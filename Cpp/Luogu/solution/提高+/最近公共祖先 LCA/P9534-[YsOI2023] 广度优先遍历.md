# [YsOI2023] 广度优先遍历

## 题目背景

Ysuperman 模板测试的图论题。

【数据删除】

## 题目描述

今天的模板测试是无向图上的广度优先遍历，【数据删除】马上写好了代码：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
using namespace std;
const int maxn = 100005;
vector<int> G[maxn];
queue<int> q;
int pa[maxn];
int main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; ++i)
    {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    memset(pa, -1, sizeof pa);
    q.push(1);
    pa[1] = 0;
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        for (auto v : G[u])
        {
            if (pa[v] != -1)
                continue;
            pa[v] = u;
            q.push(v);
        }
    }
    for (int i = 1; i <= n; ++i)
    {
        cout << pa[i];
        if (i != n)
            cout << " ";
    }
    cout << endl;
    return 0;
}
```

如你所见，这份代码会输入一个 $n$ 个点 $m$ 条边的无向图，并且求出这张图以 $1$ 为根的一棵“广度优先遍历树”，最后输出所有点的父亲节点编号。

不过值得注意的是，这棵“广度优先遍历树”的具体形态和“边的输入顺序”有关，也就是说，不同的输入顺序可能会得到不同的父亲节点编号。

现在【数据删除】告诉了你 $n,m$、这 $m$ 条边以及在某个“边输入顺序”情况下他的代码的输出，你需要还原出这个“边输入顺序”。如果有多种边输入顺序对应的都是这样的输出，你**只需要输出其中任意一种**即可。

特别的，保证有解，且无向图连通，无自环（但是有可能有重边）。

## 说明/提示

#### 样例 1 解释

直接运行【数据删除】的代码即可。

如果不改变边输入顺序，将下面数据输入【数据删除】的代码：

```
4 4
2 1
1 3
2 4
4 3
```

他的代码跑出来结果如下：

```
0 1 1 2
```

如果按照样例 1 输出给出的顺序，即，将下面数据输入他的代码：

```
4 4
1 3
3 4
1 2
2 4
```

输出为：

```
0 1 1 3
```

#### 数据范围

对于前 $10\%$ 的数据，满足 $n\le 8$，$m\le 10$。

对于前 $40\%$ 的数据，满足 $n\le 1000$，$m\le 2000$。

另有 $10\%$ 的数据，满足 $m=n-1$。

对于 $100\%$ 的数据，满足 $1\le n\le 10^5$，$1\le m\le 2\times 10^5$。

#### 提示

为什么有可能会有重边，因为懒得去重了，这个家伙出图论题就是懒得判重边的（）

附件下发了本题 checker。

## 样例 #1

### 输入

```
4 4
2 1
1 3
2 4
4 3
0 1 1 3```

### 输出

```
1 3
3 4
1 2
2 4
```

## 样例 #2

### 输入

```
8 9
7 8
6 1
5 4
7 1
4 1
3 7
2 6
7 5
2 4
0 6 7 1 4 1 1 7```

### 输出

```
6 2
7 3
4 5
1 6
7 8
1 4
1 7
2 4
5 7```

# 题解

## 作者：xiaolilsq (赞：26)

已经把以 $1$ 为根的 bfs 树给定了，那么对于原图中的一条非树边，如果它连接的是深度相同的节点那么这条边无所谓，因为无论如何它都不会成为树边，如果它连接的是深度不同的节点，那么必然连接的是相邻两层节点，否则无解，不妨设连接的是 $u,v$，且 $u$ 在 $v$ 的上一层，且 $w$ 是 $v$ 的父亲，$u,v$ 的 lca 是 $z$，其中 $z$ 往下靠近 $u$ 的是 $1$ 号边，而靠近 $v$ 的是 $2$ 号边，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/4dlep19b.png)

那么这其实说明 $v$ 这个点被 $w$ 给“抢”掉了，或者说 $w$ 应该在队列中排在 $u$ 的前面，进一步而言就是 $2$ 号边应该在 $1$ 号边的前面，并且容易发现这是充要的。

对于所有这样的非树边都有一个这样的偏序关系，找到一个拓扑序输出即可。

---

## 作者：WilliamFranklin (赞：8)

这道题我在赛时最后 5 分钟，终于做出来了，第一次进了前 $50$ 名（实际第 $41$ 名）！

为了纪念，特此发这题题解。

### 主要思路

首先发现，题目中的代码是用 vector 存图的，经常用 vector 的都知道，遍历边的时候，是按输入的顺序。

相信我们的第一直觉就是再建一个树，每一个节点都向他的父亲节点（题中的）连一条边。然后，我们再考虑，因为这个题保证有解，所以当这个点在图中不是被自己的父亲节点最先遍历到的话，那一定是与它父亲节点深度同样的节点遍历到。由此，我们就只需要保证这个点的父亲节点比其他连向这个点并且深度与它父亲节点相同的节点早遍历到即可。这种性质一定是可以延续到叶子节点的。由此，我们直接在叶子节点中找关系，这样我们就可以确定下来每一条从根节点到叶子节点的链被遍历到的顺序。

关于如果找叶子节点间的关系，我们可以这样：首先叶子节点 $i$ 开始向上遍历，一直中当前节点的父亲节点，直到走到根节点为止。假设当前遍历到的点为 $j$，找出在原图上有那些与它相连且深度等于它父亲节点的点 $k$，那么我们发现，为了让 $j$ 先被自己的父亲节点遍历到，那么这个 $i$ 就必须要在 $j$ 与 $k$ 的最近公共祖先的下一层包含 $k$ 的儿子的子树中的叶子节点之前遍历到。可以证明，最后这样就可以满足了从 $i$ 到根节点的链上的点都满足了最先被自己的父亲节点遍历到的要求。由此，我们可以让 $i$ 向 $j$ 与 $k$ 的最近公共祖先的下一层包含 $k$ 的儿子的子树中的叶子节点都连一条有向边，最后跑一边拓扑，就可以保证每一个点都是先被它的父亲节点遍历到的。

也许在跑拓扑的时候，你认为可能有环，但别忘了，这题可是保证有解的啊！

对于怎么连边，具体看代码。

说的可能不太清楚，看看代码吧！

### AC Code

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 5;

int n, m;
int x[N * 2], y[N * 2];
int fa[N];
int in[N];
vector<int> G;
int minn[N];
int h[N], ne[N * 4], e[N * 4], idx;
int f[N][30];
int dep[N];
map<pair<int, int> , int> mp;
bool vis[N];
int in1[N];
vector<int> V[N];
vector<int> GG[N];

void add(int a, int b) {
	ne[idx] = h[a], e[idx] = b, h[a] = idx++;
}

void dfs(int x) {
	f[x][0] = fa[x];
	if (!in[x]) {
		GG[x].push_back(x);
		return;
	}
	
	for (int i = h[x]; ~i; i = ne[i]) {
		int j = e[i];
		if (j == fa[x]) continue;
		dep[j] = dep[x] + 1;
		dfs(j);
		for (int k = 0; k < GG[j].size(); k++) {
			GG[x].push_back(GG[j][k]);
		}
	}
	
	return;
}

int lca(int x, int y) {
	bool g = 0;
	if (dep[x] < dep[y]) swap(x, y), g = 1;
	for (int i = 25; i >= 0; i--) {
		if ((1 << i) <= dep[x] - dep[y]) {
			x = f[x][i];
		}
	}
	
	for (int i = 25; i >= 0; i--) {
		if (f[x][i] != f[y][i]) {
			x = f[x][i];
			y = f[y][i];
		}
	}
	
	if (g) return y;
	else return x;
}

void tp() {
	queue<int> q;
	
	for (int i = 1; i <= n; i++) {
		if (!in1[i] && !in[i]) {
			vis[i] = 1;
			q.push(i);
		}
	}
	
	while (q.size()) {
		int t = q.front();
		//cout << t << endl;
		q.pop();
		int x = t;
		//cout << x << ' ' << fa[x] << ",,," << endl;
		while (fa[x]) {
			cout << fa[x] << ' ' << x << endl;
			mp[make_pair(fa[x], x)] = 1;
			mp[make_pair(x, fa[x])] = 1;
			x = fa[x];
			if (vis[x]) break;
			vis[x] = 1;
		}
		
		for (int i = h[t]; ~i; i = ne[i]) {
			int j = e[i];
			
			in1[j]--;
			
			if (!in1[j] && !vis[j]) {
				vis[j] = 1;
				q.push(j);
			}
		}
	}
}

int main() {
	memset(h, -1, sizeof(h));
	
	cin >> n >> m;
	
	for (int i = 1; i <= m; i++) {
		cin >> x[i] >> y[i];
		V[x[i]].push_back(y[i]);
		V[y[i]].push_back(x[i]);
	}
	for (int i = 1; i <= n; i++) {
		cin >> fa[i];
		in[fa[i]]++;
		add(fa[i], i);
		add(i, fa[i]);
	}
	
	memset(minn, 0x3f3f3f3f, sizeof(minn));
	dep[0] = -1;
	dfs(1);
	
	for (int i = 1; i <= 26; i++) {
		for (int j = 1; j <= n; j++) {
			f[j][i] = f[f[j][i - 1]][i - 1];
		}
	}
	
	memset(h, -1, sizeof(h));
	idx = 0;
	
	for (int i = 1; i <= n; i++) {
		if (!in[i]) {
			for (int k = 0; k < V[i].size(); k++) {
				int j = V[i][k];
				
				if (dep[j] == dep[fa[i]] && j != fa[i]) {
					int father = lca(j, fa[i]);
					//cout << i << ' ' << father << '.' << endl;
					for (int l = 0; l < GG[father].size(); l++) {
						add(i, GG[father][l]);
						in1[GG[father][l]]++;
					}
				}
			}
		}
	}
	
	tp();
	
	for (int i = 1; i <= m; i++) {
		if (mp[make_pair(x[i], y[i])]) {
			mp[make_pair(x[i], y[i])] = mp[make_pair(y[i], x[i])] = 0;
		} else {
			cout << x[i] << ' ' << y[i] << endl;
		}
	}
	
	return 0;
}
```

可（yi）能（ding）会有些不足，请大佬指正，谢谢！

---

## 作者：RsCb (赞：6)

考虑原图中没有被这棵树选上的边。

**情况一：没有被选上的边连接的两个结点在树上的深度差为 $2$ 或更多。**

![](https://cdn.luogu.com.cn/upload/image_hosting/37tcivr8.png)

这种情况并不会出现。由 BFS 的性质可得，“广度优先遍历树”中结点的深度等于原图中这个结点到根结点的距离。观察可得，这种情况并不满足这个性质。

**情况二：没有被选上的边连接的两个结点在树上的深度差为 $0$。**

![](https://cdn.luogu.com.cn/upload/image_hosting/uc36gpiu.png)

这种情况的边无论什么输入顺序都不会被选上。由上一段所述的性质可得，无论如何变换边的输入顺序，结点的深度都不变。因此，这样的边连接的两结点的深度永远相等。如果这个边被选上成为树边，那么两结点的深度就相差 $1$，矛盾，故它永远无法被选上。

因此，我们只需考虑最后一种情况。

**情况三：没有被选上的边连接的两个结点在树上的深度差为 $1$。**

![](https://cdn.luogu.com.cn/upload/image_hosting/sy6zbmg3.png)

设该边连接的结点中，深度较小的为 $u'$，较大的为 $v$，设 $v$ 的父亲为 $u$。$u,u',v$ 在上图中分别对应结点 $4,8,6$。设结点 $u$ 的第 $i$ 代祖宗为 $\mathrm{anc}_{u,i}$。边 $(u,v)$ 被选上而边 $(u', v)$ 没有，说明 $u$ 先于 $u'$ 被访问，说明 $\mathrm{anc}_{u,1}$ 先于 $\mathrm{anc}_{u',1}$ 被访问，说明 $\mathrm{anc}_{u,2}$ 先于 $\mathrm{anc}_{u',2}$ 被访问……以此类推，我们得到 $\mathrm{anc}_{u,k}$ 先于 $\mathrm{anc}_{u',k}$ 被访问，其中 $\mathrm{anc}_{u,k}$ 与 $\mathrm{anc}_{u',k}$ 有相同的父亲。$\mathrm{anc}_{u,k}$ 与 $\mathrm{anc}_{u',k}$ 父亲相同，而 $\mathrm{anc}_{u,k}$ 先被访问，说明边 $(\mathrm{anc}_{u,k+1},\mathrm{anc}_{u,k})$ 的输入先于边 $(\mathrm{anc}_{u,k+1},\mathrm{anc}_{u',k})$。

由此，我们知道了一条情况三的边代表了祖先上的某两条边的先后顺序。现在我们只需找到所有情况三的边，并算出它代表的两边先后顺序，根据这些先后顺序求得所有边的顺序。

要找到这些边，DFS 即可。

要算出它代表的两边先后顺序，使用类似求 LCA 的算法。

要根据这些先后顺序求得所有边的顺序，可以使用拓扑排序。将边看作 DAG 上的结点，先后顺序转化为有向边，再在得到的 DAG 上拓扑排序得到的就是答案。

**请注意：可能有重边。**

以下是代码：

```cpp
#include<bits/stdc++.h>
const int N = 1e5+7;
const int M = 2e5+7;
int n, m;
std::pair<int, int> e[M];
std::vector<int> g[N];
std::vector<int> t[N];
std::vector<int> dag[M];
std::pair<int, int> edge(int u, int v){
    if(u > v) std::swap(u, v);
    return std::make_pair(u, v);
}
int lb(int u, int v){
    return std::lower_bound(e+1, e+m+1, edge(u, v)) - e;
}
int ub(int u, int v){
    return std::upper_bound(e+1, e+m+1, edge(u, v)) - e;
}
int lg[N], d[N], anc[N][20];
void dfs0(int u, int fa){
    d[u] = d[fa] + 1;
    anc[u][0] = fa;
    for(int i=1; i<=lg[d[u]]+1; i++)
        anc[u][i] = anc[anc[u][i-1]][i-1];
    for(int v: t[u])
        dfs0(v, u);
}
void exlca(int& x, int& y){
    for(int i=lg[d[x]]; i; i--)
        if(anc[x][i] != anc[y][i])
            x = anc[x][i], y = anc[y][i];
}
void dfs1(int u, int fa){
    for(int v: g[u]) if(v != fa){
        if(d[v] && d[v] == d[fa]){
            int pre = fa, nxt = v;
            exlca(pre, nxt);
            int pl = lb(pre, anc[pre][0]),
                pu = ub(pre, anc[pre][0]),
                nl = lb(nxt, anc[nxt][0]),
                nu = ub(nxt, anc[nxt][0]);
            for(int i=pl; i<pu; i++)
                for(int j=nl; j<nu; j++)
                    dag[i].push_back(j);
        }
    }
    for(int v: t[u])
        dfs1(v, u);
}
int ans[M];
int in[M];
void topo(){
    int cnt = 0;
    for(int i=1; i<=m; i++)
        for(int j: dag[i])
            in[j]++;
    int flg = true;
    while(flg){
        flg = false;
        for(int i=1; i<=m; i++)
            if(!in[i]){
                flg = true;
                in[i]--;
                ans[++cnt] = i;
                for(int j: dag[i])
                    in[j]--;
            }
    }
    assert(cnt == m);
}
int main(){
    scanf("%d%d", &n, &m);
    for(int i=2; i<=n; i++)
        lg[i] = lg[i>>1] + 1;
    for(int i=1; i<=m; i++){
        int u, v; scanf("%d%d", &u, &v);
        e[i] = edge(u, v);
        g[u].push_back(v); g[v].push_back(u);
    }
    std::sort(e+1, e+m+1);
    for(int i=1; i<=n; i++){
        int f; scanf("%d", &f);
        t[f].push_back(i);
    }
    dfs0(1, 0); dfs1(1, 0); topo();
    for(int i=1; i<=m; i++)
        printf("%d %d\n", e[ans[i]].first, e[ans[i]].second);
    return 0;
}
```


---

## 作者：PNNNN (赞：5)

思路：

1. 先把题目给出的 bfs 树建出来，并预处理出每个点的深度以及倍增的 $f$ 数组以求 lca。

2. 我们可以发现，有一些点在原图中可以从多条路径到达，就好比样例 $1$ 中的点 $4$：

![1](https://cdn.luogu.com.cn/upload/image_hosting/fd62evvi.png)

而在输入中 $4$ 的父亲是 $3$，所以我们要让一些边排在另一些边之后。

那具体是要把哪一些边排在哪一些边之后呢？在图中，$(1,2)$ 这条边要排在 $(1,3)$ 之后。

考虑到一般情况：设 $x$ 为当前点的父亲，$y$ 为另一个连向当前点且深度小于当前点的点，$k$ 为 $x$ 和 $y$ 的 lca。可以发现，为了使 $x$ 成为当前点的父亲，要使从 $y$ 向上跳 $dep[y]-dep[k]-1$ 个点后，也就是 $y$ 到 $k$ 的简单路径上深度最小但不是 $k$ 的那个点，到 $k$ 的那条边，要排在从 $x$ 向上跳 $dep[x]-dep[k]-1$ 个点后的点到 $k$ 的那条边，因为这是最近的两条可以使当前点的在 bfs 树中的父亲改变的边。这个可以自己画一下。

3. 在求出了边的先后顺序之后，我们就可以进行拓扑了，把边都拓扑一遍，边拓扑便输出。具体实现看代码。

代码：

```
#include<bits/stdc++.h>
#define mk make_pair
using namespace std;

int n,m;

int f[100005][25],dep[100005];

struct line{
	int x,y;
}lst[200005];

vector <int> to[100005],e[100005];

map <pair<int,int>,vector<pair<int,int>>> op;//存边之间的先后顺序 

map <pair<int,int>,int> in,vis,mp;//每条边的入度、是否遍历过、以及输入时出现的次数 

inline int max(int x,int y){
	return x>y?x:y;
}

inline int min(int x,int y){
	return x<y?x:y;
}

inline void dfs(int x,int last){//建树
	f[x][0]=last,dep[x]=dep[last]+1;
	for(int i=0;i<to[x].size();i++){
		int y=to[x][i];
		if(y==last)continue;
		dfs(y,x);
	}
}

inline void init(){//预处理f数组，以求lca
	dfs(1,0);
	for(int j=1;1<<j<=n;j++){
		for(int i=1;i<=n;i++){
			f[i][j]=f[f[i][j-1]][j-1];
		}
	}
	return;
}

inline int lca(int x,int y){
	if(dep[x]<dep[y])swap(x,y);
	int h=dep[x]-dep[y];
	for(int i=0;1<<i<=h;i++){
		if(h&(1<<i))x=f[x][i];
	}
	if(x==y)return x;
	for(int i=log2(n);i>=0;i--){
		if(f[x][i]!=f[y][i]){
			x=f[x][i],y=f[y][i];
		}
	}
	return f[x][0];
}

inline int jump(int x,int h){//使点x往上跳h的高度
	for(int i=0;1<<i<=h;i++){
		if(h&(1<<i))x=f[x][i];
	}
	return x;
}

inline bool cmp(int x,int y){
	return dep[x]<dep[y];
}

inline void check(int x,int last){//判断边之间的前后顺序
	for(int i=0;i<to[x].size();i++){
		int y=to[x][i];
		if(y==last)continue;
		for(int j=0;j<e[y].size();j++){
			if(dep[e[y][j]]>=dep[y])break;//因为排了序，说明后面的深度都小于等于当前点，对当前点在bfs树的父亲没有影响，可以直接跳出
			if(e[y][j]==x)continue;
			int LCA=lca(e[y][j],x),jp=jump(e[y][j],dep[e[y][j]]-dep[LCA]-1),fa=jump(x,dep[x]-dep[LCA]-1);
			op[mk(min(LCA,fa),max(LCA,fa))].push_back(mk(min(jp,LCA),max(jp,LCA)));//建拓扑的边
			in[mk(min(jp,LCA),max(jp,LCA))]++;
		}
		check(y,x);
	}
}

inline void topu(int x,int y){
	pair<int,int> tmp=mk(x,y);vis[tmp]=1;
	while(mp[tmp]>0)mp[tmp]--,cout<<x<<' '<<y<<endl;//输出
	for(int i=0;i<op[tmp].size();i++){
		pair<int,int> tmp2=op[tmp][i];in[tmp2]--;
		if(!in[tmp2])topu(tmp2.first,tmp2.second);
	}
	return;
}

inline int read(){
	register int x=0,t=0;
	static char ch=getchar();
	while(!isdigit(ch)) t|=(ch=='-'),ch=getchar();
	while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return t?-x:x;
}

signed main(){
	n=read(),m=read();
	for(int i=1;i<=m;i++){
		lst[i].x=read(),lst[i].y=read();
		e[lst[i].x].push_back(lst[i].y);
		e[lst[i].y].push_back(lst[i].x);
		mp[mk(min(lst[i].x,lst[i].y),max(lst[i].x,lst[i].y))]++;
	}
	for(int i=1;i<=n;i++){
		int x=read();
		if(i==1)continue;
		to[x].push_back(i);
	}init();
	for(int i=1;i<=n;i++)sort(e[i].begin(),e[i].end(),cmp);
   //这里要把每个点连的边按深度排序,方便判断边的前后顺序时直接跳出
	check(1,0);
	for(int i=1;i<=m;i++){
		int x=lst[i].x,y=lst[i].y;
		if(in[mk(min(x,y),max(x,y))]==0&&vis[mk(min(x,y),max(x,y))]==0){
			topu(min(x,y),max(x,y));
		}
	}
	return 0;
}
```

---

## 作者：yxzy4615 (赞：5)

提供一种严格线性的做法。

在给定“广度优先搜索树”下，对于整个图而言，所有边就可以分为树边与非树边。对于每个点，记以 $1$ 为根时的深度为 $d_i$，父亲为 $fa_i$。

对于非树边 $(u,v)\ (d_u\leq d_v)$ ，如果 $d_u=d_v$，则这条边不会影响答案。

如果 $d_u=d_v+1$，那么在同一层而言，$fa_v$ 的遍历次序一定在 $u$ 前面。

而对于整棵树而言 $fa_i$ 的遍历次序一定在 $i$ 前面。

所以我们可以对于遍历次序建一个 $\text{DAG}$ 跑拓扑排序即可，边数不超过 $m$。

时间复杂度就是严格的线性 $O(n+m)$。

### $\text{code:}$

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e5+10;
int n,m,e[N][2],fa[N],u[N],v[N],d[N],du[N],q[N],dfn[N];
vector<int>sr[N],T[N],c[N];
void dfs(int x){d[x]=d[fa[x]]+1;for(int y:sr[x]) dfs(y);}
void out(int x,int y){cout<<x<<" "<<y<<'\n';}
int main(){
    ios::sync_with_stdio(0);
    cin>>n>>m;
    for(int i=1;i<=m;i++) cin>>e[i][0]>>e[i][1];
    for(int i=1;i<=n;i++){
        cin>>fa[i],sr[fa[i]].push_back(i);
        if(i!=1) T[i].push_back(fa[i]),du[fa[i]]++;
    }
    for(int i=1;i<=m;i++){
        if(fa[e[i][0]]==e[i][1]) u[v[e[i][0]]]=-1,u[i]=1,v[e[i][0]]=i;
        if(fa[e[i][1]]==e[i][0]) u[v[e[i][1]]]=-1,u[i]=1,v[e[i][1]]=i;
    }dfs(1);
    for(int i=1;i<=m;i++){
        if(u[i]==0){
            if(d[e[i][0]]==d[e[i][1]]) continue;
            if(d[e[i][0]]<d[e[i][1]]) swap(e[i][0],e[i][1]);
            T[e[i][1]].emplace_back(fa[e[i][0]]);du[fa[e[i][0]]]++;
        }
    }
    int L=0;for(int i=1;i<=n;i++)
        if(!du[i]) dfn[i]=0,q[++L]=i;
    for(int i=1,x;i<=L;i++){
        x=q[i];for(int y:T[x]){
            dfn[y]=max(dfn[y],dfn[x]+1);
            if(!(--du[y])) q[++L]=y;
        }
    }
    for(int i=2;i<=n;i++) c[dfn[i]].emplace_back(i);
    for(int i=n;i>=0;i--) for(int x:c[i]) out(x,fa[x]);
    for(int i=1;i<=m;i++) if(u[i]!=1) out(e[i][0],e[i][1]);
    return 0;
}
```

---

## 作者：robinyqc (赞：3)

一个比较简单的思路，但是根号复杂度。

首先，我们发现，把原图按照 bfs 分层，第 $i$ 层的点一定先于 $i+1$ 层的点加入。

因此，只有相同层数的边之间的顺序决定了 bfs 树的形态，不同层数的边之间的顺序无关紧要，可以一层一层求解。又注意到，假如 $p$ 的父亲是 $fa_p$，而层数小于 $p$ 的点 $q$ 与 $p$ 相连，那么，$fa_p$ 必定先于 $q$ 进入 bfs 队列。且如果同一层的两个点 $u,v$，满足 $u$ 早于 $v$ 入队，且 $fa_u\neq fa_v$，那么 $fa_u$ 早于 $fa_v$ 入队。

新建一个有向图。若同一层的 $x$ 早于 $y$ 入队，那么连一条 $x\to y$ 的有向边。由于题目保证有解，这个图一定是个 DAG。进行一个拓扑排序，就能得出答案了。

下面是重点：时间复杂度。因为上面这个做法看起来是 $O(nm)$ 的，怎么可能过呢？

首先，我们需要一个优化：假如我们已经知道了 $u$ 早于 $v$ 入队，就不需要向 $v$ 再连边了，也就是 DAG 中没有重边。这一点，可以使用 set 建图，也可以使用 vector 建图，在使用的时候使用 sort+unique 去重。尽管后一种做法对每条边要去重两次，但是 sort 的优异常数仍然比 set 更快。

因此，现在我们的复杂度就变为了必要的偏序关系数量，也就是 DAG 的边数。

具体来说，这个值大致可以表示为：

$$
\max_{1\leq s\leq n,p_1+p_2+\dots+p_s=n} \left\{\sum_{i=1}^s{\min\{{p_i}^2,m\}}\right\}
$$

一眼望去这个值是平方级别的。但是真的吗？无论怎么尝试，你肯定都构造不出一个方案卡到平方级别。这是为什么？以下是重点：

$$
\begin{aligned}
\text{证明：}&\\
\text{因为}\ &\min\{{p}^2,m\}=\sqrt{{\min}^2\{{p}^2,m\}}\leq \sqrt{\min\{{p}^2,m\}\max\{{p}^2,m\}}=\sqrt {{p}^2m}=p\sqrt m\\
\text{故 }& \max_{1\leq s\leq n,p_1+p_2+\dots+p_s=n} \left\{\sum_{i=1}^s{\min\{{p_i}^2,m\}}\right\}\leq \max_{1\leq s\leq n,p_1+p_2+\dots+p_s=n} \left\{\sum_{i=1}^s{p_i\sqrt m}\right\}=n\sqrt m\quad\blacksquare
\end{aligned}
$$

因此整个做法是根号级别的，而且卡不满。就算 sort 是 log 复杂度的，但是也能过。

下面是代码，复杂度 $O(n\sqrt m \log n)$，但是卡不满，跑得比大多数 $O(n \log n)$ 还快。

```cpp
#include<iostream>
#include<cstdio>
#include<cctype>
#include<vector>
#include<queue>
#include<cstring>
#include<algorithm>
using namespace std;
#define endl '\n'

int n,m;
vector<int> e[100005];
vector<int> f[100005];
vector<int> dag[100005];
int fa[100005],dep[100005],in[100005];
bool vis[100005];

void unique(vector<int> &v) {
    sort(v.begin(),v.end());
    v.erase(unique(v.begin(),v.end()),v.end());
}

signed main() {
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1,u,v;i<=m;i++) {
        cin>>u>>v;
        e[u].push_back(v);
        e[v].push_back(u);
    }
    for(int i=1;i<=n;i++) cin>>fa[i];
    
    // bfs 分层
    queue<pair<int,int> > Q;
    Q.push({1,0});
    vis[1]=1;
    while(!Q.empty()) {
        auto p=Q.front(); Q.pop();
        f[p.second].push_back(p.first);
        dep[p.first]=p.second;
        for(int to:e[p.first]) {
            if(!vis[to]) {
                vis[to]=1;
                Q.push({to,p.second+1});
            }
        }
    }
    
    // 建立 DAG
    for(int d=n;d>=1;d--) {
        for(int p:f[d]) {
            unique(dag[p]);
            for(int to:e[p]) if(to!=fa[p]&&dep[to]<dep[p]) {
                dag[fa[p]].push_back(to);
            }
            for(int gt:dag[p]) if(fa[p]!=fa[gt]) dag[fa[p]].push_back(fa[gt]);
        }
    }
    
    // 拓扑排序，得出答案
    memset(vis,0,sizeof(vis));
    for(int i=1;i<=n;i++) for(int gt:dag[i]) in[gt]++;
    queue<int> T;
    for(int i=1;i<=n;i++) if(in[i]==0) T.push(i);
    vector<pair<int,int> > ans;
    ans.reserve(m);
    while(!T.empty()) {
        int nw=T.front(); T.pop();
        for(int to:e[nw]) if(dep[to]<dep[nw]) ans.push_back({to,nw});
        for(int to:dag[nw]) {
            in[to]--;
            if(in[to]==0) T.push(to);
        }
    }
    
    // 特别处理横向边
    for(int i=1;i<=n;i++) for(int to:e[i]) if(to<i&&dep[to]==dep[i])
        ans.push_back({to,i});

    for(auto p:ans) cout<<p.first<<' '<<p.second<<endl;
    return 0;
}
```

---

## 作者：Dream_poetry (赞：2)

### 闲话：

首先感谢亲爱的变量名打错让我被硬控一个点。

另外我貌似恰好是第 $404$ 个通过该题的蒟蒻，特来庆祝，写篇题解。

### 思路：

首先容易发现，如果一个点只会被一个点指向，那肯定就没必要特别安排这条边的顺序。

所以我们考虑一个点被多个点到达的情况。

我们已知这个点的父亲节点 $fa$，和一个指向该点的 $x$，显然只有当 $fa$ 和 $x$ 在同一层上我们会进行如下操作。

为了使我们当前该点能够使得它最终的父亲是 $fa$，我们肯定是希望先将 $fa$ 点入队列再让 $x$ 点入队列的。

所以我们找到两者的最近公共祖先的下一层，即最浅的一层使 $f_{fa,k}$ 不等于 $f_{x,k}$，记此时 $f_{x,k}$ 为 $l$，我们要将当前点与 $l$ 子树内的所有叶子节点连边，表示输出 $f_{fa,k}$ 子树内的边的顺序先于输出 $f_{x,k}$ 子树内的顺序，以备拓扑排序。

为什么是叶子节点呢？因为我们这样可以直接从叶子节点向上跳并且输出，直到一个已被访问的节点。

一个子树内的叶子结点可在进行 LCA 预处理时求出。

进行完上述操作后，我们就可以开始拓扑排序了，边拓扑排序边输出树边内的边的顺序。

最后输出非树边的顺序即可。

注：为防止重边，还需要开一个 map 来进行判断。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m;
vector<int>z[100005];
int fa[100005];
int out[100005];
int in[100005];


inline void add(int x,int y){
	z[x].push_back(y);
}

struct node{
	int x,y;
}edge[200005];
int tot;
int he[100005];
struct Node{
	int nex,to;
}e[400005];
inline void Add(int x,int y){
	e[++tot].nex=he[x];
	e[tot].to=y;
	he[x]=tot;
}

int f[100005][25];
int dep[100005];


vector<int> zz[100005];


inline void dfs(int x){
	f[x][0]=fa[x];
	for (int k=1;k<=20;k++){
		f[x][k]=f[f[x][k-1]][k-1];
	}
	if (!out[x]){
		zz[x].push_back(x);
		return;		
	}
	for (int i=he[x];i;i=e[i].nex){
		int v=e[i].to;
		if (v!=fa[x]){
			dep[v]=dep[x]+1;
			dfs(v);
			for (int j=0;j<zz[v].size();j++){
				zz[x].push_back(zz[v][j]);
			}	
		}
	}
}



inline int lca(int x, int y){
	int flag=0;
	if (dep[x]<=dep[y]){
		swap(x,y);
		flag=1;
	}
	for (int k=20;k>=0;k--) {
		if (dep[f[x][k]]>=dep[y]){
			x=f[x][k];
		}
	}
	for (int k=20;k>=0;k--){
		if (f[x][k]!=f[y][k]){
			x=f[x][k];
			y=f[y][k];
		}
	}	
	if (flag){
		return y;
	}
	return x;
}

int vis[100005];
map<pair<int,int>,bool>V;


inline void topsort(){
	queue<int>q;
	for (int i=1;i<=n;i++){
		if (!in[i] && !out[i]){
			q.push(i);
			vis[i]=1;
		}
	}
	while (q.size()){
		int x=q.front();
		q.pop();
		int w=x;
		while (fa[x]){
			cout<<fa[x]<<' '<<x<<"\n";
			V[make_pair(fa[x],x)]=1;
			V[make_pair(x,fa[x])]=1;
			x=fa[x];
			if (vis[x]) break;
			vis[x]=1;
		}
		for (int i=he[w];i;i=e[i].nex){
			int v=e[i].to;
			in[v]--;
			if (!in[v] && !vis[v]){
				vis[v]=1;
				q.push(v);	
			}
		}
	}
}

signed main(){
	cin>>n>>m;
	for (int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		edge[i]=(node){x,y};
		add(x,y);
		add(y,x);
	} 
	
	for (int i=1;i<=n;i++){
		cin>>fa[i];
		out[fa[i]]++;
		Add(fa[i],i);
		Add(i,fa[i]);
	}
	dfs(1);
	
	memset(he,0,sizeof(he));
	tot=0;
	for (int x=1;x<=n;x++){
		if (!out[x]){
			for (int i=0;i<z[x].size();i++){
				int v=z[x][i];
				if (v!=fa[x] && dep[v]==dep[fa[x]]){
					int l=lca(v,fa[x]);
					for (int j=0;j<zz[l].size();j++){
						Add(x,zz[l][j]);
						in[zz[l][j]]++;
					}
				}
			}
		}
	}
	topsort();
	for (int i=1;i<=m;i++){
		if (V[make_pair(edge[i].x,edge[i].y)]){
			V[make_pair(edge[i].x,edge[i].y)]=0;
			V[make_pair(edge[i].y,edge[i].x)]=0;
		}
		else{
			cout<<edge[i].x<<" "<<edge[i].y<<"\n";
		}
	}
	return 0;
}
```

---

## 作者：Hanghang (赞：2)

好题。

首先考虑到对于任意的边的输入顺序，分层图是不会变的，即所有点到根的最短距离不变。

那么分为两种边，分别为不同层的边相连，相同层的边相连。

显然第二种边是无用的，我们将其放到最后输出即可。

由于下层的决策会影响上层的决策而且不同层之间的边的顺序不会影响答案，所以我们按分层图从大到小处理。

不妨设当前层为 $t$，那么上一层为 $t-1$，对于连接不同层的边，层数大的儿子，小的为父亲,节点 $x$ 的真父亲是 $ba_x$，$t-1$ 到 $t$ 的边的顺序只有两种因素决定：$t$ 层的点的相对顺序，以及 $t$ 层的点 $x$ 所有父亲的相对关系。

对于第一种情况，显然对于每个点都要被真父亲选走，所以 $ba_x$ 要在其他父亲之前。

对于第二种情况，一种暴力的做法是枚举 $t$ 层任意两点 $x,y$，如果 $x$ 要在 $y$ 之前，那么 $ba_x$ 也一定要在 $ba_y$之前。

由于答案一定存在，那么每一层的相对关系一定由多个 DAG 组成，我们对每个点赋值 $p$，那么如果 $x$ 在 $y$ 之前，那么 $p_x$ 一定比 $p_y$ 小。

这里存在一个问题，有可能对于两个不同 DAG 的点，$p$ 值也会存在一个相对关系，但在原图中这是没有的，所以我们要再建立并查集，维护每个 DAG 里面的节点。

那么我们对同层的边排序的时候，先考虑并查集祖先，然后考虑父亲的权值，再考虑儿子的权值。

考虑优化，发现此题的瓶颈在于要枚举 $t$ 层的任意两点来推出 $ba_x$ 的相对关系。

由于题目保证存在答案，那么我们可以想办法直接继承儿子的权值 $p$。

那么我们可以直接继承所有儿子里面最小的权值，那么我们对于任意值大于 $p$ 的点且在同一并查集祖先的都可以直接得到相对顺序。

那这样就做完了。复杂度 $O(n+m \log m)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
 
typedef long long ll;
typedef pair<int,int> pii;
const int N=1e6+3;
int n,m,k,dep[N],f[N],p[N],ba[N],in[N];
vector<int>ve[N],pos[N],g[N];
vector<pii>res[N];
bool v[N],vis[N];
struct Nod{int x,y;}a[N];
int F(int x){return f[x]==x?x:f[x]=F(f[x]);}
#define fi first
#define se second
bool Cmp(pii a,pii b)
{
    if(F(a.fi)==F(b.fi))
    {
        if(p[a.fi]!=p[b.fi])return p[a.fi]<p[b.fi];
        return p[a.se]<p[b.se];
    }
    return F(a.fi)<F(b.fi);
}
void Bfs()
{
    queue<int>q;q.push(1);memset(dep,-1,sizeof(dep));dep[1]=1;
    while(!q.empty())
    {
        int x=q.front();q.pop();
        for(int y:ve[x])if(dep[y]==-1)dep[y]=dep[x]+1,q.push(y);
    }
    for(int i=1;i<=n;i++)pos[dep[i]].push_back(i),k=max(k,dep[i]);
}
int main()
{
    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1,x,y;i<=m;i++)cin>>x>>y,ve[x].push_back(y),ve[y].push_back(x);
    for(int i=1;i<=n;i++)cin>>ba[i],f[i]=i;
    Bfs();
    for(int t=k;t>1;t--)
    {
        for(int x:pos[t])p[ba[x]]=!p[ba[x]]?p[x]:min(p[ba[x]],p[x]),f[F(ba[x])]=F(x);
        for(int x:pos[t])for(int y:ve[x])if(dep[y]==t-1&&y!=ba[x])
            g[ba[x]].push_back(y),in[y]++,f[F(y)]=F(ba[x]);
        queue<int>q;
        for(int x:pos[t-1])if(!in[x])q.push(x),v[x]=1;
        while(!q.empty())
        {
            int x=q.front();q.pop();
            for(int y:g[x])if(!v[y])
            {
                p[y]=max(p[y],p[x]+1);
                if(!(--in[y]))q.push(y),v[y]=1;
            }
        }
        for(int x:pos[t])for(int y:ve[x])if(dep[y]==t-1)
            res[t-1].push_back(make_pair(y,x));
        sort(res[t-1].begin(),res[t-1].end(),Cmp);
    }
    for(int i=1;i<k;i++)for(int j=0;j<res[i].size();j++)
        cout<<res[i][j].fi<<" "<<res[i][j].se<<endl;
    for(int t=1;t<=k;t++)for(int x:pos[t])for(int y:ve[x])
        if(dep[y]==t&&x<y)cout<<x<<" "<<y<<endl;
    return 0;
}
```

有任何疑惑欢迎与我交流。

---

## 作者：clarkwang (赞：2)

## 问题转化

题目中给定了每个节点的父亲节点，容易想到这些边应该优先选择。

我们对这些可以建一棵树，对这个树进行一个遍历，但直接遍历存在一些问题：我们不知道如何遍历才能得到正确的顺序。

由此，我想到，只要顺序唯一就可以直接遍历了。

我们可以在树的基础上建一个图，跑一次拓扑排序即可。

按照排序顺序选择该点到原树上父亲节点的边，其余边再进行任意排列即可。

----

## 如何建图


观察给定代码后，我们可以这么想：

广搜第一次访问某个节点会阻碍其他的访问，我们可以类似这样，对其他的访问进行阻碍，即建一个边。

这样在拓扑排序的过程中就会确定他们访问的顺序了。

-----

但是，直接建立反边在部分图的情况下会遇到问题，比如下图：  
![](https://cdn.luogu.com.cn/upload/image_hosting/i15toidj.png)

右上角是$1$号节点，从一侧访问最下方节点时在新图上建立向另一侧的边，不能成功使从$1$号点只从该侧优先访问，而是只能同时向两侧，那排序顺序就不唯一了。

解决方案是在原树寻找公共祖先，对目标点满足是该公共祖先的深度最浅的祖先建边即可。

然后进行拓扑排序就解决了。

-----

## 其他

直接寻找祖先会超时，可以提前树剖或建好倍增的表。

-----

最后的最后...

代码如下：
```
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <queue>

using namespace std;

vector<int> G[100005];
vector<int> G2[100005];

int n, m;
int r[100001][21];
int d[100001];
int dep[100001];

struct Edge {
	int u, v;
	int f;

	Edge(int x = 0, int y = 0) {
		u = x;
		v = y;
		f = 0;
	}

	friend bool operator < (Edge A, Edge B) {
		return A.f > B.f;
	}
} E[200001];

void dfs(int u, int fa, int de) {
	dep[u] = de;
	for(int i = 1;i <= 20;i++) {
		r[u][i] = r[r[u][i - 1]][i - 1];
	}
	for(auto v : G[u]) {
		if(v == fa) continue;
		if(r[v][0] == u) {
			dfs(v, u, de + 1);
		}
	}
}

void build(int u, int fa) {
	for(auto v : G[u]) {
		if(v == fa) continue;
		if(r[v][0] == u) {
			build(v, u);
		}
	}
	G2[fa].push_back(u);
	for(auto v : G[u]) {
		if(v == fa) continue;
		if(r[v][0] != u && dep[v] < dep[u]) {
			int s = r[u][0];
			int t = v;
//			while(r[s][0] != r[t][0]) {
//				s = r[s][0];
//				t = r[t][0];
//			}
			for(int i = 20;~i;i--) {
				if(r[s][i] == 0 || r[t][i] == 0) continue;
				if(r[s][i] != r[t][i]) {
					s = r[s][i];
					t = r[t][i];
				}
			}
			G2[u].push_back(t);
			d[t]++;
		}
	}
	d[u]++;
}

int f[100001];
queue<int> q;

void solve() {
	int l = n;
	q.push(1);
	while(l > 1) {
		int u = q.front();
		q.pop();
		for(auto v : G2[u]) {
			d[v]--;
			if(!d[v]) {
				q.push(v);
				E[f[v]].f = l--;
			}
		}
	}
}

int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1;i <= m;i++) {
		int u, v;
		scanf("%d%d", &u, &v);
		E[i] = Edge(u, v);
	}
	for(int i = 1;i <= n;i++) {
		scanf("%d", &r[i][0]);
	}
	for(int i = 1;i <= m;i++) {
		G[E[i].u].push_back(E[i].v);
		G[E[i].v].push_back(E[i].u);
		if(r[E[i].u][0] == E[i].v) {
			f[E[i].u] = i;
		}
		if(r[E[i].v][0] == E[i].u) {
			f[E[i].v] = i;
		}
    }
    dfs(1, 0, 0);
    build(1, 0);
    solve();
    sort(E + 1, E + m + 1);
    for(int i = 1;i <= m;i++) {
    	printf("%d %d\n", E[i].u, E[i].v);
    }
    return 0;
}
```

-----

感谢你的阅读。

---

## 作者：Register_int (赞：2)

直接在 bfs 树上搜索。设 $dep_u$ 表示 $u$ 的深度，假设当前搜到 $u$，父亲为 $fa$，且有一个 $v$ 满足 $dep_v=dep_{fa}$，则 $u$ 就有可能被 $v$ 提前记录。因此，我们需要保证 $fa\rightarrow u$ 的这条链在队列中提前于 $v\rightarrow u$ 的这条链。

找到 $fa$ 和 $v$ 的 $\text{lca}$，$k$。显然非树边只要全部置后即可，那么影响这两条链先后的只有 $k$ 对应这两条链的边。根据这个，我们可以得到一些关于树边输出先后顺序的偏序关系，可以用拓扑排序输出。时间复杂度 $O(m\log m)$。

# AC 代码

```cpp
#include <bits/stdc++.h>

typedef long long ll;

using namespace std;

const int MAXN = 1e5 + 10;
const int MAXM = 2e5 + 10;

int n, m; map<pair<int, int>, int> mp;

vector<int> t[MAXN], g[MAXN], tp[MAXN];

int fa[MAXN][20], dep[MAXN], lg[MAXN];

void init(int u) {
	dep[u] = dep[fa[u][0]] + 1;
	for (int i = 1; i <= lg[dep[u]]; i++) fa[u][i] = fa[fa[u][i - 1]][i - 1];
	for (int v : t[u]) init(v);
}

int d[MAXN];

void solve(int u, int v) {
	for (int i = lg[dep[u]]; ~i; i--) {
		if (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
	}
	tp[u].push_back(v), d[v]++;
}

void dfs(int u, int f) {
	for (int v : g[u]) if (v != f && dep[v] == dep[f]) solve(f, v);
	for (int v : t[u]) dfs(v, u);
}

void solve() {
	queue<int> q;
	for (int i = 1; i <= n; i++) if (!d[i]) q.push(i);
	for (int u; !q.empty();) {
		u = q.front(); q.pop();
		if (fa[u][0]) {
			printf("%d %d\n", fa[u][0], u);
			mp[{ fa[u][0], u }]--, mp[{ u, fa[u][0] }]--;
		}
		for (int v : tp[u]) if (!(--d[v])) q.push(v);
	}
	for (int u = 1; u <= n; u++) {
		for (int v : g[u]) if (mp[{ u, v }]) printf("%d %d\n", u, v), mp[{ u, v }]--, mp[{ v, u }]--;
	}
}

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 2; i <= n; i++) lg[i] = lg[i >> 1] + 1;
	for (int i = 1, u, v; i <= m; i++) {
		scanf("%d%d", &u, &v);
		g[u].push_back(v), g[v].push_back(u);
		mp[{ u, v }]++, mp[{ v, u }]++;
	}
	for (int i = 1; i <= n; i++) scanf("%d", &fa[i][0]), t[fa[i][0]].push_back(i);
	init(1), dfs(1, 0), solve();
}
```

---

## 作者：mc123456 (赞：1)

## 分析

给定了一个广度优先遍历的树的情况下，我们可以对边进行分类，分成数边和非树边。容易证明非树边一定不是返祖边（即一定是横叉边），且连接的两个点在广度优先遍历树下深度之差一定小于等于 $1$。

那么我们就可以遍历每一条非树边，将其看做一个约束，即一条非树边若连接了 $u, v$（$dep_u \geq dep_v$）两个点，则：

+ 若 $dep_u = dep_v$，则这条边不起任何约束作用。

+ 若 $dep_u > dep_v$，那么在广度优先遍历中 $fa_u$ 一定比 $v$ 更先被遍历到，那么就可以从 $v$ 向 $fa_u$ 连一条边，表示 $v$ 要比 $fa_u$ 更后遍历到。

对于一条连接了 $u$ 和 $fa_u$ 的树边，同样可以看作一条限制，即 $fa_u$ 一定比 $u$ 更先被遍历到，那么可以从 $u$ 向 $fa_u$ 连一条边，表示这个限制。

然后我们在这个建出来的限制图上跑一遍拓扑排序，同时记录每个点应当被什么时候遍历到，最后按照应当被遍历到的顺序输出边即可（注意可能有重边）。

时间复杂度 $O(n + m)$。

## 代码

可能因为用哈希表记录了重边，所以跑的比较慢。

```cpp
#include <bits/stdc++.h>
#include <bits/extc++.h>
using namespace std;
using namespace __gnu_pbds;
#define endl '\n'
#define int long long
const int N = 2e5 + 10;

int n, m;
int u[N], v[N];
vector<int> g[N], buc[N], f[N];
int fa[N], dep[N], in[N], tp[N];
queue<int> q;
gp_hash_table<int, int> um;

void dfs(int x)
{
    for (auto y : f[x])
        dep[y] = dep[x] + 1, dfs(y);
}

signed main()
{
    cin.tie(0), cout.tie(0), ios::sync_with_stdio(0);
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
        cin >> u[i] >> v[i], um[u[i] * 100000ll + v[i]]++, um[v[i] * 100000ll + u[i]]++;
    for (int i = 1; i <= n; i++)
        cin >> fa[i], f[fa[i]].push_back(i), g[i].push_back(fa[i]), in[fa[i]]++;
    dfs(0);
    for (int i = 1; i <= m; i++)
        if (fa[u[i]] != v[i] && fa[v[i]] != u[i])
        {
            if (dep[u[i]] == dep[v[i]])
                continue;
            if (dep[u[i]] < dep[v[i]])
                swap(u[i], v[i]);
            g[v[i]].push_back(fa[u[i]]), in[fa[u[i]]]++; // p.s. this line can also use u[i] instead of fa[u[i]]
        }
    for (int i = 1; i <= n; i++)
        if (!in[i])
            q.push(i);
    while (!q.empty())
    {
        int x = q.front();
        q.pop();
        for (auto y : g[x])
        {
            tp[y] = max(tp[y], tp[x] + 1);
            if (!(--in[y]))
                q.push(y);
        }
    }
    for (int i = 2; i <= n; i++)
        buc[tp[i]].push_back(i);
    for (int i = n; i >= 0; i--)
        for (auto x : buc[i])
            cout << x << ' ' << fa[x] << endl, um[x * 100000ll + fa[x]]--, um[fa[x] * 100000ll + x]--;
    for (int i = 1; i <= m; i++)
        if (um[u[i] * 100000ll + v[i]])
            cout << u[i] << ' ' << v[i] << endl, um[u[i] * 100000ll + v[i]]--, um[v[i] * 100000ll + u[i]]--;
}
}
```

---

## 作者：Epoch_L (赞：1)

## Solution
我们把题目给出的 bfs 生成树的边记为树边，其他边（包括重边）记为非树边。

显然对于每条非树边 $(x,y)$，一定有 $|dep_x-dep_y|\le 1$，因为是 bfs，如果 $|dep_x-dep_y|>1$ 那肯定会先在 $x$ 处先访问到 $y$，那这条边就成了树边。

接着讨论如果 $dep_x=dep_y$，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/20bkk781.png?x-oss-process=image/resize,m_lfit,h_270,w_255)

黑边代表树边，若此时有一条非树边 $(2,3)$，会发现树边按任何顺序加都行，所以这种边没用。

于是只剩一种情况，钦定 $dep_x=dep_y+1$，下图是样例 1：

![](https://cdn.luogu.com.cn/upload/image_hosting/y0vbt36z.png?x-oss-process=image/resize,m_lfit,h_270,w_255)

为了不访问先访问到 $(2,4)$ 这条边，$3$ 号点就要先拓展，所以 $(1,3)$ 这条边就要比 $(1,2)$ 这条边先加入。

树边我们就按照如上先后顺序输出，其它边任意。具体的，对树边建有向图，然后拓扑排序输出。

如何找到有限制的边，考虑倍增 lca 的过程，在最后 $x,y$ 分别跳到 lca 往各自方向上的第一个点，对照上图就是 $3$ 和 $2$，我们只需要记录每个节点往父亲节点的边编号即可。

有一个问题就是树边的重边，跳 lca 时是一个父子关系，直接会跳到同一点，如果仍按上文方式建图，就会建出一个自环，拓扑排序时就没有输出。事实上，树边的重边没有影响，直接跳过即可。否则你就会 80/90 pts。

显然，如果要判是否有解，只需要判断有向图是否有环即可。

## Code
实现有一点丑，用了两个 map，常数挺大的，最大点 545ms。

```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
#define pb emplace_back
#define push emplace
#define mkp make_pair
using namespace std;
using ll=long long;
using pii=pair<int,int>;
using pll=pair<ll,ll>;
using ull=unsigned long long;
bool Mbe;
inline void read(int &x){
  char ch=getchar();
  int r=0,w=1;
  while(!isdigit(ch))w=ch=='-'?-1:1,ch=getchar();
  while(isdigit(ch))r=(r<<1)+(r<<3)+(ch^48),ch=getchar();
  x=r*w;
}
const int N=2e5+7;
map<pii,int>mp,tr;
vector<int>edge[N],e[N];
int n,m,x[N],y[N];
int f[N][18],dep[N],in[N],faid[N];
bool ok[N];
void dfs(int u,int fa){
  dep[u]=dep[fa]+1;
  f[u][0]=fa;
  for(int i=1;i<=17;i++)f[u][i]=f[f[u][i-1]][i-1];
  for(int v:edge[u])dfs(v,u);
}
void lca(int u,int v){
  if(dep[u]<dep[v])swap(u,v);
  u=f[u][0];//这里深度一定差 1，不需要再去枚举
  for(int i=17;i>=0;i--)if(f[u][i]!=f[v][i])u=f[u][i],v=f[v][i];
  e[faid[u]].pb(faid[v]);in[faid[v]]++;//建有向图
}
queue<int>q;
void topsort(){
  for(int i=1;i<=m;i++)if(ok[i]&&!in[i])q.push(i);
  while(!q.empty()){
    int u=q.front();q.pop();
    printf("%d %d\n",x[u],y[u]);
    for(int v:e[u])if(--in[v]==0)q.push(v);
  }
  for(int i=1;i<=m;i++)if(!ok[i])printf("%d %d\n",x[i],y[i]);
}
void solve(){
  read(n);read(m);
  for(int i=1;i<=m;i++){
    read(x[i]),read(y[i]);
    mp[mkp(x[i],y[i])]=i;
    mp[mkp(y[i],x[i])]=i;
  }
  for(int i=1,x;i<=n;i++){
    read(x);
    if(i==1)continue;
    faid[i]=mp[mkp(x,i)];//往父亲的边编号
    tr[mkp(x,i)]=tr[mkp(i,x)]=1;//标记为树边
    ok[mp[mkp(x,i)]]=1;
    edge[x].pb(i);
  }
  dfs(1,0);
  for(int i=1;i<=m;i++)
    if(!ok[i]&&dep[x[i]]!=dep[y[i]]){//非树边且深度不等
      if(tr.count(mkp(x[i],y[i])))continue;//不是树边的重边
      lca(x[i],y[i]);
    }
  topsort();
}

bool Med;
int main(){
  fprintf(stderr,"%.3lf MB\n",(&Med-&Mbe)/1048576.0);
  int T=1;
  while(T--)solve();
  cerr<<1e3*clock()/CLOCKS_PER_SEC<<" ms\n";
  return 0;
}
```

---

## 作者：irris (赞：1)

## Preface

2C 一血，但是因为重边虚空调试了 $12$ 分钟。/px

## Solution

设一条边 $w$ **导出的点** 指的是 $w$ 边两个端点中深度相对较大的那个，这相当于是 BFS 过程中被这条边松弛到的点。**导入的点** 则相反。

我们考虑把两条边 $u, v$（它们所 **导出的点相同**，且导入的点 **深度 $dep$ 相同**）**出队** 的相对顺序关系（也即 **入队** 的相对顺序关系）表示出来。

设 $u$ 是经过边 $x$ 被放进队的，$v$ 是经过边 $y$ 被放进队的（为了避免边界情况，让我们说所有由点 $1$ 引出的边是被边 $0$ 放进队的）。

+ 若 $x \neq y$，那么 $u, v$ 出队相对顺序关系等于 $u, v$ 入队相对顺序关系等于 $x, y$ 出队相对顺序关系，递归。如此类推直到 $x = y$。
+ 现在 $x = y$，那么这两条边导出的这个点相同，且是 $u, v$ 导入的点 **在 BFS 树上的 LCA**（因为我们一直在跳父亲，而它们深度相同）。这时，我们发现 $u, v$ 的相对顺序 **就是在输入的 `G` 数组中它们的相对顺序**，因为在这个相同的导入点上我们分别往队列里 push 了 $u, v$ 导出的点。

容易发现这样就解决了原问题。让我们找到所有的偏序关系：对于每个点 $a$，我们找到所有与它相邻的点 $p$ 满足 $p \neq fa_a$ 且 $dep_p = dep_{fa_a}$，这样就有一个 $fa_a$ 对应边先于 $p$ 对应边先出队的偏序关系。这总共只有 $\mathcal O(m)$ 对。

建立了在 `G` 中实际的边的出现先后关系之后，直接进行 **拓扑排序** 即可找到一组合法解。

时间复杂度 $\mathcal O(m\log m)$，瓶颈在于 `std::map` 和倍增 LCA。

## Code

```cpp
#include <bits/stdc++.h>

namespace FastIO {
	template <typename T> inline T read() { T x = 0, w = 0; char ch = getchar(); while (ch < '0' || ch > '9') w |= ch == '-', ch = getchar(); while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar(); return w ? ((~x) + 1) : x; }
	template <typename T> inline void write(T x) { x && (write<T>(x / 10), putchar(x % 10 ^ '0')); }
	template <typename T> inline void print(T x) { x || putchar('0'); x < 0 && (putchar('-'), x = (~x) + 1); write<T>(x); }
	template <typename T> inline void print(T x, char end) { x || putchar('0'); x < 0 && (putchar('-'), x = (~x) + 1); write<T>(x), putchar(end); }
}; using namespace FastIO;

const int LG = 17;
#define MAXN 100001
std::vector<int> ch[MAXN];
int fa[LG + 1][MAXN], dep[MAXN];
void dfs(int u = 1) {
	for (int j = 1; j <= LG; ++j) fa[j][u] = fa[j - 1][fa[j - 1][u]];
	for (int v : ch[u]) dep[v] = dep[u] + 1, dfs(v);
}

#define MAXM 200001
int u[MAXM], v[MAXM], prev[MAXM], deg[MAXM];
std::vector<int> out[MAXM];
std::map<std::pair<int, int>, int> id;
inline std::pair<int, int> mp(int u, int v) { return std::make_pair(std::min(u, v), std::max(u, v)); }
inline void lca_p(int u, int v) {
	for (int j = LG; ~j; --j) if (fa[j][u] != fa[j][v]) u = fa[j][u], v = fa[j][v];
	int s = fa[0][u];
	++deg[id[mp(v, s)]], out[id[mp(u, s)]].push_back(id[mp(v, s)]);
}


int main() {
	int N = read<int>(), M = read<int>();
	for (int i = 1; i <= M; ++i) {
		u[i] = read<int>(), v[i] = read<int>();
		prev[i] = id[mp(u[i], v[i])], id[mp(u[i], v[i])] = i;
	}
	for (int i = 1; i <= N; ++i) ch[fa[0][i] = read<int>()].push_back(i);
	dfs();
	for (int i = 1; i <= M; ++i) {
		if (dep[u[i]] > dep[v[i]]) std::swap(u[i], v[i]);
		if (dep[u[i]] == dep[v[i]] - 1 && fa[0][v[i]] != u[i]) 
			lca_p(fa[0][v[i]], u[i]);
	} 
	std::queue<int> Q;
	for (int i = 1; i <= M; ++i) if (deg[i] == 0 && id[mp(u[i], v[i])] == i) Q.push(i);
	while (!Q.empty()) {
		int i = Q.front(), j = i; Q.pop();
		while (j) printf("%d %d\n", u[j], v[j]), j = prev[j];
		for (int o : out[i]) if ((--deg[o]) == 0) Q.push(o);
	} 
	return 0;
}
```

---


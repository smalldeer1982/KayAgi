# 校园跑

## 题目背景

你正要进行校园跑。

## 题目描述

校园跑软件会随机生成若干个点位，共有 $m$ 种不同的点位序列，通过第 $i$ 种点位序列的所需的最小跑动距离为 $a_i$，每次获取点位生成第 $i$ 种点位序列的概率为 $p_i$。

你共有 $n$ 次获取点位的机会，每次获取点位后，你可以选择按当前点位开始跑步，也可以选择重新获取点位，如果已经没有获取点位的机会，则只能按当前点位开始跑步。

你想使自己最后跑动距离的期望尽量小，求这个最小的期望。

你的答案与标准答案的绝对误差或相对误差不超过 $10^{-4}$ 即视为正确。形式化的，如果你的答案是 $a$，评测用的标准答案为 $b$，那么你的答案会且仅会在 $\frac{|a-b|}{\max(1,|b|)}\le10^{-4}$ 的情况下通过。

## 说明/提示

$1\le T\le2\times10^5$，$1\le n,a_i\le10^9$，$1\le m,\sum m\le2\times10^5$，$1\le b_i\le10^4$。

## 样例 #1

### 输入

```
3
5 3
3 2 1
3 1 1
10 10
1 2 3 4 5 6 7 8 9 10
1 2 3 4 5 6 7 8 9 10
2 3
1 2 2
1 1 1
```

### 输出

```
1.527360
3.535155
1.444444
```

# 题解

## 作者：Falashiro (赞：4)

设 $f_{i,j}$ 表示剩余 $i$ 次获取点位的机会，当前点位最小跑动距离为 $a_j$ 时最后跑动距离的期望的最小值，设 $g_i=\sum\limits_{j=1}^mp_j\times f_{i,j}$。易知 $f_{0,i}=a_i$。
	
当 $i>0$ 时，有：

$$
\begin{aligned}
		f_{i,j}&=\min\{a_j,\sum\limits_{k=1}^mp_k\times f_{i-1,k}\}\\
        &=\min\{a_j,g_{i-1}\}
\end{aligned}
$$

我们可以将 $a$ 序列从小到大排序，则存在整数 $k\in[1,m]$，使得：

$$f_{i,j}=
\left\{
\begin{aligned}
	a_j\ (j\le k)\\
	g_{i-1}\ (j>k)
\end{aligned}
\right.
$$

于是有：

$$
\begin{aligned}
	g_i&=\sum\limits_{j=1}^mp_j\times f_{i,j}\\
	&=(\sum\limits_{j=1}^kp_j\times a_j)+(\sum\limits_{j=k+1}^mp_j)\times g_{i-1}
\end{aligned}
$$

设 $s_i=\sum_{j=1}^ip_j$，$w_i=\sum_{j=1}^ip_j\times a_j$，则：

$$
\begin{aligned}
		g_i=w_k+(1-s_k)\times g_{i-1}
\end{aligned}
$$

即：
$$
\begin{pmatrix}
	g_{i}\\
	1
\end{pmatrix}
=
\begin{pmatrix}
	1-s_k&w_k\\
	0&1
\end{pmatrix}
\begin{pmatrix}
	g_{i-1}\\
	1
\end{pmatrix}
$$

显然随着 $i$ 的增加，$g_i$ 单调不增，$k$ 单调不增，那么 $k$ 至多变化 $m-1$ 次。

对于 $k$ 相同的一段，我们可以通过矩阵快速幂以 $\Theta(\log n)$ 的时间复杂度求出一个 $g$ 的值，结合倍增，则能够以 $\Theta(\log n)$ 的时间复杂度求出最小的满足 $g_i<a_k$ 的 $i$，即下一个 $k$ 变化的分界点。而 $k$ 至多变化 $m-1$ 次，于是我们可以以 $\Theta(m\log n)$ 的时间复杂度求出 $g_n$，$g_n$ 即为最终答案。

---

## 作者：fzitb7912 (赞：0)

## 分析
考虑 DP。

定义状态函数 $f_{i,j}$ 表示前 $i$ 次机会，最后距离为 $a_j$ 时的概率。不对啊。

我们反着来呢。定义状态函数 $f_{i,j}$ 表示剩余 $i$ 次机会时，我们当前距离为 $a_j$ 最后的期望最小距离。那么我们可以选择直接跑，也可以选择随机重选，有：$f_{i,j}=\min(\sum\limits_{k=1}^{m} f_{i-1,k} p_k,a_j)$。最后答案是 $\sum\limits_{k=1}^{m}f_{n-1,k}p_k$。时间复杂度 $O(nm)$。

记 $s_i =\sum\limits_{k=1}^{m}f_{i,k}p_k$，那么 $f_{i,j}=\min(s_{i-1},a_j)$，答案为 $s_{n-1}$。注意到对于 $f_{i,j}$，变量只有 $a_j$。而我们实际上的答案和 $j$ 无关，也就是说，我们可以将 $a$ 排序。那么可以找到分割点 $k$，有：$f_{i,j}=a_j[j \le k]+s_{i-1}[j>k]$。那么 $s_i = \sum\limits_{j=1}^{k} a_jp_j +\sum\limits_{j=k+1}^{m}s_{i-1}p_j$。时间复杂度 $O(n\log m)$。

这个 $k$ 怎么找呢。好像不能直接找哦。注意到 $\sum m \le 2\times 10^5, 1 \le n \le 10^9$，而我们将 $a$ 排序之后，$f_i$ 对应的 $k$ 和 $f_{i-1}$ 对应的 $k'$ 不相等当且仅当 $k < k'$，而 $0 \le k\le m$，所以不同的 $k$ 的数量是 $O(m)$ 的。那我们是不是可以对于 $k$ 相同的 $i \in [l,r]$，跑一样的 DP。记 $sum_i =\sum\limits_{j=1}^{i}a_jp_j$，$sp_i=\sum\limits_{j=i}^{m} p_j$，也就是 $\begin{bmatrix}s_{i-1}& sum_{k}\end{bmatrix}\times \begin{bmatrix}sp_{k+1}&0\\1&1 \end{bmatrix}=\begin{bmatrix}s_{i}& sum_{k} \end{bmatrix}$。矩阵快速幂维护可以做到 $O(a^3 \log n),a=2$。那我们怎么得到相同的 $k$ 呢，直接二分就可以了。在最开始的时候可以得到一个 $k$，二分 $r$。找到最后的一个 $r$，满足 $a_{k} \le s_{r-1}$。那么 $r$ 更新 $r+1$  时候的 $k$ 就不一样了，但是一定有 $k' <k$，所以可以暴力找。时间复杂度 $O(a^3 m\log^2 n)$。算一下复杂度，你发现它又炸了。

怎么更快呢。可以直接把 $\begin{bmatrix}sp_{k+1}&0\\1&1 \end{bmatrix}^{2^{i}}$ 预处理出来。那么我们去倍增找到 $r$ 就行了。预处理的时间复杂度 $O(a^3 m \log n)$，DP 的时间复杂度 $O(a^3 m\log n)$。这样就行了。

然后这题有点精度波动（？），至少我写的倍增判定 $x \le y$ 需要给 $y$ 加个 $eps$，不然会 TLE 一个点。也许是我倍增写得有问题吧。

## 代码

```cpp
const double eps=1e-9;
const int N=2e5+10,inf=1e18;
int b[N];
struct node{
	long double a;
	long double p;
	il bool operator<(const node&b)const{
		return a<b.a;
	}
}a[N];
long double sp[N],sum[N];
int n,m;
struct Matrix{
	long double c[2][2];
};
Matrix g[N][31];

il Matrix add(Matrix a,Matrix b){
	Matrix c;
	memset(&c,0.0,sizeof(c));
	for(re int k=0;k<=1;++k)
	for(re int i=0;i<=1;++i)
	for(re int j=0;j<=1;++j) c.c[i][j]+=a.c[i][k]*b.c[k][j];
	return c;
}

il void solve(){
	n=rd,m=rd;long double s=0;
	for(re int i=1;i<=m;++i) cin>>a[i].a;
	for(re int i=1;i<=m;++i) b[i]=rd,s+=b[i]*1.0;
	for(re int i=1;i<=m;++i) a[i].p=b[i]*1.0/s;
	Matrix res;
	memset(&res,0,sizeof(res));
	s=0;
	for(re int i=1;i<=m;++i) s+=a[i].a*a[i].p;
	sort(a+1,a+m+1);
	sp[m+1]=0.0;
	for(re int i=1;i<=m;++i) sum[i]=sum[i-1]+a[i].a*a[i].p;
	for(re int i=m;i>=1;--i) sp[i]=sp[i+1]+a[i].p;
	for(re int k=0;k<=m;++k){
		g[k][0].c[0][0]=1,
		g[k][0].c[1][1]=1,
		g[k][0].c[0][1]=0,
		g[k][0].c[1][0]=0;
		Matrix f;
		memset(&f,0,sizeof(f));
		f.c[0][1]=0,
		f.c[0][0]=sp[k+1],
		f.c[1][0]=1,
		f.c[1][1]=1;
		for(re int i=1;i<31;++i){
			g[k][i]=add(g[k][i-1],f);
			f=add(f,f);
		}
	}
	int k=m;
	for(re int i=m;i>=0;--i) if(a[i].a<=s){
		k=i;break;
	}
	res.c[0][0]=s,
	res.c[0][1]=sum[k];
	int u=0;
	while(u<n-1){
		bool flag=0;
		for(re int i=30;i>=0;--i){
			if(u+(1ll<<i)>=n) continue;
			Matrix res_=add(res,g[k][i]);
			long double s_=res_.c[0][0];
			if(a[k].a-eps<=s_){
				if(i==1){
					flag=1;
				}
				res=add(res,g[k][i]);
				res=add(res,g[k][1]);
				u+=(1ll<<i);
			}
		}
		if(u+1<n){
			s=res.c[0][0];
			int k_=k; 
			for(;k>=0;--k)
			if(a[k].a<=s) break;
			++u;
			res.c[0][1]=sum[k];
			res=add(res,g[k][1]);
		}	
	}
	printf("%.10Lf\n",res.c[0][0]);
    return ;
}

```

---


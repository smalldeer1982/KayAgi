# [GCJ 2011 Qualification] GoroSort

## 题目描述

Goro 有 4 只手臂。Goro 非常强壮。你可别惹 Goro。Goro 需要对一个包含 $N$ 个不同整数的数组进行排序。算法不是 Goro 的强项，力量才是 Goro 的强项。Goro 的计划是用两只手的手指按住数组中的若干元素，然后用另外两只手狠狠地敲桌子。这样，未被固定的元素会飞到空中，被随机打乱后再落回原来的空位。

Goro 想要尽快将数组排序。如果 Goro 每次都聪明地选择要固定哪些元素，平均需要敲多少次桌子才能将给定的数组排序？Goro 用来固定数组的两只手有无限多的手指。

更具体地说，在每次敲桌子之前，Goro 可以选择数组中的任意子集元素将其固定在原位。每次可以根据之前敲桌子的结果选择不同的固定方式。每次敲桌子会将未固定的元素等概率地随机排列。每种排列出现的概率相同。

## 说明/提示

**样例解释**

在第 3 个测试用例中，一种可行的策略是先固定最左边的两个元素。元素 3 和 4 没有被固定。敲桌子后，它们有 $1/2$ 的概率变为正确顺序 $[3, 4]$，有 $1/2$ 的概率变为错误顺序 $[4, 3]$。因此，平均需要 2 次敲桌子才能将它们排好。之后，Goro 可以固定元素 3 和 4，再敲桌子直到 1 和 2 排好，平均也需要 2 次。总共期望敲桌子次数为 $2 + 2 = 4$。

**数据范围**

- $1 \leq T \leq 100$；
- 每组测试数据的第二行为 $N$ 个最小正整数的一个排列。

**小数据范围（10 分，测试点 1 - 可见）**

- $1 \leq N \leq 10$；
- 时间限制：~~30~~ 3 秒。

**大数据范围（20 分，测试点 2 - 隐藏）**

- $1 \leq N \leq 1000$；
- 时间限制：~~60~~ 6 秒。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3
2
2 1
3
1 3 2
4
2 1 4 3```

### 输出

```
Case #1: 2.000000
Case #2: 2.000000
Case #3: 4.000000```

# 题解

## 作者：Aamumatematiikka (赞：2)

### 题目描述

有一个长度为 $n$ 的排列，我们每次操作可以让其中一部分随机重拍，求在最优的操作情况下期望需要的操作数。

### 思路

我们可以把这个排列分为若干组，其中每一组中的每一个元素应该呆在的位置都在自己组内，并且这个组尽可能的小，我们每次只操作这个组内的数，不会出现组外的数落入导致出现过多不可能的情况，这样让成功的概率尽可能得大。所以我们需要先找出这样的组。

我们可以通过每个数去遍历，找到当前位置目前在的数的目标位置，通过判重标记循环，从而找到最小的组。

对于大小不超过 $1$ 的组，每个元素都在自己的目标位置，所以期望操作次数为 $0$。

对于大小超过 $1$ 的组，我们观察样例不难发现需要的期望操作次数为这个组的大小，所以期望操作次数就是大小超过 $1$ 的组的总大小，换句话说就是不在自己顺序排列位置上的元素个数。

### 代码

```cpp
#include <iostream>
#include <cstring>
using namespace std;
typedef long long ll;
const int N=1005;
int T, n, a[N], ans=0;
int main(){
	scanf("%d",&T);
	for(int q=1;q<=T;q++){
		scanf("%d",&n);
		for(int i=1;i<=n;i++) scanf("%d",&a[i]);
		ans=0;
		for(int i=1;i<=n;i++) if(a[i]==i) ans++;
		printf("Case #%d: %.6lf\n",q,(n-ans)*1.0);
	}
	return 0;
}
```

这篇代码中，每次询问只需要扫一遍，所以总复杂度为 $\mathcal{O}(Tn)$，可以通过这道题。

---


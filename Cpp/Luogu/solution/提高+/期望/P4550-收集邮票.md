# 收集邮票

## 题目描述

有 $n$ 种不同的邮票，皮皮想收集所有种类的邮票。唯一的收集方法是到同学凡凡那里购买，每次只能买一张，并且买到的邮票究竟是 $n$ 种邮票中的哪一种是等概率的，概率均为 $1/n$。但是由于凡凡也很喜欢邮票，所以皮皮购买第 $k$ 次邮票需要支付 $k$ 元钱。

现在皮皮手中没有邮票，皮皮想知道自己得到所有种类的邮票需要花费的钱数目的期望。

## 样例 #1

### 输入

```
3```

### 输出

```
21.25```

# 题解

## 作者：League丶翎 (赞：143)

#### 概率题是真的仙
## Solution
用$f[i]$表示现在取到$i$张邮票,要取完剩下邮票的期望次数
显然$f[n]=0$
现在已经取得$i$张邮票,所以下一次取邮票有$\frac{i}{n}$的概率取到已经有的,期望为$\frac{i}{n}*f[i]$
有$\frac{n-i}{n}$的概率取到没有的,期望为$\frac{n-i}{n}*f[i+1]$,这次取邮票的期望为1,所以总期望为:
$$f[i]=\frac{i}{n}*f[i]+\frac{n-i}{n}*f[i+1]+1$$
化简可得:$f[i]=f[i+1]+\frac{n}{n-i}$

用$g[i]$表示现在取到$i$张邮票,要取完剩下邮票的期望价格
显然$g[n]=0$
现在已经取得$i$张邮票,所以下一次取邮票有$\frac{i}{n}$的概率取到已经有的,期望为$\frac{i}{n}*(g[i]+f[i]+1)$,有$\frac{n-i}{n}$的概率取到没有的,期望为$\frac{n-i}{n}*(g[i+1]+f[i+1]+1)$所以总期望为:
$$g[i]=\frac{i}{n}*(g[i]+f[i]+1)+\frac{n-i}{n}*(g[i+1]+f[i+1]+1)$$
化简可得:$g[i]=\frac{i}{n-i}*f[i]+g[i+1]+f[i+1]+\frac{n}{n-i}$

前面的推导貌似很自然的样子,但是为啥$g[i]$的推导式看着就那么奇怪呢?
那是因为式子的结构表示的是每次都将后面取到的邮票费用+1(总费用+f[i]),再加上自己的费用(+1)
这样就很好理解了

为啥不是$f[0]*(f[0]+1)/2*n$我也想了很久
因为推导过来每次的贡献是不相同的
比如说所有情况中有1次需要取2张,1次需要取3张,那么总贡献为$(3+6)/2=4.5$,而期望次数为2.5,显然是不对的...

代码比思考简单多了
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
double f[10005],g[10005];
int main() {
	scanf("%d",&n);
	for(int i=n-1;~i;--i) {
		f[i]=f[i+1]+(1.0*n)/(1.0*(n-i));
		g[i]=(1.0*i)/(1.0*(n-i))*(f[i]+1)+g[i+1]+f[i+1]+1;
	}
	printf("%.2lf\n",g[0]);
	return 0;
}
```

---

## 作者：__gcd (赞：83)

Update:2020.2.1 发出题解的第二天


------------


初学期望DP，有问题请指出

* 定义状态

众所周知，期望DP的定义状态一般都为**已经……还需要……的期望**

由于本题需要求的就是

*自己得到所有种类的邮票需要花费的钱数目的期望。*

那么我们就可以定义一个 $ans$ ，它的意义是：

$ans(i)$：已经收集到了 $i$ 种邮票，还需要花费的钱数的期望。

但是题目中有一个条件

*皮皮购买第k张邮票需要支付k元钱*

这意味着购买价格是与购买次数有关的。

所以我们还需要定义一个状态 $num$ ，它的意义是：

$num(i)$：已经收集到了 $i$ 种邮票，还需要购买的次数的期望。

* 初始化：$num(n)=0$，$ans(n)=0$

这个应该不需要我讲吧qwq

* 状态转移

首先吧这个写在前面

期望公式：$E(X)=\sum p_{i}\cdot x_{i}$ ，其中 $p_i$ 是事件 $i$ 发生的概率，$x_i$ 是权值。

发现 $num$ 的转移是比较简单的，先考虑 $num$。有以下两种情况：

* 买到之前买到过的邮票种类，此时 $x=num(i)+1$（种类总数不变），$p=\dfrac {i}{n}$

* 买到之前没有买到过的，此时 $x=num(i+1)+1$（总种类数量+1），$p=\dfrac {n-i}{n}$

注：以上的 $x$ 指的是**次数**。

根据公式，我们就可以得到关于 $num$ 的公式：

$$num(i)=(num(i)+1)\times\dfrac {i}{n}+(num(i+1)+1)\times\dfrac {n-i}{n}$$

化简之后得到状态转移方程：

$$num(i)=\dfrac{num(i+1)\times\dfrac {n-i}{n}+1}{1-\dfrac {i}{n}}$$

得到 $num$ 后，我们再思考 $ans$ 的转移，同样是以上的两种情况

* 买到之前买到过的邮票种类：此时 $x=ans(i)+num(i)+1$（种类+1，总花费=之前花费+本次花费），$p=\dfrac {i}{n}$

* 买到之前没有买到过的，此时 $x=ans(i+1)+num(i+1)+1$（同上），$p=\dfrac {n-i}{n}$

然后我们又轻松地得到了关于 $ans$ 的公式：

$$ans(i)=(ans(i)+num(i)+1)\times\dfrac {i}{n}+(ans(i+1)+num(i+1)+1)\times\dfrac {n-i}{n}$$

~~请自行化简~~

既然我们有了转移方程，那就开写呗

```cpp
num[n] = 0; ans[n] = 0;
for(int i = n - 1; i >= 0; i--)
{
	double p1 = frac(i, n), p2 = frac(n - i, n);
	num[i] = (p2 * num[i + 1] + 1) / (1 - p1);
	ans[i] = (ans[i + 1] * p2 + num[i] * p1 + num[i + 1] * p2 + 1) / (1 - p1);
}
cout << fixed << setprecision(2) << ans[0];
```

注：以上的 $frac(x,y)$ 表示 $\dfrac{x}{y}$

~~以上就是中心代码~~

但是这篇题解并没有完，题解中的几个细节还没有完善~~别急着抄代码啊~~

* Q：为什么要在次数和价格的计算过程中 $+1$

A：在天数的过程中， $num(i)$ 和 $num(i+1)$ 其实计算的是**前一次购买的期望次数**，如果要转化为这一次，还需要在次数上 $+1$ 才可以。同样地，$ans(i)+num(i+1)$ 与 $ans(i+1)+num(i+1)$ 这两个价格也只是**前一次购买的总价格**，而每次购买，**邮票的价值都会根据次数的增长将价格 $+1$**，所以最终计算，还需要 $+1$ 才可以。

* Q：为什么要倒序循环

A：正序循环也是可以的，只需要将状态“已经……还需要……的期望”改成“……需要……的期望”即可，大家不妨去推导试试。

end.

---

## 作者：YoOXiii (赞：49)

关于一个对期望一无所知的蒟蒻A这题的心路历程

首先不管价格 只考虑买邮票次数的期望

对于总共n张邮票 手里有i张邮票，下一次买到新邮票的概率为(n-i)/n,买的次数期望即为其倒数n/(n-i)。

然后我们把价格给他考虑进去，可以发现对于第i张邮票，为了获得它的平均价格是购买前i张邮票的期望次数之和 把每一次的价格和次数的期望乘一下累计到答案里面就行了

于是这样沙雕的分析就帮我们水掉了一个期望DP（滑稽

代码如下

```
#include <cstdio>

inline int read() {
	int x=0,f=1;
	char cr=getchar();
	while (cr>'9' || cr<'0') {
		if (cr=='-') f=-1;
		cr=getchar();
	}
	while (cr>='0' && cr<='9') {
		x=(x<<3)+(x<<1)+cr-'0';
		cr=getchar();
	}
	return x*f;
}

using namespace std;

const int maxn=30005;

double ans[maxn],sum[maxn];

int main() {
	int n=read();
	for (int i=1;i<=n;i++) ans[i]=ans[i-1]+1.0*n/(n-i+1),sum[i]=sum[i-1]+ans[i]*1.0*n/(n-i+1);
	printf("%.2lf\n",sum[n]);
}
```


---

## 作者：枫林晚 (赞：46)

博客园地址：https://www.cnblogs.com/Miracevin/p/9392318.html
 
### 题解：

k张k元不好做，先考虑每张都是1元怎么做。

设f[i]表示，已经有了i种，买到n种的期望步数，也就是期望花费。

f[i]=(i/n)*(f[i]+1) + (n-i)/n*(f[i+1]+1)  ;   ( i<n)

f[n]=0;

就是说，i/n的概率买到之前买过的邮票，(n-i)/n的概率买到新的邮票。

期望=概率X结果。理解上就是，这样的概率i/n,(n-i)/n，到达了这样的结果。就可以推出来了。

 

因为这个f数组，可以表示期望的步数，非常有用。以下讲解继续沿用。

然后，对于k张k元的情况，有两种做法：

 

（都要通过    期望=概率*事件的结果取值   来理解）

 
### ①（理解麻烦，过程简单）

设g[i]表示，从有了i种有邮票到买到n种邮票要花的钱数。

f[i]还和上面的一样。

所以，g[i]的转移是：

g[i]=i/n(g[i]+f[i]+1)+(n-i)/n(g[i+1]+f[i+1]+1)

g[n]=0;

比较难以理解。

解释：

i/n是买到自己原来买过的概率。

该种情况下，到达的结果是，还要有的g[i]花费，并且，之后期望还要买的f[i]次价格都上涨了1，总体加了f[i]，再加上这次的1花费。

为什么可以认为，这一次是第一次买，花费是1呢？？

我们在状态中，默认已经有了i张（从天上掉下来的，不花钱），所以，第一次买就是1元了。

或者，因为我们最后要求的是g[0]，

对于g[0]，第一次买花费1肯定是成立的。

所以，我们之后的所有花费，都默认第一次是1，之后计算还会加上的。

![](https://cdn.luogu.com.cn/upload/pic/30576.png)

画图理解一下，g[i]的组成，黑色部分是的g[i],红色一道是增加了总体的f[i], 绿色一个点是这次操作花费的1元。

而相邻的g[i+1]->g[i]的更新时类似的。因为都加上了一个f[i+1]么，所以g[i+1]的花费1也就变成了花费2了。

 

之后拆开括号，移项，然后直接求。

 
### ②（理解简单，过程麻烦）

发现，假设买了k张邮票，花费就是：（k^2+k）/2     ----------------等差数列求和嘛

再确切一些，设s[i]表示，有了i种邮票，到n种邮票的步数（不是期望）

所以，f[i]=E(s[i])

所以花费的期望：E(cos)=E((s[0]^2+s[0])/2)

基于期望的线性性质，E(cos)=(   E(s[0]^2)+E(s[0])    )/2

我们已经求出了f[0]=E(s[0])

所以，要求出E(s[0]^2)   （注意，这个是平方的期望，不等于期望的平方！！）

 

设g[i]=E(s[i]^2)即从i到n步数平方的期望

因为，E((x+1）^2)=E(x^2)+2E(x)+1

所以，g[i]=i/n(E(  (s[i]+1)^2 ) +  (n-i)/n (E( (s[i+1]+1)^2 )

拆开它:g[i]=i/n ( g[i] + 2f[i] + 1 ) + ( n - i )  ( g[i+1] + 2 f[i+1] +1)

拆开括号，移项，然后直接求。

 

 
**总结：**

期望一定要小心谨慎分析，不要直觉瞎搞，设计好状态，转移。

分清楚 ： 事件，概率，结果，期望。

抓住E(x+y)=E(x)+E(y) 还有: E(x)=∑pi*xi

---

## 作者：daerwen (赞：39)

# [题解]P4550 收集邮票

## 前言

这道题真的好啊。其实这道题用倒推很简单，就是在一些理解上比较难，然后机房某巨佬问我，能用正推吗？在翻阅了关于这一道题的大部分题解之后，我发现只有寥寥几篇用到了正推，且就在下的个人感官而言，讲的比较模糊，于是有了这篇博客的诞生。

## [传送门](https://www.luogu.com.cn/problem/P4550)

## 题面描述

你要买齐 n 张邮票，每张邮票被买到的概率是 $ \large \frac{1}{n} $ ，特别的，第 k 次购买要花费 k 元。问期望花费是多少。

## 分析

我们采用正推的方法。假设 ` f[i] ` 表示买了 i 种邮票的期望购买次数，假设 ` g[i] ` 表示买了 i 种的期望花费，不难得出初始条件为 ` f[0] = g[0] = 0; `

### f[i] 的递推式

类似于 [P1291 [SHOI2002]百事世界杯之旅](https://www.luogu.com.cn/problem/P1291) ，我们不难想到，我们要求第 i 种邮票的期望购买次数，即我们已经购买了 i - 1 种邮票，对于下一张邮票，我们有 $ \large \frac{i-1}{n} $ 的几率买到已经买到的，有 $ \large \frac{n-i+1}{n} $ 的几率买到没有的。

我们再买一次，买到的期望次数是 $ \large 1*\frac{n-i+1}{n} $ 

再买两次，买到的期望次数是 $ \large 2*\frac{i-1}{n}*\frac{n-i+1}{n} $ 

再买三次，买到的期望次数是$ \large 3*(\frac{i-1}{n})^2*\frac{n-i+1}{n}$ 

$\Large \dots$ 

再买 k 次，（假设 k 为正无穷次），买到的期望次数为 $ \large k*(\frac{i-1}{n})^{k-1}*\frac{n-i+1}{n} $ 

由于期望的线性关系，我们把上面这些式子累加就是买第 i 张邮票的期望次数

即
$$
\large Ex=1*\frac{n-i+1}{n}+2*\frac{i-1}{n}*\frac{n-i+1}{n}+\dots\\
\large +k*(\frac{i-1}{n})^{k-1}*\frac{n-i+1}{n}
$$
即
$$
\large Ex=\frac{n-i+1}{n}*(1+2*\frac{i-1}{n}+\dots
\large +k*(\frac{i-1}{n})^{k-1})
$$
我们对 Ex 进行错位相减，得
$$
\frac{i-1}{n}*Ex=\frac{n-i+1}{n}*(1*\frac{i-1}{n}+2*(\frac{i-1}{n})^2+\dots
 k*(\frac{i-1}{n})^k)\\
 \frac{n-i+1}{n}*Ex=\frac{n-i+1}{n}*(1+\frac{i-1}{n}+(\frac{i-1}{n})^2+\dots
 (\frac{i-1}{n})^k)\\
Ex=(1+\frac{i-1}{n}+(\frac{i-1}{n})^2+\dots
 (\frac{i-1}{n})^k)\\
$$
看到这里，我们回忆起了等比数列求和公式

即$\large Sum=\frac{a_1-a_n*q}{1-q} (q为公比)$

带入到这里得
$$
Ex=\frac{1-(\frac{i-1}{n})^k}{1-\frac{i-1}{n}}\\
Ex=\frac{1-(\frac{i-1}{n})^k}{\frac{n-i+1}{n}}\\
$$
采用极限的思想，k 为正无穷，而 $ \large \frac{i-1}{n} $ 恒小于 1 ，所以 $\large (\frac{i-1}{n})^k$ 无限趋于 0，我们舍掉这一项，得
$$
Ex=\frac{1}{\frac{n-i+1}{n}}\\
Ex=\frac{n}{n-i+1}\\
$$
带回得
$$
\large f_i=f_{i-1}+Ex\\
\large f_i=f_{i-1}+\frac{n}{n-i+1}
$$

### g[i] 的递推式

其实我们可以感性理解一下，$\large g_i=g_{i-1}+f_i*\frac{n}{n-i+1} $ 

下面给出推导过程

我们已经买了 i - 1 种邮票，已经买了 f[i - 1] 次

我们再买一次 ，花费为 ` f[i - 1] + 1 `元，期望花费为 $ \large (f_{i-1}+1)*\frac{n-i+1}{n} $ 

我们再买一次 ，花费为 ` f[i - 1] + 1 + f[i - 1] + 2`元，期望花费为 $ \large (f_{i-1}+1+f_{i-1}+2)*\frac{n-i+1}{n}*\frac{i-1}{n}  $  

$\Large \dots$ 

再买 k 次，（假设 k 为正无穷次)，花费为

 ` f[i - 1] + 1 + f[i - 1] + 2 + ... + f[i - 1] + k`

期望花费为 

$ \large (f_{i-1}+1+f_{i-1}+2+\dots+f_{i-1}+k)*\frac{n-i+1}{n}*(\frac{i-1}{n})^{k-1} $   

同样由于期望的线性关系，我们把它们累加就是买第 i 种邮票的期望花费

即
$$
Ex=(f_{i-1}+1)*\frac{n-i+1}{n}+(f_{i-1}+1+f_{i-1}+2)*\frac{n-i+1}{n}*\frac{i-1}{n}\\
+\dots+(f_{i-1}+1+f_{i-1}+2+\dots+f_{i-1}+k)*\frac{n-i+1}{n}*(\frac{i-1}{n})^{k-1}\\
$$
把式子全部展开为
$$
Ex=\frac{n-i+1}{n}*(f_{i-1}+1)*(1+\frac{i-1}{n}+\dots +(\frac{i-1}{n})^{k-1})\\
+\frac{n-i+1}{n}*(f_{i-1}+2)*(\frac{i-1}{n}+\dots +(\frac{i-1}{n})^{k-1})\\
+\dots\\
+\frac{n-i+1}{n}*(f_{i-1}+k)*(\frac{i-1}{n})^{k-1}\\
$$
再把 f[i - 1] 全部提出来，把常数放到另一项里，即
$$
Ex=\frac{n-i+1}{n}*f_{i-1}*(1+\frac{i-1}{n}+\dots +(\frac{i-1}{n})^{k-1})\\
+\frac{n-i+1}{n}*f_{i-1}*(\frac{i-1}{n}+\dots +(\frac{i-1}{n})^{k-1})\\
+\dots\\
+\frac{n-i+1}{n}*f_{i-1}*(\frac{i-1}{n})^{k-1}\\

+\frac{n-i+1}{n}*1*(1+\frac{i-1}{n}+\dots +(\frac{i-1}{n})^{k-1})\\
+\frac{n-i+1}{n}*2*(\frac{i-1}{n}+\dots +(\frac{i-1}{n})^{k-1})\\
+\dots\\
+\frac{n-i+1}{n}*k*(\frac{i-1}{n})^{k-1}\\
$$


即
$$
Ex=\frac{n-i+1}{n}*f_{i-1}*(1+2*\frac{i-1}{n}+\dots +k*(\frac{i-1}{n})^{k-1})\\
+\frac{n-i+1}{n}*(1+(1+2)*\frac{i-1}{n}+\dots +(1+2+\dots +k)*(\frac{i-1}{n})^{k-1})\\
$$
设 
$$
Ex=S_1+S_2\\
 S_1=\frac{n-i+1}{n}*f_{i-1}*(1+2*\frac{i-1}{n}+\dots +k*(\frac{i-1}{n})^{k-1})\\
 S_2=\frac{n-i+1}{n}*(1+(1+2)*\frac{i-1}{n}+\dots (1+2+\dots +k)*(\frac{i-1}{n})^{k-1})\\
$$
我们对$S_1$ 进行错位相减
$$
\frac{i-1}{n}*S_1=\frac{n-i+1}{n}*f_{i-1}*(\frac{i-1}{n}+\dots +k*(\frac{i-1}{n})^k)\\
\frac{n-i+1}{n}*S_1=\frac{n-i+1}{n}*f_{i-1}*(\frac{i-1}{n}+\dots +(\frac{i-1}{n})^k)\\
S_1=f_{i-1}*(1+\frac{i-1}{n}+\dots +(\frac{i-1}{n})^k)\\
$$
在使用等比数列求和公式，得
$$
S_1=f_{i-1}*\frac{1-(\frac{i-1}{n})^{k+1}}{1-\frac{i-1}{n}}\\
S_1=f_{i-1}*\frac{1}{\frac{n-i+1}{n}}\\
S_1=f_{i-1}*\frac{n}{n-i+1}\\
$$
同样的，我们对 $S_2$ 错位相减，得
$$
S_2=\frac{n-i+1}{n}*(1+(1+2)*\frac{i-1}{n}+\dots (1+2+\dots +k)*(\frac{i-1}{n})^{k-1})\\
\frac{i-1}{n}*S_2=\frac{n-i+1}{n}*(\frac{i-1}{n}+\dots +(1+2+\dots +k)*(\frac{i-1}{n})^k)\\
\frac{n-i+1}{n}*S_2=\frac{n-i+1}{n}*(1+2*\frac{i-1}{n}+\dots +k*(\frac{i-1}{n})^k)\\
S_2=(1+2*\frac{i-1}{n}+\dots +k*(\frac{i-1}{n})^k)\\
\frac{i-1}{n}*S_2=(\frac{i-1}{n}+2*(\frac{i-1}{n})^2+\dots +k*(\frac{i-1}{n})^{k+1})\\
\frac{n-i+1}{n}*S_2=(1+\frac{i-1}{n}+(\frac{i-1}{n})^2+\dots +k*(\frac{i-1}{n})^{k+1})\\
S_2=\frac{n}{n-i+1}*(1+\frac{i-1}{n}+(\frac{i-1}{n})^2+\dots +k*(\frac{i-1}{n})^{k+1})\\
$$
再次应用等比数列求和公式，得
$$
S_2=(\frac{n}{n-i+1})^2
$$
我们把 $S_1$ $S_2$ 带回得
$$
Ex=f_{i-1}*\frac{n}{n-i+1}+(\frac{n}{n-i+1})^2
$$
由于我们已经求出了 f[i] 的递推式，即
$$
\large f_i=f_{i-1}+\frac{n}{n-i+1}
$$
所以
$$
\large f_{i-1}=f_i-\frac{n}{n-i+1}
$$
带入得
$$
Ex=(f_i-\frac{n}{n-i+1})*\frac{n}{n-i+1}+(\frac{n}{n-i+1})^2\\
Ex=f_i*\frac{n}{n-i+1}-(\frac{n}{n-i+1})^2+(\frac{n}{n-i+1})^2\\
Ex=f_i*\frac{n}{n-i+1}
$$
所以 g[i] 的递推式为
$$
\Large g_i=g_{i-1}+f_i*\frac{n}{n-i+1}
$$
这道题做完了

## AC代码

```c++
#include<bits/stdc++.h>
using namespace std;
int n;
double f[10005],g[10005];
signed main()
{
	scanf("%d",&n);
	g[0] = 0;
	f[0] = 0;
	for(int i = 1;i <= n;i++)
	{
	    f[i] = f[i - 1] + (n * 1.0) / (n - i + 1);
		g[i] = g[i - 1] + f[i] * n * 1.0 / (n - i + 1);
	}
	printf("%0.2lf\n",g[n]);
	return 0;	
} 
```

当然，我们发现，f[i] 仅与 f[i - 1] 有关，g[i] 仅与 g[i - 1] 和 f[i] 有关，所以我们连数组都不用打。

```c++
#include<bits/stdc++.h>
using namespace std;
int n;
double num,money;
signed main()
{
	scanf("%d",&n);
	num = 0;
	money = 0;
	for(int i = 1;i <= n;i++)
	{
	    num += (n * 1.0) / (n - i + 1);
		money += num * n * 1.0 / (n - i + 1);
	}
	printf("%0.2lf\n",money);
	return 0;	
} 
```

## 后话

这个推导过程真麻烦啊！！

比较一下正推和倒推，两者的代码难度都不打，就思维难度而言，倒推要比正推难一点，而正推几乎没有任何思维难度，主要就是看数学功底和推式子的能力，~~以及充足的耐心~~ 。

谢谢观看。

---

## 作者：totorato (赞：34)

# 收集邮票

不用数组，直接递推：

我们可以将题目这样理解以下：将每次买到一个新的邮票看成是一个在$y=x$上的点，其横坐标为这是第几张邮票。

相邻两个点的横坐标是有关系的。设第$x$个和第$x+1$个点之间的距离为$d$，则$d$服从$P(d=v)=(\frac{n-x}{x})^{d-1}(\frac{n-x}{x})$的分布。这个式子的意思是为了购买下一张邮票，前$d-1$次购买邮票没有买到新的，第$d$次买到了新的。

假设最后一个点的横坐标为$X$，我们需要求的实际上是$\sum_{i=1}^Xi$。这是一个阶梯形图形的面积。

在每个点处向右引一条平行于$x$轴的直线，将这个阶梯图形分为$N$个梯形。我们可以分别求出每个梯形面积的期望，再累加。因为每个梯形面积的期望显然不会与它的横坐标有关，只跟它是第几个有关。

对于第$x$个梯形，我们枚举其高，并分别求出它这么高的概率。即：
$$E_x=\sum_{i=1}^{\infty}(ig_{x-1}+\frac{i(i+1)}{2})\frac{x}{n}(\frac{n-x}{x})^{i-1}$$
其中$g_{x-1}$意为剩下的$x-1$张邮票期望几次买完。由于$E$与剩下邮票买完的次数是一个线性关系，所以这里可以直接求和。

那么：经过对这个式子的求和(实际上就是三次错位相减)，我们可以求出其极限：
$$E_x=\frac{ng_{x-1}}{x}+\frac{n^2}{x^2}$$
然后就是$g$的求法，显然$g_{x}=g_{x-1}+\frac{n}{x}$。这是一个经典的问题：一件事情有$p$的概率成功，求它平均第几次成功。不难算出期望第$\frac{1}{p}$次成功。

将每个$E_x$累加就是答案。

于是，代码可以简单地写成：

```cpp
#include <cstdio>
int n;
double f = 0, g = 0, p;
int main()
{
	scanf("%d", &n);
	for(int x=1; x<=n; ++x)
		p = 1.0 * n / x,
		f += (g += p) * p;
	printf("%.2lf\n", f);
	return 0;
}
```



---

## 作者：devout (赞：15)

设我们最后买了$x$张邮票，那么答案就应该是

$$\begin{matrix}\sum_{i=1}^x i\end{matrix}=\frac{x^2+x}{2}$$

所以我们需要分别维护$x$的期望和$x^2$的期望

我们用$f[i]$表示买了$i$种不同的邮票的次数的期望，$g[i]$表示买了$i$种不同的邮票的次数的平方的期望

显然，$f[0]=g[0]=0$

考虑使用$f[i]$转移$f[i+1]$

我们有$\frac{i}{n}$的可能买到一个之前买过的邮票，那么此时次数应该$+1$，同时我们还有$\frac{n-i}{n}$的可能买到一个之前没有买过的邮票，那么应该是上一次的次数$+1$，也就是说，我们可以得到这样的一个等式

$$f[i+1]=\frac{i}{n}(f[i+1]+1)+\frac{n-i}{n}(f[i]+1)$$

化简之后可以得到

$$f[i+1]=\frac{i}{n-i}+f[i]+1$$

在转移$g[i+1]$的时候，类比转移$f$的时候的等式，我们可以得到

$$g[i+1]=\frac{i}{n}(f[i+1]+1)^2+\frac{n-i}{n}(f[i]+1)^2$$

利用完全平方公式展开

$$g[i+1]=\frac{i}{n}(g[i+1]+2f[i+1]+1)+\frac{n-i}{n}(g[i]+2f[i]+1)$$

化简得

$$g[i+1]=\frac{2i}{n-i}f[i+1]+\frac{i}{n-i}+g[i]+2f[i]+1$$

我们从$0$到$n-1$进行递推就可以得到最后的答案了

```
#include <bits/stdc++.h>
using namespace std;
int n;
double f[N],g[N];
int main()
{
    scanf("%d",&n);
    f[0]=g[0]=0;
    for(int i=0;i<n;i++){
        f[i+1]=1.*i/(n-i)+f[i]+1;
        g[i+1]=2.*i/(n-i)*f[i+1]+1.*i/(n-i)+g[i]+2*f[i]+1;
    }
    printf("%.2lf\n",(f[n]+g[n])/2);
    return 0;
}
```


---

## 作者：ShineEternal (赞：15)


转载自vercont的洛谷日报




如有兴趣学习更多期望知识，请点击[这里](https://45475.blog.luogu.org/mathematical-expectation)

# 题目链接：

但这应该是个经典问题吧

和上面一道UVA题目有一点点像

行了不废话了放链接

https://www.luogu.org/problem/P4550

- 题意简叙：

n个数1~n，第k次取数需要k元，每次取数对于所有数概率均等（$\frac{1}{n}$）,问取完n个数的期望花费

---

### 分析：
**这个题意千万别理解错了，不是买到k需要k元，而是第k次买需要k元。可能是题面就模糊，但是结合一下样例和难度颜色应该也能看出来**

这道题是那题的升级版，要用到高次的期望，但输出不用那么麻烦了。

首先第一步很好转化吧，设用了x步，则花费为

$$\sum_{i=1}^{x}i=\frac{(x^2+x)}{2}$$

现在就转换成要求上式的期望。

有了前面那题的基础现在考虑起来就简单了

维护一个线性期望$a$，平方期望$f$（都是数组）

好吧再清楚地表达一下：

$a[i]$表示找完i个数之后还需要的次数的期望

$f[i]$表示找完i个数之后还需要的**次数平方**的期望

不难想到最后的答案是$\frac{a[0]+f[0]}{2}$

下面就开始考虑状态转移（dp？）

----

### 先来考虑$a[i]$

$$a[i]=?$$

#### 情况1，买到买过的

买过的是i个，概率为$\frac{i}{n}$,花费就相当于记在买到i时候的账上了（从i账上查），得到花费为$a[i]+1$

可得到式子$\frac{i}{n}(a[i]+1)$

#### 情况2，买到没买过的

没买过的是$n-i$个，概率为$\frac{n-i}{n}$,花费就相当于记在买到i+1时候的

账上了（从i+1账上查），因为当前多买了一个，得到花费为$a[i+1]+1$

可得到式子$\frac{n-i}{n}(a[i+1]+1)$

两种情况一合并，得：

$$a[i]=\frac{i}{n}(a[i]+1)+\frac{n-i}{n}(a[i+1]+1)$$

这时就发现了，推着推着出现了i+1，自然而然的想到了倒推

边界$a[n]=0$~~都得全了还买什么~~

但是这个式子固然能做，是不是麻烦了点？

那么把它化简看看能出来什么...

……&%&（）……&……&*%……&*%……*&%

一顿猛算后发现：

$$a[i]=a[i+1]+\frac{n}{n-i}$$

当然如果熟练了，直接心算都没毛病啦~~

---

### 然后考虑$f[i]$

唉有了前面osu的铺垫这还不是轻而易举？

跟推a的时候一个思路，新的或旧的，唯一就把平方拆开就行喽

$$f[i]=\frac{i}{n}(f[i]+2\times a[i]+1)+\frac{n-i}{n}(f[i+1]+2\times a[i+1]+1)$$

- 倒推
- 边界$f[n]=0$
- 可算，但麻烦
- 化简

OK既然上面讲了写式子下面就说说化简的事吧~

$$f[i]=\frac{i}{n}(f[i]+2\times a[i]+1)+\frac{n-i}{n}(f[i+1]+2\times a[i+1]+1)$$
把第一个括号拆成$f[i]$和$2\times a[i]+1$两部分

然后把$\frac{i}{n}\times f[i]$给移到左边，合并得：

$$\frac{n-i}{n}f[i]=\frac{i}{n}(2\times a[i]+1)+\frac{n-i}{n}(f[i+1]+2\times a[i+1]+1)$$

然后两边同除$\frac{n-i}{n}$

$$f[i]=\frac{i}{n-i}(2\times a[i]+1)+f[i+1]+2\times a[i+1]+1$$

就简单一些了。

代码中精度转换注意一下，不要丢失

end

### code：

```cpp
#include<cstdio>
using namespace std;
double a[10005],f[10005];
int main()
{
	int n;
	scanf("%d",&n);
	a[n]=0;
	f[n]=0;
	for(int i=n-1;i>=0;i--)
	{
		a[i]=a[i+1]+1.0*n/(n-i);
		f[i]=1.0*i/(n-i)*(2*a[i]+1)+f[i+1]+2*a[i+1]+1;
	}
	printf("%.2lf\n",(f[0]+a[0])/2);
	return 0;
} 
```


---

## 作者：bztMinamoto (赞：13)

神仙题啊……这思路到底是怎么来的……

ps：本题是第$k$次买邮票需要$k$元，而不是买的邮票标号为$k$时花费$k$元

我们设$g[i]$表示现在有$i$张，要买到$n$张的期望张数，设$P(x,i)$表示买$x$次能从$i$张买到$n$张的概率，则有$$g[i]=\sum_{x=0}^\infty x\times P(x,i)$$

然后考虑一下递推关系式，有$$g[i]=g[i+1]+\frac{n}{n-i},g[n]=0$$

于是就可以愉快的递推了

然后设$f[i][j]$表示现在有$i$张邮票，下一张邮票要花$j$元，买到$n$张的期望花费。不难发现如下的递推式$$f[i][j]=j+f[i][j+1]\times \frac{i}{n}+f[i+1][j+1]\times \frac{n-i}{i}$$

然而因为$j$可能是无限大，所以我们没办法简单的递推。

于是换一个角度思考，我们考虑在$f[i][j]$的情况下还需要买几次才能够买齐，则有$$f[i][j]=\sum_{x=0}^\infty (j+(j+1)+...+(j+x-1))\times P(x,i)$$

其中$x$表示枚举次数，小括号里是$x$次购买所需的花费

继续推$$f[i][j]=\sum_{x=0}^\infty \frac{x(2j+x-1)}{2} \times P(x,i)$$

然后把$j+1$带进去，可以得出$$f[i][j+1]-f[i][j]=\sum_{x=0}^\infty x\times P(x,i)=g[i]$$

然后再考虑一下原来的递推公式$$f[i][j]=j+f[i][j+1]\times \frac{i}{n}+f[i+1][j+1]\times \frac{n-i}{i}$$

$$f[i][j]=j+(f[i][j]+g[i])\times \frac{i}{n}+(f[i+1][j]+g[i+1])\times \frac{n-i}{i}$$

然后移项之后可得$$f[i][j]=\frac{(j+g[i]\times \frac{i}{n}+(f[i+1][j]+g[i+1])\times \frac{n-i}{i})\times n}{n-i}$$

然后考虑一下，因为答案是$f[1][0]$，所以所有$j$不等于$0$的情况对我们都没有用，于是可以把第二维省略，只考虑$j=0$的情况

$$f[i]=\frac{(j+g[i]\times \frac{i}{n}+(f[i+1]+g[i+1])\times \frac{n-i}{i})\times n}{n-i}$$

边界条件为$f[n]=0$

然后就可以直接递推了
```
//minamoto
#include<cstdio>
const int N=10005;
double f[N],g[N],m;int n;
int main(){
	scanf("%d",&n),f[n]=g[n]=0,m=n;
	for(int i=n-1;i>=0;--i) g[i]=g[i+1]+m/(m-i);
	for(int i=n-1;i>=0;--i)
	f[i]=((f[i+1]+g[i+1])*(m-i)/m+g[i]*i/m+1.0)*m/(m-i);
	printf("%.2lf\n",f[0]);
	return 0;
}
```

---

## 作者：command_block (赞：9)

深夜肝题纪念。

期望题道道都是神题,蒟蒻表示Orz。

~~感觉我的思路没有那么麻烦。~~

这道题题目描述有点模糊,并不是买第$i$种邮票需要$i$元,而是第$i$次买邮票需要$i$元。

假如皮皮花了x步收集了全部的邮票,那么花费就是$1+2+3+...+x=x(x+1)/2$(等差数列)。

化简得$(x^2+x)/2$。

我们就是要求$(x^2+x)/2$的期望。

**平方的期望不等于期望的平方。**

由于期望的线性性,可以转化为分别维护**平方的期望**与**线性期望**。

这种套路题都是要**倒推**。

设$p1[i]$为收集了$i$张邮票之后还要花费的次数的期望。$p2[i]$为收集了$i$张邮票之后还要花费的次数**平方**的期望。

易得$p1[n]=p2[n]=0$(都拿到了之后就不用收集了)

答案就是$(p2[0]+p1[0])/2$

转移:

$\Large{1.p1}$

$p1[i]=(i/n)(p1[i]+1)+(n-i)/n(p1[i+1]+1)$

这个好理解,有(i/n)的概率买到已有的,这时候花费**变**为(p1[i]+1);

有(n-i)/n的概率买到没有的,这时候花费**变**为(p1[i+1]+1);

像解一元一次含参方程一样:

$p1[i]=(i/n)(p1[i]+1)+(n-i)/n(p1[i+1]+1)$

$p1[i]=(i/n)p1[i]+(n-i)/n*p1[i+1]+1$

$(n-i)/n*p1[i]=(n-i)/n*p1[i+1]+1$

$p1[i]=p1[i+1]+n/(n-i)$

$\Large{1.p2}$

开始麻烦了。

想了解更多非线性期望套路,见[P1654 OSU!](https://www.luogu.org/problemnew/show/P1654)一题。

$p2[i]=i/n*(p2[i]+2*p1[i]+1)+(n-i)/n*(p2[i+1]+2*p1[i+1]+1)$

老样子,有(i/n)的概率买到已有的,有(n-i)/n的概率买到没有的。

前者花费**变**为(花费的次数+1)的平方的期望,因为$E((x+1)^2)=E(x^2)+2E(x)+1$,所以得$(p2[i]+2*p1[i]+1)$

同理后者花费**变**为$(p2[i+1]+2*p1[i+1]+1)$

理解了上面的式子,下面就是套路化简。

$p2[i]=i/n*(p2[i]+2*p1[i]+1)+(n-i)/n*(p2[i+1]+2*p1[i+1]+1)$

$p2[i]=i/n*p2[i]+i/n*(2*p1[i]+1)+(n-i)/n*(p2[i+1]+2*p1[i+1]+1)$

$(n-i)/n*p2[i]=i/n*(2*p1[i]+1)+(n-i)/n*(p2[i+1]+2*p1[i+1]+1)$

$p2[i]=i/(n-i)*(2*p1[i]+1)+p2[i+1]+2*p1[i+1]+1$

推完了式子之后,代码就很简单了。

Code:

```cpp
#include<cstdio>
using namespace std;
int n;
double p2[10500],p1[10500]; 
int main()
{
  scanf("%d",&n);
  p2[n]=0;p1[n]=0; 
  for (int i=n-1;i>-1;i--){
  	p1[i]=p1[i+1]+1.00*n/(n-i);
  	p2[i]=1.00*i/(n-i)*(2*p1[i]+1)+p2[i+1]+2*p1[i+1]+1;
  }printf("%.2lf",(p1[0]+p2[0])/2);
  return 0;
}
```

---

## 作者：_兰_ (赞：7)

自认为这道题是一道比较简单的扩展题……？此处采用了和别的题解思路不同的，纯概率意义上的解法。

首先考虑一个简化版问题：

> 每次随机一个$[1,n]$的整数，问期望几次能凑出所有数 

这东西我写过一个blog，现在`copy`过来：

>考虑期望的线性性，就是$E=\sum E(i)$，其中$E$为所求，$E(i)$为在已经取出$i-1$个数字时，取到第$i$个数字的期望。根据之前整理过的内容，“发生概率为$p$的事件，在期望$\frac{1}{p}$次之后会发生”，我们可以得到如下：
$$
\begin{aligned}
P(i)& =\frac{n-(i-1)}{n} \\
E(i)& =\frac{1}{P(i)}=\frac{n}{n-i+1}
\end{aligned}
$$
>然后把他们加起来就是
$$
E=\sum\frac{n}{n-i+1}=\sum\frac{n}{i}
$$

思路是自然的。然后考虑本题，需要给每次操作附加一个权值。所以本质上我们可以分开计算，$g_i$表示已经取出$i-1$个数字时，取到第$i$个数字的期望步数，$f_i$表示期望步数的`cost`。

考虑如何计算$f_i$。假设从一开始到拿完$i$进行了$p$次操作，这一次拿$i$需要$q$次操作，那么这$q$次操作的$\rm \sum cost$就是
$$
(p-q)\cdot q+q^2=pq
$$

这个原理需要编一下233.

大概就是考虑前一半是不考虑这一次拿，之前拿的次数，是要算进当前ans里的。后半部分$q^2$则是这一次拿数对彼此产生的贡献。首先是进行了$q$个操作，那么每次的贡献呢？我们考虑$q$的意义，$q$是“拿数次数的期望”，而“期望”则是所有情况的平均拿数次数，[（平均次数$\times$个数）$=$ 总次数 ]，所以对彼此的贡献可以用$q^2$来刻画。

然后就递推一下就好：

```cpp
	for (i = 1 ; i <= N ; ++ i)
		n = 1.0 * N / (N - i + 1), 
		g[i] = g[i - 1] + n, f[i] = f[i - 1] + g[i] * n ; 
	printf("%.2f", f[N])  ; 
```



---

## 作者：哈撒各一 (赞：4)

首先我们看到这道题，心里一定会想：要是每天都用一块钱就可以买到邮票就好了，这样蒟蒻我就会做了。

那么很显然的状态转移就是：

$f_{i} = f_{i+1} + \frac{n}{n-i}$

然而我们发现，这道题的邮票价格可以看做一个一次式：$f_{i} = k \times d + b$。

当它不涨价时，就是 $k=0$ 时的特殊情况，那么我们对于一般的情况下，只要在开一个数组来记录他的价格就可以了呀！

那么我们令 $g_{i}$ 表示已经有i张邮票时，下一张邮票的期望价格，而我们根据价格的定义：天数=价格。可以简单地得出g的递推方程：

$g_{i} = g_{i+1} + \frac{n}{n-i}$

所以此时我们只需要把原来方程中的 $1$ 换成  $g_i$ 就可以得出转移方程：

$f_{i} = f_{i+1} + \frac{n}{n-i} \times g_{i}$

**CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 10010
double f[N],g[N];
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	//ios::sync_with_stdio(false);
	//cin.tie(0),cout.tie(0);
	int n;
	cin>>n;
	for(int i=n-1;~i;--i){
		g[i]=g[i+1]+(1.0*n/(n-i));
		f[i]=f[i+1]+(1.0*n/(n-i))*g[i];
	}
	printf("%.2lf\n",f[0]);
	return 0;
}
```


---

## 作者：傅思维666 (赞：3)

## 题解：

一道期望DP的入门题目。对于期望DP，我们先要尝试着设置状态，思考转移。

对于期望DP。小伙伴们不太懂的可以走这边：

[浅谈期望DP](https://www.cnblogs.com/fusiwei/p/11743090.html)

期望DP先来尝试设置一下状态：

根据这道题，肯定类比先设置状态为$dp[i]$表示已经买了i种邮票，想要取完的期望钱数。转移方程是：
$$
dp[i]=\frac{i}{n}dp[i]+\frac{n-i}{n}dp[i+1]+i+1
$$
但是上面这个方程~~显然~~是不对的。

为什么呢？因为我们这个方程只考虑了期望钱数，并没有考虑期望次数。根据以上方程，我们新加的钱数默认为i+1，那样的话，整个取邮票的过程就与种数无关，而这显然是不对的。

也就是要考虑期望次数。因为钱数和期望次数有关。

设期望次数为f[i]，那么针对f[i]的转移就是我们比较熟悉的：
$$
f[i]=\frac{i}{n}f[i]+\frac{n-i}{n}f[i+1]+1
$$
即：
$$
f[i]=f[i+1]+\frac{n}{n-i}
$$
这时我们可以来考虑钱数了。

这时，每一个新状态的钱数期望就是上一个状态的钱数期望加上上一个状态的的期望次数+1。

也就是：
$$
dp[i]=\frac{i}{n}(dp[i]+f[i]+1)+\frac{n-i}{n}(dp[i+1]+f[i+1]+1)
$$
代码：

```cpp
#include<cstdio>
using namespace std;
int n;
double f[10010],dp[10010];
int main()
{
    scanf("%d",&n);
    for(int i=n-1;i>=0;i--)
        f[i]=f[i+1]+(1.0*n)/(1.0*(n-i));
    for(int i=n-1;i>=0;i--)
        dp[i]=(1.0*i/1.0*n)*dp[i]+(1.0*(n-i))/(1.0*n)*dp[i+1]+1;
    printf("%.2lf\n",dp[0]);
    return 0;
}
```


---

## 作者：BeyondStars (赞：3)

概率与期望的题，要抓住关键期望的**线性运算**。$E(X)=\sum V_iP_i$。首先预处理出f数组，f[i]表示买到i张邮票的期望购买次数(不是价格),然后抓住期望就是次数这一点，$f(i) = \frac{i}{n}f(i)+\frac{n-i}{n}(f(i+1)+1)$其中，$\frac{i}{n}$是购买到已经拥有的邮票的概率，乘上已经拥有的邮票的购买次数，算出购买的已经拥有的邮票的期望。$\frac{n-i}{n}$表示已经买到表示买到不拥有的邮票的概率，乘以买到$i+1$张邮票的次数再加上本次购买的$1$。这样$f$就处理完了。然后考虑处理$g$数组，$g(i)$表示购买了$i$张邮票，还要买到$n$张邮票的期望价格。那么显然，$g(n)=0$,然后~~想不出来~~可以写出如下表达式:$$g(i)=\frac{i}{n}(g(i)+f(i)+1)+\frac{n-i}{n}(g(i+1)+f(i+1)+1)$$含义是一样的，解释一下$(g(i)+f(i)+1)$，因为已经买了$i$张邮票，话费了$g(i)$元，购买这张邮票的价格是$f(i+1)+1$，后面也是一样的。
代码：
```cpp
#include <iostream>
#include <iomanip>
using namespace std;
const int MAXN = 10010;
double f[MAXN],g[MAXN];
int main(){
    int n;cin>>n;
    for(int i = n-1;i>=0;i--){
        f[i] = f[i+1]+double(n)/double(n-i);
        g[i] = double(i)/double(n-i)*(f[i]+1)+g[i+1]+f[i+1]+1.0;
    }
    cout.setf(ios::fixed);
    cout<<setprecision(2)<<g[0];
}
```
期望的题就是代码短

---

## 作者：过往梦魇之殇 (赞：3)

### [题目传送门](https://www.luogu.org/problemnew/show/P4550)

首先，设设$f[i]$表示取到第$i$张邮票，把剩余邮票全部去完的期望次数。
那么有$i/n$的概率取到已经取到的邮票，有$(n-i)/n$的概率取到没有取过邮票。

所以有：$f[i]=i/n*f[i]+(n-i)/n*f[i+1]$

$(n-i)/n*f[i+1]=f[i]-i/n*f[i]$

$f[i]=n/(n-i)*[(n-i)/n*f[i+1]+1]$

最终得到$f[i]=f[i+1]+1$

然后设$g[i]$表示取到第$i$张邮票，把剩余油票全部去完的期望费用。


同理，有$i/n$的概率取到已经有的邮票，有$(n-i)/n$的概率取到没有取得邮票。


所以有：$g[i]=i/n*(g[i]+f[i]+1)+(n-i)/n*(g[i+1]+f[i+1]+1)$


再合并同类项可得：


$i/n*f[i]+i/n+(n-i)/n*(g[i+1]+f[i+1]+1)=(n-i)/n*g[i]$


$g[i]=i/(n-i)*f[i]+g[i+1]+f[i+1]$


再加上费用（这样子可以使化简后的式子更加简洁）


$g[i]=i/(n-i)*(f[i]+1)+g[i+1]+f[i+1]+1$


>Finish！

~~然后就是一道简单的递推题了...~~

展示一下我丑陋的代码$qwq$：

```cpp
#include<iostream>
#include<sstream>
#include<fstream>
#include<vector>
#include<list>
#include<deque>
#include<queue>
#include<stack>
#include<map>
#include<set>
#include<bitset>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cctype>
#include<cmath>
#include<ctime>
#include<iomanip>
#include<complex>
#define re register
#define pi acos(-1.0)
#define inf 2147483640
using namespace std;
inline int read()
{
    int sum=0,negative=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')negative=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        sum=sum*10+ch-'0';
        ch=getchar();
    }
    return sum*negative;
}
inline void write(int X)
{
    if(X<0)putchar('-'),X=-X;
    if(X>=10)write(X/10);
    putchar(X%10+'0');
}
using namespace std;
const int N=10010;
double f[N],g[N],m;
int n;
int main()
{
	n=read();
	m=(double)n;
	for (int i=n-1;i>=0;i--)
	{
		double j=(double)i;
		f[i]=f[i+1]+m/(m-j);
	}
	for (int i=n-1;i>=0;i--)
	{
		double j=(double)i;
		g[i]=j/(m-j)*(f[i]+1)+g[i+1]+f[i+1]+1;
	}
	printf("%0.2lf",g[0]);
	return 0;
}
```

###### 不要白嫖！务必点赞！o(￣▽￣)o

> Thanks For Watching!

---

## 作者：Monster_Qi (赞：3)

### 解题思路

　　前几天的一道考试题。。考场上瞎猜了个结论结果莫名奇妙过了，，并不知道发生了什么，而且并不会证明这个结论$23333$。看见题解没有就想发出来请各位看一看怎么证明。。
  
  具体结论就是设$g(i)=\sum\limits_{j=1}^i\frac{\sum\limits_{k=1}^j\frac{1}{k}}{j}$，也就是$g(1)=\frac{1}{1}$，$g(2)=\frac{1}{1}+\frac{1+\frac{1}{2}}{2}$，以此类推，那么$ans=n*n*g(n)$ 。
  
### 代码
代码及其之短(雾
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int n;
double f[N],ans,sum;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		sum+=1.0/i;
		ans+=sum/i;
	}
	printf("%.2lf\n",ans*n*n);
	return 0;
}
```

---

## 作者：No_wonder (赞：2)

一道基础的期望dp而已，不过这两年noip好像有考期望的趋势，所以过来巩固一下。

期望简单来说，就是概率乘权值。比如我有一个骰子，摇到每一个面的概率都是$\frac{1}{6}$，权值分别为$1,2,3,4,5,6$,那么我摇骰子的期望值就是$\frac{1}{6}*1+\frac{1}{6}*2+\frac{1}{6}*3+\frac{1}{6}*4+\frac{1}{6}*5+\frac{1}{6}*6=3.5$

我摇骰子的期望值就是$3.5$（虽然不明白骰子六个面都是整数为什么有人期望着摇出来个$3.5$

本题也是一样，我们考虑设计$dp[i]$表示已经有了$i$张邮票，买到剩下所有$n-i$张邮票的期望次数。

下一次买的情况有买到新的和没买到新的，概率分别为$\frac{n-i}{n},\frac{i}{n}$，权值分别为$dp[i+1]+1,dp[i]+1$,并且显然有$dp[n]=0$，我们就可以列出方程。

$dp[i]=\frac{n-i}{n}*(dp[i+1]+1)+\frac{i}{n}*(dp[i]+1)$

这里的$dp$是购买次数，化简后我们就可以得到另一个美观的式子。简述化简过程就是展开右式，再把两个含$dp[i]$的合并然后同除就好了，最终得到。

$dp[i]=dp[i+1]+\frac{n}{n-i}$

然后我们考虑价格。用相似的办法设计一个$f[i]$表示已经有了$i$张邮票买到剩下所有邮票的期望价格，显然$f[n]=0$，相似的考虑买到与没买到，我们有

$f[i]=\frac{n-i}{n}*(f[i+1]+dp[i+1]+1)+\frac{i}{n}*(dp[i]+f[i]+1)$

我来给大家解释一下这个式子，有些同学可能会疑惑为什么会出现先前的购买次数。因为你买了这张邮票后，剩下的每张邮票都会贵1元，剩下的还要买$dp[i]$次，所以就要把这部分钱也加进去。

整理后，我们会得到另一个式子，过程类似，这里不再赘述。

$f[i]=\frac{i}{n-i}*dp[i]+f[i+1]+dp[i+1]+\frac{n}{n-i}$

代码中注意精度，不要混淆int 与 double

AC代码

```cpp
#include<bits/stdc++.h>
#define ri register int
using namespace std;
int n;
double dp1[10010],dp2[10010];
int main()
{
	scanf("%d",&n);
	dp1[n]=dp2[n]=0;
	for(ri i=n-1;i>=0;i--)
	{
		dp1[i]=dp1[i+1]+(double)n/(double)(n-i);
		dp2[i]=(double)i/(double)(n-i)*dp1[i]+dp2[i+1]+dp1[i+1]+(double)n/(double)(n-i);
	}
	printf("%.2lf",dp2[0]);
}
```


---

## 作者：蒟蒻wyx (赞：2)

![Zh0AGq.png](https://s2.ax1x.com/2019/07/13/Zh0AGq.png)

但是，正解更加玄妙

设$f_i$,$g_i$同上

对于一次购买，有$\frac{i - 1}{n}$的概率会选到以前选到过的邮票

**那么，就要重新选择一次$f_i$,否则从$f_{i -1}$转移过来**

于是$f_i = \frac{i - 1}{n}f_i + \frac{n - i + 1}{n}(f_{i - 1} + 1)$

乱搞$f_i = f_{i - 1} + \frac{n}{n - i + 1}$

同样的，我们也可以得到$g_i = g_{i - 1} + f_{i - 1}\frac{n}{n - i + 1}+ \frac{n ^ 2}{(n - i + 1)^2}$

代码

```
#include<bits/stdc++.h>

using namespace std;

const int mxk = 1e6;
double f[mxk], g[mxk], nn; int n;

int main() {
    cin >> n;nn = n * 1.0;
    for(int i = 1; i <= n; ++i) {
        f[i] = f[i - 1] + (nn / (nn - i * 1.0 + 1));
        g[i] = g[i - 1] + f[i - 1] *(nn / (nn - i* 1.0  + 1)) + (nn * nn / ((nn  - i* 1.0 + 1) * (nn - i* 1.0  + 1)));
    }
    printf("%.2lf\n", g[n]);
}
```

不过，我们也可以用一些小技巧

利用$f$的递推式

$g_i = g_{i - 1} + \frac{n}{n - i + 1}f_i$

```
#include<cstdio>

using namespace std;

const int mxk = 1e5 + 10;
double f, g; int n;

int main() {
    scanf("%d", &n);
    for(int i = 1; i <= n; ++i) {
        f += n * 1.0 / (n - i + 1);
        g += f * n/ (n - i + 1) ;
    }
    printf("%.2lf\n", g);
}
```



---

## 作者：yzx4188 (赞：1)

## ~~好水的紫题~~



一道概率题，只要知道了公式就能~~随随便便3ms~~过

楼上楼下的dalao们说的很清楚

设 $CS_i$ 表示现在取到第 $i$ 张邮票时，剩下邮票的期望次数，设现在有 $CS_j$

则这次取邮票的总期望值为：

 $$\large{CS_j = \frac{j * CS_i}{n}  + \frac{n - j * CS_{i+1}}{n} + 1}$$

我们再设 $JZ_i$ 表示现在取到 $i$ 张邮票，剩下邮票的期望价值设现在有 $JZ_j$

则这次取到之前没有用过的邮票的总期望值为：

$$\large{JZ_j = \frac{j * (JZ_j + CS_j + 1)}{n} + \frac{n - j * (JZ_{j + 1} + CS_{j + 1} + 1)}{n}}$$

## AC code

简短的代码：

```cpp
#include<iostream>
#include<iomanip>//fixed和setprecision的库
using namespace std;
int n;
double cs1,cs2,jz1,jz2;//不需要使用数组，因为每一个期望值在计算时都只和前面的一个期望值有关系。
int main(){
    cin>>n;
    for(int i=n-1;~i;i--){
        cs1=cs2+(1.0*n)/(1.0*(n-i));//计算期望值
        jz1=(1.0*i)/(1.0*(n-i))*(cs1+1)+jz2+cs2+1;//同上
        cs2=cs1;//将这次的期望值存进f2里，下一次循环时用
        jz2=jz1;//同上
    }
    cout<<fixed<<setprecision(2)<<jz1;//输出(记得保存两位小数啊！！！)
    return 0;
}
```

---

## 作者：Space_Gold_Trash (赞：0)

有趣的一道题

他要求如果将每次的代价都为$1$的话,这题就是个傻逼题了

但是他每次的代价是$k$

这就很烦

因为他每次的代价都不相同,会根据他的抽奖的序号改变,所以就具有搞不出转移方程

那么我们如果换种思路,预处理出他的期望价值的话会怎么样呢?

设状态$f_i$表示前$i$种邮票搞完的期望次数

那么我们可以搞出转移方程

$f_i=\frac{n-i}{n}*f_{i+1}+\frac{i}{n}*f_i+1$

化简得到

$f_i=f_{i+1}+\frac{n}{n-i}$

设状态$g_i$表示前$i$种邮票搞完的期望价值

那么我们可以搞出状态转移方程

$g_i=\frac{i}{n}(g_i+f_i+1)+\frac{n-i}{n}(f_{i+1}+g_{i+1}+1)$

化简得

$g_i=\frac{i}{n-i}*f_i+\frac{n}{n-i}+g_{i+1}+f_{i+1}$

程序

```
#include<bits/stdc++.h>
#define N 10011
using namespace std;
int n;
double f[N],g[N];
int main( ){
	scanf("%d",&n);
	int i;
	for(i=n-1;i>=0;--i){
		f[i]=f[i+1]+1.0*n/(n-i);
		g[i]=i*1.0/(n-i)*f[i]+1.0*n/(n-i)+g[i+1]+f[i+1];
	}
	printf("%.2f\n",g[0]);
}
```

---


# [1007] 梦美与线段树

## 题目背景

欢迎大家光临星象馆

这里有着无论何时永远不会消失

美丽的无穷光辉

满天的星星等候着大家的到来

## 题目描述

梦美为了研究星象馆的星星，用巨型投影机——耶拿将星星排成了一个序列，接着梦美将这个星星序列建成了一棵线段树。

这是一棵维护区间和的线段树，每个节点的权值是该节点所对应的区间中，所有星星的权值和。有的时候梦美会从这棵线段树的根节点开始在星空游历。当她要进入子节点的时候，假设左右子树对应区间的权值和分别为 $sum_l$  和 $sum_r$，当前节点的权值为 $sum_{cur}$ ，梦美会以 $\frac{sum_l}{sum_{cur}}$ 的概率进入左子树，否则进入右子树。

游历的时候，梦美会把她经过的节点的权值累加起来，现在她希望您帮她设计一个算法求出这个权值期望下是多少。

当然，如果星星都是不变的梦美会觉得很没有意思，因此她会发出一些指令，每个指令是，对下标在 $[l,r]$ 的星星，权值加上 $v$ 。不过由于馆里的工作人员全都离开了，因此没有人教梦美在线段树上维护懒标记，所以梦美的每次指令都会实时更新所有的线段树节点。

为了解决线段树写法不一的问题，此处给出梦美维护这个问题时的部分代码：
```cpp
const int N = 100010, MOD = 998244353;
int a[N], sum[N << 2];
#define lson (o << 1)
#define rson (o << 1 | 1)
void pushup(int o) {
	sum[o] = (sum[lson] + sum[rson]) % MOD;
}
void build(int o, int l, int r) {
	if (l == r) {
		sum[o] = a[l];
	} else {
		int mid = (l + r) >> 1;
		build(lson, l, mid);
		build(rson, mid + 1, r);
		pushup(o);
	}
}
void change(int o, int l, int r, int q, int v) {
	if (l == r) {
		sum[o] = (sum[o] + v) % MOD;
		return;
	}
	int mid = (l + r) >> 1;
	if (q <= mid) change(lson, l, mid, q, v);
	else change(rson, mid + 1, r, q, v);
	pushup(o);
}
void add_to_interval(int l, int r, int v) {
	for (int i = l; i <= r; i ++) {
		change(1, 1, n, i, v);
	}
}
```
其中 `a` 数组表示每个星星的权值，`sum` 数组表示每个线段树节点的权值，`add_to_interval` 函数表示一次操作。

## 说明/提示

对于 $30\%$ 的数据，保证 $1 \leq n,m\leq 100$；

对于另外 $20\%$ 的数据，满足所有操作 1 中 $l=r$；

对于 $100\%$ 的数据，保证 $1\leq n,m \leq 10^5,1 \leq a_i,v \leq 10^9,1\le l\le r\le n$。

样例答案实际是 $\frac{94}{5}$ 和 $\frac{303}{13}$。

## 样例 #1

### 输入

```
4 3
1 2 3 4
2
1 1 3 1
2```

### 输出

```
399297760
844668322```

# 题解

## 作者：zcysky (赞：10)

发现这个题还没题解就自己补了吧……

其实这个题最初的idea是我的，然后最初我是按照我去年的一个题P3924 康娜的线段树加强的，唯一的不同其实就是把等概率进入改成了按权重进入。

曾经我想过这个问题，然后还没来得及想清楚我就很菜的退役了，所以这个题等到现在才出出来……

一开始我感觉区间加对于期望的贡献是不太好算的，就打算出成区间乘（这样就是个很傻逼的题了）。然后有一天（在文化课上）闲来无事想到这个题画了一个图，猛然发现分子是都可以被约分掉的，于是这个题就变成了维护一个区间的平方和，考虑如何合并：$(a+b)^2=a^2+b^2+2ab$，对这三项分开来维护就好了。

当然我最初就是这么写的，辛辛苦苦维护完之后，一个叫做司机（mcfx）的毒瘤发现了这个题其实可以在取模之前爆掉long long，然后另一个叫做ComeIntoPower的毒瘤就顺手改了数据把我卡了。

所以把下面的代码改成__uint128就能过了。然而yfz在造数据的时候似乎没卡掉int128

所以司机和小圆强无敌！

```cpp
#include<bits/stdc++.h>
#define lson (o<<1)
#define rson (o<<1|1)
#define fi first
#define sc second
#define dbg(x) cout<<#x<<" = "<<(x)<<endl;
typedef long long ll;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef  __uint128_t ulll;
using namespace std;
const double pi=acos(-1);
const double eps=1e-6;
inline int lowbit(int x){return x&(-x);}
inline int read(){
    int f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
template<typename T> inline T max(T x,T y,T z){return max(max(x,y),z);}
template<typename T> inline T min(T x,T y,T z){return min(min(x,y),z);}
template<typename T> inline T sqr(T x){return x*x;}
template<typename T> inline void checkmax(T &x,T y){x=max(x,y);}
template<typename T> inline void checkmin(T &x,T y){x=min(x,y);}
template<typename T> inline void read(T &x){
x=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;
}
template<typename A,typename B,typename C> inline A fpow(A x,B p,C yql){
    A ans=1;
    for(;p;p>>=1,x=1LL*x*x%yql)if(p&1)ans=1LL*x*ans%yql;
    return ans;
}
struct FastIO{
    static const int S=1310720;
    int wpos;char wbuf[S];
    FastIO():wpos(0) {}
    inline int xchar(){
        static char buf[S];
        static int len=0,pos=0;
        if(pos==len)pos=0,len=fread(buf,1,S,stdin);
        if(pos==len)return -1;
        return buf[pos++];
    }
    inline int read(){
        int c=xchar(),x=0;
        while(c<=32&&~c)c=xchar();
        if(c==-1)return -1;
        for(;'0'<=c&&c<='9';c=xchar())x=x*10+c-'0';
        return x;
    }
}io;
//#define read io.read
const int N=100100;
const int yql=998244353;
inline int orzyql(int x){return x>=yql?x-yql:x;}
ulll ax[N<<2],ab[N<<2],bx[N<<2],addv[N<<2],size[N<<2],sumv[N<<2];
int n,m,a[N];
inline void merge(int o,int l,int r){
    ax[o]=orzyql(ax[lson]+ax[rson]);
    bx[o]=orzyql(bx[lson]+bx[rson]);
    ab[o]=orzyql(ab[lson]+ab[rson]);
    ax[o]=(ax[o]+1LL*(r-l+1)*(r-l+1))%yql;
    bx[o]=(bx[o]+1LL*sumv[o]*sumv[o])%yql;
    ab[o]=(ab[o]+2LL*(r-l+1)*sumv[o])%yql;
}
inline void pushup(int o,int l,int r){
    sumv[o]=orzyql(sumv[lson]+sumv[rson]);
    merge(o,l,r);
}
inline void pushdown(int o,int l,int r){
    if(!addv[o])return;
    int mid=(l+r)>>1;
    sumv[lson]=(sumv[lson]+1LL*(mid-l+1)*addv[o]%yql)%yql;
    sumv[rson]=(sumv[rson]+1LL*(r-mid)*addv[o]%yql)%yql;
    addv[lson]=orzyql(addv[lson]+addv[o]);
    addv[rson]=orzyql(addv[rson]+addv[o]);
    bx[lson]=(1LL*addv[o]*addv[o]%yql*ax[lson]+1LL*addv[o]*ab[lson]%yql+bx[lson])%yql;
    bx[rson]=(1LL*addv[o]*addv[o]%yql*ax[rson]+1LL*addv[o]*ab[rson]%yql+bx[rson])%yql;
    ab[lson]=(2LL*addv[o]*ax[lson]%yql+ab[lson])%yql;
    ab[rson]=(2LL*addv[o]*ax[rson]%yql+ab[rson])%yql;
    addv[o]=0;
}
inline void build(int o,int l,int r){
    if(l==r){
        sumv[o]=a[l];
        ax[o]=1;bx[o]=1LL*a[l]*a[l]%yql;
        ab[o]=2LL*a[l]%yql;
        return;
    }
    int mid=(l+r)>>1;
    build(lson,l,mid);
    build(rson,mid+1,r);
    pushup(o,l,r);
}
inline void optadd(int o,int l,int r,int ql,int qr,int v){
    if(ql<=l&&r<=qr){
        sumv[o]=(sumv[o]+1ll*(r-l+1)*v)%yql;
        addv[o]=orzyql(addv[o]+v);
        bx[o]=(1LL*v*v%yql*ax[o]+1LL*v*ab[o]%yql+bx[o])%yql;
        ab[o]=(2LL*v*ax[o]%yql+ab[o])%yql;
        return;
    }
    int mid=(l+r)>>1;
    pushdown(o,l,r);
    if(ql<=mid)optadd(lson,l,mid,ql,qr,v);
    if(qr>mid)optadd(rson,mid+1,r,ql,qr,v);
    pushup(o,l,r);
}
int main(){
    n=read();m=read();
    for(int i=1;i<=n;i++)a[i]=read();
    build(1,1,n);
    while(m--){
        int opt=read();
        if(opt==2)printf("%lld\n",1LL*bx[1]*fpow(sumv[1],yql-2,yql)%yql);
        else{
            int l=read(),r=read(),v=read();
            optadd(1,1,n,l,r,v);
        }
    }
}
```

---

## 作者：xzyxzy (赞：7)

# 线段树维护懒标记
对，就和题面中写的一样

经过打表、找规律或者推式子可以发现，题目要求我们动态维护$$\frac{\sum_{i=1}^{tot}val[i]^2}{totval}$$
其中tot表示线段树结点总数，val表示线段树结点的权值，totval表示序列的总和

还是考虑懒标记

对于每个点维护四个东西，$l,val,tag,v$，分别表示该点子树内$\sum len^2$、子树内$\sum lenv$，加标记，权值。其中len表示该点所统管的叶子结点个数。pushup很好做，注意pushup要更新答案

维护一个全局答案，考虑每次给区间加一个值，有两个操作需要考虑

## upd_ans
原$val^2$，现$val^2+2vallenk+len^2k^2$，于是加$lk^2+2valk$即可

这样可以把整个子树的答案都统计上

## put_tag
l不变，$v+=len×k$，$tag+=k$，$val=\sum len_i(v_i+len_ik)=val_{old}+lk$

于是就很好维护了~~不明白为什么这题上了黑~~

先看看代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#define lc now<<1
#define rc now<<1|1
#define int __int128
using namespace std;
int read()
{
    char ch=getchar();int h=0,t=1;
    while((ch>'9'||ch<'0')&&ch!='-') ch=getchar();
    if(ch=='-') t=-1,ch=getchar();
    while(ch>='0'&&ch<='9') h=h*10+ch-'0',ch=getchar();
    return h*t;
}
const int N=1e5+100,mod=998244353;
struct Que{int op,l,r,k;}A[N];
int n,m,P[N];
int ksm(int x,int k)
{
    int s=1;for(;k;k>>=1,x=x*x%mod)
                if(k&1) s=s*x%mod;return s;
}
void print(int x) {if(x>9) print(x/10);putchar(x%10+'0');}
struct Seg {int l,val,tag,v;}t[N<<2];
int tot,ans;
int f(int x) {return x*x;}
void pushup(int now,int l,int r)
{
	ans-=f(t[now].v);
	t[now].v=t[lc].v+t[rc].v;
	ans+=f(t[now].v);
	t[now].l=t[lc].l+t[rc].l+f(r-l+1);
	t[now].val=t[lc].val+t[rc].val+(r-l+1)*t[now].v;
}
void build(int now,int l,int r)
{
	if(l==r)
	{
		t[now]=(Seg){1,P[l],0,P[l]};
		tot+=P[l];ans+=f(P[l]);return;
	}
	int mid=(l+r)>>1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	pushup(now,l,r);
}
void put(int now,int l,int r,int k,int op)
{
	if(op)
	{
		ans+=2*k*t[now].val;
		ans+=k*k*t[now].l;
	}
	t[now].tag+=k;
	t[now].v+=k*(r-l+1);
	t[now].val+=t[now].l*k;
}
void pushdown(int now,int l,int mid,int r)
{
	int &s=t[now].tag;if(!s) return;
	put(lc,l,mid,s,0);put(rc,mid+1,r,s,0);s=0;
}
void Add(int now,int l,int r,int gl,int gr,int k)
{
	if(l>=gl&&r<=gr) {put(now,l,r,k,1);return;}
	int mid=(l+r)>>1;
	pushdown(now,l,mid,r);
	if(gl<=mid) Add(now<<1,l,mid,gl,gr,k);
	if(gr>mid) Add(now<<1|1,mid+1,r,gl,gr,k);
	pushup(now,l,r);
}
signed main()
{
    n=read();m=read();
    for(int i=1;i<=n;i++) P[i]=read();
    for(int i=1;i<=m;i++)
    {
        int op=read(),l=0,r=0,k=0;
        if(op==1) l=read(),r=read(),k=read();
        A[i]=(Que){op,l,r,k};
    }
	build(1,1,n);
	for(int i=1;i<=m;i++)
		if(A[i].op==2)
		{
			int fz=ans/__gcd(ans,tot);
			int fm=tot/__gcd(ans,tot);
			print(fz%mod*ksm(fm,mod-2)%mod),puts("");
		}
		else tot+=(A[i].r-A[i].l+1)*A[i].k,Add(1,1,n,A[i].l,A[i].r,A[i].k);
}
```
然后我们发现出题人设置了一个陷阱（于是把我比赛时卡成了90分）

保证答案约分后分母不是mod的倍数、

于是答案可能是$\frac{2mod}{mod}=2$，于是你边做边取模会发现分母变成了0

答案不大（$10^{32}$左右），可以用std=c++11近乎作弊的方法使用__int128，然后中间计算不再取模，就可以很好地完成这题了

最后安利一道同样是线段树的模板题：https://www.luogu.org/problemnew/show/P4247

可以来博客玩玩：https://www.cnblogs.com/xzyxzy

---

## 作者：bztMinamoto (赞：4)

我我我我我我我终于AAAAAAAA了！！！

我们来考虑概率期望原来的定义，是总收益除以总情况数

然后因为每一个节点的权值都是左右儿子权值之和，而走的概率也与权值有关

那么我们可以看做是从根节点出发走$sum[1]$次（$sum[1]$为根节点的权值），那么走到每一个节点的次数就是这一个节点的权值

那么总收益就是每一个节点被走到的次数乘上节点的权值，就是每一个节点权值的平方和。而总共走了$sum[1]$次

那么答案就是整棵子树的权值的平方和乘上$sum[1]$的逆元

问题来了，因为这是区间加和，我们得打懒标记，所以要$O(1)$在打懒标记时统计出子树里的权值平方和

只有对于需要被打懒标记的节点（也就是区间被完全包含的节点）我们需要统计答案，其他情况下直接pushup即可维护

我们考虑一下，设一个节点代表的区间长度为$l$，区间加和的值为$t$，原节点的值为$sum$，那么这个节点的权值将变为$sum+l*t$

那么平方和的增加量为$(sum+l*t)^2-sum^2=2*sum*l*t-l^2*t^2$

首先，$l^2$是很好维护的，只要记录一下子树里所有区间长度的平方和即可，这个是不变的，建树的时候就可以弄出来了

于是考虑怎么维护$sum*l$

对于每一个节点来说，区间加和之后，它的$sum$变成$sum+l*t$，那么$sum*l$变为$(sum+l*t)*l$

那么增加量就是$l^2*t$，而且$l^2$我们已经维护好了

所以每一次打完懒标记，我们都可以$O(1)$维护答案了！

然后最坑的一点是……出题人最后一个点要用高精或__int128……然后导致无数个90分……调死掉……

然而尴尬的是我比赛的时候式子少推了一步结果只有20分233333

ps:__int128编译器上过不了的，建议用洛谷IDE调，或者先写好调到90分再改成__int128
```
//minamoto
#include<bits/stdc++.h>
#define ll long long
#define add(x,y) ((x)+(y))
#define dec(x,y) ((x)-(y)<0?(x)-(y)+P:(x)-(y))
#define mul(x,y) ((I)*(x)*(y))
#define ls (p<<1)
#define rs (p<<1|1)
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline ll read(){
    #define num ch-'0'
    char ch;bool flag=0;ll res;
    while(!isdigit(ch=getc()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getc());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
const int N=500005,P=998244353;const __int128 I=1;
inline ll ksm(ll a,ll b){
    ll res=1;
    while(b){
        if(b&1) res=mul(res,a)%P;
        a=mul(a,a)%P,b>>=1;
    }
    return res;
}
__int128 sum[N<<2],len[N<<2],len_2[N<<2],ans[N<<2],tag[N<<2],xl[N<<2],a[N],n,m;
//sz子树节点个数，sum节点，ans当前子树答案 ,s子树总和 
inline void upd(int p,int l,int r){
    sum[p]=add(sum[ls],sum[rs]),ans[p]=add(add(ans[ls],ans[rs]),mul(sum[p],sum[p]));
    xl[p]=add(add(xl[ls],xl[rs]),mul((r-l+1),sum[p]));
}
void pushdown(int p,int l,int r){
    if(tag[p]){
    	int mid=(l+r)>>1;
        tag[ls]=add(tag[ls],tag[p]),tag[rs]=add(tag[rs],tag[p]);
        
        ans[ls]=add(ans[ls],mul(mul(xl[ls],2),tag[p]));
        ans[ls]=add(ans[ls],mul(mul(tag[p],tag[p]),len_2[ls]));
        
        ans[rs]=add(ans[rs],mul(mul(xl[rs],2),tag[p]));
        ans[rs]=add(ans[rs],mul(mul(tag[p],tag[p]),len_2[rs]));
        
        xl[ls]=add(xl[ls],mul(len_2[ls],tag[p]));
        xl[rs]=add(xl[rs],mul(len_2[rs],tag[p]));
        
        sum[ls]=add(sum[ls],mul(tag[p],(mid-l+1)));
        sum[rs]=add(sum[rs],mul(tag[p],(r-mid)));
        
        tag[p]=0;
    }
}
void build(int p,int l,int r){
    if(l==r){
        sum[p]=a[l],len[p]=1,len_2[p]=1,ans[p]=mul(sum[p],sum[p]),tag[p]=0,xl[p]=sum[p];
        return;
    }
    int mid=(l+r)>>1;
    build(ls,l,mid),build(rs,mid+1,r);
    len[p]=add(add(len[ls],len[rs]),(r-l+1));
    len_2[p]=add(add(len_2[ls],len_2[rs]),mul((r-l+1),(r-l+1)));
    upd(p,l,r);
}
void update(int p,int l,int r,int ql,int qr,ll val){
    if(ql<=l&&qr>=r){
        tag[p]=add(tag[p],val);
        
        ans[p]=add(ans[p],mul(mul(xl[p],2),val));
        ans[p]=add(ans[p],mul(len_2[p],mul(val,val)));
        
        xl[p]=add(xl[p],mul(len_2[p],val));
        
        sum[p]=add(sum[p],mul((r-l+1),val));
        
        return;
    }
    pushdown(p,l,r);
    int mid=(l+r)>>1;
    if(ql<=mid) update(ls,l,mid,ql,qr,val);
    if(qr>mid) update(rs,mid+1,r,ql,qr,val);
    upd(p,l,r);
}
ll calc(){
    __int128 x=ans[1],y=sum[1];
    while(y%P==0) y/=P,x/=P;
    x%=P,y%=P;
    return x*ksm(y,P-2)%P;
}
int main(){
//	freopen("testdata.in","r",stdin);
    n=read(),m=read();
    for(int i=1;i<=n;++i) a[i]=read();
    build(1,1,n);
    while(m--){
        int op=read();
        if(op==2) printf("%lld\n",calc());
        else{
            int l=read(),r=read();ll v=read();
            update(1,1,n,l,r,v);
        }
    }
    return 0;
}
```

---

## 作者：cww970329 (赞：3)

# 梦美的线段树 题解

---

题目链接[点这](https://www.luogu.org/problemnew/show/P4927)

这题有点毒瘤啊，`__int128`才能过，建议食用洛谷ide

介于前面三篇的都比较玄学（~~代码都比较丑~~）,打算自己写一发

自己写的线段树常数应该比其他几篇大一点，为了方便理解吧

首先数学期望

$$E = \sum P_i * sum_i = 一通操作 =  \frac{\sum sum_i^2}{sum_{rt}} $$

![image.png-9.9kB][1]


这一步应该比较好计算，同时相信大部分人都死在了这里~~比如我~~

然后想到这题不是线段树维护期望，而是维护区间平方和

对于一个节点

```c++
struct node{
    int sum, tag; // 常规都区间和 & 标记
    int len; 也很好理解
    
    // 然后就有些奇怪都东西了
    int len_2, len_sum, con;
};
```

`con`: contribution, 即为该节点对答案分子的贡献，$con_rt = \sum sum_i^2$

因为con比较难以一步计算出来，所以考虑一个比较容易想到(~~放屁~~)的区间平方和

$sum^2$更新时，$sum_{new}^2 = (sum_{old} + tag * len)^2 = sum_{old}^2 + 2*len * tag * sum_{old} + len^2 * tag^2$

即 `sum +=` $2*len*tag*sum_{old} + len^2*tag^2$

包含上子节点的话就是，$\sum sum^2$，也就是 `con` 了

$$\begin{align*}  
  con & += \sum (2*tag*(len*sum)) + \sum (len^2 * tag^2) \\  
 &+= 2*tag* \sum ((len*sum)) + tag^2 * \sum (len^2 )  \\  
\end{align*}  $$

![image.png-22.4kB][2]


对于难以统计的 $\sum ((len*sum))$ 和 $\sum (len^2 )$ 这里变可以单独维护，这里便是`Node`结构体里奇怪的`len_sum, len_2`，注释里标注了`include child nodes`，都是包含其子节点的。

那么考虑这两个奇怪的东西，

- $\sum (len_i^2 )$简单，建树的时候直接构造就好了
- 对于$\sum (len_i*sum_i)$
- $ \begin{align*}
\sum (len_i*sum_i)_{new} & = \sum(len_i * (sum_i + len_i*tag)) \\ 
&= \sum(len_i * sum_i + len_i^2*tag) \\
&= \sum(len_i*sum_i)_{old} + tag * \sum len_i^2
\end{align*} $

![image.png-27.7kB][3]

又回到了`len_2`

所以这里代码里对应的：

- `len_2`: $\sum len_i^2$
- `len_sum`: $\sum(len_i*sum_i)$
- `con`: $\sum sum^2$,答案的分子在`con[root]`里

这么一来，线段树部分就很清晰了，自认为自己的数学功底很差，所以推公式的时候慢慢推，让像我一样的弱智都能看得懂

本来想交一发 `long long`先来个90分的，然后发现，前90分也要`__int128`，这便是这题毒瘤的地方了。代码量到这里已经可以了，何必再爆`long long`,数据结构配高精有意思吗？有意思吗？有意思吗？据观察大家都用的`__int128`过的。

不过听郭黑康说最后一个点q是MOD的倍数（题目不是保证不是倍数的吗？？？），没遇到这个坑，也不知道是不是我写法的原因，`int128`之后`CE`了几发就过了

最后输出答案的时候，`gcd`,`power`啥的，就不说了，老生常谈了


```c++
#include <bits/stdc++.h>
using namespace std;
typedef __int128 LL;
const int N = (1e5 + 7) << 2;
const LL MOD = 998244353;

LL sqr(LL x){return x*x;}
LL gcd(LL x, LL y){
	if (y) while((x %= y) && (y %= x));
	return x + y;
}
LL power(LL a, LL x){
    LL ans = 1;
    for (; x; x >>= 1){
        if (x & 1) ans = (ans * a) % MOD;
        a = (a * a) % MOD;
    }
    return ans % MOD;
}
//------------head & math-------------

int arr[N];

struct SegTree{
    #define lc (rt << 1)
    #define rc (rt << 1 | 1)
    #define lson rt<<1, l, mid
    #define rson rt<<1|1, mid+1, r

    int n;
    // for one Node
    LL sum[N], len[N], tag[N];
    LL len_2[N], len_sum[N];  // include child nodes
    LL con[N]; // contribution, also include child nodes

    // commonly pushUp
    void pushUp(const LL &rt) {
        sum[rt] = sum[lc] + sum[rc];
        len_sum[rt] = len[rt]*sum[rt] + len_sum[lc] + len_sum[rc];
        con[rt] = sqr(sum[rt]) + con[lc] + con[rc];
    }

    void Tag(const LL &rt, const LL &l, const LL &r, const LL &v){
        sum[rt] += v * (r-l+1);
        tag[rt] += v;
        con[rt] += 2*v*len_sum[rt] + sqr(v)*len_2[rt];
        len_sum[rt] += v * len_2[rt];
    }

    void pushDown(const LL &rt, const LL &l, const LL &r){
        if (!tag[rt]) return;
        LL mid = (l+r) >> 1;
        Tag(lson, tag[rt]);
        Tag(rson, tag[rt]);
        tag[rt] = 0;
    }

    void build(const LL &rt, const LL &l, const LL &r) {
        if (l == r) {
            sum[rt] = len_sum[rt] = (LL)arr[l];
            len[rt] = len_2[rt] = 1;
            tag[rt] = 0;
            con[rt] = sqr(sum[rt]);
            return;
        }
        LL mid = (l + r) >> 1;
        build(lson);
        build(rson);
        len[rt] = len[lc] + len[rc];
        len_2[rt] = sqr(len[rt]) + len_2[lc] + len_2[rc];
        tag[rt] = 0;
        pushUp(rt);
    }

    void update(const LL &rt, const LL &l, const LL &r, const LL &L, const LL &R, const LL &v) {
        if (L <= l && r <= R) {
            Tag(rt, l, r, v);
            return;
        }
        LL mid = (l + r) >> 1;
        pushDown(rt, l, r);
        if (L <= mid) update(lson, L, R, v);
        if (mid <  R) update(rson, L, R, v);
        pushUp(rt);
    }

    void query(){ // print ans;
        LL p = con[1], q = sum[1], gd = gcd(p, q);
        p /= gd, q /= gd;
        //printf("%d, %d: ", p, q);
        LL ans = ((p%MOD) * power(q, MOD-2)) % MOD;
        printf("%lld\n", ans);
    }

    void print(LL rt, LL l, LL r){ // prLL tree, debug
        printf("%d: [%d, %d], len = %d, len_2 = %d, sum = %d, len_sum = %d, tag = %d, con = %d\n", 
            rt, l, r, len[rt], len_2[rt], sum[rt], len_sum[rt], tag[rt], con[rt]);
        if (l == r) return;
        LL mid = (l + r) >> 1;
        print(rt<<1, l, mid);
        print(rt<<1|1, mid+1, r);
    }
} T;


int main(){
    //freopen("in.txt", "r", stdin);
    int n, m;
    scanf("%d%d", &n, &m);
    for (LL i = 1; i <= n; i++){
        scanf("%d", &arr[i]);
    }
    T.build(1, 1, n);
    //T.print(1, 1, n);

    for (int op, l, r, v; m--;){
        scanf("%d", &op);
        if (op==2) T.query();
        else{ // update
            scanf("%d%d%d", &l, &r, &v);
            T.update(1, 1, n, l, r, v);
        }
    }
    return 0;
}

```


最后再扯点啥呢，自己写结构体都是把结构体当成`class`来用的，就当是全是`public`的`class`吧

`define lson, rson`也是一个令人愉悦的点，跟**kuangbing**学的

还有哪里看不懂欢迎私戳我提问或者`cww970329@qq.com`


最后打个广告，[csdn](https://blog.csdn.net/cww97), [github](https://github.com/cww97)

本稿子本来在作业部落编辑的，贴过来后发现latex有些炸了，[原来的稿子](https://www.zybuluo.com/cww97/note/1323775)

附件：
- 可能炸的公式1 ![image.png-9.9kB][1]
- 可能炸的公式1 ![image.png-22.4kB][2]
- 可能炸的公式2 ![image.png-27.7kB][3]

  [1]: http://static.zybuluo.com/cww97/sbubtgp27owr2xlmphc0r37e/image.png
  [2]: http://static.zybuluo.com/cww97/lk3ty4r505gp98cym0nf46gw/image.png
  [3]: http://static.zybuluo.com/cww97/2ejzkm8yjie22jmhyvzc6idm/image.png


---

## 作者：GUO大侠 (赞：1)

#### 推式子,维护标记。

首先知道约完分以后,答案就是   
 ----------------------$(∑sum^2)/Allsum$    
 $Allsum$很好维护,考虑怎么维护被区间加的$∑sum^2.$   
 设加的数是$v $  
 增量  
 ----------------------=$∑(sum+len*v)^2-∑sum^2$     
 ----------------------=$∑(2*len*sum*v+len^2v^2)$

所以我们要有的是$∑len^2,∑len*sum$  (前者是常量,后者需要维护变化)   
在我的代码中,  
$sum$表示"真_该区间值",
$vsum$是$(∑sum^2)$,      
$sumxl$是$∑sum*len$, 
$vlen$是$∑len^2$    
在下发标记or modify时↓, $∑len*sum+=∑len^2*v$

```
void add(int u,int v){
	(t[u].lazy+=v);
	(t[u].vsum+=2*(t[u].sumxl)*v+(t[u].vlen)*mul(v));
	(t[u].sumxl+=t[u].vlen*v);
	(t[u].sum+=1ll*v*(t[u].len));
}
```

----

完整代码↓用了__ int128,如果有可以不用的童鞋请告诉我您怎么搞的

----------
```cpp
#include<bits/stdc++.h>
#define re(x) scanf("%d",&x)
#define ll long long
#define int __int128
#define mid ((l+r)>>1)
#define lson (u<<1)
#define rson (u<<1|1)
using namespace std;
const int N = 1e5 + 10,mod= 998244353 ;
struct tr{
	int sum,vsum,sumxl,vlen,lazy,len;
}t[N<<2];
int n,m;
int mul(int a){return 1ll*a*a;}
void print(int x){if(x>9)print(x/10);putchar(x%10+'0');}
int read(){
    char ch=getchar();int h=0,t=1;
    while((ch>'9'||ch<'0')&&ch!='-') ch=getchar();
    if(ch=='-') t=-1,ch=getchar();
    while(ch>='0'&&ch<='9') h=h*10+ch-'0',ch=getchar();
    return h*t;
}
int ksm(int a,int b){
	a%=mod;int r=1;
	for(;b;b>>=1,a=a*a%mod)if(b&1)r*=a,r%=mod;
	return r;	
}
void uptag(int u){
	t[u].sum=t[lson].sum+t[rson].sum;
	t[u].vsum=(t[lson].vsum+t[rson].vsum)+mul(t[u].sum);	
	t[u].sumxl=(t[lson].sumxl+t[rson].sumxl+1ll*t[u].sum*(t[u].len));
}
void add(int u,int v){
	(t[u].lazy+=v);
	(t[u].vsum+=2*(t[u].sumxl)*v+(t[u].vlen)*mul(v));
	(t[u].sumxl+=t[u].vlen*v);
	(t[u].sum+=1ll*v*(t[u].len));
}
void pushtag(int u){
	if(!t[u].lazy)return;
	int v=t[u].lazy;t[u].lazy=0;
	add(lson,v);add(rson,v);
}
void build(int u,int l,int r){
	if(l==r){
		t[u].sum=read();
		t[u].vsum=mul(t[u].sum);
		t[u].lazy=0;
		t[u].sumxl=t[u].sum;
		t[u].vlen=t[u].len=1;
		return;
	}
	build(lson,l,mid);
	build(rson,mid+1,r);
	t[u].vlen=(t[lson].vlen+t[rson].vlen+(r-l+1)*(r-l+1));
	t[u].len=r-l+1;
	uptag(u);
}
void modify(int u,int l,int r,int L,int R,int v){
	if(l>=L&&r<=R){
		add(u,v);
		return;
	}
	pushtag(u);
	if(L<=mid)modify(lson,l,mid,L,R,v);
	if(R>mid)modify(rson,mid+1,r,L,R,v);
	uptag(u);
}
signed main(){
	n=read();m=read();
	build(1,1,n);
	while(m--){
		int op=read(),l,r,v;
		if(op&1){
			l=read();r=read();v=read();
			modify(1,1,n,l,r,v);
		}
		else{
			int fz=t[1].vsum/__gcd(t[1].vsum,t[1].sum);
			int fm=t[1].sum/__gcd(t[1].vsum,t[1].sum);
			print(fz%mod*ksm(fm,mod-2)%mod);puts("");
		}
	}
	return 0;
}

```

---

## 作者：SunburstFan (赞：1)

### [P4927 [1007] 梦美与线段树](https://www.luogu.com.cn/problem/P4927)

恶心题，式子并不难推，但是代码有一点繁琐。

#### 题目大意

有一颗线段树，每次按节点权值的占比的概率进入该子树，求走过的权值和的期望值。

#### 解题思路

令当前节点为 $rt$，则不难看出进入 $rt$ 左子树的期望为：

$
sum_l \times P(l) = sum_l \times \frac {sum_l}{sum_{rt}} = \frac {{sum_l}^2}{sum_{rt}}
$。

同理，进入 $rt$ 右子树的期望为：

$
sum_r \times P(r) = sum_r \times \frac {sum_r}{sum_{rt}} = \frac {{sum_r}^2}{sum_{rt}}
$。

那么就可以得出 $rt$ 节点走过的权值和的期望值为：$\frac {{sum_l}^2+{sum_r}^2}{sum_{rt}}$。

下半部分是很好维护的，仅需要维护区间和的线段树即可，而不难看出上半部分就是一个维护区间平方和。

怎么维护呢？考虑每次更新，设增加的数值为 $\Delta V$。

那么 $rt$ 节点的平方和就成为了 $(sum_{rt} + len_{rt} \times \Delta V)^2$。

考虑完全平方公式展开：

$(sum_{rt} + len_{rt} \times \Delta V)^2 = {sum_{rt}^2 + 2 \times len_{rt} \times sum_{rt} \times \Delta V + {len_{rt}}^2} \times {\Delta V}^2 $。

$len$ 和 ${len}^2$ 都可以在线段树的 `build` 阶段维护。

那么我们只需要知道如何维护 $len_{rt} \times sum_{rt}$，这道题就做完了。

每次更新，$len_rt \times sum_{rt}$ 就会变成 $len_{rt} \times (sum_{rt} + len_{rt} \times \Delta V)$

再拆开来：

$len_{rt} \times sum_{rt} + {len_{rt}}^2 \times \Delta V$。

所以每次更新，$len_{rt} \times sum_{rt}$ 只需要加上 ${len_{rt}}^2 \times \Delta V$ 即可， $len^2$ 前边已经说过如何维护了。

乍一看，这棵线段树要维护的东西似乎有点多，比较繁琐。

线段树部分代码：

```cpp
struct Sgt_Tree{
    #define lson rt<<1,l,md
    #define rson rt<<1|1,md+1,r

    int sum[N<<2],sum_2[N<<2];
    int len[N<<2],len_2[N<<2]; 
    int len_sum[N<<2],tag[N<<2];

    void push_up(int rt,int l,int r){
        sum[rt]=sum[rt<<1]+sum[rt<<1|1];
        sum_2[rt]=sum_2[rt<<1]+sum_2[rt<<1|1]+sum[rt]*sum[rt];
        len_sum[rt]=len_sum[rt<<1]+len_sum[rt<<1|1]+(r-l+1)*sum[rt];
    }
    void build(int rt,int l,int r){
        if(l==r){
            sum[rt]=a[l];
            len[rt]=1,len_2[rt]=1;
            sum_2[rt]=sum[rt]*sum[rt];
            tag[rt]=0;
            len_sum[rt]=sum[rt];
            return;
        }

        int md=(l+r)>>1;
        build(lson);build(rson);
        len[rt]=(len[rt<<1]+len[rt<<1|1]+(r-l+1))%mod;
        len_2[rt]=(len_2[rt<<1]+len_2[rt<<1|1]+(r-l+1)*(r-l+1))%mod;
        push_up(rt,l,r);
    }
    
    void make_tag(int rt,int len,int x){
        tag[rt]+=x;
        sum_2[rt]=sum_2[rt]+2*len_sum[rt]*x;
        sum_2[rt]=sum_2[rt]+len_2[rt]*x*x;
        len_sum[rt]+=len_2[rt]*x;
        sum[rt]+=len*x;  
    }
    void push_down(int rt,int l,int r){
        if(tag[rt]){
            int md=(l+r)>>1;
            make_tag(rt<<1,md-l+1,tag[rt]);
            make_tag(rt<<1|1,r-md,tag[rt]);
        }
        tag[rt]=0;
    }
    void update(int rt,int l,int r,int L,int R,int x){
        if(L<=l&&r<=R){
            make_tag(rt,r-l+1,x);
            return ;
        }

        push_down(rt,l,r);

        int md=(l+r)>>1;        
        if(L<=md)update(lson,L,R,x);
        if(R>md)update(rson,L,R,x);
        
        push_up(rt,l,r);
    }

}Tr;
```

---

## 作者：Hoks (赞：0)

## 前言
模拟赛里打到的题，有点折磨。

第一次切这样的概率与期望题，有意思。
## 思路分析
考虑逐步优化，先从最朴素的暴力聊起。

既然题目中给的线段树没有懒标记，那么我们也先写颗没有懒标记的树试试。

根据题意，直接对着线段树每个节点维护和 $s$ 和答案 $f$。

设点 $p$ 的左儿子为 $ls$，右儿子为 $rs$，对应区间为 $[l,r]$，那么 pushup 就很简单：
$$f_p=\frac{s_{ls}}{s_p}\times f_{ls}+\frac{s_{rs}}{s_p}\times f_{rs}+s_p$$

复杂度 $O(n^2\log n)$，期望得分 $50$，[实际得分](https://www.luogu.com.cn/record/157579900) $50$。

接着考虑来优化这个过程，肯定是考虑懒标记。

重点就在于这个答案怎么用懒标记延迟更新。

然后就卡着卡了一个上午，我才意识到这种式子是不可能用懒标记延迟更新的，因为必须算出了 $f_{ls},f_{rs}$ 才能得到 $f_p$。

所以考虑把式子变化一下。

因为期望的本质即为**可能情况权值和除以可能情况总数**，所以我们可以考虑维护出**可能情况权值和**与**可能情况总数**。

那么答案即为**每个节点的权值平方和除以根节点的权值**。

接着来考虑如何维护这个东西。

假设目前权值为 $x$，区间加 $y$，那么很容易得到式子：
$$(x+y)^2=x^2+y^2+2xy$$
直接大力维护出有多少个 $y^2$，以及 $\sum x$ 的值直接乘上 $2y$ 即可。

但这样维护出来的只是单点，算答案还要遍历整颗树。

所以考虑把儿子的贡献都给加到父亲上再维护下就行了。

**[注意点](https://www.luogu.com.cn/discuss/757531)。**
## 代码
```cpp
#include<bits/stdc++.h>
#define ls (p<<1)
#define rs (ls|1)
#define mid ((l+r)>>1)
#define int __int128
using namespace std;
const int N=1e5+10,INF=0x3f3f3f3f3f3f3f3f,mod=998244353;
int n,m,t[N<<2],tt[N<<2],s[N<<2],ss[N<<2],lz[N<<2];
namespace Fast_IO
{
    static char buf[1000000],*paa=buf,*pd=buf,out[10000000];int length=0;
    #define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
    inline int read()
    {
        int x(0),t(1);char fc(getchar());
        while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
        while(isdigit(fc)) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
        return x*t;
    }
    inline void flush(){fwrite(out,1,length,stdout);length=0;}
    inline void put(char c){if(length==9999999) flush();out[length++]=c;}
    inline void put(string s){for(char c:s) put(c);}
    inline void print(int x)
    {
        if(x<0) put('-'),x=-x;
        if(x>9) print(x/10);
        put(x%10+'0');
    }
    inline bool chk(char c) { return !(c>='a'&&c<='z'||c>='A'&&c<='Z'||c>='0'&&c<='9'||c=='#'||c=='.'); }
    inline bool ck(char c) { return c!='\n'&&c!='\r'&&c!=-1&&c!=' '; }
    inline void rd(char s[],int&n)
    {
        s[++n]=getchar();
        while(chk(s[n])) s[n]=getchar();
        while(ck(s[n])) s[++n]=getchar();
        n--;
    }
}
using namespace Fast_IO;
inline int ksm(int x,int y,int mod)
{
    int res=1;
    while(y){if(y&1) res=res*x%mod;x=x*x%mod;y>>=1;}
    return res;
}
inline void pushson(int p,int l,int r,int x){tt[p]+=x*(r-l+1);lz[p]+=x;ss[p]+=2*x*t[p]+x*x*s[p];t[p]+=x*s[p];}
inline void pushdown(int p,int l,int r){pushson(ls,l,mid,lz[p]),pushson(rs,mid+1,r,lz[p]),lz[p]=0;}
inline void build(int p,int l,int r)
{
    if(l==r)
    {
        s[p]=1;int x=read();
        tt[p]+=x*(r-l+1);lz[p]+=x;
        ss[p]+=2*x*t[p]+x*x*s[p];
        t[p]+=x*s[p];return;
    }
    build(ls,l,mid);build(rs,mid+1,r);
    tt[p]=tt[ls]+tt[rs];
    t[p]=(r-l+1)*tt[p]+t[ls]+t[rs];
    ss[p]=tt[p]*tt[p]+ss[ls]+ss[rs];
    s[p]=(r-l+1)*(r-l+1)+s[ls]+s[rs];
}
inline void modify(int p,int l,int r,int s,int e,int x)
{
    if(l>=s&&r<=e) return pushson(p,l,r,x);pushdown(p,l,r);
    if(mid>=s) modify(ls,l,mid,s,e,x);
    if(mid<e) modify(rs,mid+1,r,s,e,x);
    tt[p]=tt[ls]+tt[rs];
    t[p]=(r-l+1)*tt[p]+t[ls]+t[rs];
    ss[p]=tt[p]*tt[p]+ss[ls]+ss[rs];
}
inline void put()
{
    int x=ss[1],y=tt[1];while(y%mod==0) x/=mod,y/=mod;
    print(x%mod*ksm(y,mod-2,mod)%mod);put('\n');
}
signed main()
{
    n=read(),m=read();build(1,1,n);
    for(int i=1,op,l,r;i<=m;i++)
    {
        op=read();if(op==2) put();
        else l=read(),r=read(),modify(1,1,n,l,r,read());
    }
    genshin:;flush();return 0;
}
```

---

## 作者：wangkeli (赞：0)

プラネタリウムはいかがでしょう？

どんな时も决して消えることのない、美しい无穷のきらめき。

満天の星々がみなさまをお待ちしています。



------------
### 题意

有一颗维护区间和的线段树，每次按权值占比概率进入子树，求权值和期望。

### 思路

计算每个叶子结点的期望权值，那么第 $i$ 个点的期望为 $\frac{sum_i^2}{\sum{sum}}$,其中 $\sum{sum}$ 代表所有节点的权值之和。

现在加上区间修改操作，只需要区间维护 ${sum^2}$ 就可以了。

假设某个操作让区间 $l \sim r$ 增加了 $k$。

那么 $\Delta{sum^2}= \sum_{l}^r{sum} \times 2k \times (r-l) + (r-l)^2 \times k^2$	

发现在区间加的时候，总期望的变化只和 $\sum_{l}^r{(sum \times (r-l))}$ 与 $\sum_{l}^r{(r-l)^2}$ 有关，后者只需要预处理即可。前者则可以利用后者维护:

$(\sum_{l}^r{sum}+k \times (r-l)) \times (r-l)=\sum_{l}^r{(sum \times (r-l))}+k(r-l)^2$

用带 lazy tag 的线段树维护即可。

---

## 作者：SkyRainWind (赞：0)

[my blogs](https://www.cnblogs.com/SkyRainWind/p/17171162.html)

题解：

~~《星之梦》真的不错，key顶尖短篇之一，推荐。~~

首先看一下期望是什么：

从期望的定义出发，比如先在根节点尝试 $sum[1..n]$ 次，那么根据概率得有 $sum[1..mid]$ 个情况跑到左子树中，$sum[mid+1..n]$ 跑到右子树中，也就是说这一次对于期望的贡献就是 $\frac{sum[1..mid]^2+sum[mid+1..n]^2}{sum[1..n]}$（平方是因为尝试了这么多次，并且这一次的权值也是这个值。）

递归下去我们就发现最后的期望值就是 $\frac{A}{sum[1..n]}$，其中 $A$ 就是对于线段树上每一个点 $i$，这个点代表的区间 $[l..r]$ 的权值和 $A_i$，求这个和的平方再对所有点求和得到（$A=\sum A_i^2$）

现在要带修改，考虑怎么区间修改的同时维护 $A$。

考虑对于线段树一个点 $i$ ，如果这个点对应的区间 $[l..r]$ 中所有数都 $+v$，那么 $A$ 如何变化（考虑这个是因为我们要打懒标记，因此必须预先知道这个区间的变化）？

$\Delta A_i=(sum[l..r]+len\times v)^2-sum[l..r]^2=2\times sum[l..r]$ $\times v \times len +\ len^2\times v^2 $

因此只需要维护 $\sum sum[l..r]\times len$ 和 $\sum len^2$ 即可，其中后者是个常量，可以在建树的时候处理出来。

考虑前者该如何维护，$(sum[l..r]+v\times len)\times len = sum[l..r]\times len+len^2\times v$ ，因此只需要借助 $\sum len^2$ 即可（注意这里只是对 $i$ 结点来说的，但是我们需要的是这个点及子树的和，因此我们需要 $\sum len^2$）

pushup 也很好写，按定义维护变量即可。

**线段树区间修改懒标记的本质就是能对一个大区间整体操作，而不需要借助小区间递推上来（如区间加和，可以 $sum[l..r]+len\times v$ 而不必借助子树），在本题中也是一样，借助 $\sum len^2$ 和 $\sum sum[l..r]\times len$，我们就可以实现对区间的整体操作，其实这也是 pushdown 能进行的基础**

代码，注释很详细了：
```cpp
// by SkyRainWind
#include <bits/stdc++.h>
#define mpr make_pair
#define debug() cerr<<"Yoshino\n"
#define pii pair<int,int>
#define pb push_back

using namespace std;

typedef long long ll;
typedef long long LL;
#define int __int128

const int inf = 1e9, INF = 0x3f3f3f3f, maxn = 2e5+5, mod = 998244353;

int n,m,a[maxn];
struct segm{
	int l;	// l = \sum len^2
	int len;	// 当前区间长度 
	int sum,val,lazy;	// sum 区间和 , val \sum sum[l..r]*len 对子树的点求和 
	int res;	// 当前点子树中的点对应的区间和的平方的和（期望的分子） 
}se[maxn << 2];
// S^2 -> (S+len*v)^2-S^2 = 2*S*len*v + len^2*v^2，其中 S 为区间和 
// 维护 \sum len^2 (常量) \sum S*len 

int pw(int x,int y){
	if(!y)return 1;if(y==1)return x;
	int mid=pw(x,y>>1);
	if(y&1)return 1ll*mid*mid%mod*x%mod;
	return 1ll*mid*mid%mod;
}

int read(){
    char ch=getchar();int h=0,t=1;
    while((ch>'9'||ch<'0')&&ch!='-') ch=getchar();
    if(ch=='-') t=-1,ch=getchar();
    while(ch>='0'&&ch<='9') h=h*10+ch-'0',ch=getchar();
    return h*t;
}
void print(int x){if(x>9)print(x/10);putchar(x%10+'0');}
int sq(int x){return 1ll*x*x;}
void pushup(int num,int l,int r){
	se[num].l = se[num<<1].l + se[num<<1|1].l + sq(r-l+1);
	se[num].sum = se[num << 1].sum + se[num << 1|1].sum;
	se[num].val = se[num << 1].val + se[num << 1|1].val + (r-l+1) * se[num].sum;
	se[num].res = se[num << 1].res + se[num << 1|1].res + sq(se[num].sum);
}

void build(int x,int y,int num){
	se[num].len = y-x+1;
	if(x == y){
		se[num].l = 1;
		se[num].sum = se[num].val = a[x];
		se[num].res = sq(a[x]);
		return ;
	}
	int mid = x+y>>1;
	build(x,mid,num <<1);build(mid+1,y,num<<1|1);
	pushup(num,x,y);
}

void add(int num,int v){	// 对区间能进行整体操作 
	se[num].lazy += v;
	se[num].res += 2*se[num].val*v + se[num].l*v*v;
	se[num].sum += se[num].len * v;
	se[num].val += se[num].l * v;
}

void pushdown(int num,int l,int r){
	if(!se[num].lazy)return ;
	add(num<<1,se[num].lazy);
	add(num<<1|1,se[num].lazy);
	
	se[num].lazy = 0;
}

void upd(int x,int y,int v,int l,int r,int num){
	if(x<=l && r<=y){
		add(num, v);
		return ;
	}
	pushdown(num,l,r);
	int mid=l+r>>1;
	if(y<=mid)upd(x,y,v,l,mid,num<<1);
	else if(x>mid)upd(x,y,v,mid+1,r,num<<1|1);
	else upd(x,y,v,l,mid,num<<1), upd(x,y,v,mid+1,r,num<<1|1);
	pushup(num,l,r);
}

signed main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++)a[i]=read();
	build(1,n,1);
	while(m --){
		int op=read(),l,r,v;
		if(op == 2){
			int fz = se[1].res / __gcd(se[1].res,se[1].sum);
			int fm = se[1].sum / __gcd(se[1].res,se[1].sum);
			print(fz%mod*pw(fm,mod-2)%mod);puts("");
		}else{
			l=read(),r=read(),v=read();
			upd(l,r,v,1,n,1);
		}
	}

	return 0;
}
```

---


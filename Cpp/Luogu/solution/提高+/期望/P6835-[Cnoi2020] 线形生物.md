# [Cnoi2020] 线形生物

## 题目背景

> 为了能够在冥界过上这种愉快的生活而不是被判入地狱，人类们摒弃了自行结束生命的做法，拼尽全力地生活着。如此看来，人类似乎也显得有些积极与可爱了呢。  （射命丸 文） 

线形生物沿着一维的阶梯向着冥界单向地前行着。

照这样的话，它只需要一级一级地，走 $n$ 步就能够到达白玉楼。

但 Cirno 觉得这样太单调了，于是，一维的壁垒被打破，链状的道路生出了花椰菜状的枝桠。



## 题目描述

线形生物要从 $1$ 号台阶走到 $n+1$ 号台阶。

最开始，$1,2,3,\ldots,n$ 号台阶都有一条连向下一台阶的有向边 $i\rightarrow i+1$。

之后 Cirno 加入了 $m$ 条**返祖边** $u_i \rightarrow v_i (u_i \ge v_i)$，它们构成了一个**返祖图**。

线形生物每步会 **等概率地** 选取当前台阶的一条出边并走向对应的台阶。

当走到 $n+1$ 号台阶时，线形生物就会停止行走。

同时，Cirno 会统计线性生物总共走的步数，记作 $\delta$。

Cirno 想知道 $E(\delta)$（即 $\delta$ 的**数学期望**）对 $998244353$ 取模后的结果。

## 说明/提示

## 后置数学知识
 - **可能用到的幂级数求和** : 若 $x>1$，则有 $\sum\limits_{i=1}^{\infty}\big(\frac{1}{x}\big)^i=\frac{1}{x}+\frac{1}{x^2}+\frac{1}{x^3}+\cdots=\frac{1}{x-1}$。
 - **数学期望** : 随机试验中每次可能结果的概率乘以其结果的总和，反映随机变量平均取值的大小。
 - **离散期望公式** : $E(x)=\sum\limits_{k=1}^{\infty}x_kp_k$。
 
## 数据范围与约定

对于 $100\%$ 的数据，保证：$id \in \{1,2,3,4,5\}$，$0 < n,m \le 10^6$，$1 \le v_i \le u_i \le n$。

#### 子任务「本题采用捆绑测试」

 - Subtask1（$10\%$）: 返祖图中所有点都有自环且所有边均为自环(未画出)，总图形如 :  
 ![](https://cdn.luogu.com.cn/upload/image_hosting/6fikv6ft.png)
   
 - Subtask2（$10\%$）: 返祖图中所有点均向且仅向自己的前驱连边，特别地，$1$ 号节点的前驱是 $1$ 号节点，总图形如 :  
   ![](https://cdn.luogu.com.cn/upload/image_hosting/6rc9dazb.png)
 
 - Subtask3（$10\%$）: 返祖图中所有点均向且仅向 $1$ 号节点连边，总图形如 :  
 ![](https://cdn.luogu.com.cn/upload/image_hosting/wup1ctvu.png)
 
 - Subtask4（$10\%$）: $n \le 100$，$m \le 1000$。
 
 - Subtask5（$60\%$）: 无特殊限制。
 
 ## 后记
 
  题目名称出自 th17 东方鬼形兽 6 Boss 埴安神袿姬 Hard / Lunatic 难度符卡 線形「リニアクリーチャー」。
  

## 样例 #1

### 输入

```
1 5 5
1 1
2 2
3 3
4 4
5 5```

### 输出

```
10```

## 样例 #2

### 输入

```
2 5 5
1 1
2 1
3 2
4 3
5 4```

### 输出

```
30```

## 样例 #3

### 输入

```
3 5 5
1 1
2 1
3 1
4 1
5 1```

### 输出

```
62```

## 样例 #4

### 输入

```
4 5 5
1 1
3 1
4 2
5 1
5 5```

### 输出

```
35```

# 题解

## 作者：tommymio (赞：65)

期望入门题。

这题非常的好，考察了期望的线性性质和选手的推柿子能力，给良心出题人点赞（~~然而我月赛时并没有做出来~~

注：期望的线性性质：在本题中体现为从 $x$ 点到 $y$ 点的期望步数 $E_{x\to y}=E_{x\to x+1}+...+E_{y-1 \to y}=\sum\limits_{i=x}^{y-1}E_{i\to i+1}$。

对于这类在图上随机游走的问题，我们一般会设 $E_{x\to x+1}$ 表示从 $x$ 点到 $x+1$ 点的期望步数，那么答案就是 $\sum\limits_{x=0}^n E_{x\to x+1}$ 的值。

不妨先根据期望的定义列出 $E_{x\to x+1}$ 的转移式（其中 $du_x$ 表示 $x$ 的**返祖边**的条数，而 $E$ 表示 $x$ 的**返祖边**的边集）：

$$
E_{x\to x+1}=\frac{1}{du_x+1}\times1+\frac{1}{du_x+1}\sum_{(x,y)\in E} (E_{y\to x+1}+1)
$$

将 $E_{y\to x+1}=\sum\limits_{i=y}^{x}E_{i\to i+1}$ 代入上式并对上式进行化简：

$$
E_{x\to x+1}=1+\frac{1}{du_x+1}\sum_{(x,y)\in E}\sum_{i=y}^xE_{i\to i+1}
$$

此时记 $E_{x\to x+1}$ 为 $f_x$，记 $sum_x=\sum\limits_{i=0}^x f_i$，则上式可写作：

$$
f_x=1+\frac{1}{du_x+1}\sum_{(x,y)\in E}sum_x-sum_{y-1}
$$

发现等式两边都含有 $E_{x\to x+1}$ ，把 $E_{x\to x+1}$ 全部提到左边（为了让 $f_x$ 能够转移），并消去和式系数 $\frac{1}{du_x+1}$，得：

$$
f_x=(du_x+1)+\sum_{(x,y)\in E}sum_{x-1}-sum_{y-1}
$$

到这里维护一下前缀和，就可以直接转移了。总时间复杂度为 $O(n)$。

上式的化简步骤都是一些常见的状态转移方程的 $\text{Dirty Work}$，本来不想写出来的（

**Show the Code**
```cpp
#include<cstdio>
#define int ll
typedef long long ll;
const int mod=998244353;
int cnt=0;
int h[1000005],to[2000005],ver[2000005];
int f[1000005],sum[1000005],du[1000005];
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
inline void add(int x,int y) {to[++cnt]=y;ver[cnt]=h[x];h[x]=cnt;}
signed main() {
	int id=read(),n=read(),m=read();
	for(register int i=1;i<=m;++i) {int x=read(),y=read();add(x,y);++du[x];}
	for(register int x=1;x<=n;++x) {
		f[x]=du[x]+1;
		for(register int i=h[x];i;i=ver[i]) {
			int y=to[i];
			f[x]=((f[x]+(sum[x-1]-sum[y-1])%mod)%mod+mod);
		}
		sum[x]=(sum[x-1]+f[x])%mod;
	}
	printf("%lld\n",sum[n]); 
	return 0;
}
```

---

## 作者：Daniel13265 (赞：23)

# 前言

这道题实际上不需要复杂的数学推导，只需要利用期望的线性性就能轻松推出答案。

# 分析

设 $E_{x\to y}\left(1\le x\le y\le n+1\right)$ 表示从 $x$ 号台阶到 $y$ 号台阶的期望步数，设 $S$ 表示返祖边集，设 $k_x$ 表示从 $x$ 号台阶出发的返祖边数。根据题意以及期望的定义，有
$$
E_{x\to x+1}=\frac{1}{k_x+1}\cdot1+\frac{1}{k_x+1}\sum_{\left(x,y\right)\in S}\left(E_{y\to x+1}+1\right).
$$

期望具有线性性，于是对于任意 $1\le x\le y\le n+1$ 有
$$
E_{1\to x}+E_{x\to y}=E_{1\to y}.
$$

二者结合，可以得到
$$
\begin{aligned}
E_{x\to x+1}&=\frac{1}{k_x+1}\cdot1+\frac{1}{k_x+1}\sum_{\left(x,y\right)\in S}\left(E_{1\to x}+E_{x\to  x+1}-E_{1\to y}+1\right)\\
&=\frac{1}{k_x+1}\cdot1+\frac{1}{k_x+1}\sum_{\left(x,y\right)\in S}\left(E_{1\to x}-E_{1\to y}+1\right)+\frac{k_x}{k_x+1}E_{x\to  x+1}.
\end{aligned}
$$

移项化简得

$$
E_{x\to x+1}=1+\sum_{\left(x,y\right)\in S}\left(E_{1\to x}-E_{1\to y}+1\right).
$$
再次根据期望的线性性有
$$
E_{1\to x+1}=E_{1\to x}+1+\sum_{\left(x,y\right)\in S}\left(E_{1\to x}-E_{1\to y}+1\right).
$$
有明显初始状态 $E_{1\to1}=0$，所以直接递推 $E_{1\to x}$ 即可，答案即为 $E_{1\to n+1}$。这个算法的时空复杂度均为 $\mathcal O\left(n+m\right)$。

# 参考代码

```cpp
#include <cstdio>

int read() {
  static int ch, x;
  while ((ch = getchar()) < 48) {}
  x = ch ^ 48;
  while ((ch = getchar()) >= 48) x = (((x << 2) + x) << 1) + (ch ^ 48);
  return x;
}

#define MAXN 1000010
const int P = 998244353;

// e[x] 表示文中的 E_{1 \to x}。
int e[MAXN], head[MAXN], nxt[MAXN], to[MAXN];

int main() {
  read();
  const int n = read(), m = read();
  for (int i = 1; i <= m; ++i) {
    const int x = read(), y = read();
    nxt[i] = head[x];
    to[i] = y;
    head[x] = i;
  }
  int ans = 0;
  for (int i = 1; i <= n; ++i) {
    e[i] = ans;
    long long d = 0;
    // 注意不能直接累加 ans，因为可能出现 x = y 的情况。
    for (int j = head[i]; j; j = nxt[j]) d += ans - e[to[j]] + 1;
    ans = (ans + 1 + d) % P;
  }
  printf("%d\n", ans + (ans >> 31 & P));
  return 0;
}

```



---

## 作者：Little09 (赞：11)

感觉这道题好像出的水了点，像我这种对期望一窍不通的菜鸡也可以推出来。我的思路好像和大家不太一样（更简单一点吧）……但是好歹过了，大家可以参考一下。

我们设要通过第 $x$ 个点需要的期望步数为 $E(x)$。那么我们可以根据定义推出 $E(x)$ 的表达式：

$$E(x)=\dfrac{n+\sum \sum_{i=t_x}^{x}E(i)}{n}$$

在这里，$t_x$ 表示所有 $x$ 的返祖点。第一个求和符号枚举的是它的所有返祖边，第二个求和是要求从 $t_x$ 走到 $x$ 的期望步数。显而易见，第二个求和可以前缀和优化。

我们令 $S(x)=\sum_{i=1}^{x}E(i)$。那么原式可以写为：

$$E(x)=\dfrac{n+(n-1)\times S(x)-\sum S(t_x-1)}{n}$$

把 $S(x)$ 改为 $E(x)+S(x-1)$，再移项，就可以得到 $E(x)$ 的公式：

$$E(x)=n+(n-1)\times S(x-1)-\sum S(t_x-1)$$

至此可以 $O(n+m)$ 计算了。维护一下 $E$ 和 $S$，从 $1$ 开始枚举就可以了。

献上丑陋的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int x,y;
long long g[1000001],ans;
const long long mod=998244353;
int h[1000001],t[1000001],nxt[1000001],cnt;
long long E[1000001],S[1000001];
inline int read()
{
	char C;
	int F=1,ANS=0;
	while (C<'0'||C>'9')
	{
		if (C=='-') F=-1;
		C=getchar();
	}
	while (C>='0'&&C<='9')
	{
		ANS=ANS*10+C-'0';
		C=getchar();
	}
	return F*ANS;
}
inline void add(int x,int y)
{
	t[++cnt]=y;
	nxt[cnt]=h[x];
	h[x]=cnt;
}
int main()
{
	int id,n,m;
	cin >> id >> n >> m;
	for (int i=1;i<=m;i++) 
	{
		int x,y;
		x=read(),y=read();
		g[x]++;
		add(x,y);
	}
	for (int i=1;i<=n;i++)
	{
		E[i]=(g[i]+1+g[i]*(S[i-1]))%mod;
		long long res=0;
		for (int j=h[i];j;j=nxt[j]) 
		{
			res=(res+S[t[j]-1])%mod;
		}
		E[i]-=res;
		E[i]=(E[i]+mod)%mod;
		S[i]=(S[i-1]+E[i])%mod;
	}
	cout << S[n];
	return 0;
}
```


---

## 作者：Lonely_NewYear (赞：6)

# 洛谷 P6835 题解

果然状态对了 DP 就对一半啊！

## 题目分析

期望DP，设 $f_i$ 表示第 $i$ 个点到第 $i+1$ 个点的期望步数。

如果某个点如果返祖的话，就要再走一遍祖先到这个点的路，外加返祖边的贡献，即 $1+\sum_{i=v}^{u}f[i]$，求和的部分可以用前缀和优化。设 $g_i=\sum_{j=1}^{i}f[i]$。

最后还要加上直接往后走的情况，所以方程就为：

$$f_i=\frac{\sum_{i\rightarrow v}(g_i-g_{v-1}+1)+1}{out_i+1}$$

$$(out_i+1)\times f_i=out_i\times g_i-\sum_{i\rightarrow v}g_{v-1}+out_i+1$$

$$\texttt{又因为}g_i=g_{i-1}+f_i,\texttt{所以},$$

$$(out_i+1)\times f_i=out_i\times g_{i-1}+out_i\times f_i-\sum_{i\rightarrow v}g_{v-1}+out_i+1$$

$$f_i=out_i\times g_{i-1}-\sum_{i\rightarrow v}g_{v-1}+out_i+1$$

式子可终于推完了~~可怕的 LaTeX 可终于写完了~~

会枚举一遍点和边，所以时间复杂度为 $O(n+m)$。

## 代码

```cpp
#include<cstdio>
using namespace std;
const int mod=998244353;
struct edge
{
	int to,next;
}g[1000001];
int cnt,head[1000001];
long long dp[1000001],sum[1000001];
void add(int u,int v)
{
	g[++cnt]=(edge){v,head[u]};
	head[u]=cnt;
}
int main()
{
	int n,m;
	scanf("%*d%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);
	}
	for(int i=1;i<=n;i++)
	{
		dp[i]=1;
		for(int j=head[i];j;j=g[j].next)
		{
			int v=g[j].to;
			dp[i]=(dp[i]+sum[i-1]-sum[v-1]+1+mod)%mod;
		}
		sum[i]=(sum[i-1]+dp[i])%mod;
	}
	printf("%lld",sum[n]);
    return 0;
}
```

谢谢观看！

---

## 作者：tiger2005 (赞：4)

## 题意简述

有 `N+1` 个点，从 `i` 指向 `i+1` 形成一个链，其中还有一些返祖边。

一个生物在 `1` 号点，每次将随机选择一条边通过，求出走到 `N+1` 的步数期望。

## 分析

![](https://cdn.luogu.com.cn/upload/image_hosting/0yk8iqz5.png)神奇做法注意！

先推式子。假设 $f_x$ 表示 `x` 走到 `N+1`的期望步数。

$$f_x=\dfrac{\sum\limits_{(x,u)\in E}f_u+1}{\sum\limits_{(x,u)\in E}1}=\dfrac{\sum\limits_{(x,u)\in E}f_u}{\operatorname{outDegree}(x)}+1$$

这个式子的分子中只有 `x+1` 一个数大于 `x`，可以代入 $f_{x+1}$ 的表达式算 $f_x$。

$$f_x=\dfrac{\sum\limits_{(x,u)\in E}f_u}{\operatorname{outDegree}(x)}+1=\dfrac{f_{x+1}}{\operatorname{outDegree}(x)}+\dfrac{\sum\limits_{(x,u)\in E \operatorname{and} u \leq x}f_u}{\operatorname{outDegree}(x)}+1$$

那就可以把 $f_{x+1}$ 的表达式写成一个数组 `g`，满足$f_{x+1}=g_{const}+\sum f_i \times g_i$，然后每次把这个数组除上 $\operatorname{outDegree}(x)$，然后把返祖边对应位置加上 $\dfrac{1}{\operatorname{outDegree}(x)}$，然后常数项加上 1。但是算完之后要把值算出来了，那就只能算的时候消元了。

$f_{x+1}=g_{const}+\sum f_i \times g_i=g_{const}+\sum\limits_{i \in [1,x]}f_i \times g*i+f_{i+1}*g_{i+1}$

$(1-g_{x+1})f_{x+1}=g_{const}+\sum\limits_{i \in [1,x]}f_i \times g_i$

$f_{x+1}=\dfrac{g_{const}+\sum\limits_{i \in [1,x]}f_i \times g_i}{1-g_{x+1}}$

然后就可以把当前点的系数消掉了！

但是这么算超时是无法避免的，那怎么办呢？

想到超时的真正原因是区间除的时候使用暴力方法，那么可以使用类似于 `tag` 的思想。对于一个数组 `s` ，可以将修改变成如下形式：

```
tag=1;
divideBy(a) -> tag*=a;
addNumber(a,x) -> s[a]+=x*tag;
getValue(a) -> return a/tag;
```

然后这道题就可以在 $O(n+m)$ 的复杂度内作完，就是算逆元常数有点大。

## 代码

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <vector>
using namespace std;
inline int read(){
	register int ret=0;
    char ch=getchar();
    while(ch<'0') ch=getchar();
    while(ch>='0') ret=(ret<<3)+(ret<<1)+ch-'0',ch=getchar();
    return ret;
}
vector<int> To[1000010];
const long long Md=998244353;
int N,M;
inline long long ksm(int x,int y){
	register long long ret=1,bas=x;
	while(y){
		if(y&1)	(ret*=bas)%=Md;
		(bas*=bas)%=Md;y>>=1;
	}
	return ret;
}
long long SZ[1000010],MUL=1,DIV=1;
inline void add(int x,long long a){
	(SZ[x]+=a*DIV%Md)%=Md;
}
int main(){
	read();N=read();M=read();
	for(int i=1,u,v;i<=M;i++){
		u=read();v=read();
		To[u].push_back(v);
	}
	SZ[0]=0;
	register long long L,P,Q;
	for(int i=N;i;i--){
		L=To[i].size()+1;
		P=ksm(L,Md-2);
		(MUL*=P)%=Md;(DIV*=L)%=Md;
		for(int j=0;j<To[i].size();j++)
			add(To[i][j],P);
		add(0,1);
		Q=(1+Md-SZ[i]*MUL%Md)%Md;
		(MUL*=ksm(Q,Md-2))%=Md;(DIV*=Q)%=Md;
		SZ[i]=0;
	}
	printf("%lld",(SZ[0]*MUL)%Md);
}
```

---

## 作者：potatoler (赞：4)

### [题目](https://www.luogu.com.cn/problem/P6835)描述

线形生物要从 $1$ 号台阶走到 $n+1$ 号台阶。最开始，$1,2,3,...,n$ 号台阶都有一条连向下一台阶的有向边 $i→i+1$，之后加入 $m$ 条「返祖边」$u_i→v_i(u_i≥v_i)$，构成一个返祖图。线形生物每步会等概率地选取当前台阶的一条出边并走向对应的台阶，走到 $n+1$ 号台阶便会停止行走。求线性生物总共走的步数的数学期望，答案对 $998244353$ 取模。

### 思路们

#### 思路一

设 $f_i$ 为从 $i$ 号台阶走到 $i+1$ 号台阶的期望步数，当走到 $i$ 号台阶时，假设它有 $k_i$ 条出边，那么便有 $\frac{1}{k_i}$ 的概率走向下一个台阶，有 $\frac{k_i-1}{k}$ 的概率走返祖边回到前面的台阶。前者需要的步数代价为 $1$，后者需要的步数代价是走返祖边后到下一个台阶的期望步数。记 $sum$ 为走每一条返祖边回到 $i$ 点的期望步数总和，具体来讲，记 $E$ 为 $i$ 号台阶的返祖边集，有 $sum=\sum_{e(i,j)\in E} (\sum_{j}^{i-1}f_j+1)$，加一是因为返祖边本身需要一步。一共有 $k_i-1$ 条返祖边，每条边走的概率均等，走一次返祖边回到 $i$ 的期望步数就是 $\frac{sum}{k_i-1}$。但是现在只回到了 $i$ ，要想走到下一个台阶，还需要加上从 $i$ 走到下一个台阶的期望步数，也就是 $f_i$。对刚才推出的式子进行化简：
$$
\begin{aligned}

f_i&=\frac{1}{k}·1+\frac{k-1}{k}(\frac{sum}{k-1}+f_i) \\

k\ f_i&=1+sum+(k-1)f_i \\

f_i&=sum+1

\end{aligned}
$$
这里的 $sum$ 可以使用前缀和维护

#### 思路二

首先我们需要知道一个结论：$\sum_{i=1}^{\infty}p(1-p)^{i-1}·i=\frac{1}{p}$ （当然如果您可以现推就不说了）

仍然设 $f_i$ 为从 $i$ 号台阶走到 $i+1$ 号台阶的期望步数，我们可以将这个期望划分成：没有走过返祖边的期望，走了一次返祖边的期望，走了两次返祖边的期望…… 假设 $i$ 号台阶有 $k_i$ 条出边，走一次返祖边回到 $i$ 的期望步数就是 $\frac{sum}{k_i-1}$（上面说了），走 $t$ 次返祖边的期望步数就是 $t·\frac{sum}{k_i-1}$。那么有：

$$
\begin{aligned}
f_i&=1+\sum_{t=0}^{\infty}\frac{1}{k}(1-\frac{1}{k})^{t}·t·\frac{sum}{k-1} \\
	 &=1+\sum_{t=1}^{\infty}\frac{1}{k}(1-\frac{1}{k})^{t}·t·\frac{sum}{k-1} \\
	 &=1+(1-\frac{1}{k})\sum_{t=1}^{\infty}\frac{1}{k}·(1-\frac{1}{k})^{t-1}·t·\frac{sum}{k-1} \\
	 &=1+(1-\frac{1}{k})·k·\frac{sum}{k-1} \\
	 &=1+sum
\end{aligned}
$$

### Code

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<climits>
#include<algorithm>
#include<vector>
#define int long long
using namespace std;
const int MaxN = 1000006, Mod = 998244353;
int degree[MaxN], f[MaxN], sum[MaxN]; // 注意这里的sum和上面所说的sum意义不同
vector<int> to[MaxN];

inline int Read(){
	int num = 0, op = 1;
	char ch = getchar();
	while(!isdigit(ch)){
		if(ch == '-') op = -1;
		ch = getchar();
	}
	while(isdigit(ch)){
		num = num * 10 + ch - '0';
		ch = getchar();
	}
	return num * op;
}

inline int Get(int x){
	int ans = 0;
	for(int i=0; i<to[x].size(); i++){
		if(to[x][i] == x) ans = (ans + 1) % Mod;
		else ans = (ans + sum[x-1] - sum[to[x][i]-1] + 1 + Mod) % Mod;
	}
	return ans;
}

signed main(){
	int id = Read(), n = Read(), m = Read();
	for(int i=1; i<=m; i++){
		int u = Read(), v = Read();
		degree[u]++;
		to[u].push_back(v);
	}
	for(int i=1; i<=n; i++){
		f[i] = (Get(i) + 1) % Mod;
		sum[i] = (sum[i-1] + f[i]) % Mod;
	}
	printf("%lld", sum[n]);
	return 0;
}
```



---

## 作者：SunnyYuan (赞：3)

## 思路

我们设 $E_{x\rightarrow y}$ 为从 $x$ 到 $y$ 的期望长度。

那么 $E_{x\rightarrow y} = E_{x->x + 1} + E_{x + 1\rightarrow x + 2} + E_{x + 2 \rightarrow x + 3} + \dots + E_{y - 1 \rightarrow y}$。

那么从 $1$ 号点到 $n + 1$ 号点就是 $E_{1\rightarrow n + 1} = \sum\limits_{i = 1}^{n} E_{i\rightarrow i + 1}$

注意从 $x$ 到 $x + 1$ 不一定只走一条边，也有可能走到返祖边再回来。

设 $out_u$ 表示点 $u$ 的出度（不包括 $u\rightarrow u + 1$ 这条边）。

我们发现，我们既可以从 $u$ 到 $u + 1$，也可以从 $u$ 由返祖边回到之前的一个点然后再到 $u + 1$，设返祖边构成的集合为 $R$，有：

$$E_{u\rightarrow u + 1} = \frac{1}{out_u + 1}\times 1 + \frac{1}{out_u + 1}\sum\limits_{(u, v) \in R}{(1 + E_{v\rightarrow u + 1})}$$

$\frac{1}{out_u + 1}\times 1$ 表示有 $\frac{1}{out_u + 1}$ 的概率从 $u$ 直接走到 $u + 1$，并且长度为 $1$，期望为 $\frac{1}{out_u + 1}\times 1$。

$\frac{1}{out_u + 1}\sum\limits_{(u, v) \in R}{(1 + E_{v\rightarrow u + 1})}$ 表示有 $\frac{1}{out_u + 1}$ 的概率走到每一条返祖边里面，每次走的长度为从 $u$ 到 $v$ 的长度 $1$ 加上 $v\rightarrow u + 1$ 的期望长度 $E_{v\rightarrow u + 1}$。

然后我们发现 $E_{v\rightarrow u + 1} = \sum\limits_{d = v}^{u} E_{d\rightarrow d + 1}$。

带入原式得

$$E_{u\rightarrow u + 1} = \frac{1}{out_u + 1}\times 1 + \frac{1}{out_u + 1}\sum\limits_{(u, v) \in R}{(1 + \sum\limits_{d = v}^{u} E_{d\rightarrow d + 1})}$$

继续化简，将 $\sum\limits_{(u, v) \in R}{(1 + \sum\limits_{d = v}^{u} E_{d\rightarrow d + 1})}$ 继续化简得 $out_u + \sum\limits_{(u, v) \in R}{\sum\limits_{d = v}^{u} E_{d\rightarrow d + 1}}$，放回到原式得

$$
\begin{aligned}
E_{u\rightarrow u + 1} &= \frac{1}{out_u + 1} + \frac{out_u}{out_u + 1} + \frac{1}{out_u + 1}\sum\limits_{(u, v) \in R}{\sum\limits_{d = v}^{u} E_{d\rightarrow d + 1}}\\
&= 1 + \frac{1}{out_u + 1}\sum\limits_{(u, v) \in R}{\sum\limits_{d = v}^{u} E_{d\rightarrow d + 1}}
\end{aligned}
$$

现在我们设 $f_i$ 为 $E_{i\rightarrow i + 1}$，有：

$$f_u = 1 + \frac{1}{out_u + 1}\sum\limits_{(u, v) \in R}{\sum\limits_{d = v}^{u} f_d}$$

我们再设 $sum_i$ 表示 $f_i$ 的前缀和，$sum_i = \sum\limits_{j = 1}^{i} f_i$，有

$$f_u = 1 + \frac{1}{out_u + 1}\sum\limits_{(u, v) \in R}(sum_u - sum_{v - 1})$$

因为 $sum_u = sum_{u - 1} + f_u$，左右两边都有 $f_u$ 不好转移。

所以我们将所有右边的 $f_u$ 调到左边去。

我们先将两边同时乘以 $out_u + 1$：

$$
\begin{aligned}

(out_u + 1)f_u &= out_u + 1 + \sum\limits_{(u, v) \in R}(sum_u - sum_{v - 1})\\
&= out_u + 1 + \sum\limits_{(u, v) \in R}(f_u + sum_{u - 1} - sum_{v - 1})\\
&= out_u + 1 + out_uf_u + \sum\limits_{(u, v) \in R}(sum_{u - 1} - sum_{v - 1})\\
(out_u + 1)f_u - out_uf_u  &= out_u + 1 + \sum\limits_{(u, v) \in R}(sum_{u - 1} - sum_{v - 1})\\
f_u  &= out_u + 1 + \sum\limits_{(u, v) \in R}(sum_{u - 1} - sum_{v - 1})\\
\end{aligned}
$$

这就是递推式，最终的答案就是 $E_{1\rightarrow n + 1} = \sum\limits_{i = 1}^{n}E_{i\rightarrow i + 1} = sum_n$。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1000010, MOD = 998244353;

int id, n, m;
int d[N], f[N], sum[N];
vector<int> edge[N];

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> id >> n >> m;
	for (int i = 1; i <= m; i++) {
		int u, v;
		cin >> u >> v;
		d[u]++;
		edge[u].push_back(v);
	}
	for (int i = 1; i <= n; i++) {
		f[i] = d[i] + 1;
		for (auto x : edge[i]) f[i] = (1ll * f[i] + sum[i - 1] - sum[x - 1]) % MOD;
		sum[i] = (1ll * sum[i - 1] + f[i]) % MOD;
	}
	cout << (sum[n] % MOD + MOD) % MOD << '\n';
	return 0;
}
```

## 参考文献

[题解 P6835 【[Cnoi2020]线形生物】](https://www.luogu.com.cn/blog/infinity-dimension/solution-p6835)

---

## 作者：vectorwyx (赞：3)

~~要是知道这题这么好做打月赛的时候我就不看到期望就自动回退了~~


------------
蛮好的期望入门题，至少我这个一道期望题都没做过的蒟蒻都能10min推出式子（。

最原始直接的想法是令 $f_{i,j}$ 表示从点 $i$ 走到点 $i+j$ 所用的期望步数。那么如果我们通过一条返祖边由点 $i$ 回到了点 $w$，它对于$f_{i,j}$的贡献就是 $\frac{1+f_{w,i-w}+f_{i,j}}{k+1}$ （ $k$ 为返祖边的条数），直接根据期望的定义求和即可转移。

但是很显然这样写我们的时空复杂度会爆炸，在这里我们需要用到期望的线性性来优化。

何为期望的线性性？简单的说，就是把一个事件拆成若干个子事件之后，这个事件的期望与这些子事件的期望之和是相同的。放到这题中，从点 $i$ 走到点 $i+j$ 可以拆分为从点 $i$ 走到点 $i+1$、从点 $i+1$ 走到点 $i+2$、……、从点 $i+j-1$ 走到点 $i+j$，因此从点 $i$ 走到点 $i+j$ 所用的期望步数就等于从点 $i$ 走到点 $i+1$的期望步数+从点 $i+1$ 走到点 $i+2$的期望步数+……+从点 $i+j-1$ 走到点 $i+j$ 的期望步数。也就是 $f_{i,j}=\sum_{k=i}^{i+j-1}f_{k,1}$。

因此，对于任何的 $f_{i,j}(j>1)$，都能用 $f_{x,1}$ 表示，原先状态的第二维就没有任何用处了。修改一下状态定义：令 $f_{i}$ 表示从点 $i$ 走向点 $i+1$ 所用的期望步数。转移方程就是  $f_{i}=\frac{(\sum_{j=1}^{k}\sum_{l=w_{j}}^{i-1}f(l))+k+1+k\times f_{i}}{k+1}$，其中 $k$ 为点 $i$ 的返祖边的数量，$w$ 为点 $i$ 的返祖边的终点的集合。

把分子中括号括起来的那一坨东西拿前缀和优化一下，令 $S_{i}=\sum_{j=1}^{i}f_{j}$，则 $f_{i}=\frac{(\sum_{j=1}^{k}S_{i-1}-S_{w_{j}-1})+k+1+k\times f_{i}}{k+1}$

令$a=\sum_{j=1}^{k}S_{i-1}-S_{w_{j}-1}$化简一下，得 $f_{i}=a+k+1$。非常简洁，时间复杂度为$O(n+m)$

（~~不会有人只看这个式子吧，不会吧不会吧~~）。

代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#define ll long long
#define fo(i,x,y) for(register int i=x;i<=y;++i)
#define go(i,x,y) for(register int i=x;i>=y;--i)
using namespace std;
inline int read(){ int x=0,fh=1; char ch=getchar(); while(!isdigit(ch)){ if(ch=='-') fh=-1; ch=getchar(); } while(isdigit(ch)){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*fh; }

const int maxn=1e6+5,yrz=998244353;
int f[maxn],S[maxn];
vector<int> w[maxn];

int main(){
	int id=read(),n=read(),m=read();
	fo(i,1,m){
		int x=read(),y=read();
		w[x].push_back(y);//记录返祖边 
	}
	fo(i,1,n){
		int k=w[i].size(),a=0;//k,a意义与文中相同 
		fo(j,0,k-1) a+=(S[i-1]+yrz-S[w[i][j]-1])%yrz,a%=yrz;
		f[i]=a+k+1;//转移 
		f[i]%=yrz;
		S[i]=(S[i-1]+f[i])%yrz;
	}
	cout<<S[n];
	return 0;
}
```


---

## 作者：wwlw (赞：2)

[Link](https://www.luogu.com.cn/problem/P6835)

-----------------

### 题目描述

有 $n$ 个点，最开始对于每个点 $i \in [1,n]$ 都有一条连向 $i+1$ 的有向边。

现在有额外的 $m$ 条边 $u\to v$，有 $v \leq u$ 。

求从 $1$ 号节点开始，走到 $n+1$ 号节点的期望步数。

### 解法

容易想到用 $f_i$ 表示从 $i$ 号节点走到 $i+1$ 号节点的期望步数，用 $d_i$ 表示点 $i$ 的出度。

那么有两种情况：

1. 直接从 $i$ 号节点走到 $i+1$ 号节点

$$E_1=\frac{1}{d_i}\times 1=\frac{1}{d_i}$$

2. 从 $i$ 号节点走到前面的某个点，然后再走回来

$$E_2=\frac{1}{d_i}\times\sum_{v\in son(i)} (1+\sum_{j=v}^{u} f_i)$$

则

$$f_i=E_1+E_2=1+\frac{1}{d_i}\times\sum_{v\in son(i)} \sum_{j=v}^{u} f_i$$

后面部分显然可以前缀和做差处理

令 $s_n=\sum_{i=1}^{n} f_i$

所以

$$f_i=1+\frac{1}{d_i}\times\sum_{v\in son(i)}(s_{i}-s_{v-1})=1+\frac{1}{d_i}\times\sum_{v\in son(i)}(f_i+s_{i-1}-s_{v-1})$$

考虑把 $f_i$ 移到一边

$$f_i=1+\frac{d_i-1}{d_i}\times f_i+\frac{1}{d_i}\times\sum_{v\in son(i)}(s_{i-1}-s_{v-1})$$

$$\frac{1}{d_i}\times f_i=1+\frac{1}{d_i}\times\sum_{v\in son(i)}(s_{i-1}-s_{v-1})$$

$$f_i=d_i+\sum_{v\in son(i)}(s_{i-1}-s_{v-1})$$

可以线性处理了，最终答案是 $s_n$

```cpp

#include<stdio.h>
#define Mod 998244353
#define N 1000007

inline int read(){
	int x=0,flag=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')flag=0;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-48;c=getchar();}
	return flag? x:-x;
}

struct E{
	int next,to;
}e[N];
int head[N],cnt,s[N],f[N];

inline void add(int id,int to){
	e[++cnt]=(E){head[id],to};
	head[id]=cnt;
}

int id,n,m;
int main(){
	id=read(),n=read(),m=read();
	for(int i=1;i<=m;i++){
		int u=read(),v=read();
		add(u,v);
	}
	f[0]=0,s[0]=0;
	for(int i=1;i<=n;i++){
		f[i]=1;
		for(int j=head[i];j;j=e[j].next){
			int k=e[j].to;
			f[i]=((f[i]+s[i-1]-s[k-1]+1)%Mod+Mod)%Mod;
		}
		s[i]=(s[i-1]+f[i])%Mod;
	//	printf("%d %d\n",f[i],s[i]);
	}
	printf("%d",s[n]);
}

```

---

## 作者：gxy001 (赞：2)

### 显然是期望 $\texttt{dp}$。

设 $f_i$ 为 $i$ 到 $i+1$ 的期望步数，$s_i=\sum\limits_{j=0}^{i}f_j$，$f_0=0$，$d_i$ 为 $i$ 点出度。
则有：
$$f_{i}=\frac{1+\sum\limits_{i\rightarrow j}(f_{i}+s_{i-1}-s_{j-1}+1)}{d_{i}}$$
注： $j \ne i+1$

其实就是分类讨论， $\dfrac {1} {d_i}$ 为直接前进不回头的贡献。$\dfrac{f_{i}+s_{i-1}-s_{j-1}+1}{d_i}$ 为先往回走的贡献，即回到 $j$（$1$），再从 $j$ 走回 $i$（$s_{i-1}-s_{j-1}$），再继续向 $i+1$ 前进（$f_i$）。

化简得：

$$f_id_i=(d_i-1)f_i+(d_i-1)s_{i-1}+d_i-\sum\limits_{i\rightarrow j} s_{j-1}$$
$$f_i=(d_i-1)s_{i-1}+d_i-\sum\limits_{i\rightarrow j} s_{j-1}$$

我们发现这个式子是无后效性的，可以递推。

### 时间复杂度

$\mathrm{O(n+m)}$，容易证明，我们会访问每条边恰好一次，并求出所有 $f_i\ (i\le n)$ 的值。

### 代码
```cpp
#include<cstdio>
int const mod=998244353;
int id,n,m,head[1000010],to[1000010],nxt[1000010],cnt,d[1000010];
long long f[1000010],s[1000010];
void add(int const &x,int const &y){
	to[++cnt]=y,nxt[cnt]=head[x],head[x]=cnt,++d[x];
}
int main(){
	scanf("%d%d%d",&id,&n,&m);
	for(int i=1,x,y;i<=m;i++)scanf("%d%d",&x,&y),add(x,y);
	for(int i=1;i<=n;i++){
		f[i]=d[i]*s[i-1]+d[i]+1;
		for(int j=head[i];j;j=nxt[j])f[i]-=s[to[j]-1];
		f[i]=(f[i]%mod+mod)%mod;
		s[i]=(s[i-1]+f[i])%mod;
	}
	printf("%lld",s[n]);
	return 0;
}
```

---

## 作者：yinpeichu2021 (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P6835)

## 思路

显然期望 dp，设 $f_i$ 表示从 $i$ 号台阶到 $n+1$ 号台阶的期望步数。则显然有式（其中 $d_i$ 表示 $i$ 号点开始的返祖边的数量，$i\to j$ 表示存在一条从 $i$ 到 $j$ 的边）：

$$
f_i=1+\sum\limits_{i\to j}\dfrac{f_j}{d_i+1}
$$

将 $i\to i+1$ 的边单独计算，得到：

$$
f_i=1+\dfrac{f_{i+1}}{d_i+1}+\sum\limits_{i\to j,j\ne i+1}\dfrac{f_j}{d_i+1}
$$

整理，得：

$$
(d_i+1)f_i=d_i+1+f_{i+1}+\sum\limits_{i\to j,j\ne i+1}f_j
$$

由此，可得到：

$$
f_{i+1}=(d_i+1)f_i-(d_i+1)-\sum\limits_{i\to j,j\ne i+1}f_j
$$

此式对于 $1\le i\le n$ 成立，边界情况为 $f_{n+1}=0$，答案即为 $f_1$ 的值。

设 $f_1=x$。由于上式中 $j\le i$ 必成立，故显然对于 $2\le i\le n+1$，$f_i$ 均可表示成 $f_i=k_ix+b_i$ 的形式，其中 $k_i,b_i$ 均可算出（详见代码）。

由 $f_{n+1}=0$ 即 $k_{n+1}x+b_{n+1}=0$，容易解出 $f_1=x$ 的值。

## Code

```cpp
#include<bits/stdc++.h>
#define eps 1e-6
#define MOD 998244353
#define inf 0x3f3f3f3f
#define INF 0x3f3f3f3f3f3f3f3f
#define pi 3.14159265358979323846
using namespace std;
typedef long long LL;
typedef long double LD;
typedef unsigned long long ULL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pLL;// kx+b
typedef complex<LD> cp;
#define fi first
#define se second
#define MAXN 1000005
int n,m;
vector<int>v[MAXN];
pLL f[MAXN];// 表示 f_i=kx+b 的 {k,b}
pLL operator%(pLL a,LL b){return {a.fi%b,a.se%b};}
pLL operator+(pLL a,pLL b){return pLL{a.fi+b.fi,a.se+b.se}%MOD;}
pLL operator-(pLL a,pLL b){return pLL{a.fi-b.fi+MOD,a.se-b.se+MOD}%MOD;}
pLL operator*(pLL a,LL b){return pLL{a.fi*b,a.se*b}%MOD;}
// 重载运算符，方便计算 kx+b 的相加
LL ksm(LL a,int b){// 快速幂
	LL res=1;
	while(b){
		if(b&1)res=res*a%MOD;
		a=a*a%MOD,b/=2;
	}
	return res;
}
void solve(){
	int id;cin>>id>>n>>m;
	for(int i=1;i<=m;i++){
		int a,b;cin>>a>>b;
		v[a].push_back(b);
	}
	f[1]={1,0};// f_1=x
	for(int i=1;i<=n;i++){
		f[i+1]=f[i]*(v[i].size()+1)-pLL{0,v[i].size()+1};
		// 前半部分，d_i=v[i].size()
		for(int j:v[i])f[i+1]=f[i+1]-f[j];
		// 后半部分
	}
	auto [k,b]=f[n+1];
	// f_{n+1}=kx+b=0
	// x=-b/k
	cout<<(MOD-b)%MOD*ksm(k,MOD-2)%MOD;
}
signed main(){
	int T=1;//cin>>T;
	while(T--)solve();
	return 0;
}
```

---

## 作者：Polaris_Dane (赞：1)

一眼高斯消元，然后发现了$n\leq 1e6$瞬间暴毙，~~其实我并没有写过高斯消元~~

考虑使用$f_i$代表从$i$走到$i+1$的期望步数

令$s_i=\sum\limits_{j=1}^if_j$

那么对于任意两点$i<j$都有从$i$到$j$期望步数为$s_{j-1}-s_{i-1}$

那么对于一个点$i$，设其返祖边集合为$S$

$f_i=\dfrac {1} {d+1}(1+\sum\limits_{j\in S}(s_{i-1}-s_{j-1}+f_i+1))=1+\dfrac {1} {d+1}\sum\limits_{j\in S}(s_{i-1}-s_{j-1}+f_i)$

移项后得到$f_i=1+\sum\limits_{j\in S}(s_{i-1}-s_{j-1}+1)$

答案就是$s_n$

貌似也可以设$f_i$为从第$i$个点到最后$n+1$的期望步数

然后通过有关$f_1$和常数项的系数递推什么的

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<set>
#include<queue>
#define M 1010000
#define inf 0x3f3f3f3f
#define LL long long
#define int long long
const int mod=998244353;
using namespace std;
inline int read(){
	int f=1,x=0;char s=getchar();
	while (!isdigit(s)){if(s=='-')f=-1;s=getchar();}
	while (isdigit(s)){x=(x<<1)+(x<<3)+(s^48),s=getchar();}
	return x*f;
}
int id,n,m,s[M],f[M];vector<int>g[M];
signed main(void){
	id=read(),n=read(),m=read();
	for (int i=1;i<=m;i++){
		int u=read(),v=read();
		g[u].push_back(v);	
	}
	for (int i=1;i<=n;i++){
		f[i]=1;
		for (int j=0;j<g[i].size();j++)
			f[i]=(f[i]+(s[i-1]-s[(int)(g[i][j])-1]+mod)%mod+1)%mod;
		s[i]=(s[i-1]+f[i])%mod;	
	}printf("%lld",s[n]);
	return 0;
}

```


---

## 作者：SisconHL (赞：0)

萌新第一次做期望题，也是第一次自己推式子，不知道哪些可以省略，写得有点繁琐请大家包含 ~

明确一点，$E_{x\to y}+E_{y\to z}=E_{x\to z}$，感性理解即可，要经常用到。

对于点 $x$，设有 $d_x$ 条返祖边，返祖边集设为 $S$。

则它有 $\dfrac 1{d_x+1}$ 的概率直接到达 $x+1$，有 $\dfrac {d_x}{d_x+1}$ 的概率返祖。

可以写出转移方程：

$$E_{x\to x+1}=\dfrac 1{d_x+1}\times 1+\dfrac 1{d_x+1}\sum_{x,y\in S}(1+E_{y\to x+1})$$

现在就来颓这个式子吧！

$$E_{x\to x+1}=\dfrac 1{d_x+1}\times 1+\dfrac 1{d_x+1}\sum_{x,y\in S}(1+E_{y\to x+1})$$

$$E_{x\to x+1}=1+\dfrac 1{d_x+1}\sum_{x,y\in S}E_{y\to x+1}$$

$$E_{x\to x+1}=1+\dfrac 1{d_x+1}\sum_{x,y\in S}(E_{1\to x}+E_{x\to x+1}-E_{1\to y})$$

$$(d_x+1)E_{x\to x+1}=d_x+1+\sum_{x,y\in S}(E_{1\to x}+E_{x\to x+1}-E_{1\to y})$$

$$(d_x+1)E_{x\to x+1}=d_x+1+d_x(E_{1\to x}+E_{x\to x+1})-\sum_{x,y\in S}E_{1\to y}$$

$$E_{x\to x+1}=d_x+1+d_xE_{1\to x}-\sum_{x,y\in S}E_{1\to y}$$

$$E_{1\to x+1}=(d_x+1)(E_{1\to x}+1)-\sum_{x,y\in S}E_{1\to y}$$

就可以 $\mathcal O(n+m)$ 递推啦 ~\(≧▽≦)/~

代码：

```cpp
#include<iostream>
#include<vector>
using namespace std;
const int maxn=1e6+10;
const int mod=998244353;
struct Node{
	int size;vector<int> v;
	void adde(int x){v.push_back(x);size++;}
	Node():size(0){}
};
Node node[maxn];
long long E[maxn];
int main(){
	cin.tie(0);ios::sync_with_stdio(false);
	int id,n,m,x,y;
	cin>>id>>n>>m;
	for(int i=0;i<m;i++){cin>>x>>y;node[x].adde(y);}
	for(int i=1;i<n+5;i++)E[i]=0;
	for(int i=1;i<=n;i++){
		E[i+1]=(node[i].size+1)%mod*(E[i]+1)%mod;
		for(int j=0;j<node[i].size;j++) E[i+1]+=(mod-E[node[i].v[j]]),E[i+1]%=mod;
	}
	cout<<E[n+1];
} 
```

---

## 作者：tongyf (赞：0)

评价：很好的一道期望DP，防止了期望DP“设从当前到终点期望为状态”的惯性思维

---

[题面](https://www.luogu.com.cn/problem/P6835)

思路：

我们发现按照上面提到的惯性思维设$f(i)$为从$i$到$n+1$期望步数为状态根本无法转移，因为有后效性

那么怎么样没有后效性呢？

我们设$f(i)$为从$i$到$i+1$期望步数

那么有转移方程：

$f(i)=\frac{\sum^{du}_{j=1} ((\sum^{i}_{k=pre(i,j)}f(k))+1)}{du}$

其中$du$为当前点出边数+1

解释一下转移方程：

$\sum^{i}_{k=pre(i,j)}f(k)$是因为有可能返祖，然后要从返祖边的目标点回来，$+1$是因为当前点到下一个点要走一步

当$j=du$时$\sum^{i}_{k=pre(i,j)}f(k)=0$

化简一下上面的转移方程：

$f(i)=\frac{(\sum^{du}_{j=1} \sum^{i-1}_{k=pre(i,j)}f(k))+(du-1)*f(i)}{du}+1$

$(1-\frac{du-1}{du})f(i)=\frac{\sum^{du}_{j=1} \sum^{i-1}_{k=pre(i,j)}f(k)}{du}+1$

$f(i)=\sum^{du}_{j=1} \sum^{i-1}_{k=pre(i,j)}f(k)+du$

$\sum^{i-1}_{k=pre(i,j)}$可以前缀和优化

时间复杂度$O(n+m)$

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
int id,n,m,f[1000005],sum[1000005];
vector<int> e[1000005];
int read(){
	int f=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		f=f*10+ch-'0';
		ch=getchar();
	}
	return f*w;
}
signed main(){
	id=read(),n=read(),m=read();
	for(int i=1;i<=m;i++){
		int u=read(),v=read();
		e[u].push_back(v);
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<e[i].size();j++){
			f[i]=((f[i]+sum[i-1]-sum[e[i][j]-1])%mod+mod)%mod;
		}
		f[i]=(f[i]+e[i].size()+1)%mod;
		sum[i]=(sum[i-1]+f[i])%mod;
	}
	printf("%lld\n",sum[n]);
	return 0;
}

```

---


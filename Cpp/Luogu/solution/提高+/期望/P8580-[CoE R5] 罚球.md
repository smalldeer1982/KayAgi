# [CoE R5] 罚球

## 题目描述

有 $n$ 个人在玩罚球游戏，游戏规则如下：
- 每个人编号为 $1,2,\dots,n$，最开始由 $1$ 号罚球，接下来让下一个没有出局的人罚球。特殊地，$n$ 号的下一个是 $1$ 号。
- 如果罚球者没有碰到篮板，那么直接出局。
- 如果罚球者碰到篮板但没有进球，那么如果上一个人进球了，这个人就会出局，否则不会出局。
- 游戏结束的条件是最后只剩下一个人。

注意最开始的那个人碰到篮板但没有进球不出局。

这 $n$ 个人中，第 $i$ 个人碰不到篮板的概率为 $\dfrac{a_i}{1000}$，碰到篮板但没有进球的概率为 $\dfrac{b_i}{1000}$，求游戏结束时所有人总共罚球数量的期望值。

## 说明/提示

**关于取模**

不会有理数取模的看[这里](https://www.luogu.com.cn/problem/P2613)。



------------
**样例说明**

输入 $\#1$：

所有人碰不到篮板的概率都是 $\dfrac{1}{5}$，碰到篮板但不进球的概率都是 $\dfrac{2}{5}$，罚球数量的期望值为 $\dfrac{25}{9}$。

计算如下（黑色表示出局，红色表示没进球但不出局，蓝色表示进球）：
$$\dfrac{1}{5}+\red{\dfrac{2}{5}}\times(\dfrac{1}{5}+\red{\dfrac{2}{5}}\times(...)+\blue{\dfrac{2}{5}}\times(...))+\blue{\dfrac{2}{5}}\times(\dfrac{3}{5}+\blue{\dfrac{2}{5}}\times(...))=\dfrac{25}{9}$$

输入 $\#2$：

所有人碰不到篮板的概率都是 $\dfrac{321}{1000}$，碰到篮板但不进球的概率都是 $\dfrac{637}{1000}$，罚球数量的期望值为 $\dfrac{1000000}{57959}$。

------------

**数据范围**

**本题采用捆绑测试**。

测试点性质：
| $t=$ | 性质 | 分数 |
| :----------: | :----------: | :----------: |
| $1$ | $n=1$ | $2$ |
| $2$ | $a_i=b_i=0$ | $2$ |
| $3$ | $a_i=1000$ | $4$ |
| $4$ | $b_i=1000$ | $4$ |
| $5$ | $a_i=0,b_1=0,\forall i>1,b_i=1000$ | $6$ |
| $6$ | $a_i=b_i=500$ | $6$ |
| $7$ | $a_i=0,b_i=500$ | $6$ |
| $8$ | $a_i,b_i$ 均为定值，且答案不为 $-1$ | $19$ |
| $9$ | $1 \le n \le 11$ | $26$ |
| $10$ | $1 \le n \le 15$ | $8$ |
| $11$ | 无特殊性质 | $17$ |

**对于** $100\%$ **的数据**，$1 \le n \le 18$，$0 \le a_i,b_i,a_i+b_i \le 1000$。

本题的 $\text{Subtask 10}$ 分为两部分计分，对应 $t \in \{10,11\}$。

保证不存在分母为 $10^6+33$ 的倍数的情况。

## 样例 #1

### 输入

```
2 8
200 400
200 400```

### 输出

```
888921```

## 样例 #2

### 输入

```
7 8
321 637
321 637
321 637
321 637
321 637
321 637
321 637```

### 输出

```
818968```

## 样例 #3

### 输入

```
6 10
338 270
229 413
132 133
141 173
157 686
616 250```

### 输出

```
315860```

## 样例 #4

### 输入

```
8 10
338 270
229 413
132 133
141 173
157 686
616 250
0 0
0 0```

### 输出

```
-1```

# 题解

## 作者：Alarm5854 (赞：5)

来自本题出题人官方题解，过了近两个月才想起来发，写得很丑，赛时果然被爆标了。
## 题意
一开始有一个带 $n$ 个点的环，从 $1$ 到 $n$ 顺时针排列。

设上一个点返回的状态为 $x$，则：
- 若 $x=1$，则这个环上第 $i$ 个点有 $\dfrac{a_i}{1000}$ 的概率返回 $1$ 且删除这个点，有 $\dfrac{b_i}{1000}$ 的概率返回 $1$ 但保留这个点，有 $\dfrac{1000-a_i-b_i}{1000}$ 的概率返回 $2$ 且保留这个点。
- 若 $x=2$，则这个环上第 $i$ 个点有 $\dfrac{a_i+b_i}{1000}$ 的概率返回 $1$ 且删除这个点，有 $\dfrac{1000-a_i-b_i}{1000}$ 的概率返回 $2$ 且保留这个点。

初始 $x=1$，从 $1$ 号点开始进行上述操作，操作完后找到沿顺时针方向下一个点，这个点成为下一个操作的点。

求只剩一个点的期望操作次数，若期望次数为无穷大，输出 $-1$，否则输出这个概率对 $10^6+33$ 取模的值，可以证明答案为有理数。

## 前置知识
期望，状压，高斯消元。

## 子任务 $1$
很明显，一开始就只有一个点，期望改变状态次数为 $0$。  

期望得分 $2$ 分。
## 子任务 $2$
这时每个点肯定会返回 $2$ 且被保留，因此当 $n>1$ 时期望次数为无穷大，$n=1$ 时期望次数为 $0$。  

期望得分 $4$ 分（这里的期望得分均为结合前面的子任务的得分）。
## 子任务 $3$
这时每个点肯定会返回 $1$ 且被删除，因此到 $n$ 号点的时候就只剩一个点了，答案即为 $n-1$。  

期望得分 $8$ 分。
## 子任务 $4$
这时每个点肯定会返回 $1$ 且被保留，因此情况同子任务 $2$。  

期望得分 $12$ 分。
## 子任务 $5$
这时 $1$ 号点一直返回 $2$，设这是第 $i$ 圈，则 $i+1$ 号点会返回 $1$ 并被删除，$i+2\sim n$ 会返回 $1$ 并被保留。第 $i(i<n)$ 圈的操作次数为 $n-i+1$，第 $n$ 圈不用操作，故答案为 $\dfrac{n(n+1)}{2}-1$。  

期望得分 $18$ 分。
## 子任务 $6$
这时每个点都本质相同，且没有任何点返回 $2$，设 $f(n)$ 为剩 $n$ 个点时的期望次数，则
$$f(1)=0,f(n)=\dfrac{1}{2}(f(n-1)+f(n))+1$$
得出
$$f(n)=2(n-1)$$  

期望得分 $24$ 分。
## 子任务 $7$
这时每个点仍然本质相同，设 $f(n)$ 为剩 $n$ 个点，且 $x=1$ 的期望次数，$g(n)$ 为剩 $n$ 个点，且 $x=2$ 的期望次数。

那么有
$$f(1)=0,f(n)=\dfrac{1}{2}(f(n)+g(n))+1$$
$$g(n)=\dfrac{1}{2}(f(n-1)+g(n))+1$$
得出
$$f(n)=4(n-1)$$
期望得分 $30$ 分。
## 子任务 $8$
其实就是子任务 $6,7$ 的拓展版本，按照前面所说，则
$$f(1)=0,f(n)=\dfrac{a_i}{1000}f(n-1)+\dfrac{b_i}{1000}f(n)+\dfrac{1000-a_i-b_i}{1000}g(n)+1$$
$$g(n)=\dfrac{a_i+b_i}{1000}f(n-1)+\dfrac{1000-a_i-b_i}{1000}g(n)+1$$
解得
$$f(n)=\dfrac{1000\times (n-1)}{(a_i+b_i)\times(1-b_i)}$$
期望得分 $49$ 分。
## 子任务 $9$
进入正题，由于 $n\le11$，于是可以想到状压。

从这里开始 $a_i$ 表示前面的 $a_{i+1}$。

设 $f(S,i)$ 表示剩余的点的状态为 $S$，现在在这个状态中第 $i$ 个为 $1$ 的地方 **(0下标)** ，上一个点的返回值为 $1$ 的期望局数，$g(S,i)$ 和 $f(S,i)$ 的区别在于变成上一个点返回值为 $2$ 的期望局数，则有：
$$f(2^k,x)=0(k\in \mathbb{N},x\le k)$$
这就是题目中的定义，$f(S,i)$ 的转移为：
$$
\begin{aligned}
f(S,i)&=\dfrac{a_{S_i}}{1000}f(S\oplus 2^{S_i},i\bmod (|S|-1))\\&+\dfrac{b_{S_i}}{1000}f(S,(i+1)\bmod |S|)\\&+\dfrac{1000-a_{S_i}-b_{S_i}}{1000}g(S,(i+1)\bmod |S|)
\end{aligned}
$$
$$
\begin{aligned}
g(S,i)&=\dfrac{a_{S_i}+b_{S_i}}{1000}f(S\oplus 2^{S_i},i\bmod (|S|-1))\\&+\dfrac{1000-a_{S_i}-b_{S_i}}{1000}g(S,(i+1)\bmod |S|)
\end{aligned}
$$
这样，可以考虑对于每一个 $S\in[1,2^n),S\neq 2^k,k\in\mathbb{N}$，都列出这样的 $2\times |S|$ 元的线性方程，可以用高斯消元解决。

至于怎么高斯消元，需要对上述的式子进行变形：
$$
\begin{aligned}
f(S,i)&-\dfrac{b_{S_i}}{1000}f(S,(i+1)\bmod |S|)-\dfrac{1-a_{S_i}-b_{S_i}}{1000}g(S,(i+1)\bmod |S|)\\&=\dfrac{a_{S_i}}{1000}f(S\oplus 2^{S_i},i\bmod (|S|-1))
\end{aligned}
$$
$$
\begin{aligned}
g(S,i)&-\dfrac{1000-a_{S_i}-b_{S_i}}{1000}g(S,(i+1)\bmod |S|)\\&=\dfrac{a_{S_i}+b_{S_i}}{1000}g(S\oplus 2^{S_i},i\bmod (|S|-1))
\end{aligned}
$$
这样就能够把高斯消元矩阵构造出来了，大小为 $2n\times(2n+1)$。

尤其需要注意的是如果出现了除以 $0$ 的情况，一定要把这个答案弄成一个不在 $[0,p)$ 范围内的数并进行特判，否则会出问题。

朴素的高斯消元复杂度为 $O(n^3)$，快速幂的复杂度为 $O(\log p)$，其中 $\log p$ 与 $n$ 同阶，故时间复杂度为 $O(2^n\times n^4)$（实际上是 $O(2^n\times n^3\times \log p)$）。

期望得分 $75$ 分。
## 子任务 $10$
由于 $p=10^6+33$，所以考虑预处理逆元，这样可以将复杂度降至 $O(2^n\times n^3)$。

期望得分 $83$ 分。
## 子任务 $11$
发现这个矩阵是个稀疏矩阵，每列非 $0$ 的元素数量很少，对于一列为 $0$ 的，就不需要进行减法，因为这是无效的，这样复杂度可以降至 $O(2^n\times n^2)$。

期望得分 $100$ 分。
## 标程
```cpp
//去掉注释后长度：2053字节
#include<ctime>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
const ll p=1e6+33;
const ll N=18;
int read(){
	char c;
	int x=0,f=1;
	while(!isdigit(c=getchar()))
		f-=2*(c=='-');
	while(isdigit(c)){
		x=x*10+f*(c-48);
		c=getchar();
	}
	return x;
}
ll n,t,k,a[21],b[21],f[1<<N][21];
ll l[1<<N],g[1<<N],c[37][37],s[37];
ll inv[p];
void gauss(ll n){
	for(ll i=0;i<n;++i){
		ll t=i;
		for(ll j=i;j<n;++j){
			if(c[j][i]){
				t=j;
				break;
			}
		}
		if(!c[t][i])
			continue;
		swap(c[i],c[t]);
		for(ll j=i+1;j<n;++j){
			if(!c[j][i])//优化
				continue;
			ll x=c[j][i]*inv[c[i][i]];
			for(ll k=i;k<=n;++k){
				if(~c[j][k])
					c[j][k]=(c[j][k]-x*c[i][k]%p+p)%p;
			}
		}
	}
	for(ll i=n-1;~i;--i){
		if(!c[i][i]||!~c[i][n])
			s[i]=-1;//这里的-1即为特殊值，需要特判
		else
			s[i]=c[i][n]*inv[c[i][i]]%p;
		if(!i)
			continue;
		for(ll j=i-1;~j;--j){
			if(~c[j][n]&&(~s[i]||!c[j][i]))//仍然需要特判-1
				c[j][n]=(c[j][n]-c[j][i]*s[i]%p+p)%p;
			else
				c[j][n]=-1;
			c[j][i]=0;
		}
	}
}
int main(){
	n=read();
	t=read();
	inv[1]=1;
	k=1<<n;
	for(ll i=2;i<p;++i)
		inv[i]=(p-p/i)*inv[p%i]%p;//线性处理逆元
	for(ll i=0;i<n;++i){
		a[i]=read()*inv[1000]%p;//提前进行转化
		b[i]=read()*inv[1000]%p;
	}
	for(ll i=1;i<k;++i)
		l[i]=l[i^(i&-i)]+1;
	for(ll i=0;i<n;++i)
		g[1<<i]=i;
	for(ll i=1;i<k;++i){
		if(l[i]==1)
			continue;
		memset(c,0,sizeof(c));//初始清空矩阵
		for(ll j=0,t=i;t;t^=t&-t,++j){
			ll x=g[t&-t];
			c[j*2][j*2]=1;
			c[j*2+1][j*2+1]=1;
			c[j*2][(j*2+2)%(l[i]*2)]=(p-b[x]%p)%p;
			c[j*2][(j*2+3)%(l[i]*2)]=(a[x]+b[x]-1+p)%p;//由于一开始进行了处理，所以就不再是a[x]+b[x]-1000了
			c[j*2+1][(j*2+3)%(l[i]*2)]=(a[x]+b[x]-1+p)%p;
			if(~f[i^(1<<x)][j%(l[i]-1)]||!a[x])
				c[j*2][l[i]*2]=(a[x]*f[i^(1<<x)][j%(l[i]-1)]+1)%p;
			else
				c[j*2][l[i]*2]=-1;
			if(~f[i^(1<<x)][j%(l[i]-1)]||!(a[x]+b[x]))
				c[j*2+1][l[i]*2]=((a[x]+b[x])*f[i^(1<<x)][j%(l[i]-1)]+1)%p;
			else
				c[j*2+1][l[i]*2]=-1;
        //c[j*2]为f所对应的位置，c[j*2+1]为g所对应的位置
		}
		gauss(l[i]*2);
		for(int j=0;j<l[i];++j)
			f[i][j]=s[j*2];
	}
	printf("%lld\n",f[k-1][0]);
	return 0;
}
```

---

## 作者：Nazq (赞：5)

### 定义状态
由于是环，且数据范围较小，考虑状压。

可以发现转移是和上一个人的罚球情况相关，可能会想到用 $0 / 1 / 2$ 来维护上一个人碰不到篮板、碰到没有进球、进球的情况（下述依次称为 $A, B, C$），但发现前两种状态对当前状态的影响是相同的，就合并前两个状态。
而且我们转移还要记录当前的人在环中的编号。
综上，定义 $f(S, i, 0 / 1)$，意为从 $S$ 状态一直罚球只剩一个人的期望次数，用 $0$ 表示上个人没进，$1$ 代表进了。

### 状态转移

转移，是根据当前的人的决策推到下一个状态。

当上一个人投中了，当前的人有三种情况，有 $A$ 和 $B$ 会下场，且本次罚球期望为 $1$。

$f(S, i, 1) = a_i f(S \setminus \{i\}, \mathrm{next}_i, 0) + b_i f(S \setminus \{i\}, \mathrm{next}_i, 0) + c_i f(S, \mathrm{next}_i, 1) + 1.$

当上一个人没投中，当前的人有三种情况，只有 $A$ 会下场，且本次罚球期望为 $1$。

$f(S, i, 0) = a_i f(S \setminus \{i\}, \mathrm{next}_i, 0) + b_i f(S, \mathrm{next}_i, 0) + c_i f(S, \mathrm{next}_i, 1) + 1.$

### 消除后效性

由于转移有后效性，考虑高斯消元。

先消第 $1$ 个转移方程，第 $2$ 个就只有 $2$ 个变量。而且以这种顺序解，可以使 $0 / 1$（上一个人的进球状态）相同的放在一堆消元。

但需要优化。高斯消元优化的思路之一是减少枚举量。

矩阵大概长这样
$$
\begin{pmatrix}

1 & x & 0 & 0 & y \\
0 & 1 & x & 0 & y \\
0 & 0 & 1 & x & y \\
x & 0 & 0 & 1 & y

\end{pmatrix}
$$
手模一下，我们把 $1 \sim 3$ 行依次与最后一行相减，
$$
\begin{pmatrix}

1 & x & 0 & 0 & y \\
0 & 1 & x & 0 & y \\
0 & 0 & 1 & x & y \\
x & 0 & 0 & 1 & y

\end{pmatrix}
\to
\begin{pmatrix}

1 & x & 0 & 0 & y \\
0 & 1 & x & 0 & y \\
0 & 0 & 1 & x & y \\
0 & x & 0 & 1 & y

\end{pmatrix}
\to
\begin{pmatrix}

1 & x & 0 & 0 & y \\
0 & 1 & x & 0 & y \\
0 & 0 & 1 & x & y \\
0 & 0 & x & 1 & y

\end{pmatrix}
\to
\begin{pmatrix}

1 & x & 0 & 0 & y \\
0 & 1 & x & 0 & y \\
0 & 0 & 1 & x & y \\
0 & 0 & 0 & x & y

\end{pmatrix}
$$
这样就会 $O(n)$ 得到行阶梯形矩阵。

### 特判 $-1$ 的情况

1. 存在 $2$ 个及以上的百发百中选手。
2. 没有人进球，但至少有两个百分百碰篮板的人。

### Warning
$i$ 下场后，$\mathrm{next}_i$ 在环内的相对位置可能会变。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int Mod = 1e6 + 33, N = 25;
ll inv[Mod], a[N], b[N], c[N], f[2][N][1 << 18], co[N][N];
int n, t, tot[1 << 18], _n, pos[1 << 18][N], c1, c2, c3, rk[1 << 18][N];
void Init(){
    inv[1] = 1;
    for(int i = 2; i < Mod; ++i)
        inv[i] = inv[Mod % i] * (Mod - Mod / i) % Mod;
    scanf("%d%d", &n, &t);
    for(int i = 1; i <= n; ++i){
        scanf("%lld%lld", &a[i], &b[i]);
        (a[i] *= inv[1000]) %= Mod;
        (b[i] *= inv[1000]) %= Mod;
        c[i] = ((1 - a[i] - b[i]) % Mod + Mod) % Mod;
        if(!a[i] && !b[i])++c1;
        if(!a[i] && !c[i])++c2;
        if(!c[i])++c3;
    }
    _n = 1 << n;
    for(int i = 1; i < _n; ++i)
        tot[i] = tot[i ^ i & -i] + 1;
    for(int state = 1, cnt = 0; state < _n; ++state){
        cnt = 0;
        for(int i = 0; i < n; ++i)
            if(state & 1 << i){
                pos[state][i] = ++cnt;
                rk[state][cnt] = i;
            }
    }
}
void Print(const int& cnt){
    for(int i = 1; i <= cnt; ++i, putchar(10))
        for(int j = 1; j <= cnt + 1; ++j)
            cout << co[i][j] << ' ';
    putchar(10);
}
void Gauss(const int& cnt){
    ll tf = 0;
//    Print(cnt);
    for(int colum = 1; colum < cnt; ++colum){
        tf = co[cnt][colum] * inv[co[colum][colum]] % Mod;
        co[cnt][colum] = (Mod + (co[cnt][colum] - tf * co[colum][colum]) % Mod) % Mod;
        co[cnt][colum + 1] = (Mod + (co[cnt][colum + 1] - tf * co[colum][colum + 1]) % Mod) % Mod;
        co[cnt][cnt + 1] = (Mod + (co[cnt][cnt + 1] - tf * co[colum][cnt + 1]) % Mod) % Mod;
    }
    for(int i = cnt; i; --i){
        for(int j = i + 1; j <= cnt; ++j)
            co[i][cnt + 1] = (Mod + (co[i][cnt + 1] - co[j][cnt + 1] * co[i][j] % Mod) % Mod) % Mod;
        (co[i][cnt + 1] *= inv[co[i][i]]) %= Mod;
    }
}
int main(){
    Init();
    if(c1 > 1 || c3 == n && c2 > 1)
        return puts("-1"), 0;
    for(int state = 1, posi; state < _n; ++state){
        if(tot[state] == 1)continue;
        memset(co, 0, sizeof(co));
        for(int i = 1, j = 0; i <= tot[state]; ++i){
            posi = rk[state][i];
            j = i == tot[state] ? 1 : i + 1;
            co[i][i] = 1;
            co[i][j] = (Mod - c[posi + 1] % Mod) % Mod;
            co[i][tot[state] + 1] = (a[posi + 1] * f[0][i == tot[state] ? j : j - 1][state ^ 1 << posi] % Mod + b[posi + 1] * f[0][i == tot[state] ? j : j - 1][state ^ 1 << posi] % Mod + 1) % Mod;
        }
        Gauss(tot[state]);
        for(int i = 1; i <= tot[state]; ++i)
            f[1][i][state] = co[i][tot[state] + 1];
        memset(co, 0, sizeof(co));
        for(int i = 1, j = 0; i <= tot[state]; ++i){
            posi = rk[state][i];
            j = i == tot[state] ? 1 : i + 1;
            co[i][i] = 1;
            co[i][j] = (Mod - b[posi + 1] % Mod) % Mod;
            co[i][tot[state] + 1] = (a[posi + 1] * f[0][i == tot[state] ? j : j - 1][state ^ 1 << posi] % Mod + c[posi + 1] * f[1][j][state] % Mod + 1) % Mod;
        }
        Gauss(tot[state]);
        for(int i = 1; i <= tot[state]; ++i)
            f[0][i][state] = co[i][tot[state] + 1];
    }
    printf("%lld\n", f[0][1][_n - 1]);
    return 0;
}
```

---

## 作者：QQ82272760 (赞：4)

虽然这题不算太难，但是这是我第一次在洛谷比赛中拿到一血的题，就写篇题解庆祝一下吧。

首先 $n\le 18$ 很容易想到容斥，设 $f_{S,i,1/0}$  表示出局的集合为 $S$，当前到第 $i$ 个人，上一个人是否投中的答案，分上一个人有没有投中讨论就能转移，注意这种期望题要倒过来转移。

你会发现所有转移并不能够成 DAG，但是只能从包含 $S$ 的集合转移到 $S$，因此可以倒序枚举 $S$，然后就能在转移出 $S$ 之前把所有包含 $S$ 的集合先处理掉了。

这样子每次转移出所有 $S$ 相同的状态，每次先找到一个 $i_0\not\in S$，然后设 $f_{S,i_0,0}=x,f_{S,i_0,1}=y$，然后发现每次想要得到的所有状态都能由 $x,y$ 表示出来，并且次数都是 $1$。当再次转移到 $i_0$ 这个位置的时候就能得到另外一种表达式，用高斯消元解出 $x,y$ 就能得到当前 $S$ 的答案。

由于矩阵比较小，我就手动高斯消元，结果代码十分难看。

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#define mod 1000033
#define vec vector<int>
using namespace std;
int n,t;
int a[18],b[18],c[18];
int pc[1<<18];
int f[1<<18][18][3];
int A[3][3],B[3];
vec g[18][3];
int add(int x,int y){
	if((x+=y)>=mod) x-=mod;
	return x;
}
int sub(int x,int y){
	if((x-=y)<0) x+=mod;
	return x;
}
int qp(int x,int y=mod-2){
	int res=1;
	while(y){
		if(y&1) res=1ll*res*x%mod;
		x=1ll*x*x%mod; y>>=1;
	}
	return res;
}
vec operator*(int x,vec y){
	for(int i=0;i<3;i+=1){
		y[i]=1ll*x*y[i]%mod;
	}
	return y;
}
vec operator+(vec x,vec y){
	for(int i=0;i<3;i+=1){
		x[i]=add(x[i],y[i]);
	}
	return x;
}
vec operator+(vec x,int y){
	x[0]=add(x[0],y);
	return x;
}
void solve(int s){
	int x,y,id;
	for(int i=0;i<n;i+=1){
		if(s>>i&1) continue;
		id=i; break;
	}
	g[id][0].clear(); g[id][1].clear();
	g[id][0].resize(3); g[id][0][1]=1;
	g[id][1].resize(3); g[id][1][2]=1;
	for(int i=(id+n-1)%n,j=id;;i=(i+n-1)%n){
		if(s>>i&1) continue;
		g[i][0].clear(); g[i][1].clear();
		g[i][0].resize(3); g[i][1].resize(3);
		g[i][0][0]=add(1ll*a[i]*f[s|(1<<i)][j][0]%mod,1);
		g[i][0]=(b[i]*g[j][0])+(c[i]*g[j][1])+g[i][0];
		g[i][1][0]=add(1ll*add(a[i],b[i])*f[s|(1<<i)][j][0]%mod,1);
		g[i][1]=(c[i]*g[j][1])+g[i][1];
		if((j=i)==id) break;
	}
	A[1][1]=sub(g[id][0][1],1); A[1][2]=g[id][0][2]; B[1]=sub(0,g[id][0][0]);
	A[2][1]=g[id][1][1]; A[2][2]=sub(g[id][1][2],1); B[2]=sub(0,g[id][1][0]);
	if(!A[1][1]){
		swap(A[1],A[2]); swap(B[1],B[2]);
	}
	x=1ll*A[2][1]*qp(A[1][1])%mod; B[2]=sub(B[2],1ll*x*B[1]%mod);
	A[2][1]=sub(A[2][1],1ll*x*A[1][1]%mod); A[2][2]=sub(A[2][2],1ll*x*A[1][2]%mod);
	x=1ll*A[1][2]*qp(A[2][2])%mod; B[1]=sub(B[1],1ll*x*B[2]%mod);
	A[1][1]=sub(A[1][1],1ll*x*A[2][1]%mod); A[1][2]=sub(A[1][2],1ll*x*A[2][2]%mod);
	x=1ll*B[1]*qp(A[1][1])%mod; y=1ll*B[2]*qp(A[2][2])%mod;
	for(int i=0;i<n;i+=1){
		if(s>>i&1) continue;
		f[s][i][0]=add(add(1ll*x*g[i][0][1]%mod,1ll*y*g[i][0][2]%mod),g[i][0][0]);
		f[s][i][1]=add(add(1ll*x*g[i][1][1]%mod,1ll*y*g[i][1][2]%mod),g[i][1][0]);
	}
	return;
}
int main(){
	int flag=1,cnt=0,cnt1=0;
	scanf("%d%d",&n,&t);
	for(int i=0;i<n;i+=1){
		scanf("%d%d",&a[i],&b[i]);
		if(!a[i]&&!b[i]) cnt+=1;
		if(b[i]==1000) cnt1+=1;
		a[i]=1ll*a[i]*qp(1000)%mod;
		b[i]=1ll*b[i]*qp(1000)%mod;
		c[i]=sub(1,add(a[i],b[i]));
	}
	if(n==1){
		printf("0\n");
		return 0;
	}
	if(cnt>1) flag=0;
	if(!cnt&&cnt1>1) flag=0;
	if(flag){
		for(int i=1;i<(1<<n);i+=1){
			pc[i]=pc[i>>1]+(i&1);
		}
		for(int i=(1<<n)-1;i>=0;i-=1){
			if(pc[i]>=n-1) continue;
			solve(i);
		}
		printf("%d\n",f[0][0][0]);
	}
	else printf("-1\n");
	return 0;
}
```

Thanks~

---

## 作者：do_while_true (赞：2)

为了简化记号，令 $a_i,b_i,c_i$ 为原题面中的 $\frac{a_i}{1000},\frac{b_i}{1000},\frac{1000-a_i-b_i}{1000}$．

$n$ 如此小，那就要大胆设 dp：

$f_{S,i,0/1}$ 表示当前状态为：存活集合是 $S$，由 $i$ 开始投球，上一个人是否投中，到最终终止时罚球数量的期望。根据定义，可以写出 dp 的式子（记 $nxt$ 为 $i$ 在 $S$ 中后一个罚球的人的编号）：

$$
f_{S,i,0}=a_i\cdot f_{S\backslash\{i\},nxt,0}+b_if_{S,nxt,0}+c_if_{S,nxt,1}+1
\\
f_{S,i,1}=a_i\cdot f_{S\backslash\{i\},nxt,0}+b_if_{S\backslash \{i\},nxt,0}+c_if_{S,nxt,1}+1
$$

因为转移出现了环，所以最暴力的想法是将所有 $f$ 放在一起高斯消元。

但是这个方程非常的特殊，所以考虑对高斯消元的复杂度进行优化。

首先是出现环的转移一定是同一个 $S$ 之内的，而对于一个 $S$ 计算其 $f$ 之前要计算出其子集的 $f$，于是按照集合 $S$ 大小从小到大对每个 $f_S$ 高斯消元。

现在方程中所有 $f_{S\backslash\{i\}}$ 的部分都变成已经计算出来了的常数了。再进一步观察转移式子，发现 $f_{S,i,1}$ 内部的转移是个环，那么单独计算出 $f_{S,i,1}$ 后，$f_{S,i,0}$ 式子里的 $f_{S,nxt,1}$ 就变成常数了，再单独计算 $f_{S,i,0}$．

此时再观察 $f_{S,i,1}$，发现每个方程仅有两个系数非零的元 $f_{S,i,1}$ 和 $f_{S,nxt,1}$，其系数矩阵是一个带状矩阵，那么用主元法就可以在 $\mathcal{O}(|S|)$ 的复杂度内求解出所有 $f_{S,i,1}$ 的值。

求出 $f_{S,i,1}$ 后，用同样的方法求解 $f_{S,i,0}$ 即可。

由于这里采用主元法来解方程的复杂度是关于状态个数线性的，所以总时间复杂度是 $\mathcal{O}(2^nn)$．

还有两个无解的情况要判，分别是出现了至少两个百发百中的人，以及所有人都进不了球且至少两个只碰篮板，这两种情况。

```cpp
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<ctime>
#include<random>
#include<assert.h>
#define pb emplace_back
#define mp make_pair
#define fi first
#define int long long
#define se second
#define dbg(x) cerr<<"In Line "<< __LINE__<<" the "<<#x<<" = "<<x<<'\n';
#define dpi(x,y) cerr<<"In Line "<<__LINE__<<" the "<<#x<<" = "<<x<<" ; "<<"the "<<#y<<" = "<<y<<'\n';
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef pair<int,int>pii;
typedef pair<ll,int>pli;
typedef pair<ll,ll>pll;
typedef pair<int,ll>pil;
typedef vector<int>vi;
typedef vector<ll>vll;
typedef vector<pii>vpii;
typedef vector<pil>vpil;
template<typename T>T cmax(T &x, T y){return x=x>y?x:y;}
template<typename T>T cmin(T &x, T y){return x=x<y?x:y;}
template<typename T>
T &read(T &r){
	r=0;bool w=0;char ch=getchar();
	while(ch<'0'||ch>'9')w=ch=='-'?1:0,ch=getchar();
	while(ch>='0'&&ch<='9')r=r*10+(ch^48),ch=getchar();
	return r=w?-r:r;
}
template<typename T1,typename... T2>
void read(T1 &x,T2& ...y){read(x);read(y...);}
const int mod=1000033;
inline void cadd(int &x,int y){x=(x+y>=mod)?(x+y-mod):(x+y);}
inline void cdel(int &x,int y){x=(x-y<0)?(x-y+mod):(x-y);}
inline int add(int x,int y){return (x+y>=mod)?(x+y-mod):(x+y);}
inline int del(int x,int y){return (x-y<0)?(x-y+mod):(x-y);}
int qpow(int x,int y){
	int s=1;
	while(y){
		if(y&1)s=1ll*s*x%mod;
		x=1ll*x*x%mod;
		y>>=1;
	}
	return s;
}
mt19937 rnd(time(NULL)^(ull)(new char));
int bit(int x){
	return 1<<(x-1);
}
const int N=19;
int n,T;
int a[N],b[N],c[N],inv1000=qpow(1000,mod-2);
int nxt[N];
int f[(1<<18)+10][N][2];
vi vec[N];
int m,u[N],v[N],w[N],ans[N+1];
int iv[N];
void Gauss(){
	for(int i=1;i<=m;i++){
		iv[i]=qpow(v[i],mod-2);
	}
	int x=del(0,v[m]),y=w[m];
	for(int i=m-1;i>=2;i--){
		x=1ll*x*v[i]%mod;
		y=1ll*y*v[i]%mod;
		x=del(0,x);
		y=del(w[i],y);
	}
	ans[1]=1ll*del(w[1],1ll*v[1]*y%mod)*qpow(add(u[1],1ll*v[1]*x%mod),mod-2)%mod;
	ans[m+1]=ans[1];
	for(int i=m;i>=2;i--){
		ans[i]=del(w[i],1ll*ans[i+1]*v[i]%mod);
	}
}
void solve(int S){
	int lst=0,fir=0;
	vi p;
	for(int i=n;i>=1;i--){
		nxt[i]=0;
		if(bit(i)&S){
			p.pb(i);
			nxt[i]=lst;
			lst=i;
			if(!fir)fir=i;
		}
	}
	nxt[fir]=lst;
	reverse(p.begin(),p.end());
	m=p.size();
	for(int i=0;i<m;i++){
		int x=p[i];
		u[i+1]=1;
		v[i+1]=del(0,c[x]);
		w[i+1]=0;
		cadd(w[i+1],1ll*a[x]*f[S^bit(x)][nxt[x]][0]%mod);
		cadd(w[i+1],1ll*b[x]*f[S^bit(x)][nxt[x]][0]%mod);
		cadd(w[i+1],1);
	}
	Gauss();
	for(int i=0;i<m;i++)
		f[S][p[i]][1]=ans[i+1];
	//-----------------------------------
	for(int i=0;i<m;i++){
		int x=p[i];
		u[i+1]=1;
		v[i+1]=del(0,b[x]);
		w[i+1]=0;
		cadd(w[i+1],1ll*a[x]*f[S^bit(x)][nxt[x]][0]%mod);
		cadd(w[i+1],1ll*c[x]*f[S][nxt[x]][1]%mod);
		cadd(w[i+1],1);
	}
	Gauss();
	for(int i=0;i<m;i++)
		f[S][p[i]][0]=ans[i+1];
}
signed main(){
	#ifdef do_while_true
//		assert(freopen("data.in","r",stdin));
//		assert(freopen("data.out","w",stdout));
	#endif
	read(n,T);
	int ct1=0,ct2=0,ct3=0;
	for(int i=1;i<=n;i++){
		read(a[i],b[i]);
		a[i]=1ll*a[i]*inv1000%mod;
		b[i]=1ll*b[i]*inv1000%mod;
		c[i]=del(1,add(a[i],b[i]));
		if(a[i]==b[i]&&a[i]==0)++ct1;
		if(a[i]==c[i]&&c[i]==0)++ct2;
		if(c[i]==0)++ct3;
	}
	if(ct1>=2||(ct2>=2&&ct3==n)){
		puts("-1");
		return 0;
	}
	for(int i=1;i<=n;i++)
		f[bit(i)][i][0]=f[bit(i)][i][1]=0;
	for(int i=0;i<(1<<n);i++)
		vec[__builtin_popcount(i)].pb(i);
	for(int i=2;i<=n;i++)
		for(auto S:vec[i])
			solve(S);
	cout << f[(1<<n)-1][1][0] << '\n';
    #ifdef do_while_true
		cerr<<'\n'<<"Time:"<<1.0*clock()/CLOCKS_PER_SEC*1000<<" ms"<<'\n';
	#endif
	return 0;
}
```

---


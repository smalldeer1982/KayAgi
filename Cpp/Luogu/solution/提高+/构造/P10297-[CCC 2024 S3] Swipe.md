# [CCC 2024 S3] Swipe

## 题目描述


Swipe 是一款新的手机游戏，最近大受欢迎。在 Swipe 游戏的每一个关卡中，您都会得到两个长度为 $N$ 的数列 $A$ 和 $B$。Swipe 游戏的每个关卡的目标是把数组 $A$ 变成数组 $B$。

现在有两种可以对 $A$ 进行的滑动操作。

- 向右滑动：选择一个区间 $[l, r]$，对任意 $l \leq i \leq r$ 令 $A_i = A_l$。
- 向左滑动：选择一个区间 $[l, r]$，对任意 $l \leq i \leq r$ 令 $A_i = A_r$。

例如，一开始 $A = [0, 1, 2, 3, 4, 5]$，如果我们对区间 $[2, 4]$ 做向右滑动的操作，序列变为 $[0, 1, 2, 2, 2, 5]$。如果我们对区间 $[3, 5]$ 做向左滑动的操作，序列变为 $[0, 1, 2, 5, 5, 5]$。注意序列从 $0$ 开始编号。

不幸的是，游戏存在一些问题，可能会包含无法通过的关卡。请问是否可以将数组 $A$ 转换为数组 $B$。如果可以，请给出任意一种将数组 $A$ 转换为数组 $B$ 的滑动操作方案。


## 说明/提示

**本题采用捆绑测试。**

对于所有数据，保证 $1 \leq N \leq 3 \times 10^5$，$1 \leq A_i, B_i \leq 3 \times 10^5$。

下面的表格显示了 $15$ 分的分配方案：

| 分值 | $N$ 的范围 | $A_i$ 和 $B_i$ 的范围 |
| :-: | :-: | :-: |
| $2$ | $N = 2$ | $1 \leq A_i, B_i \leq 3$ |
| $4$ | $1 \leq N \leq 8$ | $1 \leq A_i, B_i \leq 8$ |
| $4$ | $1 \leq N \leq 500$ | $1 \leq A_i, B_i \leq 3000$ |
| $5$ | $1 \leq N \leq 3 \times 10^5$ | $1 \leq A_i, B_i \leq 3 \times 10^5$ |

注意对于一个分值为 $M$ 的子任务，如果只答对了第一行的内容，你可以得到 $\left\lfloor\dfrac M2\right\rfloor$ 分。

## 样例 #1

### 输入

```
3
3 1 2
3 1 1
```

### 输出

```
YES
1
R 1 2
```

## 样例 #2

### 输入

```
4
1 2 4 3
1 4 2 3
```

### 输出

```
NO
```

## 样例 #3

### 输入

```
4
2 1 4 3
2 1 4 3
```

### 输出

```
YES
0
```

# 题解

## 作者：tzl_Dedicatus545 (赞：6)

唐。

注意到可以把数列 $b$ 缩成若干个连续段，记为 $c_1\cdots c_k$。

然后我们可以发现性质：**必须存在一种方案，使得 $c$ 数列中的数在 $a$ 中的出现顺序连续。**

大概就是，比如 $c=(1,2,3),a=(5,2,1,6,2,4,3)$，我们可以选出 $a=(5,2,{\textbf{\color{red}1}},6,{\textbf{\color{red}2}},4,{\textbf{\color{red}3}})$。

这个条件显然是充分必要的。

然后我们就按顺序对每个 $c_i$ 所对应的 $[l,r]$，先**逆序**扩展 $c_i$ 到 $r$，再顺序扩展 $c_i$ 到 $l$ 即可。

容易证明操作次数 $\leq n$。

```cpp
int a[maxn],b[maxn],la[maxn],tmp[maxn];
struct Node{
	int op,l,r;
};vector<Node> ans;
vpii vec2;

signed main()
{ios::sync_with_stdio(0);cin.tie(0);
	int n;cin>>n;
	rep(i,1,n,1)	cin>>a[i];
	rep(i,1,n,1)	cin>>b[i];
	vector<int> vec;int k=1;map<int,pii> M;
	for(int i=1,j=1;i<=n;i=j+1){
		j=i;
		while(b[j+1]==b[i])	j++;
		vec2.pb({i,j});
		while(k<=n && a[k]!=b[i])	k++;
		if(k==n+1){	cout<<"NO\n";return 0;}
		vec.pb(k);M[k]={i,j};
	}per(i,vec.size()-1,0,1){
		auto p=M[vec[i]];
		if(vec[i]<p._2){	ans.pb({0,vec[i],p._2});}
	}rep(i,0,vec.size()-1,1){
		auto p=M[vec[i]];
		if(p._1<vec[i]){	ans.pb({1,p._1,vec[i]});}
	}
	cout<<"YES\n"<<ans.size()<<endl;
	for(auto p:ans){
		if(p.op==0)	cout<<"R "<<p.l-1<<" "<<p.r-1<<"\n"; 
		else		cout<<"L "<<p.l-1<<" "<<p.r-1<<"\n";
	}
	return 0;
}
```

---

## 作者：syr1125 (赞：6)

## -0x3f 扯淡
这道题真的很坑，细节超多，交了一面总算通过了。

## 0x01 第一部分思路

第一部分需要我们判断 ```YES``` 还是 ```NO```。

先观察一下不能通关的一组样例：

```
4
1 2 4 3
1 4 2 3
```
这里不能通关的主要原因是 $(2,4)$ 和 $(4,2)$ 这边形成了类似于逆序对的结构。~~（瞎 BB 名词）~~

又观察发现 $B$ 的的大部分元素都是重复的，考虑把 $B$ 中一样的元素缩成一个元素再观察。

最后发现了一个答案为 ```YES``` 的**充要条件**：浓缩后的 $B$ 为 $A$ 的**子序列**。

## 0x02 第一部分的实现

```cpp
int l = 1, r = 1, cnt = 0;
for (int i = 2; i <= n + 1; i ++)
{
	if (tb[i] == tb[i - 1]) r ++;
	else
	{
		b[++ cnt] = {tb[l], l, r};
			l = r + 1, r = l;
	}
}
```
实现对 $B$ 的“浓缩”用上面的代码。

```cpp
int i = 1;
for(int j = 1; j <= n; j ++)
{
    if(i <= cnt && b[i].x == a[j]) i ++; //这里使用双指针 
}

if(i == cnt + 1) cout << "YES\n";
else
{
	cout << "NO\n";
	return 0;
}
```

判断 ```YES``` 或者 ```NO``` 用上面的代码。

## 0x03 第二部分

有了上面的“浓缩”后的 $B$，第二部分就简单~~也不简单~~了。

可以发现，$B$ 中的每一串数字都是有源点的，我们要做的，就是找到这个源点，向周围扩散，也就是说，每一个源点都会向右划一次，向左划一次。

找源点的方式非常简单，只要用“浓缩”的 $B$ 和 $A$ 一一对应就行了。

为了不超出 $N$ 次操作，我们只要当源点在最左端时不往左扩展，当源点在最右端时不往右扩展。

有些时候会有前面的源点会覆盖后面的源点，所以要做一个排序（左右讨论）。

## 0x04 第二部分代码

```cpp
int j = 1, cnt2 = 0;
for (int i = 1; i <= n; i ++)
{
	if (a[i] == b[j].x)
	{
		if (i < b[j].r)
		{
			ans[++ cnt2] = {1, i, b[j].r};
		}
		if (i > b[j].l)
		{
			ans[++ cnt2] = {-1, b[j].l, i};
		}
		j ++;
	}
	if (j > cnt) break;
}

cout << cnt2 << "\n";
sort(ans + 1, ans + 1 + cnt2, cmp);
for (int i = 1; i <= cnt2; i ++)
{
	if (ans[i].x == 1) 
	{
		cout << "R " << ans[i].l - 1 << " " << ans[i].r - 1 << "\n";
	}
	else
	{
		cout << "L " << ans[i].l - 1 << " " << ans[i].r - 1 << "\n";
	}
}
```

### 0x3F 一些hack

```
5
1 1 2 1 1
2 2 2 2 2
ans:
YES
2
L 0 2
R 2 4
```

```
7
1 2 3 4 5 6 7
1 1 1 1 1 5 5
ans:
YES
2
R 4 6
R 0 4
```

---

## 作者：wYYSZLwSSY (赞：2)

题意比较清晰，不再重复。

## 题解
先来考虑如何判定一对 $A,B$ 是否合法。

先来考虑 $O(n^2)$ 的做法。

我们可以把原过程看作一个 $B$ 中数去对应 $A$ 中数字的过程，不难发现这个对应不能有重叠。

所以可以设 $f_{i,j}$ 表示匹配到 $A$ 的第 $i$ 个位置，$B$ 的第 $j$ 个位置，是否可行。

转移即：   
$f_{i,j}\gets f_{i-1,j}$   
$f_{i,j}\gets f_{i,j}|f_{i,j-1}(b_{j-1}=a_i)$    
$f_{i,j}\gets f_{i,j}|f_{i-1,j-1}(b_{j-1}=a_{i-1})$

观察这个过程，不难发现，如果我们把 $B$ 中的相邻相同的数缩成一个数，形成序列 $C$，那么有解的充要条件是 $C$ 可以对应 $A$ 的一个子序列。
     
再来考虑输出方案。

我们可以先找到对应的子序列，然后将子序列从左往右“标齐”对应的 $c$ 的左端点（如果它原先的位置就比左端点更左就不需要操作）；之后再将子序列从右往左“标齐”对应的右端点（如果标齐左端点后的区间已经囊括了右端点就不需要操作），这样正确性显然。

至于为什么操作数小于等于 $n$，可以这样理解：如果一个数“标齐”了两次，那至少说明它对应的区间大小大于一。这样总操作次数就不超过 $n$ 了。

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n;
int a[300005],b[300005];
vector<pair<int,int> >xl;
vector<int>lx;
vector<pair<char,pair<int,int> > >ans;
signed main(){
	cin.tie(0)->sync_with_stdio(0);
	//freopen("1.in","r",stdin);
	cin>>n;
	for(int i=1;i<=n;++i)cin>>a[i];
	for(int i=1;i<=n;++i)cin>>b[i];
	int last=1;
	for(int i=2;i<=n;++i){
		if(b[i]!=b[i-1]){
			xl.push_back({last,i-1});
			last=i;
		}
	}
	xl.push_back({last,n});
	int tp=1;
	for(auto x:xl){
		while(tp<=n and a[tp]!=b[x.first])++tp;
		if(tp>n)break;
		lx.push_back(tp);
	}
	if(tp>n)return cout<<"NO"<<'\n',0;
	cout<<"YES"<<'\n';
	for(int i=0;i<xl.size();++i){
		int x=lx[i],y=xl[i].first;
		if(x==y)continue;
		if(x>y)ans.push_back({'L',{y,x}});
	}
	for(int i=xl.size()-1;i>=0;--i){
		int x=lx[i],y=xl[i].first,z=xl[i].second;
		if(x>=y){//这里分开写了，虽然没必要，但是看起来清晰
			if(x>=z)continue;
			ans.push_back({'R',{x,z}});
		}else{
			if(x>=z)continue;//注意这里不是 y>=z
			ans.push_back({'R',{x,z}});
		}
	}
	cout<<ans.size()<<'\n';
	for(auto x:ans)cout<<x.first<<' '<<x.second.first-1<<' '<<x.second.second-1<<'\n';
	return 0;
}
```

---

## 作者：WaterSun (赞：1)

[更好的阅读体验](https://www.luogu.com.cn/problem/P10297)

以为是拓扑排序之类的东西，结果一看 tag 是构造，已老实。

# 思路

注意到当 $b$ 有一段连续相同数的时候，对于最后一个经过这一段的操作必须覆盖整个这一段，因此考虑将一段相同的数缩成一个点，记作 $c_1,\dots,c_k$。

有解的条件为：$c$ 序列是 $a$ 序列的一个子序列。这个条件显然是充要的：

> 充分性：记 $c_i$ 在 $a$ 中对应 $a_{pos_i}$，在 $b$ 中对应 $b_{l_i \sim r_i}$。我们可以通过先顺序将 $pos_i$ 推到 $l_i$，再逆序将 $pos_i$ 推到 $r_i$ 的构造方式将 $a$ 序列变为 $b$ 序列。因为 $pos_i$ 是递增的，所以方案肯定能将 $a$ 变为 $b$；同时因为对于一个需要花两步的 $c_i$，长度必定 $\geq 3$，因此步数 $\leq n$。
> 必要性：反证法。若 $\exist i < j,pos_i > pos_j$，分讨 $l_i,r_j,pos_i,pos_j$ 的位置关系，容易发现无论什么情况都不能使将 $c_i,c_j$ 同时合法。

直接按照证明充分性的构造方式输出即可。

# Code

```cpp
#include <bits/stdc++.h>
#define re register
#define fst first
#define snd second

using namespace std;

typedef pair<int,int> pii;
typedef pair<int,pii> pip;
const int N = 3e5 + 10;
int n;
int arr[N],brr[N];
vector<pii> v;
vector<int> pos;
vector<pip> ans;

inline int read(){
    int r = 0,w = 1;
    char c = getchar();
    while (c < '0' || c > '9'){
        if (c == '-') w = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9'){
        r = (r << 3) + (r << 1) + (c ^ 48);
        c = getchar();
    }
    return r * w;
}

int main(){
    n = read();
    for (re int i = 1;i <= n;i++) arr[i] = read();
    for (re int i = 1;i <= n;i++) brr[i] = read();
    for (re int i = 1,lst = 1;i <= n + 1;i++){
        if (brr[i] != brr[lst]){ v.push_back({lst,i - 1}); lst = i; }
    }
    for (re int i = 0,j = 1;i < v.size();i++){
        while (j <= n && arr[j] != brr[v[i].fst]) j++;
        if (j == n + 1) return puts("NO"),0;
        pos.push_back(j);
    }
    for (re int i = 0;i < v.size();i++){
        if (pos[i] > v[i].fst) ans.push_back({0,{v[i].fst,pos[i]}});
    }
    for (re int i = v.size() - 1;~i;i--){
        if (pos[i] < v[i].snd) ans.push_back({1,{pos[i],v[i].snd}});
    } printf("YES\n%d\n",ans.size());
    for (pip p:ans) printf("%c %d %d\n",p.fst ? 'R' : 'L',p.snd.fst - 1,p.snd.snd - 1);
    return 0;
}
```

---

## 作者：leo120306 (赞：1)

### 分析
首先要知道 $a$ 中连续的数字段的长度可任意改变，连续的数字段之间的相对位置不可变，证明显然。比如 `1 1 2 3` 可以变成 ` `，`1`, `2`, `3`，`1 1 1 2`，`1 1 1 2 2 2 3 3 3` 等，但是不可以变成  `1 1 3 2`，因为 2 和 3 的相对位置改变了。

因此我们合并 $a$ 和 $b$ 中连续的数字段并尝试贪心地匹配 $b$ 为 $a$ 的子序列，如果子序列不存在则无解。

接下来就要输出解决方案了。假设我们解决方案中有一步需要将段 $[l1,r1]$ 的数字滑动至 $[l2,r2]$ 处。我们对这一步的移动方式与优先关系进行分类讨论。

1. $l1\le l2$ 且 $r1\ge r2$

    ![](https://cdn.luogu.com.cn/upload/image_hosting/zsb31mgs.png)

    不作处理。原因：在前一步（若存在）和后一步（若存在）中就会把多余的数字删掉。无优先关系。


2. $l1\le l2$ 且 $r1<r2$

    ![](https://cdn.luogu.com.cn/upload/image_hosting/gsfw0r55.png)

    从 $r1$ 右滑到 $r2$。优先关系要求后一步（若存在）在本操作完成前进行，否则后一步的数字段可能先被覆盖。


3. $l1>l2$ 且 $r1\ge r2$

    ![](https://cdn.luogu.com.cn/upload/image_hosting/qwlwkjj8.png)

    从 $l1$ 左滑到 $l2$。优先关系要求前一步（若存在）在本操作完成前进行，否则前一个数字段可能先被覆盖。

4. $l1>l2$ 且 $r1<r2$

    ![](https://cdn.luogu.com.cn/upload/image_hosting/stll36en.png)

    从 $l1$ 左滑到 $l2$ 并从 $r1$ 右滑到 $r2$。优先关系要求前一步（若存在）和后一步（若存在）均在本操作完成前进行，否则前、后数字段可能先被覆盖。

注意，当优先关系出现矛盾时仅需删去一个矛盾的关系即可，因为这种情况一定是前一个想右滑后一个想左滑，二者当然不会有交集，更不会有一个被覆盖。

有了优先关系就可以拓扑排序找一个合法的顺序，然后输出操作了。

### 实现
[link](https://www.luogu.me/paste/qjvqd2e0#)

---

## 作者：hh20080501hh (赞：1)

# 题目
[题面戳我哦。](https://www.luogu.com.cn/problem/P10297)

题意简述：给定两个序列 $A$，$B$，要求你通过两种操作使序列 $A$ 变成序列 $B$，且操作次数只能小于 $N$ 次。

- 操作 $1$：选择一段区间，记作 $[l,r]$ 让区间中的每一个数都变为 $A_l$。
- 操作 $2$：选择一段区间，记作 $[l,r]$ 让区间中的每一个数都变为 $A_r$。
# 分析
读完题意后，我们可以发现这个染色的过程其实就是一个覆盖的过程。也就是说，对于位置 $i$，在 $i$ 左边的 $A_j$ 无论经过怎样的操作都不可能到 $i$ 的右边，除非 $i$ 的右边本来就有与 $A_j$ 相等的数，不过这个数不应该算作 $A_j$，因为它本来就在 $i$ 的右边。对于右边的数也同理。


------------

不妨举个例子吧：

序列 $A$：$\{2,2,1\}$。

序列 $B$：$\{1,2,1\}$。

若我们认为第一个元素下标为 $1$，我们可以发现，无论怎么样变换 $A_1$ 都不能变为 $1$，因为 $A_3$ 被 $A_2$ 挡住了。

再举一个例子：

序列 $A$：$\{1,2,1\}$。

序列 $B$：$\{1,2,1\}$。

这时我们发现 $A_1$ 可以是 $1$，因为虽然 $A_2$ 把它右边的 $A_3$ 挡住了，但是它左边依然存在 $A_1$ 这个 $1$，可以覆盖出去。


------------
既然如此，那我们只需要判断一下是否有个数被其他的数挡住了就行。简而言之，就是是否有一个两个必选的数在序列 $A$ 和序列 $B$ 中位置相反。

当然，如果一个相同的数在序列 $B$ 中连续出现，那么我们可以认为这是一个数（毕竟答案只与位置有关系，多少个不是那么重要），我们把这么多数缩到一起去，方便我们处理。
# 代码
因为序列 $A$ 中出现了当前需要的序列 $B$ 中的数，我们是必选这个数的，不会等到后面去选，所以我们考虑使用双指针来找是否有两个必选的数在两个序列中位置相反。

代码不难，但是细节较多：

1. 题目中下标是从 $0$ 开始的，但为了操作方便，我们从 $1$ 储存，所以输出时要减掉。
1. 在缩点的时候我们要把位置存储下来，方便后续输出方案。注意这里存储位置需要注意边界问题。
1. 双指针扫描的时候，我们需要注意一下序列 $A$ 中的数是否与序列 $B$ 中的数相等，这样能减少我们的操作次数。虽然说不加这一步操作数最大也就是 $N$，但是谁不希望自己的操作方案更少一点呢？~~这样的话你的答案跟样例是一样的，不需要动脑子就判断是否满足。~~
1. 操作需要注意顺序！不能前面的覆盖把后面需要的数覆盖完了！所以我们考虑排个序，对于左右两边分开考虑。左边是左边的数可能把右边需要的数覆盖，所以我们先输出区间靠右的情况，右边同理，先输出区间靠左的情况。

下面放出代码。
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 3e5+10;

int n;
int a[N] , b[N];
int idx_ans;

struct Num
{
	int id , val;
	int ed;
}c[N];
struct Op
{
	int type;	//-1为左，1为右 
	int l , r;
	bool operator <(const Op &o) const
	{
		if (type!=o.type) return type<o.type;
		else if (type==1) return l>o.l;
		else return r<o.r;
	}
}ans[N];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);
	
	cin >> n;
	for (int i=1 ; i<=n ; i++)
	{
		cin >> a[i];
	}
	int lst = -1 , idx_c = 1 , lst_id = -1;
	for (int i=1 ; i<=n ; i++)
	{
		cin >> b[i];
		if (b[i]!=lst)
		{
			c[idx_c].val = b[i];
			c[idx_c-1].ed = i-1;
			c[idx_c++].id = i;
			lst = b[i] , lst_id = i;
		}
	}
	if (c[idx_c-1].val==b[lst_id]) c[idx_c-1].ed = n;
	
	int flag = 0;
	for (int i=1 , j=1 ; i<=n && j<=idx_c-1 ; )
	{
		if (a[i]==a[i-1] && i!=1) 
		{
			i++;
			continue;
		}
		if (a[i]==c[j].val) 
		{
			if (j==idx_c-1) flag = 1;
			if (c[j].id==c[j].ed && i==c[j].id)
			{
				i++ , j++;
				continue;
			}
			if (c[j].id<i)
			{
				ans[idx_ans++] = {-1 , c[j].id , i};
			}
			if (c[j].ed>i)
			{
				ans[idx_ans++] = {1 , i , c[j].ed};
			}
			i++ , j++;
		}
		else 
		{
			i++;
		}
	}
	
	if (!flag) cout << "NO\n";
	else 
	{
		cout << "YES\n";
		cout << idx_ans << '\n';
		sort (ans , ans+idx_ans);
		for (int i=0 ; i<idx_ans ; i++)
		{
			Op t = ans[i];
			if (t.type==-1)
			{
				cout << "L " << t.l-1 << ' ' << t.r-1 << '\n';
			}
			else 
			{
				cout << "R " << t.l-1 << ' ' << t.r-1 << '\n';
			}
		}
	}
	return 0;
}
```

---

## 作者：iyka (赞：1)

### 如何判断题目是否有解：
仔细分析题目，我们可以发现滑动操作时只会减少数列中元素的数量，且如果要交换两个元素的位置一定会产生损耗，所以如果要从数列 $A$ 变换到数列 $B$ 我们就要保证把数列 $B$ 相邻相同元素压缩后得到的数列 $B'$ 是数列 $A$ 子序列，否则题目无解。

### 如何构造滑动操作：
在判断数列 $B'$ 是否是数列 $A$ 子序列时，可以顺便记录每个数列 $B'$ 中每个元素在数列 $A$ 出现的位置，再处理出数列 $B$ 中每段相邻相同元素的位置。最后把两者进行对比就可以得出答案，具体见代码。

注意：在求解滑动操作时，对于左滑要顺序求，右滑要逆序求。

### 代码部分
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+10;
int a[N],b[N],j=1,n;
int _b[N],lenB,ia[N]; //ia记录数列B'中每个元素在数列A出现的位置
int ll,rr,cnt;
pair<int,int> l[N],r[N],idx[N];
int main()
{
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>a[i];
	for(int i=1,k=N;i<=n;++i)
	{
		cin>>b[i]; 
		if(b[i]!=k)
			_b[++lenB]=k=b[i];
	}
	j=1;
	for(int i=1;i<=n;++i)
		if(a[i]==_b[j] && j<=lenB)
			ia[j++]=i;
	if(j!=lenB+1)
		return cout<<"NO", 0;
	cout<<"YES\n"; j=1; 
	for(int i=1;i<=n;++i) //数列B中每段相邻相同元素的位置
	{
		while(b[i]==b[j] && j<=n)
			++j;
		idx[++cnt]=make_pair(i,j-1), i=j-1;
	}
	for(int i=1;i<=lenB;++i)
		if(idx[i].first<ia[i])
			l[++ll]=make_pair(idx[i].first,ia[i]);
	for(int i=lenB;i>=1;--i)
		if(idx[i].second>ia[i])
			r[++rr]=make_pair(ia[i],idx[i].second);
	cout<<ll+rr<<"\n";
	for(int i=1;i<=ll;++i)
		cout<<"L "<<l[i].first-1<<" "<<l[i].second-1<<"\n";
	for(int i=1;i<=rr;++i)
		cout<<"R "<<r[i].first-1<<" "<<r[i].second-1<<"\n";
	return 0;
}
```

---

## 作者：Genius_Star (赞：0)

宝宝题。

### 思路：

考虑将 $b$ 缩成若干个连续段，第 $i$ 段为 $[l_i, r_i]$，数值为 $c_i$。

显然只有当 $c$ 为 $a$ 的一个子序列时才会有解，因为显然这个覆盖操作不会影响 $a$ 中**元素值**的相对顺序。

于是我们随意找到 $a$ 中的一个子序列 $c$，设 $c_i$ 对应的下标为 $h_i$，考虑怎么覆盖。

首先覆盖左边的，即取 $[l_i, h_i]$ 先赋值，由于单调性，从前往后覆盖即可；同理赋值 $[\min(l_i, r_i), r_i]$，这个要从后往前赋值。

显然总操作次数 $\le N$，时间复杂度为 $O(N \log N)$。

### 完整代码：

```cpp
 #include<bits/stdc++.h>
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define add(x, y) ((x + y >= mod) ? (x + y - mod) : (x + y))
#define dec(x, y) ((x - y < 0) ? (x - y + mod) : (x - y))
#define popcnt(x) __builtin_popcount(x)
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 3e5 + 10; 
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
int n, mx, cnt;
int a[N], b[N], l[N], r[N], c[N], h[N];
set<int> S[N];
vector<pair<char, pair<int, int>>> ans;
bool End;
int main(){
	//freopen("gen.in", "r", stdin);
	//freopen("gen.out", "w", stdout);
	n = read();
	for(int i = 1; i <= n; ++i){
		a[i] = read();
		mx = max(mx, a[i]);
		S[a[i]].insert(i);
	}
	for(int i = 1; i <= n; ++i){
		b[i] = read();
		if(b[i] != b[i - 1]){
			r[cnt] = i - 1;
			c[++cnt] = b[i];
			l[cnt] = i;
		}
	}
	r[cnt] = n;
	for(int i = 1; i <= cnt; ++i){
		auto it = S[c[i]].upper_bound(h[i - 1]);
		if(it == S[c[i]].end()){
			puts("NO");
			return 0;			
		}
		h[i] = *it;
	}
	puts("YES");
	if(cnt == 1){
		int now = *S[c[1]].begin();
		puts("2");
		printf("L 0 %d\n", now - 1);
		printf("R %d %d\n", now - 1, n - 1);
		return 0;
	}
	int sum = 0;
	for(int i = 1; i <= cnt; ++i){
		if(l[i] < h[i]){
		    ++sum;
		    ans.push_back({'L', {l[i], h[i]}});	
		}
	}
	for(int i = cnt; i >= 1; --i){
		if(min(l[i], h[i]) == r[i])
		  continue;
		++sum;
		ans.push_back({'R', {min(l[i], h[i]), r[i]}});
	}
	write(sum);
	putchar('\n');
	for(auto t : ans)
	  printf("%c %d %d\n", t.fi, t.se.fi - 1, t.se.se - 1); 
	//cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：xxgirlxx (赞：0)

首先进行一个无解的判断：我们将 $B$ 中数字相同的一段压缩成一个数字，然后只需判断压缩后的 $B$ 是否是 $A$ 的子序列即可。

证明：每次操作都会将一段数变成段内的一个数，所以最终的 $B$ 数组压缩后必定是 $A$ 的子序列。

然后我们将压缩后的 $B$ 数组跟 $A$ 数组进行一一匹配，然后对匹配到的 $A$ 数组中的数进行操作使得其刚好能够覆盖匹配的 $B$ 数组中的那一段数。

然后将所有操作进行合理的排序即可，具体就是：左移和右移需要其中一种全部执行完再执行另一个，可以证明这不会有影响，然后左移操作中 $r$ 小的先执行，右移操作中 $l$ 大的先执行，可以证明这不会有影响。

证明：先证明左移操作中 $r$ 小的先执行，右移操作中 $l$ 大的先执行：这是非常好证的，因为后面的操作可能覆盖前面操作的起点，但是如果我们以上述方法进行排序就没有后面操作覆盖前面操作起点的问题。然后证明左移和右移需要其中一种全部执行完再执行另一个：如果出现了左移操作中把右移操作的起点覆盖了，这是不是说明了整个右移操作的区间都被覆盖了呢？那为什么还会有右移操作呢？而且不可能有在左移操作起点后面的部分，因为这样会使压缩后的 $B$ 数组不是 $A$ 数组的子序列（读者可以自己手玩或试着证一下），所以两种操作间不会互相影响。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+10;
int a[N],b[N],c[N],d[N],e[N],num,n,sum=1,cnt;
struct node{char dr;int l,r;}ans[N];
bool cmp(node x,node y){
	if(x.dr==y.dr&&x.dr=='L')return x.r<y.r;
	else if(x.dr==y.dr)return x.l>y.l;
	else return x.dr<y.dr;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)cin>>b[i];
	for(int i=1;i<=n;i++)if(b[i]!=b[i-1])c[++num]=b[i],d[num]=i;
	for(int i=1;i<=n&&sum<=num;i++)if(a[i]==c[sum])e[sum++]=i;
	if(sum!=num+1)cout<<"NO\n",exit(0);
	cout<<"YES\n",d[num+1]=n+1;
	for(int i=1;i<=num;i++){
		if(d[i]<e[i])ans[++cnt]={'L',d[i],e[i]};
		if(e[i]<d[i+1]-1)ans[++cnt]={'R',e[i],d[i+1]-1};
	}
	sort(ans+1,ans+cnt+1,cmp),cout<<cnt<<"\n";
	for(int i=1;i<=cnt;i++)cout<<ans[i].dr<<" "<<ans[i].l-1<<" "<<ans[i].r-1<<"\n";
}
```

---

## 作者：ax_by_c (赞：0)

显然有解等价于将 $B$ 中连续相同段缩成数之后是 $A$ 的子序列。

考虑找出这个子序列，子序列中的位置 $i$ 对应 $B$ 中的一段区间 $[l_i,r_i]$。

然后只要在 $l_i<i$ 时向左滑动，$i<r_i$ 时向右滑动即可，操作次数显然不超过 $n$。

注意操作要排序，向左滑动按照右端点排序，向右滑动按照左端点排序，两种滑动只会在端点处相交所以不用管。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace ax_by_c{
const int N=3e5+5;
struct node{
	char a;
	int b,c;
};
int n,a[N],b[N],l[N],r[N];
vector<node>ans;
bool cmp(node x,node y){
	if(x.a==y.a){
		if(x.a=='L')return x.c<y.c;
		else return x.b>y.b;
	}
	return x.a<y.a;
}
void main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)scanf("%d",&b[i]);
	for(int i=1;i<=n;i++)l[i]=n+1,r[i]=0;
	for(int i=1,j=1;i<=n;i++){
		while(j<=n&&a[j]!=b[i])j++;
		if(j==n+1){
			puts("NO");
			return ;
		}
		l[j]=min(l[j],i);
		r[j]=max(r[j],i);
	}
	for(int i=1;i<=n;i++){
		if(l[i]<i)ans.push_back({'L',l[i],i});
		if(i<r[i])ans.push_back({'R',i,r[i]});
	}
	sort(ans.begin(),ans.end(),cmp);
	puts("YES");
	printf("%d\n",(int)ans.size());
	for(auto it:ans)printf("%c %d %d\n",it.a,it.b-1,it.c-1);
}
}
int main(){
	ax_by_c::main();
	return 0;
}
```

---


# 「LAOI-9」Sequence

## 题目背景

赛后本题添加多测及一些 hack。

## 题目描述

若区间 $[l,r]$ 对任意 $l \le t\le r$ 都满足 $\sum\limits_{i=l}^ta_i>0$，则称其为**好的区间**，注意 $l$ 可以等于 $r$。

现在你需要构造一个长度为 $n$ 的数列，使得其满足：

- 恰好存在 $k$ 个好的区间；
- $\sum\limits_{i=1}^n(n-i+1)\times a_i=\frac{n\times(n+1)}{2}$；
- $-10^{12}\le a_i<10^{12}$，且均为整数。

若不存在方案，则输出一个全为 $0$ 的数列 $a$。

## 说明/提示

### 样例解释

对于样例 $1$ 中输出的序列共有以下 $12$ 个区间是好的：

1. $[1,1]$；
2. $[1,2]$；
3. $[1,3]$；
4. $[1,4]$；
5. $[1,5]$；
6. $[1,6]$；
7. $[2,2]$；
8. $[2,3]$；
9. $[2,4]$；
10. $[2,5]$；
11. $[2,6]$；
12. $[6,6]$。
### 数据范围

**本题目采用捆绑测试**。

|子任务编号|$\sum n\le$|特殊性质|分值|
|:-:|:-:|:-:|:-:|
|$1$|$10$|无|$10$|
|$2$|$10^2$|无|$15$|
|$3$|$2\times10^3$|无|$20$|
|$4$|$2\times 10^5$|$k<n$|$15$|
|$5$|$2\times10^5$|无|$40$|

对于 $100\%$ 的数据，满足 $1\le T\le 100$，$1\le n,\sum n \le 2\times10^5$，$1\le k < 2^{63}$。

## 样例 #1

### 输入

```
1
6 12```

### 输出

```
1 5 -1 -1 -2 1```

## 样例 #2

### 输入

```
2
6 114514
6 1```

### 输出

```
0 0 0 0 0 0
0 0 0 0 0 21```

# 题解

## 作者：Rnfcr (赞：4)

首先当 $k>\frac{n\times(n+1)}{2}$ 时无解，因为长度为 $n$ 的数列中的总区间数为 $\frac{n\times(n+1)}{2}$。

当 $k\le \frac{n\times(n+1)}{2}$ 时 $k$ 总可以被表示为 $1$ 至 $n$ 中若干个互不相同的整数的和，因此可以找到若干个左端点，让这些左端点到 $n$ 间的每一个区间都是好的区间。令数列中左端点项的值为 $1$ ，其余项为 $0$ 便满足了第一个要求。

设此时的 $k-\sum_{i = 1}^{n} a_i \times (n-i+1)$ 为 $b$ ，找到一个不为左端点且它的前一个位置是左端点的位置，令这个位置的值减去 $b$ ，它的前一个位置加上 $b$ 就满足了第二个要求。当 $k<\frac{n\times(n+1)}{2}$ 时一定找的到这个位置，$k=\frac{n\times(n+1)}{2}$ 时 $b$ 一定为 $0$，这时便不减去，故一定可以构造出一个合法的解。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T,n,k,choose[200009],ans[200009];
signed main(){
	ios::sync_with_stdio(NULL),cin.tie(0),cout.tie(0);
	cin>>T;
	while(T--){
		cin>>n>>k;
		int b=(n*(n+1))/2;
		if(k>b){
			for(int i=1;i<=n;i++) cout<<"0 ";
			cout<<"\n";
			continue;
		}
		for(int i=n;i;i--){
			if(k>=i){
				k-=i;
				choose[n-i+1]=1;
			}
			else choose[n-i+1]=0;
		}
		int val=1;
		for(int i=n;i>=1;i--){
			if(choose[i]){    
				ans[i]=1;
				b-=val;
			}
			else{
				ans[i]=0;
			}
			val++;
		}
		for(int i=1;i<=n;i++){
			if(choose[i]&&!choose[i+1]){
				ans[i]+=b;
				ans[i+1]-=b;
				break;
			}
		}
		for(int i=1;i<=n;i++) cout<<ans[i]<<" ";
		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：Anemones (赞：2)

对于 $\sum\limits_{i=1}^n(n-i+1)\times a_i=\frac{n\times(n+1)}{2}$ 这个要求，一种可行的方案是使得 $a$ 做前缀和后得到的 $b$ 是一个排列。

也就是我们需要构造一个排列 $b$ 使得好的区间的个数恰好为 $k$，然后逆推出原数组 $a$，其中 $b$ 是 $a$ 的前缀和数组。

先考虑 $k$ 是怎么计算得到的：对于 $b_i$，与其**左边第一个大于 $b_i$ 的数** 的距离即为 $i$ 作为区间右端点时的贡献（这也是 SPJ 的写法，不过还得用单调栈优化），这里还有些细节问题不赘述。

既然如此，那么我们便可以从 $[1,n]$ 中两端选数，从左往右填 $b_i$，如果 $b_i$ 选的是当前的最小值，那么你可以理解为产生了 $n-i$ 的贡献，否则则产生了 $0$ 的贡献，然后初始的总贡献为 $n$，在此基础上累加直到 $k$。但是这个做法存在一个缺陷：贡献至少为 $n$。

所以 Subtask 4 就是给 $k<n$ 的这一分讨的，这个可以通过选一个地方填个 $1$，再在后面填 $0$，最后塞一个大数。然而 $k=2$ 还得特判一下，在倒数第二个数放个大数，最后放个负数。

多测记得清空数组。

---

## 作者：xxgirlxx (赞：1)

写完后尝试着找出分讨更少的方法，结果把好区间定义的 $\sum_{i=l}^{t}a_i>0$ 和条件二的 $\sum_{i=1}^{n}(n-i+1)\times a_i=\frac{n\times (n+1)}{2}$ 看混看成了 $\sum_{i=l}^{t}(n-i+1)\times a_i>0$，虚空调试 1h，不过为什么 SPJ 只有 Wrong answer 啊。

首先先处理条件二，设 $b_i$ 为 $a_i$ 的前缀和，然后可以发现条件二就是 $\sum_{i=1}^{n}b_i=\frac{n\times (n+1)}{2}$。这个式子有一个处理方法就是使 $b_i$ 为 $n$ 的排列。

然后再处理条件一，首先我们知道好区间最多的情况就是全部 $a_i$ 都是 $1$（好区间数量为 $\frac{n\times (n+1)}{2}$，具体地，以第 $i$ 个数为好区间的起点，那么与其对应的终点就应该有 $n-i+1$ 个，因为全是 $1$，一直满足好区间定义，所以 $i$ 到 $n$ 都是与其对应的好区间的终点，那么总的好区间数量也就是从 $n$ 一直加到 $1$），那么 $b_i$ 就是从 $1$ 到 $n$，然后我们知道 $a_i$ 是 $b_i-b_{i-1}$，那么可以发现如果我们在 $1$ 到 $n$ 中挪动最后一个数的位置，那么假设挪到的的位置是 $x$，那么交换后好区间的数量就会减去 $n-x$。因为交换后会使 $a_{x+1}$ 变成负数，那么从 $x+1$ 开始的好区间就全部不再是好区间了。那么我们让 $b_i$ 为 $1$ 到 $n$，然后就从 $n$ 开始，把每个数都挪到 $1$ 前面，并记录好区间数，如果剩下的好区间数已经不能让目前的数字挪到 $1$ 前面就退出，然后再计算出怎么挪才能使好区间数等于 $k$ 就可以了，具体地，如果最后目前最后一个数是 $i$，好区间数比 $k$ 多了 $x$，那么就需要将 $i$ 挪到 $n-x$。

然后我们发现这只能处理 $k\ge n$ 的情况，那如果 $k<n$ 怎么办呢？可以发现样例给了提示：因为 $k<n$，所以如果需要 $k$ 个好区间那么只需要 $n-k+1$ 这个位置为正数，其他位置都是 $0$ 或负数就可以了，但是这个时候可能会不满足条件二，因为无法保证 $\frac{n\times (n+1)}{2\times k}$ 是整数，所以需要判断，如果不是整数就需要往后挪一个位置，然后将最后一个位置改成正数，但为了防止 $\frac{n\times (n+1)}{2\times (k-1)}$ 是整数导致最后一个位置变成 $0$ 使最终好区间个数少 $1$，我们往后一个位置放的值实际上是 $\frac{n\times (n+1)}{2\times (k-1)}-1$，这样最后一个位置就一定是正的了。

但是你会发现 $k=2$ 是特殊的因为它往后挪一位就是最后一位了，所以我们特殊处理 $k=2$ 的情况，由于它往后挪一位就是最后一位了，所以不能使用上面的方法，我们只能将正数放在 $n-1$ 的位置上，同时还要保证最后一个位置是非正数，这个其实很简单，我们只需要将 $n-1$ 这个位置的值大于等于 $\frac{n\times (n+1)}{2\times 2}$ 就可以了，这样 $n-1$ 这个位置的值就一定大于等于 $\frac{n\times (n+1)}{2}$，那么最后一个位置的值也就一定小于等于 $0$ 了。

最后判一下无解，也就是 $k<1$ 或者 $k>\frac{n\times (n+1)}{2}$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,k,num,a[200010],sum;
signed main(){
	cin>>t; 
	while(t--){ 
		cin>>n>>k;
		if(k<1||k>n*(n+1)/2){
			for(int i=1;i<=n;i++)cout<<"0 ";
			cout<<"\n";
		} 
		else if(k<n){
			if(k==2){
				for(int i=1;i<n-1;i++)cout<<"0 ";
				cout<<n*(n+1)/2/2+1<<" "<<n*(n+1)/2-2*(n*(n+1)/2/2+1)<<"\n";
			}
			else{
				if(n*(n+1)/2%k==0){
					for(int i=1;i<=n-k;i++)cout<<"0 ";
					cout<<n*(n+1)/2/k<<" ";
					for(int i=n-k+2;i<=n;i++)cout<<"0 ";
					cout<<"\n";
				}
				else{
					for(int i=1;i<=n-k+1;i++)cout<<"0 ";
					cout<<n*(n+1)/2/(k-1)-1<<" ";
					for(int i=n-k+3;i<n;i++)cout<<"0 ";
					cout<<n*(n+1)/2%(k-1)+(k-1)<<"\n";
				}
			}
		}
		else{
			num=n*(n+1)/2,sum=1,a[0]=n+1;
			for(int i=n;i>=1;i--,sum++){
				if(num-i+1<k)break;
				num-=i-1,a[sum]=i;
			}
			num=num-k,a[n-num]=a[sum-1]-1,sum=1;
			for(int i=1;i<=n;i++)if(a[i]==0)a[i]=sum,sum++;
			for(int i=n;i>=2;i--)a[i]-=a[i-1];
			for(int i=1;i<=n;i++)cout<<a[i]<<" ";
			cout<<"\n";
			for(int i=1;i<=n;i++)a[i]=0;
		}
	}
	return 0;
}
```

---

## 作者：ni_ju_ge (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11895)

构造题。
## 思路
设 $s=\sum\limits_{i=1}^n(n-i+1)\times a_i$。

当 $k>\frac{n\times(n+1)}{2}$ 时，显然无解。

当 $k\le \frac{n\times(n+1)}{2}$ 时，可以钦定非正数位为 $0$，且 $a_n$ 为正数（后面有用），这样可以发现第 $i$ 位为正对好的区间的数量的贡献为 $n-i+1$，于是选定一些位变为 $1$ 凑出 $k$，此时 $s=k$，差值直接增加 $a_n$ 补上即可（因为 $a_n$ 加一 $s$ 也增加一）。

但当 $k=2$ 或 $k=\frac{n\times(n+1)}{2}-1$ 时，$a_n$ 不能为正数，需要另外讨论。

当 $k=2$ 时，若 $n\times(n+1) \bmod 4=0$，直接使 $a_{n-1}=\frac{n\times(n+1)}{4}$ 即可；否则使 $a_{n-1}=\frac{n\times(n+1)}{4}+\frac{1}{2},a_n=1$ 即可。

当 $k=\frac{n\times(n+1)}{2}-1$ 时，除 $a_n$ 外均为 $1$，此时 $s$ 与 $\frac{n\times(n+1)}{2}$ 的差值为 $1$，令 $a_{n-1}=2,a_n=-1$ 即可。

注意：
 - 特判 $n=1$ 的情况。
 - 开 long long。
 - 多测。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[214514],n,k,s,tot,tt;
bool t[214514];
int main() {
	cin>>tt;
	while(tt--) {
		cin>>n>>k;
		if(n==1) {
			if(k==1) cout<<"1";
			else cout<<"0";
		} else {
			if(k>(n+1)*n/2) {//无解 
				for(int i=1; i<=n; i++) cout<<"0 ";
			} else {
				if(k==(n+1)*n/2-1) {//k=(n+1)*n/2-1
					for(int i=1; i<=n-2; i++) cout<<"1 ";
					cout<<"2 -1";
				} else if(k==2) {//k=2
					for(int i=1; i<=n-2; i++) cout<<"0 ";
					if(((n+1)*n/2)%2==0) cout<<(n+1)*n/4<<" 0";
					else cout<<((n+1)*n/2+1)/2<<" -1";
				} else {
					t[n]=s=tot=1;
					for(int i=n; i>=1; i--) {
						if(s+i<=k&&t[n-i+1]==0) {
							t[n-i+1]=1;
							s+=i,tot+=i;
						}
					}//凑数
					if(s!=k) {
						if(k-s==1&&t[n-1]==0) {
            			//因为先选了大数，所以会出现因为顺序问题差 1 的情况，此时可以替换掉几个凑出 k 
							for(int l=1; l<=n-3; l++) {
								int r=n-l;
								if(t[l]==1&&t[l+1]==0) {
									t[l]=0,t[l+1]=1,t[n-1]=1;
									s++,tot++;
									break;
								}
							}
						} else for(int i=1; i<=n; i++) cout<<"0 ";
					}
					if(s==k) {
						for(int i=1; i<=n-1; i++) cout<<t[i]<<" ";
						cout<<n*(n+1)/2-tot+1;
						//其实这里 tot 换成 s 或者 k 都可以 
					}
				}
			}
		}
		cout<<endl;
		for(int i=1;i<=n;i++) t[i]=0;
	}
}
```
## 题外话
赛后提交 WA 了，还以为是错解，结果是因为多测没清空 XD。

upd 3.20：修改了一处笔误。

---

## 作者：P2441M (赞：1)

## 题意
对于一个序列，定义区间 $[l,r]$ 是**好的**当且仅当 $a[l,r]$ 的前缀和序列是**正整数序列**。给定 $n,k$，你需要构造一个长度为 $n$ 的序列，满足:
- 恰好有 $k$ 个好的区间。
- $\sum_{i=1}^n(n-i+1)a_i=\frac{n(n+1)}{2}$。
- $a_i\in [-10^{12},10^{12}]\cap\mathbb{Z}$。

或报告无解。

对于所有数据，$1\leq n,\sum n\leq 2\times 10^5$，$1\leq k<2^{63}$。

## 题解
妙妙题，orz 出题人 @[Anemones](https://www.luogu.com.cn/user/736184)。

当且仅当 $k>\frac{n(n+1)}{2}$ 时无解。

先观察第 $2$ 条限制，等号左侧是显然是 $a$ 的前缀和序列 $s$ 的元素和，这引导我们考虑从前缀和的角度刻画好的区间，而把前缀和序列构造出来后，我们可以差分还原出原序列。

$a[l,r]$ 的前缀和序列显然是
$$
s_l-s_{l-1},s_{l+1}-s_{l-1},\cdots,s_{r}-s_{l-1}
$$
而要求其中每一项都是整数，等价于要求
$$
\forall i\in[l,r],s_i>s_{l-1}
$$

回到第 $2$ 条限制，观察到等号右侧即 $\sum_{i=1}^ni$，考虑把前缀和序列构造成一个长度为 $n$ 的**排列**。仔细思考，这里会有一个问题，这样构造会使得所有 $l=1$ 的区间都是好的，因为 $s_0=0$ 也要考虑进去，这就使得 $k$ 必然 $\geq n$，但题目没有保证这一点，我们需要做一些分类讨论。

### Case 1：$k\geq n$
下面令 $k\leftarrow k-n$，我们只考虑 $l-1>0$ 的情况。

不妨从小到大考虑每个数。当 $s_{t-1}=1$ 时，所有以 $t$ 为左端点的区间都是好的，有 $n-t+1$ 的贡献；当 $s_{t-1}=2$ 时，若将其放在 $1$ 的右边，则依然有 $n-t+1$ 的贡献……容易得到一种做法，从小到大枚举 $i$，若 $k>n-i$，则令 $k\leftarrow k-(n-i),s_i\leftarrow i$，否则令 $s_{n-k}\leftarrow i$，然后停止循环。剩下的的数从大到小插入空处即可，这样它们不会产生贡献。

### Case 2：$k<n$
这种情况我们只能放弃构造一个排列。

考察一个所有元素非 $0$ 的长度为 $len$ 的极长连续段，那么对于其左侧的一个单点 $s_{l-1}=0$，连续段内的元素都大于它，所以可以造成 $len$ 的贡献。

于是我们又得到了一种构造方法：令 $s[n-k+2,n]\leftarrow 1,s_{n-k+1}\leftarrow \frac{n(n+1)}{2}-(k-1)$ 即可。这样保证了连续段中的数单调不增，不会造成额外的贡献。

时间复杂度 $O(n)$。

## 代码
```cpp
void solve() {
    for (int i = 1; i <= n; ++i) s[i] = 0;
    if (k > n * (n + 1) / 2) {
    	for (int i = 1; i <= n; ++i) cout << 0 << " \n"[i == n];
    	return;
    }
    if (k < n) {
    	s[n - k + 1] = n * (n + 1) / 2;
        for (int i = 1; i < k; ++i) ++s[n - i + 1], --s[n - k + 1];
    	for (int i = 1; i <= n; ++i) cout << s[i] - s[i - 1] << " \n"[i == n];
    	return;
    }
    k -= n;
    int i;
    for (i = 1; i <= n; ++i) {
    	int v = n - i;
    	if (k > v) k -= v, s[i] = i;
    	else { s[n - k] = i; break; }
    }
    for (int j = n, p = 1; j >= i; --j) {
    	while (s[p]) ++p;
    	s[p] = j;
    }
    for (int i = 1; i <= n; ++i) cout << s[i] - s[i - 1] << " \n"[i == n];
}
```

---


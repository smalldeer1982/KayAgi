# 真真随机

## 题目背景

[摇曳轻落](https://music.163.com/#/song?id=22699115)。

这又何尝不是一种造计算机？

## 题目描述

你并不会伪伪随机，所以你要做一道简单题。


```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
unsigned int a[6],b[6];
char s[207];
signed main(){
	scanf("%s",s+1);
	n=strlen(s+1);
	a[1]=1;
	for(int _=1;_<=n;_++){
		char ch=s[_];
		for(int i=1;i<=5;i++) b[i]=0; 
		if(ch=='L'){
			b[2]+=a[1];
			b[2]+=a[3];
			b[4]+=a[5];
			b[2]+=a[4];
			b[4]+=a[2];
		}
		if(ch=='R'){
			b[1]+=a[2];
			b[3]+=a[1];
			b[3]+=a[5];
			b[4]+=a[2];
			b[4]+=a[3];
			b[5]+=a[2];
			b[5]+=a[4];
		}
		for(int i=1;i<=5;i++) a[i]=b[i];
	}
	printf("%u\n",a[1]);
	return 0;
}
```

如上是小 D 设计的，准备和你交互的程序。

因为小 D 不会配置交互题，所以请你构造一种输入使得该程序的输出恰好为 $n$。

## 说明/提示

### 样例解释

你可以直接把字符串输入进程序里。另外本题的程序不是瞎编的，具有一定实际意义，但是作为 J 组过于复杂所以无法告知你。

### 数据范围

本题共 $20$ 个测试点。

对于前 $20\%$ 的数据有 $n\le 10$。

对于前 $40\%$ 的数据有 $n\le 10^5$。

对于前 $60\%$ 的数据，保证在对应范围内随机生成。

对于所有数据，保证 $0 \le n\le 10^9$。你的字符串可以让小 D 的程序自然溢出。

## 样例 #1

### 输入

```
3```

### 输出

```
RLRLLLRLLLLR```

## 样例 #2

### 输入

```
3```

### 输出

```
LLRLLRLLRLLR```

## 样例 #3

### 输入

```
11776```

### 输出

```
RLRLRLLLRLRRLRLRLRLRLRLRLRLRLRLR```

## 样例 #4

### 输入

```
16```

### 输出

```
LRLRLRLRRLLRLR```

## 样例 #5

### 输入

```
47```

### 输出

```
RLRRLLRLRRLLRLRLLRRRLRRRRLR```

## 样例 #6

### 输入

```
720```

### 输出

```
RLRRRLRRLRLRRRLRRLLLRLLLRLRLLLR```

## 样例 #7

### 输入

```
176374```

### 输出

```
RRLLRRLRRLLRLLRRLLRLLRRLRLRLRRLLRLLRLLLLRLRLLRLLRLLRLLRLRLLRLR```

# 题解

## 作者：ty_mxzhn (赞：7)

~~直接吹水即可。~~

考虑人类智慧，如果我们拿第 $2$ 个点和第 $4$ 个点作为数值的存储器，把这两个数记为 $a,b$。

`RRLL` 这一操作可以把 $a\leftarrow a+2b$，`RL` 这一操作可以 $a\leftarrow a+b,b\leftarrow 2b$。

用这两个操作可以作为一种新型的二进制，其除了第一位以外都可以填 $1$ 或 $2$，第一位只能填 $1$。

显然这种新二进制和正常二进制的构造方法是一模一样的，但是由于第一位只能填 $1$，所以如果最后要求是偶数的话需要最后再反复利用 `RL`。

应该是有很多做法可以卡进限制里的。

```cpp
#include <bits/stdc++.h>
using namespace std;

int x,p,r;
signed main(){
	scanf("%d",&x);
	if(x==0){
		printf("L");
		return 0;
	}
	if(x==1){
		printf("LR");
		return 0;
	}
	while(x%2==0) x>>=1,r++; 
	for(int i=0;i<31;i++){
		if((x>>i)&1) p=i;
	}
	x-=(1<<p)-1;
	printf("L");
	for(int i=0;i<p;i++){
		if((x>>(i+1))&1) printf("RRLL");
		printf("RL");
	}
	printf("L");
	while(r--) printf("RL");
	printf("R");
	return 0;
} 
```

这也是题？这也是题？这也是题？这也是题？这也是题？这也是题？这也是题？这也是题？这也是题？

小 D 发现一些比较简洁的函数生成的字符串具有某种伪随机性质，请你看看他说的是否有道理！

---

## 作者：lovelish (赞：4)

发现几乎所有人的做法答案字符串长度都是极限 $\ge 4\log n$（包括官方题解），但自己的是 $3\log n$，因此决定写一篇题解。~~（为自己点赞）~~

首先我们很容易发现，若 $n$ 为 $2$ 的次幂，则直接一直重复输出 `LR` 即可。我们还很容易发现，当连续的 `L` 的数量大于 $1$ 时，再用一次 `L` 就相当于把 $a_2$ 与 $a_4$ 更换位置，那么也就意味着连续的 `L` 数量大于 $2$ 时就没有意义。

我们尝试找规律。

举个例子，先以 $n=16$ 为基础，然后添加 `L` 或 `R` 得到其他答案。

$n=16$ 时，按照上述所说，答案为 `LRLRLRLRLR`，枚举一下会发现无论怎么添加 `L`，答案都不会大于 $16$，然而按照上述所说，我们最多是只能添加 $5$ 个 `L` 的，因此我们枚举所有情况（每个位置都有放与不放，因此一共是 $2^5$ 种情况），得到下表：（每个答案的两种情况不一定有一定的规律，需自己进行调整以便寻找规律）


```
0 LLRLRLRLRLR
1 LLRLRLRLLRLLR LLRLRLRLRLLR 
2 LLRLRLLRLLRLR LLRLRLRLLRLR 
3 LLRLRLLRLLRLLR LLRLRLLRLRLLR
4 LLRLLRLLRLRLR LLRLRLLRLRLR
5 LLRLLRLLRLLRLLR LLRLLRLLRLRLLR 
6 LLRLLRLRLLRLR LLRLLRLLRLLRLR
7 LLRLLRLRLRLLR LLRLLRLRLLRLLR 
8 LRLLRLRLRLR LLRLLRLRLRLR
9 LRLLRLRLLRLLR LRLLRLRLRLLR
10 LRLLRLRLLRLR LRLLRLLRLLRLR
11 LRLLRLLRLLRLLR LRLLRLLRLRLLR
12 LRLRLLRLRLR LRLLRLLRLRLR
13 LRLRLLRLLRLLR LRLRLLRLRLLR
14 LRLRLLRLLRLR LRLRLRLLRLR
15 LRLRLRLLRLLR LRLRLRLRLLR
```

可以发现对于每个字符串我们可以分成五组，每组要么是 `LLR`，要么是 `LR`。每个答案的两种情况不一定有一定的规律，接下来以便寻找规律，我们进行调整并将多余的删除以及对齐每组：


```
0  LLR  LR  LR  LR  LR
1  LLR  LR  LR LLR LLR
2  LLR  LR LLR LLR  LR
3  LLR  LR LLR  LR LLR
4  LLR LLR LLR  LR  LR
5  LLR LLR LLR LLR LLR
6  LLR LLR  LR LLR  LR
7  LLR LLR  LR  LR LLR
8   LR LLR  LR  LR  LR
9   LR LLR  LR LLR LLR
10  LR LLR LLR LLR  LR
11  LR LLR LLR  LR LLR
12  LR  LR LLR  LR  LR
13  LR  LR LLR LLR LLR
14  LR  LR  LR LLR  LR
15  LR  LR  LR  LR LLR
```

对于前 $i$ 组都是 `LLR` 的：

$i=1$：$0\sim 7$

$i=2$：$4\sim 7$

$i=3$：$4\sim 5$

$i=4$：$5\sim 5$

可以发现，$i=1$ 与 $i=3$ 都是取了 $i-1$ 的前半段，$i=2$ 与 $i=4$ 都是取了 $i-1$ 的后半段，然而对于 $8\sim 15$ 的第 $2$ 组取的却是前半段，所以我们可以猜测：若这一组是 `LLR`，则下一组取的与这一组取的相反（即若这一组是取前半段，则下一组取后半段，若这一组取后半段，则下一组取前半段）；若这一组是 `LR`，则下一组取的与这一组取的相同。

枚举其他答案，发现符合猜想，我们直接找到最大的 $2$ 的次幂替换 $16$ 即可得到所有答案，该思路显然可用二进制实现，取前半段即 $2$ 进制下该位为 $0$，取后半段即 $2$ 进制下该位为 $1$。代码如下：


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
bool a[31];
int main()
{
	ios::sync_with_stdio(false);
    cin.tie(nullptr);
	int n;
	cin>>n;
	n*=2;
	for(int i=0;i<=30;i++)
	{
		a[i]=n&1;n>>=1;
	}
	int e=0;
	for(int i=30;i>=0;i--)
	{
		if(a[i]==e)
		{
			cout<<"LLR";
			e=!e;
		}
		else
		{
			cout<<"LR";
		}
	}
	return 0;
}

```

爆标了，难评。

---

## 作者：Rnfcr (赞：2)

因为只有操作 `R` 可以使得 $a_1$ 的值不为 $0$，因此考虑在 $a_2$ 上构造。

连续的 `RL` 操作可以使 $a_2$ 的值先传递到 $a_1,a_4,a_5$，然后再将 $a_1,a_4$ 的值传回到 $a_2$，所以一次 `RL` 操作可以使 $a_2 \leftarrow a_2 \times 2$。同时，此时 $a_4 = a_2 - 1$。


连续两次的 `L` 操作可以使 $a_2$ 与 $a_4$ 的值交换，所以一次 `LRLL` 操作可以使 $a_2 \leftarrow a_2 \times 2 - 1$。

初始时使用一次 `L` 操作可以使 $a_2 = 1$，通过 $a_2 \leftarrow a_2 \times 2$ 和  $a_2 \leftarrow a_2 \times 2 - 1$ 可以使 $a_2$ 为任意值，构造出 $n$ 后再用一次 `R` 操作便可使 $a_1 = n$。操作次数不大于 $4 \times \log n + 2$。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define pub push_back
#define mkp make_pair
#define pii pair<int,int>
using namespace std;
int n,tp[100];
signed main(){
	ios::sync_with_stdio(NULL),cin.tie(0),cout.tie(0);
	cin>>n;
	if(n==0){
		cout<<"Y";
		return 0;
	}
	n--;
	int pos=ceil(log2(n+1));
//	cout<<pos<<"\n";
	string s="";
	while(n){
		if(n&1) s+="1";
		else s+="0";
		n/=2;
	}
//	cout<<s;
	for(int i=0;i<s.length();i++){
		if(s[i]=='0') tp[pos-i]=1;
	}
	cout<<"L";
	for(int i=1;i<=pos;i++){
		if(tp[i]) cout<<"LRLL";
		else cout<<"RL";
	}
	cout<<"R";
	return 0;
}
```

---


# 相等排列 (equal)

## 题目背景

~~本题计划在 7 月初重新进行部分分设计。~~

由于个人原因，计划推迟。

## 题目描述

本题有 $T$ 组测试数据。

你需要构造 $n$ 个长度为 $m$ 的排列，使得 $n$ 个排列中的 $m$ 个数字所在的 $n$ 个排列中下标之和（下标从 $1$ 开始）都相等。若无解，请输出 $-1$。

## 说明/提示

对于 $100\%$ 的测试数据，保证 $1 \le T \le 10^6$，$1 \le n,m \le 10^6$，$\sum nm\le 10^6$。

## 样例 #1

### 输入

```
3
3 3
2 5
1 3```

### 输出

```
1 2 3
2 3 1
3 1 2
5 1 4 2 3
3 2 4 1 5
-1```

# 题解

## 作者：fish_love_cat (赞：4)

简单构造题。

---

首先偶数个排列显然可以 S 形构造。

奇数个排列时，如果长度是偶数，每一个数的下标和显然不是整数，于是无解。

于是只剩长度奇数的情况。

先考虑三个排列的构造。

不妨将第一个升序排序。

注意到每个下标的加和为 $3\times\frac{(1+m)}{2}$，然后第一个和第二个排列造成的贡献要刚好落满 $[3\times\frac{(1+m)}{2}-m,3\times\frac{(1+m)}{2}-1]$。

容易想到这么一个构造，在前两个排列搞出 $(1,m),(2,m-2),(3,m-4),\dots,(k,m-2k),(k+1,2m-2(k+1)),\dots,(k+d,2m-2k-2d)$ 这样的对，然后根据这个填第三个排列。

由于 $m$ 是奇数，刚好满足限制。

去掉这三个就变成偶数局面，解法一样同上。

于是做完了。

```cpp
#include<bits/stdc++.h>
using namespace std;
void solve(){
    int n,m;
    cin>>n>>m;
    if(n==1){
        if(m!=1)puts("-1");
        else puts("1");
        return;
    }
    if(n&1){
        if(m&1){
            map<int,int>mp;
            for(int i=1;i<=m;i++)cout<<i<<" ";cout<<'\n';
            for(int i=1,j=m;i<=m;i++,j=(j-2+m)%m)mp[j]=i;
            for(int i=1;i<=m;i++)cout<<mp[i]<<" ";cout<<'\n';
            for(int i=1,j=m;i<=m;i++,j=(j-2+m)%m)mp[((1+m)/2)*3-j-i]=i;
            for(int i=1;i<=m;i++)cout<<mp[i]<<" ";cout<<'\n';
        }else{
            puts("-1");
            return;
        }
        n-=3;
    }
    while(n){
        for(int i=1;i<=m;i++)cout<<i<<' ';cout<<'\n';
        for(int i=m;i;i--)cout<<i<<' ';cout<<'\n';
        n-=2;
    }
}
int main(){
    // ios::sync_with_stdio(0);
    // cin.tie(),cout.tie();
    int t;
    cin>>t;
    while(t--)solve();
    return 0;
}
```

---

## 作者：qwqerty (赞：2)

- 当 $n=1$ 时。
  - 若 $m=1$ 构造 $[1]$ 即可满足条件。
  - 若 $m>1$，每个数出现的位置都不相同且只出现一次，故无解。
- 当 $n\bmod2=0$ 时。  
  直接循环交替构造，即构造 $[1,2,3,\dots,m],[m,m-1,m-2,\dots,1],\dots,[m,m-1,m-2,\dots,1]$。$i$ 在相邻两个数组的下标中分别为 $i$ 和 $m-i+1$，其总和为 $m+1$，是个定值。故该构造满足条件。
- 当 $n>1$ 且 $n\bmod2=1$ 时。
  - 若 $m\bmod2=0$，则所有下标的和为 $\dfrac{nm(m+1)}{2}$。由于有 $m$ 个数，每个数的下标之和为 $\dfrac{n(m+1)}{2}$。若 $n\bmod2=1$ 且 $m\bmod2=0$ 则 $n(m+1)$ 为奇数，除不尽，没有满足条件的构造方式。
  - 若 $m\bmod2=1$。
    - 对于前 $n-3$ 组，可以套用 $n\bmod2=0$ 时的构造方式。其全部数的下标和相同。所以问题转化为 $n=3$ 时如何构造。
    - 对于 $n=3$ 时的情况，可以考虑先构造前两组，再通过 $\dfrac{n(m+1)}{2}$ 减去 $i$ 在前两个数组中的下标和形成最后一个数组。问题便转化为如何构造前两个数组，才能使 $\dfrac{n(m+1)}{2}$ 减去 $i$ 在前两个数组中的下标互不相同，构成一个排列。  
    考虑以下构造，第一行按顺序输出，即构造 $[1,2,3,\dots,m]$。第二行将后 $\dfrac{m+1}{2}$ 个数提前。$i$ 在第一个数组中的下标为 $i$，在第二个数组中，若 $i\le\dfrac{m-1}{2}$，则在数组中的下标为 $i+\dfrac{m+1}{2}$，否则在数组中的下标为 $i-\dfrac{m-1}{2}$。  
下面分情况讨论，对于第一种情况，$\dfrac{3(m+1)}{2}-i-(i+\dfrac{m+1}{2})=\dfrac{3(m+1)}{2}-2i-\dfrac{m+1}{2}=\dfrac{2(m+1)}{2}-2i=m+1-2i$。对于第二种情况，$\dfrac{3(m+1)}{2}-i-(i-\dfrac{m-1}{2})=\dfrac{3(m+1)}{2}-2i+\dfrac{m-1}{2}=\dfrac{3(m+1)}{2}-2i-\dfrac{m+1}{2}-1=\dfrac{2(m+1)}{2}-2i-1=m+1-2i-1=m-2i$。  
注意到第一种情况的位置必定为奇数，第二中情况的位置必定为偶数，所以它们不可能相同。对于每种情况，因为 $i$ 的值不同，所以它们的值也一定不相同。故构造出来的所有数都不相同，构成一个排列。

[通过代码。](https://www.luogu.me/paste/nkzp9mbk)

---

## 作者：lovelish (赞：2)

感觉此题的核心就是模拟找规律。

我们先从小规模数据分析起。

可以发现，若 $n=2$，我们可以构造出这样的排列：

$[1,2,3,\dots,m]$

$[m,m-1,m-2,\dots,1]$

那么也就意味着，若 $n$ 为偶数，我们直接把这复制 $\frac{n}{2}$ 份即可。

接下来我们考虑 $n$ 为奇数的情况。

计算可得当 $m$ 为偶数时无解（每个下标和为 $\frac{(1+m)*n}{m}$，显然不是整数），那么我们就只剩下了 $n,m$ 都为奇数的情况。

先特判 $n=1$：若 $n=m=1$ 构造 $[1]$，若 $n=1,m\ne 1$，显然无解。

接下来我们先考虑 $n=3$ 的情况。在此题中每个数字仅仅相当于一个名字，因此第一个排列不妨直接设为 $[1,2,3,\dots,m]$。

主要经过模拟可得以下这种构造方式：

首先在第二个排列第一个位置与第三个排列中间位置放置 $m$，我们设这两个下标分别为 $p,q$，当前放置的数字为 $x$，接下来，将 $p,q$ 都加一，直到 $q>m$ 前（也即 $p$ 超过中间位置前），这两个下标和会每次加 $2$，于是我们将 $x$ 每次减 $2$ 就可以保持下标和相同。例如 $m=11$ 时：

$[1,2,3,4,5,6,7,8,9,10,11]$

$[11,9,7,5,3,1,?,?,?,?,?]$

$[?,?,?,?,?,11,9,7,5,3,1]$

接下来差不多，这次我们把 $x$ 先设为 $m-1$，$p$ 为中间位置的下一个，$q$ 为 $1$，其他与上面都一样。例如 $m=11$ 时：

$[1,2,3,4,5,6,7,8,9,10,11]$

$[11,9,7,5,3,1,10,8,6,4,2]$

$[10,8,6,4,2,11,9,7,5,3,1]$

按照此方法构造即可通过所有 $n=3$ 的情况。

对于 $n>3$ 的奇数情况，可以发现与 $3$ 的差都为偶数，因此我们可以按照前面处理 $n$ 为偶数的方法去处理这个（即复制那两个单调排列）。于是本题就做完了。

下面是蒟蒻代码：


```cpp
#include<iostream>
using namespace std;
int main()
{
	int T;
	cin>>T;
	while(T--)
	{
		int n,m;
		cin>>n>>m;
		if(!(n&1))
		{
			for(int i=1;i<=n/2;i++)
			{
				for(int j=1;j<=m;j++)cout<<j<<" ";
				cout<<endl;
				for(int j=m;j>=1;j--)cout<<j<<" ";
				cout<<endl;
			}
		}
		else if(n&1&&!(m&1))cout<<-1<<endl;
		else
		{
			if(n==1)
			{
				if(m==1)cout<<1<<endl;
				else cout<<-1<<endl;
				continue;
			}
			for(int j=1;j<=m;j++)cout<<j<<" ";
			cout<<endl;
			for(int j=m;j>=1;j-=2)cout<<j<<" ";
			for(int j=m-1;j>=2;j-=2)cout<<j<<" ";
			cout<<endl;
			for(int j=m-1;j>=2;j-=2)cout<<j<<" ";
			for(int j=m;j>=1;j-=2)cout<<j<<" ";
			cout<<endl;
			n-=3;
			for(int i=1;i<=n/2;i++)
			{
				for(int j=1;j<=m;j++)cout<<j<<" ";
				cout<<endl;
				for(int j=m;j>=1;j--)cout<<j<<" ";
				cout<<endl;
			}
		}
	}
	return 0;
}


```

---

## 作者：Vct14 (赞：2)

构造好玩捏！！

先特判两种情况：若 $m=1$，则每一个排列均为只有一个数 $1$，一定满足要求；若 $m\ne 1$ 且 $n=1$，每个数都只出现一次，一定无法满足要求。

因为每一个排列中所有数的下标之和为 $\dfrac{m(m+1)}{2}$，因此 $n$ 个排列中所有数的下标之和为 $\dfrac{nm(m+1)}{2}$。又因为要求每个数在这 $n$ 个排列中的下标之和相等，所以每个数的下标之和都需要是 $\dfrac{n(m+1)}{2}$。显然这得是一个整数。因此若 $2\nmid n(m+1)$（即 $n$ 为奇数且 $m$ 为偶数）那么判断无解。

这提示我们按照 $n,m$ 的奇偶性分类。

若 $n$ 为偶数，我们可以发现构造两行即可满足要求：一行升序排列，一行降序排列。发现题目中并没有要求每行排列都不一样，于是可以直接构造 $\dfrac n2$ 组这样的排列。

若 $n$ 为奇数，我们考虑构造一组 $n=3$ 的解，然后因为 $n-3$ 一定为偶数，所以剩下的用上面的方法构造即可。不妨使 $n=3,m=5$，且第一行排列为 $\{1,2,3,4,5\}$。我们计算出每个数的下标和为 $\dfrac{3\times(5+1)}{2}=9$。然后经过简单地尝试（其实是因为主播不会往后推了【捂脸】），我们发现：



|数字|第一行中的下标|第二行中的下标|第三行中的下标|总和|
|:-:|:-:|:-:|:-:|:-:|
|$1$|$1$|$4$|$4$|$9$|
|$2$|$2$|$2$|$5$|$9$|
|$3$|$3$|$5$|$1$|$9$|
|$4$|$4$|$3$|$2$|$9$|
|$5$|$5$|$1$|$3$|$9$|

即可以如此构造：

```
1 2 3 4 5
5 2 4 1 3
3 4 5 1 2
```

也就是说，第一行构造 $1,2,\cdots,m$，第二行构造 $\dfrac{m-1}2+\dfrac{m+1}2,\dfrac{m-1}2,\dfrac{m-3}2+\dfrac{m+1}2,\dfrac{m-3}2,\cdots,1+\dfrac{m+1}2,1,\dfrac{m+1}2$，第三行构造 $\dfrac{m+1}2,\dfrac{m+1}2+1,\cdots,n,1,2,\cdots,\dfrac{m-1}2$。

下面证明这种构造满足要求。

容易发现第二行中，若下标 $x$ 为奇数，则 $a_x=\dfrac{m-x}2+\dfrac{m+1}2$；若下标 $x$ 为偶数，则 $a_x=\dfrac{m-x}2$。也就是说对于任意 $x$，若 $a_x\ge\dfrac{m+1}2$，则其下标 $x=m-2(a_x-\dfrac{m+1}2)$；若 $a_x<\dfrac{m+1}2$，则其下标 $x=m-2a_x$。

因此：如果 $i>\dfrac{m+1}2$，那么其在第一行中下标为 $i$，在第二行中下标为 $m-2(i-\dfrac{m+1}2)$，在第三行中下标为 $i-\dfrac{m+1}2$，和为 $i+i-\dfrac{m+1}2+m-2(i-\dfrac{m+1}2)=m+\dfrac{m+1}2$；否则其在第一行中下标为 $i$，在第二行中下标为 $m-2i$，在第三行中下标为 $i+\dfrac{m+1}2$，和为 $i+i+\dfrac{m+1}2+m-2i=m+\dfrac{m+1}2$。即这样构造符合要求。



```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	int t;cin>>t;
	while(t--){
		int n,m;cin>>n>>m;
		if(m==1){
			for(int i=1; i<=n; i++) cout<<"1\n";
			continue;
		}
		if(n*(m+1)%2 || n==1){
			cout<<"-1\n";
			continue;
		}
		if(n%2){
			for(int i=1; i<=m; i++) cout<<i<<" \n"[i==m];
			for(int i=m/2; i>=1; i--) cout<<i+(m+1)/2<<" "<<i<<" ";cout<<(m+1)/2<<"\n";
			for(int i=1; i<=m; i++) cout<<(i+m/2-1)%m+1<<" \n"[i==m];
			n-=3;
		}
		for(int i=1; i<=n/2; i++){
			for(int j=1; j<=m; j++) cout<<j<<" \n"[j==m];
			for(int j=m; j>=1; j--) cout<<j<<" \n"[j==1];
		}
	}
	return 0;
}
```

---

## 作者：Down_syndrome (赞：2)

既然是神@[wmrqwq](https://www.luogu.com.cn/user/820056) 的题，那必须来做一下了。

非常经典的脑洞构造题。

约定：对于一个数，下标值为所有排列中出现这个数的下标之和；升序排列为 $1,2,\dots,m$；降序排列为 $m,m-1,\dots,1$。

## 思路

**当 $n\equiv 0\pmod 2$ 时：**

不难发现直接输出 $\dfrac{n}{2}$ 个升序排列和降序排列即可。

**当 $n\equiv 1\pmod 2$ 时：**

当 $m\equiv 0\pmod 2$ 时，可以发现排列值总和是 $\dfrac{nm(m+1)}{2}$，所以平均下来每个数的排列值是 $\dfrac{n(m+1)}{2}$，这时候这玩意都不是整数，所以肯定无解。

当 $m\equiv 1\pmod 2$ 时：

若 $n=1$，则除 $m=1$ 外无解。

若 $n>3$，可以通过输出 $\dfrac{n-3}{2}$ 个升序排列和降序排列的方式转换为 $n=3$。

若 $n=3$：

这里才是重头戏，需要一点点脑洞的构造。这里给出其中一种方案。

第一个排列为升序排列。

第二个排列为**先从大到小的奇数，再从大到小的偶数**。

第三个排列为**先从大到小的偶数，再从大到小的奇数**。

例如当 $m=9$ 时就是：

```
1 2 3 4 5 6 7 8 9
9 7 5 3 1 8 6 4 2
8 6 4 2 9 7 5 3 1
```

可以发现这样构造是合法的，原因是，对于一个数 $i$，再第二和三个排列的排列值之和恰好比 $i+1$ 的大 $1$。

例如，对于数 $2$，它在后两个的出现位置是 $9$ 和 $4$，而数 $3$ 出现位置是 $9,3$，恰好一个位置大一。容易发现对于其它数也是这样。

所以 $i$ 和 $i+1$ 的排列值总和相同。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m;
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d%d",&n,&m);
		if(n%2==0){
			for(int i=1;i<=n/2;i++){
				for(int j=1;j<=m;j++) printf("%d ",j);
				printf("\n");
				for(int j=m;j>=1;j--) printf("%d ",j);
				printf("\n");
			}
		}
		else{
			if(n==1&&m==1) printf("1\n");
			else if(n==1||m%2==0) printf("-1\n");
			else{
				for(int i=1;i<=m;i++) printf("%d ",i);
				printf("\n");
				for(int i=m;i>=1;i-=2) printf("%d ",i);
				for(int i=m-1;i>=1;i-=2) printf("%d ",i);
				printf("\n");
				for(int i=m-1;i>=1;i-=2) printf("%d ",i);
				for(int i=m;i>=1;i-=2) printf("%d ",i);
				printf("\n");
				for(int i=1;i<=(n-3)/2;i++){
					for(int j=1;j<=m;j++) printf("%d ",j);
					printf("\n");
					for(int j=m;j>=1;j--) printf("%d ",j);
					printf("\n");
				}
			}
		}
	}
	return 0;
}
```

---


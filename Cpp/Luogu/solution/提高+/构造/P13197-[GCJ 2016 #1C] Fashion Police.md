# [GCJ 2016 #1C] Fashion Police

## 题目描述

你因为对 2016 年 Code Jam 世界总决赛的兴奋，刚刚搬到了纽约。你带来了 $\mathbf{J}$ 件不同的夹克（编号为 $1$ 到 $\mathbf{J}$）、$\mathbf{P}$ 条不同的裤子（编号为 $1$ 到 $\mathbf{P}$）、以及 $\mathbf{S}$ 件不同的衬衫（编号为 $1$ 到 $\mathbf{S}$）。你拥有的衬衫数量不少于裤子的数量，裤子的数量不少于夹克的数量，即满足 $(\mathbf{J} \leqslant \mathbf{P} \leqslant \mathbf{S})$。

每天，你会选择一件夹克、一条裤子和一件衬衫组成当天的穿搭。每天晚上你都会清洗所有衣物，因此每天所有衣物都可以重新使用。

在纽约，**时尚警察**随时在监视并记录每个人每天的穿着。如果他们发现你穿过完全相同的穿搭两次，你就会立刻被带到五大道的“时尚监狱”进行强制改造；你当然不希望那样！如果他们发现你穿过同一对衣物组合的次数超过 $\mathbf{K}$ 次，你也会立刻被带到时尚监狱。所谓“组合”，是指某一件夹克和某一条裤子的组合、某一件夹克和某一件衬衫的组合，或者某一条裤子和某一件衬衫的组合。例如，在穿搭 (夹克 1, 裤子 2, 衬衫 3) 和 (夹克 1, 裤子 1, 衬衫 3) 这两天中，组合 (夹克 1, 衬衫 3) 出现了两次，而组合 (裤子 1, 衬衫 3) 只出现了一次。

每天你只能穿一套衣服。你能否找出最多可以连续多少天避免被送进时尚监狱，并给出每天的穿搭方案列表？

## 说明/提示

**样例解释**

样例输出展示了一组可行解，其他答案也可能是正确的。

在第 1 组中，尽管时尚警察对 $\mathbf{K}$ 的限制很宽松（$10$），但你只能组成一种穿搭，因此只能坚持一天。

在第 2 组中，添加任何其他穿搭都会导致你被送进时尚监狱：

- 添加 1 1 3 会导致组合 (夹克 1, 裤子 1) 出现超过 2 次。
- 添加 1 2 2 会导致组合 (夹克 1, 裤子 2) 出现超过 2 次。

在这种情况下，任意 5 套穿搭都必然存在至少一处时尚违规。

注意，单日穿搭中的夹克、裤子、衬衫编号不需要像 $\mathbf{J}, \mathbf{P}, \mathbf{S}$ 那样满足递增关系。

在第 3 组中，你只有一种夹克+裤子的组合，只能反复穿，所以无论衬衫怎么选，都无法组成超过 $\mathbf{K}=2$ 套不同的穿搭。

在第 4 组中，另一组同样规模的最大解为：

```
1 2 2
1 1 1
```


**限制条件**

- $1 \leqslant \mathbf{T} \leqslant 100$。
- $1 \leqslant \mathbf{J} \leqslant \mathbf{P} \leqslant \mathbf{S}$。
- $1 \leqslant \mathbf{K} \leqslant 10$。

**小数据集（测试集 1 - 可见）**

- $\mathbf{S} \leqslant 3$。

**大数据集（测试集 2 - 隐藏）**

- $\mathbf{S} \leqslant 10$。

翻译由 GPT4.1 完成。

## 样例 #1

### 输入

```
4
1 1 1 10
1 2 3 2
1 1 3 2
1 2 3 1```

### 输出

```
Case #1: 1
1 1 1
Case #2: 4
1 1 2
1 2 3
1 2 1
1 1 1
Case #3: 2
1 1 2
1 1 1
Case #4: 2
1 1 3
1 2 1```

# 题解

## 作者：fish_love_cat (赞：2)

由于题目的限制，容易发现答案至多不超过 $J\times P\times\min(S,K)$。

考虑构造满这个东西。

首先肯定是对于每个 $(j,p)$ 进行讨论。

我们可以这样，对于每一个对的出现次数 $a$，取三个值加起来模 $S$ 的值放进去当 $s$，这样对于每一个 $j$ 或者 $p$，都有且只有一个对应的数会遇到相同的 $s$，限制也就解决了。

做完了，感觉并不难想。

```cpp
// 「虽然我从更高更远的地方看过悬浮岛，可是至今为止，我都没有好好地从城里俯望过整座城市。」
// 「所以我想，至少应该看过一次才对。嗯。我的梦想实现了，也留下美好的回忆，我已经没有任何遗憾了。」
// 「今天真的很谢谢你。发生了好多美好的事情。全都是托你的福。」
#include<bits/stdc++.h>
#define mk make_pair
#define pb push_back
using namespace std;
void solve(int flc){
    printf("Case #%d: ",flc);
    int j,p,s,k;
    cin>>j>>p>>s>>k;
    cout<<min(s,k)*j*p<<endl;
    for(int a=1;a<=j;a++)
    for(int b=1;b<=p;b++)
    for(int c=1;c<=min(s,k);c++){
        cout<<a<<' '<<b<<' '<<(a+b+c)%s+1<<'\n';
    }
}
int main(){
    int t;
    cin>>t;
    for(int flc=1;flc<=t;flc++)solve(flc);
    return 0;
}
// 「是啊。我留下了美梦般的回忆，不过时间到了。」
// 「最后我想再拜托你一件事就好。但愿你能忘了我。」

// Chtholly Nota Seniorious
```

---

## 作者：fyxblyn (赞：1)

## 题意
构造尽可能多的不同的三元组 $(j,p,s)$，使得任意 $(j,p),(j,s),(p,s)$ 的组合出现次数不超过 $K$。

## 思路
由于题目给出 $J \leqslant P \leqslant S$ ，我们发现能组成的 $(j,p)$ 数量最少，那么同种 $(j,p)$ 的出现次数一定最多。

考虑一种 $(j,p)$ 最多的出现次数，我们发现其同时受到 $S$ 和 $K$ 的限制，即不能超过 $S$
（否则会出现重复三元组）也不能超过 $K$（题目限制）。

一共能组成 $J \times P$ 种不同的 $(j,p)$，那么答案即为：
$$J \times P \times \min(S,K)$$

接下来解释如何构造方案。

记 $D=\min(S,K)$，我们枚举所有可能的 $(j,p) \ D$ 次并记录这是该组合第几次出现，在一个组合 $(j,p)$ 第 $d$ 次出现时，我们让 $s=((j+p+d)\mod S)+1$ 与之匹配，这样既能保证所有的 $(j,p)$ 组合出现次数不超过限制，也保证了所有的 $(j,s)$ 与 $(p,s)$ 组合出现次数不超过 $D$，自然也不超过 $K$。

具体实现可以参考代码。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1e5+5;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    int t;
    cin>>t;
    for(int z=1;z<=t;z++)
    {
        int J,P,S,K;
        cin>>J>>P>>S>>K;
        int D=min(K,S);
        int sum=J*P*D;
        cout<<"Case #"<<z<<": "<<sum<<'\n';
        for(int d=1;d<=D;d++)
            for(int j=1;j<=J;j++)
                for(int p=1;p<=P;p++)
                {
                    int s=(j+p+d)%S;
                    cout<<j<<" "<<p<<" "<<s+1<<'\n';
                }
    }
    return 0;
}
```

---

## 作者：无名之雾 (赞：0)

没看懂为啥蓝。

## solution

一个自然的刻画，是将衣服搭配看作在一个 $J\times P \times S$ 的坐标系中选择格子。

两个约束就分别变成了：

- 选择的格子要互不相同。
- 同一条直线上最多只能选取 $K$ 个格点。

于是最大值就应该为：
$$\min(J\times P \times S,J\times P \times K)$$

构造方法也较为简单。

对于每对 $(J,P)$，我们要选出 $K$ 个不同的 $S$ 值。

只需要令 $S=(J+P+K) \bmod S$ 即可。

正确性显然。代码是好写的，就不放了。

---


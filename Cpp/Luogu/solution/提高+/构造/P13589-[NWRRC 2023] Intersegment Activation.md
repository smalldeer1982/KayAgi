# [NWRRC 2023] Intersegment Activation

## 题目描述

这是一个交互题。

有一个包含 $n$ 个格子的数组，编号从 $1$ 到 $n$。对于每一对整数 $(i, j)$，其中 $1 \le i \le j \le n$，都有一个覆盖从 $i$ 到 $j$（包括 $i$ 和 $j$）的屏障。每个屏障要么是激活的，要么是未激活的。如果没有任何激活的屏障覆盖某个格子，则该格子是可见的；否则，该格子是不可见的。

你并不知道每个屏障的状态。你唯一能观察到的是当前可见格子的数量。但你可以翻转任意一个屏障的状态：如果它是激活的，则变为未激活，反之亦然。你的任务是让所有屏障都变为未激活状态，使得所有格子都可见。

### 交互协议

首先，读取一个整数 $n$，表示格子的数量（$1 \le n \le 10$）。

接下来的交互将分为若干轮进行。你的程序每一轮应先读取一个整数 $k$，表示当前可见格子的数量（$0 \le k \le n$）。

- 如果 $k = n$，则任务完成，你的程序应当退出。
- 如果 $k < n$，你可以翻转任意一个屏障的状态。在单独一行输出两个整数 $i$ 和 $j$，表示翻转 $(i, j)$ 这个屏障的状态（$1 \le i \le j \le n$）。在你的操作之后，进入下一轮，你需要读取新的 $k$ 值。

你的解法必须在不超过 $2500$ 次翻转内使所有格子可见。初始时，并非所有格子都是可见的（第一轮 $k < n$）。

交互器是非自适应的：每个测试中，所有屏障的状态在程序执行前就已确定。

## 说明/提示

初始状态。

![](https://cdn.luogu.com.cn/upload/image_hosting/f8uw3js6.png)

在示例中，最初只有 $(1, 2)$ 和 $(2, 3)$ 两个屏障是激活的。这两个屏障覆盖了所有三个格子，因此第一轮 $k = 0$。

- 翻转 $(2, 2)$ 屏障后，现在有三个激活的屏障，依然 $k = 0$ 个可见格子。
- 翻转 $(1, 2)$ 屏障后，第 $1$ 个格子变为可见，因此现在 $k = 1$ 个可见格子。
- 翻转 $(2, 3)$ 屏障后，第 $3$ 个格子也变为可见。现在唯一不可见的格子是 $2$，它被唯一激活的屏障 $(2, 2)$ 覆盖，此时 $k = 2$ 个可见格子。
- 翻转 $(2, 2)$ 屏障后，所有屏障都未激活，所有格子都可见。读取到 $k = 3$ 后，程序终止。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3
0

0

1

2

3```

### 输出

```


2 2

2 3

1 2

2 2```

# 题解

## 作者：Asedwai (赞：0)

为了方便，将屏障视作区间。
## 题面
有一个包含 $n(n\le 10)$ 个单元格的数组，任意一个区间的状态可能是**激活**或**未激活**。如果一个单元格没有被任何激活的区间覆盖，则称其为**可见的**，否则为**不可见的**。

你一开始不知道任意区间的状态，但可以知道有多少个单元格是可见的，或者翻转任意区间的状态。你需要使所有单元格可见。

刚开始和每次操作后都会告诉你有多少个单元格是可见的。你需要在 $2500$ 次操作内完成任务。
## 思路
首先考虑如何判断单元格 $x$ 是否可见：设原可见单元格数量为 $k$，翻转 $[x,x]$ 后可见单元格数量为 $k'$；若 $k'<k$，则 $x$ 可见；否则不可见。当然我们应该在判断完后翻回去，以免影响后续操作。  

::::info[证明]
翻转 $[x,x]$ 不会影响其它单元格是否可见，所以 $k$ 的变化只与单元格 $x$ 以及包含 $x$ 的区间是否被激活有关。

- 若原本 $x$ 可见，则翻转 $[x,x]$ 后必然不可见，此时 $k'<k$；

- 若原本 $x$ 不可见，且只有 $[x,x]$ 被激活，翻转后 $x$ 可见，此时 $k'>k$；

- 若原本 $x$ 不可见，且存在 $[l,r]$ 被激活（满足 $1\le l\le x\le r$），翻转后 $x$ 仍然不可见，此时 $k'=k$。

由此可以推得若 $k'<k$ 则单元格 $x$ 原本可见，否则原本不可见。
::::

可以发现我们很难有办法来判断一开始某个区间是否被激活。所以容易想到暴力枚举某些区间是否翻转。具体来说，我们可以暴力枚举 $[1,1],[1,2],[1,3],\dots,[1,n]$ 是否被翻转，其中必定有一种方案会使单元格 $1$ 可见，这说明所有包含 $1$ 的区间都是未激活的，于是变为了大小为 $n-1$ 的子问题。  

直接枚举二进制再决定翻转需要花费至多 $2\sum\text{popcount}(i)$ 次操作（乘 $2$ 是因为如果 $1$ 不可见需要再翻回去）。这我们不能接受。我们需要每翻一个区间就得到一种状态，并且状态不会重复。考虑初始设 $x=0$ 进行递推：顺序枚举 $i$，若 $x\oplus 2^i$ 没有出现过则让 $x\oplus 2^i\to x$ 并将 $0\to i$ 后重新循环。打表可以验证当无法再递推时所有的状态都会被枚举。

由于判断单元格是否可见需要两次操作，所以直觉上 $n=10$ 时操作次数大约为 $3\times (2^{11}-2)>2500$。考虑优化。

设原先可见单元格数量为 $k$，仍然暴力枚举 $[1,1],[1,2],[1,3],\dots,[1,n]$ 是否被翻转，设翻转所对区间后的可见单元格数量为 $k'$。当 $k'>k$ 时，我们立即停止枚举状态，并且找到是哪些单元格可见，记为 $i_1<i_2<\dots<i_{k'}$。此时所有包含 $i_1$ 或 $i_2$ 或 $\dots$ 或 $i_{k'}$ 的区间都是未被激活的，那么问题变为关于 $[1,i_1-1],[i_1+1,i_2-1],\dots,[i_{k'}+1,i_{k'}-1],[i_{k'}+1,n]$ 的子问题。递归的做就行了。

可以发现每次至少使一个新的单元格变为可见，因此下一次枚举的状态数至少除以 $2$，可以将操作次数看作 $2^{n+1}+2n^2$（实际上远远不到），在 $n=10$ 时为 $2248<2500$，显然不超限。

## 代码
使用 dfs 代替了递推枚举状态。仅供参考。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define LOCAL
#ifdef LOCAL
#define debug(format, args...) fprintf(stderr,\
"[\tLOG](Func:%s(), Line:%d): "   \
, __FUNCTION__, __LINE__);       \
fprintf(stderr, format"\r\n", ##args)
#else
#define debug(format, args...)  do {} while (0)
#endif
//#define endl "\n"
#define LL long long
template <typename T> void chmax(T &x, T y) { if(y > x) x = y; }
template <typename T> void chmin(T &x, T y) { if(y < x) x = y; }
#define fer(i, a, b, args...) for(int i = (a), ##args; i <= (b); i ++)
#define fel(i, a, b, args...) for(int i = (a), ##args; i >= (b); i --)
const int N = 2e5 + 10;
#define fi first
#define se second
int n; 
int ask(int l, int r) {
	cout << l << ' ' << r << endl; 
	int k; cin >> k; 
	if(k == n) exit(0); 
	return k; 
}
bool f[N]; 
int k; 
void dfs(int x, int i, int R) {
	if(x >= (1 << R) || f[x]) return ; 
    f[x] = 1; 
    fer(j, 0, R - 1) {
    	if(!f[x ^ (1 << j)]) {
    		int v = ask(i, i + j); 
    		if(v > k) {
    			k = v; 
    			return ; 
    		}
    		return dfs(x ^ (1 << j), i, R); 
    	}
    }
    return ; 
}
bool query(int x) {
	bool f = ask(x, x) < k; 
	ask(x, x); 
	return f; 
}
void solve(int l, int r, bool op) {
	if(l > r) return ; 
	if(op) {
		int j = l; 
		fer(i, l, r) {
			if(query(i)) {
				solve(j, i - 1, 0); 
				j = i + 1; 
			}
		}
		solve(j, r, 0); 
	} else {
		fer(x, 0, 1024) f[x] = 0; 
		dfs(0, l, r - l + 1); 
		solve(l, r, 1); 
	}
}
signed main() { 
	ios::sync_with_stdio(false);
	cin.tie(nullptr); cout.tie(nullptr); 
	cin >> n >> k; 
	solve(1, n, 1); 
	return 0; 
}
```

---


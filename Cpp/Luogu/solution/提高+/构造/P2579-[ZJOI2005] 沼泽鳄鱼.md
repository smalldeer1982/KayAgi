# [ZJOI2005] 沼泽鳄鱼

## 题目描述

潘塔纳尔沼泽地号称世界上最大的一块湿地，它地位于巴西中部马托格罗索州的南部地区。每当雨季来临，这里碧波荡漾、生机盎然，引来不少游客。

为了让游玩更有情趣，人们在池塘的中央建设了几座石墩和石桥，每座石桥连接着两座石墩，且每两座石墩之间至多只有一座石桥。这个景点造好之后一直没敢对外开放，原因是池塘里有不少危险的食人鱼。

豆豆先生酷爱冒险，他一听说这个消息，立马赶到了池塘，想做第一个在桥上旅游的人。虽说豆豆爱冒险，但也不敢拿自己的性命开玩笑，于是他开始了仔细的实地勘察，并得到了一些惊人的结论：食人鱼的行进路线有周期性，这个周期只可能是 $2$、$3$ 或者 $4$ 个单位时间。每个单位时间里，食人鱼可以从一个石墩游到另一个石墩。每到一个石墩，如果上面有人它就会实施攻击，否则继续它的周期运动。如果没有到石墩，它是不会攻击人的。

借助先进的仪器，豆豆很快就摸清了所有食人鱼的运动规律，他要开始设计自己的行动路线了。每个单位时间里，他只可以沿着石桥从一个石墩走到另一个石墩，而不可以停在某座石墩上不动，因为站着不动还会有其它危险。如果豆豆和某条食人鱼在同一时刻到达了某座石墩，就会遭到食人鱼的袭击，他当然不希望发生这样的事情。

现在豆豆已经选好了两座石墩 $\mathrm{Start}$ 和 $\mathrm{End}$，他想从 $\mathrm{Start}$ 出发，经过 $K$ 个单位时间后恰好站在石墩 $\mathrm{End}$ 上。假设石墩可以重复经过（包括 $\mathrm{Start}$ 和 $\mathrm{End}$），他想请你帮忙算算，这样的路线共有多少种（当然不能遭到食人鱼的攻击）。

## 说明/提示

对于 $100 \%$ 的数据，$1 \leq N \leq 50$，$1 \leq K \leq 2 \times 10^9$，$1 \leq \mathrm{NFish} \leq 20$。

## 样例 #1

### 输入

```
6 8 1 5 3
0 2
2 1
1 0
0 5
5 1
1 4
4 3
3 5
1
3 0 5 1
```

### 输出

```
2```

# 题解

## 作者：hs_black (赞：32)

机房大佬讲解后, 写一写题解

### 这是很经典的邻接矩阵乘法了

对于邻接矩阵G\[i][j] 表示i到j有没有边

如果是$G^1$ , 发现就是原矩阵,  G\[i][j]可以理解为从i走一步到j的方案数

下面考虑$G^2$ 

矩阵乘法代码:

```cpp
Matrix operator * (const Martix &p) const{
		Martix tmp;
		for (rint i = 0;i < n; i++) 
			for (rint j = 0;j < n; j++) 
				for (rint k = 0;k < n; k++) 
					tmp.Mar[i][j] = (tmp.Mar[i][j] + Mar[i][k] * p.Mar[k][j]) % P;
		return tmp;
	}
```

发现$G^2[i][j] = \sum_{k=0}^{n-1}  G[i][k] * G[k][j]$ 像不像Floyd

即枚举一个中间点k, 从i到j走两步的的方案数等于从i到走一步k的方案数, 再乘上从k走一步到j的方案数之和

以此类推

$G^t[i][j]$为再G这个邻接矩阵上从i走t步到j的方案数

### 原矩阵$G^0$为单位矩阵, 每乘一个新的邻接矩阵相当于又在新的邻接矩阵上走一步

回到本题

2, 3, 4的最小公倍数为12

所以开十二个邻接矩阵即可, 每个矩阵表示当前走一步的合法情况

a[0]表示走12步的矩阵, 即12个邻接矩阵之积

k/12个a[0]相乘使用快速幂, 在按顺序从a[1]乘到a[k%12]

答案为 $a[0]^{k/12} * a[1] * a[2] * \cdots s[k\%12]$ 

细节见代码及注释:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std;
template <typename T> 
void read(T &x) {
	x = 0; int f = 1;
	char c = getchar();
	for (;!isdigit(c);c=getchar()) if (c=='-') f=-1;
	for (;isdigit(c);c=getchar()) x = (x << 3) + (x << 1) + c - '0';
	x *= f;
}//快读
const int N = 52;
int n, m;
ll t, k;
const int P = 10000;
#define rint register int
struct matrix{
	int Mar[N][N];
	matrix () {
		memset(Mar, 0, sizeof(Mar));
	}
	matrix operator * (const matrix &p) const{
		matrix tmp;
		for (rint i = 0;i < n; i++) 
			for (rint j = 0;j < n; j++) 
				for (rint k = 0;k < n; k++) 
					tmp.Mar[i][j] = (tmp.Mar[i][j] + Mar[i][k] * p.Mar[k][j]) % P;
		return tmp;
	}//矩阵乘法
	void print(void) {
		for (int i = 0;i < n; i++) {
			for (int j = 0;j < n; j++) 
				printf ("%d ", Mar[i][j]);
			cout << endl;
		}
		cout << endl;
	}//调试输出
}a[15], b, c;

matrix pow() {
	matrix ans = b, tmp = a[0];
	int tttmp = k / 12;
	while (tttmp) {
		if (tttmp & 1) ans = ans * tmp;
		tmp = tmp * tmp;
		tttmp >>= 1;
	}
	return ans;
}//矩阵快速幂
int nfish, ttmp[50], st, ed;			
int main() {
//	freopen("hs.out","w",stdout);
	read(n), read(m), read(st), read(ed), read(k);
	while (m--) {
		int x, y;
		read(x), read(y);
		c.Mar[x][y] = c.Mar[y][x] = 1; //原矩阵
	}
//	c.print();
	for (rint i = 1;i <= 12; i++) a[i] = c; //初始化
	for (rint i = 0;i < n; i++) b.Mar[i][i] = 1; //单位矩阵
	read(nfish);
	while (nfish--) {
		read(t);
		for (int i = 0;i < t; i++) read(ttmp[i]); ttmp[t] = ttmp[0]; 
        	//由于开始时时间为0, 所以读入要从零开始
		for (int i = 1;i <= 12; i++) 
			for (int j = 0;j < n; j++) 
				a[i].Mar[j][ttmp[(i-1)%t+1]] = 0; 
        		//注意只清空从其他地方到鳄鱼新来的地点的边
	}
//	for (int i = 1;i <= 12; i++) a[i].print();
	a[0] = b;
	for (int i = 1;i <= 12; i++) a[0] = a[0] * a[i];	
//	a[0].print();
	matrix ans = pow();
	for (int i = 1;i <= k % 12; i++) ans = ans * a[i];
	cout << ans.Mar[st][ed] << endl;
	return 0;
}
```



---

## 作者：beretty (赞：23)

今天刚刚学习了矩阵乘法（然而全机房可能就我自己不会

看到网上说这道题是矩阵乘法的入门题,于是就来尝试

然后我肯定是不会的,于是就深入思考~~看题解~~

发现邻接矩阵做乘法有些神奇的性质

对于任意$g[i][j]^n$ , 表示从i出发走n步恰好到j的方案数

了解了这个性质以后,这道题就肥肠明了了

但是还要考虑食人鱼的问题

我们发现食人鱼游动的周期只有$2,3,4$三种

所以我们就直接处理他们的最小公共周期$12$

我们设g[i]表示在走第 $k * 12 + i (k∈Z)$ 步的时候整个图的联通情况

然后我们就处理出每走$12$步的后情况的矩阵

然后以每$12$步为一个整体做快速幂

最后单独处理余下的时间即可

上代码↓

```
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
const int M = 55 ;
const int N = 15 ;
const int mod = 10000 ;
using namespace std ;
int n , m , s , t , k , Fish ;
int G[M][M] ;
struct Mat{
	int f[M][M] ;
}Ans , g[N] , b , st ;
int w[M] ;
Mat operator * (Mat A , Mat B){
	Mat temp ;
	memset(temp.f , 0 , sizeof(temp.f)) ;
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=n;j++)
	    for(int k=1;k<=n;k++)
	      temp.f[i][j] = (temp.f[i][j] + A.f[i][k] * B.f[k][j])%mod ;
	return temp ;
}
inline Mat Pow(Mat Base , int k){
	Mat temp = st ;
	while(k){
		if(k&1) temp = (temp * Base) ;
		Base = (Base * Base) ; k >>= 1 ;
	}
	return temp ;
}
int main(){
	cin >> n >> m >> s >> t >> k ;
	++s ; ++t ;
	for(int i=1;i<=n;i++) st.f[i][i] = 1 ;
	for(int i=1 , x , y;i<=m;i++){
		cin >> x >> y ;
		++x , ++y ;
        for(int j=1;j<=12;j++) g[j].f[x][y] = g[j].f[y][x] = 1 ;
	}
	cin >> Fish ;
	while(Fish--){
		int num = 0 ; cin >> num ;
		for(int i=1;i<=num;i++)  cin >> w[i] , w[i]++ ;
		for(int i=1;i<=n;i++)
		  for(int j=0;j<=12;j++)
		    g[j].f[i][w[j%num + 1]] = 0 ;
	}
	for(int i=1;i<=n;i++) b.f[i][i] = 1 ;
	for(int i=1;i<=12;i++) b = (b * g[i]) ;
	Ans = Pow(b , k/12) ;
	for(int i=1;i<=k%12;i++) Ans = (Ans * g[i]) ;
    cout << Ans.f[s][t] <<endl ;
    return 0 ;
}
```

---

## 作者：Mychael (赞：13)

给我的博客打个广告：

[Mychael的无声乐章](https://www.cnblogs.com/Mychael/)



**邻接矩阵乘法**


在写这道题之前，我们先了解邻接矩阵乘法的意义

什么邻接矩阵还有乘法？

想想对于，G[i][j]，如果存在i->j的边那么G[i][j]=1

如果我们把这看做G的一次幂，理解为只走一步时i->j的路线条数【当然肯定是1啦。。】


对于G^2呢？

对于所有的G[i][k]和G[k][j]，都会相乘且结果存在最后的G'[i][j]中，难道这不是走两步时i->j的路线么？


由此，对于任意G^n[i][j],表示从i出发走n步到j的方案数【可以中途经过j】


典题：给定一张图，求从i出发走k步到j的方案数。



**题解**


有了这样的知识储备，似乎解出这道题就不是难事了。

等等。。食人鱼怎么考虑？

仔细观察，食人鱼的周期很小，为2,3,4，最小公倍数是12

也就是说，我们可以对12个时间内每个时间点建一个邻接矩阵，然后顺次【注意是顺次，矩阵乘法没有交换律】相乘

为了降低复杂度，其中[K/12]组可以放在一起用快速幂算出


坑点：

1、注意正确把握周期时间点，从A[1]乘到A[11]再乘A[0]

1、矩阵乘法没有交换律，得先预处理Q=A[1]\*A[2]\*......\*A[11]\*A[0]，再用算出Q^[K/12]，对于剩下的，从A[1]开始乘完K%12个【这个坑了我好久】

3、标号从0开始= =










```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define LL long long int
using namespace std;
const int maxn=55,INF=2000000000,P=10000;
inline int read(){
    int out=0,flag=1;char c=getchar();
    while(c<48||c>57) {if(c=='-') flag=-1;c=getchar();}
    while(c>=48&&c<=57){out=out*10+c-48;c=getchar();}
    return out*flag;
}
struct Matrix{
    LL s[maxn][maxn],n,m;
    Matrix() {n=m=0;memset(s,0,sizeof(s));}
}A[20],Q;
inline Matrix operator *(const Matrix& a,const Matrix& b){
    Matrix c;
    if(a.m!=b.n) return c;
    c.n=a.n;c.m=b.m;
    for(int i=1;i<=c.n;i++)
        for(int j=1;j<=c.m;j++)
            for(int k=1;k<=a.n;k++)
                c.s[i][j]=(c.s[i][j]+a.s[i][k]*b.s[k][j])%P;
    return c;
}
Matrix qpow(Matrix a,LL b){
    Matrix ans;
    ans.n=ans.m=a.n;
    for(int i=1;i<=ans.n;i++) ans.s[i][i]=1;
    for(;b;b>>=1,a=a*a) if(b&1) ans=ans*a;
    return ans;
}
int N,M,S,E,K,uns[20][maxn],G[maxn][maxn];
void init(){
    N=read();M=read();S=read()+1;E=read()+1;K=read();
    int a,b;
    while(M--){
        a=read()+1;
        b=read()+1;
        G[a][b]=G[b][a]=1;
    }
    int NF=read(),T,u;
    while(NF--){
        T=read();
        for(int i=0;i<T;i++){
            u=read()+1;
            for(int j=i;j<12;j+=T)
                uns[j][u]=true;
        }
    }
    Q.n=Q.m=N;
    for(int i=1;i<=N;i++) Q.s[i][i]=1;
    for(int t=0;t<12;t++){
        A[t].n=A[t].m=N;
        for(int i=1;i<=N;i++)
            for(int j=1;j<=N;j++){
                A[t].s[i][j]=(G[i][j]&&!uns[t][j]);
            }
    }
    for(int i=1;i<12;i++) Q=Q*A[i];
    Q=Q*A[0];
}
void solve(){
    int k=K/12,t=K-k*12;
    Matrix ans;ans.n=ans.m=N;
    for(int i=1;i<=N;i++) ans.s[i][i]=1;
    ans=ans*qpow(Q,k);
    for(int i=1;i<=t;i++) ans=ans*A[i];
    cout<<ans.s[S][E]<<endl;
}
int main(){
    init();
    /*for(int i=1;i<=N;i++){
        for(int j=1;j<=N;j++) cout<<G[i][j]<<' ';
        cout<<endl;
    }
    for(int t=0;t<12;t++){
        cout<<endl<<endl;
        for(int i=1;i<=N;i++){
            for(int j=1;j<=N;j++) cout<<A[t].s[i][j]<<' ';
            cout<<endl;
        }
    }*/
    solve();
    return 0;
}

```

---

## 作者：George1123 (赞：6)

# 题解-[ZJOI2005]沼泽鳄鱼


[$\texttt{Read it in my cnblogs.}$](https://www.cnblogs.com/Wendigo/p/12545665.html)

**前置知识：**

> 邻接矩阵

> 矩阵乘法

> 矩阵快速幂

---

> [``[ZJOI2005]沼泽鳄鱼``](https://www.luogu.com.cn/problem/P2579)

> 给一个有 $N$ 个点，$M$ 条双向边的图 $G$，其中有 $NFish$ 只鳄鱼以 $T$ 个点 $P_0\sim P_t$ 为周期运动。求从 $Start$ 出发到 $End$ 不停留走 $K$ 步每步不碰到鳄鱼的方案数（节点下标从 $0$ 开始编号）。

> 数据范围：$1\le N\le 50$，$1\le K\le 2\times 10^9$，$1\le NFish\le 20$，$2\le T\le 4$。

---

看到这个 $K$ 的范围就知道要带个 $\log$，而在图上可以带 $\log$ 的算法，唯有**二分、倍增（树形图）和邻接矩阵快速幂（小图）**。看到这题 $N$ 很小，又无从二分，便知道可以**邻接矩阵快速幂**。

---

首先要知道什么是**矩阵乘法**。大小为 $a\times b$ 的矩阵 $A$ 和大小为 $b\times c$ 的矩阵方可相乘，乘积矩阵 $C$ 大小为 $a\times c$，满足 $C_{i,j}=\sum\limits_{k=1}^bA_{i,k}\cdot B_{k,j}(1\le i\le a,1\le j\le c)$。

**矩阵乘法**可以解决集合的定向求和变换操作。其中原矩阵乘以变换矩阵变成目标矩阵。

---

**矩阵快速幂**：原矩阵多次定向变换，可以通过多次乘以变换矩阵解决。矩阵乘法满足结合律，所以可以先求出变换矩阵的幂。矩阵也可以快速幂，时间复杂度 $\Theta(n^3\log k)$。

---

**邻接矩阵**：用于表示图边，在无权图中，如果矩阵 $M$ 的元素 $M_{i,j}=1$，表示存在边 $(i,j)$。  

---

**而邻接矩阵快速幂**就是建立在邻接矩阵和矩阵快速幂上的。**原矩阵表示起点状态，变换矩阵为邻接矩阵，每乘一次就表示不停留地走一步后的状态**，乘 $K$ 次就成了最终状态，取终点矩阵值则为答案。

> 状态：到每个节点的方案数。

---

### Example

> 讲解时暂时初始下标为 $1$ 吧，暂时不考虑鳄鱼。

例如 $N=3$，$Start=1$，$End=3$，有双向边 ${(1,3),(3,2)}$，求走 $K=3$ 步后到终点 $End$ 的方案数。

**原始状态：**

$$
A=
\begin{bmatrix}
1 & 0 & 0\\
\end{bmatrix}
$$

**变换矩阵为邻接矩阵：**

$$
B=
\begin{bmatrix}
0 & 0 & 1\\
0 & 0 & 1\\
1 & 1 & 0\\
\end{bmatrix}
$$

**目标状态：**

![jz323.png](https://i.loli.net/2020/03/23/cidnxBCSAIO8Tav.png)

所以到终点 $End=3$ 的方案数为 $2$。

---

**但是鳄鱼怎么办呢？**

可以发现 $2\le T\le 4$，所以所有鳄鱼运动的总周期是 $12$。可以计算 $12$ 种变换邻接矩阵，表示到每个周期时可以走的边。然后顺次相乘，求乘积的 $\lfloor\frac K{12}\rfloor$ 次幂（**可以用矩阵快速幂**）乘以 前 $\left(K\bmod 12\right)$ 种变换矩阵的乘积，就是**总变换矩阵**。用表示起点的原矩阵乘以总变换矩阵，即可得答案。

时间复杂度 $\Theta(NFish+N^3\log K)$（注意，$NFish$ 为一个完整变量名）。

---

真的难讲，还是放代码吧。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

//&Start
#define inf 0x3f3f3f3f
#define re register
#define il inline
#define hash unorded_map
typedef long long lng;
typedef unsigned long long ulng;
typedef vector<int> veci;
#define fo(i,st,xb,y) for(re int i=st;i xb;i y)

//&Data
#define N 50
#define mod 10000
int n,m,s,t,k,fish,p[25][12];

//&Matrix
struct Matrix{ //矩阵
	int arr[N+5][N+5];
	Matrix(re int op=0){
		memset(arr,0,sizeof arr);
		if(op==1) fo(i,1,<=N,++) arr[i][i]=1; //构造单位矩阵 E 满足 E*A=A*E=A
	}
	il int* operator[](re int x){return arr[x];} 
	il friend Matrix operator*(re Matrix x,re Matrix y){
		re Matrix res;
		fo(k,1,<=N,++)fo(i,1,<=N,++)fo(j,1,<=N,++)
			(res[i][j]+=x[i][k]*y[k][j]%mod)%=mod;
		return res;
	}
	il void print(re char*s){
		puts(s);
		fo(i,1,<=n,++)fo(j,1,<=n,++)
			printf("%d%c",arr[i][j],"\n "[j<n]);	
	}
}st,e,g[12],all,ans;
il Matrix Pow(re Matrix a,re int x){ //矩阵快速幂
	re Matrix res(1);
	for(;x;a=a*a,x>>=1)if(x&1) res=res*a;
	return res;
}

//&Main
int main(){
	scanf("%d%d%d%d%d",&n,&m,&s,&t,&k);
	s++,t++,st[1][s]=1; //原矩阵
	fo(i,1,<=m,++){
		re int u,v;scanf("%d%d",&u,&v);
		e[u+1][v+1]=e[v+1][u+1]=1; //邻接矩阵
	}
	scanf("%d",&fish);
	fo(i,1,<=fish,++){
		re int tmp; scanf("%d",&tmp);
		fo(j,0,<tmp,++) scanf("%d",p[i]+j),p[i][j]++;
		fo(j,tmp,<12,++) p[i][j]=p[i][j%tmp];
	}
	re int fb[N+5];
	fo(i,0,<12,++){
		fill(fb+1,fb+n+1,0);
		fo(j,1,<=fish,++) fb[p[j][i]]=1;
		fo(j,1,<=n,++)fo(k,1,<=n,++)
			if(!fb[k]) g[i][j][k]=e[j][k]; //12种变换矩阵
	}
	all=Matrix(1);
	fo(i,1,<12,++) all=all*g[i];
	all=all*g[0]; //12个矩阵顺次相乘（1,2,...,11,0）
	ans=st*Pow(all,k/12); //原矩阵乘以变换矩阵
	fo(i,1,<=k%12,++) ans=ans*g[i]; //乘以剩余 K%12 个矩阵
	printf("%d\n",ans[1][t]); //答案
	return 0;
}
```

---

**祝大家学习愉快！**


---

## 作者：xyz32768 (赞：6)

先把无向边拆成两条有向边。

如果不考虑食人鱼，那么此题就是一个简单的矩乘问题。建立矩阵$P$，如果存在边$i->j$则$P[i][j]=1$，否则$P[i][j]=0$。

最后$P^K[Start][End]$就是最终结果。

考虑食人鱼。注意到题目里食人鱼的运动周期长度只有$2$，$3$，$4$，可以得出，第$t$个时间单位时是否可以在这个点上（没有食人鱼经过），取决于$t\mod 12$的值。所以这里，先预处理出一个数组$vis[j][i]$，如果当前的时间取模$12$的值为$j$，$vis[j][i]$为假表示此时可以在点$i$上，为真表示此时不能在点$i$上。

构造出$12$个矩阵$P_0,P_1,P_2,...,P_{11}$，分别储存当前单位时间模$12$的值为 $0,1,2,...,11$时的邻接矩阵。

对于一条边$i->j$，如果$vis[k][j]$为假，那么$P_k[i][j]=1$，否则如果不存在边$i->j$或者$vis[k][j]$为真，那么$P_k[i][j]=0$。

此时令矩阵$Q=P_1*P_2*P_3*...*P_{11}*P_0$。

并求矩阵$F=Q^{\lfloor\frac{K}{12}\rfloor}$，

就得到了在恰好$\lfloor\frac{K}{12}\rfloor*12$的时间内任意两点互相到达的方案数。由于剩下的不会超过$12$个时间单位，所以对于剩余的时间单位，暴力转移即可。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 55, M = 3005, PYZ = 1e4;
struct cyx {
    int m, n, v[N][N];
    cyx() {}
    cyx(int _m, int _n) :
        m(_m), n(_n) {memset(v, 0, sizeof(v));}
    friend inline cyx operator * (cyx a, cyx b) {
        cyx res = cyx(a.m, b.n); int i, j, k;
        for (i = 1; i <= res.m; i++) for (j = 1; j <= res.n; j++)
        for (k = 1; k <= a.n; k++)
            (res.v[i][j] += a.v[i][k] * b.v[k][j]) %= PYZ;
        return res;
    }
    friend inline cyx operator ^ (cyx a, int b) {
        int i, d = b; cyx c = a, res = cyx(a.m, a.n);
        for (i = 1; i <= res.m; i++) res.v[i][i] = 1;
        while (d) {
            if (d & 1) res = res * c;
            c = c * c;
            d >>= 1;
        }
        return res;
    }
} P[15], Q, F;
int n, m, S, T, K, nf, ecnt, nxt[M], adj[N], go[M];
bool vis[15][N];
void add_edge(int u, int v) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v;
}
int main() {
    int i, j, k, x, y; n = read(); m = read(); S = read() + 1;
    T = read() + 1; K = read(); for (i = 1; i <= m; i++) {
        x = read() + 1; y = read() + 1;
        add_edge(x, y); add_edge(y, x);
    }
    nf = read(); for (i = 1; i <= nf; i++) {
        x = read(); for (j = 0; j < x; j++) {
            y = read() + 1;
            for (k = j; k < 12; k += x)
                vis[k][y] = 1;
        }
    }
    Q = cyx(n, n); for (i = 1; i <= n; i++) Q.v[i][i] = 1;
    for (j = 0; j < 12; j++) {
        P[j] = cyx(n, n);
        for (i = 1; i <= n; i++)
            for (int e = adj[i]; e; e = nxt[e])
                if (!vis[j][go[e]]) P[j].v[i][go[e]] = 1;
        if (j) Q = Q * P[j];
    }
    Q = Q * P[0]; F = Q ^ (K / 12);
    for (j = 1; j <= K % 12; j++) F = F * P[j];
    printf("%d\n", F.v[S][T]);
    return 0;
}
```

---

## 作者：wangjyqh (赞：6)

### 矩阵优化dp
** 注意：矩阵乘法没有交换律 **

思路：类比P2151hh去散步

代码特点在**一维**的答案矩阵

1.矩阵优化两点间方案数不必赘述

2.注意2，3，4可以办到以他们的lcm为周期，正是因为如此我们可以矩阵加速（这样我们就可以化动为静，矩阵乘法了）

3.一维初始矩阵（一维邻接矩阵+第二个矩阵取交集）注意当前鳄鱼的位置与我们下一次走并无关，他们正好搓了一位，要小心

4.再次强调：**矩阵乘法没有交换律**：因此，我们在构造转移矩阵时要从2开始到12，再乘1（这里指的是矩阵）


```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,S,E,k,t,mod=10000;
int record[20][60],Map[60][60];
struct M{
  int m[60][60];
  M(){
    memset(m,0,sizeof(m));
  }
  M operator *(const M &a)const {//重载定义矩阵乘法
    M ret;
    for(int i=1;i<=n;++i)
      for(int j=1;j<=n;++j)
        for(int k=1;k<=n;++k)
          ret.m[i][j]=(ret.m[i][j]+m[i][k]%mod*a.m[k][j]%mod)%mod;
    return ret;
  }
}c[20],e,A;
inline void build(){//构造转移矩阵
  for(int i=1;i<=n;++i)e.m[i][i]=1;
   for(int i=1;i<=12;++i){
      for(int j=1;j<=n;++j){
          for(int k=1;k<=n;++k){           
            if(Map[j][k]&&(!record[i][j]))c[i].m[k][j]=1;
          }
      }
   }
   for(int i=2;i<=12;i++)e=e*c[i];//矩乘没有交换律
   e=e*c[1];//因为我们的第二个矩阵跟第一步有关，所以先乘2矩阵
}
inline void power(M &a,M &b,int k){
  while(k){
    if(k&1)a=a*b;
    b=b*b;
    k>>=1;
  }
}//矩阵快速幂
inline void solve(){//极其繁琐需要头脑冷静
  if(k==1){printf("%d",Map[S][E]);return ;}
  for(int i=1;i<=n;++i)if(Map[S][i]&&c[2].m[S][i])A.m[S][i]=1;//先跟第二矩阵取交集，表示走第一步--此处表示构造初始矩阵
  if(k<=12)for(int i=3;i<=k+1;++i)A=A*c[i%12];//此处分类讨论
  else {//因为初始矩阵的存在，我们已经走了一步
    for(int i=3;i<=12;++i)A=A*c[i];//所以在这里我们先暴力走一遍
    A=A*c[1];//注意不能交换律
    power(A,e,(k/12)-1);//先乘了一遍所以-1
    for(int i=2;i<=(k-12)%12+1;++i)A=A*c[i];//最后再o再
  }
  printf("%d",A.m[S][E]);
}

int main(){
   scanf("%d%d%d%d%d",&n,&m,&S,&E,&k);
   S++,E++;//加1比较顺我的思路，下面的加1同
   for(int i=1;i<=m;++i){
    int x,y;
    scanf("%d%d",&x,&y);
    ++x,++y;
    Map[x][y]=1;
    Map[y][x]=1;
   }
   scanf("%d",&t);
   for(int i=1;i<=t;++i){
     int num;
     scanf("%d",&num);
     for(int j=1;j<=num;++j){
      int x;
      scanf("%d",&x);
      int k=j;
      x++;
      while(k<=12){
        record[k][x]=1;
            k+=num;
      }//12一循环
     }
   }
   build();
   solve();
   return 0;
}
```

---

## 作者：i207M (赞：3)

## 题目总结

一个无向图，每一时刻有一些点不能到达，这些点的出现以12为最小公倍数，求s到t的路径数；

## 数据范围

 1 ≤ N ≤ 50

 1 ≤ K ≤ 2,000,000,000

 1 ≤ NFish ≤ 20

## 解题思路

处理出每一时刻的邻接矩阵，12的整数倍有快速幂，剩下的手动乘，注意顺序；

## 易错误区

**不该加的代码一定不要加**

```cpp
day[i][k][t] = 0;
//day[i][t][k] = 0;
```

注释掉的那一行不可以加，因为假如此时你已经到达那个点，而食人鱼在路上，你是可以从这个点到其他点的；

**矩阵乘法没有交换律**

乘法一定按顺序，从1乘到11，再乘0；

## 代码展示

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<list>
#include<queue>
#include<stack>
#include<bitset>
#include<deque>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define ri register int
#define il inline
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
#define mem0(x) memset((x),0,sizeof (x))
#define mem1(x) memset((x),0x3f,sizeof (x))
il char gc() {
    static const int BS = 1 << 22;
    static unsigned char buf[BS], *st, *ed;
    if (st == ed) ed = buf + fread(st = buf, 1, BS, stdin);
    return st == ed ? EOF : *st++;
}
#define gc getchar
template<class T>void in(T &x)
{
    x = 0; bool f = 0; char c = gc();
    while (c < '0' || c > '9') {if (c == '-') f = 1; c = gc();}
    while ('0' <= c && c <= '9') {x = (x << 3) + (x << 1) + (c ^ 48); c = gc();}
    if (f) x = -x;
}
#undef gc
void out(int x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) out(x / 10);
    putchar(x % 10 + '0');
}
#define Maxsz 130
#define md 10000
#define sz n
il void mod(int &x) {
    while (x > md) x -= md;
    while (x < 0) x += md;
}
int n, m, st, en, d, nf;
struct Mat {
    int m[Maxsz][Maxsz];
    il void clear() {mem0(m);}
    Mat () {clear();}
    int* operator[](int x) {
        return this->m[x];
    }
    Mat operator*(const Mat &x)const {
        Mat res;
        for (ri i = 1; i <= sz; i++) {
            for (ri k = 1; k <= sz; k++) {
                for (ri j = 1; j <= sz; j++)
                    mod(res.m[i][j] += m[i][k] * x.m[k][j] % md);
            }
        }
        return res;
    }
    void operator*=(const Mat &x) {
        *this = (*this) * x;
    }
    void operator+=(const Mat &x) {
        for (ri i = 1; i <= sz; ++i) {
            for (ri j = 1; j <= sz; ++j) {
                mod(m[i][j] += x.m[i][j]);
            }
        }
    }
    Mat operator+(const Mat &x)const {
        Mat res = *this;
        res += x;
        return res;
    }
    void print() {
        for (ri i = 1; i <= sz; i++) {
            for (ri j = 1; j <= sz; j++)
                printf("%lld ", m[i][j]);
            puts("");
        }
        puts("*****************");
    }
    void toe() {
        clear();
        for (ri i = 1; i <= sz; i++)
            m[i][i] = 1;
    }
    Mat qpow(int x) {
        Mat res, mul = *this;
        if (x == 0) {
            res.toe();
            return res;
        }
        res = *this; --x;
        for (; x; x >>= 1, mul *= mul) if (x & 1) res *= mul;
        return res;
    }
} pri, day[15], s;
#define N 55
#define M 2010
int v[M], u[M], nx[M];
int cnt, head[N];
il void add(int uu, int vv) {
    u[++cnt] = uu, v[cnt] = vv, nx[cnt] = head[uu];
    head[uu] = cnt;
}
int fish[25][8];
int zh, res;
signed main() {
    in(n), in(m), in(st), in(en), in(d);
    ++st, ++en;
    for (ri i = 1, a, b; i <= m; ++i) {
        in(a), in(b);
        ++a, ++b;
        add(a, b);
        add(b, a);
        pri[a][b] = pri[b][a] = 1;
    }
    in(nf);
    for (ri i = 1; i <= nf; ++i) {
        in(fish[i][5]);
        for (ri j = 0; j < fish[i][5]; ++j) {
            in(fish[i][j]);
            fish[i][j]++;
        }
    }
    day[13].toe();
    for (ri i = 0; i < 12; ++i) {
        day[i] = pri;
        for (ri j = 1, t; j <= nf; ++j) {
            t = fish[j][i % fish[j][5]];
            for (ri k = 1; k <= n; ++k) {
                day[i][k][t] = 0;
                //day[i][t][k] = 0;
            }
        }
        //day[i].print();
        if (i) day[13] *= day[i];
    }
    day[13] *= day[0];
    zh = (int)(d / 12);
    res = d % 12;
    day[13] = day[13].qpow(zh);
    //day[13].print();
    for (ri i = 0; i < res; ++i) day[13] *= day[(i + 1) % 12];
    // day[13].print();
    printf("%lld", day[13][st][en]);
    return 0;
}
```

---

## 作者：abs001 (赞：1)

首先可以想到DP

i为现在的时间

f[i][j] += f[i - 1][k] (k可以到j，且j上没有食人鱼)

而这样显然会超时

然后可以发现n的范围超小，k的范围超大，还要mod10000，于是就可以想到矩阵快速幂。

然后又发现鱼的循环周期只有2到4，最小公倍数只有12，于是就可以干脆求出12种的矩阵然后乘在一起去矩阵快速幂，然后对于k mod 最小公倍数就一个一个乘上去

对于初始的矩阵（没有食人鱼）就把两端石墩的值+1就行了

代码：

```cpp
#include<bits/stdc++.h>
#define mod 10000
using namespace std;

struct node{
    int a[51][51]; //矩阵
}xs[13], txs, tmp, f;

struct data{
    int t;
    int p[4];//鱼
}fi[21];

int n, m, st, en, k, fish, lcg = 1;

node mul(node x, node y)//矩阵乘法
{
    node res;
    memset(res.a, 0, sizeof(res.a));
    for(int i = 0; i < n; i++)
        for(int j = 0; j < n; j++)
            for(int k = 0; k < n; k++)
                res.a[i][j] = (res.a[i][j] + x.a[i][k] % mod * y.a[k][j] % mod) % mod;
    return res;
}

node qmul(node xs, int n)//快速幂
{
    node res = f;
    while(n > 0)
    {
        if(n & 1) res = mul(res, xs);
        xs = mul(xs, xs);
        n >>= 1;
    }
    return res;
}

void init(node &x)
{
    memset(x.a, 0, sizeof(x.a));
    for(int i = 0; i < n; i++) x.a[i][i] = 1;
}

int main()
{
    scanf("%d%d%d%d%d", &n, &m, &st, &en, &k);
    for(int i = 1; i <= m; i++)
    {
        int x, y;
        scanf("%d%d", &x, &y);
        txs.a[x][y]++, txs.a[y][x]++;//初始矩阵（没有食人鱼）
    }
    scanf("%d", &fish);
    init(tmp);//使得tmp乘任何矩阵等于任何矩阵
    for(int i = 1; i <= fish; i++)
    {
        scanf("%d", &fi[i].t);
        if(lcg % fi[i].t) lcg *= fi[i].t;
        for(int j = 0; j < fi[i].t; j++) scanf("%d", &fi[i].p[j]);
    }
    if(lcg == 24) lcg = 12;//求最小公倍数
    for(int i = 0; i < lcg; i++)
    {
        for(int j = 0; j < n; j++)
            for(int k = 0; k < n; k++) xs[i].a[j][k] = txs.a[j][k];
        for(int j = 1; j <= fish; j++)
        {
            int x = fi[j].p[i % fi[j].t];
            for(int k = 0; k < n; k++)
                for(int l = 0; l < n; l++) if(k == x) xs[i].a[k][l] = 0;//求出所有矩阵
        }
        tmp = mul(tmp, xs[i]);//把所有的矩阵乘起来
    }
    f.a[0][st] = 1;
    node res = qmul(tmp, k / 12);
    for(int i = 0; i < k % 12; i++) res = mul(res, xs[i]);
    printf("%d\n", res.a[0][en]);
    return 0;
}
```



---

## 作者：liangzihao (赞：1)

看上去像是个搜索。但是k实在太大，O(k)都会超时，但是石柱并不多（如果太多则矩阵会太大，爆内存），可以使用矩阵乘法。

鱼的周期只为2，3，4，所以最多12步一个周期。我们可以把每一时刻的邻接矩阵相乘，便可知道路径的数目。当a[i,k]>0,b[k,j]>0时，即i—>k和k—>j都有路径时c[I,j]才有路径，且等于实际i—j的路径。

A[i]代表第i个时刻的邻接矩阵,Ans[start,end]为所求。那么Ans=A[1]\*A[2]\*A[3]\*…..\*A[K]

我们知道12步一个周期，

A[1]\*A[2]\*……\*A[12]=A[12p+1]\*A[12p+2]\*……\*A[12p+12] (p为任意正整数)

那么
Ans=(A[1]\*A[2]\*……\*A[12])k div 12 \*(A[1]\*A[2]\*……\*A[k mod 12])

 
我们可以用快速幂求出G k div 12(G=A[1]\*A[2]\*……\*A[12]),时间复杂度就为O(log n)

 
代码：





```cpp
const
  p=10000;
type
  arr=array[1..50,1..50] of longint;
var
  n,m,s,e,t,w1,nf,x,y,i,j,k,u:longint;
  a,c,d:arr;
  f:array[1..12] of arr;
  w:array[1..4] of longint;
procedure cheng(a,b:arr);
var
  i,j,k:longint;
begin
  fillchar(c,sizeof(c),0);
  for i:=1 to n do
    for j:=1 to n do
      for k:=1 to n do
        c[i,j]:=(c[i,j]+a[i,k]*b[k,j]) mod p;
end;
procedure ksm(x:longint);
begin
  if x=0 then exit;
  ksm(x div 2);
  cheng(c,c);
  if x mod 2=1 then cheng(c,d);
end;
begin
  readln(n,m,s,e,t);
  for i:=1 to m do
  begin
    readln(x,y);
    a[x+1,y+1]:=1;
    a[y+1,x+1]:=1;
  end;
  readln(nf);
  for i:=1 to 12 do
    f[i]:=a;
  for i:=1 to nf do
  begin
    read(w1);
    for j:=1 to w1 do
      read(w[j]);
    for j:=1 to 12 do
    begin  
      u:=j mod w1+1;
      for k:=1 to n do
        f[j,k,w[u]+1]:=0;
    end;
  end;
  for i:=1 to n do
    c[i,i]:=1;
  for i:=1 to 12 do
    cheng(c,f[i]);
  d:=c;
  fillchar(c,sizeof(c),0);
  for i:=1 to n do
    c[i,i]:=1;
  ksm(t div 12);
  for i:=1 to t mod 12 do
    cheng(c,f[i]);
  writeln(c[s+1,e+1]);
end.

```

---

## 作者：kouylan (赞：0)

## 题解 P2579 【[ZJOI2005]沼泽鳄鱼】

[题面传送门](https://www.luogu.com.cn/problem/P2579)

【分析】

如果不考虑食人鱼的条件，那么这道题就是一个特别模板的邻接矩阵快速幂。

不会矩阵快速幂的[戳这里](https://www.bilibili.com/video/BV1D5411Y7Vb)（我的做的讲解视频）。

但是如果加上食人鱼，又该怎么做呢？我们发现，食人鱼的周期总是 $2,3,4$，也就是说所有食人鱼的游动周期是 $12$。那么，我们先把这 $12$ 个状态（邻接矩阵）算出来，然后再把他们当成一个整体去进行矩阵快速幂不就行了吗？余下的只需要单独处理就行了。

所以总体上，这道题还是比较套路的。

下面是 AC 代码

```cpp
/*
luogu P2579
*/
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int M = 1e4;

int n,m,fis,s,t,k;
int x[5005],y[5005],mov[5];
bool saf[13][55];
struct matrix{
	int mat[55][55];
	void init()
	{
		memset(mat,0,sizeof(mat));
	}
	matrix operator * (const matrix b) const
	{
		matrix res;
		res.init();
		for(int k=1;k<=n;k++)
			for(int i=1;i<=n;i++)
				for(int j=1;j<=n;j++)
					res.mat[i][j] = (res.mat[i][j]+mat[i][k]*b.mat[k][j])%M;
		return res;
	}
}g[20],st;

matrix ksm(matrix x,int w)
{
	matrix s=st;
	while(w)
	{
		if(w&1)
			s = s*x;
		x = x*x;
		w >>= 1;
	}
	return s;
}

signed main()
{
	cin>>n>>m>>s>>t>>k;
	s++, t++;
	for(int i=1;i<=m&&cin>>x[i]>>y[i];i++)
		x[i]++, y[i]++;
	cin>>fis;
	for(int i=1,tim;i<=fis&&cin>>tim;i++)
	{
		for(int j=1;j<=tim&&cin>>mov[j];j++)
			mov[j]++;
		mov[0] = mov[tim];
		for(int j=1;j<=12;j++)
			saf[j][mov[j%tim]] = true;
	}
	for(int i=1;i<12;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(!saf[i+1][y[j]])
				g[i].mat[x[j]][y[j]] = 1;
			if(!saf[i+1][x[j]])
				g[i].mat[y[j]][x[j]] = 1;
		}
	}
	for(int j=1;j<=m;j++)
	{
		if(!saf[1][y[j]])
			g[12].mat[x[j]][y[j]] = 1;
		if(!saf[1][x[j]])
			g[12].mat[y[j]][x[j]] = 1;
	}
	st = g[1];
	int tim=k/12,r=k%12;
	if(tim>0)
	{
		for(int i=2;i<=12;i++)
			st = st*g[i];
		st = ksm(st,tim-1);
	for(int i=1;i<=r;i++)
		st = st*g[i];
	}
	else
	{
		for(int i=2;i<=r;i++)
			st = st*g[i];
	}
	cout<<st.mat[s][t]%M<<endl;
	
	return 0;
}
```

祝大家 AC 愉快！

---


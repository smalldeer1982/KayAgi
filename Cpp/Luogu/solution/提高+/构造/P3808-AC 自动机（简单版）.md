# AC 自动机（简单版）

## 题目描述

给定 $n$ 个模式串 $s_i$ 和一个文本串 $t$，求有多少个不同的模式串在文本串里出现过。  
两个模式串不同当且仅当他们**编号**不同。

## 说明/提示

### 样例 1 解释

$s_2$ 与 $s_3$ 编号（下标）不同，因此各自对答案产生了一次贡献。

### 样例 2 解释

$s_1$，$s_2$，$s_4$ 都在串 `abcd` 里出现过。

### 数据规模与约定

- 对于 $50\%$ 的数据，保证 $n = 1$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^6$，$1 \leq |t| \leq 10^6$，$1 \leq \sum\limits_{i = 1}^n |s_i| \leq 10^6$。$s_i, t$ 中仅包含小写字母。

## 样例 #1

### 输入

```
3
a
aa
aa
aaa```

### 输出

```
3```

## 样例 #2

### 输入

```
4
a
ab
ac
abc
abcd```

### 输出

```
3```

## 样例 #3

### 输入

```
2
a
aa
aa```

### 输出

```
2```

# 题解

## 作者：yybyyb (赞：371)

膜拜楼下神犇

%%% 这的确是一道裸的AC自动机（写了是模板呀）

所以，就是打一遍AC自动机即可

~~具体的实现可以百度~~

~~或者也可以参考我代码的注释~~

过了这么久，当然要改一下

首先肯定要搞一搞自己的博客对不对。。。

[AC自动机不懂戳这里](http://www.cnblogs.com/cjyyb/p/7196308.html)

AC自动机的难点在于Fail失配指针的构建

自己多画图就可以很容易的弄懂这个问题

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<queue>
#include<algorithm>
using namespace std;
struct Tree//字典树 
{
     int fail;//失配指针
     int vis[26];//子节点的位置
     int end;//标记有几个单词以这个节点结尾 
}AC[1000000];//Trie树
int cnt=0;//Trie的指针 
inline void Build(string s)
{
        int l=s.length();
        int now=0;//字典树的当前指针 
        for(int i=0;i<l;++i)//构造Trie树
        {
                if(AC[now].vis[s[i]-'a']==0)//Trie树没有这个子节点
                   AC[now].vis[s[i]-'a']=++cnt;//构造出来
                now=AC[now].vis[s[i]-'a'];//向下构造 
        }
        AC[now].end+=1;//标记单词结尾 
}
void Get_fail()//构造fail指针
{
        queue<int> Q;//队列 
        for(int i=0;i<26;++i)//第二层的fail指针提前处理一下
        {
               if(AC[0].vis[i]!=0)
               {
                   AC[AC[0].vis[i]].fail=0;//指向根节点
                   Q.push(AC[0].vis[i]);//压入队列 
               }
        }
        while(!Q.empty())//BFS求fail指针 
        {
              int u=Q.front();
              Q.pop();
              for(int i=0;i<26;++i)//枚举所有子节点
              {
                        if(AC[u].vis[i]!=0)//存在这个子节点
                      {
                                AC[AC[u].vis[i]].fail=AC[AC[u].fail].vis[i];
                                    //子节点的fail指针指向当前节点的
                                  //fail指针所指向的节点的相同子节点 
                                Q.push(AC[u].vis[i]);//压入队列 
                      }
                      else//不存在这个子节点 
                      AC[u].vis[i]=AC[AC[u].fail].vis[i];
                      //当前节点的这个子节点指向当
                      //前节点fail指针的这个子节点 
              }
        }
}
int AC_Query(string s)//AC自动机匹配
{
        int l=s.length();
        int now=0,ans=0;
        for(int i=0;i<l;++i)
        {
                now=AC[now].vis[s[i]-'a'];//向下一层
                for(int t=now;t&&AC[t].end!=-1;t=AC[t].fail)//循环求解
                {
                         ans+=AC[t].end;
                         AC[t].end=-1;
                } 
        }
        return ans;
}
int main()
{
     int n;
     string s;
     cin>>n;
     for(int i=1;i<=n;++i)
     {
             cin>>s;
             Build(s);
     }
     AC[0].fail=0;//结束标志 
     Get_fail();//求出失配指针
     cin>>s;//文本串 
     cout<<AC_Query(s)<<endl;
     return 0;
}
```

---

## 作者：zcysky (赞：337)

这是一道AC自动机的裸题。

AC自动机（优化后可称Trie图）是一种（可以理解为被过分简化的）有限状态自动机。

所以可以简单的理解为将KMP放在Trie树上。

注意如果每次跳fail边复杂度过高，一次存储完可以进行优化。

这样的AC自动机就成为了Trie图。

不过这题的std是从香港新闻产业来的，加了一个跳转移边的剪枝优化。

被卡常的同学可以看下std……

```cpp
#include<bits/stdc++.h>
#define N 500010
using namespace std;
queue<int>q;
struct Aho_Corasick_Automaton{
    int c[N][26],val[N],fail[N],cnt;
    void ins(char *s){
        int len=strlen(s);int now=0;
        for(int i=0;i<len;i++){
            int v=s[i]-'a';
            if(!c[now][v])c[now][v]=++cnt;
            now=c[now][v];
        }
        val[now]++;
    }
    void build(){
        for(int i=0;i<26;i++)if(c[0][i])fail[c[0][i]]=0,q.push(c[0][i]);
        while(!q.empty()){
            int u=q.front();q.pop();
            for(int i=0;i<26;i++)
            if(c[u][i])fail[c[u][i]]=c[fail[u]][i],q.push(c[u][i]);
            else c[u][i]=c[fail[u]][i];
        }
    }
    int query(char *s){
        int len=strlen(s);int now=0,ans=0;
        for(int i=0;i<len;i++){
            now=c[now][s[i]-'a'];
            for(int t=now;t&&~val[t];t=fail[t])ans+=val[t],val[t]=-1;
        }
        return ans;
    }
}AC;
int n;char p[1000005];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%s",p),AC.ins(p);
    AC.build();
    scanf("%s",p);int ans=AC.query(p);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：hicc0305 (赞：203)

蒟蒻终于把~~WA~~ AC自动机打出来了。。。

## AC自动机讲解

AC自动机简单来说就是Tire Tree + ~~看毛片~~KMP，也就是~~在~~树上~~看毛片~~KMP。

AC自动机用来解决多模式串匹配，也就是给好几个子串，一个很长很长很长很长很长的母串，让你处理一些问题，比如什么子串出现的次数之类的。

怎么做咧？

你先把所有的子串丢到Trie上，比如四个字符串:abcd，abd，bcd，cd，建立如下图Trie树：

![](https://cdn.luogu.com.cn/upload/pic/26389.png)

然后我们就要树上看毛片了！

和KMP中的next数组很像，我们定义fail数组，fail[i]为与以i节点为结尾的串的后缀有最大公共长度的前缀的结尾编号。这句话是不是有点绕orz。

我们来分析一下什么意思：对于以d结尾的子串abcd，不存在任何一个其他子串的前缀与abcd匹配，但bcd与abcd的后缀bcd匹配，这是匹配到的最长情况，于是这个d上的fail指针就指向bcd上的d。然后，如果没有找到任何一个前缀与当前串的任何一个后缀一样的话，那么fail只能指到根了。和KMP的原理一样，fail跳到的地方必然这个子串的前面不用再比较了，因为根据fail的定义，它的已经前缀已经被比较过并且匹配了。只用再往后比就行了。放一下图：

![](https://cdn.luogu.com.cn/upload/pic/26392.png)

记num[i]为以i节点为结尾的子串有几个,我们对于每个子串，都在这个子串的结尾，把num++,以方便以后跳来跳去的时候统计。匹配到当前节点，就加上当前节点的num，当然，加过了就不要再加了，因为这道题并不是统计所有子串出现的总数，而是有多少子串出现了。

那么。。对于匹配的时候，当前节点配不下去了怎么办？比如我们尝试匹配abcde，abcd都顺利匹配了，这时候我们发现d并没有e这个节点，那么我们就跳到d的fail指针，也就是bcd上的d，还是没有e，那么继续，到cd上的d，还是没有，只能到根了，还是没有。。。那么。。。就没有了。我们处理的时候，就可以把abcd上的d的不存在的儿子，指向d的fail指针的这个儿子，好像还是有点绕。。

那么继续上图，（这里的e点都为虚线，实际上是没有的）：
![](https://cdn.luogu.com.cn/upload/pic/26396.png)

也就是说，我们在不断尝试，有没有其他前缀后面跟着e的。这样处理之后，就简单方便多了。

------------
## 代码
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int n,cnt=0;
char tmp[1000100];
struct node
{
	int fail,num;
	int ch[30];
}tr[1000100];
int q[1000100];
void build()//建立Trie树
{
	int len=strlen(tmp),u=0;
	for(int i=0;i<len;i++)
	{
		int s=tmp[i]-'a';
		if(tr[u].ch[s]==0) tr[u].ch[s]=++cnt;
		u=tr[u].ch[s];
	}
	tr[u].num++;
}
void get_fail()
{
	int l=0,r=0;
	for(int i=0;i<26;i++)
		if(tr[0].ch[i]!=0)
		{
			tr[tr[0].ch[i]].fail=0;
			q[++r]=tr[0].ch[i];
		}
	while(l<r)
	{
		int u=q[++l];
		for(int i=0;i<26;i++)
		{
			int v=tr[u].ch[i];
			if(v)
			{
				tr[v].fail=tr[tr[u].fail].ch[i];//处理fail指针，是它父亲的fail指针的i儿子
				q[++r]=v;
			}
			else tr[u].ch[i]=tr[tr[u].fail].ch[i];//处理所说的“虚指针”，WA了好几次因为把这里的tr[u].ch[i]也替换成v了。。
		}
	}
}
int AC()
{
	int len=strlen(tmp);
	int u=0,ans=0;
	for(int i=0;i<len;i++)
	{
		int s=tmp[i]-'a';
		u=tr[u].ch[s];
		int v=u;
		while(v && tr[v].num!=-1)
		{
			ans+=tr[v].num;
			tr[v].num=-1;//加过了之后就不用再加了
			v=tr[v].fail;
		}
	}
	return ans;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",tmp);
		build();
	}
	tr[0].fail=0;
	get_fail();
	scanf("%s",tmp);
	printf("%d",AC());
	return 0;
}
```

你会发现代码和yyb大佬的很像，因为我是看了yyb的题解才打出来的。。yyb的很清楚，所以我放上来只是凑个长度的没错

---

## 作者：hyfhaha (赞：171)

# AC自动机详细讲解

AC自动机真是个好东西！之前学KMP被Next指针搞晕了，所以咕了许久都不敢开AC自动机，近期学完之后，发现AC自动机并不是很难，特别是对于KMP，个人感觉AC自动机比KMP要好理解一些，可能是因为我对树上的东西比较敏感（实际是因为我到现在都不会KMP）。

很多人都说AC自动机是在Trie树上作KMP，我不否认这一种观点，因为这确实是这样，不过对于刚开始学AC自动机的同学们就一些误导性的理解（至少对我是这样的）。KMP是建立在一个字符串上的，现在把KMP搬到了树上，不是很麻烦吗？实际上AC自动机只是有KMP的一种思想，实际上跟一个字符串的KMP有着很大的不同。

所以看这篇blog，请放下KMP，理解好Trie，再来学习。

## 前置技能

1.[Trie](https://www.luogu.org/blog/juruohyfhaha/trie-xue-xi-zong-jie)(很重要哦)

2.KMP的思想（懂思想就可以了，不需要很熟练）

# 问题描述

给定n个模式串和1个文本串，求有多少个模式串在文本串里**出现过**。

注意：是出现过，就是出现多次只算一次。

默认这里每一个人都已经会了Trie。

我们将n个模式串建成一颗Trie树，建的方式和建Trie完全一样。

![AC自动机](https://i.loli.net/2019/05/02/5ccaaa22cbf29.png)

假如我们现在有文本串ABCDBC。

我们用文本串在Trie上匹配，刚开始会经过2、3、4号点，发现到4，成功地匹配了一个模式串，然后就不能再继续匹配了，这时我们还要重新继续从根开始匹配吗？

不，这样的效率太慢了。这时我们就要借用KMP的思想，从Trie上的某个点继续开始匹配。

明显在这颗Trie上，我们可以继续从7号点开始匹配，然后匹配到8。

那么我们怎么确定从那个点开始匹配呢？我们称i匹配失败后继续从j开始匹配，j是i的Fail（失配指针）。

## 构建Fail指针

### Fail的含义

Fail指针的实质含义是什么呢？

如果一个点i的Fail指针指向j。那么root到j的字符串是root到i的字符串的一个后缀。

举个例子：（例子来自上面的图

```cpp
i:4     j:7
root到i的字符串是“ABC”
root到j的字符串是“BC”
“BC”是“ABC”的一个后缀
所以i的Fail指针指向j
```

同时我们发现，“C”也是“ABC”的一个后缀。

所以Fail指针指的j的深度要尽量大。

重申一下Fail指针的含义：((最长的(当前字符串的后缀))在Trie上可以查找到)的末尾编号。

感觉读起来挺绕口的蛤。感性理解一下就好了，没什么卵用的。知道Fail有什么用就行了。

### 求Fail

首先我们可以确定，每一个点i的Fail指针指向的点的深度一定是比i小的。（Fail指的是后缀啊）

第一层的Fail一定指的是root。（比深度1还浅的只有root了）

点i的父亲fa的Fail指针指的是fafail，那么如果fafail有和i值相同的儿子j，那么i的Fail就指向j。这里可能比较难理解一点，不过等会转换成代码就很好理解了。

由于我们在处理i的情况必须要先处理好fa的情况，所以求Fail我们使用BFS来实现。

实现的一些细节：

1、刚开始我们不是要初始化第一层的fail指针为root，其实我们可以建一个虚节点0号节点，将0的所有儿子指向root（编号为1)，然后root的fail指向0就OK了。效果是一样的。

2、如果不存在一个节点i，那么我们可以将那个节点设为fafail的值和i相同的儿子。保证存在性，就算是0也可以成功返回到根，因为0的所有儿子都是根。

3、无论fafail存不存在和i值相同的儿子j，我们都可以将i的fail指向j。因为在处理i的时候j已经处理好了，如果出现这种情况，j的值是第2种情况，也是有实际值的，所以没有问题。

4、实现时不记父亲，我们直接让父亲更新儿子

```cpp
void getFail(){
	for(int i=0;i<26;i++)trie[0].son[i]=1;			//初始化0的所有儿子都是1
	q.push(1);trie[1].fail=0;				//将根压入队列
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i<26;i++){				//遍历所有儿子
			int v=trie[u].son[i];			//处理u的i儿子的fail，这样就可以不用记父亲了
			int Fail=trie[u].fail;			//就是fafail，trie[Fail].son[i]就是和v值相同的点
			if(!v){trie[u].son[i]=trie[Fail].son[i];continue;}	//不存在该节点，第二种情况
			trie[v].fail=trie[Fail].son[i];	//第三种情况，直接指就可以了
			q.push(v);						//存在实节点才压入队列
		}
	}
}
```

# 查询

求出了Fail指针，查询就变得十分简单了。

为了避免重复计算，我们每经过一个点就打个标记为-1，下一次经过就不重复计算了。

同时，如果一个字符串匹配成功，那么他的Fail也肯定可以匹配成功（后缀嘛），于是我们就把Fail再统计答案，同样，Fail的Fail也可以匹配成功，以此类推……经过的点累加flag，标记为-1。

最后主要还是和Trie的查询是一样的。

```cpp
int query(char* s){
	int u=1,ans=0,len=strlen(s);
	for(int i=0;i<len;i++){
		int v=s[i]-'a';
		int k=trie[u].son[v];		//跳Fail
		while(k>1&&trie[k].flag!=-1){	//经过就不统计了
			ans+=trie[k].flag,trie[k].flag=-1;	//累加上这个位置的模式串个数，标记 已 经过
			k=trie[k].fail;			//继续跳Fail
		}
		u=trie[u].son[v];			//到儿子那,存在性看上面的第二种情况
	}
	return ans;
}
```

# 代码

```cpp
#include<bits/stdc++.h>
#define maxn 1000001
using namespace std;
struct kkk{
	int son[26],flag,fail;
}trie[maxn];
int n,cnt;
char s[1000001];
queue<int >q;
void insert(char* s){
	int u=1,len=strlen(s);
	for(int i=0;i<len;i++){
		int v=s[i]-'a';
		if(!trie[u].son[v])trie[u].son[v]=++cnt;
		u=trie[u].son[v];
	}
	trie[u].flag++;
}
void getFail(){
	for(int i=0;i<26;i++)trie[0].son[i]=1;			//初始化0的所有儿子都是1
	q.push(1);trie[1].fail=0;				//将根压入队列
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i<26;i++){				//遍历所有儿子
			int v=trie[u].son[i];			//处理u的i儿子的fail，这样就可以不用记父亲了
			int Fail=trie[u].fail;			//就是fafail，trie[Fail].son[i]就是和v值相同的点
			if(!v){trie[u].son[i]=trie[Fail].son[i];continue;}	//不存在该节点，第二种情况
			trie[v].fail=trie[Fail].son[i];	//第三种情况，直接指就可以了
			q.push(v);						//存在实节点才压入队列
		}
	}
}
int query(char* s){
	int u=1,ans=0,len=strlen(s);
	for(int i=0;i<len;i++){
		int v=s[i]-'a';
		int k=trie[u].son[v];		//跳Fail
		while(k>1&&trie[k].flag!=-1){	//经过就不统计了
			ans+=trie[k].flag,trie[k].flag=-1;	//累加上这个位置的模式串个数，标记已经过
			k=trie[k].fail;			//继续跳Fail
		}
		u=trie[u].son[v];			//到下一个儿子
	}
	return ans;
}
int main(){
	cnt=1;scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%s",s);
		insert(s);
	}
	getFail();
	scanf("%s",s);
	printf("%d\n",query(s));
	return 0;
}
```
希望学习更多AC自动机？看我的blog [这里](https://www.luogu.org/blog/juruohyfhaha/ac-zi-dong-ji)

---

## 作者：yangrunze (赞：63)

~~我们仍未知道为什么一个PJ刚刚转TG的蒟蒻要学这个东西~~

~~也许，是因为这个算法的名字太美妙了吧~~

（如有错误，欢迎来踩）

AC自动机是啥？

是一个能够让你自动AC的算法

哦不对，是一个关于**字符串匹配的算法**

提到**字符串匹配**，大家应该都会想到**KMP**（既然来学AC自动机了，应该没有不知道的吧）

如果你听说过**KMP**，你应该对一个模式串匹配一个文本串的问题了如指掌

不过，对于多个模式串，好多好多个模式串呢？

你也许会想到对每个模式串都KMP一遍，但直觉告诉你，这样是不可能AC的

于是，**AC自动机**就派上用场了

当然，要学习**AC自动机**，你还需要掌握一种数据结构——~~踹树~~，啊呸，**Trie树**

而前面一直提的KMP，你只需要领会它的“**利用匹配过程中得到的已知线索，来加快匹配速度**”的思想就好啦，不需要掌握它的代码实现（当然，如果掌握了的话更好，会对接下来的学习更有帮助哦）



整个AC自动机分三步：**建树与插入**、**构建fail边**和**匹配查询**

### 1. 建树与插入

这个就是Trie树的基本操作啦，如果你已经把学过的Trie树的知识还给老师了，那正好借此机会来复习一下！

```cpp
struct luogu{//Trie树结构体
	int son[30];//Trie树的子节点
	int cnt,fail;//cnt就是这个单词出现的次数（单词标记），至于这个fail一会再说
}trie[500010];
int tot=0;//节点编号
void insert(string s){//把一个字符串插入到Trie树里
	int u=0;//从根节点开始（我们把根节点设为0号节点）
	for(int i=0;s[i];i++){
		int v=s[i]-'a';//当前的字母
		if(!trie[u].son[v])//如果没找到这个节点，
		trie[u].son[v]=++tot;//那就新开一个~
		u=trie[u].son[v];//顺着往下找
	}
	trie[u].cnt++;//这个单词又出一遍，计数器++
}
```
那么问题来了，我们这里为啥没有用单词末尾的标记end，而加了一个统计单词个数的cnt呢？这么问的绝对没认真读题，题目里有这一句：
> **管理员提示：本题数据内有重复的单词，且重复单词应该计算多次，请各位注意**

这下就一目了然了吧~

### 2. 构建fail边

敲黑板，划重点啦！这一部分**特别特别重要**，是整个AC自动机的重点和难点所在，小伙伴们一定要竖起耳朵认真听！！

- ####  fail边的定义

首先，咱们插入这些模式串：

```
abc
bcd
bd
c

```
![](https://cdn.luogu.com.cn/upload/image_hosting/i8df5imi.png)
然后还有一个文本串：`abcdbc`

那么下面我们开始匹配啦！

从头开始，a，b，c，……哎呀！没了！

也就是说，到c这一块，**失配**了！

根据**KMP的思想**，我们可以接着找一个有"bc"的地方接过去匹配

那哪里有"bc"呢？哇！"bcd"这一块刚好有一个！

所以我们在把"abc"匹配完成之后，直接跳到"bcd"里的'c'这个节点，接着匹配就行啦

![](https://cdn.luogu.com.cn/upload/image_hosting/8b3cyzhw.png)

看到那条漂亮的紫色边没有？这就是传说中的**fail边**，之所以叫“fail边”，是因为它决定着这个字符串失配后的去向

那问题来了，右面"c"这个字符串里也有个c，为啥不和它连成fail边呢？

原因很简单，公共部分"bc"比公共部分"c"显然更有，咱们在KMP里求的不也是**最长公共前后缀**嘛，也许你已经发现了，这个**fail边的作用，和KMP中的next数组是一样的**！！！

也就是说：fail边指向的就是当前节点所在的字符串的**最长后缀**的最后一个字符

那你来找一下"bcd"中的'd'的fail边指向谁呢？

答案当然是"bd"中的'd'

那么"abc"中的"a"呢？

好像没有哎……没有，那就是指向根节点

![](https://cdn.luogu.com.cn/upload/image_hosting/411c0uqn.png)

这个图标出了所有节点的fail边，可能画的有点乱，不过只要弄清了fail边的定义，那就很好办啦！

- ####  fail边的代码实现

掌握了fail边的定义，接下来我们就要开始研究代码咋写了

首先，不难发现，第一层的fail边都是根节点

然后呢？找fail边应该这么找：

**顺着你爸的fail边找上去，如果它指向的节点的孩子的字符和你的字符相等，那它的这个孩子就你要连的fail边**

貌似有点复杂……咱还是拿刚才"abc"里的那个'c'举例子：

>- "abc"中的'c'的父节点是"abc"中的'b'

>- "abc"中的'b'的fail边是"bcd"中的'b'

>- "bcd"中的'b'正好有一个儿子'c'，那"abc"中的'c'就要把fail边连到那儿

那么有好奇的小朋友就要问了：如果你爸没你这个孩子，那该怎么办呢？

我们要大力发扬咱们的瞎搞精神：没有孩子，咱就给它造一个，**把当前的孩子直接变成你爸的fail指针的孩子，直接跳到那里去匹配**

也许你已经发现了，我们找fail边，是一层一层往下找的，所以找fail边的过程，实际上就是一个**bfs**的过程，需要借助**队列**来实现

```cpp
void getfail(){//STL大法好！！！
	queue<int>q;
	for(int v=0;v<26;v++){//初始化第一层的fail边
		int c=trie[0].son[v];
		if(c){//如果有这个孩子
			trie[c].fail=0;//那就把它的fail边指向根节点0
			q.push(c);//并把它压入队列	
		}
	}
	while(!q.empty()){//开始bfs！
		int u=q.front();//取队首（这个队首是爸爸，我们要用它更新孩子）
		q.pop();//pop出去
		int f=trie[u].fail;//找到你爸的fail边
		for(int v=0;v<26;v++){//一个一个孩子去找
			int c=trie[u].son[v];
			if(c){//如果有这个孩子
				trie[c].fail=trie[f].son[v];//根据刚才说的，连接fail边
				q.push(c);//压入队列
			}	
			else trie[u].son[v]=trie[f].son[v];//否则就“造”一个孩子
		}
	}
}
```
### 3. 匹配查询

fail边都已经搞定了，匹配就是小case啦！

匹配的代码，其实和**trie树的查找**差不多，一个一个找下去，找到末尾


但这里有点不同，走到一个字符之后，咱们**先去走它的fail边，走完之后再继续往下找**（要不咱大费周章地找fail边意义何在？）

但要注意的是，题目让我们求**有多少个模式串在文本串里出现过**，所以出现过加完了cnt之后，咱们把cnt变成-1，下次遇到-1，就可以知道这个串已经统计过一遍了，就可以结束跳fail的过程，去找下一个节点了

```cpp
int find(string s){//对文本串s进行匹配
	int u=0;//当前节点
	int sum=0;//统计答案
	for(int i=0;s[i];i++){
		int v=s[i]-'a';
		int c=trie[u].son[v];//依旧是Trie树的查找过程
		while(c&&trie[c].cnt!=-1){//如果这个节点不是根节点，而且还不是-1
			sum+=trie[c].cnt;//加到答案里
			trie[c].cnt=-1;//加过了，变成-1
			c=trie[c].fail;//跳fail边
		}
		u=trie[u].son[v];//去往下一个节点
	}
	return sum;//这个就不用解释了吧
}
```

### 完整代码：

```cpp
//通过套取数据而直接“打表”过题者，是作弊行为，发现即棕名。
#include<iostream>
#include<cstring>
#include<queue>
using namespace std; 
struct luogu{//Trie树
	int son[30];
	int cnt,fail;
}trie[500010];
int tot=0;
void insert(string s){//插入
	int u=0;
	for(int i=0;s[i];i++){
		int v=s[i]-'a';
		if(!trie[u].son[v])
		trie[u].son[v]=++tot;
		u=trie[u].son[v];
	}
	trie[u].cnt++;
}
void getfail(){//构建fail边
	queue<int>q;
	for(int v=0;v<26;v++){
		int c=trie[0].son[v];
		if(c){
			trie[c].fail=0;
			q.push(c);	
		}
	}
	while(!q.empty()){
		int u=q.front();
		q.pop();
		int f=trie[u].fail;
		for(int v=0;v<26;v++){
			int c=trie[u].son[v];
			if(c){
				trie[c].fail=trie[f].son[v];
				q.push(c);
			}	
			else trie[u].son[v]=trie[f].son[v];
		}
	}
}
int find(string s){//匹配查询
	int u=0;
	int sum=0;
	for(int i=0;s[i];i++){
		int v=s[i]-'a';
		int c=trie[u].son[v];
		while(c&&trie[c].cnt!=-1){
			sum+=trie[c].cnt;
			trie[c].cnt=-1;
			c=trie[c].fail;
		}
		u=trie[u].son[v];
	}
	return sum;
}
int main(){
	int n;
	string s;
	cin>>n;
	while(n--){
		cin>>s;
		insert(s);//将每个模式串插入到Trie树中
	}
	getfail();//构建fail边
	cin>>s;
	cout<<find(s);//对文本串进行匹配
	return 0;//完美结束
}
```

~~最后说一下，AC自动机好虽好，但是不能滥用，否则会[这样](https://www.luogu.com.cn/discuss/show/57951)~~（伦敦大雾，AC自动机和自动AC机不是一个东西啦）

$\large{\color{magenta}The\;end}$

---

## 作者：Tel兼_dope (赞：41)

- ##  **AC自动机**：
1. ### 即字典树（ trie ）  +  KMP( 思想 ) 
1. #####              AC自动机即在一个长字符串中查询多个短字符串； 
3. #####              KMP（暴力）则为 O（k*(m+n)）； 
1. #####              大数据则无法AC，则加入字典树，由字典树存入其中需查询的n个短字符串中是否有包含关系，交集关系，由字典树链接。（缩小时间复杂度）  
- # **code**
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm> 
#include<queue>
#define maxn 5000000+10
using namespace std;
char str[maxn*2];
struct node{
	int fail;//失配指针；
	int cnt;//单词出现的次数；
	int next[62];// 此节点的下一个（儿子）节点； 
}trie[maxn];//节点结构体； 
int k=0,ans=0;
queue<int> q;//队列：建失配指针使用； 
void build_trie(int id,char *s)//id表示第几个结点，即所有字符串从第0个节点开始向下建；*s即表示这个字符串； 
{
	int len=strlen(s);//该字符串的长度；(相当于字符串最后一个字符的深度)
	int j=0;
	for(int i=0;i<len;i++){
	    j=s[i]-'a';
	    if(trie[id].next[j]==0)/*若此字母未出现在当前位置的下一深度*/
	    {
	        trie[id].next[j]=++k;//当前节点对于j字母节点的位置；即j字母的节点序号； 
	    }
	    id=trie[id].next[j];//id传为下一字母的地址； 
	}
	trie[id].cnt++;//对此单词的数量++； 
}
void build_fail(int id)
{
	while(!q.empty()) q.pop();//为了放心，（be afraid of队列未清空）
	for(int i=0;i<26;i++)//遍历超级节点下的26个字母；
	{
	    int j=trie[id].next[i];
	    if(j!=0){
	        q.push(j);
	        trie[j].fail=id;//第一层的节点失配指针皆指向超级节点； 
	    }
	}
	while(!q.empty())
	{
	    int now=q.front();q.pop();//取出当前位置；（队首元素） 
	    for(int i=0;i<26;i++)
	    {
	        int j=trie[now].next[i];
	        if(j==0)//当前位置下没有这个节点；就调到它失配指针所指向的节点下的此个字母节点； 
	        {
	            trie[now].next[i]=trie[trie[now].fail].next[i];//若为0，不影响，指向超级节点; 
	            continue;//该点遍历完成，直接进入下一节点的遍历； 
	        }
	        trie[j].fail=trie[trie[now].fail].next[i];//如果当前位置下有这个字母节点，则其失配指针指向当前位置的失配指针下的该节点；
	        //若当前位置的失配指针下没有当前遍历的该字母节点，任不影响（为0，指向超级节点）； 
	        q.push(j);//存入数组； 
	    }
	}
}
void solve_trie(int id,char *s)//查询函数； 
{
	int len=strlen(s),j=0;
	for(int i=0;i<len;i++)
	{
	    int j=trie[id].next[s[i]-'a'];//当前位置的下一个节点位置；
	    while(j && trie[j].cnt!=-1)//当此节点存在同时其cnt未被遍历； 
	    {
	        ans+=trie[j].cnt;//将答案加上所搜索的字符串中所包含的该单词数 ； 
	        trie[j].cnt=-1;//标记； 
	        j=trie[j].fail;//直接将位置指向其失配指针的位置（节约时间）； 
	    }
	    id=trie[id].next[s[i]-'a'];//id继承，当前位置的下一个节点； 
	}
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
	    scanf("%s",str);//第i个短字符串；
	    build_trie(0,str);//0为超级根节点（即所有字符串的共同祖先）；(即从0开始建) 
	}//字典树建立完成；
	build_fail(0);//建失配指针； 
	scanf("%s",str);//输入需查询的字符串；
	solve_trie(0,str); //查询； 
	printf("%d\n",ans);//输出； 
	return 0;//                                                                                              ☆⌒(*＾-゜)v THX!!
	//                                                                                                             华丽的结束；
	
	//                                                                                                                 BY:   Tel兼_dope 
}
```

---

## 作者：I_AM_HelloWord (赞：23)

正由于碰上了这道题，蒟蒻终于学会了AC自动机！激动啊٩(๑>◡<๑)۶

AC自动机=Trie+KMP

两个优化：

1.类似并差集的路径压缩，把不存在的ch[u][c]全部指向ch[f[u]][c]（f是失配函数）

2.把有效失配函数用last指针保存。

我的博客里讲的非常清楚：http://blog.csdn.net/no1\_terminator/article/details/77725530

这里就简单的讲一下：

我们重新定义KMP中的失配函数。

设f[u]=v表示从根到u号节点的这个字符串的某个后缀与从根到v号节点的这个字符串是等效的（即完全相等的）！这个后缀必须是尽量地长。

我们匹配到在一个模式串的时候就不断的沿着失配边跳，所有的端点v是标记点的失配边都对应了一个模式串。

但是这个失配关系往往会非常复杂，即我们跳了很多次，但是没有一个端点是标记点，所以我们引入last指针的优化。

即定义last[u]=v表示从u开始不断沿着失配边跳到的第一个是标记点的端点v，那么我们再匹配是就无需沿着f跳，而是沿着last跳，没跳到一个last，它就一定对应一个模式串，所以效率是非常高的。

我们首先考虑f的递推。我们设当前节点为u，其一个孩子ch[u][c]=v，k表示u沿着f边跳一次对应的点，即k=f[u],

那么如果u不是根节点，f[v]=ch[k][c]，即沿着k再向下走一个c字符，这时两个字符串还是相等的对不对。

如果u是根节点那就没什么好说的了，f[v]=0。

在此条件下，last就非常好递推了，,那么如果f[v]是标记点，那么last[v]=f[v],

否则last[v]=last[f[v]]。

这个f[v]并不能保证ch[k][c]就一定存在，所以还需要一个while循环一直跳直到找到一个ch[k][c]!=0的端点。可以出现了一个while，既使代码不够优美，又使效率无法保证，所以我们直接把所有ch[k][c]=0的端点的ch[k][c]直接连向ch[f[k]][c]，就好像并差集的一个路径压缩，由于Trie是读完所有模式串后建的，所以这个加边并不会影响Trie。

考虑到这是一个Trie树上的递推，所以我们用BFS搞一搞就好了。


好吧，有啰里啰嗦的讲了一大堆。

参考代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#define REP(i,a,b) for (int i=(a);i<=(b);i++)
#define reset(a) memset((a),0,sizeof((a)))
using namespace std;
const int N=1e6+10;
char P[N];
int n;
struct Aho_Corasick_Automaton{
    int ch[N][26],val[N],f[N],last[N],NodeCnt;
    void clear(){
        reset(ch);reset(val);reset(f);reset(last);
        NodeCnt=0;
    }
    void insert(char *S){
        int u=0,n=strlen(S);
        REP(i,0,n-1){
            int c=S[i]-'a';
            if (!ch[u][c])ch[u][c]=++NodeCnt;
            u=ch[u][c];
        }
        val[u]++;
    }
    void getFail(){
        queue<int> Q;
        Q.push(0);
        while (!Q.empty()){
            int u=Q.front(),k=f[u];Q.pop();
            REP(c,0,25){
                int v=ch[u][c];
                if (!v){ch[u][c]=ch[k][c];continue;}
                Q.push(v);
                f[v]=u?ch[k][c]:0;
                last[v]=val[f[v]]?f[v]:last[f[v]];
            }
        }
    }
    int count(char *T){
        int u=0,n=strlen(T),res=0;
        REP(i,0,n-1){
            int c=T[i]-'a';
            u=ch[u][c];
            if (val[u])res+=val[u],val[u]=0;
            int v=u;
            while (last[v]){
                v=last[v];
                if (val[v])res+=val[v],val[v]=0;
            }
        }
        return res;
    }
}AC;
int main(){
    scanf("%d",&n);
    AC.clear();
    REP(i,1,n){
        scanf("%s",P);
        AC.insert(P);
    }
    AC.getFail();
    scanf("%s",P);
    printf("%d\n",AC.count(P));
    return 0;
}
```

---

## 作者：zhiyangfan (赞：17)

其实就是在把树踹倒（Trie树）然后烤馍片（kmp）

```cpp
#include <cstdio>
#include <cstring>
const int N = 1e6 + 10;

//Trie树结构体 
struct node
{
	int son[27], fail, flag;
}trie[N];
int cnt = 1;

//将字符串加入Trie树 
void Insert(const char* s, int n)
{
	//1号为根 
	int u = 1;
	for (int i = 1; i <= n; i++)
	{
		int v = s[i] - 'a';
		//如果没有就新建节点 
		if (trie[u].son[v] == 0)
			trie[u].son[v] = ++cnt;
		u = trie[u].son[v];
	}
	//最终终点标记 
	trie[u].flag++;
}

int q[N], head, tail;
void build()
{
	//0为虚拟节点，便于构建自动机
	//第一个就失配当然就重新开始 
	for (int i = 0; i < 26; i++)
		trie[0].son[i] = 1;
	//bfs建树 
	q[tail++] = 1, trie[1].fail = 0;
	while (head < tail)
	{
		int u = q[head++];
		for (int i = 0; i < 26; i++)
		{
			int v = trie[u].son[i];
			//用父节点计算过的fail信息 
			int t = trie[u].fail;
			//如果失配 
			if (v == 0)
				//就连到父亲fail的对应子节点（递归定义，不一定就是那个节点，有可能会是
				//fail的fail的子节点 
				trie[u].son[i] = trie[t].son[i];
			else
				//匹配上的话fail连到父亲fail的对应子节点
				trie[v].fail = trie[t].son[i];
			if (v != 0)
				q[tail++] = v;
		}
	}
}

//查询就是走一遍AC自动机 
int query(const char* s, int n)
{
	int u = 1, ans = 0;
	for (int i = 1; i <= n; i++)
	{
		int v = s[i] - 'a';
		//沿着fail往下走都能匹配上 
		int k = trie[u].son[v];
		while (k > 1 && /*防止环*/trie[k].flag != -1)
		{
			ans += trie[k].flag, trie[k].flag = -1;
			k = trie[k].fail;
		}
		u = trie[u].son[v];
	}
	return ans;
}

char s[N], t[N];

int main()
{
	//fail的含义为最长的当前字符串的后缀在Trie上可以查找到的末尾编号
	//失配后直接跳就可以找到下一个匹配的点
	//类似kmp的利用原有信息的思想构建+查询
	 
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
	{
		scanf("%s", s + 1);
		int len = strlen(s + 1);
		Insert(s, len);
	}
	build();
	scanf("%s", t + 1);
	int len = strlen(t + 1);
	printf("%d", query(t, len));
	return 0;
}
```


---

## 作者：huang_yue (赞：17)

这是一个用指针写成的AC自动机。很多人都将$fail$称作“$fail$指针”，所以我觉得用指针写起来会容易理解一些。

原理在别的题解里各位大佬都已经说过了，这篇题解主要讲的是实现。 

```cpp
#include <iostream>
#include <string>
#include <queue>
/* GET(i):
 * 字符串x中的第i个字符减去'a'的值，
 * 也就是这个字符在它父亲的a数组中的位置
 * (a就是Trie上的这个节点的儿子们)。
 */
#define GET(i) (x[i] - 'a')
/* TO(x):
 * x是Trie上的一个节点。
 * 在跳转的时候，x可能为NULL(也就是0)，代表父亲没有这个儿子。
 * 这个时候就需要跳到root。
 */
#define TO(x) (x ? x : root)
using namespace std;

struct node {
	node *a[26], *fail; //a[]: 儿子们；fail: 就是fail指针
	int cnt; //有多少个字符以这个节点结尾（用来处理重复的字符串）

	/* 构造函数
	 * 创造节点使用的是new。它不会将node里面的成员置为默认值0，
	 * 所以需要专门赋一下值。
	 */
	node(): cnt(0), fail(0) {
		for (int i = 0; i < 26; ++i)
			a[i] = 0;
	}
} *root = new node(); //Trie的根 

//建立Trie 
void build(const string& x) {
	node* curr = root; //从根开始往下建Trie 
	for (int i = 0; i < x.size(); ++i) {
		if (!curr->a[GET(i)]) //如果没有这个节点的话，就新建一个 
			curr->a[GET(i)] = new node();
		curr = curr->a[GET(i)]; //然后跳到儿子节点继续建 
	}
	++curr->cnt; //建完了这个字符串，需要标记一下这里是结尾 
}

//找到fail指针 
void failure() {
	queue<node*> q; //开始bfs 
	for (int i = 0; i < 26; ++i)
		if (root->a[i])
            //把第一层(root的儿子)放进队列，并且标记它们的fail 
			q.push(root->a[i]), root->a[i]->fail = root;
	while (q.size()) {
		node* x = q.front(); q.pop();
		for (int i = 0; i < 26; ++i)
			if (x->a[i])
				/* 儿子的fail就是自己的fail的对应的儿子
				 * 当然，如果fail没有对应的儿子，就指向root
				 * 最后把儿子进队
				 */
				x->a[i]->fail = TO(x->fail->a[i]),
				q.push(x->a[i]);
			else
				//这里类似于并查集的路径压缩
				x->a[i] = x->fail->a[i];
	}
}

//查询 
int match(const string& x) {
	node* curr = root;
	int ans = 0;
	for (int i = 0; i < x.size(); ++i) {
		//跳到对应字符串中字符的那个儿子，如果没有，就跳到根
		curr = TO(curr->a[GET(i)]);
		/* 开始暴跳fail: 
		 * 找到整条fail路径上的字符串结尾节点， 
		 * 然后加到答案里，再标记成已经算过。
		 * ~x就是x != -1的意思。
		 */ 
		for (node* t = curr; t && ~t->cnt; t = t->fail)
			ans += t->cnt,
			t->cnt = -1;
	}
	return ans;
}

int main() {
	int n;
	cin >> n;
	for (int i = 0; i < n; ++i) {
		string m;
		cin >> m;
		build(m);
	}
	failure(); //不要忘了算出fail指针 
	string k;
	cin >> k;
	cout << match(k);
	return 0;
}
```


---

## 作者：Kalium (赞：15)

# 浅谈AC自动机

~~没错他不能让你直接 AC 并能让你自动 WA。~~

好吧我们进入正题：

先来一个背景：[AC自动机模板（easy）](https://www.luogu.com.cn/problem/P3808)

上面说了，

AC 自动机是 KMP + Trie 树。

所以我们还是要建一个 Trie 树（**根节点为 1**）。

建树的过程不再赘述，代码如下：

```cpp
inline void insert(char *ss) {
	int len = strlen(ss + 1), pos = 1;
	
	for (int i = 1; i <= len; i ++) {
		int c = ss[i] - 'a';
		
		if (! trie[pos][c])
			trie[pos][c] = ++ tot;
			
		pos = trie[pos][c]; 
	} 
	
	cnt[pos] ++;
}
```

现在我们要像 KMP 一样建一个 $nxt$ 数组， 但是这次我们不叫 $nxt$，叫 $fail$ 了。

那么这个家伙的意思就是：**如果说从 $root$ 到 $i$ 的串我们设为 $A$，从 $root$ 到 $j$ 的串我们称为 $B$，则 $B$ 是 $A$ 的最长后缀**。

先看看我们的字典树：

![](https://cdn.luogu.com.cn/upload/image_hosting/t7etqs8l.png)

那么我们便开始找 $fail$ 吧！

很明显，由图可知，根节点所有的孩子的 $fail$ 边所指向的点都是根节点。

那么我们是不是可以这样：

把所有根节点的儿子的 $fail$ 先预处理出来，

然后接下来开始匹配，

我们先遍历到这个 $a$ 的一个儿子即 $k$，

明显的，他没有一个是能够匹配的上的，于是他的 $fail$ 边只能指向根节点。

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/vvlp5gaj.png)

绿色的即为第三层的 $fail$ 边，第二层的 $fail$ 边即为蓝色的。

接下来我们遍历 $b$ 的儿子即为 $a$：

那么明显的有一个 $a$，所以这个 $fail$ 边便可以连向 $a$。

看图：

![](https://cdn.luogu.com.cn/upload/image_hosting/egd8jtae.png)

那我们再来遍历 $c$ 的儿子，即为 $a$，

那么我们同样的还能找到那个 $a$。

再来看 $y$，

没有与之匹配的 $fail$ 边，

便只能连向根节点。

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/n0gmwjen.png)

然后接下来便可以遍历 $k$ 的儿子就是 $i$：

明显，$i$ 也没有相同的字母， $fail$ 边还是指向根节点。

再来看 $k$ 的另一个儿子 $o$，明显的，我们也只能指向根节点。

图在下方，

$fail$ 边即为紫色边。

![](https://cdn.luogu.com.cn/upload/image_hosting/m3crmbgu.png)

然后我们再来看这个 $a$ 的儿子，就是 $o$，

我们从 $o$ 的爸爸即为 $a$ 的 $fail$ 看，其实可以发现是没有的。

所以还是连向根节点。

那么这到底是什么情况呢？

偶然？

我们看看之前所有连接的：

如果我们把 $pos$ 设为当前要求的 $fail$ 的点，那么是不是上面所有的点的 $fail$ 边都可以看成 $pos$ 他爹的$fail$ 边有无这个儿子 $k$。 

若有，$fail$ 边连向 $k$；

若没有，连向根节点。

并且，我刚刚遍历是不是按层遍历，即为 $bfs$。

所以我们可以用队列实现：

一个个儿子遍历过去，碰到的有这个儿子（真儿子），便可查询。

但是如果没有呢（假儿子）？

好办，**把连接假儿子的边设为他父亲这个点的 $fail$ 边所指向的与其相同字母的儿子**。

代码就出来了：

```
inline void bfs() {
	queue <int> q;
	
	for (int i = 0; i < 26; i ++) {
		int pos = trie[1][i];//根节点的儿子（包括真假） 
		
		if (pos) {//真儿子 
			fail[pos] = 1;//fail数组指向根节点 
			q.push(pos);//入队 
		}
	}//把根节点的儿子设为根节点，方便查询，并把他们入队 
	
	while (! q.empty()) {//开始匹配 
		int u = q.front();//取出队头 
		q.pop();//弹出 
		
		for (int i = 0; i < 26; i ++) {//一个个儿子遍历 
			int pos = trie[u][i];//u 的为i字母的儿子（包括真假） 
			
			if (pos) {//如果u的这个儿子是真儿子 
				fail[pos] = trie[fail[u]][i];//就把u这个点的儿子的fail边设置为u的fail边的那个同样的儿子 
					
				if (! fail[pos])
					fail[pos] = 1;
						
				q.push(pos);//入队 
			} else//如果是假儿子 
				trie[u][i] = trie[fail[u]][i];// 就把u的连接假儿子的边设为u这个点的fail边所指向的与其相同字母的儿子 
		}
	}
}
```

接下来是查询，

既然是查询哪些在文本中出现且相同的位置不同即可。

我们在每次查询前跳到 $fail$ 边即可，

所以查询也是极其简单的。

代码：

```
inline int find(char *ss) {
	int len = strlen(ss + 1), pos = 1, sum = 0; 
	
	for (int i = 1; i <= len; i ++) {
		int c = ss[i] - 'a';
		int u = trie[pos][c];
		
		while (u&& cnt[u] != -1) {//有这个儿子且没被搜过 
			sum += cnt[u];//加上答案 
			cnt[u] = -1;//标记 
			u = fail[u]; //跳到fail边 
		} 
		
		pos = trie[pos][c];//向下继续搞 
	}
	
	return sum; 
}
```

于是乎，就解决完毕了。

完整代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>

const int N = 1e6 + 7;

using namespace std;

char s[N];

int n, tot = 1;

struct AC {
	int trie[N][27];
	int cnt[N];
	int fail[N];
	
	inline void insert(char *ss) {
		int len = strlen(ss + 1), pos = 1;
		
		for (int i = 1; i <= len; i ++) {
			int c = ss[i] - 'a';
			
			if (! trie[pos][c])
				trie[pos][c] = ++ tot;
				
			pos = trie[pos][c]; 
		} 
		
		cnt[pos] ++;
	}//构建trie 树 
	
	inline void bfs() {
		queue <int> q;
		
		for (int i = 0; i < 26; i ++) {
			int pos = trie[1][i];//根节点的儿子（包括真假） 
			
			if (pos) {//真儿子 
				fail[pos] = 1;//fail数组指向根节点 
				q.push(pos);//入队 
			}
		}//把根节点的儿子设为根节点，方便查询，并把他们入队 
		
		while (! q.empty()) {//开始匹配 
			int u = q.front();//取出队头 
			q.pop();//弹出 
			
			for (int i = 0; i < 26; i ++) {//一个个儿子遍历 
				int pos = trie[u][i];//u 的为i字母的儿子（包括真假） 
				
				if (pos) {//如果u的这个儿子是真儿子 
					fail[pos] = trie[fail[u]][i];//就把u这个点的儿子的fail边设置为u的fail边的那个同样的儿子 
					
					if (! fail[pos])
						fail[pos] = 1;
						
					q.push(pos);//入队 
				} else//如果是假儿子 
					trie[u][i] = trie[fail[u]][i];// 就把u的连接假儿子的边设为u这个点的fail边所指向的与其相同字母的儿子 
			}
		}
	}
	
	inline int find(char *ss) {
		int len = strlen(ss + 1), pos = 1, sum = 0; 
		
		for (int i = 1; i <= len; i ++) {
			int c = ss[i] - 'a';
			int u = trie[pos][c];
			
			while (u&& cnt[u] != -1) {//有这个儿子且没被搜过 
				sum += cnt[u];//加上答案 
				cnt[u] = -1;//标记 
				u = fail[u]; //跳到fail边 
			} 
			
			pos = trie[pos][c];//向下继续搞 
		}
		
		return sum; 
	}
} ac;

int main() {
	freopen(".in", "r", stdin);
	freopen(".out", "w", stdout);
	
	cin >> n;
	
	for (int i = 1; i <= n; i ++) {
		scanf("%s", s + 1);
		ac.insert(s);
	}
	
	ac.bfs();
	
	scanf("%s", s + 1);
	
	cout << ac.find(s) << endl;
	
	return 0;
}
```

请勿直接抄（注意 freopen）。

$Atlantic$.


---

## 作者：big_news (赞：11)

[更美妙的阅读体验](https://big-news.cn/2020/08/04/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91AC%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88%E7%AE%80%E5%8D%95%E7%89%88%EF%BC%89/)

### 后缀数组

提供一个清新的后缀数组解法（好像还没看见题解里面有）。

后缀数组是个好东西啊，通过这个工具可以解决许多类型的字符串问题，这里简单介绍一下：

形式化地，对于一个长度为 $n$ 的字符串 $s$，它的形如 $s[i:n]$ 的子串被称作 $s$ 的后缀。

容易发现 $s$ 一共有 $n$ 个后缀，不妨记 $s[i:n]$ 为后缀 $i$，将所有的后缀排序后，顺序写下后缀的编号，就得到了后缀数组 (Suffix Array)。

举个例子，对 $s=ababa$，其后缀有 $a,ba,aba,baba,ababa$，排序后得到 $a,aba,ababa,ba,baba$，依次写下其编号，得到后缀数组为 $5,3,1,2,4$。

朴素求后缀数组是 $O(n^2 \log n)$ 的，这显然是不太好的。通过倍增法去求，容易发现倍增的过程是某种双关键字排序，那么对其进行基数排序，可做到 $O(n \log n)$。具体的实现超出了本篇题解的范畴，请移步 [后缀排序](https://www.luogu.com.cn/problem/P3809)。

### 回到本题

容易发现，一个串 $s$ 若能与 $t$ 匹配，那么它必然是 $t$ 的 **某个后缀的前缀**。
我们可以快速把所有后缀都排序，这样后缀就是有序的了，可以通过二分来找 $s$ 是否与 $t$ 匹配。

具体实现上，因为后缀的长度和是 $O(n^2)$ 级别的，所以不能把他们全部搞出来（会MLE）。实际上只需要写一个 `cmp()` 函数来比较字符串大小就好了，实现起来比较清新易懂。

复杂度因为每次要二分，所以整体多了一个 $\log$，不过均摊下来跑的非常快，常数比AC自动机大了不到一半。

代码：

```cpp
/* fake-acam.cpp */
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
using namespace std;

const int CN = 1e6 + 6;

char t[CN], s[CN];
string mem[CN];

int sa[CN], rk[CN << 1], prk[CN << 1], id[CN], px[CN], cnt[CN];
void SA(int n){
    int m = max(n, 300);
    for(int i = 1;i <= n;i++) rk[i] = t[i - 1];
    for(int i = 1;i <= n;i++) cnt[ rk[i] ] ++;
    for(int i = 1;i <= m;i++) cnt[i] += cnt[i - 1];
    for(int i = n; i; i--) sa[ cnt[ rk[i] ]-- ] = i;
    for(int w = 1; w < n; w <<= 1){
        memset(cnt, 0, sizeof(cnt));
        for(int i = 1;i <= n;i++) id[i] = sa[i];
        for(int i = 1;i <= n;i++) cnt[ px[i] = rk[ id[i] + w ] ]++;
        for(int i = 1;i <= m;i++) cnt[i] += cnt[i - 1];
        for(int i = n; i; i--) sa[ cnt[ px[i] ]-- ] = id[i];
        memset(cnt, 0, sizeof(cnt));
        for(int i = 1;i <= n;i++) id[i] = sa[i];
        for(int i = 1;i <= n;i++) cnt[ px[i] = rk[ id[i] ] ]++;
        for(int i = 1;i <= m;i++) cnt[i] += cnt[i - 1];
        for(int i = n; i; i--) sa[ cnt[ px[i] ]-- ] = id[i];
        memcpy(prk, rk, sizeof(rk)); m = 0;
        for(int i = 1;i <= n;i++)
            if(prk[ sa[i] ] == prk[ sa[i - 1] ] && prk[ sa[i] + w ] == prk[ sa[i - 1] + w ])
                rk[ sa[i] ] = m;
            else rk[ sa[i] ] = ++m;
        if(m == n) break;
    }
}

int n, lt;

// 判断 a[] < b[]
inline int le(char *a, char *b, int la,int lb){
    int p = 0;
    while(a[p] == b[p] && p < min(la, lb)) p++;
    if(p == lb) return -1;
    if(p == la) return true;
    return a[p] < b[p];
}

int main()
{
    freopen("_in.in", "r", stdin);
    // freopen("out.txt", "w", stdout);
    
    scanf("%d", &n);
    for(int i = 1;i <= n;i++) cin >> mem[i];
    cin >> t; lt = strlen(t);

    SA(lt);
    
    int cnt = 0;
    for(int i = 1;i <= n;i++){
        int ls = mem[i].size();
        s[ls] = '\0';
        for(int j = 0;j < ls;j++) s[j] = mem[i][j];

        int l = 1, r = lt, m; bool found = false;
        while(l < r){
            m = (l + r) >> 1;
            int leq = le(t + sa[m] - 1, s, lt - sa[m] + 1,ls);
            if(leq == -1) {found = true; break;}
            else if(leq) l = m + 1;
            else r = m;
        }

        cnt += found ? 1 : 0;
    }

    printf("%d", cnt);
}
```

---

## 作者：SpXace (赞：8)

一道AC~~（Accept）~~自动机的模板~~

先构建fail数组，在tire树中进行匹配，并利用fail数组进行跳转。

核心在于，已经匹配过的部分的后缀，也是fail数组指向的前缀，从而使此部分不必进行匹配。

AC~~（Accept）~~自动机以类似于KMP的next数组思想，充分利用已经匹配的部分，使相同的部分不必再次匹配，从而提高效率
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<vector> 
#include<cstring> 
using namespace std;
char s[1000010];
queue <int> Q;
struct node{
	int fail;		//fail数组			
	int bh;			//当前点的代表的字母 
	int Dad;		//当前点的父亲 
	int word[27];	//当前点的儿子 （0~25） 
	int end;		//当前点是否是单词结尾 
	int BJ;			//当前点是否被计入答案 
	int fail_bj;	//当前点是否已查找过fail 
};
node tree[1000050];
int N,tot = 0,Ans = 0;	
void init()							//建立tire树 
{
	int len = strlen(s);
	int rt = 0;
	for( int i = 0; i < len; ++i)
	{
		int x = s[i] - 'a';
		if (!tree[rt].word[x]){		//若当前点未加入，则加入tire树 
			tree[rt].word[x] = ++tot;
			tree[tot].bh=x;			//标记当前点的字母  ！！！！ 
			tree[tot].Dad=rt; 		//标记当前点的Dad 
		}	    
		rt=tree[rt].word[x];		//rt向下 
	}
	tree[rt].end++;				 	//是单词结尾，累加 
}
void make_fail()					//计算fail标记 
{
	tree[0].fail = -1;
	for(int i = 0; i < 26; ++i)			
		if( tree[0].word[i] )
			Q.push( tree[0].word[i] );	//根节点的孩子入队 
	while( !Q.empty() )
	{
		int now = Q.front(); Q.pop();		//取队头 (当前点)
		int x = tree[now].bh;				//当前点代表的字母  ！！！ 
		int dad = tree[now].Dad;			//当前点的父亲 
		int dad_fail = tree[dad].fail; 		//当前点父亲的fail 
		while(dad_fail != -1 && tree[dad_fail].word[x] == 0)//若当前点不是原点，且当前点父亲的fail的儿子没有当前点，则继续向上 
	 		   dad_fail = tree[dad_fail].fail;
	 	if(dad_fail == -1)									//若为原点，则当前点fail为0 
	 		tree[now].fail = 0;
	 	else
		 	tree[now].fail = tree[dad_fail].word[x];		//若找到某个fail有当前点，则赋值 
		for(int i = 0; i < 26; ++i)			
			if(tree[now].word[i])
				Q.push(tree[now].word[i]);					//此节点的孩子入队 	
	}
}
void find()											//查找文章 
{
	int len = strlen(s);
	int rt = 0;
	tree[rt].fail = -1;
	for(int i = 0; i < len; ++i)
	{
		int x = s[i] - 'a';
		while( tree[rt].fail != -1 && tree[rt].word[x] == 0)	//若当前点不是原点，且当前点的儿子中没有x，匹配失败，找fail 
			rt=tree[rt].fail;
		if(tree[rt].word[x] != 0)				//若当前点匹配成功，则继续往下找 
			rt = tree[rt].word[x];			
		else									//若当前点未匹配成功，则fail到达原点，rt等于0 
			rt = 0;								
		if(tree[rt].end && !tree[rt].BJ)		//若是单词结尾且是第一次访问，Ans++，并且BJ=1，以后不再访问 
		   Ans += tree[rt].end, tree[rt].BJ = 1; 
		int v = rt;
		while( tree[v].fail != -1 && !tree[v].fail_bj) //无论是否找到，是否是结尾，都要找当前点的fail，并不断找fail，判断是否是结尾，以保证查找的全面性 
		{
			int k=tree[v].fail;					
			if(tree[k].end && !tree[k].BJ)				//若是单词结尾且是第一次访问，Ans++，并且BJ=1，以后不再访问 
				Ans += tree[k].end, tree[k].BJ = 1; 
			v = tree[v].fail;
		} 
		tree[rt].fail_bj = 1;			//优化：若当前点已经经过查找fail，则不必查找 
	}
} 
int main()
{
	cin >> N;
	for(int i = 1; i <= N; ++i )		//输入模式串，构建tire树 
	{
		scanf("%s",s);
		init();
	}
	make_fail();					//构建fail数组 
	scanf("%s",s);
	find(); 						//查找	
	cout << Ans; 
	return 0;
}
//下班了，下班了~~~~ 
```

---

## 作者：HansLimon (赞：6)

### 算是KMP的加强版
如果我们有多个模式串，然而KMP实质上并不能在时限内做到这一点，因此，我们需要一颗可爱的线段树来记录模板们，最后一次匹配：


## 我就默认各位已经知晓KMP与Trie树了哟
# - 思路：
先将所有模板放入一颗线段树，然后使用KMP来寻找适配。

就是这么简单（？？？？我差点没学疯）

比如说，我们有这样的模板串{he, she, his, hers}，从1到4编号，目的是求出有哪些被囊括于原串的（无所谓字典序与否），我们用图来解释：
# - 构造：
#### Trie树：
![字丑请见谅qwq](https://cdn.luogu.com.cn/upload/pic/74300.png )
（4号点是因为画不下了所以拐了个弯）然后我们就建好了一颗Trie树，接下来
Import KMP：
![第一次](https://s2.ax1x.com/2019/08/23/mDULTO.png)
然后，下层的子节点会尝试找到其父亲节点next指向的结点的下一层与之相同的结点作为其next的方向，如果没有，就指向根节点。有点绕，所以还是画图叭（以下面那条为例）：
![第二次](https://s2.ax1x.com/2019/08/23/mDUXkD.png)
于是乎：
![第三次](https://s2.ax1x.com/2019/08/23/mDUjte.png)
最后就成了这个样子：
![第四次](https://s2.ax1x.com/2019/08/23/mDUq0K.png)
有点绕，花一小会时间也OK

箭头标示着给程序说“如果你在我这失配，那你就去那里”，因为我们找的是父亲节点next的下一层，所以一定不会说呀这个前面的部分不匹配的情况。

**其实说到这一步AC自动机也就差不多了**
接下来放码：
# - 代码段：
###### 这个代码段，它有点乱

我这里以 _P3808 【模板】AC自动机（简单版）_ 为例
```cpp
#include <cstdio>
#include <cstring>
#include <queue>

const int N = 1e6 + 7;
int n, cnt, trie[N][26], cnt_word[N], fail[N];//唯一看不懂的应该是这个cnt_word，用来标识某个位置有一个模式串结尾，如有多个，就++。所以说如果模式串不重复的话，可以开成bool数组
char mode_sentence[N], sentence[N];

void insert_new_word(int len){
	register int now = 0;
	for(register int i = 0;i < len;i ++){
        register int now_point = mode_sentence[i] - 'a';
		if(!trie[now][now_point])trie[now][now_point] = ++ cnt;
		now = trie[now][now_point];
		mode_sentence[i] = '\0';
    }
	cnt_word[now] ++;
}
void make_fail(){
	register std::queue<int> line;
	for (register int i = 0;i < 26;i ++){
		if (trie[0][i]){
			fail[trie[0][i]] = 0;
			line.push(trie[0][i]);
		}
	}
	while(!line.empty()){
		register int now_point = line.front();
		line.pop();
		for (register int i = 0;i < 26;i ++){
			if (trie[now_point][i]){
				fail[trie[now_point][i]] = trie[fail[now_point]][i];
				line.push(trie[now_point][i]);
			}
			else trie[now_point][i] = trie[fail[now_point]][i];
		}
	}
}
inline int question(){
	register int len = strlen(sentence), now = 0, ans = 0;
	for (register int i = 0;i < len;i ++){
		now = trie[now][sentence[i] - 'a'];
		for (register int j = now;j && cnt_word[j] != -1;j = fail[j]){
			ans += cnt_word[j];
			cnt_word[j] = -1;
		}
	}
	return ans;
}

int main(){
    scanf("%d\n", &n);
    for (register int i = 0;i < n;i ++){
    	register int cnt = -1;
    	while (true){
    		mode_sentence[++ cnt] = getchar();
    		if (mode_sentence[cnt] == '\n')break;
    	}
		insert_new_word(cnt);
	}
    make_fail();
    gets(sentence);
    printf("%d", question());
    return 0;
}
```
其实有很多巨佬建议用结构体，不过我觉得这样子可能方便理解。

写时匆忙，如有错误，请~~点赞~~在讨论区说一下，我尽快修正。

---

## 作者：ikka (赞：4)

# 洛谷P3808AC自动机题解

~~你以为我是一篇AC自动机的题解，其实我是来安利指针哒！~~

题目链接： [洛谷P3808 AC自动机](https://www.luogu.org/problemnew/show/P3808)

**AC自动机 = KMP + Trie**

实质上就是把线性的KMP转化成了Trie树上的KMP。

原来的失配指针改成了树上的失配指针。

Trie树上的失配指针表示为，每个节点的失配指针指向的是以当前节点表示的字符为最后一个字符的最长当前字符串的后缀字符串的最后一个节点。这样可以用bfs求出来。

原理很简单，例如在串ABCDFE中匹配ABCDE和CDFE，

当我们在匹配到第一个模式串的第5位和文本串的第5位时发现了不匹配，我们会直接跳到第二个模式串的第3位进行匹配，而不是从头开始。这就是AC自动机的主要原理。

个人表达能力不强，描述的有点简陋，具体实现可以看代码。
``` cpp
#include <bits/stdc++.h>
const int maxn = 1000010;
char ss[maxn];
struct node {
  node *ch[26];     //指针大法好！
  int exist;
  node *fail;
  node(): exist(0), fail(0) { memset(ch, 0, sizeof ch); }
};
node *root = new node;
void insert(char *s) {      //Trie树的插入
  node *p = root;
  for (int i = 0; s[i]; ++i) {
    int x = s[i] - 'a';
    if (p -> ch[x] == NULL) p -> ch[x] = new node;
    p = p -> ch[x];
  }
  ++p -> exist;
}
void get_fail() {        //bfs构造失配指针
  node *p, *tmp;
  std::queue<node*> q;
  q.push(root);
  while (!q.empty()) {
    tmp = q.front(); q.pop();
    for (int i = 0; i < 26; ++i) if (tmp -> ch[i]) {
      if (tmp == root) {
        tmp -> ch[i] -> fail = root;
      } else {
        p = tmp -> fail;
        while (p) {
          if (p -> ch[i]) {
            tmp -> ch[i] -> fail = p -> ch[i];
            break; 
          }
          p = p -> fail;
        }
        if (p == NULL) tmp -> ch[i] -> fail = root;
      }
      q.push(tmp -> ch[i]);
    }
  }
}
int AC(char *s) {         //匹配过程
  int cnt = 0;
  int l = strlen(s);
  node *p = root;
  for (int i = 0; i < l; ++i) {
    int x = s[i] - 'a';
    while (!p -> ch[x] && p != root) p = p -> fail;
    p = p -> ch[x];
    if (!p) p = root;
    node *tmp = p;
    while (tmp != root) {
      if (tmp -> exist >= 0) cnt += tmp -> exist, tmp -> exist = -1;
      else break;
      tmp = tmp -> fail;
    }
  }
  return cnt;
}
int main() {
  int n;
  scanf("%d", &n);
  while (n--) {
    scanf("%s", ss);    //读入模式串
    insert(ss);         //插入Trie树
  }
  get_fail();           //构造失配指针
  scanf("%s", ss);      
  printf("%d", AC(ss)); //AC自动机匹配
  return 0;     //告辞
}
```

**Advertisement ：
[我的个人博客](https://phqghume.github.io/2018/06/28/洛谷P3808-AC自动机/)**

---

## 作者：tiger2005 (赞：4)

ng

我似乎是没打任何Trie的题就跑过来的~

有AC自动机基础的看看注释

没有的先去百度
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
struct Node{
	int fa,zz[26],nn,fail,is; 
//fa父亲，zz指针，nn本身字符，fail失配指针，is该位上单词个数
}ac[1000001];
char lo[1000001];
int N,n=1,ans=0;//n目前的节点数量
queue<int> q;
void bu(){//处理当前字符串
	int now=1;//现在处理的节点
	for(int i=0;lo[i]!=0;i++){
		if(!ac[now].zz[lo[i]-'a']){//没有追指向
			++n;//新开
			ac[n].fa=now;
			ac[now].zz[lo[i]-'a']=n;
			now=n;
			ac[now].nn=lo[i]-'a';//连接fa,zz
		}
		else	now=ac[now].zz[lo[i]-'a'];//指针
	}
	++ac[now].is;//单词次数
}
int main(){
	scanf("%d",&N);
	while(N--){
		scanf(" %s",lo);
		bu();
	}
	ac[1].fail=0;
	for(int i=0;i<26;i++)	ac[0].zz[i]=1;/虚点处理
	for(int i=0;i<26;i++){
		if(ac[1].zz[i])	q.push(ac[1].zz[i]);//bfs
	}
	while(!q.empty()){
		int i=q.front();
		q.pop();//按层的顺序获取
		int f=ac[i].fa;
		while(!ac[ac[f].fail].zz[ac[i].nn])	f=ac[f].fail;//寻找fail值
		ac[i].fail=ac[ac[f].fail].zz[ac[i].nn];
		for(int j=0;j<26;j++){
			if(ac[i].zz[j])	q.push(ac[i].zz[j]);//搜寻下一层节点
		}
	}
	scanf(" %s",lo);
	int now=1; 
	for(int i=0;lo[i]!=0;i++){
		while(!ac[now].zz[lo[i]-'a'])	now=ac[now].fail;//失配
		now=ac[now].zz[lo[i]-'a'];//往下搜寻
		ans+=ac[now].is;//单词数
		ac[now].is=0;//只能记一次
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：orzws (赞：3)

要学AC自动机需要自备两个前置技能:KMP和trie树看，不懂的先看一下下面的博客，让后再回来学习。

KMP: [传送门](https://www.cnblogs.com/yjiyjige/p/3263858.html)   字典树（Trie）：[传送门](https://www.cnblogs.com/henry-1202/p/9029822.html)

如果你学会了KMP和Trie那就可以来学AC自动机了。

我们知道，KMP每次只能够匹配一条字符串，但如果有多条字符串要怎么办呢？输入一条字符串求一次next数组吗？这样会很麻烦且很浪费。

这个时候,AC自动机出现了。我们可以吧所有的子串都先放在字典树上，然后建立fail数组，也就是KMP里的next数组。

具体的图可以看一下这[点这里](https://blog.csdn.net/bestsort/article/details/82947639)，我们可以发现fail跟next差不多，然后只要匹配失败我们就跳fail。

但学AC自动机还是要先有KMP和字典树的基础，不会的先学完再来看。

第一步是要建一个字典树：
```cpp
void jt(string s) {
    int len = s.length();
    int root = 0;
    for(int i = 0; i < len; i++) {
        int next = s[i] - 'a';
        if(!trie[root][next])
            trie[root][next] = ++cnt; //如果匹配不到，那就新建一个点
        root = trie[root][next];
    }
    number[root]++;//单词结尾处，加一个标记。
}
```
其实我们也可以用结构体，但这里我们用2维数组，这样比较容易理解一些。

然后在结尾处要先标记为1，这个在下面匹配时候有很大用处。

下一步是要建fail数组：
```cpp
void Fail() {
    queue <int> q;
    for(int i = 0; i < 26; i++) {
        if(trie[0][i]) {
            q.push(trie[0][i]);
            fail[trie[0][i]] = 0;
        }
    }
    while(!q.empty()) {
        int now = q.front();
        q.pop();
        for(int i = 0; i < 26; i++) {
            if(trie[now][i]) {
                fail[trie[now][i]] = trie[fail[now]][i];
                q.push(trie[now][i]);
            } else
                trie[now][i] = trie[fail[now]][i];
        }
    }
}
```
我们的fail数组使用bfs来实现的，先把第二层的数给扔进队列，让后bfs往下匹配，找到字母就放进去，直到没有为止。
```cpp
fail[trie[now][i]] = trie[fail[now]][i];
```
这个地方看起来可能会有点懵，其实这个就跟next数组一样，如果上面的相同的话，就可以直接跳转，不用重新去找一次。

接下来就是匹配了：
```cpp
void AC(string o) {
    int now = 0;
    for(int i = 0; i < o.length(); i++) {
        now = trie[now][o[i]-'a'];
        for(int j = now; j && number[j] != -1; j = fail[j]) {
            ans += number[j];
            number[j] = -1;
        }
    }
}
```
匹配的话我们是只要能往下就找往下找。

这个时候我们在上面标记的1就起到了作用。

我们把访问过的所有节点的值都给加上，如果访问到了单词末尾，那我们就可以直接加上。

这样也可以避免重复计算，把找过的都标记为-1，就不会找多次。

下面是完整的代码：
```cpp
#include<iostream>
#include<cstring>
#include<queue>
#include<cstdio>
using namespace std;
int trie[10000005][26],fail[10000005],number[10000005],ans,cnt = 0;
void jt(string s) {
    int len = s.length();
    int root = 0;
    for(int i = 0; i < len; i++) {
        int next = s[i] - 'a';
        if(!trie[root][next])
            trie[root][next] = ++cnt;
        root = trie[root][next];
    }
    number[root]++;
}
void Fail() {
    queue <int> q;
    for(int i = 0; i < 26; i++) {
        if(trie[0][i]) {
            q.push(trie[0][i]);
            fail[trie[0][i]] = 0;
        }
    }
    while(!q.empty()) {
        int now = q.front();
        q.pop();
        for(int i = 0; i < 26; i++) {
            if(trie[now][i]) {
                fail[trie[now][i]] = trie[fail[now]][i];
                q.push(trie[now][i]);
            } else
                trie[now][i] = trie[fail[now]][i];
        }
    }
}
void AC(string o) {
    int now = 0;
    for(int i = 0; i < o.length(); i++) {
        now = trie[now][o[i]-'a'];
        for(int j = now; j && number[j] != -1; j = fail[j]) {
            ans += number[j];
            number[j] = -1;
        }
    }
}
int main() {
    int n;
    cin >> n;
    string s;
    for(int i = 1; i <= n; i++) {
        cin >> s;
        jt(s);
    }
    Fail();
    string u;
    cin >> u;
    AC(u);
    cout << ans;
}
```
这篇题解借鉴了这篇博客的思路，里面有详细图解，大家可以去看一下[传送门](https://blog.csdn.net/bestsort/article/details/82947639)。

希望对大家有帮助。

---

## 作者：FREEH (赞：3)

### 【算法目标】
- 给出多个字典单词和一个匹配字符串，求出匹配字符串中存在多少个字典单词。

### 【算法思路】
- 一、假如我们不会AC自动机，我们会怎么做？
	- 对于给出的每个字典单词，将它加入一棵Trie树里，然后把匹配字符串中的每一个单词在Trie树中跑一遍，然后统计就行了。但是这样分解匹配字符串时间复杂度很高。

- 二、AC自动机运用了KMP的思想
	- KMP中有一个next数组，失配时用于跳跃。AC自动机也运用了这个思想。
	- AC自动机处理的是字典单词。它也有一个失配数组fail，表示：以当前字符串为后缀的最长的字符串。fail指针的用途是当匹配字符串在Trie树上跑时，得以用fail指针不断地跳统计数量，优化时间。
- 三、fail指针的构造
	- 先把字典单词加入Trie树。然后用bfs一层层扫描Trie树。明显的，根节点的子节点的fail如果当前节点有子节点，那么子节点的fail节点就是当前节点的fail节点的子节点。
	- 有一个剪枝，就是如果当前节点没有子节点时，就把当前节点的子节点指向当前节点的fail节点的子节点。
- 四、统计。
	- 把匹配字符串在AC自动机上像Trie树一样跑，只是跑到的每一个节点都要不断地顺着fail指针走一次，并且统计总数。

### 【参考程序】
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;

char st[1000005],p[1000005];
struct TRIE{
    int son[27];
    int val;
}trie[1000005];
int fail[1000005];
int L;

void Fill_in(char *st,int rank)
{
    int len=strlen(st),u=0;
    for (int i=0;i<len;i++)
    {
        int v=st[i]-'a';
        if (!trie[u].son[v])
            trie[u].son[v]=++L;
        u=trie[u].son[v];
    }
    trie[u].val++;
}
void Build()
{
    queue <int> q;
    for (int i=0;i<26;i++)
        if (trie[0].son[i])
        {
            q.push(trie[0].son[i]);
            fail[trie[0].son[i]]=0;
        }
    while (!q.empty())
    {
        int now=q.front();q.pop();
        for (int i=0;i<26;i++)
            if (trie[now].son[i])
            {
                fail[trie[now].son[i]]=trie[fail[now]].son[i];
                q.push(trie[now].son[i]);
            }else
            trie[now].son[i]=trie[fail[now]].son[i];
    }
}
int Check(char *st)
{
    int len=strlen(st),u=0,ans=0;
    for (int i=0;i<len;i++)
    {
        u=trie[u].son[st[i]-'a'];
        for (int h=u;h&&~trie[h].val;h=fail[h])
        {
            ans+=trie[h].val;
            trie[h].val=-1;
        }
    }
    return ans;
}
int main()
{
    int T,n;
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
    {
        scanf("%s",st);
        Fill_in(st,i);
    }
    Build();
    scanf("%s",p);
    printf("%d",Check(p));
    return 0;
}
```

---

## 作者：漠寒 (赞：2)

## AC自动机

简单来说就是在$trie$树上跑一个$KMP$。

### 那我们为什么要这样做呢？

由题意得，我们是要在一个大串里寻找一些小串，所以我们就应该将所有小串建一个$trie$树，然后将大串放进去跑，看下能到哪些地方，既然如此，我们的目的就是在到达一个字符时，弄好它的所有的前缀和后缀，后缀，当然就是用$fail$来处理了，因此，我们每到一个字符，确认它在$trie$树中的位置之后，我们就应跳一次$fail$，弄好它的后缀，这复杂度可能很高，比如全为同一字符时，你每次就需跳长度那么多次，所以我们就需要优化，跳过一次之后打一个标记，说明已经跳过该位置和它的所有后缀，再新一次跳到这里的时候，就可以$break$掉了。

#### 代码

```
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
using namespace std;
int n,isend[1000001],go[1000001][26],fail[1000001],cnt,len,t,ans,q[1000001];
char c[1000001];

void push(){//加入 
	int t=0;
	for(int i=0;i<len;i++){
		int tt=c[i]-'a';
		if(!go[t][tt])go[t][tt]=++cnt;
		t=go[t][tt];
	}
	isend[t]++;
}

void gget(){//找fail 
	int head=0,tail=0;
	for(int i=0;i<26;i++)if(go[0][i])q[tail++]=go[0][i];
	while(head<tail){
		int a=q[head++];
		for(int i=0;i<26;i++){
			if(go[a][i]){
				int t=fail[a];
				while(t&&!go[t][i])t=fail[t];
				fail[go[a][i]]=go[t][i];
				q[tail++]=go[a][i];
			}
		}
	}
}

void tiao(int x){//往上跳fail找后缀 
	while(x){
		if(isend[x]==-1)break;//已经跳过了 
		ans+=isend[x];
		isend[x]=-1;
		x=fail[x];
	}
}

void AC(){//
	int t=0;
	for(int i=0;i<len;i++){
		int tt=c[i]-'a';
		while(t&&!go[t][tt])t=fail[t];
		if(go[t][tt])t=go[t][tt];
		tiao(t);//每取一个字符跳一次 
	}
	cout<<ans<<endl;
}

int main()
{
	scanf("%d",&n);
	while(n--){
		scanf("%s",c);
		len=strlen(c);
		push();
	}
	gget();
	scanf("%s",c);
	len=strlen(c);
	AC();
	return 0;
}

```


---

## 作者：tq20191005 (赞：2)

用指针写的,AC自动机有不懂的可以去百度.
```
#include<iostream>
#include<string>
#include<cstring>
#include<queue>
using namespace std;
class node
{
public:
	node* links[26];
	node* fail;
	int cnt, sum;
	node() {
		memset(links, NULL, sizeof links);
		fail = NULL; cnt = 0, sum = 0;
	};
	~node() {};
	//插入模式串
	void Insert(string str) {
		auto f = this;
		for (auto vi : str) {
			int ch = vi - 'a';
			if (f->links[ch] == NULL)
				f->links[ch] = new node();
			f = f->links[ch];
		}
		++f->cnt;
	}
	//创建 fail指针
	void buil_fail()
	{
		queue<node*>qu; qu.push(this);
		while (!qu.empty())
		{
			auto temp = qu.front(); qu.pop();
			for (int i = 0; i < 26; i++) {
				if (temp->links[i]) {
					qu.push(temp->links[i]);//新节点入队列
					auto father = temp->fail;//父节点转移的节点
					if (temp == this)
						temp->links[i]->fail = this;
					else {
						while (father) {
							if (father->links[i]) {
								temp->links[i]->fail = father->links[i]; break;
							}
							father = father->fail;
						}
						if (father == NULL) temp->links[i]->fail = this;
					}
				}
			}
		}
	}
	//匹配文本串
	void ac_automation(string text)
	{
		node* p = this;
		for (auto vi : text) {
			int ch = vi - 'a';
			while (p && !p->links[ch])p = p->fail;//找到一条通路  this->fail = nullptr
			if (p == NULL) { p = this; continue; }
			p = p->links[ch];
			auto tmp = p;
			while (tmp != this) {
				if (tmp->cnt > 0) {
					this->sum += tmp->cnt;
					tmp->cnt = -1;
				}
				else break;
				tmp = tmp->fail;
			}
		}
	}
};
int main(void) {
	node A;
	int n; cin >> n;
	while (n--) {
		string str; cin >> str;
		A.Insert(str);
	}
	A.buil_fail();
	string text; cin >> text;
	A.ac_automation(text);
	cout << A.sum << endl;
	return 0;
}
```

---

## 作者：G我就是菜G (赞：2)

### AC自动机

【先决条件】 $KMP/Trie$ 树

AC自动机（优化了可以叫 $Trie$ 图），是一种有限状态机

可以理解为将 $KMP$ 放在了 $Trie$ 树上

### 失配指针 $Fail$

![](https://cdn.luogu.com.cn/upload/pic/59584.png)

建完 $Trie$ 树以后定义失配指针

定义 $v=s[i]-'a'\quad now$ 为当前节点

$fail[trie[now][v]]=trie[fail[now]][v]$

即该节点父亲 $fail$ 指向的节点的与该节点字符相同的儿子

### 查询

同理，$now$ 为当前所在节点，$v=s[i]-'a'$

每次将 $now=trie[now][v]$

然后暴力查找 $fail$ 指针指向的节点是否为某个模式串的结尾

```cpp
for (int t=now;t&&~tag[t];t=fail[t])
	ans+=tag[t],tag[t]=-1;
```

### 完整代码

[P3808 【模板】AC自动机（简单版）](https://www.luogu.org/problemnew/show/P3808)
```cpp
#include <bits/stdc++.h>
#define N 500010
using namespace std;
int n;
char s[1000010];

struct node_{
    int tag[N],trie[N][26],cnt,fail[N];
    queue<int> q;
    void insert(char *s)
    {
        int len=strlen(s),now=0,v;
        for (int i=0;i<len;i++)
        {
            v=s[i]-'a';
            if (!trie[now][v]) trie[now][v]=++cnt;
            now=trie[now][v];
        }
        tag[now]++;
    }
    void build()
    {
        int now;
        for (int i=0;i<26;i++)
            if (trie[0][i]) fail[trie[0][i]]=0,q.push(trie[0][i]);
            while (!q.empty())
            {
                now=q.front(),q.pop();
                for (int i=0;i<26;i++)
                    if (trie[now][i]) fail[trie[now][i]]=trie[fail[now]][i],q.push(trie[now][i]);
                    else trie[now][i]=trie[fail[now]][i];
            }
    }
    int query(char *s)
    {
        int len=strlen(s),now=0,v,ans=0;
        for (int i=0;i<len;i++)
        {
            v=s[i]-'a';
            now=trie[now][v];
            for (int t=now;t&&~tag[t];t=fail[t]) ans+=tag[t],tag[t]=-1;
        }
        return ans;
    }
}AC;

int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
        scanf("%s",s),AC.insert(s);
    AC.build();
    scanf("%s",s);
    printf("%d\n",AC.query(s));
    return 0;
}
```

[P3796 【模板】AC自动机（加强版）](https://www.luogu.org/problemnew/show/P3796)

```cpp
#include <bits/stdc++.h>
#define N 500010
using namespace std;
int n,sum[N],_max;
char s[200][100],s1[N<<1];
struct node{
    int trie[N][26],tag[N],id[N],fail[N],cnt;
    queue<int> q;
    void clean()
    {
        cnt=0;
        memset(trie,0,sizeof(trie));
        memset(fail,0,sizeof(fail));
        memset(tag,0,sizeof(tag));
        memset(id,0,sizeof(id));
    }
    void insert(char *s,int x)
    {
        int now=0,v,len=strlen(s);
        for (int i=0;i<len;i++)
        {
            v=s[i]-'a';
            if (!trie[now][v]) trie[now][v]=++cnt;
            now=trie[now][v];
        }
        tag[now]=1;id[now]=x;
    }
    void build()
    {
        int now;
        for (int i=0;i<26;i++)
            if (trie[0][i]) fail[trie[0][i]]=0,q.push(trie[0][i]);
        while (!q.empty())
        {
            now=q.front();q.pop();
            for (int i=0;i<26;i++)
                if (trie[now][i]) fail[trie[now][i]]=trie[fail[now]][i],q.push(trie[now][i]);
                else trie[now][i]=trie[fail[now]][i];
        }
    }
    void query(char *s)
    {
        int now=0,v,len=strlen(s);
        for (int i=0;i<len;i++)
        {
            v=s[i]-'a';
            now=trie[now][v];
            for (int t=now;t;t=fail[t])
                if (tag[t]) sum[id[t]]++;
        }
    }
}AC;
int main()
{
    scanf("%d",&n);
    while (n)
    {
        AC.clean();
        for (int i=1;i<=n;i++)
            scanf("%s",s[i]),AC.insert(s[i],i);
        AC.build();
        memset(sum,0,sizeof(sum));
        scanf("%s",s1);
        AC.query(s1);
        _max=0;
        for (int i=1;i<=n;i++)
            _max=max(_max,sum[i]);
        printf("%d\n",_max);
        for (int i=1;i<=n;i++)
            if (sum[i]==_max)
                printf("%s\n",s[i]);
        scanf("%d",&n);
    }
    return 0;
}
```

---

## 作者：晚安晚安 (赞：2)

## ac自动机模板题（改）

#### 前言：
如果不会ac自动机的话自行百度qvq。

 这差不多就是一道ac机的模板题目，就改了一点点小地方，也就是要多用一个数组存次数，我直接用读入顺序作为每个字符串的编号，而次数存储也是用的读入顺序为编号，每找到一个串，则利用trie树中存的编号访问ans数组，然后其次数++。
 
之所以读入要从1开始，也是为了方便判断trie树中该节点是不是某个串的结尾。
 
其实一开始我还考虑了模板会不会有一样的，那么还要判断一下模板数量然后输出，但是因为我比较聪明~~懒~~，先做了一遍没有判断的试了一下，结果a了。。。有兴趣的同学可以吧这种情况优化一下，我后面想了一下，用了个映射（因为我还保证了输入顺序输出qvq，要不然可以更简单）
```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
using namespace std;
const int maxn = 300000+5;
const int SIGMA_SIZE = 26;
int maxx = 0;
char p[200][105];
int ans[200];
char T[1000000+5];
queue <int> qe;
struct AC_automata
{
    int ch[maxn][26], val[maxn], f[maxn], cnt = 0;
    void clear()
    {
        cnt = maxx = 0;
        for(int i = 0; i < maxn; ++i)
        {
            val[i] = f[i] = 0;
            for(int j = 0; j < 26; ++j)ch[i][j] = 0;
        }
        memset(ans, 0, sizeof ans);
    }
    void insert(char *s, int num)
    {
        int now = 0;
        for(int i = 0; i < strlen(s); i++)
        {
            if(!ch[now][s[i]-'a'])ch[now][s[i]-'a'] = ++cnt;
            now = ch[now][s[i]-'a'];
        }
        val[now] = num;
    }
    void getFail()
    {
        for(int i = 0; i < SIGMA_SIZE; i++)if(ch[0][i])qe.push(ch[0][i]);
        while(!qe.empty())
        {
            int u = qe.front();qe.pop();
            for(int i = 0; i < SIGMA_SIZE; i++)
            {
                if(ch[u][i]){f[ch[u][i]] = ch[f[u]][i];qe.push(ch[u][i]);}
                else ch[u][i] = ch[f[u]][i];
            }
        }
    }
    void find()
    {
        int len = strlen(T), now = 0;
        for(int i = 0; i < len; i++)
        {
            now = ch[now][T[i]-'a'];
            for(int t = now; t; t = f[t]){
                if(val[t]){
                    ans[val[t]]++;
                    if(t!=0)maxx = max(maxx,ans[val[t]]);
                }
            }
        }
    }
}AC;
int n;
int main()
{
    while(scanf("%d", &n) == 1 && n)
    {
        AC.clear();
        for(int i = 1; i <= n; ++i)
            scanf(" %s", p[i]),AC.insert(p[i], i);
        AC.getFail();
        scanf("%s", T);
        AC.find();
        printf("%d\n", maxx);
        for(int i = 1; i <= n; ++i)
            if(ans[i] == maxx)printf("%s\n", p[i]);
    }
    return 0;
}
```

---

## 作者：桑树下的邂逅 (赞：1)

定义一个fail数组（相当于KMP中的next），它代表了如果在当前模式串中失配应该跳到树上的哪一个结点继续匹配。所以fail结点代表的字符串应该是这一个节点代表的字符串的最长后缀。

因为后缀才可以保证fail结点代表的字符串都可以在主串中匹配，而最长后缀可以保证不会落下任何一个可以匹配的模式串

#### Fail指针构造 ####
首先在构造fail指针之前，我们需要先了解它的几个性质。

1. 根的所有子节点的fail都指向根。

2. 在一个节点不断向上跑fail的过程中，节点的深度是不断减小的。

3. 如果a节点的fail指向了b节点，那么a节点的t儿子的fail指向b节点的t儿子。

#### 字符串匹配 ####
 接下来到了AC自动机工作的时候了。

我们用一个字符串，从根节点开始在自动机上匹配，如果当前节点有字符串上下一个字符这个儿子，则转移到这个儿子节点。如果没有，就先转移到当前节点的fail，再查找fail是否有下一个字符的儿子。

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
queue<int>q;
const int maxN=1e6+100;
struct Node{
	int c[maxN][26],val[maxN],fail[maxN],root=0,cnt=0;
	int idx(char c){
		return c-'a';
	}
	void insert(char s[]){
		int now=root,len=strlen(s);
		for(int i=0;i<len;i++){
			int id=idx(s[i]);
			if(!c[now][id]) c[now][id]=++cnt;
			now=c[now][id];
		}
		val[now]++;
	}
	void build(){
		for(int i=0;i<26;i++)if(c[root][i]){
			fail[c[root][i]]=root;q.push(c[root][i]);
		}
		while(!q.empty()){
			int x=q.front();q.pop();
			for(int i=0;i<26;i++)
				if(c[x][i]){
					fail[c[x][i]]=c[fail[x]][i];
					q.push(c[x][i]);
				}else c[x][i]=c[fail[x]][i];
		}
	}
	int query(char s[]){
		int now=root,ans=0,len=strlen(s);
		for(int i=0;i<len;i++){
			int id=idx(s[i]);
			now=c[now][id];
			for(int t=now;t&&val[t]!=-1;t=fail[t]) ans+=val[t],val[t]=-1;
		}
		return ans;
	}
}AC;
int n;
char p[maxN];
int main(){
	freopen("testdata.in","r",stdin);
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%s",p),AC.insert(p);
	AC.build();
	scanf("%s",p);printf("%d\n",AC.query(p));
}
```

---

## 作者：autofish (赞：1)

对于ac自动机的解释都在代码里

```
AC自动机：
给定N个模式串S和一个文本串t，求有多少个不同的模式串在文本串出现过
AC自动机通过fail数组，让trie树中存在但没有数值的虚节点都指向一个为该字母的实节点，这样在与文本串匹配时，能匹配多个模式串：
struct Tree//字典树 
{
     int fail;//失配指针
     int vis[26];//子节点的位置
     int end;//标记有几个单词以这个节点结尾 
}AC[1000000];//Trie树
int cnt=0;//Trie的指针 
inline void Build(string s)
{
        int l=s.length();
        int now=0;//字典树的当前指针 
        for(int i=0;i<l;++i)//构造Trie树
        {
                if(AC[now].vis[s[i]-'a']==0)//Trie树没有这个子节点
                   AC[now].vis[s[i]-'a']=++cnt;//构造出来
                now=AC[now].vis[s[i]-'a'];//向下构造 
        }
        AC[now].end+=1;//标记单词结尾 
}
void Get_fail()//构造fail指针
{
        queue<int> Q;//队列 
        for(int i=0;i<26;++i)//第二层的fail指针提前处理一下
        {
               if(AC[0].vis[i]!=0)
               {
                   AC[AC[0].vis[i]].fail=0;//指向根节点
                   Q.push(AC[0].vis[i]);
				   //压入队列 
               }
        }
        while(!Q.empty())//BFS求fail指针 
        {
              int u=Q.front();
              Q.pop();
              for(int i=0;i<26;++i)//枚举所有子节点
              {
                        if(AC[u].vis[i]!=0)//存在这个子节点
                      {
                                AC[AC[u].vis[i]].fail=AC[AC[u].fail].vis[i];
                                    //子节点的fail指针指向当前节点的
                                  //fail指针所指向的节点的相同子节点 
                                Q.push(AC[u].vis[i]);//压入队列 
                      }
                      else//不存在这个子节点 
                      AC[u].vis[i]=AC[AC[u].fail].vis[i];//比如说1号节点a下面只跟着2号节点b（显性存在节点），那么1号节点下面还有25个实际存在但又不显现出来的虚节点（隐性存在节点）。   比如，如果整个trie树中有一个显性节点的字母为a，那么基本上所有字母是a的虚节点的编号兜兜转转但最终都会等于这个显性节点的编号；如果没有这个字母为a的显性节点，那么所有字母为a的隐性节点的编号兜兜转转最终都会等于根节点；这样我们就可以在匹配一个模式串的时候，同时匹配其他模式串； 
                      //当前节点的这个子节点指向当
                      //前节点fail指针指向的节点的同为这个字母的子节点，这样确保了在匹配时fail指针不会指向没有包含关系的节点
					  //比如模式串为cabdc，ab，db中，如果文本串是cabdc那么假如说匹配到b时，第一个模式串的b可以fail指针跳到ab的b（也就是同时把ab的b给匹配了，因为之前已经把a给匹配了，所以这时候就把ab匹配了），但是不会跳到db的b（不能匹配db），因为db，cabde没有包含关系，cabde中a的fail指针并不会指向d，所以cabde的b就不会指向db中b。 
              }
        }
}
int AC_Query(string s)//AC自动机匹配
{
        int l=s.length();
        int now=0,ans=0;
        for(int i=0;i<l;++i)
        {
                now=AC[now].vis[s[i]-'a'];//向下一层
                for(int t=now;t&&AC[t].end!=-1;t=AC[t].fail)//匹配其他一个字符串的同时，把其他字符串也匹配了； 
                {
                	//一个字母一个字母的匹配 
                         ans+=AC[t].end;//如果是单词节点就+1，不是就会加+0； 
                         AC[t].end=-1;//证明过这个单词已经匹配过了，就不用再次匹配； 
                } 
        }
        return ans;
}
int main() 
{
     int n;
     string s;
     cin>>n;
     for(int i=1;i<=n;++i)
     {
             cin>>s;
             Build(s);
     }
     AC[0].fail=0;//结束标志 
     Get_fail();//求出失配指针
     cin>>s;//文本串 
     cout<<AC_Query(s)<<endl;
     return 0;
}


难题：阿狸的打字机
/*阿狸的打字机：
思路：1.每输入一个单词就在trie树上新建一个节点；
	  2.每输入一个‘b'就回溯到父亲节点但不删除当前节点（因为后面要用）；
	  3.每输入一个’p‘就可以视为当前节点是一个单词节点；
	  4.通过观察我们可以发现 y串（文本串：被对比那个） 如果有一个y串节点的fail指针指向x串的最后的一个节点（x串的最后一个单词节点），那么x串一定是y串的子串；有n个y串的节点fail指针指向x串最后一个节点，就有x串就在y串出现n次；
	  5.所以我们建立一个fail树，把所有fail指针反向；在fail树中，让x串的末尾节点成为根，寻找有多少个属于y串的节点是x串的子树（因为fail指针反向了所以x变成了老大，相当于从属于y的m节点指向x的末尾节点变成x的末尾节点指向属于y的那个m节点）
	  6.问题从有多少个y串的节点的fail指针指向x的末尾节点变成了在fail树中有多少个属于y的节点在x的子树中；
	  9.用树状数组维护
	  注意trie树的节点附带的所有信息都会在fail树上附带。它们是不同的树的形态但是它们的节点是互通的； 
	  */



#include<bits/stdc++.h>
using namespace std;
const int mx = 1e5+10;
int n;
struct TR{//trie树 
	int vis[27],fail,fa;
}ac[mx];

int p = 1;//p就是trie树的大小，相当于size 

struct edge{//边 
	int to,next;
}road[mx];

struct query{
	int x,y;
};
int last[mx],cnt;

void add(int u ,int v){//存fail树的图 
	cnt++;
	road[cnt].to = v;
	road[cnt].next = last[u];
	last[u] = cnt;
}

int tree[mx];//树状数组 
int lowbit(int x){
	return x&(-x);
}
void update(int x,int k){//树状数组更新 
	while(x < mx){
		tree[x] +=k;
		x += lowbit(x);
	}
}
int sum(int x){//树状数组求和 
	int ans = 0;
	while(x>0){
		ans += tree[x];
		x -= lowbit(x);
	}
	return ans;
}

char word[mx],a[mx];
int q[mx],cur = 0 ,ret = 0;
void insert(char *s,int root){//root就是指当前节点（以当前节点为根的意思） 
	for(int i = 0 ; s[i];i++){
		if(s[i] == 'P'){
			q[++ret] = root;//ret记录有多少个P操作，并记录第x个p操作对应的是那个节点； （那个节点相当于被标记为单词节点） 
		}
		else{
			if(s[i] == 'B'){
				root = ac[root].fa;//如果是b操作就让root指针指回当前节点的父亲； 
			}
			else{//不然的话就新建节点 
				int now = s[i]-'a';
				if(ac[root].vis[now] == 0){
					ac[root].vis[now] = p;
					ac[p].fa = root;
					p++;
				}
				root = ac[root].vis[now];
			}
		}
	}
}

void build(){//建立fail指针；bfs遍历 
	queue<int> que;
	for(int i = 0 ; i <26 ; i++){
		if(ac[0].vis[i]!=0){
			ac[ac[0].vis[i]].fail = 0;
			que.push(ac[0].vis[i]);
		}
	}
	while(!que.empty()){
		int top = que.front();que.pop();
		for(int i = 0 ; i< 26; i++){
			int v = ac[top].vis[i];
			if(v!=0){
				ac[v].fail = ac[ac[top].fail].vis[i];
				que.push(ac[top].vis[i]);
			}
			else{
				ac[top].vis[i] = ac[ac[top].fail].vis[i];//虚节点 
			}
			
		}
	}
}

int dfn[mx],tim = 0,r[mx];//tim == time，时间戳 

void dfs(int now){
	dfn[now] = ++tim;
	for(int i = last[now];i ; i = road[i].next){//遍历一遍fail图 
		int go = road[i].to;
		dfs(go);
	}
	r[now] = tim; //回溯的时候，把回溯途中的所有的节点的r[i]都标记为当前节点的子树的最左边的叶子节点； 
}

int tot[mx];
int ans[mx];

int main(){
	scanf("%s",word);
	insert(word,0);
	build();
	vector<int> askx[mx];//2维数组 
	vector<int> asky[mx];
	for(int i = 1; i < p ; i ++){
		add(ac[i].fail,i);//建立fail树 
	}
	dfs(0);//dfs fail树 
	int root = 0 ;
	scanf("%d",&n);
	for(int i = 0 ; i < n ; i++){
		int x,y;
		scanf("%d%d",&x,&y);
		askx[y].push_back(x);//比如我要查询，第一次打印的串在第三次打印的串出现了多少次，第2次打印的串在第三次打印的串中出现了多少次；那么就把x=1,x=2都存进y=3的动态数组里（记住aks数组是个2维数组），这样就合并了问题，更快了 
		asky[y].push_back(i);//这个询问是第几个提出的；（因为ans的数组要按顺序输出，但是我们计算第x个串在第y个串出现多少次的时候，是按y=1，y=2，y=3......的顺序来的 
	}
	update(dfn[0],1);
	ret = 0;
	for(int i = 0 ; word[i] ; i ++){
		if(word[i] == 'P'){
			ret ++ ;//举栗子，当ret==1时，看看aksx[ret]里有多少个询问（即for循环里的j<askx[ret].size() )，就是看看有多少个关于“第x个打印的串在第一个打印的串里出现多少次”的询问，并且用到下面的for循环里 
			for(int j = 0; j < askx[ret].size(); j++){ 
				int num = q[askx[ret][j]];
				ans[asky[ret][j]] = sum(r[num]) - sum(dfn[num]-1); //树状数组中x串末尾节点从DFS序中的起始位置到结束位置的和
			}
		}
		else if(word[i] == 'B'){
			update(dfn[root],-1);//
			root = ac[root].fa;
		}
		else{
			root = ac[root].vis[word[i]-'a'];
			update(dfn[root],1);
		}
	}
	for(int i = 0 ; i < n ; i ++){
		printf("%d\n",ans[i]);
	}
	return 0;
}
```



---

## 作者：ljh736731592 (赞：1)

# 简介
	

> AC自动机，全称Aho-Corasick自动机，适用于存在多个模板串的字符串匹配问题，如果没有AC自动机，你可能需要对n个模板串分别求一趟KMP，但是复杂度过高，而AC自动机可以一次匹配，效率更优秀。
> 																																								——百度百科

# 实现
KMP是在字符串上线性匹配，而AC自动机则在字符串的集合上匹配，什么东西可以把一大堆字符串吧、放一起存储？Trie!所以AC自动机其实就是在Trie上生成KMP的失配函数。

对于一棵建好的Trie，接下来就是类似于KMP的失配函数的构造，这里要一层一层的构造，所以需要用BFS来遍历。其他大致相同，这里还有一点，当找到了某个单词后，可能找到其他的单词。例如找到his后有is，所以还要构造一个lst数组表示如果按照失配函数继续走时最近的一个单词编号，用于提高效率（蓝书上提到这个lst数组在正规文献内叫做后缀链接）。

# 模板
[模板](https://www.luogu.org/problem/P3808)

求模板串出现了几个（不能算重）

```cpp
#pragma GCC target("sse,sse2,sse3,sse4.1,sse4.2,popcnt,abm,mmx,avx")
#pragma comment(linker,"/STACK:102400000,102400000")
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-funroll-loops")
#pragma GCC optimize("-fwhole-program")
#pragma GCC optimize("-freorder-blocks")
#pragma GCC optimize("-fschedule-insns")
#pragma GCC optimize("inline-functions")
#pragma GCC optimize("-ftree-tail-merge")
#pragma GCC optimize("-fschedule-insns2")
#pragma GCC optimize("-fstrict-aliasing")
#pragma GCC optimize("-fstrict-overflow")
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-fcse-skip-blocks")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("inline-small-functions")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("-funsafe-loop-optimizations")
#pragma GCC optimize("inline-functions-called-once")
#pragma GCC optimize("-fdelete-null-pointer-checks")
#include<bits/stdc++.h>
using namespace std;
struct Tree//字典树 
{
     int fail;//失配指针
     int vis[26];//子节点的位置
     int end;//标记有几个单词以这个节点结尾 
}AC[1000000];//Trie树
int cnt=0;//Trie的指针 
inline void Build(string s)
{
        int l=s.length();
        int now=0;//字典树的当前指针 
        for(int i=0;i<l;++i)//构造Trie树
        {
                if(AC[now].vis[s[i]-'a']==0)//Trie树没有这个子节点
                   AC[now].vis[s[i]-'a']=++cnt;//构造出来
                now=AC[now].vis[s[i]-'a'];//向下构造 
        }
        AC[now].end+=1;//标记单词结尾 
}
void Get_fail()//构造fail指针
{
        queue<int> Q;//队列 
        for(int i=0;i<26;++i)//第二层的fail指针提前处理一下
        {
               if(AC[0].vis[i]!=0)
               {
                   AC[AC[0].vis[i]].fail=0;//指向根节点
                   Q.push(AC[0].vis[i]);//压入队列 
               }
        }
        while(!Q.empty())//BFS求fail指针 
        {
              int u=Q.front();
              Q.pop();
              for(int i=0;i<26;++i)//枚举所有子节点
              {
                        if(AC[u].vis[i]!=0)//存在这个子节点
                      {
                                AC[AC[u].vis[i]].fail=AC[AC[u].fail].vis[i];
                                    //子节点的fail指针指向当前节点的
                                  //fail指针所指向的节点的相同子节点 
                                Q.push(AC[u].vis[i]);//压入队列 
                      }
                      else//不存在这个子节点 
                      AC[u].vis[i]=AC[AC[u].fail].vis[i];
                      //当前节点的这个子节点指向当
                      //前节点fail指针的这个子节点 
              }
        }
}
int AC_Query(string s)//AC自动机匹配
{
        int l=s.length();
        int now=0,ans=0;
        for(int i=0;i<l;++i)
        {
                now=AC[now].vis[s[i]-'a'];//向下一层
                for(int t=now;t&&AC[t].end!=-1;t=AC[t].fail)//循环求解
                {
                         ans+=AC[t].end;
                         AC[t].end=-1;
                } 
        }
        return ans;
}
int main()
{
     int n;
     string s;
     cin>>n;
     for(int i=1;i<=n;++i)
     {
             cin>>s;
             Build(s);
     }
     AC[0].fail=0;//结束标志 
     Get_fail();//求出失配指针
     cin>>s;//文本串 
     cout<<AC_Query(s)<<endl;
     return 0;
}



```




---

## 作者：老番茄酱 (赞：0)

[~~<font size=1>博客广告，和博客一起食用更佳</font>~~](https://blog.csdn.net/weixin_45740176/article/details/104865655)
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct Trie_Tree{
    ll fail;
    ll child[27];//每父节点下的子节点有26个（26个字母）※child[]表示当前访问的节点 
    ll end;//标记有几个单词以这个节点结尾
}ac[1000000 + 10];
ll cnt = 0;//Trie的指针
inline void Build(string mushichuan){//建树 
    ll l = mushichuan.length();
    ll now = 0;//访问字典树的当前位置 
    for(ll i = 0; i < l; i++){//构造Trie树
        if(ac[now].child[mushichuan[i] - 'a'] == 0)//树没这个节点， s[i] - 'a' 把对应的字母变成数字 
            ac[now].child[mushichuan[i] - 'a'] = ++cnt;//如 "A B C" 需要构造三层，每一层都事先把 a~z 26个字母打好 
            now = ac[now].child[mushichuan[i] - 'a'];//往下递归
    }//最后跳出循环需把单词结尾标记一下 
    ac[now].end++;
}
void get_fail(){//构造fail指针
    queue <ll> q;
    for(ll i = 0; i <= 26; i++){//初始条件 
        if(ac[0].child[i] != 0){//构造了此节点, ac[0] 表示根节点 
            ac[ac[0].child[i]].fail = 0;//先把所有的第二层节点都指向根节点
            q.push(ac[0].child[i]);//把根节点的子节点 push 进 queue 中     
        }
    }
    while(!q.empty()){//bfs求每一相同的字符串，再将fail指针指向相同字符串的子节点 
        ll father = q.front();
        q.pop();
        for(ll i = 0; i < 26; i++){
            if(ac[father].child[i] != 0){//父节点下存在子节点
                ac[ac[father].child[i]].fail = ac[ac[father].fail].child[i];//看图解
                q.push(ac[father].child[i]);//像第一层把父节点的子节点 push 进 queue 中
            }
            else//父节点下不存在子节点
                ac[father].child[i] = ac[ac[father].fail].child[i];//虚根（看图解） 
        }
    }
}
ll AC_COUT(string wenbenchuan){//自动AC机的匹配
    ll l = wenbenchuan.length();
    ll now = 0, ans = 0;//now = 0 先从根结点出发 
    for(ll i = 0; i< l; i++){
        now = ac[now].child[wenbenchuan[i] - 'a'];//向下走, s[i] - 'a' 把对应的字母变成数字 
        for(ll next = now; next && ac[next].end != -1; next = ac[next].fail){//下一个节点没有 || 没有访问过， 循环求解
            ans += ac[next].end;//计算单词节点（看图解） 
            ac[next].end = -1;//与上方对应，就不会重复使用 
        }
    }
    return ans; 
}
int main(){
    ll n;
    string mushichuan, wenbenchuan;
    cin >> n;
    for(ll i = 1; i <= n; i++){
        cin >> mushichuan;
        Build(mushichuan);//建树
    }
    ac[0].fail = 0;//根节点的 fail 指针指向 0（结束标志）
    get_fail();//构造fail指针
    cin >> wenbenchuan;
    cout << AC_COUT(wenbenchuan) << endl;
    return 0;
}
```

//by初音ミク

---

## 作者：abandentsky (赞：0)

题意：说的很清楚，多模板字符串匹配。就是AC自动机了。
做法：将所有的匹配串构造成一个字典树，然后呢就是在字典树上构造fail指针，然后就是匹配了。
最重要的是这个数据太水了，我刚开始参照刘汝佳大神的书写了一个AC自动机，
Wrong了，测试后发现用val数组标记时，访问完后要归零。
**这个题目测试数据没有后缀数据，比如：xiaomi aomi mi**对于这组匹配数据，我们把文本串设置为xiaomi，正确答案是3，（按照白书中所说，我们在找到一个串的时候还应该顺着失配边回去看看）。但是我在没用last数组（后缀连接）的情况下也过了这个题目。
**贴个AC自动机模板上来**
```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 1000005
#define maxnode 1000005
#define sigma_size 26
#define mod 1000000007
#define INF 0x3f3f3f3f
using namespace std;

int f[maxnode];
int ch[maxnode][sigma_size];
int val[maxnode],last[maxnode];
int sz,n,ans;
char str[MAXN];

int idx(char c)
{
    return c-'a';
}

void Insert(char *s)
{
    int u=0;
    int len=strlen(s);
    for(int i=0;i<len;i++)
    {
        int c=idx(s[i]);
        if(!ch[u][c])
        {
            memset(ch[sz],0,sizeof(ch[sz]));
            val[sz]=0;
            ch[u][c]=sz++;
        }
        u=ch[u][c];
    }
    val[u]++;
}

void  getfail()
{
    queue<int> Q;
    f[0]=0;
    for(int i=0;i<sigma_size;i++)
    {
       int u=ch[0][i];
       if(u)
        {
             Q.push(u);
             f[u]=0;
             last[u]=0;
          }
    }
    while(!Q.empty())
    {
        int r=Q.front();
        Q.pop();
        for(int i=0;i<sigma_size;i++)
        {
            int  u=ch[r][i];
            if(!u)
                continue;
            Q.push(u);
            int v=f[r];
            while(v&&!ch[v][i])
                v=f[v];
            f[u]=ch[v][i];
            last[u]=val[f[u]]?f[u]:last[f[u]];
        }
    }
}

void print(int j)
{
    if(j)
    {
        ans+=val[j];
        val[j]=0;
        print(last[j]);
    }
}

void Find(char *T)
{
    int len=strlen(T);
    int j=0;
    for(int i=0;i<len;i++)
    {
        int c=idx(T[i]);
        while(j&&!ch[j][c])
            j=f[j];
        j=ch[j][c];
        if(val[j])
        {
            print(j);
        }
        else if(last[j])
            print(last[j]);
    }
}

int main()
{
    scanf("%d",&n);
    sz=1,ans=0;
    memset(ch[0],0,sizeof(ch[0]));
    for(int i=0;i<n;i++)
    {
        scanf("%s",str);
        Insert(str);
    }
    getfail();
    scanf("%s",str);
    Find(str);
    printf("%d\n",ans);
    return 0;
}

```


---


# [CCO 2014] Troy 与三角形

## 题目描述

**本题译自 [CCO 2014](https://cemc.math.uwaterloo.ca/contests/computing/2014/index.html) Day1 T1「[Troyangles](https://cemc.math.uwaterloo.ca/contests/computing/2014/Stage%202/day1.pdf)」**

Troy 喜欢三角形，所以他也特别喜欢数三角形。他有一个由 `.` 和 `#` 组成的 $N\times N$ 的网格。帮他数数在网格中仅由 `#` 组成的三角的个数。三角形表示为如下形式：
```plain
          #
    #    ###
#, ###, #####, ...
```
更加形式化地说，一个高度为 $h$，有 $h$ 列的三角形，其中 $h$ 为正整数，第 $i$ 行有 $2i-1(1\le i \le h)$ 个 `#`，行在彼此上方居中，所以它们是关于它们的垂直中线对称的。

## 说明/提示

对于 $20\%$ 的数据，$1\le N\le 50$；

对于 $100\%$ 的数据，$1\le N \le 2000$。

## 样例 #1

### 输入

```
5
.....
.###.
.###.
#####
.....```

### 输出

```
16```

# 题解

## 作者：localhost (赞：4)

记录$up[i][j]$表示位置$(i,j)$可以向上多少个`#`

$s[i][j]$表示位置$(i,j)$作为三角形中心可以向左多少个`#`

$S[i][j]$表示位置$(i,j)$作为三角形中心可以向右多少个`#`

$ans = \sum_{i=1}^n\sum_{j=1}^n \min(s[i][j],S[i][j])$

```cpp
#include<bits/stdc++.h>
namespace ZDY{
    #pragma GCC optimize(3)
    #define il __inline__ __attribute__ ((always_inline))
    #define rg register
    #define ll long long
    #define ull unsigned long long
    #define db double
    #define sht short
    #define MB template <class T>il
    #define Fur(i,x,y) for(int i=x;i<=y;++i)
    #define Fdr(i,x,y) for(int i=x;i>=y;--i)
    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)
    #define clr(x,y) memset(x,y,sizeof(x))
    #define cpy(x,y) memcpy(x,y,sizeof(x))
    #define fin(s) freopen(s".in","r",stdin)
    #define fout(s) freopen(s".out","w",stdout)
    #define fcin ios::sync_with_stdio(false)
    #define l2(n) ((int)(log2(n)))
    #define inf 0x3f3f3f3f
    MB T ABS(T x){return x>0?x:-x;}
    MB T MAX(T x,T y){return x>y?x:y;}
    MB T MIN(T x,T y){return x<y?x:y;}
    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}
    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}
}using namespace ZDY;using namespace std;
namespace IO{const char* ln="\n";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;
#define N 2011
int n,up[N][N],s[N][N],S[N][N];
char ch[N][N];
bool b[N][N];
int main(){
    in>>n;
    Fur(i,1,n)in>>(ch[i]+1);
    Fur(i,1,n)
        Fur(j,1,n)
        b[i][j]=(ch[i][j]=='#');
    Fur(i,1,n)
        Fur(j,1,n)
        if(b[i][j])up[i][j]=up[i-1][j]+1;
    
    Fur(i,1,n)
        Fur(j,1,n)
        if(b[i][j])s[i][j]=MIN(up[i][j],s[i][j-1]+1);

    Fur(i,1,n)
        Fdr(j,n,1)
        if(b[i][j])S[i][j]=MIN(up[i][j],S[i][j+1]+1);
    
    ll ans=0;
    Fur(i,1,n)Fur(j,1,n)if(b[i][j])ans+=MIN(s[i][j],S[i][j]);
    out<<ans<<ln;
}
```

---

## 作者：QwQcOrZ (赞：2)

# 本题第一个AC

楼下的@Bear_Dog_Cat还放了我的AC记录qwq

这题需要一种特殊的算~~wei~~法

出去吃了点东西，顺带想了这道题。

~~本题解中所有的答案都存储在ans中~~

**对于61%的数据：**

$\color{red}\text{直接暴力枚举}$

两重循环枚举三角形的最上方的顶点，然后不停向下拓展，每拓展一层就检查一遍有没有 “.” 。有则退出，无则++。

核心代码：

```cpp
for (int i=1;i<=n;i++)
for (int j=1;j<=n;j++)
{
	k=0;
	while (judge(i+k,j-k,j+k))//其中judge为判断a[i+k][j-k~j+k]中有无“.”(for查找)
	{
		k++;
		ans++;
		if (j+k>n||j-k<1||i+k>n) break;
	}
}
```

时间复杂度为：Θ(n^4)

------------

**对于79%的数据：**

$\color{red}\text{用一维前缀和优化}$

先做前缀和的预处理，两重循环枚举三角形的最上方的顶点，然后不停向下拓展，每拓展一层就用前缀和查询这个范围内的“#”是不是等于这个范围内的数的个数。否则退出，是则++。

核心代码：

```cpp
for (int i=1;i<=n;i++)
for (int j=1;j<=n;j++)
{
	k=i;
	l=1;
	while (a[k][j+(k-i)]-a[k][j-(k-i)-1]==l)//其中a[i][j]为a[i][1~j]中“#”的个数
	{
		k++;//行++
		l+=2;//应有的“#”的个数
		ans++;
		if (j+k>n||j-k<1||i+k>n) break;
	}
}
```

时间复杂度为：Θ(n^3)

------------

**对于100%的数据：**

$\color{red}\text{用玄学剪枝加一维前缀和优化}$

（此题解中高指平行于坐标轴的高，底指平行于坐标轴的底）

观察数据范围，很显然我们需要一个时间复杂度为Θ(n^2)的算法。

First，我们的思路要有所转变。

不能枚举三角形最上方的顶点，再枚举底，因为确定了最上方的顶点后可以有多个底。

所以我们要枚举底，来确定唯一的顶点。

看到这里一些同学可能会很茫然：

“什么？那怎么确定这个三角形中没有‘.’呢？再说底的长度枚举一下不是很费时间的吗？”

别急，这里我们只枚举底的中点。

至于底的长度，我们可以知道~~三大定律~~：

- 一定是奇数（不然就成梯形了）

- 确定三角形的范围内一定都是“#”

- 最长只有上一行最长的底+2（上一行已经是最优解了，再大上面就到边境或者有“.”出现了，而+2就是最优解的最大拓展，同时这样也能保证除了此行上面全是“#”）

由此可得：

1. 枚举底的中点所在的列（i:1->n）

2. 枚举底的中点所在的行（j:1->n）

3. 底的半长度+2（l:l++（l指的是底的中点加上底的右半部分的长度，便于操作））

4. 如果这条底中有不和谐的东西（“.”）就让底不断-2（l--）,直到看不见这东西（就像刚才的缩放区间）

5. ans+=l（既然最长的底可以构成三角形，那么比他小的底所代表的三角形肯定都是一个解）

```
..#.#
#####
#####
.###.
.###.
```

模拟一下上面的数据。

现在只计算以第3列为高（也就是底的中点所在的列为第3列）的三角形。

（为了防止l与1混淆，这里的l用大写来表示）

- 首先是初值，i已经枚举到了5，L=0，ans=0（假设前面什么都没有）

- 第1次操作时：j=1;L++（L:0+1=1）;∵其中没有“.” ∴L不变(L:1);ans+=L（ans:0+1=1）

- 第2次操作时：j=2;L++（L:1+1=2）;∵其中没有“.” ∴L不变(L:2);ans+=L（ans:1+2=3）

- 第3次操作时：j=3;L++（L:2+1=3）;∵其中没有“.” ∴L不变(L:3);ans+=L（ans:3+3=6）

- 第4次操作时：j=4;L++（L:3+1=4）;∵其中有“.”且越界 ∴while(…)L--(L:2);ans+=L（ans:6+2=8）

- 第5次操作时：j=5;L++（L:2+1=3）;∵其中有“.” ∴while()L--(L:2);ans+=L（ans:8+2=10）

![表格](https://cdn.luogu.com.cn/upload/pic/49986.png)

简单的讲：

一重循环枚举三角形的底的中点所在的列，然后枚举底的中点所在的行，每拓展一层就使三角形的宽度+2（l++），在这个范围内“#”的个数小于等于应有的个数时就一直使三角形的宽度-2（l--），最后答案加上现在底的个数（(底的长度+1)/2）。

代码：

```cpp
for (int j=1;j<=n;j++)
for (int k=0,i=1;i<=n;i++)//这里k就是上面的l
{
	k++;
	while (a[i][j+k-1]-a[i][j-k]<k*2-1&&k>0) k--;
	ans+=k;
}
```

时间复杂度为：Θ(n^2+n) //+n几乎可以忽略

~~自认为讲的十分清楚了qwq~~

------------

~~通知：楼下的俩题解是同一个人的俩号qwq~~

---

## 作者：离散小波变换° (赞：1)

## 题解

记大小为 $k$ 的符合题意的三角形为 $k$ 阶三角形。现在考虑以 $(x,y)$ 作为上顶点的三角形。考虑如下事实；

- 首先 $(x,y)$ 这个位置肯定得是个 $\verb!#!$，不然就一定不是一个三角形的上顶点了。
- 如果 $(x,y)$ 可以作为 $k$ 阶三角形的上顶点，那么它同样可以作为 $1\sim (k-1)$ 任意一阶三角形的上顶点。
- 如果 $(x,y)$ 可以作为 $k$ 阶三角形的上顶点，那么 $(x+1,y-1),(x+1,y),(x+1,y+1)$ 都可以作为 $k-1$ 阶三角形的顶点。

于是，记 $F_{x,y}$ 表示 $(x,y)$ 这个点最多可以作为哪一阶三角形的上顶点。有如下状态转移方程：

$$
F_{x,y}=\begin{cases}
0 & S_{x,y}=\verb!.! \cr
1+\min\{F_{x+1,y-1},F_{x+1,y},F_{x+1,y+1}\} & S_{x,y}=\verb!#!
\end{cases}
$$

从最后一行开始向上转移就行了。最终答案显然就是 $\sum F_{i,j}$。时间复杂度 $\mathcal O(n^2)$。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int MAXN=2e3+3;
char S[MAXN][MAXN]; int n,F[MAXN][MAXN]; i64 ans;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int main(){
    n=qread(); up(1,n,i) scanf("%s",S[i]+1);
    dn(n,1,i){
        up(1,n,j) if(S[i][j]=='#')
            F[i][j]=1+min({F[i+1][j],F[i+1][j-1],F[i+1][j+1]}),
            ans+=F[i][j];
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：w23c3c3 (赞：1)

其他题解都挺好的，比我的简单

~~但是方法不是很一样就来水一发（?~~

很容易想到枚举中心（其实应该是底边的中点），判断能扩出多少个三角形

但是这个显然是$O(n^4)$的

预处理出一个 `#` 斜向左下、斜向右下就可以做到$O(n^3)$

提供一个类似Manacher的想法

比如说我们已经找到了中心在$(i,j)$最大的三角形，底边长的一半为$t_{i,j}$（红色三角形）

我们希望求出$(i,j+1)$（绿色点）能扩展的三角形数量

![](https://cdn.luogu.com.cn/upload/image_hosting/oujubn30.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

那么显然，绿色点的$t_{i,j+1}$必然不小于$max(t_{i,j}-1,0)$

证明：~~显然~~

因为图中绿色三角形必然也全都是`#`

![](https://cdn.luogu.com.cn/upload/image_hosting/bovyry4s.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

所以直接从$max(t_{i,j}-1,0)$开始枚举，预处理出 `#` 斜向左下、斜向右下，判断能否扩展就可以了

复杂度$O(n^2)$

实测：代码简洁但被吊打

先贴代码再证时间复杂度

我写的是预处理出一个点向左上和左下的 `#` 数量不过差别不大

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int n,f[2003][2003],g[2003][2003],i,j,ans,t;
char s[2003][2003];
int main(){
	scanf("%d",&n);
	for(i=1;i<=n;i++)cin>>s[i]+1;
	for(i=1;i<=n;i++)for(j=1;j<=n;j++)if(s[i][j]=='#')f[i][j]=f[i-1][j-1]+1;
	for(i=n;i>=1;i--)for(j=1;j<=n;j++)if(s[i][j]=='#')g[i][j]=g[i+1][j-1]+1;
	for(i=1;i<=n;i++){
		if(s[i][1]=='#')t=1,ans++;
		for(j=2;j<=n;j++){
			t=max(t-1,0);
			while(i>t&&j>t)if(g[i-t][j]>t&&f[i][j+t]>t)t++;else break;
			ans+=t;
		}
	}
	printf("%d\n",ans);
}
```

~~撒花+谢幕~~

关于它的时间复杂度：

我们观察每一行三角形的右端点，显然，他只会不动或者越来越往右

这个算法的瓶颈在循环中间的while循环，而while每跑进一次，右端点就会向右移动一格，而右端点在每一行最多移动$n$格，所以是$O(n^2)$的

---

## 作者：lefthand166 (赞：0)

# 解法
对于一个三角形如下：
```
..#..  
.###.
#####
```
- 我们把最底下边的中点设为 $A$，此时我们假定如果 $A$ 再扩大将不满足上述三角形的定义，即这时已经是以 $A$ 为底边中点的最大三角形，设最底下有 $k$ 个`#`，求这里面有多少个以 $A$ 为底边中点且满足条件的三角形。答案很显然是 $\frac{k + 1}{2}$ 个，因为任何底边长度小于 $k$ 的都是符合条件的三角形。  
- 因此，我们可知上述所说的三角形所依赖的只是一个 $A$ ，因此我们要求出所有点的 $k_{i,j}$，最终答案一定就是 $\sum_{i = 1}^{n} \sum_{j = 1}^{n} \frac{k_{i,j} + 1}{2}$。
- 下面，求 $k$ 值可以考虑dp。设 $f[i][j]$ 是 $(i, j)$ 的 $k$。根据观察可知，假设以 $(i,j)$ 为中心左右均等扩展可扩展总共 $l$ 格，设 $f[i - 1][j] = r$，可知当 $l \ge r + 2$ 时，此时 $(i,j)$ 的上限就是 $r + 2$；反之，则是 $l$。
# AC代码如下
~~~cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e3 + 10;
char a[maxn][maxn];
int l[maxn][maxn], r[maxn][maxn];
int f[maxn][maxn];
int main() {
    // f = -1 意味着这个地方并没有#
    // 这样可使的下方的点可从 1 开始更新
    memset(f, -1, sizeof f);
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> a[i][j];
        }
    }
    //用于获取这个点的左右两边包括自己各有多少个 #
    for (int i = 1; i <= n; i++) 
        for (int j = 1; j <= n; j++) 
            if (a[i][j] == '#') l[i][j] = l[i][j - 1] + 1;
            else l[i][j] = 0;
    for (int i = 1; i <= n; i++) 
        for (int j = n; j >= 1; j--) 
            if (a[i][j] == '#') r[i][j] = r[i][j + 1] + 1;
            else r[i][j] = 0;
    long long ans = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            int k = f[i - 1][j];
            if (a[i][j] == '.') continue;
            int t = min(r[i][j], l[i][j]) * 2 - 1;
            f[i][j] = min(t, k + 2);
            ans += (f[i][j] + 1) / 2;
        }
    }
    cout << ans << '\n';
}
~~~

---

## 作者：CatFromMars (赞：0)

容易想到一个暴力：枚举每一个上顶点，再枚举最多能往下拓展 $x$ 层。那么以此为上定点的三角形就有 $x$ 个了。每一层都做一个前缀和可以 $O(1)$ 判定某一层某一区间是否全是 ```#```，所以时间复杂度 $O(n^3)$。

考虑优化，发现问题在于枚举每一层的过程中会产生太多重复计数。结合一点简单的悬线法思想我们可以想到 dp：设 $f_{i, j}$ 为以 $(i, j)$ 为顶点最多可以往下多少层。

- $(i, j)$ 是 ```.```，那么 $f_{i, j} = 0$。
- $(i, j)$ 是 ```#```，那么 $f_{i, j} = \min\{f_{i+1, j - 1}, f_{i+1, j}, f_{i+1, j + 1}\} = 1$。

答案就是 $\sum\limits_{i = 1}^n \sum\limits_{j = 1}^n f_{i, j}$。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 2000, M = 2000;
int f[N + 10][N + 10], a[N + 10][N + 10], n, m;
int main() {
	cin >> n; m = n;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++) {
			char ch; cin >> ch;
			a[i][j] = (ch == '#');
		}

	for(int i = 1; i <= m; i++)
		if(a[n][i]) f[n][i] = 1;
	for(int i = n - 1; i >= 1; i--)
		for(int j = 1; j <= m; j++)
			if(a[i][j] == 1) f[i][j] = min(f[i + 1][j - 1], min(f[i + 1][j], f[i + 1][j + 1])) + 1;
			else f[i][j] = 0;
	ll sum = 0;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			sum += 1ll * f[i][j];
	cout << sum << endl;
}
```

---

## 作者：Kent999 (赞：0)

[传送门](https://www.luogu.com.cn/problem/P4813)

读完题，先考虑如何进行暴力。

最简单的暴力是枚举三角形顶点的位置，并暴力判断这个顶点下面有多少个三角形。

这个算法应该是 $O(n^4)$ 。

很不能通过，考虑如何进行优化。

回忆刚刚的过程，我们在判断一个顶点下面有多少个三角形时有大量的重复的判断。

比如，在下面样例中。（以下 `*` 表示被判断过的点）
```
.....
.###.
.###.
#####
.....
```
当我们枚举 $(3,2)$ 作为顶点时，我们判断了以下点：
```
.....
.#*#.
.***.
*****
.....
```
当我们枚举 $(4,2)$ ，$(4,3)$ 和 $(4,4)$ 时分别判断了这些点：
```
.....
.###.
.*##.
***##
.....

.....
.###.
.#*#.
#***#
.....

.....
.###.
.##*.
##***
.....
```
考虑优化掉这些重复的判断部分。

我们定义 $p_{i,j}$ 为以 $(i,j)$ 为顶点的三角形个数。

考虑进行递推，可以推出转移方程式如下：

$p_{i,j} = \min(p_{i+1,j-1} , p_{i+1,j} , p_{i+1,j+1}) + 1$

那么最后答案就是 $p$ 数组的和了。

具体的细节看代码。
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int n,p[2005][2005];
char s[2005][2005];
ll res;//记得开long long
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%s",s[i]+1);
	for(int i=1;i<=n;i++)
		if(s[n][i]=='#')
			p[n][i]=1;//初始化最后一行
	for(int i=n-1;i>=1;i--)
		for(int j=1;j<=n;j++)
			if(s[i][j]=='#')
				p[i][j]=min(p[i+1][j-1],min(p[i+1][j],p[i+1][j+1]))+1;
				//如果j-1或j+1超出范围，那么这样算出来p[i][j]为1，所以不需要特判
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			res+=p[i][j];
	printf("%lld\n",res);
	return 0;
} 
```

---

## 作者：xkcdjerry (赞：0)

首先考虑暴力做法：  
枚举每一个三角形底边中点，然后向两边扩展，底边中点坐标是 $(i,j)$ 时，存在两个限制条件：  
* 如存在另外一个点坐标是 $(i,k)$ 且上面有高度为 $v$ 的一列 `#`，那么最多存在高为 $|k-j|+v$ 的三角形
* 最多存在高为 $\min(j,n-j+1)$ 的三角形（否则会戳出左边或者右边）

由于如果对于一个点可以拓展出的最大三角形高为 $h$，那么显然可以拓展出 $h$ 个不同的三角形（高度为 $1 \sim h$）。  
显然，这个代码的复杂度是 $O(n^4)$ 的（枚举点 $O(n^2)$ ，拓展 $n$ 次 $O(n^2)$），但是可以通过递推提前处理出每个点上方有多少个点把复杂度压到 $O(n^3)$。  

79 分代码关键片段如下：  
```c++
for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
        if(a[i][j]=='#') up[i][j]=1+up[i-1][j];
        else up[i][j]=0;
int ans=0;
for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    {
        //最大的可能三角形
        int mx=min(j,n-j+1);
        int l=j,r=j;
        //由于j-l>=mx或r-j>=mx之后不可能更新答案，所以直接剪掉
        while(l>=1&&j-l<mx)
        {
            mx=min(mx,up[i][l]+(j-l));
            l--;
        }
        while(r<=n&&r-j<mx)
        {
            mx=min(mx,up[i][r]+(r-j));
            r++;
        }
        ans+=mx;
    }
```
那么怎么优化到 100 分代码呢？观察循环里只是在求
 $$\min\{up_{i,l}+(j-l)\}$$ 
 $$\min\{up_{i,r}+(r-j)\}$$
可以解包成
 $$\min\{up_{i,l}-l\}+j$$
 $$\min\{up_{i,r}+r\}-j$$
由于 $\min\{\}$ 内部除了循环变量的范围均与 $j$ 无关，可以考虑预处理。显然此 $\min\{\}$ 内部的式子可以通过递推 $O(n^2)$ 求出，整个程序的复杂度也就降到了 $O(n^2)$。由于读入已经 $O(n^2)$ 无法继续优化。

AC 代码如下：  
```c++
#include <cstdio>
#define N 2010
char a[N][N];
int up[N][N];
int f[N][N],g[N][N];
int n;
inline int min(int a,int b)
{
    return a<b?a:b;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%s",a[i]+1);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(a[i][j]=='#') up[i][j]=1+up[i-1][j];
            else up[i][j]=0;

    //f[i][j]=min(up[i][k]-k),k<=j
    //g[i][j]=min(up[i][k]+k),k>=j
    for(int i=1;i<=n;i++)
    {
        f[i][0]=g[i][n+1]=0x3f3f3f3f;
        for(int j=1;j<=n;j++)
            f[i][j]=min(up[i][j]-j,f[i][j-1]);
        for(int j=n;j>=1;j--)
            g[i][j]=min(up[i][j]+j,g[i][j+1]);
    }
    int ans=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        {
            int mx=min(j,n-j+1);
            mx=min(mx,min(g[i][j]-j,f[i][j]+j));
            ans+=mx;
        }
    printf("%d",ans);
}
```
[AC记录](https://www.luogu.com.cn/record/56824374)

---

## 作者：学委 (赞：0)

考虑每个点能作为几个三角形的顶点。

- 计算每一点能延伸到的左右端。
- 计算每一点能支持的最上端，比如某个点在第 i 行，如果能左右分别延伸 d 格，那么能支持的最上端是 i - d。
- 对于一列，从下往上扫 i，维护合法最下端 p 和之前最差的支持。如果最差的支持不能支持第 i 行，就更新 p。注意，如果第 i 行的支持比第 i + 1 行还要差，那么第 i 行会先弹出，于是第 i + 1 行也不能用了，所以维护支持可以用单调队列。

```cpp
#include <cstdio>
#include <algorithm>
using std::min;
const int N = 2e3 + 10;
int n; char s[N][N]; int l[N][N], r[N][N], q[N], head, tail;
int main() {
  scanf("%d", &n); for (int i = 1; i <= n; ++i) scanf("%s", s[i] + 1);
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= n; ++j)
      if (s[i][j - 1] == '#') l[i][j] = l[i][j - 1]; else l[i][j] = j;
    for (int j = n; j >= 1; --j)
      if (s[i][j + 1] == '#') r[i][j] = r[i][j + 1]; else r[i][j] = j;
    for (int j = 1; j <= n; ++j)
      if (s[i][j] == '#') l[i][j] = i - min(j - l[i][j], r[i][j] - j);
      else l[i][j] = i + 1;
  } int ans = 0;
  for (int j = 1; j <= n; ++j) {
    head = 1, q[tail = 1] = n; int p = n;
    for (int i = n; i >= 1; --i) {
      while (head <= tail and l[i][j] >= l[q[tail]][j]) --tail;
      q[++tail] = i;
      while (head <= tail and i < l[q[head]][j]) p = q[head++] - 1;
      ans += p - i + 1;
    }
  } printf("%d\n", ans);
  return 0;
}
```

---

## 作者：baka24 (赞：0)

观察发现，对于长度为 $h$ 的三角形，一定有一个长度为 $h-1$ 的三角形与它处于同一顶点。

例：

$\ \ \ \ \ \ \ \text{\#}$

$\ \ \ \text{\#\#\#}$

$\text{\#\#\#\#\#}$

高度为 $h$ 的三角形。

$\ \ \ \ \ \ \ \text\color{red}{\#}$

$\ \ \ \text\color{red}{\#\#\#}$

$\text{\#\#\#\#\#}$

其中的高度为 $h-1$ 的三角形。

可以联想到，如果我们能算出对于每个点，以这个点为顶点的最大三角形，就可以直接求出总数。

例：
```
.....
.###.
.###.
#####
.....
```
以每个点为顶点的最大三角形的高度：
```
0 0 0 0 0 
0 1 3 1 0 
0 2 2 2 0 
1 1 1 1 1 
0 0 0 0 0 
```

答案：16

-----
现在问题来了，我们该如何知道以每个点为顶点的最大三角形的高度。

观察上面的例子，发现对于高度为 $h$ 的三角形，其下面一定有 $3$ 个高度为 $h-1$ 的三角形，发现可以用递推解决。

$a_{i,j}$ 表示以坐标为 $(i,j)$ 的点为顶点的最大三角形的高度。

$a_{i,j}=\min(a_{i+1,j-1},a_{i+1,j},a_{i+1,j+1})$

关于 $\min$ 的必要性：大三角之下的三个小三角不能有残缺，例：

```
.....
..#..
.###.
####.
.....
```
此时 $a_{3,2}$ 为 ```2```，因为 $a_{4,3}$ 只有 ```1```。

 ### code: 
 ```
 #include<bits/stdc++.h>
using namespace std;
#define int long long
const int MAXN=2010,M=1011451423,M2=11451403,M3=114514191981019,M4=114514191981000001;unsigned long long base=131;
int n,m,a[MAXN][MAXN];
signed main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            char c;
            cin>>c;
            if(c=='.')a[i][j]=0;
            else a[i][j]=1;
        }
    }
    for(int i=1;i<n;i++){
        for(int j=2;j<n;j++){
            if(a[i][j]&&a[i+1][j-1]&&a[i+1][j]&&a[i+1][j+1]){
                k[i][j]=1;
            }
        }
    }
    for(int i=n;i>=1;i--){
        for(int j=1;j<=n;j++){
            if(k[i][j]){
                a[i][j]=min(a[i+1][j],min(a[i+1][j-1],a[i+1][j+1]))+1;
            }
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            ans+=a[i][j];
        }
    }
    printf("%lld",ans);
    return 0;
}
```

---


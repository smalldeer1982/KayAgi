# [eJOI 2019] 塔

## 题目描述

Jernej 在晚上感到很无聊，于是他发明了一个游戏。他想要用数字卡片生成一个塔。一开始，他在一张卡片上写下了一个数字 $1$。

Jernej 可以再另一张写下一个新的数字并放在塔顶。 **这个新的数字必须等于之前塔中某一连续段的数字之和** 。也就是说，假设现在塔中已有 $n$ 个数字，你可以任意选取塔中的一段 $[l,u]$ ，并对这一段求和，将得到的新数字添加至塔顶，其中 $1\le l\le u\le n$。

Jernej 想要生成 $T$ 个塔（相当于多组询问），每个塔顶都是 $T$ 个可能不同的他想要的数字。你需要帮助他求出生成这些塔的最小步数及其方案。

## 说明/提示

#### 【Special Judge 计分标准】

本题共 $10$ 个测试点。对于每个测试点，计分规则如下：

- 对于测试点中的任意一个塔，如果你的程序输出的 **最小步数** 与标准答案 **均一致** ，那么这个测试点你会得到 $10$ 分。
- 对于测试点中的任意一个塔，如果你的程序输出的答案是错误的，那么得 $0$ 分（评测时如果发现输出不完全可能会得到 UKE）。
- 如果你的答案并 **不是最优解但不是错误的** ，那么对于该测试点中的第 $i$ 个塔，你得到的分数为 $\text{score}_i =1+\dfrac{\text{minimum steps}}{\text{solution steps}}\times 7$，其中 $\text{minimum steps}$ 表示正确答案的最小步数，$\text{solution steps}$ 表示你的程序输出的答案。最终这个测试点的得分为 $\min\limits_{i\in [1,T]} \{\text{score}_i\}$。向上取两位小数。

#### 【输入输出样例解释】

**询问 1 解释**：

- Jernej 想要生成造一个塔顶数为 $2$ 的塔。起初塔为 $\{1\}$（左边表示塔底，右边表示塔顶）；
- 第一步，选取子段 $[1,1]$，对 $\{1\}$ 中的所有元素求和，得到 $1$，现在塔为 $\{1,1\}$；
- 第二步，选取子段 $[1,2]$，对 $\{1,1\}$ 中的所有元素求和，得到 $2$，现在塔为 $\{1,1,2\}$。此时已经达到了询问的要求。

**询问 2 解释**：

- 要生成塔顶为 $3$ 的塔不止一种方法。除了样例输出的一种之外，下面的也是正确答案：

```plain
1 1
1 2
2 3
```

#### 【数据规模与约定】

**本题采用多测试点捆绑测试，共有 7 个子任务**。

- Subtask 1（1 test case - 10 points）：$T\le 10,q\le 10$。
- Subtask 2（1 test case - 10 points）：$T\le 20,q\le 20$。
- Subtask 3（1 test case - 10 points）：$T= 100,q\le 100$。
- Subtask 4（1 test case - 10 points）：$T= 10^3,q\le 10^4$。
- Subtask 5（1 test case - 10 points）：$T= 10^3,q\le 10^5$。
- Subtask 6（1 test case - 10 points）：$T= 10^3,q\le 10^6$。
- Subtask 7（1 test case - 10 points）：$T= 10^3,q\le 10^9$。
- Subtask 8（1 test case - 10 points）：$T= 10^3,q\le 10^{12}$。
- Subtask 9（2 test case - 20 points）：无其他限制。

对于所有数据，保证 $1\le T\le 10^3,1\le q\le 10^{18}$

#### 【说明】

原题来自：[eJOI2019](https://www.ejoi2019.si) Problem D. [Tower](https://www.ejoi2019.si/static/media/uploads/tasks/tower-isc.pdf)。

翻译提供：@[```_Wallace_```](https://www.luogu.com.cn/user/61430)

## 样例 #1

### 输入

```
3
2
3
7```

### 输出

```
2
1 1
1 2
3
1 1
2 2
1 3
4
1 1
1 2
2 3
1 4​```

# 题解

## 作者：tx344 (赞：9)

## [[eJOI2019] 塔 ](https://www.luogu.com.cn/problem/P6241)
## 题面
从序列中选择一段**连续**序列，将序列和加入序列，求最小操作次数生成 $n$。
## 分析
~~初看感觉没什么思路~~。

### 1. 先考虑每次操作都选择整个序列
多次操作后序列为：
$$1,1,2,4,8,16,32,64,……$$
我们能发现 $a_i=2^{i-2}\ (i>1)$。
### 2. 试着对于某次操作**不选择**整个序列
随便选择一次操作，
$$1,1,2,4,\color{red}7\color{q},15,30,60,……$$

这个序列只是将**原序列**中的 $8$（即第 $4$ 次操作）变为：

$$a_2+a_3+a_4=1+2+4=7$$

后面的操作还是选择**整个序列**。

我们发现，当 $a_5$ 减少了 $1$，$a_{6+i}$ 就会减少 $2^i$。

换句话说，当 $a_{n-i-1}$ 减少了 $1$，$a_n$ 就能减少 $2^i$。

那么我们是不是可以**只**令 $n$ 以前的某些数减少 $1$（即不选择 $a_1$）就可以让 $a_n$ 变为我们想要的数。

所以我们对于任意一次操作，只用考虑从 $a_1$ 或 $a_2$ 开始选择整个序列
$$1,1,2,4,8,16,32,64,128,……$$
### 3. 实现
例如：

我们要得到 $59$，那么肯定使 $64$ 变为 $59$ 最优。

让 $64$ 变为 $59$ 就要让 $64$ 减少 $5$。

等同于让 $64$ 减少 $(2^2+2^0)$。

所以从 $64$ 往前看，只要让第 $4$ 和 $6$ 次操作都不选择整个序列（即不选择 $a_1$），而其他操作还是选择整个序列就可以得到 $59$。

$$1,1,2,4,7,15,29,59$$
所以我们先让每次操作都选择整个序列，对于要得到的数 $q$，只用先求出将哪个数变成 $q$，再将 $2^t-q$ 二进制分解一下，确定哪几次操作不选择 $a_1$。
### 4. 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T,n,m,now,t,ans[70];
signed main()
{
//	freopen("tower.in","r",stdin);
//	freopen("tower.out","w",stdout);
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%lld",&n);m=1;
		if(n==1){puts("0");continue;}
		t=1;ans[1]=1;
		while(m<n)
		{
			t++;
			ans[t]=1;
			m<<=1;
		}
		n=m-n;
		now=t-1;
		printf("%d\n",t);
		while(n)
		{
			if(n&1)ans[now]=2;
			now--;
			n>>=1;
		}
		for(int i=1;i<=t;i++)printf("%d %d\n",ans[i],i);
	}
}
```

---

## 作者：TulipeNoire (赞：4)

首先答案的下界肯定是 $\left\lfloor\log_2q\right\rfloor+1$。
如果 $\log_2q$ 为整数，那么下界是取得到的。但是如果不为整数，那么 $\left\lfloor\log_2q\right\rfloor+1$ 次操作后的最大值还是小于 $q$。那么我们要考虑的下界变成了 $\left\lfloor\log_2q\right\rfloor+2$。

实际上这个下界是取得到的，方法是，从 $q$ 的二进制最高位开始一位一位地往下扫，若这位为 $1$，则输出 `1 tot`，否则输出 `2 tot`。其中 `tot` 表示这是第几个操作。最后再输出 `2 tot`。这就是本题的解。

这为什么是对的呢？

记第 $i$ 次操作后的塔顶为 $f_i$，那么：

若上一次是 `1 tot`，这次是 `1 tot`：$f_i=2f_{i-1}$。

若上一次是 `1 tot`，这次是 `2 tot`：$f_i=2f_{i-1}-1$。

若上一次是 `2 tot`，这次是 `1 tot`：$f_i=2f_{i-1}+1$。

若上一次是 `2 tot`，这次是 `2 tot`：$f_i=2f_{i-1}$。

我们以 $53$ 举例看看，写成二进制就是 $110101$，前缀为 $p$。

$f_1=1,f_2=2,f_3=3,f_4=7,f_5=13,f_6=27,f_7=53$。

写成二进制是：

$$f_1=000001$$

$$f_2=000010$$

$$f_3=000011$$

$$f_4=000111$$

$$f_5=001101$$

$$f_6=011011$$

$$f_7=110110$$

对于每一个连续的 `1` 块，当它后面的 `0` 执行完一次操作后。刚好是它前面的答案，那么后面的 `0` 执行后也都是一致的。即 $f_3$ 为 $p_2$。而在下一个连续的 `1` 块出现前，$f_i=p_{i-1}$。

而这个连续块的第一个执行后，直到这个连续块结束，这个连续块实际上是在连续块的前一位为 $1$，后面为 $0$。即($f_4=111$，抛开相同的前两个 $11$ 不谈，比较 $1$ 与 $01$)。在执行完后面的 $0$ 后，因为是乘二减一，所以开始的 $1$ 没了，后面的 $0$ 全变成了 $0$。但是这样最后还差一位。分类讨论发现最后一个 `2 tot` 的操作能满足末位是 $0$ 或 $1$ 的情况。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
long long x;
int main() {
    scanf("%d",&T);
    while (T--) {
        scanf("%lld",&x);
        int res=__lg(x);//用log2可能有精度误差
        if (x==1) puts("0");//特判1
        else if (x==1ll<<res) {//注意是1ll
            printf("%d\n",res+1);
            for (int i=1;i<=res+1;i++) printf("1 %d\n",i);
        }
        else {
            printf("%d\n",res+2);
            int cnt=0;
            for (int i=res+1;i>=1;i--) {
                if (x>>(i-1)&1) printf("1 %d\n",++cnt);
                else printf("2 %d\n",++cnt);
            }
            printf("2 %d\n",++cnt);
        }
    }
    return 0;
}
```

---

## 作者：lucky_Mrzhao (赞：3)

这一道题中，有一个限制：一开始塔中只有一个 $1$，而又说每次只能选出一个子段和，所以我们可以试着选取序列中所有的数，写出这样一个序列：

$$1,1,2,4,8,16,32,64 \dots $$

这个序列其实就是以 $2$ 为底数的等比数列。

但是要一些数据却需要选取数列中的子段和，比如 $7$ 这种毒瘤数据，会发现：

对于这个序列 

$$1,1,2,4,7,15,30,60 \dots$$

$a_5$ 缩小了 $1$，导致 $a_6$ 缩小了 $1$，$a_7$ 缩小了 $2$，$a_8$ 缩小了 $4$。

于是我们可以得出一个这样的推论：$a_{n-i+1}$ 缩小了 $1$，会导致 $a_n$ 缩小 $2^{i-1}$。

根据这一条结论，我们找到离 $x$ 最近的且大于 $x$ 的 $2^l$ 的一个整数。并将这两个数的差改成二进制数，再将 $2^{l-k+1}$ 减 $1$，就可以满足这一道题的要求了。

```cpp
#include<bits/stdc++.h>
#pragma G++ opminize(2,3,"Ofast","inline")
#define endl '\n'
#define int long long
using namespace std;
int t;
int a[75]; 
signed main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin >> t;
	while(t--){
		int x;
		cin >> x;
		int y = 1;
		int n = 1;
		a[n] = 1;
		if(x==1){
			cout << 0;
			continue;
		}
		while(y < x){
			n++;
			a[n] = 1;
			y <<= 1; 
		}
		x = y - x;
		int m = n - 1;
		while(x){
			if(x % 2 == 1) a[m] = 2;
			m--;
			x >>= 1;
		}
		cout << n << endl;
		for(int i = 1;i <= n;i++){
			cout << a[i] << " " << i << endl;
		}
		cout << endl;
	}
	return 0;
}
```

---

## 作者：xxgirlxx (赞：0)

## 题目意思

最开始序列只有一个数字 $1$，每次操作可以在序列中选择一段非空的区间，将区间内所有数值的和插入到序列的最后。求最少操作量及其操作让最后一个数变成 $q$。

## 题目思路

先假设我们每一次都把序列中的所有数加起来，那么序列应该为：

$$ 1\ 1\ 2\ 4\ 8\ 16\ 32\ 64 \cdots $$

可以看到是以 $2$ 的指数级增加的，也就说明我们的操作最小至少也是 $\lfloor \log q \rfloor$（序列中的数共有 $\lceil \log q \rceil$ 个，但是因为第一个数已经写好了，所以要减 $1$，也就是 $\lfloor \log q \rfloor$）。

接下来我们假定一个操作不取第一个数，假设这个操作是第 $5$ 个，那么序列应为：

$$ 1\ 1\ 2\ 4\ 8\ 15\ 31\ 62 \cdots $$

化成跟第一个序列有关的样子就是：

$$ 1\ 1\ 2\ 4\ 8\ 16-1\ 32-1\ 64-2 \cdots $$

可以看到，从不取第一个数的操作之后（假设是第 $x$ 个），后面的数依次会减去 $2^{i-x}$。

对于这个情况的证明为：

既然这个操作减少了 $1$，因为下一个操作是前面所有数和这个数的和，但是这个数少了 $1$，那么后面的操作就也会减少 $1$，再下一个操作也是把它前面的所有数的值加起来，但是因为前面两个都减少了 $1$，所以它就会减少 $2$。以此类推······减少的数就变成最开始每一次都把序列中的所有数加起来的序列一样了。

那么我们就可以借助这个来构造 $q$。

首先，我们要找到第一个比 $q$ 大的 $2$ 的次方（设其为 $y$）那么我们需要减少的值就是 $2^y-q$。

然后我们将 $2^y-q$ 进行二进制拆分，从 $y$ 为第一位的位置往前扫，如果这一位的值为 $1$，那么这一次操作我们就不取第一个数。

最后将我们的答案输出就好了。

注意：$q=1$ 的情况要特判，因为 $1$ 已经提前写过一个了，所以序列最开始的最后一个就是 $1$，要输出 $0$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,ans[1000010],cnt,num,sum,res;
int main(){
	cin>>t;
	while(t--){
		cin>>n,num=ans[1]=sum=1;
		if(n==1){cout<<"0\n";continue;} 
		while(num<n)num*=2,ans[++sum]=1;
		cout<<sum<<endl;
		res=sum,cnt=num-n;
		while(cnt){
			if(cnt&1)ans[sum-1]=2;
			sum--,cnt/=2;
		}
		for(int i=1;i<=res;i++)cout<<ans[i]<<" "<<i<<endl;
	}
	return 0;
}
```

---

## 作者：cosf (赞：0)

## [P6241 塔](https://www.luogu.com.cn/problem/P6241)

首先，我们可以知道一件事，想要让最大的数变成 $2^n$，必须要操作 $n + 1$ 次。

这是因为，第一次可以变成 $1$，第二次是 $2$，第三次是 $4$……

那么，对于 $2^{n-1} \le q \lt 2^n$，至少通过 $n$ 操作完成。

下面是构造：

我们可以让 $2^n$ 减去 $q$，例如 $(11010110)_2$ 变成 $(00101010)_2$，然后从高位向低遍历，如果那一位是 $0$，就输出 `1 t`，否则是 `2 t`，其中 `t` 表示当前是第几个被遍历的位。

这样为什么是对的呢？因为，每一个 `2 t`，都相当于让那一位减掉了塔底的数，也就是 $1$。

那么，代码也就非常的好写。

## 代码

```cpp
#include <iostream>
using namespace std;

using ll = long long;

int main()
{
	int t;
	cin >> t;
	while (t--)
	{
		ll q;
		cin >> q;
		int t = 1;
		ll p = q;
		while (p)
		{
			t++;
			p >>= 1;
		}
		t -= (q == (q & (-q)));
		cout << t << endl;
		q = (1ll << (t - 1)) - q;
		for (int i = 0; i < t; i++)
		{
			if ((q >> (t - i - 2)) & 1)
			{
				cout << "2 ";
			}
			else
			{
				cout << "1 ";
			}
			cout << i + 1 << endl;
		}
	}
	return 0;
}

```

---

话说 $10$ 个测试点 $9$ 个子任务是什么鬼。


---

## 作者：baka24 (赞：0)

一种本质与其他题解类似但相对好写的做法。

### 具体步骤：
1. 将 $n-1$ 二进制分解。
2. 当第 $i$ 位为 0 时，第 $i$ 次操作选取 $2$ 到 $n$ 的区间。当第 $i$ 位为 1 时，第 $i$ 次操作选取 $1$ 到 $n$ 的区间。
3. 输出。

这样说也许不明显，看个例子：

#### 当 $n$ 为 $21$ 时：
先将 $20$ 二进制分解，结果为 $10010$。

```
   1  0  0  1  0
1  1
```
第一位是 $1$，于是选取 $1$ 到 $n$，答案的第二位是 $1$。

以此类推：
```
   1  0  0  1  0
1  1  1
```

```
   1  0  0  1  0
1  1  1  2
```

```
   1  0  0  1  0
1  1  1  2  5
```

```
   1  0  0  1  0
1  1  1  2  5  10
```
最后，我们得到了 ```1 1 1 2 5 10``` 这个序列，再将他们全部加在一起：

$$1+1+2+5+10=21$$


### 关于最小性的证明：

我们知道每次操作最对让数列总和 $S$ 增加至 $S\times2$ 或 $S\times2-1$.

可以发现，每次增长都是尽量大的，所以感性理解一下会发现这是正确的，然后快乐的写出代码。

### code:
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t,n;bool a[MAXN];
signed main(){
    scanf("%lld",&t);
    while(t--){
        scanf("%lld",&n);
        n--;
        int cnt=0,tmp=n;
        while(tmp){
            a[++cnt]=tmp%2;
            tmp/=2;
        }
        printf("%lld\n",cnt+1);
        for(int i=cnt;i>=1;i--){
            printf("%lld %lld\n",2-a[i],cnt-i+1);
        }
        printf("1 %lld\n",cnt+1);
    }
    return 0;
}
```

---

## 作者：pengyule (赞：0)

- 评：思维难度适中；代码难度不高
- 注意点：1.long long 的左（右）移运算**必须**用`1ll<<k`而非`1<<k`；2.慎用、不用`ceil(k)`，你会发现它会错！！

### 题解
仔细观察可以发现，我们需要在每一步采取一些特定措施——只加当前塔的一段而非全部，从而在最后的时候恰好得出要求的答案。观察样例，我们猜想最小步数为 $\log_2 q+1$（事实证明这是对的）。那么显然第一步是 `1 1`。也就是说我们要用 $\log_2 q$ 步从初始的 $[1\ 1]$ 得到最后的 $[1\ 1\ \cdots\ q]$。

**考虑“特定措施”为在某些步只加当前塔的一个后缀**。思考如何通过此得到答案。

我们以 $q=107$ 为例。那么不做任何变动地进行 $\log_2 q$ 步最后会得到 $128$。$107=128-21$，这个 $21$ 很重要，它就是我们所有“特定措施”对答案的影响之和。经过一番推导和尝试，我们想到一个可行的办法：

由于 $(21)_{10}=(10101)_2$，所以我们可以把“影响之和”分解成 $1_2+(100)_2+(10000)_2=2^0\times 2^0+2^1\times 2^1+2^2\times 2^2$，策略就是在倒数第四步、倒数第三步、倒数第二步分别不选 $[1\ 1\ 2]$、$[1\ 1]$、$[1]$。你会发现在第 $t$ 步“不选”的序列的数字之和为 $x$，则第 $t,t+1,t+2,\cdots$ 步由它导致的“影响”就是 $x,x,2^1x,2^2x,\cdots$。所以上面 $2^2\times 2^2$ 就是说最后一步恰好是第 $t+3$ 步，那么 $t$ 就是 $8-3=5$，这是第一个 $2^2$ 的含义，第二个的含义就是 $x=2^2$，那不就是 $[1\ 1\ 2]$ 这个前缀吗？其它的同理。

所以现在就要解决如何得到 $21$ 的分解。我们目标是把他分解成 $2^0\times 2^{m1}+2^1\times2^{m2}+\cdots$ 的形式，那么它的二进制分解中的每一个二的指数我们依次将它减去 $0,1,\cdots$ 就能得到 $m1,m2,\cdots$ 了。

这个是 $107$ 的详细方案过程：

```
1 1 2 4 8 12 26 53 107
```

下面是代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int s[100];
void solve(){
	int n;
	cin>>n;
	if(n==1){puts("0");return;}
	int l=log2(n);
	if((1ll<<l)<n)l++;
	int c=1ll<<l;
	cout<<l+1<<endl;
	puts("1 1");
	int dt=c-n;
	memset(s,0,sizeof(s));
	for(int i=0,j=0;dt;i++,dt>>=1ll)
		if(dt&1ll){//2^j*2^(i-j)
			s[j+2]=i-j+1;
			j++;
		}
	for(int i=1;i<=l;i++)
		printf("%lld %lld\n",s[l-i+1]+1,i+1);
}
signed main(){
	int T;
	cin>>T;
	while(T--)solve();
}
```

---

## 作者：chenxia25 (赞：0)

>[洛谷题目页面传送门](https://www.luogu.com.cn/problem/P6241)

>有一个塔，从下往上数层数，初始有$1$层数字为$1$。每步可以选择已有的所有数字中$[l,r]$层内所有的数字，计算它们的和并放在塔顶。给定$n$，求最少需要多少步能构造出塔顶为$n$的塔，并给出方案（每次的$l,r$）。本题多测。

>$n\in\left[1,10^{18}\right]$。

既然要算最少多少步，不妨先算出步数的下限。每步都尽可能让塔顶大，即每步都选塔内所有数相加，这样第$1$步得$1$，以后每步翻倍，这样至少需要$ans=\lceil\log_2n\rceil+1$步塔顶才能$\geq n$。

考虑尽可能逼近下限。我们先这样丧心病狂地每步最大化塔顶地建出一个塔，显然长这个样子：第$i(i\geq2)$层为$2^{i-2}$。此时塔顶是$\geq n$的，考虑减少一些塔内的数字使得塔顶$=n$。显然$i\in[3,ans]$，都可以令第$i$步的$l$由原来的$1$变成$2$，这样第$i$层减少$1$，产生连锁反应，第$i+1$层减少$1$，第$i+2$层减少$2$，……，第$i+x$层减少$2^{x-1}$，于是塔顶减少$2^{ans-i}$。$\left\{2^{ans-i}\mid i\in[3,ans]\right\}=\left\{2^{i}\mid i\in[0,ans-3]\right\}$。再考虑一共需要减少多少。显然$2^{ans-1}-n<2^{ans-1}$，又$n$二进制下最高位一定为$1$，则$2^{ans}-n<2^{ans-2}$。那么将它二进制分解，用集合$\left\{2^{i}\mid i\in[0,ans-3]\right\}$恰好永远存在方案凑出来。也就是说下限$ans$达得到。于是这题就做完了~~（这不是某数学老师hzj的名言么）~~

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
void mian(){
	int n;
	cin>>n;
	int ans=0;
	while(1ll<<ans<n)ans++;
	ans++;
	cout<<ans<<"\n1 1\n";//第1步 
	for(int i=ans-1;i>=2;i--)
		printf("%lld %lld\n",1ll+!!((1ll<<ans-1)-n&1ll<<i-2),ans-i+1);//凑 
	cout<<"1 "<<ans<<"\n";//塔顶 
}
signed main(){
	int testnum;
	cin>>testnum;
	while(testnum--)mian();
	return 0;
}
```

---

## 作者：xtx1092515503 (赞：0)

因为每一次操作过后，塔内所有数字之和**最大**可以**翻倍**，因此可以考虑在**二进制**上做文章，即**倍增**。

**以下全部$\log$均下取整。**

法1.暴力做法（没试过，估计不可能超过$50\%$）

初始塔内所有数字之和为$1$；每次都加入一个等于塔内所有数字之和的数，即翻倍塔内数字和；按照$n$的二进制表示，在适当的时刻加入一个$1$。该方法最劣是$2\log_2 n$的，在全$1$的$n$时取到。

法2.稍微好一点的暴力做法（$61\%$）

首先倍增出$2^0,2^1,\dots,2^{\log_2n}$所有数，然后对于连续的$1$，合并在一起加入。该方法最劣是$1.5\log_2n$的，在$01$交替的$n$时取到。

法3.正解：

首先特判掉$n=1$与$n$为$2$的整数次幂的情况。在其它情况下：

一开始加入一个$[1,1]$。

然后，我们设塔的大小为$t$，塔中所有数的和为$k$。如果加入一个$[1,t]$，则$k$会翻倍；如果加入一个$[2,t]$，则$k$会变成$2k-1$。

考虑借鉴我们的暴力做法，在当时有$k=2k$或$k=2k+1$两种变法。在这里是$2k$与$2k-1$，十分类似！

我们设$n=\sum\limits_{i=1}^m\alpha_i2^{i-1}$。

在暴力的情况下，我们倒序枚举$i$，如果$\alpha_i=1$，我们采取$2k+1$，否则采取$2k$。

而在正解里面，我们倒序 **从$m-1$到$0$** 枚举$i$，如果$\alpha_i=1$，采取$2k$，否则采取$2k-1$。假若你代回式子里看一下，会发现结果刚好是$n$，有兴趣的同学可以自行验证。该方法始终是$\log_2 n$的。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int T,n,par[64],m,tp;
signed main(){
	cin>>T;
	while(T--){
		cin>>n,m=0,tp=1;
		if(n==1){puts("1");continue;}
		if((n&-n)==n){//if it's an integer power of two, then it can be done in log2(n) by simply doubling
			while(n)m++,n>>=1;
			cout<<m<<endl;
			for(int i=1;i<=m;i++)cout<<1<<' '<<i<<endl;
			continue;
		}
		while(n)par[++m]=n&1,n>>=1;//binary partition
		cout<<m+1<<endl;
		puts("1 1");
		for(int i=m-1;i>=0;i--)cout<<(!par[i])+1<<' '<<++tp<<endl;//as the equation we've got before
	}
	return 0;
}
```


---

## 作者：XenonKnight (赞：0)

> 题意：
> - 给出一个数 $n$。
> - 你有一个序列 $a$，初始只有一个元素 $a_1=1$。
> - 每次你可以选择一个区间 $[l,r]$，记录它们的和 $s$，并将 $s$ 写到这个序列的后面。
> - 问至少需要多少次操作可以得到 $n$
> - $1 \leq n \leq 10^{18}$

为什么这种题没有题解啊 qwq。

我们考虑贪心。假设当前有 $m$ 个数。那么我们每次选择的区间一定是 $[1,m]$ 和 $[2,m]$ 中的一种。如果原来的和是 $S$，那么执行一次 $[1,m]$ 可以使 $S$ 变为 $S \times 2$，执行一次 $[2,m]$ 可以使得 $S$ 变为 $S \times 2-1$。二进制拆位就可以了。

```cpp
while(T--){
	vector<int> ans;
	int x=read();
	if(x==1){//注意特判 x=1
		puts("0");
		continue;
	}
	while(x!=1){
		if(x%2==0)	ans.push_back(1),x/=2;//x是偶数说明最后一次操作是 [1,m]
		else		ans.push_back(2),x=(x+1)/2;//x是奇数说明最后一次操作是 [2,m]
	}
	reverse(all(ans));
	cout<<ans.size()+1<<endl;
	int cursum=1;
	foreach(it,ans){
		cout<<*it<<" "<<cursum<<endl;
		cursum++;
	}
	cout<<1<<" "<<cursum<<endl;//我们之前构造的方案是和为 x，而要得到 x 这个数字还需执行一次 [1,x]
}
```

---


# [Code+#7] 神秘序列

## 题目描述

E.Space 做了一个梦。

他梦到了一个神秘的序列，有人告诉他，这个序列和明天的考试有一些密切的关联。

他决心要把这个序列记住。可醒来之后，E.Space 发现自己没有记住这个序列，甚至连序列的长度都不记得了。不过，他记得这个序列有一个神奇的性质。

在梦中，E.Space 对它进行了一系列的操作。记这个序列为 $a_1, a_2, \dots, a_n$，开始时它满足 $\forall 1\le i\le n, a_i \ge 0$，并且 $a_n \neq 0$。

之后，E.Space 在每次操作时选择一个满足 $a_i=i$ 的 $i$，将 $a_i$ 变为 $0$，并且将 $a_1, a_2, \dots, a_{i-1}$ 分别变为原来的值加 $1$。

E.Space 记得，在 $n+k$ 次操作之后，这个序列变成了全 $0$ 序列，即 $a_1=a_2=\cdots =a_n= 0$。

E.Space 知道可能有多个序列满足这个性质，但是他还是希望你告诉他一种可能的情况，因为，说不定所有满足这个性质的序列都可以在考试时派上用场呢。

他的考试成绩就交给你了。

## 说明/提示

子任务 $1$（$10$ 分）：$k\le 6$

子任务 $2$（$25$ 分）：$k\le 10^6$

子任务 $3$（$30$ 分）：$k\le 10^{11}$，如果有解则保证存在一个解满足 $\forall 1\le i< n, a_i \neq i$

子任务 $4$（$28$ 分）：$k\le 10^{11}$

子任务 $5$（$7$ 分）：$k\le 10^{12}$

## 样例 #1

### 输入

```
1```

### 输出

```
2
1 2```

## 样例 #2

### 输入

```
5```

### 输出

```
4
1 2 2 4```

# 题解

## 作者：WYXkk (赞：13)

在 MO 课上听到了和这题类似的题，所以跑来写篇题解（

-----

首先发现一个性质：我们必须保证任何时刻 $a_i\le i$。

否则，一旦 $a_i>i$，那么我们再也无法对 $a_i$ 操作，它就不可能降为 $0$。

因此，每次一定是选择 $a_i=i$ 的最小 $i$ 操作。

因此我们可以把整个过程反过来，相当于每次选择最小的 $i$ 使 $a_i=0$，然后 $a_1,a_2,\cdots,a_{i-1}$ 全部减一，$a_i$ 变成 $i$。

然后通过模拟这个过程可以拿到 35pts 的好成绩。

接下来我们可以考虑找规律，因此打个表。

打表程序 ↓

```cpp
const int N=3000005;
int a[N];
int main()
{
	freopen("out.txt","w",stdout);int n=0;
	F(i,1,999)
	{
		printf("%3d:",i);
		int u=1;while(a[u]){--a[u];++u;}a[u]+=u;
		if(u>n) n=u;
		F(j,1,n) printf("%d ",a[j]);puts("");
	}
	return 0;
}
```

然后打出来的表大概长这样 ↓（截取了一部分）

```plain
  1:1 
  2:0 2 
  3:1 2 
  4:0 1 3 
  5:1 1 3 
  6:0 0 2 4 
  7:1 0 2 4 
  8:0 2 2 4 
  9:1 2 2 4 
 10:0 1 1 3 5 
 11:1 1 1 3 5 
 12:0 0 0 2 4 6 
 13:1 0 0 2 4 6 
 14:0 2 0 2 4 6 
 15:1 2 0 2 4 6 
 16:0 1 3 2 4 6 
 17:1 1 3 2 4 6 
 18:0 0 2 1 3 5 7 
 19:1 0 2 1 3 5 7 
 20:0 2 2 1 3 5 7 
 21:1 2 2 1 3 5 7 
 22:0 1 1 0 2 4 6 8 
 23:1 1 1 0 2 4 6 8 
 24:0 0 0 4 2 4 6 8 
 25:1 0 0 4 2 4 6 8 
```

每一位似乎都有循环节，但是这个循环节随着数增大越来越长，非常难受，很难处理。

事实上是，我们**找规律的对象选错了**。

我们可以对每次操作的 $a$ 找规律，得到下面这张表 ↓（截取了一部分）

$1,2,1,3,1,4,1,2,1,5,1,6,1,2,1,3,1,7,1,2,1,8,1,4,1,2,1,3,1,9,1,2,1,10,1,5$

每两个出现一个 $1$，每六个出现一个 $2$。还有其它规律吗？

我们去掉所有 $1$：$2,3,4,2,5,6,2,3,7,2,8,4,2,3,9,2,10,5,2,3,11,2,4,12,2,3,6,2,13,14,2,3,4$

现在是每三个一个 $2$，我们再去掉所有 $2$：$3,4,5,6,3,7,8,4,3,9,10,5,3,11,4,12,3,6,13,14,3,4,5,7,3,15,16,4,3,8,6,5,3,1$

剩下的是每四个一个 $3$，我们再去掉所有 $3$：$4,5,6,7,8,4,9,10,5,11,4,12,6,13,14,4,5,7,15,16,4,8,6,5,17,4,18,9,19,7$

剩下的是每五个一个 $4$，后面以此类推。

因此，我们得到规律：$\ge m$ 的操作中，第一个操作 $m$，后面每 $m+1$ 次操作一次 $m$。

仔细想想会发现这个规律是显然成立的。也就是说规律发现比规律证明难？

因此我们只需要想办法定下 $n$ 的值，然后就能 $O(n)$ 定出每个数被操作多少次，然后就可以用前缀和搞一下得出所有数最终值。

至于 $n$ 值怎么定？先本地二分打表，求出一些 $n$ 对应的最小 $s$；然后查表，求出 $s$ 对应的 $n$ 在哪个范围内；然后在这个范围内二分求出 $s$ 对应的 $n$。

然后这题就做完了。

参考代码：

打表 ↓

```cpp
const int N=3000005;
int a[N];
int check(ll s)
{
	int i=1;while(s){s=s*i/(i+1);++i;}
	return i;//这里似乎写错了，但也过了？/yun
}
ll doit(int n)
{
	ll l=1,r=2000000000000ll;
	while(l!=r)
	{
		ll mid=(l+r)>>1;
		if(check(mid+n)>=n) r=mid;else l=mid+1;
	}
	return l;
}		
int main()
{
	freopen("out.txt","w",stdout);
	F(i,1,200) printf("%lldll,",doit(i*10000));
	return 0;
}
```

最终程序 ↓

```cpp
const int N=3000005;
ll tmp[]={/*表省略*/};
ll a[N],b[N];
int check(ll s)
{
	int i=1;while(s){s=s*i/(i+1);++i;}
	return i-1;
}
int doit(ll a,int l,int r)
{
	while(l!=r)
	{
		int mid=(l+r)>>1;
		if(check(a+mid)<=mid) r=mid;else l=mid+1;
	}
	return l;
}
int main()
{
	ll s=rd();
	int i=1;while(s>=tmp[i]) ++i;
	int n=doit(s,(i-1)*10000,i*10000);
	printf("%d\n",n);s+=n;
	F(i,1,n) {ll u=s*i/(i+1);a[i]=s-u;s=u;}
	F(i,1,n) b[i]=a[i]*i;
	UF(i,n,2) {b[i-1]-=a[i];a[i-1]+=a[i];}
	F(i,1,n) printf("%lld ",b[i]);
	return 0;
}
```



---

## 作者：_yjh (赞：5)

首先考虑对于每个固定的 $n$，尝试求出当序列长度为 $n$ 时，能构造出 $k$ 的上下界。

容易发现，一个点操作的次数实际上只和其初值和其后面点的操作次数有关。于是我们不妨倒着 dp，设 $mn_i$ 表示大于等于 $i$ 的数全变为 $0$ 的最小操作次数，$mx_i$ 表示最大操作次数。容易发现转移是容易的（钦定在后面取最小值时初值取 $0$，后面取最大值时初值取 $i$ 进行转移），同时 $[mn_i,mx_i]$ 中的所有状态都是可以构造出来的，证明考虑数学归纳。

运行上面的 dp，可以发现序列长度取到 $n=2 \times 10^6$ 即可构造出 $k=10^{12}$ 的解（实际上取 $1772454$ 便足够）。而且设 $n=x$ 时构造的上下界是 $[l_x,r_x]$，$n=x+1$ 时上下界为 $[l_{x+1},r_{x+1}]$，则必有 $r_x=l_{x+1}$。也就是说不存在无解的情况，而且区间基本上时单调的（虽然相邻又大小为 $1$ 的交，但依然可以二分）。

于是直接二分出合法的 $n$，利用之前算的 dp 值倒着构造即可。

时间复杂度 $O(n \log n)$，常数比较大，要卡常。比较优秀的实现应该可以通过。

代码很好写，就不放了。

---

## 作者：听取MLE声一片 (赞：4)

神秘做法。

令 $m=n+k$，考虑给定 $m$ 的值来判断是否合法并构造。

考虑处理每个位置操作了多少次。对于第一个位置，为了最后能清零，操作后面的一次后必然操作第一个位置，也就是操作 $a_1=\lceil \frac{m}{2}\rceil$ 次。

对于第二个位置，第一个位置是没有影响的，所以只剩下 $m-a_1$ 次操作。同样为了清零，后面操作两次后必然要操作第二个位置，次数也就是 $a_2=\lceil \frac{m-a_1}{3}\rceil$。

以此类推，第 $i$ 个位置的操作次数就是 $a_i=\lceil \frac{m-sum_i}{i+1}\rceil$，其中 $sum_i$ 表示前 $i$ 项的前缀和。

注意如果到最后 $m$ 次操作次数还没有给完，那先分配给最后一个位置。

然后就是如何通过操作次数来反推原序列 $b_i$。

考虑从后往前扫，设第 $i$ 个位置的后面操作了 $x$ 次，那么原序列 $b_i=i\times a_i-x$，如果每个 $b_i$ 都符合限制，那么这个方案合法。

最后就是如何确定出 $m$ 的值。

打表发现，合法的 $\frac{\sqrt k}{n}$ 的值随着 $k$ 增加逐渐趋近一个常数。取 $1.7724566$，则有近似值 $n=1.7724566\sqrt k$，上下取一个小的偏移量暴力跑一下就行了。

```#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<set>
#include<bitset>
#include<ctime>
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N=2e6+10;
int n,m,k,a[N],b[N];
int check(){
	m=n+k;
	for(int i=1;i<=n;i++){
		int x=(m+i)/(i+1);
		a[i]=x;
		m-=x;
	}
	a[n]+=m;
	int sum=0;
	for(int i=n;i>=1;i--){
		b[i]=i*a[i]-sum;
		sum+=a[i];
		if(b[i]>i||b[i]<0)
			return 0;
	}
	//while(n>1&&b[n]==0)n--;
	cout<<n<<'\n';
	for(int i=1;i<=n;i++)
		cout<<b[i]<<' ';
	return 1;
}
signed main()
{
//	freopen("seq.in","r",stdin);
//	freopen("seq.out","w",stdout);
	k=read();
	int x=sqrt(k)*1.7724566;
	for(int i=max(x-10,3ll);i<=x+100;i++){
		n=i;
		if(check())
			return 0;
	}
	puts("Daydream!");
	return 0;
}

```

---

## 作者：leukocyte (赞：3)

提供一个跟现有题解不太一样的做法。~~（本质应该一样）~~

首先能发现这个序列满足以下性质：

1. $a_n=n$
2. $a_i\le i$
3. 将序列变为全 $0$ 的操作次数为 $\sum_i a_i$ 。

我们考虑确定 $n$ ，如何构造一个序列。

考虑另一个序列 $b_i$ ，表示每个数的操作次数。

那么显然有：

$$b_i\times i=\sum_{j>i}b_j+a_i$$
$$b_i\times (i+1)=\sum_{j\ge i}b_j+a_i$$

这启发我们从前往后构造 $a_i$ 和 $b_i$，因为我们如果知道了一段后缀的操作次数和，就很容易构造出这一段后缀的第一项。

接下来我们考虑如何确定 $n$ 。

通过我们打表找规律和一些感性理解，可以发现对于一个固定的 $k$ ，构造出来的序列的 $\sum_i a_i$ 是单调的，所以我们直接二分答案，找第一个使得 $\sum_i a_i \ge n+k$ 的即可（而且这貌似是唯一解，然而我不太会证，求证明）。

因为我做法需要进行大量乘除运算，所以可能需要卡卡常。


---

## 作者：beauty_son_whm (赞：1)

首先我们必须保证任意时刻 $a_i\leq i$。

因为如果 $a_i>i$ 那么我们再也无法操作 $i$ 这个位置了。所以我们任意时刻操作的数都是最小的 $i$ 满足 $a_i=i$。

也就是说，如果我们知道这个序列长什么样子，我现在就可以通过模拟知道它是否可以变为全 0。

正难则反，我们考虑倒着来搞，如果我们当前的序列是全 0 的。我们经过 $k$ 次逆操作，这个序列会变成什么样子？

这里定义逆操作为 选择最小的 $a_i=0$ 将所有 $j<i$ 的位置全部减一，将 $a_i$ 还原为 $i$。

我们可以打个表看一眼我们每次操作的位置构成的操作序列是什么：
```
1 2 1 3 1 4 1 2 1 5 1 6 1 2 1 3 1 7 1 2 1 8 1 4 1 2 1 3 1
9 1 2 1 10 1 5 1 2 1 3 1 11 1 2 1 4 1 12 1 2 1 3 1 6 1 2 1 13
```
我们惊奇地发现位置 1 每两次会操作一次。细想确实是这样，因为我们每次还原一个后面的数，都会使位置 1 减一。

进一步的，如果我们把所有位置 1 拿掉。我们会发现序列变成：

```
2 3 4 2 5 6 2 3 7 2 8 4 2 3 9 2 10 5 2 3 11 2 4 12 2 3 6 2 13
```

我们又惊奇地发现，位置 2 每三次会操作一次。细想也确实是这样，因为我们每次还原 2 后面的一个数，都会使 2 这个位置的数减一。所以每操作两次后面的数我都得回来操作一次 2。

进进一步的，如果我们把所有位置 2 拿掉。序列就变成了：
```
3 4 5 6 3 7 8 4 3 9 10 5 3 11 4 12 3 6 13
```

我们又又惊奇地发现，位置 3 每四次会操作一次。证明同上。

那么我们想，如果我能知道序列长度是多少，也能知道操作次数是多少，我们能否还原出这个序列？

答案是可以的，我们设 $b_i$ 表示位置 $i$ 的操作次数，则：
$$b_i=\lceil \frac{(n+k-\sum_{j<i}b_j)}{i+1} \rceil $$
 
含义是，对于第 $i$ 的位置，我们除去 $j<i$ 所有位置的操作数，每 $i+1$ 个位置，出现一次操作 $i$。

那么我们的初始序列 $a_i$ 也可以通过这个操作序列算出来:

$$a_i=\begin{cases}
0 & (\sum_{i\leq j}b_i)\bmod (i+1)=0 \\
i-((\sum_{i\leq j}b_i)\bmod (i+1)-1) & (\sum_{i\leq j}b_i)\bmod(i+1)\not=0
\end{cases}$$

这个式子的含义就是我现在把所有 $j<i$ 的操作都拿掉。那么之后每操作 $i+1$ 次 就会操作一个 $i$。那么我的周期就是 $i+1$ 。如果我的周期是完整的，那么我这个位置的初始状态就是 0。如果我的周期不完整，那么我剩的操作 -1 就是 $k>i$ 的最后一个周期的操作次数，每操作一次就会使我减小 1。

现在，我们只需要二分一下序列长度，算一下操作次数够不够就可以了。




---

## 作者：jiangby (赞：1)

题目中只给出了$k$没有给定$n$很容易想到$k$与$n$之间有关系,手玩一下容易发现每个$n$对应一段的$k$,所以先二分求出$n$

求出$n$以后我们考虑求出序列,可以考虑倒着还原它,直接模拟,但是时间接受不了,思考有没有更快的方法,可以想到以下方法,对于定义操作$i$,$a_i+=i,a_j--(a_i=0,j<i)$

不难发现这是题目中操作的逆操作,而且倒着回去的第$1,3,5,7,9...$都是操作$1$,去掉操作$1$以后的$1,4,7,10...$都是操作$2$,并且后面的也遵循这个规律,因为加法具有交换律我们可以吧一样的操作放在一起,直接差分就好了

---

## 作者：hutongzhou (赞：0)

开始可以跟着样例手算一下，发现从前往后扫一遍只要有 $a_i=i$ 就要变为零，不然先改变后面满足条件的 $a_j$ 后，前面的 $a_i$ 就超过 $i$ 无法使之变为零。

正着算比较好算，只要扫到一个 $a_i=i$，$a_i$ 就变为零，$a_1,a_2, \cdots a_{i-1}$ 加一。

但难点是构造出这个序列，可以想到倒着推回去，从前往后扫，只要找到一个零就把 $a_i$ 变为 $i$，$a_1 \cdots a_{i-1}$ 减一。

可以试着打表看一下:

```
  1:1 
  2:0 2 
  3:1 2 
  4:0 1 3 
  5:1 1 3 
  6:0 0 2 4 
  7:1 0 2 4 
  8:0 2 2 4 
  9:1 2 2 4 
 10:0 1 1 3 5 
 11:1 1 1 3 5 
 12:0 0 0 2 4 6 
 13:1 0 0 2 4 6 
 14:0 2 0 2 4 6 
 15:1 2 0 2 4 6 
 16:0 1 3 2 4 6 
 17:1 1 3 2 4 6 
 18:0 0 2 1 3 5 7 
 19:1 0 2 1 3 5 7 
 20:0 2 2 1 3 5 7 
```

发现并没有什么规律，之前想过用一些数据结构使这个暴力方法优化到 $10^6$ 的级别，发现很困难，故舍去。

又根据上表把每次改变的数的下标写下来。

```
1 2 1 3 1 4 1 2 1 5 1 6 1 2 1 3 1 7 1 2
```

发现 $1$ 是两次一循环，除去 $1$ 后 $2$ 是三次一循环，再出去 $2$ 后 $3$ 是四次一循环，依此类推。

可以得出以下式子：
$$
s_i=(k_{i-1}-\sum_{j=1}^{i-1} \lceil \frac{k_j}{j+1} \rceil )
$$

$s_i$ 表示下为 $i$ 的循环次数，$k_i$ 表示减去前 $i-1$ 的次数和(也就是还剩下的操作次数)。

简化一下式子就是：

$$
s_i=sum \times \frac{i}{i+1}
$$

`sum`  指还剩下的操作次数，这里把 `k` 数组省去了。

然后用每个数的循环次数来推整个序列。

$s_i \times i$ 是理论上要使 $i$ 变成零的次数，而减去后面的数的次数和（也就是 $i$ 被后面的数加一的次数），是 $a_i$ 的原始值。

设原始的序列为 `b`，那可以写出递推式：

$$
b_i=s_i \times i+\sum_{j=i+1}^{n} s_i;
$$

这样就可以求出序列了。

但操作的次数是 $n+k$，不知道次数，所以很容易想到二分来判断一下。

这道题二分的范围不好求，参考[这篇](https://www.luogu.com.cn/article/wbyu2yx7)，$n$ 大概是：$1.7724566 \times \sqrt{k}$。

**code**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e7+10;
int n;
int a[N],b[N];
bool check(int mid)
{
	int k=mid+n,i=1;
	while(k)
	{
		k=k*i/(i+1);
		i++;
	}
	i--;
	if(i<=mid)	return 1;
	return 0;
}
signed main()
{
	scanf("%lld",&n);
	int x=sqrt(n)*1.772456;
	int r=x+100;
	int l=max(x-100,2ll);
	while(l<r)
	{
		int mid=(l+r)>>1;
		if(check(mid))	r=mid;
		else l=mid+1;
	}
//	if(l==x+100)			之前想错了,这里应该没有无解情况 
//	{
//		puts("Daydream!");
//		return 0;
//	}
	n+=l;
	int len=1;
	while(n)
	{
		int now=n;
		n=n*len/(len+1);
		a[len]=now-n;
		len++;
	}
	len--;
	int sum=0;
	for(int i=len;i>=1;i--)
	{
		b[i]=a[i]*i-sum;
		sum+=a[i];
	}
	printf("%lld\n",len);
	for(int i=1;i<=len;i++)	printf("%lld ",b[i]);
	return 0;
} 
```

---


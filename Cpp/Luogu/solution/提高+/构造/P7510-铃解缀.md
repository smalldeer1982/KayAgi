# 铃解缀

## 题目背景

题目：数对构造。

## 题目描述

将 $1 \sim 2n$ 的整数分为 $n$ 个有序数对 $(a_i,b_i)$（$1 \le i \le n$）。你需要使得对于任意不大于 $n$ 的正整数 $i$，有 $a_i - b_i = i$。

给定 $n$，请你给出一种构造方案。若无解则输出 `-1 0`。

## 说明/提示

**样例解释**

对于第一组样例，显然这个样例无解。

对于第二组样例，样例输出给出了一种可行的构造方案。

**数据范围及约定**

**本题使用捆绑测试。**

$\texttt{Subtask 1 (20 pts)}$：$n \le 5$。

$\texttt{Subtask 2 (20 pts)}$：$n \le 10 ^ 5$。

$\texttt{Subtask 3 (30 pts)}$：$n$ 为素数。

$\texttt{Subtask 4 (30 pts)}$：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 10^6$。

这道题用来锻炼数学思维和构造能力，但不适合在 OI 比赛中。

[CoOI Round 1](https://www.luogu.com.cn/contest/43016) B 题。

## 样例 #1

### 输入

```
2
```

### 输出

```
-1 0
```

## 样例 #2

### 输入

```
5
```

### 输出

```
2 1
9 7
6 3
8 4
10 5
```

# 题解

## 作者：VinstaG173 (赞：6)

小学数学经典题。小学曾在多个 MO 课听过做法。可是赛时由于设备原因写代码太麻烦了不想写，否则应该可以首 A（

首先，我们发现 $a-b$ 与 $a+b$ 奇偶性相同，即 $\sum\limits_{i=1}^{n}(a_i-b_i) \equiv \sum\limits_{i=1}^{n}(a_i+b_i) \pmod{2}$。

上式左边是 $\dfrac{n(n+1)}{2}$，右边是 $\dfrac{2n(2n+1)}{2}$。推一推发现需要 $n \equiv 0,1 \pmod{4}$。

然后感觉这个问题不是很好处理，联想到有解条件是 $n \equiv 0,1 \pmod{4}$，并且差取遍 $1 \sim n$，想到小学时很喜欢的一个问题：

> 把 $1$ 至 $n$ 各两个排成一列，使两个 $i$ 之间隔 $i$ 个数。

当时脑抽以为这个问题有解条件也是 $n \equiv 0,1 \pmod{4}$，推了下小情况发现是 $n \equiv 0,-1 \pmod{4}$（

但是发现如果把 $i$ 变成 $i+1$ 再加两个相邻的 $1$，正好变成两个 $i$ 的下标差 $i$，并且有解条件是 $n \equiv 0,1 \pmod{4}$。于是我就做出来了？

回忆了一下以前讲的构造，记得我特别喜欢它的原因是除了几个数外都是两个 $x+2$ 套着两个 $x$ 的形式。搞了一下搞出来了。

然后发现我的构造和 std 一模一样。。。大概就是这题引申过来的吧（

Code:
```cpp
#include<cstdio>
#define rg register
int n;
int ans[2][1000003];
int main()
{
	scanf(" %d",&n);
	if(n&2)return 0&puts("-1 0");
	int m=n>>2;
	if(n&1)
	{
		ans[0][1]=1,ans[1][1]=2;
		ans[0][n]=n,ans[1][n]=n<<1;
		ans[0][n-2]=m+2,ans[1][n-2]=n+m;
		ans[0][n>>1]=n+(n>>1),ans[1][n>>1]=m<<3|1;
		ans[0][n-1]=(m+1)<<1,ans[1][n-1]=n+(m<<1|1);
		for(rg int i=1;i<m;++i)
		{
			ans[0][n-((i+1)<<1)]=2+i,ans[1][n-((i+1)<<1)]=n-i;
			ans[0][i<<1]=((m+1)<<1)-i,ans[1][i<<1]=((m+1)<<1)+i;
			ans[0][n-(i<<1|1)]=n+i,ans[1][n-(i<<1|1)]=(m<<3|1)-i;
			ans[0][i<<1|1]=n+(m<<1)-i,ans[1][i<<1|1]=n+(m<<1|1)+i;
		}
	}
	else
	{
		ans[0][1]=1,ans[1][1]=2;
		ans[0][n-1]=m+2,ans[1][n-1]=n+m+1;
		ans[0][n>>1]=n|1,ans[1][n>>1]=n+(m<<1|1);
		ans[0][n]=(m+1)<<1,ans[1][n]=n+((m+1)<<1);
		for(rg int i=1;i<m;++i)
		{
			ans[0][n-(i<<1|1)]=2+i,ans[1][n-(i<<1|1)]=n-i+1;
			ans[0][n-(i<<1)]=n+i+1,ans[1][n-(i<<1)]=(n<<1|1)-i;
			ans[0][i<<1]=((m+1)<<1)-i,ans[1][i<<1]=((m+1)<<1)+i;
			ans[0][i<<1|1]=n+(m<<1|1)-i,ans[1][i<<1|1]=n+((m+1)<<1)+i;
		}
	}
	for(rg int i=1;i<=n;++i)printf("%d %d\n",ans[1][i],ans[0][i]);
	return 0;
}
```

---

## 作者：_SkyBlue (赞：4)

## 算法 $\bf 1$

全排列枚举可能的序列。

```cpp
for(int i = 1; i <= 2 * n; i ++) {
  a[i] = i;
} do {
  bool flag = true;
  for(int i = 1; i <= 2 * n; i = i + 2) {
    if(a[i + 1] - a[i] == (i + 1) / 2) {
    } else {
      flag = false;
      break;
    }
  }
  if(flag) {
    for(int i = 1; i <= 2 * n; i = i + 2) {
      v.push_back(make_pair(a[i + 1], a[i]));
    }
    return v;
  }
} while(next_permutation(a + 1, a + 2 * n + 1));
```

## 算法 $\bf 2$

算法 $\bf 1$ 的算法显然不能满足本题的要求，考虑进行等价的转换。

假设有满足要求的 $n$ 对 $(a_i, b_i)$。

对于 $a_i - b_i = i$，我们抽象为一个长度为 $2n$ 的序列，并使得 $a_i \rightarrow i$，$b_i \rightarrow i$，中间相隔 $i - 1$ 个数。

如果存在这样的序列，必存在相应的数对集。

对于 $\forall i$，令 $i$ 第一次出现的位置为 $x_i$，第二次出现的位置为 $y_i$。则 $y_i = x_i + i$。

考虑位置的和 $1 \sim 2n$。

$$\sum_{i=1}^n x_i + \sum_{i=1}^n y_i = \sum_{i=1}^{2n}i=\dfrac{(1+2n) \times 2n}{2}=n(2n+1)$$

再考虑

$$\sum_{i=1}^n x_i + \sum_{i=1}^n y_i = \sum_{i=1}^n x_i + \sum_{i=1}^n (x_i + i) = \sum_{i=1}^n 2x_i + \sum_{i=1}^n i = 2\sum_{i=1}^n x_i + \dfrac{n(n+1)}{2}$$

那么有 
$$
\begin{aligned}
n(2n+1)&=2\sum_{i=1}^n x_i + \dfrac{n(n+1)}{2}\\
n(n-1)&\equiv0 \pmod 4\\
\end{aligned}
$$

故 $n$ 对 $4$ 取模的余数是 $0$ 或 $1$ 时存在这样的序列。

这就是从本题到兰福德问题的转换。

考虑如何构造这样的序列。

我们将序列分为若干个长度为 $\left\lfloor\dfrac{n}{4}\right\rfloor - 1$ 的子段以构造序列。

$n = 4m + 1$。

$1$，$1$，$4m-3$，$\cdots$，$2m + 1$（$m - 1$ 个奇数），$4m-1$，$2m - 2$，$\cdots$，$2$（$m-1$ 个偶数），$4m$，$2$，$\cdots$，$2m-2$（$m -1$ 个偶数），$2m + 1$，$\cdots$，$4m-3$（$m - 1$ 个奇数），$4m + 1$，$4m - 2$，$\cdots$，$2m + 2$（$m - 1$ 个偶数），$4m - 1$，$2m - 1$，$\cdots$，$3$（$m - 1$ 个奇数），$2m$，$4m$，$3$，$\cdots$，$2m - 1$（$m - 1$ 个奇数），$2m + 2$，$\cdots$，$4m - 2$（$m - 1$ 个偶数），$2m$，$4m + 1$。

$n = 4m$。

$1$，$1$，$4m-3$，$\cdots$，$2m + 1$（$m - 1$ 个奇数），$4m-1$，$2m - 2$，$\cdots$，$2$（$m-1$ 个偶数），$4m$，$2$，$\cdots$，$2m-2$（$m -1$ 个偶数），$2m + 1$，$\cdots$，$4m-3$（$m - 1$ 个奇数），$2m$，$4m - 2$，$\cdots$，$2m + 2$（$m - 1$ 个偶数），$4m - 1$，$2m - 1$，$\cdots$，$3$（$m - 1$ 个奇数），$2m$，$4m$，$3$，$\cdots$，$2m - 1$（$m - 1$ 个奇数），$2m + 2$，$\cdots$，$4m - 2$（$m - 1$ 个偶数）。

查询元素 $i$ 时查找子段的范围即可。

以上是标程做法。

```cpp
int m = n >> 2, a;
if(!((n & 3) - 1)) {
  for(int i = 1; i <= n; i ++) {
	if(i == 1) a = 1;
    else if(i >= 2 * m + 1 && i <= 4 * m - 3 && (i & 1)) a = 2 + (((4 * m - 3) - i) >> 1) + 1;
    else if(i == 4 * m - 1) a = 2 + m - 1 + 1;
    else if(i >= 2 && i <= 2 * m - 2 && !(i & 1)) a = 2 + m - 1 + 1 + (((2 * m - 2) - i) >> 1) + 1;
    else if(i == 4 * m) a = 2 + m - 1 + 1 + m - 1 + 1;
    else if(i == 4 * m + 1) a = 2 + m - 1 + 1 + m - 1 + 1 + m - 1 + m - 1 + 1;
    else if(i >= 2 * m + 2 && i <= 4 * m - 2 && !(i & 1)) a = 2 + m - 1 + 1 + m - 1 + 1 + m - 1 + m - 1 + 1 + (((4 * m - 2) - i) >> 1) + 1;
    else if(i >= 3 && i <= 2 * m - 1 && (i & 1)) a = 2 + m - 1 + 1 + m - 1 + 1 + m - 1 + m - 1 + 1 + m - 1 + 1 + (((2 * m - 1) - i) >> 1) + 1;
    else if(i == 2 * m) a = 2 + m - 1 + 1 + m - 1 + 1 + m - 1 + m - 1 + 1 + m - 1 + 1 + m - 1 + 1;
    std::cout << a + i << " " << a << std::endl;
  }
} else if(!(n & 3)) {
  for(int i = 1; i <= n; i ++) {
    if(i == 1) a = 1;
    else if(i >= 2 * m + 1 && i <= 4 * m - 3 && (i & 1)) a = 2 + (((4 * m - 3) - i) >> 1) + 1;
    else if(i == 4 * m - 1) a = 2 + m - 1 + 1;
    else if(i >= 2 && i <= 2 * m - 2 && !(i & 1)) a = 2 + m - 1 + 1 + (((2 * m - 2) - i) >> 1) + 1;
    else if(i == 4 * m) a = 2 + m - 1 + 1 + m - 1 + 1;
    else if(i == 2 * m) a = 2 + m - 1 + 1 + m - 1 + 1 + m - 1 + m - 1 + 1;
    else if(i >= 2 * m + 2 && i <= 4 * m - 2 && !(i & 1)) a = 2 + m - 1 + 1 + m - 1 + 1 + m - 1 + m - 1 + 1 + (((4 * m - 2) - i) >> 1) + 1;
    else if(i >= 3 && i <= 2 * m - 1 && (i & 1)) a = 2 + m - 1 + 1 + m - 1 + 1 + m - 1 + m - 1 + 1 + m - 1 + 1 + (((2 * m - 1) - i) >> 1) + 1;
    std::cout << a + i << " " << a << std::endl;
  }
} else {
  std::cout << "-1 0" << std::endl;
}
```
## 算法 $\bf 3$

考虑不用生成序列的方法。

$n = 4m + 1$。

用 $n + 1 \sim 2n$ 组成 $1 \sim n$ 的奇数，用 $1 \sim n$ 组成 $1 \sim n$ 的偶数。

以 $n + 1 \sim 2n$ 为例，这组数据的极差为 $n - 1$。我们可以生成 $1 \sim n - 1$ 的奇数。进行微调即可。

生成差为 $n$ 的数对 $\left(2m + 1, 6m + 2\right)$，差为 $2m - 1$ 的数对 $\left(2m + 2, 4m + 1\right)$。

不妨记录已被使用的数字。接下来在记录的情况下使用 $1 \sim n - 1$ 构造 $1 \sim n - 1$ 组成 $1 \sim n$ 的奇数。注意不能重复使用数字。

$n = 4m$。

与上面的方法同理。

用 $n + 1 \sim 2n$ 组成 $1 \sim n$ 的偶数，用 $1 \sim n$ 组成 $1 \sim n$ 的奇数。

生成差为 $n$ 的数对 $\left(2m + 1, 6m + 1\right)$，差为 $2m - 1$ 的数对 $\left(2m + 2, 4m + 1\right)$。

对于 $n \equiv 1 \pmod 4$ 的情况。

```cpp
for(int i = n - 1, j = 0; i >= 2; i -= 2, j ++) {
  v.push_back(make_pair(n * 2 - j, n * 2 - j - i));
}
int mid0 = n * 2 - n / 2, mid1 = n / 2 + 1;
v.push_back(make_pair(mid0, mid1)), v.push_back(make_pair(n, mid1 + 1));
int los = n - mid1 - 1;
for(int d = n - 2, l = 1, r = n - 1; d >= 3; d -= 2) {
  if (d == los) {
    v.push_back(make_pair(l + 1, l)), l += 2;
    continue;
  }
  v.push_back(r --, l ++);
}
```

对于 $n \equiv 1 \pmod 0$ 的情况。

```cpp
for(int i = n - 2, j = 0; i >= 2; i -= 2, j ++) {
  v.push_back(make_pair(n * 2 - j, n * 2 - j - i));
}
int mid0 = n * 2 - n / 2 + 1, mid1 = n / 2 + 1;
v.push_back(make_pair(mid0, mid1)), v.push_back(make_pair(n + 1, mid1 + 1));
int los = n - mid1;
for(int d = n - 1, l = 1, r = n; d >= 3; d -= 2) {
  if (d == los) {
    v.push_back(make_pair(l + 1, l)), l += 2;
    continue;
  }
  v.push_back(r--, l++);
}
```

我觉得还是算法 $3$ 更加优美。

---


# 「PMOI-5」棋盘

## 题目描述

给定一个无限大的棋盘（可以看做平面直角坐标系）和黑白子各 $n$ 颗，要求将黑白子不重叠地摆在棋盘的整点上，使得**恰好**存在 $n$ 条直线使得：

- 其穿过且**仅**穿过黑白子**共** 4 颗。

- 其按顺序穿过黑，白，白，黑子。

给出任意一种方案即可。

## 说明/提示

【样例解释】

样例 2 解释：（输出按顺序为点 $A\sim N$（点 $A\sim G$ 为白子，点 $H\sim N$ 为黑子），直线如图所示）。

![](https://cdn.luogu.com.cn/upload/image_hosting/zyo823p8.png)

【数据范围】

**本题采用捆绑测试。**

- Subtask 1（10 pts）：$n\equiv 0 \pmod{7}$；
- Subtask 2（20 pts）：$40\le n\le 400$；
- Subtask 3（30 pts）：$1\le n\le 9$；
- Subtask 4（40 pts）：无特殊限制。

对于 $100\%$ 的数据，$1\le n\le 10^3$。

[SPJ地址](https://www.luogu.com.cn/paste/eamtmrw5)

使用方法：编译为 `checker.exe` 后命令行同一目录下输入 ```checker.exe chessboard.in chessboard.out chessboard.ans```

需要搭配 `testlib.h` 一起使用，[testlib下载地址](https://github.com/MikeMirzayanov/testlib)。

如果发现 SPJ 出锅了请找出题人。

## 样例 #1

### 输入

```
1```

### 输出

```
NO```

## 样例 #2

### 输入

```
7```

### 输出

```
YES
2 4
2 6
4 6
5 4
6 4
6 2
4 2
0 6
2 8
6 6
8 2
6 0
3 0
2 2
```

# 题解

## 作者：Loser_King (赞：3)

# 「PMOI-5」C 棋盘题解

是出题人题解。

题外话：本篇题解中所有构造的时间复杂度都不超过 $O(n)$，但是因为出题人太逊，SPJ 是 $O(n^2\log n)$ 的，还带巨大常数，所以只开到了 $n\le 10^3$。

## Subtask 1（10 pts）：

该段分数满足：$n\equiv0\pmod{7}$。

考虑到样例中已经给出了 $n=7$ 时的构造，于是直接在平面内摆放多个 $n=7$​ 位移后的解即可。

需要注意的是这些解不仅直线不能有重叠，解和解之间的点也不能连成一条符合条件的直线。

std 的做法是每次画一个 $n=7$ 的解以后将当前 $x$ 坐标向右位移较大值，然后将 $x,y$ 同时向正方向位移 $n$ 单位，再将 $n$ 减 7。可以保证这样做在 $n\le 10^3$ 时不出错。

## Subtask 2（20 pts）：

该段分数满足：$40\le n\le 400$。

将样例中的点 $D$ 和点 $M$ 拿掉以后就形成了一组合法的 $n=6$ 的解。

观察到 Subtask 2 中所有的数都可以表示成 6 和 7 的和，于是拆分成 6 和 7 的和后摆放多个 $n=6$ 和 $n=7$ 的解即可。

## Subtask 3（30 pts）：

该段分数满足：$1\le n\le 9$。留给一些乱搞选手。~~真的有人乱搞过了这档分么？~~

$1\le n\le 4$ 时可证明是无解。

$5\le n\le 9$ 时，拿起笔分别画出 $n$ 角星，你会发现刚好满足条件。

赛后 upd：还真有不少人只过了这档分没过其他的。

~~其实感觉样例给的提示就比较明显了~~

## Subtask 4（40 pts）：

该段分数无特殊限制。

难道要拿出笔画出 $n(n\le 10^3)$ 角星么？其实大可不必。

将你所得的 $n=5\sim 9$ 的解按照 Subtask 1 的方法拼接起来即可。

std 做法是以 $n=6$ 时的解作为基本图形，然后 $n=7,9,10,11$ 的构造则由 $n=6,8$ 时的构造转变而来。

[spj/std/tester/mkdt/n=5~9的图片构造 地址](https://www.luogu.com.cn/paste/03iq64y2)



---

## 作者：int08 (赞：2)

# Solution
~~样例是重要的。~~ 看了样例，我们得到了 $n=7$ 的构造法。

![](https://cdn.luogu.com.cn/upload/image_hosting/zyo823p8.png)

但相信大家都看出来一个事实：去掉图中的 $D,M$ 点后即为规则的 $n=6$ 的解。

对称的，我们也可以构造出 $n=8$ 的解，然后通过类似办法构造出 $n=9$ 到 $n=11$ 的情况，这一项各位可以自己试试。

然后呢？一直这样构造不是个办法。

观察题目描述：

“……黑白子各 $n$ 颗……使得**恰好**存在 $n$ 条直线使得：”

一对棋子对应一条直线，意味着我们可以把一个较大的 $n$ 拆成很多个部分，然后保证每个部分正好满足棋子对数和满足条件的直线数相等，然后让不同部分之间不存在满足条件的直线。

仍然有三个主要问题等待我们解决：如何分部分，如何使不同部分之间没有满足条件的直线，有没有特殊情况。

## 1、特殊情况：$n=5$ 有解
我赛场上以为没有来着，事实上它是一个五角星形状，五个定点为黑，另外五个交点为白点，不太好构造，具体见我代码的特判部分

注：我没有在题解中加入一长段数字或图片是怕冗杂，也希望大家自己想想如何构造形状，具体的构造的点对见代码。

$n$ 小于等于 $4$ 则无解。
## 2、如何拆成很多个部分
我们发现，我们总可以把较大的 $n$ 拆解为很多个 $n=6$ 的基础部分，以及可能存在的一个 $n=7$ 到 $11$ 的情况（视 $n$ 除以 $6$ 余数决定）。

## 3、如何使不同部分之间没有满足条件的直线

最简单也最实用的办法：**使每个部分之间离远一点**，这也是我们的思路。

比如说，我们可以每部分都相对于上个部分，像右上方移动一个较大距离（$1000$ 左右的质数，再大可能超过 $5\times10^5$ 范围）。

[代码实现（$30$ 分）](https://www.luogu.com.cn/paste/ziluigqt)

获得了 $30$ 分的好成绩。为啥？因为整体来说各个部分仍在一条直线上，很难避免更多的合法直线。

**所以我们要将各部分偏移一些。**

偏移越混乱，越不容易产生合法直线。

想到了 $\text{rand}()$ 函数。

预处理一个 $ran$ 的前缀和数组来对应偏移即可。

好难解释啊，看代码吧。

# AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,j,p,pw[6][2]={{-2,0},{-2,2},{0,2},{2,0},{2,-2},{0,-2}};
int pb[6][2]={{-4,2},{-2,4},{2,2},{4,-2},{2,-4},{-2,-2}};
int main()
{
	cin>>n;
	int ran1[5000],ran2[5000];
	for(i=1;i<=2000;i++)
	{
		ran1[i]=rand()%256+1063+ran1[i-1];      //ran 数组使得偏移混乱
	}
	for(i=1;i<=2000;i++)
	{
		ran2[i]=rand()%137+212+ran2[i-1];
	}
	if(n<=4)
	{
		cout<<"NO";		
		return 0;				//n<5无解
	}
	cout<<"YES\n";
	if(n==5)
	{
		cout<<"0 0\n3 0\n0 2\n2 4\n4 2\n0 -6\n6 0\n0 6\n-2 0\n8 10\n";
		return 0;				//特判n=5的情况
	}
	for(i=0;6*i<=n-6;i++)
		for(j=0;j<6;j++)
			cout<<ran1[i]+pw[j][0]<<" "<<ran2[i]+pw[j][1]<<endl;		//每个n=6部分
	p=n-6*i;
	i--;
	if(p>=1) cout<<ran1[i]+1<<" "<<ran2[i]<<endl;
	if(p>=2) cout<<ran1[i]-1<<" "<<ran2[i]<<endl;
	if(p>=3) cout<<ran1[i]+5<<" "<<ran2[i]+4<<endl;
	if(p>=4) cout<<ran1[i]-5<<" "<<ran2[i]-4<<endl;
	if(p>=5) cout<<ran1[i]+4<<" "<<ran2[i]-4<<endl; 	//7-11部分
	for(i=0;6*i<=n-6;i++)
		for(j=0;j<6;j++)
			cout<<ran1[i]+pb[j][0]<<" "<<ran2[i]+pb[j][1]<<endl;
	p=n-6*i;
	i--;
	if(p>=1) cout<<ran1[i]-1<<" "<<ran2[i]-4<<endl;
	if(p>=2) cout<<ran1[i]+1<<" "<<ran2[i]+4<<endl;
	if(p>=3) cout<<ran1[i]+8<<" "<<ran2[i]+8<<endl;
	if(p>=4) cout<<ran1[i]-8<<" "<<ran2[i]-8<<endl;
	if(p>=5) cout<<ran1[i]+7<<" "<<ran2[i]-8<<endl;
	return 0;
} 
```
# The End.

---

## 作者：欧买歌 (赞：2)

易证 $n\le4$ 时无法构造。

对于 $5\le n\le 9$ 的情况，构造 $n$ 边形即可，我们在草稿构造出来 $n=5,6,8,9$ 的答案，$n=7$ 直接抄样例即可（代码中，crd 为坐标数组，第一维为 $n-5$，第二维前 $n$ 个点为白点，后 $n$ 个点为黑点，第三维分别为 $x$ 坐标和 $y$ 坐标）：
```cpp
int crd[5][18][2] = {
	{{1, 1}, {2, 2}, {0, 3}, {-2, 2}, {-1, 1}, {0, 0}, {4, 1}, {6, 6}, {-6, 6}, {-4, 1}},
	{{1, 1}, {2, 2}, {1, 3}, {-1, 1}, {-2, 2}, {-1, 3}, {0, 0}, {3, 1}, {3, 3}, {0, 4}, {-3, 1}, {-3, 3}},
	{{2, 4}, {2, 6}, {4, 6}, {5, 4}, {6, 4}, {6, 2}, {4, 2}, {0, 6}, {2, 8}, {6, 6}, {8, 2}, {6, 0}, {3, 0}, {2, 2}},
	{{1, 1}, {2, 2}, {2, 4}, {1, 5}, {-1, 1}, {-2, 2}, {-2, 4}, {-1, 5}, {0, 0}, {2, 1}, {3, 3}, {2, 5}, {0, 6}, {-2, 1}, {-3, 3}, {-2, 5}},
	{{6, 6}, {18, 18}, {18, 24}, {12, 30}, {0, 36}, {-6, 6}, {-18, 18}, {-18, 24}, {-12, 30}, {0, 0}, {18, 6}, {21, 21}, {18, 27}, {4, 38}, {-18, 6}, {-21, 21}, {-18, 27}, {-4, 38}}
};
```
对于 $N>9$ ( $N$ 为输入，$n$ 表示图形黑白点数)的情况，我们先放 $\left \lfloor \frac{N}{5}\right \rfloor-1$ 个 $n=5$ 情况的图形，再放一个 $n=N\bmod5-5(n=5,6,7,8,9)$ 情况的图形即可。

如何避免图形间产生冲突？题目给的范围足够大，我们可以完全随机放，冲突概率很低，实在不行换个种子。

白点直接输出，黑点需在全部白点输出完后才能输出，所以用一个 queue 队列记录黑点，最后再输出。
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
typedef pair<int,int> PR;
int n;
int crd[5][18][2] = {
	{{1, 1}, {2, 2}, {0, 3}, {-2, 2}, {-1, 1}, {0, 0}, {4, 1}, {6, 6}, {-6, 6}, {-4, 1}},
	{{1, 1}, {2, 2}, {1, 3}, {-1, 1}, {-2, 2}, {-1, 3}, {0, 0}, {3, 1}, {3, 3}, {0, 4}, {-3, 1}, {-3, 3}},
	{{2, 4}, {2, 6}, {4, 6}, {5, 4}, {6, 4}, {6, 2}, {4, 2}, {0, 6}, {2, 8}, {6, 6}, {8, 2}, {6, 0}, {3, 0}, {2, 2}},
	{{1, 1}, {2, 2}, {2, 4}, {1, 5}, {-1, 1}, {-2, 2}, {-2, 4}, {-1, 5}, {0, 0}, {2, 1}, {3, 3}, {2, 5}, {0, 6}, {-2, 1}, {-3, 3}, {-2, 5}},
	{{6, 6}, {18, 18}, {18, 24}, {12, 30}, {0, 36}, {-6, 6}, {-18, 18}, {-18, 24}, {-12, 30}, {0, 0}, {18, 6}, {21, 21}, {18, 27}, {4, 38}, {-18, 6}, {-21, 21}, {-18, 27}, {-4, 38}}
};
queue<PR> bl;
int main(){
	scanf("%d",&n);
	if (n <= 4) printf("NO\n");
	else{
		printf("YES\n");
		srand(23333);
		int q = n/5-1, r = n%5+5, x, y;
		while (q--){
			x = rand(); x = (x*1000+rand())%300000-150000;
			y = rand(); y = (y*1000+rand())%300000-150000; // 随机基准坐标
			for (int i=0;i<5;++i) printf("%d %d\n",x+crd[0][i][0],y+crd[0][i][1]);
			for (int i=5;i<10;++i) bl.push(PR{x+crd[0][i][0],y+crd[0][i][1]});
		}
		for (int i=0;i<r;++i) printf("%d %d\n",crd[r-5][i][0],crd[r-5][i][1]);
		for (int i=r;i<r*2;++i) bl.push(PR{crd[r-5][i][0],crd[r-5][i][1]});
		while (!bl.empty()){
			PR now = bl.front(); bl.pop();
			printf("%d %d\n",now.first,now.second);
		}
	}
    return 0;
}
```



------------


---

## 作者：Rubidium_Chloride (赞：1)

orz Loser_King

orz matrix67

orz Exactly Seven

想去看本题 idea 来源的可以去 [这个网站](https://matrix67.itch.io/exactly-seven) 的 第 7-7 关查看。

## Subtask 1

必然是给你把 $7$ 平移来平移去的，

但是不能产生冲突。

关于如何治疗这种东西，在讲正解的时候会说。

## Subtask 2

草，不会单独做。

## Subtask 3

~~nmd 为什么 n=5 不在这里面，调了半天。~~

大概是 $n=5,6,7,8,9$ 是有解的，构造方法在完整解答的代码里都有。

## Subtask 4

因为 $n=6$ 比较好构造，因此 $n\equiv 0\pmod 6$ 时都有解。

~~不要问我为什么不用 n=5 构造，要问就是没想到。~~

也就是说只要做出 $n=7,8,9,10,11$ 时的答案，$n$ 都可以做了。

如何不产生冲突呢，作者选择的方法是随机平移一个素数，虽然不能保证一定正确，但是似乎效果很不错（？）

代码略长，就放在 [云剪贴板](https://www.luogu.com.cn/paste/dtdis60l) 里面了。

## INF.后记

为什么 rated 赛，场上只有⑨个人过的题目是绿啊。

---


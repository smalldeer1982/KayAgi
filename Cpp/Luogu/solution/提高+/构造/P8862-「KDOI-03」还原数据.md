# 「KDOI-03」还原数据

## 题目描述

小 E 正在做一道经典题：

给定一个长度为 $n$ 的序列 $a$ 和 $q$ 个操作，操作共有 $2$ 种类型：

+ $\tt{1~l~r~x}$：对于所有 $l\le i\le r$，$a_i\leftarrow a_i+x$。
+ $\tt{2~l~r~x}$：对于所有 $l\le i\le r$，$a_i\leftarrow \max(a_i,x)$。

题目要求输出所有操作结束后的最终序列 $a'$。

小 E 迅速写了一份代码提交，但是发现，由于宇宙射线的影响，输入数据出现了一些小问题。具体地，对于所有 $2$ 操作，操作中给出的 $x$ 均被丢失了，也就是说，输入数据中的 $2$ 操作只剩下了 $\tt{2~l~r}$。输出数据则没有问题。小 E 现在想要通过剩余的数据恢复原来的输入数据，请你帮助他完成这个任务。

当然，可能会有多种合法的输入数据，你需要找到其中任意一种。数据保证有解。

## 说明/提示

**【样例 1 解释】**

所有合法输出需要满足：第 $1$ 个数 $\le3$，第 $2$ 个数恰好为 $20$。

**【样例 2】**

见选手文件中的 `restore/restore2.in` 与 `restore/restore2.ans`。

**【样例 3】**

见选手文件中的 `restore/restore3.in` 与 `restore/restore3.ans`。


***

**【数据范围】**

记 $q_2$ 为单组数据内 $2$ 操作的个数，$\sum n$ 为单个测试点内所有 $n$ 的和，$\sum q$ 为单个测试点内所有 $q$ 的和。

对于 $20\%$ 的数据，保证 $n,q\le50$，$\sum n,\sum q\le1~000$。

对于 $40\%$ 的数据，保证 $n,q\le1~000$，$\sum n,\sum q\le10^5$。

对于另外 $20\%$ 的数据，保证 $l=1,r=n$。

对于另外 $20\%$ 的数据，保证 $q_2\le100$。

对于 $100\%$ 的数据，保证 $1\le T\le 100$，$1\le n,q\le 10^5$，$1\le\sum n,\sum q\le 3\times10^5$，$-10^9\le a_i,x\le 10^9$，$-10^{15}\le a_i'\le10^{15}$， $q_2\ge1$。


***

**【校验器】**


本题样例文件较大，无法在附件中下载，请在选手文件中查看。

为了方便测试，在 $\texttt{restore}$ 目录下我们下发了 $\texttt{checker.cpp}$ 文件。你可以编译该文件，并使用它校验自己的输出文件。请注意它与最终评测时所用的校验器并不完全一致，你不需要也不应该关心其代码的具体内容。

编译命令为：

```plain
g++ checker.cpp -o checker -std=c++14
```

使用方式为：

```
./checker <inputfile> <outputfile> <answerfile>
```

校验器可能会返回以下状态中的其中一种：

+ $\tt{Accepted}$：表示你的输出完全正确。
+ $\tt{Wrong~answer~at~testcase~ x}$：表示你的输出在第 $x$ 个测试数据出错。

***

**【提示】**

本题输入输出量较大，推荐使用较快的输入输出方式。

KDOI 出题组温馨提示：**多测不清空，爆零两行泪。**


## 样例 #1

### 输入

```
1
5 3
1 2 3 4 5
2 3 5
1 3 4 2
2 1 1
20 2 5 6 5
```

### 输出

```
3 20```

# 题解

## 作者：Error_Yuan (赞：37)

T1 题解（定位：签到题）：

+ 由于 $\max$ 操作的贡献无法被后面的 $\max$ 操作抵消，倒序考虑操作，以 $a'$ 为初始数组，$1$ 操作加法变减法，对于 $2$ 操作，合法的 $x$ 一定要满足，$x\le$ 区间 $[l,r]$ 中的最小值，否则区间 $[l,r]$ 中的最小值经过正序操作后会大于最终值。

+ 而 $x$ 可以直接取等号，原因是要使得尽可能多的值达到最终值。

+ 由于保证有解，不需要进行额外判断。

+ 建议手动模拟一下过程。

+ 最终，写一颗支持区间加区间查询最小值的线段树即可。

+ 鲜花：本题本来有判断是否有解，数据给了 不可以，总司令 40。

---

## 作者：Sol1 (赞：5)

这里是一个想了 15 分钟怎么判无解然后发现不用判无解的弱智选手。

考虑最终状态对于每一时刻后的限制。这里定义初始状态为第 $0$ 时刻状态，最终状态为第 $q$ 时刻状态。

显然，最终状态对于第 $q$ 时刻的状态是全部相等。即：$b_{q,i}=a'_i$。

然后从后向前递推。如果第 $i$ 个操作是一个区间取 max 操作，我们可以把区间取 max 操作的值设定成 $b_{i,[l,r]}$ 内的最小值：因为再小就一点用处都没有，再大会违反限制。取最小值时，$[l,r]$ 以内所有值为最小值的限制都会由 $=$ 变为 $\leq$。

以样例 1 为例：考虑第三次操作后，限制由 $=20$ 变为 $\leq 20$；考虑第一次操作后，限制由 $\leq 20,=2,=3,=4,=5$ 变为 $\leq 20,=2,\leq 3,=4,=5$。

区间加操作很简单，把区间内限制的值减去操作的值即可。

$=$ 向 $\leq$ 的改变可以均摊，于是只需要维护区间最小值和区间加，可以直接使用线段树，复杂度 $O((n+q)\log n)$。

这个做法判无解也很容易：只需要看初始序列是否符合所有限制。但是在不需要判无解时，可以直接不区分限制里的 $=$ 和 $\leq$。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 0xAE3803 - 0xAA5100;

struct Segtree {
    pair <long long, int> val[N << 2];
    long long tag[N << 2];
    inline void Build(int p, int pl, int pr, long long *a) {
        tag[p] = 0;
        if (pl == pr) {
            val[p] = make_pair(a[pl], pl);
            return;
        }
        int mid = pl + pr >> 1;
        Build(p << 1, pl, mid, a); Build(p << 1 | 1, mid + 1, pr, a);
        val[p] = min(val[p << 1], val[p << 1 | 1]);
    }
    inline void Pushdown(int p) {
        tag[p << 1] += tag[p];
        val[p << 1].first += tag[p];
        tag[p << 1 | 1] += tag[p];
        val[p << 1 | 1].first += tag[p];
        tag[p] = 0;
    }
    inline void Modify(int p, int pl, int pr, int l, int r, long long v) {
        if (pl == l && pr == r) {
            tag[p] += v;
            val[p].first += v;
            return;
        }
        Pushdown(p);
        int mid = pl + pr >> 1;
        if (mid >= r) Modify(p << 1, pl, mid, l, r, v);
        else if (mid + 1 <= l) Modify(p << 1 | 1, mid + 1, pr, l, r, v);
        else {
            Modify(p << 1, pl, mid, l, mid, v);
            Modify(p << 1 | 1, mid + 1, pr, mid + 1, r, v);
        }
        val[p] = min(val[p << 1], val[p << 1 | 1]);
    }
    inline void setLeq(int p, int pl, int pr, int idx) {
        if (pl == pr) {
            val[p].second = 0xAE3803;
            return;
        }
        Pushdown(p);
        int mid = pl + pr >> 1;
        if (mid >= idx) setLeq(p << 1, pl, mid, idx);
        else setLeq(p << 1 | 1, mid + 1, pr, idx);
        val[p] = min(val[p << 1], val[p << 1 | 1]);
    }
    inline pair <long long, int> qMin(int p, int pl, int pr, int l, int r) {
        if (pl == l && pr == r) return val[p];
        Pushdown(p);
        int mid = pl + pr >> 1;
        if (mid >= r) return qMin(p << 1, pl, mid, l, r);
        else if (mid + 1 <= l) return qMin(p << 1 | 1, mid + 1, pr, l, r);
        else return min(qMin(p << 1, pl, mid, l, mid), qMin(p << 1 | 1, mid + 1, pr, mid + 1, r));
    }
};
int n, q, opt[N], l[N], r[N];
long long a[N], x[N], ad[N];
Segtree sgt;

inline void Read() {
    cin >> n >> q;
    for (int i = 1;i <= n;i++) cin >> a[i];
    for (int i = 1;i <= q;i++) {
        cin >> opt[i] >> l[i] >> r[i];
        if (opt[i] == 1) cin >> x[i];
    }
    for (int i = 1;i <= n;i++) cin >> ad[i];
}

inline void Solve() {
    sgt.Build(1, 1, n, ad);
    for (int i = q;i >= 1;i--) {
        if (opt[i] == 1) sgt.Modify(1, 1, n, l[i], r[i], -x[i]);
        else {
            pair <long long, int> res = sgt.qMin(1, 1, n, l[i], r[i]), cur = res;
            while (cur.first == res.first && cur.second <= n) {
                sgt.setLeq(1, 1, n, cur.second);
                cur = sgt.qMin(1, 1, n, l[i], r[i]);
            }
            x[i] = res.first;
        }
    }
    for (int i = 1;i <= q;i++) {
        if (opt[i] == 2) cout << x[i] << " ";
    }
    cout << endl;
}

int main() {
    std::ios::sync_with_stdio(0);
    int t;
    cin >> t;
    while (t--) {
        Read();
        Solve();
    }
    return 0;
}
```

---

## 作者：麦克斯韦の妖 (赞：3)

### P8862 「KDOI-03」还原数据

[题目链接](https://www.luogu.com.cn/problem/P8862)

很好的一题。个人做法：线段树+差分。

考虑 $a_i$ 在加值和取 $\max$ 的过程中，共加了 $x$ ,那么最后得到的 $a'_i \ge a_i+x$ 。


记：对于 $a_i$ 到 $a'_i$ 的过程中，一共经历的 $1$ 操作让 $a_i$ 共加了 $S_i$。那么在某一次 $2$ 操作时，如果 $a_i$ 已经加了 $k$ （只考虑 $1$ 操作，即后面还要加 $S_i-k$），那么当前得 $x$ 至多为 $a'_i-S_i+k$ ，否则最后一定大于 $a'_i$。

对于第 $k$ 次 $2$ 操作，令 $x_k= \min (a'_i-S_i+k),i\in [l_k,r_k]$
。不难发现如此构造一定符合要求（因为数据保证有解，所以每次取最大值的最小值）。

接下来就是如何快速求出 $S_i$ 和 $x_i$。

发现我们求 $S_i$ 的过程即区间加值。不难想到差分，好写好调。

对于 $x_i$ ，建一棵线段树，初值赋 $a'_i-S_i$ ，维护区间加，区间最小。

代码如下：（ ``cr`` 为 $2$ 操作得答案，即 $x_i$）

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define ls o<<1
#define rs o<<1|1
using namespace std;
typedef long long ll;
const int N=1e5+10;
const ll maxn=1e15;
const ll minn=-1e15;
void read(ll &x)
{
	int fx=1;
	x=0;
	char ch=getchar();
	while(ch<'0' || ch>'9')
	{
		if(ch=='-') fx=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	x=x*fx;
}
int n,q;
ll a[N];
ll b[N];
ll d[N],s[N],ss[N];
struct Node{
	int type; // 1: add    2: max
	int l,r;
	ll x;    // if type = 1
	ll cr;    // if type = 2
}p[N];
struct T{
	ll minx;
	ll lazy;
}tr[N<<2];
void pushup(int o)
{
	tr[o].minx=min(tr[ls].minx,tr[rs].minx);
}
void build(int o,int l,int r)
{
	tr[o].lazy=0;
	if(l==r)
	{
		tr[o].minx=d[l];
		return ;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	pushup(o);
}
void pushdown(int o)
{
	if(tr[o].lazy)
	{
		tr[ls].lazy+=tr[o].lazy;
		tr[rs].lazy+=tr[o].lazy;
		tr[ls].minx+=tr[o].lazy;
		tr[rs].minx+=tr[o].lazy;
		tr[o].lazy=0;
	}
}
void update(int o,int l,int r,int L,int R,int x)
{
	if(l>R || r<L) return;
	if(l>=L && r<=R)
	{
		tr[o].lazy+=x;
		tr[o].minx+=x;
		return;
	}
	pushdown(o);
	int mid=(l+r)>>1;
	update(ls,l,mid,L,R,x);
	update(rs,mid+1,r,L,R,x);
	pushup(o);
}
ll query(int o,int l,int r,int L,int R)
{
	if(l>R || r<L) return maxn;
	if(l>=L && r<=R)
	{
		return tr[o].minx;
	}
	pushdown(o);
	int mid=(l+r)>>1;
	return min(query(ls,l,mid,L,R),query(rs,mid+1,r,L,R));
}
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d",&n,&q);
		for(int i=1;i<=n;i++)
		{
			d[i]=s[i]=0;
			ss[i]=0;
			read(a[i]);
		}
		for(int i=1;i<=q;i++)
		{
			ll op,l,r;
			read(op);
			read(l);
			read(r);
			p[i].l=l,p[i].r=r;
			if(op==1)
			{
				p[i].type=1;
				ll x;
				read(x);
				p[i].x=x;
				ss[p[i].l]+=x;
				ss[p[i].r+1]-=x;		
			}
			else 
			{
				p[i].type=2;
				p[i].cr=maxn;
			}
		}
		for(int i=1;i<=n;i++)
		{
			s[i]=s[i-1]+ss[i];
		}
		for(int i=1;i<=n;i++)
		{
			read(b[i]);
			d[i]=b[i]-s[i];
		}
		build(1,1,n);
		for(int i=1;i<=q;i++)
		{
			if(p[i].type==2)
			{
				p[i].cr=query(1,1,n,p[i].l,p[i].r);
			}
			else
			{
				update(1,1,n,p[i].l,p[i].r,p[i].x);
			}
		}
		for(int i=1;i<=q;i++)
		{
			if(p[i].type==2)
			{
				printf("%lld ",p[i].cr);
			}
		} 
		printf("\n");
	}
} 
```




---

## 作者：Strelitzia_ (赞：2)

## 题目大意

有一道题：

给定一个长度为 $n$ 的序列 $a$ 和 $q$ 个操作，操作共有 $2$ 种类型：
+ $\tt{1~l~r~x}$：对于所有 $l\le i\le r$，$a_i\leftarrow a_i+x$。
+ $\tt{2~l~r~x}$：对于所有 $l\le i\le r$，$a_i\leftarrow \max(a_i,x)$。

题目要求输出所有操作结束后的最终序列 $a_1$。

现在，给出开始的序列 $a$、结束后的序列 $a_1$、所有 $1$ 操作的 $l,r,x$ 以及所有 $2$ 操作的 $l,r$（未给出 $x$），让你还原所有的 $2$ 操作。所有操作均按顺序给出。

------------
## 思路

我们先考虑暴力怎么写。

一个显然的事实是：第二个操作不会让这个区间内的数更小。也就是说，我们把忽略所有操作二后得到的序列记作 $a_2$，对于任意的 $1\le i\le n$，有 $a_{1_i}\ge a_{2_i}$。我们不妨设 $c_i=a_{1_i}-a_{2_i}$。

我们再观察一下操作二。我们发现，操作二会使 $[l,r]$ 区间内的每一个数都加上一个 $t$（对于每一个数 $t$ 不一定相同，且 $t\ge 0$）。那也就是说，最后的 $d_i$ 其实是由多个操作二的 $t$ 贡献过来的。

那么我们的做法就有了：我们先跑一边只有操作一的过程，获得 $d_i$ 同时记下来原数组，第二次再跑一遍：

- 当前为操作一时，正常修改；
- 当前为操作二时，（记此时序列为 $a_3$）我们对 $[l,r]$ 找到一个最大的 $x$ 使得对于任意的 $l\le i\le r$ 都有 $\max(a_{3_i},x)\le a_{1_i}$，以这个 $x$ 作为当前操作二的 $x$ 再按题意修改。

那么我们最后得到的答案一定合法吗？考虑对于每一次操作二，我们都将其改成了目前能改成的最大值，那么我们最后得到的就是 $a_1$。

那么操作二的 $x$ 怎么找呢？边跑边维护新的 $c_i$，每一次对一个数操作二之后将 $a_{3_i}$ 加上的数减到 $c_i$ 上，这样我们就有：

$$x=\displaystyle\min_{i=l}^{r}c_i+a_{3_i}$$

于是我们写出如下暴力代码：

```cpp
void sol() {
	n = read(), hop = 0, q = read();
	for (int i = 1; i <= n; i++) a[i] = d[i] = read();
	for (int i = 1; i <= q; i++) {
		qq[i].type = read(), qq[i].l = read(), qq[i].r = read();
		if (qq[i].type == 2) continue;
		qq[i].x = read();
		for (int j = qq[i].l; j <= qq[i].r; j++) a[j] += qq[i].x;
	}
	for (int i = 1; i <= n; i++) b[i] = read(), c[i] = b[i] - a[i];
	for (int i = 1; i <= q; i++) {
		if (qq[i].type == 1) {
			for (int j = qq[i].l; j <= qq[i].r; j++) d[j] += qq[i].x;
			continue;
		}
		int nowmn = INF;
		for (int j = qq[i].l; j <= qq[i].r; j++) nowmn = min(nowmn, d[j] + c[j]);
		ans[++hop] = nowmn;
		for (int j = qq[i].l; j <= qq[i].r; j++)
			c[j] -= max(0, nowmn - d[j]), d[j] = max(d[j], nowmn);
	}
	for (int i = 1; i <= hop; i++) printf("%lld ", ans[i]);
	puts("");
}
```

------------
考虑如何优化上一个过程。

第一次扫：区间加，单点查询，线段树搞定。

对于第二次扫，我们发现：每一次操作二之后事实上都不会改变 $a_{3_i}$ 与 $c_i$ 的和，每一次操作一相当于给 $a_{3_i}$ 进行一个区间加，操作二只需要查询一个最小值存起来。

于是我们就知道了第二次扫的过程：维护 $c_i+a_{3_i}$，区间加，区间查询最小值，还是用线段树搞定。

最后这道题我们就做完了。注意重建线段树的时候把下传用的懒标记也清空。代码如下：

```cpp
int a[N], b[N], c[N], d[N], n, q, ans[N], hop, t;
struct Q {
	int l, r, type, x;
} qq[N];
namespace Seg1 {
	struct T {
		int l, r, sum, flg_s, mn;
	} t[N];
	void build(int nowary[], int p, int l, int r) {
		t[p].l = l, t[p].r = r, t[p].flg_s = 0;
		if (l == r) {
			t[p].sum = nowary[l], t[p].mn = nowary[l];
			return;
		}
		build(nowary, p << 1, l, (l + r) >> 1), build(nowary, p << 1 | 1, ((l + r) >> 1) + 1, r);
		t[p].sum = t[p << 1].sum + t[p << 1 | 1].sum;
		t[p].mn = min(t[p << 1].mn, t[p << 1 | 1].mn);
	}
	void push(int p) {
		if (!t[p].flg_s) return;
		t[p << 1].flg_s += t[p].flg_s, t[p << 1 | 1].flg_s += t[p].flg_s;
		t[p << 1].sum += (t[p << 1].r - t[p << 1].l + 1) * t[p].flg_s;
		t[p << 1 | 1].sum += (t[p << 1 | 1].r - t[p << 1 | 1].l + 1) * t[p].flg_s;
		t[p << 1].mn += t[p].flg_s, t[p << 1 | 1].mn += t[p].flg_s, t[p].flg_s = 0;
	}
	void change(int p, int l, int r, int x) {
		if (t[p].l >= l && t[p].r <= r) {
			t[p].flg_s += x, t[p].sum += (t[p].r - t[p].l + 1) * x;
			return;
		}
		push(p);
		int mid = (t[p].l + t[p].r) >> 1;
		if (l <= mid) change(p << 1, l, r, x);
		if (r > mid) change(p << 1 | 1, l, r, x);
		t[p].sum = t[p << 1].sum + t[p << 1 | 1].sum;
		t[p].mn = min(t[p << 1].mn, t[p << 1 | 1].mn);
	}
	int assk_sum(int p, int l, int r) {
		if (t[p].l >= l && t[p].r <= r) return t[p].sum;
		push(p);
		int mid = (t[p].l + t[p].r) >> 1, res = 0;
		if (l <= mid) res = assk_sum(p << 1, l, r);
		return r > mid ? res + assk_sum(p << 1 | 1, l, r) : res;
	}
	int assk_mn(int p, int l, int r) {
		if (t[p].l >= l && t[p].r <= r) return t[p].mn;
		push(p);
		int mid = (t[p].l + t[p].r) >> 1, res = INF;
		if (l <= mid) res = assk_mn(p << 1, l, r);
		return r > mid ? min(res, assk_mn(p << 1 | 1, l, r)) : res;
	}
}
void sol() {
	n = read(), q = read(), hop = 0;
	for (int i = 1; i <= n; i++) a[i] = read();
	Seg1::build(a, 1, 1, n);
	for (int i = 1; i <= q; i++) {
		qq[i].type = read(), qq[i].l = read(), qq[i].r = read();
		if (qq[i].type == 2) continue;
		qq[i].x = read();
		Seg1::change(1, qq[i].l, qq[i].r, qq[i].x);
	}
	for (int i = 1; i <= n; i++)
		b[i] = read(), c[i] = b[i] - Seg1::assk_sum(1, i, i), d[i] = c[i] + a[i];
	Seg1::build(d, 1, 1, n);
	for (int i = 1; i <= q; i++) {
		if (qq[i].type == 1) Seg1::change(1, qq[i].l, qq[i].r, qq[i].x);
		else ans[++hop] = Seg1::assk_mn(1, qq[i].l, qq[i].r);
	}
	for (int i = 1; i <= hop; i++) printf("%lld ", ans[i]);
	puts("");
}
signed main() {
	t = read();
	for (int i = 1; i <= t; i++) sol();
}
```

---

## 作者：xiaoPanda (赞：2)

## Solution
首先可以看出，之前的 $\max$ 操作会被之后的 $\max$ 操作覆盖，考虑倒着解决问题。

那么问题转化成：对于最终的数列 $a'$，通过一系列的区间减和区间取 $\min$，得到最先的数列 $a$，构造每次取 $\min$ 的 $x$。

注意到如何时刻数列的数永远比上一个时刻大。

通过观察，设当前的数列为 $na$，可以得出一个合法的方案 $x=\min_{i=1}^nn a_i$，证明如下：

记 $mn=\min_{i=1}^n na_i$，若 $x>mn$，则反过来操作（即顺着操作）该操作是 $mn=\max(mn,x)=x$，无法得到 $mn$，故 $x\le mn$。

然后证明 $x=mn$ 一定是解，记 $mn'(mn'\le mn)$ 表示在此次操作之后的最小值（即顺着操作时的上一步的最小值），注意到反过来操作（即顺着操作）时 $mn=\max(mn',x)$，当 $x=mn$ 时不用关心 $mn'$ 的取值，所以一直都取 $x=mn$ 一定可以得到最终答案。

$\text{Upd}$：$x<mn$ 并不是代表一定无解，这代表 $mn=mn'$，那么代表之前的一次操作的 $x$ 要较大才可以，但这可能会导致两种情况：
+ 另一次的 $x$ 要较小，并且为了这个要求，还有一个 $x$ 要较大，一个 $x$ 要较小······
+ 在这个操作的区间前面没有 $\max$ 操作了，无法得出 $mn'$。

综上所述，可以用一颗线段树来维护。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
using db=double;
using ll=long long;
using vi=vector<int>;
using pii=pair<int,int>;
using pq=priority_queue<int,vector<int>,greater<int> >;
using ull=unsigned long long;
#define ft first
#define sd second
#define gc getchar
#define pb push_back
#define emp emplace_back
#define mp make_pair
#define ls p*2
#define rs p*2+1
#define sz(a) (int)a.size()
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define ROF(i,a,b) for(int i=a;i>=b;i--)
#define int long long
const int N=1e6+7;
const int mod=998244353;
const int INF=(1ll<<60);
const int inf=INT_MAX;
void read(int &x)
{
	char ch=getchar();
	int r=0,w=1;
	while(!isdigit(ch))w=ch=='-'?-1:1,ch=getchar();
	while(isdigit(ch))r=(r<<3)+(r<<1)+(ch^48),ch=getchar();
	x=r*w;
}
void write(int x) {
	char ch[20];
	int len = 0;
	if (x < 0)putchar('-'), x = -x;
	while (x) {
		ch[len++] = (x % 10) ^ 48;
		x /= 10;
	}
	if(len==0)printf("0");
	while (len--)putchar(ch[len]);
	putchar(' ');
}
int mn[N],lazy[N],a[N],op[N],tl[N],tr[N],tx[N],ans[N];
void addlazy(int p,int x)
{
	mn[p]+=x;
	lazy[p]+=x;
}
void pushdown(int p)
{
	addlazy(ls,lazy[p]);
	addlazy(rs,lazy[p]);
	lazy[p]=0;
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		mn[p]=a[l];
		return;
	}
	int mid=(l+r)/2;
	build(ls,l,mid);
	build(rs,mid+1,r);
	mn[p]=min(mn[ls],mn[rs]);
}
void add(int p,int l,int r,int L,int R,int x)
{
	if(L<=l&&r<=R)
	{
		addlazy(p,x);
		return;
	}
	pushdown(p);
	int mid=(l+r)/2;
	if(L<=mid)add(ls,l,mid,L,R,x);
	if(R>mid)add(rs,mid+1,r,L,R,x);
	mn[p]=min(mn[ls],mn[rs]);
}
int query(int p,int l,int r,int L,int R)
{
	if(L<=l&&r<=R)return mn[p];
	int mid=(l+r)/2,mn=INF;
	pushdown(p);
	if(L<=mid)mn=min(mn,query(ls,l,mid,L,R));
	if(R>mid)mn=min(mn,query(rs,mid+1,r,L,R));
	return mn;
}
void solve()
{
	int n,q,tot=0;
	read(n),read(q);
	memset(lazy,0,sizeof lazy);
	FOR(i,1,n)read(a[i]);
	FOR(i,1,q)
	{
		read(op[i]),read(tl[i]),read(tr[i]);
		if(op[i]==1)read(tx[i]);
	}
	FOR(i,1,n)read(a[i]);
	build(1,1,n);
	ROF(i,q,1)
	{
		if(op[i]==1)add(1,1,n,tl[i],tr[i],-tx[i]);
		else
		{
			int Mn=query(1,1,n,tl[i],tr[i]);
			ans[++tot]=Mn;//注意到不用关心mn'的值，这里甚至不用更新
		}
	}
	ROF(i,tot,1)write(ans[i]);
	puts("");
}
signed main()
{
	int T;
	read(T);
	while(T--)solve();
    return 0;
}
```


---

## 作者：happybob (赞：1)

考虑操作逆序，那么对于操作 $1$，加法变成减法。

问题在于对于操作二，如何找到答案。

显然我们可以发现，经过这次操作二后，序列中的每个数都 $\geq$ 这次操作二的答案，于是操作二的答案必然 $\leq$ 这个操作二的区间最小值。

我们可以发现，答案应取区间最小值，因为假如答案可以小于区间最小值，那么取区间最小值时一定也可以。

线段树维护即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int N = 1e5 + 5, INF = 2e9, MOD = 1e9 + 7;

inline int read()
{
	int op = 1, x = 0;
	char ch = getchar();
	while ((ch < '0' || ch > '9') && ch != '-') ch = getchar();
	while (ch == '-')
	{
		op = -op;
		ch = getchar();
	}
	while (ch >= '0' and ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x * op;
}

inline void write(int x)
{
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) write(x / 10);
	putchar(x % 10 + '0');
}

int n, q, t, a[N], b[N];

struct Modify
{
	int op, l, r, x;
	Modify(int _op, int _l, int _r, int _x): op(_op), l(_l), r(_r), x(_x){}
	Modify(){}
}G[N];

class SegmentTree
{
public:
	struct Node
	{
		int l, r, add, minn;
	}tr[N << 2];
	void pushup(int u)
	{
		tr[u].minn = min(tr[u << 1].minn, tr[u << 1 | 1].minn);
	}
	void pushdown(int u)
	{
		auto &rt = tr[u], &lf = tr[u << 1], &rit = tr[u << 1 | 1];
		if (rt.add != 0)
		{
			lf.add += rt.add;
			lf.minn += rt.add;
			rit.add += rt.add;
			rit.minn += rt.add;
			rt.add = 0;
		}
	}
	void build(int u, int l, int r)
	{
		tr[u] = { l, r, 0, b[l] };
		if (l == r) return;
		int mid = l + r >> 1;
		build(u << 1, l, mid);
		build(u << 1 | 1, mid + 1, r);
		pushup(u);
	}
	void update(int u, int l, int r, int x)
	{
		if (tr[u].l >= l and tr[u].r <= r)
		{
			tr[u].add += x;
			tr[u].minn += x;
			return;
		}
		pushdown(u);
		int mid = tr[u].l + tr[u].r >> 1;
		if (l <= mid) update(u << 1, l, r, x);
		if (r > mid) update(u << 1 | 1, l, r, x);
		pushup(u);
	}
	int query(int u, int l, int r)
	{
		if (tr[u].l >= l and tr[u].r <= r)
		{
			return tr[u].minn;
		}
		pushdown(u);
		int mid = tr[u].l + tr[u].r >> 1, res = (int)1e16;
		if (l <= mid) res = query(u << 1, l, r);
		if (r > mid) res = min(res, query(u << 1 | 1, l, r));
		return res;
	}
}f;

signed main()
{
	// freopen("*.in", "r", stdin);
	// freopen("*.out", "w", stdout);
	scanf("%lld", &t);
	while (t--)
	{
		scanf("%lld%lld", &n, &q);
		for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
		for (int i = q; i >= 1; i--)
		{
			scanf("%lld%lld%lld", &G[i].op, &G[i].l, &G[i].r);
			if (G[i].op == 1) scanf("%lld", &G[i].x);
		}
		for (int i = 1; i <= n; i++) scanf("%lld", &b[i]);
		f.build(1, 1, n);
		vector<int> ans;
		for (int i = 1; i <= q; i++)
		{
			if (G[i].op == 1) f.update(1, G[i].l, G[i].r, -G[i].x);
			else 
			{
				ans.push_back(f.query(1, G[i].l, G[i].r));
			}
		}
		for (int i = ans.size() - 1; i >= 0; i--) printf("%lld ", ans[i]);
		printf("\n");
	}
	return 0;
}
```


---

## 作者：Dregen_Yor (赞：1)

[更好的阅读体验](https://dregen-yor.eu.org/2022/11/21/p8862/)。

# 思路

~~首先得出这道题必须离线处理。~~

## 错误思路：正序处理

因为我们已知所有操作一的信息，如果忽略操作二，根据操作一的信息可以计算出最终数组与题目中给出数组的差，这个差必须由操作二补上。

我们考虑用 $delta_i$ 记录忽略操作二后所得数组中第 $i$ 个数与最终数组中第 $i$ 个数的差，正序遍历每个操作，对于操作一用线段树直接维护，对于每个操作二，我们维护区间中每个数加上 $delta_i$ 之后的最小值，用他来当作本次操作的 $x$，对与区间中变大了的数 $j$，从 $delta_j$ 中减去相应变大的值。

但如果这样处理的话，我们会发现，区间内每个 $delta_i$ 变化的值是不一样的，没有办法直接维护，必须遍历每个点进行操作，这样的复杂度显然是不对的。

## 正确思路：倒序处理

我们考虑从最终数组出发，从后向前处理每个操作。

对于每个操作一，将加 $x$ 改为减 $x$ 即可。

对于每个操作二，因为操作二会对序列中每个值都进行操作，我们可以取当前序列中的最小值，这样处理后，无论操作前的序列是什么样的，可以保证序列中不会有任何一个数大于最终序列，且最小的那个值一定会等于最终序列。

由于题目保证有解，所以不需要任何特判，直接输出按上面的方法得到的每个操作二 $x$ 即可。

# 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 100010
#define ls x<<1
#define rs x<<1|1
using namespace std;
struct nod{
    int op,l,r,x;
}qy[N];
int T,n,m,a[N],A[N];
int sum[N<<2],tag[N<<2];
vector <int> ans;
void bulid(int x,int l,int r){
    tag[x]=0;
    if(l==r){
        sum[x]=A[l];
        return;
    }
    int mid=(l+r)>>1;
    bulid(ls,l,mid);
    bulid(rs,mid+1,r);
    sum[x]=min(sum[ls],sum[rs]);
}
inline void pushdown(int x){
    sum[ls]+=tag[x];
    sum[rs]+=tag[x];
    tag[ls]+=tag[x];
    tag[rs]+=tag[x];
    tag[x]=0;
}
void update(int x,int l,int r,int L,int R,int data){
    if(l>=L&&r<=R){
        sum[x]+=data;
        tag[x]+=data;
        return;
    }
    if(tag[x]){
        pushdown(x);
    }
    int mid=(l+r)>>1;
    if(L<=mid){
        update(ls,l,mid,L,R,data);
    }
    if(R>mid){
        update(rs,mid+1,r,L,R,data);
    }
    sum[x]=min(sum[ls],sum[rs]);
}
int query(int x,int l,int r,int L,int R){
    if(l>=L&&r<=R){
        return sum[x];
    }
    if(tag[x]){
        pushdown(x);
    }
    int res=1e9;
    int mid=(l+r)>>1;
    if(L<=mid){
        res=min(res,query(ls,l,mid,L,R));
    }
    if(R>mid){
        res=min(res,query(rs,mid+1,r,L,R));
    }
    return res;
}
signed main(){
    scanf("%lld",&T);
    while(T--){
        scanf("%lld%lld",&n,&m);
        ans.clear();
        for(int i=1;i<=n;i++){
            scanf("%lld",&a[i]);
        }
        for(int i=1;i<=m;i++){
            scanf("%lld",&qy[i].op);
            if(qy[i].op==1){
                scanf("%lld%lld%lld",&qy[i].l,&qy[i].r,&qy[i].x);
            }
            else{
                scanf("%lld%lld",&qy[i].l,&qy[i].r);
            }
        }
        for(int i=1;i<=n;i++){
            scanf("%lld",&A[i]);
        }
        bulid(1,1,n);
        for(int i=m;i;--i){
            if(qy[i].op==1){
                update(1,1,n,qy[i].l,qy[i].r,-qy[i].x);
            }
            else{
                ans.push_back(query(1,1,n,qy[i].l,qy[i].r));
            }
        }
        for(int i=ans.size()-1;i>=0;--i){
            printf("%lld ",ans[i]);
        }
        putchar('\n');
    }
    return 0;
}
```


---

## 作者：Micnation_AFO (赞：0)

不妨考虑从最终序列入手，**倒序处理 $q$ 次操作：**

- 对于一个 $\texttt{1}$ 操作，我们可以在最终序列上减去 $x$。这样就得到了这一步操作之前的序列。

- 对于一个 $\texttt{2}$ 操作，那么答案一定是 $[l, r]$ 区间内的最小值（或小于这个最小值）。考虑反证：如果答案不是这样，那么 $[l, r]$ 之间一定会有值改变，那么经过后面的一些操作，答案一定不等于最终序列。

那么可以使用线段树，支持区间加，维护区间最小值即可。

记得多组清空时清空懒标记。

代码：
```cpp
#include <bits/stdc++.h>

using namespace std;
#define int long long

const int N = 100010;
const int INF = 1e15;

struct SegmentTree {
    int l, r;
    int dat, add;
} t[N << 2];

int T;
int n, q;
int op[N], a[N], b[N], c[N];
int l[N], r[N], x[N];

int read() {
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') { f = (ch == '-' ? -1 : f); ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}

void push_up(SegmentTree &fa, SegmentTree ls, SegmentTree rs) {
    fa.dat = min(ls.dat, rs.dat);
}

void build(int p, int l, int r) {
    t[p].l = l, t[p].r = r;
    if (l == r) { t[p].dat = b[l], t[p].add = 0; return; }
    int mid = (l + r) >> 1;
    build(p << 1, l, mid), build((p << 1) | 1, mid + 1, r);
    push_up(t[p], t[p << 1], t[(p << 1) | 1]), t[p].add = 0;
}

void spread(int p) {
    if (t[p].add) {
        t[p << 1].dat += t[p].add;
        t[(p << 1) | 1].dat += t[p].add;
        t[p << 1].add += t[p].add, t[(p << 1) | 1].add += t[p].add;
        t[p].add = 0;
    }
}

void change(int p, int l, int r, int v) {
    if (l <= t[p].l && r >= t[p].r) {
        t[p].dat += v;
        t[p].add += v;
        return;
    }
    spread(p);
    int mid = (t[p].l + t[p].r) >> 1;
    if (l <= mid) change(p << 1, l, r, v);
    if (r > mid) change((p << 1) | 1, l, r, v);
    push_up(t[p], t[p << 1], t[(p << 1) | 1]);
}

int ask(int p, int l, int r) {
    if (l <= t[p].l && r >= t[p].r) return t[p].dat;
    spread(p);
    int mid = (t[p].l + t[p].r) >> 1, val = INF;
    if (l <= mid) val = min(val, ask(p << 1, l, r));
    if (r > mid) val = min(val, ask((p << 1) | 1, l, r));
    return val;
}

void init() {
    n = read(), q = read();
    for (int i = 1; i <= n; i++) a[i] = read();
    for (int i = 1; i <= q; i++) {
        op[i] = read(), l[i] = read(), r[i] = read();
        if (op[i] == 1) x[i] = read();
    }
    for (int i = 1; i <= n; i++) b[i] = read();
    build(1, 1, n);
}

void solve() {
    for (int i = q; i >= 1; i--) {
        if (op[i] == 1) change(1, l[i], r[i], -x[i]);
        else x[i] = ask(1, l[i], r[i]);
    }
}

void output() {
    for (int i = 1; i <= q; i++) {
        if (op[i] == 1) continue;
        printf("%lld ", x[i]);
    }
    puts("");
}

signed main() {
    // freopen("restore.in", "r", stdin);
    // freopen("restore.out", "w", stdout);
    T = read();
    while (T--) {
        init();
        solve();
        output();
    }
    return 0;
}
```

---


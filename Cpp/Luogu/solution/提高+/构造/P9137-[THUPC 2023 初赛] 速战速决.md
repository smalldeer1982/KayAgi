# [THUPC 2023 初赛] 速战速决

## 题目描述

小 I 与小 J 正在玩一个叫做“开火车”，又称作“拖板车”和“小猫钓鱼”的扑克游戏。游戏规则如下，注意其与一般玩法可能有不同：

- 有 $2n$ 张牌，其中对于整数 $1 \le i \le n$，牌面为 $i$ 的牌恰好有 $2$ 张。
- 游戏开始时，小 I 和小 J 各拿其中 $n$ 张牌组成双方的初始手牌。
- 维护一个公共牌堆（可以将其看作一个栈），初始没有牌。小 I 与小 J 依次行动，小 I 先手。一次行动时，行动方依次进行以下操作：
  1. 将手牌中的一张牌放在公共牌堆顶；
  2. 若此时公共牌堆中有两张相同的牌，则这两张相同的牌以及在这两张牌之间的所有牌从公共牌堆移到当前行动方手牌中；
  3. 若此时当前行动方没有手牌，则当前行动方失败，另一方胜利。

小 J 是扑克萌新，所以会按照以下策略行动：

- 维护一个队列，初始将 $n$ 张手牌按照一定顺序放入队列中；
- 每次行动时，将队列开头的牌放在公共牌堆顶；
- 若小 J 放入某张牌后公共牌堆中有两张相同的牌，则按照在公共牌堆中自顶到底的顺序将获得的牌放入队列尾。

小 I 通过偷看得到了小 J 的策略以及队列中牌的顺序。现在小 I 不仅想获胜，还想速战速决，用**最少**的行动次数获胜，但他也是扑克萌新。所以给定小 J 队列中的 $n$ 张牌以及它们的顺序，你需要给出小 I 的策略，使得小 I 能够获胜，同时行动次数最少，或者告诉他这是不可能的。

## 说明/提示

#### 样例解释 1

![](https://cdn.luogu.com.cn/upload/image_hosting/m1asrjdd.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/x5w65xlc.png)

#### 子任务

对于所有测试数据，$1 \le n \le 3 \times 10^5$，$1 \le a_1,a_2,\cdots, a_n \le n$，且每个整数在序列 $a$ 中至多出现两次。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
3
1 3 3
```

### 输出

```
3
2 1 2
```

## 样例 #2

### 输入

```
1
1```

### 输出

```
-1```

# 题解

## 作者：Yikuwa (赞：5)

我们将小 I 的初始手牌分为两种情况：手中有两张相同的牌或没有。

容易发现后者等价于小 I 手中的牌为一个 $1$ 到 $n$ 的排列，这种情况下由于小 I 打出的第一张牌的另一半一定在小 J 手上，所以小 J 至少能够收回一次牌。

我们猜测小 I 存在一种方法能够使得小 J 只收回一次牌且收回牌数为 $2$，构造简单：

题目给出小 J 的出牌顺序 $:a_1,a_2,a_3,...a_n,a_n,a_n$

小 I 的出牌方法 $:a_n,a_1,a_2,a_3,...,a_{n-1},a_1,a_1$

解释 ：先打 $a_n$，之后 $n-1$ 轮打小 J 上一轮打出的牌，这样 $n$ 轮之后小 J 手上只剩两张 $a_n$，小 I 连着打两张相同的牌即可。

这样我们就做完了初始手牌为排列的情况。

接下来处理小 I 手中存在两张相同的牌的情况，设小 I 初始手中有两张编号为 $k$ 的牌。

我们考虑先打其中一张 $k$，接下来时刻保持小 I 手中存在一张牌与牌堆底部的牌编号相同，这样的好处就是我们可以在每一次小 J 可能收牌前把牌堆抽完，保证小 J 收不到牌，从而在 $n$ 轮交换后结束游戏。

考虑如何维护，不妨设当前牌堆底部牌为 $x$，小 I 手中有另一张 $x$，小 J 下一张要打的牌为 $y$。

分情况讨论：

- 另一张 $y$ 在牌堆中，此时如果不及时将牌堆中的 $y$ 收回，下一轮小 J 打出的 $y$ 就能形成收牌操作，所以此时小 I 打出 $x$ 清空牌堆，将牌堆中的 $y$ 收在手上，同时保证了下一回合小 J 打出 $y$ 后新牌堆顶 $y$ 的另一张在小 I 手中。

- 另一张 $y$ 在小 I 手上，这种情况其实可收可不收，但是为了方便，我们同第一种情况打出 $x$ 收回整个牌堆，同样保证新牌堆顶 $y$ 的另一张在小 I 手中。

- 另一张 $y$ 在小 J 手上，此时小 I 随便打一张牌就可以了，但是注意不能把手中与牌堆顶相同的那张牌打出去。

至此，我们已经做完了这道题，具体在代码中，我们需要维护牌堆和记录每个牌的位置（是否在小 I 手中和是否在牌堆中），为了方便处理可以维护小 I 的手牌。写起来有些细节。


```cpp
#include<bits/stdc++.h>
#define reg register
#define IL inline
using namespace std;
//#define getchar() (_S==_T&&(_T=(_S=_B)+fread(_B,1,1<<15,stdin),_S==_T)?EOF:*_S++)
char _C,_B[1<<15],*_S=_B,*_T=_B;
IL int read(){
    reg int x=0,y=1;
    for(_C=getchar();!isdigit(_C);_C=getchar())if(_C=='-')y=-1;
    for(;isdigit(_C);_C=getchar())x=(x<<1)+(x<<3)+(_C^48);
    return x*y;
}
const int N=3e5+7;
int n,cnt[N],a[N],in[N],s[N],top,Ans[N];
queue<int>q;
IL void Push(reg int x){in[s[++top]=x]=1;}
IL void Pop(reg int x){
    while(s[top]!=x)++cnt[s[top]],in[s[top]]=0,q.push(s[top--]);
    ++cnt[x],in[x]=0,q.push(x),--top;
}


IL int work(){
    printf("%d\n%d ",n+2,a[n]);
    for(reg int i=1;i<n;++i)printf("%d ",a[i]);
    printf("%d %d",a[1],a[1]);
    return 0;
}


signed main(){
    for(reg int i=n=read();i;--i)cnt[i]=2;
    if(n==1)return !puts("-1");
    for(reg int i=1;i<=n;++i)--cnt[a[i]=read()];
    reg int Start=0;
    for(reg int i=n;i&&!Start;--i)if(cnt[i]==2)Start=i;
    for(reg int i=n;i;--i)for(reg int j=cnt[i]-(Start==i);j;--j)q.push(i);
    
    if(!Start)return work();
    
    Push(Ans[0]=Start),--cnt[Ans[0]];
    for(reg int i=1;i<n;++i){
        Push(a[i]);
        if(cnt[a[i+1]]||in[a[i+1]]){
            Pop(Ans[i]=s[1]);
        }
        else{
            q.front()==s[1]?q.push(s[1]),q.pop():void();
            if(in[Ans[i]=q.front()]){
                Pop(Ans[i]);
            }
            else{
                Push(Ans[i]),--cnt[Ans[i]];
                q.pop();
            }
        }
    }
    printf("%d\n",n);
    for(reg int i=0;i<n;++i)printf("%d ",Ans[i]);
    return 0;
}
```



---

## 作者：听取MLE声一片 (赞：4)

我是纯纯口胡人，因为代码能力过低全部交给队友了。

如果对面只有一张牌，那么我们先出牌必然被对方抵消，所以无解。

如果对面所有牌互不相同，也就是说我们和对面的牌一样，我们的策略为对面出一张我们立刻抵消。但是由于我们是先手，所以必须要舍弃一个。先出对方牌的最后一张，再按照上述策略进行，对面最后会出最后一张牌来拿回。我们只需要连续出两张相同的牌把对面的牌夹住就可以获得胜利，步数为 $n+2$。

我们把相同的两张牌称为“一对”。

可以发现如果对面出一张我们有的牌，我们可以立即拿我们有的牌消除，称为操作 $A$。

如果对面只有一个一对，我们也必然会拥有一个一对。我们先出自己的一对中的一个，不断进行操作 $A$ 直到对面把他出他的一对中的一个。这时候我们拿我们那一对中的另一个把所有牌全收起来，这样他就拿不回去了。后面继续进行 $A$ 操作，步数为 $n$。

对于对面有多个一对，考虑拓展上述做法。

如果对面一对的两个连着一块，我们可以同时打出一对进行抵消，称为操作 $B$。我们在开始的时候进行此操作，保证后续进来的是单独的数。

进行 $A$ 操作直到进入的数为一对中的一个。如果满足操作 $B$ 的条件就进行然后返回，否则这一对是分开的。

考虑处理分开的情况。我们不能立刻进行消除，因为如果对面又叠上来一对我们就寄了。所以在这个时候向右枚举直到对面出现单个或者对面有一个出现两次时停止。

单个的原因是不处理对面也收不回去，有一个要出现两次是因为我把前面的收过来对面的也成单个了，也收不回去。中间不断输出自己的对保证不会被消即可。

重复进行上述操作直到完成即可。

代码：

```
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
int n,a[300005],tj[300005],cs[300005],d,ok[300005],bj[300005],cl[300005];
int main()
{
    int tp=0;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        if(tj[a[i]]) tp=1;
        tj[a[i]]++;
    }
    if(n==1){cout<<-1;return 0;}
    if(tp==0)
    {
        cout<<n+2<<endl;
        cout<<a[n]<<" ";
        for(int i=1;i<n;i++) cout<<a[i]<<" ";
        cout<<a[1]<<" "<<a[1];
        return 0;
    }
    else
    {
        cout<<n<<endl;
        vector<int> dd;
        for(int i=1;i<=n;i++)
        {
            if(tj[i]==0) dd.push_back(i);
            if(tj[i]!=2) ok[i]=1;
        }
        for(int i=1;i<=n;i++)
            if(tj[i]==0)
            {
                d=i;break;
            }
        int be=1;
        while(a[be]==a[be+1]&&be<=n)
        {
            cout<<d<<" "<<d<<" ";
            be+=2;
        }
        if(be>n) return 0;
        cout<<d<<" ";
        int i=be;
        while(i<n)
        {
            if(ok[a[i]]==1){cout<<a[i]<<" ";i++;}
            else
            {
                if(i<n&&a[i]==a[i+1])
                {
                    cout<<d<<" ";if(i+1==n) break;
                    cout<<d<<" ";i+=2;continue;
                }
                int now=i+1;bj[a[i]]=1;int cnt=1;
                while(now<=n&&tj[a[now]]==2&&!bj[a[now]])
                    bj[a[now]]=1,now++;
                int p=1;
                for(int j=i;j<=now-2;j++)
                {
                    cout<<dd[p]<<" ";p++;
                    ok[a[j]]=1;
                }
                cout<<d<<" ";i=now;
                if(i>=n) break;
                cout<<d<<" ";i++;
//				for(int j=1;j<=cnt;j++) bj[cl[j]]=0;
            }
        }
    }
    return 0;
}
```



---

## 作者：cryozwq (赞：2)

显然答案至少为 $n$，事实上只有一种情况答案会大于 $n$，就是对方手上每种牌各一张，很显然这种情况答案为 $n+2$，特判掉，接下来提出一种构造方式说明其他情况答案都是 $n$。

我们称一个人有两张的牌是对子，注意到排除了上面一种情况对面和我们都一定有对子，分情况讨论

- 对面第一张出对子

我们先手出一张对子，然后第二轮出对子的另一张，收走对面第一张，此时相当于先手转移到对面，之后对面每张牌如果不是对子，下一轮我们就跟一样的，否则如果是对子的第一张，就走我们新的一个对子第一张（注意到两个人对子数量一样，所以总是能拿出新的对子），然后某个时刻对面下一张要出之前某个对子第二张了，我们就先打和对面这个对子匹配的那个对子第二张，此时相当于先手回到我们，但是打第二张的时候，会导致本来打算打的单牌没打，于是就打这张，先手回到对面。

- 对面第一张不是对子

先手出一张对子第一张，之后按上述流程即可。

---

## 作者：Unnamed114514 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P9137)

好题。

$n=1$ 必败显然。

首先容易想到队首是最关键的，如果先手有牌和队首的牌一样，那么先手随时可以清空队列。

容易想到先手最优的办法是控制后手尽量少拿牌。

那么若先手有 $2$ 张同一张牌，那么先手可以把这张牌放队首。然后我们就可以做到随时清空，问题就是让先手拿到队列的控制权。

- 若后手此时可以拿牌，先手出队首的牌，这样的话后手的牌放队首后，和队首匹配的牌在先手手上，先手仍然可以控牌。

- 否则先手随便出一张牌，保证不会清空整个队列，并且不和后手的下一张牌相匹配。注意这样的话队列的控制权仍然在先手手中，并且此时我们并不需要考虑它和前面的牌匹配的情况，因为此时队列里面的牌一定是会被先手拿到的，而且后手一定不会拿到牌。注意这里不能直接枚举先手的牌，但是我们可以直接随机数找一下就行了，注意这里找到的概率使非常可观的。

答案就是 $n$。

***

否则的话先手和后手拿的牌都是 $[1,n]$，容易想到此时队首的控制权一定不在先手，所以我们显然要使后手拿牌最少，即 $2$ 张。

此时，先手只需要在队首放后手最后出的一张牌，前面的牌全部拿了。这样 $n$ 次操作后，后手只剩 $2$ 张牌，并且这两张牌相互匹配。此时该先手出牌，随便出一张就行了，后手出牌之后直接出和队首一样的牌，这样的话后手出完牌就输了。

答案就是 $n+2$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+5;
int n,a[N],cnt[N];
bool vis[N];
deque<int> q;
int main(){
	mt19937 rnd(time(0));
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	if(n==1){
		cout<<-1<<endl;
		return 0;
	}
	for(int i=1;i<=n;++i) cin>>a[i],++cnt[a[i]];
	for(int i=1;i<=n;++i) cnt[i]=2-cnt[i];
	for(int i=1;i<=n;++i) if(cnt[i]>=2){
		cout<<n<<endl;
		cout<<i<<' ',vis[i]=1,q.push_back(i),--cnt[i];
		q.push_back(a[1]),vis[a[1]]=1;
		for(int j=2;j<=n;++j){
			if(vis[a[j]]){
				cout<<q.front()<<' ';
				while(q.size()) ++cnt[q.back()],vis[q.back()]=0,q.pop_back();
			} else{
				int w=rnd()%n+1;
				while(w==q.front()||!cnt[w]||w==a[j]) w=rnd()%n+1;
				--cnt[w],vis[w]=1,q.push_back(w);
				cout<<w<<' ';
			}
			q.push_back(a[j]),vis[a[j]]=1;
		}
		cout<<endl;
		return 0;
	}
	cout<<n+2<<endl;
	cout<<a[n]<<' ';
	for(int i=1;i<n;++i) cout<<a[i]<<' ';
	cout<<a[1]<<' '<<a[1]<<endl;
	return 0;
}
```

---

## 作者：Genius_Star (赞：1)

### 思路：

~~小贪心，似乎一眼秒了……~~

贪心思路是：

- 因为自己是先手，所以刚开始放牌是应该是放一张自己有两张的牌，这样可以在后面的时间内收回来。

所以说，只要保持了栈底是自己有的牌，那么就可以做到很大的优势，可以做到时刻收牌。

之后，分情况讨论：

- 如果当前对方要出的牌牌堆里面有，那么让对方出的话，是可以收到牌的，肯定是对自己不利的；或者说出的牌在自己的手牌里有，这样的话，自己可能在后面的随机出牌中将此牌打出，导致对方可以消掉这张牌。

- 所以我们出牌的时候所以说我们可以直接出一张和栈底相同的牌，直接全部收掉。

这样，栈底的数会变为当前对方手里的牌，因为之前说了 “当前对方要出的牌牌堆里面有”，所以我们手里依旧有和栈底一样的牌。

- 否则的话，如果我们此时收牌，会不保持栈底是自己有的牌，所以可以随机出一张不是栈底的牌。

这样的话，保证的是：对方每回合丢掉一张牌，不会收到其他牌，总回合数是 $n$。

**维护自己当前有的牌时，可以用一个 set 维护。**

**特殊情况：**

1. 若自己没有两张一样的牌，即双方的牌一样。

策略：

- 先随意出一张牌，之后对方每出一张牌，自己有，就给消除掉，否则的话，对方出的牌就是自己先出的那张牌。

- 这样进行 $n$ 轮之后，对方有两张自己刚开始出的牌，自己有其他的所有牌。

- 因为现在是自己出牌，先任意出一张牌，对方出一张牌，自己再出一张和自己之前随意出的一样的牌，这样可以把对方出的牌消掉，之后对方再打出来就没有手牌了。

- 总回合数为 $n+2$。

2. 若 $n=1$：

- 自己先手，会被对方之间消掉，输出 $-1$。

时间复杂度：$O(N \log N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=400400;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
template<class T> //手写双端队列
class Deque{
public:
	ll cnt=0;
	T a[N];
	bool empty(){
		return (cnt==0);
	}
	void push(T x){
		a[++cnt]=x;
	}
	T front(){
		return a[1];
	}
	T top(){
		return a[cnt];
	}
	void pop(){
		--cnt;
	}
};
ll n,l,cnt=0;
ll a[N],s[N];
bool flag=1;
bool f[N]; //牌 i 是否在公共牌堆中
set<ll> S; //当前自己有的牌
Deque<ll> P; //公共牌堆
int main(){
//	freopen("A.in","r",stdin);
//	freopen("A.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++)
	  s[i]=2;
	for(int i=1;i<=n;i++){
		a[i]=read(); 
		s[a[i]]--;
	}
	if(n==1){
		puts("-1");
		exit(0);
	}
	for(int i=1;i<=n;i++)
	  flag&=(s[i]==1);
	if(flag){ //特殊情况
		write(n+2);
		putchar('\n');
		write(a[n]);
		putchar(' ');
		for(int i=1;i<=(n-1);i++){
			write(a[i]);
			putchar(' ');
		}
		write(a[1]);
		putchar(' ');
		write(a[1]);
		putchar(' ');
		exit(0);		
	}
	for(int i=1;i<=n;i++){ //找到一个有两个牌
		if(s[i]==2){
			l=i;
			break;
		}
	}
	for(int i=1;i<=n;i++)
	  if(s[i]) 
		S.insert(i);
	write(n);
	putchar('\n');
	write(l);
	putchar(' ');
	P.push(l);
	s[l]--;
	f[l]=1;
	P.push(a[1]);
	f[a[1]]=1;
	for(int i=2;i<=n;i++){
		if(f[a[i]]||S.count(a[i])){ 
			write(P.front()); //收掉整个牌堆
			putchar(' ');
			while(!P.empty()){
				ll t=P.top();
				f[t]=0;
				s[t]++;
				if(s[t]==1) 
				  S.insert(t);
				P.pop();
			}
		}
		else{
			ll x;
			auto it=S.end(); // 取自己手牌最大值
			it--;
			if(*it==P.front()) // 不能和栈底相等 
			  it--;
			x=*it;
			write(x);
			putchar(' ');
			if(!f[x]){ //若不在牌堆中
				P.push(x);
				s[x]--;
				if(!s[x]) 
				  S.erase(x);
				f[x]=1;
			}
			else{ //若在牌堆中，需要消掉一些
				while(!P.empty()){
					ll t=P.top();
					f[t]=0;
					s[t]++;
					if(s[t]==1) 
					  S.insert(t);
					P.pop();
					if(t==x)
					  break;
				}
			}
		}
		P.push(a[i]);
		f[a[i]]=1;
	}
	return 0;
}
```


---

## 作者：Leasier (赞：1)

想了 1.5h，被嘲讽了 /dk

------------

样例告诉我们 $n = 1$ 时无解。

当 $n > 1$，让对方收走自己的牌一定不优，考虑避免这种情况的发生。

若 $a_i$ 两两不同，这种情况必然会出现，手玩一下可以得出一种花费 $n + 2$ 步的最优解：

- $a_n, a_1, a_2, \cdots, a_{n - 1}, a_1, a_1$。

接下来考虑 $a_i$ 并非两两不同的情况，此时我们有一个简单的策略：

- 在栈底垫上自己拥有的牌，使得我们可以在适当时刻收牌。

于是可以考虑一开始随便取一种自己有两张的牌垫在下面。

在时刻 $i$，若栈内有一张 $a_i$，若不收牌则后手会收牌，于是先手可以考虑收牌，此后栈底变为 $a_i$，先手手里也有了一张 $a_i$。

那如果没有 $a_i$ 呢？若另一张 $a_i$ 在后手手中，此时收牌会让后手在接下来的某时刻收牌——这是我们不希望看到的；否则，若另一张 $a_i$ 在先手手中，先手也不能在此时出 $a_i$，因为这样会让后手收走得到两张 $a_i$。

于是先手可以取一种自己有一张且不为 $a_i$ 的牌。

以上操作方式保证了栈底始终是一种先手有的牌，则后手每次都会恰好失去一张牌，则总次数为 $n$，达到下界。

用一个 set 记录自己拥有的恰好一张的牌的种类，模拟即可。时间复杂度为 $O(n \log n)$。

代码：
```cpp
#include <iostream>
#include <set>

using namespace std;

int cnt[300007], a[300007], stk[300007];
bool vis[300007];
set<int> s;

int main(){
	int n;
	cin >> n;
	if (n == 1){
		cout << -1;
		return 0;
	}
	bool flag = true;
	for (int i = 1; i <= n; i++){
		cnt[i] = 2;
	}
	for (int i = 1; i <= n; i++){
		cin >> a[i];
		cnt[a[i]]--;
	}
	for (int i = 1; i <= n; i++){
		if (cnt[i] != 1){
			flag = false;
			break;
		}
	}
	if (flag){
		cout << n + 2 << endl;
		cout << a[n] << " ";
		for (int i = 2; i <= n; i++){
			cout << a[i - 1] << " ";
		}
		cout << a[1] << " " << a[1];
		return 0;
	}
	int fst, top = 0;
	for (int i = 1; i <= n; i++){
		if (cnt[i] == 2){
			fst = i;
			break;
		}
	}
	for (int i = 1; i <= n; i++){
		if (cnt[i] > 0) s.insert(i);
	}
	cout << n << endl;
	for (int i = 1; i <= n; i++){
		if (i == 1){
			cout << fst << " ";
			stk[++top] = fst;
			cnt[fst]--;
			vis[fst] = true;
		} else if (vis[a[i]] || s.count(a[i])){
			cout << stk[1] << " ";
			while (top > 0){
				vis[stk[top]] = false;
				if (++cnt[stk[top]] == 1) s.insert(stk[top]);
				top--;
			}
		} else {
			int x;
			set<int>::iterator it = s.begin();
			if (*it == stk[1]) it++;
			x = *it;
			cout << x << " ";
			if (!vis[x]){
				stk[++top] = x;
				if (--cnt[x] == 0) s.erase(x);
				vis[x] = true;
			} else {
				while (top > 0){
					vis[stk[top]] = false;
					if (++cnt[stk[top]] == 1) s.insert(stk[top]);
					if (stk[top] == x) break;
					top--;
				}
			}
		}
		stk[++top] = a[i];
		vis[a[i]] = true;
	}
	return 0;
}
```

---

## 作者：Disjoint_cat (赞：1)

# [P9137 速战速决](https://www.luogu.com.cn/problem/P9137)

## 题意

有一个游戏（具体看原题面，~~不会有人不看题面就来看题解吧~~），你知道对方的牌和策略，你需要走最少的步数获胜。

数据范围：$n\le3\times10^5$。

## 题解

下称「小 I」为「你」，「小 J」为「对方」。

典型构造 + 分讨题。

显然理论答案最小是 $n$。

但是考虑你的第一张牌，如果另一张这种牌在对方手上，那迟早会被对方拿走一次。

所以你如果每种牌都恰有一个，答案大于 $n$。而你至少有两张牌要被拿到对方手上，所以答案至少是 $n+2$。

一个可行的构造是：

$$a_n,a_1,a_2,a_3,\cdots,a_{n-1},a_1,a_1.$$

也就是说，先拿张 $a_n$ 当炮灰，然后别人打 $a_1\sim a_{n-1}$ 时立刻拿走，然后被拿走两张 $a_n$，最后用两张 $a_1$ 拖走对方的 $a_n$。

特殊的，当 $n=1$ 时根据样例答案是 $-1$。

然后讨论你**至少一种牌有两张**的情况。

设这种牌之一是 $x$。

首先如果对方**现在**这种牌只有一张，直接用自己对应的牌把他弄走就行了。

我们可以把 $x$ **垫在第一张**，然后只要对方的下一张是有两张的，我们就把它**夹走**（也就是在其后面放 $x$）。

但是这样是不成立的。比如对方 $1\ 2\ 2\ 1$，你把人家 $1$ 夹走了，但是你来不及再把 $x$ 垫上去对方就已经把 $2$ 放上去了。

于是我们考虑每次把对方的**一连串两张的牌**收走。例如上面的例子，我们可以连续把 $1\ 2$ 收走，这样只要在两个 $x$ 之间插一个别的牌就行了。

然后由于对方两组对牌间一定有至少一张单牌，所以总有机会再把 $x$ 放上去。虽然这样做会落下对方一张单牌（没拿到自己手中），但是不会影响自己胜利（因为对方没有最后一张牌也拿不走）。

至此，本题已做完，时间复杂度 $\Theta(n)$。

实现起来有一些细节，比如要注意插进去的牌，不要让他把前面落下的单牌收走（可能会出现一些问题）。

---

## 作者：ni_ju_ge (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P9137)
## 思路
显然，尽量少地让小 J 收牌可以使得步数最小。
### 当手中的牌没有两张相同时
此时无论出什么牌，小 J 总是可以收至少一次牌。可以先出小 J 最后出的牌，然后每次出小 J 上一次出的牌，这样小 J 最后只能收走最开始的牌，此时出任意两张相同牌就赢了，步数为 $n+2$。
### 当手中的牌有两张相同时
可以先出相同牌中的一张，之后每当小 J 可以收牌时，就出另一张收走全部牌，这样小 J 的牌会放在队首，而对应牌仍然在小 I 手中。否则随机出一张牌就行，注意不要出队首的牌。步数为 $n$。

注意 $n=1$ 时无解。
## 代码
```cpp
#include<bits/stdc++.h>
#include<time.h>
using namespace std;
int n,a[314514],d[314514],p[314514],q[314514],r;
bool fl;
int main() {
	srand(time(0));
	cin>>n;
	for(int i=1;i<=n;i++) {
		cin>>a[i];
		p[a[i]]++;
		if(p[a[i]]>=2) fl=true;//判断是那种情况 
	}
	if(n==1) {
		cout<<-1<<endl;
		return 0;
	}
	if(fl) {
		cout<<n<<endl;
		int x;
		r=0;
		for(int i=1;i<=n;i++) {
			p[i]=2-p[i];
			if(p[i]==2) {
				x=i;
			}
		}
		cout<<x<<" ";
		d[x]++,d[a[1]]++,q[++r]=x,q[++r]=a[1];
		for(int i=2;i<=n;i++) {
			if(d[a[i]]) {
				cout<<q[1]<<" ";
				while(r) {//清空排队 
					p[q[r]]++;
					d[q[r]]--;
					r--;
				}
			} else {
				int k=rand()%n+1;//随机出牌就行 
				while(p[k]==0||k==q[1]||k==a[i]) k=rand()%n+1;
				p[k]--,d[k]++,q[++r]=k;
				cout<<k<<" ";
			}
			d[a[i]]++,q[++r]=a[i];
		}
	} else {
		cout<<n+2<<endl;
		cout<<a[n];
		for(int i=1;i<n;i++) cout<<a[i];
		cout<<a[1]<<" "<<a[1];
	}
} 
```

---

## 作者：naught (赞：0)

# [THUPC 2023 初赛] 速战速决

## 题目描述

题意清晰，不再过多赘述。

## Solution

每张不同的卡是等效的。

小 $J$ 手上的卡牌只有 $2$ 种情况：手上没有相同的牌和有相同的牌。

**情况 $1$：**

小 $J$ 手上 的牌等价于 $1 \sim n$（但其实没用），令其手上的牌为 $b_1, b_2,\ldots,b_n$。

由于要“速战速决”，所以尽量让 $J$ 少拿牌（这个在情况 $2$ 中也适用），那么如何让 $J$ 少拿牌呢？

因为手牌为排列，所以 $I$ 手上每张牌 $J$ 都有一张复制，同理 $J$ 上每张牌 $I$ 中也有一张复制。

前者的说法是因为 $I$ 先手，垫下去的第一张牌一定会被 $J$ 回收；后者是因为，只要第一张牌不被 $J$ 回收，我们可以视为少 $1$ 张牌+$J$ 先手，如此除了放的第一张牌其他所有牌都能回收。

那么我们放的第一张牌就很显然了，即 $b_n$，之后 $J$ 每打一张牌，我们跟同一张，即可在 $n$ 次后使得 $J$ 手牌中是两张 $b_n$，其他所有牌在 $I$ 手上，此时轮到 $I$ 先手，随便放一张牌 $x$，待 $J$ 打出 $b_n$ 后再打出一张 $x$，$J$ 出完一张 $b_n$ 后就会因无牌而败了。

综上，操作次数为 $n+2$，操作序列为 $b_n, b_1, b_2,\ldots, b_{n-1}, b_1, b_1$。

**情况 $2$：**

假设 $J$ 将打出第 $i$ 张牌和第 $i+1$ 牌：

* $b_i$ 是一张单牌（即另一张牌 $x = b_i$ 在 $I$ 手上）：打出 $x$ 将其收回即可。

* $b_i$ 不是一张单牌但另一张牌 $x = b_i$ 不是下一张被打出的牌：学习情况 $1$ 中的策略，只要保证 $b_i$ 的收回只能收 $2$ 张即可。

* $b_i$ 不是一张单牌且 $b_{i+1} = b_i$：在 $J$ 下次打出 $b_i$ 前提前垫一张不是单牌 $x$，在其打出 $b_i$ 后打出另一张 $x$ 将 $b_i$ 回收即可。

操作 $1$ 等价于操作 $1$ 次得 $1$ 张牌，操作 $2$ 等价于操作 $2$ 次得 $2$ 张牌，操作 $3$ 等价于操作 $2$ 次得 $2$ 张牌，总共要从 $J$ 处获得 $n-1$ 张牌，所以要操作 $n-1$ 次，算上第一次先手垫的 $1$ 张牌，总操作数为 $n$ 次。

代码实现就显然了。

## 代码
```cpp
//written by Naught
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
#define Maxn 300005
#define fo(i, l, r) for (int i = l; i <= r; ++i)
#define fr(i, r, l) for (int i = l; i >= r; --i)
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21], *p1 = buf, *p2 = buf;
inline int read(int x=0, bool f=0, char c=getchar()) {for(;!isdigit(c);c=getchar()) f^=!(c^45);for(;isdigit(c);c=getchar()) x=(x<<1)+(x<<3)+(c^48);return f?-x:x;}

int n, b[Maxn], cnt[Maxn], lst, ind[Maxn], s[Maxn], top, ans[Maxn];
queue<int> q;

void push(int x) {ind[s[++top] = x] = 1;}

void pop(int x)
{
    while(s[top] != x) ++cnt[s[top]], ind[s[top]] = 0, q.push(s[top--]);
    ++cnt[x], ind[x] = 0, q.push(x), --top;
}

int main()
{
    n = read();
    if(n == 1) return puts("-1"), 0;
    fo(i, 1, n) cnt[i] = 2;
    fo(i, 1, n) b[i] = read(), --cnt[b[i]];
    fr(i, 1, n) if(cnt[i] == 2) {lst = i; break;}
    fr(i, 1, n) fr(j, 1, cnt[i]-(lst == i)) q.push(i);

    if(lst == 0)
    {
        printf("%d\n%d ", n+2, b[n]);
        fo(i, 1, n-1) printf("%d ", b[i]);
        printf("%d %d", b[1], b[1]);
        return 0;
    }

    push(ans[0] = lst), --cnt[ans[0]];
    fo(i, 1, n-1)
    {
        push(b[i]);
        if(cnt[b[i+1]] || ind[b[i+1]]) pop(ans[i] = s[1]);
        else
        {
            if(q.front() == s[1]) q.push(s[1]), q.pop();
            if(ind[ans[i] = q.front()]) pop(ans[i]);
            else push(ans[i]), --cnt[ans[i]], q.pop();
        }
    }

    printf("%d\n", n);
    fo(i, 0, n-1) printf("%d ", ans[i]);

    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

### 题目大意

用一种最少的行动次数和其出牌策略让小 I 胜利。

### Solution：

如果小 J 有两张相同的牌的话，那么小 I 肯定也会有两张相同的牌。

因此小 J 有两张相同的牌的第一张牌可以被小 I 的两张相同的牌一前一后包夹收掉。

如果小 J 有一张单张的牌，再他出了以后小 I 直接出于其相同的牌，以直接收掉。

优先处理单张的牌情况，再处理两张相同的牌的情况。

如果遇到单张的牌在最后面的情况，可以不用处理，因为小 J 已经没有牌了。

这样填一定只会用 $n$ 行动次数，如果按照上面两种填法填好以后还有空位置，那么可以用小 I 拥有的两张相同的牌把所有空位置填满，不用担心只有两张，因为小 I 一定会把牌收回来，不会影响答案的正确性。

当然会有两种特殊情况。

第一种：$n=1$ 的情况。

小 I 无论如何必败，直接输出 $-1$ 即可

第二种：小 J 和小 I 都没有两张相同的牌情况。

这种情况小 J 至少能收掉一次小 I 的牌。

小 I 第一张出小 J 最后要出的牌，接着小 J 出什么小 I 就出什么。小 J 出最后一张时会把小 I 出第一张收掉，然后小 I 再出两张自己拥有的相同的牌，既能胜利。

code：

```cpp
#include<cstdio>
int n,l,r,s,t,o=0,O=0,mid,a[1000005],b[1000005],c[1000005],d[1000005],f[1000005],h[1000005],sum=0;
void Add(int x,int y){for(int i=x;i<=n;i+=i&-i)f[i]+=y;return;}
int Find(int x){int y=0;for(int i=x;i>0;i-=i&-i)y+=f[i];return y;}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]),b[a[i]]++,sum+=b[a[i]]/2,Add(i,1);
    if(n==1){printf("-1");return 0;}
    if(sum==0){
        printf("%d\n%d ",n+2,a[n]);
        for(int i=1;i<n;i++)printf("%d ",a[i]);
        printf("%d %d",a[1],a[1]);
        return 0;
    }
    for(int i=1;i<=n;i++){
        if(b[a[i]]==1)c[i+1]=a[i],Add(i+1,-1);
        if(b[i]==0)o++,d[o]=i;
    }
    for(int i=n;i>=1;i--){
        if(b[a[i]]==2){
            l=1;r=i;s=0;t=Find(i);
            while(l<=r){
                mid=(l+r)/2;
                if(Find(mid)>=t)s=mid,r=mid-1;
                else l=mid+1;
            }
            if(h[a[i]]==0)O++,h[a[i]]=d[O],c[s]=d[O];
            else c[s]=h[a[i]];
        }
    }
    if(b[a[n]]==1&&b[a[n-1]]!=1){c[n]=d[1];}
    for(int i=1;i<=n;i++)if(c[i]==0)c[i]=d[1];
    printf("%d\n",n);
    for(int i=1;i<=n;i++)printf("%d ",c[i]);
}

```


---


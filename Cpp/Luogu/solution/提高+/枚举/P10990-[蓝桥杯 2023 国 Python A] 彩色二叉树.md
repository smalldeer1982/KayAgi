# [蓝桥杯 2023 国 Python A] 彩色二叉树

## 题目背景

建议使用 PyPy3 提交本题。

## 题目描述

给定包含 $n$ 个结点的完全二叉树，如下图是一棵包含 $n = 6$ 个结点的完全二叉树。

**树上的所有节点开始时没有被染色，颜色为 $0$。**

![](https://cdn.luogu.com.cn/upload/image_hosting/7zry2bbp.png)

给定 $q$ 次操作，操作可以是：
1. $x_i\ y_i\ z_i$，表示将与结点 $x_i$ 距离小于等于 $y_i$ 的结点的颜色全部染成 $z_i$；
1. $x_i$，表示查询结点 $x_i$ 的颜色。

## 说明/提示

对于 $40\%$ 的评测用例，$n, q \le 5000$；

对于所有评测用例，$1 \le n \le 10^6,1\le q \le 2 \times 10^5,1 \le x_i \le n,1 \le y_i \le 10^6,1 \le z_i\le 10^6$。

## 样例 #1

### 输入

```
6 6
1 1 1 1
2 3
1 5 2 2
2 4
2 1
2 3

```

### 输出

```
1
2
2
1
```

# 题解

## 作者：Clare613 (赞：5)

# 审题
这里有一个**完全**二叉树。
# 分析
首先，根据题目可知，这是一个**完全**二叉树，因此可知深度**不超过** $20$。再看 $q$ 的大小，$1 \le q \le 2 \times 10^5$，由此可知，在询问中可以跑树的深度。\
而树的深度就可以找祖先节点。\
类型一：标记颜色，根据 $y$ 的大小，给一路上的祖先节点染色。\
类型二：寻找颜色，在一路上的祖先节点中找到最后染色，且能给他染色。\
详见代码。
# 100分代码

```
#include<bits/stdc++.h>
using namespace std;
int z[1000005];
int c[1000005][55];
void sign(int x,int d,int nu){
	c[x][d]=nu;
	if(x==1||d==0) return ;
	sign(x/2,d-1,nu);
}
int find(int x,int step){
	if(x==0) return 0;
	int maxn=0;
	for(int i=step;i<=54;i++){
		maxn=max(maxn,c[x][i]);
	}
	return max(maxn,find(x/2,step+1));
}
int main(){
	int n,q;
	cin>>n>>q;
	for(int i=1;i<=q;i++){
		int op;
		cin>>op;
		if(op==1){
			int x,y;
			cin>>x>>y>>z[i];
			if(y>54)y=54;
			sign(x,y,i);
		}
		else{
			int x;
			cin>>x;
			cout<<z[find(x,0)]<<"\n";
		}
	}
	return 0; 
}
```

---

## 作者：Jason331 (赞：5)

### 请求题意更正

在节点没有任何染色时应输出 `0`。

## 前置芝士

使用 LCA 求树上任意两点的距离

# 解法

## 纯暴力

使用列表存储染色信息，询问时倒序遍历列表，依次检查节点是否被染色。

代码：

```python
def dis(a,b):# 树上两点之间的距离
    ea = a
    eb = b
    ans = 0
    while ea != eb:
        if ea > eb:
            ea >>= 1
        else:
            eb >>= 1
        ans += 1
    return ans

n,q = list(map(int,input().split()))
draw_list = []
for i in range(q):
    input_list = list(map(int,input().split()))
    if len(input_list) == 2:
        spot = input_list[1]
        stop = False
        for draw in draw_list[::-1]:
            if dis(spot,draw[0]) <= draw[1]:
                print(draw[2])
                stop = True
                break
        if not stop:
            print(0)
    else:
        draw_list += [input_list[1:]]
```

时间复杂度：$O(q^2 \log n)$

得分：[40分](https://www.luogu.com.cn/record/174726110)

## 暴力优化

想学习正解的同学往下翻，但本方法保证在语言为 `PyPy 3` 和 `Python 3` 的情况下可以满分。

如果我们观察一下代码，会发现第 $20$ 行：
```python
        for draw in draw_list[::-1]:
```
该行内的 `draw_list[::-1]` 耗费了大量算力进行序列的翻转，而我们遍历的时候很可能只遍历了一部分列表就跳出循环了，从而造成了很大的算力浪费。

所以我们不如不翻转列表，直接进行索引的倒序遍历，再使用索引来获取列表元素。

时间复杂度：$O(q^2 \log n)$

代码：

```python
def dis(a,b):# 树上两点之间的距离
    ea = a
    eb = b
    ans = 0
    while ea != eb:
        if ea > eb:
            ea >>= 1
        else:
            eb >>= 1
        ans += 1
    return ans

n,q = list(map(int,input().split()))
draw_list = []
for i in range(q):
    input_list = list(map(int,input().split()))
    if len(input_list) == 2:
        spot = input_list[1]
        stop = False
        i = len(draw_list) - 1
        while i >= 0:
            draw = draw_list[i]
            if dis(spot,draw[0]) <= draw[1]:
                print(draw[2])
                stop = True
                break
            i -= 1
        if not stop:
            print(0)
    else:
        draw_list += [input_list[1:]]
```

[AC 记录](https://www.luogu.com.cn/record/174854697)

虽然这个算法理论上的复杂度完全无法通过本题，但是由于数据的漏洞，还是水过了……

---

## 老老实实打正解

利用数据漏洞还是不太好的，我们还是来打正解吧。

观察使用 LCA 求两点距离的方法。

通过两点间的一个公共祖先来求两点距离，我们不如直接在染色的时候就把节点的祖先给标记上。

发现，在对节点 $x_i$ 进行距离为 $y_i$ 的染色时，与 $x_i$ 的父亲节点距离不小于 $y_i- 1$ 的节点也会被染色。

建立列表，使 $note_{i,j}$ 表示在节点 $x_i$ 进行距离为 $y_j$ 的染色操作的颜色。使 $time_{i,j}$ 表示在节点 $x_i$ 进行距离为 $y_j$ 的染色操作的时间。

染色时，枚举染色节点 $x_i$ 的第 $y$ 代直系祖先 $x_j$，对 $x_j$ 标记距离为 $y_i - y$ 距离的染色，也就是对上面提到的两个列表进行标记，方便接下来的查询。

询问时，枚举 $x_i$ 的直系祖先，对于 $x_i$ 的第 $y$ 代直系祖先 $x_j$，在 $x_j$ 进行的距离大于等于 $y$ 的染色都可以影响到 $x_i$ 的颜色，取得这些染色操作中时间最晚的一次，此次的颜色即为最终答案。

时间复杂度：$O(q \log^2 n)$

代码：
```
note = [[0] * 22 for i in range(1000001)]
time = [[0] * 22 for i in range(1000001)]
n,q = list(map(int,input().split()))
for i in range(q):
    input_list = list(map(int,input().split()))
    if input_list[0] == 2:
        spot = input_list[1]
        ans = 0
        t = 0
        length = 0
        while spot:
            for j in range(length,22):
                if time[spot][j] > t:
                    ans = note[spot][j]
                    t = time[spot][j]
            spot >>= 1
            length += 1
        print(ans)
    else:
        x,y,z = input_list[1:]
        while x and y >= 0:
            note[x][min(y,21)] = z
            time[x][min(y,21)] = i + 1
            x >>= 1
            y -= 1
```

[AC 记录](https://www.luogu.com.cn/record/174859618)

真的，我觉得这个正解还比暴力优化慢。

注：此方法无法使用 `Python 3` 获得满分，请使用 `PyPy 3`

## 后记

稍稍发表一下感想。

此题的数据真的是太水了，导致暴力竟然比正解还要快，理论上使用 `C++` 的 oier 可以直接暴力过。

所以……不管您是用的什么语言，能给我点一个赞吗？（当然得先等审核通过了）

---

## 作者：JuRuoOIer (赞：1)

# 题解 P10990 [蓝桥杯 2023 国 Python A] 彩色二叉树

前排提示：
- 本题解是两个 $\log$ 的**线段树**做法，前置知识为 [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)。
- 请进行充分地思考后再看题解，不要被难度吓到。~~本题评蓝估计纯粹是因为大纲。~~

题意略，[原题面](https://www.luogu.com.cn/problem/P10990)已经很清楚了。

### 做法

文中“同一层”指深度相同。

仔细审题，题中给的是**完全二叉树**。

于是有一个写过传统版线段树（即数组需要开四倍的那种，不是结构体存左右儿子的）的同学都应该知道的性质：
- 由于第一层只有一个点，其余的层每层点数翻倍，因此一个点 $p$ 的左儿子（假设点数无限）为 $2p$，右儿子为 $2p+1$。

借助这个性质，我们知道：对于一个点，同一层中和它编号差得越大的点离它越远。也就是说，**每层被染色的点，编号都是一段连续的区间**。

还是因为完全二叉树，所以层数**一共只有 $\log n$ 层**。综合上面的结论，我们容易想到暴力地枚举每一层并在线段树上对这一层上的点进行修改，这样复杂度就是 $O(q\log^2n)$ 的了。所以现在我们希望求出一次染色操作影响到的每层的区间。

我们知道，树上两个节点从一个到达另一个，需要先向上走到它们的 LCA，再向下走到另一个节点。而我们研究的又是同一层的节点，LCA 到两个节点的距离是相同的，因此假设从其中一个节点往外走，限制为 $k$ 步，则可能的 LCA 到该点的距离不能超过 $\lfloor\frac{k}{2}\rfloor$，即这个节点可以到达的同层节点为**该层中祖先中包含 这个点向上跳 $\lfloor\frac{k}{2}\rfloor$ 次所到达的点 的所有点**（这里句子比较长，故增加空格划分成分）。

而把最开始说的性质（一个点左右儿子的编号规律）反过来就能求出这个最高的 LCA：若起点编号为 $p$，限制走 $k$ 步，则这个 LCA 的编号 $q$ 就是 $\left\lfloor\dfrac{p}{2^{\lfloor\frac{k}{2}\rfloor}}\right\rfloor$（暂时假设不会超出树根）。然后继续用这个性质，左儿子编号 $\times 2$ 视为 `<<1`，右儿子编号 $\times 2+1$ 视为 `<<1` 后 `+1` 或 `|1`（事实上这也是老式线段树常见的写法），那么我们就可以得到 $q$ 号点下 $p$ 所在层的区间为 $q\times2^{\lfloor\frac{k}{2}\rfloor}$ 至 $q\times2^{\lfloor\frac{k}{2}\rfloor}+2^{\lfloor\frac{k}{2}\rfloor}-1$，写成代码就是 $q$ 左移 $2^{\lfloor\frac{k}{2}\rfloor}$ 位至 $q$ 左移 $2^{\lfloor\frac{k}{2}\rfloor}$ 位加二进制下 $\lfloor\frac{k}{2}\rfloor$ 个 $1$。

现在一层之内的事情解决了，考虑解决一个操作所能影响到的每一层。分开上下：
- 往上枚举的时候，由于从一个点走到其他点时是先往上后往下，因此每往上跳一层就会消耗 $1$ 步，这样步数限制就是从当前所在点开始算的了。
- 同理，往下枚举的时候，每往下一层就会增加 $1$ 步。这里由于层数是一定的，哪个方向到当前点的距离都一样，所以我们可以每次固定跳左儿子。另外记**得判向下跳的层数不能超过起点的步数限制**。

至此，这道题就已经做完了，总复杂度为 $O(q\log^2n)$，虽然有点极限（$4\times10^7$）但是足以不开 O2 跑进 $1$ 秒。

### 细节

- 向下枚举的时候记得判向下的层数是否已经超过了起点的步数限制。
- 计算最高 LCA 的时候记得判步数限制除以 $2$ 后仍超过到达根节点时需要的深度的情况。
- 线段树记得建树。

~~另外吐槽下样例真挺水的，本人 `build` 的时候递归了两遍左儿子都能过。~~

### 代码

省略了线段树板子部分。以下代码中：
- `build` 函数用于建线段树；
- `upd` 函数用于区间赋值，其中后三个参数表示区间左端点、区间右端点和要赋的值；
- `query` 函数用于单点查询，最后一个参数表示查询的点。

```cpp
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>q;
	build(1,1,n);//记得建树
	while(q--){
		cin>>op>>u;
		if(op==1){
			cin>>v>>w;
			ll now=u,tmp=v;
			while(now>=1&&tmp>=0){
				ll len=min(__lg(now),tmp>>1);//防止冲出根节点
				if((now>>len<<len)<=n)upd(1,1,n,now>>len<<len,min((now>>len<<len)+(1ll<<len)-1,n),w);//判一下边界防止爆炸
				now>>=1;
				tmp--;
			}
			ll ttmp=v-1;
			now=(u<<1);tmp=v+1;//这里为了避免询问点所在层被重复计算浪费时间，向下走的循环开始前先往下走一层。
			while(now<=(n<<1)&&ttmp>=0){
				ll len=min(__lg(now),tmp>>1);
				if((now>>len<<len)<=n)upd(1,1,n,now>>len<<len,min((now>>len<<len)+(1ll<<len)-1,n),w);
				now<<=1;
				tmp++;
				ttmp--;//防止层数超限
			}
		}
		else{
			cout<<query(1,1,n,u)<<endl;
		}
	}
	return 0;
}
```

---

## 作者：fengziyi (赞：1)

观察到本题树形为完全二叉树故将整棵树染色只需 $y_i \geq 20$。可以枚举暴力查询一个点的染色状态。

考虑将一个点的染色状态上传至其父亲和祖先节点，这样询问可通过查询其父亲和祖先节点即可查询到这个点当前被染成的颜色。

记 $col_{i,j}$ 表示距 $i$ 小于等于 $j$ 的节点的颜色，$tim_{i,j}$ 表示这次染色是哪一次操作定义的。

对于一次染色，节点 $i$ 的父亲其可扩展的距离为 $y_i - 1$，以此向上类推。染色操作后者可覆盖前者，所以遇到相同 $x_i,y_i$ 的操作可以直接覆盖。

查询时，暴力扫描 $\log(n)$ 代以内祖先的染色状况是否可扩散至该点即可，动态更新染色时间最晚的版本。

单次查询复杂度 $\log^2(n)$ 总复杂度数量级在 $10^8$ 以内。PyPy3 可过。

```python
n, m = map(int, input().split())
col = [[0] * 21 for _ in range(n + 1)]
tim = [[0] * 21 for _ in range(n + 1)]

for i in range(1, m + 1):
    ln = [int(i) for i in input().split()]
    op = ln[0]
    if op == 1:
        x, y, z = ln[1:]
        while x and y >= 0:
            col[x][min(y, 20)] = z
            tim[x][min(y, 20)] = i
            x >>= 1; y -= 1
    else:
        x = ln[1]
        y = 0; t = 0; res = 0
        while x:
            for j in range(y, 21):
                if tim[x][j] > t:
                    t = tim[x][j]
                    res = col[x][j]
            x >>= 1; y += 1
        print(res)

```

---

## 作者：meyi (赞：0)

幽默蓝题，感觉下位绿差不多得了，至少哥们一眼了。

发现是完全二叉树，所以树高只有 $\log n$，如果 $y_i\ge 2\log n$ 那就是在给整棵树染色。

考虑直接暴力枚举祖先，第 $i$ 次染色能影响到第 $j$ 次查询的充要条件是 $dep_{x_i}+dep_{x_j}-2\times dep_{\text{lca}(x_i,x_j)}\le y_i$，移个项就是 $dep_{x_j}\le2\times dep_{\text{lca}(x_i,x_j)}+y_i-dep_{x_i}$。

所以定义 $son_{i,j}$ 表示 $i$ 这个点子树内深度为 $j$ 的点最后会被哪次操作影响，对操作点到根的这条链上的 $son$ 数组前缀染色单点查询就做完了，染色复杂度 $O(\log^2 n)$，查询复杂度 $O(\log n)$，总时间复杂度 $O(n\log n+q\log^2 n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops")
#define ALL(v) v.begin(),v.end()
#define For(i,_) for(int i=0,i##end=_;i<i##end;++i) // [0,_)
#define FOR(i,_,__) for(int i=_,i##end=__;i<i##end;++i) // [_,__)
#define Rep(i,_) for(int i=(_)-1;i>=0;--i) // [0,_)
#define REP(i,_,__) for(int i=(__)-1,i##end=_;i>=i##end;--i) // [_,__)
typedef long long ll;
typedef unsigned long long ull;
#define V vector
#define pb push_back
#define pf push_front
#define qb pop_back
#define qf pop_front
#define eb emplace_back
typedef pair<int,int> pii;
typedef pair<ll,int> pli;
#define fi first
#define se second
const int dir[4][2]={{-1,0},{0,1},{1,0},{0,-1}},inf=0x3f3f3f3f,mod=1e9+7;
const ll infl=0x3f3f3f3f3f3f3f3fll;
template<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,1:0;}
template<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,1:0;}
int init=[](){return cin.tie(nullptr)->sync_with_stdio(false),0;}();
int main(){
    int t_case=1;
    //scanf("%d",&t_case);
    while(t_case--){
        int n,q;
        scanf("%d%d",&n,&q);
        int lg=__lg(n);
        V<int>x(q),y(q),z(q);
        V son(n,V<int>(lg+1,-1));
        For(i,q){
            int op;
            scanf("%d%d",&op,&x[i]);
            if(op&1){
                scanf("%d%d",&y[i],&z[i]);
                for(int j=x[i],k=0;j&&k<=y[i];j>>=1,++k)Rep(l,min(lg,y[i]-k)+1)son[j-1][l]=i;
            }
            else{
                int ans=-1;
                for(int j=x[i],k=0;j;j>>=1,++k)ckmax(ans,son[j-1][k]);
                printf("%d\n",~ans?z[ans]:0);
            }
        }
    }
    return 0;
}
```

---


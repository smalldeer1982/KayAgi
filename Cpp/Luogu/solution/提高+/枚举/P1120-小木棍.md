# 小木棍

## 题目背景

本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)

## 题目描述

乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过 $50$。

现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。

给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。


## 说明/提示

对于全部测试点，$1 \leq n \leq 65$，$1 \leq a_i \leq 50$。

## 样例 #1

### 输入

```
9
5 2 1 5 2 1 5 2 1
```

### 输出

```
6```

# 题解

## 作者：Kaori (赞：1382)

这是我第一次写luogu博客，哪里写的不好请大家见谅哦 (^_^)

此题明显是一道搜索剪枝题。我详细说一下这题的全思路，不过略长。

### 前排提示：第四条的优化7讲的是那个不少人不明白的优化，如果你只是不明白那个优化可以空降。

---

一，管理员已经在题目中告诉你输入时去掉长度大于50的木棍。

二，想好搜索什么。很明显我们要枚举把哪些棍子拼接成原来的长棍，而原始长度（原来的长棍的长度）都相等，因此我们可以在dfs外围枚举拼接后的每根长棍的长度。那枚举什么范围呢？

　　其长度至少是最长的一根木棍，此时最长的这根木棍恰好单独组成原来的长棍。如果 原始长度 小于 最长的这根木棍，那么这根最长的木棍就无法自己或与其它木棍组成原来的长棍。
  
　　其长度至多是所有木棍的长度之和，此时所有的木棍拼在一起恰好成为一根原来的长棍。如果 原始长度 大于所有木棍的长度之和，那么即使所有木棍拼在一起也组不够原来的长棍了。
  
　　这么大的循环套dfs会超时么？当然会了。所以我们可以考虑到当 原始长度 不能被 所有木棍的长度之和 整除的话，这些木棍是拼不出整数根的（如果都拼成枚举的原来长棍的长度）。因此在循环时把它们刷掉。
  
　　这里借鉴了dalao的（小）优化，即原始长度枚举到 所有木棍的长度之和/2 即可，因为此时所有木棍有可能拼成2根木棍，原始长度再大的话就只能是所有木棍拼成1根了。
  
  三，脑补一下怎么搜。设dfs(int k,int last,int rest)，k表示正在拼第几根原来的长棍，last表示使用的上一根木棍（输入的短棍）的编号，rest表示当前在拼的长棍还有多少长度未拼。于是循环枚举下一根将要使用的木棍。
  
  四，~~上面的做法不超时说明你太强大了。~~你开始思考对程序做一些优化。（下面的优化请按顺序想）
  
  1. 一根长木棍肯定比几根短木棍拼成同样长度的用处小，即短的木棍可以更灵活组合，**所以对输入的所有木棍按长度从大到小排序**，从长到短地将木棍拼入，这样短木棍可以更加灵活地接在。
  
　如果你还不太清楚“灵活”的含义，请形象脑补一下——如果先用短木棍，那么需要很多根连续的短木棍接上一根长木棍才能拼成一根原来的长棍，那么短木棍都用了后，剩下了大量长木棍，拼起来就不如短木棍灵活，更难接出原始长度。而先用长木棍，最后再用短木棍补刀，这样就剩下了相对较短的木棍，能更加灵活地拼接出原始长度。
  
  2. 根据优化1，将输入的木棍从大到小排好序后，当用木棍i拼合原始长棍时，从第i+1根木棍开始往后搜。
  
  3. 当dfs返回拼接失败，需要更换当前使用的木棍时，不要再用与当前木棍的长度相同的木棍，因为当前木棍用了不行，改成与它相同长度的木棍一样不行。这里我**预处理**出了排序后**每根木棍后面的最后一根与这根木棍长度相等的木棍**（程序中的next数组），它的下一根木棍就是第一根长度不相等的木棍了。
  
　这个预处理可以优化时间，不必在循环中慢慢往下找长度不相等的木棍。
  
  4. 只找**木棍长度**不大于**未拼长度rest**的所有木棍。我看其他大部分人的做法（包括书上的啊）都是直接在循环中判断，但我认为可以根据木棍长度的单调性来**二分**找出第一个**木棍长度**不大于**未拼长度rest**。它后面的木棍一定都满足这个条件。
  
  5. 用vis数组标记每根木棍是否用过。另外在dfs回溯的时候别忘了去掉这些标记，这样就不用每次dfs之前memset了（memset用多的话速度可TM慢了）！
  
### 　优化5的习惯可以沿用到各种竞赛
  
  6. 由于是从小到大枚举 原始长度，因此第一次发现的答案就是最小长度。dfs中只要发现所有的木棍都凑成了若干根原长度的长棍（容易发现 **凑出长棍的根数=所有木棍的长度之和/原始长度**），立刻一层层退出dfs，不用滞留，退到dfs外后直接输出原始长度并结束程序。
  
  7. 还有一个难想却特别特别重要的优化：如果**当前长棍剩余的未拼长度**等于**当前木棍的长度**或**原始长度**，继续拼下去时却失败了，就直接回溯并改之前拼的木棍。有些人不太明白这个优化，这里简单说一下：
  
　**当前长棍剩余的未拼长度**等于**当前木棍的长度**时，这根木棍在最优情况下显然是拼到这（如果用更多短木根拼完剩下的这段，把这根木棍留到后面显然不如把更多总长相等的短木棍扔到后面）。如果在最优情况下继续拼下去失败了，那肯定是之前的木棍用错了，回溯改即可。$\color{red}\text{(update at 2019.7.24)}$
 
　**当前长棍剩余的未拼长度**等于**原始长度**时，说明这根原来的长棍还一点没拼，现在正在放入一根木棍。很明显，这根木棍还没有跟其它棍子拼接，如果现在拼下去能成功话，**它肯定是能用上的，即自组或与其它还没用的木棍拼接**。但继续拼下去却失败，说明现在这根木棍**不能用上**，无法完成拼接，所以回溯改之前的木棍。
  
做了这么多优化可以确保飞跑了……搜索题啊，每招优化都要学，学一招说不定竞赛的时候就能跑的快一点。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int x=0; bool f=1; char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=0;
    for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
    if(f) return x;
    return 0-x;
}
int n,m,a[66],next[66],cnt,sum,len;
bool used[66],ok; //used数组即优化5的vis数组，记录每根木棍是否用过；ok记录是否已找到答案。 
bool cmp(int a,int b){return a>b;}
void dfs(int k,int last,int rest){ //k为正在拼的木棍的编号，last为正在拼的木棍的前一节编号，rest为该木棍还未拼的长度
    int i;
    if(!rest){ //未拼的长度为0，说明这根原始长棍拼完了，准备拼下一个 
        if(k==m){ok=1; return;} //优化6，全部拼完并符合要求，找到答案，直接返回 
        
        for(i=1;i<=cnt;i++) //找一个还没用的最长的木棍打头即可。反正要想全都拼接成功，每根木棍都得用上 
            if(!used[i]) break;
        used[i]=1; 
        dfs(k+1,i,len-a[i]);
        used[i]=0;
        if(ok) return; //优化6，找到答案就退出 
    }
    //优化4，二分找第一个 木棍长度不大于未拼长度rest 的位置 
    int l=last+1, r=cnt, mid;
    while(l<r){
        mid=(l+r)>>1;
        if(a[mid]<=rest) r=mid;
        else l=mid+1;
    }
    for(i=l;i<=cnt;i++){
        if(!used[i]){ //优化5，判断木棍是否用过 
            used[i]=1;
            dfs(k,i,rest-a[i]);
            used[i]=0;
            if(ok) return; //优化6，找到答案就退出 
            
            if(rest==a[i] || rest==len) return; //优化7 
            i=next[i]; //优化3 
            if(i==cnt) return;
        }
    }
    //到了这里，说明这时候拼不成当前这根原始木棍了，传回失败信息并修改之前拼的木棍 
}
int main(){
    n=read();
    int d;
    for(int i=1;i<=n;i++){
        d=read();
        if(d>50) continue;
        a[++cnt]=d;
        sum+=d;
    }
    sort(a+1,a+cnt+1,cmp); //优化1，木棍按长度从大到小排序 
    //优化3，预处理next数组 
    next[cnt]=cnt;
    for(int i=cnt-1;i>0;i--){
        if(a[i]==a[i+1]) next[i]=next[i+1];
        else next[i]=i;
    }
    for(len=a[1];len<=sum/2;len++){ //枚举原始长度 
        if(sum%len!=0) continue; //如果不能拼出整数根 就跳过 
        m=sum/len; //优化6中的那个计算 
        ok=0;
        used[1]=1;
        dfs(1,1,len-a[1]);
        used[1]=0;
        if(ok){printf("%d\n",len); return 0;} //优化6，输出答案，退 
    }
    printf("%d\n",sum); return 0;
}
```

有问题可以评论

---

## 作者：林则徐 (赞：407)

暴搜的思路并不难想到，主要难点是各种优化、各种剪枝：

1. 预先处理出所有木棍的总长度，且保证枚举答案的值能被总长度整除。

2. 每根木棍的长度可用桶来存储，并且预先处理出最长的和最短的木棍的长度，搜索时从最大长度到最小长度递减枚举。

3. 若拼接当前木棍时已用了一根长为X的木棍，则dfs时从长度X开始搜索。

4. 若某组拼接不成立，且此时 已拼接的长度为0 或 当前已拼接的长度与刚才枚举的长度之和为最终枚举的答案 时，则可直接跳出循环，因为此时继续枚举其它更小的值时，显然可能情况更少，且同样凑不完。

5. 注意常数不要太大。


附上代码：





```cpp
#include<cstdio>
#include<cstdlib>
const int N = 70 ;
int n , cnt , tot , maxn , minn , tm[ N ] /* 2 */ ; 
void dfs( int res , int sum , int target , int p ) {
    if( res == 0 ) {
        printf("%d", target  );
        exit( 0 );
    }
    if( sum == target ) {
        dfs( res - 1 , 0 , target , maxn );
        return;
    }
    for( int i = p ; i >= minn ; i -- ) { // 2  3 
        if( tm[ i ] && i + sum <= target ) {
            tm[ i ] -- ;
            dfs( res , sum + i , target , i );
            tm[ i ] ++ ;
            if ( sum == 0 || sum + i == target )  //4
                break;
        }
    }
    return;
}
int main() {
    scanf("%d" , &n ) ;
    minn = N ;
    int temp;
    while( n -- ) {
        scanf("%d" , &temp );
        if( temp <= 50 ) {
            cnt ++;
            tm[ temp ] ++;
            tot += temp;
            maxn = maxn > temp ? maxn : temp ;   //1
            minn = minn < temp ? minn : temp ;
        }
    }
    temp = tot >> 1;
    for( int i = maxn ; i <= temp ; i ++ ) {
        if( tot % i == 0 ) {
            dfs( tot / i , 0 , i , maxn );
        }
    }
    printf("%d" , tot );
    return 0;
}
```

---

## 作者：NoyException (赞：361)

 _题目链接： _[P1120]_ _ (https://www.luogu.org/problemnew/show/P1120)
 本蒟蒻花了半天才肝出来这道题，见到AC时内牛满面……
 # 题目解释
看到这个题目你可能会无从下手~~（其实无从下手的只是我自己而已）~~，但人家的数据范围也才不过65×50，用暴搜就行了。

 至于题目中的“舍去长度超过50的小木棍”的意思是，你不用理那些超过50的数据，直接扔掉就行了。
 
 那究竟该怎么暴搜呢？很明显BFS是顶不住了，那么我们就用深搜。我刚开始的思路,就是遍历所有的可能组合的长度，然后再对50根木棒进行全排序，排序过程中再进行剪枝，时间复杂度~~也不过就~~是O(n!\*m)~~而已~~，65！\*m的话……那肯定会爆炸啦！所以接下来我就来为大家介绍一下怎么剪枝。**Here we go!**
 
 # 如何剪枝
 （**名词说明：**原长：可能的原木棍长度，小木棍/木棍/大木棍：还未拼接的木棍，原木棍：长度为原长的已经拼好的木棍）
 ## 1：基础剪枝
 I首先，我们需要**对这些进来的数据排个序，大的在前小的在后。**为什么呢？因为~~打怪的时候不都是先开大再A一下补刀的吗~~排好序的数组更方便优化2的操作，而且小的木棒灵活性更强，放在前面可以组合出非常多没用的结果，你想想看大木棒都被你扔一边去了，小木棍给用完了，到时候怎么拼成长度一样的木棍？
 
 II其次我们很容易也可以知道，如果尝试将一小段木棒拼上去却没有成功的话，那么以后也就**别再尝试其它的长度相同的木棒**了，直接一个nxt数组转到下一个。而nxt数组也是只有在优化I后才可以建立的。
 
 III经过一番~~哲学~~分析我们可以发现，拼好的木棍的长度肯定是所有砍成的小木棍长度之和的因数。也就是说，在遍历所有的原长时，应该**判断木棍总长是否可以整除原长。**
 
 IV**使用vis数组来存储是否使用过某木棍**，而撤销使用时记得将vis改掉。
 ## 2：普通剪枝
 V我们可以清楚得知道，所有的木棍都是要用来拼接的，不能说丢掉某一根看着不中意的木棍。所以呢，当你已经拼好了一根原木棍，开始**尝试拼新的一根木棍时，请选择最大的那根还没用来拼接的木棍，**反正迟早要用上。（至于为什么用最大的参见剪枝I）
 
 VI在拼一根原木棍的时候注意，一定要**从比上一根拼进此原木棍的木棍长度更小的木棍开始尝试拼接。**你想想你曾经尝试过将一根大木棍拼进去发现拼不了，选了一个较小的，现在叫你选下一根，你却又选了那根大木棍……（警告：当你开始拼一根新的原木棒时请从头开始尝试拼接）
 
 VII当你**还剩最后一根原木棒没有拼接时直接返回成功。**因为根据III你已经进行过整除判断了，剩余的小木棒的长度总和必定就是原长，而且不管怎么拼都没问题。
 ## 3：进阶剪枝
 VIII如果发现在实现V之后**最大的那根木棍无法与其他的木棍拼成原木棍，则直接返回上一级拆了上一根原木棍重新拼，**因为如果不这么做的话最长的那根木棍是永远无法拼成原木棍的。
 
 IX若你在拼一个原木棒时还剩i个单位的长度没拼上时，恰好有一根长度就是i的木棒，那么优先选这个（这个在前面的优化里说了，重点在后面），但**如果这根木棒拼进去后发现剩余的木棒是不能组合成原木棒的，那么直接返回失败，**因为你要换这根木棒也只能换成长度更小的几段，使剩余木棒的灵活性反而更低，就更不可能拼成原木棒。所以直接返回去重做上一根原木棒。
 # 上代码
 说了这么多，应该已经够了吧。至于那些大神剪枝我是不会的，反正够写出这道题就行了。那么就有请各位客官来看一下我的代码吧，献丑了~~（555本人蒟蒻【一脸害羞】555神犇勿喷【一脸害怕】）~~
 ```cpp
#include <bits/stdc++.h>
using namespace std;

int line[65],len,nxt[65],end,sum;
bool vis[65];
bool cmp(const int a,const int b)
{
	return a>b;
}
bool perm(int pre,int fromp)
{
	int i;
	if(pre%len==0)
	{
		if(sum-pre==len) return true;//优化VII 
		for(i=2;i<=end && vis[i];i++) ;//优化V 
		vis[i]=true;
		if(perm(pre+line[i],2)) return true;
		vis[i]=false;//后面是else不运行，直接到后面的return false；这就是优化VIII 
	}
    else for(;fromp<=end;fromp++)//优化VI，直接从继承过来的fromp开始遍历 
	{
       	if(!vis[fromp])//优化IV 
       	{
       		if(pre%len+line[fromp]<=len)
       		{
       			vis[fromp]=true;
   				if(perm(pre+line[fromp],fromp)) return true;//fromp即为优化VI
				vis[fromp]=false;
				if(pre%len+line[fromp]==len) return false;//优化IX 
			}
			fromp=nxt[line[fromp]];//优化II 
		}
	}
    return false;
}

int main()
{
    int n,iA,in,maxi=0,cha=0,cun=0;
    scanf("%d\n",&n);
    for (iA=1;iA<=n;iA++)
    {
    	scanf("%d",&in);
    	if(in<=50)
		{
			maxi=max(maxi,in);
			sum+=in;
			line[iA-cha]=in;
		}
    	else cha++;
	}
	sort(line+1,line+n-cha+1,cmp);//优化I 
	for(iA=1;iA<=n-cha;iA++)
		if(line[iA]!=cun)
		{
			nxt[cun]=iA-1;
			cun=line[iA];
		}
	end=n-cha;vis[1]=true;nxt[line[end]]=end;
	for(len=maxi;len<=sum/2;len++)
	{
		if(sum%len!=0) continue;//优化III 
    	if(perm(line[1],2)) break;
	}
    if(len>sum/2) cout<<sum;
    else cout<<len;
    return 0;
}
```
咳咳码字码的好辛苦，神犇勿喷哇，蟹蟹！（~~如果您能点个赞的话……~~想什么呢咳咳）

---

## 作者：FLASH_CM (赞：78)

## 题目描述：

乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过 50 。现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。
## 想法：

首先在读入的时候忽略掉长度大于50的木棍（最重要），顺便还要记录一下最短的木棍和最长的木棍的长度（为之后的运算剪枝），然后按照木棍的长度做一次排序（因为木棍长度都小于等于50，本人用的是桶排序），接着就可以开始搜索了。
## 搜索时的策略：

1、从最长的木棍的长度开始，枚举原先每根木棍的可能长度，一直到（剪枝一：） 总长度的一半（如果原先木棍的数量不为1，则原先木棍的长度必然小于所有木棍总长度的一半）。（小贴士：如果枚举完后，仍然没有输出答案，则直接输出总长度即可）（因为如果一直到总长度的一半都没有解，则说明原先的木棍就只有一根而已）

2、从（剪枝二）最长的木棍开始选择（如从最短的木棍开始搜索，会增加回溯次数，具体原因留给读者自行思考），逐一递减，如果当前已选择的木棍的总长度加上目前准备选择的木棍的长度小于等于需要的长度，则分别搜索是否选择选择该木棍的情况（类似于01背包）

3、如果已经拼凑好了所有的木棍，则直接输出当前枚举的原先木棍长度并结束程序（如果已找到最优解，则不需要继续搜索）；如果当前拼凑的木棍的长度恰好等于枚举的原先木棍的长度，那么重新从最长的木棍开始搜索（注意：一定是从最长的木棍开始搜索，但要判断它是否已被选定，在每次选择的时候用一个 bool 函数标记即可）。

4、具体情况见代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

int num[500010],maxn,minn,sum;

int max(int x,int y){
	return x>y?x:y;
}

int min(int x,int y){
	return x>y?y:x;
}

void dfs(int wait,int already,int need,int can){	//从前往后依次为 还需要拼凑得到的木棍数量 
	int i;											//				当前已经拼凑得到的木棍的长度 
	if(wait==0){	//如果已经完成所有的木棍的拼凑，则直接输出结果	需要得到的木棍的长度 
		printf("%d",need);							//				当前可以使用的最长木棍的长度 
		exit(0);
	}
	if(already==need){//如果当前拼凑出的木棍的长度等于需要得到的木棍的长度，则开始拼凑下一根 
		dfs(wait-1,0,need,maxn);
		return ;
	}
	for(i=can;i>=minn;i--)
		if(num[i] && i+already<=need){
			num[i]--;
			dfs(wait,already+i,need,i);
			num[i]++;
			if(already==0 || already+i==need)
				return ;
		}
}
	
int main(){
//	freopen("in.txt","r",stdin);
	int i,j,k,m,n,temp;
	scanf("%d",&n);
	for(i=1;i<=n;i++){
		scanf("%d",&k);
		if(k<=50){		//忽略长度小于等于50的木棍 
			sum+=k;
			num[k]++;
			minn=min(k,minn);
			maxn=max(k,maxn);
		}
	}
	temp=sum/2;
	for(i=maxn;i<=temp;i++)			//枚举每一种可能选定的长度 
		if(sum%i==0)
			dfs(sum/i,0,i,maxn);
	printf("%d",sum);
	return 0;
}
```

---

## 作者：路人_ (赞：37)

# 小木棍（数据加强）【题解】
其实，这题的难度很迷（我先在**POJ**上做的）；

至于为什么呢？

有一道数据原版的难度是**省选**

而原题（本题）是强化的，难度却是**提高+**      ~~（迷）~~

废话不多说，进入正题；


------------
其实这道题就是一个搜索，并且用上了剪枝。

### 划重点

所谓**剪枝**，就是减小搜索树的规模。尽早排除搜索树中不必要的分支的一种手段。**形象地看**，就好像剪掉了搜索树的枝条。

考虑以下剪枝：

**1.逆序搜索**

把木棍儿的长度从大到小排序；

**2.X+Y=Y+X(好理解吧）**

1）相同的只搜一遍；

2）如果现在已经拼成的长度，在后面是不可能成功的。那么我们就认定这个分支是失败的。所以如果之后的分支再次遇见像这样的长度。我们就直接把他给返回就可以了。

3）如果刚开始拼接木棒的时候，第一根已经导致了拼接失败。那我们就可以判定当前的大分支是不可行的。至于为什么，~~是因为他在第一次已经不行啦~~（开车）。那么它在其他木棒中也是不可以的。

其实大概的剪枝思想也就只这些；

下面上代码；


------------
**深搜代码**
```c
bool dfs(int now,int cab,int last)
//now表示现在在拼的第now根原始木棒
//cab表示第now根木棒的当前长度
//上一根小木棒是last
{
	if(now>s) return 1;//所有的木棒拼完了
	if(cab==l) return dfs(now+1,0,1);//l是拼完的长度，now根拼好了
	int f=0;//剪枝2，2）
	for(int i=last;i<=cnt;i++)//剪枝1
	{
		if(!k[i] && cab+a[i]<=l && f!=a[i])
		{
			k[i]=1;
			if(dfs(now,cab+a[i],i+1)) return 1;
			f=a[i];
			k[i]=0;//回溯
			if(cab==0 || cab+a[i]==l) return 0;//cab+a[i]==l加不加应该没影响
		}
	}
	return 0;//搜索失败
}
```



------------

**主函数**

```c
int main()
{
	int n;
	while(cin>>n&&n)//输入
	{
		memset(a,0,sizeof(a));//初始化
		memset(k,0,sizeof(k));
		cnt=0,v=0,sum=0,l,s;
		for(int i=1;i<=n;i++)
		{
			int x;
			cin>>x;
			if(x>50) continue;//题意，防止毒瘤测试点
			a[++cnt]=x;
			v=max(v,x);
			sum+=x;
		}
		sort(a+1,a+cnt+1);
		reverse(a+1,a+cnt+1);//STL翻转数组
		for(l=v;l<=sum;l++)
		{
			if(sum%l) continue;
			s=sum/l;//原始木棒长l，共cnt根，故每根长sum/cnt；
			memset(k,0,sizeof(k));
			if(dfs(1,0,1)) break;
		}
		cout<<l<<endl;//输出答案
	}
	return 0;//完美结束
}
```

**完整代码**    ~~（拿走不谢）~~

```c
#include<bits/stdc++.h>
using namespace std;

int cnt=0,v=0,sum=0,l,s;
int a[100],k[100];

bool dfs(int now,int cab,int last)
{
	if(now>s) return 1;
	if(cab==l) return dfs(now+1,0,1);
	int f=0;
	for(int i=last;i<=cnt;i++)
	{
		if(!k[i] && cab+a[i]<=l && f!=a[i])
		{
			k[i]=1;
			if(dfs(now,cab+a[i],i+1)) return 1;
			f=a[i];
			k[i]=0;
			if(cab==0 || cab+a[i]==l) return 0;
		}
	}
	return 0;
}

int main()
{
	int n;
	while(cin>>n&&n)
	{
		memset(a,0,sizeof(a));
		memset(k,0,sizeof(k));
		cnt=0,v=0,sum=0,l,s;
		for(int i=1;i<=n;i++)
		{
			int x;
			cin>>x;
			if(x>50) continue;
			a[++cnt]=x;
			v=max(v,x);
			sum+=x;
		}
		sort(a+1,a+cnt+1);
		reverse(a+1,a+cnt+1);
		for(l=v;l<=sum;l++)
		{
			if(sum%l) continue;
			s=sum/l;
			memset(k,0,sizeof(k));
			if(dfs(1,0,1)) break;
		}
		cout<<l<<endl;
	}
	return 0;
}
```
**求审过，（据说，考试前发题解会np++）**


第一篇**紫题**题解 ~~（太不容易了）~~，
最后**安利**下我的[博客](https://www.luogu.org/blog/lwhd/)











---

## 作者：爷，无限霸气 (赞：21)

~~虽说这数据加强，但原版是紫题~~，[原版](https://www.luogu.org/problem/UVA307)

~~废话不多说，直接开始~~

这题显然是一道搜索题（~~标签上写了~~）

# 无优化搜索

从小到大枚举答案（~~有个小优化，如果和不能整除此答案就跳过~~）

设原始木棍根数为cnt（cnt=sum/len）

## 三个状态

1.已经拼好的木棍根数

2.当前长度

3.使用情况

我们每次搜索只需找到尚未使用的木棍（~~来尝试拼接~~），此时搜索一下新的状态

## 两个边界

1.成功拼好（可以输出答案了）

2.无法拼接（返回上次拼接状态）

### 无优化搜索完结撒花

虽不AC,却不用动脑子的好方法！！！

# 有优化搜索

搜索的优化（~~众所皆知~~）

1.优化搜索顺序（~~此题需要~~）

2.排除等效冗余（~~此题需要~~）

3.可行性剪枝

4.最优性剪枝

5.记忆化搜索

## 优化搜索顺序！

我们可以将长度从大到小排序，优先尝试一下长的木棍

~~可以优化的原因：~~

![](https://cdn.luogu.com.cn/upload/image_hosting/9hathyyu.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

如图所示(~~虽然有点丑~~)

我们从长的木棍开始合并或是从短的木棍开始合并长度一致，因此只需搜索其中一种

## 排除等效冗余

1.假设长度为x的木棍拼接失败，那么和为x的一堆木棍（一根都是如此）拼接也必然失败（状态和前面的状态一致）

2.如果已拼好的木棍长度为x，那么如果长度为y的无法向此拼接。下一堆已拼好的木棍如果长度也为x，y也一定不能向此拼接

3.用一根木棍总比用一堆木棍好（~~搜索之贪心~~）

完整代码：code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll read()
{
	ll r=0,f=1;char c=getchar();
	while((c<'0'||c>'9')&&(c!='-')) c=getchar();
	if(c=='-') f=-1,c=getchar();
	while(c>='0'&&c<='9') r=r*10+c-'0',c=getchar();
	return r*f; 
}
ll a[101],v[101],n,len,cnt;
bool dfs(ll stick,ll cab,ll last)
{
	if(stick>cnt) return true; 
	if(cab==len) return dfs(stick+1,0,1);//往下一个搜 
	ll failess=0;
	for(int i=last;i<=n;i++)
	 if(!v[i]&&cab+a[i]<=len&&failess!=a[i])
	 {
	 	v[i]=1;
	 	if(dfs(stick,cab+a[i],i+1)) return true;
	 	failess=a[i];
	 	v[i]=0;
	 	if(cab==0||cab+a[i]==len) return false;
	 }
	 return false;
}
ll cmp(ll a,ll b)
{
	return a>b;
}
int main()
{
//	freopen("data.in","r",stdin);
//	freopen("data.out","w",stdout);
	n=read();
	ll sum=0,val=0;
	for(int i=1;i<=n;i++)
	{
		ll b=read();
		if(b>50) continue;
		a[i]=b;
		sum+=a[i];
		val=max(val,a[i]);
	}
	sort(a+1,a+n+1,cmp);
	for(len=val;len<=sum;len++)
	{
		if(sum%len) continue;
		cnt=sum/len;
		memset(v,0,sizeof(v));
		if(dfs(1,0,1)) break;
	}
	cout<<len<<endl;
	return 0;
}
```


---

## 作者：lgnotus (赞：17)

emm这题主要是加剪枝，加的我都快吐了，以前把WA都剪出来了，晕倒。。

## 剪枝

1. 找到答案就终止搜索
2. 从小到大枚举长度（答案）。
3. 把木棍的长度从大到小排序，如果多选取长的木棍拼，就会让用的木棍超出拼成大木棍子的目标长度，从而可以排除更多的方案。
4. 只搜索到要拼成的大木棍数-1，为什么留给大家自己想
5. 预处理每一个木棍下一个的与它不同长度的木棍的位置，如我在枚举中用到了这跟木棍，就直接枚举跳到下一个的与它不同长度的木棍的位置，如果这根木棍已经别用过，那枚举的位置+1。
6. 如果这是一根大木棍的第一根木棍如果尝试失败了，那就不可以拼成大木棍。因为这是基于从大到小排序加的剪枝，第一根（也就是最长的）木棍试过了，如果不行，那后面小木棍一点一点补上去，拼成木棒的可能越来越少，甚至没有，所以不可以拼成。
7. 已选的长度+枚举待选的那个长度之和摆不成那个木棒，照样也不行，与纳音和剪枝6差不多。
## code

```
#include<bits/stdc++.h>
using namespace std;
int n,mx=INT_MIN,val,ans=INT_MAX,tot;
int stick[70],vis[70],sum,next[70];
bool flag;

bool cmp(int a,int b)
{
    return a>b;
}
void dfs(int now,int last,int g,int cur)/// now 代表当前拼了几根小棒子，last表示从第几根木棍开始枚举，g表示我要拼成的每一根棒子的长度，cur代表当前拼每个木棍用的长度。
{
    if(now==val-1)
    {
        ans=min(ans,g);
        flag=1;
        return;
    }
    if(cur==g)
    {
        dfs(now+1,1,g,0);
    }
    for(int i=last;i<=tot;)
    {
        if(!vis[i]&&cur+stick[i]<=g)
        {
            vis[i]=1;
            dfs(now,i+1,g,cur+stick[i]);
            if(flag)return;
            vis[i]=0;
            if(cur==0||cur+stick[i]==g)return;
            i=next[i];
        }
        else
        {
            i++;
        }
    }
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++){
        int a;cin>>a;
        if(a>50)continue;
        stick[++tot]=a;
        sum+=a;
        mx=max(mx,a);
    }
    sort(stick+1,stick+tot+1,cmp);
    for(int i=1;i<=n;i++)
    {
        int k;
        for(k=i;stick[k]==stick[i];k++);
        next[i]=k;
    }
    for(int i=mx;i<=sum;i++)
    {
        if(sum%i==0)
        {
            val=sum/i;
            dfs(0,1,i,0);
            if(flag)break;
        }
    }
    cout<<ans<<endl;
    return 0;
}



```



---

## 作者：DLYJ (赞：12)

# 题解 P1120 【小木棍 ［数据加强版］】


好久没有写过题了，终于有时间写了几道

这道题写搜索的过程其实不难，难就难在如何剪枝缩短时间

题目所求的是最小木棍长度，因为木棍长度是一样的，所以我们可以直接搜索答案

在输入的时候先累加木棍长度的总和，因为一根木棍也是符合条件的，这可能就是答案

（记得将木棍长度大于50的数据忽略）

接着对木棍长度进行一个从大到小的排序，因为答案肯定大于等于木棍长度的最大值

再对答案进行枚举，枚举过程中可以优化：如果总和除以答案有余数，易知答案错误

## 重要剪枝：

1、优化顺序，dfs判断情况时从最长的木棍枚举到最短的木
棍，因为能与最长的木棍组成当前需要的长度的木棍的个数显然要比长度短的少，能减少分枝数。因为长度不超过50，于是没必要对木棍长度快排，而是直接桶排，常数小且方便判断和回溯。


2、木棍个数应该为整数，所以枚举的长度应该能整除总长度。



3、若当前搜索时已经使用了长度为x的木棍，则下次直接从长度为x从大到小枚举，因为显然比x长的都不可行了，否则当前就不会使用x了。



4、若某次搜索拼接时，当前拼好的长度为0或当前长度加上先前枚举的长度等于需要长度，直接跳出循环，因为我们是递减枚举，显然再往后搜不能再从那些长度小的木棍中拼出当前的长度。

# 附上代码：

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
inline int read()
{
    int sum=0;
    char ch=getchar();
    while(ch>57||ch<48) ch=getchar();
    while(ch>=48&&ch<=57) sum=sum*10+ch-48,ch=getchar();
    return sum;
}
bool cmp(int a,int b) { return a>b; }
int n,mid,cnt,sum,res,ans;
int a[71],vis[71];
bool dfs(int len,int sta,int now) //dfs(剩余长度，根数，组数) 
{
    if(now==res) return 1; //如果 组数 与 当前情况下组数 相等证明方案可行 
    if(len==0) if(dfs(ans,1,now+1)) return 1; //如果剩余长度为0，可以开始下一组的组合 
    for(int i=sta;i<=cnt;++i)
    {
        if(!vis[i]&&a[i]<=len) //如果这一根尚未使用并且小于剩余长度才可以使用 
        {
            vis[i]=1;
            if(dfs(len-a[i],i+1,now)) return 1;
            vis[i]=0;
            if(len==ans||len==a[i]) break; // One Step
            //如果剩余长度=答案证明所剩一根都比它长，显然不成立 
            //如果剩余长度等于当前值，因为还有更小的木棍所以拼不完也不成立 
            while(a[i]==a[i+1]) ++i; //Two Step
            //如果这一根不成立，那么长度和它一样的肯定也不成立 
        }
    }
    return 0;
}
int main()
{
    n=read();
    for(int i=1;i<=n;++i)
    {
        mid=read();
        if(mid>50) continue;
        a[++cnt]=mid,sum+=mid;
    }
    sort(a+1,a+cnt+1,cmp);//从大到小排序 
    for(int i=a[1];i<=sum;++i)//从小到大枚举答案 
    {
        if(sum%i) continue;//有余数肯定不是正解 
        res=sum/i;//当前情况下组数 
        ans=i;
        if(dfs(ans,1,0)) //如果方案可行输出答案 
        {
            printf("%d\n",ans);
            return 0;
        }
    }
}
```


# 代码二：

```cpp
#include<bits/stdc++.h>
#define il inline
#define ll long long
#define N 100
using namespace std;
int n,a[N],tmp[N],maxn,minn=N,cnt;
il void dfs(int res,int now,int len,int p)
{
    if(!res){printf("%d",len);exit(0);}
    if(now==len){dfs(res-1,0,len,maxn);return;}
    for(int i=p;i>=minn;i--)
        if(tmp[i]&&i+now<=len){
            tmp[i]--;
            dfs(res,i+now,len,i);
            tmp[i]++;
            if(!now||now+i==len)break;
        }
    return;
}
int main()
{
    scanf("%d",&n);
    int x,sum=0;
    while(n--){
        scanf("%d",&x);
        if(x<=50){
            a[++cnt]=x;
            maxn=maxn>x?maxn:x;
            minn=minn<x?minn:x;
            tmp[x]++;sum+=x;
        }
    }
    x=sum>>1;
    for(int i=maxn;i<=x;i++)
        if(sum%i==0)dfs(sum/i,0,i,maxn);
    cout<<sum;
    return 0;
}
```


---

## 作者：玉竹君 (赞：10)

### 这是我三个小时做出来的！不是因为难思考！是因为细节！！！哭了！
首先我们还是运用的是深搜的方法，里面我加上了二分法。
这个题的主要思路~~我觉得其实很简单~~
分析一下这道题目，我们不难发现，答案是有范围的，**就是最小是最长那根小木棒，最大是所有小木棒之和！**（划重点，敲黑板）
我们用一个next数组标记，如果有两根一样的木棒，两根的情况是一样的，所以我们算一个就好了。
每一次我们判定完一根木棒后，我们要把它标记，这样我们就不会重复计算了!
还有在输入的时候我们可以进行判定，因为题目中给出了，所以只要该根超过了50我们就可以直接把它拿出来了！
我们设一个函数（nume表示这个是第几根木棒；last是上一个木棒的编号；rest是这根大木棒还剩下多少要拼）
我们不难发现，其实从大到小排比从小到大简单，因为几根小的肯定会比一根大的灵活，我们这样思考这根问题就很简单的可以将这根木棒拼出来。

我们就先写个小代码，叫二分的小可爱：(就是这个小可爱不会让你的代码炸掉哦）

------------
```
int l=last+1,r=coUnt,mid;
	while(l<r)
	{
		mid=(l+r)/2;
		if(a[mid]<=rest)
		{
			r=mid;
		}
		else
		{
			l=mid+1;
		}
	}


```
------------
然后我们判定一下这个小木棒的组成，m代表的是我们这种情况分出的大木棒根数，**裁枝：**如果等于我们假设的了，我们就可以停止了。
下面就是我的代码了：
```
#include<bits/stdc++.h>
using namespace std;
int a[70] ;
int n , m , sum , next[70],len,coUnt;
bool gg[70],pass;
bool comp (int a,int b){return a>b;}
void jj(int num , int last , int rest)
{
	int i;
	
	int l=last+1,r=coUnt,mid;
	while(l<r)
	{
		mid=(l+r)/2;
		if(a[mid]<=rest)
		{
			r=mid;
		}
		else
		{
			l=mid+1;
		}
	}
	if(!rest)
	{ 
		if(num==m)
		{
			pass=1;
			return ;
		}
		for(i=1;i<=coUnt;i++)
		{ 
			if(!gg[i]) break;
		} 
		gg[i]=1;
		jj(num+1,i,len-a[i]);
		gg[i]=0;
		if(pass)
		{
			return;
		} 
	}
	for(i=l;i<=coUnt;i++)
	{
		if(!gg[i])
		{
			gg[i]=1;
			jj(num,i,rest-a[i]);
			gg[i]=0;
			if(pass)
			return ;
			if(rest==a[i]||rest==len)
			return ;
			i=next[i];
			if(i==coUnt)
			return ;
		}
	}
}
int main()
{
	int llo;
	scanf("%d", &n );
	for(int i = 1 ; i <= n ; i++)
	{
		scanf("%d",&llo);
		if(llo>50) continue;
		a[++coUnt]=llo;		
		sum+=llo;
	}
	sort(a+1,a+coUnt+1,comp);
	next[coUnt]=coUnt;
	for(int i=coUnt-1;i>0;i--)
	{
		if(a[i]!=a[i+1])
			next[i]=i;
		else
		next[i]=next[i+1];
	}
	for(len=a[1];len<=sum/2;len++)
	{ 
        if(sum%len!=0) 
		continue; 
        pass=0;
		gg[1]=1;
        m=sum/len; 
        jj(1,1,len-a[1]);
        gg[1]=0;
        if(pass)
		{
			printf("%d\n",len);
			return 0;
		} 		
    }
	printf("%d\n",sum);
	return 0;

}
```

---

## 作者：览遍千秋 (赞：9)

## 答案可能的范围

首先，我们需要知道，答案的最小值肯定不会小于木棍长度的最大值。

其次，假设把所有小木棍全都拼成一根木棍，长度为所有木棍长度的和，答案肯定不会超过这个和。

---

## 什么样的答案可行

设第$i$根木棍的长度为$a_i$，则和$s=a_1+a_2+a_{...}+a_n$。

考虑枚举拼接后的每根木棍长度为$m$，当$m|s$时可行。

---

## 对数据的排序

在本题中，对木棍长度的排序可不仅起到优化搜索顺序的作用，这是程序一个重要剪枝的基础。

本题中需要对木棍的长度进行升序排序，具体原因将在下面解释。

---

## 避免不可能情况下的重复搜索

在本题的搜索过程中，我们有一个原则，即当$a_i=a_{i-1}$且第$i-1$根木棍没有被选取的情况下，第$i$根也不选取。

为什么呢，因为我们在尝试完成一根长度不超过所枚举的$m$的木棍时，是按照从$1$到$n$每一根考虑的，当在过程中放弃一根木棍时，放弃的是和这一根木棍所有相同长度的木棍。

---

## 满足条件后不再搜索

设当前考虑第$i$根木棍，这一根木棍已经拼接了$l$的长度，当$l+a_i=m$时，不再搜索第``i+1``到第``n``根木棍，因为他们肯定在这根木棍中不符合条件。

---

## 代码和细节

code:

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define maxn 67
int n,ans,h,a[maxn],m,ma,j=1;
bool vis[maxn],flag=0;
bool comp(int a,int b)
{
    return a>b;
}//用于sort的比较函数
void f(int u,int l,int c)//u代表已经使用的初始木棍数目，l代表当前拼的木棍的当前长度，c代表上一次选择木棍的位置+1，即现在选择木棍时的编号起始
{
    if(flag) return;//如果已经找到一个可行解，由于是从小到大枚举长度，所以一旦找到可行解，就一定是所求的最优解
    if(l==m)//如果当前拼的这根木棍已经正好为长度为m的木棍，即我们要拼的长度
    {
        if(u==n)//如果木棍已经使用完毕，即找到可行方案
        {
            flag=1;//作出标记
            return;//返回
        }
        else
        	l=0,c=1;//否则开启一根新的木棍，新的木棍当前长度为1，每一根新的木棍都从第一个开始
    }
    if(!l)//如果是新的木棍
    {
        int fff=0;
        while(vis[++fff]);
        vis[fff]=1;//找到编号最小且没有使用过的初始木棍，即当前还可用的最短的初始木棍，fff为这根木棍的编号
        f(u+1,l+a[fff],fff+1);//继续向下搜索
        vis[fff]=0;//回溯
        return;
    }
    for(int i=c;i<=n;i++)//从上一个选择的木棍下一个开始搜索，直到第n个
    {
        if(!vis[i]&&a[i]+l<=m)//如果这根木棍没有用过且在长度上可行
        {
            if(!vis[i-1]&&a[i]==a[i-1]) continue;//是否为不可能情况下的重复搜索，如果是，则不考虑这根木棍
            vis[i]=1;//符合条件，继续搜索
            f(u+1,a[i]+l,i+1);
            if(flag) return;//如果找到答案则直接返回
            vis[i]=0;//回溯
            if(l+a[i]==m) break;//如果这根初始木棍是当前形势下的可取的最长值，不考虑后面的木棍
        }
    }
}
int main()
{
        scanf("%d",&n);
        for(register int i=1;i<=n;i++)
        {
            scanf("%d",&a[j]);
            if(a[j]<=50)
            {
                h+=a[j],ma=max(ma,a[j]);
                j++;
            }
        }
        n=--j;//输入、忽略超过50的，求和
        sort(a+1,a+n+1,comp);
        for(register int i=ma;i<=h;i++)
        {
            if(h%i==0)//如果能够整除，则当前长度可能存在答案，开始搜索
            {
                m=i;
                f(0,0,1);
                if(flag)
                {
                    printf("%d\n",i);
                    break;
                }
            }
        }
}
```


---

## 作者：Alan_lcs (赞：7)

做了一下午，作为菜鸡的我终于AC掉他了，哈哈，发个题解祝贺一下；

先来个代码（写的不好，勿喷）


            
    
```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
int len[65];
bool used[65];
int sum,L,n=0,nn,last=0,x;
int cmp(const void *a,const void *b)
{
    return *(int *)b-*(int *)a;
}
bool DFS(int m,int left)    //m为剩余的未用的木棒数，left为当前正在拼接的木棒和假定的木棒长度L比还缺少的长度
{
    if(m==0&&left==0)
        return true;
    if(left==0)     //一根刚刚拼完开始拼新的一根
        left=L;
    x=0;
    if (left!=L) x=last;          //这个点很重要，这也是大多数人69分的原因，由于这个题的数据过于强大，所以能减就得减，这里的意思是当left！=L时 
    for(int i=x;i<n;++i)          //left一定已经被别的小棍减小过，而比那个之前的木棍还要大的木棍当然就得把他淘汰了（PS；就是这个点卡了我一下午） 
    {
        if(!used[i]&&len[i]<=left)
        {
            if (len[i]>left) continue;
            if(i>0)
            {
                if(!used[i-1]&&len[i]==len[i-1])    //第一次剪枝：
                    continue;                        //如果当前的没用过的棒子不可用，那么和他长度相同的未使用的棒子也不可用，直接跳过
            }
            used[i]=true;last=i;
            if(DFS(m-1,left-len[i]))
                return true;
            else
            {
                used[i]=false;//说明不能用i作为第一条，那么要拆以前的木棒，i还可能用在以前的木棒中，所以回溯
                if (left==L&&used[i]==false) return false;
                if(len[i]==left||left==L)  //重要剪枝---很重要否则会超时
                    return false;          //将开始搜索一支长为 L 的木棍时，我们总是以当前最长的未
            }                               //被使用的 木棍开始，如果搜索不成功，那么以比它短的开始
        }                                   //也一定不能取得全局的成功。因为每一支题目给出的木棍都要被用到。
    }                                       //len[i]==left是指dfs了一轮，len[i]这个正合适的都不能用到，就不需要考虑用比他小的凑出left了 
                                            //left==L是指搜索了一大圈，但是仍然没有合适的让left变化，当然就不合适了 
    return false;    
}
int main()
{
        n=0;
        int cs;
        scanf("%d",&nn);
        sum=0;
        for(int i=0;i<nn;++i)
        {
            scanf("%d",&cs);
            if (cs<=50){
            len[n]=cs;
            sum+=len[n];
            n++;
            }
            else{
            continue;}
        }
        qsort(len,n,sizeof(int),cmp);       //从大到小排序，从最大的开始搜，因为所有的都要用到，所以就先把最不好解决的解决了，也是后面last等优化的基础 
        for(L=len[0];L<=sum/2;++L)          //若L>sum/2则只有一种可能就是所有木棒只能拼接成一根。
        {
            if (sum%2==1&&L%2==0) continue;
            if(sum%L)
                continue;
            memset(used,false,sizeof(used));
            if(DFS(n,L))
            {
                printf("%d\n",L);
                    break;
            }
        }
        if(L>sum/2)
            printf("%d\n",sum);
    return 0;
}
```

---

## 作者：George1123 (赞：5)

[${\color{orange}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/wzc-wwwwd/)

[P1120 【小木棍 ［数据加强版］】传送门](https://www.luogu.org/problem/P1120)

### 此题算法:暴搜

由于错误思想太多了，题解只讲正确算法

>1.输入木棍长度，算出合法木棍的数量$t$，长度和$sum$，长度最大值$maxn$，并将木棍桶排序。

>2.枚举长木棍长度$len$，$tot$表示拼成的长木棍数量。然后$dfs$，四个参数中$k$表示拼到第几根长木棍，$rest$表示当前拼的长木棍剩余需拼长度，$lon$表示拼一个新长木棍时枚举最长的小木棍长度，$st$表示在拼某一个长木棍时依次枚举的小木棍长度。

>3.如文中剪枝，$dfs$的返回值是方案是否可行，第一个可行的方案中，$len$就是答案。

## 以下是代码


```cpp
#include <bits/stdc++.h>
using namespace std;
int n,in[70],maxn;
int t,a[70],sum,ans;
int num[70],len,tot;
inline int read(){
    int f=1,dig=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') f=-1; 
        ch=getchar();
    } while(ch>='0'&&ch<='9'){
        dig=(dig<<3)+(dig<<1)+ch-'0';
        ch=getchar();
    } return f*dig;
} 
//lon表示：每次要拼一个新的长木棍时，
//枚举的最长的小木棍的长度
//（显然，这个值是非递增的，每次向下枚举） 
//st表示：在拼某一个长木棍时，依次枚举的小木棍长度。
//（这个也是非递增的，每次可以从start向下枚举）。 
bool dfs(int k,int rest,int lon,int st){
	if(k==tot+1) return 1;
	if(!rest) return dfs
		(k+1,len,lon,lon);
	st=min(st,rest);
	for(int now=st;now;now--)
		if(num[now]){
			num[now]--;
			int tmp;
			if(len==rest)
				tmp=now;
			else tmp=lon;
			if(dfs(k,rest-now,tmp,now))
				return 1;
			//如果Len==rest，代表这是这根长木棍第一次拼，更新一下longest的值。 
			num[now]++;
			if(len==rest) break; 
			/*这个表示长木棍是第一次拼。 
			注意，目前这根短木棍now最终必然会属于一个长木棍。
			如果第一次拼时不合法，说明这根短木棍所在的长木棍无法被拼出，可以直接结束 。*/ 
			if(now==rest) break;
			/*如果现在剩下rest，而且刚好有一根长度为rest的木棍，我肯定选它最优；
			所以，如果试了它发现不成功，一定不会成功。*/
		}
	return 0;
} int main(){
//	freopen("1120.in","r",stdin);
	n=read();
	for(int i=1;i<=n;i++){
		in[i]=read();
		if(in[i]<=50){
			a[++t]=in[i];
			sum+=a[t];
			maxn=max(maxn,a[t]);
		}
	} if(!t){
		printf("0\n");
		return 0;
	} for(int i=1;i<=t;i++)
		num[a[i]]++;
	for(int i=maxn;i<=sum;i++){
		if(sum%i>0)
			continue;
		len=i; tot=sum/i;
		if(dfs(1,len,maxn,maxn)){
			ans=i;
			break;
		}
	} printf("%d\n",ans);
	return 0;
}
```
$\colorbox{#f00000}{\color{white}\text{WA}}$此题别灰心，再做几遍就$\colorbox{#00d000}{\color{white}\text{AC}}$了

谢谢大家! !


---

## 作者：AKB48 (赞：5)

总得来说就是剪枝DFS:枚举最小长度,进行拼凑.


几个剪枝:

1.    枚举最小长度时(设为len),可得:min(小木棍长度)<=len<=小木棍总长,同时(总长 mod len=0).

2.    当每次接入小木棍后,大木棍未达到要求长度时,下一个接入的小木棍取比刚刚接入的小木棍短的小木棍.

3.    当一个小木棍接入后,当前处理的大木棍刚好达到要求的长度的话,没必要用更多的小木棍代替这个刚接入的小木棍,因为更短的小木棍比它有更大的适用性(所以把它们留在后面用必定比接入这里更好).

4.    当处理完一个大木棍之后,接入下一个大木棍的第一根小木棍用剩下的最长的小木棍.


几个处理:

1.    枚举最小长度时由小到大枚举,找到第一个后直接输出就可以HALT了.

2.    将所有木棍由大到小排序,以便剪枝.


注意事项:

题目说:"直到每段的长都不超过50",所以去掉超过50的小木棍


---

## 作者：ksydom (赞：4)

本蒟蒻比楼上的dalao菜，所以写了一个经典方法还提了14遍写了一天。。。
不过这道题用到了目前的所有剪枝方法
具体方法在代码中。
          
 另附本人的错点：1. cmp从大到小是x>y;(我为什么会写错还查不出来)   2.注意左闭右开区间  3.滤50时top前后建议重记，用top或者top++都会出错
 
中间有★的地方是可以剪枝的

上代码：
```cpp
//整体思路：首先，个人不理解的地方是小木棍的数量没有给定，要靠枚举来一个一个试
// 所以第一遍认为需要二分，然而并不是二分，只要直接试就好了 
//  记你已经用了多少个小木棍，当用完时跳出 ①再记一个剩下了多少，不剩并且用完时就不用记了 
//  ②然后就是常规，如果小木棍数量没完，但是一根木棍的长读完了，就下来一根 
//  因为是一个一个枚举的，所以会在恰好可以的数量结束（具体讲解在代码中） 
#include<bits/stdc++.h>
using namespace std;
int a[109];
bool used[109];
int top=1,n;
int length;//其实这里可以记进dfs中 
bool comp(int x,int y)
{
	return x>y; //别写反 
}
bool dfs(int tot,int rest,int last)//tot已经拼了几根 rest是剩下的总长（一根）  length是已经拼成的最长长度
//★last 记上一个木棍因为数组是从大往小排的（见后剪枝），所以 他的下一次加木棍没必要加比他小的木棍。而且不用考虑一样的情况，所以从他的下一位开始加这样可以极大的提高速度（终级优化）					               
{
	if (tot == top && rest == 0)   return 1;//如果小木棍没了，并且长度够了，说明这就是正确的最小长度
	if (tot == top)  return 0;//这一步其实没有必要,因为是一位一位判的，但严谨起见加上了 
	if (rest == 0 ) rest = length,last=0;//如果总长拼完了但是小木棍还有，就再来一根 （逗号仅为个人喜好，谨慎使用） 
	for (int i = last+1; i < top; i++)//枚举空间中的小木棍，看哪根能用 
	{
		if(used[i]) continue; //如果用过了继续下一组 
		if(rest-a[i]<0) continue;//如果加到最后一组 	
		used[i] = 1;//经典dfs 
		if(dfs( tot+1, rest - a[i],i)) return 1;
		used[i] = 0;
		if(a[i]==rest || length==rest) break;//★头尾剪枝
//难点 这里因为已经在回溯之后，所以知道一定是判错跳出来的，这样的话就判断头位和尾位两种情况：
//因为他们已经错了，再加上两段比他小的合成的话效果是一样的，所以去上一行（去上一个）重判； 
		while(a[i]==a[i+1]) i++;//★去重剪枝 如果一样的话进位，这样就可以忽略掉重复的情况 
	}
	return 0; 
}
int main()
{
	int qi=0,he=0;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int tmp;
		cin>>tmp;
		if(tmp<=50)
		{
			a[top++]=tmp;
		}//这里是滤50的方法，先拿一个tmp记输入的数，判断是否大于50，不是就扔，是就存入a数组中 
		//he+=a[i];
		//qi=max(qi,a[i]); ////我的错误，重来一个for为思路简便	
	}
	for(int i=1;i<top;i++)
	{
		he+=a[i];
		qi=max(qi,a[i]);   
	}
	//cout<<"qi=="<<qi<<" "<<"he=="<<he<<endl;
	/*for(int j=1;j<top;j++)
	{
		cout<<a[j]<<" ";
	}
	cout<<endl;*/
	sort(a+1,a+top,comp);//★最优化剪枝 从大到小排序 
	/*for(int j=1;j<top;j++)
	{
		cout<<a[j]<<" ";
	}*/
	//cout<<endl;
	for (int i = qi; i <= he;i++) //枚举所有可能的长度，如果可以则输出
	                             
	{
		if(he%i!=0) continue; //★重点  可能性剪枝  长木棍是整根的，所以木棍总长一定整除单个长木棍数 
		length=i;//因为没记在dfs中所以在这里赋值 
		if (dfs(1,i,0))//从第一根木棍开始，还没减时剩下length长度的rest量，他的上一个就是第0个 
		{
			cout<<i;
			break;
		}
	}
	return 0;
}
```

---

## 作者：时崎狂三老公 (赞：4)

//我发这篇题解主要是因为有很好很容易理解的题解被压在下面了，我来再次码一遍。

```cpp
//
//显然,dfs搜索的是木棍总长的因数。 
//
//一共有4个优化(不算上速读)。
//
//   1. 我们搜索的木棍长度假设是合法的,那么每一组达到了当前长度的木棍组合，一定是存在的。
//例如样例：5 2 1 5 2 1 5 2 1 比如说我搜索木棍总长的因数6,我们目前搜的木棍组是(5,1),如果这个6的木棍长度是合法的话,那么必有一组木棍组合是(5,1).
//所以当我们搜索的木棍组是(5,1)但在之后的搜索中搜不出长度为6的木棍组,那么这个木棍长度就是非法的。
//推广到所有长度,即只要如果当前木棍组达到了木棍长度,却在之后的搜索中的木棍组并不能达到这个木棍长度,那么这个木棍长度就是不合法的。 
//   
//   2. sort排序从大到小改变搜索顺序,可以更快(因为我们一旦找到合法数据就可以退出)。 
//
//   3. 我们要从上次搜索的终点往后搜索,所有的原理都离不开第一点。
//   
//   4.如果当前这个木棍组的长度+当前的a[i] (a[i]为我们一开始输入的每根被砍碎的木棍的长度),还不能达到当前我们搜索的木棍长度
//      那么值相同的a[i]都不能使这个木棍组的长达到木棍组长度,我们的sort排序也为这点提供了基础。
//
//  由于本人本身代码能力和储存的知识尺度和智力范围：
//  题解最正常，代码这次不是很简洁(本人发题解的习惯) 
#include<bits/stdc++.h>
#define maxn 100+10+9+1
using namespace std;
int m,n,ans,flag,maxnn,a[maxn],b[maxn],vis[maxn];
bool q,pd[maxn];
int cmp(int x,int y){
    return x>y;
}
inline void ccin(int &x){
    int k=1,kk=0;
    char c;
    c=getchar();
    while(c<'0' || c>'9'){
        if(c=='-') k=-1;
        c=getchar();
    }while(c>='0' && c<='9'){
        kk=kk*10+c-'0';
        c=getchar();
    }x=kk*k;
}                                                       //速读。 
void p(int x){
    if(x==1){
        b[n++]=1;
        return ;
    }
      for(register int i=2;i<=x/2;i++)
        if(x%i==0 && i>=maxnn) b[n+=1]=i;                //找因数。
}                                                        
void dfs(int record,int sum,int step,int begin){        //record我们搜索的木棍长度,sum当前的木棍组的长度,step我们有几组木棍组的长度达到了我们搜索的木棍长度,begin上次搜索的终点。 
    if(q) return ;                                      //我们找到的话就跳掉。 
    if(step*record==flag){                              //如果我们的合法的木棍组数的数量乘上我们搜索的木棍长度达到木棍总长的话，那么这根木棍长度就是合法的。 
        ans=record;                                     //由于我们是从小的木棍总长的因数开始搜索的，那么ans只要更新为当前的木棍总长的因数即可，即record。 
        q=1;
        return ;
    }
    if(sum==record) dfs(record,0,step+1,1);
    for(register int i=begin;i<=m;i++){
        if(!pd[i] && a[i] && a[i]+sum<=record){         //由于我把每次木棍长度>50的碎木棍长设为 0所以多加了判断条件。 
                pd[i]=1;
                dfs(record,sum+a[i],step,i+1);
                pd[i]=0;
                if(sum+a[i]==record || sum==0) break;    //优化1. 
                while(a[i]==a[i+1]){                    //优化4. 
                    i++;
                }    
            }
        }
    }                                                  
int main(){
    ccin(m);
    for(register int i=1;i<=m;i++){
    ccin(a[i]);
    if(a[i]>50) a[i]=0;                                 //过滤非法数据,设为0. 
    ans+=a[i];
    maxnn=max(maxnn,a[i]);
}
  flag=ans;
  p(ans);
  sort(a+1,a+m+1,cmp);                                  //优化2. 
  for(register int i=1;i<=n;i++){
    dfs(b[i],0,0,1);
    if(q) break;                                        //由于我们是从小的因数开始找的所以一找到就退出。 
}
      printf("%d",ans);                                 //输出ans。 
    return 0;                                          //给个零自己体会什么意思。 
}
```

---

## 作者：Rbrq (赞：4)

  本人第一篇解报，不是题解，重复，不是题解，因为本人太弱了，所以无法自己想出新解法，大部分时间解报都是对题解整理。以后会对蓝题~~或者绿题，反正我都不会~~以上的题目做解报。
  

------------

   ~~毒瘤~~良心管理员非常~~毒瘤~~良心地对本题某些数据的时间限制进行修改，深入研究后发现其实可以将所有数据的时限改成200ms（逃。
   
   本题有非常多的剪枝技巧
   
   1.可以在定义变量maxn，并在输入的时候寻找最长♂的木棍长度，然后定义变量ans，来计算所有小木棍总和长度。我们可以只枚举maxn到ans/2间木棍长度，大大减少枚举数量。（可以只枚举一半是因为先dfs长度，如果找不到一定是原来只有一根。（很显然）（逃
   
   2.在dfs之前先判断该数是否ans|i，如果是再dfs，减少了枚举数量。
   

  事实上只用这两个剪枝方法就可以a掉这题，不过前文提到可以通过剪枝使最大数据可以在200ms之内通过，接下来先贴上运用前两种方法的代码然后再剪枝到毒瘤时间
  ```cpp
#include<bits/stdc++.h>
using namespace std; 
int n,tot=0,ans=0,maxn=0,minn=0x7fffffff;
int num[3600]={0};
void dfs(int last,int now,int need,int can){  //四个变量分别表示 还需要几根木棍 
	if(last==0){printf("%d",need); exit(0);}                 // 已经凑出木棍的长度 
	if(now==need){dfs(last-1,0,need,maxn); return;}          // 需要木棍长度 
	for(int i=can;i>=minn;i--){                              //目前可用最大木棍长 
		if((num[i]!=0&&(i+now<=need))){                      //简单的dfs过程 
			num[i]--;
			dfs(last,now+i,need,i);
			num[i]++;
			if(now==0||now+i==need) return;
		}
	} 
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){ 
		int a; 
		scanf("%d",&a);
	    if(a<=50){
	    num[a]++; ans+=a;
	    maxn=max(a,maxn);           // 在输入过程中处理出最大的木棍长度和最小的 
	    minn=min(a,minn);           //木棍长度，完成剪枝 
		}
	}
	for(int i=maxn;i<=ans/2;i++)  if(ans%i==0) dfs(ans/i,0,i,maxn);
	printf("%d",ans);
	return 0;
} 
```


------------

  接下来是将最大数据剪枝到200ms的玄学剪枝

   3.根据某表情符大佬的理论，一根比较长的棍子在本题是不如一根比较短的棍子的，直观的感受一下，确实如此，你长归你长，但是你的灵活运用上不如短的棍子，所以我们用一遍sort，使得较长的棍子排到前面去。
   
   4.用过的棍子长度相同就不要再用一次~~（桶装数据表示其实上面两个优化都有）~~
   
   5.非常难想到的一点：：如果当前长棍剩余的未拼长度等于当前木棍的长度或原始长度，继续拼下去时却失败了，就直接回溯并改之前拼的木棍。
   解释起来就是，你和要的一样长，但是你却不能自组，你都不能自组，难为那些比你还短的木棍干嘛呢
   
   以上就是P1120 【数据加强版】~~（臭不要脸明明降低时限）~~
   
   个人认为如果只是a掉这题可能只有【普及+/提高】绿题水准，但是如果要求全部点都在200ms以内的话，可能有【提高+/省选-】，建议管理员再加强数据（逃
   
   最后感谢 ______ 大佬   
    还有某陈巨神 
    
   附评测记录
   
 ##   我的评测:[评测记录](https://www.luogu.org/record/show?rid=9693756)

---

## 作者：WjNaG (赞：3)



### 题目描述：
每组数据给出N根小木棍，把它们拼接成若干根长度相等的木棍，求该长度的最小值。

### 题解：
这题似乎就是暴搜加剪枝优化，不过剪枝比较复杂。
先上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

int a[100],v[100],n,len,cnt;
               //正在拼 当前长度 上一根小木棍 
bool dfs(int stick,int cab,int last){  
	if(stick>cnt) return true;      //正在拼的大于总数 即全拼完
    //这一根拼完，拼下一根 
	if(cab==len) return dfs(stick+1,0,1); 
	int fail=0;         //剪枝（1）
	for(int i=last;i<=n;i++){    //剪枝（2）
		if(!v[i]&&cab+a[i]<=len&&fail!=a[i]){
			v[i]=1;     //剪枝(3)
			if(dfs(stick,cab+a[i],i+1)) return true;   //递推
			fail=a[i];
			v[i]=0; 
            //剪枝(4)
			if(cab==0||cab+a[i]==len) return false;  
		}
	}
	return false;
}

int main(){
	while(cin>>n){
		int sum=0,val=0;
		for(int i=1;i<=n;i++){
			cin>>a[i];
			if(a[i]>50){   //加强版要把超过50的长度过滤掉
				i--;
				n--;
				continue;
			}
			sum+=a[i];
			val=max(val,a[i]);
		}
		sort(a+1,a+n+1);
		reverse(a+1,a+n+1);
		for(len=val;len<=sum;len++){
        //木棍长度必定是长度和的约数
			if(sum%len) continue;    
			cnt=sum/len;      
			memset(v,0,sizeof(v));
			if(dfs(1,0,1)) break;
		}
		cout<<len<<endl;
	}
	return 0;
}
```
4个剪枝：
(1) 对于当前原始木棒，记录最近一次尝试拼接的木棍长度。如果分支搜索失败回溯，不再尝试向该木棍中拼接其他相同长度的木棍（必定也会失败）
(2)使加入小木棍的长度递减
(3)用vis数组标记每根木棍是否用过。因为如果cab==len，last会重置为1
(4)如果当前长棍剩余的未拼长度等于当前木棍的长度或原始长度，继续拼下去时却失败了(前面没有return true)，就直接回溯并改之前拼的木棍。

   当前长棍剩余的未拼长度等于当前木棍的长度时，这根木棍在最优情况下显然是拼到这（如果用更多短木根拼完剩下的这段，把这根木棍留到后面显然不如把更多总长相等的短木棍扔到后面）。如果在最优情况下继续拼下去失败了，那肯定是之前的木棍用错了，回溯改即可。
   
#### 写作时间：
2019-7-31

### 广告
[CSDN博客](https://blog.csdn.net/WjNaG)

---

## 作者：王鹏PRO (赞：3)

这个题目考察两点：
1. 剪枝
2. DFS

以下是对题目进行分析,得出能够进行**剪枝**的地方
1. “**每段的长都不超过50**” “**超过50的长度自觉过滤掉**” 所以声明int[51],既能保存数据又能供桶排序使用
2. “**乔治有一些同样长的小木棍**” 求 “**最小可能长度**”ans 所以所有小木棍长度和一定能被ans整除
3. “ **可能长度**” 范围是：[所有小木棍最大 , 小木棍长度和]
4. “**最小长度**” 得到最小长度结束DFS

所以剪枝策略是：
1. 读取数据时，桶排序+忽略大于50的数据+获取所有小木棍的最大、最小、最长度的和
```java
        for (int i = 0; i < N; i++) {
            in.nextToken();
            int t = (int) in.nval;
            if (t > 50) continue;
            nums[t]++;
            total += t;
            s = Math.min(s, t);
            e = Math.max(e, t);
        }
```


2. 不能用total整除的可能长度i，不进行dfs尝试
```java
        for (int i = e; i < total; i++) {
            if (total % i != 0) continue;
            find(total / i, 0, i, e);
            if (ans != 0) break;
        }
```


3. 从小到大遍历可能的长度，一旦找到立即结束

```java
        if (cnt == 0) {
            System.out.println(len);
            System.exit(0);
        }
```

剩余要考查的就是递归遍历dfs了
使用递归遍历的方式，选定一个长度i，验证小木棍相加后中能得多个长度为i
```java
private static void find(int cnt, int sum, int len, int max) {
        if (cnt == 0) {
            System.out.println(len);
            System.exit(0);
        }
        if (sum == len) {
            find(cnt - 1, 0, len, e);
            return;
        }
        for (int i = max; i >= s; i--) {
            if (nums[i] > 0 && i + sum <= len) {
                nums[i]--;
                find(cnt, sum + i, len, i);
                nums[i]++;
                if (sum == 0 || sum + i == len) break;
            }
        }
    }
```

下面是完整的java代码：
```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;

public class Main {
    private static final int[] nums = new int[51];
    private static int ans = 0, s = 100, e = 0, total = 0;

    public static void main(String[] args) throws Exception {
        StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        in.nextToken();
        int N = (int) in.nval;
        for (int i = 0; i < N; i++) {
            in.nextToken();
            int t = (int) in.nval;
            if (t > 50) continue;
            nums[t]++;
            total += t;
            s = Math.min(s, t);
            e = Math.max(e, t);
        }
        for (int i = e; i < total; i++) {
            if (total % i != 0) continue;
            find(total / i, 0, i, e);
            if (ans != 0) break;
        }
        if (ans == 0) ans = total;
        System.out.println(ans);
    }

    private static void find(int cnt, int sum, int len, int max) {
        if (cnt == 0) {
            System.out.println(len);
            System.exit(0);
        }
        if (sum == len) {
            find(cnt - 1, 0, len, e);
            return;
        }
        for (int i = max; i >= s; i--) {
            if (nums[i] > 0 && i + sum <= len) {
                nums[i]--;
                find(cnt, sum + i, len, i);
                nums[i]++;
                if (sum == 0 || sum + i == len) break;
            }
        }
    }

}

```


---

## 作者：zhaoyifan (赞：3)

主要难点在于如何进行dfs的剪枝

可以二分答案（不二分也不会超时，我的代码没有二分），dfs看看这个答案可不可行

虽然数据很小，直接dfs也是会超时的，所以需要加入一些剪枝。

1.从max（最大木棍长度，总木棍长度/要分的段数）为左面，所有木棍长度为右面二分答案。

2.木棍长度要排序，方便每次dfs从小到大，为避免重复搜索（比如说2 3 4 和2 4 3）定义一个pos，每次枚举从pos开始，这也是为什么排序的原因之一。

3.如果现在搜索状态的剩余长度和二分答案的长度相等，还搜不出答案，说明有木棍无解，直接break跳出循环。

4.如果现在搜索状态的剩余长度和循环搜索到木棍的长度相等，那么下一次dfs的状态如3，还搜不出答案，说明有木棍无解，直接break跳出循环。

5.如果这个长度的木棍搜不出答案，相同长度的也搜不出答案。

下面是满分代码（ac数据加强版）




```cpp
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
bool vis[101];
int n,a[101],tot,all,len;
int cmp(int x,int y)
{
    return x>y;
}
bool dfs(int now,int pos,int d)
{
    if(d==tot)
    {
        return 1;
    }
    if(now==0) 
    if(dfs(len,1,d+1)==1) return 1;
    for(int i=pos;i<=n;++i)
        if(vis[i]==0&&a[i]<=now)
        {
            vis[i]=1;
            if(dfs(now-a[i],i+1,d)) return 1;
            vis[i]=0;
            if(now==a[i]||now==len) break;   //3,4
            while(a[i+1]==a[i]) i++;        //5
    }
    return 0;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;++i)
    {
        cin>>a[i];
        if(a[i]>50)
        {
            i--;n--;
        }
        else all+=a[i];
    }
    sort(a+1,a+1+n,cmp);        //2
    for(int i=a[1];i<=all;++i)  //1
    {
        if(all%i==0) 
        {   len=i;
            tot=all/i;
            if(dfs(len,1,0)==1)
            {
                cout<<len;
                return 0;
            }
        }
    }
}
```

---

## 作者：翠竹叶飞 (赞：3)

dfs+剪枝

1.对木棍降序排序，枚举原长为总长的约数。

枚举每1根木棍时，剪枝如下：

2.第1根选最长的，且不必换。因为这一根迟早要被选，只需枚举1次。

3.重复长度的木棍枚举1根后失败，其余的都不必选。

4.若剩余的长度比最短的还要短，退出。

5.若剩余长度比剩下木棍之和还要大，退出。

6.与2类似，若最后1根失败了，即使它可以被其它若干小的木棍替换，

长木棍的用处一定比短的小。即短的两根都无法成功，长的更不可能了。

此时轻松过所有数据。

主要思想：优先尝试可能性少的步骤，避免实质相同的搜索。

```cpp
#include<iostream>
#include<cstdlib>
#include<algorithm>
#include<cstring>
#include<cstdio>
using namespace std;
int i,j,n,a[101],s[101];
int len,num;
int tot,maxn;
bool used[101],flag=0;
void dfs(int, int, int);
int comp(int a, int b)
{
    return a>b;
}
void fit(int cnt)
{
    if (len == tot || cnt == num) //必定成功或剩下1根已定
    {
        flag=1;
        return;
    }
    int i;
    for (i=cnt; i<=n; i++) 
      if (used[i]==0) break;
    used[i]=1;
    dfs(cnt,len-a[i],i+1);
    used[i]=0; //回溯 
}
void dfs(int cnt, int leftlen, int p)
{
    if (leftlen==0)
    {
        fit(cnt+1);
        return;
    }
    if (leftlen < a[n]) return;    //可行性 
    for (int i=p; i<=n; i++)
      if (a[i]<=leftlen && used[i]==0)
      {
        if (leftlen > s[i]) return; //可行性
          used[i]=1;
          dfs(cnt,leftlen-a[i],i+1);
          if (flag) return;
          used[i]=0;
          if (leftlen == a[i]) return; //the last one
          for (; i<n; i++) //剪枝3 
          if (a[i]!=a[i+1]) break;
      }
}
int main()
{
    scanf("%d",&n);
    for (i=1; i<=n; i++)
        scanf("%d",&a[i]);
    sort(a+1,a+n+1,comp);
    for (i=1; i<=n; i++)
      if (a[i]<=50) break;
    //过滤 
    for (j=1; i<=n; j++,i++)
      a[j]=a[i];
    n=j-1;
    for (i=1; i<=n; i++) 
    {
        tot+=a[i];
        maxn=max(maxn,a[i]);
    }
    for (i=n; i>=1; i--) 
      s[i]=a[i]+s[i+1];
    for (len=maxn; len<=tot; len++)
      if (tot%len==0)
      {
          memset(used,0,sizeof(used));
          num=tot/len;
          fit(1);
          if (flag){
              printf("%d",len);
              return 0;
          }
      }
}
```

---

## 作者：Deny_小田 (赞：3)

本题 ≈ poj1011

题解：

需要有技巧的dfs，注意一些小细节，我是一遍过的，因为我想的**比较**全面。

本篇题解赠送注释，主要思路都在里面了，不懂得看注释。






```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int size = 105;
int sum,a[size],n,k;
bool visited[size];
int cmp(int a,int b){ return a > b; }
int dfs(int len, int n, int stave, int now){            //len表示当前最小可能长度，n就是木棒个数
                //stave表示当前木棒个数，now表示可以再拼的长度
    if(stave == n&&now == 0) return len;            //所有木棒已全部用完，并且全拼完了，即成功
    if(!now) now = len;                    //拼完一个
    for(int i = 0; i < n; i++){
        if(visited[i] == true) continue;        //已经拼过了
        if(a[i] > now) continue;                //因为a[i]是要匹配的对象，它比剩余长度还大，肯定不可能匹配
                    //不满足题意，continue
        visited[i] = true;
        if(dfs(len,n,stave+1,now-a[i])) return len;
```
/\*  以下为dfs不成功处理的事情   \*/




```cpp
        visited[i] = false;                        //回溯
        if(now == a[i]||now == len) break;
            //剪枝2：
            //第一个条件 now == a[i]意思为dfs了一圈发现没有任何木棒与它匹配，break
            //第二个条件 dfs了一遍发现没有任何作用，也break
        while(a[i] == a[i+1]) i++;                //剪枝3：如果当前不成功，则与当前相同的数也一样不能成功
    }
    return 0;
}
int main(int argc, char const *argv[]){
    scanf("%d",&n);
    sum = 0;                //sum为搜索的上限，即最高搜到sum就停止
    for(int i = 0; i < n; i++){ scanf("%d",&a[i]); if(a[i] > 50){ i--; n--; continue; } sum += a[i]; }
    sort(a,a+n,cmp);                //剪枝一，
    for(int i = 1; i <= sum; i++){
        if(sum%i != 0) continue;            
                    //这种情况一定不行，算是一个小剪枝，因为总和为sum，如果连i都不能整除的话，更不可能分出整数份
        memset(visited,false,sizeof(visited));
        k = dfs(i,n,0,i);                        //调用不解释，参数含义上面有
        if(k) break;                //k非零，即成功，跳出循环
    }
    printf("%d\n",k);
    return 0;
}
```
PS：由于我水平有限，如果注释写错了，请私信@Deny\_小田，感谢指正！
参考资料：http://blog.csdn.net/xuezhongfenfei/article/details/8523380


---

## 作者：夏色祭 (赞：3)

#这真的是一道很（e）好（xin）的搜索题

##数据更新后都没有P的，那我来补一发

**蒟蒻的我改了一个晚上，加了无数个优化。。。**

主要讲蒟蒻的我用了哪些优化：

1：只有木棍长度总和的因数才有可能是最后的答案，所以不是的就不用去搜了。

2：对木棍长度按降序排序。

3：用sum[i]表示第i根到第n根木棍的长度总和，如果当前长度+sum[i]都<我们找的木棍长度就跳出当前循环。

4：用f[i]表示用这些木棍能否拼成长度为i的木棍，如果not f[我们找的木棍长度-当前长度-当前要接入的木棍长度]就说明这种方案不行。

5：用last记录我们上次接入的木棍长度，下次尝试接入的木棍长度和last不同才能接入，当然只是两次尝试接入的木棍均为第k根尝试接入的。

6：我们用t记录上次取的木棍的编号，下一个尝试接入的木棍的编号必须是t+1 to n，也就是下一个尝试接入的木棍长度必须<前一次接入的木棍长度（因为我们已经按降序排好序了），如果如果当前接入的木棍长度+我们之前接的木棍长度总和=我们找的木棍长度，那么t=0。

7：如果当前接入的木棍长度+我们之前接的木棍长度总和=我们找的木棍长度，则直接exit掉。

8：当前接入的木棍长度+我们之前接的木棍长度总和必须<=我们找的木棍长度。

#……

大概主要就是这几个了，希望对像我一样的蒟蒻们有帮助。。。

AC代码：

```cpp
var 
  a,summ:array[0..65]of longint;
  b:array[0..65]of boolean;
  f:array[-10000..10000]of boolean;
  n,m,i,j,sum,ans,x,last:longint;
procedure try(k,l,t,zz:longint);
var
  i,last:longint;
  begin
    if (k>n)and(l=0) then 
      begin
        writeln(ans);
        halt;
      end;
    if k>n then exit;
    last:=0;
    for i:=zz to n do 
      begin
      if l+summ[i]<ans then break;
      if (not b[i])and(a[i]<>last){优化5}and(l+a[i]<=ans){优化8}and(f[ans-l-a[i]])and(a[i]<=t) then 
        begin
          b[i]:=true;
          if l+a[i]=ans then 
            begin
              try(k+1,0,6666,1{优化6});
              b[i]:=false;
              exit;//优化7
            end;
          try(k+1,l+a[i],a[i],i+1{优化6});
          b[i]:=false;
          last:=a[i];
          if l+a[i]=ans then exit;
          if l=0 then exit;
        end;   
      end; 
  end;
begin
  readln(n);
  i:=0;
  while i<n do
    begin 
      inc(i);
      read(x);
      if x<=50 then 
        begin
          inc(j);
          a[j]:=x;
          inc(sum,x);
        end;
    end;
  n:=j;
  f[0]:=true;
  for i:=1 to n do 
    for j:=sum downto a[i] do 
      f[j]:=f[j] or f[j-a[i]]; //优化4
  for i:=1 to n-1 do 
    for j:=i+1 to n do 
      if a[i]<a[j] then
        begin
          a[0]:=a[i];
          a[i]:=a[j];
          a[j]:=a[0];
        end;//优化2
  for i:=n downto 1 do 
    summ[i]:=summ[i+1]+a[i];//优化3
  for i:=a[1] to sum do 
    if (sum mod i=0) then //优化1
      begin
        ans:=i;
        try(1,0,6666,1);
      end;
end.
```

---

## 作者：狸狸养的敏敏 (赞：2)

### 这就是一道DFS~~(大法师)~~
## 不要想多了
# 多想想剪枝！

附上题解，程序内有很详尽的注释(针对poj1011的，当然也有针对luogu的代码，附在里面了)

```cpp
/*
POJ 1011
木棒
**************************
木棒

Time Limit: 1000MS
Memory Limit: 10000K
Total Submissions: 156283
Accepted: 37378

Description
乔治拿来一组等长的木棒，将它们随机地砍断，使得每一节木棍的长度都不超过50个长度单位。
然后他又想把这些木棍恢复到为裁截前的状态，但忘记了初始时有多少木棒以及木棒的初始长度。
请你设计一个程序，帮助乔治计算木棒的可能最小长度。每一节木棍的长度都用大于零的整数表示。

Input
输入包含多组数据，每组数据包括两行。第一行是一个不超过64的整数，
表示砍断之后共有多少节木棍。第二行是截断以后，所得到的各节木棍的长度。

在最后一组数据之后，是一个零。
Output
为每组数据，分别输出原始木棒的可能最小长度，每组数据占一行。

Sample Input

9
5 2 1 5 2 1 5 2 1
4
1 2 3 4
0

Sample Output
6
5

**************************

luogu上的题目，可能会有长度>50的木棍存在，所以你们自己过滤下qwq
我就针对这道POJ上的题目写个题解

思路差不多嘛qwq
管理员不给过就熊你哈VwV
*/
#include<bits/stdc++.h>
using namespace std;
int n,lmark,ans,sum;
int nd;//当前枚举到的木棍长度
int a[66];//记录木棍长度
bool vis[66];//记录木棍有没有被用过
bool cmp(int x,int y) {//排序比较规则，将木棍从大到小排序
	return x>y;
}
bool dfs(int num,int len) {//num表示还有num根可以用,len表示还有len的长度就构造成1根完整的了
	if(num==0&&len==0)//如果木棍全部用完然后又构造好了木棍
		//由我们前面是计算除法，所以当num==0时，木棍的根数定然是最多的AwA
		return 1;
	if(len==0)len=nd;//构造完1根了，就再来一根
	int mark=1;//记录循环开始点
	if(len!=nd)mark=lmark+1;//如果不是一根全新的开始，就把mark（循环开始点）记为lmark+1(前面非重复木棍的位置)
	for(int i=mark; i<=n; i++)//剪枝，从前面非重复的位置开始循环 (枚举与当前木棍（已构成）进行匹配的木棍)
		if(vis[i]==0&&a[i]<=len) {//vis数组记录这个木棍有没有被用过
			if(i>1&&vis[i-1]==0&&a[i]==a[i-1])//剪枝；当出现重复木棍时，直接跳过
				//可以证明，在重复木棍中任取一根，不影响答案最终结果
				/*
				An example

				Input
				6
				1 1 1 2 2 2

				Output
				3

				可以见得，取第1根和取第2根和取第3根和后面的长度为2的木棍进行匹配，是不影响程序最终结果的
				重复的只计算第一根
				那么可以减少计算量
				由于我们已经排过序了
				那么判断重复就简单了
				*/
				continue;
			vis[i]=1;//记为该木棒已经用过了
			lmark=i;//最后的不重复位置
			if(dfs(num-1,len-a[i]))//考虑下一根木棍
				return 1;
			else {
				vis[i]=0;//回溯
				if(len==a[i]||len==nd)
					return 0;//len==a[i]说明当前木棍是被剩余的
				//len==nd是指当前木棍 无法被匹配（即上面的dfs(num-1,len-a[i])无法被触发）
				//那么当前答案肯定不是一种可行的方案
			}
		}
	return 0;
}
int main() {
	while(scanf("%d",&n),n) { //针对POJ的哦
		//如果是luogu上的话
		//应该介样子写
		//scanf("%d",&n);
		ans=sum=0;
		for(int i=1; i<=n; i++) {
			scanf("%d",a+i);
			sum+=a[i];//sum累计总长度，为后面的剪枝做好铺垫
		}//也是针对POJ的和蔼数据
		//对于luogu，你应该这样子写
		/*
			int cnt=n,n=0;
			for(int i=1;i<=cnt;i++)
			{
				int x;
				scanf("%d",&x);
				if(x<=50)a[++n]=x;
			}
		*/
		sort(a+1,a+n+1,cmp);//排序，为去重做好铺垫
		for(int i=a[1]; i<=sum/2; i++) {//剪枝;每根木棍的长度只可能sum>=x>=min{a},且不可能在sum{a}/2-sum{a}之间
			//即若在sum{a}/2-sum{a} 之间时
			//定然会触发sun%i>0的条件
			//减少计算量qwq
			if(sum%i)continue;//剪枝；如果木棍的总长度无法整除当前枚举的长度
			//说明无论如何都无法构成完整的根
			memset(vis,0,sizeof(vis));//把标记数组清空
			lmark=1;
			nd=i;//记录下来枚举到的长度（我懒得开全局变量了2333）
			if(dfs(n,i)) {
				ans=i;
				break;//如果搜到了，因为我们是从小到大循环，如果找到了，那么这个解定然是最优解
				//直接记录下ans，就可以闪人了
			}
		}
		if(ans)printf("%d\n",ans);//如果ans有被更新过（即找到了比所有的凑成1根更好的答案），那么输出更好的答案
		else printf("%d\n",sum);//不然就把所有拼到一起
	}
	return 0;//完结撒fafa
}
```

其实~~蓝书（信息学奥赛一本通【提高篇】）~~上面有更多的剪枝

但是似乎有些剪枝奇奇怪怪

是错的呢qwq


好惹，就到这里啦。

								我是分割线
----

----



---

## 作者：1517460958dyc (赞：2)

#### 和各位大佬的想法接近，剪枝也大体相同。但我修改了dfs中的变量，用now（当前已拼长度）和left（剩余所需长度），或许更好理解。

## P.S：
#### 我说一说剪枝的问题。开始我觉得传递最大能用的木棍长度（maxu）是多余的，从剩余长度开始遍历就好了，即for从left到minl（剩余所需长度）即可，复杂度可能还能下降（left<=maxu时遍历次数减少，还少了一个传值）。当然，T了。后来仔细一想，当拼一根新木棍时，left即为木棍长度，在某些特（du）殊（liu）数（ka）据（fa）中远大于最大可用长度。自然，凉了。并且，其实left<=maxu时，有i<=left剪枝保证直接略过无效部分。
#### 另外，从大往小取也是显然的：如同那个著名的鸡汤故事——先放石头后放沙子，先大块后零碎可以保证大块（长木棍）的处理，而不影响零碎（短木棍）的拼凑。
###### 以上（及以下）均从一~~脑回路清奇的~~蒟蒻视角说明，大佬们请见谅！
```cpp
#include<cstdio>
#include<cstdlib>
using namespace std;
int cnt[60]={},maxl=0,minl=51;//不超过50的木棍长度（似乎）明确暗示了桶排序，maxl、minl不解释
inline int read()
{
    int x=0;
    char c=getchar();
    while (c<'0'||c>'9')
        c=getchar();
    while (c>='0'&&c<='9')
        x=(x<<3)+(x<<1)+c-'0',c=getchar();
    return x;
}//快读（比大佬们的慢）
inline int max(int a,int b)
{
    return (a>b)?a:b;
}
inline int min(int a,int b)
{
    return (a<b)?a:b;
}//手写min、max
void dfs(int rest,int now,int left,int maxu)//核心与各位大佬相似，轻喷
{
    if (!rest)
    {
        printf("%d",now+left);
        exit(0);
    }
    if (!left)
    {
        dfs(rest-1,0,now,maxl);//不剩长度则当前长度为木棍长度
        return ;
    }
    for (int i=maxu;i>=minl;--i)
        if (cnt[i]&&i<=left)
        {
            --cnt[i];
            dfs(rest,now+i,left-i,i);
            ++cnt[i];//回溯
            if (now==0||i==left)//now=0即拼一根新木棍，只用最大的就行了
            					//i==left即当前刚好拼成一根完整木棍，显然最优，剩余不管。
                return ;
        }
}
int main()
{
    int n=read(),sum=0,a;
    for (int i=1;i<=n;++i)
    {
        a=read();
        if (a>50)
            continue;//注意坑点
        maxl=max(maxl,a);
        minl=min(minl,a);
        ++cnt[a];
        sum+=a;
    }
    for (int i=maxl;i<=(sum>>1);++i)
        if (sum%i==0)//显然不能有非整数根木棍
            dfs(sum/i,0,i,maxl);
    printf("%d",sum);//如果怎么凑都不行，就一根吧
    return 0;
}
```

---

## 作者：DimensionTripper (赞：2)

暴力搜索+剪枝

（这题简直神级剪枝）

由于200~1000ms实在坑人（实际上最后T的几乎都是500和1000的数据）

所以卡了我很久……

```cpp
#include <bits/stdc++.h>
#pragma GCC optimize(3)//O3与我永不离
#define N 10010
using namespace std;
int n,len[N],l,cnt,sum;
bool used[N];
bool mmp(int x,int y)
{
    return x>y;
}
void dfs(int x,int y,int lent,int goal,int now)//记录当前的这根小木棍
{
    if(x>sum/goal)
    {
        printf("%d",goal);
        exit(0);
    }
    if(goal-lent<len[cnt])
        return;//如果连最小的填进去都会大于当前答案的话就回溯
    for(int i=now;i<=cnt;i++)//从当前开始枚举，因为前面的一定被枚举过了，再做就是浪费时间
    {
        if(!used[i]&&lent+len[i]<=goal)
        {
            used[i]=true;
            lent+=len[i];
            if(lent==goal)
                dfs(x+1,1,0,goal,1);
            else
                dfs(x,y+1,lent,goal,i+1);
            used[i]=false;
            lent-=len[i];
            if(lent+len[i]==goal||lent==0)
                break;//如果这一组可以凑出却不是正确答案或者第一根都无法满足就直接退出，没必要再去枚举更小的来代替它，因为这一根总是要被用的。
            while(len[i]==len[i+1])
                i++;//该长度若不可行，则同样长度的也不可行
        }
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&l);
        if(l>50)
            continue;//一定要优先过滤50+的数据
        len[++cnt]=l;
        sum+=len[cnt];
    }
    sort(len+1,len+1+cnt,mmp);//从大到小排序，方便搜索与剪枝
    for(int i=len[1];i<=sum/2;i++)
        if(sum%i==0)
            dfs(1,1,0,i,1);//从小到大枚举答案，遇到一个可直接跳出
    printf("%d",sum);
    return 0;
}
```
参考了许多题解大佬，从9分到21分到33分到36分到63分到66分到AC……

而且跑的很慢

[1100ms](https://www.luogu.org/record/show?rid=5402366)

题解很弱……主要是把之前的题解用我能懂的语言再码了一遍……


---

## 作者：zls6602488 (赞：2)

首先很坑的就是数据中有大于50的，要过滤掉，不能进入程序的计算。

既然要求最小长度，也就是使合并后的木棍尽量多，这是一个剪枝，最总和并剩余的根数是1到目前小于50的根数之类，由于这个范围较小，所以枚举结果的木棍根数，而不是枚举长度，然后接下来判定是否能构成此种木棍根数的情况，采用这样的方法：不断构建指定长度木棍，如果最终能构建所要求的根数，就返回true，然后输出(因为根数是从大到小枚举的，所以一有答案就输出)，总的来说是以下思路。

1.枚举火柴根数，往里面填充，看是否能构成枚举的

2.为方便递归，采用have数组 记录长度为某一个数有几根的方法，而不是开布尔型数组

3.木柴从大到小排序方便操作，每回填充小木棍，先填最大的是优的，因为如果填充方案可行的话，那么最终木柴都会被填进去

4.小优化：如果还能够填充的加上已经填充的小于需要的长度，那么就退出


注意：要处理好数组have的回溯和更新问题

```delphi

var n,sum,max,i,t,ge,len,tot,w:longint;
    q,a,have,have1:array[0..80]of longint;
Procedure qsort(l,r:longint);
 var  i,j,x,y:longint;
 begin
   i:=l; j:=r; x:=a[(l*2+r)div 3];
   repeat
     while a[i]>x do inc(i);
     while a[j]<x do dec(j);
     if i<=j then
      begin
        y:=a[i]; a[i]:=a[j]; a[j]:=y;
        inc(i); dec(j);
      end;
   until i>j;
   if i<r then qsort(i,r);
   if l<j then qsort(l,j);
 end;
Function dfs(k,nowlen,num:longint):boolean;
 var i,j:longint;
 begin
   if k=ge+1 then exit(true);
   if len-nowlen>q[num] then exit(false);  //???
   for i:=num to n do
    if have[a[i]]>0 then
    begin
    if  a[i]+nowlen<len then
     begin
       dec(have[a[i]]);
       if dfs(k,nowlen+a[i],i+1) then exit(true);
       inc(have[a[i]]);
     end
     else
    if a[i]+nowlen=len then
     begin
       dec(have[a[i]]);
       for j:=1 to n do if have[a[j]]>0 then break;
       dec(have[a[j]]);
       if dfs(k+1,a[j],j+1) then exit(true);
       inc(have[a[i]]);
       inc(have[a[j]]);   //?????
     end;
    end;
  exit(false);
 end;
begin
   readln(n);  sum:=0; max:=0;  tot:=0;
   for i:=1 to n do
    begin
      read(w);
      if w<=50 then
      begin
       inc(tot); a[tot]:=w;
       inc(sum,a[tot]);
       inc(have[a[tot]]);
       if max<a[tot] then max:=a[tot];
      end;
    end;
   n:=tot;
   qsort(1,n);
   q[n]:=a[n];
   for i:=n-1 downto 1 do q[i]:=q[i+1]+a[i];
   t:=sum div max;
   if t>n then t:=n;  //??
   have1:=have;
   if have[a[1]]=n then writeln(n)
    else
   begin
     for i:=t downto 1 do
      if (sum mod i)=0 then
      begin
        len:=sum div i;  ge:=i;
        have:=have1;    // Geng Xin
        dec(have[a[1]]);
        if dfs(1,a[1],2) then
         begin
           writeln(len);
           break;
         end;
      end;
   end;
end.

```(pascal)

---

## 作者：SNiFe (赞：2)

PS：这道题很坑啊，坑害了我5个小时，原因就是我刚开始只能过79分，后来看其他大佬的题解，然后自己数据，和其他代码跑出来的对，发现有一个不一样，于是我就开始找问题，结果跑出来一样了，交上去27分，最后交上去AC了，跑自己的数据又不对了，最后竟发现是题解错了，他只开了101的数组，而我的数据刚好是102的.........(当时我的内心是崩溃的）。。。。

然后废话不多说了，我给各位讲讲我所理解的这道题：首先你要把大于50的过滤掉，然后从大到小排序，然后搜索答案，代入DFS判断可行性。DFS过程中有三个重要剪枝，代码中有注释，我为了好看还写了一个judge函数，但是judge函数是可以和DFS合并在一起的。剩下的我不多说，我在代码中有详细批注，下面附上我丑陋的代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
using namespace std;
const int maxn=1005;
int dist[maxn];//dist[i]表示第i个木棒的长度 
bool visit[maxn];//visit[i]表示第i根木棒是否使用过 
int sum=0/*小木棍长度总和*/,maxlength=0/*最大小木棍长度*/,len/*枚举答案*/,flag=0/*判断是否找到答案的标志*/,s[maxn]/*后缀和*/,n,num/*最多有好多根大木棍*/;
void judge(int);
bool compare(int x,int y){return x>y;}
void dfs(int cnt/*枚举到第几根大木棍*/,int x/*剩余大木棍（答案）长度*/,int k/*第几根小木棍长度*/)
{
    if(x==0){judge(cnt+1);return;}//枚举完一次大木棍*/ 
    if(x<dist[n])return;//判断可行性 
    for(int i=k;i<=n;i++)
    {
        if(!visit[i] && dist[i]<=x)//判断可行性 
        {            
            if(x>s[i])return;//判断可行性 
            visit[i]=1;
            dfs(cnt,x-dist[i],i+1);
            if(flag)return;//剪枝1 
            visit[i]=0;
            if(x==dist[i])return;//剪枝2 
            for(;i<n;i++)
            if(dist[i]!=dist[i+1])break;//剪枝3 
        }
    }
}
void judge(int cnt)
{
    if(len==sum||cnt==num)//判断答案 
    {
        flag=1;
        return;
    }
    int i;
    for(i=cnt;i<=n;i++)
    {
        if(!visit[i])break;
    }    
    visit[i]=1;
    dfs(cnt,len-dist[i],i+1);
    visit[i]=0;
}
int main()
{
    scanf("%d",&n);
    int temp,j=0;
    for(int i=1;i<=n;i++) 
    {
        scanf("%d",&temp);
        if(temp>50||temp==0) continue;//过滤 
        dist[++j]=temp;
        sum+=temp;
        if(maxlength<temp) maxlength=temp;
    }n=j;
    for (int i=n;i>=1;i--)s[i]=dist[i]+s[i+1];//后缀和 
    sort(dist+1,dist+j+1,compare);//sort默认是从小到大排序 
    for(len=maxlength;len<=sum;len++)
    {
        if(sum%len==0)//判断可行性 
        {     
            num=sum/len;
            memset(visit,0,sizeof(visit));
            judge(1);
            if(flag)
            {
                printf("%d\n",len);
                return 0;
            }
        }
    }
}     
结束，希望大家能有所获QAQ。。。。
```

---

## 作者：Akaina (赞：1)

### 小木棍

**最优性**剪枝：

1.木棍原来的长度一定大于等于所有木棍中最长的那根，小于等于木棍的长度和，枚举时只需枚举到木棍长度和的一半，因为如果超过一半，那只能是由一根原木棍切成所有的木棍

​                       2.设所有木棍长度和为sum则原长度一定能被sum整除

**可行性**剪枝：

3.短的木棍一定比长度更灵活，所以先从长到短排序，把难搞的先搞了，其实很多dp题也有着类似的**贪心**思想（比如洛谷P4138挂饰），需要先排序再进行操作，不然就可能会WA。

​                       4.从第一根长度小于或等于当前木棍剩余长度的开始搜索（二分查找）

​                       5.预处理出一个数组表示跟当前木棍长度相等的木棍的最后一根，因为如果当前木棍搜不出结果，等长的木棍也同样搜不出结果（如果能搜出结果，那pd就会为1，会直接返回，这与深搜的性质有关）

​                      6.用pd记录是否已查找到符合条件的情况，若找到，立刻返回

小细节：注意搜索树的性质，一定要**回溯**，读入数据时要过滤掉长度大于50的木棍

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;
int n,maxx,sum;
int a[80],ans,pd=0,len;
int pre[80],used[80];
bool cmp(int x,int y)
{
    return x>y;
}
void dfs(int k,int rest,int last)
{
    if(pd)return ;
    if(rest==0)
    {
        if(k==sum/len)
        {
            pd=1;return;
        }
        int cc=0;
        for(int i=1;i<=n;i++)
        {
            if(!used[i])
            {
                cc=i;
                used[i]=1;
                break;
            }
        }
        dfs(k+1,len-a[cc],cc);
        used[cc]=0;//一定要记得回溯,《一本通》上这儿忘了回溯
        if(pd)return;
    }
    int l=last+1,r=n,cnt=n+1;
    while(l<=r)//优化4
    {
        int mid=(l+r)>>1;
        if(a[mid]<=rest)
        {
            cnt=mid;r=mid-1;
        }
        else l=mid+1;
    }
    for(int i=cnt;i<=n;i++)
    {
        if(!used[i])
        {
            used[i]=1;
            dfs(k,rest-a[i],i);
            used[i]=0;
            if(pd)return;//优化6
            if(rest==a[i])return;
            i=pre[i];//优化5
            if(i==n)return;
        }
    }
}
void solve()
{
    for(int i=maxx;i<=sum/2;i++)//优化1
    {
        len=i;
        if(sum%i==0)//优化2
        {
            dfs(0,0,0);
            if(pd==1)
            {
                ans=i;
                return ;
            }
        }
    }
    return ;
}
int main()
{
    scanf("%d",&n);
    int tot=0;
    for(int i=1;i<=n;i++)
    {
        int x;
        scanf("%d",&x);
        if(x>50)continue;
        a[++tot]=x;
        maxx=max(maxx,x);
        sum+=x;
    }
    n=tot;
    sort(a+1,a+n+1,cmp);//优化3
    ans=sum;
    for(int i=1;i<=n;i++)
    {
        int j=i;
        while(a[i]==a[j])j++;
        pre[i]=j-1;
    }
    solve();
    printf("%d\n",ans);
    return 0;
}
```



---

## 作者：晚安自己说 (赞：1)

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#define R register
#define N 75
using namespace std;
int n,cnt,tot,maxn,minn,tm[N],temp; 
inline bool cmp(int a,int b){return a>b;}
inline int ri(){
	char c=getchar();int x=0,w=1;
	while(!isdigit(c)){if(c=='-')w=-1;c=getchar();}
	while( isdigit(c)){x=(x<<3)+(x<<1)+c-48;c=getchar();}
	return x*w;
}
inline void dfs(int res,int sum,int t,int p){
//(剩余的根数，当前已凑长度，当前找的原始木棍长度，当前可挑选的木棍长度最大值)
	if(!res){printf("%d",t); exit(0);} //搜完了 输出t
	if(sum==t){dfs(res-1,0,t,maxn); return ;}//如果当前凑够了res--
	for(R int i=p;i>=minn;--i){//可挑选的到最小值
		if(tm[i]&&i+sum<=t){//如果还有这个木棍——加上之前已经凑好的
        					//还在t内
			tm[i]--;//拿掉它
			dfs(res,sum+i,t,i);//dfs....只不过这时候的p为i 剩下的                               //木棍怎么能比当前的还大呢
			tm[i]++;//及时还回去给别的dfs用
			if(!sum||sum+i==t)break;//之前的dfs让总和为0了，或者凑										//够了，直接break 优化
		}	
	}
	return ;
}
	
int main() {
    n=ri();
    minn=N;
    for(R int i=1;i<=n;++i){
        temp=ri();
        if(temp<=50){//如题输入吧--
            cnt++;//统计个数
            tm[temp]++;//有点桶排意思？？优化1 不用排序了
            tot+=temp;//计入总和
            maxn=maxn>temp?maxn:temp;  
			minn=minn<temp?minn:temp;
        }
    }
    temp=tot>>1;//优化2 只要搜到一半，最后拼的根数不是<=2就是1了
    for(R int i=maxn;i<=temp;++i)//原先木棍长度肯定>=小木棍最长的
        if(tot%i==0)dfs(tot/i,0,i,maxn); //优化3 总长必定要整除它
    printf("%d",tot);//dfs完还没结束的话 只有一根就输出这个tot咯
    return 0;
}


```



---

## 作者：Dorg (赞：1)

貌似我们学校的人被我掀起了小木棍的潮流QAQ

我就写一下剪枝的思路吧。

------------
题目：[ P1120 小木棍 ［数据加强版］](https://www.luogu.org/problemnew/show/P1120)

我这题我淦了两天（夜半果然头脑不清醒）

思路如下：

       1. dfs（迭代加深）参数意义：rest-剩下的组数
                                now-当前组剩余长度
                                 la-以为last，上一根搜到的序号
       2. 将木棍长度排个序（随你正序逆序），从大到小放，放到一组结束，就开始下一组。
       3. 如果在dfs中，如果放入这一根就完成了拼接，但最后的结果是失败的，那么前面的抉择有问题，回炉重造。
       4. 滤除多根木棒长度相同的情况。
       5. 枚举长度时，从最大的小木棍长度开始，到总长度的一半即可（剩下一半没有意义，其实优化意义不大）。
       6. 最后，吸个氧（O2）。
       

------------
```cpp
#include<bits/stdc++.h>

using namespace std;

int have[100];
int num[100];
int nlim;
int n;
int nans=0;
int vis[100]; 
int Min=100;
int Max=-1;

void dfs(int rest,int now,int la){
	//cout<<rest<<endl;
	if(now==0)
		dfs(rest-1,nlim,n);
		
	if(rest==0){
		cout<<nans;
		exit(0);
	}
	
	if(now<Min)
		return;
	
	for(register int i=la;i>=1;i--){
		if(vis[i]==0&&now-num[i]>=0){
			//have[i]--;
			vis[i]=1;
			dfs(rest,now-num[i],i-1);
			vis[i]=0;
			if(now-num[i]==0 || now==nlim)
				break;
			while(num[i]==num[i-1])
				i--;
			//have[i]++;
		}
	} 
	
}

int main(){
	
	
	cin>>n;
	int Tn=0;
	int sum=0;
	
	for(int i=1;i<=n;i++){
		int a;
		cin>>a;
		if(a<=50){
			Tn++;
			num[Tn]=a;
			have[a]++;
			sum+=a;
			Min=min(Min,a);
			Max=max(Max,a);
		}
	}
	n=Tn;
	sort(num+1,num+1+n);
	//cout<<sum<<endl;
	for(register int i=Max;i<=sum/2;i++){//i每一段长度 
		if(sum%i==0&&sum/i<=50){
			nans=i;
			nlim=i;
			dfs(sum/i,nlim,n);
		}
	}
	cout<<sum<<endl;
	return 0;
}
```

---

## 作者：median_dxz (赞：1)

极其锻炼搜索能力..GG

### 搜索思路

1. 枚举原木棍长度
2. 搜索能拼出的木棍

终止条件：拼出$L/l$根木棍

### 剪枝思路

1. 枚举长度为$L/2$

2. 枚举长度要能被L整除,即:L%l = 0

3. 最优解剪枝：如果找到一个解，因为长度是从小到大枚举，可以直接退出

4. 可行性剪枝：如果当前木棍不行，同样长度的木棍一定不行

5. 可行性剪枝&&最优解剪枝：$lnow - stick[i] >= 0$ 从大到小排序木棍，更容易找到答案并且前面长度过长可以的直接跳过。

6. 可行性剪枝：搜索常用，只能用一次的情况下用last记录上一次选择，下一个从last+1开始

7. 先考虑一点，能用长木棍拼出合法长度就尽量用长木棍，类比就是填水杯先放石头再放沙子。基于这个思想，我们搜索的顺序是从大到小，即**后面搜到的一定比前面短**：

   然后我们来看下面的两个~~玄学~~剪枝：

8. 很妙的剪枝1：$lnow = lm$

   这是因为**从大到小排序后如果这根长木棍搜不出来**，那么我们考虑这根木棍应该是**如果前面拼成这样，后用这根长木棍拼出一根*合法木棍*是不满足条件的！**因此直接回溯。

9. 很妙的剪枝2：$lnow - stick[i] == 0$

   这是因为**如果这根木棍直接满足一根合法木棍但是没找到答案**那么我们考虑**这根合法木棍**应该是**不满足条件的，即使换了短木棍拼出这根合法木棍，也一定找不到答案**

   ~~好难懂我过了两天就忘了为什么要这么写了考试应该思维难度没这么大吧~~

10. 前面第5点如果用二分效率在这题极低，还不如手动跳(也可能是我用了stl的锅)……下次数据范围没到1e5我是不会考虑二分优化搜索的……

```cpp
/*
https://www.luogu.org/problemnew/show/P1120
Title:小木棍 ［数据加强版］
Algorithm:Search
*/
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <cstring>
#define N 70
#define mids(a,b) (a+(b-a)/2)
using namespace std;
typedef long long ll;
ll n,stick[N],l,r,mid,lm,b;//lm为长度限制
bool ans = false;
inline ll min(ll a,ll b) {return a<b?a:b;}
inline ll max(ll a,ll b) {return a>b?a:b;}
bool vis[N];
bool cmp(ll a,ll b){
	return a>b;
}
void dfs(int com_num,ll lnow,int last){//已经拼出的数量，剩余拼出的长度，上一个搜索的位置
	if(ans)return;
	if(com_num == r / lm){
		ans = true;
		return ;//找到一个解就能退出
	}
	if(lnow == 0){
		dfs(com_num+1,lm,0);//开始一根新木棍
		return ;
	}
//	ll *x = upper_bound(stick+1,stick+1+b,lnow) - 1;
	for(int i = last+1;i<=b;i++){
		if(!vis[i] && lnow - stick[i] >= 0){
			vis[i] = 1;dfs(com_num,lnow-stick[i],i);vis[i] = 0;
			if(ans || lnow == lm || lnow - stick[i] == 0)return;
			while(stick[i] == stick[i+1])i++;
		}
	}
}
int rn(void) {
	int t = 0, f = 1;
	char a = getchar();
	for(; a < '0' || a > '9'; a=getchar()) {if(a == '-')f=-1;}
	for(; a>='0' && a<= '9'; a=getchar()) {t = t * 10 + a - '0';}
	return f*t;
}
int main() {
//	ios::sync_with_stdio(false);
	n = rn();
	for(int i=1; i<=n; i++) {
		int x = rn();
		if(x > 50)continue;
		stick[++b] = x;
		l = max(l,stick[b]),r += stick[b];
	}
	sort(1+stick,stick+1+b,cmp);
	for(int i=l;i<=r/2+1;i++){
		if(r % i != 0)continue;
		lm = i;
		dfs(0,lm,0);
		if(ans){
			r = i;
			break;
		}
	}
	cout<<r<<endl;
	return 0;
}
```



---

## 作者：panhuachao (赞：1)

前言：这道题呢用到了一堆优化，有一个点大佬们都讲得很含蓄，表示小编一看到时也没弄懂，还好这条是小编自己想出来的，又对照了一下，是一样的。不然恐怕又要懵逼了。

步骤：枚举拼接木棍长度，必须把木棍长度总和整除（相信应该很好理解），然后，就一个一个去试呗。。。

好了，小编给大家带来的几个优化见下：

1.木棍长度总和必须能被拼接起来的木棍长度整除

（要排一下序。从大的来搜，搜起来也方便。要是有蒟蒻现在不懂也没关系，下面会懂的。）

2.排序（据有位大佬说，是为了“灵活”，我觉得也差不多，就是方便搜索，方便排除）

3.记录总和sum[]（目的详见第6条）

4.小木棍从大到小枚举，

5.必须从上一次选的木棍之后开始枚举

（上面这几条是给蒟蒻的，大佬应该知道）

6.如果剩下要拼的长度小于剩下木棍的总长度，那么即使全部拼起来也不行，pass，所以这就是记录sum的原因。

7.（还不叫真正毒，小编看了下数据也想到了）如果剩余的第一个不能拼接，那么这根木棍肯定会剩下来，所以pass（也就是楼下大佬说的已拼接长度为0）

8.（小编也想了一下，顺便看了一下变量输出。才想到）如果某人现在已经拼成了5的长度，要求长度是8，而手头上恰好有3根木棍，1,2,3，那么那人优先搜到了3，高兴地拼了上去，然后发现行不通，那么没有必要再换5+2+1了，因为1+2比3更灵活。  也就是楼下大佬说的“当前已拼接的长度与刚才枚举的长度之和为最终枚举的答案”。（当然，我的5,3,2,1只是举个例子，指的是数据中含有这几个数，且暂时仅考虑这几个数，意会一下，例如说8 6 5 5 5 5 3 3 2 ，中搜到8+6发现不行，就可以直接跳过8+3+3 @评论）

好了，优化都讲完了，小编的代码（看起来）有点乱，所以还是借鉴楼下大佬的吧。。。

---

## 作者：竺子豪 (赞：1)

# DFS

非常经典的搜索题
--------
也没有什么难度，只要加剪枝基本上代码就可以了。
```
#pragma GCC optimize(2)//o2优化 
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int n;
int l;
int a[100];
int lmark;
int vis[100];
bool cmp(int x,int y){//令排序从大到小排 
	return x>y; 
}
int dfs(int num,int len){
	if(num==0&&len==0)//如果无棍可放而且已经拼完一整根，则返回1 
		return 1;
	if(len==0)//如果拼完一根，则开始下一根。 
		len=l;
 	int mark=1;
 	if(len!=l)
 		mark=lmark+1;//如果拼完当前这一根还要>1个单位，则从上一个木棍的位置加1开始枚举 
	for(int i=mark;i<=n;i++){//循环枚举每一个木棒 
		if(vis[i]==0&&a[i]<=len){//如果当前的木棒可以使用，而且使用后不会超出枚举的长度，就使用。 
			if(i>1)
				if(vis[i-1]==0&&a[i]==a[i-1])//剪枝 
					continue;
			vis[i]=1;
			lmark=i;//更改起始位置 
			if(dfs(num-1,len-a[i]))//枚举下一根木棒，如果返回值=1，则返回1。 
				return 1;
			else{//否则 
				vis[i]=0;
				if(len==a[i]||len==l)//如果剩下的长度=当前枚举的长度或者=枚举的总长度，返回0； 
					return 0;
			}
		}
	}
	return 0;
}
int main(){
	int cnt;
	scanf("%d",&cnt);//输入 
		int sum=0;
		for(int i=1;i<=cnt;i++){
			int x;
			scanf("%d",&x);
			if(x>50)//如果长度大于50，则过滤了 
				continue;
			a[++n]=x;
			sum+=a[n];//求总和 
		}
		int ans=0;
		sort(a+1,a+1+n,cmp);//排序函数 
		for(l=a[1];l<=sum/2;l++){//枚举长度，拼起来的长度最短是最长的一根木棍，最长是离总长最近的因数 
 			if(sum%l)//如果l不是总和的因数，则不执行。 
		 		continue;
			memset(vis,0,sizeof(vis));//把vis数组清空 
			lmark=1;//从1开始枚举 
			if(dfs(n,l)){
				ans=l;
				break;//如果返回值为1，则退出 
			}
		}
		if(ans)//如果ans!=0,那么就输出ans 
			printf("%d\n",ans);
    return 0;
}
		
```

---

## 作者：zhyh (赞：1)

整体思想就是枚举木棍长，搜索是否能拼凑得到，再加上**各种剪枝**；

剪枝如下：~~（尽管楼下已经讲过了，蒟蒻我还是再码一遍）~~

1、将所有木棍长从大到小排序一遍，大的取完后还能取到的剩余空间就相对减少，同时也方便其他剪枝；

2、若当前木棍无法完成拼凑，则与其等长的木棍同样不行，可以跳过；

3、若木棍X是旧一组的最后一根，旧一组拼完后，发现新一组无法完成，就不需要再枚举比木棍X小的木棍了；

（因为木棍X是“合适”的，若有比X小的若干木棍能仅仅取代X，但是X却相对那几根木棍的可拼凑种类要少，更不“灵活”，显然不合理）

4、若在新一组的拼凑中，最大的木棍无法完成，则接下来的这几组都不行（因为那根最长的木棍是迟早要用的）；

具体代码如下：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
    int p[66],n,tmp,a,maxn=0,sum=0;    bool used[66];
//p记录长度
bool cmp(int p,int y){    return(p>y);    }
    
bool dfs(int s,int k,int py,int l){  //s是当前已经拼凑得到的长度，k是枚举起点的坐标，py已经完成的木棍数，l是目标长度
    
    if(k>n)return false;  //边界
    
    if(py>tmp)return true;  //边界
    
    for(int x=k;x<=n;x++){  //枚举木棍
        if(used[x]&&(s+p[x])<=l){
        
            used[x]=false;
            
            if(s+p[x]==l){
                if(dfs(0,1,py+1,l))return true;    }  //搜索下一组           
            else{
                if(dfs(s+p[x],x+1,py,l))return true;}  //继续找
            
            used[x]=true;
        
            if(s+p[x]==l || s==0)break;  //剪枝3、4
            while(p[x+1]==p[x])x++;  //剪枝2
        }
    }
    return false;
}

int main(){
    scanf("%d",&n);    tmp=0;
    for(int i=1;i<=n;i++){
        scanf("%d",&a);
        if(a>50)continue;  //忽略长度大于50的木棍
        tmp++;    p[tmp]=a;
        maxn=max(maxn,a),sum+=a;
    }
    n=tmp;
    sort(p+1,p+n+1,cmp);  //见1
    
    for(int i=maxn;i<=sum;i++){  //从小到大枚举，答案大于等于最大木棍长，且是所有木棍总和的因数；
        if(sum%i==0){
            for(int j=1;j<=n;j++)used[j]=true;
            tmp=sum/i;
            for(int j=1;j<=n;j++)
                if(p[j]==i)tmp--,used[j]=false;  //把已经符合的单根木棍去掉，没什么用的小剪枝~~懒得删了~~
                
            if(dfs(0,1,1,i)){
                printf("%d",i);
                return 0;
            }    
        }        
    }
    
    return 0;
}
```
施工完毕，祝大家AC！


---


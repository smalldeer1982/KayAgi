# [SDOI2006] 数字串位置 / 超长数字串

## 题目背景

George 很喜欢数学，尤其是算数数系列。

## 题目描述

他最喜欢的是数字的无穷序列，结果是把所有的自然数按升序排列。这个序列开始是：$\texttt{1234567891011121314...}$

我们称这个序列为序列 $S$，然后 $S_1 = 1$, $S_2 = 2$, ... , $S_{10} = 1$, $S_{11} = 0$，依此类推.

George 现有一个数字序列 $A$ ，他想知道这个序列在 $S$ 中最早出现的位置。请你帮助他解决这个问题。

## 说明/提示

来源 Source

Ural State University Problem Archive

 

## 样例 #1

### 输入

```
101
```

### 输出

```
10
```

# 题解

## 作者：冒泡的笨小猴 (赞：12)

```
这个题实在是太麻烦了！！高精度+枚举+字符串处理+AC，相当综合的一道题目！！！！！

首先，一种很显然的方法，就是枚举长度，之后枚举首位，之后判断这种情况是否满足。理论上，这个题已经做出来了，但是事实上，这个题99%在与细节！！

先说明一下我的判断方法，假设读入的长度是k，那么最终这个串所在的位置的那个数不会超过k位（除非k位全是0），于是对于确定的开始点和长度，前后扫描把这个数弄出来，之后在判断即可。

关于计算位数，这个也非常的讲究。根据WC2009高逸涵大牛的论文指示，一切从简单做起，分类讨论。详见下面的注意事项。

有以下几点注意：

1． 如果这个数后面的位数不够，比如98999，这个数出现在999处，后面的位数不够，要到前面找，此时得出这个数是998+1=999。但是，如果是99999，那么他会判断成99999+1，无法判断正确！！也就是说，如果后面的位数不够，前面的还全是9的话，就要对后面的数减1在加上前面的。比如99999，就是（9-1）+9999=89999，这个就对了。这一点如果不注意的话就得不出999999999--7988888882的解了。

2． 如果读入的数全是0，就在最前面加一个1，最后输出的时候在加对答案1即可。

3． 如果在判断的时候那个数多了一位，注意循环的次数。比如9991000，第一次是999，第二次是1000，我开始的程序始终是循环3次，就是最开始的长度，于是就有4个点WA。

4． 初始的时候答案设为无穷大，逐渐缩小。这个无穷大一定要大于200位，设成300肯定没问题。我开始设成200位，结果200个0和9的两个点WA了。

5． 关于计算位数。我开始是直接把小于这个位数的所有数的总长度*这一位是几累加的。后来发现，有两个问题。第一，如果是有首位的，这个长度就变了。比如，12345（5位），如果是在10之后的，就是0102030405（10位），这个一定要特殊判断。第二，你不感觉刚才的计算少了什么么？对！就是0！如果正常的这么算，100以上的时候，把100的两个0丢了，200的也没了……于是全盘错误……关于这个问题，是可以跟上一个问题一起解决的，详情就是特殊判断！
```
------------
最后上代码（不要抄哦）
```
#include<iostream>
#include<string>
using namespace std;

string s;

int a[300][305]={0};
int flag=1;
int kk=0;  
//x[0~(n-m)]=s[n~m] 
int getNum(int x[],int m,int n){
    for(int i=n;i>=m;--i)
    x[n-i]=s[i]-'0';
    }
void print(int x[]){
     int i;
     for(i=300;i>=0;i--)
     if(x[i]!=0) break;
     while(i>=0) cout<<x[i--];
     cout<<endl;
     }
//打印补齐后的第一个数 
void print(int l){
     for(int i=1;i<=l;++i)
     cout<<s[i];
     cout<<endl;
     }
//x=x+t 
void add(int x[],int t){
     x[0]+=t;
     int i=0;
     while(x[i]>=10)
     {
       x[i+1]+=x[i]/10;
       x[i]%=10;
       i++;
                   }
     }
//x=x-t 
void sub(int x[],int t){
     x[0]-=t;
     int i=0;
     while(x[i]<0)
     {
       x[i]+=10;
       x[i-1]-=1;
       i++;
                   }
     }

//前后数位数都足够 
bool check(int i,int j,int m,int n){
     if(s[i]=='0'||s[m]=='0') return false;
     int x[305]={0},y[305]={0};
     getNum(x,i,j);
     getNum(y,m,n);
     add(x,1);
     for(int d=0;d<=300;d++)
     if(x[d]!=y[d]) return false;
     return true;
     }


//后一个数位数不够，只判断后一个数与前一个数对应的位数是否相等 
bool tailCheck(int i,int j,int m,int n){
     if(s[i]=='0'||s[m]=='0') return false;
     int x[305]={0},y[305]={0};
     getNum(x,i,j);
     getNum(y,m,n);
     add(x,1);
     int d1=300,d2=300;
     while(x[d1]==0) d1--;
     while(y[d2]==0) d2--;
     while(d1>=0&&d2>=0)
     {
        if(x[d1]!=y[d2]) return false;        
        d1--;d2--;        
                        }
     return true;
     }


//判断第一个数的位数是否能为l 
bool find(int l){
     int i,j,m,n;
     i=1;j=l;m=j+1;n=j+l;
     if(j==s.size()-1&&s[i]=='0') return false;
     while(true)
     {
       if(j>=s.size()-1) return true;
       if(n>=s.size()-1) {n=s.size()-1;if(!tailCheck(i,j,m,n)) return false;}
       else if(!check(i,j,m,n))  //前一个数和后一个数的位数都为l 
       {
         if(!check(i,j,m,n+1))   //前一个数位数为l,后一个数位数为l+1              
         return false;              
         else {l+=1;n+=1;}  
                            }
       i=m;
       j=n;
       m=j+1;
       n=j+l; 
             
             }
     
     return true;
     }

void Multiply(int x[],int y){
     for(int i=0;i<=300;++i)
     x[i]*=y;
     
     for(int i=0;i<=300;++i)
     if(x[i]>9)
     {
        x[i+1]+=x[i]/10;
        x[i]%=10;
                  }
     }
void add(int x[],int y[]){
     for(int i=0;i<=300;++i)
     x[i]+=y[i];
     int i=0;
     while(x[i]>=10)
     {
       x[i+1]+=x[i]/10;
       x[i]%=10;
       i++;
                   }
     }

bool comp(int x[],int y[]){
     for(int i=300;i>=0;--i)
     if(x[i]<y[i]) return true;
     else if(x[i]>y[i]) return false;
     return false;
     }

void getAns(int finalAns[],int l,int k){
     int x[305]={0},ans[305]={0};
     getNum(x,1,l);
     x[l-1]-=1;
     Multiply(x,l);
     for(int i=0;i<=300;++i)
     ans[i]=a[l-1][i]+x[i];
     ans[0]+=1+k+kk;
     for(int i=0;i<=300;++i)
     if(ans[i]>9)
     {
          ans[i+1]+=ans[i]/10;
          ans[i]%=10;
                    }   
     
     if(flag==1||comp(ans,finalAns))
     for(int i=0;i<=300;++i)
     finalAns[i]=ans[i];
     }
//判断数组是否为1000....0000的形式 
bool Equal1000(int x[]){
     int tot=0;
     for(int i=0;i<=300;++i)
     if(x[i]!=0) tot++;
     if(tot>1) return false;
     return true;
     }

//判断字符串是否为全0 
bool Equal000(string s1){
     for(int i=0;i<s1.size();++i)
     if(s1[i]!='0') return false;
     return true;
     }

     
int main()
{ 
    //a[i]表示所有位数<=i的字符串长度和
    for(int i=1;i<=200;++i)
    {
      a[i][i-1]=9;
      Multiply(a[i],i);
      add(a[i],a[i-1]);
            }
    
    int finalAns[305]={0};
    flag=1;
    
    string s1;
    cin>>s1;
    
    //如果字符串=000...0,则在最前面加上0,令kk=1,最后的答案要减去kk
    if(Equal000(s1))
    {s1="1"+s1;kk=1;}
    
    //l为字符串中第一个数的位数
    //k表示字符串中第一个字符是第一个数的第K+1位，k<l
    for(int l=1;l<=s1.size();++l)
    for(int k=0;k<l;++k)
    {
       s=" "+s1;string s2="";
       if(k==0)
       {
          if(find(l))
             {getAns(finalAns,l,k);flag=0;}
               }
               
       //如果K!=0,则补齐第一个数的前k位 
       if(k!=0)
       {

          int x[305]={0};
          getNum(x,l-k+1,l-k+k);
          
          //1.直接把第l-k+1至l-k+k之间的数补齐第一个数的前k位  
          s2="";
          int i=k-1;
          while(i>=0) s2+=x[i--]+'0';
          s=" "+s2+s1;
          if(find(l))
          {getAns(finalAns,l,k);flag=0;}
          
          //2.如果第l-k+1至l-k+k之间数的形式是10....000,也可以用99....999补齐第一个数的前k位  
          if(Equal1000(x))
          {
             s2="";
             i=k-1;
             while(i>=0) {s2+='9';i--;}
             s=" "+s2+s1;
             if(find(l))
             {getAns(finalAns,l,k);flag=0;}
                          }
          //3.用第l-k+1至l-k+k之间的数减去1,补齐第一个数的前k位  
          sub(x,1);
          i=k-1;
          s2="";
          while(i>=0) s2+=x[i--]+'0';
          s=" "+s2+s1;
          if(find(l))
          {getAns(finalAns,l,k);flag=0;}
               
               } 
            
            }
    
    print(finalAns);        
                  
  //  system("pause");   
    } 
```
望管理大大通过

---

## 作者：野菜汤 (赞：5)

题解：

我是这样做的：先读入一个字符串，然后从字符串内部寻找子串，编写一个函数

分别求它的前导（前面一个数）和后导,分别添加到子串前面和后面，然后看前面

和后面分别剩余的位置数，>0继续做。直至调整为原字符串的首尾标记一致的

字符串。如果相同说明是了，然后记e为该子串末位置在s中的位置，然后求出1

到该子串数值（整数数值，非字符串）的所有数的数字个数之和（这里要用点DP

思想和数学思维），把和减去e就是第一步的结果。


**别急着以为可以了，还不行，因为像‘01’这样的串，在大原串(结果)中肯定是‘1011’得到的**


而大原串中数字在s中没有一个是完整的，所以要用截断策略。

        
**枚举位置和长度，如‘0011’串，枚举到第三位1，长度为3，这时把第三位到s末位的子串记为t，那么3-len(t)就是当前枚举串所缺失的位数。把第三位前面的

长度等与缺失位数的子串的后导添加到t后面（这里要特殊考虑进位的情况）。**


再跟第一步类似的方法jugde一次。可以的话，判断当前结果与是否原来的结果更优（更小），是的话那么就得到解了。


**然后就是刚才说过的求出总位数。**

```delphi
var s,t,q,p,ans,v,z,da,u:string;
    a,b,c,d,e,g,i,j,k,m,n,ji:longint;
    h:array[1..200]of boolean;
    f:array[1..256]of string;
function qian(l:string):string; //(求一个数的前面一个数,即a-1)
var o,w:longint;r:string;
begin
    o:=length(l);
    r:=l;
    while r[o]='0' do dec(o);
    r[o]:=pred(r[o]);
    for w:=o+1 to length(r) do r[w]:='9';
    if r[1]='0' then delete(r,1,1);
    qian:=r;
end;
function hou(l:string):string;//(后一个数,即a+1)
var o,w:longint;r:string;
begin
    o:=length(l);
    r:=l;
    while (r[o]='9')and(o>1) do dec(o);
    if (o=1)and(r[1]='9') then
     r:='1'+r else r[o]:=succ(r[o]);
    for w:=o+1 to length(r) do r[w]:='0';
    hou:=r;
end;
function sum(l1,w1:string):string;//(求两数之和)
var o,r,e1:longint;l,w,x:string;
begin
   l:=l1;w:=w1;
   x:='';
   if length(l)<length(w) then
    for o:=length(l)+1 to length(w) do l:='0'+l;
   if length(l)>length(w) then
    for o:=length(w)+1 to length(l) do w:='0'+w;
   e1:=0;
   for o:=length(w) downto 1 do
    begin
     r:=ord(l[o])+ord(w[o])-96+e1;
     e1:=r div 10;
     r:=r mod 10;
     x:=chr(r+48)+x;
    end;
   if e1>0 then x:=chr(e1+48)+x;
   sum:=x;
end;
begin
    readln(s);
    g:=length(s);
    f[1]:='9';v:='9';
    for i:=2 to 256 do
     begin
      v:=sum(v,'9');
      f[i]:=v;
      for j:=1 to i-1 do f[i]:=f[i]+'0';
     end;
    ans:='';
    for i:=1 to 250 do ans:=ans+'0';
    c:=1;
    for i:=1 to length(s) do if s[i]<>'0' then begin c:=0;break;end;
    if c=1 then begin ji:=1;ans:='1'+s;e:=length(ans)-1;end;//末尾全是0时特殊判断
    if ji=0 then
    for i:=1 to g do
     begin
      for j:=1 to g-i+1 do
       begin
        if s[j]='0' then continue;
        t:=copy(s,j,i);a:=j-1;b:=j+i;
        q:=t;p:=t;
        while a>0 do begin q:=qian(q);
         if length(q)>a then begin t:=copy(q,length(q)-a+1,a)+t;a:=0;end else
          begin t:=q+t;a:=a-length(q);
               if q='0' then continue;end;end;
        while b<=g do begin p:=hou(p);
         if length(p)>g-b+1 then begin t:=t+copy(p,1,g-b+1);b:=g+1;end else
          begin t:=t+p;b:=b+length(p);end;end;
        if t=s then begin ans:=copy(s,j,i);e:=j+i-1;break;end;
       end;
      if e>0 then break;
     end;

   if ji=0 then
   for i:=2 to g do
    begin
     for j:=g downto g-i+2 do
     if j-i<=0 then
      begin
       if s[j]='0' then continue;
       t:=copy(s,j,g-j+1);
       p:=copy(s,g-i+1,j-g+i-1);
       q:=hou(p);
       if length(q)>length(p) then
        begin t:=t+copy(q,2,length(q)-1);end else t:=t+q;
       c:=0;
        p:=qian(t);
        if copy(p,length(p)-j+2,length(p))=copy(s,1,j-1) then c:=1;
       if c=0 then continue;
       if length(t)<length(ans) then c:=0 else
        if length(t)=length(ans) then begin if t<ans then c:=0;end else
         continue;
       if c=0 then begin ans:=t;e:=j-1+length(t);end;
      end;
    end;
   if ji=0 then begin
    da:='0';
    ans[1]:=pred(ans[1]);
    ans:=sum(ans,'1');
    da:=ans;
    u:='0';
    for i:=1 to length(ans)-1 do u:=sum(u,f[i]);
    for i:=1 to length(ans)-1 do
     da:=sum(da,ans);
    da:=sum(da,u);
   end else
   begin
    da:='0';
    for i:=1 to e do da:=sum(da,f[i]);
   end;
   if ji=0 then begin
    if length(da)<6 then
     begin z:=da;da:='';end else
      begin z:=copy(da,length(da)-5,6);delete(da,length(da)-5,6);end;
    val(z,d);
    d:=d-e;
    str(d,z);
    da:=da+z;
    end;
    da:=sum(da,'1');
    if ji=1 then da:=sum(da,'1');
    writeln(da);
end.
```

---

## 作者：阿丑 (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P1511)

为叙述方便，下文用 $|x|$ 表示整数或字符串 $x$ 的长度。

#### 题意：

- 将所有正整数首尾相接组成一个字符串 $S$，给出一个字符串 $A$，求 $A$ 在 $S$ 中最早出现的位置。
- $|A|\le200$。

#### 分析：

我认为如果一个只由数字组成的字符串不是一个合法的正整数，只有可能是因为字符串有前导零或字符串表示的数就是零。所以当我们检查一个数字串是否合法时，只需检查首位是否是零即可。

按照组成 $A$ 的数的个数分类讨论。

#### Part 1：分类讨论

1. $A$ 仅由 $S$ 中的一个数组成。

这个数要么是 $A$，要么是 $\overline{1A}$。感性理解一下：如果 $A$ 是一个合法的正整数，那么往 $A$ 前后加数，若要保证合法，都会使 $A$ 迅速变大，在 $S$ 中的位置也变大，所以最优就是 $A$；如果 $A$ 不合法，往 $A$ 后加数字不会使其合法，必须往前加数字，往前加 $1$ 后类似于合法的情况，最优就是 $\overline{1A}$。

根据这一部分，答案的位数不会超过 $\lceil\lg|A|\rceil(|A|+1)$。

2. $A$ 由 $S$ 中的大于等于三个数组成。

此时第二个数一定被 $A$ 完整地包含了。枚举第二个数 $x$ 在 $A$ 中的起始位置和 $x$ 的长度。并将其 $-1$ 观察能不能匹配 $x$ 前面的部分，将其不断 $+1$ 观察能不能匹配 $x$ 后面的部分。如果都能匹配说明合法。

因为每次 $\pm1$ 的复杂度为 $\mathcal O(|x|)$，而除了一次 $-1$ 和最后一次 $+1$，其他 $+1$ 都匹配了 $|x|$ 个 $A$ 中的字符，所以其他 $+1$ 的复杂度之和与 $|A|$ 线性相关，总共是 $\mathcal O(|A|+|x|)=\mathcal O(|A|)$ 的。乘上枚举 $x$ 的复杂度，这部分的复杂度是 $\mathcal O(|A|^3)$。

3. $A$ 由 $S$ 中的两个数组成。

那么 $A$ 一定是由一个数 $a$ 的后缀 $a'$ 和另一个数 $b$ 的前缀 $b'$ 组成，并且 $b=a+1$。枚举 $a'$ 的长度 $|a'|$，$A$ 中的前 $|a'|$ 个字符就是 $a'$。注意到 $a\equiv a'\pmod{10^{|a'|}}\Rightarrow b\equiv a+1\equiv a'+1\pmod{10^{|a'|}}$，即 $a'+1$ 的后 $|a'|$ 位一定和 $b$ 的后 $|a'|$ 位相同；并且若构造出满足这个限制的 $b$，那么构造 $a=((b-1)\bmod{10^{|a'|}})\times10^{|a'|}+a'$ 就能使 $a$ 满足条件。所以该限制是 $a'$ 对 $b$ 的唯一限制。记 $a'+1$ 的后 $|a'|$ 位为 $c$。$c$ 可以含前导零。

枚举 $b$ 的长度 $|b|$。当 $|b|\ge|A|$ 时，构造 $b=b'\times10^{|a'|}+c$ 就能满足限制。若 $|b|$ 更大，则 $b$ 迅速变大，不优。所以只需要枚举 $[\max(|c|,|b'|),|A|]$ 的 $|b|$。由于 $|b|\le|A|=|a'|+|b'|=|c|+|b'|$，而 $c$ 是 $b$ 的后缀，$b'$ 是 $b$ 的前缀，所以 $b$ 是完全确定的，只需检查后缀与前缀相交部分是否相同即可。可以使用 KMP 或直接暴力匹配。对于所有的 $|b|$，复杂度之和是 $\mathcal O(|A|)$（KMP）或 $\mathcal O(|A|^2)$（暴力）。乘上枚举 $|a'|$ 的复杂度，这部分的复杂度不劣于上一部分的复杂度 $\mathcal O(|A|^3)$。

#### Part 2：计算答案

答案分为两部分，一个高精度数 $|x|$ 在 $S$ 中的位置和这个数在 $A$ 中的位置之差。考虑计算前者。

所有长度小于 $|x|$ 的数的长度之和为 $\sum\limits_{i=1}^{|x|-1}i(10^i-10^{i-1})=\sum\limits_{i=1}^{|x|-1}9i\times10^{i-1}$。所有长度等于 $|x|$ 而小于 $x$ 的数的长度之和是 $|x|(x-10^{|x|-1})$。所以 $x$ 在 $S$ 中的位置是 $|x|(x-10^{|x|-1})+\sum\limits_{i=1}^{|x|-1}9i\times10^{i-1}+1$。计算的复杂度是 $\mathcal O(|A|^2)$。总共可能会更新 $\mathcal O(|A|^2)$ 次答案（Part 1 中情况 2 的每一个 $x$ 更新一次，情况 3 的每一个 $b$ 更新一次，两者各有 $\mathcal O(|A|^2)$ 个），暴力更新的复杂度为 $\mathcal O(|A|^4)$。增加少量减枝，开 O2 勉强能过。

（理论上可以 $\mathcal O(|A|)$ 进行比较，最后输出答案时再 $\mathcal O(|A|^2)$ 计算答案，此时总复杂度为 $\mathcal O(|A|^3)$。或者通过高精压位获得小常数）

---

注意检查所枚举的数是否合法。

```cpp
#include <bits/stdc++.h>
#define rep(i, l, r) for(int i=l, _=r; i<=_; ++i)
using namespace std;
bool Mbe;
const int mN=200+9;
int n;
char s[mN*2];

struct Big {	//高精
	int len, a[mN];
	inline void carry() {
		rep(i, 0, len-1) {
			a[i+1]+=a[i]/10, a[i]%=10;
			if(a[i]<0) a[i]+=10, --a[i+1];
		}
		while(a[len]) a[len+1]=a[len]/10, a[len]%=10, ++len;
		while(len>0 && !a[len-1]) --len;
	}
	Big operator +(int i2) const {
		Big res=*this;
		res.a[0]+=i2;
		return res.carry(), res;
	}
	void operator ++() {	//为保证 ++ 是 O(len) 而非 O(maxN) 的，需要单独写 ++
		++a[0];
		for(int i=0; a[i]>9; ++i) ++a[i+1], a[i]=0;
		if(a[len]) ++len;
	}
	Big operator -(int i2) const {
		Big res=*this;
		res.a[0]-=i2;
		return res.carry(), res;
	}
	void operator --() {
		--a[0];
		for(int i=0; a[i]<0; ++i) --a[i+1], a[i]=9;
		if(!a[len-1]) --len;
	}
	Big operator *(int i2) const {
		Big res=*this;
		rep(i, 0, len-1) res.a[i]*=i2;
		return res.carry(), res;
	}
	void operator +=(Big b2) {
		if(len<b2.len) len=b2.len;
		rep(i, 0, len-1) a[i]+=b2.a[i];
		carry();
	}
	void operator -=(Big b2) {
		rep(i, 0, len-1) a[i]-=b2.a[i];
		carry();
	}
	Big operator -(Big b2) const {
		Big res=*this;
		rep(i, 0, len-1) res.a[i]-=b2.a[i];
		return res.carry(), res;
	}
	Big (char *s, int len): len(len) {
		memset(a, 0, sizeof a);
		rep(i, 0, len-1) a[_-i]=s[i]^48;
	}
	Big (int i2=0) {
		memset(a, 0, sizeof a);
		len=1, a[0]=i2, carry();
	}
	inline void output() {
		for(int i=len-1; i>=0; --i) putchar(48|a[i]);
	}
	bool operator <(Big b2) {
		if(len^b2.len) return len<b2.len;
		for(int i=len-1; i>=0; --i) if(a[i]^b2.a[i]) return a[i]<b2.a[i];
		return 0;
	}
} ans, pw[mN];	//pw 表示 10 的幂次
Big cal(Big x) {	//计算答案的前半部分
	int m=x.len;
	x=x*m+1-pw[m-1]*m;
	rep(i, 1, m-1) {
		x+=pw[i-1]*9*i;
	}
	return x;
}

void check(int l, int len) {	//case 2
	Big a(s+l+1, len);	//第二个数
	Big nans=cal(a)-l;
	if(!(nans<ans)) return;
	--a;
	if(a.len<l) return;	//第一个数不够占 l 位，不合法
	rep(i, 1, l) {
		if(s[i]^48^a.a[l-i]) {
			return;
		}
	}
	++a;
	for(int r=l+len+1; r<=n; r+=a.len) {	//依次判断接下来的数
		++a;
		rep(i, r, min(r+a.len-1, n)) {
			if(s[i]^48^a.a[a.len-1+r-i]) {
				return;
			}
		}
	}
	ans=nans;
}

bool Men;
int main() {
	cerr<<"memory: "<<(&Men-&Mbe>>20)<<" MB\n";
	pw[0]=1;
	rep(i, 1, mN-1) pw[i]=pw[i-1]*10;

	scanf("%s", s+1);
	n=strlen(s+1);

	//case 1
	ans=Big(s+1, n);
	if(s[1]==48) ++ans.len, ans.a[n]=1;
	ans=cal(ans);
	if(s[1]==48) ans=ans+1;

	//case 2
	rep(l, 1, n-2) if(s[l+1]^48) {
	//枚举第一个数结束的位置 l，并判断第二个数是否无前导零。
		rep(len, max(l, 1), n-1-l) if(len<=ans.len) {	//枚举第二个数的长度。
			check(l, len);
		}
	}

	//case 3
	rep(l, 1, n-1) if(s[l+1]^48) {
	//枚举第一个数 a 结束的位置 l，并判断第二个数 b 是否无前导零。
		Big a(s+1, l), b(s+l+1, n-l);
		a=a+1;
		rep(st, max(l+1, n-l+1), n+1) if(st-1<=ans.len) {
		//枚举 (a'+1) 在 b 中起始的位置 st
			bool can=1;
			rep(i, st, n) {
				if(b.a[b.len-(i-l)]^a.a[l-1-(i-st)]) {
				//逐位比较
					can=0;
					break;
				}
			}
			if(!can) continue;
			if(st==l+1 && s[1]==48) continue;
			//st==l+1 说明 a=a'，s[1]==48 说明 a 有前导零。
			rep(i, n+1, st+l-1) s[i]=48|a.a[_-i];	//_=st+l-1
			//构造 b
			b=Big(s+l+1, st-1);
			Big nans=cal(b)-l;
			if(nans<ans) {
				ans=nans;
				break;
			}
		}
	}
	ans.output();
	return 0;
}

```

---


# 无向图三元环计数

## 题目背景

无向图 $G$ 的三元环指的是一个 $G$ 的一个子图 $G_0$，满足 $G_0$ 有且仅有三个点 $u, v, w$，有且仅有三条边 $\langle u, v \rangle, \langle v, w \rangle, \langle w, u \rangle$。两个三元环 $G_1, G_2$ 不同当且仅当存在一个点 $u$，满足 $u \in G_1$ 且 $u \notin G_2$。

## 题目描述

给定一个 $n$ 个点 $m$ 条边的简单无向图，求其三元环个数。

## 说明/提示

**【样例 2 解释】**

共有 $5$ 个三元环，每个三元环包含的点分别是 $\{1, 2, 4\}, \{2, 3, 4\}, \{2, 3, 5\}, \{2, 4, 5\}, \{3, 4, 5\}$。

**【数据规模与约定】**

**本题采用多测试点捆绑测试，共有两个子任务**。

- Subtask 1（30 points）：$n \le 500$，$m \le {10}^3$。
- Subtask 2（70 points）：无特殊性质。

对于 $100\%$ 的数据，$1 \le n \le 10^5$，$1 \le m \le 2 \times {10}^5$，$1 \le u, v \le n$，给出的图不存在重边和自环，**但不保证图连通**。

**【提示】**

- 请注意常数因子对程序效率造成的影响。

## 样例 #1

### 输入

```
3 3
1 2
2 3
3 1
```

### 输出

```
1```

## 样例 #2

### 输入

```
5 8
1 2
2 3
3 5
5 4
4 2
5 2
1 4
3 4
```

### 输出

```
5```

# 题解

## 作者：一扶苏一 (赞：72)

# 【P1989】【模板】无向图三元环计数

~~快来做这个题呀虽然它标号很小但它确实是个刚上传的新题~~

## Description

给定一个 $n$ 个点 $m$ 条边的简单无向图，求其三元环个数。

## Limitations

$1 \leq n \leq 10^5$，$1 \leq m \leq 2 \times 10^5$

## Solution

Subtask 1 有三种做法，分别是枚举三个点 $O(n^3)$，枚举两条邻边 $O(m^2)$，枚举一个点及其对边 $O(nm)$。这里不再赘述。

 我们考虑给所有的边一个方向。具体的，如果一条边两个端点的度数不一样，则由度数较小的点连向度数较大的点，否则由编号较小的点连向编号较大的点。不难发现这样的图是有向无环的。注意到原图中的三元环一定与对应有向图中所有形如 $<u \rightarrow v>,<u \rightarrow w>,<v \rightarrow w>$ 的子图一一对应，我们只需要枚举 $u$ 的出边，再枚举 $v$ 的出边，然后检查 $w$ 是不是 $u$ 指向的点即可。

下面证明这个算法的时间复杂度是 $O(m \sqrt m)$。

首先我们可以在枚举 $u$ 的出边时给其出点打上 $u$ 的时间戳，这样在枚举 $v$ 的出边时即可 $O(1)$ 去判断 $w$ 是不是 $u$ 的出点。

那么考虑对于每一条边 $<u \rightarrow v>$，它对复杂度造成的贡献是 $out_v$，因此总复杂度即为 $\sum_{i = 1}^m out_{v_i}$，其中 $v_i$ 是第 $i$ 条边指向的点，$out_v$ 是点 $v$ 的出度。

考虑分情况讨论。

1. 当 $v$ 在原图（无向图）上的度数不大于 $\sqrt m$ 时，由于新图每个节点的出度不可能大于原图的度数，所以 $out_v = O(\sqrt m)$。
2. 当 $v$ 在原图上的度数大于 $\sqrt m$ 时，注意到它只能向原图中度数不小于它的点连边，又因为原图中所有的点的度数和为 $O(m)$，所以原图中度数大于 $\sqrt m$ 的点只有 $O(\sqrt m)$ 个。因此 $v$ 的出边只有 $O(\sqrt m)$ 条，也即 $out_v = O(\sqrt m)$。

因此所有节点的出度均为 $O(\sqrt m)$，总复杂度 $\sum_{i  = 1}^m out_{v_i} = O(m \sqrt m)$。

## Code

```cpp
#include <cstdio>
#include <vector>

const int maxn = 200005;

int n, m, ans;
int dgr[maxn], A[maxn], B[maxn], vistime[maxn];
std::vector<int> e[maxn];

int main() {
  qr(n); qr(m);
  for (int i = 1; i <= m; ++i) {
    qr(A[i]); qr(B[i]);
    ++dgr[A[i]]; ++dgr[B[i]];
  }
  for (int u, v; m; --m) {
    u = A[m]; v = B[m];
    if (dgr[u] > dgr[v]) {
      std::swap(u, v);
    } else if ((dgr[u] == dgr[v]) && (u > v)) {
      std::swap(u, v);
    }
    e[u].push_back(v);
  }
  for (int u = 1; u <= n; ++u) {
    for (auto v : e[u]) vistime[v] = u;
    for (auto v : e[u]) {
      for (auto w : e[v]) if (vistime[w] == u) {
        ++ans;
      }
    }
  }
  printf("%d\n", ans);
  return 0;
}
```



---

## 作者：Miko35 (赞：22)

bitset 好写，来写 bitset！!1

---

首先有一个非常显然的暴力，就是枚举每条边的两个端点 $u,v$，若存在一个点 $w$ 满足 $u,v$ 都对 $w$ 有连边，那 $u,v,w$ 就是一个合法三元组，时间复杂度 $O(nm)$。

考虑下 bitset 优化。维护一个 bitset $S$，其中 $S_i$ 表示与 $i$ 有连边的点集。在上述暴力中，枚举 $u,v$ 两个点的复杂度为 $O(m)$，枚举 $w$ 的过程，其实就是求 $S_u$ 与 $S_v$ 的交集，用 `&` 实现可以做到 $O\left(\dfrac{n}{w}\right)$，时间复杂度为 $O\left(\dfrac{nm}{w}\right)$。

然后你一写就会发现，这个邻接矩阵空间复杂度为 $O(n^2)$。

---

如果 bitset 真的死了，那你就不会看见这篇题解了。

邻接矩阵比起邻接表，空间劣在它存储了很多无用的 $0$。如何去根据这玩意改进？

有个典中典叫 bitset 做高维偏序，空间优化是分块，这里是根号分治。

$0$ 多的地方主要是那些度数很少的点，我们给它开了个完整的 bitset，空间复杂度就变得不是很行。

那就设置一个阈值 $B$，度数 $>B$ 的点给它开完整 bitset，这种点不会超过 $\min\left(n,\dfrac{m}{B}\right)$ 个；度数 $\leq B$ 的点就枚举连边，暴力判断。

时间复杂度？考虑计算每个点的贡献。所有度数 $>B$ 的点最多会被 $O(m)$ 条边枚举到，一次计算是 $O\left(\dfrac{n}{w}\right)$，所以这一部分复杂度 $O\left(\dfrac{nm}{w}\right)$。一个度数 $\leq B$ 的点 $u$ 的点的贡献为 $d_u^2$，其中 $d_u$ 表示 $u$ 的度数。那就有 $\sum d_u\leq m,d_u\leq B$，总共 $\sum d_u^2\leq B\cdot m$。

时间复杂度 $O\left(\dfrac{nm}{w}+B\cdot m\right)$，空间复杂度 $O\left(\dfrac{nm}{B}\right)$。这道题不卡空间，$B$ 取小一点能过，稳妥起见还是取 $O(\sqrt m)$。

bitset 优点在于好背好写，要是考场突然忘了三元环计数，bitset 也是不错的选择。

```cpp
#include<bits/stdc++.h>
#define rgi register int
using namespace std;
const int N=100010,B=660;
int n,m,u,v,d[N],bel[N],cnt,ans;
bitset<N>g[700],s;
vector<int>a[N];
signed main(){
	scanf("%d%d",&n,&m);
	for(rgi i=1;i<=m;++i){
		scanf("%d%d",&u,&v),++d[u],++d[v];
		a[u].push_back(v),a[v].push_back(u);
	}
	for(rgi i=1;i<=n;++i){
		s.reset();
		for(rgi j:a[i])s[j]=1;
		if(d[i]>=B)g[bel[i]=++cnt]=s;
		for(rgi j:a[i]){
			if(j<i){
				if(bel[j])ans+=(g[bel[j]]&s).count();
				else for(rgi k:a[j])ans+=s[k];
			}
		}
	}
	printf("%d",ans/3);
	return 0;
}
```










---

## 作者：louhao088 (赞：13)





三元环计数版题，非常巧妙的题。

给每个点赋权值，把双向边改为由大的连向小的的单向边。这样三元组就变为 $u \to v , u \to w, v\to w$。变为可以对一个点连出去的点中，他连出去的点有没有和他的兄弟。

复杂度严格小于 $O(n^2)$。其实等于每个点的入度乘上出度之和。

于是我们发现可以把值附为每个点的出度。这样可以证明复杂度为 $O(m \sqrt m)$。

为什么呢? ~~只要记住就好，问什么为什么。~~

对于每个出度大于 $\sqrt m$ 的点，比他大的点不然不超过 $\sqrt m$ 个，故他的入度不大于  $\sqrt m$ ，这种点的个数也不会大于  $\sqrt m$ 。而对于小于出度小于  $\sqrt m$ 的点，那肯定不会超过 m 个。（令 n，m 同阶)

```cpp
#include<bits/stdc++.h>
using namespace std;
//static char buf[1000000],*p1=buf,*p2=buf;
//#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++
#define re register
const int maxn=3e5+5;
inline int read()
{
	char ch=getchar();bool f=0;int x=0;
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=1;
	for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	if(f==1)x=-x;return x;
}
inline void print(int x)
{
    static int a[55];int top=0;
    if(x<0) putchar('-'),x=-x;
    do{a[top++]=x%10,x/=10;}while(x);
    while(top) putchar(a[--top]+48);
}
int n,m,u[maxn],v[maxn],in[maxn],vis[maxn],ans=0;
vector<int>e[maxn];
signed main()
{
	//freopen("P1989_9.in","r",stdin);
	//freopen(".out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=m;i++)
		u[i]=read(),v[i]=read(),in[u[i]]++,in[v[i]]++;
	for(int i=1;i<=m;i++)
	{
		if(in[u[i]]>in[v[i]]||(in[u[i]]==in[v[i]]&&u[i]>v[i]))swap(u[i],v[i]);
		e[u[i]].push_back(v[i]);
	}
	for(int i=1;i<=n;i++)
	{
		for(auto j:e[i])vis[j]=1;
		for(auto j:e[i])
		{
			for(auto k:e[j])if(vis[k])ans++;
		}
		for(auto j:e[i])vis[j]=0;
	}
	cout<<ans;
 	return 0;
}

```


---

## 作者：万弘 (赞：10)

应扶苏哥哥(也许是姐姐?)的邀请来写题解.

首先暴力,枚举$u$,枚举其所有可达点$v$,枚举$v$的可达点$w$,若$u$可达$w$,答案+1.注意这样会重复算6次.时间复杂度最坏$\mathcal O(n^2)$

显然这个暴力可以bitset优化,时间复杂度$\mathcal O(\frac{n^2}{w})$,空间复杂度$\mathcal O(n^2)$,MLE.

试试不要重复计数?  
具体地,先统计每个点的度数$deg(u).$如果$deg(u)<deg(v),$或$deg(u)=deg(v)$且$u<v$,称 **$u$优先级比$v$高**  
建一个新图,对于原图中无向边$(u,v)$,若$u$优先级比$v$高,则在新图上连有向边$u->v$(反之连$v->u$).则原图中的环$((u,v),(v,w),(u,w))$(不妨设$u$优先级比$v$高,$v$优先级比$w$高)在新图上表现为$(u->v,v->w,u->w)$.

(接下来只考虑新图)  
然后,枚举$u$,对其所有可达点打上标记.再考虑其所有可达点$v$,考虑其所有可达点$w$,若$w$有标记,答案+1.  
虽然这样没有了重复计数,但似乎时间复杂度还是最坏$\mathcal O(n^2)$?

可以证明,这种方法的时间复杂度是$\mathcal O(m\sqrt m)$的.  
简单证明下:  
记新图上入度为$in(u)$,出度为$out(u).$则$u$的贡献是$in(u)\times out(u)$.

1. 所有$out(u)\le \sqrt m$的点的贡献:$\sum_{i=1}^mout(v_i)=\mathcal O(m\sqrt m)$
2. 所有$out(u)> \sqrt m$的点的贡献:因为$out(u)\le deg(u)$,然后$m=\sum deg(u)$,所以这样的点至多$\mathcal O(\sqrt m)$个.贡献至多$\mathcal O(m\sqrt m)$

总时间复杂度$\mathcal O(m\sqrt m)$
```cpp
/**********/
#define MAXN 200011
struct Edge
{
    ll v,nxt;
}e[MAXN];
ll cnt=0,last[MAXN],deg[MAXN];
void adde(ll u,ll v)
{
    e[++cnt].v=v;
    e[cnt].nxt=last[u],last[u]=cnt;
}

bool vis[MAXN];
pll a[MAXN];
int main()
{
    ll n=read(),m=read(),ans=0;
    for (int i = 1; i <= m; ++i)
    {
        ll x=read(),y=read();
        ++deg[x],++deg[y];
        a[i]=pll(x,y);
    }
    for (int i = 1; i <= m; ++i)
    {
        ll u=a[i].first,v=a[i].second;
        if(deg[u]>deg[v] || (deg[u]==deg[v] && u>v))std::swap(u,v);
        adde(u,v);
    }
    for (int u = 1; u <= n; ++u)
    {
        for (int i = last[u]; i ; i=e[i].nxt)vis[e[i].v]=1;
        for (int i = last[u]; i ; i=e[i].nxt)
        {
            ll v=e[i].v;
            for (int j = last[v]; j ; j=e[j].nxt)
                if(vis[e[j].v])++ans;
        }
        for (int i = last[u]; i ; i=e[i].nxt)vis[e[i].v]=0;
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：MuYC (赞：6)

不得不说很妙。

#### 题解

首先考虑到无向图的三元环不好考虑，于是我们想到利用有向图的性质来（暴力）判断三元环。考虑如何转化为有向图才能使得整个图的每个图的出度尽量均匀。

如果两个点的度数不同，我们将**度数小的点连向度数大的点**。如果两个点的度数相同，那么就直接**编号小**的连向**编号大**的，这样子是可以保证整张图上不存在任意一点的**出度**大于 O($\sqrt{m}$)。

连出来的有向图肯定是有向无环的。关于这个的证明 [扶苏大佬](https://www.luogu.com.cn/user/65363) 不屑于讲，于是我来补一下。

首先一个环都可以抽象为三个点：

![](https://cdn.luogu.com.cn/upload/image_hosting/rzgy0lw8.png)

假设存在环，按照我们连的有向边，那么应该满足 :

$out_1 < out_2 < out_3 < out_1$ ($out_i$ 表示 $i$ 点的出度)

显然不会存在这种情况。

会不会存在这三个点的出度相同的情况呢？也不会，因为我们会从编号小的连向编号大的点。

会不会出现两个点的 出度相同，然后另外一个点的出度大于或者小于这两个点而导致这种情况呢？这个也不会有。

所以我们按照上面的确定边方向的方法形成的有向图不会有环，是一个 $DAG$ 。

然后现在我们要证明形成的有向图**每条边的出度** $<= \sqrt{m}$:

下面我们对于任意点 $u$ 给出证明：

+ 假如在原无向图中点 $u$ 的度 $<= \sqrt{m}$ ，定向后其出度肯定不会大于等于它在原图中的度，所以 $out_u <= \sqrt{m}$

+ 假如在原无向图中点 $u$ 的度 $> \sqrt{m}$ ，假如有边 $u$ $->$ $v$ ，那么 原图中 $u$ 的度小于等于 $v$ 的度，又因为原图中 $u$ 的度是  $>\sqrt{m}$ 的，所以满足条件的点 $v$ 不超过 $\sqrt{m}$ 个，于是这种情况下 $out_u < \sqrt{m}$

证毕。

现在我们定向得到的无向图的每条边的出度都 $<=$ $\sqrt{m}$ ，知道了这个后，我们现在的问题就是怎么找三元环了。

转化完后，原来在原图中的三元环都转换为了这样:

![](https://cdn.luogu.com.cn/upload/image_hosting/5gpydbuz.png)

我们现在可以大胆的枚举判断了，吗？

大胆枚举的时间复杂度是: O($nm$) （$\sqrt{m} * \sqrt{m} = m$）的？

但是实际上却跑得很快是为什么？

因为实际上上面的复杂度是假的。真实的复杂度应该是 O$(m\sqrt{m})$的。

为什么呢。想必大多数同学都很懵逼，并不知道为什么......

这里再来一个证明:(可能并不是很严谨，轻喷)

很容易可以知道：

每条边 $(u,v)$ 实际上对于复杂度的贡献为：

$out_v$ ，然后每条边在整个过程中至多被遍历两次，所以总的复杂度为:

O($\sum_{i = 1}^{i = m}{out_{i_{to}}}$ + $n$)，($to$ 表示边的终点)，因为前面已经证明过 $out_i <= \sqrt{m}$ ，所以总的复杂度为 O($m\sqrt{m}$ + n)。

于是我们是可以大胆枚举的。（雾

#### Code


```cpp

#include <bits/stdc++.h>
using namespace std;
const int MAXN = 2e5 + 50;
int n,m;
int start[MAXN],tot = 0;
int T[MAXN],out[MAXN],book[MAXN],F[MAXN];

struct Node {
	int next,to;
} edge[MAXN * 4];

inline int read() {
	int x = 0 , flag = 1;
	char ch = getchar();
	for( ; ch > '9' || ch < '0' ; ch = getchar()) if(ch  == '-') flag = -1;
	for( ; ch >= '0' && ch <= '9' ; ch = getchar()) x = (x << 3) + (x << 1) + ch - '0';
	return x * flag;
}

void add(int u,int v) {
	edge[++tot].next = start[u];
	edge[tot].to = v;
	start[u] = tot;
	return ;
}

int main() {
	n = read() , m = read();
	for(int i = 1 ; i <= m ; i ++) {
		F[i] = read() , T[i] = read();
		out[F[i]] ++ , out[T[i]] ++;//统计每个点在原图里面的度
	}
	for(int i = 1 ; i <= m ; i ++) {
		if(out[F[i]] > out[T[i]]) add(F[i],T[i]);
		if(out[F[i]] == out[T[i]]) add(min(F[i],T[i]),max(F[i],T[i]));
		if(out[F[i]] < out[T[i]]) add(T[i],F[i]);//分类讨论
	}
	int Ans = 0;
	for(int i = 1 ; i <= n ; i ++) {//暴力判断
		for(int j = start[i] ; j ; j = edge[j].next) {
			int to = edge[j].to;
			book[to] = i;
		}
		for(int j = start[i] ; j ; j = edge[j].next) {
			int to = edge[j].to;
			for(int k = start[to] ; k ; k = edge[k].next) {
				int to = edge[k].to;
				if(book[to] == i) Ans ++;
			}
		}
	}
	cout <<  Ans;
	return 0;
}
```

---

## 作者：寒鸽儿 (赞：5)

### Note

考虑暴力找环的过程 , 枚举第一个点 , 枚举第一个点下的第二个点 , 再枚举所有第一个点、第二个点对应的第三个点。这样复杂度为 $\mathcal{O(n^3)}$ 。  

考虑对边做定向 , 边的方向由度数较大的节点指向边数较小的节点。若度数相同则由按照节点编号定序(或者按照任意定序方式定序)。  

这样做会有很好的性质 : 

1. 新图中没有环 , 所有三元环都会成为一个由1个节点 $a$ 指向另外两个节点$b$ $c$ , 剩余节点 $b$ $c$ 之间还有一条边的DAG , 不妨记为 $b \xrightarrow{} c$ 。那么当枚举点 $a$ 时标记所有出边的点 $b$  $c$ , 再向下遍历第三个点即可找到环。而且遍历的顺序仅可能为 $a \rightarrow b \rightarrow c$ ,  因而不会重复计数。  

2. 原图中每个节点的度数 $\mathcal{O(\sqrt{m}})$ 。  

    证明如下 : 

    原无向图中的节点度数大于定向后图中的节点的出度。$\texttt{Lemma1}$

    对于原图中度数规模 $\leqslant \mathcal{O(\sqrt{m})}$ 的节点 , 由 $\texttt{Lemma1}$ , 其出度规模至多是 $\mathcal{O{\sqrt m}}$ 的 , 其入度规模至多 $\mathcal{O(n)}$ 。因而其复杂度至多是 $\mathcal{O{(n\sqrt m)}}$ 的。  

    对于原图中度数规模 $\geqslant{\mathcal{O(\sqrt m)}}$ 的节点 。 图中节点的度数的总和为 $\mathcal{O(m)}$ 。至多存在 $\mathcal{O(\sqrt m)}$ 个点的度数大于这个节点 , 也就是出度规模的上限为 $\mathcal{O(\sqrt m)}$ 。  

    这个性质保证了整张图中找三元环的复杂度为 $\mathcal{O(m \sqrt m)}$ (令 $n$ 、 $m$ 同阶)。  

### 事项

1. 注意在标记时 `vis[j] = i` ， 在判断时也应判断 `vis[j] == i` , 其含义是在当前出发的枚举点能到达的范围。  

### code

```cpp
#include <cstdio>
#include <vector>

using namespace std;

typedef vector< vector<int> > Graph;
Graph G;

const int maxn = 100010;
int vis[maxn];

int main() {
	int n, m, u, v;
	scanf("%d %d", &n, &m);
	G.resize(n + 1);
	for(int i = 1; i <= m; ++i) {
		scanf("%d %d", &u, &v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
	int ans = 0;
	for(int i = 1; i <= n; ++i) {
		for(int j : G[i])
			if(G[i].size() > G[j].size() || G[i].size() == G[j].size() && i > j) vis[j] = i;
		for(int j : G[i])
			if(G[i].size() > G[j].size() || G[i].size() == G[j].size() && i > j)
				for(int k : G[j])
					if(G[j].size() > G[k].size() || G[j].size() == G[k].size() && j > k)
						if(vis[k] == i)
							++ans;
	}
	printf("%d\n", ans);
	return 0;	
}
```



---

## 作者：RemiliaScar1et (赞：5)

## 无向图三元环计数

一个科技，在 $O(m\sqrt m)$ 复杂度内寻找三元环 。

解决的具体问题：给定 $n$ 点 $m$ 边的无向图，求无序三元点组 $(i,j,k)$ 的数量，满足图中存在边 $(i,j),(j,k),(i,k)$。

首先，对边进行重定向。对于两个点，我们比较它们的度数大小关系，若相等则比较编号大小，从小的点向大的点连边。这样可以得到一张 DAG。

为了方便，我们暂时称 $v$ 是 $u$ 的子节点当 $(u,v)\in E$。

- 在新的 DAG 中每次枚举一个点 $i$，然后将它所有的出边链接的点打上标记 $i$。

- 再枚举 $i$ 的一个子节点 $j$，枚举它的所有子节点，若发现有一个子节点 $k$ 有 $i$ 的标记，则 存在一个三元环 $k$。

这样为什么是对的呢？

按照算法的流程，原来图中的一个三元环 $(i,j,k)$ 在重定向之后一定变成了 $i$ 向 $j,k$ 连边，$j,k$ 之间再连一条边的情况。不妨设为 $j\to k$ 。我们枚举 $i$ 时会标记 $j,k$ ，再遍历 $j$ 找第三个点的时候一定会找到 $k$，并且对于这个环，遍历顺序只可能是 $i,j,k$，也就是我们只能由 $i$ 来找到这个环。每个点我们只会枚举一次，所以图中的每一个三元环，我们都会遍历仅一次。

那么时间复杂度为什么 $O(m\sqrt m)$ 呢？

考虑每条边 $(u,v)$ 对时间复杂度的贡献与 $v$ 的出度同阶，总的时间复杂度应当是 $\sum_{i=1}^m d_v$，这里 $d$ 是出度。

- 对于原图中度数不大于 $\sqrt{m}$ 的点，新图中的度数也不可能更大，所以上界 $\sqrt{m}$。

- 对于原图中度数大于  $\sqrt{m}$ 的点，由于我们只向度数大的点连边，而度数大于 $\sqrt{m}$ 的点最多有 $\sqrt{m}$ 个，度数也不可能超过 $\sqrt m$。

综上，总的时间复杂度 $O(m\sqrt{m})$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef pair<int,int> PII;
typedef long long ll;

const int N=2e5+10;

int head[N],ver[N<<1],nxt[N<<1],tot=0;
void add(int x,int y)
{
	ver[++tot]=y; nxt[tot]=head[x]; head[x]=tot;
}
int n,m;
int d[N],vis[N];
PII E[N];

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		d[x]++; d[y]++;
		E[i]={x,y};
	}
	for(int i=1;i<=m;i++)
	{
		int x=E[i].first,y=E[i].second;
		if(d[x]<d[y]) add(x,y);
		else if(d[x]==d[y]&&x<y) add(x,y);
		else add(y,x);
	}
	ll ans=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=head[i];j;j=nxt[j])
			vis[ver[j]]=i;
		for(int j=head[i];j;j=nxt[j])
		{
			int y=ver[j];
			for(int k=head[y];k;k=nxt[k])
				if(vis[ver[k]]==i) ans++;
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---


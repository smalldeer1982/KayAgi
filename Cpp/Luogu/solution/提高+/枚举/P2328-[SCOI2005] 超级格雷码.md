# [SCOI2005] 超级格雷码

## 题目描述

![](https://cdn.luogu.com.cn/upload/pic/1392.png)


## 说明/提示

感谢@Night_Aurora 提供SPJ

## 样例 #1

### 输入

```
2  2```

### 输出

```
00
01
11
10
```

# 题解

## 作者：Schi2oid (赞：8)

# 嗯……我有一个神奇的思路
大致写一下……你会发现其实你每次修改的位置跟 $B$ 进制数修改的位置不谋而合……什么意思呢……
```cpp
//设输入为3 3
000  000
001  001
002  002
012  010
011  011
010  012
020  020
021  021
022  022
122  100
121  101
120  102
110  110
111  111
112  112
102  120
101  121
100  122
200  200
201  201
202  202
212  210
211  211
210  212
220  220
221  221
222  222
//左边题目所求 右边三进制的遍历
```
~~显而易见~~，每次三进制数变化的最高位（比如三进制数从 $122$ 变到 $200$ ，则最高位为从右往左数第三位。）~~恰巧~~就是超级格雷码发生变动的位置（此时超级格雷码的第三位从 $1$ 变成了 $2$ ），而变动为 $±1$ ，每一位的变动方向不改变，直到触碰到 $0$ 或是 $B-1$ ，那么这时候将方向变一下即可。

其实可以类比时针分针秒针的关系来理解。最高位是时针，第二位是分针，第三位是秒针。在每一小时内，分针都动了 $60$ 下，而每一分钟内，秒针都动了 $60$ 下。（在这里就是分别为 $3$ 下）在这道题中，不过是可以想象成时分秒针在转过一圈后，都会反向进行旋转，这样就能保证每次操作之间的差距为 $1$ 。

那么代码 不就呼之欲出了吗

开一个方向数组。初始设置成正增长，即从 $0$ 到 $B-1$ 方向的。然后去随随便便写个 $n$ 进制加一算法，记录下进位到了哪一位，将这一位加上方向变量再输出就好啦！

以下是代码楼：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,B,a[20]={0},fx[20]={0},b[20]={0};//fx就是方向数组，b是n进制遍历数组，a是输出数组
void sc(int x)//输出函数 
{
	if(x>=10)
	{
		char c=char('A'+x-10);
		printf("%c",c);
	}
	else
	{
		printf("%d",x);
	}
}
int main(){
	int times=1;//统计输出次数
	cin>>n>>B;
	for(int i=1;i<=n;i++)
		sc(a[i]);
	printf("\n");//先输出一堆0
	for(int i=0;i<=19;i++)
		fx[i]=1; 
	while(times<pow(B,n))
	{
		b[n]++;
		int flag=n;
		for(int i=n;i>=1;i--)
		{
			if(b[i]==B)
			{
				b[i]=0;
				b[i-1]++;
				flag=i-1;//记录进位到了哪里
			}
			else break;
		}
		a[flag]+=fx[flag];
		if(a[flag]==0||a[flag]==B-1)
		{
			fx[flag]=-fx[flag];
		}
		times++;
		for(int i=1;i<=n;i++)
			sc(a[i]);
		printf("\n");
	}
	return 0;
}
```
首篇题解！还望支持！

---

## 作者：junyu33 (赞：7)

## 构造方法

对于n进制的数，我们可以构造一个长为$n^2$的循环，

0 1 2 3 ... n-1

n-1 0 1 2 ... n-2

n-2 n-1 0 1 ... n-3

......

1 2 3 4  ... 0.

对于最后一位，直接按照这样的方式循环。

对于倒数第二位，每个数字重复出现 $n$ 次。

对于倒数第三位，每个数字重复出现 $n^2$ 次。

以此类推。

## 举例解释

输入 n=3,m=3:

（循环节是 012201120）

输出：

000
001
002
012
010
011
021
022
020
120
121
122
102
100
101
111
112
110
210
211
212
222
220
221
201
202
200

## 代码

按照方法模拟即可：

```cpp
/*
 * @Author: junyu33 
 * @Date: 2020-05-12 00:29:42 
 * @Last Modified by:   junyu33 
 * @Last Modified time: 2020-05-12 00:29:42 
 */
#include <bits/stdc++.h>
using namespace std;
int rot[10000],ind,val;
int n,m;
int main(){
   cin>>n>>m;
   for(int i=1;i<=m;i++){
      for(int j=1;j<=m;j++)
         rot[ind++]=val,
         val=(val+1)%m;
      val=(val-1+m)%m;
   }
   for(int i=0;i<pow(m,n);i++){
      for(int j=0;j<n;j++){
         int digit=n-j;
         int shang=i/pow(m,digit-1);
         shang%=m*m;
         if(rot[shang]<=9) cout<<rot[shang];
         else cout<<(char)(rot[shang]-10+'A');
      }
      cout<<endl;
   }
   return 0;
}
```


---

## 作者：YangKun (赞：7)

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
using namespace std;
int a[1100],n,m;
void dfs(int k,int jw)
{
    if(k==n+1)
    {
        for(int i=n;i>=1;i--)
        {
            if(a[i]>=10)printf("%c",a[i]-10+'A');
            else printf("%d",a[i]);
        }
        printf("\n");
        return ;
    }
    if(jw==0)
    {
        for(int i=0;i<m;i++)
        {
            a[k]=i;
            if(i%2==1)dfs(k+1,1);
            else dfs(k+1,0);
        }
    }
    else
    {
        for(int i=m-1;i>=0;i--)
        {
            a[k]=i;
            if(i%2==1)dfs(k+1,0);
            else dfs(k+1,1);
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    dfs(1,0);//第一个开始，那么第一个自然一定必须是偶数 
    return 0;
}
```

------------

~~~~这道题是找规律。。

但我还打表才搞出来。。

规律：当第i数是偶数时，第i-1个数是由大到小排列，

当第i数是奇数时，第i-1个数是由小到大排列，

于是乎就打了个dfs，原本以为还要优化，但就这样AC了

---

## 作者：wsyhb (赞：5)

## 题解

$n$ 位 $B$ 进制数组成的超级格雷码不止一种，下面给出其中一种生成算法：

1. 一位超级格雷码由 $B$ 个一位 $B$ 进制串组成，顺序为：$0,1,\cdots,B-1$。
1. $n+1 \; (n \ge 1)$ 位超级格雷码由 $B$ 个部分组成（从左到右编号为 $0,1,\cdots,B-1$），编号为 $i$ 的部分包含：所有的 $n$ 位超级格雷码加上**一位后缀** $i$。若 $i$ 为偶数，则该部分**顺序**排列；若 $i$ 为奇数，则该部分**逆序**排列。

举个例子，当 $B=3$ 时，超级格雷码可以这样推出：

1. 一位超级格雷码为 $0,1,2$。
1. 两位超级格雷码的三个部分依次为：$\{0{\color{red}0},1{\color{red}0},2{\color{red}0}\}$，$\{2{\color{red}1},1{\color{red}1},0{\color{red}1}\}$ 和 $\{0{\color{red}2},1{\color{red}2},2{\color{red}2}\}$。
1. 三位超级格雷码的三个部分依次为：$\{00{\color{red}0},10{\color{red}0},20{\color{red}0},21{\color{red}0},11{\color{red}0},01{\color{red}0},02{\color{red}0},12{\color{red}0},22{\color{red}0}\}$，
$\{22{\color{red}1},12{\color{red}1},02{\color{red}1},01{\color{red}1},11{\color{red}1},21{\color{red}1},20{\color{red}1},10{\color{red}1},00{\color{red}1}\}$ 和 
$\{00{\color{red}2},10{\color{red}2},20{\color{red}2},21{\color{red}2},11{\color{red}2},01{\color{red}2},02{\color{red}2},12{\color{red}2},22{\color{red}2}\}$
1. ……

实现的话可以用 vector 或数组存储每种位数的答案，**多个部分之间使用 STL 的 `reverse()` 函数**。

## 代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
inline char to_char(int x)
{
	assert(x>=0&&x<=35);
	return x<=9?x+'0':x-10+'A';
}
int main()
{
	int n,B;
	scanf("%d%d",&n,&B);
	vector<vector<string> > ans(n);
	string empty="";
	for(int i=0;i<B;++i)
		ans[0].push_back(empty+to_char(i));
	for(int i=1;i<n;++i)
		for(int j=0;j<B;++j)
		{
			for(vector<string>::iterator it=ans[i-1].begin();it!=ans[i-1].end();++it)
				ans[i].push_back(*it+to_char(j));
			reverse(ans[i-1].begin(),ans[i-1].end());
		}
	for(vector<string>::iterator it=ans[n-1].begin();it!=ans[n-1].end();++it)
		cout<<*it<<"\n";
	return 0;
}
```

---

## 作者：晔子 (赞：5)

### 暴力出奇迹喵！
### 这是一道模拟题

你会发现和 [P5657 格雷码【民间数据】](https://www.luogu.org/problem/P5657)有异曲同工之妙，这道题直接按照上边链接题目的操作步骤 **暴力模拟** 就可以啊

我们观察 $n=2$ 时候格雷码是这样操作的

在线引用链接题面描述：

![fsakioi](https://cdn.luogu.com.cn/upload/image_hosting/5m1xu0it.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

带大家模拟一下：

比如 $n=4$ 

先生成1位：

也就是 0，1，2，3

然后生成两位：

也就是先把上一层的复制下来，顺序排好，然后再逆序排一遍，然后再顺序排一遍，再逆序排一遍。。。然后一小层作为一个分界，每一层的最左端都依次加上相应的字符 0,1,2，，，n-1


00 , 01 , 02 , 03 ，

13 , 12 , 11 , 10 ，

20 , 21 , 22 , 23 ，

33 , 32 , 31 , 30

n，B取其他值的时候也是一样的模拟

### 代码
```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<string>
#include<cstring>
#include<queue>

using namespace std;

typedef long long ll;

inline int read()
{
	int ans=0;
	char last=' ',ch=getchar();
	while(ch<'0'||ch>'9') last=ch,ch=getchar();
	while(ch>='0'&&ch<='9') ans=ans*10+ch-'0',ch=getchar();
	if(last=='-') ans=-ans;
	return ans;
}

const int maxn=65540;
string s[maxn],a[maxn];
int n,b,tot=1,cnt=1;
bool flag=0;

char chang(int x)
{
	char p;
	if(x<=9) p=(char)(x+48);
	else{
		p=(char) 65+x-10;
	}
	return p;
}

void work1(int k)
{
	char p=chang(k);
	for(int i=1;i<=tot;i++){
		s[cnt]=p+a[i];
		cnt++;
	}
}

void work2(int k)
{
	char p=chang(k);
	for(int i=tot;i>=1;i--){
		s[cnt]=p+a[i];
		cnt++;
	}
}

int main()
{
	n=read();b=read();
	tot=b;
	for(int i=1;i<=tot;i++){
		char p=chang(i-1);
	    s[i]+=p;
	} 	
	for(int t=2;t<=n;t++){
		flag=0;
		cnt=1;
		for(int i=1;i<=tot;i++) a[i]=s[i];
		for(int k=0;k<b;k++){
			if(flag==0) work1(k);
			else work2(k);
			flag^=1;
		}
		tot=cnt-1;
	}
	for(int i=1;i<=tot;i++) cout<<s[i]<<"\n";
	return 0;
}

```




---

## 作者：IceKylin (赞：3)

# P2328 超级格雷码 题解
### [原题链接](https://www.luogu.com.cn/problem/P2328)
### [更好的阅读体验？](https://www.luogu.com.cn/blog/std-IK/p2328-ti-xie)

这是一道 **构造题**，这里提供一种 **常数较大但思维难度较低** 的构造方式。

通过观察小规模的数据可以发现，对于相邻的两个超级格雷码，有且仅有一位数字不同，并且这一位数字的 **差值为 ${1}$**（在 **模意义** 下成立）。

举一个十进制的例子：${1}$ 和 ${2}$ 差值为 ${1}$，${0}$ 和 ${9}$ 差值也为 ${1}$。（这是一种 **不严谨** 的表述方式，但是相对容易理解）。

这就让我们想到了一种构造方式：

1.  对于任意的 ${n}$ 和 ${B}$，输出的第一个超级格雷码 **恒为 ${000\cdot\cdot\cdot 00}$**。

2. 对于第 ${i}$ 个超级格雷码码，先复制第 ${(i-1)}$ 个超级格雷码，然后依次枚举每一位，尝试 ${+1}$ 或 ${-1}$。如果产生的新的超级格雷码还未曾使用过，那么就将它标记为已使用，跳出循环并输出它，否则继续枚举，直到尝试成功。

这种构造方式的好处是 **不需要过多找规律**，但也有几点需要注意：

1. 修改函数（即上文提到的 ${+1}$ 或 ${-1}$ 操作）要 **特判越界的情况**。

2. 对于判断超级格雷码是否使用过，可以不用 map 维护，而是直接计算其在十进制下的值，用 **桶** 维护即可（降低时间复杂度）。

3. 此做法的时间复杂度虽为 ${O(n\times B^n)}$，理论上不会超时，但常数可能为其他题解的两倍以上，所以需要一些处理常数的细节优化，详见代码。

## AC 代码
```cpp
//By IceKylin
#include<bits/stdc++.h>
#define maxs 66000
#define maxn 40
#define maxt 2500000
#define il inline
using namespace std;
int n,b;
bool t[maxt];
char s[maxs][maxn];


il void _init(){
	for(int i=1;i<=n;++i)s[1][i]='0';
	t[0]=1;
}


il char _update(char c){
	if(b<=10){
		char mx='0'+b-1;
		if(c<'0')c=mx;
		if(c>mx)c='0';
	}
	else{
		char mx='A'+b-11;
		if(c<'0')c=mx;
		if(c=='9'+1)c='A';
		if(c=='A'-1)c='9';
		if(c>mx)c='0';
	}
	return c;
}


il int _get_val(int x){
	int val=0,base=1;
	for(int i=1;i<=n;++i){
		if(s[x][i]<='9')val+=(s[x][i]-'0')*base;
		else val+=(s[x][i]-'A'+10)*base;
		base*=b;
	}
	return val;
}


il bool _check(int x){
	int a=_get_val(x);
	if(!t[a]){
		t[a]=1;
		return true;
	}
	return false;
}


il void _copy(int x){
	for(int i=1;i<=n;++i)s[x][i]=s[x-1][i];
}


il void _change(int x){
	for(int i=1;i<=n;++i){
		char tmp=s[x][i];
		s[x][i]=_update(s[x][i]+1);
		if(_check(x))break;
		s[x][i]=tmp;
		s[x][i]=_update(s[x][i]-1);
		if(_check(x))break;
		s[x][i]=tmp;
	}
}


il void _print(int x){
	for(int i=1;i<=n;++i)cout<<s[x][i];
	cout<<'\n';
}


int main(){
	ios::sync_with_stdio(false);
	cin>>n>>b;
	_init();
	_print(1);
	int mx=pow(b,n);
	for(int i=2;i<=mx;++i){
		_copy(i);
		_change(i);
		_print(i);
	}
	return 0;
}
```

---

## 作者：G_A_TS (赞：3)

题解同步发布于[blog](https://www.cnblogs.com/wzzorz/articles/10343923.html)  

------------
此题似乎也可以不找规律。。。~~(因为我还是没看懂dalao说的奇偶性)~~  
首先确定方向，思路为爆搜+去重，但是去重开销大，要去掉  
所以方向确定为**搜一次输出一次不判断**  
先从某状态(0000?)开始，先改一位的值(++ or --)，到满就退一位(还是容易想的)  
但退回去后如何保证后面的值不变呢？

------------
首先可以确定的是，改的位的后一位一定达到边界(0 or B-1)  
所以爆搜后一层的初始一定是**0 or B-1**!  
交叉搜索奇偶判断就好啦!(感谢写SPJ的dalao)  
最后是蒟蒻我的代码

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,B;
int num[110];
int dfs(int now,int check)
{
	if(now==n+1)
	{
		for(int i=1;i<=n;i++)
		{
			if(num[i]>9)
			{
				cout<<(char)(num[i]-10+'A');
			}
			else
			{
				cout<<num[i];
			}
		}
		cout<<endl;
		return 0;
	}
	if(check==0)
	{
		for(int i=0;i<B;i++)
		{
			num[now]=i;
			dfs(now+1,(i%2)?1:0);
		}
	}
	else
	{
		for(int i=B-1;i>=0;i--)
		{
			num[now]=i;
			dfs(now+1,(i%2)?0:1);
		}
	}
}
int main()
{
	cin>>n>>B;
	dfs(1,0);
} 
```

---

## 作者：啷里个浪 (赞：2)

## 2021.12.15 P2328 [SCOI2005]超级格雷码(找规律填空)

https://www.luogu.com.cn/problem/P2328

**题意：**

输出n位B进制的格雷码。

**分析：**

好吧，咱先写出来一部分格雷码试试。

当 $n=2,B=2$ 时（这个表咱竖着看）

|  00  |  10  |
| :--: | :--: |
|  01  |  11  |

似乎没有什么规律，咱继续，当$n=3,B=3$ 时（这个表咱竖着看）

| 000  | 122  | 200  |
| :--: | :--: | :--: |
| 001  | 121  | 201  |
| 002  | 120  | 202  |
| 012  | 110  | 212  |
| 011  | 111  | 211  |
| 010  | 112  | 210  |
| 020  | 102  | 220  |
| 021  | 101  | 221  |
| 022  | 100  | 222  |

似乎发现点规律：

**1.去掉重复的数字，总是一个固定的数字循环在不断重复：**
$$
0,1,2,\cdots,B-1,B-1,\cdots,1,0
$$
**2.从右往左数第 $i$ 列数字在同一循环节里出现的次数为 $B^{i-1}$ ；**

**3.这可以用除法以及取模哟~**

咱继续实验，当 $n=2,B=3$ 时：

| 00   | 01   | 02   | 12   | 11   | 10   | 20   | 21   | 22   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

这一行咱横着看，是不是依旧符合那个规律？

对于第 $i$ 个出现的格雷码，对于它的第 $j$  位上数字编号（不是字母，咱多个函数转一下字符就行）：

1.计算它是属于第几个出现的字符，这里咱先除去每个循环节重复的字符数，找到它是第几个不重复的字符
$$
x=i\%(B^{j-1})?i/(B^{j-1})+1:i/(B^{j-1})
$$
2.计算它在每个循环节中的位置，每个循环节长度为 $2*B$ ，
$$
x\%=2*B
$$
**代码如下：**

```c++
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<bitset>
#define IOS ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);
using namespace std;

int n,B,num[100],len[100];

inline int ksm(int x,int y){
	int fin=1;
	while(y){
		if(y&1)fin*=x;
		x*=x;
		y>>=1;
	}
	return fin;
}
inline char id(int x){
	if(x>=0&&x<=9)return (char)(x+'0');
	else return (char)(x-10+'A');
}

int main(){
	IOS;
	cin>>n>>B;
	for(int i=0;i<B;i++)num[i+1]=num[2*B-i]=i;
	//for(int i=1;i<=2*B;i++)cout<<num[i]<<" ";cout<<endl;
	int m=ksm(B,n);
	//for(int i=0;i<=35;i++)cout<<id(i)<<" ";cout<<endl;
	for(int i=n-1;i>=0;i--)len[i+1]=ksm(B,i);
	//for(int i=1;i<=n;i++)cout<<len[i]<<" ";cout<<endl;
	for(int i=1;i<=m;i++){
		for(int j=n;j>=1;j--){
			int x=i%len[j]?i/len[j]+1:i/len[j];
			x%=2*B;
			cout<<id(num[x]);
		}
		cout<<endl;
	}
	return 0;
}
```



---

## 作者：iloveziwei (赞：1)

# 题目

[题目链接。](https://www.luogu.com.cn/problem/P2328)

# 简述 

输出 $B$ 进制 $n$ 位的所有格雷码。

# 思考

通过观察，我们发现第 $x$ 个格雷码的第 $n$ 位为 $\lfloor \displaystyle \frac{x-1}{B^{n-1}} \rfloor$，第 $n-i$ 位 $(i>0)$ 其实要从第 $n$ 位到第 $n-i+1$ 位之和判断，如果第 $n$ 位到第 $n-i+1$ 位之和为偶数,则第 $n-i$ 位为 $\lfloor \displaystyle \frac{(x-1) \bmod B^{n-i}}{B^{n-i-1}} \rfloor$，否则如果是奇数则 $n-i$ 位为 $B-1- \lfloor \displaystyle \frac{(x-1) \bmod B^{n-i}}{B^{n-i-1}} \rfloor $。 

# AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n,B; 
ll even_odd; //判断前面的数的奇偶性。 
ll ans[1110];
void print(){//输出 
	for(ll i=1;i<=n;i++){
		if(ans[i]>9)cout<<(char)(ans[i]-10+'A');
		else cout<<ans[i];
	}
	cout<<endl;
	return;
}
ll qpow(ll a,ll b){//快速幂 
	ll ans=1;
	while(b>0){
		if(b%2)ans*=a;
		b/=2;
		a*=a; 
	} 
	return ans;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>B;
	for(ll x=1;x<=qpow(B,n);x++){
		ans[1]=(x-1)/qpow(B,n-1);
		even_odd=ans[1]%2;
		for(ll i=2;i<=n;i++){
			ans[i]=(even_odd%2==0?(((x-1)%qpow(B,n-i+1)))/qpow(B,n-i):B-1-(((x-1)%qpow(B,n-i+1)))/qpow(B,n-i));//通过公式可知 
			even_odd+=(ans[i]%2);
		}
		print();
	}
}
```


---

## 作者：zplqwq (赞：1)

题意：

求 $n$ 位在 $B$ 进制下的格雷码。

解法：

我们猜想这个格雷码是有循环节的，于是验证一下。

样例给出了 $n=B=2$ 的情况，由于比较小，不好发现规律。

我们把 $n=B=3$ 的情况手动画出。

以 $0$ 为第一位：
$\{0,0,0\}\{0,0,1\}\{0,0,2\}\{0,1,2\}\{0,1,1\}\{0,1,0\}\{0,2,0\}\{0,2,1\}\{0,2,2\}$ 

以 $1$ 为第一位：
$\{1,2,2\}\{1,2,1\}\{1,2,0\}\{1,1,0\}\{1,1,1\}\{1,1,2\}\{1,0,2\}\{1,0,1\}\{1,0,0\}$ 

以 $2$ 为第一位：
$\{2,0,0\}\{2,0,1\}\{2,0,2\}\{2,1,2\}\{2,1,1\}\{2,1,0\}\{2,2,0\}\{2,2,1\}\{2,2,2\}$

这里为了方便做了个小分类。

然后我们就能发现规律，我们先把重复数字去掉，于是找到了一个循环。

$$\{0,1,2\}$$

尝试着推广一下，发现 $B$ 进制格雷码一定有以下循环：

$$\{0,1,2,3...B-1\}$$

然后还有一个性质，按照我们分类的规律，假设第一位是 $i$ ，那么他在一个循环里的出现次数就是 $B^{i-1}$。

这样就做完了。

我们直接求出循环节输出即可。

具体地，假设我们现在要输出第 $i$ 个格雷码的第 $j$ 位，那么设这位是 $k$ 。

则如果 $k$ 是该循环的最后一位，则 $k=(\frac{i}{B^{j-1}}+1) \% 2 \times B$ 。否则 $k=(\frac{i}{B^{j-1}}) \% 2 \times B$ 。

注意，显然，这里的 $k$ 是指的是他的数字编号（如 $A$ 是 $10$ ），所以需要在输出时处理一下。





---


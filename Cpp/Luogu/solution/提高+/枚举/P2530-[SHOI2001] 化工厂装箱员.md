# [SHOI2001] 化工厂装箱员

## 题目描述

118 号工厂是世界唯一秘密提炼锎的化工厂，由于提炼锎的难度非常高，技术不是十分完善，所以工厂生产的锎成品可能会有 $3$ 种不同的纯度，$A$：$100\%$，$B$：$1\%$，$C$：$0.01\%$，为了出售方便，必须把不同纯度的成品分开装箱，装箱员 grant 第 $1$ 次顺序从流水线上取 $10$ 个成品（如果一共不足 $10$ 个，则全部取出），以后每一次把手中某种纯度的成品放进相应的箱子，然后再从流水线上顺序取一些成品，使手中保持 $10$ 个成品（如果把剩下的全部取出不足 $10$ 个，则全部取出），如果所有的成品都装进了箱子，那么 grant 的任务就完成了。

由于装箱是件非常累的事情，grant 希望他能够以最少的装箱次数来完成他的任务，现在他请你编个程序帮助他。


## 样例 #1

### 输入

```
11
A
B
C
A
B
C
A
B
C
A
B
```

### 输出

```
3```

# 题解

## 作者：Always (赞：45)

这里提供一种新的思路:

状态:**f[i][j][k][m] : 前i个物品 当前手中有j个"A" k个"B" m个"C"时的最小卸货次数**

很明显对于第i个物品可以

1:)只取出来 暂时不装进去 前提就是当前手中货物数量<10

2:)取出来后 装进去 没有前提

所以转移方程就出来了:

**f[i][j][k][m] = f[i-1][j-1][k][m] if(ob[i]=='A' && j)**

**f[i][j][k][m] = f[i-1][j][k-1][m] if(ob[i]=='B' && k)**

**f[i][j][k][m] = f[i-1][j][k][m-1] if(ob[i]=='C' && m)**

以上三个均是 ****只取出来****

**f[i][0][k][m] = f[i][j][k][m] + 1 ;**

**f[i][j][0][m] = f[i][j][k][m] + 1 ;**

**f[i][j][k][0] = f[i][j][k][m] + 1 ;**

这三个就是卸货啦qwq 还有一个大前提:****j+k+m<=10****

初值:**f[0][0][0][0]=0** ; 其他均为**+oo**

目标:**f[n][0][0][0]**

还不懂就结合~~蒟蒻的~~代码看看

```
#pragma GCC optimize (2)
#include<bits/stdc++.h>
#define M 10005
#define rep(i , x , y) for(register int i = x ; i <= y ; ++i)
#define Rep(i , x , y) for(register int i = x ; i >= y ; --i)
using namespace std ;
int f[101][11][11][11] ;
//f[i][j][k][m] 表示前i个物品 当前手上有A j个 B k个 C m个 
int n ;
char obje[101] ;//存物品 
int main(){
	memset(f , 63 , sizeof f) ;//赋为inf 
	scanf("%d",&n) ;
	rep(i , 1 , n)cin >> obje[i] ;
	f[0][0][0][0] = 0 ;//初值 
	rep(i , 1 , n)rep(j , 0 , 10)rep(k , 0 , 10)rep(p , 0 , 10){
		if(j + k + p > 10)continue ;//手中物品不能超过10个 否则不处理 
		if(obje[i] == 'A' && j)//三个状态转移 都差不多(只装) 注意j,k,p得存在 
		f[i][j][k][p] = f[i - 1][j - 1][k][p] ;
		if(obje[i] == 'B' && k)
		f[i][j][k][p] = f[i - 1][j][k - 1][p] ;
		if(obje[i] == 'C' && p)
		f[i][j][k][p] = f[i - 1][j][k][p - 1] ;
		//这是卸货的转移 
		f[i][0][k][p] = min(f[i][0][k][p] , f[i][j][k][p] + 1) ;
		f[i][j][0][p] = min(f[i][j][0][p] , f[i][j][k][p] + 1) ;
		f[i][j][k][0] = min(f[i][j][k][0] , f[i][j][k][p] + 1) ;
	}
	printf("%d\n",f[n][0][0][0]) ;//终态 
	return 0 ;
}
```

---

## 作者：易颖杰 (赞：10)

这么一道（记忆化搜索||dp）的好题，竟然没人发记忆化搜索，那我来吧，其实一般的dp都能用记忆化搜索过，毕竟原理都一样，不过我觉得记忆化搜索好理解一些，状态f[x][a][b][c]：x表示当前处理到的成品的下标+1（就是马上要处理的开头），a表示当前手上有的A的数量，b和c就是B和C的数量啦，其它的代码里详说：
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int n,a[101],f[101][11][11][11];//a是存成品的种类
int dfs(int g[4],int x)//g存当前三种成品在手上的数量
{
    if(f[x][g[1]][g[2]][g[3]]!=0) return f[x][g[1]][g[2]][g[3]];//记忆化调用
    if(g[1]==0&&g[2]==0&&g[3]==0) return 0;//处理完了返回还需要0次处理
    int num=100000000;//num记录子方案的最优解
    for(int i=1;i<=3;i++)//枚举装箱的成品种类
        if(g[i]!=0)//要手上手上有才装
        {
            int t1=g[1],t2=g[2],t3=g[3],j,t=g[i];//记录下当下的值，方便复原
            g[i]=0;//装箱
            for(j=x;j<=x+t-1&&j<=n;j++)//取取行的成品；
                g[a[j]]++;
            num=min(num,dfs(g,j));//搜索下一层
            g[1]=t1,g[2]=t2,g[3]=t3;//回复当层的值
        }
    num++;//在上面的循环里就进行了装箱，所以次数要加一
    f[x][g[1]][g[2]][g[3]]=num;//记忆化
    return num;//返回此方案最优值
}
int main()
{
//    freopen("worker.in","r",stdin);
    //freopen("worker.out","w",stdout);
    scanf("%d",&n);
    for(int i=1;i<=n;i++)//输入
    {
        char j;
        cin>>j;
        switch(j)
        {
            case 'A': a[i]=1;break;
            case 'B': a[i]=2;break;
            case 'C': a[i]=3;break;
        }
    }
    int g[4]={0},i;
    for(i=1;i<=10&&i<=n;i++)//先装十个
        g[a[i]]++;
    cout<<dfs(g,i)<<endl;//调用记忆化搜索并输出
    return 0;
}
```

---

## 作者：丶Cyanide (赞：3)

此题第一次想到的是以前i个装完为基础的阶段进行dp,答案在dp[n][?][?]....;
但由于每次考虑装完前面的来转移不一定是最优的，所以前i位不能当作状态。
****因此我们想到一dp[i][j][k]表示装完i个A,j个B，k个C的最少装箱次数。
答案就在dp[num[A]][num[B]][num[C]]中。

考虑转移,假设我们知道当前dp[i][j][k]的最优解,为了转移到dp[i+?][j+?][k+?],我们就需要知道当前能装多少个A,B,C,因此我们需要3个东西:****1:当前流水线的位置(设为pos[i][j][k],pos[0][0][0]等于1);2:当前状态剩余多少个A,B,C没有装(因为不一定当前状态位置前面的都已经装完了,用cnt[A,B,C][i][j][k]表示); 3:当前流水线位置能新加入的有多少个A,B,C(get[A,B,C][i][1-10]表示从i这个位置延伸1-10能有多少A,B,C,预处理就行了)。

有了这3样东西，要转移就很简单了，以A为例。假设left表示当前状态还剩余没有装的个数(A,B,C 3种),那么还能延伸的区间就是 ****我们假设的pos[i][j][k]---pos[i][j][k]+(10-left)-1。假设c1为当前状态还有c1个A没有装,new1表示当前pos延伸出去能有多少个A。

****转移方程很容易想到dp[i+c1+new1][j][k]=min(dp[i][j][k]+1,dp[i+c1+new1][j][k])。同理B和C。

我的思路大概是这样，记录cnt的话，跟着转移就好了，贴代码，不懂的话可以看代码，有注释。就是代码有点长..
```cpp
#include<cstdio>//此题由于装箱过程中有新物品加入，而也有前面没装完的可能，故前i个不能作为状态。 
#include<algorithm>//我们只能考虑装了多少个A，B，和C的最少次数。 
#include<cstring>
using namespace std;
const int N=111;//pos[i][j][k]表示当前状态流水线的位置。 
int dp[N][N][N],n,pos[N][N][N],cnt[3][N][N][N];//cnt[0,1,2][i][j][k]表示当前状态剩余多少个没有装。 
int get[3][N][11];//预处理每一个位置向右x位有多少A,B,C。 
int num[3];
char s[N];
int main()
{
	scanf("%d",&n);
	char ch;
	for(int i=1;i<=n;i++)
	{
		ch=getchar();
		while(ch<'A'||ch>'C') ch=getchar();
		s[i]=ch;
		num[ch-'A']++;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=i;j<=i+9;j++)
		{
			if(s[j]=='A') get[0][i][j-i+1]=1;
			else if(s[j]=='B') get[1][i][j-i+1]=1;
			else if(s[j]=='C') get[2][i][j-i+1]=1;
			get[0][i][j-i+1]+=get[0][i][j-i];
			get[1][i][j-i+1]+=get[1][i][j-i];
			get[2][i][j-i+1]+=get[2][i][j-i];
		}
	}
	for(int i=0;i<=num[0];i++)//注意赋初值。 
		for(int j=0;j<=num[1];j++)
			for(int k=0;k<=num[2];k++)
				dp[i][j][k]=1e9;
	////////////////////////////////////////////////////////////////////////DP。 
	dp[0][0][0]=0;pos[0][0][0]=1;cnt[0][0][0][0]=0;cnt[1][0][0][0]=0;cnt[2][0][0][0]=0;//初始化 
	for(int i=0;i<=num[0];i++)
	{
		for(int j=0;j<=num[1];j++)
		{
			for(int k=0;k<=num[2];k++)
			{
				if(dp[i][j][k]==1e9) continue;//我们只针对有值的状态进行转移。 
				int c1=cnt[0][i][j][k];
				int c2=cnt[1][i][j][k];
				int c3=cnt[2][i][j][k];//当前状态剩余多少个没装的A,B,C 
				int po=pos[i][j][k];
				int left=10-(c1+c2+c3);//向右能延长多少？最多是10。 
				int new1=get[0][po][left];
				int new2=get[1][po][left];
				int new3=get[2][po][left];//新加入的A,B,C 
				if(dp[i][j][k]+1<dp[i+c1+new1][j][k])
				{
					dp[i+c1+new1][j][k]=dp[i][j][k]+1;
					cnt[1][i+c1+new1][j][k]=cnt[1][i][j][k]+new2;//因为只装了A，故对于B和C剩余的没装的就是新加入的加上原先剩余的。 
					cnt[2][i+c1+new1][j][k]=cnt[2][i][j][k]+new3;
					pos[i+c1+new1][j][k]=po+left; //不用考虑越界的情况，我们只关心装了多少个A,B,C。 
					cnt[0][i+c1+new1][j][k]=0;//记得赋0！！下面同理。 
				}
				if(dp[i][j][k]+1<dp[i][j+c2+new2][k])
				{
					dp[i][j+c2+new2][k]=dp[i][j][k]+1;
					cnt[0][i][j+c2+new2][k]=cnt[0][i][j][k]+new1;
					cnt[2][i][j+c2+new2][k]=cnt[2][i][j][k]+new3;
					pos[i][j+c2+new2][k]=po+left;
					cnt[1][i][j+c2+new2][k]=0;
				}
				if(dp[i][j][k]+1<dp[i][j][k+c3+new3])
				{
					dp[i][j][k+c3+new3]=dp[i][j][k]+1;
					cnt[0][i][j][k+c3+new3]=cnt[0][i][j][k]+new1;
					cnt[1][i][j][k+c3+new3]=cnt[1][i][j][k]+new2;
					pos[i][j][k+c3+new3]=po+left;
					cnt[2][i][j][k+c3+new3]=0;
				}
			}
		}
	}
	printf("%d",dp[num[0]][num[1]][num[2]]);
	return 0;
}
```


---

## 作者：strlen_s_ (赞：1)

## 分析

dp 题

设 $dp_{i,j,k,l}$ 表示考虑当前选完第 $i$ 个,手里有  $j$ 个 A,$k$ 个 B,$l$ 个 C,考虑填表法。

设 $nexa$ 表示拿走 A 种后,再补全到十个后的位置。

设 $nexb$ 表示拿走 B 种后,再补全到十个后的位置。

设 $nexc$ 表示拿走 C 种后,再补全到十个后的位置。

设 $c1$ 表示拿走一种后,再补全到十个后 A 的数量。

设 $c2$ 表示拿走一种后,再补全到十个后 B 的数量。

设 $c3$ 表示拿走一种后,再补全到十个后 C 的数量。

所以：

$$
dp_{nexa,j,k+c2,l+c3}=\min (dp_{nexa,j,k+c2,l+c3},dp_{i,j,k,l}+1) 
$$

$$
dp_{nexb,j+c1,k,l+c3}=\min (dp_{nexb,j+c1,k,l+c3},dp_{i,j,k,l}+1) 
$$

$$
dp_{nexc,j+c1,k+c2,l}=\min (dp_{nexb,j+c1,k+c2,l},dp_{i,j,k,l}+1) 
$$

为了更精准的遍历状态，再记一个 $vis_{i,j,k,l}$ 表示当前选完第 $i$ 个,手里有 $j$ 个A,$k$ 个 B,$l$ 个 C 的状态目前是否可达。

### 代码

```
#include<bits/stdc++.h>
#define re reigister
#define in inline
using namespace std;
in int read(){
	int x=0,f=1;char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c))x=x*10+c-'0',c=getchar();
	return x*f;
}
in void print(int x){
	if(x<0)x=-x,putchar('-');
	if(x>9)print(x/10);
	putchar(x%10+'0');
}
const int N=1e2+100;
int dp[N][11][11][11];
bool vis[N][11][11][11];
int n,_10;
int c1,c2,c3;
char c[N];
void qa(int k,int x,int y,int z){				//拿走这10个中所有的 A 。 
	int sum=10-y-z;
	c1=0,c2=0,c3=0;
	int nex=min(n,k+sum);
	for(int i=k+1;i<=nex;i++)c1+=(c[i]=='A'),c2+=(c[i]=='B'),c3+=(c[i]=='C');
	dp[nex][c1][y+c2][z+c3]=min(dp[nex][c1][y+c2][z+c3],dp[k][x][y][z]+1);
	vis[nex][c1][y+c2][z+c3]=1;					//标记状态是否可达。 
}
void qb(int k,int x,int y,int z){				//拿走这10个中所有的 B 。 
	int sum=10-x-z;
	c1=0,c2=0,c3=0;
	int nex=min(n,k+sum);
	for(int i=k+1;i<=nex;i++)c1+=(c[i]=='A'),c2+=(c[i]=='B'),c3+=(c[i]=='C');
	dp[nex][x+c1][c2][z+c3]=min(dp[nex][x+c1][c2][z+c3],dp[k][x][y][z]+1);
	vis[nex][x+c1][c2][z+c3]=1;
}
void qc(int k,int x,int y,int z){				//拿走这10个中所有的 C 。 
	int sum=10-x-y;
	c1=0,c2=0,c3=0;
	int nex=min(n,k+sum);
	for(int i=k+1;i<=nex;i++)c1+=(c[i]=='A'),c2+=(c[i]=='B'),c3+=(c[i]=='C');
	dp[nex][x+c1][y+c2][c3]=min(dp[nex][x+c1][y+c2][c3],dp[k][x][y][z]+1);
	vis[nex][x+c1][y+c2][c3]=1;
}
int ans=2e9;
int main(){
	memset(dp,0x3f,sizeof(dp));
	n=read();_10=min(n,10);						//处理小于十的情况。 
	for(int i=1;i<=n;i++){
		cin>>c[i];
		if(i<=10)
			c1+=(c[i]=='A'),c2+=(c[i]=='B'),c3+=(c[i]=='C');
	}
	vis[_10][c1][c2][c3]=1,dp[_10][c1][c2][c3]=0;
	for(int i=_10;i<=n;i++)
		for(int j=0;j<=10;j++)
			for(int k=0;k<=10;k++)
				for(int l=0;l<=10;l++){
					if(j+k+l>10)continue;
					if(!vis[i][j][k][l])continue;
					qa(i,j,k,l);
					qb(i,j,k,l);
					qc(i,j,k,l);
				}
	for(int j=0;j<=10;j++)						//对于剩余的统计答案 
			for(int k=0;k<=10;k++)
				for(int l=0;l<=10;l++){
					if(j+k+l>10)continue;
					if(!vis[n][j][k][l])continue;
					ans=min(ans,dp[n][j][k][l]+(j!=0)+(k!=0)+(l!=0));
				}
	cout<<ans;
}
```


---

## 作者：不存在之人 (赞：1)

写的像个$dp$似的，感觉其实就是个暴力。

设$dp[i][j][k][l]$表示拿到了$i$个，A有$j$个，B有$k$个，C有$l$个。

注意特判$n<10$的情况。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int dp[102][11][11][11],sum[3][104],a[102],n;
inline void mi(int &a,int b){if(b<a)a=b;}
char s[2];
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
	{
        scanf("%s",s);
        a[i]=s[0]-'A';
        sum[a[i]][i]=sum[a[i]][i-1]+1;
        for(int j=0;j<=2;++j)if(j!=a[i])sum[j][i]=sum[j][i-1];
    }
    memset(dp,0x3f,sizeof(dp));
    if(n<10)
	{
        cout<<(sum[0][n]!=0)+(sum[1][n]!=0)+(sum[2][n]!=0)<<endl;
        return 0;
    }
    dp[10][sum[0][10]][sum[1][10]][sum[2][10]]=0;
    for(int i=10;i<=n;++i)
      	for(int j=0;j<=10;++j)
        	for(int k=0;k<=10&&k+j<=10;++k)
          		for(int l=0;l<=10&&k+j+l<=10;++l)if(dp[i][j][k][l]!=0x3f3f3f3f)
				  {
               		if(j)
			   		{
                   		int num=j;
                 		mi(dp[min(i+num,n)][sum[0][min(n,i+num)]-sum[0][i]][k+sum[1][min(i+num,n)]-sum[1][i]][l+sum[2][min(i+num,n)]-sum[2][i]],dp[i][j][k][l]+1);
             		}
            		if(k)
					{
                		int num=k;
                		mi(dp[min(i+num,n)][j+sum[0][min(n,i+num)]-sum[0][i]][sum[1][min(n,i+num)]-sum[1][i]][l+sum[2][min(n,i+num)]-sum[2][i]],dp[i][j][k][l]+1);
            		}
            		if(l)
					{
                		int num=l;
                		mi(dp[min(i+num,n)][j+sum[0][min(i+num,n)]-sum[0][i]][k+sum[1][min(i+num,n)]-sum[1][i]][sum[2][min(i+num,n)]-sum[2][i]],dp[i][j][k][l]+1);
            		}
          		}
        int ans=0x3f3f3f3f;
    for(int i=0;i<=10;++i)
      	for(int j=0;i+j<=10;++j)
        	for(int k=0;i+j+k<=10;++k)
				if(dp[n][i][j][k]!=0x3f3f3f3f)
    ans=min(ans,dp[n][i][j][k]+(i!=0)+(j!=0)+(k!=0));
    cout<<ans;
    return 0;
}
```

---

## 作者：Accoty_AM (赞：1)

# 状态压缩-11进制
分成3位 0 0 0 f[i][j] 表示到i状态为j的 c，b，a，分别有多少位。

整个DP分成两步

## 从之前的拿货物转移到当前状态
由于可以拿的货物是确定的，所以转移也是一定的-详细看代码注释。
## 从现在的状态 转移到 装出手中一种货物的状态。
~~贪心的想~~装的时候把手里的物品全装完肯定是最优的，所以转移到把手中某种货物全装箱是最优的。

预处理所有可能状态可以加快程序

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rg register
inline int read(){
	rg char ch=getchar();
	rg int x=0,f=0;
	while(!isdigit(ch)) f|=(ch=='-'),ch=getchar();
	while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return f?-x:x;
}
int f[110][1334];
int n;
char s[110];
int ok[1334],cnt;
int main(){
	n=read();
	for(rg int i=1;i<=n;++i) scanf("%s",&s[i]);
//	memset(f,0x3f,sizeof f);
	f[0][0]=0;
	for(rg int a,b,c,j=0;j<=1331;++j){
		a=j%11,b=j/11%11,c=j/121%11;
		if(a+b+c>10) continue;
		ok[++cnt]=j;//预处理状态
	}
	for(rg int op,a,b,c,al,bl,cl,j,i=1;i<=n;++i){
		for(int l=1;l<=cnt;++l){
				j=ok[l];
				al=a=j%11,bl=b=j/11%11,cl=c=j/121%11;
				if(a+b+c>10)continue;
				f[i][j]=0x3f3f3f3f;
			for(int k=i;i-k<=10&&~k;--k){
				if(a<0||b<0||c<0) continue;
				f[i][j]=min(f[i][j],f[k][a+b*11+c*121]);//转移装入状态
				op=s[k]-'A'+1;
				if(op==1) --a;
				if(op==2) --b;
				if(op==3) --c;
			}
			f[i][j-al]=min(f[i][j-al],f[i][j]+1);
			f[i][j-bl*11]=min(f[i][j-bl*11],f[i][j]+1);
			f[i][j-cl*121]=min(f[i][j-cl*121],f[i][j]+1);//转移装出状态
  //这里值得一提的是状态转移可以省略下面三个转移，因为我们是按一个一个物品递进的，没有重叠的物品，所以可以省略。
//			f[i][j-al-bl*11]=min(f[i][j-al-bl*11],f[i][j]+2);
//			f[i][j-al-cl*121]=min(f[i][j-al-cl*121],f[i][j]+2);
//			f[i][j-bl*11-cl*121]=min(f[i][j-bl*11-cl*121],f[i][j]+2);
//			f[i][0]=min(f[i][0],f[i][j]+3);
		}
	}
	cout<<f[n][0]<<endl;
	return 0;
}
```
## 总结 状态的表示要精准，记录状态可以实现精准转移

---

## 作者：TheGod (赞：1)

//f[i][a][b][c][d] 取完前i件时 手中还有a个A，b个B，c个C的最小次数


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int dp[110][15][15][15];
int suma[110],sumb[110],sumc[110];//前i件中A,B,C的数量
int main(){
    char ch;
    int n,i,a,b,c,ans,tmp;
    cin>>n;
    suma[0]=sumb[0]=sumc[0]=0;
    for(i=1;i<=n;i++){
        suma[i]=suma[i-1];
        sumb[i]=sumb[i-1];
        sumc[i]=sumc[i-1];
        cin>>ch;
        if(ch=='A')suma[i]++;
            else if(ch=='B')sumb[i]++;
            else sumc[i]++;}
    if(n<=10){//不超过10直接输出
        ans=3;
        if(!suma[n])ans--;
        if(!sumb[n])ans--;
        if(!sumc[n])ans--;
        cout<<ans<<endl;return 0;}
    memset(dp,0x7f,sizeof(dp));
    dp[10][suma[10]][sumb[10]][sumc[10]]=0;
    for(i=10;i<=n;i++)
    for(a=0;a<=10;a++)
    for(b=0;b<=10;b++)
    for(c=0;c<=10;c++){
        if(dp[i][a][b][c]>=1000000)continue;//无法到达此状态 返回
        if(i==n){
            ans=3;
            if(!a)ans--;
            if(!b)ans--;
            if(!c)ans--;
            dp[n][0][0][0]=min(dp[n][0][0][0],dp[n][a][b][c]+ans);
            continue;}
               //讨论放手中全部的A,B,C
        if(a){
            tmp=min(n,i+a);//防止越界
            dp[tmp][suma[tmp]-suma[i]][b+sumb[tmp]-sumb[i]][c+sumc[tmp]-sumc[i]]=
            min(dp[tmp][suma[tmp]-suma[i]][b+sumb[tmp]-sumb[i]][c+sumc[tmp]-sumc[i]],dp[i][a][b][c]+1);}
        if(b){
            tmp=min(n,i+b);
            dp[tmp][a+suma[tmp]-suma[i]][sumb[tmp]-sumb[i]][c+sumc[tmp]-sumc[i]]=
            min(dp[tmp][a+suma[tmp]-suma[i]][sumb[tmp]-sumb[i]][c+sumc[tmp]-sumc[i]],dp[i][a][b][c]+1);}
        if(c){
            tmp=min(n,i+c);
            dp[tmp][a+suma[tmp]-suma[i]][b+sumb[tmp]-sumb[i]][sumc[tmp]-sumc[i]]=
            min(dp[tmp][a+suma[tmp]-suma[i]][b+sumb[tmp]-sumb[i]][sumc[tmp]-sumc[i]],dp[i][a][b][c]+1);}}
    cout<<dp[n][0][0][0]<<endl;
return 0;}
```

---

## 作者：Exschawasion (赞：0)

去除掉题目中的无用信息，简明题意如下：

- 存在 $\text{A}$、$\text{B}$、$\text{C}$ 三种物品，同一时刻手上最多拿 $10$ 个物品；
- 按顺序经过所有物品，每个物品有**拿**和**不拿**两种选择；
- 随时可以将手上的某种物品的数量清零（即装箱）；
- 求可能的最少装箱次数。

***

首先考虑如何设计状态。由于物品是排成一行的，故状态可用四元组 $(x_A, x_B, x_C,\text{pos})$ 表示，依次当前手上各类物品的数量和当前处在的位置。

那么可能的状态转移如下：

$$
(x_A,x_B,x_C,\text{pos})
\rightarrow
\begin{cases}
(0, x_B,x_C,\text{pos}) && (\text{清空 A})\\
(x_A,0,x_C,\text{pos}) && (\text{清空 B})\\
(x_A,x_B,0,\text{pos}) && (\text{清空 C})\\
(x_A+1,x_B,x_C,\text{pos} + 1) && (\text{取走 A})\\
(x_A,x_B+1,x_C,\text{pos} + 1) && (\text{取走 B})\\
(x_A,x_B,x_C+1,\text{pos} + 1) && (\text{取走 C})\\
\end{cases}
$$

起始状态：$(0, 0, 0, 1)$。

第一至第三种情况要在对应的 $x$ 大于等于 $0$ 的情况下进行、第四至第六种情况要看第 $\text{pos}$ 个物品的种类进行。

另外，注意到题目中说**顺序从流水线上取 $10$ 个成品**，也就是说，只要**能取**物品就**一定**取，不存在忽略某个物品的情况；对于手上的物品已经达到上限的情况，可以**先清空**手上某类物品的数量，之后再进行。于是可以得到一个性质：最优的策略中**不会放弃任何一个**物品。

依照这个性质不难推出状态转移的边界：当所有物品取尽的时候，手上有多少类物品的数量不为 $0$，便要清零多少次。$\text{pos}$ 会超过 $n$，因为起始状态中 $\text{pos}=1$。所以边界是：当 $pos=n+1$ 时，

$$(x_A, x_B, x_C, \text{pos}) = \text{(A、B、C 中大于 0 的个数)}~~~~ $$

到此，这道题大体上的思路已经清晰了。上面的状态转移方程，很自然地，可以使用**记忆化搜索**来计算。

记忆化搜索在常数上会略慢于循环计算，而且循环计算在某些情况下还能优化；但是，记忆化搜索也有“加速策略”：额外维护“**当前花费**”和“**目前最优**”的信息来剪枝。具体见代码：

```
#include <iostream>

using namespace std;

char typ[105];
int min(int & a, int & b) {
	return a < b ? a : b;
}
int f[15][15][15][105]; // 记忆化表项
int n;
                
int A, B, C, pos; // 对应 (x_A, x_B, x_C, pos) 状态
int cur_cost; // 当前花费
int cur_min = 0x3f3f3f3f; // 目前最优

int dp() {
	int g = (A > 0) + (B > 0) + (C > 0); // A B C 中大于 0 的个数
	if(cur_cost + g > cur_min) return 0x3f3f3f3f; // 剪枝
	if(pos == n + 1) { // 边界
		cur_min = min(cur_min, cur_cost + g);
		return g;
	}
	else {
		if(f[A][B][C][pos]) return f[A][B][C][pos];
		int ret = 0x3f3f3f3f;
		if(A + B + C < 10) { // 能够取物品
			switch(typ[pos]) {
				case 'A': A++; break;
				case 'B': B++; break;
				case 'C': C++; break; 
			}
			pos++;
			ret = min(ret, dp());
			pos--; // 还原 
			switch(typ[pos]) { // 注意：一定要先还原 pos 
				case 'A': A--; break;
				case 'B': B--; break;
				case 'C': C--; break; 
			}
		}
		int bak;
		cur_cost++; // 以下都是清空物品的部分，可以提前增加 cur_cost 
		if(A) { 
			bak = A, A = 0; // 备份之后清空，下同 
			ret = min(ret, dp() + 1); // 清空次数 + 1 
			A = bak;
		}
		if(B) {
			bak = B, B = 0;
			ret = min(ret, dp() + 1);
			B = bak;
		}
		if(C) {
			bak = C, C = 0;
			ret = min(ret, dp() + 1);
			C = bak;
		}
		cur_cost--; // 还原 cur_cost 
		return f[A][B][C][pos] = ret;
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin >> n;
	for(int i = 1; i <= n; i++) cin >> typ[i];
	A = B = C = 0, pos = 1; // 起始状态 
	cout << dp();
	return 0; 
} 
```

这份代码的运行速度是 38ms，空间占用较小。

![](https://i.bmp.ovh/imgs/2022/02/47a42fb78d68c020.png)


大部分动态规划的题目都能用记忆化搜索解决，且记忆化搜索在思路明朗的情况下，代码长度较短较清晰，不失为一种动态规划的解题方式。


---

## 作者：傅思维666 (赞：0)


## 题解：

一道最优化题，而且有状态有转移，我们考虑DP。

特意请教了大佬@JZYShuraK，什么时候我们考虑DP呢？首先是DP计数（数数题恶心得要命）然后是最优化题，尤其是，那种不需要了解过程，只需要输出结果的（比如本题，我们压根不需要知道到底什么时候拿走了什么、多少物品，只需要知道最少拿多少次（即我们要统计的答案））。这个时候可以果断选择DP。

注意到这道题的数据范围：N是1-100的。这个数据范围甚至可以支持我们跑$O(n^4)$的算法，无论是时间复杂度还是空间复杂度都是如此。这道题一开始把我难住的一个点是状态的设置。总觉得怎么设置都很令人不满意。后来终于恍然：一维两维搞不清楚状态，多开几维不就成了？反正空间够用。

那么，我们的状态便设置成：

$dp[i][j][k][m]$表示一共$i$个物品，手中还剩$j$个$A$，$k$个$B$，$m$个$C$时的最小装箱次数。

然后我们考虑初值和答案：因为要求最小值，所以答案显然设置成最大值。特殊地，不难发现，$dp[0][0][0][0]=0$。而根据状态，我们的最终答案就是：$dp[n][0][0][0]$。

接下来就是状态转移了：

在我们设计一个$DP$算法的时候，我们需要牢记：$DP$算法的实质其实是一个决策的过程，也就是说，对于每一个状态和阶段，我们如何去根据具体的情况而选择一个当前情况下的最优决策。而由于$DP$的无后效性的影响，这个决策是不会影响到下一个决策的，也就是说，我们每一次进行决策的时候都选择了最优的一种情况，那么最后的答案显然就是最优的。

那么针对于本题，我们的决策应该是什么呢？

就是：**放还是不放**。即取出来先在手中存着，还是取出来直接放进去。

于是我们就发现，对于第$i$件物品，如果我们存着的话，那么有：
$$
dp[i][j][k][m]=dp[i-1][j-1][k][m]
$$
（此处演示的是第$i$件物品为$A$的情况，其他情况同理）

如果装箱的话：
$$
dp[i][0][k][m]=min(dp[i][0][k][m],dp[i][j][k][m]+1);
$$
（注意，因为我们每次装箱要装进去所有的同种物品，所以第二维是0）

在我们枚举的时候，还要考虑$j+k+m\le 10$。



代码如下：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int n;
int dp[110][11][11][11];
char opt[110];
int main()
{
    memset(dp,0x3f,sizeof(dp));
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        cin>>opt[i];
    dp[0][0][0][0]=0;
    for(int i=1;i<=n;i++)
        for(int j=0;j<=10;j++)
            for(int k=0;k<=10;k++)
                for(int m=0;m<=10;m++)
                {
                    if(j+k+m>10)
                        continue;
                    if(opt[i]=='A' && j)
                        dp[i][j][k][m]=dp[i-1][j-1][k][m];
                    if(opt[i]=='B' && k)
                        dp[i][j][k][m]=dp[i-1][j][k-1][m];
                    if(opt[i]=='C' && m)
                        dp[i][j][k][m]=dp[i-1][j][k][m-1];
                    dp[i][0][k][m]=min(dp[i][0][k][m],dp[i][j][k][m]+1);
                    dp[i][j][0][m]=min(dp[i][j][0][m],dp[i][j][k][m]+1);
                    dp[i][j][k][0]=min(dp[i][j][k][0],dp[i][j][k][m]+1);
                }
    printf("%d",dp[n][0][0][0]);
    return 0;
}
```



---

## 作者：Celebrate (赞：0)

我一开始想到的方程是

dp[i][j][k] 分别表示已经分别做完三种纯度i,j,k个产品的最优解，然后可以推出当前手中的物品，然后记忆化搜索

代码打到一半，发现这样似乎行不通

为什么？因为你怎么推出来，好像确实是退不出来的吧。。。。

于是我偷看了一下题解，就会了

dp的方程一般是不储存以前的状态的，只是记下当前的最优解

那么对当前最重要的就是当前到了第几个，还有手中每种纯度产品的个数

那么方程就是 dp[i][p1][p2][p3] ，代表什么大家应该都清楚吧

下面说一下状态转移的方法

一、手中不足10个
那肯定就是i是什么颜色，就把什么颜色放进去

```cpp
if ( st[i] == 'A' && p1 )
    dp[i][p1][p2][p3] = dp[i-1][p1-1][p2][p3] ;
if ( st[i] == 'B' && p2 ) 
    dp[i][p1][p2][p3] = dp[i-1][p1][p2-1][p3] ;
if ( st[i] == 'C' && p3 ) 
    dp[i][p1][p2][p3] = dp[i-1][p1][p2][p3-1] ;
```
二、手中满十个或者没有剩余

```cpp
dp[i][0][p2][p3] = min ( dp[i][0][p2][p3] , dp[i][p1][p2][p3]+1 ) ;
dp[i][p1][0][p3] = min ( dp[i][p1][0][p3] , dp[i][p1][p2][p3]+1 ) ;
dp[i][p1][p2][0] = min ( dp[i][p1][p2][0] , dp[i][p1][p2][p3]+1 ) ;
```
你可能会问，为什么不用满足手中十个或者没有剩余

如果你加了特判（就像我一开始一样）

```cpp
if ( p1+p2+p3 == 10 || i+p1+p2+p3-1 == 0 )
```
那你一定会错，因为你在dp的过程中无法判断剩余了多少。

这似乎很有道理呢！但是为什么这样不会错呢？

很简单，因为你手中满了十个或者没有剩余才开始装箱肯定是最优的（一次放的多总是会比一次放的少要好吧），所以这样并不会影响结果的正确性，而且可以避免判断是否没有剩余

参考代码

```cpp
#pragma GCC optimize (3)
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
 
using namespace std ;
 
namespace IO {
    inline int read() {
        int x = 0 , f = 0 ; char s = getchar() ;
        while ( !isdigit(s) ) f |= s=='-' , s = getchar() ;
        while (  isdigit(s) ) x = (x<<1)+(x<<3)+(s-48) , s = getchar() ;
        return !f ? x : -x ;
    }
    inline void write(int x) {
        if( x < 0 ) {
            putchar('-') ; x =- x ;
        }
        if(x > 9) write( x/10 ) ;
        putchar( x%10+'0' ) ;
    }
}
using namespace IO ;

const int N = 110 ;
const int MAX = 11 ;

int n , dp[N][MAX][MAX][MAX] ;
char st[N] ;

void init() {
    memset ( dp , 63 , sizeof(dp) ) ; n = read() ; 
    for ( int i = 1 ; i <= n ; i ++ ) 
        cin >> st[i] ;
    dp[0][0][0][0] = 0 ;
}
void solve() {
    for ( int i = 1 ; i <= n ; i ++ ) 
        for ( int p1 = 0 ; p1 <= 10 ; p1 ++ ) 
            for ( int p2 = 0 ; p2 <= 10 ; p2 ++ ) {
                if ( p1 + p2 > 10 ) break ; 
                for ( int p3 = 0 ; p3 <= 10 ; p3 ++ ) {
                    if ( p1+p2+p3 > 10 ) break ;
                    if ( st[i] == 'A' && p1 )
                        dp[i][p1][p2][p3] = dp[i-1][p1-1][p2][p3] ;
                    if ( st[i] == 'B' && p2 ) 
                        dp[i][p1][p2][p3] = dp[i-1][p1][p2-1][p3] ;
                    if ( st[i] == 'C' && p3 ) 
                        dp[i][p1][p2][p3] = dp[i-1][p1][p2][p3-1] ;
                    dp[i][0][p2][p3] = min ( dp[i][0][p2][p3] , dp[i][p1][p2][p3]+1 ) ;
                    dp[i][p1][0][p3] = min ( dp[i][p1][0][p3] , dp[i][p1][p2][p3]+1 ) ;
                    dp[i][p1][p2][0] = min ( dp[i][p1][p2][0] , dp[i][p1][p2][p3]+1 ) ;
                }
            }
}

int main() {
    init() , solve() , write ( dp[n][0][0][0] ) ;
}

```


---

## 作者：circlegg (赞：0)

用数组表示所有的状态，状态为当前拿到了第几个物品，现在手里有A类物品，B类物品，C类物品各几个，所以每次转移都是把一种东西放进去之后再取几件，然后就比较好写了

···

    
    
```cpp
#include<iostream>
#include<cstdio> 
using namespace std;
int n,w[105],f[105][15][15][15],t[4],ans;
int read(){//read函数是对字符进行一下转变，变成数字
    int x;char c=getchar();
    while(c<'A'||c>'C') c=getchar();
    x=c-'A'+1;
    return x;
}
void dp(int cur,int nxt,int a,int b,int c,int k){//cur是当前状态的物品数，nxt转移后的状态的物品数，abc是三种物品在手中的数量，k是要放哪一种物品
    int aa=a,bb=b,cc=c;
    nxt=min(nxt,n);//不能超出
    if(k==1) aa=0;
    else if(k==2) bb=0;
    else if(k==3) cc=0;
    for(int i=cur+1;i<=nxt;i++){
        if(w[i]==1) aa++;
        else if(w[i]==2) bb++;
        else if(w[i]==3) cc++;
    }
    f[nxt][aa][bb][cc]=min(f[nxt][aa][bb][cc],f[cur][a][b][c]+1);//上一个状态的次数再多放一次
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        w[i]=read();
        if(i<=10){
            t[w[i]]++;//先记录前十个物品三种各有几个
        }
    }
    if(n<=10){//小于十个就直接输出
        for(int i=1;i<=3;i++){
            ans+=(t[i]>0?1:0);
        }
        printf("%d\n",ans);
        return 0;
    }
    for(int i=0;i<=n;i++){
        for(int j=0;j<=10;j++){
            for(int k=0;k<=10;k++){
                for(int l=0;l<=10;l++){
                    f[i][j][k][l]=(1<<30);//初始化
                }
            }
        }
    }
    f[10][t[1]][t[2]][t[3]]=0;//初状态为零次， i<=10&&j<=t[1]&&k<=t[2]&&l<=t[3] 的状态不变为零，因为这些状态一定不是最优，所以不必初始化
    for(int i=10;i<=n;i++){
        for(int j=0;j<=10;j++){
            for(int k=0;k<=10;k++){
                for(int l=0;l<=10;l++){
                    if(f[i][j][k][l]!=(1<<30)){//如果这个状态可以转移
                        if(j>0){
                            dp(i,i+j,j,k,l,1);//分别尝把每一种物品放回去进行状态进行转移
                        }
                        if(k>0){
                            dp(i,i+k,j,k,l,2);
                        }
                        if(l>0){
                            dp(i,i+l,j,k,l,3);
                        }
                    }
                }
            }
        }
    }
    ans=(1<<30);
    for(int j=0;j<=10;j++){
        for(int k=0;k<=10;k++){
            for(int l=0;l<=10;l++){
                ans=min(ans,f[n][j][k][l]+(j>0?1:0)+(k>0?1:0)+(l>0?1:0));//在所有已经取了n个物品的状态里取最小值
            }
        }
    }
    printf("%d\n",ans);
    return 0; 
}
···
```

---

## 作者：Lin1043 (赞：0)

#动态规划部分

定义 **f[i][A][B][C] 为前i个中 A种有A个 B种有B个 C种有C个 所需最小的操作次数**

那么每一次操作可以将 目前的A种或B种或C种的物品全部移除

那么 f[i+A][A'][B'][C] f[i+B][A'][B'][C'] f[i+C][A'][B'][C'](A' B' C'分别代表在i+1~i+(A或B或C)中 A或B或C的值) \_就是我的代码中的 grant函数\_

均可以由f[i][A][B][C]推得 然后对每一项求得最小操作次数

当i=n时 f[n][A][B][C]=f[n][A][B][C]+ A>0+ B>0+ C>0

再在 f[n][j][k][l]中求最小值即为\_ans \_


###以下为代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=105,INF=1<<30-1;
int f[maxn][11][11][11],a[maxn],n,p[4],ans=INF;
char c;
inline int cacl(char c)
{
    if(c=='A')return 1;
    else if(c=='B')return 2;
    else if(c=='C')return 3;
}
inline void grant(int x,int y,int A,int B,int C,int k)
{
    
    int A1=A,B1=B,C1=C;y=min(y,n);
    if(k==1)A1=0;else if(k==2)B1=0;else C1=0;//对一种物品进行操作
    for(int i=x+1;i<=y;i++){//分别记录A',B',C'的值
        if(a[i]==1)A1++;
        else if(a[i]==2)B1++;
        else if(a[i]==3)C1++;
    }
    f[y][A1][B1][C1]=min(f[x][A][B][C]+1,f[y][A1][B1][C1]);//找最小的次数达到此状态
}
inline void inti()
{
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>c;
        a[i]=cacl(c);//将字符改为数字 虽然并没起到什么帮助
        if(i<=10)p[a[i]]++;//记录数字1 2 3的个数
    }
    if(n<=10){//在n<=10的时候特判然后对每种颜色均操作一次 否则无法计算
    cout<<(int)(p[1]>0)+(int)(p[2]>0)+(int)(p[3]>0)<<endl;
    exit(0);}
    for(int i=0;i<=n;i++)
     for(int j=0;j<=10;j++)
      for(int k=0;k<=10;k++)
       for(int l=0;l<=10;l++)
        f[i][j][k][l]=INF;//数组初始化 均设置为不可到达
    f[10][p[1]][p[2]][p[3]]=0;//起点总次数为0
}
inline void dp()
{
    for(int i=10;i<=n;i++)
     for(int j=0;j<=10;j++)
      for(int k=0;k<=10;k++)
       for(int l=0;l<=10;l++)
       if(f[i][j][k][l]!=INF){//枚举f[i][j][k][l]找到可以推得的状态
           if(j)grant(i,i+j,j,k,l,1);//如果A还有剩余则取光A 下同上
           if(k)grant(i,i+k,j,k,l,2);
           if(l)grant(i,i+l,j,k,l,3);
       }
    for(int j=0;j<=10;j++)
     for(int k=0;k<=10;k++)
      for(int l=0;l<=10;l++)
       ans=min(ans,f[n][j][k][l]+(int)(j>0)+(int)(k>0)+(int)(l>0));//对于每一个已经没有物品在流水线上的状态 只需每种均操作一次即可
}
int main()
{
    inti();//输入
    dp();//dp主程序
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：远航之曲 (赞：0)

动态规划。

dp[i][j][k][l]表示拿走前i个，A、B、C分别剩下j、k、l个的最小装箱次数。

用它刷表，分别考虑把A、B、C全拿走。

具体方程见代码。

最后的答案是在所有dp[n]里找最小值，注意剩下的也要算到次数里。

特判n<10的情况。

注意最后剩余不足10个的情况。


代码如下


                
                
                
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
int n,a[200],f[120][10][10][10],a1,a2,a3;
char c;
main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
    {
        cin>>c;
        if (c=='A')
            a[i]=1;
        else if (c=='B')
            a[i]=2;
        else
            a[i]=3;
    }
    for (int i=1;i<=min(10,n);i++)
        if (a[i]==1)
            a1++;
        else if (a[i]==2)
            a2++;
        else
            a3++;
    if (n<=10)
    {
        printf("%d",(a1>0)+(a2>0)+(a3>0));
        return 0;
    }
    memset(f,-1,sizeof f);
    int x,y,z,nn;
    f[10][a1][a2][a3]=0;
    for (int i=10;i<=n;i++)
        for (int j=0;j<=10;j++)
            for (int k=0;k<=10;k++)
            {
                int l=10-j-k;
                if (f[i][j][k][l]==-1) continue;
                x=0,y=k,z=l,nn=i+j;
                if (nn>n) nn=n;
                for (int ii=i+1;ii<=nn;ii++)
                    if (a[ii]==1)
                        x++;
                    else if (a[ii]==2)
                        y++;
                    else
                        z++;
                if (f[nn][x][y][z]==-1) f[nn][x][y][z]=0x3f3f3f3f;
                f[nn][x][y][z]=min(f[nn][x][y][z],f[i][j][k][l]+1);
                x=j,y=0,z=l,nn=i+k;
                if (nn>n) nn=n;
                for (int ii=i+1;ii<=nn;ii++)
                    if (a[ii]==1)
                        x++;
                    else if (a[ii]==2)
                        y++;
                    else
                        z++;
                if (f[nn][x][y][z]==-1) f[nn][x][y][z]=0x3f3f3f3f;
                f[nn][x][y][z]=min(f[nn][x][y][z],f[i][j][k][l]+1);
                x=j,y=k,z=0,nn=i+l;
                if (nn>n) nn=n;
                for (int ii=i+1;ii<=nn;ii++)
                    if (a[ii]==1)
                        x++;
                    else if (a[ii]==2)
                        y++;
                    else
                        z++;
                if (f[nn][x][y][z]==-1) f[nn][x][y][z]=0x3f3f3f3f;
                f[nn][x][y][z]=min(f[nn][x][y][z],f[i][j][k][l]+1);
            }
            int ans=0x7fffffff;
            for (int i=0;i<=10;i++)
                for (int j=0;j<=10;j++)
                    for (int k=0;k<=10;k++)
                        if (f[n][i][j][k]!=-1)
                            ans=min(ans,f[n][i][j][k]+(i>0)+(j>0)+(k>0));
            printf("%d",ans);
}
```

---

## 作者：Zoewilly (赞：0)

DP不用说，因为物品只有三种，而且手中最多有10个物品，所以考虑手中物品各多少时所装箱的最少的次数，所以设立状态f[i,j,k,l]表示前i个物品，手中A有j个，手中B有k个，手中C有l个的最小装箱次数，那么决策就考虑在这个状态时，可以推到哪些状态，比如说把A全部装进去，那么f[i,j,k,l]+1=f[i+j,0,k,l]，因为把A都装进去了，所以A就是0了，同样B和C也是这么推的，最后在f[n,i,j,k]找个最小就可以了。



代码：

    
    


    
```cpp
var
    a                            :array[0..105] of longint;
    s                            :array[1..3] of longint;
    ch                            :char;
    f                            :array[0..105,-20..10,-20..10,-20..10] of longint;
    i,j,k,l,m,n,ans,x,y,z,nn,ii    :longint;
function min(x,y:longint):longint;
begin
    if x>y then exit(y) else exit(x);
end;
procedure init1;
begin
    x:=0; y:=k; z:=l; nn:=i+j;
    if nn>n then nn:=n;
    for ii:=i+1 to nn do
    begin
        if a[ii]=1 then inc(x);
        if a[ii]=2 then inc(y);
        if a[ii]=3 then inc(z);
    end;
    if f[nn,x,y,z]=-1 then f[nn,x,y,z]:=maxlongint;
    f[nn,x,y,z]:=min(f[nn,x,y,z],f[i,j,k,l]+1);
end;
procedure init2;
begin
    x:=j; y:=0; z:=l; nn:=i+k;
    if nn>n then nn:=n;
    for ii:=i+1 to nn do
    begin
        if a[ii]=1 then inc(x);
        if a[ii]=2 then inc(y);
        if a[ii]=3 then inc(z);
    end;
    if f[nn,x,y,z]=-1 then f[nn,x,y,z]:=maxlongint;
    f[nn,x,y,z]:=min(f[nn,x,y,z],f[i,j,k,l]+1);
end;
procedure init3;
begin
    x:=j; y:=k; z:=0; nn:=i+l;
    if nn>n then nn:=n;
    for ii:=i+1 to nn do
    begin
        if a[ii]=1 then inc(x);
        if a[ii]=2 then inc(y);
        if a[ii]=3 then inc(z);
    end;
    if f[nn,x,y,z]=-1 then f[nn,x,y,z]:=maxlongint;
    f[nn,x,y,z]:=min(f[nn,x,y,z],f[i,j,k,l]+1);
end;
begin
    readln(n);
    for i:=1 to n do
    begin
        readln(ch);
        a[i]:=ord(ch)-64;
        if i<=10 then inc(s[a[i]]);
    end;
    if n<=10 then
    begin
        for i:=1 to 3 do if s[i]>0 then inc(ans);
        writeln(ans);
        halt;
    end;
    for i:=0 to 105 do
    for j:=-20 to 10 do
    for k:=-20 to 10 do
    for l:=-20 to 10 do f[i,j,k,l]:=-1;
    f[10,s[1],s[2],s[3]]:=0;
    for i:=10 to n do
    for j:=0 to 10 do
    for k:=0 to 10 do
    begin
        l:=10-j-k;
        if f[i,j,k,l]<0 then continue;
        init1;
        init2;
        init3;
    end;
    ans:=maxlongint;
    for i:=0 to 10 do
    for j:=0 to 10 do
    for k:=0 to 10 do
    begin
        if f[n,i,j,k]=-1 then continue;
        nn:=0;
        if i<>0 then inc(nn);
        if j<>0 then inc(nn);
        if k<>0 then inc(nn);
        ans:=min(ans,f[n,i,j,k]+nn);
    end;
    writeln(ans);
end.

```

---


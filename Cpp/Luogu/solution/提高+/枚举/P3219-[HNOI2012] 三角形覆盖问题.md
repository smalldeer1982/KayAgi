# [HNOI2012] 三角形覆盖问题

## 题目描述

二维平面中，给定 $N$ 个等腰直角三角形（每个三角形的两条直角边分别平行于坐标轴，斜边从左上到右下）。我们用三个非负整数 $(x,y,d)$ 来描述这样一个三角形，三角形三个顶点的坐标分别为 $(x,y)$，$(x+d,y)$ 和 $(x,y+d)$。要求计算这 $N$ 个三角形所覆盖的总面积。例如，下图有 $3$ 个三角形，覆盖的总面积为 $11.0$。

![](https://cdn.luogu.com.cn/upload/image_hosting/1459ccln.png)

## 说明/提示

对于 $50\%$ 的数据，$1 \le N \le 500$；\
对于 $100\%$ 的数据，$1 \le N \le 10^4$。

## 样例 #1

### 输入

```
3
1 1 4
2 0 2
3 2 2```

### 输出

```
11.0```

# 题解

## 作者：ezoixx118 (赞：6)

### 题意
（很好理解吧qaq）  
给一堆等腰三角形，求面积并 
### 前言
这题最快有$O(n\log(n))$的做法，用到平衡树，可查阅[这位dalao题解](https://www.cnblogs.com/vecd/p/3464409.html)  
其他dalao们的做法都是$O(n^2)$加玄学优化的  
由于数据水，我这个蒟蒻只会以下这种水法。。。  
### 题解
从下往上扫描线（可一格一格地扫），当前要计算的面积就是一堆梯形，它会由斜边产生缺口（即上底比下底短）。可以把它们合起来算，记录 下底长之和 和 缺口大小（上下底的差） 即可更新答案。  
  
扫到一个新的三角形，枚举其斜边整点，更新数据。（具体更新方法请见代码）
  
时间复杂度$O(\sum d)=O(n\times d)$  
~~我也不知道怎么过的，反正就是过了。。。~~  
最慢（#10）143ms
### 代码
```cpp
#include<bits/stdc++.h>
#define db double
#define ll long long
#define inf 1000009
#define eps 1e-11
#define INF 1e11
#define rd(n) {n=0;char ch;int f=0;do{ch=getchar();if(ch=='-'){f=1;}}while(ch<'0'||ch>'9');while('0'<=ch&&ch<='9'){n=(n<<1)+(n<<3)+ch-48;ch=getchar();}if(f)n=-n;}
using namespace std;

int n;
int x[inf],d[inf];
int s[inf],mx[inf];
/*s[i]表示第i行梯形上底与下地之差*/
/*mx[i]表示当前第i列的最高点y值*/
vector <int> pos[inf];


int main(){
    rd(n)
    int y,maxy=0;
    for (int i=1;i<=n;i++){
        rd(x[i]) rd(y) rd(d[i])
        pos[y].push_back(i);
        maxy=max(maxy,y+d[i]);
    }
    ll ans=0;
    int now=0;//now是当前行下底长
    for (int i=0;i<=maxy;i++){
        ans+=(ll)(now*2-s[i]);
        now-=s[i];
        int cnt=pos[i].size();
        for (int j=0;j<cnt;j++){
            int id=pos[i][j];
            for (int k=0;k<d[id];k++){
                if (i+d[id]-k>mx[x[id]+k]){
                    if (mx[x[id]+k]<=i){
                        now++;
                    }
/*若当前列旧的最高点小于当前，而现在在此列增加了更高的三角形，下一行的梯形的下底会加大一格*/
                    s[mx[x[id]+k]]--;
/*旧的缺口被填上，在更高点产生新的缺口*/                    
                    mx[x[id]+k]=i+d[id]-k;
                    s[mx[x[id]+k]]++;
                }
            }
        }
    }
    printf("%.1lf\n",(db)ans/2.0);
    return 0;
}
```

---

## 作者：totorato (赞：6)

# 扫描线
一个较为简单的想法就是按照一定方向将所有的三角形的并分解成若干段可以轻松求解的梯形的面积。

但是分解的段数与三角形数同阶(甚至更大)，而求解每个梯形的上下底面积又需要$O(n)$的时间复杂度，所以这样做很容易就超时了。

因此我们需要用一些手段使复杂度降下来。
-	1.尽量少分段
-	2.扫描过程中尽量可以使用上一次扫描得到的结果
-	3.删除没有意义的三角形

而具体的做法就是：先将所有三角形按照直角顶点的x坐标排序，从左到右扫描。这时，所有的三角形都会与扫描线相交形成一些线段，扫描线向右平移，原有的线段变短，添加新的线段。

实际上，我们只需要知道扫描线在以下几种情况下覆盖它的线段长度即可用数学方法求出精确的面积。
-	新遇到一个三角形之前后
-	一个三角形结束时
-	两条有重合部分的线段由于缩短而分开时

这样，我们依然无法通过本题，因为我们还没有"删除没有意义的三角形"，这时的时间复杂度依旧很高。

当扫描线上相交的两条线段互相包含时，被包含的可以被删除。因此就有了以下的算法：

```cpp
#include <bits/stdc++.h>
#define MX 20005

using namespace std;

typedef pair<int,int> pii;

int app[MX],anum;
int tri[MX][3];
int n;

int cmp(const void *a,const void *b)
{
	return ((int*)a)[0]-((int*)b)[0];
}

void input()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d",&tri[i][0],&tri[i][1],&tri[i][2]);
		app[++anum]=tri[i][0];
		app[++anum]=tri[i][0]+tri[i][2];
	}
	qsort(tri+1,n,sizeof(tri[0]),cmp);
	sort(app+1,app+anum+1);
	anum=unique(app+1,app+anum+1)-app-1;
}

pii seg[MX],nxt[MX];
int top;

void advance(int dx)		//扫描线向右平移dx的距离
{
	int rmost=-1,ntop=0;
	for(int i=1;i<=top;i++)
	{
		if((seg[i].second-=dx)<=0)continue;
		int rpos=seg[i].first+seg[i].second;
		if(rpos>rmost)
		{
			rmost=rpos;
			nxt[++ntop]=seg[i];	//只保留没有被包含的线段
		}
	}
	swap(nxt,seg);
	top=ntop;
}

int callen()			//询问当前扫描线被覆盖的长度
{
	int rmost=-1,len=0;
	for(int i=1;i<=top;i++)
	{
		int rpos=seg[i].first+seg[i].second;
		if(rpos>rmost)
		{
			if(seg[i].first>rmost)len+=seg[i].second;
			else len+=rpos-rmost;
			rmost=rpos;
		}
	}
	return len;
}

int calstep()			//询问扫描线向右平移多长后会有两条相交的线段分开
{
	int rmost=-1,step=2000000;
	for(int i=1;i<=top;i++)
	{
		int rpos=seg[i].first+seg[i].second;
		if(seg[i].first<rmost)step=min(step,rmost-seg[i].first);
		if(rpos>rmost)rmost=rpos;
	}
	return step;
}

void work()
{
	double area=0;
	int nowx=0,nowp=1;
	app[anum+1]=2e6;
	while(nowx<=app[anum])
	{
		int f=0;
		while(tri[nowp][0]==nowx)
		{
			f=1;
			seg[++top]=make_pair(tri[nowp][1],tri[nowp][2]);
			nowp++;
		}
		if(f)sort(seg+1,seg+top+1);
		
		int nxtx=nowx+calstep();
		int temp=upper_bound(app+1,app+anum+1,nowx)-app;
		nxtx=min(nxtx,app[temp]);
		
		int nowa=callen();
		advance(nxtx-nowx);
		int nxta=callen();
		
		area+=0.5*(nowa+nxta)*(nxtx-nowx);
		nowx=nxtx;
	}
	printf("%.1lf\n",area);
}

int main()
{
	input();
	work();
	return 0;
}
```

---

## 作者：RockyYue (赞：4)

感谢管理大大审核~

# 解题思路

水题，暴力都能 AC...

首先扫描所有格，我们可以把所有三角形（包括完整的三角形和和其它三角形重叠的）都看成梯形处理。

我们枚举下梯形斜边上的所有整点，算出所有梯形面积即可。

# 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e6 + 5;
int x[N], m[N], cnt[N], maxx[N];
vector<int> line[N];
int main() {
	ios :: sync_with_stdio(0);
	int n, maxy = -1;
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		int y;
		cin >> x[i] >> y >> m[i];
		maxy = max(maxy, y + m[i]);
		line[y].push_back(i);
	}
    int diff = 0;
    long long res = 0;
    for (int i = 0; i <= maxy; ++i) {
		res += 1ll * ((diff << 1) - cnt[i]);
		diff -= cnt[i];
		for (auto& idx: line[i]) {
			for (int j = 0; j < m[idx]; ++j) {
				#define X maxx[x[idx] + j]
				int t = m[idx] + i - j;
				if (t > X) {
					diff += X <= i;
					--cnt[X];
					++cnt[X = t];
				}
			}
		}
	}
	cout << fixed << setprecision(1) << res / 2.0 << '\n';
    return 0;
}
```


---

## 作者：辰星凌 (赞：4)

# **【题解】三角形 [P1222] / 三角形覆盖问题 [HNOI2012] [P3219]**

[$\mathcal{My}\ \mathcal{Blog}$](https://www.cnblogs.com/Xing-Ling/p/12109838.html)

传送门：

- [三角形 $\text{[P1222]}$](https://www.luogu.com.cn/problem/P1222)  

- [三角形覆盖问题 $\text{[HNOI2012] [P3219]}$](https://www.luogu.com.cn/problem/P3219)  

## **【题目描述】**

给出 $n$ 个等腰直角三角的顶点和直角边长，求覆盖总面积。

## **【分析】**

[【计算几何全家桶】](https://www.luogu.com.cn/blog/ChenXingLing/post-xue-xi-bi-ji-ji-suan-ji-he-quan-jia-tong)

求三角形面积并的板题。

自适应辛普森法乱搞（什么？你说 [三角形覆盖问题](https://www.luogu.com.cn/problem/P3219) 用辛普森过不了？~~啪~~）。

代码大致和 [圆的面积并](https://www.luogu.com.cn/blog/ChenXingLing/solution-sp8073) 相同，只需要改几个关键点即可：

$F$ 函数中求交线（相较于圆变简单了）：

```cpp
#define LD double
#define Re register int
#define Rd register LD
Re t=0;
for(Re i=1;i<=n;++i)
    if(dcmp(Y-C[i].D)>=0&&dcmp(Y-C[i].U)<0){//如果直线Y与三角形相交
        Rd tmp=C[i].U-Y;//交线长度
        if(dcmp(tmp)>0)Seg[++t]=Segment(C[i].x,C[i].x+tmp);//储存交线
    }
```

判断小三角形是否被大三角形所包含：

```cpp
inline int TIT(Triangle A,Triangle B){//判断三角形A是否在三角形B以内
    return A.L>=B.L&&A.R<=B.R&&A.D>=B.D&&A.U<=B.U&&dcmp(A.R-(B.x+B.U-A.y))<=0;
}
```

完了？

...

$\text{WA}$ 了！

为什么？

在用辛普森求平面图形面积时，如果对象是圆，那么一定不可能一次性满足精度要求（误差极大），但如果是三角形的话很可能**一次计算就结束了递归**。

看下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/7ww1ev0o.png)

对于第一次递归求解 $(l,r)$，用公式计算 $now=Simpson(l,r),FL=Simpson(l,mid),FR=Simpson(mid,r)$ 时使用了上图中的 $5$ 条横线，发现它们都没有经过左边的小三角形，而此时 $now,FL,FR$ 都是算的大三角形的**准确面积**，所以**递归会直接终止**，最终只返回了大三角形的面积，小三角形被忽略。

为什么算 圆面积并 时没有出现这种问题呢？前面说了 计算对象为圆时不可能一次性满足精度要求，也就是说必定会递归扫描到各个位置，不会存在漏掉某一小块的情况。

解决方案（该思路来自 [$\text{Edgration}$ 巨佬](https://www.luogu.com.cn/blog/Edgration/solution-p1222) ）：

记录所有的 $y,y+m$ 并排序去重，对于所有相邻两端点所围住的范围单独处理。如下图，分别递归计算 $(Y_1,Y_2),(Y_2,Y_3),(Y_3,Y_4)$ 三块并求和。

![](https://cdn.luogu.com.cn/upload/image_hosting/di5coqte.png)

精度！精度！！！

[三角形](https://www.luogu.com.cn/problem/P1222) 开 $1e\!-\!9$，[三角形覆盖问题](https://www.luogu.com.cn/problem/P3219) 开 $1e\!-\!10$ 。

~~调参调出了写模拟退火的感觉~~

## **【Code】**

```cpp
#pragma GCC optimize(3,"Ofast","inline")
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<map>
#define LD double
#define LL long long
#define Re register int
#define Rd register LD
#define Vector Point
using namespace std;
const int N=10003;
const LD eps=1e-10;
int n,m;map<LD,LD>vis;
inline int dcmp(Rd a){return a<-eps?-1:(a>eps?1:0);}
struct Point{
    LD x,y;Point(LD X=0,LD Y=0){x=X,y=Y;}
    inline void in(){scanf("%lf%lf",&x,&y);}
};
struct Segment{
    LD L,R;Segment(LD l=0,LD r=0){L=l,R=r;}
    inline bool operator<(Segment O)const{return L!=O.L?L<O.L:R<O.R;}
}Seg[N];
struct Triangle{
	LD x,y,m,L,R,D,U;
	inline void in(){scanf("%lf%lf%lf",&x,&y,&m),L=x,R=x+m,D=y,U=y+m;}
}C[N],C_[N];
inline bool cmp(Triangle A,Triangle B){return A.m<B.m;}//按直角边长排序
inline LD F(Rd Y){
    if(vis[Y])return vis[Y];
    Re t=0;Rd ans=0;
    for(Re i=1;i<=n;++i)
        if(dcmp(Y-C[i].D)>=0&&dcmp(Y-C[i].U)<0){//如果直线Y与三角形相交
            Rd tmp=C[i].U-Y;//交线长度
            if(dcmp(tmp)>0)Seg[++t]=Segment(C[i].x,C[i].x+tmp);//储存交线
        }
    if(!t)return 0.0;
    sort(Seg+1,Seg+t+1);
    for(Re i=1,j;i<=t;i=j+1){
        Rd L=Seg[i].L,R=Seg[i].R;j=i;
        while(j<t&&Seg[j+1].L<=R)++j,R=max(R,Seg[j].R);
        ans+=R-L;
    }
    return vis[Y]=ans;
}
inline LD Simpson(Rd L,Rd R){return (R-L)*(F(L)+4.0*F((L+R)*0.5)+F(R))/6.0;}
inline LD sakura(Rd L,Rd R,Rd now){
    Rd mid=(L+R)*0.5,FL=Simpson(L,mid),FR=Simpson(mid,R);
    if(!dcmp(now-FL-FR))return now;
    return sakura(L,mid,FL)+sakura(mid,R,FR);
}
inline int TIT(Triangle A,Triangle B){//判断三角形A是否在三角形B以内
    return A.L>=B.L&&A.R<=B.R&&A.D>=B.D&&A.U<=B.U&&dcmp(A.R-(B.x+B.U-A.y))<=0;
}
LD ans,YY[N<<1];
int main(){
//  freopen("456.txt","r",stdin);
    scanf("%d",&m);Re t=0;
    for(Re i=1;i<=m;++i)C_[i].in();
    sort(C_+1,C_+m+1,cmp),C[++n]=C_[m];//按半径大小排序
    for(Re i=m-1;i>=1;--i){
        Re flag=1;
        for(Re j=1;j<=n&&flag;++j)if(TIT(C_[i],C[j]))flag=0;
        if(flag)C[++n]=C_[i];
    }
    for(Re i=1;i<=n;++i)YY[++t]=C[i].D,YY[++t]=C[i].U;
    sort(YY+1,YY+t+1);
    for(Re i=2;i<=t;++i)//若干个小块分别处理
        if(dcmp(YY[i]-YY[i-1])>0){
            Rd D=YY[i-1],U=YY[i]-2*eps;//这里必须要偏移边界，否则会死得非常难看
            ans+=sakura(D,U,Simpson(D,U));
        }
    printf("%.1lf",ans);
}
```


---

## 作者：zzw4257 (赞：3)

事实上可以真的扫描线，具体来说我们从左往右考虑竖直截断面的情况，对每个三角形独立观察，则有其在时间轴上形成一个从某时刻产生，每个时刻比上一个时刻上端点下移一维直到消失的变化的线段。

将三角形同时嵌入后容易发现随着截断面的右移，线段并的变化绝大多数时刻呈现线段并中每个连通分量上端点下移的情况，我们称此为规则变化，假设我们获悉时间段 $[t_1,t_2]$ 上线段并呈现规则变化，则可以通过获取 $t_1$ 时刻线段并长度然后用梯形面积公式 $\frac{[t_1+(t_1-(t_2-t_1))](t_2-t_1+1)}{2}$ 计算贡献。

我们只需要处理规则变化的时刻分界线，容易发现只有 插入新线段(即扫到某个三角形的左边界) / 删除线段(即扫到某个三角形的右边界) / 分裂两条线段 三种情况。

这样依旧不好处理，紧接着注意到具有相互包含关系的线段显然只需保留长度较大的一条，因此每个时刻存在的线段只有相交相离关系，可以以任意一维端点为键值使用 set 维护。

插入线段时可以暴力删除所有包含线段，然后时刻维护相邻两条线段的交的大小集合，就可以求出下一次变化是 插入/删除/分裂 中的哪一种，注意到一次插入操作最多带来一次删除操作(无论是到右端点删还是因被包含删)，三次新的分裂操作，因此总操作次数是 $\mathcal O(n)$ 的，总复杂度为 $\mathcal O(n\log n)$。

---

## 作者：skkkh (赞：3)

严格单 $\log$ 做法，附实现细节和代码。
---

考虑从左往右扫描线，发现每次操作是线段上端点 $-1$，插入线段，删除退化成点的线段。

如果某时刻一条线段被另一条完全覆盖，那么这条线段显然不会产生贡献，可以删去。最后得到的线段一定是左端点单调递增时，右端点也单调递增，可以用 set 维护。

当两线段相交时，下方线段上端点的改变并不会影响总覆盖长度。于是想到用小根堆维护相交区域，当有相交区域缩小至 $0$ 时删去。每次更新长度时减少的就是 set 的 $size$ 减去堆的 $size$。

删除是平凡的。插入时，若线段被已有线段包含，则不需插入。否则，将它包含的线段及其之间的交从 set 和堆中删去，并将中间未被覆盖的区域贡献到当前长度。最后再将其与上/下线段之间的交更新。

时间复杂度分析：set 和堆插入删除都是 $O(\log{N})$ 的，初始和结束时两者皆空。插入一条线段时最多在 set 和堆中加入三个元素（线段本身及其与上下线段的交）。因此只有 $O(N)$ 个元素被插入删除，总复杂度 $O(N\log{N})$。

### 实现细节：

+ 因为堆不支持直接删除，可以使用懒标记，对于每一条线段记录与上方线段的交的编号，在取堆顶元素时判一下即可。因为懒标记，所以不能用 `q.size()` 直接得到堆中元素个数，要另外记录。

+ 对于线段上端点整体 $-1$ 的情况，虽然纵坐标改变，但横坐标+纵坐标的值不变，可以用此值比较右端点大小。堆中也可用此方法判断线段的交是否已退化成点。

+ 虽然结果在 int 范围内，但计算梯形面积时可能会爆，要开 long long。

+ corner case 很多，要小心 RE 和 边界条件。

最后附上丑陋的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=50005;
#define int long long
int n,num,l[N],cnt; bool v[N*3],vl[N];
int id[N*2];
struct tri{
	int x,y,l;
	bool operator<(const tri &a)const{return x<a.x;}
}t[N];
struct len{
	int x,id;
	bool operator<(const len &a)const{return x>a.x||x==a.x&&id<a.id;}
};
struct seg{
	int y,z,id;
	bool operator<(const seg &a)const{return y<a.y||y==a.y&&z<a.z;}
};
set<seg> s;
priority_queue<len> q;
vector<len> op[N*2];
set<seg>::iterator it,itl;

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0); cin>>n;
	for(int i=1;i<=n;i++){
		cin>>t[i].x>>t[i].y>>t[i].l;
		id[i*2-1]=t[i].x,id[i*2]=t[i].x+t[i].l;
	}int x,xl,zl,qc=0;
	sort(t+1,t+n+1); sort(id+1,id+n*2+1); cnt=unique(id+1,id+n*2+1)-(id+1);
	for(int i=1;i<=n;i++){
		x=lower_bound(id+1,id+cnt+1,t[i].x)-id; op[x].push_back({1,i});
		x=lower_bound(id+1,id+cnt+1,t[i].x+t[i].l)-id; op[x].push_back({-1,i});
	}v[0]=1;
	int nx=-2e9,ny=0,px,py=0,ans=0;
	for(int i=1;i<=cnt;i++){
		while(q.size()&&v[q.top().id]) q.pop();
		while(q.size()&&q.top().x<=id[i]){
			px=nx; nx=q.top().x;
			py=ny; ny-=(nx-px)*(s.size()-qc); 
			if(px!=-2e9) ans+=(py+ny)*(nx-px);
			while(q.size()&&(q.top().x==nx||v[q.top().id])){
				if(!v[q.top().id]) qc--; v[q.top().id]=1; q.pop();
			}
		}
		px=nx; nx=id[i];
		py=ny; ny-=(nx-px)*(s.size()-qc);
		if(px!=-2e9) ans+=(py+ny)*(nx-px);
		for(int j=0;j<op[i].size();j++){
			x=op[i][j].id;
			if(op[i][j].x==-1&&!vl[x]){
				it=s.find({t[x].y,t[x].x+t[x].y+t[x].l}); s.erase(it);
			}
			else if(!vl[x]){
				it=s.lower_bound({t[x].y,-2000000000,-2000000000});
				if(it!=s.begin()){
					if(it!=s.end()){itl=it;itl--;
						if((*itl).y<=t[x].y&&(*itl).z>=t[x].x+t[x].y+t[x].l){vl[x]=1;continue;}
						if((*it).y<=t[x].y&&(*it).z>=t[x].x+t[x].y+t[x].l){vl[x]=1;continue;}
						if(!v[l[(*itl).id]])qc--;v[l[(*itl).id]]=1;
						if((*it).z<=t[x].x+t[x].y+t[x].l)ny+=max(min(id[i]+t[(*it).id].y-(*itl).z,t[(*it).id].y-t[x].y),0ll);
						else{
							ny+=t[x].l; ny-=min(max(t[x].x+t[x].y+t[x].l-id[i]-t[(*it).id].y,0ll)+max((*itl).z-t[x].x-t[x].y,0ll),t[x].l);
						}
						while(it!=s.end()&&(*it).z<=t[x].x+t[x].y+t[x].l){
							xl=(*it).id,vl[xl]=1;zl=(*it).z; it++; if(!v[l[xl]])qc--; v[l[xl]]=1;
							if(it!=s.end()&&(*it).z<=t[x].x+t[x].y+t[x].l) ny+=max(t[(*it).id].y+id[i]-zl,0ll);
							else if(it!=s.end()) ny+=max(min(id[i]+t[(*it).id].y-zl,t[x].x+t[x].y+t[x].l-zl),0ll);
							else ny+=t[x].x+t[x].y+t[x].l-zl; it--; it=s.erase(it);
						}
						if((*itl).z>t[x].x+t[x].y){
							num++,l[(*itl).id]=num,q.push({id[i]+(*itl).z-t[x].x-t[x].y,num}),qc++;
						}
						if(it!=s.end()&&t[x].x+t[x].y+t[x].l>id[i]+t[(*it).id].y){
							num++,l[x]=num,q.push({id[i]+t[x].x+t[x].y+t[x].l-id[i]-t[(*it).id].y,num}),qc++;
						}
					}
					else{itl=it; itl--;
						if((*itl).z>=t[x].x+t[x].y+t[x].l){vl[x]=1;continue;}ny+=t[x].l;
						if((*itl).z>t[x].x+t[x].y){
							num++,l[(*itl).id]=num,q.push({id[i]+(*itl).z-t[x].x-t[x].y,num}),qc++; ny-=(*itl).z-t[x].x-t[x].y;
						}
					}
				}
				else{
					if(it!=s.end()&&(*it).y<=t[x].y&&(*it).z>=t[x].x+t[x].y+t[x].l){vl[x]=1;continue;}
					if(it==s.end()) ny+=t[x].l;
					else if((*it).z>t[x].x+t[x].y+t[x].l){
						ny+=t[x].l; ny-=max(t[x].x+t[x].y+t[x].l-id[i]-t[(*it).id].y,0ll);
					}
					else ny+=t[(*it).id].y-t[x].y; 
					while(it!=s.end()&&(*it).z<=t[x].x+t[x].y+t[x].l){
						xl=(*it).id,vl[xl]=1;zl=(*it).z; it++; if(!v[l[xl]])qc--; v[l[xl]]=1;
						if(it!=s.end()&&(*it).z<=t[x].x+t[x].y+t[x].l) ny+=max(t[(*it).id].y+id[i]-zl,0ll);
						else if(it!=s.end()) ny+=max(min(id[i]+t[(*it).id].y-zl,t[x].x+t[x].y+t[x].l-zl),0ll);
						else ny+=t[x].x+t[x].y+t[x].l-zl; it--; it=s.erase(it);
					}
					if(it!=s.end()&&t[x].x+t[x].y+t[x].l>id[i]+t[(*it).id].y){
						num++,l[x]=num,q.push({id[i]+t[x].x+t[x].y+t[x].l-id[i]-t[(*it).id].y,num}),qc++;
					}
				}
				s.insert({t[x].y,t[x].x+t[x].y+t[x].l,x});
			}
		}
	}
	cout<<fixed<<setprecision(1)<<(double)(ans)/(double)2;
	return 0;
}
```

实测在 P3219 上跑 $60ms$，目前最优解，比第二快五倍。在 P1222 上 rk4。（可能是数据太水了，因为我调试时还一堆锅的代码都过了）

---

## 作者：Eltaos_xingyu (赞：2)

[题目传送门 P1222](https://www.luogu.com.cn/problem/P1222)

[题目传送门 P3219](https://www.luogu.com.cn/problem/P3219)

### 算法

这是一篇用自适应 Simpson 写的题解，主要是因为这个蒟蒻作者只会用扫描线写矩形面积并......

那么，自适应 Simpson 是什么？

**前置芝士**：Simpson 公式

![](https://cdn.luogu.com.cn/upload/image_hosting/j6x9k3qs.png)

（图片来源于 [P4525](https://www.luogu.com.cn/problem/P4525)的第二篇题解）

不难发现这个公式的误差巨大：

![](https://cdn.luogu.com.cn/upload/image_hosting/o8sk17ek.png)

（图片来源于百度百科）

蓝色部分是公式求的，黄线是原函数......这误差的确肉眼可见的大。

于是自适应 Simpson 就出现了！！！

**自适应 Simpson** 是什么？

简单讲，就是二分区间，用 Simpson 公式计算二分的区间，如果左右区间结果的和加起来与原来的区间的结果在精度控制范围内，那就行，直接返回答案即可，如果超出了精度控制范围，那就继续二分直到结果在精度范围内。

```cpp
ld simpson(ld l,ld r){
	ld mid=(l+r)/2.0;
	return (4*f(mid)+f(r)+f(l))*(r-l)/6.0;
}

ld ASR(ld l,ld r,ld EPS,ld ans,int dep=4){
	ld mid=(l+r)/2.0;
	ld l_=simpson(l,mid),r_=simpson(mid,r);
	if(fabs(l_+r_-ans)<=EPS&&dep<=0)return ans;
	return ASR(l,mid,EPS,l_,dep-1)+ASR(mid,r,EPS,r_,dep-1);
}
```

也就差不多这样......

注意一点，`ASR` 函数中的 `dep` 参数是强制限定了最少递归次数，以防精度爆炸。

相信大家也关注到了代码中的 `f` 函数，那怎么写 `f` 函数呢？

类似于扫描线，我们固定一个平行于 $x/y$ 轴的线，枚举各个三角形覆盖这条线的区间，最后区间并就行了。

那么这道题就做完了（上代码，有些未使用的函数，代码奇丑，所以就尽量不要抄哦 qwq）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const double Pi=acos(-1);
int n;

struct po{
	long double x,y;
}; 
struct vec{
	long double A,B,C;//Ax+By+C=0;
	double dis;
};
vector<po> a[10001];
int y[10001];
bool cmp(vec a,vec b){
	if(a.dis<b.dis)return 1;
	else if(a.dis>b.dis)return 0;
	else if(a.B==0&&b.B==0){
		return a.dis*(-a.C/a.A)<b.dis*(-b.C/b.A);
	}
	else if(a.dis==0&&b.dis==0)return -a.C/a.B>-b.C/b.B;
	else return a.dis*(-a.C/a.B)>b.dis*(-b.C/b.B);
}
vec get_vec_from_po(po p,po q){
	vec v;
	v.A=p.y-q.y;
	v.B=q.x-p.x;
	v.C=p.x*q.y-q.x*p.y;
	v.dis=atan2(q.y-p.y,q.x-p.x);
	return v;
}
double cross3(po s,po d,po f){
	return ((d.x-s.x)*(d.y-f.y)-(d.x-f.x)*(d.y-s.y));
}
po get_po_from_vec(vec c,vec d){
	po pp;
	pp.x=((long double)(-d.B*c.C+c.B*d.C)/(long double)(-c.B*d.A+c.A*d.B));
	pp.y=((long double)(-d.A*c.C+c.A*d.C)/(long double)(c.B*d.A-c.A*d.B));
	return pp;
}
bool compare_po_and_vec(po f,vec g){
	if(g.B==0){
		return (double)((f.x+g.C/g.A)*g.dis)>0;
	}
	if(g.A==0){
		if(g.dis==0)return (double)((f.y+g.C/g.B))<0;
		else return (double)((f.y+g.C/g.B))>0;
	}
	long double yy=-f.x*(g.A/g.B)-(g.C/g.B);
	return (double)((yy-f.y)*(-g.A/g.B)*g.dis)>0;
}
struct cmp_x{
	bool operator()(const po &c ,const po &d)const{
		return (c.x==d.x)? c.y<d.y:c.x<d.x;
	}
};
#define ld long double
const ld eps=1e-9;
struct cmp_x_pair{
	bool operator()(const pair<ld,ld> &e ,const pair<ld,ld> &g)const{
		return (fabs(e.first-g.first)<=eps)? e.second<g.second:e.first<g.first;
	}
};
struct cmp_y{
	bool operator()(const po &e ,const po &f)const{
		return (fabs(e.y-f.y)<=eps)? e.x<f.x:e.y<f.y;
	}
};



vector<pair<ld,ld> > ss;
vector<po> temp;
ld f(ld yy){
	ss.clear();
	vec buff;
	buff.A=0;
	buff.B=1;
	buff.C=-yy;
	for(int k=1;k<=n;k++){
	    temp.clear();
		temp=a[k];
		if(yy>temp[2].y||yy<temp[0].y)continue;
		vec b1=get_vec_from_po(temp[0],temp[2]);
		vec b2=get_vec_from_po(temp[1],temp[2]);
		vec b3=get_vec_from_po(temp[0],temp[1]);
		if(temp[1].y==temp[2].y&&temp[2].y==yy){
			po test1=temp[1];
			po test2=temp[2];
			ss.push_back(make_pair((test1.x>test2.x)?test2.x:test1.x,(test1.x<test2.x)?test2.x:test1.x));
		}
		else if(temp[0].y==temp[1].y&&temp[1].y==yy){
			po test1=temp[0];
			po test2=temp[1];
			ss.push_back(make_pair((test1.x>test2.x)?test2.x:test1.x,(test1.x<test2.x)?test2.x:test1.x));
		}
		else if(yy>=temp[1].y-eps){
			po test1=get_po_from_vec(b1,buff);
			po test2=get_po_from_vec(b2,buff);
			ss.push_back(make_pair((test1.x>test2.x)?test2.x:test1.x,(test1.x<test2.x)?test2.x:test1.x));
		}
		else{
			po test1=get_po_from_vec(b1,buff);
			po test2=get_po_from_vec(b3,buff);
			ss.push_back(make_pair((test1.x>test2.x)?test2.x:test1.x,(test1.x<test2.x)?test2.x:test1.x));
		}
	}
	if(ss.empty())return 0;
	sort(ss.begin(),ss.end(),cmp_x_pair());
	long double last=ss.begin()->first,an=0;
	for(vector<pair<ld,ld> >::iterator itt=ss.begin();itt!=ss.end();itt++){
		if(last<=itt->second){
			an+=itt->second-max(itt->first,last);
			last=itt->second;
		}
	}
//	cout<<yy<<" "<<an<<endl;
	return an;
}

ld simpson(ld l,ld r){
	ld mid=(l+r)/2.0;
	return (4*f(mid)+f(r)+f(l))*(r-l)/6.0;
}

ld ASR(ld l,ld r,ld EPS,ld ans,int dep=2){
	ld mid=(l+r)/2.0;
	ld l_=simpson(l,mid),r_=simpson(mid,r);
	if(fabs(l_+r_-ans)<EPS&&dep<0)return (l_+r_+ans)/2;
	return ASR(l,mid,EPS,l_,dep-1)+ASR(mid,r,EPS,r_,dep-1);
}
int main(){
	
	cin>>n;
	int cnt=0;
	for(int i=1;i<=n;i++){
		po buf;
		int tempx,tempy,tempm;
		cin>>tempx>>tempy>>tempm;
		buf.x=tempx;
		buf.y=tempy;
		a[i].push_back(buf);
		y[++cnt]=buf.y;
		buf.x=tempx+tempm;
		buf.y=tempy;
		a[i].push_back(buf);
		y[++cnt]=buf.y;
		buf.x=tempx;
		buf.y=tempy+tempm;
		a[i].push_back(buf);
		y[++cnt]=buf.y;
		sort(a[i].begin(),a[i].end(),cmp_y());
	}
	sort(y+1,y+cnt+1);
	cnt=unique(y+1,y+cnt+1)-y-1;
	ld anss=0;
	for(int i=1;i<cnt;i++){
		anss+=ASR(y[i],y[i+1],eps,simpson(y[i],y[i+1]));
	}
	cout<<fixed<<setprecision(1)<<anss;
    return 0;
}
```

但，你以为这真就完了？

### 一些注意事项/优化

上面那份代码吸氧都会 TLE，怎么办？

- 判断一个三角形是否完全包含于另一个三角形

- 不要在 `f` 函数内部排序，尽量调到外面先按类似于 `f` 函数的方式排序。

- 尽量卡精度

- 一些玄学优化，比如 `inline` 和 `register`，要选合适的编译语言等

这样就能 AC 了。

代码就不贴了。qwq

---

## 作者：约瑟夫用脑玩 (赞：2)

当初在讨论区被问到这题本来想胡个数点胡挂了，那个时候就乱胡了一个 $n\log$ 的扫描线，现在听机房说网上没啥靠谱（$n^2$ 除外）的题解？

口胡选手不邀自来，经机房验证正确性无误。

------------

如果是矩形求并很容易就想到扫描线，现在我们只有一个矩形的左下角了，我们还是考虑扫描线。

回顾矩形，我们用它左边界代表加入，右边界代表删除，而直角三角形我们发现只有一个左边界，往右扫的过程中自然递减而消失。

于是我们也就只考虑左边界，用三元组 $(x,l,r)$ 表示横坐标为 $x$，纵坐标覆盖 $[l,r]$ 的区间，把三元组按 $x$ 排序后加入。

------------

我们手动给这道题出一个便于思考的 Subtask，$\forall(a,b,c),a=1$，即所有三角形左边界的横坐标相同，扫描线会在第一个时刻全部加入。

由于排完序后第一维作用就少了很多，以下二元组表示三元组的后两维，容易发现，如果 $\exists (a,b),(c,d),c\le a\le b\le d$，那么 $(a,b)$ 是无用的。

剩下的二元组形如：$(a_i,b_i),a_{i-1}<a_{i},b_{i-1}<b_i$。

若 $b_{x-1}\ge a_x$，那么前面的高一点的左边界覆盖着低一点的左边界上端，否则出现了断层，一个断层只会有最高处一处递减，下面由于被覆盖无变化。

观察往后移而不新增 $b_{i-1}<a_i$ 的情况，每一时刻的差量是一样的，可以用~~高中~~初中知识搞个二次函数算贡献。

考虑出现 $b_{x-1}\ge a_x\to b_{x-1}<a_x$ 的情况，此时出现了新的断层，显然的发现这样的断层只会在相邻的两个二元组处出现。

$b$ 在递减而 $a$ 不动，同时 $\forall a_x<a_y,b_x<b_y$，容易发现这样的断层在最初就能确定其发生时间。

我们时刻维护当前递减的量，发生了断层对差量的变化量贡献也是 $O(1)$ 的，后续处理是容易的。

------------

考虑做原问题，不保证三角形左边界横坐标相同。

其实也就是将加入时间变得不一样了，考虑在某个时刻插入了 $(l,r)$ 的二元组有何变化。

- 首先 $\exists(a,b),a\le l\le r\le b$，则弹出 $(a,b)$，并删除其对应的断层事件，势能分析显然。
- 然后查找 $(l,r)$ 的前驱后继，讨论并加入断层事件，不要忘了还有递减到消失的消失事件。

以上过程可以简单的使用 `set` 维护，整理一下需要做的事：

- 维护贡献，在不出现任何事件时贡献使用二次函数计算。
- 加入事件，真就加入一个 $(l,r)$，弹出无用元素并相应的修改断层事件。
- 断层事件，只对贡献造成影响。
- 消失事件，只可能对贡献造成影响。

注意这里的二元组应该是与扫描线的时间有关的，我们应该插入 $(l,r+t)$，其中 $t$ 为插入时的时间（横坐标）。

查询时丢入 $T$，则真实二元组为 $(l,r+t-T)$，其中 $T$ 为当前时间（横坐标）。

复杂度 $O(n\log n)$，全带在 `set` 上。

---

## 作者：fjy666 (赞：1)

P1222 & P3219

我们先进行一次扫描线，三角形 $(x,y,m)$ 在 $x$ 和 $x+m$ 处分别进入和离开。  
接下来我们要面对的是 $x=A$ 和 $x=B$ 之间所构成的两个梯形的面积交。  
![](https://cdn.luogu.com.cn/upload/image_hosting/w2y2dq32.png)  
（[对应数据](https://www.luogu.com.cn/discuss/559365)）
我们再次使用扫描线，把梯形从上到下进行处理。  
设上一个矩形的底边在 $y=C$ 上，当前矩形的左右两边的最高点分别是 $(A,x_1)$ 和 $(B,x_2)$。  
那么我们可不可以直接把 $x_1,x_2$ 对 $C$ 取 $\min$ 后直接求面积呢？显然是不行的。  
![](https://cdn.luogu.com.cn/upload/image_hosting/v8ussofq.png)  
我们会漏掉如图所示的蓝色三角形。  
观察这种情况仅在 $x_1>C$ 且 $x_2<C$ 时发生，我们需要把答案加上 $(x_1-C)(C-x_2)$。  
时间复杂度：$n^2\log n$。  
**极度卡常。**一个优化是如果外层扫描线的区间长度为 $0$，直接跳过计算过程。
```cpp
//Code by fjy666(https://www.luogu.com.cn/user/366338)
#include <bits/stdc++.h>
using namespace std;
#define _rep(i_,a_,b_) for(int i_ = (a_); i_ <= (b_); ++i_)
#define mid ((L+R) >> 1)
// #define get(x) (((x) - 1) / kb + 1)
#define multiCase() int testCnt = in(); _rep(curCase,1,testCnt)
#define multi(init) int testCnt = (init); _rep(curCase,1,testCnt)
#ifdef ONLINE_JUDGE
#define debug(...) 0
#else
#define debug(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)
#endif
typedef long long ll;

int in(void) { int x; scanf("%d", &x); return x; }
ll inl(void) { ll x; scanf("%lld", &x); return x; }
void out(int x) { printf("%d ", x); }
void outln(int x) { printf("%d\n", x); }
void out(ll x) { printf("%lld ", x); }
void outln(ll x) { printf("%lld\n", x); }
template<typename T> void chkmax(T &a, const T &b) { a = max(a, b); } 
template<typename T> void chkmin(T &a, const T &b) { a = min(a, b); } 
struct Triangle {
	int x, y, m;
} a[10050];

struct Node {
	int x, id, f;
}; vector<Node> scan;
int exist[10050];
struct Trapezoid { int ld, lu, rd, ru; } v[10050];
struct Compare {
	bool operator ()(const Trapezoid &a, const Trapezoid &b) {
		return a.lu > b.lu;
	}
};

int main() { 
	int n = in();
	_rep(i,1,n) a[i].x = in(), a[i].y = in(), a[i].m = in(); 
	int m = 0;
	_rep(i,1,n) if(a[i].m > 0) a[++m] = a[i];
	n = m;
	sort(a + 1, a + 1 + m, [](const Triangle &a, const Triangle &b) -> int { return a.y + a.m > b.y + b.m; });
	_rep(i,1,n) scan.push_back(Node{a[i].x, i, 1}), scan.push_back(Node{a[i].x + a[i].m, i, -1});
	sort(scan.begin(), scan.end(), [](const Node &a, const Node &b) -> int { return a.x < b.x; });
	int lst = 0; ll res = 0;
	for(auto &nxt : scan) {
		int top = 0;
		_rep(i,1,n) if(exist[i]) { Triangle &t = a[i];
			v[++top] = Trapezoid{t.y, t.y + t.m - (lst - t.x), t.y, t.y + t.m - (nxt.x - t.x)};
		}
		if(top) {
			sort(v + 1, v + 1 + top, Compare());
			int r = v[1].ld; res += (v[1].lu - v[1].ld + v[1].ru - v[1].rd) * (nxt.x - lst);
			for(int i = 2; i <= top; ++i) {
				if(v[i].ld >= r) continue;
				if(v[i].lu > r && v[i].ru < r) 
					res += (v[i].lu - r) * (r - v[i].ru);
				res += (min(r, v[i].lu) - v[i].ld + min(r, v[i].ru) - v[i].rd) * (nxt.x - lst);
				r = v[i].ld;
			}
		}
		if(nxt.f == 1) exist[nxt.id] = 1;
		else exist[nxt.id] = 0;
		lst = nxt.x;
	}
	printf("%.1lf\n", res / 2.0);
	return 0;
}

/* 
a list of keywords
clear empty push_back pop_back push pop top front back
emplace_back emplace push_front pop_front insert erase
find count set reset bitset map vector string multiset
first second iterator prev next deque multimap reverse
sort begin end list modify query init check calc prime 
putchar getchar puts scanf printf max min swap replace
*/
```

---

## 作者：zzw4257 (赞：1)

### 题意
>给出一些三角形形如$\{(x,y),(x+d,y),(x,y+d)\}$,求其面积并

### Solution

面积并我们仍然使用辛普森积分，对于一个截面子问题变为线段贪心

对卡时间我们可以使用离散化，即我们对一定有边的区间才求横截面积(圆的面积并有其特殊性)

对卡精度1.根据实际意义面积$*2$取整再$/2$(因为准确面积$*2$是整数)，2.下端点偏移

```cpp
#include<bits/stdc++.h>
#define re register
#define N 20001
#define eps 1e-9
using namespace std;
struct Tri{
	int x,y,r;
	inline char operator<(re Tri p)const{return r<p.r;}
}p[N],b[N];
struct Line{
	double l,r;
	inline char operator<(re Line p)const{return l!=p.l?l<p.l:r<p.r;}
}l[N];
int n,cnt,tot,t[N<<1];
char vis[N];
double ans;
map<double,double>mp;
inline double f(re double x){
	if(mp.count(x))return mp[x];
	tot=0;re int i;re double res=0.,r=-1e10;
	for(i=1;i<=n;++i){
		if(p[i].r+p[i].y<=x||x<p[i].y)continue;
		l[++tot]={p[i].x,p[i].x+p[i].y+p[i].r-x};
	}if(!tot)return 0;
	sort(l+1,l+tot+1);
	for(i=1;i<=tot;++i)if(l[i].r>r)res+=(l[i].l<=r)?l[i].r-r:l[i].r-l[i].l,r=l[i].r;
	return mp[x]=res;
}
inline double Calc(re double l,re double r){re double mid=(l+r)/2.;return (r-l)/6.*(f(l)+f(r)+4.*f(mid));}
inline double Simpson(re double l,re double r){
	re double mid=(l+r)/2.,s1=Calc(l,r),s2=Calc(l,mid)+Calc(mid,r);
	if(fabs(s2-s1)<eps)return s2;
	return Simpson(l,mid)+Simpson(mid,r);
}
inline char In(re int i,re int j){return p[i].x>=p[j].x&&p[i].y>=p[j].y&&(p[i].x+p[i].r)<=(p[j].x+p[j].r)&&(p[i].y+p[i].r)<=(p[j].y+p[j].r)&&p[i].r+p[i].x-(p[j].x+p[j].y+p[j].r-p[i].y)<=0;}
int main(void){
	re int i,j;scanf("%d",&n);
	for(i=1;i<=n;++i)scanf("%d%d%d",&p[i].x,&p[i].y,&p[i].r);sort(p+1,p+n+1);
	for(i=1;i<=n;i++){
		for(j=i+1;j<=n;j++)if(In(i,j)){vis[i]=1;break;}
		if(!vis[i])t[++*t]=p[i].y,t[++*t]=p[i].y+p[i].r,b[++cnt]=p[i];
	}
	memcpy(p,b,sizeof p);n=cnt;
	sort(t+1,t+*t+1),*t=unique(t+1,t+*t+1)-t-1;
	for(i=1;i<*t;++i)ans+=Simpson(t[i],t[i+1]-eps);
	printf("%.1lf\n",round(ans*2.)/2.);
	return 0;

}

---


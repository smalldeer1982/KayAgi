# [POI 2009] SLW-Words

## 题目描述

设 $h$ 是一个作用于由数字 0 和 1 组成的字符串的函数。函数 $h$ 将字符串 $w$ 转换为：独立且同时地将每个数字 0 替换为 1，并将每个数字 1 替换为字符串 "10"。例如，$h("1001") = "101110"$，$h("") = ""$（即 $h$ 将空字符串映射为空字符串）。注意，$h$ 是一个单射，即一对一的函数。$h^k$ 表示函数 $h$ 自身复合 $k$ 次。特别地，$h^0$ 是恒等函数 $h^0(w)=w$。

我们对形如 $h^k("0")$ 的字符串感兴趣，其中 $k = 0,1,2,3,\cdots$。该序列以以下字符串开始：

"0", "1", "10", "101", "10110", "10110101"。

如果字符串 $x$ 作为一个连续（即单块）子序列出现在字符串 $y$ 中，我们称字符串 $x$ 是字符串 $y$ 的一个子串。给定一个整数序列 $k_1,k_2,\cdots,k_n$。你的任务是检查形如 $h^{k_1}("0") \cdot h^{k_2}("0") \cdots h^{k_n}("0")$ 的字符串是否是某个 $h^m("0")$ 的子串。

## 说明/提示

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
2
2
1 2
2
2 0
```

### 输出

```
TAK
NIE
```

# 题解

## 作者：GeXXGe (赞：3)

 ###### （本蒟蒻的第一篇题解，有问题请大佬指出，谢谢。


------------

- ## 题目
  [传送门（）](https://www.luogu.com.cn/problem/P3491)
  

------------


- ## 分析


  ~~题目很好理解，没什么好分析了罢。~~

- 首先来看**性质**：
	
    1. 斐波那契性质： $H^x=H^{x-1}+H^{x-2}$
    2. 定义 $H^{-1}(x)$ 为 $H^1(x)$ 的逆操作，不难发现当 $s′$ 为 $s$ 字串时，$H^{-1}(s$$′)$ 仍为 $s$ 字串

- 我们可以不断的将连接起来的串进行**逆转换**。

- 如果当前序列**仅剩一个元素**则为可行。

-  如果在序列中存在一个元素 $=0$，则如果他前面的元素 $\ne 1$ 或 $3$，则返回 $0$。

- 再考虑一些**不合法**的情况：

   1. 出现 $00$ 必然不合法
   2. 上一条的推论，出现 $111$ 必然不合法，因为  $H^{-1}(111)=00+s$
   3. 上一条的推论，因为  $H(111)=101010=10101+0$，因此对于 $x≥5$ 时，后缀必然为 $10101$，因此此时后面接上 $0$ 必然不合法


-----------------


- ## 代码
~~我相信没几个人会喜欢上面的一通分析的吧~~，那么，你们喜欢的**代码**来了——
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
const int N=100100;
int a[N];
int check()
{
    while(n>1)
    {
        if(!a[1])
		{
			a[1]=2;
		}
        if(a[n]==1)
		{
			a[n]=-1;
		}
        else if(a[n]==3)
		{
			a[n]=2;
		}
        for(int i=2;i<=n;i++)
        {
           if(!a[i])
           {
                if(a[i-1]==1)
				{
					a[i]=-1;
					a[i-1]=2;
				}
                else if(a[i-1]==3)
				{
					a[i]=a[i-1]=2;
				}
                else return 0;
            }
        }
        int m=0;
        for(int i=1;i<=n;i++)
        {
            if(a[i]!=-1)
			{
				a[++m]=a[i];
			}
        }
        n=m;
        for(int i=1;i<=n;i++)
		{
			a[i]--;
		}
    }
    return 1;
}
int main()
{
    int x;
    cin>>x;
    while(x--)
    {
        cin>>n;
        for(int i=1;i<=n;i++)
		{
			cin>>a[i];
		}
		puts(check()?"TAK":"NIE");
    }
    return 0;
}
```


------------

### 感谢观看
#### 不要复制完代码就走了啊，这样是不道德的，思路也是要看的， 对了，别忘了要**点个赞**！

---

## 作者：yutong_Seafloor (赞：0)

# [题目在这里 · P3491 \[POI2009\] SLW\-Words](https://www.luogu.com.cn/problem/P3491) 

感觉楼下几个讲的不是很清楚，自己补一发清楚点的。

### 题目简要：

有一个字符串会通过一个函数 $h()$ 进行变换，大概为 $0$ 变 $1$，$1$ 变 $10$，$h^k$ 表示为函数 $h$ 使用 $k$ 次（对于 $k=0$ 的情况则为不变换），给你一个数 $m$ 和一组数 $k$，问 $h^{k_1}(0)$，$h^{k_2}(0)$，$h^{k_3}(0)$ 是不是 $h^m(0)$ 的子串。

------------
### 题意分析

初看题可能感觉有点晕，于是第一时间想到了暴力带入，然后看着 $1 \le t \le 13$，$1 \le n \le 10^5$ 陷入了沉思。

其实是有规律的，我们先列举一部分 $h^k(0)$ 观看：

$0,1,10,101,10110,10110101,$……

还是看不懂？我们一个一个看这些数字：

$10$ 是 $1$ 和 $0$ 两个子串组成的，$101$ 是 $10$ 和 $1$ 两个子串组成的，$10110$ 是由 $101$ 和 $10$ 两个子串组成的，$10110101$ 是由 $10110$ 和 $101$ 组成的……

看着这种组合熟不熟悉，这不就是[斐波那契数列](https://baidu.physton.com/?q=斐波那契数列)吗！

那我们就可以对着连接起来的字符串进行逆转换。

------------
大概分析完了以后，我们还需要考虑一些会输出 `NIE` 的情况，想了一下应该只有当一个元素为 $0$，且前边的 $k$ 不是 $1$ 或者 $3$ 的时候。

因为前边谈到 $h^0(0)=0$，后缀为 $0$ 的情况只有 $k=1$ 或者 $k=3$，为什么不能是 $k=5$ 或者别的情况呢，推理一下：

如果是 $k=5$，且前是 $h^0(0)=0$，则 $h^5(0)$ 组合出来的子串必须是 $1011$ 和 $0$，$1011$ 其必然不是一个可能由 $h(0)$ 变化出来的字符，故没有可能是 $k=5$ 等情况（自己推一下试试）。

------------
## 代码 
```cpp 
#include <bits/stdc++.h>
using namespace std;
int t,n,k[100100],m,i,j;
bool check()
{
    while(n>1)
    {
    	m=0;
        if(!k[1]) k[1]=2;
        if(k[n]==1) k[n]=-1;
        else if(k[n]==3) k[n]=2;
        for(int i=2;i<=n;i++)
        if(!k[i])
        {
        	if(k[i-1]!=1 && k[i-1]!=3) return 0;
            if(k[i-1]==1) k[i]=-1,k[i-1]=2;
            if(k[i-1]==3) k[i]=k[i-1]=2;
        }
        for(int i=1;i<=n;i++)
        if(k[i]!=-1)
		k[++m]=k[i];
        n=m;
        for(int i=1;i<=n;i++)
		k[i]--;
    }
    return 1;
}
int main()
{
    cin>>t;
    for(i=1;i<=t;i++)
    {
        cin>>n;
        for(j=1;j<=n;j++)
		cin>>k[j];
		if(check()) cout<<"TAK\n";
		else cout<<"NIE\n";
    }
    return 0;
}//by·yutong_Seafloor
```

---


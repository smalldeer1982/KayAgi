# 展翅翱翔之时 (はばたきのとき)

## 题目背景

**船が往くよミライへ旅立とう**

**船只启航 朝未来展开旅途**

**青い空笑ってる（なにがしたい?）**

**湛蓝天空露出微笑（想做些什么?）**

**ヒカリになろうミライを照らしたい**

**化作光芒吧 想就此照亮未来**

**輝きは心からあふれ出してもっと先の景色望むんだ**

**光辉自内心满溢而出 愿能望见更加前方的景色**

**Ah!やっと手にしたミライチケットかざして…！**

**Ah!挥舞起终于得手的未来门票…！**



 ![](https://cdn.luogu.com.cn/upload/pic/4529.png) 

我们Aqours，终于闪闪发亮了！


2月25和26日，将是我们登上横滨ARENA演唱的日子！


而且，还要在全日本、甚至全世界的好多影院进行转播呢！


转播好像还是通过中继卫星传输的呢！


未来ずら！


## 题目描述

不过，好像中继卫星上，出了一些问题呢……

我们的中继卫星一共有 $N$ 颗，编号成 $1$ 到 $N$。不过，好像一个中继卫星可以且仅可以单向地从另一颗中继卫星那儿接收数据。

第 $i$ 颗卫星现在已经被设定到了从第 $A_i$ 颗卫星（称为接收源）那儿接受数据。

不过这些中继卫星的接收源是可以修改的，只不过每次修改要花一定的资金呢。

听说要达成中继的话，这些卫星之间必须**两两之间能够互相（直接或间接）通信**才行啊。

虽然鞠莉家里很有钱，可是这么大的花费，也得提前准备一下呢。

所以，你能帮我们算算这样子一共最少要花多少钱吗？

## 说明/提示

### 数据范围及约定

- 对于 $10\%$ 的数据，满足 $N \le 10$。
- 对于 $40\%$ 的数据，满足 $N \le 15$。
- 对于 $70\%$ 的数据，满足 $N \le 3000$。
- 对于 $100\%$ 的数据，满足 $2 \le N \le 100000,1 \le C_i \le 10^9$。

### 以下是彩蛋

事实上 LoveLive 的直播卫星中继只有一颗星，而且永远都是不加密的。

导致只要有一个卫星锅就可以在家偷偷看直播，也就是传说中的卫星源。

lin_toto：万代南梦宫都把浅水湾给买了，居然只有回放，只好跑到香港 the sky 去看 + 手动滑稽。

至于为什么看转播，eplus 表示 LoveLive 系列演唱会的票大家尽管抽选尽管抢，买得到算我输。

于是 lin_toto 在去年 μ's Final LoveLive 的时候拿肉鸡把 eplus 搞趴下了，然后就买到了。

于是今年 eplus 连抢票都不让抢了，全抽选，抽得到算我输。

然后 lin_toto 就去看转播了。


## 样例 #1

### 输入

```
4
2 2
1 6
1 3
3 1```

### 输出

```
5```

# 题解

## 作者：kkksc03 (赞：19)

官方题解

我们把这种每个点入度（或者出度）为1的点称为有向环套树。显然，给出的图是一个环套树森林。我们讨论单个环套树的情况。

如果要两两可以互相交互，那么就是形成强连通。

只有一种结构可以达成：环。

所以说，我们需要找找出每个环套树的最长链。

首先找出环，然后环上的树上有多个孩子的点贪心保留权值大的点，这样变成了外向链。

然后枚举环上的每个点，把这个环破开，然后计算最长的链（你可以想象一下“6”这个数字，对就是这个意思）。

森林可能不连通，所以分别处理。最后复杂度是$O(n)$


---

## 作者：whiteqwq (赞：16)

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1720061)

注意：“环套树”与“基环树”意思均为一棵树上增加一条边后形成的图，本文采取“基环树”的叙述方式。

## 题意
题意：给定 $n$ 个点，每个点都会依赖另一个点，可以用一定的代价改变一个点依赖的点，求让依赖关系变为环的最小代价。

数据范围：$1\leqslant n\leqslant 10^5$。

## 分析
首先，我们可以将点之间的依赖关系看为边（被依赖的点连向依赖别的点的点），这样依赖关系组成的图就会成为一个基环树森林。（简单证明一下：因为每个点只依赖一个点，所以只会有一条入边，即每一个大小为 $k$ 的森林至多有$k$条边，即为一棵基环树）

为了将这张图最终变为一个环，我们可以把每一个基环树拆成若干个链（链的根节点可以连向其他的点），然后将链首尾相连就可以得到环了。这样我们就可以只考虑一棵基环树，最后将答案相加。

我们看一个例子吧：

![](https://cdn.luogu.com.cn/upload/image_hosting/7py1ji3e.png)

最优的做法是将 $(1,3),(2,4),(4,5),(9,10)$ 断开，得到 $4$ 条链：

![](https://cdn.luogu.com.cn/upload/image_hosting/hp6gtfds.png)

然后将 $4$ 条链首尾相连，得到答案：

![](https://cdn.luogu.com.cn/upload/image_hosting/iieayt9c.png)

然后我们考虑每一棵基环树，因为每棵树只有一条入边，在环上的点都已经有了一条入边，只能向外连出边，因此这棵基环树显然是外向树。

对于每一棵根结点在环上的树，为了将其变为链，我们最多可以保留一个儿子，让它自己及其保留的儿子，保留的儿子保留的儿子……让这些点形成一条链。我们可以用贪心的思想，对于每个点我们保留它出边中费用最大的边，其他的边全部断掉，这样的话费一定是最小的。

（如在例子中断掉的 $(4,5)$ ）

这样就可以写出处理树部分的代码了：
```cpp
void dfs(long long x,long long last){
	if(vis[x]==0)
		vis[x]=1;
	for(long long i=start[x];i;i=then[i]){
		long long y=to[i];
		if(y==last||vis[y]==2)
			continue;
		dfs(y,x);
		if(worth[out[x]]>worth[i])
			ans+=worth[i];
		else ans+=worth[out[x]],out[x]=i;
	}
}
```

经过这样的处理，我们就只剩一个环及这个环上的点连出的一些链了。

我们先找一下当前基环树的环，这个部分代码是很容易写出来的（ $vis_x=1$ 代表 $x$ 点访问过， $vis_x=2$ 代表 $x$ 点在环上）：
```cpp
void find(long long x){
	top=0;
	while(vis[x]==0)
		vis[x]=1,x=f[x];
	while(vis[x]==1)
		stk[++top]=x,vis[x]=2,x=f[x];
}
```

此时， $stk$ 数组中存储的便是环上的点了。

考虑维护两个值：当前没有将整个环断成链的花费 $cut0$ 与当前已经将整个环断成链的花费 $cut1$ 。

我们思考一下，如何将当前剩下的点断成若干条链呢？发现环断开后只能带上一个点连出的链，而其他的链都必须断开。我们枚举每一个点，断开连入这个点的边，或者断开这个点带上的链，第一种操作会让之前的链保留下来（而上一个点带上的链可以与环上截下来的链成为新的链），第二种操作则可以维护现在链的形态。经过这样的操作，剩下的所有点都被分割为若干条链了。

我们注意一下：第一种操作会让一个没有断成链的环断成链（当然也可以让一个断成链的环断成更多的链），第二个操作则不会改变环的形态。因此 $cut1$ 可以从两种操作转移（第一种操作可以从 $cut0$ 与 $cut1$ 转移来，而第二种操作只能从 $cut1$ 转移来），而 $cut0$ 只能从第二种操作转移（且由 $cut0$ 转移过来）。

还是举个例子吧：

![](https://cdn.luogu.com.cn/upload/image_hosting/7vkbqvk5.png)

这个例子的答案应该是割掉 $(2,8)$ ， $(5,6)$ 和 $(7,9)$ ，为 $6$ （感谢@M_theory004 的纠正），~~至于为什么，读者自证不难。~~

最后把答案累加就可以了。

这一部分的代码：
```cpp
long long cut0=0,cut1=inf;
for(j=1;j<=top;j++)
	dfs(stk[j],0);
for(j=1;j<=top;j++){
	cut1=min(min(cut0,cut1)+worth[in[stk[j]]],cut1+worth[out[f[stk[j]]]]);
	cut0+=worth[out[f[stk[j]]]];
}
ans+=cut1;
```

由于在$\text{find}$函数与$\text{dfs}$函数中每个点都只会遍历一遍，循环也只会将每个环及里面的点遍历一遍，因此复杂度是$O(n)$的。

## 代码

注： $in_x$ 与 $out_x$ 分别指连向 $x$ 的边编号与 $x$ 连出的边的编号。
```cpp
#include<stdio.h>
#define inf 1000000000000000000
const int maxn=100005,maxm=200005;
long long i,j,k,m,n,e,ans,top;
long long start[maxn],to[maxm],then[maxm],worth[maxm],f[maxn],in[maxn],out[maxn],vis[maxn],stk[maxn];
inline long long min(long long a,long long b){
	return a<b? a:b;
}
inline void add(long long x,long long y,long long z){
	then[++e]=start[x],start[x]=e,to[e]=y,worth[e]=z;
}
void find(long long x){
	top=0;
	while(vis[x]==0)
		vis[x]=1,x=f[x];
	while(vis[x]==1)
		stk[++top]=x,vis[x]=2,x=f[x];
}
void dfs(long long x,long long last){
	if(vis[x]==0)
		vis[x]=1;
	for(long long i=start[x];i;i=then[i]){
		long long y=to[i];
		if(y==last||vis[y]==2)
			continue;
		dfs(y,x);
		if(worth[out[x]]>worth[i])
			ans+=worth[i];
		else ans+=worth[out[x]],out[x]=i;
	}
}
int main(){
	scanf("%lld",&n);
	for(i=1;i<=n;i++){
		long long x;
		scanf("%lld%lld",&f[i],&x);
		in[i]=i,add(f[i],i,x);
	}
	for(i=1;i<=n;i++){
		if(vis[i])
			continue;
		find(i);
		if(top==n){
			puts("0");
			return 0;
		}
		long long cut0=0,cut1=inf;
		for(j=1;j<=top;j++)
			dfs(stk[j],0);
		for(j=1;j<=top;j++){
			cut1=min(min(cut0,cut1)+worth[in[stk[j]]],cut1+worth[out[f[stk[j]]]]);
			cut0+=worth[out[f[stk[j]]]];
		}
		ans+=cut1;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：codecode (赞：6)

#### 题解：

要使所有卫星强连通，则只能是一个环。而若选择一个卫星修改其信号源，可以暂不管修改为何（因为可以是任意的），故可以视**修改信号源**操作为**删去一条边**。

若经过一系列**删除**操作后使得卫星与信号线路构成的图被分成若干链，则可以适当的选择这些链首的信号源使得它们构成一个环。故我们只需要考虑如何**以最小的代价将一棵基环树的若干边删去，将其变成若干条链。**

先考虑树的情形：

> 考虑一个树型 dp：$dp(i)$ 表示将以 $i$ 为根的子树变成若干链所需的最小代价。
>
> 注意到对于点 $i$，它只能将它的一个儿子“扩展”到连接着它父亲与它的链上，即只有这条边可以不被删去，其它的边都需删去。
> 
> 用一个贪心的策略，选择点权最大的儿子保留，其余的删去。
>

对于基环树，对每个环上的点外向产生的树，用如上策略可以将整个基环树化简为一个环与环上的点各产生一个点的图。

注意到环上必将删去一条边，依次枚举环上所有点，将需要删去的边的权取 $\min$ 即可。

时间复杂度 $\Theta(n)$。

---

## 作者：z7z_Eta (赞：6)


展翅翱翔之时 (はばたきのとき) haba takino toki

~~（衛星の森の満开の下）~~

题解这么少呢。。

K3的官方题解个人认为很不可读，本来题目里是有标程的，但是由于LG3新界面更新就丢了

题目大意：给基环树森林，边上有权，求割成**链状图**的最小代价

想到树上的情况，可以每次贪心的保留cost最大的ch节点，割掉其他cost较小的ch点。这样可以把树拆成链，代价最小

然后因为有环，我们可以先找到环，以环点为根做树上贪心，这样每棵环上的树变成了外向链。

接下来考虑拆环，对于环点$u$，$fa$是$u$的父亲，要拆成链，可以断开$u$向$fa$的连边，也可以断开$fa$的外向链向$fa$的连边，但是要求强制一次断开$u$向$fa$的连边，不然还是可能留下环，所以开状态dp一下，就能做了。

记得特判全图为环的情况。

>你可以想象一下“s”这个字母，对就是这个意思

###code:

```cpp
// SeptEtavioxy
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
#include<cmath>
#define re register
#define ll long long
#define il inline
#define rep(i,s,t) for(re int i=(s);i<=(t);i++)
#define each(i,u) for(int i=head[u];i;i=bow[i].nxt)
#define pt(ch) putchar(ch)
#define pti(x) printf("%d",x)
#define ptll(x) printf("%lld",x)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
using namespace std;
// c_ints
il int ci(){
	re char ch;int f=1;
	while(!isdigit(ch=getchar()))f= ch=='-'?-1:1 ;
	re int x= ch^'0';
	while(isdigit(ch=getchar()))x=(x*10)+(ch^'0');
	return f*x;
}

enum{N=100024};

class Edge{
public: int nxt;
}bow[N];
int head[N];//邻接表存图

int fa[N],rec[N];
int loop[N];
il int find_loop(int i){
	re int x=i;
	while( !rec[x] ){
		rec[x]= 1;
		x= fa[x];
	}//标记遍历点，rec[x]=1
	int tot= 0;
	while( rec[x]==1 ){
		loop[++tot]= x;
		rec[x]= 2;
		x= fa[x];
	}//把环点装在loop数组里，rec[x]=2
	return tot;
}

ll ans,c[N];//c数组是cost
int ch[N];//记录重儿子
il void dfs(int u){
	if( !rec[u] ) rec[u]= 1;
	each(v,u) if( rec[v]!=2 ){
		dfs(v);
		if( c[ch[u]]<c[v] ) ans+= c[ch[u]], ch[u]=v;
		else ans+= c[v];
	}
}

int main(){
	int n= ci();
	rep(i,1,n){
		fa[i]=ci(), c[i]=ci();
		bow[i].nxt= head[fa[i]];
		head[fa[i]]= i;
	}

	rep(i,1,n) if( !rec[i] ){
		int L= find_loop(i);
		if( L==n ){ pti(0); return 0; }//判断是否全图是整个环
		
		rep(i,1,L) dfs(loop[i]);
		ll ans0=0,ans1=1e18;//环上dp，ans0是未断环，ans1是已经断开环
		rep(i,1,L){
			int u= loop[i];
			ans1= min(min(ans0,ans1)+c[u],ans1+c[ch[fa[u]]]);
			ans0= ans0+c[ch[fa[u]]];
		}
		ans+= ans1;
	}
	ptll(ans);
	
	return 0;
}

```
>如果梦想有颜色那一定是橙色

```cpp
//接下来提供一些样例，供调试
/*
4
2 2
1 1
4 4
3 3

6
2 2
1 1
1 2
1 1
3 3
4 4

8
2 9
3 9
4 4
5 9
6 9
1 1
4 5
1 3
*/
```

---

## 作者：封禁用户 (赞：4)

# P3651 展翅翱翔之时 (はばたきのとき) 题解
## 思路
考虑对于每个基环树求答案。

对于一棵树，考虑对于每个点只保留通向它的最大的边。

对于基环树，考虑强行断掉环上的一条边，记录环上点通向它的最大边和次大边，如果最大边都是环上边就必须选择一个点强行断成非环边。

所以我们可以找出所以的环，然后将环外的点加入他连接的环，最后枚举每个环的断开点，找到最优的一个地方断开。

原图可能有多个环 此时需要拆开。

可能环上连着其他的点。

对于这些点 只有两种情况:

第一种：对环上连着其他非环上点的点A，把它在环上的边破开。

第二种：把点A之外的点所连的边破开，同时把非环上点与环连的边破开。

贪心的找对一个点连多个边的情况，贪心保留最大的，然后在枚举一下环上的点，判一下是采取一情况好，还是二情况好。

注意特判所有点形成一个环的情况哟。
```cpp
#include<bits/stdc++.h>
#define ll long long
#define inf 0x3f3f3f3f
#define fi first
#define se second
#define db double
using namespace std;
const int Maxn=1e5+5;
int n,m,p[Maxn],cnt,cnt2,a[Maxn],b[Maxn],suf[Maxn],in[Maxn],hua[Maxn],vis[Maxn];
ll tot,res,mx[Maxn],mx2[Maxn];
int head,tail,q[Maxn];
ll loop(int rt) {
	int f=0;
	ll tmp=inf,tmp2=0;
	m=0;
	p[++m]=rt;
	for(int i=a[rt];i!=rt;i=a[i]) {
		p[++m]=i;
	}
	for(int i=1;i<=m;i++) {
		tmp2+=mx[p[i]];
		vis[p[i]]=1;
		
		if(mx[p[i]]>mx2[p[i]]&&suf[p[i]]==mx[p[i]]) {
			tmp=min(tmp,mx[p[i]]-mx2[p[i]]);
		}
		else {
			f=1;
		}
	}
	if(f==1) {
		return tmp2;
	}
	else {
		return tmp2-tmp;
	}
}
signed main() {
	scanf("%d",&n);
	for(int i=1;i<=n;i++) {
		scanf("%d%d",&a[i],&b[i]);
		tot+=b[i];
		in[a[i]]++;
		if(b[i]>mx[a[i]]) {
			mx2[a[i]]=mx[a[i]];
			mx[a[i]]=b[i];
		}
		else if(b[i]>mx2[a[i]]) {
			mx2[a[i]]=b[i];
		}
	}
	for(int i=1;i<=n;i++) hua[i]=1;
	head=1;
	for(int i=1;i<=n;i++) {
		if(in[i]==0) {
			q[++tail]=i;
		}
	}
	while(head<=tail) {
		int x=q[head++];
		hua[x]=0;
		if(--in[a[x]]==0) q[++tail]=a[x];
	}
	for(int i=1;i<=n;i++) {
		if(hua[i]) {
			suf[a[i]]=b[i];
		}
	}
	for(int i=1;i<=n;i++) {
		if(hua[i]&&!vis[i]) {
			res+=loop(i);
			cnt++;
		}
		else if(!hua[i]) {
			cnt2++;
			res+=mx[i];
		}
	}
	if(cnt==1&&cnt2==0) {
		printf("0");
		return 0;
	}
	printf("%lld",tot-res);
}
```

---

## 作者：Coros_Trusds (赞：2)

[$\texttt{\color{gold}更好\color{black}{的阅读体验}}$](https://www.cnblogs.com/coros-trusds/)

容易看出考察基环树（或者说“环套树”）的熟练运用。

### 变量解释：

| 变量名称 | 解释 |
| -----------: | -----------: |
| $c_i$ | 第 $i$ 个卫星调整接收源的所需花费 |
| $in_i$ | 指向点 $i$ 的边的编号 |
| $out_i$ | 从点 $i$ 延出的边的编号 |
| $vis_i$ |  $vis_i = 0$ 时未访问；$vis_i = 1$ 时已访问但没在环上；$vis_i = 2$ 时为在环上的点  |
| $fa_i$ | 原本指向点 $i$ 的点的编号 |
| $loop_i$ | 环上的点 |



### 题目大意

> 给出一个有向图，求把这个有向图变成一个环的最小代价。

### 思路分析

对于一个基环树森林，我们将其分为几个独立的基环树，每一棵基环树把权值最大的取除，所有操作全部完成之后，再把已经不完整的基环树们连成一个环即可。

特别地，找到一棵基环树之后，如果一棵基环树的环的点数正好有 $N$ 个，那么它已经满足条件是一棵基环树了，直接输出 $0$ 即可，否则 #$4$ 和 #$7$ 会出错。

------------

整个程序分为主函数、深度优先遍历和找环。

### 找环

选定一个需要深入的点 $u$。

1. 如果点 $u$ 未被访问，则显示访问此节点，并且依次访问指向此节点的点。

2. 如果点 $u$ 已被访问，那么将其放入环中，并且标记为环中的节点，并且依次访问指向此节点的点。

这是一个找环的过程，目的是找出环为接下来的 dfs 做准备。

### dfs

对于一个节点 $u$，访问其出边所连接的点，对其进行遍历。

这个步骤是为了找出价值最大的那条边，然后割掉它。

```cpp
inline void dfs(int u,int fath)
{
	if(vis[u]==0)
	{
		vis[u]=1;
	}
	
	for(register int i=head[u];i;i=node[i].nxt)
	{
		int v=node[i].v;
		
		if(v!=fath && vis[v]!=2)
		{
			dfs(v,u);
			
			if(c[out[u]]>c[i])
			{
				sum+=c[i];
			} 
			
			else
			{
				sum+=c[out[u]];
				
				out[u]=i;
			}
		}
	}
}
```

[完整代码戳这里](https://www.cnblogs.com/Coros-Trusds/p/15098995.html)

---

## 作者：kradcigam (赞：2)

> 题目意思：
>
> 有 $n$ 个点，第 $i$ 点有一条出边 $i\to a_i$。更改点 $x$ 的出边代价为 $c_x$，要求用最小的代价将所有点连成一个环。

我们先把原图建出来，考虑这张图一定是若干个树连环。

每一个弱连通块一定是类似于这样：

![graph.png](https://i.loli.net/2021/07/27/fD7IUqYP5lW3K26.png)

即：

![iShot2021-07-27 16.22.45](https://tva1.sinaimg.cn/large/008i3skNgy1gsvl2jymqcj31080u0wh4.jpg)

我们的任务则是找到最长的一条链。

对于一条链，每个节点的入度最多为 $1$​​，所以，对于树上的点，为了最大化答案，我们选择保留入边中边权最大的一条。

对于环上的点，我们也可以这样做，因为至少去掉的那些边一定不可能被选进最优解中去。

经过这样的处理，还剩下这样的东西：

![iShot2021-07-27 16.33.19](https://tva1.sinaimg.cn/large/008i3skNgy1gsvlcvfsu3j31380u075v.jpg)

这个环是处理的重中之重。

对于环上的一个点，环上与它相邻的点的两条边以及子树的一条边至少会断一条边（没有子树，可以看成有一条边权为 $0$ 的边）。

我们还发现，我们必须断至少一条环上的边，必须至少保留一条来自子树连向环的边，否则就不为链了。

最后还有一个小细节需要特判一下：

如果这个图本身强联通，答案应为 $0$。

代码（目前的最优解）：

```cpp
#include<bits/stdc++.h>
#define log(a) cerr<<"\033[32m[DEBUG] "<<#a<<'='<<(a)<<" @ line "<<__LINE__<<"\033[0m"<<endl
#define LL long long
#define SZ(x) ((int)x.size()-1)
#define ms(a,b) memset(a,b,sizeof a)
#define F(i,a,b) for(int i=(a);i<=(b);++i)
#define DF(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
inline int read(){char ch=getchar(); int w=1,c=0;
    for(;!isdigit(ch);ch=getchar()) if (ch=='-') w=-1;
    for(;isdigit(ch);ch=getchar()) c=(c<<1)+(c<<3)+(ch^48);
    return w*c;
}
const int N=1e5+10;
int a[N],b[N],h[N],f[N],l[N];
LL ans;
bool vis[N];
queue<int>q;
int main(){
    int n=read();
    F(i,1,n){
        a[i]=read(),b[i]=read();
        h[a[i]]++;
    }
    F(i,1,n)
        if(!h[i])q.push(i);
    if(q.empty()){
        int s=0;
        for(int i=1;!vis[i];i=a[i])s++,vis[i]=true;
        if(s==n){
            puts("0");
            return 0;
        }
    }
    while(q.size()){
        int x=q.front();q.pop();
        if(f[a[x]]){
            ans+=min(f[a[x]],b[x]);
            f[a[x]]=max(f[a[x]],b[x]);
        }else f[a[x]]=b[x];
        if(--h[a[x]]==0)q.push(a[x]);
    }
    F(i,1,n)
        if(h[i]){
            int tot=0;
            for(int j=i;h[a[j]];j=a[j]){
                h[a[j]]=0;
                ans+=f[a[j]];
                l[++tot]=f[a[j]]-b[j];
            }
            sort(l+1,l+tot+1);
            ans-=l[tot];
            DF(i,tot-1,1)
                if(l[i]>0)ans-=l[i];
        }
    cout<<ans;
    return 0;
}
```



---


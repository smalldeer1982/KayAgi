# [TJOI2007] 调整队形

## 题目背景

学校艺术节上，规定合唱队要参加比赛，各个队员的衣服颜色不能很混乱：合唱队员应排成一横排，且衣服颜色必须是左右对称的。

例如：“红蓝绿蓝红”或“红蓝绿绿蓝红”都是符合的，而“红蓝绿红”或“蓝绿蓝红”就不符合要求。

合唱队人数自然很多，仅现有的同学就可能会有3000个。老师希望将合唱队调整得符合要求，但想要调整尽量少，减少麻烦。以下任一动作认为是一次调整：


## 题目描述

1、在队伍左或右边加一个人（衣服颜色依要求而定）；

2、在队伍中任两个人中间插入一个人（衣服颜色依要求而定）；

3、剔掉一个人；

4、让一个人换衣服颜色；

老师想知道就目前的队形最少的调整次数是多少，请你编一个程序来回答他。

因为加入合唱队很热门，你可以认为人数是无限的，即随时想加一个人都能找到人。同时衣服颜色也是任意的。


## 样例 #1

### 输入

```
5
1 2 2 4 3```

### 输出

```
2```

# 题解

## 作者：zyj_Orz (赞：20)

排版已订正。

## DP题。

~~感觉蓝题难度还是有点过了吧？~~

大致思路就是建一个二维数组dp【i】【j】表示从第i个人到第j个人对称的最小次数

这时候就大致可以得出**动态转移方程**了，如下

------------
1.先设置一个长度l自2至n枚举

------------
2.此时i从1枚举至n-l+1，j此时则为i+l-1。



------------
3.当第i个人颜色等于第j个人时，dp【i】【j】则与dp【i+1】【j-1】相同，赋值；



------------
4.如果不同的话，则为{dp【i+1】【j】，dp【i】【j-1】，dp【i+1】【j-1】}中次数最少的那一个再+1了。

------------


故状态转移方程代码如下：

```
if(a[i]==a[j]) dp[i][j]=dp[i+1][j-1];//相同情况
        else dp[i][j]=min(dp[i+1][j],min(dp[i][j-1],dp[i+1][j-1]))+1;
```

最后输出dp【1】【n】则为正解。

------------


发现了吗？实际上代码很精简的。只要你有心，省选难度在你眼里都将是水题！

### PS:初始化会WA第七个点！

```
#include<bits/stdc++.h>
using namespace std;
int n,a[3001],dp[3001][3001];//dp[i][j]表示i到j对称的最小次数 
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(int l=2;l<=n;l++)
    for(int i=1;i+l<=n+1;i++)//枚举第i个人
    {
        int j=i+l-1;//枚举第j个人
        if(a[i]==a[j]) dp[i][j]=dp[i+1][j-1];
        else dp[i][j]=min(dp[i+1][j],min(dp[i][j-1],dp[i+1][j-1]))+1;
    }
    cout<<dp[1][n];
}
```

>PPS：这是@M_sea dalao給我们讲解的，深入浅出Orz

>PPPS：应该没有题解与这个相似吧？因为我们全机房都是听的M_sea dalao讲解的，所以可能机房会有与我相似的题解投上来QAQ

---

## 作者：HRLYB (赞：9)

[P3847 调整队形](https://www.luogu.org/problem/P3847)

比较典型的区间dp，我们设$a[i]$表示原数组中i位置的颜色，$f[i][j]$表示i到j区间变成回文串的最小改变次数.

我们可以发现，题目中的操作“在队伍中任两个人中间插入一个人”是不需要另外处理的，这种处理一定包含在之前的状态中，体现为之前状态“在队伍左或右边加一个人”的情况，所以当前我们只需要进行“在队伍左或右边加一个人”的操作就行了.

同理剔除在队伍中间某个人也不需要处理. 那么我们需要进行的就是区间两端的操作，而且可以发现，实际上剔除两端的某一个人和在两端增加一个人是等价的. 比如说如果当前我们已经算出了i到j-1的最小转换数，要求i到j的最小转换数，则我们既可以进行在i左边加一个$a[j]$的操作，也可以把$a[j]$删去.

综上所述，插入或删除的状态转移方程是：

>$f[i][j]=min(min(f[i][j-1]+1,f[i+1][j]+1),f[i][j])$

再考虑转换颜色的情况. 如果我们已求i+1到j-1的最小转换次数且$a[i]=[j]$，那么显然$f[i][j]=f[i+1][j-1]$；如果$a[i]!=a[j]$，只要把$a[i]$或者$a[j]$换成另一个即可.

状态转移方程为：

>$f[i][j]=min(f[i+1][j-1]+1,f[i][j])$

初始化记得给f赋极大值，再加上初始化即可ac.

```cpp
#include<bits/stdc++.h>
#define maxn 4010
using namespace std;
int n,a[maxn],f[maxn][maxn];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	memset(f,0x3f3f3f3f,sizeof f);
	for(int i=1;i<=n;i++){
		for(int j=i;j;j--){
			if(i==j){f[j][i]=0;continue;}//初始化1
			if(a[i]==a[j]&&j+1<=i-1){f[j][i]=f[j+1][i-1];continue;}
			else if(a[i]==a[j]&&j+1>i-1){f[j][i]=0;continue;}//初始化2
			f[j][i]=min(f[j][i],f[j+1][i]+1);
			f[j][i]=min(f[j][i],f[j][i-1]+1);//以上两种为在两端删去或加上某个人 
			f[j][i]=min(f[j][i],f[j+1][i-1]+1);//让某一个人换衣服 
		}
	}
	printf("%d\n",f[1][n]);
	return 0;
} 
```


这道题和P4170 涂色 都是区间dp的好题，推荐去做一做.

---

## 作者：06ray (赞：8)

这道题是道很明显的区间动态规划的题目啊。

大体思路如下:
1. 先定义两个数组，a与f，a数组存的是每个同学衣服颜色的编号，f是二维的，f[i][j]则表示第i个同学到第j个同学至少需要调整几次。

1. 读入合唱队的总人数n以及每个同学衣服的颜色（用a数组存）。

1. 确定边界。首先把f数组的每个值赋值为INF，然后从1到n循环，令f[i][i]=0; 如果第i个同学衣服的颜色与第i-1个同学衣服颜色相等，那么f[i-1][i]=0,否则f[i-1][i]=1。

1. 开始推状态转移方程。首先用循环变量l枚举每个区间的长度大小，接着用变量i枚举每个区间的起始位置，再定义变量j表示区间的终点，j=i+l;(自己可以想想为什么不枚举j，而枚举区间的长度l)，枚举好了区间，就开始写状态转移方程。先判断a[i]是否等于a[j],如果相等，那么 f[i][j]=max(f[i][j],f[i+1][j-1]); 如果不相等 f[i][j]=max(f[i][j],f[i+1][j-1]+1); 接下来，我们再考虑两种情况，如果让第i个人左边加一个与第j个人衣服颜色相同的人或者是把第j个人剔除掉，那么f[i][j]=min(f[i][j],f[i][j-1]+1); 如果让第j个人右边加一个与第i个人衣服颜色相同的人或者是把第i个人剔除掉，那么:f[i][j]=min(f[i][j],f[i+1][j]+1);

1. 最后输出f[1][n]即可。

时间复杂度为O(n²)。

下面贴代码：

### 注意：减少代码复制，共创美好洛谷！

```cpp
#include <iostream> //头文件不解释
#include <cstring>
using namespace std;
int a[3010];
int f[3010][3010];
int main()
{
    memset(f,0x7f,sizeof(f));//初始化一个较大的数
    int n;
    cin>>n;//读入n
    for(int i=1; i<=n; i++)
    {
        f[i][i]=0;//确定边界
        cin>>a[i];//读入第i个同学衣服颜色编号
        if(i!=1)
        {
            if(a[i]==a[i-1])
            {
                f[i-1][i]=0;
            }
            else
            {
                f[i-1][i]=1;
            }//同样是确定边界
        }	
    }
    for(int l=2; l<=n; l++)//l要不为1，因为l为1的区间都算过了
    {
        for(int i=1; i<=n; i++)
        {
            int j=l+i;
            if(j>n) continue;//如果j>n就继续
            if(a[i]==a[j]) f[i][j]=min(f[i][j],f[i+1][j-1]);
            f[i][j]=min(f[i][j],f[i+1][j-1]+1);
            f[i][j]=min(f[i][j],f[i][j-1]+1);
            f[i][j]=min(f[i][j],f[i+1][j]+1);//状态转移方程
        }
    }
    cout<<f[1][n];//输出
    return 0;
}
```

p.s 本人蒟蒻一枚，如果此题解有地方说的不好或是说错了，请在评论区告诉错误原因，谢谢！

---

## 作者：我不是小明 (赞：7)

操作一共有四种，但我们来分析一下：

其实操作1、2都是可以转换成操作3来做(没明白，再仔细想想) 

这样一来无非就两种操作了:1.改变一个数。2.删掉一个数。                    

题目问题是：求最少经过几步操作可以使原数列变为回文？

这样我们可以用f[j][k]表示把j到k变成回文所需的最小步数，则动态转移方程为：

```cpp
if(a[j]==a[k])
	f[j][k]=f[j+1][k-1];
else f[j][k]=min(min(f[j+1][k-1]+1,f[j+1][k]+1),f[j][k-1]+1);//分别表示改变一个数， 删掉a[j]，删掉a[k] 
```
AC代码:(~~若抄袭，您将成为作弊者233~~) 
```cpp 
#include<bits/stdc++.h>//万能头QAQ
using namespace std;
int n,a[3010],f[3010][3010];
int main()
{
	cin>>n;
	for(int j=1; j<=n; j++)
		cin>>a[j];
	for(int i=2; i<=n; i++)
		for(int j=1; j+i-1<=n; j++)
		{
			int k=j+i-1;
			if(a[j]==a[k])
				f[j][k]=f[j+1][k-1];
			else f[j][k]=min(min(f[j+1][k-1],f[j+1][k]),f[j][k-1])+1;
		}
	cout<<f[1][n];
	return 0;
}
```

---

## 作者：elijahqi (赞：3)

这题确实是一个动态规划的题目

一开始我的循环没想对，但是由于我们每一次都要利用上一次的状态所以我们最外层循环应该使用长度

f[i][j]表示i到j 满足条件区间内需要更改的最小值

假如a[i]==a[j]那么 f[i][j]直接从f[i+1][j-1]的状态继承过来

如果不等于那么f[i][j]=要么改变一个人的颜色（f[i+1][j-1]+1），要么f[i+1][j](踢掉i)或者f[i][j-1](踢掉j)

```cpp
#include <cstdio>
#include <cstring>
#define N 3300
inline int min(int x,int y){
    return x<y?x:y;
}
inline int read(){
    int x=0;char ch=getchar();
    while (ch<'0'||ch>'9') ch=getchar();
    while (ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();}
    return x;
}
int a[N],f[N][N],n;
int main(){
    freopen("3847.in","r",stdin);
    n=read();
    for (int i=1;i<=n;++i) a[i]=read();
    memset(f,0,sizeof(f));
    for (int i=2;i<=n;++i){
        for (int j=1;j<=n-i+1;++j){
            int z=i+j-1;
            if (a[z]==a[j]) f[j][z]=f[j+1][z-1];else  f[j][z]=min(f[j+1][z],min(f[j][z-1],f[j+1][z-1]))+1;
        }
    }
    printf("%d",f[1][n]);
    return 0;
}
```

---

## 作者：Link_Space (赞：2)

题目大意是你有一个数字序列，你可以进行以下操作：
1. 将一个数从序列中删去

2. 在序列任意位置加上一个数，数值任意

3. 改变序列中任意一个数的数值

题目需要求的就是将序列变为一个回文串的最小操作次数

那么很显然就是区间 DP 了，我们考虑区间 DP 的常规套路：

状态方程很好设置， $dp[i][j]$ 为将 $i-j$ 变为回文串的最小次数。

状态转移就分情况讨论。

假设现在 $i-1$ 到 $j+1$ 的序列已经通过操作变为了回文串，并且操作次数为 $dp[i+1][j-1]$

那么如果 $i-1$ 与 $j+1$ 位置上的数相等的话， $i-j$ 不需要操作也是一个回文串，所以 $dp[i][j]=dp[i-1][j+1]$


但是如果不相等的话，就需要操作了，此刻 $dp[i][j]$ 的值为 $min(dp[i + 1][j], min(dp[i][j - 1], dp[i + 1][j - 1])) + 1$

做到这里发现已经做完了......答案自然是 $dp[1][n]$

代码也很简单

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N = 5e3 + 5;
int n, a[N], dp[N][N];
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n;i++)
		scanf("%d", &a[i]);
	for (int l = 2; l <= n;l++)
	{
		for (int i = 1; i + l <= n + 1;i++)
		{
			int j = i + l - 1;
			if (a[i] == a[j])
				dp[i][j] = dp[i + 1][j - 1];
			else
				dp[i][j] = min(dp[i + 1][j], min(dp[i][j - 1], dp[i + 1][j - 1])) + 1;
		}
	}
	printf("%d\n", dp[1][n]);
}
```


---

## 作者：xiezheyuan (赞：1)

[也许有更好的阅读体验](https://www.cnblogs.com/zheyuanxie/p/p3847.html)

## 简要题意

给出一个长度为 $n$ 的序列 $A$，你需要执行下面的操作，将这个序列变成回文序列：

- 在序列左右侧或中间插入一个元素，元素数值任意。
- 删除一个元素。
- 更改一个元素的值。

$1 \le n,A_i \le 3000$

## 思路

首先我们设 $f_{i,j}$ 为区间 $[i,j]$ 变成回文序列的操作次数。

如果每一次转移的时候都重新计算，那肯定是不合适的，这里我们做一个假设，假设如果枚举到了 $[i,j]$，那么 $[x,y](i \lt x \le y \lt j)$（子区间）已经变成了回文序列了。

那么如果 $A_i=A_j$，那么不必进行操作，也就是 $f_{i,j}=f_{i+1,j-1}$。(区间 $[i,j]$ 去头去尾后得到 $[i+1,j-1]$）

如果 $A_i \neq A_j$，那么我们一定需要操作：

- 如果是更改元素的值，那么一定要更改 $i$ 或者 $j$ 的，比如 $A_i = A_j$ 或 $A_j = A_i$，这种情况就是继承以前的 $f_{i+1,j-1}$。
- 如果是删除元素的值，那么也一定要删除 $i$ 或者 $j$。删除 $i$ 就是 $f_{i+1,j}$，删除 $j$ 就是 $f_{i,j-1}$（谁被删除了就删掉谁）

另外还要记住，执行了操作操作次数就要加上 $1$。

至此，我们已经推出了状态转移方程，整理如下：

$$
f_{i,j}=\left\{
\begin{aligned}
& f_{i+1,j-1} (A_i = A_j) \\
& \min(f_{i+1,j-1},f_{i+1,j},f_{i,j-1})+1 (A_i \neq A_j)
\end{aligned}
\right.
$$

最后我们来讨论一下如何做到一开始我们的假设。我怕们可以枚举区间长度 $L$，再枚举区间左端点 $i$，这样 $j=i+L-1$，子区间的长度必定小于 $L$，假设得到满足。

该算法时间复杂度 $O(n^{2})$，可以通过本题。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int n;
int a[3005],f[3005][3005];

inline int min(int x,int y,int z){
	return min(x,min(y,z));
}

signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int length=2;length<=n;length++){
		for(int l=1,r=l+length-1;l<=n&&r<=n;l++,r++){
			if(a[l]==a[r]){
				f[l][r]=f[l+1][r-1];
			}
			else{
			    f[l][r]=min(f[l+1][r-1],f[l+1][r],f[l][r-1])+1;
			}
		}
	}
	cout<<f[1][n];
	return 0;
}
```

[AC Record](https://www.luogu.com.cn/record/85015134)

---

## 作者：Coros_Trusds (赞：1)

定义 $dp(i,j)$ 或 $dp[i][j]$ 表示使区间 $[i,j]$ 内对称需要的最少次数。

$clr[i]$ 表示第 $i$ 个同学的颜色。

$\rm Firstly$，我们可以按照区间 DP 的常见步骤来算：

用一个双重循环，外层枚举长度，内层枚举左右端点。

$\rm Secondly$，题目给出了四种调整方案，简化来说就是：

1. 在队伍任意一端加一个人。

2. 在队伍中间插入一个人。

3. 删掉一个人

4. 把某一个人换成另一个人。

操作 $1$ 和操作 $2$ 其实是一样的，因为是一步一步来的，所以操作$2$ 的这种状态包括在之前插入的状态里面了。

并且操作 $1$ 和 操作 $3$ 本质也是相同的，假设已经求出了  $[i,j-1]$ 的最少次数，那么想要让 $[i,j]$ 也保持对称，可以删去最右边的 $clr[j]$ ，也可以在 $i$ 的左边新增一个等于 $clr[j]$ 的数。两种方案的结果是相同的。

所以实质上总共只剩下两种方案：

1. 在队伍任意一段加一个人。

2. 把某一个人换成另一个人。

对于一个区间 $[i,j]$ ：

如果 $clr[i]=clr[j]$ ，那么要想继续让 $dp[i][j]$ 保持对称性，我们可以让这个区间等于 $dp(i+1)(j-1)$ 。

如果 $clr[i]\not=clr[j]$ ，那么可以删掉左右任意一端，也可以在另一端新添一个相同的数。



若 $a[i]=a[j]$ ，则 $dp[i][j]=dp[i+1][j-1]$ 。

否则，$dp(i,j)=\min\{dp(i+1,j-1)+1,dp(i+1,j)+1,dp(i,j-1)+1\}$

AC 代码：

```cpp
//2021/5/21

#include <cstdio>

using namespace std;

const int ma=5005;

int a[ma];

int dp[ma][ma];//dp[i][j]:区间i-j的对称的最小次数 

inline int min(int x,int y,int z)
{
	int t=(x<y)?x:y;
	
	return (t<z)?t:z;
}

int main(void)
{
	int n;
	
	scanf("%d",&n);
	
	for(register int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	
	for(register int len=1;len<=n;len++)
	{
		for(register int i=1;i+len-1<=n;i++)
		{
			int j=i+len-1;
			 
			if(a[i]==a[j])
			{
				dp[i][j]=dp[i+1][j-1];
			}
			
			else
			{
				dp[i][j]=min(dp[i+1][j],dp[i][j-1],dp[i+1][j-1])+1;
			}
		}
	}
	
	printf("%d\n",dp[1][n]);
	
	return 0;
}
```

---

## 作者：MC_Launcher (赞：1)

### 一个披着~~好看~~外衣的dp题

------------
让我们来揭开表面看真相吧

_"题目描述_
 
_1、在队伍左或右边加一个人（衣服颜色依要求而定）；_
 
_2、在队伍中任两个人中间插入一个人（衣服颜色依要求而定）；_
 
_3、剔掉一个人；_

_4、让一个人换衣服颜色；"_


------------
对于题目要求的操作，其实都是相同的

插入一个人=删去一个人=换衣服（至于为什么自己看完剩下就知道）

我们用一个$dp[i][j]$数组来表示将这个数从第$i$个数字到第$j$个数字变为回文数的最小代价

状态转移方程献上

```cpp
if(a[i]==a[j])
{
	dp[i][j]=dp[i+1][j-1];//如果两个数字相同就可以不更改，即代价不改变，是减去头尾二数的区间的最小代价
}
else
{
	dp[i][j]=min(dp[i+1][j],min(dp[i][j-1],dp[i+1][j-1]))+1;//否则取减去头一个数，或尾一个数，抑或去掉头尾区间的最小代价+1，因为题目中的操作保证可以一次将一个回文数+一个数由一次改变变为回文数
}
```

之前min里写了3个数结果报错了

最后其实输出$dp[1][n]$即可，表示从$1$到$n$变为回文数的最小代价，即将输入的这个数变为回文数的最小步骤

最后代码献上，在此不坑大家啦，自觉

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,kkk;
	cin>>n;
	int a[n+1]={};
	for(int i=1;i<=n;i++)cin>>a[i];
	int dp[n+1][n+1]={};
	for(int chang=2;chang<=n;chang++)
	{
		for(int i=1;i<=n-chang+1;i++)
		{
			kkk=i+chang-1;
			if(a[i]==a[kkk])
			{
				dp[i][kkk]=dp[i+1][kkk-1];
			}
			else
			{
				dp[i][kkk]=min(dp[i+1][kkk],min(dp[i][kkk-1],dp[i+1][kkk-1]))+1;
			}
		}
	}
	cout<<dp[1][n];
 } 
```

嘿嘿，蛮简单的嘛，没有注释你们也能看懂吧，题目数据很善良，直接一个一个输入

#### 拒绝抄袭，从你我做起

#### ——惨遭禁言的MCL

---

## 作者：gary2005 (赞：1)

题解那么少，还全是DP的，那么我来讲讲我的记忆话搜索

首先设dp[l][r]表示从[l,r]组成回文的最小代价

所以我们有了转移方程

```cpp
dp[l][r]---->[l,r]min val

if(a[l]==a[r])//两个端点相同，只要看中间部分
dp[l][r]=min(dp[l][r],dp[l+1][r-1]);

else{
f[l][r]=min(min(dp[l+1][r]+1/*踢掉左端点*/,dp[l][r-1]+1)/*踢掉右端点*/,
min(dp[l+1][r-1]+1/*变色，将a[l]与a[r]变为同种颜色*/,dp[l][r]));
}
```
好CODE：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=3000+10;
int n,a[MAXN],dp[MAXN][MAXN];
int dfs(int l,int r){
	if(l==r) return 0;
	if(dp[l][r]!=0x3f3f3f3f) return dp[l][r];
	if(r-l==1){
		if(a[r]==a[l]) return 0;
		else return 1;
	}
	if(a[l]==a[r]){
		dp[l][r]=min(dp[l][r],dfs(l+1,r-1));
	}
	else{
		dp[l][r]=min(min(dp[l][r],dfs(l+1,r-1)+1),min(dfs(l+1,r)+1,dfs(l,r-1)+1));
	}
	return dp[l][r];
}
int main(){
	memset(dp,0x3f,sizeof(dp));
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	printf("%d\n",dfs(1,n));
	return 0;
}
```

---

## 作者：Exschawasion (赞：0)

很容易看出这是区间 dp。

因为要求步数最小，一个显然的贪心策略就是：只在**需要的时候**执行添加、删除或修改操作。思考后，还会发现一个事实：判定回文串可以从两头向中间判定，那么计算回文串也可以从两头向中间。

设 $s_x$ 表示字符串的第 $x$ 个字符、$f[l][r]$ 表示将 $[l,r]$ 区间变为回文串的最小步骤。根据上面推出来的结论，考虑转移：

- $s_l$ 到 $s_r$ 本身就是回文串则答案为 $0$；
- $s_l=s_r$ 则转移到 $f[l+1][r-1]$ 。即两边相等，直接往中间走；
- $s_l \not =s_r$ 的情况：
	- 转移到 $f[l][r-1]$，在左边加一个人；
	- 转移到 $f[l+1][r]$，在右边加一个人；
	- 转移到 $f[l+1][r-1]$，把 $s_l$ 或 $s_r$ 修改成同一个字符；
	- 如果 $s_{l+1}=s_r$，转移到 $f[l+2][r-1]$，说明可以在左边删除一个人（删除一个人，然后两边相等所以再往内一层，因此 $l$ 加的是 $2$）；
	- 如果 $s_{l}=s_{r-1}$，转移到 $f[l+1][r-2]$，说明可以在右边删除一个人。
	- 上面五种情况取最小值即可。

如果拓扑序不太好找，可以用记忆化搜索解决。判定回文串有更高效的做法，这里使用了暴力+记忆化来尽可能加快。

代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=3000+5;
int a[maxn],n;
int ok[maxn][maxn];
bool chk(int L,int R){
	if(~ok[L][R])return ok[L][R];
	while(L<=R)if(a[L]!=a[R])return ok[L][R]=0;else L++,R--;
	return ok[L][R]=1; 
}
int f[maxn][maxn];
int dp(int L,int R){
	if(~f[L][R])return f[L][R];
	if(chk(L,R))return 0;
	if(a[L]==a[R])return f[L][R]=dp(L+1,R-1);
	int ans=0x3f3f3f3f;
	ans=min(ans,dp(L,R-1)+1);
	ans=min(ans,dp(L+1,R)+1);
	ans=min(ans,dp(L+1,R-1)+1);
	if(a[L+1]==a[R])ans=min(ans,dp(L+2,R-1)+1);
	if(a[R-1]==a[L])ans=min(ans,dp(L+1,R-2)+1);
	return f[L][R]=ans;
}
int main(){
	cin>>n;
	memset(ok,-1,sizeof(ok));
	memset(f,-1,sizeof(f));
	for(int i=1;i<=n;i++)cin>>a[i];
	cout<<dp(1,n);
	return 0;
}
```


---

## 作者：osfly (赞：0)

典型到不能再典型的区间 dp 了。

观察四种操作，考虑到加一个数和删一个数的情况相同，所以无非就是：

1. 删一个数。

2. 改一个数。

设 $dp[l][r]$ 为让区间 $l\sim r$ 对称（变成回文串）的最少次数。

可以很快地得出状态转移方程：
	
情况 $1$：如果 $a_l=a_r$，则 $dp[l][r]=dp[l+1][r-1]$（该区间两端相同，令中间为回文串即可）。

情况 $2$：如果 $a_l\not=a_r$，我们则有三种方法变成回文串：

1. 改变 $l$ 或 $r$ 的值，此时 $dp[l][r]=dp[l+1][r-1]+1$。

2. 删除 $l$，此时 $dp[l][r]=dp[l+1][r]+1$。

3. 删除 $r$，此时 $dp[l][r]=dp[l][r-1]+1$。

情况 $2$ 取三种方法的最小值即可。

枚举区间长度 $len$ 与区间左端点 $l$，时间复杂度为 $O(n^2)$，可以通过此题。

```cpp
#include<cstdio>
int min(int a,int b)
{
	return a<b?a:b;
}
int min(int a,int b,int c)
{
	return min(a,min(b,c));
}
int n;
int a[3010];
int dp[3010][3010];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int len=2;len<=n;len++)
		for(int l=1,r=l+len-1;r<=n;l++,r++)
		{
			if(a[l]==a[r]) dp[l][r]=dp[l+1][r-1];
			else dp[l][r]=min(dp[l+1][r-1],dp[l+1][r],dp[l][r-1])+1;
		}
	printf("%d",dp[1][n]);
	return 0;
}
```

---


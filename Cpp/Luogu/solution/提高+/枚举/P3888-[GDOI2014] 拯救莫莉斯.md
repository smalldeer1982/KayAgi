# [GDOI2014] 拯救莫莉斯

## 题目描述

莫莉斯·乔是圣域里一个叱咤风云的人物，他凭借着自身超强的经济头脑，牢牢控制了圣域的石油市场。

圣域的地图可以看成是一个 $n\times m$ 的矩阵。每个整数坐标点 $(x, y)$ 表示一座城市（$1\le x\le n,1\le y\le m$）。两座城市间相邻的定义为：对于城市 $(A_x, A_y)$ 和城市 $(B_x, B_y)$，满足 $(A_x - B_x)^2 + (A_y - B_y)^2 = 1$。

由于圣域的石油贸易总量很大，莫莉斯意识到不能让每笔石油订购单都从同一个油库里发货。为了提高效率，莫莉斯·乔决定在其中一些城市里建造油库，最终使得每一个城市 $X$ 都满足下列条件之一：

1. 该城市 $X$ 内建有油库.
2. 某城市 $Y$ 内建有油库，且城市 $X$ 与城市 $Y$ 相邻。

与地球类似，圣域里不同城市间的地价可能也会有所不同，所以莫莉斯想让完成目标的总花费尽可能少。如果存在多组方案，为了方便管理，莫莉斯会选择建造较少的油库个数。


## 说明/提示

对于 $30\%$ 数据满足 $n \times m \le 25$;   
对于 $100\%$ 数据满足 $n \times m \le 50,0 \le F_{i, j} \le 10 ^ 5$。


## 样例 #1

### 输入

```
3 3
6 5 4
1 2 3
7 8 9```

### 输出

```
3 6```

# 题解

## 作者：喵仔牛奶 (赞：7)

$nm\leq50,m\leq n$ 说明 $m\leq7$，一眼状压。

设 $f_{i,j,k}$ 为第 $i$ 行状态为 $j$，$i-1$ 行状态为 $k$ 且 $1$ 至 $i-1$ 行全部有油库相邻的最小代价， $dp_{i,j,k}$ 为最小个数。

那么 $f$ 的转移方程显然：

$$f_{i,j,k}=\min_{0\leq l<2^m}\{f_{i-1,k,l}+sum_{i,j}\text{ }(\#)\}$$

其中 $sum_{i,j}$ 是第 $i$ 行状态为 $j$ 的花费， $dp$ 跟着 $f$ 转移一下就可以了。

$\#$ 是转移的条件，上面挤不下了，这里来写：

对于 $f_{i-1,k,l}$，第 $1$ 行至第 $i-2$ 行一定全部有油库相邻，只要考虑第 $i-1$ 列，所以 $\#$ 是 ```(j|k|l|k<<1|k>>1)```。

代码实现如下：

```cpp
#include <bits/stdc+.h>
using namespace std;
const int N = 10, M = 55;
int f[M][1 << N][1 << N], dp[M][1 << N][1 << N], sum[M][1 << N], a[M][N], n, m, ans1 = INT_MAX, ans2 = INT_MAX;
int main() {
	cin >> n >> m;
	memset(f, 0x3f, sizeof f);
	for (int i = 1; i <= n; i ++)
		for (int j = 1; j <= m; j ++)
			cin >> a[i][j];
	for (int i = 1; i <= n; i ++)
		for (int j = 0; j < 1 << m; j ++)
			for (int k = 0; k < m; k ++)
				if (j & 1 << k) sum[i][j] += a[i][k + 1];
	for (int i = 0; i < 1 << m; i++)
		f[1][i][0] = sum[1][i], dp[1][i][0] = __builtin_popcount(i);
	for (int i = 2; i <= n; i ++)
		for (int j = 0; j < 1 << m; j ++)
			for (int k = 0; k < 1 << m; k ++)
				for (int l = 0; l < 1 << m; l ++)
					if (((j | k | l | k << 1 | k >> 1) & (1 << m) - 1)== (1 << m) - 1) {
						int t = f[i - 1][k][l] + sum[i][j], p = dp[i - 1][k][l] + __builtin_popcount(j);
						if (f[i][j][k] > t || f[i][j][k] == t && dp[i][j][k] > p)
							f[i][j][k] = t, dp[i][j][k] = p;
					}
	for (int i = 0; i < 1 << m; i ++)
		for (int j = 0; j < 1 << m; j ++)
			if (((i | j | i << 1 | i >> 1) & (1 << m) - 1) == (1 << m) - 1)
				if (ans1 > f[n][i][j] || f[n][i][j] == ans1 && dp[n][i][j] < ans2)
					ans1 = f[n][i][j], ans2 = dp[n][i][j];
	cout << ans2 << ' ' << ans1 <<'\n';
    system("pause")
	return 0;
}
```

---

## 作者：Pine (赞：6)

# 状压DP

看数据范围$n*m \le 50$&&$m\le n$ 我们发现$m \le 7$完全可以状压

而第i行只会受第i-1和i+1行的影响所以我们只记录两行状态即可

令$f[i][j][k]$表示第$i$行状态为$j$第$i-1$行状态为$k$且前$i-1$都已经完全覆盖的最小总花费

令$g[i][j][k]$则表示所需的最小油库

令$cost(i+1, p) \rightarrow$在第i+1行放p的状态所需的花费，预处理一下就可以了

$f[i+1][p][j] = f[i][j][k] + cost(i+1, p)$

$f[i][j][k]$转移到$f[i+1][p][j]$的条件为:

$$j|k|p|(j\ll1)|(j\gg1)\&(2^m-1) == (2^m-1)$$

表示第i行被完全覆盖

在更新$f$数组的同时顺便更新一下$g$数组就可以了

$ans1=Min\{f[n+1][0][x]\}(x\in[0, 2^m-1])$

ans1为最小花费，而最小油库数则是在最小花费的基础上对于$g$数组取$min$即可

# 代码
```
#include <bits/stdc++.h>
#define R register
#define eps 1e-12
#define INF (1<<30)
#define LL long long
#define LINF (1ll<<60)
#define MM(x, y) memset(x, y, sizeof x)
#define Fo(i, x, y) for(R int i=x; i<=y; ++i)
#define Ro(i, x, y) for(R int i=x; i>=y; --i)
using namespace std;
template<typename T> inline T Max(R T x, R T y) {return x > y ? x : y;}
template<typename T> inline T Min(R T x, R T y) {return x < y ? x : y;}
template<typename T> inline void in(R T &x)
{
	static int ch; static bool flag;
	for(flag=false, ch=getchar(); ch<'0'||ch>'9'; ch=getchar()) flag |= ch=='-';
	for(x=0; ch>='0'&&ch<='9'; ch=getchar()) x = (x<<1) + (x<<3) + ch - '0';
	x = flag ? -x : x;
}
/*************************************Samle*************************************/

int n, m, A[55][55], M, sum[55][130], ss[130];
int f[55][130][130], g[55][130][130];

int main()
{
	in(n); in(m); Fo(i, 1, n) Fo(j, 1, m) in(A[i][j]);
	M = (1<<m)-1;
	Fo(i, 1, n)
	{
		Fo(j, 0, M)
		{
			sum[i][j] = 0; R int fl = 0;
			Fo(k, 1, m) if(j&(1<<(k-1)))
			{
				sum[i][j] += A[i][k]; ++fl;
			}
			ss[j] = fl;
		}
	}
	MM(f, 127/3); MM(g, 127/3);
	Fo(i, 0, M) f[1][i][0] = sum[1][i], g[1][i][0] = ss[i];
	Fo(i, 2, n+1)
	{
		Fo(j, 0, M) Fo(k, 0, M) // j->i-1  k->i-2
		{
			Fo(p, 0, M) if(((j | k | p | (j<<1) | (j>>1)) & M) == M)
			{
				if(f[i-1][j][k] + sum[i][p] < f[i][p][j])
				{
					f[i][p][j] = f[i-1][j][k] + sum[i][p];
					g[i][p][j] = g[i-1][j][k] + ss[p];
				}
				else if(f[i-1][j][k] + sum[i][p] == f[i][p][j])
				{
					g[i][p][j] = Min(g[i][p][j], g[i-1][j][k] + ss[p]);
				}
			}
		}
	}
	R int ans = INF, oo = INF;
	Fo(i, 0, M) if(f[n+1][0][i] < ans) ans = f[n+1][0][i], oo = g[n+1][0][i]; else if(f[n+1][0][i] == ans) oo = Min(oo, g[n+1][0][i]);
	printf("%d %d\n", oo, ans);
	return 0;
}
```

---

## 作者：asuldb (赞：3)

可能我的状态比较鬼畜，应该没有人这么写

设$dp[i][j][k]$表示在第$i$行，放置油库的状态为$j$，实际上周围已经有油库或者本身有油库的状态为$k$的时候的最小花费

由于我们是按照行来$dp$的，所以这里的周围有油库只有三种可能

1. 上一行的这个位置有油库

1. 这个位置本身有油库

1. 同一行上相邻位置有油库

显然如果上一行的某一个状态里，有一些位置周围没有油库，那么就说明接下来这一行的对应位置就必须都放上油库，其余剩下的位置可以放油库也可以不放

于是我们可以枚举子集进行转移

代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define re register
#define lowbit(x) ((x)&(-x))
#define min std::min
int n,m;
int map[51][51];
int dp[51][129][129],s[51][129][129];
int val[51][129],num[129];
inline int read()
{
	char c=getchar();
	int x=0;
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<3)+(x<<1)+c-48,c=getchar();
	return x;
}
inline int logg(int x)
{
	int tot=0;
	while(x) tot++,x>>=1;
	return tot;
}
inline int cnt(int x)
{
	int tot=0;
	while(x) tot++,x-=lowbit(x);
	return tot;
}
int M;
inline int solve(int x)
{
	return M&(((x<<1)|x)|((x>>1)|x));
}
inline void merge(int a,int b,int c,int v,int t,int x,int y,int z)
{
	if(dp[a][b][c]+v>dp[x][y][z]) return;
	if(dp[a][b][c]+v<dp[x][y][z])
	{
		dp[x][y][z]=dp[a][b][c]+v;
		s[x][y][z]=s[a][b][c]+t;
		return;
	}
	s[x][y][z]=min(s[x][y][z],s[a][b][c]+t);
}
int main()
{
	n=read(),m=read();
	for(re int i=1;i<=n;i++)
		for(re int j=1;j<=m;j++)
			map[i][j]=read();
	M=(1<<m)-1;
	for(re int i=1;i<=n;i++)
		for(re int j=1;j<=M;j++)
			val[i][j]=val[i][j-lowbit(j)]+map[i][logg(lowbit(j))];
	for(re int i=1;i<=M;i++) num[i]=cnt(i);
	memset(dp,20,sizeof(dp));
	for(re int i=0;i<=M;i++)
		dp[1][i][solve(i)]=min(dp[1][i][solve(i)],val[1][i]),s[1][i][solve(i)]=num[i];
	for(re int i=2;i<=n;i++)
	{
		for(re int j=0;j<=M;j++)
		{
			int p=M^j;
			for(re int k=p;k;k=(k-1)&p)
			{
				if(dp[i-1][j][k|j]==336860180) continue;
				int d=k|j,s=M^d;
				for(re int t=d;t;t=(t-1)&d)
					merge(i-1,j,d,val[i][s]+val[i][t],num[s]+num[t],i,t|s,j|solve(t)|solve(s));
				merge(i-1,j,d,val[i][s],num[s],i,s,j|solve(s));
			}
			for(re int k=0;k>-1;k--)
			{
				if(dp[i-1][j][k|j]==336860180) continue;
				int d=k|j,s=M^d;
				for(re int t=d;t;t=(t-1)&d)
					merge(i-1,j,d,val[i][s]+val[i][t],num[s]+num[t],i,t|s,j|solve(t)|solve(s));
				merge(i-1,j,d,val[i][s],num[s],i,s,j|solve(s));
			}
		}
	}
	int ans=999999999;
	for(re int i=0;i<=M;i++)
		ans=min(ans,dp[n][i][M]);
	int T=999999999;
	for(re int i=0;i<=M;i++)
	if(dp[n][i][M]==ans) T=min(T,s[n][i][M]);
	printf("%d %d\n",T,ans);
	return 0;
}
```

---

## 作者：Mobius127 (赞：1)

~~这种萌萌题给个蓝就差不多了，出题人你说是不是？~~

[题传](https://www.luogu.com.cn/problem/P3888)

这个题我一开始还以为是计算几何（

$(A_x-B_x)^2 + (A_y-B_y)^2=1$ 表示的是以 $(A_x, A_y)$ 的点为圆心，半径为 1 的圆上所有的 $B$ 点，但放在网格图上显然就是上下左右四个位置了。

发现 $nm \le 50 \wedge m \le n$，那么 $m$ 大概到 $7$，直接状压。

显然某一行的状态只与上下两层有关，设 $f_{x, T, G}$ 为第 $x$ 层状态为 $T$，第 $x-1$ 层状态为 $S$ 的最少花费，那么状态转移方程为：

$$f_{x, T, G}=\min_{S|T|G=R} f_{x-1, S, T}+cost(x, G)$$

至于最少放置个数什么的，多加一维即可。

考虑到最后一层的边界问题，直接在 $n+1$ 层多进行一次 DP，最终情况就是 $\min f_{n+1, S, 0}$。

复杂度 $O(n2^{2m})$。

### Code：

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <cctype>
#include <cmath>
using namespace std;
typedef long long ll;
const int INF=0x3f3f3f3f;
inline int read(){
	char ch=getchar();int x=0, f=1;
	while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
inline void write(int x){
    if(x<0) putchar('-'), x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
const int N=55;
const int MxS=1<<7;
int n, m, a[N][N], R;
int cnt[MxS], cost[N][MxS];
int f[N][MxS][MxS], ans[N][MxS][MxS];
int Mncost=INF, Mncnt=INF;
bool check(int S, int T, int G){
	if((((S|T|G|(T>>1)|(T<<1)))&(R-1))==R-1) return 1;
	return 0;
}
void DP(int x, int S, int T, int G){
	if(f[x][T][G]>f[x-1][S][T]+cost[x][G])
		f[x][T][G]=f[x-1][S][T]+cost[x][G],
		ans[x][T][G]=ans[x-1][S][T]+cnt[G];
	else if(f[x][T][G]==f[x-1][S][T]+cost[x][G])
		ans[x][T][G]=min(ans[x][T][G], ans[x-1][S][T]+cnt[G]);
}
signed main(){
	memset(f, 127, sizeof(f));
	memset(ans, 127, sizeof(ans));
	n=read(), m=read(), R=1<<m;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=m; j++)
			a[i][j]=read();
	for(int S=0; S<R; S++)
		cnt[S]=cnt[S>>1]+(S&1);
	for(int i=1; i<=n; i++)
		for(int S=0; S<R; S++)
			for(int j=0; j<m; j++)
				if(S&(1<<j))
					cost[i][S]+=a[i][j+1];
			
	for(int S=0; S<R; S++)
		f[1][0][S]=cost[1][S], ans[1][0][S]=cnt[S];
	for(int i=2; i<=n+1; i++)
		for(int S=0; S<R; S++)//i-2
			for(int T=0; T<R; T++)//i-1
				for(int G=0; G<R; G++)//i
					if(check(S, T, G))
						DP(i, S, T, G);				
	for(int S=0; S<R; S++)
		if(f[n+1][S][0]<Mncost) 
			Mncost=f[n+1][S][0], Mncnt=ans[n+1][S][0];
		else if(f[n+1][S][0]==Mncost) 
			Mncnt=min(Mncnt, ans[n+1][S][0]);
	printf("%d %d\n", Mncnt, Mncost);
	return 0;
}


```


---

## 作者：liangbowen (赞：0)

[problem](https://www.luogu.com.cn/problem/P3888) & [blog](https://www.cnblogs.com/liangbowen/p/17664121.html)。

这怎么评到紫上去的啊？差不多就个上位绿吧 /qd。

---

首先出题人非常 low。为什么这样说呢？因为 $nm\le 50,m\le n$ 就是在说 $m\le 7$，出题人为了不让你一眼秒掉这一题，就用这种猥琐的方法写数据范围，是不是很傻逼呢。

然后就是状压 DP 板板题了，判断合法状态只需要知道当前行与上一行的选择情况，于是 $dp_{i,s,t}$ 表示当前是第 $i$ 行，当前行状态为 $s$，上一行状态为 $t$，答案（同时记录代价和个数）。

对于连续的三行 $s,t,p$，合法转移即：中间行的任意数，要么自己选了，要么相邻的四个位置选了。具体转移
+ $dp_{i,s,t}=\min\limits_{p}\{dp_{i-1,t,p}+(\text{*})\}$。
+ 转移最小花费时 $(\text{*})=\sum\limits_{\text{select j}}^{\text{in line }i} a_{i,j}$（显然可以预处理）。
+ 转移最小个数时 $(\text{*})=\sum\limits_{\text{select j}}^{\text{in line }i} 1$（即二进制下 $1$ 的个数）。

初始化 $+\infty$，第一行直接算出来，后面 DP，统计答案时枚举最后一行的合法状态，求最优决策即可。

[code](https://www.luogu.com.cn/paste/eznqkzzn)，时间复杂度 $O(n2^{3m})$。由于 $n,m$ 呈反比例关系，所以 $n,m$ 显然不可能同时取到最大值，因此很轻松就跑过去啦。


---

## 作者：louhao088 (赞：0)

# 题意
在一矩阵中，选取和尽量小的数，使其满足每个位置上下左右中至少有一个选。

## 思路

由于$n*m<=50$,$n>=m $,易证 $m<=7$。

故选用状压DP

f[i][j][k]表示第i-1行状态为j第i行状态为k的方案。

## 注意 

1. 判断时有可能会超过$2^m$,所以对其判断要&($2^m$-1).


2. 最后统计时也要判断

3. 数组第一维要超过50不然会$RE$

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[55][55],f[55][(1<<8)+1][(1<<8)+1],s[55][(1<<8)+1][(1<<8)+1],ans=0x3f3f3f3f,size;
int getsum(int i,int x)//求花费 
{
	int sum=0,t=0;
	while(x)
	{
		t++;
		if(x%2==1)sum+=a[i][t];
		x=x/2;
	}
	return sum;
}
int gets(int x)//求个数 
{
	int sum=0,t=0;
	while(x)
	{
		t++;
		if(x%2==1)sum++;
		x=x/2;
	}return sum;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	memset(f,0x3f,sizeof f);
	for(int i=0;i<(1<<m);i++)
		f[1][0][i]=getsum(1,i),s[1][0][i]=gets(i);
	for(int i=2;i<=n;i++)
	{
		for(int j=0;j<(1<<m);j++)//第i-2行状态 
		{
			for(int k=0;k<(1<<m);k++)//第i-1行状态 
			{
				if(f[i-1][j][k]==0x3f3f3f3f)continue;
				for(int l=0;l<(1<<m);l++)//第i行状态 满足前i-1行成立 
				{
					if((k|l|j|(k>>1)|(k<<1)&((1<<m)-1))==((1<<m)-1))//上一行，下一行，本行左右,
					{
						if(f[i][k][l]>f[i-1][j][k]+getsum(i,l))//转移
						{
							f[i][k][l]=f[i-1][j][k]+getsum(i,l);
							s[i][k][l]=s[i-1][j][k]+gets(l);
						}
						else if(f[i][k][l]==f[i-1][j][k]+getsum(i,l))
						{
							s[i][k][l]=min(s[i][k][l],s[i-1][j][k]+gets(l));
						}
					} 
				}
			}
		}
	}
	for(int i=0;i<(1<<m);i++)
		for(int j=0;j<(1<<m);j++)
		{
			if((i|j|(j>>1)|(j<<1)&((1<<m)-1))==((1<<m)-1))//判断
			{
				if(ans>f[n][i][j])ans=f[n][i][j],size=s[n][i][j];
				else if(ans==f[n][i][j])size=min(size,s[n][i][j]);
			}
		}
	cout<<size<<" "<<ans<<endl;
    return clock();
}
```




---


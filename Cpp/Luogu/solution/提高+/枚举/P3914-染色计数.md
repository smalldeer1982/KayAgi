# 染色计数

## 题目描述

有一颗$N$个节点的树，节点用$1,2,\cdots,N$编号。你要给它染色，使得相邻节点的颜色不同。有$M$种颜色，用$1,2,\cdots,M$编号。每个节点可以染$M$种颜色中的若干种，求不同染色方案的数量除以($10^9 + 7$)的余数。


## 说明/提示

• 对于30% 的数据，$1 \le N \le 10; 1 \le M \le 4$；

• 对于60% 的数据，$1 \le N \le 200; 1 \le M \le 200$；

• 对于100% 的数据，$1 \le N \le 5000; 1 \le M \le 5000$。


## 样例 #1

### 输入

```
2 2
1 1
2 1 2
1 2```

### 输出

```
1```

# 题解

## 作者：Youngsc (赞：10)

[Youngsc](http://youngscc.github.io/)

又WA又T又MLE了一节课终于搞出来了这道题。

这道题很显然是一道树形DP，而且用到了组合数学中的乘法原理。

令$f[i][j]$表示以$i$为根的这棵子树在$i$为颜色$j$的时候的方案数，根据乘法原理可得$f[i][j]=πf[k][c]$ 其中$k$是$i$的所有儿子，$c$是所有与$j$不同的颜色。

因此我们可以很容易相处一个$O(n^3)$的是算法：枚举所有点，枚举它的颜色，枚举每一个儿子，枚举儿子的颜色，因为一个点只有一个父亲，所以枚举儿子的那一层加上枚举每一个点一共是$O(n)$的。

回过头来再看数据$n<=5000$,$m<=5000$，上述的算法似乎运行起来很吃力。那我们需要向一个办法去将复杂度变成$O(n^2)$，仔细思考后我们会发现，其实枚举儿子那一层是没有必要的，因为我只要颜色不相同的总数，与其$O(m)$地去求和，不如之前在枚举到它的时候就处理好所有的和，然后$O(1)$地去剪掉这个颜色，从而求出除去这个颜色外的方案数，达到$O(n^2)$的复杂度。

这道题还是很不错的，这种思想在很多时候都能用得上。


### 代码在这里


```cpp
# include <algorithm>
# include <iostream>
# include <cstring>
# include <cstdio>
# include <vector>
# include <cmath>
# define R register
# define mod 1000000007

using namespace std;

int e,n,m,f[5010][5010],h[5010],tot[5010],sum[5010],x,y,d;
struct pp{int v,pre;}ed[10010];

inline void in(R int &a){
    R char c = getchar();R int x=0, f=1;
    while(!isdigit(c)) {if(c == '-') f=-1; c = getchar();}
    while(isdigit(c)) x = (x<<1)+(x<<3)+c-'0',c = getchar();
    a=x*f;
}

inline void add(R int x,R int y){
    ed[++e] = (pp){y,h[x]};
    h[x] = e;
}

inline void dfs(R int fa,R int x){//树形DP一般用DFS来实现
    for(R int i=h[x]; i; i=ed[i].pre)
    {
        R int p = ed[i].v;
        if(p == fa) continue;
        dfs(x,p);
    }
    for(R int j=1; j<=m; ++j)
    {
        if(!f[x][j]) continue;//没有这种颜色
        for(R int i=h[x]; i; i=ed[i].pre)
        {
            R int p = ed[i].v;
            if(p == fa) continue;
            f[x][j] = 1LL*f[x][j]*(tot[p]-f[p][j])%mod;
        }
        while(f[x][j]<0) f[x][j] += mod;//上边(tot[p]-f[p][j])可能会变成负数，这里把它变回来。
        tot[x] = (1LL*tot[x]+1LL*f[x][j])%mod;
    }
}

inline int yg(){
    in(n),in(m);
    for(R int i=1; i<=n; ++i)
    {
        in(sum[i]);
        for(R int j=1; j<=sum[i]; ++j) in(d),f[i][d]++;
    }
    for(R int i=1; i<n; ++i)
    {
        in(x),in(y);
        add(x,y),add(y,x);
    }
    add(0,1);//为了好写，新建一个原点连向1，这样就不用额外求tot[1]了
    dfs(0,0);
    cout << tot[1];//tot[1]就是最终的答案
}

int youngsc = yg();
int main(){;}
```

---

## 作者：fishing_cat (赞：7)

[传送门](https://www.luogu.com.cn/problem/P3914)

### 题解

树形 DP 入门好题，~~是不是应该降绿啊。~~

题目中需要求相邻节点染色不同的方案数，很自然的可以设出状态 $f_{i,j}$，表示以 $i$ 为根的子树，节点 $i$ 染编号为 $j$ 的颜色的方案数。现在考虑转移。

可以发现，如果点 $i$ 要染颜色 $j$，那么其子节点就一定不能染颜色 $j$，~~这不是废话吗~~。那么点 $i$ 染颜色 $j$ 的方案数就是其所有子节点不染 $j$ 的方案数的乘积。为了方便转移，记 $z_i$ 表示点 $i$ 的总染色方案数，$sum$ 表示节点 $i$ 的子节点数量，可以得到：

$$f_{i,j} = \prod ^ {sum} _ {k = 1} (z_{son_k} - f_{son_k, j})$$

那还有颜色的限制怎么办？好说，在初始化 $f$ 时，对于不可用颜色直接初始为 $0$，只有可用颜色才初始为 $1$。这样不可用颜色的方案数就永远是 $0$ 了，就保证了颜色的限制。

时间复杂度 $O(nm)$。

### code

[link](https://www.luogu.com.cn/record/191485496)

```cpp

#include<bits/stdc++.h>
#define ll long long 
const ll N = 5e3 + 10;
const ll mod = 1e9 + 7;
using namespace std;
/*快读省了*/
ll n, m, op, kl, a, b;
vector<ll> eg[N];
ll f/**/[N]/* */[N]; // 存方案数 
//	  哪个点  染哪个色
ll z[N]; // 存总方案数 

void dfs(ll u, ll fa) {
	for (auto j : eg[u]) {
		if (j == fa) continue;
		dfs(j, u);
		for (int col = 1; col <= m; col++) {
			f[u][col] = (f[u][col] * ((z[j] - f[j][col])%mod + mod)%mod)%mod; 
		}
	}
	for (int col = 1; col <= m; col++) {
		z[u] = (z[u] + f[u][col]) % mod;
	}
}

int main() {
	read(n); read(m);
	for (int i = 1; i <= n; i ++) {
		read(op);
		for (int j = 1; j <= op; j++) {
			read(kl);
			f[i][kl] = 1;
		}
	}
	for (int i = 1; i <= n-1; i ++) {
		read(a); read(b);
		eg[a].push_back(b); 
		eg[b].push_back(a);
	}
	
	dfs(1, 0);
	
	cout << z[1] << "\n";
	return 0; // 完结撒花！！！
}

```

---

## 作者：partychicken (赞：6)

## 退役以后来发题解

noip2018前一天肝的，当时闲的没事从GitHub的女装诱惑出来做题，然后连wa好几发，感觉noip要凉。现在看果然如此，只有出分这几天还能在机房狗着。。。

这道题是道傻逼树形dp，状态转移方程显然

设计状态$dp[i][j]$为节点$i$,颜色为$j$的方案数，则有
$$dp[i][j]=\sum_{k=1,k!=j}^{m} dp[son][k]$$

然后我们发现，这个dp是$n^3$的。

考虑优化，我们发现对一个儿子不同颜色的求和可以通过预处理总和的方式$O(1)$求出。于是这个dp变成了健康的$n^2$
```
#include<bits/stdc++.h>

using namespace std;

const int mod=1e9+7;

struct Edge
{
    int to,nxt;
}e[10010];
int head[5010],cnt;

int num[5010];

void addedge(int u,int v,int val=0)
{
    e[++cnt]=(Edge){v,head[u]};
    head[u]=cnt;
}

int dp[5010][5010];
int tot[5010];
int n,m;

void dfs(int now,int fa)
{
    for(int i=head[now];i;i=e[i].nxt)
    {
        int vs=e[i].to;
        if(vs!=fa)
        {
            dfs(vs,now);
            for(int j=1;j<=m;j++)
            {
                dp[now][j]=((long long)dp[now][j]*(tot[vs]-dp[vs][j]+mod)%mod)%mod;
            }
        }
    }
    for(int i=1;i<=m;i++)
    {
        tot[now]+=dp[now][i];
        tot[now]%=mod;
    }
}



int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>num[i];
        for(int j=1;j<=num[i];j++)
        {
            int col;
            cin>>col;
            dp[i][col]=1;
        }
    }
    for(int j=1;j<n;j++)
    {
        int u,v;
        cin>>u>>v;
        addedge(u,v);
        addedge(v,u);
    }
    dfs(1,0);
    cout<<tot[1]<<endl;
}

```

---

## 作者：Gmt丶FFF (赞：3)

树形 dp 模板题。

设 $f_{x,i}$ 为 $u$ 节点染色为 $x$ 时的方案数。

那么设子节点为 $y$，那么转移方程为：

$f_{x,i}=\prod \sum_{j=1}^{m} f_{y,j}\hspace{0.2cm}(i\ne j)$

从树上往下搜再枚举 $i,j$ 明显会 T，考虑优化。

设 $dp_x=\sum f_{x,i}$。

那么 $f_{x,i}=\prod dp_y-f_{y,i}$。

这样就是 $O(n^2)$ 的了。

至于颜色限制，就将 $x$ 可选的颜色 $c$ 的数组 $f_{x,c}$ 设为 $1$ 即可。

但是正常打会 MLE，所以尽量少开数组。

1、输入存颜色时直接对 $f$ 数组初始化，不记录颜色，枚举颜色时直接 $1$ 到 $m$，用时间换取空间。

2、不开 long long，计算时直接取模即可。

这样就能 96M 极限卡过了。

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
const int mod=1e9+7;
const int N=5001;
int n,m,f[N][N],dp[N];
vector<int>a[N];
void dfs(int x,int fa)
{
	int len=a[x].size();
	for(int i=0;i<len;i++)
	{
		if(a[x][i]==fa)continue;
		dfs(a[x][i],x);
		for(int j=1;j<=m;j++)f[x][j]=(1ll*f[x][j]*(dp[a[x][i]]-f[a[x][i]][j])%mod+mod)%mod;
	}
	for(int i=1;i<=m;i++)dp[x]+=f[x][i],dp[x]%=mod;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		int k;
		scanf("%d",&k);
		for(int j=1;j<=k;j++)
		{
			int x;
			scanf("%d",&x);
			f[i][x]=1;
		}
	}
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		a[x].push_back(y);
		a[y].push_back(x);
	}
	dfs(1,0);
	printf("%d",dp[1]);
	return 0;
}
```


---

## 作者：huanzi (赞：1)

    我，我究竟还要MLE多少次啊....下一次MLE会在哪个地方，以什么样的方式袭来啊...（——日行一带的BOSS）
    
坦白而言，这一题对得起他提高加省选减的难度；~~我自认自己是个很儒雅随和的人直到我在这一题上面卡了两天~~这一题从题目就提示我们方案总数会相当的大，那么一个个枚举出具体的方案肯定是不现实的，因此，我们必须得**直接得出方案数**。~~（具体怎么求自行百度数学的乘法原理）~~

我们假设**DP[I][J]为i节点取颜色j时所有的值，TOT[I]为这个点所有的方案数**的话，那么
  
    dp[当前节点cur][各种颜色j]*=(tot[cur的子节点]-dp[cur的子节点][与前面对应的颜色j]+mod)%mod;
    tot[当前节点cur]+=dp[当前节点cur][各种颜色j]%mod;
    
由于**TOT可能会出现比DP要小的情况**，所以我们这里加了个模进行负数转正，就算TOT比DP还要大也不要紧，因为一个被除数加上除数在除于除数是不会对余数有影响的。**（在求余数的时候不能用ABS！！）**

为什么当一个节点i取颜色j时我们用乘而不是加呢？我这里的思路时；先将**DP数组所有值定义为0**~~当然这里你要是DP是全局数组就用不着这个操作~~，之后如果**读入到这个节点i能取颜色j时，我们就让dp[i][j]=1**。当然你在计算的时候进行一个特判也是可以的。

既然是一个树形DP，那么我们DFS不就解决了吗？而这一题的数值很明显就算是临时INT也装不下的话我们定义Longlong就好了？~~所以说这一道蓝题就是逊啦...~~

但是！我们需要注意的是，节点数N以及边数M都是接近甚至达到5000的值，我们用DFS又来个LONG LONG绝对会超过题目的内存最大限制。~~( 所幸这一题你就算超勇的定义Longlong也只是卡最后一个点)~~

那怎么办？INT的话装不下Longlong又太大了。那我们能不能让他临时成为LONG LONG数组，等计算完后再让他变成INT数组呢？可以！我们只需要在某个地方加上 （long long）就可以让他临时拥有LONG LONG的能力。

```
dp[cur][j]=((long long)dp[cur][j]*(tot[fl]-dp[fl][j]+mod)%mod)%mod;
```
最后是几个需要注意的点；

  1.题目说读入时最后N-1行为边，意思是指边的数目固定要比点的数量少一个，要是不注意这一点的话整个程序是没办法进行下去的。~~（别问我为什么会知道）~~
  
  2.这一题的根节点我们可以知道是1所以能直接从1开始DFS，但是如果别的题目的话你还要注意根节点究竟是谁在进行计算。
  
  3.关于inline函数，它不像正常函数在调用时存在压栈和call的操作而是会把程序代码直接嵌入到调用代码段中，通俗点就是增加空间占用减少时间占用
  
  4.就算TLEMLEWA同时出现也要保持镇静，这种题目最忌讳心态炸裂。
  
  ~~现在！各位观众！全！体！起！立！~~
  
  ```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<vector>
using namespace std;
const int mod=1e9+7;
int n,m,cnt=0;
int head[5001];
int dp[5001][5001];
int tot[5001];
struct edge{
    int to,nxt;
}e[10001];//树状DP专用存边数组 
inline int read(){
    int x=0; bool f=1; char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=0;
    for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
    if(f) return x;
    return 0-x;
}   //简单的读入优化，可以总计剩下1s多的时间，普通读入做得到吗！！！（震声） 
inline void dfs(int cur,int pre)  //本题的关键点深搜DFS,cur表示当前点current,pre表示上一个点previous
{
    for (int i=head[cur];i;i=e[i].nxt)
    {
        int fl=e[i].to;  //确立这条边联通的下一个点
        if (fl!=pre)     //预防可能会出现回到父亲的情况
        {
            dfs(fl,cur);    // 先对子节点进行计算 
            for (int j=1;j<=m;j++) dp[cur][j]=((long long)dp[cur][j]*(tot[fl]-dp[fl][j]+mod)%mod)%mod;     
        }
    }
    for (int i=1;i<=m;i++)
    {
    	tot[cur]+=dp[cur][i];
    	tot[cur]%=mod;
    }
}
inline void add(int nmsl,int v)   //心平气和的存边，kono 链式前向星 da！
{
    e[++cnt].to=v;
    e[cnt].nxt=head[nmsl];
    head[nmsl]=cnt;
}
int main()
{
    n=read(),m=read();
    for (int i=1;i<=n;i++)   // 
    {
        int faq;
        faq=read();
        for (int j=1;j<=faq;j++)
        {
            int k;
            k=read();
            dp[i][k]=1;
        }
    }
    for (int i=1;i<n;i++)//儒雅随和的读入,由题意可得边的数量比点的数量少一个 
    {
        int rz,lm;
        rz=read(),lm=read();
        add(rz,lm);
        add(lm,rz);
    }
    dfs(1,0);   //根节点来自他自己，因此我们DFS的是1，0 
    cout<<tot[1];
    return 0;
}
//本题转移方程；dp[当前节点cur][各种颜色j]*=(tot[子节点]-dp[子节点][与前面对应的颜色j]+mod)%mod;
//tot[当前节点cur]+=dp[当前节点cur][各种颜色j]%mod; 
//tot表示方案总数，dp表示每个节点染成对应颜色时拥有的方案数
```

关于链式前向星；

我们需要用到一个结构体数组e和一个~~一般路过~~数组head，其中**head用来表示以i为起点的索引的第一条边存储的位置**，e中的**nxt用于表示与第i条边同起点的下一条边的存储位置**，而**to用于储存这一条边所通向的点**，

链式前向星的最大优点是；可以解决某些卡空间的问题，删除边也很方便，只需要更改next指针的指向即可 ~~但是对于最后一个点完全木大~~

以上关于链式前向星的内容引用于；https://www.jianshu.com/p/107a645797a6

Rewrite in 2019.9.19


---

## 作者：Andrew82 (赞：1)

首先$O(n^3)$的动规很好想：

f[u][i]为u号节点颜色为i的方案数，然后

$f[u][i]=\prod_{v=son[u]}(\sum_{k=AvailableColorOf[v]} f[v][k]),k!=i$

只需要在dfs里面枚举每一个点,然后对每一个点枚举每一个儿子的颜色

由于对树的遍历是$O(n)$,遍历到每一个点后要遍历其所有儿子花费$O(n)$,对于每个儿子要遍历其颜色花费$O(n)$,因此是$O(n^3)$


(~~考试的时候就是时间复杂度算错了,根本就没想到要优化~~)

$O(n^3)$:
```cpp
#include <bits/stdc++.h>
using namespace std;
#define loop(i,start,end) for(int i=start;i<=end;++i)
#define anti_loop(i,start,end) for(int i=start;i>=end;--i)
#define clean(arry,num) memset(arry,num,sizeof(arry))
#define ll long long
#define isdegit(a) ((a>='0'&&a<='9'))

template<typename T>void read(T &x){
	x=0;char r=getchar();T neg=1;
	while(!isdegit(r)){if(r=='-')neg=-1;r=getchar();}
	while(isdegit(r)){x=(x<<1)+(x<<3)+r-'0';r=getchar();}
	x*=neg;
}

const int maxn=5010,maxm=5010,mod=1e9+7;
ll f[5010][5010],cnt=0;
struct node{
	int e;
	int nxt;
}edge[maxn<<2];
int head[maxn];
ll n,m;
vector<ll>vec[maxn];

inline void addl(int u,int v){
    edge[cnt].e=v;
    edge[cnt].nxt=head[u];
    head[u]=cnt++;
}

int dfs(int fa,int u,int col){
    if(f[u][col]){
        return f[u][col];
    }
    f[u][col]=1;
    for(int i=head[u];i!=-1;i=edge[i].nxt){
        int v=edge[i].e;
        if(v==fa)
            continue;
        ll res=0;
        vector<ll>::iterator t;
        for(t=vec[v].begin();t!=vec[v].end();++t){
            if(*t==col)
                continue;
            res+=dfs(u,v,*t);
            res%=mod;
        }
        f[u][col]*=res;
        f[u][col]%=mod;
    }
    f[u][col]%=mod;
    return f[u][col];
}

int main(){
	clean(head,-1);
	clean(f,0);
	read(n);
	read(m);
	ll nfc=0,c;
	loop(i,1,n){
		read(nfc);
		loop(j,1,nfc){
			read(c);
			vec[i].push_back(c);
		}
	}
	loop(i,1,n-1){
	    read(nfc);
	    read(c);
	    addl(c,nfc);
	    addl(nfc,c);
	}
    ll res=0;
    for(vector<ll>::iterator t=vec[1].begin();t!=vec[1].end();++t){
        res=(res+dfs(0,1,*t))%mod;
        res%=mod;
    }
	printf("%lld\n",res%mod);

	return 0;
}
```
优化:

上面的代码肯定可以T飞(60pts)

设sum[u]为u的所有方案数,f[u][i]为u涂上i的方案数

容易有:

$sum[u]=\sum_{i=AvailableColorOf[u]} f[u][i]$

$sum[u]=\prod_{v=son[u]}\sum_{i=AvailableColorOf[v]}f[v][i]$

由于一次对某个节点的dfs就可以算出其所有的标记,于是我们可以考虑用这些标记来省掉枚举儿子颜色的那一层:
- 方法一:

$f[u][i]=\sum_{v=son[u],i=AvailableColorOf[u]} (sum[v]-f[v][i])$

- 方法二:

$f[u][i]=\frac{\prod_{v=son[u]}sum[v]}{\prod_{v=son[u]}f[v][i]}$

第二种方法要求一个逆元,需要用到快速幂(也可加上exgcd)

于是优化成了$O(n^2)$


$O(n^2)$方法一:


```cpp
#include <bits/stdc++.h>
using namespace std;
#define loop(i,start,end) for(int i=start;i<=end;++i)
#define anti_loop(i,start,end) for(int i=start;i>=end;--i)
#define clean(arry,num) memset(arry,num,sizeof(arry))
#define ll int
#define LL long long
#define isdegit(a) ((a>='0'&&a<='9'))

template<typename T>void read(T &x){
	x=0;char r=getchar();T neg=1;
	while(!isdegit(r)){if(r=='-')neg=-1;r=getchar();}
	while(isdegit(r)){x=(x<<1)+(x<<3)+r-'0';r=getchar();}
	x*=neg;
}

const int maxn=5000+10,maxm=5000+10,mod=1e9+7;
ll f[maxn][maxn],cnt=0,sum[maxn];
struct node{
	int e;
	int nxt;
}edge[maxn<<2];
int head[maxn];
ll n,m;

inline void addl(int u,int v){
    edge[cnt].e=v;
    edge[cnt].nxt=head[u];
    head[u]=cnt++;
}

void dfs(int fa,int u){
	for(int i=head[u];i!=-1;i=edge[i].nxt){
		int v=edge[i].e;
		if(v==fa)
            continue;
		dfs(u,v);
        loop(col,1,m){
            if(f[u][col])
				f[u][col]=((LL)f[u][col]*((sum[v]-f[v][col])%mod+mod)%mod)%mod;
        }
	}
	loop(col,1,m)
		sum[u]=(sum[u]+f[u][col])%mod;
}

int main(){
	clean(head,-1);
	clean(f,0);
	read(n);
	read(m);
	ll nfc=0,c;
	loop(i,1,n){
		read(nfc);
		loop(j,1,nfc){
			read(c);
			f[i][c]=1;
		}
	}
	loop(i,1,n-1){
	    read(nfc);
	    read(c);
	    addl(c,nfc);
	    addl(nfc,c);
	}
    dfs(0,1);
	printf("%d\n",sum[1]);

	return 0;
}

```

$O(n^2)$方法二:

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn=5050;
const int mod=1000000007;

struct Edge
{
	int e,nx;
}edge[maxn*2];
int head[maxn],cnt;

int dp[maxn][maxn];

void add(int s,int e)
{
	edge[cnt].e=e;
	edge[cnt].nx=head[s];
	head[s]=cnt++;
}
int exp(int a,int b,int m)
{
	int ans=1;
	while(b)
	{
		if(b&1)ans=(long long)ans*a%m;
		a=(long long)a*a%m;
		b>>=1;
	}
	return ans;
}

int N,M;
int can[1000010];
int L[maxn],R[maxn];
bool vis[maxn][maxn];
int sum[maxn];

void dfs(int x,int fa)
{
	int total=1;
	for(int i=head[x];i!=-1;i=edge[i].nx)
		if(edge[i].e!=fa)
		{
			dfs(edge[i].e,x);
			total=(long long)total*sum[edge[i].e]%mod;
		}
    for(int i=1;i<=M;i++)
        if(vis[x][i])
            dp[x][i]=total;
        else
            dp[x][i]=0;
	for(int i=head[x];i!=-1;i=edge[i].nx)
		if(edge[i].e!=fa)
		{
			int e=edge[i].e;
			int inv=exp(sum[e],mod-2,mod);
			for(int j=L[e];j<=R[e];j++)
				if(vis[x][can[j]])
				{
					dp[x][can[j]]=(long long)dp[x][can[j]]*inv%mod;
					dp[x][can[j]]=(long long)dp[x][can[j]]*(sum[e]-dp[e][can[j]]+mod)%mod;
				}
		}
	sum[x]=0;
	for(int i=1;i<=M;i++)sum[x]=(sum[x]+dp[x][i])%mod;
}

int main()
{
	scanf("%d %d",&N,&M);
	for(int i=1;i<=N;i++)
	{
		int c;
		scanf("%d",&c);
		L[i]=R[i-1]+1;
		for(int j=0;j<c;j++)
		{
			int x;
			scanf("%d",&x);
			can[L[i]+j]=x;
			vis[i][x]=1;
		}
		R[i]=L[i]+c-1;
	}
	memset(head,-1,sizeof(head));cnt=0;
	for(int i=1;i<N;i++)
	{
		int a,b;
		scanf("%d %d",&a,&b);
		add(a,b);
		add(b,a);
	}
	dfs(1,-1);
	printf("%d\n",sum[1]);
    return 0;
}

```


---

## 作者：__phiu (赞：0)

### 题意
对一个树进行染色，每个节点有可以染的颜色，要求相邻节点颜色不同。

## 主要思路

显然每个节点染上一种颜色后，孩子都不能染这种颜色，所以把孩子们不染这种颜色的方案数乘起来，转移方程：

$$dp_{now,j}=\prod _{k \in Son(now)} (tot_k-dp_{k,j})$$

$tot$ 代表一个点的总方案数，$dp$ 代表一个点选一个颜色的方案数。

提前在 dfs 中预处理出 $tot$ 即可。

## 注意

本题空间较小所以不能直接开 long long 数组，在计算过程中乘 $1LL$ 即可。

在过程中可能变为负数，加 $mod$ 加回来即可。

## Code

```
#include<bits/stdc++.h>
using namespace std;
struct edge{
	int to,from;
}e[10005];
int head[5005];
int tott;
void add(int x,int y)
{
	e[++tott].to=y;
	e[tott].from=head[x];
	head[x]=tott;
}
int n,m;
//int co[5005][5005];
int cnt[5005];
int tot[5005];
int dp[5005][5005];
const int mod=1e9+7;
void dfs(int now,int fa)
{
	for(int i=head[now];i;i=e[i].from)
	{
		int to=e[i].to;
		if(to==fa)
			continue;
		dfs(to,now);
	}
	for(int i=1;i<=m;i++)
	{
		if(!dp[now][i])
			continue;
		for(int j=head[now];j;j=e[j].from)
		{
			int to=e[j].to;
			if(to==fa)
				continue;
			dp[now][i]=1ll*dp[now][i]*(tot[to]-dp[to][i])%mod;
		}
		while(dp[now][i]<0)
			dp[now][i]=(dp[now][i]%mod+mod)%mod;
		tot[now]=(1ll*tot[now]+1ll*dp[now][i])%mod;
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>cnt[i];
		for(int j=1;j<=cnt[i];j++)
		{
			int x;
			cin>>x;
//			co[i][x]=1;
			dp[i][x]++;
		}
	}
	for(int i=1;i<n;i++)
	{
		int x,y;
		cin>>x>>y;
		add(x,y);
		add(y,x);
	}
	dfs(1,0);
	cout<<tot[1]%mod;
}
```


---

## 作者：AlicX (赞：0)

### 题意
给你一颗 $n$ 的树，以及 $m$ 种颜色，再告诉你每个点可以用哪些颜色，但是相邻的两个点颜色不能相同，求方案数。

## 思路

看到这种题，树形动态规划无疑了。

- 状态定义：状态很好想，其实有个取巧的方法，可以观察数据范围来定义。定义 $f(i,j)$ 为第 $i$ 个点用 $j$ 这种颜色的方案数。

- 暴力：写一个朴素的树形动规，枚举当前点的颜色和子节点的颜色，外面还有一层递归，所以时间复杂度为 $O(nm^2)$，显然过不了。

- 优化：一般来说，动态规划的优化是不可以将枚举的状态优化掉的，就像此题，我们是无法将外层递归和枚举当前的颜色优化掉，所以我们就要优化掉枚举子节点的颜色。因为只有子节点的颜色与当前节点相同的时候才会有特殊情况，所以用前缀和将子节点的所有方案数统计起来，当遇到这种情况我们就减去这种情况，其余不变，那么现在我们的时间就是 $O(nm)$ 的，可以过了。

- 注意：取模的时候要先加上模数在取模，注意空间。

## AC Code

```cpp

#include<bits/stdc++.h>
#define int long long
#define x first
#define y second
using namespace std;
typedef pair<int,int> pii;
const int N=5e3+10,M=N*2,mod=1e9+7;
int n,m;
int s[N];
int f[N][N];
int h[N],idx=0;
struct Node{
	int to,ne;
}tr[M];
void add(int u,int v){
	tr[idx].to=v,tr[idx].ne=h[u],h[u]=idx++;
}
void dfs(int u,int fa){
	for(int i=h[u];i!=-1;i=tr[i].ne){
		int to=tr[i].to;
		if(to==fa) continue;
		dfs(to,u);
		for(int j=1;j<=m;j++) f[u][j]=((long long)f[u][j]*(s[to]-f[to][j]+mod)%mod)%mod;
	}
	for(int i=1;i<=m;i++) s[u]=(s[u]+f[u][i])%mod;
}
signed main(){
	memset(h,-1,sizeof h);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		for(int j=1;j<=x;j++){
			int a;
			cin>>a,f[i][a]=1;
		}
	}
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		add(u,v),add(v,u);
	}
	dfs(1,0);
	cout<<s[1]<<endl;
	return 0;
}

```

---

## 作者：johnsmith0x3f (赞：0)

## 0x01

设 $f(i, j)$ 表示 $i$ 的颜色为 $j$ 时 $i$ 子树的染色方案数。

显然 $f(u, j) = \prod_{v \in \{ son(u) \}} \sum_{k \ne j} f(v, k)$。

## 0x02 Code

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int read(){
	int x = 0, f = 1; char c = getchar();
	while(isdigit(c)^1) f &= (c!=45), c = getchar();
	while(isdigit(c)) x = (x<<1) + (x<<3) + (c^48), c = getchar();
	return f ? x : -x;
}

const int maxn = 5005;
const int mod = 1000000007;
int n, m, f[maxn][maxn];
bitset<maxn> s[maxn];
vector<int> G[maxn];

inline int DFS(int u, int pa){
	for(int i=1; i<=m; ++i) f[u][i] = s[u][i];
	for(int v : G[u])
		if(v!=pa){
			int sum = DFS(v, u);
			for(int i=1; i<=m; ++i)
				if(s[u][i]) f[u][i] = 1ll * f[u][i] * (sum-f[v][i]+mod) % mod;
		}
	int res = 0;
	for(int i=1; i<=m; ++i) res = (0ll+res+f[u][i]) % mod;
	return res;
}

int main(){
#ifndef ONLINE_JUDGE
	freopen("test.in", "r", stdin);
#endif
	n = read(), m = read();
	for(int i=1, x; i<=n; ++i)
		for(int k=read(); k; --k) x = read(), s[i][x] = 1;
	for(int i=1, u, v; i<n; ++i)
		u = read(), v = read(), G[u].push_back(v), G[v].push_back(u);
	printf("%d\n", DFS(1, 0));
	return 0;
}
```

---

## 作者：Supor__Shoep (赞：0)

也许你发现我和这里有某些题解长得差不多，但是真的是不一样的，因为我的代码量变长了。。

首先它就是一道简简单单的树形 DP，状态，转移，这些相似的题在洛谷上一抓一大把。说简单一点，这就是简简单单的动态规划加上简简单单的深搜，只要你学过哪怕一点点，就会把这道题~~轻轻松松一遍过~~。

但是我们要睁大自己的狗眼看看评测记录，我们会发现基本所有的人都惨遭 MLE，所以我们不能使用 long long 的数组。

问题是找到了，但是怎么解决呢？

很简单，只需要定义一个 long long 的变量，存放即将赋的值，最后在赋值的时候转化为 int 就可以了。

为了方便大家理解，举一个简单的小栗子：
```
int a[10];
long long Now;
Now=123;
Now+=123456789999;
Now-=123456700000;
a[1]=(int)Now;
```
现在大家应该知道自己为什么炸了。

然后说一下取模，经过了负数取模的教训之后，我们必须写成：
```
x=(x+MOD)%MOD;
```
这是因为负数取模在 C++ 里面和数学不太一样,不信就拿 $-1$ 试试。

最后我给大家说一下本题动态规划。假设 $f[i][j]$ 为 $i$ 节点取颜色 $j$ 时所有的值，$sum[i]$ 为这个点所有的方案数，那么就可以简单推出：
```
f[当前节点][颜色]*=(sum[当前节点子节点]-df[当前节点子节点][对应颜色]+MOD)%MOD;
sum[当前节点]+=f[当前节点][颜色]%MOD;
```
为了完成 long long，我们可以用 Now 记录，转化为代码就是：
```
Now=(long long)((sum[G[i].next_to]-f[G[i].next_to][j])%MOD+MOD)%MOD;
Now=(long long)f[x][j]*Now%MOD;
f[x][j]=(int)Now;
```
再进行合理的收尾处理，就可以过了。

不妨亮一下代码：
```
void F(int x,int y)
{
	G[++k].Next=Top[x];
	G[k].next_to=y;
	Top[x]=k;	
}
void dfs(int x,int y)
{
	long long Now=0;
	for(int i=Top[x];i;i=G[i].Next)
	{
		if(G[i].next_to!=y)
		{
			dfs(G[i].next_to,x);
			for(int j=1;j<=m;j++)
			{
				Now=(long long)((sum[G[i].next_to]-f[G[i].next_to][j])%MOD+MOD)%MOD;
				Now=(long long)f[x][j]*Now%MOD;
				f[x][j]=(int)Now;
			}
		}
	}
	for(int i=1;i<=m;i++)
	{
		sum[x]=(sum[x]+f[x][i])%MOD;
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		for(int j=1;j<=x;j++)
		{
			int y;
			cin>>y;
			f[i][y]=1;
		}
	}
	for(int i=1;i<n;i++)
	{
		int x,y;
		cin>>x>>y;
		F(x,y);
		F(y,x);
	}
	dfs(1,0);
	cout<<sum[1];
	return 0;
}
```

---

## 作者：神眷之樱花 (赞：0)

# 题面
[染色计数](https://www.luogu.com.cn/problem/P3914)
# 题解
显而易见的树形Dp。

不难发现，一个点只会和它的父亲相邻，所以要让相邻的颜色不同，只需要考虑某个点和它父亲的关系就好了。

而一个点的儿子之间是没有相互影响的，是相互独立的事件，所以用乘法原理就可以求出这些点父亲的方案数。

所以我们Dp的基本框架就有了。

如果我们这样写的话：
```cpp
for(int p = 0; p < color[x].size(); p++)
	for(int q = 0; q < color[y].size(); q++) {
		if(color[x][p] == color[y][q]) continue;
```
显然就变成 $n^3$ 了，考虑优化：

我们可以把 $y$ 的总方案数的和求出来，所以我们要用到的状态的方案数就是：
$$tot_y - dp[y][j]$$
意思就是总的方案数，减去和父亲颜色相同的方案数。

这样每次就能 $O(1)$ 求出我们要用的状态，不用再去枚举了，不懂得地方可以参照代码理解。

# 代码

加了波常数优化，冲上了 rank1。

```cpp
#include<cstdio>
#include<ctype.h>

#define re register

const int N = 5e3 + 5, mod = 1e9 + 7;

int n, m, dp[N][N], tot[N];

struct edge {
	#define M N << 1
	int head[N], next[M], to[M], size;
	inline void add(int u,int v) {
		next[++size] = head[u];
		to[size] = v; head[u] = size;
		next[++size] = head[v];
		to[size] = u; head[v] = size;
	}
	void dfs(int x,int fa) {
		for(re int i = head[x], y; i; i = next[i]) {
			if((y = to[i]) == fa) continue;
			dfs(y,x);
			for(int j = 1; j <= m; j++)
				dp[x][j] = 1ll * dp[x][j] * (tot[y] - dp[y][j] + mod) % mod; 
		}
		for(re int i = 1; i <= m; i++)
			tot[x] = (tot[x] + dp[x][i]) % mod;
	}
}a;

inline int read() {
	re int x = 0, f = 1, c = getchar();
	for(; !isdigit(c); c = getchar())
		if(c == '-') 
			f = -1;
	for(; isdigit(c); c = getchar())
		x = x * 10 + c - 48;
	return x * f;
}

int main() {
	n = read(), m = read();
	for(re int i = 1; i <= n; i++) 
    {
		int tot = read();
		while(tot--) dp[i][read()] = 1;
	}
	for(re int i = 1; i < n; i++)
		a.add(read(), read());
	a.dfs(1,0);
	printf("%d\n",tot[1]);
	return 0;
}
```

---

## 作者：MuelsyseU (赞：0)

题目：[P3914](https://www.luogu.com.cn/problem/P3914)

## 1. 前言

本题思维简单，但是思维过程和转移方程可以说是树形DP中比较具有代(mu)表(ban)性的，因此在这里着重讨论思维过程以及正确性的证明。

## 2. 思维过程

~~实际上是树形DP的接近模板的题~~

观察题目，给出一棵树，每个节点有若干个可用的颜色，任意相邻节点颜色不能相同，求总共的染色方案数。

对于计数类问题实际上很容易可以想到递推。首先，对于一棵无根树，任意指定一个节点$root$为根，然后按照一棵有根树进行处理。

而关于相邻节点不能同色的限制，实际上可以转化为：**在树上任意节点与它的子节点的颜色不能相同**。

容易发现，在此题中，每个叶子节点染色的总方案数是已知的，而如果假定该图是菊花图，即存在一个节点$p$，当以$p$为根时它的每个儿子都是叶子节点。那么总方案数就是把每个节点分别染色的方案数的乘积，减去$P$的颜色与其每个子节点发生冲突的情况总数的总和。把该方案数设为$S_p$。

实际上对于上述情况，只需要$O(nm)$的时间遍历父节点的颜色并分别处理每个子节点的冲突情况，即可运用排列组合的思想求解。

那么如何将上述方法进一步推广呢？可以假定存在若干个类似$P$的节点$p_1,p_2,...,p_k$，它们有共同的父节点$i$，则我们可以用上述方法分别求出**以$p_i$为根的子树**染色的方案数，在计算$S_i$时，我们实际上只关心每棵子树的方案数以及该子树的根节点的颜色，而不关心该子树下其它节点的颜色。因此，可以设$F_{i,j}$表示**以$i$为根的子树在把$i$染色为$j$时的染色方案数**。对于$i$不允许的染的颜色$j$，$F_{i,j}=0$。于是：

$$S_p=\sum_{j=1}^m F_{p,j}$$

同样考虑遍历$i$的颜色，则如果$\forall p \in son(i)$，$F_p$的每一项及$S_p$已被正确求出，那么有：

$$F_{i,j}=\prod_{p \in son(i)} S_p - F_{p,j}$$

通俗地说，也就是运用乘法和减法原理，对于每个以子节点$p$为根的子树，求出这个子树在$i$染色为$j$时的可行方案数（也就是总方案数减去$p$染色为$j$的不可行方案数），最后将所有子树的可行方案数相乘即可。

在推出$i$之后，同样可以把与$i$有关的值保存下来，来推出以$i$的父节点为根的子树的染色方案数。以此类推，最后即可得到**以整棵树的根节点为根的子树的总方案数**即$S_{root}$，也就是整个问题的解。

容易发现，对于任何一个节点$i$，推出$F_i$的每一项的时间复杂度为$O(|son(i)|*m)$，而$\sum_{i \in V} |son(i)|+1=N$，因此总共的时间复杂度为$O(nm)$。

实际上，上述思想就是**自底向上的树形DP**的一种。

## 3. 实现

经过计算，输入数据最多可能达到30MB左右，因此需要使用快读。

而对于我们刚才所说的自底向上遍历，可以使用一遍DFS解决，也就是优先**遍历每个儿子$p$，递归求出$F_p$的每一项及$S_p$**；之后根据这个儿子的子树的方案数更新自身子树的方案数。遍历完所有儿子后，再根据已经求出的不同颜色的方案数进行求和。

然后是DP起点，也就是叶子节点的问题。实际上我们可以直接在输入某个节点$i$可以染的颜色$j$时，使$F_{i,j}=1$；对于其余的$j$，使$F_{i,j}=0$。那么就有以下两种情况：

1. $i$是叶子节点，此时以$i$为根而将$i$染色为$j$的方案只有$1$种，符合题意；对于不允许的颜色，方案为$0$种，符合题意。

2. $i$不是叶子节点，此时如果$i$可以染色为$j$，则根据乘法原理初始时应有$F_{i,j}=1$，最后连乘得到实际方案数，符合题意；对于不允许的颜色，无论怎样连乘，最终一定有$F_{i,j}=0$，符合题意。

在取模问题上，由于我们实际得到的$S_p$是已经经过取模才存储的，因此可能会出现$S_p-F_{p,j}<0$的情况，而对于负数的取模会被错误地转化成绝对值取模最后再加上负号。因此我们可以加上一个$10^9+7$再取模，即可变为正数取模且结果正确。

以及乘法溢出和在无根树上存图及DFS的一些细节，参见注释。

```cpp
#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;

const int mod=1e9+7;
int n,m,x,y,tot,f[5010][5010],s[5010];
//邻接表建图模板 
//注意无根树中边数=2n-2 
int head[10010],ver[10010],Next[10010];
inline void add(int x,int y){
	ver[++tot]=y,Next[tot]=head[x],head[x]=tot;
}
//快读优化时间常数 
inline void read(int &a){
    char c=getchar();
	int x=0, f=1;
    while(!isdigit(c)) f=(c=='-'?-1:f),c=getchar();
    while(isdigit(c)) x=x*10+c-'0',c=getchar();
    a=x*f;
}
//DFS进行树形DP 
inline void dfs(int x,int fa){
	for(int i=head[x];i;i=Next[i]){
		int y=ver[i];
		//注意：在无根树上有几率遍历到父节点需要舍去  
		if(y==fa) continue;
		//递归 
		dfs(y,x);
		//此时关于y的方案数已经求出，运用组合数原理更新自身 
		//注意取模以及将两个int型相乘需要临时转为long long的问题  
		for(int j=1;j<=m;j++) f[x][j]=((long long)f[x][j]*(s[y]-f[y][j]+mod)%mod)%mod;
	}
	//求和 
	for(int j=1;j<=m;j++) s[x]=(s[x]+f[x][j])%mod;
}
int main(){
	read(n),read(m); 
	for(int i=1;i<=n;i++){
		read(x);
		while(x--) read(y),f[i][y]=1;
	}
	for(int i=1;i<n;i++){
		read(x),read(y);
		add(x,y);
		add(y,x);
	} dfs(1,0); //任意指定1号节点为根  
	cout<<s[1];
	return 0;
}
```

---


# [TJOI2013] 松鼠聚会

## 题目描述

草原上住着一群小松鼠，每个小松鼠都有一个家。时间长了，大家觉得应该聚一聚。但是草原非常大，松鼠们都很头疼应该在谁家聚会才最合理。

每个小松鼠的家可以用一个点 $(x,y)$ 表示,两个点的距离定义为点 $(x,y)$ 和它周围的 $8$ 个点 $(x-1,y)$，$(x+1,y)$，$(x,y-1)$，$(x,y+1)$，$(x-1,y+1)$，$(x-1,y-1)$，$(x+1,y+1)$，$(x+1,y-1)$ 距离为 $1$。


## 说明/提示

### 样例解释

在第一个样例中，松鼠在第二只松鼠家 $(-1,-2)$ 聚会；在第二个样例中，松鼠在第一只松鼠家 $(0,0)$ 聚会。

### 数据范围

- $30\%$ 的数据，$0\le N \le 1000$；
- $100\%$ 的数据，$0\le N \le 10^5$，$-10^9 \le x, y \le 10^9$。

## 样例 #1

### 输入

```
6
-4 -1
-1 -2
2 -4
0 2
0 3
5 -2```

### 输出

```
20```

## 样例 #2

### 输入

```
6
0 0
2 0
-5 -2
2 -2
-1 2
4 0```

### 输出

```
15```

# 题解

## 作者：Rbu_nas (赞：96)

一道有趣的题OwO  

题意简述：在 $n$ 个点中找到一个点 $x$，使其他 $n-1$ 个点到 $x$ 的 **切比雪夫距离** 之和最小。求距离和的最小值。

---

![](https://cdn.luogu.com.cn/upload/image_hosting/gguf3dgl.png)

然而题面只告诉了我们「一个点到周围的八个点距离为 1」，这种距离计量方式是啥意思呢。其实，这就是 **切比雪夫距离** 的定义，也称为 **棋盘距离**。

若二个向量或二个点 _p、and q_，其坐标分别为 $p_i$ 及 $q_i$，则两者之间的切比雪夫距离定义如下：

![](https://wikimedia.org/api/rest_v1/media/math/render/svg/35eef1c9d2a8386fb3fc50f6ae14784b887ee6f1)

这也等于以下 $L_p$ 度量的极值：

![](https://wikimedia.org/api/rest_v1/media/math/render/svg/2110417c896913151c041c26e45715dd24388157)

因此切比雪夫距离也称为 $L_{∞}$ 度量。

以数学的观点来看，切比雪夫距离是由一致范数（或称为上确界范数）所衍生的度量，也是超凸度量的一种。

在平面几何中，若二点 _p_ 及 _q_ 的直角坐标系坐标为 $(x_1,y_1)$ 及 $(x_2,y_2)$，则切比雪夫距离为：

![](https://wikimedia.org/api/rest_v1/media/math/render/svg/0aaa2abdfd1eb24ab4c270d21ad5e056f190d3d4)

总结一下，切比雪夫距离指的是两个点各座标数值差的最大值，也就是 $\max(|x_2-x_1|,|y_2-y_1|)$。在棋盘中就表现为一个不在边缘的格子，到周围 8 个格子都是 1 步的距离，所以也被称作棋盘距离。

举个例子：

![](https://ftp.bmp.ovh/imgs/2019/11/7bf455fdb1c5191b.png)

切比雪夫距离是常用的距离表示方式之一，这里同时介绍一下其他的距离表示方法。

- 欧几里得距离

	初中数学教材介绍的两点间距离表示。
  
    设 $A(x_1,y_1),B(x_2,y_2)$ 那么 $|AB|=\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$
  
    一般模型：在一个坐标系上，求从一个点到另一个点的最短几何距离。
  
- 曼哈顿距离

	二维空间内，两个点之间的曼哈顿距离为它们横坐标之差的绝对值与纵坐标之差的绝对值之和。它可以很快求出各点距离和。
  
    即 $A(x_1,y_1),B(x_2,y_2)$ 那么 $|AB|=|x_2-x_1|+|y_2-y_1|$
  
    一般模型：网格图中从一个点走向另一个点的最短距离。
  
- 切比雪夫距离

	详细解释可参见上文维基百科的选段。
  
    通俗的讲，有 $A(x_1,y_1),B(x_2,y_2)$，那么切比雪夫距离定义为 $\max(|x_2-x_1|,|y_2-y_1|)$
  
    一般模型：棋盘上或者在图中一个点到另外相邻八个点的距离为 1。
  
---

现在我们已知了题目的询问原来是求 切比雪夫距离 的和，可是貌似没啥用啊。

考虑枚举每一个点，都要穷举其他 $n-1$ 个点到这个点的距离，复杂度不能接受。柿子 $\max(\Delta x_1,\Delta y_1)+\max(\Delta x_2,\Delta y_2)+\dots+max(\Delta x_n,\Delta y_n)$ 很烦，如何将其转换呢？

经过观察可以发现，切比雪夫距离 $\max(\Delta x,\Delta y)$ 和曼哈顿距离 $(\Delta x+\Delta y)$ 很相似（事实上也没啥距离表示和切比雪夫距离相似的

由于计算每个点取 max 复杂度跑不掉了，可不可以考虑向曼哈顿距离转化呢？（曼哈顿距离的优势马上就要展现出来了

${}$

尝试一下。康康分类讨论曼哈顿距离的公式可不可以化开。

$$D=|x_2-x_1|+|y_2-y_1|$$

$$D=\max\left(x_2-x_1+y_2-y_1,\ x_1-x_2+y_2-y_1,\ x_1-x_2+y_1-y_2,\ x_2-x_1+y_1-y_2\right)$$

$$D=\max\{\ \left|(x_2+y_2)-(x_1+y_1)\right|,\ \left|(x_2-y_2)-(x_1-y_1)\right|\  \}$$

${}$

哇哦，这个和 $D_{\texttt{Chess}}=\max(|x_2-x_1|,|y_2-y_1|)$ 形式上长的真像，很容易就能发现 曼哈顿 意义下的 $(x_1,y_1)$ $(x_2,y_2)$ 两点的距离转化为了 切比雪夫 意义下的 $(x_2+y_2,x_2-y_2)$ $(x_1+y_1,x_1-y_1)$ 两点的距离。

推广到更一般的情况，给出 曼哈顿 意义下的坐标 $(x,y)$，可转化成 切比雪夫 意义下的坐标 $(x+y,x-y)$。

反过来，我们也能通过 切比雪夫 意义下的坐标 $(x,y)$ 转化为 曼哈顿 意义下的 $(\frac{x+y}{2},\frac{x-y}{2})$，正是我们想要的。

---

这个具体有什么用呢？上文已提到了曼哈顿距离求和非常快的优势，现在我们再研究研究怎么个快速求和。

还是从根式推起。

设 $dis(i,j)$ 为曼哈顿意义下 $i$ 到 $j$ 的曼哈顿距离。若当前枚举的终点为 $j$ 那么 $ans=\sum\limits_{i=1}^n dis(i,j)$，这也是 $O(N^2)$ 的。稍稍再化简一下：

$$\sum\limits_{i=1}^n dis(i,j)$$

$$=dis(1,j)+dis(2,j)+\dots+dis(n,j)$$

${}$

以 $dis(i,j)$ 中的一部分 $|x_i-x_j|$ 举例化简

$$\sum\limits_{i=1}^n \Delta x$$

$$=|x_1-x_j|+|x_2-x_j|+\dots+|x_j-x_j|+|x_{j+1}-x_j|+\dots+|x_n-x_j|$$

${}$

如果先将横坐标处理为递增的，很容易得知柿子 $|x_j-x_j|$ 以前肯定是可以继续拆绝对值化简的；$|x_{j+1}-x_j|$ 及以后的柿子是 $\ge0$ 的，进一步化简：

$$=\sum\limits_{i=1}^j(x_j-x_i)+\sum\limits_{i=j+1}^n(x_i-x_j)$$

这玩意..

不就是前缀和嘛..？

![](https://cdn.luogu.com.cn/upload/image_hosting/gguf3dgl.png)

维护**有序状态**下 $\sum\limits_{i=1}^k x_i$ 和 $\sum\limits_{i=1}^k y_i$ 的值，$\sum\limits_{i=1}^j x_j$ 直接用 `j * xj` 算就行了。

$dis(i,j)$ 的另一部分 $\Delta y$ 可同理化简求值。

---

理理思路：

读入 切比雪夫 意义下的坐标并化为 曼哈顿 意义下的坐标，因为有 $\div2$ 可能有小数，先不进行 $\div2$，最后把距离 $\div2$ 是一样的。

分别对 $x_i,y_i$ 排序，处理成递增的序列和前缀和。

枚举每一个终点，把它的 $x_i,y_i$ 在排好序的数组里的位置找出来（即 $x_i,y_i$ 在排序后数组里的下标），可快速算所有点到它的距离和了。

$\texttt{Code}$

```cpp
#include <iostream>
#include <algorithm>
#include <climits>
#include <stdio.h>
#define MAXN 100010

typedef long long i64;

int n, x[MAXN], y[MAXN], gx[MAXN], gy[MAXN];
i64 sumx[MAXN], sumy[MAXN];

inline i64 calc(int i)
{
    int rx = std::lower_bound(gx + 1, gx + n + 1, x[i]) - gx;
    int ry = std::lower_bound(gy + 1, gy + n + 1, y[i]) - gy;
    return rx * 1LL * x[i] - sumx[rx] + sumx[n] - sumx[rx] - (n - rx) * 1LL * x[i] +
        ry * 1LL * y[i] - sumy[ry] + sumy[n] - sumy[ry] - (n - ry) * 1LL * y[i];

    /*
        rx: 在 gx[] 中 x 排多少位，即 gx[i] = x 的 i
        ry: 在 gy[] 中 y 排多少位，即 gy[i] = y 的 i
        只有找到了 rx 和 ry 才能分成两步计算，rx 和 ry 也是下文两个数组下的 “j”
        
        dis(1, j) + dis(2, j) + ... + dis(j, j) + ... + dis(n, j) 为把 j 这个点设为终点的曼哈顿距离，坐标已经转为曼哈顿意义下的坐标
        排序后分为 j 之前和 j 之后两部分计算

        有序 x[] 下 x 坐标的贡献:
            rx 之前为 rx * x[j] - sum(x[1..j])
            rx 之后为 sum(x[j..n]) - (n - (j + 1) + 1) * x[j]

            y 坐标同理

        答案的柿子建议自己写，也可以把 * 1LL * y[i] 替换成 * 1LL * gy[ry] 
    */
}

signed main()
{
    scanf("%d", &n);

    for(int i = 1; i <= n; ++i)
    {
        int xi, yi;
        scanf("%d%d", &xi, &yi);
        x[i] = gx[i] = xi + yi;
        y[i] = gy[i] = xi - yi;

        /*
            转化成曼哈顿意义下坐标
            gx[] gy[] 是要经过排序得到的有序数组
            x[] y[] 存第 i 个点坐标
        */
    }

    std::sort(gx + 1, gx + n + 1);
    for(int i = 1; i <= n; ++i)
        sumx[i] = sumx[i - 1] + gx[i];

    std::sort(gy + 1, gy + n + 1);
    for(int i = 1; i <= n; ++i)
        sumy[i] = sumy[i - 1] + gy[i];

    /*
        计算前缀和
        为了维护 sum(gx[1..j]) 和 sum(gy[1..j])
        j 是文章中提到的 x_j 的下标
    */

    static i64 res = LLONG_MAX;
    for(int i = 1; i <= n; ++i)
        res = std::min(res, calc(i));

    //最后记得 div 2
    printf("%lld\n", res >> 1LL);
    return 0;
}

```

由于柿子比较多，很可能打错，代码中的注释有的是写代码时写的，可能和文章中的解释有些出入（主要是下标

这篇题解花了我很长时间，马上要 CPS-S 了，祝大家 RP++


---

## 作者：Heartlessly (赞：14)

## Description

给定 $n$ 个点，每个点的坐标为 $(x_i,y_i)$，且点 $(x,y)$ 到它周围 $8$ 个点 $(x-1,y)(x+1,y),(x,y-1),(x,y+1).(x-1,y+1),(x-1,y-1),(x+1,y+1),(x+1,y-1)$ 的距离均为 $1$ 。现要找到一个点，使其它点到这个点的距离和最小，输出这个最小值。

$(0 \leq n \leq 10^5,-10^9 \leq x_i,y_i \leq 10^9)$

## Solution

很容易看出这道题属于 **切比雪夫距离** 的一般模型。即对于两个点 $(x_1, y_1),(x_2,y_2)$，它们之间的距离为
$$
\max(\left | x_1 - x_2\right | , \left | y_1 - y_2\right | )
$$
直接求 **切比雪夫距离** 似乎很困难？考虑把 **切比雪夫距离** 转化为 **曼哈顿距离**，即把每个点的坐标 $(x,y)$ 变为 $(\frac{x + y}{2}, \frac{x - y}{2})$ 。（不会的请学习 **[常用距离算法详解](https://www.luogu.org/blog/xuxing/Distance-Algorithm)**）

枚举所选的点 $i$，我们只需要计算其它点到它的曼哈顿距离和即可。

如果某个点 $j$ 的横坐标 $x_j \leq x_i$，则它的对总距离的贡献为 $x_i - x_j$，反之则为 $x_j - x_i$ 。

这样就可以分两种情况讨论了。

设前 $k$ 个点的横坐标都 $\leq x_i$，那么所有点横坐标的贡献和为

![ZnGuuV.png](https://s2.ax1x.com/2019/06/27/ZnGuuV.png)

对于 $\sum\limits_{i = 1}^k x_i$ 和 $\sum\limits_{i = k + 1}^n x_i$，我们可以预处理出 $x$ 的前缀和后 $O(1)$ 求得。

怎么求 $k$ 呢？显然可以将横坐标排序后二分得到。

纵坐标 $y$ 的计算方法与上面一样。时间复杂度为 $O(n \log n)$ 。

**切比雪夫距离** 转成 **曼哈顿距离** 时要除以 $2$，为了避免出现小数，我们可以横坐标和纵坐标同时乘上 $2$，最后答案除以 $2$。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

template <class T>
inline void read(T &x) {
    x = 0;
    char c = getchar();
    bool f = 0;
    for (; !isdigit(c); c = getchar()) f ^= c == '-';
    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
    x = f ? -x : x;
}

template <class T>
inline void write(T x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    T y = 1;
    int len = 1;
    for (; y <= x / 10; y *= 10) ++len;
    for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);
}

const int MAXN = 1e5;
int n, x[MAXN + 5], y[MAXN + 5], p[MAXN + 5], q[MAXN + 5];
LL ans = 0x7fffffffffffffff, prex[MAXN + 5], prey[MAXN + 5];

int main() {
    read(n);
    for (int a, b, i = 1; i <= n; ++i) {
        read(a), read(b);
        x[i] = p[i] = a + b, y[i] = q[i] = a - b;//转曼哈顿距离，且乘上 2 
    }
    sort(p + 1, p + n + 1), sort(q + 1, q + n + 1);//排序 
    for (int a, b, i = 1; i <= n; ++i)//维护前缀和 
        prex[i] = prex[i - 1] + p[i], prey[i] = prey[i - 1] + q[i];
    for (int posx, posy, i = 1; i <= n; ++i) {
        posx = lower_bound(p + 1, p + n + 1, x[i]) - p;
        posy = lower_bound(q + 1, q + n + 1, y[i]) - q;
        //二分找到 x[i] 和 y[i] 是所有点中第几个大的 
        LL sumx, sumy;
        sumx = (LL) posx * x[i] - prex[posx] + 
        prex[n] - prex[posx] - (LL) (n - posx) * x[i];//计算横坐标贡献 
        sumy = (LL) posy * y[i] - prey[posy] + 
        prey[n] - prey[posy] - (LL) (n - posy) * y[i];//计算纵坐标贡献 
        ans = min(ans, sumx + sumy);
    }
    write(ans / 2);//答案不要忘记除回去 
    putchar('\n');
    return 0;
}
```

---

## 作者：HiJ1m (赞：6)

我的博客原文链接：http://www.cnblogs.com/Elfish/p/7931766.html


本题两点间的距离是max(|x1-x2|,|y1-y2|)，曾经在黄学长的博客里看到过一个转化 
求这个距离可以把点的坐标都转化成 (x+y)/2,(x-y)/2  然后的曼哈顿距离就是这个了

这个好像叫 切比雪夫距离

之后我们预处理前缀和，枚举源点就可以了。

记得都开longlong 我WA的很悲惨


```cpp
#include<bits/stdc++.h>
#define MAXN 100005
using namespace std;
int read(){
    int x=0,t=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')t=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*t; 
} 
struct Node{
    long long X,Y; 
}a[MAXN]; 
int N,x[MAXN],y[MAXN],pos;
long long ans=1ll<<62,s1[MAXN],s2[MAXN];
int main()
{
    N=read();
    for(int i=1;i<=N;i++){
        int p=read(),q=read();
        x[i]=a[i].X=p+q;
        y[i]=a[i].Y=p-q;
    }
    sort(x+1,x+N+1);
    sort(y+1,y+N+1);
    for(int i=1;i<=N;i++)
        s1[i]=s1[i-1]+x[i],
        s2[i]=s2[i-1]+y[i];
    for(int i=1;i<=N;i++){
        long long tmp=0;
        pos=lower_bound(x+1,x+N+1,a[i].X)-x;
        tmp+=s1[N]-s1[pos]-a[i].X*(N-pos)+a[i].X*pos-s1[pos];
        pos=lower_bound(y+1,y+N+1,a[i].Y)-y;
        tmp+=s2[N]-s2[pos]-a[i].Y*(N-pos)+a[i].Y*pos-s2[pos];
        ans=min(ans,tmp);
    }
    printf("%lld\n",ans/2);
    return 0;
}
```

---

## 作者：quantum11 (赞：5)

题意为给定一些点，选其中一个点使其他点到这个点的切比雪夫距离之和最小，求出最小距离。

切比雪夫距离=$\max(\Delta x,\Delta y)$，因为取$max$不太好优化，我们可以把它转化为曼哈顿距离$(\Delta x+\Delta y)$来做。

将$(x,y)$变为$(\frac{x+y}2,\frac{x−y}2)$ 后，原坐标系中的切比雪夫距离$=$新坐标系中的曼哈顿距离

将$(x,y)$变为$(x+y,x−y)$后，原坐标系中的曼哈顿距离$=$新坐标系中的切比雪夫距离

如果$x,y$数组都是有序的，那么

$$ans_x=\sum ^{n}_{j=1}\Delta(j,i)$$

$$=\Delta x(1,i)+\Delta x(2,i)+\Delta x(3,i)+...+\Delta x(n,i)$$

$$=(x_i-x_1)+(x_i-x_2)+...+(x_i-x_{i-1})+(x_{i+1}-x_i)+(x_{i+2}-x_i)+(x_n-x_i)$$

$$=\sum_{j=1}^{i-1}(x_i-x_j)+\sum_{j=i+1}^n(x_j-x_i)$$

$$=\sum_{j=1}^n x_j-2\times\sum_{j=1}^i x_j-x_i\times(n-2\times i)$$

然后就用前缀和优化一下

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+5;
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){
	int x=0,f=1;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=(x+(x<<2)<<1)+c-48;
	return x*f;
}
struct A{ll x,y;}a[N];ll x[N],y[N],s1[N],s2[N],ans=1ll<<62;int n,p,u,v;
int main(){
	n=read();
	for(int i=1;i<=n;++i) u=read(),v=read(),a[i].x=x[i]=u+v,a[i].y=y[i]=u-v;
	sort(x+1,x+n+1);sort(y+1,y+n+1);
	for(int i=1;i<=n;++i) s1[i]=s1[i-1]+x[i],s2[i]=s2[i-1]+y[i];
	for(int i=1;i<=n;++i){
        ll tmp=0;
        p=lower_bound(x+1,x+n+1,a[i].x)-x;tmp+=s1[n]-2*s1[p]-a[i].x*(n-2*p);
        p=lower_bound(y+1,y+n+1,a[i].y)-y;tmp+=s2[n]-2*s2[p]-a[i].y*(n-2*p);
        ans=min(ans,tmp);
	}return !printf("%lld",ans>>1);
}
```

---

## 作者：yukuai26 (赞：3)

涨姿势了
题意，求出以给定点中一点为起点的所有点的最小切比雪夫距离和的最小值

切比雪夫距离=max(|x1-x2|+|y1-y2|);

此题的切比雪夫距离和十分难缠，但是我们可以把他转换为曼哈顿距离，这样就可以快速求出来

让我们愉快地推公式

曼哈顿距离=|x1-x2|+|y1-y2|=max(x1-x2+y1-y2,x1-x2+y2-y1.......)

=max(|(x1+y1)-(x2+y2)|,|(x1-y1)-(x2-y2)|)

我们发现右式是一个切比雪夫距离,这样我们把给定的x,y带进左式，就可以得到新的x',y'

其中x'=x+y>>1;
y'=x-y>>1;

这样就算一下曼哈顿距离就行了

```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 200005
#define inf 1000000000000006
#define mod 1000000007
#define put putchar('\n')
#define int ll
using namespace std;
inline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}
int sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}
inline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}
inline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}
int t,ans,n,m,sumx[N],sumy[N],x,y;
struct xx{
	int x,y,fy,fx,i;
}z[N];
bool cmpx(xx a,xx b){return a.x<b.x;}
bool cmpy(xx a,xx b){return a.y<b.y;}
signed main(){
//	freopen(".in","r",stdin);freopen(".out","w",stdout);
	n=read();
	for (int i=1;i<=n;i++){
		x=read();y=read();z[i].i=i;
		z[i].x=x+y;z[i].y=x-y;
	}
	sort(z+1,z+n+1,cmpx);
	for (int i=1;i<=n;i++){
		z[i].fx=i;
		sumx[i]=sumx[i-1]+z[i].x;
	}
	sort(z+1,z+n+1,cmpy);
	for (int i=1;i<=n;i++){
		z[i].fy=i;
		sumy[i]=sumy[i-1]+z[i].y;
	}
	ans=inf;
	for (int i=1;i<=n;i++){
		t=0;
		t=-sumx[z[i].fx]+z[i].x*z[i].fx-sumy[z[i].fy]+z[i].y*z[i].fy-sumx[z[i].fx]-z[i].x*(n-z[i].fx)+sumx[n]-sumy[z[i].fy]-z[i].y*(n-z[i].fy)+sumy[n];
		ans=min(ans,t);
	}
	wrn(ans/2);
	return 0;
}
```

---

## 作者：Stinger (赞：2)

~~这题紫是不是太过分了点……推导过程纯whk数学和OI几乎无关评绿都可以吧……~~

题意即为给你 $n$ 个点 $(x_i,y_i)$，请选出一个点使得它到其他所有点的切比雪夫距离最小。

即，要求取一个 $k$，使得 $\sum\limits^n_{i=1}\max(\lvert x_i-x_k\rvert,\lvert y_i-y_k\rvert)$ 最小。

考虑枚举 $k$ 快速计算上式的值。

利用 $\lvert x\rvert =\max(x,-x)$，对原式做一些变换。

$$
\begin{aligned}
\max(\lvert x_i-x_k\rvert,\lvert y_i-y_k\rvert)&=\max(\max(x_i-x_k,x_k-x_i)+\max(y_i-y_k,y_k-y_i)\\
&=\max(x_i-x_k+y_i-y_k,x_i-x_k+y_k-y_i,x_k-x_i+y_i-y_k,x_k-x_i+y_k-y_i)
\end{aligned}
$$

即原式等于

$$
\sum\limits^n_{i=1}\max(x_i-x_k+y_i-y_k,x_i-x_k+y_k-y_i,x_k-x_i+y_i-y_k,x_k-x_i+y_k-y_i)
$$

然而只要式子中带着 $\max$ 就仍然不好快速计算，我们目前的出路只有把 $\max$ 化为绝对值快速计算。

可以逆向利用 $\lvert x\rvert =\max(x,-x)$ 化为（这步需要打几个括号然后观察化简）：

$$\sum\limits^n_{i=1}\lvert x_i-x_k\rvert+\lvert y_i-y_k\rvert$$

绝对值可以排序+二分处理，于是这道题就完了。

```cpp
#include <cstdio>
#include <algorithm>
#define int long long

int a[100005], b[100005], x[100005], y[100005], s1[100005], s2[100005];

signed main() {
	int n, ans = 1e18;
	scanf("%lld", &n);
	for (int i = 1; i <= n; ++ i) {
		scanf("%lld%lld", x + i, y + i);
		int tx = x[i], ty = y[i];
		x[i] = tx + ty, y[i] = tx - ty;
		a[i] = x[i], b[i] = y[i];
	}
	std::sort(a + 1, a + n + 1);
	std::sort(b + 1, b + n + 1);
	for (int i = 1; i <= n; ++ i)
		s1[i] = s1[i - 1] + a[i], s2[i] = s2[i - 1] + b[i];
	for (int i = 1; i <= n; ++ i) {
		int tmp = 0, p;
		p = std::lower_bound(a + 1, a + n + 1, x[i]) - a;
		tmp += (p + p - n) * x[i] - s1[p] * 2 + s1[n];
		p = std::lower_bound(b + 1, b + n + 1, y[i]) - b;
		tmp += (p + p - n) * y[i] - s2[p] * 2 + s2[n];
		ans = std::min(ans, tmp);
	}
	printf("%lld", ans / 2);
	return 0;
}
```

---

## 作者：cymrain07 (赞：2)

首先把切比雪夫距离转化为曼哈顿距离：$(x,y)\to(\dfrac{x+y}{2},\dfrac{x-y}{2})$。  
之后枚举每个点 $j$ 作为终点，计算距离和。  
把横坐标之差和纵坐标之差分开考虑：  
横坐标之差：  
先按 $x$ 排序，之后计算前缀和 $\textit{sum}$。

$$
\begin{aligned}
\textit{dis}&=\sum_{i=1}^n |x_i-x_j|\\
&=\sum_{i=1}^j(x_j-x_i)+\sum_{i=j+1}^n(x_i-x_j)\\
&=j\cdot x_j-\textit{sum}(i)+\textit{sum}(n)-\textit{sum}(i)-(n-j)\cdot x_j\\
&=(2j-n)x_j-2\cdot\textit{sum}(i)+\textit{sum}(n)
\end{aligned}
$$

纵坐标同理。  
最后对每个点的答案取 $\min$ 即可。  
注意开 `long long`。

```cpp
#include <bits/stdc++.h>
#define N 100005
using namespace std;
typedef long long ll;
int n;
struct node
{
    int x, y, id;
} d[N];
bool cmpx(node x, node y) { return x.x < y.x; }
bool cmpy(node x, node y) { return x.y < y.y; }
ll s[N], ans[N], fr = (1ll << 62);

int main()
{
    cin >> n;
    for (int i = 1, x, y; i <= n; i++)
    {
        cin >> x >> y;
        d[i].id = i;
        d[i].x = x + y, d[i].y = x - y;
    }
    sort(d + 1, d + n + 1, cmpx);
    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + d[i].x;
    for (int j = 1; j <= n; j++)
        ans[d[j].id] += 1ll * (2 * j - n) * d[j].x - s[j] * 2 + s[n];
    sort(d + 1, d + n + 1, cmpy);
    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + d[i].y;
    for (int j = 1; j <= n; j++)
        ans[d[j].id] += 1ll * (2 * j - n) * d[j].y - s[j] * 2 + s[n];
    for (int i = 1; i <= n; i++) fr = min(fr, ans[i]);
    cout << fr / 2;
    return 0;
}
```


---

## 作者：Star_Cried (赞：1)

## P3964 [TJOI2013]松鼠聚会

曼哈顿距离与切比雪夫距离的相互转化。

### 预备知识

* #### 切里雪夫距离

  定义两个点$(x_1,y_1)$与$(x_2,y_2)$之间的切比雪夫距离为$\max(|x_1-x_2|,|y_1-y_2|)$

* #### 曼哈顿距离

  定义两个点$(x_1,y_1)$与$(x_2,y_2)$之间的切比雪夫距离为$|x_1-x_2|+|y_1-y_2|$

### 题意

平面中给出n个点，求出所有点到其中一个点的切比雪夫距离的和的最小值。

### 思路

切比雪夫距离，我不会求最小值。

但是对于曼哈顿距离，我还是会求的。

如果题目是求曼哈顿距离的话，我们可以通过前缀和优化来$O(1)$求得每个点的答案，最后取最小值即可。

那么我们考虑转化切比雪夫距离为曼哈顿距离。

思考：切比雪夫距离与曼哈顿距离有怎样的联系？能否用$x,y$表示切比雪夫距离而去掉max？

这里有一篇大佬的[blog](https://www.cnblogs.com/zwfymqz/p/8253530.html)

然后我们就知道切比雪夫距离可以表示为$(\frac{x+y}{2},\frac{x-y}{2})$

于是我们就可以用求曼哈顿距离的方法求解。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cctype>
#define int long long
using namespace std;
inline int read(){
	int x=0,w=0;char c=getchar();
	while(!isdigit(c))w|=c=='-',c=getchar();
	while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return w?-x:x;
}
namespace star
{
	const int maxn=1e5+10;
	int n,x[maxn],y[maxn],sum[maxn],ans[maxn];
	struct node{
		int x,y,id;
		inline void change(){
			int xx=x,yy=y;
			x=xx+yy,y=xx-yy;
		}
	}e[maxn];
	inline bool cmp1(node a,node b){return a.x<=b.x;}
	inline bool cmp2(node a,node b){return a.y<=b.y;}
	inline void work(){
		n=read();
		for(int i=1;i<=n;i++) e[i].x=read(),e[i].y=read(),e[i].id=i,e[i].change();
		sort(e+1,e+1+n,cmp1);
		for(int i=1;i<=n;i++)sum[i]=sum[i-1]+e[i].x;
		for(int i=1;i<=n;i++)ans[e[i].id]+=i*e[i].x-sum[i]+(sum[n]-sum[i])-(n-i)*e[i].x;
		memset(sum,0,sizeof sum);
		sort(e+1,e+1+n,cmp2);
		for(int i=1;i<=n;i++)sum[i]=sum[i-1]+e[i].y;
		for(int i=1;i<=n;i++)ans[e[i].id]+=i*e[i].y-sum[i]+(sum[n]-sum[i])-(n-i)*e[i].y;
		int Ans=0x3f3f3f3f3f3f3f3f;
		for(int i=1;i<=n;i++)Ans=min(Ans,ans[i]);
		printf("%lld",Ans>>1);
	}
}
signed main(){
	star::work();
	return 0;
}
```



---

## 作者：Huang_Yuhan (赞：1)

# 题目描述：
草原上住着一群小松鼠,每个小松鼠都有一个家。时间长了,大家觉得应该聚一聚。但是草原非常大,松鼠们都很头疼应该在谁家聚会才最合理。

每个小松鼠的家可以用一个点$x,y$表示,两个点的距离定义为点$(x,y)$和它周围的$8$个点$(x-1,y)(x+1,y),(x,y-1),(x,y+1).(x-1,y+1),(x-1,y-1),(x+1,y+1),(x+1,y-1)$距离为$1$。

$0 \leqslant N \leqslant 100000 ,-10^9 \leqslant x,y \leqslant 10^9$

# 解：

很容易发现这是一道切比雪夫坐标系下的距离。

我们先转换成曼哈顿坐标系。

$(x,y)\rightarrow(\frac{x+y}{2},\frac{x-y}{2})$

然后我们需要找到一个点$k$

使得：

$$\sum_{i=1}^n\{|x_i-x_k|+|y_i-y_k|\}$$
最小。

然后暴力枚举即可。

只需用到前缀和就可以了。

~~突然发现自己智障了还写了个树状数组~~

然后这道题只需要注意一下精度就行了。~~(然而不注意就会WA0)~~

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100000+5;
#define lowbit(x) (x&-x)
typedef long long ll;
ll x[maxn],y[maxn],n,yy[maxn],a[maxn];
ll c[maxn],s[maxn];
void modify(int x,int d)
{
	for(x;x<=n;x+=lowbit(x))
	c[x]+=d;
}
ll ask(int x)
{
	ll sum=0;
	for(x;x;x-=lowbit(x))
	sum+=c[x];
	return sum;
}
bool cmp(int X,int Y)
{return x[X]<x[Y];}
int main()
{
	ll X,Y;
	cin>>n;
	for(int i=1;i<=n;i++){cin>>X>>Y;x[i]=X+Y;y[i]=X-Y;a[i]=i;yy[i]=y[i];}
	sort(a+1,a+1+n,cmp);
	sort(yy+1,yy+1+n);
	for(int i=1;i<=n;i++)
	{
		s[i]=s[i-1]+x[a[i]];
		int k=lower_bound(yy+1,yy+1+n,y[a[i]])-yy;
		modify(k,yy[k]);
	}
	ll ans=0x3f3f3f3f3f3f3f3f3f3f3f3f3f3f,tmp;
	for(int i=1;i<=n;i++)
	{
		tmp=x[a[i]]*i-s[i]+(s[n]-s[i])-x[a[i]]*(n-i);
		int k=lower_bound(yy+1,yy+1+n,y[a[i]])-yy,cnt=upper_bound(yy+1,yy+1+n,y[a[i]])-yy;
		cnt--;
		tmp+=1ll*cnt*y[a[i]];
		tmp-=ask(k);
		tmp+=(ask(n)-ask(k))-1ll*(n-cnt)*y[a[i]];
		ans=min(ans,tmp);
	}
	cout<<ans/2;
}
```



---


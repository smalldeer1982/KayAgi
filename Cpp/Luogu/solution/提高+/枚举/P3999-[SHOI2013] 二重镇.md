# [SHOI2013] 二重镇

## 题目描述

这是一个充满爱的村子，它的名字叫二重镇。在这个爱意浓浓的村子里，居民们的生活快乐又安宁。二重镇呈长条形状，可分为排成一行的 $N$ 个方格。每个格子可能是空地，也可能是小草、灌木、大树、房屋或城堡中的一种物品。每种物品都有一个等级，小草的等级是 $1$，灌木的等级是 $2$，依此类推。

你是这个村庄的建造者。你会陆续获得 $D$ 件物品，你要将它们合理地放置在村庄的空地上。你的目标是要让村子的总人气尽可能大。人气的获得规则在后面说明。关于放置的规则有以下几条：

* 第一，每件物品都必须放在一个地方，不可丢弃，如果没有空地了，游戏直接结束；

* 第二，物品可以放在一格空地上，或者临时放在仓库里。仓库同时最多只能放一件物品，它一开始是空的。只存在一个仓库；

* 第三，一旦物品放在某个空格上，只要符合条件，系统就会自动将一些物品合成一个大的物品，这是强制被动的，也是瞬间的。直到合成结束后，才能放置下一个物品。

* 第四，存放在仓库中的物品，随时可以取出放到空地上（但注意不能在合成的过程中放置），也可以一直留在仓库里。

* 第五，除非利用仓库，不然不能更改物品的放置顺序；

总结起来，这个游戏的流程就是获得一个新物品，决定是否将这个物品存入仓库，再决定将仓库中的物品或新物品放到哪个空地上，系统自动判定合成，获得人气，直到所有物品都被放置完毕，或空地用完为止。

最后是关于合成的规则。合成是自动完成的，也是强制性的。如果有连续两个或以上相邻的格子里有相同等级的物品，它们会自动合体成一个新的物品，新物品的等级比之前高一个级别。合体分三步：

* 第一步，确定有多少物品参与合成，这些物品的位置必须连在一起，等级相同。参与合体的物品会全部消失，对应的格子边成空地；

* 第二步，假设有 $A$ 个 $K$ 级物品参与合体，那么将获得$A\times 2^K$ 点人气。例如有一次五棵小草进行了合体，那么总人气就会增加 $5 \times 2^1=10$；

* 第三步，一个 $K+1$ 等级的物品会出现在一个格子里。如果 $K+1$ 大于 $5$，则跳过这步，但第二步中的人气仍然要算，第一步中的旧物品也会被清除。这个高等级的物品只会出现在参与合体的格子上。每个格子会记录最后一次被放置物品的时间，新的物品会出现在该时间最晚的那个格子里，形象地说，就是出现在最近被放置过东西的格子；

最后，请注意合成是会触发多次的，比如两个小草合成一个灌木，如果这棵灌木旁边还有其他灌木，合体将继续发生下去。

现在，给出 $N$ 和获得物品的顺序及等级，请你要合理地将这些物品放置在一个初始全是空地的村子里，使得村子最终的人气值尽可能高。当所有物品都被放置，或者某一刻村子里没空地了，你都会结束村子的建设，而此时村子里累计人气值就是你的最终成果。


## 说明/提示

对于 $30\%$ 的数据，$N=3$, $D\leq 10$。

对于 $60\%$ 的数据，$N\leq 4$, $D\leq 30$。

对于 $100\%$ 的数据，$N\leq 6$, $D\leq 100$。


## 样例 #1

### 输入

```
4 10
1132411235```

### 输出

```
168```

# 题解

## 作者：maruize (赞：7)

不太好写的状压DP

还是比较好想的：

- 把村庄以六进制压进状态。

- $f_{i,j,st}$前$i$步村庄状态为$j$仓库状态为$st$的最大人气,分三种情况转移。[code中的(1)-(3)]

注意:

- 合成是会触发多次的,需要写个循环。


$\color{brown}{code}$~

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<assert.h>
using namespace std;
typedef long long LL;
#define NS 47000//6^6
char opt[105];
int f[105][NS][6];//f[i][j][st]前i步村庄状态为j仓库状态为st的最大人气
int six[10];//6^k 
inline int bit(register int n,register int b)
	{return n/six[b]%6;}//n的6进制第b位(编号from0) 
int val[NS]//==-1:invalid|==0不能消|other:消除获得的人气
,to[NS];//消除后不包括新产生的那个的其他的状态 
void Up(int&a,int b){a=max(a,b);}//Update
int n;
void print6(int e){//六进制输出(debug) 
	char ou[10];int i;
	memset(ou,'0',sizeof(ou));
	for(i=0;e>0;i++,e/=6)
		ou[i]=e%6+'0';
	for(int j=n-1;j>=0;j--)putchar(ou[j]);
	putchar(' ');
}
int main(){
	int d;
	scanf("%d%d",&n,&d);
	scanf("%s",opt+1);
	for(int i=1;i<=d;i++)opt[i]-='0';
	six[0]=1;
	for(int i=1;i<=n;i++)six[i]=six[i-1]*6;
	
	for(int i=0;i<six[n];i++){
		int cnt=0;
		for(int j=0;j<n-1;j++){
			int u=bit(i,j),k=2,s=0;
			if(u==0||u!=bit(i,j+1))continue;
			cnt++,s=u*six[j]+u*six[j+1],j++;
			if(cnt>1){val[i]=-1;break;}
			while(bit(i,j+1)==u)j++,k++,s+=u*six[j];
			val[i]=k*(1<<u),to[i]=i-s;
		}
		if(cnt==0)val[i]=0,to[i]=i;//useless
	}//预处理val,to 
	
	memset(f,-0x3f,sizeof(f)),f[0][0][0]=0;
	for(int i=1;i<=d;i++){//i:第几步
		for(int j=0;j<six[n];j++){//j:状态
			if(val[j]!=0)continue;
			Up(f[i][j][opt[i]],f[i-1][j][0]);//放仓库。(1)
			for(int k=0;k<n;k++){//k:放哪儿
				if(bit(j,k)!=0)continue;
				for(int st=0;st<6;st++){//st:仓库
					int nxt=j+six[k]*opt[i],v=0,t=1;
					while(val[nxt]!=0){//循环"合成"
						assert(val[nxt]!=-1);
						v+=val[nxt];
						nxt=to[nxt]+(opt[i]+t)%6*six[k];
						//如果opt[i]+t==6那么val[nxt]肯定合法,所以只%一下就行可以少一行特判
						t++;
					}
					Up(f[i][nxt][st],f[i-1][j][st]+v);//仓库不变。(2)
				}
			}
		}
		for(int j=0;j<six[n];j++){
			if(val[j]!=0)continue;
			for(int k=0;k<n;k++){
				if(bit(j,k))continue;
				for(int st=1;st<6;st++){//j,st:状态;k:放哪儿
					int nxt=j+six[k]*st,v=0,t=1;
					while(val[nxt]!=0){//循环同上
						assert(val[nxt]!=-1);
						v+=val[nxt];
						nxt=to[nxt]+(st+t)%6*six[k];
						t++;
					}
					Up(f[i][nxt][0],f[i][j][st]+v);//clear仓库。(3)
				}
			}
		}
	}
	int ans=0;
	for(int a=1;a<=d;a++)
		for(int i=0;i<six[n];i++){
			if(val[i]!=0)continue; 
			for(int st=0;st<6;st++)
				ans=max(ans,f[a][i][st]);
		}
	printf("%d\n",ans);
	return 0;
}
```

$O(6^{n+1}dn)$

---

## 作者：logeadd (赞：6)

思路借鉴了[这个博客](http://www.cnblogs.com/wangyurzee7/p/5267194.html)：

我们可以想到状压dp

用一个十进制数来表示状态，即第i位表示位置i处的物品等级

用f[i][j][k]表示第i天，仓库的物品等级为j，状态为k时的最大收益

但是状态数貌似很多，开不下，同时上面的式子好像不太好转移

我们可以预处理出所有的合法状态，即无法消除的状态，然后在预处理出所有状态可能的转移，即枚举空位放那些等级的物品，用e[i][j][k]表示状态i，在第k个空位填等级为j的物品会转移到的状态编号，dis[i][j][k]表示这种转移所得到的收益，这样就方便转移了

注意到我们还要考虑到仓库中的物品，即会有f[i][j][k]转移到f[i][0][s]的情况，所以我们枚举第二维的顺序应该是倒序枚举(即最后考虑f[i][0]的状态）

细节有点多，注意不要写挂
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>

using namespace std;

const int mn = 8;
const int maxn = 105;
const int mx = 25005;//状态总数

char s[maxn];
int n,m,a[mn],b[mn],cnt,g[maxn];
int sit[mn],id[700005];
int e[mx][mn][mn],dis[mx][mn][mn],head[mx];

int xiao(int *a,int pos,int &val)
{
    val=0;
    while(a[pos])
    {
        int tmp=a[pos],l=pos,r=pos;
        while(a[l]==a[l-1] && l>1) l--;
        while(a[r]==a[r+1] && r<n) r++;
        if(l==r) break;
        val+=(r-l+1)*(1<<tmp);
        for(int i=l;i<=r;i++)
            a[i]=0;
        a[pos]=(tmp+1)%6;
    }
    int tmp=0;
    for(int i=1;i<=n;i++)
        tmp=tmp*10+a[i];
    if(!id[tmp]) id[tmp]=++cnt;
    return id[tmp];
}

void dfs(int x)
{
    //printf("%d\n",x);
    if(x>n)
    {
        int now = xiao(a,0,b[0]);
        for(int i=1;i<=n;i++)
        {
            if(!a[i])
            {
                ++head[now];
                for(int j=1;j<=5;j++)
                {
                    for(int k=1;k<=n;k++)
                        b[k]=a[k];
                    b[i]=j;
                    e[now][j][head[now]] = xiao(b,i,dis[now][j][head[now]]);
                }
            }
        }
        return ;
    }
    for(int i=0;i<=5;i++)
    {
        if(x==1 || !a[x-1] || !i || a[x-1]!=i)
        {
            a[x]=i;
            dfs(x+1);
        }
    }
}
int f[maxn][mn][mx];
int dp()
{
    memset(f,-1,sizeof(f));
    int ans=0;
    f[0][0][1]=0;
    for(int i=0;i<=m;i++)
        for(int k=5;k>=0;k--)
            for(int j=1;j<=cnt;j++)
            {
                if(f[i][k][j]>=0)
                {
                    if(i<m)
                    {
                        for(int s=1;s<=head[j];s++)
                            f[i+1][k][e[j][g[i+1]][s]]=max(f[i+1][k][e[j][g[i+1]][s]],f[i][k][j]+dis[j][g[i+1]][s]);
                    }
                    if(k)
                    {
                        for(int s=1;s<=head[j];s++)
                            f[i][0][e[j][k][s]]=max(f[i][0][e[j][k][s]],f[i][k][j]+dis[j][k][s]);
                    }
                    else  f[i+1][g[i+1]][j]=max(f[i+1][g[i+1]][j],f[i][k][j]);
                    ans=max(ans,f[i][k][j]);
                }
            }
    return ans;
}
int main()
{
    scanf("%d%d",&n,&m);
    scanf("%s",s+1);
    for(int i=1;i<=m;i++)
        g[i]=s[i]-'0';
    dfs(1);
    printf("%d\n",dp());
    return 0;
}

```

---

## 作者：cff_0102 (赞：3)

本题是状压 dp，不过每一位有六种状态。

用记忆化搜索，每次传参有剩余还要建设的天数、当前仓库里放的东西的等级以及目前的状态。

每次枚举每一位，尝试在所有空位中放入仓库内的数（如果有的话）以及今天给的数（如果不是最后一天结束后还要放仓库的话）。放入之后尝试合并，每次合并只需要看前一位和后一位的就行了，因为如果前一位的前一位、后一位的后一位还有相同的数，那么它们在这之前早就合并了。

另外需要注意的是题意理解的问题，题目中提到“第三步，一个 $K+1$ 等级的物品会出现在一个格子里。如果 $K+1$ 大于 $5$，则跳过这步”，也就是说，如果这是多个等级为五的物品合并，最后什么都不会留下，变成一片空地，而不是剩下一个等级为五的格子，其它的变为空地。如果没有正确理解的话就只能拿 $40$ 分。

从讨论区看到这题有点卡常，于是决定用八进制位描述状态，这样取出每一位就更方便，结果被“卡空间”了 qwq，于是后面把用来存储的地方加了个八进制转六进制，有点奇怪，不过还是 AC 了。

AC 代码：

```cpp
#include<bits/stdc++.h>
#define bit8(x) (1<<(3*(x-1)))//8 进制位下第 x 位为 1 的数
#define kthbit(x,y) (x&(7<<(3*(y-1))))//8 进制位下 x 的第 y 位的数
//#define int long long
using namespace std;
int n;
int l[105];//还剩 i 天的时候的新物品
int dp[105][6][46656];
int merge(int t,int x,int p,int&tot){//在第 p 个位置放一个 x，并合并
	if(x==0)return t;
	int a[n+2];a[0]=a[n+1]=0;
	for(int i=1;i<=n;i++){
		a[i]=(kthbit(t,i)>>(3*(i-1)));
	}
	int cnt=0;//合并的数量 
	if(a[p-1]==x)a[p-1]=0,cnt++;
	if(a[p+1]==x)a[p+1]=0,cnt++;
	if(cnt)tot+=((cnt+1)<<x);
	if(!cnt)a[p]=x;
	int tt=0;
	for(int i=1;i<=n;i++){
		tt|=bit8(i)*a[i];
	}
	if(!cnt)return tt;
	return merge(tt,(x+1)%6,p,tot);
}
int dfs(int d,int x,int t){//还要建设几天；仓库放了什么；目前状态
	int t6=0;
	int tot=0;//积累人气 
	int a[n+1];
	int six=1;
	for(int i=1;i<=n;i++){
		a[i]=(kthbit(t,i)>>(3*(i-1)));
		t6+=a[i]*six;six*=6;
	}
	if(dp[d][x][t6]!=-1)return dp[d][x][t6];
	for(int i=1;i<=n;i++){
		if(a[i]==0){//可以放东西
			if(x){//尝试放仓库 
				int tmp=0;
				int newt=merge(t,x,i,tmp);
				tmp+=dfs(d,0,newt);
				tot=max(tot,tmp);
			}
			if(d>0){//尝试放新东西 
				int tmp=0;
				int newt=merge(t,l[d],i,tmp);
				tmp+=dfs(d-1,x,newt);
				tot=max(tot,tmp);
			}
		}
	}
	if(x==0&&d>0){//存仓库 
		int tmp=0;
		tmp+=dfs(d-1,l[d],t);
		tot=max(tot,tmp);
	}
//	cout<<t<<" means ";
//	for(int i=1;i<=n;i++)cout<<a[i]<<" ";
//	cout<<" ; "<<d<<" days left and "<<x<<" is stored and ans is "<<tot<<endl;
	return dp[d][x][t6]=tot;
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int d;cin>>n>>d;
	for(int i=0;i<=d;i++){
		for(int j=0;j<=5;j++){
			for(int k=0;k<46656;k++){
				dp[i][j][k]=-1;
			}
		}
	}
	string s;cin>>s;
	for(int i=d;i>=1;i--){
		l[i]=s[d-i]-'0';
	}
	cout<<dfs(d,0,0);
	return 0;
}
```

AC 记录：<https://www.luogu.com.cn/record/176693621>，这题确实比较卡常，如果评测机波动的话提交同样的代码可能会在第九个测试点 TLE，如果取消掉 `#define int long long` 的注释就会 T 飞。

---

## 作者：shuqiang (赞：2)

这是一道特殊的状压 dp。

设 $f_{i,j,k}$ 表示前 $i$ 步仓库里的物品等级为 $j$，地里的物品等级的六进制 $k$ 时可以得到的最大人气，状态不合法则 $f_{i,j,k}=-1$。

显然，初始状态为 $f_{0,0,0}=0$（步数从 $0$ 开始）。

为了放下仓库的东西，我们可以把第一维开到两倍，如果步数是偶数，我们就放下字符串的第 $\frac{i}{2}$ 个等级的物品，否则就放下仓库里的物品，或者不放。

为了获取 $x$ 的六进制下第 $y$ 位的数值，我们可以先维护 $6$ 的幂，然后这个值就是 $\lfloor \frac{x}{6^{y-1}} \rfloor \bmod 6$，代码如下：


```cpp
int get(int x, int y){
	return x / pow6[y] % 6;
}
```

接下来，我们先实现在一个状态中放置物品的转移，显然，在转移前，一定没有连续两个相同等级的物品，这个转移分五种情况：

1. 有两个相同等级的在一个空地的两侧。
2. 先合成左边，再合成右边。
3. 先合成右边，再合成左边。
4. 仅合成右边。
5. 仅合成左边。

代码如下：

```cpp
// ni 表示当前步数，nj 表示要转移的仓库状态。
// lj 表示当前的仓库状态，nk 表示当前状态。
// w 表示要放置的物品。
void merge(int ni, int nj, int lj, int nk, int w){
	for(int ii = 0; ii < n; ii++){
		if(get(nk, ii) == 0){
			int t = nk, cnt = 0, nw = w;
            // cnt 表示累计答案。
            // nw 表示当前放置的物品等级。
            // 先放置物品。
			t += nw * pow6[ii];
            // 解决情况 1。
			if(ii != 0 && ii != n-1 && get(t, ii-1) == nw && get(t, ii+1) == nw){
				t -= nw * pow6[ii-1] + nw * pow6[ii] + nw * pow6[ii+1];
				cnt += pow2[nw] * 3; nw++;
				if(nw <= 5){
					t += nw * pow6[ii];
				}
			}
           // 解决情况 5。
			if(ii != 0 && get(t, ii-1) == nw){
				t -= nw * pow6[ii-1] + nw * pow6[ii];
				cnt += pow2[nw] * 2; nw++;
				if(nw <= 5){
					t += nw * pow6[ii];
				}
			}
           // 解决情况 2,4。
			if(ii != n-1 && get(t, ii+1) == nw){
				t -= nw * pow6[ii+1] + nw * pow6[ii];
				cnt += pow2[nw] * 2; nw++;
				if(nw <= 5){
					t += nw * pow6[ii];
				}
			}
           // 解决情况 3。
			if(ii != 0 && get(t, ii-1) == nw){
				t -= nw * pow6[ii-1] + nw * pow6[ii];
				cnt += pow2[nw] * 2; nw++;
				if(nw <= 5){
					t += nw * pow6[ii];
				}
			}
           //转移方程
			f[ni+1][nj][t] = max(f[ni+1][nj][t], f[ni][lj][nk] + cnt);
			ans = max(ans, f[ni][lj][nk] + cnt);
		}
	}
}
```

然后就是主函数了：


```cpp
#include<iostream>
#include<string>

using namespace std;

const int N = 10, D = 210, M = 5e4 + 10;
int n, d, pow2[N], pow6[N], f[D][6][M], ans = -1;
string s;

// 这里是 get,merge 函数。

int main(){
	cin >> n >> d >> s;
    // 预处理 6,2 的幂
	pow6[0] = 1;
	for(int i = 1; i <= n; i++) pow6[i] = pow6[i-1] * 6;
	pow2[0] = 1;
	for(int i = 1; i <= 5; i++) pow2[i] = pow2[i-1] * 2;
    //初始化
	for(int i = 0; i < D; i++){
		for(int j = 0; j < 6; j++){
			for(int k = 0; k < M; k++) f[i][j][k] = -1;
		}
	}
	f[0][0][0] = 0;
	for(int i = 0; i < d*2; i++){
		for(int j = 0; j < 6; j++){
			for(int k = 0; k < pow6[n]-1; k++){
				if(i & 1){
					if(f[i][j][k] != -1){
						f[i+1][j][k] = f[i][j][k]; //不放下仓库里的物品
						if(j != 0) merge(i, 0, j, k, j); //放下仓库里的物品
					}
				}
				else{
					if(f[i][j][k] != -1){
						int w = s[i/2] - '0';
						if(j == 0){
							f[i+1][w][k] = max(f[i+1][w][k], f[i][j][k]);
							ans = max(ans, f[i][j][k]);
                            //把当前物品放在仓库里。
						}
						merge(i, j, j, k, w);
                        //直接把物品放在地里。
					}
				}
				
			}
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：hgzxwzf (赞：0)

## [P3999](https://www.luogu.com.cn/problem/P3999)

### 解题思路：

注意到等级不会超过 $5$，且 $n\le 6$，所以可以设 $dp_{i,j}$ 表示考虑到第 $i$ 个物品，$j$ 是一个六进制数，记录每个位置和仓库物品的等级。

对于合并操作，可以去暴力 dfs，因为每次合并物品数量都至少减 $1$，所以一次最多合并 $O(n)$ 次。

因为合并得到的物品要求放在合并物品中最后放的，可以发现放完一个物品后，所有合并操作得到的新物品都是放在这个物品所放位置的。

对于一个物品，要分 $3$ 步：

1. 枚举所有上一次的状态，考虑当前这个物品放哪个空位，得到下一个状态，然后转移。
2. 枚举所有仓库中有物品的状态，考虑仓库中的物品放哪个空位，得到下一个状态，然后转移。
3. 用已经填满所有格子的状态更新答案。

这样操作的好处在于，既包含了先从仓库拿物品，再考虑当前物品的位置的情况，也包含了先考虑当前物品的位置，再考虑仓库中的物品的情况。

总时间复杂度 $O(6^n\times n^2)$。

### 代码：
```cpp
const int N=6*6*6*6*6*6*6+10;

int dp[2][N],a[10],ta[10],mi6[10],n,cur;

pi get(int x)
{
	int i=x,l,r;
	while(i>1&&ta[i-1]==ta[x]) i--;
	l=i;
	i=x;
	while(i<n&&ta[i+1]==ta[x]) i++;
	r=i;
	if(l==r)
	{
		int sum=0;
		per(j,1,n+1) sum=sum*6+ta[j];
		return mk(sum,0);
	}
	else
	{
		int tem=ta[x];
		rep(j,l,r) ta[j]=0;
		pi res;
		if(tem<5) ta[x]=tem+1,res=get(x);
		else
		{
			int sum=0;
			per(j,1,n+1) sum=sum*6+ta[j];
			res=mk(sum,0);
		}
		int sum=1;
		rep(i,1,tem) sum*=2;
		return mk(res.fi,res.se+sum*(r-l+1));
	}
}

int main()
{
	memset(dp,-1,sizeof(dp));
	int d,ans=0;
	scanf("%d%d",&n,&d);
	mi6[0]=1;
	rep(i,1,n+1) mi6[i]=mi6[i-1]*6;
	dp[cur][0]=0;
	rep(i,1,d)
	{
		cur^=1;
		memset(dp[cur],-1,sizeof(dp[cur]));
		int x;
		scanf("%1d",&x);
		rep(j,0,mi6[n+1]-1)
		{
			if(dp[cur^1][j]==-1) continue;
			rep(k,1,n+1) a[k]=0;
			int t=0,s=j,ss=j;
			while(ss) a[++t]=ss%6,ss/=6;
			rep(k,1,n)
				if(!a[k]) 
				{
					a[k]=x;
					rep(h,1,n+1) ta[h]=a[h];
					pi ns=get(k);
					dp[cur][ns.fi]=max(dp[cur][ns.fi],dp[cur^1][s]+ns.se);
					a[k]=0;
				}
			if(!a[n+1])
			{
				int ns=s+mi6[n]*x;
				dp[cur][ns]=max(dp[cur][ns],dp[cur^1][s]);
			}
		}
		rep(j,0,mi6[n+1]-1)
		{
			if(dp[cur][j]==-1) continue;
			rep(k,1,n+1) a[k]=0;
			int t=0,s=j,ss=j;
			while(ss) a[++t]=ss%6,ss/=6;
			if(a[n+1])
				rep(k,1,n)
					if(!a[k])
					{
						int tem=a[n+1];
						a[k]=a[n+1];
						a[n+1]=0;
						rep(h,1,n+1) ta[h]=a[h];
						pi ns=get(k);
						dp[cur][ns.fi]=max(dp[cur][ns.fi],dp[cur][s]+ns.se);
						a[k]=0;
						a[n+1]=tem;
					}
		}
		rep(j,0,mi6[n+1]-1)
		{
			if(dp[cur][j]==-1) continue;
			rep(k,1,n+1) a[k]=0;
			int t=0,s=j,ss=j;
			while(ss) a[++t]=ss%6,ss/=6;
			bool f=1;
			rep(k,1,n+1) if(!a[k]) {f=0;break;}
			if(f) ans=max(ans,dp[cur][j]);
		}
	}
	rep(i,0,mi6[n+1]-1) 
	{
		ans=max(ans,dp[cur][i]);
	}
	printf("%d",ans);
	return 0;
}
```


---


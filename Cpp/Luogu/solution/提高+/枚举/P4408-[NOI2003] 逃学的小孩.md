# [NOI2003] 逃学的小孩

## 题目描述

Chris 家的电话铃响起了，里面传出了 Chris 的老师焦急的声音：“喂，是 Chris 的家长吗？你们的孩子又没来上课，不想参加考试了吗？”一听说要考试，Chris 的父母就心急如焚，他们决定在尽量短的时间内找到 Chris。他们告诉 Chris 的老师：“根据以往的经验，Chris 现在必然躲在朋友 Shermie 或 Yashiro 家里偷玩《拳皇》游戏。现在，我们就从家出发去找 Chris，一旦找到，我们立刻给您打电话。”说完砰的一声把电话挂了。

Chris 居住的城市由 $N$ 个居住点和若干条连接居住点的双向街道组成，经过街道 $x$ 需花费 $T_{x}$ 分钟。可以保证，任意两个居住点间有且仅有一条通路。Chris 家在点 $C$，Shermie 和 Yashiro 分别住在点 $A$ 和点 $B$。Chris 的老师和 Chris 的父母都有城市地图，但 Chris 的父母知道点 $A$、$B$、$C$ 的具体位置而 Chris 的老师不知。

为了尽快找到 Chris，Chris 的父母会遵守以下两条规则：

1. 如果 $A$ 距离 $C$ 比 $B$ 距离 $C$ 近，那么 Chris 的父母先去 Shermie 家寻找 Chris，如果找不到，Chris 的父母再去 Yashiro 家；反之亦然。
2. Chris 的父母总沿着两点间唯一的通路行走。

显然，Chris 的老师知道 Chris 的父母在寻找 Chris 的过程中会遵守以上两条规则，但由于他并不知道 $A$、$B$、$C$ 的具体位置，所以现在他希望你告诉他，最坏情况下 Chris的父母要耗费多长时间才能找到 Chris？

## 说明/提示

对于 $100\%$ 的数据，$3 \le N \le 2\times 10^5$，$1 \le U_{i},V_{i} \le N$，$0 \le T_{i} \le 10^{9}$。

## 样例 #1

### 输入

```
4 3
1 2 1
2 3 1
3 4 1```

### 输出

```
4```

# 题解

## 作者：C3H5ClO (赞：101)

自己为贪心的合理性纠结了好久，题解里也没有严谨证明，我来写一下吧。

贪心的思路：找直径，直径端点为A,B,枚举C点则答案为$max(min(dis[A][k],dis[B][k])+dis[A][B])$

用反证法证明。

假设有一种情况，存在一条非直径路径DE，C先去D、E中距离较小点，再走过D、E间路径，所得的答案最大。

分两种情况讨论。

## 第一种情况，AB与DE有交点。
C与AB直接相连的情况如下图：

![](https://cdn.luogu.com.cn/upload/pic/69903.png)

根据直径定义可知　$d+e>a+b+c,d+e\ge d+c,d+e\ge e+a+b$

整理可得　

$d+e>a+b+c$------[1]

$e\ge c$------[2],     

$d\ge a+b$------[3]

此时C点到A、B点的答案$S1=d+e+min(e+b+f,d+b+f)=d+e+b+f+min(e,d)$

C点到D、E点的答案$S2=a+b+c+min(f+a,f+b+c)=a+b+c+f+min(a,b+c)$

$S1-S2=d+e-a-b-c+b+min(e,d)-min(a,b+c)=(d+e-a-b-c)+min(d,e)-min(a-b,c)$

由[1]得$d+e-a-b-c>0$

当$a-b\le c$时,$S1-S2=(d+e-a-b-c)+min(d,e)-(a-b)$

由[2]得$e>c\ge a-b$,由[3]得$d\ge a+b\ge a-b$，因此此时$S1-S2>0$

当$a-b>c$时，$S1-S2=(d+e-a-b-c)+min(d,e)-c$

由[2]得$e\ge c$,由[3]得$d\ge a+b\ge a-b>c$，因此此时$S1-S2>0$

C与AB直接相连的情况同样类似。

## 第二种情况，AB与DE无交点。

由树的联通无环性可知AB与DE有且仅有一条路径相连，C与DE直接相连的情况如下图：

![](https://cdn.luogu.com.cn/upload/pic/58646.png)

由直径的定义可知$a+b>d+e+f,a+b\ge c+d+b,a+b\ge a+c+e+f$

整理可得

$a+b>d+e+f$------[1]

$a\ge c+d$------[2]

$b\ge c+e+f$------[3]

此时C到A、B的答案$S1=a+b+min(a+c+e+g,b+c+e+g)=a+b+c+e+g+min(a,b)$

C到D、E的答案$S2=d+e+f+min(d+e+g,f+g)=d+e+f+g+min(d+e,f)$

$S1-S2=a+b-d-e-f+c+e+min(a,b)-min(d+e,f)=(a+b-d-e-f)+min(a,b)-min(d-c,f-e-c)$

由[1]得$a+b-d-e-f>0$

当$d-c\le f-e-c$时,$S1-S2=(a+b-d-e-f)+min(a,b)-(d-c)$

由[2]得$a\ge c+d>d-c$,由[3]得$b\ge c+e+f>f-e-c\ge d-c$,因此此时$S1-S2>0$

当$d-c>f-e-c$时,$S1-S2=(a+b-d-e-f)+min(a,b)-(f-e-c)$

由[2]得$a\ge c+d>d-c>f-e-c$,由[3]得$b\ge c+e+f>f-e-c$,因此此时$S1-S2>0$

C与$c$直接相连或与AB直接相连的情况类似。

综上，当DE不是直径时，总有一条C到直径AB的方案使答案更大，与假设C到DE的方案最大矛盾，因此假设不成立，原命题得证。


------------
update:使用了LaTeX格式，对部分式子做了小改动，希望管理员给过

---

## 作者：人殇物已非 (赞：52)

$update2021.2.6:$解释了评论区的$AC>AB$问题，避免了引起误解.

发现有些题解讲的略有问题，不知道是没想清楚就混过去了还是说的不清楚让人理解偏差，所以就写一篇题解来给大家细细理一下这个题的思路。

题意虽然说先去谁家再去谁家，但是我们不需要管这个，因为$A$、$B$、$C$三个点我们可以任意互相交换它们所代表的对象，所以题目要求的就是在一棵**树**上找到3个点$A$、$B$、$C$令$AB+BC$最大，同时要满足$AC>AB$。

由于这是一棵树，它满足非常可爱的性质，就是如果找一个点出去两条路径使它们的合最大，那么一条是直径时一定会存在一种最大的方案。

所以我们可以使要找的两条路径其中一条是直径（设为$AB$），然后枚举剩下的点，找到一个到达直径端点最长的另一条路径，不过因为题目要满足一个先去近的点再去远的点，所以我们需要在每次枚举的时候（设为$C$），选择$AC$和$BC$的较小的一条边作为另一条路径。可以看到，若是$AC$是小于$BC$的，则选择的路径是$AC$，实际走的路线是$CA$+$AB$，满足题目要求的$CA<CB$，而若是选择的是$BC$，实际路线是$CB$+$BA$，也符合题意要求的$CB<CA$。

至此，就可以写出代码了，跑2遍dfs找出直径，再对直径起点和终点跑出对每个点的路径长度，然后计算答案。

### $code:$
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=200010;
struct edge{
    int to,next,w;
}e[maxn<<1];
int n,m,cnt;
int dis1[maxn],dis2[maxn],last[maxn];
int st,ed;
inline void add(int u,int v,int w){
    cnt++;
    e[cnt].to=v;
    e[cnt].next=last[u];
    last[u]=cnt;
    e[cnt].w=w;
}
void dfs1(int u,int fa){
    for(int i=last[u];i;i=e[i].next){
        int v=e[i].to;
        if(v==fa) continue;
        dis1[v]=dis1[u]+e[i].w;
        if(dis1[v]>dis1[st]) st=v;
        dfs1(v,u);
    }
}
void dfs2(int u,int fa){
    for(int i=last[u];i;i=e[i].next){
        int v=e[i].to;
        if(v==fa) continue;
        dis2[v]=dis2[u]+e[i].w;
        if(dis2[v]>dis2[ed]) ed=v;
        dfs2(v,u);
    }
}
void dfs3(int u,int fa){
    for(int i=last[u];i;i=e[i].next){
        int v=e[i].to;
        if(v==fa) continue;
        dis1[v]=dis1[u]+e[i].w;
        dfs3(v,u);
    }
}
void dfs4(int u,int fa){
    for(int i=last[u];i;i=e[i].next){
        int v=e[i].to;
        if(v==fa) continue;
        dis2[v]=dis2[u]+e[i].w;
        dfs4(v,u);
    }
}
signed main(){
    cin>>n>>m;
    for(int i=1,u,v,w;i<=m;i++){
        scanf("%lld %lld %lld",&u,&v,&w);
        add(u,v,w),add(v,u,w);
    }
    dfs1(1,0);
    dfs2(st,0);
    int ans=dis2[ed];
    memset(dis1,0,sizeof(dis1)),memset(dis2,0,sizeof(dis2));
    dfs3(st,0),dfs4(ed,0);
    int tmp=0;
    for(int i=1;i<=n;i++){//枚举点C
        int d=min(dis1[i],dis2[i]);
        if(d>tmp) tmp=d;
    }
    ans+=tmp;
    cout<<ans;
}
```

---

## 作者：7KByte (赞：21)

这道题的模型应该是很清晰的，出题人为了在某种程度上增加题目的难度就在题目里添加了很多废话  
题干是：在一棵无根树上，找$A,B,C$三个点，使得$AB+BC(AC>BC)$或$AC+AB(BC>AC)$最大。  
因为题目没有要求输出点，所以如果我们将$A,B$对换，那么这两个式子实际上是同一个式子  
我们只用找最大的$AB+BC(AC>BC)$  
简单贪心一下，先令$AB$最大，然后再找一个相应的最大的$BC$，强调要满足$(AC>AB)$  
所以我们首先找出一条直径，然后枚举除端点外的点$C$，使得$MIN(AC,BC)$最大，$Ans=$树的直径$+MIN(AC,BC)$  
个人感觉代码还是比较可读的  
记得要开$long long$  


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct edge{
	int to;
	int next;
	int data;
}e[2000000];
int n,m,h[200005],pop=0;
void add(int x,int y,int z){
	pop++;
	e[pop].to=y;
	e[pop].next=h[x];
	h[x]=pop;
	e[pop].data=z;
}
int d[200005],v[200005];
queue<int>q;
int bfs(int s){
	memset(d,0,sizeof(d));
	memset(v,0,sizeof(v));
	while(q.size())q.pop();
	q.push(s);v[s]=1;
	int Max=0,maX;
	while(q.size()){
		int x=q.front(),y;q.pop();
		for(int i=h[x];i;i=e[i].next){
			if(v[y=e[i].to])continue;
			v[y]=1;
			d[y]=d[x]+e[i].data;
			q.push(y);
			if(d[y]>Max){
				Max=d[y];
				maX=y;
			}
		}
	}
	return maX;
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;i++){
		int x,y,z;
		scanf("%lld%lld%lld",&x,&y,&z);
		add(x,y,z);add(y,x,z);
	}
	int l=bfs(1);
	int r=bfs(l);
	int k[200005];
	int ans=d[r];
	for(int i=1;i<=n;i++)
	  k[i]=d[i];
	bfs(r);
	int M=0;
	for(int i=1;i<=n;i++){
		M=max(M,min(d[i],k[i]));
	}
	printf("%lld\n",ans+M);
	return 0;
}
```

---

## 作者：DarthVictor (赞：15)

## 题目
[原题链接](https://www.luogu.com.cn/problem/P4408)
## 解说
分享题说实话最开始都没什么思路，之前的大部分基本都看了一下题解启发思路。

![](https://cdn.luogu.com.cn/upload/image_hosting/prxtybsg.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

但这道题我可以大声而骄傲地说：它  是  我  完  完  全  全  自  己  做  出  来  的  ！

~~当然，代价就是Vjudge上WA了5遍，洛谷上WA了1遍，坑杀了我一节半课的时间。~~

那么，转到正题，思路是怎么样的呢？

首先可见这个图是一棵树，我们需要找到三个点，暂时叫ABC吧。其中（A到B的距离+C到AB距离中较短的）这一值最小。

（以下maxdis代表树的直径，maxv代表第一遍DFS找到的直径端点，End代表第二遍DFS找到的另一个端点，bj i代表点是否在直径上，ans i 以及之后的ans1 i 代表节点 i 到maxv的距离，ans2 i 代表节点 i 到End的距离，b代表最后的答案）

很显然这属于树的直径题。用两遍DFS找出树的两个顶点……之后呢？我在这里第一次卡住了。

由于万恶的样例带来的错觉，我觉得题目要求的点一定是在直径上。所以我就用了第三遍DFS，找出来了所有直径上的点，在第二遍DFS的时候顺带计算出ans  i，之后循环一遍找到答案就行。循环大概就是：
```cpp
for(int i=1;i<=n;i++) if(bj[i]==1&&i!=End&&i!=maxv) b=max(b,min(maxdis-ans[i],ans[i]));
```
然后就WA了。

之后很长时间我就卡在了这个代码的框框里，因为我一直坚定地认为要求的点在直径上。卡了半天还是感谢洛谷提供的一组错误样例让我恍然大悟：

我的C为什么一定要在直径上？！

下面是洛谷给的样例：

![出错的样例](https://cdn.luogu.com.cn/upload/image_hosting/86n1fe37.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

简洁明了但很有说服力。

显然，树的直径是2-4或3-4。由于这两种没有差别下面就用2-4举例。

如果按照之前的想法，C在直径上，那么我算出来的结果是4.但若我们选3作为C呢？

2到4的距离+3到2,4距离中较短的=5。

也就是说C不一定在直径上。

噫，好了，全崩了。

但是思路正确了应该就没什么问题了。我们在第二遍dfs的时候顺带算出各点到maxv的距离，之后再DFS一遍算出各点到End的距离，之后把各个点遍历一遍算min(ans1[i],ans2[i])+maxdis的最大值即可。
## 代码
```cpp
#include<cstdio>
#include<iostream>
#include<queue>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
typedef long long ll;
const int maxn=200000+3;
int n,m,tot,head[maxn],End,maxv;
ll maxdis,ans1[maxn],ans2[maxn];
struct node{
    int to,next;
    ll w;
}e[2*maxn];
void Add(int from,int to,ll w){
    e[tot].w=w;
    e[tot].to=to;
    e[tot].next=head[from];
    head[from]=tot;
    tot++;
}
void dfs1(int u,int f,ll dis){//找第一个端点 
    if(maxdis<dis) {
        maxv=u;
        maxdis=dis;
    }
    for(int i=head[u];i;i=e[i].next){
        int v=e[i].to;ll w=e[i].w;
        if(v==f) continue;
        dfs1(v,u,dis+w);
    }
}
void dfs2(int u,int f,ll dis){//找第二个端点 
    ans1[u]=dis;//顺带求出所有点到maxv的距离 
    if(maxdis<dis) {
        maxdis=dis;
        End=u;
    }
    for(int i=head[u];i;i=e[i].next){
        int v=e[i].to;ll w=e[i].w;
        if(v==f) continue;
        dfs2(v,u,dis+w);
    }
}
void dfs3(int u,int f,ll dis){//求所有点到End的距离 
    ans2[u]=dis;
    for(int i=head[u];i;i=e[i].next){
        int v=e[i].to;ll w=e[i].w;
        if(v==f) continue;
        dfs3(v,u,dis+w);
    }
}
int main(){
    int n,m;
    tot=1;
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        int from,to;ll w;
        cin>>from>>to>>w;
        Add(from,to,w);
        Add(to,from,w);
    }
    dfs1(1,-1,0);
    maxdis=0;
    dfs2(maxv,-1,0);
    dfs3(End,-1,0);
    ll b=-1;
    for(int i=1;i<=n;i++) if(i!=End&&i!=maxv) b=max(b,min(ans1[i],ans2[i])+maxdis); 
    //找最佳点 
    cout<<b;
    return 0;
}
```
幸甚至哉，歌以咏志。

---

## 作者：Ofnoname (赞：13)

题目中“可以保证，任两个居住点间有且仅有一条通路”说明输入数据是一棵树。显然最优解需要从C先跑到A在跑到B.或者从C先跑到B在跑到A。

1. 假设我们已经确定A,B点，那么AB是必走的，CA,CB会选取其中小的一段走，所以我们的C点要满足`min(CA,CB)`最大，这样就可以使答案最大。

2. 如何确定A,B点？既然AB是必走的，那当然越长越好，所以就是树的直径了。由于这里只需要求树直径的端点和总长而不用求具体路线，我就选择了DFS来求。

3. 简要介绍一下DFS求直径的方法：随意选取一个点，DFS出离它距离最大的点（设为P），再以P为起点，DFS出离它距离最大的点（设为Q），P，Q两点就是我们的A和B。

4. 记得开long long

```cpp
#include <bits/stdc++.h>
#define MAX (200000 + 7)
#define long long long
#define uint unsigned
#define add push_back
using namespace std;

long ans,ans2,fp[MAX],fq[MAX],*f;//fp为P到每个点的路径，fq同理 
int N,M,P,Q,FA;//P,Q就是我们的A和B点 

vector <int> Y[MAX],Z[MAX];

#define y Y[x][p]
#define z Z[x][p]
void DFS(int x, long sum, int fa)
{//DFS求出树的直径，sum就是当前长度 
	if (sum >= ans)
		ans = sum, FA = x;//ans就是记录的最远距离，FA就是记录最远的点 
	for (uint p = 0; p < Y[x].size(); p++)
		if (y != fa) DFS(y, sum+z, x);
}

void DFS2(int x, int fa)
{//DFS2求一个点到每个点的距离 
	for (uint p = 0; p < Y[x].size(); p++)
		if (y != fa)
		{
			f[y] = f[x] + z;
			DFS2(y, x);
		}
}
#undef y
#undef z

int main()
{
	scanf("%d%d", &N, &M);
	for (int i = 1 ,x,y,z; i < N; i++)
	{
		scanf("%d%d%d", &x, &y, &z);
		Y[x].add(y), Y[y].add(x);
		Z[x].add(z), Z[y].add(z);
	}
	
	DFS(1, 0, 0); P = FA; ans = 0;
	DFS(P, 0, 0); Q = FA;//两次DFS求出P,Q和直径长度 
	f = fp; DFS2(P, 0);
	f = fq; DFS2(Q, 0);//求出P,Q到每个点的路径 
	for (int i = 1; i <= N; i++)
		ans2 = max(ans2, min(fp[i], fq[i]));//ans2记录min(CA,CB)中的最大值 
	printf("%lld\n", ans + ans2);
}
```

---

## 作者：huyufeifei (赞：11)

大部分思路好像都是先找直径然后再找起点。

我提供另一种思路：找中间点。  
可以发现一种合法的路径其实就是在一个点处拉出去三条链(长度可以为0)，其中第二长的链长度翻倍。

然后就用树形DP+二次扫描与换根法做了。

有一个细节就是这三条链不能重复，所以只取每个子树的最长链拿来更新。

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
typedef long long LL;
const int N = 200010;

struct Edge {
    int nex, v, len;
}edge[N << 1]; int top;

int n, e[N];
LL f[N][3], t[7], ans;

inline void add(int x, int y, int z) {
    top++;
    edge[top].v = y;
    edge[top].len = z;
    edge[top].nex = e[x];
    e[x] = top;
    return;
}

void DFS(int x, int fa) {
    for(int i = e[x]; i; i = edge[i].nex) {
        int y = edge[i].v;
        if(y == fa) {
            continue;
        }
        DFS(y, x);
        for(int j = 0; j < 3; j++) {
            if(f[x][j] < f[y][0] + edge[i].len) {
                for(int k = 2; k > j; k--) {
                    f[x][k] = f[x][k - 1];
                }
                f[x][j] = f[y][0] + edge[i].len;
                break;
            }
        }
    }
    for(int i = 0; i < 3; i++) {
        if(f[x][i] < 0) {
            f[x][i] = 0;
            break;
        }
    }
    return;
}

void DFS_2(int x, int fa, LL dis) {
    t[3] = dis;
    for(int i = 0; i < 3; i++) {
        t[i] = f[x][i];
    }
    std::sort(t, t + 4);
    ans = std::max(ans, t[3] + t[2] + t[2] + t[1]);
    LL a = t[3], b = t[2];
    for(int i = e[x]; i; i = edge[i].nex) {
        int y = edge[i].v;
        if(y == fa) {
            continue;
        }
        if(f[y][0] + edge[i].len == a) {
            DFS_2(y, x, b + edge[i].len);
        }
        else {
            DFS_2(y, x, a + edge[i].len);
        }
    }
    return;
}

int main() {
    memset(f, ~0x3f, sizeof(f));
    int m;
    scanf("%d%d", &n, &m);
    for(int i = 1, x, y, z; i <= m; i++) {
        scanf("%d%d%d", &x, &y, &z);
        add(x, y, z);
        add(y, x, z);
    }

    DFS(1, 0);
    DFS_2(1, 0, 0ll);
    printf("%lld", ans);

    return 0;
}
```

---

## 作者：龙神哈迪斯 (赞：10)

Sol
===
近期在写Noi的题，看到有蓝色的题目~~还以为是恶搞的~~

毕竟只有这么少的人切

后来发现，~~这不是傻题吗~~(引用同一机房中的神牛)

求树的直径，然后再求其余点到直径两端(中最小值)的最大值

题解
===

首先，一个很显然的结论
从A走到B(或从B走到A)要使得最长的话，就是树的直径，两遍bfs就ok了
然后从C走到A(或B)，要使得最长的话，就暴力判一下呗

假设从A走到B最大值为a，从C走到A最大值为b
题目要求你使a+b最大
现在你让a最大，又让b最大
那a+b不久最大了

所以“水题”，就直接上代码了

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
#define ll long long
#define rg register
#define inf 1e18
const int _=200100;
inline int read()
{
	char ch='!';int z=1,num=0;
	while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
	if(ch=='-')z=-1,ch=getchar();
	while(ch<='9'&&ch>='0')num=(num<<3)+(num<<1)+ch-'0',ch=getchar();
	return z*num;
}
int N,M;
struct hand{int to,next,w;}e[_<<1];
int cnt,head[_];
inline void link(int u,int v,int w)
{
	e[++cnt]=(hand){v,head[u],w};head[u]=cnt;
	e[++cnt]=(hand){u,head[v],w};head[v]=cnt;
}
ll disa[_],disb[_],d[_];
bool vis[_];
queue<int>Q;
inline int spfa(int S,ll d[])
{
	for(rg int i=1;i<=N;++i)d[i]=inf;
	d[S]=0;Q.push(S);vis[S]=1;
	while(!Q.empty())
	{
		rg int u=Q.front();Q.pop();
		for(rg int i=head[u];i;i=e[i].next)
		{
			rg int v=e[i].to;
			if(d[v]>d[u]+e[i].w)
			{
				d[v]=d[u]+e[i].w;
				if(!vis[v])
				{Q.push(v);vis[v]=1;}
			}
		}
		vis[u]=0;
	}
	rg ll Max=0;rg int t=0;
	for(rg int i=1;i<=N;++i)
		if(d[i]>Max)
			Max=d[i],t=i;
	return t;
}
int main()
{
	N=read();M=read();
	for(rg int i=1;i<=M;++i)
	{
		int x=read(),y=read(),z=read();
		link(x,y,z);
	}
	rg int a,b;
	a=spfa(1,d);
	b=spfa(a,disa);
	spfa(b,disb);
	rg ll ans=disa[b],Max=0;
	for(rg int i=1;i<=N;++i)
		Max=max(Max,min(disa[i],disb[i]));
	printf("%lld\n",ans+Max);
	return 0;
}

```


---

## 作者：UperFicial (赞：8)

# 树论

### 前言

我是傻逼，我已经被自己恶心到了。

$\texttt{LCA}$ 和直径啥的都写不对，$\texttt{\color{red}WA}$ 了几乎一页。

这里感谢发现我代码重大 $\text{bug}$ 的神仙 $\texttt{M\color{red}atrixCascade}$。

题目链接：[$\text{Link}$](https://www.luogu.com.cn/problem/P4408)

### 题目大意

这题是个语文题，还是自己看题面吧。

只不过题目中有一句话要注意

> 可以保证，任两个居住点间有且仅有一条通路。

这就说明了给定的图是一棵树，所以给的 $m$ 实际上就是 $n-1$。

### 题目解析

下文将 $\texttt{Chris}$ 的父母叫做 $a$。

假设 $AC<BC$，那么说明 $a$ 先要去 $A$ 再去 $B$，那么路程为 $\operatorname{dis}(A,C)+\operatorname{dis(A,B)}$；

反之，路程为 $\operatorname{dis}(B,C)+\operatorname{dis(A,B)}$。

我们发现，两种情况中都有 $\operatorname{dis(A,B)}$，那么我们便可以让这个长度尽量大，在尽量大的基础上来枚举 $C$ 从而更新答案。

很显然 $A,B$ 就是树的直径的两个端点。

$A,B$ 确定了，只需要让枚举的 $C$ 快速求得距离。

给一个无脑做法，既然是在树上，那么直接就套树上距离：$\operatorname{dis}(u,v)=d_u+d_v-2d_{\operatorname{lca}(u,v)}$，其中 $d_i$ 表示根节点到 $i$ 的距离。

然后这道题就做完了。

然后你没开 $\text{long long}$ 又看望了你的曾曾曾祖父。

时间复杂度：$O(n\log n)$，比常规做法多个 $\log$ 是因为要求 $\text{LCA}$。

空间复杂度：$O(n)$。

[$code$](https://paste.ubuntu.com/p/GNW23CtpZy/)

$$\texttt{The End.by UF}$$

---

## 作者：Unordered_OIer (赞：7)

# P4408 题解
## 题意
找最长折返路径。
## 解答
首先，我们先不考虑先去 $B$ 还是先去 $C$ 。我们先假设先去 $B$ 。那么 $B$ 的最坏情况是什么？树的直径！（不会的话先去刷[这道](https://www.luogu.com.cn/problem/SP1437)，那里也有我的题解）。两次 $dfs$ 或者记录最长和次长路径即可。

现在假设 $B$ 点已经找完了。那么我们还需要找 $C$ ，怎么让 $C$ 最远呢？再找一条**第三长**的路径即可。

算法口胡完毕。

那么我们现在有两个思路：
1. 记录前三长路径
2. 计算 $BC$ 直径，枚举 $A$ 。

### 1. 记录前三长路径
我们只需要在 $dfs$ 的时候先把当前最优解记录到第三长路径中，然后依次向上更新。

### Code:
```cpp
#include <bits/stdc++.h>
#define N 200005
using namespace std;

typedef long long ll;
struct edge { ll t, w, nex; } edgs[N<<1];
ll n, m, edge_counter, head[N], kth_p[N][4], bestt[N];

void add(ll u, ll v, ll w)
{ edgs[++edge_counter] = (edge){v, w, head[u]}, head[u] = edge_counter; }

void dfs_h(ll u, ll fa)
{
  kth_p[u][1] = kth_p[u][2] = kth_p[u][3] = 0;
  for(ll i = head[u]; i; i = edgs[i].nex)
  {
    ll v = edgs[i].t, w = edgs[i].w;
    if(v == fa) continue;
    dfs_h(v, u);
////////path
    if(kth_p[u][3] >= kth_p[v][1] + w) continue;
    kth_p[u][3] = kth_p[v][1]+w;
////////third
    if(kth_p[u][2] >= kth_p[u][3]) continue;
    swap(kth_p[u][2], kth_p[u][3]);
////////second
    if(kth_p[u][1] >= kth_p[u][2]) continue;
    swap(kth_p[u][1], kth_p[u][2]);
////////first
  }
}

void dfs_g(ll u, ll fa)
{
  for(ll i = head[u]; i; i = edgs[i].nex)
  {
    ll v = edgs[i].t, w = edgs[i].w;
    if(v == fa) continue;
    if(kth_p[u][1] == kth_p[v][1] + w) bestt[v] = w + max(bestt[u], kth_p[u][2]);
////////v on u_greatest
    else bestt[v] = w + max(bestt[u], kth_p[u][1]);
    dfs_g(v, u);
  }
}

int main()
{
  ////////need fix
  return 0;
}
```
### 2. 计算 $BC$ 直径，枚举 $A$
首先，我们先求一次直径，然后枚举 $A$ 。思路很简单，但是代码就不是那么简单了。我们需要先求出 $LCA$ 。然后~~一堆乱搞~~求得答案。

### Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const ll N = 200009;
ll n, L, d[N], p[N][21];
ll timer, elr_in[N], elr_out[N];
struct edge { ll v, w, nex; } edgs[N<<1];
ll edges_counter, head[N];

void addE(ll u, ll v, ll w)
{
  edgs[++edges_counter] = (edge){v, w, head[u]}, head[u] = edges_counter;
  edgs[++edges_counter] = (edge){u, w, head[v]}, head[v] = edges_counter;
}

void dfs(ll u, ll fa)
{
  for(ll i = head[u]; i; i = edgs[i].nex)
  {
    ll v = edgs[i].v;
    if(v == fa) continue;
    d[edgs[i].v] = d[u] + edgs[i].w;
    dfs(edgs[i].v, u);
  }
}

void dfs_p_t(ll u, ll fa)
{
  elr_in[u] = ++timer;
  p[u][0] = fa;
  for(ll i = 1; i <= L; ++i)
    p[u][i] = p[p[u][i-1]][i-1];
  for(ll i = head[u]; i; i = edgs[i].nex)
  {
    ll v = edgs[i].v;
    if(v == fa) continue;
    d[edgs[i].v] = d[u] + edgs[i].w;
    dfs_p_t(edgs[i].v, u);
  }
  elr_out[u] = ++timer;
}

void input()
{
  scanf("%lld", &n);
  for(ll i = 1, u, v, w; i < n; ++ i)
  {
    scanf("%lld%lld%lld", &u, &v, &w);
    addE(u, v, w);
  }
}

bool isup(ll u, ll v)
{
  //...
}

ll lca(ll u, ll v)
{
  //...
}

int main()
{
  return 0;
}
```
完结撒花~顺便求赞

---

## 作者：Kendrick_Z (赞：6)

写一个NOI的水题模板 
（其实是因为要复习树的直径

题目大意：
给你n个点，m条边，求两点（u，v）之间距离与u和v到一个点的最大距离中的最小值之和的最大值（m==n-1）

max(BC+min(AC,AB);

大多数人的策略都是贪心

先找直径，然后再找一个点到两端的最大值中的最小值（根据题干

但是这种做法的正确性？

个人纠结了好久好久...一直觉得是数据水？

就在网上一直搜 后来找到一篇文章

[证明点击此处](http://blog.sina.com.cn/s/blog_72aa02bd0100y5vt.html)

解决了贪心的问题之后 我们来分析 首先要求出直径

树的直径就是树上两点的最大距离 

然后这时候解决第二个问题min（AC,AB）的最大值

其实我一开始是考虑求两点的LCA然后从LCA开始遍历最远距离 其实应该是可行的 但是LCA+树的直径 可能会挂掉

后来发现其实只需要枚举就行了.....

从链的起点和终点开始遍历

关于求直径？

我喜欢用BFS求 这样比较清新 

但是打BFS出现了小个问题 就是如果直径本来就是一个链状（如样例

这样我第二遍BFS 的时候终点不会更新  这个卡了好久

后来我把判断改成了>=就成功过了....

放下代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6;
struct edge{
    int next,to,w;
}e[N<<1];
int head[N],cnt,dis[N],point,len,n,diss[N],disss[N],m,st,ed;
bool vis[N];
inline void add(int x,int y,int w){
    e[++cnt].next=head[x];
    e[cnt].to=y;
    e[cnt].w=w;
    head[x]=cnt;
}
inline void bfs(int x){
    memset(dis,0,sizeof(dis));
    memset(vis,0,sizeof(vis));
    vis[x]=1;
    queue<int>q;
    q.push(x);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        for(int i=head[u];i;i=e[i].next){
            int v=e[i].to;
            if(!vis[v]){
                q.push(v);
                dis[v]=dis[u]+e[i].w;
                vis[v]=true;
            }	
        }		
    }
    for(int i=1;i<=n;i++){
        if(dis[i]>=len){
            len=dis[i];
            point=i;
        }
    } 	
}
inline void dfs1(int x,int fa){
    for(int i=head[x];i;i=e[i].next){
        int y=e[i].to;
        if(y==fa) continue;
        diss[y]=diss[x]+e[i].w;
        dfs1(y,x);
    }
}
inline void dfs2(int x,int fa){
    for(int i=head[x];i;i=e[i].next){
        int y=e[i].to;
        if(y==fa) continue;
        disss[y]=disss[x]+e[i].w;
        dfs2(y,x);
    }
}
signed main(){
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=m;i++){
        int u,v,w;
        scanf("%lld%lld%lld",&u,&v,&w);
        add(u,v,w);
        add(v,u,w);
    }	
    bfs(1);
    st=point; 
    bfs(point);
    ed=point;
    dfs1(st,0); 
    dfs2(ed,0);
    int ans=0;
    for(int i=1;i<=n;i++){
        ans=max(ans,min(diss[i],disss[i]));
    }
    printf("%lld",ans+len);
    return 0;
} 
```

记得开long long 

还有就是放一下求树的直径的模板

BFS版本
```cpp
inline void bfs(int x){
    memset(dis,0,sizeof(dis));
    memset(vis,0,sizeof(vis));
    vis[x]=1;
    queue<int>q;
    q.push(x);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        for(int i=head[u];i;i=e[i].next){
            int v=e[i].to;
            if(!vis[v]){
                q.push(v);
                dis[v]=dis[u]+e[i].w;
                vis[v]=true;
            }	
        }		
    }
    for(int i=1;i<=n;i++){
        if(dis[i]>=len){
            len=dis[i];
            point=i;
        }
    } 	
}
```

树形DP版：

```cpp
inline void dp(int x){
	vis[x]=1;
	for(int i=head[x];i;i=e[i].next){
		int y=e[i].to;
		if(vis[y]) continue;
		dp(y);
		ans=max(ans,dis[x]+dis[y]+e[i].w);
		dis[x]=max(dis[x],dis[y]+e[i].w);
	}
}
```
个人认为代码可读性还算是可以的...
（~~逃~~

---

## 作者：KEBrantily (赞：4)

首先要明确：

- 题目中「任两个居住点间有且仅有一条通路」说明给出的是一棵树，无须再自己求 MST。

- $a,b,c$ 不会重合。

显然可以发现，$a,b$ 两点一定在树的直径的两端。为什么？

因为如果只有在这两个位置才能保证我们选择的 $c$ 到较近位置的距离和 $ab$ 间的距离最远。可以自己画图，比较好理解。

确定了 $ab$ 之后，需要再确定 $c$ 点的位置。我们分别从 $a,b$ 跑一个最短路，然后线性枚举这个位置 $c$ 就可以。

答案就是 $\text{dis}(a,b)+\max\{\min\{\text{dis}(a,c),\text{dis}(b,c)\}\}$。

---

## 作者：SIXIANG32 (赞：4)

下午要考试，听说考前发题解可以攒点 RP，所以来攒点 RP 先。  
闲话少说，切入正题——  

---
题目大意：  
> 给你一个无向树，求任意 $A,B,C$ 三个点最大使得 $dis_{A,B} + dis_{B,C}$ 最大，且 $dis_{A, C} > dis_{B, C}$。（$dis$ 表示两点距离）  

*题目虽然说了顺序，但是我们把 $A,B$ 两点对调实际上不影响上面的式子结果*  

必然的，如果要让这个式子最大化显然有两个点是该树的直径的两个端点。所以说我们要考虑是 $A,B$ 两点是直径端点还是 $B,C$ 两点是直径端点。  
显然，我们的行走线路是 $C-B-A$，如果我们将 $C,B$ 作为直径的两端，显然是不成立的，因为直径是树中最长的点对，$dis_{A,C}$ 不可能在该情况下大于 $dis_{B, C}$。那么 $A,B$ 必然为**直径的两端**。  

---
得到了这个重要的结论后，问题已经解决了一半了。  
用两次 dfs 可以方便的求出 $A,B$ 点到所有点的距离，这正好可以用来求 $C$ 点。  
**注意直径的两端只是 $A,B$ 两点的答案候选集合，也就是说起点不一定是 $A$，终点不一定是 $B$**  
现在仅仅剩下 $C$ 点不知道了，我们回顾一下这个式子：$dis_{A,C} > dis_{B,C}$。  
我们枚举每个点作为 $C$，我们知道了候选集合到这个点的距离，我们取到该点距离小的那个做 $B$，因为 $dis_{A,C} > dis_{B,C}$，我们取这些东西的最大值，就能得到 $C-B$ 的距离了，加上直径距离，也就是 $dis_{A,B}$，就能得到答案。  
由于 $T_i \le 10^9$，所以我们要开 long long。  
代码：  

```cpp
//long long!
#include <cstdio>
#include <vector>
#include <cstring>
#define MAXN 200000
#define int long long
#define QWQ printf("qwq\n"); 
using namespace std;
int max(int x, int y) {return ((x > y) ? (x) : (y));}
int min(int x, int y) {return ((x < y) ? (x) : (y));}
struct node {
	int to, val;
	node(int T, int V) {
		to = T, val = V;
	}
};
int disA[MAXN + 10], disB[MAXN + 10], disC[MAXN + 10], n, m;
vector <node> gra[MAXN + 10];
//dfsA，dfsB，dfsC 都是找距离。  
//A 是从任意节点出发，B 是从直径起点出发，C 是从直径末尾出发
void dfsA(int u, int fa) {
	for(int p = 0; p < gra[u].size(); p++) {
		int v = gra[u][p].to;
		if(v != fa) {
			disA[v] = disA[u] + gra[u][p].val;
			dfsA(v, u);
		}
	}
} 
void dfsB(int u, int fa) {
	for(int p = 0; p < gra[u].size(); p++) {
		int v = gra[u][p].to;
		if(v != fa) {
			disB[v] = disB[u] + gra[u][p].val;
			dfsB(v, u);
		}
	}
} 
void dfsC(int u, int fa) {
	for(int p = 0; p < gra[u].size(); p++) {
		int v = gra[u][p].to;
		if(v != fa) {
			disC[v] = disC[u] + gra[u][p].val;
			dfsC(v, u);
		}
	}
} 
void calc() {//答案求解
	dfsA(1, 0);//从任一点开始找到起点
	int st, ed, ans = 0, maxn = 0;
	for(int p = 1; p <= n; p++) 
		if(disA[p] > ans)
			ans = disA[p], st = p;
	ans = 0;
	dfsB(st, 0);//算起点到所有点的距离
	for(int p = 1; p <= n; p++)
		if(disB[p] > ans)
			ans = disB[p], ed = p;
   	// ans 是直径长度
	dfsC(ed, 0);//算终点到所有点的距离
	for(int p = 1; p <= n; p++)
		maxn = max(maxn, min(disB[p], disC[p]));//算 C-B 的距离
	printf("%lld\n", maxn + ans);//输出
}
signed main() {
	scanf("%lld%lld", &n, &m);
	for(int p = 1, x, y, z; p <= m; p++) {
		scanf("%lld%lld%lld", &x, &y, &z);
		gra[x].push_back(node(y, z));
		gra[y].push_back(node(x, z));
	}
	calc();
}
```


---

## 作者：Laser_Crystal (赞：1)

~~**不开long long见祖宗**是万古不变的真理~~

首先来分析题意：

1. 从`街道信息不会重复给出`，我们知道了这个输入没有重边。从`可以保证，任两个居住点间有且仅有一条通路`知道，我们面对的是一颗树。因为树保证了这样的性质，所以其实输入的m就是n-1。

2. 从数据范围`1≤Ti≤1000000000`可以看出，我们要开long long（因为最后的答案会很大）。

3. 看Chris的父母的行走方式，就是会先去找距离C点最近的那个点（不妨设成A），然后如果人没有的话去找B。对于题目最长时间的要求，肯定是不能第一次就找到，以及AB之间的距离要尽可能的长。把题目抽象出来，变成一句能被Oier们听懂的话：

`给定一棵树，在树上面找到A、B、C三个点，使得AB之间的路径加上MIN（AC，BC）的值最大`

贪心的证明只是预感的，证明过程还是看看@C3H5ClO
神仙的题解Orz%%%

这应该是一个模板了吧

Code
```
#include<iostream>//第一次开int没过，一气之下把所有的int换成了longlong，然后过了（
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
struct side{
	long long to,nxt,w;
}e[400005];
long long head[200005],cnt=0;
long long n,m;
bool vis[200005];
long long d1[200005],d2[200005];
long long diameter,maxx=0;//diameter是直径的意思（捂脸
inline void add(long long u,long long v,long long w)
{
	cnt++;
	e[cnt].to=v;
	e[cnt].w=w;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
inline long long bfs(long long start)
{
	memset(d1,0,sizeof(d1));//d1表示从某个起点start出发，到各个点的距离
	memset(vis,0,sizeof(vis));
	queue<long long> q;
	long long maxn=0,node;
	q.push(start);
	vis[start]=1;
	while(!q.empty())
	{
		long long x=q.front();
		q.pop();
		for(register long long i=head[x];i;i=e[i].nxt)
		if(!vis[e[i].to])
		{
			vis[e[i].to]=1;
			d1[e[i].to]=d1[x]+e[i].w;
			q.push(e[i].to);
			if(d1[e[i].to]>maxn) //更新最远的点
			{
				maxn=d1[e[i].to];
				node=e[i].to;
			}
		}
	}
	return node;
}
int main()
{
	cin>>n>>m;
	for(register long long i=0;i<m;i++)
	{
		long long x,y,z;
		cin>>x>>y>>z;
		add(x,y,z),add(y,x,z);
	}
	long long l=bfs(1),r=bfs(l);//求带权树直径的两个端点
   	//这个d1数组成了从l开始到各个点的距离
	diameter=d1[r];//直径长度
	for(register long long i=1;i<=n;i++) d2[i]=d1[i];//Copy一下
	bfs(r);//这个从直径的另外一个端点搜索过后，这个d1数组就成了从r开始到各个点的距离，然后我们就可以贪心了
	for(register long long i=1;i<=n;i++) maxx=max(maxx,min(d1[i],d2[i]));//求最大的最小值
	cout<<diameter+maxx;
	return 0;
}
```

---

## 作者：ModestCoder_ (赞：1)

本来想的一个$O(n^2)$的暴力

枚举$C$,把它记为根，在$dfs$枚举$lca(A,B)$

求出$fir_u,sec_u$表示以$u$为根的子树中最长链，次长链

再记$d_u$为深度，那么对于一个$(C,lca(A,B))$的答案是$fir_u+2sec_u+d_u$


其实可以只枚举$lca(A,B)$记为$D$好了，想要知道在$fir_D,sec_D$已经有的情况下，最优的$C$在哪

对于每个点求出$fir_u,sec_u,thi_u$，前三长的链，以及$idfir_u$最长链对应的儿子编号

然后再$dfs$，如果走到最长链里面，即$v=idfir_u$，则顺便传下去$sec_u+l$

否则传下去$fir_u+l$

对于每个点$u$，我们知道了$fir_u,sec_u,thi_u$，还知道了从上面传下来的$d$，这个$d$不只是暴力里面的深度，是根的最优情况

然后$max(thi_u,d)$就是根到点$u$的最优距离

然而最终的答案是$sec_u$要×个2，这个$sec_u$是中间大的

所以找出中间大的是×2的那个

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 200010
#define LL long long
using namespace std;
struct Edge{
	int to, next;
	LL len;
}edge[maxn << 1];
int num, head[maxn], n, m;
LL fir[maxn], sec[maxn], thi[maxn], ans, deg[maxn], rt, idfir[maxn];

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

void addedge(int x, int y, int z){ edge[++num] = (Edge){y, head[x], z}, head[x] = num; }

void dfs(int u, int pre){
	fir[u] = sec[u] = thi[u] = 0;
	idfir[u] = 0;
	for (int i = head[u]; i; i = edge[i].next){
		int v = edge[i].to;
		LL l = edge[i].len;
		if (v != pre){
			dfs(v, u);
			if (fir[v] + l > fir[u]){
				thi[u] = sec[u], sec[u] = fir[u], fir[u] = fir[v] + l, idfir[u] = v;
//				if (sec[v] + l > sec[u]) sec[u] = sec[v] + l;
			} else if (fir[v] + l > sec[u]) thi[u] = sec[u], sec[u] = fir[v] + l;
			else if (fir[v] + l > thi[u]) thi[u] = fir[v] + l;
		}
	}
//	ans = max(ans, fir[u] + sec[u] + sec[u] + max(d, thi[u]));
}

void dfs1(int u, int pre, LL d){
	for (int i = head[u]; i; i = edge[i].next){
		int v = edge[i].to;
		LL l = edge[i].len;
		if (v != pre){
			if (v == idfir[u]) dfs1(v, u, max(sec[u], d) + l);
			else dfs1(v, u, max(fir[u], d) + l);
		}
	}
	LL x = fir[u], y = sec[u], z = max(d, thi[u]);
	if (z > x) swap(z, x);
	if (y > x) swap(y, x);
	if (z > y) swap(z, y);
	ans = max(ans, x + y + y + z);
//  ans = max(ans, fir[u] + sec[u] + sec[u] + max(d, thi[u]));
//	printf("%d %d %d %d %d\n", u, fir[u], sec[u], thi[u], d);
}

int main(){
	freopen("pc.in", "r", stdin);
	freopen("pc.out", "w", stdout);
	n = read(), m = read();
	for (int i = 1; i <= m; ++i){
		int x = read(), y = read(), z = read();
		addedge(x, y, z), addedge(y, x, z);
		++deg[x], ++deg[y];
	}
	for (int i = 1; i <= n; ++i) if (deg[i] > 1) rt = i;
	dfs(rt, 0);
/*	for (int i = 1; i <= n; ++i){// printf("rt : %d\n", i);
		dfs(i, 0, 0);
	}*/
	dfs1(rt, 0, 0);
	printf("%lld\n", ans);
	return 0;
}
```


---

## 作者：ShuYuMo (赞：1)

# 树的重心


关于树的重心，我说说我的理解：

## 概念
![upload successful](http://47.92.113.238:82/images/pasted-3.png)


`树的重心`也叫树的`质心`。

找到一个点,其所有的子树中`最大`的子树节点数`最少`,那么这个点就是这棵树的重心,删去重心后，生成的多棵树尽可能平衡。

其实我的理解就是（`人话`）：找一个点，把这个点删掉后，让得到的一堆小森林中最大的数最小。

## 性质
 - 删掉这个点后，得到森林，森林中的每一棵树的大小$\max\left { A \right }\leq $$\frac{n}{2}$($A\epsilon$得到的森林 $n$为结点总数)；逆定理存在。
 - 两棵树接起来，形成的树的重心一定在原来两棵数的重心形成的路径上。
 - 一棵树最多有两个重心，且相邻。
 - 一棵树添加或者删除一个节点，树的重心最多只移动一条边的位置。
 - 树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个距离和，他们的距离和一样。
 
## 求法
~~贼简单~~
到一个节点后，找他的儿子的子树大小，和去掉他本身这棵子树后，剩下的大小。如果这些值中的最大值最小，记录节点更新答案。
## 有一道POJ的模板题

顺便建议luogu的管理老师们加进来QAQ

[原题](http://poj.org/problem?id=1655)
```cpp
/*!
 * FileName: poj-1655.cpp
 * This Problem is on poj. The ID of the problem is 1655. 
 * Copyright(c) 2019 Shu_Yu_Mo
 * MIT Licensed
 * Luogu: https://www.luogu.org/space/show?uid=44615
 * Github: https://github.com/oldsuold/
 * Gitee: https://gitee.com/Shu_Yu_Mo/
 * These words were created by an amazing tool written by Shu_Yu_Mo.
 */
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstring>
#include<iostream>
#include<cmath>
#include<vector>
#include<queue>
#include<algorithm>
#define inf 0x7fffffff
using namespace std;
const int _N = 201000;
inline int read()
{
    char c = getchar(); int sign = 1; int x = 0;
    while(c > '9' || c < '0') { if(c=='-')sign = -1; c = getchar(); } 
    while(c <= '9' && c >= '0') { x *= 10; x += c - '0'; c = getchar(); }
    return x * sign;
}
struct edges{
	int node;
	int nxt;
}edge[_N];
int head[_N];
int tot = 0;
void add(int u, int v)
{
	edge[++tot].nxt = head[u];
	edge[tot].node = v;
	head[u] = tot;
}
int n;
int AnsId;
int minSize = inf;
int Size[_N];
void dfs(int now, int parent)
{
	int res = 0;
	Size[now] = 1;
	for(register int i = head[now];i;i = edge[i].nxt)
	{
		int sonNode = edge[i].node;
		if(sonNode == parent) continue;
		dfs(sonNode, now);
		Size[now] += Size[sonNode];
		res = max(res, Size[sonNode]);
	}
	res = max(res, n - Size[now]);
	if(res == minSize)
		AnsId = min(AnsId, now);
	else if(res < minSize)
		AnsId = now, minSize = res;
	return;
}
void doit()
{
	memset(Size, 0, sizeof(Size));
	minSize = inf;
	n = read();
	int k;
	memset(head, 0, sizeof(head));
	tot = 0;
	for(register int i = 1;i <= n - 1;i ++)
	{
		int tmpx = read(), tmpy = read();
		add(tmpx, tmpy);
		add(tmpy, tmpx);
		k = tmpx;
	}
	dfs(k, 0);
	printf("%d %d\n", AnsId, minSize) ;
}
int main()
{
	int T = read();
	while(T--)
	{
		doit();
	}
    return 0;
}

```

## 那关于本题的思路是

为了让小孩的妈妈走的最远：
 - 找一个最长的直径，直径两端就是小孩两朋友的家
 - 求出在这条直径上的每一个点到叶节点的最长距离，对应叶节点就是小孩的家
 
~~这样的话，小孩的妈妈走的路就是最最最最远的~~
## Code
```
/*!
 * FileName: luogu-4408.cpp
 * This Problem is on luogu. The ID of the problem is 4408. 
 * Copyright(c) 2019 Shu_Yu_Mo
 * MIT Licensed
 * Luogu: https://www.luogu.org/space/show?uid=44615
 * Github: https://github.com/oldsuold/
 * Gitee: https://gitee.com/Shu_Yu_Mo/
 * These words were created by an amazing tool written by Shu_Yu_Mo.
 */
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstring>
#include<iostream>
#include<cmath>
#include<vector>
#include<queue>
#include<algorithm>
#define inf 0x7fffffff
#define int long long
using namespace std;
const int _N = 200100;
const int _M = _N;
inline int read()
{
    char c = getchar(); int sign = 1; int x = 0;
    while(c > '9' || c < '0') { if(c=='-')sign = -1; c = getchar(); } 
    while(c <= '9' && c >= '0') { x *= 10; x += c - '0'; c = getchar(); }
    return x * sign;
}
void swap(int & x, int & y)
{
	int t = x;
	x = y;
	y = t;
}
int n, m; 
struct edges{
    int node;
    int w;
    int nxt;
}edge[_M << 1];
int tot = 0;
int head[_N];
void add(int u, int v, int w)
{
    edge[++tot].nxt = head[u];
    edge[tot].node = v;
    edge[tot].w = w;
    head[u] = tot;
}
bool vis[_N];
int dist[_N];
void dfs(int nowNode)
{
	vis[nowNode] = true;
	for(register int i = head[nowNode];i;i = edge[i].nxt)
	{
		if(vis[edge[i].node]) continue;
		dist[edge[i].node] = dist[nowNode] +  edge[i].w;
		dfs(edge[i].node);
	}
}
float r;
int dist_[_N];
int tot_ = 0;
int MaxId2, MaxId;
int MaxDeep = -inf;
bool flag = false;
int path[_N];
bool inPath[_N];
int path_w[_N];
void dfsForPath(int k,int deepth, int w)
{
	vis[k] = true;
	path[deepth] = k;
	path_w[deepth] = w;
	if(k == MaxId2) { MaxDeep = deepth;flag = true;return; }
	for(register int i = head[k];i;i = edge[i].nxt)
	{
		int SonNode = edge[i].node;
		if(vis[SonNode]) continue;
		dfsForPath(SonNode, deepth + 1, edge[i].w); 
		if(flag)return;
	}
}
int dfsLast(int k)
{
	int longest = 0;
	vis[k] = true;
	for(register int i = head[k];i;i = edge[i].nxt)
	{
		int SonNode = edge[i].node;
		if(inPath[SonNode] || vis[SonNode]) continue;
		longest = max(longest, dfsLast(SonNode) + edge[i].w);
	}
	return longest;
}
signed main()
{	
	memset(vis, false, sizeof(vis));
	n = read(), m = read();
	for(register int i = 1;i <= m;i++)
	{
		int tmpx = read(), tmpy = read(), tmpz = read();
		add(tmpx, tmpy, tmpz);
		add(tmpy, tmpx, tmpz);
	}
	int MaxDis = 0;
	memset(dist, 0, sizeof(dist));
	dfs(1);
	for(register int i = 1;i <= n;i++)
	{
		if(dist[i] > MaxDis)
		{
			MaxDis = dist[i];
			MaxId = i;
		}
	}
	memset(dist, 0, sizeof(dist));
	memset(vis, false, sizeof(vis));
	dfs(MaxId);
	int MaxDis2 = 0;
	for(register int i = 1;i <= n;i++)
	{
		if(dist[i] > MaxDis2)
		{
			MaxDis2 = dist[i];
			MaxId2 = i;
		}
	}
	memset(vis, false, sizeof(vis));
	dfsForPath(MaxId, 1, 0);
	memset(inPath, false, sizeof(inPath));
	for(register int i = 1;i <= MaxDeep;i++)
		inPath[path[i]] = true;//求出数的最长直径，并标记最长直径上的点。
	int ans = -inf;
	memset(vis, 0, sizeof(vis));
	int now = 0;
	for(register int i = 1;i <= MaxDeep;i++)
	{
		now += path_w[i];
		int tmp = min(now, MaxDis2 - now);
		int kk = dfsLast(path[i]);//求最长直径上的点到叶节点的最长距离（不走在最长直径上的点）
		ans = max(ans, kk + tmp + MaxDis2);
	}
	printf("%lld", ans);
	
    return 0;
}
/*
4 3
1 2 1
2 4 1
2 3 2

*/
```

---

## 作者：lukelin (赞：1)

**解法**  
思路非常简单，找道树的直径，然后答案是直径长度加上**最大的**min(dis[pos1], dis[pos2])，pos1和pos2是指定的任意一条直径的两个端点，dis是距离  
**证明**  
鉴于这是一棵树(原题面：可以保证，任两个居住点间有且仅有一条通路。)  
因此，我们最大的方案必然包含一条直径  
可以稍加思考，如果不是直径的话一定能找到一种取直径的方法比它更大...  
那么再任意找另一个点，因为要满足"如果A距离C比B距离C近走A，否则走B"，所以任意一个点的贡献为min(dis[pos1], dis[pos2])。  
题目要求最大的，所以取最大的min(dis[pos1], dis[pos2])  
**代码**  
树的直径显然只需要一个DFS,求解也只需要一个DFS,所以共计两个DFS
```cpp
#include <cstdio>
#include <algorithm>
#define ll long long 

using namespace std;

ll read(){
    ll x = 0; int zf = 1; char ch = ' ';
    while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
    if (ch == '-') zf = -1, ch = getchar();
    while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf;
}

struct Edge{
	int to, next;
	ll dis;
} edges[400005];

int head[200005], edge_num;

void addEdge(int u, int v, ll w){
	edges[++edge_num] = {v, head[u], w};
	head[u] = edge_num;
}

ll dis[200005];
ll dis2[200005][2];

void getDis(int u, int fa, ll vl){
	int v; dis[u] = ((u == fa) ? 0 : dis[fa] + vl);
	for (int c_e = head[u]; c_e; c_e = edges[c_e].next){
		v = edges[c_e].to; if (v == fa) continue;
		getDis(v, u, edges[c_e].dis);
	}
}

void getDis2(int u, int fa, ll vl, int op){
	int v; dis2[u][op] = ((u == fa) ? 0 : dis2[fa][op] + vl);
	for (int c_e = head[u]; c_e; c_e = edges[c_e].next){
		v = edges[c_e].to; if (v == fa) continue;
		getDis2(v, u, edges[c_e].dis, op);
	}
}

int main(){
	int n = read(), m = read();
	for (int i = 1; i <= m; ++i){
		int u = read(), v = read(); ll w = read();
		addEdge(u, v, w), addEdge(v, u, w);
	}
	getDis(1, 1, 0);
	int pos1; ll _max = -1;
	for (int i = 1; i <= n; ++i)
		if (dis[i] > _max)
			_max = dis[i], pos1 = i;
	getDis(pos1, pos1, 0);
	int pos2; _max = -1;
	for (int i = 1; i <= n; ++i)
		if (dis[i] > _max)
			_max = dis[i], pos2 = i;
	getDis2(pos1, pos1, 0, 0);
	getDis2(pos2, pos2, 0, 1);
	ll _max2 = -1;
	for (int i = 1; i <= n; ++i)
		_max2 = max(_max2, ((dis2[i][0] > dis2[i][1]) ? dis2[i][1] : dis2[i][0]));
	printf("%lld", _max + _max2);
	return 0;
}
```
**备注**  
求树的直径:从任意一点开始DFS,找到最远点pos1,再从pos1开始DFS找到最远点pos2,  
pos1和pos2即为树的直径  
证明略(易证)

---

## 作者：xiaolou (赞：1)

2325131433448687~

机房模拟赛的一题，考场上打了暴力，后来A掉了。。。

想法很粗暴，先找出树的直径，然后枚举每个点作为C点，求出min(C->A,C->B)+A->B（也就是直径）。。。

刚开始打了一个O(n^2)暴力，交上去T了最后一个点，后来又搞了个前缀和优化，变成了O(n*(n-直径))，但是还是没快多少。。。于是我猜想最后一个点是。。。

菊花图！

然后无耻的特判了菊花图，交上去就真的A了。。。

这篇题解码量很大，打了5个dfs(天啊。。。)。。。

Code：

```cpp
#include <bits/stdc++.h>

using namespace std;
struct Node
{
    int v;
    long long c;
    Node *next;
}*h[200005],pool[400005];
int vis[200005];//是否在直径上
long long qzh[200005];//直径上的前缀和优化
int in[200005];//入度，判菊花图用的（大雾）
int tot=0;
void adde(int u,int v,long long c)
{
    Node *p=&pool[++tot];
    p->v=v;
    p->c=c;
    p->next=h[u];
    h[u]=p;
}
long long max1924=0;
int far=0;
void dfs_FAR(int u,int fa,long long dis)//求直径的第一步，找出离树上一个点最远的点
{
    if(max1924<dis)
        max1924=dis,far=u;
    for(Node *p=h[u];p;p=p->next)
    {
        if(p->v!=fa)
        {
            dfs_FAR(p->v,u,dis+p->c);
        }
    }
}
long long dia=0;//diameter直径
int diaa=0;
int far1=0;//far1和far为直径两个端点
void dfs_DIA(int u,int fa,long long dis)//第二步，求直径
{
    if(dia<dis)
        dia=dis,far1=u;
    for(Node *p=h[u];p;p=p->next)
    {
        if(p->v!=fa)
        {
            dfs_DIA(p->v,u,dis+p->c);
        }
    }
}
long long distan=0;//从C到A(或B)的距离
int flag=0;//表示有没有到达目标节点
void dfs_ANS(int u,int fa,long long dis,int end)//第三步，找C点，对于每个C点，求出到far和far1的距离
{
    if(flag==1)
        return;//如果已经到达了，一直返回
    if(u==end)
    {
        distan=dis;
        flag=1;
        return;
    }
    for(Node *p=h[u];p;p=p->next)
    {
        if(p->v!=fa)
        {
            dfs_ANS(p->v,u,dis+p->c,end);
        }
        if(flag==1)
            return;
    }	
}
int tottime=0;//直径上有多少个点
void dfs_QZH(int u,int fa,int time)//求出直径上的前缀和
{
    tottime++;
    for(Node *p=h[u];p;p=p->next)
    {
        if(vis[p->v]==1&&p->v!=fa)
        {
            qzh[time]=qzh[time-1]+p->c;
            dfs_QZH(p->v,u,time+1);
        }
    }
}
int flag1924=0;
void dfs_VIS(int u,int fa,int end)//标记所有在直径上的点
{
    if(u==end)
    {
        vis[u]=1;
        flag1924=1;
        return;
    }
    for(Node *p=h[u];p;p=p->next)
    {
        if(p->v!=fa)
        {
            dfs_VIS(p->v,u,end);
            if(flag1924==1)
            {
                vis[u]=1;
                return;
            }	
        }
    }
}

————————————————————————到此为止，5个dfs打完了————————————————————————

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int x,y;
    long long c;
    ~~~~~~~~ 特判菊花图 ~~~~~~~~
    long long da=0,db=0,dc=0;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%lld",&x,&y,&c);
        in[x]++;
        in[y]++;
        if(c>da)
            dc=db,db=da,da=c;
        else if(c>db)
            dc=db,db=c;
        else if(c>dc)
        	dc=c;
        adde(x,y,c);
        adde(y,x,c);
    }
    int flag1823=0;
    for(int i=1;i<=n;i++)
    {
        if(in[i]==n-1)
        {
            flag1823=1;
            break;
        }
    }
    if(flag1823)
    {
        printf("%lld",da+2*db+dc);
        return 0;
    }
    ~~~~~~~~ 求直径开始 ~~~~~~~~
    dfs_FAR(1,0,0);
    dfs_DIA(far,0,0);
    dfs_VIS(far,0,far1);
    ~~~~~~~~ 找C点开始 ~~~~~~~~
    long long ans=0;
    for(int i=1;i<=n;i++)
    {
        if(vis[i]==1)
            continue;//如果在直径上就暂时跳过不搜
        dfs_ANS(i,0,0,far);
        long long disa=distan;
        flag=0;
        distan=0;
        dfs_ANS(i,0,0,far1);
        long long disb=distan;
        flag=0;
        distan=0;
        ans=max(ans,min(disa,disb));
    }
    dfs_QZH(far,0,1);
    long long mina=0;
    for(int i=1;i<=tottime;i++)
    {
        mina=max(mina,min(dia-qzh[i],qzh[i]));//当直径上的点的位置最接近直径的中点时，一定最优
    }
    printf("%lld\n",max(ans+dia,dia+mina));//输出最后的答案
    return 0;
}
```

---

## 作者：pengyule (赞：0)

题目中说得不清楚的地方：
1. $m=n-1$，就是一棵树，从“任两个居住点间有且仅有一条通路”可以看出
2. 两点间的距离就是所用时长

根据直径的最长性，两个朋友的家必然在直径两端。可以看做 Chris 家从直径外一点出发，走走走，刚走上直径的这个点这是很重要的一个点，然后问题转化成
> 求无根树直径上的一点 $t$，使得 $2\min\{dist(u,t),dist(t,v)\}+\max\{dist(u,t),dist(t,v)\}+d(t)$ 最大。其中，$u,v$ 为直径的两个端点，$dist(p,q)$ 代表 $p$ 到 $q$ 的路径长，$d(x)$ 代表从直径上一点 $x$ 出发，不经过直径上的其他点，所能走的最远距离。

题目就简单了，
1. 预处理出 $d(u,\cdots,v)$，复杂度 $O(n)$
2. 求直径长及直径的节点序列 $route$
3. $route$ 上枚举 $t$，$dist(u,t),dist(t,v)$ 可 $O(1)$ 得到，更新答案

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+5;
vector<int> route;
vector<pair<int,int> >G[N];
map<int,int>e[N];
void findfur(int x,int fa,int sum,int &len,int &v){
    if(sum>len) len=sum,v=x;
    for(int i=0;i<G[x].size();i++){
        if(G[x][i].first^fa) findfur(G[x][i].first,x,sum+G[x][i].second,len,v);
    }
}
bool flag=0;
void dfs(int x,int fa,int target){
    route.push_back(x);
    if(target==x){flag=1;return;}
    for(int i=0;i<G[x].size();i++){
        if(G[x][i].first^fa) dfs(G[x][i].first,x,target);
        if(flag) return;
    }
    route.pop_back();
}
int getdia(){
    int u1,l1=0;findfur(1,0,0,l1,u1);
    int u2,l2=0;findfur(u1,0,0,l2,u2);
    dfs(u1,0,u2);
    return l2;
}
bool vis[N];
void ff(int x,int sum,int &len){
    vis[x]=1;
    if(sum>len) len=sum;
    for(int i=0;i<G[x].size();i++){
        int y=G[x][i].first,z=G[x][i].second;
        if(!vis[y]) ff(y,sum+z,len);
    }
}
signed main()
{
    int n,m;
    cin>>n>>m;
    while(m--){
        int u,v,w;
        cin>>u>>v>>w;
        G[u].push_back(make_pair(v,w));
        G[v].push_back(make_pair(u,w));
        e[u][v]=e[v][u]=w;
    }
    int d=getdia(),ans=0;
    for(int i=0;i<route.size();i++)vis[route[i]]=1;
    for(int i=0,sum=0,tmp,tmp2;i+1<route.size();i++){
        tmp=min(sum,d-sum);
        tmp2=0;ff(route[i],0,tmp2);
        ans=max(ans,tmp*2+d-tmp+tmp2);
        sum+=e[route[i]][route[i+1]];
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：牛蛙丶丶 (赞：0)

#### 思路

根据题意可以发现构成的图是一棵树。

然后可以发现行走路径是从 C 到距离较近的 A 或 B 点，再走完 A-B 路径，所以对于 A-B 路径，其长度与 C 的位置是无关的，所以他有一个固定的上限，在根据树的直径的性质，可以将其 A-B 确定为树的直径，之后我们要做的就是处理出直径一端点 A 与所有点的距离，另一端点 B 与所有点的距离，枚举一遍 n 更新答案即可。

时间复杂度 $O(n)$ 。

```cpp
#include <cstdio>
#include <algorithm>
#define int long long 

const int N=400070;
struct Tree{ int to,nxt,w; }e[N];
int n,m,cnt,maxdis,maxu,A,B;
int head[N],d[2][N];
void dfs(int u,int fa,int dis){
	if(dis>maxdis) maxdis=dis,maxu=u;
	for(int i=head[u],v;i;i=e[i].nxt){
		v=e[i].to;if(v==fa) continue;
		dfs(v,u,dis+e[i].w);
	}
}
void DFS(int u,int fa,int k){
	for(int i=head[u],v;i;i=e[i].nxt){
		v=e[i].to;if(v==fa) continue;
		d[k][v]=d[k][u]+e[i].w;
		DFS(v,u,k);
	}
}
void add(int from,int to,int val){e[++cnt].to=to,e[cnt].w=val,e[cnt].nxt=head[from],head[from]=cnt;}
signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1,u,v,w;i<=m;++i){
		scanf("%lld%lld%lld",&u,&v,&w);
		add(u,v,w),add(v,u,w);
	}
	dfs(1,0,0),maxdis=0,A=maxu,dfs(A,0,0),B=maxu,DFS(A,0,0),DFS(B,0,1);
	int ans=0;
	for(int i=1;i<=n;++i)
		ans=std::max(ans,maxdis+std::min(d[0][i],d[1][i]));
	printf("%lld\n",ans);
}
```

---

## 作者：NaOH_Frog (赞：0)

贪心+图论题目。

①求树的直径，使用2次搜索或dp即可；

**②求离树的直径的两端点较近者最远的点，并求出距离。**

证明可以用反证法，分2种情况：

1. B 和 C不是树的直径的两个端点

只需要把B和C挪到直径两端点上，总距离一定变长。

2. A不取极值

同样，用“同一法”即可。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
struct nod{
	int to;
	long long dis;
};
vector<nod> v[200007];
int n, m;
long long ans = 0;
long long ans1 = 0;
int best, best2;
void dfs(int x, int fa, long long cur){
	if(v[x].size() == 1){
		if(cur > ans1){
			ans1 = cur;
			best = x;
		}
	}
	for(int i = 0; i < v[x].size(); i++){
		if(v[x][i].to == fa) continue;
		dfs(v[x][i].to, x, cur + v[x][i].dis);
	}
}
void dfs2(int x, int fa, long long cur){
	if(v[x].size() == 1){
		if(cur > ans1){
			ans1 = cur;
			best2 = x;
		}
	}
	for(int i = 0; i < v[x].size(); i++){
		if(v[x][i].to == fa) continue;
		dfs2(v[x][i].to, x, cur + v[x][i].dis);
	}
}
long long f1[200007], f2[200007], f[200007];
void dfs3(int x, int fa, long long cur){
	f1[x] = cur;
	for(int i = 0; i < v[x].size(); i++){
		if(v[x][i].to == fa) continue;
		dfs3(v[x][i].to, x, cur + v[x][i].dis);
	}
}
void dfs4(int x, int fa, long long cur){
	f2[x] = cur;
	for(int i = 0; i < v[x].size(); i++){
		if(v[x][i].to == fa) continue;
		dfs4(v[x][i].to, x, cur + v[x][i].dis);
	}
}
int main(){
	cin >> n >> m;
	for(int i = 0; i < m; i++){
		int x, y, dis;
		cin >> x >> y >> dis;
		v[x].push_back({y, dis});
		v[y].push_back({x, dis});
	}
	dfs(1, -1, 0);
	ans1 = 0;
	dfs2(best, -1, 0);//求直径
	dfs3(best, -1, 0);//求端点1到所有点距离
	dfs4(best2, -1, 0);//求端点2到所有点距离
	for(int i = 1; i <= n; i++){
		f[i] = min(f1[i], f2[i]);
		ans = max(ans, f[i]);
	}
	cout << ans + ans1 << endl;
	return 0;
}
```


---

## 作者：hzoi_liuchang (赞：0)

## 分析
我们要从点C出发先走到点A再走到点B(CA<CB) 或者是 从点C出发先走到点B再走到点A(CB<CA)

其实这两种情况是一样的，因为A、B的位置我们不确定，所以两点可以互换，所以我们把题目简化：

一句话题意：在一棵树上找三个点A、B、C使得AB+AC的值最大（满足AC<=BC）

这道题可以说是一个模板题，虽然题目中又是逃学又是找人，但实际上是让你求树的直径

AB的最大值很好想，显然就是树的直径，在一棵树中没有比直径更长的路程了

那么AC的最大值呢，我们可以在dfs求树的直径的时候顺便把每一个点到A、B的价值都求出来，在这两个价值中取较小值（因为要先到比较近的点）

最后再枚举一遍求最优决策（最大值），这实际上是一种贪心的思想
最后要注意几个细节：

1、开long long，并且赋值为无穷大时要写8个3f：0x3f3f3f3f3f3f3f3f

2、双向边，开数组时一定要乘2

3、数组不能开得太大
## 代码
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
const int maxn=500010;//数组不要开小了
typedef long long ll;//记得开long long
struct asd{
    ll from,to,next,val;
}b[maxn];
ll n,m;
ll head[maxn],tot=1;
void ad(ll aa,ll bb,ll cc){
    b[tot].from=aa;
    b[tot].to=bb;
    b[tot].next=head[aa];
    b[tot].val=cc;
    head[aa]=tot++;
}//加边函数
ll dis[maxn],disA[maxn],disB[maxn],A,B;
//disA是每个点到端点A的距离,disB是，每个点到端点B的距离
//A、B为端点A、B的编号
ll zhijing,jl=-0x3f3f3f3f3f3f3f3f,id=0;//定义直径
void dfs(ll now,ll fa){
    for(ll i=head[now];i!=-1;i=b[i].next){
        ll u=b[i].to;
        ll da=b[i].val;
        if(u==fa) continue;
        dis[u]=dis[now]+da;
        if(dis[u]>jl){
            jl=dis[u];
            id=u;
        }
        dfs(u,now);
    }
}//dfs求直径
int main() {
    scanf("%lld%lld",&n,&m);
    memset(head,-1,sizeof(head));
    for(ll i=1;i<=m;i++){
        ll aa,bb,cc;
        scanf("%lld%lld%lld",&aa,&bb,&cc);
        ad(aa,bb,cc);
        ad(bb,aa,cc);
    }
    dfs(1,0);//第一遍dfs求A点标号
    A=id;
    memset(dis,0,sizeof(dis));
    id=0,jl=-0x3f3f3f3f3f3f3f3f;
    dfs(A,0);//第二遍dfs求B点标号以及每一个点到A点的距离
    B=id,zhijing=jl;
    id=0,jl=-0x3f3f3f3f3f3f3f3f;
    for(ll i=1;i<=n;i++){
        disA[i]=dis[i];
    }
    memset(dis,0,sizeof(dis));
    dfs(B,0);//第三遍dfs求每一个点到B点的距离，每次dfs之前不要忘了初始化
    for(ll i=1;i<=n;i++){
        disB[i]=dis[i];
    }
    ll ans=-0x3f3f3f3f3f3f3f3f;
    for(ll i=1;i<=n;i++){
        ans=max(ans,min(disA[i],disB[i]));
    }//求最最优决策
    printf("%lld\n",ans+zhijing);//输出
    return 0;
}
```


---

## 作者：cold_cold (赞：0)

[安利一波博客](https://www.cnblogs.com/cold-cold/p/10035649.html)

此题很容易看出是要先求树的直径，然后的操作我一开始的思路有些错误。

一开始我的想法是在直径上找一个点作为起点，在dfs的过程中记录下直径的路径和权值road，

把road数组前缀和化，于是答案就是lenth+max{min(lenth-road[i],road[i])};

但是在WA掉以后，我发现起点不在直径上也许会更好，于是我们用SPFA求出，每个点到直径两端的距离

那么答案就是lenth+max{min(dis[0][i],dis[1][i])};

实现如下：

```cpp
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstring>
#include <map>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
using namespace std;
typedef long long ll;
inline ll read()
{
    register ll p(1),a(0);register char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if(ch=='-') p=-1,ch=getchar();
    while(ch>='0'&&ch<='9') a=a*10+ch-48,ch=getchar();
    return a*p;
}
const int N=200010;
int n,m,u,v,head[N],cnt=0,zq,zz,len=0,book[N];
ll ans=0,w,maxn=0,road[N],dis[2][N];
struct EDGE{int nxt,to;ll val;}e[N<<1];
void add(int u,int v,ll w){e[++cnt]=(EDGE){head[u],v,w};head[u]=cnt;}
void dfs(int u,int fa,ll siz)
{
    if(siz>maxn){maxn=siz;zq=u;}
    for(int i=head[u],v=e[i].to;i;i=e[i].nxt,v=e[i].to) if(fa!=v) dfs(v,u,siz+e[i].val);
}
queue<int> Q;
void SPFA(int u,int pre)
{
    memset(dis[pre],0x3f,sizeof(dis[pre]));
    memset(book,0,sizeof(book));
    Q.push(u);dis[pre][u]=0;book[u]=1;
    while(!Q.empty())
    {
        u=Q.front();Q.pop();book[u]=0;
        for(int i=head[u],v=e[i].to;i;i=e[i].nxt,v=e[i].to)
            if(dis[pre][v]>dis[pre][u]+e[i].val)
            {
                dis[pre][v]=dis[pre][u]+e[i].val;
                if(!book[v]) Q.push(v);
            }
    }
}
int main()
{
    // freopen("input","r",stdin);
    // freopen("output","w",stdout);
    n=read(),m=read();
    for(int i=1;i<=m;i++)
    {
        u=read(),v=read(),w=read();
        add(u,v,w);add(v,u,w);
    }
    dfs(1,-1,0);zz=zq,maxn=0;
    dfs(zq,-1,0);
    SPFA(zz,0);SPFA(zq,1);
    for(int i=1;i<=n;i++) ans=max(ans,min(dis[0][i],dis[1][i]));
    printf("%lld\n",ans+maxn);
    return 0;
}

```


---


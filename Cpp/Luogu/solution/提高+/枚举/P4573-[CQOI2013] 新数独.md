# [CQOI2013] 新数独

## 题目描述

下面是一个没有数字，只有大小关系（没错，那些尖角都是“大于符号”）！的数独：

![](https://cdn.luogu.com.cn/upload/image_hosting/wm5lvhj6.png)

除了大小关系外（注意相邻格子不能相同），还需要满足通常的数独规则：

 * 每个格子都是 $1\sim 9$ 的数字；
 * 每行都是 $1 \sim 9$ 的排列；
 * 每列都是 $1 \sim 9$ 的排列；
 * 每个 $3\times 3$ 的子矩阵（上图中用粗线隔开，一共有 $3\times 3$ 个这样的子矩阵）都是 $1\sim 9$ 的排列。
 
 如下图所示，是上述提到的数独的唯一一种填法：
 
 ![](https://cdn.luogu.com.cn/upload/image_hosting/73a6a29i.png)
 
 为了美观，每个 $3\times 3$ 子矩阵的**所有 $12$ 对**相邻格子的大小关系都将给出。

## 样例 #1

### 输入

```
> < < < > <
v ^ v v ^ v ^ ^ v
< < < > < <
v ^ v ^ v v ^ ^ v
< < < < > >
< > > > < >
v v ^ ^ v ^ ^ v v
< > > < > >
^ v v v ^ v v ^ v
> < < > > >
< > > > > <
v v v v ^ ^ ^ ^ ^
> < < < < <
^ ^ ^ ^ ^ v v v ^
> > < > < <```

### 输出

```
5 3 9 4 6 8 2 1 7
2 4 8 1 9 7 3 5 6
1 6 7 2 3 5 9 8 4
6 8 1 7 4 2 5 9 3
3 7 5 9 1 6 8 4 2
9 2 4 5 8 3 7 6 1
7 9 6 8 2 1 4 3 5
4 1 2 3 5 9 6 7 8
8 5 3 6 7 4 1 2 9```

## 样例 #2

### 输入

```
< > > < > <
v v ^ ^ v v ^ ^ ^
< < > < > <
^ ^ ^ v ^ ^ ^ v v
< < < < > > 
> < > > > >
v ^ ^ ^ ^ v v v ^
> > > > < >
v v ^ v ^ v ^ v ^
> < < > > > 
< < < < > <
v ^ v v v v ^ ^ v
< > > < < >
^ v v v ^ v ^ v v
< > < > < >```

### 输出

```
4 9 1 7 3 6 5 2 8
2 3 7 8 1 5 6 4 9
5 6 8 2 4 9 7 3 1
9 1 3 6 5 4 8 7 2
8 5 4 9 7 2 1 6 3
7 2 6 3 8 1 9 5 4
3 4 9 5 6 8 2 1 7
1 8 5 4 2 7 3 9 6
6 7 2 1 9 3 4 8 5```

# 题解

## 作者：一只书虫仔 (赞：28)

做这道题的原因：上课教练给了一道这题的加强版，然后我就走入了一条不归路。

[本题链接](https://www.luogu.com.cn/problem/P4573) [加强版链接](https://www.luogu.com.cn/problem/U141689)

#### Description

> 给定一个 $9 \times 9$ 的数独，并且每一个格子都与与他在同一个宫格里的数有大小关系，求填数独。

#### Solution 1

最简单的做法，直接 dfs。

先搞一个生成数独 dfs 出来，然后套进去输入。

输入如果嫌麻烦的话可以试试将所有行和列的大小关系存入数组，找一找规律不难发现，无论是上下还是左右关系，都是当编号不为 $3$ 的倍数是才会有关系，并且先左右后上下，因此我们可以这么输入：

```cpp
for (int i = 1; i <= 9; i++) {
	for (int j = 1; j <= 9; j++) { // left and right
		if (j % 3 == 0) continue;
			scanf(" %c", &lvr[i][j]);
	}
	for (int j = 1; j <= 9; j++) { // up and down 
		if (i % 3 == 0) continue;
			scanf(" %c", &uvd[i][j]);
	}
}
```

然后在普通 dfs 生成数独的特判中套进去关系特判即可：

```cpp
if (x > 1 && x - 1 % 3 != 0) {
	char tmp = uvd[x - 1][y];
	if (tmp == '^') 
		if (a[x - 1][y] > i) 
			continue;
	if (tmp == 'v')
		if (a[x - 1][y] < i)
			continue;
} // a[x - 1][y] & a[x][y]
if (y > 1 && y - 1 % 3 != 0) {
	char tmp = lvr[x][y - 1];
	if (tmp == '<')
		if (a[x][y - 1] > i)
				continue;
	if (tmp == '>')
		if (a[x][y - 1] < i)
			continue;
} // a[x][y - 1] & a[x][y]
```

dfs 生成数独的代码不放了，可以看看 [这题](https://www.luogu.com.cn/problem/P1784)。

然后用这个思路可以过本题，但是教练的加强版并过不了，只能获得 $40$ 分的好成绩（

#### Solution 2

上面的代码我们是先按照行，再按照列的顺序进行枚举，一个格子只能最多判断两个关系，太浪费了。

因此我们可以先枚举宫格，再枚举行，再枚举列。

这块我们不能再采用二维 dfs 了，因为我们的思路是基于一个结构体排序。

创建一个结构体，编号为 $cur$ 的点记录他的行，列和宫格。

按照排序的思路，也可以把排序函数写出来：

```cpp
struct qaq {
	int Col;
	int Row;
	int Gongge;
} sudaku[90];

bool fjrakioi (qaq x, qaq y) {
	if (x.Gongge != y.Gongge) return x.Gongge < y.Gongge;
	else if (x.Col != y.Col) return x.Col < y.Col;
	else return x.Row < y.Row; 
} // fjr AK IOI !!!!!!!!!!!!!
```

需要修改的部分只有 dfs 中的特判边界条件（从 $x>9$ 变为 $cur>81$）还有 dfs 内的当前局面变量（$x,y$ 变为 $cur$，为了方便可以定义另定义 $x,y$ 为 `x = sudaku[cur].Col, y = sudaku[cur].Row`），其他貌似并没有什么不一样，这个做法可以在加强版中获得 $55$ 分的好成绩（

#### Solution 3

这道题是在我们学拓扑排序的时候给的，所以这题可以用上拓扑排序（

因为这题有不同格子之间的大小关系，所以我们可以将大小关系化为拓扑排序中的图的边（这个对于拓扑排序题来说挺套路的吧 qwq），然后在结构体中加上一个变量 $tp$ 为这个格子在拓扑排序中的位置，然后按照宫格，$tp$，行，列的顺序进行排序：

```cpp
struct qaq {
	int Col;
	int Row;
	int Gongge;
	int Tuopu;
} sudaku[90];

bool fjrakioi (qaq x, qaq y) {
	if (x.Gongge != y.Gongge) return x.Gongge < y.Gongge;
	else if (x.Tuopu != y.Tuopu) return x.Tuopu < y.Tuopu;
	else if (x.Col != y.Col) return x.Col < y.Col;
	else return x.Row < y.Row; 
}
```

转化图的时候有一点比较麻烦，就是图的点编号是一个一维的，但是数独矩阵是二维的，怎么转化呢？

教练把点转化为了二维，我觉得不必要，可以把格子的二维转化为一维，公式是 $(x-1) \times 9+y$，注意一下边界即可。

然后在 dfs 数独的特判中要从四个特判改成八个特判，因为你不知道你四周哪个点比你的拓扑排序位置靠前，所以干脆都特判一遍：

```cpp
if (x > 1 && x - 1 % 3 != 0 && a[x - 1][y] != 0) {
	char tmp = uvd[x - 1][y];
		if (tmp == '^') 
			if (a[x - 1][y] > i) 
				continue;
		if (tmp == 'v')
			if (a[x - 1][y] < i)
				continue;
} // a[x - 1][y] & a[x][y]
if (y > 1 && y - 1 % 3 != 0 && a[x][y - 1] != 0) {
	char tmp = lvr[x][y - 1];
		if (tmp == '<')
			if (a[x][y - 1] > i)
				continue;
		if (tmp == '>')
			if (a[x][y - 1] < i)
				continue;
} // a[x][y - 1] & a[x][y]
if (x < 9 && x + 1 % 3 != 0 && a[x + 1][y] != 0) {
	char tmp = uvd[x + 1][y];
		if (tmp == '^') 
			if (a[x + 1][y] > i) 
				continue;
		if (tmp == 'v')
			if (a[x + 1][y] < i)
				continue;
} // a[x + 1][y] & a[x][y]
if (y < 9 && y + 1 % 3 != 0 && a[x][y + 1] != 0) {
	char tmp = lvr[x][y + 1];
		if (tmp == '<')
			if (a[x][y + 1] > i)
				continue;
		if (tmp == '>')
			if (a[x][y + 1] < i)
				continue;
} // a[x][y + 1] & a[x][y]
```

但是，这个代码仍然是 $55$，书虫一怒之下，求助了教练（

教练说可以加一步特判，即比如说这个格子 $cur_1$ 比他上面的格子 $cur_2$ 要大，那么如果确定了 $cur_2$，那么就不需要在 $[1,9]$ 的区间里枚举 $cur_1$，在 $[cur_2,9]$ 的区间里枚举 $cur_1$ 即可，因此枚举 for 循环可以改一步：

```cpp
int Max = -1;
if (x != 1 && a[x - 1][y] != 0 && uvd[x - 1][y] == '^') Max = max(Max, a[x - 1][y]);
if (x != 9 && a[x + 1][y] != 0 && uvd[x + 1][y] == 'v') Max = max(Max, a[x + 1][y]);
if (y != 1 && a[x][y - 1] != 0 && lvr[x][y - 1] == '<') Max = max(Max, a[x][y - 1]);
if (y != 9 && a[x][y + 1] != 0 && lvr[x][y + 1] == '>') Max = max(Max, a[x][y + 1]);
if (Max == -1) Max = 1;
for (int i = Max; i <= 9; i++)
```

然后，还是没卡过 $55$（

~~然后教练把时限开到了 $5$ 秒~~      
~~然后全机房的同学爽了一把，AC 了~~      
~~然后我居然跑了个机房最优解（5.5s）smg~~         
~~然后 fjr $5$ 秒的都没过 smg~~

#### Code

说了这么多，放一个教练加强版最慢点跑 $3$ 秒多的代码吧：

```cpp
#include <bits/stdc++.h>

using namespace std;

int zqzakioi (int x, int y) {
    return (x - 1) * 9 + y;
} 

int head[100]; 
int cnt;
int indeg[100];
int tuopu[100]; // index of tuopu
int Index;

struct node {
    int u, v;
} e[100];

void AddEdge (int u, int v) {
    e[++cnt].u = v;
    e[cnt].v = head[u];
    head[u] = cnt;
}

int Box[11][11] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
    {0, 1, 1, 1, 2, 2, 2, 3, 3, 3}, 
    {0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
    {0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
    {0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
    {0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
    {0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
    {0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
    {0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
    {0, 7, 7, 7, 8, 8, 8, 9, 9, 9}
};

struct qaq {
    int Col;
    int Row;
    int Gongge;
    int Tuopu;
} sudaku[90];

bool fjrakioi (qaq x, qaq y) {
    if (x.Gongge != y.Gongge) return x.Gongge < y.Gongge;
    else if (x.Tuopu != y.Tuopu) return x.Tuopu < y.Tuopu;
    else if (x.Col != y.Col) return x.Col < y.Col;
    else return x.Row < y.Row; 
}

bool col[11][11]; // hang
bool row[11][11]; // lie
bool box[11][11]; // gongge

int a[11][11];

bool lvr[11][11]; // left and right
bool uvd[11][11]; // up and down

void dfs (int cur) {
    if (cur > 81) {
        for (int i = 1; i <= 9; i++)  {
            for (int j = 1; j <= 9; j++)
                printf("%d ", a[i][j]);
            puts("");
        } 
        exit(0);
    }
    int x = sudaku[cur].Col;
    int y = sudaku[cur].Row;
    int Max = -1;
    if (x != 1 && a[x - 1][y] != 0 && uvd[x - 1][y] == '^') Max = max(Max, a[x - 1][y]);
    if (x != 9 && a[x + 1][y] != 0 && uvd[x + 1][y] == 'v') Max = max(Max, a[x + 1][y]);
    if (y != 1 && a[x][y - 1] != 0 && lvr[x][y - 1] == '<') Max = max(Max, a[x][y - 1]);
    if (y != 9 && a[x][y + 1] != 0 && lvr[x][y + 1] == '>') Max = max(Max, a[x][y + 1]);
    if (Max == -1) Max = 1;
    for (int i = Max; i <= 9; i++) {
        if (col[x][i] == true) continue;
        if (row[y][i] == true) continue;
        if (box[Box[x][y]][i] == true) continue;
        if (x > 1 && x - 1 % 3 != 0 && a[x - 1][y] != 0) {
            char tmp = uvd[x - 1][y];
            if (tmp == '^') 
                if (a[x - 1][y] > i) 
                    continue;
            if (tmp == 'v')
                if (a[x - 1][y] < i)
                    continue;
        } // a[x - 1][y] & a[x][y]
        if (y > 1 && y - 1 % 3 != 0 && a[x][y - 1] != 0) {
            char tmp = lvr[x][y - 1];
            if (tmp == '<')
                if (a[x][y - 1] > i)
                    continue;
            if (tmp == '>')
                if (a[x][y - 1] < i)
                    continue;
        } // a[x][y - 1] & a[x][y]
        if (x < 9 && x + 1 % 3 != 0 && a[x + 1][y] != 0) {
            char tmp = uvd[x + 1][y];
            if (tmp == '^') 
                if (a[x + 1][y] > i) 
                    continue;
            if (tmp == 'v')
                if (a[x + 1][y] < i)
                    continue;
        } // a[x + 1][y] & a[x][y]
        if (y < 9 && y + 1 % 3 != 0 && a[x][y + 1] != 0) {
            char tmp = lvr[x][y + 1];
            if (tmp == '<')
                if (a[x][y + 1] > i)
                    continue;
            if (tmp == '>')
                if (a[x][y + 1] < i)
                    continue;
        } // a[x][y + 1] & a[x][y]
        a[x][y] = i;
        col[x][i] = true;
        row[y][i] = true;
        box[Box[x][y]][i] = true;
        dfs(cur + 1);
        col[x][i] = false;
        row[y][i] = false;
        box[Box[x][y]][i] = false;
        a[x][y] = 0;
    }
}

int main () {
    for (int i = 1; i <= 9; i++) {
        for (int j = 1; j <= 9; j++) { // left and right
            if (j % 3 == 0) continue;
            scanf(" %c", &lvr[i][j]);
        }
        for (int j = 1; j <= 9; j++) { // up and down 
            if (i % 3 == 0) continue;
            scanf(" %c", &uvd[i][j]);
        }
    }
    for (int i = 1; i <= 9; i++)
        for (int j = 1; j <= 9; j++) {
            int tmp = zqzakioi(i, j);
            if (j % 3 != 0 && lvr[i][j] == '<') AddEdge(tmp, tmp + 1), indeg[tmp + 1]++;
            if (j % 3 != 0 && lvr[i][j] == '>') AddEdge(tmp + 1, tmp), indeg[tmp]++;
            if (i % 3 != 0 && uvd[i][j] == '^') AddEdge(tmp, tmp + 9), indeg[tmp + 9]++;
            if (i % 3 != 0 && uvd[i][j] == 'v') AddEdge(tmp + 9, tmp), indeg[tmp]++;
        }
    queue <int> q;
    for (int i = 1; i <= 81; i++)
        if (indeg[i] == 0)
            q.push(i);
    while (!q.empty()) {
        int cur = q.front();
        tuopu[++Index] = cur;
        q.pop();
        for (int p = head[cur]; p; p = e[p].v) {
            int tmp = e[p].u;
            indeg[tmp]--;
            if (indeg[tmp] == 0) q.push(tmp);
        }
    }
    int cnt_c = 1, cnt_r = 0; 
    for (int i = 1; i <= 81; i++) {
        cnt_r++;
        if (cnt_r > 9) cnt_c++, cnt_r = 1;
        sudaku[i].Col = cnt_c;
        sudaku[i].Row = cnt_r;
        sudaku[i].Gongge = Box[cnt_c][cnt_r];
        int cnt_t;
        for (int j = 1; j <= 81; j++) 
            if (tuopu[j] == i) {
                cnt_t = i;
                break;
            }
        sudaku[i].Tuopu = cnt_t;
    }
    sort(sudaku + 1, sudaku + 82, fjrakioi);
    dfs(1);
    return 0;
}
```

感谢您的阅读，希望对您有帮助

---

## 作者：Juan_feng (赞：18)

这道题居然没有人发题解，~~那本蒟蒻就来水一篇吧。~~

## 先来说说思路

**先不要把这道题想的太难了，你可以把这道题看成一个标准的数独加上几个判断。那么这道题就是标准的dfs，把9*9的方阵从头到尾搜一遍，判断每一个格子能否放1-9之间的数就行了。**
### 整理一下判断条件：
1.这一行是否有重复的数

2.这一列是否有重复的数

3.这一个小九宫格中是否有重复的数

4.是否符合大于小于的条件

**现在我分别用  _ h[i][j] ,l[i][j] ,g[i][j] _ 来表示第i行，第i列，第i个小九宫格中数字j是否重复。还有一个大于小于号的问题后面再说，让我们先来看一下读入。**

输入格式：
一共15行，包含一个新数独的实例。第奇数行包含左右方向的符号（<和>），第偶数行包含上下方向的符号（^和v） 

**说是奇数行包含左右方向的符号，偶数行包含上下方向的符号，其实如果你仔细的看一下题目或者样例输入的话，应该不难发现输入格式的描述略有问题，有的行与输入描述是相反的。。。（如果已经改过来了就当我没说）**

**其实可以这样看：输入是有15行的，你可以把这15行分成3组，每组5行，这样描述就对了，每一组的奇数行和偶数行按描述进行读入即可**。

**读入符号之后，先看这个符号属于哪一个小九宫格（因为不同小九宫格的符号是不相关的），然后就要用到下面这个数组了:**

>#### f[i][x][y]  

**它表示第i个小九宫格中第x个数和第y个数是否有大小关系。  
读入的时候如果是">"或者"v"就在相应的位置保存1，如果是"<"或"^"就保存2。**

**那么这样一来符号的问题就不是问题了，在选数的时候多加一个循环判断一下这个数周围的大小关系是否合法不就行了？**

## 那么代码如下：
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define re register
#define FOR(i,l,r) for(re int i=l;i<=r;i++)
using namespace std;

int a[10][10],h[10][10],l[10][10],g[10][10],m,n,c,f[10][10][10]; 
void dfs(int x,int y)
{
	if(x==9&&y==10)   //终止条件 
    {
	   FOR(i,1,9)   //输出填好的数独 
       {
       	 FOR(j,1,9)
       	   printf("%d ",a[i][j]);
       	 cout<<endl;
	   }
	   exit(0);  //因为保证唯一解，所以搜到一个就退出 
	}	
	if(y==10)   //搜索换行条件 
	{
		x=x+1;y=1;
	}
	FOR(i,1,9)  //枚举这一个格子中的数字（1~9） 
	{	
	    bool bl=0;
		int g1=((x-1)/3)*3,g2=(y-1)/3,g3=g1+g2;  //判断这个点在哪个小九宫格中（0~8） 
		if(g[g3][i]==1||h[x][i]==1||l[y][i]==1) //判断行，列和小九宫格中是否用过该数字 
	  	  	continue;
	  	FOR(j,1,9) // 小九宫格中大于小于号的情况
	  	{
	  		int ii=(x-1)%3*3+(y-1)%3+1;  //将坐标xy转为在九宫格内的序号（1~9） 
	  		if(f[g3][ii][j]==1) //大于号 
	  		{
	  			int xj=g3/3*3+(j-1)/3+1,yj=g3%3*3+(j-1)%3+1;  
	  			if(a[xj][yj]!=0)
                  if(i<a[xj][yj]) {
	  		  	    bl=1; break;
				}
			}
	  		if(f[g3][ii][j]==2) //小于号 
	  		{
	  			int xj=g3/3*3+(j-1)/3+1,yj=g3%3*3+(j-1)%3+1;
	  			if(a[xj][yj]!=0)
	  			  if(i>a[xj][yj]){
	  		  	    bl=1; break;
				} 
			}	  
		}
		if(bl==1) continue;
		g[g3][i]=1;h[x][i]=1;l[y][i]=1; //将行，列，小九宫格标记为已选 
		a[x][y]=i;   //标记选好的数字 
		dfs(x,y+1);  //搜索下一个点 
		a[x][y]=0;   
		g[g3][i]=0;h[x][i]=0;l[y][i]=0;  //回溯 
	}
	
}
int main()
{
	int ci=0;
	char s;
	FOR(i,1,3)  //把读入分为3组  
	{
		FOR(k,1,5)  //每组读入5行 
		{
			if(k%2==1)
			{
				FOR(j,1,6)  //单数行读入6个">"或"<" 
				{
					int q1=(i-1)*3,q2=(j-1)/2,q3=q1+q2; //计算该符号属于哪一组小九宫格 
					cin>>s;
					if(s=='>')  
					{
						int qq=(k-1)/2*3+(j-1)%2+1; 
					    f[q3][qq][qq+1]=1;     //1为大于，2为小于 
					    f[q3][qq+1][qq]=2;
					}
					else
					{
						int qq=(k-1)/2*3+(j-1)%2+1;
					    f[q3][qq][qq+1]=2;
					    f[q3][qq+1][qq]=1;
					}
				}	
			}
			else
			{
				FOR(j,1,9)   //双数行读入9个"v"或"^" 以下步骤与单数行相似 
				{
					int q1=(i-1)*3,q2=(j-1)/3,q3=q1+q2;
					cin>>s;
					if(s=='v')  
					{
						int qq=(k-1)/2*3+(j-1)%3+1;
						f[q3][qq][qq+3]=1;
						f[q3][qq+3][qq]=2;
					} 
					else
					{
						int qq=(k-1)/2*3+(j-1)%3+1;
						f[q3][qq][qq+3]=2;
						f[q3][qq+3][qq]=1;
					}
				}	
			}
		}
	}
	dfs(1,1);
    return 0; //功德圆满
}
```

---

## 作者：jiangXxin (赞：6)

改啊改，终于把这道题A了，其实这道题只不过是一个普通的数独加上一大堆判断罢了，应该来说想是挺好想的，但是写起来特别麻烦。

**先来谈一下思路：**

DFS，相当于枚举每一个点的取值，然后判断当前这个点能不能取这个值，不行就下一个，从$(1,1)$开始枚举，如果最终到达了（9,9）这个点，那么就一定是解，就可以输出了。

**实现过程：**

用一个二维数组**h**来表示在这个数这一行的数字分布情况，有这个数字就是1，没有就是0。**l**数组表示这一列的数字分布情况，作用和**h**相同，一个g数组表示在这个数字所在的小九宫格的数字分布情况。

**以上是实现基本数独所需要的**，要完成这道题，还需要一个数组（map）来映射大小关系，在这里，我使用的是一个四维数组，前两维表示一个点的坐标，后面两维用来表示另外一个点的坐标，数组存的是一个二者的最小值坐标。

**这里存最小值坐标的方法：**

考虑到这道题的坐标范围不会超过9，所以可以用$x*10+y$这个表达式来存取坐标，这样是绝对不会冲突的。

那么做好了上面的所有准备，只需要每一次填数的时候进行一堆判断，最后答案就可以出来了。

**以下是代码（略微过长，还有很多可优化的地方）：**

```cpp
#include<iostream>
#include<algorithm>
#include<map>
using namespace std;
const int N=110;
bool h[N][N],l[N][N],g[N][N];//行，列，方块 
int op[N/10][N/10][N/10][N/10];//表示两个相邻的点大小情况 
int m[N][N];//存图 
void printf()//输出 
{
	for(int i=1;i<=9;i++)
	{
		for(int j=1;j<=9;j++)
		{
			cout<<m[i][j]<<" ";
		}
		cout<<endl;
	}
	return;
}
bool pd(int x,int y,int i)//位置，要填的数 
{
	int next=x*10+y;//下一个方位hash 
	if(op[x][y][x-1][y]==next)//和上面的做比较,自己小一点 
	{
		if(m[x-1][y]<=i&&m[x-1][y]!=0)
		{
			return false;
		}
	}
	if(op[x][y][x-1][y]!=next&&op[x][y][x-1][y]!=0)//自己比上面的大 
	{
		if(m[x-1][y]>=i)
		{
			return false;
		}
	}
	if(op[x][y][x+1][y]==next)//和下面的做比较，自己小 
	{
		if(m[x+1][y]<=i&&m[x+1][y]!=0)
		{
			return false;
		}
	}		
	if(op[x][y][x+1][y]!=next&&op[x][y][x+1][y]!=0)//自己大 
	{
		if(m[x+1][y]>=i)
		{
			return false;
		}
	}	
	if(op[x][y][x][y-1]==next)//左边的做比较 ,自己小 
	{
		if(m[x][y-1]<=i&&m[x][y-1]!=0)
		{
			return false;
		}
	}	
	if(op[x][y][x][y-1]!=next&&op[x][y][x][y-1]!=0)//自己大 
	{
		if(m[x][y-1]>=i)
		{
			return false;
		}
	}		
	if(op[x][y][x][y+1]==next)//自己小 
	{
		if(m[x][y+1]<=i&&m[x][y+1]!=0)
		{
			return false;
		}
	}	
	if(op[x][y][x][y+1]!=next&&op[x][y][x][y+1]!=0)
	{
		if(m[x][y+1]>=i)
		{
			return false;
		}
	}	
	return true;
}
void dfs(int x,int y)
{
	if(m[x][y]!=0)
	{
		if(x==9&&y==9)
		{
			printf();
			exit(0);
		}
		if(y==9)
		{
			dfs(x+1,y);
		}
		else
		{
			dfs(x,y+1);
		}
	}
	if(m[x][y]==0)
	{
		for(int i=1;i<=9;i++)
		{
			if(h[x][i]==0&&l[y][i]==0&&g[(x-1)/3*3+(y-1)/3+1][i]==0)//数独标准配合 
			{
				if(pd(x,y,i)==true)//判断成功 
				{
					m[x][y]=i;
					h[x][i]=1;
					l[y][i]=1;
					g[(x-1)/3*3+(y-1)/3+1][i]=1;
					if(x==9&&y==9)
		   			{
		      		    printf();
						exit(0);   	
		  		    }              
	       			if(y==9)  
		   			{
		 				dfs(x+1,1);   	
		  			}  
		  			else	 
		  			{
		 			  	dfs(x,y+1);
		 			}  
					m[x][y]=0;	
					h[x][i]=0;
					l[y][i]=0;
					g[(x-1)/3*3+(y-1)/3+1][i]=0;					
				}
			}
		}
	}
}
void sign(char a,char b,char c,char d,char e,char f,int h)//左右方向映射 
{
	if(a=='<')
	{
		op[h][1][h][2]=h*10+1;
		op[h][2][h][1]=h*10+1;			
	}
	if(a=='>')
	{
		op[h][1][h][2]=h*10+2;
		op[h][2][h][1]=h*10+2;			
	}
	if(b=='>')
	{
		op[h][2][h][3]=h*10+3;
		op[h][3][h][2]=h*10+3;		
	}
	if(b=='<')
	{
		op[h][2][h][3]=h*10+2;
		op[h][3][h][2]=h*10+2;
	}			
	if(c=='<')	
	{
		op[h][4][h][5]=h*10+4;
		op[h][5][h][4]=h*10+4;
	}		
	if(c=='>')	
	{
		op[h][4][h][5]=h*10+5;
		op[h][5][h][4]=h*10+5;
	}
	if(d=='>')	
	{
		op[h][5][h][6]=h*10+6;
		op[h][6][h][5]=h*10+6;
	}
	if(d=='<')	
	{
		op[h][5][h][6]=h*10+5;
		op[h][6][h][5]=h*10+5;
	}
	if(e=='>')
	{
		op[h][7][h][8]=h*10+8;
		op[h][8][h][7]=h*10+8;		
	}
	if(e=='<')
	{
		op[h][7][h][8]=h*10+7;
		op[h][8][h][7]=h*10+7;		
	}
	if(f=='>')
	{
		op[h][8][h][9]=h*10+9;
		op[h][9][h][8]=h*10+9;		
	}
	if(f=='<')
	{
		op[h][8][h][9]=h*10+8;
		op[h][9][h][8]=h*10+8;		
	}			
}
void upsign(int i,char c,int j)
{
	if(c=='^')//上面比下面小 
	{
		if(i==2)//第二行 
		{
			op[1][j][2][j]=1*10+j;
			op[2][j][1][j]=1*10+j;//映射成最小的 
		}
		if(i==4)
		{
			op[2][j][3][j]=2*10+j;
			op[3][j][2][j]=2*10+j;		
		}
		if(i==7)
		{
			op[4][j][5][j]=4*10+j;
			op[5][j][4][j]=4*10+j;		
		}
		if(i==9)
		{
			op[5][j][6][j]=5*10+j;
			op[6][j][5][j]=5*10+j;		
		}
		if(i==12)
		{
			op[7][j][8][j]=7*10+j;
			op[8][j][7][j]=7*10+j;		
		}
		if(i==14)
		{
			op[8][j][9][j]=8*10+j;
			op[9][j][8][j]=8*10+j;		
		}		
	}
	else//上面 比当前大 
	{
		if(i==2)//第二行 
		{
			op[1][j][2][j]=2*10+j;
			op[2][j][1][j]=2*10+j;//映射成最小的坐标 
		}
		if(i==4)
		{
			op[2][j][3][j]=3*10+j;
			op[3][j][2][j]=3*10+j;		
		}
		if(i==7)
		{
			op[4][j][5][j]=5*10+j;
			op[5][j][4][j]=5*10+j;		
		}
		if(i==9)
		{
			op[5][j][6][j]=6*10+j;
			op[6][j][5][j]=6*10+j;		
		}
		if(i==12)
		{
			op[7][j][8][j]=8*10+j;
			op[8][j][7][j]=8*10+j;		
		}
		if(i==14)
		{
			op[8][j][9][j]=9*10+j;
			op[9][j][8][j]=9*10+j;		
		}				
	}

}
int main()
{
	int h=0;
	for(int i=1;i<=15;i++)
	{
		if(i==2||i==4||i==7||i==9||i==12||i==14)//上下方向 
		{
			for(int j=1;j<=9;j++)//9个方向 
			{
				char c;
				cin>>c;
				upsign(i,c,j);//标记大小 
			}
			continue;
		}		
		h++;
		char a,b,c,d,e,f;
		cin>>a>>b>>c>>d>>e>>f;
		sign(a,b,c,d,e,f,h);//标记大小 
	}
	dfs(1,1);
	return 0;
} 
```

---

## 作者：LevenKoko (赞：3)

[本题解同步发表于此~~（不过这里写的比较简洁）~~](https://www.cnblogs.com/zhenglw/p/10516111.html)

### 首先，这是一道数独题~~（废话*1）~~
### 其次，根据题目它有唯一解~~（废话*2）~~
### 所以，个人认为这题比有一年联赛靶形数独要简单

数独都是一样的套路...

```bh[i][z],bl[i][z],num[i][z]```三个数组分别判断该行/列/3*3方格是否填过z这个数

然后就很~~简单~~了，**关键在判断大小关系：**

我们可以写两个bool函数 check_lr（left,right）和check_ud（up,down）
分别代表检查左右大小关系和上下大小关系

简要分析搜索顺序可以发现对于当前格子我们只知道它的前一个格子和上面一个格子的大小关系，所以我们大大可以只比较这个数的前一个/上一个大小关系来剪枝

而在确定当前格子的时候不用管它的右边一个和下面一个，这样可以大大缩小代码长度和思考难度

```cpp
inline int check_lr(int x,int y,int z){
	if(y%3==1)return 1;
//如果是每个3*3小格子的第一列，没有大小关系，直接填
	if(h[x][y-1]=='<') return ANS[x][y-1]<z;
	else return ANS[x][y-1]>z;
}
```

```cpp
inline int check_ud(int x,int y,int z){//同check_lr
	if(x%3==1)return 1;
	if(l[x-1][y]=='v') return ANS[x-1][y]>z;
	else return ANS[x-1][y]<z;
}

```

还有输入好毒瘤啊，本来想一个双重循环搞过去的，结果...自己看代码吧...

总的来说，看到其他发题解的大佬判断剪枝都有点烦了，~~如果不算输入的话我的代码应该是最短的话（不过我的输入还是比较好理解的呀）~~


```cpp
#include<cstdio>
#include<queue>
#include<iostream>
#include<cstring>
using namespace std;
inline int read(){
	int ans=0,f=1;char chr=getchar();
	while(!isdigit(chr)){if(chr=='-') f=-1;chr=getchar();}
	while(isdigit(chr)){ans=(ans<<3)+(ans<<1)+chr-48;chr=getchar();}
	return ans*f;
}char h[20][20],l[20][20];int num[15][15],bh[15][15],bl[15][15];
inline int get(int x,int y){return (x-1)/3*3+(y-1)/3+1;}int ANS[10][10];
inline int check(int x,int y,int z){if(bh[x][z]||bl[y][z]||num[get(x,y)][z]) return 0;return 1;}
inline void init(int x,int y,int z) {num[get(x,y)][z]=bh[x][z]=bl[y][z]=1;}
inline void outit(int x,int y,int z){num[get(x,y)][z]=bh[x][z]=bl[y][z]=0;}
inline int check_lr(int x,int y,int z){
	if(y%3==1)return 1;
	if(h[x][y-1]=='<') return ANS[x][y-1]<z;
	else return ANS[x][y-1]>z;
}
inline int check_ud(int x,int y,int z){
	if(x%3==1)return 1;
	if(l[x-1][y]=='v') return ANS[x-1][y]>z;
	else return ANS[x-1][y]<z;
}
inline void OUTPUT(){for(int i=1;i<=9;i++,puts(""))for(int j=1;j<=9;j++) printf("%d ",ANS[i][j]);}
void dfs(int x,int y){
	if(x==10){OUTPUT();exit(0);}
	if(y==10){dfs(x+1,1);return;}
	for(int i=1;i<=9;i++)
		if(check(x,y,i)&&check_lr(x,y,i)&&check_ud(x,y,i))
			ANS[x][y]=i,init(x,y,i),dfs(x,y+1),outit(x,y,i);
//init用来标记这个格子用过了，outit用来回溯，取消标记
}int main(){
	for(int i=1;i<=9;i++) {if(i%3==0) continue;cin>>h[1][i];}
	for(int i=1;i<=9;i++) cin>>l[1][i];
	for(int i=1;i<=9;i++) {if(i%3==0) continue;cin>>h[2][i];}
	for(int i=1;i<=9;i++) cin>>l[2][i];
	for(int i=1;i<=9;i++) {if(i%3==0) continue;cin>>h[3][i];}
	for(int i=1;i<=9;i++) {if(i%3==0) continue;cin>>h[4][i];}
	for(int i=1;i<=9;i++) cin>>l[4][i];
	for(int i=1;i<=9;i++) {if(i%3==0) continue;cin>>h[5][i];}
	for(int i=1;i<=9;i++) cin>>l[5][i];
	for(int i=1;i<=9;i++) {if(i%3==0) continue;cin>>h[6][i];}
	for(int i=1;i<=9;i++) {if(i%3==0) continue;cin>>h[7][i];}
	for(int i=1;i<=9;i++) cin>>l[7][i];
	for(int i=1;i<=9;i++) {if(i%3==0) continue;cin>>h[8][i];}
	for(int i=1;i<=9;i++) cin>>l[8][i];
	for(int i=1;i<=9;i++) {if(i%3==0) continue;cin>>h[9][i];}
	dfs(1,1);
	return 0;
}
```







---

## 作者：寒鸽儿 (赞：2)

最近发现不会打暴力题了于是来补一发暴力。  
首先这是个普通的数独再加上限制条件,状态空间并不是很大,所以直接搜即可。  
话说这种比较大的搜索弄出一点工程的味道真的可以节省时间和脑力,多搞几个函数分散函数体吧  
```cpp
#include <cstdio>
#include <cstring>

using namespace std;

const int N = 15, M = 5;

int m[N][N], f[N][N][M], row[N][N], colu[N][N], blk[N][N];

inline void input();
inline bool check(int,int,int,int);
inline int getone(void);
inline void getnxt(int,int,int&,int&);
inline void output(void);
void sch(int,int);
inline int getblk(int x, int y) { return (y-1)/3+1+(x-1)/3*3; }

int main() {
	memset(f, -1, sizeof(f));
	input();
	sch(1, 1);
	return 0;
}

void sch(int x, int y) {
	if(x == 10) {
		output();
		return;
	}
	int block = getblk(x, y), tx, ty;
	getnxt(x, y, tx, ty);
	for(int i = 1; i <= 9; ++i) {
		if(check(x,y,i, block)) {
			row[x][i] = colu[y][i] = blk[block][i] = 1;
			m[x][y] = i;
			sch(tx, ty);
			m[x][y] = 0;
			row[x][i] = colu[y][i] = blk[block][i] = 0;
		}
	}
}

inline bool check(int x, int y, int i, int block) {
	if(row[x][i] || colu[y][i] || blk[block][i]) return false;
	if(~f[x][y][0] && m[x][y-1] && ((int)(i>m[x][y-1])^(f[x][y][0]))) return false;
	if(~f[x][y][1] && m[x][y+1] && ((int)(i>m[x][y+1])^(f[x][y][1]))) return false;
	if(~f[x][y][2] && m[x-1][y] && ((int)(i>m[x-1][y])^(f[x][y][2]))) return false;
	if(~f[x][y][3] && m[x+1][y] && ((int)(i>m[x+1][y])^(f[x][y][3]))) return false;
	return true; 
}

inline void getnxt(int x, int y, int &tx, int &ty) {
	if(y == 9) {
		tx = x + 1; ty = 1;
	}else {
		tx = x; ty = y + 1;
	}
}
// -> 1 	<- 0	^ 2		v 3
inline void input() {
	int tmp;
	for(int i = 1; i <= 9; ++i) {
		for(int j = 1; j <= 9; ++j) 
			if(j % 3) {
			tmp = getone();
			f[i][j][1] = tmp;
			f[i][j+1][0] = tmp^1;
			}
		if(i%3) for(int j = 1; j <= 9; ++j) {
			tmp = getone();
			f[i][j][3] = tmp;
			f[i+1][j][2] = tmp^1;
		}
	}
}

inline int getone() {
	char ch = getchar();
	while(ch != '<' && ch != '>' && ch != '^' && ch != 'v') ch = getchar();
	if(ch == '<') return 0;
	if(ch == '>') return 1;
	if(ch == '^') return 0;
	return 1;
}

inline void output() {
	for(int i = 1; i <= 9; ++i) {
		for(int j = 1; j <= 9; ++j) {
			printf("%d ", m[i][j]); 
		}
		printf("\n");
	} 
}
```

---

## 作者：chichichichi (赞：1)

一道搜索写一天……我太菜了

###  在这篇题解里你可以看到
	
   - 很多奇怪的式子
   
   - 很多 if
	- 很多循环
    
 ~~（以上都是废话）~~
 
## 正文

解法大体就是 DFS + 判断，DFS填数独很简单，所以重点在于如何判断，本篇题解会重点讲解关于本题中判断的各类细节。

- DFS框架

从左上角$(1,1)$开始，自左向右，自上到下进行搜索。

自左向右好说，每次将 $y$ 加 $1$。自上到下就要换行，当 $y==10$ 时，已经出了$9*9$的数独范围，就要到下一行去，即 $x$ 加 $1$ ， $y=1$。

当搜索到$(9,10)$时搜索结束。

每到一个位置$(x,y)$，就枚举取值，然后根据各种条件**判断**当前位置是否可行。

- 判断

1. 普通数独的约束：每行、每列、每个子矩阵中取值不能重复。

我们可以开三个二维数组，第一维分别表示：每行、每列、每个子矩阵的编号，第二维表示$1\sim9$的取值。
   
例如：设二维数组 $vis1$ 来记录每行的取值情况，则 $vis1[i][j]=1$ 表示第 $i$ 行中已有数字 $j$ 。
   
2. 新数独的约束：每个子矩阵中四联通的大小规定。

首先要存下来大小规则，可以将输入看做三组，每组有五行，读入每组中的第 $x$ 行时根据 $x$的奇偶性判定读入几个字符。

字符读进来之后要进行一步转化方便使用。我们需要设一个四维数组 $f$，来存储大小关系。（可以像其他题解一样使用三维，但是~~四维无脑简单~~而且数据大小让我们可以任意搞）
   
   $f[x][y][u][v]$中存储了矩阵中$(x,y)$和$(u,v)$的大小关系。
   
   设二维数组 $a$ 存储最后的答案。
   
   当$f[x][y][u][v]=1$时，$a[x][y]$ 应该**小于** $a[u][v]$.

   当$f[x][y][u][v]=2$时，$a[x][y]$ 应该**大于** $a[u][v]$.

   当$f[x][y][u][v]=0$时，$a[x][y]$ 与 $a[u][v]$ 的大小关系没有约束。

存下来之后就要用了。前面说了要在DFS枚举取值时判断当前枚举的值是否可行。

因为是四联通直接有约束，所以要将当前位置的当前取值与其**左面和上面**的取值进行比较，若符合他们之间的大小条件则搜索下一个位置，否则继续枚举。

与**左面和上面**进行判断的原因很简单，我们的搜索是自左向右，自上向下的，到搜索到$(x,y)$时，其四联通中只有左面 $(x,y-1)$ 和上面 $(x-1,y)$ 已有取值。

还有一个细节，就是子矩阵也是按照自左向右，自上向下进行编号的。

###  **Before the Code**

其实一开始的写法会T一个点，开 $O_2$才能过，在写这篇题解的时候又进行了几次改进，不吸氧的情况下最慢的点大致稳定在680ms左右。~~（我不是要故意占用评测姬资源的！）~~


一些坐标之间的转化并没有放到正文中，因为怕影响阅读体验，在代码当中进行了注释。如果第一眼看不明白可以随机找一个坐标代入手算一下帮助理解。如果发现了此篇题解中的错误或者想要交流欢迎私信和评论。

**Enjoy the Code**
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
const int maxn=11;
const int dx[]={0,1,1,1,4,4,4,7,7,7};//每个子矩阵的第一行在大矩阵中的行号
const int dy[]={0,1,4,7,1,4,7,1,4,7};//每个子矩阵的第一列在大矩阵中的列号
const int ddx[]={0,-1};//left down 
const int ddy[]={-1,0};
int a[maxn][maxn];//存储答案矩阵
char w[50];
int f[maxn][maxn][maxn][maxn];//存储大小关系
int vis1[maxn][maxn],flag;//关系1需要的三个数组和已找到答案的标记
int vis2[maxn][maxn];//数组分别是：每行、每列、每个子矩阵
int vis3[maxn][maxn];
void dfs(int x,int y)
{
	if(x==9&&y==10)//搜索已结束
	{
		for(int i=1;i<=9;i++)//输出答案
		{
			for(int j=1;j<=9;j++)
			printf("%d ",a[i][j]);
			printf("\n");
		}
		flag=1;//状态标记为搜索完成
		return ;
	}
	
	if(y==10)//需要换行
	{
		x++,y=1;
	}
	
	for(int i=1;i<=9;i++)//枚举取值
	{
		bool po=0;//记录当前取值是否满足条件，若不满足则更改为1
		int pos=((x/3+(x%3!=0))-1)*3+(y/3+(y%3!=0));//(x,y)所在子矩阵编号 
		
		if(vis1[x][i]||vis2[y][i]||vis3[pos][i])//条件1 
		continue;
		for(int j=0;j<=1;j++)//与左面和上面进行判断 
		{
			int xx=x+ddx[j];
			int yy=y+ddy[j];
			
			if(f[x][y][xx][yy]==1)//(x,y) < (xx,yy) 
			{
				if(i>a[xx][yy])//不符合条件
				{
					po=1;
					break;
				}	
			}
			if(f[x][y][xx][yy]==2)//(x,y) > (xx,yy)
			{
				if(i<a[xx][yy])//不符合条件
				{
					po=1;
					break;
				}
			}
		}
		if(po==1)//不符合条件，继续枚举
		continue;
        //更改标记和当前位置取值
		vis1[x][i]=1;
		vis2[y][i]=1;
		vis3[pos][i]=1;
		a[x][y]=i;
        
		dfs(x,y+1);//搜索下一个位置
        
		if(flag)//已完成搜索，返回
		return ;
        //回溯
		a[x][y]=0;
		vis1[x][i]=0;
		vis2[y][i]=0;
		vis3[pos][i]=0;
	}
}
int main(){
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=5;j++)
		{
			if(j%2)//每组中的奇数行为左右关系，读入6个
			{
				for(int k=1;k<=6;k++)
					cin>>w[k];//cin可以不读入空格和回车
			}else
			{//每组中的偶数行为上下关系，读入9个
				for(int k=1;k<=9;k++)
				cin>>w[k];
			}
			int x,y;
            //左右关系时让x为当前所在行编号
            //上下关系时让x为下面一行的编号
            x=(i-1)*3+(j/2)+1;
			if(j%2)
			{
				//6 左右关系
				y=1;//列编号
				for(int k=1;k<=6;k++)
				{
					int p1,p2;
					if(w[k]=='>')
					p1=2,p2=1;
					else
					p1=1,p2=2;
					if(y==3||y==6)//同子矩阵中才有条件
					y++;
					f[x][y][x][y+1]=p1;
					f[x][y+1][x][y]=p2;
					y++;
				}
			}else
			{
				//9 上下关系
				for(int k=1;k<=9;k++)
				{
					int p1,p2;
					if(w[k]=='v')
					p1=2,p2=1;
					else
					p1=1,p2=2;
					f[x-1][k][x][k]=p1;
					f[x][k][x-1][k]=p2;
				}
			}
		}
	}
	dfs(1,1);
	return 0;
} 
```

### See Ya !

---

## 作者：pyqpyq (赞：1)

首先上[链接](https://www.luogu.com.cn/problem/P4573)

然后开始讲题

**注意：为了数学上的方便~~及省空间~~，整篇题解中所有数字（包括数独里的）均以 $0$ 开始计数。牢记！**
# 算法分析
在被[靶型数独](https://www.luogu.com.cn/problem/P1074)数独搞自闭后再来做这道题时被吓一跳。

冷静思考一下，发现靶型数独多给的是计分方式，而这题多出来的是约束条件。

（什么？靶型数独还给了你已知数？给了 $24$ 个已知数不还是把我卡到自闭……）

所以这题完全可以从上到下，从左到右依次枚举。

（好像讨论区有 $hack$ ？没加到 $lougu$ 数据里来不管了）

最终我们的策略是 $dfs$，每次 $dfs$ 枚举到 $x$ 行 $y$ 列，$dfs$ 开头时 `y++` ，若 $y$ 为 $9$ 了则换行，若 $x$ 也为 $9$ 了则输出答案。

当然也不能无脑枚举完后再判断解是否合法。我们应在枚举时就剪掉一些不合法的枝。

好的下面是伪代码：
```
void dfs(int x,int y)
{
	if(y==9){
		x++;
		if(x==9){
			for(int i=0;i<9;++i){
				for(int j=0;j<9;++j){
					putchar(ans[i][j]+'1');
					putchar(' ');
				}
				putchar('\n');
			}
			fla=1;//fla用于出解时及时退出
			return;
		}
		y=0;
	}
	for(int i=0;i<9&&!fla;++i){
		if(/*$1*/){
			//$2
			dfs(x,y+1);
			//$3
		}
	}
} 
```
`$` 的部分是用来判断合法性的，也是这篇题解的重点。
# 读入数据
由于我比较蒻所以我就把输入不做任何位置上的处理就放进了一个叫 $mor$ 的二维数组。

至于数值上的处理还是有的，只是把 '<' 和 'v' 换成 $0$，'>' 和 '^' 换成 $1$。

不过这里还要推一下第 $i$ 行的列数为 `((i%5)&1)*3+6`。

大致思路是：我们发现每行字符数其实是以 $6$ $9$ $6$ $9$ $6$ 每 $5$ 个数循环一次的，故有了 `i%5`。而这个循环节又是 $6$ $9$ 交替的，所以用 `&1` 取 `i%5` 的奇偶性，$0$ 为偶 $1$ 为奇。最后 `*3+6` 把 $0$ 和 $1$ 映射到 $6$ 和 $9$。

为什么会循环我待会讲。为什么是 $6$ 和 $9$ 呢？因为每行不是上下大于号（'^'、'v'）就是左右大于号（'<'、'>'），上下大于号每行 $9$ 个，左右大于号每行 $6$ 个。

放代码：
```
char c;
for(int i=0;i<15;++i){
	for(int j=0;j<((i%5)&1)*3+6;++j){
		do{
			c=getchar();
		}while(c!='<'&&c!='>'&&c!='^'&&c!='v');
		mor[i][j]=(c=='>'||c=='v');
	}
}
```
# 合法性判断
首先是常规的数独的部分，只要开个桶记录一下就行了。

注意九宫格的编号可以为 `x/3*3+y/3`，至于为什么可以类比三进制推导。

这下我们就可以得出 `$2` 和 `$3` 怎么写了：
```
$2:col[x][i]=row[y][i]=squ[x/3*3+y/3][ans[x][y]=i]=1;
$3:col[x][i]=row[y][i]=squ[x/3*3+y/3][ans[x][y]=i]=0;
```
$col$ 记录行，$row$ 记录列，$squ$ 记录九宫格，$ans$ 记录答案。

同时还可以得出 `$1` 的前半部分怎么写：
```
$1.1:!col[x][i]&&!row[y][i]&&!squ[x/3*3+y/3][i]
```
所以后半部分呢？
***
我们发现题目中给的条件还没用呢。

那我们怎么用呢？

我们到一个单元格，可以先判断它与它的上下左右单元格大小关系是否合法再填进去。

然而我们发现，用我们刚才看似无脑的枚举顺序，正好可以保证当前单元格的右边和下面为空（没有枚举过）！

也就是说我们完全可以只判断是否与上面的和左边的单元格的大小关系是否合法。

那最重要的是找到上面的符号和左边的符号的坐标。相邻的单元格的坐标就只需加减横纵坐标了。

我们一个一个来。
***
找上面的符号。

然而我们发现在 $x%3==0$ 时压根没上面的符号……

不等于呢？

观察可得符号的列数（在`mor`中，下同）就是当前单元格的行数。

符号的行数就麻烦一些。

我们发现其实在九宫格边界都没有符号。

那么整个数独就会被横向的九宫格节分成 $3$ 行。

每行九宫格的字符分布情况也基本是复制粘贴。

这就解释了上面每行的字符数为什么会循环。

并且也可以应用在此时此刻。

我们同样可以将单元格行数 `x%3` 再处理。

不过是求坐标。

所以还要加上 `x/3*5` 来补上被我们忽略过的数（分割后每块有 $5$ 行字符）。

故 `$1` 的下半部分的上半部分也出来了。
```
$1.2.1:&&(!(x%3)||(mor[x/3*5+x%3*2-1][y]^ans[x-1][y]<i))
```
我这里用了个异或运算符，你们可以手玩一下。而 `*2-1` 就是对模出来的数的处理。这个式子可以观察得出也可以自己手推。
***
~~胜利就在眼前了，同志们坚持住！~~

接下来我们来推左边的运算符的坐标。

同理可得在 $y%3==0$ 时没有左边的符号。

同时还很容易发现左边的运算符的行数就是上面的运算符的行数加 $1$。

所以这次麻烦在列数，因为这次的列数就不是简单地相等了。

我们还是可以分割数独，但是这次是以纵向的九宫格界分割。

这样每块有 $6\div3=2$ 列左右大于号。

于是我们就可以和上面一样处理了！

`$1` 的下半部分的上半部分就出来了：
```
$1.2.2:&&(!(y%3)||(mor[x/3*5+x%3*2][y/3*2+y%3-1]^ans[x][y-1]<i)
```
# 最后
至此我们集齐了所有代码，可以召唤~~神龙~~ $AC$ 了！

完整代码就不放了，把上面的代码合起来再缝补一下就行。

完整代码非常短，连 $1KB$ 都不到（应该是最短的了）。这就是数学公式的魅力。什么四维数组、检查可行性时开 $for$ 循环都不要了。

不过你其实会发现上面讲的东西完全可以用打表替代。

不过打表的话代码就不短了呀！

---

## 作者：Lily_White (赞：1)

**本题解参考了[Wu_Ren](https://www.luogu.org/space/show?uid=76039)神犇的思路，不过有更加详细的讲解**

其实这题比传统的数独题要好写。

因为题目中给的大小顺序，实际上限制了很多无用状态无法搜到，直接爆搜即可切了这题。

比较烦人的是读入和宫的处理。

下面的函数

$$f(x,y)=3\lfloor \frac{x-1}3 \rfloor + \lfloor\frac{y-1}3\rfloor+1$$

可以得出一个位置所处的宫。

事实上,

九个宫可以按照下面的方式编号

```plain
1 2 3
4 5 6
7 8 9
```

$3\lfloor\frac{x-1}{3}\rfloor$让位置移动到正确的**行**。$\lfloor \frac{y-1}3 \rfloor$让位置移动到正确的**列**，因为取整函数的原因最后需要$+1$来调节。

举$1$个简单的例子
$$f(7,8)=3\lfloor\frac{7-1}3\rfloor+\lfloor\frac{8-1}3\rfloor+1=3\times 2+2+1=9$$

读入需要分情况讨论。

注意到$15$行读入实际上相当于$3$组，每组有$5$行就可以了。

我们定义$lim[x_1][y_1][x_2][y_2]$为$(x_1,y_1)$和$(x_2,y_2)$之间的关系。若这个值为$1$则为$>$，否则为$<$。

读入时，利用上面的那个式子稍作更改就可以推出结果。

读入代码参考了上述dalao的思路：

```cpp
for (int i = 1; i <= 3; i++)
        for (int j = 1; j <= 5; j++)
        {
            if (j % 2 == 1)//odd number
                for (int k = 1; k <= 6; k++)
                {
                    char c;
                    cin >> c;
           //         cerr << c << endl;
                    if (c == '>')
                        lim[(i - 1) * 3 + (j - 1) / 2 + 1][(k - 1) / 2 * 3 + (k - 1) % 2 + 1]
                        [(i - 1) * 3 + (j - 1) / 2 + 1][(k - 1) / 2 * 3 + (k - 1) % 2 + 2] = true;
                }
            else
                for (int k = 1; k <= 9; k++)
                {
                    char c;
                    cin >> c;
                    if (c == 'v')
                        lim[(i - 1) * 3 + j / 2][k][(i - 1) * 3 + j / 2 + 1][k] = true;
                }
        }
```

接着，我们使用DFS解决本题，事实上只需要存储每行，每列，每宫是否重复就可通过，不必再加其他的优化。

```cpp
void dfs(int x, int y)
{
//	cerr << x << ' ' << y << endl;
    if (a[x][y])
    {
  //  	cerr << x << ' ' << y << endl;
        if (x == 9 && y == 9)//answer found!
        {
            for (int i = 1; i <= 9; i++)
            {
                for (int j = 1; j <= 9; j++)
                    cout << a[i][j] << ' ';
                cout << endl;
            }
            return;
        }
        else if (y == 9)//search the next row
            dfs(x + 1, 1);
        else dfs(x, y + 1);//search the next place
    }
    else
    {
        for (int i = 1; i <= 9; i++)
            if (!f[x][i] && !g[y][i] && !h[(x - 1) / 3 * 3 + (y - 1) / 3 + 1][i] && 
            (((a[x - 1][y] > i) == lim[x - 1][y][x][y]) || (x % 3 == 1)) && 
            (((a[x][y - 1] > i) == lim[x][y - 1][x][y]) || y % 3 == 1))
            {
                a[x][y] = i;
                f[x][i] = g[y][i] = h[(x - 1) / 3 * 3 + (y - 1) / 3 + 1][i] = true;
                dfs(x, y);//proceeding will be done in lines 17-19
                f[x][i] = g[y][i] = h[(x - 1) / 3 * 3 + (y - 1) / 3 + 1][i] = false;
                a[x][y] = 0;
            }
    }
}
```

---

## 作者：Jith_2004 (赞：1)

[P4573](https://www.luogu.org/problemnew/show/P4573)

乍一看题目，有点吓人。但如果利用好数独里数字的大小关系
~~（说的有些笼统）~~，我们就能按照普通数独的做法从左到右、从上到下依次填数，最后输出就OK了。

这里我开了个gg数组表示每个九宫格，这样表示行、列、宫就很容易了。

还有一点就是这题的输入要处理的比较麻烦，不过楼上的题解
里已经说的很清楚了。

参考代码如下（个人感觉还是比较好理解的）：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=9;
bool bl1[N+2][N+2],bl2[N+2][N+2],bl3[N+2][N+2]; //bl1表示行，bl2表示列，bl3表示宫
int kong[N+2][N+2];
char rel[N*2+2][N+2]; //存放那些大于号和小于号
int gg[N+2][N+2]={
    {0,0,0,0,0,0,0,0,0,0},
    {0,1,1,1,2,2,2,3,3,3},
    {0,1,1,1,2,2,2,3,3,3},
    {0,1,1,1,2,2,2,3,3,3},
    {0,4,4,4,5,5,5,6,6,6},
    {0,4,4,4,5,5,5,6,6,6},
    {0,4,4,4,5,5,5,6,6,6},
    {0,7,7,7,8,8,8,9,9,9},
    {0,7,7,7,8,8,8,9,9,9},
    {0,7,7,7,8,8,8,9,9,9}
};


void outit(){ //输出
    for(int i=1;i<=N;++i){
        for(int j=1;j<=N;++j) cout<<kong[i][j]<<" ";
        cout<<endl;
    }
}

void dfs(int r,int c,int d){
    if(d>N){ //如果每行都填完了，就是可行解，outit
        outit();
        exit(0);
    }
    for(int i=1;i<=N;++i){
        if(bl1[r][i] || bl2[c][i] || bl3[gg[r][c]][i]) continue; //判断此行、列、宫中有没有出现这个数字
        //下面两个判断语句是代码最核心的部分（写的有点晦涩）
        if(gg[r][c]==gg[r][c-1] && ((rel[r*2-1][c-1]=='<' && i<kong[r][c-1]) || (rel[r*2-1][c-1]=='>' && i>kong[r][c-1]))) continue; //判断与左右的大小关系是否有矛盾
        if(gg[r][c]==gg[r-1][c] && ((rel[(r-1)*2][c]=='^' && i<kong[r-1][c]) || (rel[(r-1)*2][c]=='v' && i>kong[r-1][c]))) continue; //判断与上下的大小关系是否有矛盾
        kong[r][c]=i; //填入数字
        bl1[r][i]=bl2[c][i]=bl3[gg[r][c]][i]=1;
        if(c==N) dfs(r+1,1,d+1); //如果填到该行最后一个数字，就从下一行的第一个继续填
        else dfs(r,c+1,d); //否则就往下一个空填
        kong[r][c]=0;
        bl1[r][i]=bl2[c][i]=bl3[gg[r][c]][i]=0; //回溯
    }
    return;
}

int main(){
    for(int i=1;i<N*2;++i){ //输入
        if(i&1){
            for(int j=1;j<N;++j){
                cin>>rel[i][j];
                if(!((j+1)%3)) ++j;
            }
        }
        else for(int j=1;j<=N;++j) cin>>rel[i][j];
        if(!((i+1)%6)) ++i;
    }
    for(int i=1;i<=N;++i){
        kong[1][1]=i;
        bl1[1][i]=bl2[1][i]=bl3[1][i]=1;
        dfs(1,2,1);
        kong[1][1]=0;
        bl1[1][i]=bl2[1][i]=bl3[1][i]=0;
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

大家都好强啊
我用了最愚蠢的DFS，用时1015ms，表示被daifucong吊起来打
好像我逃了唱歌来机房就做了这么一道题，就发个题解纪念下吧

SOL：暴力模拟。。。

```cpp
#include <bits/stdc++.h>
using namespace std;
char Maph[20][20], Mapl[20][20];
int ans[20][20];
bool hh[20][20], ll[20][20], gg[20][20];
inline void print()
{
	for(int i = 1; i <= 9; i++)
	{
		for(int j = 1; j <= 9; j++)
		printf("%d ", ans[i][j]);
		printf("\n");
	}
}
inline int calc(int x, int y)
{
	return ((x - 1) / 3) * 3 + ((y - 1) / 3 + 1);//这是计算当前在哪一格
}
inline void dfs(int x, int y)
{
	if (x == 10 && y == 1)
	{
		print();
		exit(0);
        //输出一组解就跑，我怕有多解
	}
	int aa = 0, bb = 0, aaa = -1, bbb = -1;
	if (x % 3 != 1)
	{
		aa = ans[x - 1][y];
		aaa = (Mapl[((x - 1) / 3) * 2 + (x % 3 == 0 ? 2 : 1)][y]) == '^' ? 1 : 2;
	}
	if (y % 3 != 1)
	{
		bb = ans[x][y - 1];
		bbb = (Maph[x][((y - 1) / 3) * 2 + (y % 3 == 0 ? 2 : 1)]) == '<' ? 1 : 2;
	}
    // aa记录上面那个数，aaa表示符号 1：>, 2: <
    // bb记录左边那个数，bbb同aaa
	int oo = calc(x, y);
	for(int i = 1; i <= 9; i++)
	{
		if (hh[x][i] || ll[y][i] || gg[oo][i]) continue;
		if (aa && ((aaa == 1 && i < aa) || (aaa == 2 && i > aa))) continue;
		if (bb && ((bbb == 1 && i < bb) || (bbb == 2 && i > bb))) continue;
        //暴力continue
		hh[x][i] = 1;
		ll[y][i] = 1;
		gg[oo][i] = 1;
		ans[x][y] = i;
		if (y == 9) dfs(x + 1, 1);
		else dfs(x, y + 1);
		hh[x][i] = 0;
		ll[y][i] = 0;
		gg[oo][i] = 0;
		ans[x][y] = 0;
	}
}
int main()
{
	memset(hh, 0, sizeof hh);
	memset(ll, 0, sizeof ll);
	memset(gg, 0, sizeof gg);
	memset(ans, 0, sizeof ans);
	for(int i = 1; i <= 6; i++)	cin >> Maph[1][i];
	for(int i = 1; i <= 9; i++)	cin >> Mapl[1][i];
	for(int i = 1; i <= 6; i++)	cin >> Maph[2][i];
	for(int i = 1; i <= 9; i++)	cin >> Mapl[2][i];
	for(int i = 1; i <= 6; i++)	cin >> Maph[3][i];
	for(int i = 1; i <= 6; i++)	cin >> Maph[4][i];
	for(int i = 1; i <= 9; i++)	cin >> Mapl[3][i];
	for(int i = 1; i <= 6; i++)	cin >> Maph[5][i];
	for(int i = 1; i <= 9; i++)	cin >> Mapl[4][i];
	for(int i = 1; i <= 6; i++)	cin >> Maph[6][i];
	for(int i = 1; i <= 6; i++)	cin >> Maph[7][i];
	for(int i = 1; i <= 9; i++)	cin >> Mapl[5][i];
	for(int i = 1; i <= 6; i++)	cin >> Maph[8][i];
	for(int i = 1; i <= 9; i++)	cin >> Mapl[6][i];
	for(int i = 1; i <= 6; i++)	cin >> Maph[9][i];
    //读入很恶心，不要看，
    //表示开始没看到读入之间有空格，用了scanf("%s")爽的飞起
	dfs(1, 1);
}
//over
```
求管理大大给过啊qwq

---


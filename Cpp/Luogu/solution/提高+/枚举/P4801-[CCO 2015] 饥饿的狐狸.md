# [CCO 2015] 饥饿的狐狸

## 题目描述

**本题译自 [CCO 2015](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2015/index.html) Day1 T1「[Hungry Fox](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2015/stage%202/day1.pdf)」**

到你的宠物狐狸的晚餐时间啦！他的晚餐包含 $N$ 块饼干，第 $i$ 块饼干的温度是 $T_i$ 摄氏度。同时，在晚餐中还包含了一大盘 $W$ 摄氏度的水。

在喝了一口水之后，你的狐狸开始吃饭了。每当他吃一块饼干时，这块饼干的美味度为当前饼干与吃/喝的前一样食物（包括饼干和水）的温度的差的绝对值。它可以在任意时间喝水（保证水喝不完），或按任意顺序吃饼干。

最后狐狸获得的美味值为它吃下的每块饼干的美味度之和。请求出狐狸获得的最小和最大的美味值。

## 说明/提示

要得到最小美味值，一种可行的方案是，狐狸先喝水，然后吃第一块饼干，再吃第三块饼干，接着喝水，最后吃下第二块饼干，这样做，它所感受到的温度分别为 $20,18,18,20,25$ 摄氏度，总的美味度为 $2+0+5=7$。

要得到最大美味值，一种可行的方案是，狐狸先喝水，然后按顺序吃饼干，它所感受到的温度分别为 $20,18,25,18$ 摄氏度，总的美味度为 $2+7+7=16$。

对于 $30\%$ 及以上的数据， $W=0$；  

对于 $100\%$ 的数据， $1\le N \le 100000, 0\le W \le 10^9, 0 \le T _ i \le 10 ^ 9$。

## 样例 #1

### 输入

```
3 20
18
25
18```

### 输出

```
7 16```

# 题解

## 作者：桃夭 (赞：74)

**这道题虽然没有用到什么很复杂的算法或数据结构，但是……**
# 坑点很多！
**PS:题解较长请耐心看完，讲的应该蛮详细了，至于中间一些吐槽……实在是因为做题过程中太辛酸了……如引起不适请忽略qwq**

**[更好的阅读体验请戳我QAQ](https://www.luogu.org/blog/lison-lql/solution-p4801)**

### 【容许我扯皮一点东西】
**我第一眼看过去，以为是一道贪心题，没有认真审题就三分钟交程序了……结果……**

![](https://cdn.luogu.com.cn/upload/pic/42911.png)

就**出事了**

找了半天才发现，并不是贪心题……漏看了一句话
![](https://cdn.luogu.com.cn/upload/pic/42912.png)

~~吃饭就吃饭嘛干嘛先喝水啊qwq什么坏习惯~~

明白不能贪心以后，就开始了艰苦卓绝的思考。

## 好，那么接下来进入正题：

首先，哎，很容易就可以得出最小~~肥宅~~美味值的情况，就是在考虑喝水的情况下按照饼干温度依次吃下去（我最喜欢这种贪心思想了），就可以求出最小值了。我们先对~~可爱的~~小狐狸要吃的饼干进行排序，然后开始遍历从w到各点的距离，记得**取绝对值！**

**我们可以画张图**
![](https://cdn.luogu.com.cn/upload/pic/42914.png)
（啊好丑啊qwq我尽力了相信我）
就是从w点出发依次遍历各点，得出最小值。

最小值解决完以后，就要解决~~恶心的~~最大美味值了……

最大值的求解方法有点类似于最优化问题，就是从温水~~煮青蛙~~开始，依次枚举左右，取能获取的最大美味值走，每次获得新状态前，**都与喝水的情况做比较**，取最优解，得出的答案即最大美味值。
## 然后又有一个要注意的地方了呢qwq

取得最小值的过程我之前想都不想就写了一个很朴素的函数来暴力求解。代码如下：
```cpp
long long GetMin()
{
	long long MIN=0;
	long long mid;
	long long now=w;
	for (int i=1;i<=n;++i)
	{
		if ((a[i]<=w)&&(a[i+1]>=w))
		{
			mid=i;
		}
		if (a[i]>=w)
		{
			MIN+=abs(a[i]-now);
			now=a[i];
		}
	}
	now=w;
	for (int i=mid;i>=1;--i)
	{
		MIN+=abs(a[i]-now);
		now=a[i];
	}
	return MIN;
}
```
然后就……

![](https://cdn.luogu.com.cn/upload/pic/42913.png)

后来又算来算去花了十分钟~~（其实花了一个多小时，我太弱了）~~

终于悟出最小值其实可以用$O(1)$的公式求解。代码如下：
```cpp
long long GetMin()
{
	return max((long long)0,w-a[1])+max((long long)0,a[n]-w);
}
```
啊，好短，然而确实是正确的。

之后就是一些细节处理了，**记得开long long**。

**上AC代码：**

# Code
```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n;
long long w;//不开long long就凉凉 
long long a[1000010];
long long read()//读入优化 
{
	char chr;
	long long f=1;
	while (((chr=getchar())<'0')||(chr>'9'))
	{
		if (chr=='-')
		{
			f=-1;
		}
	}
	long long ans=chr-'0';
	while (((chr=getchar())>='0')&&(chr<='9'))
	{
		ans=ans*10+chr-'0';
	}
	return ans*f;
}
long long GetMin()
{
	return max((long long)0,w-a[1])+max((long long)0,a[n]-w);//是不是很奇妙的式子qwq 
}
long long GetMax(int check)//check表方向 
{
	int l=1,r=n;
	long long MAX=0;
	long long now=w;
	for (int i=1;i<=n;++i)
	{
		if (i%2==check)
		{
			MAX+=max(abs(a[l]-now),abs(a[l]-w));//往左找，记得取绝对值 
			now=a[l];
			l++;	
		}
		else
		{
			MAX+=max(abs(a[r]-now),abs(a[r]-w));//往右找 
			now=a[r];
			r--;
		}
	}
	return MAX;
}
int main()
{
	cin>>n;
	w=read();
	for(int i=1;i<=n;++i)
	{
		a[i]=read();
	}
	sort(a+1,a+n+1);//排序 
	long long minn=GetMin();//取最小值 
	long long maxn=max(GetMax(0),GetMax(1));//0表示向左找，1表示向右找 
	cout<<minn<<" "<<maxn<<"\n";
	return 0;
}
```
**留个赞可好？qwq**

---

## 作者：greykid (赞：14)

（体验党看 [博客](//www.cnblogs.com/greyqz/p/9931552.html)）

贪心。

观察题目，我们不难发现，要得到最大美味值，狐狸应该先交错吃温度最大的和最小的饼干，其中如果能喝冰水或开水就更好了。所以我们给所有饼干按照温度排序，交替选择左右端点吃，如果先喝水再吃能获得更大美味值就更好啦。这样最大美味值就求出来啦。（注意左右端点谁先开始，可能得到两个答案，再取个 max。）

那么最小美味值呢？我们肯定按照温度顺序吃饼干。这样每两个饼干之间的差值就是美味度。比如我们记第 $i$ 个饼干和 $i-1$ 个饼干的差值为 $T_i-T_{i-1}$，则第 $i+1$ 个饼干和 $i$ 个饼干的差值为 $T_{i+1}-T_i$，我们容易得到：如果不喝水，差值即为 $T_n-T_1$。此时即可分类讨论：

(1) 如果水温度在 $[T_1,T_n]$ 之间，喝水与不喝水，对答案没有影响，答案就是 $T_n-T_1$。（想一想，为什么？）

(2) 如果水温度小于 $T_1$，我们又必须要喝水，答案再加上 $W-T_1$，即为 $T_n-W$。

(3) 同理如果水温大于 $T_n$，答案即为 $W-T_1$。

合并以上算式我们可以得到一句~~富有亲和力~~的算式 $\text{MinAns}=\max\{W-T_1,0\}+\max\{T_n-W,0\}$.

真漂亮啊……

以下是代码，已经无需赘言：

```cpp
/* [CCO2015] 饥饿的狐狸
 * Au: GG
 */
#include <cstdio>
#include <algorithm>
using namespace std;
#define ll long long
 
int n, w; ll d[100003], anl, anh1, anh2;
 
int main() {
    scanf("%d%d", &n, &w);
    for (int i=1; i<=n; ++i) scanf("%lld", &d[i]);
    sort(d+1, d+n+1);
    anl=max(0ll, w-d[1])+max(0ll, d[n]-w);
    ll las=w, l=1ll, r=n;
    for (int i=1; i<=n; ++i) {
        if (i&1) anh1+=max(abs(d[l]-w), abs(d[l]-las)), las=d[l++];
        else anh1+=max(abs(d[r]-w), abs(d[r]-las)), las=d[r--];
    }
    las=w, l=1ll, r=n;
    for (int i=1; i<=n; ++i) {
        if (i&1) anh2+=max(abs(d[r]-w), abs(d[r]-las)), las=d[r--];
        else anh2+=max(abs(d[l]-w), abs(d[l]-las)), las=d[l++];
    }
    printf("%lld %lld\n", anl, max(anh1, anh2));
    return 0;   
}
```

另外说一句，没必要滥用氧气优化，因为本题 真 没有省选难度……


---

## 作者：MoonCake2011 (赞：6)

这道题，怎么说呢，就是很水的绿题了。

# 求美味值 max

贪心思路就是我们可以每次选与此相差最大的饼干或水。

但是这是不正确的。

因为最后一个饼干它的美味值不用算。

所以我们需要求出最大值开始的美味值与最小值开始的美味值。

就可以完美求出。

# 求美味值 min

最小值可以对饼干依次吃下求得。

以此推出公式 `max(0,w-t[1])+max(0,t[n]-w)`。

直接 AC。

代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,w;
int t[100010];
int lst;
int ans,cnt1,cnt2;
signed main() {
	cin>>n>>w;
	lst=w;
	for(int i=1;i<=n;i++) cin>>t[i];
	sort(t+1,t+n+1);
	int l=1,r=n;
	for(int i=1;i<=n;i++)
		if(i&1) cnt1+=max(abs(t[l]-w),abs(t[l]-lst)),lst=t[l++];
		else cnt1+=max(abs(t[r]-w), abs(t[r]-lst)),lst=t[r--];
	l=1,r=n;
	for(int i=1;i<=n;i++)
		if((i&1)^1) cnt2+=max(abs(t[l]-w),abs(t[l]-lst)),lst=t[l++];
		else cnt2+=max(abs(t[r]-w), abs(t[r]-lst)),lst=t[r--];
	ans=max(cnt1,cnt2);
	cout<<max(0ll,w-t[1])+max(0ll,t[n]-w)<<" "<<ans<<"\n";
	return 0;
} 
```

---

## 作者：Shadow_T (赞：5)

## 大致思路
拿到题一看，就可以判断出算法为：贪心。

首先将数据排序，然后将分类讨论：

### 最大值

分别先从最小的开始拿和最大的开始拿，拿的时候将最大的和最小的捆绑在一起拿。然后将最小的开始拿和最大的开始拿得出的两个数据取最大。

### 最小值

根据贪心可以推出最优方案是先拿比水烫的吃，然后吃水，最后再吃比水凉的。相当于就是：

+ $w < t_1$，先喝水，然后按从 $t_1$ 到 $t_n$ 的顺序喝水，输出 $a_n-w$。

+ $w > t_1$，先喝水，然后按从 $t_n$ 到 $t_1$ 的顺序喝水，输出 $w-a_1$。

+ $t_1 \leq w \leq t_n$，先吃所有满足 $t_i \geq w$ 的，然后喝水，最后吃所有满足 $t_i \leq w$ 的，输出 $a_n-a_1$。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
long long a[10000001],w;
#define max(a,b) ((a)>(b)?(a):(b))
int n;
long long calc1()
{
	long long Max=labs(a[1]-w);
	int l=1,r=n;	 
	for(int i=1;i<n;i++)
	{
		if(i%2==1) Max+=max(a[r]-a[l],labs(a[r]-w)),l++; 
		else Max+=max(a[r]-a[l],labs(w-a[l])),r--;
	}
	return Max;
}
long long calc2()
{
	long long Max=labs(a[n]-w);
	int l=1,r=n;
	for(int i=1;i<n;i++)
	{
		if(i%2==1) Max+=max(a[r]-a[l],labs(w-a[l])),r--; 
		else Max+=max(a[r]-a[l],labs(a[r]-w)),l++;
	}
	return Max;
}
signed main()
{
	cin>>n>>w;
	for(int i=1;i<=n;i++)
	scanf("%lld",&a[i]);
	sort(a+1,a+n+1);
	if(w>a[n]) cout<<w-a[1];
	else if(w<a[1]) cout<<a[n]-w;
	else cout<<a[n]-a[1];
	cout<<" ";
	cout<<max(calc1(),calc2());
	return 0;
}
```

---

## 作者：wyl123ly (赞：3)

## 解题思路:

确实是一道很好的贪心，但由于加上了**水**这个影响因素，使题目复杂度上升了不少。（考虑的东西多了嘛）
1. 输个入。
2. 对饼干温度~~无脑~~排序。
3. 求最小值。
4. 求最大值（用双指针做，后面会讲）。

## 解题过程:

先输入（~~这个步骤就不用我讲了~~）
```cpp
int a[1000005];
    long long n,ws;
    long long minn=0,num=ws;
    cin>>n>>ws;//输入饼干数和水温
    for(int i=1;i<=n;i++)
        cin>>a[i];
```
 先排序！！
```cpp
sort(a+1,a+n+1);
```

 **最容易的肯定就是最小值**：
 
！其实**题意一定要读懂**，我个提醒也是我自己看错的：
> 每当他吃一块饼干时，**这块饼干**的美味度为当前饼干与吃/喝的前一样食物（包括饼干和水）的温度的差的绝对值。

------------
- 那我们不妨分**三种情况**来考虑（ws 是水温）：
1. 当水温小于等于饼干中温度的最小值，此时喝好水后，从饼干中最小值一直按顺序（单调升序，前面排好序了）吃到最大值 ($a_1,a_2\cdots a_n$) 就是累计美味值最小的。
```cpp
if(ws<=a[1]){
    minn=a[n]-ws;
}
```
2. 水温大于等于饼干中温度的最大值时，喝好水后，按单调降序 ($a_n,a_{n-1}\cdots a_1$) 吃掉饼干可获得最小值。则有：
```cpp
if(ws>=a[n]){
	minn=ws-a[1];
}
```
3. 当 $a_1\le ws\le a_n$ 时，直接 $a_n-a_1$ 即可：
```cpp
if(ws>=a[1]&&ws<=a[n]){
	minn=a[n]-a[1];
}
```
------------

 **那么接下来是最大值：**
 
 前面也提到了要用**双指针**做，具体怎么实现呢？
 
 先定义两个指针：
 ```cpp
t1=1;t2=n;
```
因为排好序后，$a_n-a_1$ 的跨度最大，然后 $a_1-a_{n-1}$，再是 $a_{n-1}-a_2\cdots$，以此类推，两个指针依次**向中间**靠拢，就可算出最大的美味值和了。

但是此时要考虑两点：
1. 喝好水后应该先吃 $a_n$ 还是 $a_1$。
2. 在双指针的过程中，判断是喝了水后吃下一个饼干的美味值大还是直接吃美味值大。

所以我们要循环两次，分别为先吃 $a_1$ 和先吃 $a_n$，并在过程中判断上面所说的第2点。

则有
```cpp
   long long num=ws;//存储上一个食物的温度
   long long ans2=0,ans=0;//分别分析取a[1]与a[n]为开头的情况(找最优解);
	ans+=abs(ws-a[t1]);
	num=a[t1];//从a[1]开始
	t1++;
	for(int i=2;i<=n;i++){
		if(i%2==0){
			ans+=max(abs(num-a[t2]),abs(ws-a[t2]));
			num=a[t2];
			t2--;
		}
		else{
			ans+=max(abs(num-a[t1]),abs(ws-a[t1]));
			num=a[t1];
			t1++;	
		}
	}
	t1=1;t2=n;//从a[n]开始
	ans2+=abs(ws-a[t2]);
	num=a[t2];
	t2--;
	for(int i=1;i<=n-1;i++){
		if(i%2==0){
			ans2+=max(abs(num-a[t2]),abs(ws-a[t2]));
			num=a[t2];
			t2--;
		}
		else{
			ans2+=max(abs(num-a[t1]),abs(ws-a[t1]));
			num=a[t1];
			t1++;
		}
	}
	ans=max(ans2,ans);//赋值最优解
```

到这里题就做完了，那——

 **AC 代码！**：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000005];
int main(){
	long long n,ws;
	cin>>n>>ws;//输入饼干数和水温
	long long minn=0,num=ws;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1);//排序！！！！
	long long cnt=1;
	long long t1=1,t2=n;
	if(ws<=a[1]){//判断最小值
    	minn=a[n]-ws;
	}
	else if(ws>=a[n]){
		minn=ws-a[1];
	}
	else{
		minn=a[n]-a[1];
	}
	long long ans2=0,ans=0;//判断最大值，分别分析取a[1]与a[n]为开头的情况(找最优解);
	ans+=abs(ws-a[t1]);
	num=a[t1];//存储上一个食物或水的温度
	t1++;
	for(int i=2;i<=n;i++){
		if(i%2==0){
			ans+=max(abs(num-a[t2]),abs(ws-a[t2]));
			num=a[t2];
			t2--;
		}
		else{
			ans+=max(abs(num-a[t1]),abs(ws-a[t1]));
			num=a[t1];
			t1++;	
		}
	}
	t1=1;t2=n;
	ans2+=abs(ws-a[t2]);
	num=a[t2];
	t2--;
	for(int i=1;i<=n-1;i++){
		if(i%2==0){
			ans2+=max(abs(num-a[t2]),abs(ws-a[t2]));
			num=a[t2];
			t2--;
		}
		else{
			ans2+=max(abs(num-a[t1]),abs(ws-a[t1]));
			num=a[t1];
			t1++;
		}
	}
	ans=max(ans2,ans);//取最优解
	cout<<minn<<" "<<ans;//华丽结束！
	return 0;
}
```



 







---

## 作者：Moon_Traveller (赞：3)

[>> 传送门 <<](https://www.luogu.com.cn/problem/P4801)

### 题目大意

有一只珂爱的小狐狸，它有 $N$ 块饼干和一盘喝不完的水。当然，饼干和水都有自身的温度，第 $i$ 块饼干的温度是 $T_i$，水的温度是 $W$。

小狐狸**先喝了一口水**，然后开始享用晚餐。它每吃掉一块饼干，就会获得一定的美味值（当前饼干与小狐狸上一次吃的食物的温度的差值）。

小狐狸可以以任意顺序吃饼干、喝水，现在它想知道它能获得的最小、最大美味值分别是多少。

### 思路

我们可以先把所有饼干的温度从小到大排序一下。（为什么？因为这样做之后，我们如果按顺序吃饼干，小狐狸获得的美味值就是最小的。）

但是别忘了，小狐狸有强迫症，必须先喝一口水，所以问题就复杂了起来。

#### 最小值

最小值很简单，分成三种情况即可，我简单画一下图（

- $W \lt t_1$，即水的温度比所有饼干的温度都低，`[]ooooo`。这时小狐狸可以喝一口水，再从小到大吃饼干，美味值就是 $t_N - W$。

- $W \gt t_N$，即水的温度比所有饼干的温度都低，`ooooo[]`。这时小狐狸可以喝一口水，再从大到小吃饼干，美味值就是 $W - t_1$。

- $t_1 \le W \le t_N$，即水的温度不冷不热，`oo[]ooo`。这时小狐狸可以先一口水，然后往左吃饼干，再喝一口水，然后往右吃饼干。因为喝水时不计算美味值，所以美味值就是 $t_N - t_1$。

#### 最大值

最大值要稍微复杂一些，但是也很好理解。因为要让美味值尽可能大，所以我们要让吃饼干的温度跨度尽可能大。比如说我有六块饼干，温度分别为 $1,2,3,4,5,6$，那么我可以按照 $1,6,2,5,3,4$ 的顺序吃，也可以按照 $6,1,5,2,4,3$ 的顺序吃。

显然，从第 $1$ 块开始吃和从第 $N$ 块开始吃，获得的美味值可能是不同的。那么我们就需要把两种情况都考虑到，然后取最大值。

### 代码

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
#define int long long // 不开longlong见祖宗

int n, w;
int t[100005];

int minn()
{
    if(w < t[1]) // 冷水情况
    {
        return t[n] - w;
    }
    if(w > t[n]) // 热水情况
    {
        return w - t[1];
    }
    else // 温水情况
    {
        return t[n] - t[1];
    }
}

int max1() // 从第一块开始吃
{
    int sum = 0;
    int now = w; // 要先喝一口水，所以把记忆温度设为水的温度
    int l = 1, r = n; // 以第一块为左端点，以最后一块为右端点，慢慢收拢
    for(int i = 1; i <= n; i++)
    {
        if(i & 1) // 这里相当于 if(i % 2 == 1)，目的是可以交替吃冰饼干和热饼干，让美味值尽可能大
        {
            sum += max(abs(t[l] - now), abs(t[l] - w)); // 先喝水再吃可能比直接吃的美味值更大，所以取最大值
            now = t[l]; // 吃了饼干，就记忆一下饼干的温度
            l++; // 吃完一个，换下一个
        }
        else
        {
            sum += max(abs(t[r] - now), abs(t[r] - w)); // 这里把 l 换成 r 就可以了
            now = t[r];
            r--; // r是减不是加
        }
    }
    return sum;
}

int maxn() // 从最后一块开始吃，把上面的反过来即可
{
    int sum = 0;
    int now = w;
    int l = 1, r = n;
    for(int i = 1; i <= n; i++)
    {
        if(i & 1)
        {
            sum += max(abs(t[r] - now), abs(t[r] - w));
            now = t[r];
            r--;
        }
        else
        {
            sum += max(abs(t[l] - now), abs(t[l] - w));
            now = t[l];
            l++;
        }
    }
    return sum;
}

signed main()
{
    cin >> n >> w;
    for(int i = 1; i <= n; i++)
    {
        cin >> t[i];
    }
    sort(t + 1, t + 1 + n); // 从小到大排序
    cout << minn() << ' ' << max(max1(), maxn()) << endl;
    return 0;
}
```

---

## 作者：Bpds1110 (赞：2)

[**Link**](https://www.luogu.com.cn/problem/P4801)
## Describe:
> 给定长度为 $n$ 的整数序列 $a$，表示每块饼干的温度，和一个整数 $W$，表示水的温度，水是无限的。狐狸每吃一块饼干，获得的美味值是这一块食物的温度和吃的上一块食物的温度的差的绝对值。现在，狐狸先喝一口水，它可以按任意顺序吃饼干或喝水。求出它所获得的的最大和最小的美味值。

## Solution:
#### 最小值：
考虑最小值。可以发现，最优情况下，是把相邻饼干的温度的差缩到最小。当从序列 $a$ 严格单调不减时，可以有以下几种策略。

- 当 $W < a_1$，则 $W$ 是最小的，我们可以在喝完水后，**从左往右**吃饼干，这样的美味值就是 $a_1 - w + \sum_{i = 2}^{n}  a_i - a_{i - 1}$，故此为 $a_n - W$。
- 当 $W > a_n$，则 $W$ 是最大的，我们可以在喝完水后，**从右往左**吃饼干，这样的美味值就是 $W - a_n + \sum_{i = 1}^{n - 1} a_{i + 1} - a_i$，故此为 $W - a_1$。
- 当 $a_1 \le W \le a_n$，说明 $W$ 不大不小，我们可以在喝完水后，先吃几块饼干，喝一口水，再吃完饼干。若存在 $i$ 和 $j$，使得 $i - j = 1$ 并且 $a_i \le W \le a_j$，那么，就在吃第 $i$ 块饼干和第 $j$ 块饼干中间，喝一口水，因为水是不计入美味值的，而 $a_j - W \le a_j - a_i$，可以缩小美味值，故此得出美味值为 $a_1 - W + \sum_{i = 2}^{j - 1} a_i - a_{i - 1} + a_j - W + \sum_{i = j + 1}^{n} a_i - a_{i - 1}$，即为 $a_n - a_1$。

#### 最大值：
考虑最大值。最优情况下，相邻两个温度相差最大即最大值。可是狐狸一开始必须喝温度为 $W$ 的水，于是可以分类讨论两种情况，分别是先吃温度低的，和先吃温度高的。最后求出最大即可。

## Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define max(x, y) (x > y ? x : y)
int n, w, a[100001];
int max1()//先吃温度低的 
{
	int l = 1, r = n, s = 0, flw = w;
	//最大值为a[1]，最小值为a[n] 
	for(int i = 1; i <= n; i ++)
	{
		if(i % 2 == 1)
		{
			s += max(abs(a[l] - w), abs(a[l] - flw));
			//当前喝水或不喝 
			flw = a[l ++];
		}
		else 
		{
			s += max(abs(a[r] - w), abs(a[r] - flw));
			flw = a[r --];
		}
	}
	return s;
}
int max2()//先吃温度高的 
{
	int l = 1, r = n, s = 0, flw = w;
	//最大值为a[1]，最小值为a[n] 
	for(int i = 1; i <= n; i ++)
	{
		if(i % 2 == 0)
		{
			s += max(abs(a[l] - w), abs(a[l] - flw));
			flw = a[l ++];
		}
		else 
		{
			s += max(abs(a[r] - w), abs(a[r] - flw));
			flw = a[r --];
		}
	}
	return s;
}
signed main()
{
	cin >> n >> w;
	for(int i = 1; i <= n; i ++)
		cin >> a[i];
	sort(a + 1, a + 1 + n);
	if(w < a[1]) cout << a[n] - w << " ";
	else if(w > a[n]) cout << w - a[1] << " ";
	else if(a[1] <= w && w <= a[n])cout << a[n] - a[1] << " ";
	cout << max(max1(), max2());//求出两种情况最大值 
	return 0;
}

```


---

## 作者：信息向阳花木 (赞：1)

~~我第一眼看到感觉是贪心，一看是紫题，就立马怀疑人生想到 dp，然后发现我想多了~~

很显然，需要现将饼干的温度排序。

我们先考虑 **最小值**：

顺着温度吃就对啦，但饭前要喝水哦，所以细节要讨论一下。

* 当 $t_n < w$ 时，狐狸先喝一口水，然后按饼干温度从大往小吃，$ans = (w - t_n) + (t_n - t_{n - 1}) + ... + (t_2 - t_2) = w - t_1$。

* 当 $t_1 > w$ 时，狐狸先喝一口水，然后按饼干温度从小往大吃，$ans = (t_1 - w) + (t_2 - t_1) + ... + (t_n - t_{n - 1}) = t_n - w$。

* 如果都不是，狐狸先喝一口水，然后往前吃，再喝一口水，然后往后吃，$ans = t_n - t_1$

然后我们考虑 **最大值**：

狐狸喝完水后热的和冷的换着吃，让差值最大。例如先吃 $t_n$ 和 $t_1$，再吃 $t_{n-1}$ 和 $t_2$（或中间喝一口水）……但吃的顺序需要注意，我们要枚举一下先吃 $t_1$ 还是 $t_n$。

代码：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

#define int long long 

const int N = 100010;

inline void in(int &x)
{
	x = 0; bool f = 0; char c = getchar();
	while(c < '0' || c > '9')
	{
		if(c == '-') f = 1;
		c = getchar();
	}
	while(c >= '0' && c <= '9')
	{
		x = (x << 3) + (x << 1) + (c & 15);
		c = getchar();
	}
	x = f ? -x : x;
}

inline void out(int x)
{
	if(x < 0) putchar('-'), x = -x;
	if(x / 10) out(x / 10);
	putchar((x % 10) | 48);
}

int n, w; 
int t[N];

signed main()
{
	in(n); in(w);
	for (int i = 1; i <= n; i ++ ) in(t[i]);
	
	sort(t + 1, t + n + 1);	
	
	if(t[1] > w) printf("%lld ", t[n] - w);
	else if(t[n] < w) printf("%lld ", w - t[1]);
	else printf("%lld ", t[n] - t[1]);
	//最小值
	
	int res = abs(w - t[n]), ans = abs(w - t[1]);
	for (int i = 1, j = n - 1; i <= j; ) //先吃 t[n]
	{
		res += max(t[j + 1] - t[i], abs(t[i] - w));
		i ++;
		if(i <= j)
		{
			res += max(t[j] - t[i - 1], abs(t[j] - w));
			j --;
		}
	}
	
	for (int i = 2, j = n; i <= j; ) //先吃 t[1]
	{
		ans += max(t[j] - t[i - 1], abs(t[j] - w));
		j --;
		if(i <= j)
		{
			ans += max(t[j + 1] - t[i], abs(t[i] - w));
			i ++;
		}
	}
	printf("%lld\n", max(ans, res));
	
	return 0;
}

```

---

## 作者：Silence_World (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P4801)

### 思路

本题思路主要为**贪心**，题中告诉我们要找最小值和最大值，首先能想到的就是排序。

我们先从最小值入手。由题可得，必然要先喝水，然后对序列与 $w$ 的大小进行分类讨论：

- 当 $w$ 比 $a_1$ 小，说明狐狸要从小往大吃，那显然易见最小的就是 $a_n-w$。

- 当 $w$ 比 $a_n$ 大，说明狐狸要从大往小吃，那最小就为  $w-a_1$。

- 如果都不是，我们就先往前吃，吃完后再喝口水，然后再往后吃，这样明显美味值最小（~~读者自证不难~~）。所以对于每个 $i$，从 $a_{i-1}$ 至 $a_1$ 和 $a_{i+1}$ 至 $a_n$ 共要用 $a_n-a_1$。

综上所述，其实最小值转换到数轴上也就是最小覆盖区间，相应的，最大值就是最大覆盖区间。

既然最小值整理完了，我们再看最大值，最大值必然是先吃 $a_1$ 或 $a_n$，吃完之后吃另一个，使之跨度最大。以此类推，下一个是与第一个选择的距离更远的 $a_2$ 或 $a_{n-1}$。我们并不知道第一次选择的，所以要把第一次的两种选择都跑一遍，然后取最大值即可。

~~我绝对不会告诉你我因为没加绝对值挂了好几次的。~~
 
### AC 代码

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[100005];
int min1=1000005;
signed  main(){
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int n,w;
	cin>>n>>w;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1);
	if(w<a[1]){
		cout<<a[n]-w<<" ";
	}
	else if(w>a[n]){
		cout<<w-a[1]<<" ";
	}
	else{
		cout<<a[n]-a[1]<<" ";
	}
	int ans=abs(w-a[1]);
	int r=n;
	int l=1;
	for(int i=1;i<n;i++){
		if((i-1)%2==0){
			ans+=max(a[r]-a[l],abs(a[r]-w));
			l++;
		}
		else{
			ans+=max(a[r]-a[l],abs(w-a[l]));
			r--;
		}
	}
	r=n;
	l=1;
	int sum=abs(a[n]-w);
	for(int i=1;i<n;i++){
		if((i-1)%2==1){
			sum+=max(a[r]-a[l],abs(a[r]-w));
			l++;
		}
		else{
			sum+=max(a[r]-a[l],abs(w-a[l]));
			r--;
		}
	}
	cout<<max(ans,sum);
} 
```

---

## 作者：Endt (赞：1)

# 饥饿的狐狸-题解

这是一道贪心题，有一些难想。

美味值最大，排序之后不断最小、最大依次拿，但有可能喝水会更有价值。分从最小开始拿和最大开始拿的情况。

美味值最小，分情况：
- 水小于最小值，从小拿到大。
- 水大于最大值，从大拿到小。
- 水在中间，从水拿到小，再从水拿到大。

---

先给出代码：

```cpp
#include<bits/stdc++.h>

#define  Int  long long int

#define  Max(a,b)  ((a)>(b)?(a):(b))
#define  Min(a,b)  ((a)<(b)?(a):(b))
#define  Abs(a)  ((a)>0?(a):-(a))

int n;
Int w,t[100005];
Int ans0,ans1,ans2;
int main(){
    scanf("%d",&n);
    scanf("%lld",&w);
    for(int i=1;i<=n;++i)scanf("%lld",&t[i]);
    std::sort(t+1,t+1+n);
    
    ans0+=t[n]-t[1];
    if(w<t[1])ans0+=t[1]-w;
    if(w>t[n])ans0+=w-t[n];
    
    ans1=Abs(t[1]-w);
    for(int i=1,j=n,cnt=1;cnt<n;++cnt){
        if(cnt%2==1){
            ans1+=Max(Abs(t[j]-t[i]),Abs(t[j]-w));
            ++i;
        }else{
            ans1+=Max(Abs(t[i]-t[j]),Abs(t[i]-w));
            --j;
        }
    }
    printf("%lld ",ans0);
    ans2=Abs(t[n]-w);
    for(int i=1,j=n,cnt=1;cnt<n;++cnt){
        if(cnt%2==0){
            ans2+=Max(Abs(t[j]-t[i]),Abs(t[j]-w));
            ++i;
        }else{
            ans2+=Max(Abs(t[i]-t[j]),Abs(t[i]-w));
            --j;
        }
    }
    printf("%lld ",Max(ans1,ans2));
    
    return 0;
}
```

---

### 正确性阐释

需要美味值最大，那么选择离当前温度（或水温）差距最大的食物。若不这样做，通过其他食物再到达那一个食物，温度差显然更小，无法做出更大的贡献。

需要美味值最小，同理选择离当前温度最小的食物，顺着选是最优的。

---

## 作者：Kobe303 (赞：1)

分类讨论+贪心。

设 $mn,mx$ 分别表示要求的最大值，最小值。

先将 $T$ 按从小到大排序。

先考虑最小值，显然手玩一下发现有三种情况。

1. $W\le a_1$，此时 $mn=a_n-w$。
2. $a_1\le W\le a_n$，此时 $mn=a_n-a_1$。
3. $W\gt a_n$，此时 $mn=W-a_1$。

然后考虑最大值，显然我们要大的和小的交错吃，可能喝一口水再吃更优，所以取个 $\max$。

然后第一口吃的是最大的还是最小的不固定，所以应该两个都做一遍，再取 $\max$。

Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 100005;
int n, w;
int a[N];
ll mx, mn;

int main() {
	scanf("%d%d", &n, &w);
	for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
	sort(a + 1, a + n + 1);
	if (w <= a[1]) mn = a[n] - w;
	else if (w <= a[n]) mn = a[n] - a[1];
	else mn = w - a[1];
	int l = 1, r = n; 
	ll mx1 = 0, mx2 = 0; 
	mx1 += a[r] - w;
	--r;
	while (l < r) {
		mx1 += max(abs(w - a[l]), abs(a[r + 1] - a[l]));
		mx1 += max(abs(a[r] - w), abs(a[r] - a[l]));
		++l, --r;
	}
	if (l == r) mx1 += max(abs(w - a[l]), abs(a[l + 1] - a[l]));
	l = 1, r = n;
	mx2 += w - a[l];
	++l;
	while (l < r) {
		mx2 += max(abs(a[r] - w), abs(a[r] - a[l - 1]));
		mx2 += max(abs(w - a[l]), abs(a[r] - a[l]));
		++l, --r;
	}
	if (l == r) mx2 += max(abs(w - a[l]), abs(a[l - 1] - a[l]));
	mx = max(mx1, mx2);
	printf("%lld %lld", mn, mx);
	return 0;
}
```


---

## 作者：tangqqq (赞：1)

# P4801 饥饿的狐狸题解
一道贪心题。

先来研究最小美味值的情况，其实就是在喝了水的情况下，按从温度大到小的顺序吃饼干，再思考一下其实就可以推出这个式子：$a_{n}-a_{1}$。

接下来再考虑 $W$，如果 $W$ 在 $[a_{1},a_{n}]$ 范围那么结果不变。

如果 $W$ 大于 $a_{n}$，那么就是 $W-a_{1}$。

如果 $W$ 小于 $a_{1}$，那么就是 $a_n-W$，结合一下即可以得出代码。
```cpp
cout<<max(w-a[1],(long long)0)+max(a[n]-w,(long long)0)<<" ";
```

最大值其实就是先喝水，然后从左边和右边搜，取最大值。
## AC 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define db double
using namespace std;
ll n,a[100010],ans=0,w,p=0,t,l=1,r;
bool b=0;
int main(){
	cin>>n>>w;
	r=n;
	t=w;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+1+n);
   //处理最小值
	cout<<max(w-a[1],(long long)0)+max(a[n]-w,(long long)0)<<" ";
    
   //处理最大值
   //往右搜
	for(int i=1;i<=n;i++){
		if(i&1){
			ans=ans+max(abs(a[r]-t),abs(a[r]-w));
			t=a[r];
			r--;
		}else{
			ans=ans+max(abs(a[l]-t),abs(a[l]-w));
			t=a[l];
			l++;
		}	
	}
   //记得初始化
	l=1;
	r=n;
	t=w;
   //往左搜
	for(int i=1;i<=n;i++){
		if(i&1){
			p=p+max(abs(a[l]-t),abs(a[l]-w));
			t=a[l];
			l++;
		}else{
			p=p+max(abs(a[r]-t),abs(a[r]-w));
			t=a[r];
			r--;
		}
	}
	cout<<max(ans,p);
	return 0;
}
```

---

## 作者：lizhous (赞：1)

[洛谷传送门](https://www.luogu.com.cn/problem/P4801)

~~这怎么能评紫呢~~

## 分析
这道题我们要最大值和最小值分开考虑。首先排序。
### 最大值
我们把问题移到数轴上，则问题转化为要覆盖最大的区间长度。  
显然我们要在未选择的数中选出与上次选择的数差的绝对值最大的数。贪心的想，开始点必然为 $1$ 或 $n$。分情况计算并取较大的一个即可。注意和喝水后再吃的情况比较一下，择优。
### 最小值
我们把问题移到数轴上，则问题转化为要覆盖最小的区间长度。  
由于喝水不计答案，所以我们先把比水烫的吃了，再喝水，最后把比水凉的吃了。

具体可以见代码。
```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<algorithm>
#define int long long
#define abs(a) max(a,-a)
using namespace std;
int n, w, a[1000001], ma, ma2, mi, mi2, l, r, mn, las;
signed main() {
	scanf("%lld%lld", &n, &w);
	for (int i = 1; i <= n; i++) {
		scanf("%lld", &a[i]);
	}
	sort(a + 1, a + n + 1); //排序
    //最大值
	l = 1; //左侧初始化
	r = n; //右侧初始化
	las = w; //上次取
	for (int i = 1; i <= n; i++) { //从左开始
		if (i & 1) { //奇数
			ma += max(abs((a[l] - w)), abs((a[l] - las))); //取左边，与喝水比较
			las = a[l++]; //记录上一次
		} else {
			ma += max(abs((a[r] - w)), abs((a[r] - las))); //取右边，与喝水比较
			las = a[r--];
		}
	}
	l = 1; 
	r = n;
	las = w;
	for (int i = 1; i <= n; i++) {  //从右开始
		if (i & 1) {
			ma2 += max(abs((a[r] - w)), abs((a[r] - las)));
			las = a[r--];
		} else {
			ma2 += max(abs((a[l] - w)), abs((a[l] - las)));
			las = a[l++];
		}
	}
    //最小值
	las = w; //初始化
	for (int i = 1; i <= n; i++) {
		if (a[i] >= w) { //处理烫的部分
			mi += abs((a[i] - las));
			las = a[i];
		}
	}
	las = w;
	for (int i = n; i >= 1; i--) {
		if (a[i] < w) { //处理凉的
			mi += abs((a[i] - las));
			las = a[i];
		}
	}
	printf("%lld %lld", mi, max(ma, ma2)); //两个ma取max
}
```


---

## 作者：watergod (赞：1)

## P4801 饥饿的狐狸 题解

[题目传送](https://www.luogu.com.cn/problem/P4801)

看了有些题解，感觉对题目的分析和代码的解释不是很清晰，本蒟蒻详细地解释一下

~~这题是我遇到的第二道水紫~~，贪心

### **主要思路：**

题目求最大值和最小值，挨个分析就可以了。

但是要注意提前喝了一口水。

在输入的时候直接排序，方便进行比较。

然后这里有一个公式 比如说从 $1-5$ 之间 温度差就是：

$a_2-a_1+a_3-a_2+a_4-a_3+a_5-a_4$ = $a_5 - a_1$

**P1 最小值**

- 情况1：当 $w>a_n$ 时 也就是 $w$ 比所有温度都要大，这个时候从大到小吃，这里值为 $w-a_1$。

- 情况2：当 $w<a_1$ 时 也就是 $w$ 比所有温度都要小 这个时候就顺着吃就可以了，按照上面的公式这里应该求值就为 $a_n-w$。

- 情况3：$a_1<w<a_n$ 这种情况就像插入排序，把 $w$ 插入到符合它顺序的位置，这个时候值就是 $a_n-a_1$。

直接输出就可以了，记得后面带个空格。

------------

**P2 最大值**

最大值不难看出，要让差永远最大，蛇形吃。

也就是分为两种情况：

- 情况1：从 $a_1$ 开始吃，就是按照 $a_1$ - $a_n$ - $a_2$ - $a_{n-1}$ 依次类推。

- 情况2：从 $a_n$ 开始吃，就是按照上面的情况反过来吃，使绝对值最大就可以了。

最后取这两种情况的美味度的最大值。

这里为了方便每一次操作，设置一个头指针，一个尾指针。

接下来分析两种情况

- 从 $a_1$ 开始吃：这里我用 $ans1$ 变量来表示最大的绝对值。刚开始这个值肯定要设为 $w-a_1$ 的绝对值作为初始值。

  接下来使用循环遍历：如果这个**操作次数为奇数**的话，这个时候要比较**尾指针与头指针的差**和**水温度与头指针的差**。那么就是在从温度小的转入温度大的 这个时候要从温度大的转入下一个温度小的 就应该让头指针加1.
  
  如果这个**操作次数为偶数**的话，这个时候要比较**尾指针与头指针的差**和**尾指针与水温度的差**。同理，是在从温度大的转入温度小的，这个时候马上要进行的操作就是从温度小的转入温度大的，应该让尾指针减1.
  
- 从 $a_n$ 开始吃：这里我用 $ansn$ 变量来表示最大的绝对值。刚开始这个值要设为 $w-a_n$ 的绝对值。

  接下来还是循环遍历：如果这个**操作次数为奇数**的话：比较**尾指针与头指针的差**和**水温度与头指针的差**。也就是从温度大的转换成温度小的，同上面，应该让尾指针减一
  
  如果这个**操作次数为偶数的话**，比较**尾指针与头指针的差**和**尾指针与水温度的差**。这里不做说明，头指针加一。
 
   
### Code：
```cpp
#include<bits/stdc++.h>
using namespace std;

long long a[10000001];
long long n,w; 

int main(){
	cin >> n >> w;
	for(long long i=1;i<=n;i++){
		cin >> a[i];
	}
	sort(a+1,a+n+1);
	// 判断最小值 
	if(w>a[n]){
		cout << w-a[1] << " ";
	}else if(w<a[1]){
		cout << a[n]-w << " ";
	}else{
		cout << a[n]-a[1] << " ";
	}
	// 判断最大值
	// 情况1:从a1开始 
	long long max_1 = abs(a[1]-w);
	long long start=1,end=n;	 
	for(long long i=1;i<n;i++){
		if(i%2 == 1){
			max_1 += max(a[end]-a[start],abs(a[end]-w));
			start++; 
		}else{
			max_1 += max(a[end]-a[start],abs(w-a[start]));
			end--;
		}
	}
	// 情况2:从an开始
	long long max_n = abs(a[n] - w);
	start = 1;
	end = n;
	for(long long i=1;i<n;i++){
		if(i%2 == 1){
			max_n += max(a[end]-a[start],abs(w-a[start]));
			end--; 
		}else{
			max_n += max(a[end]-a[start],abs(a[end]-w));
			start++;
		}
	}
	cout << max(max_1,max_n);
	return 0;
}
```

[AC记录](https://www.luogu.com.cn/record/111789208)

---

## 作者：lovely_hyzhuo (赞：0)

建议降绿/黄。

这道题目看上去挺难的，因为如果吃东西前不喝水就是特别简单的贪心了。

首先对于全部水温排序，然后最小值直接 $a_n-a_1$，最大值模拟去求就行了。

但如果加上水呢？

## 1.最小值

最小值比较简单，分类讨论。

1.假如水温 $W$ 比较大，甚至比 $a_n$ 还大，那么就直接让狐狸先喝水，喝完吃最大温度的饼干，答案就是 $W-a_1$。

2.假如水温 $W$ 比较小，甚至比 $a_1$ 还小，那么就直接让狐狸先喝水，喝完吃最小温度的饼干，答案就是 $a_n-W$。

3.第三种情况就是 $W$ 刚好在最大和最小之间，那么就让狐狸先喝水，然后从左到右吃，吃到下一个饼干比水温度大为止，再喝水，直到吃完，答案就是 $a_n-a_1$。

## 2.最大值

先吃温度大的饼干和先吃温度小的饼干都有可能成为最优解，所以都模拟做一遍，取最大值。

## 3.注意事项

一定要开 long long，不然就是 $68$ 分。

## 4.AC 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[100010];
signed main()
{
	int n,W;
	cin>>n>>W;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	sort(a+1,a+n+1);//从小到大排序 
	if(W<=a[1])
		cout<<a[n]-W;//当水温特别低时，把与它跨度低的a[1]放到前面吃，然后按顺序吃，中间的美味值全部抵消，最后剩a[n]-W。 
	else if(W>=a[n])
		cout<<W-a[1];////当水温特别高时，把与它跨度低的a[n]放到前面吃，然后按顺序吃，中间的美味值全部抵消，最后剩W-a[1]。 
	else if(W<a[n]&&W>a[1])
		cout<<a[n]-a[1];//相当于将水温当做饼干也放进饼干里面，其他同上 
	cout<<" ";
	int ans1=0,ans2=0;
	int l=1,r=n;
	int now=W;
	for(int i=1;i<=n;i++)
	{
		if(i%2==1)//为了交替吃冷热饼干 
		{
			ans1+=max(abs(a[l]-now),abs(a[l]-W));//喝水或者直接吃都有可能更加美味，所以取最大值
			now=a[l];
			l++;
		}
		if(i%2==0)//为了交替吃冷热饼干 
		{
			ans1+=max(abs(a[r]-now),abs(a[r]-W));//喝水或者直接吃都有可能更加美味，所以取最大值
			now=a[r];
			r--;
		}
	}
	l=1,r=n;
	now=W;
	for(int i=1;i<=n;i++)
	{
		if(i%2==0)//为了交替吃冷热饼干 
		{
			ans2+=max(abs(a[l]-now),abs(a[l]-W));//喝水或者直接吃都有可能更加美味，所以取最大值
			now=a[l];
			l++;
		}
		if(i%2==1)//为了交替吃冷热饼干 
		{
			ans2+=max(abs(a[r]-now),abs(a[r]-W));//喝水或者直接吃都有可能更加美味，所以取最大值
			now=a[r];
			r--;
		}
	}
	cout<<max(ans1,ans2);
	return 0;
}
```


---

## 作者：Mx_sky (赞：0)

蒟蒻第一篇紫题题解~

## 思路

一眼贪心，自然是要先排序。

什么好想先想哪个，显然，最大值更好想，分两种情况讨论：
- 美味值小的排在前，美味值大的排在后。
- 美味值大的排在前，美味值小的排在后。

但总的思路是不变的，将最小和最大绑在一起。

接下来最小值稍微难一点：显然，如果想要美味值最小，则顺着吃是最优的，分三类讨论：
- $w<t_1$，从小到大顺着吃，美味值就是 $t_n-w$。
- $w>t_n$，从大到小顺着吃，美味值就是 $w-t_1$。
- $w$ 在 $t_1\sim t_n$ 之间，从小到大和从大到小都无所谓，美味值是 $t_n-t_1$。

注意 long long！！！

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[100005],w;
long long plan1()  //方案1 
{
	long long ans=abs(a[1]-w),x=1,y=n;
	for(int i=2;i<=n;i++)   //先小后大 
	{
		if(i%2==0) ans+=max(a[y]-a[x],abs(a[y]-w)),x++;  //看看是直接吃更优还是中途喝水更优    
		else ans+=max(a[y]-a[x],abs(w-a[x])),y--;  //同上 
	}
	return ans;
}
long long plan2()  //方案2 
{
	long long ans=abs(a[n]-w),x=1,y=n;
	for(int i=2;i<=n;i++)   //先大后小 
	{
		if(i%2==0) ans+=max(a[y]-a[x],abs(w-a[x])),y--;   //同plan1 
		else ans+=max(a[y]-a[x],abs(a[y]-w)),x++;
	}
	return ans;
}
int main(){
	cin>>n>>w;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+1+n);  //排序 
	if(w<a[1]) cout<<a[n]-w;
	else if(w>a[n]) cout<<w-a[1];
	else cout<<a[n]-a[1];
	//最小值 
	cout<<" "<<max(plan1(),plan2())<<endl;
	//最大值 
    return 0;
}
```


---

## 作者：Llx2022 (赞：0)

**这是个贪心套路题,但是非常有趣呢！**
# **Description**
**~~这小狐狸真是太能吃了，100000个饼干外加无限量水~~**，**因此**狐狸已经告诉我们了它的需求，我们可以通过调整它的就餐顺序，让我们求吃的最大美味值最小美味值。
# **Solution**
**~~小狐狸吃饭必须要先喝水。~~**


我们其实要求的就是 $\sum_{i=1}^n |a_i-last_i|$，其中 $last_1=w$,$last_i=|a_{i-1}-last_{i-1}|$ 或者 $w$。

**最大值**：显然我们可以每次可以通过，先吃最大，再吃最小，依次操作直到没有为止，这是由于我们的初始值 $last=w$ 所以我们第一次可能是吃 $a_n$ 或者吃 $a_1$，这是由于 $w$ 的大小决定的，因此需执行两次该操作即可。

**最小值**：这个就非常有趣了，因为要想求上式的最小值，我们肯定是想让这个式子展开剩余的项最小，因此我们发现，如果先不考虑喝水，通过考虑首项绝对值指向的实际数值 $|a_i-last_i|$，有两种结果 $a_i-last_i$ 或者  $last_i-a_i$ 因此有如下三种可能。




- 若 $w$ $\in$ $[a_1,a_n]$ 则结果为 $a_n-a_1$


- 若 $w$ $<$ $a_1$ 则结果为 $a_n-w$


- 若 $w$ $>$ $a_n$ 则结果为 $w-a_1$

# **Code**
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int N=1e5+9;
int a[N];
long long ans=0;
int main(){
	int n,k;
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1);
	cout<<max(k-a[1],0)+max(a[n]-k,0)<<" ";
	ans=abs(k-a[1]); 
	int l=1,r=n;
	for(int i=0;i<n-1;i++){
		if(i%2==0){ans+=max(a[r]-a[l],abs(a[r]-k));l++;}
		else{ans+=max(a[r]-a[l],abs(k-a[l]));r--;}
	}
	l=1,r=n;
	long long ans2=abs(a[n]-k);
	for(int i=0;i<n-1;i++){
		if(i%2==1){ans2+=max(a[r]-a[l],abs(a[r]-k));l++;}
		else{ans2+=max(a[r]-a[l],abs(k-a[l]));r--;}
	}
	cout<<max(ans,ans2);
	return 0;
}
```


---

## 作者：MCAdam (赞：0)

[P4801 [CCO 2015]饥饿的狐狸](https://www.luogu.com.cn/problem/P4801)

挺好的一道贪心题。

注意水的作用，只有吃饼干才能加美味度。

最小的情况比较显然：就是找到饼干以水的分界线，然后两部分独立开来就行（因为中间可以喝水缓冲，所以相当于独立开来）。

最大的情况：就是排序后从一头一尾反复横跳就行了，注意横跳不一定有喝水优，所以再取个$\max$。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#define ll long long
using namespace std;
const int N=1e5+10;
int v[N];
int main()
{
	int n,w,p,q,opt; ll s1=0,s2=0,s3=0;
	scanf("%d%d",&n,&w);
	for(int i=1;i<=n;i++)
		scanf("%d",&v[i]);
	sort(v+1,v+n+1);
	int pos=lower_bound(v+1,v+n+1,w)-v;
	for(int i=pos;i<=n;i++)
	{
		if(i==pos) s1+=v[i]-w;
		else s1+=v[i]-v[i-1];
	}
	for(int i=pos-1;i>=1;i--)
	{
		if(i==pos-1) s1+=w-v[i];
		else s1+=v[i+1]-v[i];
	}
	printf("%lld ",s1);
	p=n,q=1,opt=0;
	s2+=abs(w-v[1]);
	for(int i=1;i<n;i++)
	{
		if(opt) s2+=max(v[p]-v[q],abs(w-v[q])),p--,opt=0;
		else s2+=max(v[p]-v[q],abs(v[p]-w)),q++,opt=1;
	}
	p=n,q=1,opt=0;
	s3+=abs(v[n]-w);
	for(int i=1;i<n;i++)
	{
		if(opt^1) s3+=max(v[p]-v[q],abs(w-v[q])),p--,opt=1;
		else s3+=max(v[p]-v[q],abs(v[p]-w)),q++,opt=0;
	}
	printf("%lld\n",max(s2,s3));
	return 0;
}
```


---

## 作者：gyyyyx (赞：0)

[题面](https://www.luogu.com.cn/problem/P4801)

贪心题，显然可以先把 $t$ 从小到大排序。

先看美味值最小：

1. $w<t_1$，狐狸选择先喝水，然后**顺序**吃饼干。

2. $w>t_n$，狐狸选择先喝水，然后**倒序**吃饼干。

3. $t_1\leq w\leq t_n$，设 $t_x\leq w\leq t_{x+1}$，狐狸选择先喝水，然后按 $x\sim 1$ 这样吃饼干，接着再喝水，然后按 $x+1\sim n$ 这样吃饼干。

再看美味值最大：

狐狸一定选择 $1,n,2,n-1,3,n-2...$ 这样，或者 $n,1,n-1,2,n-2,3$ 这样。

其中可能还有喝水比吃饼干更优，需判断一下。

代码：

```cpp
#include<bits/stdc++.h>
#define max(x,y) (x<y?y:x)
#define abs(x) (x<0?-(x):x)
#define ll long long
using namespace std;
inline ll read(){
	long long x(0),f(1);char c(getchar());
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	return x*f;
}
int n;ll w,t[100005];
inline ll MIN(){
	if(w<t[1]) return t[n]-w;
	if(w>t[n]) return w-t[1];
	return t[n]-t[1];
}
inline ll MAX(int op){
	int l(1),r(n);ll pre(w),res(0);
	for(int i(1);i<=n;++i){
		if((i&1)^op){
			res+=max(abs(t[l]-pre),abs(t[l]-w));
			pre=t[l++];
		}
		else{
			res+=max(abs(t[r]-pre),abs(t[r]-w));
			pre=t[r--];
		}
	}
	return res;
}
int main(){
	n=read();w=read();
	for(int i(1);i<=n;++i) t[i]=read();
	sort(t+1,t+1+n);
	printf("%lld %lld\n",MIN(),max(MAX(0),MAX(1)));
	return 0;
}
```

完结撒花~

---


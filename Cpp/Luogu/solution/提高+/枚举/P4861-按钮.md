# 按钮

## 题目背景

Ada被关在了一个房间里。

## 题目描述

房间的铁门上有一个按钮，还有一个显示屏显示着“1”。    
旁边还有一行小字：“这是一个高精度M进制计算器，每按一次按钮，屏幕上的数便会乘以K。当个位数再次变为1时，门就开了。”    
由于Ada急于出去，所以你要在1s之内求出她的最小按键次数。

## 说明/提示

对于30%的数据，$2\leq M,K\leq10^4$。    
对于100%的数据，$2\leq M,K\leq2\times 10^{9}$。  
update：我们不认为个位为11,21,...为问题的解（例如，11在16进制下记为B）    

## 样例 #1

### 输入

```
11 2```

### 输出

```
10```

## 样例 #2

### 输入

```
6 26```

### 输出

```
Let's go Blue Jays!```

# 题解

## 作者：da32s1da (赞：13)

首先我们看出题目要求$K^x\equiv1 \mod{M}$的最小正整数$x$。

~~于是我们可以打个扩展BSGS~~

但我们发现开始是$1$，结束是$1$。就想到用幂的**循环节**来做。

即$k^{\phi(M)}\!\!\mod M =1$。

输出$\phi(M)$，~~试了几组，发现不对~~

可以发现答案都是$\phi(M)$的约数，于是我们记录下其约数后，对于每一个约数，我们试着除掉它之后可不可行，若可行则除掉，否则保留。

另外无解情况：若$\gcd(K,M)\ !=1$，则无解。

因为$k^{x}\!\!\mod M$一定是$\gcd(K,M)$的倍数。
```
#include<cstdio>
#include<algorithm>
using namespace std;
int tim[1000],tot,pri[1000];
int n,m,res=1,p,mm;
int get_phi(int r){    
    int ans=r;
    if(r&1^1)ans>>=1;
    while(r&1^1)r>>=1;
    for(int i=3;i*i<=r;i+=2)  
    if(r%i==0){    
        ans-=ans/i;    
        while(r%i==0)r/=i;
    }   
    if(r>1)ans-=ans/r;    
    return ans;    
}
int ksm(int u,int v,int a){
    int res=1;
    for(;v;v>>=1,u=1ll*u*u%a)
    if(v&1)res=1ll*res*u%a;
    return res;
}
int gcd(int u,int v){return v?gcd(v,u%v):u;}
int main(){
    scanf("%d%d",&n,&m);
    if(gcd(n,m)!=1)puts("Let's go Blue Jays!");//无解
    else{
        p=get_phi(n);//得到phi
        mm=p;
        for(int i=2;(i*i)<=mm;i++){
            if(mm%i)continue;
            pri[++tot]=i;
            while(mm%i==0){
                mm/=i;
                tim[tot]++;
            }
        }
        if(mm!=1){
            pri[++tot]=mm;
            tim[tot]=1;
        }
        //pri[]是因子，tim[]是每个因子出现次数
        int ss=1,qq=p;
        while(ss<=tot){//枚举每个因子
            for(int i=1;i<=tim[ss];i++){//枚举出现次数
                if(ksm(m,qq/pri[ss],n)==1)qq/=pri[ss];
                else break;
                //若除掉该因子可行，则除掉，否则保留
            }
            ss++;
        }
        printf("%d\n",qq);//输出答案
    }
}
```

---

## 作者：MY（一名蒟蒻） (赞：7)

[P4861 按钮](https://www.luogu.com.cn/problem/P4861)

分析一下题目，我们只关心个位，于是转化为求 $K^{x} \equiv 1 \pmod m$ 。

复杂度允许，使用 BSGS 算法。

[模板 P3846](https://www.luogu.com.cn/problem/P3846)

[我的 BSGS 算法学习笔记](https://www.luogu.com.cn/blog/nizhuan/bsgs-xue-xi-bi-ji)

并没有说 $K$ 与 $m$ 互质，但是考虑无解的情况，当且仅当 $K$ 与 $m$ **不互质**。

**证明：**

以上同余方程等价于不定方程 $K\times K^{x-1}-a\times m=1$ 。

有解时**满足裴蜀定理**，所以 $\gcd(K,m)=1$ 。

也就是 $K$ 与 $m$ **互质**。

输入时先判断一下是否有解，有解再跑 BSGS 。

~~主要是我不会 exBSGS~~ 。

## Code

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <map>

using namespace std;

map <int,int> _hash;
inline int BSGS(int a,int b,int p)
{
	b%=p;
	int t=ceil(sqrt(p)),val=1;
	for(int i=0;i<t;i++)
	{
		_hash[1ll*b*val%p]=i;
		val=1ll*val*a%p;
	}
	a=val; val=1;
	
	if(!a) return !b? 1:-1;
	for(int i=0,j;i<=t;i++)
	{
		j=_hash.find(val) == _hash.end()? -1:_hash[val];
		if(~j && i*t-j > 0) return i*t-j;
		val=1ll*val*a%p;
	}
	return -1;
}

int gcd(int a,int b) {return !b? a:gcd(b,a%b);}

int main()
{
//	freopen("work.in","r",stdin); freopen("work.out","w",stdout);
	int m,k;
	scanf("%d%d",&m,&k);
	if(gcd(m,k)^1) printf("Let's go Blue Jays!");
	else printf("%d",BSGS(k,1,m));
//	fclose(stdin); fclose(stdout);
	return 0;
}
```

**一些 BSGS 的题：**

- [P2485 [SDOI2011]计算器](https://www.luogu.com.cn/problem/P2485)
- [P4454 [CQOI2018]破解D-H协议](https://www.luogu.com.cn/problem/P4454) [题解](https://www.luogu.com.cn/blog/nizhuan/solution-p4454)
- [P3306 [SDOI2013] 随机数生成器](https://www.luogu.com.cn/problem/P3306)
- [P4884 多少个1？](https://www.luogu.com.cn/problem/P4884)

## $\text{Thank you for your reading !}$

---

## 作者：Soledad_S (赞：7)

题目大意：求$K^x\equiv1\pmod{M}$的最小正数解。

神犇都用欧拉定理，然而菜鸡我只会暴力$BSGS$，所以我决定把BSGS顶上来。

首先$\gcd(K,M)\ne1$时肯定无解，因为$\gcd(K,M)\mid K^x\pmod{M}$，楼上大神也解释了。

所以剩下的情况$K$和$M$就互质了，所以直接跑$BSGS$就行了。

---
$BSGS$是什么？不会的可以看[P3846](https://www.luogu.org/problemnew/show/P3846)，因为是板子，所以就不讲了吧。
```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstring>
#include<cstdio>
#include<iomanip>
#include<algorithm>
#include<cmath>
#include<map>
using namespace std;
#define int long long
inline int read() {
    char ch;
    bool bj=0;
    while(!isdigit(ch=getchar()))
        bj|=(ch=='-');
    int res=ch^(3<<4);
    while(isdigit(ch=getchar()))
        res=(res<<1)+(res<<3)+(ch^(3<<4));
    return bj?-res:res;
}
inline int quick_pow(int a,int n,int p) {
    int ans=1;
    while(n) {
        if(n&1)ans=ans*a%p;
        a=a*a%p;
        n>>=1;
    }
    return ans;
}
inline int gcd(int x,int y) {
    return !y?x:gcd(y,x%y);
}
int BSGS(int a,int b,int p) {
    map<int,int>hash;
    hash.clear();
    b%=p;
    int t=(int)sqrt(p)+1;
    for(int j=0; j<t; j++) {
        int val=b*quick_pow(a,j,p)%p;
        hash[val]=j;
    }
    a=quick_pow(a,t,p);
    if(!a)return !b?1:-1;
    for(int i=1; i<=t; i++) {
        int val=quick_pow(a,i,p);
        int j=hash.find(val)==hash.end()?-1:hash[val];
        if(j>=0&&i*t-j>=0)return i*t-j;
    }
    return -1;
}
signed main() {
    int m=read(),k=read();
    if(gcd(m,k)!=1) {
        puts("Let's go Blue Jays!");
        return 0;
    }
    int tmp=BSGS(k,1,m);
    cout<<tmp<<endl;
    return 0;
}
```


---

## 作者：Weng_Weijie (赞：5)

首先如果 $\gcd(K,M)\neq 1$ 肯定无解

否则由欧拉定理 $K^{\varphi(m)}\equiv 1\pmod{M}$

可以证明最小的解 $x$ 一定整除 $\varphi(M)$

证明如下：

假设 $x\not\mid\varphi(M)$ 且 $x$ 是最小的正整数使得 $K^x\equiv 1\pmod M$

因为 $x\not\mid\varphi(M)$ 那么假设 $kx<\varphi(M)<(k+1)x$

那么 $K^{\varphi(M)-kx}\equiv 1\pmod M$

而 $\varphi(M)-kx<x$ 因此 $x$ 不是最小的符合条件的正整数

代码：
```cpp
#include <iostream>
#include <algorithm>

using LL = long long;
int mod, k, phimod, ans = 0x3f3f3f3f;
int pow(int x, int y, int ans = 1) {
    for (; y; y >>= 1, x = (LL) x * x % mod)
        if (y & 1) ans = (LL) ans * x % mod;
    return ans;
}
int phi(int n) {
    int ret = n;
    for (int i = 2; i * i <= n; ++i)
        if (n % i == 0) {
            ret = ret / i * (i - 1);
            do n /= i; while (n % i == 0);
        }
    if (n > 1)
        ret = ret / n * (n - 1);
    return ret;
}
void check(int n) {
    if (pow(k, n) == 1)
        ans = std::min(ans, n);
}
int main() {
    std::cin >> mod >> k;
    if (std::__gcd(k, mod) != 1)
        std::cout << "Let's go Blue Jays!\n";
    else {
        ans = phimod = phi(mod);
        for (int i = 2; i * i <= phimod; ++i)
            if (phimod % i == 0)
                check(i), check(phimod / i);
        std::cout << ans << '\n';
    }
    return 0;
}

```

---

## 作者：OldVagrant (赞：4)

## 题意  
给定 $K$，$M$ 求一个最小的正整数 $x$,使得 $K^x\equiv 1\pmod M$ 。  
数据范围：$2\leq K$，$M\leq 2\times 10^9$。
## Solution
先考虑无解的情况，原式可变为 $K^{x-1}K+am=1$，由裴蜀定理可推知：要使这个式子成立必须满足 $\gcd(K^{x-1},M)=1$,即 $\gcd(K,M)=1$，否则无解。~~然而数据里并没有无解的情况，所以忘加特判也能AC~~。   
然后当 $K$，$M$ 互质时，由欧拉定理得 $K^{\varphi(m)}\equiv1\pmod m$，当然这只是一个特解，所以 $\varphi(m)$ 不一定是最小的，但是最小的一定满足  $K^x\equiv 1\pmod M$,所以 $x|\varphi(m)$,因为 $\varphi(m)$ 一定可以写成 $p\times x$ 的形式，否则无法保证 $K^x\equiv 1\pmod m$。   
最后直接寻找 $\varphi(m)$ 的约数然后从小到大枚举即可。  
~~其实这题可以再毒瘤一点，把数据范围平方一下，逼人用Prho分解质因数~~。
## Code
```c
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define rint register int
int m,k,p,q=1,zys[114514];
int getphi(int x){
	int a=x;
	if(!(x&1)){
		a>>=1,x>>=1;
		while(!(x&1)) x>>=1;
	}for(rint i=3;i*i<=x;i+=2){
		if(!(x%i)){
			x/=i,a/=i,a*=i-1;
			while(!(x%i)) x/=i;
		}
	}if(x>1) a/=x,a*=x-1;
	return a;
}
int fjzys(int x){
	int ma=sqrt(x),d=0;
	if(x/ma==ma){
		for(rint i=1;i<ma;i++) if(!(x%i)) zys[++d]=i,zys[++d]=x/i;
		zys[++d]=ma;
	}else for(rint i=1;i<=ma;i++) if(!(x%i)) zys[++d]=i,zys[++d]=x/i;
	sort(zys+1,zys+d+1);
	return d; 
}
int qpow(int a,int b,int p){
	int ans=1;
	while(b){
		if(b&1) ans=(ll)ans*a%p;
		a=(ll)a*a%p,b>>=1;
	}return ans;
}
signed main(){
	scanf("%d%d",&m,&k);
	if(__gcd(m,k)>1) puts("Let's go Blue Jays!");
	else{
		p=getphi(m),q=fjzys(p);
		for(rint i=1;i<=q;i++){
			p=qpow(k,zys[i],m);
			if(p==1){
				printf("%d",zys[i]);
				break;
			}
		}
	}return 0;
}
```


---

## 作者：顾z (赞：4)

这题太水了吧 emmm(竟然是个紫题？？)

~~之前同桌出过这题,所以就切了[@王小呆](https://www.cnblogs.com/wangxiaodai/)~~

很容易发现,我们需要求解的是这个东西$K^x \equiv 1(mod\ m)$

突然想到一个定理.--->**欧拉定理**：$a^{\phi(p)} \equiv 1 (mod\ p) $

这个定理有解的情况是$gcd(a,p)=1$

因此判断无解就是$gcd(a,p)!=1$了.

~~但是这题没有设置判断无解的分数,差评。(别问我怎么知道的。qwq~~

然后我们求解$\phi(p)$即可。

$$\phi(x)=x \times \prod_{i=1}^{r} (1-\frac{1}{p_i})$$

其中$p_i$为质数

但这**不一定是最小整数解,怎么办？**

枚举$\phi(p)$的因子就好了啊.

这个具体证明挺简单的,如果大家不会我再填坑好了。

所以就不打算证明。

我们$O(\sqrt n)$的求出$\phi(n)$再$O(\sqrt{\phi(n)})$的枚举其因子就好了。

$O(\sqrt n)$求$\phi(n)$就不多说了,相信大家都会。~~其实是我懒~

如果不会的话,可以去[@王小呆](https://www.cnblogs.com/wangxiaodai/)里面找一找,应该会有。

还有,吐槽一下数据很水。

取模写成对$\phi(n)$取模,竟然有$90pts$。

``代码``

```c++
#include<cstdio>
#include<algorithm>
#include<iostream>
#define int long long 
#define R register

using namespace std;

inline void in(R int &x)
{
	int f=1;x=0;char s=getchar();
	while(!isdigit(s)){if(s=='-')f=-1;s=getchar();}
	while(isdigit(s)){x=x*10+s-'0';s=getchar();}
	x*=f;
}

int n,m,ans=2147483647666LL;

int gcd(R int x,R int y){return y==0 ? x:gcd(y,x%y);}

inline int phi(R int x)
{
	R int res=x;
	for(R int i=2;i*i<=x;i++)
	{
		if(x%i==0)
		{
			res=res/i*(i-1);
			while(x%i==0)x/=i;
		}
	}
	if(x>1) res=res/x*(x-1);
	return res;
}

inline int ksm(R int x,R int y)
{
	R int res=1;
	for(;y;y>>=1,x=x*x%n)
		if(y&1)res=res*x%n;
	return res;
}
signed main()
{
	in(n),in(m);
	if(gcd(n,m)!=1)
	{
		puts("Let's go Blue Jays!");
		return 0;
	}
	R int tmp=phi(n);
	for(R int i=1;i*i<=tmp;i++)
	{
		if(tmp%i!=0)continue;
		if(ksm(m,i)%n==1)
		{
			ans=i;
			break;
		}
		if(ksm(m,tmp/i)%n==1)ans=min(ans,tmp/i);
	}
	printf("%lld",ans);
}
```



---

## 作者：0x3F (赞：3)

题目意思就是说，求出最小的正整数 $n$ ,使得 $k^n \equiv 1(\!\!\!\!\mod m)$ 。

当 $\gcd(k, m) \neq 1$ 时，一定无解。

当 $\gcd(k, m) = 1$ 时，由欧拉定理可知 $k^{\phi(m)} \equiv 1(\!\!\!\!\mod m)$ ，所以 $n \mid \phi(m)$ 。

于是乎，$\Theta(\sqrt{m})$ 枚举 $\phi(m)$ 的因子即可。

对于每一个因子，分别使用快速幂计算。

总时间复杂度： $\Theta(\sqrt m  \log m)$ ~~即 $\Theta(\texttt{能过})$ 。~~

~~说句闲话：`blue jays` 指多伦多蓝鸟队——欧美十佳棒球队~~

```cpp
#include <bits/stdc++.h>
using namespace std;
int m, k;

int gcd(int a, int b) {
	while (a && b) {
		if (a > b) a %= b;
		else b %= a;
	}
	return a + b;
}

int phi(int n) {
	int ans = n;
	for (register int i = 2; i * i <= n; i++) {
		if (n % i == 0) {
			ans -= ans / i;
			while (n % i == 0) n /= i;
		}
	}
	if (n != 1) ans -= ans / n;
	return ans;
}

long long qp(int a, int b) {
	if (b == 0) return 1;
	long long p = qp(a, b>>1);
	p = p * p % m;
	if (b&1) return a * p % m;
	else return p;
}

int main() {
	cin >> m >> k;
	int p = phi(m);
    if (gcd(m, k) != 1) {
    	cout << "Let's go Blue Jays!" << endl;
    	return 0;
    }
	register int i;
	for (i = 1; i * i <= p; i++) {
		if (p % i == 0) {
			if (qp(k, i) == 1) {
				cout << i << endl;
				return 0;
			}
		}
	}
	for (; i >= 1; i--) {
		if (p % i == 0) {
			if (qp(k, p/i) == 1) {
				cout << p/i << endl;
				return 0;
			}
		}
	}
	return 0;
}

```


---

## 作者：Eltaos_xingyu (赞：1)

这道题让我们求的是 $K^x\equiv 1\pmod M$ 的最小正整数解。

首先考虑到 $\gcd(M,K)>1$ 时，$K^a\bmod M$ 一定是 $\gcd(M,K)$ 的倍数，不可能归一，所以无解。

然后对于 $\gcd(M,K)=1$ 的情况，根据欧拉定理我们发现 $K^{\varphi(m)}\equiv 1\pmod M$。就算答案不是 $\varphi(m)$，根据这里的循环性，我们也一定知道这个最小按键次数是 $\varphi(m)$ 的因数。

所以枚举因数然后快速幂检验即可，时间复杂度 $O(\sqrt{\varphi(M)}\log {\varphi(M)}+\sqrt M)$。

贴上部分代码：

```cpp
void chk(int l){
	if(ksm(k,l)==1)cout<<l,exit(0);
	return;
}
signed main(){
	ios::sync_with_stdio(0);
	cin>>m>>k;
	if(__gcd(m,k)>1)return cout<<"Let's go Blue Jays!",0;
	int p=phi(m);
	int sq=sqrt(p);
	for(int i=1;i<=sq;i++){
		if(p%i==0)chk(i);
	}
	for(int i=sq;i>=2;i--){
		if(p%i==0)chk(p/i);
	}
	cout<<p<<"\n";
	return 0;
}
```

---

## 作者：eee_hoho (赞：1)

话说怎么没人写$BSGS$啊

首先我们看到题目，每次在$M$进制下对$1$乘$k$，也就是对$k$乘方，最后还是得到$1$

这样我们就可以列出同余方程$k^x\equiv 1\ (mod\ M)$

而初始状态为$1$，即$k^0=1$

所以答案就是满足方程的最小的正整数$x$

其实这道题是$\text{Ex\_BSGS}$，因为题目不满足$k$和$M$互质

考虑我们在做$\text{Ex\_BSGS}$时，每次取出$g=gcd(k,M),b'=\frac{b}{g},M'=\frac{M}{g},k'=\frac{k}{g}$

得到新方程$k^{x-1}\times k'\equiv b'\ (mod\ M')$

移项得到$k^{x-1}\equiv \frac{b'}{k'}\ (mod\ M')$

无解的情况就是$g\nmid b$并且$b\ne1$

证明就不证了，不会的可以去看这篇[文章](https://www.luogu.org/blog/sdlang/solution-p4195)QAQ

直到$g=1$，即$k$，$M$互质，就可以用$BSGS$求解了

而题目给的$b$是$1$，那么我们回去看这个过程，$k,M$不互质说明$g>1$

$$g>1,x\ne0\Rightarrow g\nmid b\Rightarrow \text{无解}$$

所以这个题特判下$k,M$互不互质然后跑$BSGS$就好了

简单说下$BSGS$怎么写吧

设$n=\left \lfloor \sqrt M \right \rfloor,x=i\times n-j,1\le i,j\le n$，原方程就变为

$$k^{i\times n-j}\equiv 1\ (mod\ M)$$
$$(k^n)^i\equiv k^j\ (mod\ M)$$

然后把$k^j$求出来哈希一下就可以啦

**Code**
``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <map>
#include <cmath>
#define int long long
using namespace std;
int m,k;
map <int,int> f;
int mypow(int a,int x,int p)   //快速幂
{
	int s=1;
	while (x)
	{
		if (x&1)s=s*a%p;
		a=a*a%p;
		x>>=1;
	}
	return s;
}
int gcd(int a,int b)    //最大公约数
{
	if (!b)return a;
	return gcd(b,a%b);
}
signed main()
{
	cin>>m>>k;
	if (gcd(m,k)!=1)     //特判无解
	{
		cout<<"Let's go Blue Jays!"<<endl;
		return 0;
	}
	int n=ceil(sqrt(m)),b=1;
	for (int i=1;i<=n;i++)    //k^j
	{
		b=b*k%m;
		f[b]=i;
	}
	b=1;
	int tmp=mypow(k,n,m);
	for (int i=1;i<=n;i++)    //(k^n)^i
	{
		b=b*tmp%m;
		if (f[b]&&(i*n-f[b]+m)%m!=0)   //有解且不为0
		{
			cout<<(i*n-f[b]+m)%m<<endl;
			return 0;
		}
	}
	cout<<"Let's go Blue Jays!"<<endl;   //无解
	return 0;
}
```

---

## 作者：LeavingZzz (赞：1)

# Solution For P4861  
$\mathsf{By\text{ }ShadderLeave}$  

**Upd**: 更新了代码部分，使其符合日报讲解

[厚颜无耻宣传博客的同余方程笔记](https://www.luogu.com.cn/blog/ShadderLeave/5days-equiv-from-beginner-to-killer)  

## 题意简述  
一个数字 $1$ 在 $M$ 进制下以最少的次数乘以 $K$ 最后使个位为 $1$  
## 分析  
不要被所谓的 $M$ 进制吓到了，$M$ 进制的十位表达就是 $M^1$，个位就是没办法进位进到十位去的一部分，所以实际上就是求关于 $x$ 的方程  
$$K^x \equiv 1\pmod{M}$$ 
的最小整数解  
题目没有保证 $K,M$ 互质，但是我们依然选用 $\mathsf{BSGS}$，因为这题有解的时候都是满足 $\gcd(K,M)=1$ 的  


------------
**证明**  
$K^x=a\times M+1$   
$K\times K^{x-1}-a\times M=1$   
看做一个不定方程 ，只有 $\gcd(K,M) | 1$ 的时候有解  
所以 $\gcd(K,M)\ne 1$ 时方程无解  
**证毕**


------------
那么套 $\mathsf{BSGS}$ 板子求解，在一开始判 $\gcd(K,M)\ne 1$ 的无解即可  
~~$\mathsf{BSGS}$ 的详细讲解那篇博客里有~~（超小声  
设 $x=i\times \sqrt{M}-j$ 

对于同余方程 $K^{i\times \sqrt{M}-j}\equiv 1\pmod{M}$ 

即 $\dfrac{K^{i\times \sqrt{M}}}{K^j}\equiv 1\pmod{M}$  

预处理分母，然后当模 $M$ 意义下有 $K^{i\times \sqrt{M}}=K^j$ 时$\dfrac{K^{i \times \sqrt{M}}}{K^j}=1$, 方程有解 $i\times \sqrt{M}-j$ 

分母怎么预处理呢？

因为我们的解形式是  $i\times \sqrt{M}-j$ ，所以 $j\in \left[0, \sqrt{M}\right)$ 

预处理出 $K^j\bmod M,j\in\left[0, \sqrt{M}\right)$ ,将其幂指数存在哈希表里面

暴力枚举 $i,i\in\left[ 1,\sqrt{M}\right]$ ，对于每一个 $K^{i\times \sqrt{M}}$ 在哈希表里面查询是否有对应的 $K^j$  

若存在那么最小解就是 $\boxed{i\times \sqrt{M}-\text{哈希表中存储的幂指数}}$  

## $\mathsf{Code:}$  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
struct Hash_Table{ //手写的哈希表比map快很多
	static const LL MOD=233333;
	LL Hash[MOD+7],V[MOD+7],stk[MOD+7],top;
	Hash_Table() {memset(Hash,-1,sizeof(Hash));top=0;}
	inline void clear() {while(top) Hash[stk[top--]]=-1;return ;}
	inline void insert(LL val,LL mi)
	{
		LL h=val%MOD;
		while(Hash[h]!=-1&&Hash[h]!=val) ++h;
		Hash[h]=val;V[h]=mi;
		stk[++top]=h;
		return ;
	}
	inline LL find(LL val)
	{
		LL h=val%MOD;
		while(Hash[h]!=-1&&Hash[h]!=val) ++h;
		return Hash[h]==val?V[h]:-1;
	}
}H;
LL A,C;
inline LL gcd(LL a,LL b)
{
	return a%b==0?b:gcd(b,a%b);
}
inline LL fast_pow(LL b,LL k,LL m)
{
	LL s=1;
	while(k)
	{
		if(k&1) s=s*b%m;
		b=b*b%m;
		k>>=1;
	}
	return s;
}
inline LL BSGS()
{
	LL sqrtm=ceil(sqrt(C)),ti=1;
	for(int i=0;i<sqrtm;i++)//预处理出A^j
	{
		H.insert(ti,i);
		ti=ti*A%C;
	}
	LL t=ti=fast_pow(A,sqrtm,C),ans;
	for(int i=1;i<=sqrtm;i++)
	{
		if((ans=H.find(ti))!=-1)
			return i*sqrtm-ans;
		ti=ti*t%C;
	}
}
int main()
{
	scanf("%lld%lld",&C,&A);
	if(gcd(A,C)!=1)//无解
		printf("Let's go Blue Jays!");
	else printf("%lld",BSGS());
	return 0;
}
```  
蟹蟹管理大大审核^_^  
$\huge\mathsf{The\text{ }End}$

---

## 作者：lidagua1004 (赞：0)

题目大意：求 $K^x\equiv1\pmod M$ 的最小正整数解。

我看其他题解大多用的欧拉定理，所以我就讲一下 BSGS 的做法。

[BSGS 模板题。](https://www.luogu.com.cn/problem/P3846)

[不会的看这里。](https://oi-wiki.org/math/number-theory/discrete-logarithm/)

显然一个 exBSGS 就可以解决，但是不用那么麻烦。

我们可以发现当 $\gcd(K,M)\neq1$ 时肯定无解，因为 $\gcd(K,M)|K^{x} \pmod M$，其他题解也解释过了。

所以当有解时 K 和 M 一定互质，用普通 BSGS 就可以解决。

代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
map<int,int> mp;
int p;
int qpow(int a,int b){//快速幂
	int ans=1,base=a;
	while(b){
		if(b&1) ans=ans*base%p;
		base=base*base%p;
		b>>=1;
	}
	return ans%p;
}
signed main(){
	int a,b;cin>>p>>a;b=1;
	if(__gcd(a,p)!=1){//特判
		cout<<"Let's go Blue Jays!";
		return 0;
	}
   //BSGS算法
	b%=p;
	int k=sqrt(p)+1;
	for(int i=0;i<k;i++) mp[b*(qpow(a,i))%p]=i;
	a=qpow(a,k);
	if(!a){
	    cout<<(b==0?1:-1);
	    return 0;
	} 
	for(int A=1;A<=k;A++){
		int q=qpow(a,A);
		int j=mp.find(q)==mp.end()?-1:mp[q];
		if(j>=0&&A*k-j>=0){
		    cout<<A*k-j;
		    return 0;
		}
	}
	return 0;
}
```

---

## 作者：gyyyyx (赞：0)

[题面](https://www.luogu.com.cn/problem/P4861)

转换一下题目：

求**最小正整数** $x$ 使得 $K^x\equiv1\ (\text{mod}\ m)$。

显而易见可以用 $\text{BSGS}$ 求出。

但问题是 $K$ 与 $m$ 不一定互质。

虽然 $\text{ExBSGS}$ 能求出，但过于麻烦。

我们发现当 $\gcd(K,m)\neq1$ 时，必定无解。

也就是要用到 $\text{BSGS}$ 的 $K,m$ 必定互质。

问题解决，上代码：

```cpp#include<bits/stdc++.h>
#define LL long long
using namespace std;
LL gcd(LL a,LL b){return b?gcd(b,a%b):a;}
inline int sqrt(LL x){
	LL l(1),r(x),mid;
	while(l<=r){
		mid=(l+r>>1);
		if(mid*mid<=x) l=mid+1;
		else r=mid-1;
	}
	return l;
}
inline LL BSGS(LL p,LL a,LL b){
	map <LL,int> mp;
	int t(sqrt(p));
	LL res(1);
	for(int B(1);B<=t;++B){
		res=res*a%p;
		mp[b*res%p]=B;
	}
	LL cur(res);
	for(int A(1);A<=t;++A){
		if(mp[cur]&&1ll*A*t^mp[cur])//注意这里
			return 1ll*A*t-mp[cur];
		cur=cur*res%p;
	}
	return -1;
}
LL P,a,ans;
int main(){
	scanf("%lld%lld",&P,&a);
	if(gcd(P,a)>1) puts("Let's go Blue Jays!");
	else{
		ans=BSGS(P,a,1);
		if(~ans) printf("%lld\n",ans);
		else puts("Let's go Blue Jays!");
	}
	return 0;
}
```

注意一下网上有些 $\text{BSGS}$ 学习笔记中的代码求出来的 $x$ 是一个**非负整数**，用于此题时 $x$ 必定为 $0$，因此要加判断。

---

## 作者：tkdqmx (赞：0)

可以看出，如果设答案为 $x$，则题目可以转换为求满足 $K^x \equiv 1 \pmod M$ 的 $x$ 的最小值。

根据欧拉定理（当 $\gcd(K,M) = 1$ 时，$K^{\phi(m)} \equiv 1 \pmod M$）可知：

若 $\gcd(K,M) \neq 1$ 则无解；否则，$x$ 一定为 $\phi(m)$ 的因数。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll m,k;
ll gcd(ll x,ll y){
	if(y==0)	return x;
	return gcd(y,x%y);
}
ll phi(ll x){
	ll ans=x;
	for(ll i=2;i*i<=x;i++){
		if(x%i==0)	ans=ans/i*(i-1);
		while(x%i==0) x/=i;
	}
	if(x>1)	ans=ans/x*(x-1);
	return ans;
}
ll quick_pow(ll x,ll y){
	ll sum=1;
	while(y){
		if(y&1) sum=sum*x%m;
		x=x*x%m;
		y>>=1;
	}
	return sum;
}
int main(){
	cin>>m>>k;
	if(gcd(m,k)!=1){
		cout<<"Let's go Blue Jays!";
		return 0;
	}
	ll s=phi(m),ans=LONG_LONG_MAX;
	for(ll i=1;i*i<=s;i++){
		if(s%i==0){
			if(quick_pow(k,i)==1){
				ans=i;
				break;
			}
			if(quick_pow(k,s/i)==1)	ans=min(ans,s/i);
		}
	}
	cout<<ans<<"\n";
}	
```


---

## 作者：5k_sync_closer (赞：0)

题意：求 $K^x\equiv 1\pmod M$ 的最小正整数解，没保证 $M$ 是质数。

这题是蓝的，考虑怎么不用 exBSGS。

注意到 $K\bot M$ 时，仍有欧拉定理 $K^{\varphi(M)}\equiv 1\pmod M$，此时直接 BSGS 即可。

否则 $K^x\bmod M=K^x-M\lfloor\dfrac{K^x}M\rfloor$ 被 $\gcd(K,M)\neq 1$ 整除，显然无解。

```cpp
#include <cmath>
#include <cstdio>
#include <algorithm>
#include <unordered_map>
using namespace std;
int M, k, z;long long B = 1, T = 1;unordered_map<int, int> H;
int main()
{
	scanf("%d%d", &M, &k);if(__gcd(M, k) != 1) return !puts("Let's go Blue Jays!");
	z = ceil(sqrt(M));for(int i = 1;i <= z;++i) H[B = B * k % M] = i;T = B;
	for(int i = 2;i <= z;++i) if(H[T = T * B % M]) return !printf("%d\n", i * z - H[T]);
	return !puts("Let's go Blue Jays!");
}
```


---

## 作者：Cuiyi_SAI (赞：0)

## 解题思路

我们逐步分析题意。

- 考虑到进制转换是取余后反向读取，因此求 $a$ 在 $M$ 进制下的个位其实就是求 $a\bmod M$
- 初始状态为 $1$，以后每次乘以 $K$，不难想到若经过 $x$ 次后得到的数在十进制表示下就是 $K^x$
- 求最小按键次数，如上文所示，就是求 $x$ 的最小正数解。

于是我们就得到了题目实际上要我们求这么一个方程：

$$
K^x\equiv 1\pmod M
$$

如果你对数论颇有了解，那么你一定会使用 $\mathbf{BSGS}$ 算法来求解这个方程（对于不了解 $\mathbf{BSGS}$ 的同学，可以戳我的[这篇blog](https://www.luogu.com.cn/blog/hsh20090304/baby-step-giant-step-chu-bu)）

但是留意题目数据和样例 $\mathbb{2}$，都没有保证 $\gcd(M,k)=1$，那就不符合 $\mathbf{BSGS}$ 的使用条件了，是吗？

我们考虑

$$
K^x\equiv 1\pmod M
$$

一定有

$$
M\mid (K^x-1)
$$

显然不难证明 $\gcd(k^x,k^x-1)=1$ ，又由于 $\gcd(M,K)\ne1$ ，所以有 $\gcd(M,k^x-1)=1$，即 $M\nmid (k^x-1)$，因此一定有

$$
k^x\not\equiv 1\pmod M
$$

综上所述，当 $\gcd(M,K)\ne 1$ 时，此方程无解。

因此，对于不互质的情况，我们直接特判无解，否则就 $\mathbf{BSGS}$ 求最小正数解，此题完结。

```
#include <bits/stdc++.h>
#define int long long
using namespace std;
int m,k;
int BSGS(int a,int b,int mod)
{
	map<int,int> vis;
	int t=sqrt(mod)+1,mi=1;
	for(int i=1;i<=t;i++)
	{
		if(i!=0) mi=(mi*a)%mod;
		vis[(b*mi)%mod]=i;
	}
	a=mi;
	if(!a) return (b%mod==0)?1:-1;
	mi=1;
	for(int i=1;i<=t;i++)
	{
		if(i!=0) mi=(mi*a)%mod;
		map<int,int>::iterator it;
		it=vis.find(mi);
		if(it!=vis.end())
		{
			if(1ll*i*t-(it->second)>0) return 1ll*i*t-(it->second);
		}
	}
	return -1;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>m>>k;
	if(__gcd(m,k)!=1)
	{
		cout<<"Let's go Blue Jays!";
		return 0;
	}
	int ans=BSGS(k,1,m);
	if(ans==-1) cout<<"Let's go Blue Jays!";
	else cout<<ans;
	return 0;
} 
```


---

## 作者：Lates (赞：0)

首先根据题意可以看出题目要求的是

$$K^x \equiv 1 \ (mod\ M)$$

$x$的最小正整数解。

如果$\ gcd(M,K)=1\ $则有解。

然后，根据[欧拉定理](https://www.luogu.com.cn/problem/P5091)，得到

$$K^{\phi(M)}\equiv 1 \ (mod\ M)$$

但$\phi(M)$并不一定是$x$的最小整数解。

可以猜到$x|\phi(M)$。证明别的题解有讲，这里不多说。

所以可以枚举$\phi(M)$的约数，找到最小的$x$满足
$$K^x\equiv1\ (mod\ M)\ ,\ x|\phi(M)$$

$\phi(M)$用这个式子算

$$M=\prod_{i=1}^{n} p_i^{c_i}$$

$$\phi(M)=M \prod_{i=1}^{n}\frac{p_i-1}{p_i}$$

就做完了。

$Code:$

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
#define int long long
#define _min(a,b) ((a)<(b)?(a):(b)) 
inline int read(){
	register int x=0,f=0,ch=getchar();
	while('0'>ch||ch>'9')f^=ch=='-',ch=getchar();
	while('0'<=ch&&ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=getchar();
	return f?-x:x;
}
int res,phi;
int gcd(int a,int b){
	return b?gcd(b,a%b):a;
}
inline void Gphi(int x){//找phi
	phi=x;
	for(register int i=2;i*i<=x;++i){
		if(x%i==0){
			phi=phi/i*(i-1);
			while(x%i==0)x/=i;
		}
	}
	if(x>1)phi=phi/x*(x-1);
}
inline int qpow(int x,int p,int P){//快速幂
	res=1;
	for(;p;p>>=1,x=x*x%P)if(p&1)res=res*x%P;
	return res%P;
}
#define INF 0x3f3f3f3f3f3f3f3f
int m,k,ans=INF;
inline int Gans(int x){//枚举约数找答案
	for(register int i=1;i*i<=x;++i){
		if(x%i==0){
        //这里显然 i<=x/i，因为我们枚举的i满足i<=sqrt(x)的，所以当i有解时，不用判断x/i的答案
			if(qpow(k,i,m)%m==1)ans=_min(ans,i);
			else if(qpow(k,x/i,m)%m==1)ans=_min(ans,x/i);
		}
	}
	return ans;
}
signed main(){
	m=read(),k=read();
	if(gcd(m,k)==1){
		Gphi(m);
		printf("%lld\n",Gans(phi));
	}else printf("Let's go Blue Jays!\n");
	return 0;
}
```
笔者比较菜，有什么问题私信，谢谢

---


# [MtOI2018] 衣服？身外之物！

## 题目背景

gcd 有许多件衣服，每件衣服有不同的颜色。

## 题目描述

gcd 共有 $n$ 件衣服，编号为 $A_1,A_2,\cdots A_n$。

每一件衣服分别拥有颜色值和清洗时间，他在每一件衣服穿完以后都会将其送去清洗，而这件衣服当天所拥有的舒适感取决于当天的天气与他的衣服颜色值的乘积，天气值存在负数。

现给出共 $m$ 天的天气情况，求最大舒适值。

如果**必定**有一天 gcd 没有衣服穿，输出 "gcd loves her clothes!"（不含引号）。      


## 说明/提示

#### 样例解释 $1$

$A_1:Day_1,Day_3,Day_5$

$A_2:Day_2,Day_4$

### 子任务

对于 $30\%$ 的数据，$n=2$，$m=100$。

对于 $50\%$ 的数据，$n\leq 3$，$m\leq 1000$。

对于 $100\% $的数据，$n\leq 4$，$n\neq 1$，$m\leq 2000$，$y_i\leq 6$，$Maxy<m$，$|z_i|\leq 10^8$。

### 题目来源

[MtOI2018 迷途の家の水题大赛](https://www.luogu.org/contest/11260) T3

出题人：b2019dy

78488

## 样例 #1

### 输入

```
2 5
5 10
1 1
2 4 3 5 2```

### 输出

```
125```

# 题解

## 作者：appear_hope (赞：4)

考虑设计状态：

$dp_{i, j}$ 表示当前经过到第 $i$ 天，$n$ 件衣服需要洗的天数构成的集合为 $j$ 时的最大舒适度。

这里我们实现扩散型的转移：

$$dp_{i, j} \rightarrow dp_{i + 1, k} + z_{i + 1} \times y_v$$

其中 $k$ 表示当第 $i + 1$ 天穿第 $v$ 件衣服时 $n$ 件衣服需要洗的天数构成的集合，要保证第 $v$ 件衣服是可以穿的。

注意：每一天过后如果当一件衣服要洗，那么这件衣服需要洗的天数会 $-1$。

代码如下：

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 2e3 + 5;
const int M = 8;
const long long inf = 1e10;
const long long INF = 5e15;

int n, m, a[M], x[N], y[N], z[N], power[N];
long long dp[N][M * M * M * M];

int main(){
	cin >> n >> m;
	power[0] = 1;
	for(int i = 1; i <= n; i++){
		power[i] = power[i - 1] * 7;
	}
	for(int i = 0; i < n; i++){
		cin >> x[i];
	}
	for(int i = 0; i < n; i++){
		cin >> y[i];
	}
	for(int i = 1; i <= m; i++){
		cin >> z[i];
	}
	for(int i = 0; i <= m; i++){
		for(int j = 0; j < power[n]; j++) dp[i][j] = -INF;
	}
	dp[0][0] = 0;
	for(int i = 0; i < m; i++){
		for(int j = 0; j < n; j++) a[j] = 0;
		for(int j = 0; j < power[n]; j++){
			if(j > 0) a[0]++;
			for(int i = 0; i < n && a[i] >= 7; a[i] -= 7, a[++i]++);
			int num = 0;
			for(int i = 0; i < n; i++) num += max(0, a[i] - 1) * power[i]; 
			for(int k = n - 1; k >= 0; k--){
				if(!a[k]){
					int v = num + y[k] * power[k];
					dp[i + 1][v] = max(dp[i + 1][v], dp[i][j] + x[k] * z[i + 1]);
				}
			} 
		}
	}
	long long ans = -INF;
	for(int i = 0; i < power[n]; i++){
		ans = max(ans, dp[m][i]);
	}
	if(ans < -inf){
		cout << "gcd loves her clothes!";
		return 0;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Monster_Qi (赞：4)

## 解题思路

　　数据范围这么小那我们肯定要先想状压$dp$了。发现我们需要的状态是每件衣服还有多少天洗完和当前到了第几天，当前到了第几天可以直接滚动数组。而对于每件衣服还有多少天洗完我们就可以用一个$4$位的七进制数来表示。第$i$位表示到了第$i$件衣服的状态，每一位的数字如果是$0$则表示这件衣服可以使用，否则表示这件衣服还需要洗几天。因为一件衣服最多洗$6$天。
  
　　这样的话可以用$f[0/1][S]$来转移，转移的话就枚举一下看哪件衣服可以用，如果能用的话把其他正在洗的衣服天数$-1$，把这件衣服洗的天数变成$y[i]$。但是发现这里的总状态数是$4^7*2000=32768000$，再加上转移的复杂度似乎不太科学。但我们进一步可以发现其实很多状态是冗余的，没必要去枚举到这些状态。我们可以用一个小$trick$，我们只需要拿那些上一次被更新的状态去更新，这样就可以用一个$vector$存储上一次被更新到的状态。转移时只需要枚举这些状态即可。然后当某一次$vector$空时即为无解。这样的话跑的还是飞快的，具体实现看代码。
  
  
## 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<vector>

using namespace std;
typedef long long LL;
const int poww[5]={0,1,7,49,343};

inline int rd(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)) f=ch=='-'?0:1,ch=getchar();
	while(isdigit(ch)) x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	return f?x:-x;
}

inline LL max(LL x,LL y){return x>y?x:y;}

int n,m,x[10],y[10],z[2005];
vector<int> v[2];
bool vis[1<<15];
LL f[2][1<<15],ans=-1e18;

inline int get_new(int S,int now){
	int ret=S;
	for(int i=1;i<=n;i++){
		if(i==now) ret+=y[i]*poww[i];
		else if(S/poww[i]%7!=0) ret-=poww[i];
	}
	return ret;
}

int main(){
	n=rd(),m=rd();int op=0,S,T;
	for(int i=1;i<=n;i++) x[i]=rd();
	for(int i=1;i<=n;i++) y[i]=rd();
	for(int i=1;i<=m;i++) z[i]=rd();
	v[0].push_back(0);
	for(int i=1;i<=m;i++){
		memset(f[op^1],-63,sizeof(f[op^1]));v[op^1].clear();
		for(int j=0;j<v[op].size();j++) vis[v[op][j]]=0;
		for(int j=0;j<v[op].size();j++){
			S=v[op][j];
			for(int k=1;k<=n;k++)
				if(S/poww[k]%7==0) {
					T=get_new(S,k);
					if(!vis[T]) v[op^1].push_back(T),vis[T]=1;
					f[op^1][T]=max(f[op^1][T],f[op][S]+(LL)z[i]*x[k]);
					//printf("f[%d][%d]=%lld\n",i,T,f[op^1][T]);
				}
		}
		op^=1;
		if(!v[op].size()) {puts("gcd loves her clothes!");return 0;}
	}
	for(int i=0;i<v[op].size();i++) ans=max(ans,f[op][v[op][i]]);
	printf("%lld\n",ans);
	return 0;
}
```

[~~打波blog广告~~](https://www.cnblogs.com/sdfzsyq/)

---

## 作者：Hoks (赞：3)

## 前言
[题目链接](https://www.luogu.com.cn/problem/P4928)，[个人博客](https://www.luogu.com.cn/blog/Hok/solution-p4928)内食用也不不会更佳。

~~数组开小，倍数数组漏写一个，答案忘赋初值，快读忘写负数快乐四连挂。~~
## 思路分析
首先看一个题目大意，一眼确定 $dp$。再看一眼数据范围，直接选择状压启动！

状压首先考虑状态情况总数，因为一件衣服最多洗四天，最多四件衣服，所以是 $4^7=16384$。然后是 $f$ 数组怎么开，最开始考虑 $f[2010][17010]$，发现空间有点危险，而且 $f[i][j]$ 的值只与 $f[i-1][k]$ 有关，所以用滚动数组滚掉一维，变成 $f[2][17010]$。

然后状压如何递推。即为前一天的所有状态尝试换上可以换的衣服取最大值（感谢第一篇题解的思路）。
## 易挂分点
如前言中所言，数组开小，倍数数组漏写一个，答案忘赋初值，快读忘写负数，警钟撅烂。
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,op,zt,now,ans=-1145141919810;//初始值一定要是大负数
int x[15],y[15],z[2010];
int f[2][114514],p[15]={0,1,7,49,343};//最开始写的时候漏了49
bool vis[114514];//因为刚开始开小了RE了所以开了114514
vector<int>a[2];
int next(int zt,int now)//zt：状态，下面同理
{
  int res=zt;
  for(int i=1;i<=n;i++)
    if(i==now) res+=y[i]*p[i];
    else if(zt/p[i]%7!=0) res-=p[i];
  return res;
}
int read()
{  
  char c=getchar();int x=0;
  while(!isdigit(c)) c=getchar();
  while(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
  return x;
}
signed main()
{
  n=read(),m=read();
  for(int i=1;i<=n;i++) x[i]=read();
  for(int i=1;i<=n;i++) y[i]=read();
  for(int i=1;i<=m;i++) z[i]=read();
  a[0].push_back(0);
  for(int i=1;i<=m;i++)
  {
    memset(f[op^1],-63,sizeof(f[op^1]));a[op^1].clear();
    for(int j=0;j<(int)a[op].size();j++) vis[a[op][j]]=0;
    for(int j=0;j<(int)a[op].size();j++)
    {
      zt=a[op][j];
      for(int k=1;k<=n;k++)
        if(zt/p[k]%7==0)
        {
          now=next(zt,k);//获得这天可穿的衣服
          if(!vis[now]) a[op^1].push_back(now),vis[now]=1;
          f[op^1][now]=max(f[op^1][now],f[op][zt]+z[i]*x[k]);
        }
    }
    op^=1;
    if(!a[op].size()){puts("gcd loves her clothes!");return 0;}
  }
  for(int i=0;i<(int)a[op].size();i++) ans=max(ans,f[op][a[op][i]]);
  printf("%lld",ans);
  return 0;
}
```

---

## 作者：y2823774827y (赞：3)


n、y较小 ，显然用状压，思路还是比较容易想的，实现较复杂，具体看代码吧，有少量注释

初赛前发篇题解,望能通过
>while(true) noip2018_rp++;

```cpp
#include<cstdio>
using namespace std;
typedef long long LL;
LL n,m,maxn,inf=1000000000000,ans; LL v[10],t[10],like[2010],bai[10],dp[2010][7000];
inline LL MAX(LL g1,LL g2){
    return g1>=g2?g1:g2;
}
int main(){
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;++i)
        scanf("%lld",v+i);
    bai[1]=1; bai[2]=10; bai[3]=100; bai[4]=1000; bai[5]=10000;
    for(int i=1;i<=n;++i){
        scanf("%lld",t+i);
        maxn+=t[i]*bai[i];
    }
    for(int i=1;i<=m;++i)
        scanf("%lld",like+i);
    for(int i=1;i<=m+1;++i)
        for(int j=0;j<=maxn;++j)
            dp[i][j]=inf;//dp i,j:第i天 洗衣状态为j
    dp[1][0]=0;
    for(int i=1;i<=m;++i){
        bool fff=false;
        for(int j=0;j<=maxn;++j){
            if(dp[i][j]==inf)//不存在这种状态
                continue;
            bool f=false,ff=false;
            LL shu=0,g[10];
            for(int k=1;k<=n;++k){
                g[k]=j%bai[k+1]/bai[k];//今天的状态
                if(g[k]>t[k]){
                	f=true;
                	break;
                }
                if(!g[k])
                    ff=true;
                if(g[k])
                    shu+=(g[k]-1)*bai[k];//明天的状态
            }
            if(f)//不存在这种状态
                continue;
            if(!ff)//今天没有能穿的衣服 
                continue;
            fff=true;
            
            for(int k=1;k<=n;++k)
            	if(!g[k]){//今天穿这件衣服 
            		int shu2=shu%bai[k]+t[k]*bai[k]+shu/bai[k+1]*bai[k+1];
            		
            		if(dp[i+1][shu2]==inf)
            		    dp[i+1][shu2]=dp[i][j]+like[i]*v[k];
            		else
            		    dp[i+1][shu2]=MAX(dp[i+1][shu2],dp[i][j]+like[i]*v[k]);
                }
            //printf("\n");
        }
        if(!fff){
            printf("gcd loves her clothes!");
            return 0;
        }
        //return 0;
    }
    for(int i=0;i<=maxn;++i){
        if(dp[m+1][i]==inf)
            continue;
        ans=MAX(ans,dp[m+1][i]);
    }
    printf("%lld",ans);
    return 0;
}/*
2 5
5 10
1 1
2 4 3 5 2

125
*/
```

---

## 作者：b2019dy (赞：3)

n进制状压  
因为我们的状态转移最多只与前$maxy$天有关，所以我们压缩前$maxy$天的状态  
预处理所有可行状态，然后枚举当天穿什么衣服，转移状态即可  
空间不足，需要使用滚动数组优化  
$f[i][s]=max(f[i][s],f[i-1][j]+a[k]*v[i])$  
s可以通过j和k得到  
时间复杂度$O(m*n*n^{maxy+1})$  
本题还存在算法复杂度更低的算法，只是转移过于复杂，这里不做介绍

---

## 作者：ARIS2_0 (赞：2)

### 前言

**状压？神秘乱搞！**

注意到 $n\le4,y_i\le6$，考虑状压 DP 乱搞。

### DP 设计

设 $f_{i,j}$ 为在第 $i$ 天，**衣服占用情况**为 $j$ 时的最大总舒适值。因为 $y_i\le6$，我们可以**用一个 7 进制数 $j$** 来代表衣服占用情况，其中 $j$ 的第 $i$ 位（即 $\lfloor \frac{j}{7^{i-1}}\rfloor\mod 7$）记录**第 $i$ 件衣服距离洗好的那一天（下文称为：）还有多少天**。

那么，我们可以列出一个转移方程（注意以下方程计算的是第 $i+1$ 天的答案）：

$f_{i+1,pos}=\min(f_{i+1,pos},f_{i,j}+x_p\times z_{i+1})$，其中 $p$ 为状态 $j$ 中一件**可使用的衣服**（即 $j$ 的第 $p$ 位为 $0$），而 $pos$ 的计算稍显复杂。设 $pos_i$ 为 $pos$ 的第 $i$ 位，则：

对于 $\forall i\in[1,4]$（因为 $n\le4$，所以 7 进制数最多 $4$ 位），如果 $i=p$， $pos_i=y_p$，否则 $pos_i=\min(pos_i-1,0)$。

证明是显然的：若第 $i+1$ 天穿的是第 $p$ 件衣服，则其在第 $i$ 天一定是空闲的；经过这一天后，第 $p$ 件衣服的冷却天数变为 $y_p$，其对答案的贡献为 $x_p\times z_{i+1}$。

初始状态：$f_{0,0}=0$，其他 $f_{i,j}=-\inf$。

### 注意事项

转移的时候，当且仅当 $f_{i,j}\not=-\inf$ 时再去转移 $f_{i+1,pos}$，这样的话可以用 $\sum_{j=0}^{7^n-1}\max(f_{m,j})=-\inf$ 来判断无解。

### AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int inf=1e16,maxn=2010;
int x[maxn],y[maxn],z[maxn],f[maxn][2500];
int kpow(int a,int b){
    if(b==0)return 1;
    int t=kpow(a,b/2);
    t*=t;
    if(b%2)t*=a;
    return t;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	int n,m;cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>x[i];
    for(int i=1;i<=n;i++)cin>>y[i];
    for(int i=1;i<=m;i++)cin>>z[i];
    for(int i=0;i<=m;i++){
        for(int j=0;j<(kpow(7,n));j++){
            f[i][j]=-inf;
        }
    }
    f[0][0]=0;
    for(int i=0;i<m;i++){
        for(int j=0;j<(kpow(7,n));j++){
            if(f[i][j]!=-inf){
                int p[5],tot=1;
                for(int res=1;res<=4;res++)p[res]=(j/tot)%7,tot*=7;
                for(int ch=1;ch<=n;ch++){
                    if(p[ch]==0){
                        int q[5];
                        for(int res=1;res<=4;res++){
                            q[res]=(res==ch?y[ch]:max(0ll,p[res]-1));
                        }
                        int pos=0,tos=1;
                        for(int res=1;res<=4;res++)pos+=q[res]*tos,tos*=7;
                        f[i+1][pos]=max(f[i+1][pos],f[i][j]+x[ch]*z[i+1]);
                    }
                }
            }
        }
    }
    int ans=-inf;
    for(int j=0;j<kpow(7,n);j++)ans=max(ans,f[m][j]);
    if(ans==-inf)cout<<"gcd loves her clothes!";
    else cout<<ans;
	return 0;
}
//设f[i][j]为第i天，衣服清洗状态为j时的最大贡献，其中j采用7进制，j的第p位表示第p件衣服清洗完毕还要多久。
//初始状态：f[0][0]=0，其他为-inf
//转移方程：f[i+1][j+第p位为y_p,其他位自减后和0取max]=max(f[i+1][j+第p位为y_p,其他位自减后和0取max],f[i][j]+x_p*z_i)，要求j的第p位为0
//答案：max(f[m][all])
```

---

## 作者：wyl123ly (赞：2)

## 状态设计

看到题目发现 $n\le4$ 则容易想到使用状态压缩dp，先设计状态 $dp_{j,i}$ 表示第 $i$ 天状态为 $j$ 时的最大舒适值。

但是这里的状态 $j$ 不能用以前的二进制来表示，注意到题目中还有一个限制条件“清洗时间”，则需要将这个“清洗时间”加入我们的状态设计当中。

发现题目条件中的 $y\le6$，则可以用七进制来表示状态 $j$，其中 $j$ 的第 $cnt$ 个进制位上的值代表到达这一天第 $cnt$ 件衣服还有几天清洗完成。

## 状态转移

状态设计完成，接下来考虑如何转移状态。

初始化：

显然 $dp_{0,0} = 0$，且 $dp$ 其他值初始化为极小值，这里极小值设置为-2e18。

这里很难通过 $j$ 状态去反推出之前的状态，则我们正推，用 $status$ 表示 $j$ 状态下往后一天推出的状态。

我们对于 $j$ 状态的第 $cnt$ 个进制位考虑：

设这个进制位的值为 $val$，

如果 $val$ 不为零，则 $status$ 的第 $cnt$ 个进制位上的值等于 $val - 1$，因为每过一天清洗时间就减少1。

如果 $val$ 为零，则先不管。

（因为 $val$ 为零代表可以在这一天选中这件衣服穿，而一天只能选择一件衣服，但是有可能有很多个 $val$ 为零的“待选衣服”）

代码：

```cpp
int num = j;
while(num){
	if(num % 7 != 0) status += p(7,cnt) * ((num % 7) - 1);
	num /= 7;
	cnt++;
}
```

其中函数p是 $7^{cnt}$ 的意思。

接下来处理第 $cnt$ 个进制位上 $val$ 为零的情况：

如果我们选了这件衣服的话，状态 $status$ 会变成 $status+y_{cnt} \times 7^{cnt}$。

则对于每个 $val$ 为零的进制位上，可以得到转移 $dp$ 方程式：

```cpp
dp[status + y[cnt + 1] * p(7,cnt)][i] = max(dp[status + y[cnt + 1] * p(7,cnt)][i],dp[j][i - 1] + z[i] * x[cnt + 1]);
```

寻找答案： 
$$
ans = \max^{7^n-1}_{j=0}\{dp_{j,m}\}
$$


判断是否“如果**必定**有一天gcd没有衣服穿”：

根据数据范围设计一个上界，判断答案是否小于这个上界就可以了。

至此 题目已经差不多做完了。

代码：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
#define int long long
const int MAXN = 2005;
const int INF = -2e18;
int n,m;
int x[MAXN],y[MAXN],z[MAXN];
int p(int a,int x){
	int ans = 1;
	for(int i = 1;i <= x;i++) ans *= a;
	return ans;
}
int dp[2505][MAXN];
void print(int x){
	for(int i = 1;i <= n;i++){
		cout<<x % 7;
		x /= 7;
	}
}
signed main(){
	cin>>n>>m;
	for(int i = 0;i <= MAXN - 2;i++){
		for(int j = 0;j <= MAXN + 500 - 2;j++){
			dp[j][i] = INF;
		}
	}
	for(int i = 1;i <= n;i++) cin>>x[i];
	for(int i = 1;i <= n;i++) cin>>y[i];
	for(int i = 1;i <= m;i++) cin>>z[i];
	dp[0][0] = 0;
	for(int i = 1;i <= m;i++){
		for(int j = 0;j <= p(7,n) - 1;j++){
			int status = 0;
			int num = j;
			int cnt = 0;
			while(num){
				if(num % 7 != 0) status += p(7,cnt) * ((num % 7) - 1);
				num /= 7;
				cnt++;
			}
			num = j;
			cnt = 0;
			for(int k = 1;k <= n;k++){
				if(num % 7 == 0) {
					dp[status + y[cnt + 1] * p(7,cnt)][i] = max(dp[status + y[cnt + 1] * p(7,cnt)][i],dp[j][i - 1] + z[i] * x[cnt + 1]);
				}
				num /= 7;
				cnt++;
			}
		}
	}
	int ans = INF;
	for(int j = 0;j <= p(7,n) - 1;j++){
		ans = max(ans,dp[j][m]);
	}
	if(ans == INF) cout<<"gcd loves her clothes!";
	else cout<<ans;
	return 0;
}
```

---

## 作者：farfarqwq (赞：1)

一道状压 dp 题，细节比较多。

看到数据范围 $n \le 4$，$m \le 2000$，$y_i \le 6$，可以想到状压。状态自然想出来一共 $n$ 位，每一位存储还要等几天就能穿 or 已经洗了几天。

**前者**似乎好写，我们用 $dp_{i,j}$ 表示第 $i$ 天，洗衣状态为 $j$ 的最大舒适感，满足 dp 条件。

通过样例解释发现第 $i$ 天穿了衣服，第 $i+y+1$ 天才能穿。

所以 $j$ 是 $n$ 位 $7$ 进制数（每一位范围是 $0\sim 6$）表示**从明天开始**还有几天能穿（若这一位是 $0$，那么**明天就能穿**；今天穿的衣服这一位**在今天**为 $y$）。

转移时，我们从 $i$ 往 $i+1$ 转移，这样将 $j$ 里所有非 $0$ 位全部减 $1$ ，再将**明天**穿的衣服那一位设为它的 $y$ 就是明天的状态。注意所有 $j$ 里为 $0$ 的位都是明天能穿的。

注意存在负数，所以 dp 初始值设为 $-\inf$，一开始 $dp_{0,0}=0$，转移时如果 $dp_{i,j}=-\inf$ 就不转移，避免一些奇奇怪怪的问题。

无解时显然是第 $i$ 位所有的 $dp_{i,j}$ 都等于 $-\inf$，自然 $dp_{n,j}$ 也都等于 $-inf$。

似乎要**开 long long**。

Code（含注释）：

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <iomanip>
#include <cmath>
#include <queue>
#include <stack>
#include <set>
#include <vector>
#include <cstring>
#include <algorithm>
#include <unordered_map>
#include <map>
#include <stack>
using namespace std;
typedef long long ll;
const int N = 2005;
int x[4], y[4], pw[6];//pw[i] 表示 7^i
ll z[N], dp[N][2401];//7^4=2401
int spl(int x, int p) {
    return x / pw[p] % 7;//获得 7 进制数第 p 位是多少
}
int d(int x, int n) {
    int res = x;
    for (int i = 0; i < n; i++)
        if (spl(x, i))
            res -= pw[i];
    return res;//将 n 位 7 进制数 x 非 0 位全部减 1
}
int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i++)
        scanf("%d", &x[i]);
    for (int i = 0; i < n; i++)
        scanf("%d", &y[i]);
    for (int i = 1; i <= m; i++)
        scanf("%lld", &z[i]);
    memset(dp, -0x7f, sizeof(dp));
    dp[0][0] = 0;//初始化
    pw[0] = 1;
    for (int i = 1; i <= n + 1; i++)
        pw[i] = pw[i - 1] * 7;//初始化 pw 数组
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < pw[n]; j++) {
            if (dp[i][j] < -1e18)
                continue;//无解就不转移
            for (int k = 0; k < n; k++) {
                if (!spl(j, k)) {//枚举每个可穿的衣服
                    int v = d(j, n) + y[k] * pw[k];//明天的状态
                    dp[i + 1][v] = max(dp[i + 1][v], dp[i][j] + z[i + 1] * x[k]);//转移，注意每个 dp[i][j] 可以有多个 dp[i-1][j'] 转移过来
                }
            }
        }
    }
    ll ans = -1e18;
    for (int j = 0; j < pw[n]; j++) {
        ans = max(ans, dp[m][j]);
    }
    if (ans != -1e18)//判无解
        printf("%lld\n", ans);
    else
        printf("gcd loves her clothes!\n");
    return 0;
}
```

Thanks for reading...

---

## 作者：Link_Cut_Y (赞：1)

[博客园观看效果更佳](https://www.cnblogs.com/LcyRegister/)

### 题意

gcd 共有 $n$ 件衣服，编号为 $A_1,A_2,\cdots A_n$。

每一件衣服分别拥有颜色值和清洗时间，他在每一件衣服穿完以后都会将其送去清洗，而这件衣服当天所拥有的舒适感取决于当天的天气与他的衣服颜色值的乘积，天气值存在负数。

现给出共 $m$ 天的天气情况，求最大舒适值。

### 分析

数据范围极小，考虑状压。

设当前状态为 $f_{i, j}$ 表示已经过完了第 $i$ 天，过完第 $i$ 天之后的衣服状态为 $j$。其中 $j$ 是一个 $7$ 进制数，它的第 $k$ 位表示第 $k$ 件衣服还需要洗几天。（若 $j = 0$，则表示不需要洗了，可以直接用。）

由于本人比较懒，因此直接用了**十进制**数代替七进制。（因此拿到了最劣解）。

显然，刷表的状态转移方程如下：

$$f_{i + 1, t} = \max(f_{i + 1, t}, f_{i, s} + col_k \times w_{i + 1})$$

其中 $i$ 表示前一天，$i + 1$ 表示后一天，$k$表示今天要穿的衣服，$s, t$ 分别表示第 $i$ 天和第 $i + 1$ 天的状态。

总状态数最劣为 $O(m \times \prod y_i)$ 个，在题目数据范围内可过。为了加速，可以提前处理出可用状态。

### 代码示例

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <cmath>
#define rep(i, a, b) for (int i = (a); i <= (b); i ++ )

using namespace std;

using LL = long long;
const int N = 2010;

int n, m;
int c[N], t[N], w[N];
LL f[N][7000];
vector<int> state;

int get(int x, int k) { // 取出 x 的第 k 位
    int res; while (k) res = x % 10, x /= 10, k -- ;
    return res;
}

bool check(int s) { // 判断状态 s 是否可用
    //  判断条件：1. 没有一位大于它最大的清洗时间
    //  2. 必须有至少以为是 0，否则 gcd 将没有衣服穿
    for (int i = 1; i <= n; i ++ ) if (get(s, i) > t[i]) return false;
    for (int i = 1; i <= n; i ++ ) if (!get(s, i)) return true;
    return false;
}

int modify(int s, int k) { // 改动 s 的第 k 位
    //  即：其他衣服的清洗时间 - 1，第 k 天的重置位 t[k]
    int ans = 0;
    for (int i = n; i; i -- )
        if (i == k) ans = ans * 10 + t[k];
        else ans = ans * 10 + (get(s, i) > 0 ? get(s, i) - 1 : 0);
    return ans;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ )
        scanf("%d", &c[i]);
    for (int i = 1; i <= n; i ++ )
        scanf("%d", &t[i]);
    for (int i = 1; i <= m; i ++ )
        scanf("%d", &w[i]);
    
    for (int i = 0; i < pow(10, n); i ++ ) // 枚举可用状态
        if (check(i))
            state.push_back(i); // 并存储
	
    memset(f, -0x7f, sizeof f);
    f[0][0] = 0;
    for (int i = 0; i < m; i ++ )
        for (auto j : state)
            for (int k = 1; k <= n; k ++ )
                if (f[i][j] != -0x7f7f7f7f && !get(j, k))
                    f[i + 1][modify(j, k)] = max(f[i + 1][modify(j, k)], f[i][j] + w[i + 1] * c[k]);
    
    LL res = -0x7f7f7f7f;
    for (auto i : state)
        res = max(res, f[m][i]);
    if (res == -0x7f7f7f7f) puts("gcd loves her clothes!");
    else printf("%lld\n", res);

    return 0;
}
```

---

## 作者：hanzhongtlx (赞：1)

小数据范围容易想到状压。  

而且发现 $y$ 很小，所以我们状压的方向也就确定了。  

我们考虑将一个四位数字（可以认为是 $7$ 进制数字）的每一位代表一个衣服还差几天就能洗完，特殊的，如果这一位是 $0$，说明对应的衣服可用。  

我们只需要枚举所有可行的下一步，更新一下就好了（虽然模拟起来比较麻烦）。  

我比较菜，复杂度是 $\mathcal O(7^nmn^2)$，，，但是可过。  

```
#include"iostream"
#include"cstring"
#include"cstdio"
#include"cmath"
using namespace std;

#define read(x) scanf("%d",&x)
#define ll long long 
#define MAXN 2005

ll dp[2405][MAXN];
int n,m,sta=0;
int x[10],y[10],z[MAXN];
ll ans=-1ll<<62;

int main()
{
	for(int i=0;i<=2400;i++)
	{
		for(int j=0;j<=2000;j++) dp[i][j]=-1ll<<62;
	}
	dp[0][0]=0;
	read(n),read(m);
	for(int i=1;i<=n;i++) read(x[i]);
	for(int i=1;i<=n;i++) read(y[i]);
	for(int i=1;i<=m;i++) read(z[i]);
	for(int i=0;i<m;i++)
	{
		for(int s=0;s<2400;s++)
		{
			if(dp[s][i]<(-1ll<<60)) continue;
			int a[5];
			memset(a,0,sizeof(a));
			int ns=s;
			a[1]=ns/343,ns%=343;
			a[2]=ns/49,ns%=49;
			a[3]=ns/7,ns%=7;
			a[4]=ns;
			for(int k=4;k>=4-n+1;k--)
			{
				if(!a[k])
				{
					int b[5];
					memset(b,0,sizeof(b));
					b[k]=y[4-k+1];
					for(int o=4;o>=4-n+1;o--)
					{
						if(o!=k&&a[o]) b[o]=a[o]-1;
					}
					int ss=b[1]*343+b[2]*49+b[3]*7+b[4];
					dp[ss][i+1]=max(dp[ss][i+1],dp[s][i]+z[i+1]*x[4-k+1]);
				}
			}
		}
	}
	for(int i=0;i<2400;i++) ans=max(ans,dp[i][m]);
	if(ans<(-1ll<<60)) printf("gcd loves her clothes!");
	else printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：木木！ (赞：1)

考虑状压，发现每个阶段的状态最多只有$7^4=2401$个，稳过。但是我们发现7和8很接近，就可以将状态转化成八进制，利用位运算加速。

转移的时候，由于有大量无用状态，使用刷表DP。虽然使用八进制让状态数变多了，但是多余的状态不过就是多个`if`的事情，耗费不大。

时间复杂度$\Theta(m\times(1+maxy)^n)$

附AC代码：

```cpp
#include <cstdio>
using namespace std;

#define reg register

inline void chkmax(long long& a,long long b)
{
	if(a<b)
	{
		a = b;
	}
}

long long dp[2005][4505];
int dped[2005][4505];

long long ci[15];
int yi[15];
long long wi[2005];

inline int nxt(int stt,int n)
{
	reg int res = 0;
	for(reg int i=1; i<=n; ++i)
	{
		if((stt>>(3*i-3))&7)
		{
			res |= (((stt>>(3*i-3))&7)-1)<<(3*i-3);
		}
	}
	return res;
}

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; ++i)
	{
		scanf("%lld",ci+i);
	}
	for(int i=1; i<=n; ++i)
	{
		scanf("%d",yi+i);
	}
	for(int i=1; i<=m; ++i)
	{
		scanf("%lld",wi+i);
	}
	
	int mstat = 1<<(n*3);
	
	dped[1][0] = 1;
	for(int i=1; i<=m; ++i)
	{
		for(int j=0; j<=mstat; ++j)
		{
			if(!dped[i][j])
			{
				continue;
			}
			
			for(int k=1; k<=n; ++k)
			{
				int thd = (j>>(3*k-3))&7;
				if(thd)
				{
					continue;
				}
				
				int nxtstt = nxt(j,n)|(yi[k]<<(3*k-3));
					
				if(!dped[i+1][nxtstt])
				{
					dped[i+1][nxtstt] = 1;
					dp[i+1][nxtstt] = dp[i][j]+wi[i]*ci[k];
				}
				else
				{
					chkmax(dp[i+1][nxtstt], dp[i][j]+wi[i]*ci[k]);
				}
			}
		}
	}
	
	long long ans = 0x8080808080808080LL;
	for(int i=0; i<=mstat; ++i)
	{
		if(dped[m+1][i])
		{
			chkmax(ans,dp[m+1][i]);
		}
	}
	
	if(ans^(0x8080808080808080LL))
	{
		printf("%lld",ans);
	}
	else
	{
		printf("gcd loves her clothes!");
	}
}
```

没加快读，时间280ms全站最劣QwQ

---

## 作者：kkxacj (赞：1)

[P4928 [MtOI2018] 衣服？身外之物！](https://www.luogu.com.cn/problem/P4928)

#### 前言

数组开小调了大概两页...

#### 思路

看到数据范围，最多四件衣服，每个衣服最多洗六天，考虑 $4$ 位 $7$ 进制状压，从第 $i$ 天推出第 $i + 1$ 天的情况，记录每一个衣服还要洗几天，初始条件是第零天所有衣服都还没洗值为 $0$，转移就是枚举每一件衣服，如果现在可以穿，就去更新一遍值，注意更新的新的状态为**将所有还需要洗的衣服的天数减一天在加上枚举的这件衣服重新洗的天数**，由于每一天的状态只和前一天有关系，所以可以压掉天数，注意判断无解的情况。

code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[10],b[10],c[2010];
long long f[3][(4 << 10)],cf[10] = {0,1,7,49,343,2401,2401 * 7},op,l,ans = -1e17;//cf为进制 
inline bool check(int x,int y)
{
	return x / cf[y] % 7;
}
inline int check1(int x)//还需要洗的衣服都要减一天 
{
    int an = x;
    for(int i = 1;i <= n;i++)
        if(check(x,i))
            an -= cf[i];
    return an;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i <= n;i++) scanf("%d",&a[i]);
	for(int i = 1;i <= n;i++) scanf("%d",&b[i]);
	for(int i = 1;i <= m;i++) scanf("%d",&c[i]);
	for(int j = 0;j < cf[n + 1];j++) f[0][j] = f[1][j] = -1e17;
	f[0][0] = 0;
	for(int i = 0;i < m;i++)
	{
		for(int j = 0;j < cf[n + 1];j++)
		{
			if(f[op][j] <= -1e17) continue;
			for(int z = 1;z <= n;z++)
				if(!check(j,z))//明天可以穿 
					f[!op][check1(j) + b[z] * cf[z]] = max(f[!op][check1(j) + b[z] * cf[z]],f[op][j] + a[z] * c[i + 1]);
		}
		for(int j = 0;j < cf[n + 1];j++) f[op][j] = -1e17;//记得清零 
		op = !op;
	}
	for(int i = 0;i < cf[n + 1];i++) ans = max(ans,f[op][i]);
	if(ans == -1e17) printf("gcd loves her clothes!");
	else printf("%lld",ans);
	return 0;
}
```


---

## 作者：liugh_ (赞：0)

## [[MtOI2018] 衣服？身外之物！](https://www.luogu.com.cn/problem/P4928)

贪心难以保存每件衣服的状态，考虑 dp。观察到 $n$ 和 $y_i$ 都很小，考虑加入状态，设 $f(i,s)$ 为考虑完前 $i$ 天，当前第 $j$ 件衣服还需要等 $s_j$ 天时的最大价值，于是我们能选第 $j$ 件衣服当且仅当 $s_j=0$，若选了 $j$ 则 $s_j\gets y_j$，同时对于所有 $k\ne j$ 令 $s_k\gets \max\{s_k-1,0\}$。时间复杂度 $\Theta(nw^4)$，其中 $w=7$。

关于记搜有个要注意的点，$f$ 的初始值不能与答案值域相交，一开始设成 $-1$ 被坑惨了……

```cpp
array<int,5> s;
int dfs(int stp){
    if(stp>m)return 0;
    int id=1;
    for(int i=1;i<=n;i++)id=id*7+s[i];
    if(f[stp][id]!=-inf)return f[stp][id];
    int res=-inf;
    auto bk=s;
    for(int i=1;i<=n;i++)if(s[i]==0){
        for(int i=1;i<=n;i++)tomax(--s[i],0);
        s[i]=y[i];
        tomax(res,z[stp]*x[i]+dfs(stp+1));
        s=bk;
    }
    return f[stp][id]=res;
}
```

---

## 作者：_Wind_Leaves_ShaDow_ (赞：0)

眼瞎了把 $y\le6$ 看成 $y<6$。

发现 $n\le4,y\le6$ 这种抽象数据就可以往状压去想了。

这题状压比较显然的，用一个 $7$ 进制数维护这一天结束时每件衣服还要几天才能用。设 $dp_{i,j}$ 表示第 $i$ 天结束时衣服的状态。

发现有很多状态用不到，而且填表的话不好写转移来的状态，可以考虑刷表法。

滚动数组常见 trick，注意有负数。

```cpp
#include <bits/stdc++.h>
#define int long long
#define Rg register
#define Ri Rg int
#define Il inline
#define vec vector
#define pb push_back
#define fi first
#define se second
#define IT ::iterator

using namespace std;

typedef double db;
//typedef long long ll;
typedef pair<int,int> pii;
const int N=2000,M=16807,Inf=1e18;
const db eps=1e-9;

int pw[6]={1,7,49,343,2401,16807};

Il int nm(int x,int p){return x/pw[p]%7;}//查询位数

int n,m,dp[2][M+5],co[5],ct[5],we[N+5];
vec<int>v;

Il int chg(int z){//模拟一天过完
	for(Ri i=0;i<n;i++)if(nm(z,i))z-=pw[i];
	return z;
}

Il void solve(int d,int z){
	if(dp[d&1][z]==-Inf)return;//兀余状态
	for(Ri i=0;i<n;i++)if(nm(z,i)>ct[i+1])return;//不合法状态
	for(Ri i=0;i<n;i++)if(!nm(z,i))dp[(d&1)^1][chg(z)+pw[i]*ct[i+1]]=max(dp[(d&1)^1][chg(z)+pw[i]*ct[i+1]],dp[d&1][z]+we[d+1]*co[i+1]);//应该看得懂的转移
	dp[d&1][z]=-Inf;//进入下一行，所以把这一行当做下一行初始化。
	return;
}

signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(Ri i=1;i<=n;i++)cin>>co[i];
	for(Ri i=1;i<=n;i++)cin>>ct[i];
	for(Ri i=1;i<=m;i++)cin>>we[i];
	for(Ri j=0;j<pw[n];j++)dp[0][j]=dp[1][j]=-Inf;
	for(Ri i=0;i<n;i++)dp[1][pw[i]*ct[i+1]]=we[1]*co[i+1];
	for(Ri i=1;i<m;i++)for(Ri j=0;j<pw[n];j++)solve(i,j);
	int ans=-Inf;
	for(Ri i=0;i<pw[n];i++)ans=max(ans,dp[m&1][i]);
	if(ans!=-Inf)cout<<ans;
	else cout<<"gcd loves her clothes!";
	return 0;
}
```

---


# 毒瘤之神秘通道

## 题目背景

~~Viston就是一个小蒟蒻 By CYJian（自己YY出来的）~~         
Viston最喜欢冒险了。

## 题目描述

~~（假的算法标签）~~
Viston发现了一个巨大的城堡，他走了进去，城堡里有一个巨大的房间，Viston进去打算参观参观，然后.......他就被困在里面了。   Viston发现了在房间里有很多同样冒险者和一个个通道，冒险者们一个个冲向了不同的**通道**，而Viston一脸懵逼。    

Viston动用他莫大的蒟蒻之力摸清了这些**通道**是什么东东~~厉害吧~~，他们是一些单向**通道**，而这些**通道**会把你传送到另一些房间里，一个房间里有一个传送到另一个房间里的传送门。     

已知所有的房间最后都通向一个地方，那就是出口。但传送门把你传送到另一个房间也是需要时间的，这个时间取决于之前有多少人使用过这个传送门，计算公式是
$$T=M$$,其中$M$表示传送门的使用人数。 ~~（你前面发啥呆啊，其他人早走光了。）~~

Viston记得每个通道有多少人进入，也探测出了每个房间里的传送门通向哪里，他想知道他从哪个通道进入初始房间才能最快的到达出口，~~毕竟Viston还想着颓金拱门呢。~~

### 注意:只有使用传送门消耗时间,而通道（即到达初始房间）不消耗时间!!!

## 说明/提示

## 样例解释
（用的WindowsXP画图画的不好请见谅）               
![](https://i.loli.net/2018/10/05/5bb7632fb40f4.jpg)
 
对于1-5号测试点(10 pts): $1 \leq N, M \leq 50$

对于6-10号测试点(20 pts): $1 \leq N, M \leq 5000$

对于11-15号测试点(30 pts): $1 \leq N, M \leq 100000$

对于16-20号测试点(40 pts): $1 \leq N, M \leq 1000000$

对于5，10，15，20号测试点，给定的树为随机生成。

保证答案都在long long范围内..


$\color{white}\text{这样你才能看出来随机树强度有多低}$   

@[Viston](https://www.luogu.org/space/show?uid=107101)

$\color{white}\text{（还想卡树剖的）}$


## 样例 #1

### 输入

```
5 2
0
1
2
2
4
5 10
3 10
```

### 输出

```
3 50```

# 题解

## 作者：Viston (赞：2)

自己的题怎么能不发篇题解呢qwq     
~~（出题人自己觉得实际上可以用树剖的）~~   
然后CYJian大佬一看：

> “这不就是两遍拓补排序吗....”    

经过了这段话后...我是豁然开朗......     

```
#include <bits/stdc++.h>
#define reg register
#define ge getchar()
#define Num(a) isdigit(a)
#define maxn 2000000
inline long long read() {
    reg long long x = 0, ch = ge;
    while(!Num(ch)) ch = ge;
    while(Num(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = ge;
    return x;
}
inline long long min(long long a,long long b){return a>b?b:a;}
int n, m,from[maxn + 1],gotoo[maxn + 1];
long long dis[maxn + 1],s[maxn + 1],q[maxn + 1];
int main() {
    n = read(), m = read();
    for(reg int i=1;i<=n;i++) 
        ++from[gotoo[i]=read()];
    for(reg int i=1;i<=m;i++) 
        ++from[gotoo[i+n]=read()],dis[i+n]=read();
    reg int x,L=1,R=0,Top=0;
    for(x=1;x<=m;++x) 
        q[++R] = x + n;
    for(x=1;x<=n;++x) 
        if(!from[x])q[++R]=x;
    while(L<=R) {
        s[++Top] = x = q[L++];
        if(!gotoo[x]) continue;
        --from[gotoo[x]];
        if(!from[gotoo[x]]) q[++R]=gotoo[x];
        dis[gotoo[x]]+=dis[x];
    }
    while(gotoo[s[Top]]==0)--Top;
    while(Top)x=s[Top--],dis[x]+=dis[gotoo[x]];
    reg long long res=2147483647LL*2147483647LL;
    reg int pos = 0;
    for(reg int i = 1; i <= m; i++) {
        res=min(res,dis[gotoo[i+n]]);
        if(dis[gotoo[i+n]]==res)
            pos=gotoo[i+n];
    }
    printf("%d %lld", pos, res);
    return 0;
}
   
```
代码略丑请见谅....

---

## 作者：D2T1 (赞：1)

# 题解 [LuoguP4974] 毒瘤之神秘通道

[link](https://www.luogu.com.cn/problem/P4974)

## 题意

原题面有点乱，这里补充个简易题面：

- 一棵 $m$ 个节点的树，初始边权为 $0$，根节点为 $0$；
- 有 $n$ 个操作，第 $i$ 个操作给出 $a_i,b_i$，把路径 $a\to0$ 上的边权值分别加上 $b_i$；
- 定义 $u\to v$ 的路径长度为路径 $u\to v$ 上的边权值和；
- 求出 $0\to a_i$ 的路径长度最小值，若有多个最小值，输出 $a_i$ 最大的那一个。

## 题解

记 $val_i$ 为 $a_i\to fa_{a_i}$ 的边权。

首先读入每个节点 $i$ 的父亲 $fa_i$，将 $val_{a_i}$ 设为 $b_i$，记录每个节点的入度。

然后进行拓扑排序，排序过程中每遍历到一个节点 $i$，就把 $val_{fa_i}$ 加上 $val_i$ 即可。因为离根节点越近的节点被遍历到的时间就越晚，可以保证所有到根节点的路径上节点的遍历时间单调递增。

这里就计算完成了一个数组 $val_i$，表示操作完成后 $a_i\to fa_{a_i}$ 的边权。

接着重新建图，连边 $fa_i\to i$，权值为 $val_i$，从 $0$ 节点开始 dfs，即可求出每个节点到 $0$ 的路径长度。挑出所有 $a_i$ 计算即可。

```cpp
//P4974
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 10;
long long val[N], ans[N], res = 0x7fffffffffffffff;
int n, m, fa[N], ind[N], ist[N], pos;
vector<int> g[N];

void dfs(int x){
	for(int i = 0; i < g[x].size(); ++ i){
		int y = g[x][i];
		ans[y] = ans[x] + val[y];
		dfs(y);
	}
}

int main(){
	scanf("%d%d", &m, &n);
	for(int i = 1, p; i <= m; ++ i){
		scanf("%d", &p);
		fa[i] = p;
		++ind[p];
	}
	for(int i = 1, a, b; i <= n; ++ i){
		scanf("%d%d", &a, &b);
		ist[a] = 1;
		val[a] += b;
	}
	//拓扑排序 
	queue<int> q;
	for(int i = 0; i <= m; ++ i){
		if(!ind[i]) q.push(i);
	}
	while(!q.empty()){
		int t = q.front();
		q.pop();
		val[fa[t]] += val[t];
		-- ind[fa[t]];
		if(!ind[fa[t]]) q.push(fa[t]);
	}
	//dfs 
	for(int i = 1; i <= m; ++ i){
		g[fa[i]].push_back(i);
	}
	dfs(0);
	for(int i = 0; i <= m; ++ i){
		if(ist[i] && ans[i] <= res) res = ans[i], pos = i;
	}
	printf("%d %lld\n", pos, res);
	return 0;
} 
```

---


# 【烂题杯 Round 1】消灭劳嗝

## 题目描述

你需要消灭劳嗝。

给定一个长度为 $n$ 的排列 $A=a_1,a_2,\cdots,a_n$，定义 $S_i=\{x|x\ge i\land \max_{i\le k\le x}a_k\le a_x\}$，您可以把它理解为以 $i$ 开头的后缀的前缀最大值的下标集合。例如对于 $A=\{3,5,2,1,4\}$，$S_1=\{1,2\}$，$S_3=\{3,5\}$。

有 $q$ 次询问，每次询问给出 $l,r$，求：

$$
\left(\left(\sum_{l\le x\le y\le r} |S_x\cup S_y|-\sum_{\substack{{1\le x<l}\\{r<y\le n}}} |S_x\cup S_y|\right)\bmod P+P\right)\bmod P
$$

其中，$P=998244353$。

## 说明/提示

**样例 1 解释：**

操作后 $A=\{1,5,4,2,3\}$。

对询问解密后真实询问如下：

```
4 5
2 3
1 5
3 4
3 5
```

对输出解密后真实输出如下：

```
5
998244350
33
1
11
```

对于第一个询问，$S_4=\{4,5\}$，$S_5=\{5\}$，$|S_4\cup S_4|+|S_4\cup S_5|+|S_5\cup S_5|=5$。

对于倒数第二个询问，不要忘了 $1\le x<l,r<y\le n$ 的项。

**数据范围：**

对于 $20\%$ 的数据，满足 $1\le n\le 100$、$1\le q\le 100$。

对于 $40\%$ 的数据，满足 $1\le n\le 100$、$1\le q\le 10^5$。

对于 $60\%$ 的数据，满足 $1\le n\le 10^5$、$1\le q\le 10^5$。

对于 $80\%$ 的数据，满足 $1\le n\le 3\times10^6$、$1\le q\le 3\times10^6$。

对于 $100\%$ 的数据，满足 $1\le n\le 10^7$，$1\le q\le 10^7$，$0\le c\le 10^7$，$0\le X\le 10^9$，$a_i$ 互不相同。

**请各位选手注意常数因子的影响。**

## 样例 #1

### 输入

```
5 3
4
5```

### 输出

```
998244304```

## 样例 #2

### 输入

```
10 114514
191981
3```

### 输出

```
998244191```

# 题解

## 作者：ZnPdCo (赞：10)

发现 $|S_x\cup S_y|=|S_x|+|S_y|-|S_x\cap S_y|$，前面两项容易通过前缀和计算，所以我们只需要求出最后一项就好了。发现 $|S_x\cap S_y|=\min_{i=x}^{y-1} |S_i|-1$，证明不难理解，就是从后往前做单调栈时，单调栈内元素最少的一刻就是两集合的交。

所以现在我们的问题就变成了求：

$$
(\sum_{l\le x\le y\le r} \min_{i=x}^{y-1}|S_i|-1)-(\sum_{\substack{{1\le x<l}\\{r<y\le r}}} \min_{i=x}^{y-1}|S_i|-1)
$$

定义 $L_i=\sum_{1\le x < y\le i} \min_{i=x}^{y-1}|S_i|$，$R_i=\sum_{i\le x < y\le n} \min_{i=x}^{y-1}|S_i|$。

考虑怎么快速计算上述的值，可以考虑每加入一个数对答案的贡献，发现 $L_i$ 比 $L_{i-1}$ 多了一个以 $i$ 为右端点的贡献，分为对比他大的区间的贡献与比他小的区间的贡献，用单调栈即可维护。

根据容斥，上述式子的值为 $L_r+R_l-L_n$。

综上，总复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>
#define N 10000010
#define P 998244353
#define ll long long
using namespace std;
namespace IO{
	const int sz=1<<22;
	char a[sz+5],b[sz+5],*p1=a,*p2=a,*t=b,p[105];
	inline char gc(){
		return p1==p2?(p2=(p1=a)+fread(a,1,sz,stdin),p1==p2?EOF:*p1++):*p1++;
	}
	template<class T> void read(T& x){
		x=0; char c=gc();
		for(;c<'0'||c>'9';c=gc());
		for(;c>='0'&&c<='9';c=gc())
			x=x*10+(c-'0');
	}
	inline void flush(){fwrite(b,1,t-b,stdout),t=b; }
	inline void pc(char x){*t++=x; if(t-b==sz) flush(); }
	template<class T> void write(T x,char c='\n'){
		if(x<0) pc('-'), x=-x;
		if(x==0) pc('0'); int t=0;
		for(;x;x/=10) p[++t]=x%10+'0';
		for(;t;--t) pc(p[t]); pc(c);
	}
	struct F{~F(){flush();}}f;
}
using IO::read;
using IO::write;
int n, c, q, a[N], nxt[N], f[N], sta[N], top;
ll L[N], R[N], sum, s[N], X;
int main() {
	read(n), read(X), read(c);
	for(int i = 1; i <= n; i ++) {
		a[i] = i;
	}
	for(int i = 1; i <= c; i ++) {
		int l, r;
		l = (X * (X ^ i)) % n + 1;
		r = (X ^ (1ll * i * i)) % n + 1;
		swap(a[l], a[r]);
	}
	top = 0, sta[top] = n + 1;
	for(int i = n; i >= 1; i --) {
		while(top && a[sta[top]] < a[i]) top --;
		nxt[i] = sta[top];
		sta[++ top] = i;
	}
	for(int i = n; i >= 1; i --)
		f[i] = 1 + f[nxt[i]];
	for(int i = 1; i <= n; i ++)
		s[i] = (s[i - 1] + f[i]) % P;
	top = 0, sta[top] = 0;
	for(int i = 1; i < n; i ++) {
		while(top && f[sta[top]] > f[i]) {
			sum -= 1ll * (f[sta[top]] - 1) * (sta[top] - sta[top - 1]) % P;
			sum = (sum % P + P) % P;
			top --;
		}
		sum += 1ll * (f[i] - 1) * (i - sta[top]) % P;
		sum = (sum % P + P) % P;
		sta[++ top] = i;
		L[i] = (L[i - 1] + sum) % P;
	}
	top = 0, sum = 0, sta[top] = n;
	for(int i = n - 1; i >= 1; i --) {
		while(top && f[sta[top]] > f[i]) {
			sum -= 1ll * (f[sta[top]] - 1) * (sta[top - 1] - sta[top]) % P;
			top --;
		}
		sum += 1ll * (f[i] - 1) * (sta[top] - i) % P;
		sum = (sum % P + P) % P;
		sta[++ top] = i;
		R[i] = (R[i + 1] + sum) % P;
	}
	read(q);
	ll res = 0;
	for(ll i = 1; i <= q; i ++) {
		int l, r;
		l = min((X * i + (X ^ (X * i))) % n, (X - i + (X ^ (X + i))) % n) + 1;
		r = max((X * i + (X ^ (X * i))) % n, (X - i + (X ^ (X + i))) % n) + 1;
		ll ans = (s[r] - s[l - 1]) * (r - l) % P - 
			s[l - 1] * (n - r) % P - 
			(s[n] - s[r]) * (l - 1) % P - 
			(L[r - 1] + R[l] - L[n - 1]) % P +
		(s[r] - s[l - 1]) % P;
		ans = (ans % P + P) % P;
		res ^= ans;
	}
	write(res);
}
```

---

## 作者：DaiRuiChen007 (赞：2)

[Problem Link](https://www.luogu.com.cn/problem/P10891)

**题目大意**

> 给定 $n$ 阶排列 $a_1\sim a_n$，定义 $S_i$ 表示 $a[i,n]$ 的前缀最大值对应的下标集合。
>
> $q$ 次询问给定 $l,r$，求 $\sum_{l\le x\le y\le r} |S_x\cup S_y|-\sum_{x<l\le r<y} |S_x\cup S_y|$。
>
> 数据范围：$n,q\le 10^7$。

**思路分析**

显然 $|S_x\cup S_y|$ 不好求，但可以用容斥原理转成 $|S_x\cap S_y|$。

考虑这个东西怎么刻画，不妨设 $x<y$，那么 $S_x\cap S_y$ 等于 $S_x$ 中 $\ge y$ 的元素构成的集合。

但这个刻画方式依然关系 $S_x$ 的具体结构，考虑另一种刻画方法，找到 $S_x$ 中 $<y$ 的最大元素 $z$，容易发现插入 $z$ 后 $S_z=S_x\cap S_y+\{z\}$。

又因为对于所有 $i\in [x,y),|S_x\cap S_y|<S_i$，因此 $|S_x\cap S_y|=\min_{i=x}^{y-1}|S_i|-1$。

这样我们就成功地将问原式转成和 $S$ 无关的结构了。

设 $f(L,R)=\sum_{x\in L,y\in R,x\le y}|S_x\cap S_y|$，那么我们要求的就是 $f([1,l),(r,n])-f([l,r],[l,r])$，不难发现这就等于 $f([1,n],[1,n])-f([1,r],[1,r])-f([l,n],[l,n])$。

那么我们只要预处理 $L_i=f([1,i],[1,i])$ 和 $R_i=f([i,n],[i,n])$ 即可，用单调栈维护 $i\to i-1/i+1$ 时的变化量（所有后缀 $\min$ 之和）即可，这是容易的。

时间复杂度 $\mathcal O(n+q)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=1e7+5,MOD=998244353;
int n,X,C,q,a[MAXN];
int stk[MAXN],tp,pre[MAXN],s[MAXN];
int fl[MAXN],fr[MAXN];
ll W(ll x) { return x*(x+1)>>1; }
signed main() {
	scanf("%d%d%d%d",&n,&X,&C,&q);
	iota(a+1,a+n+1,1);
	for(int i=1,l,r;i<=C;++i) {
		l=(1ll*X*(X^i))%n+1;
		r=(X^(1ll*i*i))%n+1;
		swap(a[l],a[r]);
	}
	for(int i=n;i>=1;--i) {
		while(tp&&a[stk[tp]]<a[i]) pre[stk[tp--]]=i+1;
		stk[++tp]=i,s[i]=tp;
	}
	for(int i=1;i<=tp;++i) pre[stk[i]]=1;
	stk[tp=0]=0;
	for(int i=1,sum=0;i<n;++i) {
		while(tp&&s[stk[tp]]>s[i]) {
			sum=(sum-1ll*(s[stk[tp]]-1)*(stk[tp]-stk[tp-1]))%MOD,--tp;
		}
		sum=(sum+1ll*(s[i]-1)*(i-stk[tp]))%MOD,stk[++tp]=i;
		if(sum<0) sum+=MOD;
		fl[i+1]=(fl[i]+sum)%MOD;
	}
	stk[tp=0]=n;
	for(int i=n-1,sum=0;i>=1;--i) {
		while(tp&&s[stk[tp]]>s[i]) {
			sum=(sum-1ll*(s[stk[tp]]-1)*(stk[tp-1]-stk[tp]))%MOD,--tp;
		}
		sum=(sum+1ll*(s[i]-1)*(stk[tp]-i))%MOD,stk[++tp]=i;
		if(sum<0) sum+=MOD;
		fr[i]=(fr[i+1]+sum)%MOD;
	}
	for(int i=1;i<=n;++i) s[i]=(s[i]+s[i-1])%MOD;
	int res=0;
	for(int o=1,l,r;o<=q;++o) {
		l=(1ll*X*o+(X^(1ll*X*o)))%n+1;
		r=(X-o+(X^(X+o)))%n+1;
		if(l>r) swap(l,r);
		int ans=(1ll*(r-l+1)*(s[r]-s[l-1])%MOD+fl[n]-fl[r]-fr[l])%MOD;
		ans=(ans-1ll*(l-1)*(s[n]-s[r])%MOD-1ll*(n-r)*s[l-1]%MOD)%MOD;
		if(ans<0) ans+=MOD;
		res^=ans;
	}
	printf("%d\n",res);
	return 0;
}
```

---

## 作者：P2441M (赞：1)

$\text{Upd 2025/7/14}$：添加了对一些细节的解释。

## 题意

给定长度为 $n$ 的排列 $a$，定义 $S_i=\{x\mid x\geq i\land \max_{j=i}^xa_j\leq a_x\}$。有 $q$ 次询问，每次询问给出 $l,r$，求

$$
\sum_{l\leq x\leq y\leq r}|S_x\cup S_y|-\sum_{1\leq x<l\land r<y\leq n}|S_x\cup S_y|
$$

答案对 $998244353$ 取模。$1\leq n,q\leq 10^7$。

## 题解

消灭老哥。

还是很有意思的。

并集不好刻画，一眼容斥，将 $|S_x\cup S_y|$ 化为 $|S_x|+|S_y|-|S_x\cap S_y|$，那么式子化为

$$
\begin{align*}
&\sum_{l\leq x\leq y\leq r}|S_x\cup S_y|-\sum_{1\leq x<l\land r<y\leq n}|S_x\cup S_y|\\
=&(r-l+2)\sum_{i=l}^r|S_i|-(n-r)\sum_{i=1}^{l-1}|S_i|-(l-1)\sum_{i=r+1}^n|S_i|\\
&-\sum_{l\leq x\leq y\leq r}|S_x\cap S_y|+\sum_{1\leq x<l\land r<y\leq n}|S_x\cap S_y|\\
\end{align*}
$$

所有的 $|S_i|$ 容易用单调栈 $\mathcal{O}(n)$ 求出。预处理 $|S_i|$ 的前缀和，容易 $\mathcal{O}(1)$ 计算前面 $3$ 项。于是我们只需算出

$$
\sum_{1\leq x<l\land r<y\leq n}|S_x\cap S_y|-\sum_{l\leq x\leq y\leq r}|S_x\cap S_y|
$$

我们发现 $|S_x\cap S_y|$ 依旧不好计算，考虑刻画其性质。由于 $\max_{j=x}^i a_j\geq \max_{j=y}^ia_j$，也就是说做 $a[x,n]$ 的后缀最大值，强于做 $a[y,n]$ 的后缀最大值，因此 $S_x$ 中 $\geq y$ 的部分必然包含在 $S_y$ 中。于是 $|S_x\cap S_y|=|\{p\mid p\in S_x\land p\geq y\}|$。

接下来是巧妙的一步。考察一个最大的 $q\in S_x$ 使得 $q<y$，注意到 $a_q$ 是 $a[x,n]$ 的前缀最大值，那么

$$
\begin{align*}
&p\in S_x\land p\geq y\\
\Leftrightarrow &\max_{i=x}^pa_i\leq a_p\land p\geq y\\
\Leftrightarrow &\max_{i=\color{red}{q}}^pa_i\leq a_p\land p\geq y\\
\Leftrightarrow &p\in S_q
\end{align*}
$$

从 $S_q$ 中去除 $q$，剩余部分必然都 $\geq y$，于是我们有 $|S_x\cap S_y|=|S_q|-1$。

更进一步地，由于在 $a[q,n]$ 中成为前缀最大值的条件是 $a[i,n](x\leq i<y)$ 中最强的，类比上面的过程，我们可以发现 $|S_q|=\min_{i=x}^{y-1}|S_i|$。

于是所求式子化为

$$
\sum_{1\leq x<l\land r<y\leq n}\min_{i=x}^{y-1}s_i-\sum_{l\leq x<y\leq r}\min_{i=x}^{y-1}s_i
$$

其中 $s_i=|S_i|-1$。

**注意一个细节**：这里我们在算交集大小和时忽略了 $\bm{x=y}$ 的情况，所以前面推出来的式子中的 $(r-l+\bm{2})\sum_{i=l}^r|S_i|$ 需要改成 $(r-l+\bm{1})\sum_{i=l}^r|S_i|$。

这个形式就很利于计算了！因为我们将所求式子转化为了与 $S_i$ 具体结构完全无关的形式。

我们需要 $\mathcal{O}(1)$ 计算上式。考虑化成前后缀的形式。令

$$
\begin{align*}
L_i=\sum_{1\leq x<y\leq i}\min_{i=x}^{y-1}s_i\\
R_i=\sum_{i\leq x<y\leq n}\min_{i=x}^{y-1}s_i
\end{align*}
$$

我们发现，所求式子实际上就是 $L_n-L_r-R_l$。

最后就是如何预处理出 $L_i,R_i$，这就很典了。以 $L_i$ 为例，从小到大枚举 $i$，考虑计算当 $i\leftarrow i+1$ 时 $L_i$ 的变化量，即为

$$
d_i=\sum_{x=1}^{i-1}\min_{i=x}^{i-1}s_i
$$

我们当然希望由 $d_{i-1}$ 推出 $d_i$。后缀最值相关，考虑对 $s$ 从左到右做单调栈的过程，先令 $d_i\leftarrow d_{i-1}$，记 $t=stk_{top}$，当 $s_{t}>s_{i-1}$ 时，我们从 $d_i$ 中删去其贡献，也就是令 $d_i\leftarrow d_i-s_t(t-stk_{top-1})$，然后弹栈。最后加上 $s_{i-1}$ 的贡献即可。

时间复杂度 $\mathcal{O}(n+q)$。

## 代码

```cpp
#include <iostream>

using namespace std;

#define lowbit(x) ((x) & -(x))
#define chk_min(x, v) (x) = min((x), (v))
#define chk_max(x, v) (x) = max((x), (v))
typedef long long ll;
typedef pair<int, int> pii;
const int N = 1e7 + 5, MOD = 998244353;

inline int add(int x, int y) { return x += y, x >= MOD ? x - MOD : x; }
inline int sub(int x, int y) { return x -= y, x < 0 ? x + MOD : x; }
inline void cadd(int &x, int y) { x += y, x < MOD || (x -= MOD); }
inline void csub(int &x, int y) { x -= y, x < 0 && (x += MOD); }

int n, X, c, q, ans, fans, a[N];
int sz[N], pre[N], L[N], R[N];
int top, stk[N];

int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n >> X;
    for (int i = 1; i <= n; ++i) a[i] = i;
    cin >> c;
    for (int i = 1, l, r; i <= c; ++i)
    	l = ((ll)X * (X ^ i)) % n + 1, r = (X ^ ((ll)i * i)) % n + 1,
		swap(a[l], a[r]);
	for (int i = n; i; --i) {
		while (top && a[stk[top]] < a[i]) --top;
		sz[i] = top, stk[++top] = i;
	}
	for (int i = 1; i <= n; ++i) pre[i] = add(pre[i - 1], sz[i] + 1);
	L[1] = 0, stk[top = 0] = 0;
	int x = 0;
	for (int i = 2; i <= n; ++i) {
		while (top && sz[stk[top]] > sz[i - 1])
			csub(x, (ll)sz[stk[top]] * (stk[top] - stk[top - 1]) % MOD), --top;
		stk[++top] = i - 1, cadd(x, (ll)sz[i - 1] * (stk[top] - stk[top - 1]) % MOD);
		L[i] = add(L[i - 1], x);
	}
	R[n] = x = 0, stk[top = 0] = n;
	for (int i = n - 1; i; --i) {
		while (top && sz[stk[top]] > sz[i])
			csub(x, (ll)sz[stk[top]] * (stk[top - 1] - stk[top]) % MOD), --top;
		stk[++top] = i, cadd(x, (ll)sz[i] * (stk[top - 1] - stk[top]) % MOD);
		R[i] = add(R[i + 1], x);
	}
	cin >> q;
	for (int i = 1, l, r; i <= q; ++i) {
		l = ((ll)X * i + (X ^ ((ll)X * i))) % n + 1;
		r = (X - i + (X ^ (X + i))) % n + 1;
		if (l > r) swap(l, r);
		ans = (ll)(r - l + 1) * sub(pre[r], pre[l - 1]) % MOD;
		csub(ans, (ll)(n - r) * pre[l - 1] % MOD);
		csub(ans, (ll)(l - 1) * sub(pre[n], pre[r]) % MOD);
		cadd(ans, sub(L[n], add(L[r], R[l])));
		fans ^= ans;
	}
	cout << fans;
    return 0;
}
```

---


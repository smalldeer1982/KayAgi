# 地震逃生

## 题目描述

汶川地震发生时，四川\*\*中学正在上课，一看地震发生，老师们立刻带领 $x$ 名学生逃跑，整个学校可以抽象地看成一个有向图，图中有 $n$ 个点，$m$ 条边。$1$ 号点为教室，$n$ 号点为安全地带，每条边都只能容纳一定量的学生，超过楼就要倒塌，由于人数太多，校长决定让同学们分成几批逃生，只有第一批学生全部逃生完毕后，第二批学生才能从 $1$ 号点出发逃生，现在请你帮校长算算，每批最多能运出多少个学生，$x$ 名学生分几批才能运完。

## 说明/提示

**【注释】**

比如有图

```plain
1 2 100
2 3 1
```

$100$ 个学生先冲到 $2$ 号点，然后一个一个慢慢沿 $2 \to 3$ 边走过去。

18 神牛规定这样是不可以的……

也就是说，每批学生必须同时从起点出发，并且同时到达终点。

**【数据范围】**

对于 $100 \%$ 的数据，$0 \le x < 2^{31}$，$1 \le n \le 200$，$1 \le m \le 2000$。

## 样例 #1

### 输入

```
6 7 7
1 2 1
1 4 2
2 3 1
4 5 1
4 3 1
3 6 2
5 6 1
```

### 输出

```
3 3
```

# 题解

## 作者：hncsyjc (赞：48)

开始看错了，以为一批人不能分开走。。。

其实就是一道裸裸的网络流

答案为maxflow和取上整(x/maxflow)

用普通的网络流算法即可AC。。。


---

## 作者：lgswdn_SA (赞：22)

## 分析
我们看一下补充说明，每次只能额定的学生数量，不能出现拥挤的情况，于是它就在疯狂暗示我们这就是网络流。下面是正解。


这题肯定贪心，由于先送哪个同学没有区别，如果每次放最多的一波人出去肯定不吃亏，所以就一股脑地每次塞最多的一波人出去就行了。

所以现在是看每次最多送几个人。

然后再一看题面，这就是裸的网络流。

dinic 算法写好，算出每次最多几个人，然后除$x$就行了。

注意，没法逃走的情况即一次一个人都出不去，特判一下就好了。

数据范围呢？出题人很贴心地给我们设置了一个$n\le 200$的数据，来代表这是真的网络流，不会卡常。不过其实数据还可以再加大，因为网络流的剪枝非常厉害，$n$再大一点也无妨。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2009;
struct edge{int to,nxt,w;}e[N*2];int hd[N],tot=1;
void add(int u,int v,int w){
	e[++tot]=(edge){v,hd[u],w}; hd[u]=tot;
}

int n,m,d[N],ans,x;
bool bfs(){
	queue<int>q; memset(d,0,sizeof(d));
	q.push(1),d[1]=1;
	while(!q.empty()){
		int u=q.front(); q.pop();
		for(int i=hd[u],v;i;i=e[i].nxt)
			if(!d[v=e[i].to]&&e[i].w){
				q.push(v),d[v]=d[u]+1;
				if(v==n) return 1;
			}
	}
	return 0;
} 
int dfs(int u,int flow){
	if(u==n) return flow;
	int rest=flow;
	for(int i=hd[u],v;i&&rest;i=e[i].nxt){
		if(e[i].w&&d[v=e[i].to]==d[u]+1){
			int tmp=dfs(v,min(rest,e[i].w));
			if(!tmp) d[v]=0;
			rest-=tmp; e[i].w-=tmp; e[i^1].w+=tmp;
		}
	}
	return flow-rest; //真正给出去的 
}

int main(){
	scanf("%d%d%d",&n,&m,&x);
	for(int i=1,u,v,w;i<=m;i++)
		scanf("%d%d%d",&u,&v,&w),add(u,v,w),add(v,u,0);
	int tmp=0;
	while(bfs()) while(tmp=dfs(1,1e9)) ans+=tmp;
	if(!ans){puts("Orz Ni Jinan Saint Cow!");return 0;} 
	printf("%d ",ans);
	int a2=ceil(x*1./ans);
	printf("%d",a2);
	return 0;
}
```
**然后不知道什么是网络瘤的可以看：[我的网络流](https://www.luogu.com.cn/blog/forever-captain/wang-lao-liu-xue-xi-bi-ji)**

---

## 作者：_louhc (赞：7)

# [P1343 地震逃生](https://www.luogu.org/problemnew/show/P1343)

---

# 算法
网络最大流。 请大家先掌握，这里不详细讲。

# 思路
很明显，1是源点，n是汇点，直接网络最大流模板即可。
这里数据十分小，用Edmonds-Karp或Dinic都可以。
~~我才不告诉你EK怎么打忘光了~~
用网络流求出了每次能通过的学生数ans后，就可以直接求出分成$floor(frac{ans - 1}x) + 1$次通过。总体来说不是很难，具体看代码QAQ

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define open(s) freopen( s".in", "r", stdin ), freopen( s".out", "w", stdout )
#define MAXN 205
#define MAXM 4005
//建双向边要开两倍别忘了

int n, m, X, ans;//小写的x会冲突（下5行） QAQ 只好改大写
int hd[MAXN], nxt[MAXM], to[MAXM], val[MAXM], tot(1);//MAXN、MAXM别看错了 ~~我才不告诉你为了这个我错了好几遍~~
//还有tot要赋值为1**千万**别忘了 ~~我又为这个调试了好久~~（不用成对存储的请忽略这句话）
int dis[MAXN];
queue<int> Q;
int S, T;
int x, y;

void Add( int x, int y, int z ){nxt[++tot] = hd[x]; hd[x] = tot; to[tot] = y; val[tot] = z;}//链式前向星万岁！~~虽然邻接矩阵也可以~~

bool BFS(){//分层
	while( !Q.empty() ) Q.pop();//清空queue 懒得手打队列QAQ
	memset( dis, 0, sizeof dis );//初始化别忘了
	Q.push(S); dis[S] = 1;
	while( !Q.empty() ){
		x = Q.front(); Q.pop();
		for ( int i = hd[x]; i; i = nxt[i] ){
			if ( val[i] && !dis[to[i]] ){
				dis[to[i]] = dis[x] + 1;
				Q.push( to[i] );
				if ( to[i] == T ) return 1;
			}
		}
	}
	return 0;
}

int DFS( int x, int fl ){
	if ( x == T ) return fl;
	int res(fl), k;
	for ( int i = hd[x]; i && res; i = nxt[i] ){
		if ( ( dis[to[i]] == dis[x] + 1 ) && val[i] ){
			k = DFS( to[i], min( res, val[i] ) );
			if ( !k ) dis[to[i]] = 0; //剪枝！ 不能再增广的点去掉！
			val[i] -= k; val[i^1] += k; res -= k; //成对存储
		}
	}
	return fl - res;
}

int main(){
	scanf( "%d%d%d", &n, &m, &X );
	S = 1; T = n;
	for ( int i = 1; i <= m; ++i ){
		int x, y, z; scanf( "%d%d%d", &x, &y, &z );
		Add( x, y, z ); Add( y, x, 0 );
	}
	
	int t;
	while( BFS() ) while( ( t = DFS( S, INT_MAX ) ) > 0 ) ans += t;
	
	if ( ans ) printf( "%d %d\n", ans, ( X - 1 ) / ans + 1 );//同上
	else printf( "Orz Ni Jinan Saint Cow!\n" ); //这是谁？
	return 0;
}
```

---

## 作者：半仙胡小桃 (赞：6)

很简单的最大流

我是EK也就是动能算法（滑稽）

找1到n能通过的学生的最大人数，如果是0，就没法逃出去了

如果能逃出去就用人数除以一次逃出的人数，如果除不尽要+1次啊，不能舍下剩下的人不管了不是吗233

    
    
    
    
        
         
                  
    
           
    
    
         
         
    
    
```cpp
#include <iostream>  
#include <queue>  
#include <string.h>  
#include <queue> 
#include <cstdio>
using namespace std;  
int maxData = 0x7fffffff; 
queue<int> dl;
int flow[10001];
struct ss{
    int d;
    int wb;
};
struct node{
    int to;
    int cap;
    int rev;
};
vector<node> v[10001];
ss pre[10001];
int n,m;
void add(int from,int to,int cap)
{
    v[from].push_back((node){to,cap,v[to].size()});
    v[to].push_back((node){from,0,v[from].size()-1}); 
}
int BFS(int s,int t)
{
    while(!dl.empty())
     dl.pop();
    for(int i=1;i<=n;i++)
     pre[i].d=-1;
    pre[s].d=0;
    flow[s]=maxData;
    dl.push(s);
    while(!dl.empty())
    {
        int dd=dl.front();
        dl.pop();
        if(dd==t)
         break;
        for(int i=0;i<v[dd].size();i++)
         {
             node &tmp=v[dd][i];
             if(tmp.to!=s&&tmp.cap>0&&pre[tmp.to].d==-1)
              {
                  pre[tmp.to].d=dd;
                  pre[tmp.to].wb=i;
                  flow[tmp.to]=min(flow[dd],tmp.cap);
                  dl.push(tmp.to);
              }
         }
    }
    if(pre[t].d==-1)
     return -1;
    else 
     return flow[t];
}
int max_flow(int s,int t)
{
    int mflow=0;
    int d=0;
    while((d=BFS(s,t))!=-1)
    {
        int k=t;
        while(k!=s)
         {
           v[pre[k].d][pre[k].wb].cap-=d;
           v[k][v[pre[k].d][pre[k].wb].rev].cap+=d;
           k=pre[k].d;
         } 
        mflow+=d;
    }
    return mflow;
}
int main()
{
    int num;
    scanf("%d%d%d",&n,&m,&num);
    for(int i=1;i<=m;i++)
     {
         int x,y,c;
         scanf("%d%d%d",&x,&y,&c);
         add(x,y,c);
     }
    int c=max_flow(1,n);
    if(!c) puts("Orz Ni Jinan Saint Cow!");
    else   
    {
        printf("%d ",c);
        int s=num/c;
        if(num%c) s++;
        printf("%d",s);
    }
}
```

---

## 作者：_Fontainebleau_ (赞：4)

~~这一题一看就是一道**网络流最大流**~~。

逃生道路——>水管

学生——>水

教室——>源点

安全地带——＞汇点

最大流的精髓就在反向边
![](https://cdn.luogu.com.cn/upload/image_hosting/78wswgeo.png?x-oss-process=image/resize,m_lfit,h_170,w_225)(・◇・)？

### **基本概念**
>残量=容量-已流过的量

>反向边的流量值=正向流过的总流量，也就是说正向流过多少，反向可以流回多少。

最大流有好几种做法：$EK(edmonds-karp) or I S A P or Dicnic......$

然额，窝只会$EK$和$ISAP$,但是，$EK$貌似不太行，$so$ 我们选择$ISAP$。

![](https://cdn.luogu.com.cn/upload/image_hosting/94z0koef.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

因为，窝是自学$ISAP$的，所以代码是从你谷的[blog](https://www.luogu.com.cn/blog/ONE-PIECE/jiu-ji-di-zui-tai-liu-suan-fa-isap-yu-hlpp)里学来的，应该不算侵权⑧。
**$ISAP$模板**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=2147483647;//inf:最大值 
int cnt=1,head[13000];//cnt:第CNT条边head[i]:第i个点属于第几条边 
int n,m,s,t;//n个点m条边s:源点t:汇点 
inline int Read()
{
    int x=0;
    char c=getchar();
    while(c>'9'||c<'0')c=getchar();
    while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
    return x;
}
struct Node
{
    int v;//当前点 
    int next;//连接点 
    int val;//容量 
}node[250000];//node[i]:第i条边的情况 
inline void addedge(int u,int v,int val)
{
    node[++cnt].v=v;
    node[cnt].val=val;
    node[cnt].next=head[u];
    head[u]=cnt;
}
int dep[13000],gap[13000];//dep[i]表示节点i的深度，gap[i]表示深度为i的点的数量 
void bfs()//倒着搜 
{
    memset(dep,-1,sizeof(dep));//把深度变为-1(0会导致gap崩坏) 
    memset(gap,0,sizeof(gap));
    dep[t]=0;//汇点深度为0 
    gap[0]=1;//深度为0的点有1个 
    queue<int>q; 
    q.push(t);//t点入栈 
    while(!q.empty())
	{
        int u=q.front();
        q.pop();
        for(int i=head[u];i;i=node[i].next)//head[u]:u点所在的边,node[i].next:u点所在的边的下一个点，就这样遍历下去 
		{
            int v=node[i].v;//v为当前边的下一个点 
            if(dep[v]!=-1)	continue;//dep[v]!=-1相当于v点已被遍历||不管 
            q.push(v);
            dep[v]=dep[u]+1;//v点的深度比u点大1 
            gap[dep[v]]++;
        }//直到所有点都被遍历过 
    }
    return;
}//从t到s跑一遍bfs，标记深度
int maxflow;
int dfs(int u,int flow)
{
    if(u==t)
	{
        maxflow+=flow;
        return flow;
    }
    int used=0;
    for(int i=head[u];i;i=node[i].next)//head[u]:u点所在的边,node[i].next:u点所在的边的下一个点，就这样遍历下去 
	{
        int d=node[i].v;
        if(node[i].val&&dep[d]+1==dep[u])//如果这条边的残量大于0,且没有断层 
		{
            int mi=dfs(d,min(node[i].val,flow-used));//流量 
            if(mi)
			{
                node[i].val-=mi;//正向边-mi 
                node[i^1].val+=mi;//反向边+mi 
                used+=mi;
            }
            if(used==flow)return used;
        }
    }
    //如果已经到了这里，说明该点出去的所有点都已经流过了
    //并且从前面点传过来的流量还有剩余
    //则此时，要对该点更改dep
    //使得该点与该点出去的点分隔开
    --gap[dep[u]];
    if(gap[dep[u]]==0)dep[s]=n+1;//出现断层，无法到达t了
    dep[u]++;//层++ 
    gap[dep[u]]++;//层数对应个数++
    return used; 
}
int ISAP()
{
    maxflow=0;
    bfs();//从t到s跑一遍bfs，标记深度
    while(dep[s]<n)	dfs(s,inf);//每走一遍增广路,s的层数会加1,如果一直没有出现断层,最多跑n-dep(刚bfs完时s的深度)条增广路共有n个点 
    return maxflow;
}
int main()
{
    n=Read(),m=Read(),s=Read(),t=Read();
    int u,v,w;
    for(int i=1;i<=m;i++)
	{
		u=Read();
		v=Read();
		w=Read();
		addedge(u,v,w);//正向边 
		addedge(v,u,0);//反向边 
	}  
    printf("%d\n",ISAP());
    return 0;
}
```

但是,$but$,这道题并不是只要套上模板就珂以过的，因为，TA让我们算"每批最多能运出多少个学生，x名学生分几批才能运完。",所以，在结尾加上几句话就好了
```cpp
	int al=ISAP(),time;
	
	if(al)
	{
		time=x/al;
		if(al*time<x)	time++;
		printf("%d %d\n",al,time);
	}
    else
    	printf( "Orz Ni Jinan Saint Cow!\n"); 
    return 0;
```

附上$A C $ $code:$


------------

```cpp
#include<bits/stdc++.h>
#define MAXN 205
#define MAXM 4005
using namespace std;
const int inf=2147483647;//inf:最大值 
int cnt=1,head[MAXN];//cnt:第CNT条边head[i]:第i个点属于第几条边 
int n,m,s,t;//n个点m条边s:源点t:汇点 
inline int Read()
{
    int x=0;
    char c=getchar();
    while(c>'9'||c<'0')c=getchar();
    while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
    return x;
}
struct Node
{
    int v;//当前点 
    int next;//连接点 
    int val;//容量 
}node[MAXM];//node[i]:第i条边的情况 
inline void addedge(int u,int v,int val)
{
    node[++cnt].v=v;
    node[cnt].val=val;
    node[cnt].next=head[u];
    head[u]=cnt;
}
int dep[MAXN],gap[MAXN];//dep[i]表示节点i的深度，gap[i]表示深度为i的点的数量 
void bfs()//倒着搜 
{
    memset(dep,-1,sizeof(dep));//把深度变为-1(0会导致gap崩坏) 
    memset(gap,0,sizeof(gap));
    dep[t]=0;//汇点深度为0 
    gap[0]=1;//深度为0的点有1个 
    queue<int>q; 
    q.push(t);//t点入栈 
    while(!q.empty())
	{
        int u=q.front();
        q.pop();
        for(int i=head[u];i;i=node[i].next)//head[u]:u点所在的边,node[i].next:u点所在的边的下一个点，就这样遍历下去 
		{
            int v=node[i].v;//v为当前边的下一个点 
            if(dep[v]!=-1)	continue;//dep[v]!=-1相当于v点已被遍历||不管 
            q.push(v);
            dep[v]=dep[u]+1;//v点的深度比u点大1 
            gap[dep[v]]++;
        }//直到所有点都被遍历过 
    }
    return;
}//从t到s跑一遍bfs，标记深度
int maxflow;
int dfs(int u,int flow)
{
    if(u==t)
	{
        maxflow+=flow;
        return flow;
    }
    int used=0;
    for(int i=head[u];i;i=node[i].next)//head[u]:u点所在的边,node[i].next:u点所在的边的下一个点，就这样遍历下去 
	{
        int d=node[i].v;
        if(node[i].val&&dep[d]+1==dep[u])//如果这条边的残量大于0,且没有断层 
		{
            int mi=dfs(d,min(node[i].val,flow-used));//流量 
            if(mi)
			{
                node[i].val-=mi;//正向边-mi 
                node[i^1].val+=mi;//反向边+mi 
                used+=mi;
            }
            if(used==flow)return used;
        }
    }
    //如果已经到了这里，说明该点出去的所有点都已经流过了
    //并且从前面点传过来的流量还有剩余
    //则此时，要对该点更改dep
    //使得该点与该点出去的点分隔开
    --gap[dep[u]];
    if(gap[dep[u]]==0)dep[s]=n+1;//出现断层，无法到达t了
    dep[u]++;//层++ 
    gap[dep[u]]++;//层数对应个数++
    return used; 
}
int ISAP()
{
    maxflow=0;
    bfs();//从t到s跑一遍bfs，标记深度
    while(dep[s]<n)	dfs(s,inf);//每走一遍增广路,s的层数会加1,如果一直没有出现断层,最多跑n-dep(刚bfs完时s的深度)条增广路共有n个点 
    return maxflow;
}
int main()
{
    n=Read(),m=Read(),s=1,t=n;
    int x=Read();
    int u,v,w;
    for(int i=1;i<=m;i++)
	{
		u=Read();
		v=Read();
		w=Read();
		addedge(u,v,w);//正向边 
		addedge(v,u,0);//反向边 
	}
	int al=ISAP(),time;
	
	if(al)
	{
		time=x/al;
		if(al*time<x)	time++;
		printf("%d %d\n",al,time);
	}
    else
    	printf( "Orz Ni Jinan Saint Cow!\n"); 
    return 0;
}
```
完结✿✿ヽ(°▽°)ノ✿


------------

**update 2020.4.2**

新增一种算法$EK$。~~as we know,~~$EK$是$edmonds-karp$的简写。
>Edmonds-Karps增广路算法的时间复杂度为O(nm^2)。

>然而在实际运用中则远远达不到这个界，

>效率较高，一般能处理10^3~10^4规模的网络
					
>                    ——李煜东《算法竞赛进阶指南》

![](https://cdn.luogu.com.cn/upload/image_hosting/hytoaci5.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

**先贴模板**
```cpp
#include<bits/stdc++.h>
#define mst(a,b) memset(a,b,sizeof(a))
#define For(i,k,j) for(register int i=(k);i<=(j);i++)
#define INF 2147483647
using namespace std;
const int MAXN=10001;
const int MAXM=100001;
int g[MAXN][MAXN]; //g[u][v] : u -> v 还可以流的量 (正向图) 
int pre[MAXN]; // 记录每个点的前驱
bool vis[MAXN]; // 记录每个点是否被访问过 
int n,m;
inline bool bfs(int s,int t)//经典BFS 
{
	//新的开始 
	mst(pre,-1);//重新计算pre[] 
	mst(vis,0);//重新记录vis[] 
	queue<int>q;//新建队列 
	vis[s]=true;//源点已被遍历 
	q.push(s);//压入队列 
	while(!q.empty())
	{
		int now=q.front();
		q.pop();
		For(i,1,n) 
		{
			if(!vis[i]&&g[now][i]>0)//如果这个点没被遍历到,且now和i有管道 
			{
				vis[i]=true;//当前点已被访问 
				pre[i]=now;//记录i点的前一个点是now 
				if(i==t)//如果i点是汇点,那么,一条路径产生 
					return 1;
				q.push(i);//else,继续搜 
			}
		}
	}
	return 0;//所有路径都被遍历完了 
}
inline int EK(int s,int t) 
{
	int v,u,d,maxflow=0;
	while(bfs(s,t)) 
	{ //可以增广 
		v=t,d=INF;//找可增量d ,d为当前流量 
		while(v!=s)//回溯 
		{
			u=pre[v]; // u记录v的前驱 
			d=min(d,g[u][v]);  // d 和当前边（正向边）还可以流过去的量取最小值->能流多少 
			v=u;//v=前一个点 
		}
		maxflow+=d;//最大流量 
		v=t;//Do it again
		while(v!=s)//回溯 
		{
			u=pre[v];// u记录v的前驱 
			g[u][v]-=d; //网络中的正向边剩下可以流的量减少d 
			g[v][u]+=d; //网络中的反向边剩下可以流的量增加d
			v=u;
		}
	}
	return maxflow;
}
int main()
{
	scanf("%d%d",&n,&m);//n为点数，m为边数 
	int s,t;//源点&汇点 
	scanf("%d%d",&s,&t);
	For(i,1,m) 
	{
		int u,v,w;//起点,终点,管道流量 
		scanf("%d%d%d",&u,&v,&w); 
		g[u][v]+=w;//建图 
	}
	printf("%d\n",EK(s,t));
    return 0;
}

```
大家可以先看注释，用的是邻接矩阵。

这里就将详细讲一个部分
```cpp
if(!vis[i]&&g[now][i]>0)//如果这个点没被遍历到,且now和i有管道 
```
$why?$，

$!vis[i]$表示当前点木有被遍历（此次BFS）

RT![](https://cdn.luogu.com.cn/upload/image_hosting/k8mmsvy0.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
——>![](https://cdn.luogu.com.cn/upload/image_hosting/b2rqx69g.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
设中间一点为a，左上为x，右上为b

那么我们随机给管道的容量赋值，在最优情况下，$S-A-X-Y-T$的流量不可能大于$S-A-T$的流量。


------------
$AC$ $code$

```cpp

#include<bits/stdc++.h>
#define mst(a,b) memset(a,b,sizeof(a))
#define For(i,k,j) for(register int i=(k);i<=(j);i++)
#define INF 2147483647
using namespace std;
const int MAXN=10001;
const int MAXM=100001;
int g[MAXN][MAXN]; //g[u][v] : u -> v 还可以流的量 (正向图) 
int pre[MAXN]; // 记录每个点的前驱
bool vis[MAXN]; // 记录每个点是否被访问过 
int n,m;
bool bfs(int s,int t)//经典BFS 
{
	//新的开始 
	mst(pre,-1);//重新计算pre[] 
	mst(vis,0);//重新记录vis[] 
	queue<int>q;//新建队列 
	vis[s]=true;//源点已被遍历 
	q.push(s);//压入队列 
	while(!q.empty())
	{
		int now=q.front();
		q.pop();
		For(i,1,n) 
		{
			if(!vis[i]&&g[now][i]>0)//如果这个点没被遍历到,且now和i有管道 
			{
				vis[i]=true;//当前点已被访问 
				pre[i]=now;//记录i点的前一个点是now 
				if(i==t)//如果i点是汇点,那么,一条路径产生 
					return 1;
				q.push(i);//else,继续搜 
			}
		}
	}
	return 0;//所有路径都被遍历完了 
}
inline int EK(int s,int t) 
{
	int v,u,d,maxflow=0;
	while(bfs(s,t)) 
	{ //可以增广 
		v=t,d=INF;//找可增量d ,d为当前流量 
		while(v!=s)//回溯 
		{
			u=pre[v]; // u记录v的前驱 
			d=min(d,g[u][v]);  // d 和当前边（正向边）还可以流过去的量取最小值->能流多少 
			v=u;//v=前一个点 
		}
		maxflow+=d;//最大流量 
		v=t;//Do it again
		while(v!=s)//回溯 
		{
			u=pre[v];// u记录v的前驱 
			g[u][v]-=d; //网络中的正向边剩下可以流的量减少d 
			g[v][u]+=d; //网络中的反向边剩下可以流的量增加d
			v=u;
		}
	}
	return maxflow;
}
int main()
{
	scanf("%d%d",&n,&m);//n为点数，m为边数 
	int s=1,t=n;//源点&汇点 
	int x;
	scanf("%d",&x);
	For(i,1,m) 
	{
		int u,v,w;//起点,终点,管道流量 
		scanf("%d%d%d",&u,&v,&w); 
		g[u][v]+=w;//建图 
	}
	int al=EK(s,t),time;
	
	if(al)
	{
		time=x/al;
		if(al*time<x)	time++;
		printf("%d %d\n",al,time);
	}
    else
    	printf( "Orz Ni Jinan Saint Cow!\n"); 
    return 0;
}

```


---

## 作者：nonprocess (赞：3)


写个题解，顺便帮助自己记忆理解

var capacity:array[1..200,1..200]of longint;//记下这张网络图

flow,pre:array[1..200]of longint;       //flow记录分流量，pre[i]表示某条路径中i这个节点是接在哪个点后面的

```cpp
    n,m,x,a1,b1,c1,maxstream,time:longint;
    queue:array[1..100000]of longint;       //模拟栈的队列数组,c++可以不用这个,c++有专门的push和pop函数,更方便
function min(a,b:longint):longint;          //求最小值的函数
begin
     if a>b then exit(b)
     else exit(a);
end;
function bfs(src,des:longint):longint;      //搜索所有的路径,src是初始点,des是目标点
var i,j,tail,index:longint;
begin
     fillchar(queue,sizeof(queue),0);
     fillchar(pre,sizeof(pre),-1);          //填为-1表示这个点还没有它的父亲节点
     pre[src]:=0;flow[src]:=$7fffff;        //初始化pre和flow,这里将$7fffff用作正无穷
     tail:=1;queue[1]:=src;                 //将初始点入栈
     while not(tail=0)do                    //判断栈中是否有元素，没有的话说明再也找不到路径了
     begin
          index:=queue[tail];               //从栈中取出栈顶端的，也就是队列的最后一个点
          dec(tail);                        //出栈
          if(index=des)then break;          //如果这个点是目标点，说明这条路找到了，就终止循环
          for i:=1 to n do                  //遍历每个节点
          begin
               if(i<>src)and(capacity[index,i]>0)and(pre[i]=-1)then //判断当前走到的点index是否和i点相连,并且还未走过(即pre[i]=-1)
               begin
                    pre[i]:=index;                                  //记录i节点是由index点过来的
                    flow[i]:=min(capacity[index,i],flow[index]);    //取(index点的最大流)和(从index到i的最大容量)二者最小值
                    inc(tail);
                    queue[tail]:=i;                                 //将i点入栈
               end;
          end;
     end;
     if(pre[des]=-1)then exit(-1)           //如果目标点的父亲节点是-1，即找不到与目标点相连的路径
     else exit(flow[des]);                  //如果能找到路径，输出最大的分流
end;
function floyd(src,des:longint):longint;    //将所有分流遍历完统计
var increasement,sumflow,k:longint;
begin
     sumflow:=0;
     increasement:=bfs(src,des);
     while(increasement<>-1)do              //如果第一遍的搜索不能找到分流,那么这段代码就不执行，答案就是学生无法撤离
     begin                                  //如果有分流，就不断的搜索，不断的合并分流
          k:=des;                           //while里面的语句因为是套模板，这里没什么用..
          while(k<>src)do
          begin
               dec(capacity[pre[k],k],increasement);
               inc(capacity[k,pre[k]],increasement);
               k:=pre[k];
          end;
          inc(sumflow,increasement);        //合并分流
          increasement:=bfs(src,des);
     end;
     exit(sumflow);                         //得到最大网络流
end;
procedure init;
var i,j:longint;
begin
     readln(n,m,x);
     for i:=1 to m do
     begin
          readln(a1,b1,c1);
          if a1=b1 then continue;           //判断只有目标点和起始点的特殊情况
          inc(capacity[a1,b1],c1);          //考虑到2个点之间多条边的情况，所以不直接赋值
     end;
end;
begin
     init;                                  //初始化
     maxstream:=floyd(1,n);                 //遍历得到最大流
     if maxstream=0 then writeln('Orz Ni Jinan Saint Cow!')
     else                                   //最大流为0即没有路径能通过，换句话说，它的最大流量就是0
     begin
          time:=x div maxstream;            //对学生的批数进行处理输出
          if x mod maxstream<>0 then inc(time);
          writeln(maxstream,' ',time);
     end;
     readln;readln;
end.
```

---

## 作者：gyh20 (赞：2)

网络流中的最大流，这里用dinic()加前向星解决
```cpp
#pragma GCC optimize(200000)/不用问为什么,要相信O(200000)优化比O(2)快得多
//至少听起来是这样的
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
struct edge{
	long long next,w,to;
}e[1000005];
inline long long read(){
	long long t=0;
	char v=getchar();
	while(v<'0'||v>'9')v=getchar();
	while(v>='0'&&v<='9'){
		t=(t<<3)+(t<<1)+v-'0';
		v=getchar();
	}
	return t;
}
long long p[1000002];
long long head[1000002],b,c,d,n,m,cnt=1,S,T,x,o;
inline void bu(register long long u,register long long v,register long long w){
      e[++cnt].to=v;
      e[cnt].w+=w;
      e[cnt].next=head[u];
      head[u]=cnt;
      e[++cnt].to=u;
      e[cnt].next=head[v];
      head[v]=cnt;
}   
queue <long long> q;
inline long long spfa(register long long s,register long long t){
    memset(p,-1,sizeof(p));
	while(!q.empty())q.pop();
	q.push(s);
	p[s]=0;
	while(!q.empty()){
		long long r=q.front();
		q.pop();
		if(r==t)return 1;
        for(register long long i=head[r];i;i=e[i].next){
			if(e[i].w>0&&p[e[i].to]<0){
			    q.push(e[i].to);
				p[e[i].to]=p[r]+1;
				}
		}
	}
	return 0;
}
inline long long dfs(register long long s,register long long t,register long long mx){
	long long r=0,y=0;
	if(s==t)return mx;
	for(register long long i=head[s];i;i=e[i].next)
		if(e[i].w>0&&p[e[i].to]==p[s]+1){
			y=dfs(e[i].to,t,min(e[i].w,mx));
			e[i].w-=y;
			e[i^1].w+=y;
			r+=y;
			mx-=y;
			if(!mx)return r;
		}
	
	return r;
}
inline long long dinic(){
	long long ans=0;
	while(spfa(S,T))ans+=dfs(S,T,0x7fffffff);
	return ans;
}
int main(){
    n=read();
	m=read();
	x=read();
	S=1;
	T=n;
	for(register long long i=1;i<=m;++i){
		b=read();
		c=read();
		d=read();
		bu(b,c,d);
	}
	o=dinic();
	if(o==0)printf("Orz Ni Jinan Saint Cow!");
	else printf("%d %d",o,(x+o-1)/o);
}//其实O(200000)没有太大的区别
```


---

## 作者：芬特 (赞：1)

看了看好像没用isap算法，我就来一个

数据好像很小，isap跑得飞快，只有一个点比较坑，t了一次

主要是maxflow除出来再取整，然后不要写错板子就可以啦

代码如下

```cpp
#include<bits/stdc++.h>
#define min(x,y) (x<y?x:y)
#define maxn 10005
#define inf 1<<30
using namespace std;
struct edge{
    int from,to,cap,flow;
};
struct isap
{
    int s,t,n,p[maxn],d[maxn],num[maxn],cur[maxn];
    bool vis[maxn];
    vector<edge>edges;
    vector<int>g[maxn];
    void init(int s,int t,int n)
    {
        this->s=s;
        this->t=t;
        this->n=n;
        for(int i=1;i<=n;i++)
        g[i].clear();
        edges.clear();
    }
    void addedge(int from,int to,int cap)
    {
        edges.push_back((edge){from,to,cap,0});
        edges.push_back((edge){to,from,0,0});
        int m=edges.size();
        g[from].push_back(m-2);
        g[to].push_back(m-1);
    }
    void bfs()
    {
    queue<int>q;
    q.push(t);
    vis[t]=1,d[t]=0;
    while(!q.empty())
    {
        int x=q.front();q.pop();
        for(int i=0;i<g[x].size();i++)
        {
            edge& e=edges[g[x][i]^1];
            if(!vis[e.from]&&e.flow<e.cap)
            {
                vis[e.from]=1;
                d[e.from]=d[x]+1;
                q.push(e.from);
            }
        }
    }
    }
    int augment()
    {
        int x=t,a=inf;
        while(x!=s)
        {
            edge& e=edges[p[x]];
            a=min(a,e.cap-e.flow);
            x=e.from;
        }
        x=t;
        while(x!=s)
        {
            edge&e=edges[p[x]];
            e.flow+=a;
            edges[p[x]^1].flow=-a;
            x=e.from;
        }
        return a;
    }
    int maxflow()
    {
        int flow=0;
        bfs();
        memset(num,0,sizeof(num));
        for(int i=1;i<=n;i++) num[d[i]]++;
        memset(cur,0,sizeof(cur));
        int x=s;
        while(d[s]<n)
        {
            if(x==t)
            {
                flow+=augment();
                x=s;
            }
            bool ok=0;
            for(int i=cur[x];i<g[x].size();i++)
            {
                edge& e=edges[g[x][i]];
                if (d[x]==d[e.to]+1 && e.cap>e.flow)
                {
                    p[e.to]=g[x][i];
                    cur[x]=i; x=e.to;
                    ok=1;
                    break;
                }
            }
            if(!ok)
            {
            int m=n-1;
            for(int i=0;i<g[x].size();i++)
            {
                edge& e=edges[g[x][i]];
                if(e.cap>e.flow) m=min(m,d[e.to]);
            }
            num[d[x]]--;
            if(!num[d[x]]) break;
            d[x]=m+1;num[d[x]]++;
            cur[x]=0;
            if(x!=s)x=edges[p[x]].from;
            }
        }
        return flow;
    }
};


int main()
{
    ios::sync_with_stdio(false);
    int n,m,s,t,u,v,w,X;
    cin>>n>>m>>X;
    s=1,t=n;
    isap get_sap;
    get_sap.init(s,t,n);
    for(int i=1;i<=m;i++)
    {
        cin>>u>>v>>w;
        get_sap.addedge(u,v,w);
    }
    int max_flow=get_sap.maxflow();    
    if(max_flow>0)
    {
    int ans=X/max_flow;
    cout<<max_flow<<" ";
    if(ans*max_flow==X) cout<<ans;
    else cout<<ans+1;
    }
    else 
    {
        cout<<"Orz Ni Jinan Saint Cow!";
    }
    return 0;
}
```

---

## 作者：青丝、暮成雪 (赞：1)

红果果的最大流（虽然第一眼还没看出来....哎，蒟蒻一枚.....）

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
#include<algorithm>
using namespace std;
int map[310][310],n,m,x,flow[310],pre[310];
queue<int> q;
int bfs(int s,int t)
{
        while(!q.empty()) q.pop();
            for(int i=1;i<=n;i++) pre[i]=-1;//前驱为负 
            pre[s]=0;//更改起点 
            flow[s]=0x7f7f7f;//起点流量为无穷
            q.push(s);
            while(!q.empty())
            {
                        int x=q.front();
                        q.pop();
                        i    f(x==t) break;//找到增广路
                        for(int i=1;i<=n;i++)
                        {
                                    if(i!=s&&map[x][i]>0&&pre[i]==-1)
                                    {
                                                pre[i]=x;//记录前驱 
                                                if(flow[x]<map[x][i]) flow[i]=flow[x];
                                                else flow[i]=map[x][i];//找增量 
                                                q.push(i);
                                    }
                        } 
            }
            if(pre[t]==-1) return -1;
            else return flow[t];
}
int max_flow(int s,int t)
{
            int ins_flow=0;
            int tot_flow=0;
            while((ins_flow=bfs(s,t))!=-1)
            {
                        int k=t;//从终点往起点找 
                        while(k!=s)
                        {
                                    int last=pre[k];
                                    map[last][k]-=ins_flow;//改正向边 
                                    map[k][last]+=ins_flow;//改反向边 
                                    k=last;
                        }
                        tot_flow+=ins_flow;
            }
            return tot_flow;
}
int main()
{
            scanf("%d%d%d",&n,&m,&x);
            for(int i=1;i<=m;i++)
            {
                        int x,y,z;
                        scanf("%d%d%d",&x,&y,&z);
                        map[x][y]+=z;
                }
            int temp=max_flow(1,n);
            if(temp==0){
                printf("Orz Ni Jinan Saint Cow!\n");
                return 0;
            }
            if(x%temp==0) printf("%d %d\n",temp,x/temp);
            else printf("%d %d\n",temp,x/temp+1);
            return 0;
}
```

---

## 作者：abandentsky (赞：0)

题意：就不说了，说来说去就是给定一个有向图，把权值视为容量，然后跑一边最大流得到最小割。完了就可以计算了，如果最大流为0，就是不能完成输出“Orz Ni Jinan Saint Cow!”,如果不是0就要考虑能不能整除，不能整除就要在商上加上一。
```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 205
#define maxnode 1000005
#define sigma_size 26
#define md 12345678
#define INF 0x3f3f3f3f
#define pii pair<int,int>
using namespace std;

struct Edge
{
    int from,to,cap,flow;
    Edge(int from=0,int to=0,int cap=0,int flow=0):from(from),to(to),cap(cap),flow(flow){};
};
int n,m,s,t,k;

struct Dinic
{
    int n,m,s,t;
    bool vis[MAXN];
    int d[MAXN],cur[MAXN];
    vector<Edge> edges;
    vector<int> G[MAXN];
    void init(int n)
    {
        this->n=n;
        edges.clear();
        for(int i=0;i<=n;i++)
            G[i].clear();
    }

    void AddEdge(int from,int to,int cap)
    {
        edges.push_back({from,to,cap,0});
        edges.push_back({to,from,0,0});
        int mm=edges.size();
        G[from].push_back(mm-2);
        G[to].push_back(mm-1);
    }

    bool bfs()
    {
        memset(vis,0,sizeof(vis));
        d[s]=0,vis[s]=true;
        queue<int> Q;
        Q.push(s);
        while(!Q.empty())
        {
            int X=Q.front();
            Q.pop();
            for(int i=0;i<G[X].size();i++)
            {
                Edge &e=edges[G[X][i]];
                if(!vis[e.to]&&e.cap>e.flow)
                {
                    vis[e.to]=true;
                    d[e.to]=d[X]+1;
                    Q.push(e.to);
                }
            }
        }
        return vis[t];
    }

    int dfs(int x,int a)
    {
        if(x==t||a==0)
            return a;
        int flow=0;
        int f;
        for(int &i=cur[x];i<G[x].size();i++)
        {
            Edge &e=edges[G[x][i]];
            if(d[e.to]==d[x]+1&&(f=dfs(e.to,min(a,e.cap-e.flow)))>0)
            {
                flow+=f;
                e.flow+=f;
                edges[G[x][i]^1].flow-=f;
                a-=f;
                if(a==0)
                    break;
            }
        }
        return flow;
    }

    int Maxflow(int s,int t)
    {
        this->s=s;
        this->t=t;
        int flow=0;
        while(bfs())
        {
            memset(cur,0,sizeof(cur));
            flow+=dfs(s,INF);
        }
        return flow;
    }
}dinic;


int main()
{
    scanf("%d %d %d",&n,&m,&k);
    for(int i=1;i<=m;i++)
    {
        int u,v,w;
        scanf("%d %d %d",&u,&v,&w);
        dinic.AddEdge(u,v,w);
    }
    int ans=dinic.Maxflow(1,n);
    if(ans==0)
    {
        printf("Orz Ni Jinan Saint Cow!\n");
        return 0;
    }
    int sum=k/ans;
    if(k%ans)
        sum+=1;
    printf("%d %d\n",ans,sum);
    return 0;
}

```


---

## 作者：苏幕寒 (赞：0)

其实这道题目就是一道朴素的求最大流的题目；
先bfs分层；再dfs对每一层次的流量进行修改；
最后输出答案就可以了；不会的可以先去做一
下 P3376 这道模板题； _**上代码：**_ 
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10005;
int n,m,s;
struct edge{
	int v,nxt,val;
}e[N*2];
int head[N],cnt=1;
int dis[N];
int maxflow;
void add(int u,int v,int val){
	e[++cnt]=(edge){v,head[u],val};head[u]=cnt;
	e[++cnt]=(edge){u,head[v],0};head[v]=cnt;
}
bool bfs()
{
	queue<int>q;
	memset(dis,-1,sizeof(dis));
	q.push(1);dis[1]=1;
	while(!q.empty())
	{
		int x=q.front();q.pop();
		for(int i=head[x];i;i=e[i].nxt)
		{
			int v=e[i].v;
			if(dis[v]==-1&&e[i].val)
			{
				q.push(v);
				dis[v]=dis[x]+1;
			}
		}
	}
	return dis[n]!=-1;
}
int dfs(int u,int flow)
{
	if(u==n) return flow;
	int res=0;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(dis[v]==dis[u]+1&&e[i].val)
		{
			int fl=dfs(v,min(e[i].val,flow));
			if(fl)
			{
				e[i].val-=fl;e[i^1].val+=fl;
				flow-=fl;res+=fl;
				if(!flow) return res;
			}
		}
	}
	return res;
}
int main()
{
	scanf("%d%d%d",&n,&m,&s);
	for(int i=1;i<=m;i++)
	{
		int x,y,val;
		scanf("%d%d%d",&x,&y,&val);
		add(x,y,val);
	}
	while(bfs()) maxflow+=dfs(1,1<<29);
	if(maxflow)printf("%d ",maxflow);
	else {
		printf("Orz Ni Jinan Saint Cow!");
		return 0;	
	}
	if(s%maxflow==0) printf("%d",s/maxflow);
	else printf("%d",s/maxflow+1);
	return 0;
}
```


---

## 作者：attack (赞：0)

来一发Dinic。

这题比较少，我们想一下，如果要输送学生，我们只要找出每次可以通过的最大的学生数量就好。

然后用一点贪心的原理，每次都去用最大的输送方案输送学生（废话。。）

只要最大流不为0就一定能输送完成

        
        
    
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
#include<algorithm>
#define lli long long int 
using namespace std;
const int MAXN=300001;
const int maxn=0x7fffff;
void read(int &n)
{
    char c='+';int x=0;bool flag=0;
    while(c<'0'||c>'9')
    {c=getchar();if(c=='-')flag=1;}
    while(c>='0'&&c<='9')
    {x=(x<<1)+(x<<3)+c-48;c=getchar();}
    flag==1?n=-x:n=x;
}
struct node
{
    int u,v,flow,cap,nxt;
}edge[MAXN];
int head[MAXN];
int num=0;
int n,m,S,T,x;
int dis[MAXN];
int vis[MAXN];
int cur[MAXN];
void add_edge(int x,int y,int z)
{
    edge[num].u=x;
    edge[num].v=y;
    edge[num].cap=z;
    edge[num].flow=0;
    edge[num].nxt=head[x];
    head[x]=num++;
}
bool bfs(int bg,int ed)
{
    memset(dis,-1,sizeof(dis));
    queue<int>q;
    q.push(bg);
    dis[bg]=0;
    while(!q.empty())
    {
        int p=q.front();
        q.pop();
        for(int i=head[p];i!=-1;i=edge[i].nxt)
        {
            if(dis[edge[i].v]==-1&&edge[i].cap>edge[i].flow)
            {
                vis[edge[i].v]=1;
                dis[edge[i].v]=dis[edge[i].u]+1;
                  q.push(edge[i].v);            
            }
        }
    }
    if(dis[ed]==-1)
        return 0;
    else return 1;
}
int dfs(int now,int a)// a:所有弧的最小残量 
{
    if(now==T||a<=0)
        return a;
    int flow=0,f;
    for(int i=head[now];i!=-1;i=edge[i].nxt)
    {
        if(dis[now]+1==dis[edge[i].v]&&edge[i].cap-edge[i].flow>0)
        {
            f=dfs(edge[i].v,min(a,edge[i].cap-edge[i].flow));
            edge[i].flow+=f;
            edge[i^1].flow-=f;
            flow+=f;
            a-=f;
            if(a<=0)break;
        }
    }
    return flow;
}
void Dinic(int S,int T)
{
    int ansflow=0;
    int cs=0;
    int maxflow=0;
    for(int i=1;i<=n;i++)
            cur[i]=head[i];
    while(bfs(S,T))
    {
        int p=dfs(S,maxn);
        cs++;
        ansflow+=p;
        maxflow=max(maxflow,p); 
    }// 求出层级
    if(ansflow==0)
        printf("Orz Ni Jinan Saint Cow!");
    else 
        printf("%d %d",ansflow,(x%ansflow)==0?(x/ansflow):(x/ansflow+1));
    //printf("%d",ansflow);
}
int main()
{
    scanf("%d%d%d",&n,&m,&x);
    //read(n);read(m);read(x);
//    swap(n,m);
    S=1;T=n;
   // read(S);read(T);
    for(int i=1;i<=n;i++)
        head[i]=-1;
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        //read(x);read(y);read(z);
        scanf("%d%d%d",&x,&y,&z);
        add_edge(x,y,z);
        add_edge(y,x,0);
    }
    Dinic(S,T);
    return 0;
}

```

---


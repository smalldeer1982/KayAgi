# [APIO2009] 抢掠计划

## 题目描述

Siruseri 城中的道路都是单向的。不同的道路由路口连接。按照法律的规定，在每个路口都设立了一个 Siruseri 银行的 ATM 取款机。令人奇怪的是，Siruseri 的酒吧也都设在路口，虽然并不是每个路口都设有酒吧。  

Banditji 计划实施 Siruseri 有史以来最惊天动地的 ATM 抢劫。他将从市中心出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆祝他的胜利。  

使用高超的黑客技术，他获知了每个 ATM 机中可以掠取的现金数额。他希望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可以经过同一路口或道路任意多次。但只要他抢劫过某个 ATM 机后，该 ATM 机里面就不会再有钱了。 例如，假设该城中有 $6$ 个路口，道路的连接情况如下图所示：  

![](https://cdn.luogu.com.cn/upload/pic/4396.png)  

市中心在路口 $1$，由一个入口符号 → 来标识，那些有酒吧的路口用双圈来表示。每个 ATM 机中可取的钱数标在了路口的上方。在这个例子中，Banditji 能抢劫的现金总数为 $47$，实施的抢劫路线是：$1-2-4-1-2-3-5$。

## 说明/提示

对于 $50\%$ 的数据，保证 $N, M \le 3000$。  

对于 $100\%$ 的数据，保证 $N, M \le 5\times 10^5$，$0 \le a_i \le 4000$。保证可以从市中心沿着 Siruseri 的单向的道路到达其中的至少一个酒吧。

## 样例 #1

### 输入

```
6 7 
1 2 
2 3 
3 5 
2 4 
4 1 
2 6 
6 5 
10 
12 
8 
16 
1 
5 
1 4 
4 3 5 6```

### 输出

```
47```

# 题解

## 作者：Lucaster_ (赞：84)

这次改一下题解风格，先不放AC代码 ~~（因为实在是太长了）~~

[（哦对了）](https://www.luogu.org/problemnew/show/P3627)

先放上程序“缩略图”：

![“分块”写程序……](https://cdn.luogu.com.cn/upload/pic/60233.png)

你看这个数组个数，你看这个过程（void）个数， ~~（你看这个好看的马蜂）~~ 是不是有点头大

不急，我们就按照我代码中一部分一部分来讲——

前置芝士：
1. 邻接表存储/遍历（如果你这个都不会的话做这种综合大题有点早……先好好学图论吧）
2. SPFA跑最长路（其实改个符号就好，没有必要建负权边跑最短路）
3. Tarjan缩点（不会的同学先学好Tarjan再来做这道题哦，[Tarjan练习题](https://www.luogu.org/problemnew/show/P2002)）

OK，现在假设上面的东西你都会，那么正式开始讲解：

_再补充一句：这道题确实是道好题，我的题解会讲的很详细，如果你很想理解，做出这道题，最好耐心看完。如果没有耐心，吃亏的可不是我。_

## 1.邻接表存储

这里我们用两个过程来存，一个add（存无边权的图），一个build（有边权）

先放上代码，等会就知道为什么要用两个了

```
 void add(int u,int v)
 {
 	cnt++;
 	e[cnt].to=v;
 	e[cnt].next=hd[u];
 	hd[u]=cnt;
 }
```
```
 void build(int u,int v,int w)
 {
 	cnt++;
 	e[cnt].to=v;
 	e[cnt].val=w;
 	e[cnt].next=hd[u];
 	hd[u]=cnt;
 }
```
## 2.输入部分

这道题的输入数据还是比较麻烦的

首先用数组存一下每条边的起点终点

等等，为什么要用数组存呢，直接输入不行吗

自己先想一下，虽然我一开始也没想到

```latex
这倒跟建边没什么关系
我们这么做主要是为了后面服务的
因为后面我们要用Tarjan缩点，缩完点以后有可能你一开始输入的那组边“就是一个点了”
不用数组存一下的话无法进行后续操作了
如果不理解的话就先搁着，后头主函数和Tarjan中会详细讲解
```
然后再输入s，p

再输入每个酒吧，这个是为了最后遍历一遍dis[酒吧]所服务的。

当然你也可以在main中输入，省掉一个存酒吧位置的数组

等会详细说

代码就长这样：

```cpp
 void readln()
 {
 	clear();
 	scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&u[i],&v[i]);
        add(u[i],v[i]);
    }
    for(int i=1;i<=n;i++) scanf("%d",&w[i]);
    scanf("%d%d",&s,&p);
    for(int i=1;i<=p;i++) scanf("%d",&bar[i]);
 }
```
u,v,w表示边起点，终点，点权的数组
bar是酒吧的英文，表示酒吧位置

眼尖的同学这时候要问了：clear是个什么东西

放心这次没 ~~开挂~~ 使用stl，这是我手写的一个清空数组的函数

长这样：

```cpp
 void clear()
 {
 	cnt=0;
 	memset(e,0,sizeof(e));
 	memset(hd,0,sizeof(hd));
 }
```
对邻接表很熟悉的同学一看就懂：这是清空邻接表的操作啊（cnt归零，hd清零，边表也清零）

这里教大家一种memset的用法（我也是从楼下大佬中找的）

memset(结构体名字，值，sizeof(结构体名字))

这样可以直接清空（赋值）一个结构体哦

前提是你结构体中的类型要统一，比如说都是int

## 3.Tarjan缩点

```
void Tarjan(int x)
 {
 	dfn[x]=low[x]=++total;
 	stk[++top]=x;vis[x]=true;
 	for(int i=hd[x];i;i=e[i].next)
 	{
 		int t=e[i].to;
 		if(!dfn[t])
 		{
 			Tarjan(t);
 			low[x]=min(low[x],low[t]);
 		}
 		else if(vis[t])
 		 low[x]=min(low[x],dfn[t]);
 	}
 	if(dfn[x]==low[x])
 	{
 		tot++;
 		do{
 			int tp=stk[top];
 			sum[tot]+=w[tp];
 			vis[tp]=false;
 			g[tp]=tot;
 		}while(stk[top--]!=x);
 	}
 }
```
基本就是标准Tarjan，我讲下不一样的地方吧：

```latex
tot++;
do{
 int tp=stk[top];
 sum[tot]+=w[tp];
 vis[tp]=false;
 g[tp]=tot;
}while(stk[top--]!=x);
```
```latex
这里我是用的数组模拟栈，首先int tp=stk[top]取出栈顶

sum表示缩完点后这个点的点权
不是很懂Tarjan的好好理解下Tarjan弹栈的部分再看这里就懂了
懂Tarjan的模拟一下应该就懂了，每次弹栈时，所有被弹出的点都是缩完点后的一个点
即sum[tot]+=w[tp]，缩完点后的点权+=原点权
很好理解吧
不懂的说明你对Tarjan还是理解不到位……这篇题解不是讲Tarjan的，楼下大佬应该有详细讲解。

然后vis[tp]=false表示tp已经出栈

g表示缩完点后每个点在哪个点中
即g[tp]=tot，tp这个点在缩完点后的第tot个点里
然后用栈顶和x比较，标准Tarjan操作

stk[top--]就相当于pop弹栈了
```
大家应该都看懂了吧

那现在我们就已经缩好点了，g已经记录好了，sum也记录好每个新点的点权了

## 5.先来看下主函数

```
int main()
{
    readln();
    for(int i=1;i<=n;i++)
     if(!dfn[i]) Tarjan(i);
    clear();
    for(int i=1;i<=m;i++)
     if(g[u[i]]!=g[v[i]])
      build(g[u[i]],g[v[i]],sum[g[v[i]]]);
    Spfa(s);
    for(int i=1;i<=p;i++)
     ans=max(ans,dis[g[bar[i]]]);
    printf("%d",ans);
    return 0;
}
```
首先readln输入，就是第二部分（P党转来的我喜欢用readln嘿嘿）

然后标准Tarjan，if(!dfn[i]) Tarjan(i);

_---(这里也是听别的大佬说的，Tarjan首字母最好大写，避免一些神奇的错误)_

这时候clear就有用了，因为我们之前add建的图是为了Tarjan缩点用的，现在缩好点了那张图就没用了！我们没有必要新开一个结构体，反而浪费很多内存，把刚刚的图clear一下就好了

然后我们遍历每一条输入的边，这个时候之前的u,v数组就有用了！我们通过判断u[i],v[i]是否在一个新点里，如果不在的话就build一条新边，这样就能建一个缩完点后的图

注意build：起点是u[i]所在的缩点，终点是v[i]所在的缩点（如果u[i]和v[i]在一个缩点里就不会执行build了），边权是v[i]所在缩点的点权（sum）！！！

这样，这张新图就表明：从U走到V可以抢劫W的钱，钱数当然是缩点点权啊

没问题

吧？

有点问题的哦：相信不少同学也看出来了——那你这样每次把边权设置为后头那个缩点的点权，前头那个点被冷落了，点权不就没用了吗？

能想到这，恭喜你你理解这道题了

不过这个问题确实存在，我们的解决方案也很简单粗暴

###### 直
##### 接
#### 来
### 看

## 6.Spfa跑最长路

正如一开始所说，我就是改了个符号，没有建负边权跑最短路，所以这一部分也是非常好理解的啦

直接上代码咯，spfa板子

```
 void Spfa(int s)
 {
 	for(int i=1;i<=tot;i++) dis[i]=0;
 	int gs=g[s];
    q.push(gs);
 	vis[gs]=true;
 	dis[gs]=sum[gs];
 	while(!q.empty())
 	{
 		int h=q.front();q.pop();
 		vis[h]=false;
 		for(int i=hd[h];i;i=e[i].next)
 		{
 			int t=e[i].to;
 			if(dis[t]<dis[h]+e[i].val)最短路中这里是>号，改成<号就是最长路咯
 			{
 				dis[t]=dis[h]+e[i].val;
 				if(!vis[t])
 				{
 					q.push(t);
 					vis[t]=true;
 				}
 			}
 		}
 	}
 }
 一看这个鬼畜的大括号就是spfa hhhhhhhh
```

我们来解决刚刚的问题，起点的点权怎么办

你会发现，spfa又不完全是板子，我改了几个地方：

```
int gs=g[s];
q.push(gs);
vis[gs]=true;
dis[gs]=sum[gs];
```
起点不是s了，而是g[s]，dis[起点]也不是0了

为什么呢？

你先想一下

——

——

——

想不出来？缩点是干啥用的来着？

——

——

——

想出来了吧：

我们刚刚build建的图是一张缩完点后的缩点图，所以我们push起点的时候当然是push缩完点后s所在的点啊

为什么呢？万一s本身就在一个环里，push（s)的话问题就大了

所以我们把起点一律改成g[s]来操作

并且，我们把起点的dis值直接加上点权，这样就不会漏掉起点点权了

而且放心，一开始更改dis值不会对后续松弛操作造成无法更改的影响，毕竟这是最长路

然后

然后

这道题就没什么可讲的了吧

最后再处理完主函数中这一部分：

```
for(int i=1;i<=p;i++)
 ans=max(ans,dis[g[bar[i]]]);
printf("%d",ans);
return 0;
```

最后还是放上完整AC代码吧：

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#define N 500005
using namespace std;
struct edge{
    int to,val,next;
} e[N];
int m,n,p,s,cnt,g[N],u[N],v[N],w[N],hd[N],bar[N],dis[N],dfn[N],low[N],stk[N],sum[N];
bool vis[N];
queue <int> q;
int ans=0,top=0,tot=0,total=0;
 inline int min(int a,int b)
  {return a<b?a:b;}
 void add(int u,int v)
 {
 	cnt++;
 	e[cnt].to=v;
 	e[cnt].next=hd[u];
 	hd[u]=cnt;
 }
 void build(int u,int v,int w)
 {
 	cnt++;
 	e[cnt].to=v;
 	e[cnt].val=w;
 	e[cnt].next=hd[u];
 	hd[u]=cnt;
 }
 void clear()
 {
 	cnt=0;
 	memset(e,0,sizeof(e));
 	memset(hd,0,sizeof(hd));
 }
 void readln()
 {
 	clear();
 	scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&u[i],&v[i]);
        add(u[i],v[i]);
    }
    for(int i=1;i<=n;i++) scanf("%d",&w[i]);
    scanf("%d%d",&s,&p);
    for(int i=1;i<=p;i++) scanf("%d",&bar[i]);
 }
 void Tarjan(int x)
 {
 	dfn[x]=low[x]=++total;
 	stk[++top]=x;vis[x]=true;
 	for(int i=hd[x];i;i=e[i].next)
 	{
 		int t=e[i].to;
 		if(!dfn[t])
 		{
 			Tarjan(t);
 			low[x]=min(low[x],low[t]);
 		}
 		else if(vis[t])
 		 low[x]=min(low[x],dfn[t]);
 	}
 	if(dfn[x]==low[x])
 	{
 		tot++;
 		do{
 			int tp=stk[top];
 			sum[tot]+=w[tp];
 			vis[tp]=false;
 			g[tp]=tot;
 		}while(stk[top--]!=x);
 	}
 }
 void Spfa(int s)
 {
 	for(int i=1;i<=tot;i++) dis[i]=0;
 	int gs=g[s];
    q.push(gs);
 	vis[gs]=true;
 	dis[gs]=sum[gs];
 	while(!q.empty())
 	{
 		int h=q.front();q.pop();
 		vis[h]=false;
 		for(int i=hd[h];i;i=e[i].next)
 		{
 			int t=e[i].to;
 			if(dis[t]<dis[h]+e[i].val)
 			{
 				dis[t]=dis[h]+e[i].val;
 				if(!vis[t])
 				{
 					q.push(t);
 					vis[t]=true;
 				}
 			}
 		}
 	}
 }
int main()
{
    readln();
    for(int i=1;i<=n;i++)
     if(!dfn[i]) Tarjan(i);
    clear();
    for(int i=1;i<=m;i++)
     if(g[u[i]]!=g[v[i]])
      build(g[u[i]],g[v[i]],sum[g[v[i]]]);
    Spfa(s);
    for(int i=1;i<=p;i++)
     ans=max(ans,dis[g[bar[i]]]);
    printf("%d",ans);
    return 0;
}
```

完结撒花！

---

## 作者：javalyc (赞：48)

[博客传送门](https://www.cnblogs.com/LLTYYC/p/9712088.html)
## 算法：Tarjan & DP
### 缩完点后竟然没题解搞DP？？？
#### 显然缩点后的图是一个DAG
#### DAG上搞DP是基本操作啊
按拓扑序搞一波DP就好了

设 f[ i ] 表示从起点抢劫到 DAG 上的点 i 时能得到的最多的钱

那么 f[ i ] = max( f [ i ] , f[ j ] + sval[ i ]) （ j 有一条边指向 i , sval[ i ] 表示DAG上点 i 的钱数）

至于 Tarjan 的具体操作其他题解讲的很详细了，这里不再赘述

测了一波，自己的DP比SPFA快个100ms（都开了O2）

#### 一些与本题无关的话：

其实真正意义的缩点还要把重复的边给去掉（缩点后可能两个块之间有多条边）

可以把边给离散化，然后去重

具体操作：


------------

```cpp
struct edge
{
    int a,b;
}e[N];//存边
int cnt3,du[N];//cnt存总边数，du存入度
int firr[N],fromm[N],too[N],cntt;//链式前向星存DAG
inline void add2(int &a,int &b)//给DAG连边
{
    fromm[++cntt]=firr[a];
    firr[a]=cntt; too[cntt]=b;
}
inline bool cmp(const edge &x,const edge &y) { return x.a==y.a ? x.a<y.a : x.b<y.b; }//排序函数，把边按 a,b 双关键字排序
void build()//构造缩点后的图
{
    for(int i=1;i<=n;i++)
    {
        if(!be[i]) continue;//因为我的主函数只缩了从起点能到的点，所以要判断一波
        //这里be存每个点所在的联通块
        for(int j=fir[i];j;j=from[j])//遍历原图的边
        {
        	if(be[i]==be[to[j]) continue;//同一个块的边不要连
            e[++cnt3].a=be[i],e[cnt3].b=be[to[j]];//把边先统一存到e里面
        }
    }
    sort(e+1,e+cnt3+1,cmp);//排序
    for(int i=1;i<=cnt3;i++)
        if(e[i].b!=e[i-1].b||e[i].a!=e[i-1].a)//因为排好序了，所以可以这样判断重复的边
        	add2(e[i].a,e[i].b),du[e[i].b]++;//如果没重复就加入DAG
}
```


------------

但是对于本题根本不需要去除重复边

要也可以，但是sort多一个log,反而更慢...

废话结束上代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
inline int read()
{
    int x=0,f=1; char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
const int N=5e5+7;
int n,m,k,sta;
int val[N];
int fir[N],from[N],to[N],cnt;
inline void add(int &a,int &b)//给原图连边
{
    from[++cnt]=fir[a];
    fir[a]=cnt; to[cnt]=b;
}

//几乎就是Tarjan的模板
int dfn[N],low[N],be[N],sval[N],st[N],cnt2,dfs_clock,_top;
bool bar[N],Bar[N];//bar表示原图的酒吧,Bar表示DAG上的酒吧
void Tarjan(int x)
{
    dfn[x]=low[x]=++dfs_clock; st[++_top]=x;
    for(int i=fir[x];i;i=from[i])
    {
        int &v=to[i];
        if(!dfn[v]) Tarjan(v),low[x]=min(low[x],low[v]);
        else if(!be[v]) low[x]=min(low[x],dfn[v]);
    }
    if(dfn[x]==low[x])
    {
        cnt2++;
        while(st[_top]!=x)
        {
            if(bar[st[_top]]) Bar[cnt2]=1;
            sval[cnt2]+=val[st[_top]];
            be[st[_top--]]=cnt2;
        }
        if(bar[st[_top]]) Bar[cnt2]=1;
        sval[cnt2]+=val[st[_top]];
        be[st[_top--]]=cnt2;
    }
}

int du[N];//存入度，DP要用
int firr[N],fromm[N],too[N],cntt;//存DAG
inline void add2(int &a,int &b)//连DAG的边
{
	fromm[++cntt]=firr[a];
	firr[a]=cntt; too[cntt]=b;
}
void build()//没有去重边的DAG构造函数
{
    for(int i=1;i<=n;i++)
    {
        if(!be[i]) continue;//我的主函数只缩了从起点能到的点，所以要判断一波
        for(int j=fir[i];j;j=from[j])
        {
            if(be[i]==be[to[j]]) continue;//同块内的边就不要连了
            add2(be[i],be[to[j]]),du[be[to[j]]]++;//不然就连起来，更新入度
        }
    }
}

int f[N],ans;
queue <int> q;
void DP()//按拓扑序的DP
{
    q.push(be[sta]); f[be[sta]]=sval[be[sta]];
    while(!q.empty())
    {
        int u=q.front(); q.pop();
        for(int i=firr[u];i;i=fromm[i])
        {
            int &v=too[i];
            f[v]=max(f[v],f[u]+sval[v]);//尝试更新f[v]
            if(!(--du[v])) q.push(v);//更新入度
        }
    }
    for(int i=1;i<=cnt2;i++) if(Bar[i]) ans=max(ans,f[i]);//在有酒吧的块内找一个钱最多的块
}

int main()
{
    int a,b;
    n=read(); m=read();
    for(int i=1;i<=m;i++)
    {
        a=read(); b=read();
        add(a,b);
    }
    for(int i=1;i<=n;i++) a=read(),val[i]=a;
    sta=read() ;k=read();
    for(int i=1;i<=k;i++) a=read(),bar[a]=1;

    Tarjan(sta);//只要从起点Tarjan就好了，其他的反正也到不了
    build();//构造DAG
    DP();
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Danny_boodman (赞：48)

首先我们看见可以重复走路径，那么就想到其实这些路口可以构成一个个强连通分量（因为只要我们能到达一个强连通分量其中某一个点，那么我们就能到达这个强连通分量的其余所有点并且保证更优）。那就很容易想到缩点加最长路，至于最长路，我是把点权转移到边权，然后把边权置为负，就可以愉快的跑最短路啦

至于如何用tarjan求强联通分量，就可以来看我的博客啦(https://www.luogu.org/blog/sincereactor/)


```
#include<iostream>
#include<stdio.h>
#include<cstring>
using namespace std;
struct ss{
	int next,to,val;
};ss data[500010];
int head[200010],qe[500010],used[500010],dis[500010],color[500010],sum[500010];
int n,m,p,q,timeclock,ans,tot,top,S,s,t,P,jiu;
int x[500010],y[500010],dfn[500010],low[500010],instack[500010],stack[500010],money[500010];
void add(int a,int b)//建个图跑tarjan求强连通分量
{
	data[++p].to=b;
	data[p].next=head[a];
	head[a]=p;
}
void Add(int a,int b,int c)//再建个图跑spfa求最长路
{
	data[++p].to=b;
	data[p].next=head[a];
	data[p].val=c;
	head[a]=p;
}
void tarjan(int a)//标准tarjan
{
	dfn[a]=low[a]=++timeclock;
	instack[a]=1;
	stack[++top]=a;
	for(int i=head[a];i;i=data[i].next)
	{
		int v=data[i].to;
		if(!dfn[v])
		{
			tarjan(v);
			low[a]=min(low[a],low[v]);
		}
		else
		if(instack[v])
		low[a]=min(low[a],dfn[v]);
	}
	if(dfn[a]==low[a])
	{
		tot++;
		while(stack[top+1]!=a)
		{
			color[stack[top]]=tot;
			sum[tot]+=money[stack[top]];
			instack[stack[top--]]=0;
		}
	}
}
void spfa()//标准spfa
{
	for(int i=1;i<=tot;i++)
	dis[i]=0x7fffffff;
	int ts=color[S];
	dis[ts]=-sum[ts];
	qe[0]=ts;p=q=0;
	while(p<=q)
	{
		s=qe[p%n];
		used[s]=0;
		t=head[s];
		while(t)
		{
			if(dis[s]+data[t].val<dis[data[t].to])
			{
				dis[data[t].to]=dis[s]+data[t].val;
				if(!used[data[t].to])
				{
					qe[++q%n]=data[t].to;
					used[data[t].to]=1;
				}
			}
			t=data[t].next;
		}
		p++;
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
	    scanf("%d%d",&x[i],&y[i]);
	    add(x[i],y[i]);
	}
	for(int i=1;i<=n;i++)
	scanf("%d",&money[i]);
	for(int i=1;i<=n;i++)
	if(!dfn[i])
	{
	   tarjan(i);
    }
	memset(data,0,sizeof(data));
	memset(head,0,sizeof(head));
	p=0;
	for(int i=1;i<=m;i++)
	{
		if(color[x[i]]!=color[y[i]])
		Add(color[x[i]],color[y[i]],-(sum[color[y[i]]]));
	}
	scanf("%d",&S);
	spfa();
	scanf("%d",&P);
	for(int i=1;i<=P;i++)//把所有酒吧看一遍，求个最大
	{
		scanf("%d",&jiu);
		if(-dis[color[jiu]]>ans)
		ans=-dis[color[jiu]];
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：一叶知秋。 (赞：30)

模拟赛T3，然而这么裸的缩点我却忘记模板了。。。

------------

然后我就开始想其他做法，费用流(其实就是SPFA我却硬要在套点东西)？然后就开始写，再然后就写挂了，一直跑负环（其实是算正环，因为是最长路嘛），没有办法，考完再加上 $tarjan$ 吧。

不过说实话这题也挺水的，缩点套 $SPFA$ 就可以了，不过既然要写题解，为了自己题解能~~过审~~让大家看得懂，还是讲讲 $tarjan$ 吧（~~反正也是对着书抄嘛~~）。

因为是自己的理解，所以这里讲的会很简单，但大家应该能听懂吧。

首先，我们引入时间戳 $dfn$（是个数组），这个应该不需要解释吧，学 $DFS$ 时应该学过吧， $dfn$ 就是第一次遍历到i这个点的时间 $N$ 个节点里 $1$~$N$ 的 $DFS$ 顺序（还是讲了嘛）。

然后（**划重点**）我们需要判断在深搜以 $x$ 为根的树的过程中，要判断是否子树中有节点连边上来（如果一个节点往它的几个祖先节点都连了边，那么找辈分最大的那个，即时间戳最小的那个），那么此时我们引进追溯值 $low[x]$，指的是在以$x$为根的树中，是否有向上（祖先）连边的节点（没有则 $low[x]=dfn[x]$（自己连自己）），如果有，连的时间戳最小（即辈分最大）的是谁。

$low[x]$ 是这样更新的：

1.初始化 $low[x]$ = $dfn[x]$ 

2.扫描与 $x$ 相连的每条边，设边的另一端是 $y$

（1）若 $y$ 没有遍历过，就往下遍历，遍历完后 $low[x]=min(low[x],low[y])$，即记录 $x$ 的子树中有没有向上连边的节点，有就取时间戳最小的那个（即连的辈分最大的那个）

（2）若 $y$ 被遍历过了并且 $y$ 还不属于任何一个强连通分量，那么 $low[x]=min(low[x],dfn[y])$，因为前面说明过，要取时间戳最小的那个，不然缩点后图中仍然存在环。

但是怎么判一个节点还不属于任何一个强连通分量呢？我们可以用栈，遍历到一个节点，存一个节点。然后判断这个节点是否在栈中即可。

最后在 $x$ 回溯前，判断 $low[x]$ 是否等于 $dfn[x]$，若等于，就说明 $x$ 为根的节点的树构成了一个强连通分量（要么自己连自己，要么子树节点连到了 $x$，并且这是能连的边中时间戳最小的一个 ），然后将栈中存放的节点不断弹出，直至弹出自己为止，这样弹出的节点就是以 $x$ 为根的树的所有节点（即这个强连通分量的所有节点）。如果要缩点就把它们变成一个点即可。

到这里，$tarjan$ 就讲完了。

然后对这道题，因为可能有许多个终点，所以我们可以学习网络流（不知道的可以点[这里](https://www.luogu.org/blog/71403/solution-p3376)）的思想，将超级源点向起点连边，将所有终点向超级汇点连边，然后输出超级源点到超级汇点的最长路即可。

当然，如果你实在不想去看关于网络流的东西，你也可以一把最长路，然后在所有终点里再取一个最大值

代码如下：

```cpp
#include<cstdio>
#define maxn 500005
#define maxm 500005
#define INF 0x3f3f3f3f
inline int read(){
    int r=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){r=(r<<3)+(r<<1)+c-'0';c=getchar();}
    return r*f;
}
int s,t,n,m,N,head[maxn],dis[maxn],q[maxn],uu[maxn],vv[maxn];
bool vis[maxn];
int s_e;
struct E{//缩点后的边
    int v,w,nxt;
}e[maxm];
struct E1{//缩点前的边
    int v,nxt;
}e1[maxm];
int head1[maxn],s_e1;
int sd[maxn],dfn[maxn],low[maxn];
int cnt,stac[maxn*10],top,s_dfn;
bool ins[maxn];
int d[maxn],c[maxn],diss[maxn];
struct Max_fei{//结构体请见谅
    inline void a_e(int u,int v,int w){
        e[++s_e]=(E){v,w,head[u]};
        head[u]=s_e;
    }
    inline int spfa(){//当然用SPFA跑最长路了
        for(int i=0;i<=N;i++){
            dis[i]=-INF;
            vis[i]=false;
        }
        dis[s]=0;
        vis[s]=true;
        q[0]=s;
        int hd=0,tl=1;
        while(hd^tl){
            int u=q[hd++];
            hd%=maxn;
            for(int i=head[u];i!=-1;i=e[i].nxt){
                int v=e[i].v;
                if(dis[v]<dis[u]+e[i].w){
                    dis[v]=dis[u]+e[i].w;
                    if(vis[v])continue;
                    vis[v]=true;
                    q[tl++]=v;
                    tl%=maxn;
                }
            }
            vis[u]=false;
        }
        return dis[t]; //返回超级源点到超级汇点的最长路
    }
}Flow;
inline void a_e(int u,int v){
    e1[++s_e1]=(E1){v,head1[u]};
    head1[u]=s_e1;
}
inline int min(int a,int b){
	return a<b?a:b;
}
inline int max(int a,int b){
	return a>b?a:b;
}
void tarjan(int u){//缩点
	dfn[u]=low[u]=++s_dfn;
	stac[++top]=u;
  	ins[u]=1;
	for(int i=head1[u];i;i=e1[i].nxt){
		int v=e1[i].v;
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(ins[v])low[u]=min(low[u],dfn[v]); 
	}
	if(low[u]==dfn[u]){
		cnt++;
		int v=0;
		while(v!=u){
			v=stac[top--];
			d[v]=cnt;//d是记录每个点属于哪一个强连通分量
			ins[v]=0;
			c[cnt]+=diss[v];//c是缩点完以后这个点一共能抢的钱数
		}
	}
}
inline void work(){
    n=read();m=read();
    for(int i=1;i<=m;i++){
        int u=read(),v=read();
        uu[i]=u,vv[i]=v;//数组存下，等会儿还要再加一次边
        if(u==v)continue;
        a_e(u,v);
    }
    for(int i=1;i<=n;i++)
    	diss[i]=read();
	for(int i=1;i<=n;i++)
		if(!dfn[i])tarjan(i);//还没有遍历过这个节点就遍历
    s=0;t=cnt+1;//超级源点与超级汇点
    N=cnt+1;
	for(int i=1;i<=m;i++){//缩完点重新加边
		if(d[uu[i]]==d[vv[i]])continue;现在是在同一个强连通分量里了，不用再加了
        Flow.a_e(d[uu[i]],d[vv[i]],c[d[vv[i]]]);
	}
    int S=read(),P=read();
    Flow.a_e(s,d[S],c[d[S]]);//超级源点连起点
    for(int i=1;i<=P;i++){
    	int bh=read();
    	Flow.a_e(d[bh],t,0);//各个终点连超级汇点
    }
    int flow=0;
    int ans=Flow.spfa();
    printf("%d\n",ans);
}
int main(){
    work();
    return 0;
}
```

~~完结偷偷撒花~~ ✿✿ヽ(°▽°)ノ✿

---

## 作者：Drinkkk (赞：19)

【参考资料】

liusu201601的博客 - bzoj1179: [Apio2009]Atm（强联通+最短路）： https://blog.csdn.net/liusu201601/article/details/79234724

百度百科 - 强连通分量： https://baike.baidu.com/item/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/7448759?fr=aladdin

【题目描述】

Siruseri 城中的道路都是单向的。不同的道路由路口连接。按照法律的规定， 在每个路口都设立了一个 Siruseri 银行的 ATM 取款机。令人奇怪的是，Siruseri 的酒吧也都设在路口，虽然并不是每个路口都设有酒吧。

Banditji 计划实施 Siruseri 有史以来最惊天动地的 ATM 抢劫。他将从市中心 出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆 祝他的胜利。

使用高超的黑客技术，他获知了每个 ATM 机中可以掠取的现金数额。他希 望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可 以经过同一路口或道路任意多次。但只要他抢劫过某个 ATM 机后，该 ATM 机 里面就不会再有钱了。 例如，假设该城中有 6 个路口，道路的连接情况如下图所示：

![](https://cdn.luogu.com.cn/upload/pic/4396.png)

市中心在路口 1，由一个入口符号→来标识，那些有酒吧的路口用双圈来表

示。每个 ATM 机中可取的钱数标在了路口的上方。在这个例子中，Banditji 能抢 劫的现金总数为 47，实施的抢劫路线是：1-2-4-1-2-3-5。

【输入输出格式】

- 输入格式

第一行包含两个整数 $N$、$M$。$N$ 表示路口的个数，$M$ 表示道路条数。接下来 $M$ 行，每行两个整数，这两个整数都在 $1$ 到 $N$ 之间，第 $i+1$ 行的两个整数表示第 $i$ 条道路的起点和终点的路口编号。接下来 $N$ 行，每行一个整数，按顺序表示每 个路口处的 ATM 机中的钱数。接下来一行包含两个整数 $S$、$P$，$S$ 表示市中心的 编号，也就是出发的路口。$P$ 表示酒吧数目。接下来的一行中有 $P$ 个整数，表示 $P$ 个有酒吧的路口的编号。

- 输出格式

输出一个整数，表示 Banditji 从市中心开始到某个酒吧结束所能抢劫的最多 的现金总数。

【输入输出样例】

- 输入样例
```
6 7 
1 2 
2 3 
3 5 
2 4 
4 1 
2 6 
6 5 
10 
12 
8 
16 
1 
5 
1 4 
4 3 5 6
```
- 输出样例
```
47
```

【数据范围】

$50\%$的输入保证 $N, M \leq 3000$。

所有的输入保证 $N, M \leq 500000$。每个 ATM 机中可取的钱数为一个非负整数且不超过 $4000$。

输入数据保证你可以从市中心 沿着 Siruseri 的单向的道路到达其中的至少一个酒吧。

这是一道强连通的题目，什么是强连通？不妨看一下下面的教程。

现在我们有一张$n$个点$m$条边的**有向图**，如下。

![](https://cdn.luogu.com.cn/upload/pic/16684.png)

上图中，有三个强联通分量。分别是[1]、[5]以及[2,3,4,6]。

什么是强连通分量？不妨看一下下面的这段话。

- **强连通图的定义**

> 有向图强连通分量：在有向图$G$中，如果两个顶点$v_i,v_j$间（$v_i>v_j$）有一条从$v_i$到$v_j$的有向路径，同时还有一条从$v_j$到$v_i$的有向路径，则称两个顶点强连通(strongly connected)。如果有向图$G$的每两个顶点都强连通，称$G$是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。

那么怎么找到这张图中有多少个强连通分量呢？下面我将模拟一次强连通的过程，不会的同学可以认真地看一下整个过程。

我们定义每个点有$2$个参数，一个是时间戳，我用字母 $i$（很多题解用$dfn$），一个是自己团的老大，我用字母$d$（很多题解用$low$）。接下来图中每个点的周围会有两个数字，分别代表$i$和$d$。还有我们用一个栈来存储新加入的点，当这个点搜完了所有和它与之相邻的点的话就将其出栈。我们先从$1$号点开始询问一直直到$n$号点，每次询问问$i$号点是否有时间戳。若没有的话就从第$i$号点开始搜（$i \in [1,n]$）。现在我们先访问$1$号点，并给出$1$号点一个时间戳和他的老大（一开始的时候他的老大是它自己），如下图。

![](https://cdn.luogu.com.cn/upload/pic/16689.png)

现在$1$号点已经入栈了，接着，我们从$1$号点开始进行深搜，我在这里省略了一些中间的过程，大家如果对此感兴趣的话可以自己模拟一下，结果如下图，注意，搜的顺序是按边的输入顺序来定义的，例如有``1 2``、``1 3``、``3 2``这三条边，若我们从$1$号点开始进行深搜的话，那么优先搜$3$号点。同理，如果我们从$3$号点开始进行深搜的话，那么优先搜索的就是$2$号点，学过最短路的同学应该都有所了解，搜索几次之后的结果如下图。

![](https://cdn.luogu.com.cn/upload/pic/16690.png)

现在栈的情况为[1,2,3,4,5]。现在搜到了$5$号点，由于$5$号点现在没得搜索了，所以将$5$号点弹出栈，并且由于$5$号点的时间戳等于它的老大，那么它就是这个团体中的老大，也即：

- **如果一个点在回溯时它的时间戳等于它的老大，那么它就是这个团体中的老大，并将团体中的所有点出栈。**

现在栈的情况为[1,2,3,4]。现在，$4$号点搜索到了$6$号点，发现$6$号点还没有时间戳和老大。于是我们更新$6$号点的老大以及时间戳，同时我们还要将$6$号点加入栈内，如下图。

![](https://cdn.luogu.com.cn/upload/pic/16692.png)

现在栈内的情况为[1,2,3,6]。

现在我们从$6$号点开始扩展它周围的点啦~

现在我们搜到了$2$号点。由于$2$号点现在在栈内，那么$2$号点的时间戳小于$6$号点的老大，那么$2$号点可能就是$6$号点的最终的老大，也即：

- **若当前所在的点为$x$号点，当前扩展到的点为$y$号点，那么如果$a[y].i<a[x].d$，那么就用$a[y].i$来更新$a[x].d$。**

更新后如下图。

![](https://cdn.luogu.com.cn/upload/pic/16697.png)

现在从$6$号点回溯到了$4$号点，发现$6$号点的老大小于$4$号点的老大所以将$4$号点的老大改为$2$，也即：

- **如果$y$点已经搜完了它周围的点，回溯到了$x$号点时，发现$y$号点的老大比$x$号点的老大要小，就用$y$号点的老大来更新$x$号点的老大。**

修改后的结果如下图。

![](https://cdn.luogu.com.cn/upload/pic/16718.png)

现在，$4$号点已经完成了任务，回溯到了$3$号点。因为$4$号点的老大比$3$号点的老大要小，所以便用$4$号点的老大来更新$3$号点的老大，修改后的结果如下图。

![](https://cdn.luogu.com.cn/upload/pic/16719.png)

现在，$2$号点也搜索完了周围的点，准备回溯，但是由于$2$号点的时间戳等于他的老大，那么就表明$2$号点是现在这个强连通分量（团队）中的老大，也即：

- **如有$x$号点的时间戳等于他的老大，那么就表明$x$号点是现在这个强连通分量（团队）中的老大。**

从$2$号点回溯到$1$号点后，因为$1$号点的时间戳等于他的老大，所以$1$号点是现在这个强连通分量（团队）中的老大。

模拟完毕~

【题目大意】

在有向图里，可以绕圈的情况下，取尽可能大的值。然后要求在有酒吧的点里尽可能大。

【题解】

通过题目我们可以想到强联通，我们可以算出每个强联通分量（联通块）内可以获得的最优解，并由此可以想到用**最长路**来解决这个问题，注意，是最长路哦。由于在一个强联通分量的点都可以互相到达，所以我们可以先**缩点**（也即将一个强联通分量视为一个点）再跑一次最长路，最后再扫一次有酒吧的点即可，因为我在代码里的点和边的结构体都有重复应用，所以要记得先清零，还有一点要注意的是是将团体连边，不是让点于点之间连边哦~

下面上AC代码~
```
#include <cstdio>
int f[2000001],chu[2000001],bb[2000001],l[2000001];
struct nodea{ int h,i,b,v,d; } a[5000001];
struct nodeb{ int x,y,gg; } b[5000001];
int len=0,tou=0,lx=0,lb=0,n=0,m=0,st=0,p=0;
void ins(int x,int y)
{
	len++;
	b[len].x=x;
	b[len].y=y;
	b[len].gg=a[x].h;
	a[x].h=len;
}
void dfs(int x)
{
	l[++tou]=x;
	a[x].i=++lx;
	a[x].d=lx;
	a[x].v=1;
	for(int i=a[x].h;i>0;i=b[i].gg)
	{
		int y=b[i].y;
		if(a[y].i==0)
		{
			dfs(y);
			if(a[y].d<a[x].d)
			{
				a[x].d=a[y].d;
			}
		}
		else if(a[y].v==1)
		{
			if(a[y].i<a[x].d)
			{
				a[x].d=a[y].i;
			}
		}
	}
	if(a[x].i==a[x].d)
	{
		lb++;
		while(true)
		{
			int k=l[tou--];
			a[k].v=0;
			a[k].b=lb;
			if(k==x)
			{
				break;
			}
		}
	}
}
void spfa()
{
	int tou=1,wei=2;
	f[1]=st;
	a[st].v=1;
	a[st].d=bb[st];
	while(tou!=wei)
	{
		int x=f[tou];
		for(int i=a[x].h;i>0;i=b[i].gg)
		{
			int y=b[i].y;
			if(a[y].d<a[x].d+bb[y])
			{
				a[y].d=a[x].d+bb[y];
				if(a[y].v==0)
				{
					a[y].v=1;
					f[wei]=y;
					wei++;
					if(wei>lb)
					{
						wei=1;
					}
				}
			}
		}
		a[x].v=0;
		tou++;
		if(tou>lb)
		{
			tou=1;
		}
	}
}
int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int x=0,y=0;
		scanf("%d %d",&x,&y);
		ins(x,y);
	}
	for(int i=1;i<=n;i++)
	{
		if(a[i].i==0)
		{
			dfs(i);
		}
	}
	int td=0;
	for(int i=1;i<=n;i++)
	{
		a[i].h=0;
		a[i].v=0;
		a[i].d=0;
		scanf("%d",&td);
		bb[a[i].b]+=td;
	}
	scanf("%d %d",&st,&p);
	int now=len;
	len=0;
	for(int i=1;i<=now;i++)
	{
		int x=b[i].x;
		int y=b[i].y;
		if(a[x].b!=a[y].b)
		{
			ins(a[x].b,a[y].b);
		}
	}
	st=a[st].b;
	spfa();
	int ans=0;
	int tx=0;
	for(int i=1;i<=p;i++)
	{
		scanf("%d",&tx);
		if(ans<a[a[tx].b].d)
		{
			ans=a[a[tx].b].d;
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：zhenyan2003 (赞：8)

### 题解中竟然没有用记忆化搜索的方法，我来补充一个
这道题前面的思路和其他题解一样，都是tarjan缩点。然后是要求金币的最大值，我用的是记忆化搜索，用jiyi[i]来表示从编号为i的联通块出发，最多可以抢到多少钱，搜索时如果遇到已经搜过的点（知道从那个点开始最多能抢多少钱）就直接return。因为记忆化搜索每个点只会遍历一次，所以记忆化搜索的复杂度应该是O(n)。

另外我的码风有点奇怪，先解释一下：stk[tk]分别是栈和栈的指针（tarjan用），num表示联通块个数，tim时间戳，shuyu[i]表示点i属于哪个联通块，he[]表示某个联通块内总共有多少钱，vis[]表示一个点是否在栈中，jiuba[]表示某个点是否有酒吧，suojb[]表示缩点后的连通块中是否有酒吧。bian[],head[],ecnt都是缩点前图中的边，如果后面有后缀x，则表示缩点后新图中的边；
## AC代码如下，具体看注释：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=500005;
int n,m,ecnt,s,p,tk,num,tim,ecntx,ans;
int qian[N],head[N],dfn[N],low[N],stk[N],shuyu[N],he[N],headx[N],jiyi[N];
bool vis[N],jiuba[N],suojb[N];
struct aaa
{
	int to,nxt;
}bian[N],bianx[N];
inline int read()//标准快读
{
    int x=0;bool f=0;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
    return f?-x:x;
}
inline void add(int a,int b)//链式前向星加边；
{
	bian[++ecnt].to=b;
	bian[ecnt].nxt=head[a];
	head[a]=ecnt;
}
inline void addx(int a,int b)//缩点后联通块与联通块加边；
{
	bianx[++ecntx].to=b;
	bianx[ecntx].nxt=headx[a];
	headx[a]=ecntx;
}
void tarjan(int u)//标准tarjan
{
	dfn[u]=low[u]=++tim;
	stk[++tk]=u;vis[u]=1;
	for(int i=head[u];i;i=bian[i].nxt)
	{
		int v=bian[i].to;
		if(!dfn[v])
			tarjan(v),low[u]=min(low[u],low[v]);
		else if(vis[v])low[u]=min(low[u],low[v]);
	}
	if(dfn[u]==low[u])
	{
		num++;
		while(stk[tk]!=u)
		{
			shuyu[stk[tk]]=num;//记录点属于的联通块；
			vis[stk[tk]]=0;
			stk[tk]=0;tk--;
		}
		shuyu[stk[tk]]=num;//此时栈顶还有一个点在此联通块中，再执行一次
		vis[stk[tk]]=0;
		stk[tk]=0;tk--;
	}
}
void suo()//缩点；
{
	for(int i=1;i<=n;i++)
	{
		he[shuyu[i]]+=qian[i];//更新每个联通块内的总钱数
		if(jiuba[i])suojb[shuyu[i]]=1;更新联通块内是否有酒吧
		for(int j=head[i];j;j=bian[j].nxt)
		{
			int v=bian[j].to;
			if(shuyu[i]!=shuyu[v])
				addx(shuyu[i],shuyu[v]);//如果起点和终点不在同一个联通块，就在这两个联通块之间加边；
		}
	}
}
int dfs(int dian)//缩了点，新图为有向无环图，此时才能dfs
{
	if(jiyi[dian])return jiyi[dian];//如果这个联通块已经被搜索过，即我们知道从这个点开始的最大钱数，就直接返回；
	if(headx[dian]==0&&suojb[dian]==1)//如果这个联通块出度为0并且此处有酒吧，就可以在此处停止，返回这个联通块的总钱数；
	{
		jiyi[dian]=he[dian];
		return he[dian];
	}
	if(headx[dian]==0&&suojb[dian]==0)return 0;//如果这个联通块出度为0但是没有酒吧，就不能停止在此处，所以它对答案的贡献是0；
	for(int i=headx[dian];i;i=bianx[i].nxt)
	{
		jiyi[dian]=max(jiyi[dian],dfs(bianx[i].to));//一个联通块的多个出度中取一个最大的；
	}
	if(jiyi[dian]==0&&suojb[dian]==0)return 0;
   	//注意：我们此时少考虑了一种情况，如果一条路径上一连串的点都没有酒吧，那么劫匪是不可以在这条路径上停下的，但如果没了这句话，程序还是会走这条路；加上这句话，如果后面的点没有酒吧 并且 此处也没有酒吧，那么它对答案的贡献是0,直接return 0;
	jiyi[dian]+=he[dian];//把自己的点权加进记忆化数组中；
	return jiyi[dian];//返回从这点开始的最大钱数；
}
int main()
{
	int a,b;
	n=read();m=read();
	for(int i=1;i<=m;i++)
	{
		a=read();b=read();
		add(a,b);
                //有个奇怪的错误，不能写add(read(),read());否则会出错，我也不知道为什么；
	}
	for(int i=1;i<=n;i++)
		qian[i]=read();
	s=read();p=read();
	for(int i=1;i<=p;i++)
		jiuba[read()]=1;
	for(int i=1;i<=n;i++)
		if(!dfn[i])
			tarjan(i);
	suo();
	ans=dfs(shuyu[s]);
	cout<<ans;
	return 0;
}
```



---

## 作者：hulean (赞：7)

### 图论 tarjan缩点+最短路 的一道题

- tarjan求强连通分量（为以后缩点打下良好的基础）

(如果不会tarjan的请点击[这儿](https://www.cnblogs.com/hulean/p/10856030.html))

```cpp
你需要的东西：
(1)、dfn[]，表示这个点在dfs时是第几个被搜到的。
(2)、low[]，表示这个点以及其子孙节点连的所有点中dfn最小的值
(3)、stack[]，表示当前所有可能能构成是强连通分量的点。
(4)、vis[]，表示一个点是否在stack中。
(5)、color[],记录每一个点强连通分量的编号。
(6)、deep,记录dfs树的深度
inline void tarjan(int now)
{
	dfn[now]=++deep;
	low[now]=deep;
	vis[now]=1;
	st.push(now);
	for(int i=0;i<ver[now].size();i++)
	{
		int x=ver[now][i];
		if(!dfn[x])
		{
			tarjan(x);
			low[now]=min(low[now],low[x]);
		}
		else
		{
			if(vis[x])
				low[now]=min(low[now],low[x]);
		}
	}
	if(dfn[now]==low[now])
	{
		color[now]=++sum;
		vis[now]=0;
		while(st.top()!=now)
		{
			color[st.top()]=sum;
			vis[st.top()]=0;
			st.pop();
		}
		st.pop();
	}
}
```
- 缩点（去除图中的环）

```cpp
//重点：这里建新图是依托强连通分量的编号来建的
for(int i=1;i<=n;i++)
	{
		for(int j=0;j<ver[i].size();j++)
		{
			int x=ver[i][j];
			if(color[i]!=color[x])//如果不是属于同一个强连通分量中，那么就合并
			{
				g[color[i]].push_back(color[x]);
           //千万不能写成g[i].push_back(x);坑死我了
			}
		}
	}
//这一部分代码还可以适当优化...（想一想）
```

- 对于点权与酒馆的一些处理（方便求最短路）

```cpp
for(int i=1;i<=n;i++)
	{
		ww[color[i]]+=w[i];//将这个强连通分量中所有的点权全部加起来
		if(tf[i])tf[color[i]]=1;//只要这个强连通分量中有一个结点有酒馆，那么就设定为有酒馆
	}
```

- 求最短路模板（然而实际是最长路）

```cpp
//模板不做解释
inline void spfa()
{
	d[color[s]]=ww[color[s]];
	queue<int>q;
	q.push(color[s]);
	while(q.size())
	{
		int now=q.front();
		q.pop();
		for(int i=0;i<g[now].size();i++)
		{
			int x=g[now][i];
			if(d[now]+ww[x]>d[x])
			{
				d[x]=d[now]+ww[x];
				q.push(x);
			}
		}
	}
}
```

**所以...**

在所有有酒馆的节点中选一个最大值输出就好了

```cpp
for(int i=1;i<=sum;i++)
	{
		//cout<<d[i]<<" ";
		if(tf[i])ans=max(ans,d[i]);
	}
```

完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=500000+10;
int n,m;
vector<int>ver[MAXN];
vector<int>g[MAXN];
int w[MAXN],ww[MAXN];
bool tf[MAXN];
int s,p,ans=0;
int dfn[MAXN],color[MAXN],low[MAXN];
int deep,sum;
bool vis[MAXN];
int d[MAXN];
stack<int>st;
inline int read()
{
	int tot=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
	{
		tot=tot*10+c-'0';
		c=getchar();
	}
	return tot;
}
inline void tarjan(int now)
{
	dfn[now]=++deep;
	low[now]=deep;
	vis[now]=1;
	st.push(now);
	for(int i=0;i<ver[now].size();i++)
	{
		int x=ver[now][i];
		if(!dfn[x])
		{
			tarjan(x);
			low[now]=min(low[now],low[x]);
		}
		else
		{
			if(vis[x])
				low[now]=min(low[now],low[x]);
		}
	}
	if(dfn[now]==low[now])
	{
		color[now]=++sum;
		vis[now]=0;
		while(st.top()!=now)
		{
			color[st.top()]=sum;
			vis[st.top()]=0;
			st.pop();
		}
		st.pop();
	}
}
inline void spfa()
{
	d[color[s]]=ww[color[s]];
	queue<int>q;
	q.push(color[s]);
	while(q.size())
	{
		int now=q.front();
		q.pop();
		for(int i=0;i<g[now].size();i++)
		{
			int x=g[now][i];
			if(d[now]+ww[x]>d[x])
			{
				d[x]=d[now]+ww[x];
				q.push(x);
			}
		}
	}
}
int main()
{
	//freopen("testdata.in","r",stdin);
	n=read();m=read();
	for(int i=1;i<=m;i++)
	{
		int x=read(),y=read();
		ver[x].push_back(y);
	}
	for(int i=1;i<=n;i++)
		w[i]=read();
	s=read();p=read();
	for(int i=1;i<=p;i++)
	{
		int x=read();
		tf[x]=1;
	}
	for(int i=1;i<=n;i++)
	{
		if(!dfn[i])
			tarjan(i);
	}
	/*cout<<endl;
	for(int i=1;i<=n;i++)
		cout<<color[i]<<" ";
	cout<<endl;*/
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<ver[i].size();j++)
		{
			int x=ver[i][j];
			if(color[i]!=color[x])
			{
				//cout<<i<<" "<<x<<" "<<color[i]<<" "<<color[x]<<endl;
				g[color[i]].push_back(color[x]);
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		ww[color[i]]+=w[i];
		if(tf[i])tf[color[i]]=1;
	}
	/*cout<<color[s]<<endl;
	cout<<endl;
	for(int i=1;i<=sum;i++)
	{
		for(int j=0;j<g[i].size();j++)cout<<i<<" "<<g[i][j]<<"\n";
	}
	cout<<endl;
	for(int i=1;i<=sum;i++)
		cout<<ww[i]<<" ";cout<<endl;
	for(int i=1;i<=sum;i++)
		cout<<tf[i]<<" ";cout<<endl;
	cout<<ww[color[s]]<<endl;*/
	spfa();
	for(int i=1;i<=sum;i++)
	{
		//cout<<d[i]<<" ";
		if(tf[i])ans=max(ans,d[i]);
	}
	//cout<<endl;
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：KevinYu (赞：6)

这一题与[Luogu P2656 ](https://www.luogu.org/problemnew/show/P2656)有异曲同工之妙。            
这一题的做法基于这样的一个事实:
```
上帝说，世界上有两种点(人)，
一种是在环内的(大括号换行的)，
一种是在环间的(大括号不换行的)
```
既然上帝他老人家都这样说了，我们就~~勉为其难地~~看看换在这一题里面有什么意义吧。       
其实已经很明显了，在一个环内的所有点都可以互相到达，也就是说只要抢了环内的一个点，就可以将环内所有点抢光，岂不美哉?       
于是我们跑一边Tarjan，将图缩成一个DAG。     
Tarjan算法过程(会的可以跳过了):      
tarjan算法基于时间戳与dfs实现，我们将一个点被发现的时间存入dfn数组中，然后将一个点够追溯到的最早的栈中节点的次序计入low数组中。        
我们来过一遍算法流程：
1.初始化:
```cpp
void tarjan(int u)
{
    low[u]=dfn[u]=++now;
    hep[++top]=u;vis[u]=1;
```
我们可以发现，tarjan的初始化中要完成2个工作:     
①.更新时间戳与low数组      
②.将节点压栈并打上标记       
2.tarjan主过程:
```cpp
    for(int i=head[u];i!=-1;i=a[i].next)
    {
		int v=a[i].to;
		if(!dfn[v]){tarjan(v);low[u]=min(low[u],low[v]);}
        	else if(vis[v])low[u]=min(low[u],dfn[v]);
    }
```
我们来慢慢分析它：    
我们首先遍历每一条边，然后对能到达的点进行访问:     
```cpp
    for(int i=head[u];i!=-1;i=a[i].next)
    {
		int v=a[i].to;
```
我们需要分出三种v点：     
1.从没访问过的     
对于这个点，我们将它作为下一个点，递归地进行tarjan过程。    
在tarjan结束后，更新它的low数组。      
你可以把更新的过程理解成从tarjan过程里回传来了它的low值，我们将它的low值与现在这个节点的low值比较，并取较小值。
```cpp
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
```
2.访问过，并在栈里的       
这种节点是可以到达当前节点的，我们发现了这样一个点，就是发现了一个强连通分量，于是我们对当前点的low值进行更新
```cpp
        else if(vis[v])low[u]=min(low[u],dfn[v]);
```
3.访问过，但不在栈里的          
都不能到达你，跟你有什么关系吗，直接忽视掉就行了。      
3.退栈:
```cpp
    if(dfn[u]==low[u])
    {
        ++tot;
        vis[u]=0;
        while(hep[top+1]!=u)
        {
            fa[hep[top]]=tot;
            vis[hep[top--]]=0;
        }
    }
}
```
整个退栈过程就是记录强连通分量的过程，下面我就来详细解释一下。         
退栈的条件是```dfn[u]==low[u]```，代表着我们的遍历过程已经触底，并且回溯回来了。      
在我们当前点上方的都是什么点呢？都是在同一个强连通分量中的点。所以我们将其全部取出，并记录进一个强连通分量中(一般管这个叫“染色”)。       
tarjan缩点过程完整代码:
```cpp
void tarjan(int u)
{
    low[u]=dfn[u]=++now;
    hep[++top]=u;vis[u]=1;
    for(int i=head[u];i!=-1;i=a[i].next)
    {
		int v=a[i].to;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
        else if(vis[v])low[u]=min(low[u],dfn[v]);
    }
    if(dfn[u]==low[u])
    {
        ++tot;
        vis[u]=0;
        while(hep[top+1]!=u)
        {
            fa[hep[top]]=tot;
            vis[hep[top--]]=0;
        }
    }
}
```
有了这个有力武器之后，我们就可以来看看完整的算法流程了。         
1.建图:
```cpp
int main()
{
    memset(head,-1,sizeof(head));
    scanf("%d%d",&n,&m);
    while(m--)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        addedge(x,y);
        edges[cnt].from=x;
        edges[cnt].to=y;
    }
    for(int i=1;i<=n;i++)scanf("%d",&p[i]);
    scanf("%d%d",&s,&m);
    for(int i=1;i<=m;i++){int x;scanf("%d",&x);isbar[x]=1;}
```
2.我们把图建好之后，还要重新建图(这就是前面的edges数组的作用)。        
```cpp
    tarjan(s);
    memset(vis,0,sizeof(vis));
    memset(head,-1,sizeof(head));
    memset(a,0,sizeof(a));
    for(int i=0;i<=cnt-1;i++)
    {
        int u,v;
        u=edges[i].from;
        v=edges[i].to;
        if(!fa[u]||!fa[v])continue;
        if(fa[u]==fa[v]){int x=fa[u];if(isbar[u]||isbar[v])flg[x]=1;}
        else{addedge(fa[u],fa[v]);if(isbar[u])flg[fa[u]]=1;if(isbar[v])flg[fa[v]]=1;in[fa[v]]++;}
    }
    for(int i=1;i<=n;i++)dq[fa[i]]+=p[i];
```
这些搞定之后，这一题基本就没有难度了。      
剩下的就是求最大点权和，topo+dp即可。     
（顺带一提，spfa也可以求最大点权和，但topo好写啊）      
```cpp
    solve(fa[s]);
    int ans(-1);
    for(int i=1;i<=tot;i++)if(flg[i])ans=max(d[i],ans);
    printf("%d",ans);
    return 0;
}
```
solve函数(可替换为spfa):
```cpp
void solve(int s)
{
    memset(d,-INF,sizeof(d));
    memset(vis,0,sizeof(vis));
    queue<int> q;
    q.push(s);
    d[s]=dq[s];
    vis[s]=1;
    while(!q.empty())
    {
        int t=q.front();
        q.pop();
        vis[t]=0;
        for(int i=head[t];i!=-1;i=a[i].next)
        {
            int v=a[i].to;
            d[v]=max(d[v],d[t]+dq[v]);
            if(!(--in[v])){q.push(v);vis[v]=1;}
        }
    }
}
```
完整代码:
```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<ctime>
#include<climits>
#include<cstdlib>
#include<algorithm>
#include<complex>
#include<iostream>
#include<map>
#include<queue>
#include<vector>
#define INF 0x3f3f3f3f
#define ll long long
using namespace std;
struct node
{
    int to,next;
}a[2000020];
int head[1000010];
int cnt(0);
void addedge(int xi,int yi)
{
    a[cnt].to=yi;
    a[cnt].next=head[xi];
    head[xi]=cnt++;
}
struct arcs
{
    int from,to;
}edges[2000020];
int dfn[1000010];
int low[1000010];
int p[1000010];
int dq[1000010];
int d[1000010];
int fa[1000010];
int isbar[1000010];
int vis[1000010];
int flg[1000010];
int in[1000010];
int now(0);
int hep[1000010];
int top(0);
int tot(0);
int n,m,s;
void tarjan(int u)
{
    low[u]=dfn[u]=++now;
    hep[++top]=u;vis[u]=1;
    for(int i=head[u];i!=-1;i=a[i].next)
    {
        int v=a[i].to;
        if(!dfn[v])
        {
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }
        else if(vis[v])low[u]=min(low[u],dfn[v]);
    }
    if(dfn[u]==low[u])
    {
        ++tot;
        vis[u]=0;
        while(hep[top+1]!=u)
        {
            fa[hep[top]]=tot;
            vis[hep[top--]]=0;
        }
    }
}
void solve(int s)
{
    memset(d,-INF,sizeof(d));
    memset(vis,0,sizeof(vis));
    queue<int> q;
    q.push(s);
    d[s]=dq[s];
    vis[s]=1;
    while(!q.empty())
    {
        int t=q.front();
        q.pop();
        vis[t]=0;
        for(int i=head[t];i!=-1;i=a[i].next)
        {
            int v=a[i].to;
            d[v]=max(d[v],d[t]+dq[v]);
            if(!(--in[v])){q.push(v);vis[v]=1;}
        }
    }
}
int main()
{
    memset(head,-1,sizeof(head));
    scanf("%d%d",&n,&m);
    while(m--)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        addedge(x,y);
        edges[cnt].from=x;
        edges[cnt].to=y;
    }
    for(int i=1;i<=n;i++)scanf("%d",&p[i]);
    scanf("%d%d",&s,&m);
    for(int i=1;i<=m;i++){int x;scanf("%d",&x);isbar[x]=1;}
    tarjan(s);
    memset(vis,0,sizeof(vis));
    memset(head,-1,sizeof(head));
    memset(a,0,sizeof(a));
    for(int i=0;i<=cnt-1;i++)
    {
        int u,v;
        u=edges[i].from;
        v=edges[i].to;
        if(!fa[u]||!fa[v])continue;
        if(fa[u]==fa[v]){int x=fa[u];if(isbar[u]||isbar[v])flg[x]=1;}
        else{addedge(fa[u],fa[v]);if(isbar[u])flg[fa[u]]=1;if(isbar[v])flg[fa[v]]=1;in[fa[v]]++;}
    }
    for(int i=1;i<=n;i++)dq[fa[i]]+=p[i];
    solve(fa[s]);
    int ans(-1);
    for(int i=1;i<=tot;i++)if(flg[i])ans=max(d[i],ans);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：HPXXZYY (赞：5)

## $$\color{green}{\text{洛谷P3627\ \ \ \ \ [APIO2009]抢掠计划}}$$

$\color{blue}{\text{【题意】：}}$ `Siruseri` 城中的道路都是 $\color{red}{\text{单向}}$ 的。不同的道路由路口连接。按照法律的规定， 在每个路口都设立了一个 `Siruseri` 银行的 `ATM` 取款机。令人奇怪的是，`Siruseri` 的酒吧也都设在路口，虽然并不是每个路口都设有酒吧。

`Banditji` 计划实施 `Siruseri` 有史以来最惊天动地的 `ATM` 抢劫。他将从市中心 出发，沿着单向道路行驶，抢劫所有他途径的 `ATM` 机，最终他将在一个酒吧庆祝他的胜利。

使用高超的黑客技术，他获知了每个 `ATM` 机中可以掠取的现金数额。他希望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。**他可以经过同一路口或道路任意多次。但只要他抢劫过某个 `ATM` 机后，该 `ATM` 机 里面就不会再有钱了。**

例如，假设该城中有 $6$ 个路口，道路的连接情况如下图所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200329134943889.png)

市中心在路口 $1$，由一个入口符号 $\to$ 来标识，那些有酒吧的路口用双圈来表示。每个 `ATM` 机中可取的钱数标在了路口的上方。在这个例子中，`Banditji` 能抢劫的现金总数为 $47$，实施的抢劫路线是：$1 \to 2 \to 4 \to 1 \to 2 \to 3 \to 5$。

$\color{blue}{\text{【思路】：}}$ 有向图的题目，很容易让人想到有向无环图（`DAG`）。因为 `DAG` 比有向有环图时的情况要简单得多。

所以，我们可以先用 `tarjan` 把原图缩点，顺便维护出每个 `scc` （强连通分量）中所有 `ATM` 内钱的总量 $\text{money}$ 和是否有酒店。

缩点后，原图变为了一个 `DAG`。我们可以用拓扑算法求解。代码如下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200329135709659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pIVVlJTkdZRV8xMjM0NTY=,size_16,color_FFFFFF,t_70)

为什么这么做是可以的呢？因为 `Banditji` 可以重复走一条路很多次。我们进入一个 `scc` 后，因为 `scc` 内所有点可以直接或间接互相到达，所以我们一定要把它内的所有 `ATM` 全部抢完，否则不优。同时，因为 `Banditji` 可以重复走一条路很多很多次，所以抢完后，无论他在什么地方，他总能走到其它点从而到达其它 `scc`。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200329140406178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pIVVlJTkdZRV8xMjM0NTY=,size_16,color_FFFFFF,t_70)

如图，蓝圈表示一个 `scc`，黑圈表示一个点。当 `Banditji` 在 `SCC 1` 中随意走到容易一个节点时，他都可以沿边走到 $3$ 号点，从而到达 `SCC 2`。所以，我们的算法是正确的。

下一个问题：如何求答案？很简单，求出所有有酒店的 `SCC` 中最大的 $\text{dp}$ 值即可。正因为它是一个 `scc`，所以 `Banditji` 无论在天涯海角，他都可以走到那个酒店中结束他的行程。正符合题意！！！

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200329140922646.png)
做到这里，这道题就算可以 `AC` 了。剩下的问题就是打 `tarjan` 算法的板子了。最后整理一下我们的思路：

- 1. `tarjan` 算法缩点——把有向有环图变成 `DAG`。
- 2. 建立一个只有 `scc` 的新图。
- 3. 调用拓扑排序算法辅以 $\text{dp}$ 求解（即 `topo_algorithm_and_dp` 函数）
- 4. 输出（即 `print_the_answer` 函数）

$\color{blue}{\text{【代码】：}}$

```cpp
const int N=5e5+100;
struct edge{
	int next,to;
}e[N],E[N];int H[N],Tot,h[N],tot;
inline void add(int a,int b){
	e[++tot]=(edge){h[a],b};h[a]=tot;
}
inline void ADD(int a,int b){
	E[++Tot]=(edge){H[a],b};H[a]=Tot;
}
bool have_a_bar[N];
int n,m,s,p,value[N];
void read_the_data(){
	n=read();m=read();//专司输入 
	for(int i=1,u,v;i<=m;i++){
		u=read();v=read();add(u,v);
	}
	for(int i=1;i<=n;i++)
		value[i]=read();
	s=read();p=read();
	for(int i=1;i<=p;i++)
		have_a_bar[read()]=1;
}
int Stack[N],stack_top;
int dfn[N],low[N],dfscnt;
int belong[N],scc,num[N];
int money[N];bool bar[N];
void tarjan(int u){
	Stack[++stack_top]=u;
	low[u]=dfn[u]=++dfscnt;
	for(int i=h[u];i;i=e[i].next){
		register int to=e[i].to;
		if (dfn[to]==0){
			tarjan(to);//递归进行计算 
			low[u]=min(low[u],low[to]);
		}
		else if (belong[to]==0)
			low[u]=min(low[u],dfn[to]);
	}
	if (dfn[u]==low[u]){
		num[belong[u]=++scc]=1;
		bar[scc]=have_a_bar[u];
		money[belong[u]]=value[u];
		while (Stack[stack_top]!=u){
			int t=Stack[stack_top];
			num[belong[t]=scc]++;
			money[scc]+=value[t];
			bar[scc]|=have_a_bar[t];
			--stack_top;
		}
		--stack_top;
	}
}
int ind[N],dp[N],ans;
void build_new_picture(){
	for(int u=1;u<=n;u++)
		for(int i=h[u];i;i=e[i].next){
			register int to=e[i].to;
			if (belong[u]!=belong[to]){
				++ind[belong[to]];
				ADD(belong[u],belong[to]);
			}
		}
}
void topo_algorithm_and_dp(){
	queue<int> q;//拓扑所需的队列 
	memset(dp,128,sizeof(dp));
	for(int i=1;i<=scc;i++)
		if (ind[i]==0) q.push(i);
	dp[belong[s]]=money[belong[s]];
	while (q.size()){
		int u=q.front();q.pop();
		for(int i=H[u];i;i=E[i].next){
			register int to=E[i].to;
			dp[to]=max(dp[to],dp[u]+money[to]);
			if ((--ind[to])==0) q.push(to);
		}
	}
}
void print_the_answer(){
	for(int i=1;i<=scc;i++)
		if (bar[i]&&dp[i]>ans)
			ans=dp[i];
	printf("%d",ans);
}
int main(){
	read_the_data();
	for(int i=1;i<=n;i++)
		if (!dfn[i]) tarjan(i);
	build_new_picture();
	topo_algorithm_and_dp();
	print_the_answer();
	return 0;
}


本代码已经 AC（本人亲自实验）且无任何反作弊系统。请读者放心。

代码中的 read 函数就是快点函数（反正没人看，干脆不给了）
```

------------------------------

如果洛谷的 `LaTeX` 炸了，大家可以去我的博客里看 ~~（随便刷刷访问量和点赞）~~。

[https://blog.csdn.net/ZHUYINGYE_123456/article/details/105177708](https://blog.csdn.net/ZHUYINGYE_123456/article/details/105177708)

---

## 作者：shame_djj (赞：3)

原题链接[【[APIO2009]抢掠计划】](https://www.luogu.org/problem/P3627)

缩点，水题一道~~

题意

		大概就是要求一个从 1 开始的路径，

		要求结束的一个点是有酒吧，

		路径上点可重复经过，但同一个点的点权只计算一次。

~~这一看就是缩点了啦~~

**可重复经过**~~，

这句话经常就是我们判断一道图上的题是否就是 tarjan ~~水~~题的标准

那么本题，缩完点了，建完新图了，然后呢~~

一个简单的想法是在新图上跑一边最长路（和最短路几乎一样）

当然你也可以换成 dp , 或者记搜什么的

然后在所有的有酒吧的连通块里选择一个最优的

新问题来了，怎么跑最短路

点权转边权~~

怎么个转法？

我觉得我的思路不错，因此发了这篇题解

**拆点，把一个点拆成两个点，该边边权即为该点点权**

然后跑 spfa 最长路就好了

给出代码
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <queue>
#include <cmath>

using namespace std;
const int maxn = 5e5 + 10;
const int INF = 1 << 25;

inline int read() {
    char c = getchar(); int x = 0, f = 1;
    for (; c > '9' || c < '0'; c = getchar()) if (c == '-') f = -1;
    for (; c >='0' && c <='9'; c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);
    return x * f;
}

int a[maxn], id[maxn], sum[maxn], stack[maxn], top, gg, k;
int dis[maxn << 1], ver[maxn], nxt[maxn], head[maxn], tot;
vector <int> h[maxn << 1], hh[maxn << 1];
int p[maxn], dfn[maxn], low[maxn], cnt;
bool ins[maxn], vis[maxn << 1];
int n, m, u, v, S, P, ans;
queue <int> q;

void add_edge () {
    u = read(), v = read();
    ver[++ tot] = v;
    nxt[tot] = head[u];
    head[u] = tot;
}

void tarjan (int x) {
    dfn[x] = low[x] = ++ cnt;
    stack[++ top] = x;
    ins[x] = 1;
    for (register int i = head[x]; i; i = nxt[i]) {
        if (!dfn[ver[i]])
            tarjan (ver[i]), low[x] = min (low[x], low[ver[i]]);
        else if (ins[ver[i]])
            low[x] = min (low[x], dfn[ver[i]]);
    }
    if (dfn[x] == low[x]) {
        ++ gg;
        do {
            k = stack[top --];
            ins[k] = 0;
            id[k] = gg;
            sum[gg] += a[k];
        } while (x != k);
    }
}

void djj () {
    n = read(), m = read();
    for (; m; m --)
        add_edge ();
    for (register int i = 1; i <= n; i ++)
        a[i] = read();
    for (register int i = 1; i <= n; i ++)
        if (!dfn[i]) tarjan (i);
    S = read(), P = read();
    for (register int i = 1; i <= P; i ++)
        p[i] = read();
}

void lxy () {
    for (register int i = 1; i <= n; i ++)
        for (register int j = head[i]; j; j = nxt[j])
            if (id[i] != id[ver[j]])
                h[id[i] + gg].push_back (id[ver[j]]), hh[id[i] + gg].push_back (0);
    for (register int i = 1; i <= gg; i ++)
        h[i].push_back (i + gg), hh[i].push_back (sum[i]);
    memset (dis, - INF, sizeof dis);
    vis[id[S]] = 1, dis[id[S]] = 0;
    q.push (id[S]);
    for (; !q.empty (); ) {
        int u = q.front ();
        q.pop (), vis[u] = 0;
        for (register int i = 0; i < h[u].size(); i ++) {
            int v = h[u][i], w = hh[u][i];
            if (dis[v] < dis[u] + w) {
                dis[v] = dis[u] + w;
                if (!vis[v]) {
                    q.push (v);
                    vis[v] = 1;
                }
            }
        }
    }
    for (register int i = 1; i <= P; i ++)
        ans = max (ans, dis[id[p[i]] + gg]);
    printf ("%d\n", ans);
}

void djj_lxy () {
    djj (), lxy ();
}

int main() {
    djj_lxy ();
}

/* 样例，本题样例还算不错了
6 7
1 2
2 3
3 5
2 4
4 1
2 6
6 5
10
12
8
16
1
5
1 4
4 3 5 6

47
*/

```

本题就完了，完结撒花~~

距离新 Noip 还有不到 2 个月的时间，祝大家 rp ++

也希望自己能更努力一些，**加油！**


---

## 作者：夏色祭 (赞：3)

##居然没有P的，强行水一发

##NOIP2017考前我们一次膜你赛的t4。。。我是pj。。。（这是最骚的

用边表存图，先用tarjan缩点，即把每一个强连通分量缩成一个点，用color[i]表示染色，即第i个点在缩点后属于第几个强连通分量

然后用spfa跑一个最长路

**昨天才学tarjan的蒟蒻**~~滑稽~~

丑陋的代码：


```cpp
uses math;
var
  a,next,last,b,c,q,color,x,y,dfn,low,dis,f:array[0..500001]of longint;
  vis,bar:array[0..500001]of boolean;
  n,m,i,j,tot,top,k,start,d,sum,ans,t:longint;
procedure add(x,y:longint);
begin
  inc(tot); 
  a[tot]:=y; 
  next[tot]:=last[x]; 
  last[x]:=tot;
end;
procedure tarjan(k:longint);
var
  i,t:longint;
begin
  inc(d); inc(top);
  q[top]:=k;vis[k]:=true;
  low[k]:=d;dfn[k]:=d;
  i:=last[k];
  while i>0 do 
    begin
      t:=a[i];
      if dfn[t]=0 then //如果节点t未被访问过
        begin
          tarjan(t); //继续向下找
          low[k]:=min(low[k],low[t]);
        end
        else
          if vis[t] then low[k]:=min(low[k],dfn[t]); //如果节点t还在栈内
      i:=next[i];
    end;
  if dfn[k]=low[k] then //说明k为一个强连通分量的根
    begin
      inc(sum);
      while q[top+1]<>k do
        begin
          color[q[top]]:=sum;
          vis[q[top]]:=false;
          inc(b[sum],c[q[top]]);
          dec(top);
        end;//更新新的一个强连通分量
    end;
end; //tarjan
procedure spfa(start:longint);
var
  i,y,h,t:longint;
begin
  fillchar(vis,sizeof(vis),0);
  h:=0; t:=1;
  f[1]:=start;
  dis[start]:=b[start];
  while h<t do 
    begin
      inc(h);
      y:=f[h];
      vis[y]:=false;
      i:=last[y];
      while i>0 do 
        begin
          if dis[y]+b[a[i]]>dis[a[i]] then 
            begin
              dis[a[i]]:=dis[y]+b[a[i]];
              if not vis[a[i]] then 
                begin
                  inc(t);
                  f[t]:=a[i];
                  vis[a[i]]:=true;
                end;
            end;
          i:=next[i];
        end;
    end;
  for i:=1 to sum do 
    if bar[i] then ans:=max(ans,dis[i]);
end;//普通的SPFA 不解释
begin
  readln(n,m);
  for i:=1 to m do 
    begin
      readln(x[i],y[i]);
      add(x[i],y[i]);
    end;
  for i:=1 to n do read(c[i]);//读入
  for i:=1 to n do 
    if color[i]=0 then tarjan(i);//对没有染色点进行一次tarjan
  //for i:=1 to n do write(color[i],' ');
  fillword(a,sizeof(a) >> 1,0);
  fillword(next,sizeof(next) >> 1,0);
  fillword(last,sizeof(last) >> 1,0);
  tot:=0;
  for i:=1 to m do 
    if color[x[i]]<>color[y[i]] then add(color[x[i]],color[y[i]]);//重新建图
  readln(start,k);
  start:=color[start];
  for i:=1 to k do 
    begin
      read(t);
      bar[color[t]]:=true;
    end;//记录酒吧所在的强连通分量
  spfa(start);
  writeln(ans);
end.

```

---

## 作者：风羽跃 (赞：2)


### 题目翻译:

给出一个有向有环图，n个节点，m条有向边。

求从起点S到多个终点的单源最长路（注意有可能存在正环！！！）

### 算法分析：

最短路+强连通分量:

(SPFA+Tarjan)

首先，题目中说“从市中心开始到某个酒吧结束所能抢劫的最多的现金总数”，从一个地方到另一个地方，求最长，很自然地想到单源最长路。至于如何求单源最长路，后面会解释。

但是，图中有可能存在正环。按照常理讲，“最长路”就是跑得越多越好。如果存在正环，很显然会不停地在这个环中遍历。这样就不会有最优解。

那怎么办呢？

题目说“只要他抢劫过某个 ATM 机后，该 ATM 机 里面就不会再有钱了。”也就是说，不能经过重复的路径，既每个环只能跑一次，这样就避免了这种情况！！！

那么，对于正环，我们怎么处理呢？

其实，环就是一个强连通分量（图中任意两点都互相连通的子图）。
所以我们可以用Tarjan（一种求强连通分量的算法）缩点，然后形成的新点的权（或者说能抢到的钱吧）就是之前的强连通分量中所有点权的和。

证明：一旦进入一个强连通分量中的任意一个点之后，因为要求最优解，所以不停地遍历这个强连通分量里的所有点一定不会比其他决策差。

关于如何求最长路：

因为题目给的是点权，我们需要点权转边权，也就是一个点所有入边的边权等于这个点的边权。

因为站在起点上，不需要走路也可以抢这个点，所以起点的dis是它自己的点权。

至于最长：

如果一个数是正数，那么它本身越大，它的相反数越小。
所以我们就把所有边权都乘-1，按照最短路跑，最后输出答案时再乘-1就OK了！！！

因为多个终点，所以还要再扫一遍。

### 最后，再捋一遍思路：
通过强连通分量缩点（统计点权）->点权转边权 -> 边权乘-1-> 求最长路 -> 统计答案

AC代码：
```cpp
#include<iostream>
#include<cstdio>
#include<stack>
#include<queue>
#include<map>

#define maxn 500001
#define maxm 500001

#define INF 0x7fffffff/2

using namespace std;

int cnt;
int cnt1;
struct Node{
	int head;
	int dfn,low;
	int color;
	int dis;
	int len;
	bool vis;
}node[maxn],car[maxn];
//链式前向星存图
struct Edge{
	int next;
	int to;
	int from;
}edge[maxm],edg[maxm];
//我存了两个图，一个是原来的，另一个是缩点以后的

int n,m,S,P;
int u,v,p[maxn];

int deep,col;//Tarjan时间戳

stack<int>s;

void add_edge(int u,int v)
{
	edge[++cnt].next=node[u].head;
	edge[cnt].from=u;
	edge[cnt].to=v;
	node[u].head=cnt;
}
//存边

void Add_edge(int u,int v)
{
	edg[++cnt1].next=car[u].head;
	edg[cnt1].to=v;
	car[u].head=cnt1;
}
//两个图，两个函数

void Tar(int u)//Tarjan算法
{
	if(!node[u].dfn){
		deep++;
		node[u].dfn=node[u].low=deep;
		node[u].vis=true;
		s.push(u);
	}
	int v;
	for(int e=node[u].head;e;e=edge[e].next){
		v=edge[e].to;
		if(!node[v].dfn){
			Tar(v);
			node[u].low=min(node[u].low,node[v].low);
		}
		else{
			if(node[v].vis){
				node[u].low=min(node[u].low,node[v].dfn);
			}
		}
	}
	if(node[u].dfn==node[u].low){
		col++;
		while(s.top()!=u){
			int t=s.top();
			node[t].color=col;//染色，代表第几个分量
			node[t].vis=false;
			car[col].len+=node[t].len;//统计缩完之后点的权
			s.pop();
		}
		s.pop();
		node[u].color=col;
		node[u].vis=false;
		car[col].len+=node[u].len;
	}
}


void SPFA(int s)//SPFA最短路
{
	//一种颜色（或者说一个分量）缩成一个点，点数就是颜色种数
	for(int i=1;i<=col;i++){
		car[i].dis=INF;
	}
	queue<int>q;
	q.push(s);
	car[s].vis=true;
	car[s].dis=car[s].len;//不走也可以抢钱
	while(!q.empty()){
		int u=q.front(),v;
		q.pop();
		car[u].vis=false;
		for(int e=car[u].head;e;e=edg[e].next){
			v=edg[e].to;
			if(car[v].dis>car[u].dis+car[v].len){
				car[v].dis=car[u].dis+car[v].len;//这里我直接用点权代替边权，没有直接写出点权转边权的过程
				if(!car[v].vis){
					q.push(v);
					car[v].vis=true;
				}
			}
		}
	}
}

int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>u>>v;
		add_edge(u,v);
	}
	for(int i=1;i<=n;i++){
		cin>>node[i].len;
		node[i].len*=-1;//边权乘-1
	}
	cin>>S>>P;
	for(int i=1;i<=P;i++){
		cin>>p[i];
	}
	for(int i=1;i<=n;i++){
		if(!node[i].color){
			Tar(i);//防止特殊数据出现不连通的图
		}
	}
	for(int i=1;i<=m;i++){
		int u=edge[i].from,v=edge[i].to;
		if(node[u].color!=node[v].color){
        //如果属于两个不同的分量就加边
			Add_edge(node[u].color,node[v].color);
            //以点的颜色（属于第几个强连通分量）作为下标
		}
	}
	int ans=INF;
	SPFA(node[S].color);
	for(int i=1;i<=P;i++){
		ans=min(ans,car[node[p[i]].color].dis);//统计答案
	}
	cout<<-ans<<endl;//答案再倒过来
	return 0;
}


```


---

## 作者：lemir3 (赞：2)

[*获得更好的阅读体验*](https://www.cnblogs.com/Lemir3/p/11089583.html)

[*题面*](https://www.luogu.org/problemnew/show/P3627)

呼呼呼,这道题其实很好看出要缩点吧.

因为每个点遍历一遍只加一次权值,但是可以多次遍历一个点.

所以我们就可以用Tarjan先把点缩了,就是说把每个强联通分量中的点染成同一个颜色,如果起点在分量内的话,就把这个强联通分量标记为起来,如果有酒馆的话,就把这个分量标记为终点.

之后把缩过的点连成一个新图,跑一遍最长路求出最大收益.

有多个酒馆,就有多个终点,在最后有酒馆标记中的点刷一遍最大值就可以了.

需要注意的是,这道题是点权图,在染强连通分量时要把每个点的权值叠加到分量中,然后开另一个用于记录达到该点时最长路的数组.

我用的Dijkstra堆优化跑最长路,但是#3T掉了,于是加了O3优化才跑过的.[*zsx*](https://www.cnblogs.com/zsx6/)大佬给我说这道题是稀疏图,跑SPFA其实还要快一些.希望大家以后牢记警钟,小心求证,大胆实验(雾).

用Dijkstra的代码,不算注释刚好200行:

```cpp

#pragma GCC diagnostic error "-std=c++11"
#pragma GCC target("sse2")
#pragma GCC optimize(3)
#pragma GCC target("avx")
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-funroll-loops")
#pragma GCC optimize("-fwhole-program")
#pragma GCC optimize("-freorder-blocks")
#pragma GCC optimize("-fschedule-insns")
#pragma GCC optimize("inline-functions")
#pragma GCC optimize("-ftree-tail-merge")
#pragma GCC optimize("-fschedule-insns2")
#pragma GCC optimize("-fstrict-aliasing")
#pragma GCC optimize("-fstrict-overflow")
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-fcse-skip-blocks")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-fhoist-adjacent-loads")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("inline-small-functions")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("-funsafe-loop-optimizations")
#pragma GCC optimize("inline-functions-called-once")
#pragma GCC optimize("-fdelete-null-pointer-checks")

#include<cstdio>
#include<queue>
#include<stack>
#include<algorithm>
#include<cstring>
#include<vector>
#include<map>

using namespace std;

priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;
vector<int>NodeEdge[500010];
stack<int>s;

struct edge
{
        int to,next;
}e[500010],NewE[500010];

int n,m,s_,p,size,time_cnt,cnt,start,ans=-2147483645;
int dis[500010],head[500010],dfn[500010],low[500010],color[500010],NodeDis[500010],TheLongestPath[500010];
bool wine[500010],flag[500010],NodeWine[500010],NodeFlag[500010];

void EdgeAdd(int,int);
void Tarjan(int);
void Dijkstra();

int main()
{
        memset(head,-1,sizeof(head));
        scanf("%d%d",&n,&m);
        for(int _=1;_<=m;_++)
        {
                int father,son;
                scanf("%d%d",&father,&son);
                EdgeAdd(father,son);
        }
        for(int _=1;_<=n;_++)
        {
                scanf("%d",dis+_);
        }
        scanf("%d%d",&s_,&p);
        for(int _=1;_<=p;_++)
        {
                int a;
                scanf("%d",&a);
                wine[a]=true;
        }
        for(int _=1;_<=n;_++)
        {
            if(dfn[_]==0)
            {
                Tarjan(_);
            }
        }
        for(int _=1;_<=n;_++)
        {
            for(int __=head[_];__!=-1;__=e[__].next)
            {
                int to=e[__].to;
                if(color[_]!=color[to])
                {
                    NodeEdge[color[_]].push_back(color[to]);
 //                   printf("edge:%d %d val:%d %d\n",color[_],color[to],NodeDis[color[_]],NodeDis[color[to]]);
                }
            }
        }
        Dijkstra();
        for(int _=1;_<=cnt;_++)
        {
            if(NodeWine[_]==true)
            {
                   ans=max(ans,TheLongestPath[_]);
            }
        }
        printf("%d\n",ans);
return 0;
}

void EdgeAdd(int from,int to)
{
        e[++size].to=to;
        e[size].next=head[from];
        head[from]=size;
}

void Tarjan(int from)
{
    dfn[from]=low[from]=++time_cnt;
    s.push(from);
    flag[from]=true;
    for(int _=head[from];_!=-1;_=e[_].next)
    {
        int to=e[_].to;
        if(dfn[to]==0)
        {
            Tarjan(to);
            low[from]=min(low[from],low[to]);
        }
        else if(flag[to]==true)
        {
            low[from]=min(low[from],dfn[to]);
        }
    }
    if(dfn[from]==low[from])
    {
        cnt++;
        while(!s.empty())
        {
            int temp=s.top();
            s.pop();
            flag[temp]=false;
            color[temp]=cnt;
            if(wine[temp]==true)
            {
                NodeWine[cnt]=true;
            }
            if(temp==s_)
            {
                start=cnt;
            }
            NodeDis[cnt]+=dis[temp];
            if(temp==from)break;
        }
    }
}

void Dijkstra()
{
    memset(NodeFlag,false,sizeof(NodeFlag));
    memset(TheLongestPath,-0x3f,sizeof(TheLongestPath));
    q.push(make_pair(dis[start],start));
    TheLongestPath[start]=NodeDis[start];
    while(!q.empty())
    {
        int from=q.top().second;
        q.pop();
        if(NodeDis[from]==true)continue;
        NodeFlag[from]=true;
        for(int _=0;_<NodeEdge[from].size();_++)
        {
            int to=NodeEdge[from][_];
            if(TheLongestPath[to]<TheLongestPath[from]+NodeDis[to])
            {
                TheLongestPath[to]=TheLongestPath[from]+NodeDis[to];
 //               printf("path:%d %d TheLongestPath:%d\n",from,to,TheLongestPath[to]);
                q.push(make_pair(NodeDis[to],to));
            }
        }
     }
}

```


---

## 作者：全网最蒻 (赞：2)

 ## P3627(抢掠计划）
这道题开始的时候没啥思路，但因为之前做过缩点的模板，
所以对这样的题目描述很敏感，所以tarjan缩点也就大概想出来了，至于原因，我是这样想的，因为每个点和边都是可以重复遍历的，所以如果我们到达了一个强联通分量，那么我们不如全部走一遍，这样一定更好，所以就可以缩点，锁完点之后的权值为之前的强联通分量中的点的权值和。之后我们机房的一个神仙又给我指导了一下之后该怎么做：我们把点的权值转化为边的权值，每个点的权值变成他的出边的权值，这样的操作会使终点的权值丢失，所以我们建立一个汇点，让终点连向他，权值为终点的权值，这样就可以把点权转化为边权，但是这样怎么维护终点必须为酒吧呢，想到可以仅仅只把酒吧点与汇点连边，这样就保证了终点的合法性，然后我为了方便，建了个源点向起点所在联通块连边权为0的边，最后以源点开始，跑一遍SPFA求最长路答案就出来了，至于tarjan和spfa本蒟蒻就不讲解了，前面都有大佬的讲解，AC代码如下

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<stack>
#include<cstring>
#include<queue>
using namespace std;
const int maxn = 500040;
const int maxm = 500050;
struct edge{
	int v,nxt;
}e[maxm];
int weight[maxn];
int low[maxn];
int dfn[maxn];
int ins[maxn];
int used[maxn];
int tot;
int Head[maxn];
struct Edge{
	int v,nxt,w;
}E[maxm];
int head[maxn];
int cnt;
int dis[maxn];
int vis[maxn];
int color;
int colorname[maxn];
int n,m;
int ans;
int bar[maxn];
int Bar[maxn];
int Weight[maxn];
stack<int>s;
int read(){
	int s = 0,w = 1;
	char g = getchar();
	while(g < '0'||g > '9'){
		if(g == '-')
		w *= -1;
		g = getchar();
	}
	while(g >= '0'&&g <= '9'){
		s = s * 10 + g - '0';
		g = getchar();
	}
	return s * w;
}
void paint(int x){
	ins[x] = 0;
	colorname[x] = color;
	Weight[color] += weight[x];
	if(bar[x])
	Bar[color] = 1;
	s.pop();
}
void Add(int u,int v,int w){
	E[++tot].nxt = Head[u];
	E[tot].v = v;
	E[tot].w = w;
	Head[u] = tot;
}
void add(int u,int v){
	e[++tot].nxt = head[u];
	e[tot].v = v;
	head[u] = tot;
}
void tarjan(int x){
	dfn[x] = low[x] = ++cnt;
	used[x] = ins[x] = 1;
	s.push(x);
	for(int i = head[x];i;i = e[i].nxt){
		int y = e[i].v;
		if(!dfn[y]){
			tarjan(y);
			low[x] = min(low[x],low[y]);
		}
		else if(ins[y])
		low[x] = min(low[x],dfn[y]);
	}
	if(low[x] == dfn[x]){
		color++;
		while(s.top() != x){
			int t = s.top();
			paint(t);
		}
		paint(x);
	}
}
void spfa(int x){
	queue<int>q;
	q.push(x);
	dis[x] = 0;
	vis[x] = 1;
	while(!q.empty()){
		int u = q.front();
		q.pop();
		vis[u] = 0;
		for(int i = Head[u];i;i = E[i].nxt){
			int v = E[i].v;
			if(dis[v] < dis[u] + E[i].w){
				dis[v] = dis[u] + E[i].w;
				q.push(v);
				vis[v] = 1;
			}
		}
	}
}
int main(){
	n = read(),m = read();
	for(int i = 1;i <= m;i ++){
		int u = read(),v = read();
		add(u,v);
	}
	for(int i = 1;i <= n;i ++){
		weight[i] = read();
	}
	int s = read(),t = read();
	for(int i = 1;i <= t;i ++){
		int x = read();
		bar[x] = 1;
	}
	for(int i = 1;i <= n;i ++){
		if(!used[i])
		tarjan(i);
	}
	tot = 0;
	for(int i = 1;i <= n;i ++){
		for(int j = head[i];j;j = e[j].nxt){
			int k = e[j].v;
			if(colorname[i] != colorname[k]){
				Add(colorname[i],colorname[k],Weight[colorname[i]]);
			}
		}
	}
	Add(0,colorname[s],0);
	for(int i = 1;i <= color;i ++){
		if(Bar[i])
		Add(i,color + 1,Weight[i]);
	}
	memset(dis,0xff,sizeof(dis));
	spfa(0);
	printf("%d",dis[color + 1]);
	return 0;
}
```
求审核大大通过

---

## 作者：GKxx (赞：2)

我的做法可能有略微的区别 来发一篇题解

首先可以比较明显地看出，一个强联通分量中是可以随便走的，所以我们可以先用Tarjan算法求出所有强联通分量，然后缩点，每个强联通分量在新图中对应的点权就是所有属于这个强联通分量的点的点权之和

然后问题就变成了，给一个有向无环图和一个给定源点，求从这个源点出发到达某些点的路径的点权和的最大值。看起来这跟单源最长路问题很像，但是这里是点权和而不是边权和。如果我们能把点权转化为边权就好了。

点权化为边权的方法可以是把点权放到它的每条入边上，不过我的第一反应是拆点。我们可以把一个点$x$拆成两个点$x_0,x_1$，然后从$x_0$到$x_1$连一条边，边权就是原来$x$的点权。对于原图中的边$(x,y)$，连边$(x_1,y_0)$，边权为0，然后跑最长路即可。（当然也可以边权全部取相反数跑最短路）。

最后对每个酒吧统计答案即可。

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>

template <typename T> inline void read(T& t) {
    int f = 0, c = getchar(); t = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) t = t * 10 + c - 48, c = getchar();
    if (f) t = -t;
}
template <typename T> inline bool chkMin(T& x, const T& y) { return y < x ? (x = y, 1) : 0; }
template <typename T> inline bool chkMax(T& x, const T& y) { return x < y ? (x = y, 1) : 0; }
#ifdef WIN32
#define LLIO "%I64d"
#else
#define LLIO "%lld"
#endif
#define rep(i, a, b) for (int i = (a); i <= (b); ++i)
#define dwn(i, a, b) for (int i = (a); i >= (b); --i)
#define erp(i, x) for (int i = head[x]; i; i = next[i])

const int maxn = 1e6 + 7, inf = INT_MAX;
struct Graph {
    int v[maxn], w[maxn], head[maxn], next[maxn], value[maxn], tot;
    void ae(int x, int y, int z = 0) {
        v[++tot] = y; w[tot] = z; next[tot] = head[x]; head[x] = tot;
    }
};
Graph G, N;
int stk[maxn], tp;
int low[maxn], pre[maxn], belong[maxn], clck, cnt;
int bar[maxn], nv[maxn], dist[maxn], q[maxn << 2];
int n, m, s, p;
void dfs1(int x) {
    stk[++tp] = x; low[x] = pre[x] = ++clck;
    for (int i = G.head[x]; i; i = G.next[i]) {
        int v = G.v[i];
        if (!pre[v]) {
            dfs1(v);
            chkMin(low[x], low[v]);
        } else if (!belong[v])
            chkMin(low[x], pre[v]);
    }
    if (low[x] == pre[x]) {
        ++cnt;
        while (0207) {
            int t = stk[tp--];
            belong[t] = cnt;
            nv[cnt] += G.value[t];
            if (t == x) break;
        }
    }
}
inline void findscc() {
    rep(i, 1, n) if (!pre[i]) dfs1(i);
}
inline void rebuild() {
    rep(i, 1, (cnt << 1)) N.head[i] = 0;
    rep(x, 1, cnt) N.ae(x, x + cnt, -nv[x]);
    rep(x, 1, n) for (int i = G.head[x]; i; i = G.next[i])
        if (belong[x] ^ belong[G.v[i]])
            N.ae(belong[x] + cnt, belong[G.v[i]], 0);
}
void spfa() {
    int l = 0, r = 0;
    q[++r] = belong[s];
    rep(i, 1, (cnt << 1)) dist[i] = inf;
    dist[belong[s]] = 0;
    while (l < r) {
        int x = q[++l];
        for (int i = N.head[x]; i; i = N.next[i]) {
            int v = N.v[i], w = N.w[i];
            if (dist[v] > dist[x] + w)
                dist[q[++r] = v] = dist[x] + w;
        }
    }
}
int main() {
    read(n); read(m);
    G.tot = N.tot = 0;
    rep(i, 1, n) G.head[i] = 0;
    rep(i, 1, m) {
        int x, y;
        read(x); read(y);
        G.ae(x, y);
    }
    rep(i, 1, n) read(G.value[i]);
    read(s); read(p);
    rep(i, 1, p) read(bar[i]);
    findscc();
    rebuild();
    spfa();
    int ans = 0;
    rep(i, 1, p) chkMax(ans, -dist[belong[bar[i]] + cnt]);
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：niolle (赞：2)


第一道自己AC的APIO的难(~~shui~~)题

和浙江07年省选的[ZJOI2007]最大半连通子图很像

一道最短路的题

我用spfa处理

由于道路之间可能存在环

所以我们首先需要用到强连通分量(Tarjan)缩点

然后就会形成一个DAG

以钱做点权 

变成一个寻找从起点出发到权最大的有酒吧的点

用spfa弱弱的搞出来

详见代码

```.cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#define rep(i,a,b) for(long long i=a;i<=b;i++)
#define MAXN 500005
using namespace std;
typedef long long ll;
ll n,m,val[MAXN],to[MAXN],nxt[MAXN],fir[MAXN],s,maxx=0,tot,p,ans;
bool book[MAXN],bookk[MAXN],bookkk[MAXN];
ll dfn[MAXN],low[MAXN],sta[MAXN],top,num,col,co[MAXN],si[MAXN],cnt,dis[MAXN];
struct zlk{
	ll x,y;
}a[MAXN];
queue<ll> Q;
bool cmpp(zlk r,zlk t)
{
	if(r.x!=t.x) return r.x<t.x;
	else return r.y<=t.y;
}
void ade(ll u,ll v)
{
	to[++tot]=v;
	nxt[tot]=fir[u];
	fir[u]=tot;
}
void dfs(ll x)
{
	dfn[x]=low[x]=++num;
	sta[++top]=x;
	for(ll k=fir[x];k;k=nxt[k]){
		if(!dfn[to[k]]){
			dfs(to[k]);low[x]=min(low[x],low[to[k]]);
		}
		else if(!co[to[k]]) low[x]=min(low[x],dfn[to[k]]);
	}
	if(low[x]==dfn[x]){
		co[x]=++col;
		si[col]=val[x];//处理每个缩点的权 
		bookk[col]=book[x];//判断每个缩点是否有酒吧 
		while(sta[top]!=x){
			co[sta[top]]=col;
			if(!bookk[col]) bookk[col]=book[sta[top]];
			si[col]+=val[sta[top--]];
		}
		top--;
	}
}
void work()//重置边 
{
	rep(i,1,n){
		for(ll k=fir[i];k;k=nxt[k]){
			if(co[i]!=co[to[k]]){
				a[++cnt].x=co[i];
				a[cnt].y=co[to[k]];
			}
		}
	}
	sort(a+1,a+1+cnt,cmpp);
	memset(fir,0,sizeof(fir));
	tot=0;
	to[++tot]=a[1].y;
	nxt[tot]=fir[a[1].x];
	fir[a[1].x]=tot;
	de[a[1].y]++;
	rep(i,2,cnt){
		if(a[i].x!=a[i-1].x || a[i].y!=a[i-1].y){
			to[++tot]=a[i].y;
			nxt[tot]=fir[a[i].x];
			fir[a[i].x]=tot;
			de[a[i].y]++;
		}
	}
}
void spfa()//弱弱的spfa 
{
	Q.push(co[s]);
	if(bookk[co[s]]) ans=co[s];
	else ans=0;
	bookkk[co[s]]=1;
	dis[co[s]]=si[co[s]];
	while(!Q.empty()){
		ll x=Q.front();Q.pop();
		for(ll k=fir[x];k;k=nxt[k]){
			if(dis[to[k]]<dis[x]+si[to[k]]){
				dis[to[k]]=dis[x]+si[to[k]];
				if(dis[to[k]]>dis[ans] && bookk[to[k]]) ans=to[k];
				if(!bookkk[to[k]]) Q.push(to[k]),bookkk[to[k]]=1;
			}
		}
		bookkk[x]=0;
	}
}
int main()
{
	scanf("%lld%lld",&n,&m);
	rep(i,1,m){
		ll u,v;
		scanf("%lld%lld",&u,&v);
		ade(u,v);//连边 
	}
	rep(i,1,n) scanf("%lld",&val[i]);
	scanf("%lld%lld",&s,&p);
	rep(i,1,p){
		ll x;scanf("%lld",&x);
		book[x]=1;
	}
	rep(i,1,n) if(!dfn[i]) dfs(i);//缩点 
	work();
	spfa();
	printf("%lld",dis[ans]);//哈哈哈 
}
```

---

## 作者：本居小铃 (赞：2)

#### ~~为了庆祝这道题不再爆栈特来水一发题解~~
前面的大佬都是用的tarjan，于是来厚颜无耻的补一篇kosaraju  
个人认为比起tarjan来，kosaraju的代码更容易理解一些  
不过还是不推荐在做题的时候使用kosaraju  
一是需要再建一个反向图就很麻烦  
二是虽然时间复杂度一样但是跑起来也没有tarjan快  
之前这道题栈空间开小了，会RE三个点，比tarjan多一个，还是比较能说明问题  
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cstring>
#include<queue>
using namespace std;
int n,m,s,p,ans,val[500010]/*初始每个点的点权*/;
int cnt/*强联通分量个数*/,cmp[500010]/*每个点所属于的强联通分量的编号*/,scc[500010]/*表示缩点之后的点权*/,dis[500010];
vector<int> G[500010];//正向图
vector<int> rG[500010];//反向图
vector<int> sccG[500010];
vector<int> vs;
bool used[500010];
inline int read(){
    int x=0,k=1; char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')k=-1;c=getchar();}
    while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*k;
}
//加边，同时加上正向图和反向图的边
void add_edge(int from,int to){
	G[from].push_back(to);
	rG[to].push_back(from);
}
//第一遍dfs找出拓扑序
void dfs(int v){
	used[v]=true;
	for(int i=0;i<G[v].size();i++){
		if(!used[G[v][i]])dfs(G[v][i]);
	}
	vs.push_back(v);
}
//第二遍dfs找强联通分量
//当前节点和她在反向图中能访问的点都在同一个强联通分量中
void rdfs(int v){
	used[v]=true;
	cmp[v]=cnt;
	scc[cnt]+=val[v];//把当v的权值加到她属于的强联通分量的权值上
	for(int i=0;i<rG[v].size();i++){
		if(!used[rG[v][i]]){
			rdfs(rG[v][i]);
		}
	}
}
void sscc(){
	memset(used,0,sizeof(used));
	vs.clear();
	for(int i=1;i<=n;i++){
		if(!used[i]) dfs(i);
	}
	memset(used,0,sizeof(used));
	for(int i=vs.size()-1;i>=0;i--){
		if(!used[vs[i]]){
			cnt++;
			rdfs(vs[i]);
		}
	}
    //缩点
	for(int i=1;i<=n;i++){
		for(int j=0;j<G[i].size();j++){
			if(cmp[G[i][j]]!=cmp[i]){
            //如果i和G[i][j]不再一个强联通分量中，将她们所属的强联通分量连边
				sccG[cmp[i]].push_back(cmp[G[i][j]]);
			}
		}
	}
}
queue<int> q;
//以下就是求最短（cháng）路
void spfa(){
    int u,v;
    q.push(cmp[s]);
    dis[cmp[s]]=scc[cmp[s]];
    while(!q.empty()){
        u=q.front(),v;
        q.pop();
        used[u]=false;
        for(int i=0;i<sccG[u].size();i++){
            v=sccG[u][i];
            if(dis[v]<dis[u]+scc[v]){
                dis[v]=dis[u]+scc[v];
                if(!used[v]){
                      used[v]=true;
                      q.push(v);
                }
            }
        }
    }
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int a,b;
		a=read();b=read();
		add_edge(a,b);
	}
	for(int i=1;i<=n;i++){
		val[i]=read();
	}
	s=read();p=read();
	sscc();
	memset(used,0,sizeof(used));
	spfa();
	for(int i=1;i<=p;i++){
		int a;
		a=read();
        //从有酒馆的强联通分量中找一个能最后能抢最多的
		ans=max(ans,dis[cmp[a]]);
	}
	cout<<ans<<endl;
	return 0;
}
```
[![iCKhE4.md.jpg](https://s1.ax1x.com/2018/09/06/iCKhE4.md.jpg)](https://imgchr.com/i/iCKhE4)  
这是评测结果  
加了读入优化还是跑得巨慢  
~~但我还是蛮喜欢写写kosaraju玩玩的~~

---

## 作者：Gypsophila (赞：2)

这个题显然是求单源最长路。

要跑最长路必须把原图变为DAG，所以用tarjan缩点

把每一个强连通分量缩成一个点，统计一下强连通分量里的点权和，然后跑spfa就行了。

有一个小技巧就是若有一条边$(u,v)$，则把该边的权值设为$v$的点权，然后从$0$点往起点连一条权值为起点的点权的边，然后就直接把$0$当为源点跑spfa就可以了。

顺便提一句，题里的图$1$号点是有一条入边的，就是$0$向他连的那条。

~~自认为比题解区代码好看的~~代码：

```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <algorithm>
#include <cstring>

using namespace std;

const int MAXN = 5005000;
int n, m, cnt, a[MAXN], s, p, U[MAXN], V[MAXN], dis[MAXN], vis[MAXN], Q[MAXN], h, t;
int scc, tot, top, sta[MAXN], ins[MAXN], dfn[MAXN], low[MAXN], bel[MAXN], val[MAXN];
int ans;
struct edge {
	int v, w;
	edge *next;
}pool1[MAXN], *head1[MAXN], pool2[MAXN], *head2[MAXN];
inline void addedge1(int u, int v) {
	edge *p = &pool1[++cnt];
	p->v = v, p->next = head1[u], head1[u] = p;
}
inline void addedge2(int u, int v, int w) {
	edge *p = &pool2[++cnt];
	p->v = v, p->w = w, p->next = head2[u], head2[u] = p;
}
inline void tarjan(int u) {
	dfn[u] = low[u] = ++tot; ins[u] = 1, sta[++top] = u;
	for(edge *p = head1[u]; p; p = p->next) {
		int v = p->v;
		if(!dfn[v]) {
			tarjan(v);
			low[u] = min(low[u], low[v]); 
		} 
		else if(ins[v]) low[u] = min(low[u], dfn[v]);
	}
	if(dfn[u] == low[u]) {
		++scc;
		while(sta[top + 1] != u) {
			bel[sta[top]] = scc;
			ins[sta[top]] = 0;
			val[scc] += a[sta[top]]; --top;
		} 
	}
}
inline void spfa() {
	dis[0] = 0, Q[++t] = 0, vis[0] = 1;
	while(h <= t) {
		int u = Q[h++]; vis[u] = 0;
		for(edge *p = head2[u]; p; p = p->next) {
			int v = p->v;
			if(dis[v] < dis[u] + p->w) {
				dis[v] = dis[u] + p->w;
				if(!vis[v]) Q[++t] = v, vis[v] = 1;
			} 
		}
	}
}
int main()
{
    scanf("%d%d", &n, &m)；
    for(int i = 1; i <= m; i++) {
    	scanf("%d%d", &U[i], &V[i])；
    	addedge1(U[i], V[i])；
	}
	for(int i = 1; i <= n; i++) scanf("%d", &a[i])；
	scanf("%d%d", &s, &p)；
	for(int i = 1; i <= n; i++) {
		if(!dfn[i]) tarjan(i)；
	} 
	addedge2(0, bel[s], val[bel[s]]);
	for(int i = 1; i <= m; i++) {
		if(bel[U[i]] != bel[V[i]]) 
		    addedge2(bel[U[i]], bel[V[i]], val[bel[V[i]]])；
	}
	spfa();
	for(int i = 1; i <= p; i++) {
		int x; scanf("%d", &x)；
		ans = max(ans, dis[bel[x]])；
	}
	printf("%d\n", ans)；
 	return 0；
}
```

---

## 作者：John_Fu (赞：2)

先跑tarjan，把每个点染色，一样颜色的点（即在一个联通分量里）合并成一个大点（我注释里的“联通块”）；

求出每个联通块能抢到的钱（等于它里面每个点能抢到钱的总和）；

然后跑SPFA，找最长路径，不过这里是点权不是边权；

代码里有注释；


```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<iostream>
#include<vector>
#include<set>
#include<cstdlib>
#include<queue>
using namespace std; 
int n,m;//n,m<=50W(我们学校内网数据好像只有3000,所以我就不写读入优化了吧 )
int cl=0;//颜色总数 
struct E{
    int v,next;
};
E edge[500001];//点之间边 
E Edge[500001];//联通块之间的边 
int cash[500001];//每个点能抢到的钱 
int bar[500001];//酒吧所在的位置 
int color[500001];//color[i]表示点i的颜色 
int tarcash[500001];//每个联通块能抢的钱 
vector<int> ccom[500001]; //ccom[i]表示颜色为i的点有哪些 
int dfn[500001];
int dfnn;//标记dfn的 
int low[500001],stack[600001];
int head=0;//stack栈顶 
int dis[500001];//SPFA中的dis 
bool vis[500001];//SPFA中的vis
//（我这道题存边方法麻烦了，他们好像用vector存，能稍微少写几行，也能省一点点内存） 
int sum=0;
int fir[500001];//一般大佬把这个数组叫做head，存边的那个
void add(int u,int v){//增加点之间的边
    edge[++sum].next=fir[u];
    fir[u]=sum;
    edge[sum].v=v;
}
int Fir[500001],Sum=0;
void Add(int u,int v){//增加联通块之间的边
    Edge[++Sum].next=Fir[u];
    Fir[u]=Sum;
    Edge[Sum].v=v;
}
int s;
int p;
void tarjan(int x){
    //tarjan，模板不解释 
    stack[++head]=x;
    vis[x]=1;
    dfn[x]=++dfnn;
    low[x]=dfnn;
    for(int i=fir[x];i;i=edge[i].next)
    {
        int t=edge[i].v;
        if(!dfn[t])
        {
            tarjan(t);
            low[x]=min(low[x],low[t]);
        }
        else if(vis[t])low[x]=min(low[x],dfn[t]);
    }
    if(dfn[x]==low[x])
    {
        color[x]=++cl;//染色 
        vis[x]=0;
        ccom[cl].push_back(x);
        while(stack[head]!=x)
        {
            color[stack[head]]=cl;//染色 
            vis[stack[head]]=0;
            ccom[cl].push_back(stack[head]);//颜色为cl的点又增加一个 
            head--;
        }
        head--;
    }
}
int main(){
    //开始读入 
    cin>>n>>m;
    int x,y;
    memset(dfn,0,sizeof(dfn));
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&x,&y);
        add(x,y);
    }
    for(int i=1;i<=n;i++)
        scanf("%d",&cash[i]);
    cin>>s>>p;
    for(int i=1;i<=p;i++)
        scanf("%d",&bar[i]);
    //读入结束 
    for(int i=1;i<=n;i++)
    {
        if(dfn[i]==0)tarjan(i);//如果i还没有搜到，则对i进行tarjan 
    } 
    for(int i=1;i<=cl;i++)
        for(int j=0;j<ccom[i].size();j++)
        {
            tarcash[i]+=cash[ccom[i][j]];//每个联通块能抢到的钱等于它里面每个点的cash[]之和 
        }
    for(int i=1;i<=n;i++)
    {
        for(int j=fir[i];j;j=edge[j].next)//枚举每一条边 
        {
            if(color[i]!=color[edge[j].v])//如果这条边的两个端点不在一个联通块里 
                Add(color[i],color[edge[j].v]); //则这条边就是一个联通块指向另一个联通块的边 
        }
    }
    //SPFA开始 
    memset(vis,0,sizeof(vis));
    dis[color[s]]=tarcash[color[s]];
    queue<int> q;
    q.push(color[s]);//将起点s所在的联通块加入SPFA的队列 
    vis[color[s]]=1;
    while(!q.empty()){
        int u=q.front();
        q.pop();
        vis[u]=0;
        for(int i=Fir[u];i;i=Edge[i].next)
        {
            int v=Edge[i].v;
            if(dis[v]<dis[u]+tarcash[v])//如果走到联通块u能抢到的钱加上v能抢的钱大于原先走到v能抢的钱 
            {
                dis[v]=dis[u]+tarcash[v];
                if(vis[v]==0)
                    q.push(v);
            }
        }
    }
    //SPFA结束 
    int ans=0;
    for(int i=1;i<=p;i++)
    {
        ans=max(ans,dis[color[bar[i]]]);//枚举走到每个酒吧能获得的钱，找最大值 
    }
    cout<<ans;
    return 0;
}

```

---

## 作者：yybyyb (赞：2)

Tarjan缩点之后

计算环的长度

再求最长路径即可

```cpp
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<vector> 
#include<algorithm>
using namespace std;
const int MAX=500001;
int Dfn[MAX],Low[MAX],S[MAX],Time=0,Top=0;
bool vis[MAX];
vector<int> e[MAX];
int G[MAX];
long long GN[MAX];
int Group=0;
int Money[MAX];
int s,p;
vector<int> To[MAX];
vector<int> W;
int n,m;
long long Dis[MAX];
bool change[MAX];
void Tarjan(int u)//Tarjan缩点 
{
    Time++;
    Top++;
    Dfn[u]=Time;
    Low[u]=Time;
    vis[u]=true;
    S[Top]=u;
    int v;
    for(int i=0;i<e[u].size();++i)
    {
        v=e[u][i];
        if(!Dfn[v])
         {
             Tarjan(v);
             Low[u]=min(Low[u],Low[v]);
         }
        else
         if(vis[v])
            Low[u]=min(Low[u],Dfn[v]);
    }
    if(Dfn[u]==Low[u])
    {
        v=-1;
        ++Group;
        //cout<<"Group:"<<Group<<":";
        while(v!=u)
        {
            v=S[Top--];
            vis[v]=false;
            G[v]=Group;
            //cout<<v<<' ';
            GN[Group]+=Money[v];
        }
        //cout<<endl;
    }
}
void Line()//把超级点连接起来 
{
    for(int i=1;i<=n;++i)
     for(int j=0;j<e[i].size();++j)
     {
         if(G[i]!=G[e[i][j]])
          To[G[i]].push_back(G[e[i][j]]);
     }
}
void Count()
{
    //memset(vis,0,sizeof(vis));
    memset(S,0,sizeof(S));
    int h=0,t=1;
    memset(Dis,0,sizeof(Dis));
    vis[G[s]]=true;
    int u,v,max1;
    u=G[s];
    Dis[u]=GN[u];
    S[1]=u;
    while(h<t)//这里不能用迪杰斯特拉，因为它无法解决最大路（可以看为负权值） 
    {
        ++h;
        u=S[h];
        for(int i=0;i<To[S[h]].size();++i)
        {
            if(Dis[To[u][i]]<Dis[u]+GN[To[u][i]])
            {
                Dis[To[u][i]]=Dis[u]+GN[To[u][i]];
                t++;
                S[t]=To[u][i]; 
            }
        }
    }
    /*for(int i=1;i<=Group;++i)
    {
        max1=0;
        if(i!=1)
        for(int j=1;j<=Group;++j)
        {
            if(!vis[j]&&Dis[j]>max1)
             u=j,max1=Dis[j];
        }
        vis[u]=true;
        memset(change,0,sizeof(change)); 
        for(int j=0;j<To[u].size();++j)
        {
            if(!change[To[u][j]])
            {
                change[To[u][j]]=true;
                Dis[To[u][j]]=max(Dis[To[u][j]],Dis[u]+GN[To[u][j]]);
            }
        }
    }*/
    
    //for(int i=1;i<=Group;++i)
    // cout<<Dis[i]<<' ';
    // cout<<endl;
    long long max0=0;
    for(int i=0;i<W.size();++i)
    {
        max0=max(max0,Dis[G[W[i]]]);
    }
    cout<<max0<<endl;
}
 
int main()
{
    int a,b;
    cin>>n>>m;
    for(int i=1;i<=m;++i)
    {
        cin>>a>>b;
        e[a].push_back(b);
    }
    for(int i=1;i<=n;++i)
     cin>>Money[i];
    cin>>s>>p;
    for(int i=1;i<=p;++i)
    {
        cin>>a;
        W.push_back(a);
    }
    for(int i=1;i<=n;++i)
     if(!Dfn[i])
      Tarjan(i);
    Line();
    Count();
    return 0;
}
```

---

## 作者：ivyjiao (赞：1)

算法：Kosaraju+DP。

本题是 [P2272 [ZJOI2007] 最大半连通子图](https://www.luogu.com.cn/problem/P2272) 的加强版，而那题不用 SPFA or Dijkstra or 拓扑排序，所以思考能否把本题的 SPFA or Dijkstra or 拓扑排序全都优化掉，答案是能的。

本文假设你会缩点。

先大力缩点，然后预处理出每个强连通分量能抢到多少钱，最后大力 DP。

众所周知，Tarjan 求出的强连通分量顺序是逆拓扑序，而 Kosaraju 求出的强连通分量顺序是正拓扑序，所以根本无需再跑一次拓扑排序。

由于此时图已经是个 DAG 了，所以我们直接大力 DP，注意由于本题起点固定，所以我们要建一个判断是否从起点可达当前点的数组（具体细节见代码），如果当前节点从起点可达，就对其进行 DP 转移，否则不转移，防止无关答案干扰正确答案。

判断完成之后的 DP 转移式如下（一个经典的 trick）：

$$
dp_v=
\left\{\begin{matrix}
dp_u+sum_v & dp_v<dp_u+sum_v\\ 
dp_v & dp_v\geq dp_u+sum_v\\
\end{matrix}\right.
$$

最后就是简单的统计答案环节了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[500001],u,v,col[500001],cnt,sum[500001],dp[500001],s,t,p,b,ans;
vector<int>G[500001],H[500001],I[500001],st;
bool vis[500001],kd[500001];
void dfs1(int u){
    vis[u]=1;
    for(int i=0;i<G[u].size();i++) if(!vis[G[u][i]]) dfs1(G[u][i]);
    st.push_back(u);
}
void dfs2(int u){
    col[u]=cnt;
    sum[cnt]+=a[u];
    for(int i=0;i<H[u].size();i++) if(!col[H[u][i]]) dfs2(H[u][i]);
}
void kosaraju(){
    for(int i=1;i<=n;i++) if(!vis[i]) dfs1(i);
    for(int i=st.size()-1;i>=0;i--){
        if(!col[st[i]]){
            cnt++;
            dfs2(st[i]);
        }
    }
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>u>>v;
        G[u].push_back(v);
        H[v].push_back(u);
    }
    for(int i=1;i<=n;i++) cin>>a[i];
    cin>>s>>p;
    kosaraju();
	for(int i=1;i<=n;i++){
		for(int j=0;j<G[i].size();j++){
			if(col[i]!=col[G[i][j]]) I[col[i]].push_back(col[G[i][j]]);
        }
    }
    dp[col[s]]=sum[col[s]];
    kd[col[s]]=1;
    for(int i=1;i<=cnt;i++){
        for(int j=0;j<I[i].size();j++){
            if(kd[i]) kd[I[i][j]]=1;
            if(!kd[I[i][j]]) continue; 
			if(dp[I[i][j]]<dp[i]+sum[I[i][j]]) dp[I[i][j]]=dp[i]+sum[I[i][j]];
        }
    }
    for(int i=1;i<=p;i++){
        cin>>b;
        ans=max(ans,dp[col[b]]);
    }
    cout<<ans;
}
```

---

## 作者：Priori_Incantatem (赞：1)

一道很模板的题，只是在缩点的基础上多了一个最短路，并且给定了终点的范围（必须是酒吧）

对于每个强连通分量，处理处内部所有节点点权（银行里的钱）之和，从给定的起点开始跑一边最短路。最后统计所有含有酒吧的强连通分量的距离最大值

PS：dijkstra会爆，得用SPFA  
~~今天两次DAG上最短路dij都挂了QwQ~~
```cpp
#include<cstdio>
#include<iostream>
#include<stack>
#include<queue>
#include<vector>
#include<algorithm>
using namespace std;
const int Maxn=500010,inf=0x3f3f3f3f;
vector <int> e[Maxn],g[Maxn];
int dfn[Maxn],low[Maxn],f[Maxn];
int c[Maxn],dis[Maxn],a[Maxn];
stack <int> s;
bool vis[Maxn];
int n,m,k;
int timecnt,st,ans;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
void tarjan(int x)
{
	dfn[x]=low[x]=++timecnt;
	vis[x]=1,s.push(x);
	for(int i=0;i<e[x].size();++i)
	{
		int y=e[x][i];
		if(!dfn[y])
		{
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else if(vis[y])low[x]=min(low[x],dfn[y]);
	}
	if(dfn[x]==low[x])
	{
		while(s.size())
		{
			int y=s.top();
			s.pop();
			f[y]=x,vis[y]=0;
			if(x==y)break;
			c[x]+=c[y];
		}
	}
}
void spfa()
{
	queue <int> q;
	fill(dis+1,dis+1+n,-inf);
	st=f[st];
	dis[st]=c[st],vis[st]=1;
	q.push(st);
	while(q.size())
	{
		int x=q.front();
		q.pop();
		vis[x]=0;
		for(int i=0;i<g[x].size();++i)
		{
			int y=g[x][i];
			if(dis[y]<dis[x]+c[y])
			{
				dis[y]=dis[x]+c[y];
				if(!vis[y])vis[y]=1,q.push(y);
			}
		}
	}
}
int main()
{
//	freopen("in.txt","r",stdin);
	n=read(),m=read();
	for(int i=1;i<=m;++i)
	{
		int x=read(),y=read();
		e[x].push_back(y);
	}
	for(int i=1;i<=n;++i)
	c[i]=read();
	
	for(int i=1;i<=n;++i)
	if(!dfn[i])tarjan(i);
	
	st=read(),k=read();
	st=f[st];
	for(int i=1;i<=k;++i)
	a[i]=read(),a[i]=f[a[i]];
	
	for(int i=1;i<=n;++i)
	{
		for(int j=0;j<e[i].size();++j)
		{
			int x=i,y=e[i][j];
			if(f[x]==f[y])continue;
			g[f[x]].push_back(f[y]);
		}
	}
	spfa();
	
	for(int i=1;i<=k;++i)
	ans=max(ans,dis[a[i]]);
	printf("%d\n",ans);
	
	return 0;
}
```

---

## 作者：寒鸽儿 (赞：1)

在有向图中,边又没啥限制,因而考虑缩点。缩点的同时记录该点内部有无酒吧以及该点的总钱数。    
缩完点之后,很自然地得到一个DAG。只要抢,就连同该DAG中的点一起包圆。  
然后我们可以在DAG上跑DP,根据tarjan的性质,缩点的编号是逆拓扑序的,因此只要按从起点所在点出发结点序递减的顺序递推即可,每次推到有酒吧的点更新答案。  
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 567890;

int head[N<<1], ver[N<<1], nex[N<<1], my[N<<1], tot, n;
inline void addedge(int u, int v) {
	ver[tot] = v; nex[tot] = head[u]; my[tot] = u; head[u] = tot++;
}

int a[N], isba[N], s;

int dfn[N], low[N], co[N], bar[N], mon[N], sta[N], dfs_clock = 1, col = 1, top;
void tarjan(int cur) {
	dfn[cur] = low[cur] = dfs_clock++;
	sta[top++] = cur;
	for(int i = head[cur]; ~i; i = nex[i])
		if(!dfn[ver[i]]) {
			tarjan(ver[i]);
			low[cur] = min(low[cur], low[ver[i]]);
		} else if(!co[ver[i]]) {
			low[cur] = min(low[cur], dfn[ver[i]]);
		}
	if(dfn[cur] == low[cur]) {
		--top;
		while(sta[top] != cur) {
			if(isba[sta[top]]) bar[col] = 1;
			mon[col] += a[sta[top]];
			co[sta[top--]] = col;
		}
		co[cur] = col;
		mon[col] += a[cur];
		if(isba[cur]) bar[col] = 1;
		++col;
	}
}

int f[N], ans;

int main() {
	memset(head, -1, sizeof(head));
	int m, u, v, p;
	scanf("%d %d", &n, &m);
	for(int i = 1; i <= m; ++i) {
		scanf("%d %d", &u, &v);
		addedge(u, v);
	}
	for(int i = 1; i <= n; ++i) scanf("%d", a + i);
	scanf("%d %d", &s, &p);
	while(p--) scanf("%d", &u), isba[u] = 1;
	for(int i = 1; i <= n; ++i) if(!dfn[i]) tarjan(i);
	--col;
	for(int i = 0, end = tot; i < end; ++i) 
		if(co[my[i]] != co[ver[i]])
			addedge(co[my[i]] + n, co[ver[i]]);
	for(int i = co[s]; i; --i) {
		f[i] += mon[i];
		if(bar[i]) ans = max(ans, f[i]);
		for(int j = head[i+n]; ~j; j = nex[j])
			f[ver[j]] = max(f[ver[j]], f[i]);
	}
	printf("%d\n", ans);
	return 0;
}

```

---

## 作者：kevin006 (赞：1)

先吐槽下：本蒟蒻这道题做了好久。。

这道题的题解我基本上都看了一遍，大部分都用的是Tarjan缩点，Tarjan的原理我就不说了，其他的题解里已经讲解的很详细了，这里主要是总结一下跑最长路的几种方法。
## Dijkstra
这是我用的第一种方法，WA了两个点。

百思不得其解，找了各种稀奇古怪的地方仍然WA，直到看到了[这个](https://www.luogu.org/discuss/show/118707)

emmm（请原谅本蒟蒻的无知）

所以，做个总结：
### Dijkstra不能跑最长路！！
## 拓扑排序+DP
这种方法我只得了55分，后来~~查看讨论后~~发现，起点并不一定入度为0，需要一个特别麻烦的特判。

不过题解中有位大佬利用只对起点进行Tarjan避免了这一点(雾

其实到底能不能完全避免我也不清楚（其实就是懒得打了），所以欢迎神犇来hack。
## SPFA
这是题解中用的最多的一种方法了，确实是正确的，无论是负权跑最短路，还是只改变松弛时判断的符号，都能胜任，据说在稀疏图上跑得还更快？！

那好了，以后跑最长路的最佳算法就是
# SPFA
最后附上SPFA代码吧
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxN = 1000010;
const int maxE = 1000010;
int N,M;
int head[maxN],cnt;
struct qxx
{
    int next,to,cost;
}edge[maxE];
int a[maxN];//dian quan
int b[maxN];
bool bar[maxN];
void add(int u,int v)
{
    cnt++;
    edge[cnt].next=head[u];
    edge[cnt].to=v;
    head[u]=cnt;
}
int mystack[maxN],top;
bool instack[maxN];
int dfn[maxN],db[maxN],timeclock;
int belong[maxN],tot;
bool bar2[maxN];
void Tarjan(int u)
{
    mystack[++top]=u;
    instack[u]=1;
    db[u]=dfn[u]=++timeclock;
    for(int i=head[u];i;i=edge[i].next)
    {
        int v=edge[i].to;
        if(!dfn[v])
        {
            Tarjan(v);
            db[u]=min(db[u],db[v]);
        }
        else if(instack[v])
        {
            db[u]=min(db[u],db[v]);
        }
    }
    if(dfn[u]==db[u])
    {
        tot++;
        while(mystack[top]!=u)
        {
            int x=mystack[top--];
            instack[x]=0;
            belong[x]=tot;
            b[tot]+=a[x];
            if(bar[x])bar2[tot]=1;
        }
        instack[u]=0;
        belong[u]=tot;
        b[tot]+=a[u];
        top--;
        if(bar[u])bar2[tot]=1;
    }
}
int head2[maxN],cnt2;
qxx edge2[maxE];
void add2(int u,int v,int w)
{
    cnt2++;
    edge2[cnt2].next=head2[u];
    edge2[cnt2].to=v;
    edge2[cnt2].cost=w;
    head2[u]=cnt2;
}
int dist[maxN];
bool vis[maxN];
void SPFA(int s)
{
    queue <int> q;
    vis[s]=1;
    dist[s]=0;
    q.push(s);
    while(!q.empty())
    {
        int temp=q.front();
        q.pop();
        vis[temp]=0;
        for(int i=head2[temp];i;i=edge2[i].next)
        {
            int v=edge2[i].to;
            int c=edge2[i].cost;
            if(dist[v]<dist[temp]+c)
            {
                dist[v]=dist[temp]+c;
                if(!vis[v])
                {
                    q.push(v);
                    vis[v]=1;
                }
            }
        }
    }
}
int main()
{
    cin>>N>>M;
    for(int i=1;i<=M;i++)
    {
        int u,v;
        cin>>u>>v;
        add(u,v);
    }
    for(int i=1;i<=N;i++)
        cin>>a[i];
    int s,P;
    cin>>s>>P;
    for(int i=1;i<=P;i++)
    {
        int x;cin>>x;
        bar[x]=1;
    }
    for(int i=1;i<=N;i++)
        if(!dfn[i])Tarjan(i);
    for(int i=1;i<=N;i++)
    {
        for(int j=head[i];j;j=edge[j].next)
        {
            int v=edge[j].to;
            if(belong[i]!=belong[v])
                add2(belong[i],belong[v],b[belong[v]]);
        }
    }
    add2(0,belong[s],b[belong[s]]);
    SPFA(0);
    int ans=0;
    for(int i=1;i<=tot;i++)
        if(bar2[i])ans=max(ans,dist[i]);
    cout<<ans<<endl;
}

```
原谅这奇怪的马蜂

---

## 作者：404_notfound (赞：1)

咕了四个小时整整一晚上

特此来发题解

[P3627 [APIO2009]抢掠计划](https://www.luogu.org/problemnew/show/P3627)



------------
### 不难看出答案即为该有向图的最长链长度（允许重复

### 我会dp！

### 但是图中可能有环，不满足dp的无后效性假设

### 我会tarjan！

~~（您太强了）~~

在同一个强连通分量里的点一定可以互相到达，tarjan缩点之后，将每一个强联通分量看作一个点，价值就是其中所有银行的价值总和

缩点完成之后我们重新构造一个新的图，原来连接两个点的边改成连向两个点所在的强连通分量（如果在同一个强连通分量里？这就是环了不用管）

接着本来想写bfs求最长路……写着写着感觉就变成spfa了（笑哭）

最后我们算出起点到每一个强连通分量的最长路，枚举每一个点，判断有酒吧就更新答案

```cpp
#include<bits/stdc++.h>
#define ll long long
#define inf 0x7fffffff
using namespace std;
int n,m; 
#define maxn 500009
vector<int> son[maxn];
int c[maxn];
bool bar[maxn];
void add(int x,int y)
{
    son[x].push_back(y);
}
int s,p;
int dfsn[maxn],lowlink[maxn];
int sta[maxn];
int top=0;
int dfs_clock=0; 
int scc_cnt=0;//有多少个强连通分量 
int scc[maxn];//每个点在那个强连通分量里 
int val[maxn];//每个点所在的强连通分量的价值总和 
int q[maxn];
int vy[maxn];//每个强连通分量的价值总和 
void dfs_scc(int x)//tarjan!!!
{
    dfsn[x]=lowlink[x]=++dfs_clock;
    sta[++top]=x;
    for(int i=0;i<son[x].size();i++)
    {
        int now=son[x][i];
        if(!dfsn[now])
        {
            dfs_scc(now);
            lowlink[x]=min(lowlink[x],lowlink[now]);
        }else if(!scc[now])
        {
            lowlink[x]=min(lowlink[x],dfsn[now]);
        }
    }
    if(lowlink[x]==dfsn[x])
    {
        scc_cnt++;
        int ans=0;
        int p=0;
        while(sta[top]!=x)
        {
            q[++p]=sta[top];//挖坑提示：q是一个用来记录的数组，把强连通分量中的点记录下来，这个q一定要开全局变量，不用memset
            //如果每次在递归中定义一个q，一轮就会爆栈！！！！本地出现蜜汁错误，洛谷ide却没问题！！
            ans+=c[sta[top]];
            scc[sta[top--]]=scc_cnt;
        }
        top--;
        scc[x]=scc_cnt;
        q[++p]=x;
        ans+=c[x];
        vy[scc_cnt]=ans;
        for(int i=1;i<=p;i++)
        {
            val[q[i]]=ans;
        }
    }
}
struct node{
    int x,y;
}e[maxn];;
vector<int> newmap[maxn];
int in[maxn],d[maxn];
struct point{
    int x,step;
};
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        add(x,y);
        e[i].x=x,e[i].y=y;
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&c[i]);
    }
    scanf("%d%d",&s,&p);
    memset(bar,0,sizeof(bar));
    for(int i=1;i<=p;i++)
    {
        int x;
        scanf("%d",&x);
        bar[x]=1;
    }
    for(int i=1;i<=n;i++)
    {
        if(!dfsn[i])dfs_scc(i);
    }
    for(int i=1;i<=m;i++)//一条边的两个端点必须不在同一个强连通分量里 
    {
        if(scc[e[i].x]!=scc[e[i].y])
        {
            newmap[scc[e[i].x]].push_back(scc[e[i].y]);
        }
    }
     
    queue<int> q;
    q.push(scc[s]);
    d[scc[s]]=val[s];
    while(!q.empty())//广搜，不，事实上这是一个spfa 
    {
        int xx=q.front();
        int x=xx;
        q.pop();
        for(int i=0;i<newmap[x].size();i++)
        {
            int to=newmap[x][i];
            if(d[to]>=d[x]+vy[to])continue; //类似于松弛的操作…… 
            d[to]=max(d[to],d[x]+vy[to]);
			q.push(to);
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        if(bar[i])//如果这个点有酒吧，那么我们就统计一下它所在的强连通分量的答案 
        {
            ans=max(ans,d[scc[i]]);
        }
    }
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：Wall_breaker (赞：1)

### ~~大家好！这里蒟蒻一枚~~
# 我们来解读一下这道有趣（po gai）的题目
### 1.缩点
首先，我们读一下题。我们可以发现，**题中“单向边”“可以经过道路或路口任意多次”**，这些信息都提醒我们很多环，并且每个环中的ATM都可以掠夺光。此外，只要一个环有一个酒吧，最终就能停留在这个环上。于是，可以**缩点**。于是乎，我们就tarjan一下。
```c++
inline void tarjan(int p) {
	dfn[p] = low[p] = ++ tot;
	vis[p] = true;
	sta[++ cnt] = p;
	for (int e = head[p]; e; e = l[e].nex) {
		int u = l[e].to;
		if (!dfn[u]) {
			tarjan(u);
			low[p] = min(low[p], low[u]);
		}
		else if (vis[u]) low[p] = min(low[p], dfn[u]);
	}
	if (dfn[p] == low[p]) {
		int fr = 0; len ++;
		while(fr != p) {
			fr = sta[cnt --];
			vis[fr] = false;
			bel[fr] = len;
			sum[len] += mon[fr];（掠夺钱数累加）
			if (lub[fr]) bar[len] = true; （有酒吧就能停）
		}
	}
}
```
然后别忘了去重建边
```c++
(set <pair <int, int> > s) //ps：s是集合，能去重；pair是对变量，记一对数
for (int i = 1; i <= n; i ++) {
	for (int j = head[i]; j; j = l[j].nex) {
		int u = l[j].to;
		if (bel[u] != bel[i]) s.insert(make_pair(bel[i], bel[u]));
	}
}
set<pair <int, int> > :: iterator  it;
int ii = 0;
for (it = s.begin(); it != s.end(); it ++) {
	g[++ ii] = (info) {it->first, tail[it->second]};
	tail[it->second] = ii;
	r[it->first] ++;
}
```
### 2.动规
很多人缩点后跑最长/最短路，然而我想创新~~实际是我不想拍冗长代码~~

**动规大法好！**

定义val[]为该点提供最大价值，sum即为[]上述代码中的每个点的权值

我们来分析一下：缩点后，这是一个有向无环图，因此，对于一个点的最大val，必然为**该点权值sum+子节点中最大val**

**即val[a] = max(val[a], val[b] + sum[a]);(b为a子节点**

有了这样的动规方程，我们还需要次序。再来想，**出度**为0的点价值必然就是自己的权值（它没儿子）。于是乎，我们就回忆起一个熟悉的普及组算法。
### 3.拓扑
topo（）+动规，大家都很熟悉，但在这里我们发现，
## **出度**不是拓扑能解决的，**入度**才是。

于是乎，我们对它改造一下。
具体来讲，就是将原图中的边所指方向翻转，这样出度变入度，起点变终点，这样拓扑序+动规就能轻松AC本题了。
### 4.代码（~~码风之气天上来，AC之力不复回~~）
```c++
#include<bits/stdc++.h>
using namespace std;
template <typename T> inline void read(T &x) {
	x = 0;
	T f = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
	for (; isdigit(c); c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);
	x *= f;
}
inline void d_read(double &x) {
	x = 0.0;
	int f = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
	for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
	if (c == '.'){
		double num = 1.0;
		c = getchar();
		for (; isdigit(c); c = getchar()) x = x + (num /= 10) * (c ^ 48);
	}
	x *= f;
}

template <typename T> inline void w(T x) {
	if (x > 9) w(x / 10);
	putchar(x % 10 + 48);
}
template <typename T> inline void write(T x, char c) {
	if (x < 0){
		putchar('-');
		x = -x;
	}
	w(x);
	putchar(c);
}
const int M = 5e5 + 5;
struct info{
	int to, nex;
}l[M], g[M];
int ans, cnt, tot, len, val[M], r[M], tail[M], dfn[M], low[M], sum[M], sta[M], bel[M], mon[M], head[M];
bool lub[M], vis[M], bar[M], flg[M];
set<pair <int, int> >s;
queue <int> q;
inline void tarjan(int p) {
	dfn[p] = low[p] = ++ tot;
	vis[p] = true;
	sta[++ cnt] = p;
	for (int e = head[p]; e; e = l[e].nex) {
		int u = l[e].to;
		if (!dfn[u]) {
			tarjan(u);
			low[p] = min(low[p], low[u]);
		}
		else if (vis[u]) low[p] = min(low[p], dfn[u]);
	}
	if (dfn[p] == low[p]) {
		int fr = 0; len ++;
		while(fr != p) {
			fr = sta[cnt --];
			vis[fr] = false;
			bel[fr] = len;
			sum[len] += mon[fr];
			if (lub[fr]) bar[len] = true; 
		}
	}
}
inline void dfs(int p, int num) {
	if (bar[p]) ans = max(ans, num); 
	for (int e = tail[p]; e; e = g[e].nex) {
		int u = g[e].to;
		dfs(u, num + sum[u]);
	}
}
int main(void) {
	int n, m, id;
	read(n); read(m);
	for (int i = 1; i <= m; i ++) {
		read(id); read(l[i].to);
		l[i].nex = head[id];
		head[id] = i;
	}
	for (int i = 1; i <= n; i ++) read(mon[i]);
	int S, P;
	read(S); read(P);
	for (int i = 1; i <= P; i ++) {
		read(id); lub[id] = true;
	}
	for (int i = 1; i <= n; i ++) {
		if (!dfn[i]) tarjan(i);
	}
	for (int i = 1; i <= n; i ++) {
		for (int j = head[i]; j; j = l[j].nex) {
			int u = l[j].to;
			if (bel[u] != bel[i]) s.insert(make_pair(bel[i], bel[u]));
		}
	}
	set<pair <int, int> > :: iterator  it;
	int ii = 0;
	for (it = s.begin(); it != s.end(); it ++) {
		g[++ ii] = (info) {it->first, tail[it->second]};
		tail[it->second] = ii;
		r[it->first] ++;
	}
	for (int i = 1; i <= len; i ++) {
		if (!r[i]) {
			q.push(i);
		}
	}
	while(!q.empty()) {
		int d = q.front();
		q.pop();
		val[d] += sum[d];
		if (bar[d]) flg[d] = true;
		if (d == bel[S]) {
			write(val[d], '\n');
			return 0;
		}
		for (int e = tail[d]; e; e = g[e].nex) {
			int u = g[e].to;
			r[u] --;
			if (!r[u]) {
				q.push(u);
			}
			if (flg[d]) {
				val[u] = max(val[u], val[d]);
				flg[u] = true;
			}
		} 
	}
	return 0;
}
```
### 5.彩蛋 觉得豁然开朗（yun li wu li）就点个赞！

---

## 作者：FREEH (赞：1)

### 【题目大意】
 -  给出一幅图、一个起点、一些终点，以及每个点对应的数值，每经过一个点就把这个点的数值累计下来（重复经过的只算一次），问从起点出发，最多可以累计多少数。

### 【解题思路】
- 	只要用Tarjan缩点，然后跑一次SPFA“最长路径”就行了。

### 【参考程序】
```
#include<cstdio>
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
const int M=500005;

int d[M],a[M],b[M];
int n,m,s,T;

struct EDGE{
	int t,next;
}e[M];
int cur;
int head[M];
void add(int a,int b)
{
	cur++;
	e[cur].t=b;
	e[cur].next=head[a];
	head[a]=cur;
}

int DFN[M],LOW[M],sta[M],In[M],color[M],sum[M];
int Index,tot,tp;
void Tarjan(int x)
{
	DFN[x]=LOW[x]=++Index;
	sta[++tp]=x;
	In[x]=true;
	for (int h=head[x];h!=-1;h=e[h].next)
	{
		int t=e[h].t;
		if (!DFN[t])
		{
			Tarjan(t);
			if (LOW[t]<=LOW[x])
				LOW[x]=LOW[t];
		}
		else
		{
			if (In[t])
				if (DFN[t]<=LOW[x])
					LOW[x]=DFN[t];
		}
	}
	if (DFN[x]==LOW[x])
	{
		tot++;
		while (sta[tp+1]!=x)
		{
			color[sta[tp]]=tot;
			sum[tot]+=d[sta[tp]];
			In[sta[tp]]=false;
			tp--;
		}
	}
}

int dis[M],vis[M];
queue <int> q;
void SPFA(int s)
{
	dis[s]=sum[s];
	q.push(s);
	while (!q.empty())
	{
		int x=q.front();q.pop();
		vis[x]=false;
		for (int h=head[x];h!=-1;h=e[h].next)
		{
			int t=e[h].t;
			if (dis[x]+sum[t]>dis[t])
			{
				dis[t]=dis[x]+sum[t];
				if (!vis[t])
				{
					q.push(t);
					vis[t]=true;
				}
			}
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	memset(head,-1,sizeof(head));
	for (int i=1;i<=m;i++)
	{
		scanf("%d%d",&a[i],&b[i]);
		add(a[i],b[i]);
	}
	for (int i=1;i<=n;i++)
		scanf("%d",&d[i]);
	
	for (int i=1;i<=n;i++)
		if (!DFN[i])
			Tarjan(i);
			
	cur=0;
	memset(head,-1,sizeof(head));
	memset(e,0,sizeof(e));
	for (int i=1;i<=m;i++)
		if (color[a[i]]!=color[b[i]])
			add(color[a[i]],color[b[i]]);
	
	scanf("%d%d",&s,&T);
	SPFA(color[s]);//注意是起点对应的缩点
	
	int ans=0;
	for (int i=1;i<=T;i++)
	{
		int t;
		scanf("%d",&t);
		ans=max(ans,dis[color[t]]);//注意是终点对应的缩点
	}
	
	printf("%d",ans);
	
	return 0;
}

---

## 作者：Strong_Jelly (赞：1)

思路 : 

这道题是一道Tarjan + 最长路的题。首先，我们用Tarjan把每个强连通分量缩成一个点，并记录那个强连通分量的点权和(因为当那个人走进一个强连通分量后那个强连通分量中的所有money都会被他拿走(绕一圈不就完了？))，然后我们化点权为边权，再以起点所在的强连通分量跑最长路，最后就能计算出从起点所在的强连通分量到任意一个终点所在的强连通分量的最长距离了(最大money值)，输出的是取从起点所在的强连通分量到任意一个终点所在的强连通分量的最大值。

全文 + 代码：https://www.cnblogs.com/qqq1112/p/11255179.html

---

## 作者：秘密观测者 (赞：1)

Tarjan缩点+最长路

正确性：每一个环我们会走尽量少次 且假如我们走完了某一个环在之后这个环就没有贡献了 能走环一定尽量走环


 
```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<queue>
#include<iomanip>
#include<stack>
#include<map>
#include<set>
#include<cmath>
#define debug(x) cerr<<#x<<"="<<x<<endl
#define INF 0x7f7f7f7f
#define llINF 0x7fffffffffffll
using namespace std;
typedef pair<int,int> pii;
typedef long long ll;
inline int init()
{
    int now=0,ju=1;char c;bool flag=false;
    while(1)
    {
        c=getchar();
        if(c=='-')ju=-1;
        else if(c>='0'&&c<='9')
        {
            now=now*10+c-'0';
            flag=true;
        }
        else if(flag)return now*ju;
    }
}
inline long long llinit()
{
    long long now=0,ju=1;char c;bool flag=false;
    while(1)
    {
        c=getchar();
        if(c=='-')ju=-1;
        else if(c>='0'&&c<='9')
        {
            now=now*10+c-'0';
            flag=true;
        }
        else if(flag)return now*ju;
    }
}
int scc[500005],head[500005],h[500005],belong[500005],v[500005],sccnumber,cnt,cou;
struct edge
{
    int from,to,val,pre;
}Edge[500005],road[500005];
inline void addedge(int from,int to,int val)
{
    ++cnt;
    Edge[cnt]=((edge){from,to,val,head[from]});
    head[from]=cnt;
}
inline void insert(int from,int to,int val)
{
    ++cou;
    road[cou]=((edge){from,to,val,h[from]});
    h[from]=cou;
}
int dfs_time=0;
stack<int> s;
int dfn[500005],low[500005];
bool bar[500005],instack[500005];
int n,m,p,k,st;
void tarjan(int now)
{
    dfn[now]=low[now]=++dfs_time;
    s.push(now);instack[now]=true;
    for(int j=h[now];j;j=road[j].pre)
    {
        if(!dfn[road[j].to])
        {
            tarjan(road[j].to);
            low[now]=min(low[now],low[road[j].to]);
        }
        else if(instack[road[j].to])
        {
            low[now]=min(low[now],dfn[road[j].to]);
        }
    }
    int topt;
    if(dfn[now]==low[now])
    {
        ++sccnumber;
        while(1)
        {
            topt=s.top();s.pop();
            belong[topt]=sccnumber;
            scc[sccnumber]+=v[topt];
            instack[topt]=false;
            if(dfn[topt]==low[topt])
            {
                break;
            }
        }
    }
}
void rebuild()
{
    for(int i=1;i<=cou;i++)
    {
        if(belong[road[i].from]!=belong[road[i].to])
        {
            addedge(belong[road[i].from],belong[road[i].to],-scc[belong[road[i].to]]);
        }
    }
}
queue<int> q;
bool inq[500005];
int dis[500005];
int spfa()
{
    int now;
    for(int i=1;i<=n;i++)dis[i]=INF;
    dis[belong[st]]=-scc[belong[st]];
    q.push(belong[st]);inq[belong[st]]=1;
    while(!q.empty())
    {
        now=q.front();q.pop();
        inq[now]=false;
        for(int j=head[now];j;j=Edge[j].pre)
        {
            if(dis[Edge[j].to]>dis[now]+Edge[j].val)
            {
                dis[Edge[j].to]=dis[now]+Edge[j].val;
                if(!inq[Edge[j].to])
                {
                    q.push(Edge[j].to);
                    inq[Edge[j].to]=true;
                }
            }
        }
    }
    int maxx=0;
    for(int i=1;i<=n;i++)
    {
        if(bar[i])
        {
            maxx=max(maxx,-dis[belong[i]]);
        }
    }
    return maxx;
}
int main()
{
    int a,b;
    n=init();m=init();
    for(int i=1;i<=m;i++)
    {
        a=init();b=init();
        insert(a,b,1);
    }
    for(int i=1;i<=n;i++)
    {
        v[i]=init();
    }
    st=init();k=init();
    for(int i=1;i<=k;i++)
    {
        a=init();
        bar[a]=1;
    }
    for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
        {
            tarjan(i);
        }
    }
    rebuild();
    printf("%d\n",spfa());
    return 0;
}
```
/\*
srO xudyh davidlee1999WTK linkct1999 Orz

compiler TDM-GCC 5.9.2

\*/

---

## 作者：k，火魂 (赞：0)

相信好多写DP的拿到了87分，而且看上去写的没有错误（~~我就是这么个....~~）

写DP是对的，但是注意一下条件（其实变成了最长路）

```cpp
inline void work(){
	q.push(bl[s]);dp[bl[s]]=val[bl[s]];
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int i=hea[x];i;i=nex[i]){
			int y=ver[i];
			dp[y]=max(dp[y],dp[x]+val[y]);
			du[y]--;
			if(du[y]==0)q.push(y);
		}
	}
}

```

注意这里，不要让du[y]==0时再入队，因为人家又，没有说必须入度为零才能走

![这个图](file:///C:/Documents%20and%20Settings/Administrator/%E6%A1%8C%E9%9D%A2/%E6%9C%AA%E5%91%BD%E5%90%8D.bmp)

~~图片坏了~~

那只好再脑子里面想象：如果一个点的下一个点就是终点，而左面有两个点可以到达这个点，那么这个点可能不会入队，因为起点只有一个，这个点的入度可能一直不回变成0，但是不变成0就不能走了吗？？所以这么写只有87分啦(~~话说数据还是很水的吧~~)

是不是发现自己根本跑不到终点？？

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<map>
using namespace std;
const int N=5e5+10;
int ver[N],nex[N],hea[N];
int w[N],val[N];
int bl[N],du[N],st[N];
int dfn[N],low[N];
int n,m,num,tot,cnt,top,s,p;
bool ins[N];
int a[N],b[N];
int dp[N];
bool v1[N],v2[N];
queue<int>q;
map<pair<int,int>,bool>v;

inline void add(int x,int y){
	ver[++tot]=y;nex[tot]=hea[x];hea[x]=tot;
}

inline void tr(int x){
	dfn[x]=low[x]=++cnt;
	st[++top]=x;ins[x]=1;
	for(int i=hea[x];i;i=nex[i]){
		int y=ver[i];
		if(!dfn[y]){
			tr(y);
			low[x]=min(low[x],low[y]);
		}
		else if(ins[y])low[x]=min(low[x],dfn[y]);
	}
	if(dfn[x]==low[x]){
		num++;
		while(st[top+1]!=x){
			int y=st[top--];
			ins[y]=0;val[num]+=w[y];bl[y]=num;
			if(v1[y])v2[num]=1;
		}
	}
}

inline void work(){
	q.push(bl[s]);dp[bl[s]]=val[bl[s]];
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int i=hea[x];i;i=nex[i]){
			int y=ver[i];
			if(dp[y]<dp[x]+val[y]){
				dp[y]=dp[x]+val[y];
				q.push(y);
			}
		}
	}
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int x,y;scanf("%d%d",&x,&y);
		add(x,y);
		a[i]=x,b[i]=y;
	}
	for(int i=1;i<=n;i++){
		scanf("%d",&w[i]);
	}
	scanf("%d%d",&s,&p);
	for(int i=1;i<=p;i++){
		int x;scanf("%d",&x);v1[x]=1;
	}
	for(int i=1;i<=n;i++){
		if(!dfn[i])tr(i);
	}
	memset(hea,0,sizeof(hea));tot=0;
	for(int i=1;i<=m;i++){
		int fx=bl[a[i]],fy=bl[b[i]];
		if(fx==fy||v[make_pair(fx,fy)])continue;
		else{
			add(fx,fy);
			du[fy]++;
		}
	}
//	for(int i=1;i<=m;i++)cout<<a[i]<<"  "<<b[i]<<"  ";cout<<endl;
//	for(int i=1;i<=num;i++)cout<<val[i]<<"  ";cout<<endl;
//	for(int j=1;j<=num;j++){
//		for(int i=hea[j];i;i=nex[i]){
//			cout<<ver[i]<<"  ";
//		}
//		cout<<endl;
//	}
	work();
	int ans=0;
	for(int i=1;i<=num;i++){
		if(v2[i])ans=max(ans,dp[i]);
	}
	printf("%d",ans);
	return 0;
	return 0;
}
```



---

## 作者：与我常在 (赞：0)

打了一个多小时，心累啊，差点就打不下去了，还好坚持下来了

最后的延时奖励就是一遍AC啦

由于Siruseri能在多次经过一个路口，所以如果该路口处于一个强联通分量中，则该强连通分量其他的ATM机一定能够到达，所以很显然我们可以对此图进行缩点，缩完后在新建的图中跑一遍最长路即可

最后计算最大值的时候，当且仅当该"点"中存在酒吧才算上这份，
否则就是不满足条件的(因为Siruseri要去酒吧庆祝)

下面是代码

```cpp
#include <queue>
#include <cstdio>
#include <cstring>

using namespace std;

const int N = 500005;

int s, p, n, m, num, idx, top, tot;
int a[N], dl[N], dfn[N], low[N];
int val1[N], bar1[N], head1[N];
int val2[N], bar2[N], head2[N];
int in[N], dis[N];

queue <int> q;

struct edge {
	int to;
	int next;
}s1[N], s2[N];

inline int Min(int x, int y) {
	return x < y ? x : y;
}

inline int Max(int x, int y) {
	return x > y ? x : y;
}

void add1(int u, int v) {
	s1[num].to = v;
	s1[num].next = head1[u];
	head1[u] = num ++;
}

void add2(int u, int v) {
	s2[num].to = v;
	s2[num].next = head2[u];
	head2[u] = num ++;
}

void tarjan(int x) {
	dfn[x] = low[x] = ++ idx;
	dl[++ top] = x;
	for(int i = head1[x]; ~i; i = s1[i].next) {
		if(!dfn[s1[i].to])
			tarjan(s1[i].to), low[x] = Min(low[x], low[s1[i].to]);
		else if(!a[s1[i].to]) low[x] = Min(low[x], dfn[s1[i].to]);
	}
	
	if(dfn[x] == low[x]) {
		a[x] = ++tot;
		while(dl[top] != x) {
			a[dl[top]] = tot;
			if(bar1[dl[top]] && !bar2[tot])
				bar2[tot] = 1;
			val2[tot] += val1[dl[top]];
			top --;
		}
		if(bar1[dl[top]] && !bar2[tot])
			bar2[tot] = 1;
		val2[tot] += val1[dl[top]];
		top --;
	}
}

void build() {
	for(int i = 1; i <= n; i ++)
		if(a[i]) {
			for(int j = head1[i]; ~j; j = s1[j].next)
				if(a[i] != a[s1[j].to]) {
					add2(a[i], a[s1[j].to]);
					++ in[a[s1[j].to]];
				}
		}
}

void topsort() {
	memset(dis, 0xaf, sizeof dis);  dis[a[s]] = val2[a[s]];
	for(int i  = 1; i <= tot; i ++)
		if(!in[i]) q.push(i);
	
	while(!q.empty()) {
		int x = q.front();  q.pop();
		for(int i = head2[x]; ~i; i = s2[i].next) {
			dis[s2[i].to] = Max(dis[s2[i].to], dis[x] + val2[s2[i].to]);
			if(!(-- in[s2[i].to])) q.push(s2[i].to);
		}
	}
}

int main() {
	scanf("%d %d", &n, &m);
	
	memset(head1, -1, sizeof head1);
	memset(head2, -1, sizeof head2);
	for(int i = 1; i <= m; i ++) {
		int u, v;
		scanf("%d %d", &u, &v);
		add1(u, v);
	}
	for(int i = 1; i <= n; i ++) scanf("%d", &val1[i]);
	
	int x;
	scanf("%d %d", &s, &p);
	for(int i = 1; i <= p; i ++)
		scanf("%d", &x), bar1[x] = 1;
	
	num = 0;
	tarjan(s);
	build();
	topsort();
	
	int mx = -1e9;
	for(int i = 1; i <= tot; i ++)
		if(bar2[i]) mx = Max(dis[i], mx);
	printf("%d\n", mx);
	
	return 0;
}
```




---

## 作者：lzcjoe (赞：0)

### 题面

1518：抢掠计划

时间限制: 1000 ms 内存限制: 131072 KB

【题目描述】

原题来自：APIO 2009

$Siruseri$城中的道路都是单向的。不同的道路由路口连接。按照法律的规定，在每个路口都设立了一个$Siruseri$银行的$ATM$取款机。令人奇怪的是，$Siruseri$的酒吧也都设在路口，虽然并不是每个路口都设有酒吧。

$Banditji$计划实施$Siruseri$有史以来最惊天动地的$ATM$抢劫。他将从市中心出发，沿着单向道路行驶，抢劫所有他途径的$ATM$机，最终他将在一个酒吧庆祝他的胜利。

使用高超的黑客技术，他获知了每个$ATM$机中可以掠取的现金数额。他希望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可以经过同一路口或道路任意多次。但只要他抢劫过某个$ATM$机后，该$ATM$机里面就不会再有钱了。

例如，假设该城中有$6$个路口，道路的连接情况如下图所示：

![](https://cdn.luogu.com.cn/upload/pic/4396.png)

市中心在路口$1$，由一个入口符号 → 来标识，那些有酒吧的路口用双圈来表示。每个$ATM$机中可取的钱数标在了路口的上方。在这个例子中，$Banditji$能抢劫的现金总数为$47$，实施的抢劫路线是：1−2−4−1−2−3−5。

【输入】

第一行包含两个整数$N,M$。$N$表示路口的个数，$M$表示道路条数。

接下来$M$行，每行两个整数，这两个整数都在$1$到$N$之间，第$i+1$行的两个整数表示第$i$条道路的起点和终点的路口编号。

接下来$N$行，每行一个整数，按顺序表示每个路口处的$ATM$机中的钱数。

接下来一行包含两个整数$S,P$，$S$表示市中心的编号，也就是出发的路口。$P$表示酒吧数目。

接下来的一行中有$P$个整数，表示$P$个有酒吧的路口的编号。

【输出】

输出一个整数，表示$Banditji$从市中心开始到某个酒吧结束所能抢劫的最多的现金总数。

【输入样例】

6 7

1 2

2 3

3 5

2 4

4 1

2 6

6 5

10

12

8

16

1 5

1 4

4

3

5

6

【输出样例】

47

【提示】

数据范围与提示:

$50%$的输入保证$N,M≤3000$。

$100%$的输入保证$N,M≤500000$。

每个$ATM$机中可取的钱数为一个非负整数且不超过$400$0。输入数据保证你可以从市中心沿着$Siruseri$的单向的道路到达其中的至少一个酒吧。

### 算法

Tarjan缩点+SPFA最长路

>有向图强连通分量：在有向图$G$中，如果两个顶点$vi,vj$间（$vi>vj$）有一条从$vi$到$vj$的有向路径，同时还有一条从$vj$到$vi$的有向路径，则称两个顶点强连通$(strongly$ $connected)$。如果有向图$G$的每两个顶点都强连通，称$G$是一个强连通图。有向图的极大强连通子图，称为强连通分量$(strongly$ $connected$ $components)$。

对于本题中的强盗，如果在一个强连通分量中必定能将强连通分量中的$ATM$机的钱抢完（每个结点都强连通，并且一条边可以走很多次），所有将原图计算强连通分量并缩点，变成一张有向无环图，定义边权为指向的结点所代表的强连通分量中的$ATM$机的钱的总数，再在这张有向无环图中求最长路（起始结点的最长路径设置为当前节点代表的强连通分量的金额和）。

有向无环图求最长路有很多办法，此处使用的是图论最短路 / 最长路的SPFA算法。

### 代码

```cpp
#include<cstdio>
#include<cstring>
#include<stack>
#include<queue>
#define mini(a,b) ((a)<(b)?(a):(b))
#define maxi(a,b) ((a)>(b)?(a):(b))
const unsigned int N=500005;
unsigned int n,m,s,p,b[N],u[N],v[N];
unsigned short int a[N];
long long int ans;
struct node
{
	unsigned int to,next;
	unsigned long long int w;
}edge[N];
unsigned int cnt,head[N];
inline void add(unsigned int x,unsigned int y)
{
	cnt++;
	edge[cnt].to=y;
	edge[cnt].next=head[x];
	head[x]=cnt;
}
inline void addw(unsigned int u,unsigned int v,unsigned long long int w)
{
	cnt++;
	edge[cnt].to=v;
	edge[cnt].next=head[u];
	head[u]=cnt;
	edge[cnt].w=w;
}//链式前向心存边、加边（对于新的图，采用旧图的结构体存，省内存）
unsigned int dfn[N],low[N],step,col[N],num;
unsigned long long int sum[N];
std::stack<unsigned int> stack;
void Tarjan(unsigned int i)
{
	step++;
	dfn[i]=step;
	low[i]=step;
	stack.push(i);
	unsigned int k;
	for(unsigned int j=head[i];j!=0;j=edge[j].next)
	{
		k=edge[j].to;
		if(dfn[k]==0)
		{
			Tarjan(k);
			low[i]=mini(low[i],low[k]);
		}
		else if(col[k]==0)
		{
			low[i]=mini(low[i],dfn[k]);
		}
	}
	if(dfn[i]==low[i])
	{
		num++;
		col[i]=num;
		sum[num]+=a[i];
		while(stack.top()!=i)
		{
			col[stack.top()]=num;
			sum[num]+=a[stack.top()];//统计总金额
			stack.pop();
		}
		stack.pop();
	}
	return;
}//强连通分量缩点Tarjan算法
long long int dis[N];
std::queue<unsigned int> q;
bool book[N];
int main()
{
	scanf("%u%u",&n,&m);
	for(register unsigned int i=1;i<=m;i++)
	{
		scanf("%u%u",&u[i],&v[i]);
		add(u[i],v[i]);
	}
	for(register unsigned int i=1;i<=n;i++)
	{
		scanf("%hu",&a[i]);
	}
	scanf("%u%u",&s,&p);
	for(register unsigned int i=1;i<=p;i++)
	{
		scanf("%u",&b[i]);
	}//读入、加边
	for(register unsigned int i=1;i<=n;i++)
	{
		if(dfn[i]==0)
		{
			Tarjan(i);
		}
	}//Tarjan算法
	cnt=0;
	memset(head,0,sizeof(head));
	for(register unsigned int i=1;i<=m;i++)
	{
		if(col[u[i]]!=col[v[i]])
		{
			addw(col[u[i]],col[v[i]],sum[col[v[i]]]);
		}
	}//重新加边
	dis[col[s]]=sum[col[s]];
	q.push(col[s]);
	register unsigned int i,k;
	while(!q.empty())
	{
		i=q.front();
		q.pop();
		book[i]=0;
		for(register unsigned int j=head[i];j!=0;j=edge[j].next)
		{
			k=edge[j].to;
			if(dis[k]<dis[i]+edge[j].w)
			{
				dis[k]=dis[i]+edge[j].w;
				if(book[k]==0)
				{
					q.push(k);
					book[k]=1;
				}
			}
		}
	}//SPFA最长路
	for(register unsigned int i=1;i<=p;i++)
	{
		ans=maxi(ans,dis[col[b[i]]]);
	}//统计答案
	printf("%llu",ans);
	return 0;
}
```

#### 运行结果

一本通OJ：

1518

未通过 93分

测试点1: 答案正确 2456KB 7MS 

测试点2: 答案正确 2452KB 7MS 

测试点3: 答案正确 2460KB 7MS 

测试点4: 答案正确 2560KB 9MS 

测试点5: 答案正确 2572KB 8MS 

测试点6: 答案正确 2584KB 9MS 

测试点7: 答案正确 2572KB 9MS 

测试点8: 答案正确 2620KB 9MS 

测试点9: 答案正确 2612KB 9MS 

测试点10: 答案正确 25180KB 536MS 

测试点11: 答案正确 24668KB 560MS 

测试点12: 运行错误 33164KB 539MS 

测试点13: 答案正确 31632KB 568MS 

测试点14: 答案正确 24140KB 517MS 

测试点15: 答案正确 24160KB 504MS 

才2MB栈空间，第12点爆栈了！

洛谷：

用时 1.58s 内存 37.66MB

测试点信息

8ms/18.63MB AC #1

276ms/21.32MB AC #2

298ms/20.53MB AC #3

256ms/37.66MB AC #4

257ms/35.27MB AC #5

233ms/24.74MB AC #6

202ms/26.70MB AC #7

5ms/2.52MB AC #8

4ms/2.68MB AC #9

6ms/2.78MB AC #10

6ms/2.82MB AC #11

5ms/2.70MB AC #12

10ms/18.79MB AC #13

8ms/18.64MB AC #14

5ms/2.64MB AC #15

---

## 作者：lian_sama (赞：0)

#### 这是一道好题
主题思路：

1.缩点去环

2.重新建图

3.SPFA求最长路

4.维护更新答案

## 1.缩点

1个结点本身是强连通分量 dfn深搜中节点次序号，low以u为根的最小次序号 

如果low与dfn相同，则是发现了一个环。则弹栈进行缩点，并且累加钱。

注意：至少要操作一次，因此用dowhile

## 2.建图

缩完点以后，序号已被破坏，因此要重建一个新id含点权的图来进行SPFA

## 3.SPFA点权最长路

1.起点打标记,距离的数组设初值,进队 

2.出队保存到临时变量,标记取消

3.循环找下一个点 

4.判断 f[]代表从起点s到v点的能取的最多的钱，如果有更多，就更新 

5.更新

6.判断是否进队，如果v点不在队列里，进队，并且打上标记 

## 4.维护更新答案
将f[酒吧的新序号]与ans比较

## 话不多说，上代码

```cpp
//3627
#include<cstdio>
#include<iostream>
#include<cmath>
#include<queue>
#include<stack>
#include<algorithm>
#define inf 1e9
using namespace std;
const int N=500100,M=500500; 
stack<int> stk;
int last[N],last2[N],f[N],nid[N],money[N],dfn[N],low[N],ax[N],ay[N],vis[N],val[N],mark[N],bar[N]; 
int n,m,cnt,ans,tot,s,p;
struct edge{
	int to,prev; 
}e[M*3];
inline void add(int u,int v,int *last){
	e[++tot]=edge{v,last[u]};
	last[u]=tot;
}
inline void tarjan(int u){//缩点 
  	dfn[u]=low[u]=++tot;vis[u]=1;stk.push(u); //1个结点本身是强连通分量 dfn深搜中节点次序号，low以u为根的最小次序号 
  	int v;
	for(int p=last[u];p;p=e[p].prev){ 
		v=e[p].to; 
    	if(!dfn[v])tarjan(v),low[u]=min(low[u],low[v]);
    	else if(vis[v])low[u]=min(low[u],dfn[v]); //u和已经求得序号取最小 
  	} 
	if(low[u]==dfn[u]){
		cnt++;//缩点后新的序号 
        do{
            v=stk.top();stk.pop();
            money[cnt]+=val[v];//累加钱 
            vis[v]=0;
			nid[v]=cnt;  //强连通分量里面的所有点都是同一个新序号 
        }while(u!=v);  //直到环绕回去 
  	}
}
inline void spfa(){
	queue<int> qu;//mark代表当前的点是否在队列里 
	qu.push(nid[s]);f[nid[s]]=money[nid[s]];mark[nid[s]]=true;//1.起点打标记,距离的数组设初值,进队 
	while(!qu.empty()){
		int u=qu.front();qu.pop();mark[u]=false;//2.出队保存到临时变量,标记取消， 
		for(int i=last2[u];i;i=e[i].prev){//3.循环找下一个点 
			int v=e[i].to;//取到下一个点 
			if(f[v]<f[u]+money[v]){ //4.判断 f[]代表从起点s到v点的能取的最多的钱，如果有更多，就更新 
				f[v]=f[u]+money[v];//5.更新 
				if(!mark[v])qu.push(v),mark[v]=true;//6.判断是否进队，如果v点不在队列里，进队，并且打上标记 
			}
		}
	}
	return;
}
int main() {
  	scanf("%d%d",&n,&m); 
  	for(int i=1;i<=m;i++){
		scanf("%d%d",&ax[i],&ay[i]);
    	add(ax[i],ay[i],last); 
  	} 
  	for(int i=1;i<=n;i++)scanf("%d",&val[i]);
  	scanf("%d%d",&s,&p);
  	for(int i=1;i<=p;i++)scanf("%d", &bar[i]);
  	for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);  //缩点 
	for(int i=1;i<=m;i++){
    	int x=nid[ax[i]],y=nid[ay[i]];
    	if(x!=y)add(x,y,last2); //不在环上,建边 
  	} 
	spfa();  
  	for(int i=1;i<=p;i++)ans=max(ans,f[nid[bar[i]]]); // 最大值 
  	printf("%d\n",ans);
  	return 0; 
} 
```


---

## 作者：Thomasguo666 (赞：0)

## Tarjan+dp

这道题是一道不错的强连通分量入门题，如果您是大佬~~那还看什么题解啊直接5分钟爆切~~，如果您不会强连通分量那这篇题解就是写给您的。

首先，我们从某个节点对整个图进行$DFS$。我们发现，图中会有四种边：树边，回边，前向边，横叉边。

放张图感受一下（图中连接3、5节点的边画反了）

![digraph.png](https://i.loli.net/2019/05/01/5cc90433ccfed.png)

如何区分这四种边呢？

我们$dfs$的时候，会记录每个点的$dfs$序$dfn$（即这个点第一次被$dfs$到的时间）。

对于每个节点$u$，考虑从它出发的一条边$e$连向的点$v$：

如果$v$的$dfn$为$0$，即它还没有被$dfs$过，说明$e$是树边。

如果$v$的$dfn$比$u$小，并且$v$是$u$的祖先，说明$e$是回边，如果不是，那么$e$是横叉边。

如果$v$的$dfn$比$u$大，说明$e$是前向边。



我们考虑一个环，容易发现一个环就是一堆树边、一堆横叉边、和一堆回边构成的。这里前向边没什么用，因为总能被一堆树边代替。而一个强连通分量就是$u$与所有能与$u$构成一个环的节点的集合。



接下来我们需要维护一个栈。当$dfs$到$u$节点时，栈内保存u的祖先节点和已经访问过并且可以到达$u$的祖先节点的节点。显然栈里的节点能与从$u$出发的回边或横叉边构成环。



为了维护这个栈，我们定义追溯值$low$，它表示一个节点$u$通过最多一次回边或横叉边能够$dfs$到的$dfn$最小的在栈内的节点。

那么有
$$
low[u]=
\min_{\texttt{v为u的邻居}}{\begin{cases}
low[v] \quad\texttt{u到v的边为树边}\\
dfn[v] \quad\texttt{u到v的边不为树边，即v被访问过且在栈里}
\end{cases}
}
$$
然后对于每个$dfs$到的节点$u$，我们先将它入栈。接下来对于$u$每个邻居$v$，如果$v$没有$dfs$过（第一种情况），那么对$v$进行$dfs$，然后更新$u$的$low$，如果$v$被$dfs$过并且在栈里（第二种情况），那么直接更新$u$的$low$。

接下来如果$low[u]$仍然等于$dfn[u]$，说明从$u$到栈顶的所有节点单独构成强连通分量，因为这一部分节点及无法与栈内的其他节点构成强连通分量，也不可能与尚未$dfs$到的节点构成强连通分量。因此将$u$和$u$上方的节点全部弹出，并把这些节点所在强连通分量编号全部标记为$u$。

配合代码理解一下

```cpp
int cnt;
int dfn[N],low[N],scc[N],ins[N];
stack<int> s;
void tarjan(int u)
{
    dfn[u]=low[u]=++cnt;
    s.push(u);ins[u]=1;
    for (int e=head[u];e;e=nex[e])
    {
        int v=tail[e];
        if (!dfn[v])
        {
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }
        else if (ins[v])
        {
            low[u]=min(low[u],dfn[v]);
        }
    }
    if (dfn[u]==low[u])
    {
        while (!s.empty())
        {
            int w=s.top();w.pop();
            scc[w]=u;ins[w]=0;
            if (w==u) break;
        }
    }
}
```

然后就是本题了。首先我们跑出图上所有的强连通分量，然后把每个强连通分量都当作一个点看待，这样这个强连通分量就成了一张DAG。因此我们对它进行拓扑排序，同时进行DP就行了。

```cpp
#include <bits/stdc++.h>
#define debug printf("Running %s on line %d...\n",__FUNCTION__,__LINE__)
#define re register
#define mid (l+r>>1)
using namespace std;
int read()
{
    int ans=0,f=1;char c=getchar();
    for (;!isdigit(c);c=getchar()) if (c=='-') f=-1;
    for (;isdigit(c);c=getchar()) ans=(ans<<3)+(ans<<1)+(c^48);
    return ans*f;
}
const int N=1000005;
struct Graph
{
    int tot;
    int head[N],tail[N],nex[N];
    Graph () 
    {
        tot=0;
        memset(head,0,sizeof(head));
        memset(tail,0,sizeof(tail));
        memset(nex,0,sizeof(nex));
    }
    void addedge(int u,int v)
    {
        nex[++tot]=head[u];
        head[u]=tot;
        tail[tot]=v;
    }
};
int val[N],bar[N];
Graph a,b;
int cnt;
int dfn[N],low[N],scc[N];
stack<int> s;
void tarjan(int u)
{
    dfn[u]=low[u]=++cnt;
    s.push(u);
    for (int e=a.head[u];e;e=a.nex[e])
    {
        int v=a.tail[e];
        if (!dfn[v])
        {
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }
        else if (!scc[v])
        {
            low[u]=min(low[u],dfn[v]);
        }
    }
    if (dfn[u]==low[u])
    {
        int w;
        do
        {
            w=s.top();s.pop();
            scc[w]=u;
            if (w==u) break;
            val[u]+=val[w],bar[u]|=bar[w];
        } while (w!=u);
    }
}
int st[N],en[N],in[N],dis[N];
int main()
{
    int n=read(),m=read(),s,p;
    for (int i=1;i<=m;i++)
    {
        int u=read(),v=read();
        a.addedge(u,v);
        st[i]=u,en[i]=v;
    }
    for (int i=1;i<=n;i++) val[i]=read();
    s=read(),p=read();
    for (int i=1;i<=p;i++) bar[read()]=1;
    tarjan(s);
    for (int i=1;i<=m;i++)
    {
        if (scc[st[i]] && scc[st[i]]!=scc[en[i]]) b.addedge(scc[st[i]],scc[en[i]]),in[scc[en[i]]]++;
    }
    dis[scc[s]]=val[scc[s]];
    queue<int> q;
    q.push(scc[s]);
    while (!q.empty())
    {
        int u=q.front();q.pop();
        for (int e=b.head[u];e;e=b.nex[e])
        {
            int v=b.tail[e];
            dis[v]=max(dis[v],dis[u]+val[v]);
            if (!(--in[v])) q.push(v);
        }
    }
    int ans=0;
    for (int i=1;i<=n;i++) if (scc[i] && bar[i]) ans=max(ans,dis[i]);
    cout<<ans<<endl;
    return 0;
}

```



---

## 作者：Nero_Claudius (赞：0)

一眼望去题解里都是最长路，因此决定写一篇$DP$。

------------

### 思路

很明显这题是一道$tarjan$缩点的题目，问题在于，缩完点后如何求出答案？

思路有两种：一种是貌似主流的$SPFA$最长路，即将点权转换为边权然后反跑最短路；另一种，则是采用$DP$的思路。

子状态为$dp[i]$，表示抢劫第i个节点的最大值。

转移方程为$dp[i]=max(dp[i],dp[j]+sum[j])$，其中$j$为指向i的节点。

转移时我们采取类似拓扑排序的方法，将所有入度为$0$的节点入栈，然后持续弹出/插入。

本题有一个需要注意的细节：$tarjan$缩点的时候只用缩起点，这是因为起点无法到达的节点对答案没有影响。

------------

### 代码

`995ms 66564kb`

```cpp
#include<bits/stdc++.h>

using namespace std;

namespace StandardIO {

	template<typename T>inline void read (T &x) {
		x=0;T f=1;char c=getchar();
		for (; c<'0'||c>'9'; c=getchar()) if (c=='-') f=-1;
		for (; c>='0'&&c<='9'; c=getchar()) x=x*10+c-'0';
		x*=f;
	}

	template<typename T>inline void write (T x) {
		if (x<0) putchar('-'),x*=-1;
		if (x>=10) write(x/10);
		putchar(x%10+'0');
	}

}

using namespace StandardIO;

namespace Fate {

	const int N=500500;

	int n,m,s,p,ans=0;
	int cnt,cntt;
	int head[N],headd[N],to[N<<1],too[N<<1],next[N<<1],nextt[N<<1];
	int is_bar[N],Bar[N],val[N];
	int bcnt,index;
	int low[N],dfn[N],instack[N],belong[N],sum[N];
	stack<int> st;
	int dp[N],indeg[N];
	
	inline void add (int a,int b) {
		to[++cnt]=b,next[cnt]=head[a],head[a]=cnt;
	}
	inline void add2 (int a,int b) {
		too[++cntt]=b,nextt[cntt]=headd[a],headd[a]=cntt;
	}
	void tarjan (int now) {
		dfn[now]=low[now]=++index;
		st.push(now),instack[now]=1;
		for (register int i=head[now]; i; i=next[i]) {
			if (!dfn[to[i]]) {
				tarjan(to[i]);
				low[now]=min(low[now],low[to[i]]);
			} else if (instack[to[i]]) {
				low[now]=min(low[now],dfn[to[i]]);
			}
		}
		if (low[now]==dfn[now]) {
			int v=-1;bcnt++;
			while (v!=now) {
				v=st.top(),st.pop();
				instack[v]=0,belong[v]=bcnt,sum[bcnt]+=val[v];
			}
		}
	}
	void calc () {
		queue<int> q;
		q.push(belong[s]),dp[belong[s]]=sum[belong[s]];
		while (!q.empty()) {
			int now=q.front();q.pop();
			for (register int i=headd[now]; i; i=nextt[i]) {
				dp[too[i]]=max(dp[too[i]],dp[now]+sum[too[i]]);
				--indeg[too[i]];
				if (indeg[too[i]]==0) {
					q.push(too[i]);
				}
			}
		}
	}

	inline void Stay_Night () {
		read(n),read(m);
		for (register int i=1; i<=m; ++i) {
			int x,y;
			read(x),read(y);
			add(x,y);
		}
		for (register int i=1; i<=n; ++i) {
			read(val[i]);
		}
		read(s),read(p);
		for (register int i=1; i<=p; ++i) {
			int x;
			read(x);
			is_bar[x]=1;
		}
		tarjan(s);
		for (register int i=1; i<=n; ++i) {
			if (!belong[i]) continue;
			Bar[belong[i]]=max(Bar[belong[i]],is_bar[i]);
			for (register int j=head[i]; j; j=next[j]) {
				if (belong[i]!=belong[to[j]]) {
					add2(belong[i],belong[to[j]]);
					indeg[belong[to[j]]]++;
				}
			}
		}
		calc();
		for (register int i=1; i<=bcnt; ++i) {
			if (Bar[i]) ans=max(ans,dp[i]);
		}
		write(ans);
	}
	
}

int main () {
//	freopen("testdata.in","r",stdin);
//	freopen("test.out","w",stdout);
	Fate::Stay_Night();
}

```

---

## 作者：Fellyhosn (赞：0)

# P3627 [APIO2009]抢掠计划 

## 标签：SPFA，Tarjan，栈

## [题目链接](https://www.luogu.org/problemnew/show/P3627)

其实这是之前考试的一道题，当时的做法是——**搜索**，然后好像过了一个点！

搜索过程就不说了，纯模拟。

## 代码1（暴力搜索）7分：
~~~
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

int gi()
{
    char x=getchar();int t=0,fh=1;
    while(x>'9'||x<'0') { if(x=='-') fh=-1; x=getchar(); }
    while(x>='0'&&x<='9') { t=t*10+x-'0';   x=getchar(); }
    return fh*t;
}

int n,m;
int tot,head[500010];
struct edge{
    int nxt,to;
}e[500010];
int du[500010],atm[500010];
bool bar[500010];//是否是终点（酒吧） 
int s,p;
int ans;
int vis[500010];//搜索时访问的次数 

void add(int x,int y)
{
    e[++tot].to=y;e[tot].nxt=head[x];head[x]=tot;
}

void dfs(int now,int sum)
{
    if(atm[now]&&sum>ans) ans=sum;
    for(int j=head[now];j;j=e[j].nxt)
    {
        int g1=e[j].to;
        if(vis[g1]<du[g1])
        {
            vis[g1]++;
            if(vis[g1]==1)
            dfs(g1,sum+atm[g1]);
            else dfs(g1,sum);
            vis[g1]--;
        }
    }
    return ;
}

inline void openfile()
{
    freopen("atm.in","r",stdin);
    freopen("atm.out","w",stdout);
}

int main()
{
    n=gi();m=gi();
    for(int i=1;i<=m;i++)
    {
        int x,y;
        x=gi();y=gi();
        add(x,y);
        du[x]++;du[y]++;
    }
    for(int i=1;i<=n;i++)
    atm[i]=gi();
    s=gi();p=gi();
    for(int i=1;i<=p;i++)
    {
      int barr=gi();
      bar[barr]=true;
    }
    dfs(s,0);
    cout<<ans;
    return 0;
}
~~~

于是痛下决心，要爆肝此题。

题目意思没有转换成模型，所以感觉这道题很难的样子。考试完了有人说要tarjan缩点，我还是很懵，后来在~~题解~~帮助下大概想明白了这道题。

### 由于路径是可以重复的！所以对于一个联通块来说可以从任意一点进出并且可以遍历完整个联通块！
### 所以这里要用到tarjan缩点！！！（这是第一步）

缩点之后，题目就转化成了：
### 给定$x$个点权，求从$col(S)$出发,$col(bar_i)$结束能够遍历最大权值和。
### 这里用SPFA求出最长路径，然后比较输出就行了（这是第二步）


$Tarjan$缩点+$SPFA$求最长路，看起来就是正解了！于是有了这个代码：
## 代码2（Tarjan+SPFA莫名RE）$88$分
### 相信有不少88分的大佬（别急后面有解释）
~~~
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;

struct edge{
    int fro,nxt,to;
}e[500010],s[500010];
int tot,head[500010];
int inde,dfn[500010],low[500010];
int sta[500010],tp;
int col[500010],cnt,sum[500010],dis[500010];
int atm[500010];
bool vis[500010];
int n,m,ans;
int S,T;

void add(int x,int y)
{
    e[++tot].to=y;
    e[tot].fro=x;
    e[tot].nxt=head[x];
    head[x]=tot;
}

void add2(int x,int y)
{
    s[++tot].to=y;
    s[tot].nxt=head[x];
    head[x]=tot;
}

void tarjan(int v)
{
    dfn[v]=low[v]=++inde;
    sta[++tp]=v;
    vis[v]=true;
    for(int j=head[v];j;j=e[j].nxt)
    {
        int g1=e[j].to;
        if(!dfn[g1])
        {
            tarjan(g1);
            low[v]=min(low[v],low[g1]);
        }
        else if(vis[g1])
        low[v]=min(low[v],dfn[g1]);
    }
    if(low[v]==dfn[v])
    {
        cnt++;
        while(sta[tp+1]!=v)
        {
            col[sta[tp]]=cnt;
            sum[cnt]+=atm[sta[tp]];
            vis[sta[tp]]=false;
            tp--;
        }
    }
}

queue<int>q;
bool used[500010];

void spfa(int v)
{
    dis[v]=sum[v];
    q.push(v);
    while(!q.empty())
    {
      int u=q.front();
      q.pop();
      used[u]=false;
    for(int j=head[u];j;j=s[j].nxt)
    {
        int g1=s[j].to;
        if(dis[g1]<dis[u]+sum[g1])
        {
            dis[g1]=dis[u]+sum[g1];
            if(!used[g1])
            {
                q.push(g1);
                used[g1]=true;
            }
        }
     }
    }
    return ;
}

int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        add(x,y); 
    }
    for(int i=1;i<=n;i++)
    scanf("%d",&atm[i]);
    for(int i=1;i<=n;i++)
    if(!dfn[i]) tarjan(i);
    tot=0;
    memset(head,0,sizeof(head));
    for(int i=1;i<=m;i++)
    {
        if(col[e[i].fro]!=col[e[i].to])
        add2(col[e[i].fro],col[e[i].to]);
    }
    scanf("%d%d",&S,&T);
    spfa(col[S]);
    for(int i=1;i<=T;i++)
    {
        int x;
        scanf("%d",&x);
        ans=max(ans,dis[col[x]]);
    }
    printf("%d",ans);
    return 0;
}
~~~
本来满心欢喜地提交上去，结果莫名RE第$4,5$两个点。

最初以为是数组大小的问题，然后开大数组还是$RE$.

然后以为是自己程序的问题，结果提交题解上去还是$RE88$分

后面想起好像有个什么**无限栈开关**的东西，$Luogu$这道题貌似没有打开这个开关吧，于是就爆栈空间了？！

别问我为什么会爆，我也不知道，数据范围是$5e5$。

于是同机房的大佬告诉我是这个$tarjan$在递归的时候爆掉的。

### 那么如何处理这个问题呢？

这位[大佬](https://www.luogu.org/space/show?uid=44317)告诉我直接新建立一个栈模拟递归的栈就行了，**避免出现递归函数**。

### 大概就像这样：
（不要在意我的码风）
~~~
stack<int>K;
void tarjan(int v)
{
    dfn[v]=low[v]=++inde;
    sta[++tp]=v;
    vis[v]=true;
    K.push(v);
    while(!K.empty())
    {
      int tmp=K.top();
      for(int j=head[tmp];j;j=e[j].nxt)
    {
		int g1=e[j].to;
        if(!dfn[g1])
        {
            dfn[g1]=low[g1]=++inde;
            vis[g1]=true;
            sta[++tp]=g1;
            K.push(g1);
            break;
        }
    }
     if(tmp==K.top())
     {
       for(int j=head[tmp];j;j=e[j].nxt)
       {
       	int g1=e[j].to;
       	 if(dfn[g1]>dfn[tmp])
       	 low[tmp]=min(low[tmp],low[g1]);
       	 else if(vis[g1])
       	 low[tmp]=min(low[tmp],dfn[g1]);
	   }
    if(low[tmp]==dfn[tmp])
     {
        cnt++;
        while(sta[tp+1]!=tmp)
        {
            col[sta[tp]]=cnt;
            sum[cnt]+=atm[sta[tp]];
            vis[sta[tp]]=false;
            tp--;
        }
     }
     K.pop();
    }
   }
}
~~~
## 至此，已经解决了所有问题！
~~我们有耳朵，欢乐多多~~
## 代码3 （Tarjan+SPFA+栈）$100$分：
~~~
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
#include<stack>
using namespace std;

struct edge{
    int fro,nxt,to;
}e[500010],s[500010];
int tot,head[500010];
int inde,dfn[500010],low[500010];
int sta[500010],tp;
int col[500010],cnt,sum[500010],dis[500010];
int atm[500010];
bool vis[500010];
int n,m,ans;
int S,T;

void add(int x,int y)
{
    e[++tot].to=y;
    e[tot].fro=x;
    e[tot].nxt=head[x];
    head[x]=tot;
}

void add2(int x,int y)
{
    s[++tot].to=y;
    s[tot].nxt=head[x];
    head[x]=tot;
}
stack<int>K;
void tarjan(int v)
{
    dfn[v]=low[v]=++inde;
    sta[++tp]=v;
    vis[v]=true;
    K.push(v);
    while(!K.empty())
    {
      int tmp=K.top();
      for(int j=head[tmp];j;j=e[j].nxt)
    {
		int g1=e[j].to;
        if(!dfn[g1])
        {
            dfn[g1]=low[g1]=++inde;
            vis[g1]=true;
            sta[++tp]=g1;
            K.push(g1);
            break;
        }
    }
     if(tmp==K.top())
     {
       for(int j=head[tmp];j;j=e[j].nxt)
       {
       	int g1=e[j].to;
       	 if(dfn[g1]>dfn[tmp])
       	 low[tmp]=min(low[tmp],low[g1]);
       	 else if(vis[g1])
       	 low[tmp]=min(low[tmp],dfn[g1]);
	   }
    if(low[tmp]==dfn[tmp])
     {
        cnt++;
        while(sta[tp+1]!=tmp)
        {
            col[sta[tp]]=cnt;
            sum[cnt]+=atm[sta[tp]];
            vis[sta[tp]]=false;
            tp--;
        }
     }
     K.pop();
    }
   }
}
queue<int>q;
bool used[500010];

void spfa(int v)
{
    dis[v]=sum[v];
    q.push(v);
    while(!q.empty())
    {
      int u=q.front();
      q.pop();
      used[u]=false;
    for(int j=head[u];j;j=s[j].nxt)
    {
        int g1=s[j].to;
        if(dis[g1]<dis[u]+sum[g1])
        {
            dis[g1]=dis[u]+sum[g1];
            if(!used[g1])
            {
                q.push(g1);
                used[g1]=true;
            }
        }
     }
    }
    return ;
}

int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        add(x,y); 
    }
    for(int i=1;i<=n;i++)
    scanf("%d",&atm[i]);
    for(int i=1;i<=n;i++)
    if(!dfn[i]) tarjan(i);
    tot=0;
    memset(head,0,sizeof(head));
    for(int i=1;i<=m;i++)
    {
        if(col[e[i].fro]!=col[e[i].to])
        add2(col[e[i].fro],col[e[i].to]);
    }
    scanf("%d%d",&S,&T);
    spfa(col[S]);
    for(int i=1;i<=T;i++)
    {
        int x;
        scanf("%d",&x);
        ans=max(ans,dis[col[x]]);
    }
    printf("%d",ans);
    return 0;
}
~~~

---

## 作者：bztMinamoto (赞：0)

一道tarjan缩点+单源最长路的问题

因为每一条道路可以重复走，所以如果存在强连通分量，我们可以遍历此强连通分量。所以我们可以将每一个强连通分量看做一个点，每一个点的权值为此强连通分量可抢劫总金额，即这一个点的权值为其中所有点的权值之和，且只要其中有一个点为酒吧，此强连通分量即可视为酒吧

接下来，在完成缩点的图上求一次单源最长路。在此图上，我们可以将每一个点的权值转化为边的权值，即当x到y存在一条路径时，此路径的权值即为y点可抢劫的总金额。一次spfa即可求出单源最长路（不知道为什么用dijkstra结果wa了两个点）

最后遍历每一个强连通分量，如果是酒吧，就用它的距离更新答案

具体细节看注解，上代码
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#define a(a,b,c) for(int a=b;a<=c;a++)
#define b(a,b,c) for(int a=b;a>=c;a--)
using namespace std;
const int INF=0x3f3f3f3f,N=500050,M=500050;
struct ab{
	int y,z;
};
bool operator < (ab i,ab j)
{
	return i.z<j.z;
}
int ver[M],Next[M],head[N],d[N];
int vc[M],nc[M],hc[M],dc[N],k[N];
int dfn[N],low[N],stack[N],v[N],c[N],f[N];
bool vis[N],vv[N],used[N];
int n,m,tot,tc,t,num,cnt,top,ans,s,p;
inline void add(int x,int y)
{
	ver[++tot]=y,Next[tot]=head[x],head[x]=tot;
}
inline void add_c(int x,int y)//缩点用
{
	vc[++tc]=y,nc[tc]=hc[x],hc[x]=tc;
}
void tarjan(int x)//跑一边tarjan
{
	dfn[x]=low[x]=++num;
	stack[++top]=x,v[x]=1;
	for(int i=head[x];i;i=Next[i])
	{
		int y=ver[i];
		if(!dfn[y])
		{
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else if(v[y]) low[x]=min(low[x],dfn[y]);
	}
	if(low[x]==dfn[x])
	{
		cnt++;int y;
		do{
		y=stack[top--],v[y]=0;
		c[y]=cnt;
		dc[cnt]+=d[y];
		if(vis[y]) vv[cnt]=1;
        //强连通分量的权值为各点的权值之和，并判断此强连通分量中是否存在酒吧
		}while(x!=y);
	}
}
void spfa(int x)
{
//在完成缩点后的图上求出单源最长路
	queue<int> q;
	q.push(x);
	memset(f,0,sizeof(f));
	f[x]=dc[x];
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		used[x]=0;
		for(int i=hc[x];i;i=nc[i])
		{
			int y=vc[i],z=dc[y];
            //点权转化为边权
			if(f[y]<f[x]+z)
			{
				f[y]=f[x]+z;
				if(!used[y]) q.push(y),used[y]=1;
			}
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	a(i,0,m-1)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	a(i,1,n)
	scanf("%d",&d[i]);
	scanf("%d%d",&s,&p);
	a(i,0,p-1)
	{
		int x;
		scanf("%d",&x);
		vis[x]=1;
	}
	a(i,1,n)
	if(!dfn[i]) tarjan(i);
	a(x,1,n)
	for(int i=head[x];i;i=Next[i])
	{
		int y=ver[i];
		if(c[x]!=c[y]) add_c(c[x],c[y]);
	}
	spfa(c[s]);
	a(i,1,cnt)
	if(vv[i]) ans=max(ans,f[i]);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：jins3599 (赞：0)

缩点+spfa.

很容易的发现在图上如果存在环，并且人在环上的话，把环全部走一遍，答案不会变差。

于是我们就可以先缩点，然后对整个缩点后的dag跑一遍最长路。

并且缩点后的一个强连通分量里，一旦有一个酒吧，那么整个连通分量都可以看成酒吧。

于是这道题就被切掉了。代码比较简单。（我因为$N$开大了一位导致MLE了两次...太蠢了。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 500005;

int s , p ,head[N] , a[N] , cnt , n , m;
int b[N];
bool flag[N];
bool check[N];
struct Edge {
	int to , nxt;
}e[N] ,e1[N];

void add(int u , int v) {
	e[++ cnt].to = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}
int head1[N] , cnt1;
void add1(int u , int v) {
	e1[++ cnt1].to = v;
	e1[cnt1].nxt = head1[u];
	head1[u] = cnt1;
}

vector <int> S[N];
int wic[N] , tot;
int idx , dfn[N] , low[N] , st[N] , top , ins[N];
void Tarjan(int now) {
	dfn[now] = low[now] = ++ idx;
	st[++ top] = now;
	ins[now] = 1;
	for(int i = head[now] ; i ; i = e[i].nxt) {
		int v = e[i].to;
		if(!dfn[v]) {Tarjan(v); low[now] = min(low[now] , low[v]);}
		else if(ins[v]) low[now] = min(low[now] , dfn[v]);
	}
	if(dfn[now] == low[now]) {
		int p; tot ++;
		do {
			p = st[top --];
			ins[p] = 0;
			S[tot].push_back(p);
			wic[p] = tot;
		} while(p != now);
	}
}

int dis[N];
bool inq[N];
void Spfa(int s) {
	queue <int> q;
	q.push(s);
	memset(dis , -0x3f , sizeof(dis));
	dis[s] = b[s];
	while(! q.empty()) {
		int now = q.front(); q.pop();
		inq[now] = 0;
		for(int i = head1[now]; i ; i = e1[i].nxt) {
			int v = e1[i].to;
			if(dis[v] < dis[now] + b[v]) {
				dis[v] = dis[now] + b[v];
				if(!inq[v]) q.push(v) , inq[v] = 1;
			}
		}
	}
	int ans = 0;
	for(int i = 1 ; i <= tot ; i ++) if(check[i]) ans = max(ans , dis[i]);
	printf("%d\n" , ans);
}

int main () {
//	freopen("data.txt" , "r" , stdin);
	scanf("%d %d" , &n ,&m);
	while(m --) {
		int u , v; scanf("%d %d" , &u, &v);
		add(u , v);
	}
	for(int i = 1 ; i <= n ; i ++) scanf("%d" , a + i);
	scanf("%d %d" , &s , &p);
	while(p --) {
		int o; scanf("%d" , &o); flag[o] = 1;
	}
	for(int i = 1 ; i <= n ;i ++) if(!dfn[i]) Tarjan(i);
	for(int i = 1 ; i <= tot ; i ++) {
		for(int j = 0 ; j < S[i].size() ; j ++) {
			b[i] += a[S[i][j]];
			if(flag[S[i][j]]) check[i] = 1;
			int now = S[i][j];
			for(int k = head[now] ; k ; k = e[k].nxt) {
				int v = e[k].to;
				if(wic[v] == wic[now]) continue;
				add1(wic[now] , wic[v]);
			}
		}
	}
	
	Spfa(wic[s]);
	return 0;
}

```

---

## 作者：loaky (赞：0)

写挂了n遍的tarjan，凄凄惨惨戚戚，然而被逼无奈之下照着板子改，因为明显可以看出途中是有环的，我们要求的又是一个最长路，因此，首先选择缩点，也就是tarjan把相连通的点看成一个大点，因为点内可以互相到达，所以只用考虑点之外，我们tarjan之后再建一张新图，此时我们就可以再新图上跑最长路了，因为最后只能停在酒吧，枚举每个酒吧位置作为结尾点的最大值！
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
const int maxn=5000000;
int ans,n,m,vis[maxn],uu[maxn],hd[maxn],vv[maxn],head[maxn],k,di[maxn],val[maxn],dis[maxn],s,p,bar[maxn],dfn[maxn],low[maxn],belong[maxn],cnt,ins[maxn],stack[maxn],top,sum,al[maxn];
struct node{
	int nxt,v;
}e[maxn];
void add1(int u,int vi){
	e[++k].v=vi;
	e[k].nxt=head[u];
	head[u]=k;
}
struct nod{
	int nxt,v,w;
}ee[maxn];
void add2(int u,int vi,int wi){
	ee[++k].v=vi;
	ee[k].w=wi;
	ee[k].nxt=hd[u];
	hd[u]=k;
}
void tarjan(int a)
{
    dfn[a]=low[a]=++cnt;
    ins[a]=1;
    stack[++top]=a;
    for(int i=head[a];i;i=e[i].nxt){
        int vi=e[i].v;
        if(!dfn[vi]){
            tarjan(vi);
            low[a]=min(low[a],low[vi]);
        }
        else if(ins[vi])   low[a]=min(low[a],dfn[vi]);
    }
    if(dfn[a]==low[a]){
        sum++;
        while(stack[top+1]!=a){
            belong[stack[top]]=sum;
            al[sum]+=val[stack[top]];
            ins[stack[top--]]=0;
        }
    }
}
queue<int>q;
void spfa(int x){
	dis[x]=0;
	vis[x]=1;
	q.push(x);
	while(!q.empty()){
		int x=q.front();
		q.pop();
		vis[x]=0;
		for(int i=hd[x];i;i=ee[i].nxt){
			int vi=ee[i].v;
			if(dis[vi]<dis[x]+ee[i].w){
				dis[vi]=dis[x]+ee[i].w;
				if(!vis[vi]){
					q.push(ee[i].v);
					vis[ee[i].v]=1;
				}
			}
		}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&uu[i],&vv[i]);
		add1(uu[i],vv[i]);
	}
	for(int i=1;i<=n;i++){
		scanf("%d",&val[i]);
	}
	scanf("%d%d",&s,&p);
	for(int i=1;i<=p;i++){
		scanf("%d",&di[i]);
	}
	for(int i=1;i<=n;i++){
		if(!dfn[i]) tarjan(i);
	}
	for(int i=1;i<=m;i++){
		if(belong[uu[i]]!=belong[vv[i]]){
			add2(belong[uu[i]],belong[vv[i]],al[belong[vv[i]]]);
		}
	}
	add2(0,belong[s],al[belong[s]]);
	spfa(0);
	for(int i=1;i<=p;i++){
		ans=max(ans,dis[belong[di[i]]]);
	}
	printf("%d",ans);
	return 0;
}
```

---


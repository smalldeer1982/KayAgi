# 由乃救爷爷

## 题目背景

大家看过葫芦娃吧？

没看过也没关系，让由乃告诉你吧

 ![](https://cdn.luogu.com.cn/upload/pic/5725.png) 

 ![](https://cdn.luogu.com.cn/upload/pic/5740.png) 

传说明斯克航空航天局里关着两个坦克，strv103b和krv。

 ![](https://cdn.luogu.com.cn/upload/pic/5733.png) 

 ![](https://cdn.luogu.com.cn/upload/pic/5722.png) 

鼠爷不小心打破了明斯克航空航天局，两个坦克逃了出来，从此其他坦克过上了水深火热的生活。

明斯克航空航天局急忙去告诉一个叫做serb的光头，只有YY出七辆图纸车，才能消灭这两个卖头势力。

serbYY出了七个连图纸都没有的车，却被瑞典人从bbs中窥见 。他们摧毁不了这七个YY车，

就把serb和鼠爷抓去。但是这时候七个坦克模型已经建出来了。

她们分别是 T28原型，T100lt，907工程，蟋蟀15，WZ111，FV215b183，FV215b

她们为了消灭卖头势力，救出serb和鼠爷，一个接一个去与卖头势力搏斗。

 ![](https://cdn.luogu.com.cn/upload/pic/5723.png) 

T28原是正面很硬的TD，但装甲在金币弹面前一点用都没有，直接被krv卖头打死。

 ![](https://cdn.luogu.com.cn/upload/pic/5728.png) 

T100lt是隐蔽超好的眼车，却因为没有视野，被103b活活黑死。

 ![](https://cdn.luogu.com.cn/upload/pic/5724.png) 

907工程是铁头，被krv顶牛直接抽包抽死。

 ![](https://cdn.luogu.com.cn/upload/pic/5727.png) 

蟋蟀15会黑枪，却因为辣鸡的转向被krv绕死。

 ![](https://cdn.luogu.com.cn/upload/pic/5729.png) 

WZ111有三百穿，被103b穿侧面一发爆了弹药架。

 ![](https://cdn.luogu.com.cn/upload/pic/5730.png) 

FV215b183有183炮，103b和krv瑟瑟发抖，不敢打她，于是她解救了其他所有坦克。

 ![](https://cdn.luogu.com.cn/upload/pic/5734.png) 

但是自己的兄弟FV215b因为瑞典人的诱惑，决定叛变（因为183OO大），TK了183一发，然后183着火烧死了，结果所有坦克都被103b和krv降服了。

瑞典人把七个坦克还有鼠爷一起给serb，让serb做出两辆最强坦克加入瑞典阵营。serb用尽了他所有的脑洞，做出了两辆车E100WT和T-50-2

 ![](https://cdn.luogu.com.cn/upload/pic/5731.png) 

 ![](https://cdn.luogu.com.cn/upload/pic/5732.png) 

krv和103b看到之后蛤蛤大笑

krv：E100WT，10mm的脸，不被HE糊死才怪

103b：E100WT，灯塔般的隐蔽，不被黑死才怪

krv：T-50-2，这血量，我一炮就可以打死

103b：T-50-2，看是你机动好还是我黑枪准

serb：百运，胶水，让她们看看你们的厉害


## 题目描述

故事还没讲完

krv骑坡卖头，却发现百运凭借优秀的精度炮炮打穿她的观察孔

krv慌了，跑去城市里面伸缩，被百运站桩撸死

strv103b跑去草后黑枪，看见胶水在肉侦，却发现自己根本打不中她，然后就被胶水点亮了，百运一梭子128的ARCR飞了过来

strv103b怂了，准备跑路了，但是还没等到自己切换回行走模式，胶水已经开始断她的腿了，被胶水断死


瑞典车们高呼不可战胜，从此不敢嚣张了


然后serb把百运和胶水加入了WOT

从此
其他坦克过上了更加水深火热的生活


然而你又不玩WOT，这事情不管你什么事啊

然而yql是大家的妹妹，所以这件事很重要：


yql在AK曼哈顿OI，CTSC，APIO之后，开始研究数学题。

由乃在挂了字符串OI，CTSC，APIO之后，开始研究大母神原型。

yql出了个数学题，由乃画出了一个表示大母神的图腾。

然后把这两个合成了一个题：


然而由于未知原因那个题挂掉了。。。

由乃想起来SCOI 2017 电子科技大学出了个卡常的rmq，然后发生了一件很有趣的事情

就是一位姓王的同学凭借奇奇怪怪的常数优化怒草了那个题，还比标程块了233倍

所以由乃也出了个卡常rmq，因为没题出了


## 说明/提示

```cpp
n,m=1000,1s
n,m=1000,1s
n,m=100000,1s
n,m=500000,1s
n,m=1000000,1s
n,m=10000000,5s
n,m=12000000,5s
n,m=15000000,5s
n,m=20000000,5s
```

## 样例 #1

### 输入

```
233 233 233```

### 输出

```
243704637294```

# 题解

## 作者：noip (赞：113)

特技卡常数题

其实这个题考的不是常数优化

是膜法

这样的

你们都会+1-1rmq吧？

不会有关系，因为你听不懂后面我要说啥

但是其实也没关系，因为我都没写过

仔细想想+1-1rmq，那个四毛子的用途？

可以得到这样一个改良算法

分块，大小设为x

预处理每个块两端到块内每个点的前缀max和后缀max

预处理块间ST表

然后查询的时候

比如说我查l，r，这两个分别在块a，b中

然后就是查块a，b之间的rmq，以及l在a块的后缀max和r在b块的前缀max

块大小为logn的时候，这个算法是O( 1 )的

但是
要真的是这样的

那发明+1-1rmq的人岂不是naive？

 ![](https://cdn.luogu.com.cn/upload/pic/5789.png) 

肯定不是

那个算法有一个问题

就是查询的两个点都在同一个块中会出偏差

但是
块大小logn啊

所以复杂度最坏是nlogn

然而我可以微调块大小让你根本没法卡

然后这个题数据随机是不是

设块大小为x

则两个端点同一个块概率为1/x，代价为O( x )

所以可以让x = sqrt( n )因为预处理ST表挺慢的

这样就可以解决了

期望下O( n )的rmq

而且不用笛卡尔树什么的，常数超级小哦~

这个大概是一个不错的rmq算法，跑得又快，常数又小，还好写

重点是没人卡你，卡还不一定卡的住，还要冒着被暴力AC的风险

最后放上183炸鱼图

![](https://cdn.luogu.com.cn/upload/pic/5788.png)


---

## 作者：critnos (赞：67)

**这是一个乱搞做法，也是到现在这道题的第三种做法。**

首先对序列排序，注意要用结构体维护每个数的位置，大概是这样：

```cpp
struct num
{
	int s,w;
	friend bool operator <(const num& qwq,const num& qaq)
	{
		return qwq.s>qaq.s;
	}
}a[20000005];
for(i=0;i<n;i++)
	a[i]=num({read(),i});
sort(a,a+n);
```
然后每次查询的时候，按顺序暴力枚举每个数是否在区间内，如果是则直接返回，，，

就没了

正确性显而易见：一旦搜到第一个在区间内的，那么一定是最大值。

大概长这个样：

```cpp
int ask(int l,int r)
{
	int i;
	for(i=0;a[i].w>r||a[i].w<l;i++);
	return a[i].s;
}
```
下面是对期望时间复杂度的证明：

**本题数据随机**

由于数据随机，所以计算一个长度为 $k$ 的区间的最大值的期望复杂度为 $\dfrac n k$。

先看看所有的连续段的长度：

长度为 $1$：$n$ 个。

长度为 $2$：$n-1$ 个。

……

长度为 $n$：$1$ 个。

总共有 $\dfrac {n\times (n+1)} 2$ 个连续区间，去掉常数为 $n^2$。

计算上面这些区间的总平均次数为：

$$t=n\times \dfrac n 1+(n-1)\times \dfrac n 2+\dots + 1 \times \dfrac n n$$

每个区间平均为：

$$\dfrac t {n^2}$$

化简一下，把上面式子的 $n$ 和下面的 $n$ 抵消：

$$t=\dfrac {n\times \dfrac 1 1+(n-1)\times \dfrac 1 2+\dots + 1 \times \dfrac 1 n} n$$

变成：

$$t=\dfrac {\dfrac n 1+ \dfrac {(n-1)} 2+\dots + \dfrac 1 n} n$$

$$t\le {\dfrac n 1+ \dfrac n 2+\dots + \dfrac n n}$$

得

$$t\le n \log n$$

所以

$$\dfrac t n \le \log n$$

最终的期望时间复杂度为 $\log n$。最重要的是，常数极小。

故而多提交几次可过。

---

## 作者：Kewth (赞：26)

[安利博客-各种 RMQ 的总结](https://kewth.github.io/2019/10/11/RMQ)

询问区间随机的前提下有个 $O(n + q)$ 的在线做法。

考虑分块，设块的大小为 $b$ ， $O(n)$ 预处理每个块的最大值。

那么对于询问 $[l, r]$ ，若该区间跨过了多个块，问题就分为两个部分：

1. 求跨过的块区间的最大值。
2. 求两端点所在零散的块的最大值。

第一个问题就是个子问题，并且数据规模减小到了 $O(\frac{n}{b})$ ，  
为了保证询问 $O(1)$ ，可以使用 ST 表，  
就可以 $O(\frac{n}{b} log\frac{n}{b})$ 进行预处理然后 $O(1)$ 询问。

第二个问题端点所在零散的块是该块的一段前缀或者后缀，  
只需 $O(n)$ 对于每个块预处理前缀最大值和后缀最大值即可 $O(1)$ 询问。

那么若询问区间在同一个块内呢？  
自然是暴力扫，但是这样的复杂度是 $O(b)$ 的。  
但询问区间随机的情况下，不难得出两个端点在同一个块内的概率是 $\frac{b}{n}$ 。  
那么这种情况询问的期望复杂度是 $O(\frac{b^2}{n})$ 的。

总复杂度 $O(n + \frac{n}{b} log\frac{n}{b} + q + q \frac{b^2}{n})$ 。  
当 $b$ 至少为 $O(logn)$ 时，预处理的 $O(\frac{n}{b} log\frac{n}{b})$ 不超过 $O(n)$ 。  
当 $b$ 至多为 $O(\sqrt{n})$ 时，询问的 $O(q \frac{b^2}{n})$ 不超过 $O(q)$ 。  
因此 $b$ 的大小取 $O(logn)$ 到 $O(\sqrt{n})$ 之间即可。

### 毒瘤活动-非随机的扩展

值得注意的是，虽然这个做法的复杂度仅适用于询问区间随机的情况，但是一般不会卡。

来点有意思的娱乐活动，考虑怎么卡掉它，以及怎么防止被出题人卡。

想要卡这个做法就要尽量让询问区间在一个块内，卡成 $O(b)$ 的询问复杂度。  
但在不知道块的大小的情况下，假设给一个区间长 $len$ 的询问，实际块的大小为 $b$ ，  
那么两个端点在同一个块内的概率大概是 $\frac{b-len+1}{b}$ ，期望复杂度就是 $O(\frac{(b-len+1)len}{b})$ 。

现在出题人要在不知道 $b$ 的情况下希望上面的复杂度尽量大，选手要在不知道 $len$ 的情况下希望上面复杂度尽量小。  
~~怎么感觉像博弈论~~

最坏的情况是 $len = \frac{b}{2}$ 的时候，此时询问的期望复杂度为 $O(\frac{b}{4})$ 。  
选手希望预处理和询问的复杂度最大值最小，也就是让它们相等，此时 $b$ 的最优取值大致为 $2\sqrt{\frac{n}{q} logn}$ ，  
这里说是“大致”，是因为为了方便计算将 $O(log \frac{n}{b})$ 看做了 $O(logn)$ 。  
将 $n, q$ 看做同阶的话，上述取值为 $2\sqrt{logn}$ ，此时复杂度为 $O(\frac{n\sqrt{logn}}{2})$ ，  
也就是 $O(n\sqrt{logn})$ ，得出结论，在询问区间非随机的情况下，该算法最优可以做到严格 $O(n\sqrt{logn})$ 。

关键这算法常数小，还好写，取 b 为 $O(\sqrt{logn})$ 的话，复杂度 $O((n + q)\sqrt{logn})$ 在绝大多数情况都足够了。

最后，附本题代码，不知道为什么实践中取 $b$ 为 $\sqrt{n}$ 时跑得比较快。

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
#define debug(...) fprintf(stderr, __VA_ARGS__)

namespace GenHelper {
	unsigned z1, z2, z3, z4, b;
	unsigned rand_() {
		b = ((z1 << 6) ^ z1) >> 13;
		z1 = ((z1 & 4294967294U) << 18) ^ b;
		b = ((z2 << 2) ^ z2) >> 27;
		z2 = ((z2 & 4294967288U) << 2) ^ b;
		b = ((z3 << 13) ^ z3) >> 21;
		z3 = ((z3 & 4294967280U) << 7) ^ b;
		b = ((z4 << 3) ^ z4) >> 12;
		z4 = ((z4 & 4294967168U) << 13) ^ b;
		return (z1 ^ z2 ^ z3 ^ z4);
	}
}; // namespace GenHelper

void ssrand(unsigned x) {
    using namespace GenHelper;
    z1 = x;
    z2 = unsigned((~x) ^ 0x233333333U);
    z3 = unsigned(x ^ 0x1234598766U);
    z4 = (~x) + 51;
}

int read() {
    using namespace GenHelper;
    int A = rand_() & 32767;
    int B = rand_() & 32767;
    return A * 32768 + B;
}

inline int input() { int x; scanf("%d", &x); return x; }

const int maxn = 20000005, minb = 4400, maxb = 4475;
int a[maxn + maxb];
int highbit[maxn + maxb];
int st[maxn / minb][maxb];
int pre[maxn / minb][maxb];
int suf[maxn / minb][maxb];

inline void chkmax(int &x, int y) {
	if(y > x) x = y;
}

int main() {
	int n = input(), q = input(), s = input();
	ssrand(unsigned(s));
	int b = int(sqrt(n));
	int B = (n - 1) / b;

	for(int i = 0; i < n; i ++) {
		a[i] = read();
		chkmax(st[i / b][0], a[i]);
	}

	for(int i = B; i >= 0; i --)
		for(int k = 1; i + (1 << k) - 1 <= B; k ++)
			st[i][k] = std::max(st[i][k - 1], st[i + (1 << (k - 1))][k - 1]);

	for(int i = 0; i <= B; i ++) {
		int be = i * b;
		pre[i][0] = a[be];
		for(int k = 1; k < b; k ++)
			pre[i][k] = std::max(pre[i][k - 1], a[be + k]);
		suf[i][b - 1] = a[be + b - 1];
		for(int k = b - 2; k >= 0; k --)
			suf[i][k] = std::max(suf[i][k + 1], a[be + k]);
	}

	for(int k = 0; (1 << k) <= n << 1; k ++)
		for(int i = 1 << k; i < (1 << (k + 1)); i ++) {
			if(i > n) break;
			highbit[i] = k;
		}
	unsigned long long ans = 0;
	while(q --) {
		int l = read() % n;
		int r = read() % n;
		if(l > r)
			std::swap(l, r);
		int L = l / b, R = r / b;

		int now = 0;
		if(L == R)
			for(int i = l; i <= r; i ++)
				chkmax(now, a[i]);
		else {
			chkmax(now, suf[L][l % b]);
			chkmax(now, pre[R][r % b]);
			int len = R - L - 1;
			int k = highbit[len];
			if(len) {
				chkmax(now, st[L + 1][k]);
				chkmax(now, st[R - (1 << k)][k]);
			}
		}

		ans += unsigned(now);
	}

	printf("%llu\n", ans);
}
```
如有疏漏的地方，欢迎指正。

---

## 作者：w33z8kqrqk8zzzx33 (赞：18)

卡个锤子的常啊，这明明是数学题（大雾

首先，观察到数据随机。数据随机 = 用脚造数据，所以考虑概率性乱搞。

假设给定的序列是一个排列，那么如果我们对排列求逆，那么 $[l,r]$ 的 rmq 位置就是逆排列里的第一个在 $[l,r]$ 里面的元素。直接模拟即可。

下面来证明时间复杂度。对于一个随机排列，任意一个元素在 $[l,r]$ 里面的可能性是 $\frac{r-l+1}{n}$。我们求一次 rmq 期望需要的时间等于期望第一个在 $[l,r]$ 里的位置在哪里。然后求这个期望很简单，把这个可能性看作完全随机：

$$E=1+(1-\frac{r-l+1}{n})E$$
$$E=\frac{n}{r-l+1}$$

那么现在时间复杂度也就退化成

$$\sum\frac{n}{r_i-l_i+1}$$

显然 $r_i-l_i$ 等于 $x$ 的概率就是 $\frac{n-x}{\binom{n}{2}}=2(\frac{1}{n-1}-\frac{x}{n(n-1)})$。展开上面来求期望：

$$2\sum_{x=0}^{n-1}\frac{n}{x+1}(\frac{1}{n-1}-\frac{x}{n(n-1)})$$
$$2\sum_{x=0}^{n-1}\frac{\frac{n}{n-1}}{x+1}-\frac{\frac{x}{n-1}}{x+1}$$

注意 $n$ 很大的时候 $\frac{n}{n-1}$ 可以看作为 $1$。

$$2\sum_{x=0}^{n-1}\frac{1-\frac{x}{n-1}}{x+1}$$

瞎做一些“大概”来简化。

$$2\sum_{x=1}^{n}\frac{1-\frac{x}{n}}{x}$$
$$2\sum_{x=1}^{n}\frac{1}{x}-\frac{1}{n}$$
$$-2+2\sum_{x=1}^{n}\frac{1}{x}$$
$$\approx-2+2(\ln n+\gamma)$$
$$=O(\log n)$$

于是得到 $O(n\log n)$ 时间，$O(n)$ 空间的一个~~废物~~，但是可以过。

```cpp
namespace GenHelper
{
    unsigned z1,z2,z3,z4,b;
    unsigned rand_()
    {
    b=((z1<<6)^z1)>>13;
    z1=((z1&4294967294U)<<18)^b;
    b=((z2<<2)^z2)>>27;
    z2=((z2&4294967288U)<<2)^b;
    b=((z3<<13)^z3)>>21;
    z3=((z3&4294967280U)<<7)^b;
    b=((z4<<3)^z4)>>12;
    z4=((z4&4294967168U)<<13)^b;
    return (z1^z2^z3^z4);
    }
}
void Srand(unsigned x)
{using namespace GenHelper;
z1=x; z2=(~x)^0x233333333U; z3=x^0x1234598766U; z4=(~x)+51;}
int read()
{
    using namespace GenHelper;
    int a=rand_()&32767;
    int b=rand_()&32767;
    return a*32768+b;
}

int n;
int ar[20000007];
pii cp[20000007];
int iv[20000007];

int rmq(int l, int r) {
	if(l > r) swap(l, r);
	rep(i, n) if(l <= iv[i] && iv[i] <= r) return ar[iv[i]];
	return 0;
}

signed main() {
    int m, s; cin >> n >> m >> s;
    Srand(s);
    rep(i, n) ar[i] = read(), cp[i].fi = -ar[i], cp[i].se = i;
    sort(cp, cp+n);
    rep(i, n) iv[i] = cp[i].se;
    unsigned long long ans = 0;
    rep(i, m) ans += rmq(read() % n, read() % n);
    cout << ans << endl;
}
```

---

## 作者：t0vd (赞：18)

有一种做法：构笛卡尔树，每次询问暴力在笛卡尔树中从上往下找最大值，实测随机数据下1.6s左右跑出。

构笛卡尔树的单调栈也只要开几十就够了，空间在256MB以内。

```cpp
#include<cstdio>

const int maxn=20000010,maxs=100;
int N,*val,ls[maxn],rs[maxn],stk[maxs],top,root;
void init(int n, int m, int*a)
{
    // initialize the program
    N=n;val=a;
    for(int i=0;i<n;i++){
        while(top&&a[stk[top]]<=a[i])ls[i]=stk[top--];
        rs[stk[top]]=i;stk[++top]=i;
    }
    root=stk[1];
}

int query(int l, int r)
{
    // return the maximum value in a[l, r]
    int x=root;
    for(;;x=(r<x?ls:rs)[x])if(l<=x&&x<=r)return val[x];
}

// -----

namespace GenHelper
{
    unsigned z1,z2,z3,z4,b;
    unsigned rand_()
    {
        b=((z1<<6)^z1)>>13;
        z1=((z1&4294967294U)<<18)^b;
        b=((z2<<2)^z2)>>27;
        z2=((z2&4294967288U)<<2)^b;
        b=((z3<<13)^z3)>>21;
        z3=((z3&4294967280U)<<7)^b;
        b=((z4<<3)^z4)>>12;
        z4=((z4&4294967168U)<<13)^b;
        return (z1^z2^z3^z4);
    }
}
void srand(unsigned x)
{
    using namespace GenHelper;
    z1=x; z2=(~x)^0x233333333U; z3=x^0x1234598766U; z4=(~x)+51;
}
int read()
{
    using namespace GenHelper;
    int a=rand_()&32767;
    int b=rand_()&32767;
    return a*32768+b;
}
int a_[20000001];
int main(){
    int n,m,s;
    unsigned long long ans=0;
    scanf("%d%d%d",&n,&m,&s);
    srand(s);
    for(int i=0;i<n;i++)a_[i]=read();
    init(n,m,a_);
    for(int i=0,l,r;i<m;i++)l=read()%n,r=read()%n,ans+=query(l<r?l:r,l>r?l:r);
    printf("%lld\n",ans);
}
```

---

## 作者：Register_int (赞：11)

科技选手用阉割版四毛子过了这题。目前这玩意好像还没有名字，姑且叫他二毛子。

首先还是分块，块长为 $B=\log n$。块间建 st 表，时空复杂度为 $O(\frac nB\log\frac nB)=O(n)$。如果一个询问的左右端点在不同块，必然可以将其拆成 块后缀+整块+前缀 的形式。预处理出每个块的前后缀最大值即可 $O(1)$ 查询。那如果两个端点在同一块块内呢？

考虑原版四毛子是怎么处理的。得益于 +1-1 RMQ 优美的性质，我们可以预处理出所有本质不同的序列的最大值 **位置**。而对于一般的序列，我们也可以找到类似的指标。

不妨来考虑所有可能成为最大值的位置。为了方便预处理，我们考虑块内一个 $[1,r]$ 的前缀。对于它的任意后缀，可能成为最大值的位置只有可能是 **后缀最大值** 出现的位置。这里后缀最大值位置定义为所有满足 $a_l>\max_{l<i\le r}a_i$ 的 $l$。

然后我们把每个后缀最大值的位置 $b_1,b_2,\cdots,b_k$ 拉下来，可以得到两个性质：

- 对于所有 $i=1\sim k$，$a_{b_i}>\max_{b_i<j\le r}a_j$。
- 对于所有 $i=1\sim k-1$，$a_{b_i}>a_{b_{i+1}}$。

可能成为最大值的位置构成了一个单调递减的子序列，所以当前后缀的最大值，就是该子序列在后缀里的第一个数，也就是：

- 对于所有 $l=1\sim r$，$\max_{l\le i\le r}a_i$ 的位置为 $\min_{b_i\ge l} b_i$。

可以发现，最大值的位置正好是前缀单调栈。我们可以使用单调递减的单调栈扫一遍进行预处理。由于块长 $\log n$，完全可以将单调栈位置进行二进制压位。查询时可以通过位运算删掉 $<l$ 的位置，再计算 lowbit 得到答案位置。这部分的时间复杂度也是 $O(n)-O(1)$ 的，可以通过。

值得注意的是这算法偏序了一般的四毛子算法，在常数和码量上都更胜一筹，实用性也没的说。另外，由于块长 $\log n$ 的特性，完全可以将块长设为 $64$ 之类的整数，这样求块的编号等都可以用位移完成。实测跑的非常快。

最后来说下这个名字的含义。四毛子由建笛卡尔树、拍欧拉序、分块建 st 表，压位预处理组成。本算法知保留了最后两个部分，因此叫二毛子算法。~~很厉害吧！~~

~~啊啊啊这好像是唯一一篇确定性算法啊你们这些随机化批！！！~~

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef unsigned uint;
typedef unsigned long long ull;

const int MAXN = 2e7 + 10;
const int MAXM = 3.2e5 + 10;

uint _z1, _z2, _z3, _z4, _b;

inline 
void srand(uint x) {
    _z1 = x, _z2 = ~x ^ 0x233333333u;
    _z3 = x ^ 0x1234598766U, _z4 = ~x + 51;
}

inline 
uint _rand() {
    _b = (_z1 ^ _z1 << 6) >> 13, _z1 = _b ^ (_z1 & 4294967294u) << 18;
    _b = (_z2 ^ _z2 << 2) >> 27, _z2 = _b ^ (_z2 & 4294967288u) << 2;
    _b = (_z3 ^ _z3 << 13) >> 21, _z3 = _b ^ (_z3 & 4294967280u) << 7;
    _b = (_z4 ^ _z4 << 3) >> 12, _z4 = _b ^ (_z4 & 4294967168u) << 13;
    return _z1 ^ _z2 ^ _z3 ^ _z4;
}

inline 
int get() {
    int a = _rand() & 32767, b = _rand() & 32767;
    return a << 15 | b;
}

#define l(i) ((i - 1) << 6 | 1)
#define r(i) (i << 6)
#define bel(i) (i + 63 >> 6)

int n, m, a[MAXN], len, tot, lgn;

int f[19][MAXM], pre[MAXN], suf[MAXN];

ull val[MAXN]; int s[30], top;

inline 
void build() {
    len = 64, tot = bel(n), lgn = __lg(tot);
    for (int i = 1; i <= tot; i++) {
        pre[l(i)] = a[l(i)], suf[r(i)] = a[r(i)];
        for (int j = l(i) + 1; j <= r(i); j++) pre[j] = max(pre[j - 1], a[j]);
        for (int j = r(i) - 1; j >= l(i); j--) suf[j] = max(suf[j + 1], a[j]);
        for (int j = l(i); j <= r(i); j++) f[0][i] = max(f[0][i], a[j]);
    }
    for (int j = 0; j < lgn; j++) {
        for (int i = 2 << j; i <= tot; i++) {
            f[j + 1][i] = max(f[j][i - (1 << j)], f[j][i]);
        }
    }
    for (int i = 1; i <= tot; i++) {
        top = 0;
        for (int j = l(i); j <= r(i); j++) {
            if (j > l(i)) val[j] = val[j - 1];
            for (; top && a[j] >= a[s[top]]; val[j] ^= 1ull << s[top--] - l(i));
            s[++top] = j, val[j] |= 1ull << j - l(i);
        }
    }
}

inline 
int query(int ql, int qr) {
    int p = bel(ql), q = bel(qr);
    if (p == q) return a[ql + __builtin_ctzll(val[qr] >> ql - l(p))];
    int ans = max(suf[ql], pre[qr]);
    if (p + 1 < q) {
        int k = __lg(q - p - 1);
        ans = max(ans, f[k][p + (1 << k)]);
        ans = max(ans, f[k][q - 1]);
    }
    return ans;
}

uint seed; ull ans;

int main() {
    scanf("%d%d%u", &n, &m, &seed), srand(seed);
    for (int i = 1; i <= n; i++) a[i] = get(); build();
    for (int ql, qr, i = 0; i < m; i++) {
        ql = get() % n + 1, qr = get() % n + 1;
        if (ql > qr) swap(ql, qr);
        ans += query(ql, qr); 
    }
    printf("%llu", ans);
}
```

---

## 作者：Memory_of_winter (赞：8)

[我的博客](https://www.cnblogs.com/Memory-of-winter/p/10228757.html)

**题目大意：**有$n(n\leqslant2\times10^7)$个数，$m(m\leqslant2\times10^7)$个询问，每次询问问区间$[l,r]$中的最大值。保证数据随机

**题解：**分块，处理出每个元素块中前缀最大值和后缀最大值，并且处理出整块的区间最大值（用$ST$表），然后似乎就可以$O(1)$求区间最大值啦！

然而发现若$l,r$在同一块中就会出锅，那就直接暴力查询（数据随机）

我的代码跑的极慢，大概是写的丑吧



**C++ Code：**

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

namespace GenHelper
{
    unsigned z1,z2,z3,z4,b;
    unsigned rand_()
    {
    b=((z1<<6)^z1)>>13;
    z1=((z1&4294967294U)<<18)^b;
    b=((z2<<2)^z2)>>27;
    z2=((z2&4294967288U)<<2)^b;
    b=((z3<<13)^z3)>>21;
    z3=((z3&4294967280U)<<7)^b;
    b=((z4<<3)^z4)>>12;
    z4=((z4&4294967168U)<<13)^b;
    return (z1^z2^z3^z4);
    }
}
unsigned RAND;
void srand(unsigned x)
{using namespace GenHelper;
z1=x; z2=(~x)^0x233333333U; z3=x^0x1234598766U; z4=(~x)+51;}
int read()
{
    using namespace GenHelper;
	static int a, b;
    a=rand_()&32767;
    b=rand_()&32767;
    return a << 15 | b;
}

#define maxn 20000010
#define M 13
const int BSZ = 4480, BNUM = maxn / BSZ + 10;
int n, m, s[maxn];
unsigned long long ans;

int Lmax[maxn], Rmax[maxn];
int L[BNUM], R[BNUM], bel[maxn];

int ST[M + 1][BNUM], LG[BNUM];
inline int query(int l, int r) {
	if (l >= r) return 0;
	static int t; t = LG[r - l];
	return std::max(ST[t][l], ST[t][r - (1 << t)]);
}

int main() {
	scanf("%d%d%u", &n, &m, &RAND); srand(RAND);
	for (int i = 1; i <= n; ++i) {
		s[i] = read();
		bel[i] = i / BSZ + 1;
	}

	const int B = bel[n];
	LG[0] = -1; for (int i = 1; i <= B; ++i) LG[i] = LG[i >> 1] + 1;
	for (int i = 1; i <= B; ++i) {
		L[i] = (i - 1) * BSZ;
		R[i] = L[i] + BSZ - 1;
	}
	L[1] = 1, R[B] = n;
	for (int i = 1, now = 1, last = 0; i <= n; ++i) {
		Lmax[i] = last = std::max(s[i], last);
		if (i >= R[now]) ST[0][now] = Lmax[i], last = 0, ++now;
	}
	for (int i = n, now = B, last = 0; i; --i) {
		Rmax[i] = last = std::max(s[i], last);
		if (i <= L[now]) last = 0, --now;
	}
	for (int i = 1, pw = 1; i <= M; ++i, pw <<= 1) {
		for (int j = 1; j <= B; ++j) ST[i][j] = std::max(ST[i - 1][j], ST[i - 1][std::min(j + pw, B)]);
	}

	while (m --> 0) {
		int l = read() % n + 1, r = read() % n + 1;
		if (l > r) std::swap(l, r);
		const int lb = bel[l], rb = bel[r];
		if (lb != rb) {
			ans += std::max(std::max(Rmax[l], Lmax[r]), query(lb + 1, rb));
		} else {
			static int res; res = 0;
			for (int i = l; i <= r; ++i) res = std::max(res, s[i]);
			ans += res;
		}
	}
	printf("%llu\n", ans);
	return 0;
}

```



---

## 作者：STPGUY (赞：8)

###### 蒟蒻我不会什么高级玩意儿（~~学不懂~~）
就试着写了一下分块（~~第一次~~）

emmmmmmmmmmmmm

大概思路呢就是把一定范围的数看成一个块

![](https://cdn.luogu.com.cn/upload/image_hosting/4bn2icp6.png)
像这个样子

对于跨块的询问就用ST表维护即可

但是总有L, R不能跨越完整的块

所以我们还需要维护每个块内每一个点的前缀与后缀

![](https://cdn.luogu.com.cn/upload/image_hosting/7cwm8i2c.png)

就像l到a,b到r，就要用后缀和前缀；

那么l到r的答案就是max(ST[l][log2(r - 1)], ST[r - log2(r - l)][log2(r - l)], front[r], back[l]), 也就是一个O(1)的查询了；

但是
### 但是
## 但是
如果l和r在一个块内
![](https://cdn.luogu.com.cn/upload/image_hosting/rkkvqt9v.png)
像这样，那岂不是就废了！

因为我们只维护了以块为单位的最值

那怎么办呐？

不要看我，我也不知道啊（~~暴力~~）

于是

1.求块的编号
```cpp
inline Ull Ceil(Ull X)
{
    return (X + KUAI - 1) / KUAI;
}
```

2.ST初始化， 前缀后缀初始化
```cpp
inline void init()
{
    int New = Ceil(N);
    int LC = log2(New);
    for (int j = 1; j <= LC; ++j)
        for (int i = 1; i <= New - (1 << j) + 1; ++i)
            ST[i][j] = max(ST[i][j - 1], ST[i + (1 << (j - 1))][j - 1]);//ST表常规操作
    
    for (int i = 1; i <= N; ++i)
        if (i % KUAI != 1)F[i] = max(F[i - 1], A[i]);
        else F[i] = A[i];//F[]是前缀数组，这里可以看出来一个块是一个这样的区间[1 + 7500K, 7500(K + 1)),K属于整数集
    for (int i = N; i >= 1; --i)
        if (i % KUAI)B[i] = max(B[i + 1], A[i]);
        else B[i] = A[i];
}
```
3.查询操作
```cpp
//写得有点冗杂，emm  可以优化一下的（懒～～）
        Ull X = read() % N + 1, Y = read() % N + 1;
        Ull L = min(X, Y), R = max(X, Y);
        Ull L2 = Ceil(L), R2 = Ceil(R);//L2，R2分别是L，R所在的块
        Ull MAXX = max(B[L], F[R]);
        if (R2 == L2)Ans += Work(L, R);//如果是一个块就暴力，暴力，暴力
        else if (R2 - L2 == 1)Ans += MAXX;//下面有图解的
        else
        {
            Ull C = log2(R2 - L2 - 1);
            Ull MAX = max(ST[L2 + 1][C], ST[R2 - (1 << C)][C]);//用ST表求块的编号为L2 + 1 到 R2 - 1的值
            Ans += max(MAX, MAXX);
        }
```
这里还有一个小问题，那就是l,r相邻的两块
![](https://cdn.luogu.com.cn/upload/image_hosting/qtfm991w.png)
就直接查询l的后缀和r的前缀啦

嗯还有就是cmath的头文件应该是有一个函数叫 log2() 的，
用不了的话用换底公式处理一下，以下代码是用换底公式处理的
# CODETIME
```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#define KUAI 7500

namespace GenHelper
{
    unsigned z1,z2,z3,z4,b;
    unsigned rand_()
    {
        b = ((z1 << 6) ^ z1) >> 13;
        z1 = ((z1 & 4294967294U) << 18) ^ b;
        b = ((z2 << 2) ^ z2) >> 27;
        z2 = ((z2 & 4294967288U) << 2) ^ b;
        b = ((z3 << 13) ^ z3) >> 21;
        z3 = ((z3 & 4294967280U) << 7) ^ b;
        b = ((z4 << 3) ^ z4) >> 12;
        z4 = ((z4 & 4294967168U) << 13) ^ b;
        return (z1 ^ z2 ^ z3 ^ z4);
    }
}

void srand(unsigned x)
{
    using namespace GenHelper;
    z1 = x;
    z2 = (~x) ^ 0x233333333U;
    z3 = x ^ 0x1234598766U;
    z4 = (~x) + 51;
}

int read()
{
    using namespace GenHelper;
    int a = rand_() & 32767;
    int b = rand_() & 32767;
    return a * 32768 + b;
}

typedef long long ll;
typedef unsigned long long  Ull;

const int Maxn = 2e5 + 5000;
int N, M, S;
Ull A[Maxn * 100], ST[Maxn][20], Ans;
Ull F[Maxn * 100], B[Maxn * 100];

inline Ull min(Ull X, Ull Y){return X < Y ? X : Y;}
inline Ull max(Ull X, Ull Y){return X > Y ? X : Y;}

inline Ull Ceil(Ull X)
{
    return (X + KUAI - 1) / KUAI;
}

inline void init()
{
    int New = Ceil(N);
    int LC = log(New)/log(2);
    for (int j = 1; j <= LC; ++j)
        for (int i = 1; i <= New - (1 << j) + 1; ++i)
            ST[i][j] = max(ST[i][j - 1], ST[i + (1 << (j - 1))][j - 1]);
    
    for (int i = 1; i <= N; ++i)
        if (i % KUAI != 1)F[i] = max(F[i - 1], A[i]);
        else F[i] = A[i];
    for (int i = N; i >= 1; --i)
        if (i % KUAI)B[i] = max(B[i + 1], A[i]);
        else B[i] = A[i];
}

inline Ull Work(Ull L, Ull R)
{
    Ull Maxn(A[L]);
    for (Ull i = L; i <= R; ++i)Maxn = max(Maxn, A[i]);
    return Maxn;
}

int main()
{
    scanf("%d %d %d", &N, &M, &S);
    srand(S);
    for (int i = 1, j(1); i <= N; ++i, j = Ceil(i))
    {
        A[i] = read();
        ST[j][0] = max(A[i], ST[j][0]);
    }
    init();
    while (M--)
    {
        Ull X = read() % N + 1, Y = read() % N + 1;
        Ull L = min(X, Y), R = max(X, Y);
        Ull L2 = Ceil(L), R2 = Ceil(R);
        Ull MAXX = max(B[L], F[R]);
        if (R2 == L2)Ans += Work(L, R);
        else if (R2 - L2 == 1)Ans += MAXX;
        else
        {
            Ull C = log(R2 - L2 - 1) / log(2);
            Ull MAX = max(ST[L2 + 1][C], ST[R2 - (1 << C)][C]);
            Ans += max(MAX, MAXX);
        }
        
    }
    printf("%lld\n", Ans);
}
```

如果我有哪里写的不对或者说的不对的，欢迎大家私信哦

#### 再见lião

---

## 作者：cirnovsky (赞：6)

## 题意简述

给定序列，求每次询问区间的RMQ。

## 题解

不带修的RMQ我们一般使用的是ST表求。但这道题ST表 $\Theta(n\log n)$ 的空间当场去世。

我们考虑把序列分个块儿。由于查询的区间不一定会完全覆盖完一个块儿，所以我么需要求出每个块儿中的前/后缀最大值，然后用ST表搞出整个块儿的最大值。

但是如果 $l,r$ 在同一个块儿内的话就会出问题，所以当查询区间的两端点在同一个块儿内的时候我们就直接暴力查询。

```cpp
const int N = 2e7 + 5;
const int SQN = 4500 + 5;
const int LGSQN = 10 + 5;
int n, m, s, block = 7500;
__uint64 f[SQN][LGSQN], a[N];
__uint64 ans, cpy[N], pas[N];

__uint64 get(__uint64 x) {
	return (x + block - 1) / block;
}

__uint64 ret(__uint64 l, __uint64 r) {
	__uint64 res = a[l];
	for (__uint64 i = l; i <= r; ++i) res = max(res, a[i]);
	return res;
}

signed main() {
	read(n, m, s);
	_srand(s);
	for (int i = 1, j = 1; i <= n; ++i, j = get(i)) {
		a[i] = _read();
		f[j][0] = max(a[i], f[j][0]);
	}
	int mot = get(n);
	int fck  = log2(mot);
	for (int j = 1; j <= fck; ++j)
		for (int i = 1; i <= mot - (1 << j) + 1; ++i)
			f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
	for (int i = 1; i <= n; ++i)
		if (i % block != 1) pas[i] = max(pas[i - 1], a[i]);
		else pas[i] = a[i];
	for (int i = n; i >= 1; --i)
		if (i % block) cpy[i] = max(cpy[i + 1], a[i]);
		else cpy[i] = a[i];
	for (int i = 0; i < m; ++i) {
		__uint64 x = _read() % n + 1;
		__uint64 y = _read() % n + 1;
		if (x > y) swap(x, y);
		__uint64 l = get(x), r = get(y);
		__uint64 MAX = max(cpy[x], pas[y]);
		if (l == r) ans += ret(x, y);
		else if (r - l == 1) ans += MAX;
		else {
			__uint64 k = log2(r - l - 1);
			__uint64 t = max(f[l + 1][k], f[r - (1 << k)][k]);
			ans += max(MAX, t);
		}
	}
	write(io_l, ans);
}
```

---

## 作者：fly_me_2_the_moon (赞：5)

显而易见

裸st表不mle才鬼

那么我们自然想到一种奇妙的算法—笛卡尔树

好

没了

笛卡尔树板子题

ps：你会发现这个美妙的随机数据直接从根往下遍历巨快无比，压根不用求lca，~~分分钟吊打什么分块rmq~~
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace GenHelper
{
    unsigned z1,z2,z3,z4,b;
    unsigned rand_()
    {
    b=((z1<<6)^z1)>>13;
    z1=((z1&4294967294U)<<18)^b;
    b=((z2<<2)^z2)>>27;
    z2=((z2&4294967288U)<<2)^b;
    b=((z3<<13)^z3)>>21;
    z3=((z3&4294967280U)<<7)^b;
    b=((z4<<3)^z4)>>12;
    z4=((z4&4294967168U)<<13)^b;
    return (z1^z2^z3^z4);
    }
}
void srand(unsigned x)
{using namespace GenHelper;
z1=x; z2=(~x)^0x233333333U; z3=x^0x1234598766U; z4=(~x)+51;}
int read()
{
    using namespace GenHelper;
    int a=rand_()&32767;
    int b=rand_()&32767;
    return a*32768+b;
}
int n,m,s;
unsigned long long sum;
const int maxn=20000005;
int a[maxn];
int fa[maxn],ls[maxn],rs[maxn];
int build()
{
	stack<int> st;
	int rt,last;
	for(int i=1;i<=n;++i)
	{
		last=0;
		while(!st.empty())
		{
			if(a[st.top()]>a[i])
			{
				rt=st.top();
				if(rs[rt])
				{
					fa[rs[rt]]=i;
					ls[i]=rs[rt];
				}
				rs[rt]=i;
				fa[i]=rt;
				break;
			}
			last=st.top(); st.pop();
		}
		if(st.empty()&&last)
		{
			fa[last]=i;
			ls[i]=last;
		}
		st.push(i);
	}
	while(!st.empty())	rt=st.top(), st.pop();
	return rt;
}

int query(int root,int l,int r)
{
	while(root<l||root>r)
		root= root<l? rs[root]:ls[root];
	return root;
}
int main()
{
	cin>>n>>m>>s;
	srand(s);
	for(int i=1;i<=n;i++)
	a[i]=read();
	int root=build();
	int l,r;
	for(int i=1;i<=m;i++)
	{
		l=read()%n+1,r=read()%n+1;
		if(l>r)
		swap(l,r);
		sum+=a[query(root,l,r)];
	}
	cout<<sum;
	return 0;
}
```


---

## 作者：cyn2006 (赞：4)

**~~内存能开1G吗~~**

我提供一种内存$\geqslant 1G$但时间比较优的方法

也就是所谓的$O(n)$预处理，$O(1)$单次查询的$rmq$

楼上已经提到了$Fast$的笛卡尔树

我来解释一下：**笛卡尔树**是一种特定的二叉树数据结构，它具有堆的有序性，中序遍历可以输出原数列。

[详细介绍请转门找度娘](https://baike.baidu.com/item/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/7579802?fr=aladdin)

我们可以发现一个非常优美的性质，即建一珂如下的笛卡尔树：当$N=0$，它是一棵空树，否则它的根节点是$A$中的一个最小元素$A_i$（并以这个最小元素的下标i标记），而左右子树分别是$A_1-A_{i-1}$和$A_{i+1}-A_{n}$的一棵笛卡尔树。

此时询问$L$到$R$的区间最小值，等同于询问$A$中编号为$lca(L,R)$的数（这里我们钦定$lca$指笛卡尔树里的$lca$）

求$lca$算法有：树剖、$Tarjan$、$\pm1rmq$、倍增$\ldots \ldots$

我这里选用$O(n)$预处理，离线$O(q)$查询的$Tarjan$，题解一大堆，也请转门找度娘

这样就能在$O(n+q)$里求出$LCA$，再累加即可

~~不过Tarjan和rmq内存太大了~~

话讲到这里，如何求区间最大值

用$2\times 10^9$去减就可以了！~~（你当我傻吗？）~~

由此，我们得到了$O(n+q)$完成区间最大值的离线算法。（不过luogu内存小，还是过不了，MLE）

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define un unsigned
#define ull un ll
#define re register
#define rt re int
template<typename T>inline void read(T&x) {
    char ch=getchar();
    x=0;
    bool f=0;
    for(; ch<'0'||ch>'9'; ch=getchar())if(ch=='-')f=1;
    for(; ch>='0'&&ch<='9'; x=(x<<1)+(x<<3)+(ch^48),ch=getchar());
    if(f)x=-x;
}
template<typename T>inline void write(T x) {
    if(x<0)x=-x,putchar('-');
    if(x>9)write(x/10);
    putchar(x%10+48);
}
template<typename T>inline void writeln(T x) {
    write(x),putchar('\n');
}
const int N=2e6+5;
struct node {
    int to,next;
} e[N<<1];
int fa[N],sta[N>>7],top=0,root,Ecnt,Enum;
int head[N],vis[N],qhead[N];
ull a[N],an[N],ans;
int n,m,s;
// Tarjan + LCA
struct Que {
    int to,next,lca;
} q[N<<1];
// build the tree
inline void build() {
    memset(fa,0,sizeof(fa));
    memset(vis,0,sizeof(vis));
    top=0;
    for(int i=1; i<=n; i++) {
        int k=top;
        for(; k&&a[sta[k]]>a[i]; k--);
        if(k)fa[i]=sta[k];
        if(k<top)fa[sta[k+1]]=i;
        sta[++k]=i;
        top=k;
    }
    root=sta[1];
}
inline void add(int u,int v) {
    e[++Ecnt]=(node) {v,head[u]},head[u]=Ecnt;
}
inline void addq(int u,int v) {
    q[++Enum]=(Que) {v,qhead[u]},qhead[u]=Enum;
}
inline int get(register int x){return fa[x]==x?x:fa[x]=get(fa[x]);}
//Tarjan LCA
inline void dfs(int x) {
    fa[x]=x;
    vis[x]=1;
    for(int k=head[x]; k; k=e[k].next)
        if(!vis[e[k].to]) {
            dfs(e[k].to);
            fa[e[k].to]=x;
        }
    for(int k=qhead[x]; k; k=q[k].next)
        if(vis[q[k].to]) {
            q[k].lca=get(q[k].to);
            if(k&1)
                q[k+1].lca=q[k].lca;
            else
                q[k-1].lca=q[k].lca;
        }
}
namespace GenHelper {
    unsigned z1,z2,z3,z4,b;
    unsigned rand_() {
        b=((z1<<6)^z1)>>13;
        z1=((z1&4294967294U)<<18)^b;
        b=((z2<<2)^z2)>>27;
        z2=((z2&4294967288U)<<2)^b;
        b=((z3<<13)^z3)>>21;
        z3=((z3&4294967280U)<<7)^b;
        b=((z4<<3)^z4)>>12;
        z4=((z4&4294967168U)<<13)^b;
        return (z1^z2^z3^z4);
    }
}
inline void sran(unsigned x) {
    using namespace GenHelper;
    z1=x;
    z2=(~x)^0x233333333U;
    z3=x^0x1234598766U;
    z4=(~x)+51;
}
inline int rd() {
    using namespace GenHelper;
    int a=rand_()&32767;
    int b=rand_()&32767;
    return a*32768+b;
}
//function main
int main() {
    int cas=1;
    for(; cas--;) {
        read(n);
        read(m);
        read(s);
        sran(s);
        Ecnt=Enum=0;
        memset(head,0,sizeof(head));
        memset(qhead,0,sizeof(qhead));
        for(int i=1; i<=n; i++)a[i]=2e9-rd();
        build();
        for(int i=1; i<=n; i++) {
            if(fa[i])add(fa[i],i),add(i,fa[i]);
            fa[i]=i;
        }
        for(int i=1,x,y; i<=m; i++) {
            x=rd()%n+1;
            y=rd()%n+1;
            if(x>y)swap(x,y);
            //if(x==y)an[i]=a[x];
            addq(x,y);
            addq(y,x);
        }
        dfs(root);
        ans=0;
        for(int i=1; i<=m; i++) {
            ans+=(2e9-a[q[i<<1].lca]);
        }
        writeln(ans);
    }
    return 0;
}
```

---

## 作者：Prean (赞：2)

# 警告！卡常警告！！！
极度卡常的一道题。就是数据范围极大的RMQ，数据随机，~~出题人太懒了让我们自己造数据~~

首先st表和线段树肯定都过不去，$ nlogn $的时间在$ n=2e7 $的情况下虽然不会TLE（假如常数大了还是会TLE的），但是空间肯定爆了，于是尝试优化。

用什么优化呢？线段树？不行，空间大，时间大，常数还大。平衡树？似乎没问题，但是常数大了就会TLE。那怎么办呢？要把阶级降低才行。说到这个的话，一定能够想到这个东西：
# 分块
没错是的。

分成$ \sqrt n $个块，每一个块的大小是$ \sqrt n $。那么我们可以在块上RMQ，预处理的时间是$ O( \sqrt nlog \sqrt n) $。

因为C++自带的$ log $函数太慢，我们可以自己初始化：
```cpp
int log[20000005]={-1};
for(register int i=1;i<=n;++i)
{
	log[i]=log[i>>1]+1;
}
```
这样初始化对于LCA的倍增算法也有效。不过要注意的是如果是LCA的话log数组不用初始化。

然后就是分类讨论。
# 1. L和R在一个块内。
很简单，直接暴力就行了。
# What？你不怕超时吗？
真的不怕。因为数据随机，所以L和R在同一个块内的概率是$ \frac 1 n $，所以时间也不会大到哪儿去。就算是$ \frac {1} {\sqrt n} $吧，时间也是$ \sqrt n \times \sqrt n$，不会超时。
# 2. 不在同一个块内并且所在块不相邻
不多说，就是直接ST表。但是L和R不一定是各自所在的块的分界线。怎么办呢？我们可以记一个前缀最大和后缀最大，这样算法就不会退化成$ O( n^{ \frac 3 2 } ) $了。
# 3. 不在同一个块内并且所在块相邻
这样的话ST表就失效了，因为要查询的区间里面没有在ST表内的元素。这个时候我们只要找到L所在块的后缀最大和R所在块的前缀最大，取两个最大的就行了。

这样就搞定辣！

不过本题极度卡常，贴上自己被卡常的代码：
```cpp
#include<iostream>
const int M=2e7+5;unsigned long long ans;
int st[4505][15],mL[M],mR[M],a[M];
int n,m,s,t,p=4480,l[4505],x[4505],y[4505],bl[M];
inline int max(int a,int b){return a>b?a:b;}
namespace GenHelper
{
    unsigned z1,z2,z3,z4,b;
    unsigned rand_()
    {
    b=((z1<<6)^z1)>>13;
    z1=((z1&4294967294U)<<18)^b;
    b=((z2<<2)^z2)>>27;
    z2=((z2&4294967288U)<<2)^b;
    b=((z3<<13)^z3)>>21;
    z3=((z3&4294967280U)<<7)^b;
    b=((z4<<3)^z4)>>12;
    z4=((z4&4294967168U)<<13)^b;
    return (z1^z2^z3^z4);
    }
}
void srand(unsigned x)
{using namespace GenHelper;
z1=x; z2=(~x)^0x233333333U; z3=x^0x1234598766U; z4=(~x)+51;}
int read()
{
    using namespace GenHelper;
    int a=rand_()&32767;
    int b=rand_()&32767;
    return a*32768+b;
}
inline void ask(int L,int R)
{
	if(L>R)std::swap(L,R);int res=0;
	if(bl[L]==bl[R])
	{
		for(int i=L;i<=R;++i)res=max(res,a[i]);
		ans+=res;return;
	}if(bl[R]-bl[L]==1){ans+=max(mR[L],mL[R]);return;}
	int k=l[bl[R]-bl[L]-1];
	res=max(st[bl[L]+1][k],st[bl[R]-(1<<k)][k]);
	res=max(res,max(mR[L],mL[R]));ans+=res;
}
signed main()
{
	int i,j;std::cin>>n>>m>>s;srand(s);
	for(i=1;i<=n;++i)
	{
		a[i]=read();bl[i]=i/p+1;
		st[bl[i]][0]=max(st[bl[i]][0],a[i]);
	}t=bl[n];l[0]=-1;
	for(i=1;i<=t;++i)
	{
		l[i]=l[i-1]+((1<<l[i-1]+1)==i);
		x[i]=(i-1)*p;y[i]=x[i]+p-1;
	}x[1]=1;y[t]=n;
	for(i=1;i<=n;++i)mL[i]=max(a[i],i^x[bl[i]]?mL[i-1]:0);
	for(i=n;i>=1;--i)mR[i]=max(a[i],i^y[bl[i]]?mR[i+1]:0);
	for(j=1;(1<<j)<=t;++j)for(i=1;i+(1<<j)-1<=t;++i)
	st[i][j]=max(st[i][j-1],st[i+(1<<j-1)][j-1]);
	for(;m;--m)ask(read()%n+1,read()%n+1);std::cout<<ans;
}
```

---

## 作者：B_1168 (赞：1)

蒟蒻首A的黑题，~~其实是很卡常的普及组知识点题目（雾）~~

同时小声吐槽：~~评测机评测起这种卡常题来是真的不靠谱啊（捂脸）~~

言归正传，本萌新既然是首A黑题，显然是不会笛卡尔树+优先栈的高级算法的，自然只能选用常用的分块+ST表

看着$O(n)$的复杂度，和从题解学习来的全新ST表辅助分块RMQ(请放心，本人真的是学习来的，分块和ST的模板本人总背得下来，举报抄题解的请停下)，本蒟蒻兴冲冲地交了上去----60，MLE！

然后去再定睛看了一眼题解----人家全部用的都是`int`，自己却开了`long long`（捂脸+1）。对这种毒瘤之甚的啥都卡题，滥开`long long`能炸得五彩斑斓啊！

改了一看----70，TLE……不过嘛，好歹空间是够用了(300MB+/500MB)

在数次无果而终的尝试后，我询问了之前的一位同学，将ST表部分的`temp=log(rr-ll+1)/log(2)`改为预先处理，是为“以空间换常数”也，好生推上80分。

因为最终实在是想不出给#2/#10压榨出30%常数的方法，本人当时选择了~~面向数据编程~~，在折腾了一天后总算是过了这道~~毒瘤题~~

可是----卡常多好玩啊！~~（雾）~~

于是，我们便请来了我们熟悉的好朋友，`zkw`线段树，测试它的速度！

测评结果：

![](https://cdn.luogu.com.cn/upload/image_hosting/2vji8ev4.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

考虑到$2\times10^7\times(\log_{2}{2\times10^7})=4.85\times10^8$，而一般电脑程序每秒平均能支撑的时间复杂度算力约在$10^8/s$，本题对$O(nlogn)$程序的常数要求可谓是可怖的----尤其是线段树这种大量运用位运算的程序。

以下放本人大量参考了洛谷日报#35的zkw线段树代码：

```cpp
//火车头略
#define max(a,b) ((a)>(b))?(a):(b)//这东西对常数优化似乎大有好处
#include<bits/stdc++.h>
#define maxn 20000005
using namespace std;

int N,n,m,s,l,r,tree[maxn<<2];

unsigned long long cnt;

namespace GenHelper
{
    unsigned z1,z2,z3,z4,b;
    unsigned rand_()
    {
    b=((z1<<6)^z1)>>13;
    z1=((z1&4294967294U)<<18)^b;
    b=((z2<<2)^z2)>>27;
    z2=((z2&4294967288U)<<2)^b;
    b=((z3<<13)^z3)>>21;
    z3=((z3&4294967280U)<<7)^b;
    b=((z4<<3)^z4)>>12;
    z4=((z4&4294967168U)<<13)^b;
    return (z1^z2^z3^z4);
    }
}
void srand(unsigned x)
{using namespace GenHelper;
z1=x; z2=(~x)^0x233333333U; z3=x^0x1234598766U; z4=(~x)+51;}
int read()
{
    using namespace GenHelper;
    int a=rand_()&32767;
    int b=rand_()&32767;
    return (a<<15)+b;
}

inline void build(int n){
    for(N=1;N<=n;N<<=1);
    for(register int i=N+1;i<=N+n;++i) tree[i]=read();
    for(register int i=N-1;i;--i) tree[i]=max(tree[i<<1],tree[i<<1|1]);
} 

inline int query(int s, int t) {
    int ans = 0;
    for(s = N + s - 1, r = N + r + 1; s ^ r ^ 1; s >>= 1, r >>= 1) {
        if(~s&1) ans = max(ans,tree[s^1]);
        if(r&1) ans = max(ans,tree[r^1]);
    }
    return ans;
}

int main(){
    scanf("%d%d%d",&n,&m,&s);
    srand(s);
    build(n);
    for(;m;m--){
    	l=read()%n+1,r=read()%n+1;
        if(l>r)swap(l,r);
        cnt+=query(l,r); 
    }
    printf("%lld\n",cnt);
}
```

在此，本人诚挚欢迎各位卡常神仙们能提供某种手段，使得不经过面向数据编程的zkw线段树能通过本题，先鞠躬~

好吧，回到重点----分块+ST！

该算法原理其他题解已经讲得较清楚了，本人就放一个凑合能看脸卡过的代码吧qwq：

```cpp
//火车头略
#include<bits/stdc++.h>

//#include<Windows.h>

#define maxn 20000001
#define maxs 4500
using namespace std;

int n,m,s,len,cnt,l,r,ll,rr,temp,a[maxn],be[maxn],dp[maxs][14],rm[maxn],lm[maxn];

unsigned long long ans=0;

//dp for Sparse-table based O(1) cross-chunk queries
//rm and lm for the prefix and suffix max for the specific chunk
//be for the chunk where the chunk was located in

namespace GenHelper
{
    unsigned z1,z2,z3,z4,b;
    unsigned rand_()
    {
    b=((z1<<6)^z1)>>13;
    z1=((z1&4294967294U)<<18)^b;
    b=((z2<<2)^z2)>>27;
    z2=((z2&4294967288U)<<2)^b;
    b=((z3<<13)^z3)>>21;
    z3=((z3&4294967280U)<<7)^b;
    b=((z4<<3)^z4)>>12;
    z4=((z4&4294967168U)<<13)^b;
    return (z1^z2^z3^z4);
    }
}
void srand(unsigned x)
{using namespace GenHelper;
z1=x; z2=(~x)^0x233333333U; z3=x^0x1234598766U; z4=(~x)+51;}
int read()
{
    using namespace GenHelper;
    int a=rand_()&32767;
    int b=rand_()&32767;
    return a*32768+b;
}

long long query(long long from,long long to){
    cnt=0;
    
    if(to<from) swap(to,from);
    
    ll=be[from],rr=be[to];
    
//	printf("%d %d %d %d ",from,to,ll,rr);
    
    if(ll==rr){
    	for(int i=from;i<=to;i++) cnt=max(cnt,a[i]);
    }
    
/*	if(rr-ll==1){
    	cnt=max(cnt,max(lm[from],rm[to]));
    }*/
    
    if(rr-ll>=1){
    	cnt=max(cnt,max(lm[from],rm[to]));
    	if(rr-ll==1){
    		return cnt;
    	}
    	rr--,ll++;
    	temp=log(rr-ll+1)/log(2);
    	cnt=max(cnt,max(dp[ll][temp],dp[rr-(1<<temp)+1][temp]));
    }
    
/*	for(long long i=from;i<=min(to,be[from]*len);i++) cnt=min(cnt,a[i]);
    if(be[from]!=be[to]){
        for(long long i=(be[to]-1)*len+1;i<=to;i++) cnt=min(cnt,a[i]);
    }
    for(long long i=be[from]+1;i<=be[to]-1;i++) cnt=min(cnt,val[i]);*/
    return cnt;
}

int main(){
    scanf("%d%d%d",&n,&m,&s);
//    DWORD start_time = GetTickCount();
    srand(s);
    len=sqrt(n);
    
    for(int i=1;i<=n;i++){
    	be[i]=(i-1)/len+1;
    	a[i]=read();
		dp[be[i]][0]=max(dp[be[i]][0],a[i]);
    	rm[i]=(be[i]==be[i-1])?(a[i]>=rm[i-1]?a[i]:rm[i-1]):a[i];
    }
    
    for(int i=n;i>=1;i--){
    	lm[i]=(be[i]==be[i+1])?(a[i]>=lm[i+1]?a[i]:lm[i+1]):a[i];
    }
/*	for(int i=1;i<=n;i++) printf("%d ",lm[i]);
//	printf("\n");
    
//	for(int i=1;i<=be[n];i++) printf("%d ",val[i]);
//	printf("\n");
    
    for(int i=1;i<=be[n];i++) dp[i][0]=val[i];*/
    for(int j=1;(1<<j)<=be[n];j++)for(int i=1;i+(1<<j)<=be[n]+1;i++)dp[i][j]=max(dp[i][j-1],dp[i+(1<<j-1)][j-1]);
    
    for(;m;m--){
    	l=read()%n+1,r=read()%n+1;
        ans+=query(l,r); 
    }
    printf("%lld\n",ans);
//    DWORD end_time = GetTickCount();
//    cout << "The run time is:" << (end_time - start_time) << "ms!" << endl;
}
```

部分数组的意义可能不甚明了，欢迎利用各种注释掉的输出语句分析qwq

![](https://cdn.luogu.com.cn/upload/image_hosting/riln6xi3.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

（附赠分块用时----$n,m=2\times10^7$的点日常卡到满，强烈请求给#2/#10开大时限）

感谢管理大佬审核，欢迎点赞qwq

---


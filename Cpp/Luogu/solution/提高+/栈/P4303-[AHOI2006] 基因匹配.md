# [AHOI2006] 基因匹配

## 题目描述

卡卡昨天晚上做梦梦见他和可可来到了另外一个星球，这个星球上生物的DNA序列由无数种碱基排列而成（地球上只有4种），而更奇怪的是，组成DNA序列的每一种碱基在该序列中正好出现5次！这样如果一个DNA序列有N种不同的碱基构成，那么它的长度一定是5N。 

卡卡醒来后向可可叙述了这个奇怪的梦，而可可这些日子正在研究生物信息学中的基因匹配问题，于是他决定为这个奇怪星球上的生物写一个简单的DNA匹配程序。 

为了描述基因匹配的原理，我们需要先定义子序列的概念：若从一个DNA序列（字符串）s中任意抽取一些碱基（字符），将它们仍按在s中的顺序排列成一个新串u，则称u是s的一个子序列。对于两个DNA序列s1和s2，如果存在一个序列u同时成为s1和s2的子序列，则称u是s1和s2的公共子序列。 

卡卡已知两个DNA序列s1和s2，求s1和s2的最大匹配就是指s1和s2最长公共子序列的长度。 

[任务] 
编写一个程序： 
- 从输入文件中读入两个等长的DNA序列； 
- 计算它们的最大匹配； 
- 向输出文件打印你得到的结果。

## 说明/提示

$1 \leq N \leq 20000$

## 样例 #1

### 输入

```
2
1 1 1 1 1 2 2 2 2 2 
1 1 1 2 2 2 2 2 1 1 
```

### 输出

```
8```

# 题解

## 作者：clockwhite (赞：17)

# P4303 基因匹配

# 前言

​	因为看到这题没有人用偏序的讲法感到十分奇怪，就来整一发。

# Solution

​	首先这是一个 LCS 问题，而在[最长公共子序列](https://www.luogu.com.cn/problem/P1439)的题解之中可以找到大量关于 LCS 的解决方案。

​	以下简要阐述我关于如何将 LCS 转化为 LIS 的简要概括。

- 对于任意公共子序列 $S=s_1s_2s_3...s_k$ ,对于其中某元素 $s_i$ 记它在第一个串中的位置为 $a_i$ 在第二个串中为 $b_i$
- 那么 $\forall i > 1,a_i>a_{i-1},b_i>b_{i-1}$ 恒成立

于是这个问题就变成了一个二维偏序问题，这也是 LIS 的经典解法。

​	如果说不知道什么是二维偏序，可以上网搜索。以下给出简要理解。二维偏序是一种要求同时满足两个偏序关系（两个不等式）的计数问题。可以先通过排序解决一个不等式，然后再用数据结构或CDQ等方式解决。

​	此处使用权值树状数组，记录位置早于 x 的最大值。值得一提的是，以在第二个串中的下标顺序计算可以直接符合一个偏序，无需排序。

​	用几何的方式来解释，即以某个字符在第二个串中的位置作为横坐标，在第一个串中的可能位置为纵坐标，在坐标系上建立一个点。

​	最后要求一个单增函数经过尽可能多的点。树状数组可以快速算出纵坐标处于 $y=\alpha$ 这样一条水平线下的最大值。

​	还有一个小细节，最朴素去做的话，应该是一个横坐标对应的五个点一起算出来再加入树状数组，因为要求纵坐标严格小于。但是如果纵坐标从上往下枚举，答案就不会相互影响。类似于0/1 背包。

​	代码内附注释。

# CODE

```c++
#define fe(i,a,b) for(int i=a;i<=b;++i)
inline int read()//快读
const int MAXN=1e5+5;
int n,x,bet[MAXN];
vector<int> pos[MAXN];//记录每个数字在第一个串中的位置
inline int lowbit(int x){return x&(-x);}//树状数组部分
inline void add(int x,int y){for(;x<=n;x+=lowbit(x))bet[x]=max(bet[x],y);}
inline int query(int x){return x?max(query(x-lowbit(x)),bet[x]):0;}
int main(){
	n=read()*5;//长度是五倍
	fe(i,1,n)pos[read()].push_back(i);
	fe(i,1,n)for(int j=4,x=read();j>=0;--j)add(pos[x][j],query(pos[x][j]-1)+1);
    //倒序枚举位置，计算的同时更新，-1是因为严格小于，+1是因为计算答案
	printf("%d",query(n));//上界之下的最大值就是答案
	return 0;
}
```



---

## 作者：蒟蒻溴化氢 (赞：13)

# 基因配对
今天上课听mzx Au巨佬讲这道题,~~当时听懂了后来忘了~~ 又听明年的Au选手@CTime_Pup_314讲了一遍蒟蒻才明白 

首先考虑朴素的转移 


$f_{i,j}=min(f_{i,j-1},f_{i-1,j},f_{i-1,j-1}[a_i=b_j])$

~~但是这样时间空间都会爆炸~~

首先考虑优化空间:

注意到每次转移第一维数组只和上一层有关 因此可以仿照背包的做法 倒序循环压到一维

再考虑时间的优化

我们认为$[a_i=b_j] $是关键点 

因为对答案贡献的只有关键点 对关键点转移的时候 它的转移就只和$f_{i-1,j-1}$有关 我们就可以只对关键点统计答案 剩下的部分用数据结构维护(我用的树状数组

1. 查询$f_{i-1,j-1}$的二维前缀最大值(压缩后就变成了一维)

2. 更新$f_i$的答案

3. 用$f_i$二维更新前缀最大值(压缩后就变成了一维)

代码:

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector> 
#define il inline 
#define res register int
#define pb push_back
using namespace std;
const int N=20000*5+10;
il int read()
{
	int x=0,f=0,c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=1;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return f?-x:x;
}
int a[N],b[N],f[N],c[N];
vector <int> p[N/5];

int n;
il void add(int x,int y){ for(;x<=n;x+=(x&-x)) c[x]=max(c[x],y);}
il int ask(int x){int ans=0;for(;x;x-=(x&-x)) ans=max(ans,c[x]);return ans;}


int main()
{
	n=read(); n*=5;
	for(res i=1;i<=n;i++) a[i]=read(),p[a[i]].pb(i);//记录一下关键点
	for(res i=1;i<=n;i++) b[i]=read();
	for(res i=1;i<=n;i++)
	{
		int x=b[i];
		for(res j=p[b[i]].size()-1;j>=0;j--)//倒序
		{
			int pos=p[b[i]][j];
			f[pos]=ask(pos-1)+1;//更新答案
			add(pos,f[pos]);//维护前缀
		}
	}
	int ans=0;
	for(res i=1;i<=n;i++) ans=max(ans,f[i]);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Jμdge (赞：9)

这里就是满分的题解了。
主要就是用到了树状数组，这点还是很难想到的，（毕竟lcs和树状数组貌似没什么卵关系）so，具体程序里说吧


```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
vector<int> f[20005];  //这里的f数组存的是某个数字在序列中出现的位置
//之所以用vector其实不是说省内存，就是偷懒的方法而已（自己理解）
int g[100005];	//然后g数组存的是最长公共子序列的答案了（树状数组中）

int lowbit(int x)	//取最低位就不用说了
{
	return x&(-x);
}

void update(int i,int x)	//一直向上（向BOSS）更新最大公共子序列的长度
{
	for(;i<=n;i+=lowbit(i))
		g[i]=max(g[i],x);
}

int getmax(int i)	//一直向前询问不同区间内的lcs答案，
//比如6->4就是查询了1~6之间最长公共子序列的长度（只要懂树状数组的人一般都能理解）
{
	int res=0;
	for(;i;i-=lowbit(i))
		res=max(res,g[i]);
	return res;
}

int main()
{
	scanf("%d",&n);
	n*=5;
	for(int i=1;i<=n;++i)
	{
		int x;
		scanf("%d",&x);
		f[x].push_back(i);	//这里是正序记录的x出现的位置
	}
	
	for(int i=1;i<=n;++i)
	{
		int x;
		scanf("%d",&x);
		for(int j=4;j>=0;--j) //但是在这里要反着读，
        //以此避免前面更新完的lcs影响到后面的答案更新
        //就像01背包问题也是和这个一个道理
		{
			int at=f[x][j];
			update(at,getmax(at-1)+1);	
  		 //首先先询问在当前位置之前的lcs（很像dp吧？）
		}
	}
	
	printf("%d\n",getmax(n));//最后直接查询n'（5*n）就好咯
	return 0;
}
```

---

## 作者：lnwhl (赞：7)

[problem](https://www.luogu.com.cn/problem/P4303)
## Description
给定两个长度为 $5n$ 的序列，每个序列中 $1\sim n$ 各有 $5$ 个，求两个序列的最长公共子序列。
## Solution
$f_{i,j}$ 表示第一个序列匹配到第 $i$ 位，第二个序列匹配到第 $j$ 位，能构成的最长 LCS 长度。不难列出朴素的转移方程：
$$f_{i,j}=\max\{f_{i-1,j},f_{i,j-1}.f_{i-1,j-1}+(a_i==b_j)\}$$
时空复杂度都是 $O(n^2)$ 的，需要优化。观察本题的特殊性质，每个数都恰好出现 $5$ 次，所以能使答案增加的位置很少，因此我们可以用 $pos$ 记录第一个序列中每个元素出现的位置，每次转移就从这 $5$ 个位置转移即可。对于空间，我们可以压掉一维。$f_{i}$ 表示第一个序列匹配到第 $i$ 位的答案，第二个序列当前位的值为 $x$，与第一个序列第 $j$ 个值为 $x$ 的位置匹配的转移方程即为：
$$f_{pos_{x,j}}=\max\limits_{i=1}^{pos_{x,j}-1}f_i+1$$
发现问题转化为求最大值，可以通过树状数组实现。复杂度为 $O(5n\log n)$。注意，$j$ 要倒序穷举，因为我们用到了滚动数组。
## Code
```cpp
#include <bits/stdc++.h>
#define il inline 
#define Rint register int
using namespace std;
const int N=1e5+10;
int n,a[N],b[N],f[N],BIT[N];
vector<int>t[N/5];
il int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
il int lowbit(int x){return x&-x;}
il void add(int x,int y)
{ 
	while(x<=5*n)
	{
		BIT[x]=max(BIT[x],y);
		x+=lowbit(x);
	}
}
il int query(int x)
{
	int res=0;
	while(x>0)
	{
		res=max(res,BIT[x]);
		x-=lowbit(x);
	}
	return res;
}
int main()
{
	n=read();
	for(Rint i=1;i<=5*n;++i) 
	{
		a[i]=read();
		t[a[i]].push_back(i);	
	}
	for(Rint i=1;i<=5*n;++i)
		b[i]=read();
	for(Rint i=1;i<=5*n;++i)
		for(Rint j=4;j>=0;--j)
		{
			int pos=t[b[i]][j];
			f[pos]=query(pos-1)+1;
			add(pos,f[pos]);
		}
	int ans=0;
	for(Rint i=1;i<=5*n;++i)
		ans=max(ans,f[i]);
	cout<<ans;
	return 0;
}
```

---

## 作者：Tyher (赞：6)


- 打个广告 [cnblogs](https://www.cnblogs.com/Tyher/p/9898976.html)
- 求两个序列的最长公共子序列，满足每个数出现不超过$5$次，$n\leq 10^5$。
- 一般的最长公共子序列是$O(n^2)$的，考虑这个题的不一样性质在哪里。
- 满足每个数出现不超过$5$次，意味合法的转移点不多。
- 那么对于$a$序列中的每个数$a_i$，他的合法转移点不会超过$5$个。
- 所以把每个数的合法转移点扣出来，这样就得到了一个长度为$5*n$的序列。
- 如果选择一个数，就相当于选择了一个转移点转移，因为要求是原串的子序列，所以转移点位置一定是单调上升的。
- 所以对于每个数的合法转移点之间要倒序排列，这样才能满足一个数的转移点只会选择一个。
- 现在问题转化成，给出一个长度为$5*n$的序列，求最长上升子序列。
- 这个就烂大街了，树状数组或者二分栈随便维护一下即可，复杂度$O(5*nlogn)$

```
#include<bits/stdc++.h>
#define R register int
#define low(x) (x&(-x))
using namespace std;
const int N=20001;
const int M=500001;
int n,m,w[M],f[M],tot,ans,te[M];
vector<int>G[N];
void add(R x,R v){while(x<=m)te[x]=max(te[x],v),x+=low(x);}
int query(R x){R v=0;while(x)v=max(te[x],v),x-=low(x);return v;}
int gi(){
    R x=0,k=1;char c=getchar();
    while(c!='-'&&(c<'0'||c>'9'))c=getchar();
    if(c=='-')k=-1,c=getchar();
    while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();
    return x*k;
}
int main(){
	n=gi(),m=n*5;
	for(R i=1,u;i<=m;++i)
		u=gi(),G[u].push_back(i);
	for(R i=1,u;i<=m;++i){
		u=gi();
		for(R j=4;j>=0;--j)w[++tot]=G[u][j];
	}
	for(R i=1;i<=tot;++i)
		f[i]=query(w[i]-1)+1,add(w[i],f[i]),ans=max(ans,f[i]);
	cout<<ans<<endl;
    return 0;
}


```

---

## 作者：aakennes (赞：3)

# P4303 [AHOI2006]基因匹配


# 【题目】
卡卡昨天晚上做梦梦见他和可可来到了另外一个星球，这个星球上生物的DNA序列由无数种碱基排列而成（地球上只有4种），而更奇怪的是，组成DNA序列的每一种碱基在该序列中正好出现5次！这样如果一个DNA序列有N种不同的碱基构成，那么它的长度一定是5N。
卡卡醒来后向可可叙述了这个奇怪的梦，而可可这些日子正在研究生物信息学中的基因匹配问题，于是他决定为这个奇怪星球上的生物写一个简单的DNA匹配程序。
为了描述基因匹配的原理，我们需要先定义子序列的概念：若从一个DNA序列（字符串）s中任意抽取一些碱基（字符），将它们仍按在s中的顺序排列成一个新串u，则称u是s的一个子序列。对于两个DNA序列s1和s2，如果存在一个序列u同时成为s1和s2的子序列，则称u是s1和s2的公共子序列。
卡卡已知两个DNA序列s1和s2，求s1和s2的最大匹配就是指s1和s2最长公共子序列的长度。

#### [任务] 编写一个程序：
从输入文件中读入两个等长的DNA序列；
计算它们的最大匹配；
向输出文件打印你得到的结果。
## 输入格式
输入文件中第一行有一个整数N，表示这个星球上某种生物使用了N种不同的碱基，以后将它们编号为1…N的整数
以下还有两行，每行描述一个DNA序列：包含5N个1…N的整数，且每一个整数在对应的序列中正好出现5次。

## 输出格式
输出文件中只有一个整数，即两个DNA序列的最大匹配数目。

## 输入输出样例
### 输入1
```
2
1 1 1 1 1 2 2 2 2 2 
1 1 1 2 2 2 2 2 1 1 
```
### 输出1
```
8
```
### 输入2
```
2
1 1 2 2 1 1 2 1 2 2
1 2 2 2 1 1 2 2 1 1
```
### 输出2
```
7
```
## 说明/提示

$1≤N≤20000$

# 【思路】
## 扯点别的
看此题前先观光一下这题的弱化版：UVA 10635（https://www.luogu.com.cn/problem/UVA10635）
考试时乍一看一个LCS板子，再一看数据范围，显然n²的效率过不去，于是乎就想起之前写过得一道题（上面那题），用lis优化lcs，时间效率为nlogn，但那道题显然有个限制条件：序列中所有的数都相等。这道题明确给出了重复的个数，一开始我就想用普通的$5\times x+cnt[x]$来存，之后跟那道题一样，结果连样例都过不去（但竟然有50分），然后就摸了。
之后看到题解十分气愤，竟然真是那道题，很气。

## 正解
在王子公主中我们b序列中的一个数对应a序列中这个数的位置，然后对应到b序列中，最后跑一遍lis。这道题我们可以把b序列中的一个数对应到a序列中这个数的所有位置，倒序存进b序列里面。
### 问题1:为什么要存所有位置
表面上我们存进了所有的位置，实际上我们只需要用这些位置的某一个最优值就可以。拿样例2来说，我们倒序存入后，新数组：

（1）8 6 5 2 1 

（2）10 9 7 4 3 

（3） 10 9 7 4 3 

（4） 10 9 7 4 3 

（5） 8 6 5 2 1

（6） 8 6 5 2 1 

（7） 10 9 7 4 3 

（8） 10 9 7 4 3 

（9） 8 6 5 2 1 

（10） 8 6 5 2 1 1

最长上升子序列的数依次来源于：第一个串的1，第二个串的3，第三个串的4，第五个串的5，第六个串的6，第七个串的7，第九个串的8。
### 问题2：为什么要倒序
每一个串一开始一定是一个上升的子序列，所以倒序后一定是一个下降的子序列，这样在跑lis的时候我们只会用到这个串中的一个数。相反，如果你不倒序，肯定就会用到这个串所有数，结果定然不对。
# 【代码】
```c++
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<map>
using namespace std;
const int maxn=1e6+5,maxe=250*250+5,INF=0x3f3f3f3f;
int n,f[maxn],a[20005][20005],b[maxn],low[maxn],cnt[maxn];
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int main(){
	freopen("a.in","r",stdin);
//	freopen("dinning.out","w",stdout);
	n=read();
	int maxmax=0;
	memset(low,0,sizeof(low));
	for(int i=1;i<=n*5;i++){
		int x=read();
		a[++cnt[x]][x]=i;
	}//a[cnt[x]][x]表示x在第一个序列中出现第cnt[x]次的位置 
	memset(cnt,0,sizeof(cnt));
	int len=0;
	for(int i=1;i<=n*5;i++){
		int x=read();
		for(int j=5;j>=1;j--)b[++len]=a[j][x];//倒序存入每一个串 
	}	
	int len1=1;
	low[1]=b[1];
	for(int i=2;i<=len;i++){
		if(low[len1]<b[i])low[++len1]=b[i];
		else low[lower_bound(low+1,low+len1+1,b[i])-low]=b[i];
	}	
	printf("%d\n",len1);
}
```


---

## 作者：Thunder_S (赞：2)

## Solution

注意到每个数字刚好出现 5 次，因此每个位置可以匹配的只有 5 个位置。

所以可以先 $\mathcal O(n)$ 找出每个数可以匹配的位置，然后组合成长度为 $25n$ 的序列，求个最长上升子序列即可。但为了不让一个数被重复，所以组合时对于每个数字需要从大到小加入可匹配的位置。

问题在于怎么求最长上升子序列。一般的求法是 $\mathcal O(n^2)$，是过不了这道题的。

考虑优化至 $\mathcal O(n\log n)$。这个方法网上有很多讲解，这里讲一下我的想法。

维护的是最长上升子序列，	那么考虑什么情况可以更新最长上升子序列，显然是当前数大于当前序列的末尾。但如果小于等于末尾，就说明这个数可能会对答案进行影响。

那么我们二分找到序列中第一个小于当前数的位置，并且从那之后可以开创一个新的分支，记录以当前数为末尾的子序列。

具体来说，设 $f_i$ 表示长度为 $i$ 的上升子序列末尾的数是什么，如果当前数 $x$ 大于 $f_{len}$（$len$ 为最长上升子序列的长度），那么直接加进来即可。

但如果当前数小于等于 $f_{len}$，就找出 $f$ 中第一个 $i$ 使得 $f_i<x$，然后 $f_{i+1}=x$，因为长度为 $i+1$ 的结尾选 $x$ 会更优，因为具有更大的空间。

## Code

```cpp
#include<cstdio>
#define N 20005
int n,num,len,a[N*5],b[N*5],q[N*30],c[N][10],d[N*30];
using namespace std;
int two_point(int l,int r,int x)
{
	int mid=0,res=0;
	while (l<=r)
	{
		mid=(l+r)>>1;
		if (d[mid]<x) res=mid,l=mid+1;
		else r=mid-1;
	}
	return res;
}
int main()
{
	scanf("%d",&n);
	for (int i=1;i<=5*n;++i)
		scanf("%d",&a[i]);
	for (int i=1;i<=5*n;++i)
	{
		scanf("%d",&b[i]);	
		c[b[i]][++c[b[i]][0]]=i;
	}
	for (int i=1;i<=5*n;++i)
	{
		for (int j=1;j<=c[a[i]][0];++j)
			q[++num]=c[a[i]][c[a[i]][0]-j+1];
	}
	d[len=1]=q[1];
	for (int i=2;i<=num;++i)
	{
		if (q[i]>d[len]) d[++len]=q[i];
		else
		{
			int p=two_point(1,len,q[i]);
			d[p+1]=q[i];
		}
	}
	printf("%d\n",len);
	return 0;
}
```

---

## 作者：HC20050615 (赞：2)

## 题意分析
求两个序列的最长公共子序列，并且每个数有且仅有5个。
## 思路
读入第一个数组时记录每一个数的每一次出现的位置。

读入第二个数组的时候，可以枚举这个数字在第一个数组中出现第几次，然后通过其在第一个数组的位置进行转移。

转移方程式如下：

(其中 $i$ 表示这是第二个数组的第几个数，$x$ 表示这个数字是多少，而$j$ 表示是第一个数组中出现的第几次 )

$f[i]=\max(\max_{t=1}^{d[x][j]}(f[t-1])+1,f[i])$

在这个方程中，$d[x][j]$ 表示第 $x$ 个数在第一个数组中出现第 $j$ 次的时候的位置。而 $f[i]$ 表示以第 $i$ 个数结尾时的最长公共子序列长度。

但是这个方程式为 $O(n^2)$，对于 $2\times10^4$ 的数据会 $TLE$ ，所以我们要对其进行优化。

观察式子可以发现，每次访问 $f$ 数组的时候，我们的目的都是要找 $f$ 数组从 $1$ 到某个数的最大值。对此我们可以用树状数组来维护，这样时间复杂度就会变成 $O(nlogn)$，然后就可以愉快的 $A$ 掉此题了。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int d[20001][6];
int c[100001];
inline int read() 
{
	char c=getchar();
	int x=0;
	while(c<'0'||c>'9') 
	{
		c=getchar();
	}
	while(c>='0'&&c<='9') 
	{
		x=x*10+(c^48);
		c=getchar();
	}
	return x;
}
inline int max(int a,int b)
{
    return a>b?a:b;
}
inline int lowbit(int n)
{
	return n&(-n);
}
inline void change(int x,int k)
{
	while(x<=n)
	{
		c[x]=max(c[x],k);
		x+=lowbit(x);
	}
	return ;
}
inline int find(int x)
{
	int ans=0;
	while(x)
	{
		ans=max(ans,c[x]);
		x-=lowbit(x);
	}
	return ans;
}
int main()
{
	n=read();
	n*=5;
	for(register int i=1;i<=n;i++)
	{
		int x=read();
		d[x][++d[x][0]]=i;
	}
	for(register int i=1;i<=n;i++)
	{
		int x=read();
		for(register int j=5;j>=1;j--)
		{
			int t=find(d[x][j]-1)+1;
			if(t>c[d[x][j]])
			{
				change(d[x][j],t);
			}
		}
	}
	printf("%d",find(n));
	return 0;
}
```


---

## 作者：KSToki (赞：2)

# 题目大意
给定两个长度为 $5n$ 的序列，每个序列中 $1\sim n$ 各有 $5$ 个，求两个序列的最长公共子序列。
# 题目分析
考虑暴力，$f[i][j]$ 表示第一个序列匹配到第 $i$ 个位置，第二个序列匹配到第 $j$ 个位置是的最长公共子序列，转移为：

$f[i][j]=max(f[i-1][j],f[i][j-1],f[i-1][j-1]+(a[i]==b[j]))$

由于仅当 $a[i]=b[j]$ 时转移会增大答案，结合本题给出的特殊性质，我们想到记录每个数在 $a$ 中出现的五个位置，每个 $b$ 仅从这几个位置转移即可。空间仍存在问题，考虑滚动数组压掉一维，像背包那样。于是我们现在只有一维，第二个序列中当前数为 $x$ 转移方程为：

$f[pos[x][j]]=\max_{i=1}^{pos[x][j]-1}{f[i]}+1$

这里 $pos$ 顾名思义是记录 $x$ 在第一个序列中的 $5$ 个位置的，$j$ 则表示是从第几个 $x$ 转移。注意 $j$ 要从 $5$ 循环到 $1$，因为我们用了滚动数组。显然这个式子可以直接用树状数组优化至 $O(nlogn)$。
# 代码
代码中并没有直接把 $f$ 数组搞出来，因为直接通过树状数组可以得到答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	char ch=getchar();
	int res=0,flag=1;
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			flag=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		res=res*10+ch-'0';
		ch=getchar();
	}
	return res*flag;
}
int n,a,c[100001],pos[20001][6];
inline int lowbit(int x)
{
	return x&(-x);
}
inline void update(int x,int v)
{
	for(;x<=n;x+=lowbit(x))
		c[x]=max(c[x],v);
}
inline int Max(int x)
{
	register int res=0;
	for(;x;x-=lowbit(x))
		res=max(res,c[x]);
	return res;
}
int main()
{
    n=read()*5;
    for(register int i=1;i<=n;++i)
    {
    	a=read();
    	pos[a][++pos[a][0]]=i;
	}
    for(register int i=1;i<=n;++i)
    {
    	a=read();
    	for(register int j=5;j>0;--j)
    		update(pos[a][j],Max(pos[a][j]-1)+1);
	}
	printf("%d\n",Max(n));
    return 0;
}
```


---

## 作者：Ariadne (赞：1)

朴素 *LCS* 会 TLE （确信）.

序列里有重复元素，也不能使用排列 *LCS* 优化. 

考虑 *LCS* ，其在两数相等时 *DP* 值加 *1*，可预先存下 S1 中每个数出现的 *5* 个位置. 用树状数组维护以 S1 的每个位置为结尾匹配到 S2 的目前位置的 *LCS* 的长度，每一次只能从特定的 *5* 个位置转移；对于每个转移，取这个位置前边的 *LCS* 的最大值加 *1* 作为这一位匹配的结果，更新树状数组，并且与之前的最优解取最大作为当前最优解，再遍历 S2 即可.

```cpp
//Code by Ariadne.w.
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define IO ios::sync_with_stdio(false); cin.tie(0);
using namespace std;
const int M = 1e6 + 7;
const ll N = 1e9 + 7;
int s1[M], s2[M], pos[20007][5], ed[20007], upd[M], n;

int lowbit(int x) {
	return x & (-x);
}

void update(int x, int d) {
	while (x <= 5 * n) {
		upd[x] = max(upd[x], d);
		x += lowbit(x);
	}
}

int query(int x) {
	int res = 0;
	while (x) {
		res = max(res, upd[x]);
		x -= lowbit(x);
	}
	return res;
}

int main() {
	int ans = 0;
	cin >> n;
	for (int i = 1; i <= 5 * n; i++) cin >> s1[i];
	for (int i = 1; i <= 5 * n; i++) cin >> s2[i];
	for (int i = 1; i <= 5 * n; i++) pos[s1[i]][ed[s1[i]]++] = i;
	for (int i = 1; i <= 5 * n; i++) {
		for (int j = 4; j >= 0; j--) {
			int now = query(pos[s2[i]][j] - 1) + 1;
			ans = max(ans, now);
			update(pos[s2[i]][j], now);
		}
	}
	cout << ans << endl;
	return 0;
}
```


---

## 作者：green_orange (赞：1)

# 题目分析

考虑对于序列中的数互不相同的情况，则我们有做法，将其中一个序列的值映射成另一序列的数组下标。对映射后的序列求LIS，则此序列的LIS就是原来两个序列的LCS。

从另一种角度解释，我们可以将这种做法解释为对于每种取值，我们都有点 $ (i, j) $ ( 其中 $ a_i = b_j $ ) ，即求点序列 $ p $ ，使 $ a_{p_i} < a_{p_{i+1}}, b_{p_i} < b_{p_{i+1}} $。 对此，我们可以用排序（以 $ a $ 作为第一关键字升序，以 $ b $ 作为第二关键字降序）+ 树状数组解决。

回到本题，则我们可以对于每一组相等关系都建出一个这样的点（即若 $ a_i = b_j $ 则建出点 $ (i, j) $ ），因为一个数最多重复 $ 5 $ 次，则我们只会建出 $ 5 \times 5n = 25 n$ 个点， 按照同样的树状数组的方法操作即可。

# 实现

``` cpp
typedef pair<int, int> Point;
constexpr int maxn = 20000;
Point pi[maxn * 25];
int x[maxn * 5], y[maxn * 5];
int pos[maxn + 1][5], cnt[maxn + 1];
int tot = 0, N;
struct BIT {
  int c[maxn * 5 + 1];
  inline int lowbit(int x) { return x & -x; }
  void maxium(int x, int v) {
    while (x <= 5 * N) {
      letmax(c[x], v);
      x += lowbit(x);
    }
  }
  int query(int x) {
    int res = 0;
    while (x) {
      letmax(res, c[x]);
      x -= lowbit(x);
    }
    return res;
  }
} bt;
int main() {
  cin >> N;
  copy_n(istream_iterator<int>(cin), 5 * N, x);
  copy_n(istream_iterator<int>(cin), 5 * N, y);
  for (int i = 5 * N - 1; i >= 0; --i)
    pos[y[i]][cnt[y[i]]++] = i; // 建图，注意式子中是严格小于，此处要反向枚举
  for (int i = 0; i < 5 * N; ++i)
    for (int j = 0; j < 5; ++j)
      pi[tot++] = Point(i, pos[x[i]][j]);
  for (int i = 0; i < tot; ++i)
    bt.maxium(pi[i].second + 1, bt.query(pi[i].second) + 1);
  cout << bt.query(5 * N) << '\n';
  return 0;
}
```

---

## 作者：ccsc (赞：1)

## 这道题，思路很难想，但是呢！代码却是异常简单~咕咕咕

首先这道题表面上是让你求一个LCS问题；；

但请各位注意一下他的取值范围，，n<=20000;

也就是让你有5*n的数据

如果用传统朴素（dp）求解必然会爆

这时就需要我们的聪明才智了

首先，我们把题意分析透彻

我们画一个如下的图

![](https://cdn.luogu.com.cn/upload/pic/62165.png)


该图表示对于a串b串相同元素时的情况（因为有五个相同，故~）

因为我们只需要思考a串b串相等时的情况；；

so~问题变得easy了起来



明显可以看出他们有递增关系

那么

看数据范围

n<=20000;


显而易见，我们需要一个n（logn）的算法



##  毋庸置疑（胡说（*——））就是一个树状数组的题了

难么？？？
代码

```cpp
#include<bits/stdc++.h>
#define N 20007
#define lowbit(x) x&(-x)
using namespace std;

int c[N*5],n,p[N][6],x,a[N*5],f[N*5],ans,b[N*5];

void add(int x,int k){
   for (int i=x;i<=5*n;i+=lowbit(i)) c[i]=max(c[i],k);
}
int Q(int x){
    int ans=0;
    for (int i=x;i;i-=lowbit(i)) ans=max(ans,c[i]);
    return ans; 
}
int main(){
   scanf("%d",&n);
   for (int i=1;i<=n*5;i++){scanf("%d",&a[i]);p[a[i]][++p[a[i]][0]]=i;}
   for (int i=1;i<=n*5;i++) scanf("%d",&b[i]);
   for (int i=1;i<=n*5;i++){
     for (int j=5;j;j--){
       int k=Q(p[b[i]][j]-1);f[i]=k+1;
       add(p[b[i]][j],f[i]);ans=max(ans,f[i]);
     }
   }    
   cout<<ans<<endl;
}
```


非常谢谢某wu大佬对我当时思路的点拨~~~

---

## 作者：PragmaGCC (赞：0)

题目要求你求出两个序列 a, b 的最长公共子序列长度。

但是看到数据范围 $2 \times 10^4$ 就知道肯定过不了，因为长度是 5n，也是就是 $10^5$。

那怎么办呢？

这一题特殊在于，虽然长度是 5n，但是只有 n 个数，并且每个数都有五个。所以，我们可以尝试从这里入手，对朴素的 LCS 进行优化。

我们定义一个阶段可以从若干个”贡献点“转移过来。

而此题中每个数都有五个，也就是说，两个序列中，合法的贡献点**最多**只有五个。

既然我们已知了这些产生贡献的点，为什么不直接对这些点进行转移呢？

此时就可以使用**树状数组**或者**线段树**将每次更新优化到 $\log_2(n)$。

于是我们就有了一个常数约为5的 $\rm O(\rm nlogn)$ 的做法。

```cpp
#include <cstdio>
#include <queue>

#define max(x, y) x > y ? x : y
const int N = 20005;

int read() {
    register int n = 0;
    register char ch = getchar();
    bool f = 1;
    while (ch < '0' || ch > '9') {
        if (ch == '-')
            f = 0;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        n = (n << 3) + (n << 1) + (ch ^ '0');
        ch = getchar();
    }
    return f ? n : -n;
}

int n;
std::deque<int> a[N];

template <class T> class BIT {
    T t[N * 5];
    int lowbit(int x) { return x & -x; }

  public:
    void update(int pos, T val) {
        while (pos <= n) {
            t[pos] = max(t[pos], val);
            pos += lowbit(pos);
        }
    }
    T query(int pos) {
        T res = 0;
        while (pos) {
            res = max(res, t[pos]);
            pos -= lowbit(pos);
        }
        return res;
    }
};
BIT<int> t;

int main(void) {
    n = read() * 5;
    for (int i = 1; i <= n; i++) {
        a[read()].push_back(i);
    }
    for (int i = 1; i <= n; i++) {
        int tmp = read();
        for (int x = 4; x >= 0; x--) {
            t.update(a[tmp][x], t.query(a[tmp][x] - 1) + 1);
        }
    }
    printf("%d\n", t.query(n));
    return 0;
}
```



---

## 作者：Merc03 (赞：0)

## 知识

- LIS

- 线段树

## 思路

首先考虑最最最朴素最最最暴力的转移，$f_{i,j}$ 表示 $a$ 的第 $i$ 个和 $b$ 的第 $j$ 个匹配上时的 $LIS$ 长度，$O(n ^ 4)$ 时间，$O(n ^ 2)$ 空间，均不可接受。

搭嘎，考虑本题的限制条件：对于每个 $i$，至多有 $5$ 个 $j$ 是有意义的，我们就表示 $f_{i, j}$ 为 $a$ 的第 $i$ 个，与 $b$ 中第 $j$ 个与 $a_i$ 相同的的数匹配时的的 $LIS$ 长度。$j \leq 5$ ，缩掉一维，时空分别为 $O(n ^ 3)$ 和 $O(n)$。

现在我们的复杂度在寻找最大的 $f_{k, l}$ 且满足 $k \leq i$，$pos_{a_k, l} \leq pos_{a_i, j}$。我们的遍历顺序必然保证第一个条件，对于第二个条件，我们对 $pos_i$ 的值域开一棵线段树来，在 $[1, pos_{a_i, j}- 1]$ 上区间查询最值，这个技巧很常见就不细讲。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace input {
	bool Sign;
	template <typename T>
	inline void read(T &a) {
		register char ch = getchar();
		while(!isdigit(ch) && ch != '-') ch = getchar();
		a = (Sign = (ch == '-')) ? 0 : ch ^ 48;
		while(isdigit(ch = getchar())) a = (a << 3) + (a << 1) + (ch ^ 48);
		a = Sign ? -a : a;
	}
}
using input::read;
const int N = 2e4 + 5;
int n, a[N * 5], b[N * 5], pos[N][6], dp[N * 5][6];
namespace SegTree {
	#define ls o << 1, L, Mid
	#define rs o << 1 | 1, Mid + 1, R
	int Mx[(N * 5) << 2];
	#define pushup(o) Mx[o] = max(Mx[o << 1], Mx[o << 1 | 1])
	inline void modify(int o, int L, int R, int pos, int v) {
		if(L == R) {Mx[o] = max(Mx[o], v); return;}
		int Mid = (L + R) >> 1;
		if(pos <= Mid) modify(ls, pos, v);
		else modify(rs, pos, v);
		pushup(o); 
	}
	inline int query(int o, int L, int R, int l, int r) {
		if(l > r) return 0;
		if(l <= L && R <= r) return Mx[o];
		int Mid = (L + R) >> 1, res = 0;
		if(l <= Mid) res = max(res, query(ls, l, r));
		if(r > Mid) res = max(res, query(rs, l, r));
		return res; 
	}
}
using namespace SegTree;
int main() {
	//freopen("lcs.in","r", stdin);
	//freopen("lcs.out", "w", stdout);
	read(n); n *= 5;
	for(int i = 1; i <= n; ++i) read(a[i]);
	for(int i = 1; i <= n; ++i) read(b[i]), pos[b[i]][++pos[b[i]][0]] = i;
	int ans = 0;
	for(int i = 1; i <= n; ++i)
		for(int j = pos[a[i]][0]; j >= 1; --j) {
			dp[i][j] = query(1, 1, n, 1, pos[a[i]][j] - 1) + 1;
			modify(1, 1, n, pos[a[i]][j], dp[i][j]);
			ans = max(ans, dp[i][j]);
		}
	printf("%d\n", ans);
	return 0;
}
```


---


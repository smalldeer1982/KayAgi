# 蓬莱「凯风快晴　−富士火山−」

## 题目背景

富士山，被当地人称为「神山」。这是一座休眠火山，最近一次喷发在 $300$ 年前。

向这样的山中投入不死之药，想必会直接喷发吧。如此便理解为什么月岩笠最终抗命。

## 题目描述

所谓的山，是一种上细下粗的结构。能不能在「树」里也找到这样的结构呢？

给定一个以 $1$ 为根的大小为 $n$ 的有根树 $T$。你需要找到满足宽度单调不减的**导出子树**中最大的一棵：

- 记该导出子树为 $T_0$，共有 $k$ 层。
- 记 $T_0$ 的根节点的深度为 $1$，计算出 $T_0$ 中每个结点的深度 $d_i$。由此定义 $T_0$ 第 $i$ 层的宽度 $w_i$ 为「所有深度为 $i$ 的节点的个数」。
- 你需要使得 $w_i$ 单调不减。即，$w_1\le w_2\le \cdots \le w_k$。

记原树的点集和边集分别为 $V,E$。导出子树是原树的一个**连通块**，它的点集 $V_0\subseteq V$，边集 $E_0$ 是 $E$ 当中所有端点均在 $V_0$ 内的边。导出子树的根，是组成它的所有节点中**在原树内深度最浅的那一个**。$T$ 也可以被认为是自身的一棵导出子树。

![](https://cdn.luogu.com.cn/upload/image_hosting/wcbeo1a0.png)

如图所示，绿色的区域和橙色的区域分别是原树的导出子树。它们的根分别为 $2$ 和 $13$。

**注意**：导出子树的定义略微不同于子树的定义。请不要将两者混淆。

请找到最大的符合条件的导出子树的大小。

## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/pzq47a3e.png)

如图所示，标灰的节点是两个样例中选出来的导出子树。

- 样例 $1$ 找到的导出子树，每一层的宽度分别为 $\{1,2,3,3\}$。
- 样例 $2$ 找到的导出子树，每一层的宽度分别为 $\{1,2,4,4,5\}$。
### 数据范围及约定

对于全部数据，$1\le n\le 5\times 10^5$。

## 样例 #1

### 输入

```
10
1 2
2 3
3 4
3 5
2 6
6 7
1 8
8 9
8 10```

### 输出

```
9```

## 样例 #2

### 输入

```
17
1 2
2 3
3 4
4 5
4 6
3 7
7 8
7 9
7 10
2 11
2 12
1 13
13 14
14 15
14 16
13 17```

### 输出

```
16```

# 题解

## 作者：Daniel_yao (赞：8)

## Problem
给定一个以 $1$ 为根，大小为 $n$ 的有根树 $T$，需要找到一棵满足宽度单调不减的**导出子树**中最大的一棵。
## Solve
从根节点往下决策是很麻烦的，因为他的儿子数量是不固定的，意思是说，在决策一个以 $u$ 为根的子树的时候，你无法知道下一层的节点选几个和选那些最优。**因为你的心胸太狭隘，无法纵观大局**。

但是倒着考虑会好想些。首先，在某一层选满肯定是最优的，不过，并不是哪一层最宽就全选哪层，假如有一个很高的树，在第二层特别的宽。你选了这一层，然后发现你只能选一二层的点。而次宽的层在很深很深的地方，如果你选了次宽的层，然后其父亲，爷爷，曾爷爷辈都可以被选到，显然，能构造出一组使得其假掉的例子。

所以，全选哪一层无法确定，那就枚举哪一层全选，取最优。但是这样，时间复杂度就是 $O(n^2)$ 的。

我们又发现，父亲的数量一定不会比儿子多，也就是说，可选层的点的数量也是呈单调态。因此，我们维护一个单调递增的栈，每一次跳到第一个小于这一个层的父辈层，之间的层的点数就是这一层与第一个小于这一个层的父辈层之间的层数再乘上第一个小于这一个层的父辈层的点数。最后取个最优方案即可。
## Code
```cpp
#include <bits/stdc++.h>
#define int long long
#define H 19260817
#define rint register int
#define For(i,l,r) for(rint i=l;i<=r;++i)
#define FOR(i,r,l) for(rint i=r;i>=l;--i)
#define MOD 1000003
#define mod 1000000007

using namespace std;

inline int read() {
  rint x=0,f=1;char ch=getchar();
  while(ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
  while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
  return x*f;
}

void print(int x){
  if(x<0){putchar('-');x=-x;}
  if(x>9){print(x/10);putchar(x%10+'0');}
  else putchar(x+'0');
  return;
}

const int N = 1e6 + 10;

struct Node {
  int v, nx;
} e[N << 1];

int n, h[N], tot, dep[N], stk[N], top, d[N], mx, ans, f[N], vis[N], sum[N]; 

void add(int u, int v) {
  e[++tot].v = v;
  e[tot].nx = h[u];
  h[u] = tot;
}

void dfs(int x, int fa) {
  dep[x] = dep[fa] + 1;
  mx = max(mx, dep[x]);
  d[dep[x]]++;
  for (int i = h[x]; i; i = e[i].nx) {
    int y = e[i].v;
    if(y == fa) continue;
    dfs(y, x);
  } 
}

signed main() {
  n = read();
  For(i,1,n-1) {
    int u = read(), v = read();
    add(u, v); add(v, u);
  }
  dep[0] = 0; 
  dfs(1, 0);
  For(i,1,n) {
    while(top && d[stk[top]] >= d[i]) top--;
    stk[++top] = i;
    sum[stk[top]] = sum[stk[top-1]] + d[stk[top]] * (stk[top] - stk[top-1]);
    ans = max(ans, sum[stk[top]]);
  }
  cout << ans << '\n';
  return 0;
}
```

---

## 作者：elbissoPtImaerD (赞：8)

显然最优时一定包含根。

发现：$\forall i\in[1,n)$，若在所有导出子树中，存在至少一个使得第 $i$ 层的宽度可以取到 $j$ 且 $j\le w_{i+1}$，那么在其中必然存在至少一个导出子树使得 $i+1$ 层的宽度也能取到 $j$。

考虑枚举导出子树的最大深度 $i$。

记 $g_{i,j}=\min\limits_{k=j}^i\{w_k\}$。  
那么导出子树的最大深度为 $i$ 的最优答案 $f_i=\sum\limits_{j=1}^ig_{i,j}$。

直接算是 $\mathcal{O(n^2)}$ 的。

发现：当固定 $i$ 时，$g_{i,j}$ 是单调不降的。  
那当 $i\gets i+1$ 时，只有 $g_{i,j}$ 的一段后缀会被更新成一个相同的数，剩下的可以直接从 $i$ 到 $i+1$。

那我们维护一个栈，将相等的一段只记录其开始位置，每次更新时直接从栈顶更新即可。

这样一共只有 $\mathcal{O(n)}$ 的入栈次数，所以总复杂度是 $\mathcal{O(n)}$ 的。

细节看代码。

```cpp
const int N=5e5+3;
int n,top,sk[N],w[N],d[N],s[N],ans;
// s_i 维护 栈底 i 个数之和 
// sk 栈维护相等的一段的开始位置 
std::vector<int>G[N];
void dfs(re int u)
{
	++w[d[u]];
	for(re int v:G[u]) !d[v]&&(d[v]=d[u]+1,dfs(v),7);
	return;
}
void Solve()
{
	rd(n);
	for(re int i=1,u,v;i<n;++i) rd(u),rd(v),G[u].pb(v),G[v].pb(u);
	d[1]=1,dfs(1);
	for(re int i=1;i<=n;++i)//枚举最大深度 
	{
		for(;top&&w[sk[top]]>=w[i];--top);
		sk[++top]=i,s[top]=s[top-1]+w[sk[top]]*(sk[top]-sk[top-1]),ans=std::max(ans,s[top]);
	}
	prt(ans,'\n');
	return;
}
```

---

## 作者：ask_silently (赞：4)

# 题目思路

通过 ~~看标签~~ 观察题目，发现此题一定和树有关，再加上数据范围，树形 DP 没错了。

一般的树形 DP 都是从根节点向下搜，但这里提供一个更加直观的 DP 思路：**从最后一层向第一层转移状态。** 是的，我们可以直接枚举层数，从而想到二维 DP 的状态：记 $dp_{i,j}$ 为第 $i$ 层选择节点数为 $j$ 的最大答案。而又因为当前一层的选择节点数一定小于等于下一层的选择节点数，所以状态转移方程也就出来啦：

$$dp_{i,j}=\max_{k=j}^{tr_{i+1}} \{dp_{i+1,k}\} + j$$

其中 $tr_{i+1}$ 为第 $i+1$ 层的节点总数。但我们不仅发现会空间爆炸，时间 $O(n^2)$ 也会爆炸。

但是求最大值我们可以用**单调队列**优化，从 $tr_{i+1}$ 到 $1$ 反着求从 $dp_{i+1,j}$ 到 $dp_{tr_{i+1}}$ 的最大值，这样做数值不会过期，所以省去了一些功夫。

而我们发现 $dp$ 数组的转移只与下一层有关，所以可以进行**滚动数组**来优化空间。这样时间与空间的问题都解决了。

接下来就是证明连通性。

对于每一层，我们优先取拥有子树的节点，则此层选择节点数一定比下一层小或相等，符合题意。此时，选全部父节点一定可行，且一定比只选一个或多个父节点的答案大。观看第二个样例，假设第二层只选择 $1$ 个父节点，则有可能从 $dp_{3,4}$ 转移过来，但此时并不合法，但是此时的答案一定没有选择两个父节点的答案优，因此不会被转移，而最优的答案一定是合法的，所以最终答案一定合法。

注意细节：在用滚动数组求 $dp$ 数组值的时候，一定把**已经没有用的值清空**，再次看一眼第二个样例，最后一层的 $dp_{5,5}$ 若是没有清空，则可能影响 $dp_{3,5}$，所以一定要清空！！！

# AcCode


```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=5e5+10;

int n,idx,sumc;
int head[N],nxt[N],ver[N],dp[N];

vector <int> tr[N];

deque <int> d;

inline int read(){
	int t=0,f=1;
	register char c=getchar();
	while (c<48||c>57) f=(c=='-')?(-1):(f),c=getchar();
	while (c>=48&&c<=57)t=(t<<1)+(t<<3)+(c^48),c=getchar();
	return f*t;
}

void add(int u,int v){
	nxt[++idx]=head[u];
	head[u]=idx;
	ver[idx]=v;
}

void shen(int dang,int ceng){
	tr[ceng].push_back(dang);
	for(int i=head[dang];i;i=nxt[i]){
		int dao=ver[i];
		shen(dao,ceng+1);
	}
	sumc=max(sumc,ceng);
}

int main(){
	n=read();
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		add(u,v);
	}
	shen(1,1);
	for(int i=1;i<=tr[sumc].size();i++) dp[i]=i;
	for(int i=sumc-1;i>=1;i--){
		while(!d.empty()) d.pop_back();
		for(int j=tr[i+1].size();j>=1;j--){
			while(!d.empty()&&d.back()<=dp[j]) d.pop_back();
			d.push_back(dp[j]);
			if(j<=tr[i].size()) dp[j]=d.front();
		}
		for(int j=tr[i+1].size()+1;j<=tr[i].size();j++) dp[j]=0;
		for(int j=1;j<=tr[i].size();j++) dp[j]+=j;
	}
	cout<<dp[1];
	return 0;
}

```

---

## 作者：ダ月 (赞：3)

### 题目分析：

有个直观的感受，就是从最深结点开始取，然后每次取 $w_i$ 个，保证 $w_i\le \min\{w_j\} ,j>i$。记录每一层结点的数目，然后构造答案序列 $d_i$，满足序列 $d_i$ 不降，并且 $d_i\le w_i$，并且 $d_i$ 所有元素和最大即可，显然这可以用单调栈完成。

那么，考虑这种取法的正确性：

若 $x$ 为叶子结点，显然取不取对后续无影响。。

若 $x$ 为非叶子节点，它的儿子数量显然 $\ge1$。若取了它，那么可以至少选择一个儿子来抵消它带来的宽度贡献。显然是要取的。

### 代码如下：

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=5e5+10;
//===
//缺省元，略
//===
vector<int> a[N];
int dep[N],md=0,tot[N],n;
void dfs(int x,int F){
	dep[x]=dep[F]+1,tot[dep[x]]++,md=max(dep[x],md);
	for(auto y:a[x]){
		if(y==F)continue;
		dfs(y,x);
	}
}ll rs=0,ans=0;
stack<pair<int,int> >st;
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		int x,y;scanf("%d%d",&x,&y);
		a[x].pd(y),a[y].pd(x);
	}dfs(1,0);
	for(int i=1;i<=md;i++){
		int sum=0;
		while(!st.empty()&&st.top().first>=tot[i])
			rs-=st.top().second*(st.top().first-tot[i]),
			sum+=st.top().second,st.pop();
		st.push({tot[i],sum+1});
		rs+=tot[i];
		ans=max(ans,rs);	
	}printf("%lld\n",ans);
	return 0;
}




```

时间复杂度：$O(n)$。

---

## 作者：_zuoqingyuan (赞：1)

只需要用到 dp 的一种做法，十分好写。

# 思路分析

首先，最优的选择一定包含节点 $1$。

考虑反证法：假设最优的导出子树根为 $u(u\ne 1)$，则将 $u$ 到 $1$ 路径上的点加入导出子树，一定优于以 $u$ 为根的导出子树，**与“最优的导出子树根为 $u$”相矛盾**，所以原结论一定成立。

确定根节点后，我们以 $1$ 为根做一遍 DFS，求出宽度 $w_i$。假设所有对于所有的 $i(i\ne 0)$，均满足 $w_i\ge w_{i-1}$，则将所有节点都选入答案中，即为最优解，也是答案上界。

不过答案上界不一定会取到，因为可能存在 $w_i<w_{i-1}$，此时不满足题目中宽度单调不减的要求，为了改变这种情况，一种可行的想法是改变所有 $w_i<w_j$ 的 $w_j(1\le j< i)$，令他们都变成 $w_i$。等所有 $w_i$ 都满足单调不减，就是一种可能的最优解。

因为 $w_i<w_{i-1}$，所以 $w_{i-1}$ 一定包含有叶子节点，所以不用担心改变 $w_{i-1}$ 后因父亲和儿子的关系而影响下几层的情况。

不过这种做法不一定是最优的，考虑下面这种情况。

![图片](https://cdn.luogu.com.cn/upload/image_hosting/9k99xb0w.png)

程序会分别在第 $1,2,3,4$ 层选择一个节点，但实际上最优解是选择第 $1,2$ 层的所有节点。这启示我们，对于处理 $w_i<w_{i-1}$ 这种情况，不一定必须改变 $w_j$，也可以直接舍弃第 $i$ 层以下的所有节点。

我们再倒着做一遍 dp。设最大深度为 $d$，则 $f_i$ 表示第 $i\sim d$ 层能选择的最多节点，$g_i$ 表示最优情况下第 $i$ 层选择的节点数。我们分情况讨论：

- 如果 $w_i\le g_{i+1}$：

这种情况下是可以直接继承下一层的信息。

$f_i\gets f_{i+1}+w_i,g_i\gets w_i$。

- 如果 $w_i> g_{i+1}$：

这种比较复杂，我们再分情况讨论（具体不详细解释，读者可自行思考）。

1. $d_i\ge g_{i+1}+f_{i+1}$：$f_i\gets w_i,g_i\gets w_i$

2. $d_i< g_{i+1}+f_{i+1}$：$f_i\gets g_{i+1}+f_{i+1},g_i\gets g_{i+1}$

然后就可以愉快的 AC 啦！

# Code：


```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N=1e6+10;
int n,idx,ver[N],to[N],nxt[N],de[N],d[N],f[N],g[N];
void add(int x,int y){
	to[++idx]=y,nxt[idx]=ver[x],ver[x]=idx;
}
void dfs(int x,int fa){
	de[x]=de[fa]+1;
	d[de[x]]++;
	for(int i=ver[x];i;i=nxt[i]){
		if(to[i]==fa)continue;
		dfs(to[i],x);
	}
	return;
}
int main(){
	scanf("%d",&n);
	for(int i=1,u,v;i<n;i++){
		scanf("%d %d",&u,&v);
		add(u,v);
	}
	dfs(1,0);
	for(int i=n;i>=1;i--){
		f[i]=d[i],g[i]=d[i];
		if(i==n)continue;
		if(g[i]<=g[i+1])f[i]+=f[i+1];
		else if(f[i]<g[i+1]+f[i+1])g[i]=g[i+1],f[i]=g[i]+f[i+1];
	}
	printf("%d\n",f[1]);
	return 0;
} 
```


如有错误，请指出。

---

## 作者：sQrtN (赞：1)

# Problem
给定一棵以 $1$ 为根的树，要求输出最大的导出子树的大小，该导出子树应满足宽度单调不减，即子树中深度为 $i+1$ 的节点数一定要**大于等于**深度为 $i$ 的节点数。那什么是导出子树？
引用讨论区中 @Planaria 的话
>子树必须包括所有儿子，而导出子树不一定包括所有儿子
# Analyze
首先，最大的导出子树（以下简称子树）一定以 $1$ 为根，因为以任意除 $1$ 外的节点为根时，一定可以通过不断将该节点的父节点加入子树成为新的父节点的方式使子树大小增大。

其次，考虑如何使子树最大，用 $dpt_u$ 记录节点 $u$ 在原树中的深度，用 $wis_i$ 记录在原树中深度为 $i$ 的节点数，将原树深度记为 $depth$，容易想到把深度最大（为 $depth$）的一层取满，然后在倒数第二层取 $\leq wis_{depth}$ 个节点，以此类推，直到取到根节点。

但还有一种情况，如图,容易得出选取 $1,2,3,4$ 四个点所得子树大小大于上述方式所选的 $1,2,5$ 三点，故我们在选取到第 $i$ 层时比较该层整层节点数与从下往上取所得答案，并取最大值向上转移，若无法理解则以图为例：当深度为 $2$ 时，$wis_2 = 3$，而从下转移上来的答案是 $1$（选取了节点 $5$，子树大小为 $1$），故将当前答案更新为 $3$ ，再继续向上转移。  
![](https://cdn.luogu.com.cn/upload/image_hosting/np4fc8y7.png)

总结来说，就是先 dfs ，得出每一层的节点数，再从最深一层向上转移，在第 $i$ 层取小于等于 $wis_{i+1}$ 个节点，若 $wis_i > wis_{i+1}$，则对**舍弃掉该层多余节点**和**舍弃下层节点**进行取舍，再向上转移
  
时间复杂度 $O(n)$
# Code
```cpp
#include<iostream>
using namespace std;
const int N = 5e5+5;
struct edge{
	int to,nxt;
}e[N];
int head[N],len,n,root,dpt[N],wis[N],depth,ans;
void insert(int u,int v){
	e[++len].to = v;
	e[len].nxt = head[u];
	head[u] = len;
}
void dfs(int u){
	wis[dpt[u]]++;
	for(int i = head[u];i ; i = e[i].nxt){
		dpt[e[i].to] += dpt[u];
		depth = max(depth,dpt[e[i].to]);
		dfs(e[i].to);
	}
}
int main(){
	scanf("%d",&n);
	for(int u,v,i = 1;i < n ;++i){
		scanf("%d%d",&u,&v);
		insert(u,v);
		dpt[v] = 1;
	}
    dpt[1] = 1;//一定选取根节点
	dfs(1);//处理出每一层节点数
	ans += wis[depth];//记录当前最大答案
	for(int i = depth - 1;i >= 1 ;--i){//从倒数第二层开始向上转移
		if(wis[i] > wis[i+1]){
			if(wis[i] >= ans + wis[i+1])
				ans = wis[i];
			else{
				ans += wis[i+1];
				wis[i] = wis[i+1];//将节点限制条件也传上来
			}
		} else ans += wis[i];
	}
	printf("%d",ans);
}
```

---

## 作者：wdsjl (赞：0)

# 题目大意

**导出子树** ：可以有节点不选的“子树”。

找到一棵最大的满足宽度单调不减的**导出子树**的大小。

# 分析

想要最优，对于单独的一层显然**全取**最优，所以我们定义 $dp_i$ 为第 $i$ 层全取的最大导出子树大小。

于是我们枚举层数，确定全选哪一层，取最优此时复杂度为 $O(n^2)$。

考虑省掉确定全选层数后取最优的时间复杂度。

定义易得最后的导出子树每层宽度单调不减，我们考虑维护一个具有单调性的数据结构：单调栈里面存层的宽度。

我们让栈中元素**单调递增**对于新的全选的一层，它从次栈顶（上一次选择的）宽度转移，新增的点数为：*这一层与次栈顶之间的层数*再乘上*这一层的点数*。在过程中取最优。

我们需要处理出来的信息就只有，每个点的层数，和每个层数的点数。

时间复杂度瓶颈在于第一遍搜索处理点的信息，后边转移复杂度为树的层数。复杂度为 $O(n)$ 可以通过。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6+10;

struct E{
	int to,ne;
}e[N*2];

int n,d[N],dp[N],dep[N],stk[N],top,h[N],cnt,mx,ans;

void add(int u,int v){
	e[cnt]={v,h[u]};
	h[u]=cnt++;
}

void dfs(int u,int fa){
	dep[u]=dep[fa]+1;
	d[dep[u]]++;
	mx=max(mx,dep[u]);
	for(int i=h[u];~i;i=e[i].ne){
		int v=e[i].to;
		if(v==fa)continue;
		dfs(v,u);
	} 
}

int main(){
	memset(h,-1,sizeof(h));
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
		add(y,x);
	}
	dep[0]=0;
	dfs(1,0);
	for(int i=1;i<=mx;i++){
		while(top&&d[stk[top]]>=d[i])top--;
		stk[++top]=i;
		dp[stk[top]]=dp[stk[top-1]]+d[stk[top]]*(stk[top]-stk[top-1]);
		ans=max(ans,dp[stk[top]]);
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：ivyjiao (赞：0)

写的第一道单调栈优化 dp。

先看数据范围：$1\leq n\leq 5\times 10^5$，而这题没有靠的上边的 $O(n\log n)$ 做法，考虑 $O(n)$。

我们考虑枚举每个节点，然后对于现在正在枚举的节点找它的子树，欸这怎么已经 $O(n^2)$ 了？重来。

我们考虑到以 $1$ 为根建立导出子树，这样一定是最优的，因为如果一个合法的且根不为 $1$ 的导出子树是最优的，那么从根一直跳祖先节点跳到 $1$ 一定合法且更优。

我们再枚举导出子树的最大深度，显然有一个明显但是错误的贪心为根据每层深度之间的关系来确定这个值，但是它为什么是错的？因为如果当前层节点特别多，我们就可以全选这一层放弃掉以后的层，或者选下一个节点很少的层，但是再下一层节点数可能更多。所以单凭这个无法确定，需要 $O(n)$ 枚举，这个省不了。

设 $g_{i,j}=\min_{k=j}^i w_k$，那么 $dp_i=\sum_{j=1}^i g_{i,j}$。其中 $dp_i$ 是最大深度为 $i$ 时的最大答案，$w_i$ 是第 $i$ 层的总节点数。

直接算又 $O(n^2)$ 了，考虑优化。

由于 $w_i$ 性质，$i$ 一定时 $g_{i,j}$ 单调不降。当 $i=i+1$ 时，只有最后一段会被更新成一个相同的数 $w_i$，剩下的不变。

所以我们可以维护一个单调栈（维护 $w_i$，单调递增），将不变的部分只记录其开始位置，每次 $i=i+1$ 时直接在栈顶更新即可。

式子为 $dp_i=dp_j+w_i\times(i-j)$，$j$ 为栈顶元素。

时间复杂度 $O(n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+1;
int n,u,v,d[N]={0,1},w[N],dp[N],st[N],l=1,ans;
vector<int>G[N];
void dfs(int u,int fa){
    w[d[u]]++;
    for(int i=0;i<G[u].size();i++){
        int v=G[u][i];
        if(v==fa) continue;
        d[v]=d[u]+1;
        dfs(v,u);
    }
}
int main(){
    cin>>n;
    for(int i=1;i<n;i++){
        cin>>u>>v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    dfs(1,0);
    for(int i=1;i<=n;i++){
        while(l&&w[st[l]]>=w[i]) l--;
        dp[i]=dp[st[l]]+w[i]*(i-st[l]);
        ans=max(ans,dp[i]);
        st[++l]=i;
    }
    cout<<ans;
}
```

---

## 作者：鱼跃于渊 (赞：0)

学长讲了，还看到有学弟写了题解，于是也来交一发。  
## 做法：  
首先根是肯定会被选的，不然易证不优。  
本来只想到了 $O(n^2)$ 的 dp，再想了想发现可以用单调栈优化到 $O(n)$。  
为什么能使用单调栈呢？我们设第 $i$ 层的节点数为 $w_i$，设在第 $i$ 层取的节点数为 $num_i$，则有 $num_i \le w_i$ 并满足序列 $num$ 不降。接下来要使 $num_i$ 的和最大，这显然满足单调性。  
具体怎么个做法呢？我们按深度从小到大处理，在弹出时减去祖先中多出的点，加上当前层的节点数，显然全选比少选更优。这样就可以得到当前层的答案。最后取每层答案的最大值就行了。  
## 代码：  
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=5e5+5;
struct node{
	int a,b;
};
int n,m,cnt,ans,dep[N],w[N];
vector <int> e[N];
stack <node> s;
void dfs(int u,int fa){
	dep[u]=dep[fa]+1;
	m=max(m,dep[u]);w[dep[u]]++;
	for(auto v:e[u])
		if(v!=fa) dfs(v,u);
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>n;
	for(int i=1,u,v;i<n;i++){
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(1,0);
	for(int i=1,sum;i<=m;i++){
		sum=0;
		while(!s.empty()&&s.top().a>=w[i]){
			cnt-=s.top().b*(s.top().a-w[i]);
			sum+=s.top().b;
			s.pop();
		}
		cnt+=w[i];
		s.push({w[i],sum+1});
		ans=max(ans,cnt);
	}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：lfxxx (赞：0)

学长给我们讲了就顺便来写一篇题解。

首先最优解一定包括根，不然一定可以从当前根连接一条到根的链。

然后考虑假若最大导出子树深度为 $n$ 则显然可以把深度为 $n$ 的节点全部选上，然后每个节点可以去选择它的父亲，重复这样的操作，一直到根，也可以在某一层多选节点。

因此考虑记录每个深度有多少个节点，按深度从小到大加入单调栈，但是在弹出节点时加上当前加入的数的大小表示选择他们的某个祖先。

那么就 $O(n)$ 地做完了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 2e6+114;
int dep[maxn],cnt[maxn],n;
vector<int> edge[maxn];
void dfs(int u,int fa){
	dep[u]=dep[fa]+1;
	cnt[dep[u]]++;
	for(int v:edge[u]){
		if(v==fa) continue;
		dfs(v,u);
	}
}
int ans;
stack< pair<int,int> > st;
signed main(){
	cin>>n;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		edge[u].push_back(v);
		edge[v].push_back(u);
	}
	dfs(1,0);
	int res=0;
	for(int i=1;i<=n;i++){
		int tot=0;
		while(st.size()>0&&cnt[i]<=st.top().first) res-=st.top().first*st.top().second,tot+=st.top().second,st.pop();
		tot++;
		res+=cnt[i]*tot;
		ans=max(ans,res);
		st.push(make_pair(cnt[i],tot));
	}
	cout<<ans;
}
```


---

## 作者：Penguin_Chen (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P9210)

~~因为我太蒟了，一开始连题解都没看懂，所以决定自己写一篇~~

首先，最优解一定包括根，不然都可以从当前导出子树的根连一条链到根节点。

然后，我们观察到，如果我们枚举导出子树的最大深度的话，显然，我们还要枚举导出子树的根的深度，时间复杂度显然是 $O(n^2)$ 的。

这就可以用到前面的结论了，最优解一定包括根，那么时间复杂度就是 $O(n)$ 的了（只用枚举最大深度）。那要怎么来维护呢？显然，导出子树满足从根节点到最深层**单调不减**，我们可以用**单调栈**来维护。

每次枚举导出子树的最大深度，对于第 $i$ 层的节点数量，如果小于等于第 $i-1$ 层的节点数量就弹栈（**节点数相等**也要弹栈，是因为我们可以将节点数相等的层放在一起，多记个节点数相等的数量就行）。

将第 $i-1$ 层（或者更多层？）的节点数改为第 $i$ 层的节点数就行（显然不可能更优），然后将第 $i$ 层的节点数压入栈，节点数相同的数量加一，以此类推。

### Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=5e5+1;
int ans;
int n,mx,res;//mx为最大深度，res为当第i层为最大深度时导出子树的最优解 
int num[maxn];//第i层的节点数 
int deep[maxn];//深度 
vector<int> edge[maxn];//邻接表 
int zh[maxn][3],tot=0;
inline int dfs(int u,int father)//dfs遍历深度 
{
	deep[u]=deep[father]+1;
	++num[deep[u]];//更新最大深度 
	mx=max(mx,deep[u]);
	for(int i=0;i<edge[u].size();++i)
	{
		int v=edge[u][i];
		if(v==father)continue;
		dfs(v,u);
	}
}
signed main()
{
	std::ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1,u,v;i<n;++i)
	{
		cin>>u>>v;
		edge[u].push_back(v);
		edge[v].push_back(u);
	}
	dfs(1,0);
	for(int i=1;i<=mx;++i)
	{
		int sum=0;//sum为和第i层节点数相同的层数的数量
		while(tot&&zh[tot][1]>=num[i])//1为节点数，2为相同节点数的层数的数量  
		{
			res-=zh[tot][2]*(zh[tot][1]-num[i]);//zh[tot][1]-num[i]为比第i层多的节点数 
			sum+=zh[tot][2];//将第i-1层（或者更多层？）的节点数改为第i层的数量就行（显然不可能更优）
			--tot;//因为节点数被改成了相同的，所以层数累加（上注） 
		}
		res+=num[i];//更新最优解 
		ans=max(ans,res);//更新答案 
		zh[++tot][1]=num[i];//压栈 
		zh[tot][2]=sum+1;
	}
	cout<<ans<<endl;
	return 0;
}
```


---


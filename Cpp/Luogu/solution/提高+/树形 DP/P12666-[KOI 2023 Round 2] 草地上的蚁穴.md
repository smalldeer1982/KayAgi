# [KOI 2023 Round 2] 草地上的蚁穴

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

KOI 公园的草地上，有一个蚂蚁们聚居的蚁穴。该蚁穴由 $N$ 个房间构成，并且存在恰好 $N - 1$ 条通道，连接着不同的两个房间。你可以通过这些通道，从任意一个房间出发，到达任何其他房间。这意味着蚁穴构成了一棵由 $N$ 个节点组成的树。每个房间都被赋予了从 $1$ 到 $N$ 之间的唯一编号。

每个房间最多只能居住一只蚂蚁。如果两只蚂蚁分别居住在通过通道直接相连的两个房间中，它们会感到不舒服。因此，在当前蚁穴中，任何一条通道所连接的两个房间中，最多只能有一个房间居住蚂蚁。

蚂蚁们非常聪明，因此在上述条件允许的情况下，它们已经安排好了最多数量的蚂蚁居住在蚁穴中。换句话说，如果现在再试图增加一只蚂蚁进入蚁穴，不论怎么重新分配蚂蚁的位置，都无法满足上述条件。

在一个晴朗的夏日，KOI 公园迎来了大量前来野餐的游客。当游客们在草地上玩耍时，蚁穴的土壤有可能被踩松，于是某些原本未直接相连的两个房间之间可能会新形成一条通道。此时，新形成通道的两个房间可能原本就已经通过一条通道直接连接，也可能不相连。换句话说，对于任意两个整数 $1 \leq i < j \leq N$，$i$ 号房间和 $j$ 号房间之间都可能新建一条通道，无论这两者之间原本是否已有通道。

由于新通道的形成，某些本来不直接相连的、各自居住着蚂蚁的房间之间可能会变得直接相连，从而导致这两只蚂蚁感到不适。因此，居住在蚁穴中的蚂蚁们可能需要重新调整其分布，以重新满足上述限制条件。

根据选定的 $(i, j)$，这种重新调整有时是可能的，但有时则不行。某些情况下，不论怎样调整蚂蚁的位置，都无法使当前所有蚂蚁在新图结构中继续满足限制条件，这时候，部分蚂蚁可能不得不离开蚁穴。

若对于某一对整数 $1 \leq i < j \leq N$，在 $i$ 号房间和 $j$ 号房间之间新建一条通道后，蚂蚁们可以通过适当的重新分布，在不驱逐任何一只蚂蚁的前提下继续满足限制条件，则称这对 $(i, j)$ 为**和平的对**。

给定蚁穴的结构，请编程计算在所有可能的新通道对中，属于和平的对的数量。

## 说明/提示

**样例 1 解释**

最多可以安排 $3$ 只蚂蚁，例如放在房间 $\{2, 3, 4\}$。已经直接连接的房间对之间即使新建通道，也不影响原有安排。因此，这种情况共有 $3$ 个和平的对。其余房间对间一旦建立通道，将无法维持当前蚂蚁数量。

**样例 2 解释**

最多可以安排 $3$ 只蚂蚁，例如放在房间 $\{1, 3, 6\}$。无论在哪两个房间之间新建通道，都能找到重新分配的方案使得 $3$ 只蚂蚁依然满足条件，因此总共有 $\binom{6}{2} = 15$ 个和平的对。

**限制条件**

- 所有输入均为整数。
- $2 \leq N \leq 250\,000$
- 所有 $u, v$ 满足 $1 \leq u, v \leq N$ 且 $u \ne v$
- 给定的蚁穴结构一定构成一棵树。

**子任务**

1.（8 分）$N \leq 16$  
2.（6 分）$N \leq 80$  
3.（18 分）$N \leq 400$  
4.（18 分）$N \leq 2\,000$  
5.（6 分）$N \leq 10\,000$  
6.（8 分）$N \leq 50\,000$  
7.（36 分）无附加限制

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
4
1 2
1 3
1 4```

### 输出

```
3```

## 样例 #2

### 输入

```
6
1 2
2 3
3 4
4 5
5 6```

### 输出

```
15```

## 样例 #3

### 输入

```
7
1 2
1 3
2 4
2 5
3 6
3 7```

### 输出

```
11```

# 题解

## 作者：Reilher_lover (赞：1)

水题。

前置：换根 dp。

# 思路分析


加入边 $(i,j)$ 后，树变为基环树。此时就是经典的基环树上的边最大独立集。

基环树上 dp 的一个经典做法是断环成链，我们删去加入边 $(i,j)$，分别以 $i,j$ 为根节点做一遍树上的边最大独立集，设 $f_i,f_j$ 分别表示 $i,j$ 为根节点，**不选** $i,j$ 的边最大独立集，那么基环树上的边最大权独立集就是 $\max\{f_i,f_j\}$。

这样就得到了一个 $O(n^2)$ 的法，首先以每个点为根节点做树上边最大独立集，求出所有 $f_i$，然后枚举每一对点对 $(i,j)$，如果 $\max\{f_i,f_j\}=res$（$res$ 是原树上的边最大独立集），那么 $(i,j)$ 就是合法方案的一种。

如果求出 $f_i$ 后，其实统计答案可以优化到 $O(n)$，问题是如何快速求出所有 $f_i$，不难想到换根 dp。

设 $f_{i,1/0}$ 表示**以 $i$ 为根**，$i$ 选/不选的最大独立集，设 $g_{i,1/0}$ 表示**在 $i$ 的子树中**，$i$ 选/不选的最大独立集，假设 $y$ 节点的父亲是 $x$。

如果我们已知 $f_{x,1/0},g_{y,1/0}$，如何计算 $f_{y,0}$？

首先，$f_{y,0}$ 包含 $g_{y,0}$。

如果 $x$ 不选，那么在 $y$ 子树之外的贡献为 $f_{x,0}-\max\{g_{y,0},g_{y,1}\}$，不难想，主要思考 dp 自下而上转移选择那个决策，换根时撤销就可以。

如果 $x$ 选，那么 $y$ 子树之外的贡献为 $f_{x,1}-g_{y,0}$。

可以得到：

$$f_{y,0}\gets g_{x,0}+\max\{f_{x,0}-\max\{g_{y,0},g_{y,1}\},f_{x,1}-g_{y,0}\}$$

$f_{y,1}$ 很好推，就不推了。

时间复杂度 $O(n)$。

# Code


```cpp
#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;
const int N=250005;
vector<int>G[N];
int n,f[N][2],g[N][2],res;
long long ans,sum;
void add(int x,int y){
	G[x].push_back(y);
}
void dfs1(int x,int fa){
	g[x][1]=1,g[x][0]=0;
	for(auto y:G[x]){
		if(y==fa)continue;
		dfs1(y,x);
		g[x][0]+=max(g[y][1],g[y][0]);
		g[x][1]+=g[y][0];
	}
	return;
}
void dfs2(int x,int fa){
	for(auto y:G[x]){
		if(y==fa)continue;
		f[y][0]=g[y][0];
		f[y][0]+=max(f[x][1]-g[y][0],f[x][0]-max(g[y][0],g[y][1]));
		f[y][1]=g[y][1];
		f[y][1]+=f[x][0]-max(g[y][0],g[y][1]);
		dfs2(y,x);
	}
	return;
} 
int main(){
	scanf("%d",&n);
	for(int i=1,u,v;i<n;i++){
		scanf("%d %d",&u,&v);
		add(u,v),add(v,u);
	}
	dfs1(1,0);
	f[1][0]=g[1][0],f[1][1]=g[1][1];
	res=max(f[1][0],f[1][1]);
	dfs2(1,0);
	for(int i=1;i<=n;i++)if(f[i][0]==res)sum++;//统计答案随便做
	for(int i=1;i<=n;i++){
		if(f[i][0]==res)ans+=1ll*(n-1);
		else ans+=sum;
	}
	printf("%lld\n",ans/2);
	return 0;
}
```

---

## 作者：cupWolf (赞：0)

## 题意

定义树上的两个节点是和平的，当且仅当在它们之间增加一条边后最大独立集不变。求树上的和平点对数量。

## 分析

实际上不需要基环树上最大独立集的知识也能做。

正难则反。考虑那些不和平的对。在所有最大独立集中，它们必须都被选中。否则我们可以以一个不都被选中的独立集为基础加边，那么加边后这个集合仍为独立集。

因此，该问题实际上等价于求最大独立集必然包含的节点数 $M$，而答案即为所有点对减去不和平的点对，即 $\binom{N}{2} - \binom{M}{2}$。

如何寻找最大独立集必然包含的节点？  
先求原树的最大独立集，再求不选某个点之后的最大独立集，若它们不等，则所有最大独立集必然包含这个点。

于是做法很明了了。换根 DP 即可。

### 如果你不会换根 DP

- 把根节点换成与根节点相邻的节点时，其他节点的子树不会改变（如下图绿框）。
  ![](https://cdn.luogu.com.cn/upload/image_hosting/d0yqawml.png)
- 由于树形 DP 只局限于一个子树， 因此，这些子树的 DP 值也不会改变。 
- 于是在换根之后，只需重新计算*两个节点的 DP 值即可。 

> *请注意：  
> 不能直接重新计算，否则会被菊花图卡成 $O(n^2)$。  
> 但是变化的部分也只有这两个节点。因此，计算出换根前后加或减了哪一项是 $O(1)$ 的。 

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long  // 有 N*(N-1)/2 的计算

const int maxn = 25e4+100;
vector<int> G[maxn];
int f[maxn][2];  // f[当前节点][当前节点选不选]
int tmp[2];
int mis, m;

void dfs(int u, int fa) {
	f[u][0] = 0;
	f[u][1] = 1;
	
	for (int v: G[u]) {
		if (v == fa) {
			continue;
		}
		
		dfs(v, u);
		
		f[u][0] += max(f[v][0], f[v][1]);
		f[u][1] += f[v][0];
	}
}

inline void chroot(int old_root, int new_root) {
	// 先把边断掉 
	f[old_root][0] -= max(f[new_root][0], f[new_root][1]);
	f[old_root][1] -= f[new_root][0];
	
	// 再建立新边
	f[new_root][0] += max(f[old_root][0], f[old_root][1]);
	f[new_root][1] += f[old_root][0];
}

void dp(int u, int fa) {
	if (fa != -1) {
		chroot(fa, u);
	}
	
	if (f[u][0] != mis) {
		m++;
	}
	
	for (int v: G[u]) {
		if (v != fa) {
			dp(v, u);
		}
	}
	
	if (fa != -1) {
		chroot(u, fa);
	}
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);

	int n;
	cin >> n;
	
	for (int i=1; i<=n-1; i++) {
		int u, v;
		cin >> u >> v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	
	dfs(1, -1);
	mis = max(f[1][0], f[1][1]);
	
	dp(1, -1);
	cout << (n*(n-1)/2 - m*(m-1)/2);
	
	return 0;
}
```

---


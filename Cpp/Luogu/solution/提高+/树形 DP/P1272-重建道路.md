# 重建道路

## 题目描述

一场可怕的地震后，人们用 $N$ 个牲口棚（编号 $1\sim N$）重建了农夫 John 的牧场。由于人们没有时间建设多余的道路，所以现在从一个牲口棚到另一个牲口棚的道路是唯一的。因此，牧场运输系统可以被构建成一棵树。

John 想要知道另一次地震会造成多严重的破坏。有些道路一旦被毁坏，就会使一棵含有 $P$ 个牲口棚的子树和剩余的牲口棚分离，John 想知道这些道路的最小数目。

## 说明/提示

### 样例解释

如果道路 $1-4$ 和 $1-5$ 被破坏，含有节点（$1,2,3,6,7,8$）的子树将被分离出来。

### 限制与约定

$1\le N\le 150$，$1\le P\le N$，保证给出的是一棵树。

## 样例 #1

### 输入

```
11 6
1 2
1 3
1 4
1 5
2 6
2 7
2 8
4 9
4 10
4 11
```

### 输出

```
2
```

# 题解

## 作者：big_news (赞：160)

个人觉得题解里面的那个转移并不是很好理解，有些基础的东西并没有把它讲明白，所以说说我自己的理解。

**状态设计**

首先可以有这么一个想法：设 $f[u][s]$ 表示在节点 $u$ ，获得大小为 $s$ 的子树所需要删除的边的个数。

**转移**

考虑对于一个 $s$ ，我们需要找到一种“空间”的分配方案。讲的形象一点，设 $s(v_i)$ 表示在子树 $v_i$ 内我们留下的节点个数，其中 $v_i$ 表示当前节点 $u$ 的第 $i$ 个子节点；再设 $c(v_i)$ 表示我们在子树 $v_i$ 中留下 $s(v_i)$ 个节点所删除的边的数量。那么现在我们要做的事情就是：对于全部 $v_i$ ，找到一种 $s(v_i)$ 的分配方式，使得 $∑s(v_i) = s$ ，且 $∑c(v_i)$ 最小，然后我们就可以令 $f[u][s] = ∑c(v_i)$，也就完成了状态的转移。

然后上面那句“对于全部 $v_i$ ，找到一种 $s(v_i)$ 的分配方式，使得 $∑s(v_i) = s$ ，且 $∑c(v_i)$ 最小”，你不觉得这是一个背包么？

然后这个时候你就会发现我们所设的 $f[u][s]$ 这个状态实际上是不完全的。不考虑滚动数组，我们应该设 $f[u][k][s]$ 表示考虑节点 $u$ 的前 $k$ 个子节点，取 $s$ 个节点所需要的最小花费，这就是一个背包。

那么可以写出一个转移：$f[u][k][s] = \min(f[u][k-1][s] + 1, f[u][k-1][s-s_v] + f[v][k_v][s_v])$，其中 $k_v$ 表示 $v$ 的所有子节点数量，$s_v$ 表示在子树 $v$ 上选取的点的数量。

上面那个方程其实很好理解：前面表示不从子树 $v$ 选取节点，那么要删除 $(u,v)$ 这条边，答案 $+1$ ；后面是在考虑子树 $v$ 内选取的节点个数。

然后上面那个方程它一点也不可爱，考虑滚动掉 $k$ 这一维，方程变成 $f[u][s] = \min(f[u][s] + 1, f[u][s-s_v] + f[v][s_v])$。

这基本上就做完了，但是在转移的顺序上还有点小问题。
我们发现 $f[u][k][s]$ 总从 $f[u][k-1][s]$ 或 $f[u][k-1][s-s_v]$ 的状态更新。也就是说，去掉 $k$ 这一维，我们需要保证 $f[u][s-s_v]$ 比 $f[u][s_v]$ 后更新，这样 $f[u][s_v]$ 才是我们想要用来转移的“上层状态”。那么也就是倒序枚举 $s$ 去更新。

于是我们只需要枚举 $s$，然后再枚举 $s_v$，去转移就好了。

**考虑答案的统计**

上面那个状态 $f[u][s]$ 里面， $u$ 实际上是强制选择的，否则就缺少一个能把若干子树连接起来的“桥梁”。但是贪心的想，我们不一定非得强制选择某一个节点啊。那么答案应该对所有的 $f[u][p]$ 取一个 $\min$ 。然后还有一个问题，就是再某一个非根节点的位置，我们想要取出这棵子树，还得把这个节点和它的父亲节点断掉，那么答案还得 $+1$ ，细节见代码。

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
using namespace std;
const int CN = 160;
class fs{
  public: int to,nxt; void init(int t,int n) {to=t;nxt=n;}
}E[CN * 2];
int hd[CN],ecnt = 0;
void add(int x,int y) {E[++ecnt].init(y,hd[x]);hd[x]=ecnt;}

int n,P,ans,sum[CN],f[CN][CN]; // sum[u] 表示子树 u 的大小
void dfs(int u,int p){
    sum[u] = 1; f[u][1] = 0; // 初始时不考虑子树，因此 f[u][1] = 1
    for(int k=hd[u];k;k=E[k].nxt){
        int v = E[k].to;
        if(v == p) continue;
        dfs(v, u); // 求出子树的答案
        sum[u] += sum[v]; // 累加大小
        
        for(int s=sum[u]; s; s--){ // 考虑背包问题的更新方式，那么一定要每次都更新一下
            f[u][s] += 1; // 实际上是 f[u][k][s] = f[u][k-1][s] + 1 ，滚动了 k 这一维
            for(int sv=0;sv<=min(s-1, sum[v]);sv++) // s-1 为了强制选根
                f[u][s] = min(f[u][s], f[u][s - sv] + f[v][sv]);
        }
    }    
}

int main()
{
    //freopen("p1272.in","r",stdin);

    scanf("%d%d",&n,&P);
    for(int i=1;i<n;i++){
        int x,y; scanf("%d%d",&x,&y);
        add(x,y); add(y,x);
    }

    memset(f,0x3f,sizeof(f));
    dfs(1,0);
    ans = f[1][P]; for(int i=2;i<=n;i++) ans = min(ans, f[i][P] + 1); // 加上与父亲之间的那条边
    printf("%d", ans);

    return 0;
}
```

---

## 作者：ysj1173886760 (赞：153)

貌似有的题解没有讲清楚 这里给出一点补充吧。

最常见的就是dp[i][j]为以i为根的子树，保留j个节点拆掉的最小边数。

可以发现题解中各种初始化和转移琳琅满目。

有的-1，有的-2.

其实就是因为dp状态没有讲清楚。

分着来说吧，dp[i][j]表示以i为根的子树，保留j个节点，且当前子树与父节点相连，拆掉的最小边数。

每个状态代表一棵子树，这个子树与父节点相连。
那么初始化的话dp[i][1]=son[i],一开始都是不连儿子只连父亲

那么转移的那个就变成了dp[u][j]=max(dp[u][j-k]+dp[v][k]-1)

为什么减1呢，因为注意到我们一开始点都是不与儿子相连的，我们通过dp的过程一步一步把他们连起来。

那么对于u->v这个边，一开始在初始化u的时候已经被减掉了，因为他是连接儿子的边，而v->u这个边并没有，因为这个连向父亲的边，我们要通过v转移，就得用u->v这个边，所以就得补回来。

而且最终算的时候，除了根节点无父亲外，其他的都要和父节点断开，也就是边数+1

第二种就是dp[i][j]表示以i为根的子树，保留j个节点，且当前子树不与父节点相连，需要拆掉的最小边数。

那么我们的初始化就变成了dp[i][1]=deg[i]

也就是把与i相连的所有边全部拆掉。

转移自然就变成了dp[u][j]=max(dp[u][j-k]+dp[v][k]-2)

和上面一样，因为u->v的边和v->u的边都已经在初始化的时候被减掉了，所以这时候要把他们连起来就得减去他们两个造成的贡献，也就是2.

那么答案就是dp[i][p] 这个就没有别的东西了，因为已经成为了一个独立的联通块了。

还有要注意的就是dp的范围。

当前节点必须保留，不然无法连接子节点。子节点的话也需要有一个，否则就不需要减去那点贡献了。

总的来说，dp还是要考虑合理性的

---

## 作者：s_ShotღMaki (赞：74)



## 1.对题目的理解

通过读题，很明显此题是一道树形DP，而且是比较经典的树形背包问题，本质上是分组背包，所谓分组背包，即在选择物品的时候，一开始将物品分为好几组，在选择时，可以从每一组中**至多选择一件物品**，问如何获得最大的价值，所以我们每次可以枚举这个组数，用i表示第几组，用j表示体积，用k来表示选择的物品，伪代码如下

```cpp
for (int i = 0到组数)
	for (int j = max_v到0)
		for (int k = 此组所有物品)
			f[j] = max (f[j], f[j - v[k]] + w[k])
```


在树也是同样的道理，每个子树其实就是每一个组，在里面选择，但不同的是，在这里我们用**dfs**来实现

## 2.大体思路
1.对于状态转移方程和初始化我也不想多说，因为别人的题解都有，这里我们用$f\left ( i,j \right )$来表示第i个点为跟的子树，保留j个点（包括自己）删去边的最小值，我们用$a[i]$l来记录出度， 也就是几个儿子，因此：

初始化：

$$f\left ( i,1 \right ) = a[i]$$



方程：

$$f\left ( now,j \right ) = max\left ( f\left ( now,j \right ),f\left ( now,j - k \right ) + f\left ( v,k \right )-1 \right )$$

其实这个转移方程没什么特殊的，其实就是一个树上背包的板子，你肯定会问：板子题为什么还这么难做，因为这个题的坑点稍微有一点多，思维难度稍微有一点大，比如说状态转移方程中的-1，还有其他的一些东西在接下来的讲解中就会更加深入

2.我跟别人的题解其实不太一样，我不知道是我跟大家不一样还是大家都没有读题，其实题目有说：每行2个整数I和J，表示节点I是节点J的父节点，**也就是说这是一棵树，而且是有根的**，所以我们并不用像其他题解那样人云亦云，全都去建双向边，既然有根，那么我们直接可以建**单向边**解决，而且更加轻松，很显然，跟没有入度，所以我们可以记录一下每一个点的入度$b[i]$，所以我们找根可以这样找，顺便初始化：


```cpp
for (int i = 1; i <= n; i ++)
{
	if (!b[i]) root = i;
	f[i][1] = a[i];
}
```

3.现在我们可以开始DP了，找出根以后直接从根开始DP，一路往下，这里我们可以开两次变量，一个是temp，一个是sum，**temp表示的当前的v的子树中的节点个数**，**sum表示当前的now节点下所有的子树的节点个数**，每次遍历完一个v就累加，其实也就是背包的一个容量罢了，每次return一下sum，由于这个节点个数要包括自己，所以初始值我们必须设置为1

4.重头戏来了，一个最大的问题，为什么我们的状态转移方程中最后要减去1呢？我先在这里放一张图，有助于理解

![](https://i.loli.net/2019/08/25/3WRSgEjhf7bQM9D.png)

这张图很显然就是我们的样例而已，他可以很好的说明问题，举个例子，比如说我们的v是5这个节点的时候，我们在更新$f\left ( 1,2 \right )$时，可以分给他保存一个，1节点保存一个那么就是$f\left ( 1,1 \right ) + f\left ( 5,1 \right ) = 4 + 0 = 5$了，而很显然答案是3，这是为什么呢，**这是因为没有考虑v和now节点之间相连的那一条边**，很显然是不可以拆掉的，所以拆掉的边数必须要减去1，代码如下：

```cpp
inline int dfs (int now)
{
	int temp; int sum = 1;
	for (int i = head[now]; i; i = edge[i].next)
	{
		int v = edge[i].v;
		temp = dfs (v); sum += temp;
		for (int j = sum; j >= 1; j --)
			for (int k = 1; k < j; k ++)
					f[now][j] = min (f[now][j], f[now][j - k] + f[v][k] - 1);
	}
	return sum;
}
```

5.那么大部分的任务我们都完成了，剩下的就是处理答案，我一开始也犯了一个小错误，直接输出了$f\left ( root,p \right )$，拿了72分，但这个显然是不对的，因为我们要获得一颗子树，并不是非得从根节点，因此我们需要枚举每一个节点为根的小子树，看看哪一个是最小的


```cpp
for (int i = 1; i <= n ; i ++)
{
	if (f[i][p] < ans) ans = f[i][p] + 1;
}
```

6.你会有疑问了，为什么是 + 1呢，这就是本题的另外一个坑点，你可以拉上去看上面那一张图片，我们再举个例子，样例别的不变，如果p变成了4怎么办，我们用眼睛看可以很清楚的看到，保留整颗以2为根的子树是最明智的，只需要砍去一条边，然而我们DP完之后$f\left ( 2,4 \right )$的值却为0，因为不需要砍掉任何边，**而需要砍掉上面的那一条边**，这里我们就忽略掉了，所以需要+1来解决问题


## 3.完整代码
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<queue>
#include<cstring>

#define N 310

using namespace std;

inline int read ()
{
    int f = 1, x = 0;
    char ch;
    do {ch = getchar (); if (ch== '-') f = -1;} while (ch < '0' || ch > '9');
    do {x = x * 10 + ch - '0'; ch = getchar ();} while (ch >= '0' && ch <= '9');
    return f * x;
}

struct node
{
	int u, v, next;
} edge[N];
int n, p;
int cnt, head[N];
int f[N][N];
int a[N];
bool b[N];
int root;
int ans = 0x3f3f3f3f;

inline void add (int u, int v)
{
	edge[++cnt].v = v;
	edge[cnt].next = head[u];
	head[u] = cnt;
}

inline int dfs (int now)
{
	int temp; int sum = 1;
	for (int i = head[now]; i; i = edge[i].next)
	{
		int v = edge[i].v;
		temp = dfs (v); sum += temp;
		for (int j = sum; j >= 1; j --)
			for (int k = 1; k < j; k ++)
					f[now][j] = min (f[now][j], f[now][j - k] + f[v][k] - 1);
	}
	return sum;
}

int main ()
{
	n = read (); p = read ();
	int x, y;
	for (int i = 1; i <= n - 1; i ++)
	{
		x = read (); y = read ();
		a[x] ++; b[y] = 1;
		add (x, y);
	}
	memset (f, 0x3f3f3f3f, sizeof (f));
	for (int i = 1; i <= n; i ++)
	{
		if (!b[i]) root = i;
		f[i][1] = a[i];
	}
	dfs (root);
	ans = f[root][p];
	for (int i = 1; i <= n ; i ++)
	{
		if (f[i][p] < ans) ans = f[i][p] + 1;
	}
	printf ("%d", ans);
	return 0;
}
```
~~我喜欢我的码风~~

可以抄题解，但是你要学会哦

## 4.推几道类似的树上背包[P1273](https://www.luogu.org/problem/P1273)，[P2014](https://www.luogu.org/problem/P2014)，[P2015](https://www.luogu.org/problem/P2015)


---

## 作者：张景 (赞：35)


- ### dp[u][j]=min(dp[u][j],dp[u][j-k]+dp[v][k])



- 树形dp 思路略微不同。。。


- f[i][j] 第i个节点切掉j个节点的所需最少边数

- dp[u][j]=min(dp[u][j],dp[u][j-k]+dp[v][k])  (u当前节点，v子节点)
- 细节比较多。。代码中解释


```cpp

#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,p,k,head[160],rd[160],dp[160][160],siz[160],ans=0x3f3f3f;
struct edge {int to,next;} ed[330];
void adde(int u,int v){ed[++k].to=v;ed[k].next=head[u];head[u]=k;}

void dfs1(int u,int fa)
{
	siz[u]++;
	for(int i=head[u];i;i=ed[i].next)
	{
		int v=ed[i].to;
		if(v==fa) continue;
		dfs1(v,u);
		siz[u]+=siz[v];
	}
	dp[u][siz[u]]=1;//如果切掉整棵子树，只需切掉与父节点的连边 
	dp[u][0]=0;//不切 
}

void dfs2(int u,int fa)
{
	for(int i=head[u];i;i=ed[i].next)
	{
		int v=ed[i].to;
		if(v==fa) continue;
		dfs2(v,u);
		for(int j=siz[u]-1;j;j--)//我切多少 
		for(int k=0;k<=j;k++)//我的儿子切多少 
		dp[u][j]=min(dp[u][j],dp[u][j-k]+dp[v][k]);
		//我切j个节点切的最少边数=min 我切j-k个节点的最少边数+我的儿子切k个节点的最少边数 
	}
	if(siz[u]-p>=0)//有那么多节点 
	ans=min(ans,dp[u][siz[u]-p]+dp[u][siz[u]]);
	//min 切掉siz[u]-p个节点(剩P个节点)的最少边数+分开我与父亲的边 
}

int main()
{
	scanf("%d%d",&n,&p);
	memset(dp,0x3f3f3f,sizeof(dp));//初始化为最大值 
	for(int i=1;i<=n-1;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		adde(u,v);adde(v,u);
	}
	dfs1(1,1);//求siz数组 & 初始化 
	dp[1][siz[1]]=0;//根节点不需要与父节点分开  （没有父亲。。。） 
	dfs2(1,1);//树形dp 
	printf("%d",ans);
	return 0;
}

```

---

## 作者：beretty (赞：32)

```cpp
//树形DP
//大致思路：
//递归操作，f[i][j]表示保留i为根的子节点。
//c数组记录点的度。
//因为这是一棵树，所以每个点的度为1
//然后随便设一个根，我设的1为根，1的根就为0.
//递归时传入两个参数，为当前节点和当前节点的根。
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
```
# define LL 153
```cpp
int hea[LL],num,n,p,a,b,c[LL],f[LL][LL],r[LL];
int ans=0x3f3f3f3f;
struct edge{
    int nex,to;
}edge[LL<<1];
void add_edge(int from,int to)
{
    edge[++num].nex=hea[from];
    edge[num].to=to;
    hea[from]=num;
}
void dfs(int u,int root)
{
    int i,j,k;
    f[u][1]=c[u];//只选这个根自己需要切掉几条边。。
    for(i=hea[u];i;i=edge[i].nex)
    if(edge[i].to!=root)//如果是根就不要搜了
    {
        dfs(edge[i].to,u);
        for(j=p;j>=1;j--)
          for(k=1;k<j;k++)
            f[u][j]=min(f[u][j],f[u][k]+f[edge[i].to][j-k]-2);// emmm,至于为什么-2.。个人认为本题最坑的一点，害的我想了好久，一定是我太菜了，因为在初始化的时候已经把所有与u和edge[i].to相连接的节点给砍掉了，但是u和edge[i].to相连的的度应该保留，而这段相连的度，在u中加了一次，在edge[i].to中也加了一次，所以应该-2。
    }
}
int main()
{
    int i,j;
    scanf("%d%d",&n,&p);
    for(i=1;i<n;i++)
    {
        scanf("%d%d",&a,&b);
        c[a]++,c[b]++;//记录a,b的度。
        add_edge(a,b),add_edge(b,a);//建双向边，因为1也不是这棵树的真根，只是因为方便设的。
    }
    memset(f,0x3f,sizeof(f));
    dfs(1,0);
    for(i=1;i<=n;i++) ans=min(f[i][p],ans);
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：依依 (赞：10)

正解:树形DP

首先定义状态很重要.....

随便以一个点为根

f[i][j]表示以i为根，保留j个节点要砍掉的最少边数

初始化：首先极大值

f[i][0]=0,f[i][1]=与i相连的边数

设边  u - > v

f[u][j]=min(f[u][j],f[u][k]+f[v][j-k]-2)

为什么要减2？

答：我们通过v更新u，就要保留u->v 此条边，但是

想想我们的初始化，我们在f[u][k]中砍掉了这条边一次

又在f[v][j-k]中砍掉了这条边一次，所以要加回来  

[搞推销的](http://www.cnblogs.com/adelalove/p/8875163.html)  

~~O(∩_∩)O~~~

---

## 作者：I_AM_HelloWord (赞：10)

这里写的比较详细：[多叉树的树形背包常见建模方法](http://blog.csdn.net/no1\_terminator/article/details/77824790)

我们设dp[k][i][j]表示以i为根的子树，在前k个儿子中，分离出一个大小为j的子树（必须包含i），所需要最少的操作次数。

那么我们每计算到第k+1个新的儿子v时(full\_son[v]表示v的儿子个数)，

dp[k+1][i][j]=min(dp[k][i][j-t]+dp[full\_son[v]][v][t]);

由于一个树形关系，我们需要在一个dfs上进行dp，即先dfs(v),然后更新dp[k+1][i][j]。

这个k的一维显然可以用滚动数组优化掉。

那么就是

j=m->1
t=1->j
dp[i][j]=min(dp[i][j-t]+dp[v][t]);

同时，dp一律要注意初始化，即刚开始时所有的dp[i][1]=du[i]（du[i]表示与i连边的节点数，又称i的入度（树是无向边哟！））


参考代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int INF=0x3f3f3f3f;
const int N=201;
struct Edge{
    int to,next;
}e[N*2];
int du[N],a[N],dp[N][N];
int n,k,res=INF,EdgeCnt=0;
void addedge(int u,int v){
    int p=++EdgeCnt;
    e[p].to=v;e[p].next=a[u];
    a[u]=p;
}
void dfs(int u,int fa){
    dp[u][1]=du[u];
    for (int p=a[u];p;p=e[p].next){
        int v=e[p].to;
        if (v!=fa){
            dfs(v,u);
            for (int j=k;j>=1;j--)
                for (int k=1;k<=j;k++)
                    dp[u][j]=min(dp[u][j],dp[u][j-k]+dp[v][k]-2);
        }
    }
    res=min(res,dp[u][k]);
}
int main(){
    scanf("%d%d",&n,&k);
    memset(dp,0x3f,sizeof(dp));
    for (int i=1;i<n;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        addedge(u,v);
        addedge(v,u);
        du[u]++;du[v]++;
    }
    dfs(1,0);
    printf("%d",res);
    return 0;
}
```

---

## 作者：Starlight_Glimmer (赞：9)

树形DP

f[i][j]:结点i保留j个结点最少需要删去的边数

状态转移：（v是u的子节点）f[u][j]=min(f[u][j],f[u][j-k]+f[v][k]-1);
```cpp
#include<cstdio>
#include<vector>
#include<cstring>
using namespace std;
#define MAXN 150
int N,P;
vector<int>G[MAXN+5];
int son[MAXN+5],sum[MAXN+5];
//son:the num of i's son     sum:the num of all the son of the tree i
int f[MAXN+5][MAXN+5];
//f[i][j]:结点i保留j个结点最少需要删去的边数
void dp(int u)
{
	sum[u]=1;//notice
	if(!G[u].size())//leaf
	{
		f[u][1]=0;
		sum[u]=1;
		return ;
	}
	for(int i=0;i<G[u].size();i++)
	{
		int v=G[u][i];
		dp(v);
		sum[u]+=sum[v];
		for(int j=sum[u];j>=0;j--)
			for(int k=1;k<j;k++)
				f[u][j]=min(f[u][j],f[u][j-k]+f[v][k]-1);
	}
}
int main()
{
	scanf("%d %d",&N,&P);
	for(int i=1;i<N;i++)
	{
		int u,v;
		scanf("%d %d",&u,&v);
		G[u].push_back(v);
		son[u]++;
	}
	memset(f,0x3f,sizeof(f));
	for(int i=1;i<=N;i++)
		f[i][1]=son[i];//只剩一个节点（itself），所有的儿子都剪掉
	dp(1);
	int ans=f[1][P];
	for(int i=2;i<=N;i++)
		ans=min(ans,f[i][P]+1);
	printf("%d\n",ans);
}
```

---

## 作者：逆时针的记忆 (赞：7)

正解:树形DP

随便以一个点为根,f[u][j]表示以u为根，保留j个节点要砍掉的最少边数

初始化：

f[u][0]=0。

f[u][1]=与u相连的边数

v是u的son，u是v的daddy

f[u][j]=min(f[u][j],f[u][k]+f[v][j-k]-2)

转移时枚举删除的边数

至于为什么要减2？

我们通过v更新u，就要保留u到v 这条边，但是

我们的初始化在f[u][k]中砍掉了这条边一次

又在f[v][j-k]中砍掉了这条边一次，在转移时断掉了两次，

所以答案要减二。

 

---

## 作者：Azuree (赞：6)

[查看原题请戳这里](https://www.luogu.org/problem/P1272)

## 状态设计

一开始我设计$f[i][j]$表示在以$i$为根节点的子树上保留$j$个节点需要断掉的最少的边数，但是这样设计状态虽然思考起来比较直观，但是状态转移貌似比较麻烦，所以我们直接用$f[i][j]$表示在以$i$为根的子树上删去$j$个节点需要去掉的最少的边数，$ans=\min(f[u][siz[u]-p]+f[u][siz[u]])$，其中$siz[u]-p$是我们要在这颗以$u$为根节点的子树上删去的点数，$f[u][siz[u]]$是把以$u$为根节点的子树和这颗树的剩余部分分开需要删去的边数。

若$u$为非根节点，则$f[u][siz[u]]=1$（把$u$和$father[u]$之间的边删去）；若$u$为根节点，则$f[u][siz[u]]=0$（根节点没有父亲节点，不用删）。

## 状态转移

状态转移和分组背包相似，用到了[泛化物品](https://baike.baidu.com/item/%E6%B3%9B%E5%8C%96%E7%89%A9%E5%93%81/810495?fr=aladdin)的思想。

我们遍历这颗树，这个过程相当于在枚举组别（以同一个节点$u$为根的$f[u][1-siz[u]]$这些状态当成物品分到一组）。

```cpp
f[u][j] = min(f[u][j],f[u][j - k] + f[v][k]);
```

这就是状态转移方程，尝试在当前这颗子树中选择一些节点尝试能不能得到更优的状态。

## 代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
#define INF 100000000000
#define re register
#define rep(i,a,b) for(int i = (a); i <= (b); i++)
#define qwq printf("qwq\n");
#define int long long

using namespace std;

long long read()
{
	register long long x = 0,f = 1;register char ch;
	ch = getchar();
	while(ch > '9' || ch < '0'){if(ch == '-') f = -f;ch = getchar();}
	while(ch <= '9' && ch >= '0'){x = x * 10 + ch - 48;ch = getchar();}
	return x * f;
}

int n,p,cnt,ans,x,y,z,d[1000005],f[155][155],siz[1005];

struct edge{
	int to,nex,w;
}e[2000005];

void add(int x,int y)
{
	e[++cnt].to = y;
	e[cnt].nex = d[x];
	d[x] = cnt;
}

void dfs1(int u,int fa)
{
	siz[u] ++;
	for(int i = d[u]; i; i = e[i].nex)
	{
		int v = e[i].to;
		if(v == fa) continue;
		dfs1(v,u);
		siz[u] += siz[v];
	}
	f[u][0] = 0;
	f[u][siz[u]] = 1;
}

void dfs2(int u,int fa)
{
	for(int i = d[u]; i; i = e[i].nex)
	{
		int v = e[i].to;
		if(v == fa) continue;
		dfs2(v,u);
		for(int j = siz[u] - 1; j; j--)
			for(int k = 0; k <= j; k++)
				f[u][j] = min(f[u][j],f[u][j - k] + f[v][k]);
	}
	if(siz[u] >= p) ans = min(ans,f[u][siz[u] - p] + f[u][siz[u]]);
}

signed main()
{
	n = read(); p = read();
	ans = INF;
	for(int i = 1; i < n; i++)
	{
		x = read(); y = read();
		add(x,y); add(y,x);
	}
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= n; j++)
			f[i][j] = INF;
	dfs1(1,1);
	f[1][siz[1]] = 0;
	dfs2(1,1);
	printf("%lld\n",ans);
    return 0;
}

```

---

## 作者：bzcxl (赞：4)

题面:https://www.luogu.org/problem/P1272

这题是一道树形dp

设dp[i][j]表示以i为根的节点保留j个点所需要砍掉的边数,cnt[i]为i的子节点数,size[i]表示以i为根的子树的节点数

则可以得到初始状态:

dp[i][1]=cnt[i],(只留下根节点则需要把所有与子节点的连边砍掉);dp[i][0]=0;

Otherwise, dp[i][j]=Inf(极大值)

对于每一个子节点,我们可以分配一定的点数给它,则有状态转移方程:

dp[i][j]=min(dp[i][j],dp[i][k]+dp[s][j-k]-1)  (1<=i<=n;0<=j<=size[i];1<=k<j;s为i的子节点)

其余细节见程序注释
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define MAXN 151
using namespace std;
int n,p;
int root;
int ans;
bool bj[MAXN];
int size[MAXN],cnt[MAXN],dp[MAXN][MAXN];
int head[MAXN],h;
struct Edge
{
	int v,next;
}edge[MAXN];
void add(int u,int v)
{
	h++;
	edge[h].v=v;
	edge[h].next=head[u];
	head[u]=h;
}
void dfs(int u)
{
	size[u]=1;
	dp[u][1]=cnt[u];
	dp[u][0]=0;
	//初始化 
	for(int i=head[u];i;i=edge[i].next)
	{
		int v=edge[i].v;
		dfs(v);  // 递归 
		size[u]+=size[v];//从搜索角度看是递归的回溯,,从dp(背包)的角度来看就是更新背包大小 
		for(int j=size[u];j>=0;j--) //倒序,使每个边只能被删一次 
		{
			for(int k=1;k<min(size[v]+1,j);k++) //这里的循环上界,稍微加了点优化,当k>size[v]时,dp[v][k]显然为Inf, 无法对答案作贡献 
			{
				dp[u][j]=min(dp[u][j],dp[u][j-k]+dp[v][k]-1); //算u的子树时把和v的连边也砍掉了,因此这里要减去1,即把砍掉的u-v边补回 
			}
		}
	}
}
int main()
{
	cin>>n>>p;
	for(int i=1;i<n;i++)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		add(a,b);    
		bj[b]=1;
		//因为是有向边,所以我选择找出根,建双向边的话就不需要找根了,任意选即可,只需要注意深搜时注意判断回边 
		cnt[a]++;
	}
	memset(dp,63,sizeof(dp));
	for(int i=1;i<=n;i++) 
	{
		if(!bj[i])
		{
			root=i;    //找根 
			break;
		}
	}
	dfs(root);
	ans=dp[root][p];
	for(int i=1;i<=n;i++) ans=min(ans,dp[i][p]+1);  
	//根据我们的状态定义,我们求得只是该子树保留p个节点所需要砍的边
	//因此,除了根节点,都还需要再断开该节点与其父节点的连边 
	cout<<ans;
}
```


---

## 作者：白菜道士 (赞：4)

### 食用 [blog](https://vasairy.blog.luogu.org/)  更佳
#### 题意描述
- ##### 有一棵树
- ##### 删掉一些节点
- ##### 使剩下的节点仍为一棵树，并恰好等于P;
- ##### 求删的最小次数
------
#### 主要思路：树形DP
- ##### 首先输入整棵多叉树
- ##### 然后将多叉树转为二叉树（方便计算）
- ##### 求删掉该节点后，会有多少节点挂掉
- ##### ~~最后将二叉树转成答案~~
- ##### 遍历二叉树 DP+记忆化 求解
------
#### 如何 **DP** ？
- ##### 设 dp( i , j )为在节点i删j个节点的最小次数
- ##### 对于节点i，有删和不删两种情况
- ##### 如果删，则
```cpp
	dp( i , j ) = dp( t [ i ].r , j - t [  i ].d ) + 1
```
意为： 在右子树上删去（要删的  j 减去已经删的 t [  i ].d ）节点的最小次数加上本次删的次数 1 
- ##### 如果删, 还有一种特殊情况
```cpp
	if(m==n-p)	dp( i , j )=dp(t[ k ].l,t[ k ].d-p)+1;
```
意为： 若其他子树还未删任何节点，可以在删去的子树中删去（子树的节点减去要保留的节点），即等同于不删子树，而删去除该子树外的所有节点
- #####	如果不删，则
```cpp
	dp( i , j )=dp(t [ i ].l , k )+dp(t [ i ].r ,m-k )
```
意为： 节点i左子树删 k 个节点，右子树删 m-k 个节   点的最小次数和
- ##### 加上记忆化
-------
```cpp
t [ i ].r为右子树，t [ i ].l为左子树
t [ i ].d为删掉该节点后，会有多少节点挂掉。
```
-------
### 传朕旨意，宣代码

```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cmath>
#include <string>
#include <cstring>
#include <algorithm>
using namespace std;//流线型头文件

const int INF=9999999;
struct tree{ int d,l,r; }t[301];
int f[301][301];
int n,p;//定义树

int dp(int k,int m)
{
	if(f[k][m]>0)		return f[k][m];
	if(m==0)		return 0;//删0个节点次数为0
	if(m<0)			return INF;//不可能删负数个节点
	if(k==0)		return INF;//不存在的节点
	int tmp;
	f[k][m]=INF;
	tmp=dp(t[k].r,m-t[k].d)+1;
	if(tmp<f[k][m])	f[k][m]=tmp;
	if(m==n-p)	tmp=dp(t[k].l,t[k].d-p)+1;
	if(tmp<f[k][m])	f[k][m]=tmp;
	int lv,rv;
	for(int i=0; i<=m; i++)
	{
		lv=dp(t[k].l,i);
		if(lv>=INF)	continue;
		rv=dp(t[k].r,m-i);
		if(rv>=INF)	continue;
		if(lv+rv<f[k][m])	f[k][m]=lv+rv;
	}
	return f[k][m];
}//树形DP+记忆化

void dfs(int x)
{
	if(x==0)	return;
	if(t[x].l==0)
	{
		t[x].d=1;
		return;
	}
	int r=t[x].l;
	t[x].d+=1;
	while(r>0)
	{
		dfs(r);
		t[x].d+=t[r].d;
		r=t[r].r;
	}
}//遍历树，求删掉该节点后，会有多少节点挂掉

int main()
{
	scanf("%d%d",&n,&p);
	int x,y,r;
	memset(t,0,sizeof(t));
	memset(f,-1,sizeof(f));
	for(int i=1; i<n; i++)
	{
		scanf("%d%d",&x,&y);
		if(t[x].l==0)	t[x].l=y;
		else
		{
			r=t[x].l;
			while(t[r].r>0)	r=t[r].r;
			t[r].r=y;
		}//转二叉树
	}
	dfs(1);
	cout<<dp(1,n-p)<<endl;
	return 0;
}
```
#### 2019 RP++ !

---

## 作者：MD_17L (赞：4)

## 树形DP
用了两种方式
1. 边集数组
   - f[x][p]表示以x为根的子树保留p个点要删除的最小边数
   - 状态转移方程:f[x][j]=min(f[x][j],f[t[i].v][k]+f[x][j-k]-2)
   - 转移时枚举当前点删除多少边,儿子节点能删除多少条边
   - 因为由儿子转移过来,他们之间的连边不能断,but转移时断掉了两次,所以ans-2

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
using namespace std;
const int N=305,M=100000000;
int n,p,a[N],d[N],f[N][N],tot,ans;
 struct ss
{
	int nx,v;
}t[N*2];
 void add(int u,int v)//边集数组
{
	tot++; t[tot].v=v; t[tot].nx=a[u]; a[u]=tot;
}
 void dp(int x,int fa)//x为当前节点,fa为当前节点的父节点
{
	f[x][1]=d[x]; //x节点保留1个节点时将与x节点相连的子节点断开 
	int i,j,k;
	for (k=a[x]; k; k=t[k].nx)	
		if (t[k].v!=fa)
		{
			dp(t[k].v,x);
			for (i=p; i>=1; i--)
				for (j=1; j<=i; j++) f[x][i]=min(f[x][i],f[t[k].v][j]+f[x][i-j]-2);
		}
	ans=min(ans,f[x][p]);
}
 int main()
{
	memset(f,0x03f,sizeof(f));
	scanf("%d%d",&n,&p);
	int x,y;
	for (int i=1; i<n; i++)
	{
		scanf("%d%d",&x,&y);
		d[x]++; d[y]++;
		add(x,y); add(y,x);
	}
	ans=M;
	dp(1,0);
	printf("%d\n",ans);
	return 0;
}
```

  2. f[x][p]表示以x为根的子树保留p个点要删除的最小边数
   - res[rx][p]表示x节点右边最近的节点保留p个点要删除的最小边数
   - 上一种方式相比,多用res数组记录兄弟节点的值,而上一种则是从p至1循环防止前面更新的值对后面的值产生影响

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
using namespace std;
const int N=305,M=1000000000;
int a[N],nx[N],f[N][N],res[N][N];
int n,p,root,ans=M;
bool flag[N];
 void dfs(int x)
{
	for (int i=0; i<=p; i++) f[x][i]=res[x][i]=M;
	f[x][0]=1;
	if (a[x]==0)
	{
		f[x][1]=0;
		return;
	}
	int i,j,k,rk=0;
	for (k=a[x]; k; k=nx[k])
	{
		dfs(k);
		if (rk>0)
			for (i=0; i<=p; i++)
				for (j=0; j<=i; j++) 
					res[k][i]=min(res[k][i],res[rk][j]+f[k][i-j]);
		else for (i=0; i<=p; i++) res[k][i]=f[k][i];
		rk=k;
	}
	for (i=1; i<=p; i++) f[x][i]=res[rk][i-1];
}
 int main()
{
	scanf("%d%d",&n,&p);
	int u,v;
	for (int i=1; i<n; i++) 
	{
		scanf("%d%d",&u,&v);
		nx[v]=a[u]; a[u]=v;
		flag[v]=true;
	}
	for (int i=1; i<=n; i++)
		if (flag[i]==false) {root=i; break;}
	dfs(root);
	for (int i=1; i<=n; i++)
		if (i==root) ans=min(ans,f[i][p]);
		else ans=min(ans,f[i][p]+1);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：SFWR (赞：4)

这个题的数据是真的水==

第一次交的时候循环写反了结果就WA了一个点

写写个人的思路吧

首先我们可以看出，这是一个树形DP。而对于这样的题，一般都会枚举当前节点的节点数与当前节点的子节点的节点数，所以在这个题目中我们要枚举的，就是切下/保留的节点数

我们用数组记录u节点切去j个的次数，那对于结果来说，保留p个实际上就是切掉size【u】-p的次数

首先先用一遍dfs，确定每个节点的子树节点数

```cpp
void siz(int u,int fa)
{
	sz[u]++;
	for(int i=head[u];i;i=eg[i].next)
	{
		int v=eg[i].to;
		if(v!=fa){
        siz(v,u);
		sz[u]+=sz[v];
        }
	}
	dp[u][sz[u]]=1;
	dp[u][0]=0;
}
```
如果我们要切掉sz【u】个，只需要切掉他与他父亲，而不切则是0

对于根节点来说，没有父亲，则有dp【root】【sz【root】】=0

当然root可以随便转的，本题解以1为root

然后就是枚举子树的节点了，不过要注意的是，对于树上背包问题，
# 一定不要忘记倒序

```cpp
void dfs(int u,int fa)
{
	for(int i=head[u];i;i=eg[i].next)
	{
		int v=eg[i].to;
		if(v==fa)continue;
		dfs(v,u);
		for(int j=sz[u]-1;j>=1;j--)
		for(int k=0;k<=j;k++)
		dp[u][j]=min(dp[u][j],dp[u][j-k]+dp[v][k]);
	}
    }
```
最后的输出就是扫一遍所有的节点辣
这个就不说了，相信你肯定知道该怎么扫了

**THE END**




---

## 作者：弥生 (赞：4)

和楼下大佬说的一样，就是树形DP，不过我是拿邻接表写的。

设f[i][j] 表示以i节点为根，隔出含有j个点的子树所需要的最少操作次数。（感觉树形DP状态都设的差不多诶，几道入门题的状态都跟这设的大差不差，我也不是很清楚毕竟我也没做几题【求大佬告知】）

……其实楼下大佬讲得很详细啊，好了不废话贴代码：

```cpp
#include<cstdio>
#include<iostream>
#include<bits/stdc++.h>
using namespace std;
const int N=151;
const int M=0x7f7f7f7f;
int f[N][N],h[N],d[N];
int cnt,n,m,ans=M;
struct node{
    int v;
    int next;
}e[2*N];//因为是无向变所以相当于正反两条有向边
void Add(int u,int v){
    cnt++;
    e[cnt].v=v;
    e[cnt].next=h[u];
    h[u]=cnt;
}
void dfs(int x,int fa){
    f[x][1]=d[x];
    for(int i=h[x];i;i=e[i].next)
        if(e[i].v!=fa){
                        dfs(e[i].v,x);
             for(int j=m;j>=1;j--)
                for(int k=1;k<=j;k++)
                    f[x][j]=min(f[x][j],f[x][j-k]+f[e[i].v][k]-2);
        }
    ans=min(ans,f[x][m]);    
}
int main(){
    memset(f,1,sizeof(f));
    scanf("%d%d",&n,&m);
    for(int i=1;i<n;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        Add(u,v);Add(v,u);
        d[u]++,d[v]++;
    }
    dfs(1,0);
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：vgccyaj (赞：3)

这是一道经典的树形dp题

代码中有注释。。









```cpp
#include <cstdio>
#include <cstring>
#include <memory.h>
#include <iostream>
using namespace std;
const int N=155;
struct Node
{int v;
 int next;
}e[2*N];
int n,p,tot,Ans=1000000000;
int f[N][N],d[N],G[N];//f[i][j]表示在以i为根的子树里截取j个节点最少要删边数
void addedge(int u,int v)//用邻接表存储边 
{e[++tot].v=v;
 e[tot].next=G[u];
 G[u]=tot;//表头 
}
void init()
{int i,u,v;
 scanf("%d %d",&n,&p);
 for(i=1;i<n;i++)
   {scanf("%d %d",&u,&v);
    d[u]++;//节点u的度 
    d[v]++;
    addedge(u,v);
    addedge(v,u);
   }
 memset(f,1,sizeof(f));
}
void dfs(int u,int r)//节点u的父节点为r 
{int i,j,k;
 f[u][1]=d[u]-(r!=0);//初始化
 for(i=G[u];i;i=e[i].next)
  if(e[i].v!=r)//方向向下 
  {dfs(e[i].v,u);
   for(j=p;j>=1;j--)
     for(k=1;k<=j;k++)
       f[u][j]=min(f[u][j],f[u][j-k]+f[e[i].v][k]-1);//为何要-1,因为一开始把所有的边都删了 
  }
 Ans=min(Ans,f[u][p]+(r!=0));
}
int main()
{init();
 dfs(1,0);//将1号点当做无根树的根节点 
 cout<<Ans;
 return 0;
}
```

---

## 作者：andysk (赞：2)

[Link](https://www.luogu.org/problem/P1272)

一道树形DP

首先想可不可枚举删的边数和删那条边，发现完全不可行。

考虑将状态设为，对于一个点，我们在它的子树中删除 $p-j$ 个点（即保留 $j$ 个点）要删掉的最少边

可以先想边界，如果一个点都不删，则 $f[i][0] = 0$

如果只保留一个点，那么保留的点就是它自己，所以要删掉它的所有儿子节点的连边，则 $f[i][1] = son[i]$

现在想转移，如果要在点 $i$ 上保留 $j$ 个点，答案会从它的一棵子树删掉 $j-k$ 个点中转移而来。我们设一条边从$u->v$ ，则 $f[u][j] = f[u][j] = min(f[u][j], f[u][k] + f[v][j - k] - 2);$

其中转移方程中的$-2$是引起题解版大肆讨论的地方。可以这样理解，因为 $v$ 是 $u$ 的儿子，而 $v$ 的答案又是从 $v$ 某个儿子中转移过来的，两次转移的前提条件都是有相连的边，再看我们的转移方程，这两条边已经在转移中统计，所以需要减掉。



### Code

```cpp
#include <bits/stdc++.h>
#define TEST std::cout << "pass" << endl;
using namespace std;

const int SIZE = 150 + 5;

int n, p, num;
int head[SIZE], f[SIZE][SIZE], son[SIZE];

struct node {
    int to, Next;
} edge[SIZE << 1];

inline int read()
{
    char ch = getchar();
    int f = 1, x = 0;
    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = (x << 1) + (x << 3) + ch - '0'; ch = getchar(); }
    return x * f;
}

inline void Addedge(int x, int y)
{
    edge[++num].to = y;
    edge[num].Next = head[x];
    head[x] = num;
}

inline void DP(int u, int fa)
{
    for (int i = head[u]; i; i = edge[i].Next) {
        int v = edge[i].to;
        if (v == fa) continue;
        DP(v, u);
        for (int j = p; j >= 1; j--) 
            for (int k = 1; k < j; k++) {
                f[u][j] = std::min(f[u][j], f[u][k] + f[v][j - k] - 2);
            }
    }
}

int main()
{
    int u, v;
    n = read(), p = read();
    for (int i = 1; i < n; i++) {
        u = read(), v = read();
        Addedge(u, v);
        Addedge(v, u);
        son[u]++, son[v]++;
    }
    memset(f, 0x3f, sizeof(f));
    for (int i = 1; i <= n; i++) f[i][0] = 0, f[i][1] = son[i];
    DP(1, 0);
    int ans = 2e9;
    for (int i = 1; i <= n; i++) ans = std::min(ans, f[i][p]);
    printf("%d", ans);
    return 0;
}
```




---

## 作者：s_a_b_e_r (赞：2)

把一颗树以1``(假装)``为根节点,计算出他有多少个儿子,把他加一就是有多少连出去的边。

``重载dfs的w并没有什么用.....``

维护一个连通块(dp[i][1]就是把i这个节点删到只剩它自己需要操作多少次),然后大力扩展连通块,通过father节点加点,使其保持p个点在块里。

然后枚举一遍在以没个i所扩展的大小为p的连通块所需要的操作次数

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
const int maxn=200;
const int INT=2333333;
int read(){
    int an=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while('0'<=ch&&ch<='9'){an=an*10+ch-'0';ch=getchar();}
    return an*f;
}
int f[maxn],cnt,fa[maxn],ans=2333;
bool vis[maxn];
struct saber{
int to,nex;
}b[maxn<<1];
void add(int x,int y){
    cnt++;
    b[cnt].nex=f[x];
    b[cnt].to=y;
    f[x]=cnt;
}
int son[maxn],dp[maxn][maxn],m,n,p;
void dfs(int x){
    vis[x]=1;son[x]=1;
    for(int i=f[x];i;i=b[i].nex){
        int v=b[i].to;
        if(!vis[v]){
            dfs(v);
            fa[v]=x;
            son[x]++;
        }
    }
}
void dfs(int x,int w){
    dp[x][1]=son[x];
    for(int i=f[x];i;i=b[i].nex){
        int v=b[i].to;
         if(v!=fa[x]){
         dfs(v,w);
        for(int j=p;j>=1;j--)
            for(int k=1;k<=j;k++)
            dp[x][j]=min(dp[x][j],dp[x][j-k]+dp[v][k]-2);
        }
    }
    ans=min(ans,dp[x][p]);
}
int main(){
    n=read();p=read();
    for(int i=0;i<=maxn-9;i++)
    for(int j=0;j<=maxn-9;j++)dp[i][j]=INT;
    for(int i=1;i<n;i++){
        int x,y;
        x=read();y=read();
        add(x,y);
        add(y,x);
    }
    dfs(1);son[1]--;
    dfs(1,INT);
    cout<<ans;
    return 0;
} 
```

---

## 作者：zx2003 (赞：2)

```cpp
//h是头指针，e是边，用于存储树
const maxi=1 shl 30;
type
 bi=record
```
next,go:longint
```cpp
end;
var
 e:array[0..150] of bi;
 h,s,son:array[1..150] of longint;//s[i]是以i为根的子树节点个数，son[i]是i的直系儿子个数
 f:array[1..150,0..150,0..150] of longint;//f[i,j,k]表示第i个节点取出节点为j的子树至少要删多//少边(在前k个儿子中)，状态比较特别，往下看就知道了
 b:array[1..150] of boolean;
 i,x,y,n,m,ans,j:longint;
procedure adde(x,y:longint);
begin
 e[i].go:=y;
 e[i].next:=h[x];
 h[x]:=i
end;
procedure dp(x:longint);
var
 p,i,j,k:longint;
begin
 p:=h[x];
 if p=0 then//没有儿子直接退出
 begin
  f[x,1,0]:=0;
```
exit

```cpp
 end;
 while p>0 do
 begin
  dp(e[p].go);
  inc(son[x]);
  inc(s[x],s[e[p].go]);
  p:=e[p].next
 end;
 p:=h[x];
 f[x,1,0]:=0;
 k:=0;
 while p>0 do
 begin
  inc(k);
  for i:=1 to s[x] do if f[x,i,k-1]>=0 then f[x,i,k]:=f[x,i,k-1]+1;//加入第k个儿子后当前所有答案都//要先删掉x与第k个儿子之间的边
  for i:=1 to s[e[p].go] do//经典背包问题
   if f[e[p].go,i,son[e[p].go]]>=0 then
    for j:=s[x] downto i+1 do
      if f[x,j-i,k-1]>=0 then if (f[x,j-i,k-1]+f[e[p].go,i,son[e[p].go]]<f[x,j,k])or(f[x,j,k]=-1) then
       f[x,j,k]:=f[x,j-i,k-1]+f[e[p].go,i,son[e[p].go]];//k与k-1要分别处理，否则会混在一起，//比较难叙述为什么，不服的话可以删掉这一维跟踪一下
  p:=e[p].next
 end
end;
begin
 readln(n,m);
 for i:=1 to n-1 do
 begin
  readln(x,y);
  b[y]:=true;
  adde(x,y)
 end;
 for i:=1 to 150 do
  for j:=0 to 150 do
   for x:=0 to 150 do f[i,j,x]:=-1;//-1表示删多少条边都得不到
 filldword(s,sizeof(s) shr 2,1);
 for i:=1 to n do if not b[i] then dp(i);
 ans:=maxi;
 for i:=1 to n do
  if f[i,m,son[i]]>=0 then
  begin
   if i=1 then if f[i,m,son[i]]<ans then ans:=f[i,m,son[i]];
   if i>1 then if f[i,m,son[i]]+1<ans then ans:=f[i,m,son[i]]+1//如果不是根(后来发现根恒为1，我//读题不仔细吗？),还要多删与父亲节点所连的边
  end;
 writeln(ans)
end.

```

---

## 作者：moye到碗里来 (赞：2)

#使用到的思路 树上dp 背包 (你叫他树形背包也没问题)

看了看大家的写法好像跟我的都不一样啊，看来是我脑回路有点问题啊（笑），我没有把无根树转为有根树，而实际上这道题确实是有根树，n-1条边，连n个点，一定有树根，所以实际上这道题是可以直接用入度来找根的，由于只有一个父亲，直接记下就可以了。

#我的状态  f[i][j]表示在i节点这个位置，要去掉j个点，所要减去的树枝。

然后用个cnt存一下以这个节点为根，子书中一共有多少个点

为什么会是这个状态呢，因为比起去存保留几个，显然是减去几个更好转移，因为剪掉树枝实质上就是把那根树枝相连的全部去掉啊。（主要是我没想出来存几个的状态转移怎么写）

所以状态转移就很好想了啊**f[i][j] = min{f[i][j-k] + f[son[i]][k],f[i][j]}**

然后初始化f[i][0] = 0;f[i][cnt[i]] = 1;

然后。。就是一个裸的树上背包啊，基本上做这道题的大家都会就不赘述了，如果有不会的，可以看下我在没有上司的舞会那道题那写的题解，实际上这道题如果根据拓扑排序来做可能会更好写。

然后对于答案，我们每一个点都跑一下，如果cnt[i]>=p

就更新ans

**ans = min(ans,f[i][cnt[i]-p] if(i is not root) ans+1);**(你去掉了多余的点剩下来的不就是p个了么= =)

以下代码

```cpp
#include<bits/stdc++.h>//雾雨魔理沙 
using namespace std;//zcxssb 
int n,p,f[155][155],cnt[155];
int head[155],root;
int ne[305],to[305],t,fa[155];
void add(int u,int v)
{
    to[++t] = v;
    ne[t] = head[u];
    head[u] = t;
}
void dp(int rt)
{
    f[rt][0] = 0;
    for(int i = head[rt]; i ; i = ne[i])
    {
        if(to[i] != fa[rt])
        {
            dp(to[i]);
            cnt[rt] += cnt[to[i]];
            for(int j = cnt[rt] - 1; j>= 1; j--)
            {
                for(int k = 1; k <= cnt[to[i]]; k++)
                {
                    if(j<k)break;
                    f[rt][j] = min(f[rt][j-k] + f[to[i]][k] , f[rt][j]);
                }
            }
        }
    }
    f[rt][cnt[rt]] = 1;
}
int main()
{
//    freopen("road.in","r",stdin);
//    freopen("road.out","w",stdout);
    memset(f,0x3f,sizeof(f));
    scanf("%d %d",&n,&p);
    for(int i = 1; i < n; i++)
    {
        cnt[i] = 1;
        int u,v;
        scanf("%d %d",&u,&v);
        add(u,v);
        fa[v] = u;
    }
    cnt[n] = 1;
    for(int i = 1;i <= n; i++)
    if(fa[i] == 0)
    {
        root = i;
        break;
    }
    dp(root);
    int ans = 0x3f3f3f;
    for(int i = 1; i <= n; i++)
    {
        if(i != root)
        if(cnt[i] >= p)
        ans = min(ans,f[i][cnt[i]-p]+1);
        else
        ans = min(ans,f[i][n-p]);
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Hzxleo4 (赞：2)

好气啊想到了状态想到了转移初始化错了。

由此可见， 初始化是 dp 中超级重要的部分。

对这题， 我们记 f[i][j] 表示 在 节点 i 的 子树中保留 j 个 节点的最小道路

然后就是树形背包

记 b 为 i 的 儿子节点

#方程： f[i][j] = min(f[i][j], f[b][k] + f[i][j-k] - 1)


这里 -1 是因为 i -> b 连着一条边， 而我们这里 b 和 i 是 属于同一块的

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
struct node{
    int a, b, c, n;
}d[155];
int n, p, h[155], cnt, siz[155], f[155][155], du[155], ans;
void cr(int a, int b){
    d[++cnt].a = a; d[cnt].b = b; d[cnt].n = h[a]; h[a] = cnt;
}
void dfs(int a){
    siz[a] = 1;
    int i, b, j, k;
    if(!h[a]) f[a][1] = 0;
    for(i = h[a]; i; i = d[i].n){
        b = d[i].b;
        dfs(b);
        siz[a] += siz[b];
        for(j = siz[a]; j >= 1; j--){
            for(k = j-1; k >= 1; k--)
                f[a][j] = min(f[a][j], f[b][k] + f[a][j-k] - 1); 
        }
    }
}
int main(){
    int i, j, a, b, c;
    memset(f, 1, sizeof(f));
    scanf("%d%d", &n, &p);
    for(i = 1; i < n; i++){
        scanf("%d%d", &a, &b);
        cr(a, b);
        du[a]++;
    }
    for(i = 1; i <= n; i++) f[i][1] = du[i];
    dfs(d[1].a);
    ans = f[d[1].a][p];
    for(i = 2; i <= n; i++) ans = min(ans, f[i][p]+1);
    printf("%d", ans);
    return 0;
}

```

---

## 作者：Santiego (赞：1)

# 重建道路 树形DP

[$\text{My Blog}$](https://www.cnblogs.com/santiego/p/11510964.html)


> 给一棵树，问最少断多少边使得这棵树树最终只有$p​$个节点


设计dp状态$f[u][i][j]$表示节点$u$，到第$i$个儿子，使$j$个节点分离，但是**不分离$u​$**最少需要断的边数。类比背包，容易得到转移方程：
$$
f[u][i][j]=min{f[u][i-1][j-k]+f[v][n][k]}
$$
再优化一维$i$，状态变为$f[u][j]$，此时必须倒序遍历$j$。

需要注意的是，最后答案并不是$f[1][sz[1]-p]$，因为最后可能把节点1也删了，所以必须在每个满足子树节点数$\ge p$的节点处统计一下答案。
$$
ans=min(f[u][sz[u]-p]+f[u][sz[u]], ans)
$$
其中注意$f[1][sz[1]]=0​$，因为不需要将树根与其父亲分离（它没父亲）

```cpp
#include <cstdio>
#include <cstring>
#define MAXN 155
#define MIN(A,B) ((A)<(B)?(A):(B))
using namespace std;
int n,p,ans;
int head[MAXN],nxt[MAXN*2],vv[MAXN*2],tot;
inline void add_edge(int u, int v){
    vv[++tot]=v;
    nxt[tot]=head[u];
    head[u]=tot;
}
int f[MAXN][MAXN],sz[MAXN];
void load(int u, int fa){
    sz[u]=1;
    f[u][0]=0;
    for(int i=head[u];i;i=nxt[i]){
        int v=vv[i];
        if(v==fa) continue;
        load(v, u);
        sz[u]+=sz[v];
    }
    f[u][sz[u]]=1;
}
void dfs(int u, int fa){
    for(int i=head[u];i;i=nxt[i]){
        int v=vv[i];
        if(v==fa) continue;
        dfs(v, u);
        for(int j=sz[u];j>=0;--j)
            for(int k=0;k<=MIN(sz[v], j);++k){
                f[u][j]=MIN(f[v][k]+f[u][j-k], f[u][j]);
            }
    }
    if(sz[u]>=p) ans=MIN(f[u][sz[u]-p]+f[u][sz[u]], ans);
}
int main(){
    scanf("%d %d", &n, &p);
    for(int i=2;i<=n;++i){
        int u,v;
        scanf("%d %d", &u, &v);
        add_edge(u, v);
        add_edge(v, u);
    }
    memset(f, 0x3f, sizeof(f));
    ans=0x3f3f3f3f;
    load(1, 0);
    f[1][sz[1]]=0;
    dfs(1, 0);
    printf("%d", ans);
    return 0;
}
/*
f[u][i][j]=min{f[u][i-1][j-k]+f[v][n][k]}
*/

```



---

## 作者：七条玲奈 (赞：1)

树形DP

不多说直接上转移方程

f[i][j]表示根节点为i时得到至少一个子树为j个节点的最小割边的数量

那么 ***f[i][j]=min{f[p][k]+f[i][j-k]}***

p是i的所有子节点

需要注意的是j的循环要倒着来 因为它要保证子问题已经被求解

f[i][1]的初值附为i的连边数量233

话不多说上代码233 代码写的丑QAQ 
```cpp
#include <bits/stdc++.h>
using namespace std;
int f[2005][2005],tot[2005],cnt,next[10000],last[10000],Arrive[10000],p,n;
void jt(int x,int y) {
	cnt++;
	next[cnt]=last[x];
	last[x]=cnt;
	Arrive[cnt]=y;
}
void dfs(int rt,int fa) {
	f[rt][1]=tot[rt];
	for (int i=last[rt]; i; i=next[i]) {
		if (Arrive[i]!=fa) {
			dfs(Arrive[i],rt);
			for (int j=p; j>1; j--)
				for (int k=1; k<j; k++)
					f[rt][j]=min(f[Arrive[i]][k]+f[rt][j-k]-2,f[rt][j]);
		}
	}
}
int main() {
	scanf("%d%d",&n,&p);
	memset(f,63,sizeof(f));
	for (int i=1; i<=n-1; i++) {
		int x,y;
		scanf("%d%d",&x,&y);
		tot[x]++;
		tot[y]++;
		jt(x,y);
		jt(y,x);
	}
	dfs(1,0);
	int Ans=1e9;
	for (int i=1; i<=n; i++) {
		Ans=min(Ans,f[i][p]);
	}
	cout<<Ans;
	return 0;
}
```

---


# 理解

## 题目背景

**已添加此题大样例，请前往附件下载。其中 `sample2-4` 分别满足 Subtask 2-4 的特殊性质。**

> 「浅村同学对于我……」\
「**理解得太深了。**」\
——绫濑沙季

## 题目描述

沙季正在用悠太推荐的方法做现代文阅读练习。

有 $n$ 个历史事件，编号为 $1$ 至 $n$，其中每个历史事件可能有一个编号比它更小的前置事件，也可能没有。形式化地，对于事件 $i$，用 $p_i$ 表示其前置事件的编号，满足 $p_i<i$，若 $p_i=0$ 则表示它没有前置事件。

沙季有两种方式记起一个历史事件：回想和联想。如果她进行回想，那么她可以花费 $r_u$ 时间，直接记起任意一个历史事件 $u$；如果她进行联想，那么她可以选择任意一个已经记起来的事件 $u$，并花费 $t_v$ 时间记起一个满足 $p_v=u$ 的事件 $v$。

但是她的脑容量有限，因此她最多只能同时记起 $k$ 个事件。她已经记起来的事件可以选择在任意时刻忘记，忘记事件不需要花费时间。为了防止记忆混乱，她不会再次记起任何曾经忘记过的事件。

现在，她有 $m$ 道阅读题，解决其中的第 $i$ 道题需要她记起事件 $x_i$，她可以在记起事件 $x_i$ 的时候立刻解决第 $i$ 道题目，花费的时间忽略不计。她想要知道她至少需要花费多少时间才能解决所有题目。

## 说明/提示

#### 样例解释

对于第一组数据，历史事件之间的关系如下图：

![pic](https://cdn.luogu.com.cn/upload/image_hosting/70kj9xfv.png)

她可以进行以下的回忆过程：

| 步骤 | 过程 | 用时 | 记起的事件集合 | 解决问题 |
| :-: | :-: | :-: | :-: | :-: |
| $1$ | 回想起事件 $1$ | $1$ | $\{1\}$ |  |
| $2$ | 联想起事件 $3$ | $1$ | $\{1,3\}$ |  |
| $3$ | 联想起事件 $5$ | $2$ | $\{1,3,5\}$ | $3$ |
| $4$ | 忘记事件 $3$ | $0$ | $\{1,5\}$ |  |
| $5$ | 联想起事件 $2$ | $1$ | $\{1,2,5\}$ | $1$ |
| $6$ | 忘记事件 $2$ | $0$ | $\{1,5\}$ |  |
| $7$ | 回想起事件 $4$ | $4$ | $\{1,4,5\}$ | $2$ |

总用时 $1+1+2+1+4=9$。

#### 数据范围与限制

**本题采用捆绑测试，各 Subtask 的限制与分值如下。**

| Subtask No. | $n,m\le$ | 特殊性质 | 分值 | 依赖子任务 |
| :-: | :-: | :-: | :-: | :-: |
| $1$ | $10$ |  | $18$ |  |
| $2$ | $10^5$ | A | $18$ |  |
| $3$ | $10^5$ | B | $18$ |  |
| $4$ | $10^5$ | C | $18$ |  |
| $5$ | $10^5$ |  | $28$ | $1,2,3,4$ |

特殊性质 A：保证 $p_i=0$ 或 $p_i=i-1$；

特殊性质 B：保证 $p_i=\lfloor\frac i2\rfloor$；

特殊性质 C：保证 $p_i\le1$。

对于所有数据，满足 $1\le T\le5$，$1\le n,m\le10^5$，$1\le k\le10$，$0\le p_i<i$，$0\le r_i,t_i\le10^9$，$1\le x_i\le n$。

## 样例 #1

### 输入

```
2
5 3 3
0 1 1 0 3
1 2 3 4 5
0 1 1 0 2
2 4 5
5 3 2
0 1 1 2 3
1 2 3 4 5
0 1 1 2 2
2 4 5
```

### 输出

```
9
8
```

# 题解

## 作者：VinstaG173 (赞：18)

### 题意转化

形式化题意：给定有根森林，点有点权，边有边权。一个子图的权值为其中每棵树根结点的点权加所有边的边权，求一个权值最小的，包含所有给定的关键点的子图（显然子图为一个森林），使得其中所有树都 $k-$合法。

其中一棵树 $k-$合法的定义是存在一种遍历整棵树的方式，维护一个集合，初始为根结点单点集，每次可以从中删除任意元素或加入其中任意元素的一个儿子，使得所有结点均加入过集合一次，且任意时刻集合的大小不超过 $k$。

下文中用选择/不选择结点 $u$ 表示 $u$ 在/不在子图中。

### Subtask 1

$O(2^n)$ 枚举子图中的点，再 $O(n)$ 验证树的合法性及计算权值，总之随便暴力可过。

注意特判 $k=1$，此时必须选单点。以下只考虑 $k\ge2$。

### Subtask 2

链部分分。容易发现我们可以在链上不断地加入儿子后直接删除父亲，显然只要 $k\ge2$ 就可以遍历任意长的链。那么问题就变成简单地求权值最小的子图。

考虑选择了哪些点。首先子树里没有关键点的可以整个丢掉。记 $f_{u,1/0}$ 表示包含 $u$ 的子树内所有关键点，且 $u$ 有/没有被选择时的最小权值，其中 $f_{u,1}$ 不包含 $r_u$ 的点权或 $t_u$ 的边权。则对于非叶子结点可以列出转移方程：

$$f_{u,0}=\min(f_{u+1,0},f_{u+1,1}+r_{u+1}),\\
f_{u,1}=\min(f_{u+1,0},f_{u+1,1}+\min(r_{u+1},t_{u+1})).$$

特别地，当 $u=x_i$ 时 $f_{u,0}$ 应为 $+\infty$。以下同样不再赘述。

### Subtask 4

菊花图部分分。容易发现可以在菊花图上不断加入儿子后直接删除儿子，同样只要 $k\ge2$ 就能遍历任意菊花图。

同上列出状态 dp，其中 $ch(u)$ 表示 $u$ 的子结点集合：

$$f_{u,0}=\sum_{v\in ch(u)}\min(f_{v,0},f_{v,1}+r_v),\\
f_{u,1}=\sum_{v\in ch(u)}\min(f_{v,0},f_{v,1}+\min(r_v,t_v)).$$

注意到上述转移方程的性质，若视为存在点 $0$，则答案即为 $f_{0,0}$。

### Subtask 3

实际解法上只有实现上的方便（只有两个儿子）。

通过手玩满二叉树或许能够发现关于一棵树最少需要多大的 $k$ 才能合法的性质。直接讲正解。

### Subtask 5

对每棵求出的树直接模拟验证合法的过程显然复杂度太高，因此我们考虑刻画合法的树的性质。

通过链的部分分我们发现如果只剩一个儿子，那么可以直接删除父亲往前遍历。

如果根结点有一个子结点的子树 $k$-合法，且其他子结点的子树均 $(k-1)$-合法，则可以保留根结点，依次遍历所有 $(k-1)$-合法的子树，最后删除根遍历 $k$-合法的子树，从而全树也是 $k$-合法的。

如果根结点有至少两棵子树不是 $(k-1)$-合法的，设为 $T_1,T_2$，若原树是 $k$-合法的，则在任意一个合法的遍历过程中，不妨设 $T_2$ 比 $T_1$ 更晚遍历完。为了遍历 $T_2$，在遍历 $T_1$ 的过程中必须保留一个不在 $T_1$ 中的结点，这个过程中一定会有一个时刻集合中点数超过 $k$，与原树 $k$-合法矛盾。

因此一棵树 $k$-合法当且仅当它的根结点的至多一个子结点的子树 $k$-合法，且其他子结点的子树都 $(k-1)$-合法。

那么我们可以设出状态：$f_{u,i}$ 表示子图中 $u$ 为根的子树 $i$-合法时的最小权值。在原图中 $u$ 的子树内可能还有其他树，它们只要是 $k$-合法的即可。特别地，$f_{u,0}$ 表示 $u$ 不选时的最小权值。

则首先有转移：

$$f_{u,0}=\sum_{v\in ch(u)}\min(f_{v,0},f_{v,k}+r_v).$$

若选择 $u$，对于 $f_{u,1}$，由于不能用 $t_v$ 转移，因此转移式跟 $f_{u,0}$ 是一样的。

当 $i\ge2$，对于 $v\in ch(u)$，有三种转移情形：$v$ 不选，此时用于转移的是 $f_{v,0}$；$v$ 作为子图中树的根，此时用于转移的是 $f_{v,k}+r_v$；$v$ 作为子图中 $u$ 的儿子，此时用于转移的是 $f_{v,i-1}+t_v$，或有一个 $v$ 是 $f_{v,i}+t_v$。

因此若前三项中有最小值，则直接用于转移；否则对剩余的 $v$，最小值为 $f_{v,i}+t_v$，选择一个 $f_{v,i}+t_v-\min(f_{v,0},f_{v,k}+r_v,f_{v,i-1}+t_v)$ 最小的取 $f_{v,i}+t_v$，其余的取前三者的最小值转移。在实现上可以直接对前三者取 $\min$ 后求和，然后对差值与 $0$ 取 $\min$ 后加入转移答案即可。

时间与空间复杂度均为 $O(nk)$。

Code:
```cpp
int n,m,k;
ll r[100003];
ll t[100003];
int d[100003];
int tg[100003];
ll f[100003][13];
ll mind[100003][13];
vector<int>e[100003];
inline void solve(){
	cin>>n>>m>>k;
	for(int i=0;i<=n;++i){
		d[i]=tg[i]=0;e[i].clear();
		for(int j=0;j<=k;++j)
			f[i][j]=mind[i][j]=0;
	}for(int i=1,p;i<=n;++i){
		cin>>p;++d[p];
		e[p].push_back(i);
	}for(int i=1;i<=n;++i)cin>>r[i];
	for(int i=1;i<=n;++i)cin>>t[i];
	for(int i=1,x;i<=m;++i){
		cin>>x;tg[x]=1;f[x][0]=1e16;
	}for(int u=n;u;--u){
		if(!d[u])continue;
		for(int i=0,v;i<d[u];++i){
			v=e[u][i];ll f1,f2;
			for(int j=2;j<=k;++j){
				f1=min(f[v][0],min(f[v][k]+r[v],f[v][j-1]+t[v]));
				f2=f[v][j]+t[v];f[u][j]+=f1;
				mind[u][j]=min(mind[u][j],f2-f1);
			}f[u][1]+=min(f[v][0],f[v][k]+r[v]);
		}for(int j=2;j<=k;++j){
			f[u][j]+=mind[u][j];
			f[u][j]=min(f[u][j],f[u][j-1]);
		}if(!tg[u])f[u][0]=f[u][1];
	}for(int i=0,v;i<d[0];++i)
		v=e[0][i],f[0][0]+=min(f[v][0],f[v][k]+r[v]);
	cout<<f[0][0]<<"\n";
}
```

---

## 作者：wurang (赞：4)

### 题面分析

这道题的题面有些复杂，先总结几个要点。

1. 题目之间的关系可以看作是一片森林
2. 一个点可以直接回想，也可以通过父亲联想。
3. 一个节点只能在脑海里出现一次。
4. 脑海里最多存放 $k$ 个事件。
5. 可以以任意顺序完成题目。

由于考虑 $k$ 个时间的限制，想到能用动态规划来解决。

### 定义状态

状态的定义十分显然，$dp_{i,j}$ 表示对于第 $i$ 个节点，最多使用 $j$ 个单位空间，要使以其为根的子树除自己外所有节点被完成的最少时间。特别的，如果 $j$ 为 $0$，那么表示第 $i$ 个节点没有被选中。

这里为什么排除第 $i$ 个节点呢，原因是有回想和联想两种方式，将其排除的话，在其父亲节点进行转移时会更加方便。

### 边界条件

首先将其全部初始化为 $0$，然后对于需要用到的事件 $i$，由于一定要选中，所以给 $dp_{i,0}$ 赋极大值。

对于每个根 $root_i$，将其所在的树产生的贡献累加，得到答案。

如何计算贡献呢？显然，每棵树都有 $k$ 的空间，对于每棵树的根只有选或不选两种，易得贡献的计算公式：

$$
\min(dp_{i,0}, dp_{i,k} + r_i)
$$

答案即：

$$
\sum_{i \in R} \min(dp_{i,0}, dp_{i,k} + r_i)
$$

其中 $R$ 表示所有没有父亲节点的节点。

### 转移方程

先考虑两种特殊情况，空间为 $0$ 和空间为 $1$ 的情况，因为此时没有足够的空间让该节点和其子节点同时存在，所以其子节点都只能单独计算贡献，所以与上面计算一颗树的贡献的方法相同，将贡献累加即可。

对于其他的情况，设我们目前遍历到节点 $u$，空间为 $i$。

我们在计算 $dp_{u,i}$ 时，对于 $u$ 的子节点 $v$，我们分两种情况讨论。

1. 通过 $u$ 联想 $v$，脑容量会少 $1$，贡献即 $dp_{v,i-1}+t_v$。
2. 将以该子节点为根的子树单独计算贡献。

这时我们考虑这种转移的正确性，如果用 $dp_{v,i}$ 转移 $dp_{u,i}$，那么以 $v$ 为子树，最多使用了 $i$ 个单位空间，此时如果保留 $u$ 节点，最多使用了 $i+1$ 个单位空间，不满足 $dp_{u,i}$ 的要求，所以 $u$ 节点必将会被删除，这时候后面的子节点无法通过 $u$ 联想 $v$。

但我们在处理最后一个通过联想得到的节点 $v$ 时，$u$ 节点可以被删除，那么贡献就可以是 $dp_{u,i} + t_i$，不一定要用原本的转移方程。

所以我们需要对于每个子节点，取最大的 $\min(dp_{v,i-1}+t_v,dp_{i,0},dp_{i,k}+r_i) - (dp_{u,i} + t_i)$，最后在 $dp_{v,i}$ 上减去即可。

代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

inline int read(){int x = 0, f = 1;char ch = getchar();while (ch < '0' || ch > '9'){if (ch == '-') f = -1; ch = getchar();}while (ch >= '0' && ch <= '9'){x = x * 10 + ch - 48; ch = getchar();}return x * f;}

int T;
int n, m, k, ans;
bool ned[100005]; // ned[i] 表示节点i是否被需要
vector<int> roots; // roots 存储所有根节点
int dp[100005][15]; // dp[i][j] 表示第i个节点，最多使用j个单位空间，要使以其为根的子树除自己外所有节点被完成的最少时间
vector<int> e[100005]; // e[i] 存储第i个节点的子节点
int p[100005], r[100005], t[100005], x[100005];

void dfs(int u, int fa)
{
    int maxx[15] = {}; // maxx[i] 表示转移dp[u][i]时，最多能省多少时间
    if(ned[u]) dp[u][0] = 1e18; // 被需要，不能不选

    for(int i : e[u]) // 遍历子节点
    {
        dfs(i, u); // 处理子节点

        if(!ned[u])
            dp[u][0] += min(dp[i][k] + r[i], dp[i][0]);
        dp[u][1] += min(dp[i][k] + r[i], dp[i][0]); //两种特殊情况

        for(int j = 2; j <= k; j++) // 遍历空间
        {
            int x = min({dp[i][0], dp[i][j-1] + t[i], dp[i][k] + r[i]}); 
            dp[u][j] += x; // 转移
            maxx[j] = max(maxx[j], x - (dp[i][j] + t[i])); // 考虑删除u节点的情况
        }
    }
    for(int j = 2; j <= k; j++)
        dp[u][j] -= maxx[j];
}

signed main()
{
    cin.tie(0)->sync_with_stdio(0);
    T = read();
    while(T--)
    {
        ans = 0;
        for(int i = 0; i < 100005; i++) e[i].clear();
        roots.clear();
        memset(p, 0, sizeof(p));
        memset(r, 0, sizeof(r));
        memset(t, 0, sizeof(t));
        memset(x, 0, sizeof(x));
        memset(ned, 0, sizeof(ned));
        memset(dp, 0, sizeof(dp));
        n = read(), m = read(), k = read();
        for(int i = 1; i <= n; i++) p[i] = read(), e[p[i]].push_back(i);
        for(int i = 1; i <= n; i++) r[i] = read();
        for(int i = 1; i <= n; i++) t[i] = read();
        for(int i = 1; i <= m; i++) x[i] = read(), ned[x[i]] = 1;
        for(int i = 1; i <= n; i++)
            if(p[i] == 0)
                roots.push_back(i);
        for(int i : roots)
            dfs(i, 0), ans += min(dp[i][k] + r[i], dp[i][0]); // 计算所有根节点的总和
        cout << ans << '\n';
    }
    return 0;
}
```

---

## 作者：huangyuze01 (赞：1)

本题我们可以先定义一个直接出答案的状态：$f_{u,i}$ 表示以 $u$ 为根的子树内记忆容量为 $i$ 的最少时间，特别地，$f_{u,0}$ 表是以 $u$ 为根的子树内，不选 $u$ 的最少时间。

则答案应为 $f_{0,0}$，所以 $f_u$ 应该不记录 $u$ 的贡献。  

对于状态转移，首先有：  
$$f_{u,1} =  \sum_{v \in son(u)} \min(f_{v,0},f_{v,k}+r_v)$$
$$f_{u,0} = \begin{cases}
\infty & u \in x \\
f_{u,1} & u \notin x \\
\end{cases}$$
考虑 $i \in [2,k]$，有三种转移情形：  
1. $v$ 不选，此时用于转移的是 $f_{v,0}$
2. $v$ 作为根，此时用于转移的是 $f_{v,k}+r_v$
3. $v$ 作为 $u$ 的儿子，此时用于转移的是 $f_{v,i-1}+t_u$

但是，我们发现，对于 $u$ 子树和 $i$ 的记忆容量，$u$ 的儿子中可以有**最多一个**记忆容量为 $k$，其余都为 $k-1$。  
这时，我们可以按以下方式处理，就是先算出和再减去 $v$ 的原贡献加上新贡献
```cpp
F(i,2,k){
		ll s = 0;
		for (auto v:go[u]){
			s += min(dp[v][0],min(dp[v][k]+ar[v],dp[v][i-1]+br[v]));
		}
		dp[u][i] = s;
		for (auto v:go[u]){
			dp[u][i] = min(dp[u][i],s-min(dp[v][0],min(dp[v][k]+ar[v],dp[v][i-1]+br[v]))+min(dp[v][0],min(dp[v][k]+ar[v],dp[v][i]+br[v])));
		}
	}
```
最后注意一下多测清空

---

## 作者：Fzrcy (赞：1)

显然这是一道树形 DP。

设 $F_u$ 为不选择历史事件 $u$ 时将子树 $u$ 内所有需要回忆的历史事件全部回忆所需的时间，$f_{u,k}$ 表示历史事件 $u$ 已经被回忆且目前还可以再回忆 $k$ 个历史事件的情况下，将子树 $u$ 内所有需要回忆的历史事件全部回忆所需的时间。

先考虑 $F_u$ 的状态转移方程：若历史事件 $u$ 需要被回忆，则 $F_u=\infty$。否则有状态转移方程：

$$
F_u=\sum_{v\in son(u)}\min(F_v,f_{v,K-1}+r_v)
$$

再考虑 $f_{u,k}$ 的状态转移方程。

对于 $u$ 的儿子 $v$，有三种情况：

1. 单独回忆子树 $v$ 内的所有需要回忆的历史事件，此时的贡献为 $\min(F_v,f_{v,K-1}+r_v)$。
2. 回忆历史事件 $v$，不忘记历史事件 $u$，然后将子树 $v$ 内所有需要回忆的历史事件全部回忆。此时的贡献为 $f_{v,k-1}+t_v$。
3. 回忆历史事件 $v$，**忘记**历史事件 $u$，然后将子树 $v$ 内所有需要回忆的历史事件全部回忆。由于题目说明不会再次记起任何曾经忘记过的事件，所以这种情况只会出现一次。且要在其他儿子的子树内的所有需要回忆的历史事件均被回忆后才能回忆历史事件 $v$。

$f_{u,k}$ 的状态转移方程为：

$$
f_{i,k}=\min(\sum_{v\in son(u)}\min\{F_v,f_{v,K-1}+r_v,f_{v,k-1}+t_v\},\min_{v\in son(u)}\{f_{v,k}+t_v+\sum_{w\in son(u),w\not=v}\min\{F_w,f_{w,K-1}+r_w,f_{w,k-1}+t_w\}\})
$$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL Inf=1.9e17;
const int N=1e5+999;

int h[N],nt[N],to[N],cnt;
inline void lnk(int x,int y){
	nt[++cnt]=h[x],h[x]=cnt,to[cnt]=y;
}
int n,m,K,p[N],R[N],T[N];
LL f[N][12],F[N];
bool bo[N],O[N]; // bo：若子树 u 中存在需要回忆的事件，则为 true，用于剪枝，其实没啥用。
inline void dp(int u){
	if(!bo[u])return;
	for(int i=h[u];i;i=nt[i])dp(to[i]);
	memset(f[u],0,sizeof f[u]);F[u]=0;
	for(int i=h[u],v=to[h[u]];i;i=nt[i],v=to[i]){
		if(!bo[v])continue;
		F[u]+=min(F[v],f[v][K-1]+R[v]);
		for(int k=0;k<=K;k++)
			f[u][k]+=min((k?f[v][k-1]+T[v]:Inf),min(F[v],f[v][K-1]+R[v]));
	}
	for(int k=1;k<K;k++){
		LL tmp=f[u][k];
		for(int i=h[u],v=to[h[u]];i;i=nt[i],v=to[i]){
			if(!bo[v])continue;
			f[u][k]=min(f[u][k],tmp-min((k?f[v][k-1]+T[v]:Inf),min(F[v],f[v][K-1]+R[v]))+f[v][k]+T[v]);
		}
	}
	if(O[u])F[u]=Inf;
	for(int i=1;i<=K;i++)
		f[u][i]=min(f[u][i],f[u][i-1]);
}

int main(){
#ifdef LOCAL
	freopen("a.in","r",stdin);
	freopen("a.out","w",stdout);
#endif
	int tt;scanf("%d",&tt);
	while(tt--){
		scanf("%d%d%d",&n,&m,&K);
		cnt=0,memset(h,0,(n+3)<<2);
		memset(bo,0,n+3);memset(O,0,n+3);
		for(int i=1;i<=n;i++)scanf("%d",&p[i]),lnk(p[i],i);
		for(int i=1;i<=n;i++)scanf("%d",&R[i]);
		for(int i=1;i<=n;i++)scanf("%d",&T[i]);
		for(int i=1,x;i<=m;i++)scanf("%d",&x),O[x]=bo[x]=true;
		for(int i=n;i;i--)bo[p[i]]|=bo[i];
		dp(0);
		cout<<F[0]<<endl;
	}
	return 0;
}
```

---

## 作者：the_Short_Path (赞：1)

[题传](https://www.luogu.com.cn/problem/P12734)
## 形式化题意
一个具有点权和边权的森林，求出一个子图满足其中每棵树根结点的点权与所有边的边权的和最小且包含所有关键点，同时满足 $k$ 合法。
## Subtask 1 骗分
直接暴力，时间复杂度 $O(T2^n)$。
## Subtask 2 / 4 骗分
形成了链 / 菊花图，我们只需要不断地加入子节点并删除父节点 / 子节点即可，所以只要 $k\ge 2$ 即可遍历。

记 $dp_{x,0/1}$ 表示选或不选 $x$， $son(x)$ 为 $x$ 的子节点序列。前者的转移方程：
$$dp_{i,0}\gets\min(dp_{i+1,0},dp_{i+1,1}+r_{i+1})$$
$$dp_{i,1}\gets\min(dp_{i+1,0},dp_{i+1,1}+\min(r_{i+1},t_{i+1}))$$
后者的转移方程：
$$dp_{i,0}\gets\sum_{j\in son(i)}\min(dp_{j,0},dp_{j,1}+r_{j})$$
$$dp_{i,1}\gets\sum_{j\in son(i)}\min(dp_{j,0},dp_{j,1}+\min(r_{j},t_{j}))$$
时间复杂度都是 $O(Tn)$。
## 注意事项
特判 $k=1$，此时答案为 $r_i$ 的和。

当 $i$ 为关键点时，$dp_{i,0}$ 应初始化为 $\infty$。

虽然这个图并没有根节点，但我们可以增加一个 $0$ 号点作为每个森林的根节点的父节点，从而得到“根节点”。
### $x$ 合法的定义
指维护一个集合，初始化为**只含根结点**的集，可以进行两种操作：
1. 删除集合中任意一个元素（即“忘记”，**被删除的元素不能再加入集合**）。
2. 加入元素（即“回想”）或集合中一个元素的子节点（即“联想”）。

若存在一种遍历该图的方式，使得该图上的所有结点均加入过集合一次，并且集合的大小始终不超过 $x$，则该图满足 $x$ 合法。
## 正解
若树满足以下情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/cmfozl2x.png)

则可以保留根结点，并依次遍历所有满足 $k−1$ 合法的子树，最后删除根并遍历满足 $k$ 合法的子树，那么全树就是满足 $k$ 合法的了。

如果同时有两个以上 $k$ 合法的子树，在遍历其中一个 $k$ 合法子树时，因为根节点未删除，所以在最后集合的大小会变成 $k+1$，此时不满足 $k$ 合法。

综上我们可以得出以下转移方程：
- $dp_{i,0}\gets\sum_{j\in son(i)}\min(dp_{j,0},dp_{j,k}+r_{j})$，$dp_{i,1}$ 同理。

- $dp_{i,x}(x\ge2)$ 分三种情况讨论，对于每个 $j\in son(i)$：
  1. $j$ 不选，则为 $dp_{j,0}$；
    
  2. $j$ 是子图中某棵树的根，则为 $dp_{j,k}+r_j$；
 
  3. $j$ 是子图中 $i$ 的子节点，则为 $dp_{j,x−1}+t_j$，或存在一个 $j$ 是 $dp_{j,x}+t_j$。
 
  - 转移以上三者中的最小值。若没有最小值，则选取满足与以上三者最小值的差最小的 $dp_{j,x}+t_j$，将差值转移即可。

时间复杂度 $O(Tnk)$。

最后再提醒一句：**十年 OI 一场空，不开 `long long` 见祖宗。**
## Code
```cpp
#include <bits/stdc++.h>
#define int long long // 一定要开 long long！！！
using namespace std;
const int inf = 1e18;
int n, m, k;
int r[100005], t[100005];
int dp[100005][15], g[100005][15];
vector <int> G[100005];
set <int> p;
void init() {// 初始化
    p.clear();
    memset(dp, 0, sizeof(dp));
    memset(g, 0, sizeof(g));
    for (int i = 0; i <= n; i++) G[i].clear();
}
void read() {// 读入
    for (int i = 1, x; i <= n; i++) cin >> x, G[x].push_back(i);// 无需维护数组
    for (int i = 1; i <= n; i++) cin >> r[i];
    for (int i = 1; i <= n; i++) cin >> t[i];
    for (int i = 1, x; i <= m; i++) cin >> x, p.insert(x), dp[x][0] = inf;// 注意初始化为 inf
}
void DP() {// dp 方程在前文中分析过
    for (int i = n; i > 0; i--) {// 倒序遍历
        if (G[i].size()) {// 特判没有子节点
            for (auto j : G[i]) {
                for (int x = 2; x <= k; x++) {
                    int qwq = min(dp[j][0], min(dp[j][k] + r[j], dp[j][x - 1] + t[j]));
                    dp[i][x] += qwq;
                    g[i][x] = min(g[i][x], dp[j][x] + t[j] - qwq);
                }
                dp[i][1] += min(dp[j][0], dp[j][k] + r[j]);
            }
            for (int x = 2; x <= k; x++) {
                dp[i][x] += g[i][x];
                dp[i][x] = min(dp[i][x], dp[i][x - 1]);
            }
            if (!p.count(i)) dp[i][0] = dp[i][1];// 注意记得赋值
        }
    }
    // 这里直接定义一个变量（比如 ans）求和也行
    for (auto x : G[0]) dp[0][0] += min(dp[x][0], dp[x][k] + r[x]);
}
signed main() {
    int T;
    cin >> T;
    while (T--) {
        cin >> n >> m >> k;
        init();
        read();
        DP();
        cout << dp[0][0] << endl;
    }
    return 0;
}
```

---

## 作者：ELECTRODE_kaf (赞：0)

每个时间最多只有一个前置事件，那么事件之间的关系可以看做一个森林。题目所求的方案就是这个森林的一个子图，按照回想每个子树的根节点，再沿着树边联想的方式遍历每个关键点。代价就是选中的子图中包含的每个子树的根节点的点权和加上边权和。

还需考虑题中关于脑容量的额外限制。记脑容量为 $K$ 的限制为限制 $K$。对于一个子树，若满足限制 $K$，临界情况下，以它的根节点的子节点为根节点的子树中有一个满足限制 $K$，其它都满足限制 $K-1$。这样我们可以先遍历满足限制 $K-1$ 的子树，把根节点保留在脑海中以从一个子树过渡到另一个，最后遍历满足限制 $K$ 的子树，联想得到第一个节点后就删掉根节点。

考虑 DP。设 $dp_{i,j}$ 表示以 $i$ 为根的子树满足限制 $j$ 时的最小代价，不包含回想或联想事件 $i$ 的花费。特别地，$dp_{i,0}$ 表示 $i$ 不包含在所选子树中时的最小花费。如果事件 $i$ 是关键点那就不能不选了，所以此时 $dp_{i,0}=\infty$。

若不选节点 $i$ 就无法联想它的子节点。那么有：$dp_{i,0}=\sum_{\text{j是i的子节点}}\min(dp_{j,0},dp_{j,k}+r_j)$。

同理联想其它事件时当前事件肯定还在占用脑容量，所以脑容量为 $1$ 等于是没有，所以 $dp_{i,1}=\sum_{\text{j是i的子节点}}\min(dp_{j,0},dp_{j,k}+r_j)$。

$i\ge 2$ 时可以使用联想，有 $dp_{i,u}=\sum_{\text{j是i的子节点}}\min(dp_{j,0},dp_{j,k}+r_j,dp_{j,u-1}+t_j)$。但这样的话还没有考虑其中一个子树可以满足限制 $K$ 的情况。实现上可以先让所有子树都满足限制 $K-1$，再记录考虑特殊情况后的差值，最后再更新。最后用 $dp_{i,j}=min(dp_{i,j},dp_{i,j-1})$ 刷一遍。

答案即为所有子树的代价和：$ans=\sum_{\text{i是子树树根}} \min(dp_{i,0},dp_{i,k}+r_i)$

```cpp
const ll N=1e5+10,K=20,MAX=1e17;
ll n,m,k;
vector<ll> g[N];
ll r[N],t[N];
bool tg[N];
ll dp[N][K],l[N][K];

ll min3(ll a,ll b,ll c){
	return min(min(a,b),c);
}

void ini(){
	init(tg,0);
	init(dp,0);
	init(l,0);
	
	rep(i,0,N-1) g[i].clear();
}

void solve(){
	cin>>n>>m>>k;
	
	rep(i,1,n){
		ll p;
		cin>>p;
		g[p].pb(i);
	}
	
//	rep(i,0,n){
//		cout<<i<<':';
//		
//		for(ll j:g[i]) cout<<j<<' ';
//		
//		endl;
//	}
//	
//	pause;
	
	rep(i,1,n) cin>>r[i];
	
	rep(i,1,n) cin>>t[i];
	
	rep(i,1,m){
		ll p;
		cin>>p;
		tg[p]=1;
		dp[p][0]=MAX;
	}
	
	rep_(i,n,1){
		if(g[i].empty()) ctn;
		
		for(ll j:g[i]){
			ll f1,f2;
			
			rep(u,2,k){
				f1=min3(dp[j][0],dp[j][k]+r[j],dp[j][u-1]+t[j]);
				dp[i][u]+=f1;
				f2=dp[j][u]+t[j];
				update(l[i][u],f1-f2,max);
			}
			
			dp[i][1]+=min(dp[j][0],dp[j][k]+r[j]);
//			cout<<"signal 1\ndp[i][1]="<<dp[i][1]<<'\n';
//			cout<<dp[j][0]<<' '<<dp[j][k]+r[j]<<'\n';
//			pause;
		}
		
		rep(j,2,k){
			dp[i][j]-=l[i][j];
			update(dp[i][j],dp[i][j-1],min);
		}
		
		if(tg[i]==0) dp[i][0]=dp[i][1];
		
//		rep(j,0,k){
//			cout<<"dp["<<i<<"]["<<j<<"]="<<dp[i][j]<<'\n';
//			pause;
//		}
	}
	
	ll ans=0;
	
	for(ll i:g[0]) ans+=min(dp[i][0],dp[i][k]+r[i]);
	
	cout<<ans<<'\n';
}

int main(){
	ll Q;
	cin>>Q;
	
	count(Q){
		ini();
		solve();
	}
}
```

---


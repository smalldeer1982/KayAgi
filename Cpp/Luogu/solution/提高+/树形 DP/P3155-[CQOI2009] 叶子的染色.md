# [CQOI2009] 叶子的染色

## 题目描述

给一棵 $m$ 个结点的无根树，你可以选择一个度数大于 $1$ 的结点作为根，然后给一些结点（根、内部结点和叶子均可）着以黑色或白色。

你的着色方案应该保证根结点到每个叶子的简单路径上都至少包含一个有色结点（哪怕是这个叶子本身）。 

对于每个叶结点 $u$，定义 $c_u$ 为从根结点到 $u$ 的简单路径上最后一个有色结点的颜色。给出每个 $c_u$ 的值，设计着色方案，使得着色结点的个数尽量少。

## 说明/提示

#### 数据规模与约定
对于全部的测试点，保证 $1\le m\le 10^4$，$1\le n\le 5021$，$1\le a < b \le m$。

## 样例 #1

### 输入

```
5 3
0
1
0
1 4
2 5
4 5
3 5```

### 输出

```
2```

# 题解

## 作者：灵乌路空 (赞：64)

先无良宣传一下博客 $wwwwww$  
[文章列表 - 核融合炉心 - 洛谷博客](https://www.luogu.org/blog/koishikoishi/)

------------

## 知识点: 树形$DP$ , $DFS$

- ### 分析题意:  
  易证 , 随意选择一个不为叶节点的点为根  
  对答案没有任何影响  
	
    - 证明:由题,  
	  着色方案 应该保证 根结点到每个叶子的简单路径上  
	  都至少包含一个有色结点（哪怕是这个叶子本身）  
	  叶节点的 着色方案  
	  只与其上方第一个有色节点有关    
	  由此,得证.  
  
  由上 , 假设随意选择了一个非叶节点 , 作为根节点:  
  并且 , 设$f[i][j]$ ,为 第 $i$ 个点 , 将其染成 $j$ 颜色,所需要的代价    
  
    - 可以得知,  
	  如果某一个节点需要被染成 $x$ 色 ,   
	  并且他的 父亲节点 已经被染成了 $x$ 色  
	  则,他不需要被染色 , 
      就可以继承父亲的颜色    
	  
    - 则,对于某一个节点,    
	  其被染成 $x$ 色的代价,  
      
	  1. 可以直接继承 其父亲被染成 $x$ 色的代价  
      2. 可以保持父亲为 非 $x$ 色,  
         并将此节点单独染成 $x$ 色  
         
  可得到 状态转移方程:   
  
  ```cpp
  f[u][0]+=min(f[v][0]-1,f[v][1]); //u表示v的父亲节点   
  f[u][1]+=min(f[v][1]-1,f[v][0]);
  ```
  
  表示 , 将一个节点 染成颜色 $j$ 的代价 ,   
  即: 为其所有 子节点 染成颜色 $j$ 代价的 和 .

------------

- ### 算法实现 :

  由此 , 可以进行 树形 $DP$ :

  
    - 初始化:   
      $f[i][1]=1\ ,\ f[i][0]=1$,  
      代表将每个点 ， 染成某种颜色的代价均为 $1$  
	  
      特别的 , 对于叶节点 , $f[i][\ (!c[i])\ ] = INF$  ,   $(\ c[i]$ 为叶节点应该变成的颜色 $)$ ,     
      表示叶节点 $i$ 不应被染成其他颜色,  
      所以设为极大代价 , 保证不会被用来更新其他节点    
      
  之后 , 随意选择一个非叶节点 , 作为树根 , 开始进行 $DFS$  
    
    1. 当到达叶节点时 ,   
       直接 $return ;$ (叶节点的代价不需要被更新)
    2. 否则 , 循环枚举所有 **非父亲节点** ,   
       先更新它们的值
    3. 待递归回到 某节点时 ,   
       用它已经被更新的子节点 ,   
       来更新它的值
  
  $DFS$ 完成后 , 得到了所有的 $f[][]$ 的值 .   
  由于根节点有 $0,1$ 两种颜色的情况  
  所以在根节点的两值 $f[root][0]$ 与 $f[root][1]$ 中 , 取一个最小值  
  即所求的答案.
  
------------

上代码   ~~(没必要那么多注释了吧)~~ :


```cpp
#include<cstdio>
#include<queue>
#include<ctype.h>
#define int long long
#define min(a,b) a<b?a:b
//======================================================
const int MARX = 1e4+10;
const int INF = 2147483647;//极大值 
struct edge 
{
	int u,v,ne;
}e[2*MARX];
int m,n,c[MARX];//输入数据 
int root,num,head[MARX]; //建树 
int f[MARX][2]; // f[i][j]表示,第i个点,将其染成j颜色,所需要的代价
//======================================================
inline int read()
{
	int fl=1,w=0;char ch=getchar();
	while(!isdigit(ch) && ch!='-') ch=getchar();
	if(ch=='-') fl=-1;
	while(isdigit(ch)){w=w*10+ch-'0',ch=getchar();}
	return fl*w;
}
inline void add(int u,int v)
{
	e[++num].u=u,e[num].v=v;
	e[num].ne=head[u],head[u]=num;
}
void dfs(int u,int fa)
{
	if(u<=n) return ;//叶节点,直接return ; 
	for(int i=head[u],v=e[i].v;i;i=e[i].ne,v=e[i].v)//枚举所有非父节点 
	  if(v!=fa)
	  {
	    dfs(v,u);
		f[u][0]+=min(f[v][0]-1,f[v][1]);//用子节点,更新当前点的各值 
		f[u][1]+=min(f[v][1]-1,f[v][0]);
	  }
}
//======================================================
signed main()
{
	m=read(),n=read();
	root=n+1;//随意选择一个不为叶节点的节点 
	for(int i=1;i<=n;i++) c[i]=read();
	for(int i=1;i<=m-1;i++)
	{
	  int u=read(),v=read();
	  add(u,v),add(v,u);
	}
	for(int i=1;i<=m;i++)//初始化 
	{
	  f[i][0]=f[i][1]=1;
	  if(i<=n) f[i][(!c[i])]=INF;//叶节点特殊初始化 
	}
	dfs(root,root);
	printf("%lld",min(f[root][0],f[root][1]));//取较小的值 
}
```


---

## 作者：太过年轻ya (赞：43)

这题卡了很长时间吧，作为一道树状dp练手题，我觉得是需要写一篇题解加强理解。（个人理解，如有错误请指出）

1.题意：题目所给出的叶子节点到根（自己定）的最短路径上要有**至少**一个染色节点，并且必须满足规定的最后一个（即路径上离自己**最近**）染色节点的颜色为c[u];

2.看到这题，我们应该想到树状dp的基本思路，**f[u][]表示以u为根节点的子树满足条件所能获得的（局部）最优解**，后一维根据具体题目而定（一般是该节点的状态），然后在深搜中利用儿子的状态更新自己的值，遍历到叶子节点就直接初始化

3.回看这题，无非节点的状态就三种：

一：黑色 二：白色 三：无色（**不要以为白色就是无色**）

那么得出dp数组f[u][3]，表示将节点u~~断剑重铸~~之后，以u为根节点的子树所要染色节点数的最小值

那么转移方程是什么呢，我们要保证答案最小，就应该秉承节点能不染就不染的原则，那么如果递归返回时儿子已经染色，爸爸就不必染色（不懂回看1黑体字），并且我们需要累加每种情况儿子节点所需要的（最小）染色数（显然？），最后就可以~~轻松~~写出状态转移方程
```cpp
go为其儿子
f[x][0]+=min(f[go][0]-1,min(f[go][1],f[go][2]));
f[x][1]+=min(f[go][0],min(f[go][1]-1,f[go][2])); 
f[x][2]+=min(f[go][0],min(f[go][1],f[go][2]));
```
**注意**：此题重点其实并不在于（个人见解）方程，而是边界条件！！

深搜的时候，当遍历到叶子节点，它的dp数组值其实早已可以确定，拿一个例子来说
```cpp
if(c[x])
{f[x][1]=1;  f[x][0]=INF; f[x][2]=1;}
```
c[x]=1进入，即需要白色，f[x][0]为INF??,我们知道，如果x节点染成黑色，那么就不满足题意，此状态是矛盾的，所以我们必须无视它，怎么办，将其置为无穷大就不会用到这个值了。

以下是代码
------------


```cpp
#include <cstdio>
#include <iostream>
#define N 10001
#define INF 0x3f3f3f3f
using namespace std;
int n,m,root;
int u,v,w;
int head[N],f[N][3],c[5022],indegree[N]; //状态含义：以i节点为根的子树可满足条件需要染色节点数的最小值 
//易知如果爸爸染色，儿子可以不染 
struct edge
{
	int to,next;
}e[N<<1];
void dfs(int x,int fa)
{
	if(x<=n)  //叶子节点初始化 
	{
		if(c[x])
		{f[x][1]=1;	f[x][0]=INF; f[x][2]=1;}
		else
		{f[x][0]=1;	f[x][1]=INF; f[x][2]=1;}
	}
	else {f[x][0]=1; f[x][1]=1;}//普通节点初始化 
	for(int i=head[x];i;i=e[i].next)
	{
		int go=e[i].to;
		if(go!=fa)
		{
			dfs(go,x);
			f[x][0]+=min(f[go][0]-1,min(f[go][1],f[go][2]));//加上儿子节点所需的染色节点数 
			f[x][1]+=min(f[go][0],min(f[go][1]-1,f[go][2])); 
			f[x][2]+=min(f[go][0],min(f[go][1],f[go][2])); 
		}
	}
	return ;
}
int main()
{
	ios::sync_with_stdio(false);
	cin>>m>>n;
	for(int i=1;i<=n;i++)
	cin>>c[i];
	for(int i=1;i<=m-1;i++)
	{
		cin>>u>>v;
		indegree[u]++; indegree[v]++;
		if(!root)
		{
			if(indegree[u]>1) root=u;
			else if(indegree[v]>1) root=v;
		}
		e[i]=(edge) {v,head[u]}; head[u]=i;
		e[i+m-1]=(edge) {u,head[v]}; head[v]=i+m-1;
	}
	dfs(root,0); 
	cout<<min(f[root][0],min(f[root][1],f[root][2]));
	return 0;
}
```

---

## 作者：redegg (赞：13)

换根写法。

如果固定根的位置，这题就是基础的树形$dp$。

这个树形$dp$的转移很简单，类似贪心，下面的黑色点数和白色点数谁多我选谁。一样多的话，我们可以把它标记一下，向上合并的时候进行特判。

但是根是不固定的，我们枚举每个根会使复杂度达到$O(10^8)$。

当然，我们可以用记忆化来降低复杂度，这题可以解决，但是我看了一下题解好像没有人是换根的做法。

我就讲讲换根怎么做吧。

我们给每个点记录四个值：$b,w,v,ok$。分别表示它下一层节点中黑色点的个数，白色点的个数，它子树一共染色的点数，它的颜色。

当$ok==0$，白色，$ok==1$时，黑色，$ok==2$时，特殊标记。

我们换根的时候，我们可以先把我们即将转移过去的点$j$，从我们当前的点$i$的答案里去掉。当然了，$i$在这时还是根，然后$i$重新计算一下自己的颜色，然后当做是$j$的子树直接更新上去就得到$j$为根的答案了！

换根的细节需要自己想，其他还有就是当黑色白色相等时特殊标记后该如何处理。

```
#include <bits/stdc++.h>
using namespace std;

int n,m;

struct ha
{
    int b,w,v,ok;
}t[100005];

vector<int> q[100005];

int dfs(int x,int father)
{
    int o=0;
    for(int i=0;i<q[x].size();i++)
    {
        int nx=q[x][i];
        if(nx==father)continue;
        dfs(nx,x);
        if(t[nx].ok==1)t[x].b++;
        else if(t[nx].ok==0)t[x].w++;
        else {o++,t[x].b++,t[x].w++;}
        t[x].v+=t[nx].v;
    }
    if(t[x].b>t[x].w)
    {
        t[x].w-=o;
        t[x].v-=t[x].b;
        t[x].v+=1;
        t[x].ok=1;
    }
    else if(t[x].b<t[x].w)
    {
        t[x].b-=o;
        t[x].v-=t[x].w;
        t[x].v+=1;
        t[x].ok=0;
    }
    else
    {
        t[x].b-=o;
        t[x].v-=t[x].w;
        t[x].v+=1;
        t[x].ok=2;
    }
    for(int i=0;i<q[x].size();i++)
    {
        int nx=q[x][i];
        if(nx==father)continue;
        if(t[nx].ok==2)
            t[nx].ok=t[x].ok;
    }
}

int ans=1e9;

void change(int x,int nx)
{
    if(t[x].ok)
        t[x].v=t[x].v+t[x].b-1;
    else
        t[x].v=t[x].v+t[x].w-1;
    if(t[nx].ok==1)
        t[x].b--;
    else if(t[nx].ok==0)
        t[x].w--;
    t[x].v-=t[nx].v;
    if(t[x].b>t[x].w)
    {
        t[x].ok=1;
        t[x].v-=t[x].b;
        t[x].v+=1;
    }
    else if(t[x].b<t[x].w)
    {
        t[x].ok=0;
        t[x].v-=t[x].w;
        t[x].v+=1;
    }
    else
    {
        t[x].ok=2;
        t[x].v-=t[x].w;
        t[x].v+=1;
    }
}

int dd(int x,int father)
{
    ans=min(ans,t[x].v);
    for(int i=0;i<q[x].size();i++)
    {
        int nx=q[x][i];
        if(nx==father)continue;
        change(x,nx);
        dfs(nx,x);
        change(nx,x);
    }
}

int main()
{
    scanf("%d%d",&m,&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&t[i].ok);
        if(t[i].ok==1)
            t[i].b=1;
        else
            t[i].w=1;
        t[i].v++;
    }
    for(int i=1;i<m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        q[x].push_back(y);
        q[y].push_back(x);
    }
    dfs(n+1,n+1);
    dd(n+1,n+1);
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：ccsc (赞：11)

本题题意：

1.题目所给出的叶子节点到根（自己定）的最短路径上要有至少一个染色节点，

2.并且必须满足规定的最后一个（即路径上离自己最近）染色节点的颜色为c[u];



这是本题的要求；

那么由于本题的“**根**”没有确定，，所以我们要先思考“**根**”的确定问题，；

首先我们先放结论：**选择任意一个点为根，答案都是相同的。**

迷之证明：假如原来以x为根，且y与x相邻，那么x与y的颜色不可能相同（必然）。既然颜色不同，那么将根从x变成y对答案显然也不会产生影响。


所以这道题变变得简单了起来……

我们随便选一个点为根，然后树形DP。

那么dp需要一个优秀的状态：

因为对于每个节点有：

		1.无色；	
        	2.白色；
            3.黑色；
            
那么就会有三种选择，但是由于无色不会对答案有影响，只有叶节点的着色方案
只与其上方第一个有色节点有关，，所以无色的状态十分没用（这一点你们可以在完全理解时体会到，对于在看这篇文章的dalao们肯定没任何问题的）

所以我们只设两种状态即可：

		用f[x][0/1]表示x的子树中，最后一个点想要得到一个白色/黑色的祖先的最小代价（即所求答案：着色方案，**使得着色结点的个数尽量少**）
        
那么优秀的转移也随之出世啦：

如果某一个节点需要被染成 x 色 ,
并且他的 父亲节点 已经被染成了 x 色
则,他不需要被染色 , 就可以继承父亲的颜色

则,对于某一个节点,
其被染成 x 色的代价,

可以直接继承 其父亲被染成 x 色的代价
可以保持父亲为 非 x 色,
并将此节点单独染成 x 色
可得到 状态转移方程:
```cpp
f[root][0]+=min(f[a[i].to][0]-1,f[a[i].to][1]);
            f[root][1]+=min(f[a[i].to][1]-1,f[a[i].to][0]);
```

大概细节问题大家需要注重，，即可理解

code：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=0x7fffffff;
const int mm=10010;
struct p{
	int nxt,to;
}a[mm<<1];
int head[mm],cnt=0,f[mm][2],n,m,w[5000];

inline int read(){
	int x=0,f=1;
	char ch;
	ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch-'0');
		ch=getchar(); 
	}
	return x*f;
}

inline void add(int x,int y){
	a[++cnt].nxt=head[x];
	a[cnt].to=y;
	head[x]=cnt;
}

inline void dp(int root,int fa){
	f[root][0]=f[root][1]=1;
    if (root<=m){
    	if (w[root]) 
			f[root][0]=inf;
    	else 
			f[root][1]=inf;
	}
    for (int i=head[root];i;i=a[i].nxt)
    {
        if (a[i].to!=fa)
        {
            dp(a[i].to,root);
            f[root][0]+=min(f[a[i].to][0]-1,f[a[i].to][1]);
            f[root][1]+=min(f[a[i].to][1]-1,f[a[i].to][0]);
        }

    }
}

int main(){
	n=read();
	m=read();	
	for(int i=1;i<=m;i++){
		w[i]=read();
	}
	int x,y;
	for(int i=1;i<n;i++)
	{
		x=read();
		y=read();
		add(x,y);
		add(y,x);
	}
	dp(m+1,-1);
	cout<<min(f[m+1][0],f[m+1][1]);
	return 0;
}
```


---

## 作者：Reanap (赞：5)

首先，选择任意一个度数大于$1$的节点为根的最优的答案都是固定的，具体证明这里不加赘述。

我们仔细研究，他只要求根节点到叶子节点的最后一个有色节点的颜色。我们对第$x$号节点染色，意味着我们把所有它子树中的叶子节点最近的一个有色节点的颜色就发生了改变。显然，儿子越多的节点性价比越高。

因此，我们定义$dp_{i,0/1}$为第$i$号节点染成第$j$种颜色的最小花费，那么对于$j$号节点是他的儿子，可以把他的儿子染成异色，也可以让儿子的颜色与他一致，有转移方程如下：

$dp_{i,0}$ += $min(dp_{j,0} - 1 , dp_{j,1})$

$dp_{i,1}$ += $min(dp_{j,1} - 1 , dp_{j,0})$

~~~~
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int MAXN = 1e4 + 5;
int head[MAXN] , to[MAXN << 1] , nxt[MAXN << 1] , cnt , n , m;
int c[MAXN] , dp[MAXN][2];
void add(int x , int y){nxt[++cnt] = head[x];head[x] = cnt;to[cnt] = y;}
void read(int &x) {
	int f = 1;x = 0;char s = getchar();
	while(s < '0' || s > '9') {if(s == '-') f = -1;s = getchar();}
	while(s >= '0' && s <= '9') {x = (x << 3) + (x << 1) + s - '0';s = getchar();}
	x *= f;
}
void dfs(int x , int fa) {
	if(x <= n) {
		dp[x][c[x]] = 1; // 染上的花费
		dp[x][!c[x]] = 1e9; // 不能染这种颜色，设为无穷大
		return;
	}
	dp[x][0] = dp[x][1] = 1;
	for (int i = head[x]; i; i = nxt[i]) {
		if(to[i] == fa) continue;
		dfs(to[i] , x);
		dp[x][0] += min(dp[to[i]][0] - 1 , dp[to[i]][1]);
		dp[x][1] += min(dp[to[i]][0] , dp[to[i]][1] - 1);
		//转移，如上
    }
}
int main() {
	read(m);read(n);
	for (int i = 1; i <= n; ++i) read(c[i]);
	for (int i = 1; i < m; ++i) {
		int x , y;
		read(x);read(y);
		add(x , y);
		add(y , x);
	}
	dfs(m , m);//姑且选m为根节点
	printf("%d" , min(dp[m][0] , dp[m][1]));
	return 0;
}

```

---

## 作者：BillYang (赞：5)

这题可以贪心，详见此http://blog.csdn.net/bill\_yang\_2016/article/details/54604122

```cpp
#include<algorithm>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdlib>
#include<vector>
#include<cstdio>
#include<cmath>
#include<queue>
using namespace std;
inline const int Get_Int() {
    int num=0,bj=1;
    char x=getchar();
    while(x<'0'||x>'9') {
        if(x=='-')bj=-1;
        x=getchar();
    }
    while(x>='0'&&x<='9') {
        num=num*10+x-'0';
        x=getchar();
    }
    return num*bj;
}
int cnt=0,Head[50005],n,Leaf,f[50005][3];
struct Edge {
    int to,next;
} Edge[50005];
void AddEdge(int from,int to) {
    cnt++;
    Edge[cnt].to=to;
    Edge[cnt].next=Head[from];
    Head[from]=cnt;
}
void TreeDp(int Now,int father) {
    if(Now<=Leaf)return;
    for(int i=Head[Now]; i; i=Edge[i].next) {
        int Next=Edge[i].to;
        if(Next==father)continue;
        TreeDp(Next,Now);
        f[Now][0]+=min(f[Next][0]-1,min(f[Next][1],f[Next][2]));
        f[Now][1]+=min(f[Next][0],min(f[Next][1]-1,f[Next][2]));
        f[Now][2]+=min(f[Next][0],min(f[Next][1],f[Next][2]));
    }
    f[Now][0]++;
    f[Now][1]++;
}
int main() {
    n=Get_Int();
    Leaf=Get_Int();
    for(int i=1; i<=Leaf; i++) {
        int color=Get_Int();
        f[i][color]=1;
        f[i][(color+1)%2]=f[i][2]=0x7fffffff/2;
    }
    for(int i=1; i<n; i++) {
        int x=Get_Int(),y=Get_Int();
        AddEdge(x,y);
        AddEdge(y,x);
    }
    TreeDp(Leaf+1,-1);
    printf("%d\n",min(f[Leaf+1][0],min(f[Leaf+1][1],f[Leaf+1][2])));
    return 0;
}
```

---

## 作者：zhouenji (赞：4)

题目说的很清楚，从根到叶子节点u的最后一个有色节点是c[u]；无后效性我们就可以用动态规划

我们用dp[x][j]表示以x染色为j，x为根的子树在合法情况下至少要染多少个点

那么在x的直接儿子中与x选择颜色相同的节点就可以放弃，与x选择颜色不同的节点就可以直接加上

说得不是很清楚，可以看看代码，再看看可能就理解了

以下是代码：

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=100000+10;
const int inf=1e9;
struct nod
{
    int next,to;
}e[maxn];
int head[maxn],du[maxn],c[maxn],dp[maxn][3];
int m,n,k=1,ans=0x7f7f7f7f;
void adde(int u,int v)
{
    e[++k].next=head[u];
    e[k].to=v;head[u]=k;
}
void dfs(int x,int f)
{
    if(du[x]==1 && f)
    {
        dp[x][c[x]]=1;dp[x][c[x]^1]=inf;
        return;
    }
    dp[x][1]=dp[x][0]=1;
    for(int i=head[x];i;i=e[i].next)
    {
        if(e[i].to==f) continue;
        dfs(e[i].to,x);
        dp[x][1]+=min(dp[e[i].to][1]-1,dp[e[i].to][0]);
        dp[x][0]+=min(dp[e[i].to][1],dp[e[i].to][0]-1);
    }
}
int main()
{
    scanf("%d%d",&m,&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&c[i]);
    }
    for(int i=1;i<m;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);adde(u,v);adde(v,u);du[u]++;du[v]++;
    }
    dfs(n+1,0);ans=min(dp[n+1][0],dp[n+1][1]);
    printf("%d\n",ans);
}
```

---

## 作者：Booksnow (赞：3)

# 树形DP

## 题目大意

给出一颗节点数为$m$，有$n$个叶子节点的树，对于每个叶子节点给点一个颜色$color$，要求该叶子结点本身或其祖先中至少有一个节点的颜色为$color$，现在，你要给这棵树染色，求最少给多少个点染色能达到要求。当然，你可以选择任意一个度数不为1的点当根。

## 题目分析

有题目易知：

- 可以以任何一个**非叶子节点**作为树的根

- 根节点到每个叶子结点的路径上都**至少包含一个**颜色为$c[i]$的点。

## 性质：根节点的选择与答案无关

你会发现用除叶子节点意外的任意点作为根节点，他的答案始终是一样的，接下来给出我的理解方法吧。

将根从$x$换到$y$，对于他们各自的子树而言是并无影响的，因为$x$的子树中无非就是两种情况，要么该子树中节点**颜色**与$x$**不同**，要么该子树中节点**无色**，所以，当你换掉根的时候，因为**本身即有区别**，是**不会对答案产生任何影响**的。

## DP过程


### 状态

设$f[i][0]$为把点$i$染成黑色的最优答案

则$f[i][1]$为把点$i$染成白色的最优答案

### 如何更新？

$f[u][0]+=min(f[v][0]-1,f[v][1])$

即如果将点$u$染成黑色，则他的子树将**不再需要染成黑色**，故染色数$-1$，那么同理易得

$f[u][1]+=min(f[v][1]-1,f[v][1])$

于是我们就能够开始统计答案，而最后

$ans=min(f[m][0],f[m][1])$

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=5e3+50,Edge=5e4+10;
int n,m;
int c[N];
int f[Edge][2]; 
int tot,u[Edge],v[Edge],nex[Edge],first[Edge];
inline void Add(int x,int y)
{
	nex[++tot]=first[x];
	first[x]=tot;
	u[tot]=x; v[tot]=y;
}
bool vis[Edge];
inline void DFS(int u,int last)
{
	vis[u]=1;
	if(u<=n) return;
	for(int i=first[u];i;i=nex[i]){
		int to=v[i];
		if(vis[to]) continue;
		DFS(to,u);
		f[u][0]+=min(f[to][0]-1,f[to][1]);
		f[u][1]+=min(f[to][1]-1,f[to][0]); 
	}
}
int main()
{
	memset(f,127,sizeof(f));
	scanf("%d%d",&m,&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&c[i]),f[i][c[i]]=1;
	int x,y;
	for(int i=1;i<m;i++){
		scanf("%d%d",&x,&y);
		Add(x,y); Add(y,x);
		if(i>n) f[i][0]=f[i][1]=1; 
	}
	f[m][0]=f[m][1]=1;
	DFS(m,0);
	printf("%d\n",min(f[m][0],f[m][1]));
	return 0;
}
```


---

## 作者：lytqwq (赞：3)


#### 大师法（DFS）+贪心

这道题完全不需要树状DP 啊

枚举每个度>=2的节点，然后dfs

对于每个节点：

如果是叶节点，他贡献的颜色就是  **“从根结点从U的简单路径上最后一个有色结点的颜色”** 

如果不是叶节点，我们记录  _他的孩子的贡献的颜色_ ，然后少数服从多数，这个节点的颜色就是  **他孩子支持的多的颜色** ，然后让  **支持少颜色的孩子**  自己解决问题（就是把颜色安排在自己身上，~~不靠爸爸~~） sum+=少颜色的支持人数

但是如果支持的一样多，这个节点显然能 ~~掰成两半~~ 满足任意一方， 所以这个节点的颜色可以任意选（我们可以让这个节点贡献的颜色为-1，翻成不是0和1就行了啊），另一半人自己解决 sum+=一半人

为什么贡献颜色为-1可以呢？因为这样在这个节点的父亲中就可以**无视**这个节点的贡献，翻成什么颜色都行。。。

而且！题目要求：选择一个度数大于1的结点作为根。所以
**不会出现**
根上只有-1贡献，最后连任意颜色都没有的情况

时间复杂度O(N^2)

上代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 10001
#define M 20001
int m,n;
int du[N];
int color[N],color2[N];//color2就是贡献的颜色
int Head[N],cnt,Next[M],V[M],ans=10000;
void add(int u,int v)
{
	V[cnt]=v;
	Next[cnt]=Head[u];
	Head[u]=cnt++;
}
int sum;
void dfs(int u,int father)
{
	if(u<=n)
	{
		color2[u]=color[u];
		return ;
	}
	int q1=0,q2=0;
	for(int i=Head[u];i!=-1;i=Next[i])
	{
		if(V[i]!=father)
		{
			dfs(V[i],u);
			if(color2[V[i]]==1)
			{
				q1++;
			}
			if(color2[V[i]]==0)
			{
				q2++;
			}
		}
	}
	if(q1>q2)
	{
		color2[u]=1;
		sum+=q2;
	}
	else if(q1<q2)
	{
		color2[u]=0;
		sum+=q1;
	}
	else
	{
		color2[u]=-1;//当然你也可以改成其他不是0或1的数
		sum+=q1;//
	}
	return ;
}
int main()
{
	memset(Head,-1,sizeof(Head));
	scanf("%d%d",&m,&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&color[i]);
	}
	int u,v;
	for(int i=1;i<=m-1;i++)
	{
		scanf("%d%d",&u,&v);
		du[u]++;
		du[v]++;
		add(u,v);
		add(v,u);
	}
	for(int i=n+1;i<=m;i++)
	{
		if(du[i]<=1)
		{
			continue;
		}
		sum=0;
		dfs(i,0);
		sum++;
		ans=min(ans,sum);//统计最小值
	}
	printf("%d\n",ans);
}
```



---

## 作者：angrychow (赞：3)

## [CQOI2009]叶子的染色

题解均有关于动态规划，此题解提供一个贪心解。

------------

递归，先染色最底层，然后染根节点(这里就用n+1作为根节点)。

![Pic1](http://chuantu.xyz/t6/702/1563889029x992245926.png)

然后我们统计儿子节点们的颜色，找到颜色较多的一种并将根染成此颜色，**并删除与根的颜色相同的儿子节点的颜色**。画图来表示就是：

![piccccc](http://chuantu.xyz/t6/702/1563889131x992245926.png)

但有麻烦的情况：如果儿子节点的两种不同颜色的数量和相等怎么办？（如下图）

![Pic22](http://chuantu.xyz/t6/702/1563889071x977013264.png)

在这个子结构里，染黑或染白都是一样优秀的，但对于上一层来说就不一定了。这里我们留给贪心一个犹豫的机会，我们先不染色。然后统计下一个子结构的颜色，**让这些没有染色的节点加入染色数多的节点**。

![Pic123](http://chuantu.xyz/t6/702/1563889885x2073530527.png)

染了色后，我们再执行**删除与根的颜色相同的儿子节点的颜色**这一操作。正确性用微扰法证明。

Code
------------

```cpp
#include<cstdio>
using namespace std;
const int size = 20001;
int h[size],cnt,n,m,c[size];
struct Edge{int nex,to;}a[size];
void AddEdge(int x,int y){a[++cnt].to=y;a[cnt].nex=h[x];h[x]=cnt;}
void dfs(int x,int prt)
{
	if(x<=n)return;
	int Black=0,White=0;
	for(int i=h[x];i;i=a[i].nex)
	{
		int y=a[i].to;
		if(y==prt)continue;
		dfs(y,x);if(c[y]==1)Black++;
		if(c[y]==2)White++;
	}
	if(Black>White)c[x]=1;
	else if(Black<White)c[x]=2;
	else c[x]=-1;
}
void DFS(int x,int prt)
{
	if(x<=n)return;
	for(int i=h[x];i;i=a[i].nex)
	{
		int y=a[i].to;
		if(y==prt)continue;
		DFS(y,x);
		if(c[x]==c[y]||c[y]==-1||(c[x]==-1&&c[y]==1))c[y]=0;//c[y]==1只是为了统计子树一种颜色的数量，没有实际意义
	}
}
int main()
{
	scanf("%d%d",&m,&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&c[i]),c[i]++;
	for(int i=1;i<m;i++)
	{
		int x,y;scanf("%d%d",&x,&y);
		AddEdge(x,y);
		AddEdge(y,x);
	}
	dfs(n+1,0);DFS(n+1,0);
	int Ans=0;for(int i=1;i<=m;i++)if(c[i])Ans++;
	printf("%d",Ans);return 0;
}
```


---

## 作者：7KByte (赞：1)

我的状态转移方程有点不同，题解里大多数人用$f[i][j]$表示$i$节点染颜色$j$,我的方程$f[i][j]$表示以$i$为根的子树中，$j$颜色的叶节点还没有被完全覆盖，如果所有叶节点被覆盖则$j=2$


转移

$$f[x][0]=\sum_i min\{f[son_i][2],f[son_i][0]\}$$

$$f[x][1]=\sum_i min\{f[son_i][2],f[son_i][1]\}$$

$$f[x][2]=min\{\sum_i f[son_i][2],f[x][0]+1,f[x][1]+1\}$$


指定任意非叶节点跑一次$DP$，$f[root][2]$即为答案


```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,c[10005],h[10005],tot;
struct edge{
	int to,nxt;
}e[20005];
void add(int x,int y){
	e[++tot].nxt=h[x];h[x]=tot;e[tot].to=y;
}
int f[10005][4];
void dfs(int x,int fa){
	if(x<=n)return;
	f[x][0]=f[x][1]=f[x][2]=0;
	for(int i=h[x];i;i=e[i].nxt)if(e[i].to^fa){
		dfs(e[i].to,x);
		int val=min(f[e[i].to][1],f[e[i].to][2])+1;
		f[x][0]+=f[e[i].to][0];
		f[x][1]+=min(f[e[i].to][0],f[e[i].to][1]);
		f[x][2]+=min(f[e[i].to][0],f[e[i].to][2]);
	}
	f[x][0]=min(f[x][0],min(f[x][1],f[x][2])+1);
}
int main()
{
	scanf("%d%d",&m,&n);
	for(int i=1;i<=n;i++)scanf("%d",&c[i]),c[i]++;
	for(int i=1;i<m;i++){
		int x,y;scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	int ans=0x3f3f3f3f;
	memset(f,0x3f,sizeof(f));
	for(int i=1;i<=n;i++)f[i][c[i]]=0,f[i][0]=1;
	int r=n+1;dfs(r,0);
	printf("%d\n",f[r][0]);
	return 0;
}
```

---

## 作者：pomelo_nene (赞：0)

$\ \ \ \ \ \ \ $[luogu](https://www.luogu.com.cn/problem/P3155)

$\ \ \ \ \ \ \ $真的没想到 T3 是最简单的。。。

$\ \ \ \ \ \ \ $首先猜个结论：怎么选根答案都是一样的。（毕竟这是猜结论，我也不知道为什么）。

$\ \ \ \ \ \ \ $然后再一个结论：我们把叶子染色，实际上就是把根染色。因为叶子染色只跟上面的颜色有关。

$\ \ \ \ \ \ \ $然后就完了？？定义 $dp_{i,0 \ or \ 1}$ 为 $i$ 为根，$i$ 染成黑色还是白色。则有 dp 方程：

$$\begin{cases}
dp_{now,0}=\sum_{\texttt{now的孩子们to}}\min \{dp_{to,1},dp_{to,0}-1\} \\\\
dp_{now,1}=\sum_{\texttt{now的孩子们to}}\min \{dp_{to,0},dp_{to,1}-1\}
\end{cases}$$

$\ \ \ \ \ \ \ $然后真的就完了。注意排斥掉和叶子颜色不同的方案。

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<iostream>
#include<cstring>
using namespace std;
vector<int> G[100005];
bool color[100005];
int dp[100005][2],m,n;
/*
dp[root][0/1]:root 为根 染成什么 最少多少个。
*/
void dfs(int now,int pre)
{
	if(now<=n)
	{
		dp[now][color[now]]=1;
		dp[now][!color[now]]=2147483647;
		return ;
	}
	dp[now][1]=dp[now][0]=1;
	for(unsigned int i=0;i<G[now].size();++i)
	{
		int to=G[now][i];
		if(to==pre)	continue;
		dfs(to,now);
		dp[now][0]+=min(dp[to][1],dp[to][0]-1);
		dp[now][1]+=min(dp[to][1]-1,dp[to][0]);
	}
}
int main(){
	freopen("leave.in","r",stdin);
	freopen("leave.out","w",stdout);
	scanf("%d %d",&m,&n);
	for(int i=1,tmp;i<=n;++i)	scanf("%d",&tmp),color[i]=bool(tmp);
	for(int i=1;i<m;++i)
	{
		int u,v;
		scanf("%d %d",&u,&v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
	dfs(n+1,-1);
	printf("%d",min(dp[n+1][0],dp[n+1][1]));
	return 0;
}
```

---


# [HAOI2015] 树上染色

## 题目描述

有一棵点数为 $n$ 的树，树边有边权。给你一个在 $0 \sim n$ 之内的正整数 $k$ ，你要在这棵树中选择 $k$ 个点，将其染成黑色，并将其他的 $n-k$ 个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间的距离的和的收益。问收益最大值是多少。

## 说明/提示

对于 $100\%$ 的数据，$0 \leq n,k \leq 2000$。

## 样例 #1

### 输入

```
3 1
1 2 1
1 3 2```

### 输出

```
3```

# 题解

## 作者：子谦。 (赞：399)

这道题的题解已经相当多了，但是我认为都没有对本道题做一个足够清晰的剖析，尤其是对于DP的部分。所以我希望我的这篇题解能够在以前各位的题解的基础上更进一步，让大家有一个更清晰的理解。

先强调一下，这道题的细节非常重要，一定要注意！

----

题目要求将k个点染成黑色，求黑点两两距离及白点两两距离，使他们之和最大。

我们可以将距离转化为路径，然后再将路径路径拆分成边，就可以记录每条边被经过的次数，直接计算即可。

很简单对吧？那么问题来了，距离转化为路径好理解，路径拆为边也好说，可是每条边被经过的次数怎么计算呢？

我们可以这样想，我们任意取两个同色的点，对于每一条边，若不在这两个点的路径上，我们自然不考虑，若是在两个点的路径上，那么这条边的计数加一。我们可以转换一下，若是两个点在边的一侧，则不影响计数，若在边的两侧，则边的计数加一。那么我们推广一下，便可以得出，一条边的两侧每有一对同色点，这条边就要被经过一次。也就是说，一条边被经过的次数等于边的两侧同色点个数的乘积。那么我们便可以求出每条边被经过的次数

### $tot=k*(m-k)+(sz[v]-k)*(n-m-sz[v]+k)$

$m$表示题目要求选的黑点数，$sz[v]$表示当前子节点的子树大小，$k$表示当前子节点的子树上已选择的黑点数

有了这个结论，我们就可以轻松地得出DP方程了。

### $f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]+tot*e[i].w)$

就是关于这个方程让我在做题的时候纠结了好久，为什么$k$正序排列就是对的，倒序排列就是错的？已有的题解也没有做出很好的解释，我A了之后也没有继续研究。多亏了帮同学找树形DP入门题时我重新注意到了这道题，使我对这一奇怪的现象产生了疑惑。得到了**DDOSvoid**大佬的帮助并进行了多次试验后，我终于明白了其中的原因，也让我对这道题的理解加深了数层。

这道题$k$前几篇题解必须正序枚举的原因并不是什么要用$j-k$更新答案，而是因为正序枚举$k$是从$0$开始的，而这道题的状态转移必须要先将$k=0$的状态转移过来才能成立。也就是说，这只是个巧合，$j$的枚举要倒序没错，但$k$的枚举必须正序简直就是无稽之谈。要想避免这一情况，只需提前转移一下$k=0$的情况即可。

下面放代码（内有注解）

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cctype>
#define ll long long
#define gc getchar
#define maxn 2005
using namespace std;

inline ll read(){
	ll a=0;int f=0;char p=gc();
	while(!isdigit(p)){f|=p=='-';p=gc();}
	while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=gc();}
	return f?-a:a;
}

struct ahaha{
	int w,to,next;
}e[maxn<<1];int tot,head[maxn];
inline void add(int u,int v,int w){
	e[tot].w=w,e[tot].to=v,e[tot].next=head[u];head[u]=tot++;
}

int n,m,sz[maxn];
ll f[maxn][maxn];
void dfs(int u,int fa){
	sz[u]=1;f[u][0]=f[u][1]=0;
	for(int i=head[u];~i;i=e[i].next){
		int v=e[i].to;if(v==fa)continue;
		dfs(v,u);sz[u]+=sz[v];
		for(int j=min(m,sz[u]);j>=0;--j){   //此处倒序枚举是为了避免重复选取
			if(f[u][j]!=-1)    //在DP前应先加上当前子节点的子树纯白色的情况，这是下面也倒序枚举的前提
				f[u][j]+=f[v][0]+(ll)sz[v]*(n-m-sz[v])*e[i].w;
			for(int k=min(j,sz[v]);k;--k){
				if(f[u][j-k]==-1)continue;
				ll val=(ll)(k*(m-k)+(sz[v]-k)*(n-m-sz[v]+k))*e[i].w;   //当前情况下连接子节点的边的贡献
				f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]+val);
			}
		}
	}
}

int main(){memset(head,-1,sizeof head);
	n=read();m=read();
	if(n-m<m)m=n-m;
	for(int i=1;i<n;++i){
		int u=read(),v=read(),w=read();
		add(u,v,w);add(v,u,w);
	}memset(f,-1,sizeof f);
	dfs(1,-1);
	printf("%lld",f[1][m]);
	return 0;
}
```

以上就是本道题的题解，不知道你是否看懂了呢。如有不明白的地方，欢迎提问。

---

## 作者：菲斯斯夫斯基 (赞：36)

# P3177 [HAOI2015] 树上染色 题解

本题解选自我的[树上 dp 小记](https://www.luogu.com.cn/article/5auons5k)。

好题。

一开始理所当然地想设计 $dp_{x,j}$ 为在 $x$ 子树内染了 $j$ 个点的最大价值。然后想了好久都没有思路，因为还会与子树外的点产生贡献。

正确的设计方式应该是 在 $x$ 子树内染了 $j$ 个点**对答案的贡献**。这样设计的好处是转移时直接求和即可，没有其他的贡献。

设计好数组就转移就很方便了：

$$dp_{x,j}=\max\limits_{k=\max(j-s_x+s_i,0)}^{\min(j,s_i)}dp_{x,j-k}+dp_{i,k}+v\times k\times (m-k)+v\times (s_i-k)\times (n-m-s_i+k)$$

上面的 $k$ 是枚举在 $i$ 子树内选多少个黑点，$v$ 是边的权值，$s_i$ 是 $i$ 子树大小，$s_x$ 是**目前枚举到的** $x$ 子树大小。$k\times (m-k)$ 是两边的黑点连起来经过当前这条边的次数，因为在两边任意选一个点都会经过；同理，$(s_i-k)\times (n-m-s_i+k)$ 就是白点的。

注意转移的上下界和一些细节。原始的大部分题解都是要把 dp 数组 `memset` 成 $-1$，不然会 WA。理由是可能会从不合法的状态转移而来，但这样也同时导致了时间复杂度是错误的。

为什么会从错误的状态转移而来呢？我们枚举了 $i$ 子树内有 $k$ 个点，那么就要要求前面的子树内至少有 $j-k$ 个点。原本 $k$ 从 $0$ 开始枚举的话就会有可能前面点的个数不够，从而导致从不合法的状态转移来。

时间复杂度的分析建议看这个[帖子](/discuss/708044)，这里就不过多赘述了。简单而不一定严谨地说，任意两个点只会在 lca 处合并一次，所以时间复杂度是 $\mathcal O(n^2)$ 的。

本题的困难主要在需要打破以前只计算子树内答案的思维，直接考虑对答案的贡献，正确设计 dp 数组。

这里给出代码：

```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
using namespace std;
const int N=2010;
int n,m,s[N];
long long dp[N][N];
vector<pair<int,int>>v[N];
void dfs(int x,int fa)
{
	s[x]=1;
	for(auto i:v[x])
	{
		if(i.fi==fa)continue;
		dfs(i.fi,x);
		s[x]+=s[i.fi];
		for(int j=max(m,s[x]);j>=0;j--)
			for(int k=max(j-s[x]+s[i.fi],0);k<=min(j,s[i.fi]);k++)//控制好上下界
				dp[x][j]=max(dp[x][j],dp[x][j-k]+dp[i.fi][k]+1ll*k*(m-k)*i.se+1ll*(s[i.fi]-k)*(n-m-s[i.fi]+k)*i.se);
	}
}
int main()
{
	cin>>n>>m;
	m=min(m,n-m);//染黑或染白都是一样的
	for(int i=1;i<n;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		v[x].push_back({y,z});
		v[y].push_back({x,z});
	}
	dfs(1,0);
	cout<<dp[1][m];
	return 0;
}
```

---

## 作者：Jμdge (赞：36)

----操作可以很朴素,代码可以很简短,dp就是这样短小精悍的东西


思路朴素,树形dp

dp难在设状态以及思考状态转移(都是废话).

那么这里我们可以令dp [ u ][ t ] 表示 u 号节点所处的子树中有 t 个点被染色时的最大贡献.

那么状态转移就是:

```
dp[u][t] = max{ dp[v1][t1]+dp[v2][t2]+...+dp[vs][ts] + e1*t1*(k-t1)+e1*(siz[v1]-t1)*(n-k-(siz[v1]-t1))+e2*t2*(k-t2)+e2*(siz[v2]-t2)*(n-k-(siz[v2]-t2))+...+es*ts*(k-ts)+es*(siz[vs]-ts)*(n-k-(siz[vs]-ts)) } 

其中,v1~vs 表示 u 的子节点编号,siz[i]表示i所处的子树大小, n,k 与题目中的n和k
```

但代码中的状态转移是略有不同的...

```cpp
//by Judge
#include<cstdio>
#include<cctype>
#define ll long long
#define rint register int
#define max(a,b) ((a)>(b)?(a):(b))
using namespace std;
const int M=2100;
inline ll read(){
	ll x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0';
	return x*f;
}
int n,k,pat;
int head[M];
ll siz[M],dp[M][M],tmp;
struct Edge{ int to,next; ll val; }e[M<<1];
inline void add(rint u,rint v,rint c){ e[++pat]=(Edge){v,head[u],c}, head[u]=pat; }
void dfs(rint u){ 
	siz[u]=1;
	for(rint i=head[u];i;i=e[i].next){
		rint v=e[i].to; if(siz[v]) continue;
		dfs(v); ll c=e[i].val; 
		for(rint a=siz[u];a>=0;--a)  //枚举当前点的以及当前点的其他子树的染色点数 (反向枚举,避免后效性) 
			for(rint b=siz[v];b>=0;--b)  //枚举目前处理的子树的染色点数 
				tmp=dp[u][a]+dp[v][b]+c*b*(k-b)+c*(n-k+b-siz[v])*(siz[v]-b),dp[u][a+b]=max(dp[u][a+b],tmp);
				// dp[u][a] 其他子树内的点各自独立于当前子树内的点的贡献 
				//dp[v][b] 当前子树内的点各自独立于其他子树内的点的贡献 
				//c*b*(k-b) 当前边对连接当前子树内的染色点与子树外的染色点的贡献
				//c*(n-k+b-siz[v])*(siz[v]-b) 当前边对连接当前子树内的未染色点与子树外的未染色点的贡献 
		siz[u]+=siz[v];
	}
}
int main(){   //主函数里尽是朴素操作
	n=read(),k=read();
	for(rint i=1;i<n;++i){ 
		rint x=read(),y=read(); ll c=read();
		add(x , y , c), add(y , x , c);
	}
	dfs(1), printf("%lld\n",dp[1][k]);
	return 0;
}
```

---

## 作者：i207M (赞：11)

## 题意

有一棵点数为 N 的树，树边有边权。给你一个在 0~ N 之内的正整数 K ，你要在这棵树中选择 K个点，将其染成黑色，并将其他 的N-K个点染成白色 。 将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间的距离的和的受益。问受益最大值是多少

## 实现

**如果枚举点对求贡献会T的话，不妨枚举每个边的贡献**

学到了，枚举贡献；

DP状态$dp[i][j]$表示，以i为根的子树，选出j个黑点，**在这课子树内的边的贡献和**；

所以我们的$dp[i][j]$真的是一部分的问题，不保存状态；

枚举一个边的贡献，就是每个同色点对，

```
int val = (k * (m - k) + (sz[v[i]] - k) * (n - sz[v[i]] - (m - k))) * w[i];
dp[x][j] = max(dp[x][j], dp[x][j - k] + dp[v[i]][k] + val);
```
记得初始化；

循环一定要j倒序，k正序，因为我们需要用j-k未更新的答案；

## 代码

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<list>
#include<queue>
#include<stack>
#include<bitset>
#include<deque>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define ri register int
#define il inline
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
#define mem0(x) memset((x),0,sizeof (x))
#define mem1(x) memset((x),0x3f,sizeof (x))
#define pb push_back
#define gc getchar
template<class T>void in(T &x)
{
    x = 0; bool f = 0; char c = gc();
    while (c < '0' || c > '9') {if (c == '-') f = 1; c = gc();}
    while ('0' <= c && c <= '9') {x = (x << 3) + (x << 1) + (c ^ 48); c = gc();}
    if (f) x = -x;
}
#undef gc
#define N 2010
#define M 4010
#define int ll
int n, m;
int v[M], u[M], w[M], nx[M];
int cnt, head[N];
il void add(int uu, int vv, int ww) {
    u[++cnt] = uu, v[cnt] = vv, w[cnt] = ww, nx[cnt] = head[uu];
    head[uu] = cnt;
}
int dp[N][N], sz[N];
int dfs(int x, int f) {
    sz[x] = 1;
    dp[x][0] = dp[x][1] = 0;
    for (ri i = head[x]; i; i = nx[i]) {
        if (v[i] == f) continue;
        sz[x] += dfs(v[i], x);
    }
    for (ri i = head[x]; i; i = nx[i]) {
        if (v[i] == f) continue;
        for (ri j = min(sz[x], m); j >= 0; --j) {
            for (ri k = 0; k <= min(sz[v[i]], j); ++k) {
                if (dp[x][j - k] != -1) {
                    int val = (k * (m - k) + (sz[v[i]] - k) * (n - sz[v[i]] - (m - k))) * w[i];
                    dp[x][j] = max(dp[x][j], dp[x][j - k] + dp[v[i]][k] + val);
                }
            }
        }
    }
    return sz[x];
}
signed main() {
    in(n), in(m);
    if (n - m < m) m = n - m;
    for (ri i = 1, a, b, c; i < n; ++i) {
        in(a), in(b), in(c);
        add(a, b, c);
        add(b, a, c);
    }
    memset(dp, -1, sizeof(dp));
    dfs(1, 0);
    printf("%lld", dp[1][m]);
    return 0;
}

```

---

## 作者：dayz_break404 (赞：9)

初看此题时，dp 状态很明显是两维，但是合并子树时答案难于统计，然后……~~就不会了qwq~~。

  既然不通，考虑改变 dp 数组的含义，记 $dp_{i,j}$ 表示当前 $i$ 的子树中将 $j$ 个点染黑对**总答案的贡献**。

  但是这样直接计算两点距离就变得更难了，考虑两点的路径统计，将统计相同颜色点两两之间的距离转化为统计每个边被计数的次数。于是我们每次进行转移时只需要考虑 $i$ 到它的儿子 $j$ 的边 $e_{i,j}$ 对总答案的贡献，于是有 dp 方程：
  $$dp_{u,j}=dp_{u,j-k}+dp_{v,k}+e_{u,v}k(m-k)+e_{u,v}(siz_v-k)(n-m-siz_v+k)$$

  其中 $n$ 为点的个数，$m$ 为总的可以允许染成黑色点的个数，$e_{u,v}$ 表示 $u$ 到 $v$ 边的权值，$siz_u$ 表示以 $u$ 为根的子树的大小，$j$ 和 $k$ 均为枚举的染黑点的个数。

  但是这样转移很明显是 $O(nm^2)$ 的，于是我们在枚举每一个 $m$ 时，给予 $m$ 一个上下界限制，最大可能地去优化时间复杂度，于是有了 $m$ 的限制：$m\in[\max(0,j-siz_u+siz_v),\min(j,siz_v)]$。

  可以证明，这样的时间复杂度是接近 $O(nm)$ 的。

  代码：
  
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
inline ll read(){
	ll x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	return x*f;
}
const int maxn=2e3+20;
ll n,m,head[maxn],idx,siz[maxn];
struct node{
	ll to,nxt,w;
}e[maxn<<1];
ll dp[maxn][maxn];
inline void add(int u,int v,int w){
	e[++idx].to=v,e[idx].w=w,e[idx].nxt=head[u],head[u]=idx;
}
void dfs(int u,int fa){
	siz[u]=1;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa) continue;
		dfs(v,u);
		siz[u]+=siz[v];
		for(ll j=m;j>=0;j--){
			for(ll k=max(j-siz[u]+siz[v],0ll);k<=min(siz[v],j);k++){
				dp[u][j]=max(dp[u][j],dp[u][j-k]+dp[v][k]+e[i].w*k*(m-k)+e[i].w*(siz[v]-k)*(n-m-siz[v]+k));
			}
		}	
	}
}
int main(){
	ll u,v,w;
	n=read(),m=read();
	for(int i=1;i<n;i++){
		u=read(),v=read(),w=read();
		add(u,v,w),add(v,u,w); 
	} 
	dfs(1,0);
	printf("%lld\n",dp[1][m]);
	return 0;
}
```

---

## 作者：Anins (赞：6)

## [[HAOI2015] 树上染色](https://www.luogu.com.cn/problem/P3177)

### 思路：

先考虑怎么计算答案，后动态规划。

#### 数学部分：

我们发现此题让我们计算最大收益，那我们考虑一种染色方案的收益是怎么算出来的：

显然总收益为所有边贡献之和，一条边对收益的贡献显然是经过它的次数与它的权值之积，那么总收益就是 $\sum (w[i] \times time[i])$。

接下来考虑计算一条边经过次数：

我们设这一条边的两个端点分别为 $u$，$v$，用 $size[i]$ 表示以 $i$ 为根的子树的大小，$black[i]$ 表示以 $i$ 为根的子树的黑色点个数，$white[i]$ 表示以 $i$ 为根的子树的白色点个数，那么有：

$time[i]=black[u] \times black[v] + white[u] \times white[v]$。

且恒有 $size[x]=white[x]+black[x]$。

#### 动态规划：

用 $f[u][i]$ 表示 $u$ 的子树中选 $i$ 个黑色点所获得的最大收益，枚举点 $u$ 的出边，设出边所到的点为 $v$ 那么分别枚举以 $u$ 和 $v$ 为根的子树选多少个黑色的点更新答案即可。

注意这里要由大到小枚举选点数量，因为转移是由小范围到大范围，如果由小到大枚举就会用到之前更新的答案导致重复计算。

动态规划不是本题重点，因此不过多赘述，请结合数学部分以及代码理解。

### 代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n, k;
ll head[2005], cnt;
ll f[2005][2005], size[2005];
struct node {
	ll v, w, ne;
}e[5005];
void add(ll u, ll v, ll w) {
	e[++cnt]={v, w, head[u]};
	head[u]=cnt;
}
void dfs(ll u, ll fa) {
	size[u]=1;
	for(int i=head[u], v; i; i=e[i].ne) {
		v=e[i].v;
		if(v==fa) continue;
		dfs(v, u);
		for(int x=size[u]; x>=0; x--) { //枚举u子树选多少点
			for(int y=size[v]; y>=0; y--) { //v子树选多少点
				if(x+y>k) continue; //越界跳过
				ll time=(y*(k-y))+((size[v]-y)*(n-k-size[v]+y));
        		/*(y*(k-y))表示black[v]*black[v]*/
         		/*((size[v]-y)*(n-k-size[v]+y))表示white[v]*white[u]*/
				f[u][x+y]=max(f[u][x+y], f[u][x]+f[v][y]+e[i].w*time); //f[u][x+y]由f[u][x]和f[v][y]转移过来，所以要倒序枚举
			}
		}
		size[u]+=size[v];
	}
}
int main() {
	cin >> n >> k;
	for(int i=1; i<n; i++) {
		ll u, v, w;
		cin >> u >> v >> w;
		add(u, v, w), add(v, u, w);
	}
	dfs(1, 0);
	cout << f[1][k];
	return 0;
}
```

---

## 作者：ff_666 (赞：6)

### **恕我直言，楼下的代码到BZOJ上都会TLE到飞起**

定义都没什么问题，但事实上时间复杂度绝非$O(N*N)$这么简单

*虽然我太弱，证不出具体复杂度，但事实证明复杂度为#### $O(K*N*N)$,且K不小*

但实验了一下，只有用当前解更新之后的最优解才可以勉勉强强地卡过去（700ms+）
```c++
#pragma GCC optimize(6)
#include<cstdio>
#include<cstring>
#define LL long long 
using namespace std;
const int maxn=2005;
int n,k,S[maxn];LL f[maxn][maxn];

template<typename Tp>Tp Max(Tp x,Tp y){return x>y?x:y;}
template<typename Tp>Tp Min(Tp x,Tp y){return x<y?x:y;}

int tot,lnk[maxn],nxt[maxn<<1],son[maxn<<1];LL w[maxn<<1];
void add_e(int x,int y,int z){son[++tot]=y,w[tot]=z,nxt[tot]=lnk[x],lnk[x]=tot;} 

char gt(){
	static char buf[100000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
int read(){
	int ret=0;bool f=0;char ch=gt();
	while(ch<'0'||ch>'9') f|=(ch=='-'),ch=gt();
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=gt();
	return f?-ret:ret;
}

void DFS(int x,int fa){
	S[x]=1,f[x][0]=f[x][1]=0;
	for(int j=lnk[x];j;j=nxt[j])if(son[j]!=fa){
		DFS(son[j],x);
		for(int t=Min(S[x],k);t>=0;t--)
		  for(int i=Min(k-t,S[son[j]]);i>=0;i--) f[x][i+t]=Max(f[x][i+t],f[x][t]+f[son[j]][i]+w[j]*(i*(k-i)+(S[son[j]]-i)*(n-S[son[j]]-k+i)));
		S[x]+=S[son[j]];
	}
}

int main(){
	n=read(),k=read();memset(f,192,sizeof f);
	for(int i=1;i<n;i++){
		int x=read(),y=read(),z=read();
		add_e(x,y,z),add_e(y,x,z);
	}
	DFS(1,0);
	printf("%lld\n",f[1][k]);
	return 0;
}
```

---

## 作者：cff_0102 (赞：5)

好像没有像我这样做法的树形 DP 题解？

设 $f_{i,j}$ 为将 $i$ 的子树中选 $j$ 个染黑，$i$ 的子树所有边的贡献之和的最大值是多少。

思考怎么转移，发现还要枚举每个子树被染色的点的数量！太麻烦了！于是：

设 $g_{i,j}$ 为将 $i$ 前面的所有兄弟（包括自己）的子树，再加上它的父节点这一块选 $j$ 个染黑，这里面所有边贡献之和的最大值。

不难发现，$f_{i,j}=g_{last_i,j}$，其中 $last_i$ 表示 $i$ 的最后一个儿子。

$g_{i,j}$ 的转移也不难，只需要枚举 $i$ 的子树中有几个点染黑就行，不难得到转移方程（注：原题中的 $k$ 也就是黑点总数这里改成了 $b$）：

$$g_{i,j} = \max\limits_{k=\max(0,j-presize_i)}^{\min(j,size_i)}(g_{pre_i,j-k}+f_{i,k}+fa_i\times(k\times(b-k)+(size_i-k)\times(n-b-(size_i-k))))$$

其中 $fa_i$ 是 $i$ 连到父亲的边的长度；$size_i$ 是 $i$ 子树的大小；$pre_i$ 是 $i$ 的前面一个兄弟（如果没有则为 $0$）；$presize_i$ 是 $i$ 前面所有兄弟（不包括自己）的子树及其父节点加起来那一块的大小，如果 $pre_i=0$ 则 $presize_i=1$。

转移方程也不难理解，就是枚举自己的子树有几个黑点（$k$），然后计算前面那一块的边的贡献（$g_{pre_i,j-k}$），自己子树的贡献（$f_{i,k}$），还有自己连到父亲那条边的贡献（$fa_i\times(k\times(b-k)+(size_i-k)\times(n-b-(size_i-k)))$，也就是边长乘以经过它的路径条数，黑连黑的路径条数是 $k\times(b-k)$，白连白的路径条数是 $(size_i-k)\times(n-b-(size_i-k))$）之和，取最大值就是答案。

AC 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2024;
int f[N][N],g[N][N],last[N],pre[N],size[N],fa[N],presize[N];
int n,b;
// f[i][j]：i 的子树中选 j 个染黑，i 的子树所有边的贡献之和最大 
// g[i][j]：i 前面的所有兄弟（包括自己）及其父节点这一块选 j 个染黑，这里面所有边贡献之和最大 
// fa[i]：i 连到父亲的边长 
// presize[i]：前面那一坨的大小，如果 pre[i]=0 则为 1 
// f[i][j] = g[last[i]][j]
// g[i][j] = max[k=max(0,j-presize[i]),min(j,size[i])](g[pre[i]][j-k]+f[i][k]+fa[i]*(k*(b-k)+(size[i]-k)*(n-b-(size[i]-k))))
struct edge{
	int n,l;
};
vector<edge>e[N];
void dfs(int x,int l){
	size[x]=1;
	int las=0;
	for(edge t:e[x])if(t.n!=l){
		int y=t.n,w=t.l;
		fa[y]=w;
		pre[y]=las;
		las=y;
		presize[y]=size[x];
		dfs(y,x);
		size[x]+=size[y];
	}
	last[x]=las;
	for(int j=0;j<=b;j++)f[x][j]=g[last[x]][j];
	for(int j=0;j<=b;j++){
		for(int k=max(0ll,j-presize[x]);k<=min(j,size[x]);k++){
			g[x][j]=max(g[x][j],g[pre[x]][j-k]+f[x][k]+fa[x]*(k*(b-k)+(size[x]-k)*(n-b-(size[x]-k))));
		}
	}
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>n>>b;
	for(int i=1;i<n;i++){
		int u,v,w;cin>>u>>v>>w;
		edge eu{v,w},ev{u,w};
		e[u].push_back(eu),e[v].push_back(ev);
	}
	dfs(1,0);
	cout<<f[1][b];
	return 0;
}
```

记得开 `long long`。

---

## 作者：YuYuanPQ (赞：4)

~~早上刚学的新鲜的 DP 题。~~

题意很简洁，废话不多说，进入正题。

设 $f_{x,j}$ 表示在以 $x$ 为根的子树中，有 $j$ 个点被染色的最大贡献。

## 先给出状态转移方程：

$f_{x,j}=\max(f_{x,j},f_{x,j-k}+f_{y,k}+w\times k\times(m-k)+w\times (siz_y-k)\times(n-m-siz_y+k))$

## 解释一下：

### 变量：

枚举 $j$，$k$。

- $j$ 代表在以 $x$ 为根的子树中，有 $j$ 个点被染色。所以 $j$ 可以取到：以 $x$ 为根的子树的大小和选择点的总数中最大的一个，也就是 $\max(siz_x,m)$。

- $k$ 代表在以 $x$ 为根的子树中，有 $k$ 个点被染成黑色。而 $k$ 可以从 $[\max(j-siz_x+siz_y,0),\min(j,siz_y)]$ 中取。

### 状态转移方程：

$f_{x,j-k}+f_{y,k}$ 代表以 $x$ 为根的子树和以 $y$ 为根的子树中，一共染了 $j-k+k=j$ 个点的最大贡献。

接下来，用到了乘法原理来解决：用子树里的乘上子树外的，即可得到贡献。

$k\times(m-k)$ 代表在以 $x$ 为根的子树中，子树里黑色点的个数乘子树外黑色点的个数。（子树外黑色点的个数可以用黑色点总个数减去子树里黑色点总个数求出）

$(siz_y-k)\times(n-m-siz_y+k)$ 代表在以 $y$ 为根的子树中，用子树大小减去黑色点个数，可以得到白色点个数，再乘上外面的白色点个数：也就是先 $n-m$ 得到白色点总个数，再 $-(siz_y-k)$ 也就是 $-siz_y+k$ 求出。

讲得很详细吧。

如果认为我的理解帮到了你，不妨点个赞再走吧~

完结撒花花~

## Code

```cpp
#include<bits/stdc++.h>
#define PII pair<int,int>
#define mkp make_pair
#define lowbit(x) ((x)&(-x))
#define pb push_back
using namespace std;
typedef long long ll;
const int N=2000;
int n,m,siz[N+10];
ll f[N+10][N+10];
vector<PII>g[N+10];
void dfs(int x,int fa)
{
    siz[x]=1;
    for(int i=0;i<g[x].size();i++)
    {
        int y=g[x][i].first;
        if(y==fa) continue;
        dfs(y,x);
        siz[x]+=siz[y];
        int w=g[x][i].second;
        for(int j=max(siz[x],m);j>=0;j--)
            for(int k=max(j-siz[x]+siz[y],0);k<=min(j,siz[y]);k++)
                f[x][j]=max(f[x][j],f[x][j-k]+f[y][k]+1ll*w*k*(m-k)+1ll*w*(siz[y]-k)*(n-m-siz[y]+k));
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    m=min(m,n-m);
    for(int i=1;i<n;i++)
    {
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        g[u].pb(mkp(v,w));
        g[v].pb(mkp(u,w));
    }
    dfs(1,0);
    printf("%lld\n",f[1][m]);
    return 0;
}
```

---

## 作者：maka_baka (赞：3)

（总结一下其它题解出现的几种写法，指出题解的思维漏洞。）
## 题目
给出 $n$ 个点的树和 $m$，把树的点黑白染色，白的 $m$ 个，黑的 $(n-m)$ 个。最大化所有黑点点对和白点点对最大距离和（称为价值）。$1\le m\le n\le 2000$。

比如这个树（$n=5$，$m=2$）：
```txt
4
|2>
2 --<3>-- 1 --<1>-- 5
|1>
3
```
把 ${1, 2}$ 染成白色，那么黑点点对距离和为 $(1+3+2)+(1+3+1)+(2+1)=14$，白点 $3$，总价值 $14+3=17$ 最大。所以对于这个样例输出 $17$。

这道题给的经验有两个，一个是点对计数转换成边权带权和，另一个是转移顺序。

## 点对计数
对于转移时枚举到的某个方案，直接 $O(n^2)$ 枚举点对肯定不行。可以枚举边，我们只要数出这条边两端分别有多少个白（黑）点，就可以知道它在计算贡献时重复数了多少次。

对于节点 $u$，它的某个孩子 $v$，$v$ 子树大小 $s(v)$。$v$ 子树里有 $j$ 个白点，外面就有 $(m-j)$ 个白点；里面有 $[s(v)-j]$ 个黑点，外面就有 $[(n-m)-(s(v)-j)]$ 个黑点。$(u, v)$ 这条边分别对 / 白黑点对 / 的重复次数是：
$$\mathrm{tot}_j(u,v)=j(m-j)+(s_v-j)[(n-m)-(s_v-j)]$$

和普通树形 dp 一样，设 $f(u, t, k)$ 表示 $u$ 为根的子树里只考虑 $u$ 和前 $k$ 个子树，$t$ 个点染成白色的最大贡献。这个状态有没有后效性呢？按上面分析，我们已经把贡献转换成了边的带权和，这个权重可以说由子树外的点决定，也可以说由子树内的点决定。这样，就没有后效性了。

转移方程（因为要讲 3 种 dp 顺序，所以变量多了些，$|\mathrm{ch}\ v|$ 表示 $v$ 的孩子数，$i+j=t$）：
$$
f(u,t,k)=\max_{0\le i\le s(u)\atop0\le j\le s(v)}
f(u,i,k-1)+f(v,j, |\mathrm{ch}\ v|)+w\cdot\mathrm{tot}_j(u,v)
$$
如果 $j>m$ 那么这条边的贡献是负数不影响答案。

## 转移顺序
如果直接开三维数组然后模拟转移，$n$ 有 $2000$，$n^3 = 8\times10^9$ 个 `int` 大概是 29 GB，所以一定要滚动数组。比如把第三维 $k$ 压掉。按 dfs 序枚举 $u$，从大到小枚举 $t$ 是很自然的想法。我来说说所谓 “$j$ 从小到大枚举” 是怎么回事。按理说，最大值肯定有交换律，可是改变 $j$ 的枚举顺序竟然会 WA？

这种最值转移[最保险的方法](https://www.luogu.com.cn/discuss/702385)是，把局部最值保存在一个临时变量里，这样你怎么枚举 $j$ 都是正解：
```cpp
void dp(int u) {
  s[u] = 1;
  for (int p=hd[u], v; p; p=nx[p]) {
    if (s[v = to[p]]) continue;
    dp(v); ll w = wg[p];
    for (int t = std::max(s[u]+s[v], m); t>=0; --t) {
      ll tmp = 0;
      for (int j = std::min(t, s[v]); j >= std::max(t-s[u], 0); j--) {
        // 这样写怎样枚举 j 都能过
        // 0 <= t-j <= s[u] <=> t-s[u] <= j <= t
        ll g = f[u][t-j] + f[v][j] + w*j*(m-j)
          + w*(s[v]-j)*(n-m-(s[v]-j));
        if (tmp < g) max = g;
      }
      f[u][t] = tmp;
    }
    s[u] += s[v];
  }
}
```
如果不用临时变量的话，这样写⁽¹⁾是错的
```
for t: max(s[u]+s[v], m) -> 0
  for j: min(t, s[v]) -> max(t-s[u], 0)
    用 f[u][t-j] 更新 f[u][t]
```
然后问题来了：只要换一下第二行 $j$ 的枚举顺序立刻 AC⁽²⁾：
```
for t: max(s[u]+s[v], m) -> 0
  for j: max(t-s[u], 0) -> min(t, s[v])
    用 f[u][t-j] 更新 f[u][t]
```
题解说因为要先转移 $j=0$ 的情况（如果取得到），但并没有说为什么 $j=0$ 这么特殊。我们知道要求 $r$ 个数 $a_1,a_2,\cdots,a_r$ 的最值，可以维护一个**局部最值**，表示 $a_{1,2,\cdots,i}$ 的最值，然后把 $a_{i+1}$ 添加进去，如此往复。

假如说要求这些数经过一些运算（称为 $g$）后的最值
```txt
f[t], f[t-1], f[t-2], ..., f[t-t]
```
对于上面的方法，我们把这个 “局部最值” 存在 `f[t]` 里。(1) 的漏洞在于，`f[t]` 保存的是不含 `g(f[t])` 的最值。结果就是，`f[t]` 被覆盖掉了。(2) 能避免这个漏洞，因为 `f[t]` 保存的最值包含了 `g(f[t])`。这就是 “先更新 $k=0$”的意思。

我还看到了[第三种写法](https://www.luogu.com.cn/article/ru1g7107)：
```txt
for i: s[u] -> 0
  for j: s[v] -> 0
    用 f[u][i] 更新 f[u][i+j]
```
提一下 dp 实现里，填表法和刷表法的区别。下面两个求斐波那契数列第 $n$ 项，第一个是填表，第二个是刷表。
```cpp
f[1] = f[2] = 1; for (int i=3; i<=n; i++) f[i] = f[i-1] + f[i-2];

f[1] = 1; for (int i=1; i<n; i++) f[i+1] += f[i], f[i+2] += f[i];
```
第三种写法就是刷表法。我们对于每个 $i$，第一次更新 `f[u][i+j]` 时，一定是用 “$i+j$ 为定值，$j$ 取最小” 的状态去更新 `f[u][i+j]`，跟上面 “先更新 $k=0$” 是一个意思。这个写法很简洁，所以 AC Code 也用这个写法。

## 时间复杂度
子树大小从 $O(n) \rightarrow O(1)$ 都会有，树形 DP 子问题规模不尽相同，不能暴力用 “状态数 × 转移数” 算。不然你会算出高达 $O(n^3)$ 的时间。

dfs 枚举 $n$ 个点，对于每个 $u$，沿用第三种写法的变量名，$j$ 枚举一个 $v$ 子树黑点数量的枚举量和 `s[v]` 相同，$i$ 枚举量同 `s[u]`，加上每个 $v$ 子问题求解，总枚举量和 $u$ 子树里有序点对数量相同，时间为 $O(n^2)$。

> [菲斯斯夫斯基](https://www.luogu.com.cn/article/0bm5ce54)：  
> 任意两个点只会在 lca 处合并一次，所以时间复杂度是 $O(n^2)$ 的。

- [上下界优化保证平方复杂度](https://www.luogu.com.cn/discuss/708044)
- [本题大量题解代码有误](https://www.luogu.com.cn/discuss/808933)

这个看题解好像也吵了一阵子，但其实不只是时间复杂度不对。我觉得即使数组不越界，即使这样能 AC，但是使用了非法的状态来转移，给非法状态设特殊值都是很流氓的做法。“非法状态” 在这里的意思是正向越界，比如对于 `f(v, j, ...)`，且 $j$ 大于 $v$ 子树大小这种状态。

~~好吧我的代码里也有黑点数大于 $m$（总黑点数）的状态可是那也只是常数大了而已~~

他们没加所谓的 “上下界优化”，实际上就是用了这种非法转移。你用能从非法状态转移出正确答案，只是因为你设的非法状态初始化值能让你的普通状态过，而不是把问题转移到这个非法的子问题上。

在我看来这和 `#define int long long` 一样都是投机取巧。但凡写的时候想想怎样避开非法状态，代码也不会退化到 $O(n^3)$。

## AC Code
```cpp
#include <iostream>
using ll=long long;
const int N=2e3+4;

int n, m, s[N], hd[N], to[N*2], nx[N*2];
ll f[N][N], wg[N*2];

void dp(int u) {
  s[u] = 1;
  for (int p=hd[u], v; p; p=nx[p]) {
    if (s[v = to[p]]) continue;
    dp(v); ll w = wg[p];
    for (int i=s[u]; i>=0; i--)
      for (int j=s[v]; j>=0; j--) {
        ll g = f[u][i] + f[v][j] + w*j*(m-j)
          + w*(s[v]-j)*(n-m-(s[v]-j));
        if (f[u][i+j] < g) f[u][i+j] = g;
      }
    s[u] += s[v];
  }
}

int main() {
  std::cin >> n >> m;
  for (int i=1; i<n; i++) {
    int u, v, w;
    std::cin >> u >> v >> w;
    to[i]  =v, wg[i]  =w, nx[i]  =hd[u], hd[u]=  i;
    to[i+n]=u, wg[i+n]=w, nx[i+n]=hd[v], hd[v]=i+n;
  }
  dp(1); std::cout << f[1][m] << '\n';
}
```

---

## 作者：Helloworldwuyuze (赞：3)

# F - 树上染色

## Des

给定一棵树，要求在树上把 $m$ 个点染成黑色，并有价值函数

$$v(E') = \sum_{v_1,v_2\in E'} dis(v_1,v_2) + \sum_{v_1,v_2\in E-E'} dis(v_1,v_2)$$

求一种染色方式使得最大化 $v(E')$。

## Sol

仍然考虑动态规划。

$f_{u,k}$ 表示 $u$ 子树内选择 $k$ 个 **对答案的贡献**。考虑这和 $f_{u,k}$ 表示 $u$ 子树内选择 $k$ 个 **的价值** 有什么不同。

对于答案的贡献，我们是默认在 $u$ 子树之外已经选择了 $m-k$ 个其他的黑色节点的，因此对于边 $u\to v$，若有 $v$ 子树内已经选择了 $k$ 个，那么边 $u\to v$ 经过的次数就是 $k\times(m-k)$ 次，因此对答案的贡献就是 $w\times k\times (m-k)$。同理可以计算得到白点的贡献。

而价值指的是 $u$ 子树内选择 $k$ 个，而 $v$ 子树内选择 $k'$ 个的贡献，这是不好被统计的。

由第一个设的状态，我们有转移方程：

$$f_{u,j} = \max\{f_{v,k} + f_{u,j-k} + w\times k\times (m-k) + w\times (sz_v-k)\times (n-m-sz_v+k)\}$$

但是这样显然会 $\text{TLE}$。这是因为我们需要 $DFS$，并且每个点枚举一个 $j$ 和一个 $k$，复杂度 $O(nk^2)$。无法接受。

我们做一个上下界优化。显然，$j$ 的上下界是 $[0,\min(m,sz_u)]$，其中 $u$ 是已经遍历到的 $u$ 子树的大小。而 $k$ 的范围是 $[\max(j-sz_u+sz_v,0),\min(sz_v,m)]$。因此，式子就变成了：

$$f_{u,j} = \max_{j=0}^{\min(m,sz_u)}\max_{k=\max(j-sz_u+sz_v,0)}^{\min(sz_v,m)}\{f_{v,k} + f_{u,j-k} + w\times k\times (m-k) + w\times (sz_v-k)\times (n-m-sz_v+k)\}$$

为啥复杂度是对的前几篇题解写得也已经很明确了。这里需要注意的是 $j$ 需要倒序枚举，否则答案会不正确。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
#include<stack>
#include<algorithm>
#include<map>

#include<bitset>
#include<set>

#include<deque>
#include<cassert>
#include<cstdlib>
#include<cmath>
#include<ctime>
#include<vector>
#include<random>

#define fi first
#define se second
#define pb push_back
#define mk make_pair
#define DBG cerr << __LINE__ << ' ' << __FUNCTION__ << endl

#define DRE default_random_engine
#define UID uniform_int_distribution
#define y0 Y0
#define y1 Y1
#define endl '\n'

#define pi acos(-1)
#define eps (1e-8)
#define null nullptr

using namespace std;

#define int long long
const int INF = 0x3f3f3f3f;
typedef pair<int,int> PII;
typedef pair<int,PII> PIII;
const int N = 2e3 + 10;
const int M = 5e2 + 10;

int f[N][N], n, m, siz[N];
vector<PII> g[N];

void solve(int x,int fa){
	siz[x] = 1;
	for(PII y:g[x]){
		if(y.fi == fa)  continue;
		solve(y.fi, x);
		siz[x] += siz[y.fi];
		for(int j = max(siz[x], m); j>=0; --j)
			for(int k = max(j - siz[x] + siz[y.fi], 0ll); k <= min(j, siz[y.fi]); ++k)
				f[x][j] = max(f[x][j], f[y.fi][k] + f[x][j-k] + y.se * k * (m-k) + y.se * (siz[y.fi]-k) * (n-m-siz[y.fi]+k));	
	}
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin>>n>>m;
	for(int i=1,x,y,z;i<n;++i)  cin>>x>>y>>z, g[x].pb(mk(y,z)), g[y].pb(mk(x,z));
	solve(1, 0);
	cout<<f[1][m]<<endl;
	return 0;
}
```

---

## 作者：cyx12 (赞：2)

# 题解：P3177 [HAOI2015] 树上染色

[题目传送门](https://www.luogu.com.cn/problem/P3177)

## Part 1 思路分析

典型的树上 dp。

定义状态：$d(i,j)$ 表示在 $i$ 为根的树中选择 $j$ 个点染黑，可以获得的最大距离之和 $ans \gets d(1,m)$。

状态转移方程：决策每棵子树中选多少个点染黑，范围 $0 \to j$。

![](https://cdn.luogu.com.cn/upload/image_hosting/3xagodwm.png)

边 $b \to d$ 产生 $2$ 次贡献（路径 $d \to e$ 和 $d \to h$）。从边的角度考虑三个黑点 $d,e,h$ 对答案的贡献。

问题：计算距离需要明确的知道哪些点被染黑，状态中不包含该信息，无法推导出状态转移方程。

边 $b \to e$ 产生 $2$ 次贡献（路径 $e \to d$ 和 $e \to h$）。

边 $a \to b$ 产生 $2$ 次贡献（路径 $d \to h$ 和 $e \to h$）。定义状态：$d(i,j)$ 表示在 $i$ 为根的子树中选择 $j$ 个点染黑，子树 $i$ 对答案的最大贡献：$ans \gets d(1,m)$。

定义状态：$d(i,j)$ 表示在 $i$ 为根的子树中选择 $j$ 个点染黑，子树 $i$ 对答案的最大贡献：$ans \gets d(1,m)$。

状态转移方程：决策 $i$ 的每棵子树中选多少个点染黑。设 $x$ 是 $i$ 的孩子节点，$cnt_x$ 表示以 $x$ 为根的子树中的节点数，$w(i, x)$ 为 $i \to x$ 的边的权值。

对以 $x$ 为根的子树做决策，当选择 $k$ 个点染成黑色时，$x$ 的子树中有 $k$ 个黑点，$cnt_x - k$ 个白点。

$k$ 个黑点通过边 $i \to x$ 为答案做出了 $k \cdot (m-k) \cdot w(i, x)$的贡献。

$cnt_x - k$ 个白点通过边 $i \to x$ 为答案做出了 $(cnt_x-k) \cdot (n-m-(cnt_x-k)) \cdot w(i, x)$ 的贡献。

可得：

$d(i,j) = d(i,j-k)+d(x,k)+k \cdot (m-k) \cdot w(i, x)+(cnt_x-k) \cdot (n-m-(cnt_x-k)) \cdot  w(i,x)$。

## Part 2 代码

```cpp
#include <iostream>
#include <cstring>
#include <vector> 
using namespace std;

typedef long long LL;
/*
	①定义状态d[i][j]表示从以i为根的树中选择j个点染黑，可以获得的距离之和最大值，ans = d[1][m]。
	②状态转移方程：决策每棵子树中选多少个点染黑，问题：计算距离需要明确的知道哪些点被染黑。
	  状态中不包含该信息，无法推导出状态转移方程。
	  
	③从边的角度考虑问题，定义状态d[i][j]表示以i为根的子树中选择j个点染黑，对最终答案的最大
	  贡献，答案ans = d[1][m];
	④状态转移方程：决策i的每课子树中选多少个点染黑。设x是i的孩子节点，cnt[x]表示以x为根的子
	  树中的节点数，w(i, x)为i->x的边的权值。m表示整棵树最多可以染m个节点为黑色。
	  ①对以x为根的子树做决策，设：选择k个节点染色（0 <= k <= j);
	  ②d[x][k]表示以x为根的子树的内部节点对整个答案的贡献，除此以外x内部的节点和x外部的节点
	    也会对整个答案做出贡献。x内部节点必然通过边(i, x)和外部产生关系。
	  ③以x为根的子树中有k个黑色节点，那么外部必然有m-k个黑色节点，内部有cnt[x]-k个白色节点，
	    外部有n - m - (cnt[x] -k)个白色节点。
	  ④d[i][j] = d[i][j-k] + d[x][k] + k * (m-k) * w(i, x) + (cnt[x]-k) * (n-m-(cnt[x]-k)) * w*(i, x); 
	
	 
*/


const int N = 2005; 
struct Node { LL to, dis; };
vector<Node> G[N];
LL n, m, cnt[N], d[N][N];

//初始化cnt 
void count(int u, int fa) {
	cnt[u] = 1;
	for(int i = 0; i < G[u].size(); i++) {
		int v = G[u][i].to, w = G[u][i].dis;
		if(v == fa) continue;						//双亲直接continue; 
		count(v, u);
		cnt[u] += cnt[v]; 
	}
}

void dp(int u, int fa) {
	d[u][0] = d[u][1] = 0;				//0和1都一定是有效状态，且最小是0。 
	for(int i = 0; i < G[u].size(); i++) {
		int v = G[u][i].to, w = G[u][i].dis;
		if(v == fa) continue;			//双亲直接continue; 
		dp(v, u);						//递归处理v;
		
		//注意背包为0时也有贡献（白色节点的贡献） 
		for(LL j = min(m, cnt[u]); j >= 0; j--)		//枚举背包大小 
		for(LL k = 0; k <= min(j, cnt[v]); k++) {		//k的范围为[0, j]
			d[u][j] = max(d[u][j], d[u][j-k] + d[v][k] + k*(m-k)*w + (cnt[v]-k)*(n-m-(cnt[v]-k))*w);
		}
	}
}

int main() {
	cin >> n >> m;
	int u, v, w; 
	for(int i=1; i<n; i++) {
		cin >> u >> v >> w;
		G[u].push_back((Node) {v, w});
		G[v].push_back((Node) {u, w});
	}
	memset(d, -0x7F, sizeof(d));	//初始化为无效值。 
	count(1, 0);
	dp(1, 0); 
	cout << d[1][m]; 
	return 0; 
}	

```

---

## 作者：Rem_CandleFire (赞：2)

在本题中，改变 $dp$ 数组用于记录状态的固有观念，记 $f_{u,i}$ 为以 $u$ 为根的子树中，选了 $i$ 个点染色，**对答案造成的最大贡献**。

那么有：
$$f_{u,i}=\max\{ f_{u,i-k}+f_{v,k}+wk(m-k)+w(Siz_v-k)(n-Siz_v-(m-k))\}$$

其中，$wk(m-k)$ 为黑点造成的贡献，即当前边权为 $w$ 的边在 $k\times(m-k)$ 条路径上（子树 $v$ 内有 $k$ 个黑点，子树 $v$ 外有 $m-k$ 个黑点，根据乘法原理）。白点对答案的贡献同理。

$Siz_i$ 表示以 $i$ 为根的树内，当前枚举到的子树大小（但因为是递归，所以 $Siz_v$ 就是子树 $v$ 的大小）。

考虑边界状态，上式成立的条件为：$0\le i\le S_u$，$0\le i-k\le Siz_u $，$0\le k\le Siz_v$，其中 $S_u$ 表示子树 $u$ 的实际大小。

如果先更新 $Siz$ 数组再进行 dp，则上式中的 $Siz_u$ 应改为 $Siz_u-Siz_v$。

对以上不等式移项分析即得边界条件。时间复杂度根据讨论区的分析为平方级别。

---

## 作者：Melo_DDD (赞：2)

远古题目没人交题解？

# 题目大意

树上白色点和黑色点两两之间的距离和。

注意双向边。

# 题目实现

不难想到 dp，但是设计挺难的。

我们设 $dp_{cur ,i}$ 表示 $cur$ 的子树中染了 $i$ 个黑点的最大收益。

接下来我们考虑每一条边对答案的贡献，显然两点之间路径不经过它那么它就没有贡献，所以我们只用考虑经过它的路径。

设当前节点是 $cur$，那么对于它的子节点 $nex$，原来我们没有管它们两个之间这条边，现在我们把这条边加上，那么 **$nex$ 的子树中的点和除以 $cur$ 为根的树外的点之间的路径一定经过边 $e_{nex->cur}$。**

我们统计上述的方案数，遍历 $nex$ 的子树大小，我们设当前以 $nex$ 为根的子树中选 $num$ 个黑点，那么：

- 这个子树和子树外黑点的连线一共有 $num\times (k - num)$ 条。

- 由题有这个子树里剩下 $siz_{nex}-num$ 个白点（因为整个树中除了黑的就是白的），整个树其他部分剩下 $n-k-(siz_{nex}-num)$ 个白点，拆了括号共 $(siz_{nex}-num)\times (n-k+num-siz_{nex})$ 条连线。

上述两个加起来就是经过边 $e_{nex->cur}$ 的方案数。

再乘边权就是距离的贡献。

转移的时候还有点其他步骤，不是难点，直接放代码：

```cpp
#include <bits/stdc++.h>
#define rep(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
#define per(i ,m ,n ,x) for (int i = (m) ;i >= (n) ;i -= (x))
using namespace std ;
const int N = 2e3 + 7 ;
int n ,k ,head[N << 1] ,tot ;
typedef long long ll ;
struct edge {
	int to ,nxt ;
	ll val ;
}e[N << 1] ;
ll siz[N] ,dp[N][N] ;
namespace shin {
	template <typename T> inline void read (T &x) {
		x = 0 ;
		char ch = getchar () ;
		while (! isdigit (ch)) {
			ch = getchar () ;
		}
		while (isdigit (ch)) {
			x = (x << 1) + (x << 3) + (ch xor 48) ;
			ch = getchar () ;
		}
	}
	inline void add (int u ,int v ,ll w) {
		e[++ tot].nxt = head[u] ;
		head[u] = tot ;
		e[tot].to = v ;
		e[tot].val = w ;
	}
	inline void dfs (int cur ,int fa) {
		siz[cur] = 1 ;
		for (int i = head[cur] ;i ;i = e[i].nxt) {
			int nex = e[i].to ;
			if (nex == fa) goto her ;
			shin :: dfs (nex ,cur) ;
			per (j ,min ((ll) k ,siz[cur]) ,0 ,1) { // 貌似不取最小值也行？
				per (_ ,min ((ll) k ,siz[nex]) ,0 ,1) {
					ll res = (ll) (dp[cur][j] + dp[nex][_] + e[i].val * (_ * (k - _) + (siz[nex] - _) * (n - k + _ - siz[nex]))) ; // 遍历 j 是为了避免后效性，防止你 cur 的子树没更完就去更其他的
					dp[cur][j + _] = max (dp[cur][j + _] ,res) ; // 记得取最大值
				}
			}
			siz[cur] += siz[nex] ; // 子树大小也要改
			her : ;
		}
	}
}
int main () {
	shin :: read (n) ,shin :: read (k) ;
	rep (i ,1 ,n - 1 ,1) {
		int u ,v ;
		ll w ;
		shin :: read (u) ,shin :: read (v) ,shin :: read (w) ;
		shin :: add (u ,v ,w) ;
		shin :: add (v ,u ,w) ;
	}
	shin :: dfs (1 ,0) ;
	cout << dp[1][k] << '\n' ;
	return 0 ;
}
//kafka & かみや & やえみこ
```

---

## 作者：zhm080507 (赞：1)

#  [P3177  树上染色](https://www.luogu.com.cn/problem/P3177)

#### 题目大意

在一棵树上选定 $k$ 个点染黑，其余点为白，记录收益为黑点两两之间的距离加上白点两两之间的距离的和，求收益最大。

#### 算法分析

这道题乍一看会觉得不好分析，因为点不固定的话没法算两点连线的距离之和。

但我们实际上可以把选点转化为记录一条边会被记录多少次。

我们设 $j$ 为以 $u$ 为子树内黑色点个数，那么白色点个数即为 $size_u-j$，那么设 $g_{u,j}$ 记录点 $u$ 上方这一条边的贡献：
$$
g_{u,j}=w_u\times[(k-j)\times j+(size_u-j)\times(n-k-siz_u+j)]
$$
同时我们还需要对 $u$ 子树内的贡献进行一个卷积：
$$
f_{u,i+j}=\max(f_{u,i}+f_{v,j})
$$
再将两者求和，就做完啦。

#### code

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int N=2100;
int n,k,a,b,c;
int siz[N],w[N],t[N],f[N][N];
vector<pair<int,int>>e[N];

void dfs(int u,int fa){
	siz[u]=1;
	for(auto x:e[u]){
		int v=x.first;
		if(v==fa) continue;
		w[v]=x.second;
		dfs(v,u);
		memset(t,0,sizeof(t));
		for(int i=0;i<=siz[u];i++){
			for(int j=0;j<=siz[v];j++){
				t[i+j]=max(t[i+j],f[u][i]+f[v][j]);
			}
		}
		siz[u]+=siz[v];
		for(int i=0;i<=n;i++)
			f[u][i]=t[i];
	}
	for(int j=0;j<=siz[u];j++)
		f[u][j]+=w[u]*((k-j)*j+(siz[u]-j)*(n-k-siz[u]+j));
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>k;
	for(int i=1;i<n;i++){
		cin>>a>>b>>c;
		e[a].push_back({b,c});
		e[b].push_back({a,c});
	}
	dfs(1,0);
	cout<<f[1][k]<<"\n";
	return 0;
}
```

---

## 作者：Qing_Nian (赞：1)

树形DP
### 简要题意
$n$ 个点的树，其中 $k$ 个点染黑色，$n-k$ 个点染白色，求黑点两两距离之和加白点两两之和的最大值。

### 思路
我们首先考虑如果 $k=0$ 时，答案应该怎么算，此时显然是 $\sum_{i=1}^n\sum_{j=i+1}^n dis(i,j)$。

然后我们考虑如何在 $O(n)$ 的时间复杂度内求出答案，明显我们可以将每条边的贡献拆开来算。

而经过边 $u\to v$ 的次数明显为$size_v\times (n-size_v)$，很好理解，就是因为子树内每个点要到底子树外的点需要经过这条边。

这启发我们如何算黑白点的贡献，设 $size1_x$ 表示以 $x$ 为根的子树内黑点的数量，$size2_x$ 表示以 $x$ 为根的子树内白点的数量。

那么经过边 $u\to v$ 的次数就是 $size1_v\times (k-size1_v)+size2_v\times (n-k-size2_v)$。此时就很好做了，设 $dp_{i,j}$ 表示以 $i$ 为根的子树内选 $j$ 个黑点的边的最大贡献和。

那么对于边 $u\to v$ 有：
$$dp_{u,i+j}=\max_{i=1,j=1}^{k,i+j\le k} \{dp_{u,i}+dp_{v,j}+j\times (k-j)\times w_{u\to v}+(size_v-j)\times (n-k-size_v+j)\times w_{u\to v}\}$$

### Code
```cpp
/*

*/
#include <bits/stdc++.h>
using namespace std;
inline long long read(){
    long long x=0,w=0;char c=0;
    while(!isdigit(c)) {w|=c=='-';c=getchar();}
    while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return w?-x:x;
}
long long n,k;
struct edge{
	int to,nex;
	long long w;
}e[4050];
int h[2050],cnt;
inline void add(int x,int y,int w){
	e[++cnt]={y,h[x],w};
	h[x]=cnt;
}
long long dis[2050];
long long dp[2050][2050],siz[2050],f[2050];
void dfs(int x,int fa){
	siz[x]=1;
	for(int i=h[x];i;i=e[i].nex){
		int v=e[i].to;
		if(v==fa){
			continue;
		}
		dis[v]=dis[x]+e[i].w;
		dfs(v,x);
		for(int i=0;i<=k;i++){
			f[i]=0;
		}
		for(int l=0;l<=min(siz[x],k);l++){
			for(int j=0;j<=min(siz[v],k);j++){
				if(l+j>k){
					break;
				}
				f[l+j]=max(f[l+j],dp[x][l]+dp[v][j]+e[i].w*j*(k-j)+e[i].w*(siz[v]-j)*(n-k-siz[v]+j));
			}
		}
		siz[x]+=siz[v];
		for(int j=0;j<=min(siz[x],k);j++){
			dp[x][j]=f[j];
		}
	}
}
int main(){ 
	n=read();
	k=read();
	for(int i=1,x,y,z;i<n;i++){
		x=read();
		y=read();
		z=read();
		add(x,y,z);
		add(y,x,z);
	}
	dfs(1,0);
	printf("%lld",dp[1][k]);
	return 0; 
}
/*

*/
```

---

## 作者：_H17_ (赞：1)

## 题目分析

树上染色的问题通常可以用 DP 的方式解决，具体状态还要看题目。

首先要有 $u$ 来表示当前根节点，同时题目说了需要 $k$ 个黑点，所以还要有一维状态限制 $i$ 表示其子树内有 $i$ 个黑点。综上 $f_{u,i}$ 表示以 $u$ 为根的子树中选择 $i$ 个黑点的最大收益。

出使状态：$f_{u,0}=f_{u,1}=0$。

**注意：其他状态可以标位不可行（用 $-1$ 或类似方法），同时不要从不可行的方案转移，也可以通过限制循环范围。**

状态转移方程：$f_{u,i}=\max f_{v,j}+f_{u,i-j}+(j\times(k-j)+(siz_v-j)\times (n-siz_v-(k-j)))\times w$。

很懵？我猜的没错吧？这是啥意思呢？首先 $f_{u,i-j}$ 表示的是考虑到 $v$ 之前的所有子树的答案（你可以理解为孩子是一个序列，考虑点对的关系可以对于 $i$ 考虑之前的 $1\sim i-1$ 的总体对 $i$ 的贡献）。同时你还要加上 $f_{v,j}$ 表示子节点的答案，还需要加上两部分分别的黑点、白点乘积（显然这就是 $(u,v)$ 这条边的贡献），不要忘记乘边权。

最终答案就是 $f_{1,k}$。

**注意：枚举时确保黑点数量不超过树的大小。**

时间复杂度 $O(n^2)$。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
constexpr int N=2001;
int n,k,siz[N],f[N][N];
vector<pair<int,int> >e[N];
void add(int u,int v,int w){
    e[u].push_back(make_pair(v,w));
    return;
}
int dfs(int u,int fa){
    f[u][0]=f[u][1]=0;
    siz[u]=1;
    for(auto[v,w]:e[u]){
        if(v==fa)
            continue;
        siz[u]+=dfs(v,u);//只需要处理过的部分
        for(int i=min(k,siz[u]);i>=0;i--){//注意顺序
            for(int j=0;j<=min(i,siz[v]);j++)
                if(f[u][i-j]!=-1)
                    f[u][i]=max(f[u][i],f[u][i-j]+f[v][j]+w*(j*(k-j)+(siz[v]-j)*(n-siz[v]-(k-j))));//转移
        }
    }
    return siz[u];
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(nullptr);
    memset(f,-1,sizeof(f));
    cin>>n>>k;
    for(int i=1,u,v,w;i<n;i++){
        cin>>u>>v>>w;
        add(u,v,w),add(v,u,w);
    }
    dfs(1,0);
    cout<<f[1][k];
    return 0;
}
```

---

## 作者：Tachibana27 (赞：1)

第二类树形 DP 好题！


---

树形 DP 很套路的思想：设 $dp_{i,j}$ 表示以 $i$ 为根节点的子树有 $j$ 个怎样的节点的最大、最小或答案。

在这题中，同样可以用这样的思想设计状态：$dp_{i,j}$ 表示以 $i$ 为根节点，有 $j$ 个黑点的最大收益。

答案显然是 $dp_{1,m}$。

考虑转移。第二类树形 DP 和背包有类似之处。不妨记 $b$ 为该子树内黑点贡献，$w$ 为白点，则有

$$
dp_{x,j}=\max dp_{x,j-k}+dp_{nxt,k}+b+w;
$$

其中 $x$ 为当前子树的根，$j$ 为当前子树染黑点的个数，$k$ 为子树的子树中枚举的黑点数量（不包括根节点），$j-k$ 是其中子树的另一棵子树的黑点数量（包括根节点），$nxt$ 为另一棵子树的子树的根。

![](https://cdn.luogu.com.cn/upload/image_hosting/mwsna7be.png)

如上图。

那么如何计算黑点的贡献呢？

若在某一子树内存在 $k$ 个黑点，则在子树外必然有 $m-k$ 个黑点，它们若要计算贡献必然会经过该边，根据乘法原理，该边的贡献为

$$
kw\times(m-k)
$$

其中 $w$ 为该边的权值。

code:

```cpp

int n,m;
class node{
	public:
		int v;
		int w;
};
int dp[2086][2086];
std::vector<node>e[1500086];
int sz[1500086];
void dfs(int x,int fa){
    sz[x]=1;
    dp[x][1]=dp[x][0]=0;
//    std::cout<<dp[x][1]<<"\n";
	for(node i:e[x]){
		if(i.v==fa)
			continue;
		dfs(i.v,x);
		sz[x]+=sz[i.v];
		for(int j=std::min(m,sz[x]);j>=0;j--)
			for(int k=0;k<=std::min(j,sz[x]);k++){
				int b=k*(m-k)*i.w;
				int w=(sz[i.v]-k)*(n-m-sz[i.v]+k)*i.w;
				dp[x][j]=std::max(dp[x][j],dp[x][j-k]+dp[i.v][k]+b+w);
			}
	}
	return;
}
int ans=INT_MAX;
signed main(){
	std::cin>>n>>m;
	if(m>(n>>1))
	    m=n-m;
	memset(dp,-0x3f,sizeof dp);
	for(int i=1;i<n;i++){
		int x,y,w;
		std::cin>>x>>y>>w;
		e[x].push_back({y,w});	
		e[y].push_back({x,w});	
			
	}
	dfs(1,-1);
	std::cout<<dp[1][m];
	return 0;
}
```

---

## 作者：highkj (赞：1)

# 思路
首先看到这种题目可以试着往 Dp 上想一下，首先我们可以定义出一个状态 $f_{i,j}$ 表示根节点为 $i$ 的子树中染了 $j$ 个其子树中的最大贡献。

然后我们就可以来思考如何转移了，因为 $i$ 肯定要从其儿子中来转移所以我们考虑 $i\to son_{i,j}$ 的这一条边的贡献，首先对于黑点，数量为 $bl\times (m-bl)$ 这里用 $bl$ 来表示 $son_{i,j}$ 中黑点的数量，然后对于白点一样考虑即可。因为在子树中的点和在这棵子树外的点匹配一定会经过此边所以状态转移方程为 $f_{i,j}=\max(f_{i,j},f_{son_{i},bl}+val\times (bl\times (m-bl))+(size_{son_{i}}-bl)\times (n-m-size_{son_i}+bl))$。

至于这个的时间复杂度证明参考[这个帖子](https://www.luogu.com.cn/discuss/708044)。

注意这道题要处理子树中只有一种颜色的情况。
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define rep(i,x,y) for(register int i=x;i<=y;i++)
#define rep1(i,x,y) for(register int i=x;i>=y;--i)
#define in(x) scanf("%lld",&x)
#define fire signed
#define il inline
il void print(int x) {
	if(x<0) putchar('-'),x=-x;
	if(x>=10) print(x/10);
	putchar(x%10+'0');
}
int T=1;
int n,m;
const int N=2e3+10;
int f[N][N],siz[N];
vector<pair<int,int> >v[N];
void dfs(int x,int fa) {
	siz[x]=1;
	f[x][0]=f[x][1]=0;
	for(auto to:v[x]) {
		if(to.first==fa) continue;
		dfs(to.first,x);
		siz[x]+=siz[to.first];
		rep1(i,min(siz[x],m),0) {
			if(f[x][i]>=0) f[x][i]+=f[to.first][0]+to.second*(siz[to.first])*(n-m-siz[to.first]);
			rep1(k,min({i,siz[to.first],m}),1) {
				if(f[x][i-k]<0) continue;
				f[x][i]=max(f[x][i],f[x][i-k]+f[to.first][k]+to.second*(m-k)*k+to.second*(siz[to.first]-k)*(n-m-siz[to.first]+k));
			}
		}
	}
	
}
void solve() {
	in(n),in(m);
	rep(i,1,n-1) {
		int x,y,z;
		in(x),in(y),in(z);
		v[x].push_back({y,z});
		v[y].push_back({x,z});
	} 
	memset(f,-1,sizeof f);
	dfs(1,0);
	cout<<f[1][m]<<endl;
	return;
}
fire main() {
	while(T--) {
		solve();
	}
	return false;
}
```

---

## 作者：_shining (赞：1)

# [题目传送门](https://www.luogu.com.cn/problem/P3177)

## 题意

这题就是让我们求收益的最大值。

## 思路

如果我们直接暴力枚举 $k$ 个节点，然后在暴力求解距离，时间复杂度大约是 $O(n^5)$，而 $n \le 2000$，肯定超时。

我们考虑计算每条边的贡献，定义 $dist_{u,v}$ 表示 $u\to v$ 的距离，边 $u\to v$ 将图分成了两部分，显然如果这条边左侧有 $b1$ 个黑点，$w1$ 个白点，右侧有 $b2$ 个黑点，$w2$ 个黑点的话，显然这条边的贡献为 $(b1\times b2+w1\times w2 )\times dist_{u,v}$。

定义 $f_{u,j}$ 表示以 $u$ 为根的子树有 $j$ 个黑点时这个子树里面的边的可得的总贡献最大。

然后可以考虑做一个树上背包，那么可以得到：

$$
f_{u,j}=\max(f_{u,j},f_{u,j-t}+f_{v,t}+dist_{u,v}\times (t\times (k-t)))+(size_v−t)\times(n−k−size_v+t)))
$$

其中 $size_u$ 为以 $u$ 为根的子树大小，$size_v−t$ 为子树内白点个数。

## 代码

```cpp
#include <iostream>
#include <cstring>
#include <vector>
#define int long long
using namespace std;
int n, k;
const int N = 2005;
int s[N], f[N][N];
vector<pair<int, int> > g[N];
inline void dfs(int u, int fa)
{
	s[u] = 1;
	f[u][0] = f[u][1] = 0;
	for(int i = 0; i < g[u].size(); i++){
		int v = g[u][i].first, w = g[u][i].second;
		if(v == fa) continue;
		dfs(v, u);
		s[u] += s[v];
		for(int j = min(k, s[u]); j >= 0; j--){
			for(int t = 0; t <= min(j, s[v]); t++){
				if(f[u][j - t] == -1) continue;
				int cost = w * t * (k - t) + w * (s[v] - t) * (n - k - s[v] + t);
				f[u][j] = max(f[u][j], f[u][j - t] + f[v][t] + cost);
			}
		}
	}
}
signed main()
{
	scanf("%lld%lld", &n, &k);
	for(int i = 1; i < n; i++){
		int u, v, w;
		scanf("%lld%lld%lld", &u, &v, &w);
		g[u].push_back({v, w});
		g[v].push_back({u, w});
	}
	memset(f, -1, sizeof(f));
	dfs(1, 0);
	printf("%lld", f[1][k]);
	return 0;
}
```

---

## 作者：许多 (赞：0)

这题的解法题解区已经很明白了，我来说一说这一题展现的树形 DP 需要注意的点。

一个就是，尤其对于初学者而言，对于树形 DP 他的初始化是比较抽象的，要特别考虑初始化状态。对本题而言就是将染色 $0$ 个点和只染色自己所在节点两个情况进行初始化处理。

还有一点就是在对于一个点 DP 处理的过程中，他 $dp$ 数组里存的东西可能从整体来看没有意义，只是类似于推向最终结果的一个过渡态。而这个过程有些类似于线段树合并（笔者自己认为）。

## 核心代码


```cpp
void dfs(int now,int f){
    siz[now]=1;
    dp[now][0]=dp[now][1]=0;
    for(int i=head[now];~i;i=edge[i].next)
        if(edge[i].to!=f){
            dfs(edge[i].to,now);
            siz[now]+=siz[edge[i].to];
            for(int j=min(m,siz[now]);j>=0;j--){
                if(dp[now][j]!=-1)
                    dp[now][j]+=dp[edge[i].to][0]+siz[edge[i].to]*(n-m-siz[edge[i].to])*edge[i].v;
                for(int k=min(j,siz[edge[i].to]);k>=1;k--){
                    if(dp[now][j-k]==-1)continue;
                    dp[now][j]=max(dp[now][j],dp[now][j-k]+dp[edge[i].to][k]+k*(m-k)*edge[i].v+(siz[edge[i].to]-k)*(n-m-siz[edge[i].to]+k)*edge[i].v);
                }
            }
        }
}
```

---

## 作者：Hope5365 (赞：0)

广告：在[博客](https://www.luogu.com.cn/article/f6dp5krc)内食用更佳！

我们定义 $f[i][j]$ 表示以点 $i$ 为根节点的子树，涂了 $j$ 个黑点的的最大收益。

如果我们直接枚举点的贡献的话，会TLE，所以我们考虑边的贡献。

对于任意两个同色点 $(u,v)$，他们会对 $(u,v)$ 路径中的所有边造成 $1$ 的贡献。

然后我们就会发现，边 $(u,v)$ 被经过的次数为 $u,v$ 两个点两侧同色的点个数的乘积。

于是我们就可以求出来每一条边被经过的次数：
$sum = (m - k) \times k + (size_v - k) \times (n - m - size_v + k)$

于是我们进一步推出转移方程：
$f[u][j] = \max(f[u][j],f[u][j - k] + f[v][k] +sum)$

AC代码：
```cpp
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;
#define int long long

const int N = 2e3 + 10;
int n,m,f[N][N],Size[N];
vector <pair <int,int> > v[N];

inline void dfs(int x,int fa)
{
	Size[x] = 1;
	f[x][0] = f[x][1] = 0;
	for(int i = 0;i < v[x].size();i ++)
	{
		int g = v[x][i].first,w = v[x][i].second;
		if (g == fa) continue;
		dfs(g,x);
		Size[x] += Size[g];
		for(int j = min(m,Size[x]);j >= 0;j --)
		{
			if (f[x][j] != -1)
				f[x][j] += f[g][0] + Size[g] * (n - m - Size[g]) * w;
			for(int k = min(j,Size[g]);k;k --)
			{
				if (f[x][j - k] == -1) continue;
				int sum = (k * (m - k) + (Size[g] - k) * (n - m - Size[g] + k)) * w;
				f[x][j] = max(f[x][j],f[x][j - k] + f[g][k] + sum);
			}
		}
	}
}

signed main()
{
	ios::sync_with_stdio(0);
	cin >> n >> m;
	for(int i = 1;i < n;i ++)
	{
		int x,y,z;
		cin >> x >> y >> z;
		v[x].push_back(make_pair(y,z));
		v[y].push_back(make_pair(x,z));
	}
	memset(f,-1,sizeof(f));
	dfs(1,-1);
	cout << f[1][m] << endl;
	return 0;
}
```

这一道题目的难点在于正确设计DP数组，考虑贡献的方式。

---

## 作者：Hog_Dawa_IOI (赞：0)

### 题意
有一棵点数为 $n$ 的树，树边有边权。给你一个在 $0 \sim n$ 之内的正整数 $k$ ，你要在这棵树中选择 $k$ 个点，将其染成黑色，并将其他的 $n-k$ 个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间的距离的和的收益。问收益最大值是多少。       
数据范围：$0 \leq n,k \leq 2000$。
### 分析
![](https://cdn.luogu.com.cn/upload/image_hosting/e8ctwc0w.png)    
显然暴力枚举哪些点染成白色哪些点染成黑色是不现实的，考虑树型 DP，对于每条边计算产生的贡献。     
对于每个点 $x$，我们枚举它的儿子 $son$，再枚举以那个儿子为根的子树中黑点的个数（记为 $cnt$）。    
由于黑点的总数已经确定是 $k$，所以当前边的儿子方向（不包括父亲，包括儿子，即以儿子为根的子树）有 $cnt$ 个黑点，$siz_{son}-cnt$ 个白点，父亲方向（包括父亲）有 $k-cnt$ 个黑点，$n-siz_{son}-k+cnt$ 个白点。   
两两相乘，再乘上当前边的权值，再相加便是当前方案的总收益之和。     
最后输出 $f_{1,k}$，也就是以 $1$（其实以哪个点都一样）为根，有 $k$ 个黑点的收益最大值。
### 代码
这里的 $k$ 是上文的 $cnt$，$m$ 是上文的 $k$。        
dfs 函数的工作内容是预处理，其实可以与 dfss 函数进行合并。      
对于 DP 数组的初始化：一开始只有自己单独一个结点时，自己可以是黑色或者白色，收益都是 $0$，其它情况无法转移，初始化为 $-1$。  
关于 $j,k$ 的枚举顺序：[子谦。的这篇题解](https://www.luogu.com.cn/article/2nmzn4ec)以及评论区有详细的讨论。另外注意边界的判定。
```cpp
#include<stdio.h>
#include<string.h>
long long max(long long a,long long b){return a>b?a:b;}
long long min(long long a,long long b){return a<b?a:b;}
struct ss{long long end,nxt,quan;}bian[4005];bool ff[2005];
long long n,m,fir[2005],num,a,b,c,f[2005][2005],siz[2005],fa[2005];
void dfs(int rt)
{
    ff[rt]=1,siz[rt]++,f[rt][0]=f[rt][1]=0;
    for(int i=fir[rt];i;i=bian[i].nxt) if(!ff[bian[i].end])
    fa[bian[i].end]=rt,dfs(bian[i].end),siz[rt]+=siz[bian[i].end];
}
void dfss(int rt)
{
    for(int i=fir[rt];i;i=bian[i].nxt) if(bian[i].end!=fa[rt])
    {
        dfss(bian[i].end);
        for(int j=min(m,siz[rt]);j>=0;j--) for(int k=0;k<=j&&k<=siz[bian[i].end];k++)
        if(f[rt][j-k]!=-1&&f[rt][j]<f[rt][j-k]+f[bian[i].end][k]+k*(m-k)*bian[i].quan
        +(siz[bian[i].end]-k)*(n-m-siz[bian[i].end]+k)*bian[i].quan)
        f[rt][j]=f[rt][j-k]+f[bian[i].end][k]+k*(m-k)*bian[i].quan
        +(siz[bian[i].end]-k)*(n-m-siz[bian[i].end]+k)*bian[i].quan;
    }
}
int main()
{
    scanf("%lld%lld",&n,&m),memset(f,-1,sizeof(f));
    for(int i=1;i<n;i++) scanf("%lld%lld%lld",&a,&b,&c),
    bian[++num].end=b,bian[num].nxt=fir[a],bian[num].quan=c,fir[a]=num,
    bian[++num].end=a,bian[num].nxt=fir[b],bian[num].quan=c,fir[b]=num;
    dfs(1),dfss(1),printf("%lld\n",f[1][m]);
}
```

---

## 作者：saikrilll (赞：0)

本题解做法与其它题解一致，主要证明一下枚举子树染色大小为何要先转移大小是 $0$ 的情况（即直接倒序枚举是错的）。


---

我们设

$cost=e.w\times(x\times(k-x)+(siz_{e.to}-x)\times(n-k-siz_{e.to}+x))$

其中 $e$ 为边，$x$ 是枚举的子树大小，$siz_{e.to}$ 是当前枚举的点为根的子树大小。则转移方程为：

$dp_{now,v}=\max(dp_{now,v-x}+cost+dp_{e.to,x})$

如果不用滚动数组优化，倒序转移的逻辑是这样的：
```cpp
for(int v=min(k,siz[now]);v>=0;v--){
	for(int x=min(v,siz[e.to]);x>=0;x--){
		ll cost=1ll*e.w*(x*(k-x)+(siz[e.to]-x)*(n-k-siz[e.to]+x));
		dp[now][v]=max(dp[now][v],dp[now][v-x]+cost+dp[e.to][x]);
	}
}
```

观察到当 $x=0$ 时，

$dp_{now,v}=\max(dp_{now,v}+cost+dp_{e.to,0})$

也就意味着该情况下 $dp_{now,v}$ 可能由此刻的 $dp_{now,v}$ 转移而来。（即受自身影响）

而 $x\mathrlap{\,/}{=}0$ 时，$dp_{now,v}$ 只受容量小的情况限制。当我们倒序枚举子树大小， 一开始时，设 $y=dp_{now,v}$ ，则经过 $x>0$ 的情况的转移后，$dp_{now,v}\mathrlap{\,/}{=}y$，到 $x=0$ 时，由于该情况下状态转移由 $y$ 转移而来，而 $dp_{now,v}$ 已改变，因此套用上述转移方程会出错。

出错的直接原因是 $x=0$ 情况下用来转移的状态被提前覆盖。为了解决上述问题，方法有：

1. 滚动数组：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=2e3+10;
int n,k,siz[maxn]; ll dp[maxn][maxn][2];
struct edge{
	int to,w;
};
vector<edge>G[maxn]; 

void dfs(int now,int fa){
	siz[now]=1;
	for(int v=k;v>=0;v--)dp[now][v][1]=dp[now][v][0]=-1e9;
	dp[now][0][0]=dp[now][1][0]=0;
	for(int i=0;i<G[now].size();i++){
		edge e=G[now][i];
		if(e.to==fa)continue;
		dfs(e.to,now); siz[now]+=siz[e.to];
		for(int v=min(k,siz[now]);v>=0;v--){
			for(int x=min(v,siz[e.to]);x>=0;x--){
				if(dp[now][v-x][0]==-1e9)continue;
				dp[now][v][1]=max(dp[now][v][1],dp[now][v-x][0]+1ll*e.w*(x*(k-x)+(siz[e.to]-x)*(n-k-siz[e.to]+x))+
				dp[e.to][x][0]);
			}
			dp[now][v][0]=dp[now][v][1];
		}
	}
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<n;i++){
		int u,v,w; cin>>u>>v>>w;
		G[u].push_back({v,w}),G[v].push_back({u,w});
	}
	dfs(1,0);
	cout<<dp[1][k][0];
	return 0;
}
```
2. 正序枚举 $x$：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=2e3+10;
int n,k,siz[maxn]; ll dp[maxn][maxn];
struct edge{
	int to,w;
};
vector<edge>G[maxn]; 

void dfs(int now,int fa){
	siz[now]=1;
	for(int v=k;v>=0;v--)dp[now][v]=-1e9;
	dp[now][0]=dp[now][1]=0;
	for(int i=0;i<G[now].size();i++){
		edge e=G[now][i];
		if(e.to==fa)continue;
		dfs(e.to,now); siz[now]+=siz[e.to];
		for(int v=min(k,siz[now]);v>=0;v--){
			for(int x=0;x<=min(v,siz[e.to]);x++){
				if(dp[now][v-x]==-1e9)continue;
				dp[now][v]=max(dp[now][v],dp[now][v-x]+1ll*e.w*(x*(k-x)+(siz[e.to]-x)*(n-k-siz[e.to]+x))+
				dp[e.to][x]);
			}
		}
	}
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<n;i++){
		int u,v,w; cin>>u>>v>>w;
		G[u].push_back({v,w}),G[v].push_back({u,w});
	}
	dfs(1,0);
	cout<<dp[1][k];
	return 0;
}
```

由此子树大小枚举顺序问题解决了。


---

还有一个小问题：为何要将 $dp_{now,1}$ 的初始值设为 $0$？考虑两种可能： $now$ 染和不染色。不染色对应 $dp_{now,0}=0$，若染色但其所有子树初始均不染时，对应 $dp_{now,1}=0$。其实就是对选根和不选根的初始化，由于转移结构相同，转移式就混为一谈了。

---

## 作者：Add_Catalyst (赞：0)

# P3177 [HAOI2015] 树上染色

---

## 题意分析

略略略~~

---

## 思路分析

我们发现将整张图直接求值似乎无法得到答案（你可以 $O(n^2\operatorname{C}_n^k)$ 暴力骗分，但这非常不现实），那么我们可以考虑将由边组成的路径再拆回成边，统计每一条边的总贡献，然后就可以发现，一条边 $(u,v,w)$ 的贡献就是两端每种颜色的和分别相乘，再相加，最后乘上边权。

那么定义 $f_{u,i}$ 表示在以 $u$ 为根的子树中已经选了 $i$ 个黑点，其中边的最大总贡献。

转移十分简单：
$$
f_{u,i+j} = \max_{(u,v,w)\in G,dep_v>dep_u}{\{ f_{u,i} + f_{v,j} + \{ j (k - j) + (siz_v-j)[n-j-(siz_v-j)] \} w \}}
$$
进行树形 DP，再加入上下界优化即可通过，均摊时间复杂度 $O(nk)$。

---



## CODE

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define ll long long
#define max(a,b) ((a)<(b)?(b):(a))
#define min(a,b) ((a)>(b)?(b):(a))
#define tomax(a,b) ((a)=max((a),(b)))
#define tomin(a,b) ((a)=min((a),(b)))
#define RCL(a,b,c,d) memset((a),(b),sizeof(c)*(d))
#define FOR(i,a,b) for(register int i=(a);i<=(b);++i)
#define DOR(i,a,b) for(register int i=(a);i>=(b);--i)
#define EDGE(g,i,u,x) for(register int (i)=(g).h[(u)],(x)=(g).v[(i)];(i);(i)=(g).nxt[(i)],(x)=(g).v[(i)])
#define main Main();signed main(){ios::sync_with_stdio(0);cin.tie(0);return Main();}signed Main
using namespace std;
constexpr int N=2e3+10;
int n,m;
int siz[N];
ll f[N][N];
struct CFS{
	int tot,h[N],v[N<<1],w[N<<1],nxt[N<<1];
	int &operator[](int i){
		return w[i];
	}
	void att(int U,int V,int W){
		v[++tot]=V,nxt[tot]=h[U],h[U]=tot,w[tot]=W;
	}
	void con(int U,int V,int W){
		att(U,V,W),att(V,U,W);
	}
}g;
void dfs(int u,int fa){
	siz[u]=1,f[u][0]=f[u][1]=0;
	EDGE(g,i,u,v)if(v^fa){
		dfs(v,u),siz[u]+=siz[v];
		DOR(j,min(m,siz[u]),0){
			if(~f[u][j])f[u][j]+=f[v][0]+(ll)siz[v]*(n-m-siz[v])*g[i];
			DOR(k,min(j,siz[v]),1)if(~f[u][j-k])
				tomax(f[u][j],f[u][j-k]+f[v][k]+(ll)(k*(m-k)+(siz[v]-k)*(n-m-siz[v]+k))*g[i]);
		}
	}
}
signed main(){
	cin>>n>>m,RCL(f,-1,f,1),tomin(m,n-m);
	FOR(i,2,n){
		int u,v,w;
		cin>>u>>v>>w,g.con(u,v,w);
	}
	dfs(1,0),cout<<f[1][m]<<endl;
	return 0;
}
```

---

---

## 作者：ifffer_2137 (赞：0)

### 题意
把一棵树分成两个大小为 $k$ 和 $n-k$ 的点集，求两个点集内两两距离和之和的最大值。
### 分析
树上一车路径长度之和，一般考虑看每条边的贡献。

然后看到这题又容易想到是树形 DP，于是设计一下状态，第一维显然是当前子树 $u$，第二维的话因为限定了两个子集的大小，所以就是子树内选了 $i$ 个第一个子集的结点。那表示的值就是子树内的最大贡献和，注意我们把每一条边的贡献放到它所连接的儿子上计算。

然后你考虑转移，发现遍历儿子然后跑个树上背包卷一下即可。注意转移的时候不要同一个子树卷到一起，拿个临时数组存下。最后讨论子树根是否选进第一个子集，加上子树根所代表的边的贡献，显然是两个子集分别在子树内的点数乘子树外的点数，再乘上边权，容易发现你钦定子树内选点数量后这个值是确定的。

于是就做完了，时间复杂度 $O(n^2)$。
### 代码

```cpp
//From: ifffer_2137
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define inf 0x7fffffff
#define eb emplace_back
#define pii pair<int,int>
#define mkpr make_pair
#define fir first
#define sec second
inline int read(){
	char ch=getchar();int x=0,w=1;
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+ch-48,ch=getchar();return w==1?x:-x;
}
const int maxn=2e3+5;
int n,k;
vector<pii> T[maxn];
int siz[maxn];
int dp[maxn][maxn];
int tmp[maxn],tt[maxn];
void dfs(int u,int f){
	siz[u]=0;int x=0;
	vector<int> tmp,tt;
	tmp.resize(k+1),tt.resize(k+1);
	for(int i=0;i<=k;i++) tmp[i]=-inf;
	tmp[0]=0;
	for(pii e:T[u]){
		int v=e.fir,w=e.sec;
		if(v==f){x=w;continue;}
		dfs(v,u);siz[u]+=siz[v];
		for(int i=0;i<=min(siz[u],k);i++) tt[i]=tmp[i];
		for(int i=0;i<=min(siz[v],k);i++) for(int j=min(siz[u],k);j>=i;j--) tmp[j]=max(tmp[j],tt[j-i]+dp[v][i]);
	}
	siz[u]++;
	for(int i=0;i<=min(siz[u],k);i++){
		if(!i) dp[u][i]=tmp[i]+1ll*x*(i*(k-i)+(siz[u]-i)*(n-k-siz[u]+i));
		else dp[u][i]=max(tmp[i],tmp[i-1])+1ll*x*(i*(k-i)+(siz[u]-i)*(n-k-siz[u]+i));
	}
	//for(int i=0;i<=min(siz[u],k);i++) cout<<u<<' '<<i<<' '<<dp[u][i]<<'\n';
}
signed main(){
	#ifndef ONLINE_JUDGE
		assert(freopen("data.in","r",stdin));
		assert(freopen("test.out","w",stdout));
	#endif
	cin.tie(0),cout.tie(0);
	n=read(),k=read();k=min(k,n-k);
	for(int i=1;i<n;i++){
		int u=read(),v=read(),w=read();
		T[u].eb(v,w),T[v].eb(u,w);
	}
	dfs(1,0);
	cout<<dp[1][k]<<'\n';
	return 0;
}
```

---

## 作者：elonzhang (赞：0)

# [P3177 [HAOI2015] 树上染色](https://www.luogu.com.cn/problem/P3177)

## 大意
一棵 $n$ 个节点的树，并将其中的 $k$ 个节点染成黑色，并将其余节点染成白色。收益就是把同色节点之间的两两距离加起来，求这个收益的最大值。

## 思路
我们发现光是枚举每个点的颜色，时间复杂度就已经爆炸了，所以这个方法肯定不能多看一眼。竟然枚举点不行，那我们可以尝试考虑 $dp$ 每条边的贡献加起来。一条边将图分成了两部分，假设这条边左侧有 $b1$ 个小黑子，$w1$ 个小白子，右侧有 $b2$ 个小黑子，$w2$ 个小黑子的话，显然这条边的贡献为 $(b_1 \times b_2 + w_1 \times w_2) \times dist_{u,v}$，其中 $dist_{u,v}$ 是 $u$ 到 $v$ 这条边的长度。所以定义 $dp_{i,j}$ 表示以 $i$ 为根的子树里有 $j$ 个小黑子时这个子树里面的边的总贡献最大是多少。然后进行一个树上背包 $dp_{u,j} = \max (dp_{u,j-t} + dp_{u,t} + dist_{u,v} \times (t \times (k-t) + (size_v - t) \times (n - k size_v + t)))$ 其中 $size_i$ 为以 $i$ 为根的子树大小，$size_i - t$ 即子树 $i$ 内小白子的个数。理解这些递归式就可与去愉快的写代码啦。

## code:
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define double long double
#define endl '\n'
#define inf 0x7f7f7f7f7f7f7f7f
const int N=2001;
int n,m,siz[N],dp[N][N];
struct road{
	int v,w;
};vector<road> g[N];

void dfs(int u,int fa){
	dp[u][0]=dp[u][1]=0;
	siz[u]=1;
	for(int i = 0;i<g[u].size();++i){
		int v=g[u][i].v,w=g[u][i].w;
		if(v==fa) continue;
		dfs(v,u);
		siz[u]+=siz[v];
		for(int j = min(m,siz[u]);j>=0;--j){
			if(dp[u][j]^-1) dp[u][j]+=dp[v][0]+w*(siz[v]*(n-m-siz[v]));
			for(int k = min(j,siz[v]);k;--k){
				if(dp[u][j-k]^-1)
				 dp[u][j]=max(dp[u][j],dp[u][j-k]+dp[v][k]+w*(k*(m-k)+(siz[v]-k)*(n-m-siz[v]+k)));
			}
		}
	}
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	memset(dp,-1ll,sizeof(dp));
//  freopen("","r",stdin);
//  freopen("","w",stdout);
//↑以上为初始化 ↑
//------------------------------
	cin >> n >> m;
	if(n-m<m) m=n-m;
	for(int i = 1;i<n;++i){
		int u,v,w;
		cin >> u >> v >> w;
		g[u].push_back({v,w});
		g[v].push_back({u,w});
	}
	dfs(1,-1);
	cout << dp[1][m] << endl;
	return 0;
}
```

---


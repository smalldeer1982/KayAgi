# 偷天换日

## 题目背景

神偷对艺术馆内的名画垂涎欲滴准备大捞一把。


## 题目描述

艺术馆由若干个展览厅和若干条走廊组成。每一条走廊的尽头不是通向一个展览厅，就是分为两个走廊。

每个展览厅内都有若干幅画，每副画都有一个价值。经过走廊和偷画都是要耗费时间的。

警察会在 $n$ 秒后到达进口，在不被逮捕的情况下你最多能得到的价值。

![](https://cdn.luogu.com.cn/upload/pic/2730.png)

## 说明/提示

来源：改编


## 样例 #1

### 输入

```
50 
5 0 10 1 10 1 5 0 10 2 500 1 1000 2 18 1 1000000 4 ```

### 输出

```
1500```

# 题解

## 作者：cyy233 (赞：26)

# 废话不说，直接开讲。
*****
这道题和访问美术馆及其相似，就是加了01背包。。。
是一道不错的**树形dp**

我们可以采用线段树的存储思想
~~虽然我还不会线段树~~

**我们把当前节点作为x，左节点就是2x,右节点即2x+1**，

这样的话，程序看上去，简单，直观多了

**~~唯一的缺点就是耗空间，像我Re到飞起~~**

对于dp，可以直接在读入中做。

还有这道题有两个坑点，**一是小偷在s-1秒时就必须离**开

**二是走廊必须走一来一回两遍**

所以做dfs前s--，做背包时前t*2

背包容量下限加一个时间t(*2)

然后就和选课一样，最多时间s（-1），最少t（*2）

从左节点下限一秒也不花，上限走这条走廊的时间i-t(*2),我们有公式

# dp[x][i]=max(dp[x][i],dp[x<<1][j]+dp[x<<1|1][i-j-t]);

x为当前节点，i为走该走廊的时间

左儿子花j秒，右儿子花i-j-t（*2）秒，走走廊t（*2)秒（t是读入时的t，可以在dp前就t*2

下面给出代码

```
#include<bits/stdc++.h>
using namespace std;
int s,dp[10010][10010],ans,a[2010],b[2010];
void read(int x){

	int t,k;
	cin>>t>>k;
	t=t<<1;
	if(k>0){
		for(int i=1;i<=k;i++){
			cin>>a[i]>>b[i];
		}	
		for(int i=1;i<=k;i++){
			for(int j=s;j>=t+b[i];j--){
				dp[x][j]=max(dp[x][j-b[i]]+a[i],dp[x][j]);
			}
		}
	}
	if(!k){
		read(x<<1);
		read(x<<1|1);
		for(int i=s;i>=t;i--)
			for(int j=0;j<=i-t;j++){
				dp[x][i]=max(dp[x][i],dp[x<<1][j]+dp[x<<1|1][i-j-t]);
			}
	}
}
int main()
{
	ios::sync_with_stdio(false);
	//freopen("steal.in","r",stdin);
	//freopen("steal.out","w",stdout);
	cin>>s;
	s--;
	read(1);
	cout<<dp[1][s];
	return 0;
}

```

~~不看美术馆的题解还想不到这样保存~~

---

## 作者：jzqjzq (赞：11)

p1270访问“美术馆”升级版（就是树形DP维护背包）

每件画由原来的时间一定和价值一定变成了不定

所以这题与1270唯一的区别在，终端的盗画处理变成了背包

定义状态：f[i][j]表示节点i花费j单位时间可得到的最大价值

我们按照深度优先顺序读入+处理DP数组（按照树形DP惯例做法）

然后就好了呀

```cpp
#include<algorithm>
#include<iostream>
#include<cmath>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std;
ll n=1,m;
ll f[1001][1001]={0},a[1001],b[1001];
inline void dfs(ll x){
    ll c,v;
    scanf("%lld",&c);
    c*=2;
    scanf("%lld",&v);//c表示走到这个点的走廊长度，因为要原路返回所以乘2，v表示这个点展画数量（具体看下面）
    if(v){//如果是终端展馆（v>0）就是01背包
        for(ll i=1;i<=v;i++)scanf("%lld%lld",&a[i],&b[i]);
        for(ll i=1;i<=v;i++)
            for(ll j=m;j>=b[i];j--)if(j-b[i]>=c)f[x][j]=max(f[x][j],f[x][j-b[i]]+a[i]);//中间判断大于走廊长度因为要保证可以走到这个展馆并且返回
        return;
    }
    ll l,r;//这里开始这个点就不是展馆了（v=0）
    n++;l=n;dfs(n);//深度优先搜索，下同
    n++;r=n;dfs(n);
    for(ll i=c;i<=m;i++)//枚举分给左端点的时间然后合并状态
        for(ll j=0;j<=i-c;j++)f[x][i]=max(f[x][i],f[l][j]+f[r][i-c-j]);
}
int main()
{
    scanf("%lld",&m);m--;//同1270坑点一样，m要减1
    dfs(1);
    printf("%lld",f[1][m]);//答案
    return 0;
}
```

---

## 作者：Uniecho1 (赞：8)

这道题折腾了我半天

也不知是我太菜了，还是怎么了

内存被卡得飞起

一怒之下我人工二分

最后发觉这个题数据范围似乎有问题？？？？
```cpp
#include<bits/stdc++.h>
#define MAXN 1005
using namespace std;

int N,cnt,f[MAXN][1005],C[35],V[35],W[MAXN];

vector<int>G[MAXN];

void init(int fa)
{
    ++cnt;
    int tim,size;
    scanf("%d%d",&tim,&size);
    G[fa].push_back(cnt);
    W[cnt]=tim*2;
    int now=cnt;
    if(!size)
    {
        init(now);
        init(now);
    }
    else
    {
        cnt++;
        G[now].push_back(cnt);
        for(int i=1;i<=size;i++)
        {
            scanf("%d%d",&V[i],&C[i]);//开始01背包
            W[cnt]+=C[i];//其实做出W就是一个小优化，我漆**觉得意义不大 
        }
        for(int i=1;i<=size;i++)
        for(int j=N;j>=C[i];j--)
        f[cnt][j]=max(f[cnt][j],f[cnt][j-C[i]]+V[i]);
    }
}

int dp(int cur)
{
    int size=W[cur];//配给这个节点的最大点数
    for(int i=0;i<G[cur].size();i++)
    {
        int v=G[cur][i];
        int s=dp(v);
        size+=s;
        for(int j=size;j>=W[cur];j--)
        for(int k=0;j-k>=W[cur];k++)
        if(k>s)break;
        else f[cur][j]=max(f[cur][j],f[cur][j-k]+f[v][k]);
    }
    return size;
}

int main()
{
    scanf("%d",&N);
    init(0);
    dp(1);
    printf("%d",f[1][N-1]);
    return 0;
}
```

---

## 作者：聊机 (赞：7)


为了庆祝我的代码成为了目前的最优解，我决定发一篇题解！
## 开始讲解！

#### 第一部分：读入（深度优先）？
一开始我并没有联想到深度优先搜索，其实读入就是一个dfs的递归，如果要分叉，先把左子树读入完，再读右子树。①

#### 第二部分：动规

一开始做这道题我也没有想到他是从入口处进去再出来的，所以第一步，先把时间减一，然后在进行动规的时候，不要忘记将走廊的长度乘二，这个很关键。

动规分为两部分。

##### 第一部分：分叉的走廊

先读入左右子树，然后从大到小枚举自己时间，再嵌套一层循环，枚举有多少时间选左子树，更新答案即可。②

##### 第二部分：展厅

展厅就是一个基本的01背包，对于每一幅画，从大到小枚举时间，选择放与不放即可。③

贴AC代码（16ms）
```cpp
#include<bits/stdc++.h>
#define ls p<<1
#define rs p<<1|1
using namespace std;
inline int read(){
	int k=0;bool f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}
	while(isdigit(ch)){k=(k<<1)+(k<<3)+(ch^48);ch=getchar();}	
	return f?k:-k;
}
int m,f[1000][600];
void dfs(int p){//读入部分
	int t=read(),n=read();
	if(!n){
		dfs(ls);
		dfs(rs);//①
		for(int v=m-t*2;v>0;v--)
		    for(int j=v;j>=0;j--)
		    	f[p][v+t*2]=max(f[p][v+t*2],f[ls][j]+f[rs][v-j]);//②千万不要忘了给走廊时间乘二
	}
	else {
	    for(int i=1;i<=n;i++)
	    {
	    	int w=read(),c=read();
	    	for(int v=m;v>=c+t*2;v--)
	    	    f[p][v]=max(f[p][v],f[p][v-c]+w);//③
		}
	}
}
int main(){
	m=read()-1; dfs(1);
	printf("%d",f[1][m]);
	return 0;
}
```
感谢您的观看。

---

## 作者：jyz666 (赞：4)

# **[P3360 偷天换日](https://www.luogu.com.cn/problem/P3360)**

[思路]

首先我们把边上的消耗放到向下的点上，如果是叶子节点的话就先做一次0/1背包

发现这是一颗二叉树，转移的时候枚举给左儿子多少时间，右儿子多少时间就好

上代码：
```cpp

#include<stdio.h>
#include<bits/stdc++.h>
#define inf 0x7f7f7f7f
using namespace std;
const int MOD=1000000007;
typedef long long ll;
typedef unsigned long long ull;
using std::max;
const int N=1000+15;
ll n,tot=1;
ll dp[N][N],w[N],c[N];
inline ll read()
{
    char ch=getchar();
    ll s=0,f=1;
    while (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=getchar();}
    while (ch>='0'&&ch<='9') {s=(s<<3)+(s<<1)+ch-'0';ch=getchar();}
    return s*f;
}
void dfs(int now)
{
    ll t=read(),x=read();
    t<<=1;
    if (x)
    {
        for (ll i=1;i<=x;i++) w[i]=read(),c[i]=read();
        for (ll i=1;i<=x;i++)
        {
            for (ll j=n;j>=c[i];j--) if (j-c[i]>=t) dp[now][j]=max(dp[now][j],dp[now][j-c[i]]+w[i]);        
        }
        return; 
    }
    ll l=++tot;dfs(tot);
    ll r=++tot;dfs(tot);
    for (ll i=t;i<=n;i++)
        for (ll j=0;j<=i-t;j++)
        {
            dp[now][i]=max(dp[now][i],dp[l][j]+dp[r][i-t-j]);
        }
}
int main()
{
    n=read();n--;
    dfs(1);
    printf("%lld\n",dp[1][n]);
    return 0;
}

```


---

## 作者：bingliang (赞：4)

树形dp题   一眼应该能看出来的     本题跟一道叫访问美术馆的题非常像    感觉两题的大体思路相同     但本题有一个重要的地方。

就是转移的时候要做背包      。   考虑对于到达每个节点的时候  我们有  i的时间    把i的时间  分配给两子树   i-k  和 k   用于走路  和拿画

但我们对于   一个房间内的画   要在  分配的时间-路程的时间内  取更多的价值    所以做个背包

不多bb上代码

    
    


```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n,m,dp[10000][10000];
int a[1000],b[1000];
void dfs(int x)
{
//    cout<<x<<endl;
    int t1,t2;
    cin>>t1>>t2;
    t1*=2;
    if(t2>0)
    {
        for(int i=1;i<=t2;i++)
        {
            cin>>a[i]>>b[i];
        }
        for(int i=1;i<=t2;i++)
    {
        for(int j=n;j>=b[i]+t1;j--)
        {
dp[x][j]=max(dp[x][j],dp[x][j-b[i]]+a[i]);            
        }
    }
    }
    if(t2==0)
    {
    dfs(x*2);
    dfs(x*2+1);
    for(int j=t1;j<=n;j++)
    {
        for(int k=0;k<=j-t1;k++)
        {
dp[x][j]=max(dp[x][j],dp[x*2][j-k-t1]+dp[x*2+1][k]);            
        }
    }
    return;
    }
}
int main()
{
cin>>n;
n--;
dfs(1);
cout<<dp[1][n];
    return 0;
}

```

---

## 作者：神蝶涵光 (赞：3)

```
初看题目，哇，双倍经验！！！（P1270） 
交后，艹，全WA，再看题目， 有那么一点点不一样......
三看题目，不愧是改编，坑点都一模一样%%%
——— 给了个假时间，所以要n-1 
```
```
同样的输入，同样的建树
void build(int k)
{
	cin>>t[k]>>s[k];
	t[k]<<=1;//跑两遍走廊
	if(!s[k])//分叉了
	{
		build(k<<1);//左树
		build(k<<1|1);//右树
	}
}
不同的是，这个题还多了一个01背包
故
	else
		for(int i=1;i<=s[k];i++)//s为画数
			cin>>s2[k][i]>>t2[k][i];//s2为01背包的价值，t2为时间
```
```
又是一个同点———搜价值（一部分）
	for(int i=0;i<=tt-t[k];i++)//tt为总时间
	{
		int l=k<<1,r=k<<1|1;//左树右树
		dp(l,i);
		dp(r,tt-i-t[k]);
		f[k][tt]=max(f[k][tt],f[l][i]+f[r][tt-i-t[k]]);//更新f
	}
但还要多个01背包的模版
	if(s[k])
	{
		//fill(f2+1,f2+1+n,0);
		memset(f2,0,sizeof(f2));//f2为做背包时用的数组
		for(int i=1;i<=s[k];i++)
			for(int j=tt-t[k];j>=t2[k][i];j--)
				f2[j]=max(f2[j],f2[j-t2[k][i]]+s2[k][i]);
		f[k][tt]=f2[tt-t[k]];
	}

```
```
总代码如下
#include<bits/stdc++.h>
using namespace std;
int n;
int f[601][601],t[601],s[601],t2[601][601],s2[601][601],f2[601];
void build(int k)
{
	cin>>t[k]>>s[k];
	t[k]<<=1;
	if(!s[k])
	{
		build(k<<1);
		build(k<<1|1);
	}
	else
		for(int i=1;i<=s[k];i++)
			cin>>s2[k][i]>>t2[k][i];
}
int dp(int k,int tt)
{
	if(!tt||f[k][tt])
		return f[k][tt];
	if(s[k])
	{
		//fill(f2+1,f2+1+n,0);
		memset(f2,0,sizeof(f2));
		for(int i=1;i<=s[k];i++)
			for(int j=tt-t[k];j>=t2[k][i];j--)
				f2[j]=max(f2[j],f2[j-t2[k][i]]+s2[k][i]);
		f[k][tt]=f2[tt-t[k]];
		return f[k][tt];
	}
	for(int i=0;i<=tt-t[k];i++)
	{
		int l=k<<1,r=k<<1|1;
		dp(l,i);
		dp(r,tt-i-t[k]);
		f[k][tt]=max(f[k][tt],f[l][i]+f[r][tt-i-t[k]]);
	}
	return f[k][tt];
}
int main()
{
	cin>>n;
	n--;
	build(1);
	dp(1,n);
	cout<<f[1][n];
	return 0;
}
```
```
注意
1 不要开O2，后果自负
2 做dp时一定要先跑01背包，因为，for里面的会影响我们做背包
3 一定要加
if(!tt||f[k][tt])
	return f[k][tt];
每个搜时，也要return
不然会超时
4 n--，要严格小于
```

---

## 作者：幻·光 (赞：2)

首先要处理输入，题目说了，输入是按深度优先给出的。

然后要考虑拿不拿画。  
其实这就是01背包。对于每一幅画，我们可以要，也可以不要。那么我们就定义一个状态 $f\,[\,i\,]\,[\,j\,]$ ,表示在节点 $i$ 花费了 $j$ 秒可以得到的最大价值。再定义一个 $d$ 数组，用于统计每次偷画的价值。

如果小偷在展室，那么对于 $d\,[\,k\,]$ ，应等于  
$\max(\,d\,[\,k\,]\,,\,d\,[\,k\,]-\,b\,[\,x\,][\,i\,]\,]\,+\,a\,[\,x\,][\,i\,]\,)$  
其中， $d\,[\,k\,]$ 表示当前最大的的价值， $b\,[\,x\,][\,i\,]$ 和 $a\,[\,x\,][\,i\,]$ 分别表示偷画需要的价值和时间。
最后再把值赋给 $f$ 数组。

如果小偷还在走廊（连接两个走廊的那种），那么 $f\,[\,i\,][\,j\,]$ 应等于 $\max\,(\,f\,[\,i\,][\,j\,]\,,\,dp\,(\,i\,\times\,\,2\,,\,$ 时间 $\,)\,+\,dp\,(\,i\,\times\,2\,+\,1\,,\,j\,-\,$ 走左子树用的时间 $\,-\,t\,[\,x\,]\,)\,)$    
$i\,\times\,\,2\,,\,$ 表示左子树， $\,i\,\times\,2\,+\,1\,$ 表示右子树

AC代码
```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
using namespace std;
const int N=607;
int s,t[N],h[N],f[N][N],d[305],a[N][N],b[N][N];
void dfs(int x)//其实题目的输入是按dfs的顺序输入的，所以用dfs来处理 
{
	scanf("%d %d",&t[x],&h[x]);
	t[x]*=2;//小偷是要回到起点的，所以要来回 
	if(!h[x])//说明这里连接的是走廊 
		dfs(x*2),dfs(x*2+1);//x*2代表左子树， x*2+1代表右子树
	else//负责这就是展室 
		for(int i=1;i<=h[x];i++)
			scanf("%d %d",&a[x][i],&b[x][i]);
} 
int dp(int x,int k)
{
	if(f[x][k] || !k)//说明已经访问过了，或者没时间了 
		return f[x][k];
	if(h[x])//说明里边有画 
	{
		memset(d,0,sizeof(d));
		for(int i=1;i<=h[x];i++)
			for(int j=k-t[x];j>=b[x][i];j--)//01背包模板 ，j=k-t[x]意思是当前剩下的时间（总时间-过走廊的时间），然后j必须大于等于b[x][i]（偷画时间），不然就没办法偷到画 
				d[j]=max(d[j],d[j-b[x][i]]+a[x][i]);//d[j-b[x][i]]+a[x][i]表示偷完画以后获得的价值 
		f[x][k]=d[k-t[x]];
		return f[x][k];
	}
	for(int i=0;i<=k-t[x];i++)//说明这连接的是走廊 
		f[x][k]=max(f[x][k],dp(x*2,i)+dp(x*2+1,k-i-t[x]));//取能获得的最大价值 
	return f[x][k];
}
int main()
{
	scanf("%d",&s);
	dfs(1);
	dp(1,s-1);//小偷不能在第s秒回去，最多只能s-1 
	printf("%d",f[1][s-1]);
	return 0;
}
```


---

## 作者：SNiFe (赞：2)

这道题坑了我\_2个小时\_，待会我会在代码中批注是哪个地方坑了我，大家要注意。

**1.**这道题我用的结构体加DFS输入，变输入边做01背包；

**2.**这是一道树形DP，所以结构类似一棵树，看了我的代码就知道了；

**3.**定义状态：f[i][j]表示节点i花费j单位时间可得到的最大价值；

代码附上+详细批注：

\_**结构体代码：**\_



```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n;//警察来临时间 
long long f[600][600]={0};//f[i][j]表示节点i花费j单位时间可得到的最大价值 
struct va
{
    int dis;//走廊长度 
    int pd;//记录有无岔路 
    int l,r;//左路，右路 
    int value[35],tim[35];//价值，时间 
}edge[605];
void sca(int i)
{
    scanf("%d%d",&edge[i].dis,&edge[i].pd);
    edge[i].dis*=2;
    if(edge[i].pd==0)
    {
        edge[i].l=i*2,sca(i*2);//此处神坑，注意 (类比楼下代码，他开的全局变量m，我开始没开m，而是i+1就GG，后来改为i*2) 
        edge[i].r=i*2+1,sca(i*2+1);//此处神坑，注意 
        for(int k=edge[i].dis;k<=n;k++)
        for(int j=0;j<=k-edge[i].dis;j++)f[i][k]=max(f[i][k],f[edge[i].l][j]+f[edge[i].r][k-j-edge[i].dis]);//左路+右路偷得价值 
    }
    else
    {
        for(int j=1;j<=edge[i].pd;j++)
        {
            scanf("%d%d",&edge[i].value[j],&edge[i].tim[j]);
        }
        for(int k=1;k<=edge[i].pd;k++)//01背包 
        for(int j=n;j>=edge[i].tim[k];j--)
        if(j-edge[i].tim[k]>=edge[i].dis)
        f[i][j]=max(f[i][j],f[i][j-edge[i].tim[k]]+edge[i].value[k]);
        return;
    }
}
int main()
{
    scanf("%d",&n);n--;//记得要-1（小偷要逃跑） 
    sca(1);
    printf("%lld",f[1][n]);
}
```
\_**其实可以不用结构体：**\_
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define ll long long
ll n,m=1;
ll f[1001][1001]={0};
ll value[1001],tim[1001];
inline void sca(ll x)
{
    ll dis,pd;
    scanf("%lld%lld",&dis,&pd);
    dis*=2;
    if(pd)
    {
        for(ll j=1;j<=pd;j++)
        scanf("%lld%lld",&value[j],&tim[j]);
        for(ll i=1;i<=pd;i++)
            for(ll j=n;j>=tim[i];j--)
            if(j-tim[i]>=dis)
            f[x][j]=max(f[x][j],f[x][j-tim[i]]+value[i]);
        return;
    }
    ll l=++m;sca(m);
    ll r=++m;sca(m);
    for(ll i=dis;i<=n;i++)
    for(ll j=0;j<=i-dis;j++)f[x][i]=max(f[x][i],f[l][j]+f[r][i-j-dis]);    
}
int main()
{
    scanf("%lld",&n);n--;
    sca(1);
    printf("%lld",f[1][n]);
    return 0;
}
//打完收工，好累

```

---

## 作者：Porsche (赞：1)

## 楼下一群线段树大佬
#### 然而考试的时候只剩十分钟了，怎么办？
#### 显然建树不明智，那怎么办，如何让暴力拿到更高分？
```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(4)
using namespace std;
bool flag[50000],wzc;
int n,m,op,x,d;
int main()
{
    scanf("%d%d",&n,&m);
    flag[0]=flag[n+1]=1;
    while(m--)
    {
        scanf("%d",&op);
        if(op==1)
        {
            scanf("%d",&x);
            wzc=0;
            for(int i=1,j;i<=n;i++)
                if(!flag[i])
                {
                    for(j=i;j<=n;j++)
                        if(flag[j]||j-i==x)break;
                    if(j-i==x)
                    {
                        for(j=i;j<=i+x-1;j++)
                            flag[j]|=1;
                        wzc=1;
                        printf("%d\n",i);
                        break;
                    }
                    i=j;
                }
            if(!wzc)printf("0\n");
        }
        else
        {
            scanf("%d%d",&x,&d);
            for(int i=x;i<=x+d-1;i++)
                flag[i]&=0;
        }
    }
    return 0;
}
```
### ↑，没错，裸暴力
#### 但是洛谷过于强大，建议开优化，开之前7000ms+，开之后3000ms-
#### 再此%一次强大的洛谷管理员

---

## 作者：qmq菜死了 (赞：0)

这是一道很好的树形 dp 题，这题其实和 P1270 “访问”美术馆是一样的题目，只不过输入稍微麻烦一点，计算偷画情况的时候变成了一个 01 背包。

但是，这题还是有不少坑的，有几个必须注意的点：1.偷画的路程必须计算 2 遍，因为是来回；2.输入偷画价值和时间的数组应该用二维，用一维会被覆盖掉；3.用来背包的数组大小必须定义 300 多，因为这里的容量是房间，定义 600 多很有可能会 TLE ；4.小偷时间为 n 时就跑不掉了，n-1 才行。

话不多说，上代码：

```cpp
#include<bits/stdc++.h>//好用方便的万能头
using namespace std;
const int N=666;
int s,f[N][N],a[N],b[N],w[N][N],c[N][N],ff[N/2];//f[i][j] 表示在节点 i ，花费了 j 秒，获得最大值，a 数组记录路径所花时间，w 数组和 c 数组分别记录 在节点 x 第 i 副画的价值和所花时间
void dfs(int x)
{
	cin>>a[x]>>b[x];
	a[x]*=2;//来回两次时间双倍
	if(b[x]==0)//如果链接两条走廊
	{
		dfs(x*2);//完全二叉树，递归左子树和右子树
		dfs(x*2+1);
	}
	else
	{
		for(int i=1;i<=b[x];i++)
		{
			cin>>w[x][i]>>c[x][i];//读入价值和时间
		}
	}
}
int dp(int x,int k)//当前走到了节点 x , 剩余时间 k 能获得的最大价值 
{
	if(k==0||f[x][k]!=0)//如果求过了或者没时间了
	{
		return f[x][k];
	}
	if(b[x]!=0)//如果有画
	{
		memset(ff,0,sizeof(ff));//每次定义 01 背包初值为 0
		for(int i=1;i<=b[x];i++)
		{
			for(int j=k-a[x];j>=c[x][i];j--)
			{
				ff[j]=max(ff[j],ff[j-c[x][i]]+w[x][i]);// 01 背包模板
			}
		}
		f[x][k]=ff[k-a[x]];
		return f[x][k];
	}
	for(int i=0;k-i-a[x]>=0;i++)//如果不是叶子节点
	{
		f[x][k]=max(f[x][k],dp(x*2,i)+dp(x*2+1,k-i-a[x]));//递归左右子树
	}
	return f[x][k];
}
int main()
{
	cin>>s;//读入警察到来时间
	dfs(1); //是完全二叉树，需要递归读入各项数据
	dp(1,s-1);//树形 dp ，找最大偷画价值
	cout<<f[1][s-1];//必须在 s-1 及之前跑掉
	return 0;
}
```


---

## 作者：cccgift (赞：0)

pascal的题解好少……

题目都给了一个图了，一看就知道和树有关。而题目是要求最优解，所以是树形dp。

先考虑输入（第一次见过输入这么坑的），使用递归读入，读完一个点后再读左结点和右结点，详见代码中的pasread。

## 接下来是dp方程：

先考虑死角，这是一个经典的01背包问题，不多讲。

考虑还有分岔路的，枚举现在剩下的时间，假设为$j$。再枚举分给左岔路的时间$k$，那么$j-k$就是分给右岔路的时间。

设$f[i,j]$为剩下$j$秒，从以$i$为根节点的子树所能得到的最大价值

$f[i,j]=max(f[i,j],f[left[i],k]+f[right[i],j-k])$

其中$left[i]$表示$i$的左结点，$right[i]$表示$i$的右结点。

结果就是$f[1,n]$。

## 另外，题目中有多个坑点：

1、时间要乘2，因为小偷不仅要进去，而且要出来，这样要2倍时间。这样就只用考虑进去了。

2、总时间要减1，因为如果恰好在第$n$秒到达出口，会被警察逮个正着，所以需要考虑在$n-1$秒内到达出口。

以下是代码：

```pascal
uses math;
var f:array[0..600,0..600] of longint;
    l,r,t,ans,h:array[1..600] of longint; //ans[i]表示在i位置的画的幅数
    w,c:array[0..600,0..30] of longint;
    time,n,i,j,k,len:longint;
procedure pasread; //递归读入
var lenn,i:longint;
begin
  inc(len);lenn:=len;read(t[len],ans[len]);t[len]:=t[len]*2;
  for i:=1 to ans[len] do read(w[len,i],c[len,i]);
  if ans[len]=0 then //有分岔路的情况
  begin
    pasread; //读左边
    l[lenn]:=lenn+1;r[lenn]:=len+1;
    pasread; //读右边
  end;
end;
procedure dfs(kk:longint); //先序遍历，存下访问结点的顺序，这样就可以不必递归访问。
begin
  if l[kk]>0 then dfs(l[kk]);
  if r[kk]>0 then dfs(r[kk]);
  inc(n);h[n]:=kk;
end;
begin
  readln(time);dec(time);
  pasread;
  dfs(1);
  for i:=1 to n do
    if l[h[i]]>0 then
      for j:=t[h[i]] to time do //dp，得从t[h[i]]开始是因为需要用这么多时间走过走廊
        for k:=0 to j-t[h[i]] do
          f[h[i],j]:=max(f[h[i],j],f[l[h[i]],k]+f[r[h[i]],j-k-t[h[i]]])
    else
      for j:=1 to ans[h[i]] do //01背包
        for k:=time downto c[h[i],j] do
          if k-c[h[i],j]>=t[h[i]] then //判断剩下的时间是否能够通过走廊
            f[h[i],k]:=max(f[h[i],k],f[h[i],k-c[h[i],j]]+w[h[i],j])
          else break;
  writeln(f[1,time]);
end.
```

---


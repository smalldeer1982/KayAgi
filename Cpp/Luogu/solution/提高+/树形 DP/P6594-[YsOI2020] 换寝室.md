# [YsOI2020] 换寝室

## 题目背景

马上要开学了，Ysuperman 正在为给孩子们分配寝室忙得不可开交......

## 题目描述

幼儿园里面有 $n$ 个房间，这些房间由 $n-1$ 条双向道路连接着，第 $i$ 条道路连接着房间 $u_i$ 和 $v_i$ ，每条道路 Ysuperman 都可以选择开启或者是关闭，每个房间**在所有道路开启的前提下**都可以到达其他任意一个房间。

每个房间有一个差异值，其中，第 $i$ 个房间的差异值为 $h_i$ 。

在选择完关闭哪些道路后，整个寝室会被分成许多连通块，一个联通块内的小朋友的不满意值定义为连通块内差异值的**最大值减去最小值**，小朋友们的总不满意值定义为**所有联通块不满意值的最大值**。

寝室里有 $m$ 个寝室老师，每个老师晚上都要查寝，第 $i$ 个老师会从第 $x_i$ 个房间走到第 $y_i$ 个房间，如果老师在查寝时经过了某条被关闭的道路，TA就会很生气，一个老师的不满意值定义为**从 $x_i$ 走到 $y_i$ 经过的被关闭的道路数量**，老师的总不满意值定义为**所有老师的不满意值之和**。

Ysuperman 能承受的老师的总不满意值最大为 $k$ ，现在TA想知道小朋友们的总不满意值最小可以达到多少。

## 说明/提示

### 样例说明

#### 样例说明 $1$

![](https://cdn.luogu.com.cn/upload/image_hosting/mf6j6hz3.png)

Ysuperman选择关闭连接着 $1$ 和 $5$ 的道路，老师的总不满意值为 $0$，寝室被分为 $2$ 个连通块，小朋友们的总不满意值为 $3$。

#### 样例说明 $2$

图同样例一。

Ysuperman选择关闭连接着 $1$ 和 $5$ 的道路以及连接着 $1$ 和 $4$ 的道路，老师的总不满意值为 $1$，寝室被分为 $3$ 个连通块，小朋友们的总不满意值为 $2$。

------
### 数据范围

**本题采用捆绑测试。**

| Subtask | $n$ | $m$ | $k$ | 特殊性质 | 分数 |
|:-:|:-:|:-:|:-:|:-:|:-:|
| 1 | $\le 20$ | $\le 10$ | $\le 80$ | 无 | 8 |
| 2 | $\le 150$ | $\le 10^3$ | $\le 8 \times 10^4$ | 无 | 13 |
| 3 | $\le 800$ | $\le 10^5$ | $\le 8 \times 10^7$ | 树为一条链 | 13 |
| 4 | $\le 800$ | $\le 10^5$ | $\le 8 \times 10^7$ | 树为一朵盛开的菊花 | 13 |
| 5 | $\le 800$ | $\le 10^5$ | $= 0$ | 无 | 13 |
| 6 | $\le 800$ | $\le 10^5$ | $\le 8 \times 10^7$ | 无 | 40 |

【一条链】定义为：所有点的度数 $\le2$。

【一朵盛开的菊花】定义为：存在一个点的度数为 $n-1$。

对于 $100\%$ 的数据，满足 $1\le h_i\le 10^9，0\le k \le 8\cdot 10^7,u_i\ne v_i$ 。

## 样例 #1

### 输入

```
5 2 0
1 3 1 4 0
1 2
1 3
1 4
1 5
2 3
1 4```

### 输出

```
3```

## 样例 #2

### 输入

```
5 2 1
1 3 1 4 0
1 2
1 3
1 4
1 5
2 3
1 4```

### 输出

```
2```

# 题解

## 作者：xiaolilsq (赞：12)

题意简化后就是这样：

给定一棵树，每条边有边权，割掉一些边，使得被割掉的边边权和不超过 $k$ ，最小化剩余连通块点权极差的最大值。

## subtask 1

枚举割掉哪些边，判一下是否合法再更新一下答案。

时间复杂度： $O(2^{n-1})$ 。

## subtask 2

最小化剩余连通块点权极差的最大值，考虑二分答案 $mid$ ，题目转化为：

给定一棵树，要求割掉一些边后剩余连通块点权极差小于 $mid$ ，最小化割掉的边边权和。

考虑 $dp$ ，设状态 $dp_{u,l,r}$ 表示考虑完了以 $u$ 为根的子树，其中 $u$ 这个点所在的联通块最小值所在点编号为 $l$ ，最大值所在点编号为 $r$ 的最小花费，每次都树形dp一遍判答案是否合法。

时间复杂度： $O(n^3\log_2maxh)$ 。

## subtask 3

树为一条链，直接转区间问题，设 $dp_r$ 表示考虑完了前 $1\sim r$ 个点最小的花费，直接枚举每一个合法的 $l$ ，把 $l\sim r$ 作为一个连通块进行转移就行了。

可以用单调队列进一步优化。

时间复杂度： $O(n\log_2maxh)$ 。

## subtask 4

树为一朵~~盛开~~的菊花，割掉一条边就是割掉根与叶子节点，最后的连通块要么和根节点连着，要么大小为1，离散化所有点权，双指针 $l$ 和 $r$ 表示把点权在 $l$ 到 $r$ 之间节点的作为和根节点连着的连通块，其他的点作为单独连通块，直接扫一遍可以得到答案。

时间复杂度： $O(n\log_2maxh)$ 。

~~所以其实subtask3和subtask4的复杂度可以更优，原本可以出个数据分治屑题的。~~

## subtask 5

$k=0$ ， 当且仅当边权为 $0$ 时可以被割掉，割掉后直接dfs即可。

时间复杂度： $O(n)$ 。

## subtask 6

考虑优化subtask 2里面讲的算法。

发现不必最大值和最小值都记录，只要记录一个即可。

二分出 $mid$ 后，首先对于所有点，dfs出所有可以以它为最小值的点。

如果两个点的最小值所在点编号相同，那么它们在同一个连通块。

转移如下：

$$dp_{u,x}=\sum_{v\ is\ u's\ son}\min(dp_{v,y}+val_{u,v},dp_{v,x})$$

其中要求 $x,y$ 合法（即点 $u$ 所在连通块的最小值所在点编号可以是 $x$ ，点 $v$ 同理，可以用 $n$ 遍 $\rm dfs$ 预处理出来）。

时间复杂度： $O(n^2\log_2maxh)$ 。

最后放一下标程：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#define inf 0x3f3f3f3f
using namespace std;
template<typename T>void read(T &x){
	x=0;int f(1);char c(getchar());
	for(;!isdigit(c);c=getchar())if(c=='-')f=-f;
	for(; isdigit(c);c=getchar())x=(x<<3)+(x<<1)+(c-'0');
	x*=f;
}
template<typename T>void write(T x){
	if(x<0)putchar('-'),x=-x;
	if(x/10)write(x/10),x%=10;
	putchar(x+'0');
}
const int maxn=808;
struct Edge{
	int v,nt;
	Edge(int v=0,int nt=0):
		v(v),nt(nt){}
}e[maxn*2];
int hd[maxn],num;
void add_edge(int u,int v){
	e[++num]=Edge(v,hd[u]);hd[u]=num;
}
int dep[maxn],pa[maxn][12];
void dfs0(int u,int fa,int dp){
	dep[u]=dp;pa[u][0]=fa;
	for(int i=1;(1<<i)<=dp;++i)
		pa[u][i]=pa[pa[u][i-1]][i-1];
	for(int i=hd[u];i;i=e[i].nt){
		int v=e[i].v;
		if(v==fa)continue;
		dfs0(v,u,dp+1);
	}
}
int lca(int x,int y){
	if(dep[x]<dep[y])swap(x,y);
	for(int t=dep[x]-dep[y],cn=0;t;t>>=1,++cn)
		if(t&1)x=pa[x][cn];
	if(x==y)return x;
	for(int i=11;i>=0;--i)
		if(pa[x][i]!=pa[y][i])
			x=pa[x][i],y=pa[y][i];
	return pa[x][0];
}
int vis[maxn];
void dfs1(int u,int fa){
	for(int i=hd[u];i;i=e[i].nt){
		int v=e[i].v;
		if(v==fa)continue;
		dfs1(v,u);
		vis[u]+=vis[v];
	}
}
int Base,lo[maxn][maxn],h[maxn];
void dfs2(int u,int fa,int ac){
	lo[ac][u]=true;
	for(int i=hd[u];i;i=e[i].nt){
		int v=e[i].v;
		if(v==fa||h[v]<h[ac]||h[v]-h[ac]>Base)
			continue;
		dfs2(v,u,ac);
	}
}
int n,dp[maxn][maxn];
void dfs3(int u,int fa){
	for(int i=1;i<=n;++i)
		if(lo[i][u])dp[i][u]=0;
		else dp[i][u]=inf;
	for(int i=hd[u];i;i=e[i].nt){
		int v=e[i].v;
		if(v==fa)continue;
		dfs3(v,u);
		int mn=inf;
		for(int j=1;j<=n;++j)
			mn=min(mn,dp[j][v]);
		mn+=vis[v];
		for(int j=1;j<=n;++j)
			if(dp[j][u]<inf)
				dp[j][u]+=min(mn,dp[j][v]);
	}
}
int judge(int pos){
	Base=pos;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j)
			lo[i][j]=0;
		dfs2(i,0,i);
	}
	dfs3(1,0);
	int ans=inf;
	for(int i=1;i<=n;++i)
		ans=min(ans,dp[i][1]);
	return ans;
}
int main(){
	int m,k,l=inf,r=-inf;
	read(n),read(m),read(k);
	for(int i=1;i<=n;++i){
		read(h[i]);
		l=min(l,h[i]);
		r=max(r,h[i]);
	}
	for(int i=1;i<n;++i){
		int u,v;
		read(u),read(v);
		add_edge(u,v);
		add_edge(v,u);
	}
	dfs0(1,0,0);
	while(m--){
		int x,y;
		read(x),read(y);
		++vis[x],++vis[y];
		vis[lca(x,y)]-=2;
	}
	dfs1(1,0);
	r=r-l,l=0;
	while(l+1<r){
		int mid=(l+r)>>1;
		if(judge(mid)<=k)
			r=mid;
		else
			l=mid+1;
	}
	if(judge(l)<=k)
		write(l);
	else
		write(r);
	putchar('\n');
	return 0;
}
```

---

## 作者：chenxinyang2006 (赞：7)

之前手滑题解交到 P6592 了，然后还过审了。。。

----------

似乎是个与官方题解不太一样的方法？

首先可以用树上差分算出每条边的权值，然后二分答案 $k$。
   
联通块的权值需要都可以被一个区间 $[x,x + k]$ 包含，那么 $x$ 一定可以是某个 $a_i$。
   
于是设 $dp_{u,x}$ 为以 $u$ 为根的子树已被划分为一些合法联通块，且 $u$ 属于的联通块的权值都在 $[a_x,a_x + k]$ 中的最小代价。
   
对于叶子节点，如果 $a_u$ 在 $[a_x,a_x + k]$ 中，那么 $dp_{u,x}$ 为 $0$，否则为 $\infty$。
   
对于非叶子节点，如果 $a_u$ 不在 $[a_x,a_x + k]$ 中，那么为 $\infty$，否则枚举其所有儿子 $v$，$dp_{u,x} = \sum \min(dp_{v,x},mn_v + cost(u,v))$，$mn_v = \min(dp_{v,k})$，$cost(u,v)$ 是割掉 $(u,v)$ 这条边的代价。

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
#define inf 1000000000
using namespace std;
int n,m,k,len;
int a[805];

int cnt;
int head[805];
struct eg{
	int to,nxt;
}edge[1605];

void make(int u,int v){
	edge[++cnt].to = v;
	edge[cnt].nxt = head[u];
	head[u] = cnt;
}

int to[10][805],deep[805];

void dfs1(int now,int fa){
	deep[now] = deep[fa] + 1;
	to[0][now] = fa;
	for(int i = head[now];i;i = edge[i].nxt){
		if(edge[i].to == fa) continue;
		dfs1(edge[i].to,now);
	}
}

int LCA(int u,int v){
	if(deep[u] < deep[v]) swap(u,v);
	for(int i = 9;i >= 0;i--) if(deep[to[i][u]] >= deep[v]) u = to[i][u];
	if(u == v) return u;
	for(int i = 9;i >= 0;i--){
		if(to[i][u] != to[i][v]){
			u = to[i][u];
			v = to[i][v];
		}
	}
	return to[0][u];
}

int cost[805],delta[805];

void dfs2(int now,int fa){
    cost[now] = delta[now];
    for(int i = head[now];i;i = edge[i].nxt){
    	if(edge[i].to == fa) continue;
    	dfs2(edge[i].to,now);
    	cost[now] += cost[edge[i].to];
	}
}

int dp[805][805],mn[805];
vector <int> v;


void dfs3(int u,int fa){
	for(int i = head[u];i;i = edge[i].nxt) if(edge[i].to != fa) dfs3(edge[i].to,u);
	for(int x = 1;x <= n;x++){
		if(a[u] < a[x] || a[u] > a[x] + len) dp[u][x] = inf;
		else dp[u][x] = 0;
	}
	v.clear();
	for(int i = head[u];i;i = edge[i].nxt) if(edge[i].to != fa) v.push_back(edge[i].to);
	mn[u] = inf;
	for(int x = 1;x <= n;x++){
		for(int i = 0;i < v.size();i++){
			dp[u][x] += min(dp[v[i]][x],mn[v[i]] + cost[v[i]]);
		}
		mn[u] = min(mn[u],dp[u][x]);
	}
}

int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i <= n;i++) scanf("%d",&a[i]);
	for(int i = 1;i < n;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		make(u,v);make(v,u);
	}
	dfs1(1,0);
	for(int i = 1;i <= 9;i++){
		for(int j = 1;j <= n;j++){
			to[i][j] = to[i - 1][to[i - 1][j]];
		}
	}
	for(int i = 1;i <= m;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		int d = LCA(x,y);
		delta[x]++;delta[y]++;
		delta[d] -= 2;
	}
	dfs2(1,0);
    int x = 1000000000;
	for(int i = 30;i >= 0;i--){
		if(x < (1 << i)) continue;
		len = x - (1 << i);
		dfs3(1,0);
		if(mn[1] <= k) x -= 1 << i;
	}
	printf("%d\n",x);
	return 0;
}
```


---

## 作者：Dtw_ (赞：0)

## 题意
你可以把整棵树断成几个连通块，全局权值为每个联通块的最大值减掉最小值的最大值。

你断的边的权值不能超过 $k$，求全局权值最小是多少。

## Solution
考虑到权值只和每个连通块的最大权值有关，所以直接二分答案，那么接下来问题转化为：你要断掉一些边，使得每个连通块内的最大值减最小值 $\leq$ 某数，求断的边的权值和的最小值。

先考虑暴力 dp。

设 $f_{u,i,j}$ 表示以点 $u$ 为根的子树中最大值为 $i$，最小值为 $j$，此时断的边的权值和是多少。

那么转移就直接枚举 $f_{v,k,t}$ 转移即可。

我们可以记录最大最小值的下标是啥，那么 $i,j$ 就是 $O(n)$ 级别的了。

时间复杂度 $O(n^3 \log V)$。

那么如何优化呢？

经典思路就是通过某些限制，把不合法的情况去除，从而减少状态数。

我们只需要记 $f_{u,i}$ 表示以点 $u$ 为根的子树中最小值的编号为 $i$。

考虑我们的最大值减最小值不能超过 $mid$，那么我们可以限制一些 $f$ 的值为 $\text{inf}$ 那么就不会从这些不合法的状态转移了。具体的我们可以开 $mn_{i,j}$ 表示以 $i$ 点为根的子树内 $j$ 是否是最小值的编号，并且 $i$ 的值和最小值之差 $\leq mid$。

如果合法的话，那么 $f_{i,j}$ 的值就是 $0$，否则为 $\text{inf}$。

$$f_{u,i} = \sum_{v\in son_u} \min(f_{v,j} + dis(u, v), f_{v,i})$$

最终如果 $\min_{i = 1}^n f_{1,i} \leq mid$ 那这个 $mid$ 就合法。

时间复杂度 $O(n^2\log V)$。

## Code

```cpp
#include <bits/stdc++.h>

using namespace std;

#define pii pair<int, int>

#define fi first
#define se second

#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);

const int N = 8e2 + 10, inf = 0x3f3f3f3f;

using ll = long long;

int n, m, k, a[N], f[N][11], dep[N], s[N];
ll dp[N][N];
bool mn[N][N];

vector<int> e[N];

void dfs(int u, int fa)
{
    dep[u] = dep[(f[u][0] = fa)] + 1;
    for (auto v : e[u])
    {
        if (v == fa) continue;
        dfs(v, u);
        s[u] += s[v];
    }
}

int LCA(int x, int y)
{
    if (dep[x] < dep[y]) swap(x, y);
    for (int i = 10; i >= 0; i--) if (dep[f[x][i]] >= dep[y]) x = f[x][i];
    if (x == y) return x;
    for (int i = 10; i >= 0; i--) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];
    return f[x][0];
}

int lim;

void dfs2(int u, int fa, int top)
{
    mn[u][top] = true;
    for (auto v : e[u])
    {
        if (v == fa || a[v] < a[top] || a[v] - a[top] > lim) continue;
        dfs2(v, u, top);
    }
}

void dfs3(int u, int fa)
{
    for (int i = 1; i <= n; i++) dp[u][i] = (mn[u][i] ? 0 : inf);
    for (auto v : e[u])
    {
        if (v == fa) continue;
        dfs3(v, u);
        ll ans = inf;
        for (int i = 1; i <= n; i++) ans = min(ans, dp[v][i]);
        ans += s[v];
        for (int i = 1; i <= n; i++) dp[u][i] += min(ans, dp[v][i]);
    }
}

bool check(int x)
{
    lim = x;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++) mn[j][i] = false;
        dfs2(i, 0, i);
    }
    dfs3(1, 0);
    ll ans = inf;
    for (int i = 1; i <= n; i++) ans = min(ans, dp[1][i]);
    return ans <= k;
}

int main()
{
    fst
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1, u, v; i < n; i++) cin >> u >> v, e[u].push_back(v), e[v].push_back(u);
    dfs(1, 0);
    for (int j = 1; j <= 10; j++) for (int i = 1; i <= n; i++) f[i][j] = f[f[i][j - 1]][j - 1];
    for (int i = 1, u, v; i <= m; i++) cin >> u >> v, s[u]++, s[v]++, s[LCA(u, v)] -= 2;
    dfs(1, 0);
    int l = 0, r = 1e9, res = 0;
    while (l <= r)
    {
        int mid = (l + r) / 2;
        if (check(mid)) r = (res = mid) - 1;
        else l = mid + 1;
    }
    cout << res;
    return 0;
}
```

---


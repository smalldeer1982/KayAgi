# [蓝桥杯 2018 国 A] 采油

## 题目描述

LQ 公司是世界著名的石油公司，为世界供应优质石油。

最近，LQ 公司又在森林里发现了一大片区域的油田，可以在这个油田中开采 $n$ 个油井。

LQ 公司在这 $n$ 个油井之间修建了 $n-1$ 条道路，每条道路连接两个油井，路径中间不会路过任何油井，而且这些道路将所有油井连通。

建立油井的时候需要使用一台大型设备，运输起来非常麻烦，LQ 公司准备在其中的一个油井位置建立一个空运站，先将设备空运到空运站，之后每次经过他们建立的道路来运输这个大型设备以建立不同的油井，当油井建立完毕后再从空运站将大型设备运走。

为了减少运输的麻烦，公司要求大型设备在道路上运输的总路程是最短的。

在建立油井和采油的过程中需要花费一些人力，第 $i$ 个油井需要花费 $B_i$ 个人，而一旦油井建成，就需要 $S_i$ 个人一直坚守在油井上进行维护。

当然，如果一个人参与了油井的建设，他可以直接留下来维护油井，或者参与下一个油井的建设，但是在维护油井的人不能再参加后续油井的建设了。

现在 LQ 公司想知道，大型设备运输的总路径长度最短是多少？在保证总路径长度最短的情况下，LQ 公司至少需要花费多少人力才能完成所有油井的建立与维护。


## 说明/提示

**【样例解释 2】**

有两种方案达到最优。

方案一：在油井 $2$ 建立空运站，先建立油井 $2$，再将大型设备运输到油井 $1$ 建立油井 $1$，最后将大型设备运回油井 $2$。

方案二：在油井 $1$ 建立空运站，先将大型设备运输到油井 $2$ 建立油井 $2$，再将大型设备运送到油井 $1$ 建立油井 $1$。

**【数据范围】**

对于 $20\%$ 的数据：$n$ 不超过 $10$；

另外 $20\%$ 的数据：每个油井最多和两个油井之间有道路直接连接；

另外 $10\%$ 的数据：有 $n-1$ 个油井只有一条道路与其他油井连接；

对于 $100\%$ 的数据：$1\le n\le10^5$，$B$、$S$、$c$ 均为不超过 $10000$ 的正整数。

时限 1 秒, 256M。蓝桥杯 2018 年第九届国赛

## 样例 #1

### 输入

```
6
3 10 20 7 15 9
2 6 10 4 8 7
1 9
1 2
2 5
3 4
3 7```

### 输出

```
54 38```

## 样例 #2

### 输入

```
2
10 20
15 15
1 8```

### 输出

```
16 30```

# 题解

## 作者：lucas_salt (赞：12)

# P8677 [蓝桥杯 2018 国 A] 采油 题解

#### 第一问
这一问是非常简单的，容易想到只要每条边只在从父节点走向子节点和从子节点走回父节点时被遍历，第一问的答案就是  $ \sum_{i=1}^{n-1} b_{i} \times2 $，即所有边权和的二倍。

第一问的主要用途其实是限制第二问的行动路径。

#### 第二问
由第一问要求走最短路程，钻井的工作人员每进入一棵子树，就必须把该子树内所有油田都建上油井，才可离开此子树回到父节点。

发现了什么？每棵子树都可以当作子问题处理（类似树形 DP，将此子树化为一个“油田”。

我们只需要求出在每棵子树建造钻井需要花费的人力 $ B $，和此棵子树留下了多少人维护 $ S $，就可以实现。

转移过程考虑贪心。在两层之间，可以任意选择进入子树和在目前的根节点建立油井的顺序，我们要先在  $ B_{i}-S_{i} $  较大的油田（或已 DP 的子树，可看作一个大“油田”）建油井，正确性从后面的递推式可以看出来。

接下来是贪心的实现过程，我使用的是递归（拓扑排序当然也可）。

先递归自己的每棵子树，将它化为一个“油田”，并将它们的  $ B $  和  $ S $  记到数组（我用的 vector）中，便于接下来排序。

```cpp
for (int i=head[u];i;i=e[i].nex)
{   
       if (e[i].to==fa)    continue; //防止走回父节点
       func(e[i].to,u);
       a[u].push_back(a[e[i].to][0]);
}
sort(a[u].begin(),a[u].end(),cmp);
```

求值部分看代码，我定义了  $ C $  表示  $ B-S$，没有继续存  $ S $，你直接用  $ S $  也可。

```cpp
int ansb=0,nc=0; //ansb 表示处理到现在已经需要的人力，nc 表示目前剩余的人力
for (int i=0;i<a[u].size();i++)    //对于每个“油田”
{
    ansc+=a[u][i].b-a[u][i].c; //这里是为了求 ansc 作准备，可以忽略一会再看
    if(nc<a[u][i].b)  ansb+=a[u][i].b-nc,nc=a[u][i].c; //剩余人数不满足此油田要求，加人力
    else    nc-=a[u][i].b-a[u][i].c; //满足要求只需要留下人维护
}
ansc=ansb-ansc; //求真正的 ansc
a[u][0].b=ansb,a[u][0].c=ansc; //此子树处理完
```

#### 注意

-  $ B_{i} $  不一定大于  $ S_{i} $，此时将  $ B_{i}=S_{i}$。
- 以  $ C $  最小或最大的点为根节点。

#### 完整代码，不太优美
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 100004
struct node{
	int b,s,c;
};
bool cmp(node x,node y){return x.c>y.c;}
struct edge{
    int to,nex;
}e[N<<1];
int head[N];
vector<node> a[N];
void func(int u,int fa)
{
    int ansc=0;
    for (int i=head[u];i;i=e[i].nex)
    {   
        if (e[i].to==fa)    continue;
        func(e[i].to,u);
        a[u].push_back(a[e[i].to][0]);
    }
    sort(a[u].begin(),a[u].end(),cmp);
    int ansb=0,nc=0;
    for (int i=0;i<a[u].size();i++)
    {
        ansc+=a[u][i].b-a[u][i].c;
        if(nc<a[u][i].b)  ansb+=a[u][i].b-nc,nc=a[u][i].c;
        else    nc-=a[u][i].b-a[u][i].c;
    }
    ansc=ansb-ansc;
    a[u][0].b=ansb,a[u][0].c=ansc;
    return;
}
signed main()
{
  int n;
  node tmp;
  cin>>n;
  for (int i=1;i<=n;i++) a[i].push_back(tmp),scanf("%d",&a[i][0].b);
  int mc=0,p;
  for (int i=1;i<=n;i++)
  {
  	scanf("%d",&a[i][0].s);
   	a[i][0].c=max(a[i][0].b-a[i][0].s,0);
   	if(a[i][0].c>mc)mc=a[i][0].c>mc,p=i;
   	a[i][0].b=max(a[i][0].b,a[i][0].s);
  }
 int nu,nv,nw,w=0;
 for (int i=1;i<=n-1;i++)
 {
	scanf("%d %d",&nv,&nw);
    w+=nw,nu=i+1;
	e[(i<<1)-1].to=nv,e[(i<<1)-1].nex=head[nu],head[nu]=(i<<1)-1;
	e[i<<1].to=nu,e[i<<1].nex=head[nv],head[nv]=i<<1;
 }
 cout<<w*2<<' ';
 func(p,0);
 cout<<a[p][0].b;
}
```

---

## 作者：破壁人罗辑 (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P8677)

## 解题思路

因为给出的图总共 $n$ 个节点和 $n-1$ 条边，又因为图是联通的，所以显然是一棵树。

### 问题一：最短路程

显然，不管将空运站设置在哪个节点，因为最终遍历所有节点后设备都要返回空运站，所以树上的每一条路都要经过两次。

输出树上所有边长度的两倍即可。

### 问题二：人员分配

因为第 $i$ 个站点建设完成后一定需要 $S_i$ 个人留守，所以无论怎样一个站点都需要消耗 $S_i$ 个人力，当遇到 $B_i<S_i$ 的情况时可以令 $B_i=S_i$，对答案无影响。接下来的讨论全部认为 $B_i\geq S_i$。

先考虑只有一个站点的情况，很容易得出消耗人力为 $B_i$。

再考虑有两个站点的情况，不妨设 $B_1-S_1\geq B_2-S_2$，如果采用先 $1$ 后 $2$ 的顺序则总消耗为 $S_1+\max(B_2,B_1-S_1)=\max(S_1+B_2,B_1)$，如果采用先 $2$ 后 $1$ 的顺序则总消耗为 $S_2+\max(B_1,B_2-S_2)=\max(S_2+B_1,B_2)$，又因为 $B_1+S_2\geq B_2+S_1$，所以有两个站点的情况下把 $B_i-S_i$ 大的放在前面一定最优。

所以我们如果有两个站点且站点参数满足 $B_1-S_1\geq B_2-S_2$，那么在不改变最终答案的情况下我们可以把它缩为一个站点，新站点的参数为 $S=S_1+S_2,B=\max(S_1+B_2,B_1),B-S=\max(B_1-S_1-S_2,B_2-S_2)\in[B_2-S_2,B_1-S_1)$。

如果有三个站点，不妨设 $B_1-S_1\geq B_2-S_2\geq B_3-S_3$，先对 $1,2$ 进行缩点再缩 $3$ 的情况下三个站点形成的新站点的参数为 $S=S_1+S_2+S_3,B=\max(S_1+S_2+B_3,S_1+B_2,B_1)$，先对 $2,3$ 进行缩点再缩 $1$ 的情况下三个站点形成的新站点的参数为 $S=S_1+S_2+S_3,B=\max(S_1+\max(S_2+B_3,B_2),B_1)=\max(S_1+S_2+B_3,S_1+B_2,B_1)$，先对 $1,3$ 进行缩点再缩 $2$ 的情况下三个站点形成的新站点的参数为 $S=S_1+S_2+S_3,B=\max(S_1+S_3+B_2,S_1+B_3,B_1)$，可以发现先缩 $1,2$ 和先缩 $2,3$ 两种方法得出的结果是相同的，都优于先缩 $1,3$ 的方法。也就是说，多个站点进行缩点时按照单调顺序进行缩点得到的是最优解。

再考虑只有一棵有 $n$ 个站点的深度为 $1$ 的树的情况（根节点的深度视为 $0$）。如果把空运站放在树根，不管如何安排顺序都可以做到每条边只经过两次，所以不妨设 $S_i+B_i\geq S_{i+1}+B_{i+1}$，则使用上述的缩点方法可以发现整棵树可以缩成一个点 $S=\sum_{i=1}^nS_i,B=\max\left(B_j+\sum_{i=1}^{j-1}S_i\right)$。

再考虑更一般的树的情况。对于每一个节点，我们可以知道要满足路径最短的情况下这个节点的每个子树必须连续完成建设，不能在某一个子树未建设满的情况下开启其他站点的建设。所以我们可以把这个节点的每一个子树进行缩点，然后将每一个子树缩成的点和自身一起排序，按 $S_i+B_i$ 递减的情况进行缩点。最后将整棵树缩成一个点，这个点的 $B$ 值即为所求。可以使用深度优先搜索来写。

**注意**：深度优先搜索开始的根节点应该是树上 $S+B$ 的值最大（或最小）的一个节点。取 $S+B$ 的值最大（或最小）的节点为根时它会被放在第一个（或最后一个）进行合并，而如果任意取一个节点进行合并时则不一定。

## AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct tr{
	int s,b;
	tr():s(0),b(0){}
	tr& operator+=(const tr &x){
		b=max(b,s+x.b);s+=x.s;return *this;
	}
	bool operator<(const tr &x)const{return b+x.s>s+x.b;}
}t[100001];
int to[300002],nxt[300002];bool vis[100001];
tr dfs(int n){
	vector<tr> v;v.push_back(t[n]);vis[n]=1;
	for(int i=nxt[n];i;i=nxt[i])if(!vis[to[i]])v.push_back(dfs(to[i]));
	tr r;sort(v.begin(),v.end());
	for(auto i:v)r+=i;
	return r;
}
int main(){
	int n,ans=0;scanf("%d",&n);int tmin=1; 
	for(int i=1;i<=n;i++)scanf("%d",&t[i].b);
	for(int i=1;i<=n;i++){scanf("%d",&t[i].s);t[i].b=max(t[i].b,t[i].s);if(t[i]<t[tmin])tmin=i;}
	for(int i=1;i<n;i++){
		int t,w;scanf("%d%d",&t,&w);
		to[n+(i<<1)-1]=i+1;nxt[n+(i<<1)-1]=nxt[t];nxt[t]=n+(i<<1)-1;
		to[n+(i<<1)]=t;nxt[n+(i<<1)]=nxt[i+1];nxt[i+1]=n+(i<<1);
		ans+=w;
	}
	printf("%d %d",ans<<1,dfs(tmin).b);
	return 0;
}
```

---

## 作者：yyz1005 (赞：3)

神奇的性质题。

首先注意到 $B_i$ 可以变为 $\max (B_i,S_i)$。

首先对于问题一，显然可以通过一般遍历方式做到 $2 \sum w_{edge}$。

对于问题二，我们考虑一个节点与其儿子。

注意到要满足路径最短的情况下这个节点的每个子树必须已经完成。

我们考虑类似于树形 dp 的方式来讨论这个问题。

讨论一个基本的情况，一个节点与 $k$ 个儿子。

讨论其消耗的最小人数 $C$。

$k=0$ 时 $C = B_i$。

$k = 1$ 时 此时有两个站点 $x(S_x,B_x),y(S_y,B_y)$。

先进行 $x$ 的建设 $C_x = \max(B_x,S_x+B_y)$，否则 $C_y = \max(B_y,S_y+B_x)$。

不妨设 $S_x+B_y > S_y+B_x (*)$，此时有 $C_x>C_y$。

注意到 $(*) \Leftrightarrow B_y-S_y>B_x-S_x$。也就是说先处理 $B_i-S_i$ 较大的点是更优的。

事实上，该部分显然可以用数学归纳法推广至 $k \in N^*$。

首先，我们考虑一种缩点。

以 $k = 1$ 为例，对于相连的节点 $x(S_x,B_x),y(S_y,B_y),B_x-S_x \ge B_y-S_y$ 可以变为 $z(S_z = S_x+S_y,B_z = \max(S_x+B_y,B_x))$。

应当注意到 $B_x-S_x \ge B_z-S_z \ge B_y-S_y$。

对于 $k = K$ 的情况：

首先设 $B_i-S_i$ 最小的一个节点为根，显然选取当前 $B_i-S_i$ 最小的一个节点来合并，就能变为 $k = K-1$ 的情况。遂数归可证。

于是，选取 $B_i-S_i$ 最小的为根深搜一样的处理就完了。

[Code](https://www.luogu.com.cn/paste/0ox51xfm)

---

## 作者：makerlife (赞：2)

### Solution

第一问显然最优情况下答案为边权和的两倍。

考虑第二问，对于一个点 $u$，至少需要耗费 $S_u$ 的人。

首先认为 $B_u\geq S_u$，因为即使 $B_u<S_u$，该节点也需要 $S_u$ 的人。

若只有一个节点，那么耗费的人显然为 $B_u$；

若有两个节点，不妨设为 $x$ 和 $y$，且 $B_x-S_x>B_y-S_y$，即 $x$ 剩下的人数比 $y$ 多，那么感性理解肯定要先走 $x$，才能充分发挥剩余的人。试图证一下，先 $x$ 后 $y$ 的总花费为 $\max\{B_x, B_x+B_y-(B_x-S_x)\}=\max\{B_x, B_y+S_x\}$，则先 $y$ 后 $x$ 的总花费为 $\max\{B_y, B_x+S_y\}$，将上面的式子移项可得 $B_y+S_x<B_x+S_y$，结论得证；

将结论推广到同一层上有 $k$ 个节点，可以通过两两依次缩点的形式转化为两个节点。

再考虑更一般的情况，在满足第一问的限制下，即按照最短路径，一定是先遍历完每个子树最短。所以搜到一个点时，先将这个点为根的所有子树缩点，按照剩余人数排序，递归继续缩点。

注意搜索时需要从 $B-S$ 最大的点开搜。

### Core Code

```cpp
struct node {
    int b, s;
    bool operator<(const node &x) const {
        return b - s > x.b - x.s;
    }
    node operator+(const node &x) const {
        node res;
        res.b = max(b, s + x.b), res.s = s + x.s;
        return res;
    }
}a[N];
node dfs(int u, int fa) {
    vector<node> p;
    p.push_back(a[u]);
    for (auto v : e[u]) {
        if (v == fa) continue;
        p.push_back(dfs(v, u));
    }
    node res;
    res.b = res.s = 0;
    sort(p.begin(), p.end());
    for (auto v : p) res = res + v;
    return res;
}
int main() {
    n = read();
    int sum = 0;
    int maxn = 0, maxpos = 1;
    for (int i = 1; i <= n; i++) {
        a[i].b = read();
    }
    for (int i = 1; i <= n; i++) {
        a[i].s = read();
        a[i].b = max(a[i].b, a[i].s);
        if (a[i].b - a[i].s > maxn) {
            maxn = a[i].b - a[i].s;
            maxpos = i;
        }
    }
    for (int i = 1; i < n; i++) {
        int v = read(), w = read();
        e[i + 1].push_back(v);
        e[v].push_back(i + 1);
        sum += w;
    }
    cout << sum * 2 << " " << dfs(maxpos, 0).b << '\n';
    return 0;
}
```

---


# [传智杯 #5 初赛] I-不散的宴会

## 题目背景

学校正在组织宴会。

莲子和梅莉发现，学校的结构十分复杂。学生之间存在着部门与上司的关系。每一个部门内部，都呈现出连成一条线的上司关系。一个部门内等级最高的学生，又可能受限于另外某个部门内的某个学生。

莲子和梅莉同样参加了宴会。但是她们对参加学生有自己的评判。例如，她对某些部门比较喜欢，对另一些部门则不感兴趣。同时对位居不同等级的学生同样有着不同的看法。

正如某个经典问题所描述的一样，每个学生都不希望与自己的直接上司共同参加宴会。

梅莉想要知道，最好情况下，有多少个参加宴会的学生是她喜欢的。

## 题目描述

学生社会可以被看作一个排列成等腰直角三角形的节点阵列。该节点阵列共有 $n$ 行，第 $i$ 行共有 $i$ 个节点。我们将第 $i$ 行第 $j$ 列的节点，标号为 $(i,j)$。

- 这些节点具有权值。具体而言，节点 $(i,j)$ 的权值为 $r_i\oplus c_j$，其中 $r$ 和 $c$ 是给定的 $01$ 序列，$\oplus$ 是**二进制异或**操作。
- 这些节点有边相连。具体而言，对于 $1\le i< n$，$1\le j\le i$，会有一条边连接 $(i,j)$ 和 $(i+1,j)$。此外，对于 $2\le i\le n$，还会有边连接 $(i,i)$ 和 $(i-1,a_i)$。其中 $a$ 是给定的序列。

现在你需要从这些节点中，选出一些节点，使得这些节点间**两两不存在边相连**，最大化选出来的节点的**权值之和**。

如下图所示，是 $n=8$ 的一个例子。黑色节点权值为 $1$，白色节点权值为 $0$。

**注**：图片中只象征性地给出了部分 $r_i$ 和 $c_i$ 的值。该图片上实际 $\def\t{,\allowbreak}r=\{1\t 1\t 0\t 1\t 0\t 0\t 0\t 1\}\t c=\{0\t 0\t 1\t 0\t 1\t 1\t 0\t 0\}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/582ii4nj.png)

## 说明/提示

### 样例解释

一种可能的选择方案如下图所示。橘红色方块表示选中的节点。

![](https://cdn.luogu.com.cn/upload/image_hosting/gpwn8ekv.png)

### 数据范围及约定

对于全部数据，保证 $1\le n\le 10^6$，$r_i\in\{0,1\}$，$c_i\in\{0,1\}$，$1\le a_i<i$。

## 样例 #1

### 输入

```
8
1 1 0 1 0 0 0 1
0 0 1 0 1 1 0 0
1 1 3 2 2 1 4```

### 输出

```
14
```

# 题解

## 作者：离散小波变换° (赞：4)

### 题解

压轴题。

容易发现这是一棵树。具体可以用归纳法。设前 $i$ 行组成一棵树，那么第 $i+1$ 行内每个点都向第 $i$ 行某个点连了边，那肯定前 $i+1$ 行也是一棵树了。

容易发现这树很特殊。它的点数达到了 $n^2$ 级别，但是第 $i$ 列整个就是串在一起的形成链的样子。可以证明，整棵树可以被划分为 $\mathcal O(n)$ 个点和 $\mathcal O(n)$ 条链。

**定义**：我们选出树上一些点作为**关键点**。这些点包括第 $1$ 层的所有点、第 $n$ 层的所有点、其他所有**度数**为 $3$ 的点。

![](https://cdn.luogu.com.cn/upload/image_hosting/d9ztpaj5.png)

图中标上红星的即为关键点。

**断言**：关键点的个数是 $\mathcal O(n)$ 级别的。

**证明**：考虑前 $i$ 行，$i\ge 2$。容易发现，第 $i$ 行所有点的度数应该恰好为 $1$。当加入第 $i+1$ 行的所有点以及边时，第 $i+1$ 行前 $i$ 个点连的边使得第 $i$ 行所有点度数都变成了 $2$，而第 $i+1$ 行第 $i+1$ 个点连的边使得第 $i+1$ 行恰好有一个点度数变成了 $3$，这个点就成了关键点。那么，第 $2\sim (n-1)$ 行应该均恰好有一个特殊点。再加上第 $1$ 行与第 $n$ 行的点，特殊点的总个数就是 $\mathcal O(n)$ 级别的了。

除了关键点，其他所有点的度数均为 $2$（读者自证不难）。于是别的点肯定会在某条链上。沿着链走，走到的两端肯定都是关键点。于是，我们可以把一条链抽象成连接两个关键点的「边」，这个「虚树」节点个数为 $\mathcal O(n)$，那么它的边的个数肯定也是 $\mathcal O(n)$。

把虚树建好后，可以用非常经典的树上最大点权独立集的动态规划做法在虚树上跑。我们关心的是两个关键点之间应该怎么转移。换言之，我们需要知道连接两个关键点的链它的贡献怎么计算。

记 $f_u,g_u$ 分别表示，在选择/不选择虚树上的节点 $u$ 的情况下，子树 $u$ 能取得的最大点权独立集的值。

假设有两个关键点 $u,v$，他们之间通过链 $s=\{p_1,p_2,\cdots p_t\}$ 连接。那么 $v$ 对 $f_u$ 的贡献是 $\max\{\operatorname{val}(p_2,p_3,\cdots,p_t)+g_v,\operatorname{val}(p_2,p_3,\cdots,p_{t-1})+f_v\}$，$v$ 对 $g_u$ 的贡献是 $\max\{\operatorname{val}(p_1,p_2,\cdots,p_t)+g_v,\operatorname{val}(p_1,p_2,\cdots,p_{t-1})+f_v\}$。其中 $\operatorname{val}(p_1,p_2,\cdots,p_t)$ 表示序列 $p$ 在不能选择相邻元素的情况下可以取得的最大点权独立集。我们需要知道，$s$ 序列在「首项/末项」「能选/不能选」共 $4$ 种组合的情况下，分别计算出来的最大点权独立集是多少。

注意一个重要性质：

- 对于每一条连接了两个关键点的链，这条链上的点（不包含顶头的两个关键点），肯定在同一列上。

这同样容易证明。由于该树特殊的构造方法，对于 $j<i$，非特殊点 $(i,j)$ 肯定与 $(i+1,j)$ 和 $(i-1,j)$ 相连，那么这三个点肯定在同一列；对于 $(i,i)$，它向上连接的点肯定是关键点，向下连接的点肯定与它在同一列。于是容易发现每条链上的非特殊点必然在同一列。

那么一条链可以被映射到 $01$ 序列 $r$ 上的一段区间 $[a,b]$。假设这个链在第 $k$ 列。如果 $c_k=0$，那么这个区间内每个位置的权值就是 $r_a,r_{a+1},\cdots,r_b$；如果 $c_k=1$，那么这个区间内每个位置的权值就是 $\neg r_a,\neg r_{a+1},\cdots,\neg r_b$。

问题转化为了，查询对 $r$ 序列或者 $\neg r$ 序列（这两个都是 $01$ 序列）做**区间最大点权独立集**的结果。

对于 $01$ 序列，计算最大点权独立集是可以采用贪心思想的。比如，对于长度为 $2k$ 的全 $1$ 段，它的最大点权独立集显然是 $k$；对于长度为 $2k+1$ 的全 $1$ 段，它的最大点权独立集显然是 $k+1$。对于含有 $0$ 的序列，总是可以以 $0$ 作为分隔符划分出各种全 $1$ 段，分别求和再相加就行。

那么怎么对 $01$ 序列做区间最大点权独立集呢？

我们预处理两个东西：

- $h_i$，表示仅考虑前 $i$ 个元素，算出的最大点权独立集的结果。
- $p_i$，表示第 $i$ 个元素所处的全 $1$ 段最后一个 $1$ 的位置。特别地，若 $i$ 位置是 $0$，那么 $p_i=i$。

容易预处理上面的两个数组。现在要计算 $[l,r]$ 区间的最大点权独立集，那么结果就是：

$$h_r-h_{\min\{r,p_l\}}+\lfloor(\min\{r,p_l\}-l)/2+1\rfloor$$

**解释**：使用做差的方法计算出 $[\min\{r,p_l\}+1,r]$ 这一段的最大点权独立集的值，再加上 $[l,\min\{r,p_l\}]$ 这个全 $1$ 段的贡献。

最后讲讲怎么建虚树。维护 $F_i$ 表示第 $i$ 列从最下面往上走走到的关键点的编号。当 $(i,i)$ 位置往 $(i-1,a_i)$ 连边时，$(i-1,a_i)$ 变成了第 $a_i$ 列最靠下的关键点，作为虚树的一员它首先要和 $F_{a_i}$ 连上边，然后更新 $F_{a_i}$ 的值。因为最后一行全部都会是关键点，所以最后再将它们变成关键点与 $F_i$ 连边即可。

于是这题就做完了。

### 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l, r, i) for(int i = l, END##i = r;i <= END##i;++ i)
#define dn(r, l, i) for(int i = r, END##i = l;i >= END##i;-- i)
using namespace std;
typedef long long i64;
const i64 INF = 1e18;
int n;
int qread(){
    int w=1,c,ret;
    while((c = getchar()) >  '9' || c <  '0') w = (c == '-' ? -1 : 1); ret = c - '0';
    while((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + c - '0';
    return ret * w;
}
const int MAXN = 1e6 + 3;
const int MAXM = 2e6 + 3;
int R[MAXN], C[MAXN], A[MAXN], F[MAXN], G[MAXM], W[MAXM], o = 0;
int X[MAXM]; i64 U[MAXM][4];
int Y[MAXM]; i64 V[MAXM][4];
int P0[MAXN], Q0[MAXN], P1[MAXN], Q1[MAXN];
int value(int w){return w % 2 == 1 ? w / 2 + 1 : w / 2;}
void calc(int l, int r, i64 &w, bool t){    // [l, r] 区间
    if(r - l + 1 ==  0){w = 0   ; return;}
    if(r - l + 1 == -1){w = 0   ; return;}
    if(r - l + 1 == -2){w = -INF; return;}
    if(t == false){
        int u = min(Q0[l], r); w = P0[r] - P0[u] + ( R[l] == 1 ? value(u - l + 1) : 0);
    } else {
        int u = min(Q1[l], r); w = P1[r] - P1[u] + (!R[l] == 1 ? value(u - l + 1) : 0);
    }
}
void calc(int l, int r, i64 O[4], bool t){  // [l + (0~1), r - (0~1)] 区间
    calc(l    , r    , O[0b11], t);
    calc(l    , r - 1, O[0b10], t);
    calc(l + 1, r    , O[0b01], t);
    calc(l + 1, r - 1, O[0b00], t);
}
i64 I[MAXM], J[MAXM];   // I 是必须选上，J 是必须不选
void dfs(int u){
    if(X[u] == 0) I[u] = W[u], J[u] = 0; else {
        int l = X[u], r = Y[u]; dfs(l), dfs(r);
        I[u] = W[u]
            + max(U[u][0b00] + I[l], U[u][0b01] + J[l])
            + max(V[u][0b00] + I[r], V[u][0b01] + J[r]);
        J[u] =
            + max(U[u][0b10] + I[l], U[u][0b11] + J[l])
            + max(V[u][0b10] + I[r], V[u][0b11] + J[r]);
    }
}
int main(){ 
    n = qread();
    up(1, n, i) R[i] = qread();
    up(1, n, i) C[i] = qread();
    up(2, n, i) A[i] = qread();
    P0[1] = R[1], P1[1] = !R[1];
    up(2, n, i){
        P0[i] = max(P0[i - 1], P0[i - 2] +  R[i]);
        P1[i] = max(P1[i - 1], P1[i - 2] + !R[i]);
    }
    Q0[n] = Q1[n] = n;
    dn(n - 1, 1, i){
        if( R[i] == 0) Q0[i] = i; else
            if( R[i + 1] == 0) Q0[i] = i; else Q0[i] = Q0[i + 1];
        if(!R[i] == 0) Q1[i] = i; else
            if(!R[i + 1] == 0) Q1[i] = i; else Q1[i] = Q1[i + 1];
    }
    up(1, n - 1, i){
        int t = A[i + 1], f = F[t]; // (i, t) 是特殊点
        F[t] = F[i + 1] = ++ o;     // 给特殊点分配编号
        if(f)
            if(X[f]) Y[f] = o, calc(G[f] + 1, i - 1, V[f], C[t]);
            else     X[f] = o, calc(G[f] + 1, i - 1, U[f], C[t]);
        W[o] = R[i] ^ C[t], G[o] = i;
    }
    up(1, n, i){    // 最后一层都是特殊点
        int t = i, f = F[t]; ++ o, W[o] = R[n] ^ C[i];
        if(f)
            if(X[f]) Y[f] = o, calc(G[f] + 1, n - 1, V[f], C[t]);
            else     X[f] = o, calc(G[f] + 1, n - 1, U[f], C[t]);
    }
    dfs(1); printf("%lld\n", max(I[1], J[1]));
    return 0;
}
```

---

## 作者：tmp_get_zip_diff (赞：1)

刚学会虚树，来写一篇题解。

## 题意

有一棵树，在矩阵上可以看作一个直角三角形，除了最后一行，每个点都有一条向下连接的边。

还有 $n-1$ 条附加边，第 $i$ 条连接 $(i,a_i)$ 和 $(i+1,i+1)$。

## 题解

首先[这道题](https://www.luogu.com.cn/problem/P1352)都做过吧，我们回顾一下。

$dp_{i,0/1}$ 代表 $i$ 的子树中，$i$ 选或不选的最大价值。

对于一条 $u \to v$ 的边，$dp_{u,0} = \max(dp_{v,0},dp_{v,1})$，$dp_{u,1} = dp_{v,0}$。

初始 $dp_{i,1}=a_i$。

---

于是乎我们可以按照上面的做法暴力建图，得到一个 $O(n^2)$ 的算法。

然而 $n \le 10^6$，直接死飞。

考虑怎么优化。

由于点权只有 $0$ 或 $1$，也就是说，如果树的形态是一条链，那么选择方式可以**贪心地唯一确定**，同时这条链其中一个异或值是不变的。

怎么贪心呢，首先如果有两端连续 $1$ 的区间被 $0$ 隔开，那么这两段区间不会相互影响，分别计算。于是对于一个长度 $len$，肯定是隔一个选一个，答案为 $\lceil \frac{len}{2} \rceil$。

我们考虑时间浪费在了哪里，因为由于这棵树很多部分都是链，然而我们又对它进行了扫描，这就浪费了时间。

于是虚树就出现了。

我们可以把每一个附加边的起点和最后一层的所有点看作关键点，那么有关键点的个数是等于 $2n-1$ 的。

接着我们发现，我们用关键点把这棵树分成了 $2n-2$ 条链，我们把这些链看成连接两个关键点的**虚树边**，对于这道题没必要建出来。

接着，我们设 $dp_{i,0/1}$ 表示关键点的编号为 $i$，$i$ 的子树中，$i$ 是否选了的最大价值。

那么对于每一条虚树边 $u \to v$，转移需要考虑 $v$ 选不选，对应着这条链的顶端、底端是否可以选到，接着对这条链求出它的贡献即可。

初始 $dp_{i,1}=r_x\ \text{xor}\ c_y$，其中 关键点 $i$ 的坐标是 $(x,y)$。

最后讲一讲怎么求链的贡献，首先预处理前缀和，对于左右端点找到它左或右第一个异或当前 $c_{line}$ 是 $1$ 的第一个点，然后分别计算左边所在的异或后是 $1$ 的块，右边所在的异或后是 $1$ 的块，和中间的块即可。

总时间复杂度 $O(n)$。

---

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 

inline int read()
{
	int x(0),f(1);
	char ch(getchar());
	while(!isdigit(ch))f=(ch=='-')?-1:1,ch=getchar();
	while(isdigit(ch))x=(x<<3)+(x<<1)+(ch-'0'),ch=getchar();
	return x*f;
}

const int N=1e6+5;
int n,r[N],c[N],a[N],pos[N],L[2][N],R[2][N],sum[2][N],cnt[2],dp[N<<1][2],lst[N],lwz[N];

int getdis(int lt,int rt)
{
	return (rt-lt+2)>>1;
}

int solve(int lt,int rt,int k)
{
	if(rt-lt+1<=-2)
		return -1e18;
	if(rt-lt+1<=0) // 重要！因为这里调了 30min 
		return 0;
	k^=1;
	if(r[lt]!=k)
		lt=R[k^1][pos[lt]]+1;
	if(r[rt]!=k)
		rt=L[k^1][pos[rt]]-1;
	if(rt-lt+1<=0)
		return 0;
	int x=pos[lt],y=pos[rt];
	if(x==y)
		return getdis(lt,rt);
	return getdis(lt,R[k][x])+(sum[k][y-1]-sum[k][x])+getdis(L[k][y],rt);
}

signed main()
{
	n=read();
	for(int i=1;i<=n;i++)
		r[i]=read();
	for(int i=1;i<=n;i++)
		c[i]=read();
	for(int i=1;i<=n-1;i++)
		a[i]=read();
	L[r[1]][++cnt[r[1]]]=1;
	pos[1]=1;
	for(int i=2;i<=n;i++)
	{
		int now=r[i],lst=r[i-1];
		if(now!=lst)
		{
			R[lst][cnt[lst]]=i-1;
			sum[lst][cnt[lst]]=sum[lst][cnt[lst]-1]+getdis(L[lst][cnt[lst]],i-1);
			L[now][++cnt[now]]=i;
		}
		pos[i]=cnt[now];
	}
	R[r[n]][cnt[r[n]]]=n;
	sum[r[n]][cnt[r[n]]]=sum[r[n]][cnt[r[n]]-1]+getdis(L[r[n]][cnt[r[n]]],n);
	for(int i=1;i<=n;i++)
	{
		int ip=i+n-1;
		dp[ip][0]=0;
		dp[ip][1]=r[n]^c[i];
		lst[i]=ip;
		lwz[i]=n;
	}
	for(int i=n-1;i>=1;i--)
	{
		int j=lst[a[i]],pos=lwz[a[i]];
		dp[i][0]=0;
		dp[i][1]=(r[i]^c[a[i]]);
		dp[i][0]+=max(solve(i+1,pos-1,c[a[i]])+dp[j][0],solve(i+1,pos-2,c[a[i]])+dp[j][1]);
		dp[i][1]+=max(solve(i+2,pos-1,c[a[i]])+dp[j][0],solve(i+2,pos-2,c[a[i]])+dp[j][1]);
		j=lst[i+1],pos=lwz[i+1]; 
		dp[i][0]+=max(solve(i+1,pos-1,c[i+1])+dp[j][0],solve(i+1,pos-2,c[i+1])+dp[j][1]);
		dp[i][1]+=max(solve(i+2,pos-1,c[i+1])+dp[j][0],solve(i+2,pos-2,c[i+1])+dp[j][1]);
		lst[a[i]]=i;
		lwz[a[i]]=i;
	}
	cout<<max(dp[1][0],dp[1][1]);
	return 0;
}
```

---


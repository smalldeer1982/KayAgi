# 排序二叉树

## 题目描述

一个边长为 $n$ 的正三角形可以被划分成 $n^2$ 个小的边长为 $1$ 的正三角形，称为单位三角形。边长为 $3$ 的正三角形被分成三层共 $9$ 个小的正三角形，我们把它们从顶到底，从左到右以 $1\sim 9$ 编号，见下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/mzls92cx.png)

四个这样的边长为 $n$ 的正三角形可以组成一个三棱锥。我们将正三棱锥的三个侧面依顺时针次序（从顶向底视角）编号为 $A,B,C$，底面编号为 $D$。侧面的 $A,B,C$ 号三角形以三棱锥的顶点为顶，底面的 $D$ 号三角形以它与 $A,B$ 三角形的交点为顶。

![](https://cdn.luogu.com.cn/upload/image_hosting/yyqpdocn.png)

其中 $\tt .$ 表示这个三角形面的 $1$ 号三角形位置，并依次编号下去。

上图为三棱锥展开后的平面图，每个面上标有圆点的是该面的顶，该图中侧面 $A,B,C$ 分别向纸内方向折叠即可还原成三棱锥。我们把这 $A,B,C,D$ 四个面各自划分成 $n^2$ 个单位三角形。

对于任意两个单位三角形，如有一条边相邻，则称它们为相邻的单位三角形。显然，每个单位三角形有三个相邻的单位三角形。现在，把 $1\sim 4n^2$ 里的所有整数分别随机填入四个面总共 $4n^2$ 个单位三角形中。

现在要求你编程求由单位三角形组成的最大二叉搜索树。所谓最大二叉搜索树，是指在所有由单位三角形组成的二叉搜索树中节点最多的一棵树。要求当 $i$ 作为二叉搜索树的一个节点时，$i$ 的儿子（如果有的话）和 $i$ 的父亲（如果有的话）必须与 $i$ 有邻边（三棱锥状态下的邻边，而非展开图的邻边）。

一棵二叉搜索树满足这个节点的左子树得每个值全部小于这个节点，这个节点的右子树的每个值全部大于这个节点。

## 说明/提示

### 样例解释

以下以 $A$ 面为例。记 $f(A,x)$ 表示 $A$ 面的第 $x$ 个单位三角形，以此类推。

$f(A,9)$ 与 $f(D,1)$ 有邻边，$f(A,7)$ 与 $f(D,2)$ 有邻边，$f(A,5)$ 与 $f(D,5)$ 有邻边。

$f(A,1)$ 与 $f(B,1)$ 有邻边，$f(A,4)$ 与 $f(B,2)$ 有邻边，$f(A,9)$ 与 $f(B,5)$ 有邻边。

$f(A,1)$ 与 $f(C,1)$ 有邻边，$f(A,2)$ 与 $f(C,4)$ 有邻边，$f(A,5)$ 与 $f(C,9)$ 有邻边。

以数字 $1$ 为二叉搜索树的根，可以得到节点最多的二叉搜索树为：

![](https://cdn.luogu.com.cn/upload/image_hosting/2y8i07id.png)

### 数据范围

对于 $100\%$ 的数据，$1\leqslant n\leqslant 18$，保证四个面所有单位三角形上填入的数互不相同且都取自 $[1,4n^2]$。

## 样例 #1

### 输入

```
3 
19 33 32 31 29 3 5 4 30 
22 25 20 21 12 24 23 34 35 
14 13 15 26 18 17 8 16 27 
11 10 9 1 28 7 2 6 36```

### 输出

```
17
```

# 题解

## 作者：Gavin·Olivia (赞：11)

首先，我们在相邻的小三角形之间建边，这样问题就转化成了在图内选点，使其为一颗排序二叉树。

对于一个根节点，它的取值范围毫无疑问是[1,4n^2];设它的值为x，那么它的左儿子的取值范围就是[1,x-1],右儿子的取值范围则是[x+1,4n^2]。由此我们可以推知对于任意一个点，若它的取值范围为[a,b]，它的值为x，则它的左儿子取值范围为[a,x-1]，右儿子取值范围为[x+1,b]，接下来就只要去枚举与它相邻的点有没有满足条件的就好。

那么f[i][j][k]数组就表示以值为i的节点为根，取值范围为[j,k]时的最大排序二叉树的节点数。然而这空间复杂度为O[(4n^2)^3]，绝对会爆。怎么办呢？

从上一推论我们能看出，节点i（除根之外）的范围边界之一一定与它的父亲有关，因此我们可以将其中一维数组转化为第几个相邻的点，即f[i][j][k]，j表示第几个相邻的点是它的父亲，k则表示它的另一边界。

具体实现详见代码。
```cpp
#include<bits/stdc++.h>
 using namespace std;
 int n,i,j,k,l,r,ans;
 int ne[1300][3],cnt[1300],f[1300][3][1300],s[5][20][50];
 int read()
{
    int x=0,w=0;char ch=0;
    while (!isdigit(ch)) w|=ch=='-',ch=getchar();
    while (isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return w?-x:x;
}
 void build(int a,int b){ne[a][cnt[a]++]=b; ne[b][cnt[b]++]=a;}
 int dp(int now,int a,int b)//now为当前节点的值，b为父亲的值，a为另一边界
{
    int fa=0; while(ne[now][fa]!=b)fa++;//寻找父亲是相邻的第几个点
    if(f[now][fa][a])return f[now][fa][a];
    int x,y,l=0,r=0;
    if(a>b)x=b+1,y=a; else x=a,y=b-1;
    for(int i=0;i<3;i++) if(i!=fa&&x<=ne[now][i]&&ne[now][i]<=y)
    {
        if (ne[now][i]<now)l=max(l,dp(ne[now][i],x,now));
        else r=max(r,dp(ne[now][i],y,now));
    }
    f[now][fa][a]=l+r+1;
    return f[now][fa][a];
}//记忆话搜索
 int main()
{
    n=read();
    for(i=1;i<=4;i++)
     for(j=1;j<=n;j++)
      for(k=1;k<j+j;k++) s[i][j][k]=read();
    for(i=1;i<=4;i++)
        for(j=2;j<=n;j++)
        {
            for(k=2;k<j<<1;k+=2)
            {
                build(s[i][j][k],s[i][j-1][k-1]); build(s[i][j][k],s[i][j][k-1]);
                build(s[i][j][k],s[i][j][k+1]);
            }
        }
    for(i=1;i<=n;i++)
    {
        build(s[1][i][1],s[3][i][(i<<1)-1]); 
        build(s[2][i][1],s[1][i][(i<<1)-1]);
        build(s[3][i][1],s[2][i][(i<<1)-1]); 
        build(s[4][i][1],s[1][n][2*n-(i<<1)+1]);
        build(s[4][i][(i<<1)-1],s[2][n][(i<<1)-1]); 
        build(s[4][n][(i<<1)-1],s[3][n][2*n-(i<<1)+1]);
    }//建边
    for(i=1;i<=4*n*n;i++)//枚举根
    {
        l=0; r=0;//记录最大左右子树
        for(j=0;j<3;j++)
         if(ne[i][j]<i)l=max(l,dp(ne[i][j],1,i));
         else r=max(r,dp(ne[i][j],4*n*n,i));
        ans=max(ans,l+r+1);
    }
    printf("%d",ans);
    return 0;
}

```

---

## 作者：fervency (赞：4)

~~我会说我在水咕值吗~~

由于本人是**蒟蒻**，有错误请指正！qwq

题意还是很清晰的，其中排序二叉树是指对于每一个有儿子的节点，其左儿子一定小于这个节点，其右儿子一定大于这个节点，我们按照题目要求建图即可（代码中有相应注释）。

但是！！！
对于样例，有两种选择：

- 直接复制粘贴，正确代码输出应该为 $9$；
- 这里提供正确输入格式的样例，其正确答案确实为 $17$；
```
3 
19
33 32 31
29 3 5 4 30
22
25 20 21
12 24 23 34 35
14
13 15 26
18 17 8 16 27
11
10 9 1
28 7 2 6 36
```

读完题来继续处理，对于一个随机二叉树，有什么办法去枚举节点呢？注意到排序二叉树的性质：

1. 对于一节点，其儿子的子树也是排序二叉树。

2. 对于一节点，其左右子树不交叉，满足枚举时无后效性（即左子树对右子树无影响）。

同时，若要使树最大，那么左右子树都要是最大的，局部最优满足全局最优，这就是妥妥的 DP 了（在图中还是记忆化更简单一些）。

知道是 DP 后我们来找状态，考虑到 $n$ 的范围在 $[1,18]$，$4n^2$ 也不会超空间，所以可以用桶的思想，结合排序二叉树性质：

若一个点范围是 $l$ 到 $r$，此时枚举到 $num$ 节点：

那么其左儿子范围是 $l$ 到 $num-1$，右儿子范围是 $num+1$ 到 $r$。已经确定父亲节点的时候，只要枚举周围 $3$ 个相邻单位三角形就可以确定了，所以空间复杂度是  $n^2$ 级别的。

在搜索的时候，我们要传下去：

$lson$：当前节点（靠与父亲连起来的边实现）、由父亲确定的下界、由本节点（可理解成区间 DP 中的断点）确定的上界；

$rson$：当前节点（靠与父亲连起来的边实现）、由父亲确定的上界、由本节点（可理解成区间 DP 中的断点）确定的下界。

其余详见代码~

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,mp[5][20][40],f[2022][4];
int vis[2022][4][2022],ans,tot[2022];
bool e[2022][2022];
int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
void add_edge(int u,int v)
{
	if(!e[u][v])
	{
		e[u][v]=1;
		f[u][++tot[u]]=v;
	}
	if(!e[v][u])
	{
		e[v][u]=1;
		f[v][++tot[v]]=u;
	}
}
int dp(int u,int ll,int rr)
{
	int fa=1;//father 
	while(f[u][fa]!=rr) fa++;
	if(vis[u][fa][ll]>0) return vis[u][fa][ll];
	int l,r;
	//左子树边界  右子树边界 
	if(ll<=rr) l=ll,r=rr-1;
	else l=rr+1,r=ll;
	int lson=0,rson=0;
	for(int k=1;k<=3;k++)
	{
		//找两个符合排序二叉树条件的儿子 
		if(k!=fa&&l<=f[u][k]&&f[u][k]<=r)
		{
			if(f[u][k]<u) lson=max(lson,dp(f[u][k],l,u));
			else rson=max(rson,dp(f[u][k],r,u));
		}
	}
	vis[u][fa][ll]=lson+rson+1;
	return vis[u][fa][ll];
}
void dfs()
{
	for(int i=1;i<=4*n*n;i++)
	{
		int lson=0,rson=0;
		for(int j=1;j<=3;j++)
		{
//			分左右子树递归
			if(f[i][j]<i) lson=max(lson,dp(f[i][j],1,i));
			else rson=max(rson,dp(f[i][j],4*n*n,i));
		}
		ans=max(ans,lson+rson+1);//加上根节点
	}
}
signed main()
{
	n=read();
	for(int k=1;k<=4;k++)
	for(int i=1;i<=n;i++)
	for(int j=1;j<=i*2-1;j++)
		mp[k][i][j]=read();//第i行第j个单位三角形 
	
	for(int k=1;k<=4;k++)
	for(int i=2;i<n;i++)
	for(int j=2;j<i*2-1;j++)
	{
		add_edge(mp[k][i][j],mp[k][i][j-1]);
		add_edge(mp[k][i][j],mp[k][i][j+1]);
		if(j&1) add_edge(mp[k][i][j],mp[k][i+1][j+1]);
		else add_edge(mp[k][i][j],mp[k][i-1][j-1]);
	}
	//最后一行
	for(int k=1;k<=4;k++) 
	for(int i=2;i<=n*2-1;i+=2)
	{
		add_edge(mp[k][n][i],mp[k][n][i-1]);
		add_edge(mp[k][n][i],mp[k][n][i+1]);
		add_edge(mp[k][n][i],mp[k][n-1][i-1]);
	}
	//三个侧面的最后一行与底面 
	for(int i=1;i<=n*2-1;i++)
	{
		add_edge(mp[1][n][i],mp[4][n-i/2][1]);
		add_edge(mp[2][n][i],mp[4][i/2+1][(i/2+1)*2-1]);
		add_edge(mp[3][n][i],mp[4][n][n*2-i]);
	}
	//侧楞处相交的单位三角形 
	for(int i=1,j=1;i<=n;i++,j++)
	{
		add_edge(mp[1][i][1],mp[3][i][i*2-1]);
		add_edge(mp[2][i][1],mp[1][i][i*2-1]);
		add_edge(mp[3][i][1],mp[2][i][i*2-1]);
	}
	dfs();
	printf("%lld\n",ans);
	return 0;
}
```

感谢管理员耐心指正（鞠躬orz）

~~（打个广告）~~[欢迎各位大佬踩爆我的博客](https://blog.csdn.net/m0_60137414?spm=1000.2115.3001.5343)

---

## 作者：Leaper_lyc (赞：3)

## 分析

### $O(n^6)$ 做法

设 $f_i$ 表示 $i$ 为子树根，其子孙的值范围在 $[j,k]$ 之间的最大 BST 中结点数。

![](https://cdn.luogu.com.cn/upload/image_hosting/rnsu3efx.png)

然后考虑 $i$ 的邻居，假设邻居为 $a,b,c\in [j,k],j\le i\le k$，且 $a,b< i$ 可以作为左儿子，$c>i$ 可以作为右儿子。

![](https://cdn.luogu.com.cn/upload/image_hosting/zoobcpvp.png)

那么我们就要枚举左儿子填 $a$ 还是 $b$。

容易知道左儿子的范围为 $[j,i-1]$，右儿子的范围为 $[i+1,k]$。

那么转移方程：$f_{i,j,k}=\max\{f_{a,j,i-1},f_{b,j,i-1}\}+f_{c,i+1,k}+1$。

如果可以作为右儿子的有两个，转移同理。

但是这样子是 $O(n^6)$ 的，显然过不去。

### $O(n^4)$ 做法

从上一推论我们能看出，节点 $i$（除了根结点）的范围边界之一一定与它的父亲有关，因此我们可以将其中一维数组转化为第几个相邻的点。

设 $f_{i,j,k}$ 表示第 $j$ 个相邻的点是作为父亲，$k$ 则表示它的另一边界，这样就完事了。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 20;
const int M = 4 * N * N;
int n, m;
int a[5][N][N * 2], cnt[M];
int f[M][5][M], g[M][5], ans = 0;
bitset <N * N * 4> G[M];
void add(int u, int v) {
    if (!G[u][v])
        G[u][v] = true, g[u][++cnt[u]] = v;
    if (!G[v][u])
        G[v][u] = true, g[v][++cnt[v]] = u;
}
int dp(int u, int L, int R) {
    int fa = 1;
    while (g[u][fa] != R) ++fa;
    if (f[u][fa][L]) return f[u][fa][L];
    int l, r;
    if (L <= R) l = L, r = R - 1;
    else l = R + 1, r = L;
    int Lson = 0, Rson = 0;
    for (int k = 1; k <= 3; ++k)
        if (k != fa && l <= g[u][k] && g[u][k] <= r)
            if (g[u][k] < u) Lson = max(Lson, dp(g[u][k], l, u));
            else Rson = max(Rson, dp(g[u][k], r, u));
    f[u][fa][L] = Lson + Rson + 1;
    return f[u][fa][L];
}
signed main() {
    cin >> n; m = n * n * 4;
    for (int k = 1; k <= 4; ++k)
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j < i * 2; ++j)
                cin >> a[k][i][j];
    for (int k = 1; k <= 4; ++k)
        for (int i = 2; i < n; ++i)
            for (int j = 2; j < i * 2 - 1; ++j) {
                add(a[k][i][j], a[k][i][j - 1]);
                add(a[k][i][j], a[k][i][j + 1]);
                if (j & 1)
                    add(a[k][i][j], a[k][i + 1][j + 1]);
                else
                    add(a[k][i][j], a[k][i - 1][j - 1]);
            }
    for (int k = 1; k <= 4; ++k)
        for (int i = 2; i < n * 2; i += 2) {
            add(a[k][n][i], a[k][n][i - 1]);
            add(a[k][n][i], a[k][n][i + 1]);
            add(a[k][n][i], a[k][n - 1][i - 1]);
        }
    for (int i = 1; i < n * 2; ++i) {
        add(a[1][n][i], a[4][n - i / 2][1]);
        add(a[2][n][i], a[4][i / 2 + 1][(i / 2 + 1) * 2 - 1]);
        add(a[3][n][i], a[4][n][n * 2 - i]);
    }
    for (int i = 1, j = 1; i <= n; ++i, ++j) {
        add(a[1][i][1], a[3][i][i * 2 - 1]);
        add(a[2][i][1], a[1][i][i * 2 - 1]);
        add(a[3][i][1], a[2][i][i * 2 - 1]);
    }
    for (int i = 1; i <= m; ++i) {
        int Lson = 0, Rson = 0;
        for (int j = 1; j <= 3; ++j)
            if (g[i][j] < i) Lson = max(Lson, dp(g[i][j], 1, i));
            else Rson = max(Rson, dp(g[i][j], m, i));
        ans = max(ans, Lson + Rson + 1);
    }
    cout << ans;
}
```

---

## 作者：吴国铨 (赞：3)

保留原来的三个4个三角形 然后建图 而不是搞到一个大的三角形里再建图

具体看代码吧

我们得到了每个点相邻的三个点的权值以后 需要枚举根 然后扩展结点 统计最大值

对于每一个点 我们并不需要分开考虑左右都选还是直选左或者直选右

我们左右都扩展一遍然后取大并做和就ok

但是介于二叉搜索树的要求 如果我们扩展节点时只要求他和相邻父亲比较大小的话

不能满足左子树的每个节点都小于根 所以我们扩展的时候再维护一下边界 这样的话就使得树满足性质了

然而时间复杂度会很大 需要记忆化

再然而我们这个状态不好表示 只能用3维 f[i][j][k] 表示从j到i 边界是k(不管是左还是右)以i为根的最优解

再再然而我们又发现这个状态爆空间了-- 降维的话 如果把第三维降掉显然会有重复

其实我们的j到i是很浪费的 我们可以压缩第二维 把到从j改为从i的第几个相邻的点到的

这样我们就能存下了 然后就是细节问题了

开始存小三角形用的5\*20\*20 n<=18 RE到死....忘记存的三角形不是矩形了.....WTF




```cpp
const
  maxnodes = 1296;
type
  relation = array [0..2, 1..maxnodes] of longint;
  status = array [1..maxnodes] of ^relation;
var
  r:relation;
  a:status;
  n,p,max:integer;
  procedure initialize;
  var
    i,j,k,id,q:longint;
    tri:array [1..4, 1..18, 1..35] of longint;
    c:array [1..maxnodes] of longint;
  procedure link(x, y :longint);
  begin
    r[c[x], x] := y;
    inc(c[x]);
    r[c[y], y] := x;
    inc(c[y])
  end;
  begin
    readln(n);
    p := 4 * n * n;
    fillchar(c, sizeof(c), 0);
    for i := 1 to p do
    begin
      new(a[i]);
      fillchar(a[i]^, sizeof(a[i]^), 0)
    end;
    for i := 1 to 4 do
      for j := 1 to n do
      for k := 1 to j shl 1 - 1 do
      readln(tri[i, j, k]);
    for i := 1 to 4 do
      for j := 1 to n do
      for k := 2 to j shl 1 - 2 do
    if k and 1 = 0      then
    begin
      link(tri[i, j, k], tri[i, j, k - 1]);
      link(tri[i, j, k], tri[i, j, k + 1]);
      link(tri[i, j, k], tri[i, j - 1, k - 1])
    end;
      j := -1;
      k := n shl 1 + 1;
    for i := 1 to n do
    begin
      inc(j, 2);
      dec(k, 2);
        link(tri[1, i, 1], tri[3, i, j]);
        link(tri[1, i, j], tri[2, i, 1]);
        link(tri[1, n, k], tri[4, i, 1]);
        link(tri[2, i, j], tri[3, i, 1]);
        link(tri[2, n, j], tri[4, i, j]);
        link(tri[3, n, j], tri[4, n, k])
    end
  end;
  function getsub(id, range, fid :integer) :integer;
  var
    from, low, high, i, j, temp, lmax, rmax :integer;
  begin
    from := 0;
    while r[from, id] <> fid do inc(from);
    if a[id]^[from, range] > 0 then
    begin
      getsub := a[id]^[from, range];
```
exit


```cpp
    end;
    if range > fid then
      begin
        low := fid + 1;
        high := range
      end
    else
    begin
      low := range;
      high := fid - 1
    end;
    lmax := 0;
    rmax := 0;
    for i := 0 to 2 do
   if (i <> from) and (r[i, id] >= low) and (r[i, id] <= high) then
   if r[i, id] < id then
   begin
     temp := getsub(r[i, id], low, id);
     if temp > lmax then lmax := temp
   end
   else
   begin
     temp := getsub(r[i, id], high, id);
     if temp > rmax then
     rmax := temp
   end;
     i:=lmax + rmax + 1;
     a[id]^[from, range] := i;
     getsub := i
  end;
  procedure solve;
  var
    i, j, k, temp, lmax, rmax :integer;
  begin
    max := 0;
    for i := 1 to p do
    begin
      lmax := 0;
      rmax := 0;
      for j := 0 to 2 do
      if r[j, i] < i then
      begin
        temp := getsub(r[j, i], 1, i);
        if temp > lmax then
        lmax := temp;
      end
      else
      begin
        temp := getsub(r[j, i], p, i);
        if temp > rmax then
        rmax := temp
      end;
      if lmax + rmax > max then
        max := lmax + rmax
    end;
    inc(max)
  end;
begin
  initialize;
  solve;
  writeln(max);
end.
```

---


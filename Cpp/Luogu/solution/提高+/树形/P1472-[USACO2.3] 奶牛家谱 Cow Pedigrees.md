# [USACO2.3] 奶牛家谱 Cow Pedigrees

## 题目描述

一个有 $n$ 个节点，深度为 $k$ 的无标号完满二叉树（即每个节点的儿子数为 $0$ 或 $2$）有多少种结构？定义根节点深度为 $1$。

答案对 $9901$ 取模。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$3\le n < 200$，$2 \le k < 100$。

USACO 2.3


## 样例 #1

### 输入

```
5 3
```

### 输出

```
2
```

# 题解

## 作者：I_AM_HelloWord (赞：210)

有时候计算一下无用的状态反而是有用的。例如楼下的全都是设dp[i][j]表示i个点刚好j层的方案数，然后弄个4层循环，还有组合数什么乱七八糟的，不仅思维难度高，编程难度高，时空复杂度都高！

既然设刚好j层那么麻烦，我们不妨设dp[i][j]表示i个点小于等于j层的方案数，那么最终我们所需的答案就是dp[n][k]-dp[n][k-1]是不是？

考虑一下dp过程（一般树形背包，除非是多叉树用分组背包只能用dfs写，否则可以先考虑写一个记忆化搜索，因为记忆化搜索虽然效率低一些，但是思维复杂度较低，初始化考虑也会更全面，然后对应的再改写成dp）

枚举一个t，表示分t个点给左子树，剩下i-t-1（除去当前的根）分给右子树，然后乘法原理搞一搞。

即：dp[i][j]=sigma(dp[t][j-1]\*dp[i-t-1][j-1]),是不是很简单？

考虑一下初始化：把dp[1][]都设成1就好了，然后枚举点的个数时只需要枚举奇数（这个很容易想到）。

参考代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int Mod=9901;
int dp[210][110],n,k;
int main(){
    scanf("%d%d",&n,&k);
    for (int i=1;i<=k;i++)dp[1][i]=1;
    for (int tk=1;tk<=k;tk++)
        for (int i=3;i<=n;i+=2)
            for (int j=1;j<i;j+=2)
                (dp[i][tk]+=dp[j][tk-1]*dp[i-j-1][tk-1])%=Mod;
    printf("%d",(dp[n][k]-dp[n][k-1]+Mod)%Mod);
    return 0;
}
```

---

## 作者：kkksc03 (赞：89)

这是一个DP问题。我们所关心的树的性质是深度和节点数，所以我们可以做这样一张表：

table[i][j]表示深度为i、节点数为j的树的个数。根据给定的约束条件，j必须为奇数。你如何构造一棵树呢？当然是由更小的树来构造了。一棵深度为i、节点数为j的树可以由两个子树以及一个根结点构造而成。当i、j已经选定时，我们选择左子树的节点数k。

这样我们也就知道了右子树的节点数，即j-k-1。至于深度，至少要有一棵子树的深度为i-1才能使构造出的新树深度为i。有三种可能的情况：左子树深度为i-1 ，右子树深度小于i-1；右子树深度为i-1，左子树深度小于i-1；左右子树深度都为i-1。事实上，当我们在构造一棵深度为i的树时，我们只关心使用的子树深度是否为i-1或更小。

因此，我们使用另一个数组smalltrees[i-2][j]记录所有深度小于i-1的树，而不仅仅是深度为i-2的树。知道了上面的这些，我们就可以用以下三种可能的方法来建树了：

```delphi

table[i][j] := smalltrees[i-2][k]*table[i-1][j-1-k];
                  // 左子树深度小于i-1，右子树深度为i-1
table[i][j] := table[i-1][k]*smalltrees[i-2][j-1-k];
                  // 左子树深度为i-1，右子树深度小于i-1
table[i][j] := table[i-1][k]*table[i-1][j-1-k];
                  // 左右子树深度都为i-1 

```
另外，如果左子树更小，我们可以对它进行两次计数，因为可以通过交换左右子树来得到不同的树。总运行时间为O(K\*N^2)，且有不错的常数因子。


---

## 作者：「QQ红包」 (赞：23)

题解by：redbag

我的博客：http://redbag.duapp.com/

欢迎来踩！

于是我将kkk所述的翻译成代码了

/\*
ID: ylx14274

PROG: nocows

LANG: C++

\*/
            
```cpp
#include<set>  
#include<map>  
#include<list>  
#include<queue>  
#include<stack>  
#include<string>  
#include<math.h>  
#include<time.h>  
#include<vector>  
#include<bitset>  
#include<memory>  
#include<utility>  
#include<stdio.h>  
#include<sstream>  
#include<iostream>  
#include<stdlib.h>  
#include<string.h>  
#include<algorithm> 
#define LL unsigned long long   
using namespace std;
int a[240][240];
int sa[240][240];
int main() 
{
    freopen("nocows.in","r",stdin);
    freopen("nocows.out","w",stdout);
    int n,m; 
    scanf("%d%d",&n,&m);//n:节点数 m:树高度 
    a[1][1]=1;//初始化
    for (int i=2;i<=m;i++)
    {
        for (int j=1;j<=n;j+=2)//要么有2个孩子要么没有孩子所以节点数一定是奇数 
            for (int k=1;k<=j-1-k;k+=2)//简单的优化,k>一半的时候可以*2，j-1是减去爸爸 
            {
                int x=2;
                if  (k==j-1-k) x=1;//一半一半的话就不用*2了
                a[i][j]+=x*((sa[i-2][k]*a[i-1][j-1-k])%9901//左子树深度小于i-1，右子树深度为i-1
                +(a[i-1][k]*sa[i-2][j-1-k])%9901//左子树深度为i-1，右子树深度小于i-1
                +(a[i-1][k]*a[i-1][j-1-k])%9901);//左右子树深度都为i-1 
                a[i][j]%=9901; //记得取摸 
            }
        for (int k=0;k<=n;k++)//加上去 
            {
                sa[i-1][k]+=sa[i-2][k]+a[i-1][k];
                sa[i-1][k]%=9901;//记得取摸 
            }
    }
    cout<<a[m][n]%9901<<endl;
    return 0;
}
```

---

## 作者：_J_C_ (赞：9)

...这道题难度标记有点虚高（虽然我WA了4次）

首先，定义dp[x][y]为还有x个点，需要达到y的高度。转移并不必像楼上那位所说的“然后弄个4层循环，还有组合数什么乱七八糟的，不仅思维难度高，编程难度高”

我们采用记忆化搜索来解决这道题。

我们规定左子树必须正好满足要求，即左子树高度为y-1，而右子树高度小于等于y-1（如果左右子树高度不等，则左右子树可以互换，方案乘以2）

然后我们用两个for循环分别枚举左子树的节点数与右子树的高度值（小于等于y-1）,利用乘法原理状态转移。

记得取模。

总时间大概1000ms，当然可以可行性剪枝、优化……反正过了就不纠结了（毕竟动规是思路题）

```cpp

#include <cstdio>
#include <cstdlib>

#define MOD 9901

bool bVis[212][112];
int dp[212][112];

int n, m;

int dfs(int cnt, int height)
{
	if (bVis[cnt][height]) return dp[cnt][height];
	if (cnt == 1) return height == 1;
	bVis[cnt][height] = true;
	if (height > (cnt + 1) / 2) return 0;
	if (height <= 1) return 0;
	int& state(dp[cnt][height]);
	for (int i(1); i < cnt; i += 2)
	{
		for (int j(1); j < height; ++j)
		{
			state += dfs(i, height - 1) * dfs(cnt - i - 1, j);
			state %= MOD;
			if (height - 1 != j)//如果高度相等，那么互换反而会导致方案重复（不妨试着模拟一下或者输出参数）
			{
				state += dfs(i, height - 1) * dfs(cnt - i - 1, j);
				state %= MOD;
			}
		}
	}
	return state;
}

int main()
{
	scanf("%d%d", &n, &m);
	printf("%d\n", dfs(n, m));
	return 0;
}

```

---

## 作者：YczSS (赞：8)


首先明确一下题目的意思：用N个点组成一棵深度为i的二叉树，求一共有几种方法？ 设dp[i,j]表示用i个点组成深度最多为j的二叉树的方法数，则：

dp[i,j]=∑(dp[k,j-1]×dp[i-1-k,j-1])(k in {1..i-2})

边界条件：dp[1,i]=1



我们要求的是深度恰好为K的方法数S，易知S=dp[n,k]-dp[n,k-1]。 但需要注意的是，如果每次都取模，最后可能会有dp[n,k]<dp[n,k-1],所以可以用S=(dp[n,k]-dp[n,k-1]+v) mod v


给出n,k,求满足以下条件的二叉树个数 1.每个结点的度为偶数 2.该树有n个结点 3.该树的深度为k 问题分析: 用动态规划和乘法原理求解,可以观察到一个树G(有x个结点,深度为k),如果去除它的根结点可以得到两个子数G1,G2,这两个子图的深度为k-1,他们的结点数的和为x-1.设其中G1有i个结点则G2有x-1-i个结点.


定义P(G)为与满足条件的二叉树G有同样多结点有深度相同且同样满足条件的树的个数.


将二叉树按上述方法依次分解为(有1个结点,深度为k-1的树和有x-1-1个结点深度为k-1的树),(有2个结点,深度为k-1的树和有x-1-2个结点深度为k-1的树),(有3个结点,深度为k-1的树和有x-1-3个结点深度为k-1的树)...(有x-1-1个结点,深度为k-1的树和有1个结点深度为k-1的树)...


由乘法原理得到:由G按上述方法分解成的每对二叉树(Gx,Gy)加一个根结点构成的二叉树的个数有P(Gx)\*P(Gy)个.


G可以分解为x-2对子树,由加法原理得到P(G)=∑P(Gi)\*P(Gj){(i,j)∈G可以分解到的子树对(Gi,Gj)}


定义f(x,k)满足为深度为k,结点个数为x,每个结点的度为偶数的二叉树的个数,由上述分析得到f(x,k)=∑(f(x-1-i,k-1)\*f(i,k-1){1<=i<=x-2}.

```cpp
var
  n,m,i,j,k:integer;
  dp:array[1..200,0..100]of integer;
begin
  readln(n,m);
  for i:=1 to m do
    dp[1,i]:=1;
  for j:=1 to m do
    for i:=1 to n do
    begin
      if not odd(i) then
        continue;
      for k:=1 to i-2 do
        dp[i,j]:=(dp[i,j]+dp[k,j-1]*dp[i-1-k,j-1]) mod 9901;
    end;
    writeln((dp[n,m]+9901-dp[n,m-1]) mod 9901);
end.
```

---

## 作者：L_M_ (赞：7)

真是道好dp

考虑：令f[i][j]为深度为i，节点数为j的树的方案

考虑分治，即这一颗树可以分为左右两个子树（当j = 1例外），可以分给左

子树k（k < j)个节点，这时根节点需要消耗一个点，所以分给右子树j - k - 1个节点

f[i][j] += f[i - 1][j - k - 1] * f[i - 1][k]

显然j不可能为偶数，所以枚举的时候枚举奇数即可

但稍等！还有一个问题，例如f[3][5] += f[2][1] * f[2][3],这时f[2][1]是0，但实际上这样的方案是存在的

因此我们要改变状态，将f[i][j]表示为深度不超过i，个数为j的树的方案

这时f[i][1]初始化为1，且最后统计答案是f[k][n] - f[k - 1][n](这样能统计出深度恰好为k的方案树）

以上

代码：
```
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<climits>
using namespace std;
const int mod = 9901;
const int maxn = 205;
typedef long long ll;
inline int read()
{
  int ans = 0,op = 1;
  char ch = getchar();
  while(ch < '0' || ch > '9')
    {
      if(ch == '-') op = -1;
      ch = getchar();
    }
  while(ch >= '0' && ch <= '9')
    {
      (ans *= 10) += ch - '0';
      ch = getchar();
    }
  return ans * op;
}
int f[maxn][maxn];
int main()
{
  int n = read(),k = read();
  for(int i = 1;i <= k;i++) f[i][1] = 1;
  f[1][1] = 1;
  for(int i = 2;i <= k;i++)
    for(int j = 3;j <= n;j += 2)
      for(int k = 1;k < j;k += 2)
    (f[i][j] += f[i - 1][k] * f[i - 1][j - k - 1]) %= mod;
  printf("%d",(f[k][n] - f[k - 1][n] + mod)% mod);
}
```

---

## 作者：唐一文 (赞：7)

# 一篇来自蒟蒻的非正解
### 首先，我们来看看数据范围：  
$3\leqslant n<200$ , $1<k< 100$  
你想到了什么东西？  
~~答：二维数组~~  
答：打表！！！

### 我们可以先打个dfs
就像这样：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int x=0;
	char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return x;
}
inline int C(int k,int n){
	register int i,j=0,maxn=(n,k-n),s=1;
	for(i=k;i>maxn;--i){
		s=s*i/(++j)%9901;
	}
	return s;
}
int n,m,t,h[10001];
inline void dfs(int k,int s,int x){
	if(k==m){
		if(s==n){
			t=(t+x)%9901;
		}
		return ;
	}
	register int i,a;
	for(i=1;i<=h[k];++i){
		h[k+1]=i*2;
		a=s+h[k+1];
		if(a>n){
			return ;
		}
		dfs(k+1,a,x*C(h[k],i)%9901);
	}
}
int main(){
	n=read();
	m=read();
	if(n%2==0){
		cout<<0;
		return 0;
	}
	if(n/2+1==m){
		int i,s=1;
		for(i=1;i<m-1;i++){
			s*=2;
			s%=9901;
		}
		cout<<s;
		return 0;
	}
	h[1]=1;
	dfs(1,1,1);
	printf("%d",t);
	return 0;
}
```
### 然后，把它塞进一个打表程序里
就像这样：
 ```cpp
#include<bits/stdc++.h>
using namespace std;
inline int C(int k,int n){
	register int i,j=0,maxn=(n,k-n),s=1;
	for(i=k;i>maxn;--i){
		s=s*i/(++j)%9901;
	}
	return s;
}
int n,m,t,h[10001];
inline void dfs(int k,int s,int x){
	if(k==m){
		if(s==n){
			t=(t+x)%9901;
		}
		return ;
	}
	register int i,a;
	for(i=1;i<=h[k];++i){
		h[k+1]=i*2;
		a=s+h[k+1];
		if(a>n){
			return ;
		}
		dfs(k+1,a,x*C(h[k],i)%9901);
	}
}
int main(){
	freopen("dabiao.txt","w",stdout);
	printf("int p[210][110]={{0}");
	for(n=1;n<=199;++n){
		printf(",{");
		printf("0");
		if(n%2==0){
			printf("}");
			continue;
		}
		for(m=1;m<=n/2+1;++m){
			if(n%2==0){
				cout<<0;
				return 0;
			}
			if(n/2+1==m){
				register int i,s=1;
				for(i=1;i<m-1;i++){
					s*=2;
					s%=9901;
				}
				printf(",%d",s);
			}
			else{
				h[1]=1;
				dfs(1,1,1);
				printf(",%d",t);
			}
		}
		printf("}");
	}
	printf("};");
	return 0;
}
```
### 最后，把表复制下来，塞进程序里  
Code出现了！
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,p[210][110]={想要表吗？自己复制去！};
int main(){
    cin>>n>>k;
    cout<<p[n][k];
    return 0;
}
```


---

## 作者：Fa1thful (赞：5)

#### 算法：动态规划/记忆化搜索
#### F1：

我们一层一层地来推，枚举层数，然后再枚举这一层选择的奶牛的个数（必须是偶数个的，因为我第一层已经处理好了），然后再枚举上一层选择的奶牛的个数（也必须是偶数的，因为我把第二层也特殊处理了，就可以从第三层开始了），但是发现一共要选择$n$个奶牛，所以不得不再加一维目前总共选择的奶牛的数量，也就是加一层循环来枚举$v$罢了；重点来了！！！假设上一层选择了$m$只奶牛，这一层选择了$j$只奶牛，那么$m$必须满足$m>=j/2$（因为二叉树的性质）,假设上一层的状态为$f[i-1][m][v-j]$，也就是i-1层选择了m只奶牛，前i-1层总共选择了v-j只奶牛的方案总数，这时第i层就是选择了j只奶牛了，第i层的j只奶牛和第i-1层的m只奶牛互相找妈妈，那么可以选择的方案总数就是$C_{j/2}^m*f[i-1][m][v-j]$,最后再统计就可以了。

#### F1代码实现：
```cpp
# include <bits/stdc++.h>
using namespace std;
const int mod = 9901;
int n, k, dp[100 + 10][200 + 10][200 + 10], w[200 + 10][200 + 10];
int main() 
{
	cin >> n >> k;
	w[0][0] = 1;	    
	dp[1][1][1] = 1;
	dp[2][2][3] = 1;
	for (int i = 1; i <= n; i++)
	{
		for (int j = 0; j <= i; j++)
	    {
			if (j == 0 || i == j) w[i][j] = 1;
	        else w[i][j] = (w[i - 1][j] + w[i - 1][j - 1]) % mod;
	    }
	}
	for (int i = 3; i <= k; i++)
	{
		for (int j = 2; j <= (n / 2 + 1); j += 2)
		{
			for (int x = j + 1; x <= n; x++)
			{
				for (int y = j / 2; y <= n / 2 + 1; y++)
				{
					if (y % 2 == 0) dp[i][j][x] += w[y][j / 2] * dp[i - 1][y][x - j] % mod;
				}
			}
		}
	}
	long long ans = 0;
	for (int i = 1; i <= n; i++)
	{
		ans += dp[k][i][n];
	} 
	cout << ans % mod << endl;		  	 
	return 0;
} 
```
#### F2：

采用记忆化搜索来解决这道题。

我们规定左子树必须正好满足要求，即左子树高度为$y-1$，而右子树高度小于等于$y-1$（如果左右子树高度不等，则左右子树可以互换，方案乘以2）然后我们用两个for循环分别枚举左子树的节点数与右子树的高度值（小于等于$y-1$）,利用乘法原理状态转移。

#### F2代码实现：
```
# include <bits/stdc++.h>
using namespace std;
const int MOD = 9901;
bool vis[212][112];
int dp[212][112];
int n, m;
int dfs(int cnt, int height)
{
    if (vis[cnt][height]) return dp[cnt][height];
    if (cnt == 1) return height == 1;
    vis[cnt][height] = true;
    if (height > (cnt + 1) / 2) return 0;
    if (height <= 1) return 0;
    int& state(dp[cnt][height]);
    for (int i = 1; i < cnt; i += 2)
    {
        for (int j = 1; j < height; j++)
        {
            state += dfs(i, height - 1) * dfs(cnt - i - 1, j);
            state %= MOD;
            if (height - 1 != j)//如果高度相等，那么互换反而会导致方案重复（不妨试着模拟一下或者输出参数）
            {
                state += dfs(i, height - 1) * dfs(cnt - i - 1, j);
                state %= MOD;
            }
        }
    }
    return state;
}
 
int main()
{
    cin >> n >> m;
    cout << dfs(n, m) << endl;
    return 0;
}
```


---

## 作者：TheOldDriver (赞：4)

1. 目标状态f[i][j] 深度i 节点数j一定为奇数
1. 满二叉树f[i][j]=1 
1. f[i][j]=左子树情况数*右子树情况数
1. t表示左子树节点数  p表示右子树深度 
1. 无法构建出深度为p的右子树 那当p更大时也不行
1. 当右子树的深度不足以容纳j-1-t个节点时 使p增大 
1. 为保证深度i使左子树深度恒为i-1 右子树深度不超过i-1
1. 如果左右子树深度相同 那么左右子树互换不会产生更多情况 不乘2 
```cpp
#include<cstdio>
#include<cmath>
#include<iostream>
using namespace std;
int n,k,f[201][201];
int main(){
	scanf("%d%d",&n,&k);
	if(!n%2){printf("0");return 0;}
	if(k*2-1>n){printf("0");return 0;}
	for(int i=1;i<=k;i++){
		for(int j=i*2-1;j<=n;j+=2){
			//目标状态f[i][j] 深度i 节点数j一定为奇数 
			if(j==pow(2,i)-1) {f[i][j]=1;break;}
			//满二叉树f[i][j]=1 
			for(int t=(i-1)*2-1;t<=j-2;t+=2){
				for(int p=1;p<=i-1;p++){
					//f[i][j]=左子树情况数*右子树情况数
					//t表示左子树节点数  p表示右子树深度 
					if(p*2-1>j-1-t) break;
					//无法构建出深度为p的右子树 那当p更大时也不行 
					while(pow(2,p)-1<j-1-t) p++;
					//当右子树的深度不足以容纳j-1-t个节点时 使p增大 
					if(p>i-1) break;
					//为保证深度i使左子树深度恒为i-1 右子树深度不超过i-1 
					if(p==i-1) f[i][j]+=f[i-1][t]*f[p][j-1-t],f[i][j]%=9901;
					//如果左右子树深度相同 那么左右子树互换不会产生更多情况 不乘2 
					else f[i][j]+=f[i-1][t]*f[p][j-1-t]*2,f[i][j]%=9901;
				}
			}
		}
	} 
	printf("%d",f[k][n]);
	return 0;
}
```

---

## 作者：罗旅洲 (赞：4)

/\*
time:76ms

dp[i][j][k] i代表第几层，j为总共放的节点数，k表示这一层放的节点数,dp数组存储方案数

转移时，枚举节点总个数，与该层的节点数，用组合数算一算即可，（转移还是看代码吧）

组合数可以预处理

\*/

```cpp
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<iostream>
#include<cstdio>
#define For(i,a,b) for(register int i=a;i<=b;++i)
#define Rep(i,a,b) for(register int i=a;i>=b;--i)
const int mod=9901;
using namespace std;
int dp[110][210][210],c[201][201],fac[201],inv[201],n,k;    //c是组合数，fac是阶乘，inv是逆元
int read(){
    char x;
    while((x=getchar())>'9' || x<'0');
    int u=x-'0';
    while((x=getchar())>='0' && x<='9')
    u=u*10+x-'0';
    return u;
}
int pow(int y,int x){                //x^(p-2)求逆元，求组合数
    int res=1;
    while(x){
        if(x&1) (res*=y)%=mod;
        (y*=y)%=mod;
        x>>=1;
    }
    return res;
}
void init(){
    fac[0]=1;
    For(i,1,200) fac[i]=fac[i-1]*i%mod;
    inv[200]=pow(fac[200],mod-2);
    Rep(i,200,1) inv[i-1]=inv[i]*i%mod;            //逆元的计算
    For(i,1,200)
        For(j,i,200)
            c[i][j]=fac[j]%mod*inv[i]%mod*inv[j-i]%mod;
}
int main(){
#ifndef ONLINE_JUDGE
    freopen("input.in", "r", stdin);
    freopen("output.out", "w", stdout);
#endif
    int i,j,u,v;
    init();            //预处理组合数
    n=read(); k=read();
    dp[1][1][1]=1; dp[2][3][2]=1;    
    For(u,2,k-1){                                //u枚举层数
        for(i=2;i<n;i+=2)                        //i枚举当前层的点数 ,i+=2,点数永远为奇
            for(j=(u<<1)-1;j<n;j+=2){            //j枚举总点数,u*2-1是这一层最少要放的点
                if(!dp[u][j][i]) continue;
                for(v=2;v<=(i<<1);v+=2){        //v表示下一层放的点数，i<<1因为下一层最多能有这一层2倍的点
                    if(j+v>n) break; 
//                    printf("%d %d\n",v,i);
                    (dp[u+1][j+v][v]+=(dp[u][j][i]*c[v/2][i]%mod))%=mod;
                }
            }
        }
    int ans=0;
    for(int i=2;i<=200;i+=2)
        if(dp[k][n][i])
            (ans+=dp[k][n][i])%=mod;    //统计答案
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：Zhengsiwei (赞：2)

[题目](https://www.luogu.com.cn/problem/P1472)在这里。  
这道题应当是用**动态规划**解的。至于为什么要用动态规划，应当是因为这是个**计数**的问题。    
整篇题解主要分四块：  
- **动态规划的数组**
- **状态转移方程**
- **常数优化，以及一点小坑**
- **完整代码**  

会一一叙述。  
### 动态规划的数组
这个应当是最难整的地方了。  
首先，我们应当考虑这样：$dp_{i,j}$表示$j$个节点、$i$层的完满二叉树的种数。  
然后你会发现推导状态转移方程时推导不下去了。究其原因，是因为这个数组中的数字之间没有什么明显而好用的关系。  
那么继续想。肯定和那个有关；我们就围绕那个试一试。譬如说，利用**前缀和**思想，设$sum_{i,j}=\sum_{k=1}^{i}dp_{k,j}$。  
还有，显然地，$sum_{1,j}=1$。这是**初始值**。
事实上，这个是走得通的。
### 状态转移方程
首先，树的根一定**既有左子树，又有右子树**。除了节点数，它们不互相影响。  
大家应该学过小学奥数中的加法原理与乘法原理吧！在这种情况下，应当**枚举左子树的节点数**，把左右子树的状况数**乘**起来。  
好极了。已经有思路了。给个代码吧！
```cpp
for(int i=1;i<=k;i++)
    for(int j=1;j<=n;j++)
        for(int cut=1;cut<j;cut++)
            sum[i][j]=(sum[i][j]+sum[i-1][j-cut-1]*sum[i-1][cut])%9901;
```
### 常数优化，以及一点小坑
**理论上**，速度能加倍。
完满二叉树有这样一条性质：节点数一定是**奇数**。
为什么呢？可以这样想：完满二叉树都是由根节点“长”出来的；只有根节点时节点数是**奇数**，每“生长”一次增加两个节点，节点数**奇偶性不变**，节点数还是**奇数**。
好极了。上面的代码中的那个$j$只需枚举**奇数**即可。我改进之后是这样：
```cpp
for(int i=1;i<=k;i++)
    for(int j=1;j<=n/2;j++)
        for(int cut=1;cut<2*j+1;cut++)
            sum[i][2*j+1]=(sum[i][2*j+1]+sum[i-1][2*j-cut]*sum[i-1][cut])%9901;
```
哦不，光是这样，你是过不了的。如果你得了91分，错在最后一个点上，输出的是负数，往下看完。  
算法没毛病的。问题出在取模上。举个例子：
$$a=13716,b=8706$$
$$a\bmod 9901=3815,b\bmod 9901=8706$$
$$(a-b)\bmod 9901=5010,a\bmod 9901-b\bmod 9901=-4891$$
所以怎么办呢？简单极了，输出时做个特判，小于零了，就加上9901。
### 完整代码
代码很简洁；但思维难度不小。这便是一个很典型的动态规划。
```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
//快读的函数。可以读入一个整数。
int main(){
    int n,k,sum[209][209]={0};//n、k如题意。sum是动态规划用的数组。
    n=read();k=read();//输入。
    for(int i=1;i<=k;i++) sum[i][1]=1;//赋初值
    for(int i=1;i<=k;i++)
        for(int j=1;j<=n/2;j++)
            for(int cut=1;cut<2*j+1;cut++)
                sum[i][2*j+1]=(sum[i][2*j+1]+sum[i-1][2*j-cut]*sum[i-1][cut])%9901;
    //动态规划。
    if(sum[k][n]-sum[k-1][n]<0)
        cout<<sum[k][n]-sum[k-1][n]+9901<<endl;
    else
        cout<<sum[k][n]-sum[k-1][n]<<endl;
    //输出。
    return 0;
}
```

---

## 作者：Kirito1 (赞：2)

# 蒟蒻第二篇题解（第一篇没通过〒▽〒），希望能通过

#### 申明：本蒟蒻构图时忘记条件“每一个节点的度是0或2”
#### 所以按照0或1或2画的，请自行脑补~~（勿喷）~~

## 首先设计状态
```cpp
int f[233][233]//f[i][j]为节点数为i，高度为j的树的方案数
 ```
## 转移方程 

先看这样一棵树

![](https://cdn.luogu.com.cn/upload/image_hosting/5zq6doqb.png)

**其深度为3，节点数6

**我们可以将树去根分为左右两棵树

![](https://cdn.luogu.com.cn/upload/image_hosting/xx03b5re.png)

**然后开始枚举子树...~~自己意yin~~

**拓展至一般的树

![](https://cdn.luogu.com.cn/upload/image_hosting/5zq6doqb.png)

**设其深度为j,大小为i

**去根枚举状态

![](https://cdn.luogu.com.cn/upload/image_hosting/u6yjce3i.png)

**在这里我们强制让右子树的深度<=左子树，然后左右子树交换

**特殊的左右子树相同时，不用交换

```cpp
当(p < j-1)时(k 为左子树大小，p为右子树深度) (左右子树只有一棵深度为 j-1，翻倍)
F[i][j] += ∑ （F[k][j-1]  *  F[i-k-1][p]  *  2 ） 


当p=j-1时(左右子树深度均为 j-1，不重复计算)
+F[k][j-1] * F[i-k-1][j-1]
```
## 上代码
```cpp
#include<bits/stdc++.h>
#define MOD 9901
using namespace std;
int n,m;
int f[300][200];//f[i][j]为大小（节点数）为i，深度为j的树 
int main(){
	cin>>n>>m;
	f[1][1]=1;// 初值，大小深度为 1 的子树只有一种情况
	for(int i=3;i<=n;i++){//大小最小为1，但上面考虑了 ，so 从3开始 
		for(int j=2;j<=m;j++){//大小为3时深度最小为2, 
			//子树状态 
			for(int k=1;k<i-1;k++){//左子树大小，最大为i-2
			//去掉根-1，右子树最少站一个再-1 
				for(int p=1;p<j-1;p++){
			//考虑右子树深度，为了避免重复 so使右子树深度小于左子树，再交换左右 
			//最大为j-2（去根深度-1 ）的情况			 
					f[i][j]=(f[i][j]+f[k][j-1]*f[i-k-1][p]*2%MOD)%MOD;
					}//原来的情况+左子树情况*右子树情况，因为左右可互换所以*2 
					//左右子树深度一样时，交换一样 
					f[i][j]=(f[i][j]+f[k][j-1]*f[i-k-1][j-1]%MOD)%MOD;
			}
		}
	}
	cout<<f[n][m];
}
```

![](https://cdn.luogu.com.cn/upload/image_hosting/b47l8p1g.png)

管理大大求过


---

## 作者：ylsoi (赞：2)

动态规划+杨辉三角一遍过，但是其实想了很久；我们肯定是一层一层地来推，枚举层数，然后再枚举这一层选择的奶牛的个数（必须是偶数个的，因为我第一层已经处理好了），然后再枚举上一层选择的奶牛的个数（也必须是偶数的，因为我把第二层也特殊处理了，就可以从第三层开始了），但是发现一共要选择n个奶牛，所以不得不再加一维目前总共选择的奶牛的数量，也就是加一层循环来枚举v罢了；现在就是重点！！！假设上一层选择了m只奶牛，这一层选择了j只奶牛，那么m必须满足m>=j/2（因为二叉树的性质）,假设上一层的状态为f[i-1][m][v-j]，也就是i-1层选择了m只奶牛，前i-1层总共选择了v-j只奶牛的方案总数，这时第i层就是选择了j只奶牛了，第i层的j只奶牛和第i-1层的m只奶牛互相找妈妈，

那么可以选择的方案总数就是C（m,j/2）\*f[i-1][m][v-j](我这里把两只兄弟奶牛看成一只了),最后再统计就可以了。

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
using namespace std;
const int maxn=200+10;
const int maxk=100+10;
const int mod=9901;
int n,k,f[maxk][maxn][maxn],ans,w[maxn][maxn];
int main()
{
    scanf("%d%d",&n,&k);
    f[1][1][1]=1;
    f[2][2][3]=1;
    w[0][0]=1;
    for(int i=1;i<=n;i++)
        for(int j=0;j<=i;j++)
            if(j==0 || j==i)w[i][j]=1;
            else w[i][j]=(w[i-1][j]+w[i-1][j-1])%mod;
    for(int i=3;i<=k;i++)
    {
        for(int j=2;j<=n/2+1;j+=2)
        {
            for(int v=j+1;v<=n;v++)
            {
                for(int m=j/2;m<=n/2+1;m++)
                if(m%2==0)f[i][j][v]+=w[m][j/2]*f[i-1][m][v-j]%mod;
            } 
        } 
    }
    for(int i=1;i<=n;i++)
    ans+=f[k][i][n];
    printf("%d\n",ans%mod);
    return 0;
}
```

---

## 作者：Till_Gloam (赞：2)

三维dp, 四维转移：

dp[i][j][k] : 第i层放j个， 总共放k个， 答案就是dp[i][j:(2 ~ n)][k];

转移方程：dp[i][j][k] += dp[i - 1][m][k - j] \* C[m][j >> 1], m:((j >> 1) + (j >> 1) % 2 ~ n)

第i层放j个， 总共放k个， 那么第i - 1层至少放(j >> 1) + (j >> 1) % 2) 个， 最多放n个;

第i层需要(j >> 1)个父亲， 总共m个父亲， 所以有C[m][j >> 1]种选择；

然后在循环中记录co(i, j):i层放j个至少总共要放几个， 若超出预算， 就break;





```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#define mod 9901
#define For(a, b, c) for(a = b; a <= c; ++a)
#define Forr(a, b, c) for(a = b; a >= c; --a)
using namespace std;
int dp[105][205][205], C[205][205];
int n, K, ans;
int co(int d, int x){
    long long u = x;
    while(d){
        u += (x >>= 1);
        --d;
        if(d > 1){
            u += x % 2;
            x += x % 2;
        }
        //cout<<d<<" "<<u<<endl;
    }
    return u;
}
int main(){
#ifndef ONLINE_JUDGE
    freopen("Usa.in", "r", stdin);
    freopen("Usa.out","w",stdout);
#endif
    int i, j, k, m;
    //cout<<co(10, 100)<<endl;
    dp[1][1][1] = 1;
    C[0][0] = 1;
    For(i, 1, 202) C[i][i] = C[i][0] = 1, C[i][1] = i;
    For(i, 2, 202) For(j, 2, 202)
        (C[i][j] = C[i - 1][j] + C[i - 1][j - 1]) %= mod;
    scanf("%d%d", &n, &K);
    For(i, 2, K){
        For(j, 2, n){
            if(i < 31) if(j >= (1 << i)) break;
            For(k, co(i, j), n){
                For(m, j >> 1, n){
                    if(m == (j >> 1) && i > 2) m += (j >> 1) % 2;
                    if(co(i - 1, m) > k - j) break;
                    (dp[i][j][k] += dp[i - 1][m][k - j] * C[m][j >> 1]) %= mod;
                    ++m;
                }
            }
            ++j;
        }
    }
    //cout<<dp[2][2][3]<<endl;
    For(i, 2, n) (ans += dp[K][i][n]) %= mod, ++i;
    printf("%d", ans);
    return 0;
}
```

---

## 作者：凯特琳 (赞：2)

如kkk所言


构造f[j,i]表示深度为i，总结点数为j的树的形态数

我们在构造一棵深度为i，总结点为j的树的时候，需要先拿出一个根结点，用j-1个节点构造子树，

而且还要保证max(deep左子树，deep右子树)=i-1

那么左右子树的形态共有两种：

1.deep左子树=i-1 deep右子树<=i-2；

2.deep左子树<=i-2 deep右子树=i-1;

3.deep左子树=i-1 deep右子树=i-1；

那么我们第三种情况可以直接枚举 上一个深度的 左右子树的节点分配情况来转移；

情况1和2的个数实际上是一样多的，因为2中可以令左右子树交换位置，就和1一样了；

那么我们看情况1，deep=i-1的树是我们上一个状态的记录值，这就要求我们有一个记录深度不超过k的树的个数的数组。

那么我们在每次转移完f[j,i]的时候，让sum[j,i]:=f[j,i]+sum[j,i-1]；类似于一个前缀和的思想。


AC代码：

```delphi

var f:array[1..200,1..100]of int64;
var sum:array[0..200,0..100]of int64;
var i,j,m,n,k,s:longint;
begin
read(n,s);
f[1,1]:=1;
sum[1,1]:=1;
f[3,2]:=1;
sum[3,2]:=1;
sum[1,2]:=1;

for i:=3 to s+1 do
begin
    for j:=i to n do
    begin
        for k:=i-1 to j-1 do//k分配给左子树，深度为i-1的左子树最少有i-1个节点
        f[j,i]:=(f[j,i]+f[k,i-1]*sum[j-k-1,i-2])mod 9901;//deep右子树<=i-2
        f[j,i]:=f[j,i]*2 mod 9901;//情况1.2个数相同
        
        for k:=i-1 to j-i do//deep左右子树=i-1，左子树最少i-1，右子树最少i-1----->左子树最多j-i（子树总结点j-1）
        f[j,i]:=(f[j,i]+f[k,i-1]*f[j-k-1,i-1]) mod 9901;
        sum[j,i]:=(sum[j,i]+f[j,i])mod 9901;//转移sum
        sum[j,i]:=(sum[j,i]+sum[j,i-1])mod 9901;//加上前面的
    end;
    for j:=1 to i-1 do//这些状态对于子树的节点分配情况是没有意义的，但是对于sum是有意义的。
    sum[j,i]:=sum[j,i-1];
end;
writeln(f[n,s]);
end.

```


---

## 作者：Celebrate (赞：2)

其实这一道题是一道递推题，唯一的难点就是难找规律

定义一个f数组，f[n][k]表示n个点不大于k长度的方案数

结果就是f[n][k]-f[n][k-1]了

三重for循环首先枚举长度i，点的个数j，左子树的个数t

公式 f[j][i]+=f[t][i-1]* f[j-i-1][i-1]

记得是乘，而不是加，乘法原理就不解释了

代码如下：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int n,k,f[210][210];
int main()
{
	int i,j,t;
	scanf("%d%d",&n,&k);
	for(i=1;i<=k;i++) f[1][i]=1;//一个点无论多高都是1种方案 
	for(i=1;i<=k;i++)//枚举高度 
	{
		for(j=3;j<=n;j+=2)//枚举点数，两边同时+1，所以j+2 
		{
			for(t=1;t<j;t+=2)//枚举左子树的点数 
			{
				f[j][i]+=f[t][i-1]*f[j-t-1][i-1];//刚才的公式 
				f[j][i]%=9901;//题目说的%9901 
			}
		}
	}
	printf("%d\n",(f[n][k]-f[n][k-1]+9901)%9901);//输出，但是这两个数可能不是同级，所以要+9901，这个不影响结果 
	return 0;
}
```

---

## 作者：Shunpower (赞：1)

这应该是一种题解区没有的做法。

想数树的形态，考虑 dp。

你会考虑在转移时进行类似**合并左右子树**的操作，因为将左右子树放在一起，加入根，深度恰好增加 $1$，节点数量总和恰好增加 $1$，为我们同时达成深度与点个数的目标带来了美妙的性质。

于是非常容易想到考虑 $f_{i,j}$ 表示节点数量为 $i$，深度恰好为 $j$ 的二叉树形态总数，然而你推出转移之后发现转移确实很简单但是要 $\mathcal O(n^2k^2)$ 的时间复杂度，感觉并不够优秀啊！

虽然可以强行做前缀和优化去掉一个 $k$，但不妨考虑使用类似 [P3830 [SHOI2012] 随机树](https://www.luogu.com.cn/problem/P3830)的状态设计方式来减小复杂度。设 $f_{i,j}$ 表示节点数量为 $i$，深度大于等于 $j$ 的二叉树形态总数，考虑转移。

首先枚举 $p$ 表示左子树贡献的节点总数，那么右子树必然贡献 $i-1-p$ 个节点。注意到因为总深度需要大于等于 $j$，所以必然存在一个子树的深度大于等于 $j-1$（合并左右子树加上根之后，整体深度都会增加 $1$）。当左子树的深度大于等于 $j-1$ 时，右子树的形态没有限制，反正深度都会大于等于 $j$，因此这种情况对答案的贡献为 $f_{p,j-1}\times f_{i-1-p,1}$。反过来如果右子树的深度大于等于 $j-1$，对答案的贡献就为 $f_{p,1}\times f_{i-1-p,j-1}$。然而你发现这样做会统计重复两边的深度都大于等于 $j-1$ 的情况，所以你需要斥掉 $f_{p,j-1\times f_{i-1-p,j-1}}$。

于是整个转移就是：

$$
f_{i,j}\gets f_{i,j}+f_{p,j-1}\times f_{i-1-p,1}+f_{p,1}\times f_{i-1-p,j-1}-f_{p,j-1\times f_{i-1-p,j-1}}
$$

根据定义，初值即为 $f_{1,1}=1,f_{3,1}=f_{3,2}=1$，答案为 $f_{n,k}-f_{n,k+1}$。

直接朴素实现即可，复杂度 $\mathcal O(n^2k)$。注意减法取模，$f_{i,1}\gets f_{i,2}$ 等实现细节。

实现：

```cpp
int n,k;
int dp[210][110];
const int M=9901;
int main(){
    cin>>n>>k;
    dp[1][1]=1,dp[3][1]=dp[3][2]=1;
    fr1(i,4,n){//其实都可以只枚举奇数，但是是常数优化就无所谓了
        fr1(j,2,k+1){//因为深度为0时不合法所以从2开始枚举深度
            fr1(p,1,i-2){
                dp[i][j]+=((dp[p][j-1]*dp[i-1-p][1]%M+dp[p][1]*dp[i-1-p][j-1]%M)%M-dp[p][j-1]*dp[i-1-p][j-1]%M+M)%M;
                dp[i][j]%=M;
            }
        }
        dp[i][1]=dp[i][2];//但在最后必须记得特意给dp[i][1]赋dp[i][2]的值，后面转移可能会用到dp[i][1]
    }
    cout<<(dp[n][k]-dp[n][k+1]+M)%M<<endl;
    ET;
}
```

[AC 记录](https://www.luogu.com.cn/record/124531525)

---

## 作者：KesdiaelKen (赞：1)

这题的解法其实很妙，其它题解里有体现。这里给出一种比较暴力的dp思路。

设$f[i][j]$表示$i$层$j$点的树有多少种。显然，当$j>1$时，根节点必有$2$子节点。所以考虑枚举根节点左右子树的节点个数，一边为$k$则另一边为$j-k-1$，所以$k$的范围为$1$到$j-2$，使$j$与$j-k-1$均大于$1$。

因为只需要一条从根引出的路径等于$i$，所以若根节点的一个子树的深度为$i-1$，则另一子树不需要为$i-1$。我们用$sum[i][j]$表示层数小于等于$i$，点数为$j$的树有多少种，则$f[i][j]$答案为$f[i-1][k]*sum[i-1][j-k-1]+sum[i-1][k]*f[i-1][j-k-1]$。但是要注意，这个式子重复计算了两个子树深度均为$i-1$的情况，因此要再减去$f[i-1][k]*f[i-1][j-k-1]$。

于是，我们只需要一边求$f$一边统计$sum$即可。程序里的$sum$使用了滚动数组，滚去了层数的维度。注意$sum$不要与$f$在同一个循环中统计，这样会导致$sum$提前统计了深度为$i$的$f$。

代码如下：
```
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<cmath>
#include<iostream>
using namespace std;
int dp[200][300]={0},sum[300]={0};
int main()
{
    dp[1][1]=1;sum[1]=1;
    int n,m;scanf("%d%d",&n,&m);
    for(int i=2;i<=m;i++)
    {
        for(int j=3;j<=n;j++)
            for(int k=1;k<=j-2;k++)
                dp[i][j]=((dp[i][j]+dp[i-1][k]*sum[j-k-1]+sum[k]*dp[i-1][j-k-1]-dp[i-1][k]*dp[i-1][j-k-1])%9901+9901)%9901;
        for(int j=3;j<=n;j++)sum[j]=(sum[j]+dp[i][j])%9901;
    }
    printf("%d\n",dp[m][n]);
    return 0;
}
```


---

## 作者：jbc392 (赞：1)

## 打表

用dfs打表

下面是AC代码 3ms

```
#include<bits/stdc++.h>
using namespace std;

int n ,k;
int p[210][110] = {{0},{0,1},{0},{0,0,1},{0},{0,0,0,2},{0},{0,0,0,1,4},{0},{0,0,0,0,6,8},{0},{0,0,0,0,6,20,16},{0},{0,0,0,0,4,40,56,32},{0},{0,0,0,0,1,68,152,144,64},{0},{0,0,0,0,0,94,376,480,352,128},{0},{0,0,0,0,0,114,844,1440,1376,832,256},{0},{0,0,0,0,0,116,1744,4056,4736,3712,1920,512},{0},{0,0,0,0,0,94,3340,955,5347,4371,9600,4352,1024},{0},{0,0,0,0,0,60,5976,7870,7500,1279,972,4262,9728,2048},{0},{0,0,0,0,0,28,139,8210,2026,4323,8349,1681,9375,1702,4096},{0},{0,0,0,0,0,8,5955,768,1419,4475,846,4202,4711,2698,7500,8192},{0},{0,0,0,0,0,1,3658,5844,44,7048,6711,5423,7462,8017,7091,3390,6483},{0},{0,0,0,0,0,0,2695,6536,3597,4607,4914,1438,5735,9580,9114,5962,3362,3065},{0},{0,0,0,0,0,0,2054,5024,5076,5100,6181,6900,4045,2338,1538,4360,1967,9789,6130},{0},{0,0,0,0,0,0,195,4706,4907,4246,5332,9601,4379,960,5542,1732,7213,6887,5906,2359},{0},{0,0,0,0,0,0,5241,4944,2806,7840,9274,5571,2074,5348,3081,2322,2278,7529,6008,4270,4718},{0},{0,0,0,0,0,0,5803,7888,4081,3288,3937,9264,4092,5702,3108,4626,6829,4370,9529,8744,3357,9436},{0},{0,0,0,0,0,0,1283,8282,2939,3087,6846,8617,5787,3756,1045,8985,5538,2473,7333,7087,5761,6249,8971},{0},{0,0,0,0,0,0,2340,4274,6233,7938,1086,2855,6692,9220,5193,5263,6346,6455,659,1327,3025,7405,1667,8041},{0},{0,0,0,0,0,0,1079,3330,4870,9532,137,1172,9842,6403,3980,783,596,9843,4203,2388,2140,8873,5646,1474,6181},{0},{0,0,0,0,0,0,9887,3852,8390,6204,1438,389,1906,9527,8073,435,4752,6372,459,1150,5290,1028,3397,1005,9129,2461},{0},{0,0,0,0,0,0,1047,8067,333,8696,1011,923,2779,9786,12,3981,5373,9006,8905,2223,2610,620,9783,5553,7419,917,4922},{0},{0,0,0,0,0,0,5096,1719,2342,8880,158,5722,379,8613,8913,8043,6137,6251,911,5402,4887,882,1225,9871,412,8315,6756,9844},{0},{0,0,0,0,0,0,1932,8293,5772,5628,3725,5488,3714,939,5236,9261,2615,2761,776,6251,8858,6009,2371,1214,7429,5077,8506,3554,9787},{0},{0,0,0,0,0,0,568,5876,2412,8246,9086,3437,8418,2635,2562,4434,6244,5147,9735,8426,3847,2492,9156,4177,8771,2785,5557,707,6994,9673},{0},{0,0,0,0,0,0,120,1346,3485,8727,3432,8953,6434,3842,7269,5181,1344,4526,3878,6970,4703,5405,5323,678,4336,1865,8250,5360,8294,3859,9445},{0},{0,0,0,0,0,0,16,81,3100,2437,7097,6549,3588,324,6782,2931,9716,2225,8975,9747,3982,9787,762,9607,7823,3033,8524,9588,5978,417,7262,8989},{0},{0,0,0,0,0,0,1,955,6085,8085,4922,6589,7602,1007,5621,8696,9332,8765,7457,6014,5831,2377,8628,7811,2673,6522,1554,877,7262,5875,7640,3711,8077},{0},{0,0,0,0,0,0,0,3031,7409,8112,4761,6480,7801,3266,9690,7931,8329,1493,7605,9853,9680,5205,6888,4268,3727,5913,1134,5883,5550,7592,5938,8178,5598,6253},{0},{0,0,0,0,0,0,0,2574,6849,1269,7281,4584,1038,5744,4663,2208,8989,572,8605,7590,4562,9316,9615,8311,8872,672,6238,8626,2815,1900,1402,2139,328,7548,2605},{0},{0,0,0,0,0,0,0,2706,6761,7062,2312,3155,7031,5685,4036,1151,7801,4159,4198,8184,1750,2843,7240,6919,5081,6621,7457,2325,9401,4100,6841,6082,6556,4556,7800,5210},{0},{0,0,0,0,0,0,0,6230,1790,9601,8638,2491,7014,7524,9486,1748,5764,149,2228,2917,4153,5273,3546,5621,2084,6195,1967,7153,4280,9161,520,4442,1322,8019,9616,1008,519},{0},{0,0,0,0,0,0,0,2498,9616,1299,1113,9086,4682,1843,1836,5164,7548,2010,610,4427,8765,5862,5013,8736,3288,3894,9353,3827,9687,663,4008,1075,70,2174,8961,5648,2535,1038},{0},{0,0,0,0,0,0,0,909,2587,9477,2700,6544,5565,7127,4453,8557,2456,1274,2509,9416,626,4384,3411,3176,6102,6963,774,5774,3839,2271,5398,8144,256,6113,2045,5295,4449,6108,2076},{0},{0,0,0,0,0,0,0,7794,9608,5768,4676,6360,6111,4587,2775,1805,2471,6352,1120,4800,2487,4678,6852,6069,8395,4086,3566,8983,4969,6644,7833,6582,1473,73,9023,3495,8711,6143,4391,4152},{0},{0,0,0,0,0,0,0,7705,1425,3142,4958,6886,9794,3833,7606,5644,7542,7753,5415,3614,7068,7646,9496,280,2855,1236,8496,648,6834,7439,4903,3032,4435,2344,8697,7201,8013,2046,8852,3033,8304},{0},{0,0,0,0,0,0,0,9432,2035,6285,1050,7016,3542,220,9499,9447,3397,2490,9743,5191,7521,7835,6560,2338,6296,1571,1623,8203,2224,1856,6079,2204,4598,6969,6099,2822,559,2017,1685,5087,4469,6707},{0},{0,0,0,0,0,0,0,9459,3816,6656,9400,8469,7947,794,3769,1176,6971,5007,6414,2772,4081,2901,9628,4524,2610,5769,6156,6028,5564,8019,7142,6860,9206,9596,800,3427,2260,3133,4030,9893,3145,5744,3513},{0},{0,0,0,0,0,0,0,5468,1316,2040,2058,2312,5129,640,8532,3000,2023,3603,8984,1758,9262,1144,1335,1920,4932,1669,2799,2324,9727,5243,8032,3790,8715,9792,2562,6344,9488,5268,1496,361,4404,8840,5100,7026},{0},{0,0,0,0,0,0,0,9812,8455,9182,5976,5452,2865,5157,303,9299,5100,6725,9873,7619,6011,760,1705,4473,731,3683,7440,8204,5212,1128,2952,4734,7043,8827,2596,5628,1008,6343,4437,7604,9224,7103,6491,7325,4151},{0},{0,0,0,0,0,0,0,9175,6162,6831,1702,1587,4168,6019,6057,9861,7480,6963,8490,5046,2939,8216,1587,8055,7352,6713,601,6272,2586,2059,3072,1632,1357,3580,8691,1876,3269,3828,3624,1678,5410,206,3120,7531,8900,8302},{0},{0,0,0,0,0,0,0,2466,1185,7336,195,9267,393,9776,7237,3506,4350,878,967,9514,4135,6706,142,4957,9470,4923,240,3331,4258,3230,6017,3798,5209,3890,2352,285,5410,3316,3457,1503,8312,11,8085,5445,8311,6300,6703},{0},{0,0,0,0,0,0,0,8470,9495,3178,4124,5099,4271,9494,9536,7212,9507,1109,1,6452,1252,6667,4237,3461,2554,4033,9790,9789,8717,4110,1089,9060,3953,2615,4196,2733,5959,877,9817,6370,8813,1713,9782,9619,6700,1521,9402,3505},{0},{0,0,0,0,0,0,0,8479,7752,5788,1780,962,3391,7098,9491,362,3081,8180,7629,6534,4576,9109,8100,7668,9777,5827,4943,3655,7754,6055,6945,7351,445,4254,2597,4635,2387,3743,3452,3396,7128,8578,1706,6461,3497,8122,9246,2507,7010},{0},{0,0,0,0,0,0,0,4880,6165,1247,9673,4894,5010,9408,4951,7054,8217,1906,1920,6497,8590,4004,9473,1220,8427,6573,6555,9604,9337,4054,6795,9172,465,1229,678,4142,7797,6955,4362,3653,3399,3115,7421,332,3741,1440,8694,4702,2123,4119},{0},{0,0,0,0,0,0,0,5979,9738,3116,3142,8098,1046,7551,3508,2365,8380,2536,2626,2628,8510,3391,4481,6236,9325,1023,7642,3012,9507,400,3056,9698,2117,7150,2539,162,7513,8359,5332,2646,7646,680,7566,2672,5363,9398,3832,1904,8636,8365,8238},{0},{0,0,0,0,0,0,0,8097,6455,7501,5474,5538,4077,8796,7146,620,5293,1447,9037,5555,408,9276,9083,5391,9034,5261,4604,4808,8751,5454,2583,3566,4809,529,2491,6085,2014,3380,6411,9089,6751,2918,4955,7190,3918,7049,2547,7106,8785,53,5166,6575},{0},{0,0,0,0,0,0,0,7879,7216,6198,6651,2922,8374,8414,1968,7122,3283,5471,1548,6299,101,7320,1660,1760,5950,1356,1205,3471,5002,673,5946,9878,9424,4584,9734,7451,4938,5338,2620,1621,7301,7949,8696,5720,1521,3985,2199,5905,1622,4523,3609,7006,3249},{0},{0,0,0,0,0,0,0,1476,9547,6376,7231,6537,6065,6491,9673,2927,4352,8052,5176,8192,796,6288,9115,1578,3204,430,669,5265,7727,1570,2934,3176,2370,4832,1671,4808,383,665,1380,1210,1841,7099,4796,7499,16,6855,7626,9213,9630,5541,4594,997,7360,6498},{0},{0,0,0,0,0,0,0,8563,5342,6980,6485,1953,6930,3070,2520,2448,6694,9359,5645,1713,8074,5822,5429,3878,5716,5741,6126,1913,1169,7578,4050,1820,1805,807,2035,4544,2404,5378,9224,5887,6254,7668,7972,7350,5417,640,1216,4715,8629,208,1500,638,2702,1416,3095},{0},{0,0,0,0,0,0,0,5272,2317,8002,9485,2657,1843,6730,7111,2924,1971,9256,3400,9745,613,7700,3497,7294,661,4905,855,7215,2931,9373,4169,7729,9159,1137,4955,6682,5224,2173,4631,7552,7911,2175,9037,7204,2322,4947,8028,3595,2326,5594,6375,2017,7935,3417,5927,6190},{0},{0,0,0,0,0,0,0,2383,8703,678,1288,956,6031,8932,2016,3978,3461,4002,6053,6159,3874,5959,8090,2215,6683,3021,8906,7927,1292,2624,9615,1540,6206,1298,5564,6580,3241,9457,7919,7146,5669,932,9824,1047,5550,2086,4785,9584,6858,9237,9170,5865,6032,3996,5955,8143,2479},{0},{0,0,0,0,0,0,0,5720,6238,9811,2013,8094,9436,5774,2630,3741,1002,2232,1245,315,3414,6694,625,3960,6915,9193,601,2055,6939,7238,6934,3372,7888,9616,4309,3426,4398,2278,1493,4762,7551,6320,9766,5903,2213,238,7979,7614,5989,3345,8961,776,4476,5294,6262,6441,8864,4958},{0},{0,0,0,0,0,0,0,974,8002,7509,8487,8623,3593,8642,1598,2345,4959,4322,9499,2033,6579,4873,1617,5424,3167,4026,8207,5159,7467,6889,4054,3916,9799,6110,470,2080,6726,9649,1706,4201,2430,5614,826,6075,2789,1768,4585,8218,4322,7891,1727,9876,3710,4316,629,9785,4423,2884,15},{0},{0,0,0,0,0,0,0,415,642,4995,5237,8668,3192,5831,9254,5989,4679,1382,9039,2922,3658,1450,5172,1442,944,1155,8113,1740,6074,8992,5745,4156,1997,8132,6771,8904,6027,3734,366,1740,6557,6211,2702,2750,2196,9795,8434,9796,1252,9236,1184,507,4007,8114,1388,5314,8112,6787,5783,30},{0},{0,0,0,0,0,0,0,6737,4351,5618,565,301,9871,9647,2992,7881,7864,2724,8246,1555,8063,2007,4396,6504,1533,9718,334,6108,7565,1984,458,3270,3392,61,2035,1245,5109,4305,4304,3573,5682,4404,2382,9623,8438,5876,2968,6360,8687,7893,877,4414,4092,6156,6185,9617,3781,6108,9471,1695,60},{0},{0,0,0,0,0,0,0,4976,468,6078,6685,7879,5462,5191,7329,6704,1031,5463,4740,4390,6506,9866,1715,8022,9101,9428,8894,8222,3841,6718,5329,1802,3512,3845,4023,7802,7464,47,9361,1502,5590,6789,751,3688,7749,6709,9369,5135,8299,1059,6974,2178,848,3842,1217,7513,187,1510,7698,865,3450,120},{0},{0,0,0,0,0,0,0,496,2248,9826,7422,8245,5915,5406,4992,4612,282,7458,1583,1009,3232,9527,8537,3326,5876,1294,4984,8881,840,2287,5482,635,8039,8990,3932,2385,8480,5554,1054,1920,6000,5992,9426,1597,190,5430,9567,2199,6526,2413,1333,8331,8568,8424,3555,1643,8319,6388,2127,8115,5240,7020,240},{0},{0,0,0,0,0,0,0,32,3977,1806,731,9699,9337,5885,8514,7385,4355,7347,946,8314,8783,9407,4566,576,1629,6575,9864,4202,2477,1398,16,2392,7443,9645,6936,7615,9403,9266,4414,6414,8612,9544,4989,5812,3623,858,956,9895,1324,3753,1204,2657,9883,6244,7919,1944,9470,2467,1361,6873,5238,7719,4379,480},{0},{0,0,0,0,0,0,0,1,9843,7949,5129,939,6057,7089,5434,9434,7878,9351,3235,8638,7661,5460,9092,7688,2973,2957,3970,6956,3067,9659,1881,1752,1986,2452,5315,1753,5465,272,2536,7612,7469,9084,3522,8472,6889,431,6172,8912,4099,8222,1247,7284,9752,8876,7923,771,9470,1263,4250,8533,1721,5653,255,9238,960},{0},{0,0,0,0,0,0,0,0,3741,5871,5672,8754,5602,9518,5985,5804,5568,1046,2104,3974,8798,3746,4938,3142,9373,54,2788,6950,60,6277,6828,5378,7520,1203,4420,8933,6507,6002,45,8903,7662,4678,9183,1832,9378,4670,1586,1448,7911,9877,3358,3531,2074,4715,125,4350,6711,437,2598,144,3090,1751,6519,327,9535,1920},{0},{0,0,0,0,0,0,0,0,7132,2809,991,3282,6906,6986,6736,6310,9328,981,8073,6477,3931,5527,4459,6201,8218,9742,3351,6108,8903,5927,9041,1058,3552,8968,840,8689,9599,3268,310,6315,2549,9090,7334,5857,4685,2042,6176,3573,802,5713,9485,9165,4898,5573,2850,6642,2883,8168,9294,6939,3486,6396,432,3761,1248,1188,3840},{0},{0,0,0,0,0,0,0,0,783,6572,6685,611,6984,1823,8374,4794,8030,2801,1584,7142,5279,8030,5763,5005,5769,8847,6611,4509,5318,8502,9586,970,6575,957,7177,2352,1344,7536,6379,9587,8033,707,1119,5482,1430,9135,9431,793,6585,8779,4449,5848,3459,9862,132,7675,3950,1134,637,8206,8939,23,5904,6026,423,5604,6216,7680},{0},{0,0,0,0,0,0,0,0,6072,5457,7934,5337,196,9837,5820,2772,4312,5496,6879,9198,5309,150,3382,7125,6601,3510,56,8401,7025,999,3789,1376,3445,452,3736,6230,1333,3159,942,1443,7073,5501,8573,4417,4358,6590,7460,8083,8145,3217,9797,4280,665,7641,1446,3048,5568,238,4478,4420,6292,9463,2972,5852,7890,1577,1462,310,5459},{0},{0,0,0,0,0,0,0,0,1778,7795,7457,8741,2882,591,5142,8820,2726,2275,3096,3218,7993,5110,4339,2751,7617,5667,4897,8760,4944,2530,5612,6307,3391,856,7390,4926,6738,8358,1483,231,6595,7418,6346,589,6490,5213,2895,9133,8228,3926,4975,6983,4481,1743,826,791,5699,9107,5843,833,3556,9234,3201,8154,4420,5234,8611,1013,6079,1017},{0},{0,0,0,0,0,0,0,0,5533,1605,5002,1972,8748,3339,2187,6803,1431,5921,9256,5758,3770,8905,2013,5214,4129,2460,61,4465,2873,8973,1331,3141,1224,9866,685,9793,2007,5129,3108,2487,8943,7061,7544,5218,4854,7352,8546,6141,702,4476,5743,5683,1367,4505,987,4903,6502,9840,6785,6845,219,7007,9691,2248,1593,273,2668,4202,3663,3274,2034},{0},{0,0,0,0,0,0,0,0,2991,3797,2656,7976,7853,6840,4385,4229,630,2986,6506,3373,2869,6455,8483,8636,8586,8796,5122,8352,7742,2844,5582,1335,3919,6093,1401,299,6925,4230,432,150,7670,5392,4715,988,1503,1936,4258,8811,3240,1718,628,3154,3138,3346,1224,4230,4512,9214,2321,4886,2434,7191,3605,8885,8709,8426,579,66,9262,1716,8582,4068},{0},{0,0,0,0,0,0,0,0,4415,1865,8223,796,8469,7963,9755,7665,6812,497,39,4996,2218,9678,7370,705,1336,796,4070,2855,7728,6670,822,4273,980,1817,390,6358,8061,4159,4488,1957,2186,3772,6567,1467,3876,3800,1588,5333,3535,1529,9900,3027,3542,4369,6087,8691,2585,8052,7957,8761,8238,6833,3930,8799,3178,519,5806,7611,3005,5746,4147,1430,8136},{0},{0,0,0,0,0,0,0,0,8829,6688,809,3327,8357,469,9553,6111,5049,9575,6321,3885,5729,1479,9306,8783,9376,5648,7452,9223,1552,8745,7235,7615,4947,3976,994,7038,5521,2227,9445,2254,6358,4888,1032,6778,7090,8312,1120,6842,7332,3233,2227,8239,6581,1054,7742,7909,1371,7582,4824,7143,2260,9080,5010,2490,9062,2730,2649,3222,3022,5303,8487,3891,1095,6371},{0},{0,0,0,0,0,0,0,0,3654,3499,5196,398,9091,442,92,5122,110,2059,3483,212,9701,2577,1579,8853,1482,5395,1008,1911,5457,2560,2619,136,3381,5685,1352,6636,9006,1104,5693,8849,9621,325,4921,191,6155,5000,1442,9240,4099,632,1639,247,1487,9622,2821,1426,1587,1241,6899,3272,7050,5330,1620,6524,2909,5759,4973,8927,7258,1628,1069,728,7112,8561,2841},{0},{0,0,0,0,0,0,0,0,7804,9133,4366,226,4918,1747,2591,7227,3794,79,5933,924,3366,8278,4383,7347,3574,4233,9403,7572,475,6493,3644,1786,6869,9546,6446,4047,7592,1615,1470,1790,610,5428,2075,2850,5818,971,7025,3951,2134,6912,7329,2229,7803,4717,3486,8088,4892,4080,1812,8561,9328,5568,2738,3958,1436,6479,1322,9311,8631,1356,3383,254,6133,9354,161,5682},{0},{0,0,0,0,0,0,0,0,4231,7156,5921,6722,501,7869,1887,6743,9738,5388,618,8688,448,583,6854,3837,6740,3761,5633,1592,4467,9508,7228,6298,1763,7281,2528,6934,9565,9470,4633,9074,8049,8938,5535,9160,119,8640,3909,3934,9471,3138,7641,7436,5358,1800,2091,5116,6189,9729,9791,3262,9177,3912,215,7861,4770,3609,1474,6735,8182,8823,2924,424,7118,3319,1908,6004,1463},{0},{0,0,0,0,0,0,0,0,3419,6489,6770,5132,1317,9439,1873,3955,6438,4803,1540,2442,7447,4795,1184,6737,4456,7651,2232,923,1689,6498,5881,3666,3401,5485,9680,7522,6859,5463,8979,7064,222,3752,5011,3973,5608,4279,8082,1406,6978,8121,8061,3570,6279,2616,3602,4,1545,2428,9803,492,1424,9602,2298,8750,6739,1836,4394,4253,2610,7983,3040,491,9088,6579,4488,5601,3570,2926},{0},{0,0,0,0,0,0,0,0,4068,9413,9809,3865,618,9755,105,5719,8107,4499,2197,6129,4189,1885,1375,6558,5066,4985,4837,8269,2107,9224,1742,1441,3775,1722,2019,8354,4583,3308,2299,7003,8195,961,1034,6862,3581,1171,9613,2110,1595,7467,6824,966,9292,4304,3294,6025,7543,5169,4158,8505,7501,3133,570,2336,5381,5465,3776,208,2642,8074,5708,9187,6214,563,4378,2242,6334,165,5852},{0},{0,0,0,0,0,0,0,0,6718,7800,961,8458,8924,1603,5496,5343,8896,8856,7564,9787,7759,8035,3125,1442,5213,8136,6773,668,1130,5859,1405,4978,3525,2390,8861,4166,7978,9241,1094,1035,8701,3845,4613,5382,6628,5610,6797,8910,9071,9702,3123,6081,4668,5472,3479,9544,5912,7526,4682,8490,348,6280,2358,2085,1890,4337,6952,1945,8588,6443,2318,2043,1056,4968,4882,7512,7413,5858,6182,1803},{0},{0,0,0,0,0,0,0,0,2144,9100,1718,6743,4401,9726,2023,5031,2911,6202,849,6684,2113,6845,1718,1661,3346,3967,1750,7163,3761,9209,4860,4198,328,9215,5839,459,5437,8824,9025,5743,5539,778,8159,938,3226,4726,2742,2846,8207,576,4472,9740,6988,9454,236,8287,2658,6744,9642,8982,9137,4116,6840,8362,7292,6244,4928,2409,6713,5646,6643,7316,5360,2548,872,1674,3622,6899,3948,4266,3606},{0},{0,0,0,0,0,0,0,0,5251,6328,4900,5354,1459,4050,8026,1705,8833,3529,8137,999,1827,6144,719,4990,2727,4027,3499,7943,1491,2683,4967,2331,8804,4556,4222,6744,5465,5925,4289,661,992,802,1270,9329,5824,7896,2888,6674,2380,3277,3429,4554,1121,2886,7523,6933,3021,2597,4463,1752,4540,2855,8766,1068,4479,5213,1060,6847,3883,8031,9012,5341,3912,8263,4987,9683,5977,5258,5929,4064,2237,7212},{0},{0,0,0,0,0,0,0,0,2572,6926,2413,7755,1606,371,4085,3831,1912,4628,4050,8466,596,6162,6920,3102,6611,6403,3065,444,7879,6910,9564,1164,2890,8837,1626,1125,1752,5374,5068,866,5096,3016,3069,241,5303,2993,2492,3103,4555,2216,4813,6419,9023,9731,5077,8511,6732,5534,8885,7382,6813,6618,4977,8435,1608,8845,9675,8399,2657,7629,9627,6932,7519,3575,1403,9358,8669,8309,2611,3992,4070,1785,4523},{0},{0,0,0,0,0,0,0,0,1543,8803,1203,6449,3610,3007,56,9429,5352,9688,5415,9221,2385,3656,6572,9023,7913,5327,1665,8476,9746,9262,2199,4901,6664,3125,1093,6989,7441,9640,8456,426,4723,5281,5766,2170,1965,2966,4522,6973,3978,5445,2571,6179,3007,140,3792,8264,6121,7901,8676,5117,4397,8969,587,4405,8704,3470,508,5240,1483,8974,7320,3926,8948,69,9666,5032,4452,1175,7278,1122,1701,7236,8093,9046},{0},{0,0,0,0,0,0,0,0,282,1900,8003,4344,4739,5804,8218,982,2842,1796,1759,7584,9371,159,1716,6249,418,2073,4938,3369,5345,5467,4876,7697,3009,4846,1983,6053,2543,6009,9783,6649,908,8359,5132,5776,7435,6190,4520,7077,5967,3844,1677,1376,2369,9725,7422,4383,3499,3645,2608,3315,1629,2592,7398,8623,4997,2275,9338,4796,7560,4061,2190,8088,6698,7593,9097,8017,7073,3919,9832,5063,816,7045,7286,5430,8191},{0},{0,0,0,0,0,0,0,0,789,8882,9133,8973,6382,7873,3435,9603,5715,3458,6625,2196,1224,7221,8743,3901,6660,3575,8340,9849,4614,4196,8592,6324,5806,5936,4802,6666,555,195,1417,3353,914,5475,2759,5624,9719,6235,2532,106,1934,5263,6460,7445,8182,959,2343,5390,894,4058,4021,3363,6195,9031,1645,2823,5757,6725,3363,7527,7405,5527,616,4790,820,8892,893,1117,5450,8535,8580,1484,3244,6038,8812,9246,9150,6481},{0},{0,0,0,0,0,0,0,0,896,3127,5223,6821,5190,8829,138,2757,7342,7252,8727,525,2322,3006,7486,9500,5028,3847,4314,8595,3617,2515,1815,4968,9352,2014,469,8343,4186,2027,9493,2137,397,707,824,5443,4527,2940,6608,8078,6028,1731,5627,103,4069,8061,3196,2556,5641,9524,5571,4811,3439,3327,1676,6832,7084,2876,2526,7855,2258,4111,8305,4403,6342,3425,3570,1275,8879,3389,4780,5123,5629,5322,7569,887,6130,4979,3061},{0},{0,0,0,0,0,0,0,0,9659,7992,8225,7364,1429,1120,5322,137,1274,3782,4211,2538,8696,3693,812,2184,5281,1331,7928,5931,2966,6715,3491,8786,3101,6136,470,1543,4228,6990,224,5912,7211,9330,4718,3232,5563,9005,9803,7846,9062,5614,6918,6912,1217,2022,7570,2698,2513,4703,6644,4895,7308,5273,6691,74,3345,9065,9596,7688,5272,8827,8622,800,7984,8257,1047,8196,2112,9025,2336,1017,2716,4742,6770,2153,3733,3918,3118,6122},{0},{0,0,0,0,0,0,0,0,7671,7921,2731,1389,8538,2323,5695,9761,8535,7141,7159,3108,3029,8388,7063,9710,4991,7328,7376,2856,1291,7982,30,7238,9046,4985,584,2588,468,5479,1063,9662,8500,3278,716,1166,717,3492,755,5094,679,9578,2710,2766,7563,7280,9692,1395,2213,3535,6919,4927,3080,6382,3334,5378,3794,7292,1204,5752,2823,4597,7908,310,5736,8272,4410,5495,6802,622,2697,8898,8452,2935,4907,747,4117,9523,4114,2457,2343},{0},{0,0,0,0,0,0,0,0,8084,9526,4120,887,7949,8774,1485,3322,5316,5247,1951,751,8184,9619,2058,3878,4271,3907,5451,8919,8770,3306,1991,9535,345,8130,5318,8050,426,9347,7707,4268,2717,1008,6604,4229,2566,3326,5523,6979,1037,1500,284,1860,2781,4399,8249,7180,5295,5010,1168,7998,8122,6437,554,5283,7131,2651,27,589,6263,9320,7348,6209,588,9837,6631,9877,2114,2050,6595,801,715,5442,6779,1818,3810,4632,2697,6906,7257,4686},{0},{0,0,0,0,0,0,0,0,9215,3999,6272,4098,432,6289,3965,9692,1589,8855,9843,3548,8128,939,7478,787,7589,3746,5318,5085,1521,1669,4456,6812,8470,7486,7587,8067,8404,7284,7941,8797,8556,7048,5441,3628,2468,942,1758,4799,7308,6502,8856,1811,2486,7433,3742,9690,6186,3454,5530,921,7071,1952,1119,6193,269,9109,9496,8388,6767,1277,7205,6833,4076,3118,3884,8024,9326,8847,9238,375,4073,4942,7024,2181,6949,6626,7913,7199,3610,9299,9372},{0},{0,0,0,0,0,0,0,0,4046,4762,8948,4754,9251,3896,7582,5294,959,6722,4885,9271,7377,5865,2484,2409,2797,1624,3109,4264,4041,2288,3439,6344,2039,7606,3253,5262,2652,3673,9466,9186,7188,1997,311,4586,9549,2513,1241,5141,3250,7106,4782,3358,995,4647,9251,8572,2176,5196,5450,6985,1751,9719,1055,4203,3930,2890,4704,2675,6970,190,3015,922,2727,7825,9247,6022,6409,524,3348,1011,4674,7848,9305,8743,9192,9660,1425,6049,248,1403,8168,8843},{0},{0,0,0,0,0,0,0,0,2461,6091,761,2346,6787,2405,7756,7669,3363,399,2729,3472,5978,7723,7156,807,7783,8332,7739,796,9726,4971,9015,2365,1963,179,2964,7971,9179,247,5213,2398,6345,8863,5372,8922,6034,4102,8789,6212,6402,2141,1183,3645,7964,2496,1012,3238,9076,3666,8529,6175,451,2665,8227,7281,441,3872,1925,2191,5368,36,1895,3030,3901,4114,7221,2944,8504,2821,9709,7421,1450,8757,8719,5848,4179,3089,9014,9091,2581,768,544,5377,7785},{0},{0,0,0,0,0,0,0,0,6180,2435,4264,2391,3045,2632,69,5445,4248,7725,2314,6231,8719,5689,2440,874,8056,1518,445,794,1571,1299,5341,1062,1285,8972,4985,4374,564,9394,7085,5377,6862,884,4444,5374,4771,1970,1523,4355,7047,9048,2389,6115,7498,416,8580,7176,403,7656,8711,2758,1103,7209,2713,4667,6129,2936,4108,2629,7459,6154,737,1330,4981,7743,9783,3110,7039,2302,291,9100,9067,8252,803,6182,7191,891,4868,7281,8209,9757,9190,5407,8638,5669},{0},{0,0,0,0,0,0,0,0,7658,1319,343,76,3743,8042,1043,4255,6705,7412,9221,4000,4423,3029,6899,8522,8536,8080,4554,5059,9866,7293,9259,5745,2826,9496,8145,338,6536,5374,2738,4719,4988,140,8956,1812,1879,1860,7156,4237,3648,5446,2506,8424,7292,25,9662,7759,1000,2999,4386,7851,660,189,5867,2700,4449,131,5449,9055,1678,2741,5349,5884,8820,2419,4716,8163,6897,1354,4255,9203,7341,7985,9405,5604,7996,1165,3269,2974,6278,3234,3335,7246,7435,3143,1437},{0},{0,0,0,0,0,0,0,0,9647,5968,7768,7629,9631,6957,302,4283,6355,4690,6764,3376,1898,6677,7580,7519,5027,4482,9598,4012,7132,1622,8408,5550,6844,7539,4940,996,8036,1292,3414,1811,7391,8352,8533,4824,4455,9683,5311,476,7798,5344,5997,111,99,6106,2846,5592,2239,3145,2290,2485,7228,2854,3068,5380,7094,3388,8782,7139,2383,8150,9588,8212,4929,6124,6671,3666,8270,3690,9495,3673,227,3246,6831,1524,5032,7450,2718,776,8278,4660,4010,4985,6531,3880,7723,2874},{0},{0,0,0,0,0,0,0,0,6565,478,61,8228,9574,8931,5997,3572,5522,4894,8493,150,4984,7789,4587,2912,8665,4072,4305,3814,8746,6105,3084,2727,9189,9138,3851,5846,3248,3967,2967,4241,8562,1517,2765,6322,7022,5358,1801,6561,8089,8696,8876,6277,8368,6391,2485,348,9114,5761,2566,2453,5647,1354,3499,5483,8595,5571,2568,1485,7446,6138,2744,2591,6434,9723,9631,4667,2452,141,6806,8753,9229,3766,6624,264,2907,9619,9011,8024,5176,7248,1186,3534,929,1720,7019,8419,5748},{0},{0,0,0,0,0,0,0,0,2115,2790,3021,1224,7544,5212,6542,9253,9602,1500,3978,3020,6570,4645,7912,7359,2934,5026,8042,839,1744,6733,8118,1737,4510,8355,2013,8675,2497,1944,6965,364,4031,4963,1120,1078,4070,3481,1266,9706,6639,7079,4433,3785,1769,8133,2596,9331,8722,6151,5549,7856,5448,1084,9283,3249,2403,2676,675,8769,7266,8592,7202,9654,8332,6300,6666,4143,9366,64,221,9779,2235,9062,1010,6758,6822,2687,3647,8422,602,8712,6621,4052,3360,2485,1254,5529,2784,1595},{0},{0,0,0,0,0,0,0,0,5217,7717,6909,8537,6895,2069,5308,5710,5674,376,4390,7446,7859,3726,662,9052,1721,1530,4883,2458,3864,49,8312,3458,475,4953,8312,315,3419,3839,8489,9477,4293,1770,1617,161,535,8103,8273,3946,3133,9525,8417,14,2098,8858,739,8550,6716,5811,6437,8072,3849,5977,63,5691,3953,4811,10,9118,5635,5897,2532,399,1693,4374,5123,4848,2834,8898,134,12,9041,8669,8398,350,6561,5892,4298,7749,910,7736,3163,1181,5581,4855,6171,2402,9689,7163,3190},{0},{0,0,0,0,0,0,0,0,6571,8931,1182,5086,526,5861,164,6180,73,5973,5271,2000,6913,8108,1837,8489,6194,4068,3668,3879,8866,5895,1649,875,1032,1638,9847,1004,1861,2784,7984,9680,9897,6741,4785,7873,4358,1065,351,8538,3835,7194,3647,3502,3039,6022,3652,1575,194,5792,4522,5602,5258,7931,466,6727,3301,3640,1369,3296,6552,6335,31,6177,2226,2856,8841,186,9583,9675,8014,238,9841,9733,3104,1235,8482,5663,4884,6002,4713,8133,2725,4209,5667,6610,797,1976,8971,8334,7615,6380},{0},{0,0,0,0,0,0,0,0,7452,3593,1759,1854,8739,5110,1302,8540,9054,7183,9817,802,5071,9605,1143,5689,375,4413,3929,6357,9894,6017,5056,5508,9655,6802,7138,4757,8440,6633,2886,406,4054,8766,2660,6071,1899,6513,4479,4345,5784,9238,3080,2376,6445,8783,5410,6534,8361,521,266,7067,5947,9288,7445,2968,4072,1038,8674,2788,100,6818,7230,8922,7819,831,2659,3795,1929,3114,7500,6003,9653,8453,7245,5261,8007,1173,8022,3293,6852,9498,144,7360,3820,705,8445,351,7415,6926,7671,1808,2859},{0},{0,0,0,0,0,0,0,0,1169,9665,1664,6936,5891,1384,2988,6163,8451,3961,3018,7686,235,8233,4352,6221,4718,1700,2530,1093,6910,9439,3068,6711,4874,5350,4468,3733,8082,7923,912,9526,9129,2547,7797,5353,9365,3051,6307,9293,9434,8553,4494,7276,3709,7815,9652,3974,6110,5886,8031,4077,7090,5714,7442,7435,4892,7813,9239,4425,3857,6463,2625,7681,6244,6503,1532,9641,8646,2112,6409,362,427,6545,4181,4253,9229,7315,2404,116,7748,2324,6943,5597,717,1697,7916,3111,2145,2886,5815,3728,6475,5718},{0},{0,0,0,0,0,0,0,0,6750,7356,4981,6064,7449,1542,9517,5911,5096,6243,437,6958,1435,1654,4953,5738,6941,8419,9296,7890,6530,2461,9352,1266,8509,3006,8169,776,245,5872,4917,9432,2589,9298,7755,9791,6290,366,6694,796,7240,6645,1008,1029,4275,4966,4997,8437,7969,42,5347,6952,1582,6658,4758,6462,2958,5879,2091,2633,7914,8029,630,5111,9623,8324,1573,6837,7546,6231,7581,6714,7594,3839,5970,5562,4301,1491,5670,1882,4049,7634,4078,8761,9552,6617,465,4043,6125,9707,933,223,6889,8767,1535},{0},{0,0,0,0,0,0,0,0,7223,7793,3253,7529,6790,5622,5212,5688,6390,4621,8568,1913,7023,5282,8518,2800,6415,8458,3965,5854,2320,1448,65,6693,4392,158,1604,9269,235,6888,8913,8147,5277,6247,9718,2853,5795,2071,3907,7133,7524,6049,800,6224,5979,5384,3569,7076,4065,4085,5997,1925,2264,6423,6518,6206,3281,516,9002,4389,414,197,8342,4370,6220,1897,4906,6219,6146,4746,9011,2999,5377,3700,6727,7999,2019,1592,5782,5600,8322,9116,2036,3239,67,4694,883,5001,8142,112,5427,1729,9627,8461,9168,3070},{0}};

inline int read()//快读 
{
    int x = 0 ,y = 1;
    char c = getchar();
    while(c > '9' || c < '0')
    {
        if(c == '-')y = -1;
        c = getchar();
    }
    while(c <= '9' && c >= '0')
    {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * y;
}

int main()
{
	n = read(); k = read();//输入
	if(n % 2 == 0)//特判
	{
		cout << 0;
		return 0;
	}
	cout << p[n][k];//输出
	return 0;//好习惯
}

```


---

## 作者：QWsin (赞：0)


<http://blog.csdn.net/QWsin/article/details/52905140>

dp（i，j）表示i个节点深度为j的树有多少个。那么如果直接转移的话，需要先枚举左子树节点个数k，和一个dep（因为至少有一个子树的深度为j-1）然后如下转移。


dp（i，j）=sigma（dp（k，j-1）\* dp（i-k-1，dep））+s igma（dp（k，dep）\* dp（i-k-1，j-1））


注意：根据dep的枚举方式会有算重的或者算漏的要处理一下，上面只是个大概思路

复杂度明显过高。引入新数组 f（i，j）表示i个节点组成的深度不大于j的个数，那么方程大幅简化，分三种情况，因为至少有一个子树的深度为j-1，所以要么左子树深度为j-1，要么右子树是，要么都是。


dp（i，j）=dp（k，j-1）\* f（i-k-1，j-2）+f（k，j-2）\* dp（i-k-1，j-1） + dp（k，j-1） \* dp（i-k-1，j-1）

然后可以看见只需要枚举k，复杂度n\* n \*k


```cpp
//QWsin
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
const int MOD=9901;
const int maxn=200+10;
const int maxk=100+10;

ll dp[maxn][maxk],f[maxn][maxk];

int main()
{
    int n,K;cin>>n>>K;
//  实际上数据没有n为奇数的 
//    if(n%2==0){printf("0\n");return 0;} 
    dp[1][1]=1;f[0][0]=1;
    for(int i=1;i<=K;i++) f[1][i]=f[0][i]=1;
    for(int i=3;i<=n;i+=2)//共n个节点 
    {
        int j=1;while((1<<j)-1 < i)j++;
        for(;j<=K;j++) //深度 
        {
            for(int k=1;k<=i-1;k+=2)//枚举左子树节点个数 
            {
                dp[i][j]+=dp[k][j-1]*f[i-k-1][j-2];
                dp[i][j]+=f[k][j-2]*dp[i-k-1][j-1];
                dp[i][j]+=dp[k][j-1]*dp[i-k-1][j-1];
            }
            dp[i][j]%=MOD;    
        }
        for(int j=1;j<=K;j++) f[i][j]=(f[i][j-1]+dp[i][j])%MOD;
    }
    printf("%lld\n",dp[n][K]);
    return 0;
}

```

---


# 数位平方和

## 题目描述

定义 $S(n)$ 表示 $n$ 的各个数位的 $k$ 次方的和。

定义 $H(n)$ 为满足 $H(n) \le \min\{n, H(S(n))\}$ 的最大值。

求$\sum_{i=A}^{B} H(i) \bmod (10^7 + 7)$。

## 说明/提示

对于 $20\%$ 的数据，$A, B \le 50$。  
对于 $100\%$ 的数据，$1 \le A, B \le {10}^6$，$1 \le k \le 6$。

## 样例 #1

### 输入

```
2 1 5```

### 输出

```
14```

# 题解

## 作者：_Lemon_ (赞：17)

先膜拜一下楼下的大神,可伶的我今天考试果断爆零了

不多BB,我们进入正题吧

首先如果小伙伴们直接打的递归的话就会发现会陷入死循环,

那么我们就想到了记忆化搜索,然后环上的点的H值就是环上最小的值

如果某个点访问了两次,就说明出现了环

但这时我们还需要再绕着环走一遍(也就是访问到第三遍)

因为只走一圈的话就会导致这个点没办法跟新到环上最小值

然后大家可以先处理出来1-9的k次方,让程序跑得快一点.

然后上代码:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<queue>
using namespace std;
const int mod=10000007;
long long h[4000005],s[4000005],small;
int lemon[10],k,cnt;
int vis[4000005];
long long q[4000005];
void solve()
{    
    for(int i=1;i<=9;i++)
    {
        int w=1;
        for(int j=1;j<=k;j++)
            w*=i;
        lemon[i]=w;
    }
}
long long get_s(int x)
{
    if(s[x]) return s[x];
    int w,all=0;
    while(x>0)
    {
        w=x%10;
        all+=lemon[w];
        x/=10;
    }
    return s[x]=all;
}
long long get_h(long long x)
{
    if(h[x]) return h[x];
    if(vis[x]==2) return x;
    vis[x]++;
    s[x]=get_s(x);
    h[x]=min(x,min(s[x],get_h(s[x])));
    vis[x]--;
    return h[x];
}
int main()
{
    freopen("count.in","r",stdin);
    freopen("count.out","w",stdout);
    int a,b;
    long long ans=0;
    cin>>k>>a>>b;
    solve();
    h[1]=1;
    for(int i=a;i<=b;i++)
    {
        cnt=0;    
        ans+=get_h(i);
        ans%=mod;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：VictoriaEVA (赞：6)

题目要求在指定的 $k$ 下，$A$ 至 $B$ 所有整数 $i$ 的 $H(i)$ 之和。

显然 $S(i)$ 易求，那么我们的主要要解决的问题就是如何求 $H(i)$。

我们来看关于 $H(i)$ 的定义：$H(i)$ 为满足 $H(i) \le \min\{i,H(S(i))\}$ 的**最大值**。

易想到通过递归求解，但是可能发生循环，举例：

当 $k=3$ 时，

$H(55)=\min(55,H(250))$，

$H(250)=\min(250,H(133))$，

$H(133)=\min(133,H(55))$。

事实上，我们注意到这些数发生循环时，所有数中的最小值即所有这些循环的 $H(i)$ 的值。

由此，我们得到了循环的解决方案：记忆化搜索（用于提高效率）+记录每个数的访问次数（用于判断是否循环）。

这里发现有两个易错点，别的题解并没有解释或讲得不是很易于理解

注意点一：本题的数据范围是 $1 \le A,B \le {10}^6$，$1 \le k \le 6$，但是在定义记录 $S(i)$，$H(i)$ 以及每个数的访问次数这三个数组时，如果你只开了 $10^6$ 的空间，那么你会喜提 **RE** 50pts（别问我怎么知道的），这是因为本题中出现的最大数并非 $10^6$，而是 $S(999999)$，即 $3188646$。
解决方法：需要定义更大的空间。

注意点二：当我们发现在数 $x$ 时出现循环时（即递归时发现 $x$ 访问次数已经为 $1$）此时我们不能直接回溯，因为如果 $x$ 并非循环中的最小值，那么 $H(x)$ 将无法获取到正确的值（即循环中的最小值），因为递归已经结束，而最小值在 $x$ 的上方。
解决方法：当发现访问次数为 $2$ 时再回溯。

上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int Mod=1e7+7;
const int M=4e6+5;	//注意空间问题 
double w[10];	//记录 1 至 9 的 k 次方，因为使用了 pow，所以要用浮点数储存 
int k,a,b;
int ans;
int s[M],h[M],fg[M];	//分别记录每个数的 S 值，H 值，以及被访问次数 
int gs(int x)	//获取 S(i)，很简单，就不多做解释了 
{
	if(s[x]) return s[x];
	int o=x,res=0;
	while(o)
	{
		res=(res+(int)w[o%10])%Mod;
		o/=10;
	}
	return s[x]=res;
}
int gh(int x)	//获取 H(i) 
{
	if(h[x]) return h[x];	//记忆化 
	if(fg[x]>1) return x;	//如果已被访问过，说明进入了循环，那么直接通过递归回溯找到最小值 
	++fg[x];	//记录访问次数 
	return h[x]=min(x,gh(gs(x)));
}
int main()
{
	scanf("%d%d%d",&k,&a,&b);
	for(int i=1;i<10;++i) w[i]=pow(i,k);	//计算 1 至 9 的 k 次方，可以略微提高效率 
	h[1]=1;
	for(int i=a;i<=b;++i) ans=(ans+gh(i))%Mod;
	printf("%d",ans);
	return 0;
}
```

---

## 作者：kakakaka (赞：5)

也许是noip考前的最后一篇题解...

很暴力的解法，把每一个数都看作一个点，那么我们可以从一个数的每一位来得到它的下一个数，并向下一个数连一条有向边。

这样我们就得到了一个有向有环图，那么题意就变成了从一个点开始，一直向下走，所经过的所有点的最小值（包括环）。

考虑tarjan缩点，统计一下每一个强连通分量（也就是环）上的最小值。

很显然环上是没有出边的，我们将所有边反向，从入度为0的分量开始拓扑，一路上不断更新路径上的最小值，那么这样就统计出来了每一个点一直向下走，所经过的所有点的最小值。

然后把题目要求的点加在一起输出就可以了。（我用的是前缀和）

另外不要怀疑这道题会因为点过多而超时，考试的时候我输出来看过，当k=6时，以1～100000分别为起点，所经过的数的最大值是3188...（反正是个七位数），还是可以承受的。

时空复杂度O（能过）

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<queue>
#define mod (10000007)
using namespace std;
int n,t[10];
bool vis[3200005];
int suan(int x){
  int ans=0;
  while(x){
    ans+=t[x%10];
    x/=10;
  }
  return ans;
}
int to[3200005];
void dfs(int r){
  if(vis[r])return;
  vis[r]=1;
  int Next=suan(r);
  to[r]=Next;
  dfs(Next);
}
int dfn[3200005],low[3200005],sccno[3200005],scc,dfscnt,mmin[3200005];
int s[3200005],top;
void tarjan(int r){
  dfn[r]=low[r]=++dfscnt;
  s[++top]=r;
  int y=to[r];
  if(!dfn[y]){
    tarjan(y);
    low[r]=min(low[r],low[y]);
  }
  else if(!sccno[y])low[r]=min(low[r],dfn[y]);
  if(low[r]==dfn[r]){
    scc++;
    int x;
    while(1){
      x=s[top--];
      sccno[x]=scc;
      mmin[scc]=min(x,mmin[scc]);
      if(x==r)break;
    }
  }
}
struct node{
  int next,to;
}edge[3200005];
int size=0;
void putin(int from,int to){
  size++;
  edge[size].to=to;
  edge[size].next=dfn[from];
  dfn[from]=size;
}
void bfs(){
  queue<int>mem;
  for(int i=1;i<=scc;i++)if(!s[i])mem.push(i);
  while(!mem.empty()){
    int x=mem.front();mem.pop();
    for(int i=dfn[x];i!=-1;i=edge[i].next){
      int y=edge[i].to;
      mmin[y]=min(mmin[y],mmin[x]); 
      s[y]--;
      if(!s[y])mem.push(y);
    }
  }
}
int main(){
  int i,j;
  scanf("%d",&n);
  memset(mmin,127/3,sizeof(mmin));
  for(i=0;i<=9;i++)t[i]=pow(i,n);
  for(i=1;i<=1000000;i++){
    dfs(i);
  }
  for(i=1;i<=3200000;i++)
    if(!dfn[i])tarjan(i);
  memset(dfn,-1,sizeof(dfn));
  memset(s,0,sizeof(s));
  for(i=1;i<=3200000;i++)
    if(sccno[i]!=sccno[to[i]])putin(sccno[to[i]],sccno[i]),s[sccno[i]]++;
  bfs();
  low[0]=0;
  for(i=1;i<=1000000;i++){
    low[i]=mmin[sccno[i]];
    (low[i]+=low[i-1])%=mod;
  }
  int l,r;
  scanf("%d%d",&l,&r);
  printf("%d\n",(low[r]-low[l-1]+mod)%mod);
  return 0;
}

```

---

## 作者：Ristear (赞：2)

### 题面解释

---
定义:

$S_i$ 表示 $i$ 的各个数位的 $k$ 次方的和。

$H_i$ 表示 $H_i\le\min(n,H_{S_i})$ 的最大值。

求 $\sum_{i=A}^B H_i\bmod (10^7+7)$。



### 题解

---
首先，因为对于最大的 $k$ 与 $i$，$S_i$ 不会超过 $31886460$，所以我们可以考虑枚举每一个 $H_i$，并且每次计算时将 $H_i$ 与 $S_i$ 纪录下来，从而优化时间复杂度。

对于 $S_i$ 的计算，我们可以提前处理 $i^k,i\in(1,9)$ 以优化 $S_i$ 的计算。

同样我们如果推一些数据，比如 $k=1$，$i=2$，那么结果会有 $H_2\le\min\ (2,H_2)$，这种情况显然 $H_2=2$，但是如果用递归处理会导致无限递归，因此我们可以标记每个数重复出现的次数，使重复递归的 $H_i=i$，从而防止这种情况的出现。


### Code

~~~cpp
#include <bits/stdc++.h>

using namespace std;

const int mod=1e7+7;
int ans;
int L,R,k;
int P[10];

int S[3200010];
int H[3200010]={0,1};
int v[3200010];

//通过预处理i^k来优化计算S[i]
void init()
{
	for(int i=1;i<=9;i++)
	{
		P[i]=1;
		for(int j=1;j<=k;j++)
		{
			P[i]*=i;
		}
	}
	return ;
}
//计算S[i]
int get_S(int x)
{
	if(S[x]) {return S[x];}
	int T=x;
	while(T)
	{
		S[x]+=P[T%10];
		T/=10;
	}
	return S[x];
}
//计算H[i]
int get_H(int x)
{
    if(H[x]) {return H[x];}
	if(v[x]==2) {return H[x]=x;}v[x]++;//防止出现无限递归
	return H[x]=min(x,get_H(get_S(x)));
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>k>>L>>R;
	init();
	for(int i=L;i<=R;i++)
	{
		ans+=get_H(i);
		ans%=mod;
	}
	cout<<ans;
	return 0;
}

~~~

---

## 作者：naught (赞：2)

## Step 1： 

“定义 $S(n)$ 表示 $n$ 个的各个数位的 $k$ 次方的和。”

数位的 $k$ 次方，我们可以通过快速幂求出，为了节省时间，我们可以定义一个 $a$ 数组，来表示 $0\sim9$ 区间中各数字 $k$ 次方的值。

然后我们通过定义一个 $s$ 数组来存储 $0\sim4\times10^{6}$ 区间中各数字的 $S$ 值。

## Step 2：

“定义 $H(n)$ 为满足 $H(n) \le \min\{n, H(S(n))\}$ 的最大值。“

关于这个，不难想到通过递归求出 $H(n)$ 的值。

但是，进行手动模拟后不难发现，有些时候直接将 $H(i)=\min{n,H(S(i))}$ 会造成死循环。

例子：当 $k=2$，$n=2$ 时，求 $ H(2)$ 即求 $ H(4) \Rightarrow H(16) \Rightarrow H(37) \Rightarrow H(58) \Rightarrow H(89) \Rightarrow H(145) \Rightarrow H(42) \Rightarrow H(20) \Rightarrow H(4) \Rightarrow H(16) \dots $　 

显然，这形成了一个环，此时不难想到“环上最小值就是整个环相同 $H$。”

所以我们可以通过定义一个 $mark$ 数组来表示个点的访问次数，若 `mark[i]==2` 则说明出现了环，那你就再走一次去寻找并更新环上最小值。

这时不难想到通过定义一个 $h$ 数组来实现记忆化搜索，又省了一些时间。

## Step 3：
此时你会发现题目已经做完，剩下仅需处理一些细节同时略微整合一下代码便可以 $\color{black}\texttt{AC}$ 了。

```cpp
//written by naught
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<climits>
using namespace std;

typedef long long ll;
#define Maxn 4000005 //4倍空间
#define Mod 10000007

inline ll read(ll x=0,bool f=0,char c=getchar()){while(!isdigit(c))f=c=='-',c=getchar();while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=getchar();return f?-x:x;}

ll k,A,B,m;
ll ans;
ll a[12],s[Maxn],h[Maxn],mark[Maxn];

ll hts(ll x,ll y) //快速幂
{
    m=1;
    while(y)
    {
        if(y%2==1)
        {
            m*=x;
            m%=Mod;
        }
        x*=x;
        x%=Mod;
        y/=2;
    }
    return m;
}

ll S(ll x) //求S
{
    m=0;
    while(x)
    {
        m+=a[x%10];
        m%=Mod;
        x/=10;
    }
    return m;
}

ll H(ll x) //求H
{
    if(h[x]) return h[x]; //记忆化搜索
    if(mark[x]==2) return x;
    ++mark[x];
    h[x]=min(x,min(s[x],H(s[x]))); //处理环
    --mark[x];
    return h[x];
}

int main()
{
    k=read(),A=read(),B=read();
    for(ll i=0;i<10;++i){
        a[i]=hts(i,k);
    }
    for(ll i=0;i<Maxn;++i){
        s[i]=S(i);
    }
    h[0]=0;
    h[1]=1;
    for(ll i=A;i<=B;++i){
        ans+=H(i);
        ans%=Mod; //勿忘取模
    }
    printf("%lld",ans);
    return 0;
}
```

---


# [NOI2015] 软件包管理器

## 题目背景

Linux 用户和 OSX 用户一定对软件包管理器不会陌生。通过软件包管理器，你可以通过一行命令安装某一个软件包，然后软件包管理器会帮助你从软件源下载软件包，同时自动解决所有的依赖（即下载安装这个软件包的安装所依赖的其它软件包），完成所有的配置。Debian/Ubuntu 使用的 apt-get，Fedora/CentOS 使用的 yum，以及 OSX 下可用的 homebrew 都是优秀的软件包管理器。  


## 题目描述

你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包 $a$ 依赖软件包 $b$，那么安装软件包 $a$ 以前，必须先安装软件包 $b$。同时，如果想要卸载软件包 $b$，则必须卸载软件包 $a$。

现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除 $0$ 号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而 $0$ 号软件包不依赖任何一个软件包。且依赖关系不存在环（即不会存在 $m$ 个软件包 $a_1,a_2, \dots , a_m$，对于 $i<m$，$a_i$ 依赖 $a_{i+1}$，而 $a_m$ 依赖 $a_1$ 的情况）。

现在你要为你的软件包管理器写一个依赖解决程序。根据反馈，用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包），你的任务就是实现这个部分。

注意，安装一个已安装的软件包，或卸载一个未安装的软件包，都不会改变任何软件包的安装状态，即在此情况下，改变安装状态的软件包数为 $0$。


## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/1504.png)  
一开始所有软件包都处于未安装状态。

安装 $5$ 号软件包，需要安装 $0,1,5$ 三个软件包。

之后安装 $6$ 号软件包，只需要安装 $6$ 号软件包。此时安装了 $0,1,5,6$ 四个软件包。

卸载 $1$ 号软件包需要卸载 $1,5,6$ 三个软件包。此时只有 $0$ 号软件包还处于安装状态。

之后安装 $4$ 号软件包，需要安装 $1,4$ 两个软件包。此时 $0,1,4$ 处在安装状态。最后，卸载 $0$ 号软件包会卸载所有的软件包。

【数据范围】  
![](https://cdn.luogu.com.cn/upload/pic/1505.png)

## 样例 #1

### 输入

```
7
0 0 0 1 1 5
5
install 5
install 6
uninstall 1
install 4
uninstall 0```

### 输出

```
3
1
3
2
3```

## 样例 #2

### 输入

```
10
0 1 2 1 3 0 0 3 2
10
install 0
install 3
uninstall 2
install 7
install 5
install 9
uninstall 9
install 4
install 1
install 9```

### 输出

```
1
3
2
1
3
1
1
1
0
1```

# 题解

## 作者：lemonaaaaa (赞：69)

###一道树链剖分的模板题###


- 每次安装软件，就把根节点到x软件路径上的值全部变为1


- 同理，每次卸载软件，就把x以及它的子树的值变为0


故我们可以用区间和的思想，每次操作之前记录一下tree[root].sum的值，更新之后再查询一遍tree[root].sum的值，两者之差的绝对值则为答案。


我的代码里把root的值设为1，每个点的编号都加上了1（个人习惯）


代码如下：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
const int maxn=200005;
int n,k=0,x,head[maxn],q,deep[maxn],father[maxn],size[maxn];
int tid[maxn],top[maxn],son[maxn],tidnum=0,pos[maxn];char s[15];
struct node
{
    int to,next;
} edge[maxn<<1];
struct Node
{
    int left,right,flag,sum;
} tree[maxn<<2];
void add(int u,int v)
{
    edge[++k].to=v;
    edge[k].next=head[u];
    head[u]=k;
}
int read()
{
    int x=0;char ch=getchar();
    while(ch<48||ch>57) ch=getchar();
    while(ch>=48&&ch<=57) x=x*10+ch-48,ch=getchar();
    return x;
}
void dfs1(int x,int fa,int depth)
{
    size[x]=1;father[x]=fa;deep[x]=depth;
    for(int i=head[x];i;i=edge[i].next)
    {
        if(edge[i].to==fa) continue;
        dfs1(edge[i].to,x,depth+1);
        size[x]+=size[edge[i].to];
        if(!son[x]||size[edge[i].to]>size[son[x]]) son[x]=edge[i].to;
    }
}
void dfs2(int x,int tp)
{
    tid[x]=++tidnum;pos[tid[x]]=x;top[x]=tp;
    if(!son[x]) return;dfs2(son[x],tp);
    for(int i=head[x];i;i=edge[i].next)
    {
        if(edge[i].to!=son[x]&&edge[i].to!=father[x])
            dfs2(edge[i].to,edge[i].to);
    }
}
void build(int id,int l,int r)
{
    tree[id].left=l;tree[id].right=r;
    tree[id].sum=0;tree[id].flag=-1;
    if(l==r) return;
    int mid=(l+r)>>1;
    build(id<<1,l,mid);build(id<<1|1,mid+1,r);
    return;
}
void downdata(int id)
{
    tree[id<<1].sum=(tree[id<<1].right-tree[id<<1].left+1)*tree[id].flag;
    tree[id<<1|1].sum=(tree[id<<1|1].right-tree[id<<1|1].left+1)*tree[id].flag;
    tree[id<<1].flag=tree[id<<1|1].flag=tree[id].flag;
    tree[id].flag=-1;
}
int get(int id,int l,int r)
{
    if(tree[id].right<l||tree[id].left>r) return 0;
    if(tree[id].right<=r&&tree[id].left>=l) return tree[id].sum;
    if(tree[id].flag!=-1) downdata(id);
    return get(id<<1,l,r)+get(id<<1|1,l,r);
}
void update(int id,int l,int r,int val)
{
    if(tree[id].right<l||tree[id].left>r) return;
    if(tree[id].right<=r&&tree[id].left>=l)
    {
        tree[id].sum=(tree[id].right-tree[id].left+1)*val;
        tree[id].flag=val;
        return;
    }
    if(tree[id].flag!=-1) downdata(id);
    update(id<<1,l,r,val);update(id<<1|1,l,r,val);
    tree[id].sum=tree[id<<1].sum+tree[id<<1|1].sum;
    return;
}
void change(int u,int v,int val)
{
    while(top[u]!=top[v])
    {
        if(deep[top[u]]<deep[top[v]]) std::swap(u,v);
        update(1,tid[top[u]],tid[u],val);
        u=father[top[u]];
    }
    if(deep[u]>deep[v]) std::swap(u,v);
    update(1,tid[u],tid[v],val);
    return;
}
int main()
{
    n=read();
    for(int i=2;i<=n;i++)
    {
        x=read();x++;
        add(x,i);
    }
    dfs1(1,1,1);dfs2(1,1);
    q=read();build(1,1,tidnum);
    for(int i=1;i<=q;i++)
    {
        scanf("%s",s);
        x=read();x++;
        int t1=tree[1].sum;
        if(s[0]=='i')
        {
            change(1,x,1);
            int t2=tree[1].sum;
            printf("%d\n",abs(t2-t1));
            
        }
        if(s[0]=='u')
        {
            update(1,tid[x],tid[x]+size[x]-1,0);
            int t2=tree[1].sum;
            printf("%d\n",abs(t1-t2));
        }
    }
    return 0;
}
```

---

## 作者：WAMonster (赞：42)

### 珂朵莉是世界上最幸福的女孩，不接受任何反驳

![](https://i.loli.net/2018/04/09/5aca3ca156185.jpg)

### 四处观望了一下发现没有珂朵莉树的题解，那就由我来水一发吧qwq

第一步：树剖打出dfs序（这个不要怎么说了，常规做法即可）

#### 第二步：

观察题目，用1代表已安装、0代表未安装，发现两个操作都是区间赋值，在赋值前后查询，取出答案。区间赋值可以用线段树维护，赋值前统计1的个数，赋值后取差值即可。（这是本题正解）

但是我们也不难想到区间赋值利器——珂朵莉树。学过珂朵莉树的同学都知道珂朵莉树的均摊复杂度是由`Assign`操作保证的，然后这里除了查询全是`Assign`，复杂度理论上不会很劣（即使数据不随机）。所以珂朵莉树吸口氧也是能跑过的。

#### 具体怎么做：
安装的时候跳重链，直到跳到根节点，边走边统计，统计后`Assign`，取差值为答案。卸载时直接统计+修改子树（和线段树做法几乎一样）

注意，这里所有节点编号最好都+1，不然重儿子不好处理。

### 最后贴上代码（吸氧）：
```cpp
// luogu-judger-enable-o2
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <set> 
#include <vector>
using namespace std;
struct node {
    int l, r;
    mutable int val;
    int operator < (const node &a) const {
        return l < a.l;
    }
    node(int L, int R = -1, int Val = 0) : l(L), r(R), val(Val) {} 
};
set<node> s;
#define maxn 200100
#define isdigit(x) ((x) >= '0' && (x) <= '9')

#define sit set<node>::iterator
sit Split(int pos) {
    sit it = s.lower_bound(node(pos));
    if (it != s.end() && it->l == pos) return it;
    --it;
    int l = it->l, r = it->r, val = it->val;
    s.erase(it);
    s.insert(node(l, pos - 1, val));
    return s.insert(node(pos, r, val)).first;
}
int Assign(int l, int r, int val) {
    sit it2 = Split(r + 1), it1 = Split(l);
    int sum = 0, sum2 = val * (r - l + 1);
    for (sit it = it1; it != it2; ++it) sum += it->val * (it->r - it->l + 1);
    s.erase(it1, it2);
    s.insert(node(l, r, val));
    return abs(sum2 - sum);
}
struct edge {
    int to, next;
} e[maxn << 1];
int son[maxn], fa[maxn], top[maxn], size[maxn], depth[maxn], head[maxn];
int ecnt, ncnt, rt = 1;
int pos[maxn];
void adde(int u, int v) {
    e[++ecnt] = (edge) {v, head[u]};
    head[u] = ecnt;		
}
void dfs1(int x) {
    size[x] = 1;
    for (int i = head[x]; i; i = e[i].next) {
        int to = e[i].to;
        if (to == fa[x]) continue;
        depth[to] = depth[x] + 1;
        fa[to] = x;
        dfs1(to);
        size[x] += size[to];
        if (size[son[x]] < size[to]) son[x] = to;
    }
}
void dfs2(int x, int t) {
    pos[x] = ++ncnt;
    top[x] = t;
    if (!son[x]) return;
    dfs2(son[x], t);
    for (int i = head[x]; i; i = e[i].next) {
        int to = e[i].to;
        if (to != fa[x] && to != son[x]) dfs2(to, to);
    }
}
int install(int x, int y) {
    int res = 0;
    while (top[x] != top[y]) {
        if (depth[top[x]] < depth[top[y]]) swap(x, y);
        res += Assign(pos[top[x]], pos[x], 1);
        x = fa[top[x]];
    }
    if (pos[x] > pos[y]) swap(x, y);
    res += Assign(pos[x], pos[y], 1);
    return res;
}
int uninstall(int x) {
    return Assign(pos[x], pos[x] + size[x] - 1, 0);
}
inline int read() {
    int res = 0;
    char c = getchar();
    while (!isdigit(c)) c = getchar();
    while (isdigit(c)) res = (res << 1) + (res << 3) + (c ^ 48), c = getchar();
    return res;
}
int n, m;
char inp[100];
int main() {
    n = read();
    s.insert(node(1, n + 1, 0));
    for (int i = 2; i <= n; ++i) {
        int f = read();
        adde(f + 1, i);
    }
    dfs1(rt);
    dfs2(rt, rt);
    m = read();
    while (m--) {
        scanf("%s", inp);
        int x = read();
        if (inp[0] ^ 'u') {
            printf("%d\n", install(x + 1, rt));
        } else {
            printf("%d\n", uninstall(x + 1));
        }
    }
    return 0;
}
```

---

## 作者：niiick (赞：18)

~~题目好长读的好累~~

对每个软件
他**要依赖的软件作为他的父亲连边**就得到一棵树

对树上每个节点
**权值为1表示已安装，0表示未安装**

安装软件包

转化为查询**从该节点到根有多少个结点权值为0**

那么我们就**查询该节点到根的路径和**
用**该节点深度-路径和**得到答案
然后再**更新该路径全部置为1**

卸载软件包

查询**该节点为根的子树总权值和**
**更新子树全部置为0**

一个优化
可以发现每次**查询与修改都是同一个区间**
那么我们**不用分两个函数查询更新**
直接**同时进行**就好，具体见代码

还要注意
每个结点编号都要**后移一位**
**不能让编号存在0**
***************************

```
#include<iostream>
#include<vector>
#include<algorithm>
#include<queue>
#include<cstring>
#include<cstdio>
using namespace std;

int read()
{
    int f=1,x=0;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return f*x;
}

void print(int x)
{
    if(x<0){putchar('-');x=-x;}
    if(x>9)print(x/10);
    putchar(x%10+'0');
}

int n,k;
int tot,cnt;
struct node{int v,nxt;}E[200010];
int head[100010];
int dep[100010],size[100010],fa[100010],top[100010];
int son[100010],num[100010];
int sum[500010],set[500010],orsum[500010];
char ss[20];

void add(int u,int v)
{
    E[++tot].nxt=head[u];
    E[tot].v=v;
    head[u]=tot;
}

void dfs1(int u,int pa)
{
    size[u]=1;
    for(int i=head[u];i;i=E[i].nxt)
    {
        int v=E[i].v;
        dep[v]=dep[u]+1;
        dfs1(v,u);
        size[u]+=size[v];
        if(size[v]>size[son[u]]) son[u]=v;
    }
}

void dfs2(int u,int tp)
{
    top[u]=tp; num[u]=++cnt;
    if(son[u]) dfs2(son[u],tp);
    for(int i=head[u];i;i=E[i].nxt)
    {
        int v=E[i].v;
        if(v==fa[u]||v==son[u]) continue;
        dfs2(v,v);
    }
}

void push(int mid,int s,int t,int p)
{
    set[p<<1]=set[p<<1|1]=set[p];
    if(set[p]==0)sum[p<<1]=sum[p<<1|1]=0;
    else sum[p<<1]=mid-s+1,sum[p<<1|1]=t-mid;
    set[p]=-1;
}

int getsum(int ll,int rr,int s,int t,int p,int w)
{
    if(ll<=s&&t<=rr){int ans=sum[p]; set[p]=w; sum[p]=(t-s+1)*w; return ans;}//先记录答案，在更新，放标记，返回
    int mid=s+t>>1;
    if(set[p]>=0)push(mid,s,t,p);
    int ans=0;
    if(ll<=mid) ans+=getsum(ll,rr,s,mid,p<<1,w);
    if(rr>mid) ans+=getsum(ll,rr,mid+1,t,p<<1|1,w);
    sum[p]=sum[p<<1]+sum[p<<1|1];
    return ans;
}

int qsum(int u,int v)
{
    int ans=0;
    while(top[u]!=top[v])
    {
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        ans+=getsum(num[top[u]],num[u],1,n,1,1);
        u=fa[top[u]];
    }
    if(dep[u]>dep[v]) swap(u,v);
    ans+=getsum(num[u],num[v],1,n,1,1);
    return ans;
}

int main()
{
    n=read();
    for(int i=1;i<n;i++)
    {
        int u=read()+1;
        fa[i+1]=u; add(u,i+1);
    }

    dep[1]=1;
    dfs1(1,-1); dfs2(1,1);

    memset(set,-1,sizeof(set));
    int q=read();
    while(q--)
    {
        scanf("%s",&ss);int u=read()+1,ans;
        
        if(ss[0]=='i')
        {
            ans=qsum(u,1);
            ans=dep[u]-ans;
        }

        else if(ss[0]=='u')
        ans=getsum(num[u],num[u]+size[u]-1,1,n,1,0);

        print(ans);printf("\n");
    }
    return 0;
}
```

---

## 作者：Apricot (赞：15)

### 　其实这道题各位dalao的解法都比我优秀，我只是写一些关于树剖的理解。


　　这道题题面很长，但归根结底，其实就是道板子题：我们设“1”表示该软件
  
  没有被安装，“0”代表已经安装。那么install操作就是先求出从该节点到根节点
  
  最短路径上的所有点权之和，再将该点到根节点的最短路径上的所有点权全部
  
  修改为“0”，uninstall与之相反，并且操作区间为该点对应的子树。
  
  　　线段树区间覆盖其实特别简单，只不过将传统线段树中的区间修改，下传
    
    标记中所有的“+=”改为“=”，这样就实现了区间覆盖。
    
# 代码(含注意事项)：
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<string.h>
using namespace std;
#define half (l+r)>>1;
const int maxn=200006;
int head[maxn],cur,son[maxn],tot[maxn],fa[maxn],top[maxn],id[maxn],val[maxn],bval[maxn],d[maxn],n,m;

struct hzw 
{
   int to;
   int next;	
}e[maxn];

struct ljm
{
   	int tag;
   	int w;
   	int lc;
   	int rc;
}t[maxn];

inline void add(int a,int b){
	e[cur].to=b;
	e[cur].next=head[a];
	head[a]=cur++;
}
//**************************
int num=1;

inline void build (int s,int l,int r)
{  
   t[s].tag=-1;//标记初始值为-1，因为本题要用到 0 ； 
   if (l==r)
   {
      t[s].w=1;
	  return;	
   }	
   int mid=half;
   t[s].lc=++num;
   build(t[s].lc,l,mid);
   t[s].rc=++num;
   build (t[s].rc,mid+1,r);
   t[s].w=t[t[s].rc].w+t[t[s].lc].w;
}

inline void pushdown(int s,int l,int r)
{
	int le=t[s].lc,ri=t[s].rc,mid=half;//所有的 += 改为 =； 
	t[le].w=t[s].tag*(mid-l+1);
	t[le].tag=t[s].tag;
	t[ri].w=t[s].tag* (r-mid);
	t[ri].tag=t[s].tag;
	t[s].tag=-1;
}

inline void update(int s,int l,int r,int ll,int rr,int v)
{
	if (l==ll&&r==rr)
	{
	   t[s].w=v*(r-l+1);//把 += 改为 =； 
	   t[s].tag=v;
	   return;
	}
	if (t[s].tag!=-1) pushdown(s,l,r);
	int mid=half;
	if (rr<=mid) update(t[s].lc,l,mid,ll,rr,v);
	else if (ll>mid) update(t[s].rc,mid+1,r,ll,rr,v);
	else
	{
	   update(t[s].lc,l,mid,ll,mid,v);
	   update(t[s].rc,mid+1,r,mid+1,rr,v);
	}
	t[s].w=t[t[s].lc].w+t[t[s].rc].w;/*任何线段树都不是
    t[s].w+=t[t[s].lc].w+t[t[s].rc].w; */
}

inline int  query(int s,int l,int r,int ll,int rr)
{
	int ans=0;
    if (l==ll&&r==rr)
	{  
	    return t[s].w;
	}
	if (t[s].tag!=-1) pushdown(s,l,r);
	int mid=half;
	if (rr<=mid) ans+=query(t[s].lc,l,mid,ll,rr);
	else if (ll>mid) ans+=query(t[s].rc,mid+1,r,ll,rr);
	else
	{
	   ans+=query(t[s].lc,l,mid,ll,mid);
	   ans+=query(t[s].rc,mid+1,r,mid+1,rr);	
	}
	return ans; 
}

bool vis[maxn];
//*************************
inline int dfs1(int s,int f,int l)
{
	d[s]=l;
	fa[s]=f;
	tot[s]=1;
	int maxs=-23333;//要用局部变量，不要用全局变量！！！ 
	for (int i=head[s];i!=-1;i=e[i].next){
		tot[s]+=dfs1(e[i].to,s,l+1);
		if (tot[e[i].to]>maxs){
			maxs=tot[e[i].to];
			son[s]=e[i].to;
		}
	}
	return tot[s];
}

int cnt=0;

inline void dfs2(int s,int firs)
{
    id[s]=++cnt;
    top[s]=firs;
    if (!son[s]) return;
    dfs2(son[s],firs);//先搜重儿子 
    for (int i=head[s];i!=-1;i=e[i].next){
    	if (id[e[i].to]) continue;
    	dfs2(e[i].to,e[i].to);
	}
}

inline void chang(int x,int y,int v)
{    
	while (top[x]!=top[y])
	{  
	   
	   if (d[top[x]]<d[top[y]]) std::swap(x,y);
	   update(1,1,n,id[top[x]],id[x],v);
	   x=fa[top[x]];	
	}
	
	if (d[x]>d[y]) std::swap(x,y);
	update(1,1,n,id[x],id[y],v);
}

inline int sum_(int x,int y)
{
	int ans=0;
	while (top[x]!=top[y])
 	{   
		if (d[top[x]]<d[top[y]]) std::swap(x,y);
		ans+=query(1,1,n,id[top[x]],id[x]);
		x=fa[top[x]];
	}
	if (d[x]>d[y]) std::swap(x,y);
	ans+=query(1,1,n,id[x],id[y]);
	return ans;
}

inline void tchang(int x,int v)
{
	update(1,1,n,id[x],id[x]+tot[x]-1,v);
}

inline int tsum(int x)
{
    return tot[x]-query(1,1,n,id[x],id[x]+tot[x]-1); 	
}

int main()
{
	memset(head,-1,sizeof(head));
    std::cin>>n;
    for (int i=2,a;i<=n;++i)
	{
    	scanf("%d",&a);
    	a++;//习惯从 1 开始建树
    	add(a,i);
	}
	dfs1(1,1,1);
	dfs2(1,1);
	build (1,1,n);
	std::cin>>m;
	std::string q;
	int p;
	for (int i=1;i<=m;++i)
	{
		std::cin>>q;
		scanf("%d",&p);
		p++;//习惯从 1 开始建树 
		if (q=="install")
		{   
			printf("%d\n",sum_(p,1));
		    chang(p,1,0);
		}
		else 
		{
			printf("%d\n",tsum(p));
			tchang(p,1);
		}
	}
	return 0;
}
```

---

## 作者：ppip (赞：14)

单 $\log$ 做法。

定义 $dep_u$ 为点 $u$ 的深度。

注意到安装结点构成一个包含根的连通块。

考虑用 set 按照 DFS 序维护连通块的叶子。

安装点 $x$ 的时候，先检查 set 中有没有它子树内的点，如果有则无需安装。否则，找到它最深的安装的祖先，这个可以在 set 中找到 DFS 序上前后最近的点并求取 LCA 得到，然后我们就可以得知本次答案为 $dep_x-dep_a$，$a$ 为找到的祖先。随后将该点加入 set，并检查刚才的祖先在不在其中，如果在则删除。

卸载点 $x$ 也是类似的。将它子树内的叶子全部从 set 中删除，如果不存在则无需卸载。否则，计算刚才删除的连通块的大小。具体地。设删除的点按照 DFS 序从小到大为 $a_1,a_2,\dots,a_m$，且令 $a_0=x$，则答案为 $\sum_{i=1}^m dep_{a_i}-dep_{\text{LCA}(a_i,a_{i-1})}$，可以画图理解。

LCA 算法可以任意选取，时间复杂度根据 LCA 算法的预处理复杂度为 $O((n+q)\log n)$ 或 $O(n+q\log n)$。 

代码使用了 DFS 序 RMQ 求 LCA，复杂度为前者。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N(1e5),LG{16};
vector<int> e[N+5];
int L[N+5],R[N+5],fz[N+5],dep[N+5],st[LG+5][N+5],fa[N+5];
int Max(int x,int y) {
	return dep[fz[x]]<dep[fz[y]]?x:y;
}
void init(int u) {
	static int lda{0};
	L[u]=++lda;
	fz[lda]=u;
	for (auto v:e[u])
		dep[v]=dep[u]+1,init(v);
	R[u]=lda;
	
}
int n;
int LCA(int u,int v) {
	if (u==v) return u;
	if (u==0||u==n+1||v==0||v==n+1) return 0;
	u=L[u];v=L[v];
	if (u>v) swap(u,v);
	int z{__lg(v-u)};
	return fa[fz[Max(st[z][u+1],st[z][v-(1<<z)+1])]];
}
int main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>n;
	for (int i{2};i<=n;++i) {
		cin>>fa[i];
		++fa[i];
		e[fa[i]].push_back(i);
	}
	dep[1]=1;
	init(1);
	iota(*st+1,*st+1+n,1);
	for (int i{1};i<=LG;++i)
		for (int j{1};j+(1<<i)-1<=n;++j)
			st[i][j]=Max(st[i-1][j],st[i-1][j+(1<<i-1)]);
	set<int> s{0,n+1};
	int q;cin>>q;
	L[n+1]=fz[n+1]=n+1;
	while (q--) {
		char op[100];cin>>op;
		int x;cin>>x;
		++x;
		if (op[0]=='i') {
			int P{fz[*prev(s.lower_bound(L[x]))]},Q{fz[*s.lower_bound(L[x])]};
			if (L[Q]<=R[x]) {
				cout<<"0\n";
				continue;
			}
			if (R[P]>=L[x]) s.erase(L[P]);
			s.insert(L[x]);
			cout<<dep[x]-max(dep[LCA(P,x)],dep[LCA(x,Q)])<<"\n";
		} else {
			int lst{fa[x]},ans{0};
			if (*s.lower_bound(L[x])>R[x]) {
				cout<<"0\n";
				continue;
			}
			for (auto it{s.lower_bound(L[x])};*it<=R[x];) {
				ans+=dep[fz[*it]]-dep[LCA(lst,fz[*it])];
				lst=fz[*it];
				it=s.erase(it);
			}
			if (*s.lower_bound(L[x])>R[fa[x]]&&*prev(s.lower_bound(L[x]))<L[fa[x]])
				s.insert(L[fa[x]]);
			cout<<ans<<"\n";
		}
	}
	return 0;
}
```

---

## 作者：CTime_Pup_314 (赞：7)

更好的阅读体验

[CTime_Pup_314的博客](https://ctp314.github.io/)

看题第一感觉，完了要卡读题

仔细看后觉得，完了好像维护的是种类个数不具有O(1)更新的信息

~~树链用分块维护？~~

再仔细看其实发现此题可做

首先规定1代表安装，0代表不安装

对于每次安装，先查询到根的路径上0的个数，再用1覆盖

对于每次删除，先查询子树1的个数，再用0覆盖

所以就找到一个可以处理覆盖的数据结构即可

线段树可以维护

详细见代码

```cpp
#include <cstdio>
#include <cstring>
#include <cctype>
#include <algorithm>
using namespace std;
const int N = 200000+5;
inline int read()
{
    int f = 1, x = 0; char ch;
    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;
    while(isdigit(ch)) {x = x*10+ch-'0'; ch = getchar();}
    return f*x;
}

struct Edge
{
    int next, to;
    Edge(int next = 0, int to = 0):next(next), to(to) {};
}edge[N<<1];

int head[N], tot;

inline void _add(int x, int y) {edge[++tot] = Edge(head[x], y); head[x] = tot;}

inline void add(int x, int y) { _add(x, y); _add(y, x);}

int n, m;
int neww[N], w[N];
int id[N], son[N], deep[N], size[N], cnt, top[N], fa[N];

inline void dfs1(int x, int f)
{
    fa[x] = f; size[x] = 1; 
    for(int i = head[x]; i; i = edge[i].next)
    {
        int y = edge[i].to;
        if(y == f) continue;
        deep[y] = deep[x]+1;
        dfs1(y, x);
        size[x] += size[y];
        if(size[y] > size[son[x]]) son[x] = y;
    }
}

inline void dfs2(int x, int topf)
{
    top[x] = topf; id[x] = ++cnt; neww[id[x]] = w[x];
    if(!son[x]) return;
    dfs2(son[x], topf);
    for(int i = head[x]; i; i = edge[i].next)
    {
        int y = edge[i].to;
        if(y == fa[x]||y == son[x]) continue;
        dfs2(y, y);
    }
}

/*
	线段树维护区间中1的个数
	标签维护区间覆盖 
	tag为0则无标记，1则用0覆盖区间，2则用1覆盖区间 
*/ 
int tag[N<<2], sum[N<<2];

inline void pushup(int x) { sum[x] = sum[x<<1]+sum[x<<1|1]; } //向上传递直接相加就好了，信息具有区间可加性 
inline void pushdown(int x, int l, int r, int mid)
{
    tag[x<<1] = tag[x]; tag[x<<1|1] = tag[x]; // 覆盖标记直接下传 
    if(tag[x] == 1) sum[x<<1] = sum[x<<1|1] = 0; // 若用0覆盖则两个子区间1的个数都为0 
    else if(tag[x] == 2) sum[x<<1] = mid-l+1, sum[x<<1|1] = r-mid; // 反之则为区间的长度 
	tag[x] = 0;
}

inline int ask(int x, int l, int r, int ql, int qr)
{
    if(ql <= l&&r <= qr) return sum[x];
    int mid = l+r>>1; int ret = 0;
    if(tag[x]) pushdown(x, l, r, mid);
    if(ql <= mid) ret += ask(x<<1, l, mid, ql, qr);
    if(qr > mid) ret += ask(x<<1|1, mid+1, r, ql, qr);
    return ret;
}

inline void change(int x, int l, int r, int ql, int qr, int d)
{
    if(ql <= l&&r <= qr)
    {
    	//修改时就打上标记，重置sum就好了 
    	tag[x] = d; 
    	if(d == 1) sum[x] = 0;
    	else if(d == 2) sum[x] = r-l+1;
    	return;
    }
    int mid = l+r>>1;
    if(tag[x]) pushdown(x, l, r, mid);
    if(ql <= mid) change(x<<1, l, mid, ql, qr, d);
    if(qr > mid) change(x<<1|1, mid+1, r, ql, qr, d);
    pushup(x);
}

// 查询链上的0的个数 
inline int qRange(int x, int y)
{
	int ret = 0;
    while(top[x] != top[y])
    {
        if(deep[top[x]] < deep[top[y]]) swap(x, y);
        ret += id[x] - id[top[x]] + 1 - ask(1, 1, n, id[top[x]], id[x]); //线段树维护的是1的个数，用区间长度去减即可 
        x = fa[top[x]];
    }
    if(deep[x] < deep[y]) swap(x, y);
    ret += id[x] - id[y] + 1 - ask(1, 1, n, id[y], id[x]);
    return ret;
}

// 用1覆盖树链 
inline void cRange(int x, int y, int d)
{
    while(top[x] != top[y])
    {
        if(deep[top[x]] < deep[top[y]]) swap(x, y);
        change(1, 1, n, id[top[x]], id[x], d);
        x = fa[top[x]];
    }
    if(deep[x] < deep[y]) swap(x, y);
    change(1, 1, n, id[y], id[x], d);
}

// 查询子树为1的个数 
inline int qSon(int x) { return ask(1, 1, n, id[x], id[x]+size[x]-1); }

// 覆盖子树 
inline void cSon(int x, int d) {change(1, 1, n, id[x], id[x]+size[x]-1, d); }

int main()
{
    n = read(); 
    for(int x = 2; x <= n; x++)
    {
        int y = read()+1; // 节点从0编号的异端 
        add(y, x);
    }
	m = read();
    dfs1(1, 0); dfs2(1, 1);
    while(m--)
    {
        char op[20]; scanf("%s", op);
        int x = read()+1;
        if(op[0] == 'i')
        {
        	// 对于下载操作分解为两个 
        	printf("%d\n", qRange(1, x)); // 查询到根节点的路径上0的个数 
        	cRange(1, x, 2); // 用1覆盖这条路径 
        }
        else 
        {
        	// 与删除同理 
        	printf("%d\n", qSon(x)); // 查询子树中1的个数 
        	cSon(x, 1); // 用0覆盖子树 
        }
    }
    return 0;
}
```

---

## 作者：immortalCO (赞：5)

树链剖分+区间设置的线段树

修改的地方简单维护即可


---

## 作者：Register (赞：4)

### 简化题意
给你一棵树，最初全都是$0$，结点从$0$到$n-1$，$0$是根结点

有两种操作：

> $1.$将从根到$x$结点的唯一路径有多少个$0$求出来，并将这个唯一路径全部赋值为$1$

> $2.$将以$x$结点为根的子树有多少个$1$求出来，并将这个子树全部赋值为$0$

### 题目分析
嗯.带修改的树上操作，统计路径或子树的和，那么就是[$\color{red}\text{树链剖分板子题}$](https://www.luogu.org/problemnew/show/P3384)

**操作1**:$x$号结点的深度减掉路径上$1$的个数得到答案，接着更新为$1$

**操作2**:考虑$DFS$序，同一棵子树在线段树上的编号一定是连续的，直接求和，然后更新为$0$
### 注意
不要用$0$表示$lazytag$不更新，因为更新的时候会有$0$

代码中为了方便处理，将下标弄成了从$1$开始
### $code:$
代码自己看，不会树链剖分的直接看模板的题解

```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> e[100001];
int n,m,u,ans,d[100001],sz[100001],fa[100001],son[100001],top[100001],seg[100001],tree[400001],add[400001];
string opt;
#define pushup(pos) tree[pos]=tree[pos<<1]+tree[pos<<1|1]
int read(){
    char ch=getchar();int res=0,w=1;
    while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {res=res*10+ch-'0';ch=getchar();}
    return res*w;
}
void pushdown(int pos,int ls,int rs){
    if(add[pos]!=-1)
    {
    	add[pos<<1]=add[pos<<1|1]=add[pos];
        tree[pos<<1]=add[pos]*ls;tree[pos<<1|1]=add[pos]*rs;
        add[pos]=-1;
    }
}
void dfs1(int x){
    sz[x]=1;d[x]=d[fa[x]]+1;
    for(register int i=0;i<e[x].size();i++)
    {
    	dfs1(e[x][i]);
        sz[x]+=sz[e[x][i]];
        if(sz[e[x][i]]>sz[son[x]]) son[x]=e[x][i];
    }
}
void dfs2(int x){
    if(son[x])
    {
        top[son[x]]=top[x];
        seg[son[x]]=++seg[0];
        dfs2(son[x]);
    }
    for(register int i=0;i<e[x].size();i++)
        if(!top[e[x][i]])
        {
            top[e[x][i]]=e[x][i];
            seg[e[x][i]]=++seg[0];
            dfs2(e[x][i]);
        }
}
void update(int l,int r,int pos,int L,int R,int x){
    if(L<=l&&r<=R) {tree[pos]=(r-l+1)*x;add[pos]=x;return;}
    int mid=(l+r)>>1;
    pushdown(pos,mid-l+1,r-mid);
    if(mid>=L) update(l,mid,pos<<1,L,R,x);
    if(R>mid) update(mid+1,r,pos<<1|1,L,R,x);
    pushup(pos);
}
int query(int l,int r,int pos,int L,int R){
    if(L<=l&&r<=R) return tree[pos];
    int mid=(l+r)>>1,res=0;
    pushdown(pos,mid-l+1,r-mid);
    if(mid>=L) res+=query(l,mid,pos<<1,L,R);
    if(R>mid) res+=query(mid+1,r,pos<<1|1,L,R);
    return res;
}
signed main(){
    n=read();
	memset(add,-1,sizeof(add));
    for(register int i=2;i<=n;i++) e[fa[i]=read()+1].push_back(i);
    dfs1(1);
    seg[0]=seg[1]=top[1]=1;
    dfs2(1);
	m=read();
    while(m--)
    {
        cin>>opt;u=read()+1;ans=0;
        if(opt=="install")
        {
            while(top[u]!=1) {ans+=d[u]-d[top[u]]+1-query(1,seg[0],1,seg[top[u]],seg[u]);update(1,seg[0],1,seg[top[u]],seg[u],1);u=fa[top[u]];}
            ans+=d[u]-query(1,seg[0],1,1,seg[u]);update(1,seg[0],1,1,seg[u],1);
        }
        else if(opt=="uninstall") {ans=query(1,seg[0],1,seg[u],seg[u]+sz[u]-1);update(1,seg[0],1,seg[u],seg[u]+sz[u]-1,0);}
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：QwQ蒟蒻wjr (赞：4)

>> 洛谷题目链接：[[NOI2015]软件包管理器](https://www.luogu.org/problem/P2146)

>> LOJ题目链接：[[NOI2015]软件包管理器](https://loj.ac/problem/2130)

题解原发于[我的blog](https://wangjunrui.netlify.com/2019/10/24/%E6%B4%9B%E8%B0%B7-p2146-noi2015-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/)

首先，很明显这是一道树链剖分的题。

注意到一个软件只会以来一个软件，并且不会出现环，所以每次都可以连一条$(x\ ,\ i)$的边。



当安装一个软件时，就把$(1\ ,\ x)$的路径上所有的点的转态变为$1$

但卸载一个软件时，就把$x$及它的所有的子树变为$0$

线段树维护即可

推荐一道树链剖分的好题[【模板】树链剖分](https://www.luogu.org/problem/P3384)

做完这道题就可以差不多学完所有关于树链剖分的芝士

最后贴上代码~~知道你们只看这个~~：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
template <typename T>
inline void read(T &x)
{
	x = 0;
	char s = getchar();
	bool f = false;
	while (!(s >= '0' && s <= '9'))
	{
		if (s == '-')
			f = true;
		s = getchar();
	}
	while (s >= '0' && s <= '9')
	{
		x = (x << 1) + (x << 3) + s - '0';
		s = getchar();
	}
	if (f)
		x = (~x) + 1;
}
#define re register
#define ls (k << 1)
#define rs (k << 1 | 1)
const int N = 1e5 + 10, M = 2e5 + 10, T = 4e5 + 10;
struct Edge
{
	int next, to;
} edge[M];
int num_edge, head[N];
struct Tree
{
	int l, r, size, sum, flag;
} tree[T];
char s[110];
int n, q, cnt;
int idx[N], rk[N], dep[N], fa[N], top[N], size[N], son[N];		//rk[i]其实并没有什么用这只是我的习惯 
inline void add_edge(int from, int to)
{
	edge[++num_edge].next = head[from];
	edge[num_edge].to = to;
	head[from] = num_edge;
}
inline void dfs1(int u, int f)
{
	fa[u] = f;
	dep[u] = dep[f] + 1;
	size[u] = 1;
	for (re int i = head[u]; i; i = edge[i].next)
	{
		int &v = edge[i].to;
		if (v == f)
			continue;
		dfs1(v, u);
		size[u] += size[v];
		if (size[son[u]] < size[v])
			son[u] = v;
	}
}
inline void dfs2(int u, int tp)
{
	idx[u] = ++cnt;
	rk[cnt] = u;
	top[u] = tp;
	if (!son[u])
		return;
	dfs2(son[u], tp);
	for (re int i = head[u]; i; i = edge[i].next)
	{
		int &v = edge[i].to;
		if (idx[v])
			continue;
		dfs2(v, v);
	}
}
inline void pushdown(int k)
{
	if (~tree[k].flag)//相当于tree[k].flag!=-1 
	{
		tree[ls].sum = tree[ls].size * tree[k].flag;
		tree[rs].sum = tree[rs].size * tree[k].flag;
		tree[ls].flag = tree[rs].flag = tree[k].flag;
		tree[k].flag = -1;
	}
}
inline void build(int k, int l, int r)
{
	tree[k].l = l;
	tree[k].r = r;
	tree[k].size = r - l + 1;
	if (l == r)
	{
		tree[k].flag = -1;
		return;
	}
	int mid = l + r >> 1;
	build(ls, l, mid);
	build(rs, mid + 1, r);
}
inline void update1(int k, int l, int r, int val)
{
	if (l <= tree[k].l && tree[k].r <= r)
	{
		tree[k].sum = tree[k].size * val;
		tree[k].flag = val;
		return;
	}
	int mid = (tree[k].l + tree[k].r) >> 1;
	pushdown(k);
	if (l <= mid)
		update1(ls, l, r, val);
	if (mid < r)
		update1(rs, l, r, val);
	tree[k].sum = tree[ls].sum + tree[rs].sum;
}
inline void update2(int x, int y)
{
	while (top[x] != top[y])
	{
		if (dep[top[x]] < dep[top[y]])
			swap(x, y);
		update1(1, idx[top[x]], idx[x], 1);
		x = fa[top[x]];
	}
	if (dep[x] > dep[y])
		swap(x, y);
	update1(1, idx[x], idx[y], 1);
}
int main()
{
	read(n);
	for (re int i = 2, x; i <= n; ++i)
	{
		read(x);
		add_edge(x + 1, i);
	}
	dfs1(1, 0);
	dfs2(1, 1);
	build(1, 1, n);
	read(q);
	for (re int i = 1, before, x; i <= q; ++i)
	{
		scanf("%s", s);
		read(x);
		++x;
		before = tree[1].sum;
		if (s[0] == 'i')
		{
			update2(1, x);
			printf("%d\n", tree[1].sum - before);
		}
		else if (s[0] == 'u')
		{
			update1(1, idx[x], idx[x] + size[x] - 1, 0);
			printf("%d\n", before - tree[1].sum);
		}
	}
	return 0;
}
```
~~马蜂差评~~



---

## 作者：RiverFun (赞：4)

同步发表于[$\tt{Blog}$](https://stevebraveman.github.io/2018/12/20/52/)

如果用1表示已安装，0表示未安装，那么先将这道题转换成人话：

操作install：统计x到根节点路径上为0的节点个数并输出，并把这一路径上的节点都赋值为1

操作uninstall：统计以x为根的子树的节点为1的个数，并把这个子树上的节点都赋值为0

然后这道题就很好理解了。

如何解决第一个操作呢，很简单，先统计出节点为1的个数，再用x的深度-节点为1的个数，然后再用线段树的区间覆盖就可以了

为什么要用x的深度，因为x的深度就是从根节点到x的路径上的节点个数

那么第二个操作呢，也很简单，直接统计子树上1的个数，然后再覆盖。

下面是~~愉快的~~代码时间：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define ls(x) ((x) << 1)
#define rs(x) ((x) << 1 | 1)
#define INF 0x7fffffff
#define MAXN 5000000
#define abs(x) ((x) < 0 ? (-x) : (x))
int max(int a, int b) {
	if (a > b) return a;
	else return b;
}
void swap(int &x, int &y) {
	int t = x;
	x = y;
	y = t;
}
struct Edge {
	int v, nx;
}e[MAXN];
int head[MAXN], ecnt, n, m, x, y, dep[MAXN], si[MAXN], wt[MAXN], w[MAXN], fat[MAXN];
int fa[MAXN], top[MAXN], son[MAXN], cnt, r = 1, id[MAXN], f[MAXN];
void add(int f, int t) {
	e[++ecnt] = (Edge) {t, head[f]};
	head[f] = ecnt;
}
struct Segtree {
	int a[MAXN], b[MAXN << 2], lazy[MAXN << 2];
	void pd(int p) {
		b[p] = b[ls(p)] + b[rs(p)];
	}
	void build(int l, int r, int p) {
		lazy[p] = -1;
		if (l == r) {
			b[p] = a[l];
			return;
		}
		int m = (l + r) >> 1;
		build(l, m, ls(p));
		build(m + 1, r, rs(p));
		pd(p);
	}
	void f(int p, int l, int r, int k) {
		lazy[p] = k;
		b[p] = k * (r - l + 1);
		return;
	}
	void pushd(int p, int l, int r) {
		if (lazy[p] != -1) {
			int m = (l + r) >> 1;
			f(ls(p), l, m, lazy[p]);
			f(rs(p), m + 1, r, lazy[p]);
			lazy[p] = -1;
		}
	}
	void updater(int x, int y, int l, int r, int p, int k) {
		if (x <= l && y >= r) {
			lazy[p] = k;
			b[p] = k * (r - l + 1);
			return;
		}
		pushd(p, l, r);
		int m = (l + r) >> 1;
		if (x <= m) updater(x, y, l, m, ls(p), k);
		if (y > m) updater(x, y, m + 1, r, rs(p), k);
		pd(p);
	}
	int qsum(int x, int y, int l, int r, int p) {
		int s = 0;
		if (x <= l && y >= r) {
			return b[p];
		}
		int m = (l + r) >> 1;
		pushd(p, l, r);
		if (x <= m) s += qsum(x, y, l, m, ls(p));
		if (y > m) s += qsum(x, y, m + 1, r, rs(p));
		return s;
	}
}tree;
void dfs1(int u, int f, int deep) {
	dep[u] = deep;
	fa[u] = f;
	si[u] = 1;
	for (int i = head[u]; i; i = e[i].nx) {
		int to = e[i].v;
		if (to == f) continue;
		dfs1(to, u, deep + 1);
		si[u] += si[to];
		if (si[to] > si[son[u]]) son[u] = to;
	}
}
void dfs2(int u, int topf) {
	id[u] = ++cnt;
	wt[cnt] = w[u];
	top[u] = topf;
	if (!son[u]) return;
	dfs2(son[u], topf);
	for (int i = head[u]; i; i = e[i].nx) {
		int to = e[i].v;
		if (fa[u] == to || to == son[u]) continue;
		dfs2(to, to);
	}
}
inline void upr(int x, int y, int k) {
	while (top[x] != top[y]) {
		if (dep[top[x]] < dep[top[y]]) swap(x, y);
		tree.updater(id[top[x]], id[x], 1, n, 1, k);
		x = fa[top[x]];
	}
	if (dep[x] > dep[y]) swap(x, y);
	tree.updater(id[x], id[y], 1, n, 1, k);
}
inline int tq(int x, int y) {
	int ans = 0;
	while (top[x] != top[y]) {
		if (dep[top[x]] < dep[top[y]]) swap(x, y);
		ans += tree.qsum(id[top[x]], id[x], 1, n, 1);
		x = fa[top[x]];
	}
	if (dep[x] > dep[y]) swap(x, y);
	ans += tree.qsum(id[x], id[y], 1, n, 1);
	return ans;
}
inline void ups(int x, int k) {
	tree.updater(id[x], id[x] + si[x] - 1, 1, n, 1, k);
}
inline int qs(int x) {
	return tree.qsum(id[x], id[x] + si[x] - 1, 1, n, 1);
}
int main() {
	scanf("%d", &n);
	for (int i = 2; i <= n; i++) {
		scanf("%d", &x);
		x++;
		fat[i]++;
		add(i, x);
		add(x, i);
	}
	dfs1(r, -1, 1);
	dfs2(r, r);
	tree.build(1, n, 1);
	scanf("%d", &m);
	while (m--) {
		char op[20];
		scanf("%s", op);
		if (op[0] == 'i') {
			scanf("%d", &x);
			x++;
			printf("%d\n", dep[x] - tq(x, r));
			upr(x, r, 1);
		}
		if (op[0] == 'u') {
			scanf("%d", &x);
			x++;
			printf("%d\n", qs(x));
			ups(x, 0);
		}
	}
}
```

---

## 作者：GoPoux4 (赞：3)

### 树链剖分（~~还是裸的~~）

然而即使是裸题也没有那么简单，有很多细节需要注意。

---

先从题面中找到关键信息：

>  _除 `00` 号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而 `00` 号软件包不依赖任何一个软件包。且依赖关系不存在环。_
 
 可以判断软件包的依赖关系是一个树形结构，于是就能做树上操作了。
 
---

### 操作

+ `install` 操作

不难发现，如果要安装编号为 `a` 的软件，则必须先安装 `fa[a]` ，即 `a` 所依赖的软件。这种关系层层向上传递，可以发现：

安装 `a` 需要安装 **`a~root`链上的全部软件**。

+ `uninstall` 操作

可以发现，卸载编号为 `a` 的软件，须将依赖它的所有软件都卸载，即：

卸载 `a` 需要卸载 **以 `a` 为根的子树上的所有软件**

---

又是链又是子树，于是我们就想到了**树链剖分**。

~~其实是只会树链剖分~~

用 `1` 表示已安装，`0` 表示未安装。用树链剖分剖出来后，再用线段树维护树上信息即可。

其中用一个标记标记此区间状态是否相同，若相同则可直接转移，可以加速。

---

#### 注意几点

1. 为了安全，避免出现 `0`，建议将所有点的编号统一 `+1`。

1. 初始编号为 `0` 的软件已安装，记得初始化为 `1`。

1. 线段树的 `tag` 在 `build()` 和 `change()` 函数中都需要向上传递，因为子节点的状态已经变化了。

1. 输入字符的时候一定要留意，防止读入空白字符。

---

**`Code`**

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <string>
#include <algorithm>
#define maxn 100005
#define ls (p<<1)
#define rs (p<<1|1)
using namespace std;

int n,q,a[maxn];
int fa[maxn],dfn[maxn],top[maxn];
int son[maxn],size[maxn],deep[maxn];
int dfs_cnt;

struct edge
{
	int v,next;
}e[maxn<<1|1];

int head[maxn],k;

inline void add(int u,int v)
{
	e[k]=(edge){v,head[u]};
	head[u]=k++;
}

void dfs1(int u)
{
	deep[u]=deep[fa[u]]+1;
	son[u]=-1;
	size[u]=1;
	for(int i=head[u];~i;i=e[i].next)
	{
		dfs1(e[i].v);
		size[u]+=size[e[i].v];
		if(son[u]==-1||size[son[u]]<size[e[i].v]) son[u]=e[i].v;
	}
}

void dfs2(int u,int t)
{
	top[u]=t;
	dfn[u]=++dfs_cnt;
	if(son[u]==-1) return;
	dfs2(son[u],t);
	for(int i=head[u];~i;i=e[i].next)
		if(e[i].v!=son[u])
			dfs2(e[i].v,e[i].v);
}

struct node
{
	int l,r,tag,lazy;//tag为此区间的状态，如状态不一则为-1
}tree[maxn<<2|1];

void build(int p,int l,int r)
{
	tree[p].l=l;tree[p].r=r;
	if(l==r)
	{
		tree[p].tag= (l==1)?1:0;//是否已安装
		tree[p].lazy=-1;
		return;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	if(tree[ls].tag!=tree[rs].tag||tree[ls].tag==-1) tree[p].tag=-1;
	else tree[p].tag=tree[ls].tag;//tag更新
}

inline void push_down(int p)
{
	if(tree[p].lazy==-1) return;
	tree[ls].tag=tree[ls].lazy=tree[rs].tag=tree[rs].lazy=tree[p].lazy;
	tree[p].lazy=-1;
}

void change(int p,int l,int r,int d)
{
	if(l<=tree[p].l&&r>=tree[p].r)
	{
		tree[p].tag=d;
		tree[p].lazy=d;
		return;
	}
	push_down(p);
	int mid=(tree[p].l+tree[p].r)>>1;
	if(l<=mid) change(ls,l,r,d);
	if(r>mid) change(rs,l,r,d);
	if(tree[ls].tag!=tree[rs].tag||tree[ls].tag==-1) tree[p].tag=-1;
	else tree[p].tag=tree[ls].tag;//tag更新
}

int query(int p,int l,int r,int aim)
{
	if(tree[p].tag!=-1&&l<=tree[p].l&&r>=tree[p].r)
		return tree[p].tag==aim?(tree[p].r-tree[p].l+1):0;
	push_down(p);
	int mid=(tree[p].l+tree[p].r)>>1,ans=0;
	if(l<=mid) ans+=query(ls,l,r,aim);
	if(r>mid) ans+=query(rs,l,r,aim);
	return ans;
}

inline int querypath(int x)
{
	int ans=0;
	while(top[x]!=1)
	{
		ans+=query(1,dfn[top[x]],dfn[x],0);
		change(1,dfn[top[x]],dfn[x],1);
		x=fa[top[x]];
	}
	ans+=query(1,dfn[top[x]],dfn[x],0);
	change(1,dfn[top[x]],dfn[x],1);
	return ans;
}

inline int querytree(int x)
{
	int ans=query(1,dfn[x],dfn[x]+size[x]-1,1);
	change(1,dfn[x],dfn[x]+size[x]-1,0);
	return ans;
}

int main()
{
	freopen("P2146.in","r",stdin);
	scanf("%d",&n);
	memset(head,-1,sizeof(head));
	a[1]=1;
	for(int i=2;i<=n;i++)
	{
		scanf("%d",&fa[i]);
		fa[i]++;
		add(fa[i],i);
	}
	dfs1(1);
	dfs2(1,1);
	build(1,1,n);
	scanf("%d",&q);
	char opt[20];int x;
	while(q--)
	{
		scanf("\n%s%d",opt,&x);
		x++;
		if(opt[0]=='i') printf("%d\n",querypath(x));
		else printf("%d\n",querytree(x));
	}
	return 0;
}
```

---

## 作者：zhengrunzhe (赞：3)

提供一个本题的一只log做法~~虽然实际跑得比两个log还慢~~

题意：到根路径覆盖1 子树覆盖0 全树求和

显然可以dfs序结合树剖线段树$O(n \log ^2 n)$维护

这个东西的瓶颈在于到根路径要去树剖

虽然这个玩意常数很小，但是理论就是两个log

引入一个~~简单~~数据结构:**Self-adjusting Top Trees**

学习见[negiizhao的博客](http://negiizhao.blog.uoj.ac/blog/4912)

对于此题，每个簇维护，簇路径权值和/标记，除簇路径以外的内点权值和/标记

这个东西理论时间复杂度是$O(n \log  n)$的

由于不知道什么原因，本人不将satt代码公开

~~写了210行结果还跑得比别人慢~~

```cpp
#include<cstdio>
#include<cstddef>
template<class type>inline const void read(type &in)
{
	in=0;char ch(getchar());bool f(0);
	while (ch<48||ch>57){if (ch=='-')f=1;ch=getchar();}
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
	if (f)in=-in;
}
template<class type>inline const type abs(const type &x)
{
	return x<0?-x:x;
}
template<class type>inline const void swap(type &a,type &b)
{
	const type c(a);a=b;b=c;
}
const int N(1e5+10);
namespace Self_Adjusting_Top_Trees
{
}using namespace Self_Adjusting_Top_Trees;
int n,m;
int main()
{
	read(n);
	node0=new tree[n+1];
	for (int fa,i(2);i<=n;i++)read(fa),link(node(fa+1),node(i));
	read(m);char opt[10];
	for (int p,now,pre(0);m--;printf("%d\n",abs(pre-(now=subtree_sum(node(1))))),pre=now)
		if (scanf("%s",opt),read(p),p++,opt[0]=='i')path_cover(node(p),1);
		else subtree_cover(node(p),0);
	return 0;
}
```

---

## 作者：Smallbasic (赞：2)

树剖水题。。。

相信大家都会树剖吧，如果不会的话就正好听我讲一下。

众所周知有个叫做dfs序的东西，就是dfs遍历这棵树的顺序。他有个显然的性质是一段子树在dfs序上是连续的。

以u为根的子树带dfs序上对应的区间为：

$$[pos_u,pos_u+siz_u-1]$$

其中$pos_u$代表u在dfs序中的位置，$siz_u$代表以u为根子树的大小。

相信这个东西应该是很好理解的。

如果只有子树的修改可以直接把树上问题转化成dfs序上的序列问题搞。但是这题有到根修改的操作。

朴素的暴力是暴力改每个点。那么能不能想个办法把这些区间拆分成log条区间再改呢？

我们成每个点子树最大的子节点为他的重儿子，重儿子连向它的那条边为重链。dfs的时候如果优先dfs重儿子就会使重链上的点。

显然一条完整重链上的点是在这样dfs序上连续的。

我们把询问/修改的链拆成很多条重链，再作区间修改，就好了。

复杂度$\Theta(n\log^2n)$

这道题设软件包安装为1，卸载为0

显然修改操作是把子树全部赋值成0或把到根路径上得点赋值成1

这样映射到dfs序上就是区间推平问题。

于是用树剖水就好了。由于操作是区间推平，我就偷懒把维护的数据结构改成珂朵莉树，反正树剖重点也不在这儿~~不过就只能吸氧才能A~~

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
#include <set>

using namespace std;

inline int readi() {
    int s = 0, f = 1;
    char ch = getchar();
    while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
    while (isdigit(ch)) s = (s << 1) + (s << 3) + (ch & 15), ch = getchar();
    return s * f;
}

inline int abs_(int n) {
	return n < 0 ? -n : n;
}

struct NNode {
    int fa, zson, dep, top, siz, pos;
    vector<int> nxt;
    NNode() { fa = 0; zson = 0; dep = 0; top = 0; siz = 1; }
}nd[500005];

static int tp = 1;

inline void dfs1(int now, int fa) {
    nd[now].fa = fa; nd[now].dep = nd[fa].dep + 1;
    int mx = 0, s = 0;
    for (vector<int> :: iterator it = nd[now].nxt.begin(); it != nd[now].nxt.end(); ++it) {
        if ((*it) == fa) continue;
        dfs1((*it), now);
        nd[now].siz += nd[(*it)].siz;
        if (mx < nd[(*it)].siz) { mx = nd[(*it)].siz; s = (*it); }
    } nd[now].zson = s;
}

inline void dfs2(int now, int fa, int top) {
    nd[now].pos = tp; ++tp; nd[now].top = top;
    if (nd[now].zson != 0) dfs2(nd[now].zson, now, top);
    for (vector<int> :: iterator it = nd[now].nxt.begin(); it != nd[now].nxt.end(); ++it) {
        if ((*it) == fa) continue;
        if ((*it) == nd[now].zson) continue;
        dfs2((*it), now, (*it));
    }
}

#define IT set<node>::iterator

struct node {
    int l, r;
    mutable int val;
    node(int L, int R = -1, int V = 0) : l(L), r(R), val(V) {}
    inline bool operator < (const node& a) const {
        return l < a.l;
    }
};

set<node> st;

inline IT split(int now) {
    IT it = st.lower_bound(node(now));
    if (it != st.end() && it -> l == now) return it;
    --it;
    int l = it -> l, r = it -> r, val = it -> val;
    st.erase(it);
    st.insert(node(l, now - 1, val));
    return st.insert(node(now, r, val)).first;
}

inline int assign(int l, int r, int val) {
    IT itr = split(r + 1), itl = split(l);
    int pre = 0, nw = val * (r - l + 1);
    for (IT it = split(l); it != split(r + 1); ++it) pre += (it -> r - it -> l + 1) * it -> val;
    st.erase(itl, itr);
    st.insert(node(l, r, val));
    return abs_(nw - pre);
}

inline int get(int l) {
    return split(l) -> val;
}

int n, u, v, q, x;
string opt;

int main() {
    n = readi();
    for (int i = 1; i < n; ++i) {
        u = readi();
        nd[u + 1].nxt.push_back(i + 1);
    	nd[i + 1].nxt.push_back(u + 1);
    } dfs1(1, 0); dfs2(1, 0, 1);
    q = readi(); st.insert(node(1, n, 0));
    while (q--) {
        cin >> opt >> x; ++x;
        if (opt == "uninstall") printf("%d\n", assign(nd[x].pos, nd[x].pos + nd[x].siz - 1, 0));
        else if (opt == "install") {
        	int sm = 0;
            while (x != 0) {
                sm += assign(nd[nd[x].top].pos, nd[x].pos, 1);
                x = nd[nd[x].top].fa;
            } printf("%d\n", sm);
		}
    } return 0;
}
```


---

## 作者：1saunoya (赞：2)

$\text{感谢 @狸狸养的敏敏 面对面教我ODT 帮他宣传一波（划掉）}$

[$\text{here}$](https://www.luogu.org/blog/Letusaccepted/odt-ke-duo-li-shu-xue-xi-bi-ji)

$\text{如果你不会树链剖分 请去模板题。}$

$\text{ODT , Old Driver Tree ， 就是一种数据结构 你修改越多 这个算法的复杂度越低。}$

$\text{操作大概是这个样子的 ： 用set 维护 n 个块(n指的是序列长度)}$

~~~
struct node {
	int l ; int r ;
	mutable int val ;
	bool operator < (const node & x) const {
		return l < x.l ;
	}
};
set < node > s ;

#define slt set < node > :: iterator
...
n = read() ;
s.insert({1 , n + 1 , 0}) ;

~~~


$\text{反正不管 你区间修改的时候就把块合并起来。。}$

$\text{所以按照这个思路 我们可以先建一个大块。。因为初始是1-n 都是0}$

$\text{然后你在修改之前查询一下区间的值。。修改之后就是 (r - l + 1) * val}$
$\text{返回绝对值即可。。}$


$\mathcal{Code}$

```cpp
//Isaunoya
#include<bits/stdc++.h>
using namespace std ;
inline int read() { register int x = 0 ; register int f = 1 ; register char c = getchar() ;
	for( ; ! isdigit(c) ; c = getchar()) if(c == '-') f = -1 ;
	for( ; isdigit(c) ; c = getchar()) x = (x << 1) + (x << 3) + (c & 15) ;
	return x * f ;
} int st[105] ;
template < typename T > inline void write(T x , char c = '\n') { int tp = 0 ;
	if(x == 0) return (void) puts("0") ;
	if(x < 0) putchar('-') , x = -x ;
	for( ; x ; x /= 10) st[++ tp] = x % 10 ;
	for( ; tp ; tp --) putchar(st[tp] + '0') ;
	putchar(c) ;
}
//#define Online_Judge

struct node {
	int l ; int r ;
	mutable int val ;
	bool operator < (const node & x) const {
		return l < x.l ;
	}
};
set < node > s ;

#define slt set < node > :: iterator
inline slt Split(int pos) {
	slt it = s.lower_bound((node) {pos}) ;
	if(it != s.end() && it -> l == pos) return it ;
	-- it ;
	int l = it -> l ;
	int r = it -> r ;
	int val = it -> val ;
	s.erase(it) ;
	s.insert({l , pos - 1 , val}) ;
	return s.insert({pos , r , val}).first ;
}
inline int Assign(int l , int r , int val) {
	slt it2 = Split(r + 1) ;
	slt it1 = Split(l) ;
	int sum = 0 ;
	int sum2 = (r - l + 1) * val  ;
	for(slt it = it1 ; it != it2 ; it ++) sum += (it -> r - it -> l + 1) * it -> val ;
	s.erase(it1 , it2) ;
	s.insert({l , r , val}) ;
	return abs(sum - sum2) ;
}
int n ;
struct Node {
	int v ;
	int nxt ;
};
const int N = 1e5 + 10 ;
Node e[N << 1] ;
int cnt = 0 ;
int head[N] ;
inline void Add(int u , int v) {
	e[++ cnt].v = v ;
	e[cnt].nxt = head[u] ;
	head[u] = cnt ;
	return ;
}
int top[N] ;
int id[N] ; int size[N] ;
int d[N] ; int idx = 0 ;
int fa[N] ; int son[N] ;
inline void Dfs1(int u) {
	size[u] = 1 ;
	for(register int i = head[u] ; i ; i = e[i].nxt ) {
		int v = e[i].v ;
		if(v == fa[u]) continue ;
		d[v] = d[u] + 1 ;
		fa[v] = u ;
		Dfs1(v) ;
		size[u] += size[v] ;
		if(size[v] > size[son[u]]) son[u] = v ;
	}
	return ;
}
inline void Dfs2(int u , int t) {
	id[u] = ++ idx ;
	top[u] = t ;
	if(! son[u]) return ;
	Dfs2(son[u] , t) ;
	for(register int i = head[u] ; i ; i = e[i].nxt) {
		int v = e[i].v ;
		if((v ^ fa[u]) && (v ^ son[u])) Dfs2(v , v) ;
	}
}
inline int getopt() { string s = "" ;
	register char c = getchar() ;
	while(isspace(c)) c = getchar() ;
	while(! isspace(c)) {
		s += c ;
		c = getchar() ;
	}
	if(s == "install") return 1 ;
	if(s == "uninstall") return 0 ;
}
inline int Change_Range(int x , int y) {
	int fx = top[x] ;
	int fy = top[y] ;
	int ans = 0 ;
	while(fx ^ fy) {
		if(d[fx] < d[fy]) swap(x , y) , swap(fx , fy) ;
		ans += Assign(id[fx] , id[x] , 1) ;
		x = fa[fx] ;
		fx = top[x] ;
	}
	if(id[x] > id[y]) swap(x , y) ;
	ans += Assign(id[x] , id[y] , 1) ;
	return ans ;
}
inline int Uninstall(int x) {
	return Assign(id[x] , id[x] + size[x] - 1 , 0) ;
}
signed main() {
#ifdef Online_Judge
	freopen("testdata.in" , "r" , stdin) ;
	freopen("testdata2.out" , "w" , stdout) ;
#endif
	n = read() ;
	s.insert({1 , n + 1 , 0}) ;
	for(register int i = 2 ; i <= n ; i ++) {
		int u = read() ; u ++ ;
		Add(u , i) ;
		Add(i , u) ;
	}
	Dfs1(1) ;
	Dfs2(1 , 1) ;
	for(register int t = read() ; t -- ; ) {
		int opt = getopt() ;
		if(opt == 1) {
			int x = read() ; x ++ ;
			write(Change_Range(x , 1)) ;
		}
		if(opt == 0) {
			int x = read() ; x ++ ;
			write(Uninstall(x)) ;
		}
	}
	return 0 ;
}

```

---

## 作者：yzhang (赞：2)

这道题就是树链剖分的模板，详细解释见程序。

学完树的dfs序，lca，线段树食用更佳。

~~不会这些学什么树剖（逃~~~
```cpp
#include <bits/stdc++.h> //万能头文件
using namespace std;
int n,q,tot;
int fa[100005],size[100005],dep[100005],son[100005];
int lo[100005],top[100005];
int sum[800005],tag[800005];	
vector <int> allson[100005];
//线段树
void pushup(int x)//更新
{
	sum[x]=sum[x<<1]+sum[(x<<1)+1];
}
void pushdown(int x,int l,int r)//清除懒标记
{
	if(tag[x]!=-1)
	{
		int m=(l+r)>>1;
		int ls=x<<1;
		int rs=ls+1;
		tag[ls]=tag[rs]=tag[x];
		sum[ls]=(m-l+1)*tag[x];
		sum[rs]=(r-m)*tag[x];
		tag[x]=-1; 
	}
}
void update(int x,int l,int r,int L,int R,int v)//修改
{
	if(R<l||r<L)
		return;
	if(L<=l&&r<=R)
	{
		sum[x]=(r-l+1)*v;
		tag[x]=v;
		return;
	}
	pushdown(x,l,r);
	int m=(l+r)>>1;
	update(x<<1,l,m,L,R,v);
	update((x<<1)+1,m+1,r,L,R,v);
	pushup(x);
}
//树链剖分
void change(int x,int y,int v)//类似lca
{
	int fx=top[x],fy=top[y];
    while(fx!=fy)
    {
        if(dep[fx]<dep[fy])
			swap(x,y),swap(fx,fy);
        update(1,1,tot,lo[fx],lo[x],v);
        x=fa[fx],fx=top[x];
    }
    if(lo[x]>lo[y])
		swap(x,y);
    update(1,1,tot,lo[x],lo[y],v);
}
void dfs1(int x)
{
	size[x]=1;
	for(int i=0;i<allson[x].size();++i)
	{
		int v=allson[x][i];
		dep[v]=dep[x]+1;//深度
		dfs1(v);
		size[x]+=size[v];//子树大小
		if(size[v]>size[son[x]])
			son[x]=v;//重儿子
	}
}
void dfs2(int x,int t)
{
	lo[x]=++tot;	
	top[x]=t;//重链父亲
	if(son[x])
		dfs2(son[x],t);
	for(int i=0;i<allson[x].size();++i)
	{
		int v=allson[x][i];
		if(v!=son[x])
			dfs2(v,v);
	}
} 
int main()
{
	memset(tag,-1,sizeof(tag)); //lazy_tag为-1表示没有
	ios::sync_with_stdio(0);
	cin>>n;
	fa[1]=1;
	for(int i=2;i<=n;++i)
	{
		int x;
		cin>>x;
		fa[i]=x+1;
		allson[x+1].push_back(i);
	}
    //预处理
	dfs1(1);
	dfs2(1,1);
	cin>>q;
	while(q--)
	{
		string s;
		int x;
		cin>>s>>x;
		x++;
		int before=sum[1];//改之前
		if(s=="install")
		{
			change(1,x,1);//1到x路上全改成1
			int after=sum[1];//改后
			cout<<fabs(before-after)<<endl;
		}
		else
		{
			update(1,1,n,lo[x],lo[x]+size[x]-1,0);//把x的子树改成0
			int after=sum[1];//改后
			cout<<fabs(before-after)<<endl;
		}
	}
	return 0;
}
```

---

## 作者：bztMinamoto (赞：2)

更好的阅读体验请移步[我的blog](https://www.cnblogs.com/bztMinamoto/p/9328728.html)

嗯……树链剖分的题目……

有点懵逼……看了看大佬们的题解才知道树剖还有这么多讲究……

首先，我们可以将所有的软件看作一棵树，初始时都是-1

对于安装操作，相当于将它到根节点的路径上的点全都变为1

对于卸载操作，相当于将它的子树全都变为0

然后只要输出每次操作前后整棵树权值的变化量即可

卸载操作的话……直接在dfs序后的线段树上区间覆盖

安装操作的话……在树剖树上向上走，然后不断更新路径即可

```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long LL;
const int N=200005;
struct SegmentTree{
    int l,r;
    LL sum,add;
    #define l(x) tree[x].l
    #define r(x) tree[x].r
    #define sum(x) tree[x].sum
    #define add(x) tree[x].add
} tree[N*4];
int n,m,a[N],top_,num;
int size[N],son[N],fa[N],dep[N],top[N],cnt[N],rnk[N];
int ver[N*2],Next[N*2],head[N];char s[20];
int read()
{
    int x=0,f=1;
    char ch=getchar();
    for (; !isdigit(ch); ch=getchar()) if(ch=='-') f=-1;
    for (; isdigit(ch); ch=getchar()) x=x*10+ch-'0';
    return x*f;
}
void add_(int x,int y){
    ver[++top_]=y,Next[top_]=head[x],head[x]=top_;
}
void dfs(int x){
    size[x]=1,dep[x]=dep[fa[x]]+1;
    for(int i=head[x];i;i=Next[i]){
        int y=ver[i];
        if(y!=fa[x]){
            fa[y]=x;
            dfs(y);
            size[x]+=size[y];
            if(!son[x]||size[y]>size[son[x]]){
                son[x]=y;
            }
        }
    }
}
void dfs_(int x){
    if(!top[x]) top[x]=x;
    cnt[x]=++num,rnk[num]=x;
    if(son[x]) top[son[x]]=top[x],dfs_(son[x]);
    for(int i=head[x];i;i=Next[i]){
        int y=ver[i];
        if(y!=fa[x]&&y!=son[x]){
            dfs_(y);
        }
    }
}
void build(int p,int l,int r)
{
    l(p)=l,r(p)=r;
    if(l==r) {sum(p)=0,add(p)=-1;return;}
    int mid=(l+r)>>1;
    build(p<<1,l,mid);
    build((p<<1)|1,mid+1,r);
}
void spread(int p)
{
    if(~add(p))
    {
        int lc=p<<1,rc=(p<<1)+1;
        sum(lc)=add(p)*(r(lc)-l(lc)+1),sum(lc);
        sum(rc)=add(p)*(r(rc)-l(rc)+1),sum(rc);
        add(lc)=add(p);
        add(rc)=add(p);
        add(p)=-1;
    }
}
void update(int p,int l,int r,int d)
{
    if(l<=l(p)&&r>=r(p))
    {
        sum(p)=1ll*d*(r(p)-l(p)+1);
        add(p)=d;
        return;
    }
    spread(p);
    int mid=(l(p)+r(p))>>1;
    if(l<=mid) update(p<<1,l,r,d);
    if(r>mid) update((p<<1)+1,l,r,d);
    sum(p)=sum(p<<1)+sum((p<<1)+1);
}
void change(int u,int v,int val){
    while(top[u]!=top[v]){
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        update(1,cnt[top[u]],cnt[u],val);
        u=fa[top[u]];
    }
    if(dep[u]>dep[v]) swap(u,v);
    update(1,cnt[u],cnt[v],val);
    return;
}
int main()
{
    //freopen("testdata.in","r",stdin);
    n=read();
    for(int i=2;i<=n;++i){
        int x=read();++x;
        add_(x,i);
    }
    m=read();
    dfs(1),dfs_(1);build(1,1,n);
    while(m--){
        scanf("%s",s);
        int x=read();++x;
        int t1=sum(1);
        if(s[0]=='i'){
            change(1,x,1);
            int t2=sum(1);
            printf("%d\n",abs(t1-t2));
        }
        else{
            update(1,cnt[x],cnt[x]+size[x]-1,0);
            int t2=sum(1);
            printf("%d\n",abs(t1-t2));
        }
    }
    return 0;
}
```

---

## 作者：Fuko_Ibuki (赞：2)

半小时打个树剖,然后先挂掉了.  
发现线段树修改的时候当做区间覆盖了.  
然后改对了,T了.
我突然想起来什么.
```
/*
本题中的根节点是0,我在处理son数组的时候将它的初值赋为0,接下来就炸了.
题目非常复杂,但其实就是修改到根节点的路径或者子树,并且询问.
这样线段树处理区间覆盖和区间和就可以了.
当然处理的时候把所有点编号+1也是可以的.
树链剖分裸题应该不用多讲了.
*/
#include<bits/stdc++.h> //Ithea Myse Valgulious
namespace chtholly{
typedef long long ll;
#define re0 register int
#define rec register char
#define rel register ll
#define gc getchar
#define pc putchar
#define p32 pc(' ')
#define pl puts("")
/*By Citrus*/
inline int read(){
  re0 x=0,f=1;rec c=gc();
  for (;!isdigit(c);c=gc()) f^=c=='-';
  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');
  return f?x:-x;
  }
inline void read(rel &x){
  x=0;re0 f=1;rec c=gc();
  for (;!isdigit(c);c=gc()) f^=c=='-';
  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');
  x=f?x:-x;
  }
template <typename mitsuha>
inline int write(mitsuha x){
  if (!x) return pc(48);
  if (x<0) x=-x,pc('-');
  re0 bit[20],i,p=0;
  for (;x;x/=10) bit[++p]=x%10;
  for (i=p;i;--i) pc(bit[i]+48);
  }
inline char fuhao(){
  rec c=gc();
  for (;isspace(c);c=gc());
  return c;
  }
}using namespace chtholly;
using namespace std;
const int yuzu=1e5;
typedef int fuko[yuzu|10];
vector<int> lj[yuzu|10];
int n,q;

namespace shu_lian_pou_fen{
fuko sz,dep,fa,son,top,dfn,ord;int cnt;

void dfs1(int u){
  dep[u]=dep[fa[u]]+1,sz[u]=1;
  for (re0 i=0;i<lj[u].size();++i){
    int v=lj[u][i];
    dfs1(v),sz[u]+=sz[v];
    if (!~son[u]||sz[v]>sz[son[u]]) son[u]=v;  
    }
  }

void dfs2(int u,int _top){
  top[u]=_top,dfn[u]=++cnt,ord[cnt]=u;
  if (~son[u]) dfs2(son[u],_top);
  for (re0 i=0;i<lj[u].size();++i){
    int v=lj[u][i];
    if (v^son[u]) dfs2(v,v);
    }
  }

typedef int karen[yuzu<<2|13];
struct segtree{
#define le rt<<1
#define ri le|1
#define ls le,l,mid
#define rs ri,mid+1,r
karen val,lazy;
void build(int rt=1,int l=1,int r=n){
  lazy[rt]=-1;
  if (l==r) val[rt]=0;
  else{
    int mid=l+r>>1;
    build(ls),build(rs);
    val[rt]=0;
    }
  }
void push_down(int rt,int l,int r){
  if (~lazy[rt]){
    int mid=l+r>>1;
    lazy[le]=lazy[ri]=lazy[rt];
    val[le]=(mid-l+1)*lazy[rt];
    val[ri]=(r-mid)*lazy[rt];
    lazy[rt]=-1;
    }
  }
void update(int ql,int qr,int v,int rt=1,int l=1,int r=n){
  if (ql>r||qr<l) return;
  if (ql<=l&&qr>=r){
    val[rt]=(r-l+1)*v;
    lazy[rt]=v;
    }else{
    int mid=l+r>>1;
    push_down(rt,l,r);
    update(ql,qr,v,ls),update(ql,qr,v,rs);
    val[rt]=val[le]+val[ri];
	}
  }
int query(int ql,int qr,int rt=1,int l=1,int r=n){
  if (ql>r||qr<l) return 0;
  if (ql<=l&&qr>=r) return val[rt];
  int mid=l+r>>1;
  push_down(rt,l,r);
  return query(ql,qr,ls)+query(ql,qr,rs);
  }
}my_;

#define all(u) dfn[u],dfn[u]+sz[u]-1
void update(int u,int v,int w){
  for (;top[u]^top[v];u=fa[top[u]]){
    if (dep[top[u]]<dep[top[v]]) swap(u,v);
    my_.update(dfn[top[u]],dfn[u],w);
    }
  if (dep[u]>dep[v]) swap(u,v);
  my_.update(dfn[u],dfn[v],w);
  }
/*
这里其实我自己是这么写的.
int query(int u,int v){//两点间询问
  int ans=0;
  for (;top[u]^top[v];u=fa[top[u]]){
    if (dep[top[u]]<dep[top[v]]) swap(u,v);
    ans+=my_.query(dfn[top[u]],dfn[u]);
    } 
  if (dep[u]>dep[v]) swap(u,v);
  return ans+my_.query(dfn[u],dfn[v]);
  }

int install(int u){
  如果下面这个询问结果为1,表示它已经下载过了,就返回0.
  下面也是一样的,删除没有下载过的软件也返回0.
  if (my_.query(dfn[u],dfn[u])) return 0;
  int cnt=query(0,u);//先算出这一条路径上的值.
  update(0,u,1);//修改
  return abs(query(0,u)-cnt);//现在减去原来就是答案.
  }
这个是一样的,重新询问子树.
int uninstall(int u){
  if (!my_.query(dfn[u],dfn[u])) return 0;
  int cnt=my_.query(all(u));
  my_.update(all(u),0);
  return abs(my_.query(all(u))-cnt);
  }
只不过下面这个直接用val[1]来计算更简洁.
*/
int install(int u){
  int cnt=my_.val[1];
  update(0,u,1);
  return abs(my_.val[1]-cnt);
  }

int uninstall(int u){
  int cnt=my_.val[1];
  my_.update(all(u),0);
  return abs(my_.val[1]-cnt);
  }

int main(){
  re0 i;
  n=read();
  memset(son,-1,sizeof son);//如果不给所有点都+1,son必须要清为-1.血的教训.
  for (i=1;i<n;++i){
    fa[i]=read();
    lj[fa[i]].push_back(i);
    }
  dfs1(0),dfs2(0,0);
  my_.build();
  for (int q=read();q--;){
    char op=fuhao();
	int u=read();
    if (op=='i'){
      write(install(u)),pl;
	  }
	else{
	  write(uninstall(u)),pl;
	  }
    }
  }
}

int main(){
shu_lian_pou_fen::main();
}
```

---

## 作者：盧鋅 (赞：1)

## 蒟蒻的题解
这是一道典型的树链剖分题

~~提交一遍过，本地调试一万年！~~

失误一：

软件包从0开始编号，假如强制从1开始剖分，然后要对所有的输入都加一，
以及询问，然后dfs1和dfs2就可以从1开始了。

失误二：

lazy标记的初始化，习惯上初始化了0，然后就和题设冲突了，memset（，-1，）就好了，很蠢的错误。

失误三：

计算错了左儿子和右儿子的长度，假如节点的长度为len，则左儿子的长度为len-（len>>1),右儿子长度为len>>1,其实用mid会好点。

失误四：
记录究竟改变了多少，其实只要看一下线段树根节点的差值就好了，没有必要在递归的时候计算。

失误五：
id[top[u]]永远<=id[u],然后一个树和它的儿子是id[u]—id[u]+size[u]-1;

失误六：

dfs2这样写会好些，因为不用初始化根节点
```cpp
void dfs2(int u,int topf){
	id[u]=++cnt_d;
	top[u]=topf;
	if(!son[u])return;
	dfs2(son[u],topf);
	int ee,v;
	for(ee=first[u];v=e[ee].v,ee;ee=e[ee].n)
		if(v!=fa[u]&&v!=son[u])
			dfs2(v,v);
}
```
失误7：由于题目的特殊性，更改和询问可以一起进行，来自同机房大佬的操作。
```
inline void cqfa(int u){
	res=a[1];
	while(top[u]!=1){
		change(1,1,n,id[top[u]],id[u],1);
		u=fa[top[u]];
	}
	change(1,1,n,id[top[u]],id[u],1);
	printf("%d\n",abs(res-a[1]));
}
inline void cqson(int u){
	res=a[1];
	change(1,1,n,id[u],id[u]+siz[u]-1,0);
	printf("%d\n",abs(res-a[1]));
}
void pushdown(int o,int len){
	if(lazy[o]==1){
		lazy[lson]=1,a[lson]=len-(len>>1);
		lazy[rson]=1,a[rson]=len>>1;
	}else if(lazy[o]==0){
		lazy[lson]=0,a[lson]=0;
		lazy[rson]=0,a[rson]=0;
	}
	lazy[o]=-1;
}
void change(int o,int l,int r,int L,int R,int k){
	if(L<=l&&r<=R){
		lazy[o]=k;
		a[o]=k*(r-l+1);
		return;
	}
	if(lazy[o]!=-1)
	pushdown(o,r-l+1);
	if(L<=mid)change(lson,l,mid,L,R,k);
	if(R>mid)change(rson,mid+1,r,L,R,k);
	pushup(o);
}
```

------------
以下都是扯淡。

~~失误八：双向加边不要忘了，嘤嘤嘤。~~

~~失误九：其实不用build去建树，因为初始都是0（滑稽）~~


------------
随缘AC。
```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
#include<cctype>
#include<cmath>
#define mid ((l+r)>>1)
#define lson (o<<1)
#define rson (o<<1|1)
#define maxn 100100
using namespace std;
inline int read(){
	register int x=0,y=0;register char ch=getchar();
	for(;!isdigit(ch);ch=getchar())if(ch=='-')y=1;
	for(;isdigit(ch);ch=getchar())x=(x<<3)+(x<<1)+(ch^48);
	return y?-x:x;
}
struct edge{
	int n,v;	
}e[maxn<<1];
int first[maxn],cnt_e=0;
inline void add_edge(int x,int y){
	e[++cnt_e].n=first[x],first[x]=cnt_e,e[cnt_e].v=y;
}
string k;
int n,q,x;
int son[maxn],fa[maxn],siz[maxn],dep[maxn];
int id[maxn],top[maxn];
int a[maxn<<2],lazy[maxn<<2];
int res,cnt_d=0;
inline voivoid pushdown(int o,int len){
	if(lazy[o]==1){
		lazy[lson]=1,a[lson]=len-(len>>1);
		lazy[rson]=1,a[rson]=len>>1;
	}else if(lazy[o]==0){
		lazy[lson]=0,a[lson]=0;
		lazy[rson]=0,a[rson]=0;
	}
	lazy[o]=-1;
}
void change(int o,int l,int r,int L,int R,int k){
	if(L<=l&&r<=R){
		lazy[o]=k;
		a[o]=k*(r-l+1);
		return;
	}
	if(lazy[o]!=-1)
	pushdown(o,r-l+1);
	if(L<=mid)change(lson,l,mid,L,R,k);
	if(R>mid)change(rson,mid+1,r,L,R,k);
	pushup(o);
}d pushup(int o){
	a[o]=a[lson]+a[rson];
}

void dfs1(int u,int f){
	fa[u]=f,dep[u]=dep[f]+1,siz[u]=1;
	int v,ee;
	for(ee=first[u];v=e[ee].v,ee;ee=e[ee].n)
		if(v!=f){
			dfs1(v,u);
			siz[u]+=siz[v];
			if(siz[son[u]]<siz[v])
				son[u]=v;
		}
}
inline void cqfa(int u){
	res=a[1];
	while(top[u]!=1){
		change(1,1,n,id[top[u]],id[u],1);
		u=fa[top[u]];
	}
	change(1,1,n,id[top[u]],id[u],1);
	printf("%d\n",abs(res-a[1]));
}
inline void cqson(int u){
	res=a[1];
	change(1,1,n,id[u],id[u]+siz[u]-1,0);
	printf("%d\n",abs(res-a[1]));
}
void dfs2(int u,int topf){
	id[u]=++cnt_d;
	top[u]=topf;
	if(!son[u])return;
	dfs2(son[u],topf);
	int ee,v;
	for(ee=first[u];v=e[ee].v,ee;ee=e[ee].n)
		if(v!=fa[u]&&v!=son[u])
			dfs2(v,v);
}
signed main(){
		n=read();
		for(register int i=2;i<=n;++i)x=read(),++x,add_edge(x,i),add_edge(i,x);
	dfs1(1,0);
	dfs2(1,1);
	memset(lazy,-1,sizeof(lazy));
	q=read();
		for(register int i=1;i<=q;++i){
			cin>>k;x=read();
			if(k=="install"){
				cqfa(x+1);
			}else if(k=="uninstall"){
				cqson(x+1);
			}
		}
	return 0;
}
```


---

## 作者：wshl (赞：1)

题解：本题主要考查树链剖分，写了好久！
- 简要题意：树上两个操作，
- 1：查询从该节点到根有多少个结点权值为0，并把0−x上的所有节点都赋为1。
- 2：查询该节点为根的子树总权值和，并更新子树全部为0。
- 1.树链剖分：其实本题主要难点是理解题意，怎么把题目的信息转化为上面的题意。就会发现其实是树链剖分的模板改动一点，线段树为区间覆盖，在区间更新和懒标记上该一下即可。码量大的题一定要细心！
- 这里的总和就为：ans=abs(操作前的总和-操作后的总和)。
- 代码如下：
```
#include<iostream>
#include<algorithm>
using namespace std;
struct N
{
	int ans,lazy;
}t[800005];
struct E
{
	int start,to;
}e[800005];
int siz[200005],d[200005],son[200005],h[200005];
int top[200005],rk[200005],f[200005],id[200005];
int n,m,P,num,sum;
void pushup(int p)
{
	t[p].ans=t[p*2].ans+t[p*2+1].ans; 
}
void build(int p,int l,int r)
{
	t[p].lazy=-1;t[p].ans=0;
	if(l==r)return ;
	int mid=l+r>>1;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
	pushup(p);
	return ;
}
void lai(int p,int l,int r)
{
	int mid=l+r>>1; //这里和模板有些不同
	if(t[p].lazy!=-1)
	{
		t[p*2].lazy=t[p*2+1].lazy=t[p].lazy;
      
		t[p*2].ans=t[p].lazy*(mid-l+1);
		t[p*2+1].ans=t[p].lazy*(r-mid);
		t[p].lazy=-1;
	}
	return ;
}
void change(int p,int l,int r,int x,int y,int z)
{
	if(x>r||y<l)return ;
	if(x<=l&&y>=r)
	{
		t[p].ans=z*(r-l+1);//这里和模板有些不同
		t[p].lazy=z;
		return ;
	}
	lai(p,l,r);
	int mid=l+r>>1;
	if(x<=mid)change(p*2,l,mid,x,y,z);
	if(y>mid)change(p*2+1,mid+1,r,x,y,z);
	pushup(p);
	return ;
}
void add(int start,int to)
{
	e[++P].to=to;
	e[P].start=h[start];
	h[start]=P;
}
void dfs1(int p,int fa,int deep)
{
	d[p]=deep;f[p]=fa;siz[p]=1;
	for(int i=h[p];i;i=e[i].start)
	{
		int k=e[i].to;
		if(k==fa)continue;
		dfs1(k,p,deep+1);
		siz[p]+=siz[k];
		if(!son[p]||siz[k]>siz[son[p]])son[p]=k;
	}
}
void dfs2(int p,int tp)
{
	id[p]=++num;rk[num]=p;top[p]=tp;
	if(!son[p])return ;
	dfs2(son[p],tp);
	for(int i=h[p];i;i=e[i].start)
	{
		int k=e[i].to;
		if(k!=son[p]&&k!=f[p])
		dfs2(k,k);
	}
}
void update(int x,int y,int v)
{
	while(top[x]!=top[y])
	{
		if(d[top[x]]<d[top[y]])swap(x,y);
		change(1,1,n,id[top[x]],id[x],v);
		x=f[top[x]];
	}
	if(d[x]>d[y])swap(x,y);
	change(1,1,n,id[x],id[y],v);
}
int main()
{
	cin>>n;
	for(int i=2;i<=n;i++)
	{
		int x;
		cin>>x;x++;
		add(x,i);add(i,x);
	}
	dfs1(1,1,1);dfs2(1,1);
	build(1,1,n);
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		char a[129193];int x;
		cin>>a;cin>>x;x++;
		sum=t[1].ans;
		if(a[0]=='i')
		{
			update(1,x,1);
			cout<<t[1].ans-sum<<endl;
		}
		else if(a[0]=='u')
		{
			change(1,1,n,id[x],id[x]+siz[x]-1,0);
			cout<<sum-t[1].ans<<endl;
		}
	}
	return 0;
} 
```


---

## 作者：离子键Ionic_Bond (赞：1)

# 真 裸树剖
这个题你只需要维护两个东西：

$\alpha$:$install$

修改该软件到0号软件路径上的所有点为1，无脑区间修改就是了；

$\beta$:$uninstall$

修改该软件子树上的所有点为0，也是无脑的区间修改。

$\gamma$:$query$

其他题解讲的很清楚了，就是求修改前后的差的绝对值，我在这里将其转换为了$deep-ans$，因为我把修改和查询合在了一个函数里，修改已经影响了答案。

# 树链剖分：

就是通过剖解树上重链的方式。将树上问题转化为区间问题。

在这里就不细讲了，详情请看[模板 树链剖分](https://www.luogu.org/problem/P3384)

_______
## Code:
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<string>
#include<iostream>
#define N 1001000
using namespace std;
int fa[N],tr[N<<2],n,a,pt[N<<2],head[N],dep[N],top[N],ms[N],sz[N],num[N],tn[N];
int tag[N<<2];
int res;
int cnt,q,timer;
string Q;
struct edg
{
	int u,v,nxt;
}e[N<<1];
void add(int u,int v)
{
	e[++cnt].nxt=head[u];
	e[cnt].u=u;
	e[cnt].v=v;
	head[u]=cnt;
}
void dfs1(int x,int f,int deep)
{
	dep[x]=deep;
	fa[x]=f;
	sz[x]=1;
	for(int i=head[x];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==fa[x])continue;
		dfs1(v,x,deep+1);
		sz[x]+=sz[v];
		if(!ms[x]||sz[v]>sz[ms[x]])ms[x]=v;
	}
}
void dfs2(int x,int topf)
{
	top[x]=topf;
	++timer;
	num[x]=timer;
	if(ms[x])dfs2(ms[x],topf);
	for(int i=head[x];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==fa[x]||v==ms[x])continue;
		dfs2(v,v);
	}
}
int ls(int p){return p<<1;}
int rs(int p){return p<<1|1;}
void pushdown(int p,int l,int r)
{
	int md=(l+r)>>1;
	tag[ls(p)]=tag[rs(p)]=tag[p];
	if(tag[p]==0)tr[ls(p)]=tr[rs(p)]=tag[p];
	else tr[ls(p)]=md-l+1,tr[rs(p)]=r-md;
	tag[p]=-1;
}
void pushup(int p)
{
	tr[p]=tr[ls(p)]+tr[rs(p)];
}
int chsum(int p,int l,int r,int gl,int gr,int k)
{
	int res=0;
	if(gl<=l&&gr>=r)
	{
		int res1=tr[p];
		tag[p]=k;
		tr[p]=(r-l+1)*k;
		return res1;
	}
	if(tag[p]!=-1)pushdown(p,l,r);
	int md=(l+r)>>1;
	if(gl<=md)res+=chsum(ls(p),l,md,gl,gr,k);
	if(gr>md)res+=chsum(rs(p),md+1,r,gl,gr,k);
	pushup(p);
	return res;
}
int qofw(int s,int t)
{
	int res=0;
	while(top[s]!=top[t])
	{
		if(dep[top[s]]<dep[top[t]])swap(s,t);
		res+=chsum(1,1,n,num[top[s]],num[s],1);
		s=fa[top[s]];
	}
	if(dep[s]>dep[t])swap(s,t);
	res+=chsum(1,1,n,num[s],num[t],1);
	return res;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n-1;i++)
	{
		int v;
		scanf("%d",&v);
	//	add(i,v);
		add(v,i);
	}
	dfs1(0,-1,0);
	dfs2(0,0);
	memset(tag,-1,sizeof(tag));
	scanf("%d",&q);
	for(int i=1;i<=q;i++)
	{
		cin>>Q;
		int s;
		if(Q=="install")
		{
			scanf("%d",&s);			
			res=qofw(s,0);
			res=dep[s]-res+1;
		}
		if(Q=="uninstall")
		{
			scanf("%d",&s);
			res=chsum(1,1,n,num[s],num[s]+sz[s]-1,0);
		}
		printf("%d\n",res);
	}
   return ~~(0-0);
}
```


---

## 作者：Randolph、 (赞：1)

[P2146 [NOI2015]软件包管理器](https://www.luogu.org/problem/P2146)

~~感觉代码比其他题解更简洁qwq~~

树链剖分模板题

- install x：将1~x的路径上的节点全部变成1（安装x需要先安装1~x）

- uninstall x：将x子树节点全部变成0（卸载x后x子树节点都会被卸载）

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include<cstring>
using namespace std;
#define N 200005

inline int in() {
    char ch = getchar();
    int x = 0;
    while (ch < '0' || ch > '9') ch = getchar();
    while (ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();
    return x;
}

char st[15];
int n, m, cnt, h[N], w[N], a[N << 2], laz[N << 2];
int f[N], son[N], d[N], top[N], seg[N], s[N];
struct edge {
    int v, h;
} e[N << 1];

inline void add(int u, int v) { e[++cnt] = (edge){ v, h[u] }, h[u] = cnt; }

void dfs1(int u, int fa) {
    f[u] = fa, d[u] = d[fa] + 1, s[u] = 1; //s：size 子树大小
    for (int i = h[u], v; i; i = e[i].h)
        if ((v = e[i].v) ^ fa) {
            dfs1(v, u), s[u] += s[v];
            if (s[v] > s[son[u]])
                son[u] = v; //son：重儿子
        }
}

void dfs2(int u, int TOP) {
    seg[u] = ++cnt, top[u] = TOP;
    if (!son[u])
        return;
    dfs2(son[u], TOP);
    for (int i = h[u], v; i; i = e[i].h)
        if ((v = e[i].v) ^ son[u] && v ^ f[u])
            dfs2(v, v);
}

inline void pushdown(int o, int len) {
    laz[o << 1] = laz[o], laz[o << 1 | 1] = laz[o];
    a[o << 1] = laz[o] * (len - (len >> 1)), a[o << 1 | 1] = laz[o] * (len >> 1); //实际上就是把“+=”改为“=”
    laz[o] = -1;
}

void treeupd(int o, int l, int r, int L, int R, int k) { //k=1表安装，k=0表卸载，这样一来方便更新a数组
    if (r < L || l > R)
        return;
    if (L <= l && R >= r) {
        laz[o] = k;
        a[o] = k * (r - l + 1); //a就相当于sum
        return;
    }
    if (laz[o] != -1)
        pushdown(o, r - l + 1);
    int mid = (l + r) >> 1;
    treeupd(o << 1, l, mid, L, R, k);
    treeupd(o << 1 | 1, mid + 1, r, L, R, k);
    a[o] = a[o << 1] + a[o << 1 | 1];
}

inline void upd(int u, int v) {
    while (top[u] ^ top[v]) {
        if (d[top[u]] < d[top[v]])
            swap(u, v);
        treeupd(1, 1, n, seg[top[u]], seg[u], 1);
        u = f[top[u]];
    }
    if (d[u] > d[v])
        swap(u, v);
    treeupd(1, 1, n, seg[u], seg[v], 1);
}

int main() {
    scanf("%d", &n);
    memset(laz,-1,sizeof(laz));
    for (int i = 2, x; i <= n; i++) x = in() + 1, add(x, i); //节点编号统一加1，由于i依赖x，所以建单向边即可
    dfs1(1, 1), cnt = 0, dfs2(1, 1);
    scanf("%d", &m);
    for (int k, x, num; m; m--) {
        scanf("%s", st), x = in() + 1, num = a[1]; //num存原已安装节点数
        if (st[0] == 'i')
            upd(1, x), printf("%d\n", a[1] - num); //upd：修改1~x路径上的节点
        else
            treeupd(1, 1, n, seg[x], seg[x] + s[x] - 1, 0), printf("%d\n", num - a[1]); //修改x子树
    }
}
```


---

## 作者：xukuan (赞：1)

我们来看一下这题的各种操作：
- 把一个点到根节点路径上的所有点变成1
- 把一个点和它的所有子节点变成0

用1表示被安装了，0表示没有安装

又是子树又是路径的集体操作，很容易想到**树剖**

那么对于线段树，我们记录什么？
- 点信息：每个点的值
- 区间信息：以当前点为根的子树的值的和（有点绕，换一种方式理解就是：当p为根时，值是$\sum_{i=p}^{p+size_p-1} value_i$，其中$size_p$表示以$p$为根的子树的大小，$value_i$表示点$i$的值）
- 目标信息：所有点的值的和

我们输出时，输出操作前后两次目标信息之差即可。因为每一次改变只会把1改成0或把0改成1，那样子变化的值的绝对值刚好就是变化数量

PS：代码风格，变量名等偏向《算法竞赛进阶指南》（李煜东 著），习惯那本书风格的可以看我的代码

代码：
```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

const ll N=100010;
ll ver[N<<1],Next[N<<1],head[N],tot;//链式前向星存边
ll n,m,cnt,d[N],father[N],size[N],son[N],id[N],top[N];
//size[x]表示以x为根节点的子树的大小
//son[x]表示x的重儿子的编号
struct SegmentTree{
	ll l,r,sum,lazy;
	//lazy表示懒标记
	//lazy=-1表示标记为空
	//lazy=0表示点的值变成0
	//lazy=1表示点的值变成1
}tree[N<<2];

inline ll read(){
	ll x=0,tmp=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') tmp=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return tmp*x;
}

inline void write(ll x){
	if(x<0){
		x=-x;
		putchar('-');
	}
	ll y=10,len=1;
	while(y<=x){
		y=(y<<3)+(y<<1);
		len++;
	}
	while(len--){
		y/=10;
		putchar(x/y+48);
		x%=y;
	}
}

inline void addEdge(ll x,ll y){
	ver[++tot]=y;
	Next[tot]=head[x];
	head[x]=tot;
}

void dfs1(ll x,ll before){
	size[x]=1; father[x]=before; d[x]=d[before]+1;
	for(ll i=head[x]; i; i=Next[i]){
		ll y=ver[i];
		if(y==before) continue;
		dfs1(y,x);
		size[x]+=size[y];
		if(size[y]>size[son[x]]) son[x]=y;
	}
}

void dfs2(ll x,ll topf){
	id[x]=++cnt; top[x]=topf;
	if(!son[x]) return;
	dfs2(son[x],topf);
	for(ll i=head[x]; i; i=Next[i]){
		ll y=ver[i];
		if(y==father[x]||y==son[x]) continue;
		dfs2(y,y);
	}
}

void build(ll p,ll l,ll r){
	tree[p].l=l; tree[p].r=r;
	tree[p].sum=0; tree[p].lazy=-1;
	if(l==r) return;
	ll mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
}

inline void pushup(ll p){
	tree[p].sum=tree[p<<1].sum+tree[p<<1|1].sum;
}

inline void pushdown(ll p){
	if(tree[p].lazy!=-1){
		tree[p<<1].sum=(tree[p<<1].r-tree[p<<1].l+1)*tree[p].lazy;
		tree[p<<1|1].sum=(tree[p<<1|1].r-tree[p<<1|1].l+1)*tree[p].lazy;
		tree[p<<1].lazy=tree[p<<1|1].lazy=tree[p].lazy;
		tree[p].lazy=-1;	
	}
}

void update(ll p,ll l,ll r,ll val){
	if(l<=tree[p].l&&tree[p].r<=r){
		tree[p].sum=(tree[p].r-tree[p].l+1)*val;
		tree[p].lazy=val;
		return;
	}
	pushdown(p);
	ll mid=(tree[p].l+tree[p].r)>>1;
	if(l<=mid) update(p<<1,l,r,val);
	if(r>mid) update(p<<1|1,l,r,val);
	pushup(p);
}

inline void Update(ll x,ll y,ll val){
	while(top[x]!=top[y]){
		if(d[top[x]]<d[top[y]]) swap(x,y);
		update(1,id[top[x]],id[x],val);
		x=father[top[x]];
	}
	if(d[x]>d[y]) swap(x,y);
	update(1,id[x],id[y],val);
}

int main(){
	n=read();
	for(ll i=2; i<=n; i++){
		ll x=read()+1;
		addEdge(x,i);
		addEdge(i,x);
	}
	dfs1(1,0); dfs2(1,1);
	build(1,1,n);
	m=read();
	while(m--){
		char s[100]; scanf("%s",s);
		ll x=read()+1,sum=tree[1].sum;
		if(s[0]=='i'){
			Update(1,x,1);
			write(tree[1].sum-sum); putchar('\n');
		}
		else if(s[0]=='u'){
			update(1,id[x],id[x]+size[x]-1,0);
			write(sum-tree[1].sum); putchar('\n');
		}
		else printf("WTF??? %lld\n",m);
	}
	return 0;
}
```

---

## 作者：1379号监听员 (赞：1)

# P2146 题解
[关于树链剖分的教程](https://listening-post-1379.blog.luogu.org/post-suan-fa-bi-ji-shu-lian-pou-fen)

## 思路
这题就是一道**树链剖分**的模板题，用0和1分别代表每个软件的存在与否，那么“安装$k$”操作就是把从$1$到$k$的路径上的节点都置为$1$，而“卸载$k$”则是将$k$的子树都置为$0$，用树链剖分就可以十分方便地维护这两种操作。

然后对根节点求区间和就可以求出一共有多少个状态值为$1$（即安装了）的软件，用这个数减去上一次操作时的安装软件数即为改变的数目。

---

## Tips：
-  “赋值”运算不能进行叠加，打延迟标记时要注意**先将原有的延迟标记下传**
-  数据范围这么大一定要写**快读**

---

##代码
```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <vector>
#include <cmath>
using namespace std;
const int maxn=100005;
int n,m,last;
vector<int> e[maxn];
int father[maxn],dep[maxn],size[maxn],hson[maxn],top[maxn],seg[maxn],rev[maxn<<2],num[maxn],tot;
struct segmenttree{ //线段树
    int l,r,sum,add=-1;
    #define l(x) tree[x].l
    #define r(x) tree[x].r
    #define sum(x) tree[x].sum
    #define add(x) tree[x].add
};
segmenttree tree[maxn<<2];
inline int readint() { //快读
   int x=0;char ch=getchar();
    while(ch<48||ch>57) ch=getchar();
    while(ch>=48&&ch<=57) x=x*10+ch-48,ch=getchar();
    return x;
}
inline void readchar(char * input) { //快读
  int len=0;
  char ch=getchar();
  while(ch!=' ' && ch!='\r' && ch !='\n')
  {
    input[len++]=ch;
    ch=getchar();
  }
}
void addedge(int x,int y) //vector存图
{
    e[x].push_back(y);
    e[y].push_back(x);
}
void dfs1(int u,int f) //树剖预处理
{
    size[u]=1;
    father[u]=f;
    dep[u]=dep[f]+1;
    for(int i=0;i<e[u].size();i++)
    {
        int v=e[u][i];
        if(v!=f)
        {
            dfs1(v,u);
            size[u]+=size[v];
            if(size[v]>size[hson[u]]) hson[u]=v;
        }
    }
}
void dfs2(int u,int f) //树剖预处理
{
    if(hson[u])
    {
        seg[hson[u]]=++tot;
        top[hson[u]]=top[u];
        rev[tot]=hson[u];
        dfs2(hson[u],u);
    }
    for(int i=0;i<e[u].size();i++)
    {
        int v=e[u][i];
        if(!top[v])
        {
            seg[v]=++tot;
            rev[tot]=v;
            top[v]=v;
            dfs2(v,u);
        }
    }
}
void build(int p,int l,int r) //线段树建树
{
    int mid=(l+r)>>1;
    l(p)=l;r(p)=r;
    if(l==r){
        sum(p)=num[rev[l]];
        return;
    }
    build(p<<1,l,mid);
    build(p<<1|1,mid+1,r);
    sum(p)=(sum(p<<1)+sum(p<<1|1));
    return;
}
void spread(int p) //下传延迟标记
{
	if(add(p)>=0)
	{
		sum(p<<1)=add(p)*(r(p<<1)-l(p<<1)+1);
		sum(p<<1|1)=add(p)*(r(p<<1|1)-l(p<<1|1)+1);
		add(p<<1)=add(p);
		add(p<<1|1)=add(p);
		add(p)=-1;
	}
}
int query(int p,int l,int r) //区间查询
{
  if(l>r) swap(l,r);
  if(l<=l(p) && r>=r(p)) return sum(p);
  spread(p);
  int mid=((l(p)+r(p))>>1);
  int ans=0;
  if(l<=mid) ans=(ans+query(p<<1,l,r));
  if(r>mid) ans=(ans+query(p<<1|1,l,r));
  return ans;
}
void update(int p,int l,int r,int c) { //区间更新
  if(l>r) swap(l,r);
  spread(p); //先将原有的延迟标记下传
  if(l<=l(p) && r>=r(p)) {
		sum(p)=c*(r(p)-l(p)+1);
		add(p)=c;
		return;
	}
	int mid=((l(p)+r(p))>>1);
	if(l<=mid) update(p<<1,l,r,c);
	if(r>mid) update(p<<1|1,l,r,c);
	sum(p)=(sum(p<<1)+sum(p<<1|1));
}
void crange(int x,int y,int k) //路径修改
{
  while(top[x]!=top[y]) {
    if(dep[top[x]]<dep[top[y]]) swap(x,y);
    update(1,seg[top[x]],seg[x],k);
    x=father[top[x]];
  }
  if(dep[x]>dep[y]) swap(x,y);
  update(1,seg[x],seg[y],k);
}
void cson(int x,int k) //子树修改
{
  update(1,seg[x],seg[x]+size[x]-1,k);
}
int main()
{
  n=readint();
  for(int i=2,a;i<=n;i++){
    a=readint();
    addedge(i,a+1);
  }
  m=readint();
  dfs1(1,0);
  tot=seg[1]=1; //树剖初始化
  top[1]=rev[1]=1;
  dfs2(1,0);
  build(1,1,n+1);
  int last=query(1,1,n); //存好上一次的软件数
  for(int i=1,x;i<=m;i++)
  {
    char op[20];
    scanf("%s\n",op);
    if (op[0]=='i') { //安装
      x=readint();
      crange(x+1,1,1);
      int cur=query(1,1,n);
      printf("%d\n",abs(last-cur)); //更新答案
      last=query(1,1,n); //存好上一次的软件数
    }
    else if (op[0]=='u') { //安装
      x=readint();
      cson(x+1,0);
      int cur=query(1,1,n);
      printf("%d\n",abs(last-cur)); //更新答案
      last=cur; //存好上一次的软件数
    }
  }
  return 0;
}
```


---

## 作者：LevenKoko (赞：1)

# [***更好的阅读体验戳我***](https://www.cnblogs.com/zhenglw/p/10356806.html)

　　 _**又是在树上瞎搞滴题目....**_ 

　　我们如果以安装的软件为1，未安装的软件为0，那么软件改变的数量即树上权值总和的数量，涉及到区间修改，区间查询，考虑 _**树剖**_ 

　　分析完毕，似乎没啥好说的了。。。树剖模板题（然鹅我是不会告诉你们我因为把int打成char查了好久好久代码滴...）　　　

　　细节问题：为了便于处理把每个节点编号都加上1，避免一些不必要的错误
  	然后注意一下push_down（标记下传）的操作，lz是lazy_tag,0代表不更新，-1代表删除（变成0），1代表安装（变成1）

　　P.S.打完才发现好像不用区间查询

　　代码（压了一丢丢行，表介意啦）：
  ```
#include<cstdio>
#include<cctype>
#include<iostream>
using namespace std;
inline int read(){
	int ans=0,f=1;char chr=getchar();
	while(!isdigit(chr)){if(chr=='-')f=-1;chr=getchar();}
	while(isdigit(chr)) {ans=(ans<<3)+(ans<<1)+chr-48;chr=getchar();}
	return ans*f;
}const int M=200005;int n,m;
inline int abs(int x) {if(x<0) return -x;return x;}
int head[M],ver[M],nxt[M],tot,fa[M],dep[M],son[M],top[M],idx[M],sz[M],t,sum[M<<2],lz[M<<2];	
inline void add(int x,int y){ver[++tot]=y;nxt[tot]=head[x];head[x]=tot;}
void dfs1(int x){
	dep[x]=dep[fa[x]]+1;sz[x]=1;
	for(int i=head[x];i;i=nxt[i]){
		if(ver[i]==fa[x]) continue;
		fa[ver[i]]=x,dfs1(ver[i]);sz[x]+=sz[ver[i]];
		if(sz[ver[i]]>sz[son[x]]) son[x]=ver[i];
	}
}void dfs2(int x,int topf){
	idx[x]=++t;top[x]=topf;
	if(!son[x]) return;dfs2(son[x],topf);
	for(int i=head[x];i;i=nxt[i])
		if(!idx[ver[i]]) dfs2(ver[i],ver[i]);
}inline void Push_Up(int i){sum[i]=sum[i<<1]+sum[i<<1|1];}
 inline void Push_Down(int i,int l,int r){
 	if(lz[i]==0) return;int mid=l+r>>1;
 	if(lz[i]==-1) sum[i<<1]=sum[i<<1|1]=0,lz[i<<1]=lz[i<<1|1]=-1;
 	else sum[i<<1]=mid-l+1,sum[i<<1|1]=r-mid,lz[i<<1]=lz[i<<1|1]=1;
 	lz[i]=0;return;
}void Update(int i,int l,int r,int ql,int qr,int x){
	if(ql<=l&&r<=qr){
		if(!x)lz[i]=-1,sum[i]=0;//lz==-1-->Update->0  lz==1 --> Update->1
		else lz[i]=1,sum[i]=r-l+1;
		return;
	}int mid=l+r>>1;Push_Down(i,l,r);
	if(mid>=ql) Update(i<<1,l,mid,ql,qr,x);
	if(mid<qr)  Update(i<<1|1,mid+1,r,ql,qr,x);
	Push_Up(i);
}void Change(int v,int x,int y){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		Update(1,1,n,idx[top[x]],idx[x],v);
		x=fa[top[x]];
	}if(dep[x]>dep[y]) swap(x,y);Update(1,1,n,idx[x],idx[y],v);
}
int main(){
//	freopen("rjb.in","r",stdin);
	n=read();
	for(int i=2;i<=n;i++){int x=read();++x;add(x,i);add(i,x);}
	dfs1(1),dfs2(1,1);
	m=read();char opt[20];int x,bf;
	while(m--){scanf("%s",opt);x=read();bf=sum[1];++x; 
		if(opt[0]=='i'){
			Change(1,x,1);
			printf("%d\n",abs(sum[1]-bf));
		}else{
			Update(1,1,n,idx[x],idx[x]+sz[x]-1,0);
			printf("%d\n",abs(sum[1]-bf));
		}
	}
	return 0;
}
  ```

---

## 作者：little_sun (赞：1)

little_sun会写树剖啦！

本题为树链剖分的模板题

对于"install x"操作, 将$x$到根节点路径上所有点的点权全部赋值为$1$

对于"uninstall x"操作, 将$x$及$x$的子树点权全部赋值为$0$

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MaxN = 150010;

struct edge
{
    int to, next;
};

struct node
{
    int l, r;
    int sum, tag;
};

struct SegmentTree
{
    node t[MaxN << 1];
    inline void pushup(int id) { t[id].sum = t[id << 1].sum + t[id << 1 | 1].sum; }
    void build(int id, int l, int r)
    {
        t[id].l = l, t[id].r = r, t[id].tag = -1;
        if (l == r)
            return;
        int mid = (l + r) >> 1;
        build(id << 1, l, mid);
        build(id << 1 | 1, mid + 1, r);
    }
    inline void pushdown(int id)
    {
        if (t[id].tag != -1)
        {
            t[id << 1].sum = t[id].tag * (t[id << 1].r - t[id << 1].l + 1);
            t[id << 1 | 1].sum = t[id].tag * (t[id << 1 | 1].r - t[id << 1 | 1].l + 1);

            t[id << 1].tag = t[id].tag;
            t[id << 1 | 1].tag = t[id].tag;

            t[id].tag = -1;
        }
    }
    inline void modify(int id, int l, int r, int delta)
    {
        if (l > t[id].r || t[id].l > r)
            return;
        if (l <= t[id].l && t[id].r <= r)
        {
            t[id].sum = delta * (t[id].r - t[id].l + 1);
            t[id].tag = delta;
            return;
        }
        if (t[id].l == t[id].r)
            return;
        pushdown(id);
        modify(id << 1, l, r, delta);
        modify(id << 1 | 1, l, r, delta);
        pushup(id);
        return;
    }
    inline int query(int id, int l, int r)
    {
        if (l > t[id].r || t[id].l > r)
            return 0;
        if (l <= t[id].l && t[id].r <= r)
            return t[id].sum;
        if (t[id].l == t[id].r)
            return 0;
        pushdown(id);
        return query(id << 1, l, r) + query(id << 1 | 1, l, r);
    }
} T;

edge e[MaxN << 1];
int n, m, cnt, dfsnum, size[MaxN], hson[MaxN];
int head[MaxN], top[MaxN], dfn[MaxN], fa[MaxN], dep[MaxN];

inline void add_edge(int u, int v)
{
    ++cnt;
    e[cnt].to = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}

inline void dfs1(int u, int f)
{
    size[u] = 1;
    for (int i = head[u]; i; i = e[i].next)
    {
        int v = e[i].to;
        if (v == f)
            continue;
        dep[v] = dep[u] + 1;
        fa[v] = u;
        dfs1(v, u);
        size[u] += size[v];
        if (size[v] > size[hson[u]])
            hson[u] = v;
    }
}

inline void dfs2(int u, int Top)
{
    ++dfsnum;
    dfn[u] = dfsnum;
    top[u] = Top;
    if (hson[u])
        dfs2(hson[u], Top);
    for (int i = head[u]; i; i = e[i].next)
    {
        int v = e[i].to;
        if (v == hson[u] || v == fa[u])
            continue;
        dfs2(v, v);
    }
}

inline int read()
{
    int x = 0;
    char ch = getchar();
    while (ch > '9' || ch < '0')
        ch = getchar();
    while (ch <= '9' && ch >= '0')
        x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    return x;
}

inline void update_tree(int u)
{
    T.modify(1, dfn[u], dfn[u] + size[u] - 1, 0);
}

inline void update_chain(int u, int v, int delta)
{
    while (top[u] != top[v])
    {
        if (dep[top[u]] < dep[top[v]])
            swap(u, v);
        T.modify(1, dfn[top[u]], dfn[u], delta);
        u = fa[top[u]];
    }
    if (dep[u] < dep[v])
        swap(u, v);
    T.modify(1, dfn[v], dfn[u], delta);
}

signed main()
{
    n = read();
    for (int i = 2; i <= n; ++i)
    {
        int u = read() + 1;
        add_edge(i, u);
        add_edge(u, i);
    }
    dep[1] = 1, fa[1] = 0;
    dfs1(1, 0), dfs2(1, 1);
    T.build(1, 1, n);
    m = read();
    for (int i = 1; i <= m; i++)
    {
        string op;
        cin >> op;
        int before = T.t[1].sum;
        if (op == "install")
        {
            int u = read() + 1;
            update_chain(u, 1, 1);
            int after = T.t[1].sum;
            printf("%d\n", after - before);
        }
        else
        {
            int u = read() + 1;
            update_tree(u);
            int after = T.t[1].sum;
            printf("%d\n", before - after);
        }
    }
    return 0;
}

```



---

## 作者：henry_y (赞：1)

## [挂个外链，（骗下访问量？）](https://www.cnblogs.com/henry-1202/p/9152374.html)

大概算是一道模板题吧？

就是细节有点多

罗列一下：
***
1. 如果习惯从1开始搞树的编号的话，处理输入进来的那个依赖关系在加边的时候两个都要+1，体现在代码就是i要从2枚举到n，然后输入进来的那个数要+1
1. 这道题的线段树的打法也有所不同，因为只有两种状态，也就是已安装和未安装，我这里是用1和0来表示的，所以lazy标记就不能打成0了，我的代码中是用-1来表示的，注意要判这个东西（当然你也可以用1和2表示这两种状态）
1. 线段树的修改也要改一下，+=得改成=（显然？）
***
剩下就是树剖模板了吧..
```cpp
#include <cstdio>
#include <cstring>
#define ll int
#define inf 1<<30
#define il inline 
il ll max(ll x,ll y){return x>y?x:y;}
il ll min(ll x,ll y){return x<y?x:y;}
il ll abs(ll x){return x>0?x:-x;}
il void swap(ll &x,ll &y){ll t=x;x=y;y=t;}
il void read(ll &x){
    x=0;ll f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    x*=f;
}
il void print(ll x){if(x<0)putchar('-');x=abs(x);if(x>9)print(x/10);putchar(x%10+'0');}
il void writeln(ll x){if(x<0)putchar('-');x=abs(x);print(x);putchar('\n');}
il void write(ll x){if(x<0)putchar('-');x=abs(x);print(x);putchar(' ');}
using namespace std;
/*===================Header Template=====================*/
#define N 100010
struct edge{ll to,next;}e[N<<2];
struct tree{ll l,r,sum,lazy;}t[N<<2];
ll cnt,head[N],sz,n,m,a[N];
ll pos[N],fa[N],dep[N],siz[N],top[N];
void insert(ll u,ll v){
    e[++cnt].next=head[u];e[cnt].to=v;head[u]=cnt;
    e[++cnt].next=head[v];e[cnt].to=u;head[v]=cnt;
}
void dfs1(ll x){
    siz[x]=1;
    for(ll i=head[x];i;i=e[i].next){
        if(fa[x]==e[i].to)continue;
        dep[e[i].to]=dep[x]+1;
        fa[e[i].to]=x;
        dfs1(e[i].to);
        siz[x]+=siz[e[i].to];
    }
}
void dfs2(ll x,ll topf){
    ll k=0;
    pos[x]=++sz;
    top[x]=topf;
    for(ll i=head[x];i;i=e[i].next){
        if(dep[e[i].to]>dep[x]&&siz[e[i].to]>siz[k])
            k=e[i].to;
    }
    if(k==0)return;
    dfs2(k,topf);
    for(ll i=head[x];i;i=e[i].next){
        if(dep[e[i].to]>dep[x]&&k!=e[i].to){
            dfs2(e[i].to,e[i].to);
        }
    }
}
void pushdown(ll ln,ll rn,ll rt){
    if(t[rt].lazy!=-1){
        ll &x=t[rt].lazy;
        t[rt<<1].sum=ln*x;
        t[rt<<1|1].sum=rn*x;
        t[rt<<1].lazy=x;
        t[rt<<1|1].lazy=x;
        x=-1;
    }
}
void build(ll l,ll r,ll rt){
    t[rt].l=l;t[rt].r=r;t[rt].lazy=-1;
    if(l==r)return;
    ll mid=(l+r)>>1;
    build(l,mid,rt<<1);
    build(mid+1,r,rt<<1|1);
}
void upd(ll L,ll R,ll c,ll rt){
    ll l=t[rt].l,r=t[rt].r,mid=(l+r)>>1;
    if(L<=l&&r<=R){t[rt].sum=(r-l+1)*c;t[rt].lazy=c;return;}
    pushdown(mid-l+1,r-mid,rt);
    if(L<=mid)upd(L,R,c,rt<<1);
    if(R>mid)upd(L,R,c,rt<<1|1);
    t[rt].sum=t[rt<<1].sum+t[rt<<1|1].sum;
}
ll query(ll L,ll R,ll rt){
    ll l=t[rt].l,r=t[rt].r,mid=(l+r)>>1,ans=0;
    if(L<=l&&r<=R)return t[rt].sum;
    pushdown(mid-l+1,r-mid,rt);
    if(L<=mid)ans+=query(L,R,rt<<1);
    if(R>mid)ans+=query(L,R,rt<<1|1);
    return ans;
}
void A(ll x,ll y){
    while(top[x]!=top[y]){
        if(dep[top[x]]<dep[top[y]])swap(x,y);
        upd(pos[top[x]],pos[x],0,1);
        x=fa[top[x]];
    }
    if(pos[x]>pos[y])swap(x,y);
    upd(pos[x],pos[y],0,1);
}
ll Q(ll x,ll y){
    ll sum=0;
    while(top[x]!=top[y]){
        if(dep[top[x]]<dep[top[y]])swap(x,y);
        sum+=query(pos[top[x]],pos[x],1);
        x=fa[top[x]];
    }
    if(pos[x]>pos[y])swap(x,y);
    sum+=query(pos[x],pos[y],1);
    return sum;
}
int main(){
    read(n);
    for(ll i=2;i<=n;i++){
        ll x;read(x);x++;
        insert(i,x);
    }
    dfs1(1);dfs2(1,1);
    build(1,n,1);
    upd(1,n,1,1);
    read(m);
    while(m--){
        char ch[10];ll x;
        scanf("%s%d",ch,&x);x++;
        if(ch[0]=='i'){writeln(Q(x,1));A(x,1);}
        if(ch[0]=='u'){
            writeln(siz[x]-query(pos[x],pos[x]+siz[x]-1,1));
            upd(pos[x],pos[x]+siz[x]-1,1,1);
        }
    }
    return 0;
}
```
~~食用请谨慎，本人人丑常数大~~

---

## 作者：jpwang (赞：1)

思路多绕了几个弯，但是不影响a了这题

容易发现安装操作就是统计root到x的路径上0的数量，显然为0的一定是从x向上的连续一整段，那么可以二分这个节点

卸载操作就是统计以x为根的子树中1的数量，然后清空

这个方法跑得巨慢，主要是要二分还要倍增向上跳，理论上讲是三个log的。。

不过没关系，洛谷现在也有o2了

```cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>
#define rep(i,st,ed) for (int i=st;i<=ed;++i)
#define drp(i,st,ed) for (int i=st;i>=ed;--i)
#define fill(x,t) memset(x,t,sizeof(x))
using std:: swap;
const int N=400005;
const int E=1600005;
struct edge{int x,y,next;}e[E];
int size[N],pos[N],dep[N],fa[N][21],bl[N],a[N];
int sum[N<<2],num[N<<2],lazy[N<<2];
int ls[N],edCnt,n,m;
int read() {
    int x=0,v=1; char ch=getchar();
    for (;ch<'0'||ch>'9';v=(ch=='-')?(-1):(v),ch=getchar());
    for (;ch<='9'&&ch>='0';x=x*10+ch-'0',ch=getchar());
    return x*v;
}
void addEdge(int x,int y) {
    e[++edCnt]=(edge){x,y,ls[x]}; ls[x]=edCnt;
    e[++edCnt]=(edge){y,x,ls[y]}; ls[y]=edCnt;
}
void dfs1(int now) {
    rep(i,1,20) fa[now][i]=fa[fa[now][i-1]][i-1];
    size[now]=1;
    for (int i=ls[now];i;i=e[i].next) {
        if (e[i].y==fa[now][0]) continue;
        dep[e[i].y]=dep[now]+1;
        fa[e[i].y][0]=now;
        dfs1(e[i].y);
        size[now]+=size[e[i].y];
    }
}
void dfs2(int now,int up) {
    pos[now]=++pos[0]; bl[now]=up;
    int mx=0;
    for (int i=ls[now];i;i=e[i].next) {
        if (e[i].y==fa[now][0]||size[e[i].y]<=size[mx]) continue;
        mx=e[i].y;
    }
    if (!mx) return ;
    dfs2(mx,up);
    for (int i=ls[now];i;i=e[i].next) {
        if (e[i].y==fa[now][0]||e[i].y==mx) continue;
        dfs2(e[i].y,e[i].y);
    }
}
void push_down(int now,int tl,int tr) {
    if (lazy[now]==-1) return ;
    int mid=(tl+tr)>>1;
    lazy[now<<1]=lazy[now];
    lazy[now<<1|1]=lazy[now];
    num[now<<1]=lazy[now];
    num[now<<1|1]=lazy[now];
    sum[now<<1]=(mid-tl+1)*lazy[now];
    sum[now<<1|1]=(tr-mid)*lazy[now];
    lazy[now]=-1;
}
int query(int now,int tl,int tr,int l,int r) {
    if (tl==l&&tr==r) return sum[now];
    push_down(now,tl,tr);
    int mid=(tl+tr)>>1;
    if (r<=mid) return query(now<<1,tl,mid,l,r);
    else if (l>mid) return query(now<<1|1,mid+1,tr,l,r);
    else return query(now<<1,tl,mid,l,mid)+query(now<<1|1,mid+1,tr,mid+1,r);
}
void modify(int now,int tl,int tr,int l,int r,int v) {
    if (tl==l&&tr==r) {
        num[now]=v;
        sum[now]=(tr-tl+1)*v;
        lazy[now]=v;
        return ;
    }
    push_down(now,tl,tr);
    int mid=(tl+tr)>>1;
    if (r<=mid) modify(now<<1,tl,mid,l,r,v);
    else if (l>mid) modify(now<<1|1,mid+1,tr,l,r,v);
    else {
        modify(now<<1,tl,mid,l,mid,v);
        modify(now<<1|1,mid+1,tr,mid+1,r,v);
    }
    sum[now]=sum[now<<1]+sum[now<<1|1];
    if (num[now<<1]==num[now<<1|1]) num[now]=num[now<<1];
    else num[now]=-1;
}
void change(int x,int y,int v) {
    while (bl[x]!=bl[y]) {
        if (dep[bl[x]]<dep[bl[y]]) swap(x,y);
        modify(1,1,n,pos[bl[x]],pos[x],v);
        x=fa[bl[x]][0];
    }
    if (pos[x]>pos[y]) swap(x,y);
    modify(1,1,n,pos[x],pos[y],v);
}
int get_sum(int x,int y) {
    int ret=0;
    while (bl[x]!=bl[y]) {
        if (dep[bl[x]]<dep[bl[y]]) swap(x,y);
        ret+=query(1,1,n,pos[bl[x]],pos[x]);
        x=fa[bl[x]][0];
    }
    if (pos[x]>pos[y]) swap(x,y);
    ret+=query(1,1,n,pos[x],pos[y]);
    return ret;
}
int UP(int x,int dep) {
    drp(i,20,0) if ((1<<i)<=dep&&fa[x][i]) x=fa[x][i],dep-=(1<<i);
    return x;
}
void solve(int x) {
    int l=0,r=dep[x]-1,prt=-1;
    while (l<=r) {
        int mid=(l+r)>>1;
        int up=UP(x,mid);
        int S=get_sum(x,up);
        if (S==0) {
            prt=mid;
            l=mid+1;
        } else r=mid-1;
    }
    change(1,x,1);
    printf("%d\n", prt+1);
}
int main(void) {
    fill(lazy,-1);
    scanf("%d",&n);
    rep(i,2,n) {
        int x; scanf("%d",&x); x++;
        addEdge(i,x);
    }
    dep[1]=1; dfs1(1); dfs2(1,1);
    scanf("%d",&m);
    while (m--) {
        char opt[10]; scanf("%s",opt);
        int x; scanf("%d",&x); x++;
        if (opt[0]=='i') {
            solve(x);
        } else if (opt[0]=='u') {
            printf("%d\n", query(1,1,n,pos[x],pos[x]+size[x]-1));
            modify(1,1,n,pos[x],pos[x]+size[x]-1,0);
        }
    }
}

```

---

## 作者：McGrady (赞：1)

裸的树链剖分+线段树，我用的非递归初始化，只要一个bfs，不仅快，还比dfs代码短。

线段树标记d=1表示区间全改1，d=0表示区间全改0，d=-1表示区间没有标记。

代码：

```cpp
program rrr(input,output);
type
  etype=record
     t,next:longint;
   end;
   treetype=record
     l,r,s,d:longint;
   end;
var
  e:array[0..200020]of etype;
  head,father,dep,top,siz,son,sson,oot,idx,q:array[-3..100010]of longint;
  a:array[0..400040]of treetype;
  n,qq,i,j,cnt,ans,h,t,x:longint;
  s:string;
procedure add(x,y:longint);
begin
   inc(cnt);e[cnt].t:=y;e[cnt].next:=head[x];head[x]:=cnt;
end;
procedure prepare;
begin
   h:=0;t:=1;q[1]:=0;dep[0]:=1;
   while h<t do
      begin
         inc(h);
         i:=head[q[h]];
         while i<>0 do
            begin
               dep[e[i].t]:=dep[q[h]]+1;
               inc(t);q[t]:=e[i].t;
               i:=e[i].next;
            end;
      end;
   for i:=0 to n-1 do siz[i]:=1;
   fillchar(sson,sizeof(sson),0);
   for i:=0 to n-1 do son[i]:=-1;
   for i:=n downto 2 do
      begin
         inc(siz[father[q[i]]],siz[q[i]]);
         if siz[q[i]]>sson[father[q[i]]] then begin son[father[q[i]]]:=q[i];sson[father[q[i]]]:=siz[q[i]]; end;
      end;
   fillchar(idx,sizeof(idx),0);father[0]:=-1;oot[-1]:=0;
   for i:=1 to n do
      if idx[q[i]]=0 then
         begin
            cnt:=oot[father[q[i]]];j:=q[i];
            while j<>-1 do
               begin
                  top[j]:=q[i];
                  inc(cnt);idx[j]:=cnt;oot[j]:=cnt;
                  inc(oot[father[j]],siz[j]);
                  j:=son[j];
               end;
         end;
end;
procedure build(k,l,r:longint);
var
  mid:longint;
begin
   a[k].l:=l;a[k].r:=r;a[k].d:=-1;a[k].s:=0;
   if l=r then exit;
   mid:=(l+r)>>1;
   build(k+k,l,mid);
   build(k+k+1,mid+1,r);
end;
procedure pushdown(k:longint);
var
  i:longint;
begin
   if a[k].l=a[k].r then begin a[k].d:=-1;exit; end;
   i:=k+k;
   if a[k].d=0 then begin a[i].s:=0;a[i].d:=0;a[i+1].s:=0;a[i+1].d:=0; end
   else begin a[i].s:=a[i].r-a[i].l+1;a[i].d:=1;a[i+1].s:=a[i+1].r-a[i+1].l+1;a[i+1].d:=1; end;
   a[k].d:=-1;
end;
function ask(k,x,y:longint):longint;
var
  mid,ans:longint;
begin
   if a[k].d<>-1 then pushdown(k);
   if (x<=a[k].l) and (a[k].r<=y) then exit(a[k].s);
   ans:=0;mid:=(a[k].l+a[k].r)>>1;
   if x<=mid then ans:=ask(k+k,x,y);
   if mid<y then ans:=ans+ask(k+k+1,x,y);
   exit(ans);
end;
procedure change0(k,x,y:longint);
var
  mid,i:longint;
begin
   if a[k].d<>-1 then pushdown(k);
   if (x<=a[k].l) and (a[k].r<=y) then begin a[k].s:=0;a[k].d:=0;exit;end;
   mid:=(a[k].l+a[k].r)>>1;i:=k+k;
   if x<=mid then change0(i,x,y);
   if mid<y then change0(i+1,x,y);
   a[k].s:=a[i].s+a[i+1].s;
end;
procedure change1(k,x,y:longint);
var
  mid,i:longint;
begin
   if a[k].d<>-1 then pushdown(k);
   if (x<=a[k].l) and (a[k].r<=y) then begin a[k].s:=a[k].r-a[k].l+1;a[k].d:=1;exit;end;
   mid:=(a[k].l+a[k].r)>>1;i:=k+k;
   if x<=mid then change1(i,x,y);
   if mid<y then change1(i+1,x,y);
   a[k].s:=a[i].s+a[i+1].s;
end;
procedure install;
begin
   ans:=dep[x];
   while x<>-1 do begin ans:=ans-ask(1,idx[top[x]],idx[x]);change1(1,idx[top[x]],idx[x]);x:=father[top[x]]; end;
   writeln(ans);
end;
procedure uninstall;
begin
   writeln(ask(1,idx[x],idx[x]+siz[x]-1));
   change0(1,idx[x],idx[x]+siz[x]-1);
end;
begin
   //assign(input,'manager.in');assign(output,'manager.out');reset(input);rewrite(output);
   readln(n);
   fillchar(head,sizeof(head),0);cnt:=0;
   for i:=1 to n-1 do begin read(father[i]);add(father[i],i); end;
   prepare;
   build(1,1,n);
   readln(qq);
   for i:=1 to qq do
      begin
         readln(s);
         if s[1]='i' then begin delete(s,1,8);val(s,x);install; end
         else begin delete(s,1,10);val(s,x);uninstall; end;
      end;
   //close(input);close(output);
end.
```

---

## 作者：PI_AC (赞：0)

# 题目

[软件包管理器](https://www.luogu.org/problem/P2146)

# 题解

一道`树链剖分`的模板题

初始化所有点的权值为$0$

1.安装操作：将当前点到根节点的所有节点权值置为$1$

2.卸载操作：将以当前点为根的子树上的所有节点权值置为$0$

对于每次操作后的查询，我们只需要对操作后的安装数量和操作前的安装数量求一个差值即可

# 代码

```cpp
#include <vector>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

template <typename T>
T Max(T x, T y) {return x > y ? x : y;}

template <typename T>
T Min(T x, T y) {return x < y ? x : y;}

template <typename T>
T Fabs(T x) {return x < 0 ? -x : x;}

#define LL long long

#define lson x << 1
#define rson x << 1 | 1

const int N = 100005;

int n, x, q, cnt;
int s[N], f[N], d[N], id[N], rk[N], son[N], top[N];
char a[10];

struct TREE {
    int l, r, sum, lazy;
};
TREE tre[N << 2];

vector <int> G[N];

void build(int x, int l, int r) {
    if(l == r) {
        tre[x].l = l, tre[x].r = r, tre[x].lazy = -1;
        return ;
    }
    int mid = (l + r) >> 1;
    build(lson, l, mid);
    build(rson, mid + 1, r);
    tre[x].l = tre[lson].l, tre[x].r = tre[rson].r, tre[x].lazy = -1;
}

void putDown(int x) {
    tre[lson].sum = (tre[lson].r - tre[lson].l + 1) * tre[x].lazy;
    tre[rson].sum = (tre[rson].r - tre[rson].l + 1) * tre[x].lazy;
    tre[lson].lazy =  tre[rson].lazy = tre[x].lazy;
    tre[x].lazy = -1;
}

void update(int x, int l, int r, int y) {
    if(tre[x].r < l || tre[x].l > r) return ;
    if(tre[x].l >= l && tre[x].r <= r) {
        tre[x].lazy = y;
        tre[x].sum = (tre[x].r - tre[x].l + 1) * y;
        return ;
    }
    if(tre[x].lazy != -1) putDown(x);
    update(lson, l, r, y);
    update(rson, l, r, y);
    tre[x].sum = tre[lson].sum + tre[rson].sum;
}

void dfs1(int x, int fa) {
    int siz = G[x].size();
    for(int i = 0; i <= siz - 1; i ++) {
        if(G[x][i] == fa) continue;
        d[G[x][i]] = d[x] + 1;
        f[G[x][i]] = x;
        dfs1(G[x][i], x);
        s[x] += s[G[x][i]];
        if(s[G[x][i]] > s[son[x]]) son[x] = G[x][i];
    }
    s[x] ++;
}

void dfs2(int x, int fa, int _top) {
    int siz = G[x].size();
    top[x] = _top;
    id[x] = ++ cnt;
    rk[cnt] = x;
    if(son[x] == 0) return ;
    dfs2(son[x], x, _top);
    for(int i = 0; i <= siz - 1; i ++) {
        if(G[x][i] == fa || G[x][i] == son[x]) continue;
        dfs2(G[x][i], x, G[x][i]);
    }
}

void upEdge(int x, int y, int z) {
    while(top[x] != top[y]) {
        if(d[top[x]] > d[top[y]]) {
            update(1, id[top[x]], id[x], z);
            x = f[top[x]];
        }
        else {
            update(1, id[top[y]], id[y], z);
            y = f[top[y]];
        }
    }
    if(d[x] > d[y])
        update(1, id[y], id[x], z);
    else
        update(1, id[x], id[y], z);
}

int main() {
    scanf("%d", &n);
    for(int i = 2; i <= n; i ++) {
        scanf("%d", &x);
        G[x + 1].push_back(i);
        G[i].push_back(x + 1);
    }
    scanf("%d", &q);
    d[1] = 1;
    dfs1(1, -1);
    dfs2(1, -1, 1);
    build(1, 1, n);
    while(q --) {
        scanf("\n%s%d", a, &x);
        x ++;
        int last = tre[1].sum;
        if(a[0] == 'i')
            upEdge(1, x, 1);
        else
            update(1, id[x], id[x] + s[x] - 1, 0);
        printf("%d\n", Fabs(tre[1].sum - last));
    }
    return 0;
}
```

---

## 作者：傅思维666 (赞：0)

## 题解：

一道树链剖分的模板题。

关于树链剖分的讲解请戳这里：

[浅谈树链剖分](https://www.cnblogs.com/fusiwei/p/11519470.html)

这道题**难点有二**：

第一个是读题，我们必须在读题之后明白这是一棵树，并且知道：安装一个软件就相当于安装这个点到根节点的所有未被安装的软件。卸载一个软件就是卸载以这个软件为根节点的子树的所有软件。

第二个是线段树的操作：我们知道线段树是用于区间操作的一种数据结构，那么这道题的区间修改，在线段树的相关题型中，又有一个名字：**区间赋值**。针对于这种区间赋值的线段树的题目，我们需要注意建树和打lazy标记时的相关信息的维护。比如，建树的时候lazy标记要置成-1。（这个时候的lazy数组属于标记数组，你愿意的话只要不设置成1设置啥都行）pushdown的时候一定要判一下当前的lazy是否为-1！（如果是就不能下传，要不然会导致下传的两个子节点的lazy值错误）。

剩下的就随便敲敲模板就成了。

上代码：

```cpp
#include<cstdio>
#include<algorithm>
#define lson pos<<1
#define rson pos<<1|1
using namespace std;
const int maxn=1e5+1;
int n,q,tot,cnt;
int head[maxn],nxt[maxn<<1],to[maxn<<1];
int deep[maxn],fa[maxn],size[maxn],son[maxn];
int id[maxn],top[maxn];
int tree[maxn<<2],lazy[maxn<<2];
char s[100];
void add(int x,int y)
{
    to[++tot]=y;
    nxt[tot]=head[x];
    head[x]=tot;
}
void dfs1(int x,int f)
{
    deep[x]=deep[f]+1;
    fa[x]=f;
    size[x]=1;
    for(int i=head[x];i;i=nxt[i])
    {
        int y=to[i];
        if(y==f)
            continue;
        dfs1(y,x);
        size[x]+=size[y];
        if(!son[x]||size[y]>size[son[x]])
            son[x]=y;
    }
}
void dfs2(int x,int t)
{
    top[x]=t;
    id[x]=++cnt;
    if(!son[x])
        return;
    dfs2(son[x],t);
    for(int i=head[x];i;i=nxt[i])
    {
        int y=to[i];
        if(y==fa[x]||y==son[x])
            continue;
        dfs2(y,y);
    }
}
void build(int pos,int l,int r)
{
    lazy[pos]=-1;
    int mid=(l+r)>>1;
    if(l==r)
        return;
    build(lson,l,mid);
    build(rson,mid+1,r);
}
void mark(int pos,int l,int r,int k)
{
    tree[pos]=(r-l+1)*k;
    lazy[pos]=k;
}
void pushdown(int pos,int l,int r)
{
    int mid=(l+r)>>1;
    if(lazy[pos]==-1) return;  
    mark(lson,l,mid,lazy[pos]);
    mark(rson,mid+1,r,lazy[pos]);
    lazy[pos]=-1;
}
void update(int pos,int l,int r,int x,int y,int k)
{
    int mid=(l+r)>>1;
    if(x<=l && r<=y)
    {
        mark(pos,l,r,k);
        return;
    }
    pushdown(pos,l,r);
    if(x<=mid)
        update(lson,l,mid,x,y,k);
    if(y>mid)
        update(rson,mid+1,r,x,y,k);
    tree[pos]=tree[lson]+tree[rson];
}
void upd_chain(int x,int y,int k)
{
    while(top[x]!=top[y])
    {
        if(deep[top[x]]<deep[top[y]])
            swap(x,y);
        update(1,1,n,id[top[x]],id[x],k);
        x=fa[top[x]];
    }
    if(deep[x]<deep[y])
        swap(x,y);
    update(1,1,n,id[y],id[x],k);
}
void upd_subtree(int x,int k)
{
    update(1,1,n,id[x],id[x]+size[x]-1,k);
}
int main()
{
    scanf("%d",&n);
    for(int i=2;i<=n;i++)
    {
        int x;
        scanf("%d",&x);x++;
        add(x,i);
        add(i,x);
    }
    dfs1(1,0);
    dfs2(1,1);
    build(1,1,n);
    scanf("%d",&q);
    while(q--)
    {
        int x;
        int t=tree[1];
        scanf("%s",s+1);
        scanf("%d",&x);x++;
        if(s[1]=='i')
        {
            upd_chain(1,x,1);
            printf("%d\n",abs(t-tree[1]));
        }
        else
        {
            upd_subtree(x,0);
            printf("%d\n",abs(t-tree[1]));
        }
    }
    return 0;
}
```

---

## 作者：chihik (赞：0)


这其实是一道树链剖分的板题，难在读题...

借一下洛谷的图：（将边看成无向的）

![](https://cdn.luogu.com.cn/upload/pic/1504.png)

如果理解了题目，我们会发现：

1.安装一个软件$u$需要将$u$号软件到$0$号软件的路径上所有未安装的软件安装。

2.删除一个软件$u$需要将以$u$为根的子树上所有安装的软件删除。

其实它们分别是路径修改和子树修改，树链剖分后线段树维护区间安装的软件个数就好了。

```cpp
#include <cstdio>
#include <vector>
#include <iostream>
using namespace std;
#define ls x << 1
#define rs x << 1 | 1
#define INF 0x3f3f3f3f

const int MAXN = 100000;
int n , q , cnt;
int Fa[ MAXN + 5 ] , Size[ MAXN + 5 ] , Depth[ MAXN + 5 ] , Heaviest_son[ MAXN + 5 ];
int Dfn[ MAXN + 5 ] , Top[ MAXN + 5 ] , Rank[ MAXN + 5 ];
vector< int > Graph[ MAXN + 5 ];

struct Point{
	int l , r , num , Lazy;
};
struct Segment_Tree{
	Point Tree[ 4 * MAXN + 5 ];
	void Build( int x , int l , int r ) {
		Tree[ x ].l = l , Tree[ x ].r = r , Tree[ x ].Lazy = -1 , Tree[ x ].num = 0;
		if( l == r )
			return;
		int Mid = ( l + r ) / 2;
		Build( ls , l , Mid );
		Build( rs , Mid + 1 , r );
	}
	void Pushdown( int x ) {
		if( Tree[ x ].Lazy == 0 ) {
			Tree[ ls ].num = Tree[ rs ].num = 0;
			Tree[ ls ].Lazy = Tree[ rs ].Lazy = 0;
			Tree[ x ].Lazy = -1;
		}
		if( Tree[ x ].Lazy == 1 ) {
			Tree[ ls ].num = ( Tree[ ls ].r - Tree[ ls ].l + 1 );
			Tree[ rs ].num = ( Tree[ rs ].r - Tree[ rs ].l + 1 );
			Tree[ ls ].Lazy = Tree[ rs ].Lazy = 1;
			Tree[ x ].Lazy = -1;
		}
	}
	void Insert( int x , int l , int r , int k ) {
		if( r < Tree[ x ].l || Tree[ x ].r < l ) 
			return;
		if( l <= Tree[ x ].l && Tree[ x ].r <= r ) {
			Tree[ x ].num = k ? ( Tree[ x ].r - Tree[ x ].l + 1 ) : 0;
			Tree[ x ].Lazy = k; 
			return;
		}
		Pushdown( x );
		Insert( ls , l , r , k );
		Insert( rs , l , r , k );
		Tree[ x ].num = ( Tree[ ls ].num + Tree[ rs ].num );
	}
	int Find( int x , int l , int r ) {
		if( r < Tree[ x ].l || Tree[ x ].r < l ) 
			return 0;
		if( l <= Tree[ x ].l && Tree[ x ].r <= r )
			return Tree[ x ].num;
		Pushdown( x );
		return Find( ls , l , r ) + Find( rs , l , r );
	}
	
	int Query_ins( int u , int v ) {
		int Ans = 0;
		while( Top[ u ] != Top[ v ] ) {
			if( Depth[ Top[ u ] ] < Depth[ Top[ v ] ] )
				swap( u , v );
			Ans += ( Depth[ u ] - Depth[ Top[ u ] ] + 1 ) - Find( 1 , Dfn[ Top[ u ] ] , Dfn[ u ] );
			Insert( 1 , Dfn[ Top[ u ] ] , Dfn[ u ] , 1 );
			
			u = Fa[ Top[ u ] ];
		}
		if( Depth[ u ] > Depth[ v ] )
			swap( u , v );
		Ans += ( Depth[ v ] - Depth[ u ] + 1 ) - Find( 1 , Dfn[ u ] , Dfn[ v ] );
		Insert( 1 , Dfn[ u ] , Dfn[ v ] , 1 );
		return Ans;
	}
	int Query_uni( int u ) {
		int Ans = Find( 1 , Dfn[ u ] , Dfn[ u ] + Size[ u ] - 1 );
		Insert( 1 , Dfn[ u ] , Dfn[ u ] + Size[ u ] - 1 , 0 );
		return Ans;
	}
}Tree;

void dfs1( int u , int fa ) {
	Fa[ u ] = fa , Depth[ u ] = Depth[ fa ] + 1 , Size[ u ] = 1;
	
	for( int i = 0 ; i < Graph[ u ].size( ) ; i ++ ) {
		int v = Graph[ u ][ i ];
		if( v == fa ) continue;
		dfs1( v , u );
		Size[ u ] += Size[ v ];
		if( Size[ Heaviest_son[ u ] ] < Size[ v ] )
			Heaviest_son[ u ] = v;
	}
}
void dfs2( int u , int top ) {
	Top[ u ] = top , Dfn[ u ] = ++ cnt , Rank[ cnt ] = u;
	
	if( !Heaviest_son[ u ] ) return;
	dfs2( Heaviest_son[ u ] , top );
	for( int i = 0 ; i < Graph[ u ].size( ) ; i ++ ) {
		int v = Graph[ u ][ i ];
		if( !Dfn[ v ] ) dfs2( v , v );
	}
}

int u , v;
char op[ 20 ];
int main( ) {
	scanf("%d",&n);
	for( int i = 2 ; i <= n ; i ++ ) {
		scanf("%d",&v);v ++;
		Graph[ i ].push_back( v );
		Graph[ v ].push_back( i );
	}
	dfs1( 1 , 0 );
	dfs2( 1 , 1 );
	
	Tree.Build( 1 , 1 , n );
	scanf("%d",&q);
	for( int i = 1 ; i <= q ; i ++ ) {
		scanf("%s %d",op,&u);u ++;
		if( op[ 0 ] == 'i' )
			printf("%d\n", Tree.Query_ins( 1 , u ) );
		if( op[ 0 ] == 'u' )
			printf("%d\n", Tree.Query_uni( u ) );
	}
	return 0;
}
```


---

## 作者：Komes (赞：0)

# 究极树剖 毁我青春之旅行


------------
看到题目，我们可以想到按照信仰来建树，每一个信仰建一棵树，当然肯定不能简简单单的建树。这里我们要用到**主席树**的概念，PS：这里不会主席树的同学可以问下度娘。
但是为什么说它是伪主席树呢？这是因为主席树每次操作都会给当前操作过后建一个新树，而这里不一样，比如我们将x城市的居民的信仰改为y，**我们只需要在x城市原来所在的树内，减去它的评级w**，然后在信仰y这棵树内，将x城市添加进去即可。
所以这个很容易跟主席树混淆！！！！！！

------------
剩下的查询就很简单啦，直接用lca的方式进行查询就OK了。
下面贴代码（因为学校oj的问题我把DFS写成了非递归的形式，如果你用递归的DFS在洛谷是可以过的！！！)



------------
```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <stack>
#define N 200005
using namespace std;
 
int n,m,w[N],c[N],head[N];
struct edge
{
	int y,next;
}s[N];

int root[N],fa[N],seg[N],rev[N],dep[N],size[N],son[N],top[N],vis[N],sk[N];
int mmax[N * 10],ls[N * 10],rs[N * 10],sum[N * 10];
int tx,ty,ans,op,x,y,d,v,len = 0,cnt;

void ins(int x,int y)
{
	len++;
	s[len].y = y; s[len].next = head[x]; head[x] = len;
}
 
int read()
{
	char c; int res,f = 1;
	while ((c = getchar()) > '9' || c < '0') if (c == '-') f = -1;
	res = c - 48;
	while ((c = getchar()) >= '0' && c <= '9') res = res * 10 + c - 48;
	return res * f;
}

void BFS()
{
	stack <int> f;
	f.push(1); vis[1] = 1; dep[1] = 1; fa[1] = 0;
	for (int i = 1; i <= n; i++) size[i] = 1;
	while (!f.empty())
	{
		int x = f.top(); sk[++cnt] = x; f.pop();
		for(int i = head[x]; i != 0; i = s[i].next)
		{
			int y = s[i].y;
			if (!vis[y])
			{
				dep[y] = dep[x] + 1;
				vis[y] = 1;
				fa[y] = x;
				f.push(y);
			}
		}
	}
	
	while (cnt)
	{
		int x = sk[cnt]; cnt--;
		for(int i = head[x]; i != 0; i = s[i].next)
		if (fa[x] != s[i].y)
		{
			size[x] += size[s[i].y];
			if (size[son[x]] < size[s[i].y]) son[x] = s[i].y;
		}
	}
}

void bfs()
{
	stack <int> q,f;
	q.push(1); f.push(1);
	while(!q.empty())
	{
		int x = q.top(),y = f.top(); f.pop(); q.pop();
		seg[x] = ++seg[0]; top[x] = y;
	
		for(int i = head[x]; i != 0; i = s[i].next)
			if (!top[s[i].y] && son[x] != s[i].y)
				q.push(s[i].y),f.push(s[i].y);
		
		if (son[x])
			q.push(son[x]),f.push(y);
	}
}

void change(int &now,int l,int r)
{
	if(!now) now = ++len;
	sum[now] += d;
	if(l==r) 
	{
		if(d > 0) mmax[now] = d;
		else mmax[now] = 0;
		return ;
	}
	int mid = l + r >> 1;
	if(v <= mid) change(ls[now],l,mid);
	else change(rs[now],mid + 1,r);
	mmax[now] = max(mmax[ls[now]],mmax[rs[now]]);
}
 
void change_c()
{
	x = read(); y = read();
	v = seg[x]; d = -w[x];
	change(root[c[x]],1,n);
	c[x] = y; d = w[x];
	change(root[c[x]],1,n);
}
 
void change_w()
{
	x = read(); y = read();
	v = seg[x]; d = -w[x];
	change(root[c[x]],1,n);
	w[x] = y; d = w[x];
	change(root[c[x]],1,n);
}
 
int query_sum(int now,int l,int r,int x,int y)
{
	if(x == l && y == r) return sum[now];
	int mid = x + y >> 1;
	if(r <= mid) return query_sum(ls[now],l,r,x,mid);
	else if(mid < l) return query_sum(rs[now],l,r,mid + 1,y);
	else return query_sum(ls[now],l,mid,x,mid)+query_sum(rs[now],mid + 1,r,mid + 1,y);
}
 
int lca_sum()
{
	x = read(); y = read();
	op = x;
	tx = top[x]; ty = top[y];
	ans = 0;
	while(tx != ty)
	{
		if(dep[tx] > dep[ty])
		{
			swap(x,y);swap(tx,ty);
		}
		ans += query_sum(root[c[op]],seg[ty],seg[y],1,n);
		y = fa[ty]; ty = top[y];
	}
	if(dep[x] > dep[y]) swap(x,y);
	ans += query_sum(root[c[op]],seg[x],seg[y],1,n);
	return ans;
}
 
int query_max(int now,int l,int r,int x,int y)
{
	if(x == l && y == r) return mmax[now];
	int mid = x + y >> 1;
	if(r <= mid) return query_max(ls[now],l,r,x,mid);
	if(mid < l) return query_max(rs[now],l,r,mid + 1,y);
	return max(query_max(ls[now],l,mid,x,mid),query_max(rs[now],mid + 1,r,mid + 1,y));
}
 
int lca_max()
{
	x = read(); y = read();
	op = x;
	tx = top[x]; ty = top[y];
	ans = 0;
	while(tx != ty)
	{
		if(dep[tx] > dep[ty])
		{
			swap(x,y);swap(tx,ty);
		}
		ans = max(ans,query_max(root[c[op]],seg[ty],seg[y],1,n));
		y = fa[ty]; ty = top[y];
	}
	if(dep[x] > dep[y]) swap(x,y);
	ans = max(ans,query_max(root[c[op]],seg[x],seg[y],1,n));
	return ans;
}
 
int main()
{
	n = read(); m = read();
	for(int i = 1; i <= n; i++) w[i] = read(),c[i] = read();
	for(int i = 1; i <= n - 1; i++)
	{
		x = read(); y = read();
		ins(x,y);
		ins(y,x);
	}
	BFS();
	len = 0;
	bfs();
	len = 0;
	for(int i = 1; i <= n; i++)
	{
		v = seg[i]; d = w[i];
		change(root[c[i]],1,n);
	}
	char ch[10];
	while(m--)
	{
		scanf("%s",ch);
		if(ch[1] == 'C') change_c();
		else if(ch[1] == 'W') change_w();
		else if(ch[1] == 'S') printf("%d\n",lca_sum());
		else if(ch[1] == 'M') printf("%d\n",lca_max());
	}
	return 0;
}
```


---

## 作者：Minakami_Yuki (赞：0)

[更好的阅读体验](https://zgjjj.github.io/2019/07/17/Luogu-P2146-NOI2015-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/)


![](https://i.loli.net/2019/07/17/5d2f025c5513d85813.png)

这是$\color{black} \mathbf {w} \color{red} \mathbf {jyyy} $嗦的$\uparrow$



# 题目链接

[**P2146** [NOI2015]软件包管理器](https://www.luogu.org/problemnew/show/P2146) 

# 题意简述

给你一棵树，有点权。将点权赋值为1需要将根到该点路径上所有点赋值为，将点权赋值为0会使以该点为根的子树上的所有点点权变为0。初始时所有点点权为0，给你m个赋值操作，输出每个操作会改变多少个点的状态。

# 解题思想

发现树的形态没有改变，我们考虑树剖。然后求出根到某个点的链的长度和某个点的子树大小，线段树维护即可。

但是我们发现这里面是区间赋值操作，而不是区间增加操作，如果单个点做效率极低，我们考虑一种新的线段树：

## 区间覆盖线段树

我们考虑在区间增线段树的基础上将**增加**改成**赋值**。

于是我们将`tag[]`维护的信息由增量改为赋值数，发现根据时间的先后，这个信息会被逐步**替代**，于是就可以在下放的时候**直接用父节点标记盖住子节点标记**，即把`+=`改为`=`。这样就可以**整个区间**赋值为**同一个数**。

注意一下题目中有赋值为`0`的操作，所以`tag[]`的初值**不能**为0，否则就会出锅。（卡了我一下午

# 参考代码

```cpp
#include <cstdio>
#include <cctype>
#include <cstring>

namespace FastIO {
    inline int read() {
        char ch = getchar(); int r = 0, w = 1;
        while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();}
        while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();}
        return r * w;
    }
    void _write(int x) {
        if(x < 0) putchar('-'), x = -x;
        if(x > 9) _write(x / 10);
        putchar(x % 10 + '0');
    }
    inline void write(int x) {
        _write(x);
        puts("");
    }
}

using namespace FastIO;

const int N = 100010;
const int M = N << 1;

template <typename T> inline void swap(T &x, T &y) {T tmp = x; x = y, y = tmp;}
template <typename T> inline T min(T a, T b) {return a < b ? a : b;}
template <typename T> inline T max(T a, T b) {return a > b ? a : b;}

int n, q, w[N];
int head[N], nxt[M], ver[M], cnt, idx;
int d[N], sz[N], fa[N], tp[N], son[N];
int dfn[N], ptn[N];
int val[N << 2], tag[N << 2];

#define ls (o << 1)
#define rs (o << 1 | 1)
#define mid ((l + r) >> 1)

inline void upd(int o) {
    val[o] = val[ls] + val[rs];
}

inline void pushdown(int o, int l, int r) {
    if(tag[o] != -1) {
        tag[ls] = tag[o];
        tag[rs] = tag[o];
        val[ls] = tag[o] * (mid - l + 1);
        val[rs] = tag[o] * (r - mid);
    }
    tag[o] = -1;
}

void build(int o, int l, int r) {
    if(l == r) {val[o] = w[ptn[l]]; return;}
    build(ls, l, mid);
    build(rs, mid + 1, r);
    upd(o);
}

void modify(int o, int l, int r, int ll, int rr, int k) {
    if(l >= ll && r <= rr) {
        val[o] = k * (r - l + 1);
        tag[o] = k;
        return;
    }
    pushdown(o, l, r);
    if(ll <= mid) modify(ls, l, mid, ll, rr, k);
    if(rr > mid) modify(rs, mid + 1, r, ll, rr, k);
    upd(o);
}

int query(int o, int l, int r, int ll, int rr) {
    if(l >= ll && r <= rr) return val[o];
    pushdown(o, l, r);
    int res = 0;
    if(ll <= mid) res += query(ls, l, mid, ll, rr);
    if(rr > mid) res += query(rs, mid + 1, r, ll, rr);
    return res;
}

void add(int x, int y) {
    ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt;
    ver[++cnt] = x, nxt[cnt] = head[y], head[y] = cnt;
}

void dfs1(int x) {
    sz[x] = 1;
    for(register int i = head[x]; i; i = nxt[i]) {
        int y = ver[i];
        if(y == fa[x]) continue;
        fa[y] = x;
        d[y] = d[x] + 1;
        dfs1(y);
        sz[x] += sz[y];
        if(sz[y] > sz[son[x]]) son[x] = y;
    }
}

void dfs2(int x, int top) {
    tp[x] = top;
    dfn[x] = ++idx;
    ptn[idx] = x;
    if(son[x]) dfs2(son[x], top);
    for(register int i = head[x]; i; i = nxt[i]) {
        int y = ver[i];
        if(y == fa[x] || y == son[x]) continue;
        dfs2(y, y);
    }
}

inline void changeline(int x, int y, int z) {
    while(tp[x] != tp[y]) {
        if(d[tp[x]] > d[tp[y]]) swap(x, y);
        modify(1, 1, n, dfn[tp[y]], dfn[y], z);
        y = fa[tp[y]];
    }
    if(d[x] > d[y]) swap(x, y);
    modify(1, 1, n, dfn[x], dfn[y], z);
}

inline int queryline(int x, int y) {
    int res = 0;
    while(tp[x] != tp[y]) {
        if(d[tp[x]] > d[tp[y]]) swap(x, y);
        res += query(1, 1, n, dfn[tp[y]], dfn[y]);
        y = fa[tp[y]];
    }
    if(d[x] > d[y]) swap(x, y);
    res += query(1, 1, n, dfn[x], dfn[y]);
    return res;
}

inline void changetree(int x, int z) {
    modify(1, 1, n, dfn[x], dfn[x] + sz[x] - 1, z);
}

inline int querytree(int x) {
    return query(1, 1, n, dfn[x], dfn[x] + sz[x] - 1);
}

char s[10];

int main() {
    memset(tag, -1, sizeof(tag));
    n = read();
    for(register int i = 2; i <= n; i++) {
        add(read() + 1, i);
    }
    dfs1(1);
    dfs2(1, 1);
    build(1, 1, n);
    q = read();
    for(register int i = 1; i <= q; i++) {
        scanf("%s", s);
        register int x = read() + 1;
        int num = val[1];
        if(s[0] == 'i') {
            changeline(1, x, 1);
            write(val[1] - num);
        }
        else {
            changetree(x, 0);
            write(num - val[1]);
        }
    }
    return 0;
}
```



---

## 作者：Sangber (赞：0)

### 题目描述  
题面比较啰唆，我先把大体意思讲一下:  

首先，有编号从$0$到$N-1$的$N$个节点，根节点一定是$0$号节点(无前驱)  
(我把下标都加上了一，转化为以$1$为起始下标的点集，那么根节点编号为$1$，注意一下)  
输入会给定根节点以外的节点的前驱，即父节点编号。  

还有$M$次操作：  

+  $install:$ 根据题意也就是**将给定的节点$x$到根的路径上的每一个节点的权值赋值为$1$**
+  $uninstall:$ 根据题意也就是**将以给定的节点$x$为根的子树的每一个节点的权值赋值为$0$**  

看到这里就很显然，这是一道树链剖分的模板题。  

----

### 基本思路  (树链剖分+线段树)
既然是模板题，思路就很简单了，树剖之后加线段树维护即可。(不过还是有点坑点的...)

----

### 细节注意事项
接下来就是关于这道题的几个坑点。   
#### 坑点一：点下标出锅  
这里我之前也有提到，尤其是在输入时，下面我把两种输入方式的正确写法都说一下：  

以$0$为下标，这意味着你的输入是从下标$1$到$N-1$的，所以要这样写：  
```cpp
    for(rg int x,i=1;i<=n-1;i++) x=read();//这里主要只说下标处理，连边什么的见详细代码
```
以$1$为下标则是：
```cpp
    for(rg int x,i=2;i<=n;i++) x=read();
```
这里我有一点检验方法，还是比较实用的，毕竟下标的处理是很基本而又重要的：  

1.  试着通过你的for循环算一下你的循环次数
1.  确保你的循环变量$i$(或其他变量名)的循环起点  

这样的话有可以适当避免下标出锅问题(我就是因为下标问题卡了十多分钟，泪的教训啊$qwq$)  

#### 坑点二：线段树修改子节点信息(标记下传)出锅  
在此篇题解的开始我便用粗体强调了，这里再说一次：  
**每次操作是在赋值，也就是覆盖之前的信息(这也正是选择线段树来维护而不是分块等数据结构的理由)**  
具体代码实现可以看一下我写的：  
```cpp
    inline void f(int rt,int l,int r,int v){
    //rt为当前接受信息的线段树节点编号
    //l为该节点包含区间的左端点，r为右端点
    //v为父节点的lazy tag值
        tag[rt]=v,sum[rt]=v*(r-l+1);//该题正确写法
        /*tag[rt]+=v,sum[rt]+=v*(r-l+1)*/
        //一般写法，区别就在于+=和=，小小的=就帮我们实现了覆盖操作
    }
    inline void pushdown(int rt,int l,int r,int mid){
    	//由于涉及到赋为0的操作，所以我用了-1表示lazy tag为空的状态
    	if(tag[rt]!=-1){
            f(lc(rt),l,mid,tag[rt);
            f(rc(rt),mid+1,r,tag[rt]);
            tag[rt]=-1;
        }
    }
```
#### 坑点三：输出出锅  
其实这一点还是比较好处理的，不过我第一次还是没有直接写对(还是涉及到读题的问题)  
题目是这样说的：  
>
输出文件的第$i$行输出$1$个整数，为第$i$步操作中**改变安装状态**的软件包数。  

也就是说我们每次输出的是变化量而并非操作后的总数，具体实现的话只需要在每次操作前事先记录一下总量$t_1$，再记录一下每次操作完后的新的总量$t_2$，输出$\vert t_1-t_2 \vert$即可(注意换行...)  

#### 参考代码
下面贴上蒟蒻的代码。。。  
```cpp
#include<cstdio>
#include<algorithm>
#define rg register
const int MAXN=100010;
using namespace std;
inline int read(){
    int s=0;bool f=false;char c=getchar();
    while(c<'0'||c>'9')f|=(c=='-'),c=getchar();
    while(c>='0'&&c<='9')s=(s<<3)+(s<<1)+(c^48),c=getchar();
    return (f)?(-s):(s);
}
int n,m;
int tot,head[MAXN],nxt[MAXN],ver[MAXN];
inline void Add_edge(int u,int v){
    nxt[++tot]=head[u],head[u]=tot,ver[tot]=v;
}
int sum[MAXN<<2],tag[MAXN<<2];
inline int lc(int rt){return rt<<1;}
inline int rc(int rt){return rt<<1|1;}
inline void pushup(int rt){
    sum[rt]=sum[lc(rt)]+sum[rc(rt)];
}
inline void f(int rt,int l,int r,int v){
    tag[rt]=v,sum[rt]=v*(r-l+1);
}
inline void pushdown(int rt,int l,int r,int mid){
    if(tag[rt]!=-1){
        f(lc(rt),l,mid,tag[rt]);
        f(rc(rt),mid+1,r,tag[rt]);
        tag[rt]=-1;
    }
}
inline void update(int rt,int l,int r,int x,int y,int v){
    if(l>y||r<x) return;
    if(x<=l&&r<=y) return f(rt,l,r,v);
    int mid=(l+r)>>1;
    pushdown(rt,l,r,mid);
    update(lc(rt),l,mid,x,y,v);
    update(rc(rt),mid+1,r,x,y,v);
    pushup(rt);
}
inline int query(int rt,int l,int r,int x,int y){
    if(l>y||r<x) return 0;
    if(x<=l&&r<=y) return sum[rt];
    int mid=(l+r)>>1;
    pushdown(rt,l,r,mid);
    return query(lc(rt),l,mid,x,y)+query(rc(rt),mid+1,r,x,y);
}
int top[MAXN],seg[MAXN];
int dep[MAXN],siz[MAXN],son[MAXN],father[MAXN];
inline void dfs1(int u,int fa){
    siz[u]=1;
    father[u]=fa;
    dep[u]=dep[fa]+1;
    for(rg int v,i=head[u];i;i=nxt[i])
        if(!dep[v=ver[i]]){
            dfs1(v,u),siz[u]+=siz[v];
            if(siz[v]>siz[son[u]]) son[u]=v;
        }
}
inline void dfs2(int u,int topf){
    top[u]=topf;
    seg[u]=++seg[0];
    if(!son[u]) return;
    dfs2(son[u],topf);
    for(rg int v,i=head[u];i;i=nxt[i])
        if(!top[v=ver[i]]) dfs2(v,v);
}
inline void uptRange(int x,int y,int v){
    int fx=top[x],fy=top[y];
    while(fx!=fy){
        if(dep[fx]>dep[fy]){
            update(1,1,n,seg[fx],seg[x],v);
            x=father[fx],fx=top[x];
        }
        else{
            update(1,1,n,seg[fy],seg[y],v);
            y=father[fy],fy=top[y];
        }
    }
    if(dep[x]<dep[y])
        update(1,1,n,seg[x],seg[y],v);
    else
        update(1,1,n,seg[y],seg[x],v);
}
inline void uptSon(int x,int v){
    update(1,1,n,seg[x],seg[x]+siz[x]-1,v);
}
int main(){
    n=read();
    for(rg int fa,i=2;i<=n;i++)
        fa=read()+1,Add_edge(fa,i);
    fill(sum+1,sum+n+1,0);
    fill(tag+1,tag+n+1,-1);
    //fill 这个函数是algorithm库里的一个函数，用法与sort类似，用于实现数组的初始化
    //之所以没写memset是因为一开始以为不能用memset初始化负数，不过好像可以？
    dfs1(1,0);
    dfs2(1,1);
    m=read();
    char s[20];
    for(rg int i=1;i<=m;i++){
        scanf("%s",s);
        int x=read()+1;
        int t1=sum[1];
        if(s[0]=='i'){
            uptRange(x,1,1);
            printf("%d\n",abs(t1-sum[1]));
        }
        else{
            uptSon(x,0);
            printf("%d\n",abs(t1-sum[1]));
        }
    }
    return 0;
}
```
完结撒花$qwq$

---

## 作者：风随逐影 (赞：0)

# 树链剖分
可以算作树剖的模版题，代码很好打，但坑点有二

1. 最好从一开始标号，从0开始会有一些不便（bug）
1. 不要用0表示懒标记不存在，如果懒标记为0我们还是要下传的，懒标记的初值要为-1


------------

```c
//遇到这种题最好从1开始标号比较方便 
#include<bits/stdc++.h>
using namespace std;
#define go(i,a,b) for(int i=(a);i<=(b);++(i))
#define com(i,a,b) for(int i=(a);i>=(b);--(i))
#define mem(a,b) memset((a),(b),sizeof(a))
#define inf 0x3f3f3f3f
#define fin freopen("input.txt","r",stdin)
#define fout freopen("output.txt","w",stdout)
#define lson rt<<1
#define rson rt<<1|1
const int maxn=100005;
vector<int>g[maxn];
char s[15];
typedef int aray[maxn];
aray dep,son,siz,f,dfn,top;
int cnt=0;
struct tree{
	int sum,laz,l,r;
}t[maxn<<2];
//-1表示不存在懒标记，0表示存在删除标记，1表示存在安装标记 

void read(int &x){
    int f=1;char s=getchar();x=0;
    while(!isdigit(s)){
    	if(s=='-') f=-1;s=getchar();
    }
    while(isdigit(s)){
   		x=(x<<3)+(x<<1)+s-'0';s=getchar();
    }
    x*=f;
}//读入优化

void dfs(int u,int fa){
	dep[u]=dep[fa]+1,f[u]=fa,siz[u]=1;
	int n=g[u].size()-1;
	go(i,0,n){
		int v=g[u][i];
		if(v==fa) continue;
		dfs(v,u);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]]) son[u]=v;
		//因为son的初值为0，所以size是有初值的，坑了我好久 
	}
}

void dfs2(int u,int t){
	dfn[u]=++cnt;top[u]=t;
	if(!son[u]) return;
	dfs2(son[u],t);
	int n=g[u].size()-1;
	go(i,0,n){
		int v=g[u][i];
		if(v==f[u]||v==son[u]) continue;
		dfs2(v,v);
	}
}

void pushdown(int rt){
	if(t[rt].laz+1){
	t[lson].laz=t[rson].laz=t[rt].laz;
	t[lson].sum=(t[lson].r-t[lson].l+1)*t[rt].laz;
	t[rson].sum=(t[rson].r-t[rson].l+1)*t[rt].laz;
	t[rt].laz=-1;
	}
}

void pushup(int rt){
	t[rt].sum=t[lson].sum+t[rson].sum;
}

void update(int rt,int x,int y,int val){
	if(t[rt].l>=x&&t[rt].r<=y){
		t[rt].sum=(t[rt].r-t[rt].l+1)*val;
		t[rt].laz=val;
		return;
	}
	pushdown(rt);
	int mid=(t[rt].l+t[rt].r)>>1;
	if(x<=mid) update(lson,x,y,val);
	if(y>mid) update(rson,x,y,val);
	pushup(rt);
}

void add(int x,int val){
	if(val){
	while(top[x]!=top[1]){
		update(1,dfn[top[x]],dfn[x],val);
		x=f[top[x]];
	}
	update(1,dfn[1],dfn[x],val);
	}
	else{
		update(1,dfn[x],dfn[x]+siz[x]-1,val);
	}
}

void build(int rt,int l,int r){
	t[rt]=(tree){0,-1,l,r};
	if(l==r) return;
	int mid=(t[rt].l+t[rt].r)>>1;
	build(lson,l,mid);
	build(rson,mid+1,r);
}

int main()
{
    //fin;fout;
    int n;read(n);
    int u;
    go(i,2,n){
    	read(u);u++;
		g[u].push_back(i);g[i].push_back(u);
	}
	dfs(1,0);dfs2(1,1);	
	build(1,1,cnt);
	int q;
	read(q);int x;
	int ans;
	go(i,1,q){
		scanf("%s",s);read(x);x++;
		ans=t[1].sum;
		if(s[0]=='i'){
			add(x,1);
			printf("%d\n",abs(ans-t[1].sum));
		}
		else if(s[0]=='u'){
			add(x,0);
			printf("%d\n",abs(ans-t[1].sum));
		}
	}
    return 0;
}
```


---

## 作者：Uniecho1 (赞：0)

这个题呢其实就是一个**裸的树剖**，只是线段树的操作有那么一点点不同而已

如果没有被卡读题，你就会发现：

1、安装一个软件包是指把根到该软件包结点全部刷成1（当然懒标记是要用的）

2、卸载一个软件包是指把以这个软件包结点为根的子树全部刷成0（懒标记接着）

但是还没完，因为有一些重要的事要说——因为是刷标记，**所以不是简单的求和**；同时**懒标记无论是0还是1都是有意义的**所以要选另一个基准（比如我用的极大值）来表示懒标记没有意义

好了就这么多，相信大佬们注意一下细节便能光速AK

```cpp
#include<bits/stdc++.h>
#define indx seg[0]
using namespace std;

int n,q;
int head[200005],siz;
int dep[100005],fa[100005],top[100005],size[100005],son[100005],seg[100005],pos[100005];
int sum[100005<<2],lazy[100005<<2];
struct node{
	int nxt,to;
}edge[200005];

void adde(int from,int to){
	siz++;
	edge[siz].nxt=head[from];
	edge[siz].to=to;
	head[from]=siz;
}

void prepare(int cur,int pa){
	dep[cur]=dep[pa]+1;fa[cur]=pa;size[cur]=1;
	for(int i=head[cur];i;i=edge[i].nxt){
		int v=edge[i].to;if(v==pa)continue;
		prepare(v,cur);size[cur]+=size[v];
		if(size[v]>size[son[cur]])son[cur]=v;
	}
}

void has(int cur,int pa){
	if(son[pa]==cur)top[cur]=top[pa];
	else top[cur]=cur;seg[cur]=++indx;
	pos[indx]=cur;if(son[cur])has(son[cur],cur);
	for(int i=head[cur];i;i=edge[i].nxt){
		int v=edge[i].to;if(v==pa||v==son[cur])continue;
		has(v,cur);
	}
}

void push(int l,int r,int id){
	int m=(l+r)>>1;
	lazy[id<<1]=lazy[id<<1|1]=lazy[id];
	sum[id<<1]=(m-l+1)*lazy[id];sum[id<<1|1]=(r-m)*lazy[id];
	lazy[id]=INT_MAX;
}

int getsum(int x,int y,int l,int r,int id){
	if(x<=l&&r<=y)return sum[id];
	if(lazy[id]==1||lazy[id]==0)push(l,r,id);
	int m=(l+r)>>1,ans=0;
	if(x<=m)ans+=getsum(x,y,l,m,id<<1);
	if(y>m)ans+=getsum(x,y,m+1,r,id<<1|1);
	return ans;
}

int query(int u,int v){
	int ans=0;
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])swap(u,v);
		ans+=getsum(seg[top[u]],seg[u],1,indx,1);
		u=fa[top[u]];
	}
    if(dep[u]<dep[v])swap(u,v);
	return ans+getsum(seg[v],seg[u],1,indx,1);
}

void adde(int x,int y,int l,int r,int id,int k){
	if(x<=l&&r<=y){
		lazy[id]=k;
		sum[id]=(r-l+1)*k;
		return;
	}
	int m=(l+r)>>1;
	if(lazy[id]==1||lazy[id]==0)push(l,r,id);
	if(x<=m)adde(x,y,l,m,id<<1,k);
	if(y>m)adde(x,y,m+1,r,id<<1|1,k);
	sum[id]=sum[id<<1]+sum[id<<1|1];
}

void change(int u,int v,int k){
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])swap(u,v);
		adde(seg[top[u]],seg[u],1,indx,1,k);
		u=fa[top[u]];
	}
    if(dep[u]<dep[v])swap(u,v);
	adde(seg[v],seg[u],1,indx,1,k);
}

int main(){
	//freopen("in.txt","r",stdin);
	memset(lazy,0x7f,sizeof(lazy));
	scanf("%d",&n);
	for(int i=2,x;i<=n;i++){//手动改编号 
		scanf("%d",&x);
		adde(i,x+1);
		adde(x+1,i);
	}
	prepare(1,0);
	has(1,0);
	scanf("%d",&q);
	for(int i=1,x;i<=q;i++){
		char s[20];scanf("%s %d\n",s,&x);
		if(s[0]=='i'){
			int cur=query(1,x+1);
			change(1,x+1,1);
			printf("%d\n",query(1,x+1)-cur);
		}
		else{
			printf("%d\n",getsum(seg[x+1],seg[x+1]+size[x+1]-1,1,indx,1));
			adde(seg[x+1],seg[x+1]+size[x+1]-1,1,indx,1,0);
		}
	}
	return 0;
}
```


---

## 作者：renhr2002 (赞：0)

这道题中，如果把依赖关系建成一棵树，就会发现：

1. 对于安装操作，相当于把x到根路径上的所有点覆盖为1；

2. 对于卸载操作，相当于把x的子树中所有点覆盖为0；

3. 并且，因为题中直接给了各个点的父子关系，建树时直接建单向边即可，为了方便dfs，我选择从父亲到儿子建边。


发现这点之后，就让我来BeO一发吧.

既然同时用到路径修改和子树修改，可见这是树剖算法。

因为要用到区间修改，线段树中需要延迟标记。我的标记规则如下：

- la=0：无标记；

- la=1：区间覆盖为1；

- la=-1：区间覆盖为0

### 注意低级失误：

我的算法中，线段树区间是从0开始的，所以树剖得到的idx数组值也要从0开始（**我就因为这个WA掉了16个点**，之后对拍才知道：线段树区间越界了。这也印证了一点：调试代码的时间通常和所犯错误的愚蠢程度成正比）

AC代码：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define maxn 8192000
int n;
struct node //链星存边 
{
    int to;
    int nxt;
}nd[maxn];
int head[maxn],cnt;
int idx[maxn],fa[maxn],dep[maxn],siz[maxn],son[maxn],top[maxn],cut;
/*
树剖：
idx：重新编号后的点编号
fa：x的父亲
dep：x的深度（根的深度为0）
siz：x的子树大小
son：x的重儿子
top：x所在重链顶端点编号 
*/
struct point
{
    int val;
    int la;
}tr[4*maxn];
/*
线段树：
val：区间求和
la：区间覆盖标记 
*/
int q;
char str[32];
int x;
void init()
{
    memset(head,-1,sizeof(head));
    cnt=1;
    return;
}
void add(int x,int y)
{
    nd[cnt].to=y;
    nd[cnt].nxt=head[x];
    head[x]=cnt++;
    return;
}
int dfs1(int x,int rt)//树剖第一次dfs 
{
    fa[x]=rt;
    siz[x]=1;
    int mxs=-1;
    for(int i=head[x];i!=-1;i=nd[i].nxt)
    {
        int t=nd[i].to;
        dep[t]=dep[x]+1;
        siz[x]+=dfs1(t,x);
        if(siz[t]>mxs)
        {
            mxs=siz[t];
            son[x]=t;
        }
    }
    return siz[x];
}
void dfs2(int x,int tp)//树剖第二次dfs 
{
    idx[x]=cut++;
    top[x]=tp;
    if(son[x]==-1)
    {
        return;
    }
    dfs2(son[x],tp);
    for(int i=head[x];i!=-1;i=nd[i].nxt)
    {
        int t=nd[i].to;
        if(!idx[t])
        {
            dfs2(t,t);
        }
    }
    return;
}
void addt(int L,int R,int l,int r,int rt,int m)//区间覆盖为1 
{
    if(L<=l&&R>=r)
    {
        tr[rt].la=1;
        tr[rt].val=r-l+1;
        return;
    }else
    {
        int mid=(l+r)/2;
        if(tr[rt].la==1)
        {
            tr[rt<<1].la=1;
            tr[rt<<1|1].la=1;
            tr[rt<<1].val=(m-(m>>1));
            tr[rt<<1|1].val=(m>>1);
            tr[rt].la=0;
        }else if(tr[rt].la==-1)
        {
            tr[rt<<1].la=-1;
            tr[rt<<1|1].la=-1;
            tr[rt<<1].val=0;
            tr[rt<<1|1].val=0;
            tr[rt].la=0;
        }
        if(L<=mid)
        {
            addt(L,R,l,mid,rt<<1,m-(m>>1));
        }
        if(R>mid)
        {
            addt(L,R,mid+1,r,rt<<1|1,m>>1);
        }
        tr[rt].val=tr[rt<<1].val+tr[rt<<1|1].val;
    }
    return;
}
void del(int L,int R,int l,int r,int rt,int m)//区间覆盖为0 
{
    if(L<=l&&R>=r)
    {
        tr[rt].la=-1;
        tr[rt].val=0;
        return;
    }else
    {
        int mid=(l+r)/2;
        if(tr[rt].la==1)
        {
            tr[rt<<1].la=1;
            tr[rt<<1|1].la=1;
            tr[rt<<1].val=(m-(m>>1));
            tr[rt<<1|1].val=(m>>1);
            tr[rt].la=0;
        }else if(tr[rt].la==-1)
        {
            tr[rt<<1].la=-1;
            tr[rt<<1|1].la=-1;
            tr[rt<<1].val=0;
            tr[rt<<1|1].val=0;
            tr[rt].la=0;
        }
        if(L<=mid)
        {
            del(L,R,l,mid,rt<<1,m-(m>>1));
        }
        if(R>mid)
        {
            del(L,R,mid+1,r,rt<<1|1,m>>1);
        }
        tr[rt].val=tr[rt<<1].val+tr[rt<<1|1].val;
    }
    return;
}
void addc(int x,int y)//路径覆盖为1 
{
    while(top[x]!=top[y]&&x!=-1&&y!=-1)
    {
        if(dep[top[x]]<dep[top[y]])
        {
            swap(x,y);
        }
        addt(idx[top[x]],idx[x],0,n-1,1,n);
        x=fa[top[x]];
    }
    if(dep[x]>dep[y])
    {
        swap(x,y);
    }
    addt(idx[x],idx[y],0,n-1,1,n);
    return;
}
int main()
{
    init();
    memset(son,-1,sizeof(son));
    scanf("%d",&n);
    for(int i=1;i<n;i++)
    {
        int a;
        scanf("%d",&a);
        add(a,i);
    }
    dfs1(0,-1);
    dfs2(0,0);
    scanf("%d",&q);
    while(q--)
    {
        scanf("%s%d",str,&x);
        if(str[0]=='i')
        {
            int ans=tr[1].val;
            addc(0,x);
            printf("%d\n",tr[1].val-ans);
        }else
        {
            int ans=tr[1].val;
            del(idx[x],idx[x]+siz[x]-1,0,n-1,1,n);
            printf("%d\n",ans-tr[1].val);
        }
    }
    return 0;
}

```

---

## 作者：小强 (赞：0)

来发题解

水的不能在水了，简直就是树链剖分裸题

题目要求：写一个数据结构，支持查询当前节点到根节点的权值为0的点并把他们改成1，以及将当前节点的子树（包括当前节点）的权值改成0。

十分熟悉有没有，就是洛谷上的链剖板子题啊

传送：https://www.luogu.org/problem/show?pid=3384

剩下的就简单了吧，对于操作1，有一个简单的操作方法就是当前节点的deep+1-更改之前的当前节点到根节点权值为1的节点的个数，很容易就实现了吧。


---

## 作者：magolor (赞：0)

经典树剖，本人代码略长但显然工整一些。使用struct和define来使代码简化。相信大家都能看懂简单的变量名。

操作就是树剖用线段树维护，安装了就是1，未安装就是0。

install操作是将该点到根节点的路径全部置1，unstall操作是将该点子树全部置0。

由于剖分序本身是DFS序的一部分，所以子树也是连续的一部分，直接线段树区间操作。

操作前后查询一下求差，三次查询可能常数略大，但比较清楚简单。








    
    
    
        
    
        





    




```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 1000000
#define lc(x) (x<<1)
#define rc(x) ((x<<1)|1)
#define mx(x) t[x].mx
#define lz(x) t[x].lz
#define mid ((lef+rig)>>1)
struct Node
{
    int mx,lz;
};
struct Segment_Tree
{
    Node t[MAXN+5];
    int dat[MAXN+5];
    void Push(int cur)
    {
        mx(cur) = mx(lc(cur)) + mx(rc(cur));
        return;
    }
    void Lazy(int cur, int lef, int rig)
    {
        if(lz(cur))
        {
            mx(lc(cur)) = (lz(cur)-1)*(mid-lef+1);
            mx(rc(cur)) = (lz(cur)-1)*( rig-mid );
            lz(lc(cur)) = lz(cur);
            lz(rc(cur)) = lz(cur);
            lz(cur) = 0;
        }
        return;
    }
    void Build(int cur, int lef, int rig)
    {
        if(lef == rig)
        {
            mx(cur) = dat[lef], lz(cur) = 0;
            return;
        }
        Build(lc(cur),lef,mid);
        Build(rc(cur),mid+1,rig);
        Push(cur);
        return; 
    }
    int Query(int cur, int lef, int rig, int L, int R)
    {
        Lazy(cur,lef,rig);
        if(L == lef && R == rig)
            return mx(cur);
        if(R <= mid)
            return Query(lc(cur),lef,mid,L,R);
        if(L >  mid)
            return Query(rc(cur),mid+1,rig,L,R);
        return Query(lc(cur),lef,mid,L,mid)+Query(rc(cur),mid+1,rig,mid+1,R);
    }
    void Edit(int cur, int lef, int rig, int L, int R, int x)
    {
        Lazy(cur,lef,rig);
        if(L == lef && R == rig)
        {
            mx(cur) = x*(rig-lef+1);
            lz(cur) = x+1;
            return;
        }
        if(R <= mid)
            Edit(lc(cur),lef,mid,L,R,x);
        else if(L >  mid)
            Edit(rc(cur),mid+1,rig,L,R,x);
        else
            Edit(lc(cur),lef,mid,L,mid,x),Edit(rc(cur),mid+1,rig,mid+1,R,x);
        Push(cur);
        return;
    }
};
struct Edge
{
    int to,nex;
    Edge(){}
    Edge(int _to, int _nex):to(_to),nex(_nex){}
};
Edge e[MAXN+5];
int first[MAXN+5],tot;
void Add(int a, int b)
{
    e[tot] = Edge(b,first[a]);
    first[a] = tot++;
    return;
}
int pos[MAXN+5],dep[MAXN+5],fa[MAXN+5],top[MAXN+5],sz[MAXN+5],heavy[MAXN+5],bound[MAXN+5],n,m,dfn;
char s[20];
void DFS1(int p, int father)
{
    sz[p] = 1;
    for(int u = first[p]; u != -1; u = e[u].nex)
        if(e[u].to != father)
        {
            fa[e[u].to] = p, dep[e[u].to] = dep[p]+1, DFS1(e[u].to,p), sz[p] += sz[e[u].to];
            if(!heavy[p] || sz[e[u].to] > sz[heavy[p]])
                heavy[p] = e[u].to;
        }
    return;
}
void DFS2(int p)
{
    bound[p] = pos[p];
    if(heavy[p])
        pos[heavy[p]] = dfn++, top[heavy[p]] = top[p], DFS2(heavy[p]), bound[p] = max(bound[p],bound[heavy[p]]);
    for(int u = first[p]; u != -1; u = e[u].nex)
        if(e[u].to != heavy[p] && e[u].to != fa[p])
            pos[e[u].to] = dfn++, top[e[u].to] = e[u].to, DFS2(e[u].to), bound[p] = max(bound[p],bound[e[u].to]);
    return;
}
Segment_Tree T;
int Qroot(int p)
{
    int ans = 0;
    while(p)
        ans += T.Query(1,1,n,pos[top[p]],pos[p]), p = fa[top[p]];
    return ans;
}
void Eroot(int p)
{
    while(p)
        T.Edit(1,1,n,pos[top[p]],pos[p],1), p = fa[top[p]];
    return;
}
int main()
{
    scanf("%d",&n), memset(first,-1,sizeof(first));
    for(int i = 2, a; i <= n; i++)
        scanf("%d",&a), Add(a+1,i);
    fa[1] = 0, dep[1] = 1, top[1] = 1, pos[1] = 1, dfn = 2, DFS1(1,0), DFS2(1), T.Build(1,1,n);
    scanf("%d",&m);
    for(int i = 1, x, a, b; i <= m; i++)
    {
        scanf("%s",s), scanf("%d",&x), x++;
         if(s[0] == 'i')
             a = Qroot(x), Eroot(x), b = Qroot(x);
        else
            b = T.Query(1,1,n,pos[x],bound[x]), T.Edit(1,1,n,pos[x],bound[x],0), a = T.Query(1,1,n,pos[x],bound[x]);
        printf("%d\n",b-a);
    }
    return 0;
}
```

---

## 作者：lwhllw (赞：0)

难点在于对于操作的处理（一开始操作一直接暴力没想到T了...）

操作1：改变0到目标节点的值为1，同时记录修改前值为0的节点数。

操作2：改变目标节点子树的值为0，同时记录修改前值为1的节点数。

操作2很好处理利用，先查询后处理，dfs序就行了

操作1弄了半天，发现只需要记录这条链上值为1的节点数目，再用 深度差+1-值为1的节点数目 就可以了

操作1的复杂度是O(log²n)，操作2的复杂度是O(logn)

p党代码如下


```cpp
uses math;
const maxn=100010;
type node=record
       left,right,lch,rch,data,op:longint;
     end;
var i,j,k,l,m,n,q,tot,ans:longint;
    top,w,son,size,depth,fa,head,last,first,next:array[0..maxn]of longint;
    a:array[0..maxn*4]of node;
procedure adds(x,y:longint);
begin
    inc(tot);
    next[tot]:=head[x];
    head[x]:=tot;
    last[tot]:=y;
end;
procedure dfs1(i,d:longint);
var j,k,p:longint;
begin
    depth[i]:=d;size[i]:=1;
    j:=head[i];p:=0;
    while j<>0 do
    begin
      k:=last[j];
      fa[k]:=i;
      dfs1(k,d+1);
      if size[k]>p then
      begin
        son[i]:=k;
        p:=size[k];
      end;
      inc(size[i],size[k]);
      j:=next[j];
    end;
end;
procedure dfs2(i:longint);
var j,k:longint;
begin
    inc(tot);w[i]:=tot;
    if son[fa[i]]=i then top[i]:=top[fa[i]]
    else top[i]:=i;
    j:=head[i];
    if son[i]<>0 then dfs2(son[i]);
    while j<>0 do
    begin
      k:=last[j];
      if son[i]<>k then dfs2(k);
      j:=next[j];
    end;
end;
procedure built(i,le,ri:longint);
var mid:longint;
begin
    if(le=ri)then
    begin
      a[i].lch:=le;a[i].rch:=ri;
      a[i].data:=0;a[i].op:=-1;
      exit;
    end;
    a[i].op:=-1;
    mid:=(le+ri)shr 1;
    a[i].lch:=le;
    a[i].rch:=ri;
    inc(tot);a[i].left:=tot;
    inc(tot);a[i].right:=tot;
    built(a[i].left,le,mid);
    built(a[i].right,mid+1,ri);
end;
procedure down(i:longint);
var l,r:longint;
begin
    l:=a[i].left;r:=a[i].right;
    if a[i].op<>-1 then
    begin
      a[l].op:=a[i].op;
      a[r].op:=a[i].op;
      a[l].data:=a[i].op*(a[l].rch-a[l].lch+1);
      a[r].data:=a[i].op*(a[r].rch-a[r].lch+1);
      a[i].op:=-1;
    end;
end;
procedure query(i,le,ri:longint);
var mid:longint;
begin
    if(a[i].lch>=le)and(a[i].rch<=ri)then
    begin
      inc(ans,a[i].data);
      exit;
    end;
    down(i);
    mid:=(a[i].lch+a[i].rch)shr 1;
    if(le<=mid)then query(a[i].left,le,ri);
    if(ri>mid)then query(a[i].right,le,ri);
end;
procedure change(i,le,ri,num:longint);
var mid:longint;
begin
    if(a[i].lch>=le)and(a[i].rch<=ri)then
    begin
      a[i].data:=num*(a[i].rch-a[i].lch+1);
      a[i].op:=num;
      exit;
    end;
    down(i);
    mid:=(a[i].lch+a[i].rch)shr 1;
    if(le<=mid)then change(a[i].left,le,ri,num);
    if(ri>mid)then change(a[i].right,le,ri,num);
    a[i].data:=a[a[i].left].data+a[a[i].right].data;
end;
procedure init;
var i,x,y:longint;
begin
    readln(n);
    for i:=1 to n-1 do
    begin
      read(y);
      adds(y,i);
    end;
    readln(q);
end;
procedure updata(i:longint);
var j,k,x,y,ansp:longint;
begin
    x:=i;y:=0;ansp:=0;
    while top[x]<>top[y] do
    begin
      j:=top[x];ans:=0;
      query(0,w[top[x]],w[x]);
      inc(ansp,depth[x]-depth[top[x]]+1-ans);
      change(0,w[top[x]],w[x],1);
      x:=fa[top[x]];
    end;
    ans:=0;
    query(0,w[y],w[x]);
    inc(ansp,depth[x]-depth[top[x]]+1-ans);
    change(0,w[y],w[x],1);
    writeln(ansp);
end;
procedure delete(i:longint);
var j,k:longint;
begin
    ans:=0;
    query(0,w[i],w[i]+size[i]-1);
    writeln(ans);
    change(0,w[i],w[i]+size[i]-1,0);
end;
procedure work;
var i,j,k:longint;
    ch:char;
begin
    for i:=1 to q do
    begin
      read(ch);
      if ch='i' then
      begin
        for j:=1 to 6 do read(ch);
        readln(k);updata(k);
      end;
      if ch='u' then
      begin
        for j:=1 to 8 do read(ch);
        readln(k);delete(k);
      end;
    end;
end;
begin
    init;
    tot:=0;
    dfs1(0,1);
    dfs2(0);
    tot:=0;
    fa[0]:=-1;
    built(0,1,n);
    work;
end.
```

---

## 作者：ww140142 (赞：0)

总之就是线段树维护树链剖分+dfs序；


详细题解和代码见链接咯：

http://blog.csdn.net/ww140142/article/details/46957597


---


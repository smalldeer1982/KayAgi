# [HNOI2003] 消防局的设立

## 题目描述

2020 年，人类在火星上建立了一个庞大的基地群，总共有 $n$ 个基地。起初为了节约材料，人类只修建了 $n-1$ 条道路来连接这些基地，并且每两个基地都能够通过道路到达，所以所有的基地形成了一个巨大的树状结构。如果基地 $A$ 到基地 $B$ 至少要经过 $d$ 条道路的话，我们称基地A到基地B的距离为 $d$。

由于火星上非常干燥，经常引发火灾，人类决定在火星上修建若干个消防局。消防局只能修建在基地里，每个消防局有能力扑灭与它距离不超过 $2$ 的基地的火灾。

你的任务是计算至少要修建多少个消防局才能够确保火星上所有的基地在发生火灾时，消防队有能力及时扑灭火灾。

## 样例 #1

### 输入

```
6
1
2
3
4
5
```

### 输出

```
2```

# 题解

## 作者：BJpers2 (赞：422)

看大家写的DP好强...我这里就提供一种比较简洁的贪心吧。

其实贪心思想楼上都已经说的很清楚了，就是找最低没被覆盖到的点，并在它的祖父处设一个消防站。考虑到这个点的所有子孙后代都已经被覆盖了，因此这时覆盖祖父能盖到更多额外的点，并保证结果不会更差。

很多思路是用dfs或堆求取最低节点，实际上没必要，只要预处理出深度（边输入边处理）并排序，碰到已覆盖就跳过，未覆盖就在祖父处设消防站，ans++。

问题在于怎样才能判断这个点覆盖到了没有。对于儿子或孙子覆盖他，可以在在儿子处设站时就标记它；而对于父亲和祖父覆盖他，可以用儿子对父亲的映射f来解决；问题在于兄弟。其实，可以用o数组维护“离i最近的消防站到i的距离”，当o[父亲]==1时，就能确定它是否被覆盖。

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#define N 2020
#define FOR(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
int n,b[N],f[N],d[N],o[N],ans,u,v,w;
bool cmp(int x,int y){return d[x]>d[y];}
int main(){
	scanf("%d",&n);b[1]=1,o[1]=o[0]=N;
	FOR(i,2,n) scanf("%d",&f[i]),d[i]=d[f[i]]+1,b[i]=i,o[i]=N;
	sort(b+1,b+n+1,cmp);
	FOR(i,1,n){
		v=b[i],w=f[v],u=f[f[v]];
		o[v]=min(o[v],min(o[w]+1,o[u]+2));
		if(o[v]>2){
			o[u]=0,ans++;
			o[f[u]]=min(o[f[u]],1),o[f[f[u]]]=min(o[f[f[u]]],2);
		}
	}printf("%d",ans);
}
```

顺便一提，这种方法的普适性很强，可以解决半径为k的最小覆盖问题。而且不用存图。只需要把维护“父亲和爷爷”改成维护“上位k位祖先”即可，复杂度O(N*K)，常数也很小。

---

## 作者：rickole (赞：256)

……蒟蒻第一次写题解，理解深入程度可能欠佳，望海涵。qwq

这是个树形dp。那首先……状态表示是：

F[i][state]表示节点i在state状态下的最小消防站个数

### 状态设计

然而，怎么设计状态呢……我直接在这一步卡住了，看了很多题解也没太明白。各位巨神题解的做法里都设了5个状态，但它们看起来毫无关联啊……极弱的我盯着看了半天，迷惑地问道：“这都是咋想到的啊？？？为啥有5个状态啊？为啥是这5个啊？”

想了一段时间之后，我似乎发现，这5个状态其实是有内在联系的。按我的理解，我把这些状态定义为：

```latex
F[i][0]表示可以覆盖到从节点i向上2层的最小消防站个数
F[i][1]表示可以覆盖到从节点i向上1层的最小消防站个数
F[i][2]表示可以覆盖到从节点i向上0层的最小消防站个数
F[i][3]表示可以覆盖到从节点i向上-1层的最小消防站个数
F[i][4]表示可以覆盖到从节点i向上-2层的最小消防站个数
```

其中，“覆盖到某层”的意思是在这棵子树中这一层和其以下层的所有点都被消防站覆盖到。比如，

“覆盖到从节点i向上1层”指的是“以节点i为根的整棵子树和i的父亲都被覆盖”，

“覆盖到从节点i向上-1层”指的是“节点i的所有儿子和它们的子孙都被覆盖”。

所以这就可以解释为什么是这5个状态了……为什么没有“覆盖到从节点i向上3层”？因为不可能。为什么没有“覆盖到从节点i向上-3层”？因为这是必须的。如果在这时候都没有覆盖全i的孙子，再向上递推时也就不可能覆盖它们了，所以设出这个状态没有意义。

哦对了，还有，在这五个状态中，上面的状态是包含下面的状态的。比如，如果能覆盖到节点i向上2层，则一定能覆盖到节点i向上1层。所以，有

$F[i][0]\ge F[i][1]\ge F[i][2]\ge F[i][3]\ge F[i][4]$


### 状态转移


$F[i][0] = 1+\displaystyle\sum_{\text{s是i的儿子}} F[s][4]$

因为i可以覆盖到向上2层，所以它自己必须是消防站。此时，它可以覆盖到所有儿子和孙子，因此儿子的状态可以是F[s][0~4]中的任意一种情况。但因为我们需要使得消防站个数最少，所以取F[s][4]。

$F[i][1] = \displaystyle\min_{\text{s是i的儿子}}\{{ F[s][0] + \sum_{\text{t是i的儿子,}t\ne s}{F[t][3]}} \}\quad \text{和}F[i][0]\text{中的最小值}$

因为i可以覆盖到向上1层，所以存在两种情况：要么恰好覆盖到i上面的1层，要么向上覆盖2层。

如果恰好覆盖到向上1层，那么i的至少一个儿子必须是消防站。其它儿子的状态可以是F[t][0~3]中的任意一种。同样，因为要取消防站个数最小值，取F[t][3]。

而如果向上覆盖两层，情况和F[i][0]是一样的。

取这两者最小值。

$F[i][2] =\displaystyle \min_{\text{s是i的儿子}}\{{ F[s][1] + \sum_{\text{t是i的儿子,}t\ne s}{F[t][2]}}\}\quad \text{和}F[i][0\text{-}1]\text{中的最小值}$


因为i可以覆盖到向上0层，所以要么恰好向上覆盖0层，要么向上覆盖1~2层。

如果向上覆盖0层，那么i的至少一个孙子必须是消防站，其它儿子的状态可以是F[t][0~2]中的任意一种。取F[t][2]。

而如果向上覆盖两层，情况和F[i][0]和F[i][1]是一样的。

取这三者最小值。

$F[i][3] =\displaystyle \sum_{\text{s是i的儿子}}\{F[s][2]\}\quad \text{和}F[i][0\text{-}2]\text{中的最小值}$

如果i恰好可以覆盖到向上-1层，即所有儿子被覆盖就可以。于是取F[s][2]。其它情况和上面取最小值。

$F[i][4] =\displaystyle \sum_{\text{s是i的儿子}}\{F[s][3]\}\quad \text{和}F[i][0\text{-}3]\text{中的最小值}$

如果i恰好可以覆盖到向上-2层，即所有孙子被覆盖就可以。取F[s][3]。其它情况和上面取最小值。

于是……就这样啦。

### 最终目标

我们希望寻找当整棵树都被覆盖的时候的消防站最小值，于是需要覆盖到根的这一层，于是结果是F[1][2]。

### 代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
#define maxN 1010
#define INF 2000000000

int N;
struct edge{
	int to;
	int next;
}sons[maxN]; //前向星存图
int head[maxN] = {0}; //前向星存图
int F[maxN][5];

int nowEdge = 0;
void addSon(int u, int v){
	nowEdge++;
	sons[nowEdge].to = v;
	sons[nowEdge].next = head[u];
	head[u] = nowEdge;
}

void dfs(int now){
	F[now][0] = 1;
	F[now][3] = 0;
	F[now][4] = 0;
	for(int i = head[now]; i; i = sons[i].next){
		int s = sons[i].to;
		dfs(s);
		F[now][0] += F[s][4];
		F[now][3] += F[s][2];
		F[now][4] += F[s][3];
	}
	if(head[now] == 0){
		F[now][1] = F[now][2] = 1;
		//特殊情况：如果now没有儿子，特殊处理
	}
	else{
		F[now][1] = F[now][2] = INF;
		for(int i = head[now]; i; i = sons[i].next){
			int s = sons[i].to;
			int F1 = F[s][0];
			int F2 = F[s][1];
			for(int j = head[now]; j; j = sons[j].next){
				if(i == j) continue;
				int t = sons[j].to;
				F1 += F[t][3];
				F2 += F[t][2];
			}
			F[now][1] = min(F[now][1], F1);
			F[now][2] = min(F[now][2], F2);
		}
	}
	for(int i = 1; i <= 4; i++){
		F[now][i] = min(F[now][i], F[now][i-1]);
		//把F[now][i]和前面取最小值的工作放在这里统一进行
	}
}

int main(){
	cin >> N;
	for(int i = 2; i <= N; i++){
		int f;
		cin >> f;
		addSon(f, i);
	}
	dfs(1);
	
	cout << F[1][2];
}
```


Qwq

---

## 作者：CaptainSlow (赞：87)

##写一个稍微好理解一点的题解

身为**蒟蒻**，看懂题意之后，明白了是一个树形动规，不过方程不太清楚。然后看了题解，看不懂~~~

最后历经十八弯终于搞懂了树形DP的思路（**就是不写贪心，不写贪心！！！**）。

由于在我看来之前的题解都不易理解，来当个好人，写一个蒟蒻们绝对看得懂的题解。


###树形DP不必解释了吧

下面讲一讲状态：

```cpp
DP[i][state] 表示 i 当前子树根节点
state就是一个一个的状态
state = 0, 1, 2 :
DP[i][0] 表示 选 i 为消防局
DP[i][1] 表示 {至少} 选了 i 的一个儿子为消防局
DP[i][2] 表示 {至少} 选了 i 的一个孙子为消防局
==================================以上三种状态是 i {一定被消防局覆盖} 的情况
state = 3, 4 :
DP[i][3] 表示 i 的 {所有} 儿子节点一定被消防局覆盖
DP[i][4] 表示 i 的 {所有} 孙子节点一定被消防局覆盖
==================================以上两种状态是 i {不一定被消防局覆盖} 的情况
```
然后讲转移

**（画棵树模拟一下理解得快些）**

```cpp
初始方程：

（以下j, k均表示i的儿子节点）

 DP[i][0] = 1 + Σ min ( DP[j][0...4] );
 由于当 i 为消防站之后儿子和孙子是否为消防局就无关紧要，因此状态在0~4中寻找一个MIN，然后还需要+1（因为自己是消防局）

 DP[i][1] = min ( DP[k][0] + Σ ( j != k ) min ( DP[j][0...3] ) );
 由于儿子为消防站时只能覆盖到兄弟（这里不含所选儿子的儿子），要使选了一个儿子之后子树中包括自己的所有节点都被覆盖，所以除了这个选的儿子，其他儿子的儿子一定要全部被覆盖，状态0~3满足。

 DP[i][2] = min ( DP[k][1] + Σ ( j != k ) min ( DP[j][0...2] ) );
 要使选了一个孙子之后合法，由于孙子最多只能覆盖到当前节点，所以其他儿子一定全部覆盖， 状态0~2满足 

 DP[i][3] = Σ min(DP[j][0...2]);
 要使儿子及孙子全部被覆盖，即儿子本身要被覆盖，状态0~2满足 

 DP[i][4] = Σ min(DP[j][0...3]); 
 孙子全部被覆盖 ，状态0~3满足
```
然后可以简化：（加速）（推到过程很简单，可以看我的代码一起理解，如果你明白了上面的方程这里就是小菜一碟了）

```cpp
 令 DP[i][j] 表示 min ( DP[i][0..k] ) (2<=k<=4)
 因此可以得到：
 DP[i][0] = 1 + Σ DP[j][4];
 DP[i][1] = DP[i][4] + min ( DP[k][0] - DP[k][3] );
 DP[i][2] = DP[i][3] + min ( DP[k][1] - DP[k][2] );
 DP[i][3] = Σ DP[j][2];
 DP[i][4] = Σ DP[j][3];
```
然后具体实践时还有一些小技巧，我的DP用递推实现

附代码：

```cpp
const
      INF=maxlongint;

var
    firap,last,point,next:array[0..1010]of longint;
    n,i,ai,e:longint;
    f:array[0..1000,0..4]of longint;

function min(n1,n2:longint):longint;
 begin
       if (n1<n2) then exit(n1) else exit(n2);
 end;

procedure dp(now:longint);
 var x1,x2,j,pj:longint;
 begin
       if ((firap[now]=-1) and (now<>1)) then    //特判（可能快些？）
       begin
             for j:=0 to 2 do f[now,j]:=1;
             for j:=3 to 4 do f[now,j]:=0;
             exit;
       end;

       x1:=INF;
       x2:=INF;
       f[now][0]:=1;
       j:=firap[now];
       while (j<>-1) do
       begin
             pj:=point[j];
             dp(pj);
             inc(f[now,0],f[pj,4]);
             inc(f[now,3],f[pj,2]);
             inc(f[now,4],f[pj,3]);
             x1:=min(x1,f[pj,0]-f[pj,3]);
             x2:=min(x2,f[pj,1]-f[pj,2]);
             j:=next[j];
       end;

       f[now,1]:=f[now,4]+x1;
       f[now,2]:=min(f[now,3]+x2,min(f[now,0],f[now,1]));
       f[now,3]:=min(f[now,2],f[now,3]);
       f[now,4]:=min(f[now,3],f[now,4]);
 end;

begin
      fillchar(firap,sizeof(firap),255);
      filldword(last,sizeof(last) div 4,0);
      fillchar(next,sizeof(next),255);

      read(n);
      for i:=2 to n do
      begin
            read(ai);
            e:=i-1;
            if (firap[ai]=-1) then firap[ai]:=e;
            next[last[ai]]:=e;
            point[e]:=i;
            last[ai]:=e;    //邻接表存边，读题意可以明白父节点编号一定小于该子节点编号
      end;

      dp(1);

      writeln(f[1][2]);    //输出F[1][2]，贪心思路
end.
```
参考资料：**（灰常感谢啊）**

@Crazyxx 在题解中最早写的一个思路

[某犇写的灰常易懂题解](http://www.cnblogs.com/QWsin/p/5306197.html)（他也参照了Crazyxx的思路，我的题解是在他写的之上整理而成）


---

## 作者：zhoutb2333 (赞：83)

这题贪心比较好想


考虑当前深度最大的叶子结点，你肯定要有一个消防局去覆盖它，


那么既然他是叶子结点，所以与他距离小于等于2的节点有这么几种：


1. 他的父亲 2. 他的兄弟 3. 他的爷爷


容易看出，在前两项能够覆盖到的节点，在爷爷那里设立一定也能覆盖到。


所以每次贪心取出深度最大的节点，在他的爷爷哪里放一个消防站


用STL的priority\_queue，时间复杂度O(nlogn)


```cpp
#include<bits/stdc++.h>
#define maxn 1010
#define maxm 2010
using namespace std;

int head[maxn],point[maxm],nxt[maxm],dep[maxn],fa[maxn],tot=0;
bool vis[maxn];
struct cmp{
    bool operator () (int &a,int &b){
        return dep[a]<dep[b];
    } 
};
priority_queue<int,vector<int>,cmp> q;
void add(int x,int y){
    point[++tot]=y;
    nxt[tot]=head[x];
    head[x]=tot;
}
void dfs(int temp,int father,int depth){
    fa[temp]=father;
    dep[temp]=depth;
    for(int j=head[temp];j;j=nxt[j]){
        if(point[j]==father)
            continue;
        dfs(point[j],temp,depth+1);
    }
}
void dfs2(int temp,int depth){
    if(depth>2)
        return;
    vis[temp]=true;
    for(int j=head[temp];j;j=nxt[j])
        dfs2(point[j],depth+1);
}
int main(){
    int n,cnt,x,y,ans=0;
    scanf("%d",&n),cnt=n;
    for(int i=1;i<=n-1;i++)
        scanf("%d",&x),add(i+1,x),add(x,i+1);
    dfs(1,0,1);
    for(int i=1;i<=n;i++)
        q.push(i);
    while(q.size()){
        while(q.size()&&vis[x=q.top()])
            q.pop();
        if(!q.size())
            break;
        if(fa[fa[x]])
            dfs2(fa[fa[x]],0);
        else
            dfs2(1,0);
        ans++; 
    }
    printf("%d\n",ans);
    return 0;
} 
```

---

## 作者：CSP_Sept (赞：72)

本题先前的题解，可以说是没有一篇做到了内容质量与美观程度并存，而这又是一道经典题目，所以打算写一篇完整而又详细美观的题解。

**本文含有贪心及 dp 的做法，适合所有语言人群阅读。**

# 0x01 解法

## 解法 A. 贪心

### A-1 贪心思路

我们贪心地先选择深度大的节点，由于一个消防站能够覆盖五层的节点，我们找出当前选择节点 $u$ 的父亲 $v$ 与爷爷 $w$。

开三个 bool 数组 $\text{diz, dio, dit}$ 分别记录以下信息：

1. $\text{diz}$：是否被距离为 $0$ 的点覆盖：消防站在 $u$ 上。
2. $\text{dio}$：是否被距离为 $1$ 的点覆盖：消防站在 $v$ 或 $u$ 的儿子上。
3. $\text{dit}$：是否被距离为 $2$ 的点覆盖：消防站在 $w$ 或 $u$ 的兄弟（$v$ 的儿子或 $w$ 的孙子）上。

每次遍历时只要寻找一下 $u,v,w$ 对应的 bool 值是否为 $\textbf{false}$ 即可。

以下是不在 $w$ 点染色的情况。

1. $\text{diz}_u,\text{diz}_v,\text{diz}_w$ 中有一个值为 $\textbf{true}$：意味着 $u$ 点已经被覆盖到，没必要对 $w$ 染色。
2. $\text{dio}_u,\text{dio}_v$ 中有一个值为 $\textbf{true}$：意味着 $u$ 点已经被覆盖到，没必要对 $w$ 染色。
3. $\text{dit}_u$ 的值为 $\textbf{true}$：意味着 $u$ 点已经被覆盖到，没必要对 $w$ 染色。

（上述情况的证明非常容易，留作习题。）

这里再记 $fa(x)$ 表示节点 $x$ 的父亲。

若不满足上面提及的情况，我们就可以对 $w$ 进行染色，并将 $\text{diz}_w,\text{dio}_{fa(w)},\text{dit}_{fa(fa(w))}$ 标记为 $\textbf{true}$。

不管 $u,v$ 的原因是以后都用不上它们了。

还不明白？那就看看下面的图理解。

### A-2 贪心实例

考虑如下的一棵树。

![](https://cdn.luogu.com.cn/upload/image_hosting/yxvyd1iu.png)

其中 $\text{dep}_i$ 表示节点 $i$ 的深度，箭头从每个 $x$ 指向 $fa(x)$。

我们先按 $\text{dep}$ 从大到小进行排序，先扫描到点 $7$。

![](https://cdn.luogu.com.cn/upload/image_hosting/8an89hmz.png)

经过对爷爷 $4$ 和父亲 $6$ 的查询，我们发现点 $4$ 可染色，于是便标记 $1,3,4$，$\text{dit}_1 = \textbf{true}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/xn3b5osj.png)

接下来依次扫描点 $5,6,4$，发现都不符合要求，不进行染色操作。

当扫描到点 $2$ 时，我们发现它的父亲 $1$ 的 $\text{dio}$ 值为 $\textbf{false}$。（之前标记的是 $1$ 的 $\text{dit}$ 值），且其他对应的 bool 值都符合要求，于是我们对 $2$ 的爷爷（假设有）进行染色。

答案为 $2$，完美覆盖了整棵树。

### A-3 贪心代码

```cpp
#include <cstdio>
#include <algorithm>

#define N 2021
using namespace std;
bool diz[N], dio[N], dit[N];
int fa[N], de[N], ind[N];
bool cmp(int a, int b){
	return de[a] > de[b];
}
bool check(int u, int op){
	if(op == 0) return (!diz[u]) && (!dio[u]) && (!dit[u]);
	if(op == 1) return (!diz[u]) && (!dio[u]);
	return !diz[u];
}
int n;
int ans = 0;
int main(){
	scanf("%d", &n);
	ind[1] = 1;
	for(int i = 2 ; i <= n ; i++){
		scanf("%d", &fa[i]);
		de[i] = de[fa[i]] + 1;
		ind[i] = i;
	}
	sort(ind + 1, ind + n + 1, cmp);
	for(int i = 1 ; i <= n ; i++){
		int u = ind[i], v = fa[u], w = fa[v], x = fa[w], y = fa[x];
		if(check(u, 0) && check(v, 1) && check(w, 2))
		    ans++, diz[w] = 1, dio[x] = 1, dit[y] = 1;
	}
	printf("%d\n", ans);
	return 0;
}
```

## 解法 B. dp

### B-2 dp 状态设计

令 $d=\text{dep}_i$，设 $dp_{i,j}\ (1\le i\le n,-2\le j\le 2)$ 表示所有 $i$ 的子孙与祖先 $u$ 中满足 $\text{dep}_u\ge d-j$ 的点都能被覆盖到。

注意到对于 $-2\le j\le k\le 2$，覆盖 $k$ 层的情况一定包含了覆盖 $j$ 层的情况，故有 $dp_{i,j}\le dp_{i,k}$，当下列出现**至少**覆盖 $j$ 层的字眼时，默认选择 $dp$ 值最小的，即选择 $dp_{i,j}$。

### B-2 dp 转移方程

容易发现，若 $i$ 要覆盖到 $2$ 层，则 $i$ 本身必须被染色且 $i$ 的儿子们也必须覆盖到至少 $-2$ 层，即

$$
dp_{i,2}=1+\sum\limits_{u\in son(i)}dp_{u,-2}
$$

求 $dp_{i,1}$，我们发现有两种情况：

- 若覆盖恰好 $1$ 层，则 $i$ 的儿子中必有一个点 $u$ 经过了染色，其他儿子 $v$ 都覆盖了至少 $-1$ 层。
- 若覆盖 $2$ 层，答案就是 $dp_{i,2}$。

于是就有式子

$$
dp_{i,1}=\min\left\{dp_{i,2},\min\left\{dp_{u,2}+\sum\limits_{v\in son(i)\land v\ne u}dp_{v,-1}\right\}\right\}
$$

求 $dp_{i,0}$，有以下两种情况：

- 恰好覆盖 $0$ 层，则 $i$ 的儿子中至少有一个点 $u$ 能覆盖 $1$ 层，其他儿子 $v$ 都覆盖了至少 $0$ 层。
- 若覆盖 $1,2$ 层，则答案就是 $\min(dp_{i,1},dp_{i,2})$。

于是就有式子：

$$
dp_{i,0}=\min\left\{dp_{i,1},dp_{i,2},\min\left\{dp_{u,1}+\sum\limits_{v\in son(i)\land v\ne u}dp_{v,0}\right\}\right\}
$$

- 对于 $dp_{i,-1}$ 的求解，我们只要让其所有儿子都被覆盖即可。
- 对于 $dp_{i,-2}$ 的求解，我们只要让其所有孙子都被覆盖即可。

于是有式子：

$$
\begin{aligned}
dp_{i,-1}&=\min\left\{dp_{i,0\sim2},\sum\limits_{u\in son(i)}dp_{u,0}\right\}\\
dp_{i,-2}&=\min\left\{dp_{i,-1\sim 2},\sum\limits_{u\in son(i)}dp_{u,-1}\right\}
\end{aligned}
$$

我们得到了上述 5 个转移方程后，即可开始转移。

最后的答案是覆盖节点 $1$ 的 $0$ 层所需的最小染色点数，即 $dp_{1,0}$。

**为了方便，我们在开数组的时候，将第二维统一加上 $2$，将 $-2\sim2$ 变为 $0\sim4$，防止 RE。**

### B-3 dp 代码

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>

#define N 2021
#define INF 99999999
using namespace std;
vector <int> t[N];
int dp[N][5];
int n;
void dfs(int u){
	dp[u][4] = 1, dp[u][1] = 0, dp[u][0] = 0;
	int len = t[u].size();
	for(int i = 0 ; i < len ; i++){
		int v = t[u][i];
		dfs(v);
		dp[u][4] += dp[v][0];
		dp[u][1] += dp[v][2];
		dp[u][0] += dp[v][1];
	}
	if(!len) dp[u][2] = dp[u][3] = 1;
	else{
		dp[u][2] = dp[u][3] = INF;
		int cnt1 = 0, cnt2 = 0;
		// %
		for(int i = 0 ; i < len ; i++){
			int v = t[u][i];
			cnt1 += dp[v][1];
			cnt2 += dp[v][2];
		}
		for(int i = 0 ; i < len ; i++){
			int v = t[u][i];
			dp[u][3] = min(cnt1 - dp[v][1] + dp[v][4], dp[u][3]);
			dp[u][2] = min(cnt2 - dp[v][2] + dp[v][3], dp[u][2]);
		}
		// %
	}
	for(int i = 3 ; i >= 0 ; i--)
	    dp[u][i] = min(dp[u][i + 1], dp[u][i]);
}
int main(){
	scanf("%d", &n);
	for(int i = 2 ; i <= n ; i++){
		int u;
		scanf("%d", &u);
		t[u].push_back(i);
	}
	dfs(1);
	printf("%d\n", dp[1][2]);
	return 0;
}
```

这里计算 $dp_{i,0},dp_{i,1}$ 的部分（注释 $\tt \%$ 的部分）运用了一个先计算总和再减去对应部分的 trick，复杂度有所降低。

# 0x02 后记

## 比较

实测表明 dp 耗时 33 ms，贪心耗时 30 ms。

其中，dp 码量更大但转移较为显然；贪心码量小但理解需要再花一点功夫。

## 修改日志

- **2023.07.24** 重构全文，改正多处用词，修了一车笔误，重新绘制了插图。改写前版本备份：<https://www.luogu.com.cn/paste/80vc1ome>。

---

## 作者：RenaMoe (赞：54)

# 题解 P2279 【[HNOI2003]消防局的设立】

[题目]( https://www.luogu.org/problem/P2279 )

第一道连状态都不会表示的$dp$

转移方程推到吐。。。

## 状态表示

每一个点$x$都有五个状态：

> `f[x][0]`：覆盖到x的爷爷和x整棵子树（向上2层），最少个数

> `f[x][1]`：覆盖到x的父亲和x整棵子树（向上1层），最少个数

> `f[x][2]`：覆盖x整棵子树（向上0层），最少个数

> `f[x][3]`：覆盖所有x的儿子及其子树（向上-1层），最少个数

> `f[x][4]`：覆盖所有x的孙子及其子树（向上-2层），最少个数

----


- `f[x][0]`：覆盖到x的爷爷和x整棵子树（向上2层），最少个数

![](https://cdn.luogu.com.cn/upload/image_hosting/83nui5b4.png)

- `f[x][1]`：覆盖到x的父亲和x整棵子树（向上1层），最少个数

![](https://cdn.luogu.com.cn/upload/image_hosting/6lhd8icf.png)

- `f[x][2]`：覆盖x整棵子树（向上0层），最少个数

![](https://cdn.luogu.com.cn/upload/image_hosting/sxrk7lgi.png)

- `f[x][3]`：覆盖所有x的儿子及其子树（向上-1层），最少个数

![](https://cdn.luogu.com.cn/upload/image_hosting/zdnxa2p1.png)

- `f[x][4]`：覆盖所有x的孙子及其子树（向上-2层），最少个数

![](https://cdn.luogu.com.cn/upload/image_hosting/djsdjzke.png)

## 转移方程

y，z是x的儿子

$f[x][0] = 1 + \sum{f[y][4]}$
$f[x][1] = min(f[y][0] + \sum{(y!=z)f[z][3]})$
$f[x][2] = min(f[y][1] + \sum{(y!=z)f[z][2]})$
$f[x][3] = \sum{f[y][2]}$
$f[x][4] = \sum{f[y][3]}$

显然`f[x][i]`一定包含`f[x][i+1]`

易得`f[x][0] >= f[x][1] >= f[x][2] >= f[x][3] >= f[x][4]`

所以转移时保证满足条件的前提下尽量选最低层的状态

----

- $f[x][0] = 1 + \sum{f[y][4]}$ 

要覆盖到爷爷的话必须选x，并贪心地选y的第五种状态

![](https://cdn.luogu.com.cn/upload/image_hosting/ogxjicaf.png)

- $f[x][1] = min(f[y][0] + \sum{(y!=z)f[z][3]})$

x的儿子中有一个一定覆盖的爷爷，同时覆盖到兄弟（因为y一定是选了），其他的儿子只需要覆盖的自己的儿子即可

![](https://cdn.luogu.com.cn/upload/image_hosting/86y5d7hh.png)

- $f[x][2] = min(f[y][1] + \sum{(y!=z)f[z][2]})$

同理，有一个儿子覆盖到父亲，但无法覆盖到y的兄弟，所以其他儿子要覆盖到自己

- $f[x][3] = \sum{f[y][2]}$

让每个儿子覆盖到自己即可

- $f[x][4] = \sum{f[y][3]}$

让每个儿子覆盖到自己的儿子

---

注意：

**`f[x][i]`包含`f[x][i+1]`，若`f[x][i]`比`f[x][i+1]`更优，`f[x][i+1]`应更新**



## 代码

```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>

using namespace std;

template<typename T> inline void read(T &x) {
	x = 0; T k = 1; char in = getchar();
	while (!isdigit(in)) { if (in == '-') k = -1; in = getchar(); }
	while (isdigit(in)) x = x * 10 + in - '0', in = getchar();
	x *= k;
}

const int N = 1005;

struct Edge {
    int nxt, to;
};

int n, cnt;
int head[N], f[N][5];
Edge e[N<<1];

inline void add(int u, int v) {
    e[++cnt] = (Edge){head[u], v}, head[u] = cnt;
}

void dfs(int x, int fa) {
    // 记录f[y][2], f[y][3]的总和，后面容斥即可
    int sum2 = 0, sum3 = 0, y, tot;
    for (int i = head[x]; i; i = e[i].nxt)
        if (e[i].to != fa) {
            y = e[i].to;
            dfs(y, x);
            sum2 += f[y][2], sum3 += f[y][3];
            tot++;
        }
    // 没有儿子特判
    if (!tot) {
        f[x][0] = f[x][1] = f[x][2] = 1;
        return;
    }
    f[x][0] = 1, f[x][1] = f[x][2] = N;
    for (int i = head[x]; i; i = e[i].nxt)
        if (e[i].to != fa) {
            y = e[i].to;
            f[x][0] += f[y][4];
            f[x][1] = min(f[x][1], f[y][0] + sum3 - f[y][3]);
            f[x][2] = min(f[x][2], f[y][1] + sum2 - f[y][2]);
            f[x][3] += f[y][2];
            f[x][4] += f[y][3];
        }
    // 检查最小值
    for (int i = 1; i < 5; ++i)
        f[x][i] = min(f[x][i], f[x][i-1]);
}

int main() {
    read(n);
    for (int i = 2, x; i <= n; ++i)
        read(x), add(x, i), add(i, x);
    dfs(1, 0);
    printf("%d\n", f[1][2]);
}
```



---

## 作者：star_city (赞：30)

这里分享一个线性做法，告别n^2和nlogn。

思路当然还是贪心，以1号点为根，对所有点按深度从大到小在它们的爷爷的地方建一个消防局。

由于dfs序的点的深度参差不齐，导致需要用堆来存储这些点。但事实上，我们可以用bfs代替dfs，而得到的bfs序的点的深度一定是单调的（这个为什么我就不说了，如果你不知道应该重新去学bfs）。这样我们就可以用栈来存储bfs得到的点，最终我们会得到一个单调栈。

为啥要用栈而不用队列？因为~~栈是先进后出~~对于每个点，深度越大，入栈时间越靠后，深度最大的点会成为栈顶元素。
```
#include <iostream>
#include <cstdio>
#include <queue>
#include <stack>

const int maxn = 1007;

using namespace std;

int ans; //ans即为最终答案
int to[maxn << 1];
int nex[maxn << 1];
int last[maxn], k; //前向星的一些东西
int fa[maxn]; //每个点的父亲
int dep[maxn]; //每个点的深度
bool vis[maxn]; //这个在最后贪心的时候用

queue <int> q; //队列用于bfs
stack <int> s; //栈用于存储bfs点序

inline void add_edge(int u, int v)
{
    to[++k] = v; nex[k] = last[u]; last[u] = k;
} //加边

inline void bfs() //bfs用于预处理出所有点的深度并把它们依次压入栈中
{
    //从1号点开始
    q.push(1);
    s.push(1);
    dep[1] = 1;
    while (!q.empty()) {
        int x = q.front();
        q.pop();
        for (int i = last[x]; i; i = nex[i]) {
            int y = to[i];
            if (y == fa[x]) continue;
            dep[y] = dep[x] + 1;
            q.push(y);
            s.push(y); //从这里也可以看出元素按照深度从小到大入栈
        }
    }
}

void dfs(int x, int depth) //这个dfs代表在x建一个消防局的影响
{
    if (depth > 2) return; //距离超过2就没影响了
    vis[x] = 1; //这就是影响
    for (int i = last[x]; i; i = nex[i])
        dfs(to[i], depth + 1);
}

inline void tackle()
{
    while (!s.empty()) {
        int x = s.top(); //依次取出栈内元素，此时栈内元素相当于已经按深度排过序了
        s.pop();
        if (!vis[x] && ++ans) dfs(fa[fa[x]], 0); //这么写“&&++ans”是为了压行，很好理解，不作阐述
        //如果没被覆盖就在它爷爷那里建个消防局，同时所需要的消防局+1
    }
}

int main(void) //简洁的主函数
{
    int n;
    scanf("%d", &n);
    for (int i = 2; i <= n; i++) {
        scanf("%d", &fa[i]);
        add_edge(i, fa[i]);
        add_edge(fa[i], i);
        //输入每个点的父亲以及连边
    }
    bfs();
    tackle();
    cout << ans;
    
    return 0;
}
```

---

## 作者：Crazyxx (赞：19)

类比距离为1的题，这题应该是树形dp，但是状态可能会多一些

1、状态的设计：

f[i][0]: 表示选了自己

f[i][1]: 表示选了儿子

f[i][2]: 表示选了孙子

——上面用来表示这个点被覆盖了的状态，下面为这个点没有被覆盖的状态

f[i][3]: 表示自己不一定被覆盖，但是儿子一定全部被覆盖

f[i][4]: 表示自己和儿子都不一定被覆盖，但是孙子一定全部都被覆盖


2、状态的更新


```cpp
f[i][0] = 1+Σmin(f[j][0...4]);
f[i][1] = min( f[k][0] + Σ(j != k)min(f[j][0...3]) );
f[i][2] = min( f[k][1] + Σ(j != k)min(f[j][0...2]) );
f[i][3] = Σf[j][0...2];
f[i][4] = Σf[j][0...3];
```
3、状态的简化
上面的状态貌似已经可以搞了，但是我们发现上面有很多...，可以合并

令f[i][j] = min(f[i][0...j]) (j >= 2)

f[i][0] = 1+Σf[j][4];

f[i][1] = min( f[k][0] + Σ(j != k)f[j][3] ) 

= Σf[j][3] + min(f[k][0]-f[k][3])

          = f[i][4] + min(f[k][0]-f[k][3]);

f[i][2] = min( f[k][1] + Σ(j != k)f[j][2] ) 

= Σf[j][2] + min(f[k][1]-f[k][2])

          = f[i][3] + min(f[k][1]-f[k][2]);

f[i][3] = Σf[j][2];

f[i][4] = Σf[j][3];

最后再更新一遍，使得f[i][j] = min(f[i][0...j]) (j >= 2)

f[1][2]即为答案，O(n+m)的复杂度(貌似n为1000，邻接矩阵n^2也可通过)


---

## 作者：quest_2 (赞：14)

 _先推一下笔者的[博客](https://www.luogu.com.cn/blog/quest233/#)～_
 
 _这里的一部分内容也会在笔者的另一篇文章中被引用到～_ 

_个人觉得这篇题解重在说明转移方程的含义_

### 题意？

这是一道比较板的**树形DP**的**选点覆盖全图**问题～

这种题所说的“覆盖”一般是指当一个点与另一个点的**相对位置达到某种关系**时，可以称一个点覆盖另一个点。

大致意思如下：

```
N个基地呈树状分布，现在要选中一些基地作为消防站。
消防站能保护的范围是和他距离不大于2的所有点。
这里定义每条边长度都为1。
现在要求一种方案保护全部基地。
需要建的消防站尽可能少。
```

### 思路？

这里的覆盖关系是和**相对距离**有关的，那我们肯定需要打一个求树上两点相对距离的 $\operatorname{dfs}$ ，这是毫无疑问需要的。这部分代码这里就先放一下：

```cpp
void getdis(int u, int lst)
{
	
    for (int i = head[u]; i; i = e[i].next)
    {
        int v = e[i].to;
        if (v == lst)
        {
            continue;
        }//前向星遍历
        
        dis[root][v] = dis[v][root] = dis[root][u] + 1;
        //这个点v到我们选中的起点的距离
        //为他的父亲u到起点的距离+1
        //这里的root指的是相对距离中的起点
        getdis(v, u);
        //向下搜
    }
}
```
我们做这个的时候要轮流选一个点作为起点 $root$ ，所以主函数里有这样的语句：

```cpp
for (int i = 1; i <= N; i++)
{
	root = i;
	getdis(i, -1);//轮流做起点跑相对距离
}
```

接下来就到DP环节，有关状态的设置我们有“选点覆盖全图”这类题的基本套路：$dp_{u,i}$ 表示树上**以** $u$ **为根的子树都被覆盖**，且 $u$ **这个点被** $i$ **覆盖**时，所付出的最小代价。 $ans_u$ 表示**以** $u$ **为根的子树都被覆盖**时，所付出的最小代价（ $ans$ 这里不指定是谁来覆盖 $u$ ）。

换言之， $ans_u$ 其实是枚举 $i$ 时所有的 $dp_{u,i}$ 中的最优解。

写成状态转移方程的形式如下：

$$ans_u=\max(\ dp_{ u,i}\ )$$

而 $dp_{u,i}$ 我们又要如何得出呢？我们知道，“一个点的子树被完全覆盖，那这个点所有的儿子的子树也都会被完全覆盖” 。所以我们在确定一个 $i$ 的情况下，就必然有

$$dp_{u,i} =\sum_{v=son\ of\ u}\min(\ ans_{v}, dp_{v,i} - 1\ )$$

也就是说，要么让覆盖 $u$ 的这个点 $i$ 也去覆盖 $v$ （这样就可以少付出一个点的代价，即 $ dp_{v,i} - 1$ ），要么找 $v$ 的子树被完全覆盖，而 $v$ 不是被 $i$ 覆盖时的最优解，这个最优解就是 $ans_v$ 。 

因为 $dp_{u,i}$ 这一状态是默认选择了一个 $i$ 的，所以这里的累加时， $dp_{u,i}$ **从1起步**。

那我们设计DP顺序的时候就很简单了，肯定要从下往上回溯，用儿子更新父亲。

这部分实现如下～

```cpp
void DP(int u, int lst)
{
/*前向星遍历，谨记“先下搜，再回溯更新”*/
    for (int i = head[u]; i; i = e[i].next)
    {
        int v = e[i].to;
        if (v == lst)
        {
            continue;
        }
        DP(v, u);//下搜
    }
    
    for (int i = 1; i <= N; i++)
    {
        if (dis[u][i] > 2)
        {
            dp[u][i] = INF;
            continue;
        }//倘若i根本覆盖不了u，这种情况就不存在了
        dp[u][i] = 1;
        //累加从1起步
        for (int j = head[u]; j; j = e[j].next)
        {
            int v = e[j].to;
            if (v == lst)
                continue;//前向星遍历基操
            dp[u][i] += min(ans[v], dp[v][i] - 1);
            //转移出dp[u][i]
        }
        ans[u] = min(ans[u], dp[u][i]);
        //转移出ans[u]
    }
}
```

那么答案就是 $ans_1$ ，代表以1为根的树被完全覆盖（这道题是默认以1为全图的根的，若不默认，则还要有一个找根环节），完整代码如下：

```cpp
#include <bits/stdc++.h>
const int MAX = 2007;
const int INF = 0x3f3f3f3f;
using namespace std;
int dp[MAX][MAX], ans[MAX], dis[MAX][MAX];
int N;
struct edge
{
    int to;
    int next;
} e[MAX];
int head[MAX], eid = 0;
void adde(int x, int y)
{

    e[++eid].to = y;
    e[eid].next = head[x];
    head[x] = eid;
}
int root;
void getdis(int u, int lst)
{
    for (int i = head[u]; i; i = e[i].next)
    {
        int v = e[i].to;
        if (v == lst)
        {
            continue;
        }
        dis[root][v] = dis[v][root] = dis[root][u] + 1;
        getdis(v, u);
    }
}
void DP(int u, int lst)
{
    for (int i = head[u]; i; i = e[i].next)
    {
        int v = e[i].to;
        if (v == lst)
        {
            continue;
        }
        DP(v, u);
    }
    for (int i = 1; i <= N; i++)
    {
        if (dis[u][i] > 2)
        {
            dp[u][i] = INF;
            continue;
        }
        dp[u][i] = 1;
        for (int j = head[u]; j; j = e[j].next)
        {
            int v = e[j].to;
            if (v == lst)
                continue;
            dp[u][i] += min(ans[v], dp[v][i] - 1);
        }
        ans[u] = min(ans[u], dp[u][i]);
    }
}
int main()
{
    memset(dp, INF, sizeof(dp));
    memset(ans, INF, sizeof(ans));
    cin >> N;
    for (int i = 2; i <= N; i++)
    {
        int fr;
        cin >> fr;
        adde(i, fr );
        adde(fr , i);
    }
    for (int i = 1; i <= N; i++)
    {
        root = i;
        getdis(i, -1);
    }
    DP(1, -1);
    cout << ans[1] << endl;
}
```


---

## 作者：WAAutoMaton (赞：13)

对于一道$O(n^2)$可过的题来说，只需要非常暴力的做法就够了。

我们只需要每次找出最深的未被消防局覆盖的节点，然后在他的爷爷处建一个消防局就行了（这个做法的正确性证明可见其他题解）。

第一步，找最深的节点用堆？没必要啊，$O(n)$遍历一遍就行了。

第二步，建一个消防局咋建？打标记？没必要啊，暴力dfs覆盖范围内的所有节点就行了，还是$O(n)$的。

消防局一共有$O(n)$个，所以总复杂度是$O(n^2)$的。

这个做法虽然复杂度比其他题解高，但是好写不是么？（而且也足够通过本题，由于数据不强还是0ms过的）

##### 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 1000
struct Edge
{
    int to,next;
}e[MAXN+10];
int head[MAXN+10];
void addEdge(int from,int to)
{
    static int c=0;
    e[++c]=(Edge){to,head[from]};
    head[from]=c;
}
int fa[MAXN+10];
bool vis[MAXN+10];
int deep[MAXN+10];
void dfs2(int now,int d)
{
    vis[now]=false;
    if (d==0) return;
    for(int i=head[now]; i!=0; i=e[i].next)
    {
        dfs2(e[i].to,d-1);
    }
    dfs2(fa[now],d-1);
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen("in.txt","r",stdin);
#endif
    int n;
    scanf("%d",&n);
    fa[1]=1;
    for(int i=2; i<=n; ++i)
    {
        int a;
        scanf("%d",&a);
        addEdge(a,i);
        fa[i]=a;
    }
    for(int i=1; i<=n; ++i)
    {
        deep[i]=deep[fa[i]]+1;
    }
    int ans=0;
    memset(vis,true,sizeof(vis));
    while(true)
    {
        int t=0;
        for(int i=1; i<=n; ++i)
        {
            if (vis[i] && deep[i]>deep[t]) t=i;
        }
        if (t==0) break;
        dfs2(fa[fa[t]],2);
        ++ans;
    }
    printf("%d\n",ans);
    return 0;
}
```
[顺便偷偷宣传博客](http://waautomaton.tk/2017/10/31/bzoj-1217-lg-2279-HNOI-2003-%E6%B6%88%E9%98%B2%E5%B1%80%E7%9A%84%E8%AE%BE%E7%AB%8B-%E9%A2%98%E8%A7%A3/)


---

## 作者：小强 (赞：9)

题解：

额。树形dp，比较常见的类型，一般就是给你一棵数和每个点可向外覆盖的点的个数，求最少选几个点可以覆盖所有的点。

一般本类题状态只有两个，1.第几号点2.还可以向外覆盖多少点。

本题可向外覆盖的点位2，那么状态很简单：

f[i][0]表示i号点可以向外覆盖0个点所需的最少个数

f[i][1]表示可以向外覆盖1个点。

f[i][2]表示可以向外覆盖2个点。

f[i][3]表示可以向外覆盖-1个点（就是这个点不覆盖，且儿子覆盖）。

f[i][4]表示可以向外覆盖-2个点。

状态设计完成，接下来考虑状态转移

```cpp
f[i][0]=min(f[k][2]-f[k][3])+∑(j!=k)f[j][0]
f[i][1]=min(f[k][1]-f[k][0])+∑(j!=k)f[j][3]
f[i][2]=∑f[j][4]+1;
f[i][3]=∑f[j][0] f[i][4]=∑f[j][3]
```
(其实状态转移比较好写，画个图就出来了，注意一下0和1的地方就可以了)
最后输出f[1][0]即可。

最后附上代码（写的丑，dalao别喷）

```cpp
#include<bits/stdc++.h>
using namespace std;

const int max_n = 1010;
const int inf   = 1e9+7;

int point[max_n],nxt[max_n<<1],v[max_n<<1];
int f[max_n][5];
int n,m,x,tot;

inline void init()
{
    memset(point,-1,sizeof(point));
    memset(nxt,-1,sizeof(nxt));
    tot=-1;
}

inline void addedge(int x,int y)
{
    ++tot; nxt[tot]=point[x]; point[x]=tot; v[tot]=y;
    ++tot; nxt[tot]=point[y]; point[y]=tot; v[tot]=x;
}

void dp(int now,int fa)
{
    int ans1=inf,ans2=inf;
    if(nxt[point[now]]==-1 && now!=1)
    {
        f[now][2]=f[now][0]=f[now][1]=1;
        f[now][3]=f[now][4]=0;
        return;
    }
    for(int i=point[now]; i!=-1; i=nxt[i])
      if(v[i]!=fa) dp(v[i],now);
    for(int i=point[now]; i!=-1; i=nxt[i])
    {
        if(v[i]==fa) continue;
        f[now][2]+=f[v[i]][4];
        f[now][3]+=f[v[i]][0];
        f[now][4]+=f[v[i]][3];
        ans1=min(ans1,f[v[i]][2]-f[v[i]][3]);
        ans2=min(ans2,f[v[i]][1]-f[v[i]][0]);
    }
    f[now][0]=f[now][3]+ans2;
    f[now][1]=f[now][4]+ans1;
    f[now][2]+=1;
    f[now][4]=min(min(f[now][0],min(f[now][4],f[now][3])),min(f[now][2],f[now][1]));
    f[now][3]=min(min(f[now][3],f[now][2]),min(f[now][1],f[now][0]));
    f[now][0]=min(f[now][0],min(f[now][1],f[now][2])); f[now][1]=min(f[now][1],f[now][2]);
}

int main()
{
    scanf("%d",&n);
    init();
    for(int i=1; i<n; ++i)
    {
        scanf("%d",&x);
        addedge(i+1,x);
    }
    dp(1,0);
    printf("%d\n",f[1][0]);
    return 0;
}
```

---

## 作者：hhhhyq (赞：6)

1. 树形dp ： 树上任意一个点，离他最近的消防局距离不超过2
  
  ~~不会做啊~~ 这个做法太复杂，我们考虑一下其他的简单做法。
1. 问题转化解法
 * 考虑**叶子节点**找到可以覆盖自己的点：自己，父亲，父亲的儿子，爷爷。那么**爷爷建一定最优**（另外点能覆盖到的点，爷爷均能覆盖）因此，每次找深度最深的点，在他的爷爷处修建，并把能覆盖的点从树中删去
    
3. _dfs1_建树、求深度，_dfs2_删点（用_vis_表示删去的点），用堆维护，每次弹出的点即最深点。

_Code:_

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>

using namespace std;
const int maxn=1010;
int n;
struct edge
{
    int v,nxt;
}e[maxn*2];
int f[maxn],s[maxn],head[maxn];
int cnt=0,ans=0;
bool vis[maxn];
int dpt[maxn];
void add_edge(int u,int v)
{
    cnt++;
    e[cnt]=(edge){v,head[u]};
    head[u]=cnt;
}
priority_queue< pair<int,int> > q;
void dfs1(int x,int f)
{
    vis[x]=1;
    dpt[x]=dpt[f]+1;
    q.push(make_pair(dpt[x],x));
    for(int i=head[x];i;i=e[i].nxt)
    {
        if(!vis[e[i].v]){
        dfs1(e[i].v,x);	
        }
    }
}
void dfs2(int x,int d)
{
    if(d>2)return;
    vis[x]=1;
    for(int i=head[x];i;i=e[i].nxt)
    {
        dfs2(e[i].v,d+1);
    }
}

int main(){
    scanf("%d",&n);
    
    for(int i=2;i<=n;i++)
    {
        scanf("%d",&f[i]);
        add_edge(i,f[i]);
        add_edge(f[i],i);
    }
    f[1]=1;
    dfs1(1,1);
    memset(vis,0,sizeof(vis));
    while(!q.empty()){
        while(!q.empty()&&vis[q.top().second])q.pop();
        if(q.empty())break;
        int t=q.top().second;q.pop();
        dfs2(f[f[t]],0);
        ans++;
    }
    printf("%d\n",ans);
}
```

---

## 作者：Link_Space (赞：5)

经典树形DP的变式，不知道大家有没有做过这样一道树形DP：一棵树上n个点，可以放置士兵，士兵可以看守到相邻的所有点，求使得每个点都被看守的最小放置士兵数。

先思考这种题该如何做：对于每个点有两种情况，当前点已被儿子节点看守，当前点未被儿子节点看守，如果未被儿子节点看守则必须放置士兵，然后树形DP求答即可。

而本题的不同就是士兵的看守距离扩大到了2，那我们上题中的对于某个点只判断两种情况显然就不可行了，但是我们可以根据相似的思路来做本题。

对于一个点来说，如果要使得这个点可以被看守，有多少种情况呢？可以得到有五种情况：当前点的祖先节点已被当前点看守，当前点的父亲节点已被当前点的儿子节点看守，当前点已被当前点的孙子节点看守，当前点的儿子节点已被当前点的儿子节点的孙子节点看守，当前点的孙子节点已被当前点的孙子节点的孙子节点看守（这里有点绕，请仔细理解）。

我们将这五种情况转化为状态 $dp[i][0-4]$ ,其中存的值为达成这种情况时用的最少的士兵数量

知道了状态之后，就考虑状态转移的问题

1. 对于 $dp[i][0]$ 来说，由于要覆盖到当前节点的祖先节点，所以就把士兵放在当前节点上，由于要使放置的士兵数量最少，那么我们就要使用一个贪心的思想：既然当前点已经放了士兵，那么当前点的儿子节点和孙子节点全部不用放士兵，所以由此可得转移方程 $dp[i][0]=$ $1+\sum$ $dp[j][4]$，其中j为i的儿子节点。

2. 那么对于 $dp[i][1]$ 呢？当前节点的父亲节点被看守，那么就是将士兵放在当前节点的儿子节点上，而儿子节点如果放了士兵，那么他的兄弟节点（即当前节点的其它儿子节点）也可以被看守，所以他的兄弟节点只需要保证自己的儿子节点被看守即可。那么就可以得到转移方程 $dp[i][1] = \sum_{min}$（$dp[j][0]+\sum dp[k][3]$），其中j为i的一个儿子，k为除这个儿子以外的其它儿子。

3. 相信你已经可以想到 $dp[i][2]$ 就是在当前节点的孙子节点上放置士兵了，则可以推出转移方程 $dp[i][2]=\sum_{min}$（$dp[j][1]+\sum dp[k][2]$）

同理可得 4.5转移方程

$dp[i][3]= \sum dp[j][2]$

$dp[i][4]= \sum dp[j][3]$

最终的答案即为 $dp[1][2]$

以下是代码，其中还有一些值得注意的点已经注释出来了

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 1e5 + 5;
int dp[N][5];
int head[N], ver[N], nxt[N], cnt;
void add(int x,int y)
{
    nxt[++cnt] = head[x];
    head[x] = cnt;
    ver[cnt] = y;
}
void dfs(int now,int father)
{
    int F3 = 0;
    int F2 = 0;//求出子节点的状态和，方便后面转移状态
    int son = 0;
    dp[now][0] = 1;
    for (int i = head[now]; i;i=nxt[i])
    {
        int v0=ver[i];
        if(v0==father)
            continue;
        dfs(v0, now);
        dp[now][0] += dp[v0][4];
        dp[now][3] += dp[v0][2];
        dp[now][4] += dp[v0][3];
        F2 += dp[v0][2];
        F3 += dp[v0][3];
        son++;//判断是否有儿子
    }
    if(!son)
    {
        dp[now][0] = dp[now][1] = dp[now][2] = 1;//如果该节点没有儿子节点，注意特判
        return;
    }
    dp[now][1] = dp[now][2] = 0x7fffffff;
    for (int i = head[now]; i;i=nxt[i])
    {
        int v0 = ver[i];
        if(v0==father)
            continue;
        dp[now][1] = min(dp[now][1], F3 - dp[v0][3] + dp[v0][0]);
        dp[now][2] = min(dp[now][2], F2 - dp[v0][2] + dp[v0][1]);
    }
    for (int i = 1; i <= 4;i++)
        dp[now][i] = min(dp[now][i], dp[now][i - 1]);//重要的一点：
     对于状态dp[i][x]来说，他是包含了dp[i][x+1]状态的，所以如果dp[i][x-1]的状态比dp[i][x]更优，则需要更新最优值
}
int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 2; i <= n;i++)
    {
        int a;
        scanf("%d", &a);
        add(i, a);
        add(a, i);
    }
    dfs(1, 0);
    printf("%d\n", dp[1][2]);
}
```


---

## 作者：tth37 (赞：4)

实际上就是[这道题](https://www.luogu.org/problem/P3267)的简化版。

首先定义状态。$f[u][4]$ 表示节点 $u$ 的二级祖先（父亲的父亲）及以下节点被完全覆盖，所需的最小代价。$f[u][3]$ 表示节点 $u$ 的一级祖先及以下节点被完全覆盖所需最小代价。以此类推， $f[u][0]$ 表示节点 $u$ 的二级儿子（儿子的儿子）及以下节点被完全覆盖所需的最小代价。

考虑 $f[u][4]$ 的推导。由于每个节点被选中后只能覆盖到与其距离小于等于二的节点，要使 $u$ 的二级祖先被覆盖到，则节点 $u$ 必须被选取。对节点 $u$ 的各个儿子没有要求。因此，$f[u][4]=1+\Sigma f[v][0...4]$ 。

考虑 $f[u][3]$。由于只需要覆盖到节点 $u$ 的父亲，只需使节点 $u$ 的**至少一个**子节点可以覆盖到其二级祖先即可。同时，该子节点在覆盖到节点 $u$ 的二级祖先时，可以同时覆盖到节点 $u$  的其他儿子，因此节点 $u$ 的其他儿子不必被覆盖。$f[u][3]=f[k][4]+\Sigma f[v][1...4]$。

$f[u][2]$ 的情况与 $f[u][3]$ 类似，只需保证一个儿子能将节点 $u$ 覆盖即可。 $f[u][2]=f[k][3]+\Sigma f[v][2...4]$ 。

$f[u][1]$ 与 $f[u][0]$ 的推导相对简单，因为各个子节点之间不会相互影响。 $f[u][1]=\Sigma f[v][2...4]$，$f[u][0]=\Sigma f[v][1...4]$。

对转移方程进行简单优化即可。代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> G[1005];
int N;
int f[1005][10];

void dp(int u, int fa) {
	f[u][3] = 0x3f3f3f3f;
	f[u][2] = 0x3f3f3f3f;
	f[u][4] = 1;
	for (vector<int>::iterator it = G[u].begin(); it != G[u].end(); it++) {
		int v = *it;
		if (v == fa) continue;
		dp(v, u);
		f[u][0] += f[v][1];
		f[u][1] += f[v][2];
		f[u][2] = min(f[u][2], f[v][3] - f[v][2]);
		f[u][3] = min(f[u][3], f[v][4] - f[v][1]);
		f[u][4] += f[v][0];
	}
	f[u][2] += f[u][1];
	f[u][3] += f[u][0];
	f[u][3] = min(f[u][3], f[u][4]);
	f[u][2] = min(f[u][2], f[u][3]);
	f[u][1] = min(f[u][1], f[u][2]);
	f[u][0] = min(f[u][0], f[u][1]);
	
	
}

int main() {
	scanf("%d", &N);
	for (register int u = 2; u <= N; ++u) {
		int v;
		scanf("%d", &v);
		G[u].push_back(v);
		G[v].push_back(u);	
	}
	dp(1, 0);
	printf("%d", f[1][2]);
	return 0;
}
```


---

## 作者：KagurazakaLorna (赞：4)

主要思路是贪心。

当前深度最大且未被覆盖的结点必须被覆盖。
为使一个消防站覆盖的结点尽量多，这个消防站应在该结点的父结点的父结点。

然后考虑程序怎么写。

假设1为根结点。
用fa[i]记录i结点的父结点，dep[i]记录i结点的深度。
由于题中说输入数据中a[i]<i，故令a[i]为i的父结点，i结点的深度是a[i]结点的深度+1。

vis[i]表示第i个结点是否被覆盖。
当结点没有被全部覆盖时，重复以下操作：

1、取出当前未被覆盖的结点中深度最大的

2、找到该结点父结点的父结点，记为pos，并覆盖。计数器+1

3、枚举所有结点中与pos结点距离不超过2的，并覆盖

下面贴程序：
```cpp
#include <bits/stdc++.h>
using namespace std;

int n,cut,ans;
bool vis[1003];
struct type {
	int dep,fa;
} nod[1003];

int main() {
	ios::sync_with_stdio(0);
	cin>>n;
	memset(vis,0,sizeof(vis));
	nod[1].fa=1; nod[1].dep=0;
	for (int i=2;i<=n;i++) {
		int x; cin>>x;
		nod[i].fa=x; nod[i].dep=nod[x].dep+1;
	}
	cut=ans=0; nod[0].dep=-1;	
	//cut表示当前已经被覆盖的结点数 ，ans表示消防站数量 
	while (cut<n) {
		int pos=0;
		for (int i=1;i<=n;i++) 
			if (!vis[i] && nod[i].dep>nod[pos].dep) pos=i;
		pos=nod[nod[pos].fa].fa;
		if (!vis[pos]) cut++;
		//注意！若pos已经被覆盖，cut不能重复加 
		ans++; vis[pos]=1;
		for (int i=1;i<=n;i++) 
			if (nod[i].fa==pos || nod[nod[i].fa].fa==pos || nod[pos].fa==i 
			   || nod[nod[pos].fa].fa==i || nod[i].fa==nod[pos].fa) {
			//上述5种情况，分别是：i是pos的子结点，i是pos子结点的子结点，pos是i的子结点，
			//pos是i子结点的子结点，i和pos是兄弟结点 
				if (!vis[i]) cut++;
				//注意！若pos已经被覆盖，cut不能重复加 
				vis[i]=1; 
			}
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：George1123 (赞：3)

[${\color{orange}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/wzc-wwwwd/)

此题的算法标签为：贪心、dfs，但我只用贪心就过了(~~用dp也可以~~）

# 思路
因为图中有$n$个点和$n-1$条边，所以这是一棵树，处理时处理单个节点就行了。

贪心思路：找最深的节点并在其祖父节点上建造消防局：

1.构造树的节点$i$

因为树节点要按深度$d$排序，所以要记录树节点的原编号$s$，以便查询其父亲节点$f[i]$、覆盖程度$p[i]$。

```cpp
struct node{
	int d,s;
}a[1010];
int n,ans,f[1010],p[1010];
```
${\color{red}\text{如果把\textit{f}、\textit{p}包装进结构体\textit{node}}}$，${\color{red}\text{父亲节点所对应的值便无法查询}}$

2.读入处理并排序

 $f[i]$只有$n-1$个，第一个节点的$s$要置成$1$

```cpp
bool cmp(node x,node y){
	return x.d>y.d;
} int main(){
	scanf("%d",&n);
	a[1].s=1;
	for(int i=2;i<=n;i++){
		scanf("%d",f+i);
		a[i].d=a[f[i]].d+1;
		a[i].s=i;
	} sort(a+1,a+n+1,cmp);
    
```

3.按照思路，建造消防局
不用dfs，不用树遍历：

$p[i]$=

3：消防局覆盖度；
2：消防局儿子父亲节点；
1：消防局孙子祖父节点；
0：消防局无法覆盖节点。

```cpp
for(int i=1;i<=n;i++){
	//(1)继承祖先节点覆盖
	p[a[i].s]=max(p[a[i].s],
	max(p[f[a[i].s]]-1,
	p[f[f[a[i].s]]]-2));
	//(2)如果当前节点未被覆盖，在其祖父节点上建造消防局
	if(!p[a[i].s]){
		ans++;
		//①覆盖祖父节点
		p[f[f[a[i].s]]]=3;
		//②覆盖父亲、当前节点
		p[f[a[i].s]]=2;
		p[a[i].s]=1;
		//③覆盖曾祖父、玄祖父
		p[f[f[f[a[i].s]]]]=
		max(p[f[f[f[a[i].s]]]],2);
		p[f[f[f[f[a[i].s]]]]]=
		max(p[f[f[f[f[a[i].s]]]]],1);
	}
}
```
然后这里的$ans$就是答案了。

## 以下是完整代码

```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	int d,s;
}a[1010];
int n,ans,f[1010],p[1010];
bool cmp(node x,node y){
	return x.d>y.d;
} int main(){
	scanf("%d",&n);
	a[1].s=1;
	for(int i=2;i<=n;i++){
		scanf("%d",f+i);
		a[i].d=a[f[i]].d+1;
		a[i].s=i;
	} sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		p[a[i].s]=max(p[a[i].s],
		max(p[f[a[i].s]]-1,
		p[f[f[a[i].s]]]-2));
		if(!p[a[i].s]){
			ans++;
			p[f[f[a[i].s]]]=3;
			p[f[a[i].s]]=2;
			p[a[i].s]=1;
			p[f[f[f[a[i].s]]]]=
			max(p[f[f[f[a[i].s]]]],2);
			p[f[f[f[f[a[i].s]]]]]=
			max(p[f[f[f[f[a[i].s]]]]],1);
		}
	} printf("%d\n",ans);         
	return 0;
} 
```
谢谢观看此题解的巨佬观众们！






---

## 作者：雄鹰展翅 (赞：2)

提供一种不同的贪心。

### 思路：

首先对于叶子结点，把消防站放在上面肯定不是最优的。

扩展到所有节点，如果这个点是 **最深的没有被覆盖的点** ，那么把消防站放在它的 **爷爷**（即父节点的父节点）上一定是最优的，因为这样可以覆盖到更多的点。

所以每次找到 **最深的没有被覆盖的点** ，把消防站放在它的 **爷爷** 上，再去更新哪些点被覆盖就行了。

### 做法：

预处理出每个点的深度，按深度从大到小访问。

设当前节点为 $w$ , $w$ 的父亲为 $v$ , $v$ 的父亲为 $u$ 。

一个点被其他点，覆盖有三种情况：

1. 被距离为$0$的点覆盖：消防站在 $w$ 上
2. 被距离为$1$的点覆盖：消防站在 $v$ 或 $w$ 的儿子上
3. 被距离为$2$的点覆盖：消防站在 $u$ 或 $w$ 的兄弟（$v$ 的儿子）或 $w$ 的孙子上

发现只需记录每个点 **自己/儿子/孙子** 是否有消防站即可。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1005
int n,ans,fa[N],b[N],d[N];
bool vis[N],vis2[N],vis3[N];//自己 儿子 孙子
bool cmp(int a,int b) {return d[a]>d[b];}
int main(){
	scanf("%d",&n),b[1]=1;//注意边界
	for(int i=2;i<=n;i++) scanf("%d",&fa[i]),d[i]=d[fa[i]]+1,b[i]=i;
	sort(b+1,b+n+1,cmp);
	
	for(int i=1;i<=n;i++){
		int w=b[i],v=fa[b[i]],u=fa[fa[b[i]]];
		if(!vis[w] && !vis[v]&&!vis2[w] && !vis[u]&&!vis2[v]&&!vis3[w])
			vis[u]=1,vis2[fa[u]]=1,vis3[fa[fa[u]]]=1,ans++;
	}
	
	cout<<ans<<endl;
	return 0;
}
```



---

## 作者：lndjy (赞：2)

来写一个和大家都不一样的做法。大家的做法仅限于m=2，当m更大时就不行了。我这个做法是当m为输入的数的时候也可以做。而且还是线性的，更快。做法来源于[这题](https://www.luogu.com.cn/problem/solution/P3523)

当两点的距离不超过2时，只要一个点有消防局，另一个点就会被覆盖。

我们设 $f_u$ 表示 $u$ 子树内距离 $u$ 最远的没有被 $u$ 覆盖的点的距离， $g_u$ 表示 $u$ 子树内最近选择节点的距离。

初始化 $f_u=-inf,g_u=inf$ ,可以得到转移：

$$f_u=\max\{f_v+1\}$$

$$g_u=\min\{g_v+1\}$$

当 $f_u+g_u\le m$ (此题为2）时，子树被完全覆盖，$f_u=-inf$.

当 $f_u=m$ ,选择这个点，覆盖了它的子树。$f_u=inf,g_u=0,tot++$.

当 $g_u>m$ ，目前无法覆盖，丢给它的父亲，$f_u=\max\{f_u,0\}$.

代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int inline read()
{
	int ans=0,f=1;
	char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-')
		f=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		ans=ans*10+ch-'0';
		ch=getchar();
	}
	return ans*f;
}
int n,m,ans,tot,cnt;
const int N=300005,inf=2e9;
struct edge
{
	int to,nxt;
}e[N*2];
int head[N],d[N],f[N],g[N];
void add(int u,int v)
{
	cnt++;
	e[cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
void dfs(int now,int fa,int x)
{
	f[now]=-inf;g[now]=inf;
	for(int i=head[now];i;i=e[i].nxt)
	{
		if(e[i].to!=fa)
		{
			dfs(e[i].to,now,x);
			f[now]=max(f[now],f[e[i].to]+1);
			g[now]=min(g[now],g[e[i].to]+1);
		}
	 } 
	 if(f[now]+g[now]<=x) f[now]=-inf;
	 if(g[now]>x) f[now]=max(f[now],0);
	 if(f[now]==x) f[now]=-inf,g[now]=0,tot++;
}
int main()
{
	n=read();m=2;
	for(int i=1;i<n;i++)
	{
		int a=read();
		add(a,i+1);
		add(i+1,a);
	}
    dfs(1,0,m);
    if(f[1]>=0) tot++;
	cout<<tot;
	return 0;
}
```


---

## 作者：like1 (赞：2)

本题是一道经典的最小点覆盖问题；一定要和最小边覆盖问题区分；

本题可以采用树形DP

首先，每个叶子节点都要被至少一个小队控制，

则贪心地放置小队，

放置之后没被覆盖的点跟属于控制范围的点无关，

又属于新的“叶子”，继续递归。

如何贪心地放置？

对于每一个点，我们求出离它最远的没被覆盖的点,

若距离超过k-它离最近的小队的距离,

则必定放置小队，

并把离它距离小于等于k的父亲标记，值为离它距离。


```
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;

const int N=1e5+5;
int First[2*N],Next[2*N],go[2*N],tot;
int rep[N],sum[N];
int n,m,x,y,ans;

inline void add(int u,int v)
{
	Next[++tot]=First[u]; First[u]=tot; go[tot]=v;
}

inline void dfs(int u,int fa)
{
	for(int i=First[u];i;i=Next[i])
	{
		int v=go[i];
		if(v==fa) continue;
		dfs(v,u);
		rep[u]=max(rep[u],rep[v]+1);
		sum[u]=max(sum[u],sum[v]-1);
	}
	rep[u]=max(rep[u],0);
	if(sum[u]>=rep[u]) rep[u]=-1;
	if(rep[u]==2)
	{
		sum[u]=2;
		rep[u]=-1;
		ans++;
	}
}

int main( )
{
	scanf("%d",&n); 
	for(int i=2;i<=n;i++)
	{
		scanf("%d",&x);
		add(i,x);
		add(x,i);
	}
	memset(rep,-1,sizeof(rep));
	memset(sum,-1,sizeof(sum));
	dfs(1,0);
	if(sum[1]>=rep[1]) rep[1]=-1;
	if(rep[1]!=-1) ans++;
	printf("%d\n",ans);
	return 0;
}
```

最后祝大家CSP2019rp++,score++;

---

## 作者：huiwang17 (赞：2)

这题真的是dp吗为什么我觉得~~贪心大法好~~
虽然数据比较水，但还是有几个要注意的点

1️⃣深度的确定

2️⃣$fa[1] = 1$， 否则就会在0号点修消防局惹啦！

3️⃣遍历两步的时候不需要考虑是祖先还是儿子还是孙子。直接辐射两步出去打好标记就好了。

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#include <stack>

using namespace std;
#define ll long long
const int MAXN = 5e5 + 7;
const int INF = 2.1e9;
const int mod = 1e9 + 7;

int n;
vector<int> a[1017];
int depth[1017];
int fa[1017];
bool ok[1017];

struct node{
    int id;
    node(int x){id = x;}
    node(){}
};

bool operator < (node n1, node n2){
    return depth[n1.id] < depth[n2.id];
}

priority_queue<node> q;

int main(){
    cin >> n;
    for(int i = 2; i <= n; i++){
        int x;
        cin >> x;
        a[x].push_back(i);
        a[i].push_back(x);
    }
    stack<int> s;
    s.push(1);
    depth[1] = 1;
    fa[1] = 1;
    while(!s.empty()){
        int top = s.top();
        s.pop();
        for(int i = 0; i < a[top].size(); i++){
            int nxt = a[top][i];
            if(depth[nxt]) continue;
            depth[nxt] = depth[top] + 1;
            fa[nxt] = top;
            s.push(nxt);
        }
    }
    for(int i = 1; i <= n; i++)
        q.push(node(i));
    int ans = 0;
    while(!q.empty()){
        int top = q.top().id;
        q.pop();
        if(ok[top]) continue;
        int grandfa = fa[fa[top]];
        ans ++;
        for(int i = 0; i < a[grandfa].size(); i++){
            int son = a[grandfa][i];
            ok[son] = 1;
            for(int j = 0; j < a[son].size(); j++){
                int gc = a[son][j];
                ok[gc] = 1;
            }
        }
    }
    cout << ans << endl;
}

```


---

## 作者：eros1on (赞：2)

[博客食用更佳](https://tle666.github.io/2019/06/18/[HNOI2003]%20%E6%B6%88%E9%98%B2%E5%B1%80%E7%9A%84%E8%AE%BE%E7%AB%8B/)

**UPD 2019.8.12**

感谢 @pqy000 dalao 的提醒，目前以改正。

# **Description**

一棵 $n$ 个结点的树，问最少几个特殊点能覆盖满整个图。

其中，一个特殊点能覆盖与它距离不超过 2 的所有点。

对于 $100\%$ 的数据，满足 $n \leq 1000$ 

[题目链接戳这里](https://www.luogu.org/problemnew/show/P2279)

# **Solution**

就是个大贪心。。

每次找到深度最大的未覆盖的结点，并贪心地在它祖父结点处放个消防站（即特殊点）。由于前提，所以这个点的所有子结点全部都被覆盖了。因此放在祖父结点处最优。

那么如何判断这个点是否被覆盖了呢？问题在于兄弟结点。其实，可以用 `dis` 数组维护距离一个特殊点的最短距离；此时当 `dis[fa] == 1` 时，就能确定它被覆盖了。

# **Code**

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;
const int INF = 0x3f3f3f3f;

int n, que[N], dep[N], fa[N], dis[N], ans;

inline bool cmp(int x, int y) { return dep[x] > dep[y];}

inline void upd(int u) {
  int f = fa[u], g = fa[f];
  dis[u] = min(dis[u], min(dis[f] + 1, dis[g] + 2));
  if (dis[u] > 2) {
    dis[g] = 0, ans++;
    dis[fa[g]] = min(dis[fa[g]], 1),
    dis[fa[fa[g]]] = min(dis[fa[fa[g]]], 2);
  }
}

int main() {
  scanf("%d", &n); dis[0] = INF;
  for (int i = 1; i <= n; i++) dis[i] = INF, que[i] = i;
  for (int i = 2; i <= n; i++) {
    scanf("%d", &fa[i]);
    dep[i] = dep[fa[i]] + 1;
    que[i] = i;
  }
  sort(que + 1, que + n + 1, cmp); // 按深度排序
  for (int i = 1; i <= n; i++) upd(que[i]);
  printf("%d\n", ans);
  return 0;
}
```



---

## 作者：大菜鸡fks (赞：2)

这题树形dp。

按照当前节点是否被覆盖分类， 用前缀最小值优化转移

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=1005;
struct edge{
	int link,next;
}e[N<<1];
int n,tot,head[N];
inline void add_edge(int u,int v){
	e[++tot]=(edge){v,head[u]}; head[u]=tot;
} 
inline void init(){
	scanf("%d",&n);
	for (int i=2;i<=n;i++){
		int u;
		scanf("%d",&u);
		add_edge(u,i);
	}
}
const int inf=1e9;
int dp[N][5],f[N][5];
void dfs(int u,int fa){
	for (int i=head[u];i;i=e[i].next){
		int v=e[i].link;
		if (v!=fa){
			dfs(v,u);
		}
	}
	int temp1=inf,temp2=inf;;
	for (int i=head[u];i;i=e[i].next){
		int v=e[i].link;
		if (v!=fa){
			dp[u][0]+=f[v][4];
			dp[u][1]+=f[v][3];
			dp[u][2]+=f[v][2];
			temp1=min(temp1,dp[v][0]-f[v][3]);
			temp2=min(temp2,dp[v][1]-f[v][2]);
			dp[u][3]+=f[v][2];
			dp[u][4]+=f[v][3];
		}
	}
	dp[u][0]++;
	dp[u][1]+=temp1;
	dp[u][2]+=temp2;
	f[u][0]=dp[u][0];
	for (int i=1;i<5;i++){
		f[u][i]=min(dp[u][i],f[u][i-1]);
	}
}
inline void solve(){
	dfs(1,0);
	printf("%d\n",f[1][2]);
}
int main(){
	init();
	solve();
	return 0;
}
```

---

## 作者：dogther (赞：2)

其实这道题可以贪心。对所有节点按深度从大到小排序，然后每次选出一个当前没有被覆盖过的最深的点，令它的爷爷作为消防站（可以证明这样一定最优，如果存在其他覆盖方案，那么覆盖它的点一定不会比它的爷爷的深度还低，同时它又是最深的未被覆盖的点，所以直接把覆盖他的点改成它的爷爷，一定不会使解变坏），然后更新与他距离为2以内的点即可，再顺着扫过去，找下一个没有被覆盖的最深节点，以此类推。时间复杂度O(nlgn)。（瓶颈在排序）


---

## 作者：Seauy (赞：1)

谁说贪心就只能是 $O(n\log n)$ 了……

用桶排就能 $O(n)$ 了

贪心策略之前的大佬都说得很清楚了，这里再简单复述一遍：每次取还没有被覆盖的最深结点，在他的爷爷处设置消防站

关于如何判断这个点被覆盖了……这里提供一个暴力一点的方法

检查一个结点的爸爸、爷爷、同属于爸爸的兄弟、儿子与孙子

爸爸、爷爷、儿子的判断就不用说了

同属于爸爸的兄弟如果被设置消防站了，则把他爸爸的 $Bro$ 数组标记成 1，如果当前结点爸爸的 $Bro$ 也是 1，那么就说明同属于爸爸的兄弟有被设置成消防站的

孙子的话，对于每个结点都开一个

```cpp
vector<int> Gds[MAXN+5];
```

来表示某个结点孙子的集合，然后爆扫孙子找有没有被设置成消防站的

这样做还是 $O(n)$ 的，因为代码写起来是这样的

```cpp
#define gf(x) fa[fa[x]]

for(int i=2;i<=n;i++)
{
	scanf("%d",&fa[i]);
	depth[i]=depth[fa[i]]+1;
	mapn[depth[i]].push_back(i);
	Son[fa[i]].push_back(i);
	Gds[gf(i)].push_back(i);
}
```

你能 $O(n)$ 地插入，就能 $O(n)$ 地爆扫

最后上代码：

```cpp
#include<bits/stdc++.h>
#define gf(x) fa[fa[x]]
using namespace std;

const int MAXN=1e3;

int n,fa[MAXN+5],depth[MAXN+5];
int ans;
vector<int> mapn[MAXN+5];
bool Bro[MAXN+5],Flag[MAXN+5];
vector<int> Son[MAXN+5],Gds[MAXN+5];

bool Check(int x)
{
	for(int i=0;i<Son[x].size();i++)
		if(Flag[Son[x][i]]) return 1;
	for(int i=0;i<Gds[x].size();i++)
		if(Flag[Gds[x][i]]) return 1;
	return 0;
}

int main()
{
	scanf("%d",&n);
	mapn[0].push_back(1);
	for(int i=2;i<=n;i++)
	{
		scanf("%d",&fa[i]);
		depth[i]=depth[fa[i]]+1;
		mapn[depth[i]].push_back(i);
		Son[fa[i]].push_back(i);
		Gds[gf(i)].push_back(i);
	}
	for(int i=n-1,now,Set;i>=0;i--)
		for(int j=0;j<mapn[i].size();j++)
		{
			now=mapn[i][j];
			if(Flag[now] || Flag[fa[now]] || Flag[gf(now)] || Bro[fa[now]] || Check(now)) continue;
			++ans;
			if(gf(now)) Set=gf(now);
			else if(fa[now]) Set=fa[now];
			else Set=now;
			Bro[fa[Set]]=Flag[Set]=1;
		}
	printf("%d\n",ans);
	return 0;
}
```

同是 $O(n)$ 贪心显然比动规好想一些，只是如果带权了的话可能会GG……

---

## 作者：_Sein (赞：1)

$f_{i,0}$表示$i$本身被覆盖，

$f_{i,1}$表示$i$至少有一个儿子被覆盖，

$f_{i,2}$表示$i$至少有一个孙子被覆盖，

$f_{i,3}$表示$i$所有儿子被覆盖，

$f_{i,4}$表示$i$所有孙子被覆盖。

转移方程为:($j,k$均为$i$的儿子)

$\begin{cases}f_{i,0}=1+\sum\limits_{j}\min\{f_{j,0~ to ~4}\}\\f_{i,1}=\min\{f_{k,0}+\sum\limits_{j\ne k}\min\{f_{j,0 ~to~3}\}\}\\f_{i,2}=\min\{f_{k,1}+\sum\limits_{j\ne k}\min\{f_{j,0 ~to~2}\}\}\\f_{i,3}=\sum f_{j,2}\\f_{i,4}=\sum f_{j,3}\end{cases}$

令$f_{i,k}(k\ge 2)=\min\{f_{i,0~to~k}\}$进行优化

$\begin{cases}f_{i,0}=1+\sum\limits_{j}f_{j,4}\\f_{i,1}=f_{i,4}+\min\{f_{k,0}-f_{k,3}\}\\f_{i,2}=f_{i,3}+\min\{f_{k,1}-f_{k,2}\}\\f_{i,3}=\sum f_{j,2}\\f_{i,4}=\sum f_{j,3}\end{cases}$

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#define ll long long
#define gc getchar()
using namespace std;
const int N=1e3+5;
inline void qr(int &x)
{
	x=0;char c=gc;
	while(c<'0'||c>'9')c=gc;
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
}
void qw(int x)
{
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
struct edge{int y,next;}a[N<<1];int len,last[N];
void ins(int x,int y){a[++len]=(edge){y,last[x]};last[x]=len;}
int f[N][5];
void dfs(int x)
{
	int s4=0,s3=0,s2=0,x1=9999999,x2=9999999;
	for(int k=last[x];k;k=a[k].next)
	{
		int y=a[k].y;
		dfs(y);
		x1=min(x1,f[y][0]-f[y][3]);x2=min(x2,f[y][1]-f[y][2]);
		s4+=f[y][4];s3+=f[y][3];s2+=f[y][2];
	}
	f[x][0]=s4+1;f[x][1]=s3+x1;
	f[x][2]=s2+x2;f[x][3]=s2;
	f[x][4]=s3;
	f[x][2]=min(f[x][2],min(f[x][1],f[x][0]));
	f[x][3]=min(f[x][2],f[x][3]);
	f[x][4]=min(f[x][3],f[x][4]);
}
int main()
{
	int n;qr(n);
	for(int i=2,x;i<=n;i++)
	{
		qr(x);ins(x,i);
	}
	dfs(1);
	qw(f[1][2]);puts("");
	return 0;
}
```

---

## 作者：MILLOPE (赞：1)

## 题目
>题目描述
>2020年，人类在火星上建立了一个庞大的基地群，总共有n个基地。起初为了节约材料，人类只修建了n-1条道路来连接这些基地，并且每两个基地都能够通过道路到达，所以所有的基地形成了一个巨大的树状结构。如果基地A到基地B至少要经过d条道路的话，我们称基地A到基地B的距离为d。
由于火星上非常干燥，经常引发火灾，人类决定在火星上修建若干个消防局。消防局只能修建在基地里，每个消防局有能力扑灭与它距离不超过2的基地的火灾。
你的任务是计算至少要修建多少个消防局才能够确保火星上所有的基地在发生火灾时，消防队有能力及时扑灭火灾。
输入输出格式
输入格式：
输入文件名为input.txt。
输入文件的第一行为n （n<=1000），表示火星上基地的数目。接下来的n-1行每行有一个正整数，其中文件第i行的正整数为a[i]，表示从编号为i的基地到编号为a[i]的基地之间有一条道路，为了更加简洁的描述树状结构的基地群，有a[i]<i。
输出格式：
输出文件名为output.txt
输出文件仅有一个正整数，表示至少要设立多少个消防局才有能力及时扑灭任何基地发生的火灾。
输入输出样例
输入样例#1：
6
1
2
3
4
5
输出样例#1：
2

## 题解
- 总体思路：贪心 + 图的遍历 +搜索。
- 我们可以先预处理出每个节点的深度，然后按照深度大小进行排序，求深度的过程我们可以用$bfs$，而在$bfs$的过程中我们可以开一个栈，我们的遍历顺序是从上向下的，即我们先遍历的是深度小的。
- 那么栈又是一个先进后出的数据结构，那么我们在把遍历到的节点加入栈时栈顶的元素是深度最大的节点的编号，这样就省去了我们排序的过程。
- 接着我们枚举栈中的每个节点，从节点的爷爷节点开始往下搜索即可。（因为爷爷节点到此节点的深度为2，符合题目要求。）

## code

```cpp
#include <bits/stdc++.h>
const int maxn = 1e3 + 100;
const int inf = 0x3f3f3f3f;
typedef long long LL;
using namespace std;

template <typename T>
inline void read(T &s) {
    s = 0;
    T w = 1, ch = getchar();
    while (!isdigit(ch)) { if (ch == '-') w = -1; ch = getchar(); }
    while (isdigit(ch))  { s = (s << 1) + (s << 3) + (ch ^ 48); ch = getchar(); }
    s *= w;
}

template<typename T>
inline void write(T s) {
	if (s < 0) putchar('-'), s = -s;
	if (s > 9) write(s / 10);
	putchar(s % 10 + '0');
}

int n;
int tot;
int ans;
int fa[maxn];
int lin[maxn];
int dep[maxn];
int nex[maxn << 1];
int ver[maxn << 1];
bool vis[maxn];
queue <int> q;
stack <int> s;

inline void add(int from, int to) {
	ver[++tot] = to;
	nex[tot] = lin[from];
	lin[from] = tot;
}

void bfs(int k) {
	q.push(k);
	s.push(k);
	dep[k] = 1;
	while (!q.empty()) {
		int u = q.front(); q.pop();
		for (int i = lin[u]; i; i = nex[i]) {
			int v = ver[i];
			if (v == fa[u]) continue;
			dep[v] = dep[u] + 1;
			q.push(v);
			s.push(v);
		}
	}
}

void dfs(int now, int depth) {
	if (depth > 2) return ;
	vis[now] = true;
	for (int i = lin[now]; i; i = nex[i]) {
		int v = ver[i];
		dfs(v, depth + 1); 
	}
}

void work() {
	while (!s.empty()) {
		int u = s.top(); s.pop();
		if (!vis[u]) {
			dfs(fa[ fa[u] ], 0);
			++ans;
		}
	}
}

int main() {
	read(n);
	for (int i = 2; i <= n; ++i) {
		read(fa[i]);
		add(i, fa[i]);
		add(fa[i], i);
	}
	bfs(1);
	work();
	write(ans);
	return 0;
}

```



---

## 作者：7KByte (赞：1)

个人做法比较正$(xuan)$常$(xue)$    
依旧是贪心思想，每次找最深的没有被覆盖的点然后建立一个消防局在他的爷爷上，没有爷爷建在爸爸上，没有爸爸就建在自己这里  


各位大佬都是$O(N^2)$，先dfs找最深的节点，然后再dfs去覆盖和寻找自己是否被覆盖  
我们可以将这个贪心优化到$O(Nlog_2N)$  


首先题中给了提示信息$a_i<i$，看似没有什么用，但这句话告诉我们，节点1一定是根节点，$a_i$一定是$i$的父亲，所以我们就不用建图然后去做~~万恶的~~$DFS$  
开一个结构题保存每个节点，需要以下元素：  
- $Father$，记录其父节点  
- $Dist$，记录其深度
- $Visit$，记录该节点是否建立消防局
- $OK$，记录改节点是否能被其子孙覆盖(不包括其爷爷和爸爸  

$OK$可能比较难理解，为什么这么做：如果我们知道一个节点，那么我们很容易知道它能覆盖到的祖先，就是它的爸爸和爷爷，但我们如果要知道它覆盖的子孙，那我们就需要复杂的$DFS$，所以我们用$OK$记录它能否被子孙覆盖，这样在判断这个点是否被覆盖时就不用$DFS$它的后代了  


一个节点被覆盖的判定条件  
- 它自己或它的爷爷或爸爸的$Visit$为$True$
- 它自己的$OK$为$True$  
- 还有一种特殊的情况
![](https://cdn.luogu.com.cn/upload/pic/50424.png)  
- 同为一个节点的儿子，其中一个儿子建有消防局，那么它的所有儿子都被覆盖了  
- 所以我们$OK$不再记录是否被覆盖，而是记录更多信息，1表示被孙子覆盖，2表示被儿子覆盖
- 它爸爸的$OK$为2  
```cpp
if(a[a[i].fa].ok==2||a[i].ok||a[i].vis||a[a[i].fa].vis||a[a[a[i].fa].fa].vis)
```   
- 判断没有被覆盖就是刚好反过来


覆盖了一个点后  
- 将它的$Visit$置为$True$  
- 将它的爸爸的$OK$置为2
- 将它的爷爷的$OK$置为1
- 注意一下：没有爷爷选爸爸，也没有爸爸选自己


覆盖一个点记得累加答案即可  
Dist深度可以在读入的时候同步求出  
时间复杂度的瓶颈在于对深度进行排序，后面的判断和覆盖都是$O(1)$的复杂度，尽管常数大  
总的时间复杂度$O(Nlog_2N+N)=O(Nlog_2N)$

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int fa;
	int d,vis,ok;
	node(){
		d=vis=fa=ok=0;
	}
}a[1005];
struct f{
	int d,now;
}sor[1005];
int n;
bool cmp(f x,f y){return x.d>y.d;}
int main()
{
	scanf("%d",&n);
	sor[1].d=a[1].d=1;
	sor[1].now=1;
	for(int i=2;i<=n;i++){
		int x;
		scanf("%d",&x);
		a[i].d=a[x].d+1;
		a[i].fa=x;
		sor[i].now=i;
		sor[i].d=a[i].d;
	}
	sort(sor+1,sor+n+1,cmp);
	int ans=0;
	for(int j=1;j<=n;j++){
		int i=sor[j].now;
		if(a[a[i].fa].ok!=2&&!a[i].ok&&!a[i].vis&&!a[a[i].fa].vis&&!a[a[a[i].fa].fa].vis){
			ans++;
			if(a[a[i].fa].fa){
				a[a[a[i].fa].fa].vis=1;
				a[a[a[a[a[i].fa].fa].fa].fa].ok=1;
				a[a[a[a[i].fa].fa].fa].ok=2;
			}
			else if(a[i].fa){
				a[a[i].fa].vis=1;
				a[a[a[i].fa].fa].ok=2;
			}
			else a[i].vis=1;
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：differential (赞：1)

这道题可以推广到以下情形：
 给出一棵树，在节点上放置哨兵，每个哨兵可以管理到距离它不超过$k$的节点，求最少放置多少哨兵可以管理完整棵树。
 - 贪心地来考虑，对于叶子节点，在其从下往上数第$k$个祖先上放哨兵是最优的。
   - 定义从$u$节点（向上）走$f[u][0]$步需要放置哨兵，定义已放置的哨兵可管理到$u$节点（向上）走$f[u][1]$步的节点，对于叶子节点，$f[u][0]=k.$
     - 令$v$为$u$的儿子，则：
       - $f[v][0]\ne 0$时，$f[u][0]=min(f[u][0],f[v][1]?inf:f[v][0]-1)$  
  //$f[v][1]$存在时可"消耗"$f[v][1]$,不需要对其计算$f[u][0]$，否则$v$向上走一步，$f[u][0]=f[v][0]-1$;
       - $f[v][0]=0$时，表明$v$点放置了哨兵,置$f[u][1]$为$k$。
       - $f[u][1]=max(f[u][1],f[v][1]-1);$
       - 当$f[u][0]=0$时,$ans+1。$
       - **当$f[u][0]+f[u][1]\le k$时，表明已放置的哨兵无法管理到$u$的某个儿子，此时置$f[u][1]$为$0$。**
 - 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
#define re register int
#define rec(i,j,k) for(re (i)=(j);(i)<=(k);(i)++)
#define mem(s,k) memset(s,(k),sizeof s)
typedef long long LL;
const int maxn=1000+1,inf=1e9;
int n;
struct node
{
	int v,to;
}e[maxn];
int num,head[maxn];
inline void add(int u,int v)
{
	e[num]=(node){v,head[u]};
	head[u]=num++;
}
int f[maxn][2],cnt,lim=2;//lim为可管理距离，cnt为放置消防站数量。 
void dfs(int u)
{
	int v;
	for(re i=head[u];i>-1;i=e[i].to)
	{
		dfs(v=e[i].v);
		f[v][0] ? (f[u][0]=min(f[u][0],f[v][1]?inf:f[v][0]-1)):f[u][1]=lim;
		f[u][1]=max(f[u][1],f[v][1]-1);
	}
	((!f[u][0])&&(cnt++))||((!f[u][1])&&(f[u][0]=min(f[u][0],lim)));
	((f[u][0]+f[u][1]<=lim)&&(f[u][1]=0));
}
int slove()
{
	rec(i,1,n)f[i][f[i][1]=0]=inf;
	dfs(1);
	(f[1][0]&&(f[1][0]+f[1][1]<=lim)&&(cnt++));//判断根节点是否需要放置消防站。 
	return cnt;
}
int main()
{
  int u;
  scanf("%d",&n);
  mem(head,-1);
  rec(i,2,n)
  {
  	scanf("%d",&u);
  	add(u,i);
  }
  printf("%d",slove());
  return 0;
}
```
- 该算法是正确的，但由于我wa了很多遍，所以我不确定最后AC的这份代码的实现有没有问题（虽然没有对拍出来），附上对拍程序：

- 对拍代码： 
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<ctime>
using namespace std;
#define re register int
#define rec(i,j,k) for(re (i)=(j);(i)<=(k);(i)++)
#define mem(s,k) memset(s,(k),sizeof s)
#define LL long long
const int mod=2e5-5;
template <class T_out> void pt(T_out X)
{
	if(X<0){putchar('-');X=-X;}
	if(X>9)pt(X/10);
	putchar(X%10+'0');
}
int main()
{
  srand(time(0));
  int n=mod;
  pt(n);
  putchar('\n');
  rec(i,2,n)
  { 
  	pt(rand()%(i-1)+1);
  	putchar('\n');
  }
  return 0;
}
```

- 另外一种实现方式（我对拍用的std）：  

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int read(){
	char ch;int op=1;
	while((ch=getchar())<'0'||ch>'9') if(ch=='-') op=-1;
	int ret=ch-'0';
	while((ch=getchar())>='0'&&ch<='9') ret=ret*10+ch-'0';
	return ret*op;
}
const int N=200000+10;
const int inf=0x3f3f3f3f;
int n,kk,k=2,cnt;
int head[N],dp[N];

struct edge{
	int v,nxt;
}e[N<<1];
void adde(int u,int v){
	e[kk].v=v;
	e[kk].nxt=head[u];
	head[u]=kk++;
}

void dfs(int u,int fa){
	int tmp=0,flg=-inf;
	for(int i=head[u];i!=-1;i=e[i].nxt){
		int v=e[i].v;
		if(v!=fa){
			++tmp;
			dfs(v,u);
			if(dp[v]>0)	dp[u]=min(dp[u],dp[v]-1);
			else 	flg=max(flg,dp[v]);
		}
	}
	if(!tmp) dp[u]=k;
	else if(!dp[u])	++cnt;
	if(flg!=-inf){
		if(dp[u]==inf) dp[u]=k;
		if(flg+dp[u]>0) dp[u]=flg-1;
	}
}
int slove(){//!!
	for(int i=1;i<=n;++i) 
		dp[i]=inf;
	cnt=0;
	dfs(1,0);
	if(dp[1]>0) cnt++;
	return cnt;
}
int a;
int main(){
	memset(head,-1,sizeof(head));
	n=read();
	for(int i=2;i<=n;i++){
		a=read();
		adde(a,i);
	}
	printf("%d",slove());
	return 0;
}
```

---

## 作者：hrbust_liu (赞：1)

感觉这题根本不用DP，只需要一个DFS即可   
返回值分为-2 -1 0 1 2   
0：子节点及以下都有消防局（不能为该节点提供消防局，但也不用依靠该节点  
1：子节点及以下最远需要消防局的距离是1（需要该节点或附近节点提供消防局  
2：子节点及以下最远需要消防局的距离是2（需要该节点提供消防局  
-1：子节点及以下能提供最远的消防局距离是1（也就是能为该节点提供消防局  
-2：子节点及以下能提供最远的消防局距离是2（其实就是该子节点是一个消防局


```c
#include<stdio.h>
#include<string.h>
#include<vector>
#include<algorithm>
using namespace std;
#define rep(i,j,k) for(int i=j;i<=k;++i)
#define per(i,j,k) for(int i=j;i>=k;--i)
#define M 1000000007
#define MAXN 1005
vector<int>G[MAXN];
bool vis[MAXN];
int dfs(int x)
{
    int ma=0,z,zz,mi=0;
    for(int i=0; i<G[x].size(); ++i)
    {
        z=G[x][i];
        zz=dfs(z);
        ma=max(ma,zz);
        mi=min(mi,zz);
    }
    if(ma==2)
    {
        vis[x]=true;
        return -2;
    }
    else if(mi==-2)
         return -1;
    else if(ma==1)
        return 2;
    else if(mi==-1)
        return 0;
    else
        return 1;
}
int main()
{
    int n;
    scanf("%d",&n);
    if(n==1)
    {
        printf("1\n");
       return 0;
    }
    G[1].clear();
    int z;
    rep(i,2,n)
    {
        G[i].clear();
        scanf("%d",&z);
        G[z].push_back(i);
    }
    memset(vis,false,sizeof(vis));
    z=dfs(1);
    int ans=0;
    z--;
    if(z>0)
        ans++;
    rep(i,1,n)
    if(vis[i])
        ans++;
    printf("%d\n",ans);
}

```

---

## 作者：Ghost_lzy (赞：1)

若要使点全部被覆盖，那么那些深度最大的节点是一定被覆盖到的，这个就是我们入手点。先将有根树转成无根树，那么接下来我们考虑深度最大的点，一般的，对于深度最大的结点u,选择u的k级祖先是最划算的（意思是说这个题目的2改成了k我们都是可以做的，至于这个结论，详见刘汝佳的《***入门经典》（蓝书P35），还有一个例题，不过和本题不一样），有了这个结论后，我们就可以顺理成章地开始贪心啦！（从深度最大的开始贪心，这样防止漏解和错解），其余的基本操作详见代码。（特别提醒！如果节点深度<=k,那么就直接选择整个树的root，所以有个fa[1]=1）

```cpp
#include<bits/stdc++.h>
#define m(x) memset(x,0,sizeof(x))
using namespace std;
struct sd{
    int id,d;
};
sd e[1005];
int n;
vector<int>G[1005];
int dep[1005],fa[1005];
bool vis[1005];
int ans=0;
void dfs(int v,int f)
{
    for(int i=G[v].size()-1;i>=0;i--)
    {
        int k=G[v][i];
        if(k!=f)
        {
           dep[k]=dep[v]+1;
           fa[k]=v;
           dfs(k,v);
        }
    }
}
bool cmp(sd v1,sd v2)
{
    return v1.d>v2.d;
}
void find(int v,int f,int rest)
{
    if(!rest) return;
    for(int i=G[v].size()-1;i>=0;i--)
    {
        int k=G[v][i];
        if(k!=f)
        {
           vis[k]=true;
           find(k,v,rest-1);
        }
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=2;i<=n;i++)
    {  int a;
        scanf("%d",&a);
        G[i].push_back(a);
        G[a].push_back(i);
    }
    dep[1]=0;
    dfs(1,0);
    for(int i=1;i<=n;i++)
    {
        e[i].d=dep[i];
        e[i].id=i;
    }
    sort(e+1,e+1+n,cmp);
   fa[1]=1;
    for(int i=1;i<=n;i++)
    {
        int k=e[i].id;
        if(!vis[k])
        {   
            int g=fa[fa[k]];
            vis[g]=true;
            find(g,0,2);
            ans++;
        }
    }
    cout<<ans;
}
```

---

## 作者：mike_he (赞：1)

1、这道题感到棘手的同学可以先尝试解决UVA1218(Perfect Service)。

2、这题就是UVA1218的一个扩展——孙子也可以被管到，因此多出了几个状态（如1楼所述）

3、这题没人用dp做..所以放一个dp题解

[codec]



```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <vector>
using namespace std;
#define MAXN 0x3f3f3f3f
int g[1001][1001];
int dp[1001][5];
inline void init(){
    memset(g,0,sizeof(g));
}
inline void add(int u,int v){
    g[u][v]=1;
}
inline int MIN(int x,int y){
    return x>y?y:x;
}
int main(){
    int N;
    cin>>N;
    int v;
    memset(g,0,sizeof(g));
    for(int i=2;i<=N;++i){
        cin>>v;
        add(v,i);
    }
    int m,n;
    for(int i=N;i>=1;--i){
        dp[i][0]=1;
        m=n=MAXN;
        for(int v=1;v<=N;++v){
            if(g[i][v]==1){
                dp[i][3]+=dp[v][2];
                dp[i][0]+=dp[v][4];
                dp[i][4]+=dp[v][3];
                m=MIN(m,dp[v][0]-dp[v][3]);
                n=MIN(n,dp[v][1]-dp[v][2]);
            }
        }
        dp[i][1]=dp[i][4]+m;
        dp[i][2]=MIN(MIN(dp[i][1],dp[i][0]),dp[i][3]+n);
        dp[i][3]=MIN(dp[i][3],dp[i][2]);
        dp[i][4]=MIN(dp[i][3],dp[i][4]);
    }
    cout<<dp[1][2];
    return 0;
}
[/codec]
```

---

## 作者：CangMing (赞：1)

[传送门](https://www.luogu.org/problem/P2279)

题目大意：

 _~~你好，小学生都会的.~~_ 
 
 
首先尝试 **树形DP** ,

用 $f_{i,{0/1}}$ 表示第$i$号基地 是$_ {1}$否$_ {0}$设立消防局.

考虑转移$……$ 好的，$awsl$  _~~去世~~_.

开始手玩.

发现如下性质：

对于任意一个不在消防局救火范围内的节点，在其祖父节点设立消防局 **不会差** .

其实很好想，如果可以的话，在深度越小的点设立消防局，可以影响到更多的节点.（儿子+孙子）

关于 **不会差** 的部分，~~是我不会证明，以及可能存在其他的最优方案~~.

如果这样的话，贪心可做.但是要注意的是，上文提到的 **如果可以的话**是一个巨大的坑.

如果考虑使用 $dfs$ 递归遍历树求解 但是存在问题.

$Input:$

5

1 1 3 4

并且先遍历了节点2. 按照贪心$+dfs$,答案会是2,选择了1和(5/4).但是显然选择3是最优的.

$dfs$遍历树的前提是 **选定根节点** 但是显然这道题其实是一棵无根树.

因为道路是 **双向的**. 就这一点而言，上文中提到的，对于一个设立消防局的节点, 其会覆盖的不仅是儿子和孙子，还有父亲，祖父，以及父亲的所有儿子.

因为最开始没有考虑到这点，导致蒟蒟 $got$ $double$ $WA$. （虽然我是用$bfs$ 写的）

所以事实上，如果要贪心，那么应该将这棵树画成  _~~菊花图~~_ 的亚子. 然后从外向内贪心.好麻烦的亚子，有没有更简便的做法呢？

还是考虑以1为根，菊花图中外面的点 $\Leftrightarrow$ 有根树中深度大的点

于是乎，我们只要从 深度大的点 $\rightarrow$ 深度小的点 就能保证贪心的正确性.

参考 [这篇题解](https://www.luogu.org/blog/starcity/solution-p2279) 中关于深度降序的优化.使用 $bfs+stack$保证了点的遍历一定是深度由大到小的.

```cpp
void bfs()//bfs保证点的深度从大到小
{
	q.push(1);
	while(!q.empty())
	{
		int now=q.front();
		st.push(now);q.pop();
		for(int i=head[now],go;go=edge[i],i;i=nxt[i])
			q.push(go);
	}
}
void solve()
{
	while(!st.empty())//从大到小遍历点
	{
		int now=st.top();st.pop();
		if(dis[now]<inf)//被覆盖在救火范围内
			continue;
		int fa=pre[now],gr=pre[fa];//向上走2步
		if(!is[fa]&&dis[fa]>1)//父亲不是消防局or覆盖的父亲消防局无法覆盖当前节点
		{
			if(!is[gr])//祖父不是消防局
			{
				++ans,is[gr]=1,dis[gr]=0;//在祖父设立消防局 更新数组
				int fgr=pre[gr],grgr=pre[fgr];//祖父向上走2步
				dis[fgr]=1,dis[grgr]=2;//更新数组
			}
			dis[fa]=1;//祖父必为消防局且此时更近
		}
		dis[now]=dis[fa]+1;//更新本身
	}
}
```
在原题解中是用 $dfs$实现覆盖的，这里然后改成了蒟蒟自己的想法.

$is[i]$ 表示第$i$号节点是否设立消防局.

$dis[i]$ 表示距离第$i$号节点距离最近消防局的距离.

$pre[i]$ 表示距离第$i$号节点的父亲.

由于本题的特殊性($r=2$)，对于 $dis[i]$可以不用取min.

(~~虽然好像  $r\neq 2$ 也可以不用，但是不重要~~ )

以下是完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5,inf=0x7f7f7f7f;
int n,pre[N],dis[N]={inf,inf},ans;
bool is[N];
int tot,head[N],edge[N],nxt[N];
queue<int>q;
stack<int>st;
inline int read()
{
	int f=0,num;char ch;
	while(ch=getchar(),!isdigit(ch)) if(ch=='-') f=1;num=ch-'0';
	while(ch=getchar(), isdigit(ch)) num=num*10+ch-'0';
	return f?-num:num;
}
inline void add(int x,int y){edge[++tot]=y,nxt[tot]=head[x],head[x]=tot;}
void bfs()
{
	q.push(1);
	while(!q.empty())
	{
		int now=q.front();
		st.push(now);q.pop();
		for(int i=head[now],go;go=edge[i],i;i=nxt[i])
			q.push(go);
	}
}
void solve()
{
	while(!st.empty())
	{
		int now=st.top();st.pop();
		if(dis[now]<inf)
			continue;
		int fa=pre[now],gr=pre[fa];
		if(!is[fa]&&dis[fa]>1)
		{
			if(!is[gr])
			{
				++ans,is[gr]=1,dis[gr]=0;
				int fgr=pre[gr],grgr=pre[fgr];
				dis[fgr]=1,dis[grgr]=2;
			}
			dis[fa]=1;
		}
		dis[now]=dis[fa]+1;
	}
}
int main()
{
	n=read();
	for(int i=2;i<=n;i++)
		dis[i]=inf,pre[i]=read(),add(pre[i],i);
	bfs();solve();
	printf("%d",ans);
	return 0;
}
```

$over$.

---

## 作者：_wkjzyc (赞：1)

### 题意

给出一个树，一个消防站能够覆盖与他距离小于2的点。

求覆盖整个树需要多少个消防站。

### 分析

有贪心思路和动规思路，这篇题解使用动规。

所以按照树形DP的常规套路，我们把一棵子树的状态作为一个划分状态的标准。但是一个子树可能还可以向外覆盖点，也有可能有几个点没覆盖。

由于覆盖半径是2，对于一棵子树划分5种状态：

$f_{i,0}$向上覆盖2个。

$f_{i,1}$向上覆盖1个。

$f_{i,2}$正好覆盖完子树。

$f_{i,3}$覆盖完儿子。

$f_{i,4}$覆盖完孙子。

需要的消防局数目。

------

$f_{i,0}$选了自己，所以孙子会被覆盖到。要求曾孙全部被覆盖，儿子0-4的状态都满足。

$$f_{i,0}=1+\min(f_{i.child,[0,4]})$$

$f_{i,1}$选了儿子中的一个节点，所以其他儿子也会被覆盖到。但是其他儿子的儿子 无法被覆盖到。所以在转移时，随机选取一个点放消防站，并要求其他点的儿子被覆盖到。

$$f_{i,1}=\min(\min (f_{i.child,[0,3]})_{i.child!=k}+f_{k,0} )_{k\in \{i.child\}}$$

同理有

$$f_{i,2}=\min(\min (f_{i.child,[0,2]})_{i.child!=k}+f_{k,1} )_{k\in \{i.child\}}$$

要让根节点的儿子都被覆盖，就是让它们本身都覆盖（好zz啊）

$$f_{i,3}=\sum(f_{i.child,[0,2]})$$

同理有

$$f_{i,4}=\sum(f_{i.child,[0,3]})$$

### 加速

取[0,2]的最小值，就是覆盖自身时的答案。

对于状态0，[0,4]中显然4最优

$$f_{i,0}=1+\min(f_{i.child,4})$$

同理有

$$f_{i,3}=\sum(f_{i.child,2})$$

$$f_{i,4}=\sum(f_{i.child,3})$$

此时0，3和4的状态处理完成，可以利用它们优化1和2的转移。

状态1，可以让所有孙子被覆盖，然后取$f_{i.child,0}-f_{i.child,3}$的最小值。这个式子相当于覆盖与i相邻的点需要的消防站数目。

所以有

$$f_{i,1}=\min (f_{i.child,0}-f_{i.child,3})+f_{i,4}$$

同理有

$$f_{i,2}=\min (f_{i.child,2}-f_{i.child,1})+f_{i,3}$$

#### 最后，你会发现还是贪心好用

#### (



### 代码

别看了，很丑，还是抄的。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int MAXN=1005;
int n,ne,head[MAXN],cnt,temp,temp1,temp2;
int f[MAXN][5];
bool tree[MAXN][MAXN];

int main()
{
	scanf("%d",&n);
	
	for(int i=2;i<=n;i++)
	{
		int x;
		scanf("%d",&x);
		tree[x][i]=1;
	}
	for(int i=n;i>=1;i--)
	{
		f[i][0]=1;
		temp1=1919,temp2=1919;
		for(int p=1;p<=n;p++)
		{
			if(tree[i][p])
			{
				f[i][3]+=f[p][2];
				f[i][4]+=f[p][3];
				f[i][0]+=f[p][4];
				temp1=min(temp1,f[p][0]-f[p][3]);
				temp2=min(temp2,f[p][1]-f[p][2]);
			}
		}
		f[i][1]=f[i][4]+temp1;
		f[i][2]=min(f[i][3]+temp2,min(f[i][0],f[i][1]));
		f[i][3]=min(f[i][2],f[i][3]);
		f[i][4]=min(f[i][4],f[i][3]);;
	}
	printf("%d",f[1][2]);
	return 0;
}
```

---

## 作者：smoothset (赞：0)

# [HNOI2003]消防局的设立 题解
## 题目描述 
2020年，人类在火星上建立了一个庞大的基地群，总共有n个基地。起初为了节约材料，人类只修建了n-1条道路来连接这些基地，并且每两个基地都能够通过道路到达，所以所有的基地形成了一个巨大的树状结构。如果基地A到基地B至少要经过d条道路的话，我们称基地A到基地B的距离为d。
由于火星上非常干燥，经常引发火灾，人类决定在火星上修建若干个消防局。消防局只能修建在基地里，每个消防局有能力扑灭与它距离不超过2的基地的火灾。
你的任务是计算至少要修建多少个消防局才能够确保火星上所有的基地在发生火灾时，消防队有能力及时扑灭火灾。
## 输入格式 
输入文件的第一行为n （n<=1000），表示火星上基地的数目。接下来的n-1行每行有一个正整数，其中文件第i行的正整数为a[i]，表示从编号为i的基地到编号为a[i]的基地之间有一条道路，为了更加简洁的描述树状结构的基地群，有a[i]<i。
## 输出格式 
输出文件仅有一个正整数，表示至少要设立多少个消防局才有能力及时扑灭任何基地发生的火灾。
## 样例
### input:
6
1
2
3
4
5
### output
2


____

## 样例分析：
我们用样例进行分析
如图：
![六个点的单链](https://img-blog.csdnimg.cn/20191022202326496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTM3MDcw,size_16,color_FFFFFF,t_70)

可以想到，当消防局在1和4时可满足条件，此时答案为2

([**推荐一个网址，画图贼棒**](https://csacademy.com/app/graph_editor/))
____
## 思路
分析了样例后，这个题到底该怎么来做呢？
首先，因为每个点可以覆盖与它距离为2的所有点
那么我们可以想到的就是让每个点都尽量覆盖更多的点

**即贪心**

此题的一个做法即为从树的最深的一个节点开始进行
那么我们就可以按照深度进行排序
接着便利每一个可以覆盖的点
并把vis置为true
每次放置消防局时便跳过已经遍历了的
这样就可以得到我们的答案了

## 坑点
1. 不是每个点都只遍历一次，故每次更新时，直接bfs即可，不需要剪枝
（~~本人被坑了1小时，亏哭了~~） 
2. 距离为2的点并不包括**自己**！！！
___

## code
```cpp
#include <cstdio>
#include <vector>
#include <cctype>
#include <algorithm>
#include <queue>
using namespace std;
typedef long long ll;
template <class T>
void rd(T &x)
{
    #define gc getchar()
    x = 0;
    char c = gc;
    ll f = 1;
    while (!isdigit(c)) {if (c == '-') f = -1;c = gc;}
    while (isdigit(c)) x = (x << 3) + (x << 1) + (c ^ 48), c = gc;
    x *= f;
    #undef gc
}
template <class T>
void pt(T x)
{
    if (x < 0)
        putchar ('-'), x = (~x) + 1;
    if (x > 9)
        pt(x / 10);
    putchar ((x % 10) ^ 48);
}
const int N = 1005;
int n;
vector <int> Graph[N];
int deep[N], ans, fa[N];
bool vis[N];
struct node
{
    int id, deep;
    bool operator < (const node &x)
    {
        return deep > x.deep;
    }
}a[N];
void dfs(int x)
{
    vis[x] = 1;
    for (int i = 0;i < (int)Graph[x].size(); i++)
        if (!vis[Graph[x][i]])
        {
            fa[Graph[x][i]] = x;
            a[Graph[x][i]].deep = a[x].deep + 1;
            dfs(Graph[x][i]);
        }
}
void update(int x, int tim)
{
    // if (tim <= 2)
    // printf("x = %d, tim = %d\n", x, tim);
    if (tim > 2)
        return;
    vis[x] = 1;
    for (int i = 0;i < (int)Graph[x].size(); i++)
        // if (!vis[Graph[x][i]])
            update(Graph[x][i], tim + 1);
}
int main() 
{
    rd(n);
    for (int i = 1;i <= n; i++)
        fa[i] = i;
    a[1].id = 1;
    for (int i = 2, x;i <= n; i++)
    {
        a[i].id = i;
        rd(x);
        Graph[x].push_back(i);
        Graph[i].push_back(x);
    }
    dfs(1);
    for (int i = 1;i <= n; i++)
        vis[i] = 0;
    sort(a + 1, a + n + 1);
    int last = 0;
    while (1)
    {
        bool f = 1;
        for (int i = last + 1;i <= n; i++)
            if (!vis[a[i].id])
            {
                last = i;
                f = 0;
                break;
            }
        if (f)
            break;
        ans++;
        // printf ("a[last].id = %d\n", a[last].id);
        int x = fa[fa[a[last].id]];
        update(x, 0);
    }
    pt(ans);
    return 0;
}
```

#### 转载自本人[CSDN blog](https://blog.csdn.net/qq_43537070/article/details/102689824)

## Thanks for reading！


---

## 作者：C20203030 (赞：0)


### 一、题目

[点此看题](https://www.luogu.org/problem/P2279)

### 二、解法

**0x01 树形dp**

我一开始想写树形$dp$，结果写不出来。

其实这道题$dp$也是可以的，定义$dp[u][i]$为离$u$最近的被标记点距离为$i$，然后处理完子树$u$的最小花费。

转移就不详细讲了，相信你自己能$yy$（~~比如用一些奇技淫巧~~ ）出来。

**0x02 贪心**

我们跑一遍这棵树，在回溯的时候存下离它最近的标记点和最远的未标记点，如果未标记点再回溯就不可能在被标记，那就在当前点标记它，这其实是一种”能拖就拖“的贪心方法，因为标记最上面的点能涉及到的范围最广，也就最优，时间复杂度只有$O(n)$。


```cpp
#include <cstdio>
#include <iostream>
using namespace std;
const int MAXN = 10005;
int read()
{
	int x=0,flag=1;
	char c;
	while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
	while(c>='0' && c<='9') x=(x<<3)+(x<<1)+c-'0',c=getchar();
	return x*flag;
}
int n,tot,ans,f[MAXN];
struct edge
{
	int v,next;
}e[2*MAXN];
struct node
{
	int x,y;
};
node dfs(int u,int fa)
{
	int Max=0,Min=0x3f3f3f3f;
	for(int i=f[u];i;i=e[i].next)
	{
		int v=e[i].v;
		if(v==fa) continue;
		node t=dfs(v,u);
		Max=max(Max,t.x);
		Min=min(Min,t.y);
	}
	if(Max==2)
	{
		ans++;
		return node{0,1};
	}
	if(Max+Min<=2)
		return node{0,Min+1};
	return node{Max+1,Min+1};
}
int main()
{
	n=read();
	for(int i=2;i<=n;i++)
	{
		int j=read();
		e[++tot]=edge{j,f[i]},f[i]=tot;
		e[++tot]=edge{i,f[j]},f[j]=tot;
	}
	node t=dfs(1,0);
	if(t.x) ans++;
	printf("%d\n",ans);
}
```

---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P2279)看题目。
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不难看出此题是$DP$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是状态的设计是此题的一大难点。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑如下定义状态：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$DP(u,v)$：$u$点依靠$v$点上的消防站，且可以满足以$u$为根的子树均被消防站覆盖到的情况下需要的最少的消防站数量。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另设一个辅助状态：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$mn(u)$：以$u$为根的子树的最优覆盖方案所需要的基站数量。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故$mn(u)=\min_{v\in V}\{DP(u,v)\}$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$son(u)$表示$u$的儿子的集合，这样的话转移也可以写出来了：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$\displaystyle DP(u,v)=\sum_{p\in son(u)}\min\{DP(p,v)-1,mn(p)\}$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是枚举$p$点是否和$u$点“共享”一个消防站。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$dis(u,v)$表示$u,v$间的距离，则可得初始化：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$\displaystyle DP(u,v)=\begin{cases}1&dis(u,v)\le 2 \\\infty&dis(u,v)>2\end{cases}$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中$dis$可以$O(n^2)$初始化得到。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外[POJ2152](https://cn.vjudge.net/problem/POJ-2152)跟此题很像，可以类似解决。
# 代码
```cpp
#include <queue>
#include <cstdio>
#include <cstring>
using namespace std;

const int MAXN = 1005, INF = 0x3f3f3f3f;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

struct edge
{
	int to, nxt;
}Graph[MAXN * 2];

queue<int> q;

int DP[MAXN][MAXN], dis[MAXN][MAXN], minVal[MAXN];
int head[MAXN];
int N, cnt;
bool visited[MAXN];

void addEdge( const int from, const int to )
{
	cnt ++;
	Graph[cnt].to = to;
	Graph[cnt].nxt = head[from];
	head[from] = cnt;
}

void getDis( const int sta, int *dist )
{
	while( ! q.empty() ) q.pop();
	memset( visited, false, sizeof( visited ) );
	q.push( sta );
	visited[sta] = 0;
	dist[sta] = 0;
	int h, v;
	while( ! q.empty() )
	{
		h = q.front();
		q.pop();
		for( int i = head[h] ; i ; i = Graph[i].nxt )
		{
			v = Graph[i].to;
			if( ! visited[v] )
			{
				visited[v] = true;
				dist[v] = dist[h] + 1;
				q.push( v );
			}
		}
	}
}

void DFS( const int u, const int fa )
{
	int v;
	for( int i = head[u] ; i ; i = Graph[i].nxt )
	{
		v = Graph[i].to;
		if( v ^ fa )
		{
			DFS( v, u );
			for( int j = 1 ; j <= N ; j ++ )
			{
				if( dis[u][j] <= 2 )
				{
					DP[u][j] += MIN( DP[v][j] - 1, minVal[v] );
				}
			}
		}
	}
	minVal[u] = INF;
	for( int i = 1 ; i <= N ; i ++ )
	{
		minVal[u] = MIN( minVal[u], DP[u][i] );
	}
}

int main()
{
	int fr;
	read( N );
	for( int i = 1 ; i < N ; i ++ )
	{
		read( fr );
		addEdge( fr, i + 1 );
		addEdge( i + 1, fr );
	}
	for( int i = 1 ; i <= N ; i ++ )
	{
		getDis( i, dis[i] );
		for( int j = 1 ; j <= N ; j ++ )
		{
			if( dis[i][j] <= 2 ) DP[i][j] = 1;
			else DP[i][j] = INF;
		}
	}
	DFS( 1, 0 );
	write( minVal[1] ), putchar( '\n' );
	return 0;
}
```

---

## 作者：ix35 (赞：0)

### 我的主要做法依然是贪心，初始排序时间复杂度O(nlgn)

贪心策略很多大佬已经讲了，从最深的点开始找，假如未被覆盖就在他的祖父节点处建一个消防站。

关键是：怎么看一个点是否被覆盖呢？

我用的是一种打标记的方法：我们首先看看一个节点建造消防站后会覆盖哪些点：

1：它的祖父节点

2：它的父节点和父节点的子节点（这里就包括它自己）

3：它的所有子节点和它的所有孙子节点

每个节点引入两个标记tag和sd，p[i].tag==1表示i节点以及i节点的所有子节点都被覆盖，p[i].sd==1表示i节点以及i节点的所有子节点，以及i节点的所有孙子节点都被覆盖，这样我们不需要每建一个消防站就更新所有影响到的节点，**思想类比线段树的lazy tag**

如果覆盖了一个节点，那么按照上面的三类就可以如下标记：

节点x的祖父节点被覆盖，vis标记为1；

节点x的父节点被覆盖，且所有子节点被覆盖，vis和tag标记为1；

节点x的所有子节点，所有孙子节点及其本身被覆盖，vis，tag和sd都标记为1；

查询一个点是否被覆盖：如果自己的vis，父节点的tag，祖父节点的sd都为0，那就是还没被覆盖

这样，我们完成了在O(1)时间内标记和查询的工作

```cpp
#include <bits/stdc++.h>
using namespace std;
struct P {
	int f,d,vis,tag,sd;
}p[1010];
int n,ans,ord[1010];
bool cmp (int a,int b) {
	return p[a].d>p[b].d;
}
int main () {
	p[1].d=1,p[1].f=0,p[1].vis=0,p[1].tag=0,ord[1]=1;
	cin >> n;
	for (int i=2;i<=n;i++) {
		cin >> p[i].f;
		p[i].d=p[p[i].f].d+1,p[i].vis=0,p[i].tag=0;
		ord[i]=i;
	}
	sort(ord+1,ord+n+1,cmp);
	for (int i=1;i<=n;i++) {
		int x=ord[i];
		if (p[x].vis==1||p[p[x].f].tag==1||p[p[p[x].f].f].sd==1) {
			continue;
		}
		ans++;
		int gf=p[p[x].f].f;
		p[p[p[gf].f].f].vis=p[p[gf].f].vis=1;
		p[p[gf].f].tag=p[gf].tag=1;
		p[gf].sd=1;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：KingBenQi (赞：0)

---
Solution
---
先用dfs1将这个树状结构的图遍历一遍,把爸爸和深度都记录一遍
用一个小根堆从最大的堆顶(depth大小排)元素开始dfs2,相当于染色打标记.
没打一次色,就相当与建立一个消防局,ans++.
如果整个图都被遍历完拉,,

```
#include<bits/stdc++.h>
#define N 1005
using namespace std;
inline int gi(){
    char ch=getchar();int x=0,q=0;
    while(ch<'0' || ch>'9') ch=='-'?q=1:0,ch=getchar();
    while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
    return q?(-x):x;
}
int n,tot,ans;
int fa[N],dep[N];
struct cmp{
	bool operator () (int &a,int &b){
		return dep[a]<dep[b];
	}
};
priority_queue<int,vector<int>,cmp> Q;
struct Edge{
	int next,to;
}h[N*5];
int head[N*20];
bool vis[N];
void Add(int u,int v){
	h[++tot].next=head[u];
	h[tot].to=v;
	head[u]=tot;
}
void dfs1(int now,int father,int depth){
	fa[now]=father;
	dep[now]=depth;
	for(int i=head[now];i;i=h[i].next){
		if(h[i].to==father) continue;
		dfs1(h[i].to,now,depth+1);
	}
}
void dfs2(int now,int depth){
	if(depth>2)
		return ;
	vis[now]=true;
	for(int i=head[now];i;i=h[i].next)
		dfs2(h[i].to,depth+1);
}
int x;
int main(){
	n=gi();
	for(int i=1;i<n;i++){
        x=gi();
		Add(i+1,x);Add(x,i+1);
	}
	dfs1(1,0,1);
	int x;
	for(int i=1;i<=n;i++) Q.push(i);
	while(Q.size()){
		while(Q.size()&&vis[x=Q.top()])
			Q.pop();
		if(!Q.size()) break;
		if(fa[fa[x]]) dfs2(fa[fa[x]],0);
		else dfs2(1,0);
		ans++;
	}
	cout<<ans<<endl;
	return 0;
}

```

---

## 作者：zhoujun (赞：0)

#因为自我感觉我的代码比较简短233

先用dfs每个节点到1号节点距离.

排序.

从距离最远，且未标记的节点搜索4步，并标记搜到的节点，每搜索一次答案加1.

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int n, ans;
bool b[1024], c[1024];
vector<int> v[1024];
pair<int,int> q[1024];
void dfs(int x,int d){//用dfs每个节点到1号节点距离
    q[x]=make_pair(d,x);
    for(int i=0; i<v[x].size(); i++){
        if(!b[v[x][i]]){
            b[v[x][i]]=1;
            dfs(v[x][i],d+1);
            b[v[x][i]]=0;
        }
    }
}
void dfs4(int x,int d){//搜索四步，并标记
    c[x]=1;
    if(d==0) return;
    for(int i=0; i<v[x].size(); i++){
        if(!b[v[x][i]]){
            b[v[x][i]]=1;
            dfs4(v[x][i],d-1);
            b[v[x][i]]=0;
        }
    }
}
int main(){
    int i, x;
    cin >> n;
    for(i=2; i<=n; i++){
        cin >> x;
        v[i].push_back(x);
        v[x].push_back(i);
    }
    b[1]=1;
    dfs(1,0);
    b[1]=0;
    sort(q,q+n+1);
    for(i=n; i>0; i--){
        if(!c[q[i].second]){
            c[q[i].second]=1;
            b[q[i].second]=1;
            dfs4(q[i].second,4);
            b[q[i].second]=0;
            ans++;
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：zk1431043937 (赞：0)

第一次写难度高一些的题解。

其实我也借鉴了各位高人的方法，结合了点自己的思考。

总的来说一个节点未被覆盖就尽量往爷爷靠。

首先将第1个点记作根节点，然后dfs算每个结点的层数，并记录每个点的父亲。

算完层数后再bfs，将能覆盖的点都覆盖掉，遇到未被覆盖的，往爷爷那里加一所消防局。

最后输出消防局总数。

代码如下：

```cpp
program p2279;
  var map:array[0..1001,0..1001]of boolean;//判断两点之间是否有路径连接。
      hash:array[0..1001]of boolean;//判断是否覆盖。
      f,dis:array[0..1001]of longint;//f记录父亲，dis记录层数。
      i,j,m,n,x,ans,temp:longint;
procedure dfs(x:longint);//计算x点所在层次。
  var i:longint;
begin
  for i:=1 to n do
  if (map[x,i]) and (not(hash[i])) then
  begin
    hash[i]:=true;
    dis[i]:=dis[x]+1;
    f[i]:=x;
    dfs(i);
  end;
end;
procedure bfs(x:longint);//将孙子，儿子，自己，父亲，爷爷覆盖，顺便统计消防局个数。
  var i,j:longint;
begin
  if not(hash[x]) then inc(m);
  hash[x]:=true;
  inc(ans);//覆盖自己，并在自己上加消防局。
  for i:=1 to n do//覆盖儿子，父亲。
  if map[x,i] then
  begin
    if not(hash[i]) then inc(m);
    hash[i]:=true;
    for j:=1 to n do//覆盖孙子，爷爷。
    if map[i,j] then
    begin
      if not(hash[j]) then inc(m);
      hash[j]:=true;
    end;
  end;
end;
begin
  readln(n);
  for i:=2 to n do
  begin
    read(j);
    map[i,j]:=true;
    map[j,i]:=true;
  end;
  hash[1]:=true;
  dis[1]:=1;
  dfs(1);
  fillchar(hash,sizeof(hash),false);
  while m<n do
  begin
    temp:=0;
    for i:=1 to n do
    if not(hash[i]) and (dis[i]>temp) then
    begin
      temp:=dis[i];
      x:=i;
    end;
    bfs(f[f[x]]);//把消防局建在爷爷上。
  end;
  writeln(ans);
end.
总的来说，细心分析题意还是不难的，用搜索，贪心，即可求解。
```

---

## 作者：a41881147 (赞：0)

这里给出树形dp的做法 ...（窝很自信泥萌能看着我的题解写出代码~~~）


一道神奇的树形dp...(窝写的好鬼畜...不过思路还算清晰...T.T)

类似于最小支配集(在树中 选出一些点,使得 没有选出的点 都与选出的点直接相连,要求选的点尽可能少)

这题里,一个选出的点控制的范围成了2...奥(shi)妙(fen)重(du)重(liu)

于是乎,状态就十分多+鬼畜了


窝加一句,看下面的状态和转移,一定要注意分清"选"和“被覆盖”


f[i][1]表示选点i,并且 i的子树都被覆盖时 最少选多少点


f[i][1]=1 然后~

f[i][1]+= min( f[son][1],g[son][1],g[son][2] )  son需要枚举到i的所有儿子

g[i][1]表示i点不选,但是 i的所有 儿子所在的子树都被覆盖 最少选多少点 (i不一定被覆盖)

这样有两种情况,就是 i的儿子之间相互覆盖, 或者 i的每个儿子 被自己的儿子或孙子覆盖

cnt1= f[son][1]+sigma( min( f[other sons][1], g[other sons][1] ) )//son要枚举i的所有儿子！！！

cnt2= sigma( min( f[son][1],g[son][3],g[son][4] ) )//g[other sons][1]表示other sons 可以被son覆盖哦~但是other sons的 儿子一定要都被覆盖



g[i][1]=min(cnt1,cnt2) 

g[i][2] 表示i点不选,但是 i的 所有孙子所在的子树 都被覆盖 最少选多少点 (i和i的儿子不一定被选)

g[i][2]=sigma( g[son][1] );

g[i][3] 表示点i不选, 但是i被 i的儿子 覆盖,且 子树i都被覆盖 最少选多少点


g[i][3]=min( f[son][1]+min( f[other sons][1],g[other sons][1,3,4]  (应该能看懂吧...) ) )

son要枚举i的所有儿子,  每枚举到一个son,都要再枚举 除了son的所有儿子 ！！！

g[i][4] 表示点i不选, 但是i被 i的孙子 覆盖,且 子树i都被覆盖 最少选多少点

 
g[i][4]=min( g[son][3]+sigma( min( g[other sons][3],g[other sons][4] ) ) ) son枚举i的所有儿子

选一个儿子son,son被son的儿子控制,那么i就是被i的孙子控制呗...   其他的儿子要么被儿子控制,要么被孙子控制,取min   son枚举所有i的儿子,每枚举到一个son,都要再枚举 除了son的所有儿子 ！！！



时间复杂度 O(n^2)


应该说的很明白了,其他细节可以看代码 比如 g[][3]和g[][4]要赋一个较大值...


这里给出代码







                






    


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 1009
using namespace std;
int n,first[N],next[N<<1],la,f[N][5],g[N][5],fa[N];
struct node{int fr,to;}a[N<<1];
void addedge(int x,int y)
{
    a[++la].fr=x,a[la].to=y;
    next[la]=first[x],first[x]=la;
}
void dfs(int x)
{
    g[x][3]=g[x][4]=1e4;
    f[x][1]=1;//选x 
    for (int i=first[x];i;i=next[i])
        if (a[i].to!=fa[x])
            {
                fa[ a[i].to ]=x;
                dfs( a[i].to );
            }
    int cnt=0;
    for (int i=first[x];i;i=next[i])
        if (a[i].to!=fa[x])
            g[x][1]+=min( f[ a[i].to ][1] ,min(g[ a[i].to ][3],g[ a[i].to ][4])   );// x的儿子全被覆盖 
    for (int i=first[x];i;i=next[i])
        if (a[i].to!=fa[x])
            {
                f[x][1]+=min( f[ a[i].to ][1],min( g[ a[i].to ][1],g[ a[i].to ][2] ) );//选x 
                cnt=f[ a[i].to ][1];
                for (int j=first[x];j;j=next[j])
                    if ( a[j].to!=fa[x]&&a[j].to!=a[i].to )
                        cnt+=min( f[ a[j].to ][1],g[ a[j].to ][1] );
                g[x][1]=min(g[x][1],cnt);  //x的儿子全被覆盖 
                g[x][2]+=g[ a[i].to ][1];  //x的孙子全被覆盖 
                cnt=f[ a[i].to ][1];    //x被儿子覆盖 
                for (int j=first[x];j;j=next[j])
                    if ( a[j].to!=fa[x]&&a[j].to!=a[i].to )    
                        {
                            int minn=f[ a[j].to ][1];
                            for (int k=1;k<=4;k++) 
                                if (k!=2) minn=min(minn,g[ a[j].to ][k]);
                            cnt+=minn;
                        }
                g[x][3]=min(g[x][3],cnt);
                cnt=g[ a[i].to ][3];   //x被孙子覆盖 
                for (int j=first[x];j;j=next[j])
                    if ( a[j].to!=fa[x]&&a[j].to!=a[i].to )
                            cnt+=min( g[ a[j].to ][3],g[ a[j].to ][4] );
                g[x][4]=min( g[x][4],cnt );
            }
}
int main()
{
    int i,j,k,x,y,z;
    cin>>n;
    for (i=2;i<=n;i++)
        scanf("%d",&x),addedge(i,x),addedge(x,i);
    dfs(1);
    cout<<min( f[1][1],min( g[1][3],g[1][4] ) )<<endl; 
}

```

---

## 作者：survivor (赞：0)

受贪心的启发，这样做就不用排序，一共只要4ms，每次return消防站到该点的距离

0. 等于5的时候就在根上建个消防站，return 0 并且 ans++

0. 如果没有儿子就 return 3 ，可以看成刚刚没有被覆盖到

0. root==1即 root 为顶点的时候要特判

0. 还有几个特判，很容易漏掉，表示wa了好多好多遍......


        
    
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int maxn=1000+5,maxm=2000+5;
int head[maxn];
int ans(0),len(1),N,x;
struct mytree
{
    int u,v,next;
}tree[maxm];
void add(int u,int v)
{
    tree[len].u=u;
    tree[len].v=v;
    tree[len].next=head[u];
    head[u]=len++;
}
int read()
{
    char ch=getchar();
    int ret(0);
    while(ch<'0'||'9'<ch) ch=getchar();
    for(;'0'<=ch&&ch<='9';ch=getchar()) ret=ret*10+ch-'0';
    return ret;
}
int dfs(int root,int mark)
{
    int son,maxx(0),minn(0x3f3f3f3f),df_son;
    bool bb(1);
    for(int i=head[root];i;i=tree[i].next)
    {
        son=tree[i].v;
        if(son==mark) {continue;}
        df_son=dfs(son,root);
        maxx=max(df_son,maxx);
        minn=min(df_son,minn);
        bb=false;
    }
    if(bb) return 3;//如果没有儿子，可以看成刚刚没有被覆盖到，即距离消防站为3 
    if(maxx+1==5) {ans++;return 0;}
    if(root==1)//如果是根要特判 
        if(maxx>2&&minn>0) ans++;//最近的儿子覆盖不到最远的儿子 
        else if(minn>1) ans++;//最近的儿子覆盖不到根 
    if(maxx<=3&&minn<=0) return minn+1;//最近的儿子可以把其他所有儿子覆盖到 
    if(maxx<=2&&minn<=1) return minn+1;//自己可以被覆盖到且没有儿子没被覆盖 
    //上面可以简写成(maxx+minn<=3) 
    return maxx+1;
}
int main()
{
    N=read();
    for(int i=2;i<=N;i++)
    {
        x=read();
        add(x,i);
        add(i,x);
    }
    dfs(1,0);
    printf("%d",ans);
```
return 0；
}

---

## 作者：sxb_201 (赞：0)

为楼上贪心的介绍加个程序 写的不好 别笑  【不知道为什么洛谷把这个题目放到动规来了】


注意 题目没有说但 n<=1000;


```cpp
#include<cstdio>
#include<iostream>
using namespace std;

int tot,num[2*1000+1],nnext[2*1000+1],g[2*1000+1];
bool b[1000+1];  //记录点是否被涂 
int d[1000+1];
int n;
int team[1000+1];
int head,tail;
int nn=0;
int mmax=99999;
void add(int x,int y)
{
    tot++;
    num[tot]=y;
    nnext[tot]=g[x];
    g[x]=tot;
}

void push(int x)
{
    tail++; team[tail]=x;
}

void DFS(int x,int depth)
{
    if(!b[x]) nn++;
    b[x]=true;
    if(depth==3)   //涂深度为3以内的点 
        return ;
    for(int i=g[x];i;i=nnext[i])
        DFS(num[i],depth+1);
}

int pop()
{
    head++; return team[head];
}

int main()
{
    cin>>n;
    for(int i=2;i<=n;i++)
    {
        int x;
        scanf("%d",&x);
        add(i,x);
        add(x,i);
    }
    head=tail=0;
    d[1]=1;
    push(1);
    while(head<tail)
    {
        int x=pop();
        for(int i=g[x];i;i=nnext[i])
        if(d[num[i]]==0)
        {
            d[num[i]]=d[x]+1;
            push(num[i]);
        }
    }
    int ans=0;
    while(nn<n)
    {
        
        int x=0;
        for(int i=1;i<=n;i++)
            if( !b[i] &&d[i]>d[x]) x=i;
        ans++;
        for(int i=g[x];i;i=nnext[i])            //找父亲 
        if(d[num[i]]<d[x])    //       有且仅有一个【深度】比他小   很重要 因为有n个点 只有n-1条边  所以x只有 
        {                                                                            //一个”合法“的 爸爸 
            x=num[i];
            break;
        }
        for(int i=g[x];i;i=nnext[i])           //找爷爷 
        if(d[num[i]]<d[x])
        {
            x=num[i];
            break;
        }
        DFS(x,1);   //开始涂点 
    }
    cout<<ans;
    return 0;
}
```

---


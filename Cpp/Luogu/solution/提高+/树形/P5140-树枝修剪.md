# 树枝修剪

## 题目背景

$Daleva$ $Geoge$是一个热爱生活的园艺工。

## 题目描述

$Daleva$ $Geoge$的花园里有一颗常年没有修剪的树，这一天，$Daleva$ $Geoge$家里来了客人，为了给客人一个好印象，他需要整理这个花园，但是那一颗树显得太碍眼了，他必须要给他好好地修剪一下。

这是一颗以$root$为根的有根树，有$n$个节点。$Daleva$ $Geoge$在根节点，$Daleva$ $Geoge$对某些叶子的形态感到不满，需要剪去多余的枝条。

有$S$个需要修剪的叶子节点,这些叶子节点有一些多余的枝条，这些叶子节点有着自己的权值$a_{i}$,表示这个节点上有多少个$Daleva$ $Geoge$不需要的枝条。同时，因为花园里没法容下这些枝条（否则就变得不和谐了），$Daleva$ $Geoge$需要把这些枝条安装到某些节点上。

$Daleva$ $Geoge$有一个神奇的胶水和一把神奇的剪刀，因此你不需考虑每个树枝的固定形态，根据$Daleva$ $Geoge$的推测，一共有$T$个叶子节点需要安装这些枝条，这些节点有各自的权值$b_{i}$，表示需要$b_{i}$个枝条才能把这棵树变得很好看。

为了修剪好这棵树，$Daleva$ $Geoge$不得不在树上跑边，把每个叶子节点中多余的枝条剪下，并用胶水粘在其他的有需要的叶子节点上。每条边都有不同的长度，现在，由于树太过庞大，$Daleva$ $Geoge$需要知道，他最少需要跑多远的路才能使这棵树被修剪好，$Daleva$ $Geoge$也要回到树根上下来。

虽然$Daleva$ $Geoge$有这些神奇的工具，但他的口袋是有限的，容量为$G$,$Daleva$ $Geoge$不能一次带太多枝条，即不能超过$G$,这更使他懒于考虑这些繁琐的问题。$Daleva$ $Geoge$当然会算啦，他那么巨，但他为了养足精力去剪枝条，这一艰巨的任务就落在你身上了。

$Daleva$ $Geoge$已经把心中树的形状告诉你了，他要躺在椅子上看你怎么算这些问题。

## 说明/提示

样例1解释：

![](https://cdn.luogu.com.cn/upload/pic/37354.png)

蓝色数字表示有多少多余枝条，黄色数字表示需要的枝条数。

则最优方案为：$1→2→1→3→1→2→1→3→1→4→1→2→1→4→1$，答案为$40$;

对于$5\%$的数据，为样例1。

对于$40\%$的数据，$n\leq 10,G\leq 10;w \leq 1000$

对于$100\%$的数据，$n\leq 40,0000,G\leq 1000;S+T\leq n;a_{i},b_{i}\leq 10^{9};w\leq 10^{9}$

数据保证不会有任意一个叶子节点既需要枝条又有多余枝条。

## 样例 #1

### 输入

```
4 2 1
2 1 4
4 1 2
3 1 2
1 2
2 6
3 3
4 3```

### 输出

```
40```

## 样例 #2

### 输入

```
5 1 1
1 2 2
3 2 2
4 1 2
5 4 2
1 1
3 1
5 1
```

### 输出

```
16```

## 样例 #3

### 输入

```
20 10 18
1 17 86406
17 16 94583
19 10 28177
16 18 31981
10 14 36241
1 7 28919
2 1 94673
5 6 2801
7 11 81927
11 13 7779
17 5 71948
19 7 20264
1 8 17736
13 20 97181
17 9 16807
11 15 93705
17 3 29601
1 12 43829
13 4 27537
1 6
20 23585
9 8376
12 3128
15 5417
8 4011
3 1156
6 1497
```

### 输出

```
1289613990```

# 题解

## 作者：Yzweak (赞：6)

坐标定位，这里是验题人。也不知道什么时候题目被加入公共题库了~~

看着略带感人的通过数，还是把题解搬到这里来吧。

首先吐槽一下出题人的语文水平，叶子节点上的枝条是什么鬼。。。

抛开猥琐的出题人，我们抽象一下这一题的数学模型：就是有一棵树，一些叶子节点有一些东西，另一些叶子节点需要这些东西，你一次只能搬运限定数量的东西，求你从根节点出发完成所有任务到回根节点所走的路径。

记得比赛页面一开始的加粗字吗？

#### 蒟蒻们特别不喜欢数据结构学傻了的dalao（记住这句话）

这句话就是~~良心的~~[彩色蒟蒻](https://www.luogu.org/space/show?uid=49285)给dalao们的提醒，毕竟这个数据范围很像某个$Nlog_{2}N$算法。

### 但是认真思考后就会发现，你进入每个叶子节点的次数是固定的 ，（总会没有人搬完了还进去吧），而且如果有多余的枝条，最好运到它临近的叶子节点。

所以你只要一遍$O(N)$的$dfs$就可以了（是不是很带感？）

一开始将需要枝条的叶子节点权值设成负。

回溯的时候如果某个子树能够"自给自足”（子树权值和为$0$）,就意味着这棵子树不需要往外送枝条也不要往里面运枝条，也就是答案就不要加上这条边的贡献啦。

##### 当然，自给自足的话肯定还要跑这条边过去搬在回来以完成所谓的“自给自足”。

##### 但是，我们还要排除一棵子树上一开始就什么都没有的情况（~~这一棵树完好无损，过去干嘛？~~）

出题人后来发现这样的答案贼大，**~~很良心地~~没有让你取模而是写高精$(2333)$**，~~(不会压位)~~所以导致标程跑了$0.7s$左右，时间复杂度上非常具有迷惑性，于是猥琐的[蒟蒻二叉树](https://www.luogu.org/space/show?uid=49719)和[彩色蒟蒻](https://www.luogu.org/space/show?uid=49285)一拍即合，没有对标程进一步优化而是减小了数据规模企图造成误导~~(树剖？倍增？LCA？kruscal重构树？DP？二分？差分？)~~

~~（说不定真的有大佬用这些东西做出来了）~~

标程主要长度就是高精了，下面是[蒟蒻二叉树](https://www.luogu.org/space/show?uid=49719)的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,f[410000],i,S,T,root,G;
int ant[21000],maxx;
vector <pair<int, int> > q[410000];
bool fronts(int x)
{
	if(ant[x] >= 10)
	{
		ant[x + 1] += ant[x] / 10;
		ant[x] %= 10;
		maxx = max(maxx, x + 1);
		return true;
	}
	return false;
}
void pluse(long long x)
{
	int ws = 0,flag = 0;
	while(x)
	{
		ws ++;
		int c = x % 10;
		ant[ws] += c;
		fronts(ws);
		x /= 10;
	}
	while(fronts(ws + 1)) ws ++,flag = 1;
	if(flag) ws ++;
	maxx = max(maxx, ws);
}
bool findans(int x,int fa)
{
	int flag = 0;
    for(int k = 0;k < q[x].size();k ++)
    {
        int y = q[x][k].first,c = q[x][k].second;
        if(y == fa) continue;
        if(findans(y, x)) flag = 1,
        pluse(1LL * (abs(f[y]) / G + (abs(f[y]) % G != 0) + (f[y] == 0 ? flag : 0)) * c * 2);
        f[x] += f[y];
    }
    if(f[x] != 0 || flag) return true;
	return false; 
}
int main()
{ 
    scanf("%d%d%d", &n, &G, &root);
    for(i = 1;i <= n - 1;i ++)
    {
        int x,y,c;
        scanf("%d%d%d", &x, &y, &c);
        q[x].push_back(make_pair(y, c));
        q[y].push_back(make_pair(x, c));
    }
    scanf("%d%d", &S, &T);
    for(i = 1;i <= S;i ++)
    {
        int x,c;
        scanf("%d%d", &x, &c);
        f[x] += c;
     }
    for(i = 1;i <= T;i ++)
    {
        int x,c;
        scanf("%d%d", &x, &c);
        f[x] -= c;
    }
    findans(root, 0);
    while(fronts(maxx + 1)) maxx ++;
    if(ant[maxx + 1] != 0) maxx ++;
    for(i = maxx;i >= 1;i --) printf("%d",ant[i]);
}
```

---

## 作者：胖娃儿二号 (赞：2)

这个题很有意思，典型的误导类题目。

但是唯一一篇题解讲的并不那么清楚，所以我来补一下做题过程中会遇到的各种问题和思考。

首先先明确这个题是一个贪心。

对于每个叶子结点，进去的次数是一定的，（都弄完了进去干嘛）那么我们就考虑优化中间的路径，才能使得最后的答案最小。

那么在一棵树上，当然是就近原则啦，先供给自己附近的再给远的。

考虑一个类似树形 dp 的维护方法，设 $dp_i$ 表示以 $i$ 为根节点的子树内能够获得的答案的最小值，$f_i$ 表示以 $i$ 为根节点的子树内多出/需要多少枝条。

肯定是从孩子向父亲维护啦，那么分类讨论。

有以下三种情况：

1. 这个子树不需要任何修改，那么不进去就行。
2. 第二，这个子树自己能够满足自己（但是要修改），那么只需要计算我们进去再出来的代价。
3. 第三，这个子树多/少了枝条，那么我们不需要计算进去+出来的，但是需要考虑搬进去/搬出来的次数。（本身的进去+出来我就带着枝条了，显然更优）
这样的分类讨论就没有问题了，但是我们发现 $dp_i$ 较难维护，因为我们不能直接记录哪个点多了/少了，就很难计算第三种情况。

考虑修改 $dp$ 的定义，设 $dp_i$ 为以 $i$ 为根节点的子树内，从i开始，最后回到i，能够获得的答案的最小值。

这样就没问题了，维护的时候只需要考虑根节点向根节点的孩子要来回几次就行了。

那么怎么判断这三种分类讨论呢？

我们把 `dfs` 设为 `bool` 类型，返回的时候把第一种情况分出来，如果子树没有修改过或者 $f_i≠0$ 那么就不是第一种情况，修改的时候用一个 $flag$ 维护是否修改过即可。

第二种和第三种我们可以一起维护，第三种情况的公式显然是
$$
\left \lfloor \dfrac{f_v}{g} \right \rfloor+\left( f_V \bmod g \right) ≠0
$$

而这个公式在二情况下计算一定是 $0$，所以加在一起也不影响。

那么特判一下 如果 $f_v=0$ 就加上 $1$，否则不用加，然后再乘以边权乘 $2$ 就行了（来回！）。

最后一个问题，看了样例 3 你就知道肯定得上高精。

实际上我们根本不需要维护 $dp_i$，孩子的值对父亲的值可以说没有影响，所以直接高精度维护即可，最后输出答案。

不过中间量还是要开 `long long` 防炸的，懒得仔细想就直接 `#define int long long` 吧。

放代码吧，代码主要是对第一篇题解的极大优化，改善了可读性，去掉了多余的部分。

```cpp
#include<stdio.h>
#include<algorithm>
#include<math.h>
using namespace std;
#define int long long
const int maxn=1e6+7;
struct edge{
	int to,next,val;
}e[2*maxn];
int head[maxn],cnt;
inline void add(int u,int v,int w){
	e[++cnt].to=v;
	e[cnt].val=w;
	e[cnt].next=head[u];
	head[u]=cnt;
}
int ans[maxn],top;
bool check(int x){
	if(ans[x]>=10) {
		ans[x+1]+=(ans[x]/10);
		ans[x]%=10;
		top=max(top,x+1);
		return 1;
	}
	else return 0;
}
void inans(long long x){
	int res=0;
	while(x){
		res++;
		ans[res]+=(x%10);
		check(res);
		x/=10;
	}
	while(check(res+1)) res++;
	top=max(top,res);
}
int n,g,root,s,t;
int f[maxn];
bool dfs(int u,int fa){
	int flag=0;
	for(int i=head[u];i;i=e[i].next){
		int v=e[i].to;
		if(v==fa) continue;
		if(dfs(v,u)) {
			flag=1;
			inans((abs(f[v])/g+(abs(f[v])%g!=0)+(f[v]==0?1:0))*e[i].val*2);
		}
		f[u]+=f[v];
	}
	return f[u]!=0||flag;
}
signed main(){
	scanf("%lld%lld%lld",&n,&g,&root);
	for(int i=1,u,v,w;i<n;i++){
		scanf("%lld%lld%lld",&u,&v,&w);
		add(u,v,w);
		add(v,u,w);
	}
	scanf("%lld%lld",&s,&t);
	for(int i=1,x,c;i<=s;i++){
		scanf("%lld%lld",&x,&c);
		f[x]+=c;
	}
	for(int i=1,x,c;i<=t;i++){
		scanf("%lld%lld",&x,&c);
		f[x]-=c;
	}
	dfs(root,0);
	for(int i=top;i;i--) printf("%lld",ans[i]);
	return 0;
}
```


---


# 「KDOI-06-S」树上异或

## 题目描述

给定一棵包含 $n$ 个节点的树，第 $i$ 个点有一个点权 $x_i$。

对于树上的 $n-1$ 条边，每条边选择删除或不删除，有 $2^{n-1}$ 种选择是否删除每条边的方案。

对于每种删除边的方案，设删除后的图包含 $k$ 个连通块，定义这个方案的权值为图中连通块点权异或和的乘积。形式化地说，若这张图包含连通块 $C_1,C_2,\ldots,C_k$，其中 $C_i$ 是第 $i$ 个连通块的顶点集合，设 $v_i=\bigoplus_{u\in C_i} x_u$，则这个方案的权值为 $v_1\times v_2\times \cdots\times v_k$。

求这 $2^{n-1}$ 种删除边的方案的**权值**之和，答案对 $998~244~353$ 取模。

## 说明/提示

**【样例解释 #1】**

有四种删除边的方案：

* 不删除边：图有且仅有一个连通块，权值为 $1\oplus2\oplus3=0$。
* 删除 $(1,2)$ 一条边：图包含两个连通块，权值为 $(1\oplus3)\times2=4$。
* 删除 $(1,3)$ 一条边：图包含两个连通块，权值为 $(1\oplus2)\times3=9$。
* 删除 $(1,2)$，$(1,3)$ 两条边：图包含三个连通块，权值为 $1\times2\times3=6$。

所有方案权值的总和为 $0+4+9+6=19$。

**【样例 #3】**

见选手目录下的 `xor/xor3.in` 与 `xor/xor3.ans`。

这个样例满足测试点 $6\sim7$ 的条件限制。

**【样例 #4】**

见选手目录下的 `xor/xor4.in` 与 `xor/xor4.ans`。

这个样例满足测试点 $8$ 的条件限制。

**【样例 #5】**

见选手目录下的 `xor/xor5.in` 与 `xor/xor5.ans`。

这个样例满足测试点 $9$ 的条件限制。

**【样例 #6】**

见选手目录下的 `xor/xor6.in` 与 `xor/xor6.ans`。

这个样例满足测试点 $19\sim21$ 的条件限制。

***

**【数据范围】**

对于所有数据保证：$1\leq n\leq5\times10^5$，$0\leq x_i\leq10^{18}$，$1\leq f_i<i$。

| 测试点编号 | $n\leq$ | $x_i$ | 特殊性质 |
|:--:|:--:|:--:|:--:|
| $1\sim2$ | $12$ | $\leq10^9$ | 无 |
| $3$ | $2000$ | $=1$ | 无 |
| $4$ | $10^5$ | $=1$ | A |
| $5$ | $10^5$ | $=1$ | B |
| $6\sim7$ | $10^5$ | $=1$ | 无 |
| $8$ | $10^5$ | $\leq7$ | A |
| $9$ | $10^5$ | $\leq7$ | B |
| $10\sim11$ | $10^5$ | $\leq7$ | 无 |
| $12\sim16$ | $200$ | $\leq8191$ | 无 |
| $17$ | $10^5$ | $\leq10^9$ | A |
| $18$ | $10^5$ | $\leq10^9$ | B |
| $19\sim21$ | $10^5$ | $\leq10^9$ | 无 |
| $22\sim25$ | $5\times10^5$ | $\leq10^{18}$ | 无 |

* 特殊性质 A：保证对于任意 $1< i\le n$，$f_i=i-1$。
* 特殊性质 B：保证对于任意 $1< i\le n$，$f_i=1$。

***

**【提示】**

$\oplus$ 表示按位异或运算。

本题输入输出量较大，请使用适当的 I/O 方式。

**请注意常数因子对程序运行效率产生的影响。**


## 样例 #1

### 输入

```
3
1 2 3
1 1```

### 输出

```
19```

## 样例 #2

### 输入

```
5
3 4 5 6 7
1 1 2 2```

### 输出

```
5985```

# 题解

## 作者：喵仔牛奶 (赞：46)

# Solution

树形 DP 好题。

## Part I 部分分类比

下文为简单，我们称一个连通块的权值为连通块内点的异或和。

考虑链的部分分，显然可以设 $f_{i}$ 是前 $i$ 个点所有断边方案的权值和，对于每个点枚举上一条断的边转移。令 $s_i=\bigoplus_{j=1}^{i}a_j$，则 $f_i=\sum_{j=0}^{i-1}(s_i\oplus s_{j})\times f_j$。

这样是 $\mathcal{O}(n^2)$ 的，我们拆位算贡献，就可以做到 $\mathcal{O}(n\log V)$。

具体地，设 $g_{i,j,k}$ 是所有断边方案中，与 $i$ 相连的连通块的价值在二进制下第 $j$ 位是 $k$ 的，不与 $i$ 相连的连通块的价值乘积的和。

初始状态：若 $a_u$ 第 $j$ 位为 $1$，则 $g_{i,j,1}=1$，否则 $g_{i,j,0}=1$。

转移如下：
- 为了避免后效性，先保存 $t_0=g_{i,j,0},t_1=g_{i,j,1}$。
- $\begin{cases}
g_{i,j,0}=t_{0}\times(g_{i-1,j,0}+f_{i-1})+t_{1}\times g_{i-1,j,1}\\
g_{i,j,1}=t_{0}\times g_{i-1,j,1}+t_{1}\times (g_{i-1,j,0}+f_{i-1})\\
f_{i}=\sum_{j=0}^{63}2^j\times g_{i,j,1}
\end{cases}$

同理，对于树我们也通过断边来转移。

## Part II 解决问题

设 $f_{u}$ 是以 $u$ 为根的子树的所有断边方案的权值和。

为了转移，再设 $g_{u,i,j}$ 是以 $u$ 为根的子树里断开若干边，所有断边方案中，与 $u$ 相连的连通块的价值在二进制下第 $i$ 位是 $j$ 的，不与 $u$ 相连的连通块的价值乘积的和。

初始状态：若 $a_u$ 第 $i$ 位为 $1$，则 $g_{u,i,1}=1$，否则 $g_{u,i,0}=1$。

对于每个儿子，枚举二进制下每位 $i$ 转移。
- 不断儿子相当于当前连通块的异或和第 $i$ 位异或上儿子连通块的第 $i$ 位，断掉儿子相当于异或上 $0$。
- 为了避免后效性，先保存 $t_0=g_{u,i,0},t_1=g_{u,i,1}$。
- $\begin{cases}
g_{u,i,0}\gets t_0\times(g_{v,i,0}+f_{v})+t_1\times g_{v,i,1} \\
g_{u,i,1}\gets t_0\times g_{v,i,1}+t_1\times(g_{v,i,0}+f_{v})
\end{cases}$

转移完后，$f_{u}$ 就可以简单地计算啦。
- $f_{u}=\sum_{i=0}^{63}2^i\times g_{u,i,1}$。

答案显然就是 $f_{1}$。

## Part III 小结

不难发现该算法时空复杂度均为 $\mathcal{O}(n\log V)$，需要将 $g_{u,i,j}$ 用 `int` 类型保存才能通过。

启示：
- 树形 DP 的题可以用链的部分分类比得出正解。
- 树形 DP 需要想清楚状态、列明白转移方程再写，否则在调试过程中通常会越写越复杂，导致耗费大量时间而最终一分也不得。

## Code

```cpp
#include <bits/stdc++.h>
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
using namespace std;
namespace Milkcat {
    typedef long long LL;
    typedef pair<LL, LL> pii;
    const int N = 1e6 + 5, mod = 998244353;
    LL n, u, v, a[N], f[N]; int g[N][64][2];
    vector<int> G[N];
    void dfs(int u, int fa) {
    	REP(i, 0, 63) g[u][i][a[u] >> i & 1] = 1;
    	for (int v : G[u]) {
    		if (v == fa) continue;
    		dfs(v, u);
    		REP(i, 0, 63) {
    			LL t0 = g[u][i][0], t1 = g[u][i][1];
    			g[u][i][0] = (t0 * (g[v][i][0] + f[v]) + t1 * g[v][i][1]) % mod;
    			g[u][i][1] = (t0 * g[v][i][1] + t1 * (g[v][i][0] + f[v])) % mod;
    		}
		}
		REP(i, 0, 63) f[u] = (f[u] + (1LL << i) % mod * g[u][i][1]) % mod;
	}
    int main() {
		cin >> n;
		REP(i, 1, n) cin >> a[i];
		REP(i, 2, n)
			cin >> u, G[u].push_back(i), G[i].push_back(u);
		dfs(1, 0);
		cout << f[1] << '\n';
        return 0;
    }
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int T = 1;
    while (T --) Milkcat::main();
    return 0;
}
```

---

## 作者：chroneZ (赞：36)

树形 dp，拆位。

大概就是设 $f_u$ 表示子树 $u$ 的答案，$g_{u, i, 0/1}$ 表示以 $u$ 为根的子树，考虑点 $u$ 所在的连通块，其点权异或和在二进制下第 $i$ 位为 $0/1$ 时，将以 $u$ 为根的子树去掉根所处的连通块后，剩余各部分的 $f$ 在各种方案下的积的总和（即一个 $\sum \prod$ 的形式）。

初始 $g_{u, i, {a_u}_i} \gets 1$，转移其实挺简单，考虑每次加入一个儿子 $v$ 时，$g_{u, i, 0} \gets g_{u, i, 0} \times f_v + g_{u, i, 0} \times g_{v, i, 0} + g_{u, i, 1} \times g_{v, i, 1}$，对 $g_{u, i, 1}$ 同理。

最终令 $f_u \gets \sum \limits_{i = 0} ^ {60} g_{u, i, 1} \times 2 ^ i$ 即可。

如果不理解为什么这样设计状态，可以先从链的部分分入手。

可以把链理解成对序列计数，$f_i$ 表示考虑前 $i$ 个位置的总答案。设 $s$ 为前缀异或和，那么 $f_i = \sum \limits_{j = 0} ^ {i - 1} f_j \times (s_i \oplus s_j)$，初值 $f_0 = 1$。

显然你不能对整体进行拆位，但是很快我们发现，可以在计算每个 $f_u$ 的时候拆位，具体来讲就是枚举 $s_i \oplus s_j$ 的每一位的情况，然后这样就可以 $\log$ 转移了。

把链上的思想类比到树上来，应该就能比较自然地得到上面那个状态设计。


```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;

static constexpr int mod = 998244353, N = 5e5 + 10, P = 60;
namespace basic {
	inline int add(int x, int y) {return (x + y >= mod ? x + y - mod : x + y);}
	inline int dec(int x, int y) {return (x - y < 0 ? x - y + mod : x - y);}
	inline void ad(int &x, int y) {x = add(x, y);}
	inline void de(int &x, int y) {x = dec(x, y);}

	inline int qpow(int a, int b) {
		int r = 1;
		while(b) {
			if(b & 1) r = 1ll * r * a % mod;
			a = 1ll * a * a % mod; b >>= 1;
		}
		return r;
	}
	inline int inv(int x) {return qpow(x, mod - 2);}

	int fac[N], ifac[N];
	inline void fac_init(int n = N - 1) {
		fac[0] = 1;
		for(int i = 1; i <= n; i++)
			fac[i] = 1ll * fac[i - 1] * i % mod;
		ifac[n] = inv(fac[n]);
		for(int i = n - 1; i >= 0; i--)
			ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod;
	}
	int invx[N];
	inline void inv_init(int n = N - 1) {
		invx[1] = 1;
		for(int i = 2; i <= n; i++)
			invx[i] = 1ll * (mod - mod / i) * invx[mod % i] % mod;
	}
	inline int binom(int n, int m) {
		if(n < m || m < 0) return 0;
		return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;
	}

	int rev[N];
	inline void rev_init(int n) {
		for(int i = 1; i < n; i++)
			rev[i] = (rev[i >> 1] >> 1) + (i & 1 ? n >> 1 : 0);
	}
}
using namespace basic;

i64 a[N]; int p2[P];
int f[N], g[N][P][2];

int n; vector<int> G[N];

void dfs(int u) {
	for(int i = 0; i < P; i++) {
		g[u][i][a[u] >> i & 1] = 1; 
	}
	for(auto v : G[u]) {
		dfs(v);
		for(int i = 0; i < P; i++) {
			int x = g[u][i][0], y = g[u][i][1]; g[u][i][0] = g[u][i][1] = 0;
			ad(g[u][i][0], 1ll * x * f[v] % mod);
			ad(g[u][i][0], add(1ll * x * g[v][i][0] % mod, 1ll * y * g[v][i][1] % mod));
			ad(g[u][i][1], 1ll * y * f[v] % mod);
			ad(g[u][i][1], add(1ll * x * g[v][i][1] % mod, 1ll * y * g[v][i][0] % mod));
		}
	}
	for(int i = 0; i < P; i++) {
		ad(f[u], 1ll * g[u][i][1] * p2[i] % mod);
	}
}

int main() {
	// freopen("xor.in", "r", stdin);
	// freopen("xor.out", "w", stdout);
	ios::sync_with_stdio(false); 
	cin.tie(nullptr); cout.tie(nullptr);
	
	p2[0] = 1;
	for(int i = 1; i < P; i++) {
		p2[i] = p2[i - 1] * 2 % mod;
	}

	cin >> n;
	for(int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	for(int i = 2; i <= n; i++) {
		int father; cin >> father;
		G[father].push_back(i);
	}
	dfs(1);
	cout << f[1] << "\n";
}
```

---

## 作者：SunnyYuan (赞：20)

## 前言

借鉴了 xyzfrozen 题解的思路，想在这里详细讲一讲。

还有大家好像都不爱画图，看得挺费劲。

LaTeX 公式中的 $u, v$ 很像，请注意甄别。

## 思路

首先设 $f_{i, j, k}$ 在以 $i$ 为根的子树中，对于每一种割边的方法，点 $i$ 所在连通块异或出来的值在二进制表示下的第 $j$ 位为 $k$ 的情况下，其他连通块的异或的乘积之和。

比如下图的割边方式：

![](https://cdn.luogu.com.cn/upload/image_hosting/eyzbtxev.png)

$f_{i, j, k}$ 就记录着所有割边情况的乘积之和。

介绍好了状态，我们想一想怎么转移，对于每一条边 $(u, v)$，假设 $u$ 是 $v$ 的父亲节点。

因为我们要从上一个状态递推到这个状态，所以先将 $f_{u}$ 拷贝到一个临时数组 $g$，即 $g_{i, j} = f_{u, i, j}$，每次枚举新边的时候重新拷贝。

转移要分类讨论：

1. 首先，我们可以让 $v$ 所在连通块并入 $u$ 所在的连通块：

![](https://cdn.luogu.com.cn/upload/image_hosting/2x0n6yew.png)

对于将 $v$ 并入 $u$ 的部分，并且 $v$ 所在连通块的异或和为 $l$，$u$ 所在连通块的异或和为 $k$：

$$f_{u, j, k\oplus l} = \sum g_{j, k}\cdot f_{v, j, l}$$

2. 然后，我们也可以让 $v$ 还是一个独立的连通块，不要并入 $u$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ypj9ysqa.png)

我们可以计算出 $v$ 的贡献：$t = \sum\limits_{i = 0}^{63}2^if_{v,i,1}$。

然后：

$$f_{u, j, k} = \sum g_{j, k}\cdot t$$

我认为我讲的比较详细了，如果还不懂，建议先做一做[P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)。

## 代码

非常详细的注释，大家可以慢慢看。

```cpp
/*******************************
| Author:  SunnyYuan
| Problem: P9745 「KDOI-06-S」树上异或
| OJ:      Luogu
| URL:     https://www.luogu.com.cn/problem/P9745
| When:    2023-10-20 12:10:24
| 
| Memory:  512 MB
| Time:    2000 ms
*******************************/

#include <bits/stdc++.h>

using namespace std;
using i64 = long long;

const int N = 500010, mod = 998244353;

vector<int> e[N];           // 建图
i64 n, x[N];                // 存储信息
int f[N][64][2];            // DP
int pow2[64];               // pow2[i] 保存 2 的 i 次幂

void dfs(int u, int fa) {
    int tmp[64][2];         // 保存当前状态
    for (int to : e[u]) {   // 遍历每一条边
        if (to == fa) continue;// 是父节点，不退回去
        dfs(to, u);         // 走到子节点
        memcpy(tmp, f[u], sizeof(tmp));// 保存当前状态
        memset(f[u], 0, sizeof(f[u]));// 清空重新计算

        int ans_v = 0;      // 计算 to 所在子树可以给的贡献

        for (int j = 0; j < 64; j++) {// 对于每一位计算贡献（ans_v）
            (ans_v += 1ll * f[to][j][1] * pow2[j] % mod) %= mod;
        }

        for (int j = 0; j < 64; j++) {// 现在正在计算第 j 位的贡献
            for (int k = 0; k < 2; k++) {// 枚举 u 的第 j 位是 0 还是 1
                (f[u][j][k] += 1ll * ans_v * tmp[j][k] % mod) %= mod;// u 不让 to 所在连通块并进来
                for (int x = 0; x < 2; x++) {
                    (f[u][j][k ^ x] += 1ll * tmp[j][k] * f[to][j][x] % mod) %= mod;// u 让 to 所在连通块并进来，所以我们要枚举 to 的第 j 位是 0 还是 1
                }
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    pow2[0] = 1;            // 2 的 0 次幂是 1
    for (int i = 1; i < 64; i++) (pow2[i] = pow2[i - 1] + pow2[i - 1]) %= mod; // 初始化 2 的 i 次幂

    cin >> n;               // 点数
    for (int i = 1; i <= n; i++) cin >> x[i];// 输入点权
    for (int i = 2; i <= n; i++) {// 输入每一条边
        int to;
        cin >> to;
        e[to].push_back(i); // 建立双向边
        e[i].push_back(to);
    }

    for (int i = 1; i <= n; i++)// 第 i 个数字
        for (int j = 0; j < 64; j++)// 第 j 位
            f[i][j][x[i] >> j & 1] = 1;// 初始化 x[i]

    dfs(1, 0);              // 树形 dp

    i64 ans = 0;            // 答案
    for (int j = 0; j < 64; j++) {// 统计答案
        (ans += 1ll * f[1][j][1] * pow2[j] % mod) %= mod;
    }
    cout << ans << '\n';    // 输出答案
    return 0;
}
```

---

## 作者：wcyQwQ (赞：7)

思路自然的一道树形 dp，vp 时独立做出来了。

我们考虑设 $f_u$ 表示以 $u$ 为根的子树的答案，我们发现将 $u$ 和子节点 $v$ 合并不好转移，一般在处理异或运算发现不好转移的时候我们都会想到拆位，所以我们可以对 $u$ 所在的连通块拉出来单独拆位，也就是记 $g_{u, i, 0/1}$ 表示以 $u$ 所在连通块二进制第 $i$ 位是 $0/1$ 时，其他连通块的总贡献。这样设状态的好处是我们可以单独考虑 $u$ 所在的连通块对 $f_u$ 的贡献，不难得到 $f_u = \sum_{i} 2^ig_{u, i, 1}$。

接下来考虑如何转移，考虑新加进一个儿子 $v$，那么我们可以选择把 $u \to v$ 割掉，也可以把 $v$ 所在的二进制下第 $i$ 位为 $0/1$ 的连通块拼进来，不难得到
$$
g_{u, i, 0} \gets g_{u, i, 0}\cdot f_v + g_{u, i, 1} \cdot g_{v, i, 1} + g_{u, i, 0} \cdot g_{v, i, 0}
$$
$$
g_{u, i, 1} \gets g_{u, i, 1}\cdot f_v + g_{u, i, 1} \cdot g_{v, i, 0} + g_{u, i, 0} \cdot g_{v, i, 1}
$$
时间复杂度 $O(n\log V)$。

---

## 作者：听取MLE声一片 (赞：7)

显然是树上 dp。

以下令根节点为 $1$ 号节点。

首先考虑暴力做法。设状态 $f_{i,j}$ 表示以 $i$ 为根的子树内 $i$ 所在的连通块异或值为 $j$ 时的答案（不包括 $i$ 所在连通块），$g_i$ 表示以 $i$ 为根的子树内的答案（包括 $i$ 所在连通块）。

对于一个点 $u$，遍历其每一个儿子 $v$。对于每一个 $v$，边可以删也可以不删，不删的情况用类似背包的方式转移：

$$f_{u,s}=f_{u,s}\times g_v+\sum_x f_{u,s\oplus x}\times f_{v,x}$$

之后就是求出 $g_u$ 了，即强令 $u$ 和其父亲的边断掉，可以得出以下转移：

$$g_u=\sum_x f_{u,x}\times x$$

这样时间复杂度为 $O(nV)$，不能通过本题。

考虑拆位。观察发现第一个转移中每位之间互不干扰，而第二个转移的每一位可以分别贡献，所以可以进行拆位。

设状态 $f_{u,i,0/1}$ 表示以 $u$ 为根的子树内 $u$ 所在的连通块异或值的第 $i$ 位的异或值为 $0/1$ 时的答案，把以上对 $f$ 的转移对每一位展开，即为：

$$f_{u,i,0}=f_{u,i,0}\times g_v+f_{u,i,0}\times f_{v,i,0}+f_{u,i,1}\times f_{v,i,1}$$

$$f_{u,i,1}=f_{u,i,1}\times g_v+f_{u,i,0}\times f_{v,i,1}+f_{u,i,1}\times f_{v,i,0}$$

注意这两个转移是并行的，要先算出来再赋值。

关于 $g$ 的转移就可以写成：

$$g_u=\sum_i f_{u,i,1}\times 2^i$$

最终答案即为 $g_1$，时空复杂度均为 $O(n\log V)$。

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<set>
#include<bitset>
#include<ctime>
#include<random>
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N=5e5+10;
const int M=60;
const int mod=998244353;
int n,a[N],f[N][M][2],g[N];
vector<int>e[N];
void dfs(int u){
	for(int i=0;i<M;i++){
		if((a[u]>>i)&1)f[u][i][1]=1;
		else f[u][i][0]=1;
	}
	for(int v:e[u]){
		dfs(v);
		for(int i=0;i<M;i++){
			int x=(f[u][i][0]*g[v]%mod+f[u][i][0]*f[v][i][0]%mod+f[u][i][1]*f[v][i][1]%mod)%mod,y=(f[u][i][1]*g[v]%mod+f[u][i][0]*f[v][i][1]%mod+f[u][i][1]*f[v][i][0]%mod)%mod;
			f[u][i][0]=x;
			f[u][i][1]=y;
		}
	}
	for(int i=0;i<M;i++)
		g[u]=(g[u]+(1ll<<i)%mod*f[u][i][1]%mod)%mod;
}
signed main()
{
//	freopen("xor.in","r",stdin);
//	freopen("xor.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=2;i<=n;i++){
		int x=read();
		e[x].push_back(i);
	}
	dfs(1);
	cout<<g[1];
	return 0;
}
```


---

## 作者：Adelaide_Black (赞：4)

题目难点在于异或的处理，由于异或并不满足乘法分配律，因此不能够采用求和再相乘的方法 DP，得重新定义一个新状态。

新状态定义为 $dp_{i,j,0/1}$ 表示对于点 $i$ 所在的连通块，它的异或值的第 $j$ 位为 $0$ 或 $1$，这个状态下除了点 $i$ 所在的连通块以外的所有连通块的乘积。而 $f_i$ 则表示对于 $i$ 节点所在情况的所有连通块异或值的乘积和，即答案。

考虑状态如何转移？（我看很多题解没有提及这个，我想我可以在此基础上解释一下(虽然挺简单易懂的)）。

对于父节点 $u$ 和它的子节点 $v$，$u$ 表示的连通块是对于 $u$ 节点本身和在 $v$ 之前的子树的处理情况。而 $v$ 表示的连通块则是对于 $v$ 节点本身这棵子树的连通块处理情况。考虑两个节点之间的关系。

如果连边则表示要将 $u$ 和 $v$ 所在的连通块连起来。因此有:

$dp_{u,j,0} \gets dp_{u,j,0} \times dp_{v,j,0} +dp_{u,j,1} \times dp_{v,j,1} $

表示对于两个连通块的第 $j$ 位，要使连边之后的新连通块的第 $j$ 位为 $0$，我们要将两个相同的位异或在一起。且他们连成一个连通块后，其余所有与该连通块不连通的连通块都要相乘。即 $u$ 所在的部分乘上 $v$ 所在的部分。

同理可得对于新连通块第 $j$ 位为 $1$ 的情况，需要 $u$ 和 $v$ 所在的两个连通块的第 $j$ 位不同，有：

$dp_{u,j,1} \gets dp_{u,j,1} \times dp_{v,j,0} +dp_{u,j,0} \times dp_{v,j,1} $

连边的情况讨论完了，接着讨论不连边的情况。

如果不连边，就将两个连通块的值相乘计算，又由于是以 $u$ 为父节点，因此不包含 $u$ 所在的连通块，但 $v$ 子树内所有的连通块都不在 $u$ 所在的连通块之中，因此用 $f_v$ 表示所有连通块的价值进行计算。

$dp_{u,j,0} \gets dp_{u,j,0} \times f_v$

$dp_{u,j,1} \gets dp_{u,j,1} \times f_v$

实际计算的时候，要将以上两种情况综合同时计算，最后，显然有 $f_u \gets \sum_{j}2^j \times dp_{u,j,1}$。

```c
#include<iostream>
#include<cstdio>
#include<cmath>
#define Mod 998244353
#define maxn 500005
#define ll long long
using namespace std;
ll n,a[maxn];
int head[maxn],nex[maxn],to[maxn],tot;
int dp[maxn][65][2];
ll f[maxn],p[65];
void dfs(int x){
	for(int i=0;i<=64;i++) dp[x][i][(a[x]>>i)&1]=1;
	for(int i=head[x];i;i=nex[i]){
		int v=to[i];
		dfs(v);
		for(int j=0;j<=64;j++){
			ll a1=dp[x][j][0],a2=dp[x][j][1];
			dp[x][j][0]=(a1*f[v]%Mod+a1*dp[v][j][0]%Mod+a2*dp[v][j][1]%Mod)%Mod;
			dp[x][j][1]=(a2*f[v]%Mod+a2*dp[v][j][0]%Mod+a1*dp[v][j][1]%Mod)%Mod;
		}
	}
	for(int j=0;j<=64;j++) f[x]+=(p[j]*dp[x][j][1]%Mod),f[x]%=Mod;
	return;
}
int main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	p[0]=1;
	for(int i=1;i<=63;i++) p[i]=p[i-1]*2,p[i]%=Mod;
	for(int i=2;i<=n;i++){
		int fa;
		scanf("%d",&fa);
		nex[++tot]=head[fa],head[fa]=tot,to[tot]=i;
	}
	dfs(1);
	cout<<f[1]<<endl;
	return 0;
} 
```

---

## 作者：shinkuu (赞：3)

感觉是那种，看到题就能猜到大概思路的题。

首先给题目条件增加限制：考虑 $x_i\leq 7$ 的时候怎么做。这启示我们思考一个和值域相关的做法。

很容易想到一个树形 dp：设 $dp_{u,i}$ 为在以 $i$ 为根的子树中，$u$ 所在连通块异或和为 $i$ 时方案数与其他连通块各自的异或和之积的乘积。则有：

$$dp_{u,i\oplus j}+dp_{u,i}\times dp_{v,j}\to dp_{u,i\oplus j}$$

$$dp_{u,i}\times dp_{v,j}\times j\to dp_{u,i}$$

以树上背包的形式合并。

以上做法能得到 36pts。考虑怎样拓展至值域更大的情况。

异或具有很好的性质。可以考虑拆开每一位分别算。状态变为 $dp_{u,i,0/1}$ 表示在以 $i$ 为根的子树中，$u$ 所在连通块异或和的第 $i$ 位为 $0/1$ 时方案数与其他连通块各自的异或和之积的乘积。

再来分析两种转移：第一种没太大变化，向两个数当前位的异或值转移。第二种则有一点变化。可以考虑乘法分配律暴力拆开，发现每个为 $1$ 的位都会对当前位的 dp 值有贡献。所以便变成：

$$dp_{u,i,p\oplus q}+dp_{u,i,p}\times dp_{v,i,q}\to dp_{u,i,p\oplus q}$$

$$dp_{u,i,p}\times dp_{v,j,1}\times 2^j\to dp_{u,i,p}$$

这样就有 84pts 了。最后一个转移是 $O(\log^2 V)$ 的，发现可以再用分配律合起来，就变成 $O(\log V)$ 的了。总复杂度 $O(n\log V)$。

```cpp
int n,m,dp[N][64][2],f[64][2];
ll c[N];
int tot,head[N];
struct node{
	int to,nxt;
}e[N<<1];
il void add(int u,int v){
	e[++tot]={v,head[u]};
	head[u]=tot;
}
il int Mod(int x,int y){
	((x+=y)>=mod)&&(x-=mod);
	return x;
}
void dfs(int u,int fa){
	rep(i,0,62){
		dp[u][i][(c[u]>>i)&1ll]=1;
	}
	go(i,u){
		int v=e[i].to;
		if(v==fa)
			continue;
		dfs(v,u);
		int sum=0;
		rep(j,0,62){
			sum=Mod(sum,1ll*dp[v][j][1]*((1ll<<j)%mod)%mod);
		}
		mems(f,0);
		rep(j,0,62){
			rep(p,0,1){
				rep(q,0,1){
					f[j][p^q]=Mod(f[j][p^q],1ll*dp[u][j][p]*dp[v][j][q]%mod);
				}
				f[j][p]=Mod(f[j][p],1ll*dp[u][j][p]*sum%mod);
			}
		}
		rep(j,0,62)rep(k,0,1){
			dp[u][j][k]=f[j][k];
		}
	}
}
void Yorushika(){
	scanf("%d",&n);
	rep(i,1,n){scanf("%lld",&c[i]);}
	rep(i,2,n){
		int v;scanf("%d",&v);
		add(v,i),add(i,v);
	}
	dfs(1,0);
	int ans=0;
	rep(i,0,62){ans=Mod(ans,1ll*dp[1][i][1]*((1ll<<i)%mod)%mod);}
	printf("%d\n",ans);
}
signed main(){
	int t=1;
	//	scanf("%d",&t);
	while(t--)
		Yorushika();
}
```

---

## 作者：igAC (赞：2)

# $\text{Description}$

[link](https://www.luogu.com.cn/problem/P9745)

简要题意：

给定一棵树，每个点有点权，每条边选择删除或不删除。

定义一种方案的价值为每个连通块的异或和的乘积。

易知有 $2^{n-1}$ 种方案，求这 $2^{n-1}$ 种方案的价值之和对 $998244353$ 取模的结果。

# $\text{Solution}$

考虑拆位。

设 $f_{i,j,0/1}$ 表示以 $i$ 为根的子树的所有方案价值在二进制下第 $j$ 位是 $0/1$ 的数量。

设 $g_i$ 表示以 $i$ 为根的子树的答案。

那么我们考虑删除与不删除的两种操作：

- 删除：

>设 $v \in son_u$ 显然 $f_{u,i,0/1}$ 可以直接乘上 $g_v$，因为题目定义的价值是一个 $\prod$ 的形式。

- 不删除：

>设 $v \in son_u$，若不删除，连通块内是异或和的形式，那么就要考虑这一位相同或者不相同：
>
>$f_{u,i,0} \leftarrow f_{u,i,0} \times f_{v,i,0} + f_{u,i,1} \times f_{v,i,1}$（此位相同）
>
>$f_{u,i,1} \leftarrow f_{u,i,0} \times f_{v,i,1} + f_{u,i,1} \times f_{v,i,0}$（此位不同）

转移的时候要注意的 $f_{u,i,0/1}$ 都要用未进行此次转移前的值。

由 $g$ 的定义我们知道 $g_u = \sum_{i=0}^{V}f_{u,i,1} \times 2^i$，其中 $V=\log maxval$，可以设为 $60$。

具体实现可参考代码。

# $\text{Code}$

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 500005
#define M 61
#define Mod 998244353
using namespace std;
int read(){
	int x=0,f=1,ch=getchar();
	for(;!isdigit(ch);ch=getchar()) f=(ch=='-')?-1:1;
	for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);
	return x*f;
}
int n,a[N],head[N],tot,f[N][M][2],g[N],pw[M]={1};
vector<int>G[N];
void dfs(int x,int fa){
	for(int i=60;i>=0;--i) f[x][i][a[x]>>i&1]=1;
	for(int y:G[x]){
		if(y==fa) continue;
		dfs(y,x);
		for(int i=60;i>=0;--i){
			int f0=f[x][i][0],f1=f[x][i][1];
			f[x][i][0]=((f0*g[y])%Mod+(f0*f[y][i][0])%Mod+(f1*f[y][i][1])%Mod)%Mod;
			f[x][i][1]=((f1*g[y])%Mod+(f1*f[y][i][0])%Mod+(f0*f[y][i][1])%Mod)%Mod;
		}
	}
	for(int i=60;i>=0;--i) g[x]=(g[x]+(f[x][i][1]*pw[i])%Mod)%Mod;
}
signed main(){
	n=read();
	for(int i=1;i<=n;++i) a[i]=read();
	for(int i=2;i<=n;++i){
		int x=read();
		G[x].push_back(i);
		G[i].push_back(x);
	}
	for(int i=1;i<=60;++i) pw[i]=(pw[i-1]<<1ll)%Mod;
	dfs(1,0);
	printf("%lld",g[1]);
	return 0;
}
```

---

## 作者：dengjunhaodejia09 (赞：1)

### 闲话
本以为不可做，但后来才发现是动态规划做少了。
### 正文
首先，看到这一道题，就发现是计数，但是二进制的话是不好用数学方法，考虑 dp。

第一步，设计状态。怎样才能既能找到答案又能转移呢？对于树上一个节点来说，我们其实只要知道当前连通块的权值与子树内其他的连通块权值之和就行了。因为在一个个儿子转移之时，当前节点连通块的权值会时时变化，所以要单独维护，此时就能从儿子节点是否是同一个连通块转移即可，这个状态的正确性就是知道当前连通块权值，存了其他连通块权值乘积的和，就能描述了，此时状态为 $dp_{i,j}$ 表示以 $i$ 为根，当前节点连通块权值为 $j$ 的其他连通块的权值和。但是这是平方的，但很多时候二进制可以拆位维护。那么每个点，存一下当前连通块每一位的状态即可，当我们记录了子树权值总和时，每个二进制位的转移便互不影响，此时就可转移了，此时状态为 $dp_{i,j,k}$ 表示以 $i$ 为根，当前节点连通块权值第 $j$ 位状态为 $k$ 的其他连通块的权值和。

第二步，转移。这一步不难，且其他题解已讲解的十分详细，就不加赘述了。


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int mod=998244353;
int f[500005][61][2],dp[500005],a[500005];
vector<int> g[500005];
void dfs(int cur){
    for(int i=0;i<=60;i++){
        if(a[cur]&(1ll<<i)){
            f[cur][i][1]=1;
        }else{
            f[cur][i][0]=1;
        }
    }
    for(int i=0;i<g[cur].size();i++){
        dfs(g[cur][i]);
    }
    for(int wei=0;wei<=60;wei++){
        for(int i=0;i<g[cur].size();i++){
            int v=g[cur][i];
            int y0=f[cur][wei][0],y1=f[cur][wei][1];
            f[cur][wei][0]=(1ll*y0*(f[v][wei][0]+dp[v])+1ll*y1*(f[v][wei][1]))%mod;
            f[cur][wei][1]=(1ll*y0*(f[v][wei][1])+1ll*y1*(f[v][wei][0]+dp[v]))%mod;
        }
    }
    for(int i=0;i<=60;i++){
        dp[cur]+=1ll*(1ll<<i)%mod*f[cur][i][1];
        dp[cur]%=mod;
    }
    
}
signed main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=2;i<=n;i++){
        int fa;
        cin>>fa;
        g[fa].push_back(i);
    }
    dfs(1);
    cout<<dp[1];
    return 0;
}
```

---

## 作者：xyzfrozen (赞：1)

Task $3\sim 11$

考虑到值域很小，我们可以强行把值域加入 $dp$ 状态。

同时显然一个连通块的贡献在 $lca$ 处计算，由于 $\oplus$ 只满足 $(a\oplus b)\oplus c=a\oplus (b \oplus c)$ 所以我们还需要知道剩下块的乘积。

设 $f_{x,i}$ 表示，$x$ 为 $lca$ 的连通块异或和为 $i$，其它子树内连通块异或和的乘积。

暴力枚举值域转移 $O(nW^2)$ ，$W$ 为值域。

精简版代码：

```cpp
void dfs(int x)
{
	f[x][w[x]]=1;
	int g[M];
	go(v)
	{
		dfs(v);
		memcpy(g,f[x],sizeof g);
		memset(f[x],0,sizeof f[x]);
		for(int i=0;i<=7;i++)
			for(int j=0;j<=7;j++)
			{
				mod(f[x][i^j],f[v][j]*g[i]%Q);
				mod(f[x][i],g[i]*f[v][j]%Q*j%Q);
			}
	}
}

signed main()
{
	dfs(1);
	for(int i=0;i<=7;i++)
		mod(ans,f[1][i]*i%Q);
}
```

------

考虑 $\oplus $ 的和，每一位只用管是 $0/1$，直接拆位算贡献，值域压缩到 $\log W$。

$$
\begin{aligned}
f'_{x,i,k} \gets f_{x,i,k} \times 2^l \times f_{v,l,1}\\
f'_{x,i,k\oplus l} \gets f_{x,i,k} \times f_{v,i,l}
\end{aligned}
$$

$O(n\log^2 W)$，考虑到 $2^l \times f_{v,i,l}$ 可以预处理，降为 $O(n\log W)$。


```cpp
#include<bits/stdc++.h>
#define int long long
#define pt putchar(' ')
#define nl puts("")
#define pi pair<int,int>
#define pb push_back
#define go(it) for(auto &it:as[x])
using namespace std;

const int N=5e5+10,M=61,Q=998244353;
int n,u,v,ans;
int w[N],f[N][M][2],p[M];
vector<int> as[N];

int fr(){
    int x=0,flag=1;
    char ch=getchar();
    while(ch<'0' || ch>'9'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9'){
        x=x*10+(ch-'0');
        ch=getchar();
    }
    return x*flag;
}
void fw(int x){
	if(x<0) putchar('-'),x=-x;
    if(x>9) fw(x/10);
    putchar(x%10+'0');
}
int max(int a,int b){return a>b?a:b;}
int min(int a,int b){return a<b?a:b;}
void mod(int &x,int y){if((x+=y)>=Q) x-=Q;}

void dfs(int x)
{
	for(int i=0;i<=60;i++)
		f[x][i][(w[x]>>i)&1]=1;
	int g[M][2],s=0;
	go(v)
	{
		dfs(v);
		memcpy(g,f[x],sizeof f[x]);
		memset(f[x],0,sizeof f[x]);
		s=0;
		for(int i=0;i<=60;i++)
			mod(s,p[i]*f[v][i][1]%Q);
		for(int i=0;i<=60;i++)
			for(int k=0;k<=1;k++)
			{
				mod(f[x][i][k],s*g[i][k]%Q);
				for(int l=0;l<=1;l++)
					mod(f[x][i][k^l],g[i][k]*f[v][i][l]%Q);
			}
	}
}

signed main()
{
	n=fr();
	p[0]=1;
	for(int i=1;i<M;i++) p[i]=p[i-1]*2%Q;
	for(int i=1;i<=n;i++) w[i]=fr();
	for(int i=2;i<=n;i++)
	{
		u=fr(),v=i;
		as[u].pb(v);
	}
	dfs(1);
	for(int i=0;i<=60;i++)
		mod(ans,f[1][i][1]*p[i]%Q);
	fw(ans);
	return 0;
}
```

---

## 作者：lyhqwq (赞：1)

# Solution

喵喵题。

首先从链的部分分入手。

考虑令 $f_i$ 表示前 $i$ 个数的答案，有

$$f_i=\sum_{j=0}^{i-1}f_j\times(s_i \oplus s_j)$$

其中 $s$ 为前缀异或和。

对于为运算的题目，考虑拆位优化。

$f_j$ 的第 $k$ 位对 $f_i$ 有贡献当且仅当 $s_i \oplus s_j$ 的第 $k$ 位为 $1$。

考虑令 $g_{i,k,0/1}$ 表示到 $i$ 为止，所有 $s_i\oplus s_j$ 的第 $k$ 位为 $0/1$ 的 $f_j$ 的和，有

$$f_i=\sum_{k=0}g_{i,k,1}\times2^k$$

考虑将其推广到树上。

令 $f_u$ 表示以 $u$ 为根的子树的答案，$g_{u,i,0/1}$ 表示以 $u$ 为根的子树，$u$ 所在的连通块的权值第 $i$ 位为 $0/1$，其他部分的答案的和。对于目前的儿子 $v$，有

$$g_{u,i,0}=g_{u,i,0}\times f_v+g_{u,i,0}\times g_{v,i,0}+g_{u,i,1}\times g_{v,i,1}$$

$$g_{u,i,1}=g_{u,i,1}\times f_v+g_{u,i,0}\times g_{v,i,1}+g_{u,i,0}\times g_{v,i,1}$$

$$f_u=\sum_{i=0}g{u,i,1}\times2^i$$

时间复杂度 $O(n\log V)$，可以通过。

# Code 
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=500005;
const int M=60;
const int Mod=998244353;
struct edge{
    int v,nxt;
}edge[N<<1];
int head[N],cnt;
int n;
int a[N],Pow[M];
int f[N],g[N][M][2];
void addedge(int u,int v){
    edge[++cnt].v=v,edge[cnt].nxt=head[u],head[u]=cnt;
}
void dfs(int u,int fa){
    for(int i=0;i<M;i++) g[u][i][(a[u]>>i)&1]=1;
    for(int i=head[u];i;i=edge[i].nxt){
        int v=edge[i].v;
        if(v==fa) continue;
        dfs(v,u);
        for(int k=0;k<M;k++){
            int g0=g[u][k][0],g1=g[u][k][1];
            g[u][k][0]=(g0*f[v]%Mod+g0*g[v][k][0]%Mod+g1*g[v][k][1]%Mod)%Mod;
            g[u][k][1]=(g1*f[v]%Mod+g0*g[v][k][1]%Mod+g1*g[v][k][0]%Mod)%Mod;
        }
    }
    for(int i=0;i<M;i++) f[u]=(f[u]+g[u][i][1]*Pow[i]%Mod)%Mod;
}
signed main(){
    scanf("%lld",&n);
    Pow[0]=1;
    for(int i=1;i<M;i++) Pow[i]=Pow[i-1]*2%Mod;
    for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    for(int i=2;i<=n;i++){
        int fa;
        scanf("%lld",&fa);
        addedge(i,fa);
        addedge(fa,i);
    }
    dfs(1,0);
    printf("%lld\n",f[1]);
    return 0;
}

```


---

## 作者：Mirasycle (赞：0)

这种树上联通块为基准的计数好像还不太会，赶紧来补一下。

先考虑链部分分以此来引导至正解。这就是一个序列上的问题了。

设 $f_i$ 为前 $i$ 个数的答案，$s_i= \bigotimes_{i=1}^n a_i$。显然 $f_{i}=\sum\limits_{j=0}^{i-1}(s_{i}\bigotimes s_{j}) \times f_{j}$，此时计算复杂度为 $(n^2)$。

发现这是一个类似前缀和的东西，但是因为要异或所以不可直接前缀和统计。于是我们可以对二进制的每一位进行前缀和。设 $g_{i,j,k}$ 为前 $i$ 位中，满足 $s$ 的第 $j$ 位为 $k$ 的 $f$ 的前缀和。时间复杂度 $O(n\log V)$。

链部分分代码如下

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=5e5+10;
const int maxlog=64;
const int mod=998244353;
long long g[maxn][maxlog][2],f[maxn];
long long a[maxn],s[maxn],pow[maxlog];
int main(){
	int n; cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) s[i]=s[i-1]^a[i];
	for(int i=1;i<=n;i++) f[i]=s[i];
	pow[0]=1;
	for(int i=1;i<maxlog;i++) pow[i]=(pow[i-1]*2)%mod;
	for(int i=1;i<=n;i++){
		for(int j=0;j<maxlog;j++){
			int x=(s[i]>>j)&1; x^=1;
			f[i]=(f[i]+g[i-1][j][x]*pow[j]%mod)%mod;
		}
		for(int j=0;j<maxlog;j++){
			int x=(s[i]>>j)&1;
			g[i][j][x]=(g[i-1][j][x]+f[i])%mod;
			g[i][j][x^1]=g[i-1][j][x^1];
		}
	}
	cout<<f[n];
	return 0;
}
```

现在考虑正解，设 $f_u$ 表示 $u$ 子树内的答案。由于贡献是联通块，需要在子树内部断边算向下的贡献，我们不要强行去算，需要再开一个辅助数组 $g_u$ 表示 $u$ 子树内除去 $u$ 所在联通块，其他所有联通块的贡献。这样子每次转移 $v\to u$ 就可以很方便地把 $v$ 并入 $u$ 联通块来快速算贡献。

* 直接断开 $v\to u$，

$$g_{u,i,0}\gets g_{u,i,0}\times f_v$$

* 将 $v$ 所在联通块并入 $u$，这样子与 $v$ 之前接壤的联通块就变成与 $u$ 接壤了。

$$g_{u,i,0}\gets g_{u,i,0}\times g_{v,i,0}+g_{u,i,1}\times g_{v,i,1}$$

对于 $g_{u,i,1}$ 的转移同理。

时间复杂度 $O(n\log V)$。


```cpp
#include<bits/stdc++.h>
#define pb emplace_back
using namespace std;
typedef long long ll;
const int maxn=5e5+10;
const int maxlog=64;
const int mod=998244353;
int g[maxn][maxlog][2],n;
int pw[maxlog],f[maxn];
vector<int> G[maxn]; ll a[maxn];
void add(int &x,int y){ x=x+y>=mod?x+y-mod:x+y; }
void dfs(int u,int fa){
	for(int i=0;i<maxlog;i++) g[u][i][(a[u]>>i)&1]=1;
	for(auto v:G[u]){
		dfs(v,u);
		for(int i=0;i<maxlog;i++){
			int g0=g[u][i][0],g1=g[u][i][1];
			g[u][i][0]=1ll*g0*f[v]%mod;
			add(g[u][i][0],1ll*g1*g[v][i][1]%mod);
			add(g[u][i][0],1ll*g0*g[v][i][0]%mod);
			g[u][i][1]=1ll*g1*f[v]%mod;
			add(g[u][i][1],1ll*g1*g[v][i][0]%mod);
			add(g[u][i][1],1ll*g0*g[v][i][1]%mod);
		}
	}
	for(int i=0;i<maxlog;i++) add(f[u],1ll*pw[i]*g[u][i][1]%mod);
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=2;i<=n;i++){
		int fa; cin>>fa;
		G[fa].pb(i);  
	}
	pw[0]=1; for(int i=1;i<maxlog;i++) pw[i]=(pw[i-1]<<1)%mod;
	dfs(1,0); cout<<f[1];
	return 0;
}
```

---

## 作者：FRZ_29 (赞：0)

## 树上异或

[题面](https://www.luogu.com.cn/problem/P9745)

[也许更好的阅读体验](https://www.cnblogs.com/FRZ29/p/18415215)

### 分析

树形 DP 题。

考虑一颗子树内部的某种割边方式，假设其被分为 $n$ 个连通块，每个连通块的权值分别为 $a_1, a_2, \dots, a_n$，那么该子树在这种割边方式下对答案的贡献就为 $\prod_{i = 1}^{n} a_i$。

因此就可以从叶子向根不断合并，求出每种割边状态的值，时间复杂度为 $O(2^{n - 1}n)$，期望得分 $8$ 分。

这启示往树形 DP 的方向思考。

将每次定下割边的方法转变，考虑在 DP 过程中通过将两个连通块连接到一起，去遍历每一种状态。

这样，每回溯到一个点。

1. 遍历该点的子树。
2. 把与该点之间存在割边的连通块与该点之前所找到的连通块合并。
3. 每次合并后求出该情况的贡献（如图，将蓝色连通块的权值异或在一起，然后计算结果）。![](https://s2.loli.net/2024/09/15/hvnaNp6PYiTo7ft.png)

实现困难，时间复杂度极高。

因为连通块对答案的贡献是 $\prod_{i = 1} ^{n} a_i$ 的形式，故某子树除去被合并的连通块后不同情况产生的贡献是可以累加的。（答案是 $a_1 b_1+\dots+a_1 b_n+a_2 b_1+\dots+a_n b_n$，即 $(a_1+\dots+a_n)(b_1+\dots+b_n)$）。

而合并连通块却无法这样优化。

对此，有一种方法能够快速地合并连通块——拆位。

具体来说，定义 $f_{u, i, j}$ 表示以 $u$ 所在的连通块的权值第 $i$ 位为 $j$ 时以 $u$ 为根节点的子树除了$u$ 所在的连通块其他连通块的乘积的值，定义 $g_u$ 表示以 $u$ 为根节点的子树对答案的贡献。

容易得到：$$g_u = \sum_{i = 0}^{63}f_{u, i, 1} \times 2^i$$，即 $u$ 所在连通块第 $i$ 位为 $1$ 时，所有的割边方案的贡献。

故仅需考虑 $f_{u, i, j}$ 的转移。

考虑当前遍历到 $u$ 的儿子节点 $v$，则。

1. 如果不合并，则 $v$ 的子树全都与 $u$ 所在的连通块无关，那么 $g_v$ 全都要乘到 $f_{u, i, 0}$。
2. 合并第 $i$ 位为 $1$ 的情况，如果连通块原本为 $1$ ，则与该子树中第 $i$ 位为 $0$ 的异或后第 $i$ 位仍然为 $1$。否则为与第 $i$ 位为 $1$ 的连通块异或。
3. 第 $i$ 位为 $0$ 则恰好相反。 

即：
$$
f_{u, i, 0} = f_{u, i, 0} \times g_{v} + f_{v, i, 0} \times f_{u, i, 0} + f_{v, i, 1} \times f_{u, i, 1}
$$

$$
f_{u, i, 1} = f_{u, i, 1} \times g_v + f_{v, i, 0} \times f_{u, i, 1} + f_{v, i, 1} \times f_{u, i, 0}
$$

答案为 $g_1$。

### 注意

本题空间较小，动态规划数组开 `long long` 会爆。

```cpp
#include <iostream>
#include <climits>
#include <cstdio>
#include <ctime>
typedef long long LL;

using namespace std;

void RD() {}
template<typename T, typename... U> void RD(T &x, U&... arg) {
    x = 0; int f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + ch - '0', ch = getchar();
    x *= f; RD(arg...);
}

const int N = 5e5 + 5;
const int mod = 998244353;

#define PRINT(x) cout << #x << "=" << x << "\n"
#define LF(i, __l, __r) for (int i = __l; i <= __r; i++)
#define RF(i, __r, __l) for (int i = __r; i >= __l; i--)

int head[N], Next[N << 1], ver[N << 1], tot = 1;
int n, f[N][65][2], g[N];
LL a[N];

void add(int u, int v) {
    ver[++tot] = v;
    Next[tot] = head[u], head[u] = tot;
}

void dfs(int u, int _f) {
    LF(i, 0, 63) f[u][i][a[u] >> i & 1] = 1;
    
    for (int i = head[u]; i; i = Next[i]) {
        int v = ver[i];
        if (v == _f) continue;
        dfs(v, u);

        LF(i, 0, 63) {
            LL t0 = f[u][i][0], t1 = f[u][i][1];
            f[u][i][0] = (t0 * g[v] + t0 * f[v][i][0] + t1 * f[v][i][1]) % mod;
            f[u][i][1] = (t1 * g[v] + t1 * f[v][i][0] + t0 * f[v][i][1]) % mod;
        }
    }

    LF(i, 0, 63) g[u] = (g[u] + (1LL << i) % mod * f[u][i][1]) % mod;
}

int main() {
    RD(n);
    LF(i, 1, n) RD(a[i]);
    LF(u, 2, n) {
        int v; RD(v);
        add(u, v), add(v, u);
    }
    dfs(1, 0);
    printf("%d", g[1]);
    return 0;
}
```

---

## 作者：TernaryTree (赞：0)

就直接嗯 dp。

设 $f_{u,i,d}$ 表示 $u$ 为根的子树内，满足 $u$ 所在连通块的第 $i$ 位为 $d$ ，除去 $u$ 所在连通块的其余连通块的乘积在所有情况下的和。

然后为了方便转移记 $g_u$ 为 $u$ 子树的答案。

转移。直接从选儿子的角度不好转移，考虑一个一个把儿子挂上来。

一开始没有儿子，$f_{u,i,f(a_u,i)}=1$，否则为 $0$，其中 $f(x,i)$ 表示 $x$ 二进制下第 $i$ 位的值。

然后一个一个加儿子。加一个儿子，可以选择断开到儿子的这条边，也可以选择连上这条边。状态转移为：

$$
\begin{aligned}
f_{u,i,0}&=\mathop{f_{u,i,0}\cdot g_v}\limits_{\text{不连这条边}}+\mathop{f_{u,i,0}\cdot f_{v, i, 0}}\limits_{\text{连上这条边，底下原有的连通块第 $\tiny i$ 位为 $\tiny 0$}}+\mathop{f_{u,i,1}\cdot f_{v, i, 1}}\limits_{\text{连上这条边，底下原有的连通块第 $\tiny i$ 位为 $\tiny 1$}} \\
f_{u,i,1}&=\mathop{f_{u,i,1}\cdot g_v}\limits_{\text{不连这条边}}+\mathop{f_{u,i,1}\cdot f_{v, i, 0}}\limits_{\text{连上这条边，底下原有的连通块第 $\tiny i$ 位为 $\tiny 0$}}+\mathop{f_{u,i,0}\cdot f_{v, i, 1}}\limits_{\text{连上这条边，底下原有的连通块第 $\tiny i$ 位为 $\tiny 1$}}
\end{aligned}
$$

注意等号右边的 $f_{u,i,0},f_{u,i,1}$ 是上一个儿子及以前的 $f$ 值，不能直接转移，需要存在 $tmp$ 中转移。

随后更新 $g_u$ 值为 $\sum\limits_{d=0}^{\log V} 2^d\cdot f_{u,i,1}$ 即可。

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int maxn = 5e5 + 10;
const int maxd = 61;
const int mod = 998244353;

int n;
int a[maxn];
int p[maxn];
vector<int> tr[maxn];
int f[maxn][maxd][2];
int g[maxn];
int tmp[maxd][2];

void dfs(int u) {
	for (int v : tr[u]) dfs(v);
	memset(tmp, 0, sizeof(tmp));
	for (int i = 0; i < maxd; i++) f[u][i][a[u] >> i & 1] = tmp[i][a[u] >> i & 1] = 1;
	for (int v : tr[u]) {
		for (int i = 0; i < maxd; i++) {
			f[u][i][0] = (tmp[i][0] * ((g[v] + f[v][i][0]) % mod) % mod + tmp[i][1] * f[v][i][1] % mod) % mod;
			f[u][i][1] = (tmp[i][1] * ((g[v] + f[v][i][0]) % mod) % mod + tmp[i][0] * f[v][i][1] % mod) % mod;
		}
		for (int i = 0; i < maxd; i++) {
			tmp[i][0] = f[u][i][0];
			tmp[i][1] = f[u][i][1];
		}
	}
	for (int i = 0; i < maxd; i++) g[u] = (g[u] + (1ll << i) % mod * f[u][i][1] % mod) % mod;
}

signed main() {
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 2; i <= n; i++) cin >> p[i], tr[p[i]].push_back(i);
	dfs(1);
	cout << g[1] << endl;
	return 0;
}
```

---

## 作者：CuCl4Loliko (赞：0)

### Preface 

考场上一眼拆位，想了想好像不太对，直接把拆位毙了，写了个 36 分位运算卷积。。。

### Problem

给你一棵树，点有点权，定义一种断边方案的权值为所有连通块的点权异或和的乘积，求所有断边方案的权值总和。

### Solution

#### 算法 1

直接枚举所有断边方式，共 $2^{n-1}$ 种，暴力计算其权值。复杂度约为 $O(n 2^{n-1})$，可以通过测试点 $1-2$，期望得分 $8pts$。

#### 算法 2

计数题考虑 DP。

设状态 $f_{u,k}$ 表示考虑完节点 $u$ 的子树，节点 $u$ 所在的连通块的当前的异或值为 $k$ 时的总权值。

易得转移方程式

若不断边，

$$f_{u,k} = \sum_{i \oplus j =k} f_{u,i} \times f_{v,j}$$

若断边，

$$f_{u,k} = \sum f_{u,k} + j\times f_{v,j}$$

直接在树上 DP 即可。复杂度为 $O(n V^2)$，其中 $V$ 为值域，可以通过测试点 $3-11$，结合上文算法期望得分 $44pts$。

#### 算法 2.5

注意到算法 2 的 DP 形式是一个位运算卷积的形式，直接用 FWT 进行优化，复杂度为 $O(n V \log V)$，可以继续通过测试点 $12-16$，结合上文算法期望得分 $64pts$。

#### 算法 3

上个算法的状态数已经达到了 $n V$，需要优化状态设计。

注意到，在同一个连通块中，权值的每一位对答案的贡献是独立的，考虑拆位。

设 $f_{u,i,0/1}$ 表示考虑完节点 $u$ 的子树，节点 $u$ 所在的连通块的当前的异或值的第 $i$ 位为 0 或 1 时的总权值。

若不断边，则 

$$f_{u,i,0} = \sum f_{u,i,0} \times f_{v,i,0} + f_{u,i,1} \times f_{v,i,1}$$

$$f_{u,i,1} = \sum f_{u,i,1} \times f_{v,i,0} + f_{u,i,0} \times f_{v,i,1}$$

若要断开边，则

$$f_{u,i,0} = \sum f_{u,i,0} \times f_{v,j,1} \times 2^j$$

$$f_{u,i,1} = \sum f_{u,i,1} \times f_{v,j,1} \times 2^j$$

直接计算的复杂度是 $O(n\log^2 V)$，可以使用前缀和加预处理 2 的幂次对第二种转移进行优化，复杂度为 $O(n\log V)$，可以通过所有测试点，期望得分 $100pts$。

此题空间只有 512MB，注意优化空间。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=5e5+5,logv=63,MOD=998244353;
struct egde{
	int to,nxt;
}e[maxn];
int head[maxn],_;
void adde(int u,int v)
{
	e[++_].to=v;
	e[_].nxt=head[u];
	head[u]=_;
}

int f[maxn][64][2];
int g[maxn][64][2];
int fa[maxn],p[maxn],n;
int sum[maxn];
long long a[maxn];

void dfs(int u)
{
	for(int i=0;i<=logv;i++)
		f[u][i][(a[u]>>i)&1]=1;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		dfs(v);
		for(int i=0;i<=logv;i++)
		{
			g[u][i][0]=f[u][i][0];
			g[u][i][1]=f[u][i][1];
			f[u][i][0]=f[u][i][1]=0;
		}
		for(int i=0;i<=logv;i++)
		{
			f[u][i][0]=(f[u][i][0]+1ll*g[u][i][0]*f[v][i][0]%MOD)%MOD;
			f[u][i][0]=(f[u][i][0]+1ll*g[u][i][1]*f[v][i][1]%MOD)%MOD;
			f[u][i][1]=(f[u][i][1]+1ll*g[u][i][1]*f[v][i][0]%MOD)%MOD;
			f[u][i][1]=(f[u][i][1]+1ll*g[u][i][0]*f[v][i][1]%MOD)%MOD;
		}
		for(int i=0;i<=logv;i++)
		{
			f[u][i][0]=(f[u][i][0]+1ll*g[u][i][0]*sum[v]%MOD)%MOD;
			f[u][i][1]=(f[u][i][1]+1ll*g[u][i][1]*sum[v]%MOD)%MOD;
		}
	}
	for(int i=0;i<=logv;i++)
		sum[u]=(sum[u]+1ll*f[u][i][1]*p[i]%MOD)%MOD;
}

signed main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	for(int i=2;i<=n;i++)
		scanf("%d",&fa[i]),adde(fa[i],i);
	p[0]=1;
	for(int i=1;i<=logv;i++)
		p[i]=1ll*p[i-1]*2%MOD;
	dfs(1);
	printf("%d",sum[1]);
	return 0;
}
```

---


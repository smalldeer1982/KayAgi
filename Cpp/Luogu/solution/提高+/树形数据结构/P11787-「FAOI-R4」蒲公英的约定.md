# 「FAOI-R4」蒲公英的约定

## 题目背景

**[背景部分或许更好的阅读体验](https://www.luogu.com.cn/article/bz5b7xlo)**

**提示：题目背景与题意并无显著关联。**

$$ 1 $$

“怎么又来了一个，还是个女生，不知道好不好看。”曹玉明还没盖上水杯，就有些迫不及待地对着自己的“小弟”戏谑道，丝毫不管台上还在说话的王老师，“还是从八班转过来的，必须好好教育一下。”

“大哥说的对，这帮实验班的不是什么好东西。”旁边的小个子男生附和着，“必须先挫掉她的锐气。”

说话间，一位穿着花白裙子的女生走了进来，一阵春风吹过还未关紧的窗户，把她的裙子掀的飘了起来，曹玉明的身边划过一丝清香，还未来得及去思索这气息的来源，只听得一声铁器撞在桌面的声音，他的腿上也感到一阵水流带来的寒意。

“你长眼睛了吗？”曹玉明扶起水杯，便大声喊着。那女生连忙弯下腰道歉。她衣兜一朵小小的蒲公英差点掉了出来，散发着一种若隐若现的馨香。他这才注意到那女生的容貌，乌黑的头发宛如瀑布一样自然地垂下来，白皙的脸上闪着明朗的春日晨曦，澄澈的眼眸犹如潭水......他还没来得及说“没事”，台上猛然传来一声王老师的河东狮吼“怎么第一天就迟到了”，那女生赶忙坐在空位上。

他还没回过神，眼神朝向那个残留着一点香气的方向，呆呆地望着。旁边一阵“咯咯”声传来，虽然细微却也惊醒了他，“笑什么笑，再给你上一课。”他抬起手，小个子男生的脸上随着一声清脆的响声多了个有些猩红的巴掌印，顿时不敢出声，曹玉明也听清楚了老师说的话，那个女生好像叫什么“张艳奇”。“好土的名字。”他嘟囔着，也没注意到小个子又要倾泻而出的笑意。

$$ 2 $$

“我服了，怎么又到这天杀的化学课了，又要看到王头那张老不死的臭脸了，还是实验课，我说白了小林你去给我说一下那个挨千刀的什么硫酸铜实验怎么做，要我被骂了第一个干的就是你！”小个子男生有些颤抖，“我也不知道啊，大哥。”他那小小的脸上又多了一个更加鲜红的巴掌印。

此时老师进来了，毕竟是对校规还有些残存的敬畏，即使是作为南城三中的一霸曹玉明也不再造次，王老师进到班里，在讲台上放了一份名单，“因为新同学的转入，大家以后分组实验的搭档可能改变，你们去看一下！”王老师把一张表格挂在黑板上，“今天金属活动性置换反应实验还是按照学号两两分组。”

曹玉明率先挤到了人群中，惊呼一声，学号表上自己前面竟然有个不认识的女生，好像叫什么“张嫣琪”，学号是“425”，而曹玉明是“426”。他在脑海里搜索了自己可怜的知识库，终于想起第二个字的读音，“原来是你啊！”他感叹于神奇的姓名机缘，也有些莫名其妙的兴奋。

实验桌前，看着试剂瓶中的蓝色溶液，还有面前的一小点铁粉，曹玉明抓耳挠腮，而张嫣琪已经熟练的用镊子夹起了铁块，放进了装了一点蓝色溶液的烧杯中。瞬时间铁粉变红，曹玉明的脸上也红了，张嫣琪拂了一下他的额头，“帅哥，别呆坐着了，实验做完了。”看着曹玉明不解的眼神，张嫣琪有一点惊讶，“硫酸铜中铜金属活动性没有铁强”，她没有一丝烦躁和嫌弃，“铁就把铜置换出来了。”

“置换”“活动性”这些词在曹玉明的脑海里宛如天书，他竟不知道怎么接上，脑海里只剩下张嫣琪的那句“帅哥”。张嫣琪见他的呆滞而有些无奈，决定先缓解一下气氛，“你不好奇我是怎么来到这里的吗？”挣扎在化学知识漩涡中的曹玉明赶忙问道，“好奇”，曹玉明急忙喊出来，掩饰自己的尴尬。他听到这世界上除了好好学习走高考和像他一样混社会，居然还可以学艺术、练体育，也能考上好大学，而在他面前的就是一位，舞蹈生，她已经拿到了一所本地高中艺术班的签约，并不想在实验班的频繁刷题中浪费时间了，就准备来到轻松一点的环境。

他有些无地自容，原先还以为面前的人是因为犯了什么事才被“发配”来这四班的，而他在这里都是居于平均以下的位置。在长久地沉默中，她好像觉察出来了什么，在他头上敲了三下。他也心领神会，“那就中午吧”，他有些小声，似是为了盖掩自己的羞愧。

$$ 3 $$

“今天还去网……”姓林的小个子男生脸上又多了一抹淡淡的红色，悻悻走开了。而 90 分钟的时间对于曹玉明来说宛如一个世纪，他终于知道了什么是反应，什么是化合，什么是置换。他用了一个自己脑海边缘的一个词，“我还任重道远啊。”而张嫣琪把衣兜里的蒲公英拿了出来，双手递给他，“这是我和你的约定。”他拿出一张纸，是南城一中的宣传报，“我相信你！”

从那以后，曹玉明的身边，那位小个子男生出现的越来越少，每个 90 分钟的午休，网吧里少了一个高大帅气的身影，四班教室的空荡又多了一分。那根蒲公英静静地水培在曹玉明的书桌前，曹玉明看着蒲公英的生长，成绩单上的排名数字却不断的变小。

2010 年 6 月 21 日，学校放了三天的假，小林和其他的帮派成员依然无所事事，反正这只是一段枷锁的开解而已；曹玉明又一次看着自己二模区排的数字，213，而目光停留在一本《2010 年南城区中考中招说明》，书上南城一中的“统招”一行赫然写着“262 人”，他又撸起袖子，翻开一本数学模拟卷，飞转的笔在前 23 个数字号码上矫若游龙，“119 分钟”，他有些沮丧，“在函数题上卡了好久啊，不过至少差不多做完了”。

$$ 4 $$

6 月 25 日，下午 14 点 40，这次的题目有些难，他这时才开始做函数题，以往都能给函数题和压轴题留上一整个小时的。他有些急切，所以飞速地读完了题目要求，“怎么这是个分数啊，第一问就来这个？”他差点叫出声，笔有些颤抖，验算了好几遍，确认这个数又浪费了好久。第二问问得有些新颖，他有些胆怯不敢下笔，没想出什么妙法后只得开始繁琐的分类讨论，草稿纸上一整面近乎满了，丝毫没有注意到考试快要结束了的他还在算着，写上四个答案区间后，他小心翼翼地又看了一遍区间有没有重叠。

“考试即将结束，收卷时请注意答题卡朝上。”“什么”他惊叫出来，“请注意考试纪律，再违反将以考试违纪处理！”他不敢再说话，看着离考试结束只剩下 2 分钟，和空白一整页的压轴大题，他早已忘记当时干了什么。他只记得，交卷时自己压轴题上第一问涂涂改改，第二问根本空白；他只记得，同学们欢呼着“这次函数题真简洁”，而好像他们口中的题目与他做的都不太像同一道；他只记得，那一晚他的书桌上是湿的，“我要考上南城一中”的白色贴纸仍然孤傲的悬挂，却有如败局已定的军队即将失守的一座堡垒……

“你真是我们的奇迹！”班级的毕业聚会在 7 月举行，“你知道你由那个混混变成了什么吗？你已经高出南城二中录取线了，你考上了一所区重点！”曹玉明低着头，一阵夏日的微风拂过，蒲公英的毛絮掉了大半，他赶忙收起衣兜，但又掉了几根毛絮。

$$ 5 $$

搬迁自然是远学的结局，曹玉明亦不例外。一根手指的长度，他在地图上一次次地算着，“五十三公里，”一声哀嚎声传来，“那就是高速开车也得一个小时，比从这里到机场都远。”他丝毫没有听到父母对一个“不良少年”考上普高——还是重点中学——的嘉许和电话里和房东的讨价声。

搬迁来得很急，甚至没来得及送走太阳辐射在这个内地小城最后的疯狂。最后一次打开这座房子的窗户，无形的波浪向着曹玉明探出窗户的身体扑来，直到额头上沁下的汗珠落在一根软绵绵的白絮上，他赶忙把手心的那串珍宝向里拉回，所剩不多的白絮还是掉了几根。

三伏的热气让把蒲公英插回花瓶里时的手抖了抖，一滴水浸到了白色的单纸，他顺着“南城二中”四个字晕开的痕迹看了下去，越看却对这张灾难的告知书越来越入迷。

还没来得及擦干手，笔触已经落到书桌前的那张贴纸，“一”下面多了一横，“前 3 名”有些突兀地写了上去。他的嘴角从那个下午开始，第一次有了一点上扬。

$$ 6 $$

“信不信我处分你啊！”南城一中里，一位穿着西服领导模样的人物，叫骂着。“我给你这次跨校交流的机会，雇大巴车跨越几十公里不是为了让你作为优秀学生代表带头旷课的！”但是他跑出了曾经梦寐以求的校门。在那个校园安保并不完善的年代，他轻而易举地拦下一辆出租车，坐了上去。

“南城机场！”他气喘吁吁。30 分钟的车程说长也不长，他想了很多。他想起，如果学校能早一天来安排这次参观，如果那个为期六年的海外培养计划能晚一天开始，如果当年自己没有看错那个正负符号，如果自己多刷一套数学题……如果硫酸铜置换实验那天有个女生没来学校，如果那个水杯没有放在桌角，如果……

航站楼里，一个穿着南城二中校服的少年看着一架飞机，丝毫不注意领带已经快要脱落了。那飞机上的白色舱体，是否有一片是那天她裙子的颜色呢？少年手里一条快要光秃秃的的蒲公英被飞机启动的气流吹过，最后几根絮毛向前方飞去，少年不再能追上它们，他停下脚步，看着絮毛随着风飞得很远很远……

## 题目描述

随着 B 市中考招生方式的多元化，中考统招的名额数量日益减少，在本题目中，你需要根据平行志愿的招生原则（我们会给出详细的解释），高效模拟这一过程。

小 $ \zeta $ 为了更好的填报志愿，找到了某年的中考志愿填报和录取的情况。

具体地，$ n $ 位学生第 $ i $ 个人会填报 $ l_i $ 个志愿，即 $l_i$ 所学校。第 $ i $ 个人的第 $ j $ 志愿为学校 $ a_{i,j} $。总共有 $ m $ 所参与招生的学校，第 $ i $ 所提供了 $ t_i $ 个名额。

按照以下流程确认每个人的录取情况，记 $ b_i $ 为学校 $ i $ 已经招生人数：

* 找到**所有**目前未确定录取结果的**最高分学生**；
* 设**未招满**学校集合 $ S=\{i \mid i \in [1,m] \land t_i > b_i\} $；
* 对于每个当前的最高分学生 $x$，从第一志愿到最后志愿枚举学校 $i=a_{x,1},a_{x,2},\cdots,a_{x,l_x}$：
	* 如果 $i\in S$，则学生 $x$ 被学校 $i$ 录取，令 $b_i\gets b_i+1$，结束；否则，继续枚举下一个。
    * 若枚举所有 $i$ 后没有结束，则学生 $x$ 不被任何学校录取。
* 在上一步中 $ b_i $ 改变不会改变 $ S $，也就是说可能会出现一些学校 $b_i>t_i$。无论这些学生有没有被录取，他们的录取结果都确定了。
* 反复执行该过程直至所有学生录取结果都确定。

对于一次询问，格式如下：

* `x v`：永久性改变 $ t_x \leftarrow t_x-v $，输出录取结果变化的学生个数。

## 说明/提示

#### 【样例解释 \#1】

初始时，录取结果分别为（$ 0 $ 表示未被任何学校录取）$ \{1,2,3,3,3\} $。

前两次操作后，录取结果不变。

第三次操作后，录取结果分别为 $ \{1,2,3,2,0\} $。

第四次操作后，录取结果分别为 $ \{1,0,2,2,0\} $。

第五次操作后，录取结果分别为 $ \{0,0,1,0,0\} $。

#### 【数据规模与约定】

对于 $ 100\% $ 的数据：

* $ 1 \le n,m,q \le 3 \times 10^5 $；
* $ 0 \le t_i \le 10^6 $，$ 0 \le l_i \le m $，$ \sum l_i \le 10^6 $，$ 1 \le a_{i,j} \le m $，$ 0 \le o_i \le 10^6 $；
* 对于同一个 $ i $ **不保证** $ a_{i,j} $ 互不相同；
* 对于每次操作有 $ 1 \le x \le m $ 和 $ 0 \le v \le 10^6 $，操作后保证 $ t_i \ge 0 $。

**提示：本题开启捆绑测试。**

* Subtask 1（15 pts）：$ n,m,q \le 500 $，$ \sum l_i \le 5000 $。
* Subtask 2（20 pts）：$ o_i $ 只有两种取值。
* Subtask 3（35 pts）：所有的 $ o_i $ 互异。
* Subtask 4（30 pts）：无特殊限制。

## 样例 #1

### 输入

```
5 3 5
1 2 5
3 1 2 3 3
3 1 2 3 2
3 3 2 1 5
2 3 2 4
1 3 4
3 1
3 2
3 1
3 1
2 2```

### 输出

```
0
0
2
2
3```

# 题解

## 作者：船酱魔王 (赞：30)

## 题意回顾

给定平行志愿招生规则下每个人的报名志愿和中考分数，支持以下操作：

* 减少一个学校的招生名额若干，求出有多少个学生的录取结果改变。

人数、学校数、操作数均不超过 $ 3 \times 10^5 $，志愿总数不超过 $ 10^6 $。

## 分析

记人数、学校数、操作数、分数档位数和志愿的量级均为 $ n $。

考虑一次志愿录取计算的时间复杂度为 $ O(n \log n) $，瓶颈在于分数排序，其余复杂度为 $ O(n) $。

考虑如果直接用数据结构维护这个问题的话，很难操作，但是操作只是有减少名额，容易发现每个人录取的志愿位次必然越来越靠后。故我们只需要在对数时间内完成一个人志愿录取位次靠后的处理即可。

我们发现这个过程类似于一棵树上的搜索，对于减少名额的学校需要踢出分数靠后的学生；而对于这些学生的志愿录取位次向后推移可能会导致其他学校部分分数靠后的学生被踢出。所以实现学校踢出学生函数和学生找学校即可，注意每个学生影响范围必然是分数比他更低的学生所以每次要找到分数最高的录取结果需要改变的学生开始操作。

注意以下实现细节：

* 维护每个人目前考虑到的志愿位次；
* 在目前录取结果改变的学生中每次要找到的是分数最高的学生找到新的录取结果；
* 一个实现技巧是维护目前学校录取的分数线，若学生分数高于或等于分数线即可进入学校。（因为每次从高分学生开始找学生录取结果改变情况所以分数线更高的学校必然是已经被更新完分数线了）
* 代码注释中该维护的内容维护全。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <map>
#include <set>
using namespace std;
const int N = 3e5 + 5;
const int M = 1e6 + 5;
int n, m, q;
int t[N];//总录取名额
vector<int> g[N];//志愿列表
int o[N];//中考分数
set<int> scl[N];//学校分数段集合*
int tot[N];//学校录取人员总数*
struct node {
    int sc, ps;//分数及录取结果
    node(int scx, int psx) {
        sc = scx, ps = psx;
    }
};
bool operator<(node p1, node p2) {
    return (p1.sc == p2.sc) ? (p1.ps < p2.ps) : (p1.sc > p2.sc);
}
map<node, int> id;//对应录取人员组编号
vector<int> res[M];//录取人员集合*
int cur[N];//志愿论次编号*
vector<int> tmp[M];
int avi[N];
set<node> se;
void enter(int x, int k);
void FindSchool(int x) {
    for(int i = cur[x]; i < g[x].size(); i++) {
        cur[x] = i + 1;
        int school = g[x][i];
        bool ok = false;
        ok |= t[school] > tot[school];
        if(scl[school].size() > 0) ok |= o[x] >= *(scl[school].begin());
        if(ok) {
            enter(x, school);
            return;
        }
    }
}
void kick(int x) {
    set<int>::iterator it = scl[x].begin();
    while(it != scl[x].end()) {
        int score = *it;
        int idx = id[node(score, x)];
        if(tot[x] - res[idx].size() < t[x]) {
            break;
        }
        tot[x] -= res[idx].size();
        se.insert(node(score, x));
        it++;
    }
    if(it != scl[x].begin()) scl[x].erase(scl[x].begin(), it);
}
void enter(int x, int k) {
    scl[k].insert(o[x]);
    res[id[node(o[x], k)]].push_back(x);
    tot[k]++;
    kick(k);
}
int main() {
    scanf("%d%d%d", &n, &m, &q);
    for(int i = 1; i <= m; i++) scanf("%d", &t[i]), avi[i] = (bool)t[i];
    int u, v;
    for(int i = 1; i <= n; i++) {
        scanf("%d", &u);
        for(int j = 1; j <= u; j++) {
            scanf("%d", &v);
            g[i].push_back(v);
        }
        scanf("%d", &o[i]);
        tmp[o[i]].push_back(i);
    }
    int ct = 0;
    for(int i = 1; i <= n; i++) {
        for(int j = 0; j < g[i].size(); j++) {
            if(id.find(node(o[i], g[i][j])) == id.end()) {
                id[node(o[i], g[i][j])] = ++ct;
            }
        }
    }
    for(int i = M - 5; i >= 0; i--) {
        for(int j = 0; j < tmp[i].size(); j++) {
            int k = tmp[i][j];
            for(int p = 0; p < g[k].size(); p++) {
                int s = g[k][p];
                cur[k] = p + 1;
                if(avi[s]) {
                    enter(k, s);
                    if(tot[s] >= t[s]) avi[s] = 2, se.insert(node(s, 0));
                    break;
                }
            }
        }
        for(set<node>::iterator it = se.begin(); it != se.end(); it++) avi[it -> sc] = 0;
        se.clear();
    }
    for(int qi = 1; qi <= q; qi++) {
        scanf("%d%d", &u, &v);
        t[u] -= v;
        kick(u);
        int ans = 0;
        while(!se.empty()) {
            set<node>::iterator it = se.begin();
            int score = it -> sc;
            while(it != se.end() && (it -> sc) == score) {
                int idx = id[*it];
                ans += res[idx].size();
                for(int i = 0; i < res[idx].size(); i++) FindSchool(res[idx][i]);
                res[idx].clear();
                it++;
            }
            se.erase(se.begin(), it);
        }
        se.clear();
        printf("%d\n", ans);
    }
    return 0;
}
```

## 后记

每个六月，都是千千万万个中国人根据自己的所谓「$ o $ 值」决定来很大程度上决定人生下一阶段走向的时刻。希望每个看到这里的人，都能在这两个六月有着满意的「$ o $ 值」，在为梦想一步步地奋斗中，获得应得的回报，过上想要的生活。

![故事的结局是](https://cdn.luogu.com.cn/upload/image_hosting/9xojk5zn.png)

---

## 作者：CaiZi (赞：7)

一道偏向大模拟和 STL 运用的题目。这里主要讲述具体实现方法。

首先我们发现，当进行一次操作后，所有分数**严格大于**第 $t_x$ 名的人都会被其它学校录取（**等于**的人不会改变），且一定只能被志愿中更加靠后的学校录取。因为在减少招生人数后，每个学校录取的学生的最低分一定不会减少。因此如果在此之前无法被志愿中更加靠前的学校录取，那么之后一定也无法完成。

然后我们就可以发现，每个学生最多只会改变被录取的学校 $l_i$ 次，之后就无法被任何学校录取，也不影响任何结果。

因此我们考虑对每个学校开一个 `pbds` 中的平衡树 `tree`，每个节点是一个 `pair<int,int>`，分别表示该人的分数（用于排序）和该人的编号。然后每次操作先让 $t_x\gets t_x-v$，然后找到第 $x$ 个 `tree` 的第 $t_x$ 大值，找到所有分数**严格大于**这个值的人，先把他们全部移出第 $x$ 个 `tree`。然后依次将他们放到自己的下一个志愿，然后递归处理他们下一个志愿的学校，同样按照这样操作。（**这里特别容易乱，一定要先全部移出第 $x$ 个 `tree`，否则可能会影响到其他的操作导致 RE 或 TLE**）

可以将第 $i$ 个人的第 $l_i+1$ 志愿设为学校 $m+1$，这所学校容量无限，减少特判。

时间复杂度 $O(\sum l_i\log\sum l_i)$。

挑战全谷最短代码（无任何压行），甚至时空常数还很小（无任何卡常），能冲到最优解第一页，代码展示：
```cpp
#include<bits/extc++.h>
#define tre tree<pair<int,int>,null_type,greater<pair<int,int>>,rb_tree_tag,tree_order_statistics_node_update>
using namespace std;
using namespace __gnu_pbds;
int n,m,q,t[300501],b[300501],o[300501],x,y;
vector<int>a[300501];
set<int>c;
tre s[300501];
inline void update(int u){
	if(t[u]<s[u].size()){
		tre::iterator v;
		vector<pair<int,int>>w;
		w.clear();
		if(t[u]==0){
			v=s[u].begin();//如果这个学校不招生，所有人都要移出
		}
		else{
			v=s[u].upper_bound(make_pair(s[u].find_by_order(t[u]-1)->first,0));//否则找到第一个被移出的人
		}
		while(v!=s[u].end()){
			w.push_back(*v);
			v=s[u].erase(v);//依次移出每一个人
		}
		for(pair<int,int>i:w){
			c.insert(i.second);
			b[i.second]++;
			s[a[i.second][b[i.second]]].insert(i);
			update(a[i.second][b[i.second]]);//依次更新每一个人
		}
	}
}
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>n>>m>>q;
	for(int i=1;i<=m;i++){
		cin>>t[i];
	}
	t[m+1]=n;
	for(int i=1;i<=n;i++){
		cin>>x;
		while(x--){
			cin>>y;
			a[i].push_back(y);
		}
		cin>>o[i];
		a[i].push_back(m+1);//增加一个任何人都能上的学校
	}
	for(int i=1;i<=n;i++){
		s[a[i][0]].insert(make_pair(o[i],i));
		update(a[i][0]);//初始时可以当做是更新一个人
	}
	while(q--){
		c.clear();
		cin>>x>>y;
		t[x]-=y;
		update(x);
		cout<<c.size()<<'\n';
	}
	return 0;
}
```

---

## 作者：沉石鱼惊旋 (赞：7)

# P11787 「FAOI-R4」蒲公英的约定

我们称『滑档』指一个学生由志愿 $i$ 变为了志愿 $j$，且 $i\lt j$。『落榜』即为一个考生没有被任何学校录取。

发现一条性质：$t_x$ 的减小只会导致更多的考生『滑档』。甚至于『落榜』。不会存在得到更好的志愿的情况。

这条性质联系生活实际不难看出，想必大家都没听说过某个学校减少招生结果本来没被这个学校录取的后来被录取了的这种事情。

或者感性理解一下这个招生的过程，首先 $t_x$ 减小必然影响已经被 $x$ 录取的分数最低的那一批学生。如果他们没被录取，就可能会『滑档』到自己的后面的志愿 $y$。然后分数比他低但是已经被 $y$ 录取的考试也可能会因为人数原因而继续『滑档』。如果一个人志愿改变，只可能是自己目前最优秀的这个志愿被挤掉了。

那么看到此题中，我们设 $cur_i$ 表示第 $i$ 名学生目前被 $a_{i,cur_i}$ 录取了。那么每进行一次操作，$cur_i$ 单调不降。也就是说，$q$ 次操作，$cur_i$ 的总增量是 $\mathcal O(\sum l)$ 级别的。那么我们就可以对每个询问暴力求出具体是哪些学生『滑档』甚至『落榜』了。

再次回忆这个 $t_x$ 减小的过程。我们可以拟定一个分数线 $L_x$。所有被第 $x$ 所学校录取，且严格低于 $L_x$ 的学生就会『滑档』。

我们对每个学校维护什么分数的什么学生被这所学校录取了。每次 $t_x$ 减小，找到第 $t_x$ 大的分数 $L_x$。把严格小于 $L_x$ 的学生记录为『滑档』。被『滑档』的学生按照分数排名，扔进自己下个志愿的学校 $y$ 里。由于学校 $y$ 可能会达到录取上限，我们再找出这所学校的分数线 $L_y$。把严格小于 $L_y$ 的学生标记为『滑档』，加入分数排名，循环做这个：“标记『滑档』——拟定分数线——末位淘汰”的事情。

新的学生参与排名我们可以用堆简单实现。之后我们还需要支持每个学校快速查询第 $k$ 大的分数，以及插入删除学生。可以使用平衡树维护。

我的代码里使用了 `__gnu_pbds::tree` 实现。可以通过 `__gnu_pbds` 简单写出一个考场可用的平衡树。其中红黑树 `__gnu_pbds::rb_tree_tag` 性能最佳。代码里用的就是红黑树。

<https://www.luogu.com.cn/record/204321549>

```cpp
#include <bits/stdc++.h>
#include <bits/extc++.h>
using namespace __gnu_pbds;
using namespace std;
#define getchar() p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++
char buf[1000000], *p1 = buf, *p2 = buf;
template <typename T>
void read(T &x)
{
    x = 0;
    int f = 1;
    char c = getchar();
    for (; c < '0' || c > '9'; c = getchar())
        if (c == '-')
            f = -f;
    for (; c >= '0' && c <= '9'; c = getchar())
        x = x * 10 + c - '0';
    x *= f;
}
template <typename T, typename... Args>
void read(T &x, Args &...y)
{
    read(x);
    read(y...);
}
template <class T>
void write(T x)
{
    static int stk[30];
    if (x < 0)
        putchar('-'), x = -x;
    int top = 0;
    do
    {
        stk[top++] = x % 10, x /= 10;
    } while (x);
    while (top)
        putchar(stk[--top] + '0');
}
template <class T>
void write(T x, char lastChar) { write(x), putchar(lastChar); }
int n, m, q;
vector<int> a[300020];
int sc[300020];
int p[300020];
int cur[300020];
int t[300020];
int b[300020];
int fa[300020];
int F(int u) { return u ^ fa[u] ? fa[u] = F(fa[u]) : u; }
void U(int u, int v) { fa[F(u)] = F(v); }
int change;
// set<array<int, 2>> s[300020];
tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> s[300020];
void doit(int f = 0)
{
    if (f)
    {
        map<int, int> done;
        set<pair<int, int>> q;
        auto add = [&](int f)
        {
            // cerr << f << ' ' << t[f] << '\n';
            // cerr << s[f].size() << '\n';
            if (s[f].size() <= t[f])
                return;
            if (!t[f])
            {
                while (!s[f].empty())
                    q.insert(*--s[f].end()), s[f].erase(--s[f].end());
                return;
            }
            int ln = (*s[f].find_by_order(t[f] - 1)).first;
            // cerr << "sz,ln: " << s[f].size() << ' ' << ln << '\n';
            // cerr << (*--s[f].end()).first << ' ' << (*--s[f].end()).second << '\n';
            while (!s[f].empty() && (*--s[f].end()).first > ln)
                q.insert(*--s[f].end()), s[f].erase(--s[f].end());
        };
        change = 0;
        add(f);
        while (!q.empty())
        {
            auto [sc, u] = *q.begin();
            q.erase(q.begin());
            cur[u]++;
            if (!done.count(u))
                done[u] = 1, change++;
            if (cur[u] == a[u].size())
                continue;
            s[a[u][cur[u]]].insert({sc, u});
            add(a[u][cur[u]]);
        }
        return;
    }
    change = 0;
    map<int, int> mp;
    int lst_p = 0;
    vector<int> vec;
    for (int i = 1; i <= n; i = F(i + 1))
    {
        int k = p[i];
        if (sc[k] != sc[lst_p])
        {
            for (auto [x, y] : mp)
                b[x] += y;
            mp.clear();
        }
        // cerr << k << ' ' << sc[k] << '\n';
        int lst = !f ? -1 : cur[k];
        for (int &j = cur[k]; j < a[k].size(); j++)
        {
            if (b[a[k][j]] < t[a[k][j]])
            {
                mp[a[k][j]]++;
                break;
            }
            else
            {
            }
        }
        // cerr << cur[k] << '\n';
        if (cur[k] == a[k].size())
            vec.emplace_back(i);
        change += cur[k] != lst;
        lst_p = k;
    }
    for (auto [x, y] : mp)
        b[x] += y;
    mp.clear();
    // cerr << "vec " << vec.size() << '\n';
    // for (int i : vec)
    //     cerr << i << ' ';
    // cerr << '\n';
    for (int i : vec)
        U(i, i + 1);
    for (int i = 1; i <= n; i++)
    {
        if (cur[i] < a[i].size())
            s[a[i][cur[i]]].insert({-sc[i], i});
    }
}
int main()
{
    read(n, m, q);
    for (int i = 1; i <= m; i++)
        read(t[i]);
    for (int i = 1; i <= n; i++)
    {
        int len;
        read(len);
        a[i].resize(len);
        for (int &j : a[i])
            read(j);
        read(sc[i]);
    }
    for (int i = 1; i <= n; i++)
        p[i] = i;
    for (int i = 1; i <= n; i++)
        fa[i] = i;
    fa[n + 1] = n + 1;
    sort(p + 1, p + n + 1, [&](int x, int y)
         { return sc[x] > sc[y]; });
    doit(0);
    // cout << change << '\n';
    // for (int i = 1; i <= n; i++)
    //     cout << (cur[i] == a[i].size() ? 0 : a[i][cur[i]]) << ' ';
    // cout << '\n';
    while (q--)
    {
        int x, v;
        read(x, v);
        // cerr << "sub: " << x << ' ' << v << '\n';
        t[x] -= v;
        // cerr << t[x] << '\n';
        doit(x);
        write(change, '\n');
        // for (int i = 1; i <= n; i++)
        //     cout << (cur[i] == a[i].size() ? 0 : a[i][cur[i]]) << ' ';
        // cout << '\n';
    }
    return 0;
}
```

---

## 作者：MPLN (赞：6)

~~细节多搞心态，赛时没调出来。~~

## 理解题目
题目里面的模拟过程有些复杂。

翻译：按分数从高到低依次选报高中，所有人都尽可能选最好的。若某个高中最开始有空，那么选报的时候，分数一样的都可以报该高中。

可以看看[暴力代码](https://www.luogu.com.cn/paste/5pga7arh)。

## 解法：模拟
怎么优化暴力？无非就是每次询问能够 $O(\operatorname{log}n)$ 修改。可是这很难搞啊，那么来探索一下性质。发现高中的名额只会减少（ $v\ge 0$ ），那么所有人**实际选报高中**在自己志愿里的排名只会降低。一直降到上不了高中~~就去搬砖~~就结束。

所以无论 $q$ 到多少，总共的换学校次数最多就是 $\sum l_i\le 10^6$ ，允许我们套个 $\operatorname{log}$ 。

若 $A$ 学校名额减少了，怎么样的学生会被踢出呢？并不是所有 $A$ 高中后 $b_A-t_A$ 名的学生，录取的分数等于第 $t_A$ 名的超出学生也会留下。

为了实现这一点，方便后续的操作，我们可以改变学校里面存储所有录取学生的方式，而新定义**小组**为**报同一所高中且分数一样**的同学们。而学校里面用一个 set 记录所有小组，方便取出分数最低的小组。

而给 $x$ 同学更换学校很简单，只要看他的下一志愿，直接往里面放（此处需要新建 / 更新小组）。然后再检查这个高中是否需要踢出低分小组即可。这样做的好处是即便 $x$ 可能本不能加入这个高中，也会再次踢出并检查下一个志愿，以此类推，注意边界。

时间复杂度 $O(n\operatorname{log}n)$ 。

在此祝愿大家升入理想高中！

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, q, T;
unordered_set<int> ans[300010];
struct group {
    int o, sz;
    vector<int> p;
    bool operator<(const group &x) const { return o < x.o; }
};
struct sch {
    int t, b, lst;
    set<group> pq;
} c[300010];
struct stu {
    int id, l, o, lq;
    vector<int> a;
    bool operator<(const stu &x) const { return o < x.o; }
} s[300010];
void ins(int x, int to, int i) {
    s[x].lq = i, c[to].b++;
    auto it = c[to].pq.lower_bound({s[x].o, 0, {}});
    if (c[to].pq.empty() || (it->o) != s[x].o) {
        c[to].pq.insert({s[x].o, 1, {x}});
    } else {
        auto newt = *it;
        newt.sz++, newt.p.push_back(x);
        c[to].pq.erase(it);
        c[to].pq.insert(newt);
    }
}
void calFirst() {
    priority_queue<stu> pq;
    for (int i = 1; i <= n; i++) pq.push(s[i]);
    while (!pq.empty()) {
        int hscore = pq.top().o;
        while (!pq.empty() && pq.top().o == hscore) {
            int x = pq.top().id; pq.pop();
            for (int i = 0; i < s[x].l; i++) {
                int to = s[x].a[i];
                if (c[to].b < c[to].t || c[to].lst == hscore) {
                    ins(x, to, i);
                    if (c[to].b >= c[to].t) c[to].lst = hscore;
                    break;
                }
            }
        }
    }
    return;
}
void change(int x) {
    ans[T].insert(x);
    if(s[x].lq + 1 >= s[x].l) return;
    int nxt = s[x].lq + 1, to = s[x].a[nxt];
    ins(x, to, nxt);
    if (!c[to].pq.empty() && c[to].t <= c[to].b - (*c[to].pq.begin()).sz) {
        c[to].b -= (*c[to].pq.begin()).sz;
        vector<int> tmp = (*c[to].pq.begin()).p;
        c[to].pq.erase(c[to].pq.begin());
        for (int p : tmp) change(p);
    }
}
int main() {
    scanf("%d%d%d", &n, &m, &q);
    for (int i = 1, x; i <= m; i++) {
        scanf("%d", &x);
        c[i] = {x, 0, -1, {}};
    }
    for (int i = 1, x, z; i <= n; i++) {
        scanf("%d", &x);
        for (int j = 1, y; j <= x; j++) {
            scanf("%d", &y);
            s[i].a.push_back(y);
        }
        scanf("%d", &z);
        s[i] = {i, x, z, 0, s[i].a};
    }
    calFirst(), T = q;
    for (int x, v; T; T--) {
        scanf("%d%d", &x, &v);
        c[x].t -= v;
        while (!c[x].pq.empty() && c[x].t <= c[x].b - (*c[x].pq.begin()).sz) {
            c[x].b -= (*c[x].pq.begin()).sz;
            vector<int> tmp = (*c[x].pq.begin()).p;
            c[x].pq.erase(c[x].pq.begin());
            for (int p : tmp) change(p);
        }
        printf("%d\n", (int)ans[T].size());
    }
    return 0;
}
```

---

## 作者：fush (赞：2)

由于题目只有减少学校名额，没有增加。  
所以**每个学生只可能往后退**，不可能重新向前。  
且每次更改的一定是这个学校中排名靠后的。

我们对每个学校维护 map，第一维是分数 $x$，第二维是个 vector，表示这个学校中分数是 $x$ 的人。

对于每个询问，我们先找出所有要后退的人，放入队列。  

然后我们每次从队首拿出一个要后退的人。     
我们根据他的志愿，一个一个试，直到可以加入。     
如果这所学校分数最低的人移走，名额依旧没有剩余。       
说明这些人也需要后退，就加入队列。

为了方便实现，我们可以记录一下每个学校的最低分。

```c++
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define FL(a,b,c) for(int a=(b),a##end=(c);a<=a##end;++a)
#define FR(a,b,c) for(int a=(b),a##end=(c);a>=a##end;--a)
#define eb emplace_back
#define vt vector
#define PII pair<int, int>
#define cmin(a, b)({auto tmd67v8=(b);(tmd67v8<a)&&(a=tmd67v8);})
constexpr int N = 1e6 + 10;
int min_s[N], t[N], len[N], now[N], p[N];
vt<int>a[N];
map<int, vt<int>>qs[N];
void f(int i){
	for(int j = now[i], u; now[i] = j + 1, j < len[i]; j++)
		if(min_s[u = a[i][j]] <= p[i] || t[u] > 0)
			return qs[u][p[i]].eb(i), t[u]--, cmin(min_s[u], p[i]), void();
}
priority_queue<PII>q;
void g(int x){
#define se qs[x].begin()->second
	while(!qs[x].empty() && t[x] + (int)(se.size()) <= 0){
		for(auto w : se)q.emplace(p[w], w);
		t[x] += se.size(), qs[x].erase(qs[x].begin());
	}
	min_s[x] = qs[x].empty() ? 1e9 : qs[x].begin()->first;
}
int32_t main(){
	cin.tie(0)->sync_with_stdio(0);
	int n, m, Q, u, x, v, s = 0;
	cin >> n >> m >> Q;
	FL(i, 1, m)cin >> t[i], min_s[i] = 1e9;
	FL(i, 1, n){
		cin >> len[i], now[i] = 0;
		FL(j, 1, len[i])cin >> u, a[i].eb(u);
		cin >> p[i], q.emplace(p[i], i);
	}
	while(!q.empty())f(q.top().second), q.pop();
	while(Q--){
		cin >> x >> v, t[x] -= v, g(x), s = 0;
		while(!q.empty()){
			s++, u = q.top().second, q.pop(), f(u);
			if(now[u] <= len[u])g(a[u][now[u] - 1]);
		}
		cout << s << endl;
	}
	return 0;
}
```

---


# 小猪佩奇爬树

## 题目描述

佩奇和乔治在爬♂树。


给定 $n$ 个节点的树 $T(V,E)$，第 $i$ 个节点的颜色为 $w_i$，保证有$1 \leq w_i \leq n$。

对于$1 \leq i \leq n$，分别输出有多少对点对 $(u,v)$，满足 $u<v$，且恰好经过**所有**颜色为 $i$ 的节点，对于节点颜色不为 $i$ 的其他节点，经过或不经过均可。

树上路径 $(u,v)$ 定义为序列 $\{f\}$，满足 $f_1=u,f_{|f|}=v$，且 $\forall 1 \leq i < |f|$，$T$ 中均存在边 $(f_i,f_{i+1})$，且 $\{f\}$ 中无重复元素，能够证明对于任意点对 $(u,v)$，其树上路径唯一。

## 说明/提示

![](https://i.loli.net/2019/10/06/H9LuWl7GSXfs4M6.png)

对于第一组样例而言。

对于颜色 $1$，点对 $(1,2),(1,3),(1,4)$ 满足条件。

对于颜色 $2$，点对 $(1,3),(1,4),(2,3),(2,4)$ 满足条件。

对于颜色 $3$，点对 $(1,4),(2,4),(3,4)$ 满足条件。

对于颜色 $4$，由于图中没有颜色为 $4$ 的节点，所以所有点对均满足条件。
### 数据范围

对于 $40\%$ 的数据, $n \leq 10^2$

对于 $60\%$ 的数据, $n \leq 10^3$

对于 $100\%$ 的数据, $n \leq 10^6$

## 样例 #1

### 输入

```
4
1 2 2 3
1 2
2 3
3 4```

### 输出

```
3
4
3
6```

## 样例 #2

### 输入

```
10
9 7 4 2 3 4 4 5 8 5
2 1
3 2
4 2
5 2
6 4
7 4
8 1
9 4
10 4```

### 输出

```
45
35
9
0
1
45
34
9
17
45```

# 题解

## 作者：浮生南柯一梦 (赞：70)

### 本题为一道基础数据结构题目，主要需要掌握的算法：倍增LCA（其他快速求）。

若还不会快速求LCA的同学请先自行百度或阅读[P3379 【模板】最近公共祖先（LCA）](https://www.luogu.org/problem/P3379)题解。

#### 一、预处理操作
1. 我们先进行建树操作，根节点可随意指定，此处我指定1号点为根节点。

2. 在读入每个节点的颜色的时候我们可以将每种颜色所包含的节点进行分类统计。

3. 我们需要预处理出每个点的子树大小（包含本身），这个也可以在dfs建树的同时完成。

#### 二、针对每个颜色枚举答案

首先找出该颜色共有几个节点。

1. 若没有节点，答案为：$\frac{n\times(n-1)}{2}$ 。易证，此处不过多赘述。

2. 若只有1个节点，答案为：所有不是该节点子树上的节点数$\times$该节点子树上的节点数+该节点各个子树两两节点数的乘积。

    上面那句话可能有一些难以理解，用下面的这张图稍加解释。

![](https://cdn.luogu.com.cn/upload/image_hosting/b1rmzk25.png)

此处我们要求的是黄色节点的路径个数。

不在黄色节点子树上的节点数：2

黄色节点的各个子树的节点数：3,1,1

答案为：$2\times(3+1+1)+3\times1+3\times1+1\times1=17$

3. 若节点数$>=$2且这些节点在一条链上。

    首先，我们要了解如何判断这些节点是否在一条链上，将深度最深的点与其他各个节点以此计算出最近公共祖先，若答案皆为深度最浅的那个点，那么这些点在一条链上。
    
    接下来，我们需要知道如何求路径个数，答案为：不在深度最浅的点的该条链所在的子树上的点的个数$\times$深度最深的点的子树个数。
    
    这句话仍然有些难以理解，我依然使用一张图来解释一下。
    
 ![](https://cdn.luogu.com.cn/upload/image_hosting/nqq6hrf9.png)
    
此处我们要求的是红色节点的路径个数。

3,4两个点中3号点的深度较浅，4号点的深度较深，

不在深度最浅的点的该条链所在的子树上的点的个数：即1,2,3,9号4个点

深度最深的点的子树个数：即4,5,6,7,8号5个点

答案为：$4\times5=20$

4. 若节点数$>=$2且这些节点不在一条链上。

    那么我们可以把这些节点按照深度从深到浅排序，寻找深度最深的两个不存在父子关系的节点，其他的节点分别和这两个点寻找最近公共祖先，如果该节点与这两个点中的一个存在父子关系，且该节点的深度比这两个点最近公共祖先的点的深度大，则该节点一定在这两个点的路径上，反之的必定不在。如果所有点都在这条路径上，那么答案为这两个节点的子树上的点的个数的乘积，否则答案为0。

    为了便于大家理解，我继续使用一张图来解释一下。
    
 ![](https://cdn.luogu.com.cn/upload/image_hosting/1ph3k9m0.png)
 
此处我们要求的是红色节点的路径个数。

深度最深的为6号节点，然后是4,5号节点。

首先，6号与4号寻找最近公共祖先，发现是4号，它们存在父子关系，不可以。

然后，6号与5号寻找最近公共祖先，发现是3号，6号和5号不存在父子关系，可以。

接着看4号和6号的最近公共祖先：4号，4号和5号的最近公共祖先：3号，4号与6号存在父子关系，4号的深度比2号深，4号一定在6号到5号的路径上。

6号节点的子树大小：3

5号节点的子树大小：4

答案为：$3\times4=12$

### 到此，所有的情况已经分类讨论清楚。
#### 下面附上我的代码以及部分注释，由于月赛时间紧张，代码有点丑，请谅解。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct q
{
	int dep,num;
};
q w[1000010];
int x,y,n[1000010],dep[1000010],l,db[2000010],nxt[2000010],len[2000010];
int f[1000010][21],fath,o,oo,fathe[1000010],ll,h,hh;
long long a,s,sn[1000010],v[1000010],vv;
vector<int> t[1000010];
bool ff;
template <typename T> inline void read(T &x)
{
	x=0;char c=getchar();bool flg=0;
	for (;!isdigit(c);c=getchar()) if (c=='-') flg=1;
	for (;isdigit(c);c=getchar()) x=x*10+c-'0';
	if (flg) x=-x;
}
inline void write(long long x)
{
	if (x<0)
	{
		putchar('-');
		x=-x;
	}
	if (x>=10) write(x/10);
	putchar(x%10+48);
}
inline void writeln(long long x)
{
	write(x);
	puts("");
}//快读、快输
bool cmp(q p,q pp)
{
	return p.dep>pp.dep;
}//按照深度从大到小排序
void wrk(int fa,int u)
{
	dep[u]=dep[fa]+1;fathe[u]=fa;
	for (int i=0;i<=19;i++)
	f[u][i+1]=f[f[u][i]][i];
	int k=len[u];
	while (k)
	{
		if (db[k]==fa)
		{
			k=nxt[k];
			continue;
		}
		f[db[k]][0]=u;
		wrk(u,db[k]);
		sn[u]+=sn[db[k]];
		k=nxt[k];
	}
}//建树，寻找子树大小
int lca(int x,int y)
{
	if (dep[x]<dep[y]) swap(x,y);
	for (int i=20;i>=0;i--)
	{
		if (dep[f[x][i]]>=dep[y]) x=f[x][i];
		if (x==y) return x;
	}
	for (int i=20;i>=0;i--)
	{
		if (f[x][i]!=f[y][i])
		{
			x=f[x][i];
			y=f[y][i];			
		}
	}
	return f[x][0];
}//寻找最近公共祖先
int main(){
	/*freopen(".in","r",stdin);
	freopen(".out","w",stdout);*/
	//ios::sync_with_stdio(false);
	read(a);
	for (int i=1;i<=a;i++)
	{
		read(n[i]);
		t[n[i]].push_back(i);
	}//读入颜色，每种颜色的节点统计
	for (int i=1;i<a;i++)
	{
		read(x);read(y);
		db[i*2-1]=y;
		nxt[i*2-1]=len[x];
		len[x]=i*2-1;
		db[i*2]=x;
		nxt[i*2]=len[y];
		len[y]=i*2;		
	}//连边
	for (int i=1;i<=a;i++) sn[i]=1;//子树大小至少为1
	wrk(0,1);//建树
	for (int i=1;i<=a;i++)
	{
		l=0;
		for (int j=0;j<t[i].size();j++)
		{
			l++;
			w[l].num=t[i][j];
			w[l].dep=dep[w[l].num];
		}//将该颜色所有的点记录下编号和深度
		if (l==1)
		{
			int k=len[w[l].num];ll=0;
			while (k)
			{
				if (db[k]==fathe[w[l].num])
				{
					k=nxt[k];
					continue;
				}
				ll++;
				v[ll]=sn[db[k]];
				k=nxt[k];
			}
			vv=(sn[w[l].num]-1)*(a-sn[w[l].num])+a-1;
			for (int j=1;j<=ll;j++)
				for (int m=j+1;m<=ll;m++)
				vv+=v[j]*v[m];
			writeln(vv);
			continue;
		}//只有1个节点的情况
		if (l==0)
		{
			writeln((a*(a-1))/2);
			continue;
		}//没有节点的情况
		sort(w+1,w+l+1,cmp);//按照深度从大到小排序
		hh=0;
		for (int j=2;j<=l;j++)
		{
			fath=lca(w[1].num,w[j].num);
			if (fath!=w[j].num) 
			{
				hh=j;
				break;
			}		
		}//判断是否为一条链，若hh==0则为一条链
		ff=0;
		if (hh!=0)
		for (int j=3;j<=l;j++)
		{
			o=lca(w[j].num,w[1].num);oo=lca(w[j].num,w[hh].num);
			if (((o==w[j].num)||(oo==w[j].num))&&(dep[w[j].num]>=dep[fath])) continue;
			ff=1;break;
		}//判断其他的点是否与这两个点存在父子关系
		if (ff==0)
		{
			if (hh==0)
			{
				int k=w[1].num;h=w[1].num;
				while (fathe[k]!=w[l].num)
				{
					k=fathe[k];
					h=k;
				}
				writeln(sn[w[1].num]*(a-sn[w[l].num]+sn[w[l].num]-sn[h]));				
			}//一条链的情况
			else writeln(sn[w[1].num]*sn[w[hh].num]);//普通情况		
		}
		else writeln(0);
	}
	return 0;
}

```
#### 最后附上几组我月赛时的调试数据供大家使用。
```
输入1：
10
6 8 4 1 9 6 1 5 10 6 
2 1
3 1
4 1
5 3
6 5
7 1
8 1
9 4
10 3

输出1：
2
45
45
29
9
0
45
9
17
9

输入2：
5
1 2 3 2 4
1 2
2 3
3 4
2 5

输出2：
4
3
7
4
10

输入3：
10
9 6 7 6 7 2 9 10 2 6
1 2
2 4
4 7
1 3
3 5
5 6
5 8
1 9
1 10

输出3：
45
1
45
45
45
2
21
45
7
9

输入4：
10
7 2 8 9 9 10 1 6 9 6
1 2
1 7
2 3
2 4
2 9
4 5
5 6
5 8
5 10

输出4：
9
34
45
45
45
1
17
9
4
9
```



---

## 作者：xiejinhao (赞：36)

#  P5588 小猪佩奇爬树 题解

> ## 本文同步发布于 [$My Blog$](https://www.cnblogs.com/Ning-H/p/11670828.html)

------------





写在前面
------------



我发现这个题目题解是少之又少……于是你就看到了本篇题解。

笔者写下这篇文章，一是为了总结，二是希望帮助到更多的人。

希望大家看完这篇文章都能有所收获。

题目传送门 [P5588 小猪佩奇爬树](https://www.luogu.org/problem/P5588)



题解部分
------------


一开始我看到本题，就想是不是和 $LCA$ 有关。

当时我思考只要求出每个颜色的 $LCA$ 即伸展的最下方节点（包含该颜色的节点）

只要所有颜色在一条链上，我们就可以统计答案。特别的，一个点也算链。

但是实际上**并不需要这么复杂**，所以我月赛也没有打出本题。

- ### 思路改进及代码实现

-那么我们先考虑简单的情况，就是没有这个颜色的节点，那么我们答案即为 $\frac{n*(n-1)}{2}$。

还有就是这个颜色只有一个节点，那么就是统计一个这节点为根的所有子树大小**互乘累加**。

这个是根据乘法原理得来的，**如果你没有理解上面那句话，那么你可以看下面这句代码来理解**：

```cpp
void dfs(int x, int fa) {
    ……;
    size[x] = 1; 
    for(int i = head[x]; i; i = Next[i]) {
        if(ver[i] == fa) continue;
        dfs(y, x);
        ans1[x] += 1LL * size[x] * size[y];
        size[x] += size[y];
        ……;
    } ans1[x] += size[x] * (n - size[x]);
    ……;
}
```

其中 $ans1$即为我们所要的答案（$size$统计子树大小）。
再开一个额外的数组确认当前颜色的 $x$ 在哪即可。

那么以上就是**一个颜色只有一个节点**的情况。

-------------------

下面重点讨论一**个颜色有两个以上节点**的情况，那么可能会出现两种情况：

1. 所有这样的节点都在一条链上，也就是说这个颜色有**两个端点**。

2. 所有这样的颜色不在一条链上，也就是说有**三个及以上端点**。

那么显而易见的，对于第2种情况一定不存在一种合法的解，输出 $0$ 即可。

所以重点是解决第1种情况。

我们考虑对于一个颜色，什么时候可能会是端点。我们记一个数组 $cnt$ 表示颜色 $c$ 到目前为止出现的次数。

那么对于树上操作，一般进行 $dfs$ ，那么 $cnt[c]$($c$ 是当前颜色)就极可能直接发生改变。

那么对于每一次改变，我们定义一个变量 $flag++$，只要最终结果 $flag=1$ 就极可能是个端点。

还有另一种可能，就是进入当前节点时 $cnt[c]$ 已经有值，或者当前节点不为当前颜色的最后一个节点，那么也要使 $flag++$。

具体再解释下 $flag$ 可能会更好理解：$flag$ 代表当前节点下子树颜色也为 $c$ 的个数。

这样好理解了吧？记得最后处理完上面的步骤还要让 $cnt[c]++$一次（当前颜色也是 $c$ 啊 $QAQ$）。

只要最后 $flag=1$那么即为端点。第一次进入直接让当前颜色的节点指针赋给 $nos$ (记录当前颜色从哪开始)

然后答案即为最两端的节点的子树大小之积。

- ### 很抽象？看看怎么实现的吧：

```cpp
int color[N], tot[N], cnt[N], n;
int enos[N], size[N], nos[N];
long long ans1[N], ans2[N];
// ans1 统计一个颜色一个节点的情况 
// ans2 统计一个颜色多个节点的情况
// enos[c] 表示 c 的个数   nos[c] 表示 c 对应的位置
// 至于 nos 的用处过会儿完整代码你就明白
// tot[c] 表示颜色 c 总共的个数 剩下的含义看上面啦
inline void dfs(int x, int fa) {
	int c = color[x], k = cnt[c];
	int flag = 0, pos = 0;
	size[x] = 1;
	
	for(int i = head[x]; i; i = Next[i]) {
		int y = ver[i];
		if(y == fa) continue;
		int lastans = cnt[c];
		dfs(y, x);
		ans1[x] += 1LL * size[x] * size[y];
		size[x] += size[y];
		if(lastans != cnt[c]) flag++, pos = y;
	}
	ans1[x] += 1LL * size[x] * (n - size[x]);
	if(k || cnt[c] != tot[c] - 1) flag++;
	cnt[c]++; // 当前节点颜色是 c
	
	if(flag == 1) { // 端点 
		if(!enos[c]) nos[c] = x;
		else {
			int p = pos ? n - size[pos] : size[x];
			ans2[c] = 1LL * size[nos[c]] * p;
		} enos[c]++;	
	}
}
```

这样子大家应该可以理解如何解决本题了吧？

那么分析下这个 $dfs$ 的复杂度，很明显是 $O(N)$ 的……（为什么某位神仙打了$O(N \log N)$的……）

好了下面放上完整代码吧（建议按照思路自己先打，不知道 $nos$ 怎么用可以看看）



------------


$Code:$ 
------------


```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e6 + 10;

int head[N], Next[N << 1], ver[N << 1];
void add(int x, int y) {
	static int cnt = 0;
	ver[++cnt] = y, Next[cnt] = head[x], head[x] = cnt;
	ver[++cnt] = x, Next[cnt] = head[y], head[y] = cnt;
}

int color[N], tot[N], cnt[N], n;
int enos[N], size[N], nos[N];
long long ans1[N], ans2[N];

inline void dfs(int x, int fa) {
	int c = color[x], k = cnt[c];
	int flag = 0, pos = 0;
	size[x] = 1;
	
	for(int i = head[x]; i; i = Next[i]) {
		int y = ver[i];
		if(y == fa) continue;
		int lastans = cnt[c];
		dfs(y, x);
		ans1[x] += 1LL * size[x] * size[y];
		size[x] += size[y];
		if(lastans != cnt[c]) flag++, pos = y;
	}
	ans1[x] += 1LL * size[x] * (n - size[x]);
	if(k || cnt[c] != tot[c] - 1) flag++;
	cnt[c]++;
	
	if(flag == 1) { // 端点 
		if(!enos[c]) nos[c] = x;
		else {
			int p = pos ? n - size[pos] : size[x];
			ans2[c] = 1LL * size[nos[c]] * p;
		} enos[c]++;	
	}
}

int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) {
		scanf("%d", color + i);
		tot[color[i]]++;
		nos[color[i]] = i;
	}
	for(int i = 1, x, y; i < n; i++) {
		scanf("%d %d", &x, &y);
		add(x, y);
	} 
	dfs(1, 0);
	for(int i = 1; i <= n; i++) {
		if(tot[i] == 0) 
			printf("%lld\n", 1LL * n * (n - 1) >> 1);
		else if(tot[i] == 1)
			printf("%lld\n", ans1[nos[i]]);
		else if(enos[i] == 2)
			printf("%lld\n", ans2[i]);
		else puts("0");
	}
	return 0;
}
```

$End$
------------


很好的一道题目，但是因为脑抽又想了很久没打出来……

所以 $Orz$ ……


---

## 作者：Clouder (赞：13)

本文亦发表于[笔者博客](https://www.codein.icu/lp5588)。

## 题意

[题目传送门](https://www.luogu.com.cn/problem/P5588)  

题目给的描述足够清晰，照搬过来：  

![Description](https://cdn.jsdelivr.net/gh/Clouder0/myPics/img/lp5588.png)  

## 解法

由特殊到一般，逐步分析。  
对每个颜色进行讨论。  

![originTree](https://cdn.jsdelivr.net/gh/Clouder0/myPics/img/originTree.png)  


### 颜色未出现

颜色的值域为 $[1,n]$，一共 $n$ 个点，只要有点的颜色重复，就会有颜色未在树上出现。  

由于未在树上出现，任意点对都是满足条件的点对。  

每个点与剩余 $n-1$ 个点构成点对，除去重复，答案即 $\frac{n \times (n - 1)}{2}$。  

### 颜色出现一次

颜色出现一次时，经过这个点的路径即合法。   

将该颜色的点当成树根，旋转树。  

![2index](https://cdn.jsdelivr.net/gh/Clouder0/myPics/img/lp55882indexTree.png)  

经过树根的点对就是合法的。  
对于每一个儿子为根的子树内的点，都可以与非该子树内的点组成点对。  

考虑如何不重不漏地统计答案。  
定义 $size_i$ 为以 $i$ 为根的子树的大小。   

每遍历到一个儿子时，统计它与已遍历儿子的点对。   

```cpp
for(int p = head[u];p;p=E[p].next)
{
    v = E[p].to;
    if(v == fa)
        continue;
    dfs(v,u);
    ans[u] += size[u] * size[v];
    size[u] += size[v];
}
ans[u] += (n - size[u]) * size[u];
```

特别地，将父亲也看作换根后的儿子看待，在最后特殊处理。  

### 颜色在链上出现

![chainTree](https://cdn.jsdelivr.net/gh/Clouder0/myPics/img/chainTree.png)

可以发现，链有两个端点。  
旋转树，将端点当做根，同颜色的节点一定只在一个儿子的子树中出现。  

合法的路径为：  
从端点和未出现同色节点的子树中的节点 到  
另一个端点，和另一个端点为根时未出现同色节点的子树中的节点。  

![1indexChainTree](https://cdn.jsdelivr.net/gh/Clouder0/myPics/img/1indexchainTree.png)

![7indexChainTree](https://cdn.jsdelivr.net/gh/Clouder0/myPics/img/7indexchainTree.png)

这部分的大小，用节点总数减去同色节点出现的子树大小得出。  

现在的问题就是如何寻找端点。  

根据性质，可以发现：  
将树旋转为以端点为根的形态，有且只有一个儿子为根的子树中会有同色节点。  

记录有多少儿子子树出现了同色节点，如果唯一则为端点。  
特别地，父亲节点要当做儿子特殊处理。  

记 $cnt_i$ 为搜索过程中颜色 $i$ 出现的次数。   
向下搜索，回溯到源点，若颜色 $i$ 出现的次数变化了，说明该子树中有同色节点出现。  
将该儿子记录下来。  

```cpp
int has = 0,hasSon;
int beginColorNum = cnt[w[u]];
for(int p = head[u];p;p=E[p].next)
{
    v = E[p].to;
    if(v == fa)
        continue;
    int temp = cnt[w[u]];
    dfs(v,u);
    if(cnt[w[u]] != temp)
        ++has,hasSon = v;
}
//处理父亲节点，搜索完儿子子树后若记录数量仍不足，说明父亲子树中也有同色点
if(beginColorNum != 0 || cnt[w[u]] + 1 != num[w[u]])
    ++has;
++cnt[w[u]];
if(has == 1)
{
    //dosomething...
}
```

这样就可以找出端点了。  

一条链有且只有两个端点，如果出现多于两个端点，说明链在某处分叉了，一定没有符合条件的路径，答案为 $0$。  
记录端点数量。  

```cpp
if(has == 1)
{
    int t;//计算合法的起点的数量
    if(hasSon)
        t = n - size[hasSon];//链在儿子为根的子树中，减去该子树，剩余节点都可为起点
    else
        t = size[u];//链在父亲为根的子树中，当前子树都可为起点。
    if(pointNum[w[u]] == 0)//第一个端点
        firstPos[w[u]] = u,preSize[w[u]] = t;
    else if(pointNum[w[u]] == 1)//两个端点都已经确定
    {
        //答案数量为合法起点、终点相乘
        f2[w[u]] = (long long)t * preSize[w[u]];
    }
    pointNum[w[u]]++;
}
```

### 颜色不在链上出现

一条链有且只有两个端点，如果出现多于两个端点，说明链在某处分叉了，一定没有符合条件的路径，答案为 $0$。  

## 代码

将上述的做法综合起来。  
~~十年OI一场空，不开...~~  

```cpp
#include <cstdio>
template <typename T>
inline void read(T &r)
{
    static char c;
    r = 0;
    for (c = getchar(); c > '9' || c < '0'; c = getchar());
    for (; c >= '0' && c <= '9'; r = (r << 1) + (r << 3) + (c ^ 48), c = getchar());
}
const int maxn = 1e6 + 10;
struct node
{
    int to, next;
} E[maxn << 1];
int head[maxn];
inline void add(const int &x, const int &y)
{
    static int tot = 0;
    E[++tot].to = y;
    E[tot].next = head[x];
    head[x] = tot;
}
int n;
int w[maxn];
int colorNum[maxn], size[maxn];
long long f1[maxn]; //颜色只在当前点出现时的答案
long long f2[maxn]; //f2[i] 颜色i在链上时的答案
int cnt[maxn];      //cnt[i] 颜色i在当前出现的次数
int pointNum[maxn], preSize[maxn];
void dfs(int u, int fa)
{
    size[u] = 1;
    int v;
    int has = 0, hasSon = 0;
    int beginColorNum = cnt[w[u]];
    for (int p = head[u]; p; p = E[p].next)
    {
        v = E[p].to;
        if (v == fa)
            continue;
        int temp = cnt[w[u]];
        dfs(v, u);
        f1[u] += (long long)size[u] * size[v];
        size[u] += size[v];
        if (cnt[w[u]] != temp)
            ++has, hasSon = v;
    }
    f1[u] += (long long)(n - size[u]) * size[u]; //父亲节点
    if (beginColorNum != 0 || cnt[w[u]] + 1 != colorNum[w[u]])
        ++has;
    ++cnt[w[u]];
    if (has == 1)
    {
        int t = hasSon ? n - size[hasSon] : size[u];
        if (pointNum[w[u]] == 0)
            preSize[w[u]] = t;//事实上只需要记录大小就够了，不用确定点
        else if (pointNum[w[u]] == 1)
            f2[w[u]] = (long long)t * preSize[w[u]];
        pointNum[w[u]]++;
    }
}
int lastPos[maxn]; //记录某个颜色最后出现的点，用于处理只出现一次的情况
int main()
{
    read(n);
    for (int i = 1; i <= n; ++i)
        read(w[i]), colorNum[w[i]]++, lastPos[w[i]] = i;
    int x, y;
    for (int i = 1; i < n; ++i)
    {
        read(x);
        read(y);
        add(x, y);
        add(y, x);
    }
    dfs(1, 0);
    for (int i = 1; i <= n; ++i)
    {
        if (colorNum[i] == 0)
            printf("%lld\n", (long long)n * (n - 1) >> 1);
        else if (colorNum[i] == 1)
            printf("%lld\n", f1[lastPos[i]]);
        else if (pointNum[i] == 2)
            printf("%lld\n", f2[i]);
        else
            puts("0");
    }
    return 0;
}
```

~~笔者认为这道题有蓝题难度了，当然可能是笔者太蒟了……~~  

---

## 作者：CYJian (赞：9)

目前效率第一(可能是fread+fwrite的原因...)

---

对于这道题，比较显然的一点是：如果存在一个点，存在三个以上的子树中有与其相同的颜色的点，那么这种颜色的方案就是0。

否则的话，就可以发现，这些颜色相同的点一定在树上的某一条链上，那么找到链的两个端点，方案数就是去掉两端点中间的一坨点，剩下两棵的子树大小的乘积。

然后思路就很清晰了：我们只需要对于每一个点，看看是不是只有一条边所连的子树中有与其相同颜色的点。如果是就是一个端点。

然后记录下这条边，最后计算只需要判断端点个数就行了：

一个端点：所有子树两两乘积和+n-1

两个端点：去掉中间一坨点后，剩下两颗子树的大小乘积

三个及以上的端点：0。

upd: 重新按照上面的题解写了份代码。。

感谢评论区的大佬 `ljc20020730` 发现原代码的bug。

```cpp
#if By_CYJian
为什么 CYJian 那么菜啊...

Algorithm: 

Solution: (看心情写)
#endif

#include <bits/stdc++.h>

using namespace std;

#define FILE(Name) freopen(Name"in", "r", stdin), freopen("out", "w", stdout)

namespace io {
	const int __SIZE = (1 << 21) + 1;
	char ibuf[__SIZE], *iS, *iT, obuf[__SIZE], *oS = obuf, *oT = oS + __SIZE - 1, __c, qu[55]; int __f, qr, _eof;
	#define Gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)
	inline void flush () { fwrite (obuf, 1, oS - obuf, stdout), oS = obuf; }
	inline void gc (char &x) { x = Gc(); }
	inline void pc (char x) { *oS ++ = x; if (oS == oT) flush (); }
	inline void pstr (const char *s) { int __len = strlen(s); for (__f = 0; __f < __len; ++__f) pc (s[__f]); }
	inline void gstr (char *s) { for(__c = Gc(); __c < 32 || __c > 126 || __c == ' ';)  __c = Gc();
		for(; __c > 31 && __c < 127 && __c != ' '; ++s, __c = Gc()) *s = __c; *s = 0; }
	template <class I> inline bool gi (I &x) { _eof = 0;
		for (__f = 1, __c = Gc(); (__c < '0' || __c > '9') && !_eof; __c = Gc()) { if (__c == '-') __f = -1; _eof |= __c == EOF; }
		for (x = 0; __c <= '9' && __c >= '0' && !_eof; __c = Gc()) x = x * 10 + (__c & 15), _eof |= __c == EOF; x *= __f; return !_eof; }
	template <class I> inline void print (I x) { if (!x) pc ('0'); if (x < 0) pc ('-'), x = -x;
		while (x) qu[++ qr] = x % 10 + '0',  x /= 10; while (qr) pc (qu[qr --]); }
	struct Flusher_ {~Flusher_(){flush();}}io_flusher_;
} using io::pc; using io::gc; using io::pstr; using io::gstr; using io::gi; using io::print;

template<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }
template<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }
template<typename T> inline T gcd(T&a, T b) { return !b ? a : gcd(b, a % b); }
typedef unsigned uit;
typedef long long ll;
typedef double db;

// 看题目取用
// const int mod = 2999999; // for Hash
// const int mod = 4999999; // for Hash
// const int mod = 19491001;
// const int mod = 19260817;
// const int mod = 104857601;
const int mod = 998244353;
// const int mod = 998244853;
// const int mod = 1004535809;
// const int mod = 1000000007;

template<typename T> const T Mod(T x) { return x >= mod * 2 ? x % mod : (x >= mod ? x - mod : x); }
template<typename T> const void Add(T&a, T b) { a = Mod(a + b); }

inline int ksm(int x, int k) {
	int s = 1;
	while(k) {
		if(k & 1) s = Mod((ll)s * x);
		x = Mod((ll)x * x), k >>= 1;
	} return s;
}

const int MAXN = 1000010;

int n;

int col[MAXN];

int tot;
int fi[MAXN];
int ne[MAXN << 1];
int to[MAXN << 1];

inline void Link(int u, int v) {
	tot++;
	to[tot] = v;
	ne[tot] = fi[u];
	fi[u] = tot;
}

int All[MAXN];
int cnt[MAXN];
int nds[MAXN];
ll res[MAXN];
ll f[MAXN];
int si[MAXN];
int nd[MAXN];

inline void dfs(int x, int la) {
	int c = col[x], ct = cnt[c], flg = 0, pos = 0; si[x] = 1;
	for(int i = fi[x]; i; i = ne[i]) {
		int u = to[i];
		if(u == la) continue;
		int las = cnt[c];
		dfs(u, x);
		f[x] += 1LL * si[u] * si[x];
		si[x] += si[u];
		int sum = cnt[c] - ct;
		if(las != cnt[c]) ++flg, pos = u;
	} f[x] += 1LL * si[x] * (n - si[x]);
	if(ct || cnt[c] != All[c] - 1) ++flg; ++cnt[c];

	if(flg == 1) {
		if(!nds[c]) nd[c] = x;
		else res[c] = 1LL * si[nd[c]] * (pos ? n - si[pos] : si[x]);
		++nds[c];
	} // cerr << x << ' ' << flg << endl;
}

int main() {
#ifndef ONLINE_JUDGE
	FILE("");
#endif
	gi(n);
	for(int i = 1; i <= n; i++) gi(col[i]), All[col[i]]++, nd[col[i]] = i;
	for(int i = 1; i < n; i++) {
		int u, v; gi(u), gi(v);
		Link(u, v), Link(v, u);
	} dfs(1, 1);
	for(int i = 1; i <= n; i++) {
		if(All[i] == 0) print(1LL * n * (n - 1) >> 1);
		else if(All[i] == 1) print(f[nd[i]]);
		else if(nds[i] == 2) print(res[i]);
		else print(0);
		pc('\n');
	} return 0;
}
```

附上神仙 `ljc20020730` 的hack数据：

```plain
10
1 9 7 7 1 1 1 3 7 9
1 2
2 3
2 4
3 5
5 6
5 7
3 8
7 9
1 10
```

---

## 作者：TheShadow (赞：6)

# 闲扯

~~这题之前不是绿题吗，怎么 突然紫了。。。~~

upd：又变回去了
upd: 感谢 @风流瀑布 指出的错误，已经修改

# 题面

[P5588 小猪佩奇爬树](https://www.luogu.org/problem/P5588)

# Solution

这道题的要做的事是很清晰的：**给定一些点，问是否存在一条简单路径 $(u,v)$ 满足所有的点都在该路径上。如果有，请输出这种路径的个数。**

显然，这题的难点就在于怎么判断是否存在，至于方案，是很好计算的。

因为每个点的颜色不同，我们可以在计算点 $u$ 时，只看 $col_u$ 即可（主要是我自己做的时候一直很脑残，没想出来怎么搞）。

首先我们要明确的一点是：**每一条链，它一定存在两个端点**（端点定义为：它的子树中，除了自己有 $cnt_{col}-1$ 个颜色为 $col$ 的节点或者它的子树中没有相同颜色节点）。

分析一下合法的情况有哪些。

1. 没有这种颜色，答案为 $\frac{n\cdot(n-1)}{2}$ 。
2. 这种颜色只有一个点，答案为 $n-1+\sum_{i=1}^{tot}\sum_{j=1}^{i-1}sz_i\cdot sz_j$ ，其中 $tot$ 表示该节点子树的个数（包括整棵树除去以该节点为根结点的子树的部分）， $sz$ 表示该节点的子树的大小。
3. 恰好存在两个端点，且它们的 $LCA$ 不为其中的任何一个，答案为 $sz_u\cdot sz_v$ 。
4. 恰好存在两个端点，且它们的 $LCA$ 为其中的一个（假设为 $u$ ），答案为 $sz_v\cdot (n-sz_{to})$ 。其中 $to$ 表示 $u$ 的子节点中，子树包含 $v$ 的那一个。

而不合法的情况就是对于一种颜色，存在两个以上的端点。

所以我们只需要对于每种情况讨论一下，统计答案即可。

# Code

```c++
#include<bits/stdc++.h>
#define del(a,i) memset(a,i,sizeof(a))
#define ll long long
#define inl inline
#define il inl void
#define it inl int
#define ill inl ll
#define re register
#define ri re int
#define rl re ll
#define mid ((l+r)>>1)
#define lowbit(x) (x&(-x))
#define INF 0x3f3f3f3f
using namespace std;
template<class T>il read(T &x){
	int f=1;char k=getchar();x=0;
	for(;k>'9'||k<'0';k=getchar()) if(k=='-') f=-1;
	for(;k>='0'&&k<='9';k=getchar()) x=(x<<3)+(x<<1)+k-'0';
	x*=f;
}
template<class T>il _print(T x){
	if(x/10) _print(x/10);
	putchar(x%10+'0');
}
template<class T>il print(T x){
	if(x<0) putchar('-'),x=-x;
	_print(x);
}
ll mul(ll a,ll b,ll mod){long double c=1.;return (a*b-(ll)(c*a*b/mod)*mod)%mod;}
it qpow(int x,int m,int mod){
	int res=1,bas=x%mod;
	while(m){
		if(m&1) res=(1ll*res*bas)%mod;
		bas=(1ll*bas*bas)%mod,m>>=1;
	}
	return res%mod;
}
const int MAXN = 1e6+5;
int n,col[MAXN],u,v,head[MAXN],num_edge,num[MAXN],cnt[MAXN],tail[MAXN],sz[MAXN];
ll ans[MAXN],mx;
struct Edge{
	int next,to;
	Edge(){}
	Edge(int next,int to):next(next),to(to){}
}edge[MAXN<<1];
il add_edge(int u,int v){
	edge[++num_edge]=Edge(head[u],v),head[u]=num_edge;
	edge[++num_edge]=Edge(head[v],u),head[v]=num_edge;
}
il DFS(int u,int fa){
	int ct=cnt[col[u]],tot=0,fla=0;sz[u]=1;//ct 表示之前有多少该颜色出现，fla 记录是否第一次出现为情况4的上端点，tot 记录有几个子树中出现了这种颜色
	for(ri i=head[u],tmp=ct;i;i=edge[i].next){
		if(edge[i].to==fa) continue;
		DFS(edge[i].to,u),sz[u]+=sz[edge[i].to];
		if(cnt[col[u]]>tmp) ++tot,tmp=cnt[col[u]];
		if(num[col[u]]-1==cnt[col[u]]&&!ct&&tot==1&&!fla){
            // 说明除了这个点外，该颜色其他的点已经第一次全部出现，且是情况4
			fla=1;
			if(ans[col[u]]!=-1) ans[col[u]]=0;//如果之前已经计算过，说明有2个及以上的下端点，不合法
			else ans[col[u]]=1ll*sz[tail[col[u]]]*(n-sz[edge[i].to]);// 计算情况4
		}
	}
	if(num[col[u]]==1){// 说明为情况2，即只有一个点
		ans[col[u]]=0;
		for(ri i=head[u],tot=0;i;i=edge[i].next){
			if(edge[i].to==fa) continue;
			ans[col[u]]+=1ll*tot*sz[edge[i].to];
			tot+=sz[edge[i].to];
		}
		ans[col[u]]+=1ll*(sz[u]-1)*(n-sz[u])+n-1;
	}
	else if(!tot){//说明子树中没有该颜色的点，为一个下端点
		if(!tail[col[u]]) tail[col[u]]=u;//记录
		else{
			if(ans[col[u]]!=-1) ans[col[u]]=0;//出现非法情况
			else ans[col[u]]=1ll*sz[u]*sz[tail[col[u]]];//计算
		}
	}
	++cnt[col[u]];
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n),mx=1ll*n*(n-1)/2,del(ans,-1);
	for(ri i=1;i<=n;++i) read(col[i]),++num[col[i]];
	for(ri i=1;i<n;++i) read(u),read(v),add_edge(u,v);
	DFS(1,0);
	for(ri i=1;i<=n;++i){
		if(!num[i]) print(mx),puts("");
		if(num[i]) print(ans[i]),puts("");
	}
	return 0;
}
```

# 总结

感觉挺巧妙的一道题，主要是搞懂有几种情况，及什么时候出现这些情况。

---

## 作者：redegg (赞：5)

发一个$O(n)$的做法...

做法比较蠢，我们发现整个情况分4种：


1. $i$号颜色只有一个点。

2. $i$号颜色所有点处于一条链上。

3. $i$号颜色不存在。

4. 其它。

第三种答案为$n(n-1)/2$，答案为$0$的情况就是第四种。是两种特殊情况。

对于第一种，我们也可以把那个点作为根，枚举其子树，两不同子树上各选一点就是一种方案，处理一下就好了。

我们主要是如何求出第二种情况的答案和判断是否是第四种情况。

设$c[x]$为$x$的颜色。

我们设$vis[i]$为是否存在$i$号颜色的点入栈并且已经出栈（也就是是否已经dfs过了并且已经回溯了）。

回溯过程中如果$vis[c[x]]==0$，那么说明$x$点是目前搜索到的$c[x]$链的一个端点。（当然$c[x]$颜色也可能不存在链，这是后话）。

我们找到一个端点后，就开始记录目前链的长度，注意，这个链的长度计算是分两类的，一类是回溯到找到端点前的dfs经过的就点，另一类是访问找到端点前没有被访问过的新点。前一种长度+1，后一种去的时候+1，返回的时候-1。（画图理解一下）。

当我们记录某种颜色的链的长度和这种颜色的点数相同时，就说明当前点就是我们要找到的另一个端点了。

如果没找到的话，就说明是第四种情况。

两端点都找到了，我们也需要把这两端点分别作为根时，把存在相同颜色的子树给直接排除掉。然后两端点各自剩下的子树的大小相乘就是答案了。

说得好多，这题...是绿题QAQ。（120行代码我哭辽）

注意，1e6的话建议使用链式前向星，vector容易tle。

```
#include <bits/stdc++.h>
using namespace std;

const int MAXN=1e6+5;

int n;
int c[MAXN],v[MAXN];

int st[MAXN],en[MAXN],len[MAXN];
int wc[MAXN],w[MAXN],siz[MAXN];
int fa[MAXN];

bool vis[MAXN],vist[MAXN];

int cnt=0;
int head[2*MAXN];
int nxt[2*MAXN],to[2*MAXN];

void dfs(int x,int pr)
{
    fa[x]=pr;
    wc[c[x]]++;

    if(!vis[c[x]])vist[x]=1;

    for(int i=head[x];i;i=nxt[i]){
        int nx=to[i],nv=wc[c[x]];
        bool ok=0;
        if(nx==pr)continue;
        if(vis[c[nx]]){
            ok=1;
            len[c[nx]]++;
        }

        dfs(nx,x);

        w[x]+=w[nx];
        if(wc[c[x]]==nv)siz[x]+=w[nx];

        if(vis[c[nx]]&&ok)
            len[c[nx]]--;
    }
    w[x]++;

    if(!vis[c[x]]){
        st[c[x]]=x;
        vis[c[x]]=1;
    }
    if(vist[x]){
        len[c[x]]++;
    }
    if(len[c[x]]==v[c[x]])
        en[c[x]]=x;
}

long long run_eq(int i){
    int x=st[i];
    long long an=0;
    for(int i=head[x];i;i=nxt[i]){
        int nx=to[i];
        if(nx==fa[x])
            continue;

        an+=(w[1]-w[nx]-1)*((long long)w[nx]);
    }
    an+=(w[x]-1)*((long long)w[1]-w[x]);
    return an/2+w[1]-1;

}
long long run_si(int i){
    return ((long long)siz[st[i]]+1)*(siz[en[i]]+1);
}

void add_edge(int x,int y){
    cnt++;
    to[cnt]=y;
    nxt[cnt]=head[x];
    head[x]=cnt;
}

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&c[i]);
        v[c[i]]++;
    }
    for(int i=1;i<n;i++){
        int x,y;
        scanf("%d%d",&x,&y);
        add_edge(x,y);
        add_edge(y,x);
    }
    dfs(1,1);
    for(int i=1;i<=n;i++)
    {
        if(st[i]==0)
        {
            long long ans=(long long)n*(n-1)/2;
            printf("%lld\n",ans);
        }
        else if(en[i]==0)
            printf("0\n");
        else{
            long long ans=0;
            if(vist[en[i]]){
                siz[en[i]]=w[1]-w[en[i]]+siz[en[i]];
            }
            if(en[i]==st[i])
                ans=run_eq(i);
            else ans=run_si(i);
            printf("%lld\n",ans);
        }
    }

    return 0;
}

```


---

## 作者：fighter (赞：4)


这里是一种时空复杂度均为$O(n\log n)$的暴力做法。~~感觉这道题顺着思路想下去还是挺简单的。~~

题目的要求实际上是对于同种颜色的点，都必须在同一条链上。

那么我们自然想到把每一种颜色单独处理，先找到每种颜色中深度最大的那个点，显然如果这种颜色能符合一条链的条件，那么这个最深的点一定是链的一端，我们设它为$x$。

接着我们考虑另一端的位置。这里出现了三种情况（如果不存在这种颜色那么直接为0，下面不再讨论）：

1. 只有一个点是这种颜色，即另一端就是$x$。
2. 另一端是$x$的祖先。
3. 另一端不是$x$的祖先。

其实普遍状况是第三种（需要优先考虑），前两种都是符合题目要求的条件的，可以直接计算（具体见代码，第一种我通过$pre$数组预处理了）。

如何判断是否存在第三种情况呢？其实很简单，我们在这种颜色中寻找不是$x$的祖先的点中深度最大的点即可。

如果我们发现存在第三种情况，那么我们就要尝试验证它是否符合题目要求的条件。具体而言，设另一端为$y$，我们就是想要知道x->y这条链上是否包含了所有颜色与它们相同的点，也就是要求出一条链上有多少点是这种颜色的。

那么就可以想到使用树上差分的思想。我们求出每个点到根节点每种颜色分别有几个点。然后把$x$和$y$的答案相加再减去$lca$的答案即可（$lca$处特判是否是当前颜色）。

然后问题转化为求一个点到根节点的路径上包含的每种颜色的点的数量。我们可以想到使用**主席树**来维护。每个节点在其父亲的基础上进行修改，这样就可以在$n\log n$复杂度内完成统计。

## 代码

```cpp
#include <bits/stdc++.h>
#define MAX 2000005
#define MAXM 25000005
#define ll long long
#define mid ((l+r)>>1)
using namespace std;

template<typename T>
void read(T &n){
    n = 0;
    T f = 1;
    char c = getchar();
    while(!isdigit(c) && c != '-') c = getchar();
    if(c == '-') f = -1, c = getchar();
    while(isdigit(c)) n = n*10+c-'0', c = getchar();
    n *= f;
}

template<typename T>
void write(T n){
    if(n < 0) putchar('-'), n = -n;
    if(n > 9) write(n/10);
    putchar(n%10+'0');
}

int n, cnt, tot;
int head[MAX], vet[MAX*2], Next[MAX*2];
int col[MAX], sz[MAX], dep[MAX], f[MAX][21];
vector<int> v[MAX];

void add(int x, int y){
    cnt++;
    Next[cnt] = head[x];
    head[x] = cnt;
    vet[cnt] = y;
}

int s[MAXM], lc[MAXM], rc[MAXM], rt[MAX];
void build(int &p, int l, int r){
    if(!p) p = ++tot;
    if(l == r) return;
    build(lc[p], l, mid);
    build(rc[p], mid+1, r);
}

void update(int &p, int l, int r, int x, int last){
    p = ++tot;
    lc[p] = lc[last], rc[p] = rc[last], s[p] = s[last]+1;
    if(l == r) return;
    if(mid >= x) update(lc[p], l, mid, x, lc[last]);
    else update(rc[p], mid+1, r, x, rc[last]);
}

int query(int l, int r, int p, int x, int y, int z){      //z:lca
    if(l == r) return s[x]+s[y]-2*s[z];
    if(mid >= p) return query(l, mid, p, lc[x], lc[y], lc[z]);
    else return query(mid+1, r, p, rc[x], rc[y], rc[z]);
}

void dfs(int x, int fa){
    dep[x] = dep[fa]+1, sz[x] = 1;
    f[x][0] = fa;
    for(int i = 1; i <= 20; i++) f[x][i] = f[f[x][i-1]][i-1];
    update(rt[x], 1, n, col[x], rt[fa]);
    for(int i = head[x]; i; i = Next[i]){
        int v = vet[i];
        if(v == fa) continue;
        dfs(v, x);
        sz[x] += sz[v];
    }
}

int Lca(int x, int y){
    if(dep[x] < dep[y]) swap(x, y);
    for(int i = 20; i >= 0; i--){
        if(dep[f[x][i]] >= dep[y]) x = f[x][i];
    }
    if(x == y) return x;
    for(int i = 20; i >= 0; i--){
        if(f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];
    }
    return f[x][0];
}
int get(int x, int fa){
    for(int i = 20; i >= 0; i--){
        if(dep[f[x][i]] > dep[fa]) x = f[x][i];
    }
    return x;
}

bool cmp(int a, int b){
    return dep[a] > dep[b];
}

ll pre[MAX];

int main()
{
    cin >> n;
    for(int i = 1; i <= n; i++){
        read(col[i]);
        v[col[i]].push_back(i);
    }
    int x, y, lca = 0;
    for(int i = 1; i < n; i++){
        read(x), read(y);
        add(x, y), add(y, x);
    }
    build(rt[0], 1, n);
    dfs(1, 0);
    for(int i = 1; i <= n; i++){
        for(int j = head[i]; j; j = Next[j]){
            int v = vet[j];
            if(v == f[i][0]) continue;
            pre[i] += (ll)sz[v]*(n-sz[v]-1);
        }
        pre[i] += (ll)(n-sz[i])*(sz[i]-1);
        pre[i] /= 2;
        pre[i] += n-1;
    }
    for(int i = 1; i <= n; i++){
        if(v[i].empty()){
            write((ll)n*(n-1)/2), puts("");
            continue;
        }
        sort(v[i].begin(), v[i].end(), cmp);
        x = v[i][0];
        if(v[i].size() == 1){
            write(pre[x]), puts("");
            continue;
        }
        y = v[i][v[i].size()-1];
        for(int j = 1; j < v[i].size(); j++){
            lca = Lca(x, v[i][j]);
            if(lca != v[i][j]){
                y = v[i][j];
                break;
            }
        }
        if(y != lca){
            int t = query(1, n, i, rt[x], rt[y], rt[lca]);
            if(col[lca] == i) t++;
            if(t == v[i].size()){
                write((ll)sz[x]*sz[y]), puts("");
            }
            else puts("0");
        }
        else{
            write((ll)sz[x]*(n-sz[get(x, lca)])), puts("");
        }
    }

    return 0;
}
```



---

## 作者：TEoS (赞：4)

来自一名div2$100pts$的蒟蒻

题解和讨论区有的大佬用了一些例如主席树、虚树之类的神仙数据结构，也有的大佬可以用$O(n)$高效通过，本文的思路比较好想，不会太难理解，实现起来也不会太复杂，没有什么太难的知识点。虽然复杂度不是太优秀，但通过本题还是绰绰有余。~~毕竟难的本蒟蒻都不会qwq~~

------------
#### 题意分析

~~好像没什么好分析的~~

给你一棵带颜色的树，让你分别求出经过每种颜色所有节点的简单路径的方案数


------------
#### 思路解析

对于每种颜色，可以考虑构建一条链，连接其中两个节点，然后尝试其它节点能否连接上。我们可以先将所有节点按照深度大小排序，这样链的两个端点就是该颜色的深度最浅的两个节点。然后我们依次尝试相同颜色的节点，看能不能接到链上，如果能，就更新端点；否则说明无解，答案为0。

那么如何计算答案呢？

可以先预先对整棵树遍历一遍，设$dfn_i$和$siz_i$分别表示$i$节点在$dfs$时的次序和以$i$为根的子树大小。

可以发现，有以下几种最终链的情况：

1. 两个端点位于两棵不同的子树上，即两个端点互相不为父子
1. 两个端点为父子关系，即一个端点是另一个端点的祖先节点
1. 不存在可行解
1. 只有一个节点，即树上只有一个这种颜色的节点
1. 没有节点，即树上没有这种颜色的节点

下面对几种情况分别进行分析：

![](https://cdn.luogu.com.cn/upload/image_hosting/t0k0a0x7.png)

以上图为例：（设链的两个端点分别为$u,v$）

**第一种情况**

如图中6、8节点和9、10节点，链的两个端点互相不为父子，因为链上的所有节点都是必须取的，因此可以变动的就是两个端点上延伸出去的部分，即以两个端点为根的子树上变动。如9、10节点，有9、10,7、10，6、10三种方案。因此，对于第一种情况，根据乘法原理，有以下式子：
$$ans=siz_u×siz_v$$

**第二种情况**

如图中2、7号节点，2号节点是7号节点的祖先节点，分别考虑两端延伸出去的部分，从2号节点延伸出去有2、3、5、1、8五种方案，从7号节点延伸出去有7、6两种方案。可以看出，对于深度较大的端点，可以延伸的范围即以它为根的子树；对于深度较小的端点，可以延伸的范围即以它的子节点为根的除包含另一个端点的子树外的所有子树，以及除以它为根的子树外的所有节点，再加上它本身。因此，对于第二种情况，根据乘法原理，设$u$是$v$的祖先节点，$w$是$u$在链上的子节点，有以下式子：
$$ans=siz_v×(n-siz_w)$$

这种情况是很多人WA前三个点的原因，在此感谢W—T—Z大佬对本人debug的帮助。

**第三种情况**

如图中1、3、5节点，无法构造出一条链连接这三个节点，因此方案数是0。

**第四种情况**

如图中4节点和11节点，树中只存在一个该颜色的节点。以4号节点为例，先不考虑端点取它本身的情况，可以看出，根据乘法原理，假若以4号节点为整棵树的根节点，则方案数为它所有子树两两相乘，除以2，再加上以它本身为根的$n-1$种情况。

**第五种情况**

如果图中不存在该颜色的节点，则所有点对都是可行方案。因此，对于第五种情况，有以下式子：
$$ans=n*(n-1)/2$$


------------
#### 具体实现

**dfs预处理**

先dfs一遍预处理出每个节点的dfs次序和子树大小，并存储到存储节点数据的数组中，方便之后排序。

```cpp
//d(i)存储节点深度
void dfs(int x)
{
	d(x)=dfn[x]=++num;siz[x]=1;
	for(int i=head[x];i;i=Next[i])
		if(!dfn[ver[i]])
		{
			int y=ver[i];
			dfs(y);
			siz[x]+=siz[y];
		}
}
```
**构建初始链**

先将所有节点按照深度从小到大排序（本人最开始手残，直接按照节点颜色排序，居然AC了，所以是数据水还是不用排序也可行本人也不清楚，但实测没有排序80pts），执行以下判断：

1. 如果这个节点是该颜色的第一个节点，直接存为端点
1. 如果当前链只构建出一个端点（这种有两种情况，一种是当前节点是该颜色的第二个节点，一种是该颜色之前的节点都是某个节点的祖先节点），则判断当前节点是不是这个端点的后代，如果是，则替代这个端点作为新的端点，否则作为另一个端点
1. 如果当前链已经有两个端点，分别判断当前节点是不是端点的后代，如果是，则替代这个端点作为新的端点；如果当前节点不是两个端点的后代，说明该颜色无解，可以新建一个bool数组进行无解的特判，之后遇到这种颜色直接跳过

判断的同时维护每个颜色有几个端点。

从上面的步骤可以看出，存储的两个端点一定没有祖先和后代的关系。因此，为了解决第2种情况，可以存储每种颜色的第一个节点，即深度最小的节点。最终判断时，如果某种颜色的节点数大于1，而只存储了一个端点，说明该颜色的其它所有节点都是这个端点的祖先节点，而该颜色的第一个节点就是链的另一端。

怎么判断一个节点是否为另一个节点的子节点呢？因为预处理时执行的是深度优先搜索，因此一棵子树内的dfs次序一定是连续的，因此以一个节点$x$为根的子树的节点的dfs次序范围为$[dfn_x,dfn_x+siz_x-1]$，判断另一个节点是否在该范围内即可。

```cpp
//w(i)存储节点颜色，b(i)存储节点编号
void check()
{
	sort(P+1,P+n+1,cmp);//按深度升序排序
	for(int i=1;i<=n;i++)
	{
		if(!cnt[w(i)])
			h[w(i)]=b(i);//存储该颜色第一个节点
		cnt[w(i)]++;//维护该颜色的节点数
		if(p[w(i)])
			continue;//该颜色无解直接跳过
		if(!tail[w(i)][1]) //没有存储第二个端点
		{
			if(!tail[w(i)][0])
				tail[w(i)][0]=b(i);//直接存储该颜色第一个节点作为端点
			else//已存储一个端点的情况
			{
				int la=tail[w(i)][0];
				if(dfn[la]+siz[la]>dfn[b(i)] && dfn[b(i)]>dfn[la])
					tail[w(i)][0]=b(i); //是该端点的后代节点则替代
				else
					tail[w(i)][1]=b(i);//不是则作为另一个端点
			}
			continue;
		}
		int la1=tail[w(i)][0],la2=tail[w(i)][1];
		bool ok=0;//判断有无解
		if(dfn[la1]+siz[la1]>dfn[b(i)] && dfn[b(i)]>dfn[la1])
			tail[w(i)][0]=b(i),ok=1;
		if(dfn[la2]+siz[la2]>dfn[b(i)] && dfn[b(i)]>dfn[la2])
			tail[w(i)][1]=b(i),ok=1;//分别判断是不是两个端点的后代节点，是则替代
		if(!ok)
			p[w(i)]=1;//无解标记
	}
}
```
**统计答案**

按照五种情况分别计算解，上面已经将得很清楚了，这里就不再赘述。

```cpp
void solve()
{
	for(int i=1;i<=n;i++)
	{
		if(p[i])
		{
			puts("0");
			continue;
		}//第三种情况，无解
		if(cnt[i]<2)//节点数小于2，即第四或第五种情况
		{
			if(!cnt[i])
				printf("%lld\n",(ll)n*(n-1)/2);//第五种情况
			else
			{
				int now=tail[i][0];
				ll ans=0;
				ans+=(ll)(n-siz[now])*(siz[now]-1);//非该节点的子节点与该节点的子节点构成的方案
				for(int i=head[now];i;i=Next[i])
				{
					if(dfn[ver[i]]<dfn[now])
						continue;
					ans+=(ll)(n-siz[ver[i]]-1)*siz[ver[i]];//该节点的一棵子树与其它节点构成的方案
				}
				printf("%lld\n",ans/2+n-1);
			}//第四种情况
			continue;
		}
		if(!tail[i][1])
		{
			int now=tail[i][0];
			for(int j=head[h[i]];j;j=Next[j])
				if(dfn[h[i]]<dfn[ver[j]] && dfn[ver[j]]+siz[ver[j]]>dfn[now] && dfn[now]>=dfn[ver[j]])//找到该节点在链上的子节点，注意这里有可能这个子节点就是另一个端点，因此可以取等号
				{
					printf("%lld\n",(ll)siz[now]*(n-siz[ver[j]]));
					continue;
				}
		}//第二种情况
		else
			printf("%lld\n",(ll)siz[tail[i][1]]*siz[tail[i][0]]);//第一种情况
	}
}
```


------------
最后奉上完整代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
#define w(i) P[i].w
#define b(i) P[i].b
#define d(i) P[i].d
using namespace std;
const int N=2e6,M=2e6;
struct Pointer//雾
{
	int w,b,d;
}P[N];
int n,tot,num;
int head[N],ver[2*M],Next[2*M];
int dfn[N],siz[N],tail[N][2],cnt[N],h[N];
bool p[N];
void add(int x,int y)
{
	ver[++tot]=y,Next[tot]=head[x],head[x]=tot;
	ver[++tot]=x,Next[tot]=head[y],head[y]=tot;
}
bool cmp(Pointer a,Pointer b)
{
	return a.d<b.d;
}
void dfs(int x)
{
	d(x)=dfn[x]=++num;siz[x]=1;
	for(int i=head[x];i;i=Next[i])
		if(!dfn[ver[i]])
		{
			int y=ver[i];
			dfs(y);
			siz[x]+=siz[y];
		}
}//dfs预处理
void check()
{
	sort(P+1,P+n+1,cmp);
	for(int i=1;i<=n;i++)
	{
		if(!cnt[w(i)])
			h[w(i)]=b(i);
		cnt[w(i)]++;
		if(p[w(i)])
			continue;
		if(!tail[w(i)][1]) 
		{
			if(!tail[w(i)][0])
				tail[w(i)][0]=b(i);
			else
			{
				int la=tail[w(i)][0];
				if(dfn[la]+siz[la]>dfn[b(i)] && dfn[b(i)]>dfn[la])
					tail[w(i)][0]=b(i); 
				else
					tail[w(i)][1]=b(i);
			}
			continue;
		}
		int la1=tail[w(i)][0],la2=tail[w(i)][1];
		bool ok=0;
		if(dfn[la1]+siz[la1]>dfn[b(i)] && dfn[b(i)]>dfn[la1])
			tail[w(i)][0]=b(i),ok=1;
		if(dfn[la2]+siz[la2]>dfn[b(i)] && dfn[b(i)]>dfn[la2])
			tail[w(i)][1]=b(i),ok=1;
		if(!ok)
			p[w(i)]=1;
	}
}//构建初始链
void solve()
{
	for(int i=1;i<=n;i++)
	{
		if(p[i])
		{
			puts("0");
			continue;
		}
		if(cnt[i]<2)
		{
			if(!cnt[i])
				printf("%lld\n",(ll)n*(n-1)/2);
			else
			{
				int now=tail[i][0];
				ll ans=0;
				ans+=(ll)(n-siz[now])*(siz[now]-1);
				for(int i=head[now];i;i=Next[i])
				{
					if(dfn[ver[i]]<dfn[now])
						continue;
					ans+=(ll)(n-siz[ver[i]]-1)*siz[ver[i]];
				}
				printf("%lld\n",ans/2+n-1);
			}
			continue;
		}
		if(!tail[i][1])
		{
			int now=tail[i][0];
			for(int j=head[h[i]];j;j=Next[j])
				if(dfn[h[i]]<dfn[ver[j]] && dfn[ver[j]]+siz[ver[j]]>dfn[now] && dfn[now]>=dfn[ver[j]])
				{
					printf("%lld\n",(ll)siz[now]*(n-siz[ver[j]]));
					continue;
				}
		}
		else
			printf("%lld\n",(ll)siz[tail[i][1]]*siz[tail[i][0]]);
	}
}//统计答案
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&w(i)),b(i)=i;
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(1);
	check();
	solve();
	return 0;
}
```

希望对大家有帮助，有不足之处请指出

---

## 作者：Tommy_clas (赞：3)

前言：中午没有打比赛，尽管想出了做法但是没有来得及写，然后下午两点一到就滚粗了，结果在比赛结束后半个小时就调过并且AC了QAQ。

[传送门](https://www.luogu.org/problem/P5588)

题目大意：有一棵$n$个点的树（$n≤1e6$），每个点都有一个颜色，对于每一种颜色$i$，求包含所有颜色为$i$的点的路径的数量。

首先，这是一道树上记数题。

理解题意之后，我们会发现：**当且仅当同一个颜色的点都位于一条链上时，该颜色的答案才不为0，其它情况答案都会为0。**

那么我们只需要针对每个颜色讨论该颜色的点在树上的关系就行了。

“我知道，我知道，要用虚树！”

“好的，请坐下，然而我们并不一定要直接建立虚树，而是建立一种类似虚树的东西。”

我们对于每个点$i$，求出它的祖先中最靠近它的与它颜色相同的节点（没有就为0）,记为$p[i]$，这个可以在$dfs$的时候求，设置一个辅助记录数组$last[i]$，表示在当前$dfs$栈中，最靠下的颜色为$i$的点的编号，显然$p[i]=last[w[i]]$，在开始点$i$的$dfs$时$last[w[i]]$应当更新，在退出点$i$的$dfs$时$last[w[i]]$应当还原。

做完之后，我们会发现，如果我们将$p[u]==v$看作是$u$向$v$连了一条边，而$p[u]==0$看作$u$是一个根节点，那么我们就针对每一种颜色都建立了一座$dfs$森林。我们的问题就转化到了如何处理这些森林上。

我们可以先记录一下每个点在新构成的森林中的入度和出度。由于一个颜色的答案不为$0$的要求是所有该颜色的点能在一条链上，所以如果某种颜色的森林出现了树状结构（即一个点的总度数大于$2$），那么这种颜色答案肯定为$0$。

接下来就是判断剩下的链是否能构成一个长链了。

我们可以分下列情况考虑：

 1. 只有一条横跨两端点的$LCA$的链(只有一个点出度为0，只有两个点入度为0，且两个入度为0的点的$LCA$是那个出度为0的点)，它明显是一条包含该颜色的所有点的最短的链。经过它的链都是可以计入答案的合法链，因此该颜色的答案就是链的两端点的子树的大小之积。
 2. 存在两条竖直的链（入度为0、出度为0的点分别有且仅有有两个），这两条竖直的链一定能和中间的若干无关点构成一条横跨两端点的$LCA$的链，然后处理方式就和1一样了。
 3. 仅存在一条竖直的链（入度为0，出度为0的点分别仅有一个），我们可以按照1的做法类比过来，求两端点的“子树”大小，下端的点的子树大小取值依然不变，但是上端的点的子树大小应当进行调整，如下图所示：![](https://cdn.luogu.com.cn/upload/image_hosting/l7ceae63.png)我们想求的“子树”大小其实是$v$加上另外两个大圆中的点，直接可以用$n$减去$v$在链上对应的真正的儿子$v_c$的子树大小，就可以得到我们想求的“子树”大小。

这样我们就能统计每个颜色构成的森林对该颜色的答案的贡献了。

但这还没有结束。

我们还没有考虑某些颜色只有一个点甚至是没有点的情况。

如果没有点，那么任意路径都是满足的，答案就是所有的路径数（点对） $\frac{n\times (n-1)}{2} $。

如果只有一个点，那么问题就转化成了“经过一个点的路径的数目”，其实就是 $ans[u]=\sum_{i=u_{ch},j=u_{ch},i!=j}siz[i]\times siz[j]$其中$u$设为树的根,这个在$dfs$的时候可以顺便求出来。

时间复杂度：整个计数过程是$O(n)$的，但是欧拉序求$LCA$预处理时间复杂度是$O(nlog_2n)$，所以总复杂度$O(nlog_2n)$。

上代码：
```cpp
#include<cstdio>
#include<vector>
#include<cmath>
#define N 1000005
#define ll long long
using namespace std;
int n,last[N],v[N],head[N],siz[N],cnt;
int p[N],din[N],dout[N],ch[N],pch[N];
int a[N],b[N];
ll ans[N],ans2[N];
vector<int>s[N];
int pos[N],mindep[25][N][2],eun,dep[N];
void minx(int a[],int b[],int c[])
{
	if(a[0]<b[0])c[0]=a[0],c[1]=a[1];
	else c[0]=b[0],c[1]=b[1];
}
struct edge
{
	int to,nxt;
}w[2*N];
int read()
{
	char c=0;
	int res=0;
	while(c<'0'||'9'<c)c=getchar();
	while('0'<=c&&c<='9')res=res*10+c-'0',c=getchar();
	return res;
}
void add(int x,int y)
{
	w[++cnt]=(edge){y,head[x]};
	head[x]=cnt;
}
void dfs(int x,int fa)
{
	siz[x]=1;
	p[x]=last[v[x]];
	pch[last[v[x]]]=ch[last[v[x]]];
	int temp=last[v[x]];
	last[v[x]]=x;
	ll sum=0;
	dep[x]=dep[fa]+1;
	pos[x]=++eun;
	mindep[0][eun][0]=dep[x];
	mindep[0][eun][1]=x;
	for(int i=head[x];i;i=w[i].nxt)
	{
		int y=w[i].to;
		if(y==fa)continue;
		ch[x]=y;
		dfs(y,x);
		++eun;
		mindep[0][eun][0]=dep[x];
		mindep[0][eun][1]=x;
		sum+=(ll)siz[x]*(ll)siz[y];
		siz[x]+=siz[y];
	}
	sum+=(ll)siz[x]*(ll)(n-siz[x]);
	ans2[x]=sum;
	last[v[x]]=temp;
}
void ST()//欧拉序求LCA
{
	int k=log(n)/log(2);
	for(int i=1;i<=k;i++)
		for(int j=1;j+(1<<i)-1<=n;j++)
			minx(mindep[i-1][j],mindep[i-1][j+(1<<(i-1))],mindep[i][j]);
}
int LCA(int x,int y)
{
	x=pos[x],y=pos[y];
	if(x>y)swap(x,y);
	int k=log(y-x+1)/log(2);
	int temp[2]={0,0};
	minx(mindep[k][x],mindep[k][y-(1<<k)+1],temp);
	return temp[1];
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
		v[i]=read(),s[v[i]].push_back(i);
	for(int i=1,x,y;i<n;i++)
	{
		x=read(),y=read();
		add(x,y),add(y,x);
	}
	dfs(1,0);
	ST();
	for(int i=1;i<=n;i++)
		if(p[i])din[p[i]]++,dout[i]++;
	for(int i=1;i<=n;i++)//统计答案 
	{
		bool flag=1;
		a[0]=0,b[0]=0;
		for(int j=0;j<(int)s[i].size()&&flag;j++)
		{
			if(din[s[i][j]]+dout[s[i][j]]>2)flag=0;
			if(!dout[s[i][j]])a[++a[0]]=s[i][j];
			if(!din[s[i][j]])b[++b[0]]=s[i][j];
		}
		if(!flag)continue;
		if(b[0]==2&&(a[0]==1||a[0]==2))
		{
			if(a[0]==1&&LCA(b[1],b[2])!=a[1])continue;
			ans[i]=(ll)siz[b[1]]*(ll)siz[b[2]];
		}
		else if(a[0]==1&&b[0]==1)
		{
			if(a[1]==b[1])ans[i]=ans2[a[1]];
			else ans[i]=(ll)siz[b[1]]*(ll)(n-siz[pch[a[1]]]);
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(s[i].empty())printf("%lld\n",(ll)n*(ll)(n-1)/2);
		else printf("%lld\n",ans[i]);
	}
	return 0;
}
```

感谢 @Bruner 提供$hack$数据并指出做法的漏洞，题解已修改。

---

## 作者：UperFicial (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P5588)。

同步发表于我的 [$\text{cnblogs}$](https://www.cnblogs.com/UperFicial/p/16721441.html)。

来一个不一样的工程做法。

我们直接对于每一个颜色 $i$ 建虚树，显然可以通过树形 DP 来判断颜色 $i$ 的节点是否在一条路径上。[原题](https://www.luogu.com.cn/blog/UperFicial/solution-cf1702g2)。

然后存一下这条路径的左右端点，这个实现的话可以分类讨论一下，就分一下竖直链还是绕过 LCA 的链。

做完这个就可以算方案数。

- 如果颜色 $i$ 没有点。那么方案数显然为路径总数，$\frac{n(n-1)}{2}$。

- 如果颜色 $i$ 只有一个节点 $u$，那么任何一个包含 $u$ 的路径都可。这里分成两部分。

	- 一种情况是，在它的各个儿子所在的子树中，每个子树选一个点，两两配对；
    
   - 或者，考虑在它儿子中选一个点，和 $u$ 子树外的节点配对。
   
	这个容易实现，记录一下子树大小然后一遍前缀和即可。

- 如果 $i$ 有多个节点，设两端点为 $x,y$，$x$ 深度较小。

	- 如果 $x$ 是 $y$ 的祖先，那么合法路径的端点可存在于三部分，$y$ 的儿子，$x$ 的除了 $x\to y$ 这个子树上的节点，以及 $x$ 子树外的节点。这个的实现方法根第二种情况一样。
    
   - 如果 $x,y$ 绕过了 $x,y$ 的 LCA，那么方案数肯定是 $x,y$ 子树各选一个点的方案数。$siz[x]\times siz[y]$。
   
然后你就开始写，很快啊！压压行后 6kb 就直接上去了啊！不过完全不过瘾啊！

时间复杂度 $\Theta(n\log n)$。

高能代码：

```cpp
const int MAXN(2e6+10);

int n,vir[MAXN];
vector<int>col[MAXN],G[MAXN];
bool flag[MAXN];

struct E{int to,nxt;};
E edge[MAXN<<1];

int head[MAXN],tot;

inline void add_edge(int u,int v)
{
	edge[++tot].nxt=head[u];
	head[u]=tot;
	edge[tot].to=v;
	return;
}

int par[MAXN][23],dep[MAXN],dfn[MAXN],t,siz[MAXN];

inline void dfs(int u,int fa)
{
	par[u][0]=fa,dep[u]=dep[fa]+1;
	dfn[u]=++t,siz[u]=1;
	rep(i,1,22) par[u][i]=par[par[u][i-1]][i-1];
	gra(i,u)
	{
		E e=edge[i];
		if(e.to==fa) continue;
		dfs(e.to,u);
		siz[u]+=siz[e.to];
	}
	return;
}

inline int LCA(int x,int y)
{
	if(dep[x]<dep[y]) Swap(x,y);
	rev(i,22,0) if(dep[par[x][i]]>=dep[y]) x=par[x][i];
	if(x==y) return x;
	rev(i,22,0) if(par[x][i]!=par[y][i]) x=par[x][i],y=par[y][i];
	return par[x][0];
}

inline bool cmp(int x,int y){return dfn[x]<dfn[y];}

int que[MAXN],tail,rt,in[MAXN],out[MAXN],f[MAXN];

inline void build(int k)
{
	sort(vir+1,vir+1+k,cmp);
	int now=k;
	rep(i,2,k)
	{
		int g=LCA(vir[i],vir[i-1]);
		if(g!=vir[i]&&g!=vir[i-1]) vir[++now]=g;
	}
	sort(vir+1,vir+1+now);
	now=unique(vir+1,vir+1+now)-vir-1;
	sort(vir+1,vir+1+now,cmp);
	que[++tail]=vir[1];
	rep(i,2,now)
	{
		int g=LCA(vir[i],vir[i-1]);
		G[g].push_back(vir[i]);
		que[++tail]=g;
		que[++tail]=vir[i];
		++in[vir[i]],++out[g];
	}
	rep(i,1,tail)
	{
		int u=que[i];
		if(in[u]==0) rt=u;
	}
	return;
}

inline void MEMSET(int c)
{
	rep(i,0,(int)col[c].size()-1)
	{
		int now=col[c][i];
		flag[now]=false;
	}
	rep(i,1,tail)
	{
		int u=que[i];
		G[u].clear();
		in[u]=0;
		f[u]=-1;
	}
	tail=0;
	return;
}

int ans[2];
int tp2,st2[MAXN];

inline void findinline(int u)
{
	bool pp=false;
	if(!ans[1]&&flag[u]) ans[1]=u;
	rep(i,0,(int)G[u].size()-1)
	{
		int v=G[u][i];
		if(f[v]==1) findinline(v);
		pp=true;
	}
	if(!pp) ans[0]=u;
	return;
}

inline void dfs2(int u)
{
	bool pp=false;
	rep(i,0,(int)G[u].size()-1)
	{
		int v=G[u][i];
		dfs2(v);
		pp=true;
	}
	if(!pp)
	{
		if(!ans[0]) ans[0]=u;
		else ans[1]=u;
	}
	return;
}

inline void findans()
{
	if(f[rt]==1) findinline(rt);
	else dfs2(rt);
}

inline ll C(int x)
{
	return 1ll*x*(x-1)/2;
}

int st[MAXN],tp;

inline ll fuckyou(int u)
{
	ll res=0;
	tp=0;
	gra(i,u)
	{
		int v=edge[i].to;
		if(v!=par[u][0]) st[++tp]=siz[v];
		else st[++tp]=n-siz[u];
	}
	ll sum=0;
	rev(i,tp,1)
	{
		res=res+st[i]*sum;
		sum+=st[i];
	}
	rep(i,1,tp) res+=st[i];
	return res;
}

inline void checkline(int u)
{
	bool pp(false);
	int tot1=0,tot2=0;
	rep(i,0,(int)G[u].size()-1)
	{
		int v=G[u][i];
		checkline(v);
		if(f[v]==1) ++tot1;
		else if(f[v]==0) ++tot2;
		else
		{
			f[u]=-1;
			return;
		}
		pp=true;
	}
	if(!pp)
	{
		f[u]=1;
		return;
	}
	if(tot1+tot2>=3) f[u]=-1;
	else if(tot2==2) f[u]=-1;
	else if(tot1==2) f[u]=0;
	else if(tot2==2) f[u]=-1;
	else if(tot1==1&&tot2==1) f[u]=-1;
	else if(tot1==1&&tot2==0) f[u]=1;
	else if(tot1==0&&tot2==1)
	{
		if(flag[u]) f[u]=-1;
		else f[u]=0;
	}
	return;
}

inline ll fuckyou2(int x,int y)
{
	tp=0,tp2=0;
	gra(i,x)
	{
		int v=edge[i].to;
		if(v!=par[x][0])
		{
			if(LCA(v,y)!=v) st[++tp]=siz[v];
		}
		else st[++tp]=n-siz[x];
	}
	gra(i,y)
	{
		int v=edge[i].to;
		if(v!=par[y][0]) st2[++tp2]=siz[v];
	}
	ll res=0;
	rep(i,1,tp) res+=st[i];
	rep(i,1,tp2) res+=st2[i];
	++res;
	ll sum=0;
	rep(i,1,tp2) sum+=st2[i];
	rep(i,1,tp) res=res+1ll*st[i]*sum;
	return res; 
}

inline void solve(int k)
{
	int fuck=0;
	rep(i,1,tail) if(out[que[i]]==0) ++fuck;
	if(fuck>2)
	{
		puts("0");
		return;
	}
	checkline(rt);
	if(f[rt]==-1)
	{
		puts("0");
		return;
	}

	findans();
	if(k==1)
	{
		printf("%lld\n",fuckyou(ans[0]));
		return;
	}
	if(LCA(ans[0],ans[1])==ans[1])
	{
		// puts("YES");
		printf("%lld\n",fuckyou2(ans[1],ans[0]));
		return;
	}
	printf("%lld\n",1ll*siz[ans[0]]*siz[ans[1]]);
	return;
}

int main()
{
    n=read();
    rep(i,1,n)
    {
    	int x=read();
    	col[x].push_back(i);
    }
    rep(i,2,n)
    {
    	int u=read(),v=read();
    	add_edge(u,v),add_edge(v,u);
    }
    dfs(1,0);
    dep[0]=0,dep[n+1]=INF;
    memset(f,-1,sizeof(f));
    rep(i,1,n)
    {
    	if(col[i].empty())
    	{
    		printf("%lld\n",1ll*(n-1)*n/2);
    		continue;
    	}
    	ans[0]=0,ans[1]=0;
    	int k=col[i].size();
    	rep(j,0,k-1) vir[j+1]=col[i][j];
    	rep(i,1,k) flag[vir[i]]=true;
    	build(k);
    	solve(k);
    	MEMSET(k);
    }
    return 0;
}
/*
Date : 2022/9/22
Author : UperFicial
Start coding at : 19:41
finish debugging at : 7:30
*/
```
   


---

## 作者：小菜鸟 (赞：1)

简述题意：树上每个点有一种颜色。对于每种颜色，求经过**所有该颜色的点**的路径数量。

---

刚看完这题秒出一个$O(n^2)$算法，准备拿60...因为是暴力分就只开了$n=10000$的空间

然后考完发现这个玩意跑得挺快的

然后开大空间，开`long long`交一发（

**过了。。。**

我\*\*\*\*\*

---

首先我们可以想到，对于一种颜色的点，如果存在这样的路径，则只有两种情况：

* 存在一个深度最大的点，其他这种颜色的点都是其祖先，形成一条链。

* 存在两条如上一条所述且互不相交的链

如果都不是，直接判无解就行。

而对于不存在的颜色，答案显然是$\frac{n(n-1)}{2}$

然后上面这两种情况都会得到一条经过所有该颜色的点的最短路径。

把链上面的树枝全部砍掉，只剩下两个端点$u,v​$上的子树

我们发现答案就是两个子树大小乘起来。

交一发，WA 0 pts...

我们可以发现这条链可能是一个点。那么把以该点为根时所有子树的大小两两相乘就是答案。。。

然后就可以$O(n^2)$\*过去了。。。

我找链用了set+暴力跳父亲，因此复杂度是错的...不知道正解该怎么做...

```cpp
#include<cstdio>
#include<set>

#define int long long

const int N=1<<15;

int n,head[N],size[N],fa[N],dep[N],col[N];

struct Edge
{
    int next,to;
};
Edge E[N<<1];
void add(int u,int v)
{
    static int tot=0;
    E[++tot].next=head[u];
    E[tot].to=v;
    head[u]=tot;
}

std::set<std::pair<int,int> > pts[N];

void dfs(int u)
{
    size[u]=1;
    pts[col[u]].insert(std::make_pair(-dep[u],u));
    for(int i=head[u];i;i=E[i].next)
    {
        int v=E[i].to;
        if(v==fa[u])continue;
        fa[v]=u;
        dep[v]=u+1;
        dfs(v);
        size[u]+=size[v];
    }
}

int check_ans(int c)
{
    if(pts[c].empty())return n*(n-1)/2;
    if(pts[c].size()==1)
    {
        int u=(*pts[c].begin()).second;
        int sum=0,res=0;
        for(int i=head[u];i;i=E[i].next)
        {
            int v=E[i].to;
            if(v==fa[u])continue;
            res+=sum*size[v];
            sum+=size[v];
        }
        if(fa[u])
        {
            res+=(n-size[u])*sum;
        }
        return res+n-1;
    }
    int u=(*pts[c].begin()).second,v,t=u;
    pts[c].erase(std::make_pair(-dep[u],u));
    int except=u;
    while(fa[t])
    {
        if(col[fa[t]]==c)
        {
            v=fa[t];
            except=t;
            pts[c].erase(std::make_pair(-dep[fa[t]],fa[t]));
        }
        t=fa[t];
    }
    if(pts[c].empty())
    {
        return size[u]*(n-size[except]);
    }
    v=(*pts[c].begin()).second,t=v;
    pts[c].erase(std::make_pair(-dep[v],v));
    while(fa[t])
    {
        if(col[fa[t]]==c)
        {
            if(pts[c].erase(std::make_pair(-dep[fa[t]],fa[t]))==0)return 0;
        }
        t=fa[t];
    }
    if(!pts[c].empty())return 0;
    return size[u]*size[v];
}

signed main()
{
    scanf("%lld",&n);
    for(int i=1;i<=n;++i)scanf("%lld",col+i);
    for(int i=1;i<n;++i)
    {
        int u,v;
        scanf("%lld%lld",&u,&v);
        add(u,v);
        add(v,u);
    }
    dfs(1);
    for(int i=1;i<=n;++i)printf("%lld\n",check_ans(i));
}
```



---

## 作者：ljc20020730 (赞：0)

本题可以直接无脑写一个虚树。

时间复杂度依然是优美的$O(n \ log_2 \ n)$。

考虑对于每一个颜色分别处理，建出$n$个颜色的$n$棵虚树。

设第$i$个颜色有$k_i$个节点，那么显然这棵虚树上的节点个数是在$k_i$这个级别上的。

虚树的根设为该颜色所有节点的共同$lca$,求多个节点的$lca$怕已经是$trick$题了。

直接找出$dfs$序最小和$dfs$序最大的两个节点，求一下$lca$即可。

首先，这棵树必然没有度数为$2$的节点，如果有，那么直接输出$0$

否则，按照根节点的度数是$1$还是$2$分类讨论。

如果是$1$ ， 那么就是一个以$1$为根的链型，我们直接可以$dfs$找到虚树中最深的节点把它拿出来。而此时的树根必然是一个标记点。

如果是$2$ , 那么就是以$1$为根挂下两根链，我们直接$dfs$找出这两根链的最深处的两个节点。

相信只要找出这一条链，大家就不难考虑求出最终的答案了。

需要特殊考虑的是，只有$0$个节点或者$1$个节点的情况，这需要分类讨论。

对于$1$个节点的情况，可以考虑补集转化，即求出子树中的路径个数，用总路径个数减去。

这样，本题的时间复杂度就是美妙且暴力的$O(n \ log_2 \ n)$

> $Ps : $ 不知道蒟蒻写个这个虚树为什么跑的那么慢，下面的代码需要开$O2$才能cao过$3s$时限....

```cpp
# include<bits/stdc++.h>
# define int long long
using namespace std;
namespace fast_IO{
    const int IN_LEN = 10000000, OUT_LEN = 10000000;
    char ibuf[IN_LEN], obuf[OUT_LEN], *ih = ibuf + IN_LEN, *oh = obuf, *lastin = ibuf + IN_LEN, *lastout = obuf + OUT_LEN - 1;
    inline char getchar_(){return (ih == lastin) && (lastin = (ih = ibuf) + fread(ibuf, 1, IN_LEN, stdin), ih == lastin) ? EOF : *ih++;}
    inline void putchar_(const char x){if(oh == lastout) fwrite(obuf, 1, oh - obuf, stdout), oh = obuf; *oh ++= x;}
    inline void flush(){fwrite(obuf, 1, oh - obuf, stdout);}
    int read(){
        int x = 0; int zf = 1; char ch = ' ';
        while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar_();
        if (ch == '-') zf = -1, ch = getchar_();
        while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar_(); return x * zf;
    }
    void write(int x){
        if (x < 0) putchar_('-'), x = -x;
        if (x > 9) write(x / 10);
        putchar_(x % 10 + '0');
    }
}
using namespace fast_IO;
const int N=1e6+10;
struct rec{ int pre,to;}a[N<<1];
vector<int>v[N],E[N];
stack<int>s;
bool ok[N];
int n,tot;
int head[N],size[N],is[N],dep[N],dfn[N],du[N];
int g[N][22]; 
void adde(int u,int v) 
{
	a[++tot].pre=head[u];
	a[tot].to=v;
	head[u]=tot;
}
void dfs1(int u,int fa) {
	size[u]=1; g[u][0]=fa; 
	dep[u]=dep[fa]+1; dfn[u]=++dfn[0];
	for (int i=head[u];i;i=a[i].pre) {
		int v=a[i].to; if (v==fa) continue;
		dfs1(v,u); size[u]+=size[v];
	}
}
int lca(int u,int v) {
	if (dep[u]<dep[v]) swap(u,v);
	for (int i=21;i>=0;i--) 
		if (dep[g[u][i]]>=dep[v]) u=g[u][i];
	if (u==v) return u;
	for (int i=21;i>=0;i--)
		if (g[u][i]!=g[v][i]) u=g[u][i],v=g[v][i];
	return g[u][0];		
}
int Ref;
void clear(int u,int fa) {
	ok[u]=0; du[u]=0;
	for (int i=0;i<(int)E[u].size();i++) {
		int v=E[u][i]; if (v==fa) continue;
		clear(v,u);
	}
	E[u].clear();
}
void dfs2(int u,int fa) {
	if (ok[u]) Ref=u;
	for (int i=0;i<(int)E[u].size();i++) {
		int v=E[u][i]; if (v==fa) continue;
		dfs2(v,u);
	}
}
bool cmp(int a,int b) {
	return dfn[a]<dfn[b];
}
bool work(int col) {
	while (s.size()) s.pop(); int cnt=0;
	for (int i=0;i<(int)v[col].size();i++) 
		is[++cnt]=v[col][i],ok[is[cnt]]=1;
	int Min=is[1],Max=is[1];	
	for (int i=2;i<=cnt;i++) {
		if (dfn[Min]>dfn[is[i]]) Min=is[i];	
		if (dfn[Max]<dfn[is[i]]) Max=is[i];
	}
	int rt=lca(Min,Max); 
	sort(is+1,is+1+cnt,cmp);
	s.push(rt);
	int res = 0; bool oo = true;
	for (int i=1;i<=cnt;i++) if (is[i]!=rt) {
		int u=is[i],l=lca(u,s.top());
		while (s.top()!=l) {
			int tmp=s.top();s.pop();
			if (dfn[s.top()]<dfn[l]) s.push(l);
			res++;
			E[s.top()].push_back(tmp);
			E[tmp].push_back(s.top());
			du[s.top()]++; du[tmp]++;
			res++;
			if (du[s.top()]>2 || du[tmp]>2) {
				oo=false;
			}
		}
		s.push(u);
	}
	while (s.top()!=rt) {
		int tmp=s.top();s.pop();
		E[s.top()].push_back(tmp);
		E[tmp].push_back(s.top());
		res++;
		du[s.top()]++; du[tmp]++;
		if (du[s.top()]>2 || du[tmp]>2) {
			oo=false;
		}
	}
	if (!oo) {
		clear(rt,0); return false;
	}
	if (E[rt].size()==1) {
		int u=rt,v; dfs2(rt,0); v=Ref;
		int s1=size[v];
		for (int i=21;i>=0;i--) 
			if (dep[g[v][i]]>=dep[u]+1) v=g[v][i];	
		int s2=n-size[v];
		write(s1*s2); putchar_('\n');
	} else {
		int u,v; 
		dfs2(E[rt][0],rt); u=Ref;
		dfs2(E[rt][1],rt); v=Ref;
		write(size[u]*size[v]); putchar_('\n');
	}
	clear(rt,0);
	return true;
}
signed main()
{
	n=read();
	for (int i=1;i<=n;i++) {
		int t=read();
		v[t].push_back(i);
	}
	for (int i=2;i<=n;i++) {
		int u=read(),v=read();
		adde(u,v); adde(v,u);
	}
	dfs1(1,0);
	for (int i=1;i<=21;i++)
	 for (int j=1;j<=n;j++)
	   g[j][i]=g[g[j][i-1]][i-1];  
	for (int c=1;c<=n;c++) {
		if (v[c].size()==0) {
			write(n*(n-1)/2); putchar_('\n');
			continue;
		}
		if (v[c].size()==1) {
			int u=v[c][0],tt=0,ret=n*(n-1)/2;
			for (int i=head[u];i;i=a[i].pre) {
				int v=a[i].to; if (v==g[u][0]) continue;
				ret-=size[v]*(size[v]-1)/2;
				tt+=size[v];
			}
			ret-=(n-tt-1)*(n-tt-2)/2;
			write(ret); putchar_('\n');
			continue;
		}
		if (!work(c)) write(0),putchar_('\n');
	}     
	flush();  
	return 0;
} 
```


---


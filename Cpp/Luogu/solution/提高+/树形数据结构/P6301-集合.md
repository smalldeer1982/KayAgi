# 集合

## 题目描述

你需要**在线**维护一个自然数的排序集 $S$ 并支持以下操作：

1. 给一个数 $x$，若 $x$ 不在集合 $S$ 中则将 $x$ 添加到集合 $S$ 中；
2. 给一个数 $x$，若 $x$ 已在集合 $S$ 中则将 $x$ 从集合 $S$ 中删除。

为了证明你维护了 $S$，你需要在操作过程中回答以下询问：

3. 求集合 $S$ 中最小元素的值，若 $S=\varnothing$ 则返回 `-1`；
4. 求集合 $S$ 中最大元素的值，若 $S=\varnothing$ 则返回 `-1`；
5. 求集合 $S$ 中元素的数量；
6. 给一个数 $x$，判断 $x$ 是否在集合内，若在则返回 `1` ，若不在则返回 `0` ；
7. 给一个数 $x$，求集合 $T=S\cap[0^-,x)$ 中最大元素的值，若 $T=\varnothing$ 则返回 `-1`；
8. 给一个数 $x$，求集合 $T=S\cap[x,n)$ 中最小元素的值，若 $T=\varnothing$ 则返回 `-1`。

为了证明你**在线地**维护了 $S$，对于所有在第一次询问后的操作 $1,2$ 与询问 $6,7,8$，实际操作和询问的参数 $x$ 为输入中给出的操作和询问的参数 $x'$ 与上一次询问的返回结果 $\text{last}$ 之和。即 $x=x'+\text{last}$。

保证 $0\le x<n$ 。

初始时 $S=\varnothing$。

## 说明/提示

### 样例解释

实际上执行的操作与回答的询问如下：

```plain
1 0
1 1
1 3
1 3
3		->  0
7 0		-> -1
7 1		->  0
8 3		->  3
4		->  3
2 3
4		->  1
6 3		->  0
5		->  2
```

因此输出为 $0+(-1)+0+3+3+1+0+2=8$。

### 数据范围

| 测试点编号 |    $n=$     |    $m=$   | 分值  |
|:--------------:|:------------:|:-----------:|:-------:|
|      $1$       | $2^{20}$ | $2^{14}$ |  $5$  |
|      $2$       | $2^{25}$ | $2^{17}$ |  $5$  |
|      $3$       | $2^{30}$ | $2^{20}$ | $10$ |
|      $4$       | $2^{30}$ | $2^{22}$ | $15$ |
|      $5$       | $2^{30}$ | $2^{22}$ | $15$ |
|      $6$       | $2^{30}$ | $2^{23}$ | $25$ |
|      $7$       | $2^{30}$ | $2^{23}$ | $25$ |

对于 $100\%$ 的数据，满足 $2^{20}\le n\le2^{30},2^{14}\le m\le 2^{23},0\le x<n$。

### 提示

**本题输入量较大，建议使用较快的读入方式。**

$0^-$ 表示略小于 $0$ 的一个值，$[0^-,x)$ 可以保证第 $7$ 个操作的 $T$ 恒有意义。

## 样例 #1

### 输入

```
4 13
1 0
1 1
1 3
1 3
3
7 0
7 2
8 3
4
2 0
4
6 2
5
```

### 输出

```
8
```

# 题解

## 作者：a___ (赞：5)

这个题大体思路出题人说了，就是六十四叉权值线段树。每个节点状压一下当前节点哪些儿子存在。   

- `update` 函数就基本与正常权值线段树一样，只不过换成 `rt<<6` 。    

- 由于我没有维护每个节点的 $siz$ ，所以 `getmin` 和 `getmax` 被分成两个函数写。   

- 至于查询区间最值的，就如出题人所说，先用 `getpos` 找到这个分割点，再连续向上跳。   

注意，由于本人未知的原因，在 `unsigned long long` 下 `~0ull` 与 `(1ull<<64)-1` 相等，却与 `x=64,(1ull<<x)-1` 不等。导致多次 WA。所以我代码里所有位移操作都是用的 `__int128` 。   

以下是代码（附带简要说明）：  
```cpp
#include<cstdio>
const int N=(1<<26);//树的节点不包含最后一层哦
int n,m,siz;
unsigned long long t[N],sum;
int lowp[(1<<16)+10],uppb[(1<<16)+10];//存(1<<16)以内的最低位、最高位
int lowbit(unsigned long long x)
{
	if(x&0xffffull)return lowp[x&0xffffull];x>>=16;
	if(x&0xffffull)return lowp[x&0xffffull]+16;x>>=16;
	if(x&0xffffull)return lowp[x&0xffffull]+32;x>>=16;
	if(x&0xffffull)return lowp[x&0xffffull]+48;
	return -1;//分四段找最低位（注:0xffff=(1<<16)-1）
}
int uppbit(unsigned long long x)
{
	if(x>>48)return uppb[x>>48]+48;
	if(x>>32)return uppb[x>>32]+32;
	if(x>>16)return uppb[x>>16]+16;
	if(x)return uppb[x];
	return -1;//分四段找最高位
}
void update(int rt,int l,int r,int p)
{
	if(r-l+1<=64){t[rt]^=(((__int128)(1))<<(p-l));return;}
	int len=(r-l+1)>>6,q=(p-l)/len;
    //子节点区间长度为len，所找节点为第q个子节点，那么子节点编号为rt<<6|q，区间为[l+q*len,l+(q+1)*len-1]
	update(rt<<6|q,l+q*len,l+(q+1)*len-1,p);
	t[rt]|=(((__int128)(1))<<q);
	if(!t[rt<<6|q])t[rt]^=(((__int128)(1))<<q);
}
bool check(int rt,int l,int r,int p)
{
	if(r-l+1<=64)return (t[rt]&(((__int128)(1))<<(p-l)));
	int len=(r-l+1)>>6,q=(p-l)/len;//同上
	return check(rt<<6|q,l+q*len,l+(q+1)*len-1,p);
}
int getmin(int rt,int l,int r)
{
	if(l==r)return l;
	int len=(r-l+1)>>6,q=lowbit(t[rt]);//不断找最低位即是最小值
	return getmin(rt<<6|q,l+q*len,l+(q+1)*len-1);
}
int getmax(int rt,int l,int r)
{
	if(l==r)return l;
	int len=(r-l+1)>>6,q=uppbit(t[rt]);//不断找最高位即是最大值
	return getmax(rt<<6|q,l+q*len,l+(q+1)*len-1);
}
int stk[30][5],top;
void getpos(int rt,int l,int r,int p)
{
	if(l==r)return;
	stk[++top][0]=rt;
	int len=(r-l+1)>>6,q=(p-l)/len;
	stk[top][1]=q;stk[top][2]=l;stk[top][3]=len;//记录路径
	getpos(rt<<6|q,l+q*len,l+(q+1)*len-1,p);
}
int findmax(int x)
{
	if(!x||!siz)return -1;
	top=0;getpos(1,0,n-1,x);
	int i,q;
	for(i=top;i;i--)
	if(t[stk[i][0]]&((((__int128)(1))<<stk[i][1])-1))
	return q=uppbit(t[stk[i][0]]&((((__int128)(1))<<(stk[i][1]))-1)),
	getmax(stk[i][0]<<6|q,stk[i][2]+q*stk[i][3],stk[i][2]+(q+1)*stk[i][3]-1);
    //因为是小于x，所以要找所有比q低的位中的最高位，那么应 &((1<<q)-1)
	return -1;
}
int findmin(int x)
{
    if(!siz)return -1;
	top=0;getpos(1,0,n-1,x);
	int i,q;
	if(t[stk[top][0]]&(((__int128)(1))<<(stk[top][1])))return x;
	for(i=top;i;i--)
	if(t[stk[i][0]]&((~0ull)^((((__int128)(1))<<(stk[i][1]+1))-1)))
	return q=lowbit(t[stk[i][0]]&((~0ull)^((((__int128)(1))<<(stk[i][1]+1))-1))),
	getmin(stk[i][0]<<6|q,stk[i][2]+q*stk[i][3],stk[i][2]+(q+1)*stk[i][3]-1);
    //同理大于x则为 &((~0ull)^((1<<(q+1))-1))
	return -1;
}
int main()
{
	int i,opt,x,last=0;
	lowp[0]=uppb[0]=-1;//预处理
	for(i=1;i<(1<<16);i++)
	{
		lowp[i]=lowp[i>>1]+1;
		if(i&1)lowp[i]=0;
		uppb[i]=uppb[i>>1]+1;
	}
	scanf("%d%d",&n,&m);n=(1<<30);//必须是64的2^k倍
	while(m--)
	{
		scanf("%d",&opt);
		switch(opt)
		{
			case 1:scanf("%d",&x);x+=last;if(!check(1,0,n-1,x))++siz,update(1,0,n-1,x);break;
			case 2:scanf("%d",&x);x+=last;if(check(1,0,n-1,x))--siz,update(1,0,n-1,x);break;
			case 3:sum+=(last=siz?getmin(1,0,n-1):-1);break;
			case 4:sum+=(last=siz?getmax(1,0,n-1):-1);break;
			case 5:sum+=(last=siz);break;
			case 6:scanf("%d",&x);x+=last;sum+=(last=check(1,0,n-1,x));break;
			case 7:scanf("%d",&x);x+=last;sum+=(last=findmax(x));break;
			case 8:scanf("%d",&x);x+=last;sum+=(last=findmin(x));break;
		}
	}
	printf("%llu\n",sum);
	return 0;
}
```   

码量其实还行，就是注意复制粘贴的时候别没改完，以及 `x=64,(~0ull)^((1<<x)-1)` 的值等于 `~0ull` 的奇怪错误。

---

## 作者：Daniel13265 (赞：5)

这是「Daniel13265 的公开赛」的官方题解。

---

### 测试点 $1,2,3$

留给所有普通权值线段树以及常数正常的平衡树。

---

### 测试点 $4,5$

留给常数优秀的平衡树。

---

### 测试点 $6,7$

留给常数极其优秀的平衡树（怀疑？）与各种乱搞。

---

标程是基于权值线段树的乱搞。

首先用权值数组存储一个数是否在集合中，然后将它的每一个位置看作一个叶子结点建立一棵完全 $\omega$ 叉树，每一个非叶子结点压位存储它的哪些子结点所代表的值域区间有非零值。那么操作 $1,2$ 与询问 $3,4,5,6$ 都是很简单的了，接下来考虑询问 $7,8$。

这里只讨论询问 $7$，因为询问 $8$ 同理。首先如果 $x=0$ 则返回 `-1`；否则考虑从树的底端代表 $x$ 的结点向上查询。假设查询到了当前的非根结点，如果该结点父结点在当前结点或者左侧的儿子结点有非零值，说明找到了所需的小于 $x$ 的值，于是向下不断靠右求出具体位置；如果没有，说明该结点的父结点所代表的值域区间还没有找到，于是继续向上查找即可。到达了根结点还没有找到就说明集合中没有小于 $x$ 的数，返回 `-1` 即可。

这个数据结构的总空间复杂度为

$$\sum_{k=1}^{\log_\omega n}\mathcal O\left(\frac n{\omega^k}\right)=\mathcal O\left(\frac n\omega\right)$$


明显，单次 $1,2$ 操作与询问 $3,4,7,8$ 的时间复杂度都是 $\mathcal O\left(\log_\omega n\right)$，而询问 $5,6$ 的时间复杂度是 $\mathcal O(1)$ 的。

实际上，如果取 $\omega=2^6,n=2^{30}$，那么时间复杂度中

$$\log_\omega n=\log_{2^6}2^{30}=5$$

甚至可以看作为常数。常数最大的为询问 $7,8$，约为操作 $1,2$ 与询问 $3,4$ 的常数的 $2$ 倍。标称在测试点 $4,5$ 与测试点 $6,7$ 之间体现出来的接近一半的时间差就在于数据中询问 $7,8$ 的个数差。


当数的值域 $n$ 与操作个数 $m$ 满足 $n\le m\cdot\omega$ 时，这个数据结构可以代替 `std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int>>`（C++17 前）`std::pmr::set<unsigned int, std::less<unsigned int>, std::pmr::polymorphic_allocator<unsigned int>>`（C++17 起），因为前者的时间复杂度和空间复杂度都优秀于后者。

---


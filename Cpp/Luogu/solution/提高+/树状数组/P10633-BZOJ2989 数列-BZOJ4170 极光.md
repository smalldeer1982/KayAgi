# BZOJ2989 数列/BZOJ4170 极光

## 题目描述

给定一个长度为 $n$ 的正整数数列 $a_i$，两个位置的 $\text{graze}$ 值为两者位置差与数值差的和：$\text{graze}(x,y)=|x-y|+|a_x-a_y|$。

你必须支持两种操作（$k$ 都是正整数）：
- `Modify x k`，表示将第 $x$ 个数的值修改为 $k$；
- `Query x k`，表示询问有几个 $i$ 满足 $\text{graze}(x,i) \leq k$；

询问不仅要考虑当前数列，还要考虑任意历史版本，即统计任意位置上出现过的任意数值与当前的 $a_x$ 的 $\text{graze}$ 值 $\leq k$ 的对数。（某位置多次修改为同样的数值，按多次统计。）

## 说明/提示

对于所有数据，保证 $1\leq n\leq 6\times 10^4$，$1\leq$ 修改操作数 $\leq 5\times 10^4$，$1\leq$ 询问次数 $\leq 6\times 10^4$，$1\leq a_i$ 的所有历史版本的最大值 $\leq 10^5$。

## 样例 #1

### 输入

```
3 5
2 4 3
Query 2 2
Modify 1 3
Query 2 2
Modify 1 2
Query 1 1```

### 输出

```
2
3
3```

# 题解

## 作者：ran_qwq (赞：12)

这道题实际上就是维护一个平面直角坐标系，每次加一个点，求与一个点曼哈顿距离 $\le k$ 的点数。

trick：$(x,y)$ 转化为 $(x+y,-x+y)$，转化为一个点为中心，边长为 $2k$ 的正方形包含的点数。

二维线段树即可，即外层区间线段树，内层动态开点权值线段树。

```cpp
int n,m,a[N],rt[V<<2];
#define mid (l+r>>1)
struct SGT1 {
	int num,ls[V<<7],rs[V<<7],val[V<<7],cnt;
	void upd(int &id,int l,int r,int x) {if(!id) id=++num; val[id]++; if(l==r) return; x<=mid?upd(ls[id],l,mid,x):upd(rs[id],mid+1,r,x);}
	int qry(int id,int l,int r,int L,int R) {return !id?0:L<=l&&r<=R?val[id]:(L<=mid?qry(ls[id],l,mid,L,R):0)+(R>mid?qry(rs[id],mid+1,r,L,R):0);}
}S;
struct SGT2 {
	#define ls (id<<1)
	#define rs (id<<1|1)
	void upd(int id,int l,int r,int x,int y) {S.upd(rt[id],-V,V,y); if(l==r) return; x<=mid?upd(ls,l,mid,x,y):upd(rs,mid+1,r,x,y);}
	int qry(int id,int l,int r,int L,int R,int _L,int _R) {return L<=l&&r<=R?S.qry(rt[id],-V,V,_L,_R):(L<=mid?qry(ls,l,mid,L,R,_L,_R):0)+(R>mid?qry(rs,mid+1,r,L,R,_L,_R):0);}
}T;
void QwQ() {
	n=rd(),m=rd(); for(int i=1;i<=n;i++) a[i]=rd(),T.upd(1,1,V,a[i]+i,a[i]-i);
	for(int x,y;m--;) {
		string s; cin>>s,x=rd(),y=rd();
		if(s=="Modify") a[x]=y,T.upd(1,1,V,y+x,y-x);
		else wr(T.qry(1,1,V,a[x]+x-y,a[x]+x+y,a[x]-x-y,a[x]-x+y),"\n"); 
	}
}
```

---

## 作者：Charlie_ljk (赞：3)

# 前置知识

- 对于 $a(x_1,y_1),b(x_2,y_2)$，$a,b$ 两点的哈夫曼距离为 $|x_1-x_2|+|y_1-y_2|$。
- 对于 $a(x_1,y_1),b(x_2,y_2)$，$a,b$ 两点的切比雪夫距离为 $\max(|x_1-x_2|,|y_1-y_2|)$。

对于此题求的就是哈夫曼距离，如果可以将其转化为切比雪夫距离，问题就好解决的多，实际上这两者的确可以相互转换。

$$\begin{aligned}
|x_1-x_2|+|y_1-y_2|
&=\max(x_1-x_2+y_1-y_2,x_1-x_2-y_1+y_2,-x_1+x_2+y_1-y_2,-x_1+x_2-y_1+y_2)\\
&=\max(|(x_1+y_1)-(x_2+y_2)|,|(x_1-y_1)-(x_2-y_2)|)
\end{aligned}
$$

于是 $(x_1,y_1),(x_2,y_2)$ 两点的哈夫曼距离，转化为了 $(x_1+y_1,x_1-y_1),(x_2+y_2,x_2-y_2)$ 两点的切比雪夫距离。

- 更详细直观的证明详见 [oi-wiki](https://oi-wiki.org/geometry/distance/#%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB%E4%B8%8E%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96)。

# 解决问题

把每个 $(x,y)$ 都替换为 $(x+y,x-y)$，那么对于每次询问，即询问以 $(x+y,x-y)$ 为中心的，$(x+y-k,x-y-k)$ 为左上角，$(x+y+k,x-y+k)$ 为右下角的矩形中的点的个数。

于是转化为一个三维偏序问题，加上时间戳就是第三维，可以用 cdq 分治解决。

**注意：题目要求不删除历史版本贡献。**

- 温馨提示，cdq 过程中排序使用归并排序可以大幅度减小常数，目前是最优解。

```cpp
#include<bits/stdc++.h>
#define ll long long 
#define endl '\n'
#define sort stable_sort
using namespace std;
const int N=6e4+10,M=3e5+10;
template<typename Tp> inline void read(Tp&x)
{
	x=0;register bool z=true;
	register char c=getchar();
	for(;c<'0'||c>'9';c=getchar()) if(c=='-') z=0;
	for(;'0'<=c&&c<='9';c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	x=(z?x:~x+1);
}
template<typename T,typename ...Tp> inline void read(T &x,Tp &...y){read(x);read(y...);}
template<typename Tp> inline void wt(Tp x)
{if(x>9)wt(x/10);putchar((x%10)+'0');}
template<typename Tp> inline void write(Tp x)
{if(x<0)putchar('-'),x=~x+1;wt(x);}
template<typename T,typename ...Tp> inline void write(T x,Tp ...y){write(x);putchar(' ');write(y...);}
int n,m,cnt,maxx,a[N],ans[N],b[M],c[M];
vector<int>pos;
struct aa {int id,x,y,val;}e[M],tmp[M];
int lowbit(int x) {return x&-x;}
void add(int x,int d) {for(;x<=maxx;x+=lowbit(x)) c[x]+=d;}
int ask(int x)
{
	int ans=0;
	for(;x;x-=lowbit(x)) ans+=c[x];
	return ans;
}
void cdq(int l,int r)
{
	if(l==r) return ;
	int mid=(l+r)>>1,x=l,y=mid+1,tot=l;
	cdq(l,mid),cdq(mid+1,r);
	for(;y<=r;y++)
	{
		for(;e[x].x<=e[y].x&&x<=mid;x++)
		{
			if(e[x].val==0) add(e[x].y,1);
			tmp[tot++]=e[x];
		}
		if(e[y].val!=0) ans[e[y].id]+=e[y].val*ask(e[y].y);
		tmp[tot++]=e[y];
	}
	for(int i=l;i<=x-1;i++) if(e[i].val==0) add(e[i].y,-1);
	for(;x<=mid;x++) tmp[tot++]=e[x];
	for(int i=l;i<=r;i++) e[i]=tmp[i];
}
signed main()
{
	read(n,m);
	for(int i=1;i<=n;i++)
	{
		read(a[i]);
		e[++cnt]={0,i+a[i],i-a[i],0};
	}
	string op;
	for(int i=1,x,y,k;i<=m;i++)
	{
		cin>>op; read(x,k);
		if(op=="Modify") 
		{
			a[x]=k;
			e[++cnt]={i,x+k,x-k,0}; b[cnt]=x-k;
		}
		else
		{
			y=x-a[x],x=x+a[x];
			e[++cnt]={i,x+k,y+k,1}; b[cnt]=y+k;
			e[++cnt]={i,x-k-1,y+k,-1}; b[cnt]=y+k;
			e[++cnt]={i,x+k,y-k-1,-1}; b[cnt]=y-k-1;
			e[++cnt]={i,x-k-1,y-k-1,1}; b[cnt]=y-k-1;
			pos.push_back(i);
		}
	}
	sort(b+1,b+1+cnt);
	b[0]=unique(b+1,b+1+cnt)-(b+1);
	for(int i=1;i<=cnt;i++)
	{
		e[i].y=lower_bound(b+1,b+1+b[0],e[i].y)-b;
		maxx=max(maxx,e[i].y);
	}
	cdq(1,cnt);
	for(int i:pos) write(ans[i]),puts("");
}
```

---

## 作者：cmrhhh (赞：1)

转化出：
$$
\begin{cases}
-k\leq a_x+x-(a_y+y)\le k \\
-k\leq x-a_x-(y-a_y)\le k 
\end{cases}
$$

记 ：
$$
u=a_x+x, u'=a_y+y \\
 v=x-a_x,v'=y-a_y
$$
转化为：
$$
\begin{cases}
-k\leq u-u'\le k \\
-k\leq v-v'\le k 
\end{cases}
$$
其中我们对 $u,v$ 统计答案，$u$ 可作为第一层坐标，$v$ 作为第二层，范围为：
$$
\begin{cases}
u-k\leq u'\le u+k \\
v-k\leq v'\le v+k 
\end{cases}
$$
区间查询即可。我这里有**外层**普通线段树/动态开点值域线段树，**内层**动态开点值域线段树两个版本。任君挑选。

#### 外层普通线段树

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
const int N=6e5+10,m=2e5;
int n,q;
struct Node{
	int sm=0/*该区间有多少点,仅在内层有用*/,ls=0,rs=0;
}tr[m<<2],tr1[(int)1.6e7];
int cnt=0,cnt1=0,id[(int)1.6e7];
void add1(int &x,int l,int r,int tar1){
	if(!x) x=++cnt1;
	tr1[x].sm++;
	if(l==r) return ;
	int mid=l+(r-l)/2;
	if(tar1<=mid) add1(tr1[x].ls,l,mid,tar1);
	else add1(tr1[x].rs,mid+1,r,tar1);
}
void add(int x,int l,int r,int tar1,int tar2){
	add1(id[x],-m,m,tar2);
	if(l==r)return ;
	int mid=l+(r-l)/2;
	if(tar1<=mid) add(x<<1,l,mid,tar1,tar2);
	else add(x<<1|1,mid+1,r,tar1,tar2);
}
int query1(int x,int l,int r,int ql,int qr){
	if(!x||qr<l||ql>r)return 0;
	if(ql<=l&&r<=qr)return tr1[x].sm;
	int mid=l+(r-l)/2;
	return query1(tr1[x].ls,l,mid,ql,qr)+
		   query1(tr1[x].rs,mid+1,r,ql,qr);
}
int query(int x,int l,int r,int ql,int qr,int ql_,int qr_){
	if(qr<l||ql>r)return 0;
	if(ql<=l&&r<=qr)return query1(id[x],-m,m,ql_,qr_);
	int mid=l+(r-l)/2;
	return query(x<<1,l,mid,ql,qr,ql_,qr_)+
		   query(x<<1|1,mid+1,r,ql,qr,ql_,qr_);
}
int a[N];
signed main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;++i){
		cin>>a[i];
		int u= a[i]+i,v=i-a[i];
		add(1,1,m,u,v);
	}
	while(q--){
		string s;
		int x,k;
		cin>>s>>x>>k;
		if(s=="Modify"){
			a[x]=k;
			add(1,1,m,a[x]+x,x-a[x]);
		}else {
			int u= a[x]+x,v=x-a[x];
			int ans=query(1,1,m,max(1ll,u-k),min(m,u+k),max(-m,v-k),min(m,v+k));
			cout<<ans<<"\n";
		}
	}
	return 0;
}
/*
外层维护u 内层维护v
*/
```



#### 外层动态开点

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int m=2e5,N=1.2e5+10;
int n,q;
struct Node{
	int sm=0,ls=0,rs=0;
}tr[(int)1.6e7],tr1[(int)1.6e7];
int cnt=0,cnt1=0,rt=0,id[(int)1.6e7+10];
void add1(int &x,int l,int r,int tar1){
	if(!x) x=++cnt1;
	tr1[x].sm++;
	if(l==r) return ;
	int mid=l+(r-l)/2;
	if(tar1<=mid) add1(tr1[x].ls,l,mid,tar1);
	else add1(tr1[x].rs,mid+1,r,tar1);
}
void add(int &x,int l,int r,int tar1,int tar2){
	if(!x) x=++cnt;
	add1(id[x],-m,m,tar2);
	if(l==r)return ;
	int mid=l+(r-l)/2;
	if(tar1<=mid) add(tr[x].ls,l,mid,tar1,tar2);
	else add(tr[x].rs,mid+1,r,tar1,tar2);
}
int query1(int x,int l,int r,int ql,int qr){
	if(!x||qr<l||ql>r)return 0;
	if(ql<=l&&r<=qr)return tr1[x].sm;
	int mid=l+(r-l)/2;
	return query1(tr1[x].ls,l,mid,ql,qr)+
		   query1(tr1[x].rs,mid+1,r,ql,qr);
}
int query(int x,int l,int r,int ql,int qr,int ql_,int qr_){
	if(!x||qr<l||ql>r)return 0;
	if(ql<=l&&r<=qr)return query1(id[x],-m,m,ql_,qr_);
	int mid=l+(r-l)/2;
	return query(tr[x].ls,l,mid,ql,qr,ql_,qr_)+
		   query(tr[x].rs,mid+1,r,ql,qr,ql_,qr_);
}
int a[N];
signed main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>q;
	int rt=0;
	for(int i=1;i<=n;++i){
		cin>>a[i];
		int u= a[i]+i,v=i-a[i];
		add(rt,1,m,u,v);
	}
	while(q--){
		string s;
		int x,k;
		cin>>s>>x>>k;
		if(s=="Modify"){
			a[x]=k;
			add(rt,1,m,a[x]+x,x-a[x]);
		}else {
			int u= a[x]+x ,v=x-a[x];
			int ans=query(1,1,m,max(1ll,u-k),min(m,u+k),max(-m,v-k),min(m,v+k));
			cout<<ans<<"\n";
		}
	}

	return 0;
}
```

## 注意

需要注意的是，我们进行 `add1` 的时候：

```cpp
void add1(int &x,int l,int r,int tar1){
	if(!x) x=++cnt1;
	tr1[x].sm++;
	if(l==r) return ;
	int mid=l+(r-l)/2;
	if(tar1<=mid) add1(tr1[x].ls,l,mid,tar1);
	else add1(tr1[x].rs,mid+1,r,tar1);
}
```

（可能）千万不要这样：

```cpp
void add1(int &x,int l,int r,int tar1){
	if(!x) x=++cnt1;
	if(l==r) {
        tr1[x].sm++;
        return ;
    }
	int mid=l+(r-l)/2;
	if(tar1<=mid) add1(tr1[x].ls,l,mid,tar1);
	else add1(tr1[x].rs,mid+1,r,tar1);
	if(!tr1[x].ls)tr1[x].ls=++cnt1;
    if(!tr1[x].rs)tr1[x].rs=++cnt1;
    tr1[x].sm=tr1[tr1[x].ls].sm+tr1[tr1[x].rs].sm;
}
```



可能会 `TLE`。

还有就是注意询问的值域，$u$ 的范围不会涉及负数。询问超过值域没有意义。

当然我解释一下代码？

就是外层维护某一段范围的 $u$，进行单点插入，找到特定的 $u$ 后内层单点插入 $v$。

查询为区间查询，外层查找某段区间特定的 $u$，对各个 $u$ 对应的内层内特定区间的 $v$ 进行区间数点。

煎蛋。

---

## 作者：hzoi_Shadow (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10633)

# 前置知识

[CDQ 分治](https://oi-wiki.org/misc/cdq-divide/) | [权值树状数组及应用](https://oi-wiki.org/ds/fenwick/#%E6%9D%83%E5%80%BC%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%8F%8A%E5%BA%94%E7%94%A8) | [曼哈顿距离与切比雪夫距离的相互转化](https://oi-wiki.org/geometry/distance/#%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB%E4%B8%8E%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96)

# 解法

增加一维为时间戳，那么操作 $1$ 等价于单点加。

曼哈顿距离直接跑 CDQ 分治，貌似不太可做，考虑转化为切比雪夫距离。
  - 原曼哈顿坐标系中的点 $(x_{1},y_{1}),(x_{2},y_{2})$ 间的距离等价于切比雪夫坐标系中的 $(x_{1}+y_{1},x_{1}-y_{1}),(x_{2}+y_{2},x_{2}-y_{2})$。
  - 即 $|x_{1}-x_{2}|+|y_{1}-y_{2}|=\max(|x_{1}+y_{1}-x_{2}-y_{2}|,|x_{1}-y_{1}-x_{2}+y_{2}|)$，将左边的绝对值展开并进行归纳即可证明。

题意转化为求以 $(x,a_{x})$ 为中心的以 $2k$ 为边长的正方形内点的个数，同 [luogu P4390 [BalkanOI2007] Mokia 摩基亚](https://www.luogu.com.cn/problem/P4390) 二维数点维护即可。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
struct node
{
	int t,x,y,pd,val,id;
	bool operator < (const node &another) const
	{
		return (x==another.x)?((y==another.y)?(pd>another.pd):(y<another.y)):(x<another.x);
	}
}a[500010],tmp[500010];
int ans[500010],y[500010],b[500010],cnt=0,q_cnt=0;
void add(int t,int x,int y,int pd,int val,int id)
{
	cnt++;
	a[cnt].t=t;
	a[cnt].x=x;
	a[cnt].y=y;
	a[cnt].pd=pd;
	a[cnt].val=val;
	a[cnt].id=id;
}
struct BIT
{
	int c[500010];
	int lowbit(int x)
	{
		return (x&(-x));
	}
	void add(int n,int x,int val)
	{
		for(int i=x;i<=n;i+=lowbit(i))
		{
			c[i]+=val;
		}
	}
	int getsum(int x)
	{
		int ans=0;
		for(int i=x;i>=1;i-=lowbit(i))
		{
			ans+=c[i];
		}
		return ans;
	}
}T;
void cdq(int l,int r,int k)
{
	if(l==r)
	{
		return;
	}
	int mid=(l+r)/2,x,y;
	cdq(l,mid,k);
	cdq(mid+1,r,k);
	sort(a+l,a+mid+1);
	sort(a+mid+1,a+r+1);
	for(x=l,y=mid+1;y<=r;y++)
	{
		for(;a[x].x<=a[y].x&&x<=mid;x++)
		{
			T.add(k,a[x].y,a[x].pd);
		}
		ans[a[y].id]+=a[y].val*T.getsum(a[y].y);
	}
	x--;
	for(int i=l;i<=x;i++)
	{
		T.add(k,a[i].y,-a[i].pd);
	}
}
int main()
{
	int n,m,x,k,i;
	string pd;
	cin>>n>>m;
	for(i=1;i<=n;i++)
	{
		cin>>y[i];
		add(0,i+y[i],i-y[i],1,0,0);
		b[0]++;
		b[b[0]]=i-y[i];
	}
	for(i=1;i<=m;i++)
	{
		cin>>pd;
		if(pd=="Modify")
		{
			cin>>x;
			cin>>y[x];
			add(i,x+y[x],x-y[x],1,0,0);
			b[0]++;
			b[b[0]]=x-y[x];
		}
		else
		{
			cin>>x>>k;
			q_cnt++;
			add(i,x+y[x]+k,x-y[x]+k,0,1,q_cnt);
			b[0]++;
			b[b[0]]=x-y[x]+k;
			add(i,x+y[x]-k-1,x-y[x]+k,0,-1,q_cnt);
			b[0]++;
			b[b[0]]=x-y[x]+k;
			add(i,x+y[x]+k,x-y[x]-k-1,0,-1,q_cnt);
			b[0]++;
			b[b[0]]=x-y[x]-k-1;
			add(i,x+y[x]-k-1,x-y[x]-k-1,0,1,q_cnt);
			b[0]++;
			b[b[0]]=x-y[x]-k-1;
		}
	}
	sort(b+1,b+1+b[0]);
	b[0]=unique(b+1,b+1+b[0])-(b+1);
	for(i=1;i<=cnt;i++)
	{	
		a[i].y=lower_bound(b+1,b+1+b[0],a[i].y)-b;
	}
	cdq(1,cnt,b[0]);
	for(i=1;i<=q_cnt;i++)
	{
		cout<<ans[i]<<endl;
	}
	return 0;
}
```

---

## 作者：Bobi2014 (赞：0)

这是一道~~可癌~~的三维偏序题。

### 前置知识

- [曼哈顿距离与切比雪夫距离的相互转化](https://oi-wiki.org/geometry/distance/#%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB%E4%B8%8E%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96)
- [【模板】三维偏序（陌上花开）](https://www.luogu.com.cn/problem/P3810)
- [[BalkanOI 2007] Mokia 摩基亚](https://www.luogu.com.cn/problem/P4390)

### 思路

把曼哈顿距离转换为切比雪夫距离，就是把 $(x_{1},y_{1}),(x_{2},y_{2})$ 的曼哈顿距离转化为 $(x_{1} + y_{1},x_{1} - y_{1}),(x_{2} + y_{2},x_{2} - y_{2})$ 的切比雪夫距离，那么每次询问就是求左上角为 $(x + y - k,x - y - k)$，右下角为 $(x + y + k,x - y + k)$ 的长方形内的点数。

这样问题就变为了时间轴、$x$ 轴、$y$ 轴组成的三维偏序问题了。

### Code


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 3e5 + 5,M = 3e5 + 5,MAXN = 3e5 + 5;
struct node{
    int ti,x,y,w;
} e[N],t[N];
int n,Q,a[M],cnt,ti,ans[N],tmp[N],m;
string opt;
vector<int> pos;
namespace Bit{
    int cnt[MAXN];
    void add(int x,int v){
        for(;x <= m;x += x & -x){
            cnt[x] += v;
        }
    }
    int query(int x){
        int res = 0;
        for(;x > 0;x -= x & -x){
            res += cnt[x];
        }
        return res;
    }
}
void cdq(int l,int r){
    if(l == r){
        return;
    }
    int mid = (l + r) >> 1;
    cdq(l,mid);
    cdq(mid + 1,r);
    int p = l,q = mid + 1,cnt = 0;
    while(p <= mid and q <= r){
        if(e[p].x <= e[q].x){
            if(e[p].w == 0){
                Bit::add(e[p].y,1);
            }
            t[++cnt] = e[p ++];
        }else{
            if(e[q].w != 0){
                ans[e[q].ti] += Bit::query(e[q].y) * e[q].w;
            }
            t[++cnt] = e[q ++];
        }
    }
    while(p <= mid){
        if(e[p].w == 0){
            Bit::add(e[p].y,1);
        }
        t[++cnt] = e[p ++];
    }
    while(q <= r){
        if(e[q].w != 0){
            ans[e[q].ti] += Bit::query(e[q].y) * e[q].w;
        }
        t[++cnt] = e[q ++];
    }
    for(int i = l;i <= mid;i ++){
        if(e[i].w == 0){
            Bit::add(e[i].y,-1);
        }
    }
    for(int i = l;i <= r;i ++){
        e[i] = t[i - l + 1];
    }
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    cin >> n >> Q;
    for(int i = 1;i <= n;i ++){
        cin >> a[i];
        e[++cnt] = {0,i + a[i],i - a[i],0};
    }
    while(Q --){
        cin >> opt;
        if(opt == "Modify"){
            int x,y;
            cin >> x >> y;
            e[++cnt] = {++ti,x + y,x - y,0};
            tmp[cnt] = x - y;
            a[x] = y;
        }else{
            int x,y,k;
            cin >> x >> k;
            y = x - a[x];
            x = a[x] + x;
            e[++cnt] = {++ti,x + k,y + k,1};
            tmp[cnt] = y + k;
            e[++cnt] = {ti,x + k,y - k - 1,-1};
            tmp[cnt] = y - k - 1;
            e[++cnt] = {ti,x - k - 1,y + k,-1};
            tmp[cnt] = y + k;
            e[++cnt] = {ti,x - k - 1,y - k - 1,1};
            tmp[cnt] = y - k - 1;
            pos.push_back(ti);
        }
    }
    sort(tmp + 1,tmp + cnt + 1);
    m = unique(tmp + 1,tmp + cnt + 1) - tmp - 1;
    for(int i = 1;i <= cnt;i ++){
        e[i].y = lower_bound(tmp + 1,tmp + m + 1,e[i].y) - tmp;
    }
    cdq(1,cnt);
    for(int i : pos){
        cout << ans[i] << '\n';
    }
    return 0;
}
```

---

## 作者：执着之幻 (赞：0)

## 题意：

在一个平面直角坐标系中给出一些操作：

1. 在平面直角坐标系中加入一个点；
2. 在加入的点中选出一个点，查询这个点与其他点的距离小于 $k$ 的点有多少个。


## 思路：

涉及算法：cdq 分治，计算几何。

首先这道题需要在平面直角坐标系中进行维护与查询点的个数，不难想到可以用 cdq 分治来做，且这道题也没有要求强制在线，可用这个算法来完成这道题目。

现在我们需要思考如何查询这个点与其他点的距离小于 $k$ 的点有多少个，这里需要用到曼哈顿距离与切比雪夫距离的相互转化，即把原来的坐标系旋转 $45$ 度，就可以把原来是斜的矩阵变成一个与坐标轴平行的矩阵，而这个转化只需把原来的点坐标 $(x,y)$，改成 $(x+y,x-y)$ 即可，然后求出这个矩阵中覆盖了多少个点即为答案。

注意事项：

1. 数组要开够；
2. 要把进行树状数组的那个关键字进行离散化，否则可能会出现负数，树状数组就炸了；
3. 可在 cdq 分治中用归并排序来优化时间复杂度；

时间复杂度：

不使用归并：$O(n\log^2n)$；

使用归并：$O(n\log n)$


## AC 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t,p,b[310000],tr[310000],d[310000],e[310000],g[310000],kk;
char ch[100];
struct ll
{
	int x,y,z,w,ans;
}a[310000],c[310000];
void add(int x,int y,int op)
{
	b[++p]=a[++t].x=x;
	a[t].y=y;
	a[t].z=t;
	a[t].w=op;
}
void add(int x,int k)
{
	while(x<=p)
	{
		tr[x]+=k;
		x+=x&(-x);
	}
}
int qy(int x)
{
	int s=0;
	while(x)
	{
		s+=tr[x];
		x-=x&(-x);
	}
	return s;
}
void cdq(int l,int r)//CDQ分治 
{
	if(l==r)return;
	int mid=(l+r)>>1;
	cdq(l,mid);
	cdq(mid+1,r);
	int i=l,j=mid+1,cnt=0,tt=0;
	for(;j<=r;j++)
	{
		while(i<=mid&&a[i].y<=a[j].y)
		{
			if(a[i].w==0)add(a[i].x,1),d[++cnt]=a[i].x;
			c[++tt]=a[i++];
		}
		if(a[j].w!=0)a[j].ans+=qy(a[j].x);
		c[++tt]=a[j];
	}
	for(int i=1;i<=cnt;i++)add(d[i],-1);
	while(i<=mid)c[++tt]=a[i++];
	tt=0;//这里采用了归并排序 
	for(int i=l;i<=r;i++)a[i]=c[++tt];
}
bool cmp(ll a,ll b)
{
	return a.z<b.z;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&e[i]);
		add(i-e[i],i+e[i],0);
	}
	int cnt=0;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%s",ch+1);
		scanf("%d%d",&x,&y);
		if(ch[1]=='Q')
		{
			add(x-e[x]+y,e[x]+x+y,1);
			g[++cnt]=t;
			add(x-e[x]-y-1,e[x]+x-y-1,1);
			add(x-e[x]+y,e[x]+x-y-1,-1);
			add(x-e[x]-y-1,e[x]+x+y,-1);
		}//容斥原理计算矩阵覆盖的点 
		else
		{
			e[x]=y;
			add(x-e[x],e[x]+x,0);
		}
	}
	sort(b+1,b+1+p);
	kk=unique(b+1,b+1+p)-b-1;
	for(int i=1;i<=t;i++)a[i].x=lower_bound(b+1,b+1+kk,a[i].x)-b;
	cdq(1,t);
	sort(a+1,a+1+t,cmp);//还原一开始的顺序，输出答案 
	for(int i=1;i<=cnt;i++)printf("%d\n",a[g[i]].ans+a[g[i]+1].ans-a[g[i]+2].ans-a[g[i]+3].ans);
	return 0;
}
```

---


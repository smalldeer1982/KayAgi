# [迷宫寻路 Round 3] 迷宫寻路大赛

## 题目描述

给定参数 $c,d$ 和一个长度为 $n$ 的序列 $\{a\}$。有 $q$ 个区间，对于每个区间 $[l,r]$，求出 $\sum\limits_{x=l}^{r} \sum\limits_{y=x}^r [c\le (\sum\limits_{i=x}^{y} \sum\limits_{j=i+1}^{y} [a_i>a_j])\le d]$。

注意区别以上两种中括号：

1. $[l,r]$ 代表一个区间。
2. $[p]$ 为艾弗森括号，其中 $p$ 是一个仅有真假两种取值的表达式。若 $p$ 为真，则 $[p]=1$，否则 $[p]=0$。

通俗的讲，对于每个区间 $[l,r]$，求出区间内有多少非空子区间的逆序对个数在 $c$ 到 $d$ 之间（含 $c$ 和 $d$）。

## 说明/提示

**本题采用捆绑测试。**

对于所有数据，$1\le n,q,a_i\le 5\times 10^5$，$1\le c,d\le 10^{12}$，对于每个 $1\le i\le q$，满足 $1\le l_i\le r_i\le n$。

| 子任务编号 | $n\leq$ | $q\leq$ | 分数 |
| :----------: | :----------: | :----------: | :----------: |
| $0$ | $10$ | $10$ | $5$ |
| $1$ | $100$ | $100$ | $10$ |
| $2$ | $1000$ | $1000$ | $10$ |
| $3$ | $5000$ | $5000$ | $15$ |
| $4$ | $50000$ | $50000$ | $25$ |
| $5$ | $5\times 10^5$ | $5\times 10^5$ | $35$ |


## 样例 #1

### 输入

```
5 1 2
1 4 2 3 5
3
1 5
1 3
2 4
```

### 输出

```
6
2
2
```

## 样例 #2

### 输入

```
10 2 4
1 9 2 5 7 3 6 10 4 8
10
1 3
2 4
3 5
4 9
1 10
2 9
5 7
6 9
2 6
7 7
```

### 输出

```
0
1
0
7
17
12
1
2
4
0
```

## 样例 #3

### 输入

```
25 3 39
20 19 18 17 16 15 18 14 13 12 11 19 17 10 9 8 7 9 6 8 5 4 6 7 3
20
17 18
1 10
20 25
4 9
13 15
6 21
3 7
12 17
18 21
3 12
5 17
3 4
8 18
17 22
19 21
2 23
14 22
13 20
18 25
11 20
```

### 输出

```
0
33
6
8
1
76
5
10
1
33
55
0
40
7
0
123
24
18
15
32
```

## 样例 #4

### 输入

```
25 40 1000
20 19 18 17 16 15 18 14 13 12 11 19 17 10 9 8 7 9 6 8 5 4 6 7 3
20
17 18
1 10
20 25
4 9
13 15
6 21
3 7
12 17
18 21
3 12
5 17
3 4
8 18
17 22
19 21
2 23
14 22
13 20
18 25
11 20
```

### 输出

```
0
1
0
0
0
21
0
0
0
0
6
0
1
0
0
77
0
0
0
0
```

## 样例 #5

### 输入

```
5 1 1
1 2 3 4 5
3
1 3
2 4
3 5```

### 输出

```
0
0
0
```

# 题解

## 作者：LostKeyToReach (赞：5)

本题解提供离线+树状数组+双指针做法，代码请根据思路自行实现。

**请务必读完解题思路。**

### 题目回顾

给定 $n, c, d$ 和 $\{a\}$，你有 $q$ 次询问，每次给出 $l, r$，求：

$$
\sum_{l \le x \le y \le r}[c \le \text{inv}(x, y) \le d].
$$

### 解题思路

考虑转换原式。

$$
\sum_{l \le x \le y \le r}[c \le \text{inv}(x, y) \le d] = \sum_{l \le x \le y \le r} [\text{inv}(x, y) \le d] - \sum_{l \le x \le y \le r} [\text{inv}(x, y) \le c - 1].
$$

接下来求解 $\displaystyle \sum_{l \le x \le y \le r} [\text{inv}(x, y) \le d]$。

定义 $L_{d}(r) = \min \{l \mid \text{inv}(l, r) \le d\}$，$\text{cnt}_{d}(r) = r - L_{d}(r) + 1$，$\text{ps}_{d}(r)$ 为 $\text{cnt}_{d}(r)$ 的前缀和。

- $L_{d}(r)$：表示以 $r$ 为右端点时最小的 $l$ 使得 $[l, r]$ 区间的逆序对数量 $\le d$，这可以使用「双指针 + 树状数组」的方法来实现，具体思路如下：
  > - 维护一个窗口 $[l, r]$ 及当前窗口的逆序对数量 $\text{CurrInv}$，再开一个树状数组用于维护逆序对数量。
  > - 枚举 $r$，每次加入 $a_r$ 时将 $\text{CurrInv}$ 加上「当前窗口里大于 $a_r$ 的数的个数」。
  > - 如果 $\text{CurrInv} > d$，就移动 $l$ 向左收缩，同时将 $\text{CurrInv}$ 减去「当前窗口里小于 $a_l$ 的数的个数」直到 $\text{CurrInv} \le d$。
  > - 操作结束后，$l$ 便为 $L_{d}(r)$。

- $\text{cnt}_d(r)$：表示使得 $\text{inv}(l, r) \le d$ 的 $l$ 的数量，将 $L_d(r)$ 求解完毕后计算 $r - L_d(r) + 1$ 即可。

- $\text{ps}_d(r)$：为 $\text{cnt}_d(r)$ 的前缀和，表示右端点为 $1 \sim r$ 时，有多少个子区间满足 $\text{inv}(l, r) \le d$。

对于这部分，我们对 $d$ 和 $c - 1$ 分别进行一次这样的计算。

至此，此部分求解完毕，接下来，我们思考一个问题：**如何从上述信息，得到「区间 $[l,r]$ 内，有多少子区间的逆序对 $\le d$」？**

固定 $r$，若我们只关心「右端点 = $r$」的子区间，逆序对 $\le d$ 的那些，其左端点 $x$ 满足：

$$
x \ge L_d(r).
$$

故此时子区间数量为：

$$
r - L_d(r) + 1 = \text{cnt}_d(r).
$$

是现在我们只想要「左端点 $x \ge l$ 且右端点为 $r$」的子区间，这些子区间的数量应该是：

$$
f_d(r, l) = 
\begin{cases}
    \text{cnt}_d(r), &\quad L_d(r) \ge l,\\
    r - l + 1, &\quad L_d(r) < l. \\
  \end{cases}
$$

那么我们再对 $[l, r]$ 中的 $f_d(k, l)$ 求和，便可得区间 $[l, r]$ 内、右端点为 $r$ 的所有子区间中满足逆序对 $\le d$ 的数量。

$$
\begin{aligned}
\sum_{k = l} ^ r f_d(k, l) &= \sum_{k = l} ^ r \text{cnt}_d(k) - \sum_{k \in S}\left[\text{cnt}_d(k) - (k - l + 1)\right] \\ &=[\text{ps}_d(r) - \text{ps}_d(l - 1)] - \sum_{k \in S}[l - L_d(k)].
\end{aligned}
$$

其中 $S = \{k \in [l, r] \mid L_d(k) < l\}$。

接下来引入两个变量 $y_{l, r}$ 和 $z_{l, r}$ 用于求解 $\displaystyle\sum_{k \in S}[l - L_d(k)]$。

$$
y_{l, r} = \sum_{k \in [l, r], L_d(k) < l}1.
$$

$$
z_{l, r} = \sum_{k \in [l, r], L_d(k) < l} L_d(k).
$$

此时 $\displaystyle\sum_{k \in S}[l - L_d(k)] = l \times y_{l, r} - z_{l, r}$。

那么 $y_l$ 和 $z_l$ 该如何求解？我们发现 $L_d(k) < l$ 这个条件的存在增加了题目难度，那我们不妨开一个桶 $b$，$b_x$ 记录所有 $L_d(k) = x$ 的位置 $k$，处理询问时将 $x < l$ 的 $b_x$ 中的位置加入便可以方便地处理掉这个限制。

接下来，我们开两个树状数组 $\text{fc}$ 和 $\text{fv}$ 分别维护 $y_{l, r}$ 和 $z_{l, r}$，加入 $b_x$ 的位置时分别单点加 $1$ 和 $L_d(k)$ 即可。

同理，我们对 $d$ 和 $c - 1$ 分别做一次。

最后，设我们处理出来的答案为 $\text{ans}_d(i)$ 和 $\text{ans}_{c - 1}(i)$，直接输出 $\text{ans}_d(i) - \text{ans}_{c - 1}(i)$ 即可。

### 时间复杂度分析

- 预处理：$O(n \log n)$。
- 离线计算答案：$O((n + q) \log n)$。
- 总时间复杂度：$O((n + q) \log n)$。

可以轻松处理 $n, q \le 5 \times 10^5$ 的数据。

### 代码实现

请自行实现。

---

## 作者：Acit (赞：2)

**思路**

先将式子拆成 $\lbrack 0,c-1 \rbrack $ 和 $\lbrack 0,d \rbrack $ 两段，分别求出答案后作差。

设 $lef_i$ 为满足 $\lbrack j,i\rbrack$ 中逆序对数不超过 $d$ 的最小的 $j$ ，显然 $lef_i$ 具有单调性。于是我们可以双指针扫一遍，用树状数组或线段树维护逆序对数，求出 $lef$ 数组。

计算答案时，我们可以在 $\lbrack l,r \rbrack$ 中二分找出最后一个满足 $lef_i < l$ 的 $i$ ，$\lbrack l,i \rbrack$ 中每个右端点的贡献构成一个等差数列，可以直接求和，$\lbrack i+1,r \rbrack$ 中每个右端点的贡献均被 $\lbrack l,r \rbrack$ 覆盖，可以直接用前缀和求出。

分别对 $d$ 和 $c-1$ 计算一次即可求出答案。

**Code**

写的线段树，巨慢。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=5e5+10;
int n,c,d;
#define lson k<<1
#define rson k<<1|1
#define mid ((l+r)>>1)
#define mid1 ((l+r+1)>>1)
#define s(k) tree[k]
int tree[N<<2];
void update(int k,int l,int r,int x,int y){
	if(l>x||r<x)return ;
	if(l==r){
		s(k)+=y;return;
	}
	update(lson,l,mid,x,y);update(rson,mid+1,r,x,y);
	s(k)=s(lson)+s(rson);	
}
int query(int k,int l,int r,int x,int y){
	if(l>y||r<x)return 0;
	if(x<=l&&r<=y)return s(k);
	return query(lson,l,mid,x,y)+query(rson,mid+1,r,x,y);
}
int lef1[N],lef2[N],a[N];
int sum1[N],sum2[N];
int calc(int x,int y){
	int l=x,r=y,ans=0;
	while(l<r){
		if(lef1[mid1]<x)l=mid1;
		else r=mid1-1;
	}
	ans+=((1+r-x+1)*(r-x+1)/2);
	ans+=(sum1[y]-sum1[r]);
	l=x,r=y;
	while(l<r){
		if(lef2[mid1]<x)l=mid1;
		else r=mid1-1;
	}
	ans-=((1+r-x+1)*(r-x+1)/2);
	ans-=(sum2[y]-sum2[r]);
	return ans;
}
int q;
signed main(){
	ios::sync_with_stdio(0);
	cin>>n>>c>>d;
	c--;
	for(int i=1;i<=n;i++)cin>>a[i];
	int lef=1,tot=0;
	for(int i=1;i<=n;i++){
		tot+=query(1,1,500000,a[i]+1,500000);
		update(1,1,500000,a[i],1);
		while(tot>d){
			tot-=query(1,1,500000,1,a[lef]-1);
			update(1,1,500000,a[lef],-1);
			lef++;
		}
		lef1[i]=lef;
	}
	while(lef<=n)update(1,1,500000,a[lef],-1),lef++;
	lef=1;tot=0;
	for(int i=1;i<=n;i++){
		tot+=query(1,1,500000,a[i]+1,500000);
		update(1,1,500000,a[i],1);
		while(tot>c){
			tot-=query(1,1,500000,1,a[lef]-1);
			update(1,1,500000,a[lef],-1);
			lef++;
		}
		lef2[i]=lef;
	}
	for(int i=1;i<=n;i++)sum1[i]=sum1[i-1]+i-lef1[i]+1,sum2[i]=sum2[i-1]+i-lef2[i]+1;
	cin>>q;
	while(q--){
		int l,r;
		cin>>l>>r;
		cout<<calc(l,r)<<endl;
	}
	return 0;
}

```

---

## 作者：george0929 (赞：2)

前置知识：双指针，树状数组求逆序对，线段树，扫描线。

考虑逆序对个数在 $c$ 到 $d$ 之间的区间的分布。

考虑一个基本事实：当区间右端点 $r$ 固定时，区间逆序对个数一定随左端点的减小而减小。

将区间视为二维平面上的点，左端点和右端点分别看作横坐标和纵坐标，则满足条件的区间组成的图形为若干个宽为 $1$ 的矩形的并（如下图）。

![](https://cdn.luogu.com.cn/upload/image_hosting/o8ma66eb.png)

通过树状数组和双指针可以得出，对于每个右端点，其左端点的范围，进而知道每个矩形的信息。

树状数组和双指针的代码：

```cpp
void init(){//其中 B1 和 B2 是两颗树状数组。
	B1.clear(),B2.clear();
	int l=1,r=1;
	int cnt1=0,cnt2=0;
	for(int i=1;i<=n;i++){
		cnt1+=B1.sz-B1.sum(a[i]);
		cnt2+=B2.sz-B2.sum(a[i]);
		B1.add(a[i]);
		B2.add(a[i]);
		while(cnt1>d){
			B1.del(a[l]);
			cnt1-=B1.sum(a[l]-1);
			l++;
		}
		while(cnt2>=c){
			B2.del(a[r]);
			cnt2-=B2.sum(a[r]-1);
			r++;
		}
		L[i]=l,R[i]=r-1;
	}
}
```

对于一个询问，即询问区间右下角的矩形面积并（如下图）。

![](https://cdn.luogu.com.cn/upload/image_hosting/2bktif41.png)

考虑询问离线，按右端点排序并进行扫描线，线段树维护一个序列，每次扫过一个矩形，若矩形的横坐标在 $x$ 到 $y$ 之间，则在区间 $[x,y]$ 增加 $1$（如下图）。

![](https://cdn.luogu.com.cn/upload/image_hosting/g6yntrqe.png)

询问区间 $l,r$ 的答案就是扫描线扫到 $r$ 时，线段树维护的序列中区间 $[l,r]$ 的和（如下图）。

![](https://cdn.luogu.com.cn/upload/image_hosting/z4luj9dz.png)

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int V=5e5;
int n,c,d,a[500005];
int L[500005],R[500005];
struct bit{
	int c[500005],sz;
	void clear(){
		sz=0;
		memset(c,0,sizeof(c));
	}
	void add(int x){
		sz++;
		for(int i=x;i<=V;i+=i&-i) c[i]++;
	}
	void del(int x){
		sz--;
		for(int i=x;i<=V;i+=i&-i) c[i]--;
	}
	int sum(int x){
		int res=0;for(int i=x;i>=1;i-=i&-i) res+=c[i];
		return res;
	}
}B1,B2;
void init(){
	B1.clear(),B2.clear();
	int l=1,r=1;
	int cnt1=0,cnt2=0;
	for(int i=1;i<=n;i++){
		cnt1+=B1.sz-B1.sum(a[i]);
		cnt2+=B2.sz-B2.sum(a[i]);
		B1.add(a[i]);
		B2.add(a[i]);
		while(cnt1>d){
			B1.del(a[l]);
			cnt1-=B1.sum(a[l]-1);
			l++;
		}
		while(cnt2>=c){
			B2.del(a[r]);
			cnt2-=B2.sum(a[r]-1);
			r++;
		}
		L[i]=l,R[i]=r-1;
	}
}
vector<pair<int,int>> Qry[500005];
int ans[500005];
struct node{
	int l,r,sum,tag;
}t[2000005];
void pushup(int p){
	t[p].sum=t[p*2].sum+t[p*2+1].sum;
}
void func(int p,int v){
	t[p].tag+=v;
	t[p].sum+=v*(t[p].r-t[p].l+1);
}
void pushdown(int p){
	int tmp=t[p].tag;
	t[p].tag=0;
	func(p*2,tmp);
	func(p*2+1,tmp);
}
void build(int p,int l,int r){
	t[p].l=l,t[p].r=r;
	if(l==r) return;
	int mid=(t[p].l+t[p].r)/2;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r); 
}
void modify(int p,int l,int r){
	if(l<=t[p].l&&t[p].r<=r){
		func(p,1);
		return;
	}
	pushdown(p);
	int mid=(t[p].l+t[p].r)/2;
	if(mid>=l) modify(p*2,l,r);
	if(mid<r) modify(p*2+1,l,r);
	pushup(p);
}
int query(int p,int l,int r){
	if(l<=t[p].l&&t[p].r<=r){
		return t[p].sum;
	}
	pushdown(p);
	int mid=(t[p].l+t[p].r)/2,res=0;
	if(mid>=l) res+=query(p*2,l,r);
	if(mid<r) res+=query(p*2+1,l,r);
	return res;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>c>>d;
	for(int i=1;i<=n;i++) cin>>a[i];
	init();
	int q;cin>>q;
	for(int i=1;i<=q;i++){
		int l,r;
		cin>>l>>r;
		Qry[r].push_back({l,i});
	}
	build(1,1,n);
	for(int i=1;i<=n;i++){
		if(L[i]<=R[i]) modify(1,L[i],R[i]);
		for(auto x:Qry[i]){
			ans[x.second]=query(1,x.first,i);
		}
	}
	for(int i=1;i<=q;i++) cout<<ans[i]<<"\n";
	return 0;
}
```

---

## 作者：Ascnbeta (赞：1)

独立切题很爽，记录一下思维过程。

## 题目大意
给定 $q$ 个区间 $[l,r]$，求每个区间里满足逆序对数 $\ge c$ 且 $\le d$ 的子区间数。

## 思路分析
首先我们肯定要求逆序对，显然的是这题肯定用树状数组而非归并求逆序对数。

因为序列是静态的，所以我们考虑将询问离线，使用扫描线的方法。

考虑一个询问区间 $[l,r]$，显然它的所有子区间都可以按右端点进行归类。所以我们可以考虑当扫描线扫到右端点时，把所有以该点为右端点满足条件的区间的贡献维护在左端点上，或者说假设 $y$ 是目前扫描线的右端点，对于所有以 $y$ 为右端点的区间 $[x,y]$，如果这个区间满足条件，就在 $x$ 上增加 $1$ 的贡献。

这样回答询问时，如果我们目前扫描线的端点就是询问区间右端点 $r$，则 $[l,r]$ 的贡献和就是这次询问的答案。因为如果这个贡献出现在 $[l,r]$ 里，那么它的位置就是满足条件区间的左端点，而它的右端点因为扫描线到了 $r$，所以一定小于等于 $r$，这样这个区间就会对询问产生贡献，这样就保证了统计到的贡献不多不少。

但是我们还有一个问题，就是不能够快速地求出对于右端点为 $y$ 的区间 $[x,y]$，有哪些 $x$ 使得区间 $[x,y]$ 满足条件。

思考一下可以发现，如果右端点固定，随着左端点左移，区间逆序对数单调不减。换句话说，满足条件的区间左端点一定是一个连续的区间。这样在最后统计贡献的时候我们可以利用**线段树区间求和与查询**来进行统计。

但是光知道连续还没什么用，但是有单调性我们可以考虑二分，这样我们就需要快速求出 $[l,r]$ 逆序对数，然后你就可以开始挑战图灵奖了。

说人话就是这么做不行，那怎么办呢？

考虑整个过程，你会发现对于一个右端点的所有满足条件区间的左端点区间，伴随着右端点右移，这个满足条件的区间左右端点也是单调不降的。

所以在树状数组求逆序对的时候我们维护两个指针 $l,r$，$l$ 表示对于目前的右端点 $y$，$[l,y]$ 是长度最长的能使区间逆序对数 $\le d$ 的区间，$[r,y]$ 是长度最短的能使区间逆序对数 $\ge c$ 的区间。如何维护指针？我们可以利用单调性，指针的右移相当于撤销这个点原来对逆序对的贡献。我们求出这个贡献，看看删去之后还能否满足条件，如果可以就右移。这样我们就做完了。

## 具体实现
双指针实现起来不是那么容易，这里使用两个树状数组分别来进行维护 $l,r$，可以参照代码进行理解。
```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
inline void read(ll &x){
    x=0;int f=1;char ch=getchar();
    while (ch<'0'||ch>'9') {
        if (ch=='-') f=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9') {
        x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
    }
    x*=f;
}
inline void read(int &x){
    x=0;int f=1;char ch=getchar();
    while (ch<'0'||ch>'9') {
        if (ch=='-') f=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9') {
        x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
    }
    x*=f;
}//IO
const int maxn = 5e5+20;
int n,q;
ll c,d;
ll t1[maxn],t2[maxn];//1是用来维护r的，2是用来维护l的。
int a[maxn];
inline int lowbit(int x) {
    return x&-x;
}
inline void modifyc(int p,int x) {
    while (p <= 5e5) {
        t1[p] += x;
        p += lowbit(p);
    }
}
inline ll queryc(int p) {
    ll ret = 0;
    while (p > 0) {
        ret += t1[p];
        p -= lowbit(p);
    }
    return ret;
}
inline void modifyd(int p,int x) {
    while (p <= 5e5) {
        t2[p] += x;
        p += lowbit(p);
    }
}
inline ll queryd(int p) {
    ll ret = 0;
    while (p > 0) {
        ret += t2[p];
        p -= lowbit(p);
    }
    return ret;
}
struct zone{
    int l,r,id;
    ll ans;
    bool operator < (const zone &y) const {
        return r < y.r;
    }
}z[maxn];
bool cmp(const zone &x,const zone &y) {
    return x.id < y.id;
}
ll cntc = 0,cntd = 0;
inline bool checkc(int p) {
    ll tmp = queryc(a[p]-1);//我们求出取消当前r对逆序对的贡献会减少的逆序对数
    if (cntc - tmp >= c) {//如果发现去掉之后逆序对数仍大于等于c，那么说明目前的r不是最大的，继续右移
        modifyc(a[p],-1);//撤销a[r]对逆序对的贡献
        cntc -= tmp;
        return true;
    }
    else return false;
}
//以下是线段树区间加区间求和板子
#define ls p<<1
#define rs p<<1|1
ll sum[maxn<<2],tag[maxn<<2];
inline void pushup(int p) {
    sum[p] = sum[ls] + sum[rs];
}
inline void pushdown(int p,int l,int r) {
    int mid = (l + r) >> 1;
    sum[ls] += tag[p]*(mid-l+1);
    sum[rs] += tag[p]*(r-mid);
    tag[ls] += tag[p];
    tag[rs] += tag[p];
    tag[p] = 0;
}
inline void modify(int p,int s,int e,int v,int l,int r) {
    if (s <= l && r <= e) {
        sum[p] += 1ll*v*(r-l)+1;
        tag[p] += 1ll*v;
        return;
    }
    int mid = (l + r) >> 1;
    if (l != r && tag[p]) pushdown(p,l,r);
    if (s <= mid) modify(ls,s,e,v,l,mid);
    if (e > mid) modify(rs,s,e,v,mid+1,r);
    pushup(p); 
}
inline ll query(int p,int s,int e,int l,int r) {
    if (s <= l && r <= e) {
        return sum[p];
    }
    int mid = (l + r) >> 1;
    if (l != r && tag[p]) pushdown(p,l,r);
    ll ret = 0;
    if (s <= mid) ret += query(ls,s,e,l,mid);
    if (e > mid) ret += query(rs,s,e,mid+1,r);
    return ret;
}
int main () {
    read(n),read(c),read(d);
    for (int i = 1; i <= n; i++) read(a[i]);
    read(q);
    for (int i = 1; i <= q; i++) read(z[i].l),read(z[i].r),z[i].id=i;
    sort(z+1,z+q+1);//询问离线按右端点排序。
    int l = 1,r = 1;
    int cur = 1;
    for (int i = 1; i <= n; i++) {
        ll tmp = queryc(5e5)-queryc(a[i]);
        cntc += tmp;//计算右端点为i时新增的逆序对
        modifyc(a[i],1);//添加a[i]对逆序对的贡献
        if (cntc >= c) {//如果个数超过c，尝试是否能右移r
            while (r<=i&&checkc(r)) ++r;//能右移就右移，注意不要超过i
        }
        tmp = queryd(5e5)-queryd(a[i]);
        cntd += tmp;
        modifyd(a[i],1);//同上，只不过是为了维护逆序对数不要超过d
        if (cntd > d) {//如果个数超过d，尽力右移
            do{
                tmp = queryd(a[l]-1);
                modifyd(a[l],-1);
                cntd -= tmp;
                ++l;//撤销a[l]对逆序对贡献
            }while(l<i&&cntd>d);//使用do while是因为进入if代表当前l已经非法，必须先考虑右移，注意我们允许l越界1位（因为可能出现对于目前右端点i没有合法l,r的情况，这时让l>r就可以）
        }
        if (l<=r&&cntc>=c&&cntd<=d) modify(1,l,r,1,1,n);//只有目前区间合法才能对答案产生贡献
        while (z[cur].r <= i && cur <= q) {
            z[cur].ans = query(1,z[cur].l,z[cur].r,1,n);
            ++cur;
        }//离线回答询问
    }
    sort(z+1,z+q+1,cmp);
    for (int i = 1; i <= q; i++) {
        printf("%lld\n",z[i].ans);
    }
    return 0;
}
```

---

## 作者：dream_on_screen (赞：1)

声明：这篇题解所用的方法不是出题人所希望能通过的，具体见[这里](https://www.luogu.com.cn/discuss/1050621)。

题目主要是问在区间内有多少个连续子区间中的逆序对数量在给定范围之间

我们可以想到，如果固定下来子区间的左端点，那么逆序对数量符合要求的右端点一定是一个区间，记为 $p_i$ 到 $q_i$。

在求出来了每个左端点对应的范围之后，可以建立一个有 $n$ 个历史版本的主席树维护合法区间数量，第 $i$ 个历史版本是在第 $i+1$ 个历史版本的基础上在 $p_i$ 到 $q_i$ 的区间都 $+1$。

然后在进行查询的时候对第 $l$ 个和第 $r+1$ 个历史版本进行差分，求出来在这些历史版本中间在 $l$ 到 $r$ 的总和就是答案了。

再回到一开始的地方，怎么求出 $p_i$ 和 $q_i$ 呢？注意到对于所有 $i<j$，显然有 $p_i<p_j$ 和 $q_i<q_j$ 成立。

可以用尺取法求出来 $p_i$ 和 $q_i$。首先用树状数组维护现在考虑的区间内每一个值出现了多少次。然后在后面加入一个数的时候产生的逆序对数量等于之前已经加入的比这个数字大的数字数量。在前面删掉一个数字同理。

可以先从 $1$ 开始暴力在区间后面加入数字，求出来 $p_1$ 的值。然后每次先删除最前面的数，然后不断在后面加入新的数直到逆序对数量第一次达到 $c$。

$q$ 同理，但是可能会有更多的细节。

然后应该到这里就分析完题目了，这个做法的时间复杂度和空间复杂度应该都是 $O(n\log n)$，理论上应该可以通过，但是可能在实现的时候需要进行一些优化，不然的话就会像我一样既超时又爆空间。

所以这是通过我卡常得到的一些启示：

- 主席树占用的时间和空间都是最多的，所以在优化的时候应该主要优化主席树。

- 因为主席树的节点可能有 $3 \times 10^7$ 个，所以说需要删除所有可以不储存的内容。

- 主席树的节点如果用结构体的话可能会占用更多空间，因为对齐结构体会造成大量空间浪费，但是实际上子任务四只减少了 4MB 空间，相比于上一个优化一次性减少 10MB 相去甚远。但是如果使用结构体的话因为访问更加连续，所以可以使子任务四时间减少 $20$ 毫秒。

- 可以减少不必要的节点创建，在修改的时候不需要每次都需要下传懒标记。

- 到这里子任务五已经不超空间了，但是大概超了 400ms 时间。对了，还有一个优化被忘记了。输入输出还可以优化。关闭流同步的优化程度是不够的，需要使用 `fread` 和 `getchar` 等字节读入输出方法才勉强可以不超时。现在时间已经降低到了 1.50s 左右，因为评测机波动，时间可能会有十到二十毫秒的波动，导致可能会超时。不过应该可以凭借运气堆概率刷出来全部不超时了。

- 但是其实如果用 C++98 的话时间就会减少到 1.2s 左右，终于能通过这道题了。

最后是写了很久的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace FastIO {char buf[1 << 21], *p1 = buf, *p2 = buf;
#define getchar() (p1 == p2 && (p1 = buf, p2 = (p1 + fread(buf, 1, 1 << 21, stdin))) == p1 ? EOF : *p1++)
template <typename T> inline T read() {T x = 0, w = 0; char ch = getchar(); while (ch < '0' || ch > '9') w |= (ch == '-'), ch = getchar(); while ('0' <= ch && ch <= '9') x = x * 10 + (ch ^ '0'), ch = getchar(); return w ? -x : x; }template <typename T> inline void write(T x) { if (!x) return; write<T>(x / 10), putchar((x % 10) ^ '0'); }
template <typename T> inline void print(T x) { if (x > 0) write<T>(x); else if (x < 0) putchar('-'), write<T>(-x); else putchar('0'); }
template <typename T> inline void print(T x, char en) { print<T>(x), putchar(en); }
}; using namespace FastIO;
#undef getchar()
//需要完成的数据结构：
//树状数组
//主席树(区间加,区间查询)
int bit[1000005];
int lowbit(int x)
{
	return x&-x;
}
void change(int id,int delta)
{
	for(int i=id;i<=1e6;i+=lowbit(i))
		bit[i]+=delta;
	return ;
}
int query(int id)
{
	int sum=0;
	for(int i=id;i;i-=lowbit(i))
		sum+=bit[i];
	return sum;
}
int query(int l,int r)
{
	if(r<l)
		return 0;
	return query(r)-query(l-1);
}
int n,a[500005],q,l[500005],r[500005];
long long c,d;
int root[500005];
const int w=3.5e7;
int ls[w],rs[w],lazy[w];
long long sum[w];
int cnt;
void create(int id,int l,int r)
{
	if(ls[id]==0&&rs[id]==0&&l!=r)
	{
		ls[id]=++cnt;
		rs[id]=++cnt;
	}
	return ;
}
void copy(int u,int v)
{
    ls[v]=ls[u];
    rs[v]=rs[u];
    lazy[v]=lazy[u];
    sum[v]=sum[u];
}
void update(int id,int l,int r)
{
	create(id,l,r);
	if(lazy[id])
	{
		if(l!=r)
		{
			copy(ls[id],++cnt);
			lazy[cnt]+=lazy[id];
			ls[id]=cnt;
			copy(rs[id],++cnt);
			lazy[cnt]+=lazy[id];
			rs[id]=cnt;
		}
		sum[id]+=1ll*(r-l+1)*lazy[id];
		lazy[id]=0;
	}
	return ;
}
int change(int id,int ll,int rr,int l,int r,int delta)
{
	if(ll==l&&rr==r)
	{
	    copy(id,++cnt);
		lazy[cnt]+=delta;
		return cnt;
	}
	create(id,ll,rr);
	copy(id,++cnt);
	int q=cnt;
	sum[q]+=1ll*(r-l+1)*delta;
	int mid=ll+rr>>1;
	bool f1=(l<=mid),f2=(mid<r);
	if(f1&&f2)
	{
		ls[q]=change(ls[id],ll,(ll+rr)/2,l,mid,delta);
		rs[q]=change(rs[id],(ll+rr)/2+1,rr,mid+1,r,delta);
	}
	else if(f1&&!f2)
		ls[q]=change(ls[id],ll,(ll+rr)/2,l,r,delta);
	else if(!f1&&f2)
		rs[q]=change(rs[id],(ll+rr)/2+1,rr,l,r,delta);
	return q;
}
long long query(int id,int ll,int rr,int l,int r)
{
	update(id,ll,rr);
	if(ll==l&&rr==r)
		return sum[id];
	int mid=ll+rr>>1;
	bool f1=(l<=mid),f2=(mid<r);
	if(f1&&f2)
		return query(ls[id],ll,(ll+rr)/2,l,mid)+query(rs[id],(ll+rr)/2+1,rr,mid+1,r);
	else if(f1&&!f2)
		return query(ls[id],ll,(ll+rr)/2,l,r);
	else
		return query(rs[id],(ll+rr)/2+1,rr,l,r);
}
int main()
{
    n=read<int>();
    c=read<long long>();
    d=read<long long>();
	for(int i=1;i<=n;i++)
		a[i]=read<int>();
	long long sum=0;
	int cur=0;
	for(int i=1;i<=n;i++)
	{
		sum+=query(a[i]+1,5e5);
		change(a[i],1);
		if(sum>=c)
		{
			cur=i;
			break;
		}
	}
	l[1]=cur;
	for(int i=2;i<=n;i++)
	{
		sum-=query(1,a[i-1]-1);
		change(a[i-1],-1);
		while(cur<n&&sum<c)
		{
			sum+=query(a[++cur]+1,5e5);
			change(a[cur],1);
		}
		if(sum<c)
		{
			for(int j=i;j<=n;j++)
				l[j]=-1;
			break;
		}
		l[i]=cur;
	}
	sum=0;
	for(int i=1;i<=1e6;i++)
		bit[i]=0;
	cur=-1;
	for(int i=1;i<=n;i++)
	{
		sum+=query(a[i]+1,5e5);
		change(a[i],1);
		if(c<=sum&&sum<=d)
			cur=i;
		if(sum>d)
		{
			cur=i-1;
			sum-=query(a[i]+1,5e5);
			change(a[i],-1);
			break;
		}
	}
	r[1]=cur;
	for(int i=2;i<=n;i++)
	{
		if(cur==-1)
		{
			for(int j=1;j<=n;j++)
				r[i]=-1;
			break;
		}
		sum-=query(1,a[i-1]-1);
		change(a[i-1],-1);
		while(cur<n&&sum<=d)
		{
			cur++;
			sum+=query(a[cur]+1,5e5);
			change(a[cur],1);
		}
		if(sum<c)
		{
			for(int j=i;j<=n;j++)
				r[j]=-1;
			break;
		}
		if(sum>d)
			r[i]=cur-1;
		else
			r[i]=cur;
	}
	for(int i=n;i>=1;i--)
	{
		if(r[i]<l[i]||l[i]==-1||r[i]==-1)
			root[i]=root[i+1];
		else
			root[i]=change(root[i+1],1,n,l[i],r[i],1);
	}
	q=read<int>();
	for(int i=1;i<=q;i++)
	{
		int l,r;
		l=read<int>();
		r=read<int>();
		print(query(root[l],1,n,l,r)-query(root[r+1],1,n,l,r),'\n');
	}
	return 0;
}
```

---

## 作者：Genius_Star (赞：1)

### 思路：

学 whk 的时候过来看了下题，以为 $c, d$ 每次给定，想了 1h 无果后就扔掉了……

注意到固定左端点 $l$ 后，随着 $r$ 的增加，逆序对数量肯定也会增加，所以符合条件的 $r$ 是一段区间。

同时将 $l$ 右移到 $l + 1$ 后，逆序对数量又会减少，则符合的 $r$ 所在的区间肯定不可能左移。 

故跑双指针走 $l, r$ 即可，树状数组维护逆序对数量。

现在我们已经对于每个 $l$，求出了 $r \in [L_l, R_l]$ 是符合条件的。

然后直接对 $l$ 从大到小扫描线即可，每次对 $[L_i, R_i]$ 区间加 $1$，询问就是 $[l, r]$ 的和。

时间复杂度为 $O((N + Q) \log N)$。

---

## 作者：Y2y7m (赞：0)

很典啊。

我们定义这个 $a$ 序列上的一个区间 $[l,r]$ 是合法的，当且仅当这个区间中上的逆序对个数在 $[c,d]$ 之间。

我们发现对于一个固定的右端点 $r$，满足 $[l,r]$ 是合法区间的左端点 $l$ 是一个连续区间。

我们可以双指针直接扫。

然后离线所有询问。

将所有询问区间按照右端点排序。

然后我们从 $1$ 到 $n$ 进行枚举，枚举到右端点 $i$ 时我们就将可以与右端点 $i$ 的可以构成合法区间的左端点区间在线段树上区间加一下。

对于询问区间 $[l,r]$，答案即为线段树上区间 $[l,r]$ 的和。

代码：


```cpp
#include <bits/stdc++.h>

using namespace std;
#define int long long
#define lson (i<<1)
#define rson (i<<1|1)
const int maxn=5e5+10;
int n,q,L,R;
int a[maxn];
int l[maxn],r[maxn];

vector<int> vec[maxn];
int ql[maxn],qr[maxn],ans[maxn];
struct BIT
{
	int c[maxn];
	int lowbit(int x)
	{
		return x&(-x);
	}
	int sum(int x)
	{
		int ans=0;
		while(x)
		{
			ans+=c[x];
			x-=lowbit(x);
		}
		return ans;
	}
	void change(int x,int d)
	{
		while(x<=5e5)
		{
			c[x]+=d;
			x+=lowbit(x);
		}
	}	
}T1,T2;

struct ST
{
	struct node
	{
		int l,r,len;
		int sum,lazy;
	}t[maxn*4];
	void build(int i,int l,int r)
	{
		t[i].l=l,t[i].r=r,t[i].len=r-l+1;
		t[i].sum=t[i].lazy=0;
		if(l==r) return ;
		int mid=(l+r)>>1;
		build(lson,l,mid);
		build(rson,mid+1,r);
	}
	void pushdown(int i)
	{
		if(t[i].lazy==0) return ;
		if(t[i].l==t[i].r)
		{
			t[i].lazy=0;
			return ;
		}
		t[lson].sum+=t[i].lazy*t[lson].len;
		t[rson].sum+=t[i].lazy*t[rson].len;
		t[lson].lazy+=t[i].lazy;
		t[rson].lazy+=t[i].lazy;
		t[i].lazy=0;
	}
	void change(int i,int l,int r,int d)
	{
		pushdown(i);
		if(l<=t[i].l&&t[i].r<=r)
		{
			t[i].sum+=t[i].len*d;
			t[i].lazy+=d;
			return ;
		}
		if(l<=t[lson].r) change(lson,l,r,d);
		if(r>=t[rson].l) change(rson,l,r,d);
		t[i].sum=t[lson].sum+t[rson].sum;
	}
	int query(int i,int l,int r)
	{
		pushdown(i);
		if(l<=t[i].l&&t[i].r<=r) return t[i].sum;
		int e=0;
		if(l<=t[lson].r) e+=query(lson,l,r);
		if(r>=t[rson].l) e+=query(rson,l,r);
		return e;
	}
}T;
void init()
{
	int s1=0,s2=0,p1=1,p2=1;
	for(int i=1;i<=n;i++)
	{
		int d=T1.sum(5e5)-T1.sum(a[i]);
		s1+=d;
		T1.change(a[i],1);
		d=T2.sum(5e5)-T2.sum(a[i]);
		s2+=d;
		T2.change(a[i],1);
		while(s1>R&&p1<=i)
		{
			s1-=T1.sum(a[p1]-1);
			T1.change(a[p1],-1);
			p1++;
		}
		while(s2>=L&&p2<=i)
		{
			s2-=T2.sum(a[p2]-1);
			T2.change(a[p2],-1);
			p2++;
		}
		l[i]=p1,r[i]=p2-1;
		if(s1<L||s2>=L) l[i]=1e9,r[i]=-1;
	}
}
signed main()
{
	ios::sync_with_stdio(false);
	cin>>n>>L>>R;
	for(int i=1;i<=n;i++) cin>>a[i];
	init();
	T.build(1,1,n);
	cin>>q;
	for(int i=1;i<=q;i++)
	{
		cin>>ql[i]>>qr[i];
		vec[qr[i]].push_back(i);
	}
	for(int i=1;i<=n;i++)
	{
		if(l[i]<=r[i]) T.change(1,l[i],r[i],1);
		for(int x:vec[i])
		{
			int t=ql[x];
			ans[x]=T.query(1,t,i);
		}
	}
	for(int i=1;i<=q;i++) cout<<ans[i]<<endl;
	return 0;
}
```

---

## 作者：Erine (赞：0)

对每个 $l$ 算出 $[r1_l,r2_l]$ 表示左端点为 $l$ 时，满足逆序对数量在 $[c,d]$ 内的右端点取值范围。可以直接树状数组双指针。

然后把合法区间刻画在二维平面上，相当于直线加，矩形查询。把矩形拆成两个 3-side 矩形然后扫描线即可。复杂度线对。

---

## 作者：SamHJD (赞：0)

对于固定的左端点 $i$，右端点 $j$ 右移时，区间的逆序对数不降。于是我们可以利用指针和树状数组对每个左端点 $i$ 求出满足逆序对数在 $[c,d]$ 中的合法右端点区间 $l_i,r_i$。

对于询问 $[L,R]$，即求对于 $i\in [L,R]$，$[l_i,r_i]$ 与 $[L,R]$ 的并的大小和，可以使用标记永久化的主席树实现，即对于版本 $i$，在 $[l_i,r_i]$ 区间加 $1$，查询 $R$ 版本的 $[L,R]$ 减 $L-1$ 版本的 $[L,R]$。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define rep(i,k,n) for(int i=k;i<=n;++i)
#define per(i,n,k) for(int i=n;i>=k;--i)
using namespace std;
template<typename T>
inline void read(T &x){
    x=0;int f=1;char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c-'0');
    x*=f;
}
template<typename T,typename ...Args>
inline void read(T &x,Args &...rest){read(x);read(rest...);}
const int N=5e5+10;
int n,a[N],l[N],r[N],V,q,invalid[N];
namespace BIT{
    ll t[N];
    void init(){memset(t,0,sizeof(t));}
    int lowbit(int x){return x&-x;}
    void add(int x,int k){if(x==0)return;for(int i=x;i<=V;i+=lowbit(i)) t[i]+=k;}
    int sum(int x){int res=0;for(int i=x;i;i-=lowbit(i))res+=t[i];return res;}
}
ll c,d;
namespace PST{
    int rt[N],tot;
    struct node{
        int ls,rs;
        ll sum,tag;
    }t[N*40];
    int upd(int p,int l,int r,int nl,int nr,int k){
        t[++tot]=t[p];p=tot;
        t[p].sum+=1ll*(min(r,nr)-max(l,nl)+1)*k;
        if(nl<=l&&r<=nr) return t[p].tag+=k,p;
        int mid=(l+r)>>1;
        if(nl<=mid) t[p].ls=upd(t[p].ls,l,mid,nl,nr,k);
        if(nr>mid) t[p].rs=upd(t[p].rs,mid+1,r,nl,nr,k);
        return p;
    }
    ll query(int p,int l,int r,int nl,int nr,ll mark){
        if(nl<=l&&r<=nr) return t[p].sum+1ll*(r-l+1)*mark;
        int mid=(l+r)>>1;ll res=0;
        if(nl<=mid) res+=query(t[p].ls,l,mid,nl,nr,mark+t[p].tag);
        if(nr>mid) res+=query(t[p].rs,mid+1,r,nl,nr,mark+t[p].tag);
        return res;
    }
}
signed main(){
    // freopen("data.in","r",stdin);
    read(n,c,d);
    rep(i,1,n) read(a[i]),V=max(V,a[i]);
    ll now=0;
    rep(i,1,n){
        l[i]=l[i-1];
        if(l[i]==i-1) l[i]=i,BIT::add(a[i],1),now=0;
        while(now<c&&l[i]+1<=n){
            l[i]++;
            BIT::add(a[l[i]],1);
            now+=BIT::sum(V)-BIT::sum(a[l[i]]);
        }
        if(l[i]==n&&now<c) invalid[i]=1;
        now-=BIT::sum(a[i]-1);
        BIT::add(a[i],-1);
    }
    BIT::init();
    now=0;
    rep(i,1,n){
        r[i]=r[i-1];
        if(r[i]==i-1) r[i]=i,BIT::add(a[i],1),now=0;
        while(now<=d&&r[i]+1<=n+1){
            r[i]++;if(r[i]==n+1) break;
            BIT::add(a[r[i]],1);
            now+=BIT::sum(V)-BIT::sum(a[r[i]]);
        }
        if(r[i]<=n) now-=BIT::sum(V)-BIT::sum(a[r[i]]);
        BIT::add(a[r[i]],-1);r[i]--;

        now-=BIT::sum(a[i]-1);
        BIT::add(a[i],-1);
    }
    rep(i,1,n){
        if(!invalid[i]) PST::rt[i]=PST::upd(PST::rt[i-1],1,n,l[i],r[i],1);
        else PST::rt[i]=PST::upd(PST::rt[i-1],1,n,l[i],r[i],0);
    }
    read(q);
    rep(qwq,1,q){
        int L,R;read(L,R);
        ll ans=0;
        ans+=PST::query(PST::rt[R],1,n,L,R,0);
        if(L>1) ans-=PST::query(PST::rt[L-1],1,n,L,R,0);
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：_zuoqingyuan (赞：0)

为什么我感觉这题做法很复杂？

# 思路分析

注意到 $c,d$ 是常数，我们可以预处理一下：对于每个 $i$，找到第一个 $L_i$ 满足 $[i,L_i]$ 区间逆序对 $\ge c$，找到最后一个 $R_i$ 满足 $[i,R_i]$ 区间逆序对数 $\le d$。此时，对于左边界为 $i$，只要右边界 $j\in [L_i,R_i]$，则区间 $[i,j]$ 都是符合条件的区间。

这个玩意可以通过双指针加树状数组预处理，时间复杂度 $O(n\log n)$。然后问题传化为，求出：

$$S(l,r)=\sum_{i=l}^r|[l,r]\cup[L_i,R_i]|$$

注意到查询为和的形式，可以差分降掉一维，分别求出 $S(1,l-1),S(1,r)$ 这两坨。

经典套路，将查询的右边界排序，然后扫描线，每次 $i\gets i+1$，就将 $[L_{i+1},R_{i+1}]$ 上的部分 $+1$。处理询问，就查询 $[l,r]$ 的区间和。线段树即可解决。

时间复杂度 $O(n\log n)$。

# Code

代码写的一坨，随便 Hack。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring> 
#include <vector>
#define ls (p<<1)
#define rs (p<<1|1)
using namespace std;
const int N=5e5+10,inf=1e9+7;
typedef long long ll;
ll tr[N],n,c,d,a[N],L[N],R[N],mx,q,ans[N];
void add(int x,ll v){
    for(;x<=mx;x+=(x&-x))tr[x]+=v;
    return;
}
ll ask(int x){
    ll cnt=0;
    for(;x>0;x-=(x&-x))cnt+=tr[x];
    return cnt;
}
struct node{
    ll l,r,id,op;
};
vector<node>Q[N];
struct sgt{
	ll sum[N<<2],tag[N<<2];
	void push_up(int p){
		sum[p]=sum[ls]+sum[rs];
	}
	void push_down(int p,int l,int r,int m){
		if(!tag[p])return;
		tag[ls]+=tag[p],sum[ls]+=(m-l+1)*tag[p];
		tag[rs]+=tag[p],sum[rs]+=(r-m)*tag[p];
		tag[p]=0;return;
	}
	void build(int p,int l,int r){
		if(l==r)return;int mid=(l+r)>>1;
		build(ls,l,mid),build(rs,mid+1,r);
	}
	void add(int p,int l,int r,int L,int R,int v){
		if(L<=l&&r<=R){
			tag[p]+=v,sum[p]+=(r-l+1)*v;
		}else{
			int mid=(l+r)>>1;push_down(p,l,r,mid);
			if(L<=mid)add(ls,l,mid,L,R,v);
			if(R>mid)add(rs,mid+1,r,L,R,v);
			push_up(p);
		}
		return;
	}
	ll ask(int p,int l,int r,int L,int R){
		if(L<=l&&r<=R)return sum[p];
		int mid=(l+r)>>1;ll cnt=0;push_down(p,l,r,mid);
		if(L<=mid)cnt+=ask(ls,l,mid,L,R);
		if(R>mid)cnt+=ask(rs,mid+1,r,L,R);
		return cnt;
	}
}tree;
int main(){
    scanf("%lld %lld %lld",&n,&c,&d);
    for(int i=1;i<=n;i++)scanf("%lld",a+i),mx=max(mx,a[i]);
    ll res=0;
    for(int i=1,j=0;i<=n;i++){
        while(j<n&&res<c)j++,add(a[j],1),res+=j-i+1-ask(a[j]);
        if(j==n){
            if(res<c)L[i]=inf;
            else L[i]=n;
        }else L[i]=j;
        add(a[i],-1);
        res-=ask(a[i]-1);
    }
	for(int i=1,j=0;i<=n;i++){
        while(j<n&&res<=d)j++,add(a[j],1),res+=j-i+1-ask(a[j]);
        if(j==n){
            if(res<=d)R[i]=n;
            else R[i]=n-1;
        }else R[i]=j-1;
        add(a[i],-1);
        res-=ask(a[i]-1);
    }
    scanf("%lld\n",&q);
    for(int i=1;i<=q;i++){
    	int l,r;
    	scanf("%d %d",&l,&r);
    	Q[r].push_back(node{l,r,i,1});
    	Q[l-1].push_back(node{l,r,i,-1});
	}
	tree.build(1,1,n);
	for(int i=1;i<=n;i++){
	    if(L[i]!=inf)tree.add(1,1,n,L[i],R[i],1);
	    for(auto u:Q[i])ans[u.id]+=u.op*tree.ask(1,1,n,u.l,u.r);
	}
	for(int i=1;i<=q;i++)printf("%lld\n",ans[i]);
	return 0;
}
```

如有错误，请指出。

---


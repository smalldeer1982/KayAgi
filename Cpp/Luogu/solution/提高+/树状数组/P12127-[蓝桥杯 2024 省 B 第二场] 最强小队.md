# [蓝桥杯 2024 省 B 第二场] 最强小队

## 题目描述

在蓝桥王国，一支勇士队伍依照既定的顺序排列。队伍由 $n$ 位勇士组成，每位勇士都有一个力量值，分别为 $a_1, a_2, \dots , a_n$。

国王下达了一项命令，要求从这支队伍中选拔一支精英小队，这支小队需满足以下条件：
1. 小队成员必须按照原队伍的次序来组成，即小队成员的排列顺序必须与原队伍保持一致。
2. 小队的首位和末位勇士的力量必须大于小队中其他所有勇士的力量。

对于一个小队，其强度与成员数量成正比，即成员数量越多，小队越强大。

现在，国王想要知道，最强小队的成员数量是多少。请你帮他找到并计算出最强小队的成员数量。

## 说明/提示

### 样例说明

在给定的样例中，勇士队伍的力量值为 $[3, 1, 2]$，我们可以选择的精英小队组建方法有：
1. 只选择第一位勇士，即 $[3]$。
2. 只选择第二位勇士，即 $[1]$。
3. 只选择第三位勇士，即 $[2]$。
4. 选择第一位勇士和第二位勇士，即 $[3, 1]$。
5. 选择第一位勇士和第三位勇士，即 $[3, 2]$。
6. 选择第二位勇士和第三位勇士，即 $[1, 2]$。
7. 选择所有勇士，即 $[3, 1, 2]$。

显然，选择所有勇士 [$3, 1, 2]$ 组成的小队是最强的。因此，最强小队的成员数量为 $3$。

### 评测用例规模与约定

- 对于 $10\%$ 的评测用例，$1 \leq n \leq 10^2$，$1 \leq a_i \leq 10^3$。
- 对于 $30\%$ 的评测用例，$1 \leq n \leq 10^3$，$1 \leq a_i \leq 10^5$。
- 对于所有评测用例，$1 \leq n \leq 10^5$，$1 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
3
3 1 2```

### 输出

```
3```

# 题解

## 作者：水星湖 (赞：4)

设最终答案区间为 $[l,r]$，不妨设 $a_l\le a_r$，另一种情况把 $a$ 反转一下就行了。

值域线段树维护考虑到第 $i$ 个数时，$a_j$ 后面小于 $a_j$ 的数的个数，记作 $f_j$，对于每个 $i$ 查询 $\max_{a_j \le a_i} f_j$，做完了。

```cpp
#include <bits/stdc++.h>
using namespace std;

namespace z {

#define int long long
const int N = 1e5 + 5;
int a[N], b[N], n, ans = 1, vis[N];
struct SGT {
    #define lc (p<<1)
    #define rc (p<<1|1)
    #define mid ((l+r)>>1)
    int t[N << 2], mx[N << 2];
    void clear() { memset(t, 0, sizeof t), memset(mx, -0x3f, sizeof mx); }
    void pd(int p) {
        if(t[p]) {
            mx[lc] += t[p], mx[rc] += t[p];
            t[lc] += t[p], t[rc] += t[p];
            t[p] = 0;
        }
    }
    void pu(int p) { mx[p] = max(mx[lc], mx[rc]); }
    void upd(int p, int l, int r, int L, int R, int v) {
        if(l >= L && r <= R) {
            t[p] += v, mx[p] += v;
            return;
        }
        pd(p);
        if(mid >= L) upd(lc, l, mid, L, R, v);
        if(mid < R) upd(rc, mid + 1, r, L, R, v);
        pu(p);
    }
    int query(int p, int l, int r, int L, int R) {
        if(l >= L && r <= R) return mx[p];
        pd(p);
        int res = -0x3f3f3f3f3f3f3f3f;
        if(mid >= L) res = max(res, query(lc, l, mid, L, R));
        if(mid < R) res = max(res, query(rc, mid + 1, r, L, R));
        return res;
    }
} sgt;
void main() {

    ios::sync_with_stdio(false);
    cin.tie(nullptr);cout.tie(nullptr);
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i], b[i] = a[i];
    sort(b + 1, b + n + 1); auto ed = unique(b + 1, b + n + 1);
    for(int i = 1; i <= n; i++) a[i] = lower_bound(b + 1, ed, a[i]) - b;
    sgt.clear();
    for(int i = 1; i <= n; i++) {
        int x = sgt.query(1, 1, n, 1, a[i]);
        ans = max(ans, x + 2);
        if(!vis[a[i]]) {
            vis[a[i]] = 1;
            sgt.upd(1, 1, n, a[i], a[i], -sgt.query(1, 1, n, a[i], a[i]));
        }
        sgt.upd(1, 1, n, a[i] + 1, n, 1);
    }
    memcpy(b, a, sizeof a);
    memset(vis, 0, sizeof vis);
    sgt.clear();
    for(int i = 1; i <= n; i++) a[i] = b[n - i + 1];
    for(int i = 1; i <= n; i++) {
        int x = sgt.query(1, 1, n, 1, a[i]);
        ans = max(ans, x + 2);
        if(!vis[a[i]]) {
            vis[a[i]] = 1;
            sgt.upd(1, 1, n, a[i], a[i], -sgt.query(1, 1, n, a[i], a[i]));
        }
        sgt.upd(1, 1, n, a[i] + 1, n, 1);
    }
    cout << ans << '\n';
}

#undef int

}


int main()
{
    z::main();
    return 0;
}
```

---

## 作者：LostKeyToReach (赞：4)

提供一个码量非常短的做法。

我们令选出的下标集合为 $\{i_k\}$，此时我们要求：

$$
\forall 2 \le j < k, a_{i_j} < \min(a_{i_1}, a_{i_k}).
$$

不妨钦定 $x = \min(a_{i_1}, a_{i_k})$，此时我们想到从大到小对数组排个序同时记录一下 $l, r, c$ 分别表示第一个 $a_i \ge x$ 的位置，最后一个 $a_i \ge x$ 的位置和 $a_i \ge x$ 的位置的个数，那么长度显然为 $2 + (r - l + 1) - c$，取最大值即可，注意特判一下 $n = 1$ 的 corner case。

时间复杂度 $O(n \log n)$，是当前最优解。

代码：

```cpp
#define MULTI_TEST 0
int32_t main() {
#if MULTI_TEST == 1
#else
    int n; std::cin >> n;
    VI a(n);
    For(i, 0, n - 1) std::cin >> a[i];
    Vec<PII> b;
    For(i, 0, n - 1) b.eb(a[i], i);
    std::sort(ALL(b), [&](auto& x, auto& y) -> bool {return x.first > y.first; });
    int mn = n, mx = -1, cnt = 0, ans = std::min(n, 2LL);
    for (int i = 0; i < n;) {
        int cur = 0, x = b[i].first;
        while (i < n && b[i].first == x) {
            int y = b[i].second;
            cmin(mn, y), cmax(mx, y);
            ++cur, ++i;
        }
        cnt += cur;
        if (mn == mx) cmax(ans, 1LL);
        else {
            cmax(ans, mx - mn - cnt + 3);
        }
    }
    std::cout << ans << "\n";
#endif
}
```

---

## 作者：dyc2022 (赞：3)

[更好的阅读体验](https://www.cnblogs.com/dyc2022/p/18825358)
***
感觉比较无脑的一道题，是为了锻炼代码能力才来的。

首先我们知道，如果确定了左右端点 $l,r$，那么我们就可以得出选出队伍的长度，即 $(l,r)$ 区间中 $< \min(l,r)$ 的数字个数加 $2$。

那么区间左右端点无非就两种情况，$a_l < a_r$ 或 $a_l \ge a_r$，为了方便可以给第一种情况取个等号。

那么先考虑 $a_l \ge a_r$ 的情况。我们可以枚举右端点，那么区间中的数字要满足的要求就仅和 $a_r$ 的值有关。所以我们就想要让这个区间尽可能大，即找到最小的 $i$ 使  $a_i \ge a_r$，线段树上二分即可。

$a_l \le a_r$ 的情况同理，只需要改成枚举 $l$。

对于实现，只需要写一个普通线段树维护区间最小值，再写一个主席树求区间中小于给定数的元素数量。那么就 $O(n \log^2 n)$ 的复杂度做完了，如果把二分搬到线段树上可以轻松一只 $\log$，但懒得写。

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
#define N 100006
using namespace std;
int n,a[N],b[N],bn,ans;
struct Segtree{int tree[N<<2];
void build(int p,int l,int r)
{
	if(l==r)return tree[p]=a[l],(void)0;
	int mid=l+r>>1;
	build(p<<1,l,mid),build(p<<1|1,mid+1,r);
	tree[p]=max(tree[p<<1],tree[p<<1|1]);
}
int query(int p,int l,int r,int L,int R)
{
	if(L<=l&&r<=R)return tree[p];
	int mid=l+r>>1,ret=-1e15;
	if(L<=mid)ret=max(ret,query(p<<1,l,mid,L,R));
	if(R>mid)ret=max(ret,query(p<<1|1,mid+1,r,L,R));
	return ret;
}}T1;
struct HJTtree{int tot,rt[N];
struct Node{int ls,rs,sum;}tree[N<<5];
void update(int &p,int q,int l,int r,int k)
{
	tree[p=++tot]=tree[q],tree[p].sum++;
	if(l==r)return;int mid=l+r>>1;
	if(k<=mid)update(tree[p].ls,tree[q].ls,l,mid,k);
	else update(tree[p].rs,tree[q].rs,mid+1,r,k);
}
int query(int p,int q,int l,int r,int L,int R)
{
	if(L>R)return 0;
	if(L<=l&&r<=R)return tree[p].sum-tree[q].sum;
	int mid=l+r>>1,ret=0;
	if(L<=mid)ret+=query(tree[p].ls,tree[q].ls,l,mid,L,R);
	if(R>mid)ret+=query(tree[p].rs,tree[q].rs,mid+1,r,L,R);
	return ret;
}}T2;
main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]),b[++bn]=a[i];
	if(n==1)return printf("1\n"),0;
	sort(b+1,b+1+bn),bn=unique(b+1,b+1+bn)-b-1;
	for(int i=1;i<=n;i++)
		a[i]=lower_bound(b+1,b+1+bn,a[i])-b;
	T1.build(1,1,n);
	for(int i=1;i<=n;i++)
		T2.update(T2.rt[i],T2.rt[i-1],1,bn,a[i]);
	for(int i=2;i<=n;i++)
	{
		int l=1,r=i-1,pos=0;
		while(l<=r)
		{
			int mid=l+r>>1;
			if(T1.query(1,1,n,1,mid)<a[i])
				pos=mid,l=mid+1;
			else r=mid-1;
		}
		pos++,ans=max(ans,T2.query(T2.rt[i-1],T2.rt[pos],1,bn,1,a[i]-1)+2);
	}
	for(int i=1;i<n;i++)
	{
		int l=i+1,r=n,pos=n+1;
		while(l<=r)
		{
			int mid=l+r>>1;
			if(T1.query(1,1,n,mid,n)<a[i])
				pos=mid,r=mid-1;
			else l=mid+1;
		}
		pos--,ans=max(ans,T2.query(T2.rt[pos-1],T2.rt[i],1,bn,1,a[i]-1)+2);
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：wangyanjing (赞：2)

# Description
以下是我对题目的理解：

给你一个序列，选一个区间 $[l,r]$，要求在这个区间中小于 $min(a_l,a_r)$ 的数的个数最多，求出这个个数 $+2$ 值。

请看为了方便理解，请看代码：

```cpp
for(int l = 1;l<=n;++l){
	for(int r = l;r<=n;++r){
		int Val = std::min(a[l],a[r]);
		int Cnt = 2;
		for(int i = l;i<=r;++i)
			if(a[i]<Val) ++Cnt;
		ans = std::max(ans,Cnt); 
	}
```
时间复杂度：$O(n^3)$。
# Solution
当我们**固定**一个 $a_i$，即 $ min(a_l,a_r) = a_i$ 时,
- 当 $r = i$：$l$ 取第一个大于等于 $a_i$ 的数的位置最优。
- 当 $l = i$：$r$ 取最后一个大于等于 $a_i$ 的数的位置最优。

取以上两种情况的最大值即可。

代码：

```cpp
inline int Cnt(int l,int r,int val){
	if(l == r) return 1;
	int ans = 2;
	for(int i = l;i<=r;++i)
		if(a[i]<val) ++ans;
	return ans;
} 
for(int i = 1;i<=n;++i){
	int MaxN;
	for(MaxN = 1;MaxN<=i;++MaxN)
		if(a[MaxN] >= a[i]) break;
	int MaxF;
	for(MaxF = n;MaxF>=i;--MaxF)
		if(a[MaxF] >= a[i]) break;
	int l1 = MaxN,r1 = i;
	int l2 = i,r2 =  MaxF;
	ans = std::max(ans,std::max(Cnt(l1,r1,a[i]),Cnt(l2,r2,a[i])));
}
```
时间复杂度：$O(n^2)$。

我们继续考虑优化：
- 对于求一个区间小于 $x$ 的数的个数：用可持久化权值线段树（主席树）即可。
- 对于求第一个大于等于 $x$ 的数的位置：离散化，求每一个数第一次出现的位置，做后缀 $min$ 即可。
- 对于求最后一个大于等于 $a_i$ 的数的位置：离散化，求每一个数最后一次出现的位置，做后缀 $max$ 即可。

详情请看代码。

```cpp
#include<cstdio>
#include<algorithm>
const int N = 1e5+5,LogN = 20;
const int inf = 0x7f7f7f7f; 
struct Segment_Tree{//可持久化权值线段树 
	struct Tree{
		int lson,rson,siz;
	}tree[N*LogN];
	int root[N],total = 0;
	inline void push_up(int rt){
		tree[rt].siz = tree[tree[rt].lson].siz + tree[tree[rt].rson].siz;
	}
	inline void Update(int &rt,int last,int l,int r,int pos,int val){
		rt = ++total,tree[rt] = tree[last];
		if(l == r) return void(tree[rt].siz += val);
		int mid = l + r >> 1;
		if(pos<=mid) Update(tree[rt].lson,tree[last].lson,l,mid,pos,val);
		else Update(tree[rt].rson,tree[last].rson,mid+1,r,pos,val);
		push_up(rt);
	} 
	inline int Ask(int rt,int treeL,int treeR,int askL,int askR){
		if(!rt || askL > askR) return 0;
		if(askL <= treeL && treeR <= askR) return tree[rt].siz;
		int mid = treeL + treeR >> 1;
		if(askR<=mid) return Ask(tree[rt].lson,treeL,mid,askL,askR);
		if(askL>mid) return Ask(tree[rt].rson,mid+1,treeR,askL,askR);
		return Ask(tree[rt].lson,treeL,mid,askL,askR) + Ask(tree[rt].rson,mid+1,treeR,askL,askR);
	}
}T;
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
int a[N],tmp[N],len;
int last[N],First[N],SufMax[N],SufMin[N];
inline void Prepare(int n){
	for(int i = 1;i<=n;++i) 
		if(!First[a[i]]) First[a[i]] = i;
	for(int i = n;i;--i)
		if(!last[a[i]])	last[a[i]] = i;
	SufMin[len+1] = inf,SufMax[len+1] = -inf;
	for(int i = len;i;--i) SufMin[i] = min(SufMin[i+1],First[i]);//后缀min 
	for(int i = len;i;--i) SufMax[i] = max(SufMax[i+1],last[i]);//后缀max 
	for(int i = 1;i<=n;++i)//与前缀和类似 
		T.Update(T.root[i],T.root[i-1],1,len,a[i],1);
}
inline int Cnt(int l,int r,int val){//查询 
	if(l == r) return 1;//细节 
	int SumL = T.Ask(T.root[l-1],1,len,1,val-1);
	int SumR = T.Ask(T.root[r],1,len,1,val-1);
	return SumR - SumL + 2;
}
int main(){
	int n;
	std::scanf("%d",&n); 
	for(int i = 1;i<=n;++i){
		std::scanf("%d",a+i);
		tmp[i] = a[i];
	}
	//离散化 
	std::sort(tmp+1,tmp+n+1);
	len = std::unique(tmp+1,tmp+n+1)-tmp-1;
	for(int i = 1;i<=n;++i)
		a[i] = std::lower_bound(tmp+1,tmp+len+1,a[i])-tmp;
	Prepare(n);
	int ans = 0;
	for(int i = 1;i<=n;++i){
		int l1 = SufMin[a[i]],r1 = i;
		int l2 = i,r2 = SufMax[a[i]];
		ans = max(ans,max(Cnt(l1,r1,a[i]),Cnt(l2,r2,a[i])));
	}
	std::printf("%d",ans);
	return 0;
}
```
时间复杂度：$O(n\log{n})$。

---

## 作者：vegetableYe (赞：1)

## 最强小队

#### 题意：

给定长度 $n\ (1 \leq n \leq 2 \times 10^5)$ 的序列 $a$，选出 $a$ 中最长的子序列 $b$，满足 $b$ 的第一个和最后一个值**严格**大于 $b$ 中其余的所有值。

#### 题解：

不妨假设 $b$ 的长度为 $m$，由于子序列只有 $b_1$ 和 $b_m$ 的大小比较好确定，因此我们可以考虑枚举这两者。

具体来说，我们可以只考虑 $\rm V$ 型的结构，也就是：

- 枚举 $a_i$ 充当 $b_m$ 时，我们只考虑 $b_1 \geq b_m$ 的情况。
- 枚举 $a_i$ 充当 $b_1$ 时，我们只考虑 $b_1 \leq b_m$ 的情况。

剩余的两种情况实际上是被上述两种情况包含的。

上述两种情况的逻辑实际上是差不多的，都是我们枚举 $a_i$ 后，在左边/右边找一个不小于 $a_i$ 的数字充当另一个 $b_1$ 或 $b_m$，我们只考虑第一种情况的逻辑，第二种是把第一种反着做一次（详见代码）。

对于 $a_i$ 充当 $b_m$ 的情况，我们需要在 $[1,i-1]$ 选择一个 $j$ 使得 $a_j\geq a_i$，$a_j$ 充当 $b_1$。那此时，为了让我们中间能选的数字尽可能多，因此贪心地，我们肯定是选择最靠左的不小于 $a_i$ 的数字 $a_j$。

这一步不难想到只需要在 ST 或线段树上二分即可，找出最优的 $a_j$ 后，我们只需要求 $[j+1,i-1]$ 中严格小于 $a_i$ 的数字个数，将这个个数 $+2$ 就是当前枚举的答案。（$+2$ 是因为算上 $j$ 和 $i$ 两个端点）

但不难发现这样非常麻烦，我们还需要多个高级数据结构来维护这一过程，那有没有简单的办法呢？

事实上我们可以考虑离线，从小到大枚举所有 $a_i$，把枚举过的数字一个个 “**激活**”，在我们统计区间合法数字个数时，只需要求出 “**被激活**” 的数字个数即可。

这样一来只需要：

1. 单点激活数字（实际上就是值域上树状数组单点加一）。
2. 区间查询激活的数字个数（值域树状数组的区间和）。

因此一个树状数组即可。

但需要注意的是，由于数组并非两两不同，因此进行以上过程时，我们需要一次性处理一串相同值，这一步双指针维护一下即可。

最后，别忘了 $ans$ 初始化为：$\min(n,2)$，以免 $n=1$ 时出问题。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
typedef long long ll;
typedef unsigned long long ull;
typedef __int128 lll;
typedef pair<ll, ll> P;
#define x first
#define y second
// #define int long long
using i64 = long long;

class BIT {
    public:
        BIT(int size) : size_(size), tree_(size + 1, 0) {}
    
        void update(int index, int delta) {
            for (int i = index + 1; i <= size_; i += (i & -i)) {
                tree_[i] += delta;
            }
        }
    
        int query(int index) {
            int sum = 0;
            for (int i = index + 1; i > 0; i -= (i & -i)) {
                sum += tree_[i];
            }
            return sum;
        }
    
        int queryRange(int left, int right) {
            return query(right) - query(left - 1);
        }
    
    private:
        int size_;
        vector<int> tree_;
    };

void solve() {
    int n;
    cin >> n;
    vector<int> a(n + 1), pre(n + 1), p(n + 1);
    for(int i = 1; i <= n; i++) {
        cin >> a[i];
        p[i] = i;
        pre[i] = max(pre[i - 1], a[i]);
    }
    vector<int> suf(n + 2);
    for(int i = n; i > 0; i--) {
        suf[i] = max(suf[i + 1], a[i]);
    }

    sort(p.begin() + 1, p.end(), [&](int & i, int & j) {
        return a[i] < a[j];
    });

    int ans = min(2, n);
    BIT bit(n + 1);
    int L = 1, R = n;
    for(int k = 1; k <= n; k++) {
        int j = k;
        while(j <= n && a[p[j]] == a[p[k]]) {
            j++;
        }

        int i = p[k];
        while(L < i && pre[L] < a[i]) {
            L++;
        }
        while(R > i && suf[R] < a[i]) {
            R--;
        }
        for(int idx = k; idx < j; idx++) {
            if(L + 1 <= p[idx] - 1) {
                ans = max(ans, bit.queryRange(L + 1, p[idx] - 1) + 2);
            }
            if(p[idx] + 1 <= R - 1) {
                ans = max(ans, bit.queryRange(p[idx] + 1, R - 1) + 2);
            }
        }
        for(int idx = k; idx < j; idx++) {
            bit.update(p[idx], 1);
        }
        k = j - 1;
    }
    cout << ans << endl;
}

/*



*/

signed main () {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int _ = 1;
    // cin >> _;
    while(_ -- ) {
        solve();
    }
    return 0;
}
```

时间复杂度：$ O(n\times \log(n))$。

---


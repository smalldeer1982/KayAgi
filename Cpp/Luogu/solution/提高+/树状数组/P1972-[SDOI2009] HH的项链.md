# [SDOI2009] HH的项链

## 题目描述

HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此，他的项链变得越来越长。  

有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答…… 因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。


## 说明/提示

【数据范围】  

对于 $20\%$ 的数据，$1\le n,m\leq 5000$；   
对于 $40\%$ 的数据，$1\le n,m\leq 10^5$；   
对于 $60\%$ 的数据，$1\le n,m\leq 5\times 10^5$；  
对于 $100\%$ 的数据，$1\le n,m,a_i \leq 10^6$，$1\le l \le r \le n$。

本题可能需要较快的读入方式，最大数据点读入数据约 20MB

## 样例 #1

### 输入

```
6
1 2 3 4 3 5
3
1 2
3 5
2 6
```

### 输出

```
2
2
4```

# 题解

## 作者：dlhham (赞：1433)

这个题用树状数组，线段树等等都可以做，不过用树状数组写起来更方便。

此题首先应考虑到这样一个结论：

对于若干个询问的区间[l,r]，如果他们的r都相等的话，那么项链中出现的同一个数字，一定是只关心出现在最右边的那一个的，例如：

项链是：1  3  4  5  1

那么，对于r=5的所有的询问来说，第一个位置上的1完全没有意义，因为r已经在第五个1的右边，对于任何查询的[L,5]区间来说，如果第一个1被算了，那么他完全可以用第五个1来替代。

因此，我们可以对所有查询的区间按照r来排序，然后再来维护一个树状数组，这个树状数组是用来干什么的呢？看下面的例子：

1 2 1 3

对于第一个1，insert(1,1)；表示第一个位置出现了一个不一样的数字，此时树状数组所表示的每个位置上的数字（不是它本身的值而是它对应的每个位置上的数字）是：1 0 0 0

对于第二个2，insert(2,1)；此时树状数组表示的每个数字是1 1 0 0

对于第三个1，因为之前出现过1了，因此首先把那个1所在的位置删掉insert(1,-1),然后在把它加进来insert(3,1)。此时每个数字是0 1 1 0

如果此时有一个询问[2,3]，那么直接求sum(3)-sum(2-1)=2就是答案。

题解清楚么？


---

## 作者：叶小枫 (赞：340)

# HH的项链 解题报告

$Author$：叶小枫

## 写在前面

解题报告是我个人的一种题解形式，它相较于一般的题解**主观性更强**，也会**更加详细**。可能体现做题的心路历程，也可能展示同样操作的不同算法，也可以半路推翻以前的写法重新维护新的操作满足新的需求……总之它也许并算不上非常严谨的题解，更像是一篇讲演稿，更像是就对着正在看报告的你说话。我希望营造一种个人主观思想的氛围，把问题用**我自己**的方式**讲明白**，这就是我撰写解题报告的所有初衷。

与各位共勉。

> Talk is easy, show me the code.

## 解题背景

最近在整理树状数组模板的时候偶然发现了一篇压箱底的ACcode，打开一看发现是这道[HH的项链](https://www.luogu.org/problem/P1972)，早已经忘记了题面于是打开又看了一眼。一眼扫过去，~~这不是个模拟吗~~，然后看到数据范围：对于所有数据 ：$ n,m\leq 1\times 10^6$

……（妈耶那我凉了啊），怎么后面还有一句

> 本题可能需要较快的读入方式，最大数据点读入数据约20MB

噫。那行吧，想一想正解是什么东西。既然是从树状数组板子旁边揪出来的那就是**树状数组**咯，然而很闲的我又喵到了刚刚打完的线段树板子……线段树……**？**

翻了一下其他题解，这可能是唯一一篇同时讲解了线段树和树状数组两种常见做法的解题报告，所以就筹划着写下来了。至于其他julao们写的**主席树**、**莫队**、**离散化**、**分块**……本蒟蒻一个都不会，就不在此班门弄斧了。

## 核心思想

最大那个点*（#10）*数据有$20MB$，这已经不是普通的`scanf`能承受的了。也许关了流同步的`cin`可以过，我没有试。所以上手先来一个**快读**，在此就略过。

读一下题目，我们发现一句话，也就是他的问题：“某一段贝壳中，包含了多少种不同的贝壳？”。这句话里包含了两个意思：1. 询问的是一个**区间**，2. 对于同一种贝壳，如果在询问的区间中**重复**出现，那么就可以只关注它出现的**某一个**位置而忽略其他同类的贝壳。

事实上，这两点也就是这道题目的核心思想。那么接下来要考虑的就是，我们要关注在区间内**哪一个位置**的同类贝壳。因为在一个区间中除了端点以外，其它中间元素的位置和数目都是不确定的，所以一种思路显而易见：只关注在**两端点处**出现的同类贝壳。第一篇高赞题解说的也就是这个事情，他选择了右端点作为判断的标准，其实左端点当然也可以~~（只要**反着建树**就好了）~~。但是完全没必要把整个树状数组反过来，所以在此也仅讨论取最**右边**一个同类贝壳的情况。

既然只关注最右边的贝壳，那么就需要**依次从左向右**地处理和修改整个数组，这样才能保证我们**对于前一个区间的修改不会影响到后面区间的询问**。当然还有一点，在关注了最右边贝壳之后，要**忽略**区间内其他同类的贝壳。

还有一个问题，我们要对区间询问什么东西？这就涉及到**前缀和**的思想：对于每一个区间，询问在它**右端点之前**有多少**不同类**的贝壳。因为由于我们之前的修改操作，所有同类的贝壳已经被简化到**只剩最靠右边**那个，所以可以保证这种做法的正确性。

所以经过总结，我们可以得到这样的总思路：

1. 我们需要一种支持单点修改、区间查询的数据结构
2. 对给定的询问区间，按照区间**右端点**进行排序，按排序后的顺序记录答案，然后**原序**输出。
3. 每个询问区间的答案就是区间**右端点**的前缀和$-$(区间**左端点$-$1**)的前缀和。

由此我们引出此解题报告的主角：**树状数组**和**线段树**。

## 树状数组解法

### 思路

单点修改、区间查询前缀和，树状数组真是一个再好不过的选择了。首先当然要开一个结构体存储询问的各个区间，方便排序和原序输出，再写一个`cmp`：

```cpp
struct QUE{
	int l;
	int r;
	int id; // 存放原序
}q[maxn];
inline bool cmp(const QUE &a,const QUE &b){
	return a.r<b.r;
}
```

然后就是树状数组的几个板子，$lowbit$，$modify$以及$query$，在此也不多解释：

```cpp
inline int lowbit(int x){
	return x&(-x);
}
void modify(int p,int v){
	for(;p<=n;p+=lowbit(p))
		tree[p]+=v;
}
int query(int p){
	int res=0;
	for(;p;p-=lowbit(p))
		res+=tree[p];
	return res;
}
// tree数组即为树状数组
```

下面引入重要的一个数组`vis[]`以及一个变量`pow`。`vis[i]`表示第`i`种贝壳在目前询问到的区间中**最后**出现的位置（也就是最右端）。变量`pow`指向的位置是**尚未修改**的区间的**左端点**，也就是**已经修改**区间**右端点**的后一个位置，方便定位未修改的区间。由于我们已经对询问的区间按右端点排好序，所以`pow`的值在不同时刻单调递增，直至末尾。

有了以上的信息之后就我们可以对区间进行修改了，主要维护两个操作：

1. 如果某元素`i`在之前已经出现过，那么将其**以前最右端位置**的前缀和$-$1，相当于忽略之前的位置。再在现在`i`的位置把前缀和$+$1，并更新`vis[i]`到当前位置。
2. 如果某元素`i`在之前没有出现，那么直接修改当前位置前缀和即可，并更新`vis[i]`。

最后再算一下**当前询问区间**的答案即可，以上两个操作如下：

```cpp
int pow=1;
	for(rint i=1;i<=m;++i){
		for(rint j=pow;j<=q[i].r;++j){
			if(vis[a[j]]) modify(vis[a[j]],-1);
			modify(j,1);
			vis[a[j]]=j;
		}
		pow=q[i].r+1;
		ans[q[i].id]=query(q[i].r)-query(q[i].l-1);
	}
```


### 总代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define rint register int
#define maxn 1000010
using namespace std;

int n,m;
int a[maxn],ans[maxn];
int vis[maxn],tree[maxn];

struct QUE{
	int l;
	int r;
	int id;
}q[maxn];

inline void read(int &x){
	char ch=getchar();int f=1;x=0;
	while(!isdigit(ch) && ch^'-') ch=getchar();
	if(ch=='-') f=-1,ch=getchar();
	while(isdigit(ch)) x=x*10+ch-'0',ch=getchar();
	x*=f;
}

inline bool cmp(const QUE &a,const QUE &b){
	return a.r<b.r;
}

inline int lowbit(int x){
	return x&(-x);
}

void modify(int p,int v){
	for(;p<=n;p+=lowbit(p))
		tree[p]+=v;
}

int query(int p){
	int res=0;
	for(;p;p-=lowbit(p))
		res+=tree[p];
	return res;
}

int main(){
	read(n);
	for(rint i=1;i<=n;++i) read(a[i]);
	read(m);
	for(rint i=1;i<=m;++i){
		read(q[i].l); read(q[i].r); q[i].id=i;
	}
	sort(q+1,q+m+1,cmp);
	
	int pow=1;
	for(rint i=1;i<=m;++i){
		for(rint j=pow;j<=q[i].r;++j){
			if(vis[a[j]]) modify(vis[a[j]],-1);
			modify(j,1);
			vis[a[j]]=j;
		}
		pow=q[i].r+1;
		ans[q[i].id]=query(q[i].r)-query(q[i].l-1);
	}
	
	for(rint i=1;i<=m;++i) printf("%d\n",ans[i]);
	return 0;
}
```

### 小结

好想好写跑得快（注意常数），是树状数组的巨大优势，认清了需要维护的操作之后树状数组一般是个不错的选择。本题的标准做法应该就是树状数组，因为无论哪方面都跟树状数组的核心思想和可支持的操作契合度很高，并且码量短、空间小、耗时少。尽管这样还是想种一棵线段树，于是才有了以下的内容。

## 线段树解法

### 思路

线段树是支持区间修改区间查询的东西……用来做**单点**修改有点大炮轰蚊子，还慢。~~不过谁让我闲呢~~，好在不会T掉，只是比树状数组要慢的太多了，所以不推荐使用。看了一些题解的评论区发现有许多想用线段树做的同学，但是没找到相应的题解，就让这篇解题报告来补上这个空吧。

其实线段树的思路跟树状数组的思路**几乎完全一样**，只是对于不同的操作有不同的写法而已。比如对于询问区间排序、维护最右端的贝壳位置、忽略无用位置、求前缀和……完全是一样的。所以这部分的**思路讲解**会偏少，主要会着眼于线段树**本身的操作**和细微的调整。如果线段树的基础很好，也可以只大致过一遍。

因为线段树占的空间比较大，所以我们所有的数组都开了**四倍**大小，不这样做会$RE$或者$WA$掉。

线段树的话目前我是没看到有其他人跟我写成一个鬼样子，大概就是上来三行宏，后面就开始疯狂输出（?

```cpp
#define root 1,n,1 // 树根的左端点右端点以及节点编号
#define lson l,mid,rt<<1 // 节点rt的左儿子，各参数意义同上
#define rson mid+1,r,rt<<1|1 // 结点rt的右儿子，各参数意义同上
```

这种写法我个人看来比较标准化和格式化，用在函数的参数里也可以减小一点思维难度。只是这样就限制了变量的命名必须是`mid`和`rt`，需要注意。并且每个函数都有了三个固定的参数`l`，`r`，`rt`用于格式化操作。

总之下面就是差别并不太大的几个板子函数，因为作了一些微调所以我们每个都捞出来讲讲：

1. $update$，emmmm没什么好讲的。
2. $build$，区别于一般的建树过程，这个$build$函数的直观作用就是把节点`tar`的值改为`1`，相当于标记一类贝壳的**最后出现位置**，用于区间求和。
3. $modify$，同样区别于一般的区间修改，这个$modify$的直观作用也仅仅是把`tar`节点的值改为`0`，相当于对该位置上的贝壳**忽略**。
4. $query$，这个就是一般的$query$，~~左边搞一搞右边搞一搞左右同时搞一搞~~然后输出区间和就行了。

**重点来了！**接下来要讲的就是一个`vector`**数组**：`vis[]`。这也是线段树做法唯一区别于树状数组的地方，这个`vis[]`数组应该是整个代码最难理解的部分。这里先放两段`vis[]`数组的使用代码：

```cpp
sort(q+1,q+m+1,cmp);
for(rint i=1;i<=m;++i) vis[q[i].r].push_back(i); // 确定每一个问题的访问顺序 
```

```cpp
for(rint i=1;i<=n;++i)
    // ...codes...
	for(rint j=0;j<vis[i].size();++j){
		int tmp=vis[i][j];
		ans[q[tmp].id]=query(root,q[tmp].l,q[tmp].r); // 按问题的原序(id)存好ans
	}
```

两段代码并不能说明什么问题，所以这里列一张样表，来解释这个数组的工作原理：

| vis[] |  1   |  2   |  3   |  4   |  5   |  6   | ...  |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  访   |  1   |  3   |  4   |  7   |  9   |  13  | ...  |
|  问   |  2   |      |  5   |  8   |  10  |  14  | ...  |
|  顺   |      |      |  6   |      |  11  | ...  | ...  |
|  序   |      |      |      |      |  12  | ...  | ...  |

这张表的第一行，加粗部分是每个`vector`数组的**编号**。每一列除了第一行下面挂着的数字，就代表着每一个**询问**的访问顺序。这张表是由第一段代码生成的，按照排序后的区间右端点作为第一关键字，让以点`q[i].r`为右端点的**询问区间**挂在以该点为编号的`vector`里，便于第二段代码调用。此时这个`vis[]`数组的第一维其实就是**点的**编号，每个点下面挂的数字就是每个**询问**的**访问顺序**。第二段代码中的`...codes...`部分进行的是**线段树**操作，在每个点操作完毕时遍历该点下挂的**询问**访问顺序，按照其保存的**原序**存储`ans`数组。

这确实有些难理解，而且讲起来也很拗口，概念也容易混淆。但是如果理解了会非常有意思，实在不行可以**手动模拟**一下，便于弄清每一步操作的含义。

接下来有个`lst[]`数组，其意义参考上文树状数组思路中的`vis[]`数组。

然后没什么好说的，用线段树的函数对每个点进行一些操作，我们就可以快乐输出然后`return 0`了。

### 一个意外

`Upd on Nov.3`

一觉醒来发现$rqy$评论了我，拿过来看看，说是线段树做法既然开了`vis`数组就没必要再对于询问区间排序了。突然发现这一行排序其实是复制树状数组代码时候无意间忘了删除的，因为`vis`数组实际上实现了跟排序一样的作用，再排一遍其实没必要。但是很奇妙的事情出现了，当我删除了这行`sort`后，交上去**T**了两个点……（不吸氧）

**“没道理啊，应该更快才对啊，这可少了一个$sort$啊。”**

以下是与$rqy$的记录：

-------

`rqy` 可能是

`rqy` cache相关？

`Maplef` **噫**（

`rqy` 就是你原本那样会**连续插入到同一个**vector里

`Maplef` 嗯对

`rqy` 理论上来说是更快的

`Maplef` 哦意思就是说

`Maplef` 每次插入到不同的vector里耗时会多……？

`Maplef` 不对啊……

`Maplef` 这跟耗时多少有很大关系吗qaq

`rqy` 是说

`rqy` 就是

`rqy` 你操作一段内存的时候就会把它加载到**缓存**里

`rqy` 所以反复**跳来跳去**是比连续访问慢不少的

`rqy` 但我没想到这个时间差**超过一个sort**

`Maplef` wua……

`Maplef` 居然这样

`Maplef` 对啊

`rqy` 嘛

`Maplef` 我也觉得它不该比sort慢

`Maplef` qwq

`Maplef` 怎么这样

---------

这个问题现在自己也搞不明白，只能说误打误撞多写了个`sort`免于超时，所以把它归在“一个意外”里。没想到跳跃访问不同的`vector`耗时比一个`sort`还要多，这也许可以成为写程序的一个注意点：在频繁访问**不同段内存**的时候，不妨可以考虑将访问顺序**重新排序**，以避免更多的耗时。

### 总代码

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#define rint register int
#define maxn 1000010

#define root 1,n,1
#define lson l,mid,rt<<1
#define rson mid+1,r,rt<<1|1
using namespace std;

int n,m;
int a[maxn<<2],lst[maxn<<2];
int tree[maxn<<2],ans[maxn<<2];
vector<int> vis[maxn<<2];

struct QUE{
	int l;
	int r;
	int id;
}q[maxn<<3];

inline void read(int &x){
	char ch=getchar();int f=1;x=0;
	while(!isdigit(ch) && ch^'-') ch=getchar();
	if(ch=='-') f=-1,ch=getchar();
	while(isdigit(ch)) x=x*10+ch-'0',ch=getchar();
	x*=f;
}

inline bool cmp(const QUE &a,const QUE &b){
	return a.r<b.r;
}

void update(int rt){
	tree[rt]=tree[rt<<1]+tree[rt<<1|1];
}

void build(int l,int r,int rt,int tar){
	if(l==r && l==tar){
		tree[rt]=1; return;
	}
	int mid=(l+r)>>1;
	if(tar<=mid) build(lson,tar);
	else build(rson,tar);
	update(rt);
}

void modify(int l,int r,int rt,int tar){
	if(l==r && l==tar){
		tree[rt]=0; return;
	}
	int mid=(l+r)>>1;
	if(tar<=mid) modify(l,mid,rt<<1,tar);
	else modify(mid+1,r,rt<<1|1,tar);
	update(rt);
}

int query(int l,int r,int rt,int nowl,int nowr){
	if(l==nowl&&r==nowr) return tree[rt];
	int mid=(l+r)>>1;
	if(nowr<=mid) return query(lson,nowl,nowr);
	else if(mid<nowl) return query(rson,nowl,nowr);
	else return query(lson,nowl,mid)+query(rson,mid+1,nowr);
}

int main(){
	read(n);
	for(rint i=1;i<=n;++i) read(a[i]);
	read(m);
	for(rint i=1;i<=m;++i){
		read(q[i].l); read(q[i].r);
		q[i].id=i;
	}
	
	sort(q+1,q+m+1,cmp);
	for(rint i=1;i<=m;++i) vis[q[i].r].push_back(i);

	for(rint i=1;i<=n;++i){
		if(!lst[a[i]]){
			lst[a[i]]=i;
			build(root,i);
		}
		else{
			modify(root,lst[a[i]]);
			lst[a[i]]=i;
			build(root,i);
		}
		
		for(rint j=0;j<vis[i].size();++j){
			int tmp=vis[i][j];
			ans[q[tmp].id]=query(root,q[tmp].l,q[tmp].r);
		}
	}
	
	for(rint i=1;i<=m;++i)
		printf("%d\n",ans[i]);
	return 0;
}
```

### 小结

线段树码量是大了点，但是支持**更多的操作**~~（也更慢）~~，拿来练练树状数组的题目倒也未尝不可。只是要注意区别和理解两种方法里不同的操作：一个用`pow`来指向位置，一个用`vis[]`数组事先存好访问顺序。两种做法因个人喜好而定，写出不同的操作一来是为了避免重复之嫌，二来也希望可以给各位带来更广阔的思考空间。

## 鸣谢

`_rqy`提供的新思路以及引出的新问题。

## 写在后面

本文在深夜写就，时间有些仓促，讲解的内容也或许蜻蜓点水。如有讲的不明白或者错误（错字）的地方恳请私信我或评论指出。

放一篇以前的解题报告：[时间复杂度 解题报告](https://www.luogu.org/blog/yexiaofeng/shi-jian-fu-za-du-xie-ti-bao-gao)。

>  最后感谢你能够看到这里，我们一起，为了未来的所有。

---

## 作者：凌幽 (赞：214)

解题做法：离线+树状数组

将问题区间排序（以左端点为关键字从小到大）

对于树状数组来说，这道题没有所谓的更新维护，而是单纯的询问“前缀和”

首先可以简化一下，像平常遇到的题一样，计算出从第一个位置起，到某个位置一共出现过多少个不同的数字

```cpp
for(int i=1;i<=n;++i)
    if(!have[num[i]]){
        have[num[i]]=1;
        add(i,1);
    }
```
这样，我们的query操作就是询问到某个位置时，一共出现了多少个不同的数字

进而，我们在此引进一个next[]数组

next[i]记录的是数字i在此后第一次出现的位置

(为何next在洛谷是关键字QAQ)

```cpp
for(int i=n;i;--i){
        if(!have[num[i]])nex[i]=n+1;
        else nex[i]=have[num[i]];
        have[num[i]]=i;
    }
```
树状数组query求区间和，对于闭区间[x,y]有query(y)-query(x-1)，ok，我们仍然可以用这样的方法

```cpp
int j=1;
    for(int i=1;i<=m;++i){
        for(;j<q[i].x;j++)add(nex[j],1);
        ans[q[i].id]=query(q[i].y)-query(q[i].x-1);
    }    
```
由于我们已经可以将不同数字出现的个数从最开始到某一时刻得出，那么query(y)的问题已解决，接下来考虑怎么才能减去query(x-1)并且不会出现错误

那就是在动态的更新，只要在左端点之前出现过，就加上，这样两次结果相减，就是正确答案了

对于最基础的树状数组add(x,d)和query(x)操作就不详细说明了，各路大神的博客上也有很多详细的解释

当然，此题莫队可过%%%


---

## 作者：会打沙包的猫 (赞：194)

蒟蒻初学树状数组，碰到这种模板自然要做，感觉大家的题解对新手都不太友好~~深有体会~~，我来发一篇稍明了一点的离线树状数组解法
~~~
1.按r排序一下
2.树状数组tree[j]维护从1到j不同数字的个数有多少个
3.然后用前缀和的思想就好（tree[r]-tree[l-1]）
 ！ok就这么简单！
~~~

~~~cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
#define maxn 1000119
int num[maxn],tree[maxn],booll[maxn],nnn[maxn],N,ww;;
//num数组保存原数列，tree树状数组，nnn保存结果
struct tt
{
    int l,r;//左右边界
    int pos;//原位置（因为我们要离线排序后处理）
};
tt ask[maxn];
bool cmp(tt x,tt y)
{ 
    return x.r<y.r;
    //快排大法好，没有什么是快排解决不来哦
    //实在不行就加上一个cmp
}
int lowbit(int n) 
{
    return n&(-n);
    //树状数组核心操作×1
}
void add(int n,int now)
{
    while(n<=N)
    {
        tree[n]+=now;
        n+=lowbit(n);
    }
    //树状数组核心操作×2-->更新操作
}
int sum(int n)
{
    int ans=0;
    while(n!=0)
    {
        ans+=tree[n];
        n-=lowbit(n);
    }
    return ans;
    //树状数组核心操作×3———>查询操作
}
int main()
{
        scanf("%d",&N);
        for(int i=1;i<=N;i++)
            scanf("%d",&num[i]);
        scanf("%d",&ww);
        for(int i=1;i<=ww;i++)
        {
            scanf("%d%d",&ask[i].l,&ask[i].r);
            ask[i].pos=i; //存储初始位置
        }
        sort(ask+1,ask+1+ww,cmp);//按r排序
        int next=1;
        for(int i=1;i<=ww;i++)
        {
            for(int j=next;j<=ask[i].r;j++)
            {
                if(booll[num[j]]) 
                    add(booll[num[j]],-1);
                 //之前打过标记，在之前的位置加上-1，保证无重复
                add(j,1);
                booll[num[j]]=j;
            }
            next=ask[i].r+1;
            //更新下一次查询的位置
            nnn[ask[i].pos]=sum(ask[i].r)-sum(ask[i].l-1);
            //按询问编号存储每组询问的结果
        }
    for(int i=1;i<=ww;i++)
      cout<<nnn[i]<<endl;
    return  0;
}
~~~
## ~~一定记得离线要按查询编号输出，不然会死的很惨！~~

---

## 作者：MambaHJ (赞：26)

个人感觉这题的题解中对新手最友好的一篇 [传送门](https://www.luogu.org/blog/user3432/solution-p1972)

- **这篇题解假设你已经学过树状数组的理论，并且已经做过一些模板题了。**

刚学树状数组，看到这题可以用，一定要自己写一篇题解防止忘了，这里~~本着不重复造轮子的理念~~，懒... 思路就不详细写了，大家可以看上面的链接，讲的对新手很友好，主要讲一下思路如何实现，以及代码需要注意的地方。
## 变量的意义
先解释一下定义的全局变量的作用
```
const int maxn = 1000010;

int n, m, a[maxn], bit[maxn], vis[maxn], ans[maxn];

struct Query{
	int l, r;
	int pos;
}query[maxn];
```
maxn：编号为0 到1000000 之间的整数。

a[maxn]：输入的项链编号数组。

bit[maxn]：在树状数组中用来记录a[i-lowbit(i)] + ... + a[i]

vis[maxn]：由于在查询区间[l, r]中，出现重复的数字时我们只需关心最右边即最后出现的那个数，所以需要用一个数组记录编号是否出现过，这里我们再引申一下，顺便用它记录出现的位置。

结构体用来记录每一个查询对应的左右区间l、r，以及用pos记录原始顺序，因为后面我们要根据区间的上界r来重新排序。
## 本题中树状数组是做什么的？
以样例的数据为例，我们来解释一下，这道题如何去用树状数组解：
样例：
```
6
1 2 3 4 3 5
3
1 2
3 5
2 6
```
我们重点关注查询[3, 5]，a[3] = a[5] = 3，所以这个查询的答案为2：
1. 由于上面以及说了出现重复的数字时我们只需关心最右边即最后出现的那个数，因此对于第一个3，我们用树状数组的add操作，add(3, 1)，这里的3是索引号，加1说明这个位置上出现过3这个数。用vis[a[3]] = j 记录它出现的位置并且表明它出现过。此时在[3, 5]这个区间上，树状数组的值为: 1 0 0。
2. 对于a[4] = 5，我们没有用vis标记过它，因此直接add(4, 1);此时在[3, 5]这个区间上，树状数组的值为: 1 1 0。
3. 对于a[5] = 3，我们回去查vis表，发现它已经在a[3]这个位置出现过，因此我们需要add(3, -1)，把它减去，然后在新的位置上add(5, 1)加上; 此时树状数组的值为 0 1 1。
4. 最后，查询时直接用sum(r) - sum(l - 1)即可(树状数组的基本能操作，不多解释了)。



记录答案时，要注意根据query的pos关键字存放答案，以输入时的顺序输出答案。

**最后放上完整代码：**
```
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int maxn = 1000010;

int n, m, a[maxn], bit[maxn], vis[maxn], ans[maxn];

struct Query{
	int l, r;
	int pos;
}query[maxn];

bool cmp(Query a, Query b){
	return a.r < b.r;
}

int lowbit(int u){
	return u & -u;
}

long long sum(int u){
	int res = 0;
	while (u > 0){
		res += bit[u];
		u -= lowbit(u); 
	}
	return res;
}

void add(int u, int d){
	while (u <= maxm){
		bit[u] += d;
		u += lowbit(u);
	}
}

int main(int argc, char const *argv[]){
	//freopen("/Users/macbook/Desktop/算法分析/OJ-Codes/洛谷/input.in", "r", stdin);
	scanf("%d", &n);
	/* 注意 编号为0 到1000000 之间的整数 */
	for (int i = 1; i <= n; ++i)
		scanf("%d", &a[i]);
	scanf("%d", &m);
	for (int i = 1; i <= m; ++i){
		scanf("%d%d", &query[i].l, &query[i].r);
		query[i].pos = i;
	}
	sort(query + 1, query + 1 + m, cmp);
	int next = 1;
	for (int i = 1; i <= m; ++i){
		for (int j = next; j <= query[i].r; ++j){
			/* 如果该查询区间内，这个数字出现过 */
			if (vis[a[j]])		
				add(vis[a[j]], -1);
			add(j, 1);
			vis[a[j]] = j;
		}
		next = query[i].r + 1;
		ans[query[i].pos] = sum(query[i].r) - sum(query[i].l - 1);
	}
	for (int i = 1; i <= m; ++i)
		printf("%d\n", ans[i]);
	return 0;
}
```


---

## 作者：无名之雾 (赞：25)

> 大家好，我是个毒瘤，我非常喜欢暴力数据结构，于是我就用分块过了这个题。

![](https://cdn.luogu.com.cn/upload/image_hosting/7i5qgxgu.png)

## 思路

对于这道题，我们把区间分 $\sqrt n$ 块。

我们首先对于每一块暴力求出不同数字的个数，时间复杂度复杂度 $O(n)$。

设 $f_{i,j}$ 表示第 $i$ 块到第 $j$ 块不同数字的个数。

如果我们要由 $f_{i,i}$ 求出 $f_{i,j}$，那么我们还需要一些量：我们要知道第 $i$ 个数左边第一个和它相同的数的位置 $l_i$ 以及右边的第一个 $r_i$。那么我们就可以求出 $f$ 数组。

预处理完毕后就可以读入询问了，对于一个询问 $[a,b]$，我们先求出 $[a,b]$ 所在的块 $fa,fb$，连续的整块 $fa+1$，到 $fb-1$ 可以 $O(1)$ 得到就是 $f_{fa+1,fb-1}$，之后暴力求出 $a$ 所在块以及 $b$ 所在块内出现的加到 $res$ 中即可，需要用到之前求出的 $l$ 以及 $r$ 数组。

## 实现

对于 $f$ 数组我们可以这么求：

$f_{i,j}=f_{i+1,j}$，再在块 $i$ 内寻找 $i+1$ 到 $j$ 块中没出现过的，加到 $f_{i,j}$ 中即可。

## 代码

```cpp
#include<bits/stdc++.h> 
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
inline void write(int x){
    if(x==0){putchar('0');return;}
	int len=0,k1=x,c[10005];
	if(k1<0)k1=-k1,putchar('-');
	while(k1)c[len++]=k1%10+'0',k1/=10;
	while(len--)putchar(c[len]);
}
const int N=1e6+5,M=1e3+5;
int w[N],f[M][M],l[N],r[N],last[N];
bitset<N>vis; 
int main(){
    int n=read(),num=ceil(sqrt(n)),siz=floor(sqrt(n));
    memset(r,0x3f,sizeof r);
    for(int i=1;i<=n;i++){
        w[i]=read();
        l[i]=last[w[i]];
        last[w[i]]=i;
        r[l[i]]=i;
    }
    for(int i=1;i<=num;i++){
        vis.reset();
        int beg=(i-1)*siz+1,end=min(i*siz,n);
        for(int j=beg;j<=end;j++){
            f[i][i]+=!vis[w[j]];
            vis[w[j]]=1;
        }
    }
    for(int i=1;i<num;i++){
    	for(int j=1;i+j<=num;j++){
        	f[j][i+j]=f[j+1][i+j];
        	int beg=(j-1)*siz+1,end=j*siz;
        	int border=(i+j)*siz; 
        	for(int k=beg;k<=end;k++){
            	f[j][i+j]+=(r[k]>border);
        	}
    	}
	}
	int m=read();
    while(m--){
        int a=read(),b=read();
        int fa=a/siz+1,fb=b/siz+1;
        int res=f[fa+1][fb-1];
        if(fb-fa<=1){
            vis.reset();
            for(int i=a;i<=b;i++){
                res+=!vis[w[i]];
                vis[w[i]]=1;
            }
            write(res),puts("");
            continue;
        }
        int rb=(fb-1)*siz;
        int enda=fa*siz,begb=(fb-1)*siz+1;
        for(int i=a;i<=enda;i++)res+=(r[i]>rb);
        for(int i=begb;i<=b;i++)res+=(l[i]<a);
        write(res),puts("");
    }
    return 0;
}
```

---

## 作者：MoonCake2011 (赞：15)

## 需要维护什么

见到这道题，我先花了一些时间想到了以下规律。

设 $lst_i$ 为 $a_i$ 的颜色上一次出现的地方。

比如样例的 $lst$ 数组是 $0,0,0,0,3,0$。

$lst$ 数组可以 $O(n)$ 求。

我们可以将询问转化为 $\sum_{i=l}^r(lst_i<l)$。

因为 $lst_i<l$ 可以保证不重复统计。

## 用什么维护

线段树可是不能维护此信息的。

又想到分块，发现 $1 \le n \le 10^6$，不行。

发现又可以用主席树，直接 MLE，28 分。

又想写线段树套平衡树。

直接 TLE+MLE 双王炸，依旧炸到 28 分。

等一下，内层的平衡树只用维护 $rank$。

归并树，启动。

## 什么是归并树

归并树是一个 FW 且几乎不为人知的数据结构。

在小蓝书上，只在 P3834 这道题上提了一嘴。

甚至完成 P3834 时间复杂度都为 $O(n \log n+m \log^3 n)$，空间复杂度 $O(n \log n)$。

它唯一的优点就是只有线段树的常数，比树套树与可持久化线段树常数要小。

还有写的短小，不需要用指针。

但是完成这道题是比较合适的。

归并树，顾名思义，是边归并排序，边建线段树。

每个线段树节点都存有那个区间排序后的结果。

通过合并两个子节点的有序序列，这个过程可以做到 $O(n \log n)$。

我们用归并树维护 $lst$ 数组。

对于每个查询，我们可以分出 $\log n$ 个区间。

查询的答案是这 $\log n$ 个区间 $<l$ 的数的个数。

有序区间，$<l$，二分查找，启动。

于是查询就变成了 $O(m \log^2 n)$。

代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[int(1e6)+10],lst[int(1e6)+10];
int b[int(1e6)+10];
vector<int>t[4000010];
inline void creat(int l,int r,int root){
	if(l==r){
		t[root].push_back(lst[l]);
		return;
	}
	int mid=l+r>>1;
	creat(l,mid,root*2);
	creat(mid+1,r,root*2+1);
	int i=0,j=0;
	while(i<t[root*2].size() && j<t[root*2+1].size())
		if(t[root*2][i]<t[root*2+1][j]) t[root].push_back(t[root*2][i++]);
		else t[root].push_back(t[root*2+1][j++]);
	while(i<t[root*2].size()) t[root].push_back(t[root*2][i++]);
	while(j<t[root*2+1].size()) t[root].push_back(t[root*2+1][j++]);
}
inline int ask(int l,int r,int x=1,int y=n,int root=1){
	if(l<=x && y<=r) return lower_bound(t[root].begin(),t[root].end(),l)-t[root].begin();
	int mid=x+y>>1,tot=0;
	if(l<=mid) tot+=ask(l,r,x,mid,root*2);
	if(mid<r) tot+=ask(l,r,mid+1,y,root*2+1);
	return tot;
}
inline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}//抄来的快读
int sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}
int main() {
	cin>>n;
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=n;i++){
		lst[i]=b[a[i]];
		b[a[i]]=i;
	}
	creat(1,n,1);
	cin>>m;
	while(m--){
		int l=read(),r=read();
		cout<<ask(l,r)<<"\n";
	}
	return 0;
} 
```
然后，88 分。

[记录](https://www.luogu.com.cn/record/145368855)。

~~线段树常数也有点大~~。

因为要在一些节点二分查找。

所以我们不妨离线下来，排序使 $l$ 递增。

在每个节点记录下上次在那个节点上 `return` 的东西 $d$。

我们再二分那个节点，就可以把二分左端点缩小到 $d+1$ 并更新 $d$。

这样，每次二分都可以缩小 $\log n$ 个节点的二分的范围。

因为归并树空间是比较纯（常数小）的 $O(n \log n)$。

所以空间较为宽裕，多开几个 $O(n)$ 的数组没有关系。

排序的常数较小，换来的优化的二分的时间更多。

所以卡过了。

[AC 记录](https://www.luogu.com.cn/record/145408684)。

代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[1000010],lst[1000010];
int b[1000010];
vector<int>t[4000010];
int d[4000010];
void creat(int l,int r,int root){
	if(l==r){
		t[root].push_back(lst[l]);
		return;
	}
	int mid=l+r>>1;
	creat(l,mid,root*2);
	creat(mid+1,r,root*2+1);
	int i=0,j=0;
	while(i<t[root*2].size() && j<t[root*2+1].size())
		if(t[root*2][i]<t[root*2+1][j]) t[root].push_back(t[root*2][i++]);
		else t[root].push_back(t[root*2+1][j++]);
	while(i<t[root*2].size()) t[root].push_back(t[root*2][i++]);
	while(j<t[root*2+1].size()) t[root].push_back(t[root*2+1][j++]);
}
inline int ask(int l,int r,int x=1,int y=n,int root=1){
	if(l<=x && y<=r)
		return d[root]=lower_bound(t[root].begin()+d[root],t[root].end(),l)-t[root].begin();//这里
	int mid=x+y>>1,tot=0;
	if(l<=mid) tot=ask(l,r,x,mid,root*2);
	if(mid<r) tot+=ask(l,r,mid+1,y,root*2+1);
	return tot;
}
inline int read(){//觉得别人的快读有点丑，换成自己云剪贴板里的代码了
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
struct node{
	int l,r,id,ans;
}q[1000010];
bool operator < (node x,node y){
	return x.l<y.l;
}
bool cmp(node x,node y){
	return x.id<y.id;
}
int main() {
	n=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=n;i++){
		lst[i]=b[a[i]];
		b[a[i]]=i;
	}
	creat(1,n,1);
	m=read();
	for(int i=1;i<=m;i++) q[i].l=read(),q[i].r=read(),q[i].id=i;
	sort(q+1,q+m+1);
	for(int i=1;i<=m;i++) q[i].ans=ask(q[i].l,q[i].r);
	sort(q+1,q+m+1,cmp);
	for(int i=1;i<=m;i++) cout<<q[i].ans<<"\n";
	return 0;
} 
```

---

## 作者：龙行龘龘 (赞：9)

# 树状数组我来了

这题莫队和主席树做的比较多,但我个人觉得树状数组比较板子啊......

整个好像就是在敲板子与输入输出的过程emmm...

对于若干个询问的区间[l,r]，如果他们的r都相等的话，那么项链中出现的同一个数字，一定是只关心出现在最右边的那一个的。因此，我们可以对所有查询的区间按照r来排序，然后再来维护一个树状数组。

那么，就是在动态的更新，如果此时有一个询问[L,R]，那么直接求sum(R)-sum(L-1)就是答案。

顺便献上我的blog:https://www.luogu.org/blog/Root-std-admin/

撸代码:

```cpp
//Written By:Jason_Root
//Time Limit : 1000 MS
//Memory Limit : 65536 KB
#include<bits/stdc++.h>
using namespace std;
const int inf = 0x7f7f7f7f; 
const int MAXN = 1e6+1000;
const int MAXK = 1e6+1000;
inline int read() { //快读 
	char ch = getchar();
	int x = 0, f = 1;
	while(ch < '0' || ch > '9') {
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while('0' <= ch && ch <= '9') {
		x = x * 10 + ch - '0';
		ch = getchar();
	}
	return x * f;
}
inline int max(int x1,int x2) { //取最大值 
	return x1>x2 ? x1 : x2;
}
struct data {
	int L,R,ad; //左右边界及原位置（因为我们要离线排序后处理）
} a[MAXN];
int sum[MAXN],ans[MAXN],nxt[MAXN],head[MAXK],n,m,mx,num[MAXN];
inline int lowbit(int x) {
	return x&(-x); //树状数组lowbit 
}
inline void add(int x,int v) {
	for(; x <= n; x+= lowbit(x)) {
		sum[x]+= v;
	}
	//树状数组更新操作 
}
inline int count(int x) {
	int tot = 0;
	for(; x; x-= lowbit(x)) {
		tot+= sum[x];
	}
	return tot;
	//树状数组查询操作 
}
inline bool cmp(const data x1,const data x2) { //sort函数的cmp 
	return x1.L==x2.L ? x1.R<x2.R : x1.L<x2.L;
}
void func() {
	n = read();
	for(int i = 1; i <= n; i++) {
		num[i] = read();
	}
	for(int i = n; i >= 1; i--) {
		nxt[i] = head[num[i]];
		head[num[i]] = i;
		mx = max(mx,num[i]);
	}
	m = read();
	for(int i = 1; i <= m; i++) {
		a[i].L = read();
		a[i].R = read();
		a[i].ad = i; //存储初始位置
	}
	sort(a+1,a+m+1,cmp); //按R排序
	for(int i = 1; i <= mx; i++) {
		if(head[i]) {
			add(head[i],1); //打标记 
		}
	}
	int now = 1;
	for(int i = 1; i <= m; i++) {
		while(now < a[i].L) {
			if(nxt[now]){
				add(nxt[now],1);
			}
			now++;
		}
		ans[a[i].ad] = count(a[i].R)-count(a[i].L-1); //按询问编号存储每组询问的结果
	}
	for(int i = 1; i <= m; i++){
		printf("%d\n",ans[i]);
	}
	return;
}
int main() {
	func();
	return 0;
}
```
好像树状数组题解都差不多的亚子2333...

真心感谢大家观看,谢谢!!!

---

## 作者：scp020 (赞：8)

# P1972 [SDOI2009] HH的项链 题解

补一个扫描线题解。

## 解法

一句话题意：给定一个序列，多次询问区间 $[l,r]$ 中有多少种不同的数。

我们设序列中 $a_i$ 上一次出现的位置为 $pre_i$，如果 $a_i$ 没有出现过，则 $pre_i = 0$。不难发现如果一种数在区间中出现多次，只会产生一次贡献。不妨钦定每种数产生贡献的位置是区间中第一次出现的位置，这时可以发现，产生的总贡献即为 $pre_x \le l - 1$ 的个数，反证法易证。

现在问题即为：给定一个序列 $pre$，多次查询区间 $[l,r]$ 中有多少个 $pre_i \le l - 1$。

我们把每一个 $pre_i$ 抽象到二维平面的点上，把 $i$ 看作横坐标，$pre_i$ 看作纵坐标，问题既转化为了经典的二维数点问题，每次询问左下角为 $(l,0)$，右上角为 $(r,l - 1)$ 的矩形中有几个点。

注意到这个询问是可差分的，我们可以将询问差分为左下角为 $(0,0)$，右上角为 $(r,l - 1)$ 的矩形减去左下角为 $(0,0)$，右上角为 $(l - 1,l - 1)$ 的矩形有几个点，这样方便我们使用扫描线思想。

我们将所有操作按横坐标排序（包括加点操作和查询操作），建立权值线段树，维护每个纵坐标出现个数。从左向右扫，如果遇到加点操作就在其纵坐标相应的线段树位置上加 $1$，如果遇到查询操作就查询线段树中 $[0,val]$ 的个数。

单次操作复杂度 $\mathcal{O}(\log n)$，共有 $n$ 次加点操作和 $2m$ 次查询操作，总时间复杂度 $\mathcal{O}((n + m) \log n)$。

## 代码

```cpp
#include<bits/stdc++.h>
namespace fast_IO
{
	/**
	 * 快读快写
	*/
};
using namespace fast_IO;
int n,m,a[1000010],pre[1000010],lst[1000010],ans[1000010],tot;
struct ope
{
	int type,x,y,id;
	inline bool operator<(const ope &rhs) const
	{
		if(x==rhs.x) return type<rhs.type;
		return x<rhs.x;
	}
};
ope op[3000010];
struct node
{
	int cnt;
	node *lc,*rc;
	inline node()
	{
		cnt=0,lc=rc=nullptr;
	}
	inline void pushup()
	{
		cnt=lc->cnt+rc->cnt;
	}
};
class seg_tree
{
	#define ls l,mid
	#define rs mid+1,r
private:
	node *root;
	inline node *build(int l,int r)
	{
		node *rt=new node();
		if(l<r)
		{
			int mid=(l+r)/2;
			rt->lc=build(ls),rt->rc=build(rs);
		}
		return rt;
	}
	inline void fix(node *rt,const int pos,int l,int r)
	{
		if(l==r)
		{
			rt->cnt++;
			return;
		}
		int mid=(l+r)/2;
		if(pos<=mid) fix(rt->lc,pos,ls);
		else fix(rt->rc,pos,rs);
		rt->pushup();
	}
	inline int ask(node *rt,const int L,const int R,int l,int r)
	{
		if(L<=l && r<=R) return rt->cnt;
		int mid=(l+r)/2,ret=0;
		if(L<=mid) ret+=ask(rt->lc,L,R,ls);
		if(R>mid) ret+=ask(rt->rc,L,R,rs);
		return ret;
	}
public:
	inline void build()
	{
		root=build(0,n);
	}
	inline void fix(const int pos)
	{
		fix(root,pos,0,n);
	}
	inline int ask(const int L,const int R)
	{
		return ask(root,L,R,0,n);
	}
};
seg_tree tree;
int main()
{
	in>>n,tree.build();
	for(int i=1;i<=n;i++) in>>a[i],pre[i]=lst[a[i]],lst[a[i]]=i,op[++tot]=(ope){0,i,pre[i],i};
	in>>m;
	for(int i=1,l,r;i<=m;i++) in>>l>>r,op[++tot]=(ope){1,r,l-1,i},op[++tot]=(ope){2,l-1,l-1,i};
	std::sort(op+1,op+tot+1);
	for(int i=1;i<=tot;i++)
	{
		if(op[i].type==0) tree.fix(op[i].y);
		else if(op[i].type==1) ans[op[i].id]+=tree.ask(0,op[i].y);
		else ans[op[i].id]-=tree.ask(0,op[i].y);
	}
	for(int i=1;i<=m;i++) out<<ans[i]<<'\n';
	fwrite(Ouf,1,p3-Ouf,stdout),fflush(stdout);
	return 0;
}
```

---

## 作者：Mr_Leceue (赞：8)

# **想用莫队开O2水过的看过来

莫队做法应该很显然，但是数据太过毒瘤让莫队~~望而生畏~~
更加奋然而前行，有什么可以让莫队屈服？

[](https://www.luogu.org/record/21624682)评测记录

我直接附上代码了

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define maxn 500007
#define Ri register int//指针优化 
using namespace std;
int n,m,be[maxn],a[maxn],unit,col[maxn*10],ans,l=1,r,prin[maxn];
struct query{int l,r,id;}q[maxn];//query的结构体，便于排序 
inline bool cmp(query a,query b){
	return be[a.l]^be[b.l]?be[a.l]<be[b.l]:(be[a.l]&1)?a.r<b.r:a.r>b.r;
}//排序小优化 
inline void syst(int x,int d){col[x]+=d;if(d>0)ans+=(col[x]==1);if(d<0)ans-=(col[x]==0);}
//d==1为增加，d==-1为减少 
template<typename type_of_scan>
inline void scan(type_of_scan &x){
	type_of_scan f=1;x=0;char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
	x*=f;
}
template<typename Tops,typename... tops>
inline void scan(Tops &x,tops&... X){
	scan(x),scan(X...);
}
template<typename type_of_print>
inline void print(type_of_print x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) print(x/10);
	putchar(x%10+'0');
} 

int main(){
	scan(n);unit=sqrt(n);
	for(Ri i=1;i<=n;i++)
		scan(a[i]),be[i]=i/unit+1;//分块 
	scan(m);
	for(Ri i=1;i<=m;i++)
		scan(q[i].l,q[i].r),q[i].id=i;
	sort(q+1,q+1+m,cmp);//排序 
	for(Ri i=1;i<=m;i++){
		while(l<q[i].l) syst(a[l],-1),l++;//减去l上这个数 
		while(l>q[i].l) syst(a[l-1],1),l--;//加上l-1上这个数 
		while(r<q[i].r) syst(a[r+1],1),r++; 
		while(r>q[i].r) syst(a[r],-1),r--;
		prin[q[i].id]=ans;//记录答案 
	}
	for(Ri i=1;i<=m;i++)
		print(prin[i]),putchar('\n');
}
```

自带巨大常数的我开O2过了，相信各位巨佬也可以。。。
顺便附上树状数组代码（其实我也写挂了，于是改写树状数组，不过又优化了，于是开着O2强过）
```cpp
#include<bits/stdc++.h>
#define maxn 500007
using namespace std;
int n,m,tree[maxn<<2],a[maxn],cent,col[maxn*10],pre[maxn*10];
struct query{int l,r,id,ans;}q[maxn];
inline bool cmp(query a,query b){return a.r==b.r?a.l<b.l:a.r<b.r;}
inline bool cmp1(query a,query b){return a.id<b.id;}
inline int lowbit(int x){return x&-x;}
inline void add(int x,int d){for(;x<=n;x+=lowbit(x)) tree[x]+=d;}
inline int ask(int x){int ans=0;while(x) ans+=tree[x],x-=lowbit(x);return ans;}

template<typename type_of_scan>
inline void scan(type_of_scan &x){
	type_of_scan f=1;x=0;char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
	x*=f;
}
template<typename Tops,typename... tops>
inline void scan(Tops &x,tops&... X){
	scan(x),scan(X...);
}
template<typename type_of_print>
inline void print(type_of_print x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) print(x/10);
	putchar(x%10+'0');
}

int main(){
	scan(n);
	for(int i=1;i<=n;i++)
		scan(a[i]);
	scan(m);
	for(int i=1;i<=m;i++)
		scan(q[i].l,q[i].r),q[i].id=i;
	sort(q+1,q+1+m,cmp);
	for(int i=1;i<=m;i++){
		while(cent<q[i].r){
			add(++cent,1);
			col[a[cent]]++;
			if(col[a[cent]]>1){
				add(pre[a[cent]],-1);
				pre[a[cent]]=cent;
				col[a[cent]]--;
			}else pre[a[cent]]=cent;
		}
		q[i].ans=ask(q[i].r)-ask(q[i].l-1);
	}
	sort(q+1,q+1+m,cmp1);
	for(int i=1;i<=m;i++)
		print(q[i].ans),putchar('\n');
	return 0;
}
```
写这道题推荐用两种方法，这样也可以复习树状数组。。。


---

## 作者：Flanksy (赞：7)

### 分治

对于静态区间数颜色问题，树状数组可以以很高的效率和相当简单的思路解决，分治麻烦很多。

希望有人能够给出更好的实现，发现代码中可以优化的地方也欢迎交流。

------------

#### 实现

树状数组的思路里动态地维护了当前有效的元素，对于分治，可以通过记录上一个等值元素的位置判定元素是否产生贡献。

对值为 $a_i$ 的元素 $i$ 记录上一个等值元素的位置 $pre_i$，对每个询问 $[l,r]$ 查询 $i\in[l,r]$ 且 $pre_i\leq l-1$ 的 $i$ 的个数。

差分询问，分别统计 $i\leq l-1$ 且 $pre_i\leq l-1$ 和 $i\leq r$ 且 $pre_i\leq l-1$ 的 $i$ 的个数。

笔者的代码中结构体内的变量及作用：

对于给出序列中的元素：

- $opt=0$。
- $i$：标识元素在序列中的位置。
- $pre$：标识上一个等值元素出现的位置，如果这个值第一次出现则为 $0$。

对于差分后的每个询问：

- $opt$： 询问的编号，$opt$ 的正负性影响答案贡献的统计。
- $i$：标识询问的区间 $[1,i]$，排序时将询问放置至正确的位置。
- $pre$：标识询问区间内元素的 $pre$ 值的上限，大于这个上限则不应统计贡献。

有相等 $i$ 值的询问应该排在元素之后，代码里偷懒使用的是 ```stable_sort```，自定义 ```cmp``` 也可以实现相同效果。

由于预先设置了 $i$ 的值并以 $i$ 为关键字排序，所有 $i$ 值为 $x$ 的询问将可以接收到所有 $i\leq x$ 的元素的贡献。在此之上，分治过程中按照 $pre$ 值从小到大归并结构体，对归并中线右边的询问统计归并中线左边的元素的贡献。

按照这个思路写出来的代码跑得比树状数组慢很多，这里是几种实现的评测记录。

[使用 ```inplace_merge``` 的朴素实现](https://www.luogu.com.cn/record/108707471)

[记录结构体编号，排序和分治过程中操作编号数组](https://www.luogu.com.cn/record/108708276)

[手动归并结构体](https://www.luogu.com.cn/record/108709686)

单个测试点的平均用时是树状数组三倍以上，这次真的要仅供参考了。

由于 $n,m$ 同阶，时间复杂度 $O(n\log n)$。

以下代码去除了输入输出部分。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Change{int i,pre,opt;}s[3000001],t[3000001];
int ans[1000001],pre[1000001];
inline int abs(int x){return x<0 ? -x:x;}
void cdqsort(int l,int r){
    if(l==r) return;
    int j=l,pos=l,sum=0,mid=l+r>>1;//j:左区间归并进度 sum:左区间已统计元素数量
    cdqsort(l,mid),cdqsort(mid+1,r);
    for(int i=mid+1;i<=r;i++){
        while(j<=mid&&s[j].pre<=s[i].pre){
        	t[pos]=s[j];
            sum+=s[j].opt==0;
            ++j,++pos;
        }
        if(s[i].opt) ans[abs(s[i].opt)]+=s[i].opt<0 ? -sum:sum;
        t[pos]=s[i],++pos;
    }
    for(int i=j;i<=mid;i++) t[pos]=s[i],++pos;
    for(int i=l;i<=r;i++) s[i]=t[i];
}
bool cmp(const Change &x,const Change &y){return x.i<y.i;}
int main(){
    int n=read();
    for(int i=1;i<=n;i++){
        int x=read();//统计过程和元素值无关
        s[i].pre=pre[x];
        s[i].i=pre[x]=i;
    }
    int m=read();
    for(int i=1;i<=m;i++){
        int l=read(),r=read();
        s[++n].i=l-1;
        s[n].opt=-i,s[n].pre=l-1;
        s[++n].i=r;
        s[n].opt=i,s[n].pre=l-1;
    }
    stable_sort(s+1,s+n+1,cmp);
    cdqsort(1,n);
    for(int i=1;i<=m;i++) write(ans[i]);
    return 0;
}
```


---

## 作者：孑彧 (赞：7)

# P1927 HH的项链 解题报告

### 题目描述

HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此，他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答……因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。

简而言之，求一段区间内不相同的数的个数

### 思路

这个题其实我在搞CF的时候见过类似的，那时候是要维护一个字母序列，所以可以直接写一个线段树莽过去

但是对于这个题肯定是不行的，因为这个数的范围太大了，所以会爆空间

由于我最近刚刚学习了莫队，然后就想用莫队来做，就是在指针移动的时候维护一个cnt数组，记录当前的数有几个，然后就愉悦的提交了一份代码

![P1972 1](C:\Users\宗子琪\Desktop\杂图\P1972 1.png)

然后他就挂了

啥？？？

难道是我的常数不够优秀？？？

各种优化全开！！！

![QQ图片20191011103209](C:\Users\宗子琪\Desktop\杂图\QQ图片20191011103209.png)

emmmmm

awsl

后来经过查验题解，我发现了一个问题：这个题卡莫队！！！

~~好了本题解结束~~

那这个题要怎么处理呢？？

很明显的是，这个题是要用一个数据结构来优化，但是不幸的是，这个题所要维护的东西既不满足区间可加性，又不满足区间可减性，所以线段树和树状数组是不可以用的，至少在线做法是无法支持的。

仔细观察题面后可以发现，对于一个数x来说，它对一个询问区间$[l,r]$来说，只有是在$r$之前的最后一个x才会对这个答案产生贡献，然后我们就可以开一个数组，来记录当前这个数在哪个位置出现过，然后我们就可以通过对询问离线处理后，对右端点为第一关键字排个序，接下来就是一个简单的求前缀和的过程了，这个过程可以通过一个树状数组来维护

然后就过了

### 代码

```c++
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#define maxn 1100000
using namespace std;
int num[maxn],t[maxn],ans[maxn],vis[maxn];
int n,m;
inline int read(){
    char c=getchar(); int x=0,f=1;
    while(c<'0' || c>'9') {if(c=='-')f=-1; c=getchar();}
    while(c>='0' && c<='9') {x=x*10+c-'0'; c=getchar();}
    return x*f;
}
struct Query{
	int l,r,id;
	bool operator < (const Query &a)const{
		return r<a.r;
	}
}q[maxn];
inline int lowbit(int x){
	return x&(-x);
}
void add(int x,int k){
	while(x<=n){
		t[x]+=k;
		x+=lowbit(x);
	}
}
int sum(int x){
	int ans=0;
	while(x!=0){
		ans+=t[x];
		x-=lowbit(x);
	}
	return ans;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		num[i]=read();
	}
	cin>>m;
	for(int i=1;i<=m;i++){
		q[i].l=read();
		q[i].r=read();
		q[i].id=i;
	}
	sort(q+1,q+1+m);
	int next=1;
	for(int i=1;i<=m;i++){
		for(int j=next;j<=q[i].r;j++){
			if(vis[num[j]]){
				add(vis[num[j]],-1);
			}
			add(j,1);
			vis[num[j]]=j;
		}
		next=q[i].r+1;
		ans[q[i].id]=sum(q[i].r)-sum(q[i].l-1);
	}
	for(int i=1;i<=m;i++){
		cout<<ans[i]<<endl;
	}
	return 0;
}
```


---

## 作者：Para (赞：5)

### [[SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)

### 思路

由于序列内的操作只有查询没有修改，我们可以考虑简单的离线，即将所有查询按照右区间排序，维护一棵 $BIT$，统计区间 $[1, x]$ $(x$ 为 $bit[x]$ 统计的区间$)$，用多少种不同的珍珠。

此外，我们还要记录一个 $vis$ 数组，统计颜色 $i$ 上一次在哪一个位置出现。如果未出现过，则直接将前面每一个状态加一，否则将之前出现的位置减一，当前位置加一，就是一个前缀和的思想。

### code

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
void read (long long &x) { 
	long long f = 1; x = 0; char s = getchar (); while (s < '0' || s > '9') {if (s == '-') f = -1; s = getchar ();}
	while (s >= '0' && s <= '9') {x = x * 10 + s - '0'; s = getchar ();} 
	x *= f;
}//不加会死的很惨
struct st {
	long long l, r, id;
}k[1000005];
long long a[1000005], bit[1000005], n;
bool cmp (st x, st y) {
	return x.r < y.r;
}
long long lowbit (long long x) {
	return x & (-x);
}
void add (long long x, long long y) {
	for (long long i = x; i <= n; i += lowbit (i)) bit[i] += y;
}
long long sum (long long x) {
	long long cnt = 0;
	for (long long i = x; i >= 1; i -= lowbit (i)) cnt += bit[i];
	return cnt;
}
long long vis[1000005], ans[1000005];
int main () {
	read (n);
	for (long long i = 1; i <= n; i++) read (a[i]);
	long long m;
	read (m);
	for (long long i = 1; i <= m; i++) read (k[i].l), read (k[i].r), k[i].id = i;
	sort (k + 1, k + 1 + m, cmp);
	long long last = 1;
	for (long long i = 1; i <= m; i++) {
		for (long long j = last; j <= k[i].r; j++) {
			if (vis[a[j]]) add (vis[a[j]], -1);
			add (j, 1);
			vis[a[j]] = j;
		}
		last = k[i].r + 1;
		ans[k[i].id] = sum (k[i].r) - sum (k[i].l - 1);
	}
	for (long long i = 1; i <= m; i++) printf ("%lld\n", ans[i]);//按标号输出
	return 0;
}

```

---

## 作者：i207M (赞：5)

## 题目总结

给定静态序列，多次回答[l,r]内不同数字的个数；

## 数据范围

N <= 500000，M <= 200000

## 解题思路

### 法一

使用树状数组离线求解；

此题首先应考虑到这样一个结论：

对于若干个询问的区间[l,r]，如果他们的r都相等的话，那么项链中出现的同一个数字，一定是只关心出现在最右边的那一个的，例如：

项链是：1 3 4 5 1

那么，对于r=5的所有的询问来说，第一个位置上的1完全没有意义，因为r已经在第五个1的右边，对于任何查询的[L,5]区间来说，如果第一个1被算了，那么他完全可以用第五个1来替代。

因此，我们可以对所有查询的区间按照r来排序，然后再来维护一个树状数组，这个树状数组是用来干什么的呢？看下面的例子：

1 2 1 3

对于第一个1，insert(1,1)；表示第一个位置出现了一个不一样的数字，此时树状数组所表示的每个位置上的数字（不是它本身的值而是它对应的每个位置上的数字）是：1 0 0 0

对于第二个2，insert(2,1)；此时树状数组表示的每个数字是1 1 0 0

对于第三个1，因为之前出现过1了，因此首先把那个1所在的位置删掉insert(1,-1),然后在把它加进来insert(3,1)。此时每个数字是0 1 1 0

如果此时有一个询问[2,3]，那么直接求sum(3)-sum(2-1)=2就是答案。

——转自 dlhham；

即：离散化后逐个位置处理，每次处理时去掉前边的重复数字，并回答提问


### 法二

主席树在线正解；

对于每一个点，都制作一个next[i]表示在这个点之后最近的颜色相同的点，如果没有就设为n+1，记一下队头O（N）扫一遍就好了

考虑区间查询l~r之间的颜色种数，其实就是求所有满足(l<=i<=r,next[i]>r)的个数，因为如果某个点的next已近超出了这个区间的范围，就说明这个点对答案产生贡献了。

这个时候问题就已近被转化为给定一个序列，求区间l~r之间权值大于r的个数。

那么我们对于每个点都在可持久化的权值线段树中构造一条新的线段树链就好了，查询就是常规的权值线段树的查询。

对于每个点都要新建一条最多Log2 N个点的链，空间复杂度N log2 N；对于每次询问最多递归深度为Log2 N层，时间复杂度M Log2 N。

——转自 [天狗的手帖](https://www.luogu.org/blog/user10356/solution-p1972)


## 易错误区

离线求解在回答时一定要按顺序回答


## 代码展示

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<list>
#include<queue>
#include<stack>
#include<bitset>
#include<deque>
using namespace std;
#define ll long long
#define in(x) x=rd()
inline ll rd() {
    ll ret=0;
    char c=getchar();
    while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9') ret=(ret<<3)+(ret<<1)+(c^'0'),c=getchar();
    return ret;
}
#define inf 2147483647l
#define ri register int
#define N 1000000
#define M 1
int n,m;
int a[N],b[N];
int bk[N];
struct Que{
	int l,r,k,o;
	friend bool operator<(Que a,Que b){
		return a.r<b.r;
	}
}q[N];
bool cmp(const Que& a,const Que& b){
	return a.k<b.k;
}
int lst[N];
int tre[N];
void add(int x,int k){
	for(;x<=n;x+=(x&-x)){
		tre[x]+=k;
	}
}
int query(int x){
	int ret=0;
	for(;x;x-=(x&-x)){
		ret+=tre[x];
	}
	return ret;
}
signed main() {
	scanf("%d",&n);
	for(ri i=1;i<=n;i++){
		scanf("%d",&a[i]);
		b[i]=a[i];
	}
	sort(b+1,b+1+n);
	unique(b+1,b+1+n);
	for(ri i=1;i<=n;i++){
		bk[i]=lower_bound(b+1,b+1+n,a[i])-b;
		lst[i]=n+1;
	}
	scanf("%d",&m);
	for(ri i=1;i<=m;i++){
		scanf("%d%d",&q[i].l,&q[i].r);
		q[i].k=i;
	}
	sort(q+1,q+1+m);
	for(ri i=1,cnt=1;i<=n&&cnt<=m;i++){
		add(lst[bk[i]],-1);
		add(i,1);
		lst[bk[i]]=i;
		while(q[cnt].r==i){
			q[cnt].o=query(q[cnt].r)-query(q[cnt].l-1);
			//printf("%d\n",query(q[cnt].r)-query(q[cnt].l-1));
			cnt++;
		}
	}
	sort(q+1,q+1+m,cmp);
	for(ri i=1;i<=m;i++){
		printf("%d\n",q[i].o);
	}
	return 0;
}
```



---

## 作者：sun1yu1jia1 (赞：3)

很显然我们可以想到线段树。

然后呢？

我用我这个不太睿智的大脑思考了一下，思考不出来。

于是我用了第二个灵感，莫队算法。当然线段树是可以做的，请看楼下几位的题解。


莫队算法，是一个优雅的暴力。

我们把区间的左端点分成√N组，然后按照组的序号进行排列，如果组序相同即按照又断电升序排列。

这样把第一个区间求出来，再调整左右端点，求出下面的区间。

时间复杂度为O(N\*√N)。本题我的代码运行时间为120ms，较中等。









    
    
    
    
        
    
    
```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;
int Read()
{
    int w = 1, i = 0; char ch = 0;
    while (ch > '9' || ch < '0')
    {
        if (ch == '-')
            w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        i = i * 10 + ch - '0';
        ch = getchar();
    }
    return i * w;
}
struct SQue {
    int iLeft, iRight;
    int iIndex, iGroup;
};
bool CompareQue(const SQue a, const SQue b)
{
    if (a.iGroup == b.iGroup)
        return a.iRight < b.iRight;
    return a.iGroup < b.iGroup;
}
int iNodeTot, iGroup, iQueTot;
int arrNum[50010];
SQue arrQue[200010];
int arrAns[200010];
int arrTime[1000010];
int iType;
int main()
{
    iNodeTot = Read();
    for (int i = 1; i <= iNodeTot; i++)
        arrNum[i] = Read();
    iGroup = sqrt(iNodeTot);
    iQueTot = Read();
    for (int i = 1; i <= iQueTot; i++)
    {
        arrQue[i] = (SQue) { Read(), Read(), i, 0 };
        arrQue[i].iGroup = arrQue[i].iLeft / iGroup;
    }
    sort(arrQue + 1, arrQue + 1 + iQueTot, CompareQue);
    for (int i = arrQue[1].iLeft; i <= arrQue[1].iRight; i++)
    {
        if (!arrTime[arrNum[i]])
            iType++;
        arrTime[arrNum[i]]++;
    }
    arrAns[arrQue[1].iIndex] = iType;
    int iLeft = arrQue[1].iLeft, iRight = arrQue[1].iRight;
    for (int i = 2; i <= iQueTot; i++)
    {
        while (iLeft > arrQue[i].iLeft)
        {
            iLeft--;
            if (!arrTime[arrNum[iLeft]])
                iType++;
            arrTime[arrNum[iLeft]]++;
        }
        while (iLeft < arrQue[i].iLeft)
        {
            arrTime[arrNum[iLeft]]--;
            if (!arrTime[arrNum[iLeft]])
                iType--;
            iLeft++;
        }
        while (iRight < arrQue[i].iRight)
        {
            iRight++;
            if (!arrTime[arrNum[iRight]])
                iType++;
            arrTime[arrNum[iRight]]++;
        }
        while (iRight > arrQue[i].iRight)
        {
            arrTime[arrNum[iRight]]--;
            if (!arrTime[arrNum[iRight]])
                iType--;
            iRight--;
        }
        arrAns[arrQue[i].iIndex] = iType;
    }
    for (int i = 1; i <= iQueTot; i++)
        printf("%d\n", arrAns[i]);
    return 0;
}
```

---

## 作者：sram (赞：2)

这道题想了很久，发题解是为了理解的更深刻一点。。。（管理放我过好嘛qwq）


------------


步入正题：这道题应该是很多做法，我选择的是离线+树状数组。
			
首先输入数组。用fisrt数组先记录元素最开始出现的位置，对应的每一个树状数组的位置add一下（树状数组洛谷也有模板题的了解一下就ok啦）。
```cpp
rep(i,1,n){//for循环的意思（1，n）闭区间
        scanf("%d",&a[i]);
        if(!first[a[i]]){
            first[a[i]]=i;
            add(i);//若第一次出现 则在树状数组中add。
        }
    }
```




然后倒着更新一遍数组，对每个元素用last数组记录当前下标元素的下一个出现的位置（可以模拟一遍就理解了）
```cpp
per(i,n,1){//还是for循环（n,1）
        last[i]=first[a[i]];
        first[a[i]]=i;//last数组记录当前元素 下一次出现的位置。
    }
```


接下来就是存一下询问啦。用vector存结构体应该快一点，结构体用左端点为关键字进行sort排序。
```cpp
    struct uzi{//全局的结构体，id为询问的序号
        int x,y,id;
        bool operator <(const uzi &a)const{
            return x<a.x;
         } 
    };

	vector<uzi> val;
    rep(i,0,m-1){
        int x,y;
        scanf("%d%d",&x,&y);
        val.push_back(uzi{x,y,i});//将询问存入
    }
    sort(val.begin(),val.end());//排序
```


接下来就是询问的处理啦（jd）

因为已经按左端点排序好了，所以 直接对树状数组动态更新，然后记录答案。这里用了一个j。当j比左端点小，就在j下标元素下个出现的位置对树状数组更新。(add)。。然后记录询问的结果就好啦。。。

```
for(auto k:val){
        while(j<k.x){
            add(last[j]);
            j++;
        }
        ans[k.id]=sum(k.y)-sum(k.x-1);
    }
```


------------

然后直接输出每个询问的结果就做完啦。。。。。
贴下全部的代码


------------









```cpp
#include<bits/stdc++.h>
#define swap(a,b) {a^=b;b^=a;a^=b}
#define rep(a,b,c) for(int a=b;a<=c;a++)
#define per(i,n,a) for (int i=n;i>=a;i--)
#define max(a,b) (a)>(b)?(a):(b)
#define min(a,b) (a)<(b)?(a):(b)
#define PII pair<int,int>
#define yxdl(qt) priority_queue<int,vector<int>,greater<int> >qt
#define xgd(qt)  priority_queue<int,vector<int>,less<int> >qt
#define INF 0x3f3f3f3f
#define lowbit(x)  x & -x
#define cs(s) freopen(s,"r",stdin)
#define debug(x) printf(" case-->%d ",x );
using namespace std;
typedef long long ll;
int a[500010],tree[500011],first[5000101],last[5100001],n,m,ans[510001];
struct uzi{
    int x,y,id;
    bool operator <(const uzi &a)const{
     	return x<a.x;
     } 
};
inline void add(int x){for(int i=x;i<=n;i+=lowbit(i))tree[i]+=1;}
inline int sum (int x){int ans=0;for(int i=x;i;i-=lowbit(i))ans+=tree[i];return ans;}
int main(){
    scanf("%d",&n);	
    rep(i,1,n){
        scanf("%d",&a[i]);
        if(!first[a[i]]){
            first[a[i]]=i;
            add(i);//若第一次出现 则在树状数组中add。
        }
    }
    per(i,n,1){
        last[i]=first[a[i]];
        first[a[i]]=i;//last数组记录当前元素 下一次出现的位置。
    }	
    scanf("%d",&m);
    vector<uzi> val;
    rep(i,0,m-1){
        int x,y;
        scanf("%d%d",&x,&y);
        val.push_back(uzi{x,y,i});//将询问存入
    }
    int j=1;
    sort(val.begin(),val.end());//排序
    for(auto k:val){
        while(j<k.x){
            add(last[j]);
            j++;
        }
        ans[k.id]=sum(k.y)-sum(k.x-1);
    }
    rep(i,0,m-1){
        printf("%d\n",ans[i] );
    }
}

```


---

## 作者：aiyougege (赞：2)

### [SDOI2009]HH的项链
#### Description
　　HH有一串由各种漂亮的贝壳组成的项链。HH相信不同的贝壳会带来好运，所以每次散步 完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH不断地收集新的贝壳，因此他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答。。。因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。

#### Solution
- Solution1: **莫队**.~~不会~~
- Solution2: **离线, 离散化,链表,树状数组**.
　　首先, 可以将颜色离散化.因为颜色从$1-1000000$实在是太大了.
```c++
namespace Map{
	int rank[N];
	int vis[P];
	void init(){
		for(int i=1;i<=n;++i)if(!vis[col[i]])s[++tot]=col[i],vis[col[i]]=true;
		sort(s+1,s+tot+1);
		for(int i=1;i<=tot;++i)rank[s[i]]=i;
		for(int i=1;i<=n;++i)s[i]=rank[col[i]];
	}
};
```
　　其次, 将项链按颜色建链表, 如果有$\text{tot}$种颜色, 那就按坐标建$\text{tot}$个链表.

```c++
namespace List{
	struct Node{
		int v,nxt;
	}e[N];
	int head[M],tail[M],pos[M],cnt;
	void AddEdge(int color,int posit){
		if(!head[color]){head[color]=++cnt;e[cnt]=(Node){posit,0};tail[color]=head[color]=cnt;;}
		else e[tail[color]].nxt=++cnt,e[cnt]=(Node){posit,0},tail[color]=cnt;
	}
	int Next(int col,int l){int i;for(i=pos[col]?pos[col]:head[col];e[i].v<l&&i;i=e[i].nxt);pos[col]=i;if(e[i].v)return e[i].v;else return n+1;}
};using namespace List;
```
　　然后将查询按**左端点**从小到大排序.
```c++
struct Query{
	int l,r,id;
	bool operator<(const Query& b)const{return l<b.l;}
}q[M];
```
　　在每个查询中, 找出从左端点$l$开始的每一种颜色的坐标, 记颜色$i$的第一个大于$l$的坐标为$p_i$, 那么表示$p_i$处开始出现了一种颜色, 那么$l-r$出现的颜色总数就为答案, 可以用**树状数组**来维护.
```c++
namespace BIT{
	int t[N];
	int lowbit(int i){return i&(-i);}
	void Add(int p,int c){int i=p;while(i<=n)t[i]+=c,i+=lowbit(i);}
	int query(int r){int i=r,ans=0;while(i)ans+=t[i],i-=lowbit(i);return ans;}
	int QUEry(int l,int r){return query(r)-query(l-1);}
};using namespace BIT;
```
　　还有一个问题是如何快速从一个查询过度到另一个查询? 因为从$l$过度到$l'$, 必定有一些颜色处于$[l,l')$之中, 而树状数组是统计不了它们的答案的.
1. 可以枚举每一种颜色是否需要更新**第一次在$[l,n]$出现的坐标**, 复杂度$O(km)$(*k为颜色数量*).~~结果:T成沙茶.~~
2. 直接枚举$[l,l')$之内的颜色是否需要更新, 均摊复杂度$O(n)$.~~结果:通过~~

#### Code

```c++
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<cctype>
#define M 200005
#define N 500005
#define P 1000005
#define inf 0x3f3f3f3f
using namespace std;

int read(){
	char ch=getchar();int s=0;
	for(;!isdigit(ch);ch=getchar());
	for(s=0;isdigit(ch);s=s*10+ch-'0',ch=getchar());
	return s;
}

int col[N],s[N];
int Answer[M];
int n,m,tot;
/*******************************************************************/
struct Query{
	int l,r,id;
	bool operator<(const Query& b)const{return l<b.l;}
}q[M];
/*******************************************************************/
namespace Map{
	int rank[N];
	int vis[P];
	void init(){
		for(int i=1;i<=n;++i)if(!vis[col[i]])s[++tot]=col[i],vis[col[i]]=true;
		sort(s+1,s+tot+1);
		for(int i=1;i<=tot;++i)rank[s[i]]=i;
		for(int i=1;i<=n;++i)s[i]=rank[col[i]];
	}
};
/*******************************************************************/
namespace List{
	struct Node{
		int v,nxt;
	}e[N];
	int head[M],tail[M],pos[M],cnt;
	void AddEdge(int color,int posit){
		if(!head[color]){head[color]=++cnt;e[cnt]=(Node){posit,0};tail[color]=head[color]=cnt;}
		else e[tail[color]].nxt=++cnt,e[cnt]=(Node){posit,0},tail[color]=cnt;
	}
	int Next(int col,int l){int i;for(i=pos[col]?pos[col]:head[col];e[i].v<l&&i;i=e[i].nxt);pos[col]=i;if(e[i].v)return e[i].v;else return n+1;}
};using namespace List;
/*******************************************************************/
namespace BIT{
	int t[N];
	int lowbit(int i){return i&(-i);}
	void Add(int p,int c){int i=p;while(i<=n)t[i]+=c,i+=lowbit(i);}
	int query(int r){int i=r,ans=0;while(i)ans+=t[i],i-=lowbit(i);return ans;}
	int QUEry(int l,int r){return query(r)-query(l-1);}
};using namespace BIT;
/*******************************************************************/
int visit[N];
int main(){
    scanf("%d",&n);int u,v,c;
	for(int i=1;i<=n;++i)
		col[i]=read();
	Map::init();
	for(int i=1;i<=n;++i)List::AddEdge(s[i],i);
	scanf("%d",&m);
	for(int i=1;i<=m;++i)q[i].l=read(),q[i].r=read();
	for(int i=1;i<=m;++i)q[i].id=i;
	sort(q+1,q+m+1);int po=0;
	for(int i=1;i<=tot;++i)Add(Next(i,1),1);
	for(int i=1;i<=m;++i){
		if(q[i].l>q[i-1].l){
			for(int j=q[i-1].l;j<q[i].l;++j)
				if(visit[s[j]]!=i){
					Add(Next(s[j],q[i].l),1),visit[s[j]]=i;
				}
		}
		Answer[q[i].id]=QUEry(q[i].l,q[i].r);
	}
	for(int i=1;i<=m;++i)
		printf("%d\n",Answer[i]);
    return 0;
}
```

---

## 作者：Tanktt (赞：1)

一道很有启发性的题目。

1. 将询问按r从小到大排序
1. 对于每个贝壳：先加到树状数组中add(i,1)，如果前面有它一样的，那么前面的这个变成0,add(pre,-1);

   因为每种贝壳只需要保留一个就可以了，每次都把前面一个删去，就能保证有一个了
   
1. 因为按照r来排序，而每个贝壳都要扫到，我们要用一个begin存储还没有扫过的贝壳起点，每次询问时再找一下就不会遗漏
1. 注意排序后的序列不是原序列，不能直接输出，要转换成原来的顺序。



------------
#### CODE

```cpp
#include<cstdio>
#include<algorithm>
#define reg register
#define FOR(i,l,r) for(reg int i=l; i<=r; i++)
using namespace std;
const int N=1000012;
int n,m,p[N],pre[N],c[N],ss[N];
struct node{
	int l,r,id;
}a[N];
inline int read()
{
	int x=0;char c=getchar();
	while (c<'0'||c>'9') c=getchar();
	while (c>='0'&&c<='9') x=(x<<1)+(x<<3)+c-48,c=getchar();
	return x;
}
inline void write(int x)
{
	if (x>=10) write(x/10);
	putchar(x%10+48);
}//快读快输

inline bool cmp(node x,node y) { return x.r<y.r; }

inline int lowbit(int x) {return x&(-x);}
inline void add(int x,int f)
{
	while (x<=n)
	{
		c[x]+=f;
		x+=lowbit(x);
	}
}
inline int sum(int x)
{
	int ans=0;
	while (x>0)
	{
		ans+=c[x];
		x-=lowbit(x);
	}
	return ans;
}
//树状数组
int main()
{
	n=read();
	FOR(i,1,n) p[i]=read();
	m=read();
	FOR(i,1,m)
	a[i].l=read(),a[i].r=read(),a[i].id=i;//存一下序号
	sort(a+1,a+1+m,cmp);
	int beg=1;
	FOR(i,1,m)
	{
		FOR(j,beg,a[i].r)
		{
			add(j,1);
			if (pre[p[j]]) add(pre[p[j]],-1);//把前面的删掉
			pre[p[j]]=j;//更新前面的贝壳序号
		}
		ss[a[i].id]=sum(a[i].r)-sum(a[i].l-1);//前缀和思想
		beg=a[i].r+1;//没扫过的起点
	}
	FOR(i,1,m)
	write(ss[i]),puts("");
	return 0;
}
```


---


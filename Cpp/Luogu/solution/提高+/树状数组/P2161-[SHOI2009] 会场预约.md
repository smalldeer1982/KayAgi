# [SHOI2009] 会场预约

## 题目背景

## 形式化描述

你需要维护一个在数轴上的线段的集合 $S$，支持两种操作：

`A l r` 表示将 $S$ 中所有与线段 $[l,r]$ 相交的线段删去，并将 $[l,r]$ 加入 $S$ 中。

`B` 查询 $S$ 中的元素数量。

对于 `A` 操作，每次还需输出删掉的元素个数。

## 题目描述

PP 大厦有一间空的礼堂，可以为企业或者单位提供会议场地。

这些会议中的大多数都需要连续几天的时间（个别的可能只需要一天），不过场地只有一个，所以不同的会议的时间申请不能够冲突。也就是说，前一个会议的结束日期必须在后一个会议的开始日期之前。所以，如果要接受一个新的场地预约申请，就必须拒绝掉与这个申请相冲突的预约。

一般来说，如果 PP 大厦方面事先已经接受了一个会场预约（例如从 $10$ 日到 $15$ 日），就不会再接受与之相冲突的预约（例如从 $12$ 日到 $17$ 日）。

不过，有时出于经济利益，PP 大厦方面有时会为了接受一个新的会场预约，而拒绝掉一个甚至几个之前预订的预约。 于是，礼堂管理员 QQ 的笔记本上经常记录着这样的信息：（本题中为方便起见，所有的日期都用一个整数表示）例如，如果一个为期 $10$ 天的会议从 $90$ 日开始到 $99$ 日，那么下一个会议最早只能在 $100$ 日开始。（此处前后矛盾，若无法理解请参考形式化描述。）

最近，这个业务的工作量与日俱增，礼堂的管理员 QQ 希望参加 SHTSC 的你替他设计一套计算机系统，方便他的工作。这个系统应当能执行下面两个操作：

`A` 操作：有一个新的预约是从 $start$ 日到 $end$ 日，并且拒绝掉所有与它相冲突的预约。执行这个操作的时候，你的系统应当返回为了这个新预约而拒绝掉的预约个数，以方便 QQ 与自己的记录相校对。

`B` 操作：请你的系统返回当前的仍然有效的预约的总数。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 2\times 10^5$，$1\le l \le r \le 10^5$。

## 样例 #1

### 输入

```
6
A 10 15
A 17 19
A 12 17
A 90 99
A 11 12
B```

### 输出

```
0
0
2
0
1
2```

# 题解

## 作者：Nartsam (赞：164)

### 一个非常简单的STL做法（非常好想，代码很短）

题意已经暗示的很明确要你使用平衡树了，但本蒟蒻太懒，不想打平衡树，于是便考虑偷懒用STL~~（还不是是因为太弱）~~

我们可以用一个有两个元素的结构体来保存一个预约，如下：
```cpp
struct Plan{
	int l,r; //l,r分别表示预约开始,结束的时间
};
```

首先考虑A操作，由于STL的set有**相同元素只保留一个**的特性，因此我们不难想到令有冲突的预约相等，这样我们就可以很方便的用.find()这个函数来完成A操作了。

#### 怎么令它们相等呢？

其实也很简单，由于使用自定义数据类型的set要重载运算符，因此我们可以这样：
```cpp
struct Plan{
	int l,r;
	bool operator <(const Plan &rhs)const{
		return r<rhs.l;
	}
};
```
这样对于两个Plan类型的结构体a,b来说，a<b就代表a完全在b的左边，a>b就代表a完全在b的右边，a==b就代表a与b有冲突(有重叠部分)

对于B操作，直接输出set里元素的个数就好了

~~于是我们就可以快乐的A掉这道题了~~

有了上面的思路，代码也不难写出:
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<set>
using namespace std;
struct Plan{
	int l,r;
	bool operator <(const Plan &rhs)const{
		return r<rhs.l;
	}
};
int T;
set<Plan> s;
int main(){
	cin>>T;
	while(T--){
		char c; scanf(" %c",&c); //空格可以防止读入无效字符
		if(c=='A'){
			int l,r,cnt=0; scanf("%d %d",&l,&r);
			Plan tmp=(Plan){l,r};
            //删掉与该预约冲突的预约，并统计个数
			set<Plan>::iterator it=s.find(tmp);
			while(it!=s.end()){
				++cnt; s.erase(it);
				it=s.find(tmp);
			}
			s.insert(tmp);
			printf("%d\n",cnt);
		}
		else{
			printf("%d\n",s.size());
		}
	}
	return 0;
}
```
AC记录：[R14872282 评测详情](https://www.luogu.org/recordnew/show/14872282)

---

## 作者：Minclxc (赞：71)

看试炼场的树状数组进来的，但发现题解代码清一色的都是平衡树、线段树

这里加个小清新的树状数组代码，原理见最前面的题解

因为每个区间最多进队一次、出队一次，所以复杂度是O(nlognlogn)

```cpp
#include<cstdio>
using namespace std;
#define fo(a,b,c) for(int a=b;a<=c;a++)
#define go(a,b,c) for(int a=b;a>=c;a--)
int read(){
    int a=0,f=0;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')f=1;
    for(;c>='0'&&c<='9';c=getchar())a=a*10+c-'0';
    return f?-a:a;
}
int min(int a,int b){return a<b?a:b;}
int max(int a,int b){return a>b?a:b;}
const int N=100001;
int tree[N],end[N];
void add(int x,int c){
    for(;x<N;x+=x&-x)tree[x]+=c;
}//数组数组加
int ask(int x){
    int sum=0;
    for(;x;x&=x-1)sum+=tree[x];
    return sum;
}//数组数组求和
int main(){
    int n=read(),ans=0;
    fo(i,1,n){
        scanf("\n");
        if(getchar()=='A'){
            int del=0,st=read(),ed=read();
            for(int p;p=ask(ed);){
                int l=0,r=ed;
                for(;l<r;){
                    int m=(l+r)>>1;
                    if(ask(m)+1<=p)l=m+1;
                    else r=m;
                }//二分找到最后可能交叉的区间
                if(end[l]>=st)add(l,-1),del++,ans--;
                else break;
            }
            add(st,1);end[st]=ed;ans++;
            printf("%d\n",del);
        }
        else printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：地表最强男人 (赞：37)

## 这是解释树状数组题解的
因为大佬没有写注释，所以看的挺蒙的，但是其实思路是比较清楚的。

- 对于操作A，需要知道中间有多少区间是需要删除的，这个可以通过树状数组+二分来维护，用树状数组$c[i]$,维护以i为左端点的区间个数，然后每一次对于一个需要插入的区间$[l,r]$每一次二分查询到左端点在$0-r$最右的端点，然后判断当前的的区间是否有包含在我们要插入的大区间的部分，如果没有包含，那么剩下的区间一定也没有包含大区间的部分内。
- 这个是可以证明的，如果当前的左端点最右的区间$[l1,r1]$如果在左侧（如果不包含大区间的部分一定是在大区间的左端，因为我们枚举的左端点是从$0-r$的），即$r1<l$,假设还有一个区间$[l2,r2]$,$l2<l1$并且$r2>l$，那么这个区间$[l2,r2]$不可能和$[l1,r1]$同时存在（$l1>l2$且$r1<r2$）。
- 我们每一次查询最右边的端点只需要寻找$ask(mid)==ask(r)$的节点，即最右边的端点（如果以$0-mid$为左端点的区间个数刚好等于$0-r$为左端点的取区间的个数，那一定是最右边的）。然后删去就可以了，删去只需要用树状数组$add(mid,-1)$就可以了。然后一边统计删去的区间数。
- 记得记录一个全局变量ans，存储当前剩余的区间数
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int n,c[200010],ans=0,righ[200010];
const int N=200010;
void add(int x,int y)
{
        for(;x<=N;x+=(x&-x))
            c[x]+=y;
}
int ask(int x)
{
        int as=0;
        for(;x;x-=(x&-x))
            as+=c[x];
        return as;
}
int main()
{
        cin>>n;
        for(int i=1;i<=n;i++)
        {
            char temp;
            cin>>temp;
            if(temp=='A')
            {
                int st,ed,anss=0;
                cin>>st>>ed;			
                while(1)
                {
                    int l=0,r=ed;
                    while(l<r)
                    {
                        int mid=(l+r)>>1;
                        if(ask(mid)<ask(ed))
                            l=mid+1;
                        else
                            r=mid;
                    }
                    if(righ[l]>=st)
                    {
                        add(l,-1);
                        anss++;
                        ans--;
                    }
                    else
                        break;
                }
                add(st,1);
                righ[st]=ed,ans++;
                cout<<anss<<endl;
            }
            else
                cout<<ans<<endl;
        }	
        return 0;
}
```



---

## 作者：香风智乃 (赞：36)

https://www.luogu.org/problemnew/solution/P2161

这里有一种**不用二分，不用求贡献，并且每个节点只要存2个信息**的线段树代码。常数还算可以（开/不开O2：588ms/908ms），长度与其他线段树题解比也挺短的（76行）。

## 进入正题

先把题目看成一个仅实现**区间修改**的线段树，用$tag$数组打打标记即可 ~~这是基础啊对吧qwq~~

为了方便~~我描述~~理解，以下把**预约序号**看成**颜色**

------
A操作的真实目的：查询一个区间中有多少种颜色，然后清空数列中所有在该区间中出现的颜色，最后把这个区间修改成另一种颜色
（先别急着看B操作qwq）

简而言之就是**查询->清空->修改**

对于**查询**操作，我们可以引入$find$函数和$same$数组。$find$函数的职能是**遍历**给定区间。当$same[o]==1$时，该区间内只有一种颜色，这时就可以得知该区间的颜色了；否则继续向下遍历。

对于**清空**操作：其实不用真的清空，只需要引入一个$del$数组，存储该颜色是否已被删除即可

对于**修改**，不在话下~~这是基础啊对吧qwq~~

------
对于B操作.....，用一个$ans$储存还剩几种颜色未被删除，~~然后就没有然后了~~

-----
应该在线离线都支持，不过离线的话可以用$st,ed$存线段树的左右端点，建的树小（当然在线的话直接开到最大对吧）

复杂度大概$O(nlogn)$吧~~原谅我不太会算（逃~~

tips：数据有锅，请不要使用读入/输出优化，读入字符用字符串（除非你很有自信）~~TLE的切身经历QAQ~~

代码如下（我也知道我讲的不清楚QAQ所以还是看吧）
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

inline int min(const int &a,const int &b) {return a<b ?a:b;}
inline int max(const int &a,const int &b) {return a>b ?a:b;}

const int maxn=400002;
struct data{
	char opt[2]; int l,r;
}a[200002];
int tag[maxn];
bool del[maxn],same[maxn];
int st=1e9,ed,n,x0,y0,v,ans,era;

inline void pushdown(int o,int l,int r) //标记下传
{
	same[o]=0; //能下传说明这个区间一定不是同色
	if(!tag[o]) return ;
	int lc=o<<1,rc=o<<1|1;
	tag[lc]=tag[rc]=tag[o];
	tag[o]=0; 
}
inline void build(int o,int l,int r)//普通的建树
{
	same[o]=1; tag[o]=0; //记得初始化：刚开始的树无修改标记且整棵树都只有一个颜色（无色==0）
	if(l==r) return ;
	int lc=o<<1,rc=o<<1|1,mid=l+((r-l)>>1);
	build(lc,l,mid); build(rc,mid+1,r);
}
inline void find(int o,int l,int r)
{
	if(same[o]==1)
	{
		if(!del[tag[o]]&&tag[o]) --ans,++era; //用ans记录还剩几种颜色，era记录这次删除了几种颜色（注意判无色）
		del[tag[o]]=1; //删除
		tag[o]=v;
		return ;
	}
	int lc=o<<1,rc=o<<1|1,mid=l+((r-l)>>1);
	find(lc,l,mid); find(rc,mid+1,r);
	tag[o]=v; same[o]=1; //该区间内都是同色
}
inline void modify(int o,int l,int r)//普通的区间修改
{
	if(x0<=l&&r<=y0) {find(o,l,r); return ;} //加入一个find函数对所求区间进行更深一层的遍历
	pushdown(o,l,r);
	int lc=o<<1,rc=o<<1|1,mid=l+((r-l)>>1);
	if(x0<=mid) modify(lc,l,mid);
	if(y0>mid) modify(rc,mid+1,r);
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%s",a[i].opt);
		if(a[i].opt[0]=='B') continue;
		scanf("%d%d",&a[i].l,&a[i].r);
		st=min(st,a[i].l); ed=max(ed,a[i].r);
	}
	build(1,st,ed);
	int cnt=0; //cnt：当前颜色的标号
	for(int i=1;i<=n;++i)
	{
		if(a[i].opt[0]=='A')
		{
			++ans; x0=a[i].l; y0=a[i].r; v=++cnt; era=0;
			modify(1,st,ed); 
			printf("%d\n",era);
		}else printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：Melacau (赞：19)

[http://www.cnblogs.com/Melacau/p/luogu2161.html](http://www.cnblogs.com/Melacau/p/luogu2161.html)


# ** fhq treap 无旋treap **


##解题思路


题意就是叫你维护一条时间轴，支持2种操作:


1)删除当前时间轴上所有与新区间有交的区间输出删除个数，然后插入新区间。


2)查询当前时间轴上的区间个数。

很容易考虑到将所有的区间按照两个端点双关键字排序(先左还是右没有什么影响)。


当插入一个区间时，和之前的几位dalao所说的一样，我们找到最后一个在新区间之前与新区间无交的区间与第一个在新区间后与新区间无交的区间，然后计算它们之间的区间个数，返回后删除，再插入新区间。


查询就直接查询时间轴上的区间个数。

## 无旋treap(fhq treap)实现方法


首先，我们需要支持查找前驱和查找后继的操作，这是平衡树基础操作，不多赘述。接下来对于找到的前驱与后继的位置，我们在此执行split操作，将整棵treap分为3部分，即为删去的各区间之前，删去的区间，删去的区间之后，然后返回的个数直接就是删去区间这一部分的root的size，然后再插入新区间后直接与删去区间之前与删去区间之后合并即可。


操作2就直接返回整棵treap的root的size即可。


因为时间效率是稳定的\(  O( n \log n ) \)，所以相对比用set的快些。目前是Rank1

```cpp
#include <stdio.h>
#define r register
#define getchar() (S==TT&&(TT=(S=BB)+fread(BB,1,1<<15,stdin),TT==S)?EOF:*S++)
char BB[1<<15],*S=BB,*TT=BB;
inline int in(){
    r int x=0; r bool f=0; r char c;
    for (;(c=getchar())<'0'||c>'9';f=c=='-');
    for (x=c-'0';(c=getchar())>='0'&&c<='9';x=(x<<3)+(x<<1)+c-'0');
    return f?-x:x;
}  
namespace Treap{
    inline int Rand(){
        static int x=23333;
        return x^=x<<13,x^=x>>17,x^=x<<5;
    }
    struct task{int lt,rt;};
    struct node{
        node *ls,*rs;task v;int pri,sz;
        node(task a):v(a){ls=rs=NULL;pri=Rand();sz=1;}
        inline void up(){sz=(ls?ls->sz:0)+(rs?rs->sz:0)+1;}
    }*root;
    struct Droot{node *a,*b;};
    inline int Size(node *x){return x?x->sz:0;}
    node *merge(node *a,node *b){\\合并操作
        if (!a) return b;
        if (!b) return a;
        if (a->pri<b->pri){
            a->rs=merge(a->rs,b);
            a->up();return a;
        }else{
            b->ls=merge(a,b->ls);
            b->up();return b;
        }
    }
    Droot split(node *a,int k){\\分离操作
        if (!a) return (Droot){NULL,NULL};
        r Droot y;if (Size(a->ls)>=k){
            y=split(a->ls,k);
            a->ls=y.b;a->up();y.b=a;
        }else{
            y=split(a->rs,k-Size(a->ls)-1);
            a->rs=y.a;a->up();y.a=a;
        }return y;
    }
    int find_pre(node *x,task a){\\查找前驱
        if (!x) return 0;
        if (x->v.rt<a.lt) return find_pre(x->rs,a)+Size(x->ls)+1;
        return find_pre(x->ls,a);
    }
    int find_nxt(node *x,task a){\\查找后继
        if (!x) return 0;
        if (x->v.lt>a.rt) return find_nxt(x->ls,a);
        return find_nxt(x->rs,a)+Size(x->ls)+1;
    }
    inline int new_task(){
        r task a;a.lt=in(),a.rt=in();
        r int L=find_pre(root,a),R=find_nxt(root,a);
        r Droot y=split(root,R);r Droot x=split(y.a,L);
        r int ans=Size(x.b);r node *newd=new node(a);
        root=merge(merge(x.a,newd),y.b);return ans;
    }
    inline int Get_Ans(){return Size(root);}
}
int main(){
    int q=in();while(q--){
        char op=getchar(); while(op!='A'&&op!='B') op=getchar();
        if (op=='A') printf("%d\n",Treap::new_task());
        else printf("%d\n",Treap::Get_Ans());
    }
}
```

---

## 作者：凄魉 (赞：14)

看到好多平衡树的题解蒟蒻内心是崩溃的，看到这道题完全不会用平衡树只会用线段树染色…………

对于每一个预订操作，我们发现需要将这一段区间内原有的预约去掉，并且将这次预定的区间染上色。所以我们想要知道这样一个信息：对于这一段区间内的所有预约，最早是从什么时候开始的（记为ml） 以及 最晚在什么时候结束（记为mr）。这样子每次操作我们先把ml~mr区间染上0的颜色标记为没有设置预约，再把这一次预定的区间染成这一次预约的颜色。

所以我们的线段树的每个节点需要记录五个信息：区间内预约个数cnt，区间预约最早开始时间ml，区间预约最晚结束时间mr，区间左端点颜色lc，区间右端点颜色rc（用以区间合并时求解预约个数）。

由于我的写法中 颜色0表示为空置、没有预定预约，这样在线段树打标记的时候需要分类讨论 本次操作为染成0色 还是 预定预约。以及在合并区间的时候是否为0色的小细节需要仔细考虑一下。
```cpp
#include<cstdio>
#define N 100200
#define ls i<<1
#define rs i<<1|1
int min(int a,int b) {return a>b?b:a;}
int max(int a,int b) {return a>b?a:b;}
struct data{
	int cnt,ml,mr,lc,rc;
	data operator + (const data &b) {return (data){(cnt&&b.cnt)?cnt+b.cnt-(rc&&(rc==b.lc)):cnt+b.cnt,min(ml,b.ml),max(mr,b.mr),lc,b.rc};}
	void clear() {ml=mr=lc=rc=cnt=-1;}
};
struct segmenttree{
	data tree[N<<3],tag[N<<3];
	void pushdown(int i)
	{
		if (!~tag[i].cnt) return;
		tree[ls].lc=tree[ls].rc=tree[rs].lc=tree[rs].rc=tag[i].cnt;
		if (tag[i].cnt)
		{
			tree[rs].cnt=tree[ls].cnt=1;
			tree[rs].ml=tree[ls].ml=tag[i].ml;
			tree[rs].mr=tree[ls].mr=tag[i].mr;
			tag[ls]=tag[rs]=tag[i];
		}
		else
		{
			int mid=(tag[i].ml+tag[i].mr)>>1;
			tree[rs].cnt=tree[ls].cnt=0;
			tree[ls].ml=tag[i].ml;
			tree[rs].ml=mid+1;
			tree[rs].mr=tag[i].mr;
			tree[ls].mr=mid;
			tag[ls]=tag[rs]=tag[i];
			tag[ls].mr=mid;tag[rs].ml=mid+1;
		}
		tag[i].clear();
	}
	void update(int i,int l,int r,int L,int R,int c)
	{
		if (L<=l&&r<=R)
		{
			tree[i].lc=tree[i].rc=c;
			tag[i].cnt=c;
			if (c)
			{
				tree[i].cnt=1;
				tree[i].ml=L;tree[i].mr=R;
				tag[i].ml=L;tag[i].mr=R;
			}
			else
			{
				tree[i].cnt=0;
				tree[i].ml=l;tree[i].mr=r;
				tag[i].ml=l;tag[i].mr=r;
			}
			return;
		}
		int mid=(l+r)>>1;
		pushdown(i);
		if (L<=mid) update(ls,l,mid,L,R,c);
		if (mid<R) update(rs,mid+1,r,L,R,c);
		tree[i]=tree[ls]+tree[rs];
	}
	data query(int i,int l,int r,int L,int R)
	{
		if (L<=l&&r<=R) return tree[i];
		pushdown(i);
		int mid=(l+r)>>1;
		if (mid<L) return query(rs,mid+1,r,L,R);
		if (mid>=R) return query(ls,l,mid,L,R);
		return query(ls,l,mid,L,mid)+query(rs,mid+1,r,mid+1,R);
	}
	void build(int i,int l,int r)
	{
		tag[i].clear();
		if (l==r)
		{
			tree[i].cnt=0;
			tree[i].lc=tree[i].rc=0;
			tree[i].ml=tree[i].mr=l;
			return;
		}
		int mid=(l+r)>>1;
		build(ls,l,mid);build(rs,mid+1,r);
		tree[i]=tree[ls]+tree[rs];
	}
}cof;
int main()
{
	int n,l,r;char a;
	scanf("%d",&n);
	cof.build(1,1,100000);
	while(n--)
	{
		while(a=getchar()) if (a=='A'||a=='B') break;
		if (a=='A')
		{
			scanf("%d%d",&l,&r);
			data tmp=cof.query(1,1,100000,l,r);
			printf("%d\n",tmp.cnt);
			cof.update(1,1,100000,tmp.ml,tmp.mr,0);
			cof.update(1,1,100000,l,r,n);
		}
		else
		{
			data tmp=cof.query(1,1,100000,1,100000);
			printf("%d\n",tmp.cnt);
		} 
	}
	return 0;
}
```

---

## 作者：alicealice (赞：12)

#### 线段树染色~~板子题~~
##### 前面的dalao们已经讲的很清楚了。

‘A’操作要执行两个动作：查询区间[x,y]内的颜色个数，将区间[x,y]染色，分别对应着query和update函数

‘B'操作则是返回整个区间的颜色个数，直接输出就行了

#### 说一下变量
##### t：它是用来维护线段树，有三种不同状态

-1：管辖区间内有多个不冲突的预约或者区间只有一个预约但其没有覆盖整个区间；

0：无预约；

k(k>=1)：有一个标号是k的预约

##### ans： 整个区间有效的预约个数

##### cnt： 每次 'A' 操作要删除掉的预约个数

##### vis： vis[i]表示标号为i的预约被拒绝了,防止加上要拒绝的预约


~~然后就没了~~
```cpp
//头文件太长，删了qwq
#define mid (s+e>>1)
#define ls(x) x<<1
#define rs(x) x<<1|1
using namespace std;
const int N = 200010;
int t[N << 2];
int tag[N << 2];
bitset<N> vis;
int ans, cnt;
inline void pushdown(int p, int s, int e)
{
	if (!tag[p])return;
	tag[ls(p)] = tag[rs(p)] = tag[p];
	t[ls(p)] = t[rs(p)] = tag[p], tag[p] = 0;
}
void update(int p, int s, int e, int l, int r, int v)
{
	if (l <= s && e <= r)
		tag[p] = t[p] = v;
	else
	{
		pushdown(p, s, e);
		if (l <= mid)
			update(ls(p), s, mid, l, r, v);
		if (r > mid)
			update(rs(p), mid + 1, e, l, r, v);
		if (t[ls(p)] == t[rs(p)]) //左右儿子不管什么颜色，只要不同就是-1；
			t[p] = t[ls(p)];//相同就随便选一个
		else
			t[p] = -1;
	}
}
void query(int p, int s, int e, int l, int r)
{
	if (l <= s && e <= r)
	{
		if (!t[p])return;
		if (t[p] < 0)//区间内存在多个预约就继续下传标记
		{
			pushdown(p, s, e);
			if(l<=mid)query(ls(p), s, mid, l, r);
			if (r > mid)query(rs(p), mid + 1, e, l, r);
		}
		else
		{
			if (!vis[t[p]])
				ans--, vis[t[p]] = 1, cnt++;
		}
	}
	else
	{
		pushdown(p, s, e);
		if (l <= mid)query(ls(p), s, mid, l, r);
		if (r > mid)query(rs(p), mid + 1, e, l, r);
	}
}
int main()
{
	int n, tmp, m, len;
	int x, y;
	char op;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
	{
		scanf(" %c", &op);
		if (op == 'A')
		{
			scanf("%d%d", &x, &y);
			query(1, 1, 200000, x, y);
			printf("%d\n", cnt);
			cnt = 0;//记得重置
			update(1, 1, 200000, x, y, i);
			ans++;//因为刚刚又对[x,y]染了色，所以要+1
		}
		else
			printf("%d\n", ans);
	}
	return 0;
}



---

## 作者：素质玩家孙1超 (赞：9)

看到没有题解是用vector做的，所以就来发个题解


题外话：我的代码暂时最优解第三  ~~（我笑爆）~~

说是用vector其实是vector充当平衡树

即动态维护一个单调不降的vector

代码不像自己写的那么长，也没有set那么无脑

### 正题

因为要先动态维护一个单调不降的vector,所以我们重载小于号,我们定义对于两个区间 $X,Y$，如果有$X.r<Y.l$ （两个区间没有交点,且$Y$在$X$的右边）则$X<Y$

代码:

```cpp
struct Range
{
	int l,r;
	bool operator <(const Range &x)const
	{
        return r<x.l;
    }
};
```

显然 若$X>Y$ 与$X<Y$同时不成立,那么$X$与$Y$有交集

对于第一个操作我们每次删除与$X$有交点的

即删除区间$X$的前驱（第一个不小于$X$的）到$X$的后继

(第一个大于$X$的)的前一个

即
```cpp
a.erase(lower_bound(a.begin(),a.end(),X),
	upper_bound(a.begin(),a.end(),X));//erase左闭右开
```

然后将这个区间插到vector里

```cpp
a.insert(lower_bound(a.begin(),a.end(),X),X);
```

第二个操作就直接输出$a.size()$就好了

---

代码（也许有点丑，但好理解）~~别忘记点赞~~

```cpp
#include<bits/stdc++.h>
#define Wl(x) {W(x);puts("");}
using namespace std;
inline int R()
{
	char c;int res;
	while((c=getchar())>'9'||c<'0');res=c-'0';
	while((c=getchar())>='0'&&c<='9') res=res*10+c-'0';
	return res;
}
void W(int x)
{
	if(x>9) W(x/10);
	putchar('0'+x%10);
}//以上为读入输出优化 
struct Range
{
	int l,r;
	bool operator <(const Range &x)const
	{
        return r<x.l;
    }
}A;//定义结构体 
vector<Range>a;int n;
int main()
{
	n=R();char op;int l,r;
	for(int i=1;i<=n;i++)
	{
		while((op=getchar())!='A'&&op!='B');
		if(op=='A')
		{
			A.l=R();A.r=R();
			l=lower_bound(a.begin(),a.end(),A)-a.begin();//前驱 
			r=upper_bound(a.begin(),a.end(),A)-a.begin();//后继 
			Wl(r-l); 
			a.erase(a.begin()+l,a.begin()+r);
			a.insert(a.begin()+l,A);
		}
		else Wl(a.size());
	}
}
```


---

## 作者：Bring (赞：9)

人生第一次不看题解过紫题（愉悦）

# ~~传播分块邪恶思想~~

~~其实只是线段树什么的不会打啊摔~~

因为不知道输入startend的最大位置，所以直接把100000个位置分成316个块块（也就是sqrt(100000)）

### 现在需要一些记录重要信息的数组和变量：

b[i]：第i号位置属于b[i]号块块

f[i]：第i号块块的第一个位置是f[i]

**c[i]：如果i号为一个时间点的开头，那么c[i]表示这个位置的结尾，否则c[i]=0**

**h[i]：第i号块块中c[i]!=0的i的数量，就是第i号块块包含的起点个数**

ans：每一次A操作删除会议计数

tot：剩余有效会议计数，用于B操作

l：~~毒瘤优化~~目前用到的最左的块块

## 流程

关于一个A操作，会输入x,y表示开始和结束

如果x,y属于一个块块，那么i直接从x到y暴力扫有没有c[i]!=0，有就删掉

~~否则就比较麻烦了~~

首先被x,y所夹的完整块块都不能存活，使用memset清除之间的c[i]，在i从b[x]+1到b[y]-1扫掉所有的h[i]

然后暴力扫x所在块块中x到最后清除c[i]，y所在块块中开头到y清除c[i]即可

### 不还没有结束

万一出现开始比x早，结束又比x晚的会议怎么办呢

根据题意不能有冲突会议

所以只需从x往前找到第一个c[i]!=0，然后判断c[i]是否>=0即可，其他的不用管

## 代码

函数clr(i)清除c[i]并记录答案
```cpp
inline void clr(int i){--h[b[i]],c[i]=0,++ans,--tot;}
```

函数wrk()处理x左边c[i]情况
```cpp
inline void wrk(){
	if(h[b[x]]){
		Frn_(i,x-1,f[b[x]])if(c[i]){
    		if(c[i]>=x)clr(i);
            return;
		}
	}
	Frn_(i,b[x]-1,l)if(h[i])Frn_(j,f[i+1]-1,f[i])if(c[j]){
		if(c[j]>=x)clr(j);
		return;
	}
}
```
完整代码
```cpp
//This program is written by Bring.
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define Rd(a) (a=read())
inline int read(){
    register int x;register char c(getchar());register bool k;
    while((c<'0'||c>'9')&&c^'-')if((c=getchar())==EOF)exit(0);
    if(c^'-')x=c&15,k=1;else x=0,k=0;
    while(c=getchar(),c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c&15);
    return k?x:-x;
}
void wr(register int a){
    if(a<0)putchar('-'),a=-a;
    if(a<=9)putchar(a|'0');
    else wr(a/10),putchar((a%10)|'0');
}
#define Ps putchar(' ')
#define Pe putchar('\n')
#define Frn0(i,a,b) for(register int i(a);i<(b);++i)
#define Frn1(i,a,b) for(register int i(a);i<=(b);++i)
#define Frn_(i,a,b) for(register int i(a);i>=(b);--i)
#define Fre(a,i) for(register int i(hd[a]);i;i=nxt[i])
#define Mst(a,b) memset(a,b,sizeof(a))
#define INF signed(0x3f3f3f3f)
#define NINF signed(0xc3c3c3c3)
#define File(a) freopen(a".in","r",stdin),freopen(a".out","w",stdout)
#define N (100001)
#define T (316)
int n,x,y,l,tot,b[N]{-1},c[N],f[N/T+10],h[N/T+10],ans;
char o;
inline void clr(int i){--h[b[i]],c[i]=0,++ans,--tot;}
inline void wrk();
signed main(){
    Frn0(i,1,N)if((b[i]=i/T)!=b[i-1])f[l=b[i]]=i;
    f[++l]=N,Rd(n);
    while(n--){
        while(o=getchar(),o^'A'&&o^'B');
        if(o=='A'){
            Rd(x),Rd(y),ans=0;
            if(b[x]==b[y]){Frn1(i,x,y)if(c[i])clr(i);}
            else{
            	memset(c+f[b[x]+1],0,sizeof(int)*(f[b[y]]-f[b[x]+1]));
            	Frn0(i,b[x]+1,b[y])ans+=h[i],tot-=h[i],h[i]=0;
            	Frn0(i,x,f[b[x]+1])if(c[i])clr(i);
				Frn1(i,f[b[y]],y)if(c[i])clr(i);
			}
			if(l<=b[x])wrk();else l=b[x];
			wr(ans),Pe,c[x]=y,++h[b[x]],++tot;
        }else wr(tot),Pe;
    }
    exit(0);
}
inline void wrk(){
	if(h[b[x]]){
		Frn_(i,x-1,f[b[x]])if(c[i]){
    		if(c[i]>=x)clr(i);
            return;
		}
	}
	Frn_(i,b[x]-1,l)if(h[i])Frn_(j,f[i+1]-1,f[i])if(c[j]){
		if(c[j]>=x)clr(j);
		return;
	}
}
```
时间O(n*sqrt(n))，空间O(n)

评测：用时: 635ms / 内存: 1412KB（好像比线段树还快~~神奇~~）

---

## 作者：henry_y (赞：8)

非指针版本。思路和楼下同样用fhqtreap的题解是一样的，不过他用的是指针我这个没用指针，并且写法的细节处有很多不同。

[同步于$blog$](https://www.cnblogs.com/henry-1202/p/10465543.html)

用fhqtreap对区间进行维护。

可以注意到的是，对于当前存在的预约，他们一定是升序排列的（有重叠的都被删了）。

那么就可以用按照位置分裂的fhqtreap搞了（预约无论按l还是按r都必定是升序的）。

每次插入一个区间的时候，就直接找出互不重叠的前驱和后继，那么需要删除的就是中间的那一段了(因为区间升序)，对于每一个A的答案就是中间那段的siz，合并的时候注意一下顺序就好，别把顺序颠倒了（无论是merge还是split）。

对于B询问，答案就是root的siz。

```cpp
#include <cstdio>
#include <algorithm>
#include <cstdlib>
#include <ctime>
#define ll long long
using namespace std;

const int N = 200010;

struct task { int l, r; };
struct fhq { int l, r, siz, rnd; task v; }t[N];
int tot, root;

#define lc (t[rt].l)
#define rc (t[rt].r)
void up(int rt) { t[rt].siz = t[lc].siz + t[rc].siz + 1; } 
void split(int rt, int &l, int &r, int k) {
	if(!k) l = 0, r = rt;
	else if(t[rt].siz == k) l = rt, r = 0;
	else if(k <= t[lc].siz) r = rt, split(lc, l, lc, k), up(rt);
	else l = rt, split(rc, rc, r, k - t[lc].siz - 1), up(rt);
}
void merge(int &rt, int l, int r) {
	if(!l || !r) rt = l + r;
	else if(t[l].rnd < t[r].rnd) rt = l, merge(rc, rc, r), up(rt);
	else rt = r, merge(lc, l, lc), up(rt);
}
int pre(int rt, task a) {
	if(!rt) return 0;
	if(t[rt].v.r < a.l) return pre(rc, a) + t[lc].siz + 1;
	else return pre(lc, a);
}
int nxt(int rt, task a) {
	if(!rt) return 0;
	if(t[rt].v.l > a.r) return nxt(lc, a);
	else return nxt(rc, a) + t[lc].siz + 1;
}
int new_node(task a) {
	t[++tot].v = a;
	t[tot].siz = 1;
	t[tot].rnd = rand()<<15|rand();
	t[tot].l = t[tot].r = 0;
	return tot;
}
int build(task a) {
	int l = pre(root, a), r = nxt(root, a), x, y, z, k;
	split(root, x, y, r); split(x, z, k, l);
	int ans = t[k].siz, t = new_node(a);
	merge(t, z, t); merge(root, t, y); return ans;
}
#undef lc
#undef rc

int main() {
#ifndef ONLINE_JUDGE
freopen("test.in","r",stdin);
freopen("t.out","w",stdout);
#endif
	srand((unsigned)time(0));
	int T; task a; char ch[10];
	scanf("%d", &T);
	while(T--) {
		scanf("%s", ch);
		if(ch[0] == 'A') scanf("%d%d", &a.l, &a.r), printf("%d\n", build(a));
		else printf("%d\n", t[root].siz);
	}
	return 0;
}
```

---

## 作者：TsReaper (赞：8)

当读入一个新的预约时，不断查找已经存在的预约中end值大等于新预约start值，并且最接近该start值的预约，找到一个删除一个，直到不能删除为止。因为不冲突的预约都是不相互覆盖的，所以它们的start值与end值必然是递增序列，所以一旦一个预约不能删除，后面的预约也不能删除。

这样，问题就转换成了：寻找最小的比给定的数x大的数。该问题解法非常多，这里写得非常不错：http://www.cnblogs.com/wuyiqi/archive/2011/12/25/2301071.html

当然，这个问题除了用树状数组以及平衡树，线段树也是可以做的。思想仍然是二分。本题可以做为k大数的模版题。


---

## 作者：xukuan (赞：8)

怎么又是恶意评分？？？橙题一道。

这题是平衡树，不过……

## 如果一题考了平衡树，先想想set能不能用！

这题能用！

思路：

输入的是A操作：将数组中的元素按一个右端点与另一个的左端点排序，有问题的直接拍掉

输入的是B操作：输出集合的长度

代码连注释都省了，直白的很
```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
#define it iterator
using namespace std;

struct node{
    ll l,r;
    inline bool operator <(const node &x) const{
        return r<x.l;
    }
};
ll n;
set<node> s;

int main(){
    cin>>n;
    while(n--){
        string op;
        cin>>op;
        if(op=="A"){
            ll l,r,ans=0;
            scanf("%lld %lld",&l,&r);
            node x=(node){l,r};
            set<node>::it i=s.find(x);
            while(i!=s.end()){
                ans++;
                s.erase(i);
                i=s.find(x);
            }
            s.insert(x);
            printf("%lld\n",ans);
        }
        else printf("%lld\n",(ll)s.size());
    }
    return 0;
}
```

---

## 作者：Log_x (赞：7)

##Splay 伸展树

楼下思路已经讲的很清楚了，这里主要是因为用了Splay（蒟蒻表示不会fhq Treap）。

**A 操作：**

Splay的查前驱后继就不多说了，删除与当前区间相交的所有区间可以用类似于提取序列区间的方法来搞：

先把前驱旋到根节点，再把后继旋到根节点的右子节点，那么后继的左子树即为被删除所有区间的集合，然后直接砍掉这条边，并返回后继左子树的大小。

**B 操作：**

和fhq Treap 一样，返回当前平衡树的大小。

最后附上**代码**，Splay目前379ms（奇迹般Rank1）：












```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int Maxn = 0x3f3f3f3f;
const int N = 2e5 + 5;
int lc[N], rc[N], fa[N], sze[N], fl[N], fr[N];
int rt, Q, T;
inline int get()
{
    char ch; bool f = false; int res = 0;
    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');
    if (ch == '-') f = true;
     else res = ch - '0';
    while ((ch = getchar()) >='0' && ch <= '9')
        res = (res << 3) + (res << 1) + ch - '0';
    return f? ~res + 1 : res;
}
inline void put(int x)
{
    if (x < 0)
      x = ~x + 1, putchar('-');
    if (x > 9) put(x / 10);
    putchar(x % 10 + 48);
}
inline bool Wrt(const int x) {return rc[fa[x]] == x;}
inline void Push(const int x) {sze[x] = sze[lc[x]] + sze[rc[x]] + 1;}
inline void Rot(const int x)
{
    int y = fa[x], z = fa[y];
    int b = (lc[y] == x ? rc[x] : lc[x]);
    fa[x] = z; fa[y] = x;
    if (b) fa[b] = y;
    if (z) (lc[z] == y ? lc[z] : rc[z]) = x;
    if (lc[y] == x) rc[x] = y, lc[y] = b;
     else lc[x] = y, rc[y] = b;
    Push(y);
}
inline void Splay(const int x, const int tar)
{
    while (fa[x] != tar)
    {
        if (fa[fa[x]] != tar)
         Wrt(x) == Wrt(fa[x]) ? Rot(fa[x]) : Rot(x);
        Rot(x);
    }
    Push(x);
    if (!tar) rt = x;
}
inline void Ins(const int str, const int edt)
{
    int x = rt, y = 0, dir;
    while (x)
    {
        ++sze[y = x];
        if (str < fl[x]) x = lc[x], dir = 0;
         else x = rc[x], dir = 1;
    }
    fl[x = ++T] = str; fr[x] = edt; sze[x] = 1; fa[x] = y;
    if (y) (dir == 0 ? lc[y] : rc[y]) = x;
    Splay(x, 0);
}
inline int Pre(const int str)
{
    int x = rt, pr;
    while (x)
    {
        if (fr[x] < str) pr = x, x = rc[x];
         else x = lc[x];
    }
    return pr;
}
inline int Suf(const int edt)
{
    int x = rt, sf;
    while (x)
    {
        if (fl[x] > edt) sf = x, x = lc[x];
         else x = rc[x];
    }
    return sf;
}
inline int Que(const int str, const int edt)
{
    int tx = Pre(str), ty = Suf(edt);
    Splay(tx, 0); Splay(ty, tx); int tz = lc[ty];
    lc[ty] = fa[tz] = 0; Push(ty); Push(tx);
    return sze[tz];
}
int main()
{
    Ins(-Maxn, -Maxn); Ins(Maxn, Maxn); 
    // 树中可能只有一个节点，因此要设立首尾哨兵 
    Q = get(); char tp;
    while (Q--)
    {
        while ((tp = getchar()) != 'A' && tp != 'B');
        if (tp == 'A') 
        {
            int u = get(), v = get();
            put(Que(u, v)), putchar('\n');
            Ins(u, v);
        }
        else put(sze[rt] - 2), putchar('\n');
        // 最后计算的时候当然也要扣除哨兵 
    }
    return 0;
}
```

---

## 作者：青烟绕指柔 (赞：6)

我和大家的做法感觉有一些区别，然后就来发题解了QAQ。

首先我们要知道，满足什么性质的线段，才与当前这个插入的线段有交集呢？

那就是：线段的左端点在[1,R]，但是线段的右端点大于L，所以，我们直接把线段的左端点当成下标，值当成R，插入到线段树当中即可。然后删除操作：只要在区间[1,R]，并且区间max大于等于当前插入的线段的左端点，那么就去删除即可。

同时线段树维护一下元素个数。

AC代码：
```cpp
#pragma GCC optimize("-Ofast","-funroll-all-loops")
#include<bits/stdc++.h>
//#define int long long
using namespace std;
const int N=1e5+10;
int n,m=1e5,mx[N<<2],sum[N<<2],s;	char op[5];
inline void push_up(int p){
	mx[p]=max(mx[p<<1],mx[p<<1|1]);
	sum[p]=sum[p<<1]+sum[p<<1|1];
}
void change(int p,int l,int r,int x,int v){
	if(l==r){mx[p]=v,sum[p]=1;	return ;}
	int mid=l+r>>1;
	if(x<=mid)	change(p<<1,l,mid,x,v);
	else change(p<<1|1,mid+1,r,x,v);
	push_up(p);
}
void del(int p,int l,int r,int ql,int qr,int v){
	if(mx[p]<v)	return ;
	if(l==r){mx[p]=sum[p]=0;	return ;}
	int mid=l+r>>1;
	if(qr<=mid)	del(p<<1,l,mid,ql,qr,v);
	else if(ql>mid)	del(p<<1|1,mid+1,r,ql,qr,v);
	else del(p<<1,l,mid,ql,mid,v),del(p<<1|1,mid+1,r,mid+1,qr,v);
	push_up(p);
}
signed main(){
	cin>>n;
	for(int i=1,l,r;i<=n;i++){
		scanf("%s",op);
		if(op[0]=='A'){
			scanf("%d %d",&l,&r);	s=sum[1];	del(1,1,m,1,r,l);
			printf("%d\n",s-sum[1]);	change(1,1,m,l,r);
		}else printf("%d\n",sum[1]);
	}
	return 0;
}

```


---

## 作者：mrwalking (赞：5)

提供 set 的一种写法，难点在于 lower\_bound在结构体中的应用。本写法相对来说，更容易理解，希望，大家对程序进行跟踪理解。

```cpp
#include <cstdio>
#include <set>
using namespace std;
struct node{
    int left,right;
    bool operator<(const node &v)const{//1 此处写成 bool operator<(const node &v)
        if(right==v.right)
            return left<v.left;
        return right<v.right;
    }
};
set<node> s;
int main(){
    int n,i,cnt,left,right;
    char cmd[5];
    set<node>::iterator it;
    scanf("%d",&n);
    for(i=1;i<=n;i++){
        scanf("%s",cmd);
        if(cmd[0]=='A'){
            scanf("%d%d",&left,&right);
            cnt=0;
            while(1){
                it=s.lower_bound((node){0,left});//建议读者画图理解该句，整个程序中最核心的代码，也是最难写得代码//1 此处写成  it=s.lower_bound(node{0,left});
                if(it!=s.end()&&right>=it->left){
                    s.erase(it);
                    cnt++;
                    continue;
                }
                s.insert((node){left,right});//1 此处写成 s.insert(node{left,right});
                break;
            }
            printf("%d\n",cnt);
        }else
            printf("%d\n",s.size());
    }
    return 0;
}

```

---

## 作者：Jμdge (赞：4)

板子题。默默水一波FHQ...

FHQ 很不错啊！（稳稳T了三个点），于是一波 O2 强行水过，然后准备补线段树。

基本操作，merge 、split 足矣。

顺便打个广告：[FHQ treap 详解](https://www.cnblogs.com/Judge/p/9506980.html)

```cpp
//by Judge
#include<iostream>
#include<cstdio>
using namespace std;
const int M=2e5+111;
///////////////////////////////////// 非常长的读优输优
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){
	int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} inline int cread(){ char c=getchar(); while(!isupper(c)) c=getchar(); return c=='A'; }
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(int x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
////////////////////////////////////////然后是板子
int cnt,root;
struct node{ int key,val[2],ch[2],siz; }t[M];
inline int Rand(){ int seed=703; return seed=int(seed*48271ll%(~0u>>1)); }
inline void update(int u){ t[u].siz=t[t[u].ch[0]].siz+t[t[u].ch[1]].siz+1; }
inline int newnode(int L,int R){ t[++cnt].siz=1,t[cnt].val[0]=L,t[cnt].val[1]=R,t[cnt].key=Rand(); return cnt; }
int merge(int u,int v){
	if(!u || !v) return u|v;
	if(t[u].key<t[v].key) {t[u].ch[1]=merge(t[u].ch[1],v),update(u); return u; }
	else {t[v].ch[0]=merge(u,t[v].ch[0]),update(v); return v; }
} void split(int now,int k,int& x,int& y,int opt){ //明明就不用查前驱后继的呀，权值split
	if(!now) return (void)(x=y=0);
	if(t[now].val[opt]<k) split(t[x=now].ch[1],k,t[now].ch[1],y,opt);
	else split(t[y=now].ch[0],k,x,t[now].ch[0],opt); update(now);
}
signed main(){
	for(int n=read(),opt,x,y,a,b,c;n;--n){ opt=cread(); //强行骚压行
		if(opt) x=read(),y=read(),split(root,y+1,a,c,0),split(a,x,a,b,1),
			print(t[b].siz),b=newnode(x,y),root=merge(merge(a,b),c);
		else print(t[root].siz);
	}Ot(); return 0;
}
```

---

## 作者：GoldenPotato137 (赞：4)

蒟蒻博客传送门:[P2161](http://www.cnblogs.com/GoldenPotato/p/8981895.html)


------------

##   splay


~~的确有线段树/树状数组的做法,但我做的时候脑残没想到~~

我们可以考虑写一个类似NOIP2017D2T3列队那道题那样的带分裂的平衡树

考虑用splay维护每一条线段的左端点和右端点

因为我们题目的意思保证了在平衡树里的线段不相交,所以我们可以考虑以下的性质

 

每一条线段作为一个点放入平衡树中,维护其L,R,并记录它是空白线段还是有预约的线段

我们要查询一段区间,设这个区间为LX,RX

我们目的是将与[LX,RX]这个线段相交的线段提取出来

#### 那么我们就需要提取右端点<LX的线段到根,左端点>RX的线段到根的下面

根据我们平衡树维护区间的经验,根的右节点的左子树即为被包括的线段

图示如下

![图示](https://cdn.luogu.com.cn/upload/pic/18444.png)

 

 

 接下来的就很暴力了

我们可以直接遍历一遍被包括的子树,统计一下有多少条线段是已经预约过的

#### 因为我们会把一整颗子树换成3个点,时间复杂度均摊意义下还是nlogn的

 

然后直接把一整颗子树删掉,换上我们新的线段:

#### [前驱+1,LX-1],空白

#### [LX,RX],有预约

#### [RX+1,后继-1],空白

注意讨论是否存在那两条空白就好

 

#### 预处理加入[0,LEN-MAX]就OK了


------------


### Code
[暴力及数据生成器](http://www.cnblogs.com/GoldenPotato/p/8981895.html)
```cpp
//Luogu P2161 [SHOI2009]会场预约
//May,2ed,2018
//splay维护类区间
#include<iostream>
#include<cstdio>
using namespace std;
long long read()
{
	long long x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=800000+1000;
const int inf=0x3f3f3f3f;
const int TMAX=100000;
struct SPLAY
{
	#define root son[0][1]
	int son[N][2],fa[N],l[N],r[N],tot;
	bool used[N];
	inline void rotate(int x,int type)
	{
		int y=fa[x],z=fa[y];
		fa[x]=z,son[z][y==son[z][1]]=x;
		fa[son[x][type]]=y,son[y][!type]=son[x][type];
		fa[y]=x,son[x][type]=y;
	}
	void splay(int x,int to)
	{
		while(fa[x]!=to)
		{
			if(x==son[fa[x]][fa[x]==son[fa[fa[x]]][1]] and fa[fa[x]]!=to)
				rotate(fa[x],x==son[fa[x]][0]),
				rotate(x,x==son[fa[x]][0]);
			else
				rotate(x,x==son[fa[x]][0]);
		}
	}
	inline void Init()
	{
		root=++tot,fa[root]=0;
		son[root][1]=++tot,fa[tot]=root;
		l[tot]=1,r[tot]=TMAX;
		son[tot][1]=++tot,fa[tot]=son[root][1];
		l[tot]=r[tot]=TMAX+1;
	}
	int FindPre(int x)//返回位置
	{
		int now=root,ans=-inf,p=0;
		while(now!=0)
			if(r[now]>=x)
				now=son[now][0];
			else
			{
				if(r[now]>ans)
					ans=r[now],p=now;
				now=son[now][1];
			}
		return p;
	}
	int FindNxt(int x)//返回位置
	{
		int now=root,ans=inf,p=0;
		while(now!=0)
			if(l[now]>x)
			{
				if(l[now]<ans)
					ans=r[now],p=now;
				now=son[now][0];
			}
			else
				now=son[now][1];
		return p;
	}
	int Count(int x)
	{
		if(x==0) return 0;
		int ans=0;
		if(used[x]==true) ans++;
		ans+=Count(son[x][0]);
		ans+=Count(son[x][1]);
		return ans;
	}
	int Change(int L,int R)
	{
		splay(FindPre(L),0);
		splay(FindNxt(R),root);
		int now=son[son[root][1]][0],ans=Count(now);
		now=++tot,son[son[root][1]][0]=now,fa[now]=son[root][1];
		l[now]=L,r[now]=R,used[now]=true;
		if(r[root]<L-1)
		{
			fa[++tot]=now,son[now][0]=tot;
			l[tot]=r[root]+1,r[tot]=L-1;
		}
		if(l[son[root][1]]>R+1)
		{
			fa[++tot]=now,son[now][1]=tot;
			l[tot]=R+1,r[tot]=r[son[root][1]]-1;
		}
		return ans;
	}
	#undef root
}s;
int n,ans;
int main()
{
	//freopen("appointment.in","r",stdin);
	//freopen("appointment.out","w",stdout);
	n=read();
	s.Init();
	char OP[2];
	for(int i=1;i<=n;i++)
	{
		scanf("%s",OP+1);
		if(OP[1]=='A')
		{
			int l=read(),r=read(),temp=s.Change(l,r);
			ans=ans+1-temp;
			printf("%d\n",temp);
		}
		else
			printf("%d\n",ans);
	}
	return 0;
}


```

---

## 作者：QWsin (赞：4)

**
主要是logn插入 logn实现一个二分查找 使得总复杂度在nlogn

我觉得C++的STL来的比较快，但是谁知道我对于set确实是用不来QAQ

因为覆盖了的预定肯定要弹出去，二分查找一下覆盖了的预定（用右端点排序再二分查找）

看看左右两个预定有没有覆盖，覆盖了的就弹出去

对于set就是erase函数

但是我发现一个扯淡的情况，erase（\*it）后\*it还是原来那个值，不能自动往后移动，（一定是set内部奇特的红黑树我不懂），所以要it++再it--才能实现移动；但是it++可能要越界；而且你还不知道要越界！！！用if（it==s.end()）特判都不行！！！

我真是没有办法了 = =不管it先自增后自减还是换一下顺序，都会RE，我一开始RE了7组！！[delete]233还有3组WA了[/delete]就是因为这个鬼

所以呢 = =只好借用楼下的办法

我一开始还很奇怪为什么要写个死循环而不是先把左边弹完再把右边弹完= =

原来是这样

然后操作就比较简单了

顺便说一句用set装结构体需要重载小于符号 而且小于符号参数必须加const（我也不知道这什么鬼，编译器就是要报错）

**


```cpp
#include<set>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
struct Node{
    int l,r;
    Node(){}
    Node(int l,int r):l(l),r(r){}
    bool operator < (const Node &rhs)const{
        return r<rhs.r;
    }
};
int read()
{
    int ret=0;char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    for(;ch>='0'&&ch<='9';ch=getchar()) ret=ret*10+ch-'0';
    return ret;
}
set<Node>a;
int main()
{
    freopen("std.in","r",stdin);
    int Q;cin>>Q;
    char ins[2];
    int l,r;
    while(Q--)
    {
        scanf("%s",ins);
        if(ins[0]=='A')
        {
            l=read();r=read();
            Node t=Node(l,r);
            int cnt=0;
            while(1)
            {
                set<Node>::iterator it=a.lower_bound(t);
                if(it->l<=r&&it->r>=l)  //往后删
                {
                    a.erase(*it);cnt++;continue;  //这里加continue主要还是为了防RE，虽然好像没什么用？
                }
                it=a.lower_bound(t);
                if(it!=a.begin())             //往前删
                {
                    it--;
                    if(it->l<=r&&it->r>=l){a.erase(*it);cnt++;continue;}
                }
                break;
            }
            a.insert(t);
            printf("%d\n",cnt);
        }
        else printf("%d\n",a.size());
    }
    return 0;
}

```

---

## 作者：PenguinZhang (赞：4)

洛谷上的算法标签是这么贴的: 高精度,平衡树,树状数组

????????????你看见我头上的问号了吗??????????????

这题我是这样写的,用一个 vector 维护所选的所有会议的集合, vector储存的是结构体, 包含了某活动的开始时间和结束时间.

因为这是已经安排好的所有活动,所以保证了开始时间和结束时间不重叠,同时保证了,**按照开始时间排序就是按照结束时间排序**

**按照开始时间排序就是按照结束时间排序**

**按照开始时间排序就是按照结束时间排序**

那么就简单了. 
首先用 lower_bound查找新活动的开始时间, 这个迭代器是 it1

然后用 lower_bound查找新活动的结束时间, 这个迭代器是 it2

这样 `[it1, it2)` 肯定都是要抹掉的区间

然后再看, 如果 it2 的开始时间也在新活动结束时间之前, 那么 it2 也要抹掉

it2-it1 就是要抹掉的数量

本题结束


```cpp
/*
ZhangBinjie@Penguin
*/

#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e5+5;

struct node {
	int starts;
	int endt;
	bool operator < (const int et) const {
		return endt < et;
	}
};

vector<node>v;

int main() {
    std::ios::sync_with_stdio(false);
    int n;
    cin >> n;
    char c;
    int st, et;
    int ans = 0;
    while (n--) {
		cin >> c;
		if (c == 'A') {
			cin >> st >> et;
			auto it1 = lower_bound(v.begin(), v.end(), st);
			auto it2 = lower_bound(v.begin(), v.end(), et);
			if (it2 != v.end()) {
				if (it2->starts <= et)
					it2++;
			}
			int nums = it2 - it1;
			cout << nums << endl;
			v.erase(it1, it2);
			ans -= nums;
			v.insert(it1, {st, et});
			ans++;
		} else {
			cout << ans << endl;
		}
	}
    return 0;
}

```

---

## 作者：fffasttime (赞：4)

stl set的写法

思想前面的人已经说了，当前集合中的区间一定是不想交的，每次找最近的点弹掉即可

然后就成了找当前节点后面的第一个节点

用线段树或平衡树写都没什么问题

不过set用起来方便多了

```cpp

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <set>
using namespace std;

struct Node
{
    int l,r;
    bool operator<(const Node &v)const{if (l==v.l)return r<v.r;return l<v.l;}
};

set<Node> f;

int main()
{
    int n;
    scanf("%d",&n);
    for (int i=0;i<n;i++)
    {
        char c[2];int ql,qr;
        scanf("%s",c);
        if (c[0]=='A')
        {
            scanf("%d%d",&ql,&qr);
            Node a=(Node){ql,qr};
            int dc=0;
            while (1)
            {
                set<Node>::iterator it=f.lower_bound(a); //找大于左端点的第一个值 
                if (it->l<=a.r && a.l<=it->r) //如果区间被覆盖 
                {
                    dc++;
                    f.erase(it); //删除
                    continue;
                }
                it=f.lower_bound(a);
                if (it!=f.begin())
                {
                    it--; //前一个区间的端点 
                    if (it->l<=a.r && a.l<=it->r)
                    {
                        dc++;
                        f.erase(it);
                        continue;
                    }
                }
                break;
            }
            f.insert(a); //插入
            printf("%d\n",dc);
        }
        else
            printf("%d\n",f.size());//当前个数就是集合中元素的个数
    }
    return 0;
}

```

---

## 作者：夏色祭 (赞：3)

提供一种离线+线段树的写法。

考虑每个线段会产生的贡献。

对于A产生的贡献，那显然就是只会对操作编号离它最近且在它后面加入与它相交的线段产生1的贡献。

对于B产生的贡献，那就会对两者之间所有的B操作产生1的贡献。

那么我们就可以用线段树维护区间min来实现上面的思路。

吉利线段树？

其实不用，我们发现从后往前做的话，当前的操作编号很肯定是最小的。那不就是区间染色了吗。

```
//by zykykyk
#include<cstdio>
#include<ctime>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<string>
#define rg register
#define il inline
#define vd void
#define ll long long
#define N 200010
#define INF 2147483647
#define For(i,x,y) for (rg int i=(x);i<=(y);i++)
#define Dow(i,x,y) for (rg int i=(x);i>=(y);i--)
#define cross(i,k) for (rg int i=first[k];i;i=last[i])
using namespace std;
il ll max(ll x,ll y){return x>y?x:y;}
il ll min(ll x,ll y){return x<y?x:y;}
il ll read(){
    ll x=0;int ch=getchar(),f=1;
    while (!isdigit(ch)&&(ch!='-')&&(ch!=EOF)) ch=getchar();
    if (ch=='-'){f=-1;ch=getchar();}
    while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
    return x*f;
}
int n,m,opt[N],l[N],r[N],ans[N],sum[N];
char c[20];

int v[N<<2],lazy[N<<2];
il vd Build(int u,int l,int r){
	v[u]=lazy[u]=INF;
	if (l==r) return;
	int mid=l+r>>1;
	Build(u<<1,l,mid),Build(u<<1^1,mid+1,r);
}
il vd push_down(int u){
	if (lazy[u]!=INF){
		int lson=u<<1,rson=u<<1^1;
		lazy[lson]=lazy[rson]=v[lson]=v[rson]=lazy[u];lazy[u]=INF;
	}
}
il vd push_up(int u){
	v[u]=min(v[u<<1],v[u<<1^1]);
}
il vd update(int u,int l,int r,int ql,int qr,int x){
	if (l>=ql&&r<=qr){
		v[u]=lazy[u]=x;push_down(u);
		return;
	}
	int mid=l+r>>1;push_down(u);
	if (qr<=mid) update(u<<1,l,mid,ql,qr,x);
	else if (ql>mid) update(u<<1^1,mid+1,r,ql,qr,x);
	else update(u<<1,l,mid,ql,qr,x),update(u<<1^1,mid+1,r,ql,qr,x);
	push_up(u);
}
il int Query(int u,int l,int r,int ql,int qr){
	if (l>=ql&&r<=qr) return v[u];
	int mid=l+r>>1;push_down(u);
	if (qr<=mid) return Query(u<<1,l,mid,ql,qr);
	else if (ql>mid) return Query(u<<1^1,mid+1,r,ql,qr);
	else return min(Query(u<<1,l,mid,ql,qr),Query(u<<1^1,mid+1,r,ql,qr)); 
}

int main(){
	n=read();
	For(i,1,n){
		scanf("%s",c);
		if (c[0]=='A') opt[i]=1,l[i]=read(),r[i]=read(),m=max(m,r[i]);
			else opt[i]=2;
	}
	Build(1,1,m);
	Dow(i,n,1){
		if (opt[i]==2) continue;
		int q=Query(1,1,m,l[i],r[i]);
		if (q==INF) sum[i]++;
			else sum[i]++,sum[q]--,ans[q]++;
		update(1,1,m,l[i],r[i],i);
	}
	int Ans=0;
	For(i,1,n){
		Ans+=sum[i];
		if (opt[i]==2) ans[i]=Ans;
	}
	For(i,1,n) printf("%d\n",ans[i]);
}

```

---

## 作者：ddwqwq (赞：2)

我也来发一个平衡树题解，主要思想用的是算法导论上的区间红黑树，但把红黑树换成了更好写的treap。第一部分主要介绍如何将一般平衡树扩展为区间树，第二部分分析解题策略和时间复杂度，最后给出完整代码。

一.区间树

相比普通平衡树，区间树的每个结点需要维护额外的三个信息：low（低端点）、high（高端点）、max（子树中最高的端点）。本题中还需要维护一个size，这里不多解释。

区间树的插入与删除结点与普通平衡树并无太大差别，只不过把低端点当作排序的关键字。同时，添加与删除时要沿途维护max属性，可以类比普通平衡树维护size属性，详见代码。

区间树支持一个额外的search操作，可以以O(log n)的时间复杂度返回树中与给定区间有交集的区间的指针，若没有符合条件的区间则返回哨兵nil的地址。search操作的正确性是可以证明的，有兴趣的读者可以自行查找资料。给出search的代码：

```cpp
    node *search(const node aim)
    {
        node *p = root;
        while (p != nil && (p->high < aim.low || p->low > aim.high))
        {
            if (p->l != nil&&p->l->max >= aim.low)
                p = p->l;
            else
                p = p->r;
        }
        return p;
    }
```
二.题目分析

很明显，本题的难度就在于快速进行区间的查询、删除与插入操作，而这些区间树都可以在O(log n)的时间内完成。

题目中的A操作可以分解为两步：

1.反复查询并删除与给定区间有交集的区间，直到search返回nil。输出删除的区间个数。

2.将给定区间插入树中。

B操作更加简单，只需在O(1)时间内返回根结点的size值。

接下来我会详细分析这种做法的时间复杂度，以说明它为什么可以通过本题。设A操作数为N，B操作数为M。

首先分析单个步骤的最坏时间复杂度。若进行第N个A操作时，树中存在N-1个区间，且即将插入的区间与它们都有交集，则此时一共需进行N次search操作，N-1次删除操作，1次插入操作，时间复杂度为O(Nlog N)。由此可以得出一个时间复杂度的上界O(N^2log N)。但显然，这并不是一个确界。

经过更深入的分析，可以发现，本题中最多进行N次插入操作，N次删除操作，2N次查询操作。所以，N次A操作的总代价至多为O（4Nlog N）==O(Nlog N)。而B操作的时间复杂度为MO（1）==O（M），二者相加即为总时间复杂度O(Nlog N + M)，完全可以应付本题的数据规模。


三.代码：

先来个数据生成器

```cpp
void main()//这是一个数据生成器
{
    freopen("XXXXXXXXX", "w", stdout);

    srand(time(NULL));
    int n = rand();
    int i, a, b;
    char c;

    printf("%d\n", n);
    for (i = 0; i < n; i++)
    {
        c = 'A' + rand() % 2;
        if (c == 'A')
        {
            a = rand() % 100;
            b = a + rand() % 100;
            printf("%c %d %d\n", c, a, b);
        }
        else
            printf("%c\n", c);
    }
}
```
主代码

```cpp
#include <cstdlib>
#include <iostream>
#include <cstdio>
#include <math.h>
#include <cstring>
#include <time.h>

struct node {
    int low;
    int high;
    int max;
    int size;
    int w;
    node *l;
    node *r;
    node *p;
    node()//一部分的初始化，另一部分在newnode函数中
    {
        size = 0;
        max = 0;
        w = 0;
    }
};
const node Nil;//定义哨兵，避免一些麻烦
node *nil = (node*)&Nil;

node *newnode()
{
    node *p = new(node);
    p->size = 1;
    p->l = nil;
    p->r = nil;
    p->p = nil;
    p->w = rand();//赋予结点随机的优先级
    return p;
}
//几个标准的函数
void left_rotate(node *&root, node *x);//定义在下面
void right_rotate(node *&root, node *x);
bool cmp(node *a, node *b)
{
    return a->low < b->low;
}
int max(int a, int b)
{
    if (a > b)
        return a;
    return b;
}

struct interval_tree {//百度翻译管区间树叫这个名
    node *root;

    interval_tree()
    {//树的初始化
        root = nil;
    }
    void insert(node *p)
    {
        node *x = root;
        node *y = nil;
        while (x != nil)
        {
            y = x;
            x->max = max(x->max, p->max);
            x->size++;//沿途维护
            if (cmp(p, x))
                x = x->l;
            else
                x = x->r;
        }

        p->p = y;//先是普通二叉搜索树的插入
        if (y == nil)
            root = p;
        else if (cmp(p, y))
            y->l = p;
        else
            y->r = p;

        while (p->w < p->p->w)
        {//维护优先级
            if (p == p->p->l)
                right_rotate(root, p->p);
            else
                left_rotate(root, p->p);
        }
    }
    void Delete(node *&p)
    {
        while (p->l != nil || p->r != nil)
        {//将要删除的结点转为叶子结点
            if (p->l == nil)
                left_rotate(root, p);
            else if (p->r == nil)
                right_rotate(root, p);
            else if (cmp(p->l, p->r))
                right_rotate(root, p);
            else
                left_rotate(root, p);
        }

        if (p->p == nil)
            root = nil;
        else if (p == p->p->l)
            p->p->l = nil;
        else
            p->p->r = nil;

        node *t = p->p;
        while (t != nil)
        {//向上维护
            t->max = max(t->high, max(t->l->max, t->r->max));
            t->size--;
            t = t->p;
        }
        delete(p);
        p = nil;
    }
    node *search(const node aim)
    {
        node *p = root;
        while (p != nil && (p->high < aim.low || p->low > aim.high))
        {
            if (p->l != nil&&p->l->max >= aim.low)
                p = p->l;
            else
                p = p->r;
        }
        return p;
    }
    int size()
    {//返回树的规模
        return root->size;
    }
};
void left_rotate(node *&root, node *x)
{//很普通的左右旋转
    node *y = x->r;
    y->p = x->p;
    if (x->p == nil)
        root = y;
    else if (x == x->p->l)
        x->p->l = y;
    else if (x == x->p->r)
        x->p->r = y;
    x->r = y->l;
    if (y->l != nil)
        y->l->p = x;
    y->l = x;
    x->p = y;
    y->max = x->max;
    x->max = max(x->high, max(x->l->max, x->r->max));
    y->size = x->size;
    x->size = x->l->size + x->r->size + 1;
}
void right_rotate(node *&root, node *x)
{
    node *y = x->l;
    y->p = x->p;
    if (x->p == nil)
        root = y;
    else if (x == x->p->r)
        x->p->r = y;
    else if (x == x->p->l)
        x->p->l = y;
    x->l = y->r;
    if (y->r != nil)
        y->r->p = x;
    y->r = x;
    x->p = y;
    y->max = x->max;
    x->max = max(x->high, max(x->l->max, x->r->max));
    y->size = x->size;
    x->size = x->l->size + x->r->size + 1;
}

int main()
{
    srand(time(0));//用时间做rand的种子

    int i, n;
    char c[2];//用字符串输入，对付输入奇奇怪怪的格式
    interval_tree T;

    scanf("%d", &n);
    for (i = 0; i < n; i++)
    {
        scanf("%s", c);
        if (c[0] == 'A')
        {
            int cnt = 0;
            node *p = newnode();
            scanf("%d %d", &p->low, &p->high);
            p->max = p->high;
            node *t = T.search(*p);
            while (t != nil)
            {
                T.Delete(t);
                cnt++;
                t = T.search(*p);
            }
            printf("%d\n", cnt);
            T.insert(p);
        }
        else
            printf("%d\n", T.size());
    }

    system("pause");//记得注释掉
    return 0;
}
```


---

## 作者：Mys_C_K (赞：2)

##ckw染色线段树 以下简称染色树

[捂脸划掉]然而并没有那么厉害各位肯定在百度上什么的查不到

只不过是蒟蒻随随便便起了一个名字

其实质是蒟蒻看到这道题没有什么好的想法

就随便乱搞了一下加个优读欺负一下数据弱（表示已经用这个染色树乱搞A掉很多题了某个题貌似还比正解快但是内存大许多）

然而作为蒟蒻的第二道省选 就用这个名称来纪念一下

其实这个所谓的染色树就是一个支持删除的线段树，不用下放标记。

如果按照原来的模板，很有可能会有这样的情况：

整个线段是1---8，已经有1---4被染色，这次要染色的是1---8，直接染根节点即可，但是1---4由于是根的左子树，并没有因为相交而被覆盖。所以事实上比一般线段树多的唯一一个就是除了保存这个区间是否有被全部染色(ctag)以外，还记录了其左右子树是否有被染色的孩子(ltag,rtag).这样，插入操作(insert\_seg)就是：如果当前区间已经被染色，本次被删除颜色+1，删除这个颜色(delete\_seg因为此时还没有涂所以不用担心之前被涂上的被擦掉)；然后，若被覆盖，

1）若ltag=rtag=0则直接打标记(ctag=color,ltag=rtag=0)。

2）若ltag或者rtag不等于零，则在左或右子树插入一条值为0的线段，这样就可以把左右子树清空并删除相交区间。

然后退出。

之后，如果要染左子树，就去染，并让ltag=1；右子树同理。

删除操作是，如果当前线段被覆盖，就清零并退出。

如果要在左子树中删除，就去删，并更新ltag，右子树同理。

如果当前子树及其孩子没有被染色的点(ltag==rtag==0) 那么返回0，表示这段区间是空的，否则返回1。这个返回是用来更新上一级的ltag和rtag的。

之所以是对的（并且没有TLE），是因为当我们在insert\_seg中提出要删除的时候，必然是第一次找到，并且必然还没有染上这次要染的颜色，那么删除后，之后就不会再删除了。另外，由于区间不相交，所以删除的时候只有把这一区间的不是0的颜色都清零即可。

好吧蒟蒻的讲解能力实在差的要死，附上丑陋的代码（debug是用来输出线段调试用的）：

```cpp
#include<iostream>
#include<cstdio>
#define maxl 100000
#define seg_cnt segment_count
#define del_seg_cnt delete_segment_count
#define del_cnt delete_count
using namespace std;
struct segment{
    int left,right,ltag,rtag,ctag;
    segment *tc,*rc;
}*final_root;
struct segment_list{
    int left,right;
}list[200010];
int segment_count,delete_count,delete_segment_count;
        //seg_cnt,del_cnt,del_seg_cnt
int get_num()
{
    char ch;
    bool flag=false;
    int num;
    while((ch=getchar())==' '||ch=='\r'||ch=='\n');
    if(ch=='-') flag=true;
    else num=ch-'0';
    while(isdigit(ch=getchar())) num=num*10+ch-'0';
    return num;
}
int delete_seg(segment* &root,int s,int t)
{
    int l=root->left,r=root->right;
    int &lt=root->ltag,&rt=root->rtag,&ct=root->ctag;
    if(s<=l&&r<=t)
    {
        lt=rt=ct=0;
        return 0;
    }
    int mid=(l+r)/2;
    if(s<=mid) lt=delete_seg(root->tc,s,t);
    if(mid<t) rt=delete_seg(root->rc,s,t);
    if(lt==0&&rt==0) return 0;
    else return 1;
}
int insert_seg(segment* &root,int s,int t,int color)
{
    int l=root->left,r=root->right;
    int &lt=root->ltag,&rt=root->rtag,&ct=root->ctag;
//    printf("l=%d r=%d lt=%d rt=%d ct=%d\n",l,r,lt,rt,ct);
    if(ct!=0) delete_seg(final_root,list[ct].left,list[ct].right),del_cnt++;
    if(s<=l&&r<=t)
    {
        if(lt!=0) insert_seg(root->tc,s,t,0);
        if(rt!=0) insert_seg(root->rc,s,t,0);
        lt=rt=0;ct=color;return 0;
    }
    int mid=(l+r)/2;
    if(s<=mid) insert_seg(root->tc,s,t,color),lt=1;
    if(mid<t) insert_seg(root->rc,s,t,color),rt=1;
    return 0;
}
int build_seg(segment* &root,int s,int t)
{
    root=new segment;
    root->left=s;
    root->right=t;
    root->ltag=root->rtag=root->ctag=0;
    if(s==t)
    {
        root->tc=root->rc=NULL;
        return 0;
    }
    int mid=(s+t)/2;
    if(s<=mid) build_seg(root->tc,s,mid);
    if(mid<t) build_seg(root->rc,mid+1,t);
    return 0;
}
int debug(segment *root)
{
    if(root->ctag!=0)
    {
        for(int i=root->left;i<=root->right;i++)
            cout<<root->ctag<<" ";
        return 0;
    }
    if(root->left==root->right){
        cout<<root->ctag<<" ";
        return 0;
    }
    debug(root->tc);
    debug(root->rc);
    return 0;
}
int main()
{
    seg_cnt=del_seg_cnt=0;
    int q;q=get_num();
    build_seg(final_root,1,maxl);
    while(q--)
    {
        char ch;
        while((ch=getchar())==' '||ch=='\r'||ch=='\n');
        if(ch=='A'){
            int s,t;s=get_num();t=get_num();
            del_cnt=0;
            seg_cnt++;
            list[seg_cnt].left=s;
            list[seg_cnt].right=t;
            insert_seg(final_root,s,t,seg_cnt);
            printf("%d\n",del_cnt);
            del_seg_cnt+=del_cnt;
        }
        else printf("%d\n",seg_cnt-del_seg_cnt);
    }
    return 0;
}
```

---

## 作者：rediserver (赞：2)

# P2161 [SHOI2009]会场预约
[原题地址](https://www.luogu.org/problem/P2161)

[Github题解](https://github.com/jerrykcode/luogu)

### 二叉索搜树

树结点存储start及end，表示一个预约
```c
typedef struct TNode {
	int start, end;
	struct TNode * left;
	struct TNode * right;
} * Tree;
```

对每个树结点：

* start < end
* 左子树中所有结点的start和end都小于start
* 右子树中所有结点的start和end都大于end

树中所有的结点的(start, end)都不存在重叠部分，即不存在冲突的预约

### A操作

声明函数:
```c
Tree insert(Tree tree, int start, int end);
```
向tree中插入一个结点(start, end)，若与已有结点存在重叠，则删除已有结点。返回插入后的树。

对二叉索搜树插入稍微更改即可：

* 若tree为NULL，新建结点并返回
* 若end < tree->start，递归插入左子树
* 若start > tree->end, 递归插入右子树
* 否则待插入的(start, end)与(tree->start, tree->end)有重叠，`(tree->start, tree->end)表示的预约被拒绝`。注意此时`tree的子树中可能也存在与(start, end)重叠的结点`，若：
	* `start < tree->start`。左子树中所有结点的start和end均小于tree->start，但若start < tree->start，
	则tree的左子树中可能存在结点subtree，使subtree->end > start，而subtree->end < tree->start < end，即`start < subtree->end < end`，即subtree与(start, end)重叠，
	调用```tree->left = leftOverlap(tree->left, start);```消除tree的左子树中的重叠，`leftOverlap`函数见下文。
	*  `end > tree->end`。右子树中所有结点的start和end均大于tree->end，但若end > tree->end，
	则tree的右子树中可能存在结点subtree，使subtree->start < end，而subtree->start > tree->end > start，即`start < subtree->start < end`，即subtree与(start, end)重叠，
	调用```tree->right = rightOverlap(tree->right, end);```消除tree的右子树中的重叠，`rightOverlap`函数见下文。
  
  以上两种情况可能同时发生。`最后使用(start, end)替换(tree->start, tree->end)，即插入了新预约同时拒绝所有冲突的预约`

* leftOverlap函数
```c
Tree leftOverlap(Tree tree, int start);
```
对tree中所有结点subtree，若subtree->end > start，则删除此结点，即拒绝了冲突的预约，返回更新后的树

* 若tree为NULL，不存在冲突的预约，返回 NULL
* 若tree->end < start，则tree结点存储的预约不冲突，且tree的左子树的所有结点也一定不冲突。递归右子树。
* 若tree->end >= start，则tree结点存储的预约冲突，且tree的右子树的所有结点也一定冲突，删除右子树的所有结点，用left存储tree的左子树，然后删除tree结点本身。
   用left取代tree，此时还要递归left，因为left中可能还存在冲突的结点。

* rightOverlap函数

与leftOverlap对称。

#### 程序中使用全局变量tree_size表示树的结点数，removed_node_num表示因插入而删除的冲突结点数。
#### main中将tree_size初始化为0，每次A操作中吧removed_node_num初始化为0，然后调用insert函数。
#### 新建结点时 tree_size++；删除结点时tree_size--，removed_node_num++；替换结点时removed_node_num++(替换后树的结点数不变，但被替换的结点要被算作拒绝的结点)
#### A操作最后输出removed_node_num。

### B操作  输出tree_size即可

## 代码 

### C

```c
#include "stdio.h"
#include "stdlib.h"

int tree_size;
int removed_node_num;

typedef struct TNode {
	int start, end;
	struct TNode * left;
	struct TNode * right;
} * Tree;

Tree newTNode(int start, int end) {
	Tree t = (Tree)malloc(sizeof(struct TNode));
	t->start = start;
	t->end = end;
	t->left = t->right = NULL;
	return t;
}

Tree insert(Tree tree, int start, int end);
Tree leftOverlap(Tree tree, int start);
Tree rightOverlap(Tree tree, int end);
void deleteTree(Tree tree);

Tree insert(Tree tree, int start, int end) {
	if (tree == NULL) {
		tree_size++;	
		return newTNode(start, end);
	}
	if (end < tree->start) {
		tree->left = insert(tree->left, start, end);
	}
	else if (start > tree->end) {
		tree->right = insert(tree->right, start, end);
	}
	else {
		if (start < tree->start) {
			tree->left = leftOverlap(tree->left, start);
		}
		if (end > tree->end) {
			tree->right = rightOverlap(tree->right, end);
		}
		tree->start = start;
		tree->end = end;
		removed_node_num++;
	}
	return tree;
}

Tree leftOverlap(Tree tree, int start) {
	if (tree == NULL) return NULL;
	if (tree->end < start) {
		tree->right = leftOverlap(tree->right, start);
		return tree;
	}
	else {
		deleteTree(tree->right);
		tree->right = NULL;
		Tree left = tree->left;
		free(tree);
		removed_node_num++;
		tree_size--;
		return leftOverlap(left, start);
	}
}

Tree rightOverlap(Tree tree, int end) {
	if (tree == NULL) return NULL;
	if (tree->start > end) {
		tree->left = rightOverlap(tree->left, end);
		return tree;
	}
	else {
		deleteTree(tree->left);
		tree->left = NULL;
		Tree right = tree->right;
		free(tree);
		removed_node_num++;
		tree_size--;
		return rightOverlap(right, end);
	}
}

void deleteTree(Tree tree) {
	if (tree == NULL) return;
	if (tree->left) deleteTree(tree->left);
	if (tree->right) deleteTree(tree->right);
	free(tree);
	removed_node_num++;
	tree_size--;
}

int main() {
	Tree tree = NULL;
	tree_size = 0;
	int n ,start, end;
	scanf("%d", &n);
	char cmd;	
	for (int i = 0; i < n; i++) {
		scanf(" %c", &cmd);
		if (cmd == 'A') {
			scanf("%d %d", &start, &end);
			removed_node_num = 0;
			tree = insert(tree, start, end);
			printf("%d\n", removed_node_num);
		}
		else {
			printf("%d\n", tree_size);
		}
	}
	deleteTree(tree);
	return 0;
}
```

---

## 作者：YaliKiWi (赞：2)

[友链(与此题无关)](ljf-cnyali.cn)

## 模拟苟过

随机跳题就找到这道题了...

观察了一下tags：平衡树/树状数组/高精，然后是紫题

我一个**蒟蒻**就特($bu$)别($xiang$)慌($da$)

所以决定...
打**模拟**骗分

觉得骗它二三十差不多了，运气好还有五六十

----

介绍下沙雕思路：

**需要用到的变量：**

- $a$数组

$a[i]$表示第$i$天占用会场的会议编号

- $canc$数组

$canc[i]$表示第$i$个会议是否**被取消**过($canc[i]==1$表示被取消过，否则没有)

- $cnt$

记录当前会议编号

- $ans$

记录当前幸存(当前有效预约)会议数量

----

然后...该干嘛干嘛，上~~fake~~代码(码风超丑)
```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 100000+10
int a[maxn],cnt,n,ans;
bool canc[maxn+maxn];
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n;
    for(register int i=1;i<=n;i++){
        char c;
        cin>>c;
        if(c=='B'){
            cout<<ans<<endl;
        }
        if(c=='A'){
            int x,y,sum=0;
            cin>>x>>y;
            cnt++;//会议编号+1
            ans++;//当前新增加会议为幸存
            for(register int j=x;j<=y;j++){
                if(a[j]){//若当前日期有预约过会议
                    if(canc[a[j]]==0){//且该会议未被取消过
                        ans--;//当前幸存会议数量-1
                        canc[a[j]]=1;//取消该会议
                        sum++;//因当前会议需要而取消的会议个数+1
                    }
                }
                a[j]=cnt;//当前日期被当前会议占用
            }
            cout<<sum<<endl;
        }
    }
    return 0;
}
```
这个居然有[80](https://www.luogu.org/recordnew/show/19663867)-[90](https://www.luogu.org/recordnew/show/19663834)！(测了两次，看运气)

玄学优化即将来临！(自己找不同吖)

然鹅这是并没有正确性的

虽然[可以过](https://www.luogu.org/recordnew/show/19597128)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 100000+10
int a[maxn],cnt,n,ans;
bool canc[maxn+maxn];
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n;
    for(register int i=1;i<=n;i++){
        char c;
        cin>>c;
        if(c=='B'){
            cout<<ans<<endl;
        }
        if(c=='A'){
            int x,y,sum=0;
            cin>>x>>y;
            cnt++;
            ans++;
            for(register int i=x;i<=y;i++){
                if(a[i]){
                    if(canc[a[i]]==0){
                        ans--;
                        canc[a[i]]=1;
                        sum++;
                    }
                }
                a[i]=cnt;
            }
            cout<<sum<<endl;
        }
    }
    return 0;
}
```

~~所以这是一篇鸡肋题解~~

本题解仅供娱乐

---

## 作者：Sakura_梦瑶 (赞：2)

严格的2qlogn复杂度线段树,维护两个信息：lr之间为起点的预约个数,lr之间最大右端点的坐标.


------------

对于一次插入 首先清理lr之间的预约,普通的区间查询,利用信息1统计答案,然后直接将根置为null就可以完成清理。

其次再找到当前l的后继右端点,然后删掉那个后继就行.对于b询问o1回答即可.


------------

以下是代码 有压行,函数名比较个性,用户体验应该不太好。
```cpp
#include<bits/stdc++.h>
#define left l,mid,ls[p]
#define righ mid+1,r,rs[p]
#define use 1,1e5,rt
#define reperb; if(ma[rs[p]])ma[p]=ma[rs[p]];else ma[p]=ma[ls[p]];
#define N 1<<23
using namespace std;bool f;
int ls[N],rs[N],num[N],ma[N],rt,cnt,ans,d,t,n;
void sak_fi(int p){
	num[p]--;if(ma[ls[p]]==ma[p])sak_fi(ls[p]);
	else if(ma[rs[p]]==ma[p])sak_fi(rs[p]);
	else{ma[p]=0;return;}reperb;
}
void sak_tr(int l,int r,int &p){
	if(!p)p=++cnt;num[p]++;if(l==r){ma[p]=t;return;}int mid=l+r>>1;
	if(mid>=d)sak_tr(left);else{sak_tr(righ);if(ma[ls[p]]>=d)sak_fi(ls[p]),f=0,ans++;}
	if(!f)num[p]--;reperb;
}
void sak_qu(int l,int r,int &p,int ql,int qr){
	if(ql==l&&qr==r){ans+=num[p],p=0;return;}int mid=l+r>>1;
	if(mid>=qr)sak_qu(left,ql,qr);else if(mid<ql)sak_qu(righ,ql,qr);
	else sak_qu(left,ql,mid),sak_qu(righ,mid+1,qr);
	reperb;num[p]=num[ls[p]]+num[rs[p]];
}
int main(){
	cin>>n;for(int i=1,c;i<=n;i++){
		scanf(" %c",&c);if(c=='B')printf("%d\n",num[rt]);
		else f=1,ans=0,scanf("%d%d",&d,&t),sak_qu(use,d,t),sak_tr(use),printf("%d\n",ans);
	}
}
```


---

## 作者：asuldb (赞：2)

同样是从试炼场点进来的，这是一道非常需要耐心的题

不过明明就是我太菜了，真正的大佬都是一眼秒吧

首先我们有一种比较常规的暴力思路，就是用线段树来维护区间连续子段数，而拒绝掉所有与当前区间相冲突的预约我们可以通过二分来做，来查找从最开始到这个区间的区间首第一个与区间首相同的位置，和区间尾到最后最靠后的一个与区间尾相同的位置

为什么可以二分呢，我们知道我们要找的子段是连续的，所以具有单调性，于是可以二分

由于我们在维护区间连续子段数和进行二分的时候需要做一个单点查询，所以时间复杂度是$O(nlog^{2}n)$

代码如下
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define re register
#define maxn 200001
using namespace std;
int l[maxn<<2],r[maxn<<2],sum[maxn<<2],d[maxn<<2],tag[maxn<<2];
//sum[i]表示i对应区间内连续子段数
int n,m,tot;
char p[maxn];
int x[maxn],y[maxn];
void build(int x,int y,int i)
{
	l[i]=x;
	r[i]=y;
	tag[i]=-1;
	if(x==y) return;
	int mid=x+y>>1;
	build(x,mid,i<<1);
	build(mid+1,y,i<<1|1);
}
inline void pushdown(int i)
{
	if(tag[i]!=-1)
	{
		tag[i<<1]=tag[i];
		tag[i<<1|1]=tag[i];
		d[i<<1|1]=tag[i];
		d[i<<1]=tag[i];
		if(tag[i]) sum[i<<1|1]=sum[i<<1]=1;
		else sum[i<<1|1]=sum[i<<1]=0;
		tag[i]=-1;
	}
}
int ask(int x,int i)
{
	if(l[i]==r[i]&&l[i]==x) return d[i];
	pushdown(i);
	int mid=l[i]+r[i]>>1;
	if(x<=mid) return ask(x,i<<1);
	return ask(x,i<<1|1);
}//单点查询
void change(int x,int y,int i,int v)
{
	if(x<=l[i]&&y>=r[i])
	{
		if(v) sum[i]=1;
		else sum[i]=0;
		tag[i]=v;
		d[i]=v;
		return;
	}
	pushdown(i);
	int mid=l[i]+r[i]>>1;
	if(y<=mid) change(x,y,i<<1,v);
	else if(x>mid) change(x,y,i<<1|1,v);
	else change(x,y,i<<1|1,v),change(x,y,i<<1,v);
	int q1=ask(mid,1),q2=ask(mid+1,1);
	if(q1==q2&&q1) sum[i]=sum[i<<1]+sum[i<<1|1]-1;
    //在进行updata操作时我们要进行两次单点查询
    //如果当前区间左儿子的最右点和右儿子的最左点相同且均不为0
    //则说明有一个子段被分开了，sum[i]应该等于sum[i<<1]+sum[i<<1|1]-1;
	else sum[i]=sum[i<<1|1]+sum[i<<1];
}
int query(int x,int y,int i)
{
	if(x<=l[i]&&y>=r[i]) return sum[i];
	pushdown(i);
	int mid=l[i]+r[i]>>1;
	if(y<=mid) return query(x,y,i<<1);
	if(x>mid) return query(x,y,i<<1|1);
	int q1=ask(mid,1),q2=ask(mid+1,1);
	if(q1==q2&&q1) return query(x,y,i<<1)+query(x,y,i<<1|1)-1;
	return query(x,y,i<<1)+query(x,y,i<<1|1);
	d[i]=d[i<<1];
}
int main()
{
	ios::sync_with_stdio(false);
	cin>>n;
	int xx,yy;
	int maxx=0,minn=99999999;
	for(re int i=1;i<=n;i++)
	{
		cin>>p[i];
		if(p[i]=='A') cin>>x[i]>>y[i],maxx=max(maxx,y[i]),minn=min(minn,x[i]);
	}
	build(1,maxx,1);
	for(re int i=1;i<=n;i++)
	{
		if(p[i]=='B') cout<<m-tot<<endl;
		if(p[i]=='A')
		{
			int now=query(x[i],y[i],1);
			cout<<now<<endl;
			tot+=now;//tot为总撤销个数，方便进行B操作
			int now1=ask(x[i],1),now2=ask(y[i],1);
			int ans1,ans2;
			int ll=minn,rr=x[i];
			if(now1)//如果当前区间的最左点为0，那么就不需要进行二分了
			{
				while(ll<=rr) 
				{
					int mid=ll+rr>>1;
					if(ask(mid,1)==now1) ans1=mid,rr=mid-1;
					else ll=mid+1;
				}
			}//查找从最开始到这个区间的区间首第一个与区间首相同的位置
			if(now2)
			{
				ll=y[i],rr=maxx;
				while(ll<=rr)
				{
					int mid=ll+rr>>1;
					if(ask(mid,1)==now2) ans2=mid,ll=mid+1;
					else rr=mid-1;
				}
			}//区间尾到最后最靠后的一个与区间尾相同的位置
			if(now1&&x[i]!=ans1) change(ans1,x[i],1,0);
			if(now2&&y[i]!=ans2) change(y[i],ans2,1,0);
			change(x[i],y[i],1,++m);
		}
	}
	return 0;
}
```
当然，这样写理论上的复杂度应该是$O(nlog^{2}n)$，但是常数太大了，所以吸氧也不能拯救这份代码，这种写法就只有60

但是我们可以考虑对这份代码进行优化，尝试去掉一个$log$

首先我们在维护sum的时候，只用到了区间最左和最右位置的状态，所以我们完全可以再开两个数组$lc$，$rc$，分别维护区间最左和最右的位置的状态

而对于我们二分查找做撤销操作，我们可以对每个区间维护一下撤销这个区间时应该撤销的实际区间是哪一个，于是我们可以再开两个数组$ll$，$rr$来进行维护每个区间做撤销操作时实际应该对哪个区间进行操作

这样一来我们通过来我们通过两次时间换空间，使我们的代码的时间复杂度降到了$O(nlongn)$，而空间上尽管多开了几个数组，但内存仍绰绰有余

于是就是代码了
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define re register
#define maxn 200001
using namespace std;
struct node
{
	int a,b,c;
};
int l[maxn<<2],r[maxn<<2],ll[maxn<<2],rr[maxn<<2];
int rc[maxn<<2],lc[maxn<<2],sum[maxn<<2],tag[maxn<<2];
int n,m,tot;
char p[maxn];
int x[maxn],y[maxn];
void build(int x,int y,int i)
{
	ll[i]=l[i]=x;
	rr[i]=r[i]=y;
	tag[i]=-1;
	if(x==y) return;
	int mid=x+y>>1;
	build(x,mid,i<<1);
	build(mid+1,y,i<<1|1);
}
inline void pushdown(int i)
{
	if(tag[i]==-1) return;
	if(tag[i])
	{
		sum[i<<1|1]=sum[i<<1]=1;
		tag[i<<1|1]=tag[i<<1]=tag[i];
		ll[i<<1]=ll[i];
        ll[i<<1|1]=ll[i];
        //左右两个儿子向左扩展的位置应该与i向左扩展的位置一致
		rr[i<<1|1]=rr[i];
		rr[i<<1]=rr[i];
        //左右两个儿子向右扩展的位置应该与i向右扩展的位置一致
		rc[i<<1]=rc[i<<1|1]=lc[i<<1]=lc[i<<1|1]=tag[i];
        //更新状态
	}
	if(!tag[i])//撤销操作的下传标记
	{
		sum[i<<1|1]=sum[i<<1]=0;
		tag[i<<1|1]=tag[i<<1]=0;
		ll[i<<1]=l[i<<1];
        ll[i<<1|1]=l[i<<1|1];
		rr[i<<1]=r[i<<1];
		rr[i<<1|1]=r[i<<1|1];
        //由于又恢复到初始状态，不需要进行扩展，所以直接修改成区间的实际值就好
		rc[i<<1]=rc[i<<1|1]=lc[i<<1]=lc[i<<1|1]=0;
	}
	tag[i]=-1;
}
void change(int x,int y,int i,int v)
{
	if(x<=l[i]&&y>=r[i])
	{
		if(v)
		{
			sum[i]=1;
			ll[i]=x;
			rr[i]=y;
		}else
		{
			sum[i]=0;
			ll[i]=l[i];
			rr[i]=r[i];
		}
		rc[i]=lc[i]=v;
		tag[i]=v;
		return;
	}
	pushdown(i);
	int mid=l[i]+r[i]>>1;
	if(y<=mid) change(x,y,i<<1,v);
	else if(x>mid) change(x,y,i<<1|1,v);
	else change(x,y,i<<1,v),change(x,y,i<<1|1,v);
	if(rc[i<<1]==lc[i<<1|1]&&rc[i<<1]) sum[i]=sum[i<<1]+sum[i<<1|1]-1;//同上一份代码
	else sum[i]=sum[i<<1|1]+sum[i<<1];
	rc[i]=rc[i<<1|1];
	lc[i]=lc[i<<1];
    //最右边的状态来自于右儿子，最左边的状态来自于左儿子
	ll[i]=ll[i<<1];
	rr[i]=rr[i<<1|1];
    //更新扩展的区间
}
node query(int x,int y,int i)
{
	if(x<=l[i]&&y>=r[i]) return (node){sum[i],ll[i],rr[i]};
	pushdown(i);
	int mid=l[i]+r[i]>>1;
	if(y<=mid) return query(x,y,i<<1);
	if(x>mid) return query(x,y,i<<1|1);
	node q1=query(x,y,i<<1),q2=query(x,y,i<<1|1);
	if(rc[i<<1]==lc[i<<1|1]&&rc[i<<1]) return (node){q1.a+q2.a-1,min(q1.b,q2.b),max(q1.c,q2.c)};
	return (node){q1.a+q2.a,min(q1.b,q2.b),max(q1.c,q2.c)};
}
int main()
{
	ios::sync_with_stdio(false);
	cin>>n;
	int xx,yy;
	int maxx=0,minn=99999999;
	for(re int i=0;i<n;++i)
	{
		cin>>p[i];
		if(p[i]=='A') cin>>x[i]>>y[i],maxx=max(maxx,y[i]),minn=min(minn,x[i]);
	}
	build(minn,maxx,1);
	for(re int i=0;i<n;++i)
	{
		if(p[i]=='B') cout<<m-tot<<endl;
		if(p[i]=='A')
		{
			node now=query(x[i],y[i],1);
			cout<<now.a<<endl;
			tot+=now.a;
			if(now.a) change(now.b,now.c,1,0);
			change(x[i],y[i],1,++m);
		}
	}
	return 0;
}
```

---

## 作者：wanzzhehe (赞：1)

实际上，大概方法楼上（楼下？）的大佬们已经说的很清楚了，就是利用平衡树来维护区间，其实就是区间树。似乎线段树染色也能做？不过我不会（逃）


我的代码主要是改进了一下搜索重复区间的问题，楼上的大都是每次只找到一个区间与目标区间重合，然后逐次统计，虽然因为每个区间最多会进出一次，但是依旧会造成一定的浪费，而我的是一次遍历了整棵树，一边查找，一边计数，一边删除重叠区间，代码大概长这样：


```cpp
struct NODE{ 
    int L, R, fix, size, max;
    NODE *ls, *rs;
    NODE(int l, int r) { 
        L = l, max = R = r;
        fix = rand(), size = 1;
        ls = rs = NULL;
    }
    inline void Update(void);
};

NODE *root;

int Find(NODE *&node, int L, int R) { 
    if(!node || node->max < L) return 0;
    int cnt = 0;
    bool flag = false; //做个标记判断是否与目标区间重叠
    if(L <= node->R && R >= node->L) cnt = 1, flag = true;
    if(R >= node->L) cnt += Find(node->rs, L, R);
    if(node->ls) cnt += Find(node->ls, L, R);
    node->Update();
    if(flag) Remove(node);
    /* 如果重叠就删除，不在找到之后直接删除是因为还要遍历这个节点的左右子树
     * 如果直接删除在后这个节点的值就会出现变化，虽说特判可以解决这个问题，但是还不如将删除操作放在后面
     */
    return cnt;
}
```

-------


附上完整代码：


```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <ctime>
using namespace std;

inline char getc(void) { 
    static char buf[1 << 18], *fs, *ft;
    return (fs == ft && (ft = (fs = buf) + fread(buf, 1, 1 << 18, stdin)), fs == ft) ? EOF : *fs++;
}

inline int read(void) { 
    char tmp = getc();
    int res = 0;
    for(; !isdigit(tmp); tmp = getc());
    for(; isdigit(tmp); tmp = getc())
        res = ((res + (res << 2)) << 1) + (tmp ^ 0x30);
    return res;
}

inline int read(char *s) { 
    char *p = s;
    while(!isgraph(*p = getc()));
    while(isgraph(*(++p) = getc()));
    *p = '\0';
    return p - s;
}

const int INF = 0x7fffffff;

struct NODE{ 
    int L, R, fix, size, max;
    NODE *ls, *rs;
    NODE(int l, int r) { 
        L = l, max = R = r;
        fix = rand(), size = 1;
        ls = rs = NULL;
    }
    inline void Update(void);
};

inline void LeftRotate(NODE *&k2);
inline void RightRotate(NODE *&k2);
void Insert(NODE *&node, int L, int R);
int Find(NODE *&node, int L, int R);
void Remove(NODE *&node);

NODE *root;
int N, a, b;
char str[3];

int main() { 
    srand(time(NULL));
    N = read();
    while(N--) { 
        read(str);
        if(*str == 'A') { 
            a = read(), b = read();
            printf("%d\n", Find(root, a, b));
            Insert(root, a, b);
        } else if(root == NULL) printf("0\n");
        else printf("%d\n", root->size);
    }
    return 0;
}

inline void NODE::Update(void) { 
    size = 1 + (ls ? ls->size : 0) + (rs ? rs->size : 0);
    max = ::max(R, ::max(ls ? ls->max : -INF, rs ? rs->max : -INF));
    //更新的时候注意左右子树为空的情况。。
}

inline void LeftRotate(NODE *&k2) { 
    NODE *k1 = k2->rs;
    k2->rs = k1->ls;
    k1->ls = k2;
    k2->Update(), k1->Update();
    k2 = k1;
}

inline void RightRotate(NODE *&k2) { 
    NODE *k1 = k2->ls;
    k2->ls = k1->rs;
    k1->rs = k2;
    k2->Update(), k1->Update();
    k2 = k1;
}

void Insert(NODE *&node, int L, int R) { 
    if(!node) node = new NODE(L, R);
    else if(L < node->L) { 
        Insert(node->ls, L, R);
        if(node->ls->fix < node->fix) RightRotate(node);
        else node->Update();
    } else { 
        Insert(node->rs, L, R);
        if(node->rs->fix < node->fix) LeftRotate(node);
        else node->Update();
    }
}

int Find(NODE *&node, int L, int R) { 
    if(!node || node->max < L) return 0;
    int cnt = 0;
    bool flag = false;
    if(L <= node->R && R >= node->L) cnt = 1, flag = true;
    if(R >= node->L) cnt += Find(node->rs, L, R);
    if(node->ls) cnt += Find(node->ls, L, R);
    node->Update();
    if(flag) Remove(node);
    return cnt;
}

void Remove(NODE *&node) { 
    if(node->ls && node->rs) { 
        if(node->ls->fix < node->rs->fix)
            RightRotate(node), Remove(node->rs);
        else LeftRotate(node), Remove(node->ls);
        node->Update();
    } else { 
        NODE *t = node;
        if(node->ls) node = node->ls;
        else node = node->rs;
        delete t;
    }
}
```


---

## 作者：baby_lu0 (赞：1)

使用的是$multset$解决的这道题。
我们考虑每次出现了一对左右端点。需要删除的情况：

1、完全包含你新加入的点。

2、或者你包含很多区间的左右端点(可以只包含一个左端点或右端点)

这两个情况显然是不能同时存在的。

然后我们继续考虑如何处理呢，把第$i$次操作当做是染成$i$颜色，对于每个颜色存储当前已有的左右端点，并且对于每个颜色进行标记是否被删除。

$multiset$里只用存端点，用数组存端点对应颜色然后删去。

如果没有可删的考虑是否出现第一种情况。

```cpp
#include<bits/stdc++.h>
#define FOR(i,l,r) for(register int i=l;i<=r;i++)
using namespace std;

typedef long long ll;

const int maxn=5e5+2000;

multiset<int>mt;
char str[3];int l,r;
pair<int,int>color[maxn];
int col[maxn];
bool vis[maxn];
vector<int>G;

int main(){
    int T;cin>>T;
    while(T--){
        scanf("%s",str);
        if(str[0]=='A'){
            scanf("%d%d",&l,&r);
            auto itl=mt.lower_bound(l);
            auto itr=mt.upper_bound(r);
            for(auto it=itl;it!=itr;it++){
                int c=col[(*it)];
                if(vis[c])continue;vis[c]=true;
                int L=color[c].first,R=color[c].second;
                G.push_back(L);G.push_back(R);
            }
            if(G.size()==0){
                if(itl==mt.begin()||itr==mt.end());
                else{
                    --itl;
                    if(col[(*itl)]==col[(*itr)]){
                        int c=col[(*itl)];
                        vis[c]=true;
                        int L=color[c].first,R=color[c].second;
                        G.push_back(L);G.push_back(R);
                    }
                }

            }
            for(auto it:G)mt.erase(it);
            printf("%d\n",G.size()/2);
            G.clear();
            mt.insert(l);mt.insert(r);
            color[T]=make_pair(l,r);
            col[l]=col[r]=T;
        }
        if(str[0]=='B'){
            printf("%d\n",mt.size()/2);
        }
    }
}

```

---

## 作者：CodyTheWolf (赞：0)

### [开头小广告：自己做的一个模板库OwO](https://www.luogu.org/blog/29354/Templet)

------------
## 分析：
### 这道题两种主流算法是平衡树（或者set）和线段树染色，前者大同小异，不过后者就有很多不同的写法了。~~貌似大家写的有点复杂有好多数组~~，那我这边写一个比较简单易懂的：

------------
## 算法：
### 我们把每次$Ai$操作看成在线段树上$s$和$t$之间涂上颜色i，开两个数组$s[i]$和$t[i]$表示第$i$个颜色的起始和结束以便于我们后面的查询

### 线段树上只用两个数组：$color$代表区间的颜色，$tag$是懒标记。(如果一时没有明白可以想成最普通的区间线段树加法）

### 这里的color，我们设-1为杂色，0为无色，大于0为颜色。在PushUp的时候，如果$color[lson]==color[rson]$是没有问题的，但是当：


------------

### $color[lson]!=color[rson]$&&$color[lson]!=0$&&$color[rson]!=0$
（说人话就是**左右儿子颜色不同**且**两个都是有颜色**的，**而不是一个是白色**）


------------

### 时，我们只需再往下多走一个区间就行了，因为当区间左右端点重合，只有一个位置，也只有一个颜色，不可能还是-1。

### 所以对于$A$操作，我们只需要在线段树上查询询问的区间$[x,y]$，并在查询的时候在全局开数组，记录一下有哪几个颜色（记得处理过的颜色标记一下，因为颜色只会出现一次，不需要也不能重复删除）。

### 对于一个颜色$c$,我们在线段树上把$s[c]->t[c]$全部修改成0即可，记得打懒标记。

### 添加的区间直接在线段树上修改成对应的编号即可，这里的两个操作是可以共用一个函数的（在我的程序里就是Update函数）

------------
## 复杂度分析：
### 每个区间只会被插入一次和删除一次，因此复杂度是$O(nlogn)$

------------
# CODE
### 线段树直接封装好了，比较容易看懂XD

```cpp
// luogu-judger-enable-o2
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
const int MAXN = 1e5 + 5, MAXQ = 2e5 + 5, N = 1e5;
int colors[MAXQ], colort[MAXQ];
int queue[MAXQ], tail;
bool tag[MAXQ];
int n, sum = 0;
char opt[3];

#define mid ((x + y) >> 1)
#define lson (pst << 1)
#define rson (pst << 1 | 1)

//线段树
struct SegmentTree 
{
    int color[MAXN << 2], tag[MAXN << 2];

    inline void PushUp(int pst)
    {
        if (color[lson] == color[rson])
            color[pst] = color[lson];
        else if (!color[lson] || !color[rson])
            color[pst] = color[lson] + color[rson];//直接加起来是因为一个是0，加起来肯定是另外一个（FHQ_TREAP的写法）
        else
            color[pst] = -1;

        return;
    }

    inline void PushDown(int pst)//非常普通的下放
    {
        if (tag[pst])
        {
            color[lson] = color[rson] = tag[pst];
            tag[lson] = tag[rson] = tag[pst];
            tag[pst] = 0;
        }

        return;
    }

    inline void Query(int x, int y, int pst, int l, int r)
    {
        if (y < l || x > r)
            return;

        if (l <= x && y <= r && (~color[pst]))//不是杂色且符合区间
        {
            if (color[pst])
                queue[++tail] = color[pst];//queue是用来记录颜色的

            return;
        }

        PushDown(pst);
        Query(x, mid, lson, l, r), Query(mid + 1, y, rson, l, r);
        PushUp(pst);

        return;
    }

    inline void Update(int x, int y, int pst, int l, int r, int k)//非常普通的修改操作，和区间线段树加法没什么区别
    {
        if (y < l || x > r)
            return;

        if (l <= x && y <= r)
        {
            color[pst] = tag[pst] = k;

            return;
        }

        PushDown(pst);
        Update(x, mid, lson, l, r, k), Update(mid + 1, y, rson, l, r, k);
        PushUp(pst);

        return;
    }
} ST;

signed main(void)
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
    {
        scanf("%s", opt);

        if (opt[0] == 'A')
        {
            scanf("%d %d", colors + i, colort + i);

            tail = 0;//记得让tail归0
            ST.Query(1, N, 1, colors[i], colort[i]);

            int cnt = 0;//删除的个数
            for (int i = 1; i <= tail; i++)
                if (!tag[queue[i]])//tag用来标记颜色是否被删除
                {
                    int s = colors[queue[i]], t = colort[queue[i]];
                    ST.Update(1, N, 1, s, t, 0);
                    tag[queue[i]] = true;
                    cnt++;
                }

            ST.Update(1, N, 1, colors[i], colort[i], i);

            printf("%d\n", cnt);
            sum = sum - cnt + 1;
        }

        if (opt[0] == 'B')
            printf("%d\n", sum);//sum就是当前还有的区间数咯~
    }

    return 0;
}
```

---

## 作者：sjkmost (赞：0)

本题其实就是让你维护一个由不相交区间组成的序列，那么我们可以用一个平衡树来维护，每次插入一个区间之后不断删除它的前驱与后继，直到它与它的前驱和后继不相交为止。

由于每个区间至多被插入一次，删除一次，所以复杂度是均摊$O(nlogn)$的。

实现上需要注意的是平衡树是可以在插入和删除时维护前驱和后继而不影响它们$O(logn)$的复杂度的，没有必要每次去查找前驱和后继。

另外本题由于每次查询都是查询全部区间的数量，可以不用维护一个$size$域，而是使用一个计数器来维护。

使用$Treap$实现的平衡树：

```cpp
namespace Treap {
    struct Node {
        int l, r, w;
        Node *ch[2], *prec, *succ;
        
        int cmp(int a, int b) {
            return a == l ? b == r ? -1 : b > r : a > l; 
        }
    } node[MAXN], *null = &node[0], *root = node;
    
    int cnt;
    
#define newnode() &node[++ cnt]
#define Rand() (rand() << 15 | rand())
    inline Node *Find(int l, int r) {
        int d;
        Node *k = root;
        
        while (k != null) {
            d = k->cmp(l, r);
            if (d == -1)
                return k;
            k = k->ch[d];
        }
        return k;
    }
    
    inline void Rotate(Node *&o, int d) {
        Node *k = o->ch[d ^ 1];
        o->ch[d ^ 1] = k->ch[d];
        k->ch[d] = o;
        o = k;
    }
    
    Node *Insert(Node *&o, Node *p, Node *s, int l, int r) {
        if (o == null) {
            o = newnode();
            o->ch[0] = o->ch[1] = null;
            o->prec = p, o->succ = s;
            p->succ = s->prec = o;
            o->l = l, o->r = r;
            o->w = Rand();
            return o;
        }
        
        int d = o->cmp(l, r);
        Node *k;
        if (d)
            k = Insert(o->ch[d], o, s, l, r);
        else
            k = Insert(o->ch[d], p, o, l, r);
        
        if (o->ch[d]->w > o->w)
            Rotate(o, d ^ 1);
        return k;
    }
    
    void Remove(Node *&o, int l, int r) {
        int d = o->cmp(l, r);
        if (d != -1) {
            Remove(o->ch[d], l, r);
            return;
        }
        
        int m;
        if (o->ch[0] != null && o->ch[1] != null) {
            m = o->ch[0]->w > o->ch[1]->w;
            Rotate(o, m);
            Remove(o->ch[m], l, r);
            return;
        }
        
        o->prec->succ = o->succ;
        o->succ->prec = o->prec;
        if (o->ch[0] == null)
            o = o->ch[1];
        else
            o = o->ch[0];
    }
};
```
主程序：

```cpp
int main() {
    srand(19260817);
    init();
    
    int n = read_int(), dx, dy, num = 0, ans;
    char com;
    Node *m;
    
    For(i, 1, n) {
        com = read_char();
        
        if (com == 'A') {
            dx = read_int(), dy = read_int();
            if (Find(dx, dy) != null) {
                puts("1");
                continue;
            }
            
            ans = 0;
            m = Insert(root, null, null, dx, dy);
            while (m->prec != null && m->prec->r >= m->l)
                Remove(root, m->prec->l, m->prec->r), ++ ans;
            while (m->succ != null && m->succ->l <= m->r)
                Remove(root, m->succ->l, m->succ->r), ++ ans;
            num += 1 - ans;
            printf("%d\n", ans);
        }
        else
            printf("%d\n", num);
    }
    return 0;
}
```

---

## 作者：wzj423 (赞：0)

前面dalao的gaoji线段树闪闪发光

我：（愚蠢的萌新玩家-10000）

我的线段树写法如下：

维护正常的染色线段树标记以及正常的加和标记

每段颜色在左端点加上1

因为肯定是全部擦除的所以到时候（询问&擦除）直接统计和就好啦

每次询问的时候看一看左右是不是还有颜色（查询），有的话可以向两边拓展（一个较大的区间）

然后擦除大区间，染色小区间就好了

应该是O（nlogn）的，但我的代码不清真，不开O2会被卡TAT

以下是不清真的代码

```cpp
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cstdlib>

#include <cstring>
#include <cmath>
#include <cctype>
#include <string>

#include <algorithm>
#include <queue>
#include <stack>

using namespace std;
int N;
struct node
{
    int color,ctag,num,ntag;
} T[100010<<3];
pair<int,int> req[200010];
const int maxn=100010;
/**
color: -1 multi-color 0 white
ctag: color to draw ,-1 invalid
num:number of the color(extra 1 added at left point)
ntag: number tag,-1 invalid;
*/
// code
void build_tree(int L,int R,int id=1)
{
    if(L==R)
        return;
    int mid=(L+R)>>1;
    T[id].ctag=-1;
    T[id].ntag=-1;
    build_tree(L,mid,id<<1);
    build_tree(mid+1,R,id<<1|1);
}
void clean_mark(int id)
{
    if(T[id].ctag!=-1)
    {
        T[id].color=T[id].ctag;
        T[id<<1].ctag=T[id<<1|1].ctag=T[id].ctag;
        T[id].ctag=-1;
    }
    if(T[id].ntag!=-1)
    {
        T[id].num=T[id].ntag;
        T[id<<1].ntag=T[id<<1|1].ntag=T[id].ntag;
        T[id].ntag=-1;
    }
}
void delete_tree(int B,int E,int L,int R,int id=1)
{
    if(L>E||R<B)
        return;
    //printf("delete_tree %d,%d,%d,%d,%d\n",B,E,L,R,id);
    clean_mark(id);
    if(L>=B&&R<=E)
    {
        memset(T+id,0,sizeof (node));
        return;
    }
    if(L==R)
        return;
    int mid=(L+R)>>1;
    delete_tree(B,E,L,mid,id<<1);
    delete_tree(B,E,mid+1,R,id<<1|1);
    ///push_up
    clean_mark(id<<1);
    clean_mark(id<<1|1);
    if(T[id<<1].color==T[id<<1|1].color&&T[id<<1].color!=-1)
        T[id].color=T[id<<1].color;
    else
        T[id].color=-1;
    T[id].num=T[id<<1].num+T[id<<1|1].num;
    T[id].ntag=T[id].ctag=-1;
}
inline int query_num()
{
    clean_mark(1);
    return T[1].num;
}
void color_tree(int B,int E,int color,int L,int R,int id=1)
{
    if(L>E||R<B)
        return;
    //printf("color_tree %d,%d,%d,%d,%d\n",B,E,L,R,id);
    clean_mark(id);
    if(L>=B&&R<=E)
    {
        T[id].ctag=color;
        if(L==B)
            T[id].ntag=1;
        return;
    }
    if(L==R)
        return;
    int mid=(L+R)>>1;
    color_tree(B,E,color,L,mid,id<<1);
    color_tree(B,E,color,mid+1,R,id<<1|1);
    ///push_up
    clean_mark(id<<1);
    clean_mark(id<<1|1);
    if(T[id<<1].color==T[id<<1|1].color&&T[id<<1].color!=-1)
        T[id].color=T[id<<1].color;
    else
        T[id].color=-1;
    T[id].num=T[id<<1].num+T[id<<1|1].num;
    T[id].ntag=T[id].ctag=-1;
}
int query_color(int B,int E,int L,int R,int id=1)
{
    if(L>E||R<B)
        return 0;
    //printf("query_color %d,%d,%d,%d,%d\n",B,E,L,R,id);
    clean_mark(id);
    if(L>=B&&R<=E)
    {
        return T[id].color;
    }
    if(L==R)
        return 0;
    int mid=(L+R)>>1;
    return query_color(B,E,L,mid,id<<1)+query_color(B,E,mid+1,R,id<<1|1);
}
int main()
{
    scanf("%d",&N);
    build_tree(1,maxn);
    for(int i=1; i<=N; ++i)
    {
        char C;
        int x,y;
        int b,e,n1,n2;
        scanf("%1s",&C);
        if(C=='B')
        {
            printf("%d\n",query_num());
        }
        else if(C=='A')
        {
            scanf("%d%d",&x,&y);
            req[i].first=x,req[i].second=y;
            b=x,e=y;


            int cl1=query_color(x,x,1,maxn),cl2=query_color(y,y,1,maxn);
            if(cl1)
                b=req[cl1].first;
            if(cl2)
                e=req[cl2].second;
            //printf(">: delete [%d,%d]\n",b,e);
            n1=query_num();
            delete_tree(b,e,1,maxn,1);
            n2=query_num();
            color_tree(x,y,i,1,maxn,1);

            //printf("%d=%d-%d\n",n1-n2,n1,n2);
            printf("%d\n",n1-n2);
        }
    }
    return 0;
}

```

---


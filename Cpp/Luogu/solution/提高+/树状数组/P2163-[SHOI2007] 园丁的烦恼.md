# [SHOI2007] 园丁的烦恼

## 题目背景

很久很久以前，在遥远的大陆上有一个美丽的国家。统治着这个美丽国家的国王是一个园艺爱好者，在他的皇家花园里种植着各种奇花异草。

有一天国王漫步在花园里，若有所思，他问一个园丁道： “最近我在思索一个问题，如果我们把花坛摆成六个六角形，那么……”

“那么本质上它是一个深度优先搜索，陛下。”园丁深深地向国王鞠了一躬。

“嗯……我听说有一种怪物叫九头蛇，它非常贪吃苹果树……”

“是的，显然这是一道经典的动态规划题，早在 N 元 $4002$ 年我们就已经发现了其中的奥秘了，陛下。”

“该死的，你究竟是什么来头？”

“陛下息怒，干我们的这行经常莫名其妙地被问到和 OI 有关的题目，我也是为了预防万一啊！” 王者的尊严受到了伤害，这是不可容忍的。

## 题目描述

看来一般的难题是难不倒这位园丁的，国王最后打算用车轮战来消耗他的实力： “年轻人，在我的花园里有 $n$ 棵树，每一棵树可以用一个整数坐标来表示，一会儿，我的 $m$ 个骑士们会来轮番询问你某一个矩阵内有多少树，如果你不能立即答对，你就准备走人吧！”说完，国王气呼呼地先走了。

这下轮到园丁傻眼了，他没有准备过这样的问题。所幸的是，作为“全国园丁保护联盟”的会长——你，可以成为他的最后一根救命稻草。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n, m \leq 10$。
- 对于 $100\%$ 的数据，保证 $0 \leq n \leq 5 \times 10^5$，$1 \leq m \leq 5 \times 10^5$，$0 \leq x, y, a, b, c, d \leq 10^7$，$a \leq c$，$b \leq d$。

## 样例 #1

### 输入

```
3 1
0 0 
0 1
1 0
0 0 1 1
```

### 输出

```
3```

# 题解

## 作者：Soulist (赞：79)

#### 关于本题
由于作者比较蒟蒻，所以做这道题的时候调试了非常之久......然后被卡常了？？？

反正由于常数问题，最后不得不将cin改为快读，才在400ms的时差下惊险通过此题。。。

因为本题题解大部分都看不懂，所以特意写一篇来让大家理解
### 关于做法

  本题因为树的坐标均为给定的， 而查询比较多， 所以考虑使用2维前缀和QAQ， 对于每一个点我们都建立一个$S_{i,j}$表示以($0$,$0$)为左下坐标，($i$,$j$)为右上坐标的矩阵内部有多少课树。

那么对于每一个查询左下为点($a$, $b$)，右上为点($c$, $d$)的矩阵的查询，可以将之进行拆分。如下图：
![](https://cdn.luogu.com.cn/upload/pic/24264.png)

> 则图中的黑色部分为整个大的黑色部分也就是S_{c,d}减去旁边两个红色边所（自行想象一下）形成的矩形，也就是 $S_{a,d}$和 $S_{c,b}$ ; 注意到图中灰边矩形被减去了两次，所以还应当被加上上一次，所以有：黑色矩形中的树的数量为下式：
> #### 黑色矩形 $=$  $S_{c,d}$ + $S_{a-1,b-1} $- $S_{a-1,d}$-$S_{c,b-1}$
(自行想一想为什么是$a$ - $1$和$b$ - $1$)

> (上面那一串话比较拗口搞不懂的话，其实您可以考虑画一张类似的如上的图，然后根据$S_{i,j}$的定义来手动模拟一下上式的计算过程)

所以目前的问题就转化成为了求出上述的2维前缀和了。

但由于本题数据范围过大，所以直接使用二维前缀和肯定是会炸的（不仅仅是因为它是$2$维，还有因为这里的前缀和对应的是题中坐标，而坐标过于广泛），所以考虑先对坐标进行离散化，然后对于所有的坐标（包括询问坐标）按照$x$轴进行排序，

按照$x$坐标排序后，我们进行前缀和操作的时候就不需要考虑$x$坐标了，然后同时将$y$坐标离散化掉（我是用排序离散化掉y的）

> Q1：为什么按$x$坐标排序后就不需要考虑$x$坐标了

> A1:因为排序后一定有后面来的点的$x$坐标一定比前面所有的$x$坐标都大，故当这个点为询问时只需要判断比该点的$y$坐标小的点有多少个即可。

所以之后对于每一个按照$x$坐标顺序读入的树点，可以将之分为两类操作：

(1):加入一个树点

(2):询问比该点$y$坐标要小的点数量

介于上述两个操作，我们可以显然可以使用一个数据结构来操作。（树状数组这么短为什么不用它呢？）

所以，下面给出代码了：（直接抄是肯定不会对的啦。）
 ```
#include<bits/stdc++.h>
using namespace std;
const int N = 3000000 + 5;
const int M = 1e7 + 5;
int tree[N], n, m;
struct node
{
	int x, y, id, qs, ut;
}t[N];
int cnt;
int qy[N], ans[N];
//刘氏快读
#define Finline __inline__ __attribute__ ((always_inline))
Finline char get_char()
{
    static char buf[200000001], *p1 = buf, *p2 = buf + fread(buf, 1, 200000000, stdin);
    return p1 == p2 ? EOF : *p1 ++;
}
inline int read(){
    int num = 0;
    char c;
    while((c = get_char()) < 48);
    while(num = num * 10 + c - 48, (c = get_char()) >= 48);
    return num;
}
//以上均为刘氏快读优化 
bool cmp(node r1, node r2)
{
	if(r1.x == r2.x) 
		if(r1.y == r2.y) return r1.qs <= r2.qs;//x,y均相同的情况下优先处理树点而不是询问点
	if(r1.x == r2.x)
		return r1.y < r2.y;//x相同则按y排序
	return r1.x < r2.x ; 
}
int lowbit(int x)//树状数组
{	
	return x&(-x);
}
int find1(int x)// 2分查找找出离散化后的y
{
	int l = 1, r = cnt;
	while(l < r)
	{
		int mid = (l + r) / 2;
		if(qy[mid] < x)
			l = mid + 1;
		else
			r = mid - 1;
	}
	return l;
}//考虑优化find1？？？不知道怎么优化啊QAQ？？？离散化？？？ 
void add(int root, int rx, int ry, int rq)
{
	cnt++;
	t[cnt].x = rx;
	t[cnt].y = ry;
	t[cnt].id = root;
	t[cnt].qs = rq;
	qy[cnt] = ry;
}//加入一个点
void add_tree(int root, int k)//树状数组加入点
{
	for(int i = root; i <= cnt; i += lowbit(i))//从编号开始，每次向上依次传值。。。 
		tree[i] += k;
}
int find(int root)查找比该点y小的点有多少个
{
	int num = 0;
	for(int i = root; i != 0; i -= lowbit(i))
		num += tree[i];//从节点x开始，依次找到下路 
	return num;
}
void q_read()
{
	int p;
	n = read();
	m = read();
	int sx, sy;
	for(int i = 1; i <= n; i++)
	{
		sx = read(); sy = read();
		add(i, sx, sy, 0);//读入 
	}
	int a, b, c, d;
	for(int i = 1; i <= m; i++)
	{
		a = read(); b = read(); c = read(); d = read();
		p = m ;
		add(i, a - 1, b - 1, 1);//0,1表示这个数是否为问题 
		add(i + p, c, d, 1);
		add(i + 2 * p, a - 1, d, 1);
		add(i + 3 * p, c, b - 1, 1);
	}
}
void doit()
{
	sort(t + 1, t + cnt + 1, cmp);//通过关于x的排序离散化掉x
	sort(qy + 1, qy + cnt + 1);//通过关于y的排序离散化掉y
	for(int i = 1; i <= cnt; i++)
	{
		int tof = find1(t[i].y);//查找值为t[i].y的坐标的点在离散化后的y序列中的位置
		if(t[i].qs == 0)//是树点
			add_tree(tof, 1);//加入一个点
		else//是询问
			ans[t[i].id]+=find(tof);//记录答案
	}
}
int qans(int x)
{
	int p = m ;
	return ans[x] + ans[x + p] - ans[x + 2 * p] - ans[x + 3 * p];//之前讲的前缀和，把最后一个1 * p改为3 * p即可A了
}
void write()//输出程序
{
	for(int i = 1; i <= m; i++)
		cout << qans(i) <<endl;
}
//以下是优美的主程序 
int main()
{
	q_read();
	doit();
	write();
	return 1;//防止抄袭
}
``` 

---

## 作者：cc123321 (赞：64)

CDQ的题解，一个裸的二维数点，效率nlogn，按x轴排序，然后乱搞一通CDQ就好了。
注意：每个询问拆成4个询问，再加上n个点，所以空间要开5倍。
QAQ

```cpp
#include<bits/stdc++.h>
#define maxn 5000005 * 5
using namespace std;
inline int read()
{
    char x = getchar();
    int lin = 0, f = 1;
    while(x < '0' || x > '9')
    {
        if(x == '-') f = -1;
        x = getchar();
    }
    while(x >= '0' && x <= '9')
    {
        lin = lin * 10 + x - '0';
        x = getchar();
    }
    return lin * f;
}
struct st{
    int x,y,typ,add,id,ans;
}s[maxn],ce[maxn];
int n,m,x,y,tot,a,b,c,d,ans[maxn];
void add(int x,int y,int typ,int add,int id,int ans)
{
    s[++tot] = (st) {x,y,typ,add,id,ans};
}
bool com(st a,st b)
{
    if(a.x == b.x)
        if(a.y == b.y)
            return a.typ < b.typ;
        else return a.y < b.y;
    return a.x < b.x;
}
void cdq(int l,int r)
{
    if(l == r) return;
    int mid = l + r >> 1;
    cdq(l,mid);
    cdq(mid + 1,r);
    int le = l,re = mid + 1,pos = 0,ans = 0;
    while(le <= mid || re <= r)
    {
        if(re > r || (le <= mid && s[le].y <= s[re].y))
        {
            if(s[le].typ == 1) ++ans;
            ce[++pos] = s[le++];
        }
        else
        {
            if(s[re].typ == 2) s[re].ans += ans;
            ce[++pos] = s[re++];
        }
    }
    for(int i = 1; i <= pos; i++)
        s[l + i - 1] = ce[i];
}

int main(){
    n = read(); m = read();
    for(int i = 1; i <= n; i++)
    {
        x = read(); y = read();
        add(x,y,1,0,0,0);
    }
    
    for(int i = 1; i <= m; i++)
    {
        a = read(); b = read();
        c = read(); d = read();
        add(a - 1,b - 1,2,1,i,0);
        add(c,d,2,1,i,0);
        add(a - 1,d,2,-1,i,0);
        add(c,b - 1,2,-1,i,0);
    }
    sort(s + 1,s + 1 + tot,com);
    
    cdq(1,tot);
    for(int i = 1; i <= tot; i++)
        if(s[i].typ == 2)
            ans[s[i].id] += s[i].add * s[i].ans;
    for(int i = 1; i <= m; i++)
        printf("%d\n",ans[i]);
}
```

---

## 作者：wkjwkj (赞：46)

## 前置芝士

 在做这道题之前，我们可以先来看一下这道题目。

[题面](https://www.luogu.com.cn/paste/ueskwrtc)

相信这道题目大家都会做，只要将星星的坐标按 $x$ 排序，即可降掉一维，接下来要处理的就是 $n$ 个询问，将数组按照排序后的顺序扫一遍，每次用 `ask(y)` 询问每颗星星左下角的星星个数，再将该颗星星的 y 坐标放入树状数组，则可处理出每个星星的等级，进一步得出答案。

[代码](https://www.luogu.com.cn/paste/4i7bg8ob)

## 分析题意

受到刚才题目的启发，我们便可以得到了 `ask(y)` 的几何意义，即如下图所示，表示红色矩形中树的棵数。

![](https://cdn.luogu.com.cn/upload/image_hosting/mdqak2j0.png)

类似的，根据题意，题目中查询的为以 $(a, b)$ 为左下角，$(c, d)$ 为右上角的矩形内部（包括边界）有多少棵树，那么我们可以根据题意画出符合题意的图形

![](https://cdn.luogu.com.cn/upload/image_hosting/3mfw7ck9.png)

如图，该图形代表一次询问，则图中粉色部分的矩形内所含有的树的棵数即为我们所要求的的答案，故我们不难发现答案可用我们上一题的思路来统计。

到这里，可能有同学会问：统计粉色矩形内的树的棵数不是执行了两次 `ask(d)` 与 `ask(b-1)` 吗？得出的结果不是不正确吗？其实不然两次 `ask(d)` 与 `ask(b-1)` 并不是在同一时间进行的，故代表的意义不同，得出的结果也不同，不会出现问题。

设在点 $(a-1,d)$ 时， `ask(d)=sum2` ，在点 $(a-1,b-1)$ 时， `ask(b-1)=sum1` ，在点 $(c,b-1)$ 时， `ask(b-1)=sum3` ，在点 $(c,d)$ 时， `ask(d)=sum4` 我们便可以得出 `ans=sum4-sum2-sum3+sum1` 自此，我们便得出了思路。

关于在具体代码实现上，我们便可以将每个询问裂成四个**虚点**，即放入扫描数组，但不添加至树状数组中，则这样可以得出我们的正确答案且不影响树状数组的统计。

值得一提的是，本题的数据范围比较大，我们可以在按 $x$ 排序后，对 $y$ 数组进行离散化。还有不要忘记对  `n=0,m!=0` 的情况进行特判~~并且注意卡常~~

放上我丑陋的代码：

```cpp
#include<bits/stdc++.h>
#define reg register
using namespace std;
int n;
int c[2500005];
struct star{
    int x,y;
    int pos;//pos用来方便统计答案与判定是否为虚点
};
star st[2500005];
int ans[500005][5];
int tot[500005];
int x1_[500005],x2_[500005],y1_[500005],y2_[500005];//不要轻易用x1,x2,y1,y2...
int b[2500005],p;
bool cmp(star x,star y)
{
    if(x.x!=y.x)return x.x<y.x;
    if(x.y!=y.y)return x.y<y.y;
    return x.pos<y.pos;
}
inline void add(int x,int y)
{
    for(reg int i=x;i<=n;i+=i&-i)c[i]+=y;
}
inline int ask(int x)
{
    int ans=0;
    for(reg int i=x;i>=1;i-=i&-i)ans+=c[i];
    return ans;
}
inline int lsh(int x)
{
	return lower_bound(b+1,b+p+1,x)-b;
}
int main()
{
	//printf("%d",sizeof(ans)/1024/1024);
	int m;
    scanf("%d%d",&n,&m);
    if(n==0){
    	for(reg int i=1;i<=m;i++)printf("0\n");
    	return 0;
    }
    if(m==0)
    {
        return 0;
    }
    for(reg int i=1;i<=n;i++)scanf("%d%d",&st[i].x,&st[i].y),st[i].pos=0;
    for(reg int i=1;i<=m;i++){
    	scanf("%d%d%d%d",&x1_[i],&y1_[i],&x2_[i],&y2_[i]),st[++n].x=x1_[i]-1,st[n].y=y1_[i]-1,st[n].pos=i;
		st[++n].x=x2_[i],st[n].y=y2_[i],st[n].pos=i;
		st[++n].x=x2_[i],st[n].y=y1_[i]-1,st[n].pos=i;
		st[++n].y=y2_[i],st[n].x=x1_[i]-1,st[n].pos=i;
    }
    sort(st+1,st+n+1,cmp);
    for(reg int i=1;i<=n;i++)b[i]=st[i].y;
    sort(b+1,b+n+1);
    p=unique(b+1,b+n+1)-(b+1);
    for(reg int i=1;i<=n;i++)
    {
    	if(st[i].pos)ans[st[i].pos][++tot[st[i].pos]]=ask(lsh(st[i].y));
    	//printf("%d\n",ask(lsh(st[i].y)));
    	else if(st[i].pos==0)add(lsh(st[i].y),1);
		//printf("st[i].y=%d,ask(st[i].y)=%d\n",lsh(st[i].y),ask(st[i].y));
    }
    for(reg int i=1;i<=m;i++)
      printf("%d\n",ans[i][4]-ans[i][3]-ans[i][2]+ans[i][1]);
    return 0;
}
```



## 后言

放上个随机小数据生成器，方便大家调试。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	freopen("data.in","w",stdout);
	srand((unsigned)(time(0)));
	int n=rand()%10,m=1;
	printf("%d %d\n",n,m);
	for(int i=1;i<=n;i++)
	{
		int x=rand()%10,y=rand()%10;
		printf("%d %d\n",x,y);
	}
	for(int i=1;i<=1;i++)
	{
		int x=rand()%10,y=rand()%10;
		int x2=rand()%10,y2=rand()%10;
		if(x>x2)swap(x,x2);
		if(y>y2)swap(y,y2);
		printf("%d %d %d %d\n",x,y,x2,y2);
		
	}
	return 0;
}
```

[顺便推销一波博客](https://mywkj.github.io/)



---

## 作者：alpq010815 (赞：16)

离散化，对x排序
转化=F(x2,y2)−F(x1−1,y2)−F(x2,y1−1)+F(x1−1,y1−1)
相当于有四个查询
记下每个x的查询，与添加
没有修改，然后扫描线，降掉一维
直接统计答案就行了
```
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<queue>
using namespace std;
const int MAXN=500004;
struct node{int x,y,xx,yy;}a[MAXN];vector<int>V[MAXN],Q[MAXN],q[MAXN];
int n,m,N,M,sum[MAXN],x[MAXN],y[MAXN],tmpx[MAXN*3],tmpy[MAXN*3],totx,toty,ans[MAXN];
void modify(int x){for(;x<=M;x+=x&-x)sum[x]++;}
int query(int x){int ans=0;for(;x;x-=x&-x) ans+=sum[x];return ans;}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d%d",&x[i],&y[i]),tmpx[++totx]=x[i],tmpy[++toty]=y[i];
    for(int i=1;i<=m;i++) {
        scanf("%d%d%d%d",&a[i].x,&a[i].y,&a[i].xx,&a[i].yy);a[i].x--;a[i].y--;
        tmpx[++totx]=a[i].x;tmpx[++totx]=a[i].xx;tmpy[++toty]=a[i].y;tmpy[++toty]=a[i].yy;
    }
    sort(tmpx+1,tmpx+totx+1);sort(tmpy+1,tmpy+toty+1);
    N=unique(tmpx+1,tmpx+totx+1)-tmpx-1;M=unique(tmpy+1,tmpy+toty+1)-tmpy-1;
    for(int i=1;i<=n;i++){
        x[i]=lower_bound(tmpx+1,tmpx+N+1,x[i])-tmpx;
        y[i]=lower_bound(tmpy+1,tmpy+M+1,y[i])-tmpy;
        V[x[i]].push_back(y[i]);
    }
    for(int i=1;i<=m;i++){
        a[i].x=lower_bound(tmpx+1,tmpx+N+1,a[i].x)-tmpx;
        a[i].y=lower_bound(tmpy+1,tmpy+M+1,a[i].y)-tmpy;
        a[i].xx=lower_bound(tmpx+1,tmpx+N+1,a[i].xx)-tmpx;
        a[i].yy=lower_bound(tmpy+1,tmpy+M+1,a[i].yy)-tmpy;
        Q[a[i].x].push_back(i);q[a[i].xx].push_back(i);
    }
    for(int i=1;i<=N;i++){
        for(int j=0;j<V[i].size();j++) modify(V[i][j]);
        for(int j=0;j<Q[i].size();j++) ans[Q[i][j]]+=query(a[Q[i][j]].y)-query(a[Q[i][j]].yy);
        for(int j=0;j<q[i].size();j++) ans[q[i][j]]+=query(a[q[i][j]].yy)-query(a[q[i][j]].y);
    }
    for(int i=1;i<=m;i++) printf("%d\n",ans[i]);
}
```


---

## 作者：chengni (赞：11)

似乎好像还没有直接用树状数组写的啊，来一发

这个问题可以转化成二维偏序（逆序对）问题，直接用一维数状数组来求

先将询问的矩阵拆成四个点，然后按其中一维排序，另一维用树状数组求逆序对的方法直接求就可以了

因为分为询问的点和原有的点，可以直接两个数组做，不然容易乱掉

最后容斥一下就好了

```cpp
#include<bits/stdc++.h>

using namespace std;

typedef long long ll;

inline ll read(){
    char ch=getchar();ll x=0,f=1;
    while(ch<'0' || ch>'9') {
       if(ch=='-') f=-1;
      	  ch=getchar();
    }
    while(ch<='9' && ch>='0') {
       x=x*10+ch-'0';
       ch=getchar();
    }
    return x*f;
}

struct node{
    int x,y;
}t[40404004];

struct nod{
    int x,y,id,w;
}a[20200222];


int tr[10000020];

int lowbit(int x){
    return x&-x;
}

void add(int x,int k){
    x++;
    while(x<=10000010){
        tr[x]+=k;
        x+=lowbit(x);
    }
}

int sum(int x){
    x++;
    int s=0;
    while(x){
        s+=tr[x];
        x-=lowbit(x); 
    }
    return s;
}

bool cmp(node a,node b){
    return a.x<b.x;
}

bool cmpp(nod a,nod b){
    return a.x<b.x;
}

int ans[2020022];

int main(){
    int n=read(),m=read();
    for(int i=1;i<=n;i++){
        t[i].x=read(),t[i].y=read();
    }
    int cnt=0;
    for(int i=1;i<=m;i++){//询问矩阵拆成四个点
        int xa=read(),ya=read(),xb=read(),yb=read();
        cnt++;a[cnt].id=cnt;a[cnt].w=1;a[cnt].x=xb;a[cnt].y=yb;
        cnt++;a[cnt].id=cnt;a[cnt].w=1;a[cnt].x=xb;a[cnt].y=ya-1;
        cnt++;a[cnt].id=cnt;a[cnt].w=1;a[cnt].x=xa-1;a[cnt].y=yb;
        cnt++;a[cnt].id=cnt;a[cnt].w=1;a[cnt].x=xa-1;a[cnt].y=ya-1;
    }
    sort(t+1,t+n+1,cmp);//分别按 x 排序
    sort(a+1,a+cnt+1,cmpp);
    int now=1;
    for(int i=1;i<=cnt;i++){//树状数组求逆序对
        while(t[now].x<=a[i].x && now<=n) {;
            add(t[now].y,1);
            now++;
        }
        ans[a[i].id]+=sum(a[i].y);
    }
    for(int i=1;i<=cnt;i+=4){//容斥输出
        printf("%d\n",ans[i]-ans[i+1]-ans[i+2]+ans[i+3]);
    }
    return 0;
}

```


---

## 作者：文文殿下 (赞：11)

不知道大家为什么把他当成一个高维问题做了。

既要cdq又要数据结构什么的。。

难道不是一层cdq就好了嘛。

把一个询问拆成四个，本质是一个二维数点问题。。这个真的没人想到嘛。。？

```cpp
#include<cstdio>
#include<algorithm>
const int maxn = 3e6+10;
struct qwq {
	int x,y,type,ind;
}query[maxn],tmp[maxn];
bool cmp (qwq a,qwq b) {
	if(a.x==b.x) {
		if(a.y==b.y) {
			return a.type<b.type;
		}
		return a.y<b.y;
	}
	return a.x<b.x;
}
int n,m;
int cnt = 0;
int ans[maxn];
inline void add(int x,int y,int type,int ind) {
	query[cnt].x=x;
	query[cnt].y=y;
	query[cnt].type=type;
	query[cnt].ind=ind;
	++cnt;
}
void cdq(int L,int R) {
	if(R-L<=1) return;
	int M = (R+L)>>1;
	cdq(L,M);cdq(M,R);
	int q = L,p = M,o=0;
	int sum=0;
	while(q<M&&p<R) {
		if(query[q].y<=query[p].y) {
			if(query[q].type==0)
				++sum;
			tmp[o++]=query[q++];
		}
		else {
			if(query[p].type==1) {
				ans[query[p].ind]-=sum;
			}else if(query[p].type==2) {
				ans[query[p].ind]+=sum;
			}
			tmp[o++]=query[p++];
		}
	}
	while(q<M) {
		tmp[o++]=query[q++];
	}
	while(p<R) {
		if(query[p].type==1) {
			ans[query[p].ind]-=sum;
		}else if(query[p].type==2) {
			ans[query[p].ind]+=sum;
		}
		tmp[o++]=query[p++];
	}
	for(int i = 0;i<o;++i) {
		query[i+L]=tmp[i];
	}
	return;
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i = 0;i<n;++i) {
		scanf("%d%d",&query[cnt].x,&query[cnt].y);
		query[cnt].type=0;
		++cnt;
	}
	for(int i = 0;i<m;++i) {
		 int x1,y1,x2,y2;
		 scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
		 add(x1-1,y1-1,2,i);
		 add(x2,y2,2,i);
		 add(x1-1,y2,1,i);
		 add(x2,y1-1,1,i);
	}
	std::sort(query,query+cnt,cmp);
	cdq(0,cnt);
	for(int i = 0;i<m;++i) printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：skydogli (赞：10)

## 主席树裸题
一句话题意:给出$n$个点$(x_i,y_i)$,以及m个询问$a,b,c,d$,每个询问求满足$a<=x_i<=b$且$c<=y_i<=d$的点的个数,不会主席树的[出门右转](https://www.luogu.org/problemnew/show/P3834)

回到这题,我们只需要十分套路地把所有点的坐标按$x$从小到大排序,然后依次插入,对于每个询问,就先2次二分出$a$和$c$对应的点的范围$l$到$r$,取出$root[r]$和$root[l-1]$,查询树中$b$到$d$的数量,相减就是答案.复杂度$O(nlog_2(R))$,空间复杂度$O(nlog_2(R))$($R$为值域).常数略大,但可以通过此题

#### 代码&注释
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
#define getchar() (p1==p2 and (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#define MN 500005
#define INF 10000000
#define Ls Tree[x].ls
#define Rs Tree[x].rs
#define mid ((l+r)>>1)
char buf[1<<24],*p1=buf,*p2=buf;
inline int read(){
    int a=0;char c=getchar();
    while(c>57 or c<48)c=getchar();
    while(47<c and c<58){
        a=a*10+c-48;
        c=getchar();
    }
    return a;
}//快读
struct tree{
    int ls,rs,sum;
}Tree[MN<<5];//动态开点,因为值域1e7,所以log偏大,空间要开大点
struct data{
    int x,y;
}w[MN];
int n,m,a,b,c,d,root[MN],cnt;
bool cmp(data a,data b){
    return a.x<b.x;
}//结构体,按x从小到大排序
inline int low_bnd(int x){
    int l=0,r=n;
    while(l+1<r)
        (w[mid].x>=x)?r=mid:l=mid;
    return r;
}//找l的范围,要大于等于a
inline int sma_bnd(int x){
    int l=1,r=n+1;
    while(l+1<r)
        (w[mid].x<=x)?l=mid:r=mid;
    return l;
}//找r的范围,要小于等于c
void pluss(int &x,int l,int r,int v){
    Tree[++cnt]=Tree[x];x=cnt;
    ++Tree[x].sum;
    if(l==r)return;
    (mid>=v)? pluss(Ls,l,mid,v):pluss(Rs,mid+1,r,v);
}//动态开点
int ask(int x,int l,int r,int b,int e){
    if(l>e||r<b||!x)return 0;
    if(b<=l&&r<=e)return Tree[x].sum;
    return ask(Ls,l,mid,b,e)+ask(Rs,mid+1,r,b,e);
}//查询区间
int main(){
    n=read();m=read();
    for(int i=1;i<=n;++i){
        w[i].x=read();w[i].y=read();
    }
    sort(w+1,w+1+n,cmp);
    for(int i=1;i<=n;++i){
        root[i]=root[i-1];
        pluss(root[i],0,INF,w[i].y);//依次建树
    }
    for(int i=1;i<=m;++i){
        a=read();b=read();c=read();d=read();
        int l=low_bnd(a),r=sma_bnd(c);//求出区间
        printf("%d\n",ask(root[r],0,INF,b,d)-ask(root[l-1],0,INF,b,d));//差分相减
    }
    return 0;
} 

```

---

## 作者：critnos (赞：7)

首先要让树的 $x$ 坐标在两个查询点的 $x$ 坐标之间，这个的话，将树的的坐标按 $x$ 坐标为关键字排序，然后对于每个查询二分查找，就得到了一个区间。

问题就转化为了一个区间，每次查询这个区间内有多少 $l,r$ 之间的数。

~~然后到这里就完了，随便莫队/主席树/树套树就行了~~

首先有一个显而易见的事实就是上面询问的答案就是 $\le r$ 的数的个数，
减 $\le l-1$ 的数的个数。

然后另一个显而易见的事实就是如果这个查询的区间是 $[x,y]$ 那么答案就是 $[1,y]-[1,x-1]$。

重点是第二点，满足区间可减性。

然后我们就可以使用一个小技巧：

我们将每个形如 $[x,y]$ 的询问拆成 $[1,y]-[1,x-1]$ 的形式，扫过去，然后对于形如 $[1,k]$ 的询问我们一起处理。

举个栗子（以求区间等于 $x$ 的数为例）：

```
n=5,m=3
1 2 3 2 1
1 5 3
1 5 2
1 5 1
```
这时候我们扫到了 $5$，发现了有三个对于 $5$ 的询问。

我们应该用什么维护 $[1,5]$ 中有多少个 $1,2,3$ 呢？数组计数！

那么现在是这个样子：

```
1 2 3
2 2 1
```
做完了。

也就是说再用一个数据结构，扫过去的同时不断加入 $a_k$ 的影响，然后查询所有形如 $[1,k]$ 的询问。

时间复杂度 $O(n\times \text{加入复杂度}+m\times \text{查询复杂度})$，空间复杂度 $O(n+m)$。

那么对于本题就应该用权值树状数组维护了。

注意离散化。

```cpp
#include<bits/stdc++.h>
#define lowbit(x) (x&-x)
using namespace std;
struct node
{
	int x,y;
	void get()
	{
		scanf("%d%d",&x,&y);
	}
}a[500005];
int h[1500005];
bool cmp(node x,node y)
{
	return x.x<y.x;
}
int le;
vector<pair<int,bool> > lx[1500005];
node x[500005],y[500005];
int t[1500005];
int l[500005],r[500005];
int ans[500005];
void add(int x,int v)
{
	for(;x<=le;x+=lowbit(x))
		t[x]+=v;
}
int ask(int x)
{
	int s=0;
	for(;x;x-=lowbit(x))
		s+=t[x];
	return s;
}
int main()
{
	int n,m,i,j,wz=0;
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++)
		a[i].get();
	for(i=0;i<m;i++)
		x[i].get(),y[i].get();
	sort(a+1,a+1+n,cmp);
	for(i=1;i<=n;i++)
		h[i]=a[i].y;
	wz=n;
	for(i=0;i<m;i++)
		h[++wz]=x[i].y,h[++wz]=y[i].y;
	sort(h+1,h+1+wz);
	le=unique(h+1,h+1+wz)-h-1;
	for(i=1;i<=n;i++)
		a[i].y=lower_bound(h+1,h+le+1,a[i].y)-h;
	for(i=0;i<m;i++)
		x[i].y=lower_bound(h+1,h+le+1,x[i].y)-h,y[i].y=lower_bound(h+1,h+le+1,y[i].y)-h;
	for(i=0;i<m;i++)
	{
		l[i]=lower_bound(a+1,a+1+n,x[i],cmp)-a,r[i]=upper_bound(a+1,a+1+n,y[i],cmp)-a-1;
		lx[l[i]-1].push_back({i,0});
		lx[r[i]].push_back({i,1});
	}
	for(i=1;i<=n;i++)
	{
		add(a[i].y,1);
		for(j=0;j<lx[i].size();j++)
		{
			wz=lx[i][j].first;
			if(lx[i][j].second==0)
				ans[wz]-=ask(y[wz].y)-ask(x[wz].y-1);
			else
				ans[wz]+=ask(y[wz].y)-ask(x[wz].y-1);
		}
	}
	for(i=0;i<m;i++)
		printf("%d\n",ans[i]);
}
```


---

## 作者：communist (赞：7)

#### 其实是不用把一个询问拆成四个的

把询问转化为数学语言：

对于每个查询，询问满足$a<=x<=b$且$c<=y<=d$的点$x,y$的个数

~~自然~~想到**偏序问题**，看到有两个式子，二维偏序？好像办不到，反正我不会

如何**升维**，拆分即可

把原式拆成$a<=x,x<=b,c<=y,y<=d$，这样就可以用四维偏序解决了，但是这样的复杂度显然是不能保证的

尝试**降维**

如果这样呢$a<=x,x<=b,c<=y<=d$

对于一个点，我们定义其三个维度为：

$a,b->x$即以横坐标作为第一维和第二维

$c->y$即以纵坐标作为第三维

而查询，依照上式，我们定义其维度

以$a$为第一维，$c$为第二维，$b,d$为三维和四维（查询用）

所以三维偏序的式子就是

$a_i<=a_j,b_i>=b_j,c_i<=c_j<=d_i$

考虑重复元素的贡献问题，记得排序时加上$c$相同，按$d$排

#### 上代码（其实是要写离散化的，但是我懒得写，拿$O2$替了）

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
const int maxn=5e5+10,maxl=1e7+10;
struct node{
    int a,b,c,d,w,mp;
}v[2*maxn];
int n,m,c[maxl],ans[maxn];
bool cmpy(const node &a,const node &b)
{
    return a.b==b.b?(a.c==b.c?a.d<b.d:a.c>b.c):a.b<b.b;
}
bool cmpx(const node &a,const node &b)
{
    return a.a==b.a?cmpy(a,b):a.a>b.a;
}
int lowbit(int x)
{
    return x&-x;
}
void add(int x,int ch)
{
    while(x<=maxl-9)
    {
        c[x]+=ch;
        x+=lowbit(x);
    }
}
int sum(int x)
{
    int ret=0;
    while(x)
    {
        ret+=c[x];
        x-=lowbit(x);
    }
    return ret;
}
void cdq(int l,int r)
{
    if(l==r)
        return;
    int mid=l+r>>1;
    cdq(l,mid),cdq(mid+1,r);
    sort(v+l,v+mid+1,cmpy),sort(v+mid+1,v+r+1,cmpy);
    int i=l,j=mid+1;
    for(;j<=r;j++)
    {
        while(v[i].b<=v[j].b&&i<=mid)
            add(v[i].c,v[i].w),i++;
        ans[v[j].mp]+=sum(v[j].d)-sum(v[j].c-1);
    }
    for(j=l;j<i;j++)
        add(v[j].c,-v[j].w);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&v[i].a,&v[i].c);
        v[i].a++,v[i].c++;
        v[i].b=v[i].a,v[i].w=1,v[i].d=v[i].mp=0;
    }
    for(int i=n+1;i<=n+m;i++)
    {
    	scanf("%d%d%d%d",&v[i].a,&v[i].c,&v[i].b,&v[i].d);
    	v[i].a++,v[i].b++,v[i].c++,v[i].d++;
    	v[i].w=0,v[i].mp=i-n;
	}
	sort(v+1,v+n+m+1,cmpx);
    cdq(1,n+m);
    for(int i=1;i<=m;i++)
        printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：HH_Halo (赞：5)

[另一种食用方式](https://www.cnblogs.com/hhhhalo/p/13811571.html)

## 题目描述
[这不是个链接](https://www.luogu.com.cn/problem/P2163)
## 思路分析
* 二维偏序题，常用方法为树状数组(~~然而常数有亿点大需要吸口氧~~)
* 为什么是二维偏序呢，因为显然对于一个点 $(x,y)$，其它点 $(i,j)$ ,只有同时满足 $i<x,j<y$ 才能产生贡献。对于每个 $(x,y)$ 我们只需查前面有多少个纵坐标小于 $y$ 的了，然后再更新一下，都可以用树状数组实现
* 但这题要求是一个矩阵范围内，可以类似于矩阵前缀和的处理，将矩阵拆成 $4$ 个点：$(c,d),(c,b-1),(a-1,d),(a-1,b-1)$。考虑有重复加减，最后的答案就是
$$
query(c,d)-query(c,b-1)-query(a-1,d)+query(a-1,b-1)
$$
* 还有一些细节就是，我们并不关心纵坐标的具体值，所以先将其离散化;查询拆成的坐标和树的坐标一起存储，一起排序，用一个 $flag$ 区分开是否是查询就好;因为每次查询拆成了四个点，所以加上不是查询的一共要开**五倍空间**，我因为这里一直 $RE$
## $Code$
```c++
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define N 2500005
#define R register
using namespace std;
inline int read(){
	int x = 0,f = 1;
	char ch = getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
int n,m,ed,b[N],c[N];
int ans[N][5],cnt[N];
inline void update(int x,int val){
	for(;x<=n;x+=x&(-x))c[x] += val;
}
inline int query(int x){
	int res = 0;
	for(;x;x-=x&(-x))res += c[x];
	return res;
}
struct data{
	int x,y,flag;
	data(){}
	data(int _x,int _y,int _flag){x = _x,y = _y,flag = _flag;}
	inline bool operator <(const data &a)const{
		if(x!=a.x)return x<a.x;
	    return y==a.y ? flag < a.flag : y < a.y;
	}
}tr[N<<1];
int main(){
	n = read(),m = read();
	for(R int i = 1;i <= n;i++){
		tr[i].x = read(),tr[i].y = read(),tr[i].flag = 0;
	}
	for(R int i = 1;i <= m;i++){
		int a = read(),b = read(),c = read(),d = read();
		tr[++n] = data(a-1,b-1,i);
		tr[++n] = data(c,d,i);
		tr[++n] = data(c,b-1,i);
		tr[++n] = data(a-1,d,i);
	}
	sort(tr+1,tr+1+n);
	for(R int i = 1;i <= n;i++)b[i] = tr[i].y;
	sort(b+1,b+1+n);
	ed = unique(b+1,b+1+n)-(b+1);
	for(R int i = 1;i <= n;i++){
		int tmp = lower_bound(b+1,b+1+ed,tr[i].y)-b;
		if(tr[i].flag)ans[tr[i].flag][++cnt[tr[i].flag]] = query(tmp);//用一个cnt方便记录是拆成的第几个点
		else update(tmp,1);
	}
	for(R int i = 1;i <= m;i++)printf("%d\n",ans[i][4]-ans[i][3]-ans[i][2]+ans[i][1]);
	return 0;
}
```

---

## 作者：Night_Aurora (赞：3)

对于$(x_1,y_1,x_2,y_2)$这个矩形内的散点

设F(x,y)是有多少个散点(a,b)满足a<=x且b<=y

那么这个矩形中点的数量=$F(x_2,y_2)-F(x_1-1,y_2)-F(x_2,y_1-1)+F(x_1-1,y_1-1)$

可以把一个查询换成四个更简单的查询

我们发现这就是一个二维偏序

我们可以给每个散点以及查询的x坐标离散化，通过树状数组离线维护每个的答案

复杂度4Nlogn，因为离散化什么的这题常数特别大

数据也特别大...

最后迫不得已排序用桶排(1E7的桶)

开两个桶来代替离散化的lower\_bound

才勉强A掉

另外感谢zhouyonglong大大放宽时限

[鄙人脏乱差的代码](http://paste.ubuntu.com/25444703/)


---

## 作者：BFqwq (赞：1)

# P2163
## 题面
求一个矩形的内点数
## 思考
这个题是个二维偏序模板题

首先，一个点可以被认为是一个二位前缀和

所以我们将一个查询拆为四个点

分别是(x1-1,y1-1),(x1-1,y2),(x2,y1-1),(x2,y2);

然后我们将y离散化

将所有点和查询依照X排序

依次扫过去

然后用一棵线段树（树状数组也行）维护此刻y方向的点

将扫到的点加入树中

## 代码
（楼主使用了一个splay来离散化）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1500005;
int f[N],cnt[N],value[N],sons[N][2],sub_size[N],whole_size,root,sumsize;
inline int read(){
    register int res=0,k=1;
    char c=getchar();
    while(!isdigit(c)){
        if(c=='-')k=-1;
        c=getchar();
    }
    while(isdigit(c)){
        res=(res<<1)+(res<<3)+c-48;
        c=getchar();
    }
    return res*k;
}
inline void S_Clear(int x){
    sons[x][0]=sons[x][1]=f[x]=sub_size[x]=cnt[x]=value[x]=0; 
} 
inline bool get_which(int x){
	return sons[f[x]][1]==x;
} 
inline void update(int x){
	if(x){
		sub_size[x]=cnt[x];
		if(sons[x][0]) sub_size[x]+=sub_size[sons[x][0]];  
		if(sons[x][1]) sub_size[x]+=sub_size[sons[x][1]];
	}
	return;
}  
inline void rotate(int x){
	int father=f[x],g_father=f[father],which_son=get_which(x);
	sons[father][which_son]=sons[x][which_son^1];
	f[sons[father][which_son]]=father;
	sons[x][which_son^1]=father;
	f[father]=x;
	f[x]=g_father;
	if(g_father){
		sons[g_father][sons[g_father][1]==father]=x;
	}
	update(father);
	update(x);
}
inline void splay(int x){
	for(int fa;fa=f[x];rotate(x))
		if(f[fa])
			rotate((get_which(x)==get_which(fa)?fa:x));
	root=x; 
}
inline void insert(int x){
	if(!root){
        whole_size++;
        sons[whole_size][0]=sons[whole_size][1]=f[whole_size]=0;
        root=whole_size;
        sub_size[whole_size]=cnt[whole_size]++;
        value[whole_size]=x;
        return ;
    } 
    int now=root,fa=0;
    while(1){
        if(x==value[now]){
        	sumsize--;
        	break; 
        }
        fa=now;
        now=sons[now][value[now]<x];
        if(!now){
            whole_size++;
            sons[whole_size][0]=sons[whole_size][1]=0;
            f[whole_size]=fa;
            sub_size[whole_size]=cnt[whole_size]=1;
            sons[fa][value[fa]<x]=whole_size;
            value[whole_size]=x;
            update(fa);
            splay(whole_size);
            break; 
        }
    }
} 
inline int find_rank(int x){
    int now=root,ans=0;  
    while(1){  
        if (x<value[now])  
          now=sons[now][0];  
        else{  
            ans+=(sons[now][0]?sub_size[sons[now][0]]:0);  
            if (x==value[now]){  
                splay(now); return ans+1;  
            }  
            ans+=cnt[now];  
            now=sons[now][1];  
        }  
    }  
} 
const int maxn=500005;
int sum[N<<2];
inline void pushup(int o){
	sum[o]=sum[o<<1]+sum[o<<1|1];
	return ;
}
inline void change(int o,int l,int r,int q,int k){
	if(l==r){
		sum[o]+=k;
		return ;
	}
	int mid=(l+r)>>1;
	if(q<=mid) change(o<<1,l,mid,q,k);
	if(q>mid) change(o<<1|1,mid+1,r,q,k);
	pushup(o);
}
int query(int o,int l,int r,int ql,int qr){
	if(ql<=l&&qr>=r)return sum[o];
	int ans=0;
	int mid=(l+r)>>1;
	if(ql<=mid) ans+=query(o<<1,l,mid,ql,qr);
	if(qr>mid) ans+=query(o<<1|1,mid+1,r,ql,qr);
	return ans;
}
int n,m,x[maxn],y[maxn],a[maxn],b[maxn],c[maxn],d[maxn],ans[maxn][4],tot;
struct _node{
	int x,y,o,wh;
	friend bool operator <(_node aa,_node bb){
		if(aa.x==bb.x) return aa.o<bb.o;
		return aa.x<bb.x;
	}
}node[maxn*5];
void work(){
	sort(node+1,node+tot+1);
	for(int i=1;i<=tot;i++){
		if(!node[i].o)change(1,1,sumsize,node[i].y,1);
		else{
			if(node[i].y==0) ans[node[i].o][node[i].wh]=0;
			else ans[node[i].o][node[i].wh]=query(1,1,sumsize,1,node[i].y);
		}
	}
}
int main(){
	n=read();m=read();
    for(int i=1;i<=n;i++){
    	x[i]=read();
    	y[i]=read();
    	insert(y[i]);
    	sumsize++;
	}
	for(int i=1;i<=m;i++){
		a[i]=read();
		b[i]=read();
		c[i]=read();
		d[i]=read();
		insert(b[i]-1);
		insert(d[i]);
		sumsize+=2;
	}
	for(int i=1;i<=n;i++){
		node[++tot].x=x[i];
		node[tot].y=find_rank(y[i]);
	}
	for(int i=1;i<=m;i++){
		node[++tot].x=a[i]-1;node[tot].y=find_rank(b[i]-1);node[tot].o=i;node[tot].wh=0;
		node[++tot].x=a[i]-1;node[tot].y=find_rank(d[i]);node[tot].o=i;node[tot].wh=1;
		node[++tot].x=c[i];node[tot].y=find_rank(b[i]-1);node[tot].o=i;node[tot].wh=2;
		node[++tot].x=c[i];node[tot].y=find_rank(d[i]);node[tot].o=i;node[tot].wh=3;
	}
	work();
	for(int i=1;i<=m;i++){
		printf("%d\n",ans[i][0]+ans[i][3]-ans[i][1]-ans[i][2]);
	}
    return 0;
}
```
祝大家csps.rp++


---

## 作者：x122 (赞：1)

## 看本题都是树状数组的题解，本蒟蒻来水一波线段树的题解
### 本题思路
![如图](https://i.loli.net/2019/07/07/5d218043a598612737.png)
  对于给定的矩形（红色），我们可以考虑其左边至纵坐标的一个矩形（绿色），用红色矩形和绿色矩形中所有的点（即树木）减去绿色矩形中的所有点（即树木），所得到的答案即为给定矩形中的数目个数。于是，我们可以先减去绿色矩形中点的树木，在加上绿色矩形与红色矩形中点的总数目。
  
  因此，我们可以用线段树+扫描线~~很轻松~~的过掉。
  
  注：红色矩形的左边即为绿色矩形的右边，少画了......
  
###   本题写法
先离散化，在从左往右运用扫描线，用线段树维护区间点的个数

## code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans[1000001],len[4000001];//len用来实现离散化
struct data{
    int x,y;
};
data xy[1000001];//记录点的坐标
struct data1{
    int p1,q1,p2,q2,f;
} num[1000001];//记录给定矩形的坐标
struct node{
    int sum;
} tree[4000001];
int cmp(const data &p,const data &q) {//按横坐标为点的坐标排序
    return p.x<q.x;
}
int cmp2(const data1 &p,const data1 &q) {
    return p.p1<q.p1;
}
int cmp3(const data1 &p,const data1 &q) {
    return p.p2<q.p2;
}
void push_up(int rt) {
    tree[rt].sum=tree[rt*2].sum+tree[rt*2+1].sum;
}
void add(int rt,int l,int r,int x) {  //加点
    if(l==r) {
        if(l==x) tree[rt].sum+=1;
        return ;
    }
    int mid=(l+r)/2;
    if(x<=mid) add(rt*2,l,mid,x);
    if(x>mid) add(rt*2+1,mid+1,r,x);
    push_up(rt);
}
int ask(int rt,int l,int r,int x,int y) { //求出当前矩形中点的总数
    if(x<=l && y>=r) {
        return tree[rt].sum;
    }
    int mid=(l+r)/2;
    int ret=0;
    if(x<=mid) ret+=ask(rt*2,l,mid,x,y);
    if(y>mid) ret+=ask(rt*2+1,mid+1,r,x,y);
    push_up(rt);
    return ret;
}
int main(){
    scanf("%d%d",&n,&m);
    int sum=0;
    for(int i=1;i<=n;i++) {
        scanf("%d%d",&xy[i].x,&xy[i].y);
        xy[i].x+=1;xy[i].y+=1;
        len[++sum]=xy[i].x;len[++sum]=xy[i].y;
    }
    for(int i=1;i<=m;i++) {
        int a,b,c,d;
        scanf("%d%d%d%d",&a,&b,&c,&d);
        a+=1;b+=1;c+=1;d+=1;
        num[i].p1=a;num[i].q1=b;num[i].p2=c;num[i].q2=d;num[i].f=i;
        len[++sum]=a;len[++sum]=b;
        len[++sum]=c;len[++sum]=d;
    } //离散化
    sort(len+1,len+sum+1);
    int size=unique(len+1,len+sum+1)-len-1;
    for(int i=1;i<=n;i++) {
        xy[i].x=lower_bound(len+1,len+size+1,xy[i].x)-len;
        xy[i].y=lower_bound(len+1,len+size+1,xy[i].y)-len;
    }
    for(int i=1;i<=m;i++) {
     	num[i].p1=lower_bound(len+1,len+size+1,num[i].p1)-len;
     	num[i].q1=lower_bound(len+1,len+size+1,num[i].q1)-len;
     	num[i].p2=lower_bound(len+1,len+size+1,num[i].p2)-len;
     	num[i].q2=lower_bound(len+1,len+size+1,num[i].q2)-len;
    }
    sort(xy+1,xy+n+1,cmp);
    sort(num+1,num+m+1,cmp2);
    int tot=0;
    for(int i=1;i<=m;i++) { //减去绿色矩形中点的数目
        while(num[i].p1>xy[tot+1].x && tot<=n) {
            tot+=1;
            add(1,1,n,xy[tot].y);
        }
        ans[num[i].f]-=ask(1,1,n,num[i].q1,num[i].q2);
    }
    memset(tree,0,sizeof(tree));
    sort(num+1,num+m+1,cmp3);
    tot=0;
    for(int i=1;i<=m;i++) {//加上红色矩形与绿色矩形中点的总数
        while(num[i].p2>=xy[tot+1].x && tot<=n) {
            tot+=1;
            add(1,1,n,xy[tot].y);
        }
        ans[num[i].f]+=ask(1,1,n,num[i].q1,num[i].q2);
    }
    for(int i=1;i<=m;i++)
        printf("%d\n",ans[i]);
    return 0;
}
```


---

## 作者：cirnovsky (赞：0)

。。。居然没有看到主席树题解。

这差不多就是一道主席树的板题了。

首先对x排序，然后动态开点一个一个的insert进去。

对于询问直接就二分取出横轴的范围l和r

然后询问root[r]-root[l-1]就好了

```cpp
#pragma GCC diagnostic error "-std=c++11"
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
#define ls (data[rt].l)
#define rs (data[rt].r)
#define SIZE_CHECKER(x, y) ((size[son[x]] < size[y]) && (son[x] = y))
#define PII pair < int , int >
#define PLL pair < LL, LL >
#define mid ((l + r) >> 1)
#define mp make_pair
#define fir first
#define sec second
#define pb push_back
#define R register

using namespace std;
#ifndef __int8
	typedef char __int8;
#endif
#ifndef __uint8
	typedef unsigned char __uint8;
#endif
#ifndef __int16
	typedef short __int16;
#endif
#ifndef __uint16
	typedef unsigned short __uint16;
#endif
#ifndef __int32
	typedef int __int32;
#endif
#ifndef __int64
	typedef long long __int64;
#endif
#ifndef __uint32
	typedef unsigned int __uint32;
#endif
#ifndef __uint64
	typedef unsigned long long __uint64;
#endif

#define io_e '\0'
#define io_s ' '
#define io_l '\n'
 #define _DEBUG_ 1 // debug toggle
namespace Fast_IO {
    #ifndef _DEBUG_
        #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
    #else
        #define gc() getchar()
    #endif
    const int SIZ = 1 << 21 | 1;
    char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c;
    int fr;
    inline void ioout() {
        fwrite(obuff, 1, oS - obuff, stdout);
        oS = obuff;
    }
    template <class Type>
    inline void read(Type& x) {
        x = 0;
        Type y = 1;
        for (c = gc(); (c > '9' || c < '0') && c ^ '-'; c = gc())
            ;
        c == '-' ? y = -1 : x = (c & 15);
        for (c = gc(); c >= '0' && c <= '9'; c = gc()) x = x * 10 + (c & 15);
        x *= y;
    }
    inline bool blank(char ch) { return ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t'; }
    inline void read(char* s) {
        register char ch = gc();
        for (; blank(ch); ch = gc())
            ;
        for (; !blank(ch); ch = gc()) *s++ = ch;
        *s = 0;
    }
    inline void read(char& c) {
        for (c = gc(); blank(c); c = gc())
            ;
    }
    template <typename Type, typename... Args>
    inline void read(Type& t, Args&... args) {
        read(t), read(args...);
    }
    template <typename... Args>
    inline void read(char* t, Args&... args) {
        read(t), read(args...);
    }
    template <typename... Args>
    inline void read(char& t, Args&... args) {
        read(t), read(args...);
    }
    template <class Type>
    inline void write(char lastChar, Type x) {
        if (x < 0)
            *oS++ = '-', x = -x;
        if (x == 0)
            *oS++ = '0';
        while (x) fu[++fr] = x % 10 + '0', x /= 10;
        while (fr) *oS++ = fu[fr--];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x[]) {
        for (register int i = 0; x[i]; ++i) *oS++ = x[i];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x) {
        *oS++ = x;
        *oS++ = lastChar;
        ioout();
    }
    template <typename Type, typename... Args>
    inline void write(char midChar, Type t, Args... args) {
        write(midChar, t), write(midChar, args...);
    }
}  // namespace Fast_IO

using Fast_IO::read;
using Fast_IO::write;

const int SIZE = 5e5 + 5;
const int INF = 1e7;
int n, m, tot, rt[SIZE];
struct TreeNode {
	int l, r;
	int sum;
} data[SIZE << 5];
struct TwoNode {
	int x, y;
} ints[SIZE];
struct BinarySeach {
	int upper_bound(int x) {
		int l = 1, r = n + 1;
		while (l < r - 1) if (ints[mid].x > x) r = mid; else l = mid;
		return l;
	}
	
	int lower_bound(int x) {
		int l = 0, r = n;
		while (l < r - 1) if (ints[mid].x >= x) r = mid; else l = mid;
		return r;
	}
} BS;

bool cmp(const TwoNode& x, const TwoNode& y) {
	return x.x < y.x;
}

void update(int &rt, int l, int r, int x) {
	data[++tot] = data[rt];
	++data[rt = tot].sum;
	if (l ^ r) if (mid >= x) update(ls, l, mid, x); else update(rs, mid + 1, r, x); else return ;
}

int queryf(int rt, int l, int r, int x, int y) {
	if (l > y || r < x || !rt) return 0;
	else if (l >= x && r <= y) return data[rt].sum;
	else return queryf(ls, l, mid, x, y) + queryf(rs, mid + 1, r, x, y);
}

signed main() {
	read(n, m);
	for (int i = 1; i <= n; ++i) read(ints[i].x, ints[i].y);
	sort(ints + 1, ints + 1 + n, cmp);
	for (int i = 1; i <= n; ++i) update(rt[i] = rt[i - 1], 0, INF, ints[i].y);
	for (int i = 1, a, b, c, d; i <= m; ++i) {
		read(a, b, c, d);
		write(io_l, queryf(rt[BS.upper_bound(c)], 0, INF, b, d) - queryf(rt[BS.lower_bound(a) - 1], 0, INF, b, d));
	}
	return 0;
}
```

---

## 作者：skylee (赞：0)

一眼看上去就很水啊。。坐标肯定是要离散化的。。询问跟着一起离散化。。然后以y为第一关键字，x为第二关键字排序。树状数组统计每个点左下角有多少个点。然后加加减减。。


离散化的细节貌似很恶心。。调着调着就A了。。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

char buf[20000000],*pt=buf,*o=buf;

inline int getint(){
    int s=0,f=1; while((*pt!='-')&&(*pt<'0'||*pt>'9'))pt++;
    if(*pt=='-')f=-1,pt++; while(*pt>='0'&&*pt<='9')s=s*10+*pt++-48; return s*f;
}
inline void print(int x){
    char str[30],*p=str; if(!x)*o++=48;
    else{ while(x) *p++=x%10+48,x/=10; while(p--!=str)*o++=*p;}
}

struct point{
    int x,y,id;
    point(){
        id = -1;
    };
    point(int _x,int _y,int _id){
        x = _x, y = _y, id = _id;
    }
}p[2800010];

bool cmp(point a,point b){
    if(a.y == b.y){
        if(a.x == b.x)  return a.id < b.id;
        else    return a.x < b.x;
    }
    return a.y < b.y;
}

int n,m,N,P,pc = 0;
int X[810000],Y[810000],bx[810000],by[810000],bit[2800000],cnt[2800000];

void upd(int x){
    for(;x <= N;x += x & -x)    bit[x] ++;
}
int query(int x){
    int r = 0;
    for(;x;x -= x & -x) r += bit[x];
    return r;
}

int main(){
    fread(buf,1,20000000,stdin);
    n = getint(); m = getint();
    bx[0] = by[0] = 0;
    N = n + 1;
    P = (m << 2) + n;
    bx[N] = by[N] = 12345678;
    
    for(int i = 1;i <= n;i ++){
        X[i] = getint();
        Y[i] = getint();
        bx[i] = ++ X[i];  
        by[i] = ++ Y[i];
    }
    sort(bx + 1, bx + n + 1);
    sort(by + 1, by + n + 1);
    int cx = unique(bx , bx + n + 2) - bx -1;
    int cy = unique(by , by + n + 2) - by -1;
    for(int i = 1;i <= n;i ++){
        p[(m << 2) + i - 1].x = upper_bound(bx,bx + cx,X[i]) - bx;
        p[(m << 2) + i - 1].y = upper_bound(by,by + cy,Y[i]) - by;
    }
    int x1,y1,x2,y2,X1,X2,X3,Y1,Y2,Y3;
    for(int i = 1;i <= m;i ++){
        x1=  getint(); y1=getint();x2=getint();y2=getint();
        X1 = upper_bound(bx,bx + cx,x1) - bx;
        X2 = upper_bound(bx,bx + cx,x2) - bx;
        X3 = upper_bound(bx,bx + cx,x2 + 1) - bx;
        Y1 = upper_bound(by,by + cy,y1) - by;
        Y2 = upper_bound(by,by + cy,y2) - by;
        Y3 = upper_bound(by,by + cy,y2 + 1) - by;
        p[pc] = point(X3,Y3,pc ++);
        p[pc] = point(X1,Y3,pc ++);
        p[pc] = point(X3,Y1,pc ++);
        p[pc] = point(X1,Y1,pc ++);
    }
    
    sort(p,p + P,cmp);
    for(int i = 0;i < P;i ++){
        if(~ p[i].id)   cnt[p[i].id] = query(p[i].x);
        else    upd(p[i].x);
    }
    
    for(int i = 1;i <= m;i ++)
       print(cnt[i - 1 << 2] - cnt[(i - 1 << 2) + 1] - cnt[(i - 1 << 2) + 2] + cnt[(i - 1 << 2) + 3]),*o++='\n';
        
    return fwrite(buf,1,o-buf,stdout),0;
}
```

---

## 作者：abs001 (赞：0)

提供一种扫描线做法

首先肯定是要离散化的，之后将点与所求矩形按x排序，就可以用线段树写了

可以先看这道：[P1856 [USACO5.5]矩形周长Picture](https://www.luogu.org/problemnew/show/P1856)

注意：对于一个矩形的处理中要先将第二条边结算掉

对于一个矩形的上边与下边，要分别记下当时的区间和，最后做差就是答案。

代码：

```cpp
#include<bits/stdc++.h>
#define N 500001
#define rint register int 
using namespace std;

struct node{
    int x, y, y2, z, ans, num;
    bool operator < (const node &a) const
    {
        return x < a.x || (x == a.x && z < a.z);
    }
}q[N * 2];

struct data{
    int x, y;
    bool operator < (const data &a) const
    {
        return x < a.x;
    }
}d[N];

int n, m, l1, l2;
int tx[3 * N], ty[3 * N], tree[N << 2];

void read(rint &a)
{
    int res = 0, zf = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9')
    {
        ch = getchar();
        if(ch == '-') zf = -1;
    }
    while(ch >= '0' && ch <= '9') res = res * 10 + ch - '0', ch = getchar();
    a = res * zf;
}

void out(rint a)
{
    if(a < 10)
    {
        putchar(a % 10 + '0');
        return;
    }
    out(a / 10);
    putchar(a % 10 + '0');
}

int js(rint x)
{
    return (x & -x);
}

int lower_bound(rint *a, rint l, rint r, rint x)//手写，不然超时
{
    while(l <= r)
    {
        rint mid = (l + r) >> 1;
        if(a[mid] > x) r = mid - 1;
        else if(a[mid] < x) l = mid + 1;
        else return mid;
    }
    return -1;
}

void zx(rint &x)
{
    x = lower_bound(tx, 1, l1, x);
}

void zy(rint &y)
{
    y = lower_bound(ty, 1, l2, y);
}

void change(rint x, rint y)
{
    for(; x <= n; x += js(x))
        tree[x] += y;
}

int query(rint x)
{
    int ret = 0;
    for(; x; x -= js(x)) ret += tree[x];
    return ret;
}

bool cmp(node l, node r)
{
    return l.num < r.num;
}

int main()
{
    read(n), read(m);
    for(rint i = 1; i <= n; i++) read(d[i].x), read(d[i].y), tx[++l1] = d[i].x, ty[++l2] = d[i].y;
    for(rint i = 1; i <= m; i++)
    {
        read(q[i].x), read(q[i].y), read(q[m + i].x), read(q[m + i].y2);
        q[i].z = 1, q[m + i].z = 2, q[i].num = m + i, q[m + i].num = i;
        q[i].y2 = q[m + i].y2, q[m + i].y = q[i].y;
        tx[++l1] = q[i].x, tx[++l1] = q[m + i].x;
        ty[++l2] = q[i].y, ty[++l2] = q[m + i].y2;
    }
    sort(tx + 1, tx + l1 + 1), sort(ty + 1, ty + l2 + 1);
    l1 = unique(tx + 1, tx + l1 + 1) - tx - 1, l2 = unique(ty + 1, ty + l2 + 1) - ty - 1;
    //离散化
    for(rint i = 1; i <= n; i++) zx(d[i].x), zy(d[i].y);
    for(rint i = 1; i <= 2 * m; i++) zx(q[i].x), zy(q[i].y), zy(q[i].y2);
    sort(d + 1, d + n + 1), sort(q + 1, q + m + m + 1);
    for(rint i = 1, j = 1; j <= 2 * m; )
    {
        if(q[j].z == 2)//第二条边
        {
            if(i <= n && d[i].x <= q[j].x) change(d[i].y, 1), i++;
            else q[j].ans = query(q[j].y2) - query(q[j].y - 1), j++;
        }
        else//第一条边
        {
            if(i <= n && d[i].x < q[j].x) change(d[i].y, 1), i++;
            else q[j].ans = query(q[j].y2) - query(q[j].y - 1), j++;
        }
    }
    sort(q + 1, q + m + m + 1, cmp);
    for(rint i = 1; i <= m; i++) out(q[i].ans - q[m + i].ans), putchar('\n');
    return 0;
}
```


---


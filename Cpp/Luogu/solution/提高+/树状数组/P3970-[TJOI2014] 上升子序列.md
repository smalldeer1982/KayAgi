# [TJOI2014] 上升子序列

## 题目描述

给定一个只包含整数的序列(序列元素的绝对值大小不超过10^9),你需要计算上升子序列的个数,满足如下条件的称之为一个上升子序列:

1. 是原序列的一个子序列

2. 长度至少为2

3. 所有元素都严格递增

如果两个上升子序列相同,那么只需要计算一次。例如:序列{1,2,3,3}有4个上升子序列,分别为{1,2}{1,3},{1,2,3},{2,3}


## 说明/提示

### 数据范围

对于 30% 的数据，N ≤ 5000

对于 100% 的数据，N ≤ 10^5


## 样例 #1

### 输入

```
4
1 2 3 3```

### 输出

```
4```

# 题解

## 作者：asuldb (赞：23)

这本质上是一个$dp$

如果没有"两个上升子序列相同,那么只需要计算一次"这一个性质，那么就很好做了，我们用$dp[i]$表示以$i$结尾的上升子序列个数，那么就有$dp[i]=\sum_{j=1}^{i-1}dp[j]$

这个暴力转移是$O(n^2)$的，我们这里可以直接用树状数组来优化，于是就变成了$O(nlogn)$

同时由于数字可能非常大，所以需要离散化

之后再来考虑一下如何去重

首先重复的情况肯定是来自于一个之前已经出现过的数，而这个出现的数又将所有之前那个点算出来的答案又都加了一遍，这样就会有重复的了

那我们怎么去掉这些重复的情况呢

首先直接不考虑这个再次出现的数是肯定不对的，**如果这个数和它之前出现的那个位置之间有一些比这个数小的的数，那么这些就就没有被计入答案，于是就错了**

但是我们可以对每一个数维护一个$lastans[i]$，表示$i$这个数上次被计入答案的时候$\sum_{j=1}^{i-1}dp[j]$是多少，之后我们还是用树状数组来查询前缀和，之后我们计入答案的应该就是这次查询出来的答案减去$lastans$，也就是表示新增的上升子序列的个数是多少，之后我们再把这个数加入树状数组

代码
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<map>
#include<algorithm>
#define re register
#define lowbit(x) ((x)&(-(x)))
#define maxn 100005
#define LL long long
#define int long long
const LL mod=1e9+7;
std::map<LL,LL> ma;
LL c[maxn];
int n;
LL a[maxn],b[maxn];
LL lastans[maxn];
int f[maxn];
inline LL read()
{
	char c=getchar();
	LL x=0,r=1;
	while(c<'0'||c>'9') 
	{
		if(c=='-') r=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	  x=(x<<3)+(x<<1)+c-48,c=getchar();
	return x*r;
}
inline void add(int x,LL v)
{
	for(re LL i=x;i<=n;i+=lowbit(i))
		c[i]=(c[i]+v)%mod;
}
inline LL query(LL x)
{
	LL ans=0;
	for(re LL i=x;i;i-=lowbit(i))
		ans=(ans+c[i])%mod;
	return ans;
}
signed main()
{
	n=read();
	for(re int i=1;i<=n;i++) a[i]=b[i]=read();
	std::sort(b+1,b+n+1);
	int tot=std::unique(b+1,b+1+n)-b-1;
	for(re int i=1;i<=tot;i++)
		ma[b[i]]=i;
	LL cnt=0;
	for(re int i=1;i<=n;i++)
	{
		int j=ma[a[i]];
		if(!f[j])
		{
			LL mid=query(j-1);
			cnt=(cnt+mid)%mod;
			add(j,mid+1);
			lastans[j]=mid;
			f[j]=1;
			continue;
		}
		LL mid=query(j-1);
		cnt=(cnt+mid-lastans[j]+mod)%mod;
		add(j,(mid-lastans[j]+2*mod)%mod);
		lastans[j]=mid;
	}
	std::cout<<cnt;
	return 0;
}
```

---

## 作者：Deu5ExMach1na (赞：18)

## 关于此题的一个新的方法：




此题其实不需要其他题解的 $ last$ 数组来记录什么的，整体代码长度也比较短。


关键部分的代码：

```cpp
  for (int i = 1; i <= n; i++) {
    int val = ask(num[i]) - ask(num[i] - 1);
    add(num[i], ask(num[i] - 1));
    if (val) add(num[i], -val + 1);
    else add(num[i], 1);
  }
```

解释如下：

$num[i] $ 储存的是原来序列的数，

$add()$，$ask()$  对应的是树状数组的基操，

对于如何建立树状数组，我们可以这样来考虑：

建立数组 $c[i]$ 保存**当前以 $i$ 结尾的上升子序列的集合的元素个数**。


------------


如何维护 $c[i]$？：

1.遍历 $num[]$。

2.如果当前的数对应的集合为空，则要将 $ c[i] $ 加一，让它变成 $ \{i\}$ 只有一个 $i$ 元素，方便后续转移。
 
3.遍历到 $i$ 时，我们将它加上 $c[1]$ 到 $c[num[i]-1]$ 的和，这应该是比较好理解的，
但是若 $c[i]$ 本身有值，我们会发现出现了重复，此时把 $c[i]$ 对应集合的元素全重新计算了一遍，所以要**减去 $c[i]$ 原本的值**。

4.注意 $\{i\}$ 没有被重复计算，所以还要 $+1$。


------------


所以答案就是：

`
cout << ask(m) - m;
`

因为 $\{i\}$ 不算做上升序列。

CODE：
```cpp
#include <bits/stdc++。h>
#define int long long
#define mod 1000000000 + 7
#define N 100007
using namespace std;

int n, m;
int num[N], c[N], ls[N];

void add(int x, int v) {
  for (; x <= m; x += x & -x) { c[x] += v; c[x] %= mod; }
}

int ask(int x) {
  int ret = 0;
  for (; x; x -= x & -x) { ret += c[x]; ret %= mod; }
  return ret;
}

signed main() {
  ios::sync_with_stdio(false);
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> num[i];
    ls[i] = num[i];
  }

  sort(ls + 1, ls + n + 1);
  m = unique(ls + 1, ls + n + 1) - (ls + 1);
  for (int i = 1; i <= n; i++)
    num[i] = lower_bound(ls + 1, ls + 1 + m, num[i]) - ls;

  for (int i = 1; i <= n; i++) {
    int val = ask(num[i]) - ask(num[i] - 1);
    add(num[i], ask(num[i] - 1));
    if (val) add(num[i], -val + 1);
    else add(num[i], 1);
  }
  cout << ask(m) - m;

  return 0;
}
```



---

## 作者：_JF_ (赞：9)

[Link](https://www.luogu.com.cn/problem/P3970)

这题在省选算是简单的吧。

看了一圈题解，好像大家都去重了，写一个不用去重的抽象做法。

先离散化，设 $dp_i$ 表示**以 $i$ 这个数**为结尾的子序列最多有多少个。

然后直接枚举 $[1,i-1]$ 的数转移即可，发现可以线段树优化到单次 $O(\log n)$。

但是题目要求不重复。

一个重要的观察：对于两个相同的数 $a_j$ 和 $a_i$，其中 $j<i$，以 $i$ 这个位置为结尾的子序列一定是要不少于以 $j$ 这个位置为结尾的子序列个数。

原因显然，因为以 $j$ 这个位置为的所有子序列去掉 $a_j$，完全可以换上 $a_i$ 代替，相当于 $a_i$ 的答案覆盖了 $a_j$，所以是不少于。

既然 $a_i$ 可以覆盖到 $a_j$ 的答案，由此可以得出一个结论，就是对于 $a_i$ 这个数，它一定覆盖了前面等于他的所有数的答案。对于 $a_i$ 后面的数，我们只用关心 $a_i$ 即可。

那就解决了重复的问题了，对于当前的数，我们只用统计当前前面出现过且小于的数的答案即可，并且更新当前数对应的 $dp$ 值。可以直接更新的原因是具有单调性。

注意初始化要为 $1$，就当长度为 $1$ 的也算进去，为了后面统计的时候有值。最后再减去即可。

警钟敲烂：在取模的情况下不能用取最大值或最小值，这都是不准的。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =1e6+10;
const int mod=1e9+7;
#define int long long 
struct node{
	int val,id;
}a[N];
int dp[N],lst[N],c[N],d[N<<1];
bool cmp(node a,node b){
	return a.val<b.val;
}
int Query(int l,int r,int s,int t,int p){
	if(l<=s&&t<=r)	return d[p];
	int mid=(s+t)>>1,sum=0;
	if(l<=mid)	sum+=Query(l,r,s,mid,p<<1),sum%=mod;
	if(r>mid)	sum+=Query(l,r,mid+1,t,p<<1|1),sum%=mod;
	return sum;	
}
void update(int l,int r,int change,int s,int t,int p){
	if(l<=s&&t<=r){
		d[p]+=change,d[p]%=mod;
		return ;
	}
	int mid=(s+t)>>1;
	if(l<=mid)	update(l,r,change,s,mid,p<<1);
	if(r>mid)	update(l,r,change,mid+1,t,p<<1|1);
	d[p]=(d[p<<1]+d[p<<1|1])%mod;
	return ;
}
signed main()
{
//		freopen("1.in","r",stdin);
//	freopen("ans1.out","w",stdout);
	int n,node=1;
	cin>>n;
	for(int i=1;i<=n;i++)	cin>>a[i].val,a[i].id=i;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		if(i==1)	node++;
		else if(a[i].val!=a[i-1].val)	node++;
		c[a[i].id]=node;
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		int now=Query(1,c[i]-1,1,n,1);
		update(c[i],c[i],now+1-dp[c[i]],1,n,1),dp[c[i]]=now+1,dp[c[i]]%=mod;	
	}
	for(int i=2;i<=node;i++)	
		ans+=dp[i]-1,ans%=mod;
	cout<<ans<<endl;
	return 0;
}

```


---

## 作者：SDqwq (赞：4)

## $\texttt{Description}$

求序列中长度 $>1$ 的本质不同的上升子序列数量。

$\texttt{Data Range:}1\le n\le10^5$

## $\texttt{Solution}$

先看如果不管算重的情况。

考虑朴素 dp。

设 $f_i$ 表示以序列第 $i$ 个元素结尾的上升子序列数量。

不难得到转移：

$$f_i=\sum\limits_{j=1}^{i-1}f_j(a_j<a_i)$$

时间复杂度 $\mathcal{O}(n^2)$

二维偏序容易想到用树状数组进行优化。

时间复杂度 $\mathcal{O}(n\log n)$

接下来考虑如何去重。

容易想到上升子序列的一个性质：对于序列中元素值相同的情况，以最后一个该值出现的位置为结尾的上升子序列一定包含了以前面结尾的上升子序列。这非常的直观。

知道了这个性质，我们就可以使用一个 $\mathrm{vector}$ 来维护每种元素值对应的所有 dp 值。

然后我们算最终答案时，直接枚举结尾的数，然后在其对应的 $\mathrm{vector}$ 中取出最后一个的 dp 值即可。

但是还有一个问题，就是我们转移的时候也会算重。

我们发现，由于以同一个值结尾的上升子序列在树状数组中加了多次，所以导致重复。

那么我们很自然地想到每次新加入一个 dp 值到树状数组中时，先在树状数组中减去上一个以相同的值结尾的 dp 值，这样保证了树状数组维护的永远是当前 $\mathrm{vector}$ 中的最后一个 dp 值，就不会算重了。

## $\texttt{Code}$

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
typedef long long ll;
const ll mod = 1e9 + 7;
inline ll mymod(ll x, ll y) {return ((x % y) + y) % y;}

int a[100005], b[100005];
ll dp[100005];
vector<ll> vec[100005];

struct BIT {
	ll c[100005];
	
	inline void update(int x, ll d) {
		for (int i = x; i <= 1e5; i += i & -i) c[i] = mymod(c[i] + d, mod);
	}
	
	inline ll query(int x) {
		ll res = 0;
		for (int i = x; i; i -= i & -i) res = mymod(res + c[i], mod);
		return res;
	}
} bit;

int main() {
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]), b[i] = a[i];
	sort(b + 1, b + 1 + n);
	for (int i = 1; i <= n; i++) a[i] = lower_bound(b + 1, b + 1 + n, a[i]) - b, dp[i] = 1;
	for (int i = 1; i <= n; i++) {
		if (vec[a[i]].size()) bit.update(a[i], -vec[a[i]][vec[a[i]].size() - 1]);
		dp[i] = (dp[i] + bit.query(a[i] - 1)) % mod;
		bit.update(a[i], dp[i]);
		vec[a[i]].push_back(dp[i]);
	}
	ll ans = 0;
	for (int i = 1; i <= n; i++) {
		if (!vec[i].size()) continue;
		ans = (ans + vec[i][vec[i].size() - 1]) % mod;
		ans = mymod(ans - 1, mod);
	}
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：Tx_Lcy (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P3970)
## 思路
板子题，应该是属于省选题中比较水的题。

题目要求各个上升子序列互不相同，如果忽略这个限制，那么是一个树状数组的板子，如果加上这个限制，似乎也没有难做很多。

我们设 $did_i$ 表示值为 $i$ 的数是否出现过，注意由于值域较大，需要离散化。

+ 若 $did_i=1$，我们再记一个 $lastans_i$ 表示上一个值为 $i$ 的数的 $f_i$ 的值是多少，此时树状数组 $\verb!update!$ 就只能 $\verb!update!$ $f_i-lastans_i$，更新一下 $lastans_i$。

+ 若 $did_i=0$，更加好做，直接 $\verb!update!$ $f_i+1$，然后记一下 $did_i$ 和 $lastans_i$ 即可。

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int const N=1e6+10;
int const mod=1e9+7;
int a[N],b[N],f[N],n,lastans[N],did[N];
struct Tree_Array{
    int c[N];
    inline int lowbit(int x){return x&-x;}
    inline void update(int x,int v){while (x<=n) c[x]+=v,c[x]%=mod,x+=lowbit(x);}
    inline int query(int x){int res=0;while (x) res+=c[x],res%=mod,x-=lowbit(x);return res;}
}T;//树状数组板子，不再赘述
signed main(){
    ios::sync_with_stdio(false);
    cout.tie(0),cout.tie(0);
    cin>>n;int ans=0;
    for (int i=1;i<=n;++i) cin>>a[i],b[i]=a[i];
    sort(b+1,b+n+1);int l=unique(b+1,b+n+1)-b-1;
    for (int i=1;i<=n;++i) a[i]=lower_bound(b+1,b+l+1,a[i])-b;
    for (int i=1;i<=n;++i){
        f[i]=T.query(a[i]-1);
        if (did[a[i]]) T.update(a[i],(f[i]-lastans[a[i]]+mod+mod)%mod);
        else T.update(a[i],(f[i]+1)%mod),did[a[i]]=1;
        f[i]%=mod;
        ans+=((f[i]-lastans[a[i]])%mod+mod)%mod;
        ans%=mod;
        lastans[a[i]]=f[i];
    }
    cout<<ans<<'\n';
    return 0;
}
```


---

## 作者：LlLlCc (赞：3)

一个比较巧妙的$DP$

不妨设：

$\large f_i:$以第$i$个数为结尾的递增序列数

如果没有那个去重的限制的话，那么$f_i$非常好求：

$\large f_i=\sum\limits_{j=1}^i f_j(a_j<a_i)$

直接套权值线段树或者树状数组优化就好了

考虑加上去重的限制

很明显，如果$k_1<k_2$，那么$f_{k_1}\leq f_{k_2}$且所有以$k_1$为结尾的序列都可以以$k_2$结尾，即$f_{k_1}$可以舍弃，保留$f_{k_2}$就好了，也就是说从一枚举到$n$，出现重复的数就把之前那个数在权值线段树中的值覆盖

## code
```
#include<bits/stdc++.h>
#define maxn 100005
#define ll long long
using namespace std;
const ll TT=1e9+7;
int n,A[maxn],x,tot,c[maxn],L,R;
ll Ans,f[maxn];
bool vis[maxn];
struct lc{
	int x,id;
	bool operator <(const lc b)const{return x<b.x;}
}a[maxn];
struct Lc{
	int L,R;
	ll x;
}tree[maxn<<2];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-f;ch=getchar();}
	while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
inline int get(int x){int sum=0;for (;x;x-=x&-x) sum+=c[x];return sum;}
inline void change(int x){for (;x<=n;x+=x&-x) c[x]++;}
inline void build(int k,int L,int R){
	tree[k].L=L,tree[k].R=R;
	if (L==R) return;
	int mid=L+R>>1;
	build(k<<1,L,mid);build(k<<1|1,mid+1,R);
}
inline ll Get(int k){
	if (L<=tree[k].L&&tree[k].R<=R) return tree[k].x;
	int mid=tree[k].L+tree[k].R>>1;ll sum=0;
	if (L<=mid) sum=Get(k<<1);
	if (R>mid) sum+=Get(k<<1|1);
	return sum%TT;
}
inline void Change(int k,int x,ll y){
	if (tree[k].L==tree[k].R){tree[k].x=y;return;}
	int mid=tree[k].L+tree[k].R>>1;
	if (x<=mid) Change(k<<1,x,y);
	else Change(k<<1|1,x,y);
	tree[k].x=(tree[k<<1].x+tree[k<<1|1].x)%TT;
}
int main(){
	n=read();
	for (int i=1;i<=n;i++) x=read(),a[i]=(lc){x,i};
	sort(a+1,a+n+1);
	for (int i=1;i<=n;i++){
		if (a[i].x!=a[i-1].x||i==1) tot++;
		A[a[i].id]=tot;
	}
	build(1,1,tot);
	for (int i=1;i<=n;i++){
		f[i]=get(A[i]-1);
		if (!vis[A[i]]) change(A[i]),vis[A[i]]=1;
		L=1,R=A[i]-1;f[i]=(f[i]+Get(1))%TT;Change(1,A[i],f[i]);
	}
	L=1,R=tot;
	printf("%lld",Get(1));
	return 0;
}
```


---

## 作者：hsfzLZH1 (赞：3)

50分解法：简单DP

假设一个已经去过重的数列a[1],a[2],...,a[m]

定义f[i]为以i为结尾的上升子序列的个数（包括长度为1的），那么初始值为f[i]=1，状态转移方程为：

f[i]=(f[i]+f[j])%mod  i>j&&a[i]>a[j]

转移方法：i从1...m，j从1...n-1，时间复杂度O(N^2)，期望得分50分。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=5010;
const int mod=1000000007;
int n,m=1,a[maxn],f[maxn],ans;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++,m++)
    {
        scanf("%d",a+m);
        if(m!=1&&a[m]==a[m-1])m--;
    }
    for(int i=1;i<m;i++)
    {
        f[i]=1;
        for(int j=1;j<i;j++)if(a[j]<a[i])f[i]=(f[i]+f[j])%mod;
        ans=(ans+f[i]-1)%mod;
    }
    printf("%d\n",ans);
    return 0;
}
```
100分解法：排序去重离散化+线段树

在线段树上维护一个值f[i]，代表以a[i]为结尾的上升子序列个数，为了方便，可以把长度为1的也统计进去。

那么f[a[i]]的值可以由f[a[1]]...f[a[i]-1]推出，那么

f[a[i]]=sigma{f[a[j]]}j:1...i-1

我们在线段树上查询值为[1,a[i]-1]的和即可，最后用单点修改把结果赋值为a[i]

最后我们依次查询a[i]并累加，注意用完之后a[i]清零，避免重复计算

最后累加的和即为答案

有几点需要注意的：

1，快读，inline，register

2，线段树的查询操作不要写成传值（返回值为int的），这样太慢

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=100010;
const int mod=1000000007;
struct node{int x,y;bool operator<(node a)const{return x<a.x;}}s[maxn];
int n,tot=1,ans,sum,f[maxn<<2],b[maxn];
inline void query(int o,int l,int r,int x,int y)//线段树查询操作，x,y为查询边界，l,r为当前边界
{
    int lc=o<<1,rc=o<<1|1;//位运算计算左右子节点值
    if(l==x&&r==y)//落在一点上
    {
        ans=(ans+f[o])%mod;
        return;
    }
    int mid=(l+r)>>1;//讨论左右子
    if(y<=mid)query(lc,l,mid,x,y);
    else if(x>mid)query(rc,mid+1,r,x,y);
    else
    {
        query(lc,l,mid,x,mid);
        query(rc,mid+1,r,mid+1,y);
    }
}
inline void update(int o,int l,int r,int x,int y)//线段树的更新操作，同上
{
    int lc=o<<1,rc=o<<1|1;
    if(l==r)
    {
        f[o]=y;
        return;
    }
    int mid=(l+r)>>1;
    if(x<=mid)update(lc,l,mid,x,y);
    else update(rc,mid+1,r,x,y);
    f[o]=(f[lc]+f[rc])%mod;
}
inline int read()//快读
{
    int data=0,w=1;
    char ch=0;
    while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
    if(ch=='-')ch=getchar(),w=-1;
    while(ch>='0'&&ch<='9')data=data*10+ch-'0',ch=getchar();
    return data*w;
}
int main()
{
    int n=read();
    for(int i=1;i<=n;i++)s[i].y=i,s[i].x=read();//读入，编码，方便排序
    sort(s+1,s+1+n);//按x的值从小到大排序
    for(int i=1;i<=n;i++)//去重
    {
        if(s[i].x!=s[i-1].x)tot++;
        b[s[i].y]=tot;//b代表更新后的顺序值
    }
    for(int i=1;i<=n;i++)//计算f[a[i]]
    {
        ans=0;
        if(b[i]>1)query(1,1,tot,1,b[i]-1);
        update(1,1,tot,b[i],ans+1);
    }
    for(int i=1;i<=n;i++)//统计答案
    {
        ans=0;
        query(1,1,tot,b[i],b[i]);
        if(ans)//必须要有才统计和更新
        {
            sum=(sum+ans-1)%mod;//去掉重复
            update(1,1,tot,b[i],0);
        }
    }
    printf("%d\n",sum);
    return 0;
}
```
此题同样可以用树状数组解决，常数更小，再次不多做赘述。


---

## 作者：Little09 (赞：2)

之前莫名其妙一直 $80$ 分，今天突然看到这题，就顺手把它过了。

首先不考虑去重和长度大于 $1$，上升子序列个数还是很好求的，大概是 DP 设 $dp_i$ 表示以 $a_i$ 结尾的上升子序列个数。转移方程大致如下：

$$dp_i=1+\sum_{j=1}^{i-1}dp_j[a_j<a_i]$$

容易用树状数组或线段树优化至 $O(n\log n)$。接下来主要去重的问题。

容易发现的是，如果存在 $i,j(i<j)$ 满足 $a_i=a_j$，那么对于后面一个点 $k(j<k)$ 的贡献应当只计算 $j$ 提供的而不计算 $i$ 的。所以在计算完 $j$ 的 $dp_j$ 后，在树状数组中要把 $dp_i$ 给减掉。这样就不会算重了。

我们可以预处理出每一个 $a_j$ 前面第一个和它相等的位置 $a_j$。这样就可以树状数组了。

最后在减去长度为 $1$ 的情况。注意要离散化。

代码比较奇怪（离散化用的 map），请理性参考。

```cpp
// By: Little09
// Problem: P3970 [TJOI2014]上升子序列
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3970
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
using namespace std;
#define ll long long
int n;
const ll mod=1000000007;
const int N=500005;
ll tree[N];
ll a[N],b[N],dp[N];
int used[N],pre[N];
int cnt;
map<int,int>q;
inline int lowbit(int x)
{
	return x&(-x);
}
inline void add(int x,ll k)
{
	for (;x<=n;x+=lowbit(x)) tree[x]=(k+tree[x])%mod;
}
inline ll ask(int x)
{
	ll ans=0;
	for (;x;x-=lowbit(x)) ans=(tree[x]+ans)%mod;
	return ans;
}
inline int read()
{
    int F=1,ANS=0;
	char C=getchar();
    while (C<'0'||C>'9')
	{
		if (C=='-') F=-1;
		C=getchar();
	}
    while (C>='0'&&C<='9')
	{
		ANS=ANS*10+C-'0';
		C=getchar();
	}
    return F*ANS;
}
int main()
{
	n=read();
	for (int i=1;i<=n;i++) b[i]=a[i]=read();
	sort(b+1,b+n+1);
	for (int i=1;i<=n;i++)
	{
		if (i==1||b[i]!=b[i-1]) q[b[i]]=++cnt;
	}
	for (int i=1;i<=n;i++) 
	{
		int u=q[a[i]];
		pre[i]=used[u];
		a[i]=u;
		used[u]=i;
	}
	dp[1]=1;
	add(a[1],1);
	for (int i=2;i<=n;i++)
	{
		if (pre[i]==0) 
		{
			dp[i]=(ask(a[i]-1)+1)%mod;
			add(a[i],dp[i]);
		}
		else 
		{
			dp[i]=(ask(a[i]-1)+1)%mod;
			add(a[i],dp[i]-dp[pre[i]]);
		}
	}
	ll ans=ask(n);
	for (int i=1;i<=n;i++) ans=(ans-(pre[i]==0));
	cout << ans;
	return 0;
}
```



---

## 作者：FlyInTheSky (赞：2)


这题没有去重就是裸的 LIS 方案数

考虑树状数组维护以某个权值结尾的方案数

从左到右扫描，每次找左边比这个数权小的方案数，然后**直接覆盖当前权的方案**，因为这样就可以去除和前面一个相同权值的重复的部分。

为了方便起见，将长度为 1 的 LIS 先算作其内，之后再减掉即可。

~~我没取模爆成20分以为自己写挂了丢人~~

```c++
#include<cstdio> 
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<map>
#define ms(i, j) memset(i, j, sizeof i)
#define LL long long
#define db long double
#define fir first
#define sec second
#define mp make_pair
using namespace std;

namespace flyinthesky {

    const LL MAXN = 100000 + 5, MO = 1e9 + 7;
    
    LL n, a[MAXN], tax[MAXN], tot_tax, c[MAXN], lst[MAXN];
    LL lowbit(LL x) {return x & (-x);}
    void add(LL x, LL v) {while (x <= n) c[x] = (c[x] + v) % MO, x += lowbit(x);}
    LL query(LL x) {LL ret = 0; while (x > 0) ret = (ret + c[x]) % MO, x -= lowbit(x); return ret;}
 
    void clean() {
    }
    int solve() {

    	clean();
    	cin >> n;
    	for (LL i = 1; i <= n; ++i) scanf("%lld", &a[i]), tax[i] = a[i];
    	sort(tax + 1, tax + 1 + n), tot_tax = unique(tax + 1, tax + 1 + n) - tax - 1;
    	for (LL i = 1; i <= n; ++i) a[i] = lower_bound(tax + 1, tax + 1 + tot_tax, a[i]) - tax;

        for (LL i = 1; i <= n; ++i) {
            LL tmp = query(a[i] - 1);
            add(a[i], -lst[a[i]]), add(a[i], lst[a[i]] = (tmp + 1) % MO);
        }
        printf("%lld\n", (query(tot_tax) - tot_tax + MO) % MO);

        return 0;
    }
}
int main() { 
    flyinthesky::solve();
    return 0;
}
```

---

## 作者：DUO_JIaMInG (赞：2)

上升子序列 就是满足严格递增

先考虑大体思路：

如果题目没有要求“如果两个上升子序列相同,那么只需要计算一次”，那么就非常友好了

dp转移方程也很简单 

dp[i]=Σdp[j] (0<j<i)

但是现在要求相同的只能记一次

我们考虑用一个数组la（lastans）[]记录

那么这个数组的作用是什么呢？

在a[i]第一次出现时 我们记录下它前面有多少个上升子序列

即la[i]=子序列个数

在a[i]第二次出现时 仍然先计算它前面上升子序列的个数（假设为ans1） 

但因为其中有一部分已经在第一次遇到a[i]时求解过了

所以我们用ans1-la[a[i]] 

这就是第一个a[i]与第二个a[i]之间上升子序列的个数

 

具体细节：

如果用一般dp的方法求解 大概只能过前30%

对于100% 的数据 我们考虑用树状数组优化（安利）

这样复杂度可以从O(n^2)降到O(nlogn)

最后不要忘记离散化

具体看代码啦
```
using namespace std;
const int mod=1e9+7;
const int mxn=1e5+5;
typedef long long ll;
ll a[mxn],b[mxn],ans;
int n,sz;
bool v[mxn];
ll ld[mxn],f[mxn];
ll lowbit(ll x){
    return x&(-x);
}
void motify(ll x,ll w){
    for(;x<=n;x+=lowbit(x)){
        f[x]=(f[x]+w)%mod;
    }
}
ll get(ll x){
    ll temp=0;
    for(;x;x-=lowbit(x)){
        temp=(temp+f[x])%mod;
    }
    return temp;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        scanf("%lld",&a[i]);
        b[i]=a[i];
    }
    sort(b+1,b+n+1);
    sz=unique(b+1,b+n+1)-(b+1);
    for(int i=1;i<=n;i++){
        a[i]=lower_bound(b+1,b+sz+1,a[i])-b;
    }
    ans=0;
    for(int i=1;i<=n;i++){
        if(!v[a[i]]){
            v[a[i]]=1;
            ll t=get(a[i]-1);
            ans=(ans+t)%mod;
            ld[a[i]]=t;
            motify(a[i],t+1);
            continue;
        }
        v[a[i]]=1;
        ll t=get(a[i]-1);
        ans=(ans+t-ld[a[i]]+mod)%mod;
        motify(a[i],(t-ld[a[i]]+2*mod)%mod);
        ld[a[i]]=t;
    }
    std::cout<<ans;
    return 0;
}
```


---

## 作者：Ayin (赞：1)

看了一圈题解，发现好像我的做法居然和所有人都不一样？

对于每个元素，我首先考虑计算以它为结尾的上升子序列的数量贡献值。

容易发现，它只可以从小于该元素的元素所对应的贡献值转移过来。

于是考虑把原序列元素进行排序，离散化去重，从小到大计算贡献，然后依次把计算的贡献值添加入树状数组进行维护。

转移就是把当前树状数组中当前元素最后出现的位置前面的位置所有的贡献值之和 +1 添加到该大小的元素最后出现的位置。

上代码～～～

[code](https://www.luogu.com.cn/paste/1cbfh8uj)

交上去发现~~居然~~只有 80 分？

当时我的同桌也在做这道题，于是他提供了 HACK 数据：

```
4
3 10 3 4
```
为什么会出问题呢？

容易发现刚才的思路中，有一个显而易见的问题，就是在计算贡献时，我只考虑了最后一个 ${3}$ 之后所能产生的贡献，而这就会漏掉 ${3,10}$ 这种情况。

于是考虑把同种元素的贡献拆分到其在原序列中的位置，就可以避免上述情况了。

上～代～码～
```cpp
#include<bits/stdc++.h>
#define int long long
#define lowbit(x) ((x)&(-x))
using namespace std;
const int mod = 1e9+7;
const int N = 1e5+10;
int read(){
    int a=0,b=1;
    char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') b=-1;
    for(;ch>='0'&&ch<='9';ch=getchar()) a=(a*10)+(ch-48);
    return a*b;
}
int n,m,ans,num[N],pum[N];
int tree[N];
vector<int> sum[N];
void add(int x,int k){
	while(x<=n){
		tree[x]=(tree[x]+k)%mod;
		x=x+lowbit(x);
	} return;
}
int ask(int x,int re = 0){
	while(x){
		re=(re+tree[x])%mod;
		x=x-lowbit(x);
	} return re;
}
signed main(){
	n=read(); for(int i=1;i<=n;i++) num[i]=read(),pum[i]=num[i];
	sort(pum+1,pum+n+1); m=unique(pum+1,pum+n+1)-(pum+1);
	for(int i=1;i<=n;i++){
		num[i]=lower_bound(pum+1,pum+m+1,num[i])-(pum);
		sum[num[i]].push_back(i);
	}
	for(int i=1;i<=m;i++){
		int len=sum[i].size(),ls;
		vector<int> lt;
		for(int j=0;j<len;j++) lt.push_back(ask(sum[i][j]));
		add(sum[i][0],lt[0]+1);
		for(int j=1;j<len;j++) add(sum[i][j],lt[j]-lt[j-1]);
		ans=(ans+lt[len-1])%mod;
	}
	printf("%lld\n",ans);
    return 0;
} 
```


---

## 作者：loser_seele (赞：1)

题目是对原数列的严格上升子序列的计数。

朴素 dp 的复杂度是 $ \mathcal{O}(n^2) $ 的，难以接受，但注意到 dp 方程可以简化为前缀和的形式，于是可以用树状数组简单维护即可。时间复杂度 $ \mathcal{O}(n \log{n}) $。

但是数据的值域太大，需要先离散化之后再用树状数组处理。

我们发现存在另一个问题：序列里的数字可能会重复。

考虑最后一个出现的重复数字一定包含了以前的状态，于是可以在所有的重复数字中只保留最后一个即可，包含了当前的所有答案，不会影响其正确性。

最后输出答案时去掉长度为 $ 1 $ 的情况，即为数列中数字的种类数量。

其中更新答案时需要一个支持单点修改和区间询问的数据结构，在这里使用了 LCT 实现，时间复杂度 $ \mathcal{O}(n \log{n}) $，可以通过。

因为 LCT 特有的自带大常数，本份代码喜提本题最劣解。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long//保险
const int maxn=2e5+10;
const int mod=1e9+7;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
    while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
    return x*f;
}
int c[2000020],tag[2000020],n;
struct Splay
{
    int ch[maxn][2],fa[maxn],siz[maxn],val[maxn],sum[maxn],add[maxn],mul[maxn],rev[maxn];
    void clear(int x)
    {
        ch[x][0]=ch[x][1]=fa[x]=siz[x]=val[x]=sum[x]=add[x]=rev[x]=0;
        mul[x]=1;
    }
    int getch(int x)
    {
        return (ch[fa[x]][1]==x);
    }
    int isroot(int x)
    {
        clear(0);
        return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;
    }
    void maintain(int x)
    {
        clear(0);
        siz[x]=(siz[ch[x][0]]+1+siz[ch[x][1]]);
        sum[x]=(sum[ch[x][0]]+val[x]+sum[ch[x][1]])%mod;
    }
    void pushdown(int x)
    {
        clear(0);
        if(mul[x]!=1)
        {
            if(ch[x][0])
            mul[ch[x][0]]=(mul[x]*mul[ch[x][0]])%mod,val[ch[x][0]]=(val[ch[x][0]]*mul[x])%mod,sum[ch[x][0]]=(sum[ch[x][0]]*mul[x])%mod,add[ch[x][0]]=(add[ch[x][0]]*mul[x])%mod;
            if(ch[x][1])
            mul[ch[x][1]]=(mul[x]*mul[ch[x][1]])%mod,val[ch[x][1]]=(val[ch[x][1]]*mul[x])%mod,sum[ch[x][1]]=(sum[ch[x][1]]*mul[x])%mod,add[ch[x][1]]=(add[ch[x][1]]*mul[x])%mod;
            mul[x]=1;
        }
        if(add[x])
        {
            if(ch[x][0])
            add[ch[x][0]]=(add[ch[x][0]]+add[x])%mod,val[ch[x][0]]=(val[ch[x][0]]+add[x])%mod,sum[ch[x][0]]=(sum[ch[x][0]]+add[x]*siz[ch[x][0]])%mod;
            if(ch[x][1])
            add[ch[x][1]]=(add[ch[x][1]]+add[x])%mod,val[ch[x][1]]=(val[ch[x][1]]+add[x])%mod,sum[ch[x][1]]=(sum[ch[x][1]]+add[x]*siz[ch[x][1]])%mod;
            add[x]=0;
        }
        if(rev[x])
        {
            if(ch[x][0])
            rev[ch[x][0]]^=1,swap(ch[ch[x][0]][0],ch[ch[x][0]][1]);
            if(ch[x][1])
            rev[ch[x][1]]^=1,swap(ch[ch[x][1]][0],ch[ch[x][1]][1]);
            rev[x]=0;
        }
    }
    void update(int x)
    {
        if(!isroot(x))
        update(fa[x]);
        pushdown(x);
    }
    void rotate(int x)
    {
        int y=fa[x],z=fa[y],chx=getch(x),chy=getch(y);
        fa[x]=z;
        if(!isroot(y))
        ch[z][chy]=x;
        ch[y][chx]=ch[x][chx^1];
        fa[ch[x][chx^1]]=y;
        ch[x][chx^1]=y;
        fa[y]=x;
        maintain(y);
        maintain(x);
        maintain(z);
    }
    void splay(int x)
    {
        update(x);
        for(int f=fa[x];f=fa[x],!isroot(x);rotate(x))
        if(!isroot(f))
        rotate(getch(x)==getch(f)?f:x);
    }
    void access(int x)
    {
        for(int f=0;x;f=x,x=fa[x])
        splay(x),ch[x][1]=f,maintain(x);
    }
    void makeroot(int x)
    {
        access(x);
        splay(x);
        swap(ch[x][0],ch[x][1]);
        rev[x]^=1;
    }
    int find(int x)
    {
        access(x);
        splay(x);
        while(ch[x][0])
        x=ch[x][0];
        splay(x);
        return x;
    }//前面都是LCT板子部分
    void added(int u,int c)
    {
        int v=u;
        makeroot(u), access(v), splay(v);
      val[u] = (val[v] + c) ;
      sum[v] = (sum[v] + siz[v] * c ) ;
      add[v] = (add[v] + c) ;
        return;
    }//单点加（相当于对区间[u,u]加）
    int query(int u)
    {
        if(u==0)
            return 0;
        int v=1;
        makeroot(u), access(v), splay(v);
        return sum[v];
    }//区间查询（注意特判u=0的情况，在转化前缀和时1-1=0会出问题）
    void link(int u,int v)
    {
    if (find(u) != find(v)) 
    makeroot(u), fa[u] = v;
    }
}st;
int c1[maxn],d1[maxn],c2[maxn],d2[maxn],a[maxn],b[maxn],lst[maxn];
signed main()
{
        int n;
        cin>>n;
        for(int i=1;i<=n;i++)
            a[i]=read(),b[i]=a[i];
            sort(b+1,b+n+1);
            int len=unique(b+1,b+n+1)-b-1;
        for(int i=1;i<=maxn/2;i++)
        st.clear(i),st.val[i]=0,st.maintain(i),st.splay(i);
        for(int i=0;i<=100000;++i)
        st.sum[i]=0;
        for(int i=1;i<100000;i++)
            st.link(i,i+1);
            for(int i=1;i<=n;i++)
            {
            a[i]=lower_bound(b+1,b+len+1,a[i])-b;
            int delta=st.query(a[i]-1)+1-lst[a[i]];
            st.added(a[i],delta);
		    lst[a[i]]+=delta;
            }
        cout<<st.query(len)-len<<'\n';
}
```


---

## 作者：GoPoux4 (赞：1)

_推销博客：https://www.cnblogs.com/syc233/p/13693730.html_

---

先不考虑序列长度至少为 $2$ 的限制和去重，那么这道题就是一个简单的DP：

令 $f_i$ 表示以 $a_i$ 结尾的上升子序列个数，那么很容易写出转移方程：
$$
f_i=\sum_{j=1}^{i-1}f_j[a_j<a_i]
$$
直接转移 $O(n^2)$ ，可以用树状数组优化到 $O(n \ {\rm{\log}} \ n)$ 。

考虑如何去重。发现若对于当前数 $a_i$ ，存在 $a_j=a_i,1\leq j<i$ ，那么 $a_i$ 对上升子序列的贡献会与 $a_j$ 的贡献重复。

显然，能转移到 $j$ 的状态一定能转移到 $i$ ，能转移到 $i$ 的状态不一定能转移到 $j$ ，即重合部分就是 $f_j$ 。

转移时，对于值域中的每一个数 $x$，记录上一次计算出的 $f_i,a_i=x$ 。转移时将重复部分减去即可。

因为题目要求序列长度至少为 $2$ ，最后再减去长度为 $1$ 的情况。

---

$\text{Code}:$

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
#define maxn 100005
#define Rint register int
#define INF 0x3f3f3f3f
using namespace std;
typedef long long lxl;
const lxl mod=1e9+7;

template <typename T>
inline void read(T &x)
{
	x=0;T f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	x*=f;
}

int n,a[maxn],b[maxn],m;

lxl sum[maxn],las[maxn];

inline int lowbit(int x) {return x&-x;}

inline void add(int x,lxl d)
{
	for(int i=x;i<=m;i+=lowbit(i))
		(sum[i]+=d)%=mod;
}

inline lxl query(int x)
{
	lxl res=0;
	for(int i=x;i>=1;i-=lowbit(i))
		(res+=sum[i])%=mod;
	return res;
}

int main()
{
	// freopen("P3970.in","r",stdin);
	read(n);
	for(int i=1;i<=n;++i)
	{
		read(a[i]);
		b[i]=a[i];
	}
	sort(b+1,b+n+1);
	m=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;++i)
	{
		a[i]=lower_bound(b+1,b+m+1,a[i])-b;
		lxl val=query(a[i]-1)+1-las[a[i]];
		add(a[i],val);
		las[a[i]]+=val;
	}
	printf("%lld\n",query(m)-m);
	return 0;
}

```


---

## 作者：Adove (赞：1)

我来提供一种zkw线段树的做法

细节：要注意运用差分思想，假设有两个数的值相同，后面那个数的f就包含了前面一个数的f，要作差。

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

const int MAXN=1<<18;
const int MOD=1e9+7;

int n;
long long ans;
long long tree[MAXN<<1],a[MAXN],f[MAXN];
struct rpg{
	int num,id,ren;
}b[MAXN],c[MAXN];

bool cmp(rpg a,rpg b){return a.num<b.num;}
void shel()
{
	for(int i=1;i<=n;++i) c[b[i].id]=b[i];
	for(int i=1;i<=n;++i) b[i]=c[i];
}

void init()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d",&b[i].num),b[i].id=i;
	sort(b+1,b+n+1,cmp);b[1].ren=1;
	for(int i=2;i<=n;++i){
		if(b[i].num==b[i-1].num) b[i].ren=b[i-1].ren;
		else b[i].ren=b[i-1].ren+1;
	}shel();
	for(int i=1;i<=n;++i){
		if(b[i].ren==b[i-1].ren) continue;
		a[++a[0]]=b[i].ren;
	}return;
}

void solve()
{
	for(int i=1;i<=a[0];++i){
		int l=a[0],r=a[0]+a[i];
		long long sum=0;
		while(l^r^1){
			if(~l&1) sum+=tree[l^1];
			if(r&1) sum+=tree[r^1];
			l>>=1,r>>=1;
		}ans=(ans+sum-tree[a[0]+a[i]])%MOD;
		if(tree[a[0]+a[i]]) ++ans;
		tree[a[0]+a[i]]=(sum+1)%MOD;
		for(int j=a[0]+a[i]>>1;j;j>>=1) tree[j]=(tree[j<<1]+tree[j<<1|1])%MOD;
	}printf("%lld\n",ans);
	return;
}

int main()
{
	init();
	solve();
	return 0;
}
```

---

## 作者：冷笑叹秋萧 (赞：0)

## 题意
给出一个长度为序列 $a[1] \sim a[n] (n \le 10^5)$，计算上升子序列的个数，并且相同的子序列只计算一次。
## Solution
考虑使用 DP 计算，设 $f[i]$ 表示以 $i$ 结尾的上升子序列的个数，不难写出转移方程：
$f[i]=\sum f[j](a[j] \lt a[i])$

但是我们可以发现这样转移是 $O(n^2)$ 的，显然通过不了极限数据，需要使用数据结构进行优化，又注意到题目说相同的子序列只算一次，所以对于相同的 $a[i]$，我们只需要取最靠后的那个 $f[i]$ 的值。

于是我们可以想到用线段树进行优化，首先要离散化一下 $a[i]$ 到数组空间可以承受住的范围，然后对于每个离散化之后的 $a[i]$，我们对表示 $1 \sim a[i]-1$ 的区间进行求和然后单点修改存到表示 $a[i]$ 的节点上，最后输出区间的总和即可。
## CODE
```cpp
#include<bits/stdc++.h>
#define N 100005
#define MO 1000000007
#define ll long long
using namespace std;
struct arr {
	ll x; int id;
} a[N];
struct segment {
	ll val, num;
} tree[N << 2];
int b[N], n;
bool cmp(arr x, arr y) {
	return x.x < y.x;
}
void change(int u, int l, int r, int x, ll k) {
	if (l == r) {
		tree[u].val = k; tree[u].num = 1; return;
	} int mid = l + r >> 1;
	if (x <= mid) change(u << 1, l, mid, x, k); else change(u << 1 | 1, mid + 1, r, x, k);
	tree[u].val = (tree[u << 1].val + tree[u << 1 | 1].val) % MO; tree[u].num = (tree[u << 1].num + tree[u << 1 | 1].num) % MO;
}
ll find(int u, int l, int r, int x, int y) {
	if (l > r || x > y || l > y || x > r) return 0;
	if (l >= x && r <= y) return (tree[u].val + tree[u].num) % MO;
	int mid = l + r >> 1; ll res = 0;
	if (x <= mid) res = (res + find(u << 1, l, mid, x, y)) % MO;
	if (y > mid) res = (res + find(u << 1 | 1, mid + 1, r, x, y)) % MO; return res;
}
int main() {
	freopen("subsequence.in", "r", stdin); freopen("subsequence.out", "w", stdout);
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i) {
		scanf("%lld", &a[i].x); a[i].id = i; 
	} sort(a + 1, a + 1 + n, cmp); int cnt = 0; a[0].x = -1e9 - 1;
	for (int i = 1; i <= n; ++i) {
		if (a[i].x != a[i - 1].x) ++cnt; b[a[i].id] = cnt;
	}
	for (int i = 1; i <= n; ++i) {
		ll sum = find(1, 1, cnt, 1, b[i] - 1); change(1, 1, cnt, b[i], sum);
	} printf("%lld\n", tree[1].val);
	return 0;
} 
```

---

## 作者：Coros_Trusds (赞：0)

相对于其他题解来说思维更加简单的一种方法，也是一种可以忽略去重条件的做法。

# 题目大意

给定一个长度为 $n$ 的序列 $a$，求出该序列长度大于 $1$ 的本质不同上升子序列个数。

# 题目分析

根据套路很容易想出朴素算法，~~$30$ 分到手~~。

想想朴素的 $dp$。令 $dp_i$ 表示前 $i$ 个数中满足条件的子序列个数，转移方程：$dp_i=1+\sum\limits_{j=1}^{i-1}dp_j\times [a_i\gt a_j]$。但是这样子是 $\mathcal{O(n^2)}$ 的会超时，想想优化。

考虑线段树来优化，虽说树状数组也可以，但是从码量、常数、思维理解难度和空间等方面比起来就相形见绌 $(chù)$ 了。

我们先离散化一下，因为我们并不关心序列中每个数的具体值，我们只在乎它们之间的相对大小。

用线段树存 $dp$ 值，依次遍历每个元素，我们将下标在 $1\sim a_i-1$ 范围内的所有 $dp$ 值之和加一，再将当前位置 $a_i$ 赋上这个值即可。可以看到，上面就是朴素的 $dp$ 换了一下而已。

无脑 $dp$，无需考虑去重条件。

# 代码

```cpp
//2022/2/11
//2022/2/19
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <algorithm>
#define enter() putchar(10)
#define debug(c,que) cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) cout << arr[i] << w;
#define speed_up() cin.tie(0),cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define Abs(x) ((x) > 0 ? (x) : (-x))
const int mod = 1e9 + 7;
inline int MOD(int x) {
	while (x < 0) x += mod;
	while (x >= mod) x -= mod;
	return x;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;
using namespace std;

const int ma = 1e5 + 5;
int a[ma],b[ma];
int n;
struct Segment_Tree {
	struct Node {
		int l,r;
		int sum;
	} node[ma << 2];
	#define lson (p << 1)
	#define rson (p << 1 | 1)
	inline void pushup(int p) {
		node[p].sum = MOD(node[lson].sum + node[rson].sum);
	}
	inline void build(int p,int l,int r) {
		node[p].l = l,node[p].r = r;
		if (l == r) {
			node[p].sum = 0;
			return;
		}
		int mid = l + r >> 1;
		build(lson,l,mid),build(rson,mid + 1,r);
		pushup(p);
	}
	inline void update(int x,int y,int p,int k) {
		if (x <= node[p].l && node[p].r <= y) {
			node[p].sum = k * (node[p].r - node[p].l + 1),node[p].sum = MOD(node[p].sum);
			return;
		}
		int mid = node[p].l + node[p].r >> 1;
		if (x <= mid) update(x,y,lson,k);
		if (y > mid) update(x,y,rson,k);
		pushup(p);
	}
	inline int query(int x,int y,int p) {
		if (x <= node[p].l && node[p].r <= y) {
			return MOD(node[p].sum);
		}
		int mid = node[p].l + node[p].r >> 1,res = 0;
		if (x <= mid) res = MOD(res + query(x,y,lson));
		if (y > mid) res = MOD(res + query(x,y,rson));
		return res;
	}
	#undef lson
	#undef rson
} seg;
int main(void) {
#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
#endif
	n = read();
	for (register int i = 1;i <= n; ++ i) {
		a[i] = b[i] = read();
	}
	sort(b + 1,b + n + 1);
	int num = unique(b + 1,b + n + 1) - b - 1;
	for (register int i = 1;i <= n; ++ i) {
		a[i] = lower_bound(b + 1,b + num + 1,a[i]) - b;
	}
	seg.build(1,1,num);
	for (register int i = 1;i <= n; ++ i) {
		int val = seg.query(1,a[i] - 1,1) + 1;
		seg.update(a[i],a[i],1,val);
	}
	printf("%d\n",seg.query(1,num,1) - num);

	return 0;
}
```

---


# 区间方差

## 题目背景

出题人并没有能力写有趣的题面……


## 题目描述

对于一个长度为 $n$ 的序列 $a_1,a_2,a_3\cdots a_n$，我们定义它的平均数 $a$ 为:

$$a=\frac{1}{n}\sum_{i=1}^{n}a_i$$

并定义它的方差 $d$ 为:

$$d=\frac{1}{n}\sum_{i=1}^{n}(a_i-a)^2$$

现在给定一个长度为 $n$ 的序列 $b_1,b_2\cdots b_n$。你需要支持两种操作。每种操作的格式为 `c x y`。

若 $c=1$，为修改操作，代表将 $b_x$ 赋值为 $y$。

若 $c=2$，为查询操作，代表查询 $b_x$ 到 $b_y$ 的方差。

为了避免浮点数误差，请以分数取模形式输出结果（对 1000000007（$10^9+7$）取模）。

## 说明/提示

#### 样例 1 解释
四次修改后，序列 $b$ 为：$\{1,2,3,4\}$。

区间 $[1,1]$ 的方差为 $0$。

区间 $[1,2]$ 的方差为 $\frac{1}{4}$ 。$4$ 的逆元为 $250000002$。

区间 $[1,3]$ 的方差为 $\frac{2}{3}$。$3$ 的逆元为 $333333336$，$2\times333333336\bmod M=666666672$。

#### 数据规模与约定

- 对于 $50\%$ 的数据，$n\leq 1000$，$m\leq 1000$。
- 对于 $100\%$ 的数据，$1\leq n,m\leq 1\times 10^5$，$1\leq b_i\leq 1\times 10^9$，$1\leq x\leq n$。对于操作 1，$1\leq y\leq 1\times 10^9$。对于操作2，$x\leq y\leq n$。

## 样例 #1

### 输入

```
4 8
0 0 0 0
1 1 1
1 2 2
1 3 3
1 4 4
2 1 1
2 1 2
2 1 3
2 1 4```

### 输出

```
0
250000002
666666672
250000003```

# 题解

## 作者：fa_555 (赞：22)

under 题解 [P5142](https://www.luogu.org/problemnew/show/P5142)

------------

题目要求维护模意义下的区间方差，显然是数据结构题。

考虑方差公式：

$ \begin{aligned} \sigma^2 &= \frac{1}{n} \sum \limits_{i = 1}^n (x_i - \bar{x})^2 \\ &= \frac{1}{n} (\sum \limits_{i = 1}^n x_i^2 - 2 \bar{x} \sum \limits_{i = 1}^nx_i + n \bar{x}^2) \\ &= \frac{1}{n} (\sum \limits_{i = 1}^n x_i^2 - 2 \bar{x} \times n \bar{x} + n \bar{x}^2) \\ &= \frac{1}{n} \sum \limits_{i = 1}^n x_i^2 - \bar{x}^2 \\ \end{aligned} $

而算术平均数

$ \begin{aligned} \bar{x} &= \frac{1}{n} \sum \limits_{i = 1}^n x_i \end{aligned} $


可以发现，只要维护序列的**区间和**和**区间平方和**，就可以维护平均数和方差。

**区间和**和**区间平方和**都**满足结合律**，因此可以用**线段树**维护。

------------

题目要求对 $ 1e9+7 $ 取模，而 $ 1e9+7 < \frac{INT \_ MAX}{2} $，完全可以不使用 `long long` 变量维护。

于是写了一发代码，看看~~毒瘤~~真正的取模和强制类型转换~~的大常数~~是什么样子的：

代码(c++11) 含注释：

```cpp
#include<cstdio>

using namespace std;
typedef long long ll;

constexpr int mod = 1e9+7;

int N, M, op, x, y, s1, s2, inv, ave, ans, a[100003];

int qpow(int b, int p = mod - 2, int m = mod) {
	// 快速幂用于费马小定理求逆元 
	b %= m;
	int s = 1 % m;
	for(; p; p >>= 1, b = (ll)b * b % m)
		if(p & 1) s = (ll)s * b % m;
	return s;
}

namespace SGT {
	#define ls p<<1
	#define rs p<<1|1
	#define sr(x) ((ll)(x)*(x)%mod) // 注意这个宏 

	int L[400003], R[400003], s1[4000003], s2[400003];
    	// s1[] 存储区间和，s2[] 存储区间平方和 
        // 由于无区间修改，不需要 lazytag 和 pushdown 操作 

	inline void pushup(int p) {
		s1[p] = (s1[ls] + s1[rs]) % mod;
		s2[p] = (s2[ls] + s2[rs]) % mod;
	}

	void build(int p, int l, int r) {
		L[p] = l, R[p] = r;
		if(l == r) {
			s1[p] = a[l] % mod;
			s2[p] = sr(a[l]) % mod;
			return;
		}
		int m = (l + r) >> 1;
		build(ls, l, m);
		build(rs, m + 1, r);
		pushup(p);
	}

	void modify(int p, int k, int v) {
    	// 单点修改 
		if(L[p] == R[p]) {
			s1[p] = v % mod;
			s2[p] = sr(v) % mod;
			return;
		}
		int m = (L[p] + R[p]) >> 1;
		if(k <= m) modify(ls, k, v);
		else modify(rs, k, v);
		pushup(p);
	}

	int query1(int p, int l, int r) {
		// 询问区间和 
		if(l == L[p] && r == R[p]) return s1[p] % mod;
		int m = (L[p] + R[p]) >> 1;
		if(r <= m) return query1(ls, l, r) % mod;
		if(l > m) return query1(rs, l, r) % mod;
		return (query1(ls, l, m) + query1(rs, m + 1, r)) % mod;
	}

	int query2(int p, int l, int r) {
		// 询问区间平方和 
		if(l == L[p] && r == R[p]) return s2[p] % mod;
		int m = (L[p] + R[p]) >> 1;
		if(r <= m) return query2(ls, l, r) % mod;
		if(l > m) return query2(rs, l, r) % mod;
		return (query2(ls, l, m) + query2(rs, m + 1, r)) % mod;
	}
}

int main() {
	scanf("%d%d", &N, &M);
	for(int i = 1; i <= N; ++i) scanf("%d", &a[i]);
	SGT::build(1, 1, N);
	
	while(M--) {
		scanf("%d%d%d", &op, &x, &y);
		if(op == 1) SGT::modify(1, x, y % mod);
		else {
			// 以下各变量均在模意义下 
			// 强制类型转换 (ll) 一个也不能少！ 
			s1 = SGT::query1(1, x, y) % mod;	// 区间和 
			s2 = SGT::query2(1, x, y) % mod;	// 区间平方和 
			inv = qpow(y - x + 1);				// 区间长度（分母）的逆元 
			ave = (ll)s1 * inv % mod;			// 区间算术平均数 
			ans = (ll)s2 * inv % mod - (ll)ave * ave % mod;
			ans = (ans % mod + mod) % mod;
				// 区间方差，前文有减法操作，防止出现负数
				// 现有题解在这里都给 $ans 加了 3 个 $mod 才 AC 
				// 但考试中怎么知道加上几个才不会被卡呢？ 
				
			printf("%d\n", ans);
		}
	}
	return 0;
}

```


------------

后记：

故意不开 `long long` 并不是为了毒瘤，而是为了磨炼自己的基本功。

在平常的练习中把刀磨锋利，才能在考试中得心应手地使用。

~~（寓言故事草）~~

如果有错误或不懂的地方，请在私信或评论中告知我。**谢谢大家！**


---

## 作者：NaCly_Fish (赞：19)


这是一道比较水的数据结构题，题目内容还是 [P1471](https://www.luogu.org/problemnew/show/P1471) 的弱化版。。  


好吧来看解法：  

对于修改操作，题目要求的是方差：  
$$\frac1{r-l+1}\sum\limits_{i=l}^r(b_i-\overline{b})^2$$
其中  
$$\overline{b}=\frac1{r-l+1}\sum\limits_{i=l}^rb_i$$
（也就是平均数）  

原式可以展开为：  
$$\frac1{r-l+1}\sum\limits_{i=l}^r(b_i^2-2b_i\overline b+\overline b^2)$$  
把这个式子再拆开，就成了
$$\frac1{r-l+1}\left(\sum\limits_{i=l}^rb_i^2-2b'\sum\limits_{i=l}^rb_i\right)+b'^2$$
   
其中 $\overline b$ 可以直接用区间和算出来。  

那么现在要做的事就很明显了：维护区间和、平方和。  
可以考虑开两个树状数组来搞，一个记录平方和，一个直接记录和。  

具体做法可以看我的代码：  
 
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector>
#include<queue>
#define N 100003
#define p 1000000007
#define int long long
using namespace std;

inline void read(int &x);
void print(int x);
inline int lowbit(int x);
void change(int i,int k); //单点修改
inline int querySum(int i);
inline int querySquare(int i);
int inv(int n); //求逆元用

int sum[N],square[N];
//sum是和，square是平方和
int n,m;

signed main(){
    int op,a,b;
    read(n),read(m);
    for(int i=1;i<=n;++i){
        read(a);
        if(a==0) continue;
        change(i,a);
    }
    ++m;
    while(--m){
        read(op),read(a),read(b);
        if(op==1) change(a,b);
        else{
            if(a==b){
                putchar('0');
                putchar('\n');
                continue;
            }
            int average,inverse,ans,r,l;
            l = a,r = b;
            inverse = inv(r-l+1);
            average = (querySum(r)-querySum(l-1))*inverse%p;
            ans = ((querySquare(r)-querySquare(l-1))%p-(average<<1)*(querySum(r)-querySum(l-1))%p)*inverse%p;
            ans = ((ans+average*average%p)%p+p)%p;
            print(ans);
            putchar('\n');
        }
    }
    return 0;
}

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}

inline int lowbit(int x){
    return x&(-x);
}

void change(int i,int k){
    int d = k-(querySum(i)-querySum(i-1)); //计算增量
    int t = i;
    while(t<=n){
        sum[t] = (sum[t]+d)%p;
        t += lowbit(t);
    }
    d = k*k-(querySquare(i)-querySquare(i-1)); //同上,因为维护的是平方和所以k要平方
    t = i;
    while(t<=n){
        square[t] = (square[t]+d)%p;
        t += lowbit(t);
    }
}

inline int querySum(int i){
    int res = 0;
    while(i){
        res = (res+sum[i])%p;
        i -= lowbit(i);
    }
    return res;
}

inline int querySquare(int i){
    int res = 0;
    while(i){
        res = (res+square[i])%p;
        i -= lowbit(i);
    }
    return res;
}

int inv(int n){
    if(n==1) return 1;
    if(n<1) return 0;
    return (p-p/n)*inv(p%n)%p;
}
```


---

## 作者：Prean (赞：6)

题意简明，不说了（

因为教练让同学们做线段树的题，早就会了线段树的我就来~~爆踩~~水水蓝了/kk

首先推一下柿子：
$$ \frac 1 n\sum_{i=1}^n(a_i^2-2 \times a_i \times \overline a + \overline a^2) $$
$$ \frac 1 n(\sum_{i=1}^na_i^2-2\overline a \times \sum_{i=1}^na_i + n \times \overline a^2) $$
于是用线段树维护一下区间和&区间平方和就好了。。。

愿意的话甚至可以用树状数组维护。。。

code:
```cpp
#include<cstdio>
const int M=1e5+5,mod=1e9+7;
int n,m,a[M];
inline int Inv(int a){
	int b=mod-2,ans=1;
	for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;
	return ans;
}
inline int Add(const int&a,const int&b){
	return a+b>=mod?a+b-mod:a+b;
}
inline int Del(const int&a,const int&b){
	return a-b<0?a-b+mod:a-b;
}
struct Node{
	int sum,squ;
	inline Node operator+(const Node&it)const{
		return (Node){Add(sum,it.sum),Add(squ,it.squ)};
	}
}tmp,t[M<<2];
inline void update(const int&u){
	t[u]=t[u<<1]+t[u<<1|1];
}
void build(int u,int l,int r){
	if(l==r)t[u].sum=a[l],t[u].squ=1ll*a[l]*a[l]%mod;
	else{
		int mid=l+r>>1;
		build(u<<1,l,mid);build(u<<1|1,mid+1,r);
		update(u);
	}
}
void Modify(int u,int x,int val,int l=1,int r=n){
	if(l==r)t[u].sum=val,t[u].squ=1ll*val*val%mod;
	else{
		int mid=l+r>>1;
		if(x<=mid)Modify(u<<1,x,val,l,mid);
		else Modify(u<<1|1,x,val,mid+1,r);
		update(u);
	}
}
Node Query(int u,int L,int R,int l=1,int r=n){
	if(L>r||l>R)return (Node){0,0};
	if(L<=l&&r<=R)return t[u];
	int mid=l+r>>1;
	return Query(u<<1,L,R,l,mid)+Query(u<<1|1,L,R,mid+1,r);
}
signed main(){
	register int i,f,L,R,val,inv;
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;++i)scanf("%d",a+i);
	build(1,1,n);
	for(i=1;i<=m;++i){
		scanf("%d%d%d",&f,&L,&R);
		if(f==1){
			Modify(1,L,R);
		}
		else{
			tmp=Query(1,L,R);
			inv=Inv(R-L+1);
			val=1ll*inv*tmp.sum%mod;
			printf("%d\n",1ll*inv*Del(Add(tmp.squ,1ll*val*val%mod*(R-L+1)%mod),2ll*val*tmp.sum%mod)%mod);
		}
	}
}
```

---

## 作者：MY（一名蒟蒻） (赞：4)

[P5142 区间方差](https://www.luogu.com.cn/problem/P5142)

## Part 0 方差

首先看一下题目里给的公式：

$d=\frac{1}{n}\sum_{i=1}^n(a_i-a)^2$

这东西和每个数字都有关系，那么直接用这个公式就非常不可做。

考虑展开。

$$d=\frac{1}{n}\sum_{i=1}^n(a_i-a)^2$$

$$\Downarrow$$

$$d=\frac{1}{n}\sum_{i=1}^na_i^2-2a_ia+a^2$$

$$\Downarrow$$

$$d=\frac{\sum_{i=1}^na_i^2-2\sum_{i=1}^na_ia+na^2}{n}$$

$$\Downarrow$$

$$d=\frac{\sum_{i=1}^na_i^2}{n}-2a^2+a^2$$

$$\Downarrow$$

$$d=\frac{\sum_{i=1}^na_i^2}{n}-\frac{(\sum_{i=1}^na_i)^2}{n^2}$$

所以我们只需要维护**区间平方和**和**区间和**即可。

单点修改没有计算贡献的麻烦。

## Part 1 有理数取模

模数非常良心，是个质数。

那我们就可以通过[费马小定理](https://www.luogu.com.cn/blog/nizhuan/zheng-ming-fei-ma-xiao-ding-li)打快速幂解决逆元。

费马小定理：

$a^{p-1}\equiv1\ (mod\ p)$

我们现在想知道 $res$ 在模 $1e9+7$ 意义下的逆元。

由上式可知 $res\times res^{-1}= res^{p-1}$ ， 即 $res^{-1}=res^{p-2}$ 。

## Part 2 Code

由于我是做了双倍经验过来的，于是没有用相对好写的树状数组。

```cpp
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstdlib>

using namespace std;

typedef long long ll;
const int N=1e5+10,mod=1e9+7;

ll a[N];
struct Segment_Tree//线段树
{
	int sumv[N << 2],sump[N << 2];
	inline int ls(int o) {return o << 1;}
	inline int rs(int o) {return o << 1|1;}
	inline void pushup(int o)
	{
		int l=ls(o),r=rs(o);
		sumv[o]=(sumv[l]+sumv[r])%mod; sump[o]=(sump[l]+sump[r])%mod;
		return ;
	}
	void build(int o,int l,int r)
	{
		if(l == r) {sumv[o]=a[l]; sump[o]=(a[l]*a[l])%mod; return ;}
		int mid=(l+r) >> 1;
		build(ls(o),l,mid); build(rs(o),mid+1,r);
		pushup(o); return ;
	}
	void modify(int o,int l,int r,int p)
	{
		if(l == r) {sumv[o]=a[l]; sump[o]=(a[l]*a[l])%mod; return ;}
		int mid=(l+r) >> 1;
		if(p <= mid) modify(ls(o),l,mid,p);
		else modify(rs(o),mid+1,r,p);
		pushup(o); return ;
	}
	ll query(int o,int l,int r,int ql,int qr,bool f)
	{
		if(ql <= l && r <= qr) return f? sumv[o]:sump[o];
		int mid=(l+r) >> 1;
		ll res=0;
		if(ql <= mid) res=(res+query(ls(o),l,mid,ql,qr,f))%mod;
		if(qr > mid) res=(res+query(rs(o),mid+1,r,ql,qr,f))%mod;
		return res;
	}
} tree;

ll qpow(ll n,ll m)//快速幂
{
	ll res=1;
	while(m)
	{
		if(m&1) res=(res*n)%mod;
		m>>=1; n=(n*n)%mod;
	}
	return res;
}

int main()
{
// 	freopen("work.in","r",stdin); freopen("work.out","w",stdout);
	int n,m,op,x,y;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	tree.build(1,1,n);
	while(m--)
	{
		scanf("%d%d%d",&op,&x,&y);
		if(op == 1) {a[x]=y; tree.modify(1,1,n,x);}
		else
		{
			ll k=qpow(y-x+1,mod-2),s=tree.query(1,1,n,x,y,true),sp=tree.query(1,1,n,x,y,false);
			printf("%lld\n",((sp*k)%mod-(((s*k)%mod)*((s*k)%mod))%mod+mod)%mod); 
		}
	}
// 	fclose(stdin); fclose(stdout);
	return 0;
}
```

加强版（额外的经验）

1. [P1471 方差](https://www.luogu.com.cn/problem/P1471)
2. [P2122 还教室](https://www.luogu.com.cn/problem/P2122) [题解](https://www.luogu.com.cn/blog/nizhuan/solution-p2122)

感谢您的阅读！

---

## 作者：lukelin (赞：4)

### 前言
[更好的阅读体验？安利一下我的博客。](https://www.cnblogs.com/linzhengmin/p/11128621.html)  
这是一道线段树板子题。
### 题解
我们观察这个式子
$$avg=\frac{1}{n}\sum_{i=1}^n a_i$$
$$d=\frac{1}{n}\sum_{i=1}^n (a_i-avg)^2$$
我们把它展开变成
$$d=\frac{1}{n}\sum_{i=1}^n (a_i^2-2\times a_i \times avg - avg^2)$$
提出常数项得
$$d=\frac{1}{n}(\sum_{i=1}^n a_i^2-2\times avg \times \sum_{i=1}^n a_i + n\times avg^2)$$
那么我们开两棵线段树，一棵维护$a_i$的和，一棵维护$a_i^2$的和，在加一个[乘法逆元](https://www.cnblogs.com/linzhengmin/p/10941194.html)即可。  
结果蒟蒻lukelin还WA了一次，原因是~~取模不勤~~。
### 代码
两棵线段树放在一起处理，十分方便。  
逆元按照巨佬的说法，用了快速幂（~~再见拓欧~~）。
```cpp
#include <cstdio>
#define ll long long

ll s[400005], s2[400005];
const ll MOD = 1e9 + 7;

ll read(){
	ll x = 0; int zf = 1; char ch = ' ';
	while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
	if (ch == '-') zf = -1, ch = getchar();
	while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf;
}

ll getInv(ll x){
	ll res = 1;
	for (int y = MOD - 2; y; y >>= 1, x = (x * x) % MOD)
		if (y & 1)
			(res *= x) %= MOD;
	return res;
}

void build(int pos, int l, int r){
	if (l == r){
		s[pos] = read(); s2[pos] = (s[pos] * s[pos]) % MOD;
		return ;
	}
	int mid = (l + r) >> 1;
	build(pos << 1, l, mid);
	build(pos << 1 | 1, mid + 1, r);
	s[pos] = s[pos << 1] + s[pos << 1 | 1];
	s2[pos] = s2[pos << 1] + s2[pos << 1 | 1];
}

ll query(int pos, int l, int r, int x, int y){
	if (x <= l && r <= y)
		return s[pos];
	ll ans = 0; int mid = (l + r) >> 1;
	if (x <= mid)
		ans += query(pos << 1, l, mid, x, y);
	if (mid < y)
		(ans += query(pos << 1 | 1, mid + 1, r, x, y)) %= MOD;
	return ans;
}

ll query2(int pos, int l, int r, int x, int y){
	if (x <= l && r <= y)
		return s2[pos];
	ll ans = 0; int mid = (l + r) >> 1;
	if (x <= mid)
		ans += query2(pos << 1, l, mid, x, y);
	if (mid < y)
		(ans += query2(pos << 1 | 1, mid + 1, r, x, y)) %= MOD;
	return ans;
}

void modify(int pos, int l, int r, int x, ll val){
	if (l == r){
		s[pos] = val, s2[pos] = (val * val) % MOD;
		return ;
	}
	int mid = (l + r) >> 1;
	if (x <= mid)
		modify(pos << 1, l, mid, x, val);
	else if (mid < x)
		modify(pos << 1 | 1, mid + 1, r, x, val);
	s[pos] = (s[pos << 1] + s[pos << 1 | 1]) % MOD;
	s2[pos] = (s2[pos << 1] + s2[pos << 1 | 1]) % MOD;
}

int main(){
	int n = read(), m = read();
	build(1, 1, n); ll c, a, b;
	while (m--){
		c = read(), a = read(), b = read();
		if (c == 1)
			modify(1, 1, n, a, b);
		else if (c == 2){
			ll ans2 = query2(1, 1, n, a, b), ans = query(1, 1, n, a, b);
			ll avg = (ans * getInv(b - a + 1)) % MOD;
			ll res = (((ans2 - (avg * ans * 2ll % MOD) + ((((avg * avg) % MOD) * (b - a + 1)) % MOD)) % MOD * getInv(b - a + 1))) % MOD;
			while (res < 0) res += MOD;
			printf("%lld\n", res);
		}
	}
	return 0;
}
```

---

## 作者：ADay (赞：3)

[更好的阅读体验](https://aday526.github.io/%E9%A2%98%E8%A7%A3%20P5142%20%E3%80%90%E5%8C%BA%E9%97%B4%E6%96%B9%E5%B7%AE%E3%80%91/)  
咋全是 $\texttt{线段树or树状数组}$ 的题解啊...zkw线段树来一发~


首先看到题目的两个式子：

$b=\dfrac{1}{n}\sum\limits_{i=l}^ra_i$①

$d=\dfrac{1}{n}\sum\limits_{i=l}^r(a_i-b)^2$②

把②展开得：

$d=\dfrac{1}{n}\sum\limits_{i=l}^r(a_i^2-2a_ib+b^2)$③

再把①代入③得：

$d=\dfrac{1}{n}(\sum\limits_{i=l}^ra_i-2b\sum\limits_{i=l}^ra_i^2)+b^2$

那么，我们就可以用两个数据结构维护$\sum\limits_{i=l}^ra_i$和$\sum\limits_{i=l}^ra_i^2$，$\mathcal O(\log_2n)$查询，再$\mathcal O(1)$得出结果

而这题是单点修改，zkw线段树的码量和常数都会比普通线段树小很多，所以用zkw会更加方便

~~树状数组是啥，能吃吗~~

代码，没有压行的习惯，但也只有70+行

```cpp
#include<bits/stdc++.h>
#define int long long//懒
using namespace std;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read()//快读
{
    int _s=0,_f=1;char _ch=getchar();
    for(;!isdigit(_ch);_ch=getchar())if(_ch=='-')_f=-1;
    for(;isdigit(_ch);_ch=getchar())_s=_s*10+_ch-'0';
    return _s*_f;
}
const int maxn=1e5+5,mod=1e9+7;
int n,m,a[maxn<<2]/*维护原数组的和*/,b[maxn<<2]/*维护平方和*/,N/*详见zkw线段树具体教程*/;
void build()//zkw建树
{
    n=read();m=read();
    for(N=1;N<=n+1;N<<=1)"YOU AK IOI";
    for(signed i=N+1;i<=N+n;i++)a[i]=read(),b[i]=a[i]*a[i];
    for(signed i=N-1;i>=1;i--)a[i]=a[i<<1]+a[i<<1|1],b[i]=b[i<<1]+b[i<<1|1];
}
inline void modify(int *q,int s,int k)//单点修改
{
    int d=k-q[s+=N];//赋值=加上他们的差
    for(;s;s>>=1)
    {
        q[s]=(q[s]+d)%mod;
        if(q[s]<0)q[s]+=mod;
    }
}
inline int query(int *q,int s,int t)//区间查询
{
    int res=0;
    for(s=N+s-1,t=N+t+1;s^t^1;s>>=1,t>>=1)
    {
        if(~s&1)res=(res+q[s^1])%mod;
        if(t&1)res=(res+q[t^1])%mod;
    }
    return res;
}
inline void change(int s,int k)
{
    modify(a,s,k);
    modify(b,s,(k*k)%mod);//维护平方和，应是k*k
}
inline int inv(int x)//逆元
{//mod逆元(x)=(x^(mod-2))%mod
    int y=mod-2,res=1;
    for(;y;x=(x*x)%mod,y>>=1)
        if(y&1)res=(res*x)%mod;//快速幂
    return res;
}
inline int ask(int s,int t)//计算结果
{
    int num=t-s+1,u=query(a,s,t),v=query(b,s,t);
    int i=inv(num);
    int w=i*u%mod;
    int res=v-2ll*w%mod*u%mod;
    res=res*i%mod+w*w%mod;
    res%=mod;
    return res<0?res+mod:res;
}
signed main()
{
    build();
    while(m--)
    {
        int opt=read(),x=read(),y=read();
        if(opt==1)change(x,y);
        else printf("%d\n",ask(x,y));
    }
    return 0;
}
```

最后提醒一下，记得勤取模！

PS:60篇题解祭~~（求过）~~





---

## 作者：EDqwq (赞：2)

### 拆柿子：

$$d = \frac{1}{n}\sum\limits_{i=1}^n(a_i - p)^2$$

（ $p$ 为平均数）

拆掉平方后：

$$d = \frac{1}{n}\sum\limits_{i=1}^n(a_i ^ 2 - 2 \times a_i \times p + p^2)$$

于是我们发现这个柿子未知的东西有三项：

1. $a_i$ 的和

1. $a_i$ 平方和

1. 平均数

由于求平均数，仅需 $a_i$ 的和，所以我们维护前两项即可。

树状数组 / 线段树都可以做到，我用的是树状数组。

然后是有理数取膜，不会的可以到[这里](https://www.luogu.com.cn/problem/P2613)学习。

***

### 代码：

```cpp
/*
  Author: EnderDeer
  Online Judge: Luogu
*/

#include<bits/stdc++.h>

#define int long long
#define mem(x) memset(x,0,sizeof(x))
#define mod 1000000007

using namespace std;

int read(){
   int s = 0,w = 1;
   char ch = getchar();
   while(ch < '0' || ch > '9'){if(ch == '-')w = -1;ch = getchar();}
   while(ch >= '0' && ch <= '9')s = s * 10 + ch - '0',ch = getchar();
   return s * w;
}

int n,m;

int poww(int b,int p = mod - 2,int m = mod) {
	b %= m;
	int s = 1 % m;
	for(;p;p >>= 1,b = (int)b * b % m)if(p & 1)s = (int)s * b % m;
	return s;
}

int lowbit(int x){
	return x & -x;
}

struct node{
	int tree[1000010];
	
	void update(int i,int x){
		for(;i <= n;i += lowbit(i)){
			tree[i] += x;
			tree[i] %= mod;
		}
	}
	
	int query(int x){
		int s = 0;
		for(;x;x -= lowbit(x))s += tree[x],s %= mod;
		return s % mod;
	}
}T[3];

signed main(){
	cin>>n>>m;
	for(int i = 1;i <= n;i ++){
		int x;
		x = read();
		T[1].update(i,x % mod);
		T[2].update(i,x * x % mod);
	}
	while(m --){
		int op,x,y;
		op = read(),x = read(),y = read();
		if(op == 1){
			int num1 = T[1].query(x) - T[1].query(x - 1);
			int num2 = T[2].query(x) - T[2].query(x - 1);
			T[1].update(x,(y - num1) % mod);
			T[2].update(x,(y * y - num2) % mod);
		}
		else {
			int sum = (T[1].query(y) - T[1].query(x - 1)) % mod;
			int sqsum = (T[2].query(y) - T[2].query(x - 1)) % mod;
			int inv = poww(y - x + 1);
			int p = (int)sum * inv % mod;
			int ans = (int)sqsum * inv % mod - (int)p * p % mod;
			ans = (ans % mod + mod) % mod;
			cout<<ans<<endl;
		}
	}
	return 0;
}
```

---

## 作者：滑稽的小宫 (赞：2)

## 带修莫队

单点修改？区间查询？果断带修莫队

**（不了解带修莫队的小伙伴们可以参考一下[这个](https://www.luogu.com.cn/blog/xiaogong/post-0x44-fen-kuai)）**

计算方差有一个比较好用的公式，下面来推导一下：
$$
s^2=\frac 1 n [(a_1-\bar a)^2+(a_2-\bar a)^2+\cdots+(a_n-\bar a)]
$$

$$
=\frac 1n [(a_1^2+a_2^2+\cdots+a_n^2)-2(a_1+a_2+\cdots+a_n)*\bar a+n*\bar a^2]
$$

带入 $\bar a=\frac {a_1+a_2+\cdots+a_n}{n}$,得：
$$
s^2=\frac 1 n [(a_1^2+a_2^2+\cdots+a_n^2)-2\frac{(a_1+a_2+\cdots+a_n)^2}{n}+\frac {(a_1+a_2+\cdots+a_n)^2}{n}]
$$

$$
=\frac {(a_1^2+a_2^2+\cdots+a_n^2)-\frac{(a_1+a_2+\cdots+a_n)^2}{n}}{n}
$$

然后分子分母同时乘上一个n得：
$$
s^2=\frac {n\times(a_1^2+a_2^2+\cdots+a_n^2)-(a_1+a_2+\cdots+a_n)^2}{n^2}
$$
这样就把方差转化为了用平方和、代数和与项数表示的函数

因此我们维护一下平方和s2，代数和s即可，项数可以由询问的r-l+1即可

注意分母的n方要转化为关于p的逆元，然后再乘上去，这里用费马小定理求逆元

$Talk\ is\ cheap,\ show\ you\ the\ code:$

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#define N 100010
#define ll long long
const ll p=1000000007;
int n,m;
ll an[N],sz,a[N],s2,s;
class query{
	public:
	ll l,r,t,id;
	bool operator <(query x)const{//带修莫队基本操作
		if(l/sz==x.l/sz){
			if(r/sz==x.r/sz)return t<x.t;
			else return r<x.r;
		}else return l<x.l;
	}
}q[N];
class changing{
	public:
	int p;
	ll v,lst;
}op[N];
void add(ll v){//这里是把一个值加入到方差集合里面
	s2=(s2+v*v%p);//平方和加上插入值的平方
	s=(s+v%p)%p;//代数和加上这个值
	return;
}void del(ll v){//把一个值从里面删除
	s2=(s2-v*v%p+p)%p;//注意加上一个p以免变为负数取余出问题
	s=(s-v%p+p)%p;
	return;
}void Do(int k,int l,int r){//执行一个修改操作，带修莫队基本操作
	int p=op[k].p;
	op[k].lst=a[p];
	a[p]=op[k].v;
	if(p<=r&&p>=l)del(op[k].lst),add(op[k].v);
	return;
}void Redo(int k,int l,int r){//恢复一个修改操作，带修莫队基本操作
	int p=op[k].p;
	op[k].v=a[p];
	a[p]=op[k].lst;
	if(p<=r&&p>=l)del(op[k].v),add(op[k].lst);
}ll fpow(ll a,ll x){//快速幂，一个数的p-2次方就是它关于p的逆元（p为质数）
	if(x==0)return 1;
	ll r=fpow(a,x/2);
	if(x&1)return r*r%p*a%p;
	else return r*r%p;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	int que=0,tm=0;
	for(int i=1;i<=m;i++){
		int c,x,y;
		scanf("%d%d%d",&c,&x,&y);
		if(c==1)op[++tm]=(changing){x,y,0};
		else q[++que]=(query){x,y,tm,que};
	}if(tm==0)tm=1;
	sz=std::pow((ll)n*n*2*tm/que,0.33333);//这里块大小的计算是经过了一些推导，具体过程请看题解开头给出的链接文章中带修莫队的最后一部分
  //这里也可以用pow(n,0.69)或者pow(1.414*n,0.66667)当做块长卡过时限
	std::sort(q+1,q+que+1);
	int l=1,r=0,t=0;
	for(int i=1;i<=que;i++){
    //带修莫队基本操作
		while(l<q[i].l)del(a[l++]);
		while(l>q[i].l)add(a[--l]);
		while(r<q[i].r)add(a[++r]);
		while(r>q[i].r)del(a[r--]);
		while(t<q[i].t)Do(++t,l,r);
		while(t>q[i].t)Redo(t--,l,r);
		ll len=r-l+1;
		an[q[i].id]=(len*s2%p-s*s%p+p)%p*fpow(len*len%p,p-2)%p;//计算方差，len^2的逆元是它的p-2次方
	}for(int i=1;i<=que;i++)printf("%lld\n",an[i]);
	return 0;
}
```



---

## 作者：int32 (赞：1)

~~这都有蓝~~

## $\sf Sol$

线段树板子题。

先推一波柿子：

对于区间 $[l,r]$，其方差为：

$$s^2=\dfrac1d\sum_{i=l}^r (a_i-\bar a)$$

$$s^2=\dfrac1d(\sum_{i=l}^ra_i^2-2\bar a\sum_{i=l}^r a_i+d\bar a^2)$$

$$s^2=\dfrac1d(\sum_{i=l}^ra_i^2-2\bar a\times d\bar a+d\bar a^2)$$

$$s^2=\dfrac1d(\sum_{i=l}^ra_i^2-d\bar a^2)$$

$$s^2=\dfrac1d\sum_{i=l}^ra_i^2-\bar a^2$$

$$s^2=\dfrac1d\sum_{i=l}^ra_i^2-\dfrac1{d^2}(\sum_{i=l}^r a_i)^2$$

（其中 $d=r-l+1$）

于是考虑维护 $\sum_{i=l}^ra_i^2$ 和 $\sum_{i=l}^r a_i$（即区间平方和及区间和）。

然后正常按照线段树单点修改，区间查询做即可。

注意：最后要进行有理数取模，$d$ 的逆元用快速幂求。

## $\sf Main\ Code$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
const int mod=1e9+7;
int n, m;
int a[N];
int sum[N<<2], sqr[N<<2];
#define lc rt<<1
#define rc lc|1
void pushup(int rt){
    sum[rt]=(sum[lc]+sum[rc])%mod;
    sqr[rt]=(sqr[lc]+sqr[rc])%mod;
}
void build(int rt, int l, int r){
    if(l==r){
        sum[rt]=a[l]%mod;
        sqr[rt]=a[l]*a[l]%mod;
        return;
    }
    int mid=l+r>>1;
    build(lc,l,mid);
    build(rc,mid+1,r);
    pushup(rt);
}
void update(int rt, int q, int l, int r, int delta){
    if(l==r){
        sum[rt]=delta%mod;
        sqr[rt]=delta*delta%mod;
        return;
    }
    int mid=l+r>>1;
    if(q<=mid) update(lc,q,l,mid,delta);
    else update(rc,q,mid+1,r,delta);
    pushup(rt);
}
int total(int rt, int ql, int qr, int l, int r){
    if(ql<=l&&qr>=r) return sum[rt]%mod;
    int mid=l+r>>1;
    int res=0ll;
    if(ql<=mid) res=(res+total(lc,ql,qr,l,mid))%mod;
    if(qr>mid) res=(res+total(rc,ql,qr,mid+1,r))%mod;
    return res%mod;
}
int square(int rt, int ql, int qr, int l, int r){
    if(ql<=l&&qr>=r) return sqr[rt]%mod;
    int mid=l+r>>1;
    int res=0ll;
    if(ql<=mid) res=(res+square(lc,ql,qr,l,mid))%mod;
    if(qr>mid) res=(res+square(rc,ql,qr,mid+1,r))%mod;
    return res%mod;
}
#undef lc
#undef rc
int qpow(int a, int b){
    a%=mod;
    int r=1ll;
    while(b){
        if(b&1) r=r*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return r%mod;
}
signed main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i];
    build(1,1,n);
    while(m--){
        int op, l, r, d;
        cin>>op;
        if(op==1){
            cin>>l>>d;
            update(1,l,1,n,d%mod);
        }
        else{
            cin>>l>>r;
            int rsum=total(1,l,r,1,n)%mod;
            int rsqr=square(1,l,r,1,n)%mod;
            int len=r-l+1;
            int inv=qpow(len,mod-2)%mod;
            int ans=((rsqr*
            inv%mod-(rsum*
            inv%mod)*(rsum*
            inv%mod)%mod)%
            mod+mod)%mod;
            cout<<ans<<'\n';
        }
    }
    return 0;
}
```

---

## 作者：lotus_grow (赞：1)



------------

### 题意

有一个长度为 $n$ 的序列 $b$ ，以及 $m$ 个操作。

操作 1 ：修改操作，将 $b_x$ 修改为 $y$ 。

操作 2 ：查询操作，查询 $b_x$ 到 $b_y$ 的方差。



------------

### 思路

套路题......

将方差公式化简，有

$nd=\sum_{i=1}^n (b_i-\overline{b})^2 =\sum_{i=1}^n (b_i^2-2b_i\overline{b}+\overline{b}^2)=\sum_{i=1}^nb_i^2-2n\overline{b}\sum_{i=1}^nb_i+n \overline{b}^2$

由 $\overline{b}=\frac{\sum_{i=1}^n b_i}{n}$

$nd=\sum_{i=1}^n b_i^2-2{(\sum_{i=1}^n b_i)}^2+\frac{{(\sum_{i=1}^n b_i)}^2}{n} $

所以 $n^2 d=n\sum_{i=1}^n b_i^2-2n{(\sum_{i=1}^n b_i)}^2+{(\sum_{i=1}^n b_i)}^2$

维护**区间和**以及**区间平方和**即可


------------

### 代码
```cpp
#include<cstdio>
#define mod 1000000007

using namespace std;
typedef long long ll;

struct node
{
	ll s,sq;
}c[300000];
int n,m;
int k,l,r;
ll a[300000];

int lowbit(int x)
{
	return x&(-x);
}
void insert(int x,ll k)
{
	int t=x;
	for(;x<=n;x+=lowbit(x)) c[x].s+=k,c[x].sq+=k*k+2*a[t]*k;
 	a[t]+=k;
}
node sum(int x)
{
	node t;
	t.s=0;t.sq=0;
	for(;x;x-=lowbit(x)) t.s+=c[x].s,t.sq+=c[x].sq;
	return t;
}
ll cal(int l,int r)
{
	node sl=sum(l-1),sr=sum(r);
	ll res=(r-l+1)*(sr.sq-sl.sq)-(sr.s-sl.s)*(sr.s-sl.s);
	return res%mod;
}
ll qp(ll x,int p)
{
    ll res=1;
    for(;p;p>>=1,x=x*x%mod)
        if(p&1) res=res*x%mod;
    return res;
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		int x;
		scanf("%d",&x);
		insert(i,x);
	}
	while(m--)
	{
		scanf("%d%d%d",&k,&l,&r);
		if(k==1) insert(l,r-a[l]);
		if(k==2) printf("%lld\n",cal(l,r)*qp((ll)(r-l+1)*(r-l+1)%mod,mod-2)%mod);
	}
	return 0;
}
```


---

## 作者：SunsetSamsara (赞：0)

## 前置知识

线段树，（一点点）数学

## 分析

维护区间方差，显然考虑线段树

考虑方差的计算公式

$$s ^ 2 = \dfrac{\sum\limits_{i = 1}^{n}(x_i -  \overline{x})^2}{n}$$

为了维护方差，得把它打开才能发现简单的维护方式：

$$s ^ 2 = \dfrac{\sum\limits_{i = 1}^{n}(x_i^2 - 2x_i \overline{x} + \overline{x}^2)}{n}$$
$$= \dfrac{\sum\limits_{i = 1}^{n}x_i^2}{n} - \dfrac{2\overline{x} \sum\limits_{i = 1}^{n} x_i}{n} + \overline{x}^2$$
$$= \dfrac{\sum\limits_{i = 1}^{n}x_i^2}{n} - \dfrac{2(\sum\limits_{i = 1}^{n} x_i)^2}{n^2} + \dfrac{(\sum\limits_{i = 1}^{n} x_i)^2}{n^2}$$
$$= \dfrac{\sum\limits_{i = 1}^{n}x_i^2}{n} - \dfrac{(\sum\limits_{i = 1}^{n} x_i)^2}{n^2}$$
$$= \dfrac{\sum\limits_{i = 1}^{n}x_i^2}{n} -\Bigg (\dfrac{\sum\limits_{i = 1}^{n} x_i}{n}\Bigg )^2$$

发现需要维护区间和与区间平方和，直接线段树维护。

最后有一点，分数取模。分母逆元乘分子就是分数取模后的值了。

## 代码
```cpp
#include <bits/stdc++.h>
#define lld long long
using namespace std;
const lld mod = 1e9 + 7;
struct node {
	lld sum;
	lld sum2;
	int l, r;
};
int n, m;
lld a[1000001];
struct SGT {
	node arr[1000001];
	void pushup(int x) {
		arr[x].sum = (arr[x << 1].sum + arr[x << 1 | 1].sum) % mod;
		arr[x].sum2 = (arr[x << 1].sum2 + arr[x << 1 | 1].sum2) % mod;
	}
	//建树 
	void build(int x, int l, int r) {
		arr[x].l = l;
		arr[x].r = r;
		if (l == r) {
			arr[x].sum = a[l];
			arr[x].sum2 = a[l] * a[l] % mod;
			return;
		}
		int mid = (l + r) >> 1;
		build(x << 1, l, mid);
		build(x << 1 | 1, mid + 1, r);
		pushup(x);
	}
	//线段树单点修改 
	void modify(int x, int k, lld d) {
		if(arr[x].l == arr[x].r) {
			arr[x].sum = d % mod;
			arr[x].sum2 = d * d % mod;
			return;
		}
		int mid = (arr[x].l + arr[x].r) >> 1;
		if (k <= mid) modify(x << 1, k, d);
		else modify(x << 1 | 1, k, d);
		pushup(x);
	}
	//线段树查询区间和取模 
	lld query1(int x, int l, int r) {
		if (l <= arr[x].l && arr[x].r <= r)
			return arr[x].sum;
		int mid = (arr[x].l + arr[x].r) >> 1;
		lld ret = 0;
		if (l <= mid) ret = (ret + query1(x << 1, l, r)) % mod;
		if (mid < r) ret = (ret + query1(x << 1 | 1, l, r)) % mod;
		return ret;
	}
	//线段树查询区间平方和取模 
	lld query2(int x, int l, int r) {
		if (l <= arr[x].l && arr[x].r <= r)
			return arr[x].sum2;
		int mid = (arr[x].l + arr[x].r) >> 1;
		lld ret = 0;
		if (l <= mid) ret = (ret + query2(x << 1, l, r)) % mod;
		if (mid < r) ret = (ret + query2(x << 1 | 1, l, r)) % mod;
		return ret;
	}
}T;
//逆元 
lld invx(lld x) {
	lld pw = mod - 2, ret = 1;
	for (; pw; pw >>= 1, x = x * x % mod)
		if (pw & 1) ret = ret * x % mod;
	return ret;
}
signed main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; ++ i)
		scanf("%lld", a + i);
	T.build(1, 1, n);
	int op;
	lld x, y;
	for (; m --; ) {
		scanf("%d", &op);
		scanf("%lld%lld", &x, &y);
		if (op == 1)
			T.modify(1, x, y);
		else if (op == 2) {
			lld sum1, sum2, inv, ans;
			inv = invx(y - x + 1);
			sum1 = T.query2(1, x, y) * inv % mod;
			sum2 = T.query1(1, x, y) * inv % mod;
			ans = sum1 - sum2 * sum2 % mod;
			ans = (ans % mod + mod) % mod;
			printf("%lld\n", ans);
		}
	}
}

```

---

## 作者：神眷之樱花 (赞：0)

# 更全面的题解
[安利我的博客](https://www.cnblogs.com/sjzyh/p/14838705.html)
# 题解
这道题和 P1471 比起来更为简单，连 tag 标记都不用打，只需要展开方差柿子即可：

方差公式为：
$$\frac{1}{n} * \sum_{i = l} ^ {r} (a_i - \bar a) ^ 2$$
这样我们肯定很难维护，于是我们尝试把平方打开，就会发现这道题迎刃而解了：
$$\sum_{i = l} ^ {r} (a_i - \bar a) ^ 2\ = \ (a_{l} ^ 2 + a_{l + 1} ^ 2 + … + a_{r} ^ 2) - 2 * \bar a *(a_l + a_{l + 1} + … + a_r) - (r - l + 1) * \bar a ^ 2 $$
不难发现中间是我们维护的区间和，后面可以直接计算，所以我们就只需要再维护一个区间平方和即可。

然后这道题就做完了。

如果想冲榜可以改用树状数组写法，或者 zkw线段树。
```cpp
#include<cstdio>

const int N = 1e5 + 5,mod = 1e9 + 7;

int a[N],n,m;
struct SegmentTree {
	#define M N << 2
	int l[M],r[M],sum[M],pow[M];
	inline void pushup(int p) {
		pow[p] = (1ll * pow[p << 1] + pow[p << 1 | 1]) % mod;
		sum[p] = (1ll * sum[p << 1] + sum[p << 1 | 1]) % mod;
	}
	void build(int p,int lf,int rg) {
		l[p] = lf; r[p] = rg;
		if(lf == rg) {
			sum[p] = a[lf] % mod; pow[p] = 1ll * a[lf] * a[lf] % mod;
			return ;
		}
		int mid = (lf + rg) >> 1;
		build(p << 1,lf,mid);
		build(p << 1 | 1,mid + 1,rg);
		pushup(p);
	}
	void update(int p,int pos,int k) {
		if(l[p] == pos && r[p] == pos) {
			sum[p] = k; pow[p] = 1ll * k * k % mod;
			return ;
		}
		int mid = (l[p] + r[p]) >> 1;
		if(pos <= mid) update(p << 1,pos,k);
		else update(p << 1 | 1,pos,k);
		pushup(p);
	}
	int query_sum(int p,int L,int R) {
		if(L <= l[p] && r[p] <= R) return sum[p];
		int mid = (l[p] + r[p]) >> 1; int res = 0;
		if(L <= mid) res = query_sum(p << 1,L,R) % mod;
		if(R >  mid) res = (1ll * res + query_sum(p << 1 | 1,L,R)) % mod;
		return res;
	}
	int query_pow(int p,int L,int R) {
		if(L <= l[p] && r[p] <= R) return pow[p];
		int mid = (l[p] + r[p]) >> 1; int res = 0;
		if(L <= mid) res = query_pow(p << 1,L,R) % mod;
		if(R >  mid) res = (1ll * res + query_pow(p << 1 | 1,L,R)) % mod;
		return res;
	}
}tr;

#undef M

int power(int a,int b = mod - 2,int ans = 1) {
	for(; b; b >>= 1,a = 1ll * a * a % mod)
		if(b & 1) ans = 1ll * ans * a % mod;
	return ans;
}

inline int read() {
	int x = 0,flag = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9'){if(ch == '-')flag = -1;ch = getchar();}
	while(ch >='0' && ch <='9'){x = (x << 3) + (x << 1) + ch - 48;ch = getchar();}
	return x * flag;
}

int main() {
	n = read(),m = read();
	for(int i = 1; i <= n; i++) a[i] = read();
	tr.build(1,1,n);
	for(int i = 1; i <= m; i++) {
		int opr = read(),x = read(),y = read();
		if(opr == 1) tr.update(1,x,y % mod);
		else {
			int inv = power(y - x + 1);
			int ave = 1ll * tr.query_sum(1,x,y) * inv % mod;
			int Pow = 1ll * tr.query_pow(1,x,y) * inv % mod;
			printf("%d\n",((1ll * Pow - 1ll * ave * ave % mod) % mod + mod) % mod);
		}
	}
	return 0;
}
```


---

## 作者：Suzt_ilymtics (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5142)

## **简述题意**

> 给一段序列，支持区间求方差，单点修改

## **前置芝士**

- 线段树/树状数组/分块
- 逆元
- 推式子

## **Solution**

题目中已经给出了方差的求法，我们这里设 $len$ 表示要求的区间长度：

$$d = \frac{1}{len} \sum_{i = l}^{r} (a_i - \overline{a})^2$$

看上去不好维护，让我们化简试试：

$$d = \frac{1}{len} \sum_{i = l}^{r} (a_i^2 - 2 \cdot a_i \cdot \overline{a} + \overline{a}^2)$$

直接利用乘法分配律将其分开：

$$d = \frac{1}{len} \sum_{i = l}^{r} a_i^2 - \frac{1}{len} \sum_{i = l}^{r} 2 \cdot a_i \cdot \overline{a} + \frac{1}{len} \sum_{i = l}^{r} \overline{a}^2$$

很简单的昂，把无关项提出来,得到：

$$d = \frac{1}{len} \sum_{i = l}^{r} a_i^2 - 2 \cdot \overline{a} \cdot \frac{1}{len} \sum_{i = l}^{r} a_i +  \overline{a}^2$$

因为 $\overline{a} = \frac{1}{len} \sum_{i = l}^{r} a_i$，所以继续化简可以得到：

$$d = \frac{1}{len} \sum_{i = l}^{r} a_i^2 - 2 \cdot \overline{a}^2 +  \overline{a}^2$$

$$d = \frac{1}{len} \sum_{i = l}^{r} a_i^2 -  \overline{a}^2$$


然后直接pia的一下，把线段树扔上去，维护个区间和和区间平方和，连```Push_down```都不需要写，就做完了。

但是！！

我们知道方差经常是分数形式，并且这还是在模意义下。

那么求出分母的逆元就好了，具体原理见[有理数取余](https://www.luogu.com.cn/problem/P2613)。

求逆元有两种方法（我们定义 $a$ 的逆元为 $a^{-1}$）：

- 费马小定理：$a^{-1} = a^{p - 2} \bmod {p}$；

- 线性求逆元递推公式：
$inv_i = (p - \frac{p}{i}) \times  inv_{p \bmod i} \bmod p $，证明的话可以看[这道题](https://www.luogu.com.cn/problem/P3811)。

### Tips:

- 记得开 ```long long```；
- 取模要彻底。

剩下的看代码吧。

## Code

```cpp
/*
Work by: Suzt_ilymics
Problem: P5142 区间方差
Knowledge: 线段树
Time: O(nlogn)
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define LL long long
#define int long long
#define orz cout<<"lkp AK IOI!"<<endl

using namespace std;
const int MAXN = 1e5+5;
const int INF = 1e9+7;
const int mod = 1e9+7;

int n, m;
int a[MAXN], inv[MAXN];

int read(){
    int s = 0, f = 0;
    char ch = getchar();
    while(!isdigit(ch))  f |= (ch == '-'), ch = getchar();
    while(isdigit(ch)) s = (s << 1) + (s << 3) + ch - '0' , ch = getchar();
    return f ? -s : s;
}

namespace Seg{
    #define lson i << 1
    #define rson i << 1 | 1
    struct Tree{ int val, sum; }tree[MAXN << 2];
    void Push_up(int i) { // 更新 
        tree[i].val = (tree[lson].val + tree[rson].val) % mod;
        tree[i].sum = (tree[lson].sum + tree[rson].sum) % mod;
    } 
    void Build(int i, int l, int r) { // 建树 
        if(l == r) { tree[i].val = a[l] % mod, tree[i].sum = a[l] * a[l] % mod; return ; }
        int mid = (l + r) >> 1;
        Build(lson, l, mid), Build(rson, mid + 1, r);
        Push_up(i);
    }
    void Modify(int i, int l, int r, int L, int R, int val_) { // 单点修改，粘的模板所以写的区间修改的形式 
        if(L <= l && r <= R) { tree[i].val = val_ % mod, tree[i].sum = val_ * val_ % mod; return ; }
        int mid = (l + r) >> 1;
        if(mid >= L) Modify(lson, l, mid, L, R, val_);
        if(mid < R) Modify(rson, mid + 1, r, L, R, val_);
        Push_up(i);
    }
    int Query1(int i, int l, int r, int L, int R) { // 区间和 
        if(L <= l && r <= R) return tree[i].val;
        int mid = (l + r) >> 1, ans = 0;
        if(mid >= L) ans += Query1(lson, l, mid, L, R);
        if(mid < R) ans += Query1(rson, mid + 1, r, L, R);
        return ans % mod;
    }
    int Query2(int i, int l, int r, int L, int R) { // 区间平方和 
        if(L <= l && r <= R) return tree[i].sum;
        int mid = (l + r) >> 1, ans = 0;
        if(mid >= L) ans += Query2(lson, l, mid, L, R);
        if(mid < R) ans += Query2(rson, mid + 1, r, L, R);
        return ans % mod;
    }
}

void Init() {
    inv[0] = inv[1] = 1; // 线性求逆元，注意初始化 
    for(int i = 2; i <= n; ++i) inv[i] = (mod - mod / i) * inv[mod % i] % mod;
}

int Quick_Pow(int x, int p, int mod) { // 快速幂（然而没用到 
    int res = 1;
    while(p) {
        if(p & 1) res = res * x % mod;
        x = x * x % mod;
        p >>= 1;
    }
    return res;
}

signed main()
{
    n = read(), m = read();
    Init();
    for(int i = 1; i <= n; ++i) a[i] = read();
    Seg::Build(1, 1, n);
    for(int i = 1, opt, l, r; i <= m; ++i) {
        opt = read(), l = read(), r = read();
        if(opt == 1) Seg::Modify(1, 1, n, l, l, r);
        else {
            int len = r - l + 1;
            int sum1 = Seg::Query1(1, 1, n, l, r) * inv[len] % mod; 
            int sum2 = Seg::Query2(1, 1, n, l, r) * inv[len] % mod;
            printf("%lld\n", (sum2 - sum1 * sum1 % mod + mod) % mod);
        }
    }
    return 0;
}

```

---

## 作者：KEBrantily (赞：0)

本题化完简单式子然后直接上线段树即可。

## Description

给定一个序列，对其进行单点修改和求区间方差的操作。

注意输出方差时要以分数取模形式输出。

## Solution

单点修改不多说，来看求区间方差。

假设我们要求的是 $[x,y]$ 的方差，也就是求：

$${\frac{1}{y-x+1}\sum_{i=x}^y}(a_i-\overline a)^2$$

化简以下（为了方便设 $d=y-x+1$）：

${=\frac{1}{d}\sum_{i=x}^y(a_i^2-2a_i\overline a+\overline a^2)}$

${=\frac{1}{d}[\sum_{i=x}^y(a_i^2-2a_i\overline a)]+\overline a^2}$

${=\frac{1}{d}\sum_{i=x}^ya_i^2}-\frac{1}{d}\sum_{i=x}^ya_i\cdot 2\overline a+\overline a^2$

${=\frac{1}{d}\sum_{i=x}^ya_i^2}-2\overline a^2+\overline a^2$

${=\frac{1}{d}\sum_{i=x}^ya_i^2}-\overline a^2$

所以根据推导过程可以看出，我们需要维护的是区间平方和以及区间和。

然后就上线段树板子，最后按上面的公式求值，分数换成逆元即可。

## Code

```cpp
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#define maxn 510010
#define INF 0x3f3f3f3f
#define int long long
#define Mod 1000000007

using namespace std;

int n,m,a[maxn];

inline int read(){
    int s=0,w=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=(s<<1)+(s<<3)+ch-'0',ch=getchar();
    return s*w;
}

int quickpow(int x,int y){
    int ans=1;
    while(y){
        if(y&1)ans=(ans*x)%Mod;
        x=(x*x)%Mod;y>>=1;
    }
    return ans;
}

namespace Seg{
    #define ls x<<1
    #define rs x<<1|1
    #define f(x) x*x%Mod
    int sum[maxn],fsum[maxn];
    
    void pushup(int x){
        sum[x]=(sum[ls]+sum[rs])%Mod;
        fsum[x]=(fsum[ls]+fsum[rs])%Mod;
    }
    
    void build(int x,int l,int r){
        if(l==r){
            sum[x]=a[l]%Mod;
            fsum[x]=f(a[l]);
            return;
        }
        int mid=l+r>>1;
        build(ls,l,mid);
        build(rs,mid+1,r);
        pushup(x);
    }
    
    void update(int x,int l,int r,int pos,int val){
        if(l==r){
            sum[x]=val%Mod;
            fsum[x]=f(val);
            return;
        }
        int mid=l+r>>1;
        if(pos<=mid) update(ls,l,mid,pos,val);
        else update(rs,mid+1,r,pos,val);
        pushup(x);
    } 
    
    int query(int x,int l,int r,int L,int R){
        int ans=0;
        if(L<=l&&R>=r) return sum[x]%Mod;
        int mid=l+r>>1;
        if(L<=mid) ans=(ans+query(ls,l,mid,L,R))%Mod;
        if(R>=mid+1) ans=(ans+query(rs,mid+1,r,L,R))%Mod;
        return ans%Mod;
    }
    
    int query2(int x,int l,int r,int L,int R){
        int ans=0;
        if(L<=l&&R>=r) return fsum[x]%Mod;
        int mid=l+r>>1;
        if(L<=mid) ans=(ans+query2(ls,l,mid,L,R))%Mod;
        if(R>=mid+1) ans=(ans+query2(rs,mid+1,r,L,R))%Mod;
        return ans%Mod;
    }   
    
    int query3(int x,int l,int r,int L,int R,int val){
        int ans=0;
        if(L<=l&&R>=r) return fsum[x]%Mod;
        int mid=l+r>>1;
        if(L<=mid) ans=(ans+query2(ls,l,mid,L,R))%Mod;
        if(R>=mid+1) ans=(ans+query2(rs,mid+1,r,L,R))%Mod;
        return ans%Mod;
    }
}

signed main(){
    n=read();m=read();
    for(int i=1;i<=n;i++) 
        a[i]=read();Seg::build(1,1,n);
    for(int i=1,opt,fir,sec;i<=m;i++){
        opt=read();fir=read();sec=read();
        if(opt==1) Seg::update(1,1,n,fir,sec);
        else{
            int ni=quickpow(sec-fir+1,Mod-2);
            int ave=Seg::query(1,1,n,fir,sec)*ni%Mod;
            int ans=Seg::query2(1,1,n,fir,sec)*ni%Mod-f(ave);
            printf("%lld\n",(ans%Mod+Mod)%Mod);
        }
    }
    return 0;
}
```


---

## 作者：Jsxts_ (赞：0)

# 题解 P5142 区间方差
[传送门](https://www.luogu.com.cn/problem/P5142)
## 题意
给你一个序列 $a$，支持两种操作：

1、将 $a_x$ 修改为 $y$。 

2、询问 $x \sim y$ 的方差。

## 题解

这里提供一种分块的做法。

推方差的柿子就不写了，可以在其他大佬的题解上看。

最终的式子为：

$$\sigma^2=\dfrac 1 {y-x+1} \sum_{i=x} ^ y a_i^2-b^2$$

其中 $b$ 为 $x \sim y$ 的平均数：

$$b=\dfrac 1 {y-x+1} \sum_{i=x}^y a_i$$

接下来是分块的思路：

维护块内区间和、区间平方和，就可以求出上面的式子了，剩下的散块暴力查找。

关于分数取模，因为 $a$ 除以 $b$ 模 $mod$ 等于 $a$ 乘以模 $b$ 意义下的逆元。所以我们用费马小定理求逆元即可。

最后记得一定要多取模！！

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 1000000007;
int n,m,sq;
ll a[100010];
int st[1010],ed[1010];
int bl[100010],cnt;
ll sum[1010],sum2[1010];
ll ksm(ll a,ll b,ll p) {//费马小定理求逆元 
	a %= p;
	ll res = 1;
	while (b) {
		if (b & 1) res = (res * a) % p;
		b >>= 1;
		a = (a * a) % p;
	}
	return res;
}
void build() {//建块 
	sq = sqrt(n);
	for (int i = 1;i <= n;i += sq) {
		st[++cnt] = i;
		ed[cnt] = min(n,i+sq-1);
		for (int j = st[cnt];j <= ed[cnt];j ++ ) {
			bl[j] = cnt;
			sum[cnt] += a[j];//预处理区间和、区间平方和 
			sum2[cnt] = (sum2[cnt] + a[j]*a[j]) % mod;
		}
	}
}
void modify_simple(int x,ll s) {//单点修改 
	sum[bl[x]] -= a[x];
	sum2[bl[x]] -= a[x]*a[x];
	a[x] = s;
	sum2[bl[x]] = (sum2[bl[x]] + a[x]*a[x]) % mod;
	sum[bl[x]] += a[x];
}
ll query_fc(int x,int y) {//区间方差 
	int l = bl[x],r = bl[y];
	ll res = 0,res2 = 0;
	ll len = (y-x+1);
	ll inv = ksm(len,mod-2,mod);
	if (l == r) {//散块暴力 
		for (int i = x;i <= y;i ++ ) res += a[i],res2 = (res2 + a[i]*a[i])%mod;
		ll t = res * inv % mod;//分数取模 
		return ((res2 * inv % mod - t*t%mod)%mod+mod)%mod;//根据式子算答案 
	}
	for (int i = x;i <= ed[l];i ++ ) res += a[i],res2 = (res2 + a[i]*a[i])%mod;
	for (int i = l + 1;i < r;i ++ ) {
		res += sum[i];//整块查询 
		res2 += sum2[i];
	}
	for (int i = st[r];i <= y;i ++ ) res += a[i],res2 = (res2 + a[i]*a[i])%mod;
	ll t = res * inv % mod;
	return ((res2 * inv % mod - t*t%mod)%mod+mod)%mod;
}

int main() {
	scanf("%d%d",&n,&m);
	for (int i = 1;i <= n;i ++ ) {
		scanf("%lld",&a[i]);
	}
	build();
	while (m -- ) {
		int op,x;
		ll y;
		scanf("%d%d%lld",&op,&x,&y);
		if (op == 1) modify_simple(x,y);
		else printf("%lld\n",query_fc(x,y));
	}
	return 0;
}
```

Time: 503 ms，比线段树慢一点。

强化版：P1471。

---

## 作者：ricky0916 (赞：0)

[弱化版](https://www.luogu.com.cn/problem/P1471)

# 题解 P5142 【区间方差】

题意：~~请写出一个数据结构，使它满足两种操作。~~

$ 1. $单点修改$ b_x=y $

$ 2. $访问 $ d( or$ $ s^2)=\frac{1}{r-l+1}\sum_{i=l}^{r}(b_i-\frac{1}{r-l+1}\sum_{j=l}^rb_j)^2  $，其中$ l,r $为边界

显然因为有在单点和区间上做的事，所以考虑用线段树

现在看方差的式子

令$ a=\frac{1}{r-l+1}\sum_{i=l}^rb_i $（原题定义）

则可以将原式展开

$ \frac{1}{r-l+1}\sum_{i=l}^{r}(b_i-a)^2 $

$ =\frac{1}{r-l+1}(\sum_{i=l}^{r}b_i^2-2\sum_{i=l}^rb_i \times a+a^2\times(r-l+1)) $

$ =\frac{1}{r-l+1}\sum_{i=l}^r b_i^2-\frac{2}{(r-l+1)^2}\times a^2+\frac{1}{(r-l+1)^2} \times a^2 $

$ =\frac{1}{r-l+1}\sum_{i=l}^rb_i^2-(\frac{1}{r-l+1}\times a)^2 $

这样，我们就可以维护两个量，一个区间和，一个区间平方和

这里要对$ 1000000007 $取模，考虑到费马小定理，即$p$为奇数且$(a,p)=1$时，$ a^{p-1}\equiv1\pmod p$

所以$ a^{-1}\equiv a^{p-2}\pmod p $，一个快速幂就行了

当然，由于分母$ =r-l+1<10^7 $，一个预处理就好了，不需要每一次都去求 ~~（快速幂方便）~~

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int val1[400010],val2[400010],init_val[100010],k,inv[100010];
int n,m,opt,x,y;
const int p=1e9+7;
inline int read(){
	int x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	return x;
}
inline void putss(int x){
	if(x/10) putss(x/10);
	putchar(x%10+'0');
}
void init(int x){
	inv[1]=1;
	for(int i=2;i<=x;i++){
        inv[i]=1ll*inv[p%i]*(p-p/i)%p;
    }
}
void push_up(int rt){
	val1[rt]=(val1[rt*2+1]+val1[rt*2+2])%p;
	val2[rt]=(val2[rt*2+1]+val2[rt*2+2])%p;
}
void build(int rt,int l,int r){
	if(l==r){
		val1[rt]=init_val[l];
		val2[rt]=1ll*init_val[l]*init_val[l]%p;
		return;
	}
	int mid=(l+r)/2;
	build(rt*2+1,l,mid);
	build(rt*2+2,mid+1,r);
	push_up(rt);
}
int query1(int rt,int l,int r,int ql,int qr){
	if(ql>r||qr<l) return 0;
	if(qr>=r&&ql<=l) return val1[rt];
	int mid=(l+r)/2;
	return (query1(rt*2+1,l,mid,ql,qr)+query1(rt*2+2,mid+1,r,ql,qr))%p;
}
int query2(int rt,int l,int r,int ql,int qr){
	if(ql>r||qr<l) return 0;
	if(qr>=r&&ql<=l) return val2[rt];
	int mid=(l+r)/2;
	return (query2(rt*2+1,l,mid,ql,qr)+query2(rt*2+2,mid+1,r,ql,qr))%p;
}
void update_one(int rt,int l,int r,int idx,int x){
	if(l==r){
		val1[rt]=x;
		val2[rt]=1ll*x*x%p;
		return;
	}
	int mid=(l+r)/2;
	if(mid>=idx) update_one(rt*2+1,l,mid,idx,x);
	else update_one(rt*2+2,mid+1,r,idx,x);
	push_up(rt);
}
int main(){
	n=read();
	m=read();
	for(int i=0;i<n;i++){
		init_val[i]=read();
	}
	build(0,0,n-1);
	init(n);
	while(m--){
		opt=read();
		if(opt==1){
			x=read();
			k=read();
			update_one(0,0,n-1,x-1,k);
		}
		else{
			x=read();
			y=read();
			int tmp1=1ll*query1(0,0,n-1,x-1,y-1)*inv[y-x+1]%p,tmp2=1ll*query2(0,0,n-1,x-1,y-1)*inv[y-x+1]%p;
			putss(1ll*(tmp2-1ll*tmp1*tmp1%p+p)%p);
			putchar('\n');
		}
	}
	return 0;
}
```
## 附:
在弱化版里有一个区间修改，我们考虑如何做区间修改

设$ [l,r] $区间每个数被加了$ k $

则$ \sum_{i=l}^{r}(b_i+k)^2 $

$ =\sum_{i=l}^r b_i^2+2k\sum_{i=l}^rb+(r-l+1)\times k^2 $

这样区间更新时我们只要先$ pushdown $区间平方和，再做区间和就好了

$ pushdown $代码（可能有点丑）：

```cpp
void push_down(int rt,int l,int r){
	if(lazy[rt]!=0){
		lazy[rt*2+1]+=lazy[rt];
		lazy[rt*2+2]+=lazy[rt];
		int mid=(l+r)/2;
		val2[rt*2+1]+=2*val1[rt*2+1]*lazy[rt]+lazy[rt]*lazy[rt]*(mid-l+1);
		val2[rt*2+2]+=2*val1[rt*2+2]*lazy[rt]+lazy[rt]*lazy[rt]*(r-mid);
		val1[rt*2+1]+=(mid-l+1)*lazy[rt];
		val1[rt*2+2]+=(r-mid)*lazy[rt];
		lazy[rt]=0;
	}
}
```


---

## 作者：PragmaGCC (赞：0)

这道题与 [P1471](https://www.luogu.com.cn/problem/P1471) 非常相似，可以说是弱化版，但是增加了一个有理数取膜。

不会有理数取膜可以去做一下 [P2613 【模板】有理数取余](https://www.luogu.com.cn/problem/P2613)。

建议写完这道题后去写 P1471。

我们并不知道怎样快速求区间的方差，所以我们尝试推一下柿子：
$$\sum_{i=1}^{n}(v_i-\overline{v}) = \dfrac{\sum_{i=1}^nv_i^2 + n\overline{v}^2 - 2\overline{v}\sum_{i-1}^nv_i}{n}
=\dfrac{\sum_{i=1}^nv_i^2}{n} - \overline{v}^2
$$
PS：n代表查询区间长度。

区间平均值可以通过区间和得到，我们只需要再维护一个区间平方和即可。

可以使用线段树来维护。

而在最后的除以 n 需要用逆元来处理，这里选择费马小定理求逆元（因为我写拓欧锅掉了qwq）

至于我的线段树是指针版的，个人感觉更好写。

```cpp
#include <cstdio>
#define int long long
// 优美的代码陋习
int read() {
    register int n = 0;
    register char ch = getchar();
    bool f = 1;
    while (ch < '0' || ch > '9') {
        if (ch == '-')
            f = 0;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        n = (n << 3) + (n << 1) + (ch ^ '0');
        ch = getchar();
    }
    return f ? n : -n;
}
const int N = 1e5 + 5, mod = 1e9 + 7;
struct node {
    node *ch[2];
    int sum1, sum2;
    node() {
        ch[0] = ch[1] = NULL;
        sum1 = sum2 = 0;
    }
};
node *t;
int a[N];
void pushup(node *k) {
    k->sum1 = (k->ch[0]->sum1 + k->ch[1]->sum1) % mod;
    k->sum2 = (k->ch[0]->sum2 + k->ch[1]->sum2) % mod;
}
int sq(int num) { return num * num % mod; }
void build(node *k, int l, int r) {
    if (l == r) {
        k->sum1 = a[l] % mod;
        k->sum2 = sq(a[l]);
        return;
    }
    const int mid = l + r >> 1;
    k->ch[0] = new node();
    k->ch[1] = new node();
    build(k->ch[0], l, mid), build(k->ch[1], mid + 1, r);
    pushup(k);
}
void update(node *k, int q, int l, int r, int delta) {
    if (l == r) {
        k->sum1 = delta % mod;
        k->sum2 = sq(delta) % mod;
        return;
    }
    const int mid = l + r >> 1;
    if (q <= mid)
        update(k->ch[0], q, l, mid, delta);
    else
        update(k->ch[1], q, mid + 1, r, delta);
    pushup(k);
}
int query1(node *k, int ql, int qr, int l, int r) {
    if (l >= ql && r <= qr) {
        return k->sum1;
    }
    const int mid = l + r >> 1;
    int ans = 0;
    if (ql <= mid)
        ans += query1(k->ch[0], ql, qr, l, mid);
    if (qr > mid)
        ans += query1(k->ch[1], ql, qr, mid + 1, r);
    return ans;
}
int query2(node *k, int ql, int qr, int l, int r) {
    if (l >= ql && r <= qr) {
        return k->sum2;
    }
    const int mid = l + r >> 1;
    int ans = 0;
    if (ql <= mid)
        ans += query2(k->ch[0], ql, qr, l, mid);
    if (qr > mid)
        ans += query2(k->ch[1], ql, qr, mid + 1, r);
    return ans;
}
int getinv(int b) {
    int p = mod - 2;
	b %= mod;
	int s = 1 % mod;
	for(; p; p >>= 1, b = b * b % mod)
		if(p & 1) s = s * b % mod;
	return s;
}
signed main(void) {
    int n = read(), m = read();
    t = new node();
    for (int i = 1; i <= n; i++)
        a[i] = read();
    build(t, 1, n);
    while (m--) {
        int opt = read(), x = read(), y = read();
        if (opt == 1) {
            update(t, x, 1, n, y);
        } else {
            int a = query1(t, x, y, 1, n) % mod;
			int b = query2(t, x, y, 1, n) % mod;
			int inv = getinv(y - x + 1);
			int ans = b * inv % mod - sq(a * inv % mod);
		    ans = (ans % mod + mod) % mod;
            printf("%lld\n", ans);
        }
    }
    return 0;
}
```

---

## 作者：HPXXZYY (赞：0)

#### $\texttt{UPDATE on 2020/05/23:}$ 修复推导公式已知错误。

#### $\texttt{UPDATE on 2020/05/24:}$ 修复推导公式已知错误。

#### $\texttt{UPDATE on 2020/08/30:}$ 修复几个错别词。

------------------------------------

$\color{blue}{\texttt{[Solution]:}}$

咋一看，这题吓了我们一跳：方差该怎么维护？

像这种不好直接维护的量，我们通常有两种方法：

- 1. 把它转化为我们好维护的值来维护。
- 2. 强行维护它，考虑修改对它的结果的影响。

在实际编程中，第一种方法往往好打不好想，第二种方法是好想不好打。

比如这题，我们可以把方差的公式化简一下（记 $x$ 为序列 $a_{1..n}$ 的平均数，$s^2$ 即为方差）：

$$
\begin{aligned}
ns^2 &= \sum\limits_{i=1}^{n}  \left (a_i - x \right )^2\\
&= \sum\limits_{i=1}^{n} \left (a_i^2-2a_ix+x^2 \right )\\
&=\sum\limits_{i=1}^{n}a_i^2- 2nx^2+nx^2\\
&=\sum\limits_{i=1}^{n}a_i^2-nx^2
\end{aligned}
$$

又因为：


$$x=\dfrac{\sum\limits_{i=1}^{n}a_i}{n}$$

所以，我们可以得到：

$$s^2=\dfrac{\sum\limits_{i=1}^{n} a_i^2}{n}-\dfrac{\left (\sum\limits_{i=1}^{n} a_i \right )^2}{n^2}$$

于是，我们直接开两个树状数组分别维护区间平分和和区间和即可。

$\color{blue}{\texttt{[my AC code]:}}$

```cpp
const int mod=1e9+7;
const int N=1e5+100;
typedef long long ll;
int n,m,a[N];//a:记录序列 
struct Binary_Indexed_Tree{
	ll sum[N];//树状数组前缀和 
	Binary_Indexed_Tree(){
		memset(sum,0,sizeof(sum));
	}//自动初始化操作(是不是贼6~) 
	inline int F(int x){return x&(-x);}
	inline void updata(int x,ll t){//修改操作 
		for(;x<=n;x+=F(x)) sum[x]=(sum[x]+t)%mod;
	}//让a[x]变成a[x]+t(注意需要实时取模) 
	inline ll query(int x){//注意类型可能需要ll 
		register ll ans=0ll;//注意别漏了初始化 
		for(;x;x-=F(x)) ans=(ans+sum[x])%mod;
		return ans;//ans:前x个数的和对mod取模的值 
	}//query(x):求a[1]+...+a[x]，返回膜mod的结果 
}c1,c2;//c1:平方和,c2:原数和(用结构体封装树状数组) 
inline int sqr(int x){
	return 1ll*x*x%mod;
}
inline int ksm(int a,int b){
	register int res=1;
	while (b){
		if (b&1) res=1ll*res*a%mod;
		a=1ll*a*a%mod;b>>=1;
	}
	return res;
}
int main(){
	n=read();m=read();
	for(int i=1;i<=n;i++){
		register int x=read();
		c1.updata(i,sqr(a[i]=x));
		c2.updata(i,a[i]%mod);
	}
	for(int i=1,opt,l,r;i<=m;i++){
		opt=read();l=read();r=read();
		if (opt==1){//操作1:修改 
			c1.updata(l,(1ll*sqr(r)-sqr(a[l])+mod)%mod);
			c2.updata(l,(1ll*r-a[l]+mod)%mod);a[l]=r;
		}
		else{//否则就是操作2:查询 
			if (l==r){printf("0\n");continue;}//注意特判 
			int t1=(1ll*c1.query(r)-c1.query(l-1)+mod)%mod;
			int t2=(1ll*c2.query(r)-c2.query(l-1)+mod)%mod;
			int ans=1ll*sqr(t2)*sqr(ksm(r-l+1,mod-2))%mod;
			ans=((1ll*t1*ksm(r-l+1,mod-2)%mod-ans)%mod+mod)%mod;
			printf("%d\n",ans);
		}
	}
	return 0;
}

温馨提示：read() 函数即快读函数。
```

---

## 作者：Gauss0320 (赞：0)

此处的平均数其实就是指算数平均数，习惯上记作$\overline{X}$
$$\overline{X}=\frac{1}{n}\sum_{i=1}^nX_i$$
对方差公式进行展开:
$$δ^2=\frac{1}{n}\sum_{i=1}^n\Big(X_i-\overline{X}\Big)^2$$
根据完全平方公式，我们有：
$$δ^2=\frac{1}{n}\sum_{i=1}^n\Big(X_i^2-2X_i\overline{X}+\overline{X}^2\Big)\ $$
$$\ \ \ \ \ \ \ \ \ \ \ \ \ =\frac{1}{n}\Big(\sum_{i=1}^nX_i^2-2\overline{X}\sum_{i=1}^nX_i+n\overline{X}^2\Big)$$
$$\ \ \ \ \ \ \ \ \ \ \ \ =\frac{1}{n}\sum_{i=1}^nX_i^2-2\overline{X}\cdot \frac{1}{n}\sum_{i=1}^nX_i+\overline{X}^2$$
$$=\frac{1}{n}\sum_{i=1}^nX_i^2-\overline{X}^2\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ $$
想到用线段树来维护区间和与平方和，逆元可以用快速幂来求。
```cpp
#include <cstdio>
#include <iostream>
#define re register
#define ll long long
using namespace std;

const int N = 40010;
const ll M = 1e+9 + 7;
int n, m, c, a;
ll X[N<<2], b;
struct SegTree {
	ll s, qs;
	int l, r;
}T[N<<4];

void push_up(int x) {
	T[x].s = (T[x<<1].s + T[x<<1|1].s) % M,
	T[x].qs = (T[x<<1].qs + T[x<<1|1].qs) % M; 
}
void build(int x, int l, int r) {
	int mid = l + r >> 1;
	T[x].l = l, T[x].r = r;
	if(l == r) T[x].s = X[l] % M, T[x].qs = X[l] * X[l] % M;
	else build(x<<1, l, mid), build(x<<1|1, mid + 1, r), push_up(x);
}
void modify(int x, int ind, ll k) {
	if(T[x].l == T[x].r) {
		T[x].s = k % M, T[x].qs = k * k % M;
		return;
	}
	int mid = T[x].l + T[x].r >> 1;
	if(ind <= mid) modify(x<<1, ind, k);
	else modify(x<<1|1,ind,k);
	push_up(x);
}
ll query_sum(int x, int l, int r) {
	if(l <= T[x].l && T[x].r <= r) return T[x].s % M;
	ll res = 0;
	int mid = T[x].l + T[x].r >> 1;
	if(l <= mid) res += query_sum(x<<1, l, r), res %= M;
	if(r > mid) res += query_sum(x<<1|1, l, r), res %= M;
	return res % M;
}
ll query_qsum(int x, int l, int r) {
	if(l <= T[x].l && T[x].r <= r) return T[x].qs % M;
	ll res = 0;
	int mid = T[x].l + T[x].r >> 1;
	if(l <= mid) res += query_qsum(x<<1, l, r), res %= M;
	if(r > mid) res += query_qsum(x<<1|1, l, r), res %= M;
	return res % M;
}
ll qpow(ll a, ll b, ll res = 1) {
	while(b) {
		if(b & 1) res *= a , res %= M;
		a *= a, a %= M;
		b >>= 1;
	}
	return res;
}
int main()
{
	scanf("%d %d", &n, &m);
	for(re int i = 1; i <= n; i++)
		scanf("%lld", X + i);
	build(1, 1, n);
	while(m--) {
		scanf("%d %d %lld", &c, &a, &b);
		if(c == 1) modify(1, a, b % M);
		else {
			ll s = query_sum(1, a, b) % M, qs = query_qsum(1, a, b) % M, rev = qpow(b - a + 1, M - 2);
			printf("%lld\n", (M + M + M + qs * rev % M - s * rev % M * s % M * rev % M) % M);
		}
	}
	return 0;
}
```


---

## 作者：良月澪二 (赞：0)

没有线段树

不会化简的[看这里](https://www.luogu.org/blog/yhzq/solution-p1471)

由于有减法

所以最后的时候先加几个mod

可能是很多人10分的原因
```cpp
/**
 * @Date:   2019-03-31T19:57:45+08:00
 * @Last modified time: 2019-03-31T19:57:45+08:00
 */
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <complex>
#include <algorithm>
#include <climits>
#include <queue>
#include <map>
#include <set>
#include <vector>
#include <iomanip>
#define A 400010
#define B 2010

using namespace std;
typedef long long ll;
const ll mod = 1e9 + 7;
struct node {
    int l, r;
    ll w, ml;
}tree[A];
int n, m, opt, a;
ll b;
void build(int k, int l, int r) {
    tree[k].l = l; tree[k].r = r;
    if (l == r) {
        scanf("%lld", &tree[k].w); tree[k].w %= mod;
        tree[k].ml = tree[k].w * tree[k].w % mod;
        return;
    }
    int m = (l + r) >> 1;
    build(k << 1, l, m);
    build(k << 1 | 1, m + 1, r);
    tree[k].w = (tree[k << 1].w + tree[k << 1 | 1].w) % mod;
    tree[k].ml = (tree[k << 1].ml + tree[k << 1 | 1].ml) % mod;
}
void change(int k, int pos, ll add) {
    if (tree[k].l == tree[k].r) {
        tree[k].w = add;
        tree[k].ml = add * add % mod;
        return;
    }
    int m = (tree[k].l + tree[k].r) >> 1;
    if (pos <= m) change(k << 1, pos, add);
    else change(k << 1 | 1, pos, add);
    tree[k].w = (tree[k << 1].w + tree[k << 1 | 1].w) % mod;
    tree[k].ml = (tree[k << 1].ml + tree[k << 1 | 1].ml) % mod;
}
ll askw(int k, int l, int r) {
    if (tree[k].l >= l and tree[k].r <= r) return tree[k].w % mod;
    int m = (tree[k].l + tree[k].r) >> 1; ll ans = 0;
    if (l <= m) ans += askw(k << 1, l, r), ans %= mod;
    if (r > m) ans += askw(k << 1 | 1, l, r), ans %= mod;
    return ans % mod;
}
ll askwf(int k, int l, int r) {
    if (tree[k].l >= l and tree[k].r <= r) return tree[k].ml % mod;
    int m = (tree[k].l + tree[k].r) >> 1; ll ans = 0;
    if (l <= m) ans += askwf(k << 1, l, r), ans %= mod;
    if (r > m) ans += askwf(k << 1 | 1, l, r), ans %= mod;
    return ans % mod;
}
ll fpow(ll a, ll b, ll ans = 1) {
    while (b) {
        if (b & 1) ans = ans * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

int main(int argc, char const *argv[]) {
    scanf("%d%d", &n, &m); build(1, 1, n);
    while (m--) {
        scanf("%d%d%lld", &opt, &a, &b);
        if (opt == 1) change(1, a, b % mod);
        else {
            ll sum = askw(1, a, b) % mod, fsum = askwf(1, a, b) % mod;
            printf("%lld\n", (mod + mod + mod + fsum * fpow(b - a + 1, mod - 2) % mod -  sum * fpow(b - a + 1, mod - 2) % mod * sum % mod * fpow(b - a + 1, mod - 2) % mod) % mod);
        }
    }
    return 0;
}
```

---

## 作者：QMQMQM4 (赞：0)

# 很明显是一道数据结构来维护序列的题目

#### step1：维护什么？

区间方差，单点修改，在算方差时还需要用到平均数，需要区间和

首先方差的原始式子不好维护，先大力乱推一下

$\frac{1}{n}\sum_{i=1}^n(a_{i}-\overline{a})^2$

$=\frac{1}{n}\sum_{i=1}^n(a_{i}^2-2\times a_{i}\times \overline{a}+\overline{a}^2)$
						
$= \frac{1}{n}(\sum_{i=1}^n a_{i}^2- 2\times\overline{a}\sum_{i=1}^na_{i}+\sum_{i=1}^n\overline{a}^2)$

$=\frac{1}{n}(\sum_{i=1}^na_{i}-2\times\overline{a}\times n \overline{a}+ n \overline{a}^2)$

$=\frac{1}{n}(\sum_{i=1}^na_{i}^2-\sum_{i=1}^n\overline{a}^2)$

$=\frac{1}{n}\sum_{i=1}^n(a_{i}^2-\overline{a}^2)$

到这里就推出来，只需要维护区间平方和以及区间长度。

平均数$\overline{a} = \frac{1}{n}\sum_{i=1}^na_{i}$可看出用区间和除以区间长度

最后计算公式在代码里注释

#### step2：一些细节

需要采用分数取模，题面已经说的很清楚了，这里采用递推逆元的方法

区间长度$r-l+1$

注意开 long long 以及对答案取模的次数

```
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iostream>
using namespace std;

typedef long long ll;
const ll p = 1e9+7;
const ll maxn = 1e5+3;
//注意数组的大小
ll a[maxn],sumv1[maxn<<4],sumv2[maxn<<4],in[maxn],n,m;

inline void pushup(ll o)
{
	sumv1[o] = (sumv1[o<<1]+sumv1[o<<1|1])%p;
	sumv2[o] = (sumv2[o<<1]+sumv2[o<<1|1])%p;
}

inline void build(ll o,ll l,ll r)
{
	if(l==r)
	{
		sumv1[o] = a[l]%p;
		sumv2[o] = a[l]*a[l]%p;
		return ;
	}
	ll mid = (l+r)>>1;
	build(o<<1,l,mid);
	build(o<<1|1,mid+1,r);
	pushup(o);
}

void change(ll o,ll l, ll r,ll q,ll v)
{
	if(l==r)
	{
		sumv1[o] = v%p;
		sumv2[o] = v*v%p;
		return ;
	}
	ll mid = (l+r)>>1;
	if(q<=mid)
		change(o<<1,l,mid,q,v);
	else
		change(o<<1|1,mid+1,r,q,v);
	pushup(o);
}

//区间和
ll query1(ll o,ll l,ll r,ll ql,ll qr)
{
	if(ql<=l&&r<=qr)
		return sumv1[o]%p;
	ll ans = 0;
	ll mid = (l+r)>>1;
	if(ql<=mid)
		ans += query1(o<<1,l,mid,ql,qr)%p;
	if(qr>mid)
		ans += query1(o<<1|1,mid+1,r,ql,qr)%p;
	return ans%p;
}

//区间平方和
ll query2(ll o,ll l,ll r,ll ql,ll qr)
{
	if(ql<=l&&r<=qr)
		return sumv2[o]%p;
	ll ans = 0;
	ll mid = (l+r)>>1;
	if(ql<=mid)
		ans += query2(o<<1,l,mid,ql,qr)%p;
	if(qr>mid)
		ans += query2(o<<1|1,mid+1,r,ql,qr)%p;
	return ans%p;
}

int main()
{
	scanf("%lld%lld",&n,&m);
	//递推逆元
	in[1] = 1;
	for(int i = 2;i<=n;++i)
		in[i] = (ll)(p-p/i)*in[p%i]%p;
	
	for(int i = 1;i<=n;++i)
		scanf("%lld",&a[i]);
	build(1,1,n);
	//printf("%lld %lld",query1(1,1,n,1,4),query2(1,1,n,1,4));
	while(m--)
	{
		ll opt,l,r;
		scanf("%lld%lld%lld",&opt,&l,&r);
		if(opt == 1)
			change(1,1,n,l,r%p);
		else
		{
			ll s1 = query1(1,1,n,l,r)%p;
			ll s2 = query2(1,1,n,l,r)%p;
//先求出区间和以及区间平方和
			ll inv = in[r-l+1];
//分数取模
			ll tot1 = s1*inv%p;
//求出平均数           
			ll tot2 = s2*inv%p-tot1*tot1%p;
//求出方差            
			tot2 = (tot2%p+p)%p;
//注意取模次数     
			printf("%lld\n",tot2);
			//printf(" %lld\n",s2/(r-l+1)-(s1/(r-l+1))*(s1/(r-l+1)));
		}	
	}
	return 0;
}

```
~~小声1313一句，这题和1417几乎没什么区别，反而1417更难，还要区修，就要考虑lazytag维护区间和，看到双倍经验就过去，卡了我很久~~




























---


# [POI 2007] 堆积木KLO

## 题目描述

PinkRabbit 从他的 npy 那里得到了一个由 $n$ 块积木叠成的高塔，每块积木上都写有一个数字。我们记从下往上第 $i$ 块积木上面的数为 $a_i$，将一个满足积木上的数为 $a_1,a_2,\dots,a_n$ 的高塔用 $\{a_1,a_2,\dots,a_n\}$ 直接表示，则 PinkRabbit 认为高塔 $\{a_1,a_2,\dots,a_m\}$ 价值为 $\sum_{i=1}^m [a_i = i]$。

PinkRabbit 可以删除当前高塔中的若干个积木，其余的积木受重力影响会下落到不能下落为止。如果将高塔 $\{1,1,2,4,5\}$ 中从下往上第二个积木删去，那么可以得到高塔 $\{1,2,4,5\}$，新高塔的价值为 $2$。

PinkRabbit 想删除当前高塔中任意个积木，使得最终得到的高塔价值最大。由于他是人赢，所以他指定你来回答这个问题。

## 说明/提示

**样例 1 解释**  
初始状态 $\{1,1,2,5,4\}$ 仅有 $a_1$ 满足 $a_i=i$，总价值为 $1$。  
删去从下往上第二个积木，得到状态 $\{1,2,5,4\}$，$a_1,a_2,a_4$ 均满足 $a_i=i$，总价值为 $3$。  
容易证明不存在更优的方案。


**数据规模与约定**  
对于 $100\%$ 的数据，$1 \le n \le 10^5$，$1 \le a_i \le 10^6$。

## 样例 #1

### 输入

```
5
1 1 2 5 4```

### 输出

```
3```

# 题解

## 作者：再不见 (赞：10)

一道DP好题。

一开始容易想到用$f_{ij}$表示前$i$个积木删除$j$个 的最大价值。则$f_{ij} = max(f_{i-1j} + [a_i == i-j] , f_{i-1j-1})$

时间复杂度$O(n^2)$ 可以过36分

优化上述方法，将第一维滚动掉，第二维反向枚举则有$f_j = max(f_j + [a_i == i - j] , f_{j-1})$

代码
```cpp
	For(i , 1 , n) {
		for(int j = i ; j >= 0 ; -- j) {
			f[j] = max(f[j] + (a[i] == i - j ? 1 : 0) , f[j - 1]);
		}
```

容易发现第二重循环每次更新的数比较少，可以把要更新的数放到队列里，减少计算次数。这样可以水60分。



------------

好了，以上都是扯淡，下面是正解。

我们有一个更好的状态定义$f_i$是第i个积木在自己的位置上时，前i个积木中最多能归位的数目。

则有

$$
f[i]=max(f[j]|i>j,a[i]>a[j],a[i]-a[j] \le i-j)+1
$$

然后以$i - a_i$ 为关键字排序，树状数组统计$< a_i $的最大值，这就是$f_i$的值。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define I inline 
#define ri register int
#define ll long long
#define For(i , x , y) for(ri i = x ; i <= y ; ++ i)
#define Next(i , u) for(ri i = head[u] ; i ; i = e[i].nxt)
#define lowbit(x) x & -x
I int read() {
	int s = 0 , w = 1; char ch = getchar();
	while(ch < 48 || ch > 57) {if(ch == '-') w = -1 ; ch = getchar();}
	while(ch >= 48 && ch <= 57) s = (s << 1) + (s << 3) + (ch ^ 48) ,ch = getchar();
	return s * w;
}

const int N = 2e5 + 5;

int n , Ans , c[N] , f[N];

struct node {
	int x , id;
} a[N];

I void modify(int x , int val) {
	while(x <= n) c[x] = max(c[x] , val) , x += lowbit(x);
}

I int query(int x) {
	int res = 0;
	while(x > 0) res = max(res , c[x]) , x -= lowbit(x);
	return res;
}

I bool cmp(node A , node B) {
	return (A.id - A.x == B.id - B.x) ? (A.id < B.id) :  (A.id - A.x< B.id - B.x ); 
}

signed main() {
	n = read();
	For(i , 1 , n) a[i].x = read() , a[i].id = i;
	sort(a + 1 , a + n + 1 , cmp);
	For(i , 1 , n) {
		if(a[i].id - a[i].x < 0) continue;
		int res = query(a[i].x - 1) + 1 ; modify(a[i].x , res);
		Ans = max(Ans , res);
	}
	cout << Ans << endl;
	return 0;
}


```





---

## 作者：RenaMoe (赞：4)


> 给出长为 n 的序列 a，求一个 a 的子序列 b，最大化 $\sum_{i}^{k}[b_i=i]$。

**CDQ的题解**

## 思路

DP 时，如果点 i 能从点 j 转移过来，满足条件：

$$
i > j
\\
a_i > a_j
\\
a_i-a_j \le i-j
$$

满足后两个条件时一定满足第一个条件。

转化为 $a_i>a_j,i-a_i\ge j-a_j$，二维偏序直接上 CDQ。

懒得归并，复杂度 $O(n\log^2n)$。

因为一个 $>$ 一个 $\ge$，所以 $i-a_i$ 属性要作第一维。

## 代码

记得加个 0 点。

```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>
using namespace std;

template<typename T> inline void read(T &x) {}

const int N = 1e5 + 9;

struct Data {
	int id, x, y;
};

int n;
Data a[N];
int f[N];

bool cmpx(const Data &x, const Data &y) {
	if (x.x == y.x) return x.y < y.y;
	return x.x < y.x;
}
bool cmpy(const Data &x, const Data &y) {
	if (x.y == y.y) return x.x < y.x;
	return x.y < y.y;
}

inline void CDQ(int l, int r) {
	if (l == r) return;
	int mid = (l + r) >> 1;
	sort(a+l, a+mid+1, cmpy);
	CDQ(l, mid);
	sort(a+l, a+mid+1, cmpx), sort(a+mid+1, a+r+1, cmpx);
	int pl = l, pr = mid + 1, ma = -INF;
	while (pr <= r) {
		while (pl <= mid && a[pl].x < a[pr].x)
			ma = max(ma, f[a[pl].id]), pl++;
        // 当 i - a[i] < 0 时，该点一定不满足
		if (a[pr].y >= 0) f[a[pr].id] = max(f[a[pr].id], ma + 1);
		pr++;
	}
	sort(a+mid+1, a+r+1, cmpy);
	CDQ(mid+1, r);
}

int main() {
	read(n);
	for (int i = 1; i <= n; ++i)
		read(a[i].x), a[i].y = i - a[i].x, a[i].id = i;
	a[++n] = (Data){ 0, 0, 0 };
	sort(a+1, a+n+1, cmpy);
	CDQ(1, n);
	int ans = 0;
	for (int i = 1; i <= n; ++i)
		ans = max(ans, f[i]);
	printf("%d\n", ans);
    return 0;
}
```




---

## 作者：Seauy (赞：4)

~~两只 log 两只 log……~~

看到这题写 dp 方程肯定是相当容易的，仔细一分析，效率 $ O(n^2) $ 当场报废

但是可以发现递推过程中有可以加速的地方，这个时候就可以用数据结构来维护啦！

# 1. 思路

考虑用 $ dp_{i,j} $ 来表示考虑了前 i 块积木，留了 j 块下来的最大价值，很容易推出转移方程

$$ dp_{i,j}=\max(dp_{i-1,j},dp_{i-1,j-1}+[A_i = j]) $$

$ O(n^2) $ 计算~~无法通过此题~~

尝试把所有状态跟它们的递推关系在直角坐标系上画出来

![](https://cdn.luogu.com.cn/upload/image_hosting/90fe7jpw.png)

这是 $ n=5 $ 的情况，状态 $ dp_{i,j} $ 对应于平面上的 $ (j,i) $，有黑边相连的状态是有递推关系的（一个状态只跟它左下与正下的状态有关）

假如我们把递推式中的 $ [A_i=j] $ 去掉，式子就变成了

$$ dp_{i,j}=\max(dp_{i-1,j},dp_{i-1,j-1}) $$

这表明了什么？$ dp_{i,j} $ 就是 从 $ (1,1) $ 到 $ (j,i) $ 的平行四边形内的点的最大值！

以 $ (3,4) $ 为例

![](https://cdn.luogu.com.cn/upload/image_hosting/8p364qqg.png)

平行四边形看上去有些不顺眼，我们来把它拉成平行于坐标轴的网格

![](https://cdn.luogu.com.cn/upload/image_hosting/yx6fq6gq.png)

原来的 $ (j,i) $ 变换到了 $ (j,i-j+1) $，平行四边形内最大值变成了二维前缀最大值！

而 $ A_i=j $ 时会对右上角的所有状态产生影响，我们可以尝试修改网格上 $ (A_i,i-A_i+1) $ 的值

单点修改，二维前缀最大值查询，你想到了什么？树套树啊！

由于是前缀最大值，第一维可以用树状数组维护，第二维线段树动态开点

这里注意一点，其实一般的区间最大值查询加修改树套树是很难支持的，但是这题的特殊点在于修改后的值永远都比之前大，所以直接对树上每个结点的最大值跟更新值取较大值就行了

最后取

$$ ans=\max_{i=1}^{n} dp_{n,i} $$

就行了，注意这是点变换之前的

复杂度 $ O(n \log^2 n) $ 轻松跑过 1e5 ~~喜提最差解~~

~~我咋没爆空间~~

人家咋都是一只 log 的，待会我去学习一下……

# 2. 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN=1e5;

struct SegNode
{
	int maxn,Son[2];
	void Clean() {maxn=Son[0]=Son[1]=0;}
}node[30000000];int num;//root[i]=i

int n,A[MAXN+5];
int ans;

int lowbit(int x)
{return x&-x;}

void New(int now,bool t)
{
	if(node[now].Son[t]) return;
	node[now].Son[t]=++num;
}

int Ask(int now,int L,int R,int QR)
{
	if(QR<L || !node[now].maxn) return 0;
	if(R<=QR) return node[now].maxn;
	int mid=(L+R)>>1;
	return max(Ask(node[now].Son[0],L,mid,QR),Ask(node[now].Son[1],mid+1,R,QR));
}

void Change(int now,int L,int R,int x,int v)
{
	node[now].maxn=max(node[now].maxn,v);
	if(L==R) return;
	int mid=(L+R)>>1;
	New(now,x>mid);
	if(x<=mid) Change(node[now].Son[0],L,mid,x,v);
	else Change(node[now].Son[1],mid+1,R,x,v);
}

int GetMax(int QR,int QU)
{
	if(QR<1 || QU<1) return 0;
	int cnt=0;
	for(;QR>0;QR-=lowbit(QR)) cnt=max(cnt,Ask(QR,1,n,QU));
	return cnt;
}

void AsMax(int x,int y,int v)
{
	if(x<1 || y<1) return;
	for(;x<=n;x+=lowbit(x)) Change(x,1,n,y,v);
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&A[i]);
	num=n;
	for(int i=1;i<=n;i++)//(x,y) => (x,y-x+1)
		AsMax(A[i],i-A[i]+1,max(GetMax(A[i],i-A[i]),GetMax(A[i]-1,i-A[i]+1)+1));
	for(int i=1;i<=n;i++) ans=max(ans,GetMax(i,n-i+1));
	/*
		for(int i=n;i>=1;i--)
		{
			for(int j=1;j<=i;j++) printf("%d ",GetMax(j,i-j+1));
			printf("\n");
		}
	*/
	printf("%d\n",ans);
	return 0;
}
```

# 3. 优化

哦我知道为啥我是两只 log 的了

这就是个二维偏序啊……把所有修改按 x 坐标排序，开一维树状数组记录 1~x 所有点映射在 y 坐标上的前缀最大值就行了

~~我好zz~~ 其它题解都是这么写的，学正解可以看他们的

---

## 作者：syf2008 (赞：4)

这道题我看题解的各位大佬用了dp,本蒟蒻来一发结构体

这题最难的就是思想

1. 首先你得知道这题要用upper_bound
1. 你如果像我用结构体，那你一定要会用sort结构体排序或者你也可以用题解的dalao用树状数组

上代码
```
#include <bits/stdc++.h>
using namespace std;
struct ss
{
	int a,i;
}b[100005];//建立结构体
int zhuan(ss a,ss b)//sort要用
{
	if(b.a==a.a)
	return b.i<a.i;
	return b.a>a.a;
}
int d[100005],ss,s=0,n,maxn=1;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{cin>>ss;//输入
	if(ss<=i)//如果它的值小于编号，如果值大于编号，是不可能有价值，屏蔽
	{b[++s].a=ss;
	b[s].i=i-ss;}//i-ss是求他到有价值的差}
	if(!s)//如果没有一个可能有价值
	{cout<<0<<endl;return 0;}
	sort(b+1,b+s+1,zhuan);
	d[1]=b[1].i;
	for(int i=2;i<=s;i++)
	{
	int v=upper_bound(d+1,d+maxn+1,b[i].i)-d;//二分查找
	d[v]=b[i].i;
	maxn=max(v,maxn);//比对
	}
	cout<<maxn<<endl;
}
```

---

## 作者：lkytxdy (赞：1)

## P6564 [POI2007] 堆积木KLO

> 给出一个长度为 $n$ 的序列 $a$，删去若干元素，最大化 $\sum_{i=1}^{n'}[a'_i=i]$。
>
> $1\leq n\leq 10^5$，$1\leq a_i\leq 10^6$。

$a’_i=i$ 即第 $i$ 个位置上的数要变为 $i$，或者说 $i$ 所在的位置 $pos_i$ 变为 $i$。

容易发现，元素的相对顺序不变，但是位置可以改变，并且一个元素的位置只会变小而不会变大。所以，要让 $a_i$ 的位置 $pos_{a_i}$ 变成 $a_i$（$pos_{a_i}$ 初始为 $i$），如果 $i<a_i$，由于 $pos_{a_i}$ 只会越来越小，永远不可能变成 $a_i$；否则，需要在前 $i-1$ 个元素中恰好删去 $i-a_i$ 个。

设 $f_i$ 表示强制 $pos_{a_i}=a_i$，前 $i$ 个 $pos_{a_j}=a_j$ 最多能满足多少个。考虑 $j$ 能转移到 $i$ 的条件：$j<i$，$a_j<a_i$（$a_j,a_i$ 相对顺序不变），$j-a_j\leq i-a_i$。发现满足了后两个条件一定能满足第一个，所以这其实是个二维偏序。

以 $a_i$ 为下标开一棵树状数组，然后按 $i-a_i$ 从小到大枚举转移。时间复杂度 $\mathcal O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int n,m=1e6,a[N],c[N];
vector<int>v[N];
void modify(int x,int y){
	for(int i=x;i<=m;i+=i&(-i)) c[i]=max(c[i],y);
}
int query(int x){
	if(!x) return 0;
	int ans=0;
	for(int i=x;i;i-=i&(-i)) ans=max(ans,c[i]);
	return ans;
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		if(i>=a[i]) v[i-a[i]].push_back(a[i]);
	}
	for(int i=0;i<=m;i++)
		for(int j:v[i]) modify(j,query(j-1)+1);
	printf("%d\n",query(m));
	return 0;
}
```



---

## 作者：SuperTNT (赞：1)

# [POI2007] 堆积木KLO

## 思路

* 朴素 $dp$ 思路， 设 $dp_{i,j}$ 表示前 $i$ 块积木，留下 $j$ 块下来的数目，则转移方程为 $dp_{i,j}=max(dp_{i−1,j},dp_{i−1,j−1}+[A_i=j])$ ，时间复杂度是 $O(n^2)$ 的，无法通过此题

考虑换 $dp$ 思路，设 $dp_i$ 表示第 $i$ 块积木在自己位置上，前 $i$ 个积木最多有多少个在自己位置上的数目，转移方程为 $dp_i=max_{j<i,a_j<a_i,a_i-a_j\le i-j}(dp_j)+1$ ，前两个条件要满足是显然的，对于第三个条件，只有满足这个条件才能使第 $i$ 块积木在自己的位置上，但这样转移时间复杂度仍然是$O(n^2)$ 的

* 我们将条件提取出来

* $j<i$ ①

  $a_j<a_i$ ②

  $a_i-a_j\le i-j$ ③

* 我们发现只要第二、三条件满足，第一条件也就满足，第三条件转化以后成为 $i-a_i \ge j-a_j$ ，只要第三条件满足第二条件就是一个裸的 $LIS$ ，我们按 $i-a_i$ 排序，之后求 $LIS$ 就好，因为 $n$ 比较大，因此我们要用 $n\log n$ 做法，这里我用的是二分求的 $LIS$ ，这样这道题就解决了，复杂度为  $O(n \log n)$ 

  <font color =#FF4F00>小提示：对于该位置上编号比所给 $a[]$ 小的，直接扔掉就好了，对答案没有贡献</font>

## 代码

```c++
#include <bits/stdc++.h>

#define re register

typedef long long ll;

namespace TNT
{
    const int MAXN = 1e5 + 10;

    inline int read()
    {
        int x = 0, f = 1;
        char ch = getchar();

        while (ch < '0' || ch > '9')
        {
            if (ch == '-')
                f = -1;
            ch = getchar();
        }

        while (ch >= '0' && ch <= '9')
        {
            x = (x << 3) + (x << 1) + (ch ^ 48);
            ch = getchar();
        }

        return x * f;
    }

    inline void write(int x)
    {
        if (x < 0)
            putchar('-'), x = -x;
        if (x > 9)
            write(x / 10);

        putchar(x % 10 + '0');
    }

    struct node
    {
        int h;
        int id;
    } a[MAXN];

    inline bool cmp(node b, node c)
    {
        return b.id - b.h == c.id - c.h ? b.id < c.id : b.id - b.h < c.id - c.h;
    }

    int dp[MAXN];

    inline void main()
    {
        int n = read(), cnt = 0;

        for (re int i = 1, x; i <= n; i++)
        {
            x = read();

            if (i - x >= 0)
                a[++cnt] = (node){x, i};
        }

        std::sort(a + 1, a + 1 + cnt, cmp);

        int j = 0, ans = 0;
        for (re int i = 1; i <= cnt; i++)
        {
            dp[i] = a[i].h;
            j = std::lower_bound(dp + 1, dp + 1 + ans, dp[i]) - dp;

            if (j != i)
                dp[j] = dp[i];

            ans = std::max(j, ans);
        }

        write(ans);

        return;
    }
} // namespace TNT

int main()
{
    TNT::main();
    return 0;
}
```



---

## 作者：Fading (赞：1)

这是蓝题？？？一道蓝题搞了我$2$个小时，是我太菜了还是难度值有毒...

upd : 现在紫了，~~那没事了...~~

------------


首先有一个很显而易见的 dp ：设$f_{i,j}$表示前$i$个数保留$j$个的最大值。

转移：$f_{i,j}=\max(f_{i-1,j},f_{i-1,j-1}+[a[i]=j]);$

接下来考虑优化：

我的第一反应是线段树优化 dp ，然后不会...

然后注意到，可以把这个题的转移看成一个网格图，总共只有$O(n)$个有必要的点。比如样例就是：

![](https://cdn.luogu.com.cn/upload/image_hosting/wzow84a3.png)

每一个点只能往下或者右下走。红色右下的边表示可以给答案$+1$。

那么我们就可以把有用点拿出来跑最短路了。但是边数还是$O(n^2)$的，怎么办？

不要把边建出来就可以了。问题等价于查询一个平行四边形的最大 f 值。如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ixszwcp8.png)

所以我们一条一条对角线 dp 下来，然后开一个下标为$j$的树状数组维护前缀最大值，更新就可以了。

时间复杂度$O(n\log_2n)$，我找有用点的时候还搞了一个 map ，后来发现想复杂了。

丑陋的代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
#define gc getchar
inline ll read(){
    register ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}
    return (f==1)?x:-x;
}
map<int,int> cac[1010101];
int n,m,a[1010101],T,ANS;
int f[1010101],tr[1010101];
inline void update(int x,int y){
	x++;
	for (;x<=n+1;x+=x&-x) tr[x]=max(tr[x],y);
}
inline int query(int x){
	x++;
	int ans=0;
	for (;x;x-=x&-x) ans=max(tr[x],ans);
	return ans;
}
inline void init(){
	n=read();
	cac[0][0]=(T=1);
	for (int i=1;i<=n;i++){
		a[i]=read();
		if (a[i]>i) continue;
		if (!cac[i-a[i]].count(a[i]-1)) cac[i-a[i]][a[i]-1]=++T;
		if (!cac[i-a[i]].count(a[i])) cac[i-a[i]][a[i]]=++T;
	}
}
inline void doit(){
	for (int i=0;i<=n;i++){
		if (!cac[i].count(n)) cac[n-i][i]=++T;
	}
	for (int i=0;i<=n;i++){
		for (map<int,int>::iterator it=cac[i].begin();it!=cac[i].end();it++){
			if (it==cac[i].end()) break;
			f[it->second]=max(query(it->first),(cac[i].count(it->first-1)?(f[cac[i][it->first-1]]+(a[it->first+i]==it->first)):-9999999));
			ANS=max(ANS,f[it->second]);
			update(it->first,f[it->second]);
		}
	}
}
inline void outit(){cout<<ANS;}
int main(){
	init();
	doit();
	outit();
	return 0;
} 
```


~~我不会告诉你们我写了2个伪算法~~

~~正解的转化怎么这么nb啊~~

---


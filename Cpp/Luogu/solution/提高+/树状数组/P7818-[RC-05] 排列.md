# [RC-05] 排列

## 题目背景

[广告](http://119.27.163.117/problem/97)

## 题目描述

给出 $1\sim n$ 的排列 $p$，下标从 $1$ 开始。

**恰好** $K$ 次任意选择 $1\le i<n$ 并交换 $p_i,p_{i+1}$。问交换完毕后，字典序最小的排列 $p$ 是什么？

## 说明/提示

**本题捆绑测试。**

对于所有数据，$1\le n\le 5\times 10^5$，$0\le K\le 10^{12}$。

详细数据范围如下表：

| Subtask 编号 | $n$ | $K$ | 分数 |
| :-----------: | :-----------: | :-----------: | :-----------: | 
| $1$ | $\le 8$ | |$30$ |
| $2$ | $\le 10^3$ |  |$30$ |
| $3$ | $\le 10^3$ | $=10^{12}$ | $15$ |
| $4$ | $\le 5\times 10^5$ | | $25$ |

## 样例 #1

### 输入

```
5 2
2 1 4 3 5```

### 输出

```
1 2 3 4 5```

## 样例 #2

### 输入

```
5 3
5 4 3 2 1```

### 输出

```
2 5 4 3 1```

## 样例 #3

### 输入

```
5 6
5 4 3 2 1```

### 输出

```
1 3 5 4 2```

# 题解

## 作者：FreeTimeLove (赞：10)

这是我的第一篇题解。感谢[@vectorwyx](https://www.luogu.com.cn/user/238408)大佬不吝赐教。

题意为求将一个给定的全排列交换相邻的数 $k$ 次后能得到的**字典序最小**的全排列。

既然要求字典序最小，那么一定要靠前的数尽量小，我们就想到了贪心算法：

设当前操作到了第 $i$ 位，剩余交换次数 $k'$。每次查找**能够交换到第** $x$ **位**的数中最小的数，将其交换到第 $i$ 位，再将 $k'$ 减去相应的交换次数。

具体地说，我们用树状数组维护**原序列**第 $1$ 位至第 $i$ 位**未被选**的数的个数 $(x\in[1,n])$，用线段树维护**原序列**第 $l$ 位至第 $r$ 位**未被选**的数中的最小值及其位置 $(l,r\in[1,n])$。

每次操作，如果所有未选过的数都能交换到第 $i$ 位，我们就找 $[1,n]$ 中的**未选的**最小值 $x$ ；否则，通过二分查找确定第 $k'$ 个未选的数的位置，找 $[1,x+k'+1]$ 中**未选的**最小值 $x$。将 $x$ 交换到第 $i$ 位（这里我们将其压入队列 $ans$,标记 $x$ 为已经选过，并不进行实际交换），$k'$ 减去交换次数。如果 $k'=0$ 或者所有数都确定好位置，就结束交换。

最多进行 $n$ 次操作，每次操作二分查找 $+$ 树状数组的时间复杂度为 $O(\log^2 n)$，交换时线段树和树状数组的更新时间复杂度为 $O(\log n)$，总时间复杂度为 $O(n\log^2 n)$。

但是这样交上去，我们却发现 WA 了 $5$ 个点。为什么？因为我们没有注意到**恰好** $k$ 次（不是最多 $k$ 次）！如果排完后还有多余次数 $k''$,若 $k''$ 为偶数则不用管，如果 $k''$ 是奇数，那么交换最后两个数字。

显然如果次数多余，当前的全排列一定已经是递增的。如果剩余偶数次，交换最后两位 $k''$ 次后不变；如果是奇数次，那么交换后等价于交换最后两位一次。这样可以确保字典序最小。

### AC code

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#define ll long long
using namespace std;
const int N=4e6+5,INF=0x3f3f3f3f;
ll n,k,a[N],bk[N],pos,tot,ans[N];
struct xxs{
	ll p,num;
}x;
namespace BIT{
	ll c[N];
	void add(int x,ll k){
		while(x<=n){
			c[x]+=k;
			x+=x&-x;
		}
	}
	ll search(int x){
		ll ans=0;
		while(x){
			ans+=c[x]; 
			x-=x&-x;
		}
		return ans;
	}
}

int half(int lim){
	int mid,l=1,r=n+1;
	while(l<r){
		mid=(l+r)>>1;
		if(BIT::search(mid)>=lim)
			r=mid;
		else
			l=mid+1;
	}
	return l;
}
namespace SGT{
	xxs c[N];
	int L[N],R[N];
	void pu(int rt){
		if(c[rt<<1].num<c[rt<<1|1].num)
			c[rt]=c[rt<<1];
		else
			c[rt]=c[rt<<1|1];
	}
	void build(int l,int r,int rt){
		L[rt]=l,R[rt]=r;
		if(l==r){
			c[rt]=(xxs){l,a[l]};
			return ;
		}
		int mid=(l+r)>>1;
		build(l,mid,rt<<1);
		build(mid+1,r,rt<<1|1);
		pu(rt); 
	}
	void upd(int x,ll k,int rt){
		if(L[rt]>x||R[rt]<x)
			return;
		if(L[rt]==R[rt]){
			c[rt].num=k;
			return;
		}
		upd(x,k,rt<<1);
		upd(x,k,rt<<1|1);
		pu(rt);
	}
	xxs qry(int l,int r,int rt){
		if(L[rt]>r||R[rt]<l)
			return (xxs){1,INF};
		if(L[rt]>=l&&R[rt]<=r)
			return c[rt];
		xxs lx=qry(l,r,rt<<1);
		xxs rx=qry(l,r,rt<<1|1);
		return (lx.num<rx.num?lx:rx);	
	}
}
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		bk[i]=1;
		BIT::add(i,1);
	}
	SGT::build(1,n,1);//维护区间最小值及其初始位置 
	for(int xx=1;xx<=n&&k;xx++){
		if(k<n-xx)
			pos=half(k+1); 
		else
			pos=n;
		x=SGT::qry(1,pos,1);
		
		k-=BIT::search(x.p)-1;//交换次数=当前为序列中未选的第几个数-1
		ans[++tot]=x.num;
        
		//标记为已选
		bk[x.p]=0;
		BIT::add(x.p,-1);
		SGT::upd(x.p,INF,1);
	}
    
	if(k&& k&1)swap(ans[n-1],ans[n]);
    
	if(tot<n)//未被选的依次排到队尾
		for(int i=1;i<=n;i++)
			if(bk[i])
				ans[++tot]=a[i];
	
	for(int i=1;i<=n;i++)
		cout<<ans[i]<<' ';
	cout<<endl;
	return 0;
}
```
### The End.

---

## 作者：shinzanmono (赞：5)

English version of this editorial is provided after the sample code.

考虑字典序最小的套路是贪心，首先要知道从位置 $a$ 到 $b$ 需要 $|a-b|$ 次操作。我们在当前可操作的队列中找到最小的进行操作即可。

使用线段树，树状数组维护即可。

坑点在于**恰好** $k$ 次，若已经升序排序后次数有剩余则反复交换最后两个位置即可。

示例代码 / Sample Code：

```cpp
#include<iostream>
#include<algorithm>
const int sz=5e5+10;
const int inf=0x3fffffff;
int a[sz],b[sz],ans[sz],n;
struct BIT{
    int sum[sz];
    void add(int p,int val){
        for(int i=p;i<=n;i+=i&-i)sum[i]+=val;
    }
    int query(int p){
        int res=0;
        for(int i=p;i>=1;i-=i&-i)res+=sum[i];
        return res;
    }
}bit;
struct SegT{
    int tree[sz<<2];
    void build(int p,int ln,int rn){
        if(ln==rn)return tree[p]=a[ln],void();
        int mid=ln+rn>>1;
        build(p<<1,ln,mid);
        build(p<<1|1,mid+1,rn);
        tree[p]=std::min(tree[p<<1],tree[p<<1|1]);
    }
    void change(int p,int ln,int rn,int pos,int val){
        if(ln==rn)return tree[p]=val,void();
        int mid=ln+rn>>1;
        if(pos<=mid)change(p<<1,ln,mid,pos,val);
        else change(p<<1|1,mid+1,rn,pos,val);
        tree[p]=std::min(tree[p<<1],tree[p<<1|1]);
    }
    int query(int p,int ln,int rn,int l,int r){
        if(ln>=l&&rn<=r)return tree[p];
        int mid=ln+rn>>1,res=inf;
        if(l<=mid)res=std::min(res,query(p<<1,ln,mid,l,r));
        if(r>mid)res=std::min(res,query(p<<1|1,mid+1,rn,l,r));
        return res;
    }
}st;
int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    long long k;
    std::cin>>n>>k;
    for(int i=1;i<=n;i++)std::cin>>a[i],b[a[i]]=i;
    st.build(1,1,n);
    for(int i=1;i<=n;i++){
        int l=1,r=n;
        while(l<r){
            int mid=l+r>>1;
            if(mid-bit.query(mid)>k)r=mid;
            else l=mid+1;
        }
        int val=st.query(1,1,n,1,l),pos=b[val],t=pos-bit.query(pos)-1;
        ans[i]=val,k-=t,bit.add(pos,1),st.change(1,1,n,pos,inf);
    }
    if(k&1)std::swap(ans[n-1],ans[n]);
    for(int i=1;i<=n;i++)std::cout<<ans[i]<<" ";
    std::cout<<"\n";
    return 0;
}
```

## English Version
The trick to consider the minimum lexicographic order problem is greedy. First, we know that $|a-b|$ operations are required from position $a$ to $b$. We just need to find the smallest one in the current operable value queue and perform the operation.

We can use Binary Indexed Tree(Fenwick Tree) and Segment Tree.

Moreover, the number of operations is **exactly** $k$. So after the array is sorted, we repeatedly operate on the last two values.

---

## 作者：aaa_lvzekai (赞：4)

### 题目描述

[题目链接](https://www.luogu.com.cn/problem/P7818)

交换 **恰好** $n$ 次相邻的两个数。求交换完后，字典序最小的排列。

### 思路

#### 75 分思路

算法：贪心。

很明显我们让尽可能小的在前面可以让字典序最小，所以我们可以在可以换到最前面的中选一个最小的放最前面最优。

但如果已经全部换好了，但还有次数剩余，分以下两种情况：

- 如果剩余偶数次，就不交换。

- 如果剩余奇数次，就交换最后两个。

时间复杂度：$O(n ^ 2)$。

#### 100 分思路

算法：贪心+二分+线段树+树状数组。

在原来代码上加上二分+线段树+树状数组优化即可。

时间复杂度：$O(n \log^2 n)$。

不开 O2 100pts and 673ms：[提交记录](https://www.luogu.com.cn/record/146677575)。

开 O2 100pts and 666ms：[提交记录](https://www.luogu.com.cn/record/146677565)。

#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
struct st
{
	ll l,r,now;
};
const ll N=500010,INF=0x3f3f3f3f3f3f3f3f;
ll n,m,a[N],ans[N],cnt[N],tmp,x,id;
st tree[N*4];
unordered_map<ll,ll> mp;
void pushup(ll u)
{
    tree[u].now=min(tree[u*2].now,tree[u*2+1].now);
}
void build(ll u,ll l,ll r)
{
    tree[u].l=l,tree[u].r=r;
    if(l==r)
    {
    	tree[u].now=a[l];
        return;
    }
    ll mid=(l+r)/2;
    build(u*2,l,mid);
    build(u*2+1,mid+1,r);
    pushup(u);
}
ll query(ll u,ll l,ll r)
{
    if(tree[u].l>=l&&tree[u].r<=r)
    {
        return tree[u].now;
    }
    ll mid=(tree[u].l+tree[u].r)/2,minn=INF;
    if(l<=mid)
    {
        minn=query(u*2,l,r);
    }
    if(r>mid)
    {
        minn=min(minn,query(u*2+1,l,r));
    }
    return minn;
}
void modify(ll u,ll x)
{
    if(tree[u].l==x&&tree[u].r==x)
    {
        tree[u].now=INF;
    }
    else
    {
        ll mid=(tree[u].l+tree[u].r)/2;
        if(x<=mid)
        {
            modify(u*2,x);
        }
        else
        {
            modify(u*2+1,x);
        }
        pushup(u);
    }
}
ll lowbit(ll x)
{
	return x&-x;
}
void add(ll x)
{
	for(int i=x;i<=n;i+=lowbit(i))
	{
		cnt[i]++;
	}
}
ll sum(ll x)
{
	ll ans=0;
	for(int i=x;i>=1;i-=lowbit(i))
	{
		ans+=cnt[i];
	}
	return ans;
}
ll find(ll x)
{
	ll l=1,r=n,mid,ans=n;
	while(l<=r)
	{
		mid=(l+r)/2;
		if(mid-sum(mid)>=x)
		{
			ans=mid;
			r=mid-1;
		}
		else
		{
			l=mid+1;
		}
	}
	return ans;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		mp[a[i]]=i;
	}
	build(1,1,n);
	for(int i=1;i<=n;i++)
	{
		tmp=find(min(m+1,n-i+1));
		x=query(1,1,tmp),id=mp[x];
		ans[i]=x;
		m-=id-i+sum(n)-sum(id);
		add(id),modify(1,id);
	}
	if(m%2)
	{
		swap(ans[n-1],ans[n]);
	}
	for(int i=1;i<=n;i++)
	{
		cout<<ans[i]<<" ";
	}
	cout<<"\n";
	return 0;
}
```

---

## 作者：NianFeng (赞：4)

**blog食用地址**：[广告](https://www.luogu.com.cn/blog/YuanFang-Nian/p7818-rc-05-pai-lie-ti-xie-post)

***

# 0x01 题目分析

## 题意

给出 $1\sim n$ 的排列 $p$，求正好 $K$ 次选择相邻两数交换完毕后，字典序最小的排列 $p$。

## 思路

**字典序**中的比较，是从头到尾挨个比较大小。虽然数字的比较还要在此基础上考虑位数，但这里的排列 $p$ 位数不变，这也让我们得以从数字的角度思考。

我们可以先把 $p$ 当成一个 $n$ 位的 $n$ 进制数。首先，在不受任何限制的时候，$p$ 最小一定为 $\overline{ 1, 2, 3 \cdots n }$。那么为什么呢？答案是显然的。由于数字/字典序的比较是从前往后的，我们每一位考虑**都贪心的使用当前最小数**，最后的出来的数一定是最小的。

那么，在有 $K$ 次操作的限制之下，这个思路可行吗？

答案是肯定的。思考一下，在同一位上面，不取最小值和取最小值本身就已经拉开了差距，在后面的位数中无法补回来。比如说 $199$ 和 $200$，虽然 $99$ 比 $00$ 远大得多，但是由于 $1$ 已经比 $2$ 小了，所以 $199 < 200$。

不过，我们还要考虑一个东西。如果 $K$ 实在是**太大了**，剩下的操作怎么办？毕竟是**恰好** $K$ 次移动诶！

这个问题其实很好解决。在 $K$ 足够大的时候，没用完 $K$ 的最小字典序肯定是 $\{ 1, 2, 3\ldots n \}$。此时的字典序已经足够小了，那么我们的处理方式就是尽量抵消剩余操作。不难看出，两次在**同一位置**进行交换操作，交换是可以**被抵消的**，这样一来 $K$ 就可以简化为 $2\times x + 1$ 或 $2\times x$，也就是 $0$ 和 $1$。$0$ 就是不操作，考虑 $1$ 的时候最后一次操作放在哪里。为了使影响最小，我们就选择把最后**两位交换**，因为在字典序已经最小的时候，交换一个位置**必然会使当前位置变大**，而位置越往前，影响越大，所以交换的是 $p_{n-1}$ 和 $p_n$。

于是，基本的思路就来了：**每次移动，都贪心选尽可能的大的往前移，最后多的操作能抵消抵消，不能的交换最后两位**。

# 0x02 操作实现

## 需要的操作

- 判断、查找可行的操作区间

- 在可行区间内查找最小值

- 交换操作与其信息记录

## 实现

### 1.判断、查找可行的操作区间

首先思考如何判断可行的操作区间。将某个数移到当前位，所使用的交换次数实际上就是**其与这一位的距离**。同时，在每一次交换完之后，就是把所交换的数**与其前面的未确定数交换整体位置**，这样一来，未确定的数**在相对位置上是不会改变的**，同时。那么，当考虑到 $i$ 位且剩余 $k$ 次操作的时候，肯定是在剩余的数中选择前 $\min(k + 1, n - i + 1)$ 个中最小的。怎么来的呢？剩余的数都被挤到后面，且位置相邻，在交换次数为 $k$ 的时候，最远可以取到的数就是 $k + 1$；同时，选到第 $i$ 位的时候，也只剩下 $n - i + 1$ 个数了，所以在这个区间内取最小值。

确定了可行区间，怎么去找呢？显然，在数组中删去一个数时间会爆炸，同时也不好维护。但是，我们有一条性质，**未确定的数相对位置不会改变且正好被挤到最后面**，所以就有了一个做法：去二分查找第 $\min(k + 1, n - i + 1)$ 个未选数数在 $p$ 中的位置，标记为 $last$，区间 $1\sim last$ 中的最小值记为 $x$。同时在每选完 $x$ 后就把其变为极大值，这就不影响后续查找了。

而维护位置 $i$ 前面已选数的数量和查找，有树状数组就够了！

```cpp
int cnt[N];                     //树状数组。前面有个tree这里就用cnt代替了
int lowbit(int x){
    return x&(-x);
}
void update(int x){             //单点加，记录位置上的已选数个数
    for(int i=x;i<=n;i+=lowbit(i))
        cnt[i]++;
}
int query(int x){               //前缀和查询，返回位置前被数的数量
    int res=0;
    for(int i=x;i;i-=lowbit(i))
        res+=cnt[i];
    return res;
}
int find(int x){                //二分查找指定位置
    int l=1,r=n,ans=n;
    while(l<=r){
        int mid=l+r>>1;
        if(mid-query(mid)>=x){  //这里可能要注意一下，
            ans=mid;            //我们记录的是已选数的个数，而要查找的是没选的数，
            r=mid-1;            //用下标减去已选的数就行了
        } else{
            l=mid+1;
        }
    }
    return ans;
}
```

### 2.在可行区间内查找最小值

这个实际上很好维护。结合上面的操作，我们无非需要做的就是查询 $1\sim last$ 中的最小值，并将 $p_{last}$ 修改为 $inf$。用线段树维护即可。

```cpp
struct TREE{                            //都是比较正常的写法
    int l,r,minn;
}tree[N<<2];
void build(int root,int l,int r){
    tree[root].l=l,tree[root].r=r;
    if(l==r){
        tree[root].minn=a[l];           //这个就是p数组
        return;
    }
    int mid=l+r>>1;
    int leftroot=root<<1;
    int rightroot=root<<1|1;
    build(leftroot,l,mid);
    build(rightroot,mid+1,r);
    tree[root].minn=min(tree[leftroot].minn,tree[rightroot].minn);
}
//没怎么写过线段树和树状数组一起的题目，所以就用同一个函数名了。希望不会降低代码可读性QAQ
void update(int root,int pos){
    if(tree[root].l==pos&&tree[root].r==pos){
        tree[root].minn=1e9;            //修改为inf
        return;
    }
    int mid=tree[root].l+tree[root].r>>1;
    int leftroot=root<<1;
    int rightroot=root<<1|1;
    if(pos<=mid) update(leftroot,pos);
    else update(rightroot,pos);
    tree[root].minn=min(tree[leftroot].minn,tree[rightroot].minn);
}
int query(int root,int l,int r){
    if(l<=tree[root].l&&tree[root].r<=r){
        return tree[root].minn;
    }
    int mid=tree[root].l+tree[root].r>>1;
    int leftroot=root<<1;
    int rightroot=root<<1|1;
    int ans=1e9;
    if(l<=mid) ans=min(ans,query(leftroot,l,r));
    if(mid<r) ans=min(ans,query(rightroot,l,r));
    return ans;
}
```

### 3.交换操作与其信息记录

在交换操作的时候，由于相对位置没有变动，实际上只用标记 $x$ 被取过了。同时，要将操作完的数组（代码中记为 $b$ 数组）在 $i$ 位的值改为 $x$。

在信息更新这里，绕的部分也许是在 $K$ 的更新。在没有其他操作的时候，$K$ 较小的值明显就是 $pos_x - i$（这里 $pos_x$ 是 $x$ 的位置）。但是如果有操作呢？我们思考一下，更新的部分对于当前位置有什么影响。前文有讲，**交换操作本质是把一个数与其到当前位置的数交换整体位置**，那么在 $pos_x$ 前的数对 $x$ 的位置是没有影响的，只用考虑其后面的更新。每一次更新会将 $x$ 向后推移一个，最终位置是 $pos_x + ( query(n) - query(pos_x) )$。将 $K$ 减去最终位置和 $i$ 的差即可。

```cpp
    for(int i=1;i<=n;i++){
        int last=find(min(m+1,n-i+1));      //这个是位置
        int x=query(1,1,last),p=pos[x];     //被选数及其位置
        b[i]=x,m-=p+query(n)-query(p)-i;    //更新b数组，这里的m就是K
        update(p),update(1,p);              //标记为已更新，改变为inf
    }
```

# 0x03 总代码

###### 可恶，居然比100行多了一行，我爱注释

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
namespace io{
    inline int read(){
        int x=0;
        char c=getchar();
        while(c<'0'||c>'9') c=getchar();
        while(c>='0'&&c<='9'){
            x=(x<<1)+(x<<3)+c-'0';
            c=getchar();
        }
        return x;
    }
}
using namespace io;
const int N=500100;
int n,m,a[N],b[N];                      //题中的n,K,p和答案数组
map<int,int>pos;
struct TREE{                            //都是比较正常的写法
    int l,r,minn;
}tree[N<<2];
void build(int root,int l,int r){
    tree[root].l=l,tree[root].r=r;
    if(l==r){
        tree[root].minn=a[l];           //这个就是p数组
        return;
    }
    int mid=l+r>>1;
    int leftroot=root<<1;
    int rightroot=root<<1|1;
    build(leftroot,l,mid);
    build(rightroot,mid+1,r);
    tree[root].minn=min(tree[leftroot].minn,tree[rightroot].minn);
}
//没怎么写过线段树和树状数组一起的题目，所以就用同一个函数名了。希望不会降低代码可读性QAQ
void update(int root,int pos){
    if(tree[root].l==pos&&tree[root].r==pos){
        tree[root].minn=1e9;            //修改为inf
        return;
    }
    int mid=tree[root].l+tree[root].r>>1;
    int leftroot=root<<1;
    int rightroot=root<<1|1;
    if(pos<=mid) update(leftroot,pos);
    else update(rightroot,pos);
    tree[root].minn=min(tree[leftroot].minn,tree[rightroot].minn);
}
int query(int root,int l,int r){
    if(l<=tree[root].l&&tree[root].r<=r){
        return tree[root].minn;
    }
    int mid=tree[root].l+tree[root].r>>1;
    int leftroot=root<<1;
    int rightroot=root<<1|1;
    int ans=1e9;
    if(l<=mid) ans=min(ans,query(leftroot,l,r));
    if(mid<r) ans=min(ans,query(rightroot,l,r));
    return ans;
}
int cnt[N];                     //树状数组。前面有个tree这里就用cnt代替了
int lowbit(int x){
    return x&(-x);
}
void update(int x){             //单点加，记录位置上的已选数个数
    for(int i=x;i<=n;i+=lowbit(i))
        cnt[i]++;
}
int query(int x){               //前缀和查询，返回位置前被数的数量
    int res=0;
    for(int i=x;i;i-=lowbit(i))
        res+=cnt[i];
    return res;
}
int find(int x){                //二分查找指定位置
    int l=1,r=n,ans=n;
    while(l<=r){
        int mid=l+r>>1;
        if(mid-query(mid)>=x){  //这里可能要注意一下，
            ans=mid;            //我们记录的是已选数的个数，而要查找的是没选的数，
            r=mid-1;            //用下标减去已选的数就行了
        } else{
            l=mid+1;
        }
    }
    return ans;
}
signed main(){
    n=read(),m=read();
    for(int i=1;i<=n;i++) pos[a[i]=read()]=i;   //顺便标记位置
    build(1,1,n);
    for(int i=1;i<=n;i++){
        int last=find(min(m+1,n-i+1));          //这个是位置
        int x=query(1,1,last),p=pos[x];         //被选数及其位置
        b[i]=x,m-=p+query(n)-query(p)-i;        //更新b数组，这里的m就是K
        update(p),update(1,p);                  //标记为已更新，改变为inf
    }
    if(m&1) swap(b[n-1],b[n]);                  //不要忘记剩余的K
    for(int i=1;i<=n;i++) printf("%lld " ,b[i]);
    return 0;
}
```

# 0x04 后话

以后在更新的时候为了方便理解，会带上图床……（吧，但愿我能做到（QAQ）

感谢您的观看，有错误/不足之处欢迎指出！（>w<）

---

## 作者：QueenSi (赞：4)

在此警醒世人：若你错了 #$5$ #$12$ 等 $5$ 个点，请注意"**恰好**"两个字 _~~(毒瘤死了~~_   
由于题目要求交换k次后字典序最小的排列，所以我们希望数字小的尽可能往前靠。    
这时可以考虑贪心，我们尽可能希望**高位是最小的**。  
即我们**从前往后**确定最终排列时,设当前还能交换 $s$ 次, 已经考虑到第 $i$ 位，一定选取 $[i,min(n-i+1,s+1)]$ 中的最小数字，使它交换到前面，然后 $s$ 减少其交换到第 $i$ 位的次数。   
这显然是正确的，如果在高位不把能取到的最小值交换过来，那我必然可以以这种贪心方式得到一个更优的排列。    
这里有一个思考误区：可能通过其他方式的交换，使得到达同一种排列时交换的次数变少。其实这是不对的，可以从逆序对的角度考虑。按照我们的策略贪心时，交换前后两个数 $a$ , $b$ ，逆序对一定减少 $1$ , 满足贪心的各种交换的本质都是逆序对减少 $1$,所以这些交换其实是等价的，不可能通过其他方式减少交换次数。   
本题重点是恰好取到 $k$, 如果次数不够用，那么就没这个问题。如果次数太多了，我们通过**最少交换方案交换出升序排列**之后还有剩余，那么考虑只交换最后两个，所以如果剩余的次数是奇数个，输出的答案就是升序排列后末尾两个数交换的排列。  
我们考虑剩余的情况，假设我们使用 $p$ 次使排列变为升序排列, , 那么剩余的 $k-p$ 次用来交换后面两个，我们显然希望 $k-p$ 为偶数。前面说过贪心策略下的交换本质是逆序对减少 $1$ ,设排列变为升序最少交换 $q$ 次(也就是有q个逆序对), 那么交换p次的方案必然是交换某些位置后，使逆序对改变 $v$ 个，然后再使逆序对减少到0，此时我们发现 $p=2v+q$ , $p$ 与 $q$ 的奇偶性保持一致，于是我们的结论是成立的。  
贴代码：  
```
#include<bits/stdc++.h>
void File(){
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
}
#define il inline
#define mp make_pair
#define fi first
#define se second
typedef long long ll;
typedef double dfb;
typedef long double dlb;
#define int long long 

namespace Faster_Bound{
	#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
	char buf[1<<23],*p1=buf,*p2=buf;
	int Oplen,x32,f32; 
	ll x64,f64;char _c;
	il void Main_cry(){
		srand((unsigned)time(NULL));
	}
	il int read(){
		x32=0,f32=1,_c=getchar();
		for(;!isdigit(_c);_c=getchar()) if(!(_c^'-')) f32=-1;
		for(;isdigit(_c);_c=getchar()) x32=(x32<<3)+(x32<<1)+(_c^48);
		return x32*f32;
	}
	il ll read64(){
		x64=0,f64=1,_c=getchar();
		for(;!isdigit(_c);_c=getchar()) if(!(_c^'-')) f64=-1;
		for(;isdigit(_c);_c=getchar()) x64=(x64<<3)+(x64<<1)+(_c^48);
		return x64*f64;
	}
	template <typename T> il T random(T a,T b){
		return rand()%(b-a+1)+a;
	}
	il bool Ischar(char &Cc){
		if(Cc>=32&&Cc<=176) return true;
		return false;
	}
	il int Cread(char *ss){
		_c=getchar();++ss;
		for(;!Ischar(_c);_c=getchar());
		for(;Ischar(_c);_c=getchar(),++Oplen,++ss) *ss=_c; 
		return Oplen;
	}
}
using namespace std;
using namespace Faster_Bound;
const int INF32 = 2e9+10;
const long long INF64 = 1e18+10;
const long long mod1 = 1e9+7;
const long long mod2 = 998244353;


const int N = 5e5+10;
int n=read(),ans[N],dat[N],pos[N];
ll k=read64();
int trcnt;
struct TREE{
	int ls,rs,num,minn;
}t[N<<2];  int Root;
#define ls(x) t[x].ls
#define rs(x) t[x].rs
void Build(int &x,int a,int b){
	x=++trcnt;
	if(a==b){
		t[x].minn=dat[a];
		t[x].num=1;
		return;
	}
	int mid=(a+b)>>1;
	Build(ls(x),a,mid);
	Build(rs(x),mid+1,b);
	t[x].num=t[ls(x)].num+t[rs(x)].num;
	t[x].minn=min(t[ls(x)].minn,t[rs(x)].minn);
}
int Query(int x,int cur){
     if(!t[x].num||!cur) return INF32;
	 if(t[x].num<=cur)
	 	return t[x].minn;
	 if(t[ls(x)].num<=cur) return min(t[ls(x)].minn,Query(rs(x),cur-t[ls(x)].num));
	 else return Query(ls(x),cur);
}
int Delete(int x,int a,int b,int seat){
	--t[x].num;
	if(a==b){
		t[x].minn=INF32;
		return 1;
	}
	int mid=(a+b)>>1,res;
	if(seat<=mid) res=Delete(ls(x),a,mid,seat);
	else res=t[ls(x)].num+Delete(rs(x),mid+1,b,seat);
	t[x].minn=min(t[ls(x)].minn,t[rs(x)].minn);
	return res;
}


signed main() {
	Main_cry();
//	File();
	for(int i=1;i<=n;++i)
		dat[i]=read(),pos[dat[i]]=i;
	Build(Root,1,n);
	for(int i=1;i<=n;++i){
		int x;x=Query(Root,min(k+1,n-i+1));
		ans[++ans[0]]=x;
		k-=Delete(Root,1,n,pos[x])-1;
	}	
	if(k&1) swap(ans[n-1],ans[n]);
	for(int i=1;i<=n;++i)
		printf("%lld ",ans[i]);
	return puts(""),0;
}

```

  

---

## 作者：YuanZihan1225 (赞：3)

[传送门](https://www.luogu.com.cn/problem/P7818)

要使字典序最小，显然可以贪心的把第 $i$ 小的数放到第 $i$ 个位置，那我们从前往后扫描排列，对于第 $i$ 个数，查找 $[i,\min(i+k,n)]$ 中最小的数，将其交换到 $i$ 位置， $k$ 减少需要交换的次数。

查找区间最小值可以用线段树维护，但是交换很麻烦，怎么办？

其实我们可以不用真的每次都去交换，用线段树维护一个区间内有多少个数没被处理过（指没有被交换到最优位置），当处理到第 $i$ 位时，还剩 $k$ 次交换的机会，就在没被处理过的数中找从前往后找最多 $\min(k+1,n-i+1)$ 次最小数。
```cpp
long long query(int id, int cnt)
{
	if(!tr[id].num || !cnt) return inf;
	if(tr[id].num <= cnt) return tr[id].mn;
	if(tr[ls].num <= cnt) return min(tr[ls].mn, query(rs, cnt - tr[ls].num));
	else return query(ls, cnt);
}
```
找到后用一个 $ans$ 数组依次存储起来。然后需要更新线段树：标记处理后的数为 $inf$ ，将相应区间内未处理过的数的数量 $-1$ ，还要求出交换的次数，即这个数离 $i$ 的距离，再用 $k$ 减去交换的次数。
```cpp
long long update(int id, int l, int r, int pos)
{
	tr[id].num--;
	if(l == r)
	{
		tr[id].mn = inf;
		return 1;
	}
	int mid = l + r >> 1;
	int res = 0;
	if(pos <= mid) res = update(ls, l, mid, pos);
	else res = tr[ls].num + update(rs, mid + 1, r, pows);
	tr[id].mn = min(tr[ls].mn, tr[rs].mn);
	return res; 
}
```
最后要注意 $k$ 会很大，可能排列已经是字典序最小了还需要交换，那么我们肯定贪心的只交换最后两个数，即 $k$ 为奇数时交换一次，偶数时相当于不交换。

~~抄袭无耻，天理不容！~~

---

## 作者：_maple_leaf_ (赞：1)

## 题意
够清晰了，不再赘述。

## 思路
首先，由于是字典序，所以我们要让前几位尽量小，也就是要让第 $i$ 位取到 $\min^{\min(n,i+k)}_{j=i}p_j$，假设取到了 第 $i+o$ 位，取完后相应的让 $k=k-o$，并把它移到第 $i$ 位，于是考虑如何维护。

接着，我们可以先维护一个区间和并支持区间加的线段树，因为把第 $i+o$ 位移到 $i$ 位，就是把 $[i+o,n]$ 这一段区间内移到未取到的值的最前面所需要的次数减一，我们就可以将第 $i$ 位移到未取到的值的最前面所需要的次数的初值设为 $i-1$。这样，我们查找最小值的区间右端点就可以用二分求出，即二分找到第一个移到未取到的值的最前面所需要的次数大于 $k$ 的地方 $r$，然后查找区间的右端点就取 $r-1$。 

然后，我们再维护一个区间最小值并支持单点修改的线段树，可以查找 $[i,r-1]$ 这一区间内的最小值 $p_{min}$，并在查询完后将这个最小值压入答案队列并修改为无穷大，这样就不会再取到。然后在找到最小之后就可以在维护的第一个线段树中把 $[min,n]$ 这一段区间内的到未取到的值的最前面所需要的次数都减一。然而上述操作只在维护的第二个线段树中维护一个最小值是不够的，所以还要维护一个编号。

最后，注意到题目中要求的是恰好 $k$ 次，所以当所有位置都填完后 $k$ 是一个奇数，那就交换答案的最后两个位置，可以证明这是最优的。然后输出。

## 代码
```cpp
//by _maple_leaf_ uid:964876
void push_down(int id,int l,int r){
    tr[id<<1]+=tr[id];
    tr[id<<1|1]+=tr[id];
    tr[id]=0;
}
void build(int id,int l,int r){
    if(l==r){
        tr[id]=l-1;
        return ;
    }int mid=l+r>>1;
    build(id<<1,l,mid);
    build(id<<1|1,mid+1,r);
}
void update(int id,int l,int r,int s,int t,int v){
    if(s<=l&&r<=t){
        tr[id]+=v;
        return ;
    }push_down(id,l,r);
    int mid=l+r>>1;
    if(s<=mid)update(id<<1,l,mid,s,t,v);
    if(mid<t)update(id<<1|1,mid+1,r,s,t,v);
}
int find(int id,int l,int r,int x){
    if(l==r)return tr[id];
    push_down(id,l,r);
    int mid=l+r>>1;
    if(x<=mid)return find(id<<1,l,mid,x);
    else return find(id<<1|1,mid+1,r,x);
}
struct node{
	int z,id;//维护的编号
	bool operator <(const node &b)const{
		return z==b.z?id<b.id:z<b.z; 
	}//重载运算符方便比较
}trr[N<<2];
void init(int id,int l,int r){
	if(l==r){
		trr[id]={a[l],l};
		return ;
	}int mid=l+r>>1;
	init(id<<1,l,mid);
	init(id<<1|1,mid+1,r);
	trr[id]=min(trr[id<<1],trr[id<<1|1]);
}
void gx(int id,int l,int r,int x,int v){
	if(l==r){
		trr[id].z=v;
		return ;
	}int mid=l+r>>1;
	if(x<=mid)gx(id<<1,l,mid,x,v);
	else gx(id<<1|1,mid+1,r,x,v);
	trr[id]=min(trr[id<<1],trr[id<<1|1]);
}
node get(int id,int l,int r,int s,int t){
	if(s<=l&&r<=t){
		return trr[id];
	}int mid=l+r>>1;
	node ret={1919810,114514};
	if(s<=mid)ret=min(ret,get(id<<1,l,mid,s,t));
	if(mid<t)ret=min(ret,get(id<<1|1,mid+1,r,s,t));
	return ret; 
} 
vector<int>ans;
bool f[N];
signed main(){
    n=read(),k=read();
    for(int i=1;i<=n;i++)a[i]=read();
    build(1,1,n);
    init(1,1,n);//初始化
    for(int i=1;i<=n;i++){
		int l=1,r=n;
		while(l<r){
			int mid=l+r>>1;
			if(find(1,1,n,mid)>k)r=mid;
			else l=mid+1;
		}//二分查找
		node tmp;
		if(find(1,1,n,r)>k)tmp=get(1,1,n,1,r-1);
		else tmp=get(1,1,n,1,r);
        ans.push_back(tmp.z);
        k-=find(1,1,n,tmp.id);
        gx(1,1,n,tmp.id,1919810);//修改为无穷大
        update(1,1,n,tmp.id+1,n,-1);
    }
    if(k&1ll)swap(ans[n-2],ans[n-1]);
    for(auto i:ans)write(i,-1);
    return 0;
}
```

---


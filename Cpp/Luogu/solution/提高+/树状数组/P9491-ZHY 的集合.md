# ZHY 的集合

## 题目背景

## 赛后时限改为 1s。

ZHY 又一次在赛时看错题了。
[](T341514)

## 题目描述

对于两个集合大小为 $x$ 的集合 $A,B$，满足 $A\cap B=\varnothing$（空集），ZHY 定义 $f(A,B)$ 如下：

- 设 $C=A\cup B$。将 $C$ 中的元素从小到大排序。

- $f(A,B)=\displaystyle \sum_{i=1}^x C_i$。

现在，ZHY 有 $n$ 个大小为 $m$ 的集合 $S_1,S_2,\cdots,S_n$，他想知道 $\displaystyle \sum_{i=1}^n\sum_{j=i + 1}^n f(S_i,S_j)$ 是多少。

然而，ZHY 并不满足于此。于是他又进行了 $q$ 次修改操作，每次操作会重新给定一个集合。请你在每次修改后都输出一次答案，即 $\displaystyle \sum_{i=1}^n\sum_{j=i + 1}^n f(S_i,S_j)$。保证任意时刻任意一个集合中元素两两不同，保证任意时刻任意两个集合的交为空。

## 说明/提示

**本题采用捆绑测试。**

| $\mathrm{Subtask} \kern{2pt} \mathrm{id}$ | $n$ | $m$ | $q$ | 分值 |
| :-----: | :-----: | :-----: | :-----: | :-----: |
| $0$ | $\le 100$ | $\le 10$ | $\le 10$ | $7$ |
| $1$ | $\le 100$ | $\le 100$ | $\le 100$ | $11$ |
| $2$ | $\le 10^3$ | $\le 100$ | $\le 10^3$ | $7$ |
| $3$ | $\le 10^4$ | $\le 100$ | $=0$ | $15$ |
| $4$ | $\le 10^4$ | $\le 100$ | $\le 10^3$ | $27$ |
| $5$ | $\le 10^4$ | $\le 100$ | $\le 10^4$ | $33$ |

对于所有数据，$0 \le n, q \le 10^4$，$1 \le m \le 100$，$1 \le S_{i,j} \le 10^9$。保证任意时刻对于 $\forall i\in [1,n],\kern{2pt}j \in [1,m],\kern{2pt}i' \in[1,n],\kern{2pt}j'\in [1,m]$，若 $i \ne i'$ 或 $j \ne j'$，则 $S_{i,j} \ne S_{i',j'}。$

## 样例 #1

### 输入

```
3 2 2
1 3
2 6
4 8
1 3 5
2 7 9```

### 输出

```
13
18
26```

# 题解

## 作者：Lynkcat (赞：6)

考虑算一下贡献。

当集合 $S_i$ 与 $S_j$ 进行归并的时候，当且仅当 $S_{i,k}< S_{j,m-k+1}$ 时 $S_{i,k}$ 会算进答案里。

于是枚举 $k$，用 BIT 维护 $S_{j,m-k+1}$ 来动态算 $S_{i,k}$ 的贡献与 $S_{j,m-k+1}$ 的贡献，所以总时间复杂度 $O(qm\log n)$。

下面提供了 $O(qm\log nm)$ 的代码，不难通过精细实现做到 $O(qm\log n)$。

```c++
// Problem: T350821 ZHY 的集合
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/T350821?contestId=117064
// Memory Limit: 256 MB
// Time Limit: 5000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
#define poly vector<int>
#define IOS ios::sync_with_stdio(false)
#define ll long long
#define mp make_pair
#define mt make_tuple
#define pa pair < int,int >
#define fi first
#define se second
#define inf 1e18
#define mod 998244353
#define sz(x) (int)((x).size())
#define int ll
#define N 2000005
using namespace std;
int n,m,q,lst[20005],a[20005][105];
int id[20005];
int tmp[N],ans[N];
namespace BIT
{
	int tr[N],tr1[N];
	inline void upd(int x,int y,int z){while (x<N){tr[x]+=y;tr1[x]+=z;x+=x&-x;}}
	inline int qry(int x){int res=0;while(x){res+=tr[x];x-=x&-x;}return res;}
	inline int qry1(int x){int res=0;while(x){res+=tr1[x];x-=x&-x;}return res;}
}
void BellaKira()
{
	cin>>n>>m>>q;
	poly g;
	for (int i=1;i<=n;i++)
	{
		lst[i]=0;
		for (int j=1;j<=m;j++)
		{
			cin>>a[i][j];
			g.push_back(a[i][j]);
		}
		sort(a[i]+1,a[i]+m+1);
		id[i]=i;
	}
	for (int i=n+1;i<=n+q;i++)
	{
		cin>>lst[i];
		int x=lst[i];
		lst[i]=id[lst[i]];
		for (int j=1;j<=m;j++)
		{
			cin>>a[i][j];
			g.push_back(a[i][j]);
		}
		sort(a[i]+1,a[i]+m+1);
		id[x]=i;
	}
	sort(g.begin(),g.end());
	g.erase(unique(g.begin(),g.end()),g.end());
	for (int i=1;i<=n+q;i++)
		for (int j=1;j<=m;j++) a[i][j]=lower_bound(g.begin(),g.end(),a[i][j])-g.begin()+1;
	for (int t=1;t<=m;t++)
	{
		// cout<<"!!"<<t<<endl;
		for (int i=1;i<=n;i++)
		{
			tmp[i]=tmp[i-1];
			// cout<<"?"<<a[i][t]<<endl;
			tmp[i]+=BIT::qry1(a[i][t]-1);
			tmp[i]+=(BIT::qry(N-1)-BIT::qry(a[i][t]-1))*g[a[i][t]-1];
			// cout<<"?"<<i<<" "<<BIT::qry(a[i][t])<<endl;
			BIT::upd(a[i][m-t+1],1,g[a[i][m-t+1]-1]);
		}
		// cout<<"??"<<tmp[n]<<endl;
		// cout<<"!!"<<t<<endl;
		for (int i=n+1;i<=n+q;i++)
		{
			tmp[i]=tmp[i-1];
			BIT::upd(a[lst[i]][m-t+1],-1,-g[a[lst[i]][m-t+1]-1]);
			tmp[i]-=BIT::qry1(a[lst[i]][t]-1);
			tmp[i]-=(BIT::qry(N-1)-BIT::qry(a[lst[i]][t]-1))*g[a[lst[i]][t]-1];


			tmp[i]+=BIT::qry1(a[i][t]-1);
			tmp[i]+=(BIT::qry(N-1)-BIT::qry(a[i][t]-1))*g[a[i][t]-1];
			BIT::upd(a[i][m-t+1],1,g[a[i][m-t+1]-1]);
		}
		for (int i=1;i<=n+q;i++) ans[i]+=tmp[i];
		
		for (int i=1;i<=n;i++)
			BIT::upd(a[i][m-t+1],-1,-g[a[i][m-t+1]-1]);
		for (int i=n+1;i<=n+q;i++)
		{
			BIT::upd(a[lst[i]][m-t+1],1,g[a[lst[i]][m-t+1]-1]);
			BIT::upd(a[i][m-t+1],-1,-g[a[i][m-t+1]-1]);
		}
	}
	for (int i=n;i<=n+q;i++) cout<<ans[i]<<'\n';
			
			
	
}
signed main()
{
	IOS;
	cin.tie(0);
	int T=1;
	while (T--)
	{
		BellaKira();
	}
}
```

---

## 作者：Galex (赞：3)

考虑没有修改怎么做，先将每个 $S_i$ 从小到大排序。

对于 $S_{i_1,j}$，若它在 $f(S_{i_1},S_{i_2})$ 中会产生贡献，则说明 $S_{i_1,j} < S_{i_2,m-j+1}$，因为此时比 $S_{i_1,j}$ 小的数最多有 $m-1$ 个。那么 $S_{i_1,j}$ 对答案产生贡献的次数就是 $\displaystyle \sum_{i_2=1}^n [S_{i_2,m-j+1}>S_{i_1,j}]$。对于每个 $j$ 定义 $T_{j,i}=S_{i,j}$，将 $T_j$ 排序，然后对于每个 $S_{i,j}$ 算它的贡献时在排好序的 $T_{m-j+1}$ 里二分一下有多少个数比它大即可。复杂度 $O(nm\log n)$。

有修改类似。假设需要修改的集合是 $S_x$。设 $V(x)=\displaystyle \sum_{i=1}^n [i\ne x]\times f(S_i,S_x)$，那么答案只需减去修改前的 $V(x)$ 再加上修改后的 $V(x)$。故只需考虑怎么算 $V(x)$。

首先肯定得算上 $S_x$ 中每个数的贡献，这部分和没有修改差不多，为保证 $T_j$ 有序可以使用平衡树维护。

再考虑其它集合的贡献。我们知道 $S_{i,j}$ 会产生贡献当且仅当 $S_{i,j} < S_{x,m-j+1}$。显然这里每个 $S_{i,j}$ 至多对 $V(x)$ 产生一次贡献。如果我们先枚举 $S_{x,j}$，则相当于要求 $\displaystyle \sum_{i=1}^n [S_{i,m-j+1}<S_{x,j}] \times S_{i,m-j+1}$，也就是 $T_{m-j+1}$ 的一个前缀和。这也能用平衡树很好的维护。于是这题就做完了。

总复杂度 $O((n+q)m\log n)$。

但是平衡树常数过大，时限缩小后可能无法通过。所以可以离散化后将平衡树改为权值树状数组，即可轻松通过。

---


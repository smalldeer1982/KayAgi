# [KTSC 2024 R1] 铁路 2

## 题目背景

**请勿用 C++14 (GCC 9) 提交。**

你需要在程序开头加入如下代码：

```cpp
#include<vector>
int travel(std::vector<int> U, std::vector<int> V, std::vector<int> W);
```

## 题目描述

**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T4 「[철도 2](https://assets.ioikorea.kr/ioitst/2024/1/railroad2/railroad2_statement.pdf)」**

IOI 国有 $N$ 个城市和连接这些城市的 $N-1$ 条双向铁路，任意两个不同的城市都可以通过铁路互相到达。也就是说，IOI 国的铁路网络是一个树结构。城市编号从 $0$ 到 $N-1$，铁路编号从 $0$ 到 $N-2$。对于每条编号为 $i$ 的铁路，它连接了编号为 $U[i]$ 和 $V[i]$ 的城市，长度为 $W[i]$。

在 IOI 国的任何一个城市出发，都可以乘坐直达列车直接到达另一个城市。也就是说，对于所有 $u,v$ $(0 \leq u, v \leq N-1, u \neq v)$ 的 $N(N-1)$ 个城市对 $(u, v)$，从 $u$ 城市出发到达 $v$ 城市的直达列车存在。乘坐这趟直达列车时，直到到达 $v$ 城市之前不能下车，这趟列车的耗时等于 IOI 国铁路网络中从 $u$ 城市到 $v$ 城市的唯一简单路径上所有铁路的长度之和。

作为铁路爱好者，你喜欢长时间乘坐一列火车，享受悠闲的时光。因此，乘坐耗时长的直达列车会让你感到更大的乐趣。

具体来说，对于两个不同的城市 $x, y$，乐趣 $\operatorname{joy}(x, y)$ 定义为满足以下条件的最大正整数 $D$：

- 从 $x$ 城市出发，乘坐耗时至少为 $D$ 的直达列车，经过有限次后到达 $y$ 城市。

你需要编写一个程序，计算满足 $0 \leq x, y \leq N-1, x \neq y$ 的所有 $N(N-1)$ 个城市对 $(x, y)$ 的 $\operatorname{joy}(x, y)$ 之和，并对 $1000000007\left(=10^{9}+7\right)$ 取模。

你需要实现以下函数：

```cpp
int travel(std::vector<int> U, std::vector<int> V, std::vector<int> W);
```

- 该函数只会被调用一次。
- `U, V, W`：大小为 $N-1$ 的整数数组。对于每个 $i$ $(0 \leq i \leq N-2)$，存在一条连接 $U[i]$ 和 $V[i]$ 的长度为 $W[i]$ 的铁路。
- 该函数需要返回满足 $0 \leq x, y \leq N-1, x \neq y$ 的所有 $N(N-1)$ 个城市对 $(x, y)$ 的 $\operatorname{joy}(x, y)$ 之和，并对 $1000000007\left(=10^{9}+7\right)$ 取模。

注意，提交的代码中不应包含任何输入输出操作。

## 说明/提示

对于所有输入数据，满足：

- $2 \leq N \leq 5\cdot 10^5$
- IOI 国的铁路网络是一个树结构
- 对于所有 $i$ $(0 \leq i \leq N-2)$，$0 \leq U[i], V[i] \leq N-1 ; U[i] \neq V[i]$
- 对于所有 $i$ $(0 \leq i \leq N-2)$，$1 \leq W[i] \leq 10^9$

详细子任务附加限制及分值如下表所示。

| 子任务 | 分值 | 附加限制 |
| :-: | :-: | :-: |
| $1$ | $3$ | $N \leq 50$ |
| $2$ | $6$ | $N \leq 500$ |
| $3$ | $19$ | $N \leq 2000$ |
| $4$ | $5$ | $N \leq 8000$；<br>对于所有 $i$ $(0 \leq i \leq N-2)$，$U[i]=0$ |
| $5$ | $7$ | $N \leq 8000$；<br>对于所有 $i$ $(0 \leq i \leq N-2)$，$U[i]=i, V[i]=i+1$ |
| $6$ | $15$ | $N \leq 8000$ |
| $7$ | $4$ | 对于所有 $i$ $(0 \leq i \leq N-2)$，$U[i]=0$ |
| $8$ | $11$ | 对于所有 $i$ $(0 \leq i \leq N-2)$，$U[i]=i ; V[i]=i+1$ |
| $9$ | $30$ | 无附加限制 |

## 样例 #1

### 输入

```
5
0 1 1
1 2 2 
0 3 3
0 4 2```

### 输出

```
80```

## 样例 #2

### 输入

```
5 
0 1 3 
0 2 2
0 3 2
0 4 1```

### 输出

```
78```

## 样例 #3

### 输入

```
6 
0 1 3 
1 2 1
2 3 4
3 4 1
4 5 5```

### 输出

```
284```

# 题解

## 作者：songhongyi (赞：2)

题意：一棵树，建立一个新图，两点间距离为树上距离。定义两个点的权值 $f(x,y)$ 定义为最大的 $D$ 使得仅使用新图中边权超过 $D$ 的边可以使得 $x,y$ 连通。求任两点权值和。

其实这题和瓶颈树之类的没啥关系。考虑到每个点 $x$ 距离它最远的距离 $d_x$。显然 $f(x,y) \le \min{(d_x,d_y)}$。不难发现，通过走到直径端点即可取到这个值。因此我们只需要求出 $ \min{(d_x,d_y)}$ 的和即可。排序后，$d_i$ 的系数为 $2(n-i)$。复杂度为 $O(n \log n)$，瓶颈在排序。

```cpp
//
// Problem: P11238 「KTSC 2024 R1」铁路 2
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P11238
// Memory Limit: 1000 MB
// Time Limit: 2000 ms

#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;
const int MAXN = 5e5 + 10, pmod = 1e9 + 7;
vector< pair< int, int > > edges[ MAXN ];
long long int dis[ MAXN ], dis2[ MAXN ], d[ MAXN ];
void dfs( int x, int fa )
{
    for ( auto i : edges[ x ] )
    {
        if ( i.first != fa )
        {
            dis[ i.first ] = dis[ x ] + i.second;
            dfs( i.first, x );
        }
    }
}
int travel( std::vector< int > U, std::vector< int > V, std::vector< int > W )
{
    int n = U.size() + 1;
    for ( int i = 0; i < n - 1; i++ )
    {
        U[ i ]++, V[ i ]++;
        edges[ U[ i ] ].emplace_back( V[ i ], W[ i ] );
        edges[ V[ i ] ].emplace_back( U[ i ], W[ i ] );
    }
    dfs( 1, 1 );
    int u = 0;
    for ( int i = 1; i <= n; i++ )
    {
        if ( dis[ i ] > dis[ u ] )
        {
            u = i;
        }
    }
    dis[ u ] = 0;
    dfs( u, u );
    int v = 0;
    for ( int i = 1; i <= n; i++ )
    {
        dis2[ i ] = dis[ i ];
        if ( dis[ i ] > dis[ v ] )
        {
            v = i;
        }
    }
    dis[ v ] = 0;
    dfs( v, v );
    for ( int i = 1; i <= n; i++ )
    {
        d[ i ] = max( dis[ i ], dis2[ i ] );
    }
    sort( d + 1, d + n + 1 );
    long long int res = 0;
    for ( int i = 1; i <= n; i++ )
    {
        ( res += d[ i ] % pmod * ( n - i ) % pmod ) %= pmod;
    }
    return res * 2 % pmod;
}
```

---

## 作者：dyc2022 (赞：1)

[更好的阅读体验](https://www.cnblogs.com/dyc2022/p/18953742)
***
**以下所有下标均从 $\boldsymbol 1$ 开始。**
***
题面过于冗长，用人话讲就是对于每个点对 $(u, v)$，定义 $\text{joy}(u,v) = \max\limits_{p}\min \{\text{dis}(u,p), \text{dis}(p,v)\}$，然后求 $\sum \limits_{u=1}^{n} \sum \limits_{v=1}^{n} \text{joy}(u,v)$。

观察这个式子 $\text{joy}(u,v) = \max\limits_{p}\min \{\text{dis}(u,p), \text{dis}(p,v)\}$，我们发现这个 $p$ 点一定要是 $u,v$ 能到达的最远点。联系到我们用两次 dfs 求树的直径的过程，我们发现这个点一定是直径的端点。

那么对于一个点 $i$，我们把它到直径端点的距离处理出来，称其为 $maxd_i$。我们先假设我们要求的是无序点对的答案，那么我们求 $mxd$ 两两最小值之和，其实就是将 $mxd$ 升序排序后，对于下标数对 $(i,j)(i<j)$，是 $i$ 产生贡献。所以 $i$ 位置产生贡献的区间为 $[i+1,n]$，长度为 $n-i$。求和最后 $\times 2$ 即可。

对于实现，可以用树上倍增求出点对距离，复杂度 $O(n \log n)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
#define N 500006
#define MOD 1000000007
using namespace std;
signed travel(vector<signed> U,vector<signed> V,vector<signed> W);
int n,fa[21][N],wt[21][N],dep[N],s,t,maxd[N],maxn;
vector<pair<int,int> > G[N];
void dfs(int u)
{
    for(int i=1;i<=20;i++)
        fa[i][u]=fa[i-1][fa[i-1][u]],wt[i][u]=wt[i-1][u]+wt[i-1][fa[i-1][u]];
    for(auto [v,w]:G[u])if(v!=fa[0][u])
        fa[0][v]=u,wt[0][v]=w,dep[v]=dep[u]+1,dfs(v);
}
int getdis(int u,int v)
{
    int ret=0;
    if(dep[u]<dep[v])swap(u,v);
    for(int i=20;~i;i--)
        if(dep[fa[i][u]]>=dep[v])ret+=wt[i][u],u=fa[i][u];
    if(u==v)return ret;
    for(int i=20;~i;i--)
        if(fa[i][u]^fa[i][v])ret+=wt[i][u]+wt[i][v],u=fa[i][u],v=fa[i][v];
    return ret+wt[0][u]+wt[0][v];
}
signed travel(vector<signed> U,vector<signed> V,vector<signed> W)
{
    n=U.size()+1;
    for(int i=0;i<n-1;i++)
        G[U[i]+1].push_back({V[i]+1,W[i]}),G[V[i]+1].push_back({U[i]+1,W[i]});
    dep[1]=1,dfs(1);
    for(int i=1,tmp;i<=n;i++)
        if((tmp=getdis(1,i))>maxn)maxn=tmp,s=i;
    maxn=0;
    for(int i=1,tmp;i<=n;i++)
        if((tmp=getdis(s,i))>maxn)maxn=tmp,t=i;
    for(int i=1;i<=n;i++)maxd[i]=max(getdis(s,i),getdis(t,i));
    sort(maxd+1,maxd+1+n);
    int ret=0;
    for(int i=1;i<=n;i++)ret+=maxd[i]%MOD*(n-i)%MOD,ret%=MOD;
    return ret*2%MOD;
}
```

---

## 作者：内拉组里 (赞：0)

第一次写函数交互题，一直 **RE**，调了很久，遂作此篇，进食后人。

本文所有下标从 $ 1 $ 开始。

# Subtask 1$ / $2

看到题目第一反应是瓶颈路问题，然后推了一个多小时成功证伪了这个想法）

观察 $ joy $ 函数的定义，不难发现对于所有 $ (u,v) $，都有 $ joy(u,v) = joy(v,u) \ge dist (u,v) $。

一方面很容易想到只需要求一半的 $ joy(u,v) $ 然后翻倍即可得到答案；

另一方面可以考虑建一张无向完全图，在任意两点 $ (u,v) $ 间连一条权值为 $ dist(u,v) $ 的边。

然后就可以用类似 **Floyd** 的方法去暴力 **dp** 更新一下所有的 $ joy(u,v) $ 即可。

## Analyses：

> 总时间复杂度 $ \Theta (N^3) $。
>
> 总空间复杂度 $ \Theta (N^2) $。

## Code：

```cpp
namespace pts28
{
	int n;
	vector<pii> G[maxn];
	int dist[maxn][maxn];
	
	signed main (void)
	{
		for (int i = 1; i <= n; i++)
		{
			auto dfs = [&] (auto &dfs, int u, int rt) -> void
			{
				for (auto [v, w] : G[u]) if (v != rt)
				{
					dist[i][v] = dist[i][u] + w;
					dfs (dfs, v, u);
				}
			};
			dfs (dfs, i, i);
		}
		for (int k = 1; k <= n; k++)
		{
			for (int i = 1; i <= n; i++)
			{
				for (int j = 1; j <= n; j++)
					dist[i][j] = max (dist[i][j], min (dist[i][k], dist[k][j]));
			}
		}
		int ans = 0;
		for (int i = 1; i <= n; i++)
		{
			for (int j = i + 1; j <= n; j++)
				(ans += dist[i][j]) %= modd;
		}
		return (ans << 1) % modd;
	}
}
```

***

# Subtask 4$ / $7

对于菊花图的情况，可以手玩样例 **#2**。

对于 $ joy(u,v) $，分类讨论 $ u $ 和 $ v $ 在树中充当的身份

这里钦定所有节点中，距离根最远的子节点为 $ x $，因为 $ n \ge 2 $，故这样的 $ x $ 一定存在。

- $ u $ 为根，$ v $ 为任意不为 $ x $ 的节点，$ joy(u,v) = dist(u,x) $，

	即每一次都先跳到 $ x $，再跳到 $ v $，由于 $ x $ 是根能跳到的最远的节点，故不存在更优解。

- $ u = x $，$ v $ 为任意非根节点，$ joy(u,v) = dist(u,rt) + dist(rt,v) $，

	即每一次先跳到根，然后直接跳到 $ v $，

	由于在菊花图中任意一个非根节点 $ y $ 到 $ v $ 的距离可以表示为 $ dist(y,rt) + dist(rt,v) $，

	而在 $ y = x $ 时取到最大值，故不存在更优解。

- $ u,v $ 均不是 $ x $，也不是根，$ joy(u,v) = \min(dist(u,x),dist(v,x)) $，

	即每一次先跳到 $ x $，再跳到 $ v $，证明同上，

	即由于 $ dist(y,rt) + dist(rt,v) $ 在 $ y = x $ 处取到最大值，

	即 $ x $ 是 $ u $ 能到达的最远的点（之一 $ ? $），故一定不存在更优解。

综上所述，在菊花图中有 $ joy(u,v) = \min(dist(u,rt),dist(v,rt)) + dist(rt,x) $，

**Ps：**这里的 $ dist(u,v) $ 可以做前缀和优化处理，即用 $ dep_u $ 表示 $ dist(u,rt) $。

$ ans = \sum\limits^n_{i = 1} \sum\limits^n_{j = 1,j \neq i} [\min(dep_u + dep_v) + dep_x] $，

对所有的 $ dep_u $ 升序排序，然后再对 $ dep_u $ 做一遍前缀和 $ p_u $，即可得到：
$$
\begin{aligned}
	ans &= 2 \sum\limits^n_{i = 1} \sum\limits^n_{j = i + 1} (dep_i + dep_x) \\ 
		&= 2 \sum\limits^n_{i = 1} (n - i) (dep_i + dep_x) \\ 
		&= 2 \sum\limits^n_{i = 1} (n \times dep_i - i \times dep_i + n \times dep_x - i \times dep_x) \\ 
		&= 2 n^2 dep_x - n (n + 1) dep_x - 2 \sum\limits^n_{i = 1} (n - i) \times dep_i \\ 
		&= n (n - 1) dep_x - 2 \sum\limits^n_{i = 1} (n - i) dep_i 
\end{aligned}
$$
$ \Theta (N) $ 扫过去计算 $ \sum\limits^n_{i = 1} (n - i) dep_i $ 即可。

这里要特别注意一下 $ joy(u,u) $ 的情况。

## Analyses：

> 对应时间复杂度 $ \Theta (N \log{N}) $，瓶颈在于排序。
>
> 对应空间复杂度 $ \Theta (N) $。

***

# Subtask 5$ / $8

对于树是一条链的情况，自己手玩样例 **#3** 后不难发现，所有情况不外乎以下四种情况：

1. $ u \rightarrow 1 \rightarrow v $ 
2. $ u \rightarrow n \rightarrow v $ 
3. $ u \rightarrow 1 \rightarrow n \rightarrow v $ 
4. $ u \rightarrow n \rightarrow 1 \rightarrow v $ 

总结起来就是 $ joy(u,v) = \min\Large{\max(dist(0,u),dist(u,n)) \choose \max(dist(0,v),dist(v,n))} $ 

类似地，对所有的 $ \max(dist(0,u),dist(u,n)) $ 排序，式子可以自己尝试推一下。

## Analyses：

> 对应时间复杂度 $ \Theta (N \log{N}) $，瓶颈在于排序。
>
> 对应空间复杂度 $ \Theta (N) $。

***

# Full Mark

用以上的方法已经可以拿到 **92pts** 了，而满分只需要把一条链的情况放在树上加以完善即可。

不难发现一条链和树的直径其实十分类似，

于是大胆猜测对于一条直径 $ s \sim t $，$ joy(u,v) = \min\Large{\max(dist(u,s),dist(u,t)) \choose \max(dist(v,s),dist(v,t))} $。

证明也非常简单，

根据树的直径的性质可得，树上任意一点能够到达的最远的点一定是直径的一端。

所以 $ s $ 和 $ t $ 都跳到了力所能及的最远的点，并且距离不会超过直径，所以不存在更优解。

首先预处理出从 $ s $ 和 $ t $ 出发到每个点的路径，

然后类似地排个序 $ \Theta (N) $ 扫过去多项式求和即可。

## Analyses：

> 总时间复杂度 $ \Theta (N \log{N}) $，瓶颈在于排序。
>
> 总空间复杂度 $ \Theta (N) $。

# Code

```cpp
/* construct : AUG 13'25 */
// #include	"railroad2.h"	(LOJ)
#include	<algorithm>
#include	<iostream>
#include	<cstring>
#include	<vector>
#include	<queue>
#define		int		long long
using namespace std;
using pii = pair<int,int>;
constexpr int maxn = 5e5+4;
constexpr int modd = 1e9+7;

int n;
vector<pii> G[maxn];

namespace pts9
{
	constexpr int maxn = 2e3+4;
	int dist[maxn][maxn];
	
	signed main (void)
	{
		for (int i = 1; i <= n; i++)
		{
			auto dfs = [&] (auto &dfs, int u, int rt) -> void
			{
				for (auto [v, w] : G[u]) if (v != rt)
				{
					dist[i][v] = dist[i][u] + w;
					dfs (dfs, v, u);
				}
			};
			dfs (dfs, i, i);
		}
		for (int k = 1; k <= n; k++)
		{
			for (int i = 1; i <= n; i++)
			{
				for (int j = 1; j <= n; j++)
					dist[i][j] = max (dist[i][j], min (dist[i][k], dist[k][j]));
			}
		}
		int ans = 0;
		for (int i = 1; i <= n; i++)
		{
			for (int j = i + 1; j <= n; j++)
				(ans += dist[i][j]) %= modd;
		}
		return (ans << 1) % modd;
	}
}

namespace pts92
{
	int f[maxn];
	int g[maxn];
	
	/** @return one of the farthest vertices,the length of the longest chain within [u] */
	pii dfs (int u, int rt)
	{
		int ans = 0;
		int vtx = u;
		for (auto [v, w] : G[u]) if (v != rt)
		{
			auto [btm, len] = dfs (v, u);
			if (ans < len + w)
			{
				ans = len + w;
				vtx = btm;
			}
		}
		return pii (vtx, ans);
	}
	
	signed main (void)
	{
		if (G[1].size() == n - 1)
		{
			vector<int> dist (1, 0);
			for (auto [v, w] : G[1])
				dist.emplace_back(w);
			sort (dist.begin(), dist.end());
			int sum = 0;
			int ans = dist[n - 1] * n % modd * (n - 1) % modd;
			for (int i = 0; i < n; i++)
			{
				(ans += sum + (n - i - 1) * dist[i] % modd) %= modd;
				(sum += dist[i]) %= modd;
			}
			return ans;
		}
		else if ([&] ()
		{
			for (int i = 1; i <= n; i++)
			{
				for (auto [j, _] : G[i])
				{
					if (j != i - 1 && j != i + 1)
						return 0;
				}
			}
			return 1;
		}())
		{
			vector<int> dist (n + 1);
			dist[1] = 0;
			dist[2] = dist[1] + G[1][0].second;
			for (int i = 2; i < n; i++)
				dist[i + 1] = dist[i] + G[i][1].second;
			int ans = 0;
			vector<int> f (n + 1);
			for (int i = 1; i <= n; i++)
				f[i] = max (dist[i], dist[n] - dist[i]);
			sort (f.begin(), f.end());
			for (int i = 1; i <= n; i++)
				(ans += (n - i) * (f[i] % modd) % modd) %= modd;
			return (ans << 1) % modd;
		}
		else
		{
			auto [s, _] = dfs (1, 1);
			auto [t, __] = dfs (s, s);
			auto dij = [&] (int s, int *dist) -> void
			{
				priority_queue<pii,vector<pii>,greater<pii> > q;
				q.emplace(0, s);
				dist[s] = 0;
				vector<int> vis (n + 1);
				vis[s] = 1;
				while (!q.empty())
				{
					int u = q.top().second; q.pop();
					for (auto [v, w] : G[u])
					{
						if (!vis[v])
						{
							vis[v] = 1;
							dist[v] = dist[u] + w;
							q.emplace(dist[v], v);
						}
					}
				}
			};
			dij (s, f);
			dij (t, g);
			int ans = 0;
			for (int i = 1; i <= n; i++)
			{
				for (int j = i + 1; j <= n; j++)
					(ans += min (max (f[i], g[i]), max (f[j], g[j]))) %= modd;
			}
			return (ans << 1) % modd;
		}
	}
}

namespace pts100
{
	int f[maxn];
	int g[maxn];
	
	/** @return one of the farthest vertices,the length of the longest chain within [u] */
	pii dfs (int u, int rt)
	{
		int ans = 0;
		int vtx = u;
		for (auto [v, w] : G[u]) if (v != rt)
		{
			auto [btm, len] = dfs (v, u);
			if (ans < len + w)
			{
				ans = len + w;
				vtx = btm;
			}
		}
		return pii (vtx, ans);
	}
	
	signed main (void)
	{
		auto [s, _] = dfs (1, 1);
		auto [t, __] = dfs (s, s);
		auto bfs = [&] (int s, int *dist) -> void
		{
			queue<int> q;
			q.emplace(s);
			dist[s] = 0;
			vector<int> vis (n + 1);
			vis[s] = 1;
			while (!q.empty())
			{
				int u = q.front(); q.pop();
				for (auto [v, w] : G[u])
				{
					if (!vis[v])
					{
						vis[v] = 1;
						dist[v] = dist[u] + w;
						q.emplace(dist[v], v);
					}
				}
			}
		};
		bfs (s, f);
		bfs (t, g);
		int ans = 0;
		for (int i = 1; i <= n; i++)
			f[i] = max (f[i], g[i]);
		sort (f + 1, f + n + 1);
		for (int i = 1; i <= n; i++)
			(ans += (n - i) * (f[i] % modd) % modd) %= modd;
		return (ans << 1) % modd;
	}
}

#undef		int
int travel (vector<int> U, vector<int> V, vector<int> W)
{
	n = U.size() + 1;
	for (int i = 0; i < n - 1; i++)
	{
		G[++U[i]].emplace_back(++V[i], W[i]);
		G[V[i]].emplace_back(U[i], W[i]);
	}
	return pts100::main ();
}
```

同时附上双倍经验：[**LibreOJ#4259. 「KTSC 2024 R1」铁路 2**](https://loj.ac/p/4259)

---

## 作者：ElectricArc (赞：0)

## 思路

我们需要分析 $\operatorname{joy}(u, v)$ 的组成。

> $\operatorname{joy}(u, v)$ 定义为满足以下条件的最大正整数 $D$：从城市 $u$ 出发，乘坐耗时至少为 $D$ 的直达列车，经过有限次后能到达城市 $v$ 的最大正整数 $D$。

初看这个定义，可能会觉得一头雾水（~~其实是因为这里没有放样例解释的翻译~~）。我们来看看样例 1：

![](https://cdn.luogu.com.cn/upload/image_hosting/pr8qao5p.png)

设 $\operatorname{dis}(u, v)$ 为 $u, v$ 两点间唯一简单路径的距离。

- $\operatorname{joy}(0, 1) = \min \{ \operatorname{dis}(0, 3), \operatorname{dis}(3, 1) \} = \min \{ 3, 4 \} = 3$。（原样例解释给的比较绕）

- $\operatorname{joy}(1, 2) = \min \{ \operatorname{dis}(1, 3), \operatorname{dis}(3, 2) \} = \min \{ 4, 5 \} = 4$。

- $\operatorname{joy}(2, 3) = \operatorname{dis}(2, 3) = 6$。

我们可以发现，$\operatorname{joy}(u, v)$ 的组成与 $u, v$ 两点各自能到达的最远距离有关。而树上一点 $u$ 能到达的最远的点，一定是这棵树的**直径**的其中一个端点。

设 $p, q$ 为树的直径的端点，$f(u)$ 为 $u$ 能到达的最远距离，则

$$
f(u) = \max \{ \operatorname{dis}(u, p), \operatorname{dis}(u, q) \}
$$

由此可以得到

$$
\operatorname{joy}(u, v) = \min \{ f(u), f(v) \}
$$

接下来的问题是，如何计算 $\operatorname{joy}(u, v)$ 的总和？总不能遍历 $n(n - 1)$ 对 $(u, v)$ 逐个相加吧。这样只能得到 $55$ 分的好成绩。

我们再看回样例解释，它给了一张表：

| $\operatorname{joy}(u, v)$ | $0$ | $1$ | $2$ | $3$ | $4$ |
| :-: | :-: | :-: | :-: | :-: | :-: |
| $0$ | $-$ | $3$ | $3$ | $3$ | $3$ |
| $1$ | $3$ | $-$ | $4$ | $4$ | $4$ |
| $2$ | $3$ | $4$ | $-$ | $6$ | $5$ |
| $3$ | $3$ | $4$ | $6$ | $-$ | $5$ |
| $4$ | $3$ | $4$ | $5$ | $5$ | $-$ |

容易发现 $\operatorname{joy}(u, v) = \operatorname{joy}(v, u)$，且一些值重复出现多次，这启发我们可以根据 $f(u)$ 的大小来确定贡献。

| $u$ | $0$ | $1$ | $2$ | $3$ | $4$ |
| :-: | :-: | :-: | :-: | :-: | :-: |
| $f(u)$ | $3$ | $4$ | $6$ | $6$ | $5$ |

排序后：

| $f(u)$ | $3$ | $4$ | $5$ | $6$ | $6$ |
| :-: | :-: | :-: | :-: | :-: | :-: |
| 贡献次数（只考虑对角线一侧） | $4$ | $3$ | $2$ | $1$ | $0$ |

可以看出，对于每个 $f(i)$，它对答案的贡献是 $f(i) \times (n - i)$。这是因为对于任意一个节点 $u$，所有 $f(j)$ 大于等于 $f(i)$ 的节点 $j$ 都可以作为 $v$，使得 $\operatorname{joy}(u, v)$ 至少为 $f(i)$。由于 $f(i)$ 是**从小到大**排序的，所以满足条件的 $j$ 的数量是 $n - i$。

最后记得 $\times 2$ 再取模（因为刚刚只考虑了对角线一侧），这道题就做完了。

## 具体实现

```cpp
#include <vector>
#include <cstring>
#include <algorithm>
#define ll long long
using namespace std;

const int N = 5e5 + 1, mod = 1e9 + 7;

int p, q; // 树的直径的端点
ll dis[N], dis2[N], maxDis;
vector<pair<int, int>> g[N];

void dfs(int u, int pre) {
	for (auto e : g[u]) {
		int v = e.first, w = e.second;
		if (v == pre) continue;
		dis[v] = dis[u] + w;
		if (dis[v] > maxDis)
			maxDis = dis[v], p = v;
		dfs(v, u);
	}
}

int travel(vector<int> U, vector<int> V, vector<int> W) {
	int n = U.size() + 1;
	for (int i = 0; i < n - 1; i++) {
		g[U[i] + 1].push_back({V[i] + 1, W[i]});
		g[V[i] + 1].push_back({U[i] + 1, W[i]}); // 变成 1 索引
	}

	dfs(1, 0); // 找到 q
	q = p, maxDis = 0;
	memset(dis, 0, sizeof dis);
	dfs(q, 0); // 找到 p
	for (int i = 1; i <= n; i++) dis2[i] = dis[i]; // dis2[i] = dis(i, q)
	memset(dis, 0, sizeof dis);
	dfs(p, 0); // 计算 dis[i] = dis(i, p)

	ll ans = 0;
	vector<ll> f;
	for (int i = 1; i <= n; i++) f.push_back(max(dis[i], dis2[i]));
	sort(f.begin(), f.end());
	for (int i = 1; i <= n; i++)
		ans = (ans + ((f[i - 1] % mod) * (n - i)) % mod) % mod;
	return ans * 2 % mod;
}
```

在这里，三次 dfs、转移 dis、计算答案的时间复杂度都为 $O(n)$ ，而排序的时间复杂度为 $O(n \log n)$ 。

因此总的时间复杂度为 $O(n \log n)$，可以通过该题。

---

## 作者：XYstarabyss (赞：0)

根据题意，我们需要求出的 $joy(x,y)$ 即在树上面找到一个点 $z$，使得 $\min(dis(x,z),dis(y,z))$ 最大。

而我们又知道，在树上面距离一个点最远的一定是树的直径的两个端点中的一个，

所以设直径的两个端点为 $a$ 和 $b$，$dis(x,z)=\max(dis(x,a),dis(x,b))$，$dis(y,z)=\max(dis(y,a),dis(y,b))$。

那如果算的距离中 $x$ 和 $y$ 取到的直径端点不一样怎么办？没关系，因为 $dis(a,b)$ 一定大于等于树上的任何其他距离，不会影响最终答案。

统计答案的时候一定不要直接去枚举，到时候炸给你看。我们要先算出对于每一个编号为 $i$ 的城市对应的 $dis(i,z)$，然后再列出所有的组合。

先看 $n = 4$ 的情况，设 $dis(0,z) \le dis(1,z) \le dis(2,z) \le dis(3,z)$，列出的所有 $joy(x,y)$ 就是

$\min(dis(0,z),dis(1,z)),\min(dis(0,z),dis(2,z)),\min(dis(0,z),dis(3,z))$

$\min(dis(1,z),dis(2,z)),\min(dis(1,z),dis(3,z))$

$\min(dis(2,z),dis(3,z))$

即为

$3 \times dis(0,z)$

$2 \times dis(1,z)$

$1 \times dis(2,z)$

所以用一点排列组合的知识，我们先把 $dis(i,z)$ 排个序，然后对于第 $j$ 小的乘上 $(n - 1)$ 就能算出答案。

还有，因为 $joy(x,y)$ 和 $joy(y,x)$ 算是两个不同的项，所以最终答案还要乘二。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define f(n,m,i) for(register int i(n);i <= m;++ i)
#define fc(n,m,i) for(register int i(n);i >= m;-- i)
#define dbug(x) cerr<<(#x)<<':'<<x<<' ';
#define ent cerr<<'\n';
#define min(a,b) ((a)<(b))?(a):(b)
#define max(a,b) ((a)>(b))?(a):(b)
const int mod(1e9 + 7);
vector <int> map0[500005],map1[500005];
long long dis1[500005],dis2[500005],d[500005];
void dfs(int x,int fa,long long *dis,int &sav){
    f(1,map0[x].size(),i){
        int nxt(map0[x][i - 1]);
        if (nxt != fa){
            dis[nxt] = dis[x] + map1[x][i - 1];
            dfs(nxt,x,dis,sav);
        }
    }
    if (dis[x] > dis[sav]){
        sav = x;
    }
}
int travel(std::vector <int> U,std::vector <int> V,std::vector <int> W){
    int n(U.size() + 1),u(0),v(0);
    f(0,n - 2,i){
        ++ U[i],++ V[i];
        map0[U[i]].push_back(V[i]);
        map0[V[i]].push_back(U[i]);
        map1[U[i]].push_back(W[i]);
        map1[V[i]].push_back(W[i]);
    }
    dfs(1,0,dis1,u);
    dis1[u] = 0,dfs(u,0,dis2,v);
    dis1[v] = 0,dfs(v,0,dis1,u);
    f(1,n,i){
        d[i] = max(dis1[i],dis2[i]);
    }
    sort(d + 1,d + n + 1);
    long long res(0);
    f(1,n,i){
        res = (res + d[i] % mod * (n - i) % mod) % mod;
    }
    return res * 2 % mod;
}
```

---

## 作者：Semsue (赞：0)

对于每个点 $u$，找到树上距离其最远的点集合 $f(u)$，根据直径的性质，直径的端点至少有一个点属于 $f(u)$。设直径端点为 $(s,t)，$记 $d_u=\max(dis(u,s),dis(u,t))$，其中 $dis(u,v)$ 代表 $u,v$ 在树上唯一简单路径的长度。有性质 $joy(u,v)=\min(d_u,d_v)$。

证明：$u$ 或者 $v$ 走到 $s$ 或 $t$ 后可以在直径上反复横跳，所以两边均可取到最大值，两者再取最小值即为最大的 $D$。

故按 $d$ 排序，排名为 $i$ 的 $d$ 对答案贡献 $2(n-i)$ 次。

```cpp
#include <bits/stdc++.h>
#include <vector>
int travel(std::vector<int> U, std::vector<int> V, std::vector<int> W);
using namespace std;
typedef long long i64;
const int maxn = 5e5 + 5, mod = 1e9 + 7;
int qmod(int x) { return x >= mod ? x - mod : x; }
struct para{
	int s, t;
	i64 d;
}tr;
int n, ans;
vector<i64> dep, val, f[21], dd;
vector<pair<int, int>> G[maxn];
int LCA(int u, int v) {
	if (dd[u] < dd[v]) swap(u, v);
	int d = dd[u] - dd[v];
	for (int i = 0; i <= 20; i++) if ((d >> i) & 1) u = f[i][u];
	if (u == v) return u;
	for (int i = 20; ~i; i--) if (f[i][u] != f[i][v]) u = f[i][u], v = f[i][v];
	return f[0][u];
}
i64 dis(int u, int v) {
	return dep[u] + dep[v] - dep[LCA(u, v)] * 2;
}
void dfs(int u, int fa, i64 d) {
	for (int i = 1; i <= 20; i++) f[i][u] = f[i - 1][f[i - 1][u]];
	dep[u] = d;
	if (d > tr.d) tr.t = u, tr.d = d;
	for (auto e : G[u]) if (e.first != fa) {
		f[0][e.first] = u;
		dd[e.first] = dd[u] + 1;
		dfs(e.first, u, d + e.second);
	}
}
int travel(std::vector<int> U, std::vector<int> V, std::vector<int> W) {
	n = U.size() + 1;
	dd.resize(n + 1);
	dep.resize(n + 1);
	val.resize(n + 1);
	for (int i = 0; i <= 20; i++) f[i].resize(n + 1);
	for (int i = 0; i < n - 1; i++) {
		U[i]++, V[i]++;
		G[U[i]].push_back(make_pair(V[i], W[i]));
		G[V[i]].push_back(make_pair(U[i], W[i]));
	}
	tr = para{1, 0, 0};
	dfs(1, 0, 0);
	tr.s = tr.t, tr.d = 0;
	f[0][tr.s] = dd[tr.s] = 0;
	dfs(tr.s, 0, 0);
	for (int i = 1; i <= n; i++) {
		i64 d1 = dis(i, tr.s), d2 = dis(i, tr.t);
		val[i] = max(d1, d2);
	}
	sort(val.begin(), val.end());
	for (int i = n; i >= 1; i--) {
		ans = qmod(ans + 2ll * (val[i] % mod) * (n - i) % mod);
	}
	return ans;
}
```

---


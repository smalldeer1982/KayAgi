# [TOIP 2023] 关卡地图

## 题目描述

许多游戏的设计是以关卡为单位，玩家通过一个关卡后才能挑战下一个关卡。这些关卡的解锁关系有时并不是线性的，也就是玩家通过一个关卡后可能一次开放多个可以挑战的新关卡，也可能不会开放任何新关卡。

经典的 A 游戏就属于这种非线性的关卡结构。关卡的状态分为三种：「尚未解锁」、「已解锁但未通过」以及「已通过」。A 游戏有 $n$ 个关卡，被呈现在一张地图上，其中有 $m$ 对关卡存在相互解锁关系，以 $(u_i, v_i)$ 表示。当玩家通过关卡 $u_i$ 时，关卡 $v_i$ 将被解锁；反过来，当玩家通过关卡 $v_i$ 时，关卡 $u_i$ 也会被解锁。玩家可以从任意关卡开始游戏，且保证在非线性的玩法下，可以通过其他所有关卡。另外，为了避免通关流程过于简单，A 游戏满足 $m \le n$。

凯特决定把 A 游戏当作线性解锁关卡来玩：选择一个起始关卡，接着一旦通过了某个关卡 $c$ 后，下一关**只能是与关卡 $c$ 有相互解锁关系的关卡**，且**一关最多只能通过一次**。已知凯特通过关卡 $i$ 时，得到的成就感为 $a_i$，请帮他找出最适合的通关路径以最大化成就感总和。

举例来说，假设 A 游戏的关卡地图如下图所示，图中圆点中的数字代表关卡编号，圆点旁边的数字代表该关卡通关所得到的成就感；两个关卡的连线代表一个相互解锁关系。若凯特选择从关卡 $7$ 开始通关，则关卡 $5$ 将被解锁，接着依序通过关卡 $5, 1, 3, 6, 2$，得到的成就感总和为 $4+(-3)+(-1)+3+0+2 = 5$。另一方面，若凯特选择从关卡 $8$ 开始通关，并依序通过关卡 $6, 3, 1, 2$，得到的成就感总和为 $2+0+3+(-1)+2 = 6$，此时成就感总和为最大值。

![](https://cdn.luogu.com.cn/upload/image_hosting/5eyx6ogx.png)

## 说明/提示

### 测试数据限制

* $1 \le n \le 10^5$。
* $m = n-1$ 或 $m = n$。
* $1 \le u_i < v_i \le n$，且若 $i \ne j$，保证 $(u_i, v_i) \ne (u_j, v_j)$。
* $-10^9 \le a_i \le 10^9$。
* 游戏设计保证正常游玩（非线性）时从任何一关作为起始关卡皆能解锁所有关卡。
* 上述变量均为整数。

### 评分说明

本题共有四组子任务，条件限制如下所示。
每一组可有一或多组测试数据，该组所有测试数据皆需答对才会获得该组分数。

|  子任务  |  分数  | 额外输入限制 |
| :------: | :----: | ------------ |
| 1 | $17$ | $n \le 100$ |
| 2 | $23$ | $m = n-1$ |
| 3 | $34$ | $a_i \ge 0$ |
| 4 | $26$ | 无额外限制 |

## 样例 #1

### 输入

```
8 8
6 8
3 6
2 6
1 3
1 2
1 4
1 5
5 7
-1 2 3 -10 -3 0 4 2```

### 输出

```
6```

## 样例 #2

### 输入

```
2 1
1 2
-1 -10```

### 输出

```
-1```

# 题解

## 作者：gghack_Nythix (赞：4)

## 前言：

题解只有一篇，所以写一篇。

## 分析：

此题要求我们求树的直径，但是边权变成了点权。

但是没有关系，让我们重新思考。

首先考虑树的子任务：设 $dp_{now}$ 表示以 $now$ 这个点为根的子树，且最长链必经过 $now$ 的最长链长度，$f_{now}$ 表示在以 $now$ 为根的子树中，经过 $now$，但是**不计算** $now$ 点权值的最长链。

那么 $dp_{now}$ 的转移是简单的，分以下三种讨论：

- 以当前点 $now$ 为最优的转移状态。

- 以一条链为最优状态。

- 以两条链拼起来为最优状态。

那么你就可以转移出 $dp_{now}$ 了。$f_{now}$ 的转移也差不多。

```cpp
    f[now] = 0 , dp[now] = a[now] , anstr = max (anstr , dp[now]);
    for (auto x : g[now]) {
        if (x == fa || !tag[x]) continue;
        dfs (x , now) ;
        dp[now] = max (dp[now] , max (f[x] + f[now] + a[now] + a[x] , max (f[x] , f[now]) + a[x] + a[now]) ) ;
        f[now] = max ( f[x] + a[x] , max (f[now] , a[x]) ) , anstr = max (anstr , dp[now]);
    }
```

然后你就可以通过树的子任务了。

考虑有环的一般情况：我们讨论以下两种：

- 直径不经过环，这个上面讨论过了。

- 经过环，这个接下来说。

那么对于经过环的情况，我们考虑怎么表示它的直径。对于环上两个不同点 $i,j$，我们把路径拆成三段：

- 从 $i$ 的子树最远点到 $i$。

- 从 $i$ 到 $j$。

- 从 $j$ 的子树最远点到 $j$。

写出来大概长这样：

$$
T=\max_{i\ne j}{(f_i+f_j+dis_{i,j})}
$$

其中 $T$ 就是答案。

这个 $dis_{i,j}$ 我们再做一个前缀和，就变成了 $sum_j-sum_{i-1}$。当然路径有两条，记环上点权总和为 $S$，则两条路径权值分别为 $S-(sum_j-sum_{i-1})+a_j+a_i$ 和 $sum_j-sum_{i-1}$。

然后你对于环扫两遍，每次维护一种路径就可以了。

```cpp
# include <bits/stdc++.h>
# define int long long
# define pb push_back
using namespace std;
const int N = 3e5 + 5;
int n , m , a[N] , deg[N] , tag[N] , f[N] , dp[N] , fuck[N] , id[N] , cur , ans = -9e18 , sum[N] , anstr = -9e18;
vector <int> g[N];
vector <int> loop;
void dfs (int now , int fa) {
    f[now] = 0 , dp[now] = a[now] , anstr = max (anstr , dp[now]);
    for (auto x : g[now]) {
        if (x == fa || !tag[x]) continue;
        dfs (x , now) ;
        dp[now] = max (dp[now] , max (f[x] + f[now] + a[now] + a[x] , max (f[x] , f[now]) + a[x] + a[now]) ) ;
        f[now] = max ( f[x] + a[x] , max (f[now] , a[x]) ) , anstr = max (anstr , dp[now]);
    }
    return void();
}
int sol (int x) {
    sum[0] = 0; int tot = 0 , maxx = -9e18 , res = -9e18;
    for (int i = 1;i < loop.size();++i) sum[i] = sum[i - 1] + a[loop[i]];
    tot = sum[(int)loop.size() - 1] ; for (int i = 1;i < loop.size();++i) res = max (res , sum[i] + f[loop[i]] + maxx) , maxx = max (maxx , f[loop[i]] - sum[i - 1]); maxx = -9e18;
    for (int i = 1;i < loop.size();++i) res = max (res , -sum[i] + f[loop[i]] + maxx + a[loop[i]]) , maxx = max (maxx , f[loop[i]] + sum[i - 1] + tot + a[loop[i]]);
    return res;
}
signed main () {
    cin >> n >> m; for (int i = 1;i <= m;++i) { int u , v; cin >> u >> v , g[u].pb (v) , g[v].pb (u) , deg[u] ++ , deg[v] ++ ; }
    for (int i = 1;i <= n;++i) cin >> a[i]; queue <int> q; for (int i = 1;i <= n;++i) if (deg[i] == 1) q.push (i);
    while (!q.empty()) { int now = q.front(); q.pop() , tag[now] = 1; for (auto x : g[now]) if (--deg[x] == 1) q.push (x);  }
    if (m == n - 1) {dfs (1 , 1) ; return cout << anstr << '\n' , 0; }
    for (int i = 1;i <= n;++i) if (!tag[i]) dfs (i , i); loop.pb (0);
    for (int i = 1;i <= n;++i) if (!tag[i]) {while (i) { for (auto x : g[i]) if (!tag[x] && !fuck[x]) {fuck[i] = x; break;} id[i] = ++cur , loop.pb (i) , i = fuck[i]; } break;} 
    cout << max (sol(-1) , anstr) << "\n"; return 0;
}
```

---

## 作者：leo120306 (赞：3)

## 题意简述
给定一颗无根树/基环树，有点权，求点权和最大的简单路径的点权和。

## 分析
1. $m=n-1$

树上求最小点权和路径很简单，树形 dp 一下就好了。

```cpp
void dfs(int u,int fa){
	for(int v:g[u]){
		if(v==fa)continue;
		dfs(v,u);
		ans[u]=max(ans[u],dp[u]+dp[v]);
		dp[u]=max(dp[u],dp[v]+a[u]);
	}
}
```

2. $m=n$

本题最复杂的部分。首先，对于基环树，我们需要得到这个环，搜索一下即可。

```cpp
int vi[N], // 标记
vis[N],viscnt; // 存储正在递归的索引

vector<int>ring; // 存储环上的点编号
int f=0;

void dfs2(int u,int fa){
	if(f)return;
	if(vi[u]){
		int las=viscnt;
		while(vis[viscnt]!=u)
			ring.push_back(vis[viscnt]),viscnt--;
		ring.push_back(u);
		viscnt=las;
		f=1;
		return;
	}
	vi[u]=1;
	vis[++viscnt]=u;
	for (int v:g[u]){
		if(v==fa)continue;
		dfs2(v,u);
	}
	viscnt--;
	vi[u]=0;
}
```

然后考虑基环树直径的形式。以环上每一个结点为根分别拆分子树，不难得出有两种可能：直径是子树的直径，或者是一个子树以根为端点的极长链——环——另一个子树以根为端点的极长链。

对于第一种情况，分别按 $m=n-1$ 的方法求出子树直径，再取最大值。

对于第二种情况，设环上有 $x$ 个结点。不妨先断环为链，环上第 $i$ 个结点的编号为 $r_i\ (1 \le i \le 2x)$，环上结点编号 $r_i$ 的子树以根为端点的极长链长度为 $dp_{r_i}$。我们需要做的就是求环上的这段路径长度。因此作关于环上点权的前缀和，记作 $s_i (1 \le i \le 2x)$。可推出我们需要求：
$$\max\{ s_{i-1} - s_j + dp_{r_i} + dp_{r_j} \} \quad(i-1 \ge j,i-j < cnt)$$
枚举 $i$，单调队列维护 $- s_j + dp_{r_j}$ 即可。

求 $dp$ 时间复杂度 $O(n)$，断环为链+前缀和时间复杂度 $O(n)$，单队时间复杂度 $O(n)$，总复杂度 $O(n)$，可通过。

## 实现
**说句闲话**：记得断环为链数组开两倍。记得开 long long。
```cpp
#include <bits/stdc++.h>
using namespace std;
 
typedef long long ll;
typedef pair<int,int> pii;
#define Mod 1000000007
#define N 200005
#define int ll

int n,m;
int dp[N],ans[N];
vector<int>g[N];
int a[N];
int vi[N],vis[N],viscnt,onring[N],sr[2*N];
vector<int>ring;


void dfs(int u,int fa){
	for(int v:g[u]){
		if(v==fa||onring[v])continue;
		dfs(v,u);
		ans[u]=max(ans[u],dp[u]+dp[v]);
		dp[u]=max(dp[u],dp[v]+a[u]);
	}
}

int f=0;

void dfs2(int u,int fa){
	if(f)return;
	if(vi[u]){
		int las=viscnt;
		while(vis[viscnt]!=u)
			ring.push_back(vis[viscnt]),viscnt--;
		ring.push_back(u);
		viscnt=las;
		f=1;
		return;
	}
	vi[u]=1;
	vis[++viscnt]=u;
	for (int v:g[u]){
		if(v==fa)continue;
		dfs2(v,u);
	}
	viscnt--;
	vi[u]=0;
}

int q[N],tail=0,head=1;

signed main(){
	memset(ans,0xc0,sizeof(ans));
	memset(dp,0xc0,sizeof(ans));
	
	cin>>n>>m;
	for (int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	
	int d=-1e9; 
	for(int i=1;i<=n;i++){
		cin>>a[i];
		dp[i]=a[i];
		d=max(d,a[i]);
	}
	
	if(m==n-1){
		dfs(1,0);
		for(int i=1;i<=n;i++)
			d=max(d,ans[i]);
		cout<<d<<endl;
		return 0; 
	}
	
	dfs2(1,0);
	int cnt=ring.size();
	ring.insert(ring.begin(),0);
	for(int i=1;i<=cnt;i++)
		onring[ring[i]]=i+1,ring.push_back(ring[i]);
	ring.push_back(0);
	for(int i=1;i<=2*cnt;i++){
		sr[i]=sr[i-1]+a[ring[i]];
	}
	for(int i=1;i<=cnt;i++)
		dfs(ring[i],0);
	
	for(int i=1;i<=2*cnt;i++){
		while(head<=tail&&q[head]<=i-cnt)head++;
		if(head<=tail&&i-1>=q[head]){
			d=max(d,sr[i-1]-sr[q[head]] + dp[ring[i]]+dp[ring[q[head]]]);
		}
		while(head<=tail&&dp[ring[q[tail]]]-sr[q[tail]] <= dp[ring[i]]-sr[i])tail--;
		q[++tail]=i;
	}
	
	for(int i=1;i<=n;i++)
		d=max(d,ans[i]);
	
	cout<<d<<endl;
	
	return 0;
}
```

---

## 作者：Adam1101 (赞：2)

### [题目传送门](https://www.luogu.com.cn/problem/P11850)

### 题意简述
给定一棵带有点权树或基环树，求其直径。

### 前置芝士
如果你还不了解**树的直径**和**基环树**，建议你~~换道题~~自行学习。

### 思路
对于 $ m = n - 1 $ 的情况，我们可以随便找一个根节点进行 DFS，把每一条边的边权设为其子节点的点权，再 DP 求树的直径。

注意点权可能有负数，不能用两遍 DFS 求直径。而且要注意加上当前点的点权。
```cpp
void pre_dfs(int x, int fa) {
    for (int i = head[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if (y == fa) continue;
        e[i].w = a[y]; //设置边权
        pre_dfs(y, x);
    }
}

void dfs_zj(int x, int fa) { //DP 求树的直径
    for (int i = head[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        int w = e[i].w;
        if (y == fa || in_cir[y]) continue;
        dfs_zj(y, x);
        int t = D1[y] + w;
        if (t > D1[x]) {
            D2[x] = D1[x];
            D1[x] = t;
        }
        else if (t > D2[x]) {
            D2[x] = t;
        }
    }
    ans = max(ans, D1[x] + D2[x] + a[x]);
}
```
对于 $ n = m $ 的情况，整个图会变成一棵基环树。

我们可以先找到环，再把它当作一个广义根节点，跟树一样进行 DFS 处理出边权。
```cpp
void dfs_cir(int x, int fa) { //找环
    dfn[x] = ++D, fat[x] = fa;
    for (int i = head[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        int w = e[i].w;
        if (y == fa) continue;
        if (dfn[y]) {
            if (dfn[y] < dfn[x]) continue;
            cir[++C] = y;
            in_cir[x] = in_cir[y] = 1;
            for (; y != x; y = fat[y]) {
                cir[++C] = fat[y];
                in_cir[fat[y]] = 1;
            }
            continue;
        }
        dfs_cir(y, x);
    }
}

void pre_dfs(int x, int fa) {
    for (int i = head[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if (y == fa || in_cir[y]) continue; //注意不要搜到环上的节点
        e[i].w = a[y];
        pre_dfs(y, x);
    }
}
```
基环树的直径，显然只有两种情况，要么在一个环上节点的子树内（如下图红色部分），要么“横跨”环的一部分（如下图蓝色部分）。

![](https://cdn.luogu.com.cn/upload/image_hosting/oil6m2f7.png)

对于第一种情况，我们可以直接对环上节点进行 DP（如上文），求出其子树内的直径。

对于第二种情况，首先，不在环上的部分，肯定是该子树内的最长链。

我们先求出这个最长链的长度，记为 $ d_i $，每个点的权值记为 $ a_i $。我们要求的就是：$ \max(d_i + d_j + \sum_i^j{a_i}) $。

$ \sum_i^j{a_i} $ 部分我们可以用前缀和表示，设 $ s_i = \sum_1^i{a_i} $ 则原式就可化为 $ \max(d_i - s_{i - 1} + d_j + s_j) $。我们枚举 $ j $，则只需维护前缀最大 $ d_i - s_{i - 1} $ 即可。

但要注意，这里需要维护的是一个环，所以上面公式的 $ \sum_i^j{a_i} $ 也可以是 $ sum - \sum_i^j{a_i} $，这里 $ sum $ 表示环上所有点的点权之和，所以我们同时要维护一个 $ d_i + s_i $ 的最大值，具体为什么请读者自行思考。
```cpp
int maxn1 = d[1] - s[1], maxn2 = d[1] + s[0];
for (int i = 2; i <= C; i++) {
    ansall = max(ansall, d[i] + s[i - 1] + maxn1); //ansall 表示最终答案
    ansall = max(ansall, d[i] - s[i] + maxn2 + sum);
    maxn1 = max(maxn1, d[i] - s[i]);
    maxn2 = max(maxn2, d[i] + s[i - 1]);
}
```

### 接下来是完整的~~无注释~~代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 2e5 + 10;
struct Edge {
    int to;
    int w;
    int nxt;
}e[N * 2];
int head[N];
int a[N]，D1[N]，D2[N];
int dfn[N], fat[N], cir[N];
int d[N], s[N];
bool in_cir[N];
int ans = -1e9;
int C, D, E;

void add(int x, int y, int z) {
    E++;
    e[E].to = y;
    e[E].w = z;
    e[E].nxt = head[x];
    head[x] = E;
}

void pre_dfs(int x, int fa) {
    for (int i = head[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if (y == fa || in_cir[y]) continue;
        e[i].w = a[y];
        pre_dfs(y, x);
    }
}

void dfs_zj(int x, int fa) {
    for (int i = head[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        int w = e[i].w;
        if (y == fa || in_cir[y]) continue;
        dfs_zj(y, x);
        int t = D1[y] + w;
        if (t > D1[x]) {
            D2[x] = D1[x];
            D1[x] = t;
        }
        else if (t > D2[x]) {
            D2[x] = t;
        }
    }
    ans = max(ans, D1[x] + D2[x] + a[x]);
}

void dfs_cir(int x, int fa) {
    dfn[x] = ++D;
    fat[x] = fa;
    for (int i = head[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        int w = e[i].w;
        if (y == fa) continue;
        if (dfn[y]) {
            if (dfn[y] < dfn[x]) continue;
            cir[++C] = y;
            in_cir[x] = in_cir[y] = 1;
            for (; y != x; y = fat[y]) {
                cir[++C] = fat[y];
                in_cir[fat[y]] = 1;
            }
            continue;
        }
        dfs_cir(y, x);
    }
}

void dfs_dep(int x, int fa, int dep) {
    ans = max(ans, dep);
    for (int i = head[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        int w = e[i].w;
        if (y == fa || in_cir[y]) continue;
        dfs_dep(y, x, dep + a[y]);
    }
}

signed main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m ; i++) {
        int a1, b1;
        cin >> a1 >> b1;
        add(a1, b1, 0);
        add(b1, a1, 0);
    }
    for (int i = 1; i <= n; i++) cin >> a[i];
    if (m == n - 1) {
        pre_dfs(1, 0);
        dfs_zj(1, 0);
        cout << ans << "\n";
        return 0;
    }
    dfs_cir(1, 0);
    int ansall = -1e9;
    for (int i = 1; i <= C; i++) {
        pre_dfs(cir[i], 0);
        ans = -1e9;
        dfs_zj(cir[i], 0);
        ansall = max(ansall, ans);
    }
    int sum = 0;
    for (int i = 1; i <= C; i++) {
        ans = -1e9;
        dfs_dep(cir[i], 0, a[cir[i]]);
        d[i] = ans;
        sum += a[cir[i]];
        s[i] = s[i - 1] + a[cir[i]];
    }
    int maxn1 = d[1] - s[1], maxn2 = d[1] + s[0];
    for (int i = 2; i <= C; i++) {
        ansall = max(ansall, d[i] + s[i - 1] + maxn1);
        ansall = max(ansall, d[i] - s[i] + maxn2 + sum);
        maxn1 = max(maxn1, d[i] - s[i]);
        maxn2 = max(maxn2, d[i] + s[i - 1]);
    }
    cout << ansall << "\n";
    return 0;
}
```
~~你要是直接把这代码交上去，我相信你不会CE。~~

---


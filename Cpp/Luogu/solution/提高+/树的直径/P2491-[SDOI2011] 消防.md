# [SDOI2011] 消防

## 题目描述

某个国家有 $n$ 个城市，这 $n$ 个城市中任意两个都连通且有唯一一条路径，每条连通两个城市的道路的长度为 $z_i$。

这个国家的人对火焰有超越宇宙的热情，所以这个国家最兴旺的行业是消防业。由于政府对国民的热情忍无可忍（大量的消防经费开销）可是却又无可奈何（总统竞选的国民支持率），所以只能想尽方法提高消防能力。

现在这个国家的经费足以在一条边长度和不超过 $s$ 的路径（两端都是城市）上建立消防枢纽，为了尽量提高枢纽的利用率，要求其他所有城市到这条路径的距离的最大值最小。

你受命监管这个项目，你当然需要知道应该把枢纽建立在什么位置上。

## 说明/提示

对于 $20\%$ 的数据，$n \le 300$。

对于 $50\%$ 的数据，$n \le 3 \times 10^3$。

对于 $100\%$ 的数据，$1\le n \le 3 \times 10^5$，$1\le z_i \le 10^3$。

- 注意，数据中存在权值为 $0$ 的边。



------------
2024/1/28 添加一组 hack 数据。

## 样例 #1

### 输入

```
5 2
1 2 5
2 3 2
2 4 4
2 5 3```

### 输出

```
5```

## 样例 #2

### 输入

```
8 6
1 3 2
2 3 2 
3 4 6
4 5 3
4 6 4
4 7 2
7 8 3```

### 输出

```
5```

# 题解

## 作者：dspr (赞：40)

/\*
%20的数据是树网的核，直接O(n^3)，怎么暴力怎么打。

%50的话，我也不知道怎么搞，能想出50，正解应该就很容易想到了。

然后正解的话我们可以想到，需要选的路径的所有边都在直径上是最优的。

因为离树上任意一点最远的点一定是直径的端点，所以我们选择的路径要与直径相交上才会产生最优解，

至于为什么整条路径都在直径上最优，

我们不妨假设现在有一棵树，

将直径上的一个点作为我们要选的路径上的一点，

我们要以这个点为中心扩展出一条路径，

离这个点最远的点一定是直径的端点，当前的最大值就是这个长度。

这时如果我们选的一条边不在直径上，并不会更新这个最大值，

这样即使不能继续在直径上延长，也对答案没有贡献，

于是为了方便处理，我们将整条路径都放在直径上，

但是这些不在直径上的路径的长度不能忽略，需要进行处理，

想通了这些，这道题就很简单了。

首先我们先用两遍bfs求出直径的两个端点，再把整条直径找出来，时间复杂度O(N)

然后对于每个直径上的点我们做一次dfs，求出不经过直径的以这个点源的路径的最大长度，一起取一个最大值，作为答案的最小值，这个步骤看上去是O(N^2)，而实际上我们对于整棵树上的每一个点只会跑一次，于是时间复杂度为O(N)。

最后我们再以之前求得的最大值为左端点，直径的长度为右端点，二分答案，就可以很轻松的得出结果了。

下面是代码，写的有点丑

\*/
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+20;
int a[N],to[N*2],nex[N*2],w[N*2],b[N],c[N];
int ll,rr,l,r;
int bfs(int x)
{
    memset(c,0,sizeof(c));//两遍bfs求出直径的两个端点
    b[1]=x;
    int head=0,tail=1;
    int ans,s=0;
    while(head!=tail)
    {
        head++;
        for(int i=a[b[head]];i;i=nex[i])
        {
            if(!c[to[i]]&&to[i]!=x)
            {
                int y=to[i];
                tail++;
                c[y]=c[b[head]]+w[i];
                b[tail]=y;
                if(c[y]>s)
                {
                    s=c[y];
                    ans=y;
                }
            }
        }
    }
    return ans;
}
void dfs(int s1,int s2,int x,int t)//对于每个直径上的点dfs一次，求不经过直径的路径最大长度
{
    l=max(l,t);
    for(int i=a[x];i;i=nex[i])
    {
        if(to[i]!=s1&&to[i]!=s2)
        {
           dfs(x,x,to[i],t+w[i]);
        }
    }
}
void _dfs(int fa,int x,int y,int t,int s)//找出直径并对直径路径长度维护一个前缀和，方便以后处理。
{
    if(x==y)
    {
        b[0]=t;
        b[t]=s;
        r=s;
        return;
    }
    for(int i=a[x];i;i=nex[i])
    {
        if(fa!=to[i])
        {
            _dfs(x,to[i],y,t+1,s+w[i]);
            if(b[0])
            {
                b[t]=s;
                dfs(fa,to[i],x,0);
                return;
            }
        }
    }
}
bool pd(int t,int s)//判断答案是否可行。因为答案的左端点就是不经过直径的最大路径长，所以只需再直径上验证即可。
{
    int i,j;
    for(i=1;i<=b[0];++i)
    {
        if(b[i]>t)
        break;
    }
    i--;
    for(j=i;j<=b[0];++j)
    {
        if(b[j]-b[i]>s)
        break;
    }
    j--;
    return b[b[0]]-b[j]<=t;
}
int main()
{
    int n,s;
    scanf("%d%d",&n,&s);
    for(int i=1,t=0;i<n;++i)
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);//存边
        nex[++t]=a[x];
        to[t]=y;
        w[t]=z;
        a[x]=t;
        nex[++t]=a[y];
        to[t]=x;
        w[t]=z;
        a[y]=t;
    }
    ll=bfs(1);
    rr=bfs(ll);
    _dfs(0,ll,rr,1,0);
    while(l!=r)//二分答案
    {
        int mid=(l+r)>>1;
        if(pd(mid,s))r=mid;
        else　l=mid+1;
    }
    cout<<l;
    return 0;
}
```

---

## 作者：灵乌路空 (赞：33)


## 知识点 : 树的直径, 单调队列 

### [原题面](https://www.luogu.org/problem/P2491)

[P1099 树网的核](https://www.luogu.org/problem/P1099) 的 数据加强版 


### 题目要求 : 

>给定一棵树 ,  边有边权  
>求一条 **边长度和 $\le s$ 的路径** ,   
>使其他所有点 到这条路径的距离的 最大值最小 . 

### 分析题意 :   

- 对于树的直径 , 有一 性质 :     
  对于 任意树上的节点 ,  距离其最远的点 一定为树的直径的端点  
  - 证明 : 详见此篇博客 : [树的直径 - Luckyblock - 博客园](https://www.cnblogs.com/luckyblock/p/11686641.html)  
	
  - 则可 先求得树的直径, 并记录树的直径上的点   
  	由于要记录路径 , 使用 $\text{DFS}$ 处理较为容易   
  	之后就可以 枚举树的直径上 长度 $\le s$ 的合法区间    

- 对于每一个 合法区间  ,    
  如何求得 其他所有点 到这条路径的距离的最大值 ?   
  对路径外的点 进行分类讨论 :   
  
  1. 对于在直径上的点 ,    
  	 显然, 直径的端点 距离此区间的端点的距离, 比非端点远   
	
	 则只需考虑 直径两端点 到达区间对应两端点的 距离    
     可以对 直径上的点使用前缀和 维护到达两端点的距离 , 来做到 $O(1)$ 查询 
	
  2. 对于在直径外的点 ,  
  	 显然, 当直径上 与其距离最近的点 在区间内时 , 才有可能 做出贡献   
	 否则 选择直径的端点 必然比选择它更优   
	
	  则可以维护 **从各直径点 , 不经过直径其他点, 能到达的点的 最远距离**   
	
  
-  在枚举区间时 需要维护 **距选择路径上的点 最远的 直径外的点**      
   显然这是一个滑动窗口最值问题 , 可以使用单调队列维护   

### 算法实现 :

1. 先使用 $\text{DFS}$ 求得直径上的点      
   可以通过 求得两端点, 然后记录直径上每一个点的前驱, 来记录路径

2. 使用 $\text{BFS}$ 求得 **从各直径点 , 不经过直径其他点, 能到达的点的 最远距离**  
   - 先将直径上的点 加入队列, 然后向外进行扩展   
   - 由于树上两点之间 只有一条简单路径 ,    
     则按照上述规则进行扩展, 扩展到的最远的点, 一定为 **从此点, 不经过直径其他点, 能到达的点的 最远距离**

3. 使用单调队列, 枚举每一个合法区间, 并取得最优解
    - 固定左端点, 找到合法的右端点 ,  
	  并维护 队列中的 **距选择路径上的点 最远的 直径外的点**  
	
	- 将队首元素 与 该区间端点与直径端点的距离 进行比较, 最大值即该合法区间的 答案    
	  取最小的 合法区间答案 作为最终答案
	
	- 区间左端点 右移

---

附代码 :

```cpp
#include <cstdio>
#include <cstring>
#include <ctype.h>
#include <queue>
#define int long long
#define max(a, b) (a > b ? a : b)
#define min(a, b) (a < b ? a : b)
const int INF = 1e15 + 7;
const int MARX = 3e5 + 10;
//=============================================================
struct edge
{
	int u, v, w, ne;
}e[MARX << 1];
int n, num, s, u, v, head[MARX];//建图变量
int dis[MARX], pre[MARX], map[MARX];//求树的直径, dis记录距离,  pre记录直径上点的前驱, map存直径上两相邻点的距离  
int ans = 1e15, sum[MARX], dis1[MARX];//sum记录直径上距离的前缀和, dis1记录直径上点i到 直径外点的最长距离 
int que[MARX] = {INF}, t = 0, h = 0;//单调队列- 
//=============================================================
inline int read()
{
    int s = 1, w = 0; char ch = getchar();
    for(; ! isdigit(ch); ch = getchar()) if(ch == '-') s  = -1;
    for(; isdigit(ch); ch = getchar()) w = w * 10 + ch - '0';
    return s * w;
}
void add(int u, int v, int w)
{
	e[++ num].u = u, e[num].v = v, e[num].w = w;
	e[num].ne = head[u], head[u] = num;
}
void dfs(int now, int fat, int sum, bool flag)//dfs求得 树的直径 
{
	if(flag) pre[now] = fat, map[now] = sum;//第二次dfs记录路径 (前驱 
	dis[now] = dis[fat] + sum;//更新距离 
	for(int i = head[now]; i; i = e[i].ne)
	  if(e[i].v != fat) dfs(e[i].v, now, e[i].w, flag);
}
void get_road()//求得 树的直径 
{
	dfs(1, 0, 0ll, 0); //一次dfs 
	for(int i = 1, maxdis = 0; i <= n; i ++)//选择 距离最远的点 
	  if(dis[i] > maxdis) u = i, maxdis = dis[i];
	dfs(u, 0, 0ll, 1); //二次dfs 
	for(int i = 1, maxdis = 0; i <= n; i ++)//选择 距离最远的点 
	  if(dis[i] > maxdis) v = i, maxdis = dis[i];
}
void bfs()//bfs处理 以每个直径上的点为起点, 不经过直径上其他点, 能到达的点的 最远距离
{
	memset(dis, 63, sizeof(dis));
	std :: queue <int> q, from;
	for(int i = v; i != 0; i = pre[i]) //将直径上的点加入 队列 
	  q.push(i), from.push(i), dis[i] = 0;
	  
	for(; !q.empty();)
	{
	  int now = q.front(), fr = from.front(); q.pop(), from.pop();
	  for(int i = head[now]; i ; i = e[i].ne)//枚举出边 
	    if(dis[e[i].v] >= INF)//未被更新过 
	    {
	      dis[e[i].v] = dis[now] + e[i].w;//更新最远距离 
	      dis1[fr] = max(dis1[fr], dis[e[i].v]);
		  q.push(e[i].v), from.push(fr);
		}
	}
}
void solve()
{
	pre[n + 1] = v;
	for(int i = n + 1; i != 0; i = pre[i]) //预处理前缀和 
	  sum[pre[i]] = sum[i] + map[i];
	
	for(int l = v, r = v; l != 0 && r != u; l = pre[l])//当r=u时停止枚举,之后枚举的区间都不合法 
	{
	  int last = r; ++ h;
	  while(sum[r] - sum[l] <= s && r != 0) //枚举右端点 
	  {
	  	last = r, r = pre[r];
	  	if(r != 0 && sum[r] - sum[l] <= s)//单调队列更新 
	  	{
	  	  for(;dis1[r] >= que[t] && t >= h;) t--;
	  	  que[++ t] = dis1[r];	
		}
	  }
	  if(r == 0 || sum[r] - sum[l] > s) r = last;//越界处理 
	  
	  int now = max(sum[l] , sum[u] - sum[r]);//更新答案 
	  now = max(now, que[h]);
	  ans = min(now, ans);
	}
}
//=============================================================
signed main()
{
	n = read(), s = read();
	for(int i = 1; i < n ;i ++)
	{
	  int u1 = read(), v1 = read(), w1 = read();
	  add(u1, v1, w1), add(v1, u1, w1);
	}
	get_road(); bfs(); solve();
	printf("%lld", ans);
}
```

---

## 作者：wucstdio (赞：26)

表示并没有想到最优解一定在树的直径上。

首先考虑二分，二分完后问题转化为，能否选出一条长度$\le s$的路径，使得剩下的点到这条路径的距离不超过$x$？

考虑用DP来求解这个问题。令$f[i]$表示在$i$的子树中选出一条链，其中一个端点是$i$的最短路径长度，$g[i]$表示在$i$的子树中选出一条链，这条链的LCA是$i$的最短路径长度。

那么怎么转移呢？考虑下面这种情况：

![](https://cdn.luogu.com.cn/upload/pic/60601.png)

我们设$maxd[i]$表示$i$的子树内部最深的点的深度。

1、如果$maxd[node]-dep[node]\le x\&maxd[to]-dep[node]\le x$，那么$f[node]=0$。

2、否则，如果$maxd[node]-dep[node]\le x$，那么$f[node]=f[to]+w(node,to)$。

3、否则，如果$maxd[to]-dep[node]\le x$，那么$f[node]$不变。

4、否则，$f[node]=\inf$，这时如果$g[node]$还没有被更新，那么$g[node]=f[node]+f[to]+w(node,to)$，否则$g[node]=\inf$。

至于统计答案，我们可以在到达每一个节点时，统计这个节点上方的所有点到它的最长距离是否$\le x$，如果是就用$g[node]$更新答案。

最后还有一点问题，这道题的数据范围是300000，这么写实现不好的话可能会T（极限数据1.9s），常数优化技巧如下：

1、先把节点按照dfn排序，这样二分完后就不用dfs了，递归转迭代。（优化至1.1s）

2、二分上界可以设到树的直径而不是$10^9$。（优化至0.7s）

然后就可以开开心心的AC了。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
struct Edge
{
	int to;
	int nxt;
	int len;
}e[600005];
int n,m,edgenum,head[300005],pa[300005],dep[300005],maxd[300005],f[300005],g[300005];
int up[300005],max1[300005],max2[300005],ans,p[300005],maxx;
void add(int u,int v,int l)
{
	e[++edgenum].len=l;
	e[edgenum].to=v;
	e[edgenum].nxt=head[u];
	head[u]=edgenum;
}
int ind;
void dfs1(int node)
{
	max1[node]=max2[node]=0;
	p[++ind]=node;
	for(int hd=head[node];hd;hd=e[hd].nxt)
	{
		int to=e[hd].to;
		if(to==pa[node])continue;
		dep[to]=dep[node]+e[hd].len;
		pa[to]=node;
		dfs1(to);
		if(max1[to]+e[hd].len>max1[node])
		{
			max2[node]=max1[node];
			max1[node]=max1[to]+e[hd].len;
		}
		else if(max1[to]+e[hd].len>max2[node])
			max2[node]=max1[to]+e[hd].len;
	}
	maxx=max(maxx,max1[node]+max2[node]);
}
void dfs2(int node)
{
	for(int hd=head[node];hd;hd=e[hd].nxt)
	{
		int to=e[hd].to;
		if(to==pa[node])continue;
		up[to]=up[node]+e[hd].len;
		if(max1[to]+e[hd].len==max1[node])
		  up[to]=max(up[to],max2[node]+e[hd].len);
		else up[to]=max(up[to],max1[node]+e[hd].len);
		dfs2(to);
	}
}
bool check(int x)
{
	ans=1000000000;
	for(int i=n;i>=1;i--)
	{
		int node=p[i];
		maxd[node]=dep[node];
		f[node]=g[node]=0;
		for(int hd=head[node];hd;hd=e[hd].nxt)
		{
			int to=e[hd].to;
			if(to==pa[node])continue;
			if(maxd[node]-dep[node]<=x&&maxd[to]-dep[node]<=x)f[node]=0;
			else if(maxd[node]-dep[node]<=x)f[node]=f[to]+e[hd].len;
			else if(maxd[to]-dep[node]<=x);
			else
			{
				if(g[node]==0)g[node]=f[node]+f[to]+e[hd].len;
				else g[node]=1000000000;
				f[node]=1000000000;
			}
			maxd[node]=max(maxd[node],maxd[to]);
		}
		if(maxd[node]-dep[node]<=x)f[node]=0;
		if(g[node]==0)g[node]=f[node];
		if(up[node]<=x)ans=min(ans,g[node]);
	}
	return ans<=m;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++)
	{
		int u,v,l;
		scanf("%d%d%d",&u,&v,&l);
		add(u,v,l);
		add(v,u,l);
	}
	dfs1(1);
	dfs2(1);
	int l=0,r=maxx;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(check(mid))r=mid-1;
		else l=mid+1;
	}
	printf("%d\n",l);
	return 0;
}
```

---

## 作者：Demoe (赞：23)

### [题目传送门](https://www.luogu.com.cn/problem/P2491)

## 前置知识

树的直径、尺取法（蠕动区间）。

## 简述题意

在树上找一点使其他所有点到他**距离最长**的**最小值**，求这个最小值。

## 简述算法

1. 求出树的直径。

2. 通过尺取，求出满足 $s$ 要求的 $i$,$j$，并求出直径上 $i$，$j$ 到两端的距离的**最大值**。

3. 标记直径上的点。

4. 求出其它点到直径上点的距离。

5. 所有点的距离的最大值即为答案。

## 具体阐述

首先很容易发现，枢纽一定在树的**直径**上（若有多条任选一条不影响）。

我们可以先用两次 dfs 求出直径。

```cpp
void dfs(ll x,ll ff){
	fa[x]=ff;
	if(dis[x]>dis[k]) k=x;
	for(ll i=hd[x];i;i=es[i].nxt){
		ll to=es[i].t;
		if(to==ff||line[to]) continue;
		dis[to]=dis[x]+es[i].va;
		dfs(to,x);
	}
}
```

我们先处理这条直径。

采用**尺取法（蠕动区间）**，我们可以计算出在所有满足条件的最优情况下，最大值的最小值（有点绕）。

### 具体操作

从一端开始，每次 $i$ 向另一端移动一次。

我们另从这一端取一个 $j$。

每次只要 $dis_{i,j}>s$，我们就让 $j$ 移动。

我们用 $j$ 到**出发点**的距离和 $i$ 到**结束点**的距离不断更新答案。

```cpp
	for(ll i=top,j=top;i;i=fa[i]){
		while(dis[j]-dis[i]>s) j=fa[j];
		ans=min(ans,max(dis[i],dis[top]-dis[j]));
	}
```

然后其实还有可能最远距离在**直径以外**的点上。

我们就对直径上每个点进行搜索。

每次标记好，**不重复**搜索。

最后更新答案。

```cpp
	for(ll i=top;i;i=fa[i]) line[i]=1;
	for(ll i=top;i;i=fa[i]){
		k=i;dis[k]=0;
		dfs(i,fa[i]);
	}
	for(ll i=1;i<=n;i++) ans=max(ans,dis[i]);
```

## 时间复杂度

每个环节都是 $O(n)$ 的，总复杂度 $O(n)$。

## 上代码

```cpp
/*
***
还要继续努力
成为一名烤咕学家哦
***
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e6+5;
ll n,s,tot,hd[N],cnt,dis[N],ans=9999999999,top,k,fa[N],line[N];
struct edge{ll t,nxt,va;}es[N<<2];
template <typename T> void rd(T &x){
	ll fl=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') fl=-fl;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x*=fl;
}
void wr(ll x){
	if(x<0) x=-x,putchar('-');
	if(x<10) putchar(x+'0');
	if(x>9) wr(x/10),putchar(x%10+'0');
}
void add(ll u,ll v,ll w){
    es[++tot]=(edge){v,hd[u],w},hd[u]=tot;
}
void dfs(ll x,ll ff){
	fa[x]=ff;
	if(dis[x]>dis[k]) k=x;
	for(ll i=hd[x];i;i=es[i].nxt){
		ll to=es[i].t;
		if(to==ff||line[to]) continue;
		dis[to]=dis[x]+es[i].va;
		dfs(to,x);
	}
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	rd(n);rd(s);
	for(ll i=1,u,v,w;i<n;i++){
		rd(u);rd(v);rd(w);
		add(u,v,w);add(v,u,w);
	}
	dis[1]=1;dfs(1,0);
	dis[k]=0;dfs(k,0);
	top=k;
	for(ll i=top,j=top;i;i=fa[i]){
		while(dis[j]-dis[i]>s) j=fa[j];
		ans=min(ans,max(dis[i],dis[top]-dis[j]));
	}
	for(ll i=top;i;i=fa[i]) line[i]=1;
	for(ll i=top;i;i=fa[i]){
		k=i;dis[k]=0;
		dfs(i,fa[i]);
	}
	for(ll i=1;i<=n;i++) ans=max(ans,dis[i]);
	wr(ans);puts("");
	return 0;
}
```

---

## 作者：破壁人 (赞：12)

显然可以发现这条路径必然在树的直径上

至于证明，只需要假设路径Q不在直径上，那么假设距离最远的点不在直径上，易证不可能，因此距离这条路径Q最远的点一定在直径上。

之后再假设一个A点是不在直径上的一个点，我们假设直径上有一条路径P，如果A到P的距离大于了直径的端点到Q的距离，显然是矛盾的，因此任意的A点到P的距离一定小于直径端点到Q的距离，因此得证。

所以我们先dfs求出树的直径，从直径的端点开始单调的移动两个指针，保证两个指针的距离是不大于s得最大值，（这样的路径在左指针固定的情况下肯定是最优的），两个指针之间的路径就是候选路径。

对树的直径维护一个前缀和。

ls表示左指针到直径端点的距离。

rs表示右指针到直径端点的距离。

h表示左右指针之间的点可以扩展到的最远距离。

这三个量都是可以进行单调性维护的。

对于每一条候选路径，其他所有城市到这条路径的距离的最大值=max(ls,rs,h);

不断移动左右指针就可以得出最终答案。







```cpp
#include<iostream>
#include<vector>
#include<cstring>
using namespace std;
vector<int> a[300001],b[300001];
int last[300001],op,u,vv,dis[300001];
int l,r,s1,s2[300001][1],s3,l1,r1;
bool v[300001],vs[300001];
void dfs1(int o,int p,int q)
{
    if(p>op){op=p;u=o;}
    for(int i=0;i<a[o].size();i++)
        if((!v[a[o][i]])&&(a[o][i]!=q))
        {
            v[a[o][i]]=true;
            dfs1(a[o][i],p+b[o][i],o);
        }
}
void dfs2(int o,int p,int q)
{
    last[o]=q;
    dis[o]=p;
    if(p>op){op=p;vv=o;}
    for(int i=0;i<a[o].size();i++)
        if((!v[a[o][i]])&&(a[o][i]!=q))
        {
            v[a[o][i]]=true;
            dfs2(a[o][i],p+b[o][i],o);
        }
}
int main()
{
    int n,s;
    cin>>n>>s;
    for(int i=1;i<n;i++)
    {
        int x,y,z;
        cin>>x>>y>>z;
        a[x].push_back(y);
        b[x].push_back(z);
        a[y].push_back(x);
        b[y].push_back(z);
    }
    memset(v,0,sizeof(v));
    op=0;
    dfs1(1,0,0);
    op=0;
    memset(v,0,sizeof(v));
    memset(last,0,sizeof(last));
    dfs2(u,0,0);
    memset(v,0,sizeof(v));
    for(int i=vv;last[i]!=0;i=last[i]) v[i]=true;
    l=vv;l1=r1=s1=0;
    int ans=1000000000;
    memset(vs,0,sizeof(vs));
    for(int i=vv;last[i]!=0;i=last[i])
    {
        while((dis[l]-dis[i]>s)&&(l!=i))
        {
            vs[l]=true;
            s1+=dis[l]-dis[last[l]];
            if(vs[s2[l1][1]]==true) l1++;
            l=last[l];
        }
        op=0;
        dfs1(i,0,0);
        int yu=op;
        while((s2[r1][0]<yu)&&(r1>=l1)) r1--;
        r1++;
        s2[r1][0]=yu;
        s2[r1][1]=i;
        ans=min(ans,max(max(s2[l1][0],s1),dis[i]));
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Frozen_Heart (赞：10)

貌似自己的思路和别人的不太一样啊？？？
本来只打算拿50%的数据的，结果A？！

感觉自己的方法比较容易理解，但是跑得比其他的巨佬还是慢些。

这道题先求出树的直径，然后我们从底部开始往上枚举，很显然的一个贪心：**固定了一个端点之后，另一端点越远越好**。

所以我们直接枚举端点，找到它的另一端。
这时候我通过LCA$O(1)$来计算距离，就可以把此情况的最大距离用$O(n)$处理得到。

加上前面的贪心思想，就愉快地AC了？？？
欢迎踩博客[Frozen_Heart](https://www.cnblogs.com/lsgjcya/p/9236210.html)
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
int read()
{
    int x=0,w=1;char ch=getchar();
    while(ch>'9'||ch<'0') {if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*w;
}
int n,s,x,y,z,root,t,l,r,cnt,ans=2000000000,sum;
int head[300010],dis[300010],f[300010][20],deep[300010],vis[300010];
struct node{
    int to,next,v;
}edge[600010];
void add(int x,int y,int z)
{
    cnt++;
    edge[cnt].to=y;
    edge[cnt].next=head[x];
    edge[cnt].v=z;
    head[x]=cnt;
}
int LCA(int x,int y)
{
    if(deep[x]<deep[y]) swap(x,y);
    for(int i=19;i>=0;i--)
    {
        if(deep[f[x][i]]>=deep[y]) x=f[x][i];
    }
    if(x==y) return x;
    for(int i=19;i>=0;i--)
    {
        if(f[x][i]!=f[y][i])
            x=f[x][i],y=f[y][i];
    }
    return f[x][0];
}
void init()
{
    for(int i=1;i<=9;i++)
    {
        for(int j=1;j<=n;j++)
        {
            f[j][i]=f[f[j][i-1]][i-1];
        }
    }
}
void dfs1(int k,int fa)
{
    for(int i=head[k];i;i=edge[i].next)
    {
        int v=edge[i].to;
        if(v==fa) continue;
        dis[v]=dis[k]+edge[i].v;
        dfs1(v,k);
    }
}
void dfs2(int k,int fa)
{
    for(int i=head[k];i;i=edge[i].next)
    {
        int v=edge[i].to;
        if(v==fa) continue;
        dis[v]=dis[k]+edge[i].v;f[v][0]=k;deep[v]=deep[k]+1;
        dfs2(v,k);
    }
}
int main()
{
    n=read();s=read();
    for(int i=1;i<n;i++)
    {
        x=read();y=read();z=read();
        add(x,y,z);add(y,x,z);
    }
    dfs1(1,0);
    for(int i=1;i<=n;i++)
    {
        if(!root||dis[i]>dis[root]) root=i;
    }
    memset(dis,0,sizeof(dis));
    deep[root]=1;dfs2(root,0);
    for(int i=1;i<=n;i++)
    {
        if(!t||dis[i]>dis[t]) t=i;
    }
    init();
    l=t;r=t;vis[t]=1;
    while(l!=0)
    {
        sum=0;
        if(dis[r]-dis[l]>s)
        {
            vis[r]=0;r=f[r][0];vis[r]=1;
        }
        else
        {
            while(dis[r]-dis[l]<=s&&l!=0) {l=f[l][0];vis[l]=1;}
            int rlca;
            for(int i=1;i<=n;i++)
            {
                if(vis[i]) continue;
                int lca1=LCA(l,i),lca2=LCA(r,i);
                if(deep[lca1]>deep[lca2]) rlca=lca1;
                else rlca=lca2;
                if(deep[rlca]<deep[l])
                {
                    sum=max(sum,dis[l]+dis[i]-2*dis[rlca]);
                }
                else sum=max(sum,dis[i]-dis[rlca]);
            }
            ans=min(ans,sum);
            l=f[l][0];vis[l]=1;
        }
    }
    cout<<ans;
}
```

---

## 作者：zhoubaobao (赞：7)


明显可知这条路径在直径上是最优
所以先dfs两次找出树的直径

### 方法：
先随机找一个点搜出离他最远的一个点，这就是直径的一个端点。
再从这个点搜，找离他最远的一个点，这就是另一个端点。
这里我就不证明了。

看代码：
```cpp
void dfs(int x,int fa,int p)
{
	for(int i=head[x];i;i=to[i])
	{
		if(y[i]==fa)continue;
		if(vis[y[i]]==1)continue;
		if(p==1)pre[y[i]]=x;
		dis[y[i]]=dis[x]+w[i];
		dfs(y[i],x,p);
	}
}
```

```cpp
dfs(1,0,0);
	for(i=1;i<=n;i++)
	{
		if(maxx<dis[i])
		{
			k=i;
			maxx=dis[i];
		}
	}
	maxx=0;
	dis[k]=0;
	dfs(k,0,1);
```
### O（n）
我们可以很轻松的在搜索时标出直径上的点都有谁

再看代码：
```cpp
memset(dis,0,sizeof(dis));
    dis[p]=0;
    vis[p]=1;
    while(p!=k)
    {
    	for(int i=head[p];i;i=to[i])
    	{
    		if(y[i]==pre[p])
    		{
    			dis[y[i]]=dis[p]+w[i];
    			vis[y[i]]=1;
    			break;
			}
		}
		p=pre[p];
	}
```
### O（n）

然后可以算出直径上每个符合的路径到直径两端点的最大距离。
```cpp
int find(int x,int m)
{
    for(int i=head[x];i;i=to[i])
    {
        if(y[i]==pre[x]&&m>=w[i])
        {
            return find(y[i],m-w[i]);
        }
    }
    return x;
}
int work(int x,int m) 
{
    int t1=dis[x],t=find(x,m);
    int t2=dis[k]-dis[t];
    return max(t1,t2);
}
```
### O（n）
最后再来一个搜索，搜出非直径上的点到直径上的距离最小值。

这样每个部分的复杂度都是O(n).
就可以开心的AC了。


---

## 作者：1000001001wj (赞：6)

#本题解仅用于抛蒟蒻引大佬

由于我太弱（懒）了，所以没有代码，并且可能错。。。。

如果错了还请大佬指出

这道题基本分为几步：

1. 找到直径

2. 找到直径中点并加入已选队列（如果在边上则两边的点都选）

3. 贪心（二分）

接下来详解

1：
随意找个点，bfs找距离最远的那个点，这个点肯定是直径中的一点，再从这个点bfs一边就找到另一个点，原因可以百度，这里就不安利了

2：
找直径时记录下每个点的前一个节点，然后再退回来，用bool数组记录是不是（有用），在上一步时已经拿到了直径长，所以在找的时候判一下就有中点了，如果贪心用优先队列存

3：
这里只说贪心，二分应该都会（其实是我不会）先从中点dfs一边，在直径上的点记录到较近的直径端点的距离，其他点记录dfs路径上后到达且未回头的叶节点到该点的距离最大值（大概就是朝离直径越来越远的那边一路走到头的那个点），开一个变量记录当前路长或剩余可用路长（应该都知道吧？）再开一个bool数组记录是否已选（或者利用上步的数组记录到中点的前置节点），每次取队头，看看和之前那个点之间的路程+已用的是不是已超最大值，如果是就输出当前节点记录的到叶节点的最大路程（见上面，懒的打全了。。。）否则将相邻未选节点加入优先队列中，最后判一下优先队列是不是空了，如果空了都知道怎么办吧233


---

## 作者：良月澪二 (赞：4)

别的题解怎么都那么麻烦

用不着二分，直接贪心取就可以

听说必须要取树的直径上的路径

先$dfs$预处理出树的直径

然后每次在树的直径上取不超过s的路径

更新答案

最后求出不在直径上的点到所选路径的最大距离（很显然）

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <complex>
#include <algorithm>
#include <climits>
#include <queue>
#include <map>
#include <set>
#include <vector>
#include <iomanip>
#define A 1000010
#define B 2010

using namespace std;
typedef long long ll;
struct node {
	int next, to, dis;
}edge[A];
int head[A], num_edge;
void add_edge(int from, int to, int dis) {
	edge[++num_edge].next = head[from];
	edge[num_edge].to = to;
	edge[num_edge].dis = dis;
	head[from] = num_edge;
}
int dis[A], vis[A], n, s, a, b, c, st = 1, en, fa[A], ans = INT_MAX;
void dfs(int fr) {
	for (int i = head[fr]; i; i = edge[i].next) {
		int ca = edge[i].to;
		if (ca == fa[fr] or vis[ca]) continue;
		fa[ca] = fr;
		dis[ca] = dis[fr] + edge[i].dis;
		dfs(ca);
	}
}

int main(int argc, char const *argv[]) {
	scanf("%d%d", &n, &s);
	for (int i = 1; i < n; i++) {
		scanf("%d%d%d", &a, &b, &c);
		add_edge(a, b, c);
		add_edge(b, a, c);
	}
    /******************树的直径*******************/
	dfs(st);
	for (int i = 1; i <= n; i++)
		if (dis[i] > dis[st])
			st = i;
	memset(fa, 0, sizeof fa), dis[st] = 0; dfs(st);
	for (int i = 1; i <= n; i++)
		if (dis[i] > dis[en])
			en = i;
	int tmp = en;
    /**********************************************/
	for (int i = en; i; i = fa[i]) { //不断取<=s的路径
		while (fa[tmp] and dis[i] - dis[fa[tmp]] <= s) tmp = fa[tmp];
		ans = min(ans, max(dis[tmp], dis[en] - dis[i]));
	}
    //不在直径上的点到所选路径的最大距离
	for (int i = en; i; i = fa[i]) vis[i] = 1;
	for (int i = en; i; i = fa[i]) dis[i] = 0, dfs(i);
	for (int i = 1; i <= n; i++)
		if (!vis[i])
			ans = max(ans, dis[i]);
	printf("%d\n", ans);
}
```

---

## 作者：the_Death (赞：3)

###### 大家都好强啊QAQ，这次题解大多看了lyd的书


------------------

### P1099 && P2491 题解

 [Luogu树网的核](https://www.luogu.org/problem/P1099) && [Luogu消防](https://www.luogu.org/problem/P2491)

前排安利博客,[LuitaryiJack](https://www.cnblogs.com/Jackpei/) && [Chrisk](https://www.cnblogs.com/ChrisKKK/) && [喵の耳](https://www.cnblogs.com/gengyf/)

[更好的阅读体验](https://www.cnblogs.com/fallen-down/p/11631117.html)

~~这次是真的更好的阅读体验~~


------------------



### 简化题意

~~emmmmmm,似乎没有办法简化题意(雾)~~
一个无环联通无向图，定义直径上一段长度不超过${S}$的路为${F}$(也可以是一个点)，定义图中到${F}$的距离最长的为偏心距。求一个${F}$，使得图上到${F}$的距离最大值最小，并输出这个距离

### 分析~~是抄LYD+自己理解的~~
#### 初步结论：
1. 树的各个直径中点都交于一点

     -   证明([@LuitaryiJack](https://www.cnblogs.com/Jackpei/))：如果两条直径没有交于一点，那么就代表你可以构造一条直径，长为原直径的长加上两个中点之间的距离，此时原直径就不符合直径的定义。所以树的各个直径中点都交于一点
2. 任意一条直径上求出的最小偏心距都相等

    - 证明：由结论${1}$可知，所有的直径都交于一点。所以其他的点到这些直径的距离就可以化为到中点的距离。又因为中点都相交于一点。所以我们可以知道任意一条直径上求出的偏心距都是相等的。
#### 初步做法
1. O(${N^{3}}$)
   
   在树网的核这道题上，由于图的点数过少，所以我们可以用O(${N^{3}}$)的方法水过这道题。即暴力枚举：先求出树的直径，再在上面枚举F，然后在${F}$上每一个点用${dfs}$求图上到${F}$的最远的点的距离，再取最小值即可

2. O(${N^{2}}$)
   
   然后考虑对枚举暴力进行优化。由于贪心可知，如果每次${F}$的选取越长，~~通过感性理解~~我们求的的偏心距就越小。所以我们每次定${F}$长为${S}$，然后枚举${dfs}$求偏心距

#### 二级结论
- 这题满足单调的性质：偏心距越大，可以得到的点的位置越集中，使得由这些点构成的${F}$越短，即${S}$越小

   - 证明：~~QAQ感觉性质就是证明啊~~在二分${mid}$作为偏心距的大前提下，我们首先定义一些东西：

      1. 直径两个端点为${q}$和${v}$
      2. 在直径上，离${q}$最长的不超过${mid}$的点为${p}$，同理，${u}$是相对${v}$而言的那个点
   
   - 根据直径的最长性，任何从${p}$和${q}$之间的直径中分叉离开的子树，其离${p}$最远的距离不会超过${mid}$。
   - 所以${p}$和${u}$就是在偏心距不超过${mid}$的前提下，尽量靠近${F}$的点
  
#### 二级做法~~什么鬼标题~~

- O(${NlogSUM}$)，sum为树网中所有边的长度之和
  
  二分${mid}$，然后按照上面的结论证明找${p}$和${u}$，然后判断他们之间的距离是否超过${S}$，以及离${F}$最远的的点到这俩点的距离是否合法。若两者都满足，那么代表这是合法的

#### 最终的做法

- O(${N}$)
    
    设直径上的节点为${u_{1},u_{2}.....u_{t}}$，那么先和前几种做法一样，把这些节点标记为已经访问，然后用深度优先遍历求${d[u_{i}]}$，含义为从${u_{i}}$出发，不经过直径上的点，可以到达的最远距离。显然，偏心距要么就是由结论${2}$得到的直径两端点到${F}$的距离的较大值，要么就是直径外到${F}$的最大的距离。所以，首先枚举${F}$的两个端点取${max}$。最后由于最后要用${F}$完全遍历一遍直径，所以我们取${max(d[u_{i}])}$。然后扫一边直径即可求解

------------------

### *code*

我选取了我们机房大佬们的${code}$给大家做参考。要是有侵权，emmmmm，那就侵权吧~~手动滑稽~~

1 O(${N^{3}}$) [@喵の耳](https://www.cnblogs.com/gengyf/)
```cpp
#include <bits/stdc++.h>
using namespace std;
namespace gengyf{
    inline int read(){
        int x=0,f=1;char s=getchar();
        while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
        while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
        return x*f;
    }
    const int inf=0x3f3f3f3f;
    const int N=310;
    int m[N][N],n,s,ans=inf;
    int main(){
        n=read();s=read();
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++){
                m[i][j]=inf;
                if(i==j)m[i][j]=0;
            }
        for(int i=1;i<n;i++){
            int x,y,z;
            x=read();y=read();z=read();
            m[x][y]=min(z,m[x][y]);
            m[y][x]=m[x][y];
        }
        for(int k=1;k<=n;k++)
            for(int i=1;i<=n;i++)
                for(int j=1;j<=n;j++){
                    if(m[i][k]==inf||m[k][j]==inf)continue;
                    else m[i][j]=min(m[i][k]+m[k][j],m[i][j]);
                }
        int l,r,len=0;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++){
                if(m[i][j]>=inf||m[i][j]<=len)continue;
                len=m[i][j];
                l=i;r=j;
        }
        for(int i=1;i<=n;i++){
            if(m[l][i]+m[i][r]!=len)continue;
            for(int j=1;j<=n;j++){
                if(m[l][j]+m[r][j]!=len)continue;
                if(m[i][j]>s)continue;
                int ecc=-inf;
                for(int k=1;k<=n;k++){
                    ecc=max(ecc,m[i][k]+m[j][k]-m[i][j]>>1);
                }
                ans=min(ans,ecc);
            }
        }
        printf("%d",ans);
        return 0;
    }
}
int main(){
    gengyf::main();
    return 0;
}
```

markdown的代码插入不知道怎么折叠QAQ，好丑

2 O(${N^{2}}$) [@LuitaryiJack](https://www.cnblogs.com/Jackpei/)

```cpp

#include<cstdio>
#include<iostream>
#include<cstring>
#define R register int 
using namespace std;
const int N=310;
inline int g() {
	R ret=0,fix=1; register char ch; while(!isdigit(ch=getchar())) fix=ch=='-'?-1:fix;
	do ret=ret*10+(ch^48); while(isdigit(ch=getchar())); return ret*fix;
}
struct edge {
	int v,w,nxt;
	#define v(i) e[i].v
	#define w(i) e[i].w
	#define nxt(i) e[i].nxt
}e[N<<1];
int n,m,k,st,ed,mx,ans=0x3f3f3f3f,tot,cnt,fir[N],pre[N],cnte[N],d[N],mem[N],sume[N];
inline void add(int u,int v,int w) {v(++tot)=v,w(tot)=w,nxt(tot)=fir[u],fir[u]=tot;}
bool vis[N];
void dfs(int u,int fa) {
	//if(vis[u]) return ;
	for(R i=fir[u];i;i=nxt(i)) {
		R v=v(i);
		if(vis[v]||v==fa) continue;
		d[v]=d[u]+w(i);
		dfs(v,u);
		pre[v]=u;
		cnte[v]=i;
	}
}
inline void solve() {
	memset(vis,0,sizeof(vis));
	memset(d,0,sizeof(d)); mx=0;
	d[1]=0,dfs(1,0);
	for(R i=1;i<=n;++i) if(d[i]>mx) mx=d[i],st=i;
	memset(pre,0,sizeof(pre));
	memset(d,0,sizeof(d)); mx=0;
	d[st]=0,dfs(st,0);
	for(R i=1;i<=n;++i) if(d[i]>mx) mx=d[i],ed=i;
	for(R i=ed;i;i=pre[i]) mem[++cnt]=i,sume[cnt]=sume[cnt-1]+w(cnte[i]);
	for(R i=1;i<=cnt;++i) { R j; mx=0;
		memset(vis,false,sizeof(vis));
		memset(d,0,sizeof(d));
		for(j=i;j<=cnt;++j) if(sume[j-1]-sume[i-1]>k) break; 
		--j;
		for(R t=i;t<=j;++t) vis[mem[t]]=true;
		for(R t=i;t<=j;++t) dfs(mem[t],0);
		for(R i=1;i<=n;++i) if(d[i]>mx) mx=d[i];
		ans=min(mx,ans);
	}
}
signed main() {
	n=g(),k=g();
	for(R i=1,u,v,w;i<n;++i) u=g(),v=g(),w=g(),add(u,v,w),add(v,u,w);
	solve();
	printf("%d\n",ans);
}

```


3 O(${NlogSUM}$) [@LuitaryiJack](https://www.cnblogs.com/Jackpei/)
   
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#define R register int
using namespace std;
int n,s,l=1,r=1;
int fa[300010],vis[300010],fir[300010],cnt;
long long d[300010],ans=0x3f3f3f3f;
inline int g() {
	R ret=0,fix=1; register char ch; while(!isdigit(ch=getchar())) fix=ch=='-'?-1:fix;
	do ret=ret*10+(ch^48); while(isdigit(ch=getchar())); return ret*fix;
}
struct node {
	int v,w,nxt;
	#define v(i) e[i].v
	#define w(i) e[i].w
	#define nxt(i) e[i].nxt
}e[600010];
inline void add(int u,int v,int w) {v(++cnt)=v,w(cnt)=w,nxt(cnt)=fir[u],fir[u]=cnt;}
inline void dfs(int u) {
	for(R i=fir[u];i;i=nxt(i)) {
		R v=v(i);
		if(vis[v]||fa[u]==v) continue;
		fa[v]=u;
		d[v]=d[u]+w(i);
		dfs(v);
	}
}
signed main() {
	n=g(),s=g();
	for(R i=1,u,v,w;i<n;++i) u=g(),v=g(),w=g(),add(u,v,w),add(v,u,w);
	dfs(1);
	for(R i=1;i<=n;++i) l=d[i]>d[l]?i:l;
	memset(fa,0,sizeof(fa));
	d[l]=0,dfs(l);
	for(R i=1;i<=n;++i) r=d[i]>d[r]?i:r;
	R t=r;
	for(R i=r;i;i=fa[i]) {
		while(fa[t]&&d[i]-d[fa[t]]<=s) t=fa[t];
		ans=min((long long)ans,max(d[t],d[r]-d[i]));
	}
	for(R i=r;i;i=fa[i]) vis[i]=true;
	for(R i=r;i;i=fa[i]) d[i]=0,dfs(i);
	for(R i=1;i<=n;++i) if(!vis[i]) ans=max(ans,d[i]);
	printf("%lld\n",ans);
}
```
4 O(${N}$) @我自己又丑又长又慢的代码QAQ
   
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=500010;
int head[maxn],ver[maxn<<1],nxt[maxn<<1],tot;
int edge[maxn<<1],fa[maxn],dp[maxn],val[maxn];
int dep[maxn],n,m,x,y,z,tmp,ans,s;bool v[maxn];
inline int read(){
    char c=getchar();int x=0,f=1;
    while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return f*x;
}
inline void add(int x,int y,int z){
    ver[++tot]=y,nxt[tot]=head[x];
    head[x]=tot;edge[tot]=z;
}
inline void dfs(int x){
    for(register int i=head[x];i;i=nxt[i]){
        if(ver[i]!=fa[x]){
            dep[ver[i]]=dep[x]+edge[i];
            fa[ver[i]]=x,dfs(ver[i]);
        }
    }
}
inline void diameter(){
    dfs(1);x=1;
    for(register int i=2;i<=n;i++)
        if(dep[i]>dep[x]) x=i;//离根最远的点
    dep[x]=0;memset(fa,0,sizeof(fa));
    //换了根，所以fa会变
    dfs(x);y=1;//两遍dfs求树的直径
    for(register int i=2;i<=n;i++)
        if(dep[i]>dep[y]) y=i;//离x最远的点
    while(y!=x) v[y]=1,val[++m]=y,y=fa[y];
    //把直径上x,y之间的点全部标记上访问过
    //单开val[]记一下直径上都有什么
    v[x]=1;val[++m]=x;
}
inline void treedp(int x){v[x]=1;
    for(register int i=head[x];i;i=nxt[i])
        if(!v[ver[i]]) treedp(ver[i]),
            dp[x]=max(dp[x],dp[ver[i]]+edge[i]);
    //在直径上dp，
    //dp[]->从[]出发，不过直径上的点，可以到达的最远的点的距离
}
int main(){
    n=read(),s=read();ans=0x3f3f3f3f;
    for(register int i=1;i<n;i++)
        x=read(),y=read(),z=read(),
        add(x,y,z),add(y,x,z);
    diameter();register int j=m;
    for(register int i=1;i<=m;i++) treedp(val[i]);
    for(register int i=1;i<=m;i++)
        tmp=max(tmp,dp[val[i]]);
    for(register int i=m;i>=1;i--){
        while(j>=1&&dep[val[j]]-dep[val[i]]<=s) j--;
        ans=min(ans,max(tmp,
            max(dep[val[i]],dep[val[1]]-dep[val[j+1]])));
    }
    printf("%d",ans);
}
```
好像和chrisk没有关系啊，QAQ，算了，前排安利博客就安利了吧，反正也~~没有收钱~~都是同学QAQ

--------------

最后国际惯例，thanks for your attention

~~总算写完了，累死了~~

---

## 作者：D_14134 (赞：3)

### 二分+贪心
最大值最小很容易想到二分。

二分出所有点到路径的最大值，然后判断这个最大值是否能满足条件。 

一定存在一种方案，这个路径在树的最长链上。证明的话可以用反证法，假设该路径不在最长链上，那么这种方案的最大值一定不比在最长链上的更优。 

根据这个性质我们可以确定一个贪心的策略。

首先确定树的最长链，然后求出最长链上的每一个点到不是最长链上的点的最远距离。如果最长链上存在一个点它到其他点得最远距离>mid的话，说明它根本不可能走到最长链上，那么就判断无解。 

求出了最远距离之后，每一个点剩余的距离记为mid-最远距离。也就是说，离它最远的点走到这个点了之后还能走多少。然后让最长链的左右端点向中间移，直到不能动为止。然后判断这条路径的长度是否<=s，是的话就有解，否则无解。


# code
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=300010;
int n,s,x,y,z,Max,dMax,pt,inf,ans;
int tot,point[maxn],nxt[maxn*2],v[maxn*2],c[maxn*2];
int h[maxn],father[maxn],edge[maxn],leaf[maxn],tmp[maxn],len[maxn],goal[maxn],dis[maxn];
bool vis[maxn];
void add(int x,int y,int z){
    nxt[++tot]=point[x];point[x]=tot;v[tot]=y;c[tot]=z;
}
void dfs(int x,int fa,int dep){
    father[x]=fa;h[x]=dep;
    if(h[x]>Max) Max=h[x],pt=x;
    bool flag=false;
    for(int i=point[x];i;i=nxt[i])
        if(v[i]!=fa){
            dfs(v[i],x,dep+c[i]),flag=true;
            edge[v[i]]=c[i];
        }
    if(!flag) leaf[++leaf[0]]=x;
}
void chain(int x){
    while(h[x]!=0){
        vis[x]=true;
        tmp[++tmp[0]]=x;
        x=father[x];
    }
    tmp[++tmp[0]]=x;vis[x]=true;
}
void length(int x,int fa,int dep,int st){
    dis[st]=max(dis[st],dep);
    for(int i=point[x];i;i=nxt[i])
        if(v[i]!=fa&&!vis[v[i]])
            length(v[i],x,dep+c[i],st);
}
bool check(int mid){
    for(int i=1;i<=tmp[0];++i)
        if(dis[tmp[i]]<=mid) len[tmp[i]]=dis[tmp[i]]-mid;
        else return false;

    len[tmp[1]]=len[tmp[tmp[0]]]=mid;
    for(int i=1;i<=tmp[0];++i)
        if(len[tmp[i]]>=edge[tmp[i]]){
            len[tmp[i+1]]=min(len[tmp[i+1]],len[tmp[i]]-edge[tmp[i]]);
            len[tmp[i]]=inf;
        }
        else break;
    for(int i=tmp[0];i>=1;--i)
        if(len[tmp[i]]>=edge[tmp[i-1]]){
            len[tmp[i-1]]=min(len[tmp[i-1]],len[tmp[i]]-edge[tmp[i-1]]);
            len[tmp[i]]=inf;
        }
        else break;
    int l=0,a=0,b=0;
    for(int i=1;i<=tmp[0];++i) if(len[tmp[i]]!=inf) {a=i;break;}
    for(int i=tmp[0];i>=1;--i) if(len[tmp[i]]!=inf) {b=i;break;}
    for(int i=a;i<b;++i) l+=edge[tmp[i]];
    if(l<=s) return 1;
    else return 0;
}
int find(){
    int l=0,r=dMax,mid,ans;
    while(l<=r){
        mid=(l+r)/2;
        if(check(mid)) ans=mid,r=mid-1;
        else l=mid+1;
    }
    return ans;
}
int main(){
    scanf("%d%d",&n,&s);
    for(int i=1;i<n;++i){
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);add(y,x,z);dMax+=z;
    }
    dfs(1,0,0);
    leaf[0]=1,h[pt]=0,Max=0,edge[pt]=0,dfs(pt,0,0);
    chain(pt);
    memset(len,127,sizeof(len));
	inf=len[0];
    for(int i=1;i<=tmp[0];++i) length(tmp[i],0,0,tmp[i]);
    ans=find();
	printf("%d\n",ans);
}
```

---

## 作者：安好 (赞：3)

/\*
20%的数据,就是NOIP那道树网的核。

100%这么大的数据范围，若直径长度为d，dlogd可能会被卡


先bfs两遍求出树的直径(防爆栈)，O(n)的

然后维护 g[i]表示i是路径右端点时，右边那段删掉的直径长度。

f[i]表示i是路径左端点时，左边那段删掉的直径长度。

h[i]表示i是直径上的点，每个直径上的点不是都有一棵（或者很多棵）

由非此直径上点组成的树（森林）嘛，点i到这些子节点中最远的那个的距离。

然后在这个序列上跑双指针。就是路径长度不是有限制嘛，然后从左到右枚举左端点，然后右端点是非严格单调右移的。

时间复杂度线性。而对于一段路径区间[l,r]，它作为枢纽时的答案为

max(max(f[l],g[r]),max{hi,i∈[l,r]}) 

然后最右边那个怎么搞呢？ 单调队列，维护hi最大值啊~

\*/






    

    
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#define N 3000007
#define inf 0x3f3f3f3f
using namespace std;
int n,m,k,s,t,ans,cnt,num,L,R;
int head[N],f[N],g[N],h[N],fa[N],vis[N];
int belong[N],tmp[N],que[N],id[N];
struct edge{
    int v,net,w;
}e[N<<1];
queue<int>q;
inline int read()
{
    int x=0,f=1;char c=getchar();
    while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
inline void add(int u,int v,int w)
{
    e[++cnt].v=v;e[cnt].w=w,e[cnt].net=head[u];head[u]=cnt;
}
int bfs(int s,int Time)
{
    int len=0;q.push(s);
    g[s]=0,fa[s]=s,vis[s]=Time;
    while(!q.empty())
    {
        int u=q.front();q.pop();
        for(int i=head[u];i;i=e[i].net)
        {
            int v=e[i].v;
            if(vis[v]==Time) continue;
            g[v]=g[u]+e[i].w;len=max(len,g[v]);
            fa[v]=u;vis[v]=Time;
            q.push(v);
        }
    }return len;
}
void solve()
{
    int i;
    for(s=1,bfs(s,++num),i=1;i<=n;i++)
      if(g[i]>g[s]) s=i;
    for(bfs(s,++num),i=1;i<=n;i++)
      if(g[i]>g[t]) t=i;
    belong[n=1]=t;num++;
    do{
        t=fa[t],belong[++n]=t,vis[t]=num;
    }while(t!=s);
    for(i=1;i<=n;i++) f[i]=g[belong[1]]-g[belong[i]];
    for(i=1;i<=n;i++) tmp[i]=g[belong[i]];
    for(i=1;i<=n;i++) h[i]=bfs(belong[i],num);
    for(i=1;i< n;i++) g[i]=tmp[i];g[n]=0;    
}
int main()
{
    int x,y,z;
    n=read();m=read();
    for(int i=1;i<n;i++)
    {
        x=read();y=read();z=read();
        add(x,y,z);add(y,x,z);
    }
    solve();
    int l=1,r=0;ans=inf;
    for(l=1;l<=n;l++)
    {
        while(r<n && f[r+1]-f[l]<=m)
        {
            ++r;while(L<=R && que[R]<h[r]) R--;
            que[++R]=h[r];id[R]=r;
        }
        ans=min(ans,max(max(f[l],g[r]),que[L]));
        if(id[L]<=l)L++;
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Tommy_clas (赞：2)

前言：我又来分享我自己的不优秀但是能过的做法了qwq

[传送门](https://www.luogu.org/problem/P2491)

题目大意：给你一棵$n$个点的树，树的每条边有一个非负权值。定义一个点到路径的距离是它到路径上所有的点的距离的最小值，要求选出一条长度不超过$s$的路径，使树上任意一个点到这条路径上的距离的最大值（这里我们定义它为这条路径的“权值”）最小。

嗯，题面给出来后可以说是一脸懵逼。不过我们先可以进行一波大胆猜测：
 
 1. 当延伸一条路径使其长度增加时，在每一次增加的长度都“没有浪费”的前提下，路径的权值是单调递减的。
 
 2. 当限制长度增加时，新路径是可以在原路径的基础上延伸若干条边得到的。
 
 3. 上述路径一定是在直径的中点（或相邻的节点）开始，并沿着一条直径延伸

接下来就是~~并不严谨的~~证明：

证1：

假设我们已经有一条路径$S$，**如果我们找到一个到它的距离最大的点$p$，然后让$S$向它延伸一条边，这样$S$的权值就减小了**；**如果不选点$p$方向延伸，也就是不缩小$p$到$S$的距离，那么路径延长后$S$的权值依然是不变的，新增加的长度就被“浪费”了**。所以在每一次增加的长度都“没有浪费”的前提下，路径的权值是单调递减的。

证2：

由于增加的限制长度是相同的(即权值减小值相同)，任何路径的初始权值都不大于原路径，所以新路径是可以在原路径的基础上延伸若干条边得到的。

证3：

我们可以先考虑$s=0$的情况(也就是只选一个点)：一棵树中最长的链是它的直径，所以如果把点设在直径的与中点最接近的节点处，那么容易得到此时路径的权值最小(直径的一半~直径)，然后根据结论1的延伸方式，每一次都是向着距离最大的点的方向延伸，而起始点又是在直径上，所以延伸路径很明显在直径上。

这样我们就有了以下做法：

 1. 求出直径长度和任意一条直径的所有点。
 2. 求直径中距离直径中点最近的一个点$rt$，以此为基础进行刚才的贪心延伸(堆维护)。
 
延伸也有一些需要注意的地方：
 1. 每次延伸都应当取到目前路径最大的点，有点类似于prim算法，可以用一个堆进行维护。
 2. 延伸前可以先进行一波预处理，处理出$d[i]$表示以$rt$为根的树中，从$i$出发所能走的最长距离，一开始和每次延伸后都把端点$x$的儿子$ch$的$d[ch]+v(x,ch)$丢进堆里进行维护。
 3. 当路径的长度再增加时会超过$s$，就可以跳出了。
 4. 不要忘了你在延伸路径，所以当你从堆里得到的点并不是路径的两个端点时，也应该跳出，就算你延伸其它的边，权值也不会再减小了。
 5. 不用担心你延伸的点是否在直径中，因为“到路径距离最大”这个条件已经帮你限制了。（一开始写的时候因为这个无缘无故多了1000多byte QAQ）

然后就在$O(nlogn)$的时间内解决了问题。

然而很菜的我并不会$O(n)$做法QAQ、

上代码

```cpp
#include<cstdio>
#include<queue>
#include<iostream>
#define N 500005
#define ll long long
using namespace std;
int n,head[N],cnt,maxid[2],fa[N],dep[N],mid;
bool tag[N];
ll s,dis,maxn[N][2][2],d[N],ans;
struct edge
{
	int to,nxt,v;
}w[N*2];
void add(int x,int y,int v)
{
	w[++cnt]=(edge){y,head[x],v};
	head[x]=cnt;
}
inline void equ(ll a[],ll b[])
{
	a[0]=b[0],a[1]=b[1];
}
void dfs1(int x,int last)//求直径
{
	fa[x]=last,dep[x]=dep[last]+1;
	maxn[x][0][1]=maxn[x][1][1]=x;
	for(int i=head[x];i;i=w[i].nxt)
	{
		int y=w[i].to;
		if(y==last)continue;
		dfs1(y,x);
		ll temp[2]={maxn[y][0][0]+(ll)w[i].v,maxn[y][0][1]};
		if(temp[0]>maxn[x][0][0])equ(maxn[x][1],maxn[x][0]),equ(maxn[x][0],temp);
		else if(temp[0]>maxn[x][1][0])equ(maxn[x][1],temp);
	}
	if(dis<maxn[x][0][0]+maxn[x][1][0])
	{
		dis=maxn[x][0][0]+maxn[x][1][0];
		maxid[0]=maxn[x][0][1];
		maxid[1]=maxn[x][1][1];
	}
}
void get_d()
{
	int x=maxid[0],y=maxid[1];
	if(dep[x]<dep[y])swap(x,y);
	while(dep[x]>dep[y])tag[x]=1,x=fa[x];
	while(x!=y)tag[x]=tag[y]=1,x=fa[x],y=fa[y];
	tag[x]=1;
}
void get_mid()//求离直径中点最近的节点
{
	int x=maxid[0],last=0;
	ll sum=0;
	while(x!=maxid[1])
	{
		int y,v;
		for(int i=head[x];i;i=w[i].nxt)
			if(tag[w[i].to]==1&&w[i].to!=last)y=w[i].to,v=w[i].v;
		if(2*sum<dis&&2*(sum+v)>=dis)
		{
			mid=(2*(sum+v)-dis)<(dis-2*sum)?y:x;return;
		}
		sum+=v,last=x,x=y;
	}
}
void dfs_pre(int x,int last)//预处理
{
	d[x]=0;
	for(int i=head[x];i;i=w[i].nxt)
	{
		int y=w[i].to;
		if(y==last)continue;
		dfs_pre(y,x);
		d[x]=max(d[x],d[y]+(ll)w[i].v);
	}
}
struct node
{
	int id,id2;ll d,d2;
	bool operator<(const node &b)const
	{
		return d<b.d;
	}
};
priority_queue<node>q;
void calc()//延伸
{
	for(int i=head[mid];i;i=w[i].nxt)
		q.push((node){mid,w[i].to,d[w[i].to]+w[i].v,w[i].v});
	int l=mid,r=mid;
	ll sum=0;
	while(!q.empty())
	{
		int last=q.top().id,last2=q.top().id2;
		ll v=q.top().d,v2=q.top().d2;
		q.pop();
		if((last!=l&&last!=r)||sum+v2>s)
		{
			ans=v;return;
		}
		sum+=v2;
		if(l==last)l=last2;
		else if(r==last)r=last2;
		for(int i=head[last2];i;i=w[i].nxt)
			if(w[i].to!=last)q.push((node){last2,w[i].to,d[w[i].to]+w[i].v,w[i].v});
	}
}
int main()
{
	scanf("%d %lld",&n,&s);
	for(int i=1,x,y,v;i<n;i++)
	{
		scanf("%d %d %d",&x,&y,&v);
		add(x,y,v),add(y,x,v);
	}
	dfs1(1,0);
	get_d(),get_mid();
	dfs_pre(mid,0);
	calc();
	printf("%lld\n",ans);
	return 0;
}
```


---


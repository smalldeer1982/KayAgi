# [HAOI2015] 树上操作

## 题目描述

有一棵点数为 $N$ 的树，以点 $1$ 为根，且树有点权。然后有 $M$ 个操作，分为三种：
- 操作 $1$：把某个节点 $x$ 的点权增加 $a$。
- 操作 $2$：把某个节点 $x$ 为根的子树中所有点的点权都增加 $a$。
- 操作 $3$：询问某个节点 $x$ 到根的路径中所有点的点权和。


## 说明/提示

对于 $100\%$ 的数据，$1\le N,M\le10^5$，且所有输入数据的绝对值都不会超过 $10^6$。


## 样例 #1

### 输入

```
5 5
1 2 3 4 5
1 2
1 4
2 3
2 5
3 3
1 2 1
3 5
2 1 2
3 3```

### 输出

```
6
9
13```

# 题解

## 作者：zht467 (赞：95)

树链剖分固然可以搞。

但还有另一种做法，可以看出，增加一个节点的权值会对以它为根的整棵子树都有影响，相当于给整棵子树增加一个值。

而给以某一节点 x 为根的子树增加一个权值也会影响当前子树，节点 y 所增加的值为 dis[y] \* z - (dis[x] - 1) \* z，每个节点都会增加 -(dis[x] - 1) \* z ，询问时只用加上 dis[y] \* y 和当前节点 y 的权值。

给整棵子树增加一个权值可以用 dfs 序 + 线段树搞， dis 数组可以预处理出来。

——代码









```cpp
#include <cstdio>
#include <cstring>
#define LL long long
#define root 1, 1, n
#define ls now << 1, l, mid
#define rs now << 1 | 1, mid + 1, r
using namespace std;
const int MAXN = 100001;
int n, m, cnt, tot;
int head[MAXN], next[MAXN << 1], to[MAXN << 1], tid[MAXN], size[MAXN];
LL a[MAXN << 2], b[MAXN << 2], val[MAXN], dis[MAXN];
inline void add(int x, int y)
{
    to[cnt] = y;
    next[cnt] = head[x];
    head[x] = cnt++;
} 
inline void dfs(int u)
{
    int i, v; 
    tid[u] = ++tot;
    size[u] = 1;
    for(i = head[u]; i != -1; i = next[i])
    {
        v = to[i];
        if(!size[v])
        {
            dis[v] = dis[u] + 1;
            dfs(v);
            size[u] += size[v];
        }
    }
}
inline void push_down(int now)
{
    a[now << 1] += a[now];
    a[now << 1 | 1] += a[now];
    b[now << 1] += b[now];
    b[now << 1 | 1] += b[now];
    a[now] = b[now] = 0;
}
inline void update(LL x, LL y, int ql, int qr, int now, int l, int r)
{
    if(ql <= l && r <= qr)
    {
        a[now] += x;
        b[now] += y;
        return;
    }
    push_down(now);
    int mid = (l + r) >> 1;
    if(ql <= mid) update(x, y, ql, qr, ls);
    if(mid < qr) update(x, y, ql, qr, rs);
}
inline LL query(int u, int x, int now, int l, int r)
{
    if(l == r) return dis[u] * a[now] + b[now];
    push_down(now);
    int mid = (l + r) >> 1;
    if(x <= mid) return query(u, x, ls);
    else return query(u, x, rs);
}
int main()
{
    int i, x, z;
    LL y;
    scanf("%d %d", &n, &m);
    for(i = 1; i <= n; i++)    scanf("%lld", &val[i]);
    memset(head, -1, sizeof(head));
    for(i = 1; i < n; i++)
    {
        scanf("%d %d", &x, &y);
        add(x, y);
        add(y, x);
    }
    dis[1] = 1;
    dfs(1);
    for(i = 1; i <= n; i++) update(0, val[i], tid[i], tid[i] + size[i] - 1, root);
    for(i = 1; i <= m; i++)
    {
        scanf("%d %d", &z, &x);
        if(z == 1)
        {
            scanf("%lld", &y);
            update(0, y, tid[x], tid[x] + size[x] - 1, root);
        }
        else if(z == 2)
        {
            scanf("%lld", &y);
            update(y, -((dis[x] - 1) * y), tid[x], tid[x] + size[x] - 1, root);
        }
        else printf("%lld\n", query(x, tid[x], root));
    }
    return 0;
}
```

---

## 作者：yingjz (赞：42)

蒟蒻我又开始写题解了

> 是时候安利博客了：<https://yjzoier.gitee.io/hexo/p/1d27.html>

## 题目描述

有一棵点数为 N 的树，以点 1 为根，且树点有边权。然后有 M 个操作，分为三种：

- 操作 1 ：把某个节点 x 的点权增加 a 。
- 操作 2 ：把某个节点 x 为根的子树中所有点的点权都增加 a 。
- 操作 3 ：询问某个节点 x 到根的路径中所有点的点权和。

<https://www.luogu.org/problemnew/show/P3178>

## Solution

这是一道数据结构的题目，当然会**树剖**的同学可以直接看作模板题；

这里介绍一种不同于树剖的方法，首先需要知道一个概念：**欧拉序**，这是 *DFS* 序的一种，举个例子：

> ![tree](https://i.loli.net/2019/01/13/5c3acf8ac094b.jpg)
>
> 这样的一棵树，它的欧拉序就是 ***1 2 4 4 5 5 2 3 6 6 7 7 8 8 3 1***

显然，每个点在欧拉序中出现了 $2$ 次；欧拉序有一个非常优越的性质，如果把每个点第一次出现记作 `+`，第二次出现记作 `-`，那么**根节点到任意节点的权值和在欧拉序上对应一个前缀和**，这个性质非常好理解，因为欧拉序其实又叫"出栈入栈序"，所以前缀中尚未抵消掉的点在 DFS 到当前点时在栈中，那么其肯定在当前点到根的路径中。

> 这一段描述有点抽象，以刚才那棵树↑为例，我们对于每个点标上符号，那么此时欧拉序其实就是这样的（设权值为 $a_i$）
>
> $+a_1, +a_2, +a_4, -a_4, +a_5, -a_5, -a_2, +a_3, +a_6, -a_6, +a_7, -a_7, +a_8, -a_8, -a_3, -a_1$
>
> 如果我们要计算点 5 到根节点的权值和，其实就是
>
> $+a_1, +a_2, +a_4, -a_4, +a_5$

利用这个性质，我们可以方便地完成操作 1 和操作 3.可是操作 2 就比较麻烦了，因为有些是要 $+a$ 的，有些是要 $-a$ 的，无法直接快速计算出 $+a$ 对于某个区间的影响；这时候我们只需要做一个小小的变化，其实一个区间受到 $+a$ 的影响就是 $a \times$ (该区间内 + 的个数 - 该区间内 - 的个数)

最后是代码

```c++
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;

typedef long long ll;
const int N = 100007;

int n, m, a[N], tid[N], tif[N], num[N << 1], stamp;
int ecnt, head[N], vet[N << 1], nxt[N << 1];
ll val[N << 3], tag[N << 3];
struct DFN{int f, v;} dfspath[N << 1];

void eadd(int u, int v){
    vet[++ecnt] = v;
    nxt[ecnt] = head[u];
    head[u] = ecnt;
}

void dfs(int u, int f){
    dfspath[ tid[u] = ++stamp].f = 1;
    dfspath[stamp].v = u;
    for (int e = head[u]; e; e = nxt[e])   
        if (vet[e] != f) dfs(vet[e], u);
    dfspath[ tif[u] = ++stamp].f = -1;
    dfspath[stamp].v = u;
}

void pushdown(int rt, int l, int m, int r){
    if (tag[rt]){
        val[rt << 1] += tag[rt] * (num[m] - num[l-1]);
        val[rt << 1 | 1] += tag[rt] * (num[r] - num[m]);
        tag[rt << 1] += tag[rt]; 
        tag[rt << 1 | 1] += tag[rt];
        tag[rt] = 0;
    }
}

void build(int rt, int l, int r){
    if (l == r) {
        val[rt] = dfspath[l].f * a[dfspath[l].v];
        return;
    }
    int m = (l + r) >> 1;
    build(rt << 1, l, m);
    build(rt << 1 | 1, m+1, r);
    val[rt] = val[rt << 1] + val[rt << 1 | 1];
}

void Update(int rt, int l, int r, int x, int c){
    val[rt] += c;
    if (l == r) return;
    int m = (l + r) >> 1;
    if (x <= m) Update(rt << 1, l, m, x, c);
    else Update(rt << 1 | 1, m+1, r, x, c);
}

void Change(int rt, int l, int r, int p, int q, int c){
    if (p <= l && r <= q){
        tag[rt] += c;
        val[rt] += (ll)c * (num[r] - num[l-1]);
        return;
    }
    int m = (l + r) >> 1;
    pushdown(rt, l, m, r);
    if (p <= m) Change(rt << 1, l, m, p, q, c);
    if (q > m) Change(rt << 1 | 1, m+1, r, p, q, c);
    val[rt] = val[rt << 1] + val[rt << 1 | 1];
}

ll Query(int rt, int l, int r, int p, int q){
    if (p <= l && r <= q) return val[rt];
    int m = (l + r) >> 1; ll res = 0;
    pushdown(rt, l, m, r);
    if (p <= m) res += Query(rt << 1, l, m, p, q);
    if (q > m) res += Query(rt << 1 | 1, m+1, r, p, q);
    return res;
}

int main(){
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
    for (int i = 1; i < n; ++i){
        int u, v;
        scanf("%d%d", &u, &v);
        eadd(u, v); eadd(v, u);
    }
    dfs(1, 0);
    for (int i = 1; i <= stamp; ++i)
        num[i] = num[i-1] + dfspath[i].f;
    build(1, 1, n + n);
    while (m--){
        int opt, x, a; scanf("%d", &opt);
        if (opt == 1) {
            scanf("%d%d", &x, &a);
            Update(1, 1, n + n, tid[x], +a);
            Update(1, 1, n + n, tif[x], -a);
        } else if (opt == 2) {
            scanf("%d%d", &x, &a);
            Change(1, 1, n + n, tid[x], tif[x], a);
        } else {
            scanf("%d", &x);
            printf("%lld\n", Query(1, 1, n + n, 1, tid[x]));
        }
    }

    return 0;
}
```



---

## 作者：关怀他人 (赞：37)

# 树链剖分裸体
### Solution :
1. 树剖
   
   这个大家应该都会吧，不会的可以看博客
   [https://www.cnblogs.com/ivanovcraft/p/9019090.html](https://www.cnblogs.com/ivanovcraft/p/9019090.html)
	```cpp
    void dfs1(int u,int fa,int d){
        f[u] = fa;
        size[u] = 1;
        dep[u] = d;
        for(int i = head[u];i != -1;i = e[i].next){
            int v = e[i].to;
            if(v == fa)
                continue;
            dfs1(v,u,d + 1);
            size[u] += size[v];
            if(size[v] > size[son[u]])
                son[u] = v;
        }
    }
    void dfs2(int u,int t){
        top[u] = t;
        id[u] = ++ind;
        a[ind] = w[u];
        if(!son[u])
            return;
        dfs2(son[u],t);
        for(int i = head[u];i != -1;i = e[i].next){
            int v = e[i].to;
            if(v != f[u] && v != son[u])
                dfs2(v,v);
        }
    }
   ```

   
2. 用一个线段树去维护区间和
	 
     (1). 对于操作1可以直接进行线段树的单点修改
     ```cpp
    void addInterval(int k,int l,int r,ll val){
        if(tree[k].l >= l && tree[k].r <= r){
            tree[k].f += val;
            tree[k].sum += val * (tree[k].r - tree[k].l + 1);
            return;
        }
        if(tree[k].f)
            down(k);
        int mid = (tree[k].l + tree[k].r) / 2;
        if(l <= mid)
            addInterval(k * 2,l,r,val);
        if(r > mid)
            addInterval(k * 2 + 1,l,r,val);
        update(k);
    }
    ```
    注意懒标记的下传不要写错了
    ```cpp
    void down(int k){
        tree[k * 2].sum += tree[k].f * (tree[k * 2].r - tree[k * 2].l + 1);
        tree[k * 2 + 1].sum += tree[k].f * (tree[k * 2 + 1].r - tree[k * 2 + 1].l + 1);
        tree[k * 2].f += tree[k].f;
        tree[k * 2 + 1].f += tree[k].f;
        tree[k].f = 0;
    }
	```
    
    (2).对于操作2，我们知道树剖中已经处理了一个节点子树的大小(size)且一个节点的子树的编号(id)是连续的，所以很容易想到对于id[x]到id[x]+size[x] - 1进行区间修改
    ```cpp
	void addInterval(int k,int l,int r,ll val){
      if(tree[k].l >= l && tree[k].r <= r){
          tree[k].f += val;
          tree[k].sum += val * (tree[k].r - tree[k].l + 1);
          return;
      }
      if(tree[k].f)
          down(k);
      int mid = (tree[k].l + tree[k].r) / 2;
      if(l <= mid)
          addInterval(k * 2,l,r,val);
      if(r > mid)
          addInterval(k * 2 + 1,l,r,val);
      update(k);
  	}
	```
	(3).对于操作3，就是常规的树剖操作了，对每一条链上做区间求和即可
    ```cpp
    ll sumInterval(int k,int l,int r){
        ll cnt = 0;
        if(tree[k].l >= l && tree[k].r <= r)
            return tree[k].sum;
        if(tree[k].f)
            down(k);
        int mid = (tree[k].l + tree[k].r) / 2;
        if(l <= mid)
            cnt += sumInterval(k * 2,l,r);
        if(r > mid)
            cnt += sumInterval(k * 2 + 1,l,r);
        return cnt;
    }

    ll sumTree(int x,int y){
        int fx = top[x],fy = top[y];
        ll ans = 0;
        while(fx != fy){
            if(dep[fx] >= dep[fy]){
                ans += sumInterval(1,id[fx],id[x]);
                x = f[fx];
                fx = top[x];
            }else{
                ans += sumInterval(1,id[fy],id[y]);
                y = f[fy];
                fy = top[y];
            }
        }
        if(id[x] <= id[y])
            ans += sumInterval(1,id[x],id[y]);
        else
            ans += sumInterval(1,id[y],id[x]);
        return ans;
    }
    ```
3. 最后附上完整代码,供各位参考
    ```cpp
    /*
    Problem : luogu P3178
    Algorithm : Ê÷ÆÊ + Ïß¶ÎÊ÷ 
    Status : AC
    */
    #include <bits/stdc++.h>
    #include <cstring>
    #include <vector>
    #include <algorithm>
    #include <cstdio>
    #include <iostream>
    using namespace std;
    typedef long long ll;

    const int INF = 0x3f3f3f3f;
    const int MAXN = 100005;

    int n,m,len,ind;
    int head[MAXN],f[MAXN],top[MAXN],id[MAXN],size[MAXN],son[MAXN],dep[MAXN];
    ll w[MAXN],a[MAXN];

    struct Edge{
        int to,next;
    } e[MAXN * 2];

    struct Tree{
        int l,r;
        ll sum,f;
    } tree[MAXN * 4];

    void add(int u,int v){
        e[++len].to = v;
        e[len].next = head[u];
        head[u] = len;
    }

    void dfs1(int u,int fa,int d){
        f[u] = fa;
        size[u] = 1;
        dep[u] = d;
        for(int i = head[u];i != -1;i = e[i].next){
            int v = e[i].to;
            if(v == fa)
                continue;
            dfs1(v,u,d + 1);
            size[u] += size[v];
            if(size[v] > size[son[u]])
                son[u] = v;
        }
    }

    void dfs2(int u,int t){
        top[u] = t;
        id[u] = ++ind;
        a[ind] = w[u];
        if(!son[u])
            return;
        dfs2(son[u],t);
        for(int i = head[u];i != -1;i = e[i].next){
            int v = e[i].to;
            if(v != f[u] && v != son[u])
                dfs2(v,v);
        }
    }

    void update(int k){
        tree[k].sum = tree[k * 2].sum + tree[k * 2 + 1].sum;
    }

    void down(int k){
        tree[k * 2].sum += tree[k].f * (tree[k * 2].r - tree[k * 2].l + 1);
        tree[k * 2 + 1].sum += tree[k].f * (tree[k * 2 + 1].r - tree[k * 2 + 1].l + 1);
        tree[k * 2].f += tree[k].f;
        tree[k * 2 + 1].f += tree[k].f;
        tree[k].f = 0;
    }

    void build(int k,int l,int r){
        tree[k].l = l;
        tree[k].r = r;
        if(l == r){
            tree[k].sum = a[l];
            return;
        }
        int mid = (l + r) / 2;
        build(k * 2,l,mid);
        build(k * 2 + 1,mid + 1,r);
        update(k);
    }

    void addInterval(int k,int l,int r,ll val){
        if(tree[k].l >= l && tree[k].r <= r){
            tree[k].f += val;
            tree[k].sum += val * (tree[k].r - tree[k].l + 1);
            return;
        }
        if(tree[k].f)
            down(k);
        int mid = (tree[k].l + tree[k].r) / 2;
        if(l <= mid)
            addInterval(k * 2,l,r,val);
        if(r > mid)
            addInterval(k * 2 + 1,l,r,val);
        update(k);
    }

    ll sumInterval(int k,int l,int r){
        ll cnt = 0;
        if(tree[k].l >= l && tree[k].r <= r)
            return tree[k].sum;
        if(tree[k].f)
            down(k);
        int mid = (tree[k].l + tree[k].r) / 2;
        if(l <= mid)
            cnt += sumInterval(k * 2,l,r);
        if(r > mid)
            cnt += sumInterval(k * 2 + 1,l,r);
        return cnt;
    }

    void addPoint(int k,int x,ll val){
        if(tree[k].l == tree[k].r){
            tree[k].sum += val;
            return;
        }
        if(tree[k].f)
            down(k);
        int mid = (tree[k].l + tree[k].r) / 2;
        if(x <= mid)
            addPoint(k * 2,x,val);
        else
            addPoint(k * 2 + 1,x,val);
        update(k);
    }

    ll sumTree(int x,int y){
        int fx = top[x],fy = top[y];
        ll ans = 0;
        while(fx != fy){
            if(dep[fx] >= dep[fy]){
                ans += sumInterval(1,id[fx],id[x]);
                x = f[fx];
                fx = top[x];
            }else{
                ans += sumInterval(1,id[fy],id[y]);
                y = f[fy];
                fy = top[y];
            }
        }
        if(id[x] <= id[y])
            ans += sumInterval(1,id[x],id[y]);
        else
            ans += sumInterval(1,id[y],id[x]);
        return ans;
    }

    int main(){
        //freopen(".in","r",stdin);
        //freopen(".out","w",stdout);
        memset(head,-1,sizeof(head));
        scanf("%d%d",&n,&m);
        for(int i = 1;i <= n;i++)
            scanf("%lld",&w[i]);
        for(int i = 1;i < n;i++){
            int x,y;
            scanf("%d%d",&x,&y);
            add(x,y);
            add(y,x);
        }
        dfs1(1,0,1);
        dfs2(1,1);
        build(1,1,n);
        while(m--){
            int op,x;
            ll y;
            scanf("%d%d",&op,&x);
            if(op == 1){
                scanf("%lld",&y);
                addPoint(1,id[x],y);
            }else if(op == 2){
                scanf("%lld",&y);
                addInterval(1,id[x],id[x] + size[x] - 1,y);
            }else if(op == 3)
                printf("%lld\n",sumTree(1,x)); 
        }
        return 0;
    }

    ```
### 注意开long long
## 祝大家一遍AC


---

## 作者：benny (赞：18)

来一波**树剖+超(du)级(liu)树状数组**的题解，代码短，下面详细介绍



------------
# 什么是树剖？
众所周知，在一颗树中，每个非根节点都有**唯一的父亲**，却有可能有**很多的儿子**。所谓树剖，是让所有非叶子节点，都挑选一个**最偏爱的儿子**，并且dfs优先搜索它

因为具体怎么偏爱的不同，
一颗树有很多种剖分方式，像这样

![一颗树的3种剖分](https://cdn.luogu.com.cn/upload/pic/46897.png)

别忘了我们优先搜索最偏爱的儿子，每个点赋予属性dfn为时间戳
![加上时间戳](https://cdn.luogu.com.cn/upload/pic/46898.png)

观察到，无论怎么剖分，有：
1. 每个点被唯一地放在一根链中（一个点也算链）
1. 所有链的总长度（长度定义为链的顶点个数）为n
1. 同一根链上的dfn具有**连续性**！！！（这一点用于本题操作3）
1. 定义一个点c的重量为它子树中节点的个数，那么它子孙的dfn，可以一一对应到一个区间，这个区间左端点是dfn[c],长度为“c的重量”。别忘了，区间也有**连续性**

是不是有点乱？我们梳理一下。对于树中的每个点c，我们依次赋予了一些神秘的属性：

- 它的父亲fa
- 它的深度de,可以令de[c]=de[fa[c]]+1
- 重量wei，等于它儿子的总重量，再加1
- 它最偏爱的儿子son，具体怎么定义**待会再议**
- 它的dfn，注意是依据son的
- 它所在的链的顶端（显然是它的一个祖先），记作g
g[c]=son[fa[c]]==c?g[fa[c]]:c即如果它是父亲的宠儿，那么它的链顶等于它父亲的链顶，否则就是它自己

## 你肯定不耐烦了，这样剖分有什么用？


很有用。我们如果要修改或询问树中一条路径上的信息，实质上是修改或询问**许许多多条链的信息**，更有意思的是，这些链上的dfn是**连续的**，可转化为**区间操作**。除此之外，
我们有**重链剖分**和**长链剖分**两大利器，是非常非常非常有用的，本题就需要重链剖分

## 什么是重链剖分

我们定义son[c]为c**最重的一个儿子之一**。会发现一个神奇的性质

虽然一颗树被重链剖分会产生很多条链，但是对于树中每一个点，它到根节点的路上，经历的链的条数是**很少的**、**有限的**、甚至的**lg级别的**

啊，去根节点的路上，那些链又少又长

![重链剖分1](https://cdn.luogu.com.cn/upload/pic/46905.png)

![](https://cdn.luogu.com.cn/upload/pic/46906.png)


最深的11到1也只有1条链。那么怎么证明链的条数一定是lg级别呢？假设有一个坏蛋，想让11到根节点的路变得很多，他要怎么做？他要通过**增加节点**来让11（和它的祖先）不在是宠儿，从而将链**切断**。比如他可以让11不是宠儿：

![](https://cdn.luogu.com.cn/upload/pic/46908.png)

从而让路径条数增加到2

很可惜，这个坏蛋是不能得逞的，因为他需要加**很多很多的节点**，才能略有收益。

![](https://cdn.luogu.com.cn/upload/pic/46909.png)

以上是重链剖分的性质，希望你能感性理解。附上代码：
```cpp

void dfs1(LL c,LL from)//第一遍dfs，置好fa,de,wei,son 
{
    LL i,y;
    fa[c]=from;
    de[c]=de[from]+1;
    wei[c]=1;
    son[c]=0;wei[0]=0;
    for(i=hea[c];i;i=nex[i])
    {
        y=poi[i];
        if(y==from) continue;
        dfs1(y,c);
        wei[c]+=wei[y];
        if(wei[y]>wei[son[c]])
            son[c]=y;//最重的儿子 
    }
}
void dfs2(LL c,LL from)//第二遍dfs，置好dfn和g 
{
    LL i,y;
    //printf("%lld\n",c);
    dfn[c]=++dfn[0];
    g[c]=son[from]==c?g[from]:c;//g定义为链顶 
    if(son[c])dfs2(son[c],c);//优先访问重儿子（最偏爱的儿子） 
    for(i=hea[c];i;i=nex[i])
    {
        y=poi[i];
        if(y==from||y==son[c]) continue;
        dfs2(y,c);
    }
}
```
在重链剖分中
最偏爱的儿子是“重儿子”，链是重链
## 重链剖分有什么用

我们对于每个点，我们有了6大属性，和一条公理。可以猥琐欲为了。

- 两点(u和v)最近公共祖先LCA(本题不需要):还记得g是一个点的链顶吗？不断令u=fa[g[u]],v=fa[g[v]],不断地跳最终它们会在LCA处相遇

如果我们要修改或询问u到v路径上的点的所有关键值，实际上是修改或询问很少(lg)的区间。

- 具体来说，维护一个序列a，其下标是dfn，存的是关键值。
- 操作（包括修改和询问）节点u的关键值，就是在操作a[dfn[u]]
- 操作一条重链(u->v,u是v的祖先)上的所有关键值，实际上在操作:a[dfn[u]], a[dfn[u]+1], a[dfn[u]+2]..a[dfn[v]]
- 操作一个点到根节点路径上的所有关键值，本质上是在操作lg条重链（上一步）
- 操作两点间路径上所有的关键值（本题不需要），如果能处理LCA，本质上也是lg条重链
- 操作c的子树，记wei为c的重量，本质上在操作
a[dfn[c]],a[dfn[c]+1],a[dfn[c]+2],...a[dfn[c]+wei-1]

聪明的你一定不会傻傻的一个一个操作，而是用线段树喽，但本题我还会讲树状数组解法。

## 什么是长链剖分
长链剖分不如重链剖分应用广泛，本题不需要

重新定义son[c]为最长（或者叫深）的那个儿子，称作重(chang)儿子。

很可惜，长链剖分没有重链剖分“链少”的性质，它有时候链会多到根号n

![](https://cdn.luogu.com.cn/upload/pic/46912.png)

但是，有一个好消息，长链剖分有其特有的性质

设c的k级祖先为y，（即y是c的祖先且两点距离为k），记len[y]为y所在长链的长度，那么有：

len[y]>=k

在这张图中，此性质尤为明显，使重链剖分可叹而不可及!
![](https://cdn.luogu.com.cn/upload/pic/46943.png)

## 长链剖分有什么用

结合倍增nlgn预处理，他可以O(1)求节点c的k级祖先

1. 预处理lg[x],表示以2为底的对数下取整
1. 预处理顶点的属性：fa,de,len,son,g,dfn,其中len表示节点所在长链的长度
1. 预处理st表，st[c][k]是个二维数组，表示c的"2的k次方"级祖先的编号，显然k是lg级的，而且有递推式

 st[c][k]=st[st[c][k-1]][k-1]
 
1. 预处理两个
	
    vector<int> getup[maxn],
  
  	vector<int> getdown[maxn].
  	
    它们是二维的动态空间，含义如下。
    
    仅在c处于链顶时（其他情况getup[c],getdown[c]为空）
    
    getup[c][i]表示c的i级祖先，保证i<=len[c]
    
    getdown[c][i]表示在c链中的i级子孙,保证i<=len[c]
    
    时空复杂度均为len的和，也就是n。

1. **"过半跳"**,每次询问c的k级祖先，首先设y=st[c][lg[k]], r=c和y的距离。r可以用深度来减，也可以是2的lg[k]次方，那么

  r>=k/2,即
  
  r>=k-r  
1. **"跳链顶"**,

	tot=r+de[y]-de[g[y]],记录跳了多少步
    
    设z=g[y]跳到链顶
  
1. **不用写在程序里的小证明**

	我断言，c的k级祖先一定在向量getup[z]或getdown[z]里，理由如下。
 
 	根据长链的性质,len[y]>=r
    
    又r>=k-r
    
    所以
    
    len[z]=len[y]>=r>=r-k>=dis(z,c的k级祖先),
    
    如下图，颜色越粗表示越长
    ![](https://cdn.luogu.com.cn/upload/pic/46929.png)
    
    此时c的k级祖先在 getup[z]中
    
    当然还有c的k级祖先在getdown[z]的情况
    
1. **直接跳**，返回getup[z][k-tot]。或者返回getdown[z][tot-k]



------------
# 什么是超级树状数组

超级树状数组有，

2种基本操作：区间累加、前缀求和

1种延伸操作：区间求和（用前缀和减）

的nlgn数据结构，本质上是维护2个树状数组。虽然应用不如线段树广泛，但是代码短、细节少。

## 什么是树状数组

树状数组本质上有2种基本操作:单点累加，前缀求和。1种延伸操作:区间求和（用前缀和减）。简单地发一下代码：


```cpp
void ADD(LL *a,LL i,LL x)//单点加 
{
    if(i>n) return;
    a[i]+=x;
    ADD(a,i+lowbit(i),x);
}

LL ASK(LL *a,LL i)//前缀求和 
{
    if(i==0) return 0;
    return ASK(a,i-lowbit(i))+a[i];
}

```

假设各位大佬已经会树状数组了，我们继续讨论

## 开始推公式

![](https://cdn.luogu.com.cn/upload/pic/46937.png)

## 代码

注意我用大小写区分层次
```cpp
LL lowbit(LL x){return x&(-x);}
void ADD(LL *a,LL i,LL x)//单点加 
{
    if(i>n) return;
    a[i]+=x;
    ADD(a,i+lowbit(i),x);
}

LL ASK(LL *a,LL i)//前缀求和 
{
    if(i==0) return 0;
    return ASK(a,i-lowbit(i))+a[i];
}
void Add(LL l,LL r,LL x)//区间加 
{
    //printf("Add %lld %lld %lld\n",l,r,x);
    ADD(d,l,x);
    ADD(d,r+1,-x);
    ADD(fd,l,x*(l-1));
    ADD(fd,r+1,-x*r);
}

LL Ask_(LL r)//前缀求和 
{
    return r*ASK(d,r)-ASK(fd,r); 
}
LL Ask(LL l,LL r)//区间求和 
{
    //printf("Ask %lld %lld\n",l,r);
    return Ask_(r)-Ask_(l-1);
}
```



------------
# 总代码

个人觉得码风不错

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
const LL maxn=200001;
const LL maxm=2*maxn;

LL hea[maxn],nex[maxm],poi[maxm];
LL w[maxn];
LL fa[maxn],de[maxn],wei[maxn],son[maxn];
LL g[maxn],dfn[maxn];
LL d[maxn],fd[maxn];
LL n,Q,i,j,k,t,x,y,type,u;

LL max(LL x,LL y){return x>y?x:y;}
LL lowbit(LL x){return x&(-x);}
void ADD(LL *a,LL i,LL x)//单点加 
{
    if(i>n) return;
    a[i]+=x;
    ADD(a,i+lowbit(i),x);
}

LL ASK(LL *a,LL i)//前缀求和 
{
    if(i==0) return 0;
    return ASK(a,i-lowbit(i))+a[i];
}
void Add(LL l,LL r,LL x)//区间加 
{
    //printf("Add %lld %lld %lld\n",l,r,x);
    ADD(d,l,x);
    ADD(d,r+1,-x);
    ADD(fd,l,x*(l-1));
    ADD(fd,r+1,-x*r);
}

LL Ask_(LL r)//前缀求和 
{
    return r*ASK(d,r)-ASK(fd,r); 
}
LL Ask(LL l,LL r)//区间求和 
{
    //printf("Ask %lld %lld\n",l,r);
    return Ask_(r)-Ask_(l-1);
}
LL ask(LL u)
{
    //printf("ask %lld\n",u);
    if(g[u]==g[1]) return Ask(dfn[1],dfn[u]);else
    return
        Ask(dfn[g[u]],dfn[u])+ask(fa[g[u]]);
}
void PW(LL i,LL j)
{
    k++;
    poi[k]=j;nex[k]=hea[i];hea[i]=k;
}

void PW2(LL i,LL j)
{
    PW(i,j);PW(j,i);
}

void dfs1(LL c,LL from)//第一遍dfs，置好fa,de,wei,son 
{
    LL i,y;
    fa[c]=from;
    de[c]=de[from]+1;
    wei[c]=1;
    son[c]=0;wei[0]=0;
    for(i=hea[c];i;i=nex[i])
    {
        y=poi[i];
        if(y==from) continue;
        dfs1(y,c);
        wei[c]+=wei[y];
        if(wei[y]>wei[son[c]])
            son[c]=y;//最重的儿子 
    }
}
void dfs2(LL c,LL from)//第二遍dfs，置好dfn和g 
{
    LL i,y;
    //printf("%lld\n",c);
    dfn[c]=++dfn[0];
    g[c]=son[from]==c?g[from]:c;//g定义为链顶 
    if(son[c])dfs2(son[c],c);//优先访问重儿子（最偏爱的儿子） 
    for(i=hea[c];i;i=nex[i])
    {
        y=poi[i];
        if(y==from||y==son[c]) continue;
        dfs2(y,c);
    }
}

int main()
{
    scanf("%lld%lld",&n,&Q);
    for(i=1;i<=n;i++) scanf("%lld",&w[i]);
    for(i=1;i<n;i++)
    {
        scanf("%lld%lld",&j,&t);
        PW2(j,t);
    }
    dfs1(1,0);
    dfs2(1,0);
    //for(i=1;i<=n;i++)
    //	printf("i=%lld dfn=%lld fa=%lld son=%lld g=%lld\n",i,dfn[i],fa[i],son[i],g[i]);
    for(i=1;i<=n;i++)
        Add(dfn[i],dfn[i],w[i]);
    while(Q--)
    {
        scanf("%lld%lld",&type,&u);
        if(type==1)
        {
            scanf("%lld",&x);
            Add(dfn[u],dfn[u],x);
        }else
        if(type==2)
        {
            scanf("%lld",&x);
            Add(dfn[u],dfn[u]+wei[u]-1,x);
        }else
        {
            printf("%lld\n",ask(u));
        }
    }
}
```


---

## 作者：KingBenQi (赞：14)

Solution
---
树链剖分板子题
在树上支持单点修改,子树修改,路径求和三种操作
用线段树维护
一定要开long long!!!!
```
#include<bits/stdc++.h> 
using namespace std;
#define LL long long
const int maxn=500000+10;
inline LL gi(){
    char ch=getchar();LL x=0,q=0;
    while(ch<'0' || ch>'9') ch=='-'?q=1:0,ch=getchar();
    while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
    return q?(-x):x;
}
#define mid ((l+r)>>1)  
#define lson rt<<1,l,mid
#define rson rt<<1|1,mid+1,r
#define len (r-l+1)
LL n,m;
struct Edge{
	LL next,to;
	
}h[maxn<<1];
LL head[maxn<<1];
LL tot,to[maxn],w[maxn],wt[maxn];
LL a[maxn<<2],laz[maxn<<2];
LL son[maxn],id[maxn],fa[maxn],cnt,dep[maxn],siz[maxn],top[maxn]; 
LL res=0;
inline void Add(LL u,LL v){
	h[++tot].next=head[u];
	h[tot].to=v;
	head[u]=tot;
}
inline void pushdown(LL rt,LL lenn){
    laz[rt<<1]+=laz[rt];
    laz[rt<<1|1]+=laz[rt];
    a[rt<<1]+=laz[rt]*(lenn-(lenn>>1));
    a[rt<<1|1]+=laz[rt]*(lenn>>1);
    laz[rt]=0;
}
inline void build(LL rt,LL l,LL r){
    if(l==r){
        a[rt]=wt[l];
        return;
    }
    build(lson);
    build(rson);
    a[rt]=(a[rt<<1]+a[rt<<1|1]);
}
inline void query(LL rt,LL l,LL r,LL L,LL R){
    if(L<=l&&r<=R){
		res+=a[rt];
		return;
	}
    else{
        if(laz[rt])pushdown(rt,len);
        if(L<=mid)query(lson,L,R);
        if(R>mid)query(rson,L,R);
    }
}
inline void update(LL rt,LL l,LL r,LL L,LL R,LL k){
    if(L<=l&&r<=R){
        laz[rt]+=k;
        a[rt]+=k*len;
    }
    else{
        if(laz[rt])pushdown(rt,len);
        if(L<=mid)update(lson,L,R,k);
        if(R>mid)update(rson,L,R,k);
        a[rt]=(a[rt<<1]+a[rt<<1|1]);
    }
}
inline LL qRange(LL x,LL y){
    LL ans=0;
    while(top[x]!=top[y]){
        if(dep[top[x]]<dep[top[y]])swap(x,y);
        res=0;
        query(1,1,n,id[top[x]],id[x]);
        ans+=res; 
        x=fa[top[x]];
    }
    if(dep[x]>dep[y])swap(x,y);
    res=0;
    query(1,1,n,id[x],id[y]);
    ans+=res;
    return ans;
}
inline void updSon(LL x,LL k){
    update(1,1,n,id[x],id[x]+siz[x]-1,k);
}

inline void dfs1(LL x,LL f,LL deep){
    dep[x]=deep; 
    fa[x]=f;
    siz[x]=1; 
    LL maxson=-1;
    for(LL i=head[x];i;i=h[i].next){
        LL y=h[i].to;
        if(y==f)continue;
        dfs1(y,x,deep+1); 
        siz[x]+=siz[y]; 
        if(siz[y]>maxson)son[x]=y,maxson=siz[y];
    }
}

inline void dfs2(LL x,LL topf){
    id[x]=++cnt;
    wt[cnt]=w[x];
    top[x]=topf;
    if(!son[x])return;
    dfs2(son[x],topf);
    for(LL i=head[x];i;i=h[i].next){
        LL y=h[i].to;
        if(y==fa[x]||y==son[x])continue;
        dfs2(y,y);
    }
}

int main(){
    n=gi();m=gi();
    for(LL i=1;i<=n;i++)w[i]=gi();
    for(LL i=1;i<n;i++){
        LL a,b;
		a=gi();b=gi();
        Add(a,b);
		Add(b,a);
    }
    dfs1(1,0,1);
    dfs2(1,1);
    build(1,1,n);
    while(m--){
        LL k,x,y,z;
        k=gi();
        if(k==1){
            x=gi();y=gi();
			update(1,1,n,id[x],id[x],y);
		}
        else if(k==2){
            x=gi();y=gi();
            updSon(x,y);
        }
        else{
            x=gi();
            printf("%ld\n",qRange(1,x));
        }
    }
	return 0;
}


```

---

## 作者：小糯米 (赞：7)

首先说说重链序：

第一次dfs，算出dep[]、fa[N]、size[N]、son[N]，其中son[x]通过size[y]计算最大值得到。

第二次dfs，传入x和链首元素tp：

对其儿子列表，首先递归son[x]，然后再递归其它儿子（轻儿子）
重儿子递归，tp元素不变，轻儿子递归，tp改成轻儿子自己
每个结点都存储到o[++last]=x里，同时存储p[x]=last
最后，输出o[N]即为重链剖分以后的序。

首先树链剖分得到重链序，然后考虑操作：


1-单点更新：

2-区间更新：以某点为根的区间是p[x]和p[x]+size[x]-1，刚好连续

3-求路径：某点到根的路径，可以按重链、跳、重链…的组合来实现，也即多个区间的和组合起来。

显然，可以用线段树来维护区间操作和查询。

AC代码：

```cpp
#include <cstdio>
#include <iostream>
#include <vector>
using namespace std;
const int N = 1e5 + 1;
typedef long long ll;
ll n, m, fa[N], top[N], siz[N], son[N], o[N], las, p[N], v[N];
bool vis[N];
vector<ll> g[N];
inline ll read()
{
    ll x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = (x << 3) + (x << 1) + (ch ^ 48);
        ch = getchar();
    }
    return x * f;
}
void dfs1(ll x, ll fat, ll len)
{
    fa[x] = fat;
    siz[x] = 1;
    for (ll i = 0; i < g[x].size(); ++i)
    {
        ll y = g[x][i];
        if (y == fat)
            continue;
        dfs1(y, x, len + 1);
        siz[x] += siz[y];
        if (siz[y] > siz[son[x]])
            son[x] = y;
    }
}
void dfs2(ll x, ll dp)
{
    top[x] = dp;
    o[++las] = v[x];
    p[x] = las;
    if (son[x] == 0)
        return;
    dfs2(son[x], dp);
    for (ll i = 0; i < g[x].size(); ++i)
    {
        ll y = g[x][i];
        if (y == fa[x] || y == son[x])
            continue;
        dfs2(y, y);
    }
}
struct node
{
    ll l, r, sum, tag;
    ll len()
    {
        return r - l + 1;
    }
};
node tree[4 * N];
void bud(ll l, ll r, ll k)
{
    tree[k].l = l;
    tree[k].r = r;
    if (l == r)
    {
        tree[k].sum = o[l];
        return;
    }
    ll mid = (l + r) / 2;
    bud(l, mid, 2 * k);
    bud(mid + 1, r, 2 * k + 1);
    tree[k].sum = tree[2 * k].sum + tree[2 * k + 1].sum;
}
void but(ll k, ll tag)
{
    tree[k].sum += tree[k].len() * tag;
    tree[k].tag += tag;
}
void pud(ll k)
{
    but(2 * k, tree[k].tag);
    but(2 * k + 1, tree[k].tag);
    tree[k].tag = 0;
}
void upd(ll x, ll y, ll a, ll k)
{
    ll l = tree[k].l, r = tree[k].r;
    if (x <= l && y >= r)
    {
        but(k, a);
        return;
    }
    if (tree[k].tag)
        pud(k);
    ll mid = (l + r) / 2;
    if (x <= mid)
        upd(x, y, a, 2 * k);
    if (y >= mid + 1)
        upd(x, y, a, 2 * k + 1);
    tree[k].sum = tree[2 * k].sum + tree[2 * k + 1].sum;
}
ll que(ll x, ll y, ll k)
{
    ll l = tree[k].l, r = tree[k].r;
    if (x <= l && y >= r)
        return tree[k].sum;
    if (tree[k].tag)
        pud(k);
    ll mid = (l + r) / 2, ans = 0;
    if (x <= mid)
        ans += que(x, y, 2 * k);
    if (y >= mid + 1)
        ans += que(x, y, 2 * k + 1);
    return ans;
}
int main()
{
    n = read();
    m = read();
    for (ll i = 1; i <= n; ++i)
        v[i] = read();
    for (ll i = 1; i <= n - 1; ++i)
    {
        ll x, y;
        x = read();
        y = read();
        g[x].push_back(y);
        g[y].push_back(x);
    }
    dfs1(1, 0, 1);
    dfs2(1, 1);
    bud(1, n, 1);
    for (ll i = 1; i <= m; ++i)
    {
        ll cmd, x, a;
        cmd = read();
        x = read();
        if (cmd == 1)
        {
            a = read();
            upd(p[x], p[x], a, 1);
        }
        if (cmd == 2)
        {
            a = read();
            upd(p[x], p[x] + siz[x] - 1, a, 1);
        }
        if (cmd == 3)
        {
            ll sum = 0;
            while (top[x] != 1)
            {
                sum += que(p[top[x]], p[x], 1);
                x = fa[top[x]];
            }
            sum += que(1, p[x], 1);
            printf("%lld\n", sum);
        }
    }
    return 0;
}
```

---

## 作者：wshl (赞：6)

题解：本题主要考察树链剖分
- 简要题意：树上操作：
- 操作 1 ：把某个节点$x$的点权增加$a$。
- 操作 2 ：把某个节点$x$为根的子树中所有点的点权都增加$a$。
- 操作 3 ：询问某个节点$x$ 
- 1.树链剖分：线段树求区间和与单点修改，区间查询，接下来就是树链剖分的模板
- 三年OI一场空，不开$longlong$见祖宗
- 代码如下：
```
#include<iostream>
#include<algorithm>
using namespace std;
#define ll long long
struct N
{
	ll ans,lazy;
}t[866006];
struct E
{
	ll start,to;
}e[866006];
ll a[666666];
ll siz[200005],d[200005],f[200005],h[200005];
ll top[200005],rk[200005],son[200005],id[200005];
ll n,m,P,num;
void pushup(ll p)
{
	t[p].ans=t[p*2].ans+t[p*2+1].ans;
	return ;
}
void build(ll p,ll l,ll r)
{
	if(l==r){t[p].ans=rk[l];t[p].lazy=0;return ;}
	ll mid=l+r>>1;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
	pushup(p);
}
void lai(ll p,ll l,ll r)
{
	ll mid=l+r>>1;
	if(t[p].lazy)
	{
		t[p*2].ans+=t[p].lazy*(mid-l+1);
		t[p*2+1].ans+=t[p].lazy*(r-mid);
		t[p*2].lazy+=t[p].lazy;
		t[p*2+1].lazy+=t[p].lazy;
		t[p].lazy=0;
	}
	return ;
}
void change(ll p,ll l,ll r,ll x,ll y,ll z)
{
	if(x<=l&&y>=r)
	{
		t[p].ans+=z*(r-l+1);
		t[p].lazy+=z;
		return ;
	}
	lai(p,l,r);
	ll mid=l+r>>1;
	if(x<=mid)change(p*2,l,mid,x,y,z);
	if(y>mid)change(p*2+1,mid+1,r,x,y,z);
	pushup(p);
}
long long ask(ll p,ll l,ll r,ll x,ll y)
{
	if(x<=l&&y>=r)return t[p].ans;
	lai(p,l,r);
	int mid=l+r>>1;
	long long ans=0;
	if(x<=mid)ans+=ask(p*2,l,mid,x,y);
	if(y>mid)ans+=ask(p*2+1,mid+1,r,x,y);
	return ans;
}
void add(ll start,ll to)
{
	e[++P].to=to;
	e[P].start=h[start];
	h[start]=P;
}
void dfs1(ll p,ll fa,ll deep)
{
    f[p]=fa;siz[p]=1;d[p]=deep;
    for(ll i=h[p];i;i=e[i].start)
	{
        ll k=e[i].to;
        if(k==fa)continue;
        dfs1(k,p,deep+1);
        siz[p]+=siz[k];
        if(siz[k]>siz[son[p]])son[p]=k;
    }
}
void dfs2(ll p,ll tp)
{
    id[p]=++num;rk[num]=a[p];top[p]=tp;
    if(!son[p]) return;
    dfs2(son[p],tp);
    for(ll i=h[p];i;i=e[i].start)
	{
        ll k=e[i].to;
        if(k==f[p]||k==son[p]) continue;
        dfs2(k,k);
    }
}
long long sum(ll x,ll y)
{
    long long ans=0;
    while(top[x]!=top[y])
	{
        if(d[top[x]]<d[top[y]])swap(x,y);
        ans+=ask(1,1,n,id[top[x]],id[x]);
        x=f[top[x]];
    }
    if(d[x]>d[y])swap(x,y);
    ans+=ask(1,1,n,id[x],id[y]);
    return ans;
}
int main()
{
	cin>>n>>m;
	for(ll i=1;i<=n;i++)cin>>a[i];
	for(ll i=1;i<=n-1;i++)
	{
		ll x,y;
		cin>>x>>y;
		add(x,y);add(y,x);
	}
	d[1]=1;
	dfs1(1,0,1);dfs2(1,1);
	build(1,1,n);
	while(m--)
	{
		ll q,x,y;
		cin>>q;
		if(q==1)
		{
			cin>>x>>y;
			change(1,1,n,id[x],id[x],y);
		}
		if(q==2)
		{
			cin>>x>>y;
			change(1,1,n,id[x],id[x]+siz[x]-1,y);
		}
		if(q==3)
		{
			cin>>x;
			cout<<sum(x,1)<<endl;
		}
	}
	return 0;
}
```

---

## 作者：Hope2075 (赞：5)

给出一种分治做法

（这个做法具体叫什么我也不知道，欢迎dalao指出）

基本思路是：递归处理左右两边后，用左边所有修改操作更新右边所有查询操作

首先一遍DFS求出DFS序，求出对应子树的范围，并捎带把初始数值和深度求出来以备之后使用

求出DFS序后，树的结构就基本没用了，可以把所有点薅下来（点：为什么要把我薅下来），把树拍扁

考虑一个修改对一个询问什么情况下会产生贡献，会产生多大贡献

对于修改操作，受到影响的只有这个子树内的点

单点修改会使整棵子树内的询问增加一个固定值

修改整棵子树则会使该子树内的询问增加不同的值，这个值与点的深度有关，数值与深度的关系是一个一次函数

修改之间彼此独立，也就是可以以任意顺序更新

很明显，处理时可以让左右两边按DFS序排序

然后考虑怎样更新

先给出样例的一种DFS序，如果后面不好理解，可以回来看看这个

```
[1[2[3][5]][4]]
```

所以维护一个栈，记录能影响到当前点的操作

每次更新时，根据点的深度和栈里的情况更新

如果只有单点修改，只要记录栈内修改操作数值之和就可以

但是修改子树就有些麻烦

因为贡献与深度有关，考虑维护受深度影响的部分，更新时将这部分乘以深度，加上就可以

这样会多算一些，只要把多算的部分从不受深度影响的部分减去就可以

当操作被弹出栈时，把对这两个数值进行的操作撤销就可以

但是，怎么实现？

每次枚举右边的点

当需要更新数值不同的点时，把已经不能影响到它的操作从栈里弹出

随后，把能影响到它的操作压入栈

注意：有些操作可能永远不能更新右边的点

这部分点直接跳过就可以，~~或者也压栈以WA~~ ~~（我开始就这么干的）~~

接下来，把相同数值的点全部更新

当然，如果一次只更新一个也可以，这样这些点都被更新完毕前不会影响栈内的情况

重复操作，直到更新完毕

为什么这样更新可以：

首先，保证有序时，操作的影响范围是一段连续区间，且左端点是单调的（这个点就是它自身）

不同操作的影响范围只能包含或相离

可以考虑扫描线

当扫到一个区间起点时，入栈

当扫到终点时出栈

这样会发现，栈顶始终是不包含任何栈内区间的操作

能保证正确

如果不好理解，可以用线段树等数据结构维护，这样复杂度会多一个$\log m$，也许能过

每更新完一层，会发现两边分别是有序的，所以把两边归并一下就能使整体有序（按DFS序）

更新完后，把所有操作按输入顺序排序，然后输出就可以

这样，每层次操作复杂度是$O(m)$，一共$O(\log m)$层

最后复杂度是$O(n+m \log m)$的

但是这样写细节很多，容易WA,TLE,MLE,RE(qwq)

所以一定要细心

最后是码了一上午才AC的代码：

（既然前面已经写归并了，最后处理时也弄个归并排序吧）
```cpp
#include<iostream>
#define next orz
using namespace std;
const int N=100007;
int head[N],next[N*2],ver[N*2],tot;
long long v[N];
int pid[N],cur=1;
long long dis[N];
long long dep[N];
int rb[N];
void add(int a,int b){
	tot++;
	ver[tot]=b;
	next[tot]=head[a];
	head[a]=tot;
	tot++;
	ver[tot]=a;
	next[tot]=head[b];
	head[b]=tot;
}
void dfs(int id,int pa){
	pid[id]=cur++;
	dis[id]=dis[pa]+v[id];
	dep[id]=dep[pa]+1;
	for(int i=head[id];i;i=next[i]){
		if(ver[i]==pa)continue;
		dfs(ver[i],id);
	}
	rb[id]=cur-1;
}
struct opt{
	char type;
	int id;
	long long num;
	int order;
};
inline bool cmp(int a,int b){
	return pid[a]<pid[b];
}
inline bool operator<(opt a,opt b){
	return cmp(a.id,b.id);
}
inline bool cmp2(opt a,opt b){
	return a.order<b.order;
}
opt qlist[N];int cnt;
opt slist[N];
long long sum[N],dsum[N];
int n,m;
int st[N],top;
void calc(int l,int r){
	if(l==r)return;
	int mid=((l+r)>>1);
	calc(l,mid);
	calc(mid+1,r);
	int i=l,j=mid+1,p;
	int cur;
	long long csum=0,cdsum=0;
	top=0;
	while(j<=r){
		p=pid[qlist[j].id];
		while(top&&rb[qlist[st[top-1]].id]<p){
			cur=st[--top];
			if(qlist[cur].type==1){
				csum-=qlist[cur].num;
			}else if(qlist[cur].type==2){
				cdsum-=qlist[cur].num;
				csum+=qlist[cur].num*(dep[qlist[cur].id]-1);
			}
		}
		while(i<=mid&&pid[qlist[i].id]<=p){
			if(i<=mid&&rb[qlist[i].id]<p){
				i++;
				continue;
			}
			if(qlist[i].type==1){
				csum+=qlist[i].num;
				st[top++]=i;
			}else if(qlist[i].type==2){
				cdsum+=qlist[i].num;
				csum-=qlist[i].num*(dep[qlist[i].id]-1);
				st[top++]=i;
			}
			i++;
		}
		while(j<=r&&pid[qlist[j].id]==p){
			if(qlist[j].type==3){
				qlist[j].num=qlist[j].num+csum+cdsum*(dep[qlist[j].id]);
			}
			j++;
		}
	}
	i=l;j=mid+1;p=l;
	while(i<=mid&&j<=r){
		if(qlist[i]<qlist[j]){
			slist[p++]=qlist[i++];
		}else{
			slist[p++]=qlist[j++];
		}
	}
	while(i<=mid){
		slist[p++]=qlist[i++];
	}
	while(j<=r){
		slist[p++]=qlist[j++];
	}
	for(i=l;i<=r;i++)qlist[i]=slist[i];
}
void msort(int l,int r){
	if(l==r)return;
	int mid=((l+r)>>1);
	msort(l,mid);
	msort(mid+1,r);
	int i=l,j=mid+1,p=l;
	while(i<=mid&&j<=r){
		if(cmp2(qlist[i],qlist[j])){
			slist[p++]=qlist[i++];
		}else{
			slist[p++]=qlist[j++];
		}
	}
	while(i<=mid){
		slist[p++]=qlist[i++];
	}
	while(j<=r){
		slist[p++]=qlist[j++];
	}
	for(i=l;i<=r;i++)qlist[i]=slist[i];
}
int main(){
	//freopen("3178.in","r",stdin);
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>v[i];
	}
	for(int i=1,a,b;i<n;i++){
		cin>>a>>b;
		add(a,b);
	}
	dfs(1,0);
	pid[n+1]=0x7fffffff;
	for(int i=0,a;i<m;i++){
		cin>>a;
		qlist[i].type=a;
		cin>>qlist[i].id;
		if(a!=3){
			cin>>qlist[i].num;
		}else{
			qlist[i].num=dis[qlist[i].id];
		}
		qlist[i].order=i;
	}
	calc(0,m-1);
	msort(0,m-1);
	for(int i=0;i<m;i++){
		if(qlist[i].type==3){
			cout<<qlist[i].num<<endl;
		}
	}
}
```

用时1243ms(无氧) 970ms(氧化)

如果优化归并过程，可能会更快

---

## 作者：yijan (赞：5)

~~NOIP前一天还来水题解~~

竟然有一样脑回路新奇的题解。。只是不太明白为啥要用线段树维护~~Fenwicktree吼啊~~

首先把这个树的euler tour跑出来。首先考虑单点修改：

我们知道在欧拉序上一个点刚刚被访问要记录一次，离开会记录一次，于是我们在刚刚访问的位置+c，离开位置-c；

对于一个路径查询，我们需要计算一下1-这个点的前缀和，可以考虑树状数组。查询是进入还是离开的点呢？实际上都一样，因为进入离开之间所有点必定是两两配对的，所以算出来肯定是0.

考虑子树修改稍显麻烦，在一个点用一个树状数组记录+(dep[x]-1)*c（进入时加离开时减），

同时用一个等同于单点修改的记录一下+c，

当我们查询时，考虑所有加子树的贡献，就是  
（u查询点）sum1是+c,sum0是+c*(dep[x-1])

$sum1(in[u])*dep[u] - sum0(in[u])$

然后考虑完所有单点加和子树加的贡献，就仅仅需要再计算一下初始到根的权值和就好。

代码非常简洁QWQ1.6k速度碾压树剖（实际上在此之前也写过一个树剖）

```cpp
/*Heroes Never Die!*/
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
#define MAXN 100006
struct edge{
	ll u;edge* next;
	edge( ll u = 0 , edge* next = NULL ):u(u),next(next) {}
	void insert( ll u ) {
		if( this->next == NULL ) this->next = new edge(u,NULL);
		else this->next = new edge( u,this->next );
	}
}e[MAXN];
ll in[MAXN],out[MAXN] , n , N , m , sdep[MAXN] , w[MAXN] , dep[MAXN];
ll S[3][MAXN<<1];//0 : 单点更值 ， 1 值*dep 2 个数
void add( ll x , ll c , ll p ) { while( x <= N ) S[p][x] += c , x += x&-x; }
ll sum( ll x , ll p ) { ll res = 0; while( x > 0 ) res += S[p][x], x -= x & -x; return res; }
void addpoint( ll x ,ll c ) {
	add( in[x] , c , 0 ) , add( out[x] , -c , 0 );
}
void add_sub( ll x , ll c ) {
	add( in[x] , c*(dep[x]-1) , 1 ) , add( out[x] , -c*(dep[x]-1) , 1 ),
	add( in[x] , c , 2 ) , add( out[x] , -c , 2 );
}
ll query( ll x ) {
	return sdep[x] + sum(in[x],0) + dep[x] * sum( in[x],2 ) - sum(in[x],1);
}
void dfs( ll u , ll fa ) {
	in[u] = ++N;
	for( edge* n = e[u].next;n!=NULL;n=n->next ) {
		ll v = n->u;
		if( v == fa ) continue;
		sdep[v] = w[v] + sdep[u] , dep[v] = dep[u] + 1;
		dfs(v , u);
	}
	out[u] = ++N;
}
int main() {
	freopen("input","r",stdin);
	freopen("o","w",stdout);
	cin >> n >> m;
	for( ll i = 1  ; i <= n ; ++ i ) scanf("%lld",&w[i]);
	for( ll i = 0 ,u,v ; i < n - 1 ; ++ i )
		scanf("%lld%lld",&u,&v),e[u].insert(v),e[v].insert(u);
	sdep[1] = w[1] , dep[1] = 1;
	dfs( 1 , 1 );
	for( ll i = 0,opt,u,v ; i < m ; ++ i ){
		scanf("%lld%lld",&opt,&u);
		if( opt == 1 ) scanf("%lld",&v) , addpoint(u,v);
		else if( opt == 2 ) scanf("%lld",&v) , add_sub(u,v);
		else printf("%lld\n",query(u));
	}	
}
//qwq
```

考虑树剖的话，如果不抄板子我们知道只需要统计到根。。所以查询一个while就够了，具体看代码：

```cpp
/*Heroes Never Die!*/
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
typedef long long ll;
using namespace std;
#define MAXN 100006
struct edge{
    ll u;edge* next;
    edge(ll u=0,edge* next=NULL):u(u),next(next) {}
    void insert( ll u ) {
        if(this->next == NULL) this->next = new edge(u,NULL);
        else this->next = new edge(u,this->next);
    }
}e[MAXN];
ll siz[MAXN] , hea[MAXN] , pre[MAXN] , top[MAXN] , tig[MAXN] , bac[MAXN] , dep[MAXN],cnt;
ll w[MAXN] ;
ll n , m;
void dfs(ll u,ll fa) {
    siz[u] = 1;
    for( edge* n = e[u].next;n!=NULL;n=n->next ) {
        ll v = n->u;
        if(v == fa) continue;
        dep[v] = dep[u] + 1 , pre[v] = u;
        dfs(v,u);
        siz[u] += siz[v];
        if(!hea[u]||siz[hea[u]] < siz[v]) hea[u] = v;
    }
}
void dfs2(ll u,ll to) {
    tig[u] = ++cnt , bac[cnt] = u , top[u] = to;
    if( !hea[u] )return;
    dfs2(hea[u] , to);
    for( edge* n = e[u].next;n!=NULL;n=n->next ) {
        ll v = n->u;
        if( v == pre[u] || v == hea[u] ) continue;
        dfs2(v,v);
    }
}
ll S[MAXN<<2] , lazy[MAXN<<2];
void pushup( ll rt ) {
    S[rt] = S[rt<<1] + S[rt<<1|1];
}
void pushdown( ll rt , ll m ) {
    if( lazy[rt] ) {
        S[rt<<1] += lazy[rt] * ( m - (m>>1) ), 
        S[rt<<1|1] += lazy[rt] * ( m >> 1 ),
        lazy[rt<<1] += lazy[rt] , 
        lazy[rt<<1|1] += lazy[rt],
        lazy[rt] = 0;
    }
}
void build( ll rt ,ll l ,ll r ) {
    if( l == r ) { S[rt] = w[bac[l]] ; return; }
    ll m = l + r >> 1;
    build(rt<<1 , l , m);
    build(rt<<1|1 , m+1 , r);
    pushup( rt );
}
void update(ll rt,ll l,ll r,ll L,ll R,ll c){
    if( L <= l && R >= r ) { S[rt] += c*(r-l+1) , lazy[rt] += c; return; }
    ll m = l + r >> 1;
    pushdown(rt , r - l + 1);
    if( L <= m ) update( rt<<1 , l , m, L ,R, c );
    if( R >  m ) update( rt<<1|1, m+1 , r , L , R , c );
    pushup(rt);
}
ll query( ll rt, ll l,ll r,ll L,ll R ) {
    if( L <= l && R >= r ) return S[rt];
    pushdown(rt , r - l + 1);
    ll m = l + r >> 1, res = 0;
    if( L <= m ) res += query( rt<<1 , l , m , L , R );
    if( R >  m ) res += query( rt<<1|1 , m + 1, r , L, R );
    return res;
}
ll up( ll u ){
    ll res = 0;
    while( u ) {
        res += query( 1 , 1 , n , tig[top[u]] , tig[u] );
        u = pre[top[u]];
    }
    return res;
}
void add_point( ll u , ll c ) {
    update( 1 , 1 , n , tig[u] , tig[u] , c );
}
void add_sub( ll u , ll c ) {
    update( 1 , 1 , n , tig[u] , tig[u] + siz[u] - 1 , c );
}
int main() {
   // freopen("input","r",stdin);
//	freopen("o","w",stdout);
    cin >> n >> m;
    ll res = 0;
    for( ll i = 1 ; i <= n ; ++ i ) scanf("%lld",&w[i]),res += w[i];
    for( ll i = 0,u,v ; i < n-1 ; ++ i ) 
        scanf("%lld%lld",&u,&v) , e[u].insert(v), e[v].insert(u);
    dfs(1,1) , dfs2(1,1);
    build(1,1,n);
    for( ll i = 0,u,v,op ; i < m ; ++ i ) {
        scanf("%lld",&op);
        if( op == 1 ) scanf("%lld%lld",&u,&v),add_point(u,v);
        else if( op == 2 ) scanf("%lld%lld",&u,&v) , add_sub( u , v );
        else scanf("%lld",&u) , printf("%lld\n",up(u));
 	}
}



```

---

## 作者：QwQ蒟蒻wjr (赞：3)


>> 题目链接：[洛谷P3178 [HAOI2015]树上操作](https://www.luogu.org/problem/P3178)

这篇题解原发于[我的blog](https://wangjunrui.netlify.com/2019/10/23/%E6%B4%9B%E8%B0%B7-p3178-haoi2015-%E6%A0%91%E4%B8%8A%E6%93%8D%E4%BD%9C/)

这是一道树链剖分的板子题，纯粹的模板题~~事实上模板题比他难~~
事实上只要做过这道题[P3384 【模板】树链剖分](https://www.luogu.org/problem/P3384)就可以~~我把题目难度提升了~~

毕竟我是刚切完板子题的人，初生牛犊不怕虎，直接再打一遍练练手~~被逼的~~

记住因为这题没有提供取模的数，因为$10^6 \times10^5>2^{31}-1$，所以可能会爆$int$~~您要是想作死的话也可以~~，所以这道题只要懒标记和线段树上的累加$long\ long$使用即可，这样我就过了这道~~假紫题~~难题

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define ll long long
#define re register
#define ls (k<<1)
#define rs (k<<1|1)
template<typename T>
inline void read(T&x)
{
	x=0;
	char s=getchar();
	bool f=false;
	while(!(s>='0'&&s<='9'))
	{
		if(s=='-')
			f=true;
		s=getchar();
	}
	while(s>='0'&&s<='9')
	{
		x=(x<<1)+(x<<3)+s-'0';
		s=getchar();
	}
	if(f)
		x=(~x)+1;
	return;
}
const int N=1e5+10;
#define M (N<<1)
struct Edge
{
	int next,to;
} edge[M];
int num_edge,head[N];
int n,m,cnt,rk[N],id[N],dep[N],fa[N],top[N],son[N],size[N],num[N];
ll res;
struct Tree
{
	int l,r,size;
	ll lazy,sum;
} tree[N<<2];
inline void add_edge(int from,int to)
{
	edge[++num_edge].next=head[from];
	edge[num_edge].to=to;
	head[from]=num_edge;
}
inline void dfs1(int u,int f)
{
	dep[u]=dep[f]+1;
	fa[u]=f;
	size[u]=1;
	for(re int i=head[u]; i; i=edge[i].next)
	{
		int &v=edge[i].to;
		if(v==f)
			continue;
		dfs1(v,u);
		size[u]+=size[v];
		if(size[v]>size[son[u]])
			son[u]=v;
	}
}
inline void dfs2(int u,int tp)
{
	id[u]=++cnt;
	rk[cnt]=u;
	top[u]=tp;
	if(!son[u])
		return;
	dfs2(son[u],tp);
	for(re int i=head[u]; i; i=edge[i].next)
	{
		int &v=edge[i].to;
		if(id[v])
			continue;
		dfs2(v,v);
	}
	return;
}
inline void pushup(int k)
{
	tree[k].sum=tree[ls].sum+tree[rs].sum;
}
inline void pushdown(int k)
{
	if(!tree[k].lazy)
		return;
	tree[ls].lazy+=tree[k].lazy;
	tree[rs].lazy+=tree[k].lazy;
	tree[ls].sum+=tree[k].lazy*tree[ls].size;
	tree[rs].sum+=tree[k].lazy*tree[rs].size;
	tree[k].lazy=0;
}
inline void build(int k,int l,int r)
{
	tree[k].l=l;
	tree[k].r=r;
	tree[k].size=r-l+1;
	if(l==r)
	{
		tree[k].sum=num[rk[l]];
		return;
	}
	int mid=l+r>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	pushup(k);
	return;
}
inline void update(int k,int l,int r,int val)
{
	if(l<=tree[k].l&&tree[k].r<=r)
	{
		tree[k].sum+=(ll)val*tree[k].size;
		tree[k].lazy+=val;
		return;
	}
	pushdown(k);
	int mid=(tree[k].l+tree[k].r)>>1;
	if(l<=mid)
		update(ls,l,r,val);
	if(mid<r)
		update(rs,l,r,val);
	pushup(k);
	return;
}
inline void query(int k,int l,int r)
{
	if(l<=tree[k].l&&tree[k].r<=r)
	{
		res+=tree[k].sum;
		return;
	}
	pushdown(k);
	int mid=(tree[k].l+tree[k].r)>>1;
	if(l<=mid)
		query(ls,l,r);
	if(mid<r)
		query(rs,l,r);
}
inline ll ask(int x,int y)
{
	ll ans=0ll;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])
			swap(x,y);
		res=0;
		query(1,id[top[x]],id[x]);
		ans+=res;
		x=fa[top[x]];
	}
	if(dep[x]>dep[y])
		swap(x,y);
	res=0;
	query(1,id[x],id[y]);
	ans+=res;
	return ans;
}
int main()
{
	read(n),read(m);
	for(re int i=1; i<=n; ++i)
		read(num[i]);
	for(re int i=1,x,y; i<n; ++i)
	{
		read(x),read(y);
		add_edge(x,y);
		add_edge(y,x);
	}
	dfs1(1,0);
	dfs2(1,1);
	build(1,1,n);
	for(re int i=1,opt,x,y; i<=m; ++i)
	{
		read(opt);
		if(opt==1)
		{
			read(x),read(y);
			update(1,id[x],id[x],y);
		}
		else if(opt==2)
		{
			read(x),read(y);
			update(1,id[x],id[x]+size[x]-1,y);
		}
		else if(opt==3)
		{
			read(x);
			printf("%lld\n",ask(1,x));
		}
	}
	return 0;
}
```
~~马蜂差评~~

---

## 作者：Celtic (赞：2)

题目链接[树上操作](https://www.luogu.com.cn/problem/P3178)
#### 题意
- 有一棵点数为 n 的树，以点 1 为根，且点有点权。然后有 m 个操作，分为三种：

- 操作 1 ：把某个点 x 的点权增加 a 。

- 操作 2 ：把某个点 x 的子树中所有点的点权都增加 a 。

- 操作 3 ：询问某个点 x 到根的路径中所有点的点权和。

- n,m<=100000


------------
这题可以看作一个树剖的模板题。

再介绍一种做法。

先普及一个概念： 树的括号序列
- 在 $dfs $过程，进入一个点，就将一个左括号加入序列，退出一个点，就将一个右括号加入序列。这个序列，称为树的括号序列。

#### 思路
- 设 l[x]为x的左括号所在位置，r[x]为x的右括号所在位置。

- 给一个点 x 的点权加上一个数，就是给x子树中所有点到根路径的权值和加上这个数，即为给[l[x],r[x]-1] 加上这个数。在查询时询问 l[x] 处的值。

- 通过差分，可以转化为给 l[x]加上这个数，给 r[x] 减去这个数。在查询时询问 [1,l[x]] 的和。

- 那么，给一个点x子树里的所有点加上一个数，可以转化为区间加入一个数，贡献系数是区间里左括号个数-右括号个数。

- 时间复杂度O(nlogn)


------------

#### 代码
~~自己打~~

---

## 作者：切格瓦·星 (赞：2)

树链剖分固然可以搞，但是.......

#      ~~可以用树链剖分那就就用他啊~~

具体代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
struct edge{
	int v,next;
}e[N*4];
struct tree{
	int l,r;
	long long val,add;
}t[N*4];//用结构体存边和线段树. 
int n,m,a[N],cnt,sum,head[N];
int size[N],fath[N],dep[N],id[N],w[N],top[N],son[N];
//各个数组,意义下面有. 
void add(int u,int v){
	e[++cnt].v=v;
	e[cnt].next=head[u];
	head[u]=cnt;
}//建边. 
void spread(int p){
	if(t[p].add){
		t[p*2].val+=t[p].add*(t[p*2].r-t[p*2].l+1);
		t[p*2+1].val+=t[p].add*(t[p*2+1].r-t[p*2+1].l+1);
		t[p*2].add+=t[p].add;
		t[p*2+1].add+=t[p].add;
		t[p].add=0;
	}
}//下放标记. 
void dfs1(int u,int fa){
	fath[u]=fa;
	size[u]=1;
	for(int i=head[u];i;i=e[i].next){
		int v=e[i].v;
		if(v==fa) continue;
		dep[v]=dep[u]+1;
		dfs1(v,u);
		size[u]+=size[v];
		if(size[v]>size[son[u]])
			son[u]=v;
	}
}//第一个DFS求出每个点的父亲(fath[i]),以这个点为根的子树的节点数(size[i]),
 //当前点的重儿子(即这个点的子树中节点数最多的子树的根,son[i]),当前点的深度(dep[i]). 
void dfs2(int u,int topf){
	id[u]=++sum;
	w[sum]=a[u];
	top[u]=topf;
	if(!son[u]) return;
	dfs2(son[u],topf);
	for(int i=head[u];i;i=e[i].next){
		int v=e[i].v;
		if(v==fath[u]||v==son[u]) continue;
		dfs2(v,v);
	}
}//第二个DFS求出每个点所在链的顶点(top[i]),并把点的值附上新的编号以便进入线段树中(id[i],w[i]). 
void build(int p,int l,int r){
	t[p].l=l;t[p].r=r;
	if(l==r){
		t[p].val=w[l];
		t[p].add=0;
		return;
	}
	int mid=l+r>>1;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
	t[p].val=t[p*2].val+t[p*2+1].val;
}//建树 
void change(int p,int l,int r,int v){
	if(t[p].l>=l&&t[p].r<=r){
		t[p].val+=(long long)v*(t[p].r-t[p].l+1);
		t[p].add+=v;
		return;
	}
	spread(p);
	int mid=(t[p].l+t[p].r)>>1;
	if(mid>=l) change(p*2,l,r,v);
	if(mid<r) change(p*2+1,l,r,v);
	t[p].val=t[p*2].val+t[p*2+1].val;
}//单点查询和区间查询可以放到一起做. 
long long query(int p,int l,int r){
	if(t[p].l>=l&&t[p].r<=r)
		return t[p].val;
	spread(p);
	long long ans=0,mid=(t[p].l+t[p].r)>>1;
	if(mid>=l) ans+=query(p*2,l,r);
	if(mid<r) ans+=query(p*2+1,l,r);
	return ans;
}
long long qiuzhi(int x,int y){
	long long ans=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		ans+=query(1,id[top[x]],id[x]);
		x=fath[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	ans+=query(1,id[x],id[y]);
	return ans;
}//常规操作,计算两个点所连成的路径中所有点的点权和. 
int main(){
	//freopen("1.in","r",stdin);
	//freopen("1.out","w",stdout);//本人测试数据的时候打的 
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	int u,v;
	for(int i=1;i<n;i++){
		scanf("%d %d",&u,&v);
		add(u,v);
		add(v,u);
	}
	dep[1]=1;
	dfs1(1,-1);
	dfs2(1,1);
	build(1,1,n);
	int opt,x;
	for(int i=1;i<=m;i++){
		scanf("%d",&opt);
		if(opt==1){
			scanf("%d %d",&x,&v);
			change(1,id[x],id[x],v);
		}
		else if(opt==2){
			scanf("%d %d",&x,&v);
			change(1,id[x],id[x]+size[x]-1,v);
			//区间id[x]到id[x]+size[x]-1就可以表示以x为根的子树,想想为什么可以. 
		}
		else if(opt==3){
			scanf("%d",&x);
			cout<<qiuzhi(x,1)<<endl;
		}
	}
	return 0;
}
```


---

## 作者：Nice卡卡西 (赞：2)

### 感~~受一下神马是真正的恶心~~
#### 这道题还算是比较裸的树链剖分，题面当中的3种操作比较符合树链剖分的用途：
将二维的树化成一维的链，利用线段树进行数据维护
话不多说，奉上蒟蒻的code：
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
#define int long long
const int maxn=2e5+10;
inline int read()
{
	int s=0,w=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')
			w=-w;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		s=s*10+c-'0';
		c=getchar();
	}
	return s*w;
}
int n,m;
int e,beg[maxn],nex[maxn],to[maxn],w[maxn],wt[maxn];
int a[maxn<<2],laz[maxn<<2];
int son[maxn],id[maxn],fa[maxn],cnt,dep[maxn],siz[maxn],top[maxn]; 
int res=0;
//id[]表示时间戳（即在链当中的编号）
//dep[]表示该节点的深度
//siz[]表示该节点子树的大小【方便修改子树数值时调用线段树】
//top[]表示重量开端 
#define mid ((l+r)>>1)
#define lson rt<<1,l,mid
#define rson rt<<1|1,mid+1,r
#define len (r-l+1)
inline void add(int x,int y)//链式前向星 
{
    to[++e]=y;
    nex[e]=beg[x];
    beg[x]=e;
}
//-----------------------以下为线段树----------------------------------- 
inline void build(int rt,int l,int r)
{
    if(l==r)
	{
        a[rt]=wt[l];
        return;
    }
    build(lson);
    build(rson);
    a[rt]=(a[rt<<1]+a[rt<<1|1]);
}
inline void pushdown(int rt,int lenn)
{
    laz[rt<<1]+=laz[rt];
    laz[rt<<1|1]+=laz[rt];
    a[rt<<1]+=laz[rt]*(lenn-(lenn>>1));
    a[rt<<1|1]+=laz[rt]*(lenn>>1);
    laz[rt]=0;
}
inline void query(int rt,int l,int r,int L,int R)
{
    if(L<=l&&r<=R)
	{
	    res+=a[rt];
		return;
	}
    else
	{
        if(laz[rt])
		    pushdown(rt,len);
        if(L<=mid)
		    query(lson,L,R);
        if(R>mid)
		    query(rson,L,R);
    }
}
void update(int node,int left,int right,int pos,int v)
{
	if(left==right)
	{
		a[node]+=v;
		return ;
	}
	int midn=(left+right)/2;
    if(laz[node])//注意：单点修改可能会影响lazy标记，需要处理一下 
		pushdown(node,right-left+1);
	if(pos<=midn)
	{
		update(2*node,left,midn,pos,v);
	}
	else
	{
		update(2*node+1,midn+1,right,pos,v);
	}
	a[node]=a[2*node]+a[2*node+1];
}
inline void updata(int rt,int l,int r,int L,int R,int k)
{
    if(L<=l&&r<=R)
	{
        laz[rt]+=k;
        a[rt]+=k*len;
    }
    else
	{
        if(laz[rt])
		    pushdown(rt,len);
        if(L<=mid)
		    updata(lson,L,R,k);
        if(R>mid)
		    updata(rson,L,R,k);
        a[rt]=(a[rt<<1]+a[rt<<1|1]);
    }
}
//-----------------------以上为线段树----------------------------------- 
inline void dfs1(int x,int f,int deep)
{
    dep[x]=deep;
    fa[x]=f;
    siz[x]=1;
    int maxson=-1;
    for(register int i=beg[x];i;i=nex[i])
	{
        int y=to[i];
        if(y==f)
		    continue;
        dfs1(y,x,deep+1);
        siz[x]+=siz[y];
        if(siz[y]>maxson)
			son[x]=y,maxson=siz[y];
    }
}
inline void dfs2(int x,int topf)
{
    id[x]=++cnt;
    wt[cnt]=w[x];
    top[x]=topf;
    if(!son[x])
	    return;
    dfs2(son[x],topf);
    for(register int i=beg[x];i;i=nex[i])
	{
        int y=to[i];
        if(y==fa[x]||y==son[x])
			continue;
        dfs2(y,y);
    }
}
inline int qRange(int x,int y)
{
    int ans=0;
    while(top[x]!=top[y])
	{
        if(dep[top[x]]<dep[top[y]])
		    swap(x,y);
        res=0;
        query(1,1,n,id[top[x]],id[x]);
        ans+=res;
        x=fa[top[x]];
    }
    if(dep[x]>dep[y])
	    swap(x,y);
    res=0;
    query(1,1,n,id[x],id[y]);
    ans+=res;
    return ans;
}
signed main()
{
	n=read();
	m=read();
	for(int i=1;i<=n;i++)
		w[i]=read();
	for(int i=1;i<n;i++)
	{
		int a,b;
		a=read();
		b=read();
		add(a,b);
		add(b,a);
	}
	dfs1(1,0,1);
    dfs2(1,1);
    build(1,1,n);
	while(m--)
	{
		int k,x,y;
        k=read();
        if(k==1)
        {
        	x=read();
        	y=read();
        	update(1,1,n,id[x],y);
		}
		if(k==2)
		{
			x=read();
			y=read();
			updata(1,1,n,id[x],id[x]+siz[x]-1,y);
		}
		if(k==3)
		{
			x=read();
			printf("%lld\n",qRange(1,x));
		}
	}
	return 0;
}
```
如果大佬对蒟蒻的见解表示怀疑或不解，请私信本人，48小时之内回复！

---

## 作者：__wfx (赞：2)

这题其实可以在出栈入栈序上建立树状数组

由于一颗树根节点入栈与出栈序之间夹得是它的子树所以我们在该节点入栈的地方加上它的$val$出栈的时候减去它的$val$ 之后查询$x$入栈到$1$的前缀和就是$x$节点到根的距离

给以某一节点 $x$ 为根的子树在$x$节点上增加$val$会使该子树上所有的节点到根的距离都增加$val$

但是给以$x$节点为根的子树上的点都增加一个$val$, 每一个节点到根的距离增加的值不同我们就可以开第二个树状数组来维护输出$t2.ask(x) * dis[x] + t1.ask(x)$

具体操作请看代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<cstring>
#include<string>
#include<queue>
#include<ctime>
#include<deque>
#include<set>
#include<bitset>
#include<vector>
#include<list>
#include<stack>
#include<map>
#include<cmath>
#include<cctype>
#include<ctime>
#define ll long long
#define inf 99999999
#define int long long
#define N 101000
using namespace std;
inline ll read()
{
 	ll res=0,bo=1;
 	char ch=getchar();
 	while(ch<'0'||ch>'9'){if(ch=='-')bo=-1;ch=getchar();}
 	while(ch>='0'&&ch<='9'){res=(res<<1)+(res<<3)+ch-'0';ch=getchar();}
 	return bo*res;
}
struct Eage{
    int to, nxt;
}eage[N << 1];//链式前向星 
int head[N], n, m, cnt, p, in[N], out[N], z[N], dis[N];	
void add(int a, int b){
    eage[++cnt].to = b;
    eage[cnt].nxt = head[a];//加边 
    head[a] = cnt;
    return;
}
void dfs(int x, int fa){
    in[x] = ++p;// 求出入栈出栈序 
    dis[x] = dis[fa] + 1; //dis[x]指 x节点到根之间有多少个节点 
    for(int i = head[x]; i; i = eage[i].nxt){
        if(eage[i].to == fa) continue;
        dfs(eage[i].to, x); 
    } 
    out[x] = ++p;
}
struct Tree{
    ll tree[N << 1];//因为每个点一次入栈一次出栈所以要开双倍空间 
    inline void bulid(){
        for(int i = 1; i <= n; ++i){
            for(int j = in[i]; j <= n << 1; j += j & -j)//建树在它入栈时加上它的权值 
                tree[j] += z[i];
            for(int j = out[i]; j <= n << 1; j += j & -j)//出栈时减去它的权值这样就保证只有它的子树才能加上它的权值 
                tree[j] -= z[i]; 
        }
    }
    inline ll ask(int x){
        ll ans = 0;
        for(int i = in[x]; i; i -= i & -i)//查询前缀和就是它到root的距离 
            ans += tree[i];
        return ans;
    } 
    inline void change(int x, int k){
        for(int i = in[x]; i <= n << 1; i += i & -i)
            tree[i] += k; 
        for(int i = out[x]; i <= n << 1; i += i & -i)
            tree[i] -= k;
    }
}t1, t2; //开两树状数组 
signed main()
{
    n = read(); 
    m = read();
    for(int i = 1; i <= n; ++i)
        z[i] = read();
    for(int i = 1; i < n; ++i){
        int a = read();
        int b = read();
        add(a, b);//双向边 
        add(b, a);
    }
    dfs(1, 0);
    t1.bulid(); 
    for(int i = 1; i <= m; ++i){
        int a = read(), x = read();
        if(a == 1) t1.change(x, read());//直接加在储存每个点的权值的树状数组上
        if(a == 2) {
            int y = read();
            t1.change(x, (ll)-y * ((ll)dis[x] - 1));//由于子树的每个节点减去的权值都是一样的 
				//怕爆int
            t2.change(x, (ll)y);//每个节点加的权值不一样的加在第二个树状数组上 
        }
        if(a == 3){
            ll ans = 0;
            ans += t1.ask(x);
            ans += t2.ask(x) * (ll)dis[x];//由于已经减过 y * (dis[x] - 1)所以查询时直接加上 t2.ask(x) * dis[x] 即可 
            printf("%lld\n", ans);
        }
    }
    return 0;
}
```

---

## 作者：RainAir (赞：2)

看到没有用指针的题解就来发一波。。。

这一题也是树链剖分的板子题。

对于操作1：直接在点的dfn在线段树的位置修改即可。

对于操作2：我们考虑在记录每个以该点为根的子树大小时，由于dfn的顺序一定是子树的dfn小于根的，所以修改子树可以转化为修改对应的线段树中该点的$ dfn $与$ dfn + size - 1 $(读者可以自己模拟一下）。

对于操作3:查询1到该点的距离即可。

代码如下：
```c++
#include <algorithm>
#include <iostream>
#include <cstring>
#include <climits>
#include <cstdlib>
#include <cstdio>
#include <queue>
#include <stack>
#include <map>
#include <set>

#define LL long long  //一定要加long long
#define DEBUG(x) std::cerr << #x << '=' << x << std::endl

const int MAXN = 100000 + 5;

LL N,M;

struct Data{
    LL u,v,w;
}d[MAXN];

inline void Read(LL &x){
    char ch = getchar();
    x = 0;int flag = 1;
    for(;!isdigit(ch);ch = getchar())
        if(ch == '-') flag = -1;
    for(;isdigit(ch);ch = getchar())
        x = (x << 1) + (x << 3) + ch - '0';
    x *= flag;
}  //快读

struct Node{
    LL dfn,size,depth;
    bool vis;
    struct Edge *firstEdge;
    struct Chain *chain;
    Node *fa,*maxChild;
}node[MAXN];

struct Edge{
    Node *s,*t;
    Edge *next;
}pool1[MAXN * 2],*frog1 = pool1;

Edge *New(Node *u,Node *v){
    Edge *ret = ++frog1;
    ret->s = u;ret->t = v;
    ret->next = u->firstEdge;
    return ret;
}

inline void add(LL u,LL v){
    node[u].firstEdge = New(&node[u],&node[v]);
    node[v].firstEdge = New(&node[v],&node[u]);
}

struct Chain{
    Node *top;
}pool2[MAXN],*frog2 = pool2;

Chain *New2(Node *top){
    Chain *ret = ++frog2;
    ret->top = top;
    return ret;
}

void dfs1(Node *v){
    v->vis = true;
    v->size = 1;
    for(Edge *e = v->firstEdge;e;e = e->next){
        if(!e->t->vis){
            e->t->fa = v;
            e->t->depth = v->depth + 1;
            dfs1(e->t);
            v->size += e->t->size;
            if(!v->maxChild || e->t->size > v->maxChild->size)
                v->maxChild = e->t;
        }
    }
}

void dfs2(Node *v){
    static LL ts = 0;
    v->dfn = ++ts;
    
    if(!v->fa || v->fa->maxChild != v)
        v->chain = New2(v);
    else v->chain = v->fa->chain;
    if(v->maxChild) dfs2(v->maxChild);
    for(Edge *e = v->firstEdge;e;e = e->next){
        if(e->t->fa == v && e->t != v->maxChild)
            dfs2(e->t);
    }
}

inline void split(){
    node[1].depth = 1;
    dfs1(&node[1]);
    dfs2(&node[1]);
}  //树剖经典两次dfs

struct SegmentTree;
SegmentTree *New3(LL,LL,SegmentTree *,SegmentTree *);

struct SegmentTree{
    LL l,r;
    LL sum,tag;
    SegmentTree *lc,*rc;
    
    static SegmentTree *build(LL l,LL r){
        LL mid = (l + r) / 2;
        return (l == r) ? New3(l,r,NULL,NULL) : New3(l,r,build(l,mid),build(mid + 1,r));
    }
    
    void pushup(){
        sum = lc->sum + rc->sum;
    }
    
    void cover(LL delta){
        sum += (r - l + 1) * delta;
        tag += delta;
    }
    
    void pushdown(){
        if(tag){
            lc->cover(tag);
            rc->cover(tag);
            tag = 0;
        }
    }
    
    void update(LL pos,LL x){
        if(l == r){
            sum = x;
            tag = 0;
            return;
        }
        pushdown();
        LL mid = (l + r) / 2;
        if(pos <= mid) lc->update(pos,x);
        else rc->update(pos,x);
        pushup();
    }
    
    void modify(LL left,LL right,LL delta){
        if(left == l && right == r){
            cover(delta);
            return;
        }
        pushdown();
        LL mid = (l + r) >> 1;
        if(right <= mid) lc->modify(left,right,delta);
        else if(left > mid) rc->modify(left,right,delta);
        else{
            lc->modify(left,mid,delta);
            rc->modify(mid + 1,right,delta);
        }
        pushup();
    }
    
    LL query(LL left,LL right){
        if(left > r || right < l) return 0;
        if(left == l && right == r) return sum;
        pushdown();
        LL mid = (l + r) >> 1;
        if(right <= mid) return lc->query(left,right);
        else if(left > mid) return rc->query(left,right);
        else{
            return lc->query(left,mid) + rc->query(mid + 1,right);
        }
    }
}pool3[MAXN * 4],*frog3 = pool3,*segt;

SegmentTree *New3(LL l,LL r,SegmentTree *lc,SegmentTree *rc){
    SegmentTree *ret = ++frog3;
    ret->l = l;ret->r = r;
    ret->lc = lc;ret->rc = rc;
    ret->sum = ret->tag = 0;
    return ret;
}

inline void modify(LL x,LL y,LL delta){
    Node *u = &node[x],*v = &node[y];
    while(u->chain != v->chain){
        if(u->chain->top->depth < v->chain->top->depth) std::swap(u,v);
        segt->modify(u->chain->top->dfn,u->dfn,delta);
        u = u->chain->top->fa;
    }
    if(u->depth > v->depth) std::swap(u,v);
    segt->modify(u->dfn,v->dfn,delta);
}

inline LL query(LL x,LL y){
    LL ret = 0;
    Node *u = &node[x],*v = &node[y];
    while(u->chain != v->chain){
        if(u->chain->top->depth < v->chain->top->depth) std::swap(u,v);
        ret += segt->query(u->chain->top->dfn,u->dfn);
        u = u->chain->top->fa;
    }
    if(u->depth > v->depth) std::swap(u,v);
    return ret + segt->query(u->dfn,v->dfn);
}

int main(){
    LL w[MAXN];
    Read(N);Read(M);
    segt = SegmentTree::build(1,N);
    for(LL i = 1;i <= N;i++){
        Read(w[i]);
    }
    for(LL u,v,i = 1;i < N;i++){
        Read(u);Read(v);
        add(u,v);
    }
    split();
    for(LL i = 1;i <= N;i++)
        segt->update(node[i].dfn,w[i]);
    for(LL opt,x,a,i = 1;i <= M;i++){
        Read(opt);Read(x);
        if(opt == 1){
            Read(a);
            modify(x,x,a);
        }
        if(opt == 2){
            Read(a);
            segt->modify(node[x].dfn,node[x].dfn + node[x].size - 1,a);
        }
        if(opt == 3)
            printf("%lld\n",query(1,x));
        
    }
    return 0;
}

```

---

## 作者：我不是柳橙汁 (赞：1)

# 这道题是裸的树链剖分算法

# 这道题是裸的树链剖分算法

# 这道题是裸的树链剖分算法

我觉得还可以。因为我读优忘记写负数了。

然后对于点操作，线段树从自己到自己增加就行了。

然后和 P3384 【模板】树链剖分 一模一样的做法，简直就是双倍经验

```cpp
#include<iostream>
#include<cstdio>
using namespace std;

struct edge{
    long long to,next;
}e[200010];
long long n,m,len,tot;
long long a[100010],tree[400010],lazy[400010];
long long head[100010],real[100010],id[100010],fa[100010],hson[100010],dep[100010],size[100010],top[100010];

long long v_in(){//快读 
    long long sum=0,f=1;
    char ch=getchar();
    while (ch<'0'||ch>'9'){
        if (ch=='-') f*=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9'){
        sum=sum*10+ch-'0';
        ch=getchar();
    }
    return sum*f;
}

void add(long long u,long long v){//加边 
    e[++len].to=v;
    e[len].next=head[u];
    head[u]=len;
}

/*线段树(Segment Tree)*/ 

void pushup(long long rt){//上推 
    tree[rt]=tree[rt<<1]+tree[rt<<1|1];
}

void pushdown(long long rt,long long ln,long long rn){//下推 
    if (lazy[rt]){
        tree[rt<<1]+=lazy[rt]*ln;
        tree[rt<<1|1]+=lazy[rt]*rn;
        lazy[rt<<1]+=lazy[rt];
        lazy[rt<<1|1]+=lazy[rt];
        lazy[rt]=0;
    }
}

void build(long long l,long long r,long long rt){//建树 
    if (l==r){
        tree[rt]=a[real[l]];
        return;
    }
    long long mid=(l+r)>>1;
    build(l,mid,rt<<1);
    build(mid+1,r,rt<<1|1);
    pushup(rt);
}

void update(long long l,long long r,long long rt,long long left,long long right,long long c){//修改操作 
    if (l>=left&&r<=right){
        tree[rt]+=c*(r-l+1);
        lazy[rt]+=c;
        return;
    }
    long long mid=(l+r)>>1;
    pushdown(rt,mid-l+1,r-mid);
    if (mid>=left) update(l,mid,rt<<1,left,right,c);
    if (mid+1<=right) update(mid+1,r,rt<<1|1,left,right,c);
    pushup(rt);
}

long long query(long long l,long long r,long long rt,long long left,long long right){//询问操作 
    if (l>=left&&r<=right) return tree[rt];
    long long mid=(l+r)>>1,ans=0;
    pushdown(rt,mid-l+1,r-mid);
    if (mid>=left) ans+=query(l,mid,rt<<1,left,right);
    if (mid+1<=right) ans+=query(mid+1,r,rt<<1|1,left,right);
    pushup(rt);
    return ans;
}

/*树链剖分*/

void dfs1(long long u,long long f){//第一遍深搜(建树,记录fa,size,dep,hson) 
    fa[u]=f;
    size[u]=1;
    for (long long i=head[u];i!=0;i=e[i].next){
        long long v=e[i].to;
        if (fa[u]!=v){
            dep[v]=dep[u]+1;
            dfs1(v,u);
            if (hson[u]==0||size[hson[u]]<size[v]) hson[u]=v;
            size[u]+=size[v];
        }
    }
}

void dfs2(long long u,long long anc){//第二遍深搜(分链,重新编号,记录top,id,real) 
    top[u]=anc;
    id[u]=++tot;
    real[tot]=u;
    if (hson[u]==0) return;
    dfs2(hson[u],anc);
    for (long long i=head[u];i!=0;i=e[i].next){
        long long v=e[i].to;
        if (v!=fa[u]&&v!=hson[u]) dfs2(v,v);
    }
}

void point_add(){//1操作 
    long long x=v_in(),w=v_in();
    update(1,n,1,id[x],id[x],w);
}

void tree_add(){//2操作 
    long long x=v_in(),w=v_in();
    update(1,n,1,id[x],id[x]+size[x]-1,w);
}

void chain_query(){//3操作 
    long long u=v_in();
    long long tu=top[u],ans=0;
    while (tu!=1){
        ans+=query(1,n,1,id[tu],id[u]);
        u=fa[tu];
        tu=top[u];
    }
    ans+=query(1,n,1,id[1],id[u]);
    printf("%lld\n",ans);
}

main(){
    n=v_in();
    m=v_in();
    for (long long i=1;i<=n;i++) a[i]=v_in();
    for (long long i=1;i<n;i++){
        long long u=v_in(),v=v_in();
        add(u,v);//无向边 
        add(v,u);
    }
    dep[1]=1;
    dfs1(1,0);
    dfs2(1,1);
    build(1,n,1);
    for (long long i=1;i<=m;i++){
        long long q=v_in();
        if (q==1) point_add();
        else if (q==2) tree_add();
        else chain_query();
    }
    return 0;
}
```

---

## 作者：Sunqi666 (赞：1)

这是树链剖分模板题。

个人觉得唯一坑的地方就是，输入是有负数的（~~自己写快读没加判负，调了我贼久~~）

这题显然是模板的弱化版，比模板少了两个操作。

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pushup(o) t[o]=t[o<<1]+t[o<<1|1]
#define wxp 100001
ll n,m,to[200000],fa[wxp],next[200000],head[wxp],son[wxp],siz[wxp],top[wxp],w[wxp],wt[wxp],t[400001],tag[400001],tot,cnt,id[wxp],dep[wxp];
ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
    return x*f;
}
void build(ll o,ll l,ll r){
    tag[o]=0;
    if(l==r)t[o]=w[l];
    else{
        ll mid=l+r>>1;
        build(o<<1,l,mid);
        build(o<<1|1,mid+1,r);
        pushup(o);
    }
}
void pushdown(ll o,ll l,ll r){
    ll mid=l+r>>1;
    tag[o<<1]+=tag[o];
    tag[o<<1|1]+=tag[o];
    t[o<<1]+=tag[o]*(mid-l+1);
    t[o<<1|1]+=tag[o]*(r-mid);
    tag[o]=0;
}
ll query(ll o,ll l,ll r,ll x,ll y){
    if(x<=l&&r<=y)return t[o];
    pushdown(o,l,r);
    ll ans=0,mid=l+r>>1;
    if(x<=mid)ans=query(o<<1,l,mid,x,y);
    if(mid<y)ans+=query(o<<1|1,mid+1,r,x,y);
    return ans;
}
void update(ll o,ll l,ll r,ll x,ll y,ll wwxp){
    if(x<=l&&r<=y){
        t[o]+=wwxp*(r-l+1);
        tag[o]+=wwxp;
    }
    else{
        pushdown(o,l,r);
        ll mid=l+r>>1;
        if(x<=mid)update(o<<1,l,mid,x,y,wwxp);
        if(mid<y)update(o<<1|1,mid+1,r,x,y,wwxp);
        pushup(o);
    }
}
void add(ll u,ll v){
    to[++tot]=v,next[tot]=head[u],head[u]=tot;
}
void dfs1(ll s,ll f){
    fa[s]=f;
    dep[s]=dep[f]+1;
    siz[s]=1;
    for(int i=head[s];i;i=next[i]){
        if(to[i]==f)continue;
        dfs1(to[i],s);
        siz[s]+=siz[to[i]];
        if(siz[son[s]]<siz[to[i]])son[s]=to[i];
    }
}
void dfs2(ll s,ll t){
    id[s]=++cnt;
    top[s]=t;
    w[cnt]=wt[s];
    if(!son[s])return;
    dfs2(son[s],t);
    for(int i=head[s];i;i=next[i]){
        if(to[i]==fa[s]||to[i]==son[s])continue;
        dfs2(to[i],to[i]);
    }
}
int main(){
    n=read(),m=read();
    for(int i=1;i<=n;i++)wt[i]=read();
    for(int i=1;i<n;i++){
        int u=read(),v=read();
        add(u,v),add(v,u);
    }
    dfs1(1,0);
    dfs2(1,1);
    build(1,1,n);
    while(m--){
        int k=read();
        if(k==1){
            ll x=read(),y=read();
            update(1,1,n,id[x],id[x],y);
        }
        if(k==2){
            ll x=read(),y=read();
            update(1,1,n,id[x],id[x]+siz[x]-1,y);
        }
        if(k==3){
            ll x=read(),ans=0;
            while(top[x]!=1){
                ans+=query(1,1,n,id[top[x]],id[x]);
                x=fa[top[x]];
            }
            printf("%lld\n",ans+query(1,1,n,1,id[x]));
        }
    }
}
```
代码中wt数组是题目读入的n个数，w数组是按照编号排序过后的n个数

~~wxp是我教练~~

调题不易，望管理员大大通过QwQ

---

## 作者：Kelin (赞：1)

稍微翻了下提交记录，为什么没有人用树状数组呢？

树链剖分+树状数组。

因为这道题是只要区间求和，区间修改，单点修改

所以果断放弃线段树，上一波树状数组。

想知道原理看这个博客http://www.cnblogs.com/lcf-2000/p/5866170.html

这里是代码

```cpp
#include<cstdio>
#define re register int
const int N=1e5+9;
typedef int array[N];
typedef long long ll;
struct edges{int nx,to;}e[N<<1];
int n,m,tot,tmp;array a,b,fi,top,size,son,id,real,fa,depth;ll c1[N],c2[N];
void dfs1(re u){
    depth[u]=depth[fa[u]]+(size[u]=1);
    for(re i=fi[u],v;i;i=e[i].nx)
        if((v=e[i].to)!=fa[u]){
            fa[v]=u;dfs1(v);size[u]+=size[v];
            if(size[v]>size[son[u]])son[u]=v;
        }
}
void dfs2(re u){
    if(son[fa[u]]==u)top[u]=top[fa[u]];
    else top[u]=u;
    real[id[u]=++tmp]=u;
    if(son[u])dfs2(son[u]);
    for(re v,i=fi[u];i;i=e[i].nx)
        if((v=e[i].to)!=fa[u]&&v!=son[u])
            dfs2(v);
}
inline void insert(re x,ll w){for(re i=x;i<=n;i+=i&(-i))c1[i]+=w,c2[i]+=(ll)x*w;}
inline ll sigma(re x){ll sum=0;for(re i=x;i;i-=i&(-i))sum+=(ll)(x+1)*c1[i]-c2[i];return sum;}
inline void swap(re&x,re&y){re t=x;x=y;y=t;}
inline ll sum(re u,re v){
    ll sum=0;
    while(top[u]!=top[v]){
        if(depth[top[u]]<depth[top[v]])swap(u,v);
        sum+=sigma(id[u])-sigma(id[top[u]]-1);
        u=fa[top[u]];
    }
    if(depth[u]>depth[v])swap(u,v);
    sum+=sigma(id[v])-sigma(id[u]-1);
    return sum;
}
inline void add(re u,re v){e[++tot]=(edges){fi[u],v};fi[u]=tot;}
int main(){
scanf("%d%d",&n,&m);
    for(re i=1;i<=n;++i)scanf("%d",&a[i]);
    for(re i=1,u,v;i<n;++i)scanf("%d%d",&u,&v),add(u,v),add(v,u);
    dfs1(1);dfs2(1);
    for(re i=1;i<=n;++i)b[i]=a[real[i]];
    for(re i=1;i<=n;++i)insert(i,b[i]-b[i-1]);
    re op,x,y;
    while(m--){
scanf("%d%d",&op,&x);
        if(op==1)scanf("%d",&y),insert(id[x],y),insert(id[x]+1,-y);
        else if(op==2)scanf("%d",&y),insert(id[x],y),insert(id[x]+size[x]-1+1,-y);
        else printf("%lld\n",sum(1,x));
    }
return 0;
}
```

---

## 作者：59percent (赞：0)

### 思路

首先树链剖分得到重链序，然后考虑操作：


1-单点更新：

2-区间更新：以某点为根的区间是p[x]和p[x]+size[x]-1，刚好连续

3-求路径：某点到根的路径，可以按重链、跳、重链…的组合来实现，也即多个区间的和组合起来。

显然，可以用线段树来维护区间操作和查询。
### 代码
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;

const int N = 1e5 + 5;
vector<int> g[N];
int n, m, last,
    o[N],w[N],
    p[N], dep[N], fa[N], son[N], size[N], top[N];
struct Node {
    int L, R;
    long long sum, tag;
    void save_tag(long long w) {
        sum += (R+1-L) * w;
        tag += w;
    }
} tree[4*N];

void build(int L, int R, int k) {
    tree[k].L = L;
    tree[k].R = R;
    if(L == R) {
        tree[k].sum = o[L];
        return;
    }
    int mid = (L+R) / 2;
    build(L, mid, 2*k);
    build(mid+1, R, 2*k+1);
    tree[k].sum = tree[2*k].sum + tree[2*k+1].sum;
}

void push_down(int k) {
    tree[2*k].save_tag(tree[k].tag);
    tree[2*k+1].save_tag(tree[k].tag);
    tree[k].tag = 0;
}

void update(int k, int x, int y, int w) {
    int L = tree[k].L, R = tree[k].R;
    if(y<L || x>R)
        return;
    if(x<=L && y>=R) {
        tree[k].save_tag(w);
        return;
    }
    if(tree[k].tag)
        push_down(k);
    int mid = (L+R) / 2;
    if(x <= mid)
        update(2*k, x, y, w);
    if(y >= mid+1)
        update(2*k+1, x, y, w);
    tree[k].sum = tree[2*k].sum + tree[2*k+1].sum;
}

long long query(int k, int x, int y) {
    int L = tree[k].L, R = tree[k].R;
    if(x<=L && y>=R)
        return tree[k].sum;
    if(tree[k].tag)
        push_down(k);
    long long ans = 0;
    int mid = (L+R)/2;
    if(x <= mid)
        ans += query(2*k, x, y);
    if(y >= mid+1)
        ans += query(2*k+1, x, y);
    return ans;
}

void dfs1(int x, int father, int len) {
    dep[x] = len;
    fa[x] = father;
    size[x] = 1;
    for(int i = 0; i < g[x].size(); i++) {
        int y = g[x][i];
        if(y == father) continue;
        dfs1(y, x, len + 1);
        size[x] += size[y];
        if(size[y] > size[son[x]])
            son[x] = y;
    }
}

void dfs2(int x, int tp) {
    o[++last] = w[x];
    p[x] = last;
    top[x] = tp;
    if(son[x] == 0)
        return;
    dfs2(son[x], tp);
    for(int i = 0; i < g[x].size(); i++) {
        int y = g[x][i];
        if(y==fa[x] || y==son[x])
            continue;
        dfs2(y, y);
    }
}

int main() {
    cin>>n>>m;
    for(int i = 1; i <= n; i++)
        scanf("%d", w+i);
    for(int i = 1; i < n; i++) {
        int x, y;
        scanf("%d%d", &x, &y);
        g[x].push_back(y);
        g[y].push_back(x);
    }
    dfs1(1, 0, 1);
    dfs2(1, 1);
    build(1, n, 1);
    for(int i = 1; i <=m; i++) {
        int opt, x, y;
        cin>>opt>>x;
        switch(opt) {
        case 1:
            scanf("%d", &y);
            update(1, p[x], p[x], y);
            break;
        case 2:
            scanf("%d", &y);
            update(1, p[x], p[x]+size[x]-1, y);
            break;
        default:
            long long sum = 0;
            while(top[x] != 1) {
                sum += query(1, p[top[x]], p[x]);
                x = fa[top[x]];
            }
            sum += query(1, p[1], p[x]);
            cout<<sum<<endl;
        }
    }
    return 0;
}
```


---

## 作者：little_sun (赞：0)

就是个树剖的模板题嘛。。。

两边dfs把树割成链, 然后在链上线段树维护

做完了。。。

```cpp
#include <bits/stdc++.h>
#define int long long

const int MaxN = 100010;

struct edge
{
    int next, to;
};

struct node
{
    int l, r;
    int sum, tag;
};

edge e[MaxN << 1];
int n, m, cnt, dfscnt;
int a[MaxN], head[MaxN], dfn[MaxN], pre[MaxN];
int top[MaxN], dep[MaxN], hson[MaxN], fa[MaxN], size[MaxN];

struct SegmentTree
{
    node t[MaxN << 2];
    inline void pushup(int id) { t[id].sum = t[id << 1].sum + t[id << 1 | 1].sum; }
    void build(int id, int l, int r)
    {
        t[id].l = l, t[id].r = r;
        if (l == r)
        {
            t[id].sum = a[pre[l]];
            return;
        }
        int mid = (l + r) >> 1;
        build(id << 1, l, mid);
        build(id << 1 | 1, mid + 1, r);
        pushup(id);
    }
    inline void pushdown(int id)
    {
        if (t[id].tag)
        {
            t[id << 1].sum += t[id].tag * (t[id << 1].r - t[id << 1].l + 1);
            t[id << 1 | 1].sum += t[id].tag * (t[id << 1 | 1].r - t[id << 1 | 1].l + 1);

            t[id << 1].tag += t[id].tag, t[id << 1 | 1].tag += t[id].tag;

            t[id].tag = 0;
        }
    }
    void modify(int id, int l, int r, int delta)
    {
        if (l > t[id].r || r < t[id].l)
            return;
        if (l <= t[id].l && t[id].r <= r)
        {
            t[id].sum += delta * (t[id].r - t[id].l + 1);
            t[id].tag += delta;
            return;
        }
        if (t[id].l == t[id].r)
            return;
        pushdown(id);
        modify(id << 1, l, r, delta);
        modify(id << 1 | 1, l, r, delta);
        pushup(id);
    }
    int query(int id, int l, int r)
    {
        if (l > t[id].r || r < t[id].l)
            return 0;
        if (l <= t[id].l && t[id].r <= r)
            return t[id].sum;
        if (t[id].l == t[id].r)
            return 0;
        pushdown(id);
        return query(id << 1, l, r) + query(id << 1 | 1, l, r);
    }
} T;

inline void add_edge(int u, int v)
{
    ++cnt;
    e[cnt].to = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}

void dfs1(int u, int f)
{
    size[u] = 1;
    for (int i = head[u]; i; i = e[i].next)
    {
        int v = e[i].to;
        if (v == f)
            continue;
        dep[v] = dep[u] + 1, fa[v] = u;
        dfs1(v, u);
        size[u] += size[v];
        if (size[v] > size[hson[u]])
            hson[u] = v;
    }
}

void dfs2(int u, int Top)
{
    ++dfscnt;
    dfn[u] = dfscnt;
    pre[dfscnt] = u;
    top[u] = Top;
    if (hson[u])
        dfs2(hson[u], Top);
    for (int i = head[u]; i; i = e[i].next)
    {
        int v = e[i].to;
        if (v == fa[u] || v == hson[u])
            continue;
        dfs2(v, v);
    }
}

inline int read()
{
    int x = 0, f = 1;
    char ch = getchar();
    while (ch > '9' || ch < '0')
    {
        if (ch == '-')
            f = 0;
        ch = getchar();
    }
    while (ch <= '9' && ch >= '0')
        x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    return f ? x : (-x);
}

inline int query(int u, int v)
{
    int ans = 0;
    while (top[u] != top[v])
    {
        if (dep[u] < dep[v])
            std::swap(u, v);
        ans += T.query(1, dfn[top[u]], dfn[u]);
        u = fa[top[u]];
    }
    if (dep[u] < dep[v])
        std::swap(u, v);
    ans += T.query(1, dfn[v], dfn[u]);
    return ans;
}

signed main()
{
    n = read(), m = read();
    for (int i = 1; i <= n; i++)
        a[i] = read();
    for (int i = 1; i < n; i++)
    {
        int u = read(), v = read();
        add_edge(u, v);
        add_edge(v, u);
    }
    dep[1] = 1, fa[1] = 0;
    dfs1(1, 0), dfs2(1, 1);
    T.build(1, 1, n);
    for (int i = 1; i <= m; i++)
    {
        int op = read();
        if (op == 1)
        {
            int u = read(), x = read();
            T.modify(1, dfn[u], dfn[u], x);
        }
        if (op == 2)
        {
            int u = read(), x = read();
            T.modify(1, dfn[u], dfn[u] + size[u] - 1, x);
        }
        if (op == 3)
        {
            int u = read();
            printf("%lld\n", query(u, 1));
        }
    }
    return 0;
}

```



---

## 作者：Mr_浓氨 (赞：0)

这道题典型的树链剖分的模板题目，然而我还是耗了一段时间才做完的

操作1其实就是单点修改，然后操作二就是将这个点的在线段树上的编号到这个点的编号加上子树中所含的节点个数减一，就是seg[x],seg[x]+size[x]-1;

之后输出就行了

代码下

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<iomanip>
#include<ctime>
#include<cstdlib>
#include<queue>
#include<vector>
#include<map>
#include<stack>
#include<cmath>
#define ll long long
using namespace std;
inline ll read()
{
	ll x = 0, f = 1;
	char c = getchar();
	while (c<'0' || c>'9')
	{
		if (c == '-')
		{
			f = -1;
		}
		c = getchar();
	}
	while (c >= '0'&&c <= '9')
	{
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}
ll fa[100001], d[100001], seg[100001], sizea[100001], son[100001], top[100001], res[100001];
ll wt[100001];
ll n, m, t;
struct node
{
	ll val, lazy;
}tree[800001];
vector<ll>a[100001];
inline void dfs1(ll u)
{
	sizea[u] = 1;
	son[u] = 0;
	d[u] = d[fa[u]] + 1;
	for (unsigned ll i = 0;i < a[u].size();i++)
	{
		if (a[u][i] != fa[u])
		{
			fa[a[u][i]] = u;
			dfs1(a[u][i]);
			sizea[u] += sizea[a[u][i]];
			if (sizea[a[u][i]] > sizea[son[u]])
			{
				son[u] = a[u][i];
			}
		}
	}
}
ll tot;
inline void dfs2(ll v, ll topa)
{
	tot++;
	seg[v] = tot;
	res[tot] = v;
	top[v] = topa;
	if (son[v] != 0)
	{
		dfs2(son[v], topa);
	}
	for (unsigned ll i = 0;i < a[v].size();i++)
	{
		if (a[v][i] != son[v] && a[v][i] != fa[v])
		{
			dfs2(a[v][i], a[v][i]);
		}
	}
}
inline void build(ll v, ll l, ll r)
{
	if (l == r)
	{
		tree[v].val = wt[res[l]];
		return;
	}
	ll mid = (l + r) >> 1;
	build(v << 1, l, mid);
	build(v << 1 | 1, mid + 1, r);
	tree[v].val = tree[v << 1].val + tree[v << 1 | 1].val;
}
inline void pushdown(ll v, ll l, ll r)
{
	if (tree[v].lazy != 0)
	{
		ll mid = (l + r) >> 1;
		tree[v << 1].val += tree[v].lazy*(mid - l + 1);
		tree[v << 1 | 1].val += tree[v].lazy*(r - mid);
		tree[v << 1].lazy += tree[v].lazy;
		tree[v << 1 | 1].lazy += tree[v].lazy;
		tree[v].lazy = 0;
	}
}
inline ll query(ll v, ll l, ll r, ll nl, ll nr)
{
	if (nl >= l && nr <= r)
	{
		return tree[v].val;
	}
	if (nl > r || nr < l)
	{
		return 0;
	}
	ll mid = (nl + nr) >> 1;
	pushdown(v, nl, nr);
	return query(v << 1, l, r, nl, mid) + query(v << 1 | 1, l, r, mid + 1, nr);
}
inline void add(ll v, ll l, ll r, ll nl, ll nr, ll sum)
{
	if (nl >= l && nr <= r)
	{
		tree[v].val += sum * (nr - nl + 1);
		tree[v].lazy += sum;
		return;
	}
	if (nl > r || nr < l)
	{
		return;
	}
	ll mid = (nl + nr) >> 1;
	pushdown(v, nl, nr);
	add(v << 1, l, r, nl, mid, sum);
	add(v << 1 | 1, l, r, mid + 1, nr, sum);
	tree[v].val = tree[v << 1].val + tree[v << 1 | 1].val;
}
inline ll tquery(ll x, ll y)
{
	ll ans = 0;
	while (top[x] != top[y])
	{
		if (d[top[x]] > d[top[y]])
		{
			ans += query(1, seg[top[x]], seg[x], 1, n);
			x = fa[top[x]];
		}
		else
		{
			ans += query(1, seg[top[y]], seg[y], 1, n);
			y = fa[top[y]];
		}
	}
	if (seg[x] < seg[y])
	{
		ans += query(1, seg[x], seg[y], 1, n);
	}
	else
	{
		ans += query(1, seg[y], seg[x], 1, n);
	}
	return ans;
}
inline void tadd(ll x, ll y, ll sum)
{
	while (top[x] != top[y])
	{
		if (d[top[x]] > d[top[y]])
		{
			add(1, seg[top[x]], seg[x], 1, n, sum);
			x = fa[top[x]];
		}
		else
		{
			add(1, seg[top[y]], seg[y], 1, n, sum);
			y = fa[top[y]];
		}
	}
	if (seg[x] < seg[y])
	{
		add(1, seg[x], seg[y], 1, n, sum);
	}
	else
	{
		add(1, seg[y], seg[x], 1, n, sum);
	}
}
int main()
{
	n = read(), m = read();
	for (ll i = 1;i <= n;i++)
	{
		wt[i] = read();
	}
	for (ll i = 1;i < n;i++)
	{
		ll x = read(), y = read();
		a[x].push_back(y);
		a[y].push_back(x);
	}
	dfs1(1);
	dfs2(1, 1);
	build(1, 1, n);
	for (ll i = 1;i <= m;i++)
	{
		ll judge = read();
		if (judge == 1)
		{
			ll x = read(), z = read();
			add(1, seg[x], seg[x], 1, n, z);
		}
		else if(judge == 2)
		{
			ll x = read(), z = read();
			add(1, seg[x], seg[x] + sizea[x] - 1, 1, n, z);
		}
		else
		{
			ll x = read();
			printf("%lld\n", tquery(1, x));
		}
	}
	return 20030711;
}

```

我这里故意用的多点修改进行单点修改，虽说时间有点长，但是防抄袭啊

---

## 作者：henry_y (赞：0)

首先看到操作三就能想到树链剖分吧？

再看看题面就能想到线段树维护吧？

然后就没难度了吧？

考虑一下每个操作的做法：

操作1：单点修改，直接在线段树上面修改就好

操作2：把以x为根的子树+a，这是唯一有难度的一个地方。那么想一想我们是怎么剖分这棵树的——两次dfs，也就是说我们的树是按dfs序来构建的，再想想dfs序，它有一个很有趣的性质：

**一个子树的编号一定是连续的**

证明可以自己去找找。网上有的。

那么当我们想到这个性质之后操作2就不难了，第一次dfs的时候我们已经维护出来一个siz数组表示该节点的子节点了，我们只需要对pos[x],pos[x]+siz[x]-1这个区间进行区间修改就可以了（pos数组是树上的节点在线段树中的编号）

操作3：树链剖分的基本操作，爬到同一条重链上然后区间修改就好了

[然后说了这么多一定是要安利一下自己博客的对不对](https://www.cnblogs.com/henry-1202/p/9129614.html)

Code：

```cpp
#include <cstdio>
#include <cstring>
#define ll long long
#define inf 1<<30
#define il inline 
il ll max(ll x,ll y){return x>y?x:y;}
il ll min(ll x,ll y){return x<y?x:y;}
il ll abs(ll x){return x>0?x:-x;}
il void swap(ll &x,ll &y){ll t=x;x=y;y=t;}
il void read(ll &x){
    x=0;ll f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    x*=f;
}
il void print(ll x){if(x<0)putchar('-');x=abs(x);if(x>9)print(x/10);putchar(x%10+'0');}
il void writeln(ll x){if(x<0)putchar('-');x=abs(x);print(x);putchar('\n');}
il void write(ll x){if(x<0)putchar('-');x=abs(x);print(x);putchar(' ');}
using namespace std;
/*===================Header Template=====================*/
#define N 100010
struct tree{ll l,r,sum,tag;}t[N<<2];
struct data{ll to,next;}e[N<<1];
ll n,m,root,pos[N],sz;
ll cnt,head[N],v[N],v1[N];
ll fa[N],siz[N],top[N],dep[N];
void insert(ll u,ll v){
    e[++cnt].to=v;e[cnt].next=head[u];head[u]=cnt;
    e[++cnt].to=u;e[cnt].next=head[v];head[v]=cnt;
}
void dfs1(ll x){
    siz[x]=1;
    for(ll i=head[x];i;i=e[i].next){
        if(e[i].to==fa[x])continue;
        fa[e[i].to]=x;
        dep[e[i].to]=dep[x]+1;
        dfs1(e[i].to);
        siz[x]+=siz[e[i].to];
    }
}
void dfs2(ll x,ll topf){
    top[x]=topf;
    pos[x]=++sz;
    v1[sz]=v[x];
    ll k=0;
    for(ll i=head[x];i;i=e[i].next){
        if(dep[e[i].to]>dep[x]&&siz[e[i].to]>siz[k])k=e[i].to;
    }
    if(!k)return;
    dfs2(k,topf);
    for(ll i=head[x];i;i=e[i].next){
        if(k!=e[i].to&&dep[e[i].to]>dep[x])dfs2(e[i].to,e[i].to);
    }
}
void build(ll l,ll r,ll rt){
    t[rt].l=l;t[rt].r=r;
    ll mid=(l+r)>>1;
    if(l==r){return;}
    build(l,mid,rt<<1);
    build(mid+1,r,rt<<1|1);
    t[rt].sum=t[rt<<1].sum+t[rt<<1|1].sum;
}
void pushdown(ll ln,ll rn,ll rt){
    if(t[rt].tag){
        ll &x=t[rt].tag;
        t[rt<<1].tag+=x;
        t[rt<<1|1].tag+=x;
        t[rt<<1].sum+=x*ln;
        t[rt<<1|1].sum+=x*rn;
        x=0;
    }
}
void upd1(ll L,ll c,ll rt){
    ll l=t[rt].l,r=t[rt].r,mid=(l+r)>>1;
    if(l==r){t[rt].sum+=c;return;}
    pushdown(mid-l+1,r-mid,rt);
    if(L<=mid)upd1(L,c,rt<<1);
    else upd1(L,c,rt<<1|1);
    t[rt].sum=t[rt<<1].sum+t[rt<<1|1].sum;
}
void upd2(ll L,ll R,ll c,ll rt){
    ll l=t[rt].l,r=t[rt].r,mid=(l+r)>>1;
    if(L<=l&&r<=R){t[rt].sum+=(r-l+1)*c;t[rt].tag+=c;return;}
    pushdown(mid-l+1,r-mid,rt);
    if(L<=mid)upd2(L,R,c,rt<<1);
    if(R>mid)upd2(L,R,c,rt<<1|1);
    t[rt].sum=t[rt<<1].sum+t[rt<<1|1].sum;
}
ll query(ll L,ll R,ll rt){
    ll l=t[rt].l,r=t[rt].r,mid=(l+r)>>1,ans=0;
    if(L<=l&&r<=R)return t[rt].sum;
    pushdown(mid-l+1,r-mid,rt);
    if(L<=mid)ans+=query(L,R,rt<<1);
    if(R>mid)ans+=query(L,R,rt<<1|1);
    return ans; 
}
ll solve_query(ll x,ll y){
    ll sum=0;
    while(top[x]!=top[y]){
        if(dep[top[x]]<dep[top[y]])swap(x,y);
        sum+=query(pos[top[x]],pos[x],1);
        x=fa[top[x]];
    }
    if(pos[x]>pos[y])swap(x,y);
    sum+=query(pos[x],pos[y],1);
    return sum;
}
int main(){
    read(n);read(m);
    for(ll i=1;i<=n;i++)read(v[i]);
    for(ll i=1;i<n;i++){
        ll x,y;
        read(x);read(y);
        insert(x,y);
    }
    dfs1(1);dfs2(1,1);
    build(1,n,1);
    for(ll i=1;i<=n;i++)upd1(pos[i],v[i],1);
    while(m--){
        ll pd,x,y;
        read(pd);read(x);
        if(pd==1){
            read(y);
            upd1(pos[x],y,1);
        }else if(pd==2){
            read(y);
            upd2(pos[x],pos[x]+siz[x]-1,y,1);
        }else if(pd==3){
            writeln(solve_query(x,1));
        }
    }
    return 0;
}
```

---

## 作者：Duan2baka (赞：0)


博客链接[http://blog.csdn.net/waduan2/article/details/77657761](http://blog.csdn.net/waduan2/article/details/77657761)



>题目大意：给出一棵树，支持单点修改，子树修改和区间求和

树上区间和，树剖一下套个线段树就可以了...


#####注意答案爆int

代码如下:

```cpp
#include<cstdio>
#define N 100500
#define int long long
using namespace std;
int n,x,T,top,m,k,y,z;
int fir[N],dep[N],Top[N],tree[N],pre[N],son[N],size[N],fa[N],w[N];
struct Edge{
    int to,nex;
    Edge(){}
    Edge(int _to,int _nex):to(_to),nex(_nex){}
}nex[N*2];
struct Seg{
    int l,r,sum,lazy;
}a[N*8];
inline void swap(int&a,int&b){int c=a;a=b;b=c;}
inline void add(int x,int y){
    nex[++top]=Edge(y,fir[x]);
    fir[x]=top;
}
void dfs1(int x,int Dep,int Fa){
    fa[x]=Fa;dep[x]=Dep;
    size[x]=1;
    for(int i=fir[x];i;i=nex[i].nex){
        if(nex[i].to==Fa) continue;
        dfs1(nex[i].to,Dep+1,x);
        size[x]=size[x]+size[nex[i].to];
        if(size[nex[i].to]>size[son[x]]) son[x]=nex[i].to;
    }
}
void dfs2(int x,int topp){
    Top[x]=topp;
    tree[x]=++T;
    pre[T]=x;
    if(!son[x]) return;
    dfs2(son[x],topp);
    for(int i=fir[x];i;i=nex[i].nex){
        if(nex[i].to==fa[x] || nex[i].to==son[x]) continue;
        dfs2(nex[i].to,nex[i].to);
    }
}
void Pushdown(int x){
    a[2*x].lazy+=a[x].lazy;
    a[2*x+1].lazy+=a[x].lazy;
    a[2*x].sum=a[2*x].sum+(a[2*x].r-a[2*x].l+1)*a[x].lazy;
    a[2*x+1].sum=a[2*x+1].sum+(a[2*x+1].r-a[2*x+1].l+1)*a[x].lazy;
    a[x].lazy=0;
}
void maketree(int l,int r,int k){
    a[k].l=l;a[k].r=r;a[k].lazy=0;
    if(l==r){
        a[k].sum=w[pre[l]];
        return;
    }
    int mid=(l+r)>>1;
    maketree(l,mid,2*k);maketree(mid+1,r,2*k+1);
    a[k].sum=a[k*2].sum+a[k*2+1].sum;
}
int Query_Sum(int x,int y,int k){
    if(x==a[k].l && y==a[k].r){
        return a[k].sum;
    }
    Pushdown(k);
    int mid=(a[k].l+a[k].r)>>1;
    if(y<=mid){return Query_Sum(x,y,2*k);}
    if(x>mid){return Query_Sum(x,y,2*k+1);}
    return Query_Sum(x,mid,2*k)+Query_Sum(mid+1,y,2*k+1);
}
int Find_Sum(int x,int y){
    int sum=0;
    while(Top[x]!=Top[y]){
        if(dep[Top[x]]<dep[Top[y]]) swap(x,y);
        sum=sum+Query_Sum(tree[Top[x]],tree[x],1);
        x=fa[Top[x]];
    }
    if(tree[y]>tree[x]) swap(x,y);
    sum=sum+Query_Sum(tree[y],tree[x],1);
    return sum;
}
void Add(int x,int y,int val,int k){
    if(x>y) swap(x,y);
    if(a[k].r<x || a[k].l>y) return;
    if(x<=a[k].l && y>=a[k].r){
        a[k].lazy+=val;
        a[k].sum+=val*(a[k].r-a[k].l+1);
        return;
    }
    Pushdown(k);
    Add(x,y,val,2*k);
    Add(x,y,val,2*k+1);
    a[k].sum=a[2*k].sum+a[2*k+1].sum;
}
main(){
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;i++) scanf("%lld",w+i);
    for(int i=2;i<=n;i++){
        scanf("%lld%lld",&x,&y);
        add(x,y);add(y,x);
    }
    dfs1(1,1,0);dfs2(1,1);
    maketree(1,n,1);
    for(int i=1;i<=m;i++){
        scanf("%d",&k);
        switch(k){
            case 1: scanf("%lld%lld",&x,&y);Add(tree[x],tree[x],y,1);break;
            case 2: scanf("%lld%lld",&x,&y);Add(tree[x],tree[x]+size[x]-1,y,1);break;
            case 3: scanf("%lld",&x);printf("%lld\n",Find_Sum(x,1));break;
        }
    }
return 0;
}

```

---

## 作者：qscqesze_lca (赞：0)

树链剖分+线段树模板题。

然而区间修改依旧细节重重，

一个+=坑了我好久。

设原数组第i位的值为a\_i，d\_i=a\_i-a\_{i-1}，则有(这里认为a\_0=0)：

a\_x=\sum\_{i=1}^x d\_i

所以有：

\sum\_{i=1}^x a\_i= \sum\_{i=1}^x \sum\_{j=1}^i d\_j =\sum\_{i=1}^x(x-i+1)d\_i

于是我们得到了：

\sum\_{i=1}^x a\_i=(x+1)\sum\_{i=1}^x d\_i-\sum\_{i=1}^x d\_i \times i

于是我们把原数组差分后维护两个树状数组，一个维护d\_i，一个维护d\_i \times i。

这样区间求和时可以在两个树状数组中查询得到前缀和，区间修改时就是差分数组的修改，每次修改两个点即可。

多码一码吧。

注意要开long long

```cpp
  1 #include <stdio.h>
  2 #include <algorithm>
  3 #define N 100001
  4 #define lson l , mid , x << 1
  5 #define rson mid + 1 , r , x << 1 | 1
  6 using namespace std;
  7 int fa[N] , deep[N] , bl[N] , si[N] , pos[N] , tot , endp[N] , n , val[N];
  8 int head[N] , to[N << 1] , next[N << 1] , cnt;
  9 long long sum[N << 3] , mark[N << 3];
 10 void add(int x , int y)
 11 {
 12     to[++cnt] = y;
 13     next[cnt] = head[x];
 14     head[x] = cnt;
 15 }
 16 void dfs1(int x)
 17 {
 18     int y , i;
 19     si[x] = 1;
 20     for(i = head[x] ; i ; i = next[i])
 21     {
 22         y = to[i];
 23         if(y != fa[x])
 24         {
 25             fa[y] = x;
 26             deep[y] = deep[x] + 1;
 27             dfs1(y);
 28             si[x] += si[y];
 29         }
 30     }
 31 }
 32 void dfs2(int x , int c)
 33 {
 34     int y , i , k = 0;
 35     pos[x] = ++tot;
 36     bl[x] = c;
 37     endp[x] = pos[x];
 38     for(i = head[x] ; i ; i = next[i])
 39     {
 40         y = to[i];
 41         if(y != fa[x] && si[y] > si[k])
 42             k = y;
 43     }
 44     if(k)
 45     {
 46         dfs2(k , c);
 47         endp[x] = max(endp[x] , endp[k]);
 48         for(i = head[x] ; i ; i = next[i])
 49         {
 50             y = to[i];
 51             if(y != fa[x] && y != k)
 52             {
 53                 dfs2(y , y);
 54                 endp[x] = max(endp[x] , endp[y]);
 55             }
 56         }
 57     }
 58 }
 59 void pushup(int x)
 60 {
 61     sum[x] = sum[x << 1] + sum[x << 1 | 1];
 62 }
 63 void pushdown(int x , int l , int r)
 64 {
 65     if(mark[x])
 66     {
 67         int mid = (l + r) >> 1;
 68         mark[x << 1] += mark[x];
 69         mark[x << 1 | 1] += mark[x];
 70         sum[x << 1] += (long long)mark[x] * (mid - l + 1);
 71         sum[x << 1 | 1] += (long long)mark[x] * (r - mid);
 72         mark[x] = 0;
 73     }
 74 }
 75 void update(int b , int e , int a , int l , int r , int x)
 76 {
 77     pushdown(x , l , r);
 78     if(b <= l && r <= e)
 79     {
 80         sum[x] += (long long)a * (r - l + 1);
 81         mark[x] = a;
 82         return;
 83     }
 84     int mid = (l + r) >> 1;
 85     if(b <= mid)
 86         update(b , e , a , lson);
 87     if(e > mid)
 88         update(b , e , a , rson);
 89     pushup(x);
 90 }
 91 long long query(int b , int e , int l , int r , int x)
 92 {
 93     pushdown(x , l , r);
 94     if(b <= l && r <= e)
 95         return sum[x];
 96     int mid = (l + r) >> 1;
 97     long long ans = 0;
 98     if(b <= mid)
 99         ans += query(b , e , lson);
100     if(e > mid)
101         ans += query(b , e , rson);
102     return ans;
103 }
104 long long solvequery(int x)
105 {
106     long long ans = 0;
107     while(bl[x] != 1)
108     {
109         ans += query(pos[bl[x]] , pos[x] , 1 , n , 1);
110         x = fa[bl[x]];
111     }
112     ans += query(1 , pos[x] , 1 , n , 1);
113     return ans;
114 }
115 int main()
116 {
117     int m , i , x , y , opt;
118     scanf("%d%d" , &n , &m);
119     for(i = 1 ; i <= n ; i ++ )
120         scanf("%lld" , &val[i]);
121     for(i = 1 ; i < n ; i ++ )
122     {
123         scanf("%d%d" , &x , &y);
124         add(x , y);
125         add(y , x);
126     }
127     dfs1(1);
128     dfs2(1 , 1);
129     for(i = 1 ; i <= n ; i ++ )
130         update(pos[i] , pos[i] , val[i] , 1 , n , 1);
131     while(m -- )
132     {
133         scanf("%d" , &opt);
134         switch(opt)
135         {
136             case 1: scanf("%d%d" , &x , &y); update(pos[x] , pos[x] , y , 1 , n , 1); break;
137             case 2: scanf("%d%d" , &x , &y); update(pos[x] , endp[x] , y , 1 , n , 1); break;
138             default: scanf("%d" , &x); printf("%lld\n" , solvequery(x));
139         }
140     }
141     return 0;
142 }
```

---

## 作者：Vasily (赞：0)

显然一波树链剖分。

关于以XXX为根的子树，记录时间戳，改起来比链爽多了（直接改）

还有，注意数组范围（MLE一次），还有long long（WA一次），还要注意某些细节和边权的

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <vector>
#include <map>
#include <stack>
#include <queue>
#include <set>
#include <cmath>
#include <algorithm>
#include <ctime>
#define ll long long
using namespace std ;
const ll maxn = 500000 ;
inline void Read ( ll &x ) {
    char c = getchar() ; bool f = 0 ; x = 0 ;
    while ( !isdigit(c) ) {
        if ( c == '-' ) f = 1 ;
        c = getchar() ;
    }
    while ( isdigit(c) ) {
        x = 10 * x + c - '0' ;
        c = getchar() ;
    } if (f) x = -x ;
}
ll n, m, size[maxn], son[maxn], fa[maxn], w[maxn], val[maxn], top[maxn], dep[maxn], zhf[maxn] ;
ll e, be[maxn], nxt[maxn<<1], to[maxn<<1], tree[maxn<<2], lzy[maxn<<2], cnt, in[maxn], out[maxn] ;

void init() {
    memset ( son, -1, sizeof(son) ) ;
}

void add ( ll x, ll y ) {
    to[++e] = y ;
    nxt[e] = be[x] ;
    be[x] = e ;
}

ll dfs1 ( ll x, ll father, ll deep ) {
    size[x] = 1 ;
    fa[x] = father ;
    dep[x] = deep ;
    ll i, u ;
    for ( i = be[x] ; i ; i = nxt[i] ) {
        u = to[i] ;
        if ( u == father ) continue ;
        size[x] += dfs1 ( u, x, deep+1 ) ;
        if ( son[x] == -1 || size[u] > size[son[x]] ) son[x] = u ;
    }
    return size[x] ;
}

void dfs2 ( ll x, ll Top ) {
    w[x] = ++cnt ;
    zhf[cnt] = val[x] ;
    top[x] = Top ;
    in[x] = cnt ;
    ll i, u ;
    if ( son[x] != -1 ) dfs2 ( son[x], Top ) ;
    else goto End ;
    for ( i = be[x] ; i ; i = nxt[i] ) {
        u = to[i] ;
        if ( u == fa[x] || u == son[x] ) continue ;
        dfs2 ( u, u ) ;
    }
    End : 
    out[x] = cnt ;
}

void push_up ( ll h ) { tree[h] = tree[h<<1]+tree[h<<1|1] ; }
void push_down ( ll h, ll len ) {
    if ( lzy[h] ) {
        lzy[h<<1] += lzy[h] ;
        lzy[h<<1|1] += lzy[h] ;
        tree[h<<1] += lzy[h] * ( len-(len>>1) ) ;
        tree[h<<1|1] += lzy[h] * (len>>1) ;
        lzy[h] = 0 ;
    }
}

void create_tree ( ll h, ll l, ll r ) {
    if ( l == r ) {
        tree[h] = zhf[l] ;
        return ; 
    }
    ll mid = l+r >> 1 ;
    create_tree ( h<<1, l, mid ) ;
    create_tree ( h<<1|1, mid+1, r ) ;
    push_up(h) ;
}

void update ( ll h, ll l, ll r, ll x, ll y, ll k ) {
    if ( x <= l && r <= y ) {
        tree[h] += (r-l+1) * k ;
        lzy[h] += k ;
        return ; 
    }
    push_down ( h, r-l+1 ) ;
    ll mid = l+r >> 1 ;
    if ( y <= mid ) update ( h<<1, l, mid, x, y, k ) ;
    else if ( x > mid ) update ( h<<1|1, mid+1, r, x, y, k ) ;
    else {
        update ( h<<1, l, mid, x, mid, k ) ;
        update ( h<<1|1, mid+1, r, mid+1, y, k ) ;
    } push_up(h) ;
}

ll query ( ll h, ll l, ll r, ll x, ll y ) {
    if ( x <= l && r <= y ) return tree[h] ;
    push_down ( h, r-l+1 ) ;
    ll mid = l+r >> 1 ;
    if ( y <= mid ) return query ( h<<1, l, mid, x, y ) ;
    else if ( x > mid ) return query ( h<<1|1, mid+1, r, x, y ) ;
    else return 
        query ( h<<1, l, mid, x, mid ) +
        query ( h<<1|1, mid+1, r, mid+1, y ) ;
}

ll Query ( ll u, ll v ) {
    ll rec = 0 ;
    while ( top[u] != top[v] ) {
        if ( dep[top[u]] > dep[top[v]] ) swap ( u, v ) ;
        rec += query ( 1, 1, n, w[top[v]], w[v] ) ;
        v = fa[top[v]] ;
    }
    if ( dep[u] > dep[v] ) swap ( u, v ) ;
    rec += query ( 1, 1, n, w[u], w[v] ) ;
    return rec ;
}

void UPDATE ( ll x, ll value ) { update ( 1, 1, n, in[x], out[x], value ) ; }

void Update ( ll u, ll v, ll value ) {
    while ( top[u] != top[v] ) {
        if ( dep[top[u]] > dep[top[v]] ) swap ( u, v ) ;
        update ( 1, 1, n, w[top[v]], w[v], value ) ;
        v = fa[top[v]] ;
    }
    if ( dep[u] > dep[v] ) swap ( u, v ) ;
    update ( 1, 1, n, w[u], w[v], value ) ;
}

int main() {
    ll i, j, k, u, v, op ;
    Read(n) ; Read(m) ;
    init() ;
    for ( i = 1 ; i <= n ; i ++ ) 
        Read(val[i]) ;
    for ( i = 1 ; i < n ; i ++ ) {
        Read(u) ; Read(v) ;
        add ( u, v ) ;
        add ( v, u ) ;
    }
    dfs1 ( 1, 1, 1 ) ;
    dfs2 ( 1, 1 ) ;
    create_tree ( 1, 1, n ) ;
    while (m--) {
        Read(op) ;
        if ( op == 1 ) {
            Read(u) ; Read(v) ;
            Update ( u, u, v ) ; 
        } else if ( op == 2 ) {
            Read(u) ; Read(v) ;
            UPDATE ( u, v ) ;
        } else {
            Read(u) ;
            printf ( "%lld\n", Query ( 1, u ) ) ;
        }
    }
    return 0 ;
}
```

---

## 作者：wanglichao1121 (赞：0)

明显套路题，强行树剖一波，题目的操作都是树剖支持的基本操作

```cpp
#include <bits/stdc++.h>
#define mid ((l+r)>>1)
using namespace std;
int n,m,N,NN,p,q,ca,x,y;
```
int size[100001],fa[100001],fir[100001],nex[200001],to[200001],
```cpp
    pos[100001],top[100001],a[100001],end[100001];
long long sum,tr[400001],flag[400001];
void Add(int p,int q)
{
    to[++NN]=q;nex[NN]=fir[p];fir[p]=NN;
}
int build(int now,int fat)
{
    size[now]=1;fa[now]=fat;
    for(int i=fir[now];i;i=nex[i])
        if(to[i]!=fat) size[now]+=build(to[i],now);
    return size[now];
}
void pou(int now,int To)
{
    pos[now]=++N;top[now]=To;int Max=0,ans=0;
    for(int i=fir[now];i;i=nex[i])
        if(to[i]!=fa[now] && size[to[i]]>Max)
            Max=size[to[i]],ans=to[i];
    if(ans)
        pou(ans,To);
    for(int i=fir[now];i;i=nex[i])
            if(to[i]!=fa[now] && to[i]!=ans) pou(to[i],to[i]);
    end[now]=N;
}
void push(int now,int l,int r)
{
    if(flag[now])
        tr[now*2]+=flag[now]*(mid-l+1),
        tr[now*2+1]+=flag[now]*(r-mid),
        flag[now*2]+=flag[now],flag[now*2+1]+=flag[now],flag[now]=0;
}
void add(int now,int l,int r,int x,int y,int z)
{
    if(l==x && r==y)
    {
        tr[now]+=(long long)(r-l+1)*z;flag[now]+=z;
        return;
    } 
    push(now,l,r);
    if(x<=mid) add(now*2,l,mid,x,min(y,mid),z);
    if(y>mid) add(now*2+1,mid+1,r,max(x,mid+1),y,z);
    tr[now]=tr[now*2]+tr[now*2+1];
}
long long que(int now,int l,int r,int x,int y)
{
    if(l==x && r==y)
        return tr[now];
    push(now,l,r);
    long long ans=0;
    if(x<=mid) ans+=que(now*2,l,mid,x,min(y,mid));
    if(y>mid) ans+=que(now*2+1,mid+1,r,max(x,mid+1),y);
    return ans;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=1;i<n;i++)
        scanf("%d%d",&p,&q),Add(p,q),Add(q,p);
    build(1,0);pou(1,1);
    for(int i=1;i<=n;i++)
        add(1,1,N,pos[i],pos[i],a[i]);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&ca,&x);
        if(ca<3) scanf("%d",&y);
        if(ca==1) add(1,1,N,pos[x],pos[x],y);
        if(ca==2) add(1,1,N,pos[x],end[x],y);
        if(ca==3)
        {
            for(sum=0;x;x=fa[top[x]])
                sum+=que(1,1,N,pos[top[x]],pos[x]);
            printf("%lld\n",sum);
        }
    }
    return 0;
}
```

---


# 【模板】重链剖分/树链剖分

## 题目描述

如题，已知一棵包含 $N$ 个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：

- `1 x y z`，表示将树从 $x$ 到 $y$ 结点最短路径上所有节点的值都加上 $z$。

- `2 x y`，表示求树从 $x$ 到 $y$ 结点最短路径上所有节点的值之和。

- `3 x z`，表示将以 $x$ 为根节点的子树内所有节点值都加上 $z$。

- `4 x`，表示求以 $x$ 为根节点的子树内所有节点值之和。

## 说明/提示

**【数据规模】**

对于 $30\%$ 的数据： $1 \leq N \leq 10$，$1 \leq M \leq 10$；

对于 $70\%$ 的数据： $1 \leq N \leq {10}^3$，$1 \leq M \leq {10}^3$；

对于 $100\%$ 的数据： $1\le N \leq {10}^5$，$1\le M \leq {10}^5$，$1\le R\le N$，$1\le P \le 2^{30}$。所有输入的数均在 `int` 范围内。

**【样例说明】**

树的结构如下：

![](https://cdn.luogu.com.cn/upload/pic/2319.png)

各个操作如下：

![](https://cdn.luogu.com.cn/upload/pic/2320.png)

故输出应依次为 $2$ 和 $21$。

## 样例 #1

### 输入

```
5 5 2 24
7 3 7 8 0 
1 2
1 5
3 1
4 1
3 4 2
3 2 2
4 5
1 5 1 3
2 1 3```

### 输出

```
2
21```

# 题解

## 作者：zengqinyi (赞：1055)

也可以看看博客：[入门树链剖分详解](http://www.cnblogs.com/chinhhh/p/7965433.html)

（话说复制markdown是真的麻烦）

#写在前面

首先，在学树链剖分之前最好先把 LCA、树形DP、DFS序 这三个知识点学了 
emm还有必备的 链式前向星、线段树 也要先学了。

如果这三个知识点没掌握好的话，树链剖分难以理解也是当然的。

-------------------------

#树链剖分

树链剖分 就是对一棵树分成几条链，把树形变为线性，减少处理难度

需要处理的问题：

- 将树从x到y结点最短路径上所有节点的值都加上z
- 求树从x到y结点最短路径上所有节点的值之和
- 将以x为根节点的子树内所有节点值都加上z
- 求以x为根节点的子树内所有节点值之和

## 概念

- 重儿子：对于每一个非叶子节点，它的儿子中 儿子数量最多的那一个儿子 为该节点的重儿子
- 轻儿子：对于每一个非叶子节点，它的儿子中 非重儿子 的剩下所有儿子即为轻儿子
- 叶子节点没有重儿子也没有轻儿子（因为它没有儿子。。）
- 重边：连接任意两个重儿子的边叫做重边
- 轻边：剩下的即为轻边
- 重链：相邻重边连起来的 连接一条重儿子 的链叫重链
- 对于叶子节点，若其为轻儿子，则有一条以自己为起点的长度为1的链
- 每一条重链以轻儿子为起点


![](https://images2018.cnblogs.com/blog/1256986/201712/1256986-20171203120143991-1630008815.png)

## dfs1()

这个dfs要处理几件事情：

- 标记每个点的深度dep[]
- 标记每个点的父亲fa[]
- 标记每个非叶子节点的子树大小(含它自己)
- 标记每个非叶子节点的重儿子编号son[]

```
inline void dfs1(int x,int f,int deep){//x当前节点，f父亲，deep深度 
dep[x]=deep;//标记每个点的深度 
fa[x]=f;//标记每个点的父亲 
siz[x]=1;//标记每个非叶子节点的子树大小 
int maxson=-1;//记录重儿子的儿子数 
for(Rint i=beg[x];i;i=nex[i]){
    int y=to[i];
    if(y==f)continue;//若为父亲则continue 
    dfs1(y,x,deep+1);//dfs其儿子 
    siz[x]+=siz[y];//把它的儿子数加到它身上 
    if(siz[y]>maxson)son[x]=y,maxson=siz[y];//标记每个非叶子节点的重儿子编号 
}
}//变量解释见最下面
```
## dfs2()

这个dfs2也要预处理几件事情

- 标记每个点的新编号
- 赋值每个点的初始值到新编号上
- 处理每个点所在链的顶端
- 处理每条链

顺序：**先处理重儿子再处理轻儿子**，理由后面说

```
inline void dfs2(int x,int topf){//x当前节点，topf当前链的最顶端的节点 
    id[x]=++cnt;//标记每个点的新编号 
    wt[cnt]=w[x];//把每个点的初始值赋到新编号上来 
    top[x]=topf;//这个点所在链的顶端 
    if(!son[x])return;//如果没有儿子则返回 
    dfs2(son[x],topf);//按先处理重儿子，再处理轻儿子的顺序递归处理 
    for(Rint i=beg[x];i;i=nex[i]){
        int y=to[i];
        if(y==fa[x]||y==son[x])continue;
        dfs2(y,y);//对于每一个轻儿子都有一条从它自己开始的链 
    }
}//变量解释见最下面
```

## 处理问题

**Attention 重要的来了！！！**
前面说到dfs2的顺序是先处理重儿子再处理轻儿子
我们来模拟一下：

![](https://images2018.cnblogs.com/blog/1256986/201712/1256986-20171203120207335-1162265491.png)


- 因为顺序是先重再轻，所以每一条重链的新编号是连续的
- 因为是dfs，所以每一个子树的新编号也是连续的

现在回顾一下我们要处理的问题

- 处理任意两点间路径上的点权和
- 处理一点及其子树的点权和
- 修改任意两点间路径上的点权
- 修改一点及其子树的点权

1、当我们要处理任意两点间路径时：
设所在链顶端的深度更深的那个点为x点

- ans加上x点到x所在链顶端 这一段区间的点权和
- 把x跳到x所在链顶端的那个点的上面一个点

不停执行这两个步骤，直到两个点处于一条链上，这时再加上此时两个点的区间和即可

![](https://images2018.cnblogs.com/blog/1256986/201712/1256986-20171203120221226-353167092.png)

这时我们注意到，我们所要处理的所有区间均为连续编号(新编号)，于是想到线段树，用线段树处理连续编号区间和

每次查询时间复杂度为$O(log^2n)$

```
inline int qRange(int x,int y){
    int ans=0;
    while(top[x]!=top[y]){//当两个点不在同一条链上 
        if(dep[top[x]]<dep[top[y]])swap(x,y);//把x点改为所在链顶端的深度更深的那个点
        res=0;
        query(1,1,n,id[top[x]],id[x]);//ans加上x点到x所在链顶端 这一段区间的点权和
        ans+=res;
        ans%=mod;//按题意取模 
        x=fa[top[x]];//把x跳到x所在链顶端的那个点的上面一个点
    }
    //直到两个点处于一条链上
    if(dep[x]>dep[y])swap(x,y);//把x点深度更深的那个点
    res=0;
    query(1,1,n,id[x],id[y]);//这时再加上此时两个点的区间和即可
    ans+=res;
    return ans%mod;
}//变量解释见最下面
```

2、处理一点及其子树的点权和：

想到记录了每个非叶子节点的子树大小(含它自己)，并且每个子树的新编号都是连续的

于是直接线段树区间查询即可

时间复杂度为$O(logn)$

```
inline int qSon(int x){
    res=0;
    query(1,1,n,id[x],id[x]+siz[x]-1);//子树区间右端点为id[x]+siz[x]-1 
    return res;
}
```
当然，区间修改就和区间查询一样的啦~~
```
inline void updRange(int x,int y,int k){
    k%=mod;
    while(top[x]!=top[y]){
        if(dep[top[x]]<dep[top[y]])swap(x,y);
        update(1,1,n,id[top[x]],id[x],k);
        x=fa[top[x]];
    }
    if(dep[x]>dep[y])swap(x,y);
    update(1,1,n,id[x],id[y],k);
}

inline void updSon(int x,int k){
    update(1,1,n,id[x],id[x]+siz[x]-1,k);
}//变量解释见最下面
```


## 建树

既然前面说到要用线段树，那么按题意建树就可以啦！
不过，建树这一步当然是在处理问题之前哦~


AC代码：

```cpp
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<cstdio>
#define Rint register int
#define mem(a,b) memset(a,(b),sizeof(a))
#define Temp template<typename T>
using namespace std;
typedef long long LL;
Temp inline void read(T &x){
    x=0;T w=1,ch=getchar();
    while(!isdigit(ch)&&ch!='-')ch=getchar();
    if(ch=='-')w=-1,ch=getchar();
    while(isdigit(ch))x=(x<<3)+(x<<1)+(ch^'0'),ch=getchar();
    x=x*w;
}

#define mid ((l+r)>>1)
#define lson rt<<1,l,mid
#define rson rt<<1|1,mid+1,r
#define len (r-l+1)

const int maxn=200000+10;
int n,m,r,mod;
//见题意 
int e,beg[maxn],nex[maxn],to[maxn],w[maxn],wt[maxn];
//链式前向星数组，w[]、wt[]初始点权数组 
int a[maxn<<2],laz[maxn<<2];
//线段树数组、lazy操作 
int son[maxn],id[maxn],fa[maxn],cnt,dep[maxn],siz[maxn],top[maxn]; 
//son[]重儿子编号,id[]新编号,fa[]父亲节点,cnt dfs_clock/dfs序,dep[]深度,siz[]子树大小,top[]当前链顶端节点 
int res=0;
//查询答案 

inline void add(int x,int y){//链式前向星加边 
    to[++e]=y;
    nex[e]=beg[x];
    beg[x]=e;
}
//-------------------------------------- 以下为线段树 
inline void pushdown(int rt,int lenn){
    laz[rt<<1]+=laz[rt];
    laz[rt<<1|1]+=laz[rt];
    a[rt<<1]+=laz[rt]*(lenn-(lenn>>1));
    a[rt<<1|1]+=laz[rt]*(lenn>>1);
    a[rt<<1]%=mod;
    a[rt<<1|1]%=mod;
    laz[rt]=0;
}

inline void build(int rt,int l,int r){
    if(l==r){
        a[rt]=wt[l];
        if(a[rt]>mod)a[rt]%=mod;
        return;
    }
    build(lson);
    build(rson);
    a[rt]=(a[rt<<1]+a[rt<<1|1])%mod;
}

inline void query(int rt,int l,int r,int L,int R){
    if(L<=l&&r<=R){res+=a[rt];res%=mod;return;}
    else{
        if(laz[rt])pushdown(rt,len);
        if(L<=mid)query(lson,L,R);
        if(R>mid)query(rson,L,R);
    }
}

inline void update(int rt,int l,int r,int L,int R,int k){
    if(L<=l&&r<=R){
        laz[rt]+=k;
        a[rt]+=k*len;
    }
    else{
        if(laz[rt])pushdown(rt,len);
        if(L<=mid)update(lson,L,R,k);
        if(R>mid)update(rson,L,R,k);
        a[rt]=(a[rt<<1]+a[rt<<1|1])%mod;
    }
}
//---------------------------------以上为线段树 
inline int qRange(int x,int y){
    int ans=0;
    while(top[x]!=top[y]){//当两个点不在同一条链上 
        if(dep[top[x]]<dep[top[y]])swap(x,y);//把x点改为所在链顶端的深度更深的那个点
        res=0;
        query(1,1,n,id[top[x]],id[x]);//ans加上x点到x所在链顶端 这一段区间的点权和
        ans+=res;
        ans%=mod;//按题意取模 
        x=fa[top[x]];//把x跳到x所在链顶端的那个点的上面一个点
    }
    //直到两个点处于一条链上
    if(dep[x]>dep[y])swap(x,y);//把x点深度更深的那个点
    res=0;
    query(1,1,n,id[x],id[y]);//这时再加上此时两个点的区间和即可
    ans+=res;
    return ans%mod;
}

inline void updRange(int x,int y,int k){//同上 
    k%=mod;
    while(top[x]!=top[y]){
        if(dep[top[x]]<dep[top[y]])swap(x,y);
        update(1,1,n,id[top[x]],id[x],k);
        x=fa[top[x]];
    }
    if(dep[x]>dep[y])swap(x,y);
    update(1,1,n,id[x],id[y],k);
}

inline int qSon(int x){
    res=0;
    query(1,1,n,id[x],id[x]+siz[x]-1);//子树区间右端点为id[x]+siz[x]-1 
    return res;
}

inline void updSon(int x,int k){//同上 
    update(1,1,n,id[x],id[x]+siz[x]-1,k);
}

inline void dfs1(int x,int f,int deep){//x当前节点，f父亲，deep深度 
    dep[x]=deep;//标记每个点的深度 
    fa[x]=f;//标记每个点的父亲 
    siz[x]=1;//标记每个非叶子节点的子树大小 
    int maxson=-1;//记录重儿子的儿子数 
    for(Rint i=beg[x];i;i=nex[i]){
        int y=to[i];
        if(y==f)continue;//若为父亲则continue 
        dfs1(y,x,deep+1);//dfs其儿子 
        siz[x]+=siz[y];//把它的儿子数加到它身上 
        if(siz[y]>maxson)son[x]=y,maxson=siz[y];//标记每个非叶子节点的重儿子编号 
    }
}

inline void dfs2(int x,int topf){//x当前节点，topf当前链的最顶端的节点 
    id[x]=++cnt;//标记每个点的新编号 
    wt[cnt]=w[x];//把每个点的初始值赋到新编号上来 
    top[x]=topf;//这个点所在链的顶端 
    if(!son[x])return;//如果没有儿子则返回 
    dfs2(son[x],topf);//按先处理重儿子，再处理轻儿子的顺序递归处理 
    for(Rint i=beg[x];i;i=nex[i]){
        int y=to[i];
        if(y==fa[x]||y==son[x])continue;
        dfs2(y,y);//对于每一个轻儿子都有一条从它自己开始的链 
    }
}

int main(){
    read(n);read(m);read(r);read(mod);
    for(Rint i=1;i<=n;i++)read(w[i]);
    for(Rint i=1;i<n;i++){
        int a,b;
        read(a);read(b);
        add(a,b);add(b,a);
    }
    dfs1(r,0,1);
    dfs2(r,r);
    build(1,1,n);
    while(m--){
        int k,x,y,z;
        read(k);
        if(k==1){
            read(x);read(y);read(z);
            updRange(x,y,z);
        }
        else if(k==2){
            read(x);read(y);
            printf("%d\n",qRange(x,y));
        }
        else if(k==3){
            read(x);read(y);
            updSon(x,y);
        }
        else{
            read(x);
            printf("%d\n",qSon(x));
        }
    }
}
```

---

## 作者：attack (赞：229)


[更好的阅读体验及例题点这里](http://www.cnblogs.com/zwfymqz/p/8094500.html)


## 前言


- 树链剖分是什么？


树链剖分，说白了就是一种让你代码不得不强行增加1k的数据结构-dms

- 有什么用？

~~证明出题人非常毒瘤~~

可以非常友(bao)好(li)的解决一些树上问题


## 核心思想

树链剖分的思想比较神奇


它的思想是：**把一棵树拆成若干个不相交的链，然后用一些数据结构去维护这些链**


 

那么问题来了


- 如何把树拆成链？


首先明确一些定义

**重儿子**：该节点的子树中,节点个数最多的子树的根节点(也就是和该节点相连的点)，即为该节点的重儿子

**重边**：连接该节点与它的重儿子的边

**重链**：由一系列重边相连得到的链

**轻链**：由一系列非重边相连得到的链


这样就不难得到拆树的方法

**对于每一个节点，找出它的重儿子，那么这棵树就自然而然的被拆成了许多重链与许多轻链**


-  如何对这些链进行维护？


首先，要对这些链进行维护，就要确保每个链上的节点都是连续的，

因此我们需要对整棵树进行重新编号，然后利用dfs序的思想，用线段树或树状数组等进行维护（具体用什么需要看题目要求，因为线段树的功能比树状数组强大，所以在这里我就不提供树状数组的写法了）


注意在进行重新编号的时候先访问重链

这样可以保证重链内的节点编号连续

上面说的太抽象了，结合一张图来理解一下

![](http://images2017.cnblogs.com/blog/1101696/201712/1101696-20171224081845381-1133998892.png)

对于一棵最基本的树

给他标记重儿子，

![](http://images2017.cnblogs.com/blog/1101696/201712/1101696-20171224082406709-293882916.png)

蓝色为重儿子，红色为重边

然后对树进行重新编号

![](http://images2017.cnblogs.com/blog/1101696/201712/1101696-20171224082851146-1417020317.png)

橙色表示的是该节点重新编号后的序号

不难看出重链内的节点编号是连续的


然后就可以在线段树上搞事情啦

像什么区间加区间求和什么的

另外有一个性质：以$i$为根的子树的树在线段树上的编号为$[i,i+子树节点数-1]$


接下来结合一道例题，加深一下对于代码的理解

## 代码

首先来一坨定义

```cpp
int deep[MAXN];//节点的深度 
int fa[MAXN];//节点的父亲 
int son[MAXN];//节点的重儿子 
int tot[MAXN];//节点子树的大小 
```
### 第一步

按照我们上面说的，我们首先要对整棵树dfs一遍，找出每个节点的重儿子

顺便处理出每个节点的深度，以及他们的父亲节点

```cpp
int dfs1(int now,int f,int dep)
{
    deep[now]=dep;
    fa[now]=f;
    tot[now]=1;
    int maxson=-1;
    for(int i=head[now];i!=-1;i=edge[i].nxt)
    {
        if(edge[i].v==f) continue;
        tot[now]+=dfs1(edge[i].v,now,dep+1);
        if(tot[edge[i].v]>maxson) maxson=tot[edge[i].v],son[now]=edge[i].v;
    }
    return tot[now];
}
```
### 第二步
然后我们需要对整棵树进行重新编号

我把一开始的每个节点的权值存在了$b$数组内

```cpp
void dfs2(int now,int topf)
{
    idx[now]=++cnt;
    a[cnt]=b[now];
    top[now]=topf;
    if(!son[now]) return ;
    dfs2(son[now],topf);
    for(int i=head[now];i!=-1;i=edge[i].nxt)
        if(!idx[edge[i].v])
            dfs2(edge[i].v,edge[i].v);
}
```
$idx$表示重新编号后该节点的编号是多少
另外，这里引入了一个$top$数组，

$top[i]$表示$i$号节点所在重链的头节点(最顶上的节点)

至于这个数组有啥用，后面再说

### 第三步

我们需要根据重新编完号的树，把这棵树的上每个点映射到线段树上，

```cpp
struct Tree
{
    int l,r,w,siz,f;
}T[MAXN];
void Build(int k,int ll,int rr)
{
    T[k].l=ll;T[k].r=rr;T[k].siz=rr-ll+1;
    if(ll==rr)
    {
        T[k].w=a[ll];
        return ;
    }
    int mid=(ll+rr)>>1;
    Build(ls,ll,mid);
    Build(rs,mid+1,rr);
    update(k);
}
```
另外线段树的基本操作，
这里就不详细解释了

直接放代码

```cpp
void update(int k)//更新
{
    T[k].w=(T[ls].w+T[rs].w+MOD)%MOD;
}
void IntervalAdd(int k,int ll,int rr,int val)//区间加
{
    if(ll<=T[k].l&&T[k].r<=rr)
    {
        T[k].w+=T[k].siz*val;
        T[k].f+=val;
        return ;
    }
    pushdown(k);
    int mid=(T[k].l+T[k].r)>>1;
    if(ll<=mid)    IntervalAdd(ls,ll,rr,val);
    if(rr>mid)    IntervalAdd(rs,ll,rr,val);
    update(k);
}
int IntervalSum(int k,int ll,int rr)//区间求和
{
    int ans=0;
    if(ll<=T[k].l&&T[k].r<=rr)
        return T[k].w;
    pushdown(k);
    int mid=(T[k].l+T[k].r)>>1;
    if(ll<=mid) ans=(ans+IntervalSum(ls,ll,rr))%MOD;
    if(rr>mid)  ans=(ans+IntervalSum(rs,ll,rr))%MOD;
    return ans;
}
void pushdown(int k)//下传标记
{
    if(!T[k].f) return ;
    T[ls].w=(T[ls].w+T[ls].siz*T[k].f)%MOD;
    T[rs].w=(T[rs].w+T[rs].siz*T[k].f)%MOD;
    T[ls].f=(T[ls].f+T[k].f)%MOD;
    T[rs].f=(T[rs].f+T[k].f)%MOD;
    T[k].f=0;
}
```
### 第四步
我们考虑如何实现对于树上的操作

树链剖分的思想是:对于两个不在同一重链内的节点,让他们不断地跳,使得他们处于同一重链上

那么如何"跳”呢？

还记得我们在第二次$dfs$中记录的$top$数组么？

有一个显然的结论：$x$到$top[x]$中的节点在线段树上是连续的，

结合$deep$数组

假设两个节点为$x$,$y$

我们每次让$deep[top[x]]$与$deep[top[y]]$中大的(在下面的)往上跳(有点类似于树上倍增)

让x节点直接跳到$top[x]$,然后在线段树上更新

最后两个节点一定是处于同一条重链的，前面我们提到过重链上的节点都是连续的，直接在线段树上进行一次查询就好

```cpp
void TreeSum(int x,int y)//x与y路径上的和
{
    int ans=0;
    while(top[x]!=top[y])
    {
        if(deep[top[x]]<deep[top[y]]) swap(x,y);
        ans=(ans+IntervalSum(1,idx[ top[x] ],idx[x]))%MOD;
        x=fa[ top[x] ];
    }
    if(deep[x]>deep[y]) swap(x,y);
    ans=(ans+IntervalSum(1,idx[x],idx[y]))%MOD;
    printf("%d\n",ans);
}
void TreeAdd(int x,int y,int val)//对于x,y路径上的点加val的权值
{
    while(top[x]!=top[y])
    {
        if(deep[top[x]]<deep[top[y]]) swap(x,y);
        IntervalAdd(1,idx[ top[x] ],idx[x],val);
        x=fa[ top[x] ];
    }
    if(deep[x]>deep[y])    swap(x,y);
    IntervalAdd(1,idx[x],idx[y],val);
}
```
在树上查询的这一步可能有些抽象，我们结合一个例子来理解一下

![](http://images2017.cnblogs.com/blog/1101696/201712/1101696-20171224083619412-395006861.png)

还是上面那张图，假设我们要查询$3.6$这两个节点的之间的点权合，为了方便理解我们假设每个点的点权都是$1$

刚开始时

$top[3]=2,top[6]=1$

$deep[top[3]]=2,deep[top[6]]=1$

我们会让$3$向上跳,跳到$top[3]$的爸爸,也就是$1$号节点

![](http://images2017.cnblogs.com/blog/1101696/201712/1101696-20171224084036146-1852472774.png)

这时$1$号节点和$6$号节点已经在同一条重链内,所以直接对线段树进行一次查询即可

### 对于子树的操作

这个就更简单了

因为一棵树的子树在线段树上是连续的

所以修改的时候直接这样

IntervalAdd(1,idx[x],idx[x]+tot[x]-1,z%MOD);

## 时间复杂度

### 性质1

如果边$\left( u,v\right)$,为轻边,那么$Size\left( v\right) \leq Size\left( u\right) /2$。

证明：显然，否则该边会成为重边

### 性质2

树中任意两个节点之间的路径中轻边的条数不会超过$\log _{2}n$,重路径的数目不会超过$\log _{2}n$

证明：不会

有了上面两条性质，我们就可以来分析时间复杂度了

由于重路径的数量的上界为$\log _{2}n$，

线段树中查询/修改的复杂度为$\log _{2}n$

那么总的复杂度就是$\left( \log _{2}n\right) ^{2}$

## 完整代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int MAXN=2*1e6+10;
#define ls k<<1
#define rs k<<1|1
inline char nc()
{
    static char buf[MAXN],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,MAXN,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    char c=nc();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=nc();}
    while(c>='0'&&c<='9'){x=x*10+c-'0',c=nc();}
    return x*f;
}
struct node
{
    int u,v,nxt;
}edge[MAXN];
int head[MAXN];
int num=1;
struct Tree
{
    int l,r,w,siz,f;
}T[MAXN];
int N,M,root,MOD,cnt=0,a[MAXN],b[MAXN];
inline void AddEdge(int x,int y)
{
    edge[num].u=x;
    edge[num].v=y;
    edge[num].nxt=head[x];
    head[x]=num++;
}
int deep[MAXN],fa[MAXN],son[MAXN],tot[MAXN],top[MAXN],idx[MAXN];
int dfs1(int now,int f,int dep)
{
    deep[now]=dep;
    fa[now]=f;
    tot[now]=1;
    int maxson=-1;
    for(int i=head[now];i!=-1;i=edge[i].nxt)
    {
        if(edge[i].v==f) continue;
        tot[now]+=dfs1(edge[i].v,now,dep+1);
        if(tot[edge[i].v]>maxson) maxson=tot[edge[i].v],son[now]=edge[i].v;
    }
    return tot[now];
}
void update(int k)
{
    T[k].w=(T[ls].w+T[rs].w+MOD)%MOD;
}
void Build(int k,int ll,int rr)
{
    T[k].l=ll;T[k].r=rr;T[k].siz=rr-ll+1;
    if(ll==rr)
    {
        T[k].w=a[ll];
        return ;
    }
    int mid=(ll+rr)>>1;
    Build(ls,ll,mid);
    Build(rs,mid+1,rr);
    update(k);
}
void dfs2(int now,int topf)
{
    idx[now]=++cnt;
    a[cnt]=b[now];
    top[now]=topf;
    if(!son[now]) return ;
    dfs2(son[now],topf);
    for(int i=head[now];i!=-1;i=edge[i].nxt)
        if(!idx[edge[i].v])
            dfs2(edge[i].v,edge[i].v);
}
void pushdown(int k)
{
    if(!T[k].f) return ;
    T[ls].w=(T[ls].w+T[ls].siz*T[k].f)%MOD;
    T[rs].w=(T[rs].w+T[rs].siz*T[k].f)%MOD;
    T[ls].f=(T[ls].f+T[k].f)%MOD;
    T[rs].f=(T[rs].f+T[k].f)%MOD;
    T[k].f=0;
}
void IntervalAdd(int k,int ll,int rr,int val)
{
    if(ll<=T[k].l&&T[k].r<=rr)
    {
        T[k].w+=T[k].siz*val;
        T[k].f+=val;
        return ;
    }
    pushdown(k);
    int mid=(T[k].l+T[k].r)>>1;
    if(ll<=mid)    IntervalAdd(ls,ll,rr,val);
    if(rr>mid)    IntervalAdd(rs,ll,rr,val);
    update(k);
}
void TreeAdd(int x,int y,int val)
{
    while(top[x]!=top[y])
    {
        if(deep[top[x]]<deep[top[y]]) swap(x,y);
        IntervalAdd(1,idx[ top[x] ],idx[x],val);
        x=fa[ top[x] ];
    }
    if(deep[x]>deep[y])    swap(x,y);
    IntervalAdd(1,idx[x],idx[y],val);
}
int IntervalSum(int k,int ll,int rr)
{
    int ans=0;
    if(ll<=T[k].l&&T[k].r<=rr)
        return T[k].w;
    pushdown(k);
    int mid=(T[k].l+T[k].r)>>1;
    if(ll<=mid) ans=(ans+IntervalSum(ls,ll,rr))%MOD;
    if(rr>mid)  ans=(ans+IntervalSum(rs,ll,rr))%MOD;
    return ans;
}
void TreeSum(int x,int y)
{
    int ans=0;
    while(top[x]!=top[y])
    {
        if(deep[top[x]]<deep[top[y]]) swap(x,y);
        ans=(ans+IntervalSum(1,idx[ top[x] ],idx[x]))%MOD;
        x=fa[ top[x] ];
    }
    if(deep[x]>deep[y]) swap(x,y);
    ans=(ans+IntervalSum(1,idx[x],idx[y]))%MOD;
    printf("%d\n",ans);
}
int main()
{
    #ifdef WIN32
    freopen("a.in","r",stdin);
    #else
    #endif
    memset(head,-1,sizeof(head));
    N=read();M=read();root=read();MOD=read();
    for(int i=1;i<=N;i++) b[i]=read();
    for(int i=1;i<=N-1;i++)
    {
        int x=read(),y=read();
        AddEdge(x,y);AddEdge(y,x);
    }
    dfs1(root,0,1);
    dfs2(root,root);
    Build(1,1,N);
    while(M--)
    {
        int opt=read(),x,y,z;
        if(opt==1)
        {    
            x=read();y=read();z=read();z=z%MOD;
            TreeAdd(x,y,z);
        }
        else if(opt==2)
        {
            x=read();y=read();
            TreeSum(x,y);
        }
        else if(opt==3)
        {
            x=read(),z=read();
            IntervalAdd(1,idx[x],idx[x]+tot[x]-1,z%MOD);
        }
        else if(opt==4)
        {
            x=read();
            printf("%d\n",IntervalSum(1,idx[x],idx[x]+tot[x]-1));
        }
    }
    return 0;
}
```

---

## 作者：NaCly_Fish (赞：213)

>## 树上路径，分清边孰轻孰重。  

## ——《我的一个OIer朋友》

树链剖分，简称树剖。是一种巧妙的算法，可以把树划分成许多链，简便地实现树上的修改与查询操作。   

（这里说的 树链剖分 指的是 轻重链剖分）  
↑ 如果你初学树剖可以无视这句话。



在接下来的讲解中，您将**不可避免**地接触以下名词：  

1. 重儿子：对于一个非叶子节点 $u$，它会有许多儿子。其中有一个儿子的孩子最多（也就是子树最大），那么这个儿子就叫 $u$ 的重儿子；  
2. 轻儿子：不是重儿子，就是轻儿子；  
3. 重链：一条全部以重儿子为节点的路径，除了顶部为轻儿子。

此处名词解释相对其它很多 blog 有所简化，不过不影响阅读。  
纯文字的描述好像不太方便，那我们拿张图来：  
![](https://cdn.luogu.com.cn/upload/pic/45367.png)   

图中，重儿子、重链都用红色标出来了。  
我们可以看到，对于节点 $1$ 来说，它的儿子 $2$ 号节点子树最大，因此 $2$ 是 $1$ 的重儿子。  
对于 $2$ 号点，它的儿子 $6$ 号节点子树最大，因此 $6$ 是 $2$ 的重儿子。  
对于其它节点同理。如果想加深印象，可以试着手动模拟一下。   

接着就是重头戏了：如何代码实现树剖

树剖的实际上就是两遍预处理，第一步要算出以下数据：  
对于任意节点 $u$ 的`深度`、`子树大小`、`重儿子编号`、`父节点编号`；分别记为：$\text{depth , size , son , fa}$  
这点用一个简单的 DFS 就可以实现，时间复杂度 $\Theta(n)$：
```cpp
void dfs1(int u,int f){ //u为当前节点，f为父节点
    fa[u] = f;
    size[u] = 1; //子树大小要算上子树的根节点，也就是u
    depth[u] = depth[f]+1; //比父亲深度大1
    int v,t = -1,l = adj[u].size(); //此处使用vector存图
    for(int i=0;i<l;++i){ //遍历连接u的点v
        v = adj[u][i];
        if(v==f) continue;
        dfs1(v,u);
        size[u] += size[v];
        if(size[v]>t){ 
        	//如果这个子树大小比已找到的还大，那就更新已找到的，同时更新u的重儿子为v
            t = size[v];
            son[u] = v;
        }
    }
}
```  

第二遍预处理，则需要计算：  

对于任意节点 $u$ 的`所在重链顶点`，`第几个被遍历`，分别记为 $\text{top , id}$  
时间复杂度也是线性的。
```cpp
void dfs2(int u,int f){ //这里f就不是指父亲了，是u所在重链的顶端节点
    top[u] = f;
    id[u] = ++cnt;
    if(w[u]!=0)
        add(id[u],id[u],w[u]); //树状数组维护区间和，w[u]为u的初始权值
    if(son[u]==0) return; //重儿子编号为0意味着没有儿子，返回
    dfs2(son[u],f); //先从重儿子开始dfs，这样可以使一条重链上的节点id连续，便于区间操作
    int v,l = adj[u].size();
    for(int i=0;i<l;++i){
        v = adj[u][i];
        if(v==son[u]||v==fa[u]) continue;
        dfs2(v,v); //由于是轻儿子，所以其所在重链顶端节点自然是自己
    }
}
```   
~~然后你就学会了树剖~~  
并不是，你还需要实现修改和查询。  
在考虑这个问题之前，我们先来看一下刚才预处理的成果吧：   
现在把前面贴的图改了一下，逗号后面的数表示这个节点的 $\text{id}$    
![](https://cdn.luogu.com.cn/upload/pic/45373.png)   
来看一下各点的 $\text{id}$，你可以发现两个性质：  
1. 一条重链上的点 $\text{id}$ 连续；  
2. 一棵子树上的点 $\text{id}$ 也连续。

  
接下来就要利用这个性质搞定那四个操作啦！  
来看第一个操作：  

> 将树从 $x$ 到 $y$ 结点最短路径上所有节点的值都加上 $z$

我们可以回想一下当初倍增求 LCA 的时候，是怎么办的？  
就是两个节点，深度大的往上跳，一直跳到父亲相同。  
这里的思想也和求 LCA 很相似。   

由于每条重链上的点 $\text{id}$ 连续，所以我们可以直接调用 
```cpp
add(id[top[u]],id[u],k);
```  
就可以把 $u$ 到其重链顶点的节点值都增加 $k$  
（这里 add 就是区间加操作）  

加完了之后，我们再执行  
```cpp
u = fa[top[u]];
```  
这样就 $u$ 跳到其重链顶上去了。两个节点按这样的方式不断向上跳，直到一条重链上。  
于是操作 1 就完成了，完整代码如下：
```cpp
void addPath(int u,int v,int k){
    while(top[u]!=top[v]){
        if(depth[top[u]]<depth[top[v]])  
            swap(u,v); //深度大的点先跳，保证能跳到一条重链上
        add(id[top[u]],id[u],k);    
        u = fa[top[u]];
    }
    if(depth[u]>depth[v]) swap(u,v);
    add(id[u],id[v],k); //在一条重链上，直接加
}

```
操作 2 只是大同小异，区间修改变成了区间查询而已。  
```cpp
int queryPath(int u,int v){
    int res = 0;
    while(top[u]!=top[v]){
        if(depth[top[u]]<depth[top[v]])
            swap(u,v);
        res += query(id[top[u]],id[u]);
        u = fa[top[u]];
    }
    if(depth[u]>depth[v]) swap(u,v);
    res += query(id[u],id[v]);
    return res;
}
```   
接下来看操作3：  

> 将以 $x$ 为根节点的子树内所有节点值都加上 $z$

关于子树的操作其实非常简单。  
题目的修改和查询都是对整个子树的。又由于子树的节点 $\text{id}$ 是连续的，所以该怎么办已经很清楚了吧。  

修改和查询依然很相似，直接放在一起贴出来：
```cpp
int querySon(int u){
    return query(id[u],id[u]+size[u]-1);
    //id[u]到id[u]+size[u]-1刚好涵盖了u的所有子节点id，下同
}

void addSon(int u,int k){
    add(id[u],id[u]+size[u]-1,k);
}
```   

然后这题代码就出来了，但是题目中多了个取模，注意要加上。  

总时间复杂度为 $\Theta(n\log^2 n)$：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector>
#include<queue>
#define N 100003
#define inf 0x3f3f3f3f
#define ll long long
using namespace std;

vector<int> adj[N];
int n,m,r,p,cnt;
int son[N],depth[N],fa[N],size[N];
int id[N],top[N],w[N];
ll c1[N],c2[N];

//以下为树状数组
inline int lowbit(int x){
    return x&(-x);
}

inline void add(int l,int r,int x){
    x %= p;
    int ad1 = (ll)(l-1)*x%p;
    int ad2 = (ll)r*x%p;
    for(int t=l;t<=n;t+=lowbit(t)){
        c1[t] = (c1[t]+x)%p;
        c2[t] = (c2[t]+ad1)%p;
    }
    for(int t=r+1;t<=n;t+=lowbit(t)){
        c1[t] = (c1[t]-x)%p;
        c1[t] = (c1[t]+p)%p;
        c2[t] = (c2[t]-ad2)%p;
        c2[t] = (c2[t]+p)%p;
    }
}

inline int qwq(int i){ //qwq
    int res = 0;
    for(int t=i;t>0;t-=lowbit(t)){
        res = (res+(ll)i*c1[t]%p)%p;
        res = (res-c2[t])%p;
        res = (res+p)%p;
    }
    return res;
}

inline int query(int l,int r){
    int res = (qwq(r)-qwq(l-1))%p;
    return (res+p)%p;
}
//以上树状数组

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}

void dfs1(int u,int f){
    fa[u] = f;
    size[u] = 1;
    depth[u] = depth[f]+1;
    int v,t = -1,l = adj[u].size();
    for(int i=0;i<l;++i){
        v = adj[u][i];
        if(v==f) continue;
        dfs1(v,u);
        size[u] += size[v];
        if(size[v]>t){
            t = size[v];
            son[u] = v;
        }
    }
}

void dfs2(int u,int f){
    top[u] = f;
    id[u] = ++cnt;
    if(w[u]!=0)
        add(id[u],id[u],w[u]);
    if(son[u]==0) return;
    dfs2(son[u],f);
    int v,l = adj[u].size();
    for(int i=0;i<l;++i){
        v = adj[u][i];
        if(v==son[u]||v==fa[u]) continue;
        dfs2(v,v);
    }
}

int queryPath(int u,int v){
    int res = 0;
    while(top[u]!=top[v]){
        if(depth[top[u]]<depth[top[v]])
            swap(u,v);
        res = (res+query(id[top[u]],id[u]))%p;
        u = fa[top[u]];
    }
    if(depth[u]>depth[v]) swap(u,v);
    res = (res+query(id[u],id[v]))%p;
    return res;
}

void addPath(int u,int v,int k){
    k %= p;
    while(top[u]!=top[v]){
        if(depth[top[u]]<depth[top[v]])
            swap(u,v);
        add(id[top[u]],id[u],k);    
        u = fa[top[u]];
    }
    if(depth[u]>depth[v]) swap(u,v);
    add(id[u],id[v],k);
}

int querySon(int u){
    return query(id[u],id[u]+size[u]-1);
}

void addSon(int u,int k){
    k %= p;
    add(id[u],id[u]+size[u]-1,k);
}

int main(){
    int u,v;
    read(n),read(m),read(r),read(p);
    for(int i=1;i<=n;++i)
        read(w[i]);
    for(int i=1;i<n;++i){
        read(u),read(v);
        adj[u].push_back(v);
        adj[v].push_back(u);
    }    
    dfs1(r,0);
    dfs2(r,r);
    int ans,op,x,y,z;
    while(m--){
        read(op),read(x);
        if(op==1){
            read(y),read(z);
            addPath(x,y,z);
            continue;
        }
        if(op==2){
            read(y);
            ans = queryPath(x,y);
            print(ans);
            putchar('\n');
            continue;
        }
        if(op==3){
            read(z);
            addSon(x,z);
            continue;
        }
        ans = querySon(x);
        print(ans);
        putchar('\n');
    }
    return 0;
}
```   
此外，树剖还可以用来求LCA，代码比倍增法短很多：  
```cpp
inline int lca(int u,int v){
	while(top[u]!=top[v]){
    	if(depth[top[u]]<depth[top[v]])
        	swap(u,v);
        u = fa[top[u]];    
    }
    if(depth[u]<depth[v]) return u;
    return v;
}
```
~~是不是超级简单~~

---

## 作者：xpigeon (赞：11)

# 【模板】树链剖分

## 前言

树剖的基本思想是将树按一定方式剖分成若干条重链，重链便转化为了序列，随后我们就可以使用线段树来维护这序列上的值，这样，树上的修改与查询就成为了序列上的修改与查询，以达到更优时间复杂度的目的。

本篇题解将着重讲解树剖相关内容，对此，你需要学习的前置知识有：
1. [线段树](https://oi-wiki.org/ds/seg/)。
2. [最近公共祖先](https://oi-wiki.org/graph/lca/)的相关定义，以免我下面提到这个词你看不懂
3. 因为是树上问题所以要了解[链式前向星存图](https://oi-wiki.org/graph/save/)

## 树剖基本内容

对于树剖这种方法具体如何剖分一颗树。我们由浅入深，逐步来讲解。

### 相关定义

- 重儿子：某个父节点的儿子中，子树大小（也就是子树中节点最多的）最大的节点。（同时规定一个节点的重儿子只有一个）
- 轻儿子：某个父节点的儿子中，非重儿子的节点。
- 重边：父节点与其重儿子连成的边。
- 轻边：父节点与其轻儿子连成的边。
- 重链：由多条重边连成的链。（叶子节点单独成链）

放一张图辅助理解：

![](https://cdn.luogu.com.cn/upload/image_hosting/duojmqm5.png)

上图内容不难从定义推得，我挑取一部分详细解释一下（认为自己能够完全理解定义的同学可以跳过了）：

- $1$ 节点的重儿子是 $4$（其子树大小为 $4$ 并且无法在 $1$ 节点的其他儿子节点找到子树大小更大的）。
- $2$ 节点的重儿子是 $5$（因为只有一个儿子，所以你当然无法找到第二个子树大小更大的）。
- $3$ 节点的重儿子可以在 $6$ 或者 $7$ 中任意选得，因为它们的子树大小是一样的，但我们需要保证一个子树的重儿子只有一个。
- $1$ 节点到 $10$ 节点连成的重链中 $4$ 是 $1$ 的重儿子，$9$ 是 $4$ 的重儿子，$10$ 是 $9$ 的重儿子。
- 节点 $6$ 没有重儿子，单独成链（因为我们要让树全部剖分成链，如果没有重边连成重链，就单独成链），同理，节点 $8$ 也是。

### 性质

我们再次观察上图，不难发现有如下性质：

1. 当前节点 $x$ 每次向下走一条轻边到达轻儿子 $y$，自身的子树大小至少除以 $2$。（否则 $y$ 就应该变为 $x$ 的重儿子）
2. 每条重链的链顶一定是轻儿子。
3. 任意两点的路径可以被不超过 $\log{n}$ 条链覆盖。（可以从性质第一条推导）

### 详细实现

上述定义已经足够我们把一棵树剖分成若干条链了，接下来我们结合代码详细说明一下其实现流程。

我们通常使用两次 dfs 来实现树剖，同时，你还需要记录如下变量：

1. $siz[i]$ 子树大小。
2. $dep[i]$ 深度。
3. $fa[i]$ 记录父节点。
4. $hson[i]$ 记录重儿子。
5. $top[i]$ 记录当前节点所在重链的链顶。
6. $id[i]$ 记录当前节点被拍成序列后，在序列上的新编号。
7. $id\_val[i]$ 表示新序列上第 $i$ 个数的值。

### 第一遍 dfs

维护了前四个变量。

遍历了整棵树求解节点信息，时间复杂度 $O(n)$。

```cpp
//       当前节点  父节点 
void dfs1(int x,int f){
	siz[x]=1;//siz数组先初始化为1，表示目前自身大小为1 
	fa[x]=f;//记录父节点 
	dep[x]=dep[f]+1;//深度比父节点深1 
	for(int i=head[x];i;i=e[i].next){//遍历子节点 
		int y=e[i].to;
		if(y!=f){//注意别遍历回去了 
			dfs1(y,x); 
			siz[x]+=siz[y];//递归回来时，子节点的大小已经被计算完毕，直接加给父节点
			//每次递归判断是否能够更新重儿子节点 
			if(siz[hson[x]]<siz[y] || !hson[x]){
				hson[x]=y;
			}
		}
	}
}
```
### 第二遍 dfs 

用于求解后三个变量。

注意我们求解 $top[i]$ 时，有重儿子要先遍历重儿子，直到找不到重儿子再返回。

这是因为沿着重边一路走下去的节点一定在同一条重链，其链顶是一样的，如果找不到重儿子，则说明该重链结束了，需要重新传入链顶参数进行新重链的求解。

同样，在求解 $id[i]$ 和 $id\_val[i]$ 时也要遵循重儿子先行的顺序，至于为什么这样做对时间复杂度来说是优的，在下面具体讲**题意操作**时会谈到。

遍历了一遍整棵树，时间复杂度 $O(n)$。


```cpp
//     当前节点  链顶 
void dfs2(int x,int t){
	top[x]=t;//记录当前节点所在链的链顶 
	id[x]=++cnt;//记录当前节点在序列中的新编号
	id_val[cnt]=a[x];//当前节点的值直接赋给它对应的编号就好了 
	if(!hson[x]) return ;//如果找不到重儿子就返回 
	else dfs2(hson[x],t);//继续求解当前重链
	//递归后说明重链已经走完，接下来遍历轻儿子 
	for(int i=head[x];i;i=e[i].next){
		int y=e[i].to;
		//这里的判断很容易理解，不能走到父节点还需要满足是轻儿子 
		if(y!=fa[x] && y!=hson[x]){
			dfs2(y,y);//根据性质，轻儿子就是当前新重链的链顶 
		}
	}
}
```

### 小结

现在我们就成功的把一棵树剖分成了若干条链，同时也把树上的点按重儿子先行的规则拍成了序列，放一张图，我们具体观察一下我的树现在具有什么样的性质。

![](https://cdn.luogu.com.cn/upload/image_hosting/n43mx173.png)

现在红色字体是我们根据程序模拟出来的个节点在序列上的新编号，不难发现：同一条重链上的节点，在序列上的编号是连续的，结合之前所讲的**性质 $3$**，你也许隐隐约约对树剖为什么能更快地求解树上的修改与查询有了答案。

如果没有想到也没关系，我们马上根据题意讲解题意操作并给出复杂度证明！

## 题意操作

由于题意上的操作都是形如 $x$ 到 $y$ 的最短路径上的查询与修改，或者以 $x$ 为根的子树里的查询与修改。同时考虑到我们刚才把树剖成了序列，所以对于序列的区间修改与查询，我们使用线段树进行快速维护。

为使文章精简，线段树部分的代码不再展示与讲解，有需求的同学在可以先自学或者在本文最下方完整代码处查看。

同时也为了文章必要的清晰与读者的观感，我们约定：
1. ```change()``` 为线段树的区间加操作。
2. ```query()``` 为线段树的区间查询操作。

### 操作一：树从 $x$ 到 $y$ 结点最短路径上所有节点的值都加上 $z$

在一棵树上 $x$ 到 $y$ 的最短路径为，从 $x$ 到 $x$ 和 $y$ 的 $LCA$（最近共祖先），再到 $y$。又因为两点间的最短路径被若干条重链覆盖着。我们便容易想到，从链顶更深的点开始，每次操作一条链，再不断交替着往上跳出已经修改的链，直到修改到两点已经在同一条链中。

放一张图，大家可以了解一下是怎么不断跳链的。
![](https://cdn.luogu.com.cn/upload/image_hosting/nb5l3rmw.png)

代码实现：


```cpp
void changeto(int x,int y,int z){//x到y都加上z
	while(top[x]!=top[y]){//两个点不在同一条链上 
		if(dep[top[x]]<dep[top[y]]){//每次要让链顶深度更深的跳，否则两点越来越远 
			swap(x,y);
		}
		//修改这条链的链顶到该点在序列上的区间 
		change(1,id[top[x]],id[x],z);
		//跳出这条链 
		x=fa[top[x]];
	}
	//当它们在同一条链上时
	//只剩两点间的区间未修改 
	if(id[x]>id[y]){//保证左区间小于右区间 
		swap(x,y);
	}
	change(1,id[x],id[y],z);
}
```
#### 单次操作一时间复杂度

根据上面讲过的性质 $3$，任意两点的路径可以被不超过 $\log{n}$ 条链覆盖。意思是我们一次操作一不会在超过 $\log{n}$ 条链上调用线段树的 ```change()``` 函数，又由线段树一次区间修改的时间复杂度为 $O(\log{n})$ 级别。

故单次操作一的总时间复杂度为 $O(\log^2{n})$ 。

现在你应该知道我们为什么使用树剖在链上操作会快了，我们继续看接下来的操作。

### 操作二：求树上从 $x$ 到 $y$ 结点最短路径上所有节点的值之和

类比我们的操作一，操作二也很好想了，两点不断跳出链，每次跳前查询一下该点到链顶的区间和，最后加到一起输出。

直接给出代码：

```cpp
long long queryto(int x,int y){
	long long ans=0;
	while(top[x]!=top[y]){//不在同一条链 
		if(dep[top[x]]<dep[top[y]]){//链顶深的先跳 
			swap(x,y);
		}
	 	//统计链顶到该点的区间和 
		ans=(ans+query(1,id[top[x]],id[x]));
		//跳出链 
		x=fa[top[x]]; 
	}
	if(id[x]>id[y]){
		swap(x,y);
	}
	//统计最后一段区间 
	ans=ans+query(1,id[x],id[y]);
	//返回答案即可 
	return ans;
}
```
#### 单次操作二时间复杂度

同样的原因，一共不会超过 $\log{n}$ 条链，并且线段树单次查询的时间复杂度为 $O(\log{n})$ 级别。

故单次操作二的时间复杂度为 $O(\log^2{n})$。

### 操作三：将以 $x$ 为根节点的子树内所有节点值都加上 $z$

重新来看这张图。

![](https://cdn.luogu.com.cn/upload/image_hosting/n43mx173.png)

先给出结论：对一个节点进行 dfs 时，该节点及其子树会形成一段连续的区间，区间的末尾是最后一个被 dfs 的节点。

这一点不难理解，如果当前节点的子树还未被 dfs 完毕，此时是不会回溯出来到别的位置进行 dfs 的。

故这个操作只需我们调用一下 ```change()``` 函数即可:

```cpp
change(1,id[x],id[x]+siz[x]-1,z);
			//从x的编号开始，修改到id[x]+siz[x]-1
			//即最后一个被dfs的节点。 
```

单次时间复杂度 $O(\log{n})$ ，不细讲。

### 操作四：查询以 $x$ 为根节点的子树内所有节点值之和

与操作三同理，直接查询 $x$ 到其子树里最后一个被 dfs 的节点的区间即可。


```cpp
query(1,id[x],id[x]+siz[x]-1)
```

单次时间复杂度 $O(\log{n})$，不细讲。

#### 小结

至此，所有操作已经讲解完毕。您又学会了一种新算法，拜谢%%%。

## 总时间复杂度

单次操作最高的时间复杂度在 $O(\log^2{n})$ 级别，共有 $m$ 次操作。

故总时间复杂度 $O(m\log^2{n})$。

## 完整代码

题目还要求对p取模，但我为了美观，就没在讲解时加，大家写的时候记得加上，同时注意可能存在负数，对负数取模时要先加模数再取模。


```cpp
#include<bits/stdc++.h>
#define ls i<<1
#define rs i<<1|1
using namespace std;
const int N=1e5+5;
struct {
	int next,to;
}e[N<<1];
int tot,head[N];
int dep[N],siz[N],hson[N],fa[N];
int top[N],id[N],cnt;
int n,m,r,p,a[N],id_val[N];
struct node{
	int l,r;
	long long sum;
	long long add;
}t[N<<2];
void add(int x,int y){
	e[++tot].to=y;
	e[tot].next=head[x];
	head[x]=tot;
}
//-----------------------------
//线段树
void pushup(int i){
	t[i].sum=(t[ls].sum+t[rs].sum+p)%p;
}
void build(int i,int l,int r){
	t[i].l=l;
	t[i].r=r;
	if(l==r){
		t[i].sum=id_val[l]%p;
		return ;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	pushup(i);
}
void spread(int i){
	if(t[i].add){
		t[ls].sum=(t[ls].sum+t[i].add*(t[ls].r-t[ls].l+1)+p)%p;
		t[rs].sum=(t[rs].sum+t[i].add*(t[rs].r-t[rs].l+1)+p)%p;
		t[ls].add+=t[i].add;
		t[rs].add+=t[i].add;
		t[ls].add%=p;
		t[rs].add%=p;
		t[i].add=0;
	}
}
void change(int i,int l,int r,int v){ 
	if(l<=t[i].l && r>=t[i].r){
		t[i].sum=(t[i].sum+v*(t[i].r-t[i].l+1)%p+p)%p;
		t[i].add+=v;
		t[i].add%=p;
		return; 
	}
	spread(i);
	int mid=(t[i].l+t[i].r)>>1;
	if(l<=mid){
		change(ls,l,r,v);
	}
	if(r>mid){
		change(rs,l,r,v);
	} 
	pushup(i); 
}
long long query(int i,int l,int r){
	if(t[i].l>r||t[i].r<l){ 
		return 0;
	}
	if(l<=t[i].l&&t[i].r<=r){
		return t[i].sum;
	}
	spread(i);
	return (query(ls,l,r)+query(rs,l,r)+p)%p; 
}
//----------------------
//树剖 
void dfs1(int x,int f){
	siz[x]=1;
	fa[x]=f;
	dep[x]=dep[f]+1;
	for(int i=head[x];i;i=e[i].next){
		int y=e[i].to;
		if(y!=f){
			dfs1(y,x);
			siz[x]+=siz[y];
			if(siz[hson[x]]<siz[y] || !hson[x]){
				hson[x]=y;
			}
		}
	}
}
void dfs2(int x,int t){
	top[x]=t;
	id[x]=++cnt;
	id_val[cnt]=a[x];
	if(!hson[x])return ;
	dfs2(hson[x],t);
	for(int i=head[x];i;i=e[i].next){
		int y=e[i].to;
		if(y!=fa[x] && y!=hson[x]){
			dfs2(y,y);
		}
	}
}
void changeto(int x,int y,int z){
	while(top[x]!=top[y]){ 
		if(dep[top[x]]<dep[top[y]]){
			swap(x,y);
		}
		change(1,id[top[x]],id[x],z);
		x=fa[top[x]];
	}
	if(id[x]>id[y]){
		swap(x,y);
	}
	change(1,id[x],id[y],z);
}
long long queryto(int x,int y){
	long long ans=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]){
			swap(x,y);
		}
		ans=(ans+query(1,id[top[x]],id[x])+p)%p;
		x=fa[top[x]]; 
	}
	if(id[x]>id[y]){
		swap(x,y);
	}
	ans=(ans+query(1,id[x],id[y])+p)%p;
	return ans;
}
//---------
int main(){
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	cin>>n>>m>>r>>p;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n-1;i++){
		int x,y;
		cin>>x>>y;
		add(x,y);
		add(y,x);
	}
	dfs1(r,0); 
	dfs2(r,r);
	build(1,1,n);
	for(int i=1;i<=m;i++){
		int opt,x,y,z;
		cin>>opt;
		if(opt==1){
			cin>>x>>y>>z;
			changeto(x,y,z);
		}
		if(opt==2){
			cin>>x>>y;
			cout<<queryto(x,y)<<'\n';
		}
		if(opt==3){
			cin>>x>>z;
			change(1,id[x],id[x]+siz[x]-1,z);
		}
		if(opt==4){
			cin>>x;
			cout<<query(1,id[x],id[x]+siz[x]-1)<<'\n';
		}
	}
	return 0;
}
```

## 后记

在上述讲解时提到了最近公共祖先，同学们不难发现使用树剖求解最近公共祖先也是一种可行的方式，并且常数小，实际运行速度非常可观，应该可以说比同时间复杂度的算法都优秀（但不绝对）感兴趣的同学可以看我的另一篇题解：[题解：P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/article/9xg0zx9v)。~~（你就会发现我用的图都是旧的）~~

#### 至此所有内容已经讲解完毕，笔者力求语言简洁直观，希望大家看到这篇题解都能有所收获，若有不足之处，欢迎私信批评指出，笔者一定认真倾听。

完结撒花！！！

---

## 作者：CaptainSlow (赞：10)

引用楼下的一句话：

## 脑子都快被剖炸了

虽然是道模板题，但我觉得树链剖分学习起来还是有一定困难的。

这里给大家推荐一个[入门树链剖分的博文](http://blog.sina.com.cn/s/blog\_6974c8b20100zc61.html)，一些详细的概念可以参照里面。

**但是本蒟蒻表示看完还是不太明白**

于是在这里写一写**我学树链剖分时遇到的问题**：

首先，我从离NOIP2017 100多天时开始学树链剖分，然后在距离比赛第九天时终于学完了。。。（懒癌晚期）

**回归正题**

（这里的概念直接借用了刚刚的博文中的名称）

（问答显示展现）

- 1：
- Q：为什么树链剖分扯到线段树上去了？

- A：通过线段树达到查询，维护这些树上点和边的关系。

- 2：
- Q：为什么要使一条重链各边在线段树中连续分布？

- A：这与我们实现我们的树链剖分所用的线段树有关。我们修改时一般对一个子树或一条链操作，而使当前子树的边在线段树中分布在连续区间里，我们就方便通过线段树进行操作。


以上就是我学习遇到的问题所在了，相信大部分同志也会遇到。

附带一些实践的小细节，在我的代码中展现：

**（温馨提示：注意随时取模，因此作为P选手longint即可（看不下去楼下一堆写long long的））**

```cpp
//Luogu P3384

type
     edgetype=record
      point,next:longint;
     end;

var
    edge:array[0..200005]of edgetype;    //edge邻接表存边；开双倍大小（无向图一条边要存两个方向的）
    tree,lazy:array[0..300005]of longint;    //tree是线段树节点的信息；lazy是每个节点的懒标记
    last,siz,fa,dep,son,top,id,a,real:array[0..100000]of longint;    
    {last[v]表示邻接表中以v为起点的边最后一次出现的位置
     siz[v]表示以节点v为根的子树大小，fa[v]表示节点v的父节点，dep[v]表示节点v的深度，son[v]表示节点v的重儿子（没有则是-1），
     top[v]表示节点v所在重链的顶端节点，id[v]表示v在线段树中的位置，real表示线段树的叶子节点对应实际树中点的编号，
     a则是每个节点的初始值}
    es,ps,n,m,i,r,p,x,y,z,ty:longint;

procedure ready;
 begin
       es:=0; ps:=0;    //es记录存入边时边的编号，ps记录在DFS2过程时点在线段树底端的编号
       filldword(last,sizeof(last) div 4,0);
       filldword(lazy,sizeof(lazy) div 4,0);    //last和lazy初始化
 end;

procedure swap(var x1,x2:longint);
 var temp:longint;
 begin
       temp:=x1; x1:=x2; x2:=temp;
 end;

procedure addedge(u,v:longint);    //加边
 begin
       inc(es);
       edge[es].point:=v;
       edge[es].next:=last[u];
       last[u]:=es;
 end;

//Part. Sugment Tree 线段树基本操作

{
function max(n1,n2:longint):longint;
 begin
       if (n1>n2) then exit(n1) else exit(n2);
 end;}

procedure pushup(rt:longint);
 begin
       tree[rt]:=(tree[rt*2]+tree[rt*2+1]) mod p;
 end;

procedure pushdown(rt,l,r:longint);
 var mid,ls,rs,ll,lr:longint;
 begin
       if (lazy[rt]>0) then
       begin
             mid:=(l+r) div 2; ls:=rt*2; rs:=ls+1; ll:=mid-l+1; lr:=r-mid;
             tree[ls]:=(tree[ls]+lazy[rt]*ll mod p) mod p;
             lazy[ls]:=(lazy[ls]+lazy[rt]) mod p;
             tree[rs]:=(tree[rs]+lazy[rt]*lr mod p) mod p;
             lazy[rs]:=(lazy[rs]+lazy[rt]) mod p;
             lazy[rt]:=0;
       end;
 end;

procedure build(rt,l,r:longint);    //普通的建树
 var mid:longint;
 begin
       if (l=r) then
       begin
             tree[rt]:=a[real[l]] mod p;
             exit;
       end;
       mid:=(l+r) div 2;
       build(rt*2,l,mid);
       build(rt*2+1,mid+1,r);
       pushup(rt);
 end;

procedure updata(rt,l,r,ql,qr,w:longint);    //更新
 var mid:longint;
 begin
       if ((ql<=l) and (r<=qr)) then
       begin
             tree[rt]:=(tree[rt]+(r-l+1)*w mod p) mod p;
             lazy[rt]:=(lazy[rt]+w) mod p;
             exit;
       end;
       mid:=(l+r) div 2;
       pushdown(rt,l,r);
       if (ql<=mid) then updata(rt*2,l,mid,ql,qr,w);
       if (qr>mid) then updata(rt*2+1,mid+1,r,ql,qr,w);
       pushup(rt);
 end;

function query(rt,l,r,ql,qr:longint):longint;    //查询
 var mid:longint;
 begin
       if ((ql<=l) and (r<=qr)) then exit(tree[rt]);
       mid:=(l+r) div 2; query:=0;
       pushdown(rt,l,r);
       if (ql<=mid) then query:=(query+query(rt*2,l,mid,ql,qr)) mod p;
       if (qr>mid) then query:=(query+query(rt*2+1,mid+1,r,ql,qr)) mod p;
       pushup(rt);
 end;

//Part. End

procedure dfs1(u,f:longint);    //得到fa,dep,siz,son的值
 var now,v:longint;
 begin
       fa[u]:=f; dep[u]:=dep[f]+1; siz[u]:=1; son[u]:=-1;
       now:=last[u];
       while (now>0) do
       begin
             v:=edge[now].point;
             if (v<>f) then
             begin
                   dfs1(v,u);
                   inc(siz[u],siz[v]);
                   if ((son[u]=-1) or (siz[v]>siz[son[u]])) then son[u]:=v;
             end;
             now:=edge[now].next;
       end;
 end;

procedure dfs2(u,tp:longint);    //将树放入线段树，同时求出top和id
 var now,v:longint;
 begin
       inc(ps); id[u]:=ps; top[u]:=tp; real[ps]:=u;    //ps就是类似es变量的功能
       if (son[u]=-1) then exit;
       dfs2(son[u],tp);
       now:=last[u];
       while (now>0) do
       begin
             v:=edge[now].point;
             if ((v<>son[u]) and (v<>fa[u])) then dfs2(v,v);
             now:=edge[now].next;
       end;
 end;

procedure add(u,v,w:longint);    //在树上u到v的路径上加上w
 var f1,f2:longint;
 begin
       f1:=top[u]; f2:=top[v];
       while (f1<>f2) do    //基本的树链剖分更新操作，不解释（不明白可以看那份博文里的解释）
       begin
             if (dep[f1]<dep[f2]) then
             begin
                   swap(f1,f2);
                   swap(u,v);
             end;
             updata(1,1,n,id[f1],id[u],w);    //更新树上u到顶端f1节点的路径
             u:=fa[f1];
             f1:=top[u];
       end;
       if (dep[u]>dep[v]) then swap(u,v);
       updata(1,1,n,id[u],id[v],w);    //同一链上更新u到v的路径
 end;

function getsum(u,v:longint):longint;    //树上求和
 var ans,f1,f2:longint;
 begin
       ans:=0;
       f1:=top[u]; f2:=top[v];
       while (f1<>f2) do    //类似add过程的操作
       begin
             if (dep[f1]<dep[f2]) then
             begin
                   swap(f1,f2);
                   swap(u,v);
             end;
             ans:=(ans+query(1,1,n,id[f1],id[u])) mod p;
             u:=fa[f1];
             f1:=top[u];
       end;
       if (dep[u]>dep[v]) then swap(u,v);
       ans:=(ans+query(1,1,n,id[u],id[v])) mod p;
       exit(ans);
 end;

begin
      ready;

      read(n,m,r,p);
      for i:=1 to n do read(a[i]);
      for i:=1 to n-1 do
      begin
            read(x,y);
            addedge(x,y);
            addedge(y,x);
      end;

      dep[0]:=0;
      dfs1(r,0);
      dfs2(r,r);
      build(1,1,n);

      for i:=1 to m do
      begin
            read(ty);
            case ty of
             1:begin    //1操作
                     read(x,y,z);
                     add(x,y,z);
               end;
             2:begin    //2操作
                     read(x,y);
                     writeln(getsum(x,y));
               end;
             3:begin    //3操作
                     read(x,z);
                     updata(1,1,n,id[x],id[x]+siz[x]-1,z);    
                     //因为是子树上操作所以直接用updata即可，id[x]~id[x]+siz[x]-1即以x为根节点的子树在线段树中的区间
               end;
             4:begin    //4操作
                     read(x);
                     writeln(query(1,1,n,id[x],id[x]+siz[x]-1));    //因为是子树上查询所以直接用query即可
               end;
            end;
      end;
end.
```
（有问题的童鞋可以私信我~）


---

## 作者：yhy2024 (赞：5)

## 1、概念

重儿子：一个节点的儿子中，子树大小最大的儿子。

轻儿子：不是重儿子的儿子。

重边：一个节点连向她重儿子的边。

重链：一条全是重边的链。显然最上面的节点是轻儿子。

下图就是一棵剖好的树：

![](https://cdn.luogu.com.cn/upload/image_hosting/f113x2hd.png)

摘自 oi-wiki。

## 2、性质

1、一个节点会且只会被包含在一条重链中，轻儿子链顶，重儿子在链里。

2、设当前子树大小为 $n$，那么一个轻儿子的子树大小 $\le \frac n 2$，显然如果大于 $\frac n 2$ 那么没有一个儿子比她大，她就是重儿子了。

3、一个树的重链数量是 $\log n$ 级别的。由 2 可知每经过一个轻儿子子树大小就会除以 $2$。

## 3、树剖实现 LCA

记 $son_x$ 为 $x$ 的重儿子，$size_x$ 为 $x$ 的子树大小，$top_x$ 为 $x$ 所在的重链的链顶，$fa_x$ 为 $x$ 的父亲，$d_x$ 为 $x$ 的深度，即到根的距离。

预处理两个 dfs，第一个求子树大小和重儿子和父亲和深度，第二个求 $top$。

```cpp
inline void dfs1(int x){
	siz[x]=1;
	for(auto i:v[x]){
		if(i!=fa[x]){
			d[i]=d[x]+1,fa[i]=x;
			dfs1(i);
			siz[x]+=siz[i];
			if(siz[i]>siz[son[x]]) son[x]=i;//找重儿子
		}
	}
}
inline void dfs2(int x){
	if(!son[x])return;
	top[son[x]]=top[x],dfs2(son[x]);//先遍历重儿子
	for(auto i:v[x]){
		if(!top[i]) top[i]=i,dfs2(i);
	}
}
```

求 LCA 时，如果不在同一条重链上，先跳深度大的链，在同一条重链上，深度小的就是 LCA。时间复杂度 $O(\log n)$，由性质 3 可得。

```cpp
inline int LCA(int x,int y){
	int fx=top[x],fy=top[y];
	while(fx!=fy){
		if(d[fx]<d[fy]) swap(fx,fy),swap(x,y);//跳深度大的
		x=fa[fx],fx=top[x];//到下一条重链上
	}
	return d[x]<d[y]?x:y;
}
```

## 4、本题实现

记 $seg_x$ 为 $x$ 在数列上的位置，$rev_x$ 为数列上 $x$ 表示的节点，对于 $x$ 有 $rev_{seg_x}=x$。第二次 dfs 时处理出来。

遍历时先走重儿子，因为这样重链的上的点可以看作序列上一段区间。

例如这棵树：

![](https://cdn.luogu.com.cn/upload/image_hosting/tu0q28q3.png)

红链可以看作区间 $[1,5]$，蓝链可看作区间 $[8,10]$。$8$ 是区间 $[6,6]$，$10$ 是区间 $[7,7]$。

```cpp
inline void dfs1(int x){
	siz[x]=1;
	for(auto i:v[x]){
		if(i!=fa[x]){
			d[i]=d[x]+1,fa[i]=x;
			dfs1(i);
			siz[x]+=siz[i];
			if(siz[i]>siz[son[x]]) son[x]=i;
		}
	}
}
inline void dfs2(int x){
	if(!son[x])return;
	seg[son[x]]=++seg[0],rev[seg[0]]=son[x];//使同一条重链上区间连续
	top[son[x]]=top[x],dfs2(son[x]);
	for(auto i:v[x]){
		if(!top[i]){
			seg[i]=++seg[0],rev[seg[0]]=i;
			top[i]=i,dfs2(i);
		}
	}
}
```

不难发现找两点的路径其实就是找 LCA，跳重链时修改算共献即可，最后在同一条链上时也有贡献。

初始序列 $[1,1,4,5,1,4,1,1,4,5]$。

映射到树对应的序列 $[1,1,5,1,4,1,5,4,1,4]$。

![](https://cdn.luogu.com.cn/upload/image_hosting/tu0q28q3.png)

当对 $6$ 到 $9$ 的路径加 $1$ 时，先跳蓝链，序列变为 $[1,1,5,1,4,1,5,5,2,5]$，现在她们都在红链上，再修改红链，序列变为 $[2,2,6,2,5,1,5,5,2,5]$。


```cpp
inline int QSUM(int x,int y){
	int fx=top[x],fy=top[y],res=0;
	while(fx!=fy){
		if(d[fx]<d[fy]) swap(x,y),swap(fx,fy);
		res+=query(1,1,seg[0],seg[fx],seg[x]);
		x=fa[fx],fx=top[x]; 
	}
	if(d[x]>d[y]) swap(x,y);
	res+=query(1,1,seg[0],seg[x],seg[y]);
	return res; 
} 
inline void Modify(int x,int y,int z){
	int fx=top[x],fy=top[y];
	while(fx!=fy){
		if(d[fx]<d[fy]) swap(x,y),swap(fx,fy);
		modify(1,1,seg[0],seg[fx],seg[x],z);
		x=fa[fx],fx=top[x]; 
	}
	if(d[x]>d[y]) swap(x,y);
	modify(1,1,seg[0],seg[x],seg[y],z);//同一条重链时
}
```

修改子树和询问子树，注意到 $seg_x$ 是 $x$ 的进栈时间，出栈时一共经过了 $size_x-1$ 个点，所以出栈时间是 $seg_x+size_x-1$，她的子树在序列上就是区间 $[seg_x,seg_x+size-1]$。因为线段树是 $O(\log n)$ 的所以算上树剖是 $O(n \log^2 n)$。
 
```cpp
#include<bits/stdc++.h>
#define N 100005
#define rd read()
#define int long long
using namespace std;
int m,n,rt,md,x,y,z,op,a[N];
int siz[N],d[N],son[N],seg[N],rev[N],fa[N],top[N];
int tag[N<<2],tr[N<<2];
vector<int>v[N];
inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9')
		x=x*10+ch-'0',ch=getchar();
	return x*f;
}
inline void dfs1(int x){
	siz[x]=1;
	for(auto i:v[x]){
		if(i!=fa[x]){
			d[i]=d[x]+1,fa[i]=x;
			dfs1(i);
			siz[x]+=siz[i];
			if(siz[i]>siz[son[x]]) son[x]=i;
		}
	}
}
inline void dfs2(int x){
	if(!son[x])return;
	seg[son[x]]=++seg[0],rev[seg[0]]=son[x];
	top[son[x]]=top[x],dfs2(son[x]);
	for(auto i:v[x]){
		if(!top[i]){
			seg[i]=++seg[0],rev[seg[0]]=i;
			top[i]=i,dfs2(i);
		}
	}
}
inline void add(int k,int l,int r,int v){
	tr[k]=(tr[k]+(r-l+1)*v)%md;
	tag[k]=(tag[k]+v)%md;
}
inline void pushdown(int k,int l,int r){
	if(tag[k]){
		int mid=l+r>>1;
		add(k<<1,l,mid,tag[k]);
		add(k<<1|1,mid+1,r,tag[k]);
		tag[k]=0;
	}
}
inline void pushup(int k){tr[k]=tr[k<<1]+tr[k<<1|1];}
inline void build(int k,int l,int r){
	if(l==r){tr[k]=a[rev[l]];return;}
	int mid=l+r>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	pushup(k);
}
inline void modify(int k,int l,int r,int x,int y,int v){
	if(x<=l&&r<=y){add(k,l,r,v);return;}
	int mid=l+r>>1;
	pushdown(k,l,r);
	if(x<=mid) modify(k<<1,l,mid,x,y,v);	
	if(y>mid) modify(k<<1|1,mid+1,r,x,y,v);
	pushup(k);
}//正常线段树
inline int query(int k,int l,int r,int x,int y){
	if(x<=l&&r<=y) return tr[k];
	int mid=l+r>>1,res=0;
	pushdown(k,l,r);
	if(x<=mid) res+=query(k<<1,l,mid,x,y);
	if(y>mid) res+=query(k<<1|1,mid+1,r,x,y);
	return res; 
}
inline int QSUM(int x,int y){
	int fx=top[x],fy=top[y],ans=0;
	while(fx!=fy){
		if(d[fx]<d[fy]) swap(x,y),swap(fx,fy);
		ans+=query(1,1,seg[0],seg[fx],seg[x]);
		x=fa[fx],fx=top[x]; 
	}
	if(d[x]>d[y]) swap(x,y);
	ans+=query(1,1,seg[0],seg[x],seg[y]);
	return ans; 
} 
inline void Modify(int x,int y,int z){
	int fx=top[x],fy=top[y];
	while(fx!=fy){
		if(d[fx]<d[fy]) swap(x,y),swap(fx,fy);
		modify(1,1,seg[0],seg[fx],seg[x],z);
		x=fa[fx],fx=top[x]; 
	}
	if(d[x]>d[y]) swap(x,y);
	modify(1,1,seg[0],seg[x],seg[y],z); 
} 
signed main(){
	cout.tie(0);
	n=rd,m=rd,rt=rd,md=rd;
	for(int i=1;i<=n;i++) a[i]=rd;
	for(int i=1;i<n;i++){
		x=rd,y=rd;
		v[x].push_back(y);
		v[y].push_back(x);
	}
	d[rt]=seg[rt]=seg[0]=1;
	top[rt]=rev[1]=rt;
	dfs1(rt);dfs2(rt);build(1,1,seg[0]);
	for(int i=1;i<=m;i++){
		op=rd,x=rd;
		if(op==1) y=rd,Modify(x,y,rd);
		if(op==2) cout<<QSUM(x,rd)%md<<'\n';
		if(op==3) modify(1,1,seg[0],seg[x],seg[x]+siz[x]-1,rd);
		if(op==4) cout<<query(1,1,seg[0],seg[x],seg[x]+siz[x]-1)%md<<'\n';
	}
	return 0;
} 
```

---

## 作者：Zskioaert1106 (赞：4)

~~太好了是有一堆水蓝的树链剖分~~

部分采自本人的[另一篇专栏](https://www.luogu.com.cn/article/5fxdcss7)。

### 树链剖分

树链剖分是什么？

你可以理解为就是把一棵树剖开，分割成许多链，它将树反映为序列，使得很多处理线性结构的工具能在树上应用，如线段树。

良好的剖分方法能使这些工具加个 $\log$ 就用在树上，比如**重链剖分**。

### 重链剖分

#### 算法介绍

可以理解为一种 dfs 方法得到的 dfs 序（再剖分成一些向上的链），具体地，对于每个结点，定义它所有孩子里子树大小最大的为它的“重孩子”（有多个取一个，其它的为轻孩子）。dfs 时总遵循第一个搜重孩子的原则。

如图所示，这是对一棵树进行的重链剖分，其中连向重孩子的边（黑边）组成的链被称为重链，而连向轻孩子的边（红边）被称为轻边。

![重剖示意图](https://cdn.luogu.com.cn/upload/image_hosting/vjuruj3z.png)

以最上面的结点为根，则图中序号是一种合法的重剖序。不难发现，每个重链上的所有结点在生成的序列中仍然是挨在一起的。这意味着什么？我们可以对它们进行一些整体操作！

更重要一点的是，可以证明在任意一个结点向根的路径上，重链和轻边条数，均不超过 $\log n$。

#### 正确性证明

考虑一颗满二叉树，此时轻孩子的子树大小和重孩子的是一样的，而这时树高是 $\log n$，且有叶子到根的路径上全是轻边。而当树改变时，由于重剖会优先选择子树大的，所以轻边的数量只会更少。

然后还有一条结论，就是结点到根的路径上，重链的条数不会超过轻边条数加 $1$。试想当每两条重链有一个轻边隔开，如果少一条轻边则就会有两条重链连到一起。

我们定义 $top_x$ 代表结点 $x$ 所在重链的链头（不在重链上则为 $x$，特别地，根结点的链头初始要设为本身），每次都跳到链头，跑的次数不就可以 $n \rightarrow \log$ 了吗？

通常我们对树进行重链剖分可以用两遍 dfs。第一遍可以求出每个结点的深度、子树大小以及重孩子，第二遍则可以先搜重孩子形成重链，记录每个点的链头。第二遍搜索的 dfs 序便是重剖序。

#### 代码实现

```cpp
vector<int>a;
void dfs1(int x){
	deep[x]=deep[fa[x]]+1;
	siz[x]=1;
	for(int u:e[x]){
		if(u==fa[x])continue;
		fa[u]=x;
		dfs1(u);
		siz[x]+=siz[u];
		if(siz[u]>siz[wc[x]])wc[x]=u;//重孩子
	}
}
void dfs2(int x){
	a.push_back(x);//记录重剖序
	if(!wc[x])return;//说明没有子结点了
	top[wc[x]]=top[x];
	dfs2(wc[x]);
	for(int u:e[x]){
		if(u==fa[x]||u==wc[x])continue;
		top[u]=u;
		dfs2(u);
	}
}
dfs1(s);
top[s]=s;
top2(s);
```

#### 经典应用

重链剖分可以用来求 LCA，这种方法比树上倍增的常数要小。

根据上面的方法，求 $\operatorname{LCA}(x,y)$ 经过的路径（即从 $x$ 到 $y$）可以转化为从 $x$ 到 $\operatorname{LCA}(x,y)$ 和从 $y$ 到 $\operatorname{LCA}(x,y)$ 两条路径。所以重剖求 LCA 的时间复杂度也是 $O(\log n)$ 的。而且这只是上界，实际中随机出现的树很难顶到 $\log$ 的级别。

重链剖分求 LCA 的具体步骤如下：

1. 如果 $top_x=top_y$，则 $x$ 和 $y$ 在同一重链上。$\operatorname{LCA}(x,y)$ 即为深度较小者。

2. 否则选择 $x$ 和 $y$ 中链头深度较大的（此处以 $x$ 为例），使 $x \leftarrow f\!a_{top_x}$；

3. 重复操作 1、2。

另一个常用的操作是重链剖分配合线段树，也就是本题的内容。

### 例题讲解

题目传送门：[P3384 【模板】重链剖分/树链剖分](https://www.luogu.com.cn/problem/P3384)

本题要我们实现四种操作，但是实际上只有前两种依赖重链剖分，后两种任意的 dfs 序皆可行。

#### 初始化

我们先通过两遍 dfs 进行剖分，然后建立基于树剖序的线段树：

```cpp
#include<iostream>
#include<vector>
#define p_b push_back
using namespace std;
const int N=1e5+1;
int n,m,r,a[N],ts[N],L[N<<2],R[N<<2];
long long p,s[N<<2],lzy[N<<2];
int fa[N],deep[N],siz[N],wc[N],top[N];
vector<int>e[N],tl;
void dfs1(int x){
    deep[x]=deep[fa[x]]+1;
    siz[x]=1;
    for(int u:e[x]){
        if(u==fa[x])continue;
        fa[u]=x;
        dfs1(u);
        siz[x]+=siz[u];
        if(siz[u]>siz[wc[x]])wc[x]=u;
    }
}
void dfs2(int x){
    ts[x]=tl.size();
    tl.p_b(x);
    if(wc[x]){
        top[wc[x]]=top[x];
        dfs2(wc[x]);
        for(int u:e[x]){
            if(u==fa[x]||u==wc[x])continue;
            top[u]=u;
            dfs2(u);
        }
    }
}
```

建立线段树时，在最底层赋值出一定要将 dfs 序转换成原来的编号。

```cpp
void pushup(int u){
    s[u]=(s[u<<1]+s[u<<1|1])%p;
}
void build(int u,int l,int r){
    L[u]=l,R[u]=r;
    if(l==r)s[u]=a[tl[l]];
    else{
        int mid=(l+r)>>1;
        build(u<<1,l,mid);
        build(u<<1|1,mid+1,r);
        pushup(u);
    }
}
void maketag(int u,long long x){
    (lzy[u]+=x)%=p;
    (s[u]+=x*(R[u]-L[u]+1))%=p;
}
void pushdown(int u){
    if(lzy[u]){
        maketag(u<<1,lzy[u]);
        maketag(u<<1|1,lzy[u]);
        lzy[u]=0;
    }
}
void update(int u,int l,int r,long long x){
    if(l<=L[u]&&R[u]<=r)maketag(u,x);
    else if(L[u]<=r&&l<=R[u]){
        pushdown(u);
        update(u<<1,l,r,x);
        update(u<<1|1,l,r,x);
        pushup(u);
    }
}
long long query(int u,int l,int r){
    if(l<=L[u]&&R[u]<=r)return s[u]%p;
    if(L[u]>r||R[u]<l)return 0;
    pushdown(u);
    return (query(u<<1,l,r)+query(u<<1|1,l,r))%p;
}
```

#### 操作 1

要求给从 $x$ 到 $y$ 的每个结点都增加 $z$，正好是我们上面讲过的 LCA 经过的两条路径。

采用同样的步骤，每经过一条链就用线段树整体增加。最后增加 $top$ 相同的那一段。

```cpp
int x,y,z;
cin>>x>>y>>z;
z%=p;//先 % 为敬（防止溢出）
while(top[x]!=top[y]){
    if(deep[top[x]]<deep[top[y]])swap(x,y);
    update(1,ts[top[x]],ts[x],z);
    x=fa[top[x]];
}
if(deep[x]>deep[y])swap(x,y);
update(1,ts[x],ts[y],z);
```

#### 操作 2

从修改改成了求和。同样使用线段树如法炮制，每经过一条链就让答案加上即可。

```cpp
int x,y;
cin>>x>>y;
long long ans=0;
while(top[x]!=top[y]){
    if(deep[top[x]]<deep[top[y]])swap(x,y);
    (ans+=query(1,ts[top[x]],ts[x]))%=p;
    x=fa[top[x]];
}
if(deep[x]>deep[y])swap(x,y);
cout<<(ans+query(1,ts[x],ts[y]))%p<<'\n';
```

#### 操作 3

这个操作就跟重链无关了。不难发现，dfs 的定义使得在一颗子树内的所有结点 dfs 序的编号总是连续的。因此我们可以直接用线段树增加：区间左界为子树根的 dfs 序编号，右界为左界加上子树大小。

```cpp
int x,z;
cin>>x>>z;
z%=p;
update(1,ts[x],ts[x]+siz[x]-1,z);
```

#### 操作 4

跟操作 3 方法一样。

```cpp
int x;
cin>>x;
cout<<query(1,ts[x],ts[x]+siz[x]-1)%p<<'\n';
```

这样，我们就做完这道蓝色的模板了。~~然后你就会发现还有一堆蓝色的板子等你去刷~~

#### 完整代码

```cpp
#include<iostream>
#include<vector>
#define p_b push_back
using namespace std;
const int N=1e5+1;
int n,m,r,a[N],ts[N],L[N<<2],R[N<<2];
long long p,s[N<<2],lzy[N<<2];
int fa[N],deep[N],siz[N],wc[N],top[N];
vector<int>e[N],tl;
void dfs1(int x){
    deep[x]=deep[fa[x]]+1;
    siz[x]=1;
    for(int u:e[x]){
        if(u==fa[x])continue;
        fa[u]=x;
        dfs1(u);
        siz[x]+=siz[u];
        if(siz[u]>siz[wc[x]])wc[x]=u;
    }
}
void dfs2(int x){
    ts[x]=tl.size();
    tl.p_b(x);
    if(wc[x]){
        top[wc[x]]=top[x];
        dfs2(wc[x]);
        for(int u:e[x]){
            if(u==fa[x]||u==wc[x])continue;
            top[u]=u;
            dfs2(u);
        }
    }
}
void pushup(int u){
    s[u]=(s[u<<1]+s[u<<1|1])%p;
}
void build(int u,int l,int r){
    L[u]=l,R[u]=r;
    if(l==r)s[u]=a[tl[l]];
    else{
        int mid=(l+r)>>1;
        build(u<<1,l,mid);
        build(u<<1|1,mid+1,r);
        pushup(u);
    }
}
void maketag(int u,long long x){
    (lzy[u]+=x)%=p;
    (s[u]+=x*(R[u]-L[u]+1))%=p;
}
void pushdown(int u){
    if(lzy[u]){
        maketag(u<<1,lzy[u]);
        maketag(u<<1|1,lzy[u]);
        lzy[u]=0;
    }
}
void update(int u,int l,int r,long long x){
    if(l<=L[u]&&R[u]<=r)maketag(u,x);
    else if(L[u]<=r&&l<=R[u]){
        pushdown(u);
        update(u<<1,l,r,x);
        update(u<<1|1,l,r,x);
        pushup(u);
    }
}
long long query(int u,int l,int r){
    if(l<=L[u]&&R[u]<=r)return s[u]%p;
    if(L[u]>r||R[u]<l)return 0;
    pushdown(u);
    return (query(u<<1,l,r)+query(u<<1|1,l,r))%p;
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m>>r>>p;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1,u,v;i<n;i++){
        cin>>u>>v;
        e[u].p_b(v),e[v].p_b(u);
    }
    dfs1(r);
    tl.p_b(0);
    top[r]=r;
    dfs2(r);
    build(1,1,n);
    for(short opt;m--;){
        cin>>opt;
        if(opt==1){
            int x,y,z;
            cin>>x>>y>>z;
            z%=p;
            while(top[x]!=top[y]){
                if(deep[top[x]]<deep[top[y]])swap(x,y);
                update(1,ts[top[x]],ts[x],z);
                x=fa[top[x]];
            }
            if(deep[x]>deep[y])swap(x,y);
            update(1,ts[x],ts[y],z);
        }
        else if(opt==2){
            int x,y;
            cin>>x>>y;
            long long ans=0;
            while(top[x]!=top[y]){
                if(deep[top[x]]<deep[top[y]])swap(x,y);
                (ans+=query(1,ts[top[x]],ts[x]))%=p;
                x=fa[top[x]];
            }
            if(deep[x]>deep[y])swap(x,y);
            cout<<(ans+query(1,ts[x],ts[y]))%p<<'\n';
        }
        else if(opt==3){
            int x,z;
            cin>>x>>z;
            z%=p;
            update(1,ts[x],ts[x]+siz[x]-1,z);
        }
        else if(opt==4){
            int x;
            cin>>x;
            cout<<query(1,ts[x],ts[x]+siz[x]-1)%p<<'\n';
        }
    }
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/203587560)。

### 巩固习题

~~其实就是水题啦~~

- [P3833 [SHOI2012] 魔法树](https://www.luogu.com.cn/problem/P3833)

- [P3178 [HAOI2015] 树上操作](https://www.luogu.com.cn/problem/P3178)

- [P2590 [ZJOI2008] 树的统计](https://www.luogu.com.cn/problem/P2590)

- [P3038 [USACO11DEC] Grass Planting G](https://www.luogu.com.cn/problem/P3038)

这题求的是边权，边转点之后其实是一样的。

- [P4116 Qtree3](https://www.luogu.com.cn/problem/P4116)

- [P2146 [NOI2015] 软件包管理器](https://www.luogu.com.cn/problem/P2146)

- [P1505 [国家集训队] 旅游](https://www.luogu.com.cn/problem/P1505)

***

- [P3703 [SDOI2017] 树点涂色](https://www.luogu.com.cn/problem/P3703)

- [P4211 [LNOI2014] LCA](https://www.luogu.com.cn/problem/P4211)

- [P3401 洛谷树](https://www.luogu.com.cn/problem/P3401)

---

## 作者：lcfollower (赞：4)

写在前面
---

本文摘自[这里](https://www.luogu.com.cn/article/sfv0fvgi)，有删改（当然是我自己写的）。

树链剖分大部分情况下就是指重链剖分。

前置知识
---

你需要学会熟练地使用：

- 树的 dfs 序。
- 线段树。
- LCA。

LCA 为什么需要熟练地使用？

LCA 即查找 $u$，$v$ 的最近公共祖先，对重链剖分的跳重链的过程可以更好地理解。

引入
---
【模板】重链剖分/树链剖分
---

这里通过[板子](https://www.luogu.com.cn/problem/P3384)引入。

> 给定一棵包含 $n$ 个结点的树（根节点为 $r$），每个节点有一个点权，以及 $Q$ 次询问，询问内容如下：
>
> - `1 x y z`，将树 $x$ 到 $y$ 的简单路径上所有节点的值都加上 $z$。
>
> - `2 x y`，求树从 $x$ 到 $y$ 的简单路径上所有节点的值之和。
>
> - `3 x z`，将以 $x$ 为根节点的子树内所有节点值都加上 $z$。
>
> - `4 x`，求以 $x$ 为根节点的子树内所有节点值之和。
>
> 对于操作 $2,4$ 的答案需要对给定的 $p$ 取模。
> 
> $1\le n \le {10}^5$，$1\le Q \le {10}^5$，$1\le r\le N$，$1\le p \le 2^{30}$。所有输入的数均在 `int` 范围内。

考虑只有操作 $2$，那么就如『例题（前置知识）』（可以见我开头放的那个文章）里一样直接 dfs 预处理和 LCA 查询，时间复杂度为 $\mathcal O(n + Q\log n)$。

那如果带上操作 $4$ 呢？那么 LCA 就无能为力了。

这个时候我们要引入本文的重点：重链剖分！

### 定义：

当然哈图论总是有新的名称。

- 重儿子：根节点的儿子中点权最大的儿子。

- 重边：根节点连向重儿子的边。

- 重链：若干条重边连接起来的东西，注意单个剩余节点也算重链。

- 轻儿子：除了重儿子以外的儿子。

- 轻边：所有连向儿子的边除了重边的边。

### 静态问题

套用一下 <https://oi-wiki.org> 的图（略带修改）：

![](https://cdn.luogu.com.cn/upload/image_hosting/bqr3gmh2.png)

可以发现：

- 重链的开头一定是轻儿子（重儿子都被加入重链了，一条重链总有限制长度，限制要求为轻儿子开头）。

- dfs 序并非传统的搜索，而是重儿子优先，轻儿子随便顺序都可以。如果儿子的点权有多个最大值，那么任选一个即可。

- 同一个重链内的 dfs 序是**连续的**（原因动一下脑就可以想到）。

- 同一棵子树内的 dfs 序也是**连续的**（类似于 dfs 序）。

然后我们将如上树的点权按照 **dfs 序**折射成一个数组 $w$：

$$w:\boxed{2}\boxed{6}\boxed{4}\boxed{5}\boxed{10}\boxed{1}\boxed{1}\boxed{3}\boxed{3}\boxed{4}\boxed{1}\boxed{5}\boxed{9}\boxed{3}\boxed{8}\boxed{3}\boxed{5}\boxed{514}\boxed{114}$$

回到操作 $2$，我们发现，节点 $x$，$y$ 之间的简单路径实际上是由**多条重链组合**加上**一段同一条重链内的路径**，于是我们可以使用跳重链的方式累加答案，可以用**前缀和**维护，具体内容到时候展开。

然后是操作 $4$，由于子树内的下标在 $w$ 中是连续的，所以可以实现预处理子树大小，然后直接**前缀和**计算即可。

时间复杂度下面讲。

### 动态问题

~~讲了这么点，树还是静态的。~~

不过没关系，因为我们离正解只有一步之遥。

对于修改操作，我们可以像查询操作一样，$1$ 也跳重链，$3$ 通过子树大小计算后修改。

这样我们支持区间加和与区间查询的数据结构，我们能够想到的是：**线段树**！

BIT 常数小，但是范围局限，区间最值的实现过程也不好写，所以这里我们选择幸运儿线段树。

### 时空复杂度分析：

首先是 dfs，时间复杂度为 $\mathcal O(n)$，空间复杂度为 $\mathcal O(n)$。

其次查询和修改，时间复杂度为 $O(\log^2 n)^{\textcircled{2}}$，空间复杂度为 $\mathcal O(n)$。

$\textcircled{2}$：首先线段树查询和修改是 $\mathcal O(\log n)$ 的；其次跳重链的时候总是跳到轻儿子上面，于是乎一条路径上最多有 $\log n$ 个轻儿子，也就是最多会跳 $\mathcal O(\log n)$ 条重链，总时间复杂度为 $\mathcal O(\log^2 n)$。

因此，对于操作 $2,4$，时间复杂度为 $\mathcal O(n + Q\log n)$（可以用前缀和 $\mathcal O(1)$ 解决查询）；对于**所有**操作，时间复杂度为 $\mathcal O(n + Q\log^2 n)$，足以通过本题。

### 一些小问题

我曾经思考过一个问题，普通的 dfs 生成的序列能不能维护？

对于子树内的下标无疑是连续的，但是对于两个节点之间的路径我们无从下手。

所以这就是重链剖分产生的意义。（~~猜测~~

综上所述，如果只是修改与查询子树内的答案，你当然直接 dfs 序也可以，不用重链剖分（~~偷懒~~。

### 代码实现

似乎一段一段放代码比一下子放代码更容易理解，所以我还是一段一段放代码。（~~大雾~~

#### dfs 部分

先罗列一下要生成啥：

- $i$ 所属重链中最顶端的节点 $top_i$（不记录路径），因为重链中的节点有用的只有头顶节点。

- 子树 $i$ 的大小 $sz_i$。

- $w$ 数组。

- dfs 遍历顺序（$w$ 数组中的下标）$id_i$。

- 节点的父亲 $fa_i$：跳重链需要用，即 $fa_{top_u}$。

- $i$ 的重儿子 $wson_i$，辅助完成 $top$。

- 节点深度 $deep_i$（下面会讲到）。

观察到，$wson$ 需要先完成才能完成 $top$；实现 $top$ 的 dfs 是『重度优先搜索』，而 $id$ 由于是『重度优先搜索』下的编号所以和 $top$ 放在一起。$w$ 也需要在『重度优先搜索』下完成所以和它们放在一起（dfs2），剩余的都放在 dfs1。

```cpp
inline void dfs1(int u, int fath) {//处理 deep ,sz ,fa & sz。
//u 是当前节点，fath 是父亲。
	deep[u] = deep[fath] + 1 ,sz[u] = 1 ,fa[u] = fath;//很好理解。

	for (int v : edge[u]) {
		if (v == fath) continue;
		dfs1(v, u);
		sz[u] += sz[v];//遍历树的模板。
		if (sz[wson[u]] < sz[v]) wson[u] = v;//更新重儿子。
	}
}
inline void dfs2(int u, int t) { //处理 top ,id，w。
//u，t 分别表示当前节点和 u 所在重链的头顶 t。

	top[u] = t ,id[u] = ++ cnt ,w[cnt] = a[u];
	
//如果你连重儿子都没有你就是叶节点，更新过了就别继续了，不然这样 0 节点会多占一个 id 和 w 的空间，top 倒是没啥关系。
  if (!wson[u]) return;

	dfs2(wson[u], t);//『重度优先搜索』。

	for (int v : edge[u]) {
		if (v == fa[u] || v == wson[u]) continue;//你都是重儿子了都遍历过了就别占用空间了。

		dfs2(v, v);//轻儿子开头重链啊，顶端就是自己哈。
	}
/*
PS：这里占用空间的解释：
第一会导致少计算几个节点；
第二会导致重复计算，并且少计算几个节点。
因为 sz 是不会更新的。
所以并不只是单纯的『占用空间』。
*/

}
```


####  线段树部分

上模板！

```cpp
/*
PS：作者默认你会熟练应用线段树，这里不解释。
区间求和和查询都是最基础的板子。
*/
struct segment_tree {
	int l, r, add, sum;
} tr[N << 2];

inline void pushup(int u) {
	tr[u].sum = tr[lc].sum + tr[rc].sum;
}
inline void pushdown(int u) {
	if (tr[u].add) {
		tr[lc].sum += tr[u].add * (tr[lc].r - tr[lc].l + 1);
		tr[lc].add += tr[u].add;
		tr[rc].sum += tr[u].add * (tr[rc].r - tr[rc].l + 1);
		tr[rc].add += tr[u].add;
		tr[u].add = 0;
	}
}
inline void build(int u, int l, int r) {
	tr[u] = {l, r, 0, w[r]};
	if (l == r) return;
	int mid = ((l + r) >> 1);
	build(lc, l, mid);
	build(rc, mid + 1, r);
	pushup(u);
}
inline void update(int u, int L, int R, int k) {
	int l = tr[u].l, r = tr[u].r;
	if (l >= L && r <= R) {
		tr[u].add += k;
		tr[u].sum += k * (r - l + 1);
		return;
	}
	pushdown(u);
	int mid = ((l + r) >> 1);
	if (L <= mid) update(lc, L, R, k);
	if (mid < R) update(rc, L, R, k);
	pushup(u);
}
inline void update_tree(int u, int k) {
	update(1, id[u], id[u] + sz[u] - 1, k);
}
inline int query(int u, int L, int R) {
	int l = tr[u].l, r = tr[u].r;
	if (l >= L && r <= R) return tr[u].sum;
	pushdown(u);
	int mid = ((l + r) >> 1);
	int res = 0;
	if (L <= mid) res += query(lc, L, R);
	if (mid < R) res += query(rc, L, R);
	return res;
}
inline int query_tree(int u) {
	return query(1, id[u], id[u] + sz[u] - 1);
}
```

#### 跳重链部分

啊哈前面抛了一个问题在这（~~你们应该都忘掉了~~）：$deep$ 有啥用？

第一处：我们一致让 $top_u$ 的深度大于等于 $top_v$ 的深度，不然一直跳 $u$ 会导致这样的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/qbjv56cu.png)

第二处：最后的同一个重链内的修改/查询，由于在**同一条重链中**，所以 $deep$ 更深的那个 $id$ 更大，我们就把这个更大的 $id$ 作为区间右端点。

```cpp
inline void update_path(int u, int v, int k) {
	while (top[u] != top[v]) {//不在同一条重链。
		if (deep[top[u]] < deep[top[v]]) swap(u, v);//原因见上。
		update(1, id[top[u]], id[u], k);//修改。
		u = fa[top[u]];//跳重链。
	}
	if (deep[u] > deep[v]) swap(u, v);//原因见上。
	update(1, id[u], id[v], k);//不要忘了 awa。
}

inline int query_path(int u, int v) {
//和 update_path 一模一样。
	int res = 0;
	while (top[u] != top[v]) {
		if (deep[top[u]] < deep[top[v]]) swap(u, v);
		res += query(1, id[top[u]], id[u]);
		u = fa[top[u]];
	}
	if (deep[u] > deep[v]) swap(u, v);
	res += query(1, id[u], id[v]);
	return res;
}
```

#### 剩下的都是读入部分，略。

---

### 完整代码

```cpp
#include<bits/stdc++.h>

#define int long long
#define up(i,x,y) for(register int i=x;i<=y;i++)
#define pr printf

using namespace std;

inline int read() {
	int x = 0, f = 0;
	char ch = getchar();
	while (!isdigit(ch)) {
		f |= (ch == '-');
		ch = getchar();
	}
	while (isdigit(ch))x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return f ? -x : x;
}
inline void write(int x) {
	if (x < 0)putchar('-'), x = -x;
	if (x > 9)write(x / 10);
	putchar(x % 10 | 48);
}
inline void writeln(int x) {
	write(x), putchar('\n');
}
inline void writesp(int x) {
	write(x), putchar(' ');
}
#define lc u << 1
#define rc u << 1 | 1

const int N = 1e5 + 10;
int a[N];
vector <int> edge[N];
int fa[N], deep[N], sz[N], wson[N], top[N], id[N], w[N], cnt;

inline void dfs1(int u, int fath) {
	deep[u] = deep[fath] + 1 ,sz[u] = 1 ,fa[u] = fath;
	for (int v : edge[u]) {
		if (v == fath) continue;
		dfs1(v, u);
		sz[u] += sz[v];
		if (sz[wson[u]] < sz[v]) wson[u] = v;
	}
}
inline void dfs2(int u, int t) { //处理 top ,id，nw。
	top[u] = t ,id[u] = ++ cnt ,w[cnt] = a[u];
	if (!wson[u]) return;
	dfs2(wson[u], t);
	for (int v : edge[u]) {
		if (v == fa[u] || v == wson[u]) continue;
		dfs2(v, v);
	}
}

struct segment_tree {
	int l, r, add, sum;
} tr[N << 2];

inline void pushup(int u) {
	tr[u].sum = tr[lc].sum + tr[rc].sum;
}
inline void pushdown(int u) {
	if (tr[u].add) {
		tr[lc].sum += tr[u].add * (tr[lc].r - tr[lc].l + 1);
		tr[lc].add += tr[u].add;
		tr[rc].sum += tr[u].add * (tr[rc].r - tr[rc].l + 1);
		tr[rc].add += tr[u].add;
		tr[u].add = 0;
	}
}
inline void build(int u, int l, int r) {
	tr[u] = {l, r, 0, w[r]};
	if (l == r) return;
	int mid = ((l + r) >> 1);
	build(lc, l, mid);
	build(rc, mid + 1, r);
	pushup(u);
}
inline int query(int u, int L, int R) {
	int l = tr[u].l, r = tr[u].r;
	if (l >= L && r <= R) return tr[u].sum;
	pushdown(u);
	int mid = ((l + r) >> 1);
	int res = 0;
	if (L <= mid) res += query(lc, L, R);
	if (mid < R) res += query(rc, L, R);
	return res;
}
inline int query_path(int u, int v) {
	int res = 0;
	while (top[u] != top[v]) {
		if (deep[top[u]] < deep[top[v]]) swap(u, v);
		res += query(1, id[top[u]], id[u]);
		u = fa[top[u]];
	}
	if (deep[u] > deep[v]) swap(u, v);
	res += query(1, id[u], id[v]);
	return res;
}
inline int query_tree(int u) {
	return query(1, id[u], id[u] + sz[u] - 1);
}
inline void update(int u, int L, int R, int k) {
	int l = tr[u].l, r = tr[u].r;
	if (l >= L && r <= R) {
		tr[u].add += k;
		tr[u].sum += k * (r - l + 1);
		return;
	}
	pushdown(u);
	int mid = ((l + r) >> 1);
	if (L <= mid) update(lc, L, R, k);
	if (mid < R) update(rc, L, R, k);
	pushup(u);
}
inline void update_path(int u, int v, int k) {
	while (top[u] != top[v]) {
		if (deep[top[u]] < deep[top[v]]) swap(u, v);
		update(1, id[top[u]], id[u], k);
		u = fa[top[u]];
	}
	if (deep[u] > deep[v]) swap(u, v);
	update(1, id[u], id[v], k);
}
inline void update_tree(int u, int k) {
	update(1, id[u], id[u] + sz[u] - 1, k);
}
signed main() {
	int n = read(), m = read(), root = read(), p = read();
	up(i, 1, n) a[i] = read();
	up(i, 1, n - 1) {
		int u = read(), v = read();
		edge[u].push_back(v);
		edge[v].push_back(u);
	}

	dfs1(root, 0);//根节点没有父亲哈。
	dfs2(root, root);//根节点的重链顶端肯定是自己哈。

	build(1, 1, n);
	while (m --) {
		int op = read(), u = read();
		if (op == 1) {
			int v = read(), k = read();
			update_path(u, v, k);
		}
		if (op == 2) {
			int v = read();
			writeln(query_path(u, v) % p);
		}
		if (op == 3) {
			int k = read();
			update_tree(u, k);
		}
		if (op == 4) writeln(query_tree(u) % p);
	}
	return 0;
} // 158 行代码完结撒花！
```

![](https://cdn.luogu.com.cn/upload/image_hosting/hsax6i04.png)

重链剖分应用 $1$：边权转点权
---

$T1$ [USACO11DEC] Grass Planting G
---
> [P3038](https://www.luogu.com.cn/problem/P3038)。
>
> 给出一棵有 $n$ 个节点的树，以及 $m$ 次操作：
>
> - `P x y`：将 $x$，$y$ 之间的简单路径上的边权均加一。
>
> - `Q x y`：查询 $x$，$y$ 之间的那一条边的边权，保证两个节点**直接相连**。
>
> 初始边权均为 $0$。
>
> $2\le n\le 10^5$，$1\le m\le 10^5$。

那时的我：哎呀这玩意不是很简单嘛，套个模板就行了。

~~结果你们一定猜得到。~~

注意板子题维护的是『点权』，而现在我们需要维护『边权』。

假设有一对父子关系 $u$，$v$，边权为 $w$（$deep_u < deep_v$），那么可以将 $w$ 赋值到 $a_v$。

这样在修改/查询时，剩余的情况为在同一个重链内的 $u$，$v$，这时候 $\operatorname{update}/\operatorname{query}$ 的两个参数 `id[u] ,id[v]` 就需要改为 `id[u] + 1 ,id[v]`，这样就不会计算 $fa_u$ 和 $u$ 之间的那条边的边权了！

注意在线段树修改/查询时可能出现 $id_u + 1 > id_v$（即 $id_u = id_v$）的情况，对我们理解有点误导，这时候特判就行了（不加也没关系，~~**助于理解**~~）。

时间复杂度为 $\mathcal O(m\log^2 n)$。

$T2$ 月下“毛景树”
---

> [P4315](https://www.luogu.com.cn/problem/P4315)
>
> 给定一棵 $n$ 个节点的树，有若干如下操作，以 `Stop` 结束：
>
> - `Change k w`：将第 $k$ 条边的边权改为 $w$。
>  
> - `Cover u v w`：将 $u$，$v$ 之间的边的边权都改为 $w$。
>
> - `Add u v w`：将 $u$，$v$ 之间的边的边权都加 $w$。
>
> -  `Max u v`：求 $u$，$v$ 之间的边的边权的最大值。
>
> $1\le n\le 10^5$，操作和询问数目不超过 $10^5$，且在操作后所有边权都不会大于 $10^9$。

板子题。

`Change` 操作就是单点修改，`Cover` 操作就是区间覆盖，`Add` 操作就是区间加，`Max` 操作就是区间求最大值。

这里就是维护区间覆盖（懒标记）、区间最大值（信息）、区间加（懒标记）的板子，熟练应用线段树就可以 AC 了。

注意这里是『边权』不是『点权』。

时间复杂度为 $\mathcal O(m\log^2 n)$，$m$ 为操作次数。

## 关于边权的一个小问题

既然能把 $(u,v,w)$ 折射到 $a_v = w$，那么能不能把 $(u,v,w)$ 折射到 $a_u = w$ 呢？

明显更麻烦，所以不提倡，当然你硬要做可以写几个特判，我可能会在视频里提到。

重链剖分应用 $2$：求 LCA
---

既然『前置知识』里有 LCA，那么我们能不能把 LCA 不改成『前置知识』呢（~~线段树还是算了~~）？

答案是可以的。

首先预处理一模一样，仍是 `dfs1` 和 `dfs2`。

> 现在要证明一个点：对于两个节点 $x$，$y$，若不在同一条重链上，则 $\operatorname{LCA}(x,y)$ 也不在较深的重链上。

证明：

![](https://cdn.luogu.com.cn/upload/image_hosting/03kcrojm.png)

此时 $x$，$y$ 所属重链没有交集，LCA 也不在这 $y$ 所属重链上。

![](https://cdn.luogu.com.cn/upload/image_hosting/rjd0a67b.png)

此时两者 LCA 为 $x$，$x$ 不在 $y$ 所属重链中。

分类讨论完毕，因此得证。

所以我们可以模仿跳重链的过程，跳到同一重链时，取深度较浅的节点即为 LCA（想不通记得注意重链是一条链）。

上面证明过了一条路径的重链个数为 $\mathcal O(\log n)$ 级别，时间复杂度为 $\mathcal O(n\log n)$。

$T1$【模板】最近公共祖先（LCA）
---
> [P3379](https://www.luogu.com.cn/problem/P3379)。
> 
> 给定 $Q$ 组询问，每次给定 $x$，$y$，求在给出的 $n$ 个节点的树中，$\operatorname{LCA}(x,y)$。
> 
> $1\le n ,m\le 5\times 10^5$，$1\le x ,y\le n$。

看懂上面的，这就是板子题了 awa。

时间复杂度为 $\mathcal O(Q\log n)$。

```cpp
/* 蒟蒻中期码风，略丑，勿喷。 */
#include<bits/stdc++.h>

#define int long long
#define up(i,x,y) for(register int i=x;i<=y;i++)

using namespace std;

inline int read(){int x = 0, f = 0;char ch = getchar();while (!isdigit(ch)) {f |= (ch == '-');ch = getchar();}while (isdigit(ch))x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();return f ? -x : x;}
inline void write(int x){if (x < 0)putchar('-'), x = -x;if (x > 9)write(x / 10);putchar(x % 10 | 48);}
inline void writeln(int x){write(x), putchar('\n');}
inline void writesp(int x){write(x), putchar(' ');}

const int N = 5e5 + 10;
vector <int> edge[N];
int fa[N],deep[N],son[N],sz[N];
int top[N];

inline void dfs1(int u,int fath){
  fa[u] = fath ,deep[u] = deep[fath] + 1, sz[u] = 1;
  for(int v : edge[u]){
    if(v == fath) continue;
    dfs1(v,u);
    sz[u] += sz[v];
    if(sz[son[u]] < sz[v]) son[u] = v;
  }
} inline void dfs2(int u,int t){
  top[u] = t;
  if(!son[u]) return;
  dfs2(son[u],t);
  for(int v : edge[u]){
    if(v == fa[u] || v == son[u]) continue;
    dfs2(v,v);
  }
}
/* 以上都是基本操作。 */

inline int LCA(int u,int v){
  while(top[u] != top[v]){
    if(deep[top[u]] < deep[top[v]]) swap(u,v);
    u = fa[top[u]];
  }
  return deep[u] < deep[v] ? u : v;// 选取深度较低的点为 LCA。
} signed main() {
  int n = read() , Q = read() ,s = read();
  up(i,1,n - 1){int u = read() ,v = read();edge[u].push_back(v);edge[v].push_back(u);}
  dfs1(s,0);
  dfs2(s,s);
  while(Q--){int u = read() ,v = read() ;writeln(LCA(u,v));}
  return 0;
}
```

现在前置知识（例题）里的求 LCA 步骤就可以用树剖了！（~~小题大做~~

---

## 作者：Tighnarri (赞：4)

## 【模板】重链剖分/树链剖分

### 预备知识
1. 知道什么是树，会存图，遍历图。
2. 会[【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)。

知道这两个知识，我们就能来学树剖了。

### 一些概念
重儿子：子树大小最大的儿子。

轻儿子：非重儿子的所有儿子节点。

重边：连接当前节点与重儿子节点的边。

轻边：连接当前节点与轻儿子节点的边。

重链：若干条首尾衔接的重边。

重链剖分：先遍历每个点的重儿子，再遍历轻儿子得到的 DFS 序。

具有如下性质：

1. 整棵树在树剖后被分为若干条链，每条链中的节点在 DFS 序中连续且按深度递增（父亲一定在儿子之前）。
2. 有普通 DFS 序的性质，一个点的子树区间在 DFS 序中可以表示成 $dfn_i→dfn_i+siz_i-1$ 。
### 具体实现
接下来就是如何把一棵树剖成链。

观察上面的概念，发现重儿子与子树大小有关，所以需要一个保存子树大小的数组 $siz$ 。要记录 DFS 序，所以需要个数组 $dfn$ ，与计数变量 $dfx$ 。需要记录每个节点的重儿子，需要数组 $hson$。需要存图，可以用链式前向星。

此时我们已经可以把树剖成链了，但是链与链之间没有关联，而且我们也不知道这条链有多长（或者说到哪结束）

所以我们需要另一些信息，每条链的链顶（深度最小的节点） $top$ 数组，和每个节点的父亲 $fa$ 数组，以及每个节点的深度 $dep$ 数组。

这时候我们第一遍 DFS 数组处理第一段说的，第二遍 DFS 处理第二段说的，就可以把树剖成一个完美的，可用的链了。

code：
```cpp
int siz[N],fa[N],top[N],dep[N],dis[N],hson[N],dfn[N],dfx,dist[N];
void dfs1(int u,int f){
	dep[u]=dep[f]+1;
	siz[u]=1;
	fa[u]=f;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==f) continue;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[v]>siz[hson[u]]){
			hson[u]=v;
		}
	}
	return ;
}
void dfs2(int u,int tp){
	top[u]=tp;
	dfn[u]=++dfx;
	dist[dfx]=dis[u];
	if(hson[u]) dfs2(hson[u],tp);
	else return;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa[u] || v==hson[u]) continue;
		dfs2(v,v);
	}
	return ;
}
```
**补充**：在本题种因为点带权，所以需要保留下来这些点在 DFS 序中的位置以及大小，也就是 $dist$ 数组。

这些代码是不是非常好懂而且形象，如果有不懂得可以私信或者回复问我。

### 维护序列
然后我们得到了一个序列，直接拿线段树维护就行了。

修改或者查询子树是简单的，我们有上述规律：$dfn_i→dfn_i+siz_i-1$ ，直接像正常线段树一样修改或者查询这一段区间即可。

代码形如这样，code：

```cpp
void changeson(int x,int k){
	modify(1,1,n,dfn[x],dfn[x]+siz[x]-1,k);
}
int askson(int x){
	return query(1,1,n,dfn[x],dfn[x]+siz[x]-1)%p;
}
```

但是怎么修改一条简单路径呢？

我们知道树上路径是唯一的，所以两点路径必定是经过若干条完整的链，然后到达了相同的链，或者本来就在相同的链。

那么对于一条链上的，我们有上述规律：每条链中的节点在 DFS 序中连续且按深度递增

所以说我们直接令 $dfn_x<dfn_y$ 然后修改 $dfn_x→dfn_y$ 这个区间就行。

然后怎么跨链修改？

可以考虑修改完一条链后跳到另一条链上去修改，就是我们先修改 $dfn_{top_x}→dfn_x$ ，然后令 $x=fa_{top_x}$ 跳到下一条链。

但是会出现我们跳到根节点了两个点还不在同一条链，所以我们应当先处理链顶深度较大的点，也就是 $dep_{top_x}>dep_{top_y}$ 。

所以代码像下面这样写，code：
```cpp
void change(int x,int y,int k){
	k%=p;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		modify(1,1,n,dfn[top[x]],dfn[x],k);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	modify(1,1,n,dfn[x],dfn[y],k);
	return ;
}
int ask1(int x,int y){
	int res=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		res+=query(1,1,n,dfn[top[x]],dfn[x])%p;res%=p;
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	res+=query(1,1,n,dfn[x],dfn[y])%p;
	return res%p;
}
```
最后拼上[【模板】线段树 1](https://www.luogu.com.cn/problem/P3372) 的代码，就得到了本题的代码，code：

```cpp
#include<iostream>
#include<queue>
#include<algorithm>
#include<cstring>
#include<vector>
#define lc u*2
#define rc u*2+1
using namespace std;
const int N=1e5+50;
const int M=1e5+50;
int n,m,root,p;
struct Edge{
	int to,nxt;
}e[2*N];
int head[2*N],tot;
void add(int u,int v){
	e[++tot].to=v;
	e[tot].nxt=head[u];
	head[u]=tot;
	return ;
}
int tr[4*N],tag[4*N];
int siz[N],fa[N],top[N],dep[N],dis[N],hson[N],dfn[N],dfx,dist[N];
void dfs1(int u,int f){
	dep[u]=dep[f]+1;
	siz[u]=1;
	fa[u]=f;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==f) continue;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[v]>siz[hson[u]]){
			hson[u]=v;
		}
	}
	return ;
}
void dfs2(int u,int tp){
	top[u]=tp;
	dfn[u]=++dfx;
	dist[dfx]=dis[u];
	if(hson[u]) dfs2(hson[u],tp);
	else return;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa[u] || v==hson[u]) continue;
		dfs2(v,v);
	}
	return ;
}
void pushup(int u){
	tr[u]=(tr[lc]%p+tr[rc]%p)%p;
}
void pushdown(int u,int l,int r){
	int mid=(l+r)>>1;
	tr[lc]+=tag[u]*(mid-l+1)%p;tr[lc]%=p;
	tag[lc]+=tag[u]%p;tag[lc]%=p;
	tr[rc]+=tag[u]*(r-mid)%p;tr[rc]%=p;
	tag[rc]+=tag[u]%p;tag[rc]%=p;
	tag[u]=0;
}
void build(int u,int l,int r){
	tag[u]=0;
	if(l==r){
		tr[u]=dist[l]%p;
		return ;
	}
	int mid=(l+r)>>1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	pushup(u);
	return ;
}
void modify(int u,int l,int r,int x,int y,int k){
	if(l>=x && r<=y){
		tr[u]+=k*(r-l+1)%p;tr[u]%=p;
		tag[u]+=k%p;tag[u]%=p;
		return;
	}
	pushdown(u,l,r);
	int mid=(l+r)>>1;
	if(x<=mid) modify(lc,l,mid,x,y,k);
	if(mid<y) modify(rc,mid+1,r,x,y,k);
	pushup(u);
	return ;
}
int query(int u,int l,int r,int x,int y){
	int res=0;
	if(l>=x && r<=y){
		return tr[u]%p;
	}
	pushdown(u,l,r);
	int mid=(l+r)>>1;
	if(x<=mid) res+=query(lc,l,mid,x,y)%p,res%=p;
	if(mid<y) res+=query(rc,mid+1,r,x,y)%p,res%=p;
	return res%p;
}
void change(int x,int y,int k){
	k%=p;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		modify(1,1,n,dfn[top[x]],dfn[x],k);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	modify(1,1,n,dfn[x],dfn[y],k);
	return ;
}
void changeson(int x,int k){
	modify(1,1,n,dfn[x],dfn[x]+siz[x]-1,k);
}
int ask1(int x,int y){
	int res=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		res+=query(1,1,n,dfn[top[x]],dfn[x])%p;res%=p;
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	res+=query(1,1,n,dfn[x],dfn[y])%p;
	return res%p;
}
int askson(int x){
	return query(1,1,n,dfn[x],dfn[x]+siz[x]-1)%p;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>root>>p;
	for(int i=1;i<=n;i++){
		cin>>dis[i];
	}
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		add(u,v);
		add(v,u);
	}
	dfs1(root,-1);
	dfs2(root,root);
	build(1,1,n);
	for(int i=1;i<=m;i++){
		int op;
		cin>>op;
		if(op==1){
			int x,y,z;
			cin>>x>>y>>z;
			change(x,y,z%p);
		}else if(op==2){
			int x,y;
			cin>>x>>y;
			cout<<ask1(x,y)%p<<'\n';
		}else if(op==3){
			int x,z;
			cin>>x>>z;
			changeson(x,z%p);
		}else if(op==4){
			int x;
			cin>>x;
			cout<<askson(x)%p<<'\n';
		}
	}
	return 0;
}
```
算是一些比较形象的算法了，如果有不懂得欢迎提问，如果有错误的地方请 @ 我改正，谢谢！

---

## 作者：cybermage_liu (赞：4)

> 每个节点一辈子都被束缚在链子上，是重儿子还是轻儿子在开始前就被决定了，不能改变。
> ——树链剖分
# 树链剖分算法思想
## 引入
题目是对链和子树进行操作，如果直接在树上进行操作并不容易。

但是如果把链和子树换成一个区间的话，就是线段树板子了，我们可以利用转化的思想考虑将链和子树转化为区间。

考虑树的先序排列（样例）：$2\ 1\ 4\ 3\ 5$。

可以发现：**如果一个节点有儿子，那它后面第一个点一定是它的某一个儿子，且它的子树在先序排列中是连续的**。

这很重要，我们可以利用这个性质将链和子树转化为区间。

子树可以直接进行转化，因为一个节点的子树在先序排列中是连续的，但链并不好转化。

这时候就要用到树链剖分了。
## 基础概念
* 有关树的基本知识。

* 一个节点拥有的子树最大的儿子是重儿子，其它儿子是轻儿子。

* 连接重儿子的边是重边，连接轻儿子的边是轻边。

* 重边组成的链为重链。
## DFS

我们在 DFS 求先序排列时，将重儿子放在最前面，作为第一个儿子，那么**在先序排列中重链就是一个连续的区间**了，这对后面的树链剖分很重要。

而且还保持着先序排列的性质，对求子树毫无影响，只是改变了一下顺序。

例如下图，黑色为轻链，其余同色为一条重链。

![](https://cdn.luogu.com.cn/upload/image_hosting/efphmc10.png)

**注意，第 $10$ 个节点也在一条重链上，自己就是重链的开端。**

可以通过两次 DFS，求出我们下面树链剖分要用到的所有信息。

第一次 DFS：
* $dep$：节点深度（树链剖分用）。
* $fa$：父亲节点（树链剖分用）。
* $size$：子树大小（找重儿子和求子树用）。
* $son$：重儿子节点（为第二次 DFS 做准备）。

第二次 DFS：
* $in$：此节点在先序排列中的位置（树链剖分和求子树用）。
* $dfn$：先序排列中此位置是哪个节点（建树用）。
* $top$：重链的开端节点（树链剖分用）。
### 代码
```cpp
void dfs(int u,int father){
//当前节点，其父节点
	dep[u]=dep[father]+1;//节点深度
	fa[u]=father;//父亲节点
	size[u]=1;//子树大小
	int maxsize=-inf;
	for(int i=head[u];i;i=nxt[i]){
		int v=ver[i];
		if(v==father) continue;
		dfs(v,u);
		size[u]+=size[v];
		if(size[v]>maxsize){
			maxsize=size[v];
			son[u]=v;//重儿子
		}
	}
}
void dfs2(int u,int father,int topp){
//当前节点，其父节点，当前节点所在重链的开端
	in[u]=++tot2;//节点先序排列位置
	dfn[tot2]=u;//先序排列中此位置是哪个节点
	top[u]=topp;//链的开端
	if(son[u]) dfs2(son[u],u,topp);//重儿子为第一个儿子
	for(int i=head[u];i;i=nxt[i]){
		int v=ver[i];
		if(v==father || v==son[u]) continue;
		dfs2(v,u,v);
	}
}
```
## 树链剖分
经过上面的 DFS 后，此时链可以很容易地拆成多个重链的一部分（除去连接重链的轻链），也就是多个区间，然后对于每个区间用线段树维护，拆链的过程就是树链剖分。

树链剖分（原链两端点为 $x$ 和 $y$）：
* 如果 $top_x$ 和 $top_y$ 相同，那么他们在一条重链上，特殊计算两个点间的重链区间（从 $in_x$ 到 $in_y$）（注意深度小的放前面）。
* 否则计算开端深度较大的点（假设为 $x$，为 $y$ 同理）从开端到此点的重链区间（从 $in_{top_x}$ 到 $in_x$），并将 $x$ 变为其 $fa_{top_x}$，到达另一条重链。

修改与询问同理。

再把上面的图放一遍，方便理解。

![](https://cdn.luogu.com.cn/upload/image_hosting/efphmc10.png)

比如求 $5$ 和 $6$ 之间的链上的值，$5\ 2\ 1\ 3\ 6$ 树链剖分拆成了 $5/2\ 1/3\ 6$。

有人可能会有疑惑，为什么必须要拆成重链呢？因为这样单次树链剖分时间复杂度约为 $O(\log n)$，如果是随意拆链，最坏情况下时间复杂度可以达到树高。
### 代码
```cpp
void change_chain(int x,int y,int z){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);//取开端深度较大的
		change(1,1,n,in[top[x]],in[x],z);//修改开端到此点的重链区间
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	change(1,1,n,in[x],in[y],z);//特殊修改 x 和 y 间的重链区间
}
int query_chain(int x,int y){
	int ans=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);//取开端深度较大的
		ans+=query(1,1,n,in[top[x]],in[x]);//计算开端到此点的重链区间
		ans%=mod;
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	return (ans+query(1,1,n,in[x],in[y]))%mod;//特殊计算 x 和 y 间的重链区间
}
```
## 正确性证明
DFS 部分正确性显然。

树链剖分部分上面已讲过原理，只是将一条链上的节点划分到多条重链上，转化为线段树方便处理的形式。

每次对 $top$ 深度较大的节点进行操作，且一旦 $top$ 相等退出特殊处理，就不会发生越界或多算少算的情况。

正确性也非常显然。

## 时间复杂度分析
线段树单次操作时间复杂度 $O(\log n)$。

单次树链剖分上面已讲过时间复杂度 $O(\log n)$。

总共有 $m$ 次操作。

综上，易得算法整体时间复杂度 $O(m\log^2 n)$。

恭喜你学会了树链剖分！
# AC code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5,inf=0x3f3f3f3f3f3f3f3f;
int n,m,root,mod,a[N],sum[N<<2],lazy[N<<2];
int head[N],nxt[N<<1],ver[N<<1],tot=0;
int size[N],fa[N],dep[N],son[N],in[N],dfn[N],top[N],tot2=0;
//加边
void add(int u,int v){
	ver[++tot]=v;
	nxt[tot]=head[u];
	head[u]=tot;
}
//DFS
void dfs(int u,int father){
//当前节点，其父节点
	dep[u]=dep[father]+1;//节点深度
	fa[u]=father;//父亲节点
	size[u]=1;//子树大小
	int maxsize=-inf;
	for(int i=head[u];i;i=nxt[i]){
		int v=ver[i];
		if(v==father) continue;
		dfs(v,u);
		size[u]+=size[v];
		if(size[v]>maxsize){
			maxsize=size[v];
			son[u]=v;//重儿子
		}
	}
}
void dfs2(int u,int father,int topp){
//当前节点，其父节点，当前节点所在重链的开端
	in[u]=++tot2;//节点现位置
	dfn[tot2]=u;//现位置是哪个节点
	top[u]=topp;//链的开端
	if(son[u]) dfs2(son[u],u,topp);//重儿子为第一个儿子
	for(int i=head[u];i;i=nxt[i]){
		int v=ver[i];
		if(v==father || v==son[u]) continue;
		dfs2(v,u,v);
	}
}
//线段树模板
void pushdown(int k,int l,int r,int mid){
	if(!lazy[k]) return;
	lazy[k<<1]+=lazy[k];
	lazy[k<<1]%=mod;
	lazy[k<<1|1]+=lazy[k];
	lazy[k<<1|1]%=mod;
	sum[k<<1]+=lazy[k]*(mid-l+1);
	sum[k<<1]%=mod;
	sum[k<<1|1]+=lazy[k]*(r-mid);
	sum[k<<1|1]%=mod;
	lazy[k]=0;
}
void build(int k,int l,int r){
	if(l==r){
		sum[k]=a[dfn[l]];//注意这里和普通线段树不同
		sum[k]%=mod;
		return;
	}
	int mid=l+r>>1;
	build(k<<1,l,mid);build(k<<1|1,mid+1,r);
	sum[k]=sum[k<<1]+sum[k<<1|1];sum[k]%=mod;
}
void change(int k,int l,int r,int x,int y,int z){
	if(x<=l && r<=y){
		sum[k]+=z*(r-l+1);
		sum[k]%=mod;
		lazy[k]+=z;
		lazy[k]%=mod;
		return;
	}
	int mid=l+r>>1;
	pushdown(k,l,r,mid);
	if(x<=mid) change(k<<1,l,mid,x,y,z);
	if(mid<y) change(k<<1|1,mid+1,r,x,y,z);
	sum[k]=sum[k<<1]+sum[k<<1|1];sum[k]%=mod;
}
int query(int k,int l,int r,int x,int y){
	if(x<=l && r<=y) return sum[k];
	int mid=l+r>>1,res=0;
	pushdown(k,l,r,mid);
	if(x<=mid) res=query(k<<1,l,mid,x,y);
	if(mid<y) res+=query(k<<1|1,mid+1,r,x,y);
	return res%mod;
}
//树链剖分
void change_chain(int x,int y,int z){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);//取开端深度较大的
		change(1,1,n,in[top[x]],in[x],z);//修改开端到此点的重链区间
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	change(1,1,n,in[x],in[y],z);//特殊修改 x 和 y 间的重链区间
}
int query_chain(int x,int y){
	int ans=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);//取开端深度较大的
		ans+=query(1,1,n,in[top[x]],in[x]);//计算开端到此点的重链区间
		ans%=mod;
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	return (ans+query(1,1,n,in[x],in[y]))%mod;//特殊计算 x 和 y 间的重链区间
}
signed main(){
	cin>>n>>m>>root>>mod;
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(int i=1;i<n;i++){
		int u,v;
		scanf("%lld%lld",&u,&v);
		add(u,v);add(v,u);
	}
	dfs(root,0);
	dfs2(root,0,root);
	build(1,1,n);
	while(m--){
		int op,x,y,z;
		scanf("%lld%lld",&op,&x);
		if(op==1){
			scanf("%lld%lld",&y,&z);
			change_chain(x,y,z%mod);//链
		}
		else if(op==2){
			scanf("%lld",&y);
			printf("%lld\n",query_chain(x,y));//链
		}
		else if(op==3){
			scanf("%lld",&y);
			change(1,1,n,in[x],in[x]+size[x]-1,y%mod);//子树
		}
		else printf("%lld\n",query(1,1,n,in[x],in[x]+size[x]-1));//子树
	}
	return 0;
}
```

---

## 作者：_O_v_O_ (赞：3)

前置知识：[线段树](/problem/P3372)。

# Part I

我们先看加入只有 $3,4$ 操作的情况要咋搞。

我们注意到，我们可以对这个树变成其 **dfs 序**，顾名思义，**dfs 序** 就是对这棵树进行一次 dfs 后，每个点被 dfs 到的顺序。

就拿样例中的树为例：

![](https://cdn.luogu.com.cn/upload/pic/2319.png)

这棵树的 dfs 序为 $[2,1,3,4,5]$。

我们注意到，根据 dfs 的性质，一棵子树的点的编号在 dfs 序上是**连续的**。

那么，树上子树加就转换为了在 dfs 上的区间加，这一点用线段树可以完成。  
具体的，我们设 $in_i$ 为 $i$ 被遍历到的顺序，$out_i$ 为 $i$ 子树遍历完后的顺序，那么 $i$ 子树加就等价于 $[in_i,out_i]$ 加。

# Part II

接下来考虑加入 $1,2$ 操作。

先引入一些概念：

- **重儿子**：对于一个点，我们定义其子树大小最大的儿子为**重儿子**。
- **轻儿子**：对于一个点，它子节点中非重儿子的儿子为**轻儿子**。
- **重链**：一条**顶部为轻儿子**，其余全部以重儿子为节点的路径。

拿一棵树举例：
![](https://cdn.luogu.com.cn/upload/image_hosting/urticqgs.png)

图中标红的点为重儿子，黄色的为轻儿子。  
那么这棵树剖出来的链为 $[1,4,5,6],[2,3],[7],[8]$。

~~好的那么你已经会树剖了。~~

那么我们要如何搞出两点之间加，求和呢？

我们来回想一下我们是咋求 LCA 的。

很显然，是一直用深度大的节点往上跳。  
那么我们这里也可以模仿一下，设 $top_i$ 为 $i$ 所在链的链顶，$fa_i$ 为 $i$ 的父亲，那么设 $y$ 为 $top$ 深度较大的点，我们就一直令 $y\leftarrow fa_{top_y}$。

举个例子，就拿上图中 $6,7$ 号点之间的求和为例。  
因为 $7$ 号点的 $top$ 深度更大，我们先令 $7\leftarrow 4$，即变为 $fa_{top_7}$，那么两点就在同一条链了。

那么我们缺的就是在一条链上的区间加。

我们可以在上述 dfs 时先往重儿子 dfs，那么这样一条链就在 dfs 序上是一个区间了。

# Part 3

所以树链剖分的复杂度是什么呢？

我们注意到，线段树区间加的复杂度为 $O(\log n)$。

有一个性质：两点之间这样跳链总共会经过不超过 $O(\log n)$ 条链。

证明：我们发现，若我们要从一个点走向一个轻儿子，那么子树大小至少都会折半。  
假如我们要从两点之间的 LCA 走向两边，那么分别最多走 $O(\log n)$ 次，因此得证。

那么树链剖分的复杂度就是 $O(n\log^2 n)$ 了。

# Part 4

代码，请自行理解：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int N=1e6+5;
int n,m,r,p;
int a[N],b[N];
int siz[N],son[N],dep[N];
int dfn[N],top[N],out[N],rnk[N],fa[N];
int cnt;
vector<int> e[N];

struct segtree{
#define lrt rt<<1
#define rrt rt<<1|1
	struct seg_tree{
		int sum,l,r,lazy;
	};
	seg_tree tr[N<<2];
	void push_up(int rt){
		tr[rt].sum=(tr[lrt].sum+tr[rrt].sum)%p;
	}
	void push_down(int rt){
		if(tr[rt].lazy){
			(tr[lrt].sum+=tr[rt].lazy*(tr[lrt].r-tr[lrt].l+1)%p)%=p;
			(tr[lrt].lazy+=tr[rt].lazy)%=p;
			(tr[lrt|1].sum+=tr[rt].lazy*(tr[rrt].r-tr[rrt].l+1)%p)%=p;
			(tr[rrt].lazy+=tr[rt].lazy)%=p;
			tr[rt].lazy=0;
		}
	}
	void build(int rt,int l,int r,int a[]){
		tr[rt].l=l,tr[rt].r=r;
		if(l==r){
			tr[rt].sum=a[l]%p;
			return;
		}
		int mrt=(l+r)>>1;
		build(lrt,l,mrt,a),build(rrt,mrt+1,r,a);
		push_up(rt);
	}
	void add(int rt,int l,int r,int x){
		push_down(rt);
		if(tr[rt].l==l&&tr[rt].r==r){
			(tr[rt].lazy+=x)%=p;
			(tr[rt].sum+=tr[rt].lazy*(r-l+1))%=p;
			return;
		}
		int mrt=(tr[rt].l+tr[rt].r)/2;
		if(mrt<l) add(rrt,l,r,x);
		else if(mrt>=r) add(lrt,l,r,x);
		else add(lrt,l,mrt,x),add(rrt,mrt+1,r,x);
		push_up(rt);
	}
	int ask(int rt,int l,int r){
		push_down(rt);
		if(tr[rt].l==l&&tr[rt].r==r){
			return tr[rt].sum%p;
		}
		int mrt=(tr[rt].l+tr[rt].r)/2;
		if(mrt<l) return ask(rrt,l,r);
		else if(mrt>=r) return ask(lrt,l,r);
		else return (ask(lrt,l,mrt)+ask(rrt,mrt+1,r))%p;
	}
};
segtree tr;

void dfs1(int x){
	siz[x]=1,son[x]=-1;
	for(int i:e[x]){
		if(i==fa[x]) continue;
		fa[i]=x,dep[i]=dep[x]+1;
		dfs1(i);
		siz[x]+=siz[i];
		if(son[x]==-1||siz[i]>siz[son[x]]){
			son[x]=i;
		}
	}
}

void dfs2(int x){
	dfn[x]=++cnt,b[cnt]=a[x];
	if(son[x]!=-1){
		top[son[x]]=top[x];
		dfs2(son[x]);
	}
	for(int i:e[x]){
		if(i==fa[x]||i==son[x]) continue;
		top[i]=i;
		dfs2(i);
	}
	out[x]=cnt;
}

void add1(int x,int y,int z){
	z%=p;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		tr.add(1,dfn[top[x]],dfn[x],z);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	tr.add(1,dfn[x],dfn[y],z);
}

int ask1(int x,int y){
	int ans=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		(ans+=tr.ask(1,dfn[top[x]],dfn[x]))%=p;
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	(ans+=tr.ask(1,dfn[x],dfn[y]))%=p;
	return ans;
}

void add2(int x,int z){
	z%=p;
	tr.add(1,dfn[x],out[x],z);
}

int ask2(int x){
	return tr.ask(1,dfn[x],out[x]);
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(nullptr);
	cin>>n>>m>>r>>p;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		e[u].push_back(v),e[v].push_back(u);
	}
	fa[r]=r;
	dfs1(r);
	top[r]=r;
	dfs2(r);
	tr.build(1,1,n,b);
	while(m--){
		int op;
		cin>>op;
		if(op==1){
			int x,y,z;
			cin>>x>>y>>z;
			add1(x,y,z);
		}
		if(op==2){
			int x,y;
			cin>>x>>y;
			cout<<ask1(x,y)<<endl;
		}
		if(op==3){
			int x,z;
			cin>>x>>z;
			add2(x,z);
		}
		if(op==4){
			int x;
			cin>>x;
			cout<<ask2(x)<<endl;
		}
	}
	return 0;
}
```

---

## 作者：niuzh (赞：2)

### 前置芝士
 - [树](https://oi-wiki.org/graph/tree-basic/)
 - [线段树](https://oi-wiki.org/ds/seg/)
## 思路

我们先引入两个概念：

- **重子节点**：对于一个点，其子树大小最大的子节点是**重子节点**。
- **重边**：连接一个节点与它**重子节点**的边为**重边**。
- **轻子节点**：不是**重子节点**就是**轻子节点**。
- **轻边**：连接一个节点与它**轻子节点**的边为**轻边**。
- **重链**：若干条首尾衔接的重边为**重链**。

树肯定会被重链**完全剖分**。

举个栗子。~~将就看吧。~~
![](https://cdn.luogu.com.cn/upload/image_hosting/uin1xvmn.png)

标蓝的是重子节点，一个红框是一条重链。

这有什么用呢？

考虑对树进行 dfs 时优先去重子节点。此时一条重链里一段连续区间点的 dfs 序是**连续的**。

所以我们可以开一个线段树去维护每一个重链里点权的和了。

观察一下，~~显然~~它也可以求 LCA（最近公共祖先），对于两个点，我们可以反复让两点中**所在重链顶部深的点**跳到**所在重链顶部的父亲**，直到两点处于**同一重链**，此时深的点一定是浅的点的**后代**，直接暴力跳即可。

> 为什么不让自身深的点跳呢？
> ![](https://cdn.luogu.com.cn/upload/image_hosting/5obk9efk.png)
> 
> 找 $4$ 和 $5$ 的最近公共祖先，显然就会出问题。

时间复杂度呢？

可以发现，每经过一个**轻边**时，就到了另一条重链，同时所在子树大小也**至少除以二**。

因此，对于树上的每一条路径，把它拆成从 LCA 到两端点，分别至多跳 $$O(\log n)$$ 次。所以，树上的每条路径都可以被拆分成不超过 $$O(\log n)$$ 条重链。

## 代码实现

#### 定义变量

```cpp
const int N=1e5+10;
vector<int> tree[N];
int n,m,r,cnt,a[N],mod;
int fa[N],dep[N],sze[N],son[N],top[N],dfn[N];
```
数组含义：
 - $tree$ 是树。
 - $a$ 是初始点权。
 - $fa$ 是节点父亲。
 - $dep$ 是节点深度。
 - $sze$ 是以节点为根子树的大小。
 - $son$ 是节点**重子节点**。
 - $top$ 是节点所在**重链**的顶部节点。
 - $dfn$ 是节点 **dfs 序**，也是线段树中的编号。

#### 线段树

```cpp
struct node
{
	int tree[N<<2],lzy[N<<2];
	void pushup(int p)
	{
		tree[p]=tree[p<<1]+tree[p<<1|1];
		tree[p]%=mod;
	}
	void makelzy(int p,int l,int r,int x)
	{
		tree[p]+=(x*(r-l+1))%mod;
		lzy[p]+=x;
		lzy[p]%=mod;
	}
	void pushdown(int p,int l,int r)
	{
		int mid=(l+r)>>1;
		makelzy(p<<1,l,mid,lzy[p]);
		makelzy(p<<1|1,mid+1,r,lzy[p]);
		lzy[p]=0;
	}
	void update(int p,int l,int r,int x,int y,int add)
	{
		if (x<=l&&r<=y)
		{
			makelzy(p,l,r,add);
			return;
		}
		pushdown(p,l,r);
		int mid=(l+r)>>1;
		if (mid>=x) update(p<<1,l,mid,x,y,add);
		if (mid<y) update(p<<1|1,mid+1,r,x,y,add);
		pushup(p);
	}
	int query(int p,int l,int r,int x,int y)
	{
		if (x<=l&&r<=y)
		{
			return tree[p];
		}
		pushdown(p,l,r);
		int mid=(l+r)>>1,ans=0;
		if (mid>=x) ans+=query(p<<1,l,mid,x,y)%mod;
		if (mid<y) ans+=query(p<<1|1,mid+1,r,x,y)%mod,ans%=mod;
		return ans%mod;
	}
} tr;
```
没啥可说的，注意取模。

### 树剖部分

#### 预处理
```cpp
void dfs1(int x)
{
	son[x]=-1;//设为-1方便找重子节点。
	sze[x]=1;
	for (auto v:tree[x])
	{
		if (dep[v]) continue;//代表已经访问过了，是父亲。
		dep[v]=dep[x]+1;
		fa[v]=x;
		dfs1(v);
		sze[x]+=sze[v];
		if (son[x]==-1||sze[v]>sze[son[x]])
		{
			son[x]=v;
		}
	}
}
```
处理出 $fa$，$son$，$sze$ 和 $dep$ 的值。按照定义求即可。

#### 处理重链（重点）

```cpp
void dfs2(int x, int t)//这里的t是当前节点所在重链顶部的编号。（不是dfs序编号）
{
	top[x]=t;//赋值。
	cnt++;
	dfn[x]=cnt;//dfs序。
	if(a[x])
	{
		tr.update(1,1,n,dfn[x],dfn[x],a[x]);//赋初值。
	}
	if (son[x]==-1)//没有子节点，是叶子节点。
	{
		return;
	}
	dfs2(son[x],t);//优先跳重子节点。
	for (auto v:tree[x])
	{
		if (v!=son[x]&&v!=fa[x])//再跳轻子节点。
		{
			dfs2(v,v);//到一条新的重链，注意此重链顶部就是这个轻子节点。
		}
	}
}
```
这里是求每个点的 dfs 序与所在重链顶点。考虑在搜索时记录当前所在重链顶点，如果往下搜自己的重子节点，就不变，否则将其设为往下搜的轻子节点。

#### 处理操作 $1$ 和 $2$。（求 LCA，重点）

都是求 LCA，放到一块说。

```cpp
void add(int u,int v,int k)
{
	while (top[u]!=top[v])//不在同一重链。
	{
		if (dep[top[u]]<dep[top[v]])
		{
			swap(u,v);//所在重链顶部深的点是u。（两点顺序无影响）
		}
		tr.update(1,1,n,dfn[top[u]],dfn[u],k);//重链里连续区间点的 dfs 序是连续的，直接线段树加。
		u=fa[top[u]];//跳~~~
	}
	if (dep[u]>dep[v])
	{
		swap(u,v);//深的点是v。
	}
	tr.update(1,1,n,dfn[u],dfn[v],k);//同上。
}
int query(int u,int v)//同理。
{
	int ans=0;
	while (top[u]!=top[v])
	{
		if (dep[top[u]]<dep[top[v]])
		{
			swap(u,v);
		}
		ans+=tr.query(1,1,n,dfn[top[u]],dfn[u]);
		ans%=mod;
		u=fa[top[u]];
	}
	if (dep[u]>dep[v])
	{
		swap(u,v);
	}
	ans+=tr.query(1,1,n,dfn[u],dfn[v]);
	ans%=mod;
	return ans;
}
```
一直跳直到两点处于同一重链，具体思路上边讲了。注意一定要取模。

#### 处理操作 $3$ 和 $4$。

```cpp
int queryone(int u)
{
	return tr.query(1,1,n,dfn[u],dfn[u]+sze[u]-1);
}
void addone(int u,int k)
{
	tr.update(1,1,n,dfn[u],dfn[u]+sze[u]-1,k);
}
```

一个子树中的 dfs 序无论如何都是连续的，直接加或求和。

#### 主程序

```cpp
signed main()
{
	cin>>n>>m>>r>>mod;
	for (int i=1; i<=n; i++)
	{
		cin>>a[i];
		a[i]%=mod;
	}
	for (int i=1; i<n; i++)
	{
		int u,v;
		cin>>u>>v;
		tree[u].push_back(v);
		tree[v].push_back(u);
	}
	dep[r]=1;//注意根节点是r。
	dfs1(r);
	dfs2(r,r);
	while (m--)
	{
		int op;
		cin>>op;
		if (op==1)//操作1。
		{
			int x,y,z;
			cin>>x>>y>>z;
			add(x,y,z);
		}
		else if (op==2)//操作2。
		{
			int x,y;
			cin>>x>>y;
			cout<<query(x,y);
			cout<<'\n';
		}
		else if (op==3)//操作3。
		{
			int x,z;
			cin>>x>>z;
			addone(x,z);
		}
		else//操作4。
		{
			int x;
			cin>>x;
			cout<<queryone(x);
			cout<<'\n';
		}
	}
	return 0;
}
```
### 总代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
vector<int> tree[N];
int n,m,r,cnt,a[N],mod;
struct node
{
	int tree[N<<2],lzy[N<<2];
	void pushup(int p)
	{
		tree[p]=tree[p<<1]+tree[p<<1|1];
		tree[p]%=mod;
	}
	void makelzy(int p,int l,int r,int x)
	{
		tree[p]+=(x*(r-l+1))%mod;
		lzy[p]+=x;
		lzy[p]%=mod;
	}
	void pushdown(int p,int l,int r)
	{
		int mid=(l+r)>>1;
		makelzy(p<<1,l,mid,lzy[p]);
		makelzy(p<<1|1,mid+1,r,lzy[p]);
		lzy[p]=0;
	}
	void update(int p,int l,int r,int x,int y,int add)
	{
		if (x<=l&&r<=y)
		{
			makelzy(p,l,r,add);
			return;
		}
		pushdown(p,l,r);
		int mid=(l+r)>>1;
		if (mid>=x) update(p<<1,l,mid,x,y,add);
		if (mid<y) update(p<<1|1,mid+1,r,x,y,add);
		pushup(p);
	}
	int query(int p,int l,int r,int x,int y)
	{
		if (x<=l&&r<=y)
		{
			return tree[p];
		}
		pushdown(p,l,r);
		int mid=(l+r)>>1,ans=0;
		if (mid>=x) ans+=query(p<<1,l,mid,x,y)%mod;
		if (mid<y) ans+=query(p<<1|1,mid+1,r,x,y)%mod,ans%=mod;
		return ans%mod;
	}
} tr;
int fa[N],dep[N],sze[N],son[N],top[N],dfn[N];
void dfs1(int x)
{
	son[x]=-1;
	sze[x]=1;
	for (auto v:tree[x])
	{
		if (dep[v]) continue;
		dep[v]=dep[x]+1;
		fa[v]=x;
		dfs1(v);
		sze[x]+=sze[v];
		if (son[x]==-1||sze[v]>sze[son[x]])
		{
			son[x]=v;
		}
	}
}
void dfs2(int x, int t)
{
	top[x]=t;
	cnt++;
	dfn[x]=cnt;
	if(a[x])
	{
		tr.update(1,1,n,dfn[x],dfn[x],a[x]);
	}
	if (son[x]==-1)
	{
		return;
	}
	dfs2(son[x],t);
	for (auto v:tree[x])
	{
		if (v!=son[x]&&v!=fa[x])
		{
			dfs2(v,v);
		}
	}
}
void add(int u,int v,int k)
{
	while (top[u]!=top[v])
	{
		if (dep[top[u]]<dep[top[v]])
		{
			swap(u,v);
		}
		tr.update(1,1,n,dfn[top[u]],dfn[u],k);
		u=fa[top[u]];
	}
	if (dep[u]>dep[v])
	{
		swap(u,v);
	}
	tr.update(1,1,n,dfn[u],dfn[v],k);
}
int query(int u,int v)
{
	int ans=0;
	while (top[u]!=top[v])
	{
		if (dep[top[u]]<dep[top[v]])
		{
			swap(u,v);
		}
		ans+=tr.query(1,1,n,dfn[top[u]],dfn[u]);
		ans%=mod;
		u=fa[top[u]];
	}
	if (dep[u]>dep[v])
	{
		swap(u,v);
	}
	ans+=tr.query(1,1,n,dfn[u],dfn[v]);
	ans%=mod;
	return ans;
}
int queryone(int u)
{
	return tr.query(1,1,n,dfn[u],dfn[u]+sze[u]-1);
}
void addone(int u,int k)
{
	tr.update(1,1,n,dfn[u],dfn[u]+sze[u]-1,k);
}
signed main()
{
	cin>>n>>m>>r>>mod;
	for (int i=1; i<=n; i++)
	{
		cin>>a[i];
		a[i]%=mod;
	}
	for (int i=1; i<n; i++)
	{
		int u,v;
		cin>>u>>v;
		tree[u].push_back(v);
		tree[v].push_back(u);
	}
	dep[r]=1;
	dfs1(r);
	dfs2(r,r);
	while (m--)
	{
		int op;
		cin>>op;
		if (op==1)
		{
			int x,y,z;
			cin>>x>>y>>z;
			add(x,y,z);
		}
		else if (op==2)
		{
			int x,y;
			cin>>x>>y;
			cout<<query(x,y);
			cout<<'\n';
		}
		else if (op==3)
		{
			int x,z;
			cin>>x>>z;
			addone(x,z);
		}
		else
		{
			int x;
			cin>>x;
			cout<<queryone(x);
			cout<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：lw393 (赞：2)

**算法介绍**

重点在于介绍重链剖分。

重链剖分是在 $O(\log n \times T(n))$ 的复杂度下维护树上的任意一条链的算法（$T(n)$ 是修改或查询的时间复杂度）。

在此之前，我们先看看怎么使用重链剖分求两点的 LCA。

顾名思义，重链剖分就是将树拆分成一条一条的重链，然后利用重链的性质去解决树上任意链的问题。

我们先借助图来理解什么是重边：

![](https://cdn.luogu.com.cn/upload/image_hosting/mnr4hyjp.png)

在这幅图中画出的用两根线连着的边是重边，而连续的重边形成重链。重边怎么界定呢？我们规定重儿子是一个节点的子结点中子树大小最大的子节点，重边是一个点到其重儿子的边（若有多个，任取其一）。

![](https://cdn.luogu.com.cn/upload/image_hosting/vgabllo3.png)

然后在这幅图中，标记了每个点的父亲与重儿子还有字数大小来帮助理解。

了解了上述后开始进行实现。

先定义一些数组（这些就是我们要预处理的）：

1. $father_x$ 是节点 $x$ 的父亲编号。
2. $deep_x$ 是节点 $x$ 的树上深度。
3. $siz_x$ 是节点 $x$ 的字树大小。
4. $son_x$ 是节点 $x$ 的重儿子。
5. $top_x$ 是节点 $x$ 所处重链的链头。

我们需要进行两次 dfs 来做到对如上数组的定义。

在第一次 dfs 中，我们需要完成对每个节点重儿子，深度，子树大小，与父亲的处理。重儿子是节点的儿子中子树大小最大的儿子。

不难，所以直接给出代码：
```cpp
void dfs1(int u, int fa){
    deep[u] = deep[fa] + 1;
    father[u] = fa;
    siz[u] = 1;
    for(auto v : G[u]){
        if(v == fa) continue;
        dfs1(v, u);
        siz[u] += siz[v];
        if(!son[u] || siz[son[u]] < siz[v]){
            son[u] = v;
        }
    }
}
```

在第二个 dfs 中，我们就需要记录节点的链头。

代码：
```cpp
void dfs2(int u, int topx){
    top[u] = topx;
    if(!son[u]) return;
    dfs2(son[u], topx); //重儿子与节点自己在同一个重链上
    for(auto v : G[u]){
        if(v == father[u] || v == son[u]) continue;
        dfs2(v, v);//开一条新链，此边为轻边
    }
}
```
做完了重链剖分以后怎么去利用我们统计好的节点内的结果去计算 LCA 呢？

我们利用好重链的性质。我们知道若 $top_u \not = top_v$ 则 $u$，$v$ 不一定存在祖先后代关系。

而在 $top_u=top_v$ 时必定深度小的为祖先。

我们就让所在链头深度大的往上跳。知道链头相同时退出。

代码：
```cpp
int lca(int u, int v){
    while(top[u] != top[v]){
        if(deep[top[u]] < deep[top[v]]) swap(u, v);
        u = father[top[u]];
    }
    return (deep[u] < deep[v] ? u : v);
}
```

这样我们就得到了树链剖分求 LCA 的全过程了。

**正确性证明**

对于重链剖分后的一棵树，若 $(u,v)$ 是一条轻链则 $$siz_v \le \frac{siz_u}{2}$$。

由上可知，任意两点间的路径轻链不会超过 $2 \log_2n$ 条，故向上跳的次数上界为 $2\log_2n$ 次。

于是我们就得到单次查询的复杂度应为 $O(\log n)$。

**本题做法**

我们利用重链剖分中将一条链拆分成若干个链的思想，再利用树的 dfs 序来维护链上点的信息（本质是将一棵树拆分成了序列）。

对于链上修改与查询，我们使用线段树来处理这个已经转换为区间修改区间和的问题。

上面针对 LCA 的树链剖分的两次 dfs 显得不够用了，我们还需要 dfs 序将树拉成序列，为了方便还要记录每个点转换成的 dfs 序编号，以及它的反映射。

修改完的完全体代码如下：

```cpp
vector<int>G[N];
int deep[N], father[N], siz[N], son[N];
int top[N], dfn[N], rev[N], num, w[N];

int val[N];//原编号点权

void dfs1(int u, int fa){
    deep[u] = deep[fa] + 1;
    father[u] = fa;
    siz[u] = 1;
    for(auto v : G[u]){
        if(v == fa) continue;
        dfs1(v, u);
        siz[u] += siz[v];
        if(!son[u] || siz[son[u]] < siz[v]){
            son[u] = v;
        }
    }
}

void dfs2(int u, int topx){
    dfn[u] = ++num; //dfs序
    w[num] = val[u]; //dfs序编号对应的点权，这里是为了方便
    rev[num] = u; //dfs序->点编号
    top[u] = topx;
    if(!son[u]) return;
    dfs2(son[u], topx);
    for(auto v : G[u]){
        if(v == father[u] || v == son[u]) continue;
        dfs2(v, v);
    }
}
```

然后利用上面 lca 的结构来写查询与修改。不难发现，就是拆分了链为若干条重链后的每条重链都处理一遍（代码中的 query 与 modify 函数是线段树处理的事）。

解释一下：为什么可以用区间修改的方式处理每条重链。原因在于我们在 dfs2 中，每颗子树都先访问的是重儿子，所以每条重链上 dfs 序是连续的。

代码：

```cpp
void add_in_path(int x, int y, int z){
    while(top[x] != top[y]){
        if(deep[top[x]] < deep[top[y]]) swap(x, y);
        modify(1, dfn[top[x]], dfn[x], z);//这是待修链的对应序列区间，在query中也是一样的
        x = father[top[x]];
    }
    if(deep[x] > deep[y]) swap(x, y);
    modify(1, dfn[x], dfn[y], z);//最后一段
}

int query_in_path(int x, int y){
    int ans = 0;
    while(top[x] != top[y]){
        if(deep[top[x]] < deep[top[y]]) swap(x, y);
        (ans += query(1, dfn[top[x]], dfn[x])) %= mod;
        x = father[top[x]];
    }
    if(deep[x] > deep[y]) swap(x, y);
    (ans += query(1, dfn[x], dfn[y])) %= mod;
    return ans;
}
```

上述部分是特指链上操作的部分，而一整颗子树的操作的话我们利用 dfs 序，直接操作区间 $[dfn_x,dfn_x+siz_x-1]$，就好了。

树链剖分的板子就好了（其实树链剖分的板子真实意义上是 lca 那道题）。

代码的时间复杂度容易分析是：$O(\log^2n)$。

**代码实现**

再贴一遍：

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
#define int long long
const int N = 1e5 + 5;
int mod = 0;

//树链剖分

vector<int>G[N];
int deep[N], father[N], siz[N], son[N];
int top[N], dfn[N], rev[N], num, w[N];

int val[N];

void dfs1(int u, int fa){
    deep[u] = deep[fa] + 1;
    father[u] = fa;
    siz[u] = 1;
    for(auto v : G[u]){
        if(v == fa) continue;
        dfs1(v, u);
        siz[u] += siz[v];
        if(!son[u] || siz[son[u]] < siz[v]){
            son[u] = v;
        }
    }
}

void dfs2(int u, int topx){
    dfn[u] = ++num;
    w[num] = val[u];
    rev[num] = u;
    top[u] = topx;
    if(!son[u]) return;
    dfs2(son[u], topx);
    for(auto v : G[u]){
        if(v == father[u] || v == son[u]) continue;
        dfs2(v, v);
    }
}

//线段树

struct node{
    int l, r;
    int sum, tag;
}tree[N << 2];

void pushup(int k){
    int lc = k * 2;
    int rc = k * 2 + 1;
    tree[k].sum = tree[lc].sum + tree[rc].sum;
    tree[k].sum %= mod;
}

void add_tag(int k, int v){
    tree[k].sum = (tree[k].sum + (long long)(tree[k].r - tree[k].l + 1) * v % mod) % mod;
    tree[k].tag += v;
    tree[k].tag %= mod;
}

void pushdown(int k){
    int lc = k * 2;
    int rc = k * 2 + 1;
    if(tree[k].tag){
        add_tag(lc, tree[k].tag);
        add_tag(rc, tree[k].tag);
        tree[k].tag = 0;
    }
}

void build(int k, int l, int r){
    tree[k].l = l, tree[k].r = r;
    if(l == r){
        tree[k].sum = w[l];
        return;
    }
    int mid = (l + r) >> 1;
    int lc = k * 2;
    int rc = k * 2 + 1;
    build(lc, l, mid);
    build(rc, mid + 1, r);
    pushup(k);
}

void modify(int k, int l, int r, int v){
    if(tree[k].l >= l && tree[k].r <= r){
        add_tag(k, v);
        return;
    }
    pushdown(k);
    int mid = (tree[k].l + tree[k].r) >> 1;
    int lc = k * 2;
    int rc = k * 2 + 1;
    if(r <= mid) modify(lc, l, r, v);
    else if(l > mid) modify(rc, l, r, v);
    else modify(lc, l, mid, v), modify(rc, mid + 1, r, v);
    pushup(k);
}

int query(int k, int l, int r){
    if(tree[k].l >= l && tree[k].r <= r){
        return tree[k].sum % mod;
    }
    pushdown(k);
    int mid = (tree[k].l + tree[k].r) >> 1;
    int lc = k * 2;
    int rc = k * 2 + 1;
    if(r <= mid) return query(lc, l, r);
    else if(l > mid) return query(rc, l, r);
    else return (query(lc, l, mid) + query(rc, mid + 1, r)) % mod;
}

//具体函数

void add_in_path(int x, int y, int z){
    while(top[x] != top[y]){
        if(deep[top[x]] < deep[top[y]]) swap(x, y);
        modify(1, dfn[top[x]], dfn[x], z);
        x = father[top[x]];
    }
    if(deep[x] > deep[y]) swap(x, y);
    modify(1, dfn[x], dfn[y], z);
}

int query_in_path(int x, int y){
    int ans = 0;
    while(top[x] != top[y]){
        if(deep[top[x]] < deep[top[y]]) swap(x, y);
        (ans += query(1, dfn[top[x]], dfn[x])) %= mod;
        x = father[top[x]];
    }
    if(deep[x] > deep[y]) swap(x, y);
    (ans += query(1, dfn[x], dfn[y])) %= mod;
    return ans;
}

void solve(){
    int n, m, r, p;
    cin >> n >> m >> r >> p;
    mod = p;
    for(int i = 1; i <= n; i++){
        cin >> val[i];
    }
    for(int i = 1; i < n; i++){
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    dfs1(r, 0);
    dfs2(r, r);
    //cout << siz[6] << ' ';
    build(1, 1, n);
    for(int i = 1; i <= m; i++){
        int op;
        cin >> op;
        if(op == 1){
            int x, y, z;
            cin >> x >> y >> z;
            z %= mod;
            add_in_path(x, y, z);
        }else if(op == 2){
            int x, y;
            cin >> x >> y;
            cout << query_in_path(x, y) << '\n';
        }else if(op == 3){
            int x, z;
            cin >> x >> z;
            z %= mod;
            modify(1, dfn[x], dfn[x] + siz[x] - 1, z);
        }else if(op == 4){
            int x;
            cin >> x;
            cout << query(1, dfn[x], dfn[x] + siz[x] - 1) << '\n';
        }
    }
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    //cin >> t;
    while(t--){
        solve();
    }
    return 0;
}
```

---

## 作者：粥2414 (赞：2)

# 前置知识
- dfs 序。
- 线段树或树状数组。
- 图的存储。
- lca 相关知识。（不一定要会求但一定要了解）
# 树链剖分
看到这题，一眼~~树状数组模板题~~。然而是树上，那怎么办？

有没有一种算法可以将在树上的问题转换为序列上的问题呢？

有的兄弟，有的，那就是**树链剖分**。
## 简介
树链剖分就是通过将树剖分成一条一条的链，将其转化为序列问题的算法。有了树链剖分，就可以将很多原本只能运用于序列上的数据结构用于树上。
## 用处
先说明用处，方便理解。

首先需要明确几个概念：

- 重儿子：一个节点的儿子中，拥有最大子树的那个叫做重儿子，其余的是轻儿子。如果子树大小相同，取任意**一个**即可。
- 重链：由根节点（可以是子树根节点）的重子孙组成的一条链。特别地，单独的一个节点也可视为重链。
- 轻边，轻链的定义类似。

如图所示的即为一棵树的重链：

![重链](https://cdn.luogu.com.cn/upload/image_hosting/8zzt51uw.png)

划分的方式可能不唯一。

树链剖分可以很方便地解决两点间简单路径上的操作。

对于本题的操作 $3$、$4$，普通的 dfs 序便可解决，原理是 dfs 序保证一个节点的子树节点全在这个节点后面的一段连续区间，套个数据结构即可。

而对于前两个操作，普通 dfs 序就不行了。它没法保证两点间简单路径的连续性。这时就可以用树链剖分解决。
## 原理
树链剖分就是一种特殊的 dfs 序，它保证一个节点的子树，以及它所在的重链在一个连续的区间内。如果要操作的区间在一个重链内，那么直接操作即可；如果要操作的简单路径跨了多个重链，那么可以先修改当前重链，然后跳到当前重链顶部的父节点，循环往复，直到两个节点的 $lca$。
## 实现
其代码主体就是两个 dfs。

第一个 dfs 预处理出节点 $i$ 的父节点 $fa_i$，深度 $dep_i$，子树大小 $siz_i$，重儿子 $son_i$ 

### 代码

```cpp
 void dfs1(ll now, ll fat) {
	fa[now] = fat;
	dep[now] = dep[fat] + 1;
	siz[now] = 1;
	for (rint i = h[now]; i; i = lian[i].ne) {
		ll to = lian[i].to;
		if (to != fat) {
			dfs1(to, now);
			siz[now] += siz[to];
			if (siz[to] > siz[son[now]])son[now] = to;
		}
	}
}
```
---

第二个 dfs 预处理出每个节点对应的 dfs 序和 dfs 序对应的初值，以及一条重链的顶端节点编号。

如何保证重链在一起？优先递归重儿子即可。
### 代码
```cpp
 void dfs2(ll now, ll ftop) {//ftop 为重链顶端
	dfss[now] = ++dcnt;
	dv[dfss[now]] = v[now];
	top[now] = ftop;
	if (son[now])dfs2(son[now], ftop);//优先递归重儿子，在一条重链上，顶端相同。
	for (rint i = h[now]; i; i = lian[i].ne) {
		ll to = lian[i].to;
		if (to != fa[now] && to != son[now])dfs2(to, to);//新的重链，顶端为它自己
	}
}
```
# 具体操作
这样，树链剖分就完成了。接下来是数据结构部分了。

对于节点 $x$ 子树上的操作，只需要对区间 $[x,x+siz_x-1]$ 进行操作即可。

对于点 $x,y$ 之间简单路径上的操作，则要麻烦一点。步骤如下：

1. 判断两个点是否在一条重链上，即重链顶部是否相等。如果相等，修改区间 $[x,y]$ 即可；否则，进行第二步。
2. 如果 $dep_{top_x}<dep_{top_y}$，那么交换 $x,y$。这一步是保证向上跳时不会跳过 $lca$。
3. 修改区间 $[top_x,x]$，然后令 $x\gets fa_{top_x}$。注意顶端节点的 dfs 序较小，要在前面。
4. 回到步骤 $1$。
## 正确性证明
这样会不会修改多余的节点呢？答案是否定的。

我们假设节点 $y$ 在 $lca$ 所在重链，且点 $x$ 不在，那么 $x$ 一定在 $lca$ 的某个轻儿子的子树上。由于此时 $x$ 所在重链顶端高度一定低于 $y$，所以一定优先让 $x$ 向上跳，最终会跳到 $lca$ 某个轻儿子为顶端的重链上，然后 $x$ 就会变成 $lca$，直接修改，不会影响其他节点。

如果两个儿子都不在 $lca$ 所在重链，那么在向上跳的过程中，必然会有一个儿子先到达 $lca$ 所在重链，回归上文情况。
# 复杂度分析
两遍 dfs 复杂度 $O(n)$，树状数组或线段树复杂度 $O(n\log n)$，向上跳的过程中每穿越一条树链，那么就相当于经过了一个节点的轻边，由于重儿子的子树大小一定大于等于它，所以其子树大小至少会变为原来的二倍，所以最坏时间复杂度 $O(\log n)$，实际可能更小。

总复杂度 $O(n\log^2 n)$。
# 完整代码
线段树在我校 oj 上~~由于评测机太烂~~需要严重卡常，所以我使用树状数组进行维护，洛谷上两者皆可正常通过。
```cpp
//#define LH
#include<bits/stdc++.h>
using namespace std;
#define max(a,b) ((a>b)?a:b)
#define min(a,b) ((a<b)?a:b)
#define ll long long
#define rint register int
namespace DHW {
#ifdef LH
	char buf[1 << 20],*p1 = buf,*p2 = buf;
	#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?EOF:*p1++);
#endif
	 ll read() {
		ll f = 1, x = 0;
		char ch = getchar();
		while (ch < 48 || ch > 57) {
			if (ch == '-')f = -1;
			ch = getchar();
		}
		while (ch >= 48 && ch <= 57) {
			x = x * 10 + ch - 48;
			ch = getchar();
		}
		return x * f;
	}
	 void write(ll x) {
		if (x < 0) {
			putchar('-');
			x = -x;
		}
		if (x > 9)write(x / 10);
		putchar(x % 10 + 48);
	}
#ifdef LH
	#undef getchar
#endif
} using namespace DHW;
ll qp(ll a, ll b) {
	ll ans = 1;
	while (b) {
		if (b & 1)ans *= a;
		a *= a;
		b >>= 1;
	}
	return ans;
}
const ll N = 1e5+9;
ll n, m, r, p;
ll tr1[N], tr2[N];
struct LIAN {
	ll to, ne;
} lian[N * 2];
ll h[N], lcnt;
ll dep[N], fa[N], dfss[N], son[N], dcnt, top[N], siz[N];
ll v[N], dv[N];
 void add(ll u, ll v) {
	lian[++lcnt].to = v;
	lian[lcnt].ne = h[u];
	h[u] = lcnt;
}
 ll lowbit(ll x) {
	return x & (-x);
}
 void tr_add(ll x, ll v) {
	rint i = x;
	while (i <= n) {
		tr1[i] = (tr1[i] + v)  ;
		tr2[i] = (tr2[i] + (v * x)  )  ;
		i += lowbit(i);
//		cout<<i<<' ';
	}
}
 ll tr_qu(ll r) {
	ll i = r, ans = 0;
	while (i > 0) {
		ans += (((r + 1) * tr1[i])   - tr2[i]  )  ;
		i -= lowbit(i);
	}
	return ans  ;
}
 void dfs1(ll now, ll fat) {
	fa[now] = fat;
	dep[now] = dep[fat] + 1;
	siz[now] = 1;
	for (rint i = h[now]; i; i = lian[i].ne) {
		ll to = lian[i].to;
		if (to != fat) {
			dfs1(to, now);
			siz[now] += siz[to];
			if (siz[to] > siz[son[now]])son[now] = to;
		}
	}
}
 void dfs2(ll now, ll ftop) {
//	if(now==4)cout<<"dhwzs";
	dfss[now] = ++dcnt;
	dv[dfss[now]] = v[now];
	top[now] = ftop;
	if (son[now])dfs2(son[now], ftop);
	for (rint i = h[now]; i; i = lian[i].ne) {
		ll to = lian[i].to;
		if (to != fa[now] && to != son[now])dfs2(to, to);
	}
}
 void do_add1(ll x, ll y, ll z) { //操作1
	while (top[x] != top[y]) {
		if (dep[top[x]] < dep[top[y]])swap(x, y);
		tr_add(dfss[top[x]], z);
		tr_add(dfss[x] + 1, -z);
		x = fa[top[x]];
	}
	if (dep[x] < dep[y])swap(x, y);
	tr_add(dfss[y], z);
	tr_add(dfss[x] + 1, -z);
}
 void do_add3(ll x, ll z) { //操作3
//	cout<<x<<' '<<dfss[x]<<endl;
	tr_add(dfss[x], z);
	tr_add(dfss[x] + siz[x], -z);
}
 ll do_qu2(ll x, ll y) { //操作2
	ll ans = 0;
	while (top[x] != top[y]) {
		if (dep[top[x]] < dep[top[y]])swap(x, y);
		ans += (tr_qu(dfss[x])  - tr_qu(dfss[top[x]] - 1) )  ;
		ans %= p;
		x = fa[top[x]];
	}
	if (dep[x] < dep[y])swap(x, y);
	ans += (tr_qu(dfss[x])  - tr_qu(dfss[y]-1) );
	return ans;
}
 ll do_qu4(ll x) { //操作4
	return (tr_qu(dfss[x] + siz[x] - 1)   - tr_qu(dfss[x] - 1)  )  ;
}
void dfs3(ll now, ll fat) {
	cout<<dfss[now]<<' '<<v[now]<<' '<<siz[now]<<' '<<now<<endl; 
	for (rint i = h[now]; i; i = lian[i].ne) {
		ll to = lian[i].to;
		if (to != fat) {
			dfs3(to, now);
		}
	}
}
int main() {
	n = read();
	m = read();
	r = read();
	p = read();
	for (rint i = 1; i <= n; i++) {
		v[i] = read();
	}
	for (rint i = 1; i < n; i++) {
		ll u = read(), v = read();
		add(u, v);
		add(v, u);
	}
	dfs1(r, 0);
	dfs2(r, r);
	for (rint i = 1; i <= n; i++) {
		tr_add(i, dv[i]);
		tr_add(i + 1, -dv[i]);
	}
	for (rint i = 1; i <= m; i++) {
		ll op = read(), x = read();
		if (op == 1) {
			ll y = read(), z = read();
			do_add1(x, y, z);
		}
		if (op == 2) {
			ll y = read();
			write(do_qu2(x, y)%p);
			putchar('\n');
		}
		if (op == 3) {
			ll z = read();
			do_add3(x, z);
		}
		if (op == 4) {
			write(do_qu4(x)%p);
			putchar('\n');
		}
	}
//	dfs3(r,0);
//	for(int i=1;i<=n+1;i++){
//		cout<<tr1[i]<<' '<<tr2[i]<<endl;
//	}
	return 0;
}
```
# 其他运用
由上文两点向上跳的过程可以很显然地看出，树剖还可用于求 $lca$，常数貌似是比朴素的倍增求 $lca$ 要小的。（~~黄题蓝做~~，不再赘述）

---

## 作者：Alexxtl (赞：1)

## 一、算法介绍：

树链剖分是一个在信息学竞赛中使用很频繁的算法，其通过将树分割成若干条链的形式，维护树上路径的信息。树链剖分由很多种形式，如重链剖分，长链剖分以及实链剖分等，此处只涉及重链剖分。

重链剖分可以将树上任意一条路径划分成不超过 $\log n$ 条连续的链，每条链上的点深度互不相同。

重链剖分能保证划分出的每条链上的节点 dfs 序连续，因此可以使用线段树等对序列进行维护的数据结构来维护树上路径的信息。除此之外，重链剖分还经常用于实现其他功能，如求最近公共祖先等。

### 定义：

- 重子节点：对于每个非叶节点，定义其子节点中**子树最大**的子节点（如有相同任取起义）为重子节点。

- 轻子节点：对于每个非叶节点，定义其子节点中**除重子节点外**其余所有子节点为轻子节点。

- 重边：对于每个非叶节点，定义其与其**重子节点**之间的边为重边。

- 轻边：对于每个非叶节点，定义其与其**轻子节点**之间的边为轻边。

- 重链：定义若干条**首尾衔接**的**重边**构成的链为重链。落单的节点也视为重链。

**如图**：

![](https://oi-wiki.org/graph/images/hld.png)

（图片来自 **OI Wiki**）

## 二、代码实现：

树链剖分的实现由两个 **dfs** 构成。

第一个 dfs 记录每个节点的**父节点**、**深度**、**子树大小**、**重子节点**，第二个 dfs 记录每个节点所在链的**顶端**，**dfs 序**以及 dfs 序所对应的节点的**编号**。
以下为代码实现，细节包含在注释中：

```cpp
int fa[N],top[N],son[N],size[N],deep[N],w[N],dfn[N],cnt_tree;
void dfs1(int x){
	size[x]=1;//标记每个节点的子树大小，初始为 1，因为包含节点本身
	int maxson=-1;//记录以重子节点为根的子树大小
	for(int i=head[x];i;i=t[i].next){
		int y=t[i].ver;
		if(y==fa[x]) continue;
		deep[y]=deep[x]+1,fa[y]=x,dfs1(y),size[x]+=size[y];//更新深度、子树大小、父节点等信息
		if(maxson<size[y]) maxson=size[y],son[x]=y;//维护重子节点
	}
}

void dfs2(int x){
	dfn[x]=++cnt_tree,w[cnt_tree]=a[x];//标记新编号并赋值到新数组中
	if(son[x]) top[son[x]]=top[x],dfs2(son[x]);//先处理重子节点
	for(int i=head[x];i;i=t[i].next){//按轻子节点递归处理
		int y=t[i].ver;
		if(y==fa[x]||y==son[x]) continue;
		top[y]=y,dfs2(y);//每个轻子节点有一条以其为起始的链
	}
}
```

## 三、问题解决

说完了树链剖分，是时候回到本题了。

容易发现，每一条重链和每一个子树中的节点的编号都是**连续**的。问题要求我们处理**路径上**与**子树上**的修改与查询，我们分成两类问题讨论：

- **路径上**：

  类似于**倍增法求最近公共祖先**的思想，两个节点不断向上跳，跳到其**所在重链的顶端的父节点**，每次处理所在**链顶端深度更深的节点**，直到跳到**同一条重链**上为止，沿途对每一条重链用**线段树**维护区间修改与查询。时间复杂度 $O(\log^2 n)$。

- **子树上**：

  由于子树的 dfs 序连续，修改或查询一个节点的子树只用处理这一段连续的 dfs 序区间，**线段树**维护即可。时间复杂度 $O(\log n)$。

### 正确性证明：

至于为什么这么做是对的，下面提供证明：

令 $x$ 和 $y$ 表示两个节点，$z$ 表示 $x$ 和 $y$ 的最近公共祖先，假设 $x$ 在 $z$ 所在的重链上且 $y$ 不在，则 $y$ 一定在 $z$ 的轻子节点的子树上，显然 $y$ 所在的重链深度一定更深，所以会优先跳 $y$，直到 $y$ 跳到 $z$ 为止。如都不在 $z$ 所在的重链上，上跳时总有一个会跳到 $z$ 所在的重链上。当二者都在该链上时，直接区间维护即可。如此，显然不会更新多余的节点，也不会有节点被漏掉。

### 时间复杂度：

#### 1.重链数量

从任意节点到根的路径上，轻边的数量不超过 $\log n$ 条，这是因为在每次经过轻边时，子树的大小至少减半，显然最多经过 $\log n$ 条轻边。因此，每个路径拆解后重链不会超过 $\log n$ 条。

#### 2.单次操作复杂度分析

**路径上操作**：每条重链的区间操作通过线段树实现，复杂度为 $O(\log n)$。最多会经过 $\log n$ 条重链，故总时间复杂度为 $O(\log n) × O(\log n) = O(\log^2 n)$。

**子树上操作**：该操作只需进行一次线段树的区间修改或查询，复杂度为 $O(\log n)$。

## 四、通过代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

#define ll long long
#define ls(p) p<<1
#define rs(p) p<<1|1
const int N=1e5+10;

namespace IO{//快读快写
	inline int read(){
		int x=0,f=1;
		char ch=getchar();
		while(ch<'0'||ch>'9'){
			if(ch=='-') f=-1;
			ch=getchar();
		}
		while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
		return x*f;
	}

	inline void write(int x){
		if(x<0){
			putchar('-');
			x=-x;
		}
		if(x>9) write(x/10);
		putchar(x%10+'0');
	}
}

using namespace IO;

namespace code{
	int n,m,R,P,a[N];
	
	int head[N],tot;
	
	struct edge{//链式前向星存图
		int ver,next;
	}e[N<<1];
	
	void add(int x,int y){//加边
		e[++tot].ver=y,e[tot].next=head[x],head[x]=tot;
	}
	
	int fa[N],son[N],deep[N],size[N],w[N],dfn[N],top[N],cnt;
	
	void dfs1(int x){//树剖预处理
		size[x]=1;
		int max_son=-1;
		for(int i=head[x];i;i=e[i].next){
			int y=e[i].ver;
			if(y==fa[x]) continue;
			fa[y]=x,deep[y]=deep[x]+1;
			dfs1(y);
			size[x]+=size[y];
			if(size[y]>max_son) max_son=size[y],son[x]=y;
		}
	}
	
	void dfs2(int x,int fr){
		dfn[x]=++cnt,w[cnt]=a[x],top[x]=fr;
		if(son[x]) dfs2(son[x],fr);
		for(int i=head[x];i;i=e[i].next){
			int y=e[i].ver;
			if(y==fa[x]||y==son[x]) continue;
			dfs2(y,y);
		}
	}
	
	struct segment_tree{//线段树
		struct node{
			ll sum,lazy;
		}t[N<<2];
		
		void push_up(int p){
			t[p].sum=(t[ls(p)].sum+t[rs(p)].sum)%P;
		}
		
		void push_down(int p,int l,int r){
			int mid=(l+r)>>1;
			t[ls(p)].sum=(t[ls(p)].sum+t[p].lazy*(mid-l+1))%P,t[ls(p)].lazy=(t[ls(p)].lazy+t[p].lazy)%P;
			t[rs(p)].sum=(t[rs(p)].sum+t[p].lazy*(r-mid))%P,t[rs(p)].lazy=(t[rs(p)].lazy+t[p].lazy)%P;
			t[p].lazy=0;
		}
		
		void build(int p,int l,int r){
			if(l==r) return t[p].sum=w[l]%P,void();
			int mid=(l+r)>>1;
			build(ls(p),l,mid),build(rs(p),mid+1,r);
			push_up(p);
		}
		
		void add(int p,int l,int r,int al,int ar,ll k){
			if(al<=l&&r<=ar) return t[p].sum=((ll)t[p].sum+k*(r-l+1))%P,t[p].lazy=((ll)t[p].lazy+k)%P,void();
			int mid=(l+r)>>1;
			push_down(p,l,r);
			if(al<=mid) add(ls(p),l,mid,al,ar,k);
			if(ar>mid) add(rs(p),mid+1,r,al,ar,k);
			push_up(p);
		}
		
		ll query_sum(int p,int l,int r,int ql,int qr){
			if(ql<=l&&r<=qr) return t[p].sum;
			ll mid=(l+r)>>1,ret=0;
			push_down(p,l,r);
			if(ql<=mid) ret=((ll)ret+query_sum(ls(p),l,mid,ql,qr))%P;
			if(qr>mid) ret=((ll)ret+query_sum(rs(p),mid+1,r,ql,qr))%P;
			return ret;
		}
	}t;
	
	void solve1(int x,int y,int z){//路径上修改
		while(top[x]!=top[y]){
			if(deep[top[x]]<deep[top[y]]) swap(x,y);
			t.add(1,1,n,dfn[top[x]],dfn[x],z),x=fa[top[x]];
		}
		if(deep[x]>deep[y]) swap(x,y);
		t.add(1,1,n,dfn[x],dfn[y],z);
	}
	
	void solve2(int x,int y){//路径上查询
		int ret=0;
		while(top[x]!=top[y]){
			if(deep[top[x]]<deep[top[y]]) swap(x,y);
			ret=((ll)ret+t.query_sum(1,1,n,dfn[top[x]],dfn[x]))%P,x=fa[top[x]];
		}
		if(deep[x]>deep[y]) swap(x,y);
		ret=(ret+t.query_sum(1,1,n,dfn[x],dfn[y]))%P;
		write(ret),putchar('\n');
	}
	
	void solve3(int x,int z){//子树上修改
		t.add(1,1,n,dfn[x],dfn[x]+size[x]-1,z);
	}
	
	void solve4(int x){//子树上查询
		write(t.query_sum(1,1,n,dfn[x],dfn[x]+size[x]-1)),putchar('\n');
	}

	void solve(){
		n=read(),m=read(),R=read(),P=read();
		for(int i=1;i<=n;i++) a[i]=read();
		for(int i=1;i<n;i++){
			int x=read(),y=read();
			add(x,y);
			add(y,x);
		}
		dfs1(R),dfs2(R,R),t.build(1,1,n);
		while(m--){
			int op=read(),x=read(),y,z;
			if(op==1) y=read(),z=read(),solve1(x,y,z);
			else if(op==2) y=read(),solve2(x,y);
			else if(op==3) z=read(),solve3(x,z);
			else solve4(x);
		}
	}
}

int main(){
	code::solve();
	return 0;
}
```

---


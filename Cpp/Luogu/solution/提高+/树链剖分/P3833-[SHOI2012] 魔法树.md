# [SHOI2012] 魔法树

## 题目背景

SHOI2012 D2T3


## 题目描述

Harry Potter 新学了一种魔法：可以改变树上的果子个数。满心欢喜的他找到了一个巨大的果树，来试验他的新法术。

这棵果树共有 $N$ 个节点，其中节点 $0$ 是根节点，每个节点 $u$ 的父亲记为 $fa[u]$，保证有 $fa[u] < u$ 。初始时，这棵果树上的果子都被 Dumbledore 用魔法清除掉了，所以这个果树的每个节点上都没有果子（即 $0$ 个果子）。

不幸的是，Harry 的法术学得不到位，只能对树上一段路径的节点上的果子个数统一增加一定的数量。也就是说，Harry 的魔法可以这样描述：`A u v d` 。表示将点 $u$ 和 $v$ 之间的路径上的所有节点的果子个数都加上 $d$。

接下来，为了方便检验 Harry 的魔法是否成功，你需要告诉他在释放魔法的过程中的一些有关果树的信息：`Q u`。表示当前果树中，以点 $u$ 为根的子树中，总共有多少个果子？


## 样例 #1

### 输入

```
4
0 1
1 2
2 3
4
A 1 3 1
Q 0
Q 1
Q 2```

### 输出

```
3
3
2```

# 题解

## 作者：chen_zhe (赞：31)

前置题目：P3384

这道题目是一个模板题（省选考模板？）

作为一个 STL 的忠实拥护者，怎么能只有数组写链式前向星的题解呢？

这道题的数据还是比较水的，因此有两种做法。

第一种做法：倍增跳 LCA，然后用树状数组或者线段树维护一下子树和链就可以了

时间复杂度 $O(n \log n)$，常数较大

（其实数据出好一点这个就真的不行了，不信用这种方法做 P3384）

第二种做法：树链剖分

在这里顺便说一下树链剖分：

树链剖分是把一个树分成若干条链，最常用的是轻重链剖分。一个节点 $u$ 的重链所连接的节点 $v$，有一个特征，就是 $v$ 的子树是最大的，其他的边全都是轻链。通过一些处理（两次dfs）可以求出一个节点的父亲、深度和在线段树上的 $id$，那么就可以很方便地做这道题目了。

时间复杂度 $O(n \log^2 n)$ 常数较小，如果把线段树改成树状数组就最好了


我这里的代码对于输入的数据做了处理，即每个读入的节点的编号加 $1$，当然不这样处理也可以，把第一次处理时的 $fa$ 变成一个很大的数，比如 $n+100$ 之类的。不过一般的题目数据不会卡的。

然后再介绍一个小技巧

```cpp
char c;
scanf("%s",&c);
```
可以有效地去除空格


好了代码如下：

```cpp
#include <iostream>
#include <cstdio>
#include <vector>

using namespace std;

int n,m,r,father[100050],depth[100050],size[100050],son[100050],top[100050],ide[100050],rid[100050],cnt=0;

long long val[100050],p;

vector <int> graph[100050];

struct SegTree
{
    int left,right;
    long long value,tag;
}t[500050];

void dfs1(int u,int fa)
{
    father[u]=fa;
    depth[u]=depth[fa]+1;
    size[u]=1;
    for (int i=0;i<graph[u].size();i++)
    {
        int v=graph[u][i];
        if (v!=fa)
        {
            dfs1(v,u);
            size[u]+=size[v];
            if (size[v]>size[son[u]])
                son[u]=v;
        }
    }
}

void dfs2(int now,int fir)
{
    cnt++;
    top[now]=fir;
    ide[now]=cnt;
    rid[ide[now]]=now;
    if (!son[now]) 
        return;
    dfs2(son[now],fir);
    for (int i=0;i<graph[now].size();i++)
    {
        int v=graph[now][i];
        if (v!=father[now] && v!=son[now])
            dfs2(v,v);
    }
}

void Push_Up(int id)
{
    t[id].value=t[id<<1].value+t[id<<1|1].value;
}

void Push_Down(int id)
{
    t[id<<1].tag+=t[id].tag;
    t[id<<1|1].tag+=t[id].tag;
    t[id<<1].value+=t[id].tag*(t[id<<1].right-t[id<<1].left+1);
    t[id<<1|1].value+=t[id].tag*(t[id<<1|1].right-t[id<<1|1].left+1);
    t[id].tag=0;
}

void Build(int id,int left,int right)
{
    t[id].left=left;
    t[id].right=right;
    if (left==right)
    {
        t[id].value=val[rid[left]];
        return;
    }
    int mid=(left+right)>>1;
    Build(id<<1,left,mid);
    Build(id<<1|1,mid+1,right);
    Push_Up(id);
}

void Update(int id,int left,int right,long long value)
{
    if (t[id].left>=left && t[id].right<=right)
    {
        t[id].tag+=value;
        t[id].value+=value*(t[id].right-t[id].left+1);
        return;
    }
    Push_Down(id);
    int mid=(t[id].left+t[id].right)>>1;
    if (right<=mid)
        Update(id<<1,left,right,value);
    else if (left>mid)
        Update(id<<1|1,left,right,value);
    else
    {
        Update(id<<1,left,mid,value);
        Update(id<<1|1,mid+1,right,value); 
    }
    Push_Up(id);
}

long long Query(int id,int left,int right)
{
    if (t[id].left>=left && t[id].right<=right)
        return t[id].value;
    else
    {
        int mid=(t[id].left+t[id].right)>>1;
        Push_Down(id);
        if (right<=mid)
            return Query(id<<1,left,right);
        if (left>mid)
            return Query(id<<1|1,left,right);
        else
            return Query(id<<1,left,mid)+Query(id<<1|1,mid+1,right);
    }
}

void SubTreeChange(int id,int value)
{
    int x=ide[id];
    int y=ide[id]+size[id]-1;
    Update(1,x,y,value);
}

long long SubTreeQuery(int id)
{
    int x=ide[id];
    int y=ide[id]+size[id]-1;
    return Query(1,x,y);
}

void LinkChange(int x,int y,int value)
{
    int tx=top[x];
    int ty=top[y];
    while (tx!=ty)
    {
        if (depth[tx]<depth[ty])
        {
            swap(x,y);
            swap(tx,ty);
        }
        Update(1,ide[tx],ide[x],value);
        x=father[tx];
        tx=top[x];
    }
    if (depth[x]>depth[y])
        swap(x,y);
    Update(1,ide[x],ide[y],value);
}

long long LinkQuery(int x,int y)
{
    int tx=top[x];
    int ty=top[y];
    long long ans=0;
    while (tx!=ty)
    {
        if (depth[tx]<depth[ty])
        {
            swap(x,y);
            swap(tx,ty);
        }
        ans+=Query(1,ide[tx],ide[x]);
        x=father[tx];
        tx=top[x];
    }
    if (depth[x]>depth[y])
        swap(x,y);
    ans+=Query(1,ide[x],ide[y]);
    return ans;
}

int main()
{
    scanf("%d",&n);
    for (int i=1;i<n;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        graph[u+1].push_back(v+1);
        graph[v+1].push_back(u+1);
    }
    dfs1(1,0);
    dfs2(1,1);
    scanf("%d",&m);
    Build(1,1,cnt);
    for (int i=1;i<=m;i++)
    {
        int u,v,d;
        char c;
        scanf("%s",&c);
        if (c=='A')
        {
            scanf("%d%d%d",&u,&v,&d);
            LinkChange(u+1,v+1,d);
        }
        else
        {
            scanf("%d",&u);
            printf("%lld\n",SubTreeQuery(u+1));
        }
    }
    return 0;
}
```

倍增+线段树做法

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstdlib>
#include <cstring>
#include <vector>

using namespace std;

struct Seg_Tree
{
    int left,right,add;
    long long value;
}son[400050];

int n,m;

vector <int> graph[100050];

int fa[100050][16],size[100050],depth[100050];

int Time,pos[100050],belong[100050];

long long delta[500050];

bool vis[100050];

int read()
{
    int w=0,c=1; 
    char ch=getchar();
    while (ch<'0' || ch>'9')
    {
        if (ch=='-') 
            c=-1;
        ch=getchar();
    }
    while (ch>='0' && ch<='9')
    {
        w=w*10+ch-'0';
        ch=getchar();
    }
    return w*c;
}

void Build(int id,int left,int right)
{
    son[id].value=son[id].add=0;
    son[id].left=left;
    son[id].right=right;
    if (left==right)
        return;
    Build(id<<1,left,(left+right)>>1);
    Build(id<<1|1,((left+right)>>1)+1,right);
    son[id].value=son[id<<1].value+son[id<<1|1].value;
}

void Change_delta(int id,long long value,int left,int right)
{
    son[id].value+=value*(right-left+1);
    delta[id]+=value;
}

void Push_Up(int id)
{
    son[id].value=son[id<<1].value+son[id<<1|1].value;
}

void Push_Down(int id,int left,int right)
{
    int mid=(left+right)/2;
    Change_delta(id<<1,delta[id],left,mid);
    Change_delta(id<<1|1,delta[id],mid+1,right);
    delta[id]=0;
}

void Update(int id,int left,int right,long long value,int pos1,int pos2)
{
    int mid=(left+right)/2;
    //cout << id << " " << left << " " << right << " " << value << " " << pos1 << " " << pos2 << endl;
    //system("pause");
    if (pos1<=left && pos2>=right)
    {
        Change_delta(id,value,left,right);
        return;
    }
    Push_Down(id,left,right);
    if (pos1<=mid)
        Update(id<<1,left,mid,value,pos1,pos2);
    if (pos2>mid)
        Update(id<<1|1,mid+1,right,value,pos1,pos2);
    Push_Up(id);
}

void getlca(int u)
{
    vis[u]=true;
    size[u]=1;
    for (int i=1;i<=16;i++)
    {
        if (depth[u]<(1<<i))
            break;
        fa[u][i]=fa[fa[u][i-1]][i-1];
    }
    for (int i=0;i<graph[u].size();i++)
    {
        int v=graph[u][i];
        if (vis[v])
            continue;
        depth[v]=depth[u]+1;
        fa[v][0]=u;
        getlca(v);
        size[u]+=size[v];
    }
}

void dfs(int k,int num)
{
    int x=0;
    //cout << k << " " << num << endl;
    //system("pause");
    Time++;
    pos[k]=Time;
    belong[k]=num;
    for (int i=0;i<graph[k].size();i++)
    {
        int v=graph[k][i];
        if (depth[v]>depth[k] && size[v]>size[x])
            x=v;
    }
    if (x==0)
        return;
    dfs(x,num);
    for (int i=0;i<graph[k].size();i++)
    {
        int v=graph[k][i];
        if (depth[v]>depth[k] && x!=v)
            dfs(v,v);
    }
}

void Insert(int x,int y,long long z)
{
    for (;belong[x]!=belong[y];x=fa[belong[x]][0])
    {
        //cout << x << " " << y << endl;
        if (depth[belong[x]]<depth[belong[y]])
            swap(x,y);
        Update(1,1,n,z,pos[belong[x]],pos[x]);
    }
    if (depth[x]<depth[y])
        swap(x,y);
    //cout << x << " " << y << " " << pos[x] << " " << pos[y] << endl;
    Update(1,1,n,z,pos[y],pos[x]);
}

long long Query(int id,int left,int right,int pos1,int pos2)
{
    int mid=(left+right)/2;
    long long ans=0;
    //cout << id << " " << left << " " << right << " " << son[id].value << " " << pos1 << " " << pos2 << endl;
    if (pos1<=left && pos2>=right)
        return son[id].value;
    Push_Down(id,left,right);
    if (pos1<=mid)
        ans+=Query(id<<1,left,mid,pos1,pos2);
    if (pos2>mid)
        ans+=Query(id<<1|1,mid+1,right,pos1,pos2);
    Push_Up(id);
    return ans;
}

int main()
{
    //freopen("tree.in","r",stdin);
    //freopen("tree.out","w",stdout);
    scanf("%d",&n);
    for (int i=1;i<n;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        u++;
        v++;
        graph[u].push_back(v);
        graph[v].push_back(u);
    }
    getlca(1);
    dfs(1,1);
    Build(1,1,n);
    m=read();
    //for (int i=1;i<=n;i++)
    //    cout << belong[i] << endl;
    for (int i=1;i<=m;i++)
    {
        char chr;
        int x;
        scanf("%s",&chr);
        scanf("%d",&x);
        x++;
        if (chr=='A')
        {
            int y,z;
            scanf("%d%d",&y,&z);
            y++;
            Insert(x,y,z);
        }
        if (chr=='Q')
            printf("%lld\n",Query(1,1,n,pos[x],pos[x]+size[x]-1));
    }
    return 0;
}

/*4
0 1
1 2
2 3
4
A 1 3 1
Q 0
Q 1
Q 2
*/
```
**实测倍增比树链剖分慢1000ms**


---

## 作者：Lynkcat (赞：14)

这是本菜鸡第一次炸出[ chen_zhe ](https://www.luogu.com.cn/user/8457)，纪念一下555。

本来是想让[ chen_zhe ](https://www.luogu.com.cn/user/8457)大大修一下题面，结果[ chen_zhe ](https://www.luogu.com.cn/user/8457)大大不仅修改了题面，还直接改了难度（蓝掉绿）……

[帖子地址](https://www.luogu.com.cn/discuss/show/212175)

[ chen_zhe ](https://www.luogu.com.cn/user/8457)大大属实nb！！！

接下来进入正题，首先一看到这题你一定会想到树链剖分，并且还会不屑地说：切，这不就是模板题吗？！

然而我们这种不会树链剖分的菜鸡正在瑟瑟发抖……（没有歧视树链剖分的意思，当然建议大家去学树链剖分，本菜鸡也正在学习中）

这时候我们会想到一道类似的题：[[HAOI2015]树上操作](https://www.luogu.com.cn/problem/P3178)

在[[HAOI2015]树上操作](https://www.luogu.com.cn/problem/P3178)里，我们可以搞一个dfs序然后直接用线段树维护。

显然，我们这道题也可以这么做。

我们考虑用一种神奇的dfs序：[欧拉序](https://www.cnblogs.com/stxy-ferryman/p/7741970.html)

这个[欧拉序](https://www.cnblogs.com/stxy-ferryman/p/7741970.html)的有一个很好的性质：
>如果把每个点第一次出现记作 +，第二次出现记作 -，那么根节点到任意节点的权值和在欧拉序上对应一个前缀和。——摘自[YJZoier巨佬的题解](https://www.luogu.com.cn/blog/user31635/solution-p3178)

换句话说，如果把每个点第一次出现记作 +，第二次出现记作 -，那么任意节点到它的祖先的权值和在欧拉序上对应一段区间的和。

设一个点 $x$ 和它的祖先 $y$ ，那么树上 $x$ 到 $y$ 的权值和就是欧拉序上 $+x$ 到 $+y$ 的和

比如样例，[欧拉序](https://www.cnblogs.com/stxy-ferryman/p/7741970.html)是 $+0,+1,+2,+3,-3,-2,-1,-0$

那么我们看 $3$ 这个点，它的祖先中有 $1$ ，那么欧拉序上 $+1$ 到 $+3$ 部分的和即为树上 $1$ 到 $3$ 的和。

你可能会说：你这个例子不全面啊，样例只是个链啊。

其实很简单就能证明，如果 $y$ 还有别的子树，那么这些子树要么是还没有在这段欧拉序区间中出现过，要么是一个 $+$ 一个 $-$ 已经做完抵消了。接下来的节点同理。

那么我们可以得到一个很明确的做法：

1.预处理跑完欧拉序和 
$\operatorname{lca}$ 的预处理。

2.对于每个修改操作，将 $+\operatorname{lca}(x,y)$ 到 $+x$ 与 $+\operatorname{lca}(x,y)$ 到 $+y$ 部分进行处理，**然后千万千万别忘了将$+\operatorname{lca}(x,y)$处理！！！**。这东西显然可以用线段树维护。只不过要注意下 $+$ 和 $-$ 的处理。

3.查询操作，显然答案是 $+x$ 到 $-x$ 部分的和。

接下来放上代码：

```pascal
uses math;
type rec=record
     l,r:longint;
     sum,lz:int64;
     end;
     edge=record
     x,y,next:longint;
     end;
     ou=record
     z,u:longint;
     end;
var tree:array[0..1000000]of rec;
    zf,a,shang,xia,h,dep:array[0..1000000]of int64;
    e:array[0..1000000]of edge;
    ol:array[0..1000000]of ou;
    f:array[0..500000,0..20]of longint;
    cnt,cnt1,n,m,i,k:longint;
    a1,x,y:int64;
    ch,ch1:char;
procedure push_up(k:longint);
begin
  tree[k].sum:=tree[k*2].sum+tree[k*2+1].sum;
end;
procedure push_down(k:longint);
begin
  if tree[k].lz<>0 then
  begin
    tree[k*2].sum:=tree[k*2].sum+(zf[tree[k*2].r]-zf[tree[k*2].l-1])*tree[k].lz;
    tree[k*2].lz:=tree[k*2].lz+tree[k].lz;
    tree[k*2+1].sum:=tree[k*2+1].sum+(zf[tree[k*2+1].r]-zf[tree[k*2+1].l-1])*tree[k].lz;
    tree[k*2+1].lz:=tree[k*2+1].lz+tree[k].lz;
    tree[k].lz:=0;
  end;
end;
procedure build(k,l,r:longint);
begin
  tree[k].l:=l;tree[k].r:=r;
  if l=r then tree[k].sum:=ol[l].z*a[ol[l].u] else
  begin
    build(k*2,l,l+(r-l) div 2);
    build(k*2+1,l+(r-l) div 2+1,r);
    push_up(k);
  end;
end;
procedure xg1(k,l,r,a:longint);
var mid:longint;
begin
  if (tree[k].l=l)and(tree[k].r=r) then
  begin
    tree[k].sum:=tree[k].sum+(zf[r]-zf[l-1])*a;//只将
    tree[k].lz:=tree[k].lz+a;
    exit;
  end;
  mid:=tree[k].l+(tree[k].r-tree[k].l) div 2;
  push_down(k);
  if l<=mid then xg1(k*2,l,min(r,mid),a);
  if r>mid then xg1(k*2+1,max(mid+1,l),r,a);
  push_up(k);
end;
function cx(k,l,r:longint):int64;
var mid:longint;
begin
  if (tree[k].l=l)and(tree[k].r=r) then exit(tree[k].sum);
  mid:=tree[k].l+(tree[k].r-tree[k].l) div 2;
  push_down(k);
  cx:=0;
  if l<=mid then cx:=cx+cx(k*2,l,min(r,mid));
  if r>mid then cx:=cx+cx(k*2+1,max(mid+1,l),r);
  push_up(k);
end;
procedure ad(x,y:longint);
begin
  inc(cnt);
  e[cnt].x:=y;
  e[cnt].next:=h[x];
  h[x]:=cnt;
end;
procedure olx(now,fa:longint);
var t:longint;
begin
  inc(cnt1);
  ol[cnt1].z:=1;
  ol[cnt1].u:=now;
  xia[now]:=cnt1;
  t:=h[now];
  while t>0 do
  begin
    if e[t].x<>fa then olx(e[t].x,now);
    t:=e[t].next;
  end;
  inc(cnt1);
  ol[cnt1].z:=-1;
  ol[cnt1].u:=now;
  shang[now]:=cnt1;
end;
procedure dfs(k,l:longint);
var t,i:longint;
begin
  dep[k]:=dep[l]+1;
  f[k,0]:=l;
  for i:=1 to trunc(log2(dep[k])) do
    f[k,i]:=f[f[k,i-1],i-1];
  t:=h[k];
  while t>0 do
  begin
    if e[t].x<>l then dfs(e[t].x,k);
    t:=e[t].next;
  end;
end;
function lca(x,y:longint):longint;
var i,t:longint;
begin
  if dep[x]<dep[y] then
  begin
    t:=x;x:=y;y:=t;
  end;
  for i:=20 downto 0 do
  begin
    if dep[f[x,i]]>=dep[y] then x:=f[x,i];
    if x=y then exit(x);
  end;
  for i:=20 downto 0 do
    if f[x,i]<>f[y,i] then
    begin
      x:=f[x,i];
      y:=f[y,i];
    end;
  exit(f[x,0]);
end;
begin
  readln(n);
  for i:=1 to n-1 do
  begin
    readln(x,y);
    inc(x);inc(y);
    ad(x,y);
    ad(y,x);
  end;
  readln(m);
  olx(1,0);
  dfs(1,0);
  for i:=1 to 2*n do zf[i]:=zf[i-1]+ol[i].z;
  build(1,1,2*n);
  for i:=1 to m do
  begin
    read(ch,ch1);
    case ch of
    'A':begin
        readln(x,y,a1);inc(x);inc(y);
        xg1(1,xia[lca(x,y)],xia[x],a1);
        xg1(1,xia[lca(x,y)],xia[y],a1);
        xg1(1,xia[lca(x,y)],xia[lca(x,y)],-a1);
      end;
    'Q':begin
        readln(x);  inc(x);
        writeln(cx(1,xia[x],shang[x]));
      end;
    end;
  end;
end.

```
题解如有错误请指出，感激不尽！！！


---

## 作者：Soledad_S (赞：12)

[无耻地安利博客](https://www.cnblogs.com/soledadstar/p/11521865.html)

## 此题理论最优解
> 题目大意：路径修改，子树求和

明显是树剖的模板，但树剖的时间复杂度~~高~~达了优秀的$\Theta(Q \;log^2n)$，而实际上树上差分可以把时间复杂度降到$\Theta(Q \;logn)$。

设$tag[x]$为$1$到$x$的路径上全都加了这个值，~~显然~~对于$(x,y)$这条路径加$d$的操作可以看作
$$tag[x]+=d,tag[y]+=d,tag[LCA(x,y)]-=d,tag[prt[LCA(x,y)]]-=d$$

若查询以$root$为根的子树和，考虑子树内每个点$x$对答案的贡献是
$$(dep[x]-dep[root]+1)\times tag[x]$$
上式的意义是在$(x,root)$这条路径每个点都被加了$tag[x]$，对上式求和得到
$$\sum \;((dep[x]-dep[root]+1)\times tag[x])$$
$$\sum \;(dep[x]\times tag[x]-(dep[root]-1)\times tag[x])$$
$$\sum \;(dep[x]\times tag[x])-(dep[root]-1)\times\sum\;(tag[x])$$

两个树状数组维护$dep[x]\times tag[x]$和$tag[x]$就好了，因为在$DFS$序上子树是连续的区间，直接查询即可。

因为我的丑代码常数太大，把理论最优解跑还得不如树剖
```cpp
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
#define int long long
inline int read() {
	char ch;
	bool bj=0;
	while(!isdigit(ch=getchar()))
		bj|=(ch=='-');
	int res=ch^(3<<4);
	while(isdigit(ch=getchar()))
		res=(res<<1)+(res<<3)+(ch^(3<<4));
	return bj?-res:res;
}
void printnum(int x) {
	if(x>9)printnum(x/10);
	putchar(x%10+'0');
}
inline void print(int x,char ch) {
	if(x<0) {
		putchar('-');
		x=-x;
	}
	printnum(x);
	putchar(ch);
}
const int MAXN=1e5+5;
int n,m,h[MAXN],cnt;
int top[MAXN],size[MAXN],prt[MAXN],son[MAXN],dep[MAXN],tot,tid[MAXN];
struct Edge {
	int to,nxt;
} w[MAXN<<1];
int c1[MAXN],c2[MAXN];
inline void AddEdge(int x,int y) {
	w[++cnt].nxt=h[x];
	w[cnt].to=y;
	h[x]=cnt;
}
void DFS1(int x,int fa,int depth) {
	dep[x]=depth;
	prt[x]=fa;
	size[x]=1;
	for(int i=h[x]; i; i=w[i].nxt) {
		int v=w[i].to;
		if(v==fa)continue;
		DFS1(v,x,depth+1);
		if(size[v]>size[son[x]])son[x]=v;
		size[x]+=size[v];
	}
}
void DFS2(int x,int sp) {
	top[x]=sp;
	tid[x]=++tot;
	if(!son[x])return;
	DFS2(son[x],sp);
	for(int i=h[x]; i; i=w[i].nxt) {
		int v=w[i].to;
		if(v==prt[x]||v==son[x])continue;
		DFS2(v,v);
	}
}
inline int LCA(int x,int y) {
	while(top[x]^top[y]) {
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		x=prt[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	return x;
}
inline int lowbit(int x) {
	return x&(-x);
}
inline void update(int x,int d,int c[]) {
	if(!x)return;
	while(x<=n)c[x]+=d,x+=lowbit(x);
}
inline int query(int x,int c[]) {
	int sum=0;
	while(x)sum+=c[x],x-=lowbit(x);
	return sum;
}
inline void add(int x,int d) {
	update(tid[x],d,c1);
	update(tid[x],dep[x]*d,c2);
}
inline int ask(int x,int y,int c[]) {
	return query(y,c)-query(x-1,c);
}
signed main() {
	n=read();
	int x,y,d;
	for(int i=1; i<n; i++) {
		x=read()+1;
		y=read()+1;
		AddEdge(x,y);
		AddEdge(y,x);
	}
	DFS1(1,0,1);
	DFS2(1,1);
	m=read();
	char ch;
	while(m--) {
		do ch=getchar();
		while(ch!='A'&&ch!='Q');
		if(ch=='A') {
			x=read()+1;
			y=read()+1;
			d=read();
			int u=LCA(x,y);
			add(x,d);
			add(y,d);
			add(u,-d);
			add(prt[u],-d);
		} else {
			x=read()+1;
			int tmp=ask(tid[x],tid[x]+size[x]-1,c1);
			print(ask(tid[x],tid[x]+size[x]-1,c2)-tmp*(dep[x]-1),'\n');
		}
	}
	return 0;
}
```
~~为什么还是写了两个DFS？因为我要树剖求LCA~~

---

## 作者：Treaker (赞：6)

其实就是一个树剖的裸题。

注意，一颗子树内的dfs序是连续的，直接+size 查找就可以。

这里采用数组写法，指针写法详见[我博客](https://www.luogu.org/blog/Treaker/#)其他树剖题。

顺便推荐做一下模板[【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)  

完整代码如下：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int N = 100100;
int ls(int x) {return x << 1;}
int rs(int x) {return x << 1 | 1;}
int n , m , cnt;
int head[N] , top[N] , fa[N] , dfn[N] , id[N] , size[N] , dep[N] , hs[N];
long long sum[N << 2] , tag[N << 2];
char s[10];
struct Edge
{
	int to , nxt;
}e[N << 1];
void add(int from,int to)
{
	e[++cnt] = (Edge){to,head[from]};
	head[from] = cnt;
}
void get_tree(int now)
{
	size[now] = 1;
	for(int i = head[now] , to;i;i = e[i].nxt)
	{
		to = e[i].to;
		if(dep[to])	continue;
		dep[to] = dep[now] + 1;
		fa[to] = now;
		get_tree(to);
		size[now] = size[now] + size[to];
		if(size[to] > size[hs[now]])	hs[now] = to;
	}
}
void dfs(int now,int topfa)
{
	dfn[now] = ++cnt;
	id[cnt] = now;
	top[now] = topfa;
	if(hs[now])		dfs(hs[now],topfa);
	for(int i = head[now] , to;i;i = e[i].nxt)
	{
		to = e[i].to;
		if(to == fa[now] || to == hs[now])	continue;
		dfs(to,to);
	}
}
void push_down(int p,int l,int r)
{
	int mid = (l + r) >> 1;
	sum[ls(p)] = sum[ls(p)] + (mid - l + 1) * tag[p];
	sum[rs(p)] = sum[rs(p)] + (r - mid) * tag[p];
	tag[ls(p)] = tag[ls(p)] + tag[p];
	tag[rs(p)] = tag[rs(p)] + tag[p];
	tag[p] = 0;
}
void chenge(int p,int l,int r,int x,int y,int k)
{
	if(x <= l && r <= y)
	{
		sum[p] = sum[p] + (r - l + 1) * k;
		tag[p] = tag[p] + k;
		return ;
	}
	int mid = (l + r) >> 1;
	if(tag[p])	push_down(p,l,r);
	if(x <= mid)	chenge(ls(p),l,mid,x,y,k);
	if(y > mid)		chenge(rs(p),mid+1,r,x,y,k);
	sum[p] = sum[ls(p)] + sum[rs(p)];
}
void sec_add(int x,int y,int k)
{
	while(top[x] != top[y])
	{
		if(dep[top[x]] < dep[top[y]])	swap(x,y);
		chenge(1,1,n,dfn[top[x]],dfn[x],k);
		x = fa[top[x]];
	}
	if(dep[x] < dep[y])	swap(x,y);
	chenge(1,1,n,dfn[y],dfn[x],k);
}
long long query(int p,int l,int r,int x,int y)
{
	if(x <= l && r <= y)	return sum[p];
	int mid = (l + r) >> 1;
	long long res = 0;
	if(tag[p])	push_down(p,l,r);
	if(x <= mid)	res = res + query(ls(p),l,mid,x,y);
	if(y > mid)		res = res + query(rs(p),mid+1,r,x,y);
	return res;
}
int main()
{
	scanf("%d",&n);
	for(int i = 1 , x , y; i < n;i ++)
	{
		scanf("%d%d",&x,&y);
		x ++; y ++;
		add(x,y); add(y,x);
	}
	cnt = 0;  dep[1] = 1;
	get_tree(1);
	dfs(1,1);
	scanf("%d",&m);
	for(int i = 1 , u , v , d;i <= m;i ++)
	{
		scanf("%s%d",s,&u);
		u ++;
		if(s[0] == 'A')
		{
			scanf("%d%d",&v,&d);
			v ++;
			sec_add(u,v,d);
		}
		else	printf("%lld\n",query(1,1,n,dfn[u],dfn[u] + size[u] - 1));
	}
	return 0;
}
```


---

## 作者：Genius_Z (赞：6)

讲一下如何用$LCT$维护子树信息

众所周知，$LCT$强在维护链信息而弱在维护子树信息

但是维护子树信息也是可以做的，这样可以应对一些出题人比较毒瘤的情况（比如又加边删边还查询子树）

定义$vir$为某个节点虚子树的权值和，$tot$为总权值和。

当$access$导致虚实转换时，$vir$就要加上当前实儿子（将要成为虚儿子）的$tot$，减去将要成为实儿子的$tot$

这题因为初始没有点权，所以不需要在$link$的时候加上虚子树的值，但我这里为了指出在有权时的做法加上了。

还有就是注意有根树每次查找要$makeroot$原树的根。

Code： 

```cpp
#include <algorithm>
#include <tuple>
#include <bitset>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <vector>
#define inl inline
#define re register int
#define fa(x) t[x].fa
#define ls(x) t[x].child[0]
#define rs(x) t[x].child[1]
#define int long long
const int inf = 0x3f3f3f3f;
#define lowbit(x) ((x) & (-x))
using namespace std;
template <class Read>
inl Read read() {
	Read x = 0;
	register bool w = 0;
	register char c = getchar();
	while (c > '9' || c < '0') {
		if (c == '-') w = 1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return w ? -x : x;
}
struct node {
	int tot, vir, w, fa, child[2], tag, size;
	bool filp;
} t[100001];
inl void maintain(int x) {
	t[x].tot = t[x].vir + t[x].w + t[ls(x)].tot + t[rs(x)].tot;
	t[x].size = t[ls(x)].size + t[rs(x)].size + 1;
}
inl bool nroot(int x) {
	return ls(fa(x)) == x || rs(fa(x)) == x;
}
inl bool poi(int x) {
	return rs(fa(x)) == x;
}
inl void rotate(int x) {
	re f = fa(x), gf = fa(f), fs = poi(x), gfs = poi(f), s = t[x].child[fs ^ 1];
	if (nroot(f)) t[gf].child[gfs] = x;
	t[f].child[fs] = s, t[x].child[fs ^ 1] = f;
	if (s) fa(s) = f;
	fa(f) = x, fa(x) = gf;
	maintain(f);
}
inl void reverse(int x) {
	swap(ls(x), rs(x));
	t[x].filp ^= 1;
}
inl void sum(int x, int w) {
	t[x].tag += w, t[x].tot += w * t[x].size, t[x].w += w;
}
inl void pushdown(int x) {
	if (t[x].filp) {
		if (ls(x)) reverse(ls(x));
		if (rs(x)) reverse(rs(x));
		t[x].filp = 0;
	}
	if (t[x].tag) {
		if (ls(x)) sum(ls(x), t[x].tag);
		if (rs(x)) sum(rs(x), t[x].tag);
		t[x].tag = 0;
	}
}
inl void push(int x) {
	if (nroot(x)) push(fa(x));
	pushdown(x);
}
inl void splay(int x) {
	push(x);
	while (nroot(x)) {
		if (nroot(fa(x))) poi(fa(x)) == poi(x) ? rotate(fa(x)) : rotate(x);
		rotate(x);
	}
	maintain(x);
}
inl void access(int x) {
	for (re i = 0; x; x = fa(i = x)) {
		splay(x), t[x].vir += t[rs(x)].tot, t[x].vir -= t[rs(x) = i].tot, maintain(x);
	}
}
inl void makeroot(int x) {
	access(x), splay(x), reverse(x);
}
inl void split(int x, int y) {
	makeroot(y), access(x), splay(x);
}
inl void link(int x, int y) {
	split(x, y), fa(y) = x, t[x].vir += t[y].w;
}
inl bool spread() {
	register char c = getchar();
	while (c != 'A' && c != 'Q')
		c = getchar();
	return c == 'Q';
}
signed main() {
	re n = read<int>();
	for (re i = 1; i < n; i++) {
		re x = read<int>() + 1, y = read<int>() + 1;
		link(x, y);
	}
	re m = read<int>();
	while (m--) {
		re op = spread(), x = read<int>() + 1;
		if (!op) {
			re y = read<int>() + 1, w = read<int>();
			split(x, y), sum(x, w);
		}
		else {
			makeroot(1), access(x), splay(x);
			printf("%lld\n", t[x].tot - t[ls(x)].tot);
		}
	}
}
```



---

## 作者：rsdbk_husky (赞：5)

### 放在前面的前面：本文有树剖图解

放在前面：一道树剖板子题，关于树剖的教程网上数不胜数，我就只 **概述** 一下，就不造轮子了，具体细节请见 [OI WIKI](https://oi-wiki.org/graph/hld/)。

## 一. 过程概述

#### 0. 基础：邻接表，线段树。

#### 1. 第一次 dfs：

求出该有根树（如果题目没明确根就任选一个）所有节点的父节点，深度，（以他为根的）子树的大小， 重儿子。

#### 2. 第二次 dfs：

求出该有根树所有节点的 dfs 序—— $dfs$，每个 dfs 对应的节点编号—— $dfsidx$（$i=dfsidx_{dfs_i}$），所在重链的链顶—— $top$，其子树中节点中 dfs 序最大的一个—— $bottom$。用途：

$dfs$：若这棵树上本来就有权值需要用它辅助给线段树建树。本题中无用。

$dfsidx$：用他将线段树上节点的编号转化为线段树上节点的编号。

$top$：进行树链上操作时需要。（详见我的代码和[OI WIKI](https://oi-wiki.org/graph/hld/)）

$bottom$：进行子树上操作时需要。（详见我的代码和[OI WIKI](https://oi-wiki.org/graph/hld/)）

#### 3. 权值增减与查询：

详解见[OI WIKI](https://oi-wiki.org/graph/hld/)，这里只放两张图：

![树和dfs序](https://cdn.luogu.com.cn/upload/image_hosting/ct1tktum.png)

（madeby：大佬 EternalAlexander 的 [OI Painter](https://www.luogu.com.cn/discuss/show/41151)）

![另一张dfs图](https://cdn.luogu.com.cn/upload/image_hosting/j7clempb.png)

有点先序遍历内味了，只不过不是根左右，而是根重轻。
由此也可发现：树上一条重链或一棵子树都是线段树上连续的一部分，这正是树剖的核心。

## 二. 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

#define re register
typedef long long LL;

const int MAXn = 1e5;
const int MAXm = MAXn - 1;

template <class T>
inline void read(T &x) {
    register char c;while (c = getchar(), c < '0' || c >'9');register T s(c - '0');while (c = getchar(), c >= '0' && c <= '9') {s = (s << 1) + (s << 3) + c - '0';}x = s;
}

int cntnext, head[MAXn + 10], nex[MAXm + 10], to[MAXm + 10];//////
inline void Insert(int from, int too) {							//
	nex[++cntnext] = head[from];								//邻接表 
	head[from] = cntnext;										//
	to[cntnext] = too;										//////
} 

struct Node {												//////线段树 
    LL sum;														//
    int l;														//
    int r;														//
    LL add;														//
};																//
Node stt[MAXn * 4 + 10];										//
																//
void _BuildUseArray_(int nodeid, int l, int r, LL *array) {		//
    stt[nodeid].l = l;											//
    stt[nodeid].r = r;											//
    if (l == r) {												//
        stt[nodeid].sum = array[l];								//
        return;													//
    }															//
    int mid = (l + r) >> 1;										//
    _BuildUseArray_((nodeid << 1), l, mid, array);				//
    _BuildUseArray_((nodeid << 1) + 1, mid + 1, r, array);		//
    stt[nodeid].sum = (stt[(nodeid << 1)].sum + stt[(nodeid << 1) + 1].sum);
}																//
																//	
void _Build0_(int nodeid, int l, int r) {						//
	stt[nodeid].l = l;											//
	stt[nodeid].r = r;											//
	if (l == r) {												//
		return;													//
	}															//
	int mid = (l + r) >> 1;										//
	_Build0_((nodeid << 1), l, mid);							//
	_Build0_((nodeid << 1) + 1, mid + 1, r);					//
}																//
																//
void _Spread_(int nodeid) {										//
    stt[(nodeid << 1)].sum = ( stt[(nodeid << 1)].sum + ((stt[(nodeid << 1)].r - stt[(nodeid << 1)].l + 1) * stt[nodeid].add) );
    stt[(nodeid << 1) + 1].sum = ( stt[(nodeid << 1) + 1].sum + (stt[nodeid].add * (stt[(nodeid << 1) + 1].r - stt[(nodeid << 1) + 1].l + 1)) );
																//
    stt[(nodeid << 1)].add = (stt[(nodeid << 1)].add + stt[nodeid].add);
    stt[(nodeid << 1) + 1].add = (stt[(nodeid << 1) + 1].add + stt[nodeid].add);
																//
    stt[nodeid].add = 0;										/// 
}																////////// 线段树 
																///
void _Add_(int nodeid, int l, int r, LL k) {					//
    if (stt[nodeid].l >= l && stt[nodeid].r <= r) {				//
        stt[nodeid].add = (stt[nodeid].add + k);				//
        stt[nodeid].sum = (stt[nodeid].sum + k * (stt[nodeid].r - stt[nodeid].l + 1));
        return;													//
    }															//
    _Spread_(nodeid);											//
    int mid = (stt[nodeid].l + stt[nodeid].r) >> 1;				//
    if (l <= mid)   _Add_((nodeid << 1), l, r, k);				//
    if (mid < r)    _Add_((nodeid << 1) + 1, l, r, k);			//
    stt[nodeid].sum = (stt[(nodeid << 1)].sum + stt[(nodeid << 1) + 1].sum);
}																//
																//
LL _Eva_(int nodeid, int l, int r) {							//
    if (stt[nodeid].l >= l && stt[nodeid].r <= r)				//
        return stt[nodeid].sum;									//
    _Spread_(nodeid);											//
    LL val = 0;													//
    int mid = (stt[nodeid].l + stt[nodeid].r) >> 1;				//
    if (l <= mid)   val = (val + _Eva_((nodeid << 1), l, r));	//
    if (mid < r)    val = (val + _Eva_((nodeid << 1) + 1, l, r));
    return val;													//
}																//
																//
void BuildUseArray(int l, int r, LL *array) {					//
	_BuildUseArray_(1, l, r, array);							//
}																//
																//
void Build0(int l, int r) {										//
	memset(stt, 0, sizeof(stt));								//
	_Build0_(1, l, r);											//
}																//
																//
void Add(int l, int r, LL k) {									//
	_Add_(1, l, r, k);											//
}																//
																//
LL Eva(int l, int r) {											//
	return _Eva_(1, l, r);										//
}															//////线段树 

int fa[MAXn + 10], dep[MAXn + 10], siz[MAXn + 10], hson[MAXn + 10];//树剖 
int Dfs1(int nodeid, int fat, int deep) {						////
	int size = 1;												///
	int maxsiz = 0;												//
	int maxer = 0;												//
	int eachsiz;												//
	fa[nodeid] = fat;											//
	dep[nodeid] = deep;											//
	for (re int i = head[nodeid]; i; i = nex[i]) {				//
		eachsiz = Dfs1(to[i], nodeid, deep + 1);				//
		size += eachsiz;										//
		if (eachsiz > maxsiz) {									//
			maxsiz = eachsiz;									//
			maxer = to[i];										//
		}														//
	}															//
	siz[nodeid] = size;											//
	hson[nodeid] = maxer;										//
	return size;												//
}																//
																//
int cntdfs, dfs[MAXn + 10], dfsidx[MAXn + 10], top[MAXn + 10], bottom[MAXn + 10];		
void Dfs2(int nodeid, int topp) {								//
	dfs[++cntdfs] = nodeid;										//
	dfsidx[nodeid] = cntdfs;									//
	top[nodeid] = topp;											//
	if (hson[nodeid]) {											//
		Dfs2(hson[nodeid], topp);								//
		for (int i = head[nodeid]; i; i = nex[i]) {				//
			if (to[i] != fa[nodeid] && to[i] != hson[nodeid]) {	//
				Dfs2(to[i], to[i]);								//
			}													//
		}														//
	}															//
	bottom[nodeid] = dfs[cntdfs];								//
}																///
																////////// 树剖 
void TreePathAdd(int x, int y, int k) {							///
	while (top[x] != top[y]) {									//
		if (dep[top[x]] > dep[top[y]]) {						//
			swap(x, y);											//
		}														//
		Add(dfsidx[top[y]], dfsidx[y], k);						//
		y = fa[top[y]];											//
	}															//
	if (dep[x] > dep[y]) {										//
		swap(x, y);												//
	}															//
	Add(dfsidx[x], dfsidx[y], k);								//
}																//
																//
LL TreePathEva(int x, int y) {									//
	LL sum = 0;													//
	while (top[x] != top[y]) {									//
		if (dep[top[x]] > dep[top[y]]) {						//
			swap(x, y);											//
		}														//
		sum += Eva(dfsidx[top[y]], dfsidx[y]);					//
		y = fa[top[y]];											//
	}															//
	if (dep[x] > dep[y]) {										//
		swap(x, y);												//
	}															//
	sum += Eva(dfsidx[x], dfsidx[y]);							//
	return sum;													//
}																//
																//
void SonTreeAdd(int rootid, int k) {							//
	Add(dfsidx[rootid], dfsidx[bottom[rootid]], k);				//
}																//
																//
LL SonTreeEva(int rootid) {										//
	return Eva(dfsidx[rootid], dfsidx[bottom[rootid]]);			//
}															//////树剖 

int n, q;
int main() {
	read(n);
	Build0(1, n);
	for (re int i = 1, from, to; i < n; ++i) {
		read(from), read(to);
		Insert(from + 1, to + 1);
	}
	Dfs1(1, 0, 1);
	Dfs2(1, 1);	
	read(q);
	for (re int i = 1, from, to, val, opt, root; i <= q; ++i) {
		getchar();
		opt = getchar();
		switch (opt) {
		case 'A':
			read(from), read(to), read(val);
			TreePathAdd(from + 1, to + 1, val);
			break;
		case 'Q':
			read(root);
			printf("%lld\n", SonTreeEva(root + 1));
			break;
		}
	}
}
```

最后：安利一波我的[博客](https://rsdbkhusky.github.io/)。



---

## 作者：ZSH_ZSH (赞：5)

~~这是一篇良心题解~~（废话

看到题目，想到这是树剖的板子题

因为别的题解把树剖过程讲得很清楚

那么树剖的具体过程我在此不再赘述

简单来说就是更新简单路径上的权值，这一点可以用树状数组实现

看了一下，没有题解详细介绍树状数组的区间修改和区间查询的，来给大家普及一下

## 本题解重点： 如何用树状数组进行区间修改，区间查询，模拟线段树

安利一下大佬的[博客](https://www.cnblogs.com/RabbitHu/p/BIT.html)

树状数组的区间修改主要通过差分实现，有兴趣的同学可以点击上面博客使用

### 关于树状数组的速度：

答：树状数组的速度远远高于线段树

同样是[P3372](https://www.luogu.com.cn/problem/P3372)线段树板子

**树状数组 170 ms**

**线段树 400+ ms**

所以在处理一些求和问题的时候，可以考虑用树状数组

那么进入正题：

关于 $A$ 操作前文已经提及，用树剖维护

关于 $Q$ 操作,易得，一颗子树的dfs序是连续的，所以可以直接对dfs序求和，这是树上问题的常用技巧

这里注意一下，因为个人习惯，我将节点编号从1开始 

大家写的时候不必照着我的习惯，可以直接将编号从0开始，没有影响的

最后注意一下细节，AC很简单的 （我一遍AC的 （逃

# 代码

```

#include<bits/stdc++.h>
//PS 请管理员大大自动忽略这一长串的板子，写习惯了。。
namespace my_std
{
	using namespace std;
	#define int long long
	#define rep(i,a,b) for (int i=(a);i<=(b);i++)
	#define drep(i,a,b) for (int i=(a);i>=(b);i--)
	#define go(u) for (int i=head[(u)];i;i=e[i].nxt)
	#define pf printf
	#define writeln(x) write(x),putchar('\n')
	#define writesp(x) write(x),putchar(' ')
	#define mem(x,v) memset(x,v,sizeof(x))
	typedef long long ll;
	const int INF=0x7fffffff;
	inline int read()
	{
		int sum=0,f=1;
		char c=0;
		while (!isdigit(c))
		{
			if (c=='-') f=-1;
			c=getchar();
		}
		while (isdigit(c))
		{
			sum=(sum<<1)+(sum<<3)+(c^48);
			c=getchar();
		}
		return sum*f;
	}
	void write(int k)
	{
		if (k<0) putchar('-'),k=-k;
		if (k>=10) write(k/10);
		putchar(k%10+'0');
	}
}
using namespace my_std;
const int N=100010;
int n,cnt,head[N];
int tree1[N],tree2[N];
int in[N],num[N],f[N];
int size[N],son[N],top[N];
int idx,dep[N];
struct edge
{
	int to,nxt;
}e[N<<1];
inline int lowbit(int x)
{
	return x&(-x);
}
void update(int x,int y)
{
	for (int i=x;i<=n;i+=lowbit(i))
	{
		tree1[i]+=y;
		tree2[i]+=x*y;
	}
   //树状数组精髓操作*1 修改
}
void modify(int x,int y,int z)
{
	update(x,z);
	update(y+1,-z);
   //树状数组精髓操作*2 差分
}
int getsum(int x)
{
	int res=0;
	for (int i=x;i>0;i-=lowbit(i))
	{
		res+=tree1[i]*(x+1)-tree2[i];
	}
	return res;
   //树状数组精髓操作*3 求和
}
int query(int l,int r)
{
	return getsum(r)-getsum(l-1);
}
void add(int u,int v)
{
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
void dfs1(int u,int fa)
{
	dep[u]=dep[fa]+1;
	f[u]=fa;
	size[u]=1;
	go(u)
	{
		int v=e[i].to;
		if (v==fa) continue;
		dfs1(v,u);
		size[u]+=size[v];
		if (size[son[u]]<size[v])
		{
			son[u]=v;
		}
	}
}
void dfs2(int u,int t)
{
	in[u]=++idx;
	num[idx]=u;
	top[u]=t;
	if (!son[u]) return;
	dfs2(son[u],t);
	go(u)
	{
		int v=e[i].to;
		if (v==son[u]||v==f[u]) continue;
		dfs2(v,v);
	}
}
void mark(int x,int y,int z)
{
	while (top[x]!=top[y])
	{
		if (dep[top[x]]<dep[top[y]]) swap(x,y);
		modify(in[top[x]],in[x],z);
		x=f[top[x]];
	}
	if (dep[x]<dep[y]) swap(x,y);
	modify(in[y],in[x],z);
}
signed main()
{
	n=read();
	int u,v,d;
	rep(i,1,n-1)
	{
		u=read()+1,v=read()+1;
		add(u,v),add(v,u);
	}
	dfs1(1,0);
	dfs2(1,1);
	int quiz=read();
	char opt;
	rep(i,1,quiz)
	{
		scanf("%s",&opt);
		if (opt=='A')
		{
			u=read()+1,v=read()+1;
			d=read();
			mark(u,v,d);
		}
		else
		{
			u=read()+1;
			int ans=query(in[u],in[u]+size[u]-1);
			writeln(ans);
		}
	}
}

```

希望这篇题解能给大家消除一些困惑

码字不易，求求管理员大大给过（QAQ）

---

## 作者：ker_xyxyxyx_xxs (赞：3)

[P3833 [SHOI2012]魔法树](https://www.luogu.com.cn/problem/P3833)

树链剖分模板题。

问题就是维护树上一个点到另外一个点的和与中途每个点的区间修改。

将整个树先 dfs 一遍，预处理每个点的深度，父亲，重儿子和子树大小。

接着再 dfs 一遍，这一次使用“重链优先搜索”，对于每个节点的子树，先对它的重儿子进行 dfs ，将整个树重新编号，点值映射一下就可以了。

接着你就会发现，每一条重链的编号都是连续的。这样你的维护树就变成了许多条链，你只需要维护这些链即可。链上，线性结构。自然就是线段树，所以这个题后面就变成了一个区间修改的维护和的线段树，写写就过了。

至于树链剖分的操作，就是先在这一条链上修改，不停的往上跳到下一条链。

Code

```cpp
# include <iostream>
# include <cstdio>
# define int long long
using namespace std;

typedef long long ll;

const int N = 2e6 + 5;

typedef struct {
    int x , y , next;
}Edge;
Edge edge[N];

int E = 0 , elast[N];

void add(int x , int y ) {
    E ++;
    edge[E].x = x;
    edge[E].y = y;
    edge[E].next = elast[x];
    elast[x] = E;
}

int f[N] , dep[N] , son[N] , siz[N];

void dfs1(int x , int fa) {
    dep[x] = dep[fa] + 1;
    f[x] = fa;
    siz[x] = 1;
    int maxv = -1;
    for (int i = elast[x] ; i ; i = edge[i].next) {
        int y = edge[i].y;
        if (y != fa) {
            dfs1(y , x);
            siz[x] += siz[y];
            if (siz[y] > maxv) son[x] = y , maxv = siz[y];
        }
    }
}

int top[N] , id[N] , w[N] , W[N] , Cnt = 0;

int n , m , root;

void dfs2(int x , int Top) {
    id[x] = ++ Cnt;
    w[Cnt] = W[x];
    top[x] = Top;
    if (!son[x]) return ;
    dfs2(son[x] , Top);
    for (int i = elast[x] ; i ; i = edge[i].next) {
        int y = edge[i].y;
        if (y != f[x] && y != son[x]) dfs2(y , y);
    }
}

typedef struct {
    int l , r , sum , lazy;
}Node;
Node tr[N * 4];

void pushup(int p) {
    tr[p].sum = tr[p << 1].sum + tr[p << 1 | 1].sum;
}

void pushdown(int p) {
    if (tr[p].lazy) {
        tr[p << 1].lazy += tr[p].lazy;
        tr[p << 1 | 1].lazy += tr[p].lazy;
        tr[p << 1].sum += (tr[p << 1].r - tr[p << 1].l + 1) * tr[p].lazy;
        tr[p << 1 | 1].sum += (tr[p << 1 | 1].r - tr[p << 1 | 1].l + 1) * tr[p].lazy;
        tr[p].lazy = 0;
    }
}

void modify(int p , int x , int y , int d) {
    if (x <= tr[p].l && tr[p].r <= y) {
        tr[p].lazy += d;
        tr[p].sum += d * (tr[p].r - tr[p].l + 1);
        return ;
    } else {
        pushdown(p);
        int mid = (tr[p].l + tr[p].r) >> 1;
        if (x <= mid) modify(p << 1 , x , y , d);
        if (y > mid) modify(p << 1 | 1 , x , y , d);
        pushup(p);
    }
}

int query(int p , int x , int y) {
    if (x <= tr[p].l && tr[p].r <= y) return tr[p].sum;
    else {
        pushdown(p);
        int mid = (tr[p].l + tr[p].r) >> 1 , ans = 0;
        if (x <= mid) ans += query(p << 1 , x , y);
        if (y > mid) ans += query(p << 1 | 1 , x , y);
        return ans;
    }
}

void build(int p , int x , int y) {
    tr[p].l = x , tr[p].r = y;
    if (x == y) {
        tr[p].sum = w[x];
        return ;
    } else {
        int mid = (x + y) >> 1;
        build(p << 1 , x , mid) , build(p << 1 | 1 , mid + 1 , y);
        pushup(p);
    }
}

void change(int x , int y , int z) {
	while (top[x] != top[y]) {
		if (dep[top[x]] < dep[top[y]]) swap(x , y);
	    modify(1 , id[top[x]] , id[x] , z);
		x = f[top[x]];
	}
	if (dep[x] > dep[y]) swap(x , y);
	modify(1 , id[x] , id[y] , z);
}

signed main() {
	cin >> n;
	for (int i = 1 ; i <= n - 1 ; i ++) {
		int x , y;
		cin >> x >> y;
		x ++ , y ++;
		add(x , y);
	}
	dfs1(1 , 0);
	dfs2(1 , 1);
	build(1 , 1 , n);
	cin >> m;
	while (m --) {
		char opt;
		cin >> opt;
		int x , y , z;
		if (opt == 'A') {
			cin >> x >> y >> z;
			x ++ , y ++;
			change(x , y , z);
		} else {
			cin >> x;
			x ++;
			cout << query(1 , id[x] , id[x] + siz[x] - 1) << endl;
		}
	}
}
```

---

## 作者：vvauted (赞：3)

## Disciption
这是一道很板的树剖题，有两种操作：

1. 更新 $u,v$ 路径上点的点权
2. 查询子树点权和

## Solution
### P1
首先是两个对树的 dfs，预处理树剖信息（这里不需要建立线段树，因为初始点权都为 $0$），给出代码：
```cpp
void dfs1(int p,int f)
{
	register int i;
	fa[p]=f;
	siz[p]=1;
	dep[p]=dep[f]+1;
	for(i=head[p];i;i=nxt[i])
	{
		if(to[i]==f) continue;
		dfs1(to[i],p);
		siz[p]+=siz[to[i]];
		if(siz[to[i]]>siz[son[p]]) son[p]=to[i];
 	}
}
void dfs2(int p,int tp)
{
	register int i;
	top[p]=tp;
	dfn[p]=(++tot);
	if(!son[p]) return;
	dfs2(son[p],tp);
	for(i=head[p];i;i=nxt[i]) if(to[i]!=son[p]&&to[i]!=fa[p]) dfs2(to[i],to[i]);
}
```
### P2
然后写出线段树操作代码，此处我用 `struct` 打包，保证函数名不会冲突（注意，本题要开 `long long`），给出代码：
```cpp
struct Sugment_Tree{
	inline int lc(int p){return p<<1;}
	inline int rc(int p){return p<<1|1;}
	long long int val[Maxn<<2],tag[Maxn<<2];
	inline void push_up(int p){val[p]=val[lc(p)]+val[rc(p)];}
	inline void tging(int p,int l,int r,long long int v)
	{
		tag[p]+=v;
		val[p]+=(r-l+1)*v;
	}
	inline void push_down(int p,int l,int r)
	{
		if(tag[p])
		{
			int mid=(l+r)>>1;
			tging(lc(p),l,mid,tag[p]);
			tging(rc(p),mid+1,r,tag[p]);
			tag[p]=0;
		}
	}
	inline void upd(int p,int l,int r,int ul,int ur,long long int v)
	{
		if(ul<=l&&r<=ur)
		{
			tging(p,l,r,v);
			return;
		}
		int mid=(l+r)>>1;
		push_down(p,l,r);
		if(mid>=ul) upd(lc(p),l,mid,ul,ur,v);
		if(mid<ur) upd(rc(p),mid+1,r,ul,ur,v);
		push_up(p);
	}
	inline long long int query(int p,int l,int r,int ql,int qr)
	{
		if(ql<=l&&r<=qr) return val[p];
		push_down(p,l,r);
		long long int ans=0,mid=(l+r)>>1;
		if(mid>=ql) ans+=query(lc(p),l,mid,ql,qr);
		if(mid<qr) ans+=query(rc(p),mid+1,r,ql,qr);
		return ans;
	}
}T;
```
我跟别人不一样的点就在于节点 `l,r` 是在操作时传参的，很容易被卡常。
### P3
依据树剖预处理好的信息，对线段树进行操作。

给出两种操作的代码：
```cpp
int tmp;
#define swap(a,b) tmp=a,a=b,b=tmp
void upd(int u,int v,long long int w)
{
	while(top[u]!=top[v])
	{
		if(dep[top[u]]<dep[top[v]]) swap(u,v);
		T.upd(1,1,n,dfn[top[u]],dfn[u],w);
		u=fa[top[u]]; 
	}
	if(dep[u]>dep[v]) swap(u,v);
	T.upd(1,1,n,dfn[u],dfn[v],w);
}
long long int query(int u)
{
	return T.query(1,1,n,dfn[u],dfn[u]+siz[u]-1);
}
```
对于操作 $1$，使用 `while` 循环解决，~~避免被卡常~~。

对于操作 $2$，子树的序号是连续的，所以节点 $u$ 的子树的 
` dfn` 就在 $[dfn_u,dfn_u+siz_u-1]$ 内，其中 `siz` 为子树大小。


注：注意的一点就是，同一个链上，`dep` 越小，`dfn` 越小，不要搞错顺序，线段树会炸。
### P4 读入
读入小技巧来自 cz 大佬：

![](https://cdn.luogu.com.cn/upload/image_hosting/vucwiwkl.png)

---

## 作者：CG__HeavenHealer (赞：3)

### 题意

一棵树， $q$ 次询问，若 $op = A$ 则令树上 $x$ 到 $y$ 节点每一个点的权值加 $d$ ，若 $op = Q$ ，则查询以 $u$ 为根节点的子树的和。

### 解法

**树剖**裸题。

先介绍一下树链剖分：

树链剖分用于将整棵树剖分为若干条链，使它组合成线性结构，然后用其他的数据结构维护信息。

树链剖分可以将树上的任意一条路径划分成不超过 $ log_2n $ 条连续的链，每条链上的点深度互不相同。

定义以下内容：

**重子节点** 表示其子节点中子树最大的子结点。

**轻子节点** 表示剩余的所有子结点。

从这个结点到重子节点的边为 **重边**。

到其他轻子节点的边为 **轻边**。

若干条首尾衔接的重边构成 **重链**。

把落单的结点也当作重链，那么整棵树就被剖分成若干条重链。

例如，下面这棵树：

![](https://cdn.luogu.com.cn/upload/image_hosting/elqshy0n.png)

标红的是对应节点的重儿子和重链：

对于节点 $1$ ：重儿子为 $3$；

对于节点 $2$ ：重儿子为 $7$；

对于节点 $3$ ：重儿子为 $5$；

对于节点 $4$ ：重儿子为 $6$；

对于节点 $5$ ：重儿子为 $9$；

对于节点 $6$ ：重儿子为 $10$；

对于节点 $9$ ：重儿子为 $11$。

#### 实现

树链剖分为将树组合成线性结构，需要通过两次$DFS$维护以下信息：

1.$ fa_x $ ：每个点的父亲

2.$dep_x$ ：每个点的深度

3.$siz_x$ ：每个非叶子节点的子树大小(含它自己)

4.$son_x$ ：每个非叶子节点的重儿子编号

第一次$DFS$：

```c++
void dfs1(int u, int F) {
    fa[u] = F, dep[u] = dep[F] + 1, siz[u] = 1;
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to; 
		if (v == F) continue;
        dfs1(v, u);
        siz[u] += siz[v];
        if (siz[son[u]] < siz[v]) son[u] = v;
    }
}
```

处理完以上信息后，我们再DFS一遍，处理每个点所在的链顶$top_x$。

顺序：**先重后轻**

第二次$DFS$：

```cpp
void dfs2(int u, int F) {
    top[u] = F;
    if (!son[u]) return;
    dfs2(son[u], F);
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (v != fa[u] && v != son[u]) dfs2(v, v);
    }
}
```

回到本题——怎样维护每个节点的子树的信息？

我们可以用线段树维护每个区间的信息，并更改。

我们需要先在dfs2中加一个步骤：

```c++
int id[N],dfn;//时间戳
//in dfs2:
id[u]=++dfn;//记录该节点的时间戳
```

在dfs时，**时间戳都是连续的**，所以在修改区间时，可以边往链顶跳边更新信息。

```cpp
void update_range(int x, int y, int k) {
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]]) swap(x, y);
        update(1, 1, n, id[top[x]], id[x], k);//边跳边更新
        x = fa[top[x]];
    }
    if (dep[x] > dep[y]) swap(x, y);
    update(1, 1, n, id[x], id[y], k);
}
```

同样的，由于时间戳连续，可以指定查询的左端点为 $id[u]$ ，右端点为 $id[u]+siz[u]-1$ 来查询：

```cpp
int query_son(int u) { return query(1, 1, n, id[u], id[u] + siz[u] - 1); }
// siz[u] 是以 u 为根的子树大小，id 编号是连续的，所以查 u 的子树和就等价于查询 id[u]~id[u]+siz[u]-1（根节点算了两次，所以减一）的区间和。
```

### Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define ri register int
const int N = 1e5 + 10;
inline int read() {
    int x = 0;
    char ch = getchar();
    bool f = 1;
    while (!isdigit(ch)) {
        if (ch == '-') f = 0;
        ch = getchar();
    }
    while (isdigit(ch)) {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }
    return f ? x : -x;
}
struct Edge {
    int to, nxt;
} e[N << 1];
int head[N], cnt;
inline void add(int u, int v) {
    e[++cnt].to = v;
    e[cnt].nxt = head[u];
    head[u] = cnt;
}
int n;
#define Ergodic(u) for (ri i = head[u]; i; i = e[i].nxt)
namespace SegmentTree {
struct segmenttree {
    int v, tag;
} t[N << 2];
#define ls u << 1
#define rs u << 1 | 1
#define mid ((l + r) >> 1)
inline void push_up(int u) { t[u].v = t[ls].v + t[rs].v; }
inline void push_down(int u, int l, int r) {
    t[ls].tag += t[u].tag, t[rs].tag += t[u].tag;
    t[ls].v += t[u].tag * (mid - l + 1);
    t[rs].v += t[u].tag * (r - mid);
    t[u].tag = 0;
}
void update(int u, int l, int r, int ql, int qr, int k) {
    if (ql > r || qr < l) return;
    if (ql <= l && r <= qr) {
        t[u].tag += k;
        t[u].v += k * (r - l + 1);
        return;
    }
    push_down(u, l, r);
    update(ls, l, mid, ql, qr, k);
    update(rs, mid + 1, r, ql, qr, k);
    push_up(u);
}
int query(int u, int l, int r, int ql, int qr) {
    if (ql > r || qr < l) return 0;
    if (ql <= l && r <= qr) return t[u].v;
    push_down(u, l, r);
    int lson = query(ls, l, mid, ql, qr);
    int rson = query(rs, mid + 1, r, ql, qr);
    return lson + rson;
}
}  // namespace SegmentTree
using namespace SegmentTree;
namespace Tree_Chain_Divide {
int dep[N], son[N], fa[N], top[N], siz[N];
void dfs1(int u, int F) {
    siz[u] = 1, fa[u] = F, dep[u] = dep[F] + 1;
    Ergodic(u) {
        int v = e[i].to;
        if (v == F) continue;
        dfs1(v, u);
        siz[u] += siz[v];
        if (siz[v] > siz[son[u]]) son[u] = v;
    }
}
int id[N], dfn;
void dfs2(int u, int topf) {
    top[u] = topf;
    id[u] = ++dfn;
    if (!son[u]) return;
    dfs2(son[u], topf);
    Ergodic(u) {
        int v = e[i].to;
        if (v == son[u] || v == fa[u]) continue;
        dfs2(v, v);
    }
}
void update_range(int x, int y, int k) {
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]]) swap(x, y);
        update(1, 1, n, id[top[x]], id[x], k);
        x = fa[top[x]];
    }
    if (dep[x] > dep[y]) swap(x, y);
    update(1, 1, n, id[x], id[y], k);
}
int query_son(int u) { return query(1, 1, n, id[u], id[u] + siz[u] - 1); }
}  // namespace Tree_Chain_Divide
using namespace Tree_Chain_Divide;
signed main() {
    n = read();
    for (ri i = 1; i < n; i++) {
        int u = read(), v = read();
        add(u + 1, v + 1), add(v + 1, u + 1);
    }
    dfs1(1, 0), dfs2(1, 1);
    int q = read();
    while (q--) {
        char op;
        scanf(" %c", &op);
        if (op == 'A') {
            int u = read(), v = read(), d = read();
            update_range(u + 1, v + 1, d);
        } else {
            int u = read();
            printf("%lld\n", query_son(u + 1));
        }
    }
    return 0;
}
```



---

## 作者：Flowery (赞：2)

如果你还不会树链剖分，可以先尝试这道模板题：[【模板】轻重链剖分](https://www.luogu.com.cn/problem/P3384)  

这道题可以说是树链剖分套线段树的模板题，蒟蒻的我花了一下午时间来练树链剖分后终于~~好像~~搞懂了呢！虽然看到其他题解有用LCT做，但是蒟蒻的我表示我并不会。

## 首先介绍一下树链剖分：

![图片1.png](https://cdn.luogu.com.cn/upload/image_hosting/2ad9tlva.png)


根据树的概念，树上存在着许多的链，如本图中，就含有很多的链，例如3-2-1-9-10-11就是其中一条链。

对于一棵树，如果我们已经找出了一条链的情况下，它在链上的操作是线性的。此外，一条链周围点，也可以通过这条链实现快速的维护。

例如，还是上图中的3-2-1-9-10-11这一条链，当我们找出它时，便可以快速的维护4这个点（指4向上一步就可以进入链中，复杂度几乎属于常数），减少了树型结构的复杂度。

综上可知，链在树型结构中的地位非常重要，一颗树可以根据不同剖分成多条链，从而将树型结构优化成接近线性结构，进而运用数据结构维护。

树链剖分分为：重链剖分、长链剖分、实链剖分，一般说树链剖分指的是重链剖分。

我们给出一些定义，并按以下规则划分一颗树：

### 定义：


 **重子节点**——表示其子节点中子树最大的子结点。如果有多个子树最大的子结点，取其一。如果没有子节点，就无重子节点。
 
**轻子节点**——表示剩余的所有子结点。

从这个结点到重子节点的边为重边。

到其他轻子节点的边为轻边。

若干条首尾衔接的重边构成重链。

把落单的结点也当作重链，那么整棵树就被剖分成若干条重链。

如图所示，当前一颗树已经被按上述要求分成了若干条链。

![图片2.png](https://cdn.luogu.com.cn/upload/image_hosting/cjl04brb.png)

### 代码实现：两次dfs


**第一次dfs：**

fa：记录父节点

dep：记录当前深度

size：记录子树规模

son：当前重儿子是谁,这里主要处理出了每个节点的子树规模以及找出了重儿子，为接下来剖分做准备
```cpp
void dfs1(int x,int Fa)
{
	fa[x]=Fa;
	size[x]=1;
	dep[x]=dep[Fa]+1;
	for(int i=head[x];i;i=nxt[i])
	if(to[i]!=fa[x])
	{
		dfs1(to[i]);
		size[x]+=size[to[i]];
		if(size[son[x]]<size[to[i]])son[x]=to[i];
	}
}
```
**第二次dfs：**

top：当前每个点所在链的顶端节点

seg、rev：对每一个节点按
按链的顺序重新编号，这样同一链上的点编号相邻

这里找出了每个点对应的链的顶点，以此划分链

```cpp
void dfs2(int x)
{
	if(son[fa[x]]!=x)top[x]=x;
	else top[x]=top[fa[x]];
	seg[x]=++dfn;
	rev[dfn]=x;
	if(son[x])dfs2(son[x]);
	for(rg i=head[x];i;i=nxt[i])
	if(to[i]!=fa[x]&&to[i]!=son[x])
	dfs2(to[i]);
}
```
### 重链剖分的性质:

树上每个节点都属于且仅属于一条重链 。

所有的重链将整棵树 完全剖分 。

在剖分时优先遍历重儿子，最后重链的 DFS 序就会是连续的。

一颗子树内的 DFN 序是连续的。

可以发现，当我们向下经过一条 轻边 时，所在子树的大小至少会除以二因此每过一条链复杂度至少除以二，最终复杂度为logn级别。

因此，对于树上的任意一条路径，把它拆分成从lca分别向两边往下走，分别最多走logn次，因此，树上的每条路径都可以被拆分成不超过logn条重链。

 _<此处介绍大多引用xj学长的细心讲解啦~~~>_ 

然后我们就可以干很多事情，例如 

### 套线段树！！

因此我们就可以把线段树的板子打上去了！！

这道题就用线段树维护区间和以及区间最大值，但因为树链剖分后每次change_son修改的的区间是从seg[ x ]到seg[ x ]+size[ x ]-1（相当于seg记录的是dfs序啦）


（并且这道题要记得开long long呦）

# Code:

~~< 提供自认为比较清新的码风 >~~

```cpp
#define Flowery
#define maxn 400000
#define ll long long
#define rg register long long
#include<bits/stdc++.h>
using namespace std;
int T,n;
struct node
{
	ll l,r,val,maxx,lazy;
}gy[maxn];
int to[maxn],head[maxn],nxt[maxn],cnt;
inline void add(ll x,ll y)
{
	to[++cnt]=y;
	nxt[cnt]=head[x];
	head[x]=cnt;
}
int fa[maxn],dep[maxn],size[maxn],son[maxn];
void dfs1(ll x)
{
	size[x]=1;
	dep[x]=dep[fa[x]]+1;
	for(rg i=head[x];i;i=nxt[i])
	if(to[i]!=fa[x])
	{
		dfs1(to[i]);
		size[x]+=size[to[i]];
		if(size[son[x]]<size[to[i]])son[x]=to[i];
	}
}
int top[maxn],seg[maxn],rev[maxn],dfn;
void dfs2(ll x)
{
	if(son[fa[x]]!=x)top[x]=x;
	else top[x]=top[fa[x]];
	seg[x]=++dfn;
	rev[dfn]=x;
	if(son[x])dfs2(son[x]);
	for(rg i=head[x];i;i=nxt[i])
	if(to[i]!=fa[x]&&to[i]!=son[x])dfs2(to[i]);
}
void push_up(ll x)
{
	gy[x].val=gy[2*x].val+gy[2*x+1].val;
}
void push_down(ll x)
{
	if(gy[x].lazy)
	{
		gy[2*x].lazy+=gy[x].lazy;
		gy[2*x+1].lazy+=gy[x].lazy;
		gy[2*x].val+=(gy[2*x].r-gy[2*x].l+1)*gy[x].lazy;
		gy[2*x+1].val+=(gy[2*x+1].r-gy[2*x+1].l+1)*gy[x].lazy;
		gy[x].lazy=0;
	}
}
void build(ll x,ll l,ll r)
{
	gy[x].l=l;gy[x].r=r;
	if(l==r)return;
	ll mid=(l+r)>>1;
	build(2*x,l,mid);
	build(2*x+1,mid+1,r);
	push_up(x);
}
void modify(ll x,ll l,ll r,ll v)
{
	if(gy[x].l>r||gy[x].r<l)return;
	if(l<=gy[x].l&&gy[x].r<=r)
	{
		gy[x].lazy+=v;
		gy[x].val+=(gy[x].r-gy[x].l+1)*v;
		return;
	}
	push_down(x);
	modify(2*x,l,r,v);
	modify(2*x+1,l,r,v);
	push_up(x);
}
ll query(ll x,ll l,ll r)
{
	if(gy[x].l>r||gy[x].r<l)return 0;
	if(l<=gy[x].l&&gy[x].r<=r)return gy[x].val;
	push_down(x);
	return query(2*x,l,r)+query(2*x+1,l,r);
}
void change(ll u,ll v,ll val)
{
	while(top[u]!=top[v])
	{
		if(dep[top[u]]<dep[top[v]])swap(u,v);
		modify(1,seg[top[u]],seg[u],val);
		u=fa[top[u]];
	}
	if(dep[u]<dep[v])swap(u,v);
	modify(1,seg[v],seg[u],val);
}
ll u,v,d;
char opt[2];
int main()
{
	scanf("%lld",&n);fa[1]=-1;
	for(rg i=1;i<n;i++)
	{
		scanf("%lld%lld",&u,&v);u++;v++;
		add(u,v);add(v,u);
		fa[v]=u;
	}
	dep[1]=1;dfs1(1);dfs2(1);build(1,1,n);
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%s",opt);
		if(opt[0]=='A')
		{
			scanf("%lld%lld%lld",&u,&v,&d);u++;v++;
			change(u,v,d);
		}
		if(opt[0]=='Q')
		{
			scanf("%lld",&u);u++;
			printf("%lld\n",query(1,seg[u],seg[u]+size[u]-1));
		}
	}
	return 0;
}
```

(11-3 modify:图片不小心崩啦)

[my blog](https://www.luogu.com.cn/blog/flowery/)

---

## 作者：UltiMadow (赞：2)

upd: 管理说没代码不好理解，于是我就把代码放上来了（

强烈要求管理卡一卡树剖，因为出题人说正解不是树剖（

大家应该学树状数组的时候都学过如何用树状数组处理区间加区间查的问题 （POJ3468）

做完那个题再做这个题就比较简单了，思想是相同的，都是维护两个树状数组

当我们要修改一条路径 $u\to v$ 的时候，在 $u$ 节点上增加 $d$，在 $v$ 节点上增加 $d$ ，在 $u$ 和 $v$ 的 LCA 减少 $d$，在 LCA 的父亲节点减少 $d$

查询一个节点上的值即为子树和

但是要求查询的是一个节点为根的所有子树的和

发现要求的东西即为 $\sum dep_{u,v}\times tag_u$

$tag_u$ 即为一个节点上的差分值，$dep_{u,v}$ 即为 $u$ 相对于 $v$ 的深度。这里规定 $u$ 相对于 $u$ 的深度为 1

然后转化一下，用一个树状数组记录 $\sum dep_v\times tag_v$

这里 $dep_v$ 指 $v$ 的绝对深度，也就是相对于根节点的深度

另一个树状数组记录 $\sum tag_u$

于是很明显答案就是第一个树状数组的查询结果**减去**第二个树状数组的查询结果 $\times (dep_u-1)$

时间复杂度 $\mathcal O(n\log n)$，常数不大，在目前的评测环境下用 O2 没卡常能到 900 ms 左右，应该优于常数巨大还多一个 $\log$ 的线段树+树剖


（题解中间那一段是从我的做题笔记那里暴力 ctrl+c/v 过来的）

code:
```cpp
#include<bits/stdc++.h>
#define MAXN 100010
#define ll long long
using namespace std;
int n,Q,fa[MAXN],son[MAXN],bro[MAXN];
int in[MAXN],out[MAXN],tot,dep[MAXN];
void dfs(int u){
	in[u]=++tot;dep[u]=dep[fa[u]]+1;
	for(int v=son[u];v;v=bro[v])dfs(v);
	out[u]=tot;
}
namespace LCA{
	int sz[MAXN],hev[MAXN],top[MAXN];
	void dfs1(int u){
		sz[u]=1;int mx=-114514;
		for(int v=son[u];v;v=bro[v]){
			dfs1(v);sz[u]+=sz[v];
			if(mx<sz[v])mx=sz[v],hev[u]=v;
		}
	}
	void dfs2(int u,int ct){
		top[u]=ct;
		if(hev[u])dfs2(hev[u],ct);
		for(int v=son[u];v;v=bro[v])
			if(v!=hev[u])dfs2(v,v);
	}
	int lca(int u,int v){
		while(top[u]!=top[v]){
			if(dep[top[u]]<dep[top[v]])swap(u,v);
			u=fa[top[u]];
		}return dep[u]>dep[v]?v:u;
	}
}
using LCA::dfs1;using LCA::dfs2;using LCA::lca;
struct BIT{
	ll t[MAXN];
	int lowbit(int x){return x&(-x);}
	void update(int x,ll y){for(;x<=n;x+=lowbit(x))t[x]+=y;}
	ll query(int x){
		ll ret=0;
		for(;x;x-=lowbit(x))ret+=t[x];
		return ret;
	}
}T1,T2;
void update(int u,int v,ll d){
	int lc=lca(u,v),lcf=fa[lc];
	T1.update(in[u],d*dep[u]);
	T1.update(in[v],d*dep[v]);
	T1.update(in[lc],-d*dep[lc]);
	T2.update(in[u],d);
	T2.update(in[v],d);
	T2.update(in[lc],-d);
	if(!lcf)return;
	T1.update(in[lcf],-d*dep[lcf]);
	T2.update(in[lcf],-d);
}
ll query(int u){
	ll ret=T1.query(out[u])-T1.query(in[u]-1);
	ret-=(dep[u]-1)*(T2.query(out[u])-T2.query(in[u]-1));
	return ret;
}
char opt[10];
signed main(){
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		int pa,u;scanf("%d%d",&pa,&u);pa++;u++;
		fa[u]=pa;bro[u]=son[pa];son[pa]=u;
	}scanf("%d",&Q);
	dfs(1);dfs1(1);dfs2(1,1);
	while(Q--){
		scanf("%s",opt+1);
		if(opt[1]=='Q'){
			int u;scanf("%d",&u);u++;
			printf("%lld\n",query(u));
		}else{
			int u,v;ll d;scanf("%d%d%lld",&u,&v,&d);
			u++;v++;update(u,v,d);
		}
	}
	return 0;
}
```

---

## 作者：傅思维666 (赞：2)

## 题解：

一道树链剖分的裸题。

当然，倍增LCA的较朴素做法如果数据水一些的话是过不去的，建议大家借此机会学一下树链剖分。

（顺便推下自己讲树链剖分的~~比较好~~的博客,博客阅读口味更佳）：



[浅谈树链剖分](https://www.cnblogs.com/fusiwei/p/11519470.html)



# 浅谈树链剖分

本篇随笔讲解图论中的树链剖分相关内容。

树链剖分是树上问题的极常用操作，可以说不会树链剖分，一半以上的树上难题都毫无思路。其重要性不言而喻。想要流畅阅读本篇博客并学习树链剖分，需要读者具有一定的图论基础，并对树形结构和深搜算法有基本的认识。由于本蒟蒻的水平可能不足支持强大的树剖的讲解，所以题解中的一些不足之处敬请大佬们指正。

---

## 树链剖分的基本概念

树链剖分，顾名思义，就是把树拆成链。根据树的形态，我们可以很容易的发现，任何一棵树都会有很多条链正好把树完全拆分。但是树链剖分并不是单单地把树拆成链。它拆出的链有**“轻重之分”**。

那么什么是轻重链呢？

这就涉及到了树链剖分的一些基本概念名词，如下述。

* **重儿子**：我们知道，除叶子节点之外，每个节点都会有若干个儿子节点，而只要这个节点不是叶子节点，它都是一棵子树的根。那么，这个父亲节点就有很多个儿子，而一定会有一个儿子的儿子最多，也就是子树最大。那么这个儿子节点就叫做$x$的重儿子。
* **轻儿子**：与重儿子对照理解，重儿子是唯一的，除了重儿子之外的所有儿子都是轻儿子。
* **重边**：父节点与重儿子组成的边（需要注意的是，这里的父节点不一定也是重儿子）
* **轻边**：除重边之外的边。
* **重链**：由重边连起来的链叫做重链，特别地，一条重链的顶部是一个轻儿子。
* **轻链**：由轻边连起来的链叫做轻链。

我们可以通过一张图来直观理解：

![](https://img2018.cnblogs.com/blog/1738131/201909/1738131-20190917105354236-601205151.png)



---

## 树链剖分解决的问题

树链剖分是树状结构的操作，自然解决的是树上问题。根据我们以上讲述的基本概念，我们发现我们可以将一棵树进行轻重链的树链剖分。然后我们就可以把一条链上的节点处理成区间的形式（这个理解非常重要！）从而把树上的问题转化成了区间问题进行求解。至于区间问题，我们可以采用一些数据结构求解，比如线段树、树状数组等。

一般来讲，树链剖分可以解决以下问题：

* 修改两点路径上各点的值

* 查询两点路径上各点的值

* 修改某点子树上各点的值

* 查询某点子树上各点的值

* 求解LCA问题

---

## 树链剖分的深搜预处理

根据以上的概念理解，我们会发现，若要求解以上问题，我们用树链剖分的好处就是把树上问题变成区间问题，而区间问题可以用数据结构求解，比如线段树。但是区间需要编号连续，如果用原树的节点编号来进行“区间求解”，那显然是不行的。因为一条链上的节点可能是“3.5.7.8.2.1”这样的乱序，而不是我们想要的一段“连续的数列”，所以这时不能转换成线段树求解。为了让区间连续，我们对整棵树进行**预处理**。

树链剖分的核心操作也是预处理。

对于任意节点$x$，我们通过DFS处理出它的**深度，子树大小，重儿子编号和父节点编号**。这些东西可以用一次深搜处理出来。实质上就是一个树上遍历的过程。

我们用$deep[]$表示深度，$size[]$表示子树大小，$son[]$表示重儿子是谁（编号），以及$fa[]$表示父节点是谁（编号）。

代码：

```cpp
void dfs1(int x,int f)
{
    fa[x]=f;
    size[x]=1;
    deep[x]=deep[f]+1;
    for(int i=head[x];i;i=nxt[i])
    {
        int y=to[i];
        if(y==f)
            continue;
        dfs1(y,x);
        size[x]+=size[y];
        if(son[x]==0 || size[y]>size[son[x]])
            son[x]=y;
    }
}
```

但是为了进行树链剖分的相关操作，仅仅处理出这些数据是远远不够的。因为有了这些数据，我们只知道了重链的相关信息，却依然不能维护出我们需要的那段“连续的区间”。所以，我们需要第二遍深搜。

如何在深搜中保证链上节点编号连续呢？

根据深搜的性质和重链的性质，我们已经可以隐隐约约的猜到：用**DFS序**即可。

也就是说，我们必然会进行第二遍DFS，而第二遍DFS要处理出的东西就是：**每条链的顶端节点，每个点的DFS序新编号**。

我们用$top[]$数组表示每个节点所在链的顶端是谁，$id[]$数组表示节点的DFS序新编号。

所以有了以下代码：

```cpp
void dfs2(int x,int t)
{
    id[x]=++cnt;
    top[x]=t;
    if(!son[x])
        return;
    dfs2(son[x],t);
    for(int i=head[x];i;i=nxt[i])
    {
        int y=to[i];
        if(y==fa[x] || y==son[x])
            continue;
        dfs2(y,y);
    }
}
```

这里有必要说明一下：

我们先处理重儿子后处理轻儿子。

为什么呢？

因为我们最终的目的是把链的新的DFS编号变成连续的。这样，我们先处理重链再处理轻链，就能做到：每一条重链上的编号是连续的，同时，每一棵子树上的编号也是连续的。

以上就是树链剖分的核心操作：预处理~~（预处理竟然变成了核心操作）~~

---

## 树链剖分操作详解

之后我们回顾一下树链剖分所解决的问题：

* 修改两点路径上各点的值

* 查询两点路径上各点的值

* 修改某点子树上各点的值

* 查询某点子树上各点的值

通过刚才的预处理，我们已经把树上节点的新编号变成了连续的。然后我们就可以针对区间（链）把原树变成线段树来进行我们要做的一系列操作。

先来一份线段树的基本代码：

(包括建树、递归修改、递归查询、lazy标记)

```cpp
void build(int pos,int l,int r)
{
    int mid=(l+r)>>1;
    if(l==r)
    {
        tree[pos]=w[l];
        return;
    }
    build(lson,l,mid);
    build(rson,mid+1,r);
    tree[pos]=(tree[lson]+tree[rson]);
}
void mark(int pos,int l,int r,int k)
{
    tree[pos]+=(r-l+1)*k;
    lazy[pos]+=k;
}
void pushdown(int pos,int l,int r)
{
    int mid=(l+r)>>1;
    mark(lson,l,mid,lazy[pos]);
    mark(rson,mid+1,r,lazy[pos]);
    lazy[pos]=0;
}
void update(int pos,int l,int r,int x,int y,int k)
{
    int mid=(l+r)>>1;
    if(x<=l && r<=y)
    {
        mark(pos,l,r,k);
        return;
    }
    pushdown(pos,l,r);
    if(x<=mid)
        update(lson,l,mid,x,y,k);
    if(y>mid)
        update(rson,mid+1,r,x,y,k);
    tree[pos]=(tree[lson]+tree[rson]);
}
int query(int pos,int l,int r,int x,int y)
{
    int mid=(l+r)>>1;
    int ret=0;
    if(x<=l && r<=y)
        return tree[pos];
    pushdown(pos,l,r);
    if(x<=mid)
        ret+=query(lson,l,mid,x,y);
    if(y>mid)
        ret+=query(rson,mid+1,r,x,y);
    return ret;
}
```

如果读者已经对线段树非常熟悉，那么就会发现：在经过树链剖分的预处理之后，对于上述的4个操作，我们只需要把节点的新编号（新编号在树上是按链连续的）映射到一个数列上，然后对数列进行线段树的上述操作即可。

---

### 树链剖分求LCA

讲这个是为了为下面的链上修改做铺垫。

树链剖分求LCA是比较快速的做法，它的实现原理也比较好理解：

我们每次求LCA（x,y）的时候就可以判断两点是否在同一链上

如果两点在同一条链上我们只要找到这两点中深度较小的点输出就行了~~（废话）~~

如果两点不在同一条链上：

那就找到深度较大的点令它等于它所在的链顶端的父节点即为x=fa[top[x]]：

直到两点到达同一条链上，输出两点中深度较小的点即可。

---

### 链上修改

对于一个修改任意两点最短路径上的所有点的操作，我们的一个朴素思路是求出两点的LCA，然后进行修改。

这就是为什么讲树链剖分求LCA。因为链上修改是基于求LCA操作的。

相比于树链剖分求LCA，链上修改只是加了个线段树的操作而已。

或许代码能帮你理解一下：

```cpp
void upd_chain(int x,int y,int k)
{
    while(top[x]!=top[y])
    {
        if(deep[top[x]]<deep[top[y]])
            swap(x,y);
        update(1,1,n,id[top[x]],id[x],k);//attention
        x=fa[top[x]];
    }
    if(deep[x]<deep[y])
        swap(x,y);
    update(1,1,n,id[y],id[x],k);//attention
}
```

#### ATTENTION

这里需要注意的是update时的节点编号问题，以为重新编号是基于DFS序的基础的，所以根据深搜的性质，每个节点的$top[]$肯定要比这个节点的新编号小。

下面的$id[x],id[y]$也是这个道理，**千万不要写反**！！

---

### 链上查询

链上查询的基本实现思路与链上修改大同小异。

直接放代码：

```cpp
int q_chain(int x,int y)
{
    int ret=0;
    while(top[x]!=top[y])
    {
        if(deep[top[x]]<deep[top[y]])
            swap(x,y);
        (ret+=query(1,1,n,id[top[x]],id[x]))%=mod;
        x=fa[top[x]];
    }
    if(deep[x]<deep[y])
        swap(x,y);
    (ret+=query(1,1,n,id[y],id[x]))%=mod;
    return ret;
}
```

---

### 树上修改/查询

树上修改/查询并不需要那么复杂的操作。我们进行树上修改/查询主要运用了树链剖分的一个性质：

以某一个节点为根的子树编号是这个节点+这个节点的$size[]$-1.

即新树映射到数列上，一棵子树所占的区间是：$[id[x],id[x]+size[x]-1]$.

这样就很容易写树上修改/查询的代码了：

```cpp
void upd_subtree(int x,int k)
{
    update(1,1,n,id[x],id[x]+size[x]-1,k);
}
int q_subtree(int x)
{
    return query(1,1,n,id[x],id[x]+size[x]-1);
}
```

---

在这里再向大家推荐模板例题：洛谷3384

[题目传送门](https://www.cnblogs.com/fusiwei/p/11529844.html)

熟练运用树链剖分并解决实际问题是一个提高组/省选选手所必须的一个素质。希望这篇随笔能帮到正在$OI$路上奋斗的你（耶比）。



## 本题代码在这！！

再赋上本题的代码：

顺便赋上自己丑陋的代码：

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define int long long
#define lson pos<<1
#define rson pos<<1|1
using namespace std;
const int maxn=1e5+1;
int n,tot,cnt,q;
int head[maxn],nxt[maxn<<1],to[maxn<<1];
int fa[maxn],deep[maxn],size[maxn],son[maxn];
int id[maxn],top[maxn];
int tree[maxn<<2],lazy[maxn<<2];
void add(int x,int y)
{
    to[++tot]=y;
    nxt[tot]=head[x];
    head[x]=tot;
}
void dfs1(int x,int f)
{
    deep[x]=deep[f]+1;
    fa[x]=f;
    size[x]=1;
    for(int i=head[x];i;i=nxt[i])
    {
        int y=to[i];
        if(y==f)
            continue;
        dfs1(y,x);
        size[x]+=size[y];
        if(!son[x]||size[son[x]]<size[y])
            son[x]=y;
    }
}
void dfs2(int x,int t)
{
    id[x]=++cnt;
    top[x]=t;
    if(!son[x])
        return;
    dfs2(son[x],t);
    for(int i=head[x];i;i=nxt[i])
    {
        int y=to[i];
        if(y==fa[x]||y==son[x])
            continue;
        dfs2(y,y);
    }
}
void mark(int pos,int l,int r,int k)
{
    tree[pos]+=(r-l+1)*k;
    lazy[pos]+=k;
}
void pushdown(int pos,int l,int r)
{
    int mid=(l+r)>>1;
    mark(lson,l,mid,lazy[pos]);
    mark(rson,mid+1,r,lazy[pos]);
    lazy[pos]=0;
}
void update(int pos,int l,int r,int x,int y,int k)
{
    int mid=(l+r)>>1;
    if(x<=l && r<=y)
    {
        mark(pos,l,r,k);
        return;
    }
    pushdown(pos,l,r);
    if(x<=mid)
        update(lson,l,mid,x,y,k);
    if(y>mid)
        update(rson,mid+1,r,x,y,k);
    tree[pos]=tree[lson]+tree[rson];
}
void upd_chain(int x,int y,int k)
{
    while(top[x]!=top[y])
    {
        if(deep[top[x]]<deep[top[y]])
            swap(x,y);
        update(1,1,n,id[top[x]],id[x],k);
        x=fa[top[x]];
    }
    if(deep[x]<deep[y])
        swap(x,y);
    update(1,1,n,id[y],id[x],k);
}
int query(int pos,int l,int r,int x,int y)
{
    int ret=0;
    int mid=(l+r)>>1;
    if(x<=l && r<=y)
        return tree[pos];
    pushdown(pos,l,r);
    if(x<=mid)
        ret+=query(lson,l,mid,x,y);
    if(y>mid)
        ret+=query(rson,mid+1,r,x,y);
    return ret;
}
int q_subtree(int x)
{
    return query(1,1,n,id[x],id[x]+size[x]-1);
}
signed main()
{
    scanf("%lld",&n);
    for(int i=1;i<n;i++)
    {
        int x,y;
        scanf("%lld%lld",&x,&y);
        x++,y++;
        add(x,y);
        add(y,x);
    }
    dfs1(1,0);
    dfs2(1,1);
    scanf("%lld",&q);
    while(q--)
    {
        char k;
        cin>>k;
        if(k=='A')
        {
            int x,y,d;
            scanf("%lld%lld%lld",&x,&y,&d);
            x++,y++;
            upd_chain(x,y,d);
        }
        else
        {
            int x;
            scanf("%lld",&x);
            x++;
            printf("%lld\n",q_subtree(x));
        }
    }
    return 0;
}
```

---

## 作者：Zxsoul (赞：1)

## 题面

>树链剖分板子题目

>路径修改 ，子树查询

## 思路

- 题目明确，值得关注的点是子树的更改是在**点**上，比较好实现 

- 其次树是从 $0$ 号点开始，在记录的时候每个数都加 $1$ 即可

## 算法介绍

- 帮助读者更好的理解代码

- 预处理 $01$

```cpp
void dfs1(int u,int pre,int d){//预处理父亲节点，重儿子,深度 
    fa[u] = pre ;size_[u] = 1 ;dep[u] = d;
    for (int i = head[u] ;i ;i = e[i].nxt){
        int v = e[i].v;
        if(v != pre){
            dfs1(v,u,d+1);//先搜后家 
            size_[u]+=size_[v];//得到当前节点u的子树个数 
            if(!hson[u] || size_[hson[u]]<size_[v]){
                hson[u] = v;//更新重儿子 
            }
        }
    }
}
```
- 预处理 $02$

```cpp
void dfs2(int u,int top){//寻找重链，（删链操作）， 
    tp[u] = top;//链顶 
    l[u] = ++js;// dfsn,对应的序号 
    pre[js] = u;//对应序号的数，主要放在线段数上 
    if(!hson[u])return;
    dfs2(hson[u],top);// 沿着重儿子一直神搜下去，找到顶点的重链 
    for(int i = head[u];i;i = e[i].nxt){//完成重链后去找轻链 
        int v = e[i].v;
        if(v!=hson[u]&&v!=fa[u]){
            dfs2(v,v);//新的重链 
        }
    }
}

```

- 路径修改（包含边权修改，用兴趣的可起去了解一下）

```cpp
void path_add(int u,int v,int w){//链修改 
    
    while(tp[u]!=tp[v]){//以链顶深度更深的往上跳 
        if(dep[tp[u]] < dep[tp[v]]) swap(u,v);//都操作同一个变量，方便书写 
        Seg::all_date(1,l[tp[u]],l[u],w);//更深的链先操作 
        u = fa[tp[u]];//链顶的父亲， 
    }
    if(dep[u] > dep[v]) swap(u,v);//最后在同一链上，交换的原因同上 
    Seg::all_date(1,l[u],l[v],w);//点权写法 
     /*
        Seg::all_date(1,l[u]+1,l[v],w)
        求的是当前 u-v 的距离或最值，而l[u]表示u点的上一条边 
        边权写法，（每个点记录的是连接他父亲的边） 
    */ 
}
```
## 正解代码

```cpp
//不可以 copy ~~~
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <vector>
using namespace std;
#define int long long

const int manx=1e6+10;
const int mamx = 1e6 + 11;
const int mod = 2123400401301379571;
const int inf = 0x3f3f3f3f;

inline int read() {
  char c = getchar(); int x = 0, f = 1;
  for ( ; !isdigit(c); c = getchar()) if (c == '-') f = -1;
  for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
  return x * f;
}
struct node{
	int v,nxt,w;
}e[manx<<1];
int head[manx],cnt,n,m,val[manx],pr[manx],dfn[manx],pre[manx],fa[manx],dep[manx],size_[manx],hson[manx];
void add(int u,int v){
	e[++cnt].v = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}
namespace Tree{
	#define ls i<<1
	#define rs i<<1|1
	struct tree{
		int r;
		int l;
		int sum;
		int lazy;
	}tr[manx<<2];
	inline void up(int i){
	  tr[i].sum = tr[ls].sum + tr[rs].sum ;
	}
	inline void down(int i){
		if(tr[i].lazy){
			int x = tr[i].lazy;
			tr[ls].sum += (tr[ls].r - tr[ls].l + 1) * x;
			tr[rs].sum += (tr[rs].r - tr[rs].l + 1) * x;
			tr[ls].lazy += x;
			tr[rs].lazy += x;
			tr[i].lazy = 0;
 		}
	}
	inline void build(int i,int l,int r){
		tr[i].l = l;tr[i].r = r;
		if(l == r){
			tr[i].sum = val[pre[l]];
			return;
		}
		int mid = (l + r) >> 1;
		build(ls,l,mid);
		build(rs,mid+1,r);
		up(i);
	}
	inline void all_add(int i,int l,int r,int x){
		if(tr[i].l >= l && tr[i].r <= r){
			tr[i].sum += (tr[i].r - tr[i].l + 1) * x;
			tr[i].lazy += x;
			return;
		}
		down(i);
		int mid = (tr[i].r + tr[i].l ) >> 1;
		if(mid >= r) all_add(ls,l,r,x);
		else if(mid < l) all_add(rs,l,r,x);
		else all_add(ls,l,mid,x),all_add(rs,mid+1,r,x);
		up(i);
	}
	inline int query(int i,int l,int r){
		if(tr[i].l >= l && tr[i].r <= r){
			return tr[i].sum;
		}
		down(i);
		int mid = (tr[i].r + tr[i].l ) >> 1;
		if(mid >= r) return query(ls,l,r);
		else if(mid < l) return query(rs,l,r);
		else return query(ls,l,mid) + query(rs,mid+1,r);
	//	up(i);
	}
}
namespace Seg{
	int js = 0;
	inline void dfs1(int u,int pre,int d){
		fa[u] = pre;size_[u] = 1;dep[u] = d;
		for(int i = head[u]; i ;i = e[i].nxt){
			int v = e[i].v;
			if(v != pre){
				dfs1(v,u,d+1);
				size_[u] += size_[v];
				if(!hson[u] || size_[hson[u]] < size_[v]){
					hson[u] = v;
				}
			}
		}
	}
	inline void dfs2(int u,int p){
		pr[u] = p;
		dfn[u] = ++js;
		pre[js] = u;
		if(!hson[u]) return;
		dfs2(hson[u],p);
		for(int i = head[u];i;i = e[i].nxt){
			int v = e[i].v ;
			if(v != fa[u] && v != hson[u]){
				dfs2(v,v);
			}
		} 
	}
	inline void add(int u,int v,int x){
		while(pr[u] != pr[v]){
			if( dep[pr[u]] < dep[pr[v]])swap(u,v);
			Tree::all_add(1,dfn[pr[u]],dfn[u],x);
			u = fa[pr[u]];
		}
		if(dep[u] > dep[v]) swap(u,v);
		Tree::all_add(1,dfn[u],dfn[v],x);
	}
}
 main(){
	n = read();
	for(int i = 1,x,y;i < n; i++){
		x = read()+1,y = read()+1;
		add(x,y);
		add(y,x);
	}
	//cout<<1<<endl;
	Seg::dfs1(1,0,1),Seg::dfs2(1,1),Tree::build(1,1,n);
	m = read();
	for(int i = 1;i <= m; i++){
		char a;
		int b,c,d;
		cin >> a;
		if(a == 'A'){
			b = read()+1;
			c = read()+1;
			d = read();	
			Seg::add(b,c,d);
		}else{
		
			d = read()+1;
			cout<<Tree::query(1,dfn[d],dfn[d] + size_[d] - 1)<<endl;
		}
	}
	return 0;
}


```




---

## 作者：KEBrantily (赞：1)

## Description

树链剖分板子题

考查两种操作

- **A u v w** 把 u 节点到 v 节点路径上所有节点权值加 w
- **Q u** 求以 u 为根节点的子树权值之和


------------
首先需要了解线段树和 dfs 序，我这里没有很好的链接，不熟悉的再自行百度吧

另外了解树链剖分的思想（重儿子等等），否则会出很多千奇百怪的错误


------------
### 树链剖分的构成

 
DFS1 来处理每个点的深度，他的父节点以及他的重儿子

DFS2 来处理每条链的链顶，每个点的 dfs 序和他们的 pre（建树时用）

然后就是各种操作函数

------------

这里就不止说这个题了，顺便说一下树链剖分的其他几种操作

线段树也有很多操作，一些题可能会同时考到

但线段树就不说了，回去翻板子题的教程吧

分享几个树剖典型题目 **[P2590](https://www.luogu.com.cn/problem/P2590)** **[P3178](https://www.luogu.com.cn/problem/P3178)** 和 **[P4315](https://www.luogu.com.cn/problem/P4315#submit)**

------------
## Solution

### 操作一   区间加

树链剖分最常用操作之一
```cpp
void change1(int x,int y,int val){
		while(top[x]!=top[y]){
		    if(depth[top[x]]<depth[top[y]]) swap(x,y);
			update(1,1,n,val,dfn[top[x]],dfn[x]);
			x=fa[top[x]];
		}
		if(dfn[x]>dfn[y]) swap(x,y);
		update(1,1,n,val,dfn[x],dfn[y]);
	}
```

### 操作二 区间求和
```cpp
int qsum1(int x,int y){
		int ans=0;
		while(top[x]!=top[y]){
		    if(depth[top[x]]<depth[top[y]]) swap(x,y);
			ans+=query(1,1,n,dfn[top[x]],dfn[x]);
			x=fa[top[x]];
		}
		if(dfn[x]>dfn[y]) swap(x,y);
		ans+=query(1,1,n,dfn[x],dfn[y]);
		return ans; 
	}
```

### 操作三 区间取最大值
```cpp
int qmax(int x,int y){
		int ans=-101010101;
		while(top[x]!=top[y]){
		    if(depth[top[x]]<depth[top[y]]) swap(x,y);
			ans=max(ans,qmax(1,1,n,dfn[top[x]],dfn[x]));
			x=fa[top[x]];
		}
		if(dfn[x]>dfn[y]) swap(x,y);
		ans=max(ans,qmax(1,1,n,dfn[x],dfn[y]));
		return ans; 
	}
```
取最小值也是一样的

不过建树的时候注意处理最大值

### 操作四 子树上加
在以某点为根节点的子树上加值
```cpp
	void change2(int x,int val){update(1,dfn[x],dfn[x]+size[x]-1,val,1,n);}

```
看起来很简单对吧，其实只需要知道他的思想就好了

### 操作五 子树取和
```cpp
	int qsum2(int x){return query(1,dfn[x],dfn[x]+size[x]-1,1,n);}

```
------------
这是我见的比较常用的几种操作

而且一些树链剖分的操作是不用专门来写函数的

就像上面的子树上操作一样

------------
## Code

再给下本题的代码，其实不是很必要了

没写注释，大家将就看吧

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<queue>
#include<cmath>
#define maxn 10001000
#define INF 0x3f3f3f3f
#define int long long
#define lson x<<1
#define rson x<<1|1

using namespace std;

char s;
int n,q,cnt,tot,lazy[maxn],head[maxn],sum[maxn],a[maxn],size[maxn],dfn[maxn],depth[maxn],top[maxn],fa[maxn],pre[maxn],mmax[maxn],son[maxn];

struct edge{int fr,to,nxt;}e[maxn*2];

void addedge(int fr,int to){e[++tot].to=to;e[tot].nxt=head[fr];head[fr]=tot;}

int read(){
	int s=0,w=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
	while(ch>='0' &&ch<='9'){s=(s<<1)+(s<<3)+ch-'0';ch=getchar();}
	return s*w;
}

namespace Seg{
	void pushup(int x){sum[x]=sum[lson]+sum[rson];}
	
	void pushdown(int x,int ln,int rn){
		if(lazy[x]){
		    lazy[lson]+=lazy[x];
			lazy[rson]+=lazy[x];
			sum[lson]+=lazy[x]*ln;
			sum[rson]+=lazy[x]*rn;
			lazy[x]=0;
		}
	}
	
	void build(int x,int l,int r){
		lazy[x]=0;
		if(l==r){sum[x]=0;return;}
		int mid=(l+r)>>1;
		build(lson,l,mid);build(rson,mid+1,r);
		pushup(x); 
	}
	
	void update(int x,int l,int r,int val,int L,int R){
		if(L<=l &&r<=R){sum[x]+=(r-l+1)*val;lazy[x]+=val;return;}
		int mid=(l+r)>>1;
		pushdown(x,mid-l+1,r-mid);
		if(L<=mid) update(lson,l,mid,val,L,R);
		if(R>mid) update(rson,mid+1,r,val,L,R);			
		pushup(x);
	}
	
	int query(int x,int l,int r,int L,int R){
		if(L<=l &&r<=R) return sum[x];
		int ans=0;
		int mid=(l+r)>>1;
		pushdown(x,mid-l+1,r-mid);
        if(l>R||r<L) return 0;
		if(L<=mid) ans+=query(lson,l,mid,L,R);
		if(R>mid) ans+=query(rson,mid+1,r,L,R);
		return ans;
	}
}

namespace Cut{
	void dfs1(int x,int fat){
		size[x]=1;depth[x]=depth[fat]+1;fa[x]=fat;
		for(int i=head[x];i;i=e[i].nxt){
			int to=e[i].to;
			if(to==fat) continue;
			dfs1(to,x);
			size[x]+=size[to];
			if(size[son[x]]<size[to]) son[x]=to;
		}
	}
	
	void dfs2(int x,int tp){
		top[x]=tp;dfn[x]=++cnt;pre[cnt]=x;
		if(son[x]) dfs2(son[x],tp);
		for(int i=head[x];i;i=e[i].nxt){
			int to=e[i].to;
			if(to==son[x]||to==fa[x]) continue;
			dfs2(to,to);
		}
	}
	
	void change1(int x,int y,int val){
		while(top[x]!=top[y]){
		    if(depth[top[x]]<depth[top[y]]) swap(x,y);
			Seg::update(1,1,n,val,dfn[top[x]],dfn[x]);
			x=fa[top[x]];
		}
		if(dfn[x]>dfn[y]) swap(x,y);
		Seg::update(1,1,n,val,dfn[x],dfn[y]);
	}
	
	int qsum1(int x,int y){
		int ans=0;
		while(top[x]!=top[y]){
		    if(depth[top[x]]<depth[top[y]]) swap(x,y);
			ans+=Seg::query(1,1,n,dfn[top[x]],dfn[x]);
			x=fa[top[x]];
		}
		if(dfn[x]>dfn[y]) swap(x,y);
		ans+=Seg::query(1,1,n,dfn[x],dfn[y]);
		return ans; 
	}
	
	void change2(int x,int val){Seg::update(1,1,n,val,dfn[x],dfn[x]+size[x]-1);}
	int qsum2(int x){return Seg::query(1,1,n,dfn[x],dfn[x]+size[x]-1);}
}

signed main(){
	n=read();
//	for(int i=1;i<=n;i++) a[i]=i-1;
	for(int i=1,fs,es;i<n;i++){fs=read()+1;es=read()+1;addedge(fs,es);addedge(es,fs);}
	Cut::dfs1(1,0);Cut::dfs2(1,1);Seg::build(1,1,n);
	q=read();
	for(int i=1,fs,es,ds;i<=q;i++){
	    cin>>s;
	    if(s =='A'){
	    	fs=read()+1;es=read()+1;ds=read();
			Cut::change1(fs,es,ds); 
		}
		if(s =='Q'){
			fs=read()+1;
			printf("%lld\n",Cut::qsum2(fs));
		}
	}
	return 0;
}
```

**ps：**

本题每个点的初始权值是 0 ，序号是 1 到 n，

我看成了初始权值为 1 到 n ，然后就 D 了好久 

另外注意编号从 0 开始，要在输入加边或者 dfs 建树的地方处理一下

------------

希望对大家有帮助

---

## 作者：日月影 (赞：1)

没有题解，水一波

这道题很明显是树剖 23333

不会，请自行百度  （树链剖分）

first  处理出各个点的重儿子，以这个点为根的子树大小，深度，以这个点沿重链向上爬的最老祖先。最重要的是处理dfs序

然后
对于u，v之间的路径   如果 top[u]!=top[v]  就让top的深度大的往上爬，直到top[u]==top[v]   ,在爬的途中，以线段树维护【top[x],x】的值就好了

总之，只要理解了树剖，这道题就迎刃而解了

代码如下：




        
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
struct data
{
    int pre,to;
}p[220010];
int head[200100],tot;
int n;
int son[200100],siz[200100],father[200100];
int deep[200100];
int top[200100];  
int in[200100],num;  //i在dfs序 中的位置 
long long s[400100];  //线段树 
long long tag[400100];
void add(int x,int y)
{
    p[++tot].pre=head[x];
    p[tot].to=y;
    head[x]=tot;
}
void dfs(int x)
{
    siz[x]++;
    for(int i=head[x];i;i=p[i].pre)
    {
        int v=p[i].to;
        deep[v]=deep[x]+1;
        dfs(v);
        siz[x]+=siz[v];
        if(son[x]==0||siz[v]>siz[son[x]])  son[x]=v;
    }
}
void dfs2(int x)   //找top是关键 
{
    in[x]=++num;
    if(son[x]>0)
    top[son[x]]=top[x],dfs2(son[x]);
    for(int i=head[x];i;i=p[i].pre)
    {
        int v=p[i].to;
        if(v!=son[x])
        {
            top[v]=v;
            dfs2(v);
        }
    }
}
void df(int rt,int l,int r)
{
    if(tag[rt])
    {
        int mid=(l+r)>>1;
        long long t=tag[rt];
        tag[rt]=0;
        s[rt<<1]+=(mid-l+1)*t;
        s[rt<<1|1]+=(r-mid)*t;
        tag[rt<<1]+=t;
        tag[rt<<1|1]+=t;
    }
}
void addans(int rt,int l,int r,int x,int y,int z)
{
    if(l>=x&&y>=r)  tag[rt]+=z*1ll,s[rt]+=1ll*(r-l+1)*z;
    else
    {
        int mid=(l+r)>>1;
        df(rt,l,r);
        if(x<=mid)  addans(rt<<1,l,mid,x,y,z);
        if(y>mid)  addans(rt<<1|1,mid+1,r,x,y,z);
        s[rt]=s[rt<<1]+s[rt<<1|1];
    }
}
void hp(int x,int y,int z)
{
    while(top[x]!=top[y])
    {
        if(deep[top[x]]>deep[top[y]])
        {
            addans(1,1,n,in[top[x]],in[x],z);
            x=father[top[x]];
        }
        else
        {
            addans(1,1,n,in[top[y]],in[y],z);
            y=father[top[y]];
        }
    }
    if(deep[x]>deep[y])    //这一步必不可少 
    {
        addans(1,1,n,in[y],in[x],z);
    }
    else
    {
        addans(1,1,n,in[x],in[y],z);
    }
}
long long Query(int x,int y,int l,int r,int rt)
{
    if(l>=x&&r<=y)  return s[rt];
    else
    {
        int mid=(l+r)>>1;
        df(rt,l,r);
        long long ans=0;
        if(x<=mid)  ans+=Query(x,y,l,mid,rt<<1);
        if(y>mid)  ans+=Query(x,y,mid+1,r,rt<<1|1);
        return ans;
    }
}
int main()
{
    scanf("%d",&n);
    int x,y,z;
    for(int i=1;i<=n-1;i++)
    {
        scanf("%d%d",&x,&y);
        father[y]=x;
        add(x,y);
    }
    dfs(0);
    top[0]=0;
    dfs2(0);
    int q;
    scanf("%d",&q);
    char c;
    for(int i=1;i<=q;i++)
    {
        cin>>c;
        if(c=='A')  
        {
            scanf("%d%d%d",&x,&y,&z);
            hp(x,y,z);
        }
        else
        {
            scanf("%d",&x);
            printf("%lld\n",Query(in[x],in[x]+siz[x]-1,1,n,1));
        }
    }
    return 0;
}

```

---

## 作者：1234KID (赞：1)

树链剖分+线段树。

我们可以发现，以某个点为根的子树的编号，在线段树上是连续的一段。（想一想，为什么）

然后然后就是树剖模板题了。


（代码，自己码吧！）

（为什么这题评分这么难啊？）


---

## 作者：Suzt_ilymtics (赞：0)


看题面这么有意思~~相对而言~~，结果是个模板题（又可以水经验了呢

无良宣传一下自己的博客，希望有所帮助

[树链剖分](https://www.cnblogs.com/Silymtics/p/13868056.html)


# Solution

分为两个操作，咱们分开来看

## ‘A’操作

将点 $u$ 和 $v$ 之间的路径上的所有节点的果子个数都加上 $d$

树链剖分模板操作，直接搞就好了

## ‘Q’操作

和模板题不同的是，这个操作求的是子树个，想一想我们在初始化的时候是怎么遍历的

"dfs到一个节点，把它的儿子都遍历一遍，然后统计一下该节点的大小"

看，在dfs序上，我们把它们的儿子放在了一起，并且长度是这棵子树的根节点的大小，所以直接在线段树上区间求和就好了

# AC代码

（我知道你们最想看这，但懂了上面的思路应该能自己打出来）

```cpp
/*
Work by: Suzt_ilymics
Knowledge: ??
Time: O(??)
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#define int long long
using namespace std;
const int MAXN = 1e5+5;

int n, Q, cnt;
int fath[MAXN], dfn[MAXN], pre[MAXN], top[MAXN], siz[MAXN], dep[MAXN], son[MAXN];

int read(){
    int w = 1, s = 0;
    char ch = getchar();
    while(ch < '0' || ch > '9') { if(ch == '-') w = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + ch - '0', ch = getchar();
    return s * w;
}

namespace Seg{
    #define lson i << 1
    #define rson i << 1 | 1
    struct Tree{
        int len, lazy, sum;
    }tree[MAXN << 2];
    void push_up(int i){
        tree[i].sum = tree[lson].sum + tree[rson].sum;
        return ;
    }
    void push_down(int i){
        if(tree[i].lazy){
            tree[lson].lazy += tree[i].lazy;
            tree[rson].lazy += tree[i].lazy;
            tree[lson].sum += tree[lson].len * tree[i].lazy;
            tree[rson].sum += tree[rson].len * tree[i].lazy;
            tree[i].lazy = 0;
        }
        return ;
    }
    void build(int i, int l, int r){
        tree[i].len = r - l + 1;
        tree[i].lazy = 0;
        if(l == r){ tree[i].sum = 0; return ;}
        int mid = (l + r) >> 1;
        build(lson, l, mid), build(rson, mid + 1, r);
        push_up(i);
        return ;
    }
    void add(int i, int l, int r, int L, int R, int k){
        if(L <= l && r <= R){
            tree[i].sum += tree[i].len * k;
            tree[i].lazy += k;
            return ;
        }
        push_down(i);
        int mid = (l + r) >> 1;
        if(mid >= L) add(lson, l, mid, L, R, k);
        if(mid < R) add(rson, mid + 1, r, L, R, k);
        push_up(i);
        return ;
    }
    int get_sum(int i, int l, int r, int L, int R){
        if(L <= l && r <= R){
            return tree[i].sum; 
        }
        push_down(i);
        int mid = (l + r) >> 1, ans = 0;
        if(mid >= L) ans += get_sum(lson, l, mid, L, R);
        if(mid < R) ans += get_sum(rson, mid + 1, r, L, R);
        return ans;
    }
}

namespace Cut{
    struct edge{
        int to, nxt;
    }e[MAXN << 1];
    int head[MAXN], num_edge;
    void add_edge(int from ,int to){
        e[++num_edge] = (edge){to, head[from]}, head[from] = num_edge;
    }
    void dfs(int x, int fa){
        siz[x] = 1, fath[x] = fa, dep[x] = dep[fa] + 1;
        for(int i = head[x]; i; i = e[i].nxt){
            int v = e[i].to;
            if(v == fa) continue;
            dfs(v, x);
            siz[x] += siz[v];
            if(siz[v] > siz[son[x]]){ son[x] = v; }
        }
    }
    void dfs2(int x, int tp){
        dfn[x] = ++cnt, pre[cnt] = x, top[x] = tp;
        if(son[x]) dfs2(son[x], tp);
        for(int i = head[x]; i; i = e[i].nxt){
            int v = e[i].to;
            if(v == fath[x] || v == son[x]) continue;
            dfs2(v, v);//
        }
    }
    void change(int x, int y, int k){
        while(top[x] != top[y]){
            if(dep[top[x]] < dep[top[y]]){ swap(x, y); }
            Seg::add(1, 1, n, dfn[top[x]], dfn[x], k);
            x = fath[top[x]];
        }
        if(dep[x] > dep[y]) swap(x, y);
        Seg::add(1, 1, n, dfn[x], dfn[y], k);
    }
}

signed main(){
    n = read();
    for(int i = 1, u, v; i < n; ++i){
        u = read(), v = read();
        Cut::add_edge(u + 1, v + 1), Cut::add_edge(v + 1, u + 1);
    }
    Cut::dfs(1, 0), Cut::dfs2(1, 1), Seg::build(1, 1, n);
    Q = read();
    for(int i = 1, x, y, k; i <= Q; ++i){
        char opt;
        cin>>opt;
        if(opt == 'A'){
            x = read() + 1, y = read() + 1, k = read();
            Cut::change(x, y, k);
        }
        if(opt == 'Q'){
            x = read() + 1;
            printf("%lld\n", Seg::get_sum(1, 1, n, dfn[x], dfn[x] + siz[x] - 1));
        }
    }
    return 0;
}
```

最后推荐几个例题：

[P4315 月下毛景树](https://www.luogu.com.cn/problem/P4315)

[P2590 树的统计](https://www.luogu.com.cn/problem/P2590)

[P3178 树上操作](https://www.luogu.com.cn/problem/P3178)

树链剖分虽然码量大，但在树上操作确实有优势，

建议在刚开始学的时候要多打几遍，不要总想着复制以前的代码~~说的就是我~~，

可以帮助加深理解，提高码速，（~~顺便还能把线段树练了~~）

---

## 作者：Link_Space (赞：0)

其实就是一道树剖的模板，没有什么多说的，只要会打树剖就能秒这道题，但是树剖里面还是有许多需要注意的东西，不然很有可能会调几个小时都找不到错在哪里，以下是代码，刚学树剖或者找不出代码错误的大佬们可以看看，内含详细注释。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
typedef long long ll;
struct node{
    int lef;
    int rig;
    ll sum;//区间内果子和
    ll aim;//pushdown懒标记
} Tree[1000000];
int n;
int head[1000000];
int nxt[1000000];
int ver[1000000];
int cnt;
int idx;
int id[1000000];
int siz[1000000];
int top[1000000];
int dep[1000000];
int father[1000000];
int son[1000000];
void add(int x,int y)
{
    nxt[++cnt] = head[x];
    head[x] = cnt;
    ver[cnt] = y;
}
void dfs1(int now,int fa,int depth)
{
    father[now] = fa;
    dep[now] = depth;
    siz[now] = 1;
    for (int i = head[now]; i;i=nxt[i])
    {
        int v0 = ver[i];
        if(v0==fa)
            continue;
        dfs1(v0, now, depth + 1);
        siz[now] += siz[v0];
        if(siz[son[now]]<siz[v0])
            son[now] = v0;//子树最大的即为该节点的重儿子
    }
}
void dfs2(int now,int t)
{
    top[now] = t;//该节点所处的链的链顶
    id[now]=++idx;
    if(!son[now])
        return;
    dfs2(son[now], t);//搜索重儿子
    for (int i = head[now]; i;i=nxt[i])
    {
        int v0 = ver[i];
        if(v0==father[now]||v0==son[now])
            continue;
        dfs2(v0, v0);
    }
}
void pushup(int now)
{
    Tree[now].sum = Tree[now << 1].sum + Tree[now << 1 | 1].sum;
}
void build(int now,int l,int r)
{
    Tree[now] = {l, r, 0, 0};
    if(l==r)
        return;
    int mid = l + r >> 1;
    build(now << 1, l, mid);
    build(now << 1 | 1, mid + 1, r);
    pushup(now);
}
void pushdown(int now)
{
    if(Tree[now].aim)
    {
        Tree[now << 1 | 1].sum += (Tree[now << 1 | 1].rig - Tree[now << 1 | 1].rig + 1) * Tree[now].aim;
        Tree[now << 1].sum += (Tree[now << 1].rig - Tree[now << 1].lef + 1) * Tree[now].aim;
        Tree[now << 1].aim += Tree[now].aim;
        Tree[now << 1 | 1].aim += Tree[now].aim;
        Tree[now].aim = 0;
    }
}//pushdown
void modify(int now,int l,int r,int k)
{
    if(l<=Tree[now].lef&&r>=Tree[now].rig)
    {
        Tree[now].sum = (Tree[now].sum+k * (Tree[now].rig - Tree[now].lef + 1));
        Tree[now].aim = (Tree[now].aim + k) ;
        return;
    }
    pushdown(now);
    int mid = Tree[now].lef + Tree[now].rig >> 1;
    if(l<=mid)
        modify(now << 1, l, r, k);
    if(r>mid)
        modify(now << 1 | 1, l, r, k);
    pushup(now);
}
ll query(int now,int l,int r)
{
    if(l<=Tree[now].lef&&Tree[now].rig<=r)
        return Tree[now].sum;
    pushdown(now);//记得pushdown，我经常忘记导致很久查不出来
    int mid = Tree[now].lef + Tree[now].rig >> 1;
    ll res = 0;
    if(l<=mid)
        res = (res+query(now << 1, l, r));
    if(r>mid)
        res = (res+query(now << 1 | 1, l, r));
    return res;
}//常规线段树操作
void modify_path(int now,int to,int k)
{
    while(top[now]!=top[to])
    {
        if(dep[top[now]]<dep[top[to]])
            swap(now, to);
        modify(1, id[top[now]], id[now], k);
        now = father[top[now]];
    }//倍增跳跃修改，修改路径上的所有果子的数量
    if(dep[now]<dep[to])
        swap(now, to);
    modify(1, id[to], id[now], k);//记住所有的modify里面的参数都是dfs序，否则可能很久查不出来，本蒟蒻就因为这个查了很久
}
ll query_tree(int now)
{
    return query(1, id[now], id[now] + siz[now] - 1);//子树的左边界即为当前节点因为越在上面的点的dfs序越小，而右边界即为当前节点+子树节点个数-1
}
int main()
{
    scanf("%d", &n);
    for (int i = 1; i < n;i++)
    {
        int a, b;
        scanf("%d%d", &a, &b);
        a++;
        b++;//记得++，节点的编号从0开始
        add(a, b);
        add(b, a);
    }
    dfs1(1, -1, 1);
    dfs2(1, 1);
    build(1, 1, n);//树剖初始化
    int q;
    scanf("%d", &q);
    for (int i = 1; i <= q;i++)
    {
        char op[2];
        scanf("%s", op);
        if(*op=='A')
        {
            int u, v, d;
            scanf("%d%d%d", &u, &v, &d);
            u++, v++;//同上，记得++
            modify_path(u, v, d);
        }
        else 
        {
            int u;
            scanf("%d", &u);
            u++;
            printf("%lld\n",query_tree(u));//注意题面已经提示该题需要使用longlong，否则会炸
        }
    }
}
```


---

## 作者：MuYC (赞：0)

#### 水话
不是很懂为什么省选会考这种模板题，而且明显这个模板比树链剖分的板子还好打，因为树链剖分的板子支持的操作比较多.....


一名提高组爆零选手:

$20$分钟打完了，然后编译一遍过了，交上去A了。

好像这也是我为数不多的一遍过树剖的题目（记得不错的话这是第5次

#### 做法

这道题看上去没什么想想，直接上树链剖分了。

关于树链剖分我也不知道该怎么讲了，有许多博客比我讲得好，如果你是还没有学习树链剖分的同学的话，在这里安利博客：

[OIWIKI](https://oi-wiki.org/graph/hld/)

[某个神佬的博客,讲得很清晰](https://www.luogu.com.cn/blog/yjpiaomiao/shulianpoufen)

（这里指的是轻重链剖分）

这里总结一下：

#### 适用情况
+ 对于一条路径上的值进行修改

+ 查询一条路径上的一些具有可以进行区间维护的性质的东西(比如求和，最大值)

##### 额外的例子:

查询一条路径中的元素种类总数

查询一条路径中大于一个给定的值的数的个数(树链剖分后套权值线段树 or 主席树)

查询路径中第$k$大的数

+ 对于一棵子树中的值进行修改

+ 查询一棵子树中的一些具有可以进行区间维护的性质的东西(比如求和，最大值)

上面四种是最裸的树链剖分。直接上树链剖分加线段树即可。


#### 算法复杂度：

对于路径上的更新权值/求和的时间复杂度是O($log^2n$)。

因为重链的条数不超过$log_2n$条(一般的话数量可能远远低于这个值)，每次线段树维护的时间复杂度是:O($log_2n$)的，所以时间复杂度是O$(log^2n)$的。

子树修改/查询时间复杂度:O$(logn)$，很明显，因为$DFS$后编号是连续的，时间复杂度就是线段树做区间查询/修改的复杂度

**如何构造一棵树使得轻重链剖分后重链条数达到$log2(n)$**

完全二叉树即可。你可以自己画一棵完全二叉树，然后你就会发现重链很多，但是因为是完全二叉树，那它的深度也不会很深，所以基本上卡不死轻重链剖分。

因为这是一篇题解，所以放上这一题的代码吧

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int MAXN = 100005;
int n;

int cnt = 0, start[MAXN];
int dfn[MAXN],siz[MAXN],fa[MAXN],tp[MAXN];
int id_dfn[MAXN],deep[MAXN],son[MAXN],now = 0;

struct Edge {
	int next,to;
} edge[MAXN * 2];

struct Node {
	int l,r,sum,laz;
} T[MAXN * 4];

void add(int from,int to)
{
	cnt ++;
	edge[cnt].to = to;
	edge[cnt].next = start[from];
	start[from] = cnt;
}
//下面是线段树
void build_tree(int x,int l,int r)
{
	T[x].l = l , T[x].r = r;
	T[x].sum = T[x].laz = 0;
	if(l == r)return ;
	int mid = (l + r) >> 1;
	build_tree(x << 1 , l , mid);
	build_tree(x << 1 | 1 , mid + 1 , r);
	return ;
}

void ad(int x,int k)
{
	T[x].laz += k;
	T[x].sum += (T[x].r - T[x].l + 1) * k;
	return ;
}

void pushdown(int x)
{
	if(T[x].laz == 0)return ;
	ad(x << 1 , T[x].laz);
	ad(x << 1 | 1 , T[x].laz);
	T[x].laz = 0;
	return ;
}

void change(int x,int l,int r,int k)
{
	if(T[x].l >= l && T[x].r <= r){ad(x,k);return ;}
	pushdown(x);
	int mid = (T[x].l + T[x].r) >> 1;
	if(l <= mid)change(x << 1 , l , r , k);
	if(r  > mid)change(x << 1 | 1 , l , r , k );
	T[x].sum = T[x << 1].sum + T[x << 1 | 1].sum;
	return ;
}

int GetSum(int x,int l,int r)
{
	int sum = 0;
	if(T[x].l >= l && T[x].r <= r)return T[x].sum;
	pushdown(x);
	int mid = (T[x].l + T[x].r) >> 1;
	if(l <= mid)sum += GetSum(x << 1 , l , r);
	if(r  > mid)sum += GetSum(x << 1 | 1 , l, r );
	return sum;
}
//线段树end

//树链剖分的核心：两个DFS
int DFS1(int x,int from)
{
	fa[x] = from;deep[x] = deep[from] + 1;
	siz[x] = 1 ; son[x] = 0;
	for(int i = start[x] ; i ; i = edge[i].next)
	{
		int to = edge[i].to;
		if(deep[to])continue;
		int v = DFS1(to,x);
		siz[x] += v;
		if(v > siz[son[x]])son[x] = to;
	}//第一个DFS求父节点，节点深度以及子树大小还有重儿子的编号
	return siz[x];
}

void DFS2(int x , int top)
{
	dfn[x] = ++ now;
	id_dfn[now] = x;
	tp[x] = top;
	if(son[x])DFS2(son[x],top);
	for(int i = start[x] ; i ; i = edge[i].next)
	{
		int to = edge[i].to;
		if(to == fa[x] || to == son[x] || dfn[to])continue;
		DFS2(to,to);
	}
	return ;
}
//DFS end

void deal(int x,int y,int k)
{
	while(tp[x] != tp[y])
	{
		if(deep[tp[x]] < deep[tp[y]])swap(x,y);
		change(1,dfn[tp[x]],dfn[x] , k);
		x = fa[tp[x]];
	}
	change(1,min(dfn[x],dfn[y]),max(dfn[x],dfn[y]),k);
	return ;
}

signed main()
{
	cin >> n;
	for(int i = 1 ; i <= n - 1 ; i ++)
	{
		int u , v;
		cin >> u >> v;
		add(u + 1,v + 1);
		add(v + 1,u + 1);
	}
	DFS1(1,0);
	DFS2(1,1);
	build_tree(1,1,n);
	int Q;
	cin >> Q;
	while(Q)
	{
		int u , v , w;
		char op;
		cin >> op;
		if(op == 'A')cin >> u >> v >> w, deal(u+1,v+1,w);
		else cin >> u ,cout << GetSum(1,dfn[u + 1] , dfn[u + 1] + siz[u + 1] - 1) << endl;
		Q --;
	}
	return 0;
}
```

---

## 作者：云浅知处 (赞：0)

树剖模板题一道，建议刚学完树剖之后来打一下这道题练练手。

[可能更好的阅读体验qwq](https://yunqian-qwq.github.io/post/p3833)

------------

这题说白了就是维护一棵点权树，支持：

- 给一条链上的所有点的权值加上 $d$。
- 统计子树权值和。

那么这里轻重链剖分一下，就变成了线段树上的区间加与区间求和。其实树状数组也是可以的。

------------

简单说两句树剖：

如果要支持在一个序列上进行区间加，区间求和，那么做法十分显然。直接线段树即可。

但是当问题转到树上之后，直接线段树就不行了。

一种直接的想法就是：类似序列上的一维平衡树/线段树，我们也在树上搞信息合并&懒标记！

然后顺着这个思路想下去，如果你已经熟练掌握 LCT&Splay，你会得到一个类似 [top tree](https://negiizhao.blog.uoj.ac/blog/4912) 一样的玩意。对，就是那个[模板题](https://www.luogu.com.cn/problem/P5649)黑题的玩意。

然而我们要讲的是树链剖分，所以这里就不说 top tree 了。

再想：已经可以在序列上进行区间加区间求和，怎么在树上进行类似的操作？

那么我们东改改西改改，把这棵树搞成一个序列不就行了嘛！

不过，这可不能乱改。比如说我们直接用 BFS 序（即深度）来搞，那么可能出现加的时候区间不连续的情况，从而复杂度爆炸。

因此，我们使用**轻重链剖分**，把整棵树剖分成很多条链。

对于每一个节点 $u$，它的重链所连接的子节点 $v$，满足 $v$ 在 $u$ 的所有子节点中，字数大小是最大的，然后所有节点同理。这样，我们就把整棵树分割成了很多条链。

然后就可以通过两次 DFS 来搞出来每个节点在线段树里面对应的位置，直接用线段树维护了。

------------

Code:

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<vector>
#include<iostream>

#define MAXN 100005
#define lson(o) (o<<1)
#define rson(o) (o<<1|1)
#define int long long

using namespace std;

vector<int>v[MAXN];
int fa[MAXN],hson[MAXN],sz[MAXN],top[MAXN],dfn[MAXN],d[MAXN];
int n,m;

int DFS1(int u,int dep){
	d[u]=dep;
	sz[u]=1;
	hson[u]=0;
	sz[hson[u]]=0;
	for(int i=0,s=v[u].size();i<s;i++){
		if(v[u][i]==fa[u])continue;
		fa[v[u][i]]=u;
		sz[u]+=DFS1(v[u][i],dep+1);
		if(sz[hson[u]]<sz[v[u][i]]){
			hson[u]=v[u][i];
		}
	}
	return sz[u];
}

int tot=0;

void DFS2(int u,int tp){
	top[u]=tp;
	dfn[u]=++tot;
	if(hson[u]!=0){
		DFS2(hson[u],tp);
		for(int i=0,s=v[u].size();i<s;i++){
			if(v[u][i]!=fa[u]&&v[u][i]!=hson[u]){
				DFS2(v[u][i],v[u][i]);
			}
		}
	}
}

struct SMT{
	
	int d[MAXN<<2],plz[MAXN<<2];
	
	inline void pushup(int o){
		d[o]=d[lson(o)]+d[rson(o)];
	}
	
	inline void build(){
		memset(d,0,sizeof(d));
		memset(plz,0,sizeof(plz));
	}
	
	inline void pushdown(int ql,int qr,int o){
		int mid=(ql+qr)>>1;
		if(plz[o]){
			d[lson(o)]+=(mid-ql+1)*plz[o];
			d[rson(o)]+=(qr-mid)*plz[o];
			plz[lson(o)]+=plz[o];
			plz[rson(o)]+=plz[o];
			plz[o]=0;
		}
	}
	
	inline void change(int l,int r,int k,int ql,int qr,int o){
		if(l<=ql&&qr<=r){
			plz[o]+=k;
			d[o]+=(qr-ql+1)*k;
			return;
		}
		int mid=(ql+qr)>>1;
		pushdown(ql,qr,o);
		if(l<=mid)change(l,r,k,ql,mid,lson(o));
		if(r>mid)change(l,r,k,mid+1,qr,rson(o));
		pushup(o);
	}
	
	inline int query(int l,int r,int ql,int qr,int o){
		if(l<=ql&&qr<=r){
			return d[o];
		}
		pushdown(ql,qr,o);
	//	puts("1");
		int mid=(ql+qr)>>1,ans=0;
	//	puts("2");
		if(l<=mid)ans+=query(l,r,ql,mid,lson(o));
	//	puts("3");
		if(r>mid)ans+=query(l,r,mid+1,qr,rson(o));
	//	puts("4");
		return ans;
	}
	
};

SMT tree;

void modify(int x,int y,int k){
	while(top[x]!=top[y]){
		if(d[top[x]]<d[top[y]])swap(x,y);
		tree.change(dfn[top[x]],dfn[x],k,1,n,1);
		x=fa[top[x]];
	}
	if(d[x]>d[y])swap(x,y);
	tree.change(dfn[x],dfn[y],k,1,n,1);
}

int queryson(int x){
	return tree.query(dfn[x],dfn[x]+sz[x]-1,1,n,1);
}

signed main(void){
	
	cin>>n;
	for(int i=2;i<=n;i++){
		int p,q;
		cin>>p>>q;
		p++,q++;
		v[p].push_back(q);
		v[q].push_back(p);
	}
	
	DFS1(1,1);
	DFS2(1,1);
	tree.build();
	
	cin>>m;
	while(m--){
		char opt;
		int x,y,k;
		cin>>opt;
		if(opt=='Q'){
			cin>>x;
			x++;
			cout<<queryson(x)<<endl;
		}
		else{
			cin>>x>>y>>k;
			x++,y++;
			modify(x,y,k);
		}
	}
	
	return 0;
}
```

---

## 作者：Provicy (赞：0)

此题即为模板[P3384树链剖分](https://www.luogu.org/problem/P3384)

刚看到这题以为有什么坑（毕竟省选D2T3），仔细一看，树剖裸题？最近两三天刚学树剖，马上码了这题。

我们为了方便，在读入点编号的时候，都把它们$+1$即可。

至于题目中所说的**读入时，$a$是$b$的父亲**，这根本不需理，在第一遍$DFS$时候和其他题处理相同即可。

因为和树剖模板相同，所以没有太多可以讲，不过还是要提醒各位码代码时一定要仔细。我写的时候第一遍因为快读打错了而爆零（好像不用快读$Qw
Q$）

在这里给和我一样刚学树剖的同学安利几道题（话说$OI$ $Wiki$上就有讲）

[[ZJOI2008]树的统计](https://www.luogu.org/problem/P2590)

[[USACO11DEC]牧草种植Grass Planting](https://www.luogu.org/problem/P3038)

[[HAOI2015]树上操作](https://www.luogu.org/problem/P3178)

[[NOI2015]软件包管理器](https://www.luogu.org/problem/P2146)

[[SDOI2011]染色](https://www.luogu.org/problem/P2486)

[[SDOI2014]旅行](https://www.luogu.org/problem/P3313)

[[JLOI2014]松鼠的新家](https://www.luogu.org/problem/P3258)

以上等等，如**染色**这题就很适合树剖稍微进阶一些的练习（我也是今天才$AC$掉）

同时，安利一波我一个朋友的树剖博客，写的真的很清楚啦[巨佬的博客](https://www.luogu.org/blog/zyxxs/post-xiao-yi-jiang-tan-dfs-xu-yu-shu-lian-pou-fen)

最后放$代码$：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=410000;
int n,q,f[N],d[N],son[N],size[N],id[N],nowid,top[N],leaf[N],flag[N],head[N],maxE;
struct Edge{int nxt,to;}e[N];
inline int read()
{
	int s=0,w=1; char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') w=-1; ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar(); return s*w;
}
inline void Add(int u,int v) {e[++maxE].nxt=head[u];head[u]=maxE;e[maxE].to=v;}
inline int LeftChild(int x) {return x<<1;}
inline int RightChild(int x) {return x<<1|1;}
inline void Push_Up(int x) {leaf[x]=leaf[LeftChild(x)]+leaf[RightChild(x)];}
void DFS1(int x,int before)
{
	d[x]=d[before]+1; f[x]=before; size[x]=1;
	for(int i=head[x];i;i=e[i].nxt)
	{
		if(e[i].to==before) continue;
		DFS1(e[i].to,x); size[x]+=size[e[i].to];
		if(size[e[i].to]>size[son[x]]) son[x]=e[i].to;
	}
}
void DFS2(int x,int topf)
{
	id[x]=++nowid; top[x]=topf;
	if(!son[x]) return; DFS2(son[x],topf);
	for(int i=head[x];i;i=e[i].nxt) if(e[i].to!=f[x]&&e[i].to!=son[x]) DFS2(e[i].to,e[i].to);
}
inline void Change(int x,int l,int r,int k) {flag[x]+=k; leaf[x]+=k*(r-l+1);}
inline void Push_Down(int x,int l,int r)
{
	Change(LeftChild(x),l,(l+r)>>1,flag[x]);
	Change(RightChild(x),((l+r)>>1)+1,r,flag[x]);
	flag[x]=0;
}
void UpDate(int u,int v,int l,int r,int x,int k)
{
	if(l>=u&&r<=v) {Change(x,l,r,k); return;}
	Push_Down(x,l,r);
	if(u<=(l+r)>>1) UpDate(u,v,l,(l+r)>>1,LeftChild(x),k);
	if(v>(l+r)>>1) UpDate(u,v,((l+r)>>1)+1,r,RightChild(x),k);
	Push_Up(x);
}
void UpDate_Road(int x,int y,int k)
{
	while(top[x]!=top[y])
	{
		if(d[top[x]]<d[top[y]]) swap(x,y);
		UpDate(id[top[x]],id[x],1,n,1,k);
		x=f[top[x]];
	}
	if(d[x]>d[y]) swap(x,y);
	UpDate(id[x],id[y],1,n,1,k);
}
int Ask(int u,int v,int l,int r,int x)
{
	if(l>=u&&r<=v) return leaf[x];
	Push_Down(x,l,r);int ans=0;
	if(u<=(l+r)>>1) ans+=Ask(u,v,l,(l+r)>>1,LeftChild(x));
	if(v>(l+r)>>1) ans+=Ask(u,v,((l+r)>>1)+1,r,RightChild(x));
	return ans;
}
signed main()
{
	n=read();
	for(int i=1,u,v;i<n;i++)
	{
		u=read();v=read();u++,v++;
		Add(u,v); Add(v,u);
	}
	DFS1(1,0);DFS2(1,1);q=read();
	for(int i=1,u,v,d;i<=q;i++)
	{
		char op;
		cin>>op>>u;u++;
		if(op=='A') cin>>v>>d,v++,UpDate_Road(u,v,d);
		if(op=='Q') printf("%lld\n",Ask(id[u],id[u]+size[u]-1,1,n,1));
	}
	return 0;
}
```


---

## 作者：苏幕寒 (赞：0)

这是一道很好练习树剖的模板题，~~虽然树剖有模版题的说~~，首先输入没什么好说的，然后邻接表建树；

然后便是树链剖分的重点，dfs分重链轻链，代码如下：
```cpp
void dfs(int u,int ff,int deep)
{
	dep[u]=deep;fa[u]=ff;
	size[u]=1;int maxson=-1;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==ff) continue;
		dfs(v,u,deep+1);
		size[u]+=size[v];
		if(size[v]>maxson){
			maxson=size[v];son[u]=v;
		}
	}
}
void DFS(int u,int topf)
{
	id[u]=++num;top[u]=topf;
	if(son[u]) DFS(son[u],topf);
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==fa[u]||v==son[u]) continue;
		DFS(v,v);
	}
}
```
然后建树，树建好后修改和回答问题即可；
对了线段树的数组一定不要忘记乘4，千万不要走上我这名蒟蒻的老路；话不多说了，上代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e6+1e4;
int n,m,fa[N],dep[N],son[N],size[N];
struct edge{
	int v,nxt;
}e[N<<1];
int head[N],cnt,num,id[N],top[N];
ll dat[N],add[N];
void fk(int u,int v){
	e[++cnt]=(edge){v,head[u]};head[u]=cnt;
}
void dfs(int u,int ff,int deep)
{
	dep[u]=deep;fa[u]=ff;
	size[u]=1;int maxson=-1;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==ff) continue;
		dfs(v,u,deep+1);
		size[u]+=size[v];
		if(size[v]>maxson){
			maxson=size[v];son[u]=v;
		}
	}
}
void DFS(int u,int topf)
{
	id[u]=++num;top[u]=topf;
	if(son[u]) DFS(son[u],topf);
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==fa[u]||v==son[u]) continue;
		DFS(v,v);
	}
}
void build(int q,int l,int r)
{
	if(l==r){
		dat[q]=0;return;
	}
	int mid=(l+r)>>1;
	build(q*2,l,mid);
	build(q*2+1,mid+1,r);
}
void spread(int q,int l,int r)
{
	int mid=(l+r)>>1;
	dat[q*2]+=add[q]*(mid-l+1);
	dat[q*2+1]+=add[q]*(r-mid);
	add[q*2]+=add[q];
	add[q*2+1]+=add[q];
	add[q]=0;
	return;
}
void change(int q,int l,int r,int ql,int qr,int k)
{
	if(l>=ql&&r<=qr){
		dat[q]+=(ll)k*(r-l+1);
		add[q]+=k;return;
	}
	int mid=(l+r)>>1;
	spread(q,l,r);
	if(mid>=ql) change(q*2,l,mid,ql,qr,k);
	if(mid<qr) change(q*2+1,mid+1,r,ql,qr,k);
	dat[q]=dat[q*2]+dat[q*2+1];
}
ll query(int q,int l,int r,int ql,int qr)
{
	ll ans=0;
	if(l>=ql&&r<=qr) return dat[q];
	int mid=(l+r)>>1;
	spread(q,l,r);
	if(mid>=ql) ans+=query(q*2,l,mid,ql,qr);
	if(mid<qr) ans+=query(q*2+1,mid+1,r,ql,qr);
	return ans;
}
void qchange(int x,int y,int z)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		change(1,1,num,id[top[x]],id[x],z);
		x=fa[top[x]];
	}
	if(id[x]>id[y]) swap(x,y);
	change(1,1,num,id[x],id[y],z);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		fk(u,v);fk(v,u);
	}
	dfs(0,-1,1);DFS(0,0);build(1,1,n);
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		char c;
		scanf("%s",&c);
		if(c=='A')
		{
			int x,y,z;
			scanf("%d%d%d",&x,&y,&z);
			qchange(x,y,z);
		}
		if(c=='Q')
		{
			int x;
			scanf("%d",&x);
			printf("%lld\n",query(1,1,n,id[x],id[x]+size[x]-1));
		}
	}
	return 0;
}
```


如果对树剖感兴趣的dalao可以再去练练 
P3384
【模板】树链剖分

P2590
[ZJOI2008]树的统计
这两道题目，如果我的代码有任何问题的话，欢迎踩我；


---

## 作者：abs001 (赞：0)

## 前置知识：[树链剖分](https://www.luogu.org/problemnew/show/P3384)
## 题目解析

此题就是树链剖分的一个模板题。
包括了路径修改与子树查询。

其实子树的查询就是从id[i]开始到id[i]+si[i]-1的和，其中id表示dfs序，si表示子树大小。

线段树写法则是区间修改，区间求和。

代码：
```cpp
#include<bits/stdc++.h>
#define N 100001
#define ll long long
using namespace std;

struct node{
    ll to, ne;
}e[N];

ll n, m, cnt;
ll he[N], si[N], son[N], fa[N], up[N], id[N], rk[N], de[N], tree[N << 2], tag[N << 2];
char s[10];

void add(ll x, ll y)
{
    e[++cnt] = {y, he[x]};
    he[x] = cnt;//邻接表储存
}

void dfs1(ll x)
{
    si[x] = 1;//子树大小
    for(ll i = he[x]; i; i = e[i].ne)
    {
        ll y = e[i].to;
        fa[y] = x, de[y] = de[x] + 1;//深度与父节点
        dfs1(y);
        si[x] += si[y];
        if(si[y] > si[son[x]]) son[x] = y;//重儿子
    }
}

void dfs2(ll x, ll f)
{
    id[x] = ++cnt, rk[cnt] = x, up[x] = f;//dfs序、id[cnt]所对应的cnt、一条重链上最上面的点
    if(!son[x]) return;
    dfs2(son[x], f);
    for(ll i = he[x]; i; i = e[i].ne)
    {
        ll y = e[i].to;
        if(y == son[x]) continue;
        dfs2(y, y);
    }
}

void pushup(ll rt)//上传标记
{
    tree[rt] = tree[rt << 1] + tree[rt << 1 | 1];
}

void se(ll rt, ll l, ll r, ll tmp)
{
    tree[rt] += (r - l + 1) * tmp;
    tag[rt] += tmp;
}

void pushdown(ll rt, ll l, ll r)//下传标记
{
    ll mid = (l + r) >> 1;
    se(rt << 1, l, mid, tag[rt]);
    se(rt << 1 | 1, mid + 1, r, tag[rt]);
    tag[rt] = 0;
}

void change(ll rt, ll l, ll r, ll x, ll y, ll z)
{
    if(x <= l && r <= y)
    {
        tree[rt] += (r - l + 1) * z;
        tag[rt] += z;
        return;
    }
    pushdown(rt, l, r);
    ll mid = (l + r) >> 1;
    if(x <= mid) change(rt << 1, l, mid, x, y, z);//左区间
    if(y > mid) change(rt << 1 | 1, mid + 1, r, x, y, z);//右区间
    pushup(rt);
}

ll query(ll rt, ll l, ll r, ll x, ll y)
{
    if(x <= l && r <= y) return tree[rt];
    pushdown(rt, l, r);
    ll mid = (l + r) >> 1, res = 0;
    if(x <= mid) res += query(rt << 1, l, mid, x, y);//左区间
    if(y > mid) res += query(rt << 1 | 1, mid + 1, r, x, y);//右区间
    return res;
}

void qchange(ll x, ll y, ll z)//查询
{
    while(up[x] != up[y])
    {
        if(de[up[x]] < de[up[y]]) swap(x, y);//找跳的深的
        change(1, 1, n, id[up[x]], id[x], z);//区间修改
        x = fa[up[x]];
    }
    if(id[x] > id[y]) swap(x, y);
    change(1, 1, n, id[x], id[y], z);
}

int main()
{
    scanf("%lld", &n);
    for(ll i = 1; i < n; i++)
    {
        ll x, y;
        scanf("%lld%lld", &x, &y), x++, y++;
        add(x, y);
    }
    dfs1(1), cnt = 0;
    dfs2(1, 1);
    scanf("%lld", &m);
    for(int i = 1; i <= m; i++)
    {
        ll x, y, z;
        scanf("%s%lld", s, &x), x++;
        if(s[0] == 'A')
        {
            scanf("%lld%lld", &y, &z), y++;
            qchange(x, y, z);//路径修改
        }
        else printf("%lld\n", query(1, 1, n, id[x], id[x] + si[x] - 1));//子树查询
    }
    return 0;
}
```


---

## 作者：VenusM1nT (赞：0)

树链剖分。维护子树和、操作区间加，无脑上线段树即可。

$\text{P.S.}$ 传标记给 $sum$ 的时候记得把 $tag$ 乘上 $(len-(len>>1))$ 和 $(len>>1)$，以及修改的时候也要乘上区间长度，而 $tag$ 不用。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define MAXN 100005
using namespace std;
int cnt,fst[MAXN],nxt[MAXN<<1],to[MAXN<<1];
int n,Q;
int siz[MAXN],son[MAXN],dfn[MAXN],Index,top[MAXN],dep[MAXN],faz[MAXN];
ll t[MAXN<<2],tag[MAXN<<2];
void AddEdge(int u,int v)
{
	to[++cnt]=v;
	nxt[cnt]=fst[u];
	fst[u]=cnt;
}
void Dfs1(int u)
{
	siz[u]=1;
	son[u]=0;
	for(int i=fst[u];i;i=nxt[i])
	{
		int v=to[i];
		if(v==faz[u]) continue;
		dep[v]=dep[u]+1;
		faz[v]=u;
		Dfs1(v);
		siz[u]+=siz[v];
		if(siz[son[u]]<siz[v]) son[u]=v;
	}
}
void Dfs2(int u,int rt)
{
	dfn[u]=++Index;
	top[u]=rt;
	if(son[u]) Dfs2(son[u],rt);
	for(int i=fst[u];i;i=nxt[i])
	{
		int v=to[i];
		if(v==faz[u] || v==son[u]) continue;
		Dfs2(v,v);
	}
}
void PushUp(int rt)
{
	t[rt]=t[rt<<1]+t[rt<<1|1];
}
void PushDown(int rt,int len)
{
	t[rt<<1]+=tag[rt]*1ll*(len-(len>>1));
	t[rt<<1|1]+=tag[rt]*1ll*(len>>1);
	tag[rt<<1]+=tag[rt];
	tag[rt<<1|1]+=tag[rt];
	tag[rt]=0;
}
void BuildSegmentTree(int rt,int l,int r)
{
	if(l==r)
	{
		t[rt]=0;
		return;
	}
	int mid=l+r>>1;
	BuildSegmentTree(rt<<1,l,mid);
	BuildSegmentTree(rt<<1|1,mid+1,r);
	PushUp(rt);
}
void Modify(int rt,int l,int r,int tl,int tr,ll val)
{
	if(tl<=l && r<=tr)
	{
		t[rt]+=val*(r-l+1);
		tag[rt]+=val;
		return;
	}
	PushDown(rt,r-l+1);
	int mid=l+r>>1;
	if(tl<=mid) Modify(rt<<1,l,mid,tl,tr,val);
	if(tr>mid) Modify(rt<<1|1,mid+1,r,tl,tr,val);
	PushUp(rt);
}
ll Query(int rt,int l,int r,int tl,int tr)
{
	if(tl<=l && r<=tr) return t[rt];
	PushDown(rt,r-l+1);
	int mid=l+r>>1;
	ll res=0;
	if(tl<=mid) res+=Query(rt<<1,l,mid,tl,tr);
	if(tr>mid) res+=Query(rt<<1|1,mid+1,r,tl,tr);
	return res;
}
void ModifyOnTree(int u,int v,ll val)
{
	while(top[u]!=top[v])
	{
		if(dep[top[u]]<dep[top[v]]) swap(u,v);
		Modify(1,1,n,dfn[top[u]],dfn[u],val);
		u=faz[top[u]];
	}
	if(dep[u]>dep[v]) swap(u,v);
	Modify(1,1,n,dfn[u],dfn[v],val);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d %d",&x,&y);
		x++;
		y++;
		AddEdge(x,y);
		AddEdge(y,x);
	}
	Dfs1(1);
	Dfs2(1,1);
	BuildSegmentTree(1,1,n);
	scanf("%d",&Q);
	while(Q--)
	{
		int x,y;
		ll z;
		char opt;
		cin>>opt;
		scanf("%d",&x);
		x++;
		if(opt=='A')
		{
			scanf("%d %lld",&y,&z);
			y++;
			ModifyOnTree(x,y,z);
		}
		else printf("%lld\n",Query(1,1,n,dfn[x],dfn[x]+siz[x]-1));
	}
	return 0;
}
```

---

## 作者：wangxuye (赞：0)

### 题目链接
[SHOI2012 魔法树](https://www.luogu.org/problemnew/show/P3833)  
### 题目大意
给你一棵树，每次可以查询一个子树内的点权和或者将一条路径上的点权和全部增加$v$
### 题目思路
树，子树，路径，树剖解决！  
树剖只要注意不手残写错就行了~~（我才不会告诉你我因为这个T了3发）~~

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=100010,M=100010;

int head[N],ver[M],nxt[M];
int n,m,tot=0,num=0;
int d[N],f[N],size[N],son[N],id[N],rk[N],top[N];

inline void add_edge(int x,int y)
{
	ver[++tot]=y,nxt[tot]=head[x],head[x]=tot;
}

struct SegmentTree{
	int l,r;
	ll sum,add;
	#define l(x) tree[x].l
	#define r(x) tree[x].r
	#define sum(x) tree[x].sum
	#define add(x) tree[x].add
} tree[N<<2];
inline void pushup(int p)
{
	sum(p)=sum(p<<1)+sum(p<<1|1);
}
inline void build(int p,int l,int r)
{
	l(p)=l,r(p)=r,add(p)=sum(p)=0;
	if(l==r) return ;
	int mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
}
inline void spread(int p)
{
	if(add(p))
	{
		sum(p<<1)+=add(p)*(r(p<<1)-l(p<<1)+1);
		sum(p<<1|1)+=add(p)*(r(p<<1|1)-l(p<<1|1)+1);
		add(p<<1)+=add(p);
		add(p<<1|1)+=add(p);
		add(p)=0;
	}
}
inline void update(int p,int l,int r,int v)
{
	if(l<=l(p)&&r(p)<=r)
	{
		add(p)+=v;
		sum(p)+=(ll)v*(r(p)-l(p)+1);
		return ;
	}
	spread(p);
	int mid=(l(p)+r(p))>>1;
	if(l<=mid) update(p<<1,l,r,v);
	if(r>mid) update(p<<1|1,l,r,v);
	pushup(p);
}
inline ll query(int p,int l,int r)
{
	if(l<=l(p)&&r(p)<=r) return sum(p);
	spread(p);
	int mid=(l(p)+r(p))>>1;
	ll ans=0;
	if(l<=mid) ans+=query(p<<1,l,r);
	if(r>mid) ans+=query(p<<1|1,l,r);
	return ans;
}

inline void dfs1(int x,int fa)
{
	size[x]=1;
	for(int i=head[x];i;i=nxt[i])
	{
		int y=ver[i];
		if(y==fa) continue;
		f[y]=x;
		d[y]=d[x]+1;
		dfs1(y,x);
		size[x]+=size[y];
		if(size[y]>size[son[x]]) son[x]=y;
	}
}

inline void dfs2(int x,int t)
{
	top[x]=t;
	id[x]=++num;
	rk[num]=x;
	if(!son[x]) return ;
	dfs2(son[x],t);
	for(int i=head[x];i;i=nxt[i])
	{
		int y=ver[i];
		if(y==f[x]||y==son[x]) continue;
		dfs2(y,y);
	}
}
inline void upRange(int x,int y,int v)
{
	int fx=top[x],fy=top[y];
	while(fx!=fy)
	{
		if(d[fx]>d[fy])
		{
			update(1,id[fx],id[x],v);
			x=f[fx],fx=top[x];
		}
		else
		{
			update(1,id[fy],id[y],v);
			y=f[fy],fy=top[y];
		}
	}
	if(d[x]>d[y]) update(1,id[y],id[x],v);
	else update(1,id[x],id[y],v);
}
inline ll qSon(int x)
{
	return query(1,id[x],id[x]+size[x]-1);
}

inline int read()
{
	int s=0;
	bool flag=false;
	char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') flag=true;
	for(;'0'<=ch&&ch<='9';ch=getchar()) s=(s<<3)+(s<<1)+(ch^48);
	if(flag) return -s;
	return s;
}
inline void write(ll x)
{
	if(!x)
	{
		putchar('0');
		return ;
	}
	char ch[20];
	int cnt=0;
	while(x) ch[++cnt]=x%10+'0',x/=10;
	for(int i=cnt;i;i--) putchar(ch[i]);
}
inline void writeln(ll x)
{
	write(x);
	putchar('\n');
}

int main()
{
	n=read();
	for(int i=1;i<n;i++)
	{
		int a=read()+1,b=read()+1;
		add_edge(a,b);
	}
	dfs1(1,0);
	dfs2(1,1);
	build(1,1,n);
	m=read();
	for(int i=1;i<=m;i++)
	{
		char ch=getchar();
		while(ch!='A'&&ch!='Q') ch=getchar();
		if(ch=='A')
		{
			int a=read()+1,b=read()+1,c=read();
			upRange(a,b,c);
		}
		else
		{
			int a=read()+1;
			writeln(qSon(a));
		}
	}
	return 0;
}
```

---

## 作者：斯德哥尔摩 (赞：0)

树链剖分模板。。。

话说省选竟然考了模板，惊奇。。。

楼上几位巨佬已经解释了树链剖分，这里给出另一种模板，宏定义。

宏定义 是个好东东，能让你的程序更加清晰，方便调试（尤其是 线段树 这种容易手滑的数据结构。。。）

附代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define LSON rt<<1//以下为宏定义
#define RSON rt<<1|1
#define DATA(x) b[x].data
#define SIGN(x) b[x].c
#define LSIDE(x) b[x].l
#define RSIDE(x) b[x].r
#define WIDTH(x) (RSIDE(x)-LSIDE(x)+1)//以上为宏定义
#define MAXN 100010//数组大小
using namespace std;
int n,m,c=1,d=1;
int head[MAXN],deep[MAXN],son[MAXN],size[MAXN],fa[MAXN],id[MAXN],top[MAXN];//树剖之数组
struct node1{//前向星（因为建单向边，可以只开一倍）
    int next,to;
}a[MAXN<<1];
struct node2{//线段树，记得开 long long
    long long data,c;
    int l,r;
}b[MAXN<<2];
inline int read(){//读优
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
inline void add(int x,int y){//加边
    a[c].to=y;
    a[c].next=head[x];
    head[x]=c++;
}
void dfs1(int rt){//树链剖分两个 dfs，应该都会，没有什么奇奇怪怪的地方
    son[rt]=0;size[rt]=1;
    for(int i=head[rt];i;i=a[i].next){
        int will=a[i].to;
        if(!deep[will]){
            deep[will]=deep[rt]+1;
            fa[will]=rt;
            dfs1(will);
            size[rt]+=size[will];
            if(size[son[rt]]<size[will])son[rt]=will;
        }
    }
}
void dfs2(int rt,int f){
    id[rt]=d++;top[rt]=f;
    if(son[rt])dfs2(son[rt],f);
    for(int i=head[rt];i;i=a[i].next){
        int will=a[i].to;
        if(will!=fa[rt]&&will!=son[rt])
        dfs2(will,will);
    }
}//以上为树剖
inline void pushup(int rt){//上传
    DATA(rt)=DATA(LSON)+DATA(RSON);
}
inline void pushdown(int rt){//标记下传
    if(!SIGN(rt)||LSIDE(rt)==RSIDE(rt))return;
    SIGN(LSON)+=SIGN(rt);
    DATA(LSON)+=SIGN(rt)*WIDTH(LSON);
    SIGN(RSON)+=SIGN(rt);
    DATA(RSON)+=SIGN(rt)*WIDTH(RSON);
    SIGN(rt)=0;//记得清0
}
void buildtree(int l,int r,int rt){//建树
    int mid;
    LSIDE(rt)=l;
    RSIDE(rt)=r;
    if(l==r){
        DATA(rt)=0;//初值为0
        return;
    }
    mid=l+r>>1;
    buildtree(l,mid,LSON);
    buildtree(mid+1,r,RSON);
    pushup(rt);
}
void update(int l,int r,long long c,int rt){//修改
    int mid;
    if(l<=LSIDE(rt)&&RSIDE(rt)<=r){
        SIGN(rt)+=c;//打上标记
        DATA(rt)+=c*WIDTH(rt);
        return;
    }
    pushdown(rt);//下传
    mid=LSIDE(rt)+RSIDE(rt)>>1;//分左右
    if(l<=mid)update(l,r,c,LSON);
    if(mid<r)update(l,r,c,RSON);
    pushup(rt);//记得上传
}
long long query(int l,int r,int rt){//求和
    int mid;
    long long ans=0;
    if(l<=LSIDE(rt)&&RSIDE(rt)<=r)
    return DATA(rt);
    pushdown(rt);//下传
    mid=LSIDE(rt)+RSIDE(rt)>>1;
    if(l<=mid)ans+=query(l,r,LSON);
    if(mid<r)ans+=query(l,r,RSON);
    return ans;
}//以上为线段树
void work1(int x,int y,int k){//求 LCA+求和，应该是板子了
    while(top[x]!=top[y]){
        if(deep[top[x]]<deep[top[y]])swap(x,y);
        update(id[top[x]],id[x],k,1);
        x=fa[top[x]];
    }
    if(deep[x]>deep[y])swap(x,y);
    update(id[x],id[y],k,1);//最后这一步不要忘了
    return;
}
void work(){//工作
    char ch[2];
    int x,y,k;
    m=read();
    while(m--){
        scanf("%s",ch);x=read()+1;
        if(ch[0]=='A'){//分类
            y=read()+1;k=read();
            work1(x,y,k);
        }
        if(ch[0]=='Q')printf("%lld\n",query(id[x],id[x]+size[x]-1,1));
    }//某节点子树区间：[ id[x] , id[x]+size[x]-1 ] , size[x]为子树大小
}
void init(){//读入+预处理
    int x,y;
    n=read();
    for(int i=1;i<n;i++){
        x=read()+1;y=read()+1;//习惯于下标从1开始
        add(x,y);
    }
    deep[1]=1;
    dfs1(1);
    dfs2(1,1);//树剖
    buildtree(1,n,1);//建线段树
}
int main(){//主函数So easy!
    init();
    work();
	return 0;
}

```

---


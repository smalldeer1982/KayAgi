# [HEOI2016/TJOI2016] 树

## 题目描述

在 2016 年，佳媛姐姐刚刚学习了树，非常开心。现在他想解决这样一个问题：给定一颗有根树，根为 $1$ ，有以下两种操作：

1. 标记操作：对某个结点打上标记。（在最开始，只有结点 $1$ 有标记，其他结点均无标记，而且对于某个结点，可以打多次标记。）

2. 询问操作：询问某个结点最近的一个打了标记的祖先。（这个结点本身也算自己的祖先）

你能帮帮她吗?


## 说明/提示

$30\%$ 的数据，$1 \leqslant N, Q \leqslant 1000$ ；

$70\%$ 的数据，$1 \leqslant N, Q \leqslant 10000$ ；

$100\%$ 的数据，$1 \leqslant N, Q \leqslant 100000$ 。

## 样例 #1

### 输入

```
5 5 
1 2 
1 3 
2 4 
2 5 
Q 2 
C 2 
Q 2 
Q 5 
Q 3```

### 输出

```
1
2
2
1```

# 题解

## 作者：Sleepp (赞：70)

此题树剖裸题，~~但是并不想写线段树~~，于是就写了并查集 ，发现好像题解里并没有我这种做法，就写了这篇题解。
## 题解 

我的做法是离线操作，在读入时记录每个点被染色的次数，之后从根节点```dfs```，如果这个点被染色了，就让并查集数组的值为自己，否则为他的父亲。 然后倒序枚举操作，如果是查询操作，直接```find()```这个点，得到的值就是最近的被染色的祖先，如果是标记操作，则删除这个标记，即让**这个点被染色的次数减1**，如果染色次数变成了0，就意味着这个点没有染色了，将并查集数组的值改为它的父亲。


## 代码


```cpp
#include <cstdio>
const int MAXN=100010;
struct P {
    bool ty;
    int id,ans;
}p[MAXN];
int edv[MAXN<<1],ednxt[MAXN<<1];
int first[MAXN],cnt=0;
void add(int x,int y) {
    edv[++cnt]=y;
    ednxt[cnt]=first[x];
    first[x]=cnt;
}
int col[MAXN];
char inp[3];
int ufs[MAXN];  //并查集数组
int f[MAXN];	//记录一个点的父亲
void dfs(int x,int fa) {
    if(col[x]) ufs[x]=x;   //如果有染色，就让值等于自己
    else ufs[x]=fa;        //否则等于父亲
    f[x]=fa;
    for(int i=first[x];i;i=ednxt[i]) {
        int v=edv[i];
        if(v==fa) continue;
        dfs(v,x);
    }
}
int find(int x) {
    return x==ufs[x]?x:ufs[x]=find(ufs[x]);
}
int main() {
    int n,q;
    scanf("%d%d",&n,&q);
    int in1,in2;
    for(int i=1;i<n;++i) {
        scanf("%d%d",&in1,&in2);
        add(in1,in2);
        add(in2,in1);
    }
    col[1]=1;
    for(int i=1;i<=q;++i) {
        scanf("%s%d",inp,&p[i].id);
        switch(inp[0]) {
            case 'Q':{
                p[i].ty=0;
                break;
            }
            case 'C':{
                p[i].ty=1;
                ++col[p[i].id];
                break;
            }
        }
    }
    dfs(1,0);
    f[1]=1;
    for(int i=q;i>=1;--i) {
        if(p[i].ty) {
            --col[p[i].id];
            if(!col[p[i].id]) ufs[p[i].id]=f[p[i].id];  //这个点没有染色了
        } else {
            p[i].ans=find(p[i].id);
        }
    }
    for(int i=1;i<=q;++i) {
        if(!p[i].ty) {
            printf("%d\n",p[i].ans);
        }
    }
    return 0;
}
```
~~如果强制在线就GG了~~

---

## 作者：Llf0703 (赞：29)

~~第一次写树剖没看题解A题~~，发现题解大佬里竟然没有一个做法一样的，实在是太激动了

---

## 方法

~~裸树剖~~，直接用线段树维护每一段区间中**被标记的最深的节点**就行了。先全部赋值为-1，然后向上传递时直接取两段中的最大值即可（因为越深的点dfs序越大）

还有需要注意的是查询中在链上往上跳时只要找到了有标记的节点就需要输出，否则不是最深的点。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Edge{
  int next,to;
} edge[200005];
struct Tree{
  int left,right,deepest;
} tree[800005];
int head[200005],size[200005],fa[200005],son[200005],deep[200005],top[200005],id[200005],dfsid[200005];
int cnt=1,n,m,a,b,c,dfsord;
char x;
inline int read()//快读
{
  char ch=getchar();
  int f=1,x=0;
  while (ch<'0' || ch>'9')
  {
    if (ch=='-') f=-1;
    ch=getchar();
  }
  while (ch>='0' && ch<='9')
  {
    x=x*10+ch-'0';
    ch=getchar();
  }
  return f*x;
}
inline void add(int u,int v)//加边
{
  edge[cnt].to=v;
  edge[cnt].next=head[u];
  head[u]=cnt++;
}
void build(int x,int l,int r)//建树
{
  tree[x].left=l;
  tree[x].right=r;
  tree[x].deepest=-1;//注意要赋值为-1
  if (r-l>1)
  {
    build(x*2,l,(l+r)/2);
    build(x*2+1,(l+r)/2,r);
  }
}
void change(int x,int l,int r)
{
  if (l<=tree[x].left && r>=tree[x].right) tree[x].deepest=l;//只有一个元素时标记的最深的节点就是它自己
  else
  {
    int mid=(tree[x].left+tree[x].right)/2;
    if (l<mid) change(x*2,l,r);
    if (r>mid) change(x*2+1,l,r);
    tree[x].deepest=max(tree[x*2].deepest,tree[x*2+1].deepest);//取两段上最深的节点
  }
}
int query(int x,int l,int r)
{
  if (l<=tree[x].left && r>=tree[x].right) return tree[x].deepest;
  else
  {
    int mid=(tree[x].left+tree[x].right)/2,ans=-1;//同样注意初值
    if (l<mid) ans=max(ans,query(x*2,l,r));
    if (r>mid) ans=max(ans,query(x*2+1,l,r));
    return ans;
  }
}
void dfs1(int x,int f,int dep)
{
  deep[x]=dep;
  fa[x]=f;
  size[x]=1;
  int mx=-1;
  for (int i=head[x];i;i=edge[i].next)
  {
    int y=edge[i].to;
    if (y==f) continue;
    dfs1(y,x,dep+1);
    size[x]+=size[y];
    if (size[y]>mx)
    {
      mx=size[y];
      son[x]=y;
    }
  }
}
void dfs2(int x,int topf)
{
  top[x]=topf;
  id[x]=++dfsord;
  dfsid[dfsord]=x;//因为是输出节点原序号，这里得到dfs序对应的节点序号
  if (!son[x]) return;
  dfs2(son[x],topf);
  for (int i=head[x];i;i=edge[i].next)
  {
    int y=edge[i].to;
    if (y==fa[x] || y==son[x]) continue;
    dfs2(y,y);
  }
}
inline void uprange(int u)
{
  change(1,id[u],id[u]+1);
}
inline int qrange(int u,int v)
{
  int ans=-1;
  while (top[u]!=top[v])
  {
    if (deep[id[u]]<deep[id[v]]) swap(u,v);
    ans=query(1,id[top[u]],id[u]+1);
    if (ans!=-1) return dfsid[ans];//只要找到就返回
    u=fa[top[u]];
  }
  if (deep[u]>deep[v]) swap(u,v);
  ans=query(1,id[u],id[v]+1);
  return dfsid[ans];
}
int main()
{
  n=read();m=read();
  for (int i=1;i<n;i++)
  {
    a=read();b=read();
    add(a,b);
    add(b,a);
  }
  dfs1(1,0,1);
  dfs2(1,1);
  build(1,1,n+1);
  change(1,1,2);//注意先将根节点打上标记
  for (int i=1;i<=m;i++)
  {
    cin>>x;
    a=read();
    if (x=='C') uprange(a);
    else printf("%d\n",qrange(a,1));
  }
  return 0;
}

```

---

## 作者：Adove (赞：17)

这题其实是可以标记永久化来做的

我们知道dfs序有一个特点：某节点及其子树节点在一段连续的区间内

那么每次我们修改时，连带子树节点一并下放标记

如果当前子树节点有了标记，我们需要判断一下旧标记的深度与当前标记的深度，保留较深的那一个

查询时单点查询，将路过的标记计入贡献即可

上代码

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

const int MAXN=1<<17;

int n,m,x,y,np,cnt;
int siz[MAXN],id[MAXN],tp[MAXN];
int mrk[MAXN<<1],h[MAXN];
char ch;
struct rpg{
	int li,nx;
}a[MAXN<<1];

void add(int ls,int nx){
	a[++np]=(rpg){h[ls],nx};
	h[ls]=np;
}

void init(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;++i){
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}return;
}

void dfs(int x,int f,int deep){
	id[x]=++cnt;
	tp[x]=deep;
	siz[x]=1;
	for(int i=h[x];i;i=a[i].li){
		if(a[i].nx!=f){
			dfs(a[i].nx,x,deep+1);
			siz[x]+=siz[a[i].nx];
		}
	}return;
}

void cmrk(int k,int l,int r,int le,int ri,int x){
	if(le<=l&&r<=ri){
		if(tp[mrk[k]]<tp[x]) mrk[k]=x;
		return;
	}int i=k<<1,mid=l+r>>1;
	if(le<=mid) cmrk(i,l,mid,le,ri,x);
	if(mid<ri) cmrk(i|1,mid+1,r,le,ri,x);
}

int ask(int k,int l,int r,int p,int x){
	if(l==r) return mrk[k]?mrk[k]:x;
	int i=k<<1,mid=l+r>>1;
	if(mrk[k]) x=mrk[k];
	if(p<=mid) return ask(i,l,mid,p,x);
	else return ask(i|1,mid+1,r,p,x);
}

void solve(){
	mrk[1]=1;
	while(m--){
		scanf("\n%c%d",&ch,&x);
		if(ch=='C') cmrk(1,1,n,id[x],id[x]+siz[x]-1,x);
		else printf("%d\n",ask(1,1,n,id[x],1));
	}return;
}

int main(){
	init();
	dfs(1,0,1);
	solve();
	return 0;
}
```

---

## 作者：He_Ren (赞：16)

### [P4092 [HEOI2016/TJOI2016]树](https://www.luogu.org/problemnew/show/P4092)

~~（题解居然没有和我方法一样的）~~

这题不用建树

fa[i]表示i的父节点

据说这样暴力就可以了


## 但是！

**有优化的方法**！

## 时间戳

nearfa[i] 表示 点i 最近的一个打了标记的祖先，默认1

t[i] 表示 **这个点最后一次被查询是在第几次标记之后**，默认1

cnt  表示 **执行了几次标记操作** ，~~为了方便~~，cnt从1开始

---
执行标记操作时，如果这个点已经被标记了，就不用再标记了。

否则标记，cnt++;

### find(u) 函数：（递归实现）

如果点u被标记，返回u ~~（废话）~~；

如果t[u]==cnt （在最后一次标记后已经访问过），直接返回nearfa[u] ；

否则, 将 t[u] 设为cnt，同时将 nearfa[u] 设为 find(fa[u]) , 返回 ;  (递归实现)

上代码：
```cpp
#include<cstdio>

int fa[100050];
bool flag[100050];
int t[100050],nearfa[100050],cnt=1;

int find(int u)
{
	if(flag[u])return u;//如果点u被标记，返回u
	if(t[u]==cnt)return nearfa[u];//在最后一次标记后已经访问过
	t[u]=cnt;//表示在此次标记后已被访问
	return nearfa[u]=find(fa[u]);//继续递归
}

int main(void)
{
	flag[1]=1; fa[1]=1;
	int n,q;
	scanf("%d%d",&n,&q);
	for(int i=1;i<n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		fa[v]=u;
	}
	for(int i=1;i<=n;i++)t[i]=nearfa[i]=1;//初始化
	for(int i=0;i<q;i++)
	{
		char oper;
		int u;
		scanf("\n%c %d",&oper,&u);
		if(oper=='C')
			{if(!flag[u])flag[u]=1,cnt++;}//如果没被标记，标记
		else printf("%d\n",find(u));
	}
	return 0;
}
```


时间复杂度：(最坏) $O(n^2)$

数据强一点可以卡掉

---

## 作者：NXYorz (赞：16)

看到各位大佬又是**树剖加线段树**或者**永久化**等等一系列高级操作，本蒟蒻表示太强了。

但是本蒟蒻感觉自己思路有点奇特并且翻了翻第一页的题解发现没有大佬和本蒟蒻的思路一样所以就想写出来。

本蒟蒻的基本思路就是**搜索**

首先我们先开一个数组father[i]表示i到最近染色的父亲。然后就开始我们维护每一次涂色，我们把每一次涂色点称作~~父亲~~，从父亲开始找他的儿子们和孙子们（下文我们用**它**来代替），如果**它**没有被染色的话那么**这个点所距离最近的染色的父亲**就一定是我们**当前染色的点**啦...

## **那么为什么如果这个点（它）被染色了就不能要了呢？**

如果有一个点**它**之前就已经被染色了，那么我们就已经把它的儿子们更新成**它本身**了，相对于**它**的父亲来说，**它**的儿子们显然是距离**它**本身更近，因为**它**本身也早已先一步相对于父亲标记了。

对于每一次询问我们只需要O（1）来回答就好啦。

 _PS：本来想插个图片的，可是本蒟蒻太菜了以至于不会，有没有会的大佬教一下...._ 
 
 [最后弱弱的推荐一下自己的博客](https://www.luogu.com.cn/blog/niexiaoyang12138/#)
 
 啊呀忘了代码了
 ```cpp
#include<iostream>
#include<cstdio>
#define N 100001
using namespace std;
int n,m,q,sum,head,tail;
int first[N],father[N],dl[N*5];
bool v[N];
struct E
{
	int next;
	int to;
} e[N];
void add(int x,int y)
{
	e[++sum].next=first[x];
	e[sum].to=y;
	first[x]=sum;
}
void in(int &x)
{
	x=0;
	char ee=getchar();
	while(ee<'0'||ee>'9') ee=getchar();
	while(ee>='0'&&ee<='9')
	{
		x=(x<<1)+(x<<3)+ee-'0';
		ee=getchar();
	}
}
void work(int x)
{
	v[x]=1;
	father[x]=x;
	head=0;
	tail=0;
	dl[++tail]=x;
	while(head<tail)
	{
		int now=dl[++head];
		for(int i=first[now]; i; i=e[i].next)
		{
			int u=e[i].to;
			if(v[u]) continue;
			dl[++tail]=u;
			father[u]=x;
		}
	}
}
int main()
{
	scanf("%d%d",&n,&q);
	for(int i=1; i<n; i++)
	{
		int ui,vi;
		scanf("%d%d",&ui,&vi);
		add(ui,vi);
	}
	v[1]=1;
	for(int i=1; i<=n; i++) father[i]=1;
	for(int i=1; i<=q; i++)
	{
		char oper;
		int num;
		cin>>oper;
		in(num);
		if(oper=='C'&&!v[num]) work(num);
		else if(oper=='Q') printf("%d\n",father[num]);
	}
	return 0;
}
```


---

## 作者：Styx (赞：13)

**这道题打了树链剖分的标签,然后一直没有人写树链剖分的题解,本蒟蒻就先献丑一下,权且当作抛砖引玉.**

**这道题有两种操作,一种是给某个点打上标记,另一种是查询某个节点最近的打标记的祖先,第一个操作非常好办,第二个的话,稍微想一下,祖先一定在这个点到根(也就是1)的路径上,然后这条路径是由若干条完整或不完整的链组成的.**

**我们把每个打标记的点记值为一,每次跳整条链的时候计算区间和,如果区间和大于零,说明这条链上至少有一个被标记的点.这段区间在树剖序里一定是连续的,所以我们可以对这段区间进行二分,每次需要查询区间和,复杂度大致是O(nlognlogn)其实还可以优化的,但那种线段树我太菜了不会写,所以就不贴了,反正我是来抛砖引玉的,期待大佬们给出更加高妙的树链剖分做法.**

**对了,之前的第一个操作,直接线段树点修改就可以了.**

**代码如下**

```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
#define lson root<<1
#define rson root<<1|1
using namespace std;

struct node
{
    int sum,l,r;
}tr[400040];
int deep[100010],fa[100010],size[100010],son[100010],w[100010],iid[100010],id[100010],c[100010],top[100010],cnt;
vector<int> g[100010];

void push_up(int root)
{
    tr[root].sum=tr[lson].sum+tr[rson].sum;
}

void build(int root,int l,int r)
{
    if(l==r)
    {
        tr[root].l=l;
        tr[root].r=r;
        tr[root].sum=w[l];
        return ;
    }
    tr[root].l=l;
    tr[root].r=r;
    int mid=(l+r)>>1;
    build(lson,l,mid);
    build(rson,mid+1,r);
    push_up(root);
}


void update(int root,int x,int val)
{
    if(x==tr[root].l&&x==tr[root].r)
    {
        tr[root].sum=val;
        return ;
    }
    int mid=(tr[root].l+tr[root].r)>>1;
    if(x<=mid)
    {
        update(lson,x,val);
    }
    else
    {
        update(rson,x,val);
    }
    push_up(root);
}

int query(int root,int l,int r)
{
    if(l==tr[root].l&&tr[root].r==r)
    {
        return tr[root].sum;
    }
    int mid=(tr[root].l+tr[root].r)>>1;
    if(l>mid)
    {
        return query(rson,l,r);
    }
    else
    {
        if(r<=mid)
        {
            return query(lson,l,r);
        }
    }
    return query(lson,l,mid)+query(rson,mid+1,r);
}

void dfs1(int now,int f,int dep)
{
    deep[now]=dep;
    fa[now]=f;
    size[now]=1;
    int maxson=-1;
    for(int i=0;i<g[now].size();i++)
    {
        if(g[now][i]==f)
        {
            continue;
        }
        dfs1(g[now][i],now,dep+1);
        size[now]+=size[g[now][i]];
        if(maxson<size[g[now][i]])
        {
            maxson=size[g[now][i]];
            son[now]=g[now][i];
        }
    }
}

void dfs2(int now,int topf)
{
    id[now]=++cnt;
    iid[cnt]=now;
    w[cnt]=c[now];
    top[now]=topf;
    if(!son[now])
    {
        return;
    }
    dfs2(son[now],topf);
    for(int i=0;i<g[now].size();i++)
    {
        if(g[now][i]==son[now]||g[now][i]==fa[now])
        {
            continue;
        }
        dfs2(g[now][i],g[now][i]);
    }
}

int check(int l,int r)
{
    if(l==r)
    {
        return l;
    }
    int mid=(l+r)>>1;
    int tmp=query(1,mid+1,r);
    if(tmp)
    {
        return check(mid+1,r);
    }
    else
    {
        return check(l,mid);
    }
}

int path_query(int x,int y)
{
    while(top[x]!=top[y])
    {
        if(deep[top[x]]<deep[top[y]])
        {
            swap(x,y);
        }
        int tmp=query(1,id[top[x]],id[x]);
        if(!tmp)
        {
            x=fa[top[x]];
        }
        else
        {
            return check(id[top[x]],id[x]);
        }
    }
    if(deep[x]>deep[y])
    {
        swap(x,y);
    }
    return check(id[x],id[y]);
}

int main()
{
    int n,m,vv;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n-1;i++)
    {
        int from,to;
        scanf("%d%d",&from,&to);
        g[from].push_back(to);
        g[to].push_back(from);
    }
    c[1]=1;
    dfs1(1,0,1);
    dfs2(1,1);
    build(1,1,n);
    char c;
    for(int i=1;i<=m;i++)
    {
        scanf("\n%c %d",&c,&vv);
        if(c=='C')
        {
            update(1,id[vv],1);
        }
        if(c=='Q')
        {
            printf("%d\n",iid[path_query(1,vv)]);
        }
    }
}
```

---

## 作者：wenjie (赞：7)

写成完整的树链剖分+线段树并没有什么优势，dfs序便足够维护。

利用子树dfs序连续性，套线段树模板即可。

具体来说，询问即单点查询（此时，查询区间设为dfn[x]~dfn[x]即可）

而为一个节点打标记时，update dfn[x]~(dfn[x]+size[x]-1)

update时 比较之前储存的最近祖先与将要更新的点的深度，保留更深的节点。

query时 由于从mid断开的两个区间(因为本题要求单点查询)必有一个return 0 故可以return a+b;

详见代码，一份~~十分工整~~泥古不化的线段树模板。
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,q,cnt,ccnt;
int head[400005];
int lazy[400005];
int tr[400005];
int dfn[400005];
int size[400005];
int dep[400005];
char s;
struct data{
	int to,next;
}e[400005];
inline void insert(int u,int v)
{
	e[++cnt].to=v;
	e[cnt].next=head[u];
	head[u]=cnt;
}
void build(int root,int left,int right)
{
	if(left==right){tr[root]=1;return ;}
	int mid=(left+right)>>1;
	build(root<<1,left,mid);
	build(root<<1|1,mid+1,right);
	tr[root]=1;
	return ;
}
void dfsdfn(int x)//处理dfs序
{
	dfn[x]=++ccnt;
	size[x]=1;
	for(int i=head[x];i;i=e[i].next)
	{
		int v=e[i].to;
		dep[v]=dep[x]+1;
		dfsdfn(v);
		size[x]+=size[v];
	}
	return ;
}
void push(int root,int left,int right)
{
	if(dep[tr[root<<1]]<=dep[lazy[root]])
    		tr[root<<1]=lazy[root],lazy[root<<1]=lazy[root];
	if(dep[tr[root<<1|1]]<=dep[lazy[root]])
    		tr[root<<1|1]=lazy[root],lazy[root<<1|1]=lazy[root];
	return;
}
void update(int root,int left,int right,int l,int r,int k)
{
	if(left>=l&&right<=r)
	{
		if(dep[tr[root]]<=dep[k])
		{
			tr[root]=k;
			lazy[root]=k;
		}
		return ;
	}
	if(left>r||right<l)return;
	int mid=(left+right)>>1;
	if(lazy[root])push(root,left,right);
	update(root<<1,left,mid,l,r,k);
	update(root<<1|1,mid+1,right,l,r,k);
	return ;	
}
int query(int root,int left,int right,int l,int r)
{
	if(left>=l&&right<=r)
	{
		return tr[root];
	}
	if(left>r||right<l)return 0;
	int mid=(left+right)>>1;
	if(lazy[root])push(root,left,right);
	int a=query(root<<1,left,mid,l,r);
	int b=query(root<<1|1,mid+1,right,l,r);
	return a+b;
}
int main()
{
	n=read();
	q=read();
	for(int i=1;i<n;i++)
	{
		int a=read();
		int b=read();
		insert(a,b);
	}
	dep[1]=1;
	dfsdfn(1);
	build(1,1,n);
	for(int i=1;i<=q;i++)
	{
		scanf("%s",&s);
		if(s=='Q')
		{
			int x=read();
			printf("%d\n",query(1,1,n,dfn[x],dfn[x]));
		}
		else
		{
			int x=read();
			update(1,1,n,dfn[x],dfn[x]+size[x]-1,x);
		}
	}
}
```



---

## 作者：万弘 (赞：4)

### [HEOI2016/TJOI2016]树（LCT）

考虑询问操作，一种朴素的想法是，把这个点到根的路径扯出来，然后二分/倍增 计算。

事实上“扯出到根的路径”这一步恰对应有根树LCT的$\text{access}$操作，那么倍增计算也不需要了，在splay上二分即可。

注意修改时要$\text{access}$,再$\text{splay}$到根，再修改，否则祖先的信息会错掉（事实上绝大部分LCT的修改都要如此）

时间复杂度$\Theta(m\log n)$,有根树LCT常数其实不大，O2之后最长点不到100ms。

```cpp
#define MAXN 200011
struct LCT
{
    int fa[MAXN],son[MAXN][2],val[MAXN],f[MAXN];
    bool not_root(int x){return son[fa[x]][0]==x||son[fa[x]][1]==x;}
    void pushup(int x){f[x]=f[son[x][0]]|f[son[x][1]]|val[x];}
    void rotate(int x)
    {
        int y=fa[x],z=fa[y],k=(son[y][1]==x);
        if(not_root(y))son[z][son[z][1]==y]=x;
        fa[x]=z;
        son[y][k]=son[x][!k],fa[son[x][!k]]=y;
        son[x][!k]=y,fa[y]=x;
        pushup(y),pushup(x);
    }
    void splay(int x)
    {
        while(not_root(x))
        {
            int y=fa[x];
            if(not_root(y))rotate((son[y][1]==x)==(son[fa[y]][1]==y)?y:x);
            rotate(x);
        }
    }
    void access(int x)
    {
        for(int y=0;x;y=x,x=fa[x])
            splay(x),son[x][1]=y;
    }
    int Qtag(int x)//splay上二分
    {
        if(son[x][1]&&f[son[x][1]])return Qtag(son[x][1]);
        if(val[x])return x;
        return Qtag(son[x][0]);
    }
    int Query(int x){access(x),splay(x);return Qtag(x);}//询问祖先中最深的有色点
    void modify(int x){access(x),splay(x),val[x]=1,pushup(x);}//染色操作
}lct;
```

---

## 作者：Ccliang (赞：4)

怎么都是并查集，标记永久化啥的题解，我大树剖表示不服！

~~这不就是树剖模板么~~

思路：

对于每次打标记的点，更新其子树的答案。

更新时取深度最深的点最为答案。

~~不就是维护区间最值嘛。~~

~~然后拿树剖模板一套就过了~~

代码：~~知道你们只看这个~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int N = 100000 + 10;

inline int read()
{
	int res=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')res=(res<<3)+(res<<1)+(ch^48),ch=getchar();
	return res;
}

struct edge{
	int next,to;
}r[N<<1];

int head[N],tot;

inline void add(int u,int v)
{
	r[++tot]=(edge){head[u],v};
	head[u]=tot;
	r[++tot]=(edge){head[v],u};
	head[v]=tot;
}

int dep[N],size[N],fa[N],son[N],top[N],id[N],cnt;

void dfs1(int u,int father)
{
	fa[u]=father,dep[u]=dep[father]+1,size[u]=1;
	for(int e=head[u];e;e=r[e].next)
	{
		int v=r[e].to;
		if(v==father)continue;
		dfs1(v,u);
		size[u]+=size[v];
		if(size[v]>size[son[u]])
			son[u]=v;
	}
}

void dfs2(int u,int topf)
{
	top[u]=topf;
	id[u]=++cnt;
	if(!son[u])
		return ;
	dfs2(son[u],topf);
	for(int e=head[u];e;e=r[e].next)
	{
		int v=r[e].to;
		if(v==fa[u]||v==son[u])continue;
		dfs2(v,v);
	}
}

int tree[N<<2],lazy[N<<2];
#define lson pos<<1
#define rson pos<<1|1
void pushdown(int pos)
{
	if(!lazy[pos])return ;
	int k=lazy[pos];
	lazy[pos]=0;
	tree[lson]=dep[k]>dep[tree[lson]]?k:tree[lson];
	tree[rson]=dep[k]>dep[tree[rson]]?k:tree[rson];
	lazy[lson]=dep[k]>dep[lazy[lson]]?k:tree[lson];
	lazy[rson]=dep[k]>dep[lazy[rson]]?k:tree[rson];
}

void change(int pos,int l,int r,int L,int R,int x)
{
	if(l>R||r<L)
		return ;
	if(l>=L&&r<=R)
	{
		tree[pos]=dep[x]>dep[tree[pos]]?x:tree[pos];
		lazy[pos]=dep[x]>dep[lazy[pos]]?x:lazy[pos];
		return ;
	}
	pushdown(pos);
	int mid=(l+r)>>1;
	if(dep[x]>dep[tree[lson]])
		change(lson,l,mid,L,R,x);
	if(dep[x]>dep[tree[rson]])
		change(rson,mid+1,r,L,R,x);
    //如果区间最劣的答案都比修改值优就不需要往下递归了
	tree[pos]=dep[tree[lson]]<dep[tree[rson]]?tree[lson]:tree[rson];
}

int query(int pos,int l,int r,int x)
{
	if(l==x&&r==x)
		return tree[pos];
	pushdown(pos);
	int mid=(l+r)>>1;
	if(x<=mid)return query(lson,l,mid,x);
	else return query(rson,mid+1,r,x);
}

int n,Q;

char opt;

int main()
{
	n=read(),Q=read();
	for(int i=1,u,v;i<n;i++)
		u=read(),v=read(),add(u,v);
	dfs1(1,0),dfs2(1,1);
	change(1,1,n,id[1],id[1]+size[1]-1,1);
	int num;
	while(Q--)
	{
		cin>>opt;
		num=read();
		if(opt=='Q')
			printf("%d\n",query(1,1,n,id[num]));
		if(opt=='C')
			change(1,1,n,id[num],id[num]+size[num]-1,num);
	}
    return 0;
}
```


---

## 作者：__Watcher (赞：3)

似乎没有一篇题解是对询问分块。

---

若该题的询问中，前半部分都是标记，后半部分都是查询，这种静态的情况下，显然可以 $O(n)$ 预处理出每个点的答案，$O(1)$ 输出。

然而现在带上了修改，于是考虑对询问分块。设块长为 $k$。

对于每一个询问：

1. 块内。枚举每个插入操作，判断该操作标记的节点是否为当前节点的祖先（使用 $dfs$ 序判断），并更新答案。

2. 块外。在每一块的终点，对之前的所有操作进行与静态情况相同的预处理。询问时可 $O(1)$ 查询该部分的答案。

复杂度为 $O(qk+n+\frac{nq}{k})$，分析得 $k$ 应取 $\sqrt n$。

---

如果你这么写，显然只有 $60 \rm{pts}$ 的好成绩。

卡常小技巧：

1. 由于需要多次计算当前分块的下界，该计算需要使用模运算，较为缓慢。可以使用变量维护这个值，在块的终点加上块长即可。

2. 使用数组版的邻接链表，而非 vector 版的。

3. 多次修改块长卡进时限。（ 实测 $k$ 取 $n^{0.6}$ 较优 ）。

---

提供代码，仅供参考（ 可不开 O2 AC ）：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll read() {
	ll x=0, f=1; char ch=' ';
	while(!isdigit(ch)) {ch=getchar(); if(ch=='-') f=-1;}
	while(isdigit(ch)) x=(x<<3)+(x<<1)+(ch^48), ch=getchar();
	return x*f;
}
int n, q, K, tot, h[100005], x[100005], dfn[100005], sz[100005], clk, minn[100005], dp[100005], up;
int vis[100005];
char type[100005][2];
struct AB{
	int a, b, n;
}d[200005];
void charu(int a, int b) {
	d[++tot].a=a, d[tot].b=b, d[tot].n=h[a], h[a]=tot;
} 
void dfs(int u, int fa) {
	dp[u]=dp[fa]+1, sz[u]=1, dfn[u]=++clk;
	for(int k=h[u];k;k=d[k].n) {
		int v=d[k].b;
		if(v==fa) continue;
		dfs(v, u);
		sz[u]+=sz[v];
	}
}
void dfs1(int u, int fa, int tmp) {
	int nowtmp=tmp;
	if(vis[u]==1) nowtmp=u;
	minn[u]=nowtmp;
	for(int k=h[u];k;k=d[k].n) {
		int v=d[k].b;
		if(v==fa) continue;
		dfs1(v, u, nowtmp);
	}
}
int main() {
	cin>>n>>q;
	for(int i=1;i<n;i++) {
		int a=read(), b=read();
		charu(a, b), charu(b, a);
	}
	dfs(1, 1);
	K=pow(n, 0.6);
	vis[1]=1;
	dfs1(1, 1, 1);
	for(int i=1;i<=q;i++) {
		scanf("%s", type[i]);
		x[i]=read();
		if(type[i][0]=='Q') {
			int nowtmp=minn[x[i]];
			for(int j=i-1;j>up;j--) {
				if(type[j][0]=='C') {
					if(dfn[x[i]]>=dfn[x[j]]&&dfn[x[i]]<=dfn[x[j]]+sz[x[j]]-1) {
						if(dp[x[j]]>dp[nowtmp]) nowtmp=x[j];
					}
				}
			}
			printf("%d\n", nowtmp);
		}
		if(i%K==0) {
			for(int j=i;j>up;j--) {
				if(type[j][0]=='C') vis[x[j]]=1;
			}
			dfs1(1, 1, 1);
			up+=K;
		}
	}
}

```
---

后记：此种做法可以维护更多信息，详情请移步 [CF342E](https://www.luogu.com.cn/problem/CF342E)。


---

## 作者：wwwsy (赞：2)



思路比较简单

- 先读入所有的操作

- 用时间做标记
	（1单位时间 = 一次操作）

- tag[i]表示点 i 最早一次被打上tag的时间

- 一遍 dfs 维护离点 i 最近的打了标记的祖先 top[ i ]

- query( i , time )访问 : i 表示从 i 点访问
	, time 表示这次访问发生的时间；
    
	1. 如果 tag[ top[ i ] ] > time （在访问之后才打的标记） -----> query( fa[ top[ i ] ] , time )
    
   1. 反之 输出 top[ i ] ; 
    

------------


```
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,q;
int u,v;
struct ty{
	int next,to;
}edge[N];
int head[N];

int fa[N];
int cnt;
void add(int x,int y){
	edge[++cnt].next =head[x];
	edge[cnt].to =y;
	head[x]=cnt;
	fa[y]=x;
}

char c;
int d;
int tag[N];
int num;
struct tp{
	int id,timee;
}qy[N];

int top[N];
void dfs(int x){
	if(tag[x]!=-1) top[x]=x;
	for(int i=head[x];i;i=edge[i].next ){
		top[edge[i].to]=top[x];
		dfs(edge[i].to);
	}
}

void query(int x,int timee){
	if(tag[top[x]]<timee){
		printf("%d\n",top[x]);
		return;
	}
	else{
		query(fa[top[x]],timee);
		return;
	}
}

int main(){
	scanf("%d%d",&n,&q);
	for(int i=1;i<n;i++){
		scanf("%d%d",&u,&v);
		add(u,v);
	}
	memset(tag,-1,sizeof(tag));
	for(int i=1;i<=q;i++){
		scanf(" %c %d",&c,&d);
		if(c=='Q'){
			qy[++num].id =d;
			qy[num].timee=i;
		} 
		if(c=='C'){
			if(tag[d]==-1) tag[d]=i;
			tag[d]=min(tag[d],i);
		}
	}
	tag[1]=0;
	top[1]=1;
	dfs(1);
//	for(int i=1;i<=n;i++) printf("%d ",top[i]);
	for(int i=1;i<=num;i++){
		query(qy[i].id,qy[i].timee);
	}
	return 0;
}
```


---

## 作者：maoyujie (赞：2)

由于自己一时愚蠢yy出一种奇怪~~没必要~~的做法
正常的树剖+线段树。
但是我那时候想要用bool数组表示线段树一个节点的状态
所以就用~~假的~~线段树二分了。。。
c[x]表示线段树编号为x的节点有没有点被染过色
更新操作显然。
查询的话就对节点到1的路径对应的线段树的不连续的几段
按dfs序从大到小分别用线段树二分就行了吧。
具体操作看代码吧    ~~虽然开个int数组就不用二分了~~
```cpp
#include<bits/stdc++.h>
#define ls (x<<1)
#define rs (x<<1|1)
using namespace std;
const int N=100005;
inline void read(int &x,int f=1,char c=getchar()){
	for(x=0;!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=x*10+c-48;x*=f;
}
int dep[N],top[N],siz[N],fa[N],pos[N],id[N],son[N];
int n,T,x,y,clo;vector<int>G[N];char c[N<<2],opt[2];
void dfs(int x){
    siz[x]=1;dep[x]=dep[fa[x]]+1;
    for(int i=0;i<G[x].size();i++){
        int to=G[x][i];if(to==fa[x])continue;
        fa[to]=x;dfs(to);siz[x]+=siz[to];
        if(siz[to]>siz[son[x]])son[x]=to;
    }
}
void dfs2(int x,int y){
    pos[x]=++clo;id[clo]=x;top[x]=y;
    if(son[x])dfs2(son[x],y);
    for(int i=0;i<G[x].size();i++){
        int to=G[x][i];
        if(to!=son[x]&&to!=fa[x])dfs2(to,to);
    }
}
void change(int x,int l,int r,int p){
	if(l==r){c[x]=1;return;}
	int mid=l+r>>1;
	if(p<=mid)change(ls,l,mid,p);
	else change(rs,mid+1,r,p);
	c[x]=c[ls]|c[rs];
}
int query(int x,int l,int r,int L,int R){
	if(l==r&&c[x])return l;
	int mid=l+r>>1,tmp=0;
	if(R>mid&&c[rs])
		tmp=max(tmp,query(rs,mid+1,r,L,R));
	if((!tmp)&&L<=mid&&c[ls])
		tmp=max(tmp,query(ls,l,mid,L,R));
	return tmp;
}
int solve(int x,int res=0){
	for(;x;x=fa[top[x]]){
		res=query(1,1,n,pos[top[x]],pos[x]);
		if(res)return id[res];
	}
	return 1;
}
int main(){
	read(n),read(T);
	for(int i=1;i<n;i++){
		read(x),read(y);
		G[x].push_back(y),G[y].push_back(x);
	}
	dfs(1),dfs2(1,1),change(1,1,n,pos[1]);
	while(T--){
		scanf("%s",opt),read(x);
		if(opt[0]=='C')change(1,1,n,pos[x]);
		else printf("%d\n",solve(x));
	}
	return 0;
}
```

---

## 作者：small_lemon_qwq (赞：1)

树剖、LCT、离线见鬼去吧。

只需要普通的 dfs 序以及树上前缀和（差分）就可以了。

考虑树上前缀和，有标记为 $0$，否则为标记次数，显然用树状数组维护。

修改就是将节点 $u$ 的所有子树的前缀和值加 $1$，树状数组区间加即可，所以这里用的树状数组是区间加，单点查询的树状数组。

考虑查询，比较暴力的方法是二分答案与 $u$ 的深度差，再用类似倍增法 LCA 的方式得到当前二分的答案是那个点，直接差分判断即可，时间复杂度是 $\operatorname{O}(n\log^2n)$。

但实际上不用这么麻烦，倍增法 LCA 的最后一步就是直接贪心，如果直跳向上 $2^i$ 步不是答案，那就让 LCA 的两个点同时往上跳 $2^i$ 步（$i$ 从大到小枚举），这里也可以用一样的方式来求，但时间复杂度就还是 $\operatorname{O}(n\log^2n)$，因为查询需要时间，不过也能过。

用分块可以做到 $\operatorname{O}(n\sqrt n)$，但我没写。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,f[100005][18],sz[100005],dep[100005],pos[100005],cnt;
vector<int>g[100005];
void dfs(int x,int fa){
	pos[x]=++cnt;
	f[x][0]=fa;
	sz[x]=1;
	for(auto y:g[x]){
		if(y==fa)continue;
		dep[y]=dep[x]+1;
		dfs(y,x);
		sz[x]+=sz[y];
	}
}
int t[100005];
inline void add(int x,int d){
	while(x<=n){
		t[x]+=d;
		x+=x&-x;
	}
}
int ask(int x){
	int ans=0;
	while(x){
		ans+=t[x];
		x-=x&-x;
	}
	return ans;
}
inline void update(int l,int r,int c){
	add(l,c);
	add(r+1,-c);
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<n;i++){
		int x,y;
		cin>>x>>y;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	dep[1]=1;
	dfs(1,1);
	add(1,1);
	for(int i=1;i<=__lg(n);i++){
		for(int j=1;j<=n;j++){
			f[j][i]=f[f[j][i-1]][i-1];
		}
	}
	while(m--){
		char op;
		int u;
		cin>>op>>u;
		if(op=='C'){
			update(pos[u],pos[u]+sz[u]-1,1);
		}else if(op=='Q'){
			for(int i=__lg(dep[u]);i>=0;--i){
				if(ask(pos[f[u][i]])==ask(pos[u])){
					u=f[u][i];
				}
			}
			cout<<u<<"\n";
		}
	}
	return 0;
}
```

---

## 作者：Rhodoks (赞：1)

不知道为什么没有用树链剖分+$\text{set}$过的。

使用树链剖分把从根到任意节点的路径剖成$O(\log(n))$段路径，对每条路径开一个$\text{set}$按照深度从深到浅维护路径上被打标记的节点。标记时将节点插入所述路径的$\text{set}$。查询在当前路径的$\text{set}$中用$\text{lower\_bound}$查询深度小于等于当前节点的最深的节点，如果查不到则上跳至上一段路径。时间复杂度为$O(n\log^2n)$。

```cpp
#include <bits/stdc++.h>
#define DB double
#define LL long long

#define MST(a,b) memset((a),(b),sizeof(a))
#define MRK() cout<<"Mark"<<endl;
#define WRT(x) cout<<#x<<" = "<<(x)<<endl;

#define MAXN 210000
#define MAXM 410000
#define MOD 998244353
#define INF 0x3f3f3f3f
#define LLINF 0x3f3f3f3f3f3f3f3f
#define EPS 1e-5

#define _ 0
using namespace std;

int depth[MAXN],pa[MAXN],top[MAXN],son[MAXN],size[MAXN];
bool flag[MAXN];
vector<int> g[MAXN];
int n,q;

struct cmp
{
	bool operator()(const int &x,const int &y)
	{
		return depth[x]>depth[y];
	}
};
set<int,cmp> st[MAXN];

void dfs1(int pos,int f)
{
	pa[pos]=f;
	size[pos]=1;
	depth[pos]=depth[f]+1;
	for (auto p:g[pos])
		if (p!=f)
		{
			dfs1(p,pos);
			size[pos]+=size[p];
			if (size[p]>size[son[pos]])
				son[pos]=p;
		}
}

void dfs2(int pos,int topf)
{
	top[pos]=topf;
	if (son[pos])
		dfs2(son[pos],topf);
	for (auto p:g[pos])
		if (p!=pa[pos] && p!=son[pos])
			dfs2(p,p);
}

void init()
{
	int x,y;
	cin>>n>>q;
	for (int i=1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		g[x].push_back(y);
		g[y].push_back(x);
	}
}

void insert(int x)
{
	if (flag[x])
		return;
	st[top[x]].insert(x);
	flag[x]=1;
}

int query(int x)
{
	while (1)
	{
		auto p=st[top[x]].lower_bound(x);
		if (p!=st[top[x]].end())
			return *p;
		x=pa[top[x]];
	}
}

void work()
{
	char op;
	int x;
	insert(1);
	while (q--)
	{
		scanf("\r\n%c%d",&op,&x);
		if (op=='C')
			insert(x);
		else
			printf("%d\n",query(x));
	}
}

int main()
{
	init();
	dfs1(1,1);
	dfs2(1,1);
	work();
	return ~~(0^_^0);
}


```


---

## 作者：Kisaragi_77 (赞：1)

### 吼题啊！

首先看一下小数据/随机数据的部分

很容易想到的一种方法就是直接维护每个节点的答案

直接维护每个节点的答案

如果遇到一个修改就直接下放到子树的所有节点当中，更新

这样，每次修改最坏都是$O(n)$的,查询$O(1)$ 

看起来貌似很不错，不过很容易被一条链的修改操作卡到飞起

***GG my friend !***

考虑性能瓶颈：

- 每次有大量的访问都是无效的，即很多点都没有更新
- 每次对子树内的点更新最值的话一个个遍历太傻



这样优化的思路就很清晰了，我们可以采用解决数据结构题的通用思路来解题



**1.离线处理？**

先读进来所有询问，离线处理整棵树最后的样子，再搞出每个点被修改的时间？

好像不可做

看到题解区有用并查集维护祖先关系的做法，推荐学习

~~离线做法辣鸡(苟头)~~





**2.大力维护？**

直接套用我们一开始的思路

对子树内的点所得的一段区间(dfs序在一块)进行更新

能不能做我还真的不知道

好像题解区有人用标记永久化的思想过了





**2.二分？**

在一条到根的路径上二分一段区间有没有标记

由于是动态的估计倍增应该GG了

硬要写的话可以写个树状数组  +  普通的树链剖分（树状数组维护区间标记数量）

这样的话二分深度即可

树状数组很好写，但这个二分估计不太好写

这样我们便得到了一个$(O(nlog^2n))$ 的优秀做法，可以通过本题了

然而两个log过于屑，考虑一个log

~~听说长链剖分可以$O(1)$维护$2^k$祖先信息?~~





**3.适当转化--树链剖分裸题？**

上面的想法加起来只花了我5分钟左右就全部弃了

有没有简单一点的实现呢？

![1566574244356](https://cdn.luogu.com.cn/upload/pic/74455.png)

考虑我们标记了2

那么对于2下面的点，1就没用了

考虑上面二分做法的思路

我们拉一条从查询点(如图点4)到点1的路径

只要查询第一个碰到的有标记的点即可

**----也就是dfs序最小的点！**

这不就一树剖板子么？

单点修改，区间求最小值

查询返回树剖中维护的rank值(dfs序为i的节点编号)即可



```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define ls (o<<1)
#define rs (o<<1|1)
using namespace std;
inline int read(){
	int x;scanf("%d",&x);return x;
}
const int N =1e5+5;
int head[N],tot,fa[N],son[N],sz[N],dep[N],top[N],id[N],rk[N],clk,n,val[N<<2];
struct Edge{
	int to,nxt;
}e[N<<1];
inline void addEdge(int u,int v){
	e[++tot].nxt =head[u];head[u] =tot;e[tot].to =v;
}
inline void dfs(int u){
	sz[u] =1;
	for(int i=head[u];i;i=e[i].nxt){
		int v =e[i].to;
		if(v==fa[u])	continue;
		fa[v] =u;
		dep[v] =dep[u] +1;
		dfs(v);
		sz[u] +=sz[v];
		if(sz[v]>sz[son[u]])	son[u] =v;
	}
}
inline void link(int u,int t){
	top[u] =t;	id[u] =++clk;	rk[clk] =u;
	if(!son[u])	return ;
	link(son[u],t);
	for(int i=head[u];i;i=e[i].nxt){
		int v =e[i].to;
		if(v!=fa[u] && v!=son[u])	link(v,v);
	}
}
inline void update(int o){
	val[o] =max(val[ls],val[rs]);
}
inline void modify(int o,int l,int r,int x,int v){
	if(l==r)	return (void)(val[o] =v);
	int mid =(l+r) >>1;
	if(x<=mid)	modify(ls,l,mid,x,v);
	else modify(rs,mid+1,r,x,v);
	update(o);
}
inline int query(int o,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr)	return val[o];
	int mid =(l+r) >>1,ans =0;
	if(ql<=mid)	ans =max(ans,query(ls,l,mid,ql,qr));
	if(mid+1<=qr)	ans =max(ans,query(rs,mid+1,r,ql,qr));
	return ans;
}
inline int askRan(int x,int y){
	int ans =0;
	while(top[x]!=top[y]){
		if(dep[top[x]] < dep[top[y]])	swap(x,y);
		ans =max(ans,query(1,1,n,id[top[x]],id[x]));
		x =fa[top[x]];
	}
	if(dep[x] > dep[y])	swap(x,y);
	ans =max(ans,query(1,1,n,id[x],id[y]));
	return ans;
}
int main(){
	n =read();	int T =read();
	for(int i=1;i<=n-1;++i){
		int u =read(),v =read();
		addEdge(u,v);
		addEdge(v,u);
	}
	dfs(1);
	link(1,1);
	modify(1,1,n,id[1],id[1]);
	while(T--){
		char op[5];	scanf("%s",op);
		int x =read();
		if(op[0]=='C')	modify(1,1,n,id[x],id[x]);
		else printf("%d\n",rk[askRan(1,x)]);
	}
}
```













---

## 作者：LevenKoko (赞：1)

### 来一发大暴力

   对于某个询问节点，二分答案所在的深度，若该深度到该节点上的区间和>0，说明其中有满足条件的点，增加深度继续二分，否则减小深度

线段树上的操作：单点修改+区间查询（区间和）

关于时间：

时间复杂度$O(nlog^{2}n)$
虽然不是最优解法，但能过了，稍微卡一下，总时间大概900ms,最大点300ms,如果$O(nlogn)$的玩家太注重卡常的话还是可以碾的,当然我的代码还有优化余地...（比如传参部分可以用空间换时间，卡常玩家可以尝试一下（还有fread之类的都可以尝试一下））

~~关于最优解法：我有一个绝妙的思路，这里篇幅太小写不小，你可以看别人的题解~~

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#define writeln(x)  write(x),puts("")
using namespace std;
inline int read(){
	int ans=0,f=1;char chr=getchar();
	while(!isdigit(chr)){if(chr=='-') f=-1;chr=getchar();}
	while(isdigit(chr)){ans=(ans<<3)+(ans<<1)+chr-48;chr=getchar();}
	return ans*f;
}void write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}const int M=100005;char opt[2];
int head[M<<1],ver[M<<1],x,y,nxt[M<<1],tot,n,m,dep[M],fa[M],tp[M],sz[M],son[M],idx[M],s[M<<2],rk[M];
inline void add(int x,int y){ver[++tot]=y,nxt[tot]=head[x],head[x]=tot;}
void dfs1(int x,int f){
	sz[x]=1;dep[x]=dep[f]+1,fa[x]=f;
	for(register int i=head[x];i;i=nxt[i]){
		if(!dep[ver[i]]){
			dfs1(ver[i],x),sz[x]+=sz[ver[i]];
			if(sz[son[x]]<sz[ver[i]]) son[x]=ver[i];
		}
	}
}int t;
void dfs2(int x,int topf){
	idx[x]=++t;tp[x]=topf;rk[t]=x;
	if(!son[x]) return;
	dfs2(son[x],topf);
	for(int i=head[x];i;i=nxt[i])
		if(!idx[ver[i]]) dfs2(ver[i],ver[i]);
}
#define ls (i<<1)
#define rs (i<<1|1)
#define mid (l+r>>1)
inline void Push_Up(int i){s[i]=s[ls]+s[rs];}
void Update(int i,int l,int r,int pos,int x){
	if(l==r){s[i]=x;return;}
	if(pos<=mid) Update(ls,l,mid,pos,x);
	else Update(rs,mid+1,r,pos,x);
	Push_Up(i);
}
int Query(int i,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr) return s[i];int ans=0;
	if(ql<=mid) ans+=Query(ls,l,mid,ql,qr);
	if(qr>mid)  ans+=Query(rs,mid+1,r,ql,qr);
	return Push_Up(i),ans;
}
inline void Ask(int x){
	if(Query(1,1,n,idx[x],idx[x])) {cout<<x<<endl;return;}
	while(x){
		int t=Query(1,1,n,idx[tp[x]],idx[x]);
		if(t==0){x=fa[tp[x]];continue;}
		else{
			register int ll=idx[tp[x]],rr=idx[x],midd,ans;
			while(ll<=rr){
				midd=ll+rr>>1;
				if(Query(1,1,n,midd,rr)) ans=midd,ll=midd+1;
				else rr=midd-1;
			}return (void)(writeln(rk[ans]));
		}
	}
}
int main(){
	n=read(),m=read();
	for(register int i=1;i<n;++i)x=read(),y=read(),add(x,y),add(y,x);
	dfs1(1,0),dfs2(1,1);Update(1,1,n,1,1);
	while(m--){
		scanf("%s",opt+1);x=read();
		if(opt[1]=='Q')	Ask(x);
		else	Update(1,1,n,idx[x],1);
	}
	return 0;
}

```

---

## 作者：newhy2001 (赞：1)

### 可以使用一个数组来维护最近标记祖先，每次打标记就往下更新，直到有一个子节点的最近标记祖先的深度大于等于当前改动的数的深度就停止~
## 代码如下：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,t;
int head[100001],next[100001],end[100001],deep[100001],latest[100001];
inline int read() {
	int s=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='C') return 0;//快读的同时又把字符一起判断了~
		if(ch=='Q') return 1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		s=(s<<1)+(s<<3)+ch-'0';
		ch=getchar();
	}
	return s;
}
void add(int x,int y) {//链式前向星存法~
	next[++t]=head[x];
	head[x]=t;
	end[t]=y;
	return;
}
void build(int x) {
	for(int i=head[x];i;i=next[i]) {//建立树，给最近祖先赋初值1，计算深度~
		int to=end[i];
		deep[to]=deep[x]+1;
		latest[to]=1;
		build(to);
	}
	return;
}
void change(int x) {//改变深度~
	for(int i=head[x];i;i=next[i]) {
		int to=end[i];
		if(deep[latest[x]]>deep[latest[to]]) {//比较之前此节点的祖先深度与当前祖先深度的大小~
			latest[to]=latest[x];//深度大就更新~
			change(to);//继续找~（ps:深度小就不更新，因为要找最近的~）
		}
	}
	return;
}
int main() {
	n=read();
	m=read();
	deep[1]=1;
	latest[1]=1;
	for(int i=1;i<n;i++) {
		int x=read(),y=read();
		add(x,y);
	}
	build(1);
	for(int i=1;i<=m;i++) {
		int pan=read();
		int x;
		if(!pan) {
			x=read();
			latest[x]=x;//打标记~（当前节点的最近祖先一定是自己重复也无所谓，可以单独判断跳过重复）
			change(x);//向下更新最近标记祖先~
		}
		else {
			x=read();
			printf("%d\n",latest[x]);//直接输出即可~
		}
	}
	return 0;
}
```

---

## 作者：Aleph1022 (赞：1)

树剖做法不难想到吧，区间 $\max$ 就行。楼下大佬也讲了，我就不多说。

为了~~投题解~~展示出个性，我翻了一圈题解，发现用树剖的都是用最通用的写法——DFS。

由于之前膜你赛 DFS 求 $\mathrm{size}$ 被卡爆栈，所以决定多用 BFS。

顺便展示一下个人 YY 出来的 BFS 树剖写法。

代码：
```cpp
#include <cstdio>
#include <algorithm>
#define ls (p << 1)
#define rs (ls | 1)
using namespace std;
const int N = 1e5;
int n,q;
int seg[(N << 2) + 10];
int to[(N << 1) + 10],pre[(N << 1) + 10],first[N + 10],edge_tot;
inline void add(const int &u,const int &v)
{
    to[++edge_tot] = v;
    pre[edge_tot] = first[u];
    first[u] = edge_tot;
}
void change(int x,int p,int tl,int tr)
{
    if(tl == tr)
    {
        seg[p] = x;
        return ;
    }
    int mid = tl + tr >> 1;
    if(x <= mid)
        change(x,ls,tl,mid);
    else
        change(x,rs,mid + 1,tr);
    seg[p] = max(seg[ls],seg[rs]);
}
int query(int l,int r,int p,int tl,int tr)
{
    if(l <= tl && tr <= r)
        return seg[p];
    int mid = tl + tr >> 1;
    int ret = -1;
    if(l <= mid)
        ret = max(ret,query(l,r,ls,tl,mid));
    if(r > mid)
        ret = max(ret,query(l,r,rs,mid + 1,tr));
    return ret;
}
int f[N + 10],d[N + 10],size[N + 10],son[N + 10],top[N + 10],rk[N + 10],id[N + 10],dfn_tot;
int answer(int x)
{
    int fx = top[x];
    int ret = -1;
    while(fx)
    {
        ret = max(ret,query(id[fx],id[x],1,1,n));
        x = f[fx],fx = top[x];
    }
    return ret;
}
int que[N + 10],head = 1,tail = 1;
int main()
{
    scanf("%d%d",&n,&q);
    int u,v;
    for(register int i = 1;i < n;++i)
        scanf("%d%d",&u,&v),add(u,v),add(v,u);//（理论上）无向边与否并不影响，但是本题根据题意单向边会 WA 一个点，LibreOJ 的数据是没有问题的
	//以下为树剖
    que[tail++] = 1;
    d[1] = 1;
    int from;
    while(head < tail)
    {
        from = que[head++];
        size[from] = 1;//初始化 size
        for(register int i = first[from];i;i = pre[i])
            if(to[i] ^ f[from])
            {
                que[tail++] = to[i];
                f[to[i]] = from;
                d[to[i]] = d[from] + 1;
                //更新深度与父亲
            }
    }
    for(register int i = n;i >= 1;--i)
    {
        size[f[que[i]]] += size[que[i]];
        if(!son[f[que[i]]] || size[que[i]] > size[son[f[que[i]]]])
            son[f[que[i]]] = que[i];
    }//逆着 BFS 的顺序求 size 和 son，不需要另外开一个数组存 BFS 序，用本身的队列就行了
    for(register int i = 1;i <= n;++i)
        for(register int j = i;!id[j] && j;j = son[j])
            id[j] = ++dfn_tot,rk[dfn_tot] = j,top[j] = i;//连接重链，模拟 DFS 序（不是同一条重链上的 DFS 序不连续是不影响的，毕竟没用）
    //以上为树剖
    change(id[1],1,1,n);//先标记根节点
    char opt;
    int x;
    while(q--)
    {
        scanf(" %c%d",&opt,&x);
        if(opt == 'C')
            change(id[x],1,1,n);
        else
            printf("%d\n",rk[answer(x)]);
    }
}

```

---

## 作者：硫代硫酸钠 (赞：1)

线段树解法:


修改:将一个点修改时顺便修改子树的所有点.

查询:直接询问标记.

但这个思路是错误的,原因是后打的标记一定会覆盖先打的.

只需要加一个函数判断深度即可.

代码:
```cpp
#include<iostream>  
#include<cstdio>  
#include<cstdlib>  
#include<cstring>  
#include<cmath>  
#include<algorithm>  
#define F(i,j,n) for(int i=j;i<=n;i++)  
#define D(i,j,n) for(int i=j;i>=n;i--)  
#define ll long long  
#define pa pair<int,int>  
#define N 600005  
using namespace std;  
int n,m,cnt,tot;  
int head[N],dep[N],l[N],r[N];  
int tag[N*4],mx[N*4];  
int to[N],nxt[N],num;
inline int read()  
{  
    int x=0,f=1;char ch=getchar();  
    while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}  
    while (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}  
    return x*f;  
}  
inline void addedge(int x,int y)  
{  
    num++;to[num]=y;nxt[num]=head[x];head[x]=num; 
    num++;to[num]=x;nxt[num]=head[y];head[y]=num; 
}  
inline void dfs(int x,int f)  
{  
    l[x]=++tot;dep[x]=dep[f]+1;  
    for(int p=head[x];p;p=nxt[p]) if (to[p]!=f) dfs(to[p],x);  
    r[x]=tot;  
}  
inline int better(int x,int y)  
{  
    return dep[x]>dep[y]?x:y;  
}  
void pushup(int k)  
{  
    mx[k]=better(mx[k<<1],mx[k<<1|1]);  
}  
void update(int k,int x)  
{  
    tag[k]=better(tag[k],x);  
    mx[k]=better(mx[k],x);  
}  
void pushdown(int k)  
{  
    if (!tag[k]) return;  
    update(k<<1,tag[k]);update(k<<1|1,tag[k]);  
    tag[k]=0;  
}  
void build(int k,int l,int r)  
{  
    tag[k]=0;mx[k]=1;  
    if (l==r) return;  
    int mid=(l+r)>>1;  
    build(k<<1,l,mid);build(k<<1|1,mid+1,r);  
}  
void change(int k,int l,int r,int L,int R,int x)  
{  
    if (l==L&&r==R){update(k,x);return;}  
    int mid=(l+r)>>1;  
    pushdown(k);  
    if (R<=mid) change(k<<1,l,mid,L,R,x);  
    else if (L>mid) change(k<<1|1,mid+1,r,L,R,x);  
    else change(k<<1,l,mid,L,mid,x),change(k<<1|1,mid+1,r,mid+1,R,x);  
    pushup(k);  
}  
int query(int k,int l,int r,int pos)  
{  
    if (l==r) return mx[k];  
    int mid=(l+r)>>1;  
    pushdown(k);  
    if (pos<=mid) return query(k<<1,l,mid,pos);  
    else return query(k<<1|1,mid+1,r,pos);  
}  
int main()  
{  
    n=read();m=read();  
    F(i,1,n-1){int x=read(),y=read();addedge(x,y);}  
    dfs(1,0);  
    build(1,1,n);  
    F(i,1,m)  
    {  
        char ch=getchar();while (ch!='C'&&ch!='Q') ch=getchar();  
        int x=read();  
        if (ch=='C') change(1,1,n,l[x],r[x],x);  
        else printf("%d\n",query(1,1,n,l[x]));  
    }  
} 
```

---

## 作者：7KByte (赞：1)

弱省省选前写篇题解释放压力……  

对于树上操作，并且要求祖先，我们很容易想到**树链剖分**   

我们按照树剖的模板做，先两遍$DFS$，然后建立线段树  

个人线段树比较独特（类似权值线段树但不是权值线段树），利用线段树对位置划分代替对答案二分（很像主席树对不对），每个线段树节点保存这段区间代表的树上节点**是否有标记**，只用记录有还是没有，查询时优先查询后标记的节点  

```cpp
struct node{
	int l,r;
	int data;
}a[N<<2];
void build(int x,int l,int r){
	a[x].l=l;a[x].r=r;a[x].data=0;
	if(l==r)return;
	int mid=(l+r)>>1;
	build(x*2,l,mid);build(x*2+1,mid+1,r);
}
void change(int x,int to){
	if(a[x].l==a[x].r){
		a[x].data=1;return;
	}
	int mid=(a[x].l+a[x].r)>>1;
	if(mid>=to)change(x*2,to);
	else change(x*2+1,to);
	a[x].data=(a[x*2].data|a[x*2+1].data);
}
int ask(int x,int l,int r){
	if(!a[x].data)return 0;
	if(a[x].l==a[x].r)return a[x].l;
	int mid=(a[x].l+a[x].r)>>1,p;
	if(mid<r&&(p=ask(x*2+1,l,r)))return p;
	if(mid>=l)return ask(x*2,l,r);
	return 0;
}
```

对于$C$，直接线段树上单点修改  
对于$Q$，直接借助轻边重链往上跳  

```cpp
int tree_ask(int x){
	int p;
	while(!(p=ask(1,L[top[x]],L[x])))
	  x=fa[top[x]];
	return p;
}
```

其余的初始化两遍$DFS$和主程序自己打吧（手动滑稽）

---

## 作者：bzy369258147 (赞：1)

一个练习dfs序的好题。

其他题解中的关于深度的特判其实有个简单的处理，可以直接子树内对当前达标记节点的dfs序取max即可，因为一个节点的祖先的dfs序一定递减.

然后记一下dfs序的反函数查询即可.

代码如下：

```
#include<bits/stdc++.h>
using namespace std;

vector<int>to[100005];
int id  [100005];
int uid [100005];
int size[100005];
int cnt = 0;

void dfs(int now,int last){
    id  [now] = ++ cnt;
    uid [cnt] = now;
    size[now] = 1;
    for( auto next : to[now] ){
        if( next == last )continue;
        dfs( next,now );
        size[now] += size[next];	
    }
}

namespace SGT{
    #define Lson ( now << 1 )
    #define Rson ( Lson | 1 )
    #define Ason P <= mid ? Lson : Rson
    #define mid  ( ( l[now] + r[now] ) >> 1 )
    #define Lrange Lson,L,min( mid,R )
    #define Rrange Rson,max( mid + 1,L ),R
    int l[400005];
    int r[400005];
    int v[400005];
    
    void build(int now,int L,int R){
        l[now] = L;r[now] = R;
        if( L == R )return ;
        build( Lrange );build( Rrange );
    }
    
    void modify(int now,int L,int R,int val){
        if( v[now] > val )return ;
        if( l[now] == L and r[now] == R )return void( v[now] = val );
        if( L <= mid )modify( Lrange,val );
        if( R >  mid )modify( Rrange,val );
    }
    
    int query(int now,int P){
        if( l[now] == r[now] )return v[now];
        return max( v[now],query( Ason,P ) );
    }
}

int main(){
    int n,q;cin >> n >> q;
    for(int i = 1;i < n;i ++){
        int u,v;cin >> u >> v;
        to[u].push_back(v);
        to[v].push_back(u);
    }
    dfs( 1,1 );SGT::build( 1,1,n );SGT::modify( 1,1,n,1 );
    while( q -- ){
        char op;int x;cin >> op >> x;
        if( op == 'C' ){
            SGT::modify( 1,id[x],id[x] + size[x] - 1,id[x] );
        }else{
            printf( "%d\n",uid[SGT::query( 1,id[x] )] );
        }	
    }
    return 0;
}
```

---

## 作者：天上一颗蛋 (赞：1)

参考了[皎月半洒花的博客](https://www.cnblogs.com/pks-t/p/9222857.html)

看到树想到树剖，由于要取距自己到根离自己最近的标记点，刚开始想到线段树里存节点深度，查询时返回最大值。但是这样的话只能得到节点深度，无法得知节点编号，就想倍增乱搞一下，求出标记点，复杂度$O(\log ^ {3}\;N)$

虽然可以过但是实现有点复杂，就看了一下上面的博客

真的很强，由于树剖dfs时一条链上的编号是连续的，在此链中且深度越大**线段树编号**越大，所以我们可以在线段树里存当前节点的**线段树编号**，也达到了维护深度最大值的效果

答案就是ori [ (一条链中) MAX  index] (ori为线段树编号回找树原始编号的数组)

复杂度$O(\log ^ {2}\;N)$

一直都是把树剖当板子用的，现在发现结合性质还有更多用处，我还要加油啊

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
using namespace std;
int RD(){
    int out = 0,flag = 1;char c = getchar();
    while(c < '0' || c >'9'){if(c == '-')flag = -1;c = getchar();}
    while(c >= '0' && c <= '9'){out = out * 10 + c - '0';c = getchar();}
    return flag * out;
    }
const int maxn = 1000019,INF = 1e9;
int num,na,nume,cnt;
int head[maxn];
struct Node{int v,nxt;}E[maxn * 2];
void add(int u,int v){
    E[++nume].nxt = head[u];
    E[nume].v = v;
    head[u] = nume;
    }
int size[maxn],wson[maxn],dep[maxn],fa[maxn],top[maxn],pos[maxn],ori[maxn];
int v[maxn];
void dfs1(int id,int F){
    size[id] = 1;
    for(int i = head[id];i;i = E[i].nxt){
        int v = E[i].v;
        if(v == F)continue;
        dep[v] = dep[id] + 1;
        fa[v] = id;
        dfs1(v,id);
        size[id] += size[v];
        if(size[v] > size[wson[id]])wson[id] = v;
        }
    }
void dfs2(int id,int TP){
    top[id] = TP;
    pos[id] = ++cnt;
    ori[cnt] = id;
    if(!wson[id])return ;
    dfs2(wson[id],TP);
    for(int i = head[id];i;i = E[i].nxt){
        int v = E[i].v;
        if(v == fa[id] || v == wson[id])continue;
        dfs2(v,v);
        }
    }
#define lid (id << 1)
#define rid (id << 1) | 1
struct sag_tree{
    int l,r,max;
    }tree[maxn << 2];
void build(int id,int l,int r){
    tree[id].l = l;
    tree[id].r = r;
    if(l == r){
        tree[id].max = 0;
        return ;
        }
    int mid = (l + r) >> 1;
    build(lid,l,mid);
    build(rid,mid + 1,r);
    tree[id].max = max(tree[lid].max,tree[rid].max);
    }
void update(int id,int val, int l,int r){
    if(tree[id].l == l && tree[id].r == r){
        tree[id].max = l;
        return ;
        }
    int mid = (tree[id].l + tree[id].r) >> 1;
    if(mid < l)update(rid,val,l,r);
    else if(mid >= r)update(lid,val,l,r);
    else update(lid,val,l,mid),update(rid,val,mid + 1,r);
    tree[id].max = max(tree[lid].max,tree[rid].max);
    }
int query(int id,int l,int r){
	if(tree[id].l == l && tree[id].r == r)return tree[id].max;
	int mid = (tree[id].l + tree[id].r) >> 1;
	if(mid < l)return query(rid,l,r);
	else if(mid >= r)return query(lid,l,r);
	else return max(query(lid,l,mid),query(rid,mid + 1,r));
	}
void Qmax(int x, int y){
	int ans = 0;
	while(top[x] != top[y]){
		if(dep[top[x]] < dep[top[y]])swap(x, y);
		ans = query(1, pos[top[x]], pos[x]);
		if(ans){
			printf("%d\n", ori[ans]);
			return ;
			}
		x = fa[top[x]];
		}
	if(dep[x] > dep[y])swap(x, y);
	ans = query(1, pos[x], pos[y]);
	printf("%d\n", ori[ans]);
	}
int main(){
	num = RD();na = RD();
	for(int i = 1;i <= num - 1;i++){
		int u = RD(),v = RD();
		add(u,v),add(v,u);
		}
	dep[1] = 1;
	dfs1(1,-1);dfs2(1,1);
	build(1,1,num);
	update(1,pos[1],pos[1],pos[1]);
	for(int i = 1;i <= na;i++){
		char cmd;cin>>cmd;
		if(cmd == 'C'){
			int x = RD();
			update(1,pos[x],pos[x],pos[x]);
			}
		else{
			int x = RD();
			Qmax(x,1);
			}
		}
	return 0;
	}
```

---

## 作者：λᴉʍ (赞：1)

大暴力。


首先将每个点的答案设为1，每次修改只需从这个点往下搜，收到打了标记的点就退出，否则更新答案并继续搜下去。


事实上一棵扫把树就可以卡掉。


代码很久以前写的，太丑，懒得贴代码了。


会搜索的都能AC这题。


---

## 作者：YuYuanPQ (赞：0)

看一眼题目加上数据范围，显然是可以用树剖的。\
笔者在这里就不讲树剖了，不会的先去学一下吧。

---
这个询问并不像平时做的题那样，可以不用思考直接套用线段树。

但我们可以转化一下：\
因为直接搞不行，那换种思路。经过计算可以发现，$\mathcal{O}(Q\log^2N)$ 的算法是可以过的。我们考虑二分。
- 操作 $1$ 转化为单点赋值为 $1$。
- 操作 $2$ 转化为区间查询。\
这里的操作 $2$ 的转化比较妙：在树剖一条条链往根节点跳的时候，我们可以对每条经过的链进行二分。二分什么呢？显然，从一条链的深度最深的点往链头这段区间的“后缀和”是递增的，那么我们就能对后缀和进行二分了。如果二分到的区间 $[mid,r]$ 的和 $\geq 1$，就让 $l=mid+1$，往右边找。否则往左边找。

注意：
1. 在对当前链二分之前，可以先判断当前链的区间和是否 $\geq 1$（也许能节省一点时间？）。当然了，不这么打也行。
2. 找到就直接返回结果，因为求的是最近的打了标记的祖先。

（独立切的题，开心）

## Code
```cpp
//my_sol
#include<bits/stdc++.h>

typedef int IT;
typedef long long LL;
typedef __int128 int128;
typedef double DB;
typedef long double LDB;

#define pb push_back
#define fst first
#define sec second
#define psh push
#define mkp make_pair
#define PII pair<IT,IT>
#define PLI pair<LL,IT>
#define lowbit(x) ((x)&(-x))
using namespace std;

const int N=1e5+10,ES=N<<1;

int n,Q;
char st[5];

int ecnt,head[N],nxt[ES],to[ES];
void add(int x,int y){
    nxt[++ecnt]=head[x];
    head[x]=ecnt;
    to[ecnt]=y;
    return;
}

int dep[N],fa[N],siz[N],son[N];
void dfs1(int x,int fth){
    dep[x]=dep[fth]+1;
    fa[x]=fth;
    siz[x]=1;
    for(int i=head[x];i;i=nxt[i]){
        int y=to[i];
        if(y==fth) continue;
        dfs1(y,x);
        siz[x]+=siz[y];
        if(siz[y]>siz[son[x]])
            son[x]=y;
    }
}
int top[N];
int id[N],idx;
int pt[N];
void dfs2(int x,int ntop){
    top[x]=ntop;
    id[x]=++idx;
    pt[idx]=x;
    if(!son[x]) return;
    dfs2(son[x],ntop);
    for(int i=head[x];i;i=nxt[i]){
        int y=to[i];
        if(y!=fa[x]&&y!=son[x])
            dfs2(y,y);
    }
}

struct Seg_Tree{
    int sum;
}t[N<<2];
void pushup(int rt){
    t[rt].sum=t[rt<<1].sum+t[rt<<1|1].sum;
    return;
}
void modify(int rt,int l,int r,int qx,int v){
    if(qx<l||r<qx) return;
    if(l==r){
        if(l==qx) t[rt].sum=v;
        return;
    }
    int mid=(l+r)>>1;
    modify(rt<<1,l,mid,qx,v);
    modify(rt<<1|1,mid+1,r,qx,v);
    pushup(rt);
    return;
}
int query(int rt,int l,int r,int ql,int qr){
    if(r<ql||qr<l) return 0;
    if(ql<=l&&r<=qr) return t[rt].sum;
    int mid=(l+r)>>1;
    return query(rt<<1,l,mid,ql,qr)+
        query(rt<<1|1,mid+1,r,ql,qr);
}

int erfen(int x,int y){
    int l=id[x],r=id[y];
    int res=0;
    if(query(1,1,n,l,r)==0) return -1;
    while(l<=r){
        int mid=(l+r)>>1;
        if(query(1,1,n,mid,r)!=0) l=mid+1,res=mid;
        else r=mid-1;
    }
    return pt[res];
}
int SP_query(int x,int y){
    while(top[x]!=top[y]){
        if(dep[top[x]<dep[top[y]]]) swap(x,y);
        int s=erfen(top[x],x);
        if(s!=-1) return s;
        x=fa[top[x]];
    }
    if(dep[x]>dep[y]) swap(x,y);
    int s=erfen(x,y);
    if(s!=-1) return s;
}

int main(){
    scanf("%d%d",&n,&Q);
    for(int i=1;i<n;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        add(u,v);
    }

    dfs1(1,0);
    dfs2(1,1);
    modify(1,1,n,id[1],1);

    while(Q--){
        int x;
        scanf("%s%d",st,&x);
        if(st[0]=='C'){
            modify(1,1,n,id[x],1);
        }
        else{
            printf("%d\n",SP_query(1,x));
        }
    }
    return 0;
}
```

---

## 作者：rainygame (赞：0)

遇到这种题，我们第一个想到的应该就是树剖。

先树剖一下，然后考虑如何查询。

我们可以发现，树剖完之后，如果在这条链上有最近祖先，那么答案就是这个最近祖先，否则再往上跳即可。

问题就是如何快速求出最近祖先。

如果 $u$ 在这条链上有最近祖先 $v$，那么在这条链上 $u$ 的 dfs 序一定大于等于 $v$ 的 dfs 序（注意这个 dfs 序指的是处理重链的那个 dfs 的 dfs 序，不是普通的 dfs 序），而且 $v$ 还是满足条件的所有祖先中 dfs 序最大的那个。

有的读者可能反应过来：**这不就是查询前驱吗？**

没错，所以我们可以使用平衡树来解。但是这个题用平衡树有些大费周章了。我们可以考虑使用 `set` 来代替平衡树。

但是 `set` 的 `lower_bound` 只能查询后继，所以插入之前需要把 dfs 序取一下相反数，到时候取出来之后再取一次即可。取出来的数是 dfs 序，还需要映射成实际的节点编号。

时间复杂度 $O(n \log^2 n)$。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define MAXN 100001

int n, q, u, v, cnt;
int id[MAXN], id2[MAXN];
int dep[MAXN], top[MAXN], son[MAXN], siz[MAXN], fa[MAXN];
vector<int> e[MAXN];
set<int> st[MAXN];
char opt;

void dfs1(int x, int f){
	fa[x] = f;
	dep[x] = dep[f] + 1;
	siz[x] = 1;
	for (auto i: e[x]){
		if (i != f){
			dfs1(i, x);
			siz[x] += siz[i];
			if (siz[son[x]] < siz[i]) son[x] = i;
		}
	}
}

void dfs2(int x, int tp){
	top[x] = tp;
	id[x] = ++cnt;
	id2[cnt] = x;
	if (!son[x]) return;
	dfs2(son[x], tp);
	for (auto i: e[x]){
		if (i != fa[x] && i != son[x]) dfs2(i, i);
	}
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin >> n >> q;
    for (int i(1); i<n; ++i){
    	cin >> u >> v;
    	e[u].push_back(v);
    	e[v].push_back(u);
	}
	dfs1(1, 0);
	dfs2(1, 1);
	st[1].insert(-1);
	
	while (q--){
		cin >> opt >> u;
		if (opt == 'C') st[top[u]].insert(-id[u]);
		else{
			while (st[top[u]].lower_bound(-id[u]) == st[top[u]].end()) u = fa[top[u]];
			cout << id2[-*st[top[u]].lower_bound(-id[u])] << '\n';
		}
	}

    return 0;
}

```


---

## 作者：Herlo (赞：0)

看了一眼嗯是个树剖题。开始~~乱刚~~思考操作怎么实现。
操作1：把某点值变为1，在线段树中维护最大值，初始最大值为1，更改某点时，更改该点的子树那部分线段树的最大值。
操作2：查询到x~1路径上值为1的编号最大的原编号，
利用树剖+线段树在向上跳的时候求出最大值。
看了看题解菊苣是线段树维护区间和加二分。。tql
```cpp
#include<bits/stdc++.h>
using namespace std;
#define C getchar()
typedef long long ll;
#define pi acos(-1.0)
#define INF 0x3f3f3f3f
#define mod 1000000007
const int MAXN = 1e5 + 10;
#define pii pair<int, int>
#define endll printf("\n")
#define stop system("pause")
#define lowbit(x) ((x) & (-x))
#define Temp template<typename T>
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define mem(a, b) memset(a, b, sizeof(a))
Temp inline void rd(T &s)
{
    s = 0;T t = 1, k = C;
    for (; k < '0' || k > '9'; k = C)if (k == '-') t = -1;
    for (; k >= '0' && k <= '9'; k = C) s = (s << 1) + (s << 3) + (k ^ 48);
    s *= t;
}
int  n;
vector<int>g[MAXN];
//dfs1
int son[MAXN],fa[MAXN];
int dep[MAXN],size[MAXN];
//dfs2
int top[MAXN],id[MAXN],rk[MAXN];
//tree
int cnt;
struct Segment_Tree
{
    #define lson rt<<1,l,mid
    #define rson rt<<1|1,mid+1,r
    int maxv[MAXN<<2];int lazy[MAXN<<2];
    inline int ls(int p) {return p<<1;}
    inline int rs(int p) {return p<<1|1;}
    void push_up(int p) {maxv[p] = max(maxv[ls(p)],maxv[rs(p)]);}
    void push_down(int p)
    {
        maxv[ls(p)]=max(maxv[ls(p)],lazy[p]);
        maxv[rs(p)]=max(maxv[rs(p)],lazy[p]);
        lazy[ls(p)]=max(lazy[ls(p)],lazy[p]);
        lazy[rs(p)]=max(lazy[rs(p)],lazy[p]);
        lazy[p]=0;
    }
    void build(int rt,int l,int r)
    {
        lazy[rt]=0;
        if(l==r) {maxv[rt]=1; return ;}
        int mid = (l+r)>>1;
        build(lson);build(rson);push_up(rt);
    }
    int Querymax(int ql,int qr,int rt,int l,int r)
    {
        if(ql<=l && r<=qr) return maxv[rt];
        if(lazy[rt]) push_down(rt);
        int Max=-INF ,mid=(l+r)>>1;
        if(ql<=mid) Max = max(Max,Querymax(ql,qr,lson));
        if(qr>mid) Max = max(Max,Querymax(ql,qr,rson));
        return Max;
    }
    void update(int q,int v,int rt,int l,int r)//单点更新
    {
        int mid = (l+r)>>1;
        if(l==r) {maxv[rt] = v; return ;}
        if(q<=mid) update(q,v,lson);
        else update(q,v,rson);
        push_up(rt);
    }
    void update(int ql,int qr,int v,int rt,int l,int r)//区间更新
    {
        if(ql>r||qr<l) return;
        if(ql<=l && qr>=r) {lazy[rt]=max(lazy[rt],v),maxv[rt]=max(maxv[rt],v);return;}
        if(lazy[rt]) push_down(rt);
        int mid=(l+r)>>1;
        update(ql,qr,v,lson);update(ql,qr,v,rson);
        push_up(rt);
    }
}tree;
void dfs1(int u,int pre)
{
    size[u]=1;dep[u]=dep[pre]+1;fa[u]=pre;
    int maxson=-1;
    for(int i=0;i<g[u].size();i++)
    {
        int v=g[u][i];
        if(v==pre) continue;
        dfs1(v,u);
        size[u]+=size[v];
        if(size[v]>maxson) maxson=size[v],son[u]=v;
    }
}
void dfs2(int x,int topx)//
{
    top[x]=topx;id[x]=++cnt;rk[cnt]=x;
    if(son[x]!=-1) dfs2(son[x],topx);
    for(int i=0;i<g[x].size();i++)
    {
        int v=g[x][i];
        if(v==fa[x]||v==son[x]) continue;
        dfs2(v,v);
    }
}
int qmax(int x,int y)
{
    int ans=1;
    for(;top[x]!=top[y];x=fa[top[x]])
    {
        if(dep[top[x]]<dep[top[y]]) swap(x,y);//
        ans=max(tree.Querymax(id[top[x]],id[x],1,1,n),ans);
    }
    if(dep[x]>dep[y]) swap(x,y);
    ans=max(tree.Querymax(id[x],id[y],1,1,n),ans);
    return rk[ans];
}

int main()
{
    rd(n);int q;rd(q);
    FOR(i,1,n-1)
    {
        int u,v;rd(u);rd(v);
        g[u].push_back(v);
        //g[v].push_back(u);
    }
    //
    mem(son,-1);dep[0]=0;
    dfs1(1,0);
    cnt=0;
    dfs2(1,1);
    tree.build(1,1,n);
    while(q--)
    {
        char s[11];
        scanf("%s",s);int x;rd(x);
        if(s[0]=='C') tree.update(id[x],id[x]+size[x]-1,id[x],1,1,n);//
        else printf("%d\n",qmax(x,1));//询问路径最大值
    }
    //stop;
    return 0;
}

```


---

## 作者：Leap_Frog (赞：0)

## P4092 [HEOI2016/TJOI2016]树（题解）

**题目传送门：**  
[点我](https://www.luogu.org/problemnew/show/P4092)

**解题思路：**  
用线段树与dfs序

**注意点：**  
- dfs序与原序要分清
- 修改时并不能直接赋值，要取最大值。

**解题过程：**  
先把原数赋予按照dfs序，以及逆dfs序。  
~~现在经观察得，~~每一个点的子孙便是【它，它的最右子节点】中所有整数。

接下来便可以向线段树思考了，它需要维护区间最大值  
支持区间改最大值，查最大值。

**PS** *dfs序：*  
把原树按照dfs的序号编号，先dfs到的节点dfs序小  
例如下图中就是样例，黑体是dfs序，蓝体是题目给定序（原序）
![出错啦](https://cdn.luogu.com.cn/upload/pic/51164.png)

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
using namespace std;
const ll Max=100005;
struct data	//线段树节点
{
	ll num,flag;
	data() {num=1;flag=0;}
	data(ll a,ll b):num(a),flag(b) {}
};
struct tree	//题目中给的树
{
	vector<ll>b[Max];
	ll dfs_xu[Max],ni_dfs_xu[Max],size;
	inline void clean()	//清空
	{
		for(ll i=0;i<Max;i++) b[i].clear();
	}
	inline void add_edge(ll x,ll y)	//加边
	{
		b[x].push_back(y);
	}
	void dfs(ll now,ll fa)	//求dfs序
	{
		if(now==1) size=0;
		size++;
		dfs_xu[now]=size;
		for(ull i=0;i<b[now].size();i++)
			if(b[now][i]!=fa)
				dfs(b[now][i],now);
	}
	inline void ni_dfs()	//求逆dfs序
	{
		for(ll i=1;i<=size;i++) ni_dfs_xu[dfs_xu[i]]=i;
	}
	ll rightest(ll n)	//n是原序,rightest是原序;
	{
		if(b[n].size()==0) return n;
		return rightest(b[n][b[n].size()-1]);
	}
};
struct cut_tree	//线段树
{
	data tre[Max<<2];
	inline void down(ll rt,ll l,ll r)	//下推标记（有点烦）
	{
		if(!tre[rt].flag) return;
		if(l==r)
		{
			tre[rt].num=max(tre[rt].num,tre[rt].flag);	//注意！！！不应该直接赋值
			tre[rt].flag=0;
			return;
		}
		tre[rt<<1].flag=max(tre[rt].flag,tre[rt<<1].flag);
		tre[rt<<1|1].flag=max(tre[rt].flag,tre[rt<<1|1].flag);
		tre[rt].num=max(tre[rt].num,tre[rt].flag);
		tre[rt].flag=0;
	}
	inline void up(ll rt,ll l,ll r)	//上推数值
	{
		tre[rt].num=max(tre[rt<<1].num,tre[rt<<1|1].num);
	}
	ll csearch(ll rt,ll l,ll r,ll d)	//查询
	{
		down(rt,l,r);
		if(l==d&&r==d) return tre[rt].num;
		if(d<=(l+r)>>1) return csearch(rt<<1,l,(l+r)>>1,d);
		return csearch(rt<<1|1,((l+r)>>1)+1,r,d);
	}
	void change(ll rt,ll l,ll r,ll dl,ll dr,ll dc)	//修改
	{
		if(l>r) return;
		if(dl>r) return;
		if(l>dr) return;
		if(dl<=l&&r<=dr)
		{
			tre[rt].flag=max(tre[rt].flag,dc);
			return;
		}
		change(rt<<1,l,(l+r)>>1,dl,dr,dc);
		change(rt<<1|1,((l+r)>>1)+1,r,dl,dr,dc);
		up(rt,l,r);
	}
};
cut_tree tr;
tree a;
int main()
{
	ll n,q;
	scanf("%lld%lld",&n,&q);
	a.clean();
	for(ll i=1;i<n;i++)
	{
		ll x,y;
		scanf("%lld%lld",&x,&y);
		a.add_edge(x,y);
	}
	a.dfs(1,0);
	a.ni_dfs();
	while(q--)
	{
		char c;ll x;
		cin>>c;scanf("%lld",&x);
		if(c=='C')
		{
			ll y=a.rightest(x);
			tr.change(1,1,n,a.dfs_xu[x],a.dfs_xu[y],a.dfs_xu[x]);	//此处要搞清！！！
		}
		if(c=='Q')
		{
			ll y=tr.csearch(1,1,n,a.dfs_xu[x]);
			printf("%lld\n",a.ni_dfs_xu[y]);	//还有此处
		}
	}
	return 0;
}
```
[~~没有广告~~](https://daniu.blog.luogu.org/)

---


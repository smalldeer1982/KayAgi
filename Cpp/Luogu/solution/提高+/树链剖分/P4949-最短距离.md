# 最短距离

## 题目描述

给出一个 $n$ 个点 $n$ 条边的无向连通图。

你需要支持两种操作：

1. 修改 第 $x$  条边的长度为 $y$ ；

2. 查询 点 $x$ 到点 $y$ 的最短距离。

共有 $m$ 次操作。

## 说明/提示

![Luogu](https://cdn.luogu.com.cn/upload/pic/37934.png)  

对于 $100\%$ 的数据，保证 $z\in [0,5000]$。

## 样例 #1

### 输入

```
4 5
1 2 11
1 3 12
2 3 13
1 4 15
2 2 3
1 2 1
2 2 3
2 2 4
2 3 4```

### 输出

```
13
12
26
16```

# 题解

## 作者：libra9z (赞：12)

### [原题描述](https://www.luogu.org/problemnew/show/P4949)

### ~~这道题题目简短，题意清楚，给个好评~~
#### 这个题目是给了一个环套树，有Q此询问，每一次询问是改变一个边的权值或求两点之间的最短路径，~~废话~~。
我们珂以先考虑假设这些操作池在一珂树上的。

这就很好做，用树剖套线段树就足以解决。

边权怎么搞？珂以把一个边的权值看成这条边所连接的节点深度更深的儿子的点权。

~~[Spoj375](https://www.luogu.org/problemnew/show/SP375)是一个很好的这种类型的题目，但特别卡时限。~~

但是，题目中是环套树(~~黑题哪有那么简单？~~)。

所以，我们把环套树分成一珂树和另外一个多余的边。
这显然珂以用并茶几搞出来。

接着，每一次询问分俩块：

1. 查询在树中的路径的长度
1. 考虑经过多余的边，查询路径一个节点到多余的边的一个节点，再次查询路径另一个节点到多余的边的另一个节点，最后加起来，再加上多余边的权值（注意还要反过来加一次！！）

#### ~~结束了么？结束了~~

最后放一下代码：
```cpp
#include <stdio.h>
#include <string.h>

#define Maxn 100010

int n, q, eu, ev, ew, ed;
int b[Maxn], a[Maxn];

int fa[Maxn];
int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
inline bool unite(int x, int y) {
	x = find(x), y = find(y);
	if (x == y) return false;
	return (fa[x] = y) | 1;
}

struct Edge {
	int to, next, weight;
} e[Maxn << 1];
int head[Maxn], _cnt;
inline void AddEdge(int u, int v, int w) {
	e[_cnt] = (Edge) {v, head[u], w};
	head[u] = _cnt ++;
}

int par[Maxn], dep[Maxn];
int sz[Maxn], son[Maxn];
int top[Maxn], ind[Maxn], indx;
void dfs1(int u, int parent, int depth) {
	par[u] = parent, dep[u] = depth, sz[u] = 1;
	for (int i = head[u]; ~i; i = e[i].next) {
		int v = e[i].to;
		if (v == parent) continue;
		dfs1(v, u, depth + 1); sz[u] += sz[v];
		if (sz[son[u]] < sz[v]) son[u] = v;
		b[v] = e[i].weight;
	}
}
void dfs2(int u, int topv) {
	top[u] = topv, ind[u] = ++ indx, a[indx] = b[u];
	if (son[u]) dfs2(son[u], topv);
	for (int i = head[u]; ~i; i = e[i].next)
		if (e[i].to != par[u] && e[i].to != son[u])
			dfs2(e[i].to, e[i].to);
}

int bit[Maxn];
inline void modify(int x, int y) {
	while (x <= n) bit[x] += y, x += x & -x;
}
inline int query(int x) {
	int ans = 0;
	while (x) ans += bit[x], x -= x & -x;
	return ans;
}

inline int TreeSum(int x, int y) {
	int ans = 0;
	while (top[x] ^ top[y]) {
		if (dep[top[x]] < dep[top[y]]) x ^= y ^= x ^= y;
		ans += query(ind[x]) - query(ind[top[x]] - 1);
		x = par[top[x]];
	}
	if (ind[x] > ind[y]) x ^= y ^= x ^= y;
	ans += query(ind[y]) - query(ind[x]);
	return ans;
}

inline void change(int x, int y)
{
	int l1 = (x << 1) - 1, l2 = x - 1 << 1;
	int a = e[l1].to, b = e[l2].to;
	int v = dep[a] < dep[b] ? b : a;
	int now = query(ind[v]) - query(ind[v] - 1);
	modify(ind[v], y - now);
}

int main() {
	memset(head, -1, sizeof head);
	scanf("%d %d", &n, &q);
	for (int i = 1; i <= n; ++ i) fa[i] = i;
	for (int i = 1; i <= n; ++ i) {
		int u, v, w; scanf("%d %d %d", &u, &v, &w);
		if (unite(u, v)) AddEdge(u, v, w), AddEdge(v, u, w);
		else eu = u, ev = v, ew = w, ed = i, _cnt += 2;
	}
	dfs1(1, 0, 1);
	dfs2(1, 1);
	for (int i = 1; i <= n; ++ i)
		modify(i, a[i]);
	while (q --) {
		int opt, x, y;
		scanf("%d %d %d", &opt, &x, &y);
		if (opt == 1) {
			if (x == ed) ew = y;
			else change(x, y);
		}
		else {
			int ans = TreeSum(x, y);
			int ans1 = TreeSum(x, eu) + TreeSum(y, ev) + ew;
			int ans2 = TreeSum(x, ev) + TreeSum(y, eu) + ew;
			printf("%d\n", ans < (ans1 < ans2 ? ans1 : ans2) ? ans : (ans1 < ans2 ? ans1 : ans2));
		}
	}
	return 0;
}
```
## 最后蒟蒻的第一篇题解完结散花！！



---

## 作者：monstersqwq (赞：8)

### 题意：

给出一个 $n$ 个点 $n$ 条边的无向连通图，支持修改某条边的权值和查询图上两点的最短路。

### 思路：

如果这种操作放在一棵树上，那么就是寻找树上两点间路径并求和，使用树链剖分可以方便地解决。

现在考虑如何把这个图改变成一棵树使它可以被解决。

发现此图连通，至少有 $n-1$ 条边，但这个图有 $n$ 条边，多出来了一条边，把这条边先找出来（任意一条多出的都可以），可以使用并查集查找到，存储下编号等信息。

现在这个图变成了一棵树，使用树链剖分，先忽略多出的边的影响（即最短路不经过那条边）来求出操作二中 $x$ 到 $y$ 的路径，然后再考虑多出的边的影响。

若多出的边有影响，则最短路一定会经过此边，设此边两端点为 $cu,cv$，边权为 $w$，那么最短路径是：$x$ 或 $y$ 经过树上的边到 $cu$ 再到 $cv$，最后再经过树上的边到达 $x,y$ 中另一个点。

可以分起始点讨论，最后有两种情况：

- $x-cu-cv-y$，总和为 $\operatorname{dis}(x,cu)+cw+\operatorname{dis}(cv,y)$
- $x-cv-cu-y$，总和为 $\operatorname{dis}(x,cv)+cw+\operatorname{dis}(cu,y)$

再算上忽略影响时的结果，三种情况分别求出结果，取最小值即可。

最后一点：此题要求边权，树链剖分可以维护点的信息，但是边的信息无法维护，考虑把边权放到树上的更深的点作为点权，但这样需要考虑 $\operatorname{lca}(x,y)$ 的点权是上面那条边的边权，不需要加在结果中，最后当两点在同一条重链上时，不求更浅的那个点的点权，因为这个点一定是 $\operatorname{lca}(x,y)$，不能加进去。

树链剖分的单点修改区间查询使用树状数组完成，无根树以 $1$ 为根即可。

代码：

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <string>
#include <cstring>
#include <queue>
#include <map>
using namespace std;
typedef long long ll;
//1e5+10
int n,m,fa[100010];
int cu,cv,cw,ch;
int fin(int x)
{
	if(fa[x]!=x) return fa[x]=fin(fa[x]);
	return x;
}//并查集求多余的边
int c[100010];
int lowbit(int x)
{
	return x&-x;
}
void upd(int x,int k)
{
	while(x<=n)
	{
		c[x]+=k;
		x+=lowbit(x);
	}
}
int query(int x)
{
	int res=0;
	while(x>=1)
	{
		res+=c[x];
		x-=lowbit(x);
	}
	return res;
}//树状数组单点修改区间查询
int hed[100010],nxt[200020],ww[200020],to[200020],cnt;
struct Edge
{
	int u,v,w;
}e[100010];//为了处理操作一，我开了一个存边的数组，使用其它的方法也可以
void adde(int u,int v,int w)
{
	cnt++;
	to[cnt]=v;
	ww[cnt]=w;
	nxt[cnt]=hed[u];
	hed[u]=cnt;
}//链式前向星求边，记得开2倍空间
int siz[100010],f[100010],top[100010],son[100010],dep[100010],id[100010],dfscnt,wt[100010];//wt存该dfs序的点权，初始化时需要用，其它同普通树链剖分
void dfs1(int u,int from)
{
	siz[u]=1;
	f[u]=from;
	dep[u]=dep[from]+1;
	for(int i=hed[u];i!=0;i=nxt[i])
	{
		if(to[i]!=from)
		{
			dfs1(to[i],u);
            siz[u]+=siz[to[i]];
		    if(siz[to[i]]>siz[son[u]])
		    {
			    son[u]=to[i];
		    }
		}
		
	}
}
void dfs2(int u,int topf,int w)
{
	dfscnt++;
	wt[dfscnt]=w;
	id[u]=dfscnt;
	top[u]=topf;
    for(int i=hed[u];i!=0;i=nxt[i])
    {
        if(to[i]==son[u]&&son[u]!=0) dfs2(son[u],topf,ww[i]);
    }
	for(int i=hed[u];i!=0;i=nxt[i])
	{
		int v=to[i];
		if(v!=f[u]&&v!=son[u]) dfs2(v,v,ww[i]);
	}
}
int ask(int x,int y)
{
	if(x==y) return 0;
	int fx=top[x],fy=top[y],res=0;
	while(fx!=fy)
	{
		if(dep[fx]<dep[fy])
		{
			res+=query(id[y])-query(id[fy]-1);
			y=f[top[y]];fy=top[y];
		}
		else
		{
			res+=query(id[x])-query(id[fx]-1);//差分求和
			x=f[top[x]];fx=top[x];
		}
	}
	if(id[x]<id[y]) res+=query(id[y])-query(id[x]);
	else res+=query(id[x])-query(id[y]);//重点：边权下放点权时的lca不被统计，只查询(x,y]的和
	return res;
}
int main()
{
	cin>>n>>m;
    for(int i=1;i<=n;i++) fa[i]=i;//记得初始化！
	for(int i=1;i<=n;i++)
	{
		int u,v,w;
		cin>>u>>v>>w;
		if(fin(u)!=fin(v))
		{
			fa[fin(u)]=fin(v);
		}
		else
		{
			cu=u;
			cv=v;
			cw=w;
			ch=i;//存储多余边的信息
			continue;
		}
		adde(u,v,w);
		adde(v,u,w);
		e[i].u=u;
		e[i].v=v;
		e[i].w=w;
	}
	dfs1(1,0);
	dfs2(1,1,0);
	for(int i=2;i<=n;i++)
	{
		upd(i,wt[i]);
	}//初始化树状数组，因为根节点无点权所以从1来循环
	for(int i=1;i<=m;i++)
	{
		int opt,x,y;
		cin>>opt>>x>>y;
		if(opt==1)
		{
			if(x==ch) cw=y;//若改的是多余的边，直接修改边权
			else
			{
				if(f[e[x].u]==e[x].v)//修改时需要判断此边需要放到哪里作点权
				{
					upd(id[e[x].u],y-e[x].w);
				}
				else
                {
                    upd(id[e[x].v],y-e[x].w); //改变值和增加值差不多，求差即可
                } 
                e[x].w=y;//修改边权后也要在原数组修改，简化运算，减小常数
			}
		}
		else
		{
			int ans=min(ask(x,y),min(ask(x,cu)+ask(y,cv)+cw,ask(x,cv)+ask(y,cu)+cw));//分三种情况讨论
			cout<<ans<<endl;
		}
	}
	return 0;
}
```

---

## 作者：kbtyyds (赞：5)

# P4949 题解

建议先过[P3384 【模板】轻重链剖分/树链剖分](https://www.luogu.com.cn/problem/P3384)以及[P4315 月下“毛景树”](https://www.luogu.com.cn/problem/P4315)。

[本题链接](https://www.luogu.com.cn/problem/P4949)

## 题目描述

给出一个 $n$ 个点 $n$ 条边的无向连通图。

你需要支持两种操作：

1. 修改 第 $x$  条边的长度为 $y$ ；

2. 查询 点 $x$ 到点 $y$ 的最短距离。

共有 $m$ 次操作。

---

## 1.分析

如果是 $n$ 个点 $n-1$ 条边的无向连通图（就是一棵树），那么点 $x$ 到点 $y$ 就**只有一条路径**，直接树链剖分+线段树解决即可。

但是，对于 $n$ 个点 $n$ 条边的无向连通图就无法直接处理，仿照上面的做法，我们可以将这 $n$ 条边**分成两部分**：一部分是 $n-1$ 条边并构成一棵树（后文提到的树都是它），另一部分是多出的那一条边。

方便起见，记多出来的那条边为第 $k$ 条，其边权为 $w$ ，连接 $u$ 与 $v$ 两点；记 $dis(x,y)$ 为树上 $x,y$ 的距离， $ans(x,y)$ 为图上 $x,y$ 的最短距离。

那么操作一就很简单，直接修改即可。

对于操作二，我们不难推出以下式子：

$$ans(x,y)=\min(dis(x,y),dis(x,u)+w+dis(v,y),dis(x,v)+w+dis(u,y))$$

$\min$ 函数里面的三个式子也正好是 $x$ 到 $y$ 的**三种不同的路线**！

$dis(x,y)$ 是 $x$ 与 $y$ 的**树上距离**（纯在树上走）。

$dis(x,u)+w+dis(v,y)$ 是从点 $x$ 在树上走到 $u$，再走过多出来的边，最后从 $v$ 走到 $y$ 的**总距离**。

$dis(x,v)+w+dis(u,y)$ 同理。

## 2.细节处理

判断多出来的边可以用并查集判断，类似于Kruskal算法求最小生成树一样。

修改树上的边直接边权转点权，多出来的直接暴力修改。

剩下就是树链剖分的板子了\~。

## 3.代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define S 100010
#define int long long
using namespace std;
inline int read()
{
    int f=1,x=0;
    char c=getchar();
    while(c!='-'&&(c<'0'||c>'9')) c=getchar();
    while(c=='-') f=-f,c=getchar();
    while('0'<=c&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return f*x;
}
int n,m,a[S],b[S];
int set[S],ans,xu,xv,w;
int head[S],len;
int fa[S],son[S],dep[S],size[S];
int top[S],dfn[S],cnt;
int seq[S];
struct link
{
    int u,v,w,nxt;
}edge[S<<1];
inline int find(int x)//-----------并查集---------------
{
    if(x==set[x]) return x;
    return set[x]=find(set[x]);
}
inline void add(int u,int v,int w,bool p)
{
    edge[++len]=(link){u,v,w,head[u]};
    if(p) head[u]=len;
}
inline void dfs1(int x,int f)
{
    fa[x]=f,size[x]=1,dep[x]=dep[f]+1;
    for(int i=head[x];~i;i=edge[i].nxt)
    {
        int t=edge[i].v;
        if(t==f) continue;
        dfs1(t,x);
        size[x]+=size[t];
        if(size[t]>size[son[x]]) son[x]=t;
    }
}
inline void dfs2(int x,int topf)
{
    top[x]=topf,dfn[x]=++cnt,a[cnt]=b[x];
    if(!son[x]) return;
    dfs2(son[x],topf);
    for(int i=head[x];~i;i=edge[i].nxt)
    {
        int t=edge[i].v;
        if(!dfn[t]) dfs2(t,t);
    }
}
struct seg//----------------线段树----------------
{
    #define ls o<<1
    #define rs o<<1|1
    int sum[S<<2];
    inline void pushup(int o)
    {
        sum[o]=sum[ls]+sum[rs];
    }
    inline void build(int o,int l,int r)
    {
        if(l==r) {sum[o]=a[l];return;}
        int mid=(l+r)>>1;
        build(ls,l,mid);
        build(rs,mid+1,r);
        pushup(o);
    }
    inline void update(int o,int l,int r,int x,int k)
    {
        if(l==r) {sum[o]=k;return;}
        int mid=(l+r)>>1;
        if(x<=mid) update(ls,l,mid,x,k);
        else update(rs,mid+1,r,x,k);
        pushup(o);
    }
    inline int ask(int o,int l,int r,int ql,int qr)
    {
        if(ql<=l&&r<=qr) return sum[o];
        int mid=(l+r)>>1,res=0;
        if(ql<=mid) res+=ask(ls,l,mid,ql,qr);
        if(qr>mid) res+=ask(rs,mid+1,r,ql,qr);
        return res;
    }
}c;
inline int lca(int x,int y)
{
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]]) swap(x,y);
        x=fa[top[x]];
    }
    if(dep[x]>dep[y]) swap(x,y);
    return x;
}
inline int dis(int x,int y)
{
    int res=0,LCA=lca(x,y);
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]]) swap(x,y);
        res+=c.ask(1,1,n,dfn[top[x]],dfn[x]);
        x=fa[top[x]];
    }
    if(dep[x]>dep[y]) swap(x,y);
    res+=c.ask(1,1,n,dfn[x],dfn[y]);
    res-=c.ask(1,1,n,dfn[LCA],dfn[LCA]);
    return res;
}
inline void debug()
{
    for(int i=1;i<=n;i++) printf("%lld ",b[i]);
    printf("\n");
}
signed main()
{
    memset(head,-1,sizeof head);
    n=read(),m=read();
    for(int i=1;i<=n;i++) set[i]=i;
    for(int i=1;i<=n;i++)
    {
        int u=read(),v=read(),w=read(),p=1;
        if(find(u)==find(v)) p=0,ans=i;//并查集
        else set[find(u)]=find(v);//并查集
        add(u,v,w,p),add(v,u,w,p);
    }
    dfs1(1,0);
    for(int i=1;i<=n;i++)//边权转点权
    {
        if(i==ans)
        {
            seq[i]=-1;
            xu=edge[i<<1].u;
            xv=edge[i<<1].v;
            w=edge[i<<1].w;
            continue;
        }
        int u=edge[i<<1].u,v=edge[i<<1].v;
        seq[i]=dep[u]>dep[v]?u:v;
        b[seq[i]]=edge[i<<1].w;
    }
    dfs2(1,1);
    c.build(1,1,n);
    while(m--)
    {
        int op=read(),x=read(),y=read();
        if(op==1)
        {
            if(x==ans) w=y;
            else c.update(1,1,n,dfn[seq[x]],y);
        }
        else printf("%lld\n",min(dis(x,y),min(dis(x,xu)+dis(y,xv),dis(x,xv)+dis(y,xu))+w));//式子
    }
    return 0;//拜拜程序~
}
```

---

## 作者：陆拾里 (赞：5)

看到没人所以就来了 第一次写题解啊233333
基本就是裸的树链剖分，唯一的问题在于多了一条边
还好只多了一条，于是把这条边先拿出来，剩下的边组成一棵树
对于修改操作在树上或者单独的这条边上直接修改就可以
对于查询操作，考虑最短路径是否通过单独的这条边
于是可以分两种情况，一种是不经过单独这条边直接在树上做，另一种是一定过这条边，于是路径为单独边的长度加上单独边的两点分别到目标两点的距离
边权存为点权的一些需要注意的事项这里就不再讨论了 祝大家AC愉快！
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<vector>
#include<set>
#include<map>
#include<stack>
#include<queue>
#include<time.h>
#include<climits>
using namespace std;
#define fi first
#define se second
#define fio ios::sync_with_stdio(false);cin.tie(0)
#define pb push_back
#define Max(x,y) (x>y?x:y)
#define Min(x,y) (x<y?x:y)
#define ls (rt<<1)
#define rs (rt<<1|1)
typedef long long LL;
typedef unsigned long long uLL;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
const int MOD = 1e9 + 7;
const double pi = acos(-1.0);
LL read()
{
    LL x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int gcd(int a, int b)
{
	return b?gcd(b,a%b):a;
}
int N,M;
int head[MAXN];
struct node
{
	int to,nxt;
	int w;
}e[MAXN<<1];
int all;
void add(int a, int b, int w)
{
	e[all].to=b;
	e[all].nxt=head[a];
	e[all].w=w;
	head[a]=all++;
}
int fa[MAXN];
int find(int x)
{
	if(fa[x]==x)	return x;
	return fa[x]=find(fa[x]);
}
void Union(int a, int b)
{
	int ra=find(a), rb=find(b);
	if(ra==rb)	return ;
	fa[ra]=rb;
}
int f[MAXN],d[MAXN],size[MAXN],son[MAXN],rk[MAXN],top[MAXN],id[MAXN];
int cnt;
int val[MAXN];
void dfs1(int u, int pre, int dep)
{
	f[u]=pre;
	d[u]=dep;
	size[u]=1;
	for(int i=head[u];i!=-1;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==pre)	continue;
		dfs1(v,u,dep+1);
		size[u]+=size[v];
		if(size[v]>size[son[u]])
			son[u]=v;
	}
}
void dfs2(int u, int t)
{
	top[u]=t;
	id[u]=++cnt;
	rk[cnt]=u;
	if(!son[u])
		return ;
	dfs2(son[u],t);
	for(int i=head[u];i!=-1;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v!=son[u]&&v!=f[u])
			dfs2(v,v);
	}
}
void Dfs(int u, int pre)
{
	for(int i=head[u];i!=-1;i=e[i].nxt)
	{
		int v=e[i].to;
		int w=e[i].w;
		if(v==pre)	continue;
		val[v]=w;
		Dfs(v,u);
	}
}
int c[MAXN];
int lowbit(int x)
{
	return x & (-x);
}
int query(int x)
{
	int res = 0;
	while(x>0)
	{
		res+=c[x];
		x-=lowbit(x);
	}
	return res;
}
void modify(int x, int v)
{
	while(x <= N)
	{
		c[x]+=v;
		x+=lowbit(x);
	}
}
int ran[MAXN<<2],deep[MAXN<<2],first[MAXN<<2],_pow[25],tot=1,dp[MAXN<<2][20],dep[MAXN<<2];
void dfs(int u, int pre)
{
	ran[tot++]=u;
	for(int i=head[u];i!=-1;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==pre)	continue;
		deep[v]=deep[u]+1;
		dfs(v,u);
		ran[tot++]=u;
	}
}
void ST(int len)
{
	int K = (int)(log((double)len) / log(2.0));
	for(int i=1;i<=len;i++)
		dp[i][0]=i;
	for(int j=1;j<=K;j++)
		for(int i=1;i+_pow[j]-1<=len;i++)
		{
			int a = dp[i][j-1], b=dp[i+_pow[j-1]][j-1];
			if(dep[a]<dep[b])	dp[i][j]=a;
			else	dp[i][j]=b;
		}
}
int RMQ(int x, int y)
{
	int K = (int)(log((double)(y-x+1))/log(2.0));
	int a=dp[x][K], b=dp[y-_pow[K]+1][K];
	if(dep[a]<dep[b])	return a;
	else	return b;
}
int LCA(int u, int v)
{
	int x=first[u],y=first[v];
	if(x>y)	swap(x,y);
	int res=RMQ(x,y);
	return ran[res];
}
void change(int x, int y)
{
	int l1=2*x-1,l2=2*x-2;
	int a=e[l1].to;
	int b=e[l2].to;
	int v=d[a]<d[b]?b:a;
	int now=query(id[v])-query(id[v]-1);
	modify(id[v],y-now);
}
int sum(int x, int y)
{
	int p=LCA(x,y);
	int save=query(id[p])-query(id[p]-1);
	int ans=0,fx=top[x],fy=top[y];
	while(fx!=fy)
	{
		if(d[fx]>=d[fy])
		{
			ans+=query(id[x])-query(id[fx]-1);
			x=f[fx],fx=top[x];
		}
		else
		{
			ans+=query(id[y])-query(id[fy]-1);
			y=f[fy],fy=top[y];
		}
	}
	if(id[x]<=id[y])
		ans+=query(id[y])-query(id[x]-1);
	else
		ans+=query(id[x])-query(id[y]-1);
	return ans-save;
}
void init()
{
	memset(head,-1,sizeof(head));
	for(int i=1;i<=N;i++)
		fa[i]=i;
	memset(first,-1,sizeof(first));
	_pow[0]=1;
	for(int i=1;i<=20;i++)
		_pow[i]=_pow[i-1]<<1;
}
void solve()
{
	int ex,ey,ew,ei;
	scanf("%d%d",&N,&M);
	init();
	for(int i=1;i<=N;i++)
	{
		int x,y,w;
		scanf("%d%d%d",&x,&y,&w);
		if(find(x)!=find(y))
		{
			add(x,y,w);add(y,x,w);
			Union(x,y);
		}
		else
		{
			ex=x;ey=y;ew=w;ei=i;
			all++;all++;
		}
	}
	Dfs(1,-1);
	dfs1(1,0,1);
	dfs2(1,1);
	dfs(1,-1);
	for(int i=1;i<tot;i++)
		dep[i]=deep[ran[i]];
	for(int i=1;i<tot;i++)
	{
		if(first[ran[i]]==-1)
			first[ran[i]]=i;
	}
	ST(2*N-1);
	for(int i=1;i<=N;i++)
	{
		modify(i,val[rk[i]]);
	}
	int op;
	for(int i=1;i<=M;i++)
	{
		scanf("%d",&op);
		if(op==1)
		{
			int x,y;
			scanf("%d%d",&x,&y);
			if(x==ei)
			{
				ew=y;
			}
			else
			{
				change(x,y);
			}
		}
		else
		{
			int x,y;
			scanf("%d%d",&x,&y);
			int ans=sum(x,y);
			ans=min(ans,ew+sum(x,ex)+sum(y,ey));
			ans=min(ans,ew+sum(x,ey)+sum(y,ex));
			printf("%d\n",ans);
		}
	}
}
int main()
{
	solve();
	return 0;
}
```

---

## 作者：云浅知处 (赞：3)

一看题目人傻了：动态全源最短路？？这能做？？

然后冷静一下发现题目中说的是 $n$ 点 $n$ 边的连通无向图，也就是**基环树**。

如果是普通的树直接树剖就做完了。基环树实际上就是一棵树多了一条边。

那么我们对于要算两个点的最短距离，只需要讨论一下他们之间的最短路径是否经过那条多出来的边即可。

具体来说，我们随便扔掉一条边 $(u,v)$ 得到一棵树，设其边权为 $w$，如果询问的是 $x,y$ 间的最短距离，那么答案就是下面三个中的最小值：

- 直接在树上走，即 $\text{dist}(x,y)$
- 先走到 $u$，经过 $(u,v)$ 再走到 $w$，即 $\text{dist}(x,u)+w+\text{dist}(v,y)$
- 先走到 $v$，经过 $(v,u)$ 再走到 $w$，即 $\text{dist}(x,v)+w+\text{dist}(u,y)$

其中 $\text{dist}(i,j)$ 表示扔掉这条边后树上两点 $i,j$ 间的最短距离。这可以用树剖做到 $O(\log ^2n)$ 求值。

这样一来，我们就在 $O(m\log ^2n)$ 的时间内解决了这道题。

```cpp
#include<bits/stdc++.h>

#define int long long

#define lson(o) (o<<1)
#define rson(o) (o<<1|1)

using namespace std;

inline int read(){
    int x=0,f=1;char c=getchar();
    for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
    for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
    return x*f;
}

const int MN=1e5+10;
int n,q;

struct Edge{
	int to,cost;
	Edge(int T,int C):to(T),cost(C){}
	Edge(){}
};
vector<Edge>G[MN];
int dep[MN],fa[MN],p[MN],dfn[MN],top[MN],sz[MN],hson[MN],tot,val[MN],wei[MN];

int find(int x){return (x==p[x])?x:(p[x]=find(p[x]));}

struct SegTree{
	
	int d[MN<<2];
	
	inline void pushup(int o){
		d[o]=d[lson(o)]+d[rson(o)];
	}
	
	inline void build(int l,int r,int o){
		if(l==r){d[o]=val[l];return ;}
		int mid=(l+r)>>1;
		build(l,mid,lson(o));
		build(mid+1,r,rson(o));
		pushup(o);
	}
	
	inline int query(int l,int r,int ql,int qr,int o){
		if(l<=ql&&qr<=r)return d[o];
		int mid=(ql+qr)>>1,ans=0;
		if(l<=mid)ans+=query(l,r,ql,mid,lson(o));
		if(r>mid)ans+=query(l,r,mid+1,qr,rson(o));
		return ans;
	}
	
	inline void modify(int pos,int k,int ql,int qr,int o){
		if(ql==qr){d[o]=k;return ;}
		int mid=(ql+qr)>>1;
		if(pos<=mid)modify(pos,k,ql,mid,lson(o));
		else modify(pos,k,mid+1,qr,rson(o));
		pushup(o);
	}

};

SegTree tree;

int dfs1(int u,int de){
	dep[u]=de,sz[u]=1;
	for(int i=0;i<G[u].size();i++){
		int v=G[u][i].to,w=G[u][i].cost;
		if(v==fa[u])continue;
		fa[v]=u,wei[v]=w,sz[u]+=dfs1(v,de+1);
		if(sz[v]>sz[hson[u]])hson[u]=v;
	}
	return sz[u];
}

void dfs2(int u,int tp){
	top[u]=tp,dfn[u]=++tot,val[tot]=wei[u];
	if(hson[u])dfs2(hson[u],tp);
	for(int i=0;i<G[u].size();i++){
		int v=G[u][i].to;
		if(v!=fa[u]&&v!=hson[u])dfs2(v,v);
	}
}

int querysum(int x,int y){
	int ans=0;if(x==y)return 0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		ans+=tree.query(dfn[top[x]],dfn[x],1,n,1);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	ans+=tree.query(dfn[x]+1,dfn[y],1,n,1);
	return ans;
}

int cu,cv,cw;
int x[MN],y[MN];

signed main(void){
	
	n=read();q=read();
	for(int i=1;i<=n;i++)p[i]=i;
	for(int i=1;i<=n;i++){
		int u=read(),v=read(),w=read();x[i]=u,y[i]=v;
		int uu=find(u),vv=find(v);
		if(uu==vv)cu=u,cv=v,cw=w;
		else p[uu]=vv,G[u].push_back(Edge(v,w)),G[v].push_back(Edge(u,w));
	}
	
	dfs1(1,1);dfs2(1,1);
	tree.build(1,n,1);
	
	while(q--){
		int op=read(),a=read(),b=read();
		if(op==1){
			if(x[a]==cu&&y[a]==cv){cw=b;continue;}
			int u=x[a],v=y[a];if(u==fa[v])swap(u,v);
			tree.modify(dfn[u],b,1,n,1);
		}
		else{
			int r=querysum(a,b);
			int s=querysum(a,cu)+cw+querysum(cv,b);
			int t=querysum(a,cv)+cw+querysum(cu,b);
			cout<<min(r,min(s,t))<<endl;
		}
	}

    return 0;
}
```

---

## 作者：Ccliang (赞：3)

~~我原本正在找树剖题做，然后就看到了这道题~~

然后我就一脸懵逼了，这TM一个图怎么用树剖，然后仔细一看：

-  给出一个 n 个点 n 条边的无向连通图。

只多了一条边，于是我们拿出一条多余的边，并记录下来。

这个拿出边的操作~~很明显~~可以用并查集实现。

然后将边权压到点里去。

对于 x 到 y，分类讨论一下：

假设我们拿出的边的两个端点是 u 和 v。

则 x 到 y 有 3 种情况

1. x -> y ，直接求个区间和就可以了。

2. x -> u，u -> v，v -> y，求两个区间和再加一个记录下来的权值。

3. x -> v，v -> u, u -> y,和第二种情况是差不多的。

答案就是三种情况的最小值。

~~然后貌似就没有了~~

放一下代码：~~我知道你们只看这个~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;

const int N = 100000 + 10;

inline int read()
{
	int res=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')res=(res<<3)+(res<<1)+(ch^48),ch=getchar();
	return res;
}
#define fir first
#define sec second
int n,Q;

vector <pair<int,int> > edge;

struct Edge{
	int next,to,w;
}r[N<<1];

int head[N],tot;

void add(int u,int v,int w)
{
	r[++tot]=(Edge){head[u],v,w};
	head[u]=tot;
	r[++tot]=(Edge){head[v],u,w};
	head[v]=tot;
}

int fa[N];

int find(int x)
{
	if(fa[x]==x)
		return fa[x];
	return fa[x]=find(fa[x]);
}

int dep[N],size[N],top[N],son[N],id[N],cnt;

int a[N],b[N];

void dfs1(int u,int father)
{
	dep[u]=dep[father]+1,size[u]=1,fa[u]=father;
	for(int e=head[u],v;e;e=r[e].next)
	{
		v=r[e].to;
		if(v==father)continue;
		dfs1(v,u),a[v]=r[e].w;
		size[u]+=size[v];
		if(size[son[u]]<size[v])
			son[u]=v;
	}
}

void dfs2(int u,int topf)
{
	id[u]=++cnt;
	top[u]=topf;
	b[cnt]=a[u];
	if(!son[u])
		return ;
	dfs2(son[u],topf);
	for(int e=head[u],v;e;e=r[e].next)
	{
		v=r[e].to;
		if(v==fa[u]||v==son[u])continue;
		dfs2(v,v);
	}
}

int sum[N];
#define lowbit(x) x&(-x)
void modify(int x,int y)
{
	while(x<=n)
		sum[x]+=y,x+=lowbit(x);
}

int query(int x)
{
	int res=0;
	while(x>=1)
		res+=sum[x],x-=lowbit(x);
	return res;
}

void change(int x,int y)
{
	int u=dep[edge[x-1].fir]>dep[edge[x-1].sec]?edge[x-1].fir:edge[x-1].sec;
	modify(id[u],y-query(id[u])+query(id[u]-1));
}

int Tquery(int x,int y)
{
	int res=0;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])
			swap(x,y);
		res+=query(id[x])-query(id[top[x]]-1);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y])
		swap(x,y);
	res+=query(id[y])-query(id[x]);
	return res;
}

int ans,ans1,ans2,lastw,last,lastu,lastv,opt,x,y;

int main()
{
	n=read(),Q=read();
	for(int i=1;i<=n;i++)
		fa[i]=i;
	for(int i=1,u,v,w,r1,r2;i<=n;i++)
	{
		u=read(),v=read(),w=read();
		edge.push_back(make_pair(u,v));
		r1=find(u),r2=find(v);
		if(r1!=r2)
			add(u,v,w),fa[r1]=r2;
		else last=i,lastw=w,lastu=u,lastv=v;//将多余的边记录下来
	}
	dfs1(1,0),dfs2(1,1);
	for(int i=1;i<=n;i++)
		modify(i,b[i]);
	while(Q--)
	{
		opt=read(),x=read(),y=read();
		if(opt==1)
		{
			if(x==last)lastw=y;
			else change(x,y);
		}
		if(opt==2)
		{
			ans=Tquery(x,y);//情况1
			ans1=Tquery(x,lastu)+Tquery(y,lastv)+lastw;//情况2
			ans2=Tquery(x,lastv)+Tquery(y,lastu)+lastw;//情况3
			printf("%d\n",min(min(ans1,ans2),ans));
		}	
	}
	return 0;
}
```


---

## 作者：zhanghzqwq (赞：2)

前言：不得不说这道题真的是一道好题，对于树剖和树上操作的理解很有帮助

### 一、题意:

给你一个$n$个点$n$条边的无向连通图，让你求$x$点到$y$点的最短路径，其中还有一些修改操作：修改每一条边的边权。

### 二、思路

我们拿到这道题时，显然会发现这是一棵树再加上一条边，那么显而易见，我们应该先把加上的边求出来：这部分可以用并查集维护。

我们在想，如果只是一棵树呢，那么是不是就是一个树剖模板（因为在一棵树上的最短路径是唯一的）。

既然我们加上一条边，设这条边是从U到V的，那么从$x$到$y$的最短路径只有三种可能：

 1.原来树上的$x$到$y$(树剖维护）。
 
 2.$x$到$U$的距离+$U$到$V$的距离+$V$到$y$的距离。（分别用树剖求一下树上的两段距离）

 3.$x$到$V$的距离+$V$到$U$的距离+$U$到$y$的距离。（同上）

ok，大体思路已经出来了，那么我们该如何用树剖维护距离呢？我们注意到这里是边权和，而一般的树剖是维护点权的，所以我们这里吧边权下放到点权，这样就可以用树剖维护了。（~~其实就是树剖模板~~）这里维护点权和使用线段树维护的，单点修改区间和~~也是模板~~。

### 三、代码

代码的细节很多，我会写到注释里：

```
#include<cstdio>
#include<algorithm>
using namespace std;
const int MAXN=1e5+10;
int n,m;
int f[MAXN];//注意不要跟树剖的fa数组重名了
int find(int a){//并查集模板
	if(f[a]==a){
		return a;
	}
	return f[a]=find(f[a]);
} 
void merge(int x,int y){//并查集合并
	f[find(x)]=find(y);
}
struct Edge{
	int u,v,w,next;
} pool[MAXN<<1];
int head[MAXN],uu;
void add(int u,int v,int w){
	pool[++uu].u=u;
	pool[uu].v=v;
	pool[uu].w=w;
	pool[uu].next=head[u];
	head[u]=uu;
}
int U,V,W,Id;//这里是多出来的边的信息，Id是这是第几条边。
int cnt;
int val[MAXN],wt[MAXN];
int dep[MAXN],fa[MAXN],siz[MAXN],son[MAXN];
int top[MAXN],id[MAXN];
void dfs1(int u,int father){//树剖第一次dfs
	dep[u]=dep[father]+1;
	fa[u]=father;
	siz[u]=1;
	int maxson=0;
	for(int i=head[u];i;i=pool[i].next){
		int v=pool[i].v;
		int w=pool[i].w;
		if(v!=father){
			dfs1(v,u);
			siz[u]+=siz[v];
			val[v]=w;//下放到点权
			if(siz[v]>maxson){
				son[u]=v;
				maxson=siz[v];
			}
		}
	}
}
void dfs2(int u,int topf){//第二次dfs
	top[u]=topf;
	id[u]=++cnt;//建立树的dfs序
	wt[cnt]=val[u];
	if(!son[u]){//如果没有重儿子的话就代表这是叶子
		return;
	}
	dfs2(son[u],topf);//先遍历重儿子
	for(int i=head[u];i;i=pool[i].next){
		int v=pool[i].v;
		if(v!=fa[u]&&v!=son[u]){
			dfs2(v,v);
		}
	}
}
//这里往下是区间修改单点查询的线段树
int sum[MAXN<<2];
inline int lc(int p){return p<<1;}
inline int rc(int p){return p<<1|1;}
void pushUp(int p){//更新父节点信息
	sum[p]=sum[lc(p)]+sum[rc(p)];
}
void build(int p,int l,int r){//建树
	if(l==r){
		sum[p]=wt[l];
		return;
	}
	int mid=(l+r)>>1;
	build(lc(p),l,mid);
	build(rc(p),mid+1,r);
	pushUp(p);
}
void update(int p,int l,int r,int x,int d){//单点修改
	if(l==r){
		sum[p]=d;
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid){
		update(lc(p),l,mid,x,d);
	}else{
		update(rc(p),mid+1,r,x,d);
	}
	pushUp(p);
}
int query(int p,int l,int r,int ql,int qr){//查询区间和
	if(ql<=l&&r<=qr){
		return sum[p];
	}
	int mid=(l+r)>>1;
	int res=0;
	if(ql<=mid){
		res+=query(lc(p),l,mid,ql,qr);
	}
	if(mid<qr){
		res+=query(rc(p),mid+1,r,ql,qr); 
	}
	return res;
}
//接下来是本题的两个操作
void change(int x,int y){//修改一条边的边权（需修改下放的点权）
	x<<=1;//链式前向星双向建边，所以乘2
	int u=pool[x].u;
	int v=pool[x].v;
	if(dep[u]>dep[v]){//修改深度大的点
		swap(u,v);
	}
	update(1,1,n,id[v],y);
}
int ask(int x,int y){//树剖求两点距离
	int res=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]){//别忘了是top[x]和top[y]比较
			swap(x,y);
		}
		res+=query(1,1,n,id[top[x]],id[x]);
		x=fa[top[x]];
	}
	if(x==y){//因为是下放点权，所以两个点的lca不算入距离
		return res;
	}
	if(dep[x]>dep[y]){
		swap(x,y);
	}
	res+=query(1,1,n,id[x]+1,id[y]);//同上，别忘了加1
	return res;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		f[i]=i;
	}
	for(int i=1;i<=n;i++){
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		if(find(u)!=find(v)){//并查集判环
			merge(u,v);
			add(u,v,w);
			add(v,u,w);
		}else{
			U=u;
			V=v;
			W=w;
			Id=i;
			uu+=2;//链式前向星的uu记得加2
		}
	}
	dfs1(1,0);
	dfs2(1,1);
	build(1,1,n);
	while(m--){
		int op;
		scanf("%d",&op);
		int x,y;
		scanf("%d%d",&x,&y);
		if(op==1){
			if(x==Id){//如果是加边就这届修改
				W=y;
			}else{
				change(x,y);
			}
		}else{
        //这三行分别是那三种情况
			int ans=ask(x,y);
			ans=min(ans,ask(x,U)+W+ask(V,y));
			ans=min(ans,ask(x,V)+W+ask(U,y));
			printf("%d\n",ans);
		}
	}
	return 0;//完结撒花
}
```

总之，这道题不是很难想，不过代码的细节一定要处理好，qwq


---

## 作者：冰霜_凯撒 (赞：2)

 #### 本体是一道基环树和树链剖分的题，可以先暴力找环，然后再将环用树状数组维护，其他部分用树剖维护即可。
![如图](https://cdn.luogu.com.cn/upload/pic/59390.png)
#### 如图先找到环1 - 2 - 3 - 4，比如找1 - 6距离，先找到6的根4和1的根1，用树剖算出距离之和，再用树状数组算出1 - 2 - 4与1 - 3 - 4的距离最小值，即可快速求出答案。(树边长度忽略）
#### 下面粘贴题解代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
using namespace std;
int n,m,t;
const int N=3e5+50;
//建图 
int s[N<<1],sl[N<<1],len[N<<1];
int gx[N],gy[N],gt[N],f;
void addline(int x,int y,int z){
    s[++t]=y;
    sl[t]=sl[x];
    sl[x]=t;
    len[t]=z;
    s[++t]=x;
    sl[t]=sl[y];
    sl[y]=t;
    len[t]=z;
    return;
}
// 找环 
bool book[N];
int d[N<<1],dl[N<<1],q,q1,root[N],bood[N],deep[N];
int rof[N],r;
void bfs(int x){
    int j1,j2;
    q=0;q1=0;book[x]=1;deep[x]=1;
    d[++q]=x;dl[q]=0;bood[x]=q;
    while(q1<q){
        int u=d[++q1],u1=deep[u];
        for(int i=sl[u];i;i=sl[i]){
            int de=s[i];
            if(de==d[dl[bood[u]]]) continue;
            //cout<<de<<" "<<u<<endl;
            if(!book[de]){
                book[de]=1;d[++q]=de;
                dl[q]=q1;bood[de]=q;
                deep[de]=u1+1;
            }
            else{
                j1=u;j2=de;
                if(root[u]!=u)
                root[u]=u,rof[++r]=u;
                if(root[de]!=de)
                root[de]=de,rof[++r]=de;
                if(deep[j1]<deep[j2]) swap(j1,j2);
                while(deep[j1]!=deep[j2]){
                	int f1=bood[j1];
                	f1=dl[f1];
                	j1=d[f1];
                	if(root[j1]!=j1)
                	root[j1]=j1,rof[++r]=j1;
                }
                while(j1!=j2){
                    int f1=bood[j1],f2=bood[j2];
                    f1=dl[f1],f2=dl[f2];
                    j1=d[f1],j2=d[f2];
                    if(root[j1]!=j1)
                    root[j1]=j1,rof[++r]=j1;
                    if(root[j2]!=j2)
                    root[j2]=j2,rof[++r]=j2;
                } 
                return;
            }
        }
    }
    return;
}
//建树
int num[N],fa[N],son[N],siz[N],dep[N],top[N],cnt;
int a[N<<2],tag[N<<2],w[N],wt[N]; 
int root1;
void dfs1(int x,int y,int dd){
    fa[x]=y;dep[x]=dd;siz[x]=1;root[x]=root1;
    int ms=-1;
    for(int i=sl[x];i;i=sl[i]){
        int de=s[i];
        if(root[de]!=0) continue;
        w[de]=len[i];
        dfs1(de,x,dd+1);
        siz[x]+=siz[de];
        if(ms<siz[de]){
            ms=siz[de];son[x]=de;
        }
    }
    return;
}
void dfs2(int x,int topp){
    top[x]=topp;num[x]=++cnt;wt[cnt]=w[x];
    if(!son[x]) return;
    dfs2(son[x],topp);
    for(int i=sl[x];i;i=sl[i]){
        int de=s[i];
        if(root[de]!=root1||de==fa[x]||de==son[x]) continue;
        dfs2(de,de);
    }
    return;
}
void build(int l,int r,int p){
    if(l>r) return;
    if(l==r){
        a[p]=wt[l];
        return;
    }
    int mid=(l+r)/2;
    build(l,mid,p*2);
    build(mid+1,r,p*2+1);
    a[p]=a[p*2]+a[p*2+1];
    return;
}
//建树状数组
int tree[N<<2],sround[N],g,ysh,yhs[N<<2];
int par[N];
int lowbit(int x){return x&(-1*x);}
void add(int x,int y){
    tree[x]+=y;
    while(x<=r*2){
        x+=lowbit(x);
        tree[x]+=y;
    }
    return;
}
void bfs1(int x){
    memset(book,0,sizeof book);
    q=0;q1=0;d[++q]=x;
    sround[++g]=x;book[x]=1;
    int u;
    while(q1<q){
        u=d[++q1];
        for(int i=sl[u];i;i=sl[i]){
            int de=s[i];
            if(root[de]==de&&!book[de]){
                add(++ysh,len[i]);
                add(ysh+r,len[i]);
                yhs[u]=ysh;par[de]=u;
                d[++q]=de;sround[++g]=de;book[de]=1;
                break;
            }
        }
    }
    for(int i=sl[u];i;i=sl[i]){
        int de=s[i];
        if(de==d[1]){
            add(++ysh,len[i]);
            add(ysh+r,len[i]);
            yhs[u]=ysh;par[d[1]]=u;
        }
    }
    return;
}
//opt=1
void pushdown(int p,int rr){
    tag[p*2]+=tag[p];
    tag[p*2+1]+=tag[p];
    a[p*2]+=tag[p]*(rr-(rr/2));
    a[p*2+1]+=tag[p]*(rr/2);
    tag[p]=0;
    return;
}
void update(int p,int l,int r,int L,int R,int k){
    if(L<=l&&R>=r){
        tag[p]+=k;
        a[p]+=k*(r-l+1);
        return;
    }
    if(tag[p]) pushdown(p,r-l+1);
    int mid=(l+r)/2;
    if(L<=mid) update(p*2,l,mid,L,R,k);
    if(R>mid) update(p*2+1,mid+1,r,L,R,k);
    a[p]=a[p*2]+a[p*2+1];
    return;
}
//opt=2
int res;
void quary(int p,int l,int r,int L,int R){
    if(L<=l&&R>=r){
        res+=a[p];return;
    }
    if(tag[p]) pushdown(p,r-l+1);
    int mid=(l+r)/2;
    if(L<=mid) quary(p*2,l,mid,L,R);
    if(R>mid) quary(p*2+1,mid+1,r,L,R);
    return;
}
int sum(int x,int y){
    int ans=0;
    while(top[x]!=top[y]){
        if(dep[top[x]]<dep[top[y]]) swap(x,y);
        res=0;
        quary(1,1,n,num[top[x]],num[x]);ans+=res;
        x=fa[top[x]];
    }
    if(dep[x]>dep[y]) swap(x,y);
    res=0;
    quary(1,1,n,num[x]+1,num[y]);
    ans+=res;
    return ans;
}
int sum1(int x){
    int ans=0;
    while(x>0){
        ans+=tree[x];
        x-=lowbit(x);
    }
    return ans;
} 
int main()
{
    scanf("%d%d",&n,&m);
    int suml;
    int i,x,y,z,opt,dx,dy,dt,cha;t=n;
    for(i=1;i<=n;++i){
        s[i]=i;
        scanf("%d%d%d",&x,&y,&z);
        gx[++f]=x;gy[f]=y;gt[f]=t+1;
        addline(x,y,z);
    }
    bfs(1);
    for(i=1;i<=r;++i){
        root1=rof[i];
        dfs1(rof[i],0,1);
        dfs2(rof[i],rof[i]);
    }
    
    build(1,cnt,1);
    bfs1(rof[1]);
    while(m--){
        scanf("%d%d%d",&opt,&x,&y);
        if(opt==1){
            dx=gx[x];dy=gy[x];dt=gt[x];
            cha=y-len[dt];
            len[dt]=y;len[dt+1]=y;
            if(root[dx]==dx&&root[dy]==dy){
                dx=yhs[dx];dy=yhs[dy];
                if(dx>dy) swap(dx,dy);
                if(dx==1&&dy==g){
                	add(dy,cha);
                	add(dy+r,cha);
                }
                else{
                    add(dx,cha);
                    add(dx+r,cha);
                }
            }
            else{
                if(fa[dx]==dy){
                    update(1,1,n,num[dx],num[dx],cha);
                }
                else{
                    update(1,1,n,num[dy],num[dy],cha);
                }
            }
        }
        else{
            suml=0;
            if(root[x]==root[y]){
                suml+=sum(x,y);
            }
            else{
                suml+=sum(root[x],x)+sum(root[y],y);
            	dx=yhs[root[x]];dy=yhs[root[y]];
              	if(dx>dy) swap(dx,dy);
              	//cout<<dx<<" "<<dy<<endl;
             	suml+=min((sum1(dy-1)-sum1(dx-1)),(sum1(dx+r-1)-sum1(dy-1)));
            }
            
            printf("%d\n",suml);
        }
    }
    return 0;
 } 
```
#### 祝大家AC愉快！！！

---

## 作者：hyfhaha (赞：1)

# 吼题啊
刚开始看上去又以为是LCT啥子的。

后来发现，TM是个图。

然后果断准备放弃，突然发现只有N个点N条边。

woc，这不就一个基环树上树链剖分吗。。。

关于基环树问题，相信大家都一定很有经验了吧，用个并查集找出多的边，然后把图分成一棵树和一条边，然后树上就树上做，多出来的边就可以另外处理。

关于边权转点权，直接在查询的最后减去LCA的点权就OK了，其他当成点权处理。

关于线段树，这个大家都会改吧。。。

关于修改操作，直接找出相应的点权，然后修改就行了，找点权记得先边的编号乘2

总之还是很简单的

下面可以看看代码注释：
```cpp
#include<bits/stdc++.h>
#define maxn 4000001
#define L(x) (x<<1)
#define R(x) ((x<<1)|1)
using namespace std;
int tree[maxn],tag[maxn];
int rev[maxn],dep[maxn],size[maxn],seg[maxn],top[maxn],son[maxn],father[maxn];
int n,m,root,x,y,z,a[maxn],visx[maxn],visy[maxn],tot,mode;
int cnt,from[maxn],to[maxn],Next[maxn],head[maxn];
int Gx,Gy,Gz,Gd;
int fa[maxn],X[maxn],Y[maxn],Z[maxn];
int find(int x){
    if(fa[x]==x)return x;
    else return fa[x]=find(fa[x]);
}
bool merge(int x,int y){
    int i=find(x),j=find(y);
    if(i==j)return false;
    fa[i]=j;return true;
}
void add(int x,int y){
    cnt++;
    from[cnt]=x;to[cnt]=y;
    Next[cnt]=head[x];head[x]=cnt;
}
void update(int node,int begin,int end,int x,int y,int val){
    if(begin>y||end<x)return;
    if(begin>=x&&end<=y){
        tree[node]=val;
        return;
    }else{
        int mid=(begin+end)>>1;
        if(x<=mid)update(L(node),begin,mid,x,y,val);
        if(y>mid) update(R(node),mid+1,end,x,y,val);
        tree[node]=tree[L(node)]+tree[R(node)];
    }
}
int query(int node,int begin,int end,int x,int y){
    if(begin>=x&&end<=y){
        return tree[node];
    }else{
        int mid=(begin+end)>>1,sum=0;
        if(x<=mid)sum+=query(L(node),begin,mid,x,y);
        if(y>mid) sum+=query(R(node),mid+1,end,x,y);
        return sum;
    }
}
int dfs1(int x){
    size[x]=1;
    dep[x]=dep[father[x]]+1;
    for(int i=head[x];i!=-1;i=Next[i]){
        int v=to[i],big=0;
        if(father[x]==v)continue;
        father[v]=x;
        big=dfs1(v);
        size[x]+=big;
        if(big>size[son[x]])son[x]=v;
    }
    return size[x]; 
}
void dfs2(int x){
    if(son[x]){
        seg[son[x]]=++seg[0];
        top[son[x]]=top[x];
        rev[seg[0]]=son[x];
        dfs2(son[x]);
    }
    for(int i=head[x];i!=-1;i=Next[i]){
        int v=to[i];
        if(!top[v]){
            seg[v]=++seg[0];
            top[v]=v;
            rev[seg[0]]=v;
            dfs2(v);
        }
    }
}
int linkquery(int x,int y){
    int fx=top[x],fy=top[y],ans=0;
    while(fx!=fy){
        if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);
        ans+=query(1,1,seg[0],seg[fx],seg[x]);
        x=father[fx];fx=top[x];
    }
    if(dep[x]>dep[y])swap(x,y);
    ans+=query(1,1,seg[0],seg[x],seg[y]);
    ans-=query(1,1,seg[0],seg[x],seg[x]);
    return ans;
}
void change(int x,int y){                       //修改边权
    x*=2;       //记得乘2
    x=dep[from[x]]>dep[to[x]]?from[x]:to[x];    //因为边权钦定的是深度大的点
    update(1,1,seg[0],seg[x],seg[x],y);         //直接改
}
int main(){
    memset(head,-1,sizeof(head));
    scanf("%d%d",&n,&m);root=1;
    for(int i=1;i<=n;i++)fa[i]=i;
    for(int i=1;i<=n;i++){
        scanf("%d%d%d",&x,&y,&z);
        if(merge(x,y)){add(x,y),add(y,x);}
        else Gx=x,Gy=y,Gz=z,Gd=i,cnt+=2;        //并查集判多的边
        X[i]=x;Y[i]=y;Z[i]=z;
    }
    dfs1(root);
    seg[root]=++seg[0];
    rev[seg[0]]=root;
    top[root]=root;
    dfs2(root);
    for(int i=1;i<=n;i++)if(Gd!=i)change(i,Z[i]);   //因为本人懒得写build，所以这样写
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&mode,&x,&y);
        if(mode==1){
            if(x==Gd)Gz=y;          //如果是多余的边就直接改
            else change(x,y);       //不然就另外改
        }else{
            int ans;
            ans=linkquery(x,y);         //第一种情况，不经过多余的边
            ans=min(ans,Gz+min(linkquery(x,Gx)+linkquery(Gy,y),linkquery(x,Gy)+linkquery(Gx,y)));   //第二种情况，经过多余的边
            printf("%d\n",ans);
        }
    }
}
```

---

## 作者：Starrydream (赞：1)

# P4949 最短距离

## 题目描述

给出一个 N 个点 N 条边的无向连通图。

你需要支持两种操作：

1. 修改 第 x 条边的长度为 y ；
2. 查询 点 x 到点 y 的最短距离。

共有 M 次操作。

## 输入输出格式

输入格式：



输入共 N + M + 1 行：

第 1 行，包含 2 个正整数 N，M，表示点数即边数，操作次数。

第 2 行到第 N + 1 行，每行包含 3 个正整数 x，y，z，表示 x 与 y 间有一条长度 为 z 的边。

第 N + 2 到 N + M + 1 行，每行包含 3 个正整数 opt，x，y，表示操作种类，操作的参数（含义见【题目描述】）。



输出格式：



对于每次操作 2 输出查询的结果。



## 输入输出样例

输入样例#1：



```
4 5
1 2 11
1 3 12
2 3 13
1 4 15
2 2 3
1 2 1
2 2 3
2 2 4
2 3 4
```

输出样例#1：



```
13
12
26
16
```

## 说明

![Luogu](Images/37934-1542366203739.png)

## 题解

这道题思维难度还行，代码实现难度略高。

首先我们需要实现支持以下功能的函数：

- O(1)查询每条边代表的点，断边为0即可
- O(1)维护环上边权总和
- O(1)查询一条边是否为割边。
- O(1)查询邻接表中每个编号所对应的读入顺序
- O(1)查询一个点所属的环子树

接下来任选一条边断开，将这颗树用HPD维护。

当给出一个修改操作时

- 如果是树边，直接HPD维护，
  $$
  O(nlogn)
  $$


- 如果是环边，O(1)在数组中修改这条环边边权，O(1)更新环上边权总和，O(nlogn)更新HPD这条边对应点点权



对于查询操作

- 如果两点属于同一环子树，直接查询两点距离，
  $$
  O(nlog^2n)
  $$


- 如果属于不同子树，需要考虑环上另一条路径长度（O(1)查询即可），复杂度同样

上一下一遍过的Code（NOIP要是我代码能力发挥出写这题的一半就不会炸这么惨。。。）：

```c++
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <iostream>
#include <stack>
#define maxn 105005
#define ll long long
int n , head[maxn] , cnt = 1 , u , v , circle[maxn] , m , eref[maxn << 1];
ll val[maxn];
struct edge{
	int next , to ;
	ll dis;
}e[maxn<<1];
inline bool isEdge(int x , int y)
{
	if(x == u && y == v)	return false;
	if(x == v && y == u)	return false;
	return true;
}
inline bool c(int x){
	return circle[x];
}
inline void add(int x , int y , ll d)
{
	e[++cnt].next = head[x];
	e[cnt].to = y;
	e[cnt].dis = d;
	head[x] = cnt;
}
namespace cir{
	int dfn[maxn] , low[maxn] , idx , tot , cirnum , sz[maxn];
	bool flag;
	std::stack<int> st;
	void DFS_CIRCLE(int x , int pre)
	{
		if(flag)	return;
		dfn[x] = low[x] = ++idx;
		st.push(x);
		for(int i = head[x] ; i ; i = e[i].next){
			int v = e[i].to;
			if(!dfn[v]){
				DFS_CIRCLE(v , x);
				low[x] = std::min(low[x] , low[v]);
			}
			else if(v != pre)	low[x] = std::min(low[x] , dfn[v]);
		}
		if(dfn[x] == low[x])
		{
			++tot;
			while(st.top() != x)
			{
				circle[st.top()] = tot;
				++sz[tot];
				st.pop();
			}
			circle[st.top()] = tot;
			++sz[tot];
			st.pop();
			if(sz[tot] > 1)
			{
				flag = true;
				cirnum = tot;
				return;
			}
		}
	}
	void pre()
	{
		DFS_CIRCLE(1,1);
		for(int i = 1 ; i <= n ; ++i)
			if(circle[i] != cirnum)
				circle[i] = 0;
		for(int i = 1 ; i <= n ; ++i){
			if(circle[i]){
				u = i;
				for(int j = head[i] ; j ; j = e[j].next){
					if(circle[e[j].to])	v = e[j].to;
				}				
				break;
			}
		}
	}
}
struct SegmentTree
{
	#define ls(x) (x << 1)
	#define rs(x) (x << 1 | 1)
	#define pushup(x) sum[x] = sum[ls(x)] + sum[rs(x)] 
	ll sum[maxn<<2];
	void build(int l , int r , int Node , ll v[])
	{
		if(l == r)
		{
			sum[Node] = v[l];
			return;
		}
		int mid = l + r >> 1;
		build(l , mid , ls(Node) , v);
		build(mid + 1 , r , rs(Node) , v);
		pushup(Node);
	}
	void update(int p , int l , int r , int Node , ll v)
	{
		if(l == r){
			sum[Node] = v;
			return;
		}
		int mid = l + r >> 1;
		if(p <= mid) 	update(p , l , mid , ls(Node) , v);
		else update(p , mid + 1 , r , rs(Node) , v);
		pushup(Node);
	}
	ll query(int L , int R , int l , int r , int Node)
	{
		if(L <= l && r <= R){
			return sum[Node];
		}
		int mid = l + r >> 1 ;
		ll ans = 0;
		if(L <= mid)	ans += query(L , R , l , mid , ls(Node));
		if(R > mid)		ans += query(L , R , mid + 1 , r , rs(Node));
		return ans;
	}
};
struct HPD
{
	int id[maxn] , hs[maxn] , sz[maxn] , top[maxn] , f[maxn] , dep[maxn] , idx;
	ll v[maxn];
	SegmentTree tr;
	void dfs1(int x , int fx)
	{
		dep[x] = dep[fx] + 1;
		f[x] = fx;
		sz[x] = 1;
		for(int i = head[x] ; i ; i = e[i].next){
			int v = e[i].to;
			if(v == fx || !isEdge(x , v))	continue;
			dfs1(v , x);
			sz[x] += sz[v];
			if(sz[v] > sz[hs[x]])	hs[x] = v;
		}
	}
	void dfs2(int x , int topv)
	{
		top[x] = topv;
		id[x] = ++idx;
		v[id[x]] = val[x];
		if(!hs[x])	return;
		dfs2(hs[x] , topv);
		for(int i = head[x] ; i ; i = e[i].next){
			int ver = e[i].to;
			if(ver == f[x] || !isEdge(x , ver) || ver == hs[x])	continue;
			dfs2(ver , ver);
		}
	}
	void build(){
		tr.build(1,n,1,v);
	}
	inline ll query(int x , int y)
	{
		ll ans = 0;
		while(top[x] != top[y]){
			if(dep[top[x]] < dep[top[y]])	std::swap(x,y);
			ans += tr.query(id[top[x]] , id[x] , 1 , n , 1);
			x = f[top[x]];
		}
		if(dep[x] < dep[y])	std::swap(x,y);
		ans += tr.query(id[y] , id[x] , 1 , n , 1);
		ans -= tr.query(id[y] , id[y] , 1 , n , 1);
		return ans;
	}
	void update(int p , ll x){
		if(!p)	return;
		tr.update(id[p] , 1 , n , 1 , x);
	}
}forest;
namespace Solve
{
	ll cirsum , cirEdis[maxn << 1];
	int eid[maxn << 1] , bl[maxn] , cirnum; // the edge to the point 
	bool cire[maxn << 1]; // the type of points
	void DFS_Down(int x , int fx , ll dis , int Enum) // Enum -> the real id of edge
	{
		val[x] = dis;
		eid[Enum] = x;
		for(int i = head[x] ; i ; i = e[i].next){
			int v = e[i].to;
			if(v == fx)	continue;
			if(!isEdge(x , v))	continue;
			DFS_Down(v , x , e[i].dis , eref[i]);
		}
	}
	void getBelong(int x , int fx , int rt)
	{
		bl[x] = rt;
		for(int i = head[x] ; i ; i = e[i].next)
			if(e[i].to != fx && !circle[e[i].to])
				getBelong(e[i].to , x , rt);
	}
	inline ll q(int x , int y)
	{
		if(bl[x] == bl[y]){
			return forest.query(x,y);
		}
		else{
			ll ans = forest.query(x,y);
			ll tmp = forest.query(bl[x] , bl[y]);
			ans -= tmp;
			tmp = std::min(tmp , cirsum - tmp);
			ans += tmp;
			return ans;
		}
	}
	inline void upd(int x , ll y)
	{
		int p = eid[x];
		if(cire[x]){
			cirsum += y - cirEdis[x];
			cirEdis[x] = y;
		}
		forest.update(p , y);
	}
	inline void solve()
	{
		scanf("%d%d",&n,&m);
		for(int i = 1 ; i <= n ; ++i){
			int x , y ;
			ll d;
			scanf("%d%d%lld",&x,&y,&d);
			add(x,y,d) , eref[cnt] = i , add(y,x,d) , eref[cnt] = i;
		}
		cir::pre();// get the circle , identify the edge to cut
		DFS_Down(1 , 1 , 0 , 0); // the root must be invalid !!
		forest.dfs1(1 , 1);
		forest.dfs2(1 , 1);
		forest.build();
		for(int i = 1 ; i <= n ; ++i){
			if(circle[i]){
				getBelong(i , i , i);
				for(int j = head[i] ; j ; j = e[j].next)
					if(circle[e[j].to])
						cire[eref[j]] = true , cirsum += e[j].dis , cirEdis[eref[j]] = e[j].dis;
			} 
		}
		cirsum >>= 1;
		for(int i = 1 ; i <= m ; ++i){
			int op ,x , z;
			ll y;
			scanf("%d",&op);
			if(op == 1){
				scanf("%d%lld",&x,&y);
				upd(x,y);
			}
			if(op == 2){
				scanf("%d%d",&x,&z);
				printf("%lld\n",q(x,z));
			}
		}
	}
}
int main()
{
	Solve::solve();
}
```



---

## 作者：Register_int (赞：0)

边点数量相同的连通图，那显然就是基环树。  
如果是在树上的话，那么路径显然只有一条，加上带改可以树剖做。这里参见 [P1505](\problem\P1505)。  
然而现在是基环树，没法树剖了。解决方法也很简单，直接把环上一条边拆下来，分段考虑。假设拆出来的边的两个端点分别为 $x,y$，边权为 $z$，那么 $u,v$ 间的最短距离为：
$$\min\{\operatorname{dis}(u,v),\operatorname{dis}(u,x)+\operatorname{dis}(y,v)+z,\operatorname{dis}(u,y)+\operatorname{dis}(x,v)+z\}$$
拆边用并查集搞一搞。  
# AC 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 2e5 + 10;

const int inf = ~0u >> 1;

struct edge {
	int v, w, nxt;
} e[MAXN << 1];

int head[MAXN], tot;

inline 
void add(int u, int v, int w) {
	e[++tot] = { v, w, head[u] }, head[u] = tot;
}

struct pos {
	int u, v;
} a[MAXN];

int dep[MAXN], fa[MAXN], size[MAXN], tv[MAXN], son[MAXN];
int top[MAXN], id[MAXN], rev[MAXN], val[MAXN], cnt;

void dfs1(int u, int f) {
	dep[u] = dep[f] + 1, fa[u] = f, size[u] = 1;
	for (int i = head[u], v; i; i = e[i].nxt) {
		v = e[i].v;
		if (v == f) continue;
		dfs1(v, u);
		tv[v] = e[i].w, size[u] += size[v];
		if (size[son[u]] < size[v]) son[u] = v;
	}
}

void dfs2(int u, int t) {
	top[u] = t, id[u] = ++cnt, rev[cnt] = u, val[cnt] = tv[u];
	if (son[u]) dfs2(son[u], t);
	for (int i = head[u], v; i; i = e[i].nxt) {
		v = e[i].v;
		if (v == fa[u] || v == son[u]) continue;
		dfs2(v, v);
	}
}

struct node {
	int l, r, sum;
} t[MAXN << 2];

inline 
void pushup(int p) {
	t[p].sum = t[p << 1].sum + t[p << 1 | 1].sum;
}

inline 
void build(int l, int r, int p) {
	t[p].l = l, t[p].r = r;
	if (l == r) return t[p].sum = val[l], void();
	int mid = l + r >> 1;
	build(l, mid, p << 1), build(mid + 1, r, p << 1 | 1);
	pushup(p);
}

inline 
void change(int x, int k, int p) {
	if (t[p].l == t[p].r) return t[p].sum = k, void(0);
	int mid = t[p].l + t[p].r >> 1;
	change(x, k, p << 1 | (x > mid));
	pushup(p);
}

inline 
int query(int l, int r, int p) {
	if (l <= t[p].l && t[p].r <= r) return t[p].sum;
	int mid = t[p].l + t[p].r >> 1, res = 0;
	if (l <= mid) res += query(l, r, p << 1);
	if (r > mid) res += query(l, r, p << 1 | 1);
	return res;
}

inline 
int sum(int x, int y) {
	int res = 0;
	while (top[x] != top[y]) {
		if (dep[top[x]] < dep[top[y]]) swap(x, y);
		res += query(id[top[x]], id[x], 1);
		x = fa[top[x]];
	}
	if (dep[x] > dep[y]) swap(x, y);
	if (x != y) res += query(id[x] + 1, id[y], 1);
	return res;
}

int f[MAXN];

int find(int k) {
	return k == f[k] ? k : f[k] = find(f[k]);
}

bool merge(int x, int y) {
	return (x = find(x)) ^ (y = find(y)) ? f[x] = y : 0; 
}

int n, m, p;

int u[MAXN], v[MAXN], w[MAXN];

int opt, x, y;

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) f[i] = i;
	for (int i = 1; i <= n; i++) {
		scanf("%d%d%d", &u[i], &v[i], &w[i]);
		if (!p && !merge(u[i], v[i])) p = i;
		else add(u[i], v[i], w[i]), add(v[i], u[i], w[i]);
	}	
	dfs1(1, 0), dfs2(1, 1), build(1, n, 1);
	while (m--) {
		scanf("%d%d%d", &opt, &x, &y);
		if (opt == 1) {
			if (x == p) w[p] = y;
			else change(id[dep[u[x]] > dep[v[x]] ? u[x] : v[x]], y, 1);
		} else printf("%d\n", min({ sum(x, y), sum(x, u[p]) + sum(v[p], y) + w[p], sum(x, v[p]) + sum(u[p], y) + w[p] }));
	}
}
```

---

## 作者：letitdown (赞：0)

题目很简洁了，支持基环树上修改边权和查询两点最短距离。

我们可以试着断开一条在环上的边，对于这条边单独维护权值，剩下的就可以简单树剖处理了。

我把这条边叫做“禁边”。

我们先拓扑排序求出所有在环上的点，就是最后度数多于1的点，然后随便找出一条两端都在环上的边当做禁边，再随便找出一个在环上的点当做树根。

修改：

当修改的是禁边时，我们直接进行赋值，否则就是老套路，把边权转化成这条边两端深度较小的点的点权，在数据结构上修改边权就是看这条边两端哪个点深度较大，单点加上当前给出的边权和原来这个点的权值的差值。

查询：

我们设 $rt_i$ 表示 $i$ 点祖先中第一个在环上的点，这个可以在拓扑时顺便求出。

当查询的两个点的 $rt$ 相同时，直接进行树剖查询即可。

否则我们分最短路经过禁边和不经过禁边进行讨论：

如果不经过禁边，那么两点的距离就是它们到自己 $rt$ 的距离加上这两个 $rt$ 之间的距离，否则就是它们到自己 $rt$ 的距离加上整个环的长度减去这两个 $rt$ 之间的距离，前者很好求，分三部分树剖，后者中的“整个环的长度减去这两个 $rt$ 之间的距离”可以转化成禁边两个端点在树上的距离减去减去这两个 $rt$ 之间的距离再加上禁边长度。两者取最小值即可。

最近树剖套线段树被卡常自闭了，所以这里用的是树状数组，常数极小，跑到了最优解第一个，比第二名快了一倍qwq

## Code
```cpp
#include<cstring>
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
namespace EMT{
	typedef long long ll;typedef double db;//(double)clock() / (double)CLOCKS_PER_SEC;
	#define pf printf
	#define F(i,a,b) for(int i=a;i<=b;i++)
	#define D(i,a,b) for(int i=a;i>=b;i--)
	inline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
	inline void file(){auto it=freopen("in.in","r",stdin);it=freopen("my.out","w",stdout);it++;}
	inline int max(int a,int b){return a>b?a:b;}inline int min(int a,int b){return a<b?a:b;}
	inline void pi(int x){pf("%d ",x);}inline void pn(){pf("\n");}
	const int N=1e5+10;
	int top[N],dfn[N],ti,siz[N],son[N],fa[N],n,m,in[N],co=1,head[N],rt[N],ban,deep[N],val[N],Rt,vv;
	struct node{int next,to,w;}e[N<<1];
	inline void add(int next,int to,int w){e[++co]=(node){head[next],to,w},head[next]=co;}
	inline void toposort(){
		static int q[N],hd=1,tl;
		F(i,1,n)if(in[i]==1)q[++tl]=i;
		while(hd<=tl){
			int x=q[hd++];
			for(int i=head[x];i;i=e[i].next){
				int j=e[i].to;
				if(in[j]>1){
					in[j]--;
					if(in[j]==1)q[++tl]=j;
				}
			}
		}
		F(i,1,n)if(in[i]>1)rt[i]=i;
		F(i,1,n)if(rt[i]==i){
			q[hd=tl=1]=i;
			while(hd<=tl){
				int x=q[hd++];
				for(int I=head[x];I;I=e[I].next){
					int j=e[I].to;if(rt[j])continue;
					rt[j]=rt[x];q[++tl]=j;
				}
			}
			if(!ban){
				for(int I=head[i];I;I=e[I].next){
					int j=e[I].to;if(rt[j]==j){
						ban=I;break;
					}
				}
			}if(!Rt)Rt=i;
		}
	}
	inline void dfs1(int k,int f){
		siz[k]=1;
		for(int i=head[k],j;i;i=e[i].next)if((j=e[i].to)!=f&&i!=ban&&i!=(ban^1)){
			fa[j]=k,deep[j]=deep[k]+1,val[j]=e[i].w;
			dfs1(j,k);siz[k]+=siz[j];
			if(siz[son[k]]<siz[j])son[k]=j;
		}
	}
	inline void dfs2(int k,int tp){
		top[k]=tp;dfn[k]=++ti;
		if(!son[k])return;
		dfs2(son[k],tp);
		for(int i=head[k];i;i=e[i].next)if(e[i].to!=fa[k]&&e[i].to!=son[k]&&i!=ban&&i!=(ban^1))dfs2(e[i].to,e[i].to);
	}
	struct BIT{
		int t[N];
		inline void add(int x,int v){while(x<=n)t[x]+=v,x+=x&-x;}
		inline int ask(int x){int ans=0;while(x)ans+=t[x],x-=x&-x;return ans;}
		inline int ask(int l,int r){return ask(r)-ask(l-1);}
	}bit;
	inline int ask(int x,int y){
		int ans=0;
		while(top[x]!=top[y])if(deep[top[x]]>=deep[top[y]])ans+=bit.ask(dfn[top[x]],dfn[x]),x=fa[top[x]];
		else ans+=bit.ask(dfn[top[y]],dfn[y]),y=fa[top[y]];
		if(deep[x]<=deep[y])ans+=bit.ask(dfn[x]+1,dfn[y]);
		else ans+=bit.ask(dfn[y]+1,dfn[x]);
		return ans;
	}
	inline short main(){
		// file();
		n=read(),m=read();
		F(i,1,n){int x=read(),y=read(),z=read();in[x]++,in[y]++;add(x,y,z),add(y,x,z);}
		toposort();
		dfs1(Rt,0);dfs2(Rt,Rt);
		F(i,1,n)bit.add(dfn[i],val[i]);
		vv=ask(e[ban].to,e[ban^1].to);
		while(m--){
			int opt=read();
			if(opt==1){
				int x=read(),y=read();
				if(x*2==ban||x*2==(ban^1)){
					e[ban].w=y;
				}else{
					int id=x*2;
					if(deep[e[id].to]<deep[e[id^1].to])id^=1;
					bit.add(dfn[e[id].to],y-val[e[id].to]),val[e[id].to]=y;
					if(rt[e[id].to]==e[id].to&&rt[e[id^1].to]==e[id^1].to)vv=ask(e[ban].to,e[ban^1].to);
				}
			}else{
				int x=read(),y=read();
				if(rt[x]==rt[y])pi(ask(x,y)),pn();
				else{
					int base=ask(x,rt[x])+ask(y,rt[y]);
					int v1=ask(rt[x],rt[y]),v2=vv-v1+e[ban].w;
					pi(base+min(v1,v2)),pn();
				}
			}
		}
		return 0;
	}
}
signed main(){return EMT::main();}
```

---

## 作者：miao5 (赞：0)

### 大意

给出 $n$ 个点 $n$ 条边的图，让你求 $x$ 到 $y$ 的最短距离，其中还包括修改边的边权。

读完题以后可以得知这是一颗树加上一条边。

### 思路

我们可以记录下来多出来的那条边，那如何找呢？

用并查集！

```
if(gett(u)!=gett(v)){
	merge(u,v);
	add(u,v,w);
	add(v,u,w);
}
else{
	u1=u;
	v1=v;
	w1=w;
	id=i;
	cnt+=2;
}//并查集找到多出来的边。 
```

然后考虑剩下的部分，剩下的部分就是一颗树。

如果只有一棵树的话，那这就是树刨的模板题。

那如果加上多出来的那条边呢？

那就有三种情况。

1.  直接走树边 $x$ 到 $y$ 。

2.  从 $x$ 走到多出来的边的起点 $u_1$，加上多出来的边的长度  $w_1$，再从多出来的边的终点 $v_1$ 走到  $y$ 。

2.  从 $x$ 走到多出来的边的终点 $v_1$，加上多出来的边的长度  $w_1$，再从多出来的边的起点 $u_1$ 走到  $y$ 。

之后要注意把边权下放为点权。

另一个操作也是模板。


code:

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define lc(p) p<<1
#define rc(p) p<<1|1
using namespace std;
const int MAXN=1e5+10;
int n,m;
int f[MAXN];
int gett(int a){
	if(f[a]==a) return a;
	return f[a]=gett(f[a]);
} 
void merge(int x,int y){
	f[gett(x)]=gett(y);
}//并查集 
struct Edge{
	int u,v,w,nxt;
} e[MAXN<<1];
int cnt;
int head[MAXN];
void add(int u,int v,int w){
	e[++cnt].u=u;
	e[cnt].v=v;
	e[cnt].w=w;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}//链式前向星 
int dep[MAXN],fa[MAXN];
int siz[MAXN],son[MAXN];
int val[MAXN],wt[MAXN];
void dfs1(int u,int father){
	dep[u]=dep[father]+1;
	fa[u]=father;
	siz[u]=1;
	int maxs=0;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].v;
		int w=e[i].w;
		if(v!=father){
			dfs1(v,u);
			siz[u]+=siz[v];
			val[v]=w;
			if(siz[v]>maxs){
				son[u]=v;
				maxs=siz[v];
			}
		}
	}
}
int top[MAXN],num[MAXN];
void dfs2(int u,int topf){
	top[u]=topf;
	num[u]=++cnt;
	wt[cnt]=val[u];
	if(!son[u]) return;
	dfs2(son[u],topf);
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].v;
		if(v!=fa[u]&&v!=son[u]){
			dfs2(v,v);
		}
	}
}//树刨处理dfs序 
int sum[MAXN<<2];
void pushup(int p){
	sum[p]=sum[lc(p)]+sum[rc(p)];
}
void build(int p,int l,int r){
	if(l==r){
		sum[p]=wt[l];
		return;
	}
	int mid=(l+r)>>1;
	build(lc(p),l,mid);
	build(rc(p),mid+1,r);
	pushup(p);
}
void update(int p,int l,int r,int x,int d){
	if(l==r){
		sum[p]=d;
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid) update(lc(p),l,mid,x,d);
	else update(rc(p),mid+1,r,x,d);
	pushup(p);
}
int query(int p,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr) return sum[p];
	int mid=(l+r)>>1;
	int ans=0;
	if(ql<=mid) ans+=query(lc(p),l,mid,ql,qr);
	if(mid<qr) ans+=query(rc(p),mid+1,r,ql,qr); 
	return ans;
}//树刨模板 
void opt1(int x,int y){
	x<<=1;
	int u=e[x].u;
	int v=e[x].v;
	if(dep[u]>dep[v]) swap(u,v);
	update(1,1,n,num[v],y);
}//修改 
int opt2(int x,int y){
	int ans=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		ans+=query(1,1,n,num[top[x]],num[x]);//记录 
		x=fa[top[x]];
	}
	if(x==y) return ans;
	if(dep[x]>dep[y]) swap(x,y);
	ans+=query(1,1,n,num[x]+1,num[y]);//记录 
	return ans;
}//求值 
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) f[i]=i;
    int u1,v1,w1,id;
	for(int i=1;i<=n;i++){
		int u,v,w;
		cin>>u>>v>>w;
		if(gett(u)!=gett(v)){
			merge(u,v);
			add(u,v,w);
			add(v,u,w);
		}//初始化 
		else{
			u1=u;
			v1=v;
			w1=w;
			id=i;
			cnt+=2;
		}//并查集找到多出来的边。 
	}
	dfs1(1,0);
	cnt=0;
	dfs2(1,1);
	build(1,1,n);//初始化 
	while(m--){
		int opt;
		cin>>opt;
		int x,y;
		cin>>x>>y;
		if(opt==1){
			if(x==id) w1=y;
			else opt1(x,y);
		}//修改 
		else{
			int ans=opt2(x,y);
			ans=min(ans,opt2(x,u1)+w1+opt2(v1,y));
			ans=min(ans,opt2(x,v1)+w1+opt2(u1,y));
			cout<<ans<<endl;
		}//取三种答案的最小值，输出。 
	}
}
```


---

## 作者：JK_LOVER (赞：0)

## 题意
一颗带权的有边权的有 $n$ 个点 $n$ 条边的图。求问两点之间的最短路。支持单点修改。
## 分析
如果是 $n$ 个点 $n-1$ 条边 ，而且不用单点修改。可以用树上距离 $O(\log n)$ 求解。
$$
ans = dis[x] + dis[y] -2\times dis[lca(x,y)]
$$
考虑是如果是 $n$ 个点 $n-1$ 条边 ，支持单点修改。可以用 $LCT$   $O(\log n)$ ，或者树链剖分 $O(\log^2 n)$ 求解，考虑边权由儿子点映射。
$$
ans = \sum_{i\in U ,i \ne lca}^n val[i] 
$$
如果 $n$ 个点 $n$ 条边 ，支持单点修改。这个树上简单路径最多也只会多一条。直接单独考虑第 $n$ 条边。
$$
ans = \min(dis(x,y),dis(x,A)+dis(B,y)+C,dis(x,B)+dis(A,y)+C)
$$
这样就会把所有状况全部考虑。因为没有 $LCT$ 的题解，这里说说一下拆边成点的方法，具体就见代码了。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
    int sum=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){sum=sum*10+ch-'0';ch=getchar();}
    return sum*f;
}
const int N = 2001001;
int n,Q;
int c[N][2],f[N],val[N],sum[N],Fa[N],A,B,C,D;
bool r[N];
int find(int x)
{
	return Fa[x] == x?x:Fa[x] = find(Fa[x]);
}
bool nroot(int x)
{
	return c[f[x]][1] == x || c[f[x]][0] == x;	
} 
void pushr(int x)
{
	swap(c[x][1],c[x][0]);
	r[x]^=1;
}
void pushup(int x)
{
	if(x > n) sum[x] = val[x];
	else sum[x] = 0;
	if(c[x][1]) sum[x] += sum[c[x][1]];
	if(c[x][0]) sum[x] += sum[c[x][0]];
}
void pushdown(int x)
{
	if(r[x])
	{
		if(c[x][1]) pushr(c[x][1]);
		if(c[x][0]) pushr(c[x][0]);
		r[x] = 0;
	}
}
void rotate(int x)
{
	int y = f[x],z = f[y],k = c[y][1] == x,w = c[x][!k];
	if(nroot(y)){c[z][c[z][1] == y] = x;}
	c[y][k] = w;c[x][!k] = y;
	f[x] = z;f[y] = x;f[w] = y;
	pushup(y);
}
void push(int x)
{
	if(nroot(x)) push(f[x]);
	pushdown(x);
}
void splay(int x)
{
	push(x);
	while(nroot(x))
	{
		int y = f[x],z = f[y];
		if(nroot(y))
		{
			rotate((c[y][1] == x)^(c[z][1] == y)?x:y);
		}
		rotate(x);
		pushup(x);
	}
}
void access(int x)
{
	for(int y = 0;x;x=f[y=x])
	{splay(x);c[x][1] = y;pushup(x);}
}
void makeroot(int x)
{
	access(x);splay(x);pushr(x);
}
void split(int x,int y)
{
	makeroot(x);access(y);splay(y);
}
void link(int x,int y)
{
	split(x,y);f[x] = y;
}
void work(int &ans,int x,int y,int X,int Y)
{
	split(x,y);
	int ans1 = sum[y];
	split(X,Y);
	ans1 += sum[Y];
	ans1 += C;
	ans = min(ans,ans1); 
}
int main()
{
	n = read();Q = read();
	for(int i = 1;i <= n;i++) Fa[i] = i;
	for(int i = 1;i <= n;i++)
	{
		int x = read(),y = read(),z = read();
		int fx = find(x),fy = find(y);
		if(fx == fy)
		{
			A = x;B = y;C = z;D = i+n;
			continue;
		}
		Fa[fx] = fy;
		link(x,i+n);
		link(i+n,y);
		val[i+n] = z;
	}
	while(Q--)
	{
		int opt = read(),a = read(),b = read();
		if(opt == 1)
		{
			if(a+n == D)
			{
				C = b;
				continue;
			}
			makeroot(a+n);
			val[a+n] = b;
			continue;
		}
		split(a,b);
		int ans1 = sum[b];
		work(ans1,a,A,B,b);
		work(ans1,a,B,A,b);
		printf("%d\n",ans1);
	}
}
```


[地址](https://www.luogu.com.cn/blog/xzc/solution-p4949)

---

## 作者：lemondinosaur (赞：0)

# 题目大意
给出一个基环树，支持修改边权和查询两点间最短距离

---
# 分析
如果是一棵树那就很简单了，树链剖分，将边权变成子节点的点权，

然后因为只有单边修改，所以可以用常数比较小的树状数组；

但是这是一棵基环树，考虑将环上的一条边拎出来，对其它边用树的方法做$x->y$，

这条边特判，也就是$x->zx->zy->y$或者$x->zy->zx->y$，一共三种情况求最小值，注意查询时的区间边界

---
# 代码
```cpp
#include <cstdio>
#include <cctype>
#define rr register
using namespace std;
const int N=100011; struct node{int y,w,next;}e[N<<1];
int c[N],a[N],dep[N],dfn[N],top[N],f[N];
int fat[N],big[N],son[N],ls[N],tot,n,m,K=1,zx,zy,zw,zp;
inline signed iut(){
	rr int ans=0; rr char c=getchar();
	while (!isdigit(c)) c=getchar();
	while (isdigit(c)) ans=(ans<<3)+(ans<<1)+(c^48),c=getchar();
	return ans;
}
inline void print(int ans){
	if (ans>9) print(ans/10);
	putchar(ans%10+48);
}
inline void add(int x,int y){for (;x<=n;x+=-x&x) c[x]+=y;}
inline signed query(int x){rr int ans=0; for (;x;x-=-x&x) ans+=c[x]; return ans;}
inline signed getf(int u){return f[u]==u?u:f[u]=getf(f[u]);}
inline signed Query(int x,int y){
	rr int ans=0;
	while (top[x]!=top[y]){
		if (dep[top[x]]<dep[top[y]]) x^=y,y^=x,x^=y;
		ans+=query(dfn[x])-query(dfn[top[x]]-1);
		x=fat[top[x]];
	}
	if (dep[x]>dep[y]) x^=y,y^=x,x^=y;
	return ans+=query(dfn[y])-query(dfn[x]);//[dfn[x]+1~dfn[y]]最上面的点权不算
}
inline void dfs1(int x,int fa,int W){
	dep[x]=dep[fa]+1,fat[x]=fa,son[x]=1,c[x]=W;
	for (rr int i=ls[x],mson=-1;i;i=e[i].next)
	if (e[i].y!=fa){
		dfs1(e[i].y,x,e[i].w);
		son[x]+=son[e[i].y];
		if (son[e[i].y]>mson) big[x]=e[i].y,mson=son[e[i].y];
	}
}
inline void dfs2(int x,int linp){
	dfn[x]=++tot,a[tot]=c[x],top[x]=linp;
	if (!big[x]) return; dfs2(big[x],linp);
	for (rr int i=ls[x];i;i=e[i].next)
	if (e[i].y!=fat[x]&&e[i].y!=big[x]) dfs2(e[i].y,e[i].y);
}
signed main(){
	n=iut(); m=iut();
	for (rr int i=1;i<=n;++i) f[i]=i;
	for (rr int i=1;i<=n;++i){
		rr int x=iut(),y=iut(),w=iut();
		rr int fa=getf(x),fb=getf(y);
		if (fa==fb) {zx=x,zy=y,zw=w,zp=i,K+=2; continue;}
		if (fa>fb) fa^=fb,fb^=fa,fa^=fb; f[fa]=fb;
		e[++K]=(node){y,w,ls[x]},ls[x]=K;
		e[++K]=(node){x,w,ls[y]},ls[y]=K;
	}
	dfs1(1,0,0),dfs2(1,1);
	for (rr int i=1;i<=n;++i) c[i]=c[i-1]+a[i];
	for (rr int i=n;i>=1;--i) c[i]-=c[i&(i-1)];//O(n)预处理树状数组
	for (rr int i=1;i<=m;++i){
		rr int op=iut(),x=iut(),y=iut();
		if (op==1){
			if (x==zp) zw=y;
			else{
				rr int xx=e[x<<1].y,yy=e[x<<1|1].y;
				if (dep[xx]<dep[yy]) xx^=yy,yy^=xx,xx^=yy;
				add(dfn[xx],y-a[dfn[xx]]),a[dfn[xx]]=y;
			}
		}else{
			rr int t1=Query(x,zx)+Query(y,zy);
			rr int t2=Query(x,zy)+Query(y,zx);
			rr int ans1=Query(x,y),ans2=(t1<t2?t1:t2)+zw;
			print(ans1<ans2?ans1:ans2),putchar(10);
		}
	}
	return 0;
}
```

---

## 作者：AThousandSuns (赞：0)

作为本题rk2来水一波题解……

本题是基环树，可以考虑断掉环上的一条边 $(uu,vv)$，那么 $(u,v)$ 的最短距离就是 $\min(dis(u,v),dis(u,uu)+dis(v,vv)+w,dis(u,vv)+dis(v,uu)+w)$。

（其中 $w$ 是断掉的边的边权，$dis(u,v)$ 表示 $u,v$ 两点在树上的距离）

而 $dis(u,v)=d_u+d_v-d_{lca}$。$d_u$ 表示从根到 $u$ 的距离。那么一次询问可以做到 $O(\log n)$。

考虑修改。如果修改的是断掉的边，直接修改 $w$ 即可。否则相当于把以 $v$ 为根的子树中所有的 $d$ 加一个数。

线段树？区间加，单点查询，直接树状数组即可。

于是时间复杂度 $O(q\log n)$，并且常数巨小。%%%rk1 Sooke爷%%%

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=100010;
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define ROF(i,a,b) for(int i=(a);i>=(b);i--)
#define MEM(x,v) memset(x,v,sizeof(x))
inline int read(){
	int x=0,f=0;char ch=getchar();
	while(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();
	while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
	return f?-x:x;
}
struct edge{
	int u,v,w,id;
}e[maxn];
int n,q,el=1,head[maxn],to[maxn*2],nxt[maxn*2],w[maxn*2],dep[maxn],fa[maxn],son[maxn],sz[maxn],top[maxn],dfn[maxn],dfs_clock,hid;
ll dis[maxn];
bool vis[maxn];
inline void add(int u,int v,int w_){
	to[++el]=v;nxt[el]=head[u];head[u]=el;w[el]=w_;
}
void dfs1(int u,int f){
	dfn[u]=++dfs_clock;
	dep[u]=dep[fa[u]=f]+1;
	sz[u]=1;
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];
		if(v==f) continue;
		if(vis[v]){hid=i>>1;continue;}
		vis[v]=true;
		e[i>>1].id=i;
		dis[v]=dis[u]+w[i];
		dfs1(v,u);
		sz[u]+=sz[v];
		if(sz[v]>sz[son[u]]) son[u]=v;
	}
}
void dfs2(int u,int topf){
	top[u]=topf;
	if(son[u]) dfs2(son[u],topf);
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];
		if(v==fa[u] || v==son[u] || u==e[hid].u && v==e[hid].v || u==e[hid].v && v==e[hid].u) continue;
		dfs2(v,v);
	}
}
int lca(int u,int v){
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]]) swap(u,v);
		u=fa[top[u]];
	}
	return dep[u]<dep[v]?u:v;
}
struct BIT{
	ll a[maxn];
	void update_(int p,ll x){
		for(int i=p;i<=n;i+=i&-i) a[i]+=x;
	}
	ll query(int p){
		ll s=0;
		for(int i=p;i;i-=i&-i) s+=a[i];
		return s;
	}
	void update(int l,int r,ll x){
		update_(l,x);update_(r+1,-x);
	}
}tr;
ll calc(int u,int v){
	return tr.query(dfn[u])+tr.query(dfn[v])-2*tr.query(dfn[lca(u,v)]);
}
int main(){
	n=read();q=read();
	FOR(i,1,n){
		int u=read(),v=read(),w=read();
		add(u,v,w);add(v,u,w);
		e[i]=(edge){u,v,w,0};
	}
	vis[1]=true;
	dfs1(1,0);dfs2(1,1);
	FOR(i,1,n) tr.update(dfn[i],dfn[i],dis[i]);
	while(q--){
		int op=read(),x=read(),y=read();
		if(op==2) printf("%lld\n",min(min(calc(x,y),calc(x,e[hid].u)+e[hid].w+calc(y,e[hid].v)),calc(x,e[hid].v)+e[hid].w+calc(y,e[hid].u)));
		else{
			if(x==hid) e[hid].w=y;
			else{
				int dy=y-e[x].w;
				e[x].w=y;
				tr.update(dfn[to[e[x].id]],dfn[to[e[x].id]]+sz[to[e[x].id]]-1,dy);
			}
		}
	}
}
```

---

## 作者：cold_cold (赞：0)

[安利一波博客](https://www.cnblogs.com/cold-cold/p/10049804.html)

此题是一道基环树上树链剖分题目

思路是这样的：基环树其实可以看做一棵树多连了一条边，于是我们可以通过加边时维护一个并查集，来找出多的那条边。

将那条多出的边记录下来。

然后我们考虑u到v的最大值，有两种情况

&ensp;&ensp;&ensp;1. u直接在树上到v

&ensp;&ensp;&ensp;2. u，v到多出的那条边的两端，通过这条边连在一起

与是我们就可以很愉快的在树上跑树链剖分了，注意此题是边权而不是点权

那我们对于u到v权值为w的一条边可以看做u->xx->v，u,v点权为0，xx点权为w，就可将边权转化为点权了，点数翻倍，记得数组大小翻倍哟

值得一提的是我一开始线段树的数组忘记开4倍了，结果又WA又TLE40分，搞得我还以为哪里写错了呢

实现如下：

```cpp
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>
#include <queue>
#define lson l,mid,o<<1
#define rson mid+1,r,o<<1|1
using namespace std;
typedef long long ll;
inline int read()
{
    int a=0,p=0;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if(ch=='-') p=1,ch=getchar();
    while(ch>='0'&&ch<='9') a=(a<<3)+(a<<1)+ch-'0',ch=getchar();
    return p?-a:a;
}
const int N=200100;
int n,q,op,u,v,w,cnt,sum[N<<2],head[N],top[N],fe[N],fa[N],id[N],dep[N],size[N],son[N],ww[N],wn[N],tim=0,t1,t2,keu,kev,kew,kex,xu;
int getf(int u){return fe[u]==u?u:fe[u]=getf(fe[u]);}
struct EDGE{int nxt,to;}e[N<<1];
void add(int u,int v){e[++cnt]=(EDGE){head[u],v};head[u]=cnt;}
void build(int l,int r,int o)
{
    if(l==r){sum[o]=wn[l];return;}
    int mid=(l+r)>>1;
    build(lson);build(rson);
    sum[o]=sum[o<<1]+sum[o<<1|1];
}
void update(int pre,int val,int l,int r,int o)
{
    if(l==r){sum[o]=val;return;}
    int mid=(l+r)>>1;
    if(pre<=mid) update(pre,val,lson);
    else update(pre,val,rson);
    sum[o]=sum[o<<1]+sum[o<<1|1];
}
int query(int L,int R,int l,int r,int o)
{
    if(L<=l&&r<=R) return sum[o];
    int mid=(l+r)>>1,ans=0;
    if(L<=mid) ans+=query(L,R,lson);
    if(R> mid) ans+=query(L,R,rson);
    return ans;
}
int query_tree(int u,int v)
{
    int ans=0;
    while(top[u]!=top[v])
    {
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        ans+=query(id[top[u]],id[u],1,n,1);
        u=fa[top[u]];
    }
    if(dep[u]>dep[v]) swap(u,v);
    return ans+query(id[u],id[v],1,n,1);
}
void dfs1(int u,int ff)
{
    fa[u]=ff;dep[u]=dep[ff]+1;size[u]=1;
    int maxson=0;
    for(int i=head[u],v=e[i].to;i;i=e[i].nxt,v=e[i].to) if(v!=ff)
    {
        dfs1(v,u);
        size[u]+=size[v];
        if(size[v]>maxson) maxson=size[v],son[u]=v;
    }
}
void dfs2(int u,int topf)
{
    id[u]=++tim;top[u]=topf;wn[tim]=ww[u];
    if(!son[u]) return;
    dfs2(son[u],topf);
    for(int i=head[u],v=e[i].to;i;i=e[i].nxt,v=e[i].to) if(v!=fa[u]&&v!=son[u])
        dfs2(v,v);
}
int main()
{
//    freopen("input","r",stdin);
//    freopen("output","w",stdout);
    xu=n=read(),q=read();
    for(int i=1;i<=n;i++) fe[i]=i;
    for(int i=1;i<=n;i++)
    {
        u=read(),v=read(),w=read();
        t1=getf(u),t2=getf(v);
        if(t1!=t2)
        {
            fe[t1]=t2;xu=n+i;ww[xu]=w;
            add(u,xu);add(xu,u);
            add(v,xu);add(xu,v);
        }
        else {keu=u;kev=v;kew=w;kex=i;}
    }
    n<<=1;
    dfs1(1,1);dfs2(1,1);build(1,n,1);
    int ans=0;
    while(q--)
    {
        op=read(),u=read(),v=read();
        if(op==1)
		{
			if(u==kex) kew=v;
			else update(id[u+(n>>1)],v,1,n,1);
		}
        else
        {
            ans=query_tree(u,v);
            printf("%d\n",min(ans,kew+min(query_tree(u,keu)+query_tree(v,kev),query_tree(u,kev)+query_tree(v,keu))));
        }
    }
    return 0;
}
/*
9 4
1 2 2
2 3 9
3 4 7
3 5 1
1 6 7
6 7 1
4 8 9
6 9 8
8 9 2
1 9 3
1 1 5
2 9 7
2 4 5
*/
```

---

## 作者：ModestCoder_ (赞：0)

基环树，不是特别的复杂

如果先把一条多余的边拿掉，然后对于每个询问

 - 最短路径不经过多余边，直接树上求两点间距离
 - 最短路径经过多余边，树上求多余边两端点分别到两个询问点的距离，加上多余边长度

两种情况比大小即可

至于如何求得树上两点间距离，因为有修改操作无法直接倍增解决

所以用上树剖，然后距离可以用常数更小的树状数组维护一下

注意这里用以点代边，细节处理需注意

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 100010
using namespace std;
struct Edge{
	int to, next, len;
}edge[maxn << 1];
struct Line{
	int x, y, z;
}line[maxn << 1];
int num, head[maxn], size[maxn], son[maxn], fa[maxn], d[maxn], val[maxn], id[maxn], top[maxn];
int Index, U, V, Len, n, m, tree[maxn];
inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
} 

void addedge(int x, int y, int z){ edge[++num] = (Edge) {y, head[x], z}; head[x] = num; }

void dfs(int u){
	size[u] = 1, son[u] = -1;
	for (int i = head[u]; i; i = edge[i].next){
		int v = edge[i].to;
		if (!size[v]){
			fa[v] = u, d[v] = d[u] + 1, val[v] = edge[i].len;
			dfs(v);
			size[u] += size[v];
			if (son[u] == -1 || son[u] != -1 && size[son[u]] < size[v]) son[u] = v;	
		} else
		if (v != fa[u]) U = u, V = v, Len = edge[i].len;
	}
}

void dfs(int u, int x){
	top[u] = x, id[u] = ++Index;
	if (son[u] == -1) return;
	dfs(son[u], x);
	for (int i = head[u]; i; i = edge[i].next){
		int v = edge[i].to;
		if (v != son[u] && v != fa[u] && !(u == U && v == V) && !(u == V && v == U)) dfs(v, v);
	}
}

void add(int x, int y){ for (; x <= n; x += x & -x) tree[x] += y; }
int query(int x){ int sum = 0; for (; x; x -= x & -x) sum += tree[x]; return sum; }

int qrylen(int u, int v){
	int sum = 0;
	while (top[u] != top[v]){
		if (d[top[u]] < d[top[v]]) swap(u, v);
		sum += query(id[u]) - query(id[top[u]] - 1);
		u = fa[top[u]];
	}
	if (u == v) return sum;
	if (d[u] < d[v]) swap(u, v);
	return sum + query(id[u]) - query(id[v]);
}

int main(){
	n = read(), m = read();
	for (int i = 1; i <= n; ++i){
		line[i] = (Line){read(), read(), read()};
		addedge(line[i].x, line[i].y, line[i].z);
		addedge(line[i].y, line[i].x, line[i].z);
	}
	dfs(1); dfs(1, 1);
	for (int i = 1; i <= n; ++i) add(id[i], val[i]);
	while (m--){
		int opt = read(), x = read(), y = read();
		if (opt == 1){
			int u = line[x].x, v = line[x].y;
			if (u == U && v == V || u == V && v == U) Len = y; else{
				if (d[u] < d[v]) swap(u, v);
				add(id[u], y - line[x].z);
				line[x].z = y;
			}
		} else{
			int sum = qrylen(x, y),
				sum1 = qrylen(x, U) + qrylen(y, V) + Len,
				sum2 = qrylen(x, V) + qrylen(y, U) + Len;
			printf("%d\n", min(sum, min(sum1, sum2)));
		}
	}
	return 0;
}
```


---


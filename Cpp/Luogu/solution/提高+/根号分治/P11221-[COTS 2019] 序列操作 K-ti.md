# [COTS 2019] 序列操作 K-ti

## 题目背景

译自 [Izborne Pripreme 2019 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2019/) D1T1。$\texttt{2s,0.5G}$。


## 题目描述

给定长度为 $N$ 的正整数序列 $a_0,a_1,\cdots,a_{N-1}$ 和正整数 $k$。注意是 $\texttt{0-index}$。

进行 $N$ 次操作，将 $a$ 删空。对于每次操作：

- 设当前 $a$ 的长度为 $n$。
- 令 $S=\{0,k,2k,\cdots,k\lfloor\frac{n-1}{k}\rfloor\}$。找到 $v=\max_{i\in S}a_i$。
- 令 $p$ 为 $\min_{i\in S,a_i=v} i$。
- 删去 $a_p$。后面的元素顺次前移一位。

求出每次操作删去的数。

## 说明/提示




对于 $100\%$ 的数据，保证：

- $2\le k\le N\le 10^5$；
- $1\le a_i\le N$。


| 子任务编号 | $N\le $ |  $k$   | 得分 |  
| :--: | :--: | :--: | :--: |  
| $ 1 $    | $ 1\, 000 $    |  $\le N$  | $ 7 $   |  
| $ 2 $    | $ 10^5 $   |  $=2$ | $ 25 $   |  
| $ 3 $    | $ 10^5$ | $\le 10$ | $ 23 $   |  
| $ 4 $    | $ 10^5$ | $\ge 100$ | $ 25 $   |  
| $ 5 $    | $ 10^5$  |  $\le N$ | $ 20 $   |  


## 样例 #1

### 输入

```
10 2
2 3 1 9 10 4 5 6 1 5```

### 输出

```
10
6
4
5
2
9
3
5
1
1```

## 样例 #2

### 输入

```
10 3
2 3 1 9 10 4 5 6 1 5```

### 输出

```
9
10
4
5
6
2
5
3
1
1```

# 题解

## 作者：suzhikz (赞：2)

分块比较板子的题目。

每个块内维护每个下标对 $k$ 取模后每种下标的最大值。

询问的时候维护下扫过的数字个数 $cnt$，然后在下一个块查询下标取模后为 $(k-(cnt \bmod k)\bmod k)$ 的位置。

删除就是把询问再做一遍然后找到第一个有这个数的块，然后删除后再暴力重构。


```cpp
//我永远喜欢艾莉丝!
#include<iostream>
#include<algorithm>
#include<cmath>
#include<iomanip>
#include<cstdio>
#include<string>
#include<deque>
#include<stack>
#include<queue>
#include<vector>
#include<stdio.h>
#include<map>
#include<set>
#include<string.h>
#include<random>
#include<time.h>
#include<stdlib.h>
#include<bitset>
#define il inline
#define reg register
#define ll long long
#define popcount __builtin_popcount
using namespace std;
//#define int __int128
inline void read(int &n){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}n=x*f;}
inline void read(ll &n){ll x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}n=x*f;}
const int N=1e5+5,B=405;
int n,k,a[N];
struct node{
	int m,l[B+10],r[B+10],w[B+10],maxx[B+10],siz;
	void init(vector<int>g){
		m=siz=g.size();
		r[0]=1;l[m+1]=m;
		for(int i=0;i<m;i++){
			w[i+1]=g[i];l[i+1]=i;r[i+1]=i+2;
			maxx[i%k]=max(maxx[i%k],g[i]);
		}
	}
	int find(int x){
		if(x>B)return 0;else return maxx[x];
	}
	void del(int ma,int mb){
		int u=0;
		int cnt=0;
		for(int i=r[0];i<=m&&i>0;i=r[i]){
			if(cnt%k==mb&&w[i]==ma){
				u=i;break;
			}
			cnt++;
		}
		memset(maxx,0,sizeof(maxx));siz--;
		r[l[u]]=r[u];l[r[u]]=l[u];
		cnt=0;
//		cout<<ma<<' '<<u<<endl;
		for(int i=r[0];i<=m&&i>0;i=r[i]){
//			cout<<w[i]<<' ';
			maxx[cnt%k]=max(maxx[cnt%k],w[i]);
			cnt++;
		}
	}
}b[405];int tot;

int main(){
	read(n);read(k);
	for(int i=1;i<=n;i++)read(a[i]);
	for(int i=1;i<=(n-1)/B+1;i++){
		int l=(i-1)*B+1,r=min(n,i*B);
		vector<int>tmp;
		for(int j=l;j<=r;j++){
			tmp.push_back(a[j]);
		}
		tot++;b[tot].init(tmp);
	}
	for(int i=1;i<=n;i++){
		int cnt=0,maxx=0,cnt2;
		for(int j=1;j<=tot;j++){
			maxx=max(maxx,b[j].find((k-cnt%k)%k));
			cnt+=b[j].siz;
		}
		cnt=0;
//		cout<<pos<<' ';
		cout<<maxx<<endl;
		for(int j=1;j<=tot;j++){
			if(b[j].find((k-cnt%k)%k)==maxx){
				b[j].del(maxx,(k-cnt%k)%k); break;
			}else{
				cnt+=b[j].siz;
			}
		}
//		cout<<endl;
	} 
	
	
	return 0;
}

```

---

## 作者：Reobrok_Kk (赞：1)

原本想练根号分治的，结果做了一个分块做法。看了一遍题解区，发现没有纯分块做法，来发一个。

简要题意是给一个数组 $a_0,a_1,\dots,a_{n-1}$。进行 $n$ 次删除操作，每次取下标为 $k$ 的倍数的位置（包括 $0$）的最大值删除，如果有重复的取靠前的删。问每次删除的数。

考虑分块。将数组分成 $\sqrt n$ 块，将块内的数按 $1,2,\dots,k-1,0,1,\dots$ 划分成不同组。组数是 $\min (k,块长)$ 的，可以发现每次统计最大值只会取块内一组，于是我们每块每组分别统计最大值及其出现的位置。

删除时考虑扫一遍所有块，记录一个 $lst$ 表示距离上一个位置为 $k$ 的倍数的距离。因为该题从 $0$ 开始取下标，所以 $lst$ 初始化为 $k-1$。

每扫到一个块判断块内是否有全局第 $k$ 倍数的位置。具体的，就是判断 $k$ 是否 $\leq$ 块内剩余数字的数量加上 $lst$。若有，则统计第 $(k - lst) \mod k$ 组。扫完一个块就更新一遍 $lst$。

统计完成，输出答案。然后将删除位置标记为删除，将其所属的块进行重构。因为删除一个数，后面的数向前移，改变了分组。直接扫一遍块，遇到删除位置就跳过，否则标记为下一组。

统计删除位置扫一遍所有块复杂度为块数，删除后重构块复杂度是块长的。块长取 $\sqrt n$，总复杂度 $O(n\sqrt n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int a[N], n, k, siz = 386;
int id[N], mx[390][390], num[390][390], cnt[390], L[390];
bool vis[N];
signed main() {
    cin >> n >> k;
    memset(L, -1, sizeof L);
    for (int i = 0; i < n; ++ i) {
        cin >> a[i]; id[i] = i / siz + 1;
        cnt[id[i]] ++; if (L[id[i]] == -1) L[id[i]] = i;
        if (mx[id[i]][(i - L[id[i]] + 1) % k] < a[i]) mx[id[i]][(i - L[id[i]] + 1) % k] = a[i], num[id[i]][(i - L[id[i]] + 1) % k] = i;
    }
    int t = n, m = id[n - 1];
    while (t --) {
        int lst = k - 1, maxx = 0, nvm = -1;
        for (int i = 1, tmp; i <= m; ++ i) {
            tmp = (k - lst) % k;
            if (lst + cnt[i] >= k && maxx < mx[i][tmp]) maxx = mx[i][tmp], nvm = num[i][tmp];
            (lst += cnt[i]) %= k;
        }
        cout << maxx << '\n';
        vis[nvm] = 1; int ct = 0; cnt[id[nvm]] --;
        for (int i = 0; i < siz; ++ i) mx[id[nvm]][i] = 0;
        for (int i = L[id[nvm]]; id[i] == id[nvm]; ++ i) {
            if (vis[i]) continue;
            (ct += 1) %= k;
            if (mx[id[nvm]][ct] < a[i]) mx[id[nvm]][ct] = a[i], num[id[nvm]][ct] = i;
        }
    }
}
```

---

## 作者：McIron233 (赞：1)

部分分提示性很强，子任务三和子任务四已经提示我们正解复杂度应该和根号有关，考虑使用根号分治。

如果 $k$ 很大，可以将序列分成 $m = \lceil \dfrac{n}{k} \rceil$ 块，每次操作时查询每一块第一个元素的最大值以及首次出现该最大值的位置。删除时，设被删除的位置是 $p$，那么第 $p$ 块删除第一个元素，$p$ 之前的块不作操作，$p$ 之后的每一块都将自己的第一个元素转移至前一块的末尾。这一部分的时间复杂度是 $O(n^2 \cdot k^{-1})$。

如果 $k$ 很小，可以使用类似[锦标赛排序](https://oi-wiki.org/basic/tournament-sort/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)的思路，创建一棵满二叉树，每个结点维护一个序列 $X_i$ 表示管辖的区间范围内所有符合下标是 $i$ 倍数的最大值以及其第一次出现的位置。对于求答案，直接取根节点信息。对于删除操作，由于元素位移，所以给所有二叉树结点加以维护一个偏移量并计算偏移量带来的影响即可。这部分的时间复杂度是 $O(nk \log n)$。

将这两个算法结合起来，总时间复杂度就是 $O(n^2 \cdot B^{-1}+nB \log n)$，考虑 $k$ 很小时的空间限制，根号分治的阈值 $B$ 取 $100$，实测可以通过测试。

---

## 作者：hgckythgcfhk (赞：0)

注意到数据范围 $10^5$，且时限 $2$ 秒，不像是很正常限制，大胆猜测时间复杂度带根号，于是根号分治。

考虑暴力怎么写，维护 $\lfloor \dfrac{n-1}{k}\rfloor$ 个指针，每次扫这些指针记录答案的位置，然后后移指针并删掉输出的数，发现可以用链表优化，时间复杂度 $O(\dfrac{n^2}{k})$，由于数据不大而且洛谷测评机很快，这个其实只有 $k=2$ 的时候没过，所以到这里其实就卡卡能过了。

现在考虑 $k$ 很小的时候怎么做，我们发现，所选的集合相当于下标对 $k$ 取模等于 $0$，取模这个操作前面对后面的贡献是可加的，所以可以对序列分块，每个块存一个数组 $ans$，$ans_i$ 表示当前块的下标在模 $k$ 意义下与 $i$ 同余的所有位置的答案的最大值，这里我们定义一样大的靠前的更大，再存当前块有多少个数，不过这个个数要对 $k$ 取模。

假设我们前面有 $now$ 个数，我们为了凑出 $k$ 的倍数，在当前块要选出第 $-now$ 个数，也就是 $ans_{k-1-now\bmod k}$，如果不够这么多数，我们可以先加上 $k$ 个 $0$，由于给定的是正整数，所以这样并不影响答案。

这个过程也是可加的，所以我们暴力重构当前块不会对其他块单独的贡献有任何影响，所以每次查完暴力重构就行。

时间复杂度 $O(n+n\sqrt{n})$，空间复杂度 $O(k\sqrt{n})$，由于我们可以根据上面的暴力处理出来所有 $k>2$ 的情况，所以这里 $k=2$，是个常数，所以空间是低于线性的，不过我们如果把 $k$ 取大点能更快一点，这里我取的 $10$。

```cpp
#include <bits/stdc++.h>
#define il inline
#define rg register
#define cit const rg unsigned
#define open ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)//,freopen("1.in","r",stdin),freopen("1.out","w",stdout)
#define int rg unsigned
#define void il void
#define vector basic_string
#define vint vector<unsigned>
#define Bool(a,n) bitset<n>a
#define cle(a) memset(a,0,sizeof a)
#define PP pop_back()
#define BK back()
#define SZ size()
unsigned n,k,a[N],nxt[N],pre[N];
struct solve1{
	void main(){
		for(int i=0;i<n;++i)nxt[i]=i+1,pre[i]=i-1;
		nxt[n]=0;pre[0]=n;
		vint b;for(int i=0;i*k<n;++i)b+=i*k;
		while(b.SZ){int pos=n;
			for(cit&i:b)if(a[i]>a[pos])pos=i;cout<<a[pos]<<'\n';
			nxt[pre[pos]]=nxt[pos],pre[nxt[pos]]=pre[pos];
			for(int i=0;i<b.SZ;++i)if(b[i]>=pos)b[i]=nxt[b[i]];
			while(b.SZ&&b.BK==n)b.PP;
		}
	}
};Bool(vis,N);constexpr unsigned Q=320;
struct A{unsigned ans[10],ed;
	void build(cit l,cit r){ed=~0;
		for(int i=0;i<Q;++i)ans[i]=n;
		for(int i=l;i<=r;++i)if(!vis[i]){++ed,ed==k?ed=0:0;
			if(a[ans[ed]]<a[i])ans[ed]=i;
		}
	}
}b[330];
struct solve2{
	void main(){int m=0;
		for(int l=0,r=Q-1;l<n;l+=Q,r+=Q)
			b[l/Q].build(l,min(r,n-1)),m=l/Q;
		for(int _=n;_;--_){int ans=n,now=0;
			for(int i=0;i<=m;now=(now+b[i].ed+1)%k,++i)
				if(a[ans]<a[b[i].ans[(k-now%k)%k]])ans=b[i].ans[(k-now%k)%k];
			cout<<a[ans]<<'\n';cit l=ans-ans%Q;
			vis[ans]=1,b[l/Q].build(l,min(l+Q-1,n-1));
		}
	}
};
void init(){
	
}
void solve(){cin>>n>>k;
	for(int i=0;i<n;++i)cin>>a[i];
	if(k<10){solve2 t;t.main();return;}
	solve1 t;t.main();
}signed main(){open;int t=1;//cin>>t;
	while(t--)solve();}
```
为过审，省略了部分用不到的宏定义，不保证一定没有多删，但程序的大体意思很明确。

---


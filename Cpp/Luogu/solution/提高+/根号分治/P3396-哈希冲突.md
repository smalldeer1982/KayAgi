# 哈希冲突

## 题目背景

众所周知，模数的 hash 会产生冲突。例如，如果模的数 $p=7$，那么 $4$ 和 $11$ 便冲突了。

## 题目描述

B 君对 hash 冲突很感兴趣。他会给出一个正整数序列 $\text{value}$。

自然，B 君会把这些数据存进 hash 池。$\text{value}_k$ 会被存进 $(k \bmod p)$ 这个池。这样就能造成很多冲突。


B 君会给定许多个 $p$ 和 $x$，询问在模 $p$ 时，$x$ 这个池内 **数的总和**。

另外，B 君会随时更改 $\text{value}_k$。每次更改立即生效。

保证 $1\leq p<n$。

## 说明/提示

#### 样例解释 

`A 2 1` 的答案是 `1+3+5+7+9=25`。

`A 3 1` 的答案是 `20+4+7+10=41`。

`A 5 0` 的答案是 `1+10=11`。

#### 数据规模

对于 $10\%$的数据，有 $n\leq 1000$，$m\leq 1000$。

对于 $60\%$ 的数据，有 $n\leq 100000$，$m\leq 100000$。

对于 $100\%$ 的数据，有 $n\leq 150000$，$m\leq 150000$。

保证所有数据合法，且 $1\leq \mathrm{value}_i \leq 1000$。

## 样例 #1

### 输入

```
10 5
1 2 3 4 5 6 7 8 9 10
A 2 1
C 1 20
A 3 1
C 5 1
A 5 0```

### 输出

```
25
41
11```

# 题解

## 作者：阮行止 (赞：192)

这是一道论文题。集训队论文《根号算法——不只是分块》。

首先，题目要我们求的东西，就是下面的代码：

```cpp
for(i=k;i<=n;i+=p)
    ans+=value[i];
```
即：从 k开始，每隔p个数取一个数，求它们的和。

这个算法的复杂度是$O(n^2)$的。

令答案为$ans[p][k]$，表示模数是p，余数是k.

那么，对于第i个数，如何处理它对ans的贡献呢？


```cpp
for(p=1;p<=n;p++) //枚举模数
    ans[p][i%p]+=value[i]; //处理对应的贡献
```

这样看上去很妙的样子，然而$O(n^2)$的预处理， $O(1)$询问，空间复杂度还是

$O(n^2)$的


所以我们很自然地想到：只处理$[1,\sqrt{n}]$以内的p

这样的话，令 $size=\sqrt{n}$，则可以这样预处理：


```cpp
for(p=1;p<=size;p++) //只枚举[1,size]中的
    ans[p][i%p]+=value[] //处理对应的贡献
```

于是预处理的复杂度降到了 $O(n\sqrt{n})$.

接着考虑询问。如果询问的p<size ，那显然可以$O(1)$给出回答。

如果p超过size，我们就暴力统计并回答。因为 $p>\sqrt{n}$，所以少于$\sqrt{n}$个数对答案有贡献。所以对于  $p>\sqrt{n}$，暴力统计的复杂度是 $O(\sqrt{n})$..

接着考虑修改。显然我们把p<size的值全都更新一遍就行。复杂度也是  $O(\sqrt{n})$.

```cpp
void change(int i,int v) //将value[i]改为v
    {
    for(p=1;p<=size;p++)
    ans[p][i%p]=ans[p][i%p]-value[i]+v; //更新答案
    value[i]=v; //更新value数组 
}
```

这样，我们就在$O((m+n)\sqrt{n})$.的时间内完成了任务


---

## 作者：暗ざ之殇 (赞：49)

## 美学暴力——根号算法
通过分块的标签找到了一个貌似不是分块的题目，不过学了个新算法，和大家分享一下吧$qwq$
### 题目大意
给你一个长度为 $n$ 的序列和 $m$ 个操作，每次操作有两种类型：

$1$. 询问下标模 $x$ 后为 $y$ 的所有数之和；

$2$. 修改第 $x$ 个数；

### 题解
先想想暴力怎么搞：

对于第 $1$ 种操作，我们可以 $O(n)$ 的枚举求和，对于第 $2$ 种操作，我们可以 $O(1)$ 修改；
```
    long long ans=0;
    for(int i=y;i<=n;i+=x) ans+=a[i];  //暴力枚举加和 
    printf("%lld\n",ans);
```
总的时间复杂度为 $O(nm)$ ，$n^2$ 过 $15w$？显然不行；

考虑一下第一种操作为什么跑的慢。

**如果模数 $x$ 很小时，我们上面的那层 $for$ 循环的复杂度更接近 $O(n)$；反之，如果模数 $x$ 很大时，复杂度反而会小；**

这就提供了我们一种思路：

**只有当 $x$ 比较大的时候我们才暴力，如果 $x$ 很小，我们直接记录答案！**

那么 $x$ 什么时候才算大呢？

一般我们钦定 $x > \sqrt{n}$ 的时候我们就暴力；

这种算法有个~~响当当~~的名字： 

### 根号算法
根号算法是一种很常见的算法；

常见的根号思想有：双向搜索，根号分类讨论，根号重建，复杂度平衡，以及一些根号级别的数据结构如分块和莫队；

**这些算法一般是多种暴力算法的结合，一般具有较低的思维难度和编码难度；**

——$ImmortalCO$猫

有的时候，我们可以对一个题想出两个暴力，各有各自的长处和短处。

**如果我们能对数据范围进行分块处理，或者两个暴力分别算之后拼接在一起，就用两个合在一起的暴力，实现了正解。**

通常这个分界点可以取到 $n--\sqrt{n}$

所以叫根号算法。

**通过根号算法，我们就能实现两种操作时间复杂度的均分了 。**

我们用 $dp [ i ][ j ]$ 记录模 $i$ 为 $j$ 的所有下标所对应的数的和；（这里数组只需开到 $\sqrt{n}$）

$O(n\sqrt{n})$ 预处理出答案：
```
    for(int i=1;i<=n;i++)  //枚举每个数 
        for(int j=1;j<=sqrt(n);j++)  //枚举模几
            dp[j][i%j]+=a[i]; 
```
**对于第 $1$ 种操作，如果所给的模数 $x < \sqrt{n}$，那么我们直接输出答案；否则我们暴力枚举；**

时间复杂度 $O(\sqrt{n})$
```
    if(C=='A')   //求模x为y的和
    {
        if(x<=sqrt(n)) printf("%lld\n",dp[x][y]);  //直接输出 
        else                
        {
            long long ans=0;
            for(int i=y;i<=n;i+=x) ans+=a[i];  //暴力枚举加和 
            printf("%lld\n",ans);
        }
    }
```
对于第 $2$ 种操作，我们在将第 $x$ 个数更新的同时，也要把 $dp$ 数组更新一遍；

时间复杂度 $O(\sqrt{n})$
```
    for(int i=1;i<=sqrt(n);i++)  //更新第x个数所涉及到的所有的池
        dp[i][x%i]+=y-a[x]; 
    a[x]=y;
```
总体时间复杂度 $O(n\sqrt{n})$，这样我们就用几乎暴力的算法过掉了本题$qwq$

**$Code$：**
```
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int read()
{
	char ch=getchar();
	int a=0,x=1;
	while(ch<'0'||ch>'9')
	{
		if(ch=='-') x=-x;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		a=(a<<1)+(a<<3)+(ch-'0');
		ch=getchar();
	}
	return a*x;
}
const int N=150005;
int a[N];
long long dp[400][400];  //dp[i][j]:模i为j的所有下标所对应的数的和,只需开到√n 
int n,m,x,y;
char C;
int main()
{
	n=read();m=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=n;i++)  //枚举每个数 
	    for(int j=1;j<=sqrt(n);j++)  //枚举模几
		    dp[j][i%j]+=a[i]; 
	while(m--)
	{
		cin>>C;
		x=read();y=read();
		if(C=='A')   //求模x为y的和
		{
			if(x<=sqrt(n)) printf("%lld\n",dp[x][y]);  //直接输出 
			else     //若x>√n,直接暴力!              
			{
				long long ans=0;
				for(int i=y;i<=n;i+=x) ans+=a[i];  //暴力枚举加和 
				printf("%lld\n",ans);
			}
		} 
		else       //把第x个数改成y 
		{
			for(int i=1;i<=sqrt(n);i++)  //更新第x个数所涉及到的所有的池
			    dp[i][x%i]+=y-a[x]; 
			a[x]=y;
		}
	} 
	return 0;
}
```


---

## 作者：Creeper_LKF (赞：21)

怎么说呢，其实是一开始复杂度推导错误，然后搞了个n^(1/3)的块出来，然后发现跑的飞快，比标解还快(792ms)（光速逃）。

后来想了想，似乎如果查询都比较大的话那么块大了没有优势，特别是用来卡暴力的大查询，反而块比较小跑的还比较优。

代码如下（前面有一些比较长的板子就忽略了，看函数名都知道干什么的，如有需要可以看R6585322）

最新：用了小号测了一把，发现n^(1/3)几乎是最快的，从pow(n,0.33)到0.3和0.35都会导致效率暴降


```
//Source Code

const int MAXN = 151111;
const int MAXB = 111;

int num[MAXN];
int block[MAXN][MAXB];

int main(){
    Main_Init();
    int n = read(), m = read(), block_cnt = pow(n, 0.33);
    for(int i = 1; i <= n; i++){
        num[i] = read();
        for(int j = 1; j <= block_cnt; j++){
            block[j][i % j] += num[i];
        }
    }
    while(m --){
        char cons;
        while((cons = *LKF::pc ++) < 65);
        int x = read(), y = read();
        if(cons == 'A'){
            if(x < block_cnt) write('\n', block[x][y % x]);
            else {
                int ans = 0;
                for(int i = y; i <= n; i += x) ans += num[i];
                write('\n', ans);
            }
        } else {
            for(int i = 1; i <= block_cnt; i++){
                block[i][x % i] += y - num[x];
            }
            num[x] = y;
        }
    }
    Main_Init();
    return 0;
}
```

---

## 作者：Thomasguo666 (赞：13)

## 神仙根号算法题

（然而并不是分块）

乍一看数据范围挺大的。

然后我们发现，如果我们以某个数$T$为界，如果模数$p$在$T$以下，那么我们记录以$p$为模的池，复杂度$O(T)$。

如果在$T$以上，那么我们直接暴力硬算，复杂度$O(N/T)$。

然后，$T$如果取$\sqrt{N}$就可以保证两种情况复杂度相等

不过据说$T$取$N^{\frac{1}{3}}$跑起来更快？

试了一把，总时间将近缩短了一半。

应该是由于模数大多较小吧。



```c++
#include <bits/stdc++.h>
using namespace std;
int ans[505][505],a[150005];
int qaq()
{
	int n,m,cur;
	cin>>n>>m;
	int sz=sqrt(n);
	for (int i=1;i<=n;i++)
	{
		cin>>cur;
		a[i]=cur;
		for (int p=1;p<=sz;p++) ans[p][i%p]+=cur;
	}
	while (m--)
	{
		int x,y;
		char opt;
		cin>>opt>>x>>y;
		if (opt=='A') 
		{
			if (x<=sz) cout<<ans[x][y]<<endl;
			else 
			{
				int sum=0;
				for (int i=y;i<=n;i+=x) sum+=a[i];
				cout<<sum<<endl;
			}
		}
		else if (opt=='C')
		{
			for (int p=1;p<=sz;p++) ans[p][x%p]-=(a[x]-y);
			a[x]=y;
		}
	}
	return 0;
}
int w=qaq();
int main()
{
	return w;
}
```



---

## 作者：hs_black (赞：10)

#### 这个套路还是蛮常见的

思路: 将操作分为两类, 大于$\sqrt{n}$ 的, 和小于它的

为什么要这么干

考虑暴力 , 每次修改$O(1)$ , 每次查询$O(n)$ 

那么它的复杂度是$O(n^2)$ 的

观察发现, 修改的复杂度远小于查询, 导致复杂度不平衡

考虑在修改时预处理以降低查询复杂度

修改时处理将x膜1 ~ $\sqrt{n}$ 加上a[x], cnt[x] += a[x],  $O(\sqrt{n})$ 

查询时, 如果x < $\sqrt{n}$ , 直接输出 mod\[x][y%x]  , 否则 暴力枚举 , 复杂度$O(\sqrt{n})$ 

总复杂度$O(n\sqrt{n})$ 

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
int siz;
long long cnt[500000], mod[500][500];
int read(void) {
	int x = 0;
	char c = getchar();
	while (!isdigit(c)) c = getchar();
	while (isdigit(c)) {
		x = (x << 3) + (x << 1) + c - '0';
		c = getchar();
	}
	return x;
}
int n, m;
int a[200005];
void add(int x,int k) {
	for (int i = 1;i <= siz; i++) mod[i][x % i] += k;
	cnt[x] += k;
}
int main() {
	n = read(), m = read();
	siz = sqrt(n);
	for (int i = 1;i <= n; i++) {
		a[i] = read();
		add(i, a[i]);
	}
	char s[5];
	while (m--) {
		scanf ("%s", s);
		int x = read(), y = read();
		if (s[0] == 'C') {
			add(x, -a[x]);
			a[x] = y;
			add(x, y);
		}
		else {
			y %= x;
			if (x <= siz) printf ("%lld\n", mod[x][y]);
			else {
				int val = 0;
				for (int i = y;i <= n; i += x) val += cnt[i];
				printf ("%d\n", val);
			}
		}
	}
	return 0;
}
```



---

## 作者：Kevin_F (赞：7)

####[传送门啦](https://www.luogu.org/problemnew/show/P3396)

非常神奇的分块大法。

这个题一看数据范围，觉得不小，但是如果我们以 $ \sqrt(x) $ 为界限，数据范围就降到了 $ x < 400 $ 

我们设数组 $ f[i][j] $ 表示在 % $ i $ 意义下余数是 $ j $ 的数的总和。

然后我们以 $ \sqrt(n) $ 为界限，小于 $ \sqrt(n) $ 的直接调用数组，剩下的暴力查找。修改的话看代码吧，真的不难。

    #include <iostream>
	#include <cstdio>
	#include <cstring>
	#include <algorithm>
	#include <cmath> 
	using namespace std;
	const int maxn = 150005;

	inline int read(){
		char ch = getchar();
		int f = 1 ,x = 0;
		while(ch > '9' || ch < '0'){if(ch == '-')f = -1; ch = getchar();}
		while(ch >= '0' && ch <= '9'){x = (x << 1) + (x << 3) + ch - '0';ch = getchar();}
		return x * f;
	}

	int n,m,a[maxn],x,y;
	char flag;
	long long f[390][390];//表示在 %i 意义下 余数是 j 的数的总和 

	int main(){
		n = read(); m = read();
		for(int i=1;i<=n;i++){
			a[i] = read();
			for(int j=1;j<=sqrt(n);j++)
				f[j][i % j] += a[i];
		}
		while(m--){
			cin >> flag;
			x = read(); y = read();
			if(flag == 'A'){
				if(x * x <= n)
					printf("%lld\n",f[x][y]);
				else {
					int sum = 0;
					for(int j=y;j<=n;j+=x)
						sum += a[j];
					printf("%d\n",sum);
				}
			}
			else {
				for(int j=1;j<=sqrt(n);j++)
					f[j][x % j] += y - a[x];
				a[x] = y;
			}
		}
		return 0;
	}

---

## 作者：HPXXZYY (赞：7)

**本题解参考了阮行止老师的题解，本题解仅仅给出代码，思路请看阮行止老师的题解。**

[阮行止老师的题解](https://www.luogu.org/blog/blue/solution-p3396)

```cpp
#define gc getchar()
#define g(c) isdigit(c)
inline long long read(){
	char c=0;long long x=0;bool f=0;
	while (!g(c)) f=c=='-',c=gc;
	while (g(c)) x=x*10+c-48,c=gc;
	return f?-x:x;
}//快读
const int N=150100,M=420;
long long Q[M][M],sze,i,n,a[N],m;
inline void init(){
	for(int i=1;i<=n;i++)
		for(int p=1;p<=sze;p++)
			Q[p][i%p]+=a[i];
}//初始化操作
inline long long get_answer(int v,int c){
	if (v<=sze) return Q[v][c];
	else{
		register long long ans=0;
		for(int i=c;i<=n;i+=v)
			ans+=a[i];
		return ans;
	}
}//查询和操作
inline void change(int i,int v){
//	a[i]=v
	for(int p=1;p<=sze;p++)
		Q[p][i%p]=Q[p][i%p]-a[i]+v;
	a[i]=v;
}//修改操作
char opt;
int main(){
	freopen("testdata.in","r",stdin);
	freopen("write.out","w",stdout);
	n=read();m=read();
	for(i=1;i<=n;i++)
		a[i]=read();
	sze=sqrt(n);init();
//	printf("sze=%d\n",sze);
	for(i=1;i<=m;i++){
		do{//特别注意opt的读入，否则只有70分
			opt=gc;
		}while (opt!='A'&&opt!='C');
		int x=read(),y=read();
		if (opt=='C') change(x,y);
		else printf("%lld\n",get_answer(x,y));
	}
	return 0;
}
```
**【补充】：** 为了达到反作弊但不修改原程序的效果，本题解仅仅略去头文件，其它部分是原汁原味的$AC$代码。

---

## 作者：Demoe (赞：2)

### [题目传送门](https://www.luogu.com.cn/problem/P3396)

## 题意

- 给定一个序列，支持单点修改和跳点求和（即 $y+kx(k\in N)$ 的位置上的和）

## Sol

2014 年集训队论文 《根号算法——不只是分块》 ——王悦同 例一加强版。

原题是没有修改操作的，但单点修改没有提高本题难度。（

~~既然都根号算法了那就往根号上想~~

若 $x \ge \sqrt n$ 则直接暴力跳就行了，此时复杂度小于 $O(\sqrt n)$。

考虑预处理 $x < \sqrt n$ 的情况。

考虑定义 $f_{i,j}$ 为 $x=i$，$y=j$ 时的答案。（此题问法保证了 $y\le x$）

考虑每个点对 $f$ 的贡献。

显然 $a_x$ 仅对 $f_{i,x%i}$ 有 $a_x$ 的贡献，所以每个点仅有 $O(\sqrt n)$ 的复杂度。

更新与其相同。

总复杂度 $O((n+m)\sqrt n)$。

### $\text{Code}$

```cpp
// wish to get better qwq

#include<bits/stdc++.h>
#define re register int
#define pb push_back

using namespace std;
typedef long long ll;

template <typename T> void rd(T &x){
	ll fl=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') fl=-fl;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x*=fl;
}
void wr(ll x){
	if(x<0) x=-x,putchar('-');
	if(x<10) putchar(x+'0');
	if(x>9) wr(x/10),putchar(x%10+'0');
}

char op;
inline void getop(){
	op=getchar();
	while(op!='A'&&op!='C') op=getchar();
}

// ---------- IO ---------- //

const int N=2e5+5,SQ=505;
ll n,m,v[N],len,qaq,qwq;
ll f[N][SQ];    // 当时傻了开大了

inline void modify(ll x,ll y){
	for(re i=1;i<=len;i++) f[i][x%i]+=y-v[x];
	v[x]=y;
}

inline ll query(ll x,ll y){
	if(x<=len) return f[x][y%x];
	ll sum=0;
	for(re i=y%x;i<=n;i+=x) sum+=v[i];
	return sum;
}

// ---------- Sqrt & Operations ---------- //

int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	rd(n);rd(m);len=(int)sqrt(n);
	for(re i=1;i<=n;i++){
		int x;rd(x);modify(i,x);
	}
	while(m--){
		getop();rd(qaq);rd(qwq);
		if(op=='A') wr(query(qaq,qwq)),puts("");
		else modify(qaq,qwq);
	}
	return 0;
}

// ---------- Main ---------- //

```

---

说完这题，我们再来考虑一下论文题。

- 给定一个序列，每次询问给定 $x$，$y$，问 $y+kx(k \in N)$ 的位置上的和。

- 不保证 $y\le x$

$x \ge \sqrt n$ 时仍暴力跑。

$x < \sqrt n$ 时，还是需开一个 $f_{i,j}$ 表示 $x=i$，$y=j$ 的答案。

对于每个 $x$，从后往前更新即可。

---

## 作者：Plozia (赞：2)

宣传博客->[link](https://blog.csdn.net/BWzhuzehao/article/details/115642522)

这道题是一道根号算法题目，**但是并不是分块，而是一种新科技——根号分治**。

根号分治的具体思想就是：设置一个阈值 $p$，询问小于阈值的时候想办法快速计算答案，询问大于阈值的时候暴力计算答案，一般取 $p=\sqrt{n}$。

什么意思呢？拿这道题讲解一下。

这道题设置一个阈值 $p=\sqrt{n}$，表示询问时模数的阈值。

- 模数大于阈值

这个直接暴力做就可以了，设询问的池为 $x$，每一次不断加上询问的模数即可，因为此时保证模数大于阈值 $p=\sqrt{n}$，那么可以保证单次查询的复杂度在 $O(\sqrt{n})$ 里面。

- 模数小于等于阈值

这个时候就需要维护一下这一块的答案了。

设 $ans_{p,k}$ 表示模数为 $p$ 时 $k$ 池内的答案，其中 $p \in [1,\left\lfloor\sqrt{n}\right\rfloor]$。

那么这个显然在一开始可以 $O(\sqrt{n})$ 预处理出来。

然后询问的时候就可以 $O(1)$ 询问了。

- 修改操作

这个时候我们需要枚举模数 $p \in [1,\left\lfloor\sqrt{n}\right\rfloor]$，修改 $ans_{p,x \bmod p}$ 的值，最后直接更新 $a_p$ 即可。

因为 $p$ 最大上限是 $\sqrt{n}$，因此这一部分也可以在 $O(\sqrt{n})$ 的时间内完成。

代码：

```cpp
/*
========= Plozia =========
    Author:Plozia
    Problem:P3396 哈希冲突
    Date:2021/4/12
========= Plozia =========
*/

#include <bits/stdc++.h>

typedef long long LL;
const int MAXN = 150000 + 10, MAXBlock = 400 + 10;
int n, m, a[MAXN], Size;
LL ans[MAXBlock][MAXBlock];

int read()
{
    int sum = 0, fh = 1; char ch = getchar();
    for (; ch < '0' || ch > '9'; ch = getchar()) fh -= (ch == '-') << 1;
    for (; ch >= '0' && ch <= '9'; ch = getchar()) sum = (sum << 3) + (sum << 1) + (ch ^ 48);
    return sum * fh;
}

int main()
{
    n = read(), m = read(); Size = sqrt(n);
    for (int i = 1; i <= n; ++i) a[i] = read();
    for (int i = 1; i <= Size; ++i)
        for (int j = 1; j <= n; ++j)
            ans[i][j % i] += (LL)a[j];
    for (int i = 1; i <= m; ++i)
    {
        char ch; std::cin >> ch;
        if (ch == 'A')
        {
            int x = read(), y = read();
            if (x <= Size) printf("%lld\n", ans[x][y]);
            else
            {
                LL sum = 0;
                for (int i = y; i <= n; i += x) sum += a[i];
                printf("%lld\n", sum);
            }
        }
        else
        {
            int x = read(), y = read();
            for (int i = 1; i <= Size; ++i)
                ans[i][x % i] = ans[i][x % i] - (LL)a[x] + y;
            a[x] = y;
        }
    }
    return 0;
}
```

---

## 作者：Strelitzia (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P3396)

---

前置知识：根号分治。

做这道题之前，可以先做一下这一道 _[CF103D Time to Raid Cowavans](https://www.luogu.com.cn/problem/CF103D)_，如果你做了。

你会发现 _[哈希冲突](https://www.luogu.com.cn/problem/P3396)_ 就是这道题的加强版，也就是多了个修改操作。

对于查修操作中的 $x > \sqrt n$，直接暴力来。

然而，对于另一种情况，由于有修改操作，我们不能离线来。

所以，我们不能直接对于每个模 $x$，求后缀和。

但这道题，有个特殊的地方，如果它模 $x$，这些询问的地点都是小于 $x$，的。

所以就可以直接维护前 $\sqrt n$ 个地点的值了。


```cpp
#include <cmath>
#include <vector>
#include <cstdio>
#include <cctype>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

template<typename T>void read(T &x) {
	x = 0;T f = 1;char ch = getchar();
	while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}
	while (isdigit(ch)) {x = (x << 3) + (x << 1) + ch - '0';ch = getchar();}
	x *= f;
}
int read() {
	int x = 0, f = 1;char ch = getchar();
	while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}
	while (isdigit(ch)) {x = (x << 3) + (x << 1) + ch - '0';ch = getchar();}
	return x *= f;
}
template<typename T>void print(T x) {
	if (x < 0) putchar('-'),x = -x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}

template<typename T>T Abs(T x) {return x < 0 ? -x : x;}
template<typename T>T Min(T x,T y) {return x < y ? x : y;}
template<typename T>T Max(T x,T y) {return x > y ? x : y;}

const int BL = 400 + 5;
const int N = 150000 + 5;;

int n,m;
int a[N];
int s[BL][BL];

int main () {
	read(n);read(m);
	int t = sqrt(n);
	for (int i = 1 ; i <= n ; ++ i) {
		read(a[i]);
		for (int j = 1 ; j <= t ; ++ j)
			s[j][i % j] += a[i];
	}
	char ch;
	int x,y;
	for (int i = 1 ; i <= m ; ++ i) {
		while ((ch = getchar()) != 'A' && ch != 'C');
		read(x);read(y);
		if (ch == 'A') {
			int tmp = 0;
			if (x > t) {
				for (int j = y ; j <= n ; j += x)
					tmp += a[j];
				print(tmp),putchar('\n');
			}
			else
				print(s[x][y]),putchar('\n');
		}
		else {
			int las = a[x];
			a[x] = y;
			for (int j = 1 ; j <= t ; ++ j)
				s[j][x % j] += y - las;
		}
	}
	return 0;
}
```

---

## 作者：杨铠远 (赞：1)

这真是一道水分块（暴力）题
暴力91分，我痛定思痛加了一个特判（我A了~）
为了不变棕 又敲了10行分块
```
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cmath>
using namespace std;
const int N=150001;
int a[N];
int an=75075000;//特判的遗迹 
int sq;
int f[20000][20000];
inline int read()
{
	register int res=0;
	register char ch=0;
	while(isspace(ch=getchar()));
	do 
		res=(res<<3)+(res<<1)+ch-'0';//优化的快读 
	while(isdigit(ch=getchar()));
	return res;
}
inline char read_ch()//机房大佬的快读字符 
{
	register char ch=0;
	while(((ch=getchar())!='A')&&(ch!='C'));
	return ch;
}
int main()
{
	register int n,m,mod,x,ans=0;
	register char c;
	n=read();
	m=read();
	for(register int i=1;i<=n;++i)
		a[i]=read();
	sq=sqrt(n); //分块 
	for(int i=1;i<=n;i++)
	for(int p=1;p<=sq;p++)
	{
		f[p][i%p]+=a[i];//由题意，处理一部分 
	}
	while(m--)
	{
		c=read_ch();
		ans=0;
		switch(c)
		{
			case 'A':
				mod=read();
				x=read();
				if(mod<sq)
				{
					printf("%d\n",f[mod][x%mod]);//搞他！ 
				}
				else{
				
				while(x<=n)
				{
					ans+=a[x];//比mod快很多哦 
					x+=mod;
				}
				printf("%d\n",ans);}
				break;
			case 'C':
				x=read();
				mod=read();
				for(int p=1;p<=sq;p++)
				{
					f[p][x%p]+=(mod-a[x]);//改值 
				}
				a[x]=mod;
				break;
			}
	}
	return 0;
}
```


---

## 作者：Vanilla_chan (赞：0)

## Problem

[P3396 哈希冲突](https://www.luogu.com.cn/problem/P3396)

## Solution

本文摘自[基础数据结构学习笔记](https://www.luogu.com.cn/blog/Vanilla-chan/ji-chu-shuo-ju-jie-gou-xue-xi-bi-ji)

先想两种极端的做法

- 对于每个询问，暴力计算$k,k+p,k+2\times p\dots$的$value$之和。
- 预处理出$ans[p][k]$表示在$\bmod p$的意义下，余数为$k$的$value$之和。

第一种方法时间$\rm O(n^2)$，空间$\rm O(1)$；第二种方法时间$\rm O(1)$，空间$O(n^2)$。

考虑**根号分治**。

对于$p\le \sqrt n$，我们预处理，保存在数组$ans[p][k]$中。空间$\rm O(\sqrt n\times\sqrt n)=\rm O(n)$，时间上预处理$\rm O(n\sqrt n)$，修改$\rm O(\sqrt n)$，查询$\rm O(1)$.

对于$p>\sqrt n$，我们不预处理，每一次询问暴力统计。每次统计的数量不会超过$\dfrac np\le \sqrt n$.

$\color{white}我做了那些Ynoi我都白做了啊啊啊，这么简单的一个根号分治我都想不出来……我太菜了……\color{gray}awa$

[Code](https://www.luogu.com.cn/paste/yim0r4cd)



---

## 作者：漠寒 (赞：0)

## 分析

在我看了二十分钟题后，才发现被模的数是下标，不是值（美好），然后就开始换做法。

对于每一个模数 $x$ ，我们发现第一个符合要求的就是 $y$ ，之后每一个符合要求的数就是前一个数加上 $x$ ，这样的话每一次的操作时间复杂度就是 $n/x$，这样我们发现如果每一个 $x$ 都很小的话，时间复杂度就达到了 $n^2$，所以我们如何优化呢？

由前面可知我们所忌惮的就是小的 $x$，因此我们可以设置一个较小的数，存储比它小的数作为模数时各结果的答案，然后当 $x$ 小于这个限度时，就可以直接输出了，对于每一个修改的数，计算限定数次数，对于所给 $x$ 大于该限定数的，计算 $n/x$ 次，因此我们可以得到当限定数 $t$ 设为 $\sqrt{n}$ 时，极限的时间复杂度即为 $(m+n)\sqrt{n}$，至此此题得解。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[150001],x,y,ans[400][400],rt,n,m;
char op[10];
inline void read(int &res){
	res=0;
	int f=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){res=(res<<1)+(res<<3)+c-48;c=getchar();}
	res*=f;
}
int main()
{
	read(n);
	read(m);
	rt=sqrt(n);//限度 
	for(int i=1;i<=n;++i){
		read(a[i]);
		for(int j=1;j<=rt;j++)ans[j][i%j]+=a[i];//存储限度内的答案 
	}
	for(int i=1;i<=m;++i){
		scanf("%s",op);read(x);read(y);
		if(op[0]=='A'){
			if(x<=rt)printf("%d\n",ans[x][y]);
			else{//题目中说了输入合法，否则我觉得还是判断x与y的大小为好 
				int s=0;
				for(int j=y;j<=n;j+=x){//分析中的计算方法 
					s+=a[j];
				}
				printf("%d\n",s);
			}
		}
		if(op[0]=='C'){
			for(int j=1;j<=rt;j++)ans[j][x%j]+=(y-a[x]);//将存储答案更新 
			a[x]=y;
		}
	}
	return 0;
}
```


---

## 作者：FutaRimeWoawaSete (赞：0)

# 前言     
之前一直做 $Ynoi$ 的时候就发现了一个有趣的现象：怎么根号分治这玩意儿被这么普遍地使用啊，最近才知道原来根号分治是来源于王悦同巨佬的集训队论文《根号算法——不只是分块》。     

# 题解       

首先我们发现这玩意儿是个区查单修，而且看这 $150000$ 就感觉是个 $O(n\sqrt n)$ ，我们考虑根号分治。       

首先考虑询问，对于 $x \geq \sqrt n$ 的情况，那么我们直接在原区间里面暴力找，总时间复杂度不超过 $O(\sqrt n)$ 。     

接着考虑 $x \leq n$ 的情况，我们可以直接开一个暴力二维数组 $b_{i,j}$ 表示在模 $i$ 意义下 $j$ 池的总和是多少，先预处理出来，如果没有修改的话我们就直接输出这个池就好了。      

接着考虑修改操作，首先我们肯定得修改 $a_x$ 保证我们的第一类 $x \geq \sqrt n$ 的情况的正确性，接着我们知道对于一个元素，其对应的每种模 $x$ 的意义下的池只有一个，所以暴力枚举 $1 \sim \sqrt n$ 的所有 $x$ ，然后修改即可，总时间复杂度不超过 $O(\sqrt n)$ 。       

此题还和 [Ynoi2011 初始化](https://www.luogu.com.cn/problem/P5309) 有利益关系，大家做完此题不妨去思考这道。       

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
const int Len = 1.5e5 + 5 , SIZE = 405;
int n,m,t,BLOCK[SIZE][SIZE],a[Len];
char s[15];
int main()
{
	scanf("%d %d",&n,&m);
	int t = sqrt(n);
	for(int i = 1 ; i <= n ; i ++) scanf("%d",&a[i]);
	for(int i = 1 ; i <= t ; i ++)
	{
		for(int j = 1 ; j <= n ; j ++)
			BLOCK[i][j % i] += a[j];
	}
	for(int i = 1 ; i <= m ; i ++)
	{
		scanf("%s",s);int x,y;scanf("%d %d",&x,&y);
		if(s[0] == 'A')
		{
			if(x >= t) 
			{
				int res = 0;
				for(int j = y ; j <= n ; j += x) res += a[j];
				printf("%d\n",res); 
			}
			else printf("%d\n",BLOCK[x][y]);
		}
		else
		{
			for(int j = 1 ; j <= t ; j ++)
			{
				BLOCK[j][x % j] -= a[x];
				BLOCK[j][x % j] += y;
			}
			a[x] = y;
		}
	}
	return 0;
}
```

---

## 作者：keep_ (赞：0)

# 根号分治

## 前言

本题是一道讲解根号分治思想的论文题(~~然鹅我并没有找到论文~~)，正

如论文中所说，根号算法——不仅是分块，根号分治利用的思想和分块像

似却又不同，某一篇洛谷日报中说过，分块算法实质上是一种是通过分成

多块后在每块上打标记以实现快速区间修改，区间查询的一种算法。根号

分治与其思路相似，将原本若一次性解决时间复杂度很高的问题分块去解

决来降低整体的时间复杂度。

## 例题

以本题举例子[哈希冲突](https://www.luogu.com.cn/problem/P3396)

本题作为论文的第一道题目，是一道很好的练习题,注意，本体给出的 

 $value[i]$ 是 $i$ 在序列中出现的次数，不要把题读错了(~~一开始我就读错了~~)

我们首先阅读题目，发现，无论是 $O(n^2)$ 预处理， $O(1)$ 查询，还是在

查询时直接$O(n^2)$获取答案，都是 $O(n^2)$ 的时间复杂度，我们考虑对

其进行优化，我们可以考虑将$p$，也就是模数按根号分块处理

对于 $p<=\sqrt{q}$ 我们直接 $O(n\sqrt{n})$ 进行预处理，
```c++
	for(int i=1;i<=n;i++){
		v=read();
		val[i]=v;
	}
	size=sqrt(n); 
	for(int i=1;i<=n;i++){
		for(int p=1;p<=size;p++){
			ans[p][i%p]+=val[i]; 
		}
	}
```

 $ans[p][i]$ 表示在 $%p$ 后值为 $i$的数的个数

对 $p>\sqrt{q}$ 的情况,

我们直接暴力得出答案，暴力得到答案的时间复杂度为 $O(\sqrt{n})$

```c++
	int an=val[y]; 
	for(int i=x+y;i<=n;i+=x){
		an+=val[i]; 
	}
	cout<<an<<endl;
```
 $an=val[y]$ 是为了处理 $y%x=y$ $(y<x)$ 的情况,为什么说我们暴力跳

答案时间复杂度是 $O(\sqrt{n})$ 呢？我们当前的 $p>\sqrt{n})$ 因为统

计答案时每一次要跳$p$个数，所以有贡献的数一定小于 $\frac{n}
{p}$ 也就是 $\sqrt{n}$ ，所以暴力得到答案的时间复杂度为 $O(\sqrt{n})$

每一次修改，我们只需要修改 $p<=\sqrt{n}$ 的情况即可，时间复杂度也是 $O(\sqrt{n})$

```c++
	cin>>x>>y;
	int l=y-val[x];
	val[x]=y; 
	for(int p=1;p<=size;p++){
		ans[p][x%p]+=l;
	}
```
所以在本题，我们运用根号分治的想法，把时间复杂度由原本的$O(n^2)$

优化到了 $O(n\sqrt{n})$ 从而解决本题。

莫名觉得根号分治挺像折半搜索
，推荐一道练习题[CF444D DZY Loves Strings](https://www.luogu.com.cn/problem/CF444D)
  还是很有难度的

## 代码
放一下全部代码吧
```c++
#include<iostream>
#include<string>
#include<string>
#include<cstdio>
#include<cmath>
#define int long long
using namespace std;
const int maxn=3e5+10;
inline int read(){
	int ret=0;
	int f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')	
			f=-f;
		ch=getchar();
	}
	while(ch<='9'&&ch>='0'){
		ret=ret*10+(ch^'0');
		ch=getchar();
	}
	return ret*f;
}
int val[maxn];
int n,m;
int p;
int ans[2000][2000];
int size;
char a;
signed main(){
//	freopen("a.in","r",stdin);
	n=read();
	m=read();
	int v;
	for(int i=1;i<=n;i++){
		v=read();
		val[i]=v;//???????? 
	}
	size=sqrt(n);//???? 
	for(int i=1;i<=n;i++){
		for(int p=1;p<=size;p++){
			ans[p][i%p]+=val[i]; 
		}
	}
	int x,y;
	while(m--){
		cin>>a;
		if(a=='A'){
			x=read();
			y=read();
			if(x<=size){
				cout<<ans[x][y]<<endl;
			}
			else{
				int an=val[y]; 
				for(int i=x+y;i<=n;i+=x){
						an+=val[i]; 
				}
				cout<<an<<endl;
			} 
		}
		if(a=='C'){
			cin>>x>>y;
			int l=y-val[x];
			val[x]=y; 
			for(int p=1;p<=size;p++){
				ans[p][x%p]+=l;
			}
		}
	}
	return 0;
}
```
到这里本题解就结束了

完结撒花！！


---

## 作者：Lumos壹玖贰壹 (赞：0)

#### 根号分块
~~感觉就是分类讨论+暴力？~~
##### 题目描述

ha老师对hash冲突很感兴趣。他会给出一个正整数序列 value

自然，ha老师会把这些数据存进 hash 池。$value_k$ 会被存进 ($k$ $mod$ $p$)这个池。

ha老师会给定许多个p和x，询问在模p时，x这个池内数的总和。

另外，ha老师会随时更改 $value_k$。每次更改立即生效。

##### Solution
吐槽：这题目描述真的绝了......以为是把数值hash，结果是hash下标......搞半天搞不清

1. 看清题后就会有个暴力，每次求和就把模p等于x的位上的数加起来，修改就修改那个点。单次求和复杂度是$O$($N\over p$)。当p特别小的时候，单次复杂度会变成$O(N)$~~然后就炸了~~
2. 但p特别小的时候，x也一定特别小(x<p),我们可以$O(p^2)$预处理。我们预处理p到$\sqrt{n}$就好了。
3. 对于每个询问，若p $\leqslant$ $\sqrt{N}$,直接输出就好。若大于，就按1中的方案暴力统计。因为p>$\sqrt{N}$,所以$O$($N \over p$)<$\sqrt{N}$，最终复杂度是$O$($N\sqrt{N}$)
4. 对于修改(把第p个数变成x)，就枚举模数$i$，把$f[i][p$%$i]$进行修改

##### Code
so easy
```cpp
#include<bits/stdc++.h>
#define ri register int
#define ll long long
using namespace std;
const int maxn=150005;
int f[400][400],n,m,a[maxn],x,y;
char op;
int main(){
	scanf("%d %d\n",&n,&m);
	memset(f,0,sizeof(f));
	for(ri i=1;i<=n;i++){
		a[i]=rd();
		for(ri j=1;j<=sqrt(n);j++) f[j][i%j]+=a[i];
	}
	for(ri i=1;i<=m;i++)
	{
		cin>>op;
		x=rd(); y=rd();
		if(op=='A'){
			if(x*x<=n) printf("%d\n",f[x][y]);
			else{
				ll ans=0;
				for(ri j=y;j<=n;j+=x) ans=ans+a[j];
				printf("%lld\n",ans);
			}
		}
		else{
			for(ri i=1;i<=sqrt(n);i++)
				f[i][x%i]+=y-a[x];
			a[x]=y;
		}
	}
	return 0;
}

```

---

## 作者：7KByte (赞：0)

神仙分块题，写篇题解记录下


切题的一个很好的思路是先考虑暴力程序怎么打，然后如何去优化


题面简化

> $C\ i\ j\ :\ \ $将$Val[i]$的值改为$j$

> $A\ i\ j\ :\ \ $求$\sum\limits_{k=1}^{ki+j<=n}Val[ki+j]$

暴力求解很简单，修改$O(1)$，查询直接枚举$k$即可，单次复杂度$O(\frac{n}{i})$

```cpp

#include<bits/stdc++.h>
#define N 150005
#define rep(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
int n,m,a[N];
int main(){
	scanf("%d%d",&n,&m);
	rep(i,1,n)scanf("%d",&a[i]);
	char op[2];int x,y;
	rep(i,1,m){
		scanf("%s%d%d",op,&x,&y);
		if(op[0]=='C'){a[x]=y;continue;}
		int ans=0;
		for(int j=y;j<=n;j+=x)ans+=a[j];
		printf("%d\n",ans);
	}
	return 0;
}
```

--------------

考虑优化

经过观察我们可以发现每次查询所耗的时间取决于$i$的大小，$i$越大，需要的运算越少

对此一个比较套路的做法是进行预处理。对于$i$较小的情况提前预处理

我们发现$Val[pos]$对于不同的$i$，只对池$pos\%i$有影响

```cpp
rep(i,1,n){
		scanf("%d",&a[i]);
		rep(j,1,len)c[j][i%j]+=a[i];
	}
```

考虑预处理所有的$i<=Cnt$，预处理的时间$O(N*Cnt)$，对于每次查询，$i<=Cnt$时$O(1)$，$i>cnt$时时间严格小于$O(\frac{N}{Cnt})$，所以查询时间复杂度$O(N*\frac{N}{Cnt})$

解方程$N*Cnt=N*\frac{N}{Cnt}$得到$Cnt=\sqrt{N}$

所以总的时间复杂度为$O(Nsqrt{N})$

小声说一句:本题数据大部分随机的，卡暴力的数据$i$都特别小，所以$Cnt<10$时跑的最快（手动滑稽

```cpp
#include<bits/stdc++.h>
#define N 150005
#define M 400
#define rep(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
int n,m,a[N],c[N][M];
int len;
int main(){
	scanf("%d%d",&n,&m);
	len=sqrt(n);
	rep(i,1,n){
		scanf("%d",&a[i]);
		rep(j,1,len)c[j][i%j]+=a[i];
	}
	char op[2];int x,y;
	rep(i,1,m){
		scanf("%s%d%d",op,&x,&y);
		if(op[0]=='C'){
			rep(j,1,len)c[j][x%j]+=y-a[x];
			a[x]=y;
		}
		else{
			if(x<=len)printf("%d\n",c[x][y]);
			else{
				int ans=0;
				for(int j=y;j<=n;j+=x)ans+=a[j];
				printf("%d\n",ans);
			}
		}
	}
	return 0;
}
```

---

## 作者：Minakami_Yuki (赞：0)

根号分治入门题

# 题目链接

[P3396 哈希冲突](https://www.luogu.org/problem/P3396)

# 题意简述

给你一个序列，每次查询模`p`意义下某数总和，或者更改某一个数。

# 解题思想

先考虑暴力怎么打，显然有两种操作：
一是先$O(n ^ 2)$预处理出模$i$意义下余数为$j$的答案，然后可以做到$O(1)$查询，$O(n)$修改。

二是对于每一次询问，暴力$O(n)$统计，修改是$O(1)$的。

两种做法的总复杂度都是$O(n ^ 2)$的，且第一种做法空间也会炸。

观察到两种做法查询修改互补，我们可以考虑结合一下：

对于模数较小的情况，我们可以预处理出来，这样空间不会炸，修改范围也会变小。
对于模数较大的情况，我们暴力统计，这样结果不会过多，查询不会炸。

这个较大较小的界，我们可以定为$O(\sqrt n)$，所以总复杂度为$O(n\sqrt n)$

# 参考代码

```c++
#include <cstdio>
#include <cctype>
#include <cmath>

namespace FastIO {
    inline int read() {
        char ch = getchar(); int r = 0, w = 1;
        while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();}
        while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();}
        return r * w;
    }
    void _write(int x) {
        if(x < 0) putchar('-'), x = -x;
        if(x > 9) _write(x / 10);
        putchar(x % 10 + '0');
    }
    inline void write(int x) {
        _write(x);
        puts("");
    }
}

using namespace FastIO;

const int N = 150010;
const int SIZE = 400;

int n, m;
int a[N];
int f[SIZE][SIZE];

int main() {
    n = read(), m = read();
    int size = sqrt(n);
    for(register int i = 1; i <= n; i++) {
        a[i] = read();
        for(register int j = 1; j <= size; j++) {
            f[j][i % j] += a[i];
        }
    }
    while(m--) {
        char s[3];
        scanf("%s", s);
        int x = read(), y = read();
        if(s[0] == 'A') {
            if(x <= size) write(f[x][y]);
            else {
                int ans = 0;
                for(register int i = y; i <= n; i += x) {
                    ans += a[i];
                }
                write(ans);
            }
        }
        else {
            for(register int i = 1; i <= size; i++) {
                f[i][x % i] += y - a[x];
            }
            a[x] = y;
        }
    }
    return 0;
}
```



---


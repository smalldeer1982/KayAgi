# 【MX-J3-T4】 Partition

## 题目背景

原题链接：<https://oier.team/problems/J3E>。

## 题目描述

你有 $n$ 行 $m$ 列的一个矩阵，第 $i$ 行第 $j$ 列的格子（记作 $(i,j)$）上写有一个整数 $a_{i,j}$。

- 称 $(a,b)$ 在 $(c,d)$ 的**下方**，当且仅当 $b=d,a>c$，即**同一列中，行编号更大**。
- 称 $(a,b)$ 在 $(c,d)$ 的**上方**，当且仅当 $(c,d)$ 在 $(a,b)$ 的**下方**。
- 称 $(a,b)$ 在 $(c,d)$ 的**右边**，当且仅当 $a=c,b>d$，即**同一行中，列编号更大**。
- 称 $(a,b)$ 在 $(c,d)$ 的**左边**，当且仅当 $(c,d)$ 在 $(a,b)$ 的**右边**。

如图，$A(2,2)$ 下方有 $D(3,2),E(4,2)$，右边有 $B(2,3),C(2,4)​$。

![](https://cdn.luogu.com.cn/upload/image_hosting/183z78z1.png)

为了让矩阵更加美观，你想要给每个格子涂上红、橙、黄、绿四种颜色之一，有很多种方案，但是如果一个方案满足如下要求，就称这个方案是**简单**的：

- 红色格子的**上方**只能是红色格子，**左边**只能是红色或黄色格子，**右边**只能是红色或橙色格子。
- 橙色格子的**右边**只能是橙色格子，**上方**只能是橙色或红色格子，**下方**只能是橙色或绿色格子。
- 绿色格子的**下方**只能是绿色格子，**右边**只能是绿色或橙色格子，**左边**只能是绿色或黄色格子。
- 黄色格子的**左边**只能是黄色格子，**下方**只能是黄色或绿色格子，**上方**只能是黄色或红色格子。



上图中展示了一些可能的染色方案，其中：

- 第一幅图是简单的。
- 第二幅图也是简单的。注意如果一种颜色的格子不存在，那么可以直接忽略对应要求。
- 第三幅图不是简单的，因为 $F(3,2)$ 绿色格子下方有 $G(4,2)$ 是黄色，不符合第四条要求。

若 $(i,j)$ 的颜色为红、橙、黄、绿，则这个格子的权值 $w_{i,j}$ 分别为 $1,2,3,4$。计算所有简单的方案中，$\sum\limits_{i=1}^n\sum\limits_{j=1}^m a_{i,j} w_{i,j}$ 的最大值。

## 说明/提示

**【样例解释 #1】**

![](https://cdn.luogu.com.cn/upload/image_hosting/zzc58sfc.png)

染色方案如上图所示。

**【数据范围】**

|测试点编号|$n,m\le$|特殊性质|
|:-:|:-:|:-:|
|$1\sim 3$|$4$||
|$4\sim 6$|$10$||
|$7\sim 11$|$500$||
|$12$|$2000$|$a_{i,j}\ge 0$|
|$13\sim 14$ |$1400$|$\vert a_{i,j}\vert \le 250$|
|$15\sim 20$|$2000$||

对于全体数据，保证 $1\le n,m\le 2000$，$|a_{i,j}|\le 10^9$。

## 样例 #1

### 输入

```
3 4
8 -2 -5 7
-4 6 -1 -3
5 1 4 3
```

### 输出

```
87
```

## 样例 #2

### 输入

```
10 10
-607544439 -979004727 -312554064 -699869702 666983975 -320873934 -942207367 -178682386 275703899 -502153774
410971617 -76369893 -359278237 275932972 -86448038 714539457 -54215653 -250390633 -543539625 929531007
718862112 -158262990 482471050 -836696543 791951750 239968249 -766605973 -759094194 -19007257 907151693
-348361375 170949857 -285590070 402599195 469840858 288238039 410877678 179198841 60474475 813298551
-49654250 -340449178 -818518909 981342312 -472457171 144738808 -78496024 119951006 719889194 589539617
-343916789 -102845130 647967162 178223670 -520096558 -701610878 769986590 -306817394 776077393 891533714
-652884066 743855180 513738054 837511580 -206701878 751808326 -442751338 507912998 -51199158 -548890634
-19583239 -517604006 -564570564 -853892671 738975088 851320757 -595055422 852889648 213674342 -548020267
779798717 -323958612 577597457 -318242425 57184511 189209789 347708858 891010501 322410555 -669564400
623568486 123756685 -925342948 -864544839 -83746874 680094424 335536285 -977426931 -724040964 -337707402
```

### 输出

```
26663074561
```

# 题解

## 作者：yummy (赞：14)

# D. Partition 官方题解

本题考察的主要知识点：

- 【4】动态规划的基本思路

### 读题

对于这题，读明白题是成功的一半。

结合给出的图形，我们不难发现，这个图的“红橙/黄绿分割线”和“红黄/橙绿分割线”分别单调。换言之，简单的染色方案应当满足：

1. 红色或橙色的格子的右边和上方都是红色或橙色。
2. 红色或黄色的格子的左边和上方都是红色或黄色。

---

上面两个条件的必要性是显然的，下面证明上面命题是题目要求的充分条件。

使用反证法不难证明如下两个结论：

3. 黄色或绿色的格子的左边和下方都是黄色或绿色。
4. 橙色或绿色的格子的右边和下方都是橙色或绿色。

接下来，使用结论 1,2 可推出题目要求的第 1 条，结论 1,4 可推出题目要求的第 2 条，结论 2,3 可推出题目要求的第 3 条，结论 3,4 可推出题目要求的第 4 条。

---

因此大概思路也就有了——红橙/黄绿分割线是从左上角，每次向右或向下走一步，走到右下角得到的路径，红黄/橙绿分割线是从右上角开始，每次向左或向下走一步，走到左下角得到的路径。我们 DP 这两条路径即可得到答案。

### 55 分做法

从上往下 DP。本题解中，我们规定网格交叉点 $(i,j)$ 表示的是格子 $(i,j)$ **左上角**的那个交叉点，特别地，最右侧的一排交叉点用 $(x,m+1)$ 表示，最下面一排用 $(n+1,y)$ 表示。

设 $f(i,l,r)$ 表示当前在第 $i$ 行，红橙/黄绿分割线在第 $l$ 列，红黄/橙绿分割线在第 $r$ 列的最大总和。同时设 $s_{i,x}$ 表示 $a_{i,1}+a_{i,2}+\ldots + a_{i,x}$，那么有转移方程：

- 当 $l\le r$ 时，分割线从左到右把网格分成黄、红、橙三块。$f(i,l,r)=\max(f(i,l-1,r), f(i,l,r+1), f(i-1,l,r)+2s_{i,m}-s_{i,r-1}+2s_{i,l-1})$。

- 当 $l>r$ 时，分割线从左到右把网格分成黄、绿、橙三块。

  $f(i,l,r)=\max(f(i,l-1,r), f(i,l,r+1), f(i-1,l,r)+2s_{i,m}+2s_{i,l-1}-s_{i,r-1})$。

### 100 分做法

我们把“红色、橙色、黄色、绿色的权值分别为 $1,2,3,4$”拆分成三步：

- 所有格子自动获得 $1$ 权值。
- 橙色、绿色格子增加 $1$ 权值。
- 黄色、绿色格子增加 $2$ 权值。

红黄/橙绿分界线和红橙/黄绿分界线是分别独立的。

使用 $s_{i,j}$ 表示 $(i,j)$ 以及其下方格子数字和。我们可以分别用一个二维 DP 来求出两个部分贡献的增加量最大值。时间复杂度 $O(nm)$，可以通过。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
long long s[2005][2005],f[2005][2005],g[2005][2005];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%lld",&s[i][j]);
	for(int i=n;i;i--)
		for(int j=1;j<=m;j++)
			s[i][j]+=s[i+1][j];
	long long S=0;
	for(int j=1;j<=m;j++)
		S+=s[1][j];
	memset(f,-0x3f,sizeof f);
	memset(g,-0x3f,sizeof g);
	f[0][1]=g[0][m+1]=0;
	for(int i=1;i<=n+1;i++){
		for(int j=1;j<=m+1;j++)
			f[i][j]=max(f[i-1][j],f[i][j-1]+s[i][j-1]);
		for(int j=m+1;j;j--)
			g[i][j]=max(g[i-1][j],g[i][j+1]+s[i][j]);
	}
	cout<<S+2*f[n+1][m+1]+g[n+1][1];
	return 0;
}
```

---

## 作者：wanglongye (赞：7)

~~这题是蓝？~~

~~昨天直播里问是不是必须得用dp做这道题的就是我……~~

## 思路

### 预处理（dp）

我们可以看出来，红、橙、黄、绿色把矩阵分成了 $4$ 个部分，每个部分**像**一个三角形一样（意思是不是三角形，看下面）。

以红色举例，设第 $1$ 列的红色格子的数量为 $a_1$，第 $2$ 列的红色格子的数量为 $a_2$，以此类推，则能找到一个整数 $x$ 满足 $1 \le x \le m$ 且 $a_1 \le a_2 \le \dots \le a_{x-1} \le a_x$，$a_x \ge a_{x+1} \ge \dots \ge a_{n-1} \ge a_n$，否则，必然违反规则，例如，如果像下图这样，则违反了**红色格子右边只能是红色或橙色格子**或**橙色格子的右边只能是橙色格子**的规则，橙色、黄色、绿色也一样（只不过橙色、黄色为每一行的格子数量）

![](https://cdn.luogu.com.cn/upload/image_hosting/m2pj73su.png)

假设有一条横着的线，线上面没有绿色，线下面没有红色，称这条线为红绿分割线，还有一条竖着的线，线左边没有橙色，线右面没有黄色，称这条线为黄橙分割线。这两条分割线将整个矩阵分成了四部分，左上部分**只有**红色和黄色，左下部分**只有**绿色和黄色，右下部分**只有**绿色和橙色，右上部分**只有**红色和橙色，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/d53zlnwu.png)

如果红绿分割线上方有绿或下方有红，则一定违反规则**红色格子左边只能是红色或黄色格子，右边只能是红色或橙色格子**或这个分割线不在这个位置，黄橙分割线也是左边有橙或右边有黄则违反规则**橙色格子上方只能是橙色或红色格子，下方只能是橙色或绿色格子**或分割线不在这个位置。

由于我们对于每一部分想让其分值尽量大，所以通过dp求出左上角涂成黄色的格子上的**数字和最大**是多少、左下角涂成黄色的格子上的**数字和最小**是多少、右下角涂成橙色的格子上的**数字和最小**是多少、右上角涂成橙色的格子上的**数字和最大**是多少（数字和可能是负数），另外我们需要通过二位前缀和减去一种颜色的格子上最大或最小数字和求出另一种颜色的格子上最小或最大的数字和。

### 枚举

枚举两条分割线的位置，分别计算四部分每种颜色的格子的数字和，乘上对应的权值再相加得到一个将矩阵分成四部分的答案，对于所有将矩阵分成四部分的答案取最大值就是整个测试点的答案。

代码较长时间复杂度为 $O(nm)$，常数较大，运行时间较长，但是能过。

## 代码
```cpp#include <cstdio>
#include <algorithm>
using namespace std;
const int N=2005;
int n,m;
long long a[N][N],lmax[N][N],rmax[N][N],lmin[N][N],rmin[N][N],lu[N][N],ru[N][N],ld[N][N],rd[N][N],sm,ans;
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) scanf("%lld",&a[i][j]);
	} 
	for(int i=1;i<=n;i++) {
		sm=0;
		for(int j=1;j<=m;j++) {
			sm+=a[i][j];
			lu[i][j]=lu[i][j-1]+lu[i-1][j]-lu[i-1][j-1]+a[i][j];//二维前缀和
			lmax[i][j]=max(lmax[i][j-1],lmax[i-1][j]+sm);//左上角涂成黄色的格子上的数字和最大值 
		}
		sm=0;
		for(int j=m;j>=1;j--) {
			sm+=a[i][j];
			ru[i][j]=ru[i][j+1]+ru[i-1][j]-ru[i-1][j+1]+a[i][j];
			rmax[i][j]=max(rmax[i][j+1],rmax[i-1][j]+sm);//右上角涂成橙色的格子上的数字和最大值 
		}
	}
	for(int i=n;i>=1;i--) {
		sm=0;
		for(int j=1;j<=m;j++) {
			sm+=a[i][j];
			ld[i][j]=ld[i+1][j]+ld[i][j-1]-ld[i+1][j-1]+a[i][j];
			lmin[i][j]=min(lmin[i][j-1],lmin[i+1][j]+sm);//左下角涂成黄色的格子上的数字和最小值 
		}
		sm=0;
		for(int j=m;j>=1;j--) {
			sm+=a[i][j];
			rd[i][j]=rd[i+1][j]+rd[i][j+1]-rd[i+1][j+1]+a[i][j];
			rmin[i][j]=min(rmin[i][j+1],rmin[i+1][j]+sm);//右下角涂成橙色的格子上的数字和最小值 
		}
	}
	ans=-1e18;
	for(int i=0;i<=n;i++) {
		for(int j=0;j<=m;j++) {
			ans=max(ans,lmax[i][j]*3+(lu[i][j]-lmax[i][j])*1+lmin[i+1][j]*3+(ld[i+1][j]-lmin[i+1][j])*4+rmin[i+1][j+1]*2+(rd[i+1][j+1]-rmin[i+1][j+1])*4+rmax[i][j+1]*2+(ru[i][j+1]-rmax[i][j+1])*1);//枚举并求最大值 
		}
	}
	printf("%lld\n",ans);
	return 0;
}
``````

---

## 作者：sbno333 (赞：5)

质量说不上来。

先理解题，四种颜色分别上下左右生根生长，然后两边除了自己的有要求。

梳理题意的时候我们会得到一些结论。

结论 $1$：对于根在对面的两种颜色，一定存在一条平行于根线的线，使得线的任意一段只有两个中的一种颜色。

假设不对，则存在两个格子，他们颜色的根对面，而且在同一平行于根的直线。

考虑不能相邻，否则不符合题意。

考虑中间是其他颜色，此时那个颜色会生根，然后会顶掉一个颜色，矛盾！所以得证。

这样会有两条分界线，它们交于一点，这个点也可以反过来确定分界线。

发现两条线分成了四个区域，每个区域只有两种颜色。

对于每个区域，我们继续看结论。

结论 $2$：落地生根的每个与根线垂直的距离跟最远的点距离根的距离是单峰的。

证明：假设不单峰，则存在两个同色位置，中间有其它颜色，不能是对面，另外两种会顶掉一个，得证。

每个区域只要区域内合法，全局合法，因为相邻位置的颜色只有自己或者应该的另一种颜色。

考虑区域内合法。

结论 $3$：区域内颜色单调。

证明：只要不是单峰即可得证。

假设单峰，则另一种颜色在峰的两个坡都有，然后因为落地生根，所以矛盾，得证。

于是都是单调的，大体如下面的样子：

```
...**
..***
..***
*****
```

我们发现在做的时候，每一个区域的所有可能包含的 $n\times m$ 区间都有，考虑提前预处理 DP。

我们以坐上角为例。

如果最后一个位置是红色，那么最后一列都肯定是红色，于是就是去掉最后一列的那个状态加上最后一列的和乘上红色权值。

另一种是最后一个位置是黄，同理，去掉最后一列的状态加上最后一列都黄的权值。

四个区域都类似。

然后枚举分界点，对于四个区域加权求最大值即可。

我们需要用到二位前缀和来处理某个区域都是某一颜色的贡献。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
int a[2009][2009];
int n,m;
int f[2009][2009];
int dp12[2009][2009];//上右 
int dp13[2009][2009];//上左
int dp24[2009][2009];//右下 
int dp34[2009][2009];//左下 
int sm(int lx,int ly,int rx,int ry){
	if(lx>rx){
		swap(lx,rx);
	}
	if(ly>ry){
		swap(ly,ry);
	}
	lx--,ly--;
	return f[rx][ry]-f[lx][ry]-f[rx][ly]+f[lx][ly];
}
signed main(){
	std::ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		} 
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1]+a[i][j];
		} 
	}
	for(int i=1;i<=n;i++){
		for(int j=m;j>=1;j--){
			dp12[i][j]=max(dp12[i-1][j]+2*sm(i,j,i,m),dp12[i][j+1]+1*sm(i,j,1,j));
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			dp13[i][j]=max(dp13[i-1][j]+3*sm(i,j,i,1),dp13[i][j-1]+1*sm(i,j,1,j));
		}
	}
	for(int i=n;i>=1;i--){
		for(int j=m;j>=1;j--){
			dp24[i][j]=max(dp24[i+1][j]+2*sm(i,j,i,m),dp24[i][j+1]+4*sm(i,j,n,j));
		}
	}
	for(int i=n;i>=1;i--){
		for(int j=1;j<=m;j++){
			dp34[i][j]=max(dp34[i+1][j]+3*sm(i,j,i,1),dp34[i][j-1]+4*sm(i,j,n,j));
		}
	}
	int ans;
	ans=-1e16;
	for(int i=0;i<=n;i++){
		for(int j=0;j<=m;j++){
			ans=max(ans,dp13[i][j]+dp12[i][j+1]+dp24[i+1][j+1]+dp34[i+1][j]);
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Kayisama (赞：4)

题意简述：

对于一个 $n$ 行 $m$ 列的格子图，第 $i$ 行第 $j$ 列的点有一权值 $a_{i,j}$。现在要求对格子图染色，四种颜色的有各自的权值（见原题面）每个位置的权值乘上所染颜色的权值后求和就是最终答案，同时，每个位置所染颜色有限制（具体见原题面）。

分析题目，我们针对染色的限制进行分析，我们会发现，颜色的分布要求是有规律的——黄色和绿色会被一条从左上角的格点到右下角的分割线与另外两种颜色所分割开，而橙色和绿色也会被一条从右上角到左下角的分割线与另外两种颜色所分割开。

我们换一种考虑问题的方式，对于一种颜色的贡献，其实就是这个颜色所在点的贡献之和连加这个点的权值次，我们发现上文提到的分割线正好可以用到。我们假设对在答案中加入一次某一颜色所在点的贡献之和是把这个颜色的积分加一，那么我们可以采用这种思考方式：

答案就是把每种颜色的积分都加一，把绿色和黄色的积分加二，把绿色和橙色的积分加一后的结果。

此时每个点的积分正好就是这个点的权值。我们对于这种计算方式，考虑使用 DP 计算分割线的选取来获得最优结果。

进行分析，对于第一条分割线（对于绿色的黄色的贡献和），我们每一次转移有两种选择：

1. 向右走一步，也就是列数会增加 $1$，同时会新加入增加的那一列的分割线下方的贡献。
2. 像下走一步，行数会增加 $1$，不会产生新的贡献。

对于第二条分割线（对于绿色和橙色的贡献和），我们只要把转移的方式中向右走变为向左走即可。

而对于计算分割线下方的贡献，我们可以对每一列求前缀和，这样就可以快速求出，总复杂度为 $O(nm)$。

我的代码:


```cpp
#include <bits/stdc++.h>
using namespace std;
#define lowbit(x) (x&(-x))
#ifdef ONLINE_JUDGE
#define getchar getchar_unlocked
#endif
inline void read() {}
template <typename T, typename... R>
inline void read(T &x,R &... oth){
    x=0;T f=1;
    char c=getchar();
    while(c<'0' || c>'9') {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(c>='0' && c<='9') x=(x<<1)+(x<<3)+(c&15),c=getchar();
    x*=f;
    read(oth...);
    return;
}
//考虑计算黄色和绿色，以及橙色和绿色的分割方式可以贡献的最大值
//考虑dp分割线
#define int long long
const int maxn=2005;
int n,m;
//f包括黄色和绿色 g包括橙色和绿色 
int s[maxn][maxn],f[maxn][maxn],g[maxn][maxn];
int sum;
signed main(){
	memset(f,-0x3f,sizeof f);
	memset(g,-0x3f,sizeof g);
	read(n,m);
	for (int i=1;i<=n;i++){
		for (int j=1;j<=m;j++){
			read(s[i][j]);
			sum+=s[i][j];//求全局和
		}
	}
	for (int i=n;i;i--)
		for (int j=1;j<=m;j++)
			s[i][j]+=s[i+1][j];//求前缀和
	f[0][1]=g[0][m+1]=0;//初始化
	for (int i=1;i<=n+1;i++){
		for (int j=1;j<=m+1;j++){
			//第i行第j列=max(从上面走下来的最大值,
			//				 从左边走过来+把当前列分割线下方染色的贡献)
			f[i][j]=max(f[i-1][j],f[i][j-1]+s[i][j-1]);
		}
		for (int j=m+1;j;j--){
			//第i行第j列=max(从上面走下来的最大值,
			//				 从右边走过来+把当前列分割线下方染色的贡献)
			g[i][j]=max(g[i-1][j],g[i][j+1]+s[i][j]);
		}
			
	}
	//四个积分各+1,黄色和绿色的积分+2,橙色和绿色的积分+1
	//=>  红1 橙2 黄3 绿4 
	printf("%lld",sum+2*f[n+1][m+1]+g[n+1][1]);
    return 0;
}
```

关于一个我自己也思考了很久的问题，这里进行解答：

Q：为什么 dp 加 s 的时候第二维一个需要减一，一个不需要？

A：我们这样想，我们把一个格子的列的范围看为 $[x,x+1)$ 这样一个区间，格子两边分别为 $x$ 和 $x+1$，我们显然是要选择为 $x$ 的那个的。而对于两个分割线，其中对应 $x$ 的 $j$ 分别是 $j-1$ 和 $j$，故这样写

还有注意开 long long！

[我的提交记录](https://www.luogu.com.cn/record/174755569)

---

## 作者：irris (赞：3)

## Preface

> 数学 / 观察，结论 / dp

$*1800$，$7.5$。很不幸有些地方撞了 [某道题](https://www.luogu.com.cn/problem/P6750)，但是我觉得出题人独立创造这个结论实属不易（

## Solution

![](https://cdn.luogu.com.cn/upload/image_hosting/l61o3iny.png)

考虑这个权值如何构造：我们可以写为 $\sum a_{i, j} + 2b + c$，其中 $b$ 表示 **黄、绿色** 格子的权值和，$c$ 表示 **橙、绿色** 格子的权值和。

容易发现，$b$ **只和** 从左上到右下的分割线形态有关，相当于一条 $(1, 1)$ 左上角到 $(n, m)$ 右下角分割线左下角部分的权值和；$c$ **只和** 从右上到左下的分割线形态有关，相当于一条 $(1, m)$ 右上角到 $(n, 1)$ 左下角分割线右下角部分的权值和。

容易证明这两条分割线的形态完全独立，因此可以分别施加 dp，$(f / g)_{i, j}$ 表示当前的分割线确定到格 $(i, j)$ 即可。

时间复杂度 $\mathcal O(nm)$。

---

## 作者：ELECTRODE_kaf (赞：2)

在只考虑一种颜色时，可以发现它的形状类似于一个三角形，存在一个峰（往左和往右在高度上分别不上升）。

我们通过枚举中心点将整个矩阵分成四个区域：

|  位置 | 包含颜色 |
| :-: | :--: |
|  左上 |  红黄  |
|  左下 |  黄绿  |
|  右上 |  红橙  |
|  右下 |  绿橙  |

在此之前，我们需要预处理对于每个区域在不同范围下的最大得分。

以左上为例：

设 $f_{i,j}$ 表示左上区域以 $(i,j)$ 为右下角的最大得分。有

$$f_{i,j}=\max(f_{i-1,j}+\sum^{j}_{k=1}3\cdot a_{i,k},f_{i,j-1}+\sum^{i}_{k=1}1\cdot a_{k,j})$$

分别对应第 $i$ 行全黄和第 $j$ 列全红的情况，而求和的部分可以用二维前缀和维护。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define rep(i,x,y) for(ll i=x;i<=y;i++)
#define IL inline

const ll N=3e3,inf=5000000000000000;
ll n,m,a[N][N],lu[N][N],ld[N][N],ru[N][N],rd[N][N],ans=-inf,ps[N][N];

IL ll read() {
	ll re=0,f=1;
	char in=getchar();

	while (in<'0'||in>'9') {
		if (in=='-') f=-1;

		in=getchar();
	}

	while (in>='0'&&in<='9') {
		re=re*10+in-48;
		in=getchar();
	}

	return re*f;
}

void cals() {
	ps[1][1]=a[1][1];

	rep(j,2,m) {
		ps[1][j]=ps[1][j-1]+a[1][j];
	}

	rep(i,2,n) {
		ps[i][1]=ps[i-1][1]+a[i][1];
	}

	rep(i,2,n) {
		rep(j,2,m) {
			ps[i][j]=ps[i-1][j]+ps[i][j-1]-ps[i-1][j-1]+a[i][j];
		}
	}
}

ll cal(ll x1,ll x2,ll y1,ll y2) {
	return ps[x2][y2]-ps[x1-1][y2]-ps[x2][y1-1]+ps[x1-1][y1-1];
}

/*
  红
黄  橙
  绿
红1
橙2
黄3
绿4
*/

void ptt() {
	rep(i,1,n) {
		rep(j,1,m) {
			lu[i][j]=max(lu[i-1][j]+3*cal(i,i,1,j),lu[i][j-1]+1*cal(1,i,j,j));
		}
	}

	for(ll i=n; i>0; i--) {
		rep(j,1,m) {
			ld[i][j]=max(ld[i+1][j]+3*cal(i,i,1,j),ld[i][j-1]+4*cal(i,n,j,j));
		}
	}

	rep(i,1,n) {
		for(ll j=m; j>0; j--) {
			ru[i][j]=max(ru[i-1][j]+2*cal(i,i,j,m),ru[i][j+1]+1*cal(1,i,j,j));
		}
	}

	for(ll i=n; i>0; i--) {
		for(ll j=m; j>0; j--) {
			rd[i][j]=max(rd[i+1][j]+2*cal(i,i,j,m),rd[i][j+1]+4*cal(i,n,j,j));
		}
	}
}

int main() {
	n=read();
	m=read();

	rep(i,1,n) {
		rep(j,1,m) {
			a[i][j]=read();
		}
	}

	cals();
	ptt();

	rep(i,0,n) {
		rep(j,0,m) {
			ans=max(ans,lu[i][j]+ld[i+1][j]+ru[i][j+1]+rd[i+1][j+1]);
		}
	}

	cout<<ans;
}
```

---

## 作者：ZHR100102 (赞：2)

# 观察

首先观察样例，发现整张图可以看作是被两条线分隔开的。同时每个颜色的四个方向上又存在一大堆奇怪的性质，很容易发现这两条线一条是从左上到右下的线，另一条是从右下到左上的线。

# 暴力 dp

有了这两条线，并且发现这两条线**一定不会往回走**（比如往上走的线，不会在某个地方往下走），即无后效性，那么我们就可以暴力 dp 了。

设计 $dp_{i,j,k}$ 表示在第 $i$ 行时，两条线分别在第 $j$ 列与第 $k$ 列时的最大值。

然后暴力转移一下就好了，这种做法还要对两条线的位置关系进行分讨转移，比较麻烦，复杂度又高，因此我们需要从另一个角度考虑 dp。

# 正解

我们观察每个颜色各自的贡献，可以发现，红色的权值为 $1$，且其他颜色的权值都比 $1$ 大。因此我们可以把染色的过程看作先把每个数涂上红色，然后其他颜色的权值减小了 $1$，再来 dp。

这样以后橙色的权值为 $1$，黄色的权值为 $2$，绿色的权值为 $3$。再来观察图的形态，可以发现橙色和绿色是连在一起的。所以我们可以把橙色和绿色的部分统一先填上色，过程就和上面暴力 dp 一样，从右上到左下进行 dp，只不过我们只需要维护一条线的路线，复杂度降低了很多。

从右上到左下具体的转移方程如下：

$$dp_{i,j}=\max(dp_{i-1,j}+f_{i,m}-f_{i,j-1},dp_{i,j+1}+a_{i,j})$$

其中 $f_{i,j}$ 表示第 $i$ 行的前缀和数组，$a_{i,j}$ 表示第 $i$ 行第 $j$ 列的元素。 

最后黄色和绿色的权值都变成 $2$ 了，因为他们两个依然是相邻的，所以我们可以从左上到右下做一次 dp，做最后一次涂色，统计进答案就好了。

一共做了两次 dp，时间复杂度为 $O(nm)$。

# 代码

在实现上我们在 dp 时可以多进行一次，这样统计答案时就不用一个一个取最大值，只需要取最后转移到的地方就好了。

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define lc (p<<1)
#define rc ((p<<1)|1)
using namespace std;
typedef long long ll;
typedef pair<int,int> pi;
int n,m;
ll a[2005][2005],dp1[2005][2005],dp2[2005][2005],ans=0,f[2005][2005];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>a[i][j];
			ans+=a[i][j];
			f[i][j]=f[i][j-1]+a[i][j];
		}
	}
	memset(dp1,-0x3f,sizeof(dp1));
	memset(dp2,-0x3f,sizeof(dp2));
	for(int i=1;i<=m+1;i++)dp1[0][i]=dp2[0][i]=0;
	for(int i=1;i<=n+1;i++)
	{
		for(int j=m+1;j>=1;j--)
		{
			dp1[i][j]=max(dp1[i-1][j]+f[i][m]-f[i][j-1],dp1[i][j+1]+a[i][j]);
		}
		for(int j=1;j<=m+1;j++)
		{
			dp2[i][j]=max(dp2[i-1][j]+f[i][j-1],dp2[i][j-1]+a[i][j-1]);	
		}
	}
	cout<<ans+dp1[n+1][1]+2*dp2[n+1][m+1];
	return 0;
}
```

# 总结

这题的状态设计难点主要在想到以分割线的形态做 dp 和把不同颜色的贡献拆开来，其他就是代码实现的细节了。

---

## 作者：WaTleZero_pt (赞：1)

讲题目之前，我觉得还是有必要强调一下：**十年 OI 一场空，不开 long long 见祖宗！** ~~这个愚蠢的萌新做题时因为前缀和函数值返回 int 没发现调了 45min！~~

言归正传，我们开始讲题。

首先我们先只考虑绿色，其他全部视为白色。我们会发现。这个颜色构成的图案像一个简单的“山峰”，令第 $i$ 列的高度为 $x_{i}$，则至少存在一个点 $p$，满足 $x_{1} \leq x_{2} \leq \cdots \leq x_{p} \geq x_{p+1} \geq ... \geq x_{m}$。其他颜色同理，只是把“山峰”旋转一个角度就好了。

注意到这点，我们一定可以通过画一条横线和一条竖线把整个答案最优的矩阵分成 $4$ 小块，每一个小块只有两种颜色。这样子就好办了许多。我们只需要预处理左上块，左下块，右上块，右下块所能得到的最大答案，再枚举分割线即可。

如何求每一小块的值呢？我们以左上块（红色和黄色）为例。令 $w_{i,j}$ 为以 $(i,j)$ 作为右下角的矩阵最大值。显然，如果要符合要求，要么第 $i$ 行全是黄色格子，要么第 $j$ 列全是红色格子。这样状态转移方程已经很明显了了。即 $w_{i,j}=\max(w_{i-1,j}+\sum\limits_{k=1}^{j}3a_{i,k},w_{i,j-1}+ \sum\limits_{k=1}^{i}a_{k,j})$。注意到这样的转移时间复杂度是 $O(n^3)$ （假定 $n,m$ 同阶，你可以理解为 $n \approx m$）的，采用二维前缀和（一位前缀和也可以，就是要开两个，一个记录行，一个记录列）即可优化到 $O(n^2)$。左下块，右上块和右下块的做法与左上块基本一致。

到这里就讲完了。这里上核心代码：

```cpp
for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			a[i][j]=max(a[i-1][j]+3*s(i,1,i,j),a[i][j-1]+1*s(1,j,i,j));
	//左上 
	for(int i=n;i>=1;i--)
		for(int j=1;j<=m;j++)
			b[i][j]=max(b[i+1][j]+3*s(i,1,i,j),b[i][j-1]+4*s(i,j,n,j));
	//左下 
	for(int i=1;i<=n;i++)
		for(int j=m;j>=1;j--)
			c[i][j]=max(c[i-1][j]+2*s(i,j,i,m),c[i][j+1]+1*s(1,j,i,j));
	//右上 
	for(int i=n;i>=1;i--)
		for(int j=m;j>=1;j--)
			d[i][j]=max(d[i+1][j]+2*s(i,j,i,m),d[i][j+1]+4*s(i,j,n,j));
	//右下 
	for(int i=0;i<=n;i++)
		for(int j=0;j<=m;j++)
			ans=max(ans,a[i][j]+b[i+1][j]+c[i][j+1]+d[i+1][j+1]);
	//求解答案 
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P10997)

**题目大意**

> 你有 $n$ 行 $m$ 列的一个矩阵，第 $i$ 行第 $j$ 列的格子（记作 $(i,j)$）上写有一个整数 $a_{i,j}$，你可以把所有格子染上红、橙、黄、绿四种颜色之一。
>
> - 红色格子的**上方**只能是红色格子，**左边**只能是红色或黄色格子，**右边**只能是红色或橙色格子。
> - 橙色格子的**右边**只能是橙色格子，**上方**只能是橙色或红色格子，**下方**只能是橙色或绿色格子。
> - 绿色格子的**下方**只能是绿色格子，**右边**只能是绿色或橙色格子，**左边**只能是绿色或黄色格子。
> - 黄色格子的**左边**只能是黄色格子，**下方**只能是黄色或绿色格子，**上方**只能是黄色或红色格子。
>
> 四种颜色的权值分别为 $1,2,3,4$，记 $w_{i,j}$ 为 $(i,j)$ 所染颜色的权值，最大化 $\sum w_{i,j}\times a_{i,j}$。
>
> 数据范围：$n,m\le 2000$。

**思路分析**

这个做法可以解决 $f(c,i,j)$ 任意给定的情况，其中 $f(c,i,j)$ 表示方格 $(i,j)$ 染颜色 $c$ 的代价。

容易注意到，“红格子加绿格子将网格分成左右两部分”或“黄格子加橙格子将网格分成上下两部分”至少有一个条件成立。

不妨设红格子加绿格子能将网格分成左右两部分，剩余的情况可以旋转网格解决，那么一定存在 $(i,j)$，使得 $(i,j)$ 被染黄，且 $(i+1,j+1)/(i+1,j)/(i+1,j+1)$ 至少有一个被染橙。

设 $(i+1,j)$ 被染橙，那么原问题就变成了 $[1,i]\times [1,j],[1,i]\times (j,m],(i,n]\times [1,j],(i,n]\times (j,m]$ 四个子矩形中分别要选择一个阶梯型区域染色，可以分别简单 dp 求出。

时间复杂度 $\mathcal O(nm)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=2005;
const ll inf=4e18;
ll z[MAXN][MAXN],tmp[MAXN][MAXN],S[MAXN][MAXN];
ll a[MAXN][MAXN],b[MAXN][MAXN],c[MAXN][MAXN],d[MAXN][MAXN],tot[MAXN];
ll l[MAXN],r[MAXN],t[MAXN];
ll solve(int n,int m,int U,int D,int L,int R) {
	memset(S,0,sizeof(S)),memset(tot,0,sizeof(tot));
	ll ans=-inf;
	for(int i=1;i<=n;++i) {
		for(int j=1;j<=m;++j) S[i][j]=S[i][j-1]+z[i][j];
		tot[i]=tot[i-1]+S[i][m];
	}
	memset(a,0,sizeof(a)),memset(b,0,sizeof(b));
	memset(c,0,sizeof(c)),memset(d,0,sizeof(d));
	for(int i=n;i>=1;--i) {
		ll w=0;
		for(int j=1;j<=m;++j) w=max(w,c[i+1][j]),c[i][j]=w+(L-D)*S[i][j];
		w=0;
		for(int j=m;j>=1;--j) w=max(w,d[i+1][j]),d[i][j]=w+(R-D)*(S[i][m]-S[i][j-1]);
	}
	for(int i=1;i<=n;++i) {
		ll w=0;
		for(int j=1;j<=m;++j) w=max(w,a[i-1][j]),a[i][j]=w+(L-U)*S[i][j];
		w=0;
		for(int j=m;j>=1;--j) w=max(w,b[i-1][j]),b[i][j]=w+(R-U)*(S[i][m]-S[i][j-1]);
		memset(l,0,sizeof(l)),memset(l,0,sizeof(l));
		for(int j=1;j<=m;++j) l[j]=max(l[j-1],c[i+1][j]);
		for(int j=m;j>=1;--j) r[j]=max(r[j+1],d[i+1][j]);
		for(int j=0;j<=m;++j) ans=max(ans,a[i][j]+b[i][j+1]+l[j]+r[j+1]+tot[i]*U+(tot[n]-tot[i])*D);
		if(i==n) break;
		memset(t,0,sizeof(t));
		for(int j=m;j>=1;--j) t[j]=max(t[j+1],b[i][j]);
		for(int j=1;j<m;++j) ans=max(ans,a[i][j]+d[i+1][j+1]+l[j]+t[j+1]+tot[i]*U+(tot[n]-tot[i])*D);
		memset(t,0,sizeof(t));
		for(int j=1;j<=m;++j) t[j]=max(t[j-1],a[i][j]);
		for(int j=1;j<m;++j) ans=max(ans,b[i][j+1]+c[i+1][j]+t[j]+r[j+1]+tot[i]*U+(tot[n]-tot[i])*D);
	}
	return ans;
}
signed main() {
	ios::sync_with_stdio(false);
	int n,m; cin>>n>>m;
	for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) cin>>z[i][j],tmp[j][i]=z[i][j];
	ll ans=solve(n,m,1,4,3,2);
	swap(z,tmp);
	ans=max(solve(m,n,3,2,1,4),ans);
	cout<<ans<<"\n";
	return 0;
}
```

---


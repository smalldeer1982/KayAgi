# 【MX-X6-T4】夢重力

## 题目背景

原题链接：<https://oier.team/problems/X6E>。

---

> _空を仰げば$\\$
青さが僕を$\\$
飲み込んでしまう気がしてて$\\$
無重力なら楽だろうか$\\$
宇宙まで行けたら_
>
> _—— [夢重力 - Nanatsukaze](https://music.163.com/#/song?id=2155399298)_

在天体的随机运转中，如何找到一个没有重力的点呢？

## 题目描述

给定一个 $n\times n$ 的网格，其中有 $n$ 个关键点，保证每行每列各有一个关键点。保证 $n$ 是偶数。

我们定义网格中的一个无重力区域为网格的连续的 $\dfrac{n}{2}$ 行和连续的 $\dfrac{n}{2}$ 列构成的大小为 $\dfrac{n}{2}\times \dfrac{n}{2}$ 的子正方形，使得其中不包含任意关键点。

定义 $f(i,j)$ 为交换网格的第 $i$ 行和第 $j$ 行后，不同的无重力区域个数。请对于所有可能的交换求 $f(i,j)$ 的和，即你需要求：

$$\sum_{1\leq i<j\leq n}f(i,j)$$

注意求 $f$ 并不会真正在网格中执行交换，整个过程中不会对网格进行任何修改。

## 说明/提示

**【样例解释 #1】**

![](https://cdn.luogu.com.cn/upload/image_hosting/49w2x0r4.png)

上图中，左上角对应原网格。灰色的部分表示关键点。

下面的 $6$ 个网格分别对应所有可能的交换产生的网格（依次为交换 $(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)$），并使用红色和蓝色标出存在的无重力区域（紫色的位置表示两个无重力区域的交）。不难看出答案为 $2+2+0+0+2+2=8$。

**【数据范围】**

对于所有数据，保证 $2\leq n\leq 2\times 10^5$ 且 $n$ 是偶数，保证 $p$ 是一个排列。

**捆绑测试**，共 4 个 Subtask，具体限制如下所示：

- Subtask 1（12 pts）：$n\leq 10$；
- Subtask 2（19 pts）：$n\leq 200$；
- Subtask 3（34 pts）：$n\leq 2000$；
- Subtask 4（35 pts）：无特殊限制。

## 样例 #1

### 输入

```
4
1 2 3 4```

### 输出

```
8```

## 样例 #2

### 输入

```
10
9 8 1 10 7 2 4 3 6 5```

### 输出

```
27```

# 题解

## 作者：vme50xiex2 (赞：12)

容易想到对于每个子矩形，考虑有多少种交换方案能使其合法。

显然，合法需要初始时至多只有一个关键点。分别讨论两种情况，下面令 $m = \dfrac{n}{2}$，$l$ 和 $r$ 表示这个子矩形的上下边界，$a$ 和 $b$ 表示左右边界。 

1. 初始没有关键点。由于 $p$ 构成一个排列，所以此时 $[l, r]$ 以外的 $p_i$ 都在 $[a,b]$ 之间。合法只能交换 $[l, r]$ 内的两个点或者外部的两个点，方案数是 $2\dbinom{m}{2} = m(m-1)$。
2. 初始只有一个关键点，此时 $[l,r]$ 外部只有一个关键点 $p_i \notin [a,b]$，方案数是 1。

枚举上下边界 $l,r$，只用求出当前有多少矩形没有关键点和只有一个关键点。前者可以由相邻关键点之间的间隙得到，后者可以由每个关键点的左右间隙得到。

用 set 维护所有关键点的 y 坐标，加入和删除一个点时只有当前点以及左右相邻点会有影响，直接统计即可。

```cpp
// They say that life is always easier
// After you let yourself come undone
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstring>
#include <vector>
#include <set>
using namespace std;
using ll = long long;
const int N = 2e5 + 10;
const int MOD = 998244353;
int n, m, a[N], x, y;
ll ans;
set<int> st;
// 统计没有关键点的方案数
void Calc(int len, int k) { 
	if(len >= m) x += k * (len - m + 1);
}
// 统计只有一个关键点的方案数，it 是这个关键点
void Get(set<int>::iterator it, int k) { 
	if(*it < 1 || *it > n) return ;
	int l = *prev(it), p = *it, r = *next(it);
	if(r - l - 1 < m) return ;
	int lef = max(l + 1, p - m + 1);
	int rig = min(p, r - m);
	y += k * (rig - lef + 1);
}
void Add(int k) {
	auto it = st.lower_bound(k);
	int l = *prev(it), r = *it;
	Calc(r - l - 1, -1), Get(prev(it), -1);
	Calc(k - l - 1, 1), Get(it, -1);
	Calc(r - k - 1, 1);
	st.insert(k);
	it = st.find(k);
	Get(prev(it), 1);
	Get(next(it), 1);
	Get(it, 1);
}
void Del(int k) {
	auto it = st.find(k);
	int l = *prev(it), r = *next(it);
	Calc(r - l - 1, 1), Get(prev(it), -1);
	Calc(k - l - 1, -1), Get(next(it), -1);
	Calc(r - k - 1, -1), Get(it, -1);
	auto tl = prev(it), tr = next(it);
	st.erase(it);
	Get(tl, 1), Get(tr, 1);
}
void Solve() {
	cin >> n, m = n / 2;
	for(int i = 1; i <= n; ++i) cin >> a[i];
	st.insert(0), st.insert(n + 1);
	x = m + 1;
	for(int i = 1; i <= m; ++i) 
		Add(a[i]);
	for(int i = m; i <= n; ++i) {
		ans += 1ll * x * m * (m - 1) + y;
		if(i != n) {
			Add(a[i + 1]);
			Del(a[i - m + 1]);
		}
	}
	printf("%lld\n", ans);
}
int main() {
	cin.tie(0)->sync_with_stdio(0);
	int t = 1; //cin >> t;
	while(t--) Solve();
	return 0;
}
```

---

## 作者：Alphas (赞：6)

感觉很厉害的一个题。

以下令 $m = \frac n2$，我们先简单说明一个结论：如果纵坐标在 $[x, x + m - 1]$，横坐标在 $[y, y + m - 1]$ 的区域是无重力的，那么所有关键点要么纵坐标在 $[x, x + m - 1]$，要么横坐标在 $[y, y + m + 1]$。原因也很简单，我们对点的个数算两次，总点数为 $n$，由于每行每列至多有一个关键点，所以纵坐标在 $[1, x - 1]\cup[x + m, n]$ 的点的个数最多为 $m$，同理横坐标在 $[1, y - 1]\cup[y + m, n]$ 的点的个数最多也为 $m$，总点数最多为 $m+m=n$，那么两部分显然不能交，只能是如上结论的形式分布。如果实在不懂可以自己画个九宫格理解一下。

发现如果直接去交换这个事情是困难的，考虑算贡献，具体而言，考虑每个 $m\times m$ 的区域在对 $(i, j)$ 中对答案造成了贡献。同样，我们令其为纵坐标在 $[x, x + m - 1]$，横坐标在 $[y, y + m - 1]$ 的区域。

* 如果该区域中最开始出现了 $\ge 2$ 个关键点，那么我们后续最多只能把一个换出去，仍然会剩下一个，因此对答案没有贡献；
* 如果该区域中最开始出现了 $1$ 个关键点，那么我们需要在后续换出去这个点，由最开始所讲的结论的推广，具体而言就是说中间有 $t$ 个关键点的时候九宫格四个角将一共恰有 $t$ 个关键点。那么在这种情况下四个角共有一个关键点，由结论，为了交换后是合法的了，只能拿那一个跟这个换，故对答案造成 $1$ 的贡献；
* 如果该区域中最开始就出现了 $0$ 个关键点，即无重力，那么由结论，只能选择 $(i, j)\in [1, x - 1]\cup[x + m, n]$ 或 $(i, j)\in [x, x + m - 1]$，共有 $\frac {m\times (m - 1)}{2}\times 2$ 对，故对答案产生 $m\times (m - 1)$ 的贡献。

综上，我们设最开始有一个关键点的区域共 $c_1$ 个，最开始无重力的区域共 $c_0$ 个，答案为 $c_1 + c_0\times m\times (m - 1)$。

如何计算 $c_1, c_0$，我们做一个双指针维护当前纵坐标属于 $[x, x + m - 1]$ 的所有点其横坐标可以为那些值，注意到这东西仍然不是很好统计答案，因此我们变为直接维护横坐标分别为 $[1, m], [2, m + 1]\cdots [m + 1, n]$ 的位置的关键点个数之和，双指针的过程相当于区间加减一，统计答案过程相当于查询全局 $0$ 的个数以及 $1$ 的个数，分块打 lazytag 维护即可，参考 LOJ 数列分块入门 3。

代码很简单，不放了，注意打 lazytag 后查询时下标不要越界即可。时间复杂度为 $\Theta(n\sqrt n)$，有个 $\frac{\sqrt 2}4$ 的常数。

---

## 作者：meyi (赞：4)

对于长度为 $\frac{n}{2}$ 的行的连续段，将它们的关键点对应的列排序，那么无重力区域存在等价于列排序后可以被分为两个部分，一部分是 $[1,n]$ 的前缀（可以为空），一部分是 $[1,n]$ 的后缀（可以为空）。

先说直接维护这个东西的做法：

将 $p$ 分成 $p_i\le\frac{n}{2}$ 和 $p_i>\frac{n}{2}$ 两个部分，维护当前行连续段中 $p_i\le\frac{n}{2}$ 中最大的存在的数和最小的不存在的数，$p_i>\frac{n}{2}$ 中最小的存在的数和最大的不存在的数。那么无重力区域存在等价于 $p_i\le\frac{n}{2}$ 中最大的存在的数等于 $p_i\le\frac{n}{2}$ 的数的数量，且 $p_i>\frac{n}{2}$ 中最小的存在的数等于 $n+1$ 减去 $p_i>\frac{n}{2}$ 的数的数量。显然有些边界情况需要考虑，读者可自行思考。

一个行连续段内部的行互相交换和外部的行互相交换后无重力区域是否存在与交换前相同，因此若本来就存在无重力区域，那么它会对答案造成 $2\times\frac{\frac{n}{2}(\frac{n}{2}-1)}{2}=\frac{n}{2}(\frac{n}{2}-1)$ 的贡献。

接下来只需考虑内部的行与外部的行交换后是否存在无重力区域。

显然不在前后缀上的 $p_i$ 会破坏无重力区域，若这样的 $p_i$ 存在，那么 $p_i\le\frac{n}{2}$ 中最小的不存在的数和 $p_i>\frac{n}{2}$ 中最大的不存在的数至少有一个是这样的 $p_i$，若不将它们交换到前后缀上，那么一定不存在无重力区域，因此只能交换上述两个数。

若 $p_i$ 已经在前后缀上，且它不是 $p_i\le\frac{n}{2}$ 中最大的存在的数或 $p_i>\frac{n}{2}$ 中最小的存在的数，那么交换 $p_i$ 一定会使上述两个数变得不再前后缀上，因此只能交换上述两个数。

由此易得若需使区间合法，最多只有 $2\times 2=4$ 种交换方式，对每种判断一下是否造成贡献即可。

用 set 或可删堆维护，时间复杂度 $O(n\log n)$。

代码有点长，贴在最后。

再说另一种简单很多的方式：

正难则反，考虑当前行连续段中 $p_i$ 的补集，显然无重力区域存在等价于补集是一个长为 $\frac{n}{2}$ 的连续段。因此只维护补集，考虑补集中的数对答案的影响：

- 最大值减去最小值等于 $\frac{n}{2}$。本身就合法，对答案造成 $\frac{n}{2}(\frac{n}{2}-1)$ 的贡献。

- 次大值减去最小值等于 $\frac{n}{2}-1$。若最大值不是次大值加一则可以将最大值和次大值加一交换，对答案造成 $1$ 的贡献。若最小值不是 $1$ 则可以将最大值和最小值减一交换，对答案造成 $1$ 的贡献。

- 次大值减去最小值等于 $\frac{n}{2}$。将最大值和区间中缺的那个数交换即可，对答案造成 $1$ 的贡献。

- 最大值减去次小值等于 $\frac{n}{2}-1$。若最小值不是次小值减一则可以将最小值和次小值减一交换，对答案造成 $1$ 的贡献。若最大值不是 $n$ 则可以将最小值和最大值加一交换，对答案造成 $1$ 的贡献。

- 最大值减去次小值等于 $\frac{n}{2}$。将最小值和区间中缺的那个数交换即可，对答案造成 $1$ 的贡献。

用 set 或可删堆维护，时间复杂度 $O(n\log n)$。

第二种做法的代码：

```cpp
#include<bits/stdc++.h>
int main(){
    int n;
    scanf("%d",&n);
    std::vector<int>a(n);
    for(int &i:a)scanf("%d",&i);
    int m=n>>1;
    std::set<int>s;
    for(int i=m;i<n;++i)s.insert(a[i]);
    int ans=0,cnt=0;
    auto calc=[&](){
        int L=*s.begin(),R=*s.rbegin();
        if(R-L+1==m)ans-=2,++cnt;
        int r=R-*next(s.begin())+1;
        if(r==m-1)ans+=1+(R!=n);
        else if(r==m)++ans;
        int l=*next(s.rbegin())-L+1;
        if(l==m-1)ans+=1+(L!=1);
        else if(l==m)++ans;
    };
    for(int i=m;i<n;++i)calc(),s.erase(a[i]),s.insert(a[i-m]);
    calc();
    printf("%lld\n",ans+1ll*cnt*m*(m-1));
    return 0;
}
```

第一种做法的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
//#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops")
#define ALL(v) v.begin(),v.end()
#define For(i,_) for(int i=0,i##end=_;i<i##end;++i) // [0,_)
#define FOR(i,_,__) for(int i=_,i##end=__;i<i##end;++i) // [_,__)
#define Rep(i,_) for(int i=(_)-1;i>=0;--i) // [0,_)
#define REP(i,_,__) for(int i=(__)-1,i##end=_;i>=i##end;--i) // [_,__)
typedef long long ll;
typedef unsigned long long ull;
#define V vector
#define pb push_back
#define pf push_front
#define qb pop_back
#define qf pop_front
#define eb emplace_back
typedef pair<int,int> pii;
typedef pair<ll,int> pli;
#define fi first
#define se second
const int dir[4][2]={{-1,0},{0,1},{1,0},{0,-1}},inf=0x3f3f3f3f,mod=1e9+7;
const ll infl=0x3f3f3f3f3f3f3f3fll;
template<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,1:0;}
template<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,1:0;}
int init=[](){return cin.tie(nullptr)->sync_with_stdio(false),0;}();
template<class T,class U=less<T>>
struct delpq{
    priority_queue<T,V<T>,U>q1,q2;
    inline delpq(){}
    inline delpq(const U &func){priority_queue<T,V<T>,U>(func).swap(q1),priority_queue<T,V<T>,U>(func).swap(q2);}
    inline void push(const T &x){q1.push(x);}
    inline void pop(const T &x){q2.push(x);}
    inline T top(){
        while(q2.size()&&q1.top()==q2.top())q1.pop(),q2.pop();
        assert(q1.size());
        return q1.top();
    }
    inline bool empty(){return q1.size()==q2.size();}
    inline int size(){return q1.size()-q2.size();}
};
int main(){
    int t_case=1;
    //scanf("%d",&t_case);
    while(t_case--){
        int n;
        scanf("%d",&n);
        V<int>a(n);
        for(int &i:a)scanf("%d",&i),--i;
        int m=n>>1;
        delpq<int>d2,q1;
        delpq<int,greater<int>>d1,q2;
        For(i,m)d1.push(i),d2.push(m+i);
        For(i,m){
            if(a[i]<m)d1.pop(a[i]),q1.push(a[i]);
            else d2.pop(a[i]),q2.push(a[i]);
        }
        auto check=[&](){return d1.empty()||d2.empty()||(q1.top()+1==q1.size()&&q2.top()==n-q2.size());};
        auto swap_check=[&](int x,int y){
            if(x<m)q1.pop(x),d1.push(x);
            else q2.pop(x),d2.push(x);
            if(y<m)d1.pop(y),q1.push(y);
            else d2.pop(y),q2.push(y);
            bool ret=check();
            if(x<m)d1.pop(x),q1.push(x);
            else d2.pop(x),q2.push(x);
            if(y<m)q1.pop(y),d1.push(y);
            else q2.pop(y),d2.push(y);
            return ret;
        };
        int ans=0,cnt=0;
        // For(j,m)FOR(k,m,n)ans+=swap_check(a[j],a[k]);
        if(d1.size()){
            ans+=swap_check(q2.top(),d1.top());
            if(q1.size())ans+=swap_check(q1.top(),d1.top());
        }
        if(d2.size()){
            ans+=swap_check(q1.top(),d2.top());
            if(q2.size())ans+=swap_check(q2.top(),d2.top());
        }
        cnt+=check();
        FOR(i,m,n){
            if(a[i-m]<m)q1.pop(a[i-m]),d1.push(a[i-m]);
            else q2.pop(a[i-m]),d2.push(a[i-m]);
            if(a[i]<m)d1.pop(a[i]),q1.push(a[i]);
            else d2.pop(a[i]),q2.push(a[i]);
            // FOR(j,i-m+1,i+1)For(k,n)if(k<=i-m||k>i)ans+=swap_check(a[j],a[k]);
            if(d1.size()){
                ans+=swap_check(q2.top(),d1.top());
                if(q1.size())ans+=swap_check(q1.top(),d1.top());
            }
            if(d2.size()){
                ans+=swap_check(q1.top(),d2.top());
                if(q2.size())ans+=swap_check(q2.top(),d2.top());
            }
            cnt+=check();
        }
        // printf("%d %d\n",ans,cnt);
        printf("%lld\n",ans+1ll*cnt*m*(m-1));
    }
    return 0;
}
```

---

## 作者：SFlyer (赞：4)

可爱的卡了我 1h 的题。

首先考虑没有交换，怎么求出 $i\sim i+\frac{n}{2}-1$ 这些行对应的某些列可不可行。发现有这 $\frac{n}{2}$ 行不能对应特定的 $\frac{n}{2}$ 列，必须对应其他 $\frac{n}{2}$ 列。那么，$i\sim i+\frac{n}{2}-1$ 这些行对应的列必须空出一格区间，长度为 $\frac{n}{2}$。

那么问题就变成了，求所有交换后，对于交换后 $q_1,q_2,\cdots ,q_n$，多少个长度 $\frac{n}{2}$ 的子段中的数设为 $x_1\sim x_{n/2}$，满足 $x_1=1,x_{n/2}=n$，存在 $k$ 使得 $x_1\sim x_k$ 和 $x_{k+1}\sim x_{n/2}$ 连续。

可以“交换求和”，对于每一个 $x$ 求出贡献。现在问题变成了，给定一个长度为 $n$ 的数组，每一格是黑色或者白色，各占一半。求有多少种交换方式使得所有黑色连续。分类讨论即可。

```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;

const int N = 2e5+5;

int n,p[N],id[N];
set<int> st;
ll ans;

void cal(){
	auto l=(*st.begin());
	auto r=(*st.rbegin());
	if (r-l+1==n/2){
		ans+=1ll*(n/2)*(n/2-1)+(l!=1)+(r!=n);
	}
	else{
		auto it=st.begin();
		it++;
		if (r-(*it)+1==n/2-1) ans+=(r!=n)+1;
		if (r-(*it)+1==n/2) ans+=1;
		it=st.end();
		it--;
		it--;
		if ((*it)-l+1==n/2-1) ans+=(l!=1)+1;
		if ((*it)-l+1==n/2) ans+=1;
	}
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);

	cin>>n;
	for (int i=1; i<=n; i++){
		cin>>p[i];
		id[p[i]]=i;
	}
	if (n==2) return cout<<2<<"\n",0;
	for (int i=1; i<=n/2; i++){
		st.insert(id[i]);
	}
	cal();
	for (int i=1; i<=n/2; i++){
		st.erase(id[n/2-i+1]);
		st.insert(id[n-i+1]);
		cal();
	}
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：shuqiang (赞：3)

### 31 分做法

可以直接暴力枚举有哪两个点交换，然后可以先求出每一列有多少个连续出现的空地，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/hfzhzlmr.png)

然后找到有连续 $\dfrac{n}{2}$ 个大于等于 $\dfrac{n}{2}$ 的数就算一个正方形，时间复杂度 $\mathcal{O}(n^4)$。

### 65 分做法

观察上一张图，可以发现数字 $1$ 所在的格子一定检测不出正方形，这是因为 $1 < \dfrac{n}{2}$，因此，我们可以把小于 $\dfrac{n}{2}$ 的全部看成关键点，然后找到大小为 $1 \times \dfrac{n}{2}$ 的空点就是一个正方形。如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/n5dkuuam.png)

黄色的是题目输入的关键点，蓝色是新加的关键点，注意到此时小于 $\dfrac{n}{2}$ 列的格子必然都是关键点，所以此时我们可以直接从 $\dfrac{n}{2}$ 列开始判断。

先看这个样例（小于 $\dfrac{n}{2}$ 列的忽略）：

![](https://cdn.luogu.com.cn/upload/image_hosting/1zmvfyth.png)

红色的是搜到的一个长方形，这个长方形实际是这个样子的：

![](https://cdn.luogu.com.cn/upload/image_hosting/kgsuk1va.png)

考虑在什么情况下，交换两列，这个正方形仍然存在：
1. 任意在中间四列中选两个交换，根据乘法原理，一共有 $4 \times 3 \div 2 = 6$ 种。
2. 左边两列交换，一种情况。
3. 右边两列交换，也是一种情况。
4. 左边选一列，右边选一列，根据乘法原理，一共有 $2 \times 2 = 4$ 种。

总共有 $6 + 1 + 1 + 4 = 12$ 种。

![](https://cdn.luogu.com.cn/upload/image_hosting/q6zzgfz0.png)

观察这个绿色的格子，可以发现他有连续的 $3$ 个空点，只差 $1$ 个点就能凑成一个长方形了，考虑这一列怎么凑成一个长方形：
1. 把图中浅绿色和紫色格子交换，共 $2$ 种情况。
2. 交换第 $6$ 列和第 $3$ 列，一种情况。

第七列同理可以得到 $3$ 种情况。第八列同理得 $2$ 种情况。

所以这个样例的答案是 $12 + 3 + 3 + 2 = 20$ 种。

用这种做法，时间复杂度为 $\mathcal{O}(n^2)$。

### 满分做法

观察到在 $\dfrac{n}{2}$ 列后都有恰好有 $\dfrac{n}{2}$ 个关键点，只能有一个长方形，所以可以用一个 set 来维护空点的最大值和最小值，如果这两个值的差恰好是 $\dfrac{n}{2}-1$，那么这里就有一个长方形，其它情况见代码注释。

时间复杂度 $\mathcal{O}(n \log n)$。

AC 代码：

```cpp
#include<iostream>
#include<set> 

using namespace std;
typedef long long ll;

const int N = 2e5 + 10;
int n, a[N];
ll cnt; 
set<int> st;

int main(){
	cin >> n;
	for(int i = 1; i <= n; i++) cin >> a[i];
	for(int i = 1; i <= n; i++) st.insert(i);
	for(int i = 1; i <= n/2-1; i++) st.erase(a[i]);
	for(int i = n/2; i <= n; i++){
		st.erase(a[i]);
		int tmp = 0;
		auto bg = st.begin();
		auto ed = st.end();
		ed--;
		int edval = *ed, bgval = *bg;
		if(edval - bgval == n/2-1){ //有一个长方形。 
			int lt = i-n/2, rt = n-i;
			cnt += (ll)(n/2) * (n/2-1) / 2;
			cnt += (ll)lt * (lt-1) / 2;
			cnt += (ll)rt * (rt-1) / 2;
			cnt += (ll)lt * rt;
		}
		bg++; ed--;
		int edval2 = *ed, bgval2 = *bg;
		//有连续的 n/2-1 个点，可以把多余的一个点和上面的点或下面的点交换。 
		if(edval - bgval2 == n/2-2) cnt += (edval != n) + (edval - bgval != n/2-1);
		if(edval2 - bgval == n/2-2) cnt += (bgval != 1) + (edval - bgval != n/2-1);
		if(edval - bgval2 == n/2-1) cnt++; //中间有一个空点 
		if(edval2 - bgval == n/2-1) cnt++;
		st.insert(a[i-n/2+1]);
	}
	cout << cnt;
	return 0;
}
```

---

## 作者：modfish_ (赞：3)

## 思路
直接枚举交换的数对显然是不现实的。考虑换一种方法。

不难发现，如果一个区间 $[i,i+\frac{n}{2}-1]$ 符合条件，那么这个区间的值域一定由 $1$ 到 $n$ 的一个前缀和一个后缀组成（这样中间才能有 $\frac{n}{2}$ 个位置放正方形）。具体地，比如 $n=8$ 时，区间 $2,1,7,8$ 是符合条件的，因为它由前缀 $[1,2]$ 和后缀 $[7,8]$ 组成；区间 $1,7,6,8$ 也是符合条件的，它由前缀 $[1,1]$ 和后缀 $[6,8]$ 组成；区间 $5,8,7,6$ 也是符合条件的，它仅有一个后缀 $[5,8]$ 组成。

那么，不妨枚举这样的至于区间，然后计算有多少交换的方案，使得这种值域区间在原排列上是连续的。

假设当前枚举的是前缀 $[1,x]$ 和后缀 $[y,n]$，将这些数在原排列上出现的位置标为 $1$，其余位置标为 $0$，则有以下几种情况：

### 仅有一个 $1$ 的连续段
这时，任意交换连续段内的数或任意交换连续段外的数均符合条件。有 $2\binom{\frac{n}{2}}{2}$ 种方案。

还有一种可能：假设当前连续段的区间为 $[l,r]$，则交换 $p_l$ 和 $p_{r+1}$、交换 $p_r$ 和 $p_{l-1}$ 也可能符合条件，这取决于 $l$ 是否大于 $1$ 和 $r$ 是否等于 $n$，需要特判一下。

### 有两个 $1$ 的连续段
这时有几种情况：

- 两个连续段长度均大于 $1$。

此时，它们之间必须只间隔一个 $0$，则有两种交换方法。

- 两个连续段中有长度为 $1$ 的。

此时，对它们之间间隔的 $0$ 的数量没有要求。假设它们形如 $[x,x],[y,z]$，其中 $1\le x\le y\le z\le n$，则可以交换 $p_x$ 和 $p_{y-1}$，若 $z<n$，还可以交换 $p_x$ 和 $p_{z+1}$。$[x,y],[z,z]$ 的情况同理。

### 有三个 $1$ 的连续段
这时，仅有一种可能：三个连续段形如 $[x,x],[y,z],[z+2,w]$ 或 $[x,y],[y+2,z],[w,w]$，其中 $1\le x\le y\le z\le w\le n$。也就是说，这三个连续段中，最左边或者最右边的长度为 $1$，另外两个之间只间隔一个 $0$，在第一种情况中，可以交换 $p_x$ 和 $p_{z+1}$；在第二种情况中，可以交换 $p_w$ 和 $p_{y+1}$，可以视情况确定有几种方案。

于是对每种可能的值域区间这么讨论一下就可以了。可以不停滚动实现这个过程。

如何讨论连续段的情况呢？

对于最前面的 $1$ 和最后面的 $1$，可以用单调队列在值域上扫一遍维护（当然也可以用 ST 表）,不妨记其位置为 $l$ 和 $r$。

对于原排列上的位置 $i$，定义 $t_i$ 表示它是否处于当前值域中，若处于则为 $1$，否则为 $0$。特别地，$t_0=t_{n+1}=0$。定义 $v_i$ 满足：

$$v_i=\begin{cases}0,t_i=1\\t_{i-1}+t_{i+1},t_i=0\end{cases}$$

当值域发生变化时，假设 $t_i$ 从 $0$ 变成了 $1$，则：

- 若 $t_{i-1}=t_{i+1}=0$，则连续段数量增加 $1$。

- 若 $t_{i-1}=t_{i+1}=1$，则连续段数量减少 $1$。

- 否则，连续段数量不变。

从 $1$ 变成 $0$ 也是同理的。$v_i$ 的变化也可以动态维护。于是可以根据这些信息判断当前连续段的形态。具体可见代码。

时间复杂度 $O(n)$。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int maxn = 2e5 + 5;

int p[maxn], loc[maxn], a[maxn], min1[maxn], max1[maxn], tag[maxn], val[maxn], cval[maxn];
deque<int> q;

int main(){
    int n;
    scanf("%d", &n);
    int cnt = 0, calo = 0;
    cval[0] = n + 2;
    for(int i = 1; i <= n; i ++){
        scanf("%d", &p[i]);
        loc[p[i]] = i;
        if(p[i] <= n / 2){
            if(val[i] == 0) cnt ++;
            else if(val[i] == 2) cnt --;
            cval[val[i]] --;
            val[i] = 0;
            cval[val[i]] ++;
            cval[val[i - 1]] --, cval[val[i + 1]] --;
            tag[i] = 1;
            if(!tag[i - 1]) val[i - 1] ++;
            if(!tag[i + 1]) val[i + 1] ++;
            cval[val[i - 1]] ++, cval[val[i + 1]] ++;
        }
    }
    for(int i = 1; i <= n / 2; i ++) a[i] = n / 2 - i + 1;
    for(int i = 1; i <= n / 2; i ++) a[n / 2 + i] = n - i + 1;
    for(int i = 1; i <= n; i ++){
        while(!q.empty() && q.back() < i - n / 2 + 1) q.pop_back();
        while(!q.empty() && loc[a[i]] > loc[a[q.front()]]) q.pop_front();
        q.push_front(i);
        max1[i] = loc[a[q.back()]];
    }
    while(!q.empty()) q.pop_back();
    for(int i = 1; i <= n; i ++){
        while(!q.empty() && q.back() < i - n / 2 + 1) q.pop_back();
        while(!q.empty() && loc[a[i]] < loc[a[q.front()]]) q.pop_front();
        q.push_front(i);
        min1[i] = loc[a[q.back()]];
    }
    ll ans = 0;
    for(int i = n / 2; i <= n; i ++){
        if(max1[i] - min1[i] + 1 == n / 2){
            ans += 1ll * (n / 2) * (n / 2 - 1);
            if(min1[i] > 1) ans ++;
            if(max1[i] < n) ans ++;
        }else if(max1[i] - min1[i] + 1 == n / 2 + 1){
            ans += 2;
            if(tag[max1[i] - 1] == 0 && min1[i] > 1) ans ++;
            if(tag[min1[i] + 1] == 0 && max1[i] < n) ans ++;
        }else if(cnt == 2){
            if(tag[max1[i] - 1] == 0){
                if(min1[i] > 1) ans += 2;
                else ans ++;
            }
            if(tag[min1[i] + 1] == 0){
                if(max1[i] < n) ans += 2;
                else ans ++;
            }
        }else if(cnt == 3){
            if(tag[max1[i] - 1] == 0 && cval[2] - (tag[max1[i] - 2] == 1)) ans ++;
            if(tag[min1[i] + 1] == 0 && cval[2] - (tag[min1[i] + 2] == 1)) ans ++;
        }
        int x = loc[a[i - n / 2 + 1]], y = loc[a[i + 1]];
        tag[x] = 0;
        if(tag[x - 1] + tag[x + 1] == 0) cnt --;
        else if(tag[x - 1] + tag[x + 1] == 2) cnt ++;
        cval[val[x - 1]] --, cval[val[x + 1]] --;
        if(!tag[x - 1]) val[x - 1] --;
        if(!tag[x + 1]) val[x + 1] --;
        cval[val[x - 1]] ++, cval[val[x + 1]] ++;
        cval[val[x]] --;
        val[x] = tag[x - 1] + tag[x + 1];
        cval[val[x]] ++;
        tag[y] = 1;
        if(val[y] == 0) cnt ++;
        else if(val[y] == 2) cnt --;
        cval[val[y]] --;
        val[y] = 0;
        cval[val[y]] ++;
        cval[val[y - 1]] --, cval[val[y + 1]] --;
        if(!tag[y - 1]) val[y - 1] ++;
        if(!tag[y + 1]) val[y + 1] ++;
        cval[val[y - 1]] ++, cval[val[y + 1]] ++;
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：w9095 (赞：2)

[P11158 【MX-X6-T4】夢重力](https://www.luogu.com.cn/problem/P11158)

分类讨论好题。

不难发现交换行等价于交换列，考虑转化贡献体，枚举长度为 $\frac{n}{2}$ 区间，统计这个区间被多少种交换方式包含。

考虑一个长度为 $\frac{n}{2}$ 区间满足要求的充要条件是存在一段空权值区间 $[x,x+\frac{n}{2}]$ 使得区间中所有 $p_i$ 不属于 $[x,x+\frac{n}{2}]$。注意到如果存在满足要求的区间则其余每一行都必然有数，且上边界必然在 $[\frac{n}{2}+1,n]$，下边界必然在 $[1,\frac{n}{2}]$，所以我们维护 $[1,\frac{n}{2}]$ 中的最大值和 $[\frac{n}{2}+1,n]$ 中的最小值即可判定是否存在满足要求的区间。可以使用 `set` 维护。

如果这个区间本身就满足要求，那么在区间内部交换或区间外部交换没有影响，对答案贡献 $\frac{\frac{n}{2}\times(\frac{n}{2}-1)}{2}\times 2=\frac{n}{2}\times(\frac{n}{2}-1)$。但是如果 $[1,\frac{n}{2}]$ 中有数，我们可以把 $[1,\frac{n}{2}]$ 中的最大值换成一个较小的上边界，同样满足条件。如果 $[\frac{n}{2}+1,n]$ 中有数同理。需要特判一下。

如果这个区间本身不满足要求，还是有可能通过交换得到满足要求的区间。不难发现此时一定是换掉 $[1,\frac{n}{2}]$ 中的最大值或 $[\frac{n}{2}+1,n]$ 中的最小值，于是我们分别计算一下换掉之后的区间大小即可。注意如果换掉之后空权值区间长度大于 $\frac{n}{2}$，则有两种换法，如果空权值区间长度等于 $\frac{n}{2}$，则只有一种换法。这个结论手玩一下不难发现。

然后就做完了，时间复杂度 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,a[500000],cs=0,cb=0,ans=0;
set<long long>q;
int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	q.insert(0),q.insert(n+1);
	for(int i=1;i<=n/2;i++)q.insert(a[i]);
	for(int i=1;i<=n/2+1;i++)
	    {
	    set<long long>::iterator mx=q.lower_bound(n/2+1),mi=q.upper_bound(n/2),tmp=mx;
	    mi--;
	    if((*mx)-(*mi)-1>=n/2)
	       {
		   ans+=(n/2)*(n/2-1);
		   if((*mx)!=n+1)ans++;
		   if((*mi)!=0)ans++;
	       }
	    else
		    {
		    mx++;
		    if((*mx)-(*mi)-1>n/2)ans+=2;
		    else if((*mx)-(*mi)-1==n/2)ans++;
		    mx=tmp,mi--;
		    if((*mx)-(*mi)-1>n/2)ans+=2;
		    else if((*mx)-(*mi)-1==n/2)ans++;
		    }
	    q.insert(a[i+n/2]),q.erase(a[i]);
		}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：_Jocularly_ (赞：2)

无重力区域的边长 $\frac{n}{2}$ 很关键，手画一下能够发现，不管这个区域在哪，必定经过中心，利用这条性质，再看题。因为要进行行之间的交换，那么我们分类讨论两种情况。首先要理解，我们找到满足 $\le \frac{n}{2}$ 的最大值，和满足 $> \frac{n}{2}$ 的最小值，计算它们之间的距离，如果为 $\frac{n}{2}$。那么包含一个点的子矩阵必然在这两个中的其中一个，且交换的位置一定是不在区间内的最大值或最小值，直接维护即可。如果包含零个点，那么只会对在跟横坐标范围有关的区间有影响，直接计算即可。

需要维护动态最值，代码实现和思路有稍微的区别，时间复杂度为 $O(n \log n)$，[Code](https://www.luogu.com.cn/paste/5b3xevwh)。

---

## 作者：晴空一鹤 (赞：1)

智慧题。

每个无重力区域恰好对应一个该区域所有列的连续数列。也就是说，我们把该区域所在的所有列取出来，删去该区域，剩下的区域每行每列都有恰好一个数。

考虑无重力区域所在的起始行的范围：$1$ 至 $\frac{n}{2}+1$ 行。考虑将数列复制一份，因此剩余区域的起始行就在第 $1$ 行或第 $\frac{n}{2}$ 至第 $n$ 行之间。

我们依次对每个起始行求出方案数，考虑以下几种情况：

- 本就是一段连续数列，答案即为内部交换数加外部交换数加 $2$。一些边界情况特判。

- 一段连续数列加 $1$ 个其他数，根据边界等情况对答案有 $1$ 至 $3$ 的贡献。

- 两个连续数列中间空了一个，贡献为 $2$。

- 两个连续数列中间空一个加一个其他数，手模一下各种情况。

对这些情况进行判断要求我们求出区间最大、次大、最小、次小值，使用单调队列维护即可。

复杂度是高贵的 $O(n)$。

---

## 作者：wwwwwza (赞：1)

拆分贡献，思考交换某两行后，第 $i$ 行至第 $i+\frac{n}{2}-1$ 行一共能产生多少贡献。

对于每一种交换情况，因为第 $i$ 行至第 $i+\frac{n}{2}-1$ 行最多只能产生 $1$ 的贡献。

对于 $\{p_1,p_2,\dots,p_{i-1}\} \cap \{p_{i+\frac{n}{2}},\dots,p_n\}$ 为一个公差为 $1$ 的等差数列时，才会产生贡献。

接下来分类讨论一下，设集合 $a=\{p_1,p_2,\dots,p_{i-1}\} \cap \{p_{i+\frac{n}{2}},\dots,p_n\}$。

1. 设 $mx1$ 为 $a$ 集合中最大的数。
2. 设 $mx2$ 为 $a$ 集合中第二大的数。
3. 设 $mn1$ 为 $a$ 集合中最小的数。
4. 设 $mn2$ 为 $a$ 集合中第二小的数。

- 未交换的情况下有贡献。
1. 交换 $i$ 至 $i+\frac{n}{2}-1$ 之间的任意两行。
2. 交换除了 $i$ 至 $i+\frac{n}{2}-1$ 之间的任意两行。
3. $mn1\ne 1$，将 $mx1$ 换成 $mn1-1$。
4. $mx1\ne n$，将 $mn1$ 换成 $mx1+1$。

- 交换后才有贡献。

设要将 $k$ 与 $a$ 中的一个数交换，那么 $mn1<k<mx1$，且要交换的数一定要改变 $mn1$ 或 $mx1$，简单分类讨论后可得以下结果。

1. $mx1>k>mx2$，$k-mn1+1=\frac{n}{2}$。
2. $mx1>k>mn2$，$mx1-mn2+1=\frac{n}{2}$。
3. $mx1>k>mn1$，$mn2-mn1+1=\frac{n}{2}$。
4. $mn2>k>mn1$，$mx1-k+1=\frac{n}{2}$。

每找到一个 $k$ 可以增加 $1$ 的贡献。

$a$ 集合可以用线段树维护，$mx1,mx2,mn1,mn2$ 在线段树上二分可以求出。


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+10;
const int mod=998244353;
const int inf=0x3f3f3f3f;
int n,p[N],ans=0,tree[N<<2];
void update(int rt,int l,int r,int x,int d){
	if(l==r){
		tree[rt]+=d;
		return;
	}
	int mid=l+r>>1;
	if(x<=mid)update(rt*2,l,mid,x,d);
	else update(rt*2+1,mid+1,r,x,d);
	tree[rt]=tree[rt*2]+tree[rt*2+1];
}
int queryl(int rt,int l,int r,int x,int y){
	if(tree[rt]==r-l+1&&x<=l&&r<=y)return l;
	if(tree[rt]==0)return inf;
	int mid=l+r>>1,res=inf;
	if(x<=mid){
		res=queryl(rt*2,l,mid,x,y);
		if(res!=inf)return res;
	}
	if(y>mid)res=queryl(rt*2+1,mid+1,r,x,y);
	return res;
}
int queryr(int rt,int l,int r,int x,int y){
	if(tree[rt]==r-l+1&&x<=l&&r<=y)return r;
	if(tree[rt]==0)return inf;
	int mid=l+r>>1,res=inf;
	if(y>mid){
		res=queryr(rt*2+1,mid+1,r,x,y);
		if(res!=inf)return res;
	}
	if(x<=mid)res=queryr(rt*2,l,mid,x,y);
	return res;
}
signed main(){
	cin >>n;
	if(n==2){
		cout <<4;
		return 0;
	}
	for(int i=1;i<=n;i++)cin >>p[i];
	for(int i=1;i<=n;i++)update(1,1,n,i,1);
	for(int i=1;i<=n/2;i++){
		update(1,1,n,p[i],-1);
	}
	for(int i=1;i<=n/2+1;i++){
		int j=i+n/2-1;
		int mn1=queryl(1,1,n,1,n);
		int mn2=queryl(1,1,n,mn1+1,n);
		int mx1=queryr(1,1,n,1,n);
		int mx2=queryr(1,1,n,1,mx1-1);
		if(mx1-mn1+1==n/2){
			ans=ans+(n/2)*(n/2-1)+(mx1!=n)+(mn1!=1);
		}else{
			int k;
			k=n/2+mn1-1;
			if(mx1>k&&k>mx2)ans++;
			k=mx1+1-n/2;
			if(mn2>k&&k>mn1)ans++;
			k=n/2+mn2-1;
			if(k>mx1&&k<=n)ans++;
			k=mx2+1-n/2;
			if(k<mn1&&k>=1)ans++;
			
			if(mx1-mn2+1==n/2)ans+=(mx1-mn2+1-(n/2-1));
			if(mx2-mn1+1==n/2)ans+=(mx2-mn1+1-(n/2-1));
		}
		update(1,1,n,p[j+1],-1);
		update(1,1,n,p[i],1);
	}
	cout <<ans;
	return 0;
}

```

---

## 作者：EricWan (赞：1)

答案分开维护，对于一个原始小正方形，如果里面有一个特殊点，对答案的贡献为 $1$，如果没有特殊点，对答案的贡献为 $\frac{n\times(n-2)}4$，否则没有贡献。

维护一个长度为 $n$ 的树状数组用于维护一个 $\frac n2$ 行 $n$ 列的矩形向下移动的过程中的每一列上是否有特殊点即可即可。

对于一个小正方形，我们对答案有贡献仅当它浪费无特殊点的列数小于等于 $1$。

因此对答案有贡献的小正方形的左侧肯定在第一个没有特殊点的列附近或第二个没有特殊点的列附近，二分找到位置再判断即可。

代码：

```cpp
#include <bits/stdc++.h>
#define int long long
#define lowbit(x) ((x)&-(x))
using namespace std;
int n, k, a[MAXN], t[MAXN], ans;
map<pair<int, int>, int> ansmap;
void update(int x, int k) {
	while (x <= n) {
		t[x] += k;
		x += lowbit(x);
	}
}
int query(int x) {
	int ans = 0;
	while (x) {
		ans += t[x];
		x ^= lowbit(x);
	}
	return ans;
}
int getmin0() {
	int l = 1, r = n / 2;
	while (l < r) {
		int mid = (l + r) / 2;
		if (query(mid) == mid) {
			l = mid + 1;
		}
		else {
			r = mid;
		}
	}
	return l;
}
void check(int x, int y) {
	if (y + n / 2 - 1 > n || y < 1) {
		return;
	}
	int cnt1 = query(y + n / 2 - 1) - query(y - 1);
	if (cnt1 <= 1) {
		ansmap[{x, y}] = cnt1;
	}
}
signed main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	for (int l = 1, r = n / 2; r <= n; l++, r++) {
		if (l == 1) {
			for (int i = l; i <= r; i++) {
				update(a[i], 1);
			}
		}
		else {
			update(a[l - 1], -1);
			update(a[r], 1);
		}
		int l0 = getmin0();
		check(l, l0 - 1);
		check(l, l0);
		check(l, l0 + 1);
		update(l0, 1);
		int l02 = getmin0();
		update(l0, -1);
		check(l, l02 - 1);
		check(l, l02);
		check(l, l02 + 1);
	}
	for (pair<pair<int, int>, int> i : ansmap) {
		ans += ((i.second == 0) ? ((n / 2) * (n / 2 - 1)) : 1);
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Lele_Programmer (赞：0)

# P11158 题解

提供一种神奇的做法，非正解，但能过。

## 思路

对于一个 $\frac{n}{2} \times \frac{n}{2}$ 的子正方形，如果它里面没有关键点，那么它对答案的贡献是 $(\frac{n}{2}-1) \times \frac{n}{2}$。

证明：这 $\frac{n}{2}$ 行里面，每一行的关键点都不在这 $\frac{n}{2}$ 列里面，说明其余 $\frac{n}{2}$ 行的关键点全都在这 $\frac{n}{2}$ 列里面，所以只能子正方形内交换，或子正方形外交换，两者的贡献都是 $C_{\frac{n}{2}}^2$，因此总贡献是 $(\frac{n}{2}-1) \times \frac{n}{2}$。

对于一个 $\frac{n}{2} \times \frac{n}{2}$ 的子正方形，如果它里面有且仅有一个关键点，那么它对答案的贡献是 $1$。

证明：这 $\frac{n}{2}$ 行里面，有且仅有某一行的关键点出现在这 $\frac{n}{2}$ 列里面，那么其余 $\frac{n}{2}$ 行里面，有且仅有一个的关键点不在这 $\frac{n}{2}$ 列里面，那么这两行进行交换才会产生贡献，显然贡献为 $1$。

从上到下，从左往右，一个个扫的话时间复杂度是 $\mathcal{O}(n^2)$，不可行，考虑降低扫每一行的时间复杂度，因为在同一行只会有少量的子正方形会产生贡献。

一个左右长 $n$，上下宽 $\frac{n}{2}$ 的区间中，第 $i$ 列是否出现了关键点，表示为 $p_i$，拿样例 1 作为例子，第一次扫，$p = [1,1,0,0]$，第二次扫，$p = [0,1,1,0]$，第三次扫，$p = [0,0,1,1]$。然后像滑动窗口那样，记录贡献。

诶，那这样时间复杂度不还是 $\mathcal{O}(n^2)$ 吗？刚刚也已经提到了，能产生贡献的区间较少，所以我们可以跳着走，不一定要一格一格往右移动。

对于区间中没有关键点的情况，这样的情况极少，干脆直接暴力往右移动一格。

对于区间中有一个关键点的情况，举下图为例子，左边移动 $3$ 格后才会碰到关键点，右边移动 $1$ 格后就会碰到关键点，所以取最小值 $1$，表示移动 $1$ 格后区间中仍然只有一个关键点，那么产生 $2$ 次贡献，然后向右移动 $2$ 格，进入新的一种情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/9raqf8np.png)

对于区间中有多个关键点的情况，这样的情况较多，因此这个操作在此非常重要，举下图为例子，因为只有区间中有零或一个关键点的时候才有贡献，所以这里找从右端点的左边的**第二近**的关键点，求它与左端点的距离，记为 $k$，下图中，$k=5$，然后将其加 $1$ 后，移动 $k$ 格，下图中的例子会移动 $6$ 格，也就是要让左边界越过移动前的右端点的左边的第二近的关键点，这样，我们便可以跳过很多关键点，只留下一个，当然，有很大的可能在右边会再出现关键点，使得关键点的数量又不为 $1$ 了，那么又可以再跳，效率大大提高。

![](https://cdn.luogu.com.cn/upload/image_hosting/54o95c4b.png)

一行扫完了，扫下一行，只需要对 $p$ 数组的两个位置进行修改即可。

## 实现方式

上文需要求距离某个点的左或右边的最近的关键点，这一步直接用倍增来求很方便，时间复杂度 $\mathcal{O}(\log^2 n)$。

```cpp
int get_nearest_1(int pos) {
    if (query(1,pos,pos)) return pos;
    if (pos==n) return n+1;
    _rrep(i,20,0) {
        int k=pos+(1<<i);
        int r=min(k,n);
        int ret=query(1,pos,r);
        if (!ret && r==n) break;
        else if (ret) continue;
        pos+=(1<<i);
    }
    if (query(1,pos+1,pos+1)) return pos+1;
    return n+1;
}

int get_rev_nearest_1(int pos) {
    if (query(1,pos,pos)) return pos;
    if (pos==1) return 0;
    _rrep(i,20,0) {
        int k=pos-(1<<i);
        int r=max(k,1LL);
        int ret=query(1,r,pos);
        if (!ret && r==1) break;
        else if (ret) continue;
        pos-=(1<<i);
    }
    if (query(1,pos-1,pos-1)) return pos-1;
    return 0;
}
```

那代码中出现的 `query` 是什么呢？为什么复杂度有两只 $\log$？别急，待会讲。

然后我们发现 $p$ 数组需要支持单点修改以及区间查询，线段树再合适不过了！

```cpp
struct Seg {
    int l,r;
    int cnt;
} tr[N<<2];

void pushup(int u) {
    tr[u].cnt=tr[u<<1].cnt+tr[u<<1|1].cnt;
}

void build(int u,int l,int r) {
    tr[u]={l,r,p[l]};
    if (l==r) return;
    int mid=l+r>>1;
    build(u<<1,l,mid); build(u<<1|1,mid+1,r);
    pushup(u);
}

void modify(int u,int p,int k) {
    if (tr[u].l==p && tr[u].r==p) tr[u].cnt=k;
    else {
        int mid=tr[u].l+tr[u].r>>1;
        if (p<=mid) modify(u<<1,p,k);
        else modify(u<<1|1,p,k);
        pushup(u);
    }
}

int query(int u,int l,int r) {
    if (tr[u].l>=l && tr[u].r<=r) return tr[u].cnt;
    int mid=tr[u].l+tr[u].r>>1;
    int ans=0;
    if (l<=mid) ans+=query(u<<1,l,r);
    if (r>mid) ans+=query(u<<1|1,l,r);
    return ans;
}
```

所以 `query` 便是求区间内关键点的数量。

倍增里套了些线段树查询操作，然后再把扫一行的时间复杂度看成近似 $\mathcal{O}(1)$ 的话，时间复杂度大致是 $\mathcal{O}(n \log^2 n)$，可以通过。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

#define endl '\n'
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define TIMESTAMP cerr<<fixed<<setprecision(3)<<clock()*1.0/CLOCKS_PER_SEC<<"s"<<endl;
#define _rep(i,a,b) for (int i=(a);i<=(b);++i)
#define _reps(i,a,b,c) for (int i=(a);i<=(b);c)
#define _rrep(i,a,b) for (int i=(a);i>=(b);--i)
#define _rreps(i,a,b,c) for (int i=(a);i>=(b);c)
#define _iter(i,a) for (auto i=a.begin();i!=a.end();++i)
#define _graph(i,u) for (int i=h[u];~i;i=ne[i])
#define rint register int
#define LL long long
typedef pair<int,int> pii;

const int N=200005;

int n;
int arr[N];
int p[N];
int ans;

struct Seg {
    int l,r;
    int cnt;
} tr[N<<2];

void add_0() {
    ans+=((n>>1)-1)*(n>>1);
}

void add_1() {
    ans++;
}

void add_1(int k) {
    ans+=k;
}

void pushup(int u) {
    tr[u].cnt=tr[u<<1].cnt+tr[u<<1|1].cnt;
}

void build(int u,int l,int r) {
    tr[u]={l,r,p[l]};
    if (l==r) return;
    int mid=l+r>>1;
    build(u<<1,l,mid); build(u<<1|1,mid+1,r);
    pushup(u);
}

void modify(int u,int p,int k) {
    if (tr[u].l==p && tr[u].r==p) tr[u].cnt=k;
    else {
        int mid=tr[u].l+tr[u].r>>1;
        if (p<=mid) modify(u<<1,p,k);
        else modify(u<<1|1,p,k);
        pushup(u);
    }
}

int query(int u,int l,int r) {
    if (tr[u].l>=l && tr[u].r<=r) return tr[u].cnt;
    int mid=tr[u].l+tr[u].r>>1;
    int ans=0;
    if (l<=mid) ans+=query(u<<1,l,r);
    if (r>mid) ans+=query(u<<1|1,l,r);
    return ans;
}

int get_nearest_1(int pos) {
    if (query(1,pos,pos)) return pos;
    if (pos==n) return n+1;
    _rrep(i,20,0) {
        int k=pos+(1<<i);
        int r=min(k,n);
        int ret=query(1,pos,r);
        if (!ret && r==n) break;
        else if (ret) continue;
        pos+=(1<<i);
    }
    if (query(1,pos+1,pos+1)) return pos+1;
    return n+1;
}

int get_rev_nearest_1(int pos) {
    if (query(1,pos,pos)) return pos;
    if (pos==1) return 0;
    _rrep(i,20,0) {
        int k=pos-(1<<i);
        int r=max(k,1LL);
        int ret=query(1,r,pos);
        if (!ret && r==1) break;
        else if (ret) continue;
        pos-=(1<<i);
    }
    if (query(1,pos-1,pos-1)) return pos-1;
    return 0;
}

signed main() {
    scanf("%lld",&n);
    _rep(i,1,n) scanf("%lld",&arr[i]);
    _rep(i,1,n>>1) p[arr[i]]=1;
    build(1,1,n);
    _rep(i,1,(n>>1)+1) {
        int l=1,r=(n>>1);
        int cnt=query(1,l,r);
        while (true) {
            if (r>n) break;
            if (!cnt) add_0();
            else if (cnt==1) add_1();
            if (r==n) break;
            if (!cnt) {
                l++,r++;
                cnt=query(1,l,r);
            } else if (cnt==1) {
                int L=get_nearest_1(l)-l;
                int R=get_nearest_1(r+1)-(r+1);
                int k=min(L,R);
                add_1(k);
                k++;
                l+=k,r+=k;
                cnt=query(1,l,r);
            } else {
                int k=get_rev_nearest_1(r);
                k=get_rev_nearest_1(k-1)+1-l;
                l+=k,r+=k;
                if (r>n) break;
                cnt=query(1,l,r);
            }
        }
        if (i!=((n>>1)+1)) {
            modify(1,arr[i],0);
            modify(1,arr[i+(n>>1)],1);
        }
    }
    printf("%lld",ans);
    return 0;
}
```

[评测记录](https://www.luogu.com.cn/record/179972427)

---


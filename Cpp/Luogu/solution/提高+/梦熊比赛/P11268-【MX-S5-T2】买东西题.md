# 【MX-S5-T2】买东西题

## 题目背景

原题链接：<https://oier.team/problems/S5B>。

---

**此题题意与关联的现实生活情景略有不同，请认真阅读题目描述。**

## 题目描述

你要买 $n$ 个物品，第 $i$ 个物品原价 $a_i$ 元，折扣价 $b_i$ 元（保证 $b_i \le a_i$）。

你还有 $m$ 个满减优惠券，第 $j$ 个优惠券形如**原价**满 $w_j$ 减 $v_j$（保证 $v_j \le w_j$）。

对于第 $i$ 个物品，你可以选择以下三种购买方式之一：

1. 使用**原价** $a_i$ 购买。
2. 使用**折扣价** $b_i$ 购买。
3. 选择**一个未使用过的优惠券** $j$，要求满足 $a_i \ge w_j$，使用优惠券 $j$，以 $a_i - v_j$ 的价格购买。注意每个优惠券 $j$ 只能被**最多一个** $i$ 使用。

求购买所有物品最少用钱。

## 说明/提示

**【样例解释 #1】**

因为满足 $w_2\le a_1$ 即 $7\le 7$，所以可以使用原价和第 $2$ 个优惠券购买第 $1$ 个物品，花费 $7-4=3$ 元。

因为满足 $w_4\le a_2$ 即 $3\le 4$，所以可以使用原价和第 $4$ 个优惠券购买第 $2$ 个物品，花费 $4-2=2$ 元。

使用折扣价购买第 $3$ 个物品，花费 $2$ 元。

使用原价和第 $3$ 个优惠券购买第 $4$ 个物品，花费 $6-4=2$ 元。

使用折扣价购买第 $5$ 个物品，花费 $3$ 元。

共 $3+2+2+2+3=12$ 元。可以证明这是最少用钱方案。

**【样例解释 #2】**

使用原价和第 $2$ 个优惠券购买第 $1$ 个物品。

使用折扣价购买第 $2$ 个物品。

使用原价和第 $1$ 个优惠券购买第 $3$ 个物品。

共 $0+1+0=1$ 元。

**【样例 #3】**

见附件中的 `buy/buy3.in` 与 `buy/buy3.ans`。

该组样例满足测试点 $3$ 的约束条件。

**【样例 #4】**

见附件中的 `buy/buy4.in` 与 `buy/buy4.ans`。

该组样例满足测试点 $5\sim 6$ 的约束条件。

**【样例 #5】**

见附件中的 `buy/buy5.in` 与 `buy/buy5.ans`。

该组样例满足测试点 $8$ 的约束条件。

**【样例 #6】**

见附件中的 `buy/buy6.in` 与 `buy/buy6.ans`。

该组样例满足测试点 $9\sim 10$ 的约束条件。

**【数据范围】**

对于所有测试数据，保证：$1 \le n,m \le 10^6$，$1 \le a_i,b_i,w_j,v_j \le 10^9$，$b_i\le a_i$，$v_j\le w_j$。

| 测试点编号 |    $n\le$    |    $m\le$    | $a_i,w_j\le$ | 特殊性质 |
| :--------: | :-------: | :-------: | :-------: | :------: |
|    $1$     |  $10$  |  $10$  |  $10$  |    无    |
|    $2$     | $10^5$ | $10^5$ | $10^4$ |    $a_i=b_i$     |
|    $3$     | $10^5$ | $10^5$ | $10^9$ |    $a_i=b_i$     |
|    $4$     | $10^5$ | $10^5$ | $10^4$ |    $\max_j w_j\le\min_i a_i$     |
| $5\sim 6$  | $10^5$ | $10^5$ | $10^9$ |    $\max_j w_j\le\min_i a_i$     |
|    $7$     | $10^3$ | $10^3$ | $10^6$ |    无    |
|    $8$     | $10^3$ | $10^3$ | $10^9$ |    无    |
| $9\sim 10$ | $10^6$ | $10^6$ | $10^9$ |    无    |

## 样例 #1

### 输入

```
5 4
7 5
4 2
5 2
6 4
6 3
5 1
7 4
5 4
3 2```

### 输出

```
12```

## 样例 #2

### 输入

```
3 4
3 2
5 1
5 5
5 5
3 3
4 2
2 1```

### 输出

```
1```

# 题解

## 作者：Exp10re (赞：57)

做法来自 @[farmerjiang](https://www.luogu.com.cn/user/600774)，已经过本人授权。

给一种证明部分完全与反悔无关的做法，会比反悔思路简单很多。

## 解题思路

考虑如下做法：

- 添加 $n$ 张限制为 $a_i$，优惠为 $a_i-b_i$ 的虚空优惠券。
- 然后仅考虑 $n$ 件商品的原价以及这 $n+m$ 张优惠券，用它们进行朴素贪心 $^\dagger$，得到的答案即为本题的答案。

$\dagger$：参考 [ABC308F](https://www.luogu.com.cn/problem/AT_abc308_f)，将物品以及优惠券排序后从小到大枚举物品，然后将满足限制的优惠券加到大根堆中贪心的使用最大的优惠券。

我们考虑为什么这么做是对的：容易发现这么做唯一的问题在于可能有一个原价不为 $a_i$ 的商品 $a_j$ 使用了 $a_i$ 产生的虚空优惠券，根据贪心这个时候 $a_i$ 会使用另一张优惠券减 $x$ 元，记这一张优惠券的限制为 $lim$。

可以发现 $a_j$ 会抢走 $a_i$ 的虚空优惠券的一个必要条件是 $a_j\geq a_i$，又有 $lim\leq a_i \leq a_j$，故此时交换 $a_i$ 与 $a_j$ 的优惠券可以使得 $a_i$ 使用自己产生的虚空优惠券，即使用原先的 $b_i$ 折扣，并且不会产生任何额外代价。

故经过若干次交换可以使得每一个商品使用原先给出的优惠券以及自己的虚空优惠券，并且在此限制条件下不会产生比朴素贪心更高的代价，故正确性得证。

时间复杂度 $O(n\log (n+m))$。

---

## 作者：forever_nope (赞：28)

一眼反悔贪心。

将优惠券按照 $w_i$ 升序排序，方便一个指针遍历。

将物品按照 $a_i$ 升序排序，方便逐个加入优惠券。

注意到可以逐个物品看：

+ 对于物品 $i$，将 $\le a_i$ 的 $w_j$ 的优惠券 $j$ 加入。

+ 对于物品 $i$，一共有三种可能：

  + 使用折扣价。
 
  + 使用一张最优的优惠券。
 
  + 将前面一个物品的优惠券抢过来。

注意到两个物品用两个优惠券，如果交换依旧合法的话，是没必要交换的，因此可以忽略物品 $i$ 从前面抢一个优惠券，然后给前面的再安排一个优惠券的情况。

反悔贪心，不妨推一下式子，对于 $j<i$ 且 $j$ 用了优惠券 $g_j$：

+ 对于 $j$，

  + 若使用折扣价：花费 $b_j$。
 
  + 若使用优惠券：花费 $a_j-v_{g_j}$。
 
+ 对于 $i$，

  + 若使用折扣价：花费 $b_i$。
 
  + 若使用新的优惠券：花费 $a_i-v_{g_i}$。
 
  + 若抢了 $j$ 的优惠券：
 
    + 不妨将贡献后计算，即将 $j$ 的贡献于 $i$ 加入。
   
    + 花费 $a_i-v_{g_j}-[a_j-v_{g_j}]+b_j=a_i-(a_j-b_j)$。

也就是说，我们的 $i$ 抢了 $b$ 的一张优惠券，相当于 $j$ 的优惠券转化为了一个 $a_j-b_j$ 的优惠券，等待 $i$ 去使用。

容易想到，我们使用一个大根堆（`std::priority_queue`）维护这个过程。具体的，我们遍历物品 $i$、加入可以使用优惠券（同上），然后判断 $i$ 应该如何使用。如果使用折扣价，直接计算。如果使用优惠券，计算贡献后，将优惠券替换为 $a_i-b_i$ 的优惠券。

反悔贪心的正确性显然，因为我们替换的优惠券，还会再加入堆中称为新的待选优惠券，最终一定会找到对应的优惠券（看视频讲解说似乎可以通过模拟费用流解释？）。

注意到每个元素仅会被插入和删除一次，因此时间复杂度是 $\mathcal O(n\log n)$ 的。

```cpp
void Main() {
	int n, m;
	read(n, m);
	vector<pair<int, int>> a(n);
	vector<pair<int, int>> b(m);
	for (auto &[x, y] : a)
		read(x, y);
	for (auto &[x, y] : b)
		read(x, y);
	sort(a.begin(), a.end());
	sort(b.begin(), b.end());
	int i = 0;
	priority_queue<int> heap;
	long long ans = 0;
	for (auto [x, y] : a) {
		while (i < m && b[i].first <= x)
			heap.push(b[i].second), ++i;
		if (heap.empty() || x - y > heap.top())
			ans += y;
		else {
			ans += x - heap.top();
			heap.pop();
			heap.push(x - y);
		}
	}
	cout << ans << endl;
}
```

其中 `read(...)` 是快读。

---

## 作者：_fairytale_ (赞：13)

# 前言

这凭什么才绿题？？？

写的有点多，做法可能麻烦了，但是都是赛时思路，应该比较好懂。

# 题解

这种很麻烦的东西看着就很费用流啊！当然数据范围不允许我们直接建模，于是我们尝试模拟费用流，但是感觉 T2 不需要这么重量级的东西，所以我们先试试模拟费用流的儿子：反悔贪心。

首先一个很简单的观察是我们只会用 $b_i$ 或者 $(a_i-v)$ 买东西。

先不考虑不需要使用优惠券的物品，这种情况是平凡的。同时我们先让所有物品都不用优惠券，即初始赋值 $ans\gets \sum b_i$。

考虑现在我们有两个物品 $(a_i,b_i),(a_j,b_j)$ 以及一张优惠券 $(w,v)$，什么时候把优惠券给 $i$ 会更优，不妨把式子写下来：

- 给 $i$ 会花的钱：$a_i-v+b_j$
- 给 $j$ 会花的钱：$a_j-v+b_i$

因为给 $i$ 更优，所以 $a_i-v+b_j<a_j-v+b_i$，整理得 $a_i-b_i<a_j-b_j$。

这个很符合直觉啊！$a_i-b_i$ 较小的物品，说明用 $b_i$ 买的优惠比较小，我们更倾向于在这种物品上用优惠券。

记 $c_i=a_i-b_i$。

我们考虑用物品去匹配优惠券。考虑当前已经把前 $i$ 个物品都匹配好了优惠券，且已经用完了所有的优惠券，这个时候，如果我们要给第 $(i+1)$ 个物品匹配一个优惠券，那么必然会选 $c_j$ 最大的那个物品 $j$，把 $j$ 的优惠券挪给 $i$ 用。

现在考虑如果有空着的优惠券没用的时候该如何决策。还是考虑刚刚两个物品的情况，把使用优惠券的物品 $j$ 换成物品 $i$，花费（注意我们认为已经用 $b_i$ 购买了物品 $i$）的变化量 $\Delta_1=(a_i-v)-b_i-(a_j-v)+b_j=c_i-c_j$，而把物品 $i$ 直接用优惠券的情况下，变化量 $\Delta_2=a_i-v-b_i=c_i-v$。

因此，对于一张优惠券 $(w_k,v_k)$，如果它已经被某个物品 $j$ 使用，我们认为它的权值 $d_k=c_j$，否则我们认为它的权值 $d_k=v_k$。对于每个物品 $(a_i,b_i)$，我们使用 $w\le a_i$ 的优惠券中，权值最大的那一张即可（如果权值相同优先取空闲的优惠券）。

可是如果用掉的优惠券有匹配的物品怎么办？不会要递归处理吧？这也太麻烦了！

没关系，这是因为你不够贪心！！！！！！！

我们把所有优惠券按照 $w$ 升序排序，所有物品按照 $a$ 升序排序，这样每个物品对应可用的优惠券是一段前缀。

我们还是枚举每个物品 $i$ 进行匹配。对于物品 $i$，我们找到它要替换掉优惠券的物品 $j$ 以及对应的优惠券 $k$。

如果 $j$ 还能找到其他的优惠券 $l$，那么 $l$ 需要满足 $c_j-d_l<0$，即 $c_j<d_l$，因为 $j$ 在 $i$ 之前找好了对应匹配的优惠券，所以 $l\in [1,a_j]\subseteq[1,a_i]$，根据我们刚刚的策略，我们知道 $k$ 是 $w\in [1,a_i]$ 的优惠券中，$d$ 最大的优惠券，又因为 $k$ 匹配了 $j$，所以 $d_k=c_j<d_l$，矛盾！

因此，对于物品 $i$，如果要替换 $j$，把 $j$ 直接扔掉即可。

找到 $j$ 用堆/线段树/其他你喜欢的数据结构解决即可。
```cpp
#include<bits/stdc++.h>
bool Mst;
#define ll long long
#define pii pair<int,int>
#define fi first
#define se second
#define ls ((p)<<1)
#define rs (((p)<<1)|1)
#define mid ((l+r)>>1)
#define rep(x,qwq,qaq) for(int x=(qwq);x<=(qaq);++x)
#define per(x,qwq,qaq) for(int x=(qwq);x>=(qaq);--x)
using namespace std;
template<class _T>
void ckmax(_T &x,_T y) {
	x=max(x,y);
}
int ri() {
	int x;
	cin>>x;
	return x;
}
#define inf 0x3f3f3f3f
#define maxn 1001000
int n,m,k;
struct obj {
	int a,b;
} wp[maxn];
struct disc {
	int w,v;
	bool operator<(const disc&bb)const {
		return w!=bb.w?w<bb.w:v<bb.v;
	}
} yhq[maxn];
struct info {
	int mx,pos,objid;
} c[maxn<<2];
info operator+(const info&x,const info&y) {
	if(x.mx>y.mx)return x;
	else if(x.mx<y.mx)return y;
	else return x.objid?y:x;
}
void build(int p,int l,int r) {
	if(l==r) {
		c[p]= {yhq[l].v,l,0};
		return;
	}
	build(ls,l,mid),build(rs,mid+1,r);
	c[p]=c[ls]+c[rs];
}
void modify(int p,int l,int r,int pos,const info &v) {
	if(l==r) {
		c[p]=v;
		return;
	}
	if(mid>=pos)modify(ls,l,mid,pos,v);
	else modify(rs,mid+1,r,pos,v);
	c[p]=c[ls]+c[rs];
}
info query(int p,int l,int r,int L,int R) {
	if(L<=l&&r<=R)return c[p];
	if(mid<L)return query(rs,mid+1,r,L,R);
	else if(mid>=R)return query(ls,l,mid,L,R);
	else return query(ls,l,mid,L,R)+query(rs,mid+1,r,L,R);
}
ll ans;
bool Med;
signed main() {
	cerr<<(&Mst-&Med)/1024.0/1024.0<<" MB\n";
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	rep(i,1,n)wp[i]= {ri(),ri()};
	sort(wp+1,wp+n+1,[&](const obj&x,const obj&y) {
		return x.a<y.a;
	});
	rep(i,1,m)yhq[i]= {ri(),ri()};
	sort(yhq+1,yhq+m+1);
	build(1,1,m);
	rep(i,1,n) {
		int p=upper_bound(yhq+1,yhq+m+1,(disc) {
			wp[i].a,inf
		})-yhq-1;
		if(p==0) {
			ans+=wp[i].b;
			continue;
		}
		ans+=wp[i].b;
		info res=query(1,1,m,1,p);
		int tmp=wp[i].a-wp[i].b;
		if(tmp-res.mx>=0)continue;
		ans+=tmp-res.mx;
		modify(1,1,m,res.pos, {tmp,res.pos,i});
	}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：ln001 (赞：9)

### 闲话
~~颓了三个小时才开始打比赛。怕被制裁就赶紧切一题。~~

双十一，这很应景。

## 题意
给定若干物品和**满减**优惠券，物品不仅有原价，还有优惠价格。每个优惠券至多使用一次，每个物品至多使用一个优惠券。使用优惠价格的物品**不能使用**优惠券。使用优惠价格的物品没有数量限制。

## 做法
约定物品的**优惠量**为原价与优惠价格的差。

若没有优惠价格，就成了反悔贪心[板子题](https://www.luogu.com.cn/problem/AT_abc308_f)，具体做法是按照物品价格升序排序，按照优惠券下限升序排序。扫每一个物品，维护指针表示该物品能使用的最靠后的优惠券。把指针扫过的优惠券扔到**按照优惠券降价排序**的大根堆里，每个物品直接取堆顶作为优惠券。正确性是因为提前进行了排序，所以靠前的物品能使用的优惠券，靠后的物品也能用。

若每个物品有优惠价格，做法类似，逐个扫物品，维护和上文一样的指针。假设当前扫到的物品必须使用优惠券，那么优惠券有两个来源：使用过的优惠券和未使用的合法优惠券。对于使用未使用的合法优惠券，和上文做法一样。

对于使用使用过的优惠券，可以理解为掠夺靠前的物品使用的优惠券。显然若物品 $x$ 掠夺物品 $y$ 使用的优惠券能使答案更优，物品 $y$ 只会改为使用自己的优惠价格，因为若物品 $y$ 改为使用其他优惠券，物品 $x$ 也可以直接使用，不需要刻意进行掠夺。若发生掠夺，最终的总降价**仅会加上**物品 $y$ 的**优惠量**，所以**再开一个大根堆**存使用了优惠券的物品的**优惠量**，使用了优惠券的物品都丢进去就好了。

不要忘记考虑不使用优惠券的情况。

最终实现的时候可以将两个堆合并为一个，正确性显然。

[Code](https://vjudge.net/solution/55841307/Zv1XxzXDWutu4aRQ59A2)

---

## 作者：lizhous (赞：8)

## 题意简述

你要买 $n$ 个物品，第 $i$ 个物品原价 $a_i$，折扣价 $b_i$。

你还有 $m$ 个优惠券，第 $i$ 个优惠券形如**原价**满 $w_i$ 减 $v_i$。

对于第 $i$ 个物品，你可以选择以下三种购买方式之一：

1. 使用原价 $a_i$ 购买。
2. 使用折扣价 $b_i$ 购买。
3. 选择一个优惠券 $j$，要求满足 $a_i \ge w_j$，使用优惠券 $j$，以 $a_i - v_j$ 的价格购买。注意每个优惠券 $j$ 只能被最多一个 $i$ 使用。

求购买所有物品最少用钱。

## 算法1

考虑特殊性质 A。

把物品按 $a$ 升序排序后，每个优惠券可以被使用在一个后缀的物品上。

由于选择按折扣价购买不会省钱，所以我们要尽可能用优惠券省更多的钱。

从前往后扫物品，每经过一个物品会有一些优惠券变得可以被使用，每次在当前可以使用且未使用的优惠券中找到省钱最多的使用即可。

具体来说可以用优先队列维护当前所有可以使用且未使用的优惠券的 $b$ 值，每次直接找到最大的使用。

时间复杂度 $O(n)$，期望得分 $20$。

## 算法2

考虑特殊性质 B。

首先可以把折扣价改写为可以选择优惠 $c_i=a_i-b_i$ 钱。现在每个物品我们先选择折扣价，然后用优惠券来省钱。

按任意顺序扫描物品，对于一个物品，有三种选择：

1. 用当前没使用过的省钱最多的优惠券。
2. 把已经使用过的优惠券换到这个物品。而被拿走优惠券的物品改为使用折扣价。
3. 用优惠价。

找到最优的使用。

说明一下 2 为什么被拿走优惠券的物品改为使用折扣价。首先假如从 $j$ 换到 $i$，会让答案变优一定是 $c_j\ge c_i$，那么如果 $j$ 改为使用其他优惠券，那么和这张优惠券直接用在 $i$ 省的钱是一样的。

寻找 2 需要优化，若从物品 $j$ 换一个可以优惠 $v$ 钱的优惠券到物品 $i$，$j$ 物品多 $v-c_j$ 钱，$i$ 物品少 $v-c_i$ 钱，所以答案减少 $v-c_i-(v-c_j)=c_j-c_i$ 钱。由于 $c_i$ 固定，所以我们找到最大的 $c_j$ 换过来即可。

用优先队列维护当前所有选择了优惠券的物品的 $c$ 值，每次直接找到最大的进行比较。

时间复杂度 $O(n\log n)$，期望得分 $30$。

## 算法3

如果你没想到寻找 2 的优化，但是你会把特殊性质 $A$ 和特殊性质 $B$ 并在一起，那么你可以获得一个 $O(n^2)$ 的做法。

排序后从前到后扫物品，加入新的可用的优惠券。每次在当前可以使用且未使用的优惠券中找到省钱最多的使用。注意要和折扣价比较，如果折扣价最优就选择折扣价。

再增加一个贪心。对于一个物品，我们可以把对他前面物品使用的优惠券换过来，让前面的物品改为选折扣价。暴力枚举换的优惠券，找到最优的方案和当前可以使用且未使用的比较取最优即可。

关于这个贪心的正确性证明会在后面阐述。

时间复杂度 $O(n^2)$，期望得分 $20$。

## 算法4

合并算法 2 和算法 3，用优先队列维护当前所有选择了优惠券的物品的 $c$ 值，每次直接找到最大的进行比较。

总结一下最终的贪心，对于每一个新的物品 $i$：

1. 选择折扣价，贡献 $b_i$。
2. 选择可以使用的未使用的最优优惠券，设其省 $v$ 钱，贡献 $a_i-v$。
3. 选择之前已经选过的优惠券换过来使用，设从物品 $j$ 换来的，贡献 $a_i-c_i-(c_j-c_i)=a_i-c_j$。

找到最优的决策即可。

时间复杂度 $O(n\log n)$，期望得分 $100$。

---

到这里仅仅讲完了贪心的做法，下面是对这个贪心做法正确性的证明。

我们称上述三个贪心分别为贪心 1，贪心 2，贪心 3。

有一个结论：对于一个已经确定使用哪些优惠券和优惠券分配方案的方案，若不存在一个优惠券更改使用对象到其他未使用优惠券的物品上会使答案变优，那么当前优惠券分配方案是使用这些优惠券的最优方案。

证明可以反证。假如现在不存在一个优惠券更改使用对象到其他未使用优惠券的物品上会使答案变优且不失最优分配方案，那么假如当前有一个优惠券在 $u$，最优分配方案中在 $v$，那么把 $u$ 换到 $v$ 会对省的钱产生贡献。注意这里算贡献要假装 $v$ 没有券，因为最终 $v$ 上面只会有一个券，就算有券也会拿走，最后贡献是对的。那么最终贡献是每一个换的贡献的和。由于总贡献为正，那么必然存在贡献为正的换，那么这条边的调整就会让答案变优。那么存在调整，与假设不符。

那么根据这个结论，我们不难归纳证明我们的贪心得出的分配方案是使用这些优惠券的最优方案，即因为贪心 3 存在，所以新物品不会产生调整。现在我们着眼于选择这些券是否是最优的。

我们有两个调整：

1. 舍弃一个物品 $i$ 上的优惠券。发现贪心 1 和贪心 3 不会创造这种情况，而若选用贪心 2，那肯定是优于换前面过来，即舍弃不优。于是我们不难归纳证明我们的贪心得出的选择优惠券方案不含这种情况。
2. 在物品 $i$ 上增加一个优惠券。发现贪心 2 不会创造这种情况，而若选用贪心 1 或 3，那肯定是优于增加优惠券，即增加不优。于是我们不难归纳证明我们的贪心得出的选择优惠券方案不含这种情况。

类似的，假如当前优惠券集合 $B$，实际最优集合 $A$。我们总是可以通过若干次插入和删除把 $B$ 变成 $A$。而由于每次操作是独立的，总贡献为正，那么一定存在单步操作贡献为正，于是必然存在调整。也就是说不存在调整就是最优的。

---

## 作者：262620zzj (赞：8)

# 建模

首先建出费用流模型。
- 源点 $S$ 向所有物品连边 $(1,0)$。（前者为容量，后者为费用，下同）
- 每个物品 $i$ 向表示折扣价购买的点 $B$ 连边 $(1,b_i)$。
- 每个物品 $i$ 向所有自己可以用的优惠券 $j$ 连边 $(1,a_i-v_j)$。
- $B$ 向汇点 $T$ 连边 $(+\infty,0)$。
- 每个优惠券向汇点 $T$ 连边 $(1,0)$。

答案就是最小费用最大流的费用。

# 模拟费用流

在这张图上模拟寻找增广路径的过程。我们管物品到 $B$ 的边叫一类，到优惠券的边叫二类。增广路径有四种。

一、走一类边，费用为 $b_i$。

二、走二类边，费用为 $a_i-v_j$。

三、走二类边，再走二类反边，再走一类边，费用为 $(a_i-v_j)-(a_k-v_j)+b_k=a_i-(a_k-b_k)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/q161wkt2.png)

四、走二类边，再走二类反边，再走另一条二类边。费用为 $(a_i-v_j)-(a_k-v_j)+(a_k-v_l)=a_i-v_l$。

![](https://cdn.luogu.com.cn/upload/image_hosting/6ekdv8c0.png)

# 优化增广过程

首先我们发现第四类增广是没用的。因为如果有第四类增广，则需要已经存在流 $S\to j\to k \to T$，结合物品使用优惠券的条件，有 $a_j-v_k<a_i-v_k,a_j\ge w_l \Rightarrow a_i\ge w_l$。$i$ 与 $l$ 之间有直接连边，与第二类增广等价。通俗易懂的来说，也就是两个物品，两个优惠券，如果两两可以匹配，那么交换他们的优惠券没有任何意义。

现在只需要考虑前三种了。但是好像还是不太好去维护我们每次最优的增广方案是什么。

注意到（注意力惊人）如果我们把物品按照 $a$ 从小到大的顺序排序，每次寻找增广路钦定要走 $S$ 到当前 $a$ 最小的点（物品），答案是对的。证明如下：

首先一定会增广 $n$ 次，每次新加的增广路径一定经过一个没选过的物品。

接下来考虑两个物品 $i,j$，不妨设 $a_i<a_j$。

对于第一类增广，由于 $B\to T$ 这条边容量无限，所以怎么交换顺序都是一样的。

对于第二类增广，$w>a_i$ 的优惠券，只有 $j$ 能使用，故顺序不影响。$w<a_i$ 的优惠券，由于优惠的价固定是 $v$，且 $a_i<a_j$，$i$ 使用之费用更小，$i$ 应当在 $j$ 前面。

对于第三类增广费用为 $a_i-(a_k-b_k)$，其中 $a_k-b_k$ 是与 $i,j$ 无关的量，所以这种情况下 $i$ 也应当在 $j$ 前面。

综上，不管哪种增广方式，如果 $a_i<a_j$，把 $i$ 放在 $j$ 前面都是合理的。

于是我们可以将物品先排序，然后对于物品 $i$，三种方案是 $b_i,a_i-\max v_j,a_i-\max a_k-b_k$，这两个 max 用堆维护即可，由于每个元素只进出堆一次，所以复杂度 $O(n\log n)$。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int N=1e6+5;
typedef long long ll;
typedef pair<int,int> pii;
#define fi first
#define se second
int n,m;
pii item[N],coupon[N];//first=a,w second=b,v;
priority_queue<ll> vw,ab;
int match[N];
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>item[i].fi>>item[i].se;
    for(int i=1;i<=m;i++)cin>>coupon[i].fi>>coupon[i].se;
    sort(item+1,item+1+n);
    sort(coupon+1,coupon+1+m);
    int ptr=1;
    ll ans=0;
    for(int i=1;i<=n;i++){
        while(ptr<=m&&coupon[ptr].fi<=item[i].fi){
            vw.push(coupon[ptr].se);
            ptr++;
        }
        ll w1=item[i].se;
        ll w2=vw.empty()?1ll<<40:item[i].fi-vw.top();
        ll w3=ab.empty()?1ll<<40:item[i].fi-ab.top();
        ll mn=min({w1,w2,w3});
        if(mn==w1)ans+=w1;
        else if(mn==w2){
            ans+=w2;
            ab.push(item[i].fi-item[i].se);
            vw.pop();
        }
        else{
            ans+=w3;
            ab.pop();
            ab.push(item[i].fi-item[i].se);
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：zibenlun (赞：4)

## 来一篇线段树题解吧

首先考虑简化问题，看到每一个物品的原本折扣，很显然可以把它当作每一个物品本来就有一个优惠券，所以问题就变成了给所有物品更新优惠券。

思考怎么更新优惠券，显然可以想到，对于每一个优惠券，如果它更新的物品原本的优惠越少，那么这张优惠券的贡献就越大。所以就可以每一次找出能更新的里面原本优惠最小的即可。更新的时候按照 $w$ 从大到小开始。实现这个操作可以通过把物品按照 $a$ 排序，这样每一次查询的范围就是一段后缀。只需要查后缀最小值再修改就可以了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
struct nd{int a,b,c;}a[N];
struct {int l,r,minn;}c[N<<2];
int n,m,k[N],ans;
struct node{int w,v;}t[N];
bool cmpp(node x,node y){return x.w>y.w;}
bool cmp(nd x,nd y){return x.a<y.a;}
void pushup(int pos){
	if(a[c[pos<<1].minn].c<a[c[pos<<1|1].minn].c)c[pos].minn=c[pos<<1].minn;
	else c[pos].minn=c[pos<<1|1].minn;
}
void build(int pos,int l,int r){
	c[pos].l=l,c[pos].r=r;
	if(l==r){
		c[pos].minn=l;
		return ;
	}
	build(pos<<1,l,(l+r)/2);
	build(pos<<1|1,(l+r)/2+1,r);
	pushup(pos);
}
void change(int pos,int x,int v){
	if(c[pos].l>x||c[pos].r<x) return ;
	if(c[pos].l==x&&c[pos].r==x){
		a[x].c=v;
		return ;
	}
	change(pos<<1,x,v);
	change(pos<<1|1,x,v);
	pushup(pos);
}
int ask(int pos,int l,int r){
	if(c[pos].l>r||c[pos].r<l) return 0;
	if(c[pos].l>=l&&c[pos].r<=r)return c[pos].minn;
	int x=ask(pos<<1,l,r),y=ask(pos<<1|1,l,r);
	if(a[x].c<a[y].c) return x;
	else return y;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i].a>>a[i].b;
		a[i].c=a[i].a-a[i].b;
	}
	for(int i=1;i<=m;i++) cin>>t[i].w>>t[i].v;
	a[0].c=1e18;
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++) k[i]=a[i].a;
	sort(t+1,t+1+m,cmpp);
	build(1,1,n);
	for(int i=1;i<=m;i++){
		int x=ask(1,lower_bound(k+1,k+1+n,t[i].w)-k,n);
		if(a[x].c<t[i].v) change(1,x,t[i].v);
	}
	for(int i=1;i<=n;i++)ans+=a[i].a-a[i].c;cout<<ans;
	return 0;
}
```

自认为码风良好。

---

## 作者：2huk (赞：3)

首先不可能按原价买。因为 $b_i \le a_i$。

我们先默认所有物品都是按折扣价 $b_i$ 买。然后尝试用优惠券让答案变小。

不难发现给物品 $i$ 使用优惠券 $j$ 后，答案会减小 $v_j-a_i+b_i$。当然前提是 $a_i \ge w_j$。我们当然是希望让这个东西的和最大。令 $c_i=a_i-b_i$，也就是希望最大化 $v_j-c_i$ 的和。

于是我们将所有物品按照 $a_i$ 降序排序。那么**能使优惠券 $j$ 有效的物品一定是一段前缀**（有效意味 $a_i \ge w_j$）。令这个前缀是 $[1, p_j]$。$p_j$ 的求解可以二分也可以 two-pointers。

于是问题变成了，对于每张优惠券 $j$，需要为它匹配一个物品 $i \le p_j$，然后获得 $v_j-c_i$ 的收益，或者不匹配。要求一个物品不能被多次匹配。求最大收益和。

我们将所有优惠券按照 $p_j$ 升序排序。然后依次考虑每张优惠券 $j$，为它匹配一个物品。

有一种朴素想法：用一个小根堆，以 $c_i$ 为关键字排序，维护 $[1, p_j]$ 中所有仍没匹配的物品 $i$。每次选择堆顶的物品，让优惠券 $j$ 和这个堆顶匹配。因为 $c_i$ 越小 $v_j-c_i$ 越大。

很显然这样是错误的。~~因为真这么简单就不是 NOIP-T2 了~~。因为如果此时把堆顶和 $j$ 匹配，而且在 $j$ 后面有一个优惠券 $k$ 满足 $v_k \ge v_j$，但是匹配到 $k$ 时堆空了（也就是不存在没匹配的物品了），那么把 $j$ 换成 $k$ 一定更优。

所以反悔贪心。

根据上面说的，枚举到一张优惠券 $j$ 时，它会有三种可能：

- 选择一个 $[1,p_j]$ 中仍未匹配的 $c$ 最小的物品 $i$。如果 $v_j \ge c_i$，则与它匹配。答案会增加 $v_j-c_i$。
- 选择一个已经匹配上的 $v$ 最小的优惠券 $k$。如果 $v_j \ge v_k$，则将 $k$ 替换成 $j$。答案会增加 $v_j-v_k$。
- 弃之。答案不变。

考虑如何维护这个过程。我们用一个小根堆，同时存储所有 $[1,p_j]$ 中仍未匹配的物品的 $c_i$，以及所有已经匹配上的优惠券的 $v_k$。可以发现前两种操作对答案的贡献都是 $v_j$ 减堆顶（即堆中的最小值）。

剩下的就是模拟了。

```cpp
#include "bits/stdc++.h"

using namespace std;

#define int long long

const int N = 1e6 + 10;

int n, m;

struct Good {
  int a, b, c;
}goods[N];

struct Quan {
  int w, v, p;
}quans[N];

signed main() {
  cin >> n >> m;

  int sum = 0;
  for (int i = 1; i <= n; ++ i ) {
    cin >> goods[i].a >> goods[i].b;
    goods[i].c = goods[i].a - goods[i].b;
    sum += goods[i].b;
  }

  for (int i = 1; i <= m; ++ i ) {
    cin >> quans[i].w >> quans[i].v;
  }

  sort(goods + 1, goods + n + 1,
    [&](Good x, Good y) {
      return x.a > y.a;
    });
  
  for (int i = 1; i <= m; ++ i ) {
    int lo = 1, hi = n;
    while (lo <= hi) {
      int mid = lo + hi >> 1;
      if (goods[mid].a >= quans[i].w) {
        quans[i].p = mid;
        lo = mid + 1;
      } else {
        hi = mid - 1;
      }
    }
  }

  sort(quans + 1, quans + m + 1,
    [&](Quan x, Quan y) {
      return x.p < y.p;
    });
  
  priority_queue<int, vector<int>, greater<int>> pq;
  int res = 0;
  for (int i = 1, j = 1; i <= m; ++ i ) {
    while (j <= quans[i].p) {
      pq.push(goods[j].c);
      j ++ ;
    }

    if (pq.size() && pq.top() < quans[i].v) {
      res += quans[i].v - pq.top();
      pq.pop();
      pq.push(quans[i].v);
    }
  }
	
  cout << sum - res;

  return 0;
}
```

---

## 作者：Nervegas (赞：1)

## 题意
给出 $n$ 个物品、原价和折扣价，给出 $m$ 张优惠卷，每个物品可以选择使用折扣价购买或者优惠卷购买，每张优惠卷最多使用一次，求出购买完 $n$ 个物品所花费的最小值。

## 分析
一道反悔贪心题。

将物品和优惠卷分别以原价和使用最低价钱为关键字从大到小排序，先默认每个物品使用折扣价购买，并将省的钱放入一个小根堆里。

枚举每一个物品，默认使用折扣购买，将其差价入堆，当枚举到一个物品不能使用当前优惠卷时，那么说明后面的物品原价都小于当前优惠卷的使用限制，并且可以使用当前优惠卷的物品已经入堆了，我们只需要不断的比较堆顶元素，如果使用优惠卷更优，那么我们将其变为使用优惠卷购买即可。
```cpp
#include <bits/stdc++.h>
#define int long long
#define pi pair<int, int>
#define fi first
#define se second
using namespace std;
const int N = 5e6 + 10;
priority_queue<int, vector<int>, greater<int>> q;
pi a[N];
pi b[N];
int n, m;
inline bool cmp(pi a, pi b){
    return a.fi > b.fi;
}
int ans;
signed main(){
    ios::sync_with_stdio(0),cin.tie(0);
    cin >> n >> m;
    for(int i = 1 ; i <= n ; i++) cin >> a[i].fi >> a[i].se, ans += a[i].fi;
    for(int i = 1 ; i <= m ; i++) cin >> b[i].fi >> b[i].se;
    sort(a + 1, a + 1 + n, cmp);
    sort(b + 1, b + 1 + m, cmp);
    int j = 1;
    for(int i = 1 ; i <= n ; i++){
        while(j <= m && b[j].fi > a[i].fi){//当前优惠卷不可使用了，去判断堆里的
            if(!q.empty() && q.top() < b[j].se){//判断哪个更优
                q.pop();
                q.push(b[j].se);
            }
            j++;
        }
        q.push(a[i].fi - a[i].se);//先折扣购买
    }
    for(; j <= m ; j++){
        if(q.top() < b[j].se){
            q.pop();
            q.push(b[j].se);
        }
    }
    while(!q.empty()){
		ans -= q.top();
		q.pop();
	}
    cout << ans << '\n';
    return 0;
}

```

---

## 作者：ClearluvXL (赞：1)

# 【MX-S5-T2】买东西题
[题目](https://www.luogu.com.cn/problem/P11268)
## 思路
首先，我们来分析这样一个情况。假设现在有两件商品，和一个优惠，满足 $a_{1},a_{2}\geq w$。那么此时我们将这个优惠给谁呢？

首先，如果 $a-v\geq b$。那么这个优惠不如直接打折来的划算，我们直接在代价上面加上 $b$。

排除掉上面的一般情况之后，假设现在两种物品都是算上优惠更划算，我们将优惠给谁呢？很明显，将优惠给了一个物品后，该物品会比原价少 $v$，另一物品则是比原价少 $a_{i}-b_{i}$。

现在我们不如先考虑将 $v$ 这个优惠给一个人，当遇到下一个适合这个优惠的人时，如果这个人使用这个优惠更优，那么我们就让这个人使用这个优惠，而不是前面那个人，这就是反悔贪心。

还是接着上面的例子，我们现在把优惠先给 $1$。此时 1 的代价就为 $a_{1}-v$。遇到 $2$，如果 $2$ 要使用这个优惠的话，那么此时 2 的代价就为 $a_{2}-v$，$1$ 的代价为 $b_{1}$，总的代价为 $a_{2}-v+b_{1}$。相当于是在原先 $1$ 的代价上加上了 $a_{2}-v+b_{1}-(a_{1}-v)$。那么不就相当于到 $2$ 时的优惠变成了 $v-(b_{1}-(a_{1}-v))=a_{1}-b_{1}$。

所以，我们在每次决策是否使用此优惠时，如果使用，那么此优惠就更新为 $a_{i}-b_{i}$。

那么现在我们将物品按照 $a$ 从小到大排序。

维护一个集合。满足集合内的优惠的 $w$ 都 $\leq a_{i}$，此时看集合内的最大的 $v$ 能否使得此时使用优惠比打折更划算。能得话我们就要更新这个优惠。

集合的维护可以将每个优惠按照 $w$ 排序，利用双指针加优先队列，每次可以 $\log siz$ 时间来查询最大的 $v$。 $siz$ 最大为 $m$。
## 代码
```c++
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;

const int N=1e6+10;
const int mod=1e9+7;

typedef long long ll;
typedef pair<int,int> pii;

int n,m;

struct porr{
	int a,b;
	bool operator < (const porr x)const{
		return a<x.a;
	}
}p[N];

struct node{
	int w,v;
	bool operator < (const node x) const{
		if(v==x.v) return w<x.w;
		return v<x.v;
	}
}op[N];

bool cmp(node x,node y){
	return x.w<y.w;
}//end

int main(){
//	freopen("1.in","r",stdin);
	
	ios::sync_with_stdio(0);
	
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		int a,b; cin>>a>>b;
		p[i]={a,b};	
	}
	
	sort(p+1,p+n+1);
	
	for(int i=1;i<=m;i++){
		int w,v; cin>>w>>v;
		op[i]={w,v};
	}
	
	sort(op+1,op+m+1,cmp);
	
	ll ans=0;
	int j=0;
	
	priority_queue<node> q;
	for(int i=1;i<=n;i++){
		while(j<m&&op[j+1].w<=p[i].a){
			++j;
			q.push({op[j]});
		}
		
		if(q.empty()){
			ans+=p[i].b;
			continue;
		}
		
		auto now=q.top(); 
		
		if(p[i].a-now.v<p[i].b){
			ans+=p[i].a-now.v;
			q.pop();	
			//now.v-(p[i].b-(p[i].a-now.v))
			if(p[i].a-p[i].b) q.push({now.w,p[i].a-p[i].b});
		}
		else ans+=p[i].b;
	}
	
	cout<<ans<<endl;
	
	return 0;
}//end
```

---


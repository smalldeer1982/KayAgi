# 【MX-X13-T5】「KDOI-12」茫茫人海如都市的晚高峰，迎面的车终将相遇，迎面的车终将分别。

## 题目描述

一条大道共有从北到南和从南到北两个方向，记作方向 $1$ 和方向 $2$。  

每个方向都各有一条基础车道，除此之外，大道还有 $n$ 条动态车道。

一天共会经过 $m$ 个时刻，编号为 $1 \sim m$，其中第 $i$ 个时刻 $j$ 方向会有 $c_{i, j}$ 辆车驶过。

在每一个时刻 $i$，每一条动态车道 $j$ 都会有 $3$ 种情况，记为 $t_{i, j}$（$t_{i, j}\in \{0, 1, 2\}$）。  
其中若 $t_{i, j} = 0$ 则代表这条动态车道无法通行，否则其值就代表这条动态车道允许通过的方向。

动态车道不能随意调转方向，有一个值 $C$ 代表调换动态车道的方向所需要的时间。  
具体来说，如果在 $x$ 时刻与 $x + 1$ 时刻之间决定调换动态车道 $j$（$t_{x, j} \ne 0$）的方向。  
那么对于 $y \in [x + 1, x + C]$，有 $t_{y, j} = 0$。从 $x + C + 1$ 时刻开始（到下一次调转方向为止），$t_{*, j}$ 才变为 $3 - t_{x, j}$。 

特殊的是，对于 $1$ 时刻，可以直接为每个动态车道分配好其对应的方向。

定义时刻 $i$ 时方向 $j$ 的负载量 $v_{i, j}$ 是该时刻通过这个方向的车辆数量与能够通过的车道数量（包括基础和动态车道）的比值，即 $v_{i, j} = \frac{c_{i, j}}{1 + \sum_{k = 1}^n [t_{i, k} = j]}$。  

你需要求出在合理的调配下，最大负载量的最小值是多少。

## 说明/提示

**【样例解释】**

对于样例的第一组测试数据：令 $t_{1, 1} = 2, t_{2, 1} = 0, t_{3, 1} = 1$，这样有 $v_{1, 1} = v_{1, 2} = v_{2, 1} = v_{2, 2} = v_{3, 2} = 1, v_{3, 1} = 1.5$，最大负载量为 $1.5$。可以证明没有比 $1.5$ 更优的分配。

**【数据范围】**

**本题使用捆绑测试。**

| 子任务编号 | 分值 | $n\leq$ | $C\leq$ | $\sum m\leq$ |
|:--:|:--:|:--:|:--:|:--:|
| $1$ | $15$ | $1$ | $m-1$ | $5\times10^5$ |
| $2$ | $20$ | $10^5$ | $1$ | $5\times10^5$ |
| $3$ | $15$ | $10^5$ | $m-1$ | $100$ |
| $4$ | $20$ | $10^5$ | $m-1$ | $5\times10^4$ |
| $5$ | $30$ | $10^5$ | $m-1$ | $5\times10^5$ |

对于所有数据：$1\leq T\leq10^4$，$1\le n\le 10^5$，$1\le c_{i, 1}, c_{i, 2}\le 10^5$，$1\le C < m\leq5\times10^5$，$\sum m\le 5\times 10^5$。

## 样例 #1

### 输入

```
4
1 3 1
1 1 3
2 1 1
1 5 2
1 2 2 1 3
3 2 1 2 2
2 5 1
2 3 1 3 3
2 1 3 1 1
3 6 2
3 5 2 4 1 6
2 3 4 5 6 1```

### 输出

```
1.5000000000
2.0000000000
1.5000000000
3.0000000000
```

# 题解

## 作者：Mars_Dingdang (赞：3)

复健中。

## 题目大意
有 $1\sim m$ 一共 $m$ 个时刻，以及 $1,2$ 两个方向。$i$ 时刻 $1,2$ 方向分别有 $c_{i,1},c_{i,2}$ 辆车通过道路。

道路各方向各有一条基础路，还共有 $n$ 条额外的动态路可以改变方向，但改变方向需要花费 $C$ 天（如某条路第 $i$ 时刻后从 $1$ 方向变为 $2$ 方向，则 $[i+1,i+C]$ 时刻不可用）。

记第 $i$ 条动态路第 $j$ 天的方向为 $t_{i,j}$，不可用则为 $0$，求最小化 

$$\max\left\{\dfrac{c_{i,j}}{1+\sum[t_{k,i}=j]}\right\}$$

## 大体思路
首先二分答案 $mid$，变为要求
$$\dfrac{c_{i,j}}{1+\sum[t_{k,i}=j]}\le mid$$

记第 $i$ 时刻方向为 $1,2$ 的动态路数量为 $a_i,b_i$，则转化为
$$a_i\ge \lceil\dfrac{c_{i,1}}{mid}\rceil-1$$

$$b_i\ge \lceil\dfrac{c_{i,2}}{mid}\rceil-1$$
考虑如何分配动态路。我们先不考虑 $n$ 的限制，按时刻 $1\sim m$ 考虑最少需要的动态路数量。记当前时刻方向为 $1,2$ 的动态路数量为 $x,y$。下面分情况讨论：

1. 若 $a_i<x$ 且 $b_i<y$，$(x,y)$ 保持不变。
2. 若 $a_i\ge x$ 且 $b_i\ge y$，发现必然需要额外补充动态路，则无需是动态路转向，直接令 $(x,y)\leftarrow (a_i,b_i)$。
3. 若 $a_i>x$ 且 $b_i\le y$，则有可能将 $2$ 转向为 $1$。我们考虑最多转向多少条路，这相当于求出长度为 $C$ 的区间内 $mx=\max b_i$ 的滑动窗口问题，用单调队列解决。此时显然有 $y\ge \max(mx, b_i)$。考虑最优的临界情况，$y\leftarrow \max(mx, b_i)$，同时限制 $x+y$ 不减小，然后令 $x\leftarrow a_i$ 即可。

需要注意的是，只有 $x+y\le n$ 限制成立与否，因此我们不需要考虑上述情况中 $x,y$ 的相对大小。可以证明上述方法保证了 $x+y$ 最小化。

至此，单次 check 的时间复杂度为线性，总复杂度为 $O(m\log \omega)$。

## 参考代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef pair<int, int> PII;
const int maxn = 5e5 + 5;
const db eps = 1e-7;
int T, n, m, C, c[maxn][3], a[maxn], b[maxn];
deque <int> qa, qb;
inline bool check(db mid) {
    rep(i, 1, m) {
        a[i] = ceil(c[i][1] * 1.0 / mid) - 1;
        b[i] = ceil(c[i][2] * 1.0 / mid) - 1;
//        printf("%d %d\n", a[i], b[i]);
        if(a[i] + b[i] > n) return 0;
    }
    int x = 0, y = 0;
    qa.clear();
    qb.clear();
    rep(i, 1, m) {
        if(a[i] >= x && b[i] >= y) {
            x = a[i];
            y = b[i];
        }
        else if(a[i] > x) {
            while(!qa.empty() && i - qa.front() > C) qa.pop_front();
            while(!qb.empty() && i - qb.front() > C) qb.pop_front();
            int mx = b[qb.front()];
            if(mx > b[i]) y = max(mx, y + x - a[i]), x = a[i];
            else y = max(b[i], y + x - a[i]), x = a[i];
        }
        else if(b[i] > y) {
            while(!qa.empty() && i - qa.front() > C) qa.pop_front();
            while(!qb.empty() && i - qb.front() > C) qb.pop_front();
            int mx = a[qa.front()];
            if(mx > a[i]) x = max(mx, x + y - b[i]), y = b[i];
            else x = max(a[i], x + y - b[i]), y = b[i];
        }
        while(!qa.empty() && a[i] >= a[qa.back()]) qa.pop_back();
        qa.push_back(i);
        while(!qb.empty() && b[i] >= b[qb.back()]) qb.pop_back();
        qb.push_back(i);
        if(x + y > n) return 0;
    }
    return (x + y) <= n;
}
inline void solve() {
    read(n), read(m), read(C);
    rep(i, 1, m) read(c[i][1]);
    rep(i, 1, m) read(c[i][2]);
    db L = 0, R = 1e5;
//    int ch = check(2.5); writeln(ch);
    while(R - L >= eps) {
        db mid = (L + R) / 2.0;
        if(check(mid)) R = mid;
        else L = mid;
    }
    printf("%.6lf\n", L);
}

int main () {
    read(T);
    while(T --)
        solve();

    return 0;
}
```

---


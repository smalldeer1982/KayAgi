# [GCJ 2021 Qualification] Cheating Detection

## 题目描述

100 名玩家正在参加一场包含 10000 道问题的问答锦标赛，玩家编号为 1 至 100。玩家 $i$ 拥有技能值 $S_i$，问题 $j$ 拥有难度值 $Q_j$。每个技能值和难度值都是从 $[-3.00, 3.00]$ 范围内均匀随机且独立选取的。例如，某个玩家的技能值可能是 2.47853，而某个问题的难度值可能是 -1.4172。

当玩家 $i$ 尝试回答问题 $j$ 时，其答对的概率为 $f(S_i - Q_j)$，其中 $f$ 是 sigmoid 函数：
$$f(x) = \frac{1}{1 + e^{-x}}$$
这里 $e$ 是自然对数的底（约 2.718...）。注意到对所有 $x$ 都有 $0 < f(x) < 1$，因此 $f(S_i - Q_j)$ 始终是有效的概率值。所有答题行为都是随机且独立进行的。

但有一个例外：这些玩家中**恰好有一个是作弊者**！作弊者是从所有玩家中均匀随机选出的，且与其他选择独立。作弊者的行为如下：在回答每个问题前，他们会抛一枚公平硬币。如果结果为正面，则不作弊并正常答题；如果为反面，则会秘密查阅正确答案并确保答对。形式化地说，他们对每个问题以 0.5 的概率独立决定是否作弊。

锦标赛的结果仅包含每位玩家对每道题目的答题结果（正确或错误）。除了上述描述外，你无法获知任何关于玩家技能值或问题难度的具体信息。

你需要在至少 $\mathbf{P}$% 的测试用例中正确识别作弊者。也就是说，在 $\mathbf{T}$ 个测试用例中，你至少要正确判断 $\mathbf{P} \cdot \mathbf{T}/100$ 个。


## 说明/提示

**样例说明**

注意样例输入使用 $\mathbf{T} = 1$ 和 $\mathbf{P} = 0$，因此不满足任何测试集的限制条件。其样例输出展示了实际的作弊者编号。

**数据范围**

- $\mathbf{T} = 50$

**测试集 1（11 分，可见判定）**

- $\mathbf{P} = 10$

**测试集 2（20 分，可见判定）**

- $\mathbf{P} = 86$

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
Use the download button above to view the full sample input.```

### 输出

```
Use the download button above to view the full sample input.```

# 题解

## 作者：ctzm (赞：0)

可能是我第一道独立过的启发式题目？？？还是蓝？纪念一下。

---

### 简要题意

$100$ 人打 CF，这场 CF 有 $10000$ 题，题目难度乱序，每个人的 rating 和题目的难度都在 $[-3,3]$ 内均匀随机，每个人过题的概率是一个蜜汁函数 $f(s-q)$。$s$ 是参赛者的 rating，$q$ 是题目的难度。$f(x) = \frac{1}{1 + e^{-x}}$。

这场比赛有一个人出千，使用 AI 做题。这个人有固定 $50\%$ 概率直接使用 AI 并必定过题，否则自己做。请以至少 $86\%$ 的正确率找出这个老千并送入 cry 的地下室。

---

考虑最 naive 的方法：人们反感作弊者就是因为**作弊者违规地获得了更多的优势**，因此我们可以认为过题数最多的人就是作弊者。

这个方法显然很不合理，我强也是一种罪吗？但足以通过 Subtask #1。事实上，这个方法在我本地运行有 $25\%$ 的正确率。

注意到作弊者是**固定 $50\%$ 概率**作弊过题的，我们发现：

- 作弊者极有可能会过大于一半的题目（因为还有剩下的概率自己写并通过）
- 作弊者大多数时候会在一些很难的题目（通过人数很少的题目）上通过，因为至少有 $50\%$ 的几率你可以直接通过本题，这和难度无关。
- 作弊者有时会在一些简单的题目（通过人数很多的题目）上失败，这时就是作弊者自己做题，就会现出原形了。结合前面那一点，我们发现作弊者出现“会难题不会水题”的频率和程度会显著大于普通参赛者。

结合这些观察，我们可以编写一个“嫌疑函数”$g$，用于反应这个人可能是作弊者的程度。这个函数的定义方式有很多，这里分享我的定义和参数：

- $g(i) = c_1 + c_2$
- 如果参赛者 $i$ 通过题数 $AC_i \ge 5000$，则 $c_1 = AC_i ^ {1.5}$，否则 $c_1 = 0$。
- 接着，对于每道题目，我们计算该参赛者的估计排名 $rank_{i,j}$。设第 $j$ 题有 $cnt_j$ 人通过。
  - 如果该参赛者通过，则 $rank_{i,j} = cnt_j / 2$。
  - 否则 $rank_{i,j} = (100 + cnt_j) / 2$。
- 求每道题目该参赛者的估计排名的平均值 $avg_i$，则 $c2 = 0.12\sum_{j=1}^{10000}(rank_{i,j}-avg_i)^2$。注意这里并不是方差，如果是方差其实还要 $/n$。

然后取 $g(i)$ 最大的参赛者作为作弊者即可。

实测这个做法，本地 $1000$ 个测试用例仅有 $2$ 个出错，完全满足题目 $86\%$ 正确率的要求。

代码（截掉了前面的快读）：

```cpp
int t,p,ans,cnt[10010],ac[110];
double ma;
string s[101];
int main(){
	// freopen("data.txt","r",stdin);
	// freopen("out.txt","w",stdout);
	cin>>t>>p;
	for(int testcases=1;testcases<=t;testcases++){
		ma=ans=0;
		for(int i=0;i<100;i++)ac[i]=0;
		for(int j=0;j<10000;j++)cnt[j]=0;
		for(int i=0;i<100;i++){
			cin>>s[i];
			int _=0;
			for(int j=0;j<10000;j++)if(s[i][j]-'0')cnt[j]++,ac[i]++;
		}
		for(int i=0;i<100;i++){
			double _=(ac[i]>=5000)?pow(ac[i],1.5):0,avg=0;
			vector<double> v;
			for(int j=0;j<10000;j++){
				double rank;
				if(s[i][j]-'0')rank=cnt[j]/2;
				else rank=cnt[j]+(100-cnt[j])/2;
				avg+=rank;
			}
			avg/=10000;
			for(int j=0;j<10000;j++){
				double rank;
				if(s[i][j]-'0')rank=cnt[j]/2;
				else rank=cnt[j]+(100-cnt[j])/2;
				_+=(rank-avg)*(rank-avg)*0.12;
			}
//			cout<<i<<' '<<_<<'\n';
			if(_>ma){
				ma=_;
				ans=i;
			}
		}
		cout<<"Case #"<<testcases<<": "<<ans+1<<'\n';
	}
	return 0;
}
```

[赠送 AI 写的本题数据生成器 && checker](https://www.luogu.com.cn/discuss/1098195)。

---


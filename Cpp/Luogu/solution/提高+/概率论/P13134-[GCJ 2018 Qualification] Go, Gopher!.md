# [GCJ 2018 Qualification] Go, Gopher!

## 题目描述

Code Jam 团队刚刚购买了一片果园，这片果园是一个 $1000$ 行 $1000$ 列的二维矩阵，每个格子都是未经准备的土壤。我们计划在这片果园里种植各种树木——AVL 树、二叉树、红黑树、伸展树等等——因此我们需要通过挖坑来准备一些格子：

- 为了保证每年有足够的树用于树类题目，我们需要至少有 $A$ 个准备好的格子。
- 为了便于照料树木，所有准备好的格子必须组成一个网格对齐的矩形，并且该矩形内的每一个格子都必须被准备好。

注意，上述要求还意味着，矩形外的格子都不能被准备。我们希望果园看起来整洁！

例如，当 $\mathbf A=11$ 时，虽然下图左侧的 11 个准备好的格子组成了一个 $3 \times 4$ 的矩形（即有 3 行 4 列），但该矩形中心的格子尚未准备好。因此，我们还没有完成果园的准备，因为 $3 \times 4$ 矩形内并非每个格子都已准备好。然而，只需再准备中心的那个格子，面积至少为 11 的矩形就被完全填满，果园也就准备好了。

![](https://cdn.luogu.com.cn/upload/image_hosting/qetth289.png)

下面是另一个例子。在这种情况下，$\mathbf{A}=6$。注意，中间的图在 $3\times 2$ 矩形之外准备了一个格子，因此虽然最右侧的图准备了一个面积为 6 的矩形，但所有准备好的格子并未组成一个矩形（因为左侧多了一个格子）。因此，果园还没有准备好。

![](https://cdn.luogu.com.cn/upload/image_hosting/twco3tpd.png)

挖坑对人类来说很辛苦，所以我们从 [Google Go](https://golang.org/) 团队借来了 [Go gopher](https://blog.golang.org/gopher)，并训练它来帮我们准备格子。我们可以通过给它一个目标格子的坐标来部署 gopher，但目标格子不能在矩阵的任意边界上。然而，我们的训练还不够完善，所以它会从以目标格子为中心的 $3\times 3$ 区块的九个格子中，均匀地（伪）随机选择一个格子，然后准备它。（如果它选择了一个已经准备好的格子，它会无用地再准备一次。）

我们最多只能部署 gopher $1000$ 次，否则它会太累而无法继续挖坑，所以我们需要你帮忙，制定一个策略来部署它。每次部署 gopher 后，你会被告知它实际准备了哪个格子，你可以据此决定下一步的部署。注意，你不需要提前声明矩形的尺寸或位置。

### 交互协议

本题为交互题，这意味着输入输出方式与标准 Code Jam 题目不同。你需要与一个独立的进程进行交互，该进程既向你提供信息，也会评判你的回答。所有信息都通过标准输入进入你的程序；你需要传达的信息应通过标准输出发送。请注意，许多编程语言默认会缓冲输出，因此在等待回应前，请确保你的输出已真正发送出去（例如，通过刷新缓冲区）。详见 FAQ 关于刷新缓冲区的说明。你通过标准错误输出的内容会被忽略，但可能会占用内存并计入内存限制，所以不要输出过多调试信息。为帮助你调试，题目末尾提供了本地测试工具脚本（Python 版）。此外，在 Number Guessing 的题解中还提供了所有支持语言的交互题样例代码。

最开始，你的程序应读取一行，包含一个整数 $\mathbf T$，表示测试用例的数量。然后，你需要处理 $\mathbf T$ 个测试用例。

对于每个测试用例，你的程序会读取一行，包含一个整数 $\mathbf A$，表示所需准备的最小矩形面积。然后，你的程序最多可以与评测机进行 $1000$ 次交互。

每次交互时，你需要通过标准输出发送一行，包含两个整数 $I$ 和 $J$，表示你希望部署 gopher 的行号和列号。两个整数都必须在 $2$ 到 $999$ 之间，且为十进制、无前导零。如果你的输出格式错误（如超出范围），你的程序会失败，评测机会返回一行 $-1 -1$，表示测试失败，之后不会再向你的输入流发送任何内容。否则，作为回应，评测机会向你的输入流输出一行，包含两个整数 $I'$ 和 $J'$，表示 gopher 实际准备的格子的行号和列号。

如果上一次部署后，所有准备好的格子组成了一个面积至少为 $\mathbf A$ 的矩形，你会收到 $I' = J' = 0$，表示该测试用例结束。否则，$I'$ 和 $J'$ 是 gopher 实际准备的格子的行号和列号，且满足 $\text{abs}(I'-I) \leq 1$ 且 $\text{abs}(J'-J) \leq 1$。然后，你可以开始下一次交互。

如果你的程序出现错误（如输出格式错误或超出范围），如上所述，评测机会返回 $I' = J' = -1$，之后不会再向你的输入流发送任何内容。如果你的程序在读取到 $I' = J' = -1$ 后仍然等待评测机，则会超时，导致 Time Limit Exceeded 错误。请注意，你有责任让程序及时退出，以获得正确的评判结果（Wrong Answer、Runtime Error 等），而不是 Time Limit Exceeded。和往常一样，如果总时间或内存超限，或程序运行时出错，你会收到相应的评判结果。

如果在 $1000$ 次部署内解决了测试用例，你会收到 $I' = J' = 0$ 的消息，然后继续解决下一个测试用例。如果 $1000$ 次交互后仍未解决该测试用例，评测机会返回 $I' = J' = -1$，之后不会再向你的输入流发送任何内容。

在解决所有测试用例后，你不应再向评测机发送任何信息。换句话说，如果你在收到最后一个测试用例的 $I' = J' = 0$ 消息后仍继续向标准输出打印内容，你会收到 Wrong Answer 的评判。

请注意，对于每个测试用例，gopher 从每个 $3 \times 3$ 区块中选择格子的方式是（伪）随机且彼此独立的，但对于同一个测试用例，每次的随机种子是相同的，因此对于同一个测试用例，错误的解法会始终错误。不同测试用例的随机种子不同。

## 说明/提示

**交互样例**

```
  t = readline_int()         // 读取 t=2
  a = readline_int()         // 读取 a=3
  printline 10 10 to stdout  // 输出 10 10，表示准备该格子
  flush stdout
  x, y = readline_two_int()  // 读取 10 11，表示实际准备了 10 11
  printline 10 10 to stdout  // 再次输出 10 10
  flush stdout
  x, y = readline_two_int()  // 读取 10 10，实际准备了 10 10
  printline 10 12 to stdout  // 输出 10 12
  flush stdout
  x, y = readline_two_int()  // 读取 10 11，再次准备了 10 11
  printline 10 10 to stdout  // 输出 10 10
  flush stdout
  x, y = readline_two_int()  // 读取 11 10，实际准备了 11 10
  printline 11 10 to stdout  // 输出 11 10
  flush stdout
  x, y = readline_two_int()  // 读取 0 0，表示 11 11 被准备好，形成了面积为 4 的矩形
```

上面的伪代码是某一测试组的前半部分交互样例。假设该测试组只有两个测试用例。伪代码首先读取测试用例数 $t$。然后开始第一个测试用例，假设 $\mathbf A = 3$（实际测试组中 $\mathbf A$ 只会是 $20$ 或 $200$）。伪代码首先读取 $a$，然后输出 $10\ 10$，请求准备该格子。由于（伪）随机选择，$10\ 11$ 被准备，于是读取 $10\ 11$。接着再次请求 $10\ 10$，这次 $10\ 10$ 被准备。随后输出 $10\ 12$，希望完成面积为 $3$ 的矩形，但只得到了 $10\ 11$。再次请求 $10\ 10$，这次 $11\ 10$ 被准备。注意，虽然准备好的面积已达 $3$，但还未形成矩形，因此继续准备。最后尝试 $11\ 10$，收到 $0\ 0$，表示 $11\ 11$ 被准备，完成了面积为 $4$ 的矩形（实际上是正方形）。因此，第一个测试用例成功解决。

```
  a = readline_int()         // 读取 a=3
  printline 10 10 to stdout  // 输出 10 10
  x, y = readline_two_int()  // 未刷新输出缓冲区，导致评测机阻塞
```

现在准备第二个测试用例。再次读取 $a=3$，并请求准备 $10\ 10$。但这次忘记刷新输出缓冲区！结果 $10\ 10$ 被缓冲，未发送给评测机。评测机和代码都在等待对方，最终导致超时。

```
  a = readline_int()         // 读取 a=3
  printline 1 1 to stdout    // 输出 1 1
  x, y = readline_two_int()  // 读取 -1 -1，因为 1 不在 [2, 999] 范围内
  printline 10 10 to stdout  // 仍然输出
  x, y = readline_two_int()  // 阻塞，因为评测机已停止发送信息
```

上面是另一个例子。假设第二个测试用例，代码记得刷新输出缓冲区，但输出了 $1\ 1$。注意，行列号必须都在 $[2, 999]$ 范围内，所以 $1\ 1$ 非法！评测机返回 $-1\ -1$。但代码在读取到 $-1\ -1$ 后仍然向评测机发送请求并等待，评测机已停止发送信息，最终导致超时。

注意，如果上述代码在读取到 $-1\ -1$ 后立即退出，则会收到 Wrong Answer：

```
  a = readline_int()         // 读取 a=3
  printline 1 1 to stdout    // 输出 1 1
  x, y = readline_two_int()  // 读取 -1 -1，因为 1 不在 [2, 999] 范围内
  exit                       // 收到 Wrong Answer 评判
```

你可以使用本地测试工具在本地或平台上测试。要在本地测试，你需要让测试工具与你的代码并行运行；你可以使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件中的注释说明。

测试工具的使用说明已包含在脚本注释中。建议你添加自己的测试用例。请注意，虽然测试工具旨在模拟评测系统，但它**不是**真正的评测系统，可能会有不同的表现。

**数据范围**

$1 \leqslant T \leqslant 20$。

**测试点 1（10 分，可见）**

- $A=20$。
- 整个测试点的时间限制：20 秒。

**测试点 2（20 分，隐藏）**

- $A=200$。
- 整个测试点的时间限制：60 秒。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
```

### 输出

```
```

# 题解

## 作者：Objective (赞：0)

前往[博客](https://objective-abk.pages.dev/docs/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/%E9%A2%98%E8%A7%A3%EF%BC%9AP13134%20%5BGCJ%202018%20Qualification%5D%20Go%2C%20Gopher%21/)享受更好阅读效果。

Special Thanks : @[kzt123](https://www.luogu.com.cn/user/927927)，教会了我交互题并一起写了一份代码。

## 思路与算法

### 题意理解

你和人机 Gopher 交流时，你指定布置一个格子，它会在指定的格子以及周围一圈九个格子随机布置，现在需要你跟它进行交互，使得它能够布置一个大小不小于 $\mathbf{A}$ 的矩形。

### 样例分析

根据题意，我们不难发现，Gopher 始终会在你选定的格子为中心的 $3 \times 3$ 的区域布置，也就是说，我们每次都在一个点不停的布置，总会有一个时候，Gopher 能够布置完全部九个格子。

首先我们看到题目给出的例子：![img](https://cdn.luogu.com.cn/upload/image_hosting/qetth289.png)

这里我们铺设了一个 $3 \times 4$ 的大小的矩形，根据我们的思路，我们把它分为多个部分。（如下表，$\text A$ 部分和 $\text{B}$ 部分）

::cute-table

| 行 \ 列 |  1  |  2  |  3  |  4  |
| :---: | :-: | :-: | :-: | :-: |
|   1   |  A  |  A  |  A  |  B  |
|   2   |  A  |  A  |  A  |  B  |
|   3   |  A  |  A  |  A  |  B  |

这里，跟着我们的思路，我们可以先布置 $3 \times 3$ 的区域 A，这部分区域可以照着我们的思路解决，即：不断布置点 $(2, 2)$ 使得 $(1, 1)$ 到 $(3, 3)$ 的所有区域均被布置。

这时候，就只剩下最后一列了。为了避免往外布置更多无用的格子，我们在点 $(2, 3)$ 不断布置，使得第四列的所有点被布置。

所以，总的操作就是：处理完整的九宫格，处理最后剩下的不完整的九宫格。

这里，我们再画一个表格看看。

::cute-table

| 行 \ 列 |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |
| :---: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
|   1   |  A  |  A  |  A  |  B  |  B  |  B  |  C  |  C  |
|   2   |  A  |  A  |  A  |  B  |  B  |  B  |  C  |  C  |
|   3   |  A  |  A  |  A  |  B  |  B  |  B  |  C  |  C  |

我们不难看出，我们每次给出的行坐标总会是 $2$，而列坐标在这里会是 $2 \to 5 \to 7$，也就是在多出的部分之前，是 $2 \to (2 + 3) \to (2 + 2 \times 3) \to$ ······；在多出的部分之后，我们只需要取多出的部分的最后一列的坐标减一即可。

我写代码的时候，最开始为了方便，我使用了 STL 中 `bitset` 的特性来存储我们当前行的格子的布置状态，同时，它还可以直接被赋值为 $0$ 来快速初始化整个数组为零。

:::info[小小科普一下 `bitset`]{open}
**Tips**：`bitset` 是 C++ 中用来存储 `0` 或 `1` 的类型，它可以直接给出数的二进制编码，且对二进制位数没有要求，同时，我们还可以直接用十进制数来赋值（整形）。

定义方法：

```cpp
bitset <128> bs;
```

注：`<>` 中的 `128` 可被替换成为任何正整数，表示这个 `bitset` 所占的二进制位数。

所以，我们只是利用了它很方便重置的特性，但是实际上，我们用 `bool` 数组并使用 `memset()` 进行清零也是可以的。
:::

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

// b[1], b[2], b[3]分别表示第1,2,3行的准备状态
bitset<1005> b[4];

int main() {
    cin.tie(nullptr)->sync_with_stdio(false);
    
    int t;
    cin >> t;
    
    while(t--) {
        // 重置状态
        b[0] = b[1] = b[2] = b[3] = 0;
        
        int a;
        cin >> a;
        
        // 计算需要的列数
        int b1 = ceil(a / 3.0);
        
        // 从第 2 列开始，每次加三（移动到下一次的中心点）
        for(int i = 2; i + 1 <= b1; i += 3) {
            // 确保当前区域的格子都被布置
            while(!b[1][i-1] || !b[1][i] || !b[1][i+1] ||
                  !b[2][i-1] || !b[2][i] || !b[2][i+1] ||
                  !b[3][i-1] || !b[3][i] || !b[3][i+1]) {
                // 当前区域的中心坐标
                cout << 2 << " " << i << endl;
                
                // 实际准备的格子
                int t1, t2;
                cin >> t1 >> t2;
                
                // 已经完成
                if(t1 == 0 && t2 == 0) {
                    break;
                }
                
                // 标记该格子
                b[t1][t2] = 1;
            }
        }
        
        // 处理最后几列
        int t1, t2;
        cout << 2 << " " << b1 - 1 << endl;
        
        // 不断发出坐标，直到完成
        while(cin >> t1 >> t2) {
            if(t1 == 0 && t2 == 0) {
                break;
            }
            cout << 2 << " " << b1 - 1 << endl;
        }
    }
    return 0;
}
```

---

## 作者：seeker142 (赞：0)

真水的交互蓝题……

吐槽一下：交互题难度虚高，另一个例子：CF1039B

注意到可以每次操作一个 $3 \times 3$ 矩形直至填满。

考虑填满一个 $3 \times 3x$ 的矩形。

然后就过了……

```cpp
#include <bits/stdc++.h>
using namespace std;

bool dig[3][3];

int main() {
    int T;
    cin >> T;
    while (T --) {
        int A;
        cin >> A;
        for (int i = 3; ; i += 3) {
            memset(dig, 0, sizeof(dig));
            for (int cnt = 0; cnt < 9; ) {
                int I = i, J = 3;
                cout << I << ' ' << J << endl;
                cin >> I >> J;
                if (!I && !J) goto end;
                if (I == -1 && J == -1) return 0;
                if (!dig[I - i + 1][J - 2]) ++ cnt;
                dig[I - i + 1][J - 2] = true;
            }
        }
        end:;
    }
    return 0;
}
```

求一下期望次数：

经典结论：正面概率为 $p$ 的硬币的期望正面次数是 $\frac{1}{p}$。

所以填满一个 $3 \times 3$ 网格的期望次数为 $\frac{9}{9}+\frac{9}{8}+\frac{9}{7}+\ldots+\frac{9}{1} \approx 25.46 \le 25.5$。

总期望次数小于填满 $\lceil \frac{200}{9} \rceil = 23$ 次 $3 \times 3$ 网格的期望，所以小于 $23 \times 25.5 = 586.5 \ll 1000$。

---

## 作者：WuMin4 (赞：0)

## 题意

交互题，给出 $1000\times 1000$ 的网格，你每次需要选择一个格子，交互库会随机在以该格子为中心的 $3\times 3$ 正方形选择一个格子进行染色。请在 $1000$ 次操作以内使得所有被染色的格子构成一个矩形，且矩形面积大于等于 $A\pod{A\le 200}$。

## 思路

神人题目，直接猜也能 A。

根据直觉，我们考虑对于同一个坐标重复染色，当 $9$ 个格子全部被染色后继续拓展，直到满足条件，然后就 A 了。

以下为证明过程：

我们需要求均匀概率从 $9$ 个格子中染色，把 $9$ 个格子全部染色的期望次数。

设 $f_i$ 表示当前有 $i$ 个格子被染色，成功染色（即不染重复格子）的期望次数。则我们有 $\frac{i}{9}$ 的概率选到已经被染色的格子，$\frac{9-i}{9}$ 的概率成功染色。于是：

$$
f_i=\frac{i}{9}(f_i+1)+\frac{9-i}{9}
$$

移项处理后得到：

$$
f_i=\frac{9}{9-i}
$$

最后的答案即为 $\sum_{i=0}^8 \frac{9}{9-i}\approx 25.46$，直接模拟也可以求出近似的次数。所以我们期望花费 $25.46$ 次可以染 $9$ 个格子，粗略计算得到染出面积至少为 $200$ 的矩形期望次数为 $586$ 次，远远小于题目给出的 $1000$ 的限制，可以通过。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int T,a,l;
map<pair<int,int>,bool> vis;
signed main() {
	cin>>T;
	while(T--){
		vis.clear();
		cin>>a;
		l=ceil(a*1.0/9);
		bool flag=0;
		for(int c,x,y,i=2;true;i+=3){
			c=0;
			while(c!=9){
				cout<<2<<" "<<i<<endl;
				cin>>x>>y;
				if(x==0&&y==0){
					flag=1;
					break;
				}
				if(!vis[{x,y}])
					vis[{x,y}]=true,c++;
			}
			if(flag) break;
		}
	}
	return 0; 
}
```

---


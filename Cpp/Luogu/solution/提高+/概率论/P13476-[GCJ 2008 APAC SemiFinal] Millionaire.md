# [GCJ 2008 APAC SemiFinal] Millionaire

## 题目描述

你受邀参加了著名电视节目“你想成为百万富翁吗？”。当然你想！

游戏规则很简单：

- 在游戏开始前，主持人会转动幸运轮，决定每次下注获胜的概率 $P$。
- 你起始拥有 $X$ 美元。
- 游戏共进行 $M$ 轮下注。在每一轮中，你可以下注当前所拥有金额的任意部分，包括全部或不下注。下注金额可以不是整数。
- 如果你赢得本轮下注，你的总金额会增加你下注的金额；如果你输掉本轮下注，你的总金额会减少你下注的金额。
- 所有下注结束后，如果你累计金额达到 $1000000$ 或以上，你可以保留你的奖金（这时金额向下取整为整数美元）；否则你将一无所获。

给定 $M$、$P$ 和 $X$，请你计算在最优策略下（即最大化成为百万富翁概率的策略），你成为百万富翁的概率。

## 说明/提示

**样例解释**

在第一个样例中，唯一能达到 $1000000$ 的方式是在唯一一轮中押上全部金额。

在第二个样例中，你可以通过合理下注，即使输掉一轮也有机会成为百万富翁。以下是一种下注方式：

- 第一轮你有 \$600000，下注 \$150000。
- 如果第一轮输了，你剩下 \$450000，下注 \$100000。
- 如果第一轮输了、第二轮赢了，你有 \$550000，下注 \$450000。
- 如果第一轮赢了，你有 \$750000，下注 \$250000。
- 如果第一轮赢了、第二轮输了，你有 \$500000，下注 \$500000。

**数据范围**

- $1 \leq N \leq 100$
- $0 \leq P \leq 1.0$，小数点后最多 6 位
- $1 \leq X \leq 1000000$

**小数据集（13 分，测试点 1 - 可见）**

- $1 \leq M \leq 5$

**大数据集（16 分，测试点 2 - 隐藏）**

- $1 \leq M \leq 15$

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
2
1 0.5 500000
3 0.75 600000```

### 输出

```
Case #1: 0.500000
Case #2: 0.843750```

# 题解

## 作者：chen_zhe (赞：0)

本题解来自于[《挑战程序设计竞赛》](https://www.luogu.com.cn/training/813583)。

---

### 1. 该问题的难点

“连续性” 是这个问题的一大特点。每一轮可押的赌注不一定非是整数，因而有无限种可能，所以完全无法穷竭搜索。

### 2. 化连续为离散

但是，认真思考一下就会发现，我们只需要检查 “无限种可能” 中的 “有限种可能” 就足够了，因而可以设计对应的算法。首先来思考一下最后一轮会出现哪些情况。

- 如果你持有 $1000000$ 元以上的钱，就没有再赌的必要了。有 $1$ 的概率可以带钱回家。
- 如果你持有 $500000$ 元以上的钱，不妨全押了。有 $P$ 的概率可以带钱回家。虽然不全押也是可以的，不过因为要求要达到 $1000000$ 元，所以不论怎样都是这轮赢了就能带钱回家，输了就不能带钱回家。
- 如果你持有不到 $500000$ 元的钱，那已经无可奈何了。有 $0$ 的概率可以带钱回家。

![](https://cdn.luogu.com.cn/upload/image_hosting/x035txkx.png)

虽然赌注是连续的（有无限种可能），但实际的概率是像上面这样的阶梯函数。因此，只需考虑处于这三个范围中的哪一个就可以了。

那么，最后两轮时又如何呢？同样地，这次也分为 $5$ 种情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/ewxacl2m.png)

某个范围中，即使所持的钱数不同，最后可以带钱回家的概率也是完全一样的。而且同样地，$M$ 轮时只要考虑 $2^{M}+1$ 种情况就足够了。这样，就可以设计出穷竭搜索的算法了。

### 3. 动态规划

接下来，将穷竭搜索改成动态规划，就能够求解 Large 了。

```cpp
// 输入
int M, X;
double P;

double dp[2][(1 << MAX_M) + 1];

void solve() {
    int n = 1 << M;

    double *prv = dp[0], *nxt = dp[1];
    memset(prv, 0, sizeof(double) * (n + 1));
    prv[n] = 1.0;

    for (int r = 0; r < M; r++) {
        for (int i = 0; i <= n; i++) {
            int jub = min(i, n - i);
            double t = 0.0;
            for (int j = 0; j <= jub; j++) {
                t = max(t, P * prv[i + j] + (1 - P) * prv[i - j]);
            }
            nxt[i] = t;
        }
        swap(prv, nxt);
    }

    int i = (ll)X * n / 1000000;
    printf("%.6f\n", prv[i]);
}

```

---


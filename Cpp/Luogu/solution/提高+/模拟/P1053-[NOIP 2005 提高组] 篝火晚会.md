# [NOIP 2005 提高组] 篝火晚会

## 题目描述

佳佳刚进高中，在军训的时候，由于佳佳吃苦耐劳，很快得到了教官的赏识，成为了“小教官”。在军训结束的那天晚上，佳佳被命令组织同学们进行篝火晚会。一共有 $n$ 个同学，编号从 $1$ 到 $n$。一开始，同学们按照 $1,2,\cdots ,n$ 的顺序坐成一圈，而实际上每个人都有两个最希望相邻的同学。如何下命令调整同学的次序，形成新的一个圈，使之符合同学们的意愿，成为摆在佳佳面前的一大难题。


佳佳可向同学们下达命令，每一个命令的形式如下：

$$(b_1, b_2,... b_{m-1}, b_m)$$

这里 $m$ 的值是由佳佳决定的，每次命令 $m$ 的值都可以不同。这个命令的作用是移动编号是 $b_1,b_2,\cdots, b_m$ 的这 $m$ 个同学的位置。要求 $b_1$ 换到 $b_2$ 的位置上，$b_2$ 换到 $b_3$ 的位置上，……，要求 $b_m$ 换到 $b_1$ 的位置上。执行每个命令都需要一些代价。我们假定如果一个命令要移动 $m$ 个人的位置，那么这个命令的代价就是 $m$。我们需要佳佳用最少的总代价实现同学们的意愿，你能帮助佳佳吗？


## 说明/提示

- 对于 $30\%$ 的数据，满足 $n \le 1000$；
- 对于 $100\%$ 的数据，满足 $3\le n  \le  50000$。

**【题目来源】**

NOIP 2005 提高组第三题

## 样例 #1

### 输入

```
4
3 4
4 3
1 2
1 2
```

### 输出

```
2```

# 题解

## 作者：Actinoi (赞：40)

## NOIP2005 提高组——篝火晚会

​																																										$by - Actinoi $	

$2019/6/22$

为获取最佳阅读效果，建议访问https://www.actinoi.com/2019/06/22/NOIP2005提高组——篝火晚会/			   	 															

​	本题有一个坑，那就是移动的人不需要连续。然后。。。知道这个坑点之后，我们很容易想到最优解，那就是化环为链，构建目标链与初始链，然后找到目标链与初始链中不一样的人的总数，用总人数 $-$ 相同的人数就是需要调换的人数。至于为什么能够在 $O(N)$ 内完成操作，下图可以做一个更加直观的说明。

![1.jpg](https://i.loli.net/2019/06/22/5d0e0754e17fb49023.png)

> 例如，初始环是左边的这个环，目标环是右边的环，如箭头所示的路径，我们可以通过 $（2,5,6）$ 的指令 $O(N)$ 完成变换。

&nbsp;&nbsp;&nbsp;&nbsp;但是，环是可以旋转的，因此我们并不知道怎样转动是最优的。我们便可以考虑以每个点为起点进行搜索，因此，一个~~绝佳的~~ $O(N^2)$ 的算法便出炉啦！

&nbsp;&nbsp;&nbsp;&nbsp;无疑，这个算法会让我们看到一片 $TLE$ 。所以，我们便可以考虑优化这个算法。

 	
&nbsp;&nbsp;&nbsp;&nbsp;如上图，我们从 $1$ 开始构建一条初始链，再构建一条目标链。

#### 初始链： $1,  2,  3,  4,  5,  6$

#### 目标链： $1, 6, 3, 4, 2, 5$

我们将两条链对应的数相减，取绝对值，便可以得到：

#### 差值：$0, 4, 0, 0, 3, 1 $

​&nbsp;&nbsp;&nbsp;&nbsp;在这条差值中， $0$ 出现的次数的是最多的。那么，若果有一条差值 $1$ 出现的次数是最多的，那么，这意味着什么？无疑，将那条链转动 $1$ 个单位，我们便可以得到最优解了！而在程序中，我们并不需要真正转动，只需要统计出现次数最多的差值 $c$，这就代表初始环在转动 $c$ 个单位之后，在同一个位置上的人数与目标环重合的最多，然后用总人数 $n$ 减去差值 $c$ 出现总次数，便是我们需要调换的人的数w量，也就是我们想要的答案 $m$ 啦！

### 等等！

​&nbsp;&nbsp;&nbsp;&nbsp;这既然是一个环，那么，会不会构建目标链得到的结果不一样呢？的确是这样滴。还是以上图为例，从 $1$ 开始我们可以得到 $1, 6, 3, 4, 2, 5$ 与 $1, 5, 2, 4, 3, 6$ 两条链。那这怎么办呢？既然我们不确定我们拥有的目标链是顺时针构建的还是逆时针构建的，我们便可以在计算差值时顺时针与逆时针各跑一边，然后取最大值。我们用 $target$ 数组存储目标链，用 $ initial $ 数组存储初始链，便可以用 $(target[i] - initial[i] + n) % n$ 顺时针从 $1 ～ n$ 跑一遍，再用 $(target[i]- initial[n - initial[i] + 1] + n) % n$ 逆时针从 $n ～ 1$ 跑一遍差值，然后找出最大的差值。

​&nbsp;&nbsp;&nbsp;&nbsp;那么，什么时候不能符合每个同学的愿望呢？其实，只要构出目标环，便一定可以~~用玄学的方法~~使每个同学满意。那么，只有在构不成目标环的时候才输出 $-1$ 。那什么时候构不成目标环呢？无疑，第 $i$ 个同学想挨着的那个人不想挨着他~~（好一个悲伤的故事）~~的时候才构不成环，此时输出 $-1$。所以，我们直接判断第 $i$ 个同学左右两边是否还有空座就可以，如果没有的话，那就。。。输出 $-1$ 了。

最后附上代码：

```cpp
#include <iostream>
using namespace std;
int target[50001], initial[50001], people[50001][3], pluss[50001], minuss[50001]; //存储目标链，初始链，每个人最希望相邻的两个同学的编号，正序相同人数以及逆序相同人数
inline int read() {
    int s = 0, w = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){
        if(ch=='-')
            w=-1;
    ch=getchar();
    }
    while(ch >= '0' && ch <= '9')
        s = s * 10 + ch - '0', ch = getchar();
    return s * w;
}
int main() {
    int n;
    n = read();
    for (int i = 1; i <= n; i++) //读入编号是 i 的同学最希望相邻的两个同学的编号
        people[i][1] =read(), people[i][2] = read();
    target[1] = 1;
    target[2] = people[1][2]; //构建目标链
    initial[1] = 1;
    initial[n] = n; //构建初始链
    for (int i = 2; i <= n - 1; i++) {
        initial[i] = i; //构建初始链
        if (target[i - 1] == people[target[i]][1])
            target[i + 1] = people[target[i]][2];
        else if (target[i - 1] == people[target[i]][2])
            target[i + 1] = people[target[i]][1]; //构建目标链
        else{
            cout << -1 << endl; //第 i 个人希望相邻的人旁边没有空位了，无法构建目标链（一个悲伤的故事）
            return 0;
        }
    }
    int ans = 0;
    for(int i = 1; i <= n; i++){
        pluss[(target[i] - initial[i] + n) % n]++; //顺时针从 1 ~ n 跑一遍
        minuss[(target[i]- initial[n - initial[i] + 1] + n) % n]++; //逆时针从 n ~ 1 跑一遍差
    }
    for (int i = 0; i <= n - 1; i++)
        ans = max(ans, max(pluss[i], minuss[i])); //找差值人数最多的
    cout << n - ans; //总人数 - 不用移动的人数 = 需要移动的人数，也就是答案
    return 0;
}
```



---

## 作者：Drinkkk (赞：8)

- ### NOIP2005提高组第 3 题

**题面**

https://www.luogu.org/problemnew/show/P1053 。

**题目描述**

佳佳刚进高中，在军训的时候，由于佳佳吃苦耐劳，很快得到了教官的赏识，成为了“小教官”。在军训结束的那天晚上，佳佳被命令组织同学们进行篝火晚会。一共有 $n$ 个同学，编号从 $1$ 到 $n$ 。一开始，同学们按照 $1,2,…,n$ 的顺序坐成一圈，而实际上每个人都有两个最希望相邻的同学。如何下命令调整同学的次序，形成新的一个圈，使之符合同学们的意愿，成为摆在佳佳面前的一大难题。

佳佳可向同学们下达命令，每一个命令的形式如下：

$$(b_1, b_2,... b_{m-1}, b_m)$$

这里 $m$ 的值是由佳佳决定的，每次命令 $m$ 的值都可以不同。这个命令的作用是移动编号是 $b_1,b_2,…, b_m$ 的这 $m$ 个同学的位置。要求 $b_1$ 换到 $b_2$ 的位置上， $b_2$ 换到 $b_3$ 的位置上，……，要求 $b_m$ 换到 $b_1$的位置上。执行每个命令都需要一些代价。我们假定如果一个命令要移动 $m$ 个人的位置，那么这个命令的代价就是 $m$ 。我们需要佳佳用最少的总代价实现同学们的意愿，你能帮助佳佳吗？

**输入输出格式**

- 输入格式

第一行是一个整数 $n\;(3 \leq n \leq 50000)$ ，表示一共有 $n$ 个同学。

其后 $n$ 行每行包括 $2$ 个不同的正整数，以一个空格隔开，分别表示编号是 $1$ 的同学最希望相邻的两个同学的编号，编号是 $2$ 的同学最希望相邻的两个同学的编号，……，编号是 $n$ 的同学最希望相邻的两个同学的编号。

- 输出格式
一个整数，为最小的总代价。如果无论怎么调整都不能符合每个同学的愿望，则输出 ``-1``。

**输入输出样例**

- 输入样例#1
```
4
3 4
4 3
1 2
1 2
```
- 输出样例#1
```
2
```

**数据范围**

对于 $30\%$ 的数据，$n \leq 1000$ ；

对于全部的数据，$n \leq 50000$ 。

## 题解

首先我们可以通过给出来的相邻关系把这个环给建出来。

怎么建呢？首先先设 $a_i$ 表示这个环中的第 $i$ 个人的原来的编号（$1$~$n$）， $l_i$ 和 $r_i$ 分别是这个人想要的与之相邻的两个人的编号。那么我们就可以先让 $a_n=l_1,a_1=1,a_2=r_1$。因为这个环是可旋转的qwq。

然后如果 $a_{i-2}$ 是 $a_{i-1}$ 期望的左边，那么 $a_i$ 就应是 $a_{i-1}$ 所期望的右边，所以 $a_i=r_{a_{i-1}}$。

反之，如果 $a_{i-2}$ 是 $a_{i-1}$ 期望的右边，那么 $a_i$ 就应是 $a_{i-1}$ 所期望的左边，所以 $a_i=l_{a_{i-1}}$。

如果都不满足的话说明这样的环不存在，输出 $-1$ 。

这一部分的代码是这样的：
```
a[n]=l[1],a[1]=1,a[2]=r[1];
for(int i=3;i<=n-1;i++)
{
	if(a[i-2]==l[a[i-1]])
	{
		a[i]=r[a[i-1]];
	}
	else if(a[i-2]==r[a[i-1]])
	{
		a[i]=l[a[i-1]];
	}
	else
	{
		printf("-1");
		return 0;
	}
}
```

然后就是求答案辣！

我们用 $dis1_i$ 表示从原位置走到目标位置顺时针要走 $i$ 步的人有多少个。

并且用 $dis2_i$ 表示从原位置走到目标位置逆时针要走 $i$ 步的人有多少个。

易得，对于一个人 $i$，他会对 $dis1_{(i-a_i+n)\;mod\;n}$ 以及 $dis2_{(i+a_i+n)\;mod\;n}$ 均产生 $1$ 的贡献。然后我们就可以把它们统计出来了。

下面是这一部分的代码。

```
for(int i=1;i<=n;i++)
{
	dis1[(i-a[i]+n)%n]++;
	dis2[(i+a[i]+n)%n]++;
}
```

因为若有 $k$ 个人不在目标位置上，则需要 $k$ 的代价。所以有

$$ans=n-\max_{i=0}^{2n} max(dis1_i,dis2_i)$$

求一下就可以了。

完整代码：
```
#include <cstdio>
int l[1000001],r[1000001];
int a[1000001],cx[1000001];
int dis1[1000001],dis2[1000001];
int max(int x,int y)
{
	return x>y?x:y;
}
int main()
{
	int n=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d %d",&l[i],&r[i]);
	}
	a[n]=l[1],a[1]=1,a[2]=r[1];
	for(int i=3;i<=n-1;i++)
	{
		if(a[i-2]==l[a[i-1]])
		{
			a[i]=r[a[i-1]];
		}
		else if(a[i-2]==r[a[i-1]])
		{
			a[i]=l[a[i-1]];
		}
		else
		{
			printf("-1");
			return 0;
		}
	}
	for(int i=1;i<=n;i++)
	{
		dis1[(i-a[i]+n)%n]++;
		dis2[(a[i]+i+n)%n]++;
	}
	int ans=0;
	for(int i=0;i<=n*2;i++)
	{
		ans=max(ans,max(dis1[i],dis2[i]));
	}
	printf("%d",n-ans);
	return 0;
}
```

---

## 作者：LastKismet (赞：1)

# [NOIP 2005 提高组] 篝火晚会

## 一个性质

你会发现，如果存在合法最终状态的话，那么这个最终状态是唯一的。（不考虑顺时针与逆时针的差异）原因很简单，每个节点两侧的节点是固定的。

所以考虑构造最终序列。直接深搜即可。

当不存在合法序列，当且仅当一个节点想相邻的节点不想与它相邻。深搜的时候和上一个节点判断一下即可。

为了方便，我们考虑直接储存这个最终环中，任意一个起点向任意一个方向开始遍历整个环形成的链。

## 另一个性质

考虑题目中的操作，你发现并不要求 $b$ 相邻连续。然后就很傻。

你可以对任何当前需要换的节点集合构造出一次操作使得它们全部归位。每个节点在操作序列中的下一个节点，就是它本来应该在的位置当前的节点，显然最后一个节点应该在第一个节点当前的位置上。这样构造出来的操作一次就可以让序列复原，并显然最优。

所以问题就变成了，已知初始序列（就是 $1$ 到 $n$ 的顺序排列），和最终序列，任意翻转或旋转最终序列，最大化与初始序列相等的元素数。最后的答案就是与最终序列不相等的位置数的最小值。

## 最后的细节

如果你枚举所有起点与方向的话，复杂度是 $O(n^2)$ 的。

首先我们暂时忽略翻转操作（就是顺时针与逆时针两种情况），只考虑旋转起点。

你发现，由于每个节点应该在的位置唯一，所以要想他“和最初序列匹配上”所需要的旋转次数也是唯一的。（只考虑顺时针旋转，也就是非负。显然右移 $n-1$ 次等价于左移 $1$ 次。）

我们记录当前起点下每个节点要想匹配需要的旋转次数，就可以选择一个匹配上节点最多的旋转次数，得到答案。

这里我们假设我们构造出的最终序列为 $a$。从 $1$ 开始编号。

具体的，$a_i$ 节点当前的位置是 $i$，本来应该在 $a_i$，它要想匹配上需要旋转 $(a_i-i+n)\bmod n$ 次。

然后考虑翻转一次序列，这时 $a_i$ 节点当前的位置在 $n-i+1$，所以就需要旋转 $[a_i-(n-i+1)+n]\bmod n$ 次。显然翻转多于一次没有意义。

分别记录翻转和不翻转的答案取最优值即可。

## 主要代码

```cpp
#define chmax(a,b) a=max(a,b)
#define chmin(a,b) a=min(a,b)
#define rep(i,x,y) for(int i=(x);i<=(y);i++)
#define per(i,x,y) for(int i=(x);i>=(y);i--)
#define repl(i,x,y) for(int i=(x);i<(y);i++)

const int N=5e4+5;

int n;
int l[N],r[N];
int a[N];
int num[N];

int cnt;
int be;
void dfs(int now,int fid){
    if(fid){
        if(l[now]!=fid&&r[now]!=fid)cout<<-1,exit(0);
        if(r[now]==fid)swap(l[now],r[now]);
    }
    a[++cnt]=now;
    if(!be)be=now;
    else if(now==be)return;
    dfs(r[now],now);
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
    rep(i,1,n)cin>>l[i]>>r[i];
    dfs(1,0);
    rep(i,1,n)num[(a[i]-i+n)%n]++;
    int chs=0;
    repl(i,0,n)if(num[i]>num[chs])chs=i;
    int ans=num[chs];
    repl(i,0,n)num[i]=0;
    rep(i,1,n)num[(a[i]-(n-i+1)+n)%n]++;
    repl(i,0,n)if(num[i]>num[chs])chs=i;
    chmax(ans,num[chs]);
    cout<<n-ans;
    return 0;
}
```

---

## 作者：LXcjh4998 (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P1053)
# 题意
现有 $n$ 个人，编号为 $1$ 到 $n$。一开始，他们按 $1,2,\cdots,n$ 的顺序排成一圈。然而，每个人都有其最希望相邻的两个人。

我们可以执行以下操作若干次，使得最后排列的顺序能满足每个人的要求：

- 给定一个序列 $(b_1,b_2,\cdots,b_{m-1},b_m)$，并让 $b_1$ 换到 $b_2$ 的位置上，$b_2$ 换到 $b_3$ 的位置上，……$b_{m-1}$ 换到 $b_m$ 的位置上，$b_m$ 换到 $b_1$ 的位置上。这一操作的代价为 $m$，并且每次操作的 $m$ 可以不相等。

**注意：移动的人不一定要连续。**

若能通过若干次操作，使得最后的顺序能满足每个人的要求，则输出最小总代价；否则输出 $-1$。
# 思路
首先，根据每个人的希望，我们可以先尝试构造出一条目标链，如果构造不出来，则可以直接输出 $-1$。

然后，我们将目标链与初始链对应的数作差（模 $n$ 的意义下），那些结果为 $0$ 的人的位置是不用变的，而剩下的人都需要调整。

接着我们便可以惊奇的发现，若需要调整的人数为 $m$，则我们只需要 $1$ 次代价为 $m$ 的操作即可将他们调整好 ~~（至于为什么则留给读者思考）~~。

当然由于环是可以旋转的，所以实际上我们不需要调整的人不一定就是作差后结果为 $0$ 的人。那么，选择哪些人可以使我们操作的总代价最小呢？

为了使调整的人数最少，我们无需调整的人数就要最多。而实际上，只要我们采取合适的旋转方式，任何一个人都可以由需要调整，变为不需要调整。因此，我们只需统计在作差得到的结果中出现次数最多的数（即众数）出现了几次，而这就是无需调整的人数。

最后，由于最初的顺序是顺时针还是逆时针不确定，所以我们需要二者都跑一遍，最后得出结果。

例如，对于样例，模拟结果如下：

- 构造目标链：$1,4,2,3$。
- 构造初始链：$1,2,3,4$。
- 顺时针统计：$0,2,3,3$。
- 逆时针统计：$1,1,0,2$。
- 无需调整的人数：$2$。
- 最终结果：$4-2=2$。

因此输出结果为：
```cpp
2
```
# 程序
```cpp
#include<cstdlib>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<queue>
#include<cstdio>
#include<iostream>
#include<vector>
#include<map>
#include<cmath>
#include<iomanip>
#include<string>
#include<stack>
using namespace std;
long long T=1,mod;
#define ll long long
#define ull unsigned long long
#define LL 2e18
#define INT 1e9
#define INF 0x3f3f3f3f
#define MAX int(50000)
//#define DEBUG
//#define use_cin
//#define more_text

int n,                       //人数 
	expect_person[MAX+1][2]; //每个人希望相邻的两个人 

int target_list[MAX+1],      //目标链 
	initial_list[MAX+1],     //初始链 
	plus_order[MAX+1],       //顺时针，统计作差结果出现的次数 
	minus_order[MAX+1],      //逆时针，统计作差结果出现的次数 
	ans;                     //记录无需调整的人数的最大值 

void solve(int step){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%d%d",&expect_person[i][0],&expect_person[i][1]);//输入 
	
	target_list[1]=1;
	target_list[2]=expect_person[1][1];
	for(int i=2;i<=n-1;++i){
		if(target_list[i-1]==expect_person[target_list[i]][0])
			target_list[i+1]=expect_person[target_list[i]][1];
		else if(target_list[i-1]==expect_person[target_list[i]][1])
			target_list[i+1]=expect_person[target_list[i]][0];
		else{
			printf("-1"); //无法满足要求 
			return;
		}
	} //构造目标链 
	
	for(int i=1;i<=n;++i)initial_list[i]=i; //构造初始链 
	
	for(int i=1;i<=n;++i)
		++plus_order[(target_list[i]-initial_list[i]+n)%n],      //顺时针统计
		++minus_order[(target_list[i]-initial_list[n-i+1]+n)%n]; //逆时针统计
	
	for(int i=0;i<n;++i)
		ans=max(ans,max(plus_order[i],minus_order[i])); //统计答案 
	
	printf("%d",n-ans); //输出 
}
int main(){//模板，不用在意
	#ifdef DEBUG
	freopen("test.in","r",stdin);freopen("test.out","w",stdout);
	#endif
	#ifdef more_text
	#ifdef use_cin
	cin>>T;
	#else
	scanf("%lld",&T);
	#endif
	#endif
	for(int i=0;i<T;++i)solve(i);
	#ifdef DEBUG
	fclose(stdin);fclose(stdout);
	#endif
	return 0;
}
/*
Input:

Output:

Outline:

*/
```

---

## 作者：cwxcplh (赞：0)

这是一道很有趣的题。

先开始看到这道题是用模拟，还有点惊讶，后来看了一下题解才恍然大悟，我主要是对题解的进一步解释和说明。

首先我们要求最小代价 ~~（一般看到这种题都很难）~~，直接想肯定想不出来，我们倒着想。

我们先不看最小，就求如何把一个环变成另一个环。因为环不方便接，所以我们首先会断环成链，把一个环变成一个链式数组，举个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/82ate6gt.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

这个图中很明显把 $2$ 跟 $5$ 交换、$3$ 跟 $4$ 交换，只需要四步就行，我们来断环成链：

**初始链：**`1 2 3 4 5 6`。

**目标链：**`1 5 4 3 2 6`。

很明显，我们只需要找出有多少个点不动，剩下的全都要动，所以剩下的点都可以算作一个代价。

但有一个问题：环是可以旋转的，不一定初始链和目标链的 $1$ 就要在同一个位置，这也很简单，我们只需要枚举每个点跟 $1$ 对应就行了，这样我们就找到了一个~~极好的~~ $O(n^2)$ 的做法。

那么增么优化成 $O(n)$ 的呢？很简单，我们这么想：只要环往后旋转一格，那那些差值为 $1$ 的格之间就没有差值了，因为初始链是有序的，所以往后转一格相当于给每个数所对应的数加一。所以我们只需要一作差，然后求出差当中出现数量做多的那个数的次数，总数减去这个数就是答案了。

但还有个问题：环是没有方向的，怎么判断顺时针还是逆时针呢？很简单，正反都跑一遍不就对了。

[提交记录，完美 AC](https://www.luogu.com.cn/record/201885638)

**代码实现：**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,ans,a[50006][6],cs[50006],mb[50006],mp1[50006],mp2[50006];
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i][1]>>a[i][2];
		cs[i]=i;
	}
	mb[1]=1,mb[2]=a[1][2],mb[n]=a[1][1];
	for(int i=2;i<n;i++)
	{
		if(mb[i-1]==a[mb[i]][1])
		{
			mb[i+1]=a[mb[i]][2];
		}
		else if(mb[i-1]==a[mb[i]][2])
		{
			mb[i+1]=a[mb[i]][1];
		}
		else
		{
			cout<<-1;
			return 0;
		}
	}
	for(int i=1;i<=n;i++)
	{
		mp1[(mb[i]-cs[i]+n)%n]++;
		mp2[(mb[i]-cs[n-i+1]+n)%n]++;
	}
	for(int i=0;i<n;i++)
	{
		ans=max(ans,max(mp1[i],mp2[i]));
	}
	cout<<n-ans;
	return 0;
}
```

---


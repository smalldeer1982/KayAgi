# [NOIP 2005 提高组] 等价表达式

## 题目描述

明明进了中学之后，学到了代数表达式。有一天，他碰到一个很麻烦的选择题。这个题目的题干中首先给出了一个代数表达式，然后列出了若干选项，每个选项也是一个代数表达式，题目的要求是判断选项中哪些代数表达式是和题干中的表达式等价的。

这个题目手算很麻烦，因为明明对计算机编程很感兴趣，所以他想是不是可以用计算机来解决这个问题。假设你是明明，能完成这个任务吗？

这个选择题中的每个表达式都满足下面的性质：

1. 表达式只可能包含一个变量 $\tt a$。
2. 表达式中出现的数都是正整数，而且都小于 $10000$。
3. 表达式中可以包括四种运算 `+`（加），`-`（减），`*`（乘），`^`（乘幂），以及小括号 `()`。小括号的优先级最高，其次是 `^`，然后是 `*`，最后是 `+` 和 `-`。`+` 和 `-` 的优先级是相同的。相同优先级的运算（**包括 `^` 运算**）都是**从左到右**进行。
4. 幂指数只可能是 $1$ 到 $10$ 之间的正整数（包括 $1$ 和 $10$）。
5. 表达式内部，头部或者尾部都可能有一些多余的空格。

下面是一些合理的表达式的例子：

`((a^1) ^ 2)^3`，`a*a+a-a`，`((a+a))`，`9999+(a-a)*a`，`1 + (a -1)^3`，`1^10^9`


## 说明/提示

- 对于 $30\%$ 的数据，表达式中只可能出现两种运算符 `+` 和 `-`；
- 对于其它的数据，四种运算符 `+-*^` 在表达式中都可能出现。  
- 对于 $100\%$ 的数据，表达式中都可能出现小括号 `()`，$2 \le n \le  26$。

**【题目来源】**

NOIP 2005 提高组第四题

## 样例 #1

### 输入

```
( a + 1) ^2
3
(a-1)^2+4*a
a + 1+ a
a^2 + 2 * a * 1 + 1^2 + 10 -10 +a -a
```

### 输出

```
AC```

# 题解

## 作者：ClV_Csy (赞：10)

# P1054 [NOIP2005 提高组] 等价表达式
## 前言
做题顺序建议：
1. [P1449 后缀表达式](https://www.luogu.com.cn/problem/P1449)
2. [P10473 表达式计算4](https://www.luogu.com.cn/problem/P10473)
3. [P1054 [NOIP2005 提高组] 等价表达式](https://www.luogu.com.cn/problem/P1054)

**注意：**
- 下文中的**表达式**（前缀表达式、中缀表达式、后缀表达式除外）表示“**含有一个未知数 $a$ 或不含未知数的代数式**”。
- 下文中的**表达式的元素**表示“**表达式中的数、运算符`+`，`-`，`*`，`^`和左右括号`(`，`)`**”。
## 题意
先给出一个表达式，再给出 $n$ 个选项，每个选项都是一个表达式。需要输出这 $n$ 个表达式中与原表达式等价的表达式的选项序号（大写字母）。
## 思路
### 一、如何判断两表达式等价
将未知数 $a$ 替换为一个已知数（例如 $1145$），再计算表达式，表达式的值相等即认为两表达式相等。
### 二、如何计算表达式
（这也是前言中 [P10473 表达式计算4](https://www.luogu.com.cn/problem/P10473) 的常规做法）  
本题的表达式是中缀表达式，较难直接计算。所以，我们可以使用如下顺序完成计算：
#### 1.将中缀表达式转换为后缀表达式
要将中缀表达式转换为后缀表达式，可以通过对表达式内每个元素按以下规则完成：  
（有一个“运算符栈”，用于存放运算符 `+`，`-`，`*`，`^` 和左括号 `(`。**注意**：右括号 `)` **从不**出现在“运算符栈”内。）  
1. 如果为数，则直接添加到后缀表达式中。
2. 如果为运算符 `+`，`-`，`*`，`^`，则重复将“运算符栈”栈顶元素添加到后缀表达式中，再将“运算符栈”栈顶元素从“运算符栈”中弹出，直到“运算符栈”栈顶元素优先级小于该运算符优先级或“运算符栈”为空，再加入该运算符。
3. 如果为左括号 `(`，则直接加入“运算符栈”。
4. 如果为右括号 `)`，则重复弹出“运算符栈”栈顶元素，直到左括号 `(` 也弹出。
5. 当表达式内所有元素处理完毕后，依次弹出“运算符栈”所有元素并添加到后缀表达式中。

例如，我们要将中缀表达式 `1*2-3^4+5` 转换成后缀表达式，则执行顺序如下：  
1. 第一个元素为 `1`，是数。直接加入到后缀表达式内。此时后缀表达式为 `1`，“运算符栈”为 ` `。  
2. 第二个元素为 `*`，是运算符。此时“运算符栈”为空，直接加入 `*` 到“运算符栈”内。此时后缀表达式为 `1`，“运算符栈”为 `*`。  
3. 第三个元素为 `2`，是数。直接加入到后缀表达式内。此时后缀表达式为 `1 2`，“运算符栈”为 `*`。  
4. 第四个元素为 `-`，是运算符。“运算符栈”栈顶 `*` 优先级大于 `-`，弹出并加入到后缀表达式内。现在栈为空，直接加入 `-` 到“运算符栈”内。此时后缀表达式为 `1 2 *`，“运算符栈”为 `-`。  
5. 第五个元素为 `3`，是数。直接加入到后缀表达式内。此时后缀表达式为 `1 2 * 3`，“运算符栈”为 `-`。  
6. 第六个元素为 `^`，是运算符。“运算符栈”栈顶元素 `-` 优先级小于 `^`，不弹出，并将 `^` 加入到“运算符栈”内。此时后缀表达式为 `1 2 * 3`，“运算符栈”为 `- ^`。  
7. 第七个元素为 `4`，是数。直接加入到后缀表达式内。此时后缀表达式为 `1 2 * 3 4`，“运算符栈”为 `- ^`。  
8. 第八个元素为 `+`，是运算符。“运算符栈”栈顶元素 `^` 优先级大于 `+`，弹出并加入到后缀表达式内。现在“运算符栈”栈顶元素 `-` 优先级等于 `+`，也弹出并加入到后缀表达式内。现在栈为空，直接加入 `+` 到“运算符栈”内。此时后缀表达式为 `1 2 * 3 4 ^ -`，“运算符栈”为 `+`。  
9. 第九个元素为 `5`，是数。直接加入到后缀表达式内。此时后缀表达式为 `1 2 * 3 4 ^ - 5`，“运算符栈”为 `+`。  
10. 所有元素处理完毕，弹出“运算符栈”内所有元素并加入到后缀表达式内。此时后缀表达式为 `1 2 * 3 4 ^ - 5 +`，“运算符栈”为 ` `。  
11. 转换结束，后缀表达式结果为 `1 2 * 3 4 ^ - 5 +`。

**注意：**
- 记得判断正负
- 十年 OI 一场空，不开 long long 见祖宗
- 优先级不要弄反

该部分代码：

```cpp
#include <iostream>
#include <stack>
using namespace std;
typedef long long ll;
int gety(char op) { //返回一个运算符的优先级
	switch (op) {
		case '+' : return 1; break;
		case '-' : return 2; break;
		case '*' : return 3; break;
		case '^' : return 4; break;
	}
	return -1;
}
stack <char> st; //用于存储运算符和左括号的栈
void calc(string s) { //中缀转后缀的函数
	bool flag = 0; //正数 
	ll sum = 0;
	for (int i = 0; i < s.size(); i++) {
		if (s[i] == '-' && (s[i - 1] == '(' || i == 0)) {
			flag = 1; //负数
		} else if (s[i] >= '0' && s[i] <= '9') {
			sum = sum * 10 + s[i] - '0'; //与前面的数字是同一个数，合并
		} else if (s[i - 1] >= '0' && s[i - 1] <= '9'){ //数字部分结束
			if (flag == 1) sum = -sum;
			cout << sum << " ";
			flag = 0;
			sum = 0;
		}
		if (s[i] == ')') {
			while (st.top() != '(') {
				cout << st.top() << " ";
				st.pop();
			}
			st.pop();
		} else if (s[i] == '+' || (s[i] == '-' && s[i - 1] != '(' && i != 0) || s[i] == '*' || s[i] == '^') {
			if (st.size() != 0) {
				while (gety(st.top()) >= gety(s[i])) { //只有栈顶优先级小于待加入优先级才停止弹出
					cout << st.top() << " ";
					st.pop();
					if (st.size() == 0) {
						break;
					}
				}
			}
			st.push(s[i]);
		} else if (s[i] == '(') {
			st.push(s[i]);
		}
	}
	while (st.size() != 0) { //弹出剩余运算符
		cout << st.top() << " ";
		st.pop();
	}
}
int main() {
	calc("1*2-3^4+5");
	return 0;
}
```

#### 2.计算后缀表达式（这也是前言中 [P1449 后缀表达式](https://www.luogu.com.cn/problem/P1449) 的常规做法）
要计算后缀表达式，可对每个元素进行如下操作：
（有一个“数栈”，用于存储数）
- 如果为数，直接加入“数栈”。
- 如果为运算符，先取出“数栈”栈顶元素 $n2$，弹出“数栈”栈顶，再取出此时“数栈”栈顶元素 $n1$，再次弹出“数栈”栈顶。将 $n1, n2$ 做运算符所示运算，并将运算结果重新进栈。如运算符为 `+`，则做 $n1 + n2$ 运算。

操作结束后，“数栈”栈顶即是所求数。

例如，要计算后缀表达式 `1 2 * 3 4 ^ - 5 +`，操作过程如下：  
1. 第一个元素 `1` 为数。直接加入“数栈”。此时“数栈”为 `1`。
2. 第二个元素 `2` 为数。直接加入“数栈”。此时“数栈”为 `1 2`。
3. 第三个元素 `*` 为运算符。取出两栈顶元素，且 $n1 = 1, n2 = 2$，得到 $n1 \times n2 = 2$，将结果 $2$ 进栈。此时“数栈”为 `2`。
4. 第四个元素 `3` 为数。直接加入“数栈”。此时“数栈”为 `2 3`。
5. 第五个元素 `4` 为数。直接加入“数栈”。此时“数栈”为 `2 3 4`。
6. 第六个元素 `^` 为运算符。取出两栈顶元素，且 $n1 = 3, n2 = 4$，得到 $n1 ^ {n2} = 81$，将结果 $81$ 进栈。此时“数栈”为 `2 81`。
7. 第七个元素 `-` 为运算符。取出两栈顶元素，且 $n1 = 2, n2 = 81$，得到 $n1 - n2 = -79$，将结果 $-79$ 进栈。此时“数栈”为 `-79`。
8. 第八个元素 `5` 为数。直接加入“数栈”。此时“数栈”为 `-79 5`。
9. 第九个元素 `+` 为运算符。取出两栈顶元素，且 $n1 = -79, n2 = 5$，得到 $n1 + n2 = -74$，将结果 $-74$ 进栈。此时“数栈”为 `-74`。
10. 操作结束，“数栈”栈顶 `-74` 即是所求数。

前文写到的所有部分综合代码：
```cpp
#include <iostream>
#include <stack>
using namespace std;
typedef long long ll;
void init(string &s) {
	s += '@'; //防止找不到表达式结束标志
}
int gety(char op) {
	switch (op) {
		case '+' : return 1; break;
		case '-' : return 2; break;
		case '*' : return 3; break;
		case '^' : return 4; break;
	}
	return -1;
}
stack <ll> ans;
stack <char> st;
ll pow(ll a, ll b) {
	ll p = 1;
	for (int i = 1; i <= b; i++) {
		p = (p * a);
	}
	return p;
}
void cz(char op) {
	if (op == '(') {
		return;
	}
	ll n2 = ans.top();
	ans.pop();
	ll n1 = ans.top();
	ans.pop();
	switch (op) {
		case '+' : ans.push(n1 + n2); break;
		case '-' : ans.push(n1 - n2); break;
		case '*' : ans.push(n1 * n2); break;
		case '^' : ans.push(pow(n1, n2)); break;
	}
}
ll calc(string s) {
	init(s);
	bool flag = 0; //正数 
	ll sum = 0;
	for (int i = 0; i < s.size(); i++) {
		if (s[i] == '-' && (s[i - 1] == '(' || i == 0)) {
			flag = 1;
		} else if (s[i] == 'a') {
			sum = 1145;
			if (flag == 1) sum = -sum;
			ans.push(sum);
			flag = 0;
			sum = 0;
		} else if (s[i] >= '0' && s[i] <= '9') {
			sum = sum * 10 + s[i] - '0';
		} else if (s[i - 1] >= '0' && s[i - 1] <= '9'){
			if (flag == 1) sum = -sum;
			ans.push(sum);
			flag = 0;
			sum = 0;
		}
		if (s[i] == ')') {
			while (st.top() != '(') {
				cz(st.top());
				st.pop();
			}
			st.pop();
		} else if (s[i] == '+' || (s[i] == '-' && s[i - 1] != '(' && i != 0) || s[i] == '*' || s[i] == '^') {
			if (st.size() != 0) {
				while (gety(st.top()) >= gety(s[i])) { 
					cz(st.top());
					st.pop();
					if (st.size() == 0) {
						break;
					}
				}
			}
			st.push(s[i]);
		} else if (s[i] == '(') {
			st.push(s[i]);
		}
	}
	while (st.size() != 0) {
		cz(st.top());
		st.pop();
	}
	return ans.top();
}
int main() {
	cout << calc("1*2-3^4+5");
	return 0;
}
```

### 三、其他细节
由于本题输入的表达式中可能含有空格，所以不可简单地使用 `cin` 或 `scanf` 来读入数据。容易想到使用 `getline`，但是这样会导致无法正确读入第二行的数 $n$。考虑到 `gets` 不安全，可能会出现问题，因此，我们使用 `getchar` 来读入数据。

读入部分代码：
```cpp
string s;
int n;
char c = getchar();
while (c != '\n' && c != '\r') { //输入第一行表达式
	if (c != ' ') {
		s += c;
	}
	c = getchar();
}
cin >> n;
for (int i = 1; i <= n; i++) {
	s = ""; //表达式清空
	c = getchar();
	while (c == '\n' || c == '\r') { //过滤多余换行符
		c = getchar();
	}
	while (c != '\n' && c != '\r') { //输入选项中的表达式
		if (c != ' ') {
			s += c;
		}
		c = getchar();
	}
}
```
又因为数据刁钻，左右括号可能不匹配，所以需要去除多余的右括号（多余的左括号不去除没有影响）。  
代码：
```cpp
void init(string &s) {
	int l = 0, r = 0;
	for (int i = 0; i < s.size(); i++) {
		if (s[i] == '(') l++;
		else if (s[i] == ')') r++;
		if (l < r) {
			s.erase(i, 1);
			r--;
		}
	}
	s += '@';
}
```
又又因为本题数据过于刁钻（没完了是吧），运算过程中和结果爆 long long，需要模一个模数（如 $1e9+7$）。  
还有可能出现负数，所以运算符运算时需要加上一个模数再取模。  
**注意：**
- 求幂时每一步运算后也需要取模。

至此，本题终于 AC 了。

## 代码

```cpp
#include <iostream>
#include <stack>
using namespace std;
typedef long long ll;
ll mod = 1e9 + 7;
void init(string &s) {
	int l = 0, r = 0;
	for (int i = 0; i < s.size(); i++) {
		if (s[i] == '(') l++;
		else if (s[i] == ')') r++;
		if (l < r) {
			s.erase(i, 1);
			r--;
		}
	}
	s += '@';
}
int gety(char op) {
	switch (op) {
		case '+' : return 1; break;
		case '-' : return 2; break;
		case '*' : return 3; break;
		case '^' : return 4; break;
	}
	return -1;
}
stack <ll> ans;
stack <char> st;
ll pow(ll a, ll b) {
	ll p = 1;
	for (int i = 1; i <= b; i++) {
		p = (p * a) % mod;
	}
	return p;
}
void cz(char op) {
	if (op == '(') {
		return;
	}
	ll n2 = ans.top();
	ans.pop();
	ll n1 = ans.top();
	ans.pop();
	switch (op) {
		case '+' : ans.push(((n1 + n2) + mod) % mod); break;
		case '-' : ans.push(((n1 - n2) + mod) % mod); break;
		case '*' : ans.push(((n1 * n2) + mod) % mod); break;
		case '^' : ans.push((((ll)pow(n1, n2)) + mod) % mod); break;
	}
}
ll calc(string s) {
	init(s);
	bool flag = 0; //正数 
	ll sum = 0;
	for (int i = 0; i < s.size(); i++) {
		if (s[i] == '-' && (s[i - 1] == '(' || i == 0)) {
			flag = 1;
		} else if (s[i] == 'a') {
			sum = 1145;
			if (flag == 1) sum = -sum;
			ans.push(sum);
			flag = 0;
			sum = 0;
		} else if (s[i] >= '0' && s[i] <= '9') {
			sum = sum * 10 + s[i] - '0';
		} else if (s[i - 1] >= '0' && s[i - 1] <= '9'){
			if (flag == 1) sum = -sum;
			ans.push(sum);
			flag = 0;
			sum = 0;
		}
		if (s[i] == ')') {
			while (st.top() != '(') {
				cz(st.top());
				st.pop();
			}
			st.pop();
		} else if (s[i] == '+' || (s[i] == '-' && s[i - 1] != '(' && i != 0) || s[i] == '*' || s[i] == '^') {
			if (st.size() != 0) {
				while (gety(st.top()) >= gety(s[i])) { 
					cz(st.top());
					st.pop();
					if (st.size() == 0) {
						break;
					}
				}
			}
			st.push(s[i]);
		} else if (s[i] == '(') {
			st.push(s[i]);
		}
	}
	while (st.size() != 0) {
		cz(st.top());
		st.pop();
	}
	return ans.top() % mod;
}
int main() {
	string s;
	int n;
	char c = getchar();
	while (c != '\n' && c != '\r') {
		if (c != ' ') {
			s += c;
		}
		c = getchar();
	}
	ll p = calc(s);
	cin >> n;
	for (int i = 1; i <= n; i++) {
		s = "";
		c = getchar();
		while (c == '\n' || c == '\r') {
			c = getchar();
		}
		while (c != '\n' && c != '\r') {
			if (c != ' ') {
				s += c;
			}
			c = getchar();
		}
		if (calc(s) == p) {
			cout << char('A' + i - 1);
		}
	}
	return 0;
}
```

---

## 作者：BitByBit (赞：7)

[AC](https://www.luogu.com.cn/record/206514316)
# 题意
输入一个表达式和其他 $n$ 个表达式，求与第一个表达式等价的表达式。
# 思路
令第一个表达式为 $s_0$，其余 $n$ 个表达式为 $s_1$ 至 $s_n$。判断两个表达式等价，就是在两个表达式中的变量 $a$ 取值相等时表达式的值也相等。于是不难想到随机生成一些变量的值，代入到表达式中，如果值都相等，就说明两个表达式是等价的。

输入的是中缀表达式，为了计算方便，需要将其转换为后缀。从头到尾扫描中缀表达式，对不同类型的字符按不同情况处理：
1. 如果是数字则直接放入后缀表达式数组；
2. 如果是左括号则直接入栈；
3. 如果是右括号，则把从栈顶直到对应左括号之间的运算符依次退栈，写入后缀表达式数组,并清除对应的左括号；
4. 对于运算符，如果该运算符的优先级大于栈顶优先级，则直接入栈，若该运算符的优先级小于等于栈顶优先级，则把栈顶运算符逐个出栈，写入后缀表达式数组，直到遇到左括号或者遇到比它优先级小的运算符。然后再入栈；
5. 扫描完成后，取出栈中所有运算符，写入后缀表达式数组。

实际上，将一个表达式转为一棵树后，中缀表达式就是其中序遍历，后缀表达式就是其后序遍历，例如表达式 $(a-1)^2+4a$，如图：![](https://cdn.luogu.com.cn/upload/image_hosting/59ib2hcn.png)

中缀表达式为这棵树的中序遍历，后缀表达式即其后序遍历 `a 1 - 2 ^ 4 a * +`。中缀转后缀用栈实现。

计算后缀表达式的方法是：
1. 初始化操作数堆栈为空；
2. 分析表达式，遇到操作数，压入操作数堆栈；
3. 遇到操作符，依次从操作数堆栈弹出两个数 $A,B$，并将 $A$ 和 $B$ 运算的结果（为一个新的操作数）压入操作数堆栈；
4. 表达式结束，从操作数堆栈弹出一个操作数即为最后的结果。

也是用栈来实现。
# 实现
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll N=10000,M=10000,mod=1000000007;
stack<char>st1;
stack<ll>st2;
string s,s1,s2;
char c;
ll n,m,i,j,k,x,y,z,num,ansl,ansr;
ll a[N],b[N];
bool flag;
inline bool cmp(char x,char y)//比较运算符的优先级
{
	if(y=='('||x=='*'&&(y=='+'||y=='-')||x=='^'&&(y=='+'||y=='-'||y=='*'))return 0;
	return 1;
}
ll power(ll x,ll y)//快速幂加取模
{
	if(x==0)return 0;
	ll i,res=1;
	for(i=1;i<=y;i++)res=res*x%mod;
	return (res+mod)%mod;
}
inline ll Mod(ll x)//取模函数，便于处理负数
{
	return (x%mod+mod)%mod;
}
ll calc(string s,ll p)//计算后缀表达式
{
	ll i;
	while(!st2.empty())st2.pop();//清空栈
	num=0;
	for(i=0;i<=s.size()-1;i++)
	{
		if(s[i]>='0'&&s[i]<='9'||s[i]=='a')//数字
		{
			if(s[i]=='a')num=p;
			else num=num*10+s[i]-48;
			num%=mod;
		}
		else
		{
			if(s[i-1]>='0'&&s[i-1]<='9'||s[i-1]=='a')
			{
				st2.push(num);//数进栈
				num=0;
			}
			if(s[i]!=' ')//出栈并计算
			{
				y=st2.top();st2.pop();
				x=st2.top();st2.pop();
				if(s[i]=='+')z=Mod(x+y);
				else if(s[i]=='-')z=Mod(x-y);
				else if(s[i]=='*')z=Mod(x*y);
				else if(s[i]=='^')z=power(x,y);
				st2.push(z);
			}
		}
	}
	return st2.top();
}
string change(string s)//转中缀为后缀
{
	s=s+" ";
	ll i;
	while(!st1.empty())st1.pop();//清空栈
	s2="";
	for(i=0;i<=s.size()-1;i++)
	{
		if(s[i]>='0'&&s[i]<='9'||s[i]=='a')
			s2+=s[i];
		else
		{
			if(s[i-1]>='0'&&s[i-1]<='9'||s[i-1]=='a')s2+=" ";
			if(s[i]=='(')
				st1.push('(');
			else if(s[i]==')')
			{
				while(st1.top()!='(')
				{
					s2+=st1.top();
					st1.pop();
				}
				st1.pop();
			}
			else if(s[i]=='+'||s[i]=='-'||s[i]=='*'||s[i]=='^')
			{
				while(!st1.empty()&&cmp(s[i],st1.top()))
				{
					s2+=st1.top();
					st1.pop();
				}
				st1.push(s[i]);
			}
		}
	}
	while(!st1.empty())
	{
		s2+=st1.top();
		st1.pop();
	}
	return s2;
}
bool check(string s)//必须判断表达式是否合法
{
	ll i,tot=0;
	for(i=0;i<=s.size()-1;i++)
	{
		if(s[i]=='(')tot++;
		else if(s[i]==')')tot--;
		if(tot<0)return 0;
	}
	if(tot)return 0;
	return 1;
}
int main()
{
	srand(time(NULL));//随机数种子
	c=getchar();//用getchar读入字符串
	while(c=='\n'||c=='\r')c=getchar();
	while(c!='\n'&&c!='\r')
	{
		if(c!=' ')s+=c;
		c=getchar();
	}
	s=change(s);
	for(i=1;i<=50;i++)
	{
		x=rand()%2;//符号
		if(!x)x=-1;
		a[i]=(rand()%M)*x;//随机数作为变量的值
		b[i]=calc(s,a[i]);//计算结果
	}
	scanf("%lld",&n);getchar();
	for(i=1;i<=n;i++)
	{
		s1="";
		c=getchar();
		while(c=='\n'||c=='\r')c=getchar();
		while(c!='\n'&&c!='\r')
		{
			if(c!=' ')s1+=c;
			c=getchar();
		}
		if(!check(s1))continue;//判断是否合法
		s1=change(s1);
		flag=1;
		for(j=1;j<=50;j++)
			if(calc(s1,a[j])!=b[j])
			{
				flag=0;
				break;//计算是否等价
			}
		if(flag)putchar(i+64);
	}
}
```
# 注意
1. 要判断表达式是否合法；
2. 要用 `getchar` 读入，否则RE。

---

## 作者：Shadow_Soldier (赞：3)

在 2025 年 3 月 29 日，我发现自己的题解中的【如果可能有负数怎么办？】的部分有很大的问题，现已纠正。
# 题意简化
给出一个表达式和其它 $n(2 \le n \le 26)$ 个表达式（本文中，若只提到“表达式”，无“前缀”或“后缀”说明，则默认为中缀表达式），依次对应选项标号 $A,B,C,\cdots$（按大写字母顺序），求与原表达式等价的其它所有表达式的标号（按顺序从前至后）。  
关于表达式的细节，大家可以看看题目：[P1054 [NOIP 2005 提高组] 等价表达式](https://www.luogu.com.cn/problem/P1054) ，这里就不再进一步叙述了。
# 暴力（30pts）
注意到 $30\%$ 的数据中“表达式中只可能出现两种运算符 `+` 和 `-`”，我们可以将每个表达式都转变成 $xa+y$ 的形式。具体而言，用两个变量分别记录 $x$ 与 $y$（这里就用 $x$ 与 $y$ 做变量名），初值为零。当遇到加（减）变量 $a$ 时，就用 $x$ 加（减） $1$；当遇到加（减）一个常数 $u$ 时，就用 $y$ 加（减） $u$。最后只需要用每个表达式的 $x$ 和 $y$ 与原表达式的 $x$ 和 $y$ 作比较，都相等就表明该表达式与原表达式等价，否则不等价。只要注意细节，这 $30$ 分是能够拿到的。  
# 正解思路
拿到这道题，很容易就能够想到：把所有表达式都转变成只含 $a$ 的多项式，再与原表达式进行比较，如果对应项系数都相等，就表明该表达式与原表达式等价，否则不等价。可是，如何把一个表达式转变成只含 $a$ 的多项式呢？不仅操作实践难，还容易出错。况且，$a$ 的最高次数也是很大的，不仅如此，每个多项式的系数与次数也可能很大，得用高精度来存储，就算取模也不好做（也不是精确算法）。所以，这种做法基本上是不行了。  
那么怎么办呢？如何判断两个表达式等价呢？首先，若对于每个 $a$ 代入原表达式与（其它表达式中的一个）进行求值后比较都相等，则必然这两个表达式等价，否则不等价。所以可以想到，只尝试 $a$ 的一个取值，两个等价的表达式必然满足将这个 $a$ 的取值代入后的结果相等。但是，将这个 $a$ 的取值代入后的结果相等并不意味着这两个表达式**一定**等价。这怎么办呢？没关系，因为这表明这两个表达式**大概率**等价。
现在还是有一些问题，其中一个就是：最后的结果可能很大，是不是要用高精度呢？一旦用了高精度，所有运算的时间复杂度都会变大。但是其实并不需要用高精度，一边运算一边对结果取模就可以了。  
所以，大体的思路基本上就有了。给 $a$ 一个取值，分别代入到每个表达式中求值（对一个数取模的结果，一边运算一边取模），再将原表达式的结果与其他表达式的结果一一比较，得出结果（大概率正确）。    
# 实现方法（细化）
## 补充：中缀表达式求值（同级运算从左至右）
### 第一步：输入
输入其实也是一个细节，需要根据不同的情况选择不同的读入方式。可以整体读入，没有空格时可以用 `cin` 或者 `scanf` 整体读入，遇到可能有空格的时候可以用 `getline`（最好不要用 `gets` 函数，可能不安全）；也可以单个字符读入（通常用 `getchar` 函数）。
### 第二步：中缀表达式转后缀表达式
假设已经得到一个字符串 `str`，表示这个中缀表达式。直接对中缀表达式求值并不方便，可以先把中缀表达式转成后缀表达式。  
先建一个字符串（后缀表达式）和一个符号栈。再从左往右扫描字符串（中缀表达式），一边扫一边分离（数字和 其它符号），得到一个元素（数字与其它符号，可以用 `string` 形式）后进行如下操作：  

- 若该元素为数字，则将其拼接在后缀表达式后。  
- 若该元素为运算符（括号不算），则一直将符号栈栈顶元素弹出并将其拼接在后缀表达式后，直到符号栈栈空或栈顶为左括号或该元素的优先级大于栈顶元素的优先级。  
- 若该元素为左括号，则直接将该元素入符号栈。   
- 若该元素为右括号，则一直将符号栈栈顶元素弹出并将其拼接在后缀表达式后，直到符号栈栈空或栈顶为左括号（如果直到栈空都没有找到左括号，就说明这个表达式的括号不匹配，所以如果表达式一定匹配就不需要判断栈空）。然后，再将符号栈栈顶元素弹出（当然，如果这个表达式的括号匹配的话，一定是左括号）。

扫描完了之后，最后再做一件事：一直将符号栈栈顶元素弹出并将其拼接在后缀表达式后，直到符号栈栈空（当然，如果遇到左括号，就说明这个表达式的括号不匹配）。  
这样，就成功地把一个中缀表达式转成后缀表达式。
### 第三步：后缀表达式求值
接下来，只要对这个后缀表达式求值，就能够求出原中缀表达式的值了。  
建一个数字栈。先从左往右扫描字符串（后缀表达式），一边扫一边分离（同上）。得到一个元素后进行如下操作：  

- 若该元素为数字，则将其入数字串。  
- 若该元素为运算符（不可能是括号），令 $t_1$ 为数字栈栈顶元素，再将数字栈栈顶元素岀栈；令 $t_2$ 为数字栈栈顶元素，再将数字栈栈顶元素岀栈（如果表达式合法，就不可能中间栈空）。然后：  
  - 若该元素为 `+`，则将 $t_2 + t_1$ 的结果入栈。  
  - 若该元素为 `-`，则将 $t_2 - t_1$ 的结果入栈。  
  - 若该元素为 `*`，则将 $t_2 \times t_1$ 的结果入栈。  
  - 若该元素为 `^`，则将 ${t_2} ^ {t_1}$ 的结果入栈。

扫描完了之后，数字栈中一定恰好剩余一个数字（如果表达式合法的话），那么这个数就是后缀表达式的结果。  
当然，具体求 ${t_2} ^ {t_1}$ 的时候，用快速幂还是循环 $t_1$ 次就随便了，因为本题数据比较小，但是我个人倾向于写快速幂。
### 关于其他问题
#### 如果可能有负数怎么办？
首先，因为负号与减号在中缀表达式中都是 `-`，所以需要将它们区别开来。  
如何区别呢？注意到负号要么在表达式的最前面，要么前面是左括号；而减号要么在数字的后面，要么在右括号的后面。所以，同样是 `-`，我们就可以通过找它前面的字符（注意，有可能在最前面）来判断它是负号，还是减号。如果是减号，那么就把它当作运算符，否则把它当作它后面的数的一部分。定义一个变量（比如说 $w$），刚开始（扫描前）赋值为 $1$。当扫描到运算符时，判断是否是负号。如果是，则将 $w$ 取相反数赋值后 `continue`，否则按运算符处理。当扫描到数时，就在入栈前将这个数的结果乘上 $w$，并将 $w$ 赋值为 $1$。  
可是，这样做对吗？  
有一组 hack 就是 `-(2-3)`，如果按照刚才的方法计算，它会先将 $2$ 取反，再减去 $3$。然而，括号的作用就没有了。所以，这样的方法**是错的**。  
那怎么办呢？因为 $-a$ 表示的就是 $0 - a$，所以可以把 $-a$ 转换成 $0 - a$，也就是如果有一个负号，可以先在数字栈中加入 $0$，然后再用之前的方法在符号栈中加入一个 `-` 即可。
#### 能否将多个步骤合并？
注意到在第二步中，后缀表达式是从左至右转换出来的，而第三步的时候，后缀表达式也是从左至右地扫描的。所以，可以把第三步与第二步合并。将第二步中“若该元素为运算符”的部分替换为第三步中“若该元素为运算符”的部分，第三步就不需要了（答案就是数字栈里唯一的数）。  
如果输入使用的是单个字符读入的方式，可以一边输入一边进行第二步的操作。当然，可以叠加上面的第二、三步的合并。
### 贴代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
char ch, ch2, stk2[100010];
int w, temp, top1, top2, stk1[100010];
bool flag;
int Pow(int x, int y) {//快速幂
    if(!y) return 1;
    int tmp = Pow(x, y >> 1);
    tmp *= tmp;
    if(y & 1) tmp *= x;
    return tmp;
}
void Op(char op) {//计算表达式的值
    int temp = stk1[top1--];
    if(op == '+') stk1[top1] += temp;
    if(op == '-') stk1[top1] -= temp;
    if(op == '*') stk1[top1] *= temp;
    if(op == '^') stk1[top1] = Pow(stk1[top1], temp);
}
int F(char op) {//给出一个运算符的优先级
    if(op == '+' || op == '-') return 1;
    if(op == '*') return 2;
    if(op == '^') return 3;
    return 0;//括号
}
signed main()
{
    ch2 = ' ';//赋初值，用于判断负号
    w = 1;//正负标记变量
    ch = getchar();
    while(ch != '\n' && ch != '\r') {
        temp = 0;
        flag = false;
        while(ch >= '0' && ch <= '9') {
            temp = temp * 10 + (ch - '0');
            ch2 = ch;
            ch = getchar();
            flag = true;
        }
        if(flag) {
            stk1[++top1] = temp * w;
            w = 1;
        }
        if(ch == '\n' || ch == '\r') {
            break;
        }
        if(ch == ' ') {
            ch = getchar();
            continue;
        }
        if(ch == '(') {
            stk2[++top2] = '(';
        }
        else if(ch == ')') {
            while(top2 && stk2[top2] != '(') {
                Op(stk2[top2--]);
            }
            if(!top2) {
                cout << "ERROR";//右括号左边没有匹配的左括号
                return 0;
            }
            --top2;
        }
        else if(ch == '+' || ch == '-' || ch == '*' || ch == '^') {
            if(ch == '-' && (ch2 == ' ' || ch2 == '(')) {//判负号
                w = -w;
            }
            else {
                while(top2 && F(ch) <= F(stk2[top2])) {
                    Op(stk2[top2--]);
                }
                stk2[++top2] = ch;
            }
        }
        ch2 = ch;
        ch = getchar();
    }
    while(top2) {//倒着拼接在后缀表达式后并计算
        if(stk2[top2] == '(') {
            cout << "ERROR";//左括号右边没有匹配的右括号
            return 0;
        }
        Op(stk2[top2--]);
    }
    cout << stk1[1];
    return 0;
}
``````
该代码时候情况为：

- 仅存在 `+`、`-`、`*`、`^` 作为运算符（括号为 `(` 和 `)`，`-` 可以作为负号），数字都是整数。
- 所有幂指数为非负整数，不存在要求计算 $0^0$。
- 所有同级运算都是从左至右进行计算（包括幂运算）。
- 不论是计算中还是初值或最终答案，都在 $64$ 位 `long long` 的范围内。
- 表达式可能不合法，需要输出 `ERROR`。但是只存在括号不匹配导致表达式不合法的情况。
- 表达式长度不超过 $10^5$。
- 可能出现负数，但是保证负号要么出现在最前面，要么出现在 `(` 的后面。

代码仅供参考，不喜勿喷。
## 代入原题
将上面的部分（【补充：中缀表达式求值】）代入到原题中时，要注意：在快速幂和上述函数 `Op` 中都要进行取模。那么，尤其要注意的就是在做减法的时候取模，**一定要加上模数再取模！**  
当然，原题中有一个变量 $a$，就需要加一个判断，但是其实 $a$ 也是一个数，就相当于输入了一个数，这个数是你要给 $a$ 的取值，不过整体思路还是一样的，没有什么大的改动。  
原题中，既没有要判断括号是否匹配，也没有负数的存在。所以，并不需要上面【补充：中缀表达式求值】的代码那些关于判负号、判括号是否匹配的语句。  
当然，可以将中缀表达式求值的语句封装成一个函数，每次调用这个函数即可。注意要将一些变量初始化。  
# 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
char ch, ch2, stk2[100010];
int temp, top1, top2, stk1[100010];
bool flag;
int Pow(int x, int y) {//快速幂
    if(!y) return 1;
    int tmp = Pow(x, y >> 1);
    tmp *= tmp;
    if(y & 1) tmp *= x;
    return tmp;
}
void Op(char op) {//计算表达式的值
    int temp = stk1[top1--];
    if(op == '+') stk1[top1] += temp;
    if(op == '-') stk1[top1] -= temp;
    if(op == '*') stk1[top1] *= temp;
    if(op == '^') stk1[top1] = Pow(stk1[top1], temp);
}
int F(char op) {//给出一个运算符的优先级
    if(op == '+' || op == '-') return 1;
    if(op == '*') return 2;
    if(op == '^') return 3;
    return 0;//括号
}
signed main()
{
    ch2 = ' ';//赋初值，用于判断负号
    ch = getchar();
    while(ch != '\n' && ch != '\r') {
        temp = 0;
        flag = false;
        while(ch >= '0' && ch <= '9') {
            temp = temp * 10 + (ch - '0');
            ch2 = ch;
            ch = getchar();
            flag = true;
        }
        if(flag) {
            stk1[++top1] = temp;
        }
        if(ch == '\n' || ch == '\r') {
            break;
        }
        if(ch == ' ') {
            ch = getchar();
            continue;
        }
        if(ch == '(') {
            stk2[++top2] = '(';
        }
        else if(ch == ')') {
            while(top2 && stk2[top2] != '(') {
                Op(stk2[top2--]);
            }
            if(!top2) {
                cout << "ERROR";//右括号左边没有匹配的左括号
                return 0;
            }
            --top2;
        }
        else if(ch == '+' || ch == '-' || ch == '*' || ch == '^') {
            if(ch == '-' && (ch2 == ' ' || ch2 == '(')) {//判负号
                stk1[++top1] = 0;
            }
            while(top2 && F(ch) <= F(stk2[top2])) {
                Op(stk2[top2--]);
            }
            stk2[++top2] = ch;
        }
        ch2 = ch;
        ch = getchar();
    }
    while(top2) {//倒着拼接在后缀表达式后并计算
        if(stk2[top2] == '(') {
            cout << "ERROR";//左括号右边没有匹配的右括号
            return 0;
        }
        Op(stk2[top2--]);
    }
    cout << stk1[1];
    return 0;
}
``````
# 提交记录
[我的提交记录](https://www.luogu.com.cn/record/203651763)  
# 最后说的话
文中所有代码都仅供参考。  
如果文中有错误，欢迎指正。  
此题代码不难，自己将每一步理解后写出来就可以了，**千万不要抄代码！**  
最后祝愿大家 AC 本题！

---

## 作者：shihaocheng110909 (赞：2)

## 前言
一道很适合新手的表达式计算题，码量不压行一百五十行到二百行之间。
## 方法
我这里使用的是分治法，顾名思义，分而治之。我们将将一个字符串进行如下操作：

如果两边是括号的话，那么就删除两边的括号；

如果全都是数字，那么就将这段字符串转为数字并返回；

如果这个算式呈“算式——符号——算式”，那么我们就进行递归。

利用如上方法，我们就可以很轻松的完成处理一个算式的方法了。

这道题还是比较细节的，首先，题目中会出现许多“鬼畜”的符号，如 `a#^10*9&( $4+!1` 就可能成为你答案错误的原因，注意特判。其次，题目可能会出现前后少括号的情况，需要在输入的时候，特判一下补括号。讲个小技巧，我们可以多试几个 $a$ 的值，每次把与原题不相等的标记一下。$a$ 的值我们可以从 $0$ 一直循环到 $9$，就可以了。最后一点，因为可能会出现如 `a ^ 10 ^ 10 ^ 10 ^ 10` 这样鬼畜的东西，我们可以使用自然溢出法，减少我们的工作量。

~~这里没有代码~~

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
string s[30];
ull ll,rr;
bool vis[30];
int n;
ull yx(char ch)//符号优先级 
{
	if(ch=='+')return 1;
	if(ch=='-')return 1;
	if(ch=='*')return 2;
	if(ch=='^')return 3;
	return 1928374655;
}
ull s_t_i(int l,int r,string ss)//将字符串ss第l位到r为转为数字 
{
	ull ans=0;
	for(int i=l;i<=r;i++)
	{
		ans=ans*10+ss[i]-'0';
	}
	return ans;
}
ull solve(int l,int r,string ss)//分治处理字符串 
{
	ull ps=0,mid=0;//ps来判断是否处于括号内，mid来记录括号外优先级最低的符号的位置 
	for(int i=l;i<=r;i++)
	{
		if(ss[i]=='('){ps++;continue;}
		if(ss[i]==')'){ps--;continue;}
		if(!ps&&(ss[i]=='+'||ss[i]=='*'||ss[i]=='-'||ss[i]=='^'))
		{
			if(yx(ss[mid])>=yx(ss[i]))mid=i;
		}
	}
	ull lll=l,rrr=r;
	while(ss[lll]!='+'&&ss[lll]!='*'&&ss[lll]!='-'&&ss[lll]!='^'&&ss[lll]!='('&&ss[lll]!=')'&&(ss[lll]<'0'||ss[lll]>'9'))lll++;
	while(ss[rrr]!='+'&&ss[rrr]!='*'&&ss[rrr]!='-'&&ss[rrr]!='^'&&ss[rrr]!='('&&ss[rrr]!=')'&&(ss[rrr]<'0'||ss[rrr]>'9'))rrr--;
	//分类讨论 
	if(mid==0)//没有找到括号外的符号 
	{
		if(ss[lll]=='('&&ss[rrr]==')')//括号报过整个字符串 
		{
			return solve(lll+1,rrr-1,ss);
		}
		else//整个是一个数 
		{
			return s_t_i(lll,rrr,ss);
		}
	}
	else//递归 
	{
		if(ss[mid]=='+')
		{
			return solve(lll,mid-1,ss)+solve(mid+1,rrr,ss);
		}
		if(ss[mid]=='-')
		{
			return solve(lll,mid-1,ss)-solve(mid+1,rrr,ss);
		}
		if(ss[mid]=='*')
		{
			return solve(lll,mid-1,ss)*solve(mid+1,rrr,ss);
		}
		if(ss[mid]=='^')
		{
			ull s1=solve(lll,mid-1,ss);
			ull s2=solve(mid+1,rrr,ss);
			ull ans=1;
			while(s2--)ans*=s1;
			return ans;
		}
	}
}
int main()
{
	getline(cin,s[0]);//因为有空格，所有要getline 
	s[0]='('+s[0]+')';
	//括号问题 
	for(int i=1;i<s[0].size()-1;i++)
	{
		if(s[0][i]=='(')ll++;
		if(s[0][i]==')')rr++;
	}
	if(ll<rr)
	{
		while(rr>ll)
		{
			s[0]='('+s[0];
			rr--;
		}
	}
	if(rr<ll)
	{
		while(rr<ll)
		{
			s[0]=s[0]+')';
			ll--;
		}
	}
	cin>>n;
	for(int j=1;j<=n;j++)
	{
		char ch;
		cin>>ch;
		//吃括号 
		getline(cin,s[j]);
		if(ch!='\n')s[j]=ch+s[j];
		s[j]='('+s[j]+')';
		ll=rr=0;
		for(int i=1;i<s[j].size()-1;i++)
		{
			if(s[j][i]=='(')ll++;
			if(s[j][i]==')')rr++;
		}
		if(ll<rr)
		{
			while(rr>ll)
			{
				s[j]='('+s[j];
				rr--;
			}
		}
		if(rr<ll)
		{
			while(rr<ll)
			{
				s[j]=s[j]+')';
				ll--;
			}
		}
	}
	//枚举a的值 
	for(char ikun='0';ikun<='9';ikun++)
	{
		ull fl=123456789987654321;//fl表示基准 
		for(int k=0;k<=n;k++)
		{
			string sss=s[k];
			for(int i=0;i<sss.size();i++)
			{
				if(sss[i]=='a')
				{
					sss[i]=ikun;
				}
			}
			ull ls=solve(0,s[k].size()-1,sss);
			if(fl==123456789987654321)
			{
				fl=ls;
			}
			if(ls!=fl)
			{
				vis[k]=1;
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(!vis[i])cout<<(char)(i-1+'A');
	}
	return 0;
}
```
我调了两个小时才写出来，希望能给你带来帮助。这就是本题解的全部内容了，谢谢观看。

---

## 作者：Noah03 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P1054)

**此题解中的*计算方式*部分给出的逻辑并不完整，完整做法在*做法*部分！！！**

### 分析

---

首先，如果我们用数学的方式计算的话，可能过程会变得十分复杂 ~~（轻轻松松1000+行，超越猪国杀）~~ 甚至无法编写。那我们就想到了往原表达式和每个选项中带入一个值，如果计算出的值与原表达式的值相同，就说明两个表达式是等价的（当然，除了一些特殊值）。

既然这样的话，我们就要想如何求一个表达式的值呢？

首先，引入定义：

我们平常书写的表达式其中运算符在两数字之间，称为**中缀表达式**，如 `8*(2-2)+5^6-7`；而运算符写在操作数后面的表达式就叫**后缀表达式**，如 `2 4 8 ^ +`（中缀表达式为 `2+4^8`）。

如果你学过数学，可能一眼就能看出某个式子的值，但是这对于计算机来说不好处理，常见的方法是先将中缀表达式转后缀表达式，然后对后缀表达式进行求值。

### 计算方式

---

**注意题目中没有说表达式中的数一定是正数，所以要区分负号和减号。**

如果中缀表达式没有字母，对于中缀表达式转后缀表达式我们可以按如下方式进行：

1. 建立两个栈，分别存储运算数和运算符。
2. 建立两个变量：`flag` 和 `ans`，`flag` 为 false 代表正数，`ans` 记录答案。
3. 将中缀表达式后面加上一个符号，代表表达式结束。
4. 遍历字符串，按照接下来的情况处理（记当前字符索引为 $i$）：

- 当前字符为 '-'，若 $i$ 为 0 或者 前一个字符为 `(`，说明有负数，将 `flag` 设为 false。

- 否则，当前字符为数字字符，则将 `ans` 累加。

- 否则，当前字符不为数字字符但前一个字符为数字字符，说明这个数字已经结束了，判断符号，压入运算数栈，将 `ans` 和 `flag` 清空。

  **注意，接下来的条件与上述条件无关。**

- 若当前字符为 `)`，一直运算栈顶元素并将运算符栈一直弹出栈顶元素，直到栈为空或者找到了 `(`，循环结束后再弹出栈顶一次。

- 否则，若当前字符为 `+` 或 `*` 或 `^`或者**当前字符为 `-` 且表示减号**，进行操作：若运算符栈不为空，计算栈顶元素元素并弹出栈顶元素直到栈为空或者**当前栈顶元素的优先级小于当前字符（表达式第 $i$ 个字符）的优先级（不是小于等于是因为幂运算 `^` 是从右往左结合的）**。

- 否则，若当前字符为 `(`，直接入运算符栈。

5. 计算剩余表达式：一直运算表达式栈顶元素并弹出栈顶元素直到栈为空。

6. 返回运算数栈的栈顶元素。

代码：
```cpp
int convert(string s){
	bool flag=false;
	int ans=0;
	s+='@';
	for(int i=0;i<s.size();i++){
		if (s[i]=='-'&&(!i||s[i-1]=='(')) flag=true;
		else if (s[i]>='0'&&s[i]<='9') ans=((ans<<1)+(ans<<3))+(s[i]^'0');
		else if (s[i-1]>='0'&&s[i-1]<='9'){
			if (flag) ans*=-1;
			st.push(ans);
			flag=false;
			ans=0;
		}
		if (s[i]==')'){
			while(!op.empty()&&op.top()!='('){
				js(op.top());
				op.pop();
			}
			if (!op.empty()) op.pop();
		}
		else if (s[i]=='+'||(s[i]=='-'&&s[i-1]!='('&&i)||s[i]=='*'||s[i]=='^'){
			if (!op.empty()){
				while(!op.empty()&&yxj(op.top())>=yxj(s[i])){
					js(op.top());
					op.pop();
				}
			}
			op.push(s[i]);
		}
		else if (s[i]=='(') op.push(s[i]);
	}
	while(!op.empty()){
		js(op.top());
		op.pop();
	}
	return st.top();
}
```

`js` 函数用于计算表达式栈前两个数运算的结果，它的逻辑：

1. 若字符为 `(`，直接返回。
2. 取出栈顶的两个元素，根据字符计算结果，压入表达数栈。

代码：
```cpp
void js(char c){
	if (c=='(') return;
	int x=st.top();st.pop();
	int y=st.top();st.pop();
    //不要忘记写break;
	switch(c){
		case '+':st.push(y+x);break;
		case '-':st.push(y-x);break;
		case '*':st.push(y*x);break;
		case '^':st.push(pow(y,x));break;
	}
}
```

`yxj` 函数用于计算一个运算符的优先级，代码：
```cpp
int yxj(char c){
    //可以不写break;
	switch(c){
		case '+':case '-':return 1; 
		case '*':return 2;
		case '^':return 3;
		default:return -1; //保险起见
	}
}
```

但是，题目中和选项的表达式不一定全是数字，因为表达式中只可能出现一个变量 `a`，所以可以将 `a` 全部替换为一个数字，将一个特判就好了，有以下代码：
```cpp
int convert(string s){
	bool flag=false;
	int ans=0;
	s+='@';
	for(int i=0;i<s.size();i++){
		if (s[i]=='-'&&(!i||s[i-1]=='(')) flag=true;
		else if (s[i]=='a'){
			ans=114514; //将a替换为一个数字
			if (flag) ans*=-1;
			st.push(ans);
			flag=false;
			ans=0;
		}
		else if (s[i]>='0'&&s[i]<='9') ans=((ans<<1)+(ans<<3))+(s[i]^'0');
		else if (s[i-1]>='0'&&s[i-1]<='9'){
			if (flag) ans*=-1;
			st.push(ans);
			flag=false;
			ans=0;
		}
		else;
		if (s[i]==')'){
			while(!op.empty()&&op.top()!='('){
				js(op.top());
				op.pop();
			}
			if (!op.empty()) op.pop();
		}
		else if (s[i]=='+'||(s[i]=='-'&&s[i-1]!='('&&i)||s[i]=='*'||s[i]=='^'){
			if (!op.empty()){
				while(!op.empty()&&yxj(op.top())>=yxj(s[i])){
					js(op.top());
					op.pop();
				}
			}
			op.push(s[i]);
		}
		else if (s[i]=='(') op.push(s[i]);
		else;
	}
	while(!op.empty()){
		js(op.top());
		op.pop();
	}
	return st.top();
}
```

### 做法

---

*计算方式*部分已经将大部分逻辑写出来了，但是有几个需要注意的点：


1. 读入部分用 getline 会有一个 '\r' 字符，保险起见用 getchar()，输入 $n$ 也用快读（可参考我的代码）。
2. 表达式不删多余右括号见祖宗。
3. 十年 OI 一场空，不开 long long 见祖宗。
4. 十年 OI 一场空，大数不取模见祖宗。
5. 十年 OI 一场空，负数取模不先加模数见祖宗。
6. 十年 OI 一场空，多测不清空见祖宗。
7. 十年 OI 一场空，模数取小见祖宗。
8. 十年 OI 一场空，$a$ 的值取小见祖宗。
9. 十年 OI 一场空，不判栈空见祖宗。

### 代码

---

**抄袭一时爽，棕名两行泪**

下面给出代码（不加注释）：
```cpp
//The code is from Noah03,Do not copy!!!
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define Noah03MainFunction main
#define IamA return 
#define BigJuruo 0
const int mod=1e9+7; 
stack<int> st;
stack<char> op;
inline int read(){
	register int ans=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if (c=='-') f=-1;
		c=getchar(); 
	}
	while(c>='0'&&c<='9'){
		ans=((ans<<1)+(ans<<3))+(c^'0');
		c=getchar();
	}
	return f*ans;
}
string readstr(bool flag){
	string s="";
	char c=getchar();
	if (flag) while(c=='\r'||c=='\n') c=getchar();
	while(c!='\r'&&c!='\n'){
		if (c!=' ') s+=c;
		c=getchar();
	}
	return s;
}
string InitString(string s){
	int l=0,r=0;
	for(int i=0;i<s.size();i++){
		if (s[i]=='(') l++;
		else if (s[i]==')') r++;
		if (l<r){
			s.erase(i,1);
			r--;
		}
	}
	return s;
}
int yxj(char c){
	switch(c){
		case '+':case '-':return 1; 
		case '*':return 2;
		case '^':return 3;
		default:return -1;
	}
}
int Pow(int a,int b){
	a%=mod;
	int ans=1;
	while(b--) ans=ans%mod*a%mod;
	return ans%mod;
}
void js(char c){
	if (c=='(') return;
	int x=st.top();st.pop();
	int y=st.top();st.pop();
	switch(c){
		case '+':st.push((y+x+mod)%mod);break;
		case '-':st.push((y-x+mod)%mod);break;
		case '*':st.push((y%mod*x%mod+mod)%mod);break;
		case '^':st.push(Pow(y,x));break;
	}
}
int convert(string s){
	while(!st.empty()) st.pop();
	while(!op.empty()) op.pop();
	bool flag=false;
	int ans=0;
	s=InitString(s)+'@';
	for(int i=0;i<s.size();i++){
		if (s[i]=='-'&&(!i||s[i-1]=='(')) flag=true;
		else if (s[i]=='a'){
			ans=114514;
			if (flag) ans*=-1;
			st.push(ans);
			flag=false;
			ans=0;
		}
		else if (s[i]>='0'&&s[i]<='9') ans=((ans<<1)+(ans<<3))+(s[i]^'0');
		else if (s[i-1]>='0'&&s[i-1]<='9'){
			if (flag) ans*=-1;
			st.push(ans);
			flag=false;
			ans=0;
		}
		else;
		if (s[i]==')'){
			while(!op.empty()&&op.top()!='('){
				js(op.top());
				op.pop();
			}
			if (!op.empty()) op.pop();
		}
		else if (s[i]=='+'||(s[i]=='-'&&s[i-1]!='('&&i)||s[i]=='*'||s[i]=='^'){
			if (!op.empty()){
				while(!op.empty()&&yxj(op.top())>=yxj(s[i])){
					js(op.top());
					op.pop();
				}
			}
			op.push(s[i]);
		}
		else if (s[i]=='(') op.push(s[i]);
		else;
	}
	while(!op.empty()){
		js(op.top());
		op.pop();
	}
	return st.top()%mod;
}
signed Noah03MainFunction(){
	string s=readstr(false);
	int n=read();
	int ex=convert(s);
	for(int i=1;i<=n;i++){
		string nowstr=readstr(true);
		if (convert(nowstr)==ex) putchar('A'+i-1);
	}
	IamA BigJuruo;
}
```

### 结尾

---

不知道为啥代码 Luogu IDE 和 Luogu Online Judge 能过，本地过不了。

如题解有误，请各位 dalao 指出！！！

### The End.

---

## 作者：Peiyuan (赞：1)

首先感谢 @shihaocheng110909

与大部分的写法不同，这里采用分治的写法（比栈要好写）。每次分治查找区间内优先级最低的符号，然后分别递归计算这个符号两边的算式即可。由于数据较小，可以直接枚举 $a$ 的值，然后依次对于每个算式进行判断结果是否相同。

需要注意的是，由于该题是远古题目，所以给定的字符串里可能有不可见字符（比如 `\r`），还有括号可能不匹配，我们需要对这种情况对于特殊处理。最后，答案的存储可以用 `unsigned long long` 的自然溢出，用 `hash` 的原理，比较最终结果即可。

由于 @shihaocheng110909 的代码马蜂优良，所以使用他的代码。他线下同意了我使用他的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
string s[30];
bool vis[30];
ull ll,rr;
int n;
ull yx(char ch){
	if(ch=='+'||ch=='-')return 1;
	if(ch=='*')return 2;
	if(ch=='^')return 3;
}
ull num(int l,int r,string ss){
	ull ans=0;
	for(int i=l;i<=r;i++)ans=ans*10+ss[i]-'0';
	return ans;
}
ull solve(int l,int r,string ss){
	ull ps=0,mid=0;
	for(int i=l;i<=r;i++){
		if(ss[i]=='('){ps++;continue;}
		if(ss[i]==')'){ps--;continue;}
		if(!ps&&(ss[i]=='+'||ss[i]=='*'||ss[i]=='-'||ss[i]=='^')){
			if(yx(ss[mid])>=yx(ss[i]))mid=i;
		}
	}
	ull L=l,R=r;
	while(ss[L]!='+'&&ss[L]!='*'&&ss[L]!='-'&&ss[L]!='^'&&ss[L]!='('&&ss[L]!=')'&&(ss[L]<'0'||ss[L]>'9'))L++;
	while(ss[R]!='+'&&ss[R]!='*'&&ss[R]!='-'&&ss[R]!='^'&&ss[R]!='('&&ss[R]!=')'&&(ss[R]<'0'||ss[R]>'9'))R--;
	if(mid==0){
		if(ss[L]=='('&&ss[R]==')')return solve(L+1,R-1,ss);
		return num(L,R,ss);
	}else{
		if(ss[mid]=='+')return solve(L,mid-1,ss)+solve(mid+1,R,ss);
		if(ss[mid]=='-')return solve(L,mid-1,ss)-solve(mid+1,R,ss);
		if(ss[mid]=='*')return solve(L,mid-1,ss)*solve(mid+1,R,ss);
		if(ss[mid]=='^'){
			ull s1=solve(L,mid-1,ss);
			ull s2=solve(mid+1,R,ss);
			ull ans=1;
			while(s2--)ans*=s1;
			return ans;
		}
	}
}
int main(){
	getline(cin,s[0]);
	s[0]='('+s[0]+')';
	for(int i=1;i<s[0].size()-1;i++){
		if(s[0][i]=='(')ll++;
		if(s[0][i]==')')rr++;
	}
	if(ll<rr){
		while(rr>ll){
			s[0]='('+s[0];rr--;
		}
	}
	if(rr<ll){
		while(rr<ll){
			s[0]=s[0]+')';ll--;
		}
	}
	cin>>n;
	for(int j=1;j<=n;j++){
		char ch;cin>>ch;
		getline(cin,s[j]);
		if(ch!='\n')s[j]=ch+s[j];
		s[j]='('+s[j]+')';
		ll=rr=0;
		for(int i=1;i<s[j].size()-1;i++){
			if(s[j][i]=='(')ll++;
			if(s[j][i]==')')rr++;
		}
		if(ll<rr){
			while(rr>ll)s[j]='('+s[j],rr--;
		}
		if(rr<ll){
			while(rr<ll)s[j]=s[j]+')',ll--;
		}
	}
	for(char xx='0';xx<='9';xx++){
		ull fl=123456789987654321;
		for(int k=0;k<=n;k++){
			string t=s[k];
			for(int i=0;i<t.size();i++){
				if(t[i]=='a')t[i]=xx;
			}
			ull ls=solve(0,s[k].size()-1,t);
			if(fl==123456789987654321)fl=ls;
			if(ls!=fl)vis[k]=1;
		}
	}
	for(int i=1;i<=n;i++){
		if(!vis[i])cout<<char(i-1+'A');
	}
	return 0;
}
```

---

## 作者：Ag2WO4 (赞：1)

第一眼：**这题对有 ```eval()``` 函数的 Python 来说岂不是简简单单？！！**

真的是这样的吗？需要注意两点：
1. 多余空格问题（这个好解决，两侧补齐即可）；
2. 乘幂运算符次序问题（要求左结合但是 Python 里是右结合）。

我的想法是构造函数来重载运算符，将乘幂的每一项从左到右作为函数的任意参数。在同一层的加减乘处分割即可得到所有的连续乘幂项。同一层从一开始就引入构造函数，幂标志连续乘幂的每一项，加减乘标志这个连续乘幂的结束和下一个连续乘幂的开始。

这样就可以通过直接求值来判断表达式是否相等（当变量 $a$ 足够让人意想不到时，不同表达式得到相同结果的概率会很小）。变量 $a$ 可以随便取（最好取整数防止被卡精度），只要不踩到出题人设置的坑里就行。

#### 看来确实简简单单。于是得到了 AC 代码：
```python
def r(*i):
    x=i[0]
    for j in i[1:]:x**=j
    return x
a=193;b=input();d='';b=eval('r('+('('*(b.count(')')-b.count('('))+b+')'*(b.count('(')-b.count(')'))).replace('^',',').replace('(','(r(').replace(')','))').replace('+',')+r(').replace('-',')-r(').replace('*',')*r(')+')')
for i in range(int(input())):
    c=input()
    if eval('r('+('('*(c.count(')')-c.count('('))+c+')'*(c.count('(')-c.count(')'))).replace('^',',').replace('(','(r(').replace(')','))').replace('+',')+r(').replace('-',')-r(').replace('*',')*r(')+')')==b:d+=chr(i+65)
print(d)
```

---

## 作者：skx_515 (赞：1)

## 题意：
给出若干**仅含 $a$ 的多项式**，判断是否等价。
## 思路：
最开始都是在想如何进行进行化简，然后看化简过后的多项式是否等价。

但是本题我们并不是很必要使用此种方法，因为较为难写，且易出错。经过一定思考，我们发现可以采用计算其多项式的值，再使用比较其值，来较粗略地比较这两个多项式是否等价。  

但是，这种方法并不稳妥，因此，我们需要考虑一个小优化，即计算多组值，进行比较。理论上来说，只要我们计算的值足够多，就可以完美比较出来。

还有一个小细节，由于计算出的值过大，我们可以使用一个模数，比较取模之后的值。
## 实现：
1. 计算表达式的值：封装为函数，使用中缀表达式转后缀，再计算其后缀表达式的值。  
2. 将多组 $a$ 的值代入，再进行比较。  
3. **注意：建议手写栈，STL 容易炸。**
## 代码：
```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f3f3f3f3f
#define ll long long
#define cs1 131
#define cs2 13331
#define mod1 100000007
using namespace std;
char a[10100];
ll b[10100],k[10100],btop,ktop,atop,att;
char bds[10100],tttt[10010];
ll n,str1,str2,str3,now1,now2,now3;
void read(char x[],ll &len){
	//鉴于很多的字符串在输入时问题较大大
	//所以我们需要一个更加稳定的字符串输入
	//我采取了getchar()
	//getchar(a):
	//读入一个char类型的字符a
	//len:长度 
	char d;
	d=getchar();
	while(d=='\r'||d=='\n') d=getchar();//换行不要 
	while(d!='\r'&&d!='\n'){
		if(d!=' ') x[len++]=d;//空格不要 
		d=getchar();
	}
}
ll pd(char aa){
	if(aa=='+'||aa=='-'||aa=='*'||aa=='('||aa==')'||aa=='^') return 1;
	if(aa>='A'&&aa<='Z') return 2;
	if(aa=='a') return 3;
	return 0;
}
ll yxj(char aa,ll bb){//优先级
	if(aa=='+'||aa=='-') return 1;
	if(aa=='*') return 2;
	if(aa=='^') return 3;
	if(aa=='('&&bb==1) return 0;
	if(aa=='('&&bb==0) return 4;
	return -1;
}
ll qpow(ll x,ll y,ll mod){//快速幂
	ll ans=1;
	while(y){
		if(y&1) ans=ans*x%mod;
		x=x*x%mod,y>>=1;
	}
	return ans;
}
ll js(char at[],ll ttt,ll mod){//封装的计算表达式值函数
	ll ss=0,cs=0;
	atop=btop=ktop=0;
	for(ll i=0;i<att;i++){
		if(at[i]=='(') k[++ktop]=1;
		else if(at[i]==')'&&ktop==0) return INF;
		else if(at[i]==')') ktop--;
	}
	if(ktop) return INF;
	for(ll i=0;i<att;i++){
		if(at[i]==' ') continue;
		if(pd(at[i])==3){
			bds[ss]=at[i],ss++,cs++;
		}
		else if(pd(at[i])==0&&cs==0){
			bds[ss]=at[i],ss++,cs++;
		}
		else if(pd(at[i])==0&&cs!=0){
			bds[ss]=char(at[i]+17),ss++,cs++;
		}
		else{
			if(!atop) a[++atop]=at[i];
			else{
				if(at[i]==')'){
					while(atop&&a[atop]!='('){
						bds[ss]=a[atop],ss++,atop--;
					}
					atop--;
					continue;
				}
				while(atop&&yxj(at[i],0)<=yxj(a[atop],1)){
					if(a[atop]!='('&&a[atop]!=')'){
						bds[ss]=a[atop],ss++;
					}
					atop--;
				}
				a[++atop]=at[i];
			}
			cs=0;
		}
	}
	while(atop) bds[ss]=a[atop],ss++,atop--;//从上一直到此处为中缀表达式转后缀
	for(ll i=0;i<ss;i++){
		if(pd(bds[i])==3) b[++btop]=ttt;
		else if(pd(bds[i])==0) b[++btop]=bds[i]-'0';
		else if(pd(bds[i])==2&&btop) b[btop]=(b[btop]*10+(bds[i]-'A'))%mod;
		else if(btop){
			ll aa=b[btop-1],bb=b[btop];
			btop-=2;
			if(bds[i]=='+') b[++btop]=(aa+bb)%mod;
			else if(bds[i]=='-') b[++btop]=((aa-bb)%mod+mod)%mod;
			else if(bds[i]=='*') b[++btop]=aa*bb%mod;
			else if(bds[i]=='^') b[++btop]=qpow(aa,bb,mod);
		}
	}//接下来这里就是计算表达式的值了
	return b[btop];
}
int main(){
	read(tttt,att);//读入字符串 
	str1=js(tttt,cs1,mod1),str2=js(tttt,cs2,mod1);
	cin>>n;
	for(ll i=0;i<n;i++){
		att=0;
		read(tttt,att);
		now1=js(tttt,cs1,mod1),now2=js(tttt,cs2,mod1);
		if(str1==now1&&str2==now2) cout<<char(i+'A');
	}
	return 0;
}
//吐槽：
//这个大模拟也是真的难写，100多行......
```

## 另：
不了解中缀表达式转后缀表达式以及计算后缀表达式的看[这里](https://blog.csdn.net/Amentos/article/details/127182926)。

---

## 作者：xuanxuan0604 (赞：0)

## 题目链接

[P1054 [NOIP2005 提高组] 等价表达式](https://www.luogu.com.cn/problem/P1054)

---

## 前言

此题并不难，但**坑点很多**。~~（那我还做了两个月）~~

## 题意
从 $n$ 个可能含变量 $a$ 的表达式中选择与目标表达式**一致**的表达式**编号**（A-Z）。

---

## 思路

题目中的表达式往往很**复杂**，一个个做变换的难度很高 ~~（不会）~~,那怎么办？题目中的 $a$ 不好处理，那我们可以把它**变成具体数字**来解决啊。这里我代的是 $17$（不是只能用这个）。把 $a$ 变成具体数字后，我们可以干什么？**计算**！把表达式算出来，如果和目标结果**一致**就认为它们**相同**。剩下的就是如何计算了。

这下问题就变成两步了，一是把表达式**转为后缀表达式**，二是**计算后缀表达式**。

完成上面两步后，就该计算表达式的值了，如果是直接计算经上面两步处理后的表达式还有点困难（**有括号**并且运算符在数字中间），因此我们要把表达式转成**前缀表达式**（形如 `+ 2 3` 的形式）或者**后缀表达式**（形如 `2 3 +` 的形式），再运算。这里我用的是后缀表达式。

~~提一嘴~~，运算符都有**优先级**，其中：
- `+`和`-`的运算级的运算级为 $1$。
- `*`的运算级的运算级为 $2$。
- `^`的运算级的运算级为 $3$。
- 其他运算级的运算级为 $-1$。

---

### 转换后缀表达式

**转换**方式是这样的：
1. **初始化**运算符栈和结果表达式。
2. **从左往右**遍历原表达式，如果是 `(` 则入栈，如果是 _数字字符_ 则**直接添加**到结果表达式中，如果是 运算符（`+`、`-`、`*` 和 `^`） 则将栈顶优先级**不低于**此运算符的添加到结果表达式中并入栈，如果是 `)` 则从栈顶开始出栈，直到栈为空 _（当然，上面已经匹配了左右括号，这是不可能发生的）_ 或栈顶为 `(` 时**停止**，将上面所有出栈字符全加入结果表达式中，弹出栈顶 `(`。

#### 实现：

```cpp
string tn(string str,string isd){
	//替换表达式中的'a'
	string tr="";
	for(int i=0;i<str.length();i++){
		if(str[i]=='a'){
			tr+=isd;
		}
		else{
			tr+=str[i];
		}
	}
	str=tr;
//	cout<<str<<endl;
	string res=""; //后缀表达式
	stack<char> st; //运算符栈
	int i=0; //下标
	while(i<str.length()){
		if(isdigit(str[i])){ //数字
			while(isdigit(str[i])&&i<str.length()){
                		res+=str[i++];
           		 }
            		res+=" ";
            		continue;
		}
		else if(str[i]=='('){ //左括号
			st.push(str[i]);
		}
		else if(str[i]=='^'||str[i]=='+'||str[i]=='-'||str[i]=='*'){ //运算符
			while(!st.empty()&&priority(st.top())>=priority(str[i])){ //弹出
				res=res+st.top()+" ";
				st.pop();
			}
			st.push(str[i]);
		}
		else if(str[i]==')'){ //右括号
			while(!st.empty()&&st.top()!='('){ //弹出
				res=res+st.top()+" ";
				st.pop();
			}
			if(!st.empty()&&st.top()=='('){
				st.pop();
			}
		}
		i++;
	}
	while(!st.empty()){ //弹出剩余
		res=res+st.top()+" ";
		st.pop();
	}
	return res;
}

//去除多余左右括号
string pm(string st){
	ll l=0,r=0;
	string res="";
	for(int i=0;i<st.length();i++){
		if(st[i]=='('){
			l++;
		}
		else if(st[i]==')'){
			r++;
		}
	}
	if(l==r){ //括号完全匹配的上
		res=st;
	}
	else if(l<r){ //有多余右括号
		l=r=0;
		for(int i=0;i<st.length();i++){
			res.push_back(st[i]);
			if(st[i]=='('){
				l++;
			}
			else if(st[i]==')'){
				r++;
			}
			if(l<r){
				r--;
				if(res.size()){
					res.pop_back();
				}
			}
		}
	}
	else if(l>r){ //有多余左括号
		stack<int> lp;
		for(int i=0;i<st.length();i++){
			if(st[i]=='('){
				lp.push(i);
			}
			else if(st[i]==')'){
				lp.pop();
			}
		}
		int des[55];
		memset(des,0,sizeof(des));
		while(!lp.empty()){
			des[lp.top()]=1;
			lp.pop();
		}
		for(int i=0;i<st.length();i++){
			if(!des[i]){
				res+=st[i];
			}
		}
	}
	return res;
}
```

---

### 计算后缀表达式

转换完了，开始**计算**。这比刚才还要简单。我们这样做：
1. **初始化**数字栈。
2. **从左往右**遍历后缀表达式，如果是 _数字_ 则入栈，如果是运算符（`+`、`-`、`*` 和 `^`） 则出栈两个数字运算后将结果入栈。
3. 遍历完后，栈顶就是运算结果了。

#### 实现：

```cpp
int calc(string s,string ise){
	s=tn(s,ise); //转后缀
	s=rs(s); //获取按空格分割后的字符串
	stack<ll> val; //数字栈
	val.push(0); //特判
	ll a,b,sum;
	a=b=sum=0;
	string tok="";
	for(int i=0;i<vec.size();i++){
		tok=vec[i];
//		print(val);
		if(!val.empty()&&(tok=="^"||tok=="+"||tok=="-"||tok=="*")){ //是运算符
			sum=0;
			b=val.top();
			val.pop();
			a=val.top();
			val.pop();
			//计算
			if(tok=="+"){
				sum=a+b;
			}
			else if(tok=="-"){
				sum=a-b;
			}
			else if(tok=="*"){
				sum=a*b;
			}
			else if(tok=="^"){
				sum=pow_(a,b);
			}
			sum%=MOD;
			val.push(sum);
		}
		else if(tok==""){ //特判
			break;
		}
		else{ //数字
			val.push(stoll(tok));
		}
//		system("pause");
	}
//	system("pause");
	return val.top();
}
```

---

## 坑点

不能使用 `cin`，因为 `cin` 遇到空格或换行就结束，但表达式中间**可能存在多余空格**，用 `cin` 读入**不完整**，也不能 `cin` 和 `getline` 混合使用，因为 `cin` **会**在输入缓冲区留下换行符和空格，**不会带走**，这样就会出现问题。我用的不是字符数组，这里用的是 `getline`。

计算过程中**可能**会越界，这里要模一个数，这里我模的是 $10^9 + 7$。~~（某质数）~~

题目中的括号**可能不匹配**，因此，我们要**去除多余左右括号**。

我的思路大体是这样的：先看左右括号**哪个多**，右括号多就**再次遍历表达式，重新计数**，当右括号数量**超过**左括号时，**去掉**当前位置的右括号并把右括号数量减一。如果是左括号多了，就先**按常规括号匹配的方式**选出**多余的左括号**，再去掉那些左括号。

### 实现：

```cpp
string pm(string st){
	ll l=0,r=0;
	string res="";
	for(int i=0;i<st.length();i++){
		if(st[i]=='('){
			l++;
		}
		else if(st[i]==')'){
			r++;
		}
	}
	if(l==r){ //括号完全匹配的上
		res=st;
	}
	else if(l<r){ //有多余右括号
		l=r=0;
		for(int i=0;i<st.length();i++){
			res.push_back(st[i]);
			if(st[i]=='('){
				l++;
			}
			else if(st[i]==')'){
				r++;
			}
			if(l<r){
				r--;
				if(res.size()){
					res.pop_back();
				}
			}
		}
	}
	else if(l>r){ //有多余左括号
		stack<int> lp;
		for(int i=0;i<st.length();i++){
			if(st[i]=='('){
				lp.push(i);
			}
			else if(st[i]==')'){
				lp.pop();
			}
		}
		int des[55];
		memset(des,0,sizeof(des));
		while(!lp.empty()){
			des[lp.top()]=1;
			lp.pop();
		}
		for(int i=0;i<st.length();i++){
			if(!des[i]){
				res+=st[i];
			}
		}
	}
	return res;
}
```

题目中**可能**有多余空格，要删去。

去空格，这个简单，去空格不就是把除了空格以外的所有字符全合并嘛，我们可以采用**字符串分割**的方式，通过`stringstream`,可以将字符串**作为输入输出流来处理**，用输入输出的 `getline` 来处理，把**分隔符**换成空格就行了。

### 实现：

```cpp
string rs(string& str){
	vec.clear();
	stringstream ss(str);
	string tok;
	string res;
	while(getline(ss,tok,' ')){
	    res+=tok;
	    vec.push_back(tok); //后门，调试用
	}
	return res;
}
```

---

## 代码

建议只看思路完成，代码如下 ~~（这个人很菜，写了近250行）~~

```cpp
#include<iostream>
#include<sstream>
#include<cstring>
#include<vector>
#include<string>
#include<stack>
#define MOD int(1e9)+7
#define ll long long
using namespace std;

ll n,m,t; //n:选项数量，m:目标结果，t:当前结果
char ch=0;
string str,tem; //输入结果
vector<string> vec;

//快速幂算法
ll pow_(ll a,ll b){
	ll res=1;
	a%=MOD;
	while(b){
		if(b&1){
			res*=a;
			res%=MOD;
		}
		a*=a;
		a%=MOD;
		b>>=1;
	}
	return res;
}

//去除空格
string rs(string& str){
	vec.clear();
	stringstream ss(str);
	string tok;
	string res;
	while(getline(ss,tok,' ')){
	    res+=tok;
	    vec.push_back(tok); //后门
	}
	return res;
}

//输出栈，调试用
void print(stack<ll> s){
	while(!s.empty()){
		cout<<s.top()<<" ";
		s.pop();
	}
	cout<<endl;
}

//运算符优先级
int priority(char ch){
	if(ch=='+'||ch=='-'){
		return 1;
	}
	if(ch=='*'){
		return 2;
	}
	if(ch=='^'){
		return 3;
	}
	return -1;
}

//中缀表达式转后缀
string tn(string str,string isd){
	//替换表达式中的'a'
	string tr="";
	for(int i=0;i<str.length();i++){
		if(str[i]=='a'){
			tr+=isd;
		}
		else{
			tr+=str[i];
		}
	}
	str=tr;
//	cout<<str<<endl;
	string res=""; //后缀表达式
	stack<char> st; //运算符栈
	int i=0; //下标
	while(i<str.length()){
		if(isdigit(str[i])){ //数字
			while(isdigit(str[i])&&i<str.length()){
                		res+=str[i++];
           		 }
            		res+=" ";
            		continue;
		}
		else if(str[i]=='('){ //左括号
			st.push(str[i]);
		}
		else if(str[i]=='^'||str[i]=='+'||str[i]=='-'||str[i]=='*'){ //运算符
			while(!st.empty()&&priority(st.top())>=priority(str[i])){ //弹出
				res=res+st.top()+" ";
				st.pop();
			}
			st.push(str[i]);
		}
		else if(str[i]==')'){ //右括号
			while(!st.empty()&&st.top()!='('){ //弹出
				res=res+st.top()+" ";
				st.pop();
			}
			if(!st.empty()&&st.top()=='('){
				st.pop();
			}
		}
		i++;
	}
	while(!st.empty()){ //弹出剩余
		res=res+st.top()+" ";
		st.pop();
	}
	return res;
}

//去除多余左右括号
string pm(string st){
	ll l=0,r=0;
	string res="";
	for(int i=0;i<st.length();i++){
		if(st[i]=='('){
			l++;
		}
		else if(st[i]==')'){
			r++;
		}
	}
	if(l==r){ //括号完全匹配的上
		res=st;
	}
	else if(l<r){ //有多余右括号
		l=r=0;
		for(int i=0;i<st.length();i++){
			res.push_back(st[i]);
			if(st[i]=='('){
				l++;
			}
			else if(st[i]==')'){
				r++;
			}
			if(l<r){
				r--;
				if(res.size()){
					res.pop_back();
				}
			}
		}
	}
	else if(l>r){ //有多余左括号
		stack<int> lp;
		for(int i=0;i<st.length();i++){
			if(st[i]=='('){
				lp.push(i);
			}
			else if(st[i]==')'){
				lp.pop();
			}
		}
		int des[55];
		memset(des,0,sizeof(des));
		while(!lp.empty()){
			des[lp.top()]=1;
			lp.pop();
		}
		for(int i=0;i<st.length();i++){
			if(!des[i]){
				res+=st[i];
			}
		}
	}
	return res;
}

//计算后缀表达式
int calc(string s,string ise){
	s=tn(s,ise); //转后缀
	s=rs(s); //获取按空格分割后的字符串
	stack<ll> val; //数字栈
	val.push(0); //特判
	ll a,b,sum;
	a=b=sum=0;
	string tok="";
	for(int i=0;i<vec.size();i++){
		tok=vec[i];
//		print(val);
		if(!val.empty()&&(tok=="^"||tok=="+"||tok=="-"||tok=="*")){ //是运算符
			sum=0;
			b=val.top();
			val.pop();
			a=val.top();
			val.pop();
			//计算
			if(tok=="+"){
				sum=a+b;
			}
			else if(tok=="-"){
				sum=a-b;
			}
			else if(tok=="*"){
				sum=a*b;
			}
			else if(tok=="^"){
				sum=pow_(a,b);
			}
			sum%=MOD;
			val.push(sum);
		}
		else if(tok==""){ //特判
			break;
		}
		else{ //数字
			val.push(stoll(tok));
		}
//		system("pause");
	}
//	system("pause");
	return val.top();
}

int main(){
	getline(cin,str);
	str=rs(str);
	str=pm(str);
	m=calc(str,"17"); //计算目标表达式
	getline(cin,str);
	n=stoll(str); //写cin没分
	for(int i=0;i<n;i++){
		str="";
		getline(cin,str);
		str=rs(str);
		str=pm(str);
		t=calc(str,"17"); //计算当前表达式
//		cout<<t<<endl;
		if(t==m){
			tem+='A'+i; //添加到结果字符串中
		}
	}
	cout<<tem<<endl;
	return 0;
}
```
其中多个 `system("pause")` 是调试用，可以略去。

---

[AC记录](https://www.luogu.com.cn/record/197982206)

---

## 作者：algo_h (赞：0)

基于多项式表示和递归下降表达式解析，判断表达式是否相等。多项式每项前的系数可能溢出 `long`（在评测机上为 64 bit 带符号整数），但可以在不对大质数取模的前提下通过本题。使用 `int` 表示多项式系数则不能通过最后一个测试点。严格的做法可以使用高精度整数。

详细解释见代码实现。

```c++
#include <iostream>
#include <vector>

using namespace std;

// 几种特殊的分词类型
#define TOK_END (0x000)
#define TOK_INT (0x101)
#define TOK_VAR (0x102)

struct Token {
  int type;
  int value;  // type 为 TOK_INT 时存值
};

// 对表达式进行分词
vector<Token> tokenize(const string &expr)
{
  vector<Token> tokens;
  size_t pos = 0;
  while(pos != expr.size()) {
    while(pos != expr.size() && isspace(expr[pos])) ++pos;  // 跳过空白
    if(pos == expr.size()) break;
    if(isdigit(expr[pos])) {  // TOK_INT
      size_t beg = pos;
      while(pos != expr.size() && isdigit(expr[pos])) ++pos;
      tokens.push_back({ TOK_INT, stoi(expr.substr(beg, pos - beg)) });
    } else if(expr[pos] == 'a') {  // TOK_VAR
      tokens.push_back({ TOK_VAR, 0 });
      ++pos;
    } else if("+-*^()"s.find(expr[pos]) != string::npos) {  // 标点符号
      tokens.push_back({ expr[pos], 0 });
      ++pos;
    } else {
      throw runtime_error("unexpected character: "s + expr[pos]);
    }
  }
  tokens.push_back({ TOK_END, 0 });  // 哨兵
  return tokens;
}

// 我们根据本题中（一元）多项式运算的封闭性，选取多项式为唯一的操作数
struct Polynomial {
  vector<long> c;

  Polynomial &to(int power);  // 乘方
  Polynomial &mul(const Polynomial &);
  Polynomial &add(const Polynomial &);
  Polynomial &sub(const Polynomial &);

  Polynomial &regularize();  // 去除高位 0，方便比较

  bool eq(const Polynomial &) const;  // 判等
};

// 用快速幂计算多项式的乘方
Polynomial &Polynomial::to(int power)
{
  Polynomial p = { { 1 } }, q = *this;
  while(power) {
    if(power & 1) p.mul(q);
    q.mul(q);
    power >>= 1;
  }
  return *this = p.regularize();
}

// 多项式乘法，对应卷积
Polynomial &Polynomial::mul(const Polynomial &q)
{
  if(c.empty() || q.c.empty()) return *this = {};
  Polynomial p;
  p.c.resize(c.size() + q.c.size());
  for(size_t i = 0; i < c.size(); ++i) {
    for(size_t j = 0; j < q.c.size(); ++j) p.c[i + j] += c[i] * q.c[j];
  }
  return *this = p.regularize();
}

// 多项式加法，低位对齐后每项前系数相加
Polynomial &Polynomial::add(const Polynomial &q)
{
  if(c.size() < q.c.size()) c.resize(q.c.size());
  for(size_t i = 0; i < q.c.size(); ++i) c[i] += q.c[i];
  return this->regularize();
}

// 多项式减法，类似加法
Polynomial &Polynomial::sub(const Polynomial &q)
{
  if(c.size() < q.c.size()) c.resize(q.c.size());
  for(size_t i = 0; i < q.c.size(); ++i) c[i] -= q.c[i];
  return this->regularize();
}

// 通过去除前导 0 实现表示唯一化
Polynomial &Polynomial::regularize()
{
  while(!c.empty() && c.back() == 0) c.pop_back();
  return *this;
}

// 递归下降解析表达式，优先级递增，左结合
Polynomial expr(Token *&token);
Polynomial term(Token *&token);
Polynomial factor(Token *&token);
Polynomial base(Token *&token);

// expr -> term { ('+' | '-') term }
Polynomial expr(Token *&token)
{
  Polynomial poly = term(token);
  while(token->type == '+' || token->type == '-') {
    int type = token->type;
    ++token;
    Polynomial poly2 = term(token);
    type == '+' ? poly.add(poly2) : poly.sub(poly2);
  }
  return poly;
}

// term -> factor { '*' factor }
Polynomial term(Token *&token)
{
  Polynomial poly = factor(token);
  while(token->type == '*') {
    ++token;
    Polynomial poly2 = factor(token);
    poly.mul(poly2);
  }
  return poly;
}

// factor -> base { '^' base }
Polynomial factor(Token *&token)
{
  Polynomial poly = base(token);
  while(token->type == '^') {
    ++token;
    Polynomial power = base(token);
    if(power.c.size() != 1) throw runtime_error("unexpected power order: " + to_string(power.c.size()));
    poly.to(power.c[0]);
  }
  return poly;
}

// base -> INT | VAR | '(' expr ')'
Polynomial base(Token *&token)
{
  if(token->type == TOK_INT) {
    int value = token->value;
    ++token;
    return { { value } };
  }

  if(token->type == TOK_VAR) {
    ++token;
    return { { 0, 1 } };
  }

  if(token->type == '(') {
    ++token;
    Polynomial poly = expr(token);
    if(token->type != ')') throw runtime_error("unmatched parenthesis");
    ++token;
    return poly;
  }

  throw runtime_error("unexpected token type: " + to_string(token->type));
}

// 在 regular 表示下，多项式相等当且仅当系数向量相等
bool Polynomial::eq(const Polynomial &q) const { return c == q.c; }

// 读入一行输入，解析为多项式表示
Polynomial getexpr()
{
  string line;
  getline(cin, line);
  vector<Token> tokens = tokenize(line);
  //for(const Token &token : tokens) {
  //  cout << "type=";
  //  if(token.type < 0x100) {
  //    cout << "'" << char(token.type) << "'";
  //  } else {
  //    cout << token.type;
  //  }
  //  cout << " value=" << token.value << endl;
  //}
  Token *p = tokens.data();
  Polynomial poly = expr(p);
  if(p->type != TOK_END) throw runtime_error("trailing token of type: " + to_string(p->type));
  //for(int c : poly.c) cout << " " << c;
  //cout << endl;
  return poly;
}

int main()
{
  Polynomial poly = getexpr();
  int n;
  cin >> n;
  string s;
  getline(cin, s);  // 去除 n 后的换行
  for(int i = 0; i < n; ++i) {
    try {
      Polynomial poly2 = getexpr();
      if(poly2.eq(poly)) cout.put('A' + i);
    } catch(runtime_error &) {
      // Just skip it.
    }
  }
  cout << endl;
  return 0;
}
```

---


# 数7

## 题目描述

$1337$ 个人排成一个圈，从 $1$ 号人开始报数，初始方向是 $1,2,3\dots$。如果某个人报的数是 $7$ 的倍数或数字中含有 $7$，那么报数的方向就反一下。问报数字 $X$ 的是第几号人？

**比如初始 $20$ 个数字的情况是：**

| 数字 $X$ | 报的人的编号 |
| :----------: | :----------: |
| $1$ | $1$ |
| $2$ | $2$ |
| $3$ | $3$ |
| $4$ | $4$ |
| $5$ | $5$ |
| $6$ | $6$ |
| $7$ | $7$ |
| $8$ | $6$ |
| $9$ | $5$ |
| $10$ | $4$ |
| $11$ | $3$ |
| $12$ | $2$ |
| $13$ | $1$ |
| $14$ | $1337$ |
| $15$ | $1$ |
| $16$ | $2$ |
| $17$ | $3$ |
| $18$ | $2$ |
| $19$ | $1$ |
| $20$ | $1337$ |


## 说明/提示

**【数据规模与约定】**

对于 $30\%$ 的数据，满足 $X\leq10^6$；

对于 $90\%$ 的数据，满足 $X\leq10^8$；

对于 $100\%$ 的数据，满足 $X\leq10^9$。

## 样例 #1

### 输入

```
1000```

### 输出

```
1311```

# 题解

## 作者：白烛葵 (赞：86)

~~下方高能暴力~~

作为一个蒟蒻，看到这题1e9的数据范围，铁定是数论QWQ

然后死活推不出公式

之后我写了个模拟程序，跑了一下，打了个表，想找公式。。。

然而除了发现在5e7的范围内不会TLE，以外啥都没发现

~~我去，要是这题数据在5e7以内就好~~

对啊，要是在5e7内就好了。。。

于是，一种神奇的暴力算法出现了QWQ

~~完全不知道这种想法是怎么冒出来的~~

就是既然数据范围是1e9

# 那我就把范围强行压到5e7里

## 具体操作就是，将1e9分成20个5e7，也就是在场外打表

用暴力算出端点的传递方向和当前是谁报数

再写20个if语句，找出n属于20个区域中的哪一个，在进行模拟求算就行了

这样范围就很好的被我们压在5e7中

最为纯粹的暴力啊。。。

~~模拟写的好的话，跑1e9只要19s，表很快就打出来了~~

下面上代码
```
#include<cstdio>
using namespace std;
int n,i,j,k,t,pd,m;
int ha(int x,int y,int z,int a)
//模拟函数，x代表区域端点，y代表n，z是当前在哪个人，a表示如何传递方向
{
    t=z;
    for(i=x;i<=y;i++)
    {
        t+=a;//a有两值，1和-1，这样就不用每次判定浪费时间
        if(i%7==0)
        a=-a;//是7的倍数就变方向
        else
        {
            k=i;
            while(k)//还有含有7的数也要变
            {
                if(k%10==7)
                {a=-a;break;}
                k/=10;
            }
        }
        if(t==0)t=1337;
        if(t==1338)t=1;//界限规定
    }
    printf("%d",t);//答案
}
int main()
{
    //freopen("a.in","r",stdin);
    //freopen("seven.out","w",stdout);
    scanf("%d",&n);
    //下面是最暴力毒瘤的程序，20个if划分区域QWQ
    if(n<5e7){ha(1,n,0,1);}
    //分别对区域进行划分，跑5e7的模拟
    else if(n<1e8){ha(5e7,n,157,-1);}
    else if(n<1e8+5e7){ha(1e8,n,547,1);}
    else if(n<2e8){ha(1e8+5e7,n,346,-1);}
    else if(n<2e8+5e7){ha(2e8,n,867,-1);}
    else if(n<3e8){ha(2e8+5e7,n,892,1);}
    else if(n<3e8+5e7){ha(3e8,n,893,-1);}
    else if(n<4e8){ha(3e8+5e7,n,1212,-1);}
    else if(n<4e8+5e7){ha(4e8,n,63,1);}
    else if(n<5e8){ha(4e8+5e7,n,893,-1);}
    else if(n<5e8+5e7){ha(5e8,n,1302,-1);}
    else if(n<6e8){ha(5e8+5e7,n,1055,1);}
    else if(n<6e8+5e7){ha(6e8,n,98,-1);}
    else if(n<7e8){ha(6e8+5e7,n,957,1);}
    else if(n<7e8+5e7){ha(7e8,n,1279,-1);}
    else if(n<8e8){ha(7e8+5e7,n,1279,-1);}
    else if(n<8e8+5e7){ha(8e8,n,1279,-1);}
    else if(n<9e8){ha(8e8+5e7,n,143,1);}
    else if(n<9e8+5e7){ha(9e8,n,959,1);}
    else if(n<=1e9){ha(9e8+5e7,n,934,-1);}
    //说一下那个n<=1e9的等于，一开始我没写也对了，因为最大数据点好像不是1e9
    return 0;
}
```
这暴力方法是不是很厉害~~毒瘤~~QWQ

一道蓝色数论就这么轻松切掉

所以暴力就要敢想，敢写，脑洞大开，你永远不会知道

暴力到底有多少种神奇的用法

如果你认可我的思路的话

# 请点赞，关注，~~投币，素质三连~~，谢谢支持QWQ

---

## 作者：Playnext (赞：20)

~~（看到没人发题解我来发一个~~

这道题用暴力方法一个一个判断肯定超时。

#### 所以我采用 打表+暴力枚举 （逃

以每个 $1000000$ 为基础，超出的暴力计算。

详细说明在代码注释。

------------

#### 以下为打表程序：


```cpp
    inline bool Judge(REG int num) {
        if(!(num % 7)) //被7整除
            return 1;
        while(num) {
            if (num % 10 == 7)    return true; //数字是否含7
            else    num /= 10;
        }
        return false;
    }

    int kmax = 1e9;
    int now = 1, dir = 1;
    FOR(i,1,kmax)    { //暴力模拟
        //i是报的数字，now是正在报数的人
        //dir是报数方向，1向右，0向左
        if(!dir)    {
            --now;
            if (!now)    now = 1337;      //超出时回到圈尾
            if (Judge (i))    dir = 1;    //反方向
        }
        else    if(dir) {
            ++now;
            if (now == 1338)    now = 1;        //超出时回到圈头
            if (Judge (i))    dir = 0;   //反方向
        }
        if ((!i % 1e6))
            printf ("%d %d\n", Now, Dir); 
    }
    
```

#### 输出到文件后再写个程序整理就行了。

------------

#### 以下为代码：
    
```cpp
#include <bits/stdc++.h>
#define REG register
#define IN inline
#define For(x,y,z) for (REG int (x) = (y); (x) <= (z); ++(x))
#define FOR(x,y,z) for (REG int (x) = (y); (x) <  (z); ++(x))
const int kmax_num = 1e3 + 10, kmax_int = INT_MAX, kmod = 10007;

//记录每1000000位的起始数字。
int f[kmax_num] = {
    0, 469, 139, 1086, 768, 860, 1200, 837, 837, 507, 117,
    1136, 1228, 231, 1205, 337, 7, 954, 954, 862, 522,
    885, 416, 746, 1136, 117, 25, 1022, 1022, 154, 1161,
    771, 453, 545, 885, 522, 991, 661, 661, 979, 887,
    547, 910, 441, 771, 1161, 142, 50, 50, 1024, 156,
    1163, 773, 455, 547, 887, 524, 993, 993, 46, 364,
    272, 1269, 295, 1163, 156, 546, 864, 864, 1204, 841,
    841, 841, 841, 841, 841, 841, 841, 841, 841, 841,
    523, 615, 955, 592, 1061, 731, 341, 341, 249, 1246,
    272, 1140, 133, 523, 841, 749, 409, 409, 878, 548,
    158, 1177, 1269, 272, 1246, 378, 48, 48, 366, 274,
    1271, 297, 1165, 158, 548, 866, 774, 774, 411, 880,
    550, 160, 1179, 1271, 274, 1248, 380, 380, 770, 1088,
    996, 656, 1019, 550, 880, 1270, 251, 251, 591, 228,
    697, 367, 1314, 996, 1088, 91, 1065, 1065, 735, 345,
    27, 119, 459, 96, 565, 235, 1182, 1182, 1090, 750,
    1113, 644, 974, 27, 345, 253, 1250, 1250, 382, 52,
    52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
    1049, 75, 943, 1273, 326, 644, 552, 552, 189, 658,
    328, 1275, 957, 1049, 52, 1026, 158, 158, 548, 866,
    774, 434, 797, 328, 658, 1048, 29, 29, 369, 6,
    475, 145, 1092, 774, 866, 1206, 843, 843, 513, 123,
    1142, 1234, 237, 1211, 343, 13, 960, 960, 868, 528,
    891, 422, 752, 1142, 123, 31, 1028, 1028, 160, 1167,
    777, 459, 551, 891, 528, 997, 667, 667, 985, 893,
    553, 916, 447, 777, 1167, 148, 56, 56, 1030, 162,
    1169, 779, 461, 553, 893, 530, 999, 999, 52, 370,
    370, 370, 370, 370, 370, 370, 370, 370, 370, 370,
    839, 509, 119, 1138, 1230, 233, 1207, 1207, 877, 487,
    169, 261, 601, 238, 707, 377, 1324, 1324, 1232, 892,
    1255, 786, 1116, 169, 487, 395, 55, 55, 524, 194,
    1141, 823, 915, 1255, 892, 24, 1031, 1031, 12, 1257,
    917, 1280, 811, 1141, 194, 512, 420, 420, 57, 526,
    196, 1143, 825, 917, 1257, 894, 26, 26, 416, 734,
    642, 302, 665, 196, 526, 916, 1234, 1234, 237, 1211,
    343, 13, 960, 642, 734, 1074, 711, 711, 381, 1328,
    1010, 1102, 105, 1079, 211, 1218, 828, 828, 736, 396,
    396, 396, 396, 396, 396, 396, 396, 396, 396, 396,
    786, 1104, 1012, 672, 1035, 566, 896, 896, 578, 670,
    1010, 647, 1116, 786, 396, 78, 170, 170, 533, 64,
    394, 784, 1102, 1010, 670, 1033, 564, 564, 174, 1193,
    1285, 288, 1262, 394, 64, 1011, 693, 693, 353, 716,
    247, 577, 967, 1285, 1193, 853, 1216, 1216, 209, 599,
    917, 825, 485, 848, 379, 709, 1099, 1099, 1191, 194,
    1168, 300, 1307, 917, 599, 691, 1031, 1031, 562, 892,
    1282, 263, 171, 1168, 194, 1062, 55, 55, 1074, 1166,
    169, 1143, 275, 1282, 892, 574, 666, 666, 1029, 560,
    560, 560, 560, 560, 560, 560, 560, 560, 560, 560,
    652, 992, 629, 1098, 768, 378, 60, 60, 1057, 83,
    951, 1281, 334, 652, 560, 220, 583, 583, 913, 1303,
    284, 192, 1189, 215, 1083, 76, 466, 466, 558, 898,
    535, 1004, 674, 284, 1303, 58, 398, 398, 1266, 259,
    649, 967, 875, 535, 898, 429, 759, 759, 441, 533,
    873, 510, 979, 649, 259, 1278, 33, 33, 396, 1264,
    257, 647, 965, 873, 533, 896, 427, 427, 37, 1056,
    1148, 151, 1125, 257, 1264, 874, 556, 556, 216, 579,
    110, 440, 830, 1148, 1056, 716, 1079, 1079, 72, 462,
    462, 462, 462, 462, 462, 462, 462, 462, 462, 462,
    99, 568, 238, 1185, 867, 959, 1299, 1299, 830, 1160,
    213, 531, 439, 99, 462, 1330, 323, 323, 5, 97,
    437, 74, 543, 213, 1160, 842, 934, 934, 1297, 828,
    1158, 211, 529, 437, 97, 460, 1328, 1328, 938, 620,
    712, 1052, 689, 1158, 828, 438, 120, 120, 1117, 143,
    1011, 4, 394, 712, 620, 280, 643, 643, 973, 26,
    344, 252, 1249, 275, 1143, 136, 526, 526, 618, 958,
    595, 1064, 734, 344, 26, 118, 458, 458, 1326, 319,
    709, 1027, 935, 595, 958, 489, 819, 819, 501, 593,
    593, 593, 593, 593, 593, 593, 593, 593, 593, 593,
    263, 1210, 892, 984, 1324, 961, 93, 93, 483, 801,
    709, 369, 732, 263, 593, 983, 1301, 1301, 304, 1278,
    1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278,
    1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278,
    1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278,
    1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278,
    1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278,
    1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278,
    1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278,
    1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278,
    1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278,
    1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278,
    331, 649, 557, 217, 580, 111, 441, 441, 123, 215,
    555, 192, 661, 331, 1278, 960, 1052, 1052, 78, 946,
    1276, 329, 647, 555, 215, 578, 109, 109, 1056, 738,
    830, 1170, 807, 1276, 946, 556, 238, 238, 1235, 261,
    1129, 122, 512, 830, 738, 398, 761, 761, 1091, 144,
    462, 370, 30, 393, 1261, 254, 644, 644, 736, 1076,
    713, 1182, 852, 462, 144, 236, 576, 576, 107, 437,
    437, 437, 437, 437, 437, 437, 437, 437, 437, 437,
    777, 414, 883, 553, 163, 1182, 1274, 1274, 300, 1168,
    161, 551, 869, 777, 437, 800, 331, 331, 1278, 960,
    1052, 55, 1029, 161, 1168, 778, 460, 460, 120, 483,
    14, 344, 734, 1052, 960, 620, 983, 983, 1313, 366,
    684, 592, 252, 615, 146, 476, 866, 866, 958, 1298,
    935, 67, 1074, 684, 366, 458, 798, 798, 329, 659,
    1049, 30, 1275, 935, 1298, 829, 1159, 1159, 841, 933,
    1273, 910, 42, 1049, 659, 341, 433, 433, 796, 327,
    657, 1047, 28, 1273, 933, 1296, 827, 827, 437, 119,
    119, 119, 119, 119, 119, 119, 119, 119, 119, 119,
    987, 1317, 370, 688, 596, 256, 619, 619, 949, 2,
    320, 228, 1225, 251, 1119, 112, 502, 502, 594, 934
};

//记录每1000000位的方位，1向右，0向左。
int d[kmax_num] = {
    1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1,
    0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0,
    1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1,
    0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0,
    1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1,
    0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1,
    1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1,
    0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1,
    0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1,
    0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0,
    1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1,
    0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1,
    0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0,
    1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1,
    0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1,
    0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0,
    1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0,
    0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0,
    1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1,
    0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0,
    1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1,
    0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0,
    1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0,
    0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1,
    0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0,
    1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0,
    1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1,
    0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0,
    1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0,
    0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0,
    1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0,
    1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0,
    1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1,
    0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0,
    1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1
};

//判断是否符合条件
inline bool Judge(REG int num) {
    if(!(num % 7)) //被7整除
        return true;
    while(num) {
        if (num % 10 == 7)    return true; //数字是否含7
        else    num /= 10;
    }
    return false;
}

int main() {
    // freopen("G:\\Data\\Sublime Text 3 - WorkSpace\\IO\\Input\\Input.txt", "r", stdin);
    // freopen("G:\\Data\\Sublime Text 3 - WorkSpace\\IO\\Output\\Output.txt", "w",stdout);
    REG int n, now;
    REG bool dir;
    scanf (" %d", &n);

    now = f[n / 1000000];         //n / 1000000位的初始数字
    dir = d[n / 1000000];         //n / 1000000位的方位
    For(i,n / 1000000  * 1000000 + 1, n)    {
        //暴力模拟
        //i是报的数字，now是正在报数的人
        //dir是报数方向，1向右，0向左
        if(!dir)    {
            --now;
            if(!now)    	now = 1337;      //超出时回到圈尾
            if(Judge(i))    dir = 1;    //反方向
        }
        else    if(dir) {
            ++now;
            if(now == 1338)	now = 1;        //超出时回到圈头
            if(Judge(i))    dir = 0;   //反方向
        }
    }
    printf("%d\n", now);    //输出
    return 0;
}
```

---

## 作者：Aoki_灏 (赞：14)

看着这题并没有正解题解就来搬运一下xlj巨神的正解

然后就是在暴力的基础上优化

[来自这位巨神](https://www.luogu.org/space/show?uid=42857)

## 间隔打表大法好！！！

## 优化点
         1.优化%7
         
          cnt计数器计算%7的值，每次加的时候就+1
          到了7就变0，这样减少算mod7的时间

        2.优化每位数上有7的情况
        
          每次加1的时候用类似高精度的方法统计每位上面是否有7
          具体来说
          记录一个全局变量N7
          就是每一位到了7的时候N7=N7+1
          到了8的时候N7=N7-1
          处理进位的情况
          只有N7等于0的时候方向才不变

         3.间隔打表
          对于10^8以上的数据
          从10^8到10^9，每隔10的八次方就算出来
          这样的话
          10^9的被压缩成10^8的复杂度就可以跑过了
          
## 代码
```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<queue>
#include<cmath>
using namespace std;
int num[20];
int c=0;
int n;
inline void add(){
	num[1]++;
	if(num[1]==8) c--;
	if(num[1]==7) c++;
	int pos=1;
	while(num[pos]>9){
		num[pos]%=10;
		pos++;
		num[pos]++;
		if(num[pos]==8) c--;
		if(num[pos]==7) c++;
	}
}
int fx[]={1,1,-1,-1,1,1,-1,1,-1,1};
int b[]={0,548,866,892,64,1303,97,1278,1278,960};
int main(){
	
	int x;
	scanf("%d",&x);
	int k=x/100000000;
	 n=100000000*k;
	int pos=b[k],dic=fx[k];
	while(1){
		pos=(pos+dic+1336)%1337+1;
		n++;
		add();
		if(n%7==0||c>0) dic=-dic;
		if(n==x) break;  
	}
	printf("%d",pos);
	return 0;
}
```

---

## 作者：wangbo0 (赞：7)

本题思路：
首先，用一个变量 $a$ 来表示在原本 $1$ 号人的基础前进或后退的人数，再用一个 $int$ 类型的变量 $s$ 来表示报数的方向，先把它赋值为 $0$ ，表示人的号数越来越大。

最重要的来了：
大多数人会设一个长度为人数个数的数组，可是这个其实没什么用，还会浪费空间。直接用一个循环体，设 $i$ 表示报的数，在后面就方便判断了。如果符合要求：报的数是 $7$ 的倍数或数字中含有它，就把方向反一下。
最后，再把表示原本基础前进或后退的人数的变量变成正整数且小于等于   $1337$ 的形式，就可以输出了。

以上为本题核心。
```c
下面是代码：
#include<iostream>
using namespace std;
int main(){
	long long x;
	cin>>x;
	int a=1;
	int s=0;
	for(long long i=1;i<x;i++){
        if(i%7==0||i%10==7
		||i%100/10==7||i%1000/100==7
		||i%10000/1000==7||i%100000/10000==7
		||i%1000000/100000==7
		||i%10000000/1000000==7
		||i%100000000/10000000==7){
			if(s==1){
                s=0;
            }
            else if(s==0){
                s=1;
            }
		}
		if(s==0){
			a++;
		}
		if(s==1){
			a--;
		}
	}
    for(int y=0;y<10000;y++){
        if(a<=0){
            a+=1337;
        }
        if(a>0){
            cout<<a<<endl;
            break;
        }
    
    }
    
	return 0;
}
```
这次写的比较匆忙，如有错误，请指出，感激不尽！


---

## 作者：lu_run_ting (赞：4)

本蒟蒻看到题目后彻底晕了，想方法就想了一个小时QwQ

本题的X<=10^9,如果暴力肯定不行，换；

数学方法找不到，换；

全打表不行，换；

好像没有什么好方法了QaQ!
# 	隔断打表是个好东西！

下面介绍一下什么是隔断打表：

我们把整个大的区间分为若干个，用暴力算一下每个区间的第一个数，然后在这第一个数的基础上用暴力方法计算。



打表代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int x,y;
bool f(int a){
	if(a%7==0) return 1;
	while(a!=0){
		if(a%10==7) return 1;
		a/=10;
	}
	return 0;
}
int main(){x=1,y=1;
	for(int i=1;i<=1000000000;i++){
		if(i%50000000==0) cout<<x<<" "<<y<<endl;
		if(f(i)==1) y=1-y;
		if(y==1) x++;
		if(y==0) x--;
		if(x<1) x=1337;
		if(x>1337) x=1;
	} 
	return 0;
} 
```



------------

AC程序(c++)：

```cpp
#include <bits/stdc++.h>
using namespace std;
bool f(int a){
	if(a%7==0) return 1;
	while(a!=0){
		if(a%10==7) return 1;
		a/=10;
	}
	return 0;
}
int a[20]={1,156,548,345,866,893,892,1211,64,892,1303,1056,97,958,1278,1278,1278,144,960,933},b[20]={1,0,1,0,0,1,0,0,1,0,1,1,0,1,0,0,0,1,1,0},X,flag,x,y; 
int main(){
	scanf("%d",&X);
	if(1<=X&&X<50000000) flag=0;
	else if(50000000<=X&&X<100000000) flag=1;
	else if(100000000<=X&&X<150000000) flag=2;
	else if(150000000<=X&&X<200000000) flag=3;
	else if(200000000<=X&&X<250000000) flag=4;
	else if(250000000<=X&&X<300000000) flag=5;
	else if(300000000<=X&&X<350000000) flag=6;
	else if(350000000<=X&&X<400000000) flag=7;
	else if(400000000<=X&&X<450000000) flag=8;
	else if(450000000<=X&&X<500000000) flag=9;
	else if(500000000<=X&&X<550000000) flag=10;
	else if(550000000<=X&&X<600000000) flag=11;
	else if(600000000<=X&&X<650000000) flag=12;
	else if(650000000<=X&&X<700000000) flag=13;
	else if(700000000<=X&&X<750000000) flag=14;
	else if(750000000<=X&&X<800000000) flag=15;
	else if(800000000<=X&&X<850000000) flag=16;
	else if(850000000<=X&&X<900000000) flag=17;
	else if(900000000<=X&&X<950000000) flag=18;
	else if(950000000<=X&&X<1000000000) flag=19;
	else{
		cout<<934<<endl;
		return 0;
	} 
	x=a[flag],y=b[flag]; int z=flag*50000000; if(flag==0) z=1;
	for(int i=z;i<=1e9;i++){
		if(i==X){
			cout<<x<<endl;
			return 0;
		}
		if(f(i)==1) y=1-y;
		if(y==1) x++;
		if(y==0) x--;
		if(x<1) x=1337;
		if(x>1337) x=1;
	}
	cout<<x<<endl;
	return 0;
} 
```

### 注意：区间大小一定要注意！像我这种不会优化的蒟蒻，区间一定要多一点，~~不然就会酿成惨剧（别问我是怎么知道的~~
     

---

## 作者：Tenshi (赞：3)

分块打表练手题

## 步骤
先预处理出 $1\times10^6,2\times10^6,...,1000\times10^6$ 的状态。（这里的 $10^6$ 就是所谓的块长 $len$ 了）

这里的状态有两个属性：方向、位置（也就是第几个人）。

然后我们将这 $1000$ 个状态存入表中。

结合分块的思想，对于查询 $n$ ，我们将 $n$ 表述为 $n = 10^6\times k + r$ ，$k$ 就是对应的块数，可以用打表出的状态 $O(1)$ 求出，然后剩下 $r$ 直接暴力模拟求出，因为 $r<10^6$ （块长），故复杂度即为 $O(len)$ 。

## 代码实现
### generator
```cpp
#include<bits/stdc++.h>
using namespace std;

const int len=1e6;

bool check(int v){
	if(v%7==0) return true;
	while(v){
		if(v%10==7) return true;
		v/=10;
	}
	return false;
}

int main(){
	freopen("table.out", "w", stdout);
	int tag=1, p=1337; // 模拟撞到特殊的数而且已经回头了
	int tot=0;
	for(int i=1; i<=1000; i++){
		int L=(i-1)*len+1, R=i*len;
		int x=tag, y=p;
		for(int j=L; j<=R; j++){
			++tot;
			if(y==1337 && x==1) y=1;
			else if(y==1 && x==-1) y=1337;
			else y+=x;
			
			if(check(tot)) x=-x;
		} 
		tag=x, p=y;
		cout<<p<<','<<tag<<',';
	}
	return 0;
}
```

### table
```
int table[]={
	0,469,-1,139,1,1086,-1,768,1,860,-1,1200,1,837,1,837,-1,507,1,117,-1,1136,1,1228,-1,231,1,1205,1,337,-1,7,1,954,1,954,-1,862,1,522,-1,885,-1,416,1,746,-1,1136,1,117,-1,25,1,1022,1,1022,1,154,-1,1161,1,771,-1,453,1,545,-1,885,1,522,1,991,-1,661,-1,661,1,979,-1,887,1,547,-1,910,-1,441,1,771,-1,1161,1,142,-1,50,-1,50,1,1024,1,156,-1,1163,1,773,-1,455,1,547,-1,887,1,524,1,993,1,993,-1,46,1,364,-1,272,1,1269,-1,295,-1,1163,1,156,-1,546,1,864,1,864,-1,1204,1,841,1,841,1,841,1,841,1,841,1,841,1,841,1,841,1,841,1,841,1,841,-1,523,1,615,-1,955,1,592,1,1061,-1,731,1,341,1,341,-1,249,1,1246,-1,272,-1,1140,1,133,-1,523,1,841,-1,749,1,409,1,409,1,878,-1,548,1,158,-1,1177,1,1269,-1,272,1,1246,1,378,-1,48,-1,48,1,366,-1,274,1,1271,-1,297,-1,1165,1,158,-1,548,1,866,-1,774,-1,774,1,411,1,880,-1,550,1,160,-1,1179,1,1271,-1,274,1,1248,1,380,1,380,-1,770,1,1088,-1,996,1,656,-1,1019,-1,550,1,880,-1,1270,1,251,1,251,-1,591,1,228,1,697,-1,367,1,1314,-1,996,1,1088,-1,91,1,1065,1,1065,-1,735,1,345,-1,27,1,119,-1,459,1,96,1,565,-1,235,1,1182,1,1182,-1,1090,1,750,-1,1113,-1,644,1,974,-1,27,1,345,-1,253,1,1250,1,1250,1,382,-1,52,-1,52,-1,52,-1,52,-1,52,-1,52,-1,52,-1,52,-1,52,-1,52,-1,52,1,1049,-1,75,-1,943,1,1273,-1,326,1,644,-1,552,-1,552,1,189,1,658,-1,328,1,1275,-1,957,1,1049,-1,52,1,1026,1,158,1,158,-1,548,1,866,-1,774,1,434,-1,797,-1,328,1,658,-1,1048,1,29,1,29,-1,369,1,6,1,475,-1,145,1,1092,-1,774,1,866,-1,1206,1,843,1,843,-1,513,1,123,-1,1142,1,1234,-1,237,1,1211,1,343,-1,13,1,960,1,960,-1,868,1,528,-1,891,-1,422,1,752,-1,1142,1,123,-1,31,1,1028,1,1028,1,160,-1,1167,1,777,-1,459,1,551,-1,891,1,528,1,997,-1,667,-1,667,1,985,-1,893,1,553,-1,916,-1,447,1,777,-1,1167,1,148,-1,56,-1,56,1,1030,1,162,-1,1169,1,779,-1,461,1,553,-1,893,1,530,1,999,1,999,-1,52,1,370,1,370,1,370,1,370,1,370,1,370,1,370,1,370,1,370,1,370,1,370,1,839,-1,509,1,119,-1,1138,1,1230,-1,233,1,1207,1,1207,-1,877,1,487,-1,169,1,261,-1,601,1,238,1,707,-1,377,1,1324,1,1324,-1,1232,1,892,-1,1255,-1,786,1,1116,-1,169,1,487,-1,395,1,55,1,55,1,524,-1,194,1,1141,-1,823,1,915,-1,1255,1,892,1,24,-1,1031,-1,1031,1,12,-1,1257,1,917,-1,1280,-1,811,1,1141,-1,194,1,512,-1,420,-1,420,1,57,1,526,-1,196,1,1143,-1,825,1,917,-1,1257,1,894,1,26,1,26,-1,416,1,734,-1,642,1,302,-1,665,-1,196,1,526,-1,916,1,1234,1,1234,-1,237,1,1211,1,343,-1,13,1,960,-1,642,1,734,-1,1074,1,711,1,711,-1,381,1,1328,-1,1010,1,1102,-1,105,1,1079,1,211,-1,1218,1,828,1,828,-1,736,1,396,1,396,1,396,1,396,1,396,1,396,1,396,1,396,1,396,1,396,1,396,-1,786,1,1104,-1,1012,1,672,-1,1035,-1,566,1,896,1,896,-1,578,1,670,-1,1010,1,647,1,1116,-1,786,1,396,-1,78,1,170,1,170,-1,533,-1,64,1,394,-1,784,1,1102,-1,1010,1,670,-1,1033,-1,564,-1,564,1,174,-1,1193,1,1285,-1,288,1,1262,1,394,-1,64,1,1011,-1,693,-1,693,1,353,-1,716,-1,247,1,577,-1,967,1,1285,-1,1193,1,853,-1,1216,-1,1216,1,209,-1,599,1,917,-1,825,1,485,-1,848,-1,379,1,709,-1,1099,-1,1099,1,1191,-1,194,1,1168,1,300,-1,1307,1,917,-1,599,1,691,-1,1031,-1,1031,-1,562,1,892,-1,1282,1,263,-1,171,1,1168,-1,194,-1,1062,1,55,1,55,-1,1074,1,1166,-1,169,1,1143,1,275,-1,1282,1,892,-1,574,1,666,1,666,-1,1029,-1,560,-1,560,-1,560,-1,560,-1,560,-1,560,-1,560,-1,560,-1,560,-1,560,-1,560,1,652,-1,992,1,629,1,1098,-1,768,1,378,-1,60,-1,60,1,1057,-1,83,-1,951,1,1281,-1,334,1,652,-1,560,1,220,-1,583,-1,583,1,913,-1,1303,1,284,-1,192,1,1189,-1,215,-1,1083,1,76,-1,466,-1,466,1,558,-1,898,1,535,1,1004,-1,674,1,284,-1,1303,1,58,-1,398,-1,398,-1,1266,1,259,-1,649,1,967,-1,875,1,535,-1,898,-1,429,1,759,1,759,-1,441,1,533,-1,873,1,510,1,979,-1,649,1,259,-1,1278,1,33,1,33,-1,396,-1,1264,1,257,-1,647,1,965,-1,873,1,533,-1,896,-1,427,-1,427,1,37,-1,1056,1,1148,-1,151,1,1125,1,257,-1,1264,1,874,-1,556,-1,556,1,216,-1,579,-1,110,1,440,-1,830,1,1148,-1,1056,1,716,-1,1079,-1,1079,1,72,-1,462,-1,462,-1,462,-1,462,-1,462,-1,462,-1,462,-1,462,-1,462,-1,462,-1,462,1,99,1,568,-1,238,1,1185,-1,867,1,959,-1,1299,-1,1299,-1,830,1,1160,-1,213,1,531,-1,439,1,99,-1,462,-1,1330,1,323,1,323,-1,5,1,97,-1,437,1,74,1,543,-1,213,1,1160,-1,842,1,934,1,934,-1,1297,-1,828,1,1158,-1,211,1,529,-1,437,1,97,-1,460,-1,1328,-1,1328,1,938,-1,620,1,712,-1,1052,1,689,1,1158,-1,828,1,438,-1,120,-1,120,1,1117,-1,143,-1,1011,1,4,-1,394,1,712,-1,620,1,280,-1,643,-1,643,1,973,-1,26,1,344,-1,252,1,1249,-1,275,-1,1143,1,136,-1,526,-1,526,1,618,-1,958,1,595,1,1064,-1,734,1,344,-1,26,1,118,-1,458,-1,458,-1,1326,1,319,-1,709,1,1027,-1,935,1,595,-1,958,-1,489,1,819,1,819,-1,501,1,593,1,593,1,593,1,593,1,593,1,593,1,593,1,593,1,593,1,593,1,593,-1,263,1,1210,-1,892,1,984,-1,1324,1,961,1,93,1,93,-1,483,1,801,-1,709,1,369,-1,732,-1,263,1,593,-1,983,1,1301,1,1301,-1,304,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,-1,331,1,649,-1,557,1,217,-1,580,-1,111,1,441,1,441,-1,123,1,215,-1,555,1,192,1,661,-1,331,1,1278,-1,960,1,1052,1,1052,-1,78,-1,946,1,1276,-1,329,1,647,-1,555,1,215,-1,578,-1,109,-1,109,1,1056,-1,738,1,830,-1,1170,1,807,1,1276,-1,946,1,556,-1,238,-1,238,1,1235,-1,261,-1,1129,1,122,-1,512,1,830,-1,738,1,398,-1,761,-1,761,1,1091,-1,144,1,462,-1,370,1,30,-1,393,-1,1261,1,254,-1,644,-1,644,1,736,-1,1076,1,713,1,1182,-1,852,1,462,-1,144,1,236,-1,576,-1,576,-1,107,1,437,1,437,1,437,1,437,1,437,1,437,1,437,1,437,1,437,1,437,1,437,-1,777,1,414,1,883,-1,553,1,163,-1,1182,1,1274,1,1274,-1,300,-1,1168,1,161,-1,551,1,869,-1,777,1,437,-1,800,-1,331,-1,331,1,1278,-1,960,1,1052,-1,55,1,1029,1,161,-1,1168,1,778,-1,460,-1,460,1,120,-1,483,-1,14,1,344,-1,734,1,1052,-1,960,1,620,-1,983,-1,983,1,1313,-1,366,1,684,-1,592,1,252,-1,615,-1,146,1,476,-1,866,-1,866,1,958,-1,1298,1,935,1,67,-1,1074,1,684,-1,366,1,458,-1,798,-1,798,-1,329,1,659,-1,1049,1,30,-1,1275,1,935,-1,1298,-1,829,1,1159,1,1159,-1,841,1,933,-1,1273,1,910,1,42,-1,1049,1,659,-1,341,1,433,1,433,-1,796,-1,327,1,657,-1,1047,1,28,-1,1273,1,933,-1,1296,-1,827,-1,827,1,437,-1,119,-1,119,-1,119,-1,119,-1,119,-1,119,-1,119,-1,119,-1,119,-1,119,-1,119,-1,987,1,1317,-1,370,1,688,-1,596,1,256,-1,619,-1,619,1,949,-1,2,1,320,-1,228,1,1225,-1,251,-1,1119,1,112,-1,502,-1,502,1,594,-1,934,1
};
```

### main
```cpp
#include<bits/stdc++.h>
using namespace std;

const int len=1e6;

int table[]={
	0,469,-1,139,1,1086,-1,768,1,860,-1,1200,1,837,1,837,-1,507,1,117,-1,1136,1,1228,-1,231,1,1205,1,337,-1,7,1,954,1,954,-1,862,1,522,-1,885,-1,416,1,746,-1,1136,1,117,-1,25,1,1022,1,1022,1,154,-1,1161,1,771,-1,453,1,545,-1,885,1,522,1,991,-1,661,-1,661,1,979,-1,887,1,547,-1,910,-1,441,1,771,-1,1161,1,142,-1,50,-1,50,1,1024,1,156,-1,1163,1,773,-1,455,1,547,-1,887,1,524,1,993,1,993,-1,46,1,364,-1,272,1,1269,-1,295,-1,1163,1,156,-1,546,1,864,1,864,-1,1204,1,841,1,841,1,841,1,841,1,841,1,841,1,841,1,841,1,841,1,841,1,841,-1,523,1,615,-1,955,1,592,1,1061,-1,731,1,341,1,341,-1,249,1,1246,-1,272,-1,1140,1,133,-1,523,1,841,-1,749,1,409,1,409,1,878,-1,548,1,158,-1,1177,1,1269,-1,272,1,1246,1,378,-1,48,-1,48,1,366,-1,274,1,1271,-1,297,-1,1165,1,158,-1,548,1,866,-1,774,-1,774,1,411,1,880,-1,550,1,160,-1,1179,1,1271,-1,274,1,1248,1,380,1,380,-1,770,1,1088,-1,996,1,656,-1,1019,-1,550,1,880,-1,1270,1,251,1,251,-1,591,1,228,1,697,-1,367,1,1314,-1,996,1,1088,-1,91,1,1065,1,1065,-1,735,1,345,-1,27,1,119,-1,459,1,96,1,565,-1,235,1,1182,1,1182,-1,1090,1,750,-1,1113,-1,644,1,974,-1,27,1,345,-1,253,1,1250,1,1250,1,382,-1,52,-1,52,-1,52,-1,52,-1,52,-1,52,-1,52,-1,52,-1,52,-1,52,-1,52,1,1049,-1,75,-1,943,1,1273,-1,326,1,644,-1,552,-1,552,1,189,1,658,-1,328,1,1275,-1,957,1,1049,-1,52,1,1026,1,158,1,158,-1,548,1,866,-1,774,1,434,-1,797,-1,328,1,658,-1,1048,1,29,1,29,-1,369,1,6,1,475,-1,145,1,1092,-1,774,1,866,-1,1206,1,843,1,843,-1,513,1,123,-1,1142,1,1234,-1,237,1,1211,1,343,-1,13,1,960,1,960,-1,868,1,528,-1,891,-1,422,1,752,-1,1142,1,123,-1,31,1,1028,1,1028,1,160,-1,1167,1,777,-1,459,1,551,-1,891,1,528,1,997,-1,667,-1,667,1,985,-1,893,1,553,-1,916,-1,447,1,777,-1,1167,1,148,-1,56,-1,56,1,1030,1,162,-1,1169,1,779,-1,461,1,553,-1,893,1,530,1,999,1,999,-1,52,1,370,1,370,1,370,1,370,1,370,1,370,1,370,1,370,1,370,1,370,1,370,1,839,-1,509,1,119,-1,1138,1,1230,-1,233,1,1207,1,1207,-1,877,1,487,-1,169,1,261,-1,601,1,238,1,707,-1,377,1,1324,1,1324,-1,1232,1,892,-1,1255,-1,786,1,1116,-1,169,1,487,-1,395,1,55,1,55,1,524,-1,194,1,1141,-1,823,1,915,-1,1255,1,892,1,24,-1,1031,-1,1031,1,12,-1,1257,1,917,-1,1280,-1,811,1,1141,-1,194,1,512,-1,420,-1,420,1,57,1,526,-1,196,1,1143,-1,825,1,917,-1,1257,1,894,1,26,1,26,-1,416,1,734,-1,642,1,302,-1,665,-1,196,1,526,-1,916,1,1234,1,1234,-1,237,1,1211,1,343,-1,13,1,960,-1,642,1,734,-1,1074,1,711,1,711,-1,381,1,1328,-1,1010,1,1102,-1,105,1,1079,1,211,-1,1218,1,828,1,828,-1,736,1,396,1,396,1,396,1,396,1,396,1,396,1,396,1,396,1,396,1,396,1,396,-1,786,1,1104,-1,1012,1,672,-1,1035,-1,566,1,896,1,896,-1,578,1,670,-1,1010,1,647,1,1116,-1,786,1,396,-1,78,1,170,1,170,-1,533,-1,64,1,394,-1,784,1,1102,-1,1010,1,670,-1,1033,-1,564,-1,564,1,174,-1,1193,1,1285,-1,288,1,1262,1,394,-1,64,1,1011,-1,693,-1,693,1,353,-1,716,-1,247,1,577,-1,967,1,1285,-1,1193,1,853,-1,1216,-1,1216,1,209,-1,599,1,917,-1,825,1,485,-1,848,-1,379,1,709,-1,1099,-1,1099,1,1191,-1,194,1,1168,1,300,-1,1307,1,917,-1,599,1,691,-1,1031,-1,1031,-1,562,1,892,-1,1282,1,263,-1,171,1,1168,-1,194,-1,1062,1,55,1,55,-1,1074,1,1166,-1,169,1,1143,1,275,-1,1282,1,892,-1,574,1,666,1,666,-1,1029,-1,560,-1,560,-1,560,-1,560,-1,560,-1,560,-1,560,-1,560,-1,560,-1,560,-1,560,1,652,-1,992,1,629,1,1098,-1,768,1,378,-1,60,-1,60,1,1057,-1,83,-1,951,1,1281,-1,334,1,652,-1,560,1,220,-1,583,-1,583,1,913,-1,1303,1,284,-1,192,1,1189,-1,215,-1,1083,1,76,-1,466,-1,466,1,558,-1,898,1,535,1,1004,-1,674,1,284,-1,1303,1,58,-1,398,-1,398,-1,1266,1,259,-1,649,1,967,-1,875,1,535,-1,898,-1,429,1,759,1,759,-1,441,1,533,-1,873,1,510,1,979,-1,649,1,259,-1,1278,1,33,1,33,-1,396,-1,1264,1,257,-1,647,1,965,-1,873,1,533,-1,896,-1,427,-1,427,1,37,-1,1056,1,1148,-1,151,1,1125,1,257,-1,1264,1,874,-1,556,-1,556,1,216,-1,579,-1,110,1,440,-1,830,1,1148,-1,1056,1,716,-1,1079,-1,1079,1,72,-1,462,-1,462,-1,462,-1,462,-1,462,-1,462,-1,462,-1,462,-1,462,-1,462,-1,462,1,99,1,568,-1,238,1,1185,-1,867,1,959,-1,1299,-1,1299,-1,830,1,1160,-1,213,1,531,-1,439,1,99,-1,462,-1,1330,1,323,1,323,-1,5,1,97,-1,437,1,74,1,543,-1,213,1,1160,-1,842,1,934,1,934,-1,1297,-1,828,1,1158,-1,211,1,529,-1,437,1,97,-1,460,-1,1328,-1,1328,1,938,-1,620,1,712,-1,1052,1,689,1,1158,-1,828,1,438,-1,120,-1,120,1,1117,-1,143,-1,1011,1,4,-1,394,1,712,-1,620,1,280,-1,643,-1,643,1,973,-1,26,1,344,-1,252,1,1249,-1,275,-1,1143,1,136,-1,526,-1,526,1,618,-1,958,1,595,1,1064,-1,734,1,344,-1,26,1,118,-1,458,-1,458,-1,1326,1,319,-1,709,1,1027,-1,935,1,595,-1,958,-1,489,1,819,1,819,-1,501,1,593,1,593,1,593,1,593,1,593,1,593,1,593,1,593,1,593,1,593,1,593,-1,263,1,1210,-1,892,1,984,-1,1324,1,961,1,93,1,93,-1,483,1,801,-1,709,1,369,-1,732,-1,263,1,593,-1,983,1,1301,1,1301,-1,304,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,1,1278,-1,331,1,649,-1,557,1,217,-1,580,-1,111,1,441,1,441,-1,123,1,215,-1,555,1,192,1,661,-1,331,1,1278,-1,960,1,1052,1,1052,-1,78,-1,946,1,1276,-1,329,1,647,-1,555,1,215,-1,578,-1,109,-1,109,1,1056,-1,738,1,830,-1,1170,1,807,1,1276,-1,946,1,556,-1,238,-1,238,1,1235,-1,261,-1,1129,1,122,-1,512,1,830,-1,738,1,398,-1,761,-1,761,1,1091,-1,144,1,462,-1,370,1,30,-1,393,-1,1261,1,254,-1,644,-1,644,1,736,-1,1076,1,713,1,1182,-1,852,1,462,-1,144,1,236,-1,576,-1,576,-1,107,1,437,1,437,1,437,1,437,1,437,1,437,1,437,1,437,1,437,1,437,1,437,-1,777,1,414,1,883,-1,553,1,163,-1,1182,1,1274,1,1274,-1,300,-1,1168,1,161,-1,551,1,869,-1,777,1,437,-1,800,-1,331,-1,331,1,1278,-1,960,1,1052,-1,55,1,1029,1,161,-1,1168,1,778,-1,460,-1,460,1,120,-1,483,-1,14,1,344,-1,734,1,1052,-1,960,1,620,-1,983,-1,983,1,1313,-1,366,1,684,-1,592,1,252,-1,615,-1,146,1,476,-1,866,-1,866,1,958,-1,1298,1,935,1,67,-1,1074,1,684,-1,366,1,458,-1,798,-1,798,-1,329,1,659,-1,1049,1,30,-1,1275,1,935,-1,1298,-1,829,1,1159,1,1159,-1,841,1,933,-1,1273,1,910,1,42,-1,1049,1,659,-1,341,1,433,1,433,-1,796,-1,327,1,657,-1,1047,1,28,-1,1273,1,933,-1,1296,-1,827,-1,827,1,437,-1,119,-1,119,-1,119,-1,119,-1,119,-1,119,-1,119,-1,119,-1,119,-1,119,-1,119,-1,987,1,1317,-1,370,1,688,-1,596,1,256,-1,619,-1,619,1,949,-1,2,1,320,-1,228,1,1225,-1,251,-1,1119,1,112,-1,502,-1,502,1,594,-1,934,1
};

bool check(int v){
	if(v%7==0) return true;
	while(v){
		if(v%10==7) return true;
		v/=10;
	}
	return false;
}

int main(){
	int n; cin>>n;
	int y=1337, x=1;
	if(n>=len){
		y=table[n/len*2-1], x=table[n/len*2];
	}
	
	int last=n%len;
	int tot=n/len*len;
	for(int i=0; i<last; i++){
		++tot;
		if(y==1337 && x==1) y=1;
		else if(y==1 && x==-1) y=1337;
		else y+=x;
		
		if(check(tot)) x=-x;
	}
	cout<<y<<endl;
	
	return 0;
}
```

---

## 作者：4526_ (赞：3)

$update$：补上了打表代码

[题目链接](https://www.luogu.com.cn/problem/P1662)

### 更优美的暴力——分段打表

校内模拟赛遇到了这题，感觉难度不大但是全机房只有我一个AC......这篇题解将通过我考场上的解题思路介绍分段打表，希望能让大家有所收获qwq

题意不难理解，数据范围比暴力略大，作为数论题似乎又太小了，暂且往数论方向考虑

暴力搞出 $100$ 以内的情况，看不出明显的规律，对于 $10^8$ 以上数论题常用的矩阵乘法之类的也显然不行，折腾几分钟无果（赛后查 $\text{OEIS}$ 确实没有公式~~虽然大多数题都没有~~）

注意到参与报数的人数是固定的，也就是说每一个数字所对应的位置不会改变，简直是为打表而生（~~我觉得这太野蛮了~~，为了更好地提高自己的水平，还是建议大家在模拟赛时有更好的解法就不要想打表）

$10^9$ 不算太大，暴力跑大概 $20s$，在本机全部打出来，贴进代码，提交

![](https://cdn.luogu.com.cn/upload/image_hosting/o241flng.png)

很多 $\text{OJ}$ 的代码长度限制都是 $100k$，超过这个长度直接 $\text{CE}$，$OI$ 赛制下一定要注意打表代码是否超限，有时候只能放弃部分分以确保小数据范围能拿下，~~打表不规范，爆零两行泪~~

进一步想到，本题中每一个次报数的位置都是从上一个位置转移来的，如果知道当前位置，不需要更早的报数情况，也能推出之后的位置，所以只要记录一些关键位置，就可以在时限内跑出答案，每隔一定距离存储一个结果，大大缩短了代码长度

这就是分段打表的主要思想：**通过打表预处理某些数据，并根据已有数据得到全部所需信息**

从推导过程中不难发现，分段打表主要适用于**当前状态可由前一个或几个状态转移而来**的题目，比如斐波那契数列，通过牺牲时间换取更优的空间和代码长度 ~~话说打表的时间算什么牺牲啊喂~~

分段打表并不难，只要知道这一思想，基本可以暴切所有同类题目，但是在不了解的时候要独立搞出来也不容易，考场上我就是在知道分段打表的情况下才想到正解的

本题打表间隔使用 $10^6$ 或 $10^7$ 均可，因为时间压力不大，保险起见用了 $10^7$

打表部分：

```cpp
	freopen("ans.txt","w",stdout);
	dir=pos=1;
	printf("{0,1},");
	for(register int i=2;i<=1000000000;++i){
		pos+=dir;
		if(pos==1338) pos=1;
		else if(pos==0) pos=1337;
		if(i%7==0) dir*=-1;
		else{
			tmp=i;
			while(tmp){
				if(tmp%10==7){
					dir*=-1;
					break;
				}
				tmp/=10;
			}
		}
		if(i%10000000==0){
			printf("{%d,%d},",pos,dir);
		}
	}
```

AC代码：

(第一维是当前位置，第二维是报数方向，$1$ 表示从前往后，$-1$ 表示从后往前)

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

int n,ans,dir=1,tmp;
int arr[105][2]={{0,1},{117,-1},{522,-1},{1161,1},{887,1},{156,-1},{364,-1},{841,1},{841,-1},{1246,-1},{548,1},{274,1},{880,-1},{1088,-1},{228,1},{345,-1},{750,-1},{52,-1},{52,1},{658,-1},{866,-1},{6,1},{123,-1},{528,-1},{1167,1},{893,1},{162,-1},{370,1},{370,1},{487,-1},{892,-1},{194,1},{1257,1},{526,-1},{734,-1},{1211,1},{1328,-1},{396,1},{396,-1},{670,-1},{64,1},{1193,1},{716,-1},{599,1},{194,1},{892,-1},{1166,-1},{560,-1},{560,1},{83,-1},{1303,1},{898,1},{259,-1},{533,-1},{1264,1},{1056,1},{579,-1},{462,-1},{462,1},{1160,-1},{97,-1},{828,1},{620,1},{143,-1},{26,1},{958,1},{319,-1},{593,1},{593,-1},{801,-1},{1278,1},{1278,1},{1278,1},{1278,1},{1278,1},{1278,1},{1278,1},{1278,1},{1278,1},{1278,1},{1278,-1},{215,-1},{946,1},{738,1},{261,-1},{144,1},{1076,1},{437,1},{437,-1},{1168,1},{960,1},{483,-1},{366,1},{1298,1},{659,-1},{933,-1},{327,1},{119,-1},{119,-1},{2,1},{934,1}};

inline bool pd(int x){
	if(x%7==0) return true;
	tmp=x;
	while(tmp){
		if(tmp%10==7) return true;
		tmp/=10;
	}
	return false;
}

int main(){
	scanf("%d",&n);
	tmp=n/10000000;
	ans=arr[tmp][0],dir=arr[tmp][1];
	for(register int i=tmp*10000000+1;i<=n;++i){
		ans=(ans+dir+1337)%1337;
		if(pd(i)) dir=-dir;
	}
	printf("%d",ans ? ans : 1337);
	return 0;
}

```

欢迎来[我的blog](https://www.luogu.com.cn/blog/138812/#)看看

---

## 作者：XL4453 (赞：2)


### 解题思路：

直接暴力能处理的范围大概也就是 $10^8$ 这个样子，看起来有点危险，放小一些 $t=5\times 10^7$。发现最大的数据范围也就是这个数的几十倍的样子，考虑用隔断打表法直接暴力求解。

思路是直接就是记录下每一个 $kt$ 位置时的状态，包括当前报数的方向和报数者的编号，在提交代码中直接接着这个状态往后计算一段即可。

这样就在保证了复杂度的同时避免了通常打表代码太大的问题。

---
### 代码：

```cpp
#include<cstdio>
using namespace std;
int x,p[50]={1,157,547,346,867,892,893,1212,63,893,1302,1055,98,957,1279,1279,1279,143,959,934};
int dir[50]={-1,-1, 1,  -1, -1, 1,  -1, -1  ,1 ,-1, -1,  1,  -1, 1,  -1  ,-1 ,-1  ,1,  1,-1};
void work(int now,int x,int p,int dir){
	for(int i=now;i<=x;i++){
		p+=dir;
		if(i%7==0)dir=-dir;
		else{
			int i_=i;
			while(i_){
				if(i_%10==7){
					dir=-dir;
					break;
				}
				i_/=10;
			}
		}
		if(p==1338)p=1;
		if(p==0)p=1337;
	}
	printf("%d\n",p);
}
int main(){
	scanf("%d",&x);
	work(50000000*(x/50000000),x,p[x/50000000],dir[x/50000000]);
	return 0;
}
```


---

## 作者：yeshubo_qwq (赞：2)

看到这题，很容易打出一个暴力。

暴力比较简单，具体见代码。

Code：

```cpp
#include <bits/stdc++.h>
//#define int long long
using namespace std;
int n,i,x,fl,y;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for (i=1;i<=n;i++){
		if (fl==0) x=(x==1337?1:x+1);//1->2->3...->1337->1
		else x=(x==1?1337:x-1);//1->1337->1336...
		if (i%7==0) fl^=1;//7的倍数
		else{
			y=i;
			while (y>0){
				if (y%10==7) {fl^=1;break;}//含有7
				y/=10;
			}
		}
	}
	cout<<x;
	return 0;
}
```

吸氧后 #10 TLE 了（[record](https://www.luogu.com.cn/record/77001584)）。

于是考虑分块打表，发现 $10^8$ 暴力可过，令块长为 $5 \times 10^7$。

每一块需要保存当前答案和方向，可以用二维数组。

打表程序：

```cpp
#include <bits/stdc++.h>
//#define int long long
using namespace std;
int n,i,x,fl,y;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	freopen("table.txt","w",stdout);
	cout<<"int table[25][2]={{0,0}";
	for (i=1;i<=1e9;i++){
		if (fl==0) x=(x==1337?1:x+1);
		else x=(x==1?1337:x-1);
		if (i%7==0) fl^=1;
		else{
			y=i;
			while (y>0){
				if (y%10==7) {fl^=1;break;}
				y/=10;
			}
		}
		if (i%(int)(5e7)==0)
			cout<<",{"<<x<<","<<fl<<"}";
	}
	cout<<"};";
	return 0;
}
```
跑的很快，只用了两分钟。

把 table 数组粘贴上去，再改一下打表代码，就得到了 AC 代码。

```cpp
#include <bits/stdc++.h>
//#define int long long
using namespace std;
int len=5e7,table[25][2]={{0,0},{156,1},{548,0},{345,1},{866,1},{893,0},{892,1},{1211,0},{64,0},{892,1},{1303,0},{1056,0},{97,1},{958,0},{1278,0},{1278,0},{1278,1},{144,0},{960,0},{933,1},{934,0}};
int n,i,x,fl,y,z;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
//	freopen("table.txt","w",stdout);
//	cout<<"int table[25][2]={{0,0}";
	cin>>n;
	z=n/len;//前面有几块
	x=table[z][0];
	fl=table[z][1];
	for (i=z*len+1;i<=n;i++){
		if (fl==0) x=(x==1337?1:x+1);
		else x=(x==1?1337:x-1);
		if (i%7==0) fl^=1;
		else{
			y=i;
			while (y>0){
				if (y%10==7) {fl^=1;break;}
				y/=10;
			}
		}
//		if (i%(int)(5e7)==0)
//			cout<<",{"<<x<<","<<fl<<"}";
	}
//	cout<<"};";
	return cout<<x,0;
}
```

建议一定要吸氧。

[吸氧record](https://www.luogu.com.cn/record/77002618)/[不吸氧record](https://www.luogu.com.cn/record/77002487)

---

## 作者：TempestJueMu (赞：2)

首先，看到题目很容易能想到一个模拟代码。

```cpp
int x;
bool f(int a)//判断a中有无7
{
	while(a)
	{
		if(a%10==7)return 1;
		a/=10;
	}
	return 0;
}
int main()
{
	scanf("%d",&x);
	int now=0,k=1;
	for(int i=1;i<=x;++i)
	{
		now+=k;
		if(now==0)now=1337;
		if(now==1338)now=1;
		if(i%7==0/*整除*/||f(i)/*含7*/)k=-k;
	}
	printf("%d",now);
	return 0;
}
```
提交后 TLE 了 $4$ 个点，考虑优化。

- 用一个变量记录 $\bmod\ 7$ 的结果，避免每次循环都 $\bmod$ 一次。（据说 `%` 很慢）

- 用类似高精度的思想，用一个数组记录当前数的每一位数，并用一个变量记录含 $7$ 的个数，可避免每一次都将当前数字分解。

```cpp
int x,Num_7;//Num_7即当前数中含7的个数
int num[11]={0,1};//高精…？
void Update()//当前数+1
{
	num[1]++;
	if(num[1]==8)Num_7--;//由7变为8，少了一个7
	if(num[1]==7)Num_7++;//多了一个7
	int k=1;
	while(num[k]>9)//处理进位
	{
		num[k]-=10,num[k+1]++;
		k++;
		if(num[k]==8)Num_7--;//同上
		if(num[k]==7)Num_7++;
	}
}
int main()
{
	scanf("%d",&x);
	int now=0,k=1;
	for(int i=1,M=1;i<=x;++i,++M,Update())
	{
		now+=k;
		if(M==7)M=0;
		if(now==0)now=1337;
		if(now==1338)now=1;
		if(!M/*整除*/||Num_7/*含7*/)k=-k;
	}
	printf("%d",now);
	return 0;
}
```
但还是 T 了 $1$ 个点。

考虑分段，把 $10^8 \sim 10^9$ 的答案分为 $10$ 段，每段分开求解。

根据上面的代码，通过~~熟练地~~打表可以打出来。

```cpp
int fx[]={1,1,-1,-1,1,1,-1,1,-1,1};//方向
int biao[]={0,548,866,892,64,1303,97,1278,1278,960};//编号
```
### AC代码：
```cpp
int x,Num_7;
int num[11];
void insert(int x)
{
	while(x)
	{
		num[++num[0]]=x%10;
		if(num[num[0]]==7)Num_7++;
		x/=10;
	}
}
void Update()
{
	num[1]++;
	if(num[1]==8)Num_7--;
	if(num[1]==7)Num_7++;
	int k=1;
	while(num[k]>9)
	{
		num[k]-=10,num[k+1]++;
		k++;
		if(num[k]==8)Num_7--;
		if(num[k]==7)Num_7++;
	}
}
int fx[]={1,1,-1,-1,1,1,-1,1,-1,1};//方向
int biao[]={0,548,866,892,64,1303,97,1278,1278,960};//编号
int main()
{
	scanf("%d",&x);
	int s=x/100000000,start=s*100000000+1;//分段
	int now=biao[s],k=fx[s];
	insert(start);//把start存入num数组里，Num_7初始化
	for(int i=start,M=start%7;i<=x;++i,++M,Update())
	{
		now+=k;
		if(M==7)M=0;
		if(now==0)now=1337;
		if(now==1338)now=1;
		if(!M||Num_7)k=-k;
	}
	printf("%d",now);
	return 0;
}
```

---

## 作者：SegTree (赞：1)

[题目传送门。](https://www.luogu.com.cn/problem/P1662)

## 题目分析

由于数据范围是 $10^9$，而且直接模拟 $10^6$ 不会超时，也不会超过表长。

所以表的第 $i$ 项表示 $1\sim 10^6\times i$ 次的报数人编号和方向。（用 $1$ 表示从 $1$ 到 $1337$ 的方向，用 $-1$ 表示相反的方向。）剩余区域直接暴力即可。

## 打表程序
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1337;
//判断是否要“反”一下
bool check(int a){
    if(a%7==0)return true;
    while(a){
        if(a%10==7)return true;
        a/=10;
    }
    return false;
}
signed main(){
    int x=1e9,flag=1,s=0;
    cout<<"{{0,0}";
    for(int i=1;i<=x;++i){
        s+=flag;//如果是 1 就正着，否则就反过来
        if(s==0)s=maxn;
        if(s==maxn+1)s=1;//边界情况，需要对 maxn 取余
        if(check(i))flag*=-1;//把方向反过来，正着变成倒着，倒着变成正着
        if(i%1000000==0)printf(",{%d,%d}",s,flag);//输出 1e6 时的报数者和方向
    }
    printf("}");
    return 0;
}
```

## 最终程序

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1337;
const int a[][2]={};
bool check(int a){
    if(a%7==0)return true;
    while(a){
        if(a%10==7)return true;
        a/=10;
    }
    return false;
}
signed main(){
    int x,flag=1,s=0;
    scanf("%d",&x);
    if(x>=1000000)flag=a[x/1000000][1],s=a[x/1000000][0];
    for(int i=x/1000000*1000000+1;i<=x;++i){
        s+=flag;
        if(s==0)s=maxn;
        if(s==maxn+1)s=1;
        if(check(i))flag*=-1;
    }
    printf("%d\n",s);
    return 0;
}
```

代码过长，请去[这里](https://www.luogu.com.cn/paste/6vmbb87g)看打出来的表。

---

## 作者：the___ (赞：1)

# 读题
看到数据范围 $10^9$ 果断想到分块打表（毕竟数论啥的也想不出来）。
# 思路
首先，$10^6$ 范围以内肯定能过，所以考虑每 $10^6$ 打一个表，存上已到第几个人，正向那个方向报数，再继续求即可。

具体思路：
1. 从 $1$ 到 $n$ 循环报数。更改号数。
2. 若当前序号为 $7$ 的倍数（模 $7$ 为 $0$）或任一位为 $7$（循环判断，若不为 $0$ 则判断其模 $10$ 是否为 $7$，不为 $7$ 则除以 $10$，继续判断），则反转方向。
# 代码
奉上打表代码
```cpp
#include<iostream>
using namespace std;
int pd(int i){                                //判断是否改变方向
    if(i%7==0)
        return 1;
    while(i){
        if(i%10==7)
            return 1;
        else
            i/=10;
    }
    return 0;
}
int main(){
    int x=0,f=1;
    for(int i=1;i<=1000000000;i++){
        x+=f;
        if(x==1338)                               //特殊情况判断
        x=1;
        if(x==0)
            x=1337;
        if(pd(i)){
            if(f==1)
                f=-1;
            else
                f=1;
        }
        if(i%1000000==0)
            cout<<','<<x<<','<<f;                    //便于搬表
    }
    return 0; 
}
```
奉上通过代码
```cpp
#include<iostream>
using namespace std;
int pd(int i){
    if(i%7==0)
        return 1;
    while(i){
        if(i%10==7)
            return 1;
        else
            i/=10;
    }
    return 0;
}
int main(){
    int n,x,f,a[1010][2]={0,1,……}
    cin>>n;
    x=a[n/1000000][0];
    f=a[n/1000000][1];
    for(int i=n-n%1000000+1;i<=n;i++){
        x+=f;
        if(x==1338)
            x=1;
        if(x==0)
            x=1337;
        if(pd(i)){
            if(f==1)
                f=-1;
            else
                f=1;
        }
    }
    cout<<x;
    return 0;
}
```
若有疏漏、不详之处，恳请大佬指点。

---


# 正方形

## 题目描述

有 $n$ 个大小不一的正方形，现将它们依次以 $45$ 度斜放入第一象限，每个正方形都要与 $x$ 轴有一个交点，且不能与之前放入的正方形重叠。在此前提下，正方形与 $x$ 轴交点的坐标应尽可能小。问这样放置后，从上往下看，至少能部分被看见的正方形有哪些？

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/flwonnba.png)

### 数据范围及约定

- 对于 $50\%$ 的数据，$n \le 10$；
- 对于 $100\%$ 的数据，$n \le 50$ 正方形的大小不超过 $30$。


## 样例 #1

### 输入

```
4 
3 5 1 4 
3 
2 1 2 
0 ```

### 输出

```
1 2 4 
1 3```

# 题解

## 作者：jzzcjb (赞：17)

今天把这道题刚过去了，写篇题解纪念一下。

发现因为数据水，所以有些并没有考虑全情况的代码也AC了。

我的方法比较容易懂。写一篇自认为正确的题解，有错轻喷。

# Step 0

先看懂题意，题目中的**从上往下看**是指把纸竖过来，从$y$轴正方向的位置往下看，所有的正方形都变成了一段段线段，其中有多少个正方形（变成的线段）能被看到。原来的这4个正方形从上面看是这样的，

![](https://cdn.luogu.com.cn/upload/pic/33892.png ) 

对齐之后

![](https://cdn.luogu.com.cn/upload/pic/33891.png )

黄色的那一小段 $1$ 就被左边的 $5$ 和右边的 $4$ 盖住了，所以输出 $1,2,4$ 。

**依次** 就是不能越过上一个正方形。就像样例中的 $3$ 没有插到 $1$,$2$ 中间的空的意思。这意味着，**一旦给定每个正方形的边长，那么它们的放置情况就是一定的了**。

这给了我们思路，可以依次把这 $n$ 个矩形都放置好，再计算那些能被看到，那些不能被看到。

# Step 1
计算每个正方形应该被放到哪。

首先转化一下：
- 正方形能不能被看到与整张图的大小无关。是指把所有正方形的边长全部扩大或缩小相同的倍数不会改变它们互相之间的遮盖关系

- 因为要旋转 $45^{\circ}$ 边长乘除 $\sqrt{2}$ 不方便，还会有精度问题

所以不妨重新定义每个正方形对角线的长度为“边长”，并且以相同的刻度对 $x$ 轴的刻度进行重置。就像这样![](https://cdn.luogu.com.cn/upload/pic/33889.png )

回到我们的要求：看看两个正方形相邻都有哪些形态
![](https://cdn.luogu.com.cn/upload/pic/33890.png )

不难发现，两个正方形相邻的时候，只要让其中比较小的那个有一个“落脚点”即可。也就是说，只要它们之间的距离等于两者边长的较小值即可。

所以得出递推式 

$$pos_i=pos_{i-1}+\min(a_i,a_{i-1})$$

这样就结束了吗？考虑这样一种情况

![](https://cdn.luogu.com.cn/upload/pic/33893.png )

如果按上面的公式计算，就变成了

![](https://cdn.luogu.com.cn/upload/pic/33894.png )

显然不对。所以，我们还要满足对于之前所有的正方形，都能让它满足存在“落脚点”，即

$$pos_i=\max_{j=1}^{i-1} \{ pos_j+\min(a_i,a_j) \}$$

这样，就求了每个正方形的位置。
# Step 2
计算正方形覆盖

根据对于边长的重新定义，很容易能写出一个正方形的左右两个顶点的位置 $pos_i+\frac{a_i}{2}$ 和 $pos_i-\frac{a_i}{2}$。

最简单的想法是如果它左边的正方形完全覆盖它，或者它右边的正方形完全覆盖它，或者两边一边覆盖一半，那么它就不会被看见了。
$$pos_{i-1}+\frac{a_{i-1}}{2}>pos_i+\frac{a_i}{2}$$
$$pos_{i+1}-\frac{a_{i+1}}{2}<pos_i-\frac{a_i}{2}$$
$$pos_{i-1}+\frac{a_{i-1}}{2}>pos_{i+1}-\frac{a_{i+1}}{2}$$

但是，有这样一种情况。

![](https://cdn.luogu.com.cn/upload/pic/33895.png )

$3$ 同样被挡住了，但不是被它左边的挡住的，而是被左边的左边挡住了，所以对于一个正方形我们要求出他右边所有正方形中最靠左的左端点和左边所有正方形中最靠右的右顶点。
$$L_i=\min_{j=i+1}^{n} \{ pos_j-\frac{a_j}{2}\}$$
$$R_i=\max_{j=1}^{i-1} \{ pos_j+\frac{a_j}{2}\}$$

如果两个端点接触了，则证明这个正方形被覆盖了。

$L_i$要与 $pos_i+\frac{a_i}{2}$  取 $\min$ , $R_i$要与 $pos_i-\frac{a_i}{2}$ 取 $\max$。因为即使没有接上另一头，被一边单独覆盖也是不行的。

这样就结束了吗？再看一个反例

![](https://cdn.luogu.com.cn/upload/pic/33896.png )

这里$L_2$ $R_2$很显然已经接触了，但还是能看到 $2$ 。因为 $3$ 在 $2$ 的下面，所以即使 $3$ 接触了 $2$ 的右警戒线，但还是对 $2$ 造不成威胁。所以计算 $L $ 和 $R$ 时要忽略那些比 $i$ 矮的，也就是边长小与 $i$ 的正方形。

还有注意 $L $ 和 $R$ 的初始化，一个要赋成极大值，一个要赋成极小值，不能赋成 $0$ 。因为有可能某个正方形的左顶点会变为负数，这样就影响了它左边的某些正方形。

这样，这道题就被完美解决了，细节比较多，但代码很简单。

**代码：**
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,a[101],p[101],R[101],L[101];//p -> pos 
int main(){
    while(cin>>n&&n){
        memset(p,0,sizeof(p));
        memset(a,0,sizeof(a));
        memset(L,0x3f,sizeof(L));
        memset(R,0xcf,sizeof(R));
        for(int i=1;i<=n;i++){
            cin>>a[i];a[i]*=2;//后面有/2操作，这里要*2以逃避double 
            for(int j=1;j<i;j++)
            p[i]=max(p[i],p[j]+min(a[j],a[i]));
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<i;j++)if(a[j]>a[i])
            R[i]=max(R[i],p[j]+a[j]/2);
            R[i]=max(R[i],p[i]-a[i]/2);
        }
        for(int i=1;i<=n;i++){
            for(int j=i+1;j<=n;j++)if(a[j]>a[i])
            L[i]=min(L[i],p[j]-a[j]/2);
            L[i]=min(L[i],p[i]+a[i]/2);
        }
        for(int i=1;i<=n;i++) 
            if(R[i]<L[i]) cout<<i<<" "; 
        puts("");
    }
}  
```
另外再附上刚才举反例的数据
```
3
7 3 1

1 2
```








---

## 作者：kkksc03 (赞：15)

繁琐的模拟，但对时间复杂度的要求基本没有。

每个新的正方形放入只会有如下情况：左下边与已放入的正方形的右上边重合；左上边与已放入的正方形的右下边重合；最左边与y轴相交；依次枚举，并判断与其它正方形的相交情况，最后取满足要求的最小值作为其x轴坐标。然后再判断每个正方形是否露出，最后打出。


---

## 作者：Hoks (赞：2)

## 前言
题目[传送门](https://www.luogu.com.cn/problem/P1761)

[个人博客内食用应该不会更佳](https://www.luogu.com.cn/blog/Hok/p1761-xie-ti-bao-gao)

在杭州和[大佬廖子阳](https://www.luogu.com.cn/user/539211)一起集训捏，上课练习题喵。
## 题意
从前到后**按顺序**放置正方形，求有多少正方形露出。
## 思路分析
首先因为露出的地方可以看做一条直线，也就是正方形上的点映射到数轴上，自然而然的就会想到去求 $x$ 轴点坐标，接着便会想到对角线长度，但是我们会发现，对角线长度是正方形边长的 $\sqrt{2}$ 倍，如果暴力算则会有精度误差，这时我们就可以将所有的正方形边长全部看成斜边长，就可以避免精度误差。

------------

然后计算每个正方形与 $x$ 轴交点，首先考虑两个正方形相邻时：

![](https://cdn.luogu.com.cn/upload/image_hosting/38v9w37j.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/6fgwt0ji.png)

发现第 $i+1$ 个正方形的交点 $pos_{i+1}$ 即为 $pos_i+\min(a_i,a_{i+1})$。

------------

考虑特殊情况：不相邻的正方形会互相影响吗？

![](https://cdn.luogu.com.cn/upload/image_hosting/yydo5dnl.png)

在这种情况下我们发现影响第 $i+1$ 个正方形的不仅有第 $i$ 个正方形，还有他之前的所有正方形，所以 $pos_{i+1}=\max(pos_{i+1},pos_j+\min(a_j,a_{i+1}))$。 这一段的代码也就如下：

```cpp
for(int i=1;i<=n;i++) 
    for(int j=1;j<i;j++) 
        pos[i]=max(pos[i],pos[j]+min(a[j],a[i]));
```

------------

接着我们考虑怎样的正方形才是能被看见的。（懒得画图就用前面的图了）

![](https://cdn.luogu.com.cn/upload/image_hosting/yydo5dnl.png)

我们会发现，每个正方形都有一个最左的左端点和最右的右端点，只要目前正方形的左边的正方形的右端点小于右边的左端点即可。

这里有一点是需要注意的，只需统计边长大于目前正方形的即可，因为如果边长更小的正方形本身已经在这个正方形下面了，根本不可能遮挡。

以及统计左右端点的时候不要忘记算上这个正方形。

```cpp
for(int i=1;i<=n;i++)
{
    int l=pos[i]+a[i]/2,r=pos[i]-a[i]/2;
    for(int j=1;j<i;j++) if(a[j]>a[i]) r=max(r,pos[j]+a[j]/2);
    for(int j=i+1;j<=n;j++) if(a[j]>a[i]) l=min(l,pos[j]-a[j]/2);
    if(r<l) ans[++tot]=i;
}
for(int i=1;i<=tot;i++) cout<<ans[i]<<" ";
```
## AC 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,tot;
int a[55],pos[55];
int ans[55];
int read()
{
    char c=getchar();int x=0;
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
    return x;
}
signed main()
{
    while(n=read())
    {
        if(n==0) break;
        tot=0;memset(pos,0,sizeof pos);
        for(int i=1;i<=n;i++) a[i]=read()*2;
        for(int i=1;i<=n;i++) for(int j=1;j<i;j++) pos[i]=max(pos[i],pos[j]+min(a[j],a[i]));
        for(int i=1;i<=n;i++)
        {
	        int l=pos[i]+a[i]/2,r=pos[i]-a[i]/2;
	        for(int j=1;j<i;j++) if(a[j]>a[i]) r=max(r,pos[j]+a[j]/2);
	        for(int j=i+1;j<=n;j++) if(a[j]>a[i]) l=min(l,pos[j]-a[j]/2);
	        if(r<l) ans[++tot]=i;
        }
        for(int i=1;i<=tot;i++) cout<<ans[i]<<" ";
    }
    return 0;
}
```
完结撒花喵！

---

## 作者：superLouis (赞：1)

## P1761 正方形 题解
这是我的第一篇题解，请多关照。  
~~听说 CSP 前多写题解会 RP++ 呢~~（已经 CSP 后了）

----------
update：2024.10.24 将特定的、约定俗成的函数名称修改成了正体。

update：2024.10.26 更改日期（CSP 后）。

update：2024.10.27 将无穷大和无穷小改成了 `\infty` 和 `-\infty`。

update：2024.10.30 将除数学公式的标点更改成了中文全角标点。

update：2024.11.04 非数学公式（一般英文单词、题目名、算法名、人名等）没有再使用 LaTeX。

----------
#### 1. 思路分析
注意到题目中的正方形都是旋转 $45°$ 后的，计算此时正方形与 $x$ 轴交点的坐标并不简单，还带着无理数 $\sqrt{2}$，非常不方便。由此，我们可以引入一个我自定义的词汇：“斜边长”。

我们再把输入给定的正方形边长想象成它的“斜边长”，我们的坐标的单位长度也就按照“斜边长”更改为 $\sqrt{2}$ 啦。

例如：![](https://cdn.luogu.com.cn/upload/image_hosting/ovuq8thi.png?x-oss-process=image/resize,m_lfit,h_300,w_500)

这里的边长就是我们的“斜边长”。


好了，烦人的 $\sqrt{2}$ 由此被我们解决掉了。不要忘了我们定义“斜边长”的目的是什么：计算此时正方形与 $x$ 轴的交点。

显然，稍作观察即可发现，每个正方形的坐标都跟它左边相邻的正方形有直接的关系。

给出递推公式：
$$
pos[i] = pos[i - 1] + \min(a[i], a[i - 1])。
$$

但，只跟它左边的正方形有关系吗？并不是的。还是样例给的好：

![](https://cdn.luogu.com.cn/upload/image_hosting/flwonnba.png)
$S_4$ 正方形的坐标如果只看 $S_3$ 的话，$|b_4 - b_3|$ 将与 $|b_3 - b_2|$ 相等，显然不合题意。问题出现在了 $S_2$ 身上。稍加分析即可发现，每个正方形的坐标都跟它左边**所有**的正方形有直接的关系。

给出递推公式：
$$
pos[i] = \max_{j = 1}^{i - 1} \{pos[j] + \min(a[i], a[j])\}
$$

再构造几组数据，加以验证这是正确的。

坐标都求完了，应当去判断哪些正方形会被其它正方形覆盖掉了。

有了上面的经验，就知道不能再只看左边相邻的和右边相邻的了，需要看左边**所有**的和右边**所有**的。

每个正方形都有一个最左和最右的端点，也就是 $pos[i] - \frac{a[i]}{2}$ 和 $pos[i] + \frac{a[i]}{2}$。

我们记 $left_i$ 为第 $i$ 个正方形右侧“斜边长”比它长的正方形中左端点最靠左的下标。同理，记 $right_i$ 为第 $i$ 个正方形左侧“斜边长”比它长的正方形中右端点最靠右的下标。

我们只需要判断 $right_i$ 是否大于等于 $left_i$ 即可。如果是的话，则输出 $i$ 即可（注意：$left_
i$ 初始化为 $\infty$，$right_i$ 初始化为 $-\infty$）。

但是，我们需要再细心一点：如果没有找到合适的正方形使得 $left_i$ 与 $right_i$ 更新呢？换句话说，$left_i$ 与 $right_i$ 如果还是 $\infty$ 与 $-\infty$ 呢？其实，我们最后还需要走两步：

+ 把 $left_i$ 和  $pos[i] + \frac{a[i]}{2}$ 取 $\min$。
+ 把 $right_i$ 和  $pos[i] - \frac{a[i]}{2}$ 取 $\max$。

这样我们就能放心的写代码了！

#### 2. 代码实现
相信我在上述的讲解中已经很明确地给出了代码细节了。~~自认为码风良好。~~

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 60;
const double inf = 1e5;
int n, a[maxn], pos[maxn];
double div(int x) {
	if (x & 1) return (x >> 1) + 0.5;
	return x >> 1;
}
bool check(int x) {
	double l = inf, r = -inf;
	for (int i = 1; i < x; i++) {
		if (a[i] < a[x]) continue;
		r = max(r, (double) pos[i] + div(a[i]));
	}
	for (int i = x + 1; i <= n; i++) {
		if (a[i] < a[x]) continue;
		l = min(l, (double) pos[i] - div(a[i]));
	}
	r = max(r, (double) pos[x] - div(a[x]));
	l = min(l, (double) pos[x] + div(a[x]));
	if (r >= l) return false;
	return true;
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	while (cin >> n && n) {
		memset(pos, 0, sizeof(pos));
		for (int i = 1; i <= n; i++) {
			cin >> a[i];
			if (i == 1) pos[i] = (a[i] + 1) >> 1;
			else for (int j = 1; j < i; j++)
				pos[i] = max(pos[i], pos[j] + min(a[i], a[j]));
		}
		for (int i = 1; i <= n; i++) 
			if (check(i)) cout << i << " ";
		cout << "\n";
	}
	return 0;
}
```

[测评记录戳我](https://www.luogu.com.cn/record/183960396)

----------
这是本蒟蒻的第一篇题解，可能问题有点多，请管理员通过。（QwQ）

---

## 作者：One_JuRuo (赞：1)

# 思路

### 第零步：规避精度问题

发现该题中正方形的放置在确定各正方形的大小后是固定的，而当正方形的大小同时变化相同倍数时，也可看做整个图像变化倍数，发现对答案没有影响，又发现遮挡和对角线有密切关系，而与边长无关系，再加上对角线等于 $\sqrt{2}$ 倍边长，出现了精度问题，所以为了规避这一问题，我们可以把正方形整体放大 $\sqrt 2$ 倍，即对角线看做边长长度的 $2$ 倍。

同时，我们发现后续操作应该与对角线长度的 $\frac 1 2$ 有关，所以我们放大 $\sqrt 2$ 倍，而非缩小 $\sqrt 2$ 倍，以避免出现小数，下文用 $a_i$ 代表对角线长度。

### 第一步：确定正方形位置

因为要确定当前正方形的位置时，前一个正方形一定已经确定了位置，那么我们可以根据前面已确定的位置来确定下一个，为了方便储存，我们用正方形的中心位置来代表一个正方形的位置。

我们可以先手玩找找规律，如下图（红线代表正方形的中心水平距离）。

![](https://cdn.luogu.com.cn/upload/image_hosting/rstvd1vh.png)

我们可以发现，中心水平距离就是两正方形中对角线长度较小者的对角线长度。

证明也挺好证的，先考虑新正方形较小的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/xbzr9coe.png)

因为是 $45°$ 放置的，所以可以得知图中红色线段和绿色线段都应该是 $\frac 1 2$ 倍的对角线长度，而两者之和就是中心水平距离。

再考虑新正方形较大的情况，其实就是把两者反转一下，与上面一种情况一样。

但是需要注意的是，我们目前只考虑前面一个正方形对新正方形的影响，如果前面还有特别大的正方形呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/lwdcmxtx.png)

所以我们需要考虑所有已放置的正方形，取所有算出来的中心的最大值。

```cpp
for(int i=1;i<=n;++i)
	for(int j=1;j<i;++j)
		p[i]=max(p[i],p[j]+min(a[j],a[i]));
```

### 第三步：确定是否被覆盖

一个正方形什么时候被覆盖？

设第 $i$ 个正方形左边的正方形最长的延伸长度为 $l_i$，右边的正方形最长的延伸长度为 $r_i$。

一共 $3$ 种情况会导致这个正方形被覆盖。

- $l_i$ 大于等于该正方形最右边的位置，即 $l_i \geq p_i+\frac{a_i}{2}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/fl00vivj.png)

- $r_i$ 小于等于该正方形最左边的位置，即 $r_i \leq p_i-\frac{a_i}{2}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/4tnzopcg.png)

- $l_i\geq r_i$。

![](https://cdn.luogu.com.cn/upload/image_hosting/b0fpdvlv.png)

但是需要注意的是，如果正方形的对角线长度小于该正方形，则不应该用来算 $l_i,r_i$。

因为所有的正方形的下面那个顶点都是放在 $x$ 轴上的，所以对角线长度越大，那这个正方形的高度就越高，如果另一个正方形对角线长度小，那么就会在该正方形的下面，不会遮住该正方形。

如下图，左边的正方形不会对右边的正方形的 $l_i$ 做出贡献。

![](https://cdn.luogu.com.cn/upload/image_hosting/u7oj6wal.png)

另外，我们可以把三种情况合并在一起，只需要最后进行 $l_i=max(l_i,p_i-\frac{a_i}{2}),r_i=min(r_i,p_i+\frac{a_i}{2})$，就可以三种情况一起判断了。

```cpp
for(int i=1;i<=n;++i)
{
	for(int j=1;j<i;++j) if(a[j]>a[i]) r[i]=max(r[i],p[j]+a[j]/2);
	r[i]=max(r[i],p[i]-a[i]/2);
}
for(int i=1;i<=n;++i)
{
	for(int j=i+1;j<=n;++j) if(a[j]>a[i]) l[i]=min(l[i],p[j]-a[j]/2);
	l[i]=min(l[i],p[i]+a[i]/2);
}
```

# AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[105],p[105],r[105],l[105];
int main()
{
	while(~scanf("%d",&n)&&n)
	{
		memset(p,0,sizeof(p)),memset(l,0x3f,sizeof(l)),memset(r,0x8f,sizeof(r));
		for(int i=1;i<=n;++i)
		{
			scanf("%d",&a[i]),a[i]*=2;
			for(int j=1;j<i;++j) p[i]=max(p[i],p[j]+min(a[j],a[i]));
		}
		for(int i=1;i<=n;++i)
		{
			for(int j=1;j<i;++j) if(a[j]>a[i]) r[i]=max(r[i],p[j]+a[j]/2);
			r[i]=max(r[i],p[i]-a[i]/2);
		}
		for(int i=1;i<=n;++i)
		{
			for(int j=i+1;j<=n;++j) if(a[j]>a[i]) l[i]=min(l[i],p[j]-a[j]/2);
			l[i]=min(l[i],p[i]+a[i]/2);
		}
		for(int i=1;i<=n;++i) if(r[i]<l[i]) printf("%d ",i);
		puts("");
	}
	return 0;
}
```

---

## 作者：123456zmy (赞：1)

刚才~~水~~过了这道题，写篇题解

------------
确定正方形位置的方法就不详细说了，另外几位大佬的题解已经说得很清楚了，这里主要说一下求可见的正方形的方法

------------
我们可以用一个数组来存每格能看到的正方形。大的正方形会在比它小的正方形上方，于是我们就可以把所有正方形按照大小排序，然后从小到大把每个正方形能覆盖的地方赋值为它的编号，最后统计哪些编号在最后的数组中出现过，代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a1[3501];
bool ans[51];
struct abc{int a,x,i;}a[51];
bool cmp(abc i,abc j){return i.a<j.a;}
int main()
{
	scanf("%d",&n);
	while(n)
	{
		memset(a,0,sizeof(a));
		memset(a1,0,sizeof(a1));
		memset(ans,0,sizeof(ans));
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&a[i].a);
			a[i].i=i;
			a[i].x=a[i].a;
		}
		for(int i=2;i<=n;i++)for(int j=1;j<i;j++)a[i].x=max(a[i].x,a[j].x+(min(a[j].a,a[i].a)<<1));
		sort(a+1,a+n+1,cmp);
		for(int i=1;i<=n;i++)for(int j=a[i].x-a[i].a;j<=a[i].x+a[i].a;j++)a1[j]=a[i].i;
		for(int i=0;a1[i];i++)ans[a1[i]]=1;
		for(int i=1;i<=n;i++)if(ans[i])printf("%d ",i);
		putchar(10);
		scanf("%d",&n);
	}
	return 0;
}
```
相信绝对有人这样就交了上去，然而...WA了4个点。

我们看一下下面的一个数据
```
3
3 2 4
0

```
正确答案是
```
1 2 3

```
输出却是
```
1 3
```
问题就出在数组代表的信息上，上面的写法中，每个数据代表一个整点，这样就会导致只要遮住一个单位线段的两端就相当于遮住了这整条线段。

改正方法也很简单，只要让每个数据表示一条单位线段就行了，在代码中就只要改一下循环范围就行了，交上去就AC了
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a1[3501];
bool ans[51];
struct abc{int a,x,i;}a[51];
bool cmp(abc i,abc j){return i.a<j.a;}
int main()
{
	scanf("%d",&n);
	while(n)
	{
		memset(a,0,sizeof(a));
		memset(a1,0,sizeof(a1));
		memset(ans,0,sizeof(ans));
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&a[i].a);
			a[i].i=i;//编号
			a[i].x=a[i].a;
		}
		for(int i=2;i<=n;i++)for(int j=1;j<i;j++)a[i].x=max(a[i].x,a[j].x+(min(a[j].a,a[i].a)<<1));
		//求位置
		sort(a+1,a+n+1,cmp);//排序
		for(int i=1;i<=n;i++)for(int j=a[i].x-a[i].a;j<a[i].x+a[i].a;j++)a1[j]=a[i].i;
		//覆盖
		for(int i=0;a1[i];i++)ans[a1[i]]=1;//统计答案
		for(int i=1;i<=n;i++)if(ans[i])printf("%d ",i);
		putchar(10);
		scanf("%d",&n);
	}
	return 0;
}
```
代码风格——极简...希望大家看得懂。

---

## 作者：Tracy_Loght (赞：0)

接下来是计算几何代师登场的时间！

## 描述：

**题目**：给定多组数据，每次要求一个串上的数所构成的**正方形**，经过一种放置的方案，使得最终，从 $x$ 轴正上方无穷的位置，可以看到多少个正方形。

显而易见，这是一道对于平面直角坐标系上覆盖的问题。

## 题目分析：

充分理解题目的人直接跳到后一节。

先分析现有条件：

- 每个正方形边长已知，单条边的斜率已知；

- 对于每组数据中正方形个数较小，猜测最多数据不超过 $10^4$；

于是，猜测这便是一道可能码量大但是好写的模拟题。

## 加入正方形：

下列所有的图和语言皆以输入数可以为小数前提之下（没有影响）。

正如题目所述，这是判断新加入一个正方形在末尾的影响。

图片不算多，挂了记得叫我。

![](https://cdn.luogu.com.cn/upload/image_hosting/wqs0q8vx.png)

对于现在这种情况，由于斜率的问题，当最后一个正方形边长为 $a$，一个顶点落在 $x$ 轴的 $b$ 点上。

易得，对于新加入的边小于等于 $\frac{a}{2\sqrt{2}}$ 时一定不可能计入最终答案。

---

![https://cdn.luogu.com.cn/upload/image_hosting/qxob1t6c.png](https://cdn.luogu.com.cn/upload/image_hosting/qxob1t6c.png)

对于新加入的边小于 $a$ 时，当前这个正方形有一块么有被遮挡，有一块被遮挡了。

而且，这种情况下有一个特殊含义，及这个正方形一定不会对以前的正方形造成遮挡关系。

---

然后是最麻烦的一个了，大于等于 $a$ 的情况，也算简单，它与 $x$ 轴的交点一定是 $2a^2+b$。

而且它**暂时**一定可以被计算进答案内（除了更前面遮挡的情况）。

然后往前面查找被它遮挡的，注意判重。

给个赞再走吧！

---

## 作者：66666a (赞：0)

并不麻烦的模拟。。。。

只有3个数有用

左端点l  右端点r  与x轴交点x

x-l=r-x

不妨把边长直接作为x-l   r-x

然后每次放在靠近x,y轴的地方 再向右移动

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ri register int
#define rl register ll
#define INF 0x3f3f3f
using namespace std;
template<class T>
void read(T &x)
{
    x=0;int f=0;char ch=getchar();
    while(ch<'0'||ch>'9')  {f|=(ch=='-');ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    x=f?-x:x;
    return;
}
int buf[30];
void print(int x)
{
    if (x<0) putchar('-'),x=-x;
    buf[0]=0;
    while (x) buf[++buf[0]]=x%10,x/=10;
    if (!buf[0]) buf[0]=1,buf[1]=0;
    while (buf[0]) putchar('0'+buf[buf[0]--]);
}
int m,a,b,c,d,ans;
struct self{int x,y,l,r;} s[55]; 
void findcover()
{
    int a,b;double l,r;
    bool cover[55]={0};
    for(a=1;a<=m;a++)
    {
        l=0;r=999999999;
        for(b=1;b<a;b++)
        if(s[b].r>l)l=s[b].r;
        for(b=a+1;b<=m;b++)
        if(s[b].l<r)r=s[b].l;
        if(l>=r||l>=s[a].r||r<=s[a].l)cover[a]=1;
    }
    for(a=1;a<=m;a++)if(!cover[a])
    {
        print(a);
        putchar(' ');
    }
    cout<<'\n';
}
int main()
{
    while(scanf("%d",&m)==1)
    {
        if(m==0)return 0;
        cin>>s[1].y;
        s[1].x=s[1].y;
        s[1].l=0;
        s[1].r=s[1].x*2;
        for(a=2;a<=m;a++)
        {
            scanf("%d",&s[a].y);
            for(b=1;b<a;b++)
            if(s[a].y>=s[b].y)s[a].x=max(s[a].x,s[b].x+s[b].y*2);
            else s[a].x=max(s[a].x,s[b].x+s[a].y*2);
            s[a].x=max(s[a].x,s[a].y);
            s[a].l=s[a].x-s[a].y;
            s[a].r=s[a].x+s[a].y;
        }
        findcover();
    }
    return 0;
}

```

---


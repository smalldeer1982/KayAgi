# 对撞机

## 题目描述

在 2312 年，宇宙中发现了 $n$ 台巨型对撞机，这些对撞机分别用 $1 \sim n$ 的自然数标识。科学家们不知道启动这些对撞机会发生什么危险事故，所以这些机器，刚开始都是出于关闭的状态。

随着科学家们的研究发现，第 $i$ 台对撞机启动是安全的，当且仅当其他已经启动的对撞机的标识数都跟这台对撞机标识数互质。（例如假设前面启动的对撞机标识数是 $j$，如果 $i$ 能启动，那么 $i,j$ 互质，即 $\gcd(i,j) = 1$）。如果两台对撞机的标识数不为互质数就启动，那么就会发生爆炸事故。

基于前面的研究，科学家们准备做各种启动和关闭对撞机的实验。为了确保科学家们的生命安全，你要设计一个远程遥控的软件。

刚开始，所有的对撞机都是关闭状态。你的程序将会收到许多询问，格式为“启动、关闭第 $i$ 台对撞机”。这个程序应该能处理这些询问（根据收到询问的先后顺序处理）。程序按照如下的格式输出处理结果。

如果询问为 `+ i`（表示启动第 $i$ 台对撞机），程序应该按照下面三种情况之一输出结果。

- `Success`，表示启动第 $i$ 台是安全的。
- `Already on`，表示第 $i$ 台在询问之前就已经启动了。
- `Conflict with j`，表示第 $i$ 台与前面已经启动的第 $j$ 台冲突。如果前面有多台对撞机跟 $i$ 冲突，那么只输出其中任何一台即可。

如果询问为 `- i`（表示关闭第 $i$ 台对撞机），程序应该按照下面两种情况之一输出结果。

- `Success`，表示关闭第 $i$ 台对撞机。
- `Already off`，表示第 $i$ 台对撞机在询问之前就已经关闭了。

## 说明/提示

**数据范围**

$1 \le n,m \le 10^5$，$1 \le i \le n$。

---

感谢 @cn：苏卿念 提供 Special Judge

## 样例 #1

### 输入

```
10 10 
+ 6
+ 10
+ 5
- 10
- 5
- 6
+ 10 
+ 3
+ 6
+ 3
```

### 输出

```
Success
Conflict with 6
Success
Already off
Success
Success
Success
Success
Conflict with 3
Already on
```

# 题解

## 作者：星小雨 (赞：15)

首先多谢 @小可爱三岁七 （是这样打吧。。）大佬的spj。。  
闲着无聊给水题写个题解= =  
所需知识：通过线性筛的预处理进行质因数分解。。  
由于线性筛中合数都是由最小能整除它的质数筛出的，所以对于所有数记录一下能整除它的最小质数，每次不断除当前数的最小整除质数就能做到质因数分解了。。  
然后就进入正题吧。  
关于这道题，要判断当前这台对撞器已经开启或关闭——这个简单，只需要一个标记数组储存一下当前对撞器的开/关状态。  
若要开启对撞器，还需判断当前对撞器是否与先前的对撞器是否互质——这个也好办，两个数互质即它们无相同质因数，我们只需要标记每个数的所有质因数一下即可。  
这方面的具体实现就是：  
然后每开启一台对撞器，就先检查所有质因数有没有被标记，若有则产生冲突，否则就标记其所有质因子。  
关闭对撞器也大致一样，将所有质因子的标记清空即可。  
时间效率为$O(n \text{log} n)$（设$n,m$同阶），代码也很好写，不失为一道线性筛的入门题，写了这道题能对线性筛能筛的东西有更好的理解。。  
代码如下：
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int p[10005],q[100005],k[10005];
bool b[100005];
int main(){
    int n,m,a,x,t=0;char s[3];scanf("%d%d",&n,&m);
    for(int i=2;i<=n;++i){
        if(!b[i]) p[++t]=i,q[i]=t;
        for(int j=1;j<=t && (a=p[j]*i)<=n;++j){
            b[a]=1,q[a]=j;
            if(!(i%p[j])) break;
        }
    }
    memset(b,0,sizeof b);
    while(m--){
        scanf(" %s%d",s,&a);x=a;
        if(s[0]==43){
            if(b[a]){puts("Already on");continue;}
            while(x>1){if(k[q[x]]) break;x/=p[q[x]];}
            if(x!=1){printf("Conflict with %d\n",k[q[x]]);continue;}
            b[x=a]=1;puts("Success");while(x>1){k[q[x]]=a;x/=p[q[x]];}
        }
        else {
            if(!b[a]){puts("Already off");continue;}
            b[a]=0;puts("Success");while(x>1){k[q[x]]=0;x/=p[q[x]];}
        }
    }
    return 0;
}
```

---

## 作者：ssnoipbb (赞：8)

# P1871 对撞机

~~一眼模拟，鉴定为卡常题。~~

看到题解区很多大佬都用了许多强大的做法（%%%）。

但是，既然标签里只有模拟，我们能不能只模拟硬过呢。

先试一试，直接模拟，用一个 bool 数组记录每个对撞机的状态，启动时再枚举检验即可。

这样做可以得到 $90$ 分的好成绩，时间复杂度是 $O(n^2)$。

但是数据范围是 $10^5$ 的，显然不行。

但是，我们重新思考一下，在原来的程序里有没有可以优化的地方。

这里我们在枚举的过程中，使用优化过的 binary_gcd 替换普通 $\gcd$，并使用 ```bitset``` 替换 bool 标记数组。

确实比原先快了不少，虽然时间复杂度并没有明显的改进，但可以过了。

记得注意输入输出效率（其实问题不大）。

## CODE

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<bitset>
using namespace std;
const int N=1e5+10;
int aa,bb,cc,xx;
inline static int gcd(int a,int b)
{
	aa=__builtin_ctz(a);
	bb=__builtin_ctz(b);
	cc=aa<bb?aa:bb;
	b>>=bb;
	while(a)
	{
		a>>=aa;
		xx=a-b;
		aa=__builtin_ctz(xx);
		b=a<b?a:b;
		a=xx<0?-xx:xx;
	}
	return b<<cc;
}
static bitset<N>vis;
static int a[N];
int n,m;
inline static bool mak(const int& i)
{
	for(register int j=1;j^i;++j)
	{
		if(vis[a[j]])
		{
			if(gcd(a[i],a[j])!=1)
			{
				printf("Conflict with %d\n",a[j]);
				return false;
			}
		}
	}
	return true;
}
int main()
{
	scanf("%d%d",&n,&m);
	char c=0;
	m+=1;
	for(register int i=1;i^m;++i)
	{
		while ((c = getchar()) != '-' && (c != '+'));
		scanf("%d",&a[i]);
		if(c=='+')
		{
			if(vis[a[i]])
			{
				puts("Already on");
			}
			else
			{
				if(mak(i))
				{
					vis[a[i]]=true;
					puts("Success");
				}
			}
		}
		if(c=='-')
		{
			if(!vis[a[i]])
			{
				puts("Already off");
			}
			else
			{
				vis[a[i]]=false;
				puts("Success");
			}
		}
	}
	return 0;
}
```




---

## 作者：Zvelig1205 (赞：7)

# P1871 对撞机

## 闲话

最近比较颓废 + 心烦意乱，大模拟做不下去，只好水些小模拟。

## Solution 1

直接模拟，用一个 bool 数组存对撞机的状态（开启或关闭）。

Code:

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
int re()
{
	int s=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0')
	{
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
		s=s*10+ch-48,ch=getchar();
	return s*f;
}
void wr(int s)
{
	if(s<0)putchar('-'),s=-s;
	if(s>9)wr(s/10);
	putchar(s%10+48);
}
const int inf=1e5+7;
int n,m,k;char op[10];
bool vis[inf];
vector<int>h;
int gcd(int x,int y)
{
	while(y^=x^=y^=x%=y);
	return x;
}
int pd_ct(int now)
{
	int len=h.size();
	for(int i=0;i<len;i++)
		if(gcd(now,h[i])!=1)return h[i];
	return 0;
}
int main()
{
	n=re();m=re();
	for(int i=1;i<=m;i++)
	{
		scanf("%s",op);k=re();
		if(op[0]=='+')
		{
			if(vis[k])puts("Already on");
			else
			{
				int pd=pd_ct(k);
				if(pd)printf("Conflict with %d\n",pd);
				else
				{
					puts("Success"),vis[k]=1;
					h.push_back(k);
				}
			}
		}
		if(op[0]=='-')
		{
			if(!vis[k])puts("Already off");
			else
			{
				puts("Success"),vis[k]=0;
				h.erase(find(h.begin(),h.end(),k));
			}
		}
	}
	return 0;
}
```

时间复杂度应该为 $O(n^2)$。实测 90 分，最后一个点 TLE 了。

## Solution 2

~~英语课上灵光突现~~

根据题意，如果新加入的对撞机与之前的对撞机冲突，那么这两台对撞机编号的质因数绝对有重复。

这个是显然的，可以根据样例理解。

那么就可以在 $O(n\sqrt n)$ 的时间内将所有数的质因数处理出来。

所以如果新开启的对撞机与之前的没有冲突，就将所有的质因数标记。关闭同理。

也同样用 bool 数组存状态。

Code:

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
int re()
{
	int s=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0')
	{
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
		s=s*10+ch-48,ch=getchar();
	return s*f;
}
void wr(int s)
{
	if(s<0)putchar('-'),s=-s;
	if(s>9)wr(s/10);
	putchar(s%10+48);
}
const int inf=1e5+7;
int n,m,k;char op[10];
bool vis[inf];
int bel[inf];
vector<int>hav[inf];
void fenjie(int n)
{
	int num=n;
	for(int i=2;i*i<=n;i++)
	{
		if(n%i==0)
		{
			while(n%i==0)n/=i;
			hav[num].push_back(i);
		}
	}
	if(n>1)hav[num].push_back(n);
}
int pd_ct(int now)
{
	int len=hav[now].size();
	for(int i=0;i<len;i++)
		if(bel[hav[now][i]])
			return bel[hav[now][i]];
	return 0;
}
void insert(int now)
{
	int len=hav[now].size();
	for(int i=0;i<len;i++)
		bel[hav[now][i]]=now;
}
void remove(int now)
{
	int len=hav[now].size();
	for(int i=0;i<len;i++)
		bel[hav[now][i]]=0;
}
int main()
{
	n=re();m=re();
	for(int i=1;i<=n;i++)
		fenjie(i);
	for(int i=1;i<=m;i++)
	{
		scanf("%s",op);k=re();
		if(op[0]=='+')
		{
			if(vis[k])puts("Already on");
			else
			{
				int pd=pd_ct(k);
				if(pd)printf("Conflict with %d\n",pd);
				else
				{
					puts("Success"),vis[k]=1;
					insert(k);
				}
			}
		}
		if(op[0]=='-')
		{
			if(!vis[k])puts("Already off");
			else
			{
				puts("Success"),vis[k]=0;
				remove(k);
			}
		}
	}
	return 0;
}
```

总时间复杂度为 $O(n\sqrt n+m\sqrt n)$。

如果 TLE #8 #10，那么请注意自己的分解质因数是不是打假了。

## 广告

[My Blog](https://www.cnblogs.com/adm-1223/)

---

## 作者：吾乃会虎 (赞：5)

~~似乎题主把数据改好了，那我就上题解吃螃蟹了~~	
这题本身不难，主要是判断冲突条件

冲突主要有两种：	
1.已经打开或关闭
2.和其他数冲突

冲突（1）可以直接记录是否打开，直接判断	
要解决冲突（2），首先要注意到这一点：两个数不互质，当且仅当二者有公共质因子	
所以我们要记录某一个质因子是否被占用，就可以推出冲突（2）是否存在了	

如何记录呢？	
那就是修改筛法的事啦！	
（似乎线性筛也可以，但是难得搞了）	

下面上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int open[200005];//直接记录是否打开
int prime[200005];//记录质数
int yes[200005];//记录质因子是否被占用（内容为将其占用的数）
int isit[200005];//邻接链表开头
int line[700005];//邻接链表链接
int to[700005];//邻接链表内容
void push(int a,int b){
	to[++to[0]]=b;
	line[++line[0]]=isit[a];
	isit[a]=line[0];
}//记录b|a
void start(void){
	for(int i=2;i<=200000;++i){
		if(isit[i])continue;
		prime[++prime[0]]=i;
		for(int j=1;i*j<=200000;++j)
			push(i*j,prime[0]);
	}
}//筛质数+将某个数的质因子情况用邻接链表记录
int add(int k){
	if(open[k])return -1;
	int minx=0;
	int j=isit[k];
	while(j){
		if(yes[to[j]])
			minx=max(minx,yes[to[j]]);
		j=line[j];
	}//判断是否有质因子有冲突
	if(minx>0)return minx;
	j=isit[k];
	while(j){
		yes[to[j]]=k;
		j=line[j];
	}//记录已占用
	open[k]=1;
	return 0;
}
int close(int k){
	if(!open[k])return -2;
	int j=isit[k];
	while(j){
		yes[to[j]]=0;
		j=line[j];
	}//除去占用记录
	open[k]=0;
	return 0;
}
int read(void){
	char input='\0';
	int k=0;
	while(input=getchar())
		if(input=='+'||input=='-'){
			scanf("%d",&k);
			switch(input){
				case '+':return add(k);
				case '-':return close(k);
			}
		}
	return -3;//错误代码退出
}
int main(){
	start();
	int n=0,m=0;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i){
		int ans=read();
		if(ans==-3)break;
		else if(ans==-2)printf("Already off\n");
		else if(ans==-1)printf("Already on\n");
		else if(ans==0)printf("Success\n");
		else printf("Conflict with %d\n",ans);
	}
	return 0;
}
```
我当初做的可是灰题WA，咋现在成绿题AC啦？？？（滑稽）

---

## 作者：_Spectator_ (赞：2)


[可能更好的食用体验](https://www.luogu.com.cn/blog/523641/solution-p1871)

[题目传送门](https://www.luogu.com.cn/problem/P1871)

------------
### ${\color{RoyalBlue}\colorbox {white}{样例解释}}$

```
10 10 
+ 6
+ 10
+ 5
- 10
- 5
- 6
+ 10 
+ 3
+ 6
+ 3

```
题目已经讲得很清楚了，就是每次打开的对撞机编号一定要与之前所有打开的对撞机编号互质。如第 $2$ 个询问要打开 $10$ 号对撞机，而 $10$ 与前面的 $6$ 不互质，故输出 “ Conflict with $6$ ” 。其他的也就不用我多说了。还有一点要注意，在第 $9$ 个询问中 $6$ 既与 $3$ 冲突也与 $10$ 冲突，不要被样例忽悠了，**输出任意一个都是对的**，我的程序输出就是“ Conflict with $10$ ” 。


------------

### ${\color{RoyalBlue}\colorbox {white}{主要思路}}$

既然要使每次打开的对撞机编号与之前所有都互质，也就是要使每次打开的对撞机的编号的质因数中不包含之前出现过质因数。我们可以每次将编号进行分解质因数，如果其中的质因数在之前被标记过，则不能开启。如果其中的质因数在之前都没出现过，就开启这个对撞机，并记录这些质因数。开启的代码如下：
```cpp
bool o[100005];//记录是否被开启 
bool s[100005];//记录质数
int f[100005];//记录每个质因数属于哪个数
void prime(int r)//筛选质数
{
	s[0]=true,s[1]=true;
	for(int i=2;i<=r;i++)
		if(s[i]==false)
			for(int j=i+i;j<=r;j+=i)s[j]=true;
	return;
}
int open(int x)
{
	if(o[x])return -1;//-1表示已经开启
	int t[1000],g=0;
	for(int i=1;i<=sqrt(x);i++)//分解质因数
	{
		if(x%i==0&&!s[i])//如果i是x的质因数
		{
			if(f[i]!=0)return f[i];//如果质因数已经存在，返回其所属的数
			t[++g]=i;//否则将质因数存入t数组
		}
		if(x%i==0&&i*i!=x&&!s[x/i])//同上
		{
			if(f[x/i]!=0)return f[x/i];
			t[++g]=x/i;
		}
	}
	o[x]=true;
	for(int i=1;i<=g;i++)f[t[i]]=x;//将x的质因数标记为属于x
	return 0;//0表示可以开启
}
```
关闭也很简单，分解其质因数并删除标记即可。
```cpp
int close(int x)
{
	if(!o[x])return -2;//-2表示已经关闭
	for(int i=1;i<=sqrt(x);i++)//分解质因数
		if(x%i==0)
			f[i]=0,f[x/i]=0;//删除标记
	o[x]=false;
	return 0;//0表示可以关闭
}
```
然后就在主程序中判断函数的返回值并输出即可。

------------

### ${\color{RoyalBlue}\colorbox {white}{完整代码}}$

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,p,ans;
bool o[100005];//记录是否被开启 
bool s[100005];//记录质数 
int f[100005];//记录每个质因数属于哪个数
#error\
禁止抄题解
void prime(int r)
{
	s[0]=true,s[1]=true;
	for(int i=2;i<=r;i++)
		if(s[i]==false)
			for(int j=i+i;j<=r;j+=i)s[j]=true;
	return;
}
int open(int x)
{
	if(o[x])return -1;
	int t[1000],g=0;
	for(int i=1;i<=sqrt(x);i++)
	{
		if(x%i==0&&!s[i])
		{
			if(f[i]!=0)return f[i];
			t[++g]=i;
		}
		if(x%i==0&&i*i!=x&&!s[x/i])
		{
			if(f[x/i]!=0)return f[x/i];
			t[++g]=x/i;
		}
	}
	o[x]=true;
	for(int i=1;i<=g;i++)f[t[i]]=x;
	return 0;
}
int close(int x)
{
	if(!o[x])return -2;
	for(int i=1;i<=sqrt(x);i++)
		if(x%i==0)
			f[i]=0,f[x/i]=0;
	o[x]=false;
	return 0;
}
int main()
{
	cin>>n>>m;
	prime(n);//筛选质数
	for(int i=1;i<=m;i++)
	{
		char ch;cin>>ch>>p;
		if(ch=='+')ans=open(p);
		else ans=close(p);
		switch(ans)//根据函数返回值输出结果 
		{
			case 0:cout<<"Success";break;
			case -1:cout<<"Already on";break;
			case -2:cout<<"Already off";break;
			default:cout<<"Conflict with "<<ans;break;
		}
		cout<<endl;
	}
	return 0;
}

```

**xt__温馨提示：**

**${\color{brown}\colorbox{White}{题解千万条，理解第一条。直接粘题解，棕名两行泪。}} $**

---

## 作者：Zed_ (赞：2)

### 思路:

打开的对撞机编号必须两两互质，说明对于每一个质数，它只能是 $0$ 台或 $1$ 台对撞机的质因子。所以我们可以将 $1$ 到 $n$ 每个数进行质因数分解，再开一个数组记录一个质数是那一台对撞机的质因子，按照要求判断输出即可。

### Code:

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <vector>
using namespace std;

const int E = 100000 + 11;

int n, m;
int wh[E];
vector<int> p[E];
bool vis[E];

void divide(int x) {
	int temp = x;
	for (int i = 2; i <= sqrt(x); i++) {
		if (x % i == 0) {
			p[temp].push_back(i);
			while (x % i == 0) x /= i;
		}
	}
	if (x > 1) p[temp].push_back(x);
}

int main() {
	scanf("%d%d", &n, &m);
	
	for (int i = 2; i <= n; i++) divide(i);
	memset(wh, 0, sizeof(wh));
	
	for (int i = 1; i <= m; i++) {
		char s[11]; int x;
		scanf("%s%d", s, &x);
		if (s[0] == '+') {
			if (vis[x]) {
				printf("Already on\n");
				continue;
			}
			bool flag = true;
			for (int j = 0; j < p[x].size(); j++) {
				if (wh[p[x][j]]) {	// 每一个质数只能出现在一台打开的对撞机的质因子中 
					//printf("Conflict with %d\n", p[x][j]);
					printf("Conflict with %d\n", wh[p[x][j]]);
					flag = false;
					break;
				}
			}
			if (flag) {
				vis[x] = true;
				for (int j = 0; j < p[x].size(); j++) wh[p[x][j]] = x;
				printf("Success\n");
			}
		}
		else if (s[0] == '-') {
			if (vis[x] == false) printf("Already off\n");
			else {
				vis[x] = false;
				for (int j = 0; j < p[x].size(); j++) wh[p[x][j]] = 0;
				printf("Success\n");
			}
		}
	}
	
	return 0;
}
```


---

## 作者：李至擎 (赞：1)

[点我看题](https://www.luogu.com.cn/problem/P1871)

其实，这个题还是挺简单的。但是，我发现许多dalao的思路都讲的不是太明白，让我这种蒟蒻很是头疼。于是，我决定自己来写一篇题解。

思路：这道题唯一的难点就在于判断互质。如果我们对于每一次询问都遍历所有对撞机来判断的话，显然会超时。如何优化呢？

我们可以发现，如果我们每次都这样做的话，显然是非常浪费时间的——因为重复计算了很多遍相同的结果。因此，可以考虑预处理好每个数之间是否互质，这样每次查找时就只用查询剩下的对撞机就好了。

方法：

- $1.$ 预处理因数（线性筛、朴素做法什么的都可以）；

- $2.$ 输入询问；

- $3.$ 判断并输出结果。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,vis[100005],ans,num,have[100005];
char opt;
vector<int>p[100005]; 
//vis数组表示第i台对撞机是否已经开启
//ans是如果发生冲突，与其冲突的对撞机的编号
//num和opt是输入时的记录变量，n和m如题意 
//have数组表示是否已有含有i这个因数的对撞机开启 
//p数组记录了第i台对撞机的所有因数 
inline void remove(int x)//朴素做法拆因数 
{
	int y=x;//留备份 
	for(register int i=2;i*i<=x;++i)//最基础的做法，在此不多赘述 
	{
		if(y%i==0) 
		{
			p[x].push_back(i);
			while(y%i==0)y/=i;
		}
	}
	if(y>1)p[x].push_back(y);
}
inline int check1(int x)//判断能否打开 
{
	if(vis[x])return 2;//如果已打开，返回“已经开启”  
	for(register int i=0;i<p[x].size();++i)//查询所有因数 
	{
		if(have[p[x][i]])//如果已经被使用 
		{
			ans=have[p[x][i]];//记录冲突编号 
			return 3;//返回“有冲突 ” 
		}
	}
	vis[x]=1;//打开对撞机 
	for(register int i=0;i<p[x].size();++i)//加上所有因数 
	{
		have[p[x][i]]=x;//打上编号 
	}
	return 1;//返回“可以打开 ” 
}
inline int check2(int x)//判断能否关闭 
{
	if(!vis[x])return 2;//如果已关闭，返回“已经关闭” 
	vis[x]=0;//关闭对撞机 
	for(register int i=0;i<p[x].size();++i)//去掉所有因数
	{
		have[p[x][i]]=0;
		//因为我们保证了不会冲突
		//所以含有这台对撞机的所有因数之一的对撞机一定未被开启
		//所以可以直接放心大胆的去掉 
	}
	return 1;//返回“可以关闭 ” 
}
int main()
{
	ios::sync_with_stdio(0);//让cin和scanf一样快 
	cin>>n>>m;
	for(register int i=2;i<=n;++i)
	{
		remove(i);//找出每个数的因数 
	}
	while(m--)
	{
		cin>>opt>>num;//输入一组询问 
		if(opt=='+')//如果是启动对撞机 
		{
			int ok=check1(num);//检查 
			if(ok==1)puts("Success");//可以打开 
			else if(ok==2)puts("Already on");//已经开启 
			else printf("Conflict with %d\n",ans);//有冲突 
		}
		else//如果是关闭对撞机 
		{
			int ok=check2(num);//检查 
			if(ok==1)puts("Success");//可以关闭 
			else puts("Already off");//已经关闭 
		}
	}
	return 0;//结束程序 
}
```

---

## 作者：封禁用户 (赞：1)

#### FBI warning:
提交本题解只是为了一个新思路

~~因为数据有毒~~这个代码我拼死拼活优化都差一个点~~不优化也是90~~，希望有巨佬AC了私聊发我一下成功的优化（我把我的优化都放上来了）
### 思路（非优化部分）
我们用一个数组来储存是否开启，另一个数组来储存质数点的访问情况。
#### 开机
首先判断是否开机（bool数组）

先检测每个质因子是否赋值（后面会说）赋值ze输出值

若每个质因子都未赋值，则可以开机，将每个质因子都赋值为编号（不可能有重复的情况，因为重复则无法开机）
#### 关机
先是看是否已经关机（bool数组）

可以关机就代表所有质因子都被之赋值，所以删去所有质因子的值（清0），也就是之后有这个因子的就可以开机了

这里可能讲的不是太清楚，看看代码的注解就因该知道了
### 代码实现
#### 开机（不含判断是否以经开）
```
il void add(int x)
{
	int i;
	int l=0;
	int now=x,num=x;
	if(c[now][0])//优化，如果记忆过
	{
		for(i=1;i<=c[now][0];i++)//C[now][0]代表质因子个数（没去重，这里巨佬可以试试去重防止常数大然后AC，巨佬私聊我）
		{
			if(p[c[now][i]] && c[now][i]!=1)
			{
				l=p[c[now][i]];//如果赋过值，记录
			}
		}
	}else
	{
		for(i=2;i<=num;i++)//没记忆过就开始分解质因子然后记忆,基本的求因子的方式，不懂看我博客（目前还在施工，可能要9月18号）
		{
			while(1)
			{
				if(!(num%i))
				{
					num/=i;
					c[now][0]++;
					c[now][c[now][0]]=i;//记录
					if(p[i])
					{
						l=p[i];
					}
				}else
				{
					break;
				}
			}
		}
		if(num>1)
		{
			c[now][0]++;
			c[now][c[now][0]]=num;
			if(p[num])
			{
				l=p[num];
			}
		}
	}
	if(l)//如果冲突
	{
		printf("Conflict with %d\n",l);
		return;
	}
	for(i=1;i<=c[now][0];i++)//不冲突就赋值开启
	{
		p[c[now][i]]=now;
	}
	if(x-1)
	{
		p[x]=now;
	}
	printf("Success\n");
	k[now]=1;//开机数组赋值
	return;
}
```
#### 关机
能关机的都一定开过机，所以直接在记忆数组中取消赋值

```
il void down(int x)
{
	reg int now=x;
	reg int i;
	for(i=1;i<=c[now][0];i++)//质因子查找
	{
		p[c[now][i]]=0;//关机赋值
	}
	k[now]=0;//关机
	printf("Success\n");
	return;
}
```
#### 优化
就是使用了记忆化~~还有不要脸的inline和reg~~可以在完整代码中看看
### 完整代码
```
#include "cstdio"
#define il inline
#define reg register
using namespace std;
const int N=1e5+7;
int c[N][27];
int p[N];
bool k[N];
int n,m;
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
	{
        if(ch=='-')
        {
        	f=-1;
		}
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
	{
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
il void add(int x)
{
	int i;
	int l=0;
	int now=x,num=x;
	if(c[now][0])
	{
		for(i=1;i<=c[now][0];i++)
		{
			if(p[c[now][i]] && c[now][i]!=1)
			{
				l=p[c[now][i]];
			}
		}
	}else
	{
		for(i=2;i<=num;i++)
		{
			while(1)
			{
				if(!(num%i))
				{
					num/=i;
					c[now][0]++;
					c[now][c[now][0]]=i;
					if(p[i])
					{
						l=p[i];
					}
				}else
				{
					break;
				}
			}
		}
		if(num>1)
		{
			c[now][0]++;
			c[now][c[now][0]]=num;
			if(p[num])
			{
				l=p[num];
			}
		}
	}
	if(l)
	{
		printf("Conflict with %d\n",l);
		return;
	}
	for(i=1;i<=c[now][0];i++)
	{
		p[c[now][i]]=now;
	}
	if(x-1)
	{
		p[x]=now;
	}
	printf("Success\n");
	k[now]=1;
	return;
}
il void down(int x)
{
	reg int now=x;
	reg int i;
	for(i=1;i<=c[now][0];i++)
	{
		p[c[now][i]]=0;
	}
	k[now]=0;
	printf("Success\n");
	return;
}
il void turnon(int x)
{
	if(k[x])
	{
		printf("Already on\n");
	}else
	{
		add(x);
	}
	return;
}
il void close(int x)
{
	if(!(k[x]))
	{
		printf("Already off\n");
	}else
	{
		down(x);
	}
	return;
}
int main()
{
	int i,d;
	scanf("%d%d",&n,&m);
	for(i=1;i<=m;i++)
	{
		char ch=getchar(); 
		while(ch!='-'&&ch!='+')
		{
			ch=getchar(); 
		}
		d=read();
		if(ch=='+')
		{
			turnon(d);
		}else
		{
			close(d);
		}
	}
	return 0;
}
```


---

## 作者：s_ShotღMaki (赞：1)

# 大模拟

题目里面写的比较清楚了

~~请开O2~~


```cpp
#include<bits/stdc++.h>
#define maxn 200005
using namespace std;
void pao(char o,int nu);
int zhi(int x);
bool isrp(int a,int b);
struct node//每个机子 
{
	int num;//编号 
	char ooo;//开关 
}a[100005];
int n,m;
int t;
int xx;
int k[maxn];
int num;
bool ji[maxn];
int main()
{
	ios::sync_with_stdio(0);//让你的cin跟scanf一样快，noip不可用 
	cin>>n>>m;// 输入 
	for(int i=1;i<=m;i++)
	cin>>a[i].ooo>>a[i].num;//输入每个对撞机的数据 
	for(int i=1;i<=m;i++)
	pao(a[i].ooo,a[i].num);//对每个对撞机进行操作 
	return 0;
}
void pao(char o,int nu)
{
	if(o=='+')//如果是打开 
	{
		xx=zhi(nu);//判断一下和谁互质 放到xx里面 ，不然就是0 
		if(!ji[nu]&&xx==1)//如果还没有打开 
		{
			cout<<"Success"<<endl;//那就打开 
			k[++num]=nu;//存到数组里面 
			ji[nu]=true;//已经打开 
		}
		else//不然呢 
		{
			if(ji[nu])cout<<"Already on"<<endl;//输出已经打开 
			else 
			if(xx!=1)cout<<"Conflict with "<<xx<<endl;//如果有冲突就输出冲突 
		}
	}
	if(o=='-')//如果是关闭 
	{
		if(ji[nu])//如果已经打开 
		{
			ji[nu]=false;//关上 
			for(int i=1;i<=num;i++)//然后退出来 
			{
				if(k[i]==nu)
				{
					k[i]=0;
					break;
				}
			}
			cout<<"Success"<<endl;//输出成功 
		}
		else cout<<"Already off"<<endl;//不然就输出已经关闭 
	}
}
int zhi(int x)//判断互质 
{
	for(int i=1;i<=num;i++)
	if(k[i]!=0&&!isrp(k[i],x))return k[i];
	return 1;
}
bool isrp(int a,int b)//互质里面可以调用的函数 
{
	if(a==1||b==1)
	return true;
	while(1)
	{
		int t=a%b;
		if(t==0)break;
		else 
		{
			a=b;
			b=t;
		}
	}
	if(b>1)return false;
	else return true;
}
```

---

## 作者：Erotate (赞：0)

**题目大意：**

有 $n$ 台机器，每台机器的编号为 $1$ 到 $n$。如果要开启一台机器，那这台机器的编号必须和已开启的机器的编号互质。现在有两种操作：

- `+ id` 意思为开启一台机器

	如果已经开启了，输出 `Already on`。
   
   如果不能开启，输出 `Conflict with j`，$j$ 为导致这台机器不能开启的机器的编号
   
   如果能开启，输出 `Success`。
   
- `- id` 意思为关闭一台机器

	如果已经关闭了，输出 `Already off`。
    
   如果成功关闭，输出 `Success`。

---
那么，因为要判断编号是否互质，我们可以预处理 $1$ 到 $n$ 中每个数的因数，把它们加入到一个 vector 容器里：

```cpp
//g[i] 记录第 i 个数的所有因数
for(int i=1;i<=n;++i)
	for(int j=1;j*j<=i;++j)
		if(i%j==0){
			if(j!=1) g[i].push_back(j);
			if(j!=i/j) g[i].push_back(i/j);
		}
```
我们使用 C++ 中 STL 里的 set 容器，来记录已经开启的机器的编号和已开启的机器的编号的因数。

```cpp
set<int>s1 //记录编号
set<int>s2 //记录编号的因数
```

1. 当输入为 `+` 号时，我们分类讨论：

- 没有开启任何机器，直接开启。

```cpp
if(!s1.size()){
	s1.insert(x);//插入编号
	for(int i=0;i<g[x].size();++i){//循环插入因数
		s2.insert(g[x][i]);
		d[g[x][i]]=x;//这里 d 数组记录每个因数对应的数
	}
	printf("Success\n");
	continue;
}
```

- 已经开启了这台机器。

```cpp
if(s1.count(x)){// s1.count 表示在 s1 里查找 x
	printf("Already on\n");
	continue; 
}
```

- 剩下的情况就需要判断当前编号是否与之前的编号互质了。

```cpp
int f=1;
for(int i=0;i<g[x].size();++i)//判断是否互质
	if(s2.count(g[x][i])){
		f=0;
		printf("Conflict with %d\n",d[g[x][i]]);//不互质就输出因数对应的数
		break;
	}
if(f){//如果互质，就把当前数和数的因数加进 set
	s1.insert(x);
	for(int i=0;i<g[x].size();++i){
		s2.insert(g[x][i]);
		d[g[x][i]]=x;
	}
	printf("Success\n");
}
```

2. 当输入为 `-` 号时，如果在 set 里找不到要关闭的机器的编号，就说明已经关闭了；否则就把编号和编号对应的因数删除。

```cpp
if(s1.count(x)){
	s1.erase(x);
	for(int i=0;i<g[x].size();++i){
		s2.erase(g[x][i]);//s1.erase 表示 在 s1中删除 x
		d[g[x][i]]=0;
	}
	printf("Success\n");
}else printf("Already off\n");
```

---
总代码：
```cpp
#include<bits/stdc++.h>
#define N 100005
using namespace std;
int n,m,d[N];
set<int>s1,s2;
vector<int>g[N];
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
		for(int j=1;j*j<=i;++j)
			if(i%j==0){
				if(j!=1) g[i].push_back(j);
				if(j!=i/j) g[i].push_back(i/j);
			}
	for(int i=1,x;i<=m;++i){
		char c[2];
		scanf("%s%d",c,&x);
		if(c[0]=='+'){
			if(!s1.size()){
				s1.insert(x);
				for(int i=0;i<g[x].size();++i){
					s2.insert(g[x][i]);
					d[g[x][i]]=x;
				}
				printf("Success\n");
				continue;
			}
			if(s1.count(x)){
				printf("Already on\n");
				continue; 
			}
			int f=1;
			for(int i=0;i<g[x].size();++i)
				if(s2.count(g[x][i])){
					f=0;
					printf("Conflict with %d\n",d[g[x][i]]);
					break;
				}
			if(f){
				s1.insert(x);
				for(int i=0;i<g[x].size();++i){
					s2.insert(g[x][i]);
					d[g[x][i]]=x;
				}
				printf("Success\n");
			}
		}else{
			if(s1.count(x)){
				s1.erase(x);
				for(int i=0;i<g[x].size();++i){
					s2.erase(g[x][i]);
					d[g[x][i]]=0;
				}
				printf("Success\n");
			}else printf("Already off\n");
		}
	}
	return 0;
}
```


---

## 作者：0x3F (赞：0)

题目要求就是所有数两两互质。

题目描述有误，“互质”写成了“互为质数”，但是它反而给了我思路。

显而易见，如果两个数不互质，则它们必有公共质因子。

所以所有数的质因子两两没有重复。

我们对于每一次操作都将操作数的每一个质因子标记上，删除的话清空标记即可。

具体做法是这样：

当询问为 `+ i` 时：

如果 $i$ 的质因子中有一个质因子已有标记且不等于 $i$，则为 `Conflict with 「该标记的值」`。

如果 $i$ 的质因子中有一个质因子已标记为 $i$，则为 `Already on`。

否则为 `Success`，并将 $i$ 的所有质因子打上 $i$ 的标记。

当询问为 `- i` 时：

如果 $i$ 的所有质因子均被标记为 $i$，则为 `Success`，并将这些标记改为 $0$。

否则为 `Already off`。

注意： $1$ 要特判！！！

具体见代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int N, n, m;
char ch;
int vis[100010];
int main() {
	cin >> m >> m;
	while (m--) {
		cin >> ch >> N;
		n = N;
		if (n == 1) {
			if (ch == '+') {
				if (vis[1]) cout << "Already on" << endl;
				else cout << "Success" << endl, vis[1] = 1;
			} else {
				if (vis[1]) cout << "Success" << endl, vis[1] = 0;
				else cout << "Already off" << endl;
			}
		} else if (ch == '+') {
			for (int i = 2; i * i <= n; i++) {
				if (n % i == 0) {
					if (vis[i]) {
						if (vis[i] == N) {
							cout << "Already on" << endl;
							goto end;
						} else {
							cout << "Conflict with " << vis[i] << endl;
							goto end;
						}
					}
					while (n % i == 0) n /= i;
				}
			}
			if (n != 1) {
				if (vis[n]) {
					if (vis[n] == N) {
						cout << "Already on" << endl;
						goto end;
					} else {
						cout << "Conflict with " << vis[n] << endl;
						goto end;
					}
				}
			}
			cout << "Success" << endl;
			n = N;
			for (int i = 2; i * i <= n; i++) {
				if (n % i == 0) {
					vis[i] = N;
					while (n % i == 0) n /= i;
				}
			}
			if (n != 1) vis[n] = N;
			end:;
		} else {
			for (int i = 2; i * i <= n; i++) {
				if (n % i == 0) {
					if (vis[i] != N) {
						cout << "Already off" << endl;
						goto fail;
					}
					while (n % i == 0) n /= i;
				}
			}
			if (n != 1 && vis[n] != N) {
				cout << "Already off" << endl;
				goto fail;
			}
			cout << "Success" << endl;
			n = N;
			for (int i = 2; i * i <= n; i++) {
				if (n % i == 0) {
					vis[i] = 0;
					while (n % i == 0) n /= i;
				}
			}
			if (n != 1) vis[n] = 0;
			fail:;
		}
	}
}
```


---


# 小Z的掷骰游戏

## 题目描述

小 Z 得到了一种奇特的骰子（如下图所示），想要用它进行掷骰游戏。

![](https://cdn.luogu.com.cn/upload/pic/1263.png)

游戏很简单，小 Z 每次都从同样的位置将一个骰子竖直抛下，当骰子落到平面或另一个骰子上时停下来。然而，由于这是一种奇特的骰子，它还会继续翻滚和下落。这种骰子有以下特性：

- 普通骰子可能往四个方向翻滚，而这种骰子只能往 $4,5,6$ 这三个面的方向翻滚。在下图所示的情况中，这种骰子只能往两个方向翻滚；

![](https://cdn.luogu.com.cn/upload/pic/1264.png)

- 这种骰子只有在翻滚后会导致其下落时才会翻滚（如下图所示），当有多个方向可以翻滚时，它会往数字最大的面的方向翻滚；

![](https://cdn.luogu.com.cn/upload/pic/1265.png)

- 这种骰子翻滚恰好 $90^\circ$ 后会竖直下落，当落到平面或另一个骰子上时停下来（如下图中的 $B$ 和 $C$ 所示），然后继续翻滚和下落的过程。

![](https://cdn.luogu.com.cn/upload/pic/1266.png)

上图就是将 $4$ 个骰子均以上面是 $6$ 前面是 $4$ 的状态依次抛下的过程。

现在小 Z 抛了 $n$ 个骰子，他想知道游戏结束后从上面看每个数字分别出现了多少次（如下图所示），希望你帮帮他。

![](https://cdn.luogu.com.cn/upload/pic/1267.png)

## 说明/提示

本题有 $4$ 个点，每个点 $25$ 分。

对于 $25\%$ 的数据，$n=1$。

对于另外 $25\%$ 的数据，$n=2$。

对于 $100\%$ 的数据，$1 \leq n \leq 100$，不超过 $30$ 组数据。

## 样例 #1

### 输入

```
4
6 4
6 4
6 4
6 4
1
2 1
```

### 输出

```
0 1 1 0 0 1
0 1 0 0 0 0```

# 题解

## 作者：天南月 (赞：9)

为了不让楼上孤单我也来写一篇题解

其实模拟的题就是怕眼瞎~~我已经WA了几次了~~，WA了的话只要有耐心一遍一遍检查就行了~~除和本人一样的星际玩家~~。

我的代码比楼上的短一点，应该好理解一点，但还请大佬指教！

接下来上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int h[200][200],on[200][200],gs[7];
struct coordinate{
	int c_x,c_y;
}chan[5];
int n,fr,up,x,y;//分别是骰子个数，前，上，坐标（x，y）
int fir,sec,up1,fr1,up2,fr2;//最大、次大面的方向 ，向最大、次大面方向翻转后的上面和前面 
void clear(){//清除 
	memset(h,0,sizeof(h));
	memset(on,0,sizeof(on));
	memset(gs,0,sizeof(gs));
}
void sur(){//确定最大、次大面的和向最大、次大面方向翻转后的上面和前面 
	if(fr==1){
		if(up==2)sec=4,fr1=5,up2=3;
		else if(up==4)sec=4,fr1=3,up2=2;
		else if(up==5)sec=2,fr1=2,up2=3;
		else if(up==3)sec=2,fr1=4,up2=2;
		fir=3;up1=1;fr2=1;
	}
	else if(fr==2){ 
		if(up==6)fir=3,sec=4,up1=2,fr1=1,up2=3,fr2=2;
		else if(up==4)fir=2,sec=3,up1=1,fr1=2,up2=2,fr2=3;
		else if(up==1)fir=3,sec=2,up1=2,fr1=6,up2=3,fr2=2;
		else if(up==3)fir=4,sec=3,up1=1,fr1=2,up2=2,fr2=4;
	}
	else if(fr==3){ 
		if(up==5)fir=4,up1=1,fr2=2;
		else if(up==6)fir=2,up1=2,fr2=1;
		else if(up==2)fir=2,up1=1,fr2=5;
		else fir=4,up1=2,fr2=6;
		sec=3;up2=3;fr1=3;
	}
	else if(fr==4){
		if(up==5)fir=2,up1=1,fr2=5;
		else if(up==6)fir=4,up1=2,fr2=6;
		else if(up==2)fir=4,up1=1,fr2=2;
		else fir=2,up1=2,fr2=1;
		sec=1;up2=3;fr1=4;
	}
	else if(fr==5){ 
		if(up==1)fir=1,sec=4,up1=2,fr1=1,up2=3,fr2=5;
		else if(up==4)fir=4,sec=1,up1=1,fr1=5,up2=2,fr2=4;
		else if(up==6)fir=1,sec=2,up1=2,fr1=6,up2=3,fr2=5;
		else fir=2,sec=1,up1=1,fr1=5,up2=2,fr2=3;
	}
	else { 
		if(up==5)sec=4,fr1=5,up2=3;
		else if(up==4)sec=2,fr1=4,up2=2;
		else if(up==2)sec=2,fr1=2,up2=3;
		else sec=4,fr1=3,up2=2;
		fir=1;up1=1;fr2=6;
	}
}
void game(){
	sur();
	int x1=x+chan[fir].c_x,y1=y+chan[fir].c_y;
	if(h[x][y]&&h[x1][y1]<h[x][y]){//向最大面翻转 
		x=x1;y=y1;fr=fr1;up=up1;
		game();
		return ;
	}
	x1=x+chan[sec].c_x;y1=y+chan[sec].c_y;
	if(h[x][y]&&h[x1][y1]<h[x][y]){//向次小面翻转 
		x=x1;y=y1;fr=fr2;up=up2;
		game();
		return ;
	}
	//不能翻转就覆盖原位置的信息并增加高度 
	h[x][y]++;
	gs[on[x][y]]--;
	on[x][y]=up;
	gs[up]++;
}
int main(){
	std::ios::sync_with_stdio(false);
	//方向信息 
	chan[1].c_x=0;chan[1].c_y=-1;
	chan[2].c_x=-1;chan[2].c_y=0;
	chan[3].c_x=0;chan[3].c_y=1;
	chan[4].c_x=1;chan[4].c_y=0;
	while(cin>>n){
		clear();
		for(int i=1;i<=n;++i){
			cin>>up>>fr;
			x=100;y=100;//初始化坐标 
			game();
		}
		for(int i=1;i<=6;++i)
		cout<<gs[i]<<" ";
		cout<<endl;
	}
return 0;
}

```


---

## 作者：HenghengMoi (赞：2)

[P2139 小Z的掷骰游戏](https://www.luogu.com.cn/problem/P2139)

## 题意简述

投 $n$（$1 \le n \le 100$）个同种骰子，每面印有数字 $1$ 到 $6$ 各一个，滚骰子，并且：

+ 投骰子的初始位置固定
+ 骰子滚一次只能绕底面一条棱旋转恰好 $90^{\circ}$，然后竖直下落
+ 骰子只能向印着数字 $4$，$5$，$6$ 的面的方向滚，且优先选数字较大的一面
+ 骰子只能从高处往低处滚，不能在平地上滚
+ 骰子不能悬空

最后求骰子堆俯视图里各数字出现次数。

## 题目分析

**模**！

将游戏场地的俯视图视为网格，用两个二维数组记录该坐标上的骰子个数（高度）和顶端数字。因为 $\frac{14 \times (14 + 1)}{2} > 100$，所有开 $30 \times 30$ 的数组就够了。

不难发现：确定顶面和前面，就能确定骰子的摆放方式。再进一步，顶面的数有 $6$ 种可能，除去顶面以及底面的数，前面的数有 $4$ 种可能，不难算出：骰子共有 $24$ 种摆放方式。$24$ 还是非常小的，可以直接手动穷举所有情况。

[这是我自己穷举的所有情况及其对应编号，大家也可以自行打表。](https://www.luogu.com.cn/paste/bop9awoy)

然后就可以打出一份顶面、前面数字对应编号表（**编号方式不同可能导致打出来的表不同，下同**）：

```cpp
int cube[6][6] = { //cube[顶面数字][前面数字] = 编号 
-1, 22, 23, 21, 20, -1,
18, -1, 17, 19, -1, 16,
14, 15, -1, -1, 13, 12,
10, 9, -1, -1, 11, 8,
6, -1, 7, 5, -1, 4,
-1, 2, 1, 3, 0, -1
}; //如果你开的也是6×6数组，记得用的时候数字-1
```

然后开始滚骰子。初始位置设为网格中心，因为骰子只能向印着数字 $4$，$5$，$6$ 的面的方向滚，再打一个数字 $4$，$5$，$6$ 的面的方向的表：

```cpp
int x[5] = {0, 1, 0, -1, 0}; //x坐标变化量
int y[5] = {0, 0, -1, 0, 1}; //y坐标变化量
int turn[3][24] = {
0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 0, 0, 0, 0, //6的方向 
1, 2, 3, 4, 0, 0, 0, 0, 2, 3, 4, 1, 4, 1, 2, 3, 0, 0, 0, 0, 1, 2, 3, 4, //5的方向 
2, 3, 4, 1, 4, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 1, 4, 1, 2, 3  //4的方向 
};
```

每滚一次，骰子的摆放方式都会改变，再打出编号对应骰子顶、底、左、右、前、后面的数字——但等等！我们发现相对的面上的数字和为 $7$，所以记录顶、左、右面的数即可：

```cpp
int lft[24] = { //左面数字 
4, 5, 3, 2, 3, 6, 4, 1, 5, 6, 2, 1, 2, 6, 5, 1, 4, 6, 3, 1, 3, 5, 4, 2
};
int frnt[24] = { //前面数字 
5, 3, 2, 4, 6, 4, 1, 3, 6, 2, 1, 5, 6, 5, 1, 2, 6, 3, 1, 4, 5, 4, 2, 3
};
/*
int top[24] = { 顶面数字 
6, 6, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1  
} // top[i] = 6 - i / 4
*/
```

滚动并修改时，对滚动方向分类讨论：

```cpp
px = py = 15; //初始坐标 
while (true) {
	int dir = 0;
	for (int j = 0; j <= 2; j++) { //滚动方向 
		int arr = turn[j][id];
		if (h[px][py] - h[px + x[arr]][py + y[arr]] > 0) {
			dir = arr;
			break;
		}
	}
	if (dir == 0) { //滚不动，退出 
		topnum[px][py] = 6 - id / 4;
		h[px][py]++;
		break;
	}
	//滚得动，修改 
	px += x[dir];
	py += y[dir];
	if (dir == 1) id = cube[6 - frnt[id]][5 - id / 4];
	if (dir == 2) id = cube[6 - lft[id]][frnt[id] - 1];
	if (dir == 3) id = cube[frnt[id] - 1][id / 4];
	if (dir == 4) id = cube[lft[id] - 1][frnt[id] - 1];
}
```

最后统计并输出答案（**别忘记清空**）：

```cpp
for (int i = 0; i < 30; i++) { //统计答案，清空 
	for (int j = 0; j < 30; j++) {
		cntnum[topnum[i][j]]++;
		topnum[i][j] = 0;
		h[i][j] = 0;
	}
}
for (int i = 1; i <= 6; i++) { //输出答案，清空 
	cout << cntnum[i] << ' ';
	cntnum[i] = 0;
}
cout << '\n';
```

## 完整代码

```cpp
#include <iostream>
using namespace std;

int n, tp, ft, id, px, py;
int h[30][30]; //高度 
int topnum[30][30]; //顶部数字 
int cntnum[10]; //数的个数 
int x[5] = {0, 1, 0, -1, 0}; //x坐标变化量
int y[5] = {0, 0, -1, 0, 1}; //y坐标变化量
int cube[6][6] = { //cube[顶面数字][前面数字] = 编号 
-1, 22, 23, 21, 20, -1,
18, -1, 17, 19, -1, 16,
14, 15, -1, -1, 13, 12,
10, 9, -1, -1, 11, 8,
6, -1, 7, 5, -1, 4,
-1, 2, 1, 3, 0, -1
};
int lft[24] = { //左面数字 
4, 5, 3, 2, 3, 6, 4, 1, 5, 6, 2, 1, 2, 6, 5, 1, 4, 6, 3, 1, 3, 5, 4, 2
};
int frnt[24] = { //前面数字 
5, 3, 2, 4, 6, 4, 1, 3, 6, 2, 1, 5, 6, 5, 1, 2, 6, 3, 1, 4, 5, 4, 2, 3
};
/*
int top[24] = { 顶面数字 
6, 6, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1  
} // top[i] = 6 - i / 4
*/
int turn[3][24] = {
0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 0, 0, 0, 0, //6的方向 
1, 2, 3, 4, 0, 0, 0, 0, 2, 3, 4, 1, 4, 1, 2, 3, 0, 0, 0, 0, 1, 2, 3, 4, //5的方向 
2, 3, 4, 1, 4, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 1, 4, 1, 2, 3  //4的方向 
};

int main() {
	while (cin >> n) {
		for (int i = 1; i <= n; i++) {
			cin >> tp >> ft;
			id = cube[tp - 1][ft - 1];
			px = py = 15; //初始坐标 
			while (true) {
				int dir = 0;
				for (int j = 0; j <= 2; j++) { //滚动方向 
					int arr = turn[j][id];
					if (h[px][py] - h[px + x[arr]][py + y[arr]] > 0) {
						dir = arr;
						break;
					}
				}
				if (dir == 0) { //滚不动，退出 
					topnum[px][py] = 6 - id / 4;
					h[px][py]++;
					break;
				}
				//滚得动，修改 
				px += x[dir];
				py += y[dir];
				if (dir == 1) id = cube[6 - frnt[id]][5 - id / 4];
				if (dir == 2) id = cube[6 - lft[id]][frnt[id] - 1];
				if (dir == 3) id = cube[frnt[id] - 1][id / 4];
				if (dir == 4) id = cube[lft[id] - 1][frnt[id] - 1];
			}
		}
		for (int i = 0; i < 30; i++) { //统计答案，清空 
			for (int j = 0; j < 30; j++) {
				cntnum[topnum[i][j]]++;
				topnum[i][j] = 0;
				h[i][j] = 0;
			}
		}
		for (int i = 1; i <= 6; i++) { //输出答案，清空 
			cout << cntnum[i] << ' ';
			cntnum[i] = 0;
		}
		cout << '\n';
	}
	return 0;
}
```

---

## 作者：Hoks (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P2139)

推荐[个人博客](https://www.luogu.com.cn/blog/Hok/solution-p2139)内食用，味道更佳哦。

------------

面对繁琐的大模拟的题面，我们要学会抓关键词，分块思考。
1. 对于每一个骰子都会给出它上面和前面的数字，这时，我们便可以求出它 $6$ 面的数字。

```cpp
void td()//td=推导，s=上，q=前，x=下，h=后，z=左，y=右
{
    //这步其实不太好算，但只要身边有个实物就简单多了
    x=7-s,h=7-q;
    if(s==1&&q==2||s==6&&q==5||s==2&&q==6||s==5&&q==1) z=4,y=3;
    if(s==1&&q==5||s==6&&q==2||s==2&&q==1||s==5&&q==6) z=3,y=4;
    if(s==1&&q==3||s==6&&q==4||s==3&&q==6||s==4&&q==1) z=2,y=5;
    if(s==1&&q==4||s==6&&q==3||s==3&&q==1||s==4&&q==6) z=5,y=2;
    if(s==2&&q==3||s==5&&q==4||s==3&&q==5||s==4&&q==2) z=6,y=1;
    if(s==2&&q==4||s==5&&q==3||s==3&&q==2||s==4&&q==5) z=1,y=6;
}
```

2. 只能向着 $4$ , $5$ , $6$ 三个方向滚，且选择最大的一面。注意，此时，我们还要判断原先的高度是否相同，相同时无法滚落。

```cpp
void fg(int i,int j)//fg=翻滚
{
    int maxx=0,flagq=0,flagh=0,flagz=0,flagy=0;
    if((q==4||q==5||q==6)&&a[i+1][j].gd<a[i][j].gd&&q>maxx) flagh=flagz=flagy=0,flagq=1,maxx=q;
    if((h==4||h==5||h==6)&&a[i-1][j].gd<a[i][j].gd&&h>maxx) flagq=flagz=flagy=0,flagh=1,maxx=h;
    if((z==4||z==5||z==6)&&a[i][j-1].gd<a[i][j].gd&&z>maxx) flagh=flagq=flagy=0,flagz=1,maxx=z;
    if((y==4||y==5||y==6)&&a[i][j+1].gd<a[i][j].gd&&y>maxx) flagh=flagz=flagq=0,flagy=1,maxx=y;
    if(flagq){xqf(),fg(i+1,j);return ;}
    else if(flagh){xhf(),fg(i-1,j);return ;}
    else if(flagz){xzf(),fg(i,j-1);return ;}
    else if(flagy){xyf(),fg(i,j+1);return ;}
    else{js(i,j);return ;}
}
```

3. 处理好翻滚方向的问题，接着只需要让他能够一直滚起来就好了。

```cpp
void xqf(){t=s,s=h,h=x,x=q,q=t;}//xqf=向前翻
void xhf(){t=s,s=q,q=x,x=h,h=t;}//xhf=向后翻
void xzf(){t=s,s=y,y=x,x=z,z=t;}//xzf=向左翻
void xyf(){t=s,s=z,z=x,x=y,y=t;}//xyf=向右翻
```
4. 滚完之后的骰子总是会停下来的，那停下来的位置和信息就可以记录下来了。

```cpp
void js(int i,int j){a[i][j].gd++,a[i][j].s=s;}//js=计数
```

------------

这样，我们就算是把题目分块解决了，最后合起来奉上。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct node
{int s,gd;}a[210][210];
int n,s,x,z,y,q,h,t;
int mp[7];
void td()
{
    x=7-s,h=7-q;
    if(s==1&&q==2||s==6&&q==5||s==2&&q==6||s==5&&q==1) z=4,y=3;
    if(s==1&&q==5||s==6&&q==2||s==2&&q==1||s==5&&q==6) z=3,y=4;
    if(s==1&&q==3||s==6&&q==4||s==3&&q==6||s==4&&q==1) z=2,y=5;
    if(s==1&&q==4||s==6&&q==3||s==3&&q==1||s==4&&q==6) z=5,y=2;
    if(s==2&&q==3||s==5&&q==4||s==3&&q==5||s==4&&q==2) z=6,y=1;
    if(s==2&&q==4||s==5&&q==3||s==3&&q==2||s==4&&q==5) z=1,y=6;
}
void xqf(){t=s,s=h,h=x,x=q,q=t;}
void xhf(){t=s,s=q,q=x,x=h,h=t;}
void xzf(){t=s,s=y,y=x,x=z,z=t;}
void xyf(){t=s,s=z,z=x,x=y,y=t;}
void js(int i,int j){a[i][j].gd++,a[i][j].s=s;}
void fg(int i,int j)
{
    int maxx=0,flagq=0,flagh=0,flagz=0,flagy=0;
    if((q==4||q==5||q==6)&&a[i+1][j].gd<a[i][j].gd&&q>maxx) flagh=flagz=flagy=0,flagq=1,maxx=q;
    if((h==4||h==5||h==6)&&a[i-1][j].gd<a[i][j].gd&&h>maxx) flagq=flagz=flagy=0,flagh=1,maxx=h;
    if((z==4||z==5||z==6)&&a[i][j-1].gd<a[i][j].gd&&z>maxx) flagh=flagq=flagy=0,flagz=1,maxx=z;
    if((y==4||y==5||y==6)&&a[i][j+1].gd<a[i][j].gd&&y>maxx) flagh=flagz=flagq=0,flagy=1,maxx=y;
    if(flagq){xqf(),fg(i+1,j);return ;}
    else if(flagh){xhf(),fg(i-1,j);return ;}
    else if(flagz){xzf(),fg(i,j-1);return ;}
    else if(flagy){xyf(),fg(i,j+1);return ;}
    else{js(i,j);return ;}
}
int read()
{
    char c=getchar();int x=0,f=1;
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
    return x*f;
}
void sc(int n)
{
    if(n<0) putchar('-'),n*=-1;
    if(n>9) sc(n/10);
    putchar(n%10+'0');
}
signed main()
{
    while(cin>>n)
    {
        memset(mp,0,sizeof mp);
        for(int i=1;i<=200;i++)
            for(int j=1;j<=200;j++)
                a[i][j].gd=0;
        for(int i=1;i<=n;i++)
        {
            s=read(),q=read();
            td();fg(101,101);
        }
        for(int i=1;i<=200;i++)
            for(int j=1;j<=200;j++)
                if(a[i][j].gd)
                    mp[a[i][j].s]++;
        for(int i=1;i<=6;i++) cout<<mp[i]<<" ";
        cout<<endl;
    }
    return 0;
}
```


---

## 作者：zhaoxibo (赞：2)

其实就是一道模拟题，感觉不是很难。

输入后直接模拟，扔下骰子，碰到其它骰子时，就找到点 $4$ 、 $5$ 、 $6$ 在骰子的方向，然后翻滚下落，重复执行直到无法再翻滚下落，输出答案。

有一个注意的点：

已知骰子的上面和前面的点数，怎么求右面的点数。

根据题面的图，直接建一个二维数组即可：

```cpp
int right[7][7]={{0,0,0,0,0,0,0},
		 {0,0,3,5,2,4,0},
		 {0,4,0,1,6,0,3},
		 {0,2,6,0,0,1,5},
		 {0,5,1,0,0,6,2},
		 {0,3,0,6,1,0,4},
		 {0,0,4,2,5,3,0}};
		
```
 `right[a][b]` 表示当上面为 $a$ ，前面为 $b$ 时，右面的点数。

代码：
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int map[205][205][205];//三维数组存该位置的骰子上面的点数
int top[105][105];//该位置有几层
int num[12];
int right[7][7]={{0,0,0,0,0,0,0},
		 {0,0,3,5,2,4,0},
		 {0,4,0,1,6,0,3},
		 {0,2,6,0,0,1,5},
		 {0,5,1,0,0,6,2},
		 {0,3,0,6,1,0,4},
		 {0,0,4,2,5,3,0}};

int dir[12];//1.上 2.下 3.左 4.右 5.前 6.后
	    //dir[a] 表示此时点数 a 在骰子的方向
void drop(int up,int front,int x,int y,int z){
	dir[up]=1;
	dir[front]=5;
	dir[right[up][front]]=4;
	dir[7-up]=2;
	dir[7-front]=6;
	dir[7-right[up][front]]=3;
	bool flag=false;
	for(int i=6;i>=4;i--){
                //从点 6 到点 4 查询能否翻滚下落，一旦下落，返回时就退出
		if(flag) break;
		if(dir[i]==3&&top[x][y]-top[x][y-1]>0){
			drop(right[up][front],front,x,y-1,top[x][y-1]+1);
			flag=true;
		}
		else if(dir[i]==4&&top[x][y]-top[x][y+1]>0){
			drop(7-right[up][front],front,x,y+1,top[x][y+1]+1);
			flag=true;
		}
		else if(dir[i]==5&&top[x][y]-top[x+1][y]>0){
			drop(7-front,up,x+1,y,top[x+1][y]+1);
			flag=true;
		}
		else if(dir[i]==6&&top[x][y]-top[x-1][y]>0){
			drop(front,7-up,x-1,y,top[x-1][y]+1);
			flag=true;
		}
	}
	if(!flag){//统计朝上点数数量
		num[map[x][y][z-1]]--;
		map[x][y][z]=up;
		num[map[x][y][z]]++;
		top[x][y]++;
	}
}
int main(){
	int n,x,y;
	while(scanf("%d",&n)==1){
		memset(map,0,sizeof(map));
		memset(top,0,sizeof(top));
		memset(num,0,sizeof(num));
		//每读入一组数据前数组清零
		for(int i=1;i<=n;i++){
			scanf("%d%d",&x,&y);
			drop(x,y,100,100,top[100][100]+1);
		}
		for(int i=1;i<=6;i++)
			printf("%d ",num[i]);
		printf("\n");
	}
	return 0;
}
```
蒟蒻的第一篇题解，感谢观看。

---

## 作者：LXcjh4998 (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P2139)
# 题意
小 Z 得到了一个神奇的骰子（如下图所示）。

![](https://cdn.luogu.com.cn/upload/image_hosting/zovn4sqs.png)

这个骰子有以下神奇之处：
- 它只能往 $4$、$5$、$6$ 三个方向翻滚。
- 当它翻滚时会导致它下落时，它才会翻滚；当有多个方向可以翻滚时，它会往数字最大的面的方向翻滚。
- 这种骰子翻滚恰好 $90^\circ$ 后会竖直下落，当落到平面或另一个骰子上时停下来，然后继续翻滚和下落的过程。

现在小 Z 了 $n$ 个骰子（每次抛的位置都相同，且是竖直抛下），并给出每次抛骰子的上面与前面的数字，他想知道抛完后从上方看每个数字分别出现了几次。

多测。对于每组数据仅输出一行，分别为结束后从上方看 $1$ 至 $6$ 的个数。
# 思路
显然每次骰子至多有两个方向可翻滚，所以我们可以记录对于每种情况，其最大面和次大面的方向，以及翻滚后骰子上面及前面的数字，这样就可以不断转移了。

当翻滚后的坐标上骰子的高度是否小于当前坐标上骰子的高度，骰子才能翻滚，所以需要记录每个坐标上骰子的个数（即高度）。为了记录答案，还需要记录每个坐标上最上面的骰子的上面是什么数字。

完成上述操作后，这道题就十分好做了。

为了便于读者理解对于每种情况是如何翻滚的，我对它们都一一画了图，限于篇幅，这里便不再展示，而是存放在[云剪贴板](https://www.luogu.com.cn/paste/n04459rr)里（需要科学上网）。
# 程序
[AC 记录](https://www.luogu.com.cn/record/204640355)
```cpp
#include<cstdlib>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<queue>
#include<cstdio>
#include<iostream>
#include<vector>
#include<map>
#include<cmath>
#include<iomanip>
#include<string>
#include<stack>
#define re register
#define uint unsigned int
#define ll long long
#define ull unsigned long long
#define vl __int128
#define ld long double
#define LL 2e18
#define INT 1e9
#define INF 0x3f3f3f3f
#define lb(x) (x&(-x))
#ifdef __linux__
#define gc getchar_unlocked
#define pc putchar_unlocked
#else
#define gc _getchar_nolock
#define pc _putchar_nolock
#endif
int T=1;
using namespace std;
inline bool blank(const char x){return !(x^32)||!(x^10)||!(x^13)||!(x^9);}
template<typename Tp>inline void read(Tp &x){x=0;re bool z=true;re char a=gc();for(;!isdigit(a);a=gc())if(a=='-')z=false;for(;isdigit(a);a=gc())x=(x<<1)+(x<<3)+(a^48);x=(z?x:~x+1);}
inline void read(double &x){x=0.0;re bool z=true;re double y=0.1;re char a=gc();for(;!isdigit(a);a=gc())if(a=='-')z=false;for(;isdigit(a);a=gc())x=x*10+(a^48);if(a!='.')return x=z?x:-x,void();for(a=gc();isdigit(a);a=gc(),y/=10)x+=y*(a^48);x=(z?x:-x);}
inline void read(ld &x){x=0.0;re bool z=true;re ld y=0.1;re char a=gc();for(;!isdigit(a);a=gc())if(a=='-')z=false;for(;isdigit(a);a=gc())x=x*10+(a^48);if(a!='.')return x=z?x:-x,void();for(a=gc();isdigit(a);a=gc(),y/=10)x+=y*(a^48);x=(z?x:-x);}
inline void read(char &x){for(x=gc();blank(x)&&(x^-1);x=gc());}
inline void read(char *x){re char a=gc();for(;blank(a)&&(a^-1);a=gc());for(;!blank(a)&&(a^-1);a=gc())*x++=a;*x=0;}
inline void read(string &x){x="";re char a=gc();for(;blank(a)&&(a^-1);a=gc());for(;!blank(a)&&(a^-1);a=gc())x+=a;}
template<typename T,typename ...Tp>inline void read(T &x,Tp &...y){read(x),read(y...);}
template<typename T>inline void read(T *begin,T *end){re T *i;if(begin<end)for(i=begin;i<end;++i)read(*i);else for(i=begin-1;i>=end;--i)read(*i);}
template<typename Tp>inline void write(Tp x){if(!x)return pc(48),void();if(x<0)pc('-'),x=~x+1;re int len=0;re char tmp[64];for(;x;x/=10)tmp[++len]=x%10+48;while(len)pc(tmp[len--]);}
inline void write(const double x){re int a=6;re double b=x,c=b;if(b<0)pc('-'),b=-b,c=-c;re double y=5*powl(10,-a-1);b+=y,c+=y;re int len=0;re char tmp[64];if(b<1)pc(48);else for(;b>=1;b/=10)tmp[++len]=floor(b)-floor(b/10)*10+48;while(len)pc(tmp[len--]);pc('.');for(c*=10;a;a--,c*=10)pc(floor(c)-floor(c/10)*10+48);}
inline void write(const ld x){re int a=6;re ld b=x,c=b;if(b<0)pc('-'),b=-b,c=-c;re ld y=5*powl(10,-a-1);b+=y,c+=y;re int len=0;re char tmp[64];if(b<1)pc(48);else for(;b>=1;b/=10)tmp[++len]=floor(b)-floor(b/10)*10+48;while(len)pc(tmp[len--]);pc('.');for(c*=10;a;a--,c*=10)pc(floor(c)-floor(c/10)*10+48);}
inline void write(const pair<int,double>x){re int a=x.first;if(a<7){re double b=x.second,c=b;if(b<0)pc('-'),b=-b,c=-c;re double y=5*powl(10,-a-1);b+=y,c+=y;re int len=0;re char tmp[64];if(b<1)pc(48);else for(;b>=1;b/=10)tmp[++len]=floor(b)-floor(b/10)*10+48;while(len)pc(tmp[len--]);a&&(pc('.'));for(c*=10;a;a--,c*=10)pc(floor(c)-floor(c/10)*10+48);}else printf("%.*lf",a,x.second);}
inline void write(const pair<int,ld>x){re int a=x.first;if(a<7){re ld b=x.second,c=b;if(b<0)pc('-'),b=-b,c=-c;re ld y=5*powl(10,-a-1);b+=y,c+=y;re int len=0;re char tmp[64];if(b<1)pc(48);else for(;b>=1;b/=10)tmp[++len]=floor(b)-floor(b/10)*10+48;while(len)pc(tmp[len--]);a&&(pc('.'));for(c*=10;a;a--,c*=10)pc(floor(c)-floor(c/10)*10+48);}else printf("%.*Lf",a,x.second);}
inline void write(const char x){pc(x);}
inline void write(const bool x){pc(x?49:48);}
inline void write(char *x){fputs(x,stdout);}
inline void write(const char *x){fputs(x,stdout);}
inline void write(const string &x){fputs(x.c_str(),stdout);}
template<typename T,typename ...Tp> inline void write(T x,Tp ...y){write(x),write(y...);}
template<typename T>inline void write(T *begin,T *end,const char c=' '){re T *i;for(i=begin;i<end;++i)write(*i,c);}
template<typename T>inline void init(T *begin,T *end,const T& val=T()){re T* i;for(i=begin;i<end;++i)*i=val;}
template<typename T>inline T max(T *begin,T *end){re T *ans,*i;for(i=begin;i<end;++i)if(i==begin||*ans<*i)ans=i;return *ans;}
template<typename T>inline T min(T *begin,T *end){re T *ans,*i;for(i=begin;i<end;++i)if(i==begin||*i<*ans)ans=i;return *ans;}
template<typename T>inline T calc_sum(T *begin,T *end,const T& val=T()){re T ans=val,*i;for(i=begin;i<end;++i)ans+=*i;return ans;}
template<typename T>inline bool is_equal(T *begin,T *end,const T& val=T()){re T *i;for(i=begin;i<end;++i)if(*i!=val)return false;return true;} //模板，无需在意 

ll mod=0;
const int MAXN=200;
const int N=MAXN+10;
//#define DEBUG
//#define more_text

int n,
	up,front; //up:上面的数 front:前面的数 

int h[N][N],on[N][N],ans[7], //h[i][j]: 坐标 (i,j) 上有几个骰子
                             //on[i][j]: 坐标 (i,j) 上最上方骰子上面的数
							 //ans[i]: i 出现了几次 
	dir[2],U[2],F[2],x,y,tx,ty, //数组下标为 0 表示最大面，为 1 表示次大面
	                            //dir[]:滚动方向
								//U[]:滚动后上面的数字
								//F[]:滚动后前面的数字 
								//(x,y): 当前坐标 (tx,ty): 滚动后的坐标 
	d[5][2]={{0,0},{0,-1},{-1,0},{0,1},{1,0}}; //增量数组 下标 1~4 分别为 向前面、 向左面、向后面、向右面 

void clear(){
	memset(h,0,sizeof(h));
	memset(on,0,sizeof(on));
	memset(ans,0,sizeof(ans)); //多测须清空 
}

void init(){
	//当前前面为 front，上面为 up 时，dir[]、U[]、F[] 的值 
	if(front==1){
		if(up==2)dir[0]=3,dir[1]=4,U[0]=1,F[0]=5,U[1]=3,F[1]=1;
		if(up==3)dir[0]=3,dir[1]=2,U[0]=1,F[0]=4,U[1]=2,F[1]=1;
		if(up==4)dir[0]=3,dir[1]=4,U[0]=1,F[0]=3,U[1]=2,F[1]=1;
		if(up==5)dir[0]=3,dir[1]=2,U[0]=1,F[0]=2,U[1]=3,F[1]=1;
	}
	if(front==2){ 
		if(up==1)dir[0]=3,dir[1]=2,U[0]=2,F[0]=6,U[1]=3,F[1]=2;
		if(up==3)dir[0]=4,dir[1]=3,U[0]=1,F[0]=2,U[1]=2,F[1]=4;
		if(up==4)dir[0]=2,dir[1]=3,U[0]=1,F[0]=2,U[1]=2,F[1]=3;
		if(up==6)dir[0]=3,dir[1]=4,U[0]=2,F[0]=1,U[1]=3,F[1]=2;
	}
	if(front==3){ 
		if(up==1)dir[0]=4,dir[1]=3,U[0]=2,F[0]=3,F[1]=6,U[1]=3;
		if(up==2)dir[0]=2,dir[1]=3,U[0]=1,F[0]=3,F[1]=5,U[1]=3;
		if(up==5)dir[0]=4,dir[1]=3,U[0]=1,F[0]=3,F[1]=2,U[1]=3;
		if(up==6)dir[0]=2,dir[1]=3,U[0]=2,F[0]=3,F[1]=1,U[1]=3;
	}
	if(front==4){
		if(up==1)dir[0]=2,dir[1]=1,U[0]=2,F[0]=4,U[1]=3,F[1]=1;
		if(up==2)dir[0]=4,dir[1]=1,U[0]=1,F[0]=4,U[1]=3,F[1]=2;
		if(up==5)dir[0]=2,dir[1]=1,U[0]=1,F[0]=4,U[1]=3,F[1]=5;
		if(up==6)dir[0]=4,dir[1]=1,U[0]=2,F[0]=4,U[1]=3,F[1]=6;
	}
	if(front==5){ 
		if(up==1)dir[0]=1,dir[1]=4,U[0]=2,F[0]=1,U[1]=3,F[1]=5;
		if(up==3)dir[0]=2,dir[1]=1,U[0]=1,F[0]=5,U[1]=2,F[1]=3;
		if(up==4)dir[0]=4,dir[1]=1,U[0]=1,F[0]=5,U[1]=2,F[1]=4;
		if(up==6)dir[0]=1,dir[1]=2,U[0]=2,F[0]=6,U[1]=3,F[1]=5;
	}
	if(front==6){
		if(up==2)dir[0]=1,dir[1]=2,U[0]=1,F[0]=2,U[1]=3,F[1]=6;
		if(up==3)dir[0]=1,dir[1]=4,U[0]=1,F[0]=3,U[1]=2,F[1]=6;
		if(up==4)dir[0]=1,dir[1]=2,U[0]=1,F[0]=4,U[1]=2,F[1]=6;
		if(up==5)dir[0]=1,dir[1]=4,U[0]=1,F[0]=5,U[1]=3,F[1]=6;
	}
}

void move_dice(){
	//滚骰子 
	init();
	
	tx=x+d[dir[0]][0],ty=y+d[dir[0]][1]; //最大面 
	if(h[tx][ty]<h[x][y]){ //能滚过去就滚 
		x=tx,y=ty,
		up=U[0],front=F[0];
		
		move_dice();
		return;
	}
	
	tx=x+d[dir[1]][0],ty=y+d[dir[1]][1]; //次大面 
	if(h[tx][ty]<h[x][y]){
		x=tx,y=ty,
		up=U[1],front=F[1];
		
		move_dice();
		return;
	}
	
	++h[x][y];
	--ans[on[x][y]],++ans[up];
	on[x][y]=up; //覆盖原先的值 
}

void solve(int step){
	while(scanf("%d",&n)!=EOF){
		clear();
		
		for(int i=0;i<n;++i){
			read(up,front);
			
			x=y=100;
			move_dice();
		}
		
		write(ans+1,ans+7);
		write('\n');
	}
}
/*
Input:

Output:

Outline:

*/
int main(){ //模板，无需在意 
	#ifdef DEBUG
	freopen("test.in","r",stdin);freopen("test.out","w",stdout);
	#endif
	#ifdef more_text
	read(T);
	#endif
	for(int i=0;i<T;++i)solve(i);
	#ifdef DEBUG
	fclose(stdin);fclose(stdout);
	#endif
	return 0;
}
```

---

## 作者：olegekei (赞：1)

本题难点主要在于骰子下滚的过程，方向因为要求了字典序从大到小且仅点数 $4 \sim 6$ 方向可以下滚，所以只需要从点数 $6$ 到点数 $4$ 枚举一遍是否能下滚即可。

这里我用数组 $now$ 记录当前骰子的状态，数组 $p$ 记录当前时刻从上面看时的每个位置的点数用来统计答案，$high$ 记录骰子高度用来判断是否下滚。

说一下和 $now$ 数组有关的：$now_i$ 记录的是点数 $i$ 所在的位置，而位置我是用 $1 \sim 6$ 记录的，$1$ 是正面，$2$ 是后面，$3$ 是右面，$4$ 是左面，$5$ 是上面，$6$ 是下面。$getright$ 数组用来获取骰子右面的点数，$getinverse$ 数组用来获取骰子当前面的反面的点数。

下面说一下骰子下滚时的细节实现：

考虑一个骰子向方向 $1$（正面）下滚，那么正面滚到了下面，下面滚到了后面，后面滚到了上面，上面滚到了正面，而左面和右面是没动的，向方向 $2$ 下滚时同理。

而向方向 $3$ 下滚，则右面滚到了下面，下面滚到了左面，左面滚到了上面，上面滚到了右面，正面和后面是不动的。方向 $4$ 同理。

方向 $5$ 和方向 $6$ 则不需要考虑下滚，因为是不能下滚的。代码实现上我直接用了 $getroll$ 数组记录了四种下滚情况，省去了分类讨论。

下滚到不能再下滚则直接固定，对应的位置 $high_{x,y}+1$，更新一下 $p$ 数组即可。

最后输出时遍历一遍 $p$ 数组得到每个点数出现次数即可。
```cpp
#include<cstring>
#include<iostream>
using namespace std;
int n;
int high[100][100];//高度
int p[100][100];//上面的点数
int getright[7][7]{//得到当前骰子右面的点数
0,0,0,0,0,0,0,
0,0,3,5,2,4,0,
0,4,0,1,6,0,3,
0,2,6,0,0,1,5,
0,5,1,0,0,6,2,
0,3,0,6,1,0,4,
0,0,4,2,5,3,0
};
int getinverse[7]={0,6,5,4,3,2,1};//反面的点数
int now[7];//当前骰子状态
int stepx[5]={0,0,0,1,-1},stepy[5]={0,1,-1,0,0};
int getroll[5][7]={//向i方向下滚后骰子六个面的变化 
0,0,0,0,0,0,0,
0,6,5,3,4,1,2,
0,5,6,3,4,2,1,
0,1,2,6,5,3,4,
0,1,2,5,6,4,3
};
void roll(int goal){for(int i=1;i<=6;i++)now[i]=getroll[goal][now[i]];}
void pushdown(int x,int y){
	for(int i=6;i>=4;i--){//寻找6，5，4能够下滚的方向 
		if(now[i]>4)continue; 
		if(high[x+stepx[now[i]]][y+stepy[now[i]]]>=high[x][y])continue;//高度过高，无法下滚 
		int goal=now[i];
		roll(goal);//下滚 
		pushdown(x+stepx[goal],y+stepy[goal]);
		return;//因为下滚了所以直接return 
	}
	//否则进行固定 
	high[x][y]++;//当前点高度+1 
	for(int i=1;i<=6;i++)if(now[i]==5){p[x][y]=i;return;}//朝上的点数  
}
int tot[7];
int main(){
while(cin>>n){
	memset(high,0,sizeof high);
	memset(p,0,sizeof p);
	memset(tot,0,sizeof tot);
	while(n--){
		int above,front;
		cin>>above>>front;
		now[above]=5;now[getinverse[above]]=6;
		now[front]=1;now[getinverse[front]]=2;
		now[getright[above][front]]=3;now[getinverse[getright[above][front]]]=4;
		pushdown(50,50);//从中间点投掷骰子 
	}
	int ans=0;
	for(int i=0;i<100;i++){for(int j=0;j<=100;j++)tot[p[i][j]]++;}
	for(int i=1;i<=6;i++)cout<<tot[i]<<' ';cout<<'\n';
}
return 0;
}
```

---

## 作者：chensuibian (赞：0)

## 题目大意
- 骰子只能往 $4$，$5$，$6$ 这三个面的方向翻滚。
- 骰子只有在翻滚后会导致其下落时才会翻滚。
- 它会往数字最大的面的方向翻滚。
## 思路

**模拟即可**

开两个二维数组。一个用来存每一列的骰子数，当从 $4$，$5$，$6$ 三个方向翻转且当前列的骰子数大于目标列时，骰子可进行一次翻转。 另一个用来存当前每列骰子最上面的点数。

最后开一个 $ans$ 数组，每次不能翻转时更新答案即可。


[Code](https://www.luogu.com.cn/paste/aexaw7gg)

---

## 作者：Mier_Samuelle (赞：0)

写一个函数来模拟骰子滚动的过程，这个函数包含 $6$ 个参数，分别为当前骰子上面、前面、右面的点数，以及其 $x,y,z$ 坐标。每次滚动时，都需要从点数 $6$ 到点数 $4$ 枚举是否能滚动，如果可以，就根据滚动后骰子的参数递归调用该函数，直到不能再滚为止，此时更新“骰子堆”的顶层点数的状态，然后进入下一个骰子。

所有骰子都滚完后，把最终“骰子堆”顶层点数的状态扫一遍就能得到答案了。

关于如何通过上面和前面的点数求出右面的点数，这个其实自己拿个骰子试一试就知道了。可以给大家放张表：

```cpp
int gtr[10][10] = {{0, 0, 0, 0, 0, 0, 0},
                   {0, 0, 3, 5, 2, 4, 0},
                   {0, 4, 0, 1, 6, 0, 3},
                   {0, 2, 6, 0, 0, 1, 5},
                   {0, 5, 1, 0, 0, 6, 2},
                   {0, 3, 0, 6, 1, 0, 4},
                   {0, 0, 4, 2, 5, 3, 0}}; 
//gtr[i][j]表示分别以i,j为上面和前面的点数时，右面的点数是多少
```

### 完整代码

```cpp
#include <iostream>
#include <cstring>
using namespace std;
int h[210][210], n; //top[i][j]表示第i行第j列的高度
int mp[210][210][210]; //mp[i][j][k]表示坐标(x,y,z)骰子上层的点数
int ans[10]; //ans记录答案
int gtr[10][10] = {{0, 0, 0, 0, 0, 0, 0},
                   {0, 0, 3, 5, 2, 4, 0},
                   {0, 4, 0, 1, 6, 0, 3},
                   {0, 2, 6, 0, 0, 1, 5},
                   {0, 5, 1, 0, 0, 6, 2},
                   {0, 3, 0, 6, 1, 0, 4},
                   {0, 0, 4, 2, 5, 3, 0}}; //gtr[i][j]表示分别以i,j为上面和前面的点数时，右面的点数是多少
int drc[10]; //drc[i]表示当前点数i在骰子的哪一面 1上 2下 3左 4右 5前 6后
//roll(t,f,r,x,y,z)翻滚坐标(x,y,z)骰子，它的上前右三面分别为t,f,r
void roll(int t, int f, int r, int x, int y, int z){
    drc[t] = 1; drc[f] = 5; drc[r] = 4;
    drc[7 - t] = 2; drc[7 - f] = 6; drc[7 - r] = 3;
    bool flag = false;
    for (int i = 6;i >= 4 && flag == false;i--){ //按点数从大到小尝试滚动骰子
        if (drc[i] == 4 && h[x][y] - h[x][y + 1] >= 1){
            roll(7 - gtr[t][f], f, t, x, y + 1, h[x][y + 1] + 1);
            flag = true;
        }
        else if (drc[i] == 5 && h[x][y] - h[x + 1][y] >= 1){
            roll(7 - f, t, r, x + 1, y, h[x + 1][y] + 1);
            flag = true;
        }
        else if (drc[i] == 6 && h[x][y] - h[x - 1][y] >= 1){
            roll(f, 7 - t, r, x - 1, y, h[x - 1][y] + 1);
            flag = true;
        }
        else if (drc[i] == 3 && h[x][y] - h[x][y - 1] >= 1){
            roll(7 - i, f, 7 - t, x, y - 1, h[x][y - 1] + 1);
            flag = true;
        }
    }
    if (flag == false){
        mp[x][y][z] = t;
        h[x][y]++;
    }
}
int main(){
    while (cin >> n){
        memset(h, 0, sizeof(h));
        memset(mp, 0, sizeof(mp));
        memset(ans, 0, sizeof(ans)); //多测不清空，爆零两行泪
        while (n--){
            int t, f; //t,f分别表示骰子的上面和前面
            cin >> t >> f;
            int r = gtr[t][f]; //r表示骰子的右面
            roll(t, f, r, 100, 100, h[100][100] + 1);
        }
      	//统计答案
        for (int i = 0;i <= 200;i++)
            for (int j = 0;j <= 200;j++)
                ans[mp[i][j][h[i][j]]]++;
        for (int i = 1;i <= 6;i++)
            cout << ans[i] << " ";
        cout << endl;
    }
    return 0;
}
```

---

## 作者：machenfeng (赞：0)

#### 第一次写题解，技术有限，请各位大佬指点。
## 第一步-分析题目
题目链接 [P2139 小Z的掷骰游戏](https://www.luogu.com.cn/problem/P2139)

分析题目，我们可知，骰子滚动的规律如下：

1. 骰子只会向四五六方向滚动，且该方向滚动后必须下落，也就是说，假设当前骰子高度为t，则该方向t-1处不能有骰子或者不能为地面；

2. 骰子滚动方向顺序 应为四五六，如果都不行，则会在原地不动；

3. 还有一个隐形规则，也就是骰子不能悬空，否则本题无法AC，我掉过的坑。

### 先建立一个三维数组，存储在该空间中每个坐标是否有骰子。
### 我还建立了一个三维数组，用于存储每个坐标上的骰子顶面的数字。
```cpp
#define jz 152
bool zb[305][305][105];
int tong[8];
int dm[305][305][105];
int n;
```

然后，我们需要写一个递归函数，用于模拟骰子的滚落过程直到停止。

下面是我的代码，比较乱。
```cpp
void f(int x,int y,int t,int d,int q,int z){
	//检测是否悬空
	if(zb[x][y][t-1]!=1){
		int t = find_d(x,y)+1;
		f(x,y,t,d,q,z); //如果悬空，就落下去
		return;
	}
	
	dm[x][y][t] = d; //标记顶面数字
	zb[x][y][t] = 1; //标记此处空间有骰子了
	//printf("%d %d %d %d %d %d\n\n",x,y,t,d,q,z);
	if(q==6&&zb[x][y-1][t-1]==0){
		zb[x][y][t] = 0;
		f(x,y-1,t-1,7-q,d,z);
		return;
	}
	if(z==6&&zb[x-1][y][t-1]==0){
		zb[x][y][t] = 0;
		f(x-1,y,t-1,7-z,q,d);
		return;
	}
	if(z==1&&zb[x+1][y][t-1]==0){
		zb[x][y][t] = 0;
		f(x+1,y,t-1,z,q,7-d);
		return;
	}
	if(q==1&&zb[x][y+1][t-1]==0){
		zb[x][y][t] = 0;
		f(x,y+1,t-1,q,7-d,z);
		return;
	}
	//向 6 面方向滚动的所有可能
	
	if(q==5&&zb[x][y-1][t-1]==0){
		zb[x][y][t] = 0;
		f(x,y-1,t-1,7-q,d,z);
		return;
	}
	if(z==5&&zb[x-1][y][t-1]==0){
		zb[x][y][t] = 0;
		f(x-1,y,t-1,7-z,q,d);
		return;
	}
	if(z==2&&zb[x+1][y][t-1]==0){
		zb[x][y][t] = 0;
		f(x+1,y,t-1,z,q,7-d);
		return;
	}
	if(q==2&&zb[x][y+1][t-1]==0){
		zb[x][y][t] = 0;
		f(x,y+1,t-1,q,7-d,z);
		return;
	}
	//向 5 面方向滚动的所有可能
	
	
	if(q==4&&zb[x][y-1][t-1]==0){
		zb[x][y][t] = 0;
		f(x,y-1,t-1,7-q,d,z);
		return;
	}
	if(z==4&&zb[x-1][y][t-1]==0){
		zb[x][y][t] = 0;
		f(x-1,y,t-1,7-z,q,d);
		return;
	}
	if(z==3&&zb[x+1][y][t-1]==0){
		zb[x][y][t] = 0;
		f(x+1,y,t-1,z,q,7-d);
		return;
	}
	if(q==3&&zb[x][y+1][t-1]==0){
		zb[x][y][t] = 0;
		f(x,y+1,t-1,q,7-d,z);
		return;
	}
	//向 4 面方向滚动的所有可能
	
	//不动
	
	return; 
}
```
通过枚举数字四五六面分别在骰子侧面时的情况，如果符合，就滚动过去。

函数变量中 $x$ $y$ $t$ 分别表示当前骰子所在的 $x$ $y$ 坐标以及三维的高度，$d$ 表示顶面数字，$z$ 表示左面数字，$q$ 表示前面数字。 ~~（野鸡代码）~~

其中使用了一个函数 find_d( ) 功能就是，寻找三维空间中，xy坐标下最高的物体高度。
```cpp
int find_d(int x,int y){
	int re = 0;
	for(int i=0;i<105;i++){
		if(zb[x][y][i]) re = i;
	}
	return re;
}
```
因为每个测试点有多组数据，所以每次需要初始化（即清空数组数据）。

我写的很简陋、很垃圾，可以去看看别人的。
```cpp
void init(){
	for(int i=0;i<305;i++){
		for(int j=0;j<305;j++){
			zb[i][j][0] = 1;
		}
	} 
	for(int i=0;i<305;i++){
		for(int j=0;j<305;j++){
			for(int h = 1;h<105;h++){
				zb[i][j][h] = 0;
				dm[i][j][h] = 0;
			}
		}
	}
	for(int i=0;i<7;i++) tong[i] = 0;
}
```
循环遍历清空数组数据。

接下来就是主函数了，直接上代码。
```cpp
int main(){
	while(scanf("%d",&n)==1){
		init();
		for(int i=0;i<n;i++){
			int d,q,z;
			cin>>d>>q;
			int t = find_d(jz,jz)+1;
			//小小打表，计算左侧数字 
			if(d==6&&q==4){
				z = 2;
			}
			if(d==6&&q==3){
				z = 5;
			}
			if(d==6&&q==5){
				z = 4;
			}
			if(d==6&&q==2){
				z = 3;
			}
			
			
			if(d==5&&q==4){
				z = 6;
			}
			if(d==5&&q==3){
				z = 1;
			}
			if(d==5&&q==6){
				z = 3;
			}
			if(d==5&&q==1){
				z = 4;
			}
			
			
			if(d==4&&q==1){
				z = 2;
			}
			if(d==4&&q==2){
				z = 6;
			}
			if(d==4&&q==5){
				z = 1;
			}
			if(d==4&&q==6){
				z = 5;
			}
			
			
			if(d==3&&q==1){
				z = 5;
			}
			if(d==3&&q==2){
				z = 1;
			}
			if(d==3&&q==5){
				z = 6;
			}
			if(d==3&&q==6){
				z = 2;
			}
			
			
			if(d==2&&q==4){
				z = 1;
			}
			if(d==2&&q==3){
				z = 6;
			}
			if(d==2&&q==1){
				z = 3;
			}
			if(d==2&&q==6){
				z = 4;
			}
			
			
			if(d==1&&q==4){
				z = 5;
			}
			if(d==1&&q==3){
				z = 2;
			}
			if(d==1&&q==5){
				z = 3;
			}
			if(d==1&&q==2){
				z = 4;
			}
			
			
			//翻
			f(jz,jz,t,d,q,z); 
		}
		
		for(int i=1;i<305;i++){
			for(int j=1;j<305;j++){
				if(zb[i][j][1]){
					int t = find_d(i,j);
					tong[dm[i][j][t]]++;  //桶排计数，遍历所有空间位置，找到最顶端骰子的顶面数字并记录
				}
			}
		}
		
		for(int i=1;i<=6;i++){
			cout<<tong[i]<<" ";  //输出结果
		}
		cout<<endl;
	}
}
```
最后是完整代码。
```cpp
# include <bits/stdc++.h>
#define jz 152
using namespace std;
bool zb[305][305][105];
int tong[8];
int dm[305][305][105];
int n;
void init(){
	for(int i=0;i<305;i++){
		for(int j=0;j<305;j++){
			zb[i][j][0] = 1;
		}
	} 
	for(int i=0;i<305;i++){
		for(int j=0;j<305;j++){
			for(int h = 1;h<105;h++){
				zb[i][j][h] = 0;
				dm[i][j][h] = 0;
			}
		}
	}
	for(int i=0;i<7;i++) tong[i] = 0;
}
int find_d(int x,int y){
	int re = 0;
	for(int i=0;i<105;i++){
		if(zb[x][y][i]) re = i;
	}
	return re;
}
void f(int x,int y,int t,int d,int q,int z){
	//检测是否悬空
	
	if(zb[x][y][t-1]!=1){
		int t = find_d(x,y)+1;
		f(x,y,t,d,q,z);
		return;
	} 
	dm[x][y][t] = d;
	zb[x][y][t] = 1;
	//printf("%d %d %d %d %d %d\n\n",x,y,t,d,q,z);
	if(q==6&&zb[x][y-1][t-1]==0){
		zb[x][y][t] = 0;
		f(x,y-1,t-1,7-q,d,z);
		return;
	}
	if(z==6&&zb[x-1][y][t-1]==0){
		zb[x][y][t] = 0;
		f(x-1,y,t-1,7-z,q,d);
		return;
	}
	if(z==1&&zb[x+1][y][t-1]==0){
		zb[x][y][t] = 0;
		f(x+1,y,t-1,z,q,7-d);
		return;
	}
	if(q==1&&zb[x][y+1][t-1]==0){
		zb[x][y][t] = 0;
		f(x,y+1,t-1,q,7-d,z);
		return;
	}
	//6
	
	if(q==5&&zb[x][y-1][t-1]==0){
		zb[x][y][t] = 0;
		f(x,y-1,t-1,7-q,d,z);
		return;
	}
	if(z==5&&zb[x-1][y][t-1]==0){
		zb[x][y][t] = 0;
		f(x-1,y,t-1,7-z,q,d);
		return;
	}
	if(z==2&&zb[x+1][y][t-1]==0){
		zb[x][y][t] = 0;
		f(x+1,y,t-1,z,q,7-d);
		return;
	}
	if(q==2&&zb[x][y+1][t-1]==0){
		zb[x][y][t] = 0;
		f(x,y+1,t-1,q,7-d,z);
		return;
	}
	//5
	
	
	if(q==4&&zb[x][y-1][t-1]==0){
		zb[x][y][t] = 0;
		f(x,y-1,t-1,7-q,d,z);
		return;
	}
	if(z==4&&zb[x-1][y][t-1]==0){
		zb[x][y][t] = 0;
		f(x-1,y,t-1,7-z,q,d);
		return;
	}
	if(z==3&&zb[x+1][y][t-1]==0){
		zb[x][y][t] = 0;
		f(x+1,y,t-1,z,q,7-d);
		return;
	}
	if(q==3&&zb[x][y+1][t-1]==0){
		zb[x][y][t] = 0;
		f(x,y+1,t-1,q,7-d,z);
		return;
	}
	//4
	
	//不动
	
	return; 
}

int main(){
	while(scanf("%d",&n)==1){
		init();
		for(int i=0;i<n;i++){
			int d,q,z;
			cin>>d>>q;
			int t = find_d(jz,jz)+1;
			//打表，左侧 
			if(d==6&&q==4){
				z = 2;
			}
			if(d==6&&q==3){
				z = 5;
			}
			if(d==6&&q==5){
				z = 4;
			}
			if(d==6&&q==2){
				z = 3;
			}
			
			
			if(d==5&&q==4){
				z = 6;
			}
			if(d==5&&q==3){
				z = 1;
			}
			if(d==5&&q==6){
				z = 3;
			}
			if(d==5&&q==1){
				z = 4;
			}
			
			
			if(d==4&&q==1){
				z = 2;
			}
			if(d==4&&q==2){
				z = 6;
			}
			if(d==4&&q==5){
				z = 1;
			}
			if(d==4&&q==6){
				z = 5;
			}
			
			
			if(d==3&&q==1){
				z = 5;
			}
			if(d==3&&q==2){
				z = 1;
			}
			if(d==3&&q==5){
				z = 6;
			}
			if(d==3&&q==6){
				z = 2;
			}
			
			
			if(d==2&&q==4){
				z = 1;
			}
			if(d==2&&q==3){
				z = 6;
			}
			if(d==2&&q==1){
				z = 3;
			}
			if(d==2&&q==6){
				z = 4;
			}
			
			
			if(d==1&&q==4){
				z = 5;
			}
			if(d==1&&q==3){
				z = 2;
			}
			if(d==1&&q==5){
				z = 3;
			}
			if(d==1&&q==2){
				z = 4;
			}
			
			
			//翻
			f(jz,jz,t,d,q,z); 
		}
		
		for(int i=1;i<305;i++){
			for(int j=1;j<305;j++){
				if(zb[i][j][1]){
					int t = find_d(i,j);
					tong[dm[i][j][t]]++;
				}
			}
		}
		
		for(int i=1;i<=6;i++){
			cout<<tong[i]<<" ";
		}
		cout<<endl;
	}
}
```
成功AC。


## 本人第一次写题解，勿喷，请各位大佬指教，谢谢。

---


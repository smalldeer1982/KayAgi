# [HNOI2003] 操作系统

## 题目描述

写一个程序来模拟操作系统的进程调度。假设该系统只有一个 CPU，每一个进程的到达时间，执行时间和运行优先级都是已知的。其中运行优先级用自然数表示，数字越大，则优先级越高。

如果一个进程到达的时候 CPU 是空闲的，则它会一直占用 CPU 直到该进程结束。除非在这个过程中，有一个比它优先级高的进程要运行。在这种情况下，这个新的（优先级更高的）进程会占用 CPU，而老的只有等待。

如果一个进程到达时，CPU 正在处理一个比它优先级高或优先级相同的进程，则这个（新到达的）进程必须等待。

一旦 CPU 空闲，如果此时有进程在等待，则选择优先级最高的先运行。如果有多个优先级最高的进程，则选择到达时间最早的。


## 样例 #1

### 输入

```
1 1 5 3 
2 10 5 1 
3 12 7 2 
4 20 2 3 
5 21 9 4 
6 22 2 4 
7 23 5 2 
8 24 2 4 
```

### 输出

```
1 6
3 19
5 30
6 32
8 34
4 35
7 40
2 42
```

# 题解

## 作者：loaky (赞：93)

用优先队列q来模拟我们的cpu，最开始时，cpu中没有进程，因此，我们把第一个进程放进去，第二个进程进来时会有选择，有几种可能，要进入的进程的开始时间在前面那个进程结束时间之后，我们相当于可以直接完场此时cpu中的进程，将时间节点更新当前结束时间，第二种情况，当前cpu中进程的结束时间在要进来的这个进程开始时间之后，这是我们选择比较优先级，如果cpu中进程的优先级小，那么当前进程只会执行一半，我们算出他能够执行的时间，更新这个进程并且重新放回cpu中，并将即将进入的进程放进去，，继续等待下一步处理，当前在q中的所有进程，都已经不用管开始时间了，因为如果在q中，就表明要么已经执行过，所以在门口等待执行，要么是即将执行，他们的st都已经不存在什么意义，都已经是迫不及待等待了，所以q中的东西只用管优先级。
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
struct node{
	int id,st,re,pr;
	bool operator < (const node	&a)const{
		if(pr==a.pr)  return st>a.st;
		else return pr<a.pr;
	}
};
node c;
long long ti;
priority_queue<node>q;
int main(){
	while(scanf("%d%d%d%d",&c.id,&c.st,&c.re,&c.pr)!=EOF){
		while(!q.empty()&&ti+q.top().re<=c.st){
			node b=q.top();
			q.pop();
			printf("%d %lld\n",b.id,ti+b.re);
			ti+=b.re;
		}
		if(!q.empty()){
			node d=q.top();
			q.pop();
			d.re=d.re-c.st+ti;
			q.push(d);
		}
		q.push(c);
		ti=c.st;
	}
	while(!q.empty()){
		node f=q.top();
		q.pop();
		ti+=f.re;
		printf("%d %lld\n",f.id,ti);
	}
	return 0;
}
```

---

## 作者：zj余能 (赞：44)

我先交一发并没有的STL优先队列的题解。

其实此题要操作两个序列：

一个是还未开始的进程，另一个是按照优先级排序的等待进程；

每次做时比较两个序列的队头，如果是当前在运行的进程先结束，

则把此进程输出，并将其弹出优先队列；如果是下一个进程要开始，

则先结算当前在运行的进程的剩余时间，并将下一个进程加入优先队列；


附上清真的总共30行的代码：



```cpp
%:pragma GCC optimize(3)
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;

struct XY{int num,s,t,val;}v[1000000];
struct cmp{
    bool operator ()(XY &a,XY &b){ //定义优先级 
        return a.val<b.val||a.val==b.val&&a.num>b.num;
    }
};

int n=0,rest,cnt=1,sz=0,time;//cnt是表示下一个还未开始的进程 
priority_queue<XY,vector<XY>,cmp> Q;

int main(){
    while (scanf("%d%d%d%d",&v[n+1].num,&v[n+1].s,&v[n+1].t,&v[n+1].val)!=EOF) ++n;
    rest=n;v[n+1].s=1e9;
    while (rest!=0){ //没有吧N个进程都结束 
        if (sz==0) Q.push(v[cnt]),time=v[cnt].s,sz++,cnt++;//如果当前CPU是空的 
        XY tmp=Q.top();Q.pop();sz--; //去出优先队列中最先的 
        int last_time=time;
        time=min(v[cnt].s,last_time+tmp.t); //最近的时间点 
        if (time==last_time+tmp.t) printf("%d %d\n",tmp.num,time),rest--; //结束弹出 
                              else tmp.t-=time-last_time,Q.push(tmp),sz++;//结算 
        if (time==v[cnt].s)    Q.push(v[cnt]),sz++,cnt++; //加入新进程 
    }
    return 0;
}
```

---

## 作者：YangQuijote (赞：21)

- 这道题是一道纯模拟题；但话虽如此，却相当繁琐和注重细节上的逻辑，难度不低。

- 为简洁起见，以下文字中，将运行中的进程的结束，中途替换和加入新进程统称“事件”；优先级小的进程被优先级大的进程中途替换被称为“抢夺”。

- 首先第一时间能够想到的模拟方案是将循环的变量（比如i）设置为目前的时间点（int i=1），然后一点点地增加时间（i++），对每个时间点都判断是否会发生“事件”，并作出相应的操作。这样的模拟方法当然很稳妥，不太可能出错，代码写起来也简单，但是弱点也很明显：时间复杂度。由于题目数据并没有明确给出最后一个进程结束时间的最大值，而这种模拟方法一次循环又只对当前时间+1，循环次数很可能是一个极大的数值，将导致超时，因此这种模拟方法不可取。

- 虽然如此，但这种初步的方案却能给我们指出一种思路：将程序的注意力放在可能发生“事件”的时间点上。在初步的方案中，正是由于无法肯定什么时候会发生“事件”，因此将注意力放在了每个时间点上，才导致了时间复杂度的过大。

- 那么，什么时候可能发生“时间”呢？有当前进程结束，新进程到达，只有这两种情况有可能触发“事件”。但是，由于其中还涉及多个进程之间的“抢夺”等许多复杂的因素，我们的程序难以**平等，并行地**同时关注这两种情况的发生，因此要以其中一种情况的发生时间点为边界，观察另一种情况地发生。综合考虑下来，我们选定以当前进程的结束时间为边界，观察新进程的到达。

**（接下来的文字请和程序按照相同顺序一并阅读，各个重要变量代表的意义都有注释）**

- 在这里我们设置两个队列，一个是普通队列，另一个是以进程优先级为首要排列关键字，到达时间为次要排列关键字的优先队列。普通的队列是为了存储和使用方便，也可以使用数组代替。而优先队列则是解题的核心，而优先队列也可以使用（手写）堆代替。

- 首先，从普通队列中读入第一个进程作为当前进程。

- 接下来进入循环中。对于每个当前进程，我们先将“到达时间”在当前进程的“结束时间”之前的所有进程不断从普通队列加入优先队列（即”以当前进程的结束时间为边界，观察新进程的到达“），同时每向优先队列加入一个进程，就尝试用队首进程对当前进程进行”抢夺“（抢夺的含义见开头第二行的说明）。如果抢夺成功，则将当前进程需要的执行时间减去其已经运行了的时间，然后将其加入优先队列等待，同时将抢夺成功的优先队列队首变为当前进程。注意这时设置的边界，”当前进程的结束时间“，也随着当前进程的替换而改变，符合了模拟的逻辑。

- 对当前进程的一轮抢夺结束后，我们开始进入判断阶段。

（1）如果当前优先队列不为空。这里为了防止逻辑可能的混乱，我做了一个保险，再一次尝试用队首进程对当前进程进行一次抢夺。抢夺失败的话，就将当前进程一直执行到其结束并输出答案。由于之前已经将到达时间小于当前进程结束时间的所有进程都加入了优先队列，因此当抢夺失败后，可以肯定在当前进程结束之前不会有“事件”发生。当前进程结束后，由于我们已经设置了对每个“当前进程”都要进行一轮抢夺，因此不用考虑将普通队列队首作为下一个“当前进程”，而是直接将优先队列队首作为下一个“当前进程”即可。（因为如果将普通队列队首作为下一个“当前进程”才是正确做法的话，优先队列队首就一定会在下一次抢夺判定时遭到抢夺，因此是没有关系的）。

（2）如果当前优先队列为空。没有什么好说的，直接将普通队列队首作为下一个“当前进程”。

- 最后，由于发生抢夺时我们并不会输出任何答案，因此当普通队列中的进程已经全部出队时有一部分进程仍在优先队列中。这时候不用再考虑是否发生抢夺的问题，因为优先队列的出队顺序被我们设置成优先级大的先出。不断输出答案即可。注意当优先队列也空了的时候，仍有一个进程被作为“当前进程”而没有输出，因此要做最后的一次输出。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstdlib>
#include<queue>
#include<string>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
struct process
{
    int no,reach,time,prio;//no代表进程号，reach代表到达时间，time表示执行需要的时间，prio代表优先级
}re;
bool operator<(const process a,const process b)
{
    if(a.prio==b.prio)
    {
        return a.reach>b.reach;
    }
    else
    {
        return a.prio<b.prio;
    }
```
}//以prio为第一关键字，reach为第二关键字的优先队列
```cpp
priority_queue<process>p;
queue<process> q;
int main()
{
    int start,num,need,which,pri,mem;//which代表**当前正在执行的进程**的进程号，start代表其开始时间，mem代表其到达时间（重新入队时用到），need代表其执行需要时间，pri代表其优先级。
    while(scanf("%d",&num)!=EOF)
    {
        re.no=num;
        scanf("%d%d%d",&re.reach,&re.time,&re.prio);
        q.push(re);
    }
    which=q.front().no;
    need=q.front().time;
    pri=q.front().prio;
    start=q.front().reach;
    mem=q.front().reach;
    q.pop();
    while(q.empty()==0)
    {
        for(;q.front().reach<(start+need)&&q.empty()==0;)
        {
            p.push(q.front());
            q.pop();
            if(p.top().prio>pri)
            {
                need-=(p.top().reach-start);
                re.time=need;
                re.reach=mem;
                re.no=which;
                re.prio=pri;
                p.push(re);
                which=p.top().no;
                need=p.top().time;
                start=p.top().reach;
                mem=p.top().reach;
                pri=p.top().prio;
                p.pop();
            }
        }
        if(p.empty()==0)
        {
            if(p.top().prio>pri)
            {
                need-=(p.top().reach-start);
                re.time=need;
                re.reach=mem;
                re.no=which;
                re.prio=pri;
                p.push(re);
                which=p.top().no;
                need=p.top().time;
                start=p.top().reach;
                mem=p.top().reach;
                pri=p.top().prio;
                p.pop();
            }
            else
            {
                printf("%d %d\n",which,need+start);
                start=need+start;
                which=p.top().no;
                need=p.top().time;
                mem=p.top().reach;
                pri=p.top().prio;
                p.pop();
            }
        }
        else if(q.empty()==0)
        {
            printf("%d %d\n",which,need+start);
            which=q.front().no;
            need=q.front().time;
            pri=q.front().prio;
            start=q.front().reach;
            mem=q.front().reach;
            q.pop();
        }
    }
    while(p.empty()==0)
    {
        printf("%d %d\n",which,need+start);
        start=need+start;
        which=p.top().no;
        need=p.top().time;
        p.pop();
    }
    printf("%d %d\n",which,need+start);
    return 0;
}
```

---

## 作者：贞白铁战逸 (赞：15)

这道题的做法是模拟 + 堆。

其实模拟过程大家都有思路，问题是如何实现。

下面给大家分享我的思路：

1.由于到达时间是排好序了的，可以边输边处理。

2.对于每一个进程，结构体里定义一个hasmade（已完成的部分），便于计算。

3.保存上一个进程的到达时间，当前进程与其值之差可以用来处理当前优先级最高的进程（即改变其hasmade， hasmade满了后输出，并执行下一个进程）。

4.当进程全部到达时，进行最后处理，也很简单，按顺序累加时间即可。

PS：最重要的是不能忽略hasmade！

上代码：

```
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;
int n;
struct node
{
	int xh, begin, time, yxj, hasmade, ans;
	friend bool operator < (node a, node b)  //优先队列重载 
    {  
        if (a.yxj != b.yxj) return a.yxj < b.yxj;
        else return a.xh > b.xh;
    }
}a[2000005];
priority_queue <node> q;
int main()
{
	int i = 1, t, lt = 0;//lt保存上一个进程的到达时间，初始化为0 
	while(scanf("%d %d %d %d", &a[i].xh, &a[i].begin, &a[i].time, &a[i].yxj) != EOF)
	{
		t = a[i].begin;//t保存当前进程到达时间 
		while(!q.empty())//若CPU中还有进程在处理， 利用lt - t的时间处理 
		{
		    node p = q.top();
		    if (max(lt, p.begin) + p.time - a[p.xh].hasmade <= t) //若能在lt - t的时间内处理完，输出 
		    {
		    	a[p.xh].ans = max(lt, p.begin) + p.time - a[p.xh].hasmade;
		    	printf("%d %d\n", p.xh, a[p.xh].ans);
		    	lt = a[p.xh].ans;
		    	q.pop();
			}
			else //不然就更新一下其hasmade 
			{
				a[p.xh].hasmade += t - max(lt, p.begin);
				lt = t;
				break;
			}
		}
		q.push(a[i]);//加入当前检查 
		lt = t;
		i++;
	}
	while(!q.empty())//最后处理 
	{
		node p = q.top();
		a[p.xh].ans = max(lt, p.begin) + a[p.xh].time - a[p.xh].hasmade;
		//注意max(lt, p.begin)，晚到晚处理，早到也得等上一个进程处理完 
		printf("%d %d\n", p.xh, a[p.xh].ans);
		q.pop();
		lt = a[p.xh].ans;
	}
	return 0; 
}
```
谢谢大家！

---

## 作者：Uniecho1 (赞：13)

大家吼，我是一个懒人，不愿意仔细思考正解。

于是我就用珂朵莉树A了它。

思想很简单，把这一堆任务以优先级为第一关键字（降序），到达时间（升序）为第二关键字排一个序。那么排在后面的任务无论如何都抢不了排在前面的任务的时间。那么这个时候就用珂朵莉树来维护时间的占用情况，简单模拟即可。

关于珂朵莉树，这是一种暴力的数据结构（建立在set上），中心思想就是把一段具有相同性质的区间缩成set中的一个结点（当然这个题里就是这一秒是否被占用，用flag=1/0来表示），然后不停地分裂区间和合并区间。建议不了解的去做一做这道题 [珂朵莉树入门题](https://www.luogu.org/problemnew/show/CF896C)，别被评级吓到，不难。

然后我想说你们会发现大家一般都是先分裂右边再分裂左边，并且称之为珂学定律。这里解释一下，如果先分裂左边再分裂右边，右边有可能把左指针指向的区间又给分了，于是左指针就凉了，所以不行。

上代码，我觉得巨好懂。
```cpp
#include<bits/stdc++.h>
#define IT std::set<Node>::iterator
using namespace std;
struct node {
	long long id,s,t,p,e;
	node(long long id=0,long long s=0,long long t=0,long long p=0):id(id),s(s),t(t),p(p) {}
	friend bool operator <(node x,node y) {
		if(x.p!=y.p)return x.p<y.p;
		else return x.s>y.s;
	}
};
std::priority_queue<node>Q;
node v[1000005];
long long cnt;
struct Node {
	long long l,r;
	bool flag;
	Node(long long l=0,long long r=0,bool flag=0):l(l),r(r),flag(flag) {}
	friend bool operator <(Node x,Node y) {
		return x.l<y.l;
	}
};
std::set<Node>S;
IT split(long long pos) {
	IT x=S.lower_bound(Node(pos,0,0));
	if(x!=S.end()&&x->l==pos)return x;
	--x;
	Node u=*x;
	S.erase(x);
	S.insert(Node(u.l,pos-1,u.flag));
	return S.insert(Node(pos,u.r,u.flag)).first;
}
int main() {
	freopen("in.txt","r",stdin);
	long long id,s,t,p;
	S.insert(Node(1,LONG_LONG_MAX,0));
	ios::sync_with_stdio(false);
	while(cin>>id>>s>>t>>p)
		Q.push(node(id,s,t,p));
	while(!Q.empty()) {
		node u=Q.top();
		Q.pop();
		IT r=split(u.s+1);
		while(r->flag)++r;
		long long nl=r->l;
		while(r->flag||r->r-r->l+1<u.t) {
			if(!r->flag)u.t-=r->r-r->l+1;
			++r;
		}
		r=split(r->l+u.t);
		IT l=split(u.s+1);
		while(true) {
			IT j=l;
			l--;
			if(!l->flag) {
				l=j;
				break;
			}
		}
		long long ll=l->l,nr=r->l-1;
		S.erase(l,r);
		S.insert(Node(ll,nr,1));
		v[cnt++]=(node(u.id,0,0,nr));
	}
	sort(v,v+cnt);
	for(long long i=0; i<cnt; i++) {
		cout<<v[i].id<<" "<<v[i].p<<endl;
	}
	return 0;
}
```
ps：我是吸了氧的。不过我jio得打个快读应该就不用了吧。

---

## 作者：Register (赞：9)

### 解题思路
对于每一个时间结点，只有可能做以下的事：

1. 刚做完一个任务

	输出进程号和目前的时间

	- 当队列里有任务：找到队列里优先级最大的，进入$case3$
    
    - 队列没有任务：进入下一个任务的时间，进入$case2$
    
2. 来了新的任务

	- 停止正在进行的任务，将新的任务放进队列，取出队列里优先级最大的，进入$case3$
    
3. 正开始做一件任务

	- 若在下一个任务之前能做完：当前时间加上此任务需要的时间，把此任务弹出队列，进入$case1$
    
    - 若无法在下一个任务之前做完任务：时间减去最多能做的时间，当前时间也同样加上这么多，进入$case1$
    
题意现在非常显然了，我们可以判断一下时间复杂度：

- 每个任务最多进入队列$1$次，干扰进程$1$次，弹出队列$1$次

- 队列是优先队列

如果我们用最朴素的方法，时间需要$\Theta(NM)$（$N$为任务总个数，$M$为队列内最多有多少个元素）

这样明显是要超时的，如果我们使用$STL$的优先队列或手写堆实现，时间复杂度是$\Theta(NlogM)$，刚好能过

### 注意事项

- 如何写$STL$优先队列的比较

在结构体内首先写上以下代码（码风自行决定，只是注意不要$CE$）（$hh$为结构体名称）：

```cpp
friend bool operator < (const hh&x,const hh&y){
	
}
```

括号外相当于函数的声明，里面需要你返回一个```bool```类型的变量，一般~~正常人~~只会比较大小

若你返回这种东西```x.v<y.v```，此队列会按$v$的从大到小排列

若你返回这种东西```x.v>y.v```，此队列会按$v$的从小到大排列

即大于号会按关键字从小到大排列，小于号会按关键字从大到小排列

- 需要输出的一个进程的完成时间

若只有一个进程，开始时间为$x$，需要用$y$时间完成，则你要输出的是$x+y$，而非$x+y-1$

- 如何输入不确定数据量的数据

如果数据会有一个$flag$代表输入完了，那么你使用什么输入都可以

如果没有，推荐使用```scanf```，当没有输入后它会返回一个值```EOF```，在```int```形式下它是$-1$，即你可以判定它是否是```EOF```或$-1$来看是否将数据输入完成

当然，这方法无法在$.exe$窗格下实现

### 代码

```cpp
#include <cstdio>
#include <queue>
using namespace std;
int n,sum,now;
struct hh{
    int id,t,s,x;
    friend bool operator < (const hh&x,const hh&y){
        if(x.x!=y.x) return x.x<y.x;
        return x.t>y.t;
    }
}a[100000002]; 
priority_queue<hh> q;
inline int Min(int x,int y){
    return x<y?x:y;
}
int main(){
    while(~scanf("%d%d%d%d",&a[n+1].id,&a[n+1].t,&a[n+1].s,&a[n+1].x)) n++;
    a[n+1].t=0x7fffffff;
    for(register int i=1;i<=n;i++)
    {
        q.push(a[i]);now=a[i].t;
        while(!q.empty()&&now<a[i+1].t&&sum<n)
        {
            hh temp=q.top();q.pop();
            int x=Min(temp.s,a[i+1].t-now);
            temp.s-=x;now+=x;
            if(!temp.s) {printf("%d %d\n",temp.id,now);sum++;}
            else q.push(temp);
        }
    }
    return 0;
}
```

---

## 作者：crazydave (赞：6)

# 思路
本题思路比较明确，根据题目中有关“优先级”的操作不难想出本题主要使用优先队列。因此，我们使用优先队列依据题意进行模拟。

模拟过程中我们需要注意一些细节:

1.每当一个进程到达时，有可能打断正在进行的进程。因此我的方法时，每当新进程到达时，立即打断当前进程，运行优先级最高的进程（要么新进程，要么当前进程).

 2.整个过程完成之前CPU不会空闲，一旦一个进程完成，随即进行下一个进程。 所以只要时间有剩余，进程就不会被打断。  
 
 3.当不再有进程到达后，不会被打断，直接按照优先级模拟。

# 代码

```
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
#include <ext/pb_ds/priority_queue.hpp>
using namespace std;
struct task{  //任务进程
	int num,tim,rank;
	task (int a, int c, int d) {
		num=a,tim=c,rank=d;
	}
};
int a,b,c,d,now;
bool operator < (task x, task y) { //维护大根堆
    if(x.rank!=y.rank) return x.rank<y.rank;
    return x.num>y.num;    
}
__gnu_pbds::priority_queue <task> q; //建立优先队列 

int main()
{
	while(scanf("%d%d%d%d",&a,&b,&c,&d)!=EOF){
		while(!q.empty()){
			task top=q.top(); //还有时间剩余，进行下一个进程
			q.pop();
			if(now+top.tim<=b){ //如果有剩余时间（不被打断），正常出队
				now+=top.tim;
				printf("%d %d\n",top.tim,now);
			}
			else{ //如果剩余时间不够（被打断），剩余进程入队
				top.tim-=(b-now); //减去已经完成的进度
				q.push(top);
				break;  //没事剩余时间，跳出循环
			}
		}
		q.push(task(a,c,d)); //将进程入队
		now=b; //更新当前时间
	}
	while(!q.empty()){ //不再有进程到达
		task top=q.top();
		q.pop();
		now+=top.tim; //更新当前时间
		printf("%d %d\n",top.num, now);
	} 
	return 0;
}
```

---

## 作者：a41881147 (赞：4)

开一个变量now记录现在的时刻

考虑 对于每来的一个机器

它到来的时间x 如果足够堆顶的进程处理完,一直处理堆顶,更新now,弹出堆顶

然后现在时刻变成now'

堆顶的进程 now'和x之间还可能有一段时间,这段时间处理堆顶,更新堆顶的剩余需要的时间

然后插入push一下就行了...

push的时候,有个问题,就是遇到优先级相同的进程...

如果遇到 堆中优先级相同的进程 不是堆顶,那么到来时间早的更优,在堆中靠上的位置

如果 堆中优先级相同的进程 是堆顶,那么待插入的新来的进程就得等待...



窝木有用stl,手写的堆...并不是很难,20行+,而且快哦....

 

时间复杂度 O(m\*log(n)) m是操作数



 
 
 
 
     
 




```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 40009
using namespace std;
int lheap,x,y,z,now;
struct node{int pri,left,num,come;}heap[N];
bool pd(int x,int y)//优先级相同的 时间早的先处理
{
    return heap[x].pri>heap[y].pri||heap[x].pri==heap[y].pri&&heap[x].come<heap[y].come;
}
void push(int num,int x,int y,int z)
{
    int i=++lheap;
    heap[i].pri=z,heap[i].left=y,heap[i].num=num,heap[i].come=x;
    while (i>1)
        if (pd(i,i/2)&&i/2>=2) swap(heap[i],heap[i/2]),i/=2;//和不是堆顶的比较
            else if (i/2==1&&heap[i].pri>heap[1].pri) 和是堆顶的比较
                swap(heap[i],heap[1]),i=1;
            else return;
}
void pop()
{
    int i=1;
    printf("%d %d\n",heap[1].num,heap[1].left+now);
    now=heap[1].left+now;
    heap[1]=heap[lheap],lheap--;
    while (i*2<=lheap)
        {
            int p=i*2;
            if (p+1<=lheap&&pd(p+1,p)) p++;
            if (pd(p,i)) swap(heap[i],heap[p]),i=p;
                else return;
        }
}
int main()
{
    int i,j,k;
    while( scanf("%d%d%d%d",&i,&x,&y,&z)!=EOF)
        {
            while ( lheap&&heap[1].left<=x-now  ) 
                pop();
            if (lheap&&(x-now)) 
                heap[1].left-=(x-now);
            now=x;
            push(i,x,y,z);
        }
    while (lheap) 
        pop();
}

```

---

## 作者：寒冰大大 (赞：3)

你谷智颓给我的题。

首先不难发现，这个有优先级，优先级高的在前面，所以考虑优先队列维护进程序列。

于是考虑在上一次进程开始与第现在进程开始的这一段时间是在运行那些进程。

因为我们用优先队列维护优先级，所以直接取出队首（优先级最大）

判断它能不能在这个时间段完成，如果可以完成，那么看优先级第二，三……，如果不能完成，这段时间它还是要进行，于是我们修改它要的时间就好了。


另外在优先队列里面修改时间并不好做到，但是优先级是不会变的，因此我们优先队列只考虑优先级和编号（编号在前面说明开始时间就在前面），修改所需的时间，我们只需要存下每一个进程，将该编号对应的时间减就好了。判断是否能运行的时候有个小细节，我会在代码里面提到。（如果看不懂这一段可以看代码）

```cpp
#include<touwenjian.h>

using namespace std;

struct task{
	int st,le,co,bh;
    // st 开始时间，le 优先级
    // co 花费时间, bh 编号
	bool operator < (const task& a)
	const{
		if(a.le!=le) return le<a.le;
		else return bh>a.bh; 
	}
}a[1926514];  //由于不知道要读多少个数字，因此我们数组开大一点

priority_queue <task> q;

int main()
{
	ios::sync_with_stdio(false);
	int i=0;
	int t,lef=0;
	while(cin>>i)
	{
		cin>>a[i].st>>a[i].co>>a[i].le;
		a[i].bh=i;
		t=a[i].st; //这次任务开始的时间
		while(!q.empty())
		{
			task p=q.top();
            //lef 已经处理到的进程的时间点（在这个时间点之前的任务都进(过)了我们的优先队列）
            //之所以是max(lef,p.st)是因为怕一些任务
			if(max(lef,p.st)+a[p.bh].co<=t)  //p现在的co并不是真正的co(因为我们没有修改)
			{
				cout<<p.bh<<" "<<(max(lef,p.st)+a[p.bh].co)<<endl;
				lef=max(lef,p.st)+a[p.bh].co;
				q.pop();
			}
			else
			{
				a[p.bh].co-=(t-max(lef,p.st));
				lef=t;
				break;
                //完成这个任务的时间不够了，我们只能完成一部分，之后就没有时间了，直接break
			}
		}
		q.push(a[i]);
		lef=t;
	}
	while(!q.empty())
	{
		task p=q.top();
		lef=max(lef,p.st)+a[p.bh].co;
		cout<<p.bh<<" "<<lef<<endl;
		q.pop();
	}
	return 0;
}

```



---

## 作者：Suyun (赞：2)

我们使用一个优先队列来模拟 CPU 的多任务，将每一个进程按照优先级和到达时间排序。

将时间离散化后，不难发现只有每个进程的开始时间是有意义的。所以我们对于每个进程，在它加入优先队列前，先让时间流逝到该进程的开始时间，再将该进程加入优先队列。

在时间流逝的过程中，执行每个可以完整执行完毕的进程；对于不能完整执行完毕的进程，先让它执行到当前即将执行的进程开始执行前，并将该进程剩余未执行的部分重新加入优先队列（这时优先队列中还未执行的进程都不可以执行了）。

最后将时间流逝到 $\infty$，以执行完所有未执行的进程。

```cpp
#include <bits/stdc++.h>
using namespace std;

struct data {
  int id;
  int s, t, p;

  data(int id, int s, int t, int p) : id(id), s(s), t(t), p(p) {}

  bool operator <(data b) const {
    if (p != b.p) {
      return p < b.p;
    } else {
      return s > b.s;
    }
  }
};

priority_queue<data> q;
int ti = 0;

void time_pass(int t) {
  while (!q.empty()) {
    data d = q.top(); q.pop();
    if (t - ti < d.t) {
      d.t -= t - ti;
      q.push(d);
      break;
    } else {
      ti += d.t;
      cout << d.id << ' ' << ti << endl;
    }
  }

  ti = t;
}

int main() {
  ios::sync_with_stdio(false);

  int id, s, t, p;
  while (cin >> id >> s >> t >> p) {
    time_pass(s);
    q.emplace(id, s, t, p);
  }

  time_pass(INT_MAX);
}

```

---

## 作者：wym1111 (赞：2)

# 鬼才思路
主要思想：将每两个相邻的任务之间的时间不断分配给堆顶的任务
```cpp
 #include<bits/stdc++.h>
using namespace std;
#define ll long long
struct str{
	ll id,s,last,w;
	bool operator < (const str & tmp)const{
		if(w==tmp.w)return s>tmp.s;
		return w<tmp.w;
	}
}task,rest;
priority_queue<str>q;
int main(){
	ll a,b,c,d;
	while(scanf("%lld %lld %lld %lld",&task.id,&task.s,&task.last,&task.w)!=EOF){
		if(q.empty()){
			q.push(task);
			rest=task;
			continue;
		}
		str x=q.top();
		ll time=task.s-rest.s;
		while(x.last<=time&&!q.empty()){//分配给堆中的任务 
			time-=x.last;
			rest.s+=x.last;
			q.pop();
			printf("%lld %lld\n",x.id,rest.s);
			x=q.top();
		}
		x.last-=time;
		if(!q.empty()){
			q.pop();q.push(x);//更新 
		}
		q.push(task);
		rest=task;
	}
	int t=task.s;
	while(!q.empty()){//处理剩余的未完成任务 
		str x=q.top();
		t+=x.last;
		printf("%lld %lld\n",x.id,t);
		q.pop();
		}
	return 0;
}
```


---

## 作者：rsjw (赞：1)

一道~~大模拟~~

题面想必大家都很清楚了，一堆进程在抢占资源，除了先来后到的顺序以外，优先级大的还可以插队，空闲的时候未结束的进程会插进来占用空闲的时间。

那么，我们可以容易地想到，我们寻找这个最大的优先级需要使用堆。

这里就要涉及到一个堆的比较。如果我们选用了STL，那么我们需要处理繁杂的比较关系。要用到运算符的重载...

```cpp
struct Name{
   int data1,data2,data3;
   bool operator < (const Name &y) const{
      return this->data3 < y.data3;
   }
   bool operator > (const Name &y) const{
      return this->data3 > y.data3;
   }
};
```

没错就是这样的，上面这个结构体可以按data3比较。

那么放代码~

**代码里的注释要看哦**

```cpp
#include <cstdio>
#include <queue>
inline int min(const int &a,const int &b) {
	return a<b? a:b;
}
//&取地址直接运算，既节省空间又节约了时间
//加上一个const保证不能修改
//绝对保险
struct task {
	int k,time,y;
	bool operator<(const task &x)const {
	    if(y==x.y) return k>x.k;
	     return y<x.y;
	}
    //这里也用到了const ... & ...
	bool operator>(const task &x)const {
	    if(y==x.y) return k<x.k;
		  return y>x.y;  //运算符重载
          //注意这里还要比较优先级相等时序号优先比较
          //成员函数,this指针在这里可以省略
	}
} now;
std::priority_queue <task> q;
//默认是大根堆，刚好符合我们的需求，缺省填写即可
//小跟堆是这样的std::priority_queue <int,vector<int>,greater<int> > qq;
//当然没用
int main() {
	int a,b,c,k,tim=0;  //tim是时间节点

	while(scanf("%d%d%d%d",&k,&a,&b,&c)!=EOF) {
		while(tim<a) {
        //now是用来记录正在跑的进程，相当于一个Cpu
        //now.k=0的意思是当前CPU处于空闲状态
        //空闲时间要利用起来跑进程
			int tmp=min(now.time,a-tim);
         //这里可以避免最后一次跑不完的情况
			tim+=tmp,now.time-=tmp;
			if(now.time==0) {
         //如果进程时间跑完了
				if(now.k) printf("%d %d\n",now.k,tim);
				if(!q.empty()) now=q.top(),q.pop();
				else {
             //如果队列已空说明没有进程可以跑了，直接跑下一个
             //有上now.k=0的意思是当前CPU处于空闲状态
             //所以now.k=0
					now.k=0;
					break;
				}

			} else break;
        //空闲时间用完了也要退出
		}
		if(tim<a) tim=a;
     //其实这行可以和上面那个队列已空的合并成一句
		if(c>now.y||!now.k) {
			if(now.k) q.push(now);
			now=(task) { k,b,c };
        //插进来一个优先级大的(或者CPU空闲)
		} else {
			task tmp;
			tmp.k=k,tmp.time=b,tmp.y=c;
			q.push(tmp);
        //否则讲究先来后到
		}
	}
	while(!q.empty()) {
     //还有没做完的进程啊，还要按优先级跑进程
		tim+=now.time;
		now.time-=now.time;
		printf("%d %d\n",now.k,tim);
		now=q.top();
		q.pop();
	}
   //弹完之后多出了最后一块
	tim+=now.time;
	now.time-=now.time;
	printf("%d %d\n",now.k,tim);
   //很不美观...
	return 0;
}
```

完结撒花~



---

## 作者：Sol1 (赞：1)

STL Never dies!

这道题显然是要用堆维护这个序列，同时不能开数组：1e8肯定开不下。

2个优先队列貌似稍微有点费……其实1个就够。

首先澄清一下题意：一个进程是可以分成任意多个时间段来处理，比如一个需要9单位时间的进程，可以在时刻1~5和时刻100~103来处理。没有意识到这一点……你尽管做去吧qwq

然后怎么用堆维护呢？显然，对于每一个时间点，CPU要运行的一定是一个优先级最高的进程，所以堆要按照优先级排序，其次按照到达时间排序（这一点已经在题目中提到了）。

然后就是运行进程了。首先把第1个进程塞进优先队列。

然后，考虑第$i$个进程。

首先，当第$i$个进程到达时，可能会有一些待运行的进程的运行完成的时间$<$第$i$个进程到达的时间。在这种情况下，就可以直接把这些进程处理掉了。注意：这里，所有应该处理的进程都要从堆顶取出来，因为这些不干扰$i$进程的进程可能会互相干扰，所以要按照优先序来。

这里，有些同学可能会提问题：如果有两个进程，进程$p$和进程$q$，如果$p$的优先级比$q$的大，但是$q$可以在不干扰$i$的情况下运行而$p$不行，那不就出问题了？

答案：首先$p$和$q$一定是互相干扰的，因为如果两者不互相干扰，那么它们中的一个肯定已经被另一个处理完了。然后，因为$p$一定会限制$q$，而$p$目前还无法运行完成。所以$q$是无论如何都无法运行的，所以不会出现上述情况。

其次，把堆顶会干扰$i$的进程拉出来运行**一部分**然后再扔进队列里面，同时把$i$扔进队列里面。

正确性是可以证明的：如果第$i$个进程的优先级大于堆顶会干扰$i$的进程，那么下一个运行的进程将是$i$；否则，将会继续运行那个进程。

最后，当所有进程都已经输入了，那么就把堆里面所有的等待进程按照优先序全拉出来运行了就可以了。

但是显然，我们还需要维护一个时间戳$T$，这个$T$是要用来计算进程结束的时间。那么，当我们运行与$i$无关的进程的时候，我们需要把所有运行需要的时间全部加到$T$里面去；当我们处理第$i$个进程和堆顶进程时，$T$更新为第$i$个元素的到达时间。

于是这个东西就可以用STL的priority_queue结构来维护了。

顺便纪念一下我第一次**快读写挂**= =|||……我也是弱的没谁了qwq

paste my code(with comments)：

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <queue>
using namespace std;

//用来存储进程的结构体
struct Mission {
	long long idx, arv, poc, pri;//idx为进程编号，arv为到达时间，poc为处理时间，pri为优先级
	bool operator < (const Mission& mis) const {
		if (pri != mis.pri) {
			return pri < mis.pri;
		}
		return arv > mis.arv;
	}//优先级
};
priority_queue <Mission> que;//维护进程的优先队列
//快读快输
inline long long QuickRead() {
	long long x = 0;
	char c;
	if ((c = getchar()) == EOF) {
		return -1;
	}
	while (c < '0' || c > '9') {
		if ((c = getchar()) == EOF) {
			return -1;
		}
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		if ((c = getchar()) == EOF) {
			return -1;
		}
	}
	return x;
}

void QuickPut(long long x, bool f) {
	if (x == 0) {
		if (f) {
			putchar('0');
		}
		return;
	}
	QuickPut(x / 10, 0);
	putchar(x % 10 + 48);
}

void Solve() {
	Mission m;
	long long t = 0;//时间戳
	m.idx = QuickRead(); m.arv = QuickRead(); m.poc = QuickRead(); m.pri = QuickRead();
	t = m.arv;
	que.push(m);//处理第1个进程
	for (;;) {
		m.idx = QuickRead(); m.arv = QuickRead(); m.poc = QuickRead(); m.pri = QuickRead();
		if (m.idx == -1 || m.arv == -1 || m.poc == -1 || m.pri == -1) {
			break;//已经读入了所有进程
		}
		Mission m2;
		while (!que.empty() && t + que.top().poc <= m.arv) {//处理所有不干扰的进程
			if (que.empty()) {
				break;
			}
			m2 = que.top();
			que.pop();
			QuickPut(m2.idx, 1); 
			putchar(' ');
			QuickPut(t + m2.poc, 1);
			putchar('\n');//输出运行结果
			t += m2.poc;//更新时间戳
		}
		if (que.empty()) {//没有干扰它的进程
			que.push(m);//注意：不能直接运行，因为它可能干扰第i+1个进程同时优先级要没有它高
			t = m.arv;//还是更新时间戳
			continue;
		}
		m2 = que.top();
		que.pop();
		m2.poc -= m.arv - t;//运行一部分
		que.push(m);
		que.push(m2);//把两个进程都加入队列
		t = m.arv;//依然是更新时间戳
	}
	while (!que.empty()) {//把所有未运行的进程都拉出来运行
		Mission m = que.top();
		que.pop();
		QuickPut(m.idx, 1);
		putchar(' ');
		QuickPut(t + m.poc, 1);
		putchar('\n');
		t += m.poc;
	}
}

int main() {
	Solve();
	return 0;
}
```

清真的**正好100行**的代码！

有问题私信，不看评论qwq

---

## 作者：Sym_Je (赞：1)

          模拟＋优先队列
 * 这道题一看优先级就可以发现是一个优先队列的题，然后我们就开始模拟，怎么来模拟呢，我们先看一下范围1e8，而且我们不知道每个的时间有多大，可能+事间后，就会超最大时限，所以我们不能使用时间来一个一个加，呢咋办呢？   
 * 我们可以发现，这道题只让我们输出编号，和结束时间，就没有别的了，这样我们其实就可以不用多维护别的东西，只要看它在啥时候结束就欧克了。    
 *  所以我们考虑如何来一段时间，一段时间的来搞，我们可以发现，当一个任务完成有两种可能。   
   * 很顺利，直接从开始到结束，这要啥条件呢，就是如果下一个进来的时间-当前的时间大于等于了它要花费的时间，或者一直进来直到它被完成这一时间段的任务的优先级都比他小。   
   * 很曲折，有进来比他优先级大的，抢了他的头号，然后一直开始，结束，开始，结束，直到最后的结束。    
   
 *   我们发现1中的第一个情况很好模拟，一个if就?咯，然而第二种就有点不好模拟，但是跟2中的模拟很相似，我们就可以把他们一起搞（因为当前是把他们扔到优先队列的里，这样2个都可以满足。   
 *  我们考虑怎么扔呢，因为我们最后只要输出结束时间，别的都不需要，所以别的东西我们就可以相应做出更改。   
 *  我们设当前第一个延续时间为t1,优先级为yxj1，当前时间为t，下一个延续时间为t2,开始时间为ks2，优先级为yxj2，呢么根据上面说的，我们有两种情况，1.yxj1>yxj2 。 2...<...         
 
* 这样我们都可以扔到优先队列里，因为它返回最优的一个，这样我们考虑，如果我们把第一个扔进去，后第二个抢了它的第一，这样以后算第一个的时间就不好算咯，所以我们可以用转换法把第一个等价于在ks2的时候扔进去一个优先级为yxj1的延长时间为time1-ks2的这样以后我们就有两种方法把它输出，   
* 第一种就是通过方法1，把它扔出，第二种就是最后当他们还有在队列中的我们就可以按优先级一个一个输出咯，因为我们最后剩下的就是优先级从高到低的，没有人抢他们的位置所以只要一直更新时间，在输出就?咯  
 
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio> 
#include<string>
#include<queue>
using namespace std;

struct node
{
	int id,time,yxj;
}tmp;



bool operator <(node a,node b)//优先队列自定义就是一个大根堆。只能修改 <
{
	if(a.yxj!=b.yxj)当优先级不等还为< 说明了还为以优先级为关键字大根堆
	{
		return a.yxj<b.yxj;
	}
	return a.id>=b.id;反之变为>=就等于改为了以编号为关键字的小根堆
}
priority_queue<node> q;
int a,b,c,d,t;

int main()
{
	while(scanf("%d%d%d%d",&a,&b,&c,&d)!=EOF)
	{
		while(!q.empty())
		{
			tmp=q.top();
			q.pop();
			if(t+tmp.time<=b)
			{
				t+=tmp.time;
				printf("%d %d\n",tmp.id,t);
			}
			else
			{
				tmp.time-=(b-t);
				q.push(tmp);
				break;
			}
		}
		tmp.id=a;
		tmp.time=c;
		tmp.yxj=d;
		q.push(tmp);
		t=b;
	}
	while(!q.empty())
	{
		tmp=q.top();
		q.pop();
		t+=tmp.time; 
		printf("%d %d\n",tmp.id,t);
	}
	return 0;
}


```

这就好咯"*★,°*:.☆(￣▽￣)/$:*.°★* 。"

---

## 作者：zzkya (赞：1)

要在大牛分站交 不然最后一个点会t

```cpp
#include<cstdio>  
#include<queue>  
using namespace std;
struct dqs
{  
    int num,tim,yxj;  //进程号，执行过程时间和优先级   
}tmp;   
int n,t,a,b,c,d;  
priority_queue<dqs> q;  
bool operator < (dqs a,dqs b)  
{  
    if(a.yxj!=b.yxj) 
        return a.yxj<b.yxj;  
    return a.num>=b.num;  
}  
int main()  
{  
    while(scanf("%d%d%d%d",&a,&b,&c,&d)==4)  //进程号，到达时间，执行时间和优先级   
    {  
        while(!q.empty())  
        {  
            tmp=q.top();
            q.pop();  
            if((t+tmp.tim)<=b)  
            {  
                t+=tmp.tim;  
                printf("%d %d\n",tmp.num,t);  
            }  
            else  
            {  
                tmp.tim-=(b-t);  
                q.push(tmp);break;  
            }  
        }  
        tmp.yxj=d;
        tmp.num=a;
        tmp.tim=c;
        q.push(tmp);  
        t=b;
    }  
    while(!q.empty())  
    {  
        tmp=q.top();
        q.pop();
        t+=tmp.tim;  
        printf("%d %d\n",tmp.num,t);  
    }  
    return 0;  
}
```

---

## 作者：sqc1999 (赞：1)

这题用优先队列模拟一下就可以了，但是一定要快速读入，我用cin就TLE了

```cpp

#include<algorithm>
#include<queue>
#include<vector>
#include<cstdio>
using namespace std;
struct Process
{
    int Pid, StartTime, LastTime, Priority;
    Process(int pid, int st, int lt, int p) :Pid(pid), StartTime(st), LastTime(lt), Priority(p) {}
    bool operator <(const Process &p) const
    {
        return StartTime < p.StartTime;
    }
};
vector<Process> v;
struct Ptr
{
    int no;
    Ptr(int p) :no(p) {}
    bool operator <(const Ptr &p) const
    {
        Process &a = v[no], &b = v[p.no];
        return a.Priority == b.Priority ? a.StartTime>b.StartTime:a.Priority < b.Priority;
    }
};
int read()
{
    int x = 0, f = 1; char ch = getchar();
    while (ch<'0' || ch>'9'){ if (ch == '-')f = -1; ch = getchar(); }
    while (ch >= '0'&&ch <= '9'){ x = x * 10 + ch - '0'; ch = getchar(); }
    return x*f;
}
int main()
{
    priority_queue<Ptr> q;
    int a, b, c, d;
    while (scanf("%d", &a) != EOF)
    {
        b = read();
        c = read();
        d = read();
        v.push_back(Process(a, b, c, d));
    }
    sort(v.begin(), v.end());
    vector<Process>::iterator it = v.begin(), top;
    for (int t = 1;;)
    {
        if (!q.empty() && top->LastTime == 0)
        {
            printf("%d %d\n", top->Pid, t);
            q.pop();
            if (!q.empty()) top = v.begin() + q.top().no;
        }
        if (it != v.end() && it->StartTime == t)
        {
            q.push(Ptr(it - v.begin()));
            top = v.begin() + q.top().no;
            it++;
        }
        if (q.empty() && it == v.end()) break;
        if (q.empty())
        {
            t = it->StartTime;
        }
        else if (it == v.end())
        {
            t += top->LastTime;
            top->LastTime = 0;
        }
        else
        {
            int dt = min(it->StartTime - t, top->LastTime);
            t += dt;
            top->LastTime -= dt;
        }
    }
}

```

---

## 作者：御坂御坂 (赞：1)

看到没有pas的so来一发


**赤裸裸**的模拟啊，为了不**TLE**所以要加个堆优化


维护一个**最大堆**


代码如下

```cpp
type prog=
    record
        pid,start,time,level:longint;
    end;
var 
    h:array[1..15001] of prog;
    now,size,pid,start,time,level:longint;
    t:prog;
function cmp(x,y:prog):boolean;//比较函数
begin
    if x.level>y.level then exit(true);//优先级高的在前
    if (x.level=y.level)and(x.start<y.start) then exit(true);//如果优先级相等先到先来
    exit(false);
end;
procedure swap(x,y:longint);//交换函数
var t:prog;
begin
    t:=h[x];
    h[x]:=h[y];
    h[y]:=t;
end;
procedure up(i:longint);//堆-向上调整
var flag:boolean;
begin
    if i=1 then exit();
    flag:=true;
    while (i<>1)and(flag) do
    begin
        if cmp(h[i],h[i div 2]) then 
            swap(i,i div 2)
        else
            flag:=false;
        i:=i div 2;
    end;
end;
procedure down(i:longint);//堆-向下调整
var t:longint;
    flag:boolean;
begin
    flag:=true;
    while ((i*2)<=size)and(flag) do
    begin
        t:=i;
        if cmp(h[i*2],h[i]) then t:=i*2;
        if ((i*2+1)<=size) then
            if cmp(h[i*2+1],h[t]) then t:=i*2+1;
        if t<>i then
        begin
            swap(i,t);
            i:=t;
        end else
            flag:=false;
    end;
end;
function pop():prog;//取堆顶函数，也就是取优先级最高先到的那个进程
var t:prog;
begin
    t:=h[1];
    h[1]:=h[size];
    size:=size-1;
    down(1);
    exit(t);
end;
begin
    now:=0;//现在时间
    while not eof do //读到文件结束 "eof": End Of File
    begin
        readln(pid,start,time,level);
        //优化-如果下一个来的时间之前当前进程能处理完
        while (size>0)and(h[1].time<=start-now) do
        begin
            t:=pop();
            inc(now,t.time);
            writeln(t.pid,' ',now);
        end;
        //优化 处理完时 如果至下一个进程到来还有时间则跳过
        if (size>0)and((start-now)>0) then 
            dec(h[1].time,start-now);
        now:=start;//更新现在时间
        //优化-堆
        inc(size);
        h[size].time:=time;
        h[size].start:=start;
        h[size].pid:=pid;
        h[size].level:=level;
        up(size);
    end;
    //执行最后几个进程
    while (size>0) do 
    begin
        t:=pop();
        inc(now,t.time);
        writeln(t.pid,' ',now);
    end;
end.
```

---

## 作者：Macesuted (赞：0)

[题面](https://www.luogu.com.cn/problem/P2278)

原来是道大水题，但是它的题面有点意思，于是我就手残把它加进了解题计划中。

## 题面描述
对于操作系统，我们只拥有一个CPU，只能同时处理一个任务。现在有很多任务需要操作系统解决，它们将按照产生时间输入。

每个任务都需要一定时间完成，并且每个任务都有一个优先级和产生时间。当它们产生时，如果CPU空闲，那么会直接处理这个任务，如果CPU忙碌但当前正在执行的任务的优先级没有它高，会中断当前任务的执行，优先执行该任务。如果上述条件均不满足，该任务会进入等待队列。

对于CPU，当当前任务运行完后将会从队列中取出优先值最高的任务，并且立刻开始运行该任务。并且对于一个被中断的任务，当它被再次运行时只需从中断出开始运行即可，无需重新开始。
## 分析
考虑到CPU在空闲时会从等待队列中取出优先值最高的那个任务开始运行，所以很显然这就是个优先队列。只要让优先队列将优先值最高的那个任务一直放在堆顶就可以了。

对于刚出现的每一个任务，我们直接将它放进队列，然后在下一个任务出现前不断地挨个处理程序。如果一个程序在运行到一半的时候被中断，那么保存剩余运行时间为总运行时间后将它重新压回队列。
## 代码
我们使用结构体来存放每个任务的信息。
```cpp
struct task
{
	int number;//任务编号
	int need;//需要时间
	int get;//出现时间
	int grade;//优先级
	inline bool operator < (const task &b) const
	{//给优先队列提供的运算符，我们会将优先级高的，或者是优先级相同但来的更早的任务放到堆顶
		return this->grade<b.grade||(this->grade==b.grade&&this->get>b.get);
	}
};
```
然后是优先队列
```cpp
std::priority_queue<task,std::vector<task>,std::less<task>> wait;
```
最后就是主函数了
```cpp
int main()
{
	int num,get,times,grade;
	int time=-1;
	while(scanf("%d%d%d%d",&num,&get,&times,&grade)!=EOF)
	{
		while((!wait.empty())&&time+wait.top().need<=get)
		{
			time+=wait.top().need;
			printf("%d %d\n",wait.top().number,time);
			wait.pop();
		}
		if(!wait.empty())
		{
			task cache=wait.top();
			wait.pop();
			cache.need-=get-time;
			wait.push(cache);
		}
		wait.push({num,times,get,grade});
		time=get;
	}
	while(!wait.empty())
	{
		time+=wait.top().need;
		printf("%d %d\n",wait.top().number,time);
		wait.pop();
	}
	return 0;
}
```
我们最开始使用一个$time$来存放当前运行到的时刻。每一次读入一个任务的时候，意味着从$time+1$时刻到当前出现的一刹那这段时间都不会被打断。在这段时间内我们不断地取出一个任务，并试着完成它，并用最后余留下来的一点时间来完成部分的任务，然后把这个完成一部分的任务放回队列，在此时输入的那组任务就正式出现，我们直接将它放入队列，并且把$time$设为当前时刻。然后在所有的任务输入完之后逐个完成剩下所有的任务，就是最后一个while循环所在做的。

这样，这道题就结束了。

[本题完整代码](https://www.luogu.com.cn/blog/Kysic-Studio/code-P2278)

---

## 作者：panyf (赞：0)

此题中并没有给出输入文件的总行数，所以建议不开数组，边读入边操作。

此题是很明显的堆+模拟，需要分几种情况讨论：

1.输入一个进程后，如果堆不为空，先处理从上一个进程的开始时间到此进程的开始时间运行的所有进程，将运行结束的进程输出并出堆

2.如果堆为空，直接将当前进程加入堆，continue

3.如果堆仍不为空，比较当前进程与堆顶进程的优先级，如果堆顶进程优先级高，将当前进程加入堆，continue

4.如果当前进程优先级高，则将当前进程放入堆，堆顶进程继续等待

输入文件结束后，需要处理堆中剩余的进程，直到堆为空再结束程序

代码（超简短，仅20行）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int id,a,b,c,t;//t为上一个进程的开始时间
struct jc{
	int id,a,b,c;
}p,q;//id为序号，a为开始时间，b为运行时间，c为优先级，p存储当前进程，q用于修改堆顶进程
bool operator <(jc x,jc y){
	return x.c==y.c?x.a>y.a:x.c<y.c;
}//比较优先级，优先级相同则比较开始时间
priority_queue<jc>h;//堆
int main(){
	while(scanf("%d%d%d%d",&id,&a,&b,&c)!=EOF){//循环读入
		p.a=a,p.b=b,p.c=c,p.id=id;
		while(!h.empty()&&a-t>=h.top().b)t+=h.top().b,printf("%d %d\n",h.top().id,t),h.pop();//处理从上一个进程开始时间到此进程开始时间运行的所有进程
		if(h.empty())t=a,h.push(p);//堆空
		else if(p<h.top())h.push(p);//堆顶进程优先级高
		else q=h.top(),h.pop(),q.b-=a-t,h.push(q),h.push(p),t=a;//当前进程优先级高，则修改堆顶进程剩余时间，再将堆顶进程和当前进程都入堆
	}
	while(!h.empty())t+=h.top().b,printf("%d %d\n",h.top().id,t),h.pop();//处理输入结束后剩余的进程
}
```


---

## 作者：木木！ (赞：0)

思路的话楼上的dalao已经讲得很清楚了。

维护一个curt和cput，然后用堆维护进程执行顺序。

这里分享一个小trick，如果直接`pq.top().xxx = xxx`的话，会CE，因为这个变量返回的是一个只读的东西。

所以，我们可以通过`T* t = (T*)((void*)&pq.top())`将其转成可以读写，然后`t->xxx = xxx`（详见代码）

注意，xxx不能参与排序，否则会破坏堆的性质。实测能AC。

```cpp
#include <queue>
#include <cstdio>
using namespace std;

struct line
{
	int art;
	int lev;
	int contin; //还剩余的时间
	int id;
};

class pqcmp
{
public:
	bool operator()(line a,line b)
	{
		if(a.lev != b.lev)
		{
			return a.lev < b.lev;
		}
		return a.art > b.art;
	}
};

inline line makel(int id,int art,int runt,int lev)
{
	line nl;
	nl.id = id;
	nl.art = art;
	nl.contin = runt;
	nl.lev = lev;
	return nl;
}

int main()
{
	priority_queue<line,vector<line>,pqcmp> pq;
	
	int curt = 0;
	int cput = 0;
	int i,a,r,l;
	while(scanf("%d%d%d%d",&i,&a,&r,&l)!=EOF)
	{
		curt = a;
		
		while(cput < curt)
		{
			if(pq.empty())
			{
				cput = curt;
				break;
			}
			if(cput + pq.top().contin <= curt)
			{
				cput += pq.top().contin;
				printf("%d %d\n",pq.top().id,cput);
				pq.pop();
			}
			else
			{
				line *t = (line*)((void*)&pq.top()); //trick
				t->contin -= curt-cput; //注意，这里contin没有参与排序才能这么用
				
				cput = curt;
				
				break;
			}
		}
		
		pq.push(makel(i,a,r,l));
	}
	
	curt = 0x7f7f7f7f;
	
	while(cput < curt)
	{
		if(pq.empty())
		{
			break;
		}
		else
		{
			cput += pq.top().contin;
			printf("%d %d\n",pq.top().id,cput);
			pq.pop();
		}
	}
	
	return 0;
}
```

在工程里用这个技巧？死几千次都不够。

---

## 作者：蒟蒻zExNocs (赞：0)

这么标准的优先级，很明显这个题就是用堆来维护每一个程序的处理时间了。

不过本题有个要求，就是cpu空闲时，如果有多个优先级最高的进程，则选择到达时间最早的。也就是指当优先级相等时，使id最小的处于堆顶。

由于stl优先队列堆默认是大跟堆（即最大的在堆顶），那么只需要将默认的小于号在判断时改成大于号就变成小根堆了。
```cpp
struct node
{
	int id,ti,le;
    //在本题分别对应进程号、剩余执行时间、优先级。
	bool operator < (const node &a) const
	{
		if(le==a.le) return id>a.id;//id更小的在堆顶
		else return le<a.le;//优先级跟高的在堆顶
	}
｝
priority_queue<node>heap; 

```

~~由于把到达时间最早看成执行时间最短送出一血~~

那么会造堆后，剩下的就是模拟了。

为了方便，可以在每次程序达到的时候进行一次性处理cpu（及堆里）里的以前未处理的程序，那么可以定义一个变量为now,cuse，第一个是目前处理某一数据处于的时间，第二个为在now和到达新程序之间可以使用的时间。每次处理堆顶程序的时候判断cuse和该程序的ti，如果now>=ti,也就是说在到达新程序之前这个程序就已经处理完毕了，输出id和now，并更新now和cuse，now=now+ti，cuse=cuse-ti，然后再进行判断下一个堆顶。

如果now<it,那么就让目前堆顶处理时间减去now，使now=0，now=当前时间点。

当所有程序都到达完毕后，那么就直接按堆的顺序输出就可以了。

蜜汁码风的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

int read(){
	char c=getchar();int a=0;bool f=0;
	while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}
	while(c>='0'&&c<='9') a=(a<<1)+(a<<3)+(c^48),c=getchar();
	return f?-a:a;
}
int pr(int a)
{
	if(a<0){putchar('-');a=-a;}
	if(a>=10) pr(a/10);
	putchar(a%10+'0');
}
struct node
{
	int id,ti,le;
	bool operator < (const node &a) const
	{
		if(le==a.le) return id>a.id;
		else return le<a.le;
	}
	node(int id,int ti,int le):id(id),ti(ti),le(le){}
	node(){}
};
priority_queue<node>heap; 
int i,now=0,cuse=0,t,ti,le;
node it;
bool f=0;
int main()
{
	while(scanf("%d",&i)!=EOF)
	{
		t=read(),ti=read(),le=read(),cuse=(t-now);
		if(!heap.empty()) it=heap.top();
		while(!heap.empty()&&cuse>=it.ti&&now+it.ti<=t)
		{
			now+=it.ti;
			cuse-=it.ti;
			pr(it.id);putchar(' ');pr(now);putchar('\n');
			heap.pop();
			if(!heap.empty()) it=heap.top();
		}
		if(!heap.empty()&&cuse)
		{
			it=heap.top();
			heap.pop();
			heap.push(node(it.id,it.ti-cuse,it.le));
		}
		heap.push(node(i,ti,le));
		now=t;
	}
	while(!heap.empty())
	{
		it=heap.top();
		pr(it.id);putchar(' ');pr(now+it.ti);putchar('\n');
		now+=it.ti;
		heap.pop();
	}
}
```


---

## 作者：Rbrq (赞：0)

主要思路:模拟，优先队列

考虑维护一个优先队列，重载小于号，对于这个小于号的定义为如果两个工作等级相同，那么按照到达时间先后排序，否则按照工作等级高低排序

然后每输入一个工作，考虑在这个工作执行之前所有可以被完成的工作，当已经不存在可以被完成的工作但队列非空的时候，表示目前的工作只能被完成一部分，那么处理这个部分并更新当前时间和这个工作完成需要的时间

对于在输入结束后还没有被完成的工作，其已经在优先队列中按照顺序排序，只需要从队头开始完成并输出即可

注意点:

1.优先队列中定义的是小于号，相关大小比较需要相反

2.scanf在成功输入时的返回值是输入个数，失败时返回值是-1；

```cpp

#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
struct node{
    int id,rea,nee,lev;
    bool operator <(const node &rhs) const{
        return lev==rhs.lev?rea>rhs.rea:lev<rhs.lev;
    }
};
node pre;
int a,b,c,d,tnow=0;
priority_queue<node>q;
int main(){
    while(scanf("%d %d %d %d",&a,&b,&c,&d)!=EOF){
        pre.id=a; pre.rea=b;
        pre.nee=c;pre.lev=d;
        while(!q.empty()&&tnow+q.top().nee<=pre.rea){
            node fr=q.top();
            q.pop();
            printf("%d %d\n",fr.id,fr.nee+tnow);
            tnow+=fr.nee;
        }
        if(!q.empty()){
            node fr=q.top();
            q.pop();
            fr.nee=fr.nee-pre.rea+tnow;
            q.push(fr);
        }
        q.push(pre);
        tnow=pre.rea;
    }    
    while(!q.empty()){
        node fr=q.top();
        q.pop();
        tnow+=fr.nee;
        printf("%d %d\n",fr.id,tnow);
    }
    return 0;
}

````

---

## 作者：EkiXu (赞：0)

显然考虑用优先队列模拟，为了离散时间，降低复杂度，当加入一个新任务时再更新局面

若队首任务可以在新任务到达前完成 则直接弹出并输出

若不可以，则消耗掉在新任务来之前的时间（时间快进大法）然后加入新任务

最后慢慢把所有剩下的输出就行了


> 注意：排序和比较操作都在已在“cpu”内部进行了

```cpp
#include<cstdio>
#include<cstring>
#define MAXL 20000
template <typename T>
inline void Swap(T &_a,T &_b){
	T t=_a;_a=_b,_b=t;
}
template <typename T>
struct Heap{
	T a[MAXL+10];int tail;
	Heap():tail(0){}
	void Insert(const T _x){
		a[++tail]=_x;
		int p=tail;
		while(p>1&&a[p]<a[p>>1]) Swap(a[p],a[p>>1]),p>>=1;
	}
	void Pop(void){
		if(tail==0) return ;
		a[1]=a[tail--];
		int p=2;
		while(p<=tail){
			if(a[p+1]<a[p]) p++;
			if(a[p]<a[p>>1]) Swap(a[p],a[p>>1]);else break;
			p<<=1;
		}
	}
	const T Top(void){
		return a[1];
	}
	const bool Empty(void){
		return tail==0;
	}
};
struct Task{
	int id,priority,startTime,usingTime;
	Task(){}
	Task(int _id,int _startTime,int _usingTime,int _priority):id(_id),priority(_priority),startTime(_startTime),usingTime(_usingTime){}
	friend bool operator < (Task a,Task b){
		if(a.priority==b.priority) return a.id<b.id;
		return a.priority>b.priority;
	}
};
Heap<Task> cpu;
int main(){
	int a,b,c,d,now=0;
	Task u,v;
	while(~scanf("%d%d%d%d",&a,&b,&c,&d)){
		u=Task(a,b,c,d);
		while(!cpu.Empty()){
			v=cpu.Top();cpu.Pop();
			if(now+v.usingTime<=u.startTime) {
				now+=v.usingTime;
				printf("%d %d\n",v.id,now);
			}else {
				v.usingTime-=u.startTime-now;
				cpu.Insert(v);
				break;
			}
		}
		cpu.Insert(u);
		now=u.startTime;
	}
	while(!cpu.Empty()){
		u=cpu.Top();cpu.Pop();
		now+=u.usingTime;
		printf("%d %d\n",u.id,now);
	}
	return 0;
}
```
毫不要脸的贴上原博客(本人)地址：[https://oi.ozem.xyz/Luogu/p2278.html](https://oi.ozem.xyz/Luogu/p2278.html)

---

## 作者：Rapiz (赞：0)

基本上是模板题

存每个任务的开始时间和剩余时间。

每次取出堆顶元素，完成一个任务前判断一下在当前时间和完成时间之中有没有新任务出现，如果没有就处理。如果有就先到达下个任务的时间，更新剩余时间。

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
#define fa (o>>1)
using std::swap;
using std::vector;
using std::max;
const int SZ=15010;
struct TASK{int pid,at,dt,pri;
TASK(int a,int b,int c,int d):pid(a),at(b),dt(c),pri(d){}
bool operator<(const TASK& rhs)const {
    if(pri==rhs.pri) return at>rhs.at;
    return pri<rhs.pri;
}
bool operator>(const TASK& rhs)const {
    if(pri==rhs.pri) return at<rhs.at;
    return pri>rhs.pri;
}
};
vector<TASK> vec;
struct HP{
    int st[SZ<<2],sz;
    void up(int o){
        while(o>1){
            if(vec[st[o]]>vec[st[fa]]) swap(st[o],st[fa]),o=fa;
            else break;
        }
    }
    void down(int o){
        while((o<<1)<=sz){
            int mxch=o<<1;
            if(mxch<sz&&vec[st[mxch]]<vec[st[mxch+1]]) mxch++;
            if(vec[st[o]]<vec[st[mxch]]) swap(st[o],st[mxch]),o=mxch;
            else break;
        }
    }
    void in(int iid){
        st[++sz]=iid;
        up(sz);
    }
    int pop(){
        int ret=st[1];
        swap(st[1],st[sz]);
        sz--;
        down(1);
        return ret;
    }
}hp;
long long nowt;
void show(int iid){
    printf("Time %lld : pid %d left:%d\n",nowt,vec[iid].pid,vec[iid].dt);
}
int main(){
    int a,b,c,d;
    while(scanf("%d%d%d%d",&a,&b,&c,&d)!=EOF) vec.push_back(TASK(a,b,c,d));
    for(int i=0;i<vec.size();i++){
        hp.in(i);
        nowt=max(nowt,(long long)vec[i].at);
        while(hp.sz){
            int top=hp.st[1];
            //show(top);
            if(i+1<vec.size()){
                if(nowt+vec[top].dt<=vec[i+1].at)
                    printf("%d %lld\n",vec[top].pid,nowt+=vec[top].dt),hp.pop();
                else {
                    vec[top].dt-=vec[i+1].at-nowt;
                    nowt=vec[i+1].at;
                    hp.in(++i);
                }
            }
            else printf("%d %lld\n",vec[top].pid,nowt+=vec[top].dt),hp.pop();
        }
    }
}
```

---

## 作者：Mr_Li (赞：0)

应用优先队列的确是一可行的算法，但这道题还可以用堆。

先初始化一个存储进程的堆，令堆为空，i=0。然后让程序做以下步骤n（n为进程数）次：

1、让i增加1；

2、若堆不为空且堆顶进程能在第i个进程到达前运行完毕，则输出运行结束时间并删除此进程元素，然后重复此步骤直到堆为空或堆顶进程不能在第i个进程到达前运行完毕（可以设置一个变量记录当前时间和进程运行时间）；

3、将进程i入堆。

当然，加入或删除元素之后要调整堆。最后，让程序重复做一下步骤直至堆为空：

1、输出运行结束时间；

2、删除此进程元素。

同样的，每重复之后都要调整堆。显然，此算法是可行的。时间复杂度为O(nlogn)，空间复杂度为O(n)。

附代码：

```cpp

#include<iostream>
using namespace std;
struct attribute
{
       int number,arrive,surplus,level;
};
struct list
{
       attribute process[300002];
       int n;
}in,heap;
int i,end,now;
bool compare (attribute first,attribute last)
{
     return first.level>last.level||first.level==last.level&&first.arrive<last.arrive;
}
void heapify (int No)
{
     if (compare(heap.process[No*2],heap.process[No])&&No*2<=heap.n&&(compare(heap.process[No*2],heap.process[No*2+1])||No*2+1>heap.n))
     {
                                                                                                                                        swap(heap.process[No],heap.process[No*2]);
                                                                                                                                        heapify(No*2);
     }
     else
     if (compare(heap.process[No*2+1],heap.process[No])&&No*2+1<=heap.n)
     {
                                                                       swap(heap.process[No],heap.process[No*2+1]);
                                                                       heapify(No*2+1);
     }
}
void insert (int No)
{
     if (compare(heap.process[No],heap.process[No/2])&&No>1)
     {
                                                            swap(heap.process[No/2],heap.process[No]);
                                                            insert(No/2);
     }
}
int main ()
{
    freopen(".in","r",stdin);
    freopen(".out","w",stdout);
    for (in.n=1;scanf("%d %d %d %d",&in.process[in.n].number,&in.process[in.n].arrive,&in.process[in.n].surplus,&in.process[in.n].level)>0;in.n++);
    in.n--;
    heap.n=0;
    in.process[i-1].arrive=0;
    for (i=1;i<=in.n;i++)
    {
        heap.process[1].surplus-=in.process[i].arrive-in.process[i-1].arrive;
        end=in.process[i].arrive+heap.process[1].surplus;
        while (heap.process[1].surplus<=0&&heap.n>0)
        {
              cout<<heap.process[1].number<<' '<<end<<endl;
              heap.process[1]=heap.process[heap.n];
              heap.n--;
              heapify(1);
              heap.process[1].surplus-=in.process[i].arrive-end;
              end=in.process[i].arrive+heap.process[1].surplus;
        }
        end=in.process[i].arrive;
        heap.n++;
        heap.process[heap.n]=in.process[i];
        insert(heap.n);
    }
    now=end;
    for (;heap.n>=1;heap.n--)
    {
        now+=heap.process[1].surplus;
        cout<<heap.process[1].number<<' '<<now<<endl;
        heap.process[1]=heap.process[heap.n];
        heapify(1);
    }
    return 0;
}

```

---


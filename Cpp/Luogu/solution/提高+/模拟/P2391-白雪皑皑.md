# 白雪皑皑

## 题目背景

“柴门闻犬吠，风雪夜归人”，冬天，不期而至。千里冰封，万里雪飘。空中刮起了鸭毛大雪。雪花纷纷，降落人间。 美能量星球（pty 在 spore 上的一个殖民地）上的人们被这美景所震撼。但是 pty 却不高兴，他不喜欢白色的世界，他觉得这样太单调了。所以他想对雪花进行染色，让世界变得多彩些。


## 题目描述

现在有 $n$ 片雪花排成一列。 pty 要对雪花进行 $m$ 次染色操作，第 $i$ 次染色操作中，把第 $((i\times p+q)\bmod n)+1$ 片雪花和第 $((i\times q+p)\bmod n)+1$ 片雪花之间的雪花（包括端点）染成颜色 $i$。其中 $p,q$ 是给定的两个正整数。他想知道最后 $n$ 片雪花被染成了什么颜色。没有被染色输出 $0$。

## 说明/提示

- 对于 $20\%$ 的数据满足：$n,m\leq 1000$。
- 对于 $40\%$ 的数据满足：$n\leq 8000$，$m\leq 10^6$。
- 对于 $80\%$ 的数据满足：$n\leq 5\times 10^5$，$m\leq 10^7$。
- 对于 $100\%$ 的数据满足：$1\leq n\leq 10^6$，$1\leq m\leq 10^7$。

保证 $1\leq m\times p+q,m\times q+p\leq 2\times 10^9$。

## 样例 #1

### 输入

```
4
3
2
4```

### 输出

```
2
2
3
0```

# 题解

## 作者：zsaskk (赞：40)

**并查集维护序列连通性**的一道好题。

我们知道，并查集可以维护图的连通性，当然类比到序列上也是可行的。

在图上，$fa[x]=fa[y]$，则称$x,y$连通。

而在这道题中，可以用$fa[x]$表示$x$后第一个可操作的节点。

考虑题目含义，一个雪花的颜色是它最后被染上的颜色。

我们可以倒序枚举染色操作，在染色区间内进行跳跃染色，并维护连通性。

[类似题目](https://www.luogu.com.cn/problem/P4145)

这道题目~~暴力可过~~，但是如果是上面推的那道题，一个点可以多次操作，暴力~~大概率过不了~~。

```
//fa[i]表示，i前面第一个没染色的雪花
#include<bits/stdc++.h>
using namespace std;
#define reg register
inline int read(){
    reg char c;reg int f=1,x=0;
    while(!isdigit(c)) { if(c=='-') f=-1;c=getchar(); }
    while(isdigit(c)) { x=x*10+c-'0';c=getchar(); }
    return x*f;
}
int n,m,p,q,fa[1000001],col[1000001];
inline int myfind(int x){ if(x==fa[x]) return x;return fa[x]=myfind(fa[x]); }
int main(){
    n=read(),m=read(),p=read(),q=read();
    for(reg int i=1;i<=n;++i) fa[i]=i;
    for(reg int i=m;i>=1;--i){//依照题意，倒序染色（颜色以最后一次染上的颜色为准）
        int l=(i*p+q)%n+1,r=(i*q+p)%n+1;
        if(l>r) swap(l,r);
        for(reg int j=r;j>=l;){
            int t=myfind(j);
            if(t==j){
                col[j]=i,fa[j]=myfind(j-1)/*维护连通性*/;
            }j=fa[j];//直接跳到下一个可染色的点
        }
    }
    for(reg int i=1;i<=n;++i) printf("%d\n",col[i]);
}
```

再推荐一道题，需要与贪心结合。

[supermarket](https://www.luogu.com.cn/problem/UVA1316)


---

## 作者：Bay_Max (赞：23)

ps:这篇题解一定请过QAQ！！！原因很简单，洛谷数据过水，90%A了的题解其实都是有问题的！！！（本人在本地测了很多组合法数据，几乎所有题解都要1s以上，而本篇题解0.5s左右）

方法：双向链表+缩点

首先很多dalao都说过了，要从后往前染色，遇见染过色的就不管它。但是，这样其实会浪费很多时间，是要T的。

所以我们考虑，在染色的同时，把染过色的区间缩为一个点，这样就能大大节省时间。因为是线性，所以我们采取链表。

之前已经有dalao发过链表的题解了，但是他只将染过色的区间的左右端点连在一起，而中间的点还是没有变化，这样就会造成很多不必要的运算。本题解在此基础上改进，将中间点也直接与左右端点相连，效率为假O（n）（就是很逼近O（n））；

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define R register
using namespace std;
int n,m,color[1000010],pre[1000010],nxt[1000010],p,q;
template <typename T> void in(R T &a)
{
    R char c = getchar();R T x=0,f=1;
    while(!isdigit(c)) {if(c == '-') f=-1; c=getchar();}
    while(isdigit(c)) x=(x<<1)+(x<<3)+c-'0',c = getchar();
    a=x*f;
}
int main()
{
	//freopen("color.in","r",stdin);
	//freopen("color.out","w",stdout);
	in(n),in(m),in(p),in(q);
	for(R int i=1;i<=n;i++)
	{
		nxt[i]=i+1;//链表初始化
		pre[i]=i-1;
	}
	for(R int i=m;i>=1;i--)//从后往前
	{
		R int l=(i*p+q)%n+1,r=(i*q+p)%n+1;//计算左右端点
        if(l>r) l^=r,r^=l,l^=r;
        R int now=l;
        while(now<=r)//敲黑板！！！
        {
        	R int temp=0;//如果没染过色，就染色、将该点与区间左右端点相连，记录原本的下一个位置为temp
            if(!color[now]) color[now]=i,pre[now]=pre[l],temp=nxt[now],nxt[now]=nxt[r];
            temp==0?now=nxt[now]:now=temp;//temp不为零，则跳到原本的下一个点；为零，则说明该点已经染过色（就是已经缩过点，直接跳到缩点后的下一个端点）
        }
	}
	for(R int i=1;i<=n;i++) printf("%d\n",color[i]);
	return 0;
}
/*
4 3 2 4
*/
```

---

## 作者：米奇奇米 (赞：18)

# 正解当然是并查集，但是我竟然用暴力过啦，莫名其妙！！
### 还不是卡过去的
## 时间复杂度O（n*m）正常情况过不去
```cpp
#include<bits/stdc++.h>
using namespace std;
#define dd c=getchar()
int read(){int s=0,w=1;char c;while (dd,c>'9' || c<'0') if (c=='-') w=-1;while (c>='0' && c<='9') s=s*10+c-'0',dd;return s*w;}
#undef dd
void write(int x) {if (x<0) putchar('-'),x=-x;if (x>=10) write(x/10);putchar(x%10|'0');}
void wln(int x) {write(x);puts("");}//必须要开各种读入输出
int const N=1e7+5;
int q,p,i,j,m,n,a[N],x,y,f;
int main(){
	freopen("paint.in","r",stdin);
	freopen("paint.out","w",stdout);
	n=read(),m=read(),p=read(),q=read();
	for(i=1;i<=n;i++){
		f=0;
		for(j=m;j>=m-n;j--){//倒过来进行循环，由于数据，可以过，正着只能拿50分
			x=(j*p+q)%n+1;
			y=(j*q+p)%n+1;
			if(x>y) swap(x,y);//交换一下，非常重要！！！！
			if((i>=x)&&(i<=y)){
				write(j);
				f=1;
				break;//有答案直接输出，退出循环
			}
		}
		if(f==0) write(0);
		printf("\n");
	}
	return 0;
}
```
# 以下是并查集正解，楼上大佬已经有解释
### 如果将操作倒着进行，你惊讶的发现好像每个点只需要修改一次。
### 所以如果一个点i被染色了，你可以将他的父亲改成i+1，下次就会直接略过这个点了
### 这个也可以直接用链表将所有没用的点删了

```cpp
#include<bits/stdc++.h>
using namespace std;

#define dd c=getchar()
int read() {int s=0,w=1;char c;while (dd,c>'9' || c<'0') if (c=='-') w=-1;while (c>='0' && c<='9') s=s*10+c-'0',dd;return s*w;}
#undef dd
void write(int x) {if (x<0) x=-x,putchar('-');if (x>=10) write(x/10);putchar(x%10|'0');}
void wln(int x) {write(x);putchar('\n');}void wsp(int x) {write(x);putchar(' ');}

const int N=1e6+5;
int col[N],fa[N];

int find(int x){
	int t=x,p;
	while (t!=fa[t]) t=fa[t];
	while (x!=fa[x]) p=x,x=fa[x],fa[p]=t;
	return t;
}

int main(){
	freopen("paint.in","r",stdin);
    freopen("paint.out","w",stdout);
	int n,m,p,q;
    scanf("%d%d%d%d",&n,&m,&p,&q);
    for (int i=1;i<=n+2;i++) fa[i]=i;
    for (int i=m;i>=1;i--){
        int l=(i*p+q)%n+1,r=(i*q+p)%n+1;
        if (l>r) swap(l,r);
        for (int j=l;j<=r;){
            int t=find(j);
            if (t==j){
                col[j]=i;fa[j]=j+1;
            }
            j=t;
        }
    }
    for (int i=1;i<=n;i++)
        wln(col[i]);
}
```

---

## 作者：Sky_star (赞：13)

这道题可以用并查集来打（然而我一开始脑抽竟然用了双向链表-.-），从最后开始往前进行涂色，因为显然后面的优先级大于前面，后面的会将前面涂的颜色覆盖。这样我们只要快速查找下一个没被涂的点就行了，因此我想到了并查集，只要保证每个集合的fa没被涂过就行了。这样就避免了复杂度过高。

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#define MAXN 1001000
using namespace std;
int mp[MAXN],fa[MAXN],n,m,p,q;
int find(int x){return (fa[x]<0)?x:fa[x]=find(fa[x]);}
int main()
{
    scanf("%d%d%d%d",&n,&m,&p,&q);
    memset(fa,-1,sizeof fa);
    for(int i=m;i>=1;i--)
    {
        int mi=(i*p+q)%n+1,ma=(i*q+p)%n+1;//这里的操作要注意下因为m为10000000，所以尽量减少多余的操作
        if(mi>ma)swap(mi,ma);
        mi=find(mi);
        while(mi<=ma)mp[mi]=i,fa[mi]=mi+1,mi=find(mi+1);
    }
    for(int i=1;i<=n;i++)printf("%d\n",mp[i]);
    return 0;
}

```

---

## 作者：LightningUZ (赞：9)

### 思路框架

这个是不一样的做法，是线段树+一点点思维优化。

（大家似乎都是写的链表做法啊...我不会打链表啊...）

我们发现$(i\times p+q)\mod n+1$这个式子，可以先把$i$对$n$取膜之后再算！！！也就是说，有很多次区间覆盖操作都是覆盖的同一块区间！

那么本质不同的修改操作就只有$n$个，再加上最后$m\mod n$个除不尽的。

特判$m<n$的情况。

无论哪种情况，复杂度都是$O(n \log n)$的。对于$n\le 10^6$的数据，足够了。

### 具体实现思路

显然，在同一个同余系里，最后面那次覆盖的颜色是答案。那么我们把$m$次操作，每$n$个分一块（除不尽的先不管）。显然，最后一块的操作可以把前面几块的操作全部都覆盖掉。所以最后一块是唯一有用的一块。

$m$除以$n$，可以画出这样的图：

![](https://i.loli.net/2020/02/18/XlqZi1oEI9UYnsN.jpg)

`last`指针表示最后一块有用的区间**前面一个位置**，那么最后一块有用的染色操作就是$i=last+1,last+2\cdots last+n$的时候。

容易计算出 `last` 指针为：$n(\lfloor\dfrac{m}{n}\rfloor-1)$


最后$m\mod n$个特判掉。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Flandre_Scarlet
{
    #define N 1666666
    #define F(i,l,r) for(int i=l;i<=r;++i)
    #define D(i,r,l) for(int i=r;i>=l;--i)
    #define Fs(i,l,r,c) for(int i=l;i<=r;c)
    #define Ds(i,r,l,c) for(int i=r;i>=l;c)
    #define MEM(x,a) memset(x,a,sizeof(x))
    #define FK(x) MEM(x,0)
    #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i))
    #define p_b push_back
    #define sz(a) ((int)a.size())
    #define iter(a,p) (a.begin()+p)
    void R1(int &x)
    {
        x=0;char c=getchar();int f=1;
        while(c<'0' or c>'9') f=(c=='-')?-1:1,c=getchar();
        while(c>='0' and c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
        x=(f==1)?x:-x;
    }
    void Rd(int cnt,...)
    {
        va_list args;
        va_start(args,cnt);
        F(i,1,cnt) 
        {
            int* x=va_arg(args,int*);R1(*x);
        }
        va_end(args);
    }
    class SegmentTree //线段树，区间覆盖，单点求值
    {
    public:
        struct node
        {
            int l,r,c,s;
        }tree[N<<2];
        #define ls index<<1
        #define rs index<<1|1

        #define L tree[index].l
        #define R tree[index].r
        #define S tree[index].s
        #define C tree[index].c

        #define lL tree[ls].l
        #define lR tree[ls].r
        #define lS tree[ls].s
        #define lC tree[ls].c

        #define rL tree[rs].l
        #define rR tree[rs].r
        #define rS tree[rs].s
        #define rC tree[rs].c
        void Build(int l,int r,int index=1)
        {
            L=l,R=r;
            if (l==r) {S=C=0;return;}
            int mid=(l+r)>>1;
            Build(l,mid,ls); Build(mid+1,r,rs);
        }
        void ChangeOne(int x,int index=1)
        {
            C=S=x;
        }
        void PushDown(int index=1) 
        {
            if (C)
            {
                ChangeOne(C,ls); ChangeOne(C,rs);
                C=0;
            }
        }
        void Change(int l,int r,int x,int index=1)
        //l到r覆盖上x
        {
            if (l>R or L>r) return;
            if (l<=L and R<=r) return ChangeOne(x,index);
            PushDown(index);
            Change(l,r,x,ls); Change(l,r,x,rs);
        }
        int Query(int pos,int index=1)
        //查询第pos个位置的值
        {
            if (pos<L or R<pos) return 0;
            if (L==R) return S;
            PushDown(index);
            return Query(pos,ls)+Query(pos,rs);
        }
    }T;

    int n,m,p,q;
    void Input()
    {
        Rd(4,&n,&m,&p,&q);
    }
    void Soviet()
    {
        #define ll(i) ((i*p+q)%n+1)
        #define rr(i) ((i*q+p)%n+1)
        T.Build(1,n);
        if (m<n) //m<n直接特判
        {
            F(i,1,m) 
            {
                int l=ll(i),r=rr(i); if (l>r) swap(l,r);
                //记得判断l>r的情况
                T.Change(l,r,i);
            }
            F(i,1,n) printf("%d\n",T.Query(i));
        }
        else
        {
            int last=(m/n-1)*n;
            F(i,1,n) //找到最后一块有用的区间
            {
                int l=ll(i),r=rr(i); if (l>r) swap(l,r);
                T.Change(l,r,++last);
            }
            F(i,last+1,m) //最后m%n个也判掉
            {
                int l=ll(i),r=rr(i); if (l>r) swap(l,r);
                T.Change(l,r,i);
            }
            F(i,1,n) printf("%d\n",T.Query(i));
        }
    }

    #define Flan void
    Flan IsMyWife()
    {
        Input();
        Soviet();
    }
}
int main()
{
    Flandre_Scarlet::IsMyWife();
    getchar();getchar();
    return 0;
}
```

---

## 作者：Great_Influence (赞：9)

先看题目发现，这道题要求的唯一操作是区间修改，第一反应想到了线段树。但是根据数据范围来看，单纯用线段树绝对会TLE(mlog2n)，这时就得想如何优化。在自己做几个数据后会发现，最后一次操作所填的颜色会全部保留，而倒数第二次操作所填的颜色仅会被倒数第一次操作所覆盖，以此类推。而注意时间复杂度高主要是多次重复的填色操作造成的。这时，我们便可以发现一个特征：前面几次操作的颜色几乎全部被覆盖，大部分填色的时间会被浪费。所以，可以从最后一种颜色开始填，之后每填一种颜色只覆盖0的位置，不动已填色的区域。这样处理可以使时间复杂度大大降低(n)。操作与普通线段树差不多。

代码：

```cpp
#include<cstdio>
#include<cstdlib>
#include<cctype>
#include<iostream>
#define For(i,a,b) for((i)=(a);(i)<=(b);++(i))
#define Forward(i,a,b) for((i)=(a);(i)>=(b);--(i))
using namespace std;
const int MAXN=1000000+100;
template<typename T>
inline void read(T &x)//快速读入
{
    T s=0,f=1;
    char k=getchar();
    while(!isdigit(k)&&k!='-')k=getchar();
    if(k=='-')
    {
        f=-1;
        k=getchar();
    }
    while(isdigit(k))
    {
        s=(s<<3)+(s<<1)+(k^'0');
        k=getchar();
    }
    x=s*f;
}
int n,m,p[MAXN<<2];
void insert(int h,int l,int r,int x,int y,int z)//涂色
{
    if(p[h]==0&&x<=l&&r<=y)//注意当此段颜色不为0时，不能全部涂掉
    {
        p[h]=z;
        return;
    }
    int mid=(l+r)>>1;
    if(p[h]==0)p[h]=-1;
    else if(p[h]>0)return;//当这一段全部被填掉时，不必再填了。
    if(x<=mid)insert(h<<1,l,mid,x,y,z);
    if(y>mid)insert(h<<1|1,mid+1,r,x,y,z);
}
void output(int h,int l,int r)//输出
{
    if(p[h]!=-1)for(int i=l;i<=r;++i)printf("%d\n",p[h]);
    else
    {
        int mid=(l+r)>>1;
        output(h<<1,l,mid);
        output(h<<1|1,mid+1,r);
    }
}
int k,q;
int main(void)
{
    //freopen("snow.out","w",stdout);
    int i;
    read(n);
    read(m);
    read(k);
    read(q);
    Forward(i,m,1)
    {
        int u=(k*i+q)%n+1,v=(i*q+k)%n+1;
        if(u>v)swap(u,v);
        insert(1,1,n,u,v,i);//线段树操作
    }
    output(1,1,n);
    return 0;
}

```

---

## 作者：aface0427 (赞：7)

# 并查集真是一个维护连通性美妙的数据结构啊！

此题我们观察到每个点染色可能被下一次染色覆盖，所以首先需要将修改反向，使前面的染色点点不能覆盖后面的染色点保证最后修改的不被覆盖。

然后对于模拟过程中下一次染哪一个的颜色使用并查集。f[i]表示离i最近，下次修改应该被修改到的点。最后就是一个简单的模拟啦。

由于每个点最多被修改一次，复杂度O(n).

上代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<vector>
#include<cstring>
#include<cmath>
using namespace std;
#define ll long long
#define max(a,b) a>b?a:b
#define min(a,b) a<b?a:b
const int maxn=1e6+7;
void read(int &x)
{
  char c=getchar();
 x=0;
  int flag=1;
 while(!isdigit(c))
 {
   if(c=='-')flag=-1;
   c=getchar();
 }
 while(isdigit(c))
{
x=x*10+c-48;
c=getchar();
}
  x*=flag;
}
int n,m,p,q;
int fa[maxn];
int find(int x)
{
  if(x==fa[x])return x;
  else
  {
    fa[x]=find(fa[x]);
    return fa[x];
  }
}
int color[maxn];
int main()
{
  read(n),read(m),read(p),read(q);
  for(int i=1;i<=n;i++)fa[i]=i;
  for(int i=m;i>=1;i--)
  {
    int l=(i*p+q)%n+1;
    int r=(i*q+p)%n+1;
    if(l>r)swap(l,r);
    for(int j=r;j>=l;)
    {
      int tb=find(j);
      if(tb==j)
      {
        color[j]=i;
        fa[j]=find(j-1);
      }
      j=fa[j];
    }
  }
  for(int i=1;i<=n;i++)
  {
    cout<<color[i]<<endl;
  }
  return 0;
}

```

---

## 作者：Viston (赞：4)

# 暴力碾标算。    
思路： 从后往前对每一个点进行遍历！   
目前最优解.    
主体代码10行（包括头文件和变量定义）    
那就看一波代码吧.........  
```
#include<bits/stdc++.h>
inline int read(){   //以下部分都是优化
	int X=0;char ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)) X=X*10+ch-'0',ch=getchar();
	return X;
}
void print(int X){
	if(X>=10) print(X/10);
	putchar(X%10+'0');
}
inline int min(int a,int b){return a>b?b:a;}
inline int max(int a,int b){return a<b?b:a;}    //下面就是主题代码了！
int  a,b,c,d,e[1000002];
int main(){
	a=read(),b=read(),c=read(),d=read();
	for(int i=1;i<=a;++i)
		for(int j=b;j>=0;j--)
			if((min((j*c+d)%a+1,(j*d+c)%a+1)<=i&&max((j*c+d)%a+1,(j*d+c)%a+1)>=i)||j==0){
				print(j);putchar(10);break;
			}
	return 0;
}
```

---

## 作者：AKPC (赞：3)

事实上这题可以使用 $\text O(n\log m)$ 复杂度的贪心+优先队列思想做，此处 $?$ 大小要看数据。
### 前置知识
先来看本题目弱化版：

有一个数列 $a$，长度 $n$，初始时 $a$ 所有元素均为 $0$。  
现在要给 $a$ 数列进行 $q$ 次修改操作，每次操作将某一区间所有值均修改为特定的同一值。  
最后求 $a$ 数列每个元素的值。  
数据范围：$1\leq n,m\leq 10^5$，对于最后的答案 $1\leq a_{\forall i}\leq 10^9$。

样例输入：

```
5 3
1 3 1
2 4 2
3 3 3
```

样例输出：

```
1 2 3 2 0
```

**1. 存储区间。**

考虑按照修改区间的左顶点在 `vector` 里存储区间，便于后面线性的遍历。

存储区间代码大致长这样：

```cpp
#define mpr make_pair

inline int read(){//自己手敲的屑快读qwq
	int res=0,f=1;char c=getchar();
	while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}
	while (c>='0'&&c<='9') {res=res*10+(c-'0');c=getchar();}
	return res*f;
}

vector<pair<int,pair<int,int> > >a[100005];//r,{color,t}

for (int i=1;i<=q;i++){
	int x=read(),y=read(),z=read();
	a[x].push_back(mpr(y,mpr(z,i)));//这里的i在后面会讲
}
```

**2. 优先队列维护区间集的排序方式。**

存储区间的时候记录一个优先级。

越后面的操作优先级越大（在上面的代码里取了 $i$）。在后面使用优先队列的处理中，需要根据优先级从小到大排序。

代码见上部分。

**3. 线性遍历所有区间。**

遍历一遍 $1\sim n$，维护优先队列（优先级从小到大），维护这几个操作：

- 弹出队列顶部右端点小于 $i$ 的操作区间（弹出顶部过时操作）。
- 放入所有左端点 $i$ 的区间。
- 选取队列顶部的操作区间对应的值赋值给答案数组对应的下标。

遍历区间的代码大致长这样：

```cpp
#define fr first
#define sc second

int a[100005];

priority_queue<pair<pair<int,int>,pair<int,int> >,vector<pair<pair<int,int>,pair<int,int> > >,less<pair<pair<int,int>,pair<int,int> > > >que;//{t,color},{l,r}

for (int i=1;i<=n;i++){
	while (!que.empty()){//弹出过时区间
		if (que.top().sc.sc<i) que.pop();
		else break;
	}
	for (auto j:a[i]) que.push(mpr(mpr(j.sc.sc,j.sc.fr),mpr(i,j.fr)));//放入新的区间
	if (!que.empty()){//统计该位置答案
		const int x=que.top().sc.fr,y=que.top().fr.sc;
		ans[i]=y;	
	}
}
```

**4. 输出答案。**

直接输出 `ans` 数组即可。

代码如下：

```cpp
for (int i=1;i<=n;i++) cout<<ans[i]<<' ';
```


这种做法的正确性就是在每次遍历，弹出过时区间和放入区间之后，队列顶部的一定没有过时，且优先级一定最大。而且在弹出过时区间的时候，可以不考虑队列不在顶部的区间，因为在该区间到顶部的时候会自动弹出，一直没到顶部就更不用管了。

[code](https://www.luogu.com.cn/paste/fpx61x94)

### 本题思路
题意其实跟上面是一样的，但是 $1\leq n\leq 10^6,1\leq m\leq 10^7$。

乍一看不会 TLE，修改数据范围后直接交上面的代码，喜获 [$85$ 分](https://www.luogu.com.cn/record/129655885)。原因是优先队列占用空间过大。

考虑优化做法。发现优先级低的区间被优先级高的完全覆盖时是没有用处的，所以可以不加进优先队列，可以逆序枚举区间然后判断要不要加。

但是区间修改区间查询又很难蚌，~~这么复杂我不如直接线段树做这题~~，但是发现 $n$ 的范围很小，所以可以只判断左端点相同的比自己优先级大的最长区间是否完全覆盖了枚举到的区间，如果是就不放 `vector` 了。

[code](https://www.luogu.com.cn/paste/h981z5lm)

---

## 作者：木木！ (赞：2)

思路是挂链+堆。

先循环出每一个修改点，然后挂链保存修改。具体做法是将\[l,r,c\]挂在链表l上，保存r，c就是节点编号。

然后在输出的时候，遍历每一条链表，插入堆中。在堆中每一次取c最大的修改，如果r小于i就弹出。

还有一个小优化，如果r确定，则c越大越好。所以可以同时存下每一个ri对应的最大c，减少插入操作。

```cpp
#include <queue>
#include <cstdio>
using namespace std;

int beg[1000005];
int ri[10000005];
int nxt[10000005];
int qi[10000005];

int maxi[1000005];

int main()
{
	int n,m,p,q;
	scanf("%d%d%d%d",&n,&m,&p,&q);
	p %= n;
	q %= n;
	
	int l = q+1;
	int r = p+1;
	for(int i=1; i<=m; ++i)
	{
		l += p; //用+代替*，-代替%，减少常数
		r += q;
		
		if(l>n)
		{
			l -= n;
		}
		if(r>n)
		{
			r -= n;
		}
		
		if(l<r)
		{
			ri[i] = r;
			nxt[i] = beg[l];
			beg[l] = i;
		}
		else
		{
			ri[i] = l;
			nxt[i] = beg[r];
			beg[r] = i;
		}
	}
	
	priority_queue<pair<int,int> > pq;
	for(int i=1; i<=n; ++i)
	{
		while(!pq.empty() && pq.top().second<i)
		{
			pq.pop();
		}
		for(int p=beg[i]; p; p=nxt[p])
		{
			if(p > maxi[ri[p]]) //小优化
			{
				pq.push(make_pair(p,ri[p]));
				maxi[ri[p]] = p;
			}
		}
		
		if(!pq.empty())
		{
			printf("%d\n",pq.top().first);
		}
		else
		{
			printf("0\n");
		}
	}
}
```

---

## 作者：Youngsc (赞：2)

[Youngsc](http://youngscc.github.io/)

楼下说他一来是用的是链表，可能是因为写的~~不太对~~就改成并查集了，其实双向链表对于这道题是可做的。

从最后一个操作往前扫这个不用多说，当我们对一个区间进行染色之后，我们就将其从链表中删除，然后进行下一次染色，如果说此时的左端点已经被删除，会不会影响我的染色，答案是不会的，因为链表中所谓的删除无非是将两个端点两边的节点相互连接起来，也就是说我虽然不能从保留下来的节点找到已经删除节点，因为他的指针已经改变，但我依然可以从已经删除的节点找到保留的节点，因为此时的指针并没有发生改变，我只需要判断有没有染过颜色就行了。右端点已经染色同理。


## 代码如下

```cpp
# include <algorithm>
# include <iostream>
# include <cstring>
# include <cstdio>
# include <queue>
# include <cmath>
# define R register
# define LL long long

using namespace std;

int n,m,col[1000010],pre[1000010],nxt[1000010],p,q;

template <typename T> void in(R T &a){
    R char c = getchar();R T x=0,f=1;
    while(!isdigit(c)) {if(c == '-') f=-1; c=getchar();}
    while(isdigit(c)) x=(x<<1)+(x<<3)+c-'0',c = getchar();
    a=x*f;
}

inline int youngsc(){
    in(n),in(m),in(p),in(q);
    for(R int i=1; i<=n; ++i)
    {
        nxt[i] = i+1;
        pre[i] = i-1;
    }
    for(R int i=m; i>=1; --i)
    {
        R int l=(i*p+q)%n+1, r=(i*q+p)%n+1;
        if(l>r) l^=r,r^=l,l^=r;
        R int now = l;
        while(now <= r)
        {
            if(!col[now]) col[now] = i;
            now = nxt[now];
        }
        nxt[pre[l]] = nxt[r];
        pre[nxt[r]] = pre[l];
    }
    for(R int i=1; i<=n; ++i) printf("%d\n",col[i]);
    return 0;
}
int yg = youngsc();
int main(){;}

```

---

## 作者：封禁用户 (赞：2)

我认为这道题没有必要用链表和并查集，这是一道模拟题，我们从后往前来模拟每次操作，对于每次操作，更新区间左右端点，直到其覆盖整个区间，输出答案。附代码：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
struct node{
    int l,r,va;
}a[1000001];
long long n,m,p,q,tot,sum,b[1000001];
int main()
{
    cin>>n>>m>>p>>q;
    int k=m;
    int xx=(m*p+q)%n+1;
    int yy=(m*q+p)%n+1;
    if(xx>yy)
    {
        swap(xx,yy);
    }
    sum+=yy-xx+1;
    a[++tot].l=xx;
    a[tot].r=yy;
    a[tot].va=m;
    k=m-1;
    int left=xx,right=yy;
    for(int k=m-1;k>=1;k--)
    {
        int x=(k*p+q)%n+1;
        int y=(k*q+p)%n+1;
        if(x>y)
        {
            swap(x,y);
        }
        if(x<left)
        {
            a[++tot].l=x;
            a[tot].r=left-1;
            a[tot].va=k;
            if(k!=m)
            {
                sum+=left-x;
            }
            left=x;
        }
            if(y>right)
        {
            a[++tot].l=right+1;
            a[tot].r=y;
            a[tot].va=k;
            if(k!=m)
            {
                sum+=y-right;
            }
            right=y;
        }
    }
    for(int i=1;i<=tot;i++)
    {
        for(int j=a[i].l;j<=a[i].r;j++)
        {
            b[j]=a[i].va;
        }
    }
    for(int i=1;i<=n;i++)
    {
        printf("%d\n",b[i]);
    }
    return 0;
}
```

---

## 作者：lzyqwq (赞：1)

正常做法其他题解都讲了。我们直接快进到这一步：

> 维护长度为 $n$ 的 01 序列，支持单点修改和查询某个位置的后继 $1$。要求时间复杂度低于 $\mathcal{O}(\log_2 n)$。

记 $w=64$。考虑以 $w$ 为块长分块，则块内的 01 序列可以用一个 `unsigned long long` 表示。

再考虑将 $w$ 个小块分一个大块。同理大块也可以继续分下去。这样会构成一棵树的结构，深度为 $\mathcal{O}(\log_wn)$。

对于树上的每一个结点，用一个 `unsigned long long` 表示每一个子结点内是否有 $1$。

单点修改就从叶子节点往上爬修改祖先，时间复杂度为 $\mathcal{O}(\log_w n)$。

至于查询，先考虑块内的情况。那么就是查一个位置 $p$ 后的第一个二进制位，容易用位运算实现。

如果块内没有，就往祖先爬，找到一个后继 $1$ 的祖先。然后从祖先向叶子递归即可。时间复杂度为 $\mathcal{O}(\log_w n)$。

时间复杂度为 $\mathcal{O}((n+m)\log_w n)$，空间复杂度为 $\mathcal{O}(n)$。

贴一个实现，不是很精细：


```cpp
struct DS {
	const ull V = 18446744073709551615ull;
	int cnt, n, id[N], o[N], rt, bel[N]; vector<int> g[N];
	struct node { int l, r, f, num; ull v; } a[N];
	int hb(ull x) { return 63 - __builtin_clzll(x); }
	ull lb(ull x) { return (x & (x - 1)) ^ x; }
	void init(int m) {
		n = m;
		for (int i = 1; i <= n; ++i) id[i] = (i - 1 >> 6) + 1;
		for (int i = 1; i <= id[n]; ++i) {
			int l = (i - 1 << 6) + 1, r = min(i << 6, n);
			a[i] = node{l, r, 0, 0, V}; o[i] = i;
			for (int j = l; j <= r; ++j) bel[j] = j - l;
		}
		int cur = cnt = id[n];
		while (cur > 1) {
			for (int i = 1; i <= id[cur]; ++i) {
				int l = (i - 1 << 6) + 1, r = min(i << 6, cur);
				a[++cnt] = node{a[o[l]].l, a[o[r]].r, 0, 0, V};
				for (int j = l; j <= r; ++j)
					g[cnt].emplace_back(o[j]), a[o[j]].f = cnt, a[o[j]].num = j - l;
			}
			for (int i = cnt - id[cur] + 1; i <= cnt; ++i) o[i + id[cur] - cnt] = i;
			cur = id[cur];
		}
		rt = cnt;
	}
	void C(int x, bool v) {
		int f = a[x].f; ull tmp = a[f].v; a[f].v ^= (1ull << a[x].num);
		a[f].v |= (1ull * v << a[x].num);
		if (f != rt && a[f].v != tmp) C(f, a[f].v);
	}
	void U(int x, bool v) {
		ull tmp = a[id[x]].v; a[id[x]].v ^= (1ull << bel[x]);
		a[id[x]].v |= (1ull * v << bel[x]);
		if (id[x] != rt && a[id[x]].v != tmp) C(id[x], a[id[x]].v);	
	}
	int fl(int x) {
		int k = hb(lb(a[x].v));
		if (g[x].empty()) return a[x].l + k; return fl(g[x][k]);
	}
	int q(int x) {
		int f = a[x].f;
		if (hb(a[f].v) >= a[x].num)
			return x + hb(lb(a[f].v >> a[x].num << a[x].num)) - a[x].num;
		return q(f + 1);
	}
	int Q(int x) {
		if (hb(a[id[x]].v) >= bel[x])
			return x + hb(lb(a[id[x]].v >> bel[x] << bel[x])) - bel[x];
		return fl(q(id[x] + 1));
	}
} T;
```
最大点 255 ms。

---


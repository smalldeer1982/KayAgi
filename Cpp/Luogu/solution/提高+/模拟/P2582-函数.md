# 函数

## 题目背景

Alice 和 Bob 玩游戏。

## 题目描述

Alice 给出一个 $1$~$n$ 的排列表示一个函数 $y=f(x)$，即给出的第 $i$ 个数字即为 $f(i)$。  

现在 Bob 需要给出一个字典序尽可能小的函数 $y=g(x)$，使得对于任意 $i$，$f(g(i))=g(f(i))$。

## 说明/提示

#### 【样例解释】
#### 样例 1 说明
- $g(f(1))=f(g(1))=1$。
- $g(f(2))=f(g(2))=1$。
- $g(f(3))=f(g(3))=1$。
- $g(f(4))=f(g(4))=1$。
- $g(f(5))=f(g(5))=1$。

#### 样例 2 说明
- $g(f(1))=f(g(1))=2$。
- $g(f(2))=f(g(2))=3$。
- $g(f(3))=f(g(3))=4$。
- $g(f(4))=f(g(4))=5$。
- $g(f(5))=f(g(5))=1$。

---

#### 【数据规模与约定】
对于 $30\%$ 的数据，$n \le 5$。
对于 $60\%$ 的数据，$n \le 10^3$。
对于 $100\%$ 的数据，$1 \le n \le 8 \times 10^5$。

## 样例 #1

### 输入

```
5
1 2 3 4 5```

### 输出

```
1 1 1 1 1```

## 样例 #2

### 输入

```
5
2 3 4 5 1```

### 输出

```
1 2 3 4 5```

# 题解

## 作者：云浅知处 (赞：6)

很好的一道题。感觉评蓝有点低了。

首先注意到一个性质：如果 $g(x)=k$，那么就有：

$$
g(f(x))=f(g(x))=f(k)
$$

以此类推，我们可以推出：对任意的 $m$，均有：

$$
g(f^{(m)}(x))=f^{(m)}(k)
$$

也就是说，如果我们将每个 $i$ 和 $f(i)$ 看做一条有向边 $i\to f(i)$，那么：**左边相当于在 $x$ 所在的环上走 $m$ 步，右边相当于在 $k$ 所在的环上走 $m$ 步**。

方便起见，我们设建图之后点 $i$ 所在环的大小为 $\text{Size}(i)$。

这样一来，如果 $g(x)=k$，那么，由于对任意的 $m$，两边在各自的环上走 $m$ 步后的值都要相等，就必须有：

$$
\text{Size}(k)\mid\text{Size}(x)
$$

即 $\text{Size}(k)$ 为 $\text{Size}(x)$ 的约数。否则，当 $m=\text{Size}(x)$ 时，已经出现了矛盾。

那么，我们首先建图，对每个点求出它的 $\text{Size}(x)$，然后枚举约数计算即可。时间复杂度为 $O(n+\sum\sqrt{\text{Size}(i)})=O(n)$。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>

const int MN=8e5+5;

using namespace std;

int n,f[MN],g[MN];
bool vis[MN];
int mn[MN],s[MN];

int dfs(int x){
    if(vis[x])return 0;
    vis[x]=1;
    return dfs(f[x])+1;
}

void dfs2(int x,int sz){
    if(vis[x])return ;
    vis[x]=1,s[x]=sz;
    dfs2(f[x],sz);
}

void dfs3(int x,int y){
    if(vis[x])return ;
    vis[x]=1,g[x]=y;
    dfs3(f[x],f[y]);
}

int main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>f[i];

    for(int i=1;i<=n;i++){
        if(!vis[i]){
            s[i]=dfs(i);
            if(!mn[s[i]])mn[s[i]]=i;
        }
    }

    memset(vis,0,sizeof(vis));
    for(int i=1;i<=n;i++)if(!vis[i])dfs2(i,s[i]);
    
    memset(vis,0,sizeof(vis));
    for(int i=1;i<=n;i++){
        if(!vis[i]){
            int Mn=1000000;
            for(int j=1;j*j<=s[i];j++){
                if(s[i]%j==0){
                    if(mn[j]>0)Mn=min(Mn,mn[j]);
                    if(mn[s[i]/j]>0)Mn=min(Mn,mn[s[i]/j]);
                }
            }
            dfs3(i,Mn);
        }
    }

    for(int i=1;i<=n;i++)cout<<g[i]<<" ";puts("");
    return 0;
}
```

---

## 作者：木木！ (赞：5)

这题评蓝是不是评低了啊。

首先我们可以发现 $g(f(x))=f(g(x))$，即如果知道 $g(x)$ 的话， $g(f(x))$ 就可以简单算出。

将每一个 $g(x)$ 具象成一个点，可以看做 $g(x)$ 与 $g(f(x))$ 之间连了一条边。根据序列的性质，这里的每个点入度和出度均为一，最终形成的图是一个环的森林（这里用森林这个词是因为环可以看成退化的基环树）。

然后我的第一个想法就是将每个环里面最小的那个设成 $1$，然后暴力推出其他已知值。最终得到了 10pts 的好成绩。

原因是这里的环必须满足环尾和环头是相接的，也就是说，假设用 $f(x)$ 迭代 $g(x)$ 所得环的长度为 $l$，那么 $f(x)$ 迭代 $x$ 所得环长度也得是 $l$。

于是我就 $\Theta(n)$ 找环+统计环最小环首项值，贪心填入，最终获得了 20pts 的好成绩。

```cpp
for(int i=1; i<=n; ++i)
{
	if(!li[i])
	{
		int ln = 1;
		for(int j=fi[i]; j!=i; j=fi[j]) ++ln;
		li[i] = ln;
		for(int j=fi[i]; j!=i; j=fi[j]) li[j] = ln;
		chkmin(ni[ln],i);
	}
}

for(int i=1; i<=n; ++i)
{
	if(!vi[i])
	{
		vi[i] = ni[li[i]];
		int curx = vi[i];
		for(int j=fi[i]; j!=i; j=fi[j])
		{
			curx = fi[curx];
			vi[j] = curx;
		}
	}
}
```

原因是，如果 $f(x)$ 迭代 $x$ 所得环长度为 $l$，只要 $f(x)$ 迭代 $g(x)$ 所得环长度为 $l$ 的因数就可以了。

然后就是环长固定时最小首项的问题了。题解区大佬用的是直接暴力 $\Theta(\sqrt{l})$ 枚举因数，时间复杂度非常的优良，为 $\Theta(n)$。证明很简单就不贴了。

我比较菜，我以为枚举因数的时间复杂度会飙到 $\Theta(n\sqrt{n})$，所以我用的是枚举倍数的方法，时间复杂度是调和级数 $\Theta(n\log n)$。

附 AC 代码：

```cpp
#include <cstdio>
using namespace std;

void chkmin(int& a,int b) { if(a>b) a=b; }

int fi[800005];
int li[800005];
int ni[800005];
int vi[800005];

int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1; i<=n; ++i) scanf("%d",fi+i);

	for(int i=1; i<=n; ++i) ni[i] = n;

	for(int i=1; i<=n; ++i)
	{
		if(!li[i])
		{
			int ln = 1;
			for(int j=fi[i]; j!=i; j=fi[j]) ++ln;
			li[i] = ln;
			for(int j=fi[i]; j!=i; j=fi[j]) li[j] = ln;
			chkmin(ni[ln],i);
		}
	}

	for(int i=1; i<=n; ++i)
	{
		for(int j=2; j*i<=n; ++j)
		{
			chkmin(ni[j*i],ni[i]);
		}
	}

	for(int i=1; i<=n; ++i)
	{
		if(!vi[i])
		{
			vi[i] = ni[li[i]];
			int curx = vi[i];
			for(int j=fi[i]; j!=i; j=fi[j])
			{
				curx = fi[curx];
				vi[j] = curx;
			}
		}
	}

	for(int i=1; i<=n; ++i)
	{
		printf("%d ",vi[i]);
	}
}
```

---

## 作者：BFSBFSBFSBFS (赞：4)

这是1道曾经是 普及- 的题目..

光看样例没什么感觉..先暴力找找规律..

于是发现.

....当$f(i) = i$时,$g(j) = i(i < j <= n)$.

....当$g(j) = j$时,必定满足条件.

很好证明.因为$f(g(i)) = g(f(i))$.

当$f(i) = i$时,$f(g(i)) = g(i)$.相当于$f(x) = x(x = g(i))$.所以$g(i)$取满足条件$f(i) = i$最小的i.

当$g(j) = j$时,$f(j) = g(f(j))$.相当于$g(x) = x(x = f(j))$.(就是前面那个$g(j) = j$...)成立.

这时候,$g(j)$确定,$f(j)$已知,那么就能知道$g(f(j))$,进而知道$f(g(j)),g(f(g(j)))$..这样能推出全部的$g(j)$.

具体的.若$g(j)$已被确定.则跳过.否则若满足第1条.则$g(j) = i$,否则$g(j) = j$.

主要代码..
```
i = 1;
while (i <= n)
    if (g[i]){
        gsum = f[g[i]];
        fsum = f[i];
        while (!g[fsum]){
            g[fsum] = gsum;
            gsum = f[g[fsum]];
            fsum = f[fsum];
        }
        while (g[++i]);
```
其实就是1个找环的过程........
```
f(i) -> g(f(i)) -> f(g(f(i))) ->.....
```
可以看出.对于
```
f = (2, 3, 4, 5, 1)
f(1) -> f(f(1)) -> f(f(f(1))) ->.....
2    -> 3       -> 4          ->.....
```
是1个长度为5的环.

可是..只用这2个性质.50..

似乎还有更优的方法.?

强行把$g(j) = j$改成$g(j) = 1$.30..

取最小的没选过的.?50..没有区别..

沉寂2天..

自己造数据对拍.固定$n = 10,f(2) = 2$.

真的发现1组不对的数据..~~(想不起来.).~~

简单栗子.
```
f = (4, 3, 2, 1);
g = (1, 2, 3, 4);//错误.
g = (1, 1, 4, 4);//正确.
```
**原来2个同长度的环可以互换.**.

这样.只要取字典序最小的.就是最优的了..

然而....**长度能整除的换都能被更换..**.

栗子.
```
f = (6, 3, 4, 5, 2, 1, 8, 9, 10,7);
g = (1, 1, 6, 1, 6, 6, 1, 6, 1, 6);
```
需要所有能被整除的长度中取字典序最小..

这样.开头说的第1条.$f(i) = i$说明是个长度为1的环..所以可以替换所有的环..

还有1个重要的条件.题目已经说明给出的$f(i)$是全排列..

那就没有交叉环的现象了..也能解释开头的弟2条..有没有解倒是没研究过..

用$sum[i]$记录第i位的环的长度.$f[i]$记录长度为i的环字典序最小的开头.

~~(sum[i]写成[i]..)..~~

先设$k = i$.枚举$sum[i]$所有的约数.用最小的$f[x]$替换$k$.

80W有点大...只要枚举$\sqrt{sum[i]}$.就可以过了....

($n*\sqrt{\sqrt{80W}}???$)....

另外,由于不同长度的环最多不超过1500种.也可以对环长度离散后暴力判断..

Diu代码..
```
//第2种.
program P2582;
 var
  a,b,sum,f,s,fst:array[0..800001] of longint;
  i,ij,j,k,p,n,nf:longint;
 begin
  readln(n);
  for i:=1 to n do
   read(a[i]);             //f数组.
  readln;
  fillchar(b,sizeof(b),0); //g数组.
  for i:=1 to n do
   sum[i]:=1;              //统计环长度.
  fillchar(f,sizeof(f),0); //统计环长度为i的字典序最小的开头..
  for i:=1 to n do         //先找环长度..
   if b[i]=0 then
    begin
     p:=i;
     while a[p]<>i do
      begin
       inc(sum[i]);
       b[p]:=1;
       p:=a[p];
      end;
     if f[sum[i]]=0 then f[sum[i]]:=i;
    end;
  fillchar(b,sizeof(b),0);
  nf:=0;                   //环长度不同的个数..
  for i:=1 to n do
   if f[i]<>0 then
    begin
     inc(nf);
     f[nf]:=f[i];
     s[nf]:=i;             //记录长度.
    end;
  for i:=1 to nf do
   for j:=1 to nf do
    if (s[i] mod s[j]=0) and (f[j]<f[i]) then f[i]:=f[j];                //字典序修改.
  for i:=1 to nf do
   fst[s[i]]:=f[i];        //还原.
  for i:=1 to n do
   if b[i]=0 then          //重新再跑1遍环..求出g数组.
    begin
     k:=fst[sum[i]];
     p:=i;
     while b[p]=0 do
      begin
       b[p]:=k;
       k:=a[b[p]];
       p:=a[p];
      end;
    end;
  for i:=1 to n-1 do
   write(b[i],' ');
  writeln(b[n]);
 end.
```
```
//第1种..
program P2582;
 var
  a,b,sum,f:array[0..800001] of longint;
  i,ij,j,k,p,n:longint;
 begin
  readln(n);
  for i:=1 to n do
   read(a[i]);
  readln;
  fillchar(b,sizeof(b),0);
  for i:=1 to n do
   sum[i]:=1;
  filldword(f,sizeof(f)>>2,1008208820);
  for i:=1 to n do
   if b[i]=0 then
    begin
     p:=i;
     while a[p]<>i do //先找长度..
      begin
       inc(sum[i]);
       p:=a[p];
      end;
     k:=i;
     for j:=1 to n do
      if j*j<=sum[i] then //枚举长度..
       begin
        if (sum[i] mod j=0) then
         begin
          p:=sum[i] div j;
          if f[j]<k then k:=f[j];
          if f[p]<k then k:=f[p];//对2个约数判断字典序.
         end;
       end
                     else break;
     if f[sum[i]]>=k then f[sum[i]]:=k;//修改字典序最小..
     p:=i;    //重新复原g数组..
     while b[p]=0 do
      begin
       b[p]:=k;
       k:=a[b[p]];
       p:=a[p];
      end;
    end;
  for i:=1 to n-1 do
   write(b[i],' ');
  writeln(b[n]);
 end.
```
(ಡωಡ).


---

## 作者：朱江黄河 (赞：1)

首先求出全排列中每个数所在环的大小，

例如f(a)=b,f(b)=c,f(c)=a就是大小为3的环

然后求出每个大小的环中字典序最小的环（记录开头最小的数即可） 

然后对于全排列中每个环，拿字典序最小的替换即可
```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
#define maxn 800005
int a[maxn],b[maxn],c[maxn],d[maxn];
int main(){
    int n,x,si,y;scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",a+i);
     for(int i=1;i<=n;i++){//求环
     	if(c[i])continue;
     	x=i,si=0;
        do{
        	si++;
        	x=a[x];
        }while(x!=i);
        do{
        	c[x]=si;
            x=a[x];
        }while(x!=i);
        if(!d[si]){
        	d[si]=i;
        	for(int j=sqrt(si);j>0;j--){
        		if(si%j==0){
        			if(d[si/j])d[si]=min(d[si],d[si/j]);
        			if(d[j])d[si]=min(d[si],d[j]);
                }
            }
        }
    }
    for(int i=1;i<=n;i++){
    	if(d[i]){
    		for(int j=sqrt(i+1);j>0;j--){
        		if(i%j==0){
        			if(d[i/j])d[i]=min(d[i],d[i/j]);
        			if(d[j])d[i]=min(d[i],d[j]);
                }
            }
        }
    }
    for(int i=1;i<=n;i++){//替换
        if(b[i])continue;
        x=i,y=d[c[i]];
        do{
            b[x]=y;
            x=a[x],y=a[y];
        }while(x!=i);
    }
    for(int i=1;i<=n;i++)printf("%d ",b[i]);
    return 0;
} 
```

---


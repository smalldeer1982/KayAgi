# 美丽的序列

## 题目背景

GD是一个热衷于寻求美好事物的人，一天他拿到了一个美丽的序列。


## 题目描述

为了研究这个序列的美丽程度，GD定义了一个序列的“美丽度”和“美丽系数”：对于这个序列的任意一个区间[l，r]，这个区间的“美丽度”就是这个区间的长度与这个区间的最小值的乘积，而整个序列的“美丽系数”就是它的所有区间的“美丽度”的最大值。现在GD想要你帮忙计算这个序列的“美丽系数”。


## 说明/提示

样例解释 选取区间［2，3］，可以获得最大“美丽系数”为2\*2=4。 数据范围 对于20%的数据，n<=2000； 对于60%的数据，n<=200000； 对于100%的数据，1<=n<=2000000，0<=ai<=2000000。 提示 你可能需要一个读入优化。


## 样例 #1

### 输入

```
3 
1 2 3```

### 输出

```
4```

# 题解

## 作者：karma (赞：17)

看了楼下的3篇题解.感觉还是说的不明白.具体遇到题该怎么分析,并没有指出.所以写这篇题解作为补充.此题正解为单调递增栈.


**分析**:

为什么是单调递增栈?

此题要求维护区间最小值.


当遍历到后面的元素时,发现此时的元素比之前的最小值要小.意味着之前的最小值已经失效.之后不会再是最小值.所以可以找到它管辖的区间(即在这个区间中,它是最小值)的长度,进而算出区间的美丽值.计算后弹出栈


当遍历到后面的元素时,发现此时的元素比之前的最小值要大.故它不可能成为该区间的最小值.可以保留下来.可能从它开始有一段区间受它管辖.(管辖意义同上).使它进栈.


**步骤**:


此题单调栈要用结构体保存它的值和下标.方便计算它管辖区间的长度.当之后有元素比它小时.它管辖的区间长度即此时的下标减去它之前的一个最小值的下标减1.(原因:不算这个位置和前一个最小值的位置).

最后还要遍历栈.此时每一个元素的管辖区间的右端点均为N.故区间长度为N减该元素进栈时的下标.


代码如下:

```cpp
#include<cstdio>
#define maxn 2000005
struct node{
    long long idx,val;
    //dix为下标,val为值 
}a[maxn],st[maxn];
//st[]为单调递增栈 
//其实a[]没必要用结构体 
int N,top;
long long ans;
long long Max(long long x,long long y){return x>y?x:y;}
//此题似乎要开long long 
int main(){
    scanf("%d",&N);
    for(int i=1;i<=N;++i){
        scanf("%lld",&a[i].val),a[i].idx=i;
        if(!top)st[++top]=a[i];
        else {
            while(st[top].val>a[i].val){ans=Max(ans,st[top].val*(i-st[top-1].idx-1));top--;}//计算弹出去元素的美丽值
            //i-st[top-1].idx-1是这个弹出元素管理的区间 
            //必须计算弹出元素的美丽值,因为有可能成为最大的美丽值 
            st[++top]=a[i];//入栈 
        }
    }
    for(int i=1;i<=top;++i){
        ans=Max(ans,(N-st[i-1].idx)*st[i].val);//遍历栈  
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Leianha (赞：13)

## 单调栈

只是一个比较简单的单调栈题目。我们换一种思考方式，我们枚举每段数列的最小值，然后我们发现当ta所能成为最小值的范围越大，对最终的答案的贡献也就越大。所以我们考虑求出ta所能成为最小值的数列的范围。

这也就转化为了求出右边第一个比ta小的值的位置和左边第一个比ta小的值的位置的问题。这可以用单调栈来解决，我们维护一个单调递增的栈，每次栈顶的元素被弹出的值的位置就是我们所求的被弹的元素的右边第一个比ta小的值的位置。当前元素不在弹出栈顶元素的时候，我们就求出了当前的元素的左边第一个比ta小的值的位置。因为每一个数值仅仅进了一次栈，所以时间复杂度是$O(n)$.

另外还有一个[类似的题目](https://www.luogu.org/problem/AT2060)，想要练习单调栈的童鞋可以写一写。

最后献上我~~丑陋~~的代码

```cpp
#include<iostream>
#include<cstdio>
#define LL long long
using namespace std;
int n,top;
LL ans;
const int N=2000010;
int a[N],l[N],r[N],zhan[N];
inline int read()
{
    int x=0,y=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')y=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*y;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;++i)a[i]=read();
	for(int i=1;i<=n;++i)l[i]=0,r[i]=n+1;
	for(int i=1;i<=n;++i)
	{
		while(top&&a[zhan[top]]>=a[i])r[zhan[top--]]=i;
		l[i]=zhan[top];
		zhan[++top]=i;
	}
	for(int i=1;i<=n;++i)ans=max(ans,(LL)(r[i]-l[i]-1)*a[i]);
	cout<<ans;
	return 0;
}
```


---

## 作者：amstar (赞：5)

/\* luogu 2659

我的天啊，第二个测试点964ms卡过。。。（再交一次就不一定过了。。。90）

然后写一下思路吧：

用线段树logn找出最小值，以及最小值的位置，

包含最小值的所有区间的最大值，应该是区间长度最长的。

当前区间[l,r]，最小值mn,它的位置pos,

包含最小值：[l,r]的答案就是mn\*(r-l+1)

不包含最小值：将[l,r]分成两段，[l,pos-1],[pos+1,r]在这两个区间递归，像上面这样做。

详见代码


\*/




    

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1
#define INF 0x7fffffff
#define MAXN 2000100
#define LL long long
struct MN {
    int mn,pos;
}t[MAXN<<2];
LL ans = 0;
int n;
inline int read() {
    int x = 0,f = 1;char ch = getchar();
    for (; ch<'0'||ch>'9'; ch = getchar())
        if (ch=='-') f = -1;
    for (; ch>='0'&&ch<='9'; ch = getchar())
        x = x*10+ch-'0';
    return x*f;
}
inline void pushup(int rt) {
    if (t[rt<<1].mn < t[rt<<1|1].mn) t[rt].mn = t[rt<<1].mn, t[rt].pos = t[rt<<1].pos;
    else t[rt].mn = t[rt<<1|1].mn, t[rt].pos = t[rt<<1|1].pos;
}
void build(int l,int r,int rt) {
    if (l==r) {
        t[rt].mn = read();
        t[rt].pos = l;
        return;
    }
    int m = (l+r)>>1;
    build(lson);
    build(rson);
    pushup(rt);
}
MN query(int l,int r,int rt,int L,int R) {
    if (L<=l && r<=R) {
        return t[rt];
    }
    int m = (l+r)>>1;
    MN t,ret;
    ret.mn = INF;
    if (L<=m) ret = query(lson,L,R);
    if (R>m)  {
        t = query(rson,L,R);
        if (t.mn < ret.mn) ret = t;
    } 
    return ret;
}
void solve(int l,int r) {
    MN m = query(1,n,1,l,r);
    ans = max(ans,1ll*(r-l+1)*m.mn);
    if (l<m.pos) solve(l,m.pos-1);
    if (m.pos<r) solve(m.pos+1,r);
}
int main() {
    n = read();
    build(1,n,1);
    solve(1,n);
    printf("%lld",ans);    
    return 0;
}

```

---

## 作者：rui_er (赞：3)

看到题解区基本全是单调栈，我来一个不同的思路——用并查集来贪心。

这是一个比较经典的 trick，常用来批量处理一条链/一棵树上路径的最大或最小值问题，大致的思路是按顺序枚举每一条边，并查集维护连通块来算贡献。

具体到本题，我们可以把数列抽象成一条 $n+1$ 点 $n$ 边的链，$i$ 与 $i+1$ 之间的边权为 $a_i$。同时初始化一个有 $n+1$ 个点的并查集，需要记录每个集合的大小。

考虑一条边做出贡献的条件是什么，就是这条边是路径上边权最小的。因此我们将所有边按边权从大到小排序，然后按顺序枚举每一条边，根据它连接的两个连通块的大小和它的边权计算贡献，之后把这条边加到图中（也就是合并它连接的两个连通块）。

由于我们按边权降序枚举，显然在加入一条边时，过这条边的每条路径的最小边权都由这条边贡献。

时间复杂度为 $\mathcal{O}(n\log n)$，开 O2 可过。

```cpp
//By: Luogu@rui_er(122461)
#include <bits/stdc++.h>
#define rep(x,y,z) for(int x=y;x<=z;x++)
#define per(x,y,z) for(int x=y;x>=z;x--)
#define debug printf("Running %s on line %d...\n",__FUNCTION__,__LINE__)
#define fileIO(s) do{freopen(s".in","r",stdin);freopen(s".out","w",stdout);}while(false)
using namespace std;
typedef long long ll;
const int N = 2e6+5;

int n, a[N];
vector<tuple<int, int, int> > e;
template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}
struct Dsu {
	int fa[N], sz[N];
	void init(int x) {rep(i, 1, x) fa[i] = i, sz[i] = 1;}
	int find(int x) {return x == fa[x] ? x : fa[x] = find(fa[x]);}
	bool merge(int x, int y) {
		int u = find(x), v = find(y);
		if(u == v) return 0;
		if(sz[u] < sz[v]) swap(u, v);
		fa[v] = u;
		sz[u] += sz[v];
		sz[v] = 0;
		return 1;
	}
}dsu;

int main() {
	scanf("%d", &n);
	rep(i, 1, n) scanf("%d", &a[i]);
	rep(i, 1, n) e.push_back(make_tuple(i, i+1, a[i]));
	dsu.init(n+1);
	sort(e.begin(), e.end(), [](const auto& a, const auto& b) {
		return get<2>(a) > get<2>(b);
	});
	ll ans = 0;
	for(auto i : e) {
		int u = get<0>(i), v = get<1>(i), w = get<2>(i);
		chkmax(ans, 1LL * (dsu.sz[dsu.find(u)] + dsu.sz[dsu.find(v)] - 1) * w);
		dsu.merge(u, v);
	}
	printf("%lld\n", ans);
	return 0;
}
```

这个 trick 还是很有用的，我遇到过好多次，感兴趣的话可以做一下这些题：

- [AT2060 \[AGC005B\] Minimum Sum](/problem/AT2060) ([AtCoder](https://atcoder.jp/contests/agc005/tasks/agc005_b))
- [\[ABC214D\] Sum of Maximum Weights](https://atcoder.jp/contests/abc214/tasks/abc214_d)

---

## 作者：Mr_think (赞：3)

## [P2659 美丽的序列](https://www.luogu.com.cn/problem/P2659)

## 题目大意：

给出一个序列，找出一个子区间，使该区间的最小值与区间长度乘积最大。

## solution:
我们可以枚举最小值：对于每一个数列中的数字 $a_i$ ，找到当它作为数列最小值时最长的序列，分别用数组 $zuo[i]$ 与 $you[i]$ 保存这时 的左右端点。

以上操作我们可以用单调栈实现，正序找第一个比 $a[ $ $ i $ $ ]$ 小的位置 $-1$ 后就是右端点，栈里还有找不到比它小的数，把 $you[$ $i$ $ ] $ 赋成 $n$ ,倒序 $+1$ 后就是左端点,剩余 $zuo[ $ $ i $ $ ]$ 赋成 $1$ 。
最后 $\max \limits_{i=1}^{n} (you[i]-zuo[i]+1)\times a[i]$ 。

## 接下来是细节的处理：
乘积可能大于 $\text{int}$ 的范围，要开 $\text{long long }$ 。

看到这的同学，可以自己去写代码了(~~tf口吻~~)

[code](https://www.luogu.com.cn/paste/354q5rqe)
### End
## 作者的碎碎念：

有用留赞(~~言简意赅~~)

---

## 作者：Utilokasteinn (赞：2)

来一个线段树题解

$O(n^2log_n)$ 暴力思路：

$n^2$ 枚举左右端点， $log_2n$ 查询最小值，时间复杂度 $O(n^2log_2n)$ ，只能得20分。

$O(nlog_2n)$ “正解”思路：

先找到区间 $[1,n]$ 的最小值 $a_i$，算出以 $a_i$ 为最小值时的美丽度。然后以 $i$ 为中心，找到区间 $[1,i-1]$ 和 区间 $[i+1,n]$ 的最小值 $a_j$ 和 $a_k$ ，计算它们的美丽度，然后分别以 $j$ 和 $k$ 为中点递归左右区间。

由于每个数都会被当作中点计算一次美丽度（查询最小值），每次计算（查询）的用线段树维护是 $log_2$ 的，而有 $n$ 个点，所以时间复杂度是 $(nlog_2n)$ 。

注意要开 $long\;long$ 。

$code$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
struct tree{
	int l,r,min,sp;
}s[8000001];
ll n,ans;
int read()
{
	int s=0,f=1;char c=getchar();
	for(;!isdigit(c);c=getchar())
		if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())
		s=s*10+c-'0';
	return s*f;
}
void build(int l,int r,int p)
{
	s[p].l=l,s[p].r=r;
	if(l==r)
	{
		s[p].min=read();
		s[p].sp=l;
		return;
	}
	int mid=(l+r)/2;
	build(l,mid,p*2);
	build(mid+1,r,p*2+1);
	if(s[p*2].min<s[p*2+1].min)
		s[p].min=s[p*2].min,s[p].sp=s[p*2].sp;
	else s[p].min=s[p*2+1].min,s[p].sp=s[p*2+1].sp;
}
tree find_min(int l,int r,int p)
{
	if(l>s[p].r||r<s[p].l)return s[0];
    if(s[p].l>=l&&s[p].r<=r)
        return s[p];
    tree a=find_min(l,r,p*2);
	tree b=find_min(l,r,p*2+1);
    if(a.min>b.min)a=b;
    return a;
}
void find_max(int l,int r)
{
	tree x=find_min(l,r,1);
	ans=max(ans,1ll*(r-l+1)*x.min);
    if(l<x.sp)find_max(l,x.sp-1);
    if(x.sp<r)find_max(x.sp+1,r);
}
int main()
{
	s[0].min=1e9;
	n=read();
	build(1,n,1);
	find_max(1,n);
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：Star_Cried (赞：2)

## P2659 美丽的序列

`tag` 笛卡尔树

### 题意

找出一个序列的所有子段中子段长度乘段内元素最小值的最大值。

### 思路

我们需要找出所有**子段**中贡献最大的，并且一个子段的贡献为**其长度乘区间最小值**。

这……不就是裸的笛卡尔树吗？

建出符合小根堆性质的笛卡尔树，递归所有点，更新答案即可。

因为这是一道裸题，所以我记录一下建笛卡尔树的模板。（从 OI wiki 上扣的）

思路是用一个单调栈维护一下右链。

伪代码：

```pascal
新建一个大小为 n 的空栈。用 top 来标操作前的栈顶，k 来标记当前栈顶。
For i := 1 to n
    k := top
    While 栈非空 且 栈顶元素 > 当前元素 
        k--
    if 栈非空
        栈顶元素.右儿子 := 当前元素
    if k < top
        当前元素.左儿子 := 之前栈顶元素
    当前元素入栈
    top := k
```

C++:

```cpp
for(int k,i=1;i<=n;i++){
    k=top;
    while(k and a[st[k]]>a[i])k--;
    if(k) rs[st[k]]=i,isrt[i]=1;
    if(k<top) ls[i]=st[k+1],isrt[st[k+1]]=1;
    st[++k]=i;
    top=k;
}
```

### 本题实现

本题需要找出每个子段最小值乘子段长度。我们先建出笛卡尔树，然后找到笛卡尔树的根，将区间初始化为 1-n，然后向下 dfs。每次使用该点坐标将区间进行划分。也就是：

```cpp
if(ls[x])dfs(ls[x],l,x-1);
if(rs[x])dfs(rs[x],x+1,r);
```
然后更新答案即可。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<cstring>
#include<cmath>
using namespace std;
inline int read(){
	int w=0,x=0;char c=getchar();
	while(!isdigit(c))w|=c=='-',c=getchar();
	while(isdigit(c))x=x*10+(c^48),c=getchar();
	return w?-x:x;
}
namespace star
{
	const int maxn=2e6+10;
	int n,a[maxn],ls[maxn],rs[maxn],st[maxn],top;
	long long ans;
	bool isrt[maxn];
	void dfs(int x,int l,int r){
		ans=max(ans,1ll*a[x]*(r-l+1));
		if(ls[x])dfs(ls[x],l,x-1);
		if(rs[x])dfs(rs[x],x+1,r);
	}
	inline void work(){
		n=read();
		for(int i=1;i<=n;i++) a[i]=read();
		for(int k,i=1;i<=n;i++){
			k=top;
			while(k and a[st[k]]>a[i])k--;
			if(k) rs[st[k]]=i,isrt[i]=1;
			if(k<top) ls[i]=st[k+1],isrt[st[k+1]]=1;
			st[++k]=i;
			top=k;
		}
		int root=0;
		for(int i=1;i<=n;i++) if(!isrt[i]) root=i;
		dfs(root,1,n);
		printf("%lld\n",ans);
	}
}
signed main(){
	star::work();
	return 0;
}
```

### 其他

~~为什么你谷连带 log 的做法都有就是没人写笛卡尔树呀QAQ~~

笛卡尔树它多可爱呀~

---

## 作者：hanzhongtlx (赞：2)

提供一种比较屑的 $\mathcal O(n\log n)$ 解法。  

当然常数很小。。。。  
 
首先考虑到将这些数钦定为最小值，然后去找区间，易证答案一定来自于满足此值最小的最长区间。  

我们于是可以从最大值开始枚举，判断他的两侧已经有多少被枚举过了（这些数一定比他大），然后算就完了。  

可是如何判断已经被枚举的最左，最右在哪里呢。  

我们把已被用的搞成区间，记录一下左右端点，然后不断计算，扩展即可得到答案。  

具体见代码：  

```
#include"algorithm"
#include"iostream"
#include"cstdio"
#include"cmath"
using namespace std;

#define read(x) scanf("%d",&x)
#define ll long long
#define MAXN 2000005

int n;
int num[MAXN];
int t[MAXN],l[MAXN],r[MAXN];
struct node
{
	int val,id;
}a[MAXN];
int cnt=0;
ll ans=0;

bool cmp(node n,node m){return n.val>m.val;}

void hsh()
{
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++) num[++cnt]=a[i].id;
	return;
}

int main()
{
	read(n);
	for(int i=1;i<=n;i++) read(a[i].val),t[i]=a[i].val,a[i].id=i;
	hsh();
	for(int i=1;i<=n;i++)
	{
		int j=num[i],len=1;
		if(l[j-1]) len=len+(j-l[j-1]);
		if(r[j+1]) len=len+(r[j+1]-j);
		ans=max(ans,(ll)len*(ll)t[j]);
		if(l[j-1]&&r[j+1])
		{
			int op=l[j-1],rt=r[j+1];
			l[j-1]=0,r[j+1]=0;
			r[op]=rt,l[rt]=op;
		}
		else if(l[j-1])
		{
			int t=l[j-1];
			l[j-1]=0,l[j]=t,r[t]=j;
		}
		else if(r[j+1])
		{
			int t=r[j+1];
			r[j+1]=0,r[j]=t,l[t]=j;
		}
		else l[j]=r[j]=j;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：青鸟_Blue_Bird (赞：1)

发现题解区都没有写部分分的，但考场上部分分很重要，所以发一篇题解来总结一下。

### 题意

找到一段区间，使得区间的最小值乘上区间的长度的值最大。

### 步骤

我们来一步步分析部分分。

$Subtask1$ $20pts$: 

考虑用循环枚举区间，同时用线段树优化寻找区间最小值，时间复杂度 $O(N^2logN)$。

$Subtask2$ $60pts$: 

观察数据范围，可以发现，这个部分分应该是带有 $logN$ 的做法。考虑如下性质：

1. 对于一个最小值，我们要想使得答案最大，肯定是要求该最小值生效的区间最长。

1. 对于一个区间，如果我们删掉其最小值，然后缩短其区间长度，答案**可能**变大。

从以上两条性质，我们考虑递归求解。从区间 $[1,n]$ 开始，我们每次用线段树查询当前区间的最小值，并计算答案。
如果最小值的 $pos$ 处于区间中间，考虑向两边递归，尝试去掉最小值。处于区间边界时特判，直接左移一位或者右移一位即可。

小 $trick$: 线段树查询时可以利用结构体同时查询最小值和 $pos$，同时重载运算符来缩短 $pushup$ 函数的长度。

具体实现题解区的 $amstar$ 大佬好像已经写了，不再赘述。时间复杂度~~应该~~是 $O(Nlog^2N)$

$Subtask3$ $100pts$: 

考虑如何将算法优化至 $O(N)$ 的。上面的两个算法有一些不足之处：

1. 枚举区间

1. 每次都要 $O(logN)$ 的时间来查询最小值。

对于第二条，我们不妨先假设当前的值作为最小值，这是 $O(N)$ 的。然后，考虑什么样的情况下这个数作为最小值时答案最大。

从上文我们可以知道，答案的区间应该尽量长。答案最长区间的端点，贪心地想，就是当前最小值**更新换代**的地方。在哪里更新换代？自然就是分别向左和向右第一个比当前值小的那里啦！

那么我们的正解也就出来了：找到每个数的向左和向右第一个比它小的位置，那么就有当前答案： $a_i * (r_i - 1 - (l_i + 1) + 1)$。

单调栈预处理 + 线性枚举，时间复杂度 $O(N)$。


附 $100pts$ 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 2000010
#define ll long long

template <class T>
inline void read(T& a){
	T x = 0, s = 1;
	char c = getchar();
	while(!isdigit(c)){ if(c == '-') s = -1; c = getchar(); }
	while(isdigit(c)){ x = x * 10 + (c ^ '0'); c = getchar(); }
	a = x * s;
	return ;
}

int stac[N], top = 0;
int a[N]; 
int l[N], r[N]; 
int n;

int main(){
	read(n);
	for(int i = 1; i <= n; i++){
		read(a[i]);
		l[i] = 0, r[i] = n + 1;     // 记得设置边界 
	}
	for(int i = 1; i <= n; i++){  // 单调栈 
		while(top && a[stac[top]] >= a[i]) r[stac[top--]] = i;  
		l[i] = stac[top];
		stac[++top] = i; 
	}
	ll ans = 0;       // 不开 long long 见祖宗 
	for(int i = 1; i <= n; i++)
		ans = max(ans, (ll)(r[i] - 1 - (l[i] + 1) + 1) * a[i]); 
	cout << ans << endl; 
	return 0;
}


```


---

## 作者：AtlasDelRey (赞：1)

用单调栈做的，思想的话应该和上面两位大佬差不多吧……？因为是蒟蒻所以有点辣鸡，请多多包涵啦

···cpp

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int  n,a;
long long maxx,top,sum,zhan[2000001],place[2000001];//是的名字就是这么粗暴zhan就是栈place就是位置
void read(int &x) {     //听说题目说读入要优化
    x=0;
    int f=1;
    char ch=getchar();
    while (ch<'0'||ch>'9') {
        if (ch=='-') f=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9') {
        x=x*10+ch-'0';
        ch=getchar();
    }
    x*=f;
}
int main()
{
    read(n);
    for(int i=1;i<=n;i++)     //数组模拟单调栈
    {
        read(a);
        while(zhan[top]>a)     //弹出元素时顺路计算美丽度
        {
            sum=zhan[top]*(i-place[top-1]-1);//计算美丽度
            top--;//弹！
            if(sum>maxx)maxx=sum;//和前面算出的最大值比较
        }
        zhan[++top]=a;place[top]=i;
    } 
    while(top!=0)//处理栈内未弹出的元素
    {
        sum=zhan[top]*(n-place[top-1]);
        top--;
        if(sum>maxx)maxx=sum;
    }
    printf("%lld",maxx);
}
···
```

---

## 作者：傅思维666 (赞：0)

## 题解：


如果要用线段树，需要枚举所有区间。

显然是不可的。

那么我们现在要求最大美丽度。我们思考剪去一些无用区间。

什么区间无用呢？贪心地思考，区间长度肯定是越大越好，那么对于一个点来讲，左右同时拓展这个区间，直到找到左右第一个小于它的元素，记作$l,r$，那么区间$(l,r)$一定是这个点能管控到的最大美丽值。因为这个点已经是这个区间中最小的元素。

那么所有点都可以依此维护，显然地，答案一定会在这些值中产生。理由是每个点都已经这样拓展过了，而每个点都是最优的。

至于左右第一个小于它的元素，可以用单调栈来维护，正反各跑一次，然后就是细节的更新了。

代码：

```cpp
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
const int maxn=2e6+3;
int n,ans;
int a[maxn];
int s[maxn],top;
int l[maxn],r[maxn];
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	a[0]=a[n+1]=-1;
	for(int i=1;i<=n+1;i++)
	{
		while(top && a[i]<a[s[top]])
		{
			r[s[top]]=i;
			top--;
		}
		s[++top]=i;
	}
	while(top)
		top--;
	for(int i=n;i>=0;i--)
	{
		while(top && a[i]<a[s[top]])
		{
			l[s[top]]=i;
			top--;
		}
		s[++top]=i;
	}
	for(int i=1;i<=n;i++)
	{
		int len=r[i]-1-l[i];
		int tmp=a[i]*len;
		ans=max(ans,tmp);
	}
	printf("%lld\n",ans);
	return 0;
}
```



---

## 作者：怺忆 (赞：0)

本题有两个新定义：美丽度、美丽系数

其中 美丽度=（序列长度*这个序列的最小值）；

对此 我们最先想到的是枚举一个序列，

然后找出这个序列的最小值相乘，

但这样时效显然是过不去的，

那么，我们就可以反过来思考，那就是枚举一个最小值，再确定序列的范围；

上述可知，我们确定的这个序列的最小值是已定的，而我们又希望美丽系数尽可能的大，那么，

这个序列的长度也要尽可能的大，所以，我们要知道从这个最小的点向左右最多能扩展到哪，

才会遇见比自己小的数；

```cpp
for(int i=1;i<=n;i++){
		while(til>0&&a[i]<=a[h[til]]) til--;
		f[0][i]=h[til];h[++til]=i;
}
```


//向左边寻找第一个比自己小的数；可以使用单调栈的思想;用 f 数组记录左边界

```
for(int i=n;i;i--){
		while(til>0&&a[i]<=a[h[til]]) til--;
		f[1][i]=h[til];h[++til]=i;
}
```

 //再从n到1反刷一趟确定右边界；   
 //第二次反刷时要注意 h[0]=n+1;
 
 
```cpp
 #include<bits/stdc++.h>
using namespace std;
int h[2000005],a[2000005],n,til,f[2][2000005];
long long ans;
int read(){
	int ret=0;char ch=getchar();
	while (ch<'0'||ch>'9') ch=getchar();
	while (ch>='0'&&ch<='9')
    ret=ret*10+ch-'0',ch=getchar();
	return ret;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=n;i++){
		while(til>0&&a[i]<=a[h[til]]) til--;
		f[0][i]=h[til];h[++til]=i;
	}
	til=0;h[0]=n+1;
	for(int i=n;i;i--){
		while(til>0&&a[i]<=a[h[til]]) til--;
		f[1][i]=h[til];h[++til]=i;
	}
	for(int i=1;i<=n;i++)
	if(ans<(long long)
    a[i]*(f[1][i]-f[0][i]-1)) 
    ans=(long long)a[i]*(f[1][i]-f[0][i]-1);
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：晚风 (赞：0)

##据说本题可以用 **动态规划** 解决 然而蒟蒻并不会用dp解决 所以还是弱弱的写了一个 **单调栈**


单调栈基本应用 **简单**的说 可以在O(n)下求出一个序列中每个元素 向右 或 向左 比它 小 或 大 的第一个元素


基本操作自行百度)


那么我们需要把这道题变形一下  [Luogu] http://acm.hdu.edu.cn/showproblem.php?pid=1506

两题是**完全一**样的


把这道题化成链接里面的样子

**分别**求出每个元素向左和向右扩展的最大长度


最后每个元素获得的最大总面积等于 （向左延伸的长度 + 向右延伸的长度 + 1） \* 元素高度


##一定要分别求左右的扩展

也就是说要正反两次 正的求出向右 反的求出向左的（逆序枚举就行了）


```cpp
#include <bits/stdc++.h>
using namespace std ;
typedef long long ll ;
const ll N = 2000005 ;
ll Mesheight[N] , n , MaxArea , r[N] , l[N] ;
class Element{
public:
  Element(ll h , ll index)
    : height(h)
    , startIndex(index)
  {}
  ll height , startIndex ;
};
stack<Element> s ;
void Clear(){
    while (!s.empty()) s.pop() ;
}
ll GetMaxArea(const ll Mesheight[] , const ll len){
  memset(l , 0 , sizeof(l)) ;
  memset(r , 0 , sizeof(r)) ;
  MaxArea = 0 ;
  Clear() ;
  s.push(Element(0 , 0)) ;//最左端初始化 使得后来的元素可以push进去
  for ( ll i = 1 ; i <= len + 1 ; i++ ){
    if (i == len + 1){//当所有的元素已经进入 单调栈里此时从底到顶是升序的
        while (s.empty() != 1){//只留下初始化的没有作用的元素
            r[s.top().startIndex] = n - s.top().startIndex ;
            s.pop() ;
        }
        break ;
    }
    while (Mesheight[i] < s.top().height){//如果但进入的元素不符合单调栈顺序
        r[s.top().startIndex] = i - s.top().startIndex - 1 ;//获得此时栈顶元素向右扩展的最长长度
        s.pop() ;//注意可能有多个元素被pop出来
    }
    s.push(Element(Mesheight[i] , i)) ;// 加入栈顶
  }
  Clear() ;
  s.push(Element(0 , len + 1)) ;//同正序
  for ( ll i = len ; i >= 0 ; i-- ){
    if (i == 0){
        while (s.size() != 1){
            l[s.top().startIndex] = s.top().startIndex - 1 ;
            s.pop() ;
        }
        break ;
    }
    while (Mesheight[i] < s.top().height){
        l[s.top().startIndex] = s.top().startIndex - i - 1 ;
        s.pop() ;
    }
    s.push(Element(Mesheight[i] , i)) ;
  }
  for ( int i = 1 ; i <= len ; i++ )
    MaxArea = max (MaxArea , (l[i] + r[i] + 1) * Mesheight[i]) ;//枚举最大的面积
    return MaxArea ;
}
int main(){
  while (cin >> n && n){
    memset(Mesheight , 0 , sizeof(Mesheight)) ;
    for ( ll i = 1 ; i <= n ; i++ )
      scanf ("%lld" , &Mesheight[i]) ;
    cout << GetMaxArea(Mesheight , n) << endl ;
  }
  return 0 ;
}
```




---


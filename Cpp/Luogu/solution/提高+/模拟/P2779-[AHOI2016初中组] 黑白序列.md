# [AHOI2016初中组] 黑白序列

## 题目背景

小可可知道小雪喜欢什么样子的黑白序列。

## 题目描述

首先，对于任何正整数 $n$，如果一个黑白序列是由连续 $n$ 个黑接上连续 $n$ 个白，那一定是小雪喜欢的黑白序列。

其次，如果有两个黑白序列小雪都喜欢，那么把这两个序列接起来得到的新序列，小雪也一定喜欢。小雪不会喜欢更多别的黑白序列。

例如，如果用字符 `B` 和 `W` 分别表示黑色，`W` 表示白色，那么 `BW`，`BBWW`，`BBBWWW` 以及 `BWBW`，`BWBBWW`，`BWBBWWBW` 都是小雪喜欢的黑白序列。而 `W`，`WW`，`WB`，`WBBW` 以及 `BBBWW` 都不是小雪喜欢的黑白序列。

现在小可可准备了一个未完成的黑白序列，用 `B` 和 `W` 表示黑色和白色，用 `?` 表示尚未确定，他希望知道一共有多少种不同的方法，在决定了每一个 `?` 位置的颜色后可以得到一个小雪喜欢的黑白序列。

两个方案若有至少一位不同才能算是不同的，不是 `?` 的位置是不允许修改的。

答案对 $10^9 + 9$（一个素数）取模。







## 说明/提示

#### 样例输入输出 1 解释
有六种合法方案，依次得到的最终黑白序列为： 

- `BBBBWWWW`，
- `BBBWWWBW`，
- `BWBBBWWW`，
- `BWBBWWBW`，
- `BWBWBBWW`，
- `BWBWBWBW`。

#### 数据规模与约定

- 对于 $20\%$ 的数据，输入长度不超过 $22$。
- 对于 $60\%$ 的数据，输入长度不超过 $5000$。
- 对于 $100\%$ 的数据，输入长度不超过 $500000$，保证序列中只含 `W`，`B`，`?` 三种字符，其中 `?` 是英文字符。

## 样例 #1

### 输入

```
B?B?????```

### 输出

```
6```

## 样例 #2

### 输入

```
??BB????W???BB??????```

### 输出

```
26```

## 样例 #3

### 输入

```
????????B???????????W??B?????W????????????????????W????????W```

### 输出

```
10058904```

# 题解

## 作者：PosVII (赞：15)

**前言**

------------

此解法使用动态规划。

此方法时间复杂度在最坏情况下是 $O(n^2)$，因此此解法不稳定。

但我的代码是耗时最少的，这说明此解法在数据完全随机时复杂度更低。

**入手**

------------

如何确定一个字符串是黑白序列呢？我们看一个黑白序列有什么特殊的地方。

一个黑白序列 $str$，我们会发现它的首尾，中间的两个字符分别是 $B$，$W$，$B$，$W$。

那么我们就可以遍历这个字符串，找到其中任何一个特征，我们就可以寻找以其为首、尾或中间两字符的字符串。

那么动态规划的思路自然就出现了，其阶段定义为：

$dp[i]$ 表示变化字符串前 $i$ 个字符中的问号，能使字符串前 $i$ 个字符组成一个黑白序列的方法总数。

阶段定义完毕，我们要确定寻找黑白序列的特征。

很明显，因为黑白序列是对称的，我们只能选择两种特征。

**首尾为特征**

------------

常规做法。但是我们优化一下。

我们可以知道，前缀和可以快速确定区间中某个东西的数量，我们可以用这个快速判断我们枚举到的字符串是否为黑白序列。

可以拿到 $60pts$。

**中间为特征**

------------

如何 $O(1)$ 确定是否为黑白序列？我们可以从中间一层一层像寻找回文串一样找。那么我们可以对以同一个字符为中间特征的黑白序列快速寻找。

那么我们只需要枚举中间特征，再一个个扩大范围直到出现不符合的情况时直接跳出枚举循环即可。

请注意，我们在每一次更新左右端点时要看其是否符合条件。下标难以确定的话可以画图思考。

循环时不要枚举字符串的长度，这样会导致你会提前加上没有被更新的值。


**Code**

------------

```cpp
#include<bits/stdc++.h>
using namespace std;
const int p=1e9+9;
char str[500006]; 
int dp[500006]={1},n;
int main() {
    cin>>str+1;
    n=strlen(str+1);
    for(int i=1;i<=n;i++) {
    	if(str[i]!='W') {
    		int l=i,r=i+1;
    		for(int j=i;l>=1&&r<=n;j++) {
    			if(str[l]=='W'||str[r]=='B') break;
    			dp[r]=(dp[r]+dp[l-1])%p;
    			l--,r++;
			}
		}
	}
	cout<<dp[n];
    return 0;
}
```

---

## 作者：star_magic_young (赞：9)

*注:本题解中下标从1开始*

这题可以想出一个$O(n^2)$的dp,只要考虑每个偶数位置可以从前面的哪个位置加上一个"B...W..."转移过来

然而数据范围有5e5,,,

~~打表找规律(误),~~可以发现转移的时候,能够转移位置构成的集合**可能**会向前多一个元素,向后多一个元素,或者中间少掉一些或全部元素

简化问题,如果现在在$i$位置有一个W,同时前面的$j$位置到$i$之间没有W,那么在往后转移的过程中,如果转移到了$2i-j$,那么$j$就无法向后贡献答案了

就像这样 ![](https://cdn.luogu.com.cn/upload/pic/33476.png)

可以发现因为$i$位置为W,所以$j$最多只能贡献到位置$2i-j-2$

所以求出每个位置$j$后面最近的W位置$i$,然后在$2i-j$处像存图一样跟$j$连边

转移的时候,用一个变量$sum$存储能够转移的所有$f_j$之和,如果当前位置为B就无法转移,否则如果前一个位置为B就只能从这个位置往前两个的位置转移过来,其他情况,用一个指针$tl$表示当前转移区间的左端点,每次往左移动加入答案;还要记得把该位置所连出去的点,也就是无法贡献答案位置贡献扣除,每次把$f_i$加到$sum$里去

这里参考了之前大佬的思路和代码

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define LL long long
#define il inline
#define re register
#define inf 2099999999
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define db double
#define eps (1e-5)

using namespace std;
const int N=500000+10,mod=1000000009;
il LL rd()
{
    re LL x=0,w=1;re char ch=0;
    while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*w;
}
int n,f[N],nxt[N],tl,sum;
int to[N],nt[N],hd[N],tot=1;
il void add(int x,int y)
{
  if(x<=n) ++tot,to[tot]=y,nt[tot]=hd[x],hd[x]=tot;
}
il void del(int x)
{
  for(int i=hd[x];i;i=nt[i])
    {
      if(to[i]>=tl) sum=(sum-f[to[i]]+mod)%mod;
      f[to[i]]=0;
    }
}
char cc[N];

int main()
{
  scanf("%s",cc+1);
  n=strlen(cc+1);
  if(n&1) {puts("0");return 0;}
  nxt[n]=n+1;
  for(int i=n-1;i>=0;i--) nxt[i]=(cc[i+1]=='W')?i+1:nxt[i+1];
  for(int i=0;i<=n;i+=2) add((nxt[i]<<1)-i,i);
  f[0]=sum=1;
  for(int i=2;i<=n;i+=2)
    {
      del(i);
      if(cc[i]=='B') sum=0,tl=i;
      else if(cc[i-1]=='B') sum=f[i-2],tl=i-2;
      else
        {
          tl-=2;
          if(tl>=0) sum=(sum+f[tl])%mod;
        }
      sum=(sum+(f[i]=sum))%mod;
    }
  printf("%d\n",f[n]);
  return 0;
}

```

---

## 作者：浮尘ii (赞：9)

（以下内容全部来自官方）

##题目分析

一个显而易见的动态规划方程用F[i]记录前i位可以得到的不同黑白序列的个数。转移需要考虑所有的j<i，并尝试使j+1到i是一个独立的黑白序列段。总时间复杂度是O(n^2)的，这便可以得到65分。

考虑上述转移中涉及到的j，可以发现需要被考察的j往往是连续的偶数，而其中的断点总会使得对最后一个黑白序列段的长度要求有了两倍以上的限制。所以转移中j的断点只有O(logn)个。用链表维护需要转移的连续若干个j，总的时间复杂度为O(nlogn)，便可以得到满分。


##std
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>

using namespace std ;

typedef long long ll;

const ll MOD = 1e9+9;
const int MAXN = 500100;

int Solve() {
    string s ; cin >> s ;
    int N = s.size() ;
    vector<int> cntW(N+1, 0), cntO(N+1, 0);
    for (int i = 1; i <= N; i++) {
        cntW[i] = cntW[i-1] + (s[i-1] == 'B');
        cntO[i] = cntO[i-1] + (s[i-1] == 'W');
    }
    vector<int> c(N/2, 0);
    for (int i = 0; i < N/2; i++) {
        int _low = i, _high = N/2+1;
        while (_high-_low > 1) {
            int med = (_high+_low)/2;
            int cw = cntW[2*med]-cntW[2*i];
            int co = cntO[(2*med+2*i)/2]-cntO[2*i];
            if (cw == 0 && co == 0) _low = med;
            else _high = med;
        }
        c[i] = _low;
    }
    vector<int> a(N/2+1, 0), b(N/2+1, 0);
    for (int i = 1; i <= N/2; i++) {
        int maxW;
        int _low = -1, _high = 2*i;
        while (_high-_low > 1) {
            int med = (_high+_low)/2;
            if (cntW[2*i]-cntW[med] < 1) _high = med;
            else _low = med;
        }
        maxW = _low;
        a[i] = 2*N, b[i] = -1;
        if (maxW == -1) continue;
        a[i] = max(0, maxW-i+1);
        int maxO;
        _low = 2*a[i]-1, _high = maxW;
        while (_high-_low > 1) {
            int med = (_high+_low)/2;
            if (cntO[maxW]-cntO[med] < 1) _high = med;
            else _low = med;
        }
        maxO = _low;
        a[i] = max(a[i], (maxO+2)/2);
        b[i] = maxW/2+1;
        int minO;
        _low = maxW+1, _high = 2*i;
        while (_high-_low > 1) {
            int med = (_high+_low)/2;
            if (cntO[med]-cntO[maxW] == 0) _low = med;
            else _high = med;
        }
        minO = _low;
        b[i] = min(minO-i+1, b[i]);
    }
    vector<ll> dp(N/2+10, 0), dpSum(N/2+10, 0), imos(N/2+10, 0);
    ll plus = 0;
    dp[0] = 1; dpSum[1] = 1;
    if (c[0] > 0) {
        plus = dp[0];
        imos[c[0]] = MOD-1;
    }
    for (int i = 1; i <= N/2; i++) {
        dp[i] = plus;
        if (a[i] < b[i]) {
            dp[i] += dpSum[b[i]]-dpSum[a[i]]+MOD;
            dp[i] %= MOD;
        }
        dpSum[i+1] = (dpSum[i] + dp[i]) % MOD;
        (plus += imos[i]) %= MOD;
        if (c[i] > i && c[i] <= N/2) {
            (plus += dp[i]) %= MOD;
            (imos[c[i]] += MOD-dp[i]) %= MOD;
        }
    }
    return (int)dp[N/2];
}

int main() {
    freopen("bwsque.in","r",stdin);
    freopen("bwsque.out","w",stdout);
    cout << Solve() << "\n" ;
}
```

---

## 作者：xkai (赞：7)

## 前言
看到有些 $O(n^2)$ 的做法能过，但这种算法很容易就能卡掉，没必要非说数据随机下表现优秀。看到题解区正解较少，那我来提供一个 $O(n\log n)$ 的树状数组（或线段树）的做法。
## 做法
### 状态表示
原字符串为 $s$，状态 $f_{i}$ 表示以下标 $i$ 结尾的合法序列个数，$black_{i}$ 表示从 $i$ 开始往后最长的能够放置黑棋的长度（即 $s_{i}$ 到 $s_{i+black_{i}-1}$ 中只含有"B"和"?"，不含"W"），$white_{i}$ 表示从 $i$ 开始往前最长的能够放置白棋的长度（即 $s_{i-white_{i}+1}$ 到 $s_{i}$ 中只含"W"或"?"，不含"B"）。
### 状态转移
$f_{i}$ 能转移到 $f_{j}(i<j)$，当且仅当 $black_{i+1}\geqslant\frac{(j-i)}{2}$ 且 $white_{j}\geqslant\frac{(j-i)}{2}$ 。 进一步地，$j\geqslant i+2\times black_{i+1}$ 且 $i\geqslant j-2\times white_{j}$ 。
但是如果只在 $i$ 端往后寻找所有满足的 $j$ ，或只在 $j$ 端往前寻找满足条件的 $i$ ，都稍微有些困难。考虑到这两个条件对 $i$ ，$j$ 都有限制，所以把两个条件分开：只满足 $j\geqslant i+2\times black_{i+1}$ 的 $j$ 一定是从 $i+2$ 开始的连续的一段偶数，只满足 $i\geqslant j-2\times white_{j}$ 的 $i$ 一定也是到 $j$ 结束的连续的一段偶数。**所以我们可以将转移分成修改和查询两个操作，每个操作分别满足其中一个条件**。
### 算法流程
假定正在计算 $f_{i}$ （dp外层循环由小到大枚举到 $i$ ）。
并定义前缀和 $sum_{i}=\sum_{j=0}^i f_{j}$ 。
执行以下流程：
1. 将现在已经无效的答案从前缀和删去。

1. 统计当前答案，$f_{i}=sum_{i-2}-sum_{i-white_{i}\times 2-2}$ 。

1. 将 $f_{i}$ 加入前缀和，并在外层循环枚举到 $i+black_{i}\times 2+2$ 时从前缀和删除 $f_{i}$ （即1.中提及的删除操作）。

动态维护前缀和使用树状数组（线段树），使最终复杂度降到 $O(n\log n)$ 。
### 注意事项
1. $f_0$ 在计算过程中也会成为无效答案，要注意删除。

1. 查询/修改时下标可能超出数组范围，要判断边界。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=500010,mod=1e9+9,D=5;
typedef long long ll;
int n,bl[N],wh[N],tl[N],tr[N];
int f[N],c[N];
char s[N];
vector<int>tg[N];
void Insert(int x,int v){
	x+=D;
	for(;x<=n+D;x+=x&-x)c[x]=((ll)c[x]+v+mod)%mod;
}
int query(int x){
	x+=D;
	ll r=0;
	for(;x;x-=x&-x)r+=c[x];
	return r%mod;
}
int main(){
	freopen("test.in","r",stdin);
	scanf("%s",s+1);
	n=strlen(s+1);
	for(int i=n;~i;i--){
		if(s[i]=='W')bl[i]=0;
		else bl[i]=bl[i+1]+1;
	}
	for(int i=1;i<=n;i++){
		if(s[i]=='B')wh[i]=0;
		else wh[i]=wh[i-1]+1;
	}
	for(int i=0;i<=n;i+=2)
		if(s[i]!='B'&&s[i+1]!='W'){
			tl[i]=i+2;tr[i]=min(i+bl[i+1]*2+2,n+1);
			tg[tl[i]].push_back(i);
			tg[tr[i]].push_back(i);
		}
	f[0]=1;
	for(int i=2;i<=n;i+=2){
		for(int j=0;j<tg[i].size();j++){
			if(tl[tg[i][j]]==i)Insert(tg[i][j],f[tg[i][j]]);
			else Insert(tg[i][j],-f[tg[i][j]]);
		}
		if(s[i]!='B'){
			int wl=max(i-wh[i]*2-2,-1),wr=i-2;
			f[i]=(query(wr)-query(wl)+mod)%mod;
		}
	}
	printf("%d",f[n]);
}
```


---

## 作者：zzy_123 (赞：4)

这个题目可以不用标签上的线段树，直接DP。
首先状态转移f[i]=Σf[j](j<i)
但是有很多种情况可以不用考虑，一旦第一次遇到不可以的情况，那么就可以停止转移，因为后续的状态肯定也不可以。
于是开始枚举情况中的第一个"W"，从这个"W"依次往后判断之后是否出现了"B"或者前面对应的出现了"W"，那么就停止转移，否则此次枚举就可以为最后一个"W"所在的位置更新答案，增加的方案数为最前面的"B"的前面的方案数。由于是考虑第一个"W"，且前一个字母是"B",所以前面的所有状态均已到达最优。
注意考虑初始情况f[0]=1;

详情见代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long int f[501010],n;
string sum;
int main()
{
   int a,b,c,d,e;
   string h;cin>>h;
   sum=" ";sum+=h;n=sum.size()-1;//强迫症，也利用计算，使每个数的位置在字符串中的位置相同。
   f[0]=1;
   for(a=1;a<=n;a++)
   {
	if(sum[a]=='W'||sum[a]=='?')
	{
	   for(b=a;b<=n&&2*a-b-1>0;b++)//2*a-b即为最前面的"B"的位置
	   if(sum[2*a-b-1]!='W'&&sum[b]!='B')
	   f[b]+=f[2*a-b-2]%1000000009;//增加的方案数为最前面的"B"的前面的数的方案数。
	   else break;//否则此处无法满足那么以后也无法满足情况。
	}		
   }cout<<f[n]%1000000009;
}
```


---

## 作者：沙鵖之祖 (赞：3)

设 $n$ 为序列长度。

首先，$O(n^2)$ 的暴力 dp 应该是好想的，~~就连我这种大蒟蒻也想得出来。~~

我们先定义**基本可行序列**是不能被拆成多个可行序列的可行序列。

如 $\verb!BW!$,$\verb!BBBWWW!$ 都是基本可行序列，$\verb!BWBBWW!$ 就不是基本可行序列，它可以被拆成 $\verb!BW!$,$\verb!BBWW!$ 两个可行序列。我们可以实现在 $O(n^2)$ 的时间复杂度内处理好 $\mathit{S}_{i,j}$（以 $i$ 开头，以 $j$ 结尾的子序列）是否是基本可行序列。

设 $f_{i}$ 为以第 $i$ 位**结尾**的序列中有多少种可行方案，很明显，我们可以枚举所有的 $w<i$，若 $\mathit{S}_{w+1,i}$ 是一个基本可行序列，就让 $f_{i}$ 加上 $f_{w}$。

发现一个序列的结尾必定是偶数位，所以对 $i$ 与对 $w$ 的枚举可以减半。

接下来想怎么得满分。

我们枚举每一个**偶数位** $i$ 观察能否在小于 $O(n)$ 的时间复杂度内快速处理出 $f_{i}$ 的值。

首先，若 $c_{i}$（$i$ 的颜色）为 $\verb!B!$，显然它做不了结尾，$f_{i}=0$。

其次，若是 $c_{i-1}$ 为 $\verb!B!$ 那么我们只可能取到 $f_{i-2}$ 的贡献。

举个栗子：

$\verb!??B???!$

显然，如果以第 4 位为结尾，由于 $c_{3}$ 是 $\verb!B!$，那么以 4 为结尾的**基本可行序列**只能是 $\verb!BW!$，再往前走，就是 $\verb!??BW!$，显然构成不了一个基本合法序列，所以 $f_{4}=f_{2}$，因为它只能取到 $\mathit{S}_{3,4}$。

如果不是上面这两种情况，那么怎么办？

比如上述栗子中的 $f_{6}$，它能取到那些呢？

我们知道 $f_{4}$ 能取到 $f_{2}$，而 $f_{6}$ 之前没有别的 $\verb!B!$ 影响它，所以 $f_{6}$，可以往前取到 $f_{0}$！

为什么会这么神奇？

因为它的本质，就是让在 $i$ 之前，离它最近的 $\verb!B!$ 的距离**等于** 这个 $\verb!B!$ 离该基本可行序列的开头的距离，只不过我们用了简便的方法来处理它而已。 

于是我们可以定义一个指针 $back$,表示当前 $f_{i}$ 能取到的最小的位置，和一个存储变量 $now$,表示当前 $f_{i}$ 可获得的值。

当 $c_{i}$ 为 $\verb!B!$ 时，直接令 $now=0$，$back=i$，因为 $i$ 以前的 $f_{w}$ 都不能赋值给 $f_{i}$，所以最终给 $f_{i}$ 赋值的 $now$ 也是 $0$。

当 $c_{i-1}$ 为 $\verb!B!$ 时，直接令 $now=f_{i-2}$，$back=i-2$，因为只有 $f_{i-2}$ 能赋值给 $f_{i}$，所以最终给 $f_{i}$ 赋值的 $now$ 也是 $f_{i-2}$。

若这两种情况都不是，那么根据之前的观察，$back$ 可以减 $2$,$now$ 可以在 $back$ 改变后加上 $f_{back}$,显然要排除 $back<0$ 的情况。

这样完了吗？不！$\verb!W!$ 被吃了吗？

有一个位置 $j$，我们设在它后面最小的给定的 $\verb!W!$ 的位置在 $suf_{j}$，事先定义 $suf_{n}=n+1$。

举个栗子：

$\verb!?WB???WW?W!$

可以得到从 $\mathit{suf}_{0,n}$ 的序列是：

$2,2,7,7,7,7,7,8,10,10,11$

这个好理解，但它有什么用呢？

我们会发现，$f_{i}$ 最远可以贡献到的位置正是 $2 \times suf_{i}-i-2$。

比如，上述栗子中，$f_{4}$ 最远可以贡献到 $f_{8}$, $\mathit{S}_{5,8}$ 为 $\verb!BBWW!$，显然可行，再远的话就是 $\verb!??WW?W!$,就不可行了。

这又是为什么呢？

其实根处理 $\verb!B!$ 的思路是一样的，我们要 $i$ 与在它之后最近的 $\verb!W!$，即 $suf_{i}$ 的距离**等于** $suf_{i}$ 到该基本合法序列末尾的长度，只不过我们在转移过程中就能方便处理好 $\verb!B!$ 的影响，处理第二个 $\verb!W!$ 要用麻烦一点的方法一些而已。

所以，我们将 $2 \times suf_{i}-i$ 与 $i$ 连边，因为它是第一个无法获得 $f_{i}$ 贡献的位置。

由小到大处理 $f_{i}$，用 $now$ 存储给 $f_{i}$ 赋予的值，事先将所有与它连边的 $w$，让 $now$ 减去 $f_{w}$，这样处理好 $\verb!W!$ 的影响后，再用前文所述的方法处理 $\verb!B!$ 的影响，得到最后的 $now$ 数组，此时 $f_{i}$ 便可赋值为 $now$ 了，自然，处理出来的 $f_{i}$ 会对后面产生贡献，如此我们再让 $now$ 加上 $f_{i}$,便可放心去处理 $i+1$ 去啦。

总算讲完了，由于对于每个 $i$,只会有一条入边，所以跑边的时间复杂度是 $O(n)$，而 处理 $f_{i}$ 的时间复杂度也是 $O(n)$，所以总的时间复杂度可以达到优秀的 $O(n)$。

**总结一下思路，我们想分别计算出 B 与 W 的影响，一个在递推中直接处理，一个在递推中用连边的方式处理。**

附上代码（前文的 $suf$ 可以方便理解，在实际代码中已省略）：


```cpp
#include<bits/stdc++.h>
#define g getchar()
#define pc(a) putchar(a) 
using namespace std;

const int N=5e5+7,mod=1e9+9;
int nex[N],to[N],hd[N],tot;
int n,f[N],now,back;
char c[N];

void qp(int x){
	if(x<0) pc('-'),x=-x;
	if(x<=9){
		pc(x+'0');
		return;
	}qp(x/10);
	pc(x%10+'0');
}

void add(int x,int y){
	if(x<=n){
		nex[++tot]=hd[x];
		hd[x]=tot;
		to[tot]=y;
	}
}

int main(){
	while((c[++n]=g)>='?'){
	}n--;
	if(n&1){
		qp(0);
		return 0;
	}int x=n+1;
	for(int i=n-1;i>=0;i--){
		if(c[i+1]=='W') x=i+1;
		add((x<<1)-i,i);
	}f[0]=now=1;
	for(int i=2;i<=n;i+=2){
		for(int j=hd[i];j;j=nex[j]){
			int v=to[j];
			if(v>=back){
				now=now-f[v]+mod;
				if(now>mod) now-=mod;
			}f[v]=0;
		}if(c[i]=='B') now=0,back=i;
		else if(c[i-1]=='B') now=f[i-2],back=i-2;
		else{
			back-=2;
			if(back>=0) 
				 now=now+f[back];
		}if(now>mod) now-=mod;
		f[i]=now;
		now=now<<1;
		if(now>mod) now-=mod;
    }qp(f[n]);
	return 0;
}

```










---

## 作者：Felix72 (赞：1)

这题还是很不错的，唯一的遗憾之处是可以被各种复杂度的算法花式爆过去。

令**基本黑白序列**为 $n$ 个黑加上 $n$ 个白构成的序列。

我们设 $f_i$ 表示前缀 $[1, i]$ 是合法序列的方案数，每次往后面接一段新的基本黑白序列，枚举这个长度就能做到 $O(n^2)$ 了。我们试图加速这个枚举过程，但是遗憾的是可行的长度并不连续，无法直接转移。

但是天无绝人之路，可行的长度其实是 $O(\log_2n)$ 个区间。这是怎么得来的呢？我们**先忽略所有必须是白色的点**，对于 $f_i$ 往后面的转移考虑如下过程：

- 有一个指针 $p$，表示 $[i + 1, p]$ **可以**都是黑色，那么能不能转移到 $2p - i$ 就看后面能不能都是白色了；
- 看看 $[p + 1, 2p - i]$ 中有没有必黑点：
  - 如果没有：说明一定能转移到 $[2p - i, 2p - i + k]$（这个 $k$ 取决于下一个必黑点的位置），然后把 $p$ 设置为 $2p - i + k + 1$；
  - 如果有：说明这个 $p$ 无法转移，把 $p$ 设置为 $[p, 2p - i]$ 中最后一个必黑点的位置。

读者自行理解后可知，这个做法相当于一个剪枝，把连续贡献段先贡献了，再找下一个连续的可贡献段。分析 $p - i$ 的大小变化，可知无论有没有必黑点，这个长度跳两次至少翻一倍，$O(\log n)$ 次即可达到 $O(n)$ 级别，故 $p$ 的变化是 $O(\log n)$ 次。又因为对于每个 $p$ 最多产生一个连续贡献段，故贡献段数是 $O(\log n)$ 级别。考虑上必白点，贡献段数只减不增。

用刚才的算法套上简单数据结构以优化 DP，精细的预处理和差分是 $O(n \log n)$ 的，粗糙的 set 和树状数组是小常数 $O(n \log^2 n)$ 的，都能通过，自行选择实现即可。

---

## 作者：Erick。 (赞：1)

一个显而易见的动态规划方程用F[i]记录前i位可以得到的不同黑白序列的个数。转移需要考虑所有的j<i，并尝试使j+1到i是一个独立的黑白序列段。总时间复杂度是O(n^2)的，这便可以得到65分。
　　考虑上述转移中涉及到的j，可以发现需要被考察的j往往是连续的偶数，而其中的断点总会使得对最后一个黑白序列段的长度要求有了两倍以上的限制。所以转移中j的断点只有O(logn)个。用链表维护需要转移的连续若干个j，总的时间复杂度为O(nlogn)，便可以得到满分。
  ```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define rep(i,x,y) for(register int i=(x);i<=(y);++i)
#define per(i,x,y) for(register int i=(x);i>=(y);--i)
const int maxn=5e5+10,mo=1e9+9;
typedef long long LL;
using namespace std;
inline int lowbit(int x){return x&(-x);}
inline void ck(int&x){if(x<mo)x+=mo;if(x>=mo)x-=mo;}
inline void ad(int&x,int y){x+=y;ck(x);}
int n,f[maxn];
char s[maxn];
int sum,q;
struct LinkMap{
int tot,head[maxn],to[maxn],next[maxn];
void ins(int a,int b){if(a>n)return;to[++tot]=b;next[tot]=head[a];head[a]=tot;}
void work(int k){
for(int p=head[k];p;p=next[p]){if(to[p]>=q)ad(sum,-f[to[p]]);f[to[p]]=0;}
}
}lp;
int next[maxn];
int main(){
char c=getchar();
while(c=='B'||c=='W'||c=='?')s[++n]=c,c=getchar();
if(n&1){puts("0");return 0;}
next[n]=n+1;per(i,n-1,0)if(s[i+1]=='W')next[i]=i+1;else next[i]=next[i+1];
for(int i=0;i<=n;i+=2)lp.ins(next[i]+next[i]-i,i);
f[0]=1;sum=1;
for(int i=2,j=0;i<=n;i+=2){
lp.work(i-1);lp.work(i);
if(s[i]=='B')j=i,q=i,sum=0;
else if(s[i-1]=='B')j=i-1,q=i-2,sum=f[i-1]+f[i-2],ck(sum);
else ad(sum,(q-1>=0)?f[q-1]:0),ad(sum,(q-2>=0)?f[q-2]:0),q=max(0,q-2);
f[i]=sum;
ad(sum,f[i]);
}
printf("%d",f[n]);
return 0;
}
```

---

## 作者：Aysct (赞：0)

## 20240227

今日数数：[P2779 AHOI2016初中组 黑白序列](https://www.luogu.com.cn/problem/P2779)

---

显然设 $f_i$ 为仅考虑 $[1,i]$ 的计数结果。

考虑转移，设 $b_i$ 表示 $s[i,i+b_i-1]$ 没有字符 $W$ 的最大值，$w_i$ 表示 $s[i-w_i+1,i]$ 没有 $B$ 的最大值。

显然 $f_j$ 可以转移向 $f_i$ 当且仅当：
$$
\begin{cases}
b_{j+1} \geq \frac{i-j}{2} \\
w_i \geq \frac{i-j}{2}
\end{cases}
$$
对于一个二元式子，优化复杂度的简单思路是将两个元分开。

可将上式改写为：
$$
\begin{cases}
j+2b_{j+1} \geq i \\
i-2w_i \leq j
\end{cases}
$$
第一个式子相当于时间戳限制，在相应时间删除 $j$ 的影响即可。

第二个式子是前缀和。

BIT 维护即可。

```cpp
#include <bits/stdc++.h>
#define int long long
const int mod = 1e9 + 9;
using namespace std;
int n, a[500005], b[500005], w[500005];
int f[500005];
vector<int> cant[500005];
struct bit
{
    int d[500005];
    int lowbit(int x) { return x & -x; }
    void add(int pos, int v)
    {
        v = (v % mod + mod) % mod;
        pos++;
        for (; pos <= n+1; pos += lowbit(pos))
            d[pos] = (d[pos] + v) % mod;
    }
    int que(int pos)
    {
        pos++;
        int r = 0;
        for (; pos >= 1; pos -= lowbit(pos))
            r = (r + d[pos]) % mod;
        return r;
    }
} bit;
signed main()
{
    char _tp;
    while (cin >> _tp)
    {
        n++;
        if (_tp == 'B')
            a[n] = 1;
        else if (_tp == 'W')
            a[n] = -1;
    }
    for (int i = 1; i <= n; i++)
    {
        if (a[i] == 1)
        {
            w[i] = 0;
        }
        else
        {
            w[i] = w[i-1] + 1;
        }
    }
    for (int i = n; i >= 1; i--)
    {
        if (a[i] == -1)
        {
            b[i] = 0;
        }
        else
        {
            b[i] = b[i+1]+1;
        }
    }
    f[0] = 1;
    bit.add(0, f[0]);
    if (2 * b[1] <= n && 2 * b[1] != 0)
        cant[2 * b[1]].push_back(0);
    for (auto ed : cant[0])
    {
        bit.add(ed, -f[ed]);
    }
    for (int i = 2; i <= n; i += 2)
    {
        if (a[i] != 1)
        {
            f[i] = (f[i] + bit.que(n)) % mod;
            f[i] = (f[i] - bit.que(i - 2 * w[i] - 1) + mod) % mod;
            bit.add(i, f[i]);
            if (i != n && i + 2 * b[i + 1] <= n)
                cant[i + 2 * b[i + 1]].push_back(i);
        }
        for (auto ed : cant[i])
        {
            bit.add(ed, -f[ed]);
        }
    }
    cout << f[n];
    return 0;
}
```

---


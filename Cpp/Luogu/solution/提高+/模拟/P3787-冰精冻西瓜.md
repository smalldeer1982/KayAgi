# 冰精冻西瓜

## 题目背景

 ![](https://cdn.luogu.com.cn/upload/pic/5279.png) 

盛夏，冰之妖精琪露诺发现了一大片西瓜地，终于可以吃到美味的冻西瓜啦。


## 题目描述

琪露诺是拥有操纵冷气程度的能力的妖精，一天她发现了一片西瓜地。这里有 $n$ 个西瓜，由 $n-1$ 条西瓜蔓连接，形成一个有根树，琪露诺想要把它们冷冻起来慢慢吃。

这些西瓜蔓具有神奇的性质，可以将经过它的冷气的寒冷程度放大或缩小，每条西瓜蔓放大/缩小冷气寒冷程度的能力值为 $w_i$，表示冷气经过它后，寒冷程度值 $x$ 会变为 $ x\times w_i$。每个西瓜也有一个寒冷程度值，炎热的夏日，所有西瓜的寒冷程度值初始都为 $0$。

琪露诺会做出两种动作:

①.对着西瓜 $i$ 放出寒冷程度为 $x$ 的冷气。这股冷气顺着西瓜蔓向“西瓜树”的叶子节点蔓延，冷气的寒冷程度会按照上面的规则变化。遇到一个西瓜连了多条西瓜蔓时，每条叶子节点方向的西瓜蔓均会获得与原先寒冷程度相等的冷气。途径的所有西瓜的寒冷程度值都会加上冷气的寒冷程度值。

**冷气只会向释放点的子树蔓延，不会向根方向蔓延**

⑨.向你询问西瓜 $i$ 的寒冷程度值是多少。

等等，为什么会有⑨？因为笨蛋琪露诺自己也会忘记放了多少冰呢。

所以，帮她计算的任务就这么交给你啦。


## 说明/提示

子任务可能出现如下的特殊性质:

“西瓜树”退化为一条链

输入数据中的实数均保留8位小数，选手的答案被判作正确当且仅当输出与标准答案误差不超过10^-7。请特别注意浮点数精度问题。

 ![](https://cdn.luogu.com.cn/upload/pic/5278.png) 

实际数据中，冷气的寒冷程度x的范围为 [-0.1,0.1]

(样例中的冷气寒冷程度的范围为[1,5])

命题人:orangebird,鸣谢oscar。


## 样例 #1

### 输入

```
4
1 2 1.00000000
2 3 0.00000000
3 4 1.00000101
9
1 1 3.00000000
9 2
9 3
1 2 1.42856031
9 4
9 2
1 3 4.23333333
9 2
9 4```

### 输出

```
3.00000000
0.00000000
0.00000000
4.42856031
4.42856031
4.23333761```

# 题解

## 作者：_zy_ (赞：12)

## [题目传送门](https://www.luogu.com.cn/problem/P3787)

### 题目大意：

给定一棵节点为 $n$ 的树，$m$ 次操作，其中边权为 $c$ ，$c $ 为从 $ u $点到 $v$ 点所改变值得倍数。

1. 改变 $x$ 及其子树的值。

2. 求 $x$ 点的值。

题外话: 数学课的灵感突现。$QwQ$

---

### 先考虑特殊情况：

- 先考虑这条树是一条链:

那就变成了一段序列，现在不就是区间更改和单点查询嘛，这不就是一个线段树的板子嘛！

于是我们就可以把这个问题再回到树上，**按照时间戳来构造一个序列，在这个序列上进行操作。**

但是我们会发现，区间更改的值不一样。

- 再考虑只在根节点上更改:

只需要将每个点加和再乘上前缀积。

那再考虑一般情况，**我们只需要将更改的值除以该节点的前缀积，然后查询时再乘以该节点的前缀积就好。**


于是我们就解决了区间更改的值不一样的问题。

------

现在我们有了大致的雏形。

$Dfs$ 将树转化为一个序列，找到每次修改的区间 $(dfn_x$ ~ $siz_x)$ ，并求出 $x$ 的前缀积
。

然后发现...他炸了。
 
**关于砍树：**

我们发现边权为 $0$ 的点会影响下面的节点的前缀积都为 $0$，更改时会出现除以 $0$ 的情况。

如果边权为 $0 $ 的话，就不会对下面的节点产生影响，可以看成两棵树了，那么就砍掉这个边。
·
```cpp
void dfs(int x,int fa,double Mul)
{
	dfn[x]=siz[x]=++tim;				//找出修改的区间
	mul[x]=Mul;
	v[x]=1;
	for(int i=fir[x];i;i=nex[i]) {
		int p=poi[i];
		if(v[p]||p==fa)	continue;
		if(!val[i]) {
			rot[++rot[0]]=p;			//砍树
			continue;
		}
		dfs(p,x,Mul*val[i]);
		siz[x]=siz[p];
	}
}
```

剩下的就是线段树的部分了，没啥子好说的。

### 代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#define N 200010
using namespace std;
int re() {
	int p=0; char i=getchar();
	while(i<'0'||i>'9')	i=getchar();
	while(i>='0'&&i<='9')	p=p*10+i-'0',i=getchar();
	return p;
}
int n,m,sum,tim;
int fir[N],nex[N],poi[N];
int rot[N],dfn[N],siz[N];
double val[N],mul[N];
bool v[N];
struct zy {
	int l,r;
	double sum;
	double lazy;
}e[N<<1];
void ins(int x,int y,double z) {
	nex[++sum]=fir[x];
	poi[sum]=y;
	val[sum]=z;
	fir[x]=sum;
}
void dfs(int x,int fa,double Mul)
{
	dfn[x]=siz[x]=++tim;
	mul[x]=Mul; v[x]=1;
	for(int i=fir[x];i;i=nex[i]) {
		int p=poi[i];
		if(v[p]||p==fa)	continue;
		if(!val[i]) {
			rot[++rot[0]]=p;
			continue;
		}
		dfs(p,x,Mul*val[i]);
		siz[x]=siz[p];
	}
}
void Build(int p,int l,int r) {
	e[p].l=l; e[p].r=r;
	if(l==r)	return;
	int mid=(l+r)>>1;
	Build(p<<1,l,mid);
	Build(p<<1|1,mid+1,r);
}
void Pushup(int p) {
	e[p].sum=e[p<<1].sum+e[p<<1|1].sum;
}
void Pushdown(int p)
{
	double	 Lazy=e[p].lazy;
	e[p<<1].lazy+=Lazy;
	e[p<<1|1].lazy+=Lazy;
	e[p<<1].sum+=(e[p<<1].r-e[p<<1].l+1)*Lazy;
	e[p<<1|1].sum+=(e[p<<1|1].r-e[p<<1|1].l+1)*Lazy;
	e[p].lazy=0;
}
void Update(int p,int l,int r,double d) {
	if(l<=e[p].l&&r>=e[p].r) {
		e[p].sum+=(e[p].r-e[p].l+1)*d;
		e[p].lazy+=d;
		return ;
	}
	if(e[p].lazy)	Pushdown(p);
	int mid=(e[p].l+e[p].r)>>1;
	if(l<=mid)	Update(p<<1,l,r,d);
	if(r>mid)	Update(p<<1|1,l,r,d);
	Pushup(p);
}
double Query(int p,int pos)
{
	if(e[p].l==e[p].r)
		return e[p].sum;
	if(e[p].lazy)	Pushdown(p);
	int mid=(e[p].l+e[p].r)>>1;
	double ans=0;
	if(pos<=mid) ans=Query(p<<1,pos);
	else  ans=Query(p<<1|1,pos);
	return ans;
}
int main()
{
	n=re(); 
	for(int i=1;i<n;i++) {
		int a,b; double c;
		a=re(); b=re(); scanf("%lf",&c);
		ins(a,b,c); ins(b,a,c);
	}
	rot[++rot[0]]=1;
	for(int i=1;i<=rot[0];i++) 
		dfs(rot[i],0,1);
	m=re();
	Build(1,1,n);
	for(int i=1;i<=m;i++)
	{
		int op=re();
		if(op==1) {
			int x=re();
			double k; scanf("%lf",&k);
			Update(1,dfn[x],siz[x],k/mul[x]);
		}
		else {
			int x=re();
			printf("%.8lf\n\n",Query(1,dfn[x])*mul[x]);
		}
	}
	return 0;
}
```
**如有不妥，请不要吝啬您的评论！**

**~~话说，图片真的挺丑的！~~**


---

## 作者：orangebird (赞：9)

精度开double就可以过，long double更保险。

对于n,m范围在1000以内的子任务,模拟进行所有操作即可

对于具有特殊性质的子任务，可用线段树来维护这条链，做法同下面的正解。

对于wi不能取0的子任务，可以免去下面正解中割边的步骤，直接对这棵树做dfs序即可。

下面是正解:

首先从根节点开始dfs，维护dfs序，把所有wi=0的边割断，将wi=0的边所连的子树树根的编号

存起来，对所有分离出的树都求一遍dfs序。记得走完一棵树后序号不要清零，要继续向上累加。

在维护dfs序的同时，维护每个节点从其所在树的树根到其本身，wi变量的乘积ki

然后用一棵线段树/树状数组维护所有节点。

对于操作①，可以这么想，如果所有冷气都是从树根释放出来的，

那么冷冻值可以直接累加起来，最后乘以ki就能得到任意子节点的冷冻值

因此我们可以把每个操作①看做从树根释放的，那么冷冻值就是x/ki。

所以只要给冷气释放的节点和其子树都增加x/ki即可。

由于有线段树的支持，所以单次操作时间复杂度是O(logn)

对于操作⑨，只要输出线段树上对应节点的值乘以ki即可，时间复杂度也是O(logn)

所以总时间复杂度O(mlogn)，顺利AC。

感谢oscar提供"砍树"的思路。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<cmath>
#define ld long double
using namespace std;
int n,m;
const ld eps=1e-8;
vector<int>tab[100011];
vector<ld>val[100011];
ld k[100011];
ld tree[100011];
int ino[100011];
int outo[100011];
int fa[100011];
int tot=0;
queue<int>q;
void add(int x,ld t)
{
    for(x;x<=n;x+=x&-x)
        tree[x]+=t;
}
ld query(int x)
{
    ld res=0;
    for(x;x>0;x-=x&-x)
        res+=tree[x];
    return res;
}
void dfs(int now,int father,long double ki)
{
    ino[now]=++tot;
    fa[now]=father;
    k[now]=ki;
    int sz=tab[now].size();
    for(int i=0;i<sz;++i)
    {
        int nex=tab[now][i];
        if(nex==fa[now])continue;
        if(fabs(val[now][i])<eps)
        {
            fa[nex]=now;
            q.push(nex);
            continue;
        }
        dfs(nex,now,ki*val[now][i]);
    }
    outo[now]=tot;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<n;++i)
    {
        int u,v;ld w;
        scanf("%d%d%Lf",&u,&v,&w);
        tab[u].push_back(v);
        tab[v].push_back(u);
        val[u].push_back(w);
        val[v].push_back(w); 
    }
    q.push(1);
    while(!q.empty())
    {
        dfs(q.front(),fa[q.front()],1.0);
        q.pop();
    }
    scanf("%d",&m);
    while(m--)
    {
        int typ,i;
        ld x;
        scanf("%d",&typ);
        if(typ==1)
        {
            scanf("%d%Lf",&i,&x);
            ld ins=x/k[i];
            add(ino[i],ins);
            add(outo[i]+1,-ins);
        }else{
            scanf("%d",&i);
            printf("%.8Lf\n",query(ino[i])*k[i]);
        }
    }
    return 0;
}
```

---

## 作者：VanHelsing (赞：7)

[题目链接](https://www.luogu.com.cn/problem/P3787)  
### 奇怪的线段树题？  
反正我是看了一个小时的题解才想明白怎么写（  
  
第一眼看到这道题的时候的思路：区间修改？单点查询？这好办啊！线段树啊！  
  
打了十分钟之后的想法：咦？修改的值不一样？这怎么处理呢？  
苦思冥想了三十分钟之后，我决定动用人类的智慧——学习！（~~看题解~~）    

对于这道题来讲，虽然每次修改时每个点改变的值都不一样，但我们可以发现每次改变时，每个点改变的值是对于根节点改变的值乘上每个点到根节点的乘积（有点绕，我当时没看明白）（或许我现在也可能没说明白） 
  
总之呢，我们只要处理出每个节点到根节点的乘积，然后每次区间修改是同一个值，询问的时候乘上乘积就可以啦！  
那么，修改的时候我总不能去挑着修改某些点吧，这样时间就炸了呀  
所以，我们需要按照dfs序把树的节点排序，让某一个节点的子树都是一个区间，我们把每个节点的子树是多少到多少存起来，这样的话我们就可以每次修改一个区间（就是线段树的板子啦）  
（弱弱的吐槽一句，vector存图真的那么好用吗，蒟蒻不会用，只会前向星的写法）  
求dfs序的部分是  
```cpp
void dfs(int u,int fa)
{
	dfn[u]=siz[u]=++cnt;
	vis[u]=1;
	for(int i=head[u];i;i=nxt[i])
	{
		int v=to[i];
		if(v==fa||vis[v]) continue;
		if(!val[i])
		{
			rt[++rt[0]]=v;//有的边权是0，这种边就等于构成了两棵树；
            //这里就是把两棵树分开用的
			continue;
		}
		k[v]=k[u]*val[i];//k是到根节点的乘积啦
		dfs(v,u);
		siz[u]=siz[v];
	}
}
```
然后是线段树的部分  
```cpp
struct Segmentree
{
	int left,right;//左右儿子都是谁（习惯这么写了，不太习惯递归的写法）
	double sum;
	double tag;//懒标记和子树和
};Segmentree tree[maxn<<2];
void pushdown(int index)
{
	if(tree[index].tag)
	{
		tree[index<<1].tag+=tree[index].tag;
		tree[index<<1].sum+=(tree[index<<1].right-tree[index<<1].left+1)*tree[index].tag;
		tree[index<<1|1].tag+=tree[index].tag;
		tree[index<<1|1].sum+=(tree[index<<1|1].right-tree[index<<1|1].left+1)*tree[index].tag;
		tree[index].tag=0;
	}
}
void Build(int index,int l,int r)
{
	tree[index].left=l;tree[index].right=r;
	if(l==r)
	{
		return;
	}
	int mid=l+r>>1;
	Build(index<<1,l,mid);
	Build(index<<1|1,mid+1,r);
}
void Modify(int index,int l,int r,double k)//区间修改（线段树板子啦）
{
	if(l<=tree[index].left&&r>=tree[index].right)
	{
		tree[index].sum+=k;
		tree[index].tag+=k;
		return;
	}
	pushdown(index);
	int mid=(tree[index].left+tree[index].right)>>1;
	if(l<=mid)
		Modify(index<<1,l,r,k);
	if(r>mid)
		Modify(index<<1|1,l,r,k);
	tree[index].sum=tree[index<<1].sum+tree[index<<1|1].sum;
	return;
}
double Query(int index,int l)//单点查询（也是线段树板子呀）
{
	if(tree[index].left==tree[index].right)
		return tree[index].sum;
	pushdown(index);
	int mid=tree[index].left+tree[index].right>>1;
	double ans;
	if(l<=mid)
		ans=Query(index<<1,l);
	else
		ans=Query(index<<1|1,l);
	tree[index].sum=tree[index<<1].sum+tree[index<<1|1].sum;
	return ans;
}
```
最后是全部的代码  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
int n,m,sum,cnt;
int head[maxn],siz[maxn],dfn[maxn],rt[maxn];
double k[maxn];
bool v[maxn],vis[maxn];
struct Segmentree
{
	int left,right;
	double sum;
	double tag;
};Segmentree tree[maxn<<2];
void pushdown(int index)
{
	if(tree[index].tag)
	{
		tree[index<<1].tag+=tree[index].tag;
		tree[index<<1].sum+=(tree[index<<1].right-tree[index<<1].left+1)*tree[index].tag;
		tree[index<<1|1].tag+=tree[index].tag;
		tree[index<<1|1].sum+=(tree[index<<1|1].right-tree[index<<1|1].left+1)*tree[index].tag;
		tree[index].tag=0;
	}
}
void Pushup(int index)
{
	tree[index].sum=tree[index<<1].sum+tree[index<<1|1].sum;
}
void Build(int index,int l,int r)
{
	tree[index].left=l;tree[index].right=r;
	if(l==r)
	{
		return;
	}
	int mid=l+r>>1;
	Build(index<<1,l,mid);
	Build(index<<1|1,mid+1,r);
}
void Modify(int index,int l,int r,double k)
{
	if(l<=tree[index].left&&r>=tree[index].right)
	{
		tree[index].sum+=k;
		tree[index].tag+=k;
		return;
	}
	pushdown(index);
	int mid=(tree[index].left+tree[index].right)>>1;
	if(l<=mid)
		Modify(index<<1,l,r,k);
	if(r>mid)
		Modify(index<<1|1,l,r,k);
	tree[index].sum=tree[index<<1].sum+tree[index<<1|1].sum;
	return;
}
double Query(int index,int l)
{
	if(tree[index].left==tree[index].right)
		return tree[index].sum;
	pushdown(index);
	int mid=tree[index].left+tree[index].right>>1;
	double ans;
	if(l<=mid)
		ans=Query(index<<1,l);
	else
		ans=Query(index<<1|1,l);
	tree[index].sum=tree[index<<1].sum+tree[index<<1|1].sum;
	return ans;
}
struct eg{
	int nxt;
	int to;
	double w;
};eg edge[maxn<<1];
int nxt[maxn<<1],to[maxn<<1];
double val[maxn<<1];
void add_edge(int x,int y,double w)//前向星存图（不会vector啊）
{
	sum++;
	to[sum]=y;
	nxt[sum]=head[x];
	head[x]=sum;
	val[sum]=w;
}
void dfs(int u,int fa)
{
	dfn[u]=siz[u]=++cnt;
	vis[u]=1;
	for(int i=head[u];i;i=nxt[i])
	{
		int v=to[i];
		if(v==fa||vis[v]) continue;
		if(!val[i])
		{
			rt[++rt[0]]=v;
			continue;
		}
		k[v]=k[u]*val[i];
		dfs(v,u);
		siz[u]=siz[v];
	}
}
int main()
{
	scanf("%d",&n);
	Build(1,1,n);
	for(int i=1;i<n;i++)
	{
		int ui,vi;double wi;
		scanf("%d%d%lf",&ui,&vi,&wi);
		add_edge(ui,vi,wi);
		add_edge(vi,ui,wi);
	}
	rt[++rt[0]]=1;
	for(int i=1;i<=rt[0];i++)
	{
		k[rt[i]]=1;
		dfs(rt[i],rt[i]);
	}
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		int op,p;
		scanf("%d",&op);
		if(op==1)
		{
			double x;
			scanf("%d%lf",&p,&x);
			Modify(1,dfn[p],siz[p],x/k[p]);
		}
		else
		{
			scanf("%d",&p);
			printf("%.8lf\n",Query(1,dfn[p])*k[p]);
		}
	}
	return 0;
}
```
结束啦！感谢您的阅读

---

## 作者：荣一鸣 (赞：4)

题目意思很明显，虽然一开始以为直接暴力，后来发现不行

我们可以先把一棵树遍历一下,把这棵树变为一条链，因为每个点的冷气只能向叶子节点传输，所以要把该点所管辖的点作为每次更新的区间。

因为同样的冷气传导不同的西瓜是是不一样的。

我们可以假设所有的冷气都是从根传来的，这样我们就能够有一个基准值，把所有的输入的冷气转化为从跟根来的值，这样就可以区间更新了。

我们可以与处理出每一个节点从根来会变化多少k，更新时将更新的值**除以**该节点的k，作为从根节点传来的冷气，然后区间更新

查询时将该节点储存的值**乘上**该节点的k就可以了。

简单来说，就是先把每一个点相对于根节点来说等价的冷气存下来，这样就可以区间更新，询问时再乘回来，得到真实值。

下面是代码：

```
#include<bits/stdc++.h>
using namespace std;
struct edge{
	int t;
	double lt;
};
edge E[2000100];
vector<int> g[1000100];
int cnt,n,m,tail[1000100],pre[1000100],vi[1000100],num[1000100],root[1000100],cc,tt;
double tree[4000100],tag[4000100],val[1000100];

void dfs(int u,int fa,double vl){
	vi[u]=1;
	val[u]=vl;//从根来的时候变化的k
	num[++cnt]=u;//在链中的节点在书中的编号
	pre[u]=cnt;//该节点在链中的新编号
	for(int i=0;i<g[u].size();i++){
		int v=E[g[u][i]].t;
		double ll=E[g[u][i]].lt;
		if(fa==v||vi[v]) continue;
		if(ll==0){//如果该节点未被访问并且边是0则断开
			root[++cc]=v;//把新的根存下来
			continue;
		}
		dfs(v,u,vl*ll);
	}
	tail[u]=cnt;//该点所管辖的区间的结尾
}

void build(int l,int r,int k){//线段树建树
	if(l==r){
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid,k<<1);
	build(mid+1,r,k<<1|1);
	return;
}

void pd(int k){
	if(tag[k]==0.0) return;
	tag[k<<1]+=tag[k];
	tag[k<<1|1]+=tag[k];
	tree[k<<1]+=tag[k];
	tree[k<<1|1]+=tag[k];
	tag[k]=0;
}

void add(int l,int r,int a,int b,double vl,int k){//区间更新
	pd(k);
	if(l>=a&&r<=b){
		tree[k]+=vl;
		tag[k]+=vl;
		return;
	}
	int mid=(l+r)>>1;
	if(mid>=a) add(l,mid,a,b,vl,k<<1);
	if(mid<b) add(mid+1,r,a,b,vl,k<<1|1);
}

double search(int l,int r,int k,int tar){//单点查询
	pd(k);
	if(l==r&&l==tar){
		return tree[k]*val[num[tar]];//记得乘上val
	}
	int mid=(l+r)>>1;
	if(mid<tar) return search(mid+1,r,k<<1|1,tar);
	else return search(l,mid,k<<1,tar);
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		int x,y;
		double l;
		scanf("%d%d%lf",&x,&y,&l);
		if(l==0) tt++;
		E[++cnt]=(edge){y,l};//一开始存双向边，因为不知道怎么连
		g[x].push_back(cnt);
		E[++cnt]=(edge){x,l};
		g[y].push_back(cnt);
	}
	cnt=0;
	dfs(1,1,1);
	for(int i=1;i<=cc;i++){
		dfs(root[i],root[i],1);
	}
	build(1,cnt,1);
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
		int k,x;
		double y;
		scanf("%d",&k);
		if(k==9){
			scanf("%d",&x);
			printf("%.8f\n",search(1,cnt,1,pre[x]));
		}
		else{
			scanf("%d%lf",&x,&y);
			y/=val[x];//化为相对值
			add(1,cnt,pre[x],tail[x],y,1);
		}
	}
}
```

---

## 作者：琴仙仙ღ (赞：2)

#### 看到全是~~(看不懂的)~~邪教vector存边求dfs序

#### 那么就来发布一篇链式前向星求dfs序的题解吧！ヽ(￣▽￣)ﾉ~~貌似能比vector快一丢丢~~

**主要算法：dfs序+差分树状数组**

**大体思路：**

1. 砍掉权值为0的边，将权值为0的边指向的点换做新根

2. 利用k数组求出相对于根的寒气值乘积，让他们单位相同以便批量操作

3. 用dfs序找出某个点的时间戳&结束戳在树状数组的相应位置

4. 实施加法操作时只需要在差分树状数组的对应时间戳加上(实际值/k[操作节点])，结束戳+1的位置上减去(实际值/k[操作节点])即可


------------
代码：
```cpp
#include<cstdio>
#include<queue>
std::queue<int>q;							   //q队列用于储存树根
#define N 500002
int n,m,en,head[N],Index,dfn[N],nfd[N],cnt;long double k[N],tree[N],eps=1e-8;									  //各种定义
bool vis[N];									//求dfs序用的vis标记
struct edge
{
	int to,next;
	long double w;
}ed[N];
inline void addedge(int u,int v,long double w)
{
	ed[++en].to=v;
	ed[en].next=head[u];
	ed[en].w=w;
	head[u]=en;
}												//前向星
void dfs(int x,long double totw)
{
	dfn[x]=++Index;							  //tarjan版时间戳
	vis[x]=true;								 //该节点被访问过
	k[x]=totw;						           //记录相对根访问过来的乘积
	for(int i=head[x];i;i=ed[i].next)			//求dfs序
	{
		int to=ed[i].to;
		if(vis[to]==true)continue;
		if(ed[i].w<eps)						  //如果比限制精度还小（8位）则保留小数点后七位（即把它看做零）
		{
			q.push(to);						  //
			continue;
		}
		dfs(to,totw*ed[i].w);
	}
	nfd[x]=Index;								//末尾戳
}
int lowbit(int x)								//树状数组部分
{
	return x&(-x);
}
inline void add(int pos,long double val)
{
	while(pos<=n)
	{
		tree[pos]+=val;
		pos+=lowbit(pos);
	}
}
long double query(int pos)
{
	long double ans=0;
	while(pos)
	{
		ans+=tree[pos];
		pos-=lowbit(pos);
	}
	return ans;
}
int main()
{
	int u,v;long double w;
	scanf("%d",&n);
	for(int i=1;i<=n-1;i++)
	{
		scanf("%d%d%Lf",&u,&v,&w);
		addedge(u,v,w);
		addedge(v,u,w);
	}
	q.push(1);								   //第一个树根为1，其他的在dfs中寻找		
	while(!q.empty())							//遍历所有树根
	{
		dfs(q.front(),1);						//可能找到新根
		q.pop();
	}
	scanf("%d",&m);
	while(m--)
	{
		scanf("%d",&u);
		if(u==1)
		{
			scanf("%d%Lf",&v,&w);
			long double var=w/k[v];
			add(dfn[v],var);
			add(nfd[v]+1,-var);
		}
		else
		{
			scanf("%d",&v);
			printf("%.8Lf\n",query(dfn[v])*k[v]); //输出用相对值乘真实比例
		}
	}
}
```


------------
~~琪露诺大法好！~~


---

## 作者：NXYorz (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P3787)

看到这种题先往数据结构方面想，但是很快就可以发现这和普通的数据结构不一样的是，每一次修改时每一个节点修改的值不一样，这就没有办法进行下去了。
但是可以先考虑一种简单的情况：所有的操作都是在**根节点**上进行，而且**边权不为零**。在这种情况下，我们只需要每一次操作的和求出来，询问时直接乘上该节点到根节点的**前缀积**即可。

这就给我们提供了思路：**预处理处理前缀积**。

接着继续考虑，当节点操作不一定是**根节点**时但是**边权恒不为零时**前缀积处理出来有什么用。由于在根节点上的操作很容易实现，所以我们的思路就向根节点靠拢，因为已经处理出来前缀积了，所以每一次对非根节点的操作，只需要把将要增加的值除以该节点到根节点的前缀积，就是**等效**的了，但是影响到的节点只在该节点的子树内，所以可以处理出来每一个节点的**时间戳**，这样每一棵子树都是**连续的一段区间**，**区间加**操作。每次查询就查询这个点的值然后乘该点的前缀积即可。

最后，考虑**边权为零**时，发现如果边权为零，那么这两个点就不再互相往来了，砍了就好，于是就会得到若干棵树，因此只需要在上述算法基础上处理一下就好了。

要注意的是，题目中说了以$1$为根，并且冷气会顺根而下，所以我们砍树时的根节点也就是确定的了，而不是随便找一个点作为根节点。~~论偷懒的危害~~

### $Code$
```cpp
#include<cstdio>

#define double long double

using namespace std;

const int N = 1e5 + 10;

int n,m,sum,cnt;
int first[N],top[N],size[N],father[N],dfn[N],root[N];
double k[N];
bool v[N],path[N];

struct NO
{
	int l;
	int r;
	double w;
	double lazy;
};

struct SigmentT
{
	NO t[N * 4];
	
	void Pushdown(int p)
	{
		t[p << 1].lazy += t[p].lazy;
		t[p << 1].w += (t[p << 1].r - t[p << 1].l + 1) * t[p].lazy;
		t[p << 1 | 1].lazy += t[p].lazy;
		t[p << 1 | 1].w += (t[p << 1 | 1].r - t[p << 1 | 1].l + 1) * t[p].lazy;
		t[p].lazy = 0;
	}
	
	void Pushup(int p)
	{t[p].w = t[p << 1].w + t[p << 1 | 1].w;}
	
	void Build(int p , int l , int r)
	{
		t[p].l = l; t[p].r = r;
		if(l == r) return;
		int mid = l + r >> 1;
		Build(p << 1 , l , mid);
		Build(p << 1 | 1, mid + 1 , r);
	}
	
	void Updata(int p , int l , int r , double w)
	{
		if(l <= t[p].l && r >= t[p].r)
		{t[p].w += w; t[p].lazy += w; return;}
		if(t[p].lazy) Pushdown(p);
		int mid = t[p].l + t[p].r >> 1;
		if(l <= mid) Updata(p << 1 , l , r , w);
		if(r > mid) Updata(p << 1 | 1 , l , r , w);
		Pushup(p); return;
	}
	
	double Check(int p , int loc)
	{
		if(t[p].l == t[p].r) return t[p].w;
		if(t[p].lazy) Pushdown(p);
		int mid = t[p].l + t[p].r >> 1;
		double ans;
		if(loc <= mid) ans = Check(p << 1 , loc);
		else ans = Check(p << 1 | 1 , loc);
		Pushup(p); return ans;
	}
}tr;

struct E
{
	int next;
	int to;
	double w;
	void add(int x , int y , double w_)
	{
		next = first[x];
		to = y;
		w = w_;
		first[x] = sum;
	}
}e[N * 2];

int dfs(int x , int fa)
{
	father[x] = fa; dfn[x] = size[x] = ++cnt; top[x] = top[fa]; path[x] = 1;
	for(int i = first[x]; i ; i = e[i].next)
	{
		int to = e[i].to;
		if(to == fa || path[to]) continue;
		if(!e[i].w) {root[++root[0]] = to;continue;}
		k[to] = k[x] * e[i].w; dfs(to , x); size[x] = size[to];
	}
}

int main()
{
//	freopen("aa.in","r",stdin);
	scanf("%d",&n); tr.Build(1 , 1 , n);
	for(int i = 1; i < n; i++)
	{
		int ui,vi; double wi;
		scanf("%d%d%Lf",&ui,&vi,&wi);
		//if(!wi) continue;
		e[++sum].add(ui , vi , wi);
		e[++sum].add(vi , ui , wi);
	}
	root[++root[0]] = 1;
	for(int i = 1; i <= root[0]; i++)
		k[root[i]] = 1 , top[root[i]] = root[i] , dfs(root[i] , root[i]) ;
	scanf("%d",&m);
	for(int i = 1; i <= m; i++)
	{
		int op,loc; scanf("%d",&op);
		switch(op)
		{
			case 1:
				double x;
				scanf("%d%Lf",&loc,&x);
				tr.Updata(1 , dfn[loc] , size[loc] , x / k[loc]);
				break;
			case 9:
				scanf("%d",&loc);
				printf("%.8Lf\n",tr.Check(1 , dfn[loc]) * k[loc]);
				break;
			break;
		}
	}
	return 0;
}
```

---

## 作者：囧仙 (赞：1)

## 题解

观察数据点发现，数据点当中存在 $w_i$ 为 $0$ 与 $w_i\in[1-10^{-5},1+10^{-5}]$ 两种情况。显然第一种情况只要拆成若干棵树就可以做了，但为什么出题人会给一个仅有 $w_i\in[1-10^{-5},1+10^{-5}]$ 的特殊部分分呢？显然这个部分分是给一个只能在边权都不为 $0$ 的做法用的。

直接从正面下手，把 $x$ 子树内的节点全部加上对应的值貌似不大现实。但是我们可以考虑一下两个节点分别到对应树根的乘积。假设根节点到点 $i$ 路径上的边权之积为 $T_i$，那么在点 $i$ 执行操作 $1$ 释放了大小为 $x$ 的寒气后，点 $i$ 子树内节点 $j$ 受到的寒气就是 $x\div T_i\times T_j$（可以理解为一种差分的过程）。容易发现，对于任意的 $i$，这个式子的后半部分的 $T_j$ 都是不变的，而前半部分 $T_i$ 只与 $i$ 有关（废话）。那么在执行操作 $1$ 时给点 $x$ 的**点权**加上 $y\div T_x$；执行操作 $9$ 时考虑一个节点所有的父亲对它的贡献之和 $S$，然后 $S$ 乘上 $T_x$ 就能得到结果了。

然后就能回到一开始的问题了。假如 $1$ 到 $x$ 的路径上存在一个边权为 $0$ 的边，那么 $T_x$ 就未定义。因此我们必须得把整棵树根据 $0$ 权边切割为树林，但要记得处理**每棵树的根节点是什么**。根节点不一定都是树内的最小标号的节点（比如有边 $1\xrightarrow{w_i=0} 3\xrightarrow{w_i=1} 2$，那么切割成的两棵树的根应当分别为 $1,3$）。

但是这样做比较麻烦，因为你需要统计一个节点所有父亲的点权之和。直接使用树剖不光会增大码量，还会使复杂度变为 $\mathcal O(n\log^2n)$，不大好看。因此考虑在执行操作 $1$ 时就给它的所有儿子的权值加上 $y\div T_x$。使用 $\text{dfs}$ 序，由于一个子树所有节点的 $\text{dfs}$ 必然是连续的一段，所以我们只要给这一段区间加上 $y\div T_x$ 即可。可以使用树状数组维护，时间复杂度为 $\mathcal O(n\log n)$。

虽然浮点数误差 $\mathrm{eps}$ 会因为连续的乘法被放大为 $(1+\mathrm{eps})^{100000}-1$，但是 $\text{double}$ 的精度已经足够了。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long   i64;
typedef long double f80;
const int INF =2147483647;
const int MAXN=1e5+3;
int H[MAXN],V[MAXN*2],N[MAXN*2],t; f80 W[MAXN*2];
f80 S[MAXN]; int n,m,c,A[MAXN],B[MAXN],d,R[MAXN];
void add(int u,int v,f80 w){
    V[++t]=v,W[t]=w,N[t]=H[u],H[u]=t;
}
void dfs(int u,int f){
    for(int i=H[u],v;i;i=N[i]) if((v=V[i])!=f){
        if(fabs(W[i])<1e-9) R[++d]=v; dfs(v,u);
    }
}
void dfs(int u,int f,f80 s){
    S[u]=s,A[u]=++c;
    for(int i=H[u],v;i;i=N[i]) if((v=V[i])!=f){
        if(fabs(W[i])>1e-9) dfs(v,u,s*W[i]);
    }
    B[u]=c;
}
f80 D[MAXN];
void inc(int x,f80 w){while(x<=n) D[x]+=w,x+=x&-x;}
f80  gtw(int x){
    f80 r=0; while(x) r+=D[x],x-=x&-x; return r;
}
int main(){ 
    scanf("%d",&n); up(1,n-1,i){
        int u,v; f80 w; scanf("%d%d%Lf",&u,&v,&w);
        add(u,v,w),add(v,u,w);
    }
    R[++d]=1,dfs(1,0); up(1,d,i) dfs(R[i],0,1.0);
    scanf("%d",&m); up(1,m,i){
        int o; scanf("%d",&o);
        if(o==1){
            int x; f80 y; scanf("%d%Lf",&x,&y);
            inc(A[x],y/S[x]),inc(B[x]+1,-y/S[x]);
        } else {
            int x; scanf("%d",&x);
            printf("%.20Lf\n",gtw(A[x])*S[x]);
        }
    }
    return 0;
}
```

---

## 作者：PragmaGCC (赞：1)

题目大意就是子树修改，单点求值。其中修改的值会根据边权变化。

考虑到这是一棵有根树，边权都是静态的，我们可以类似树上差分，求出每个节点到根的前缀积。这样就可以算出点之间的倍数差距。在修改/查询的时候除掉/乘上这个差距即可。

但是数据范围给了提示：**边权可能为 $0$**。这意味着，在这之后的前缀积将全部变成 $0$。这显然是不对的，因为下面的边还是会有贡献。

但是，由于这条边的边权是 $0$，两部分之间将不会有任何关系，可以直接将这条边断开，分成两棵树，将下一个点作为新树的根节点。

这样我们就让修改的值固定下来了。

之后问题就转化成：

- 有一棵森林
- 对森林进行子树加，单点查询。

对原森林求出 dfs 序，子树编号在序列中是连续的，变成序列的**区间修改，单点查询**。

可以用树状数组/线段树来维护。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 4e5 + 5;
int n, m;
struct Edge {
    int to, nxt;
    double weight;
} e[N];
int head[N], ecnt;
void addedge(int from, int to, double w) {
    e[++ecnt] = (Edge) { to, head[from], w };
    head[from] = ecnt;
}
double sum[N];
int rt[N], rcnt;
int dfnL[N], dfnR[N], dfncnt;
bool vis[N];
void dfs(int x, int fa) {
    dfnL[x] = ++dfncnt;
    vis[x] = 1;
    for (int i = head[x]; i; i = e[i].nxt) {
        const int y = e[i].to;
        if (y == fa ||vis[y]) continue;
        if (e[i].weight == 0) {
            rt[++rcnt] = y;
            continue;
        }
        sum[y] = sum[x] * e[i].weight;
        dfs(y, x);
    }
    dfnR[x] = dfncnt;
}
double t[N];
int lowbit(int x) { return x & -x; }
void upd(int p, double v) { for (; p < n * 2; p += lowbit(p)) t[p] += v; }
double qry(int p) { double res = 0; for (; p; p -= lowbit(p)) res += t[p]; return res; }
int main(void) {
    scanf("%d", &n);
    for (int i = 1; i < n; i++) {
        int u, v; double w;
        scanf("%d%d%lf", &u, &v, &w);
        addedge(u, v, w), addedge(v, u, w);
    }
    rt[++rcnt] = 1;
    for (int i = 1; i <= rcnt; i++) {
        sum[rt[i]] = 1;
        dfs(rt[i], 0);
    }
    scanf("%d", &m);
    for (int op, p; m; m--) {
        scanf("%d%d", &op, &p);
        if (op == 1) {
            double x;
            scanf("%lf", &x);
            upd(dfnL[p], x / sum[p]), upd(dfnR[p]+1, -x / sum[p]);
        } else {
            printf("%.8f\n", qry(dfnL[p]) * sum[p]);
        }
    }
    return 0;
}
```



---

## 作者：When (赞：1)

~~这题面不禁让我联想到了树剖~~

#### 思路

显然，这道题并不需要树剖~~毕竟它只是蓝题~~，不过，它也需要用到$DFS$序，把树上操作转化成序列操作（这个思想可以说很套路了），但这题有一个麻烦的地方：在修改子树时每一条边都会对修改值造成影响，而这用线段树是难以维护的。

于是我们考虑将边上的影响分离出来，可以先预处理出一个从当前节点到根的前缀积，在每次子树加时将加数除以当前节点的前缀积，查询时再乘上查询节点的前缀积，我们发现，通过这样的操作，就将修改节点到根节点的前缀积乘回来了。~~是不是很妙~~

#### But

还有一个细节：数据范围中特意强调了$w_i$可能为$0$，而我们知道，当$w_i$为0时，修改其他节点（指除i及其子树以外的节点）就对i节点及其子树没有影响了。为了方便地处理，我们可以巧妙地将这些$w_i$为$0$的点也设为根，将原树拆分成几棵树遍历，这样就可以解决$0$的问题且子树编号仍然连续了。同时，我们每一个点仍然只会遍历一次（为根节点两次），所以遍历仍然是$O(n)$级别的。



#### 代码

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>

using namespace std;

const int maxn = 2e5 + 10;  //两倍空间开了吗
int n,head[maxn],num,m;
int rm[maxn],rt[maxn],top;
double tim[maxn];
struct Edge{
    int then,to;
    double val;
}e[maxn];

void add(int u, int v, double val){e[++num] = (Edge){head[u], v, val}; head[u] = num;}

int dfn[maxn],id[maxn],cnt,siz[maxn];
void DFS(int u, int f){  
    dfn[++cnt] = u, id[u] = cnt; siz[u] = 1;
    for(int i = head[u]; i; i = e[i].then){
        int v = e[i].to;
        if(v != f && !rm[v] && !id[v]){
            if(fabs(e[i].val - 0.0) <= 0.00000001) rm[v] = 1, rt[++top] = v, tim[v] = 1;  //注意double判0的时候尽量别用==
            else tim[v] = tim[u] * e[i].val, DFS(v, u), siz[u] += siz[v];
        }
    }
}

struct Seg_Tree{
    #define lc(x) x << 1
    #define rc(x) x << 1 | 1
    double c[maxn << 2],tag[maxn << 2];
    
    void f(int l, int r, int p, double x){
        c[p] += (r - l + 1) * x;
        tag[p] += x;
    }
    
    void downdate(int l, int r, int p){
        if(fabs(tag[p] - 0.0) >= 0.00000001){
            int mid = (l + r) >> 1;
            f(l, mid, lc(p), tag[p]);
            f(mid + 1, r, rc(p), tag[p]);
            tag[p] = 0;
        }
    }
    
    void add(int L, int R, int l, int r, int p, double val){
        if(L <= l && R >= r){
            f(l, r, p, val);
            return;
        }
        downdate(l, r, p);
        int mid = (l + r) >> 1;
        if(L <= mid) add(L, R, l, mid, lc(p), val);
        if(mid < R) add(L, R, mid + 1, r, rc(p), val);
        c[p] = c[lc(p)] + c[rc(p)];
    }
    
    double query(int pos, int l, int r, int p){
        if(l == r) return c[p];
        downdate(l, r, p);
        int mid = (l + r) >> 1; 
        if(mid >= pos) return query(pos, l, mid, lc(p));
        else return query(pos, mid + 1, r, rc(p));
    }
}tree;

void push(int u, double val){
    val /= tim[u];
    tree.add(id[u], id[u] + siz[u] - 1, 1, cnt, 1, val);
}

double get_ans(int u){
    double ans = tree.query(id[u], 1, cnt, 1);
    return ans * tim[u];
}

int main(){
    scanf("%d", &n);
    for(int i = 1; i < n; ++ i){
        int u,v; double val;
        scanf("%d%d%lf", &u, &v, &val);
        add(u, v, val), add(v, u, val);
    } tim[1] = 1, DFS(1, 0);
    for(int i = 1; i <= top; ++ i) DFS(rt[i], 0);
    scanf("%d", &m);
    while(m--){
        int opt,Id; double x;
        scanf("%d%d", &opt, &Id);
        if(opt == 1){
            scanf("%lf", &x);
            push(Id, x);
        }
        else printf("%.8lf\n", get_ans(Id));
    }
    return 0;
}
```



---

## 作者：SIXIANG32 (赞：0)

挺好一题，就头图就……  
闲话少说，切入正题——  

---
题目很啰嗦，但是还是比较清晰的~~主要是 SX 语文不好概括不了~~。  
由于是子树的操作，所以我们可以考虑记录这棵树的 DFS 序然后将树映射到一个序列上，$[dfn_u, siz_u]$ 就是每个子树的区间（$dfn$ 是时间戳）。  
然后我们就可以考虑线段树快乐的维护了，一个区间修改，一个单点查询，$\log_2 n$ 单操作，多好啊。  
可是由于区间修改的值不同，所以不能简单的区间修改。  
所以我们每次操作都要除以该节点的前缀积，查询时乘上就好了。  

---
但是在 DFS 算前缀积的时候我们会发现有个东西，如果有个边权为 $0$，那么单纯的把 $mul_v = mul_u \times val$ 会导致错误。  
但是考虑到如果有个边权是 $0$，那么实际上是不会对下面的前缀积造成影响，因此我们可以把这棵树给切开，切成若干棵小树，对于每个小树进行计算。  

---
代码：  
```cpp
#include <cstdio>
#include <vector>
#define MAXN 100000
using namespace std;
double f[MAXN * 9 + 10], lazy[MAXN * 9 + 10], a[MAXN + 10];
int ls(int now) {return now << 1;}
int rs(int now) {return now << 1 | 1;}
void push_up(int now) {
	f[now] = f[ls(now)] + f[rs(now)];
}
void push_down(int now, int l, int r) {
	int mid = (l + r) >> 1;
	f[ls(now)] += (mid - l + 1) * lazy[now];
	f[rs(now)] += (r - mid) * lazy[now];
	lazy[ls(now)] += lazy[now];
	lazy[rs(now)] += lazy[now];
	lazy[now] = 0;
}
void updata(int l, int r, int s, int t, int now, double val) {
	if(s >= l && t <= r) {
		lazy[now] += val;
		f[now] += (t - s + 1) * val;
		return ;
	}
	int mid = (s + t) >> 1;
	push_down(now, s, t);
	if(l <= mid) updata(l, r, s, mid, ls(now), val);
	if(r > mid) updata(l, r, mid + 1, t, rs(now), val);
	push_up(now);
}
double ask(int pos, int s, int t, int now) {
	if(s == t)
		return f[now];
	push_down(now, s, t);
	int mid = (s + t) >> 1;
	if(pos <= mid) return ask(pos, s, mid, ls(now));
	else return ask(pos, mid + 1, t, rs(now));
}
//Segments Tree
int rt[MAXN + 10], dfn[MAXN + 10], siz[MAXN + 10], C = 0, rts = 0;
struct node {
	int to;
	double val;
	node(int T, double V) {
		to = T, val = V;
	}
};
bool vis[MAXN + 10];
vector <node> gra[MAXN + 10];
double mul[MAXN + 10];
void dfs(int u, int fa) {//遍历
	dfn[u] = siz[u] = ++C, vis[u] = 1;
	for(int p = 0; p < gra[u].size(); p++) {
		int v = gra[u][p].to;
		if(v == fa || vis[v]) continue;
		if(!gra[u][p].val) {//新的树
			rt[++rts] = v;
			continue;
		}
		mul[v] = mul[u] * gra[u][p].val;
		dfs(v, u);
		siz[u] = siz[v];
	}
}
signed main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	int n, m;
	scanf("%d", &n);
	double in;
	for(int p = 1, x, y; p < n; p++) {
		scanf("%d%d%lf", &x, &y, &in);
		gra[x].push_back(node(y, in));
		gra[y].push_back(node(x, in));
	}
	rt[++rts] = 1;
	for(int p = 1; p <= rts; p++) {//得到时间戳
		mul[rt[p]] = 1;
		dfs(rt[p], rt[p]);
	}
	scanf("%d", &m);
	for(int p = 1; p <= m; p++) {
		int opt, u;
		scanf("%d", &opt);
		if(opt == 1) {
			scanf("%d%lf", &u, &in);
			updata(dfn[u], siz[u], 1, n, 1, in / mul[u]);
		}
		else {
			scanf("%d", &u);
			printf("%.8lf\n", ask(dfn[u], 1, n, 1) * mul[u]);
		}
	}
}
  
```

---

## 作者：monstersqwq (赞：0)

#### 题意：

给定一棵以 $1$ 为根的树，给定边权，点权初始为 $0$，有两个操作：

- 给某个点的点权加上 $x$，并向儿子递归地传递，期间乘上自己和儿子之间的边权，再由儿子继续向下传

- 查询某个点的点权

#### 思路：

先考虑边权中没有 $0$ 的情况（即改变一整棵子树）：

首先因为这是在一棵树上的子树修改，那么需要先把这棵树的 dfs 序求出，然后扔到一个序列上。

然后你会发现每个节点修改的值是不相同的，所以考虑通过预处理这个节点到根的边权前缀积来处理这个麻烦的事情。

考虑把所有的修改都假定在根上进行，只不过只修改需要修改的那个点的子树，那我们只需要知道每个修改对应的根修改的值，然后每个点都加上对应的数，查询时乘上相应点到树根的前缀积即可。

设点 $i$ 到根的边权前缀积为 $w_i$，那么由于我们要求出一个值，使得在根修改这个值到 $i$ 的时候变成了 $k$，那么这个值就是 $\dfrac{k}{w_i}$。

但是这个算法肯定在 $w_i=0$ 的时候会挂掉，即有边的权值为 $0$，这种情况需要单独考虑。

我们发现，如果在权值为 $0$ 的边上的节点修改是不会对权值为 $0$ 的边下的节点有影响，但是下面的节点修改则会正常地影响，于是发现这个 $0$ 权值边没有意义，可以删除它，让整棵树变成两棵，再按照上面的操作进行处理。

那么最后我们就需要维护很多棵树，为了更好的处理，可以在搜完一棵树后直接接着算 dfs 序，这样就可以在一个序列上处理了。

还有就是需要记录每个点的子树的 dfs 序最小值和最大值方便进行子树修改。

代码：

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <string>
#include <cstring>
#include <queue>
#include <map>
using namespace std;
typedef long long ll;
int n,nxt[200005],hed[200005],to[200005],cnt;
double ww[200005],sum[200005];//sum记录前缀积
int dfscnt=0,id[200005],idd[200005],f[200005];//id是dfs序，idd是以i为根的子树的dfs序最大值
int m,rt[200005];//rt记录所有根
bool vis[200005];
void adde(int u,int v,double w)
{
	cnt++;
	to[cnt]=v;
	nxt[cnt]=hed[u];
	hed[u]=cnt;
	ww[cnt]=w;
}
void dfs1(int u,int from)
{
	f[u]=from;
	for(int i=hed[u];i!=0;i=nxt[i])
	{
		int v=to[i];
		if(v!=from) dfs1(v,u);
	}
}//预处理出每个点的父亲
void dfs(int u,int root,int from)
{
	if(vis[u]) return;
	if(u==root)
	{
		sum[u]=1;
	}
	dfscnt++;
	id[u]=dfscnt;
    vis[u]=true;
	for(int i=hed[u];i!=0;i=nxt[i])
	{
		int v=to[i];
		if(v!=from&&!(ww[i]-0<=0.000000001))//为了避免精度误差
		{
            sum[v]=sum[u]*ww[i];
			dfs(v,root,u);
		}
		else if(v!=from)
		{
			rt[++rt[0]]=v;//找到了新的根
		}
	}
	idd[u]=dfscnt;
}
double c[100005];
int lowbit(int x)
{
	return x&-x;
}
void upd(int x,double k)
{
	while(x<=n)
	{
		c[x]+=k;
		x+=lowbit(x);
	}
}
double query(int x)
{
	double res=0;
	while(x>=1)
	{
		res+=c[x];
		x-=lowbit(x);
	}
	return res;
}
int main()
{
	cin>>n;
	for(int i=1;i<n;i++)
	{
		int u,v;
		double w;
		cin>>u>>v>>w;
		adde(u,v,w);
		adde(v,u,w);
	}
	dfs1(1,0);
	rt[1]=rt[0]=1;
    for(int i=1;i<=rt[0];i++)
    {
    	dfs(rt[i],rt[i],rt[f[i]]);
	}
    cin>>m;
	for(int i=1;i<=m;i++)
	{
		int opt;
		cin>>opt;
		if(opt==1)
		{
			int x;
			double k;
			cin>>x>>k;
			upd(id[x],k/sum[x]);
			upd(idd[x]+1,-(k/sum[x]));//子树修改
		}
		else
		{
			int x;
			cin>>x;
			printf("%.8lf\n",sum[x]*query(id[x]));
		}
	}
	return 0;
}
```


---


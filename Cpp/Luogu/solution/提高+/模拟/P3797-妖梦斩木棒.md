# 妖梦斩木棒

## 题目背景

 ![](https://cdn.luogu.com.cn/upload/pic/5848.png) 

妖梦是住在白玉楼的半人半灵，拥有使用剑术程度的能力。


## 题目描述

有一天，妖梦正在练习剑术。地面上摆放了一支非常长的木棒，妖梦把它们切成了等长的n段。现在这个木棒可以看做由三种小段构成，中间的n-2段都是左右都被切断的断头，我们记做’X’，最左边的一段和最右边的一段各有一个圆头，记做’（‘和’）’。幽幽子吃饱后闲来无事，决定戏弄一下妖梦。她拿来了许多这样的三种小段木棒，来替换掉妖梦切下来的n段中的一部分，然后问妖梦一些问题。这些操作可以这样描述:

1 x C 将第x个小段的木棒替换成C型，C只会是’X’,’(‘,’)’中的一种

2 l r 询问妖梦从第l段到第r段之间(含l,r)，有多少个完整的木棒

完整的木棒左右两端必须分别为’(‘和’)’，并且中间要么什么都没有，要么只能有’X’。

虽然妖梦能够数清楚这些问题，但幽幽子觉得她回答得太慢了，你能教给妖梦一个更快的办法吗？


## 说明/提示

对于30%的数据，2<=n,m<=1000。

对于100%的数据，2<=n,m<=200000。

by-orangebird


## 样例 #1

### 输入

```
4 4
2 1 4
2 2 4
1 2 (
2 2 4```

### 输出

```
1
0
1```

# 题解

## 作者：灵乌路空 (赞：16)

先无良宣传一下博客 $wwwwww$    
[文章列表 - 地靈殿 - 洛谷博客](https://www.luogu.org/blog/koishikoishi/)

---

## 知识点: 线段树,模拟  

### [原题面](https://www.luogu.org/problem/P3797)  

出题的神仙ob 在 $gxs$ 发布当天 打通了 ⑧个机体的 $L$  
~~ob太强啦~~  

---

### 题目要求:   
给定 一 长度为 $n$ 的字串 , 由 "$($" , "$X$" , "$)$" 三种字符构成 ,   初始状态 为  $(XX...XX)$   
需要支持下列两种操作:    
1.  修改 :   将第 $i$ 个元素替换为 三种元素中 给定的的一种.   
2.  查询 :  查询区间 $[l,r]$ 中 , 形如 $(X..X)$ 或 $()$ 字符串的个数   
	( 目标字串 首尾为 $(\ )$  , 且 $(\ )$ 中间 只能存在 $X$ )   

---   

### 分析题意:   

一开始走了许多弯路 = = ,    
得到了许多 看起来很有用 实际上 卵用没有的结论   
经过整理后 ,  用的只有下列结论 :   

1. 对于一个只由 字符$($ 与  字符$)$ 构成的字串 ,   
	向其中 任意位置 插入 任意数量 的 $X$ ,     
	对任意区间内 目标字串的数量都没有影响   

	根据此结论 , 可以将 原字串 进行 转化 ,   
	忽略所有 的 $X$ ,  以便于之后的的 分析及调试	   

2.  假设现 有两相邻字串 $A$ 与 $B$    
	$A$ , $B$ 中 目标字串 的数量 分别为 $sum_a$ 与 $sum_b$ ,    
	 求 两序列 合并后 目标字串的数量  $sum_{a+b}$    
	
    - 显然 , 合并后 $sum_{a+b}$ 至少为   $sum_a + sum_b$     
	  可不可能出现新的目标字串 , 使合并后 目标字串数量有所增加  ?    
	  答案是肯定的.     

	    如下列情况 (忽略了所有的 $X$) :   
	
    	| $...($ | $)...$ | $...()..$ |
		| -----------: | -----------: | -----------: |
		| $A$ | $B$ | $A+B$ |
        
      此时有: $sum_{a+b} = sum_a+sum_b+1$   

    - 合并时 如何维护 此类 横跨两个区间的 目标字串 $??$   
	  可以维护每一个区间的 最左侧的非 $X$ 字符与 最右侧的非 $X$ 字符.   
	  
	  在合并时 , 若 左区间最右侧为 "$($" 且 右区间最左侧为 "$)$"   
	  则证明 出现上述情况  , 区间目标字串数 $+1$   

3. 由结论 $2$ 扩展而来 :   
	如何维护 区间的 最左,最右侧的 非 $X$ 字符 ?   
	
	- 区间内只有一个元素时: 两 非$X$字符 即 该元素   
	- 当区间 有多个元素时, 可以将区间 看做 两不相交的 子区间合并而来 :   
		1. 当两子区间均不全为 $X$时  ,     
			区间最左侧 非 $X$ 字符 = **左**子区间 最**左**侧非 $X$ 字符,     
			区间最右侧 非 $X$ 字符 = **右**子区间 最**右**侧非 $X$ 字符,     
			
		2. 当右子区间 全为 $X$时:   
			区间最左侧 非 $X$ 字符 = **左**子区间 最**左**侧非 $X$ 字符,     
			区间最右侧 非 $X$ 字符 = **左**子区间 最**右**侧非 $X$ 字符,     
		3. 当左子区间 全为 $X$时:  同 $2$    

	- 由上 , 只需要再维护 区间是否为空 ,        
	  该信息即可由 递归回传 来进行维护 .      

4. 题目要求的 区间查询:    

	本体 即 简单的区间求和     
	但是 存在 结论 $2$ 中描述的: 横跨 两子区间的 目标字串     
	则需要对 线段树的区间求和操作 进行微小的改造:     
	
	设查询区间为 $[L,R]$ , 可以发现:     
	
	满足下列 $3$ 个条件时 , 存在 横跨 两子区间的 目标字串 , 查询的区间和需 $+1$  
	- 当 $[L,R]$ 横跨 某区间 的 左右子区间    
	- 左子区间 最右侧  非 $X$ 字符为  "$($"  , 位置为 $pos1$    
	  右子区间 最左侧  非 $X$ 字符为   "$)$" , 位置为 $pos2$    
	- $L\le pos1$ 且 $pos2 \le R$   
	
	为实现上述操作 , 还需要维护 最左 , 最右侧的 非 $X$ 字符 的位置       
	
---

### 算法实现:

根据 上述结论 , 现在需要一种数据结构 ,    
支持 维护区间信息 , 递归回传 , 单点修改   

- 建立 一棵 维护下列 区间信息的线段树:
	- 最左侧第一个 非 $X$ 字符 是否为 "$)$"  
	  最右侧第一个 非 $X$ 字符 是否为 "$($"  
    - 最左侧第一个 "$)$" 的位置 , 最右侧第一个 "$($" 的位置  
    - 是否全部为 $X$  
    - 目标字串数量
    
- 单点修改 操作 :  
   先深入至 目标 叶节点 , 更新叶节点的信息  
   之后 根据 结论 $2,3$ , 递归更新区间信息   
   
- 区间查询 操作 : 根据结论 $4$ , 求区间和即可
   

---


~~奇丑的~~ 代码:    

```cpp
//知识点: 线段树,模拟 
/*
By:Luckyblock
ob给给舔一舔
用0代表( , 用1代表) ,用2代表'X' 
*/
#include<cstdio>
#include<cstdlib>
#include<ctype.h>
#define ls (now<<1)
#define rs ((now<<1)+1)
const int MARX = 2e5+10;
//=============================================================
struct node
{
	int L,R;//维护的区间,
	bool allX,side[3];//是否全为X , side[0]:最左侧是否有) , side[1]:最右侧是否有( ,
	int sum,pos[3]; //区间内完整木棒数, 及区间内 最左侧),最右侧( 位置 
}tree[MARX<<4];
int n,m, map[110],map1[3];//map存映射关系, 0<->( , 1<->) , 2<->X 
char now_list[MARX];//当前的 字串 
//=============================================================
inline int read()
{
    int s=1, w=0; char ch=getchar();
    for(; !isdigit(ch);ch=getchar()) if(ch=='-') s =-1;
    for(; isdigit(ch);ch=getchar()) w = w*10+ch-'0';
    return s*w;
}
void Build(int now,int l,int r)//常规建树
{
	tree[now].L=l,tree[now].R=r;
	if(l == r) return ;
	int mid = (l+r)>>1;
	Build(ls,l,mid);
	Build(rs,mid+1,r);
}
void pushup(int now)//更新 第now个节点 的各信息 
{
	//维护 区间最左侧 是否有) 
	if(tree[ls].side[0]) tree[now].side[0]=1, tree[now].pos[0] = tree[ls].pos[0]; 
	else if(!tree[ls].allX && tree[rs].side[0]) tree[now].side[0]=1 , tree[now].pos[0]= tree[rs].pos[0];
	else tree[now].side[0] = 0;
	//维护 区间最右侧 是否有( 
	if(tree[rs].side[1]) tree[now].side[1]=1 , tree[now].pos[1] = tree[rs].pos[1];
	else if(!tree[rs].allX && tree[ls].side[1]) tree[now].side[1]=1 , tree[now].pos[1]= tree[ls].pos[1];
	else tree[now].side[1] = 0;
	//更新区间 合法字串数, 区间是否全为'X' 
	tree[now].sum = tree[ls].sum+tree[rs].sum + (tree[ls].side[1] && tree[rs].side[0]);;
	tree[now].allX = (tree[ls].allX || tree[rs].allX);
}
void Change(int now,int pos,int value) //单点修改, 将第pos个位置修改为 value 
{
	if(tree[now].L==pos && tree[now].R==pos)//当前区间 即指定位置 
	{
	  now_list[pos] = map1[value];//更新各信息 
	  tree[now].allX = (value!=2);//是否全为X 
	  tree[now].side[0] = tree[now].side[1] = 0;//更新 最左,最右侧元素 
	  tree[now].side[value] = 1, tree[now].pos[value]=pos;
	  return ;
	}
	int mid = (tree[now].L+tree[now].R)>>1;
	if(pos <= mid) Change(ls,pos,value);
	if(pos > mid) Change(rs,pos,value);
	pushup(now);//更新当前位置 
}
int Inquiry(int now,int L,int R)//查询区间 L,R 的目标字串数 
{
	if(L <= tree[now].L && tree[now].R <= R) return tree[now].sum;
	int sum=0,flag=0;//flag 判断区间 是否同时被左右子区间更新过   
	int mid = (tree[now].L+tree[now].R)>>1;
	if(L<=mid) sum += Inquiry(ls,L,R), flag++;
	if(R>mid) sum += Inquiry(rs,L,R), flag++;
	//存在 合法字串 横跨左右子区间  
	if(flag == 2) sum += (tree[ls].side[1] && L<=tree[ls].pos[1] && tree[rs].side[0] && R>=tree[rs].pos[0]);
	return sum; 
}
void prepare()//预处理 
{
	n=read() , m=read();
	Build(1,1,n);
	Change(1,1,1) , Change(1,n,0);
	
	now_list[1]='(' , now_list[n]=')';//原始字串 
	for(int i=2; i<n; i++) now_list[i]='X';
	
	map['(']=1, map[')']=0, map['X']=2;//建立映射关系 
	map1[1]='(',map1[0]=')',map1[2]='X';
}
//=============================================================
signed main()
{
	prepare();
	for(int i=1; i<=m; i++)
	{
	  int type=read(),value1,value2;
	  char value3;
	  if(type == 1) //修改操作 
	  {
	  	value1=read(); value3 = getchar();//读入防卡 
	  	getchar();
	  	if(now_list[value1] == value3) continue;
	  	Change(1,value1,map[(int)(value3)]);
	  }
	  else //查询操作 
	  {
	  	value1=read(), value2=read();
		printf("%d\n",Inquiry(1,value1,value2));
	  }
	}
}
```


完成了这篇题解 , 车万众信仰 $++$   
~~什么时候我也能 成为ob一样的 神仙飞机人~~ 

---


---

## 作者：离散小波变换° (赞：12)

东方Project相关试题（Easy-Normal）[1 / 30]

本题是一个单点修改，区间求答案类型的题目，这种题一般都是用线段树来解决

所以主要需要考虑线段树上维护哪些信息，以及如何pushup

区间木棒段数 $val$ 是要求的东西，肯定要维护

而合并两个区间时，中间可能可以产生一段新的木棒

条件就是左边的区间有一个可用的左括号，并且它的右边都是 X，右边的区间有一个可用的右括号，它的左边都是 X

所以，考虑记录这个区间左边是否有可用括号 $pre$ ，右边是否有可用括号 $suf$

但是这样还是不能直接维护，因为可能会出现这种情况：

~~~
[(,X,X,X] 与 [X,X,X,X] 合并
~~~

一般来说，一个区间右边是否有可用括号，只由它的右子区间决定

但是在这个情况中，它的左子区间有可用括号，而且右子区间都是 X，使得这个区间右边仍然有可用括号

所以还要维护这个区间是否都为 X，$pure = 1$ 表示是，$pure = 0$ 表示不是

代码：

```cpp
#include <cstdio>
#define ls (rt << 1)
#define rs (rt << 1 | 1)
int n,m;

struct node{
	int val,pre,suf,pure;//val表示这个区间中间有多少个木棒,pure表示这个区间是否都是X 
}tree[200005 << 2];//pre表示这个区间左边是否是XXXXX),suf表示这个区间右边是否是(XXXX 

node Merge(node x,node y){
	node ans;
	ans.pre = x.pre;
	if(x.pure) ans.pre |= y.pre;
	ans.suf = y.suf;
	if(y.pure) ans.suf |= x.suf;
	ans.pure = x.pure & y.pure;
	if(x.suf && y.pre){
		ans.val = x.val + y.val + 1;
	}else{
		ans.val = x.val + y.val;
	}
	return ans;
}

void build(int rt,int l,int r){
	if(l == r){
		if(l == 1) tree[rt].suf = 1;
		else if(r == n) tree[rt].pre = 1;
		else tree[rt].pure = 1;
		return;
	}
	int mid = l + r >> 1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	tree[rt] = Merge(tree[ls],tree[rs]);
}

void upload(int rt,int l,int r,int id,char C){
	if(l == r){
		tree[rt] = {0,0,0,0};
		if(C == '(') tree[rt].suf = 1;
		else if(C == ')') tree[rt].pre = 1;
		else tree[rt].pure = 1;
		return;
	}
	int mid = l + r >> 1;
	if(id <= mid){
		upload(ls,l,mid,id,C);
	}else{
		upload(rs,mid+1,r,id,C);
    }
	tree[rt] = Merge(tree[ls],tree[rs]);
}

node query(int rt,int l,int r,int L,int R){
	if(l == L && r == R){
		return tree[rt];
	}
	int mid = l + r >> 1;
	if(R <= mid){
		return query(ls,l,mid,L,R);
	}else if(L > mid){
		return query(rs,mid+1,r,L,R);
	}else{
		return Merge(query(ls,l,mid,L,mid),query(rs,mid+1,r,mid+1,R));
	}
}

int main(){
	scanf("%d%d",&n,&m);
	build(1,1,n); 
	int op;
	for(int i = 1;i <= m;i++){
		scanf("%d",&op);
		if(op == 1){
			int x;
			char c;
			scanf("%d %c",&x,&c);
			upload(1,1,n,x,c);
		}else{
			int l,r;
			scanf("%d%d",&l,&r);
		    node ans = query(1,1,n,l,r);
		    printf("%d\n",ans.val);
		}
	}
	return 0;
}
```


---

## 作者：Flandre_495 (赞：9)

### 前面所有人都写了线段树题解，我来写个分块的。



### 跟线段树比起来，这题用分块会慢一点，但代码很好理解，在细节的处理上比线段树容易的多。所以建议学会这种解题思路，分块可以解决很多线段树很难解决的事。


------------

#### 把 n 个点分成 sqrt(n) 块，维护每块的完整木棒数量，是否有左右圆头。

#### 用分块思想可以很直接很简单地修改或查询。

#### 具体讲解在代码中。


```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#define QWQ cout<<"QwQ"<<endl;
#include<vector>
#include<queue>
#include<stack>
#include<map>
using namespace std;
const int qwq=303030;
const int N=101010;
const int inf=0x3f3f3f3f;
//冗长的日常码前操作；
int n,m;
struct K {
	int l,r;         //左右边界；
	bool zuo,you;    //是否有左右圆头木棒；
	int sum;         //块中整个的木棒数；
} k[N];
char a[qwq];         //记录每一块的状态；
char cz[3];          //用字符串读入，就避免读入空行或括号了；
int t;


inline K search(int x,int y) { //访问块中信息；
	K res = (K) { x,y,0,0,0 };
	char now = 0;   //now记录木棍状态；
	for(int i=x; i<=y; i++) 
	{
		if( a[i]=='(' )
		now = '(';
		if( a[i]==')' ) 
		{
			if(now== 0 ) res.zuo = 1; //判断向左圆头；
			if(now=='(') res.sum++; //完整块；
			now = ')';
		}
	}
	if(now=='(')
	res.you = 1;   //判断向右圆头； 
	return res;    //返回块中信息；
}

inline void change(int x,char z) {
	a[x] = z;
	for(int i=1; i<=t; i++)
	if(x>=k[i].l && x<=k[i].r) //找到x所属块；
	{ 
		k[i] = search( k[i].l,k[i].r ); //修改块中信息；
		return ;
	}
}

inline int query(int x,int y) {
	int ans = 0;
	bool yuan = 0;     //是否有向右的圆头；
	for(int i=1; i<=t; i++) 
	{
		if(k[i].l<=x && y<=k[i].r)  //整个在块中；
		{
			K res = search( x,y );
			return res.sum;
		} 
		else if(x>=k[i].l && x<=k[i].r) //左端在块中；
		{ 
			K res = search( x,k[i].r );
			ans += res.sum;
			yuan = res.you;
		} 
		else if(x<k[i].l && k[i].r<y) //块在询问区间中；
		{ 
			ans += k[i].sum;
			if( k[i].zuo && yuan ) ans++; //左右对上；
			if( (!k[i].sum) && (!k[i].you) && (!k[i].zuo) ) continue;
			//注意这里有一个陷阱：块中全为X（空块）。
			//如果你想记录是否有向右圆头,不能用这个空块来修改；
			//可以证明：一个块当它既无完整木棒又无向左向右圆头时为空块。 
			yuan = k[i].you;
		} 
		else if(y>=k[i].l && y<=k[i].r) //右端在块中；
		{ 
			K res = search( k[i].l,y);
			ans += res.sum;
			if( res.zuo && yuan) ans++;
			return ans;
		}
	}
	return ans;
}

int main() {
	int x,y;
	scanf("%d%d",&n,&m);
	//开始建造分块；
	t = sqrt(n);
	for(int i=1; i<=t; i++) {
		k[i].l = k[i-1].r + 1;
		k[i].r = i * t;
	}
	if(k[t].r != n) {
		t++;
		k[t].l = k[t-1].r + 1;
		k[t].r = n;
	}
	a[1] = '(';	k[1].you = 1;
	a[n] = ')';	k[t].zuo = 1;
	//左右一改，建造完成； 
	while( m-- ) {
		scanf("%d",&x);
		if(x==1) {
			scanf("%d%s",&x,cz);
			change( x,cz[0] );
		} else {
			scanf("%d%d",&x,&y);
			printf("%d\n", query(x,y) );
		}
	}
	return 0;
}

```

#### 代码看来会有点长，也可能是我写的有点稀，压压行就显得短了；


#### ~~其实也挺好写的对吧~~，只要注意到一些细节。

---

## 作者：斗神_君莫笑 (赞：6)

首先看到2e5的数据规模,毫无疑问我们需要一个nlogn级别的算法~~走开!分块邪教！~~     
这时候当然要请出万能的线段树了！  

我们发现每根木棒只由左括号和右括号组成   
而显而易见，每次合并只会产生一根木棒（木棒不能包含）   
推导可知，**最左边的右括号** 和 **最右边的左括号** 最可能合并成一根木棒   
(如果产生木棒，一定和这两个括号有关)  
（如果这两个括号都不能产生木棒，则一定不产生新的木棒）  

所以我们可以维护三个值：  
sum（本区间木棍数量）  
lsum（最靠左的右括号 ）  
rsum（最靠右的左括号）   

详细合并过程见代码注释    

```cpp
#include<bits/stdc++.h>
#define lc (p<<1)
#define rc (p<<1|1)
using namespace std;
struct node{
	int l,r,sum,lsum,rsum;//rsum:最靠右的左括号      lsum:最靠左的右括号 
}T[800010];
int n,m;
void pushup(int p){ 
    if(T[lc].lsum)T[p].lsum=T[lc].lsum;//如果有最靠左的右括号,自然应该保留 
    else if(!T[lc].sum&&!T[lc].rsum)T[p].lsum=T[rc].lsum;//左区间全是X,保证右区间的右括号能进行匹配(不会被其他括号挡住) 
	else T[p].lsum=0;
    if(T[rc].rsum)T[p].rsum=T[rc].rsum;//同上 
    else if(!T[rc].sum&&!T[rc].lsum)T[p].rsum=T[lc].rsum;//右区间全是X
    else T[p].rsum=0;
    T[p].sum=T[lc].sum+T[rc].sum+(T[lc].rsum&&T[rc].lsum);//如果左区间有可匹配的左括号并且右区间同理，那么就可以合并成新的木棒，表达式返回值1 
}
void build(int p,int l,int r){
	T[p].l=l;T[p].r=r;
	if(p==1)T[p].sum=1;//初始木棍 
	else{
		if(l==1)T[p].rsum=1;//初始化左右括号 
		if(r==n)T[p].lsum=n;
	}
	if(l==r)return;
	int mid=(l+r)>>1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	//为什么建树的时候不pushup?因为我们已经通过特判赋予了信息 
	//pushup(p);
}
void update(int p,int q,int v){
	if(T[p].l==T[p].r&&T[p].l==q){//修改lsum与rsum的位置 
		if(v==1)T[p].lsum=0,T[p].rsum=q;
		if(v==2)T[p].lsum=0,T[p].rsum=0;
		if(v==3)T[p].lsum=q,T[p].rsum=0;
		return;
	}
	int mid=(T[p].l+T[p].r)>>1;
	if(q<=mid)update(lc,q,v);
	if(q>mid)update(rc,q,v);
    pushup(p);
}
int query(int p,int ql,int qr){
	if(ql<=T[p].l&&T[p].r<=qr)
		return T[p].sum;
    int mid=(T[p].l+T[p].r)>>1,ans=0;
    if(ql<=mid)ans+=query(lc,ql,qr);
    if(qr>mid)ans+=query(rc,ql,qr);
    ans+=(ql<=T[lc].rsum&&T[lc].rsum<=qr)&&(ql<=T[rc].lsum&&T[rc].lsum<=qr);
    //表达式意义:如果左区间的右括号在区间内&&右区间的左括号在区间内,合并新木棍,ans+1 
    return ans;
}
int main(){
	scanf("%d%d",&n,&m);
	build(1,1,n);
	while(m--){
		int t;
		scanf("%d",&t);
		if(t==1){
			int q;char ch;
			scanf("%d%c",&q,&ch);
			while(ch!='('&&ch!=')'&&ch!='X')ch=getchar();//防止诡异错误 
			if(ch=='(')update(1,q,1);
			if(ch=='X')update(1,q,2);
			if(ch==')')update(1,q,3);
		}
        if(t==2){
        	int p,q;
        	scanf("%d%d",&p,&q);
        	printf("%d\n",query(1,p,q));
		}
	}
	return 0;
}
```


---

## 作者：king_more (赞：5)

我用的是一个通俗易懂，容易理解的方法。

一个区间，记录它能合成的木棒数，最左边的括号是什么括号，最右边的括号是什么括号。

容易推出。

一个区间的合成木棒数等于左边的木棒数 + 右边的木棒数

如果它的左区间的最右边括号是左括号并且右区间的最左括号是右括号，就可以合成一根新的木棒。

一个新的区间的右边的括号是右边区间的有括号或者是左边区间的右括号（因为可能右边区间全是X）左边括号同理

talk is cheap,show you the code

```cpp
#include <cstdio>
#define lson rt << 1
#define rson rt << 1 | 1
using namespace std;
const int M = 200000;
struct tree{
	int flag;
	int flag_1;
	int date;
}st[M << 2];
int n,m;
void pushup(int rt){
	st[rt].date = st[lson].date + st[rson].date;
	if(st[lson].flag_1 == 1 && st[rson].flag == 2){
		st[rt].date ++;
	}
	if(st[rson].flag_1 != 0){
		st[rt].flag_1 = st[rson].flag_1;
	}
	else{
		if(st[lson].flag_1 != 0)
			st[rt].flag_1 = st[lson].flag_1;
		else{
			st[rt].flag_1 = 0;
		}
	}
	if(st[lson].flag != 0){
		st[rt].flag = st[lson].flag;
	}
	else{
		if(st[rson].flag != 0)
			st[rt].flag = st[rson].flag;
		else
			st[rt].flag = 0;
	}
}
void build(int rt,int l,int r){
	if(l == r){
		if(l == 1){
			st[rt].flag = 1;
			st[rt].flag_1 = 1;
		}
		if(l == n){
			st[rt].flag = 2;
			st[rt].flag_1 = 2;
		}
		return;
	}
	int mid = (l + r) >> 1;
	build(lson,l,mid);
	build(rson,mid + 1,r);
	pushup(rt);
}
tree ask(int l,int r,int l_1,int r_1,int rt){
	if(l_1 <= l && r <= r_1){
		return st[rt];
	}
	int mid = (l + r) >> 1;
	if(r_1 <= mid) return ask(l,mid,l_1,r_1,lson);
	if(l_1 > mid) return ask(mid + 1,r,l_1,r_1,rson);
	tree L = ask(l,mid,l_1,r_1,lson),R = ask(mid + 1,r,l_1,r_1,rson),res;
	res.date = L.date + R.date;
	if(L.flag_1 == 1 && R.flag == 2){
		res.date ++;
	}
	if(R.flag_1 != 0){
		res.flag_1 = R.flag_1;
	}
	else{
		if(L.flag_1 != 0)
			res.flag_1 = L.flag_1;
		else{
			res.flag_1 = 0;
		}
	}
	if(L.flag != 0){
		res.flag = L.flag;
	}
	else{
		if(R.flag != 0)
			res.flag = R.flag;
		else
			res.flag = 0;
	}
	return res;
}
void update(int p,int l,int r,int x,int rt){
	if(l == r && l == p){
		if(x == 1){
			st[rt].flag = st[rt].flag_1 = 1;
		}
		if(x == 2){
			st[rt].flag = st[rt].flag_1 = 2;
		}
		if(x == 0){
			st[rt].flag = st[rt].flag_1 = 0;
		}
		return;
	}
	int mid = (l + r) >> 1;
	if(p <= mid) update(p,l,mid,x,lson);
	if(p > mid) update(p,mid + 1,r,x,rson);
	pushup(rt);
}
int main(){
	scanf("%d%d",&n,&m);
	build(1,1,n);
	/*for(int i = 1;i <= n << 1;i ++){
		printf("%d %d |",st[i].flag,st[i].flag_1);
	}*/
	for(int i = 1;i <= m;i ++){
		int x;
		scanf("%d",&x);
		if(x == 2){
			int l,r;
			scanf("%d%d",&l,&r);
			printf("%d\n",ask(1,n,l,r,1).date);
		}
		else{
			int l;
			char c;
			scanf("%d",&l);
			c = getchar();
			c = getchar();
			if(c == '('){
				update(l,1,n,1,1);
			}
			else{
				if(c == ')'){
					update(l,1,n,2,1);
				}
				else{
					update(l,1,n,0,1);
				}
			}
		/*	for(int i = 1;i <= n << 1;i ++){
				printf("%d %d |",st[i].flag,st[i].flag_1);
			}*/
		}
	}
	return 0;
}
```


---

## 作者：Youngsc (赞：4)

先骗些博客访问量[Youngsc](https://youngscc.github.io/)


这道题是明显的单点操作区间查询，显然可以用线段树去搞些事情。

**我的建树和别人有些不一样，对于一段区间$[L,R]$,我们去记录三个变量，当前区间的完整木棒个数，当前区间能作为一段木棒的左半部分的最左端点的下标，当前区间能作为一根木棒的右半部分的最右端点的下标。那么每次更新一段区间时，当前区间的完整的木棒个数就是左右子区间完整的木棒个数之和，如果左子区间存在能作为左半部分的点且右子区间存在能作为右半部分的点，那么完整木棒数还需要++。更新更新左端点时可以分为两种情况，首先看左子区间是否存在可以作为左端点的位置，如果有直接赋过去就可以，否则就是第二种情况，如果左子区间全部都是'x'而且右子区间存在可以作为左端点的点,那么同样可以用这个位置来更新当前区间的位置，右端点位置同理,第二种情况很显然是成立的，至于怎么判断左子区间都是'x',可以在线段树中增加一个信息去记录，也可以参考我在代码中的方法。。**


### 代码在这里

#### （减少代码复制，共创美好洛谷）


```cpp
# include <bits/stdc++.h>
# define R register
# define LS o<<1
# define RS LS|1

using namespace std;

int n,m,x,y,t[1000010],pos;
int isl[1000010],isr[1000010];
char s[5];

template <typename T> inline void in(R T& a){
    R char c=getchar();R T x=0,f=1;
    while(!isdigit(c)){if(c=='-') f=-1; c=getchar();}
    while(isdigit(c)) x=(x<<1)+(x<<3)+c-'0',c=getchar();
    a=x*f;
}

template <typename T> inline void maxx(R T& a,R T b){a<b? a=b:0;}

inline void update(R int o){
    t[o] = t[LS]+t[RS];
    if(isl[LS]&&isr[RS]) t[o]++;
    if(isl[RS]) isl[o] = isl[RS];
    else if(!t[RS]&&!isr[RS]&&!isl[RS]&&isl[LS]) isl[o] = isl[LS];//!t[RS]&&!isr[RS]&&!isl[RS]如果成立，那么当前区间一定都是X，自己模拟几下就出来了。
    else isl[o] = 0;
    if(isr[LS]) isr[o] = isr[LS];
    else if(!t[LS]&&!isl[LS]&&!isr[LS]&&isr[RS]) isr[o] = isr[RS];
    else isr[o] = 0;
}

inline void build(R int o,R int l,R int r){
    if(l==r){
        if(l==1) isl[o]=1; //建树并且记录下标
        if(l==n) isr[o]=n;
        return;
    }
    R int mid = l+r>>1;
    build(LS,l,mid);
    build(RS,mid+1,r);
    update(o);
}

inline void change(R int o,R int l,R int r,R int x,R int y){
    if(l==r){
        if(y==0) isl[o]=isr[o]=0;
        if(y==1) isl[o]=l,isr[o]=0;
        if(y==2) isr[o]=l,isl[o]=0;
        return;
    }
    R int mid = l+r>>1;
    if(x<=mid) change(LS,l,mid,x,y);
    else change(RS,mid+1,r,x,y);
    update(o);
}

inline int qury(R int o,R int l,R int r,R int x,R int y){
    // printf("%d %d %d %d\n",l,r,isl[o],isr[o]);
    if(x<=l&&y>=r) return t[o];
    R int mid = l+r>>1;
    R int ret = 0;
    if(x<=mid) ret += qury(LS,l,mid,x,y);
    if(y>mid) ret += qury(RS,mid+1,r,x,y);
    if(isl[LS]>=x&&isr[RS]<=y&&isr[RS]) ret++;//判断左右区间能否组成完整木棍且在询问区间内
    return ret;
}

int main(){
    // freopen("data.in","r",stdin);
    // freopen("segment.out","w",stdout);
    in(n),in(m);
    build(1,1,n);
    while(m--)
    {
        in(pos);
        if(pos == 1){
            in(x),scanf("%s",s);
            if(s[0]=='(') change(1,1,n,x,1);
            if(s[0]==')') change(1,1,n,x,2);
            if(s[0]=='X') change(1,1,n,x,0);
        }
        else in(x),in(y),printf("%d\n",qury(1,1,n,x,y));
    }
    return 0;
}
```

---

## 作者：Seg_Tree (赞：3)


蒟蒻第一次写题解，轻喷。

首先感谢来自king_more的题解中关于query函数中一些小细节的小灵感。

然而不同的是，我用的是一种十分通俗易懂，非常容易理解的方法，并且在程序中加入了许多超级助于理解的注释。


**~~显然，这是一道线段树~~**

**我们的区间长这样：**
```cpp
struct tree{
	int sum;
	int lx,rx;
	//lx=1: )...  lx=0:  ....  lx=-1: (...
	//rx=1: ...(  rx=0:  ....  rx=-1: ...)
}tr[MaxN<<2];
```
**对于每一个节点上的区间，我们都用sum来储存该区间中的完整木棒数，用lx储存该区间中最靠左的有效木棒种类（rx同理）**

**那么~~问题来了~~，什么是有效木棒呢？通过分析我们可以发现，当我们在计算木棒数量时，‘X’型木棒其实时可以忽略的，只有‘（’与‘）’型木棒才能对我们的结果造成影响。所以我们将‘（’与‘）’型木棒成为有效木棒，具体如何储存详见代码注释。**

**因此，我们在回溯后update时可以有以下的方程：**

```
 tr[k].sum=tr[ls].sum+tr[rs].sum+(tr[ls].rx==1 && tr[rs].lx==1)
```


以上核心思想

query函数中思想基本相同，但还有一些非常重要的神奇小细节需要注意

还是让我们用~~神奇又伟大的C++~~代码来解释它吧

海量注释任君消化
```cpp
#include <iostream>
#define MaxN 200001
#define fangbian int m=l+r>>1,ls=k<<1,rs=k<<1|1
using namespace std;
struct tree{
	int sum;
	int lx,rx;
	//lx=1: )...  lx=0:  ....  lx=-1: (...
	//rx=1: ...(  rx=0:  ....  rx=-1: ...)
}tr[MaxN<<2];
int pos,x,y,n;
bool lc,rc;
char op;
void build(int k,int l,int r){
	fangbian;
	if(l==1){tr[k].lx=-1;tr[k].rx=1;}
	else if(r==n){tr[k].lx=1;tr[k].rx=-1;}
	if(l==r)return;
	build(ls,l,m);
	build(rs,m+1,r);
}
void cg(int k,int l,int r){
	if(l==r){//单点修改，不解释 
		if(op=='('){tr[k].lx=-1;tr[k].rx=1;}
		else if(op==')'){tr[k].lx=1;tr[k].rx=-1;}
		else{tr[k].lx=0;tr[k].rx=0;}
		return;
	}
	fangbian;
	//往下找 
	if(pos<=m)
		cg(ls,l,m);
	else if(m<pos)
		cg(rs,m+1,r);
	//更新该区间的sum,若两区间之间能合并出一个完整木棒则sum++ 
	tr[k].sum=tr[ls].sum+tr[rs].sum+(tr[ls].rx==1 && tr[rs].lx==1);
	//若左子区间非空,则用左子区间的左端木棒更新该区间的左端,否则用右子区间的左端.
	//更新该区间的右端同理.
	//若两区间都是空的也没关系,反正更新完了也都是空的. 
	tr[k].lx=tr[ls].lx?tr[ls].lx:tr[rs].lx;
	tr[k].rx=tr[rs].rx?tr[rs].rx:tr[ls].rx;
}
tree query(int k,int l,int r){//区间查找 
	if(x<=l && r<=y)return tr[k];//找到区间，返回该区间 
	fangbian;
	//不分叉的情况 
	if(m<x)return query(rs,m+1,r);
	else if(y<=m)return query(ls,l,m);
	
	//分叉的情况 
	tree L=query(ls,l,m);//该分叉中的左半区间 
	tree R=query(rs,m+1,r);//该分叉中的右半区间 
	tree finl;//L+R，即完整的区间，保证该区间绝对被[x,y](即要查找的答案区间)包含 
	//接下来即为合并L,R为finl的操作
	finl.sum=L.sum+R.sum+(L.rx==1 && R.lx==1);//合并sum
   //更新lx与rx
	finl.lx=L.lx?L.lx:R.lx;
	finl.rx=R.rx?R.rx:L.rx;
	return finl;
}
int main(){
	int m;
	cin>>n>>m;
	build(1,1,n);
	tr[1].lx=-1;
	tr[1].rx=-1;
	tr[1].sum=1;
	while(m--){
		int mode;
		cin>>mode;
		if(mode==1){
			cin>>pos>>op;
			cg(1,1,n);
		}
		else{
			cin>>x>>y;
			cout<<query(1,1,n).sum<<endl;
		}
	}
}
```


---

## 作者：orangebird (赞：3)

线段树维护一段区间向左有没有开口，向右有没有开口，以及是否贯通(全是X),包含几段完整木棒

如XXX)XXX，就只有向左开口，没有向右开口

然后单点修改，区间查询即可。

具体合并的方法见代码:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define lson (rt<<1)
#define rson (rt<<1|1)
#define mid (l+r>>1) 
using namespace std;
int n,m; 
struct node
{
    bool l,r,p;
    int num;
    node(){}
    node(int l_,int r_,int p_){
        l=l_,r=r_,p=p_;num=0; 
    }
}tree[800011];
node merge(const node& a,const node& b)
{
    node res;
    res.p=a.p&b.p;
    res.l=a.p?b.l:a.l;
    res.r=b.p?a.r:b.r;
    res.num=a.num+b.num;
    if(a.r&&b.l&&!a.p&&!b.p)res.num++;
    return res;
}
void pushup(int rt)
{
    tree[rt]=merge(tree[lson],tree[rson]); 
}
void modify(int rt,int l,int r,int x,int type)
{
    if(l==r)
    {
        if(type==0)tree[rt]=node(1,0,0);
        else if(type==1)tree[rt]=node(0,1,0);
        else tree[rt]=node(1,1,1);
        return;
    }
    if(x<=mid)modify(lson,l,mid,x,type);
    else modify(rson,mid+1,r,x,type);
    pushup(rt);
}
node query(int rt,int l,int r,int L,int R)
{
    if(L<=l&&r<=R)return tree[rt];
    if(mid+1>R)return query(lson,l,mid,L,R);
    if(L>mid)return query(rson,mid+1,r,L,R);
    return merge(query(lson,l,mid,L,R),query(rson,mid+1,r,L,R));
}
void build(int rt,int l,int r)
{
    if(l==r)
    {
        if(l==1)tree[rt]=node(0,1,0);
        else if(l==n)tree[rt]=node(1,0,0);
        else tree[rt]=node(1,1,1);
        tree[rt].num=0;
        return;
    }
    build(lson,l,mid);
    build(rson,mid+1,r);
    pushup(rt); 
}
int main()
{
    scanf("%d%d",&n,&m);
    build(1,1,n);
    while(m--)
    {
        int type;
        scanf("%d",&type);
        if(type==1)
        {
            int x;char c;int t;
            scanf("%d %c",&x,&c);
            if(c=='X')t=2;
            else if(c==')')t=0;
            else t=1;
            modify(1,1,n,x,t); 
        }else
        {
            int l,r;
            scanf("%d%d",&l,&r);
            printf("%d\n",query(1,1,n,l,r).num);
        }
    } 
    return 0;
}
```

---

## 作者：夏色祭 (赞：3)

###调了一个晚上（摔

###感谢楼上的楼上大佬的题解，拿着您的代码拍了一晚上（逃


**华丽丽的分割线--------------------------------------------------**


线段树维护三个值，区间木棍数(sum)，区间最靠右的“（”的位置(rsum)，区间最靠左的“）”的位置(lsum)。


然后就是单点修改和区间查询~~建树太简单了我就不讲了哈~~


修改：

分三种情况，

如果修改为“（”则，a[k].lsum=0,a[k].rsum=1

如果修改为“X”则，a[k].lsum=0,a[k].rsum=0

如果修改为“)”则，a[k].lsum=1,a[k].rsum=0

然后就是不是修改的点的值。

a[k].sum就是左儿子和右儿子的区间木棍数之和再加上左儿子的最靠右的“（”和右儿子的最靠左的“）”能否组成一个新的木棍。

a[k].lsum即如果它的左儿子的lsum不等于0，那肯定是它左儿子的lsum最靠左，不然就是它左儿子那个区间全是“X”，然后就是它右儿子的lsum，当然a[k].lsum也可能为0.

a[k].rsum和a[k].lsum差不多。。


询问:

即访问左儿子的木棍数+访问右儿子的木棍数+左儿子的最靠右的“（”和右儿子的最靠左的“）”能否组成一个新的木棍


代码：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
#define For(i,x,y) for (int i=x;i<=y;i++)
struct tree{
    int l,r,sum,lsum,rsum;    
}a[2000010];
int n,m,k,x,y;
char c;
void build(int k,int l,int r)
{
    if (k==1) a[k].sum=1,a[k].l=l,a[k].r=r;//刚开始有一根木棍
        else {
            a[k].sum=0,a[k].l=l,a[k].r=r;
            if (l==1) a[k].rsum=1;
            if (r==n) a[k].lsum=n;//懒得解释了。。。其实挺好理解的吧
        }
    if (l==r) return;
    int mid=l+r >> 1;
    build(k << 1,l,mid);//左子树
    build(k << 1^1,mid+1,r);//右子树
```
}//建树
```cpp
void ud(int k,int l,int x)
{
    if (a[k].l==a[k].r&&a[k].l==l) {
        if (x==1) a[k].rsum=l,a[k].lsum=0;
        if (x==2) a[k].rsum=0,a[k].lsum=0;
        if (x==3) a[k].rsum=0,a[k].lsum=l;
        return;
    }
    int mid=a[k].l+a[k].r >> 1;
    if (mid>=l) ud(k << 1,l,x);
    if (mid<l) ud(k << 1^1,l,x);
    int lson=k << 1,rson=k << 1^1;
   a[k].sum=a[lson].sum+a[rson].sum+min(1,a[lson].rsum)*min(1,a[rson].lsum);
    if (a[lson].lsum>0) a[k].lsum=a[lson].lsum;
        else
          if (a[lson].rsum==0&&a[lson].sum==0) a[k].lsum=a[rson].lsum;
              else a[k].lsum=0;
    if (a[rson].rsum>0) a[k].rsum=a[rson].rsum;
        else
          if (a[rson].lsum==0&&a[rson].sum==0) a[k].rsum=a[lson].rsum;
              else a[k].rsum=0;//同上
```
}//修改
```cpp
int queryr(int k,int l,int r)
{
    if (a[k].rsum>=l&&a[k].rsum<=r) return a[k].rsum;
      else return 0;
}
int queryl(int k,int l,int r)
{
    if (a[k].lsum<=r&&a[k].lsum>=l) return a[k].lsum;
      else return 0;
}
int query(int k,int l,int r)
{
    //printf("%d %d %d\n",a[k].l,a[k].r,min(1,queryl(k << 1^1,l,r))*min(1,queryr(k << 1,l,r)));也是用来调代码的
    if (a[k].l>r||l>a[k].r) return 0;
    if (a[k].l>=l&&a[k].r<=r) return a[k].sum;
    int ans=query(k << 1,l,r)+query(k << 1^1,l,r);//访问左儿子的木棍数+访问右儿子的木棍数
    ans+=min(1,queryl(k << 1^1,l,r))*min(1,queryr(k << 1,l,r));//左儿子的最靠右的“（”和右儿子的最靠左的“）”能否组成一个新的木棍
    return ans;
```
}//询问
```cpp
int main(){
    freopen("1.in","r",stdin);
    freopen("1.out","w",stdout); 
    scanf("%d%d",&n,&m);
    build(1,1,n);
    For(i,1,m) {
        scanf("%d",&k);
        if (k==1) {
            scanf("%d %c",&x,&c);
            if (c=='(') y=1;
            if (c=='X') y=2;
            if (c==')') y=3;
            ud(1,x,y);
        }
        else {
            scanf("%d%d",&x,&y);
            printf("%d\n",query(1,x,y));
        }
        //For(j,1,20) printf("%d %d %d %d %d\n",a[j].l,a[j].r,a[j].sum,a[j].lsum,a[j].rsum);printf("\n");用来调试代码的。。。
    }
    return 0;
}
```

---

## 作者：wjyyy (赞：2)

**博客[传送门](http://www.wjyyy.top/798.html)**
## 题解：

   表面看上去是一个**单点修改，区间查询**的线段树，可是维护木棍个数是个问题。可以看出，如果把木棍看作线段树的区间，而拼出来的木棍中间不能出现多余的'('或')'，那么我们计算线段树区间和时，只需要把两边原本就有的木棍数加起来，并判断左区间**最右边的左括号**和右区间**最左边的右括号**之间有没有**其他括号**。如果有，则不增加，如果没有，把个数增加1。



   这样一来，我们要维护的信息是：**区间内存在的完整木棍数v，最右边的左括号rl，最左边的右括号lr，最左边的左括号ll，最右边的右括号rr**。因为我们维护的是**最值**，所以当没有的时候就设为缺省值。维护最左边的，缺省值为233333（大于200000就可以）；维护最右边的，缺省值为0。这样取min或max的时候，在另一个参数有意义时，就不会有影响。



   ##### 重构代码大法好。一开始准备在原来的代码上改改，后来一个小时过去实在弄不下去了直接重构。改完语法错误就过了= =

## Code：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ls (k<<1)
#define rs (k<<1|1)
#define mid (l+r>>1)
#define Mid (t[k].l+t[k].r>>1)
using std::min;
using std::max;
struct node
{
    int l,r,v,lr,rl,ll,rr;
    node(int l,int r)
    {
        this->l=l;
        this->r=r;
        v=0;
    }
    node(){v=0;}
}t[810000];
void maintain(int k)
{
    if(t[ls].rl>t[ls].rr&&t[rs].lr<t[rs].ll)//左区间最右边的左括号和有区间最左边的右括号中间没有其他括号
        t[k].v=t[ls].v+t[rs].v+1;
    else
        t[k].v=t[ls].v+t[rs].v;
    t[k].ll=min(t[ls].ll,t[rs].ll);//维护最大/最小
    t[k].lr=min(t[ls].lr,t[rs].lr);
    t[k].rr=max(t[ls].rr,t[rs].rr);
    t[k].rl=max(t[ls].rl,t[rs].rl);
    return;
}
int n;
void build(int k,int l,int r)
{
    t[k]=node(l,r);
    if(l==r)
    {
        if(l==1)
        {
            t[k].lr=233333;//l开头的缺省值为233333
            t[k].rl=1;//r开头的缺省值为0
            t[k].ll=1;
            t[k].rr=0;
        }
        else if(l==n)
        {
            t[k].lr=n;
            t[k].rl=0;
            t[k].ll=233333;
            t[k].rr=n;
        }
        else
        {
            t[k].lr=233333;
            t[k].rl=0;
            t[k].ll=233333;
            t[k].rr=0;
        }
        return;
    }
    build(ls,l,mid);
    build(rs,mid+1,r);
    maintain(k);
}
void change(int k,int x,char c)
{
    if(t[k].l==t[k].r)
    {
        if(c=='(')
        {
            t[k].lr=233333;
            t[k].rr=0;
            t[k].ll=x;
            t[k].rl=x;
        }
        else if(c==')')
        {
            t[k].lr=x;
            t[k].rr=x;
            t[k].ll=233333;
            t[k].rl=0;
        }
        else
        {
            t[k].lr=233333;
            t[k].rr=0;
            t[k].ll=233333;
            t[k].rl=0;
        }
        return;
    }
    if(x<=Mid)
        change(ls,x,c);
    else
        change(rs,x,c);
    maintain(k);
    return;
}
int ask(int k,int l,int r)
{
    if(t[k].l==l&&t[k].r==r)
        return t[k].v;
    if(r<=Mid)
        return ask(ls,l,r);
    else if(l>Mid)
        return ask(rs,l,r);
    if(t[ls].rl>t[ls].rr&&t[rs].lr<t[rs].ll&&l<=t[ls].rl&&r>=t[rs].lr)//记得判范围
        return ask(ls,l,Mid)+1+ask(rs,Mid+1,r);
    else
        return ask(ls,l,Mid)+ask(rs,Mid+1,r);
}
int main()
{
    int m,op,l,r;
    char c;
    scanf("%d%d",&n,&m);
    build(1,1,n);
    while(m--)
    {
        scanf("%d",&op);
        if(op==1)
        {
            scanf("%d %c",&l,&c);
            change(1,l,c);
        }
        else
        {
            scanf("%d%d",&l,&r);
            printf("%d\n",ask(1,l,r));
        }
    }
    return 0;
}
```

---

## 作者：北方火柴 (赞：2)

**蒟蒻的第一篇XXX**

**复健的时候来切一下这道题，做了快两个小时（泪）（其实之前第一遍做的时候没复习然后就没去管）**

**楼下的意思很清楚，线段树很容易想到，关键就是记录每条线段的极左以及极右线段的括号，然后统计的时候看一下左右儿子**

**left表示极左，right表示极右，p1，p2表示极左以及极右的括号下标**

**想发题解主要是为了给pascal（注意修改的时候中间有空格）**

**代码习惯极差，比较丑**








































```cpp
var tree,p1,p2:array[0..800005] of longint;
      left,right,st:array[0..800005] of char;
      i,j,m,n,p,q,ll,rr,ans,o,x:longint;
      c:char;
   procedure renew(p: longint);
      begin
          if left[2*p]<>'X' then
              begin
                   left[p]:=left[2*p];
                   p1[p]:=p1[2*p];
              end else
          if right[2*p]<>'X' then
              begin
                   left[p]:=right[2*p];
                   p1[p]:=p2[2*p];
              end else
          if left[2*p+1]<>'X' then
              begin
                   left[p]:=left[2*p+1];
                   p1[p]:=p1[2*p+1];
              end else
              begin
                   left[p]:=right[2*p+1];
                   p1[p]:=p2[2*p+1];
              end;
          if right[2*p+1]<>'X' then
              begin
                   right[p]:=right[2*p+1];
                   p2[p]:=p2[2*p+1];
              end else
          if left[2*p+1]<>'X' then
              begin
                   right[p]:=left[2*p+1];
                   p2[p]:=p1[2*p+1];
              end else
          if right[2*p]<>'X' then
              begin
                   right[p]:=right[2*p];
                   p2[p]:=p2[2*p];
              end else
              begin
                   right[p]:=left[2*p];
                   p2[p]:=p1[2*p];
              end;
        tree[p]:=tree[2*p]+tree[2*p+1];
        if (right[2*p]='(') and  (left[2*p+1]=')') then inc(tree[p]);
     end;
   procedure build(p,l,r:longint);
      var m:longint;
          begin
             if l=r then
                  begin
                       left[p]:=st[l]; p1[p]:=l;
                       right[p]:=st[l];  p2[p]:=r;
                       exit;
                 end;
           m:=(l+r) div 2;
           build(2*p,l,m); build(2*p+1,m+1,r);
           renew(p);
         end;
  procedure modify(p,l,r:longint);
      var m:longint;
       begin
            if  (l>x) or (r<x) then exit;
            if  (l=r) then
               begin
                     left[p]:=st[l]; p1[p]:=l;
                     right[p]:=st[l];  p2[p]:=r;
                     exit;
              end;
           m:=(l+r) div 2;
           modify(2*p,l,m); modify(2*p+1,m+1,r);
           renew(p);
       end;
  procedure query(p,l,r:longint);
       var m:longint;
       begin
          if  (ll>r) or (rr<l)  then exit;
          if (r<=rr) and (l>=ll) then
           begin
              ans:=ans+tree[p];
              exit;
           end;
          m:=(l+r) div 2;
          query(2*p,l,m); query(2*p+1,m+1,r);
          if (left[2*p+1]=')') and (p1[2*p+1]<=rr)  and (right[2*p]='(') and (p2[2*p]>=ll) then inc(ans);
      end;
  begin
         readln(n,m);  for i:=1 to n do st[i]:='X';
         st[1]:='('; st[n]:=')';
         build(1,1,n);
         for i:=1 to m do
            begin
                read(o);
                if o=2 then
                        begin
                               readln(ll,rr);
                               ans:=0;
                               query(1,1,n);
                               writeln(ans);
                       end else
                       begin
                              read(x); readln(c,st[x]);
                              modify(1,1,n);
                       end;
           end;
   end.

```

---

## 作者：tommymio (赞：0)

分类讨论复健必做题（大雾。

经典区间括号匹配数的弱化版，不过在某种意义上有加强，细节有点多（

因为是弱化版，括号中包含的括号是不计数的，所以我们只需要维护当前区间 $[L,R]$ 最左边的右括号和最右边的左括号，以及区间内 $X$ 的个数，还有就是当前区间匹配的括号数（即题目中所称的木棒）。

$\mathrm{pushup}$ 时分别处理两种情况即可。

- 左区间最左括号为左括号，右区间最左括号为右括号。这种情况下需要这两个括号间全部都为 $X$。

- 左区间最右括号为左括号，右区间最左括号为右括号。这种情况可以直接匹配。

具体实现时，将匹配过的最左、最右括号置为空。并且注意这两种情况在当前区间长度为 $2$ 时可能同时被计数，因为实际不存在这种情况，而又被计数了两遍，所以需要只计数其中一种情况。

```cpp
#include<cstdio>
#define ls p<<1
#define rs p<<1|1
struct state {int l,r,res,sum; char lb,rb;}f[800005];
char s[2],a[200005];
inline int max(const int &x,const int &y) {return x>y? x:y;}
inline int min(const int &x,const int &y) {return x<y? x:y;}
inline const state& merge(state &des,const state &x,const state &y) {
	if(x.lb!='('&&x.lb!=')') {des.lb=y.lb;} else {des.lb=x.lb;}
	if(y.rb!='('&&y.rb!=')') {des.rb=x.rb;} else {des.rb=y.rb;} 
	des.sum=x.sum+y.sum; des.res=x.res+y.res;
	if(x.rb=='('&&y.lb==')') {++des.res;} 
	else if(des.sum==des.r-des.l-1&&x.lb=='('&&y.rb==')') {des.lb=des.rb='X';++des.res;}
	return des;
}
inline void pushup(int p) {merge(f[p],f[ls],f[rs]);}
inline void build(int p,int l,int r) {f[p].l=l; f[p].r=r; if(l==r) {f[p].sum=(a[l]=='X');f[p].lb=f[p].rb=a[l];return;} int mid=l+r>>1; build(ls,l,mid); build(rs,mid+1,r); pushup(p);}
inline void change(int p,int l,int r,int x,char op) {if(l==r) {f[p].sum=(op=='X');f[p].lb=f[p].rb=op;return;} int mid=l+r>>1; if(x<=mid) change(ls,l,mid,x,op); else change(rs,mid+1,r,x,op); pushup(p);}
inline state ask(int p,int l,int r,int L,int R) {
	if(L<=l&&r<=R) return f[p];
	int mid=l+r>>1; state res=(state){max(l,L),min(R,r),0,0,0,0};
	if(L>mid) return ask(rs,mid+1,r,L,R);
	if(R<=mid) return ask(ls,l,mid,L,R);
	return merge(res,ask(ls,l,mid,L,mid),ask(rs,mid+1,r,mid+1,R));//L<=mid&&R>mid
}
int main() {
	int n,m; scanf("%d%d",&n,&m); 
	for(register int i=2;i<n;++i) a[i]='X'; a[1]='('; a[n]=')'; build(1,1,n); 
	for(register int t=1;t<=m;++t) {
		int op; scanf("%d",&op);
		if(op==1) {int x; scanf("%d%s",&x,s); change(1,1,n,x,s[0]);}
		else {int l,r; scanf("%d%d",&l,&r); printf("%d\n",ask(1,1,n,l,r).res);}
	}
	return 0;
}
```




---

## 作者：mk703 (赞：0)

安利博客<https://mk703.cn/%e6%b4%9b%e8%b0%b7%e5%a6%96%e6%a2%a6%e6%96%a9%e6%9c%a8%e6%a3%92%e9%a2%98%e8%a7%a3/>

说来惭愧，这道题居然用了一天才A。四肢无力，头脑昏沉，应该是已经步入老年时期。


好吧，这题搭眼一看sb线段树，但是评级好高。所以就要切这道题。信心满满写一发，WA，再来，又WA。最后写了暴力对拍，用了好长时间。


首先定义线段树节点：


1. num 在区间中有多少木棍

2. fr 在区间最后是否是“（”

3. en在区间首位是否是“）”


接下来开始推：肯定seg[i].num += seg[i << 1].num + seg[(i << 1) + 1].num。但是这样就对吗？？很显然不是因为我们还有fr和en没有用所以要判断seg[i << 1].fr 和 seg[(i << 1) + 1].en是否为真，真则num++。


又来活了，fr和en怎么推。好像这就是这题最难的地方辣。


以en为例有两种情况：


1.     seg[i]的en来自左儿子，则seg[i << 1].en == true

2. 否则，seg[i]的en来自右儿子，则右儿子seg[(i << 1) + 1].en == true 左儿子啥也没有全是“X” ——!seg[i << 1].fr && !seg[i << 1].num


同理推fr。


对于单点修改时也如此。


如何区间查询。好像这就是这题第二难的地方辣。


首先要定义end表示在上一次t选择时左边有没有多的“（”，fro表示在上一次s选择时右边有没有多的“）”。


这里fro和end的推法与上面类似就不再赘述。


最后是在s和t爬到停止的时候，要判断一下s所代表区间右端和t所代表区间左端是否是匹配。就是在循环外加

if(fro && end)ans++;


---

## 作者：Chester1011 (赞：0)

### 前置芝士：线段树 ~~（应该会的吧）~~
本题可以算线段树的基本操作了，进入正题吧：
我们线段树中存储三个变量：
- $sum[x]$ :完整的木棒的数量
- $ls[x]$ :最右边的括号是否是 ( 
- $rs[x]$ :最左边的括号是否是 )
##### 做题过程分为建树，单点修改和查询 ~~（很经典了吧）~~
本题在建树和单点修改时只有一点与其他节点不同，就是合并节点信息，在这里略作解释：
首先是最简单直接赋值：
$$rs_x=rs_{sonL},ls_x=ls_{sonR}$$
$$ sum_x=sum_{sonL}+sum_{sonR}+[ls_{sonL}==1\&\&rs_{sonR}==1]$$
#### 另外注意一点，当$sonL$的区集中全是$X$时，$rs_x$是要等于$rs_{sonR}$的，而且易证得，如果$sum_{sonL}==0\&\&rs_{sonL}==0\&\&ls_{sonL}==0$，则可以说明左儿子全是$X$，因此合并部分代码如下：
```cpp
inline void update(int x)
{
		rs[x]=rs[x<<1],ls[x]=ls[x<<1|1];
		if(sum[x<<1]==0&&ls[x<<1]==0&&rs[x<<1]==0) rs[x]=rs[x<<1|1];
		if(sum[x<<1|1]==0&&ls[x<<1|1]==0&&rs[x<<1|1]==0) ls[x]=ls[x<<1];
		sum[x]=sum[x<<1]+sum[x<<1|1]+(ls[x<<1]+rs[x<<1|1]>>1);
}
```
再就是查询了，这里需要用到一个小技巧，线段树的遍历顺序是从左往右的，所以我们每遇到一个合法区间，和前一个遇到的合法区间合并计算答案就好了，同样需要注意全为$X$的情况。
### $OVER$~~
完整代码如下：
```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
inline int read()
{
		re int x=0,f=1;
		re char ch=getchar();
		for(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') f*=-1;
		for(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+(ch^48);
		return x*f;
}
const int N=200005;
int n,m,sum[N<<2],ans;
bool ls[N<<2],rs[N<<2],last;
char ch[N],s[1];
inline void update(int x)
{
		rs[x]=rs[x<<1],ls[x]=ls[x<<1|1];
		if(sum[x<<1]==0&&ls[x<<1]==0&&rs[x<<1]==0) rs[x]=rs[x<<1|1];
		if(sum[x<<1|1]==0&&ls[x<<1|1]==0&&rs[x<<1|1]==0) ls[x]=ls[x<<1];
		sum[x]=sum[x<<1]+sum[x<<1|1]+(ls[x<<1]+rs[x<<1|1]>>1);
}
void build(int l,int r,int x)
{
		if(l==r) {ls[x]=(ch[l]=='('),rs[x]=(ch[l]==')');return ;}
		re int mid=l+r>>1;
		build(l,mid,x<<1),build(mid+1,r,x<<1|1);
		update(x);
}
void change(int l,int r,int x,int p,char a)
{
		if(l==r) {ls[x]=(a=='('),rs[x]=(a==')');return ;}
		re int mid=l+r>>1;
		if(p<=mid) change(l,mid,x<<1,p,a);
		else change(mid+1,r,x<<1|1,p,a);
		update(x);
}
void ask(int l,int r,int x,int L,int R)
{
		if(L<=l&&r<=R)
		{
			if(sum[x]==0&&ls[x]==0&&rs[x]==0) return ;
			ans+=sum[x]+(last+rs[x]>>1);
			last=ls[x];//last为上一个合法区间最右边一个括号是否为 (
			return ;
		}
		re int mid=l+r>>1;
		if(L<=mid) ask(l,mid,x<<1,L,R);
		if(R>mid) ask(mid+1,r,x<<1|1,L,R);
}
inline void Fre()
{
		freopen("P3797.in","r",stdin);
		freopen("P3797.out","w",stdout);
}
int main()
{
		Fre();
		n=read(),m=read();
		for(re int i=2;i<n;i++) ch[i]='X';ch[1]='(',ch[n]=')';
		build(1,n,1);
		for(re int i=1,type,x,y;i<=m;i++)
		{
			type=read(),x=read();
			if(type==1)
			{
				scanf("%s",s);
				change(1,n,1,x,s[0]);
			}
			else
			{
				y=read(),ask(1,n,1,x,y);
				printf("%d\n",ans);
				ans=last=0;
			}
		}
		return 0;
}
```


---

## 作者：zhimao (赞：0)

花了一下午做这题，真是一道线段树的好题。

### 题意
有点像括号匹配，但又不同。若有左边‘）’，右边‘（’，且两括号间**只有**‘X’（或没东西），则匹配成功，+1。

每个操作要么把一个字符替换成另一个，要么统计一段区间内匹配数。

### 分析

看到这种带区间查询与修改的问题，肯定先想到树状数组或线段树。但思考一下发现树状数组似乎不行，于是选用线段树。

基本思路：a数组记录匹配数与当前区间左右的情况（0,1,2,3）。

- 0：表示无法用于匹配，像‘XX（X)X’这种。
- 1：表示匹配的右边，像‘）’和‘XXX）’。
- 2：表示匹配的左边，像‘（’和‘（XXX’。
- 3：表示匹配的中间，像‘XXXXXXXXX’这种。

c数组记录当a为1,2时左右括号的位置。

然后是建树和更新(其实一个样），
叶节点：（匹配数为0，c数组为区间位置）

- ‘）’则区间左为1，
- ‘（’则区间右为2，
- ‘X’ 则左右都为3，

非叶节点：

匹配数：左右区间和，若左区间右为2，右区间左为1再加1。

区间左右的情况：当左或右区间为（3,3），则大区间左右情况为另一区间情况。否则，大区间左边为左区间左，右边为右区间右。c数组与区间左右的情况写法一样（只要把a改成c即可）。如果不能理解，可以画几组试试。（我也举几个例子：3,3|0,2→XX XX|（）（X 合并为0,2；1,0|1,2→）X （）|）X X(合并为1,2。）

但实际上这样是有问题的：3,2|1,3实际上合并为0,0。所以还要特判一下：当?,2|1,?时，若?为3，则把3改为0。

最后是统计答案。c数组在这里终于有用了，当x<=左区间右位置且y<=右区间左位置同时左区间右为2，右区间左为1时ans+1。

### 代码

```pascal
var a,c:array[0..800005,0..2] of longint;
  b:array[0..200005] of char;
  n,i,j,x,y,z,m:longint;
  ch:char;
procedure build(l,r,k:longint);
var mid:longint;
begin
  if l=r then
    begin
      c[k,0]:=l;c[k,2]:=l;
      case b[l] of
        '(':a[k,2]:=2;
        ')':a[k,0]:=1;
        'X':begin a[k,0]:=3;a[k,2]:=3;end;
      end;
      exit;
    end;
  mid:=(l+r) div 2;
  build(l,mid,k*2);
  build(mid+1,r,k*2+1);
  a[k,1]:=a[k*2,1]+a[k*2+1,1];
  if(a[k*2,2]=2)and(a[k*2+1,0]=1)then inc(a[k,1]);
  if(a[k*2,0]=3)and(a[k*2,2]=3)then
    begin
      a[k,0]:=a[k*2+1,0];a[k,2]:=a[k*2+1,2];
      c[k,0]:=c[k*2+1,0];c[k,2]:=c[k*2+1,2];
    end
  else
  if(a[k*2+1,0]=3)and(a[k*2+1,0]=3)then
    begin
      a[k,0]:=a[k*2,0];a[k,2]:=a[k*2,2];
      c[k,0]:=c[k*2,0];c[k,2]:=c[k*2,2];
    end
  else
    begin
      a[k,0]:=a[k*2,0];a[k,2]:=a[k*2+1,2];
      if(a[k,0]<>3)and(a[k,2]=3)then a[k,2]:=0;
      if(a[k,0]=3)and(a[k,2]<>3)then a[k,0]:=0;
      c[k,0]:=c[k*2,0];c[k,2]:=c[k*2+1,2];
    end;
end;
function find(l,r,k:longint):longint;
var mid,s1,s2:longint;
begin
  if(x<=l)and(y>=r)then exit(a[k,1]);
  s1:=0;s2:=0;
  mid:=(l+r) div 2;
  if x<=mid then s1:=find(l,mid,k*2);
  if y>mid then s2:=find(mid+1,r,k*2+1);
  if(a[k*2,2]=2)and(a[k*2+1,0]=1)and(c[k*2,2]>=x)and(c[k*2+1,0]<=y)then
    find:=1 else find:=0;
  find:=find+s1+s2;
end;
procedure update(l,r,k:longint);
var mid:longint;
begin
  if(l=x)and(r=x)then
    begin
      b[l]:=ch;
      a[k,0]:=0;a[k,2]:=0;
      case b[l] of
       '(':a[k,2]:=2;
       ')':a[k,0]:=1;
       'X':begin a[k,0]:=3;a[k,2]:=3;end;
      end;
      exit;
    end;
  mid:=(l+r) div 2;
  if x<=mid then update(l,mid,k*2)
            else update(mid+1,r,k*2+1);
  a[k,1]:=a[k*2,1]+a[k*2+1,1];
  if(a[k*2,2]=2)and(a[k*2+1,0]=1)then inc(a[k,1]);
  if(a[k*2,0]=3)and(a[k*2,2]=3)then
    begin
      a[k,0]:=a[k*2+1,0];a[k,2]:=a[k*2+1,2];
      c[k,0]:=c[k*2+1,0];c[k,2]:=c[k*2+1,2];
    end
  else
  if(a[k*2+1,0]=3)and(a[k*2+1,0]=3)then
    begin
      a[k,0]:=a[k*2,0];a[k,2]:=a[k*2,2];
      c[k,0]:=c[k*2,0];c[k,2]:=c[k*2,2];
    end
  else
    begin
      a[k,0]:=a[k*2,0];a[k,2]:=a[k*2+1,2];
      if(a[k,0]<>3)and(a[k,2]=3)then a[k,2]:=0;
      if(a[k,0]=3)and(a[k,2]<>3)then a[k,0]:=0;
      c[k,0]:=c[k*2,0];c[k,2]:=c[k*2+1,2];
    end;
end;
begin
  readln(n,m);
  b[1]:='(';b[n]:=')';
  for i:= 2 to n-1 do b[i]:='X';
  build(1,n,1);
  for i:= 1 to m do
    begin
      read(z);
      if z=2 then
        begin
          read(x,y);
          writeln(find(1,n,1));
        end;
      if z=1 then
        begin
          read(x,ch);read(ch);
          if b[x]<>ch then update(1,n,1);
        end;
    end;
end.
```

---

## 作者：CreeperLordVader (赞：0)

线段树中的一股清流

我发现我的代码跑的还挺快，不吸氧1200多毫秒，吸氧800多毫秒

估计我维护的值是最多的。。。

思路跟别人似乎不大一样，把我的做法也详细地讲一下

#### 维护：当前区间内可以配对的括号个数（sum）

#### 当前区间从左往右第一个括号类型（lc）及其位置（lp）1为左括号，2为右括号，0为X，若不存在括号则均为0

#### 当前区间从右往左第一个括号类型（rc）及其位置（rp）

#### 为什么这么设计呢？要看下面

#### 怎么合并信息呢？

对sum而言，左右的sum直接相加是不够的，我们还应考虑左右区间在合并时可能会造成的新的贡献

#### 这个贡献只可能由左区间最右的左括号和右区间最左的右括号配对造成

因此维护lc,rc

lc,rc在维护时，不应简单的把lc和rc设为左儿子的lc和右儿子的rc，因为有可能为0

#### 如果左儿子的lc为0，说明左儿子全是0，这时该区间的lc只能是右儿子的lc，rc的维护同理

#### 为什么要维护位置呢？

在查询时，我们也不能简单地把答案相加，而要考虑左区间和右区间的括号配对的影响，但我们不能直接考虑左右区间的lc和rc

#### 万一lc和rc的位置超出了查询的区间范围呢？ 

#### 因此应当考虑在查询区间范围内的lc和rc，就要维护两次，rc的位置，即lp和rp

这个还比较好维护，和lc，rc一起更新就好了

上面应该已经讲得很详细了，代码里我就不放注释了，如果理解了的话，代码应当是能看懂的

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=200005;
int n,m;
int sum[MAXN<<2],lc[MAXN<<2],rc[MAXN<<2];
int lp[MAXN<<2],rp[MAXN<<2];
void read(int& x)
{
	char c=getchar();
	x=0;
	while(c<'0'||c>'9')
	{
		if(c=='(')
		{
			x=1;
			return ;
		}
		else if(c=='X')
		{
			x=0;
			return ;
		}
		else if(c==')')
		{
			x=2;
			return ;
		}
		else c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=x*10+c-'0';
		c=getchar();
	}
}
void update(int o)
{
	sum[o]=sum[o<<1]+sum[o<<1|1];
	if(rc[o<<1]==1&&lc[o<<1|1]==2)sum[o]++;
	if(lc[o<<1])
	{
		lc[o]=lc[o<<1];
		lp[o]=lp[o<<1];
	}
	else
	{
		lc[o]=lc[o<<1|1];
		lp[o]=lp[o<<1|1];
	}
	if(rc[o<<1|1])
	{
		rc[o]=rc[o<<1|1];
		rp[o]=rp[o<<1|1];
	}
	else
	{
		rc[o]=rc[o<<1];
		rp[o]=rp[o<<1];
	}
}
void build(int o,int l,int r)
{
	if(l==r)
	{
		sum[o]=0;
		if(l==1)
		{
			lc[o]=rc[o]=1;
			lp[o]=rp[o]=l;
		}
		else if(l==n)
		{
			lc[o]=rc[o]=2;
			lp[o]=rp[o]=l;
		}
		return ;
	}
	int mid=(l+r)>>1;
	build(o<<1,l,mid);
	build(o<<1|1,mid+1,r);
	update(o);
}
void change(int o,int l,int r,int p,int k)
{
	if(l==r&&l==p)
	{
		sum[o]=0;
		lc[o]=rc[o]=k;
		if(!k)lp[o]=rp[o]=0;
		else lp[o]=rp[o]=l;
		return ;
	}
	int mid=(l+r)>>1;
	if(p<=mid)change(o<<1,l,mid,p,k);
	else change(o<<1|1,mid+1,r,p,k);
	update(o);
}
int query(int o,int l,int r,int ql,int qr)
{
	if(ql<=l&&qr>=r)
	{
		return sum[o];
	}
	int mid=(l+r)>>1,ansl=0,ansr=0;
	bool okl=0,okr=0;
	if(ql<=mid)
	{
		ansl=query(o<<1,l,mid,ql,qr);
		if(rc[o<<1]==1&&rp[o<<1]>=ql)okl=1;
	}
	if(qr>mid)
	{
		ansr=query(o<<1|1,mid+1,r,ql,qr);
		if(lc[o<<1|1]==2&&lp[o<<1|1]<=qr)okr=1;
	}
	return ansl+ansr+(okl&okr);
}
int main()
{
	read(n);
	read(m);
	build(1,1,n);
	for(int i=1;i<=m;i++)
	{
		int op;
		read(op);
		if(op==1)
		{
			int p,k;
			read(p);
			read(k);
			change(1,1,n,p,k);
		}
		else
		{
			int l,r;
			read(l);
			read(r);
			printf("%d\n",query(1,1,n,l,r));
		}
	}
}
```


---

## 作者：zhouenji (赞：0)

这道题实在是太坑了，我一个下午就浪费在这上面了，终于过了，来发题解

题目问的是【l，r】之中括号的匹配数

我们可以用posl【g】表示【l，r】区间中左括号的位置，posr【g】【l，r】区间中右括号的位置

那么括号的数量就是左区间的数量加右区间的数量加中间的数量；

难点就在答案的统计和修改，详情见代码：

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<iostream>
using namespace std;
const int maxn=1000000+10;
int ls[maxn],rs[maxn],sum[maxn],posl[maxn],posr[maxn];
int n,m,cnt,ans,root;
void add(int &g,int l,int r,int ll,int rr,int opt)
{
    if(!g){g=++cnt;posl[g]=0;posr[g]=n+1;}
    if(rr<l || r<ll)return;
    if(ll<=l&&r<=rr){
        if(opt==1){posl[g]=l;posr[g]=n+1;return;}
        if(opt==2){posr[g]=l;posl[g]=0;return;}
        if(opt==3){posl[g]=0;posr[g]=n+1;return;}
    }int mid=l+r>>1;
    add(ls[g],l,mid,ll,rr,opt);add(rs[g],mid+1,r,ll,rr,opt);
    posl[g]=max(posl[ls[g]],posl[rs[g]]);posr[g]=min(posr[ls[g]],posr[rs[g]]);
    if(sum[rs[g]]!=0)posl[g]=posl[rs[g]];
    if(sum[ls[g]]!=0)posr[g]=posr[ls[g]];
    sum[g]=sum[ls[g]]+sum[rs[g]];
    if(posl[ls[g]]>0 && posr[rs[g]]<n+1)
    {
        sum[g]=sum[ls[g]]+sum[rs[g]]+1;
        posl[g]=posl[rs[g]];posr[g]=posr[ls[g]];
    }
}
void get(int &g,int l,int r,int ll,int rr)
{
    if(!g){g=++cnt;posl[g]=0;posr[g]=n+1;}
    if(rr<l || r<ll)return;
    if(ll<=l&&r<=rr){ans+=sum[g];return;}
    int mid=l+r>>1;
    get(ls[g],l,mid,ll,rr);get(rs[g],mid+1,r,ll,rr);
    if(posl[ls[g]]>=ll && posr[rs[g]]<=rr)ans++;
}
int main()
{
    scanf("%d%d",&n,&m);
    add(root,1,n,1,1,1);add(root,1,n,n,n,2);
    for(int i=1;i<=m;i++){
        int opt,x,y;char c;
        scanf("%d%d",&opt,&x);
        if(opt==1){
            cin>>c;
            if(c=='(')add(root,1,n,x,x,1);
            if(c==')')add(root,1,n,x,x,2);
            if(c=='X')add(root,1,n,x,x,3);
        }
        if(opt==2){
            scanf("%d",&y);
            ans=0;get(root,1,n,x,y);printf("%d\n",ans);
        }
    }
}
```

---

## 作者：Mychael (赞：0)

**线段树**

真是不容易啊。。终于过了


其实想到是线段树还是很好做的


”（“  和 “）”可以配对成一条木棒，当且仅当他们之间没有其他的“（”或“）”，即之间都为X

所以对于区间[L,R],他的完整木棒数=左区间完整木棒数+右区间完整木棒数+ 1或0【如果左区间最右侧为“（”，右区间最左为“）”，刚好可以凑成一个木棒，则这里是1，否则是0】


由此可以看出，这个线段树有三个属性：区间方案书，区间最左的非X木棒，区间最右的非X木棒

区间[L,R]的最左非X木棒=左区间的最左非X木棒【若左区间最左也没有非X木棒，那么就等于右区间的最左非X木棒】

最右非X木棒同理


具体实现在代码：




```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=200005,INF=2000000000;
int Left[4*maxn],Right[4*maxn],sum[4*maxn],L,R,N; //Left存放最左非X木棒,Right同理，sum存放完整木棒数
//1表示“（”，2表示“）”，0表示“X”
int read()     //快速读入
{
    int out=0,flag=1;
    char c=getchar();
    while(c<48||c>57) {if(c=='-') flag=-1;c=getchar();}
    while(c>=48&&c<=57)
    {
        out=out*10+c-48;
        c=getchar();
    }
    return out*flag;
}
class node     //用来在询问时存左右区间信息
{
```
public:




```cpp
        int l,r,cnt;
};
void build(int u,int l,int r)       //初始化
{
    if(l==r)
    {
        if(l==1) Left[u]=Right[u]=1;
        else if(r==N) Left[u]=Right[u]=2;
        else Left[u]=Right[u]=0;
        sum[u]=0;
    }
    else
    {
        int mid=(l+r)>>1;
        build(u<<1,l,mid);
        build(u<<1|1,mid+1,r);
        Left[u]=Left[u<<1] ? Left[u<<1]:Left[u<<1|1];
        Right[u]=Right[u<<1|1] ? Right[u<<1|1]:Right[u<<1];
        sum[u]=sum[u<<1]+sum[u<<1|1]+(Right[u<<1]==1&&Left[u<<1|1]==2); //如上所述的代码实现
    }
}
void change(int u,int l,int r,int cmd)   //单点修改【虽然我还是写成区间修改的样子】
{
    if(l>=L&&r<=R)
    {
        if(cmd==1) Left[u]=Right[u]=1;
        else if(cmd==2) Left[u]=Right[u]=2;
        else Left[u]=Right[u]=0;
        sum[u]=0;
    }
    else
    {
        int mid=(l+r)>>1;
        if(mid>=R) change(u<<1,l,mid,cmd);
        else change(u<<1|1,mid+1,r,cmd);
        Left[u]=Left[u<<1] ? Left[u<<1]:Left[u<<1|1];
        Right[u]=Right[u<<1|1] ? Right[u<<1|1]:Right[u<<1];
        sum[u]=sum[u<<1]+sum[u<<1|1]+(Right[u<<1]==1&&Left[u<<1|1]==2);
    }
}
node Query(int u,int l,int r)       //询问
{
    if(l>=L&&r<=R) return (node){Left[u],Right[u],sum[u]};
    else
    {
        int mid=(l+r)>>1;
        if(mid>=R) return Query(u<<1,l,mid);
        else if(mid<L) return Query(u<<1|1,mid+1,r);
        else
        {
            node tl=Query(u<<1,l,mid),tr=Query(u<<1|1,mid+1,r),t;
            t.cnt=tl.cnt+tr.cnt+(tl.r==1&&tr.l==2);
            t.l=tl.l ? tl.l:tr.l;
            t.r=tr.r ? tr.r:tl.r;
            return t;
        }
    }
}
int main()
{
    N=read();
    int M=read(),cmd;
    char c;
    build(1,1,N);
    while(M--)
    {
        cmd=read();
        if(cmd==1)
        {
            L=R=read();
            c=getchar();
            while(c!='X'&&c!='('&&c!=')') c=getchar();
            if(c==')') change(1,1,N,2);
            else change(1,1,N,(c=='('));
        }
        else
        {
            L=read();
            R=read();
            printf("%d\n",Query(1,1,N).cnt);
        }
    }
    return 0;
}

```

---

## 作者：Dvelpro (赞：0)

蒟蒻来发一份题解
具体看代码写的比较麻烦 
```c
#include<bits/stdc++.h>
using namespace std;
#define maxn 600000+100//结构体消耗内存好大 我开了这么大才可以 小的话后面的数据全部 re
struct ac{
  int s,l,r; //(l=='('  r==')';
  ac(){
    s=0;
    l=0;
    r=0;
  }
  ac(int a,int b,int c){
     s=a;
     l=b;
     r=c;
  }
}a[maxn*4];
int n,m;
void updata(int l,int r,int in,int va,int v){
   if(r<1|r>n) return ;
   if(l==r){
      if(v==1) a[in]=ac(0,1,0);  
      if(v==2) a[in]=ac(0,0,1);
      if(v==3) a[in]=ac(0,0,0); //更新不多解释
      return ;
   }
   int mid=(l+r)/2;
   if(va>mid){
      updata(mid+1,r,in*2+1,va,v);
   }else{
      updata(l,mid,in*2,va,v);
   }
   int x=a[in*2].s+a[in*2+1].s;
   int y=a[in*2].l+a[in*2+1].r;            // 看左右能否组成一个完整的括号
   if(y==2){
     a[in]=ac(x+1,a[in*2+1].l,a[in*2].r); //可以组成采用右儿子的左括号，左儿子的右括号
   }else{
     if(x!=0){  //当他们存在完整的括号对时 
       if(a[in*2].s==0&&a[in*2].r==0){    // 完整的括号对在右区间的时候
          a[in]=ac(x,a[in*2+1].l,a[in*2+1].r);
       }else if(a[in*2+1].s==0&&a[in*2+1].l==0){  //在左区间的时候
          a[in]=ac(x,a[in*2].l,a[in*2].r);
       }
       else a[in]=ac(x,a[in*2+1].l,a[in*2].r); //左右区间都存在
     }
     else a[in]=ac(x,a[in*2+1].l|a[in*2].l,a[in*2+1].r|a[in*2].r);//左右都不存在
   }
}
ac query(int l,int r,int L,int R,int in){
   if(l==L&&r==R){
      return a[in];
   }
   int mid=(l+r)/2;
   if(L>mid){         //这个地方一定要处理好 因为我返回的是结构体所以返回的含有这个区间左右括号的信息
      return query(mid+1,r,L,R,in*2+1);
   }else if(R<=mid){
      return query(l,mid,L,R,in*2);
   }        
   //下面和更新操作的一样 
   ac b=query(l,mid,L,mid,in*2);
   ac c=query(mid+1,r,mid+1,R,in*2+1);
   int x=b.s+c.s;
   int y=b.l+c.r;
   if(y==2){
     return ac(x+1,c.l,b.r);
   }
   if(x!=0){
       if(b.s==0&&b.r==0){
          return ac(x,c.l,c.r);
       }else if(c.s==0&&c.l==0){
          return ac(x,b.l,b.r);
       }
       return ac(x,a[in*2+1].l,a[in*2].r);
     }
   return ac(x,c.l|b.l,c.r|b.r);
}
int main(){
 // FILE *fp;
 // fp=fopen("C://Users//Dcoder//Desktop//1.txt","r+");
   cin>>n>>m;
   //build(1,n,1);
   updata(1,n,1,1,1);//相当于两次更新 一次开头 一次结尾
   updata(1,n,1,n,2);
   while(m--){
      int x;
      cin>>x;
      if(x==2){
         int l,r;
         cin>>l>>r;
       //  fprintf(fp,"%d\n",query(1,n,l,r,1).s);
         cout<<query(1,n,l,r,1).s<<endl;
      }else{
         char c;
         int y;
         cin>>y>>c;
         if(c=='X'){
            updata(1,n,1,y,3);
         }else if(c=='('){
            updata(1,n,1,y,1);
         }else{
            updata(1,n,1,y,2);
         }
      }
   }
   //fclose(fp);
   return 0;
}

```

---


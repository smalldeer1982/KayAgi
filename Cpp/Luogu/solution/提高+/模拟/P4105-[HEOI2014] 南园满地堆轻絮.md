# [HEOI2014] 南园满地堆轻絮

## 题目描述

小 Z 是 ZRP（Zombies’ Republic of Poetry，僵尸诗歌共和国）的一名诗歌爱好者，最近 他研究起了诗词音律的问题。

在过去，诗词是需要编成曲子唱出来的，比如下面这首《菩萨蛮》，唱出来的话其对应的音符就是这样的：

```cpp
 南  园  满 地 堆 轻 絮， 愁 闻 一 霎 清 明 雨   
 1   1  5 5 6 6 5  4 4 3 3 2 2 1  
```
因而可以发现，`1 1 5 5 6 6 5 4 4 3 3 2 2 1`这串音符就成为了研究音律的关键。

小 Z 翻阅了众多史料发现，过去的一首曲子的音调是不下降的。 小 Z 想要知道对于一首给定的曲子，如何通过提高音调或者降低音调，将它的音调修改的不下降，而且使得修改幅度最大的那个音符的修改幅度尽量小。即如果把一个包含 $n$ 个音 符的曲子看做是一个正整数数列 $A[1] \cdots A[n]$，那么目标是求另一个正整数数列 $B[1]…B[n]$， 使得对于任意的 $1≤i<n$ 有 $B[i] ≤B[i+1]$，而且使得 $Ans = Max\{|A[j]-B[j]|,1≤j≤n\}$尽量 小。
小 Z 很快就想清楚了做法，但是鉴于他还忙着写诗，所以这个任务就交给了你。


## 说明/提示

【数据范围】

对于 10% 的数据， $n≤3$

对于 20% 的数据,  $n≤10$

对于 30% 的数据,  $n≤100$

对于 50% 的数据,  $n≤1000$

对于 70% 的数据,  $n≤100000$

对于 100% 的数据, $n≤5000000$，$S_a,S_b,S_c,S_d,A[1] ≤10000$，$ Mod≤1000000007 $

【友情提示】

样例中生成的数列为：  199 4568 1901，此时将 4568 修改为 3234,1901 也修改为 3234 即可，代价为 1334。


## 样例 #1

### 输入

```
3 815 6901 3839 178 199 10007 ```

### 输出

```
1334```

# 题解

## 作者：Ameyax (赞：17)

贪心
我们需要把所有逆序对都变成非逆序的

那么就有一个显然的结论：答案就是差距最大的逆序对的一半

如果有更大的，那一定是你的最大逆序对找错了

```cpp
#include <bits/stdc++.h>
using namespace std;
#define LL long long
LL n, sa, sb, sc, sd, a1, a2, ai, mod, maxn, ans;
LL F(LL x)
{
    LL x1 = (sa * x) % mod;
    x1 = (x1 * x) % mod;
    x1 = (x1 * x) % mod;
    LL x2 = (sb * x) % mod;
    x2 = (x2 * x) % mod;
    LL x3 = (sc * x) % mod;
    return (((((x1 + x2) % mod) + x3) % mod) + sd) % mod;
}
int main()
{
    cin >> n >> sa >> sb >> sc >> sd >> a1 >> mod;
    maxn = a1;
    for (int i = 2; i <= n; i++)
    {
        ai = F(a1) + F(a2);
        if (ai < mod) ai += mod;
        if (ai > mod) ai %= mod;
        if (maxn - ai > ans) ans = maxn - ai;
        if (ai > maxn) maxn = ai;
        a2 = a1; a1 = ai;
    }
    cout << (ans + 1) / 2 << endl;
    return 0;
}
```
另外还可以二分答案，check函数大概长这样

```cpp
bool check(int x)
{
    int maxn = 1;
    for (int i = 1; i <= n; i++)
    {
        maxn = max(maxn, a[i] - x);
        if (maxn > a[i] + x)
            return 0;
    }
    return 1;
}
```
这里我还有一句话一定要说，我的$O(n)$算法没有我前面那位神犇的$O(nlogn)$快！！！


---

## 作者：Fading (赞：8)

### 二分+贪心 

一看到最大值的最小值，先二分答案(最小值的最大值)。

check 怎么写呢？

第一个数直接减 $\text{mid}$，这样一定是最优的。

枚举 $i=2...n$ ，一个一个判断：

- #### 如果 $a_{i-1}\leq a_i$：

就把 $a_i$ 变成 $\max(a_i-\text{mid},a_{i-1})$

反正最大值已经确定了，减多少都没有关系，但是不能减到比第前一个数小。

- #### 如果 $a_{i-1}>a_i$：

若 $a_{i-1}-a_i>\text{mid}$ 那么无论如何也无法达到要求了，无解。否则就变成$a_{i-1}$。

~~一遍过编译一遍过样例一遍 AC 真的爽~~

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ljc 998244353
using namespace std;
#ifdef Fading
#define gc getchar
#endif
#ifndef Fading
inline char gc(){
	static char now[1<<16],*S,*T;
	if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
	return *S++;
}
#endif
inline ll read(){
    register ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}
    return (f==1)?x:-x;
}
int n,SA,SB,SC,SD,a[5020001],b[5020001],MOD;
inline int F(int x){
	ll ans=0;
	ans=(ans+1LL*SA%MOD*x%MOD*x%MOD*x%MOD)%MOD;
	ans=(ans+1LL*SB%MOD*x%MOD*x%MOD)%MOD;
	ans=(ans+1LL*SC%MOD*x%MOD)%MOD;
	ans=(ans+1LL*SD)%MOD;
	return ans;
}
inline bool check(int mid){
	a[1]=b[1]-mid;
	for (int i=1;i<=n;i++){
		if (b[i]>=a[i-1]) a[i]=max(b[i]-mid,a[i-1]);
		else{
			if (a[i-1]-b[i]>mid) return 0;
			a[i]=a[i-1];
		}
	}
	return 1;
}
signed main(){
	n=read(),SA=read(),SB=read(),SC=read(),SD=read(),a[1]=read(),MOD=read();
	for (int i=2;i<=n;i++){
		a[i]=(F(a[i-1])+F(a[i-2]))%MOD;
	}
	for (int i=1;i<=n;i++){
		b[i]=a[i];//存一个备份
	}
	int lb=0,rb=MOD,ans=0;
	while (lb<=rb){
		int mid=(lb+rb>>1);
		if (check(mid)){
			rb=mid-1;ans=mid;
		}else{
			lb=mid+1;
		}
	}
	cout<<ans;
	return 0;
}

```

```


---

## 作者：是个汉子 (赞：6)

[洛谷传送门](https://www.luogu.com.cn/problem/P4105)

 $O(n\log n)$ 的做法讲的人比较多，就不提了(^人^)

### Solution

因为 $O(n)$ 的做法并没有看出来`正确性显然`，所以这里简单yy一下。

我们先说结论：答案为 $(最大逆序对差+1)/2$，也就是将相差最大的逆序对变为同一个数的代价。

设 $a_i,a_j(i<j,a_i>a_j)$ 为相差最大的逆序对，那么在区间 $(i,j)$ 中的数一定是大于等于 $a_j$ 且小于等于 $a_i$ 的。

那么将区间 $(i,j)$ 全部变为同一个数必然是满足条件的。然后对于 $(1,i)$ 和 $(j,n)$ 这两个区间我们可以用同一种方法去处理。

yy完毕。

### Code

```c++
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>

using namespace std;
const int N=5e6+10,INF=0x3f3f3f3f;
int n,sa,sb,sc,sd,a[N],mod,mx=-INF,ans;

template<typename T>inline void read(T &x){
    x=0; bool f=0;
    char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=1;ch=getchar();}
    while(isdigit(ch)){x=x*10+(ch^48);ch=getchar();}
    if(f) x=-x;
}

inline int add(int a,int b){return a+b>mod?a+b-mod:a+b;}
inline int mul(int a,int b){return 1ll*a*b%mod;}

inline int f(int x){	//这里有点毒瘤,不过问题不大(●'◡'●)
    return add(add(add(mul(mul(mul(sa,x),x),x),mul(mul(sb,x),x)),mul(sc,x)),sd);
}

int main(){
    read(n); read(sa); read(sb); read(sc); read(sd); read(a[1]); read(mod);
    for(int i=2;i<=n;i++) a[i]=add(f(a[i-1]),f(a[i-2]));
    for(int i=1;i<=n;i++){
        if(mx<=a[i]) mx=a[i];
        else ans=max(ans,mx-a[i]+1>>1);
    }
    printf("%d\n",ans);
    return 0;
}
```



---

## 作者：e4fsrc2e4fsrc2 (赞：3)

## [南园满地堆轻絮](https://www.luogu.com.cn/problem/P4105)
## 生成函数构造
定义一个函数 $\text{F(a,b,c,d,x)}=a\times x^3+b\times x^2+c\times x+d$。

然后按照题目模拟，就像这样，构造出满足题目条件的 ```f``` 数组：
```cpp
ll F(ll x){return (a*x%mod*x%mod*x%mod+b*x%mod*x%mod+c*x%mod+d)%mod;}
int main(){
    cin>>n>>a>>b>>c>>d>>f[1]>>mod;
	a%=mod,b%=mod,c%=mod,d%=mod,f[1]%=mod;
	for(R i=2; i<=n; i++)f[i]=(F(f[i-1])+F(f[i-2]))%mod;
}
```
## 思路分析
看到最大值最小，很容易想到二分。

我们发现，$|A_i-B_i|$ 的值其实就是对第 $i$ 个位置的数所修改的幅度。我们需要做的是让这个幅度尽可能的小。

假如对于一个能修改的幅度 $ans$，如果 $ans$ 能满足答案，那么 $ans+1$ 也能满足答案，答案具有单调性，可以考虑二分。然后二分能修改的幅度 $ans$。

所以问题便转化为二分的 ```check``` 函数怎么写。

### check 函数
设当前所能修改的幅度为 $x$，那么我们从前往后遍历 $A$ 数组。对于当前的 $A_i$ 来说，我们肯定要让它尽可能地小，因为这样才能使当前的数尽可能比后面的数小。

那么就是：

如果 $A_i\ge A_{i-1}$，那么将 $A_i$ 修改为 $\max(A_i-x,nums_{i-1})$。

否则：如果 $A_i-x\ge A_{i-1}$，那么将 $A_i$ 修改为 $A_{i-1}$。

否则：我们将会发现在修改幅度为 $x$ 的情况下无法构造出 $A_i\ge A_{i-1}$ 的情况，那么这个 $x$ 便不成立。

就像这样：
```cpp
bool check(ll x){
	for(R i=1; i<=n; i++)g[i]=f[i];
	for(R i=1; i<n; i++)
		if(g[i]>g[i-1])g[i]-=min(x,g[i]-g[i-1]);
		else{
			if(g[i-1]-g[i]>x)return 0;
			else g[i]=g[i-1];
		}
	return 1;
}
```
## AC 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define R register int
using namespace std;
const int N=5e6+1;
int n,a,b,c,d;ll f[N],g[N],mod;
ll F(ll x){return (a*x%mod*x%mod*x%mod+b*x%mod*x%mod+c*x%mod+d)%mod;}
bool check(ll x){
	for(R i=1; i<=n; i++)g[i]=f[i];
	for(R i=1; i<n; i++)
		if(g[i]>g[i-1])g[i]-=min(x,g[i]-g[i-1]);
		else{
			if(g[i-1]-g[i]>x)return 0;
			else g[i]=g[i-1];
		}
	return 1;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>a>>b>>c>>d>>f[1]>>mod;
	a%=mod,b%=mod,c%=mod,d%=mod,f[1]%=mod;
	for(R i=2; i<=n; i++)f[i]=(F(f[i-1])+F(f[i-2]))%mod;
	ll l=0,mid,r=mod;
	while(l<r){
		mid=l+r>>1;
		if(check(mid))r=mid;
		else l=mid+1;
	}
	cout<<l;
	return 0;
}

```

---

## 作者：Logey (赞：3)

这道题放到省选上感觉就是白给了啊= =  
大体说下思路  
作为一名OI选手，看到**最大值最小**这种字眼应该如同条件一般想到二分答案。  
答案的下界显然是 $0$，上界是最大的数。  
那考虑一下怎么检查是否合法。  
考虑贪心。  
让每一个数尽可能地小就可以了，具体见我代码吧，也非常简单。  

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>
#include <climits>

typedef long long ll;

const int MAXN = 5e6 + 7;
ll SA, SB, SC, SD, HA;
ll a[MAXN], n, b[MAXN];

ll F(ll x) {
    return ((x * x % HA * x % HA * SA % HA) + (x * x % HA * SB % HA) + (x * SC % HA) + SD) % HA;
}

bool check(ll k) {
    memcpy(b, a, sizeof a);
    b[1] = std::max(0ll, b[1] - k);
    for (int i = 2; i <= n; i++) {
        b[i] = std::max(b[i - 1], b[i] - k);
        if (std::abs(a[i] - b[i]) > k) return false;
    }
    return true;
}

int main(int argc, char *argv[]) {
    ll l = 0, r = INT_MIN;
    scanf("%lld %lld %lld %lld %lld %lld %lld", &n, &SA, &SB, &SC, &SD, a + 1, &HA);
    r = std::max(r, a[1]);
    for (int i = 2; i <= n; i++) {
        a[i] = (F(a[i - 1]) + F(a[i - 2]) + HA) % HA;
        r = std::max(r, a[i]);
    }
    ll ans = r;
    while (l <= r) {
        ll mid = l + r >> 1ll;
        if (check(mid)) ans = mid, r = mid - 1;
        else l = mid + 1;
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：fysbb (赞：3)

此题看着很复杂，但实际上就是贪心+模拟。

用 _**O(n)**_ 枚举整个数列，对于第i个数：

如果
```pas
                     Q=max(a[j]),j∈[1,i-1]
                     a[i]<Q
                     
```
则需将a[i]改为
```pas
                     P=(a[i]+Q)/2
                     P为两个数的平均数，否则代价一定不是最优
```                     

此时最优代价
```pas
                     w[i]=(Q-a[i])/2 
```                   
**{四舍五入时取大}**

最后输出max(w[i])即可

```pas
program project1;
var
   a,b,c,s1,s2,s3,s4,md,n,ans,max:int64;
   i:longint;

function re(a,b:longint):int64;   //注意在计算f[x]时，每算一步都要 mod,不然最后会WA！！！
var c,d,x1,x2,x3,x4,x5:int64;
begin
  x1:=(b*b) mod md;
  x2:=(x1*b) mod md;
  x3:=(s1*x2) mod md;
  x4:=(s2*x1) mod md;
  x5:=(s3*b) mod md;
  d:=(((((x3+x4) mod md)+x5) mod md)+s4) mod md;
  x1:=(a*a) mod md;
  x2:=(x1*a) mod md;
  x3:=(s1*x2) mod md;
  x4:=(s2*x1) mod md;
  x5:=(s3*a) mod md;
  c:=(((((x3+x4) mod md)+x5) mod md)+s4) mod md;
  re:=(c+d) mod md;
end;             //这题是真正的膜爆


begin
  readln(n,s1,s2,s3,s4,b,md);
  a:=0;
  max:=b;
  ans:=0;
  for i:=2 to n do  begin
    c:=re(a,b);
    if trunc((max-c)/2)>ans then begin
      if (max-c)/2>(max-c) div 2+0.001 then ans:=trunc((max-c)/2)+1
        else ans:=(max-c) div 2;
    end;
    if c>max then max:=c;
    a:=b;
    b:=c;
  end;
  writeln(ans);
end.

```


---

## 作者：lidxy (赞：2)

1.38s 最优解,考场半小时想出，暴力枚举，$O(n)$ 做法。

1. 如果数列单调递增答案为 $0$。

2. 数据较大的话，生成的数列应该在 $0$ 到 $mod$ 之间反复横跳。

3. 我们只需要找到出现下降序列的最高点（局部最高点）且之后（若有上升序列）并未出现比这个点更高的值之前找到此段下降序列的最低点，记录答案。
$ans=\max(ans,\max((maxn-((maxn+minn)/2)),(((maxn+minn)/2)-minn)))$

4. 若之后的上升序列出现比最高点（局部最高点）大的值，则需要重复 3 操作，直到枚举到 $n$。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
int n,s[5];
int a[5000001],ff[5000001];
int ans,mod,maxn=0,minn=10000000;
int tot;
ll f(int a,int b,int c,int d,ll x)
{
    int y=((((a*x%mod*x%mod*x%mod)+ (b*x%mod*x%mod))+ (c*x%mod))%mod + d % mod )%mod;
    return y;
}
ll read(){ll x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
int main(){
    cin.tie(0);
    cout.tie(0);
    n=read();s[1]=read();s[2]=read();s[3]=read();s[4]=read();a[1]=read();mod=read();
    ff[0]=s[4];
    ff[1]=f(s[1],s[2],s[3],s[4],a[1]);
    for(int i=1;i<n;++i)
    {
        a[i+1]=(ff[i]+ff[i-1])%mod;//生成数列
        ff[i+1]=f(s[1],s[2],s[3],s[4],a[i+1]);
    }
    for(int i=1;i<n;++i)
    {
        if(a[i+1]<a[i])//出现降序，记录答案
        {
            maxn=max(maxn,a[i]);
            minn=min(minn,a[i+1]);
            tot=1;//标记需要更新答案        
        }
        else if(tot)//出现升序，更新答案
        {
            ans=max(ans,max((maxn-((maxn+minn)>>1)),(((maxn+minn)>>1)-minn)));//
            tot=0;
            minn=1000000;
        }
    }
    if(tot)//最后若为降序，更新答案
    {
        ans=max(ans,max((maxn-((maxn+minn)>>1)),(((maxn+minn)>>1)-minn)));
        tot=0;
        minn=1000000;
    }
    printf("%d",ans);//over
    fclose(stdin);
    fclose(stdout);
    return 0;
}
```

---

## 作者：OldVagrant (赞：2)

## 题意
[题意传送门](https://www.luogu.com.cn/problem/P4105)
## Solution 
挺好的一道简单贪心。
### Step1：模拟
首先我们要根据题意把那个生成的数列算出来，这个就根据题面上给的方法硬模拟即可，注意要开 long long。  
### Step2：贪心 
把生成的序列叫做 $b$,题上要求我们改变 $b$ 中的一些数，使得 $b$ 单调不减，那么不难发现，对于每个 $b_i$ $(1\leq i< n)$,要把 $b_{i+1}\sim b_n$  变得都不小于 $b_i$ 的话，幅度最大的一次修改就是把 $b_{i+1}\sim b_n$ 中最小的一个数 $b_j$ 与 $b_i$ 都变成 $\lfloor(b_i+b_j)\div 2\rfloor$，代价就是 $\max(\lfloor(b_i+b_j)\div 2\rfloor-b_j,b_i-\lfloor(b_i+b_j)\div 2\rfloor)$，当然如果 $b_j$ 都不小于 $b_i$ 了那么就没有必要再改。  
因为对于 $b_{i+1}\sim b_n$ 中的每个数，只有当这个数比 $b_i$ 小才用修改它，否则的话要么根本不用修改，要么就是遍历到后面的某个位置时会修改。然后稍微想一下，肯定是把两个数都改成他们的和的一半这样幅度最小，改成其他的话总会有一边的修改幅度比改成他们和的一半的幅度要大，这样就不是最优的了。所以把 $b_i$ 之后的数列变为单调不减的最小的最大代价就是把 $b_i$ 和  $b_{i+1}\sim b_n$ 中最小的数改成一样的数的代价。   
然后遍历一遍整个数列，对于每个 $b_i$ 计算出使它之后的序列单调不减所要修改的最大幅度的最小值 $num_i$，然后不断把这个值和答案取最大值，即     $ans=\max(ans,num_i)$ 。   
### Step3:找最小
想到贪心的做法之后，下一步就是处理出来每个 $b_i$ 对应的 $b_j$ ，把那个最小值预处理出来。  
这里提供两种办法：
1. 线段树，利用线段树维护区间最小值，然后遍历的时候查询即可。时间复杂度 $O(n\log n)$ ,可过此题。   
2. $O(n)$ 预处理，倒着遍历一遍生成的序列，开一个数组 $minn$ ,$minn_i$ 就是 $b_{i+1}\sim b_n$ 的最小值，初始化 $minn_n=b_n$ ,然后 $\forall i \in[1,n),minn_i=\min(minn_{i+1},b_i)$,这样能做到 $O(n)$ 的时间复杂度。

## Code
先放线段树的：
```c
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define rint register int
#define pc(x) putchar(x)
#define gc getchar
int n,a[5000001],sa,sb,sc,sd,mod,f[5000001],inf,ans,minn;
ll b,c,d;
inline int read(){
	int x=0;
	char ch=gc();
	while(!isdigit(ch)) ch=gc();
	while(isdigit(ch)) x=x*10+ch-'0',ch=gc();
	return x;
}
ll make(ll k){//根据题意模拟
	b=sa,b=b*a[k]%mod,b=b*a[k]%mod,b=b*a[k]%mod,c=sb,c=c*a[k]%mod,c=c*a[k]%mod,d=sc,d=d*a[k]%mod,b=(b+c+d+sd)%mod;
	return b;
}
struct SegmentTree{//least即区间最小值
	int l,r,least;
}st[20000001];
void push_up(ll p){
	st[p].least=min(st[p<<1].least,st[p<<1|1].least);
}
void build(ll p,ll l,ll r){//建树
	st[p].l=l,st[p].r=r;
	if(l==r){
		st[p].least=a[l];
		return;
	}ll mid=l+r>>1;
	build(p<<1,l,mid),build(p<<1|1,mid+1,r),push_up(p);
}
ll query(ll p,ll l,ll r){//查询
	if(l<=st[p].l&&st[p].r<=r) return st[p].least;
	ll mid=st[p].l+st[p].r>>1,mi=inf;
	if(l<=mid) mi=min(mi,query(p<<1,l,r));
	if(mid<r) mi=min(mi,query(p<<1|1,l,r));
	return mi;
}
int main(){
	n=read(),sa=read(),sb=read(),sc=read(),sd=read(),a[1]=read(),mod=read(),f[0]=sd,f[1]=make(1),inf=mod+1;
	for(rint i=2;i<=n;i++) a[i]=(f[i-1]+f[i-2])%mod,f[i]=make(i);//模拟
	build(1,1,n);
	for(rint i=1;i<n;i++){//找到最小值，并计算最大修改幅度，更新答案。
		minn=query(1,i+1,n);
		if(minn<a[i]){
			if((a[i]&1)^(minn&1)) ans=max(a[i]-minn+1>>1,ans);
			else ans=max(a[i]-minn>>1,ans);
		}
	}printf("%d",ans);
	return 0;
}
```   

下面这个是 $O(n)$ 预处理的：
```c
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define rint register int
#define pc(x) putchar(x)
#define gc getchar
int n,a[5000001],sa,sb,sc,sd,mod,f[5000001],inf,ans,tmp,mi[5000001];
ll b,c,d;
inline int read(){
	int x=0;
	char ch=gc();
	while(!isdigit(ch)) ch=gc();
	while(isdigit(ch)) x=(x<<3)+(x<<1)+ch-48,ch=gc();
	return x;
}
ll make(ll k){//根据题意模拟
	b=sa,b=b*a[k]%mod,b=b*a[k]%mod,b=b*a[k]%mod,c=sb,c=c*a[k]%mod,c=c*a[k]%mod,d=sc,d=d*a[k]%mod,b=(b+c+d+sd)%mod;
	return b;
}
int main(){
	n=read(),sa=read(),sb=read(),sc=read(),sd=read(),a[1]=read(),mod=read(),f[0]=sd,f[1]=make(1),inf=mod+1;
	for(rint i=2;i<=n;i++) a[i]=(f[i-1]+f[i-2])%mod,f[i]=make(i);//模拟
	mi[n]=a[n];
	for(rint i=n-1;i;i--) mi[i]=min(mi[i+1],a[i]);//预处理
	for(rint i=1;i<n;i++){//最小值已经存好了，直接用就好，同时更新答案
		if(mi[i]<a[i]){
			if((a[i]&1)^(mi[i]&1)) ans=max(a[i]-mi[i]+1>>1,ans);
			else ans=max(a[i]-mi[i]>>1,ans);
		}
	}printf("%d",ans);
	return 0;
}
```


---

## 作者：GFyyx (赞：1)

## 题目大意
给定 $n,S_a,S_b,S_c,S_d,A_1,Mod$。

定义生成函数 $F(x) = S_a\times x^3 + S_b\times x^2 + S_c\times x + S_d$ 
以及递推式 $A_i =( F(A_{i-1}) + F(A_{i-2}))\%mod$ 用于生成正整数序列 $A$。

构造另一个正整数序列 $B$ 使其为单调不下降序列。

求 $Ans=Max\{|A_j-B_j|,1≤j≤n\}$ 的最小值。

## 解题思路
题目给定 $n \leq 5 \times 10^6$，但是时间限制是 5s，可以考虑用 $\Theta(n \log n)$ 的算法。

求最大值最小，不难证明，答案具有单调性。这里考虑贪心与二分。

### 生成函数
纯模拟即可，注意 $S_a,S_b,S_c,S_d,A_1 ≤10000,Mod≤1000000007 $ 乘方过程中可能会炸 ```long long```，每乘一步都要进行取模操作。

### 二分答案
直接二分能修改的幅度 $x$。从前往后遍历 $A$ 数组。对于当前的 $A_i$ 来说，贪心地让它尽可能地小，这样使得 $A_j,i<j \leq n$ 更容易满足 $A_i \leq A_j$。

#### 二分答案的正确性
设修改的幅度为 $x$，对于每个 $A_i$ 均可取得最小的可能值。若 $A_{i+1}+x<A_i$ 则 $x$ 的取值不合理。

## AC 代码
```cpp
#include <iostream>
using namespace std;
long long n,sa,sb,sc,sd,mod,a[5000001],b[5000001];
inline long long ff(long long x){
	return (sa*x%mod*x%mod*x%mod+sb*x%mod*x%mod+sc*x%mod+sd%mod)%mod;
}//生成函数，注意取模 
inline bool check(long long x){
	for(register int i=1; i<=n; i++) b[i]=a[i];//取出数组a[i]进行check 
	for(register int i=1; i<=n; i++){ 
		if(b[i]>b[i-1]) b[i]-=min(x,b[i]-b[i-1]);//使a[i]尽可能小 
		if(b[i]<b[i-1]){
			if(b[i-1]-b[i]>x) return 0;//仍然无法满足单调不下降 
			else b[i]=b[i-1];
		}
	}
	return 1;//x取值合理 
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin >> n >> sa >> sb >> sc >> sd >> a[1] >> mod;
	for(register int i=2; i<=n; i++)
		a[i]=(ff(a[i-1])+ff(a[i-2]))%mod;//递推求a[i] 
	long long l=0,r=mod,mid;//a[i]的最大值为mod 
	while(l<r){
		mid=(l+r)>>1;
		if(check(mid)) r=mid;
		else l=mid+1;
	}//二分修改幅度 
	cout << r << endl;//答案为r 
	return 0; 
}
```


---

## 作者：STPGUY (赞：1)

# [[HEOI2014]南园满地推轻絮](https://www.luogu.com.cn/problem/P4105)

## 思路：

就是二分去找$\max(x)$, 满足$|a_i-b_i|\le x$

那么就是要让$b_i$尽可能小的满足$a_i-b_i<x$，然后在保证$b_i$单调不下降的情况下，不等式是否成立

>   易证：
>
>   ​		当$x > y$时，若$b_i$数组满足条件$a_i-b_i\le y$且$b_i$单调不下降，那么$b_i$数组也一定满足$a_i-b_i\le y$且$b_i$单调不下降
>
>   ​		那么有了这个性质就可以二分答案了，因为当小的取值成立时，大的取值一定成立

## Code

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
const int maxn = 5e6 + 10;

int n, sa, sb, sc, sd, p;
int l, r, ans, a[maxn], b[maxn];

inline int f(int x)
{
    return (1ll * sa * x  % p * x % p * x % p + 1ll * sb * x % p * x % p + 1ll * sc * x % p + sd) % p;
}

inline bool Check(int x)
{
    b[1] = max(0, a[1] - x);
    for (int i = 2; i <= n; ++i)
    {
        b[i] = max(b[i - 1], a[i] - x);
        if (abs(b[i] - a[i]) > x) return 0;
    }
    return 1;
}

int main()
{
    scanf ("%d %d %d %d %d %d %d", &n, &sa, &sb, &sc, &sd, a + 1, &p);
    for (int i = 2; i <= n; ++i) a[i] = (f(a[i - 1]) + f(a[i - 2])) % p, r = max(r, a[i]);
    r = max(a[1], r);
    while (l <= r)
    {
        int mid = (l + r) >> 1;
        if (Check(mid)) ans = mid, r = mid - 1;
        else l = mid + 1;
    }
    printf ("%d\n", ans);
}
```



---

## 作者：Yyxxxxx (赞：1)

## 题意
求一个最小的$k$，使得对于所有的$i$，有$|A_i-B_i|\le k$
$$A_i-B_i\le k,B_i-A_i\le k$$
$$A_i-k\le B_i,B_i\le A_i+k$$
$$A_i-k\le B_i\le A_i+k$$
这种什么什么最大还是最小的题目，二分就完了~~话说看标签就行~~

我们会得到一个判断的函数
```cpp
inline bool pd(int k)
{
	b[1]=a[1]-k;//让第一个尽量小
	for(int i=2;i<=n;i++)
		if(a[i]>=b[i-1])b[i]=max(a[i]-k,b[i-1]);//不能比上一个数还小
		else 
			if(a[i]+k<b[i-1])return 0;//最大都不能满足不小于前一个数，不行
			else b[i]=b[i-1];
	return 1;
}
```
当然我们不需要再搞一个数组$B$
```cpp
inline bool pd(int k)
{
	long long bi=1;
	for(int i=1;i<=n;i++)
	{
		bi=max(bi,a[i]-k);
		if(bi>a[i]+k)return 0;
	}
	return 1;
}
```
## $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=5e6+10;
ll s1,s2,s3,s4,ans,a[maxn],b[maxn],mod,n;
ll read()
{
	ll x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=(x<<1)+(x<<3)+(c-48);
		c=getchar();
	}
	return x*f;
}
ll F(ll x)
{
	int x1=x*x%mod*x%mod*s1%mod;
	int x2=x*x%mod*s2%mod;
	int x3=x*s3%mod;
	return ((((x1+x2)%mod+x3)%mod+s4)%mod+mod)%mod;
}
inline bool pd(int k)
{
	long long bi=1;
	for(int i=1;i<=n;i++)
	{
		bi=max(bi,a[i]-k);
		if(bi>a[i]+k)return 0;
	}
	return 1;
}
int main()
{
	n=read(),s1=read(),s2=read(),s3=read(),s4=read(),a[1]=read(),mod=read();
	for(int i=2;i<=n;i++)a[i]=(F(a[i-1])+F(a[i-2]))%mod;
	int l=0,r=mod;
	while(l<=r)
	{
		int mid=l+r>>1;
		if(pd(mid))r=mid-1,ans=mid;
		else l=mid+1;
	}
	printf("%d",ans%mod);
	return 0;
} 
```


---

## 作者：eros1on (赞：1)

[博客食用更佳~](https://tle666.github.io/2019/07/23/[HEOI2014]%20%E5%8D%97%E5%9B%AD%E6%BB%A1%E5%9C%B0%E5%A0%86%E8%BD%BB%E7%B5%AE/)

# **Description**

对于一个正整数数列 $A_1 \cdots A_n$ ，求另一个正整数数列 $B_1 \cdots B_n$ ，使得对于任意的 $1 \leq i < n$ 有 $B_i \leq B_{i + 1}$ ，而且使得 $ans = \max\{|A_j - B_j|,\ 1 \leq j \leq n\}$ 尽量小。

定义生成函数 $F(x) = S_a \times x^3 + S_b \times x^2 + S_c \times x + S_d$ ，则数列 $A$ 的递推公式为 $A_i = (F(A_{i - 1}) + F(A_{i - 2})) \% mod$

对于 $100\%$ 的数据，有 $n \leq 5000000,\ S_a,S_b,S_c,S_d,A_1 \leq 10000,\ mod \leq 1000000007$

[题目链接戳这里](https://www.luogu.com.cn/problem/P4105)

# **Solution**

由于时让 $ans$ 中的最大值最小，所以很容易能想到二分答案。假设现在的答案为 $k$ ，则对于所有的 $i$ 满足 $1 \leq i \leq n$ ，都有 $|A_i - B_i| \leq k$ 。也就是说，

$$A_i - k \leq B_i \leq A_i + k$$

因此我们只需每次都贪心使 $B_i$ 尽可能小即可。而如果 $B_i$ 再怎么大也大不到 $B_{i - 1}$ 时，那就说明 $k$ 不行啦！

**注意对 F 函数频繁取模！！！**

# **Code**

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 5000500;
#define int long long

int n, s[5], a[N], mod, ans, b[N];

inline int F(const int &x) {
  int res = 0;
  (res += s[1] * x % mod * x % mod * x % mod) %= mod,
  (res += s[2] * x % mod * x % mod) %= mod,
  (res += s[3] * x % mod) %= mod,
  (res += s[4] % mod) %= mod;
  return (res + mod) % mod;
}

inline bool chk(int k) {
  b[1] = a[1] - k;
  for (int i = 1; i <= n; i++) {
    if (a[i] >= b[i - 1]) b[i] = max(a[i] - k, b[i - 1]);
    else {
      if (b[i - 1] - a[i] > k) return false;
      b[i] = b[i - 1];
    }
  }
  return true;
}

signed main() {
  scanf("%lld%lld%lld%lld%lld%lld%lld", &n, &s[1], &s[2], &s[3], &s[4], &a[1], &mod);
  for (int i = 2; i <= n; i++) a[i] = (F(a[i - 1]) + F(a[i - 2])) % mod;
  int l = 0, r = mod; // 要取模，所以 r 最大也超不过 mod
  while (l <= r) {
    int mid = (l + r) >> 1;
    if (chk(mid)) r = mid - 1, ans = mid;
    else l = mid + 1;
  }
  printf("%lld\n", l % mod);
  return 0;
}
```



---

## 作者：WOL_GO (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P4105)

## 思路

对于最终的答案 $ans$，一定满足修改幅度为 $ans+1$ 也能解决问题，但修改幅度为 $ans-1$ 一定不能解决问题。所以，这题的答案具有单调性，可以用二分答案解决。

### check 思路

首先，对于一个数 $a_{i}$，假如这个数不需要修改也能解决问题，那么我们就给它改到满足题目要求的最小值，这样可以方便后续修改。如果这个数需要修改，那就判断一下这个数是否小于 $a_{i-1}-mid$，如果小于，直接返回 `false` 方可，否则把 $a_{i}$ 修改为 $a_{i-1}$。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=5e6+5;
void read(ll &xx){
    register char ch=getchar();
    register ll ans=0;
    char t=0;
    while(!isdigit(ch))t|=ch=='-',ch=getchar/*_unlocked*/();
    while(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar/*_unlocked*/();
    xx=t?-ans:ans;
    return ;
}
void write(ll x){
    if(x<0){
        putchar('-');
        x*=-1;
    }
    char wr[18];
    int cnt=1;
    if(x==0){
        putchar('0');
        putchar('\n');
        return ;
    }
    while(x){
        wr[cnt++]=x%10+'0';
        x/=10;
    }
    for(cnt--;cnt;cnt--){
        putchar(wr[cnt]);
    }
    putchar('\n');
    return;
}
ll n,sa,sb,sc,sd,mod,a[maxn],dp[maxn],b[maxn];
ll F(ll x){
    return sa%mod*x%mod*x%mod*x%mod+sb%mod*x%mod*x%mod+sc%mod*x%mod+sd%mod;
}
bool check(ll x){
    a[1]-=x;
    a[1]=max(0ll,a[1]);
    for(int i=2;i<=n;i++){
        // cout<<a[i-1]<<" "<<a[i]<<" "<<x<<"\n";
        if(a[i]>a[i-1]){
            a[i]-=min(x,a[i]-a[i-1]);
        }
        if(a[i]<a[i-1]){
            if(a[i-1]-a[i]>x)return 0;
            a[i]=a[i-1];
        }
    }
    return 1;
}
int main(){
    read(n);
    read(sa);
    read(sb);
    read(sc);
    read(sd);
    read(a[1]);
    b[1]=a[1];
    read(mod);
    for(int i=2;i<=n;i++)a[i]=(F(a[i-1])%mod+F(a[i-2])%mod)%mod,b[i]=a[i];
    ll l=1ll,r=mod,mid;
    while(l<r){
        mid=l+r>>1;
        // cout<<l<<" "<<r<<" "<<mid<<"\n";
        if(check(mid))r=mid;
        else l=mid+1;
        for(int i=1;i<=n;i++)a[i]=b[i];
    }
    write(l);
    return 0;
}
```


---

## 作者：傅思维666 (赞：0)

## 题解：

结论题。答案就是（最大逆序对的差+1）/2。

证明：假设最大逆序对的下标为$i,j$，那么对于这个区间，因为它已经是最大的逆序对了，所以不会对这个区间的答案造成影响。

然后对于它两边的区间$(1,i),(j,n)$，同理，因为已经是最大逆序对了，所以这两个区间的最大逆序对不会超过$i,j$。也就保证了答案的正确性。

代码：

```cpp
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
const int maxn=5e6+6;
int n,sa,sb,sc,sd,mod,maxx,ans;
int a[maxn];
int fun(int x)
{
    int ret=((sa*x%mod*x%mod*x%mod)+(sb*x%mod*x%mod)+(sc*x%mod)+sd%mod)%mod;
    return ret%mod;
}
signed main()
{
    scanf("%lld%lld%lld%lld%lld%lld%lld",&n,&sa,&sb,&sc,&sd,&a[1],&mod);
    for(int i=2;i<=n;i++)
        a[i]=(fun(a[i-1])%mod+fun(a[i-2])%mod)%mod;
    for(int i=1;i<=n;i++)
        if(maxx<=a[i])
            maxx=a[i];
        else
            ans=max(ans,(maxx-a[i]+1)>>1);
    printf("%lld\n",ans);
    return 0;
}
```



---

## 作者：fanfansann (赞：0)

最小化最大值，一眼就能看出来要二分。

我们先通过题目中花里胡哨的方法构造出数据，然后因为题目中修改次数无限，随意修改，我们只要求修改差值的最大值，也就是说我们只需要维护最大值即可。我们只要找到差值最大的逆序对，答案就是最大的逆序对的一半。

因为作为逆序对，前面的大于后面，差值最大的两个最终必须都要相等（因为要求最后的序列非严格单调递增，可以相等），那么我们不论是高的降低，还是低的增加，需要改的都是这个差值，肯定是一半最优。

这样我们就可以$O(n)$解决。

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<queue>

using namespace std;
typedef long long ll;
const int N=5e6+10;
int n;
ll a[N];
ll maxx;
int sa, sb, sc, sd;
ll mod;
ll res;
ll f(ll x){
    return (sa * x % mod * x % mod * x % mod + sb * x % mod * x % mod + sc * x % mod + sd) % mod;
}
int main(){
	cin >> n>> sa >> sb >> sc >> sd >> a[1] >> mod;
	maxx = a[1];
	for(int i = 2;i <= n;i ++){
		a[i] = (f(a[i-1]) + f(a[i-2])) % mod;
		res = max(res, maxx - a[i]);
		maxx = max(maxx, a[i]);
	}
	cout << (res + 1) / 2;
	return 0;
}
```


---

## 作者：Agakiss (赞：0)

### Description
[[HEOI2014]南园满地堆轻絮](https://www.luogu.org/problem/P4105)
### Solution

维护最大值的最小值，试试二分$+$贪心的套路，发现可以

二分$x$，初始$k=-INF$，使后一个数在比前一个数大的情况下尽量小，成为新的$k$，如果后一个数$+x$仍然大于$k$，则$return$ $false$
### Code
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define ll long long
#define mid ((l + r) >> 1)
#define INF 0x7fffffff
#define MAXN 5000010
ll n, Sa, Sb, Sc, Sd, MOD, l, r, ans, h;
ll a[MAXN];
inline ll read() {
	ll s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}
inline ll f(ll x) {
	return (((Sa * x % MOD * x % MOD * x % MOD + Sb * x  % MOD * x % MOD) + Sc * x) % MOD + Sd) % MOD;
}
inline bool check(ll x) {
	h = -INF;
	for (register ll i = 1; i <= n; i++) {
		if (h > a[i] + x) return false;
		h = max(h, a[i] - x);
	}
	return true;
}
int main() {
	n = read(), Sa = read(), Sb = read(), Sc = read(), Sd = read(), a[1] = read(), MOD = read();
	for (register ll i = 2; i <= n; i++)
		a[i] = (f(a[i - 1]) + f(a[i - 2])) % MOD;
	l = 0, r = MOD;
	while (l <= r) {
		if (check(mid)) ans = mid, r = mid - 1;
		else l = mid + 1;
	}
	printf("%lld", ans);
	return 0;
}
```

---


# 水の斗牛

## 题目背景

蒟蒻${\rm CYJian}$拉着${\rm JerryC}$和${\rm Justin}$等一众机房巨佬来打斗牛辣！！

## 题目描述

现在一共有$N$个人玩起了斗牛。一共玩了T局，每局有三个人参与游戏，每个人的初始分都是0。

本题为了方便，对于斗牛的基本规则做了些许变动，具体规则如下：

## 1.基本规则

每一轮斗牛开始时，每一位玩家都会拿到5张牌。

每张牌一定是一个2到10之间的整数或A(表示1)。

每张牌有一个花色，a代表黑桃，b代表红桃，c代表梅花，d代表方块。


## 2.牌型

五张牌中，除炸弹和无牛牌型以外，都分为两个部分：牛和分。其中牛包括三张点数相同(铁板)或三张点数和为10的倍数的牌，分包括剩下的两张牌，一套牌的分即为这两张牌模10的余数。

1)炸弹：四张点数相同的牌。

2)牛牛：分恰好为0。

3)牛：分不为0，分和牛数的数值相同。如分是5，则这套牌被称为牛五。

4)无牛：不存在三张牌，其点数相同或其点数和为10的倍数。

## 3.牌型大小关系

炸弹>牛牛>牛九>牛八>……>牛二>牛一>无牛

双方拥有炸弹时，炸弹点数大的更大；

相同牛数且只有一方有铁板时，有铁板的比没有铁板的大；

相同牛数且双方拥有铁板时，铁板点数大的更大；

相同牛数且双方均没有铁板或双方均无牛时，我们比较双方牌中点数最大的一张牌，点数更大的一方更大；若双方点数最大的一张牌点数相同，则花色更大的一方更大，花色大小为黑桃>红桃>梅花>方块。

## 4.计分

一局牌的底分为10，即每位玩家都会押10分。

对于其中的两位玩家，我们在比较完双方的牌型之后，选择牌型更大的一方的牌型来计算得失分数的翻倍。具体如下：

1)炸弹：底分×10。

2)牛牛：底分×3。

3)牛七/牛八/牛九：底分×2。

4)牛六~牛一：底分。

5)无牛：底分。

6)铁板：在计算完牌型得分之后，在牌型得分的基础上×2。注意铁板翻倍不与炸弹同时进行。

我们在计分时，采用两两之间计分的方式，也就是说对于三名玩家A、B、C，我们先计算A和B之间的分数得失，再计算A和C之间的分数得失，最后计算B和C之间的分数得失。

现在我们假设所有玩家都足够聪明，也就是说，所有玩家都会打出他们手上的牌中最大的牌型。${\rm CYJian}$想知道，在这T轮游戏结束之后，每位玩家的得分情况。

## 说明/提示

样例一解释：

第一局玩家牌型如下：

${\rm CYJian}$：炸弹

${\rm JerryC}$：牛五

${\rm Justin}$：铁板牛牛

所以${\rm CYJian}$加200分，${\rm JerryC}$扣160分，${\rm Justin}$扣40分。

第二局中，所有人都是牛五，但是${\rm CYJian}$拥有黑桃五，${\rm JerryC}$拥有红桃五，${\rm Justin}$拥有梅花五，所以${\rm CYJian}$加20分，${\rm JerryC}$没有变化，${\rm Justin}$扣20分。

数据范围：

| 测试点编号 |   $T$    |   $N$   | 特殊性质 |
| :--------: | :------: | :-----: | :------: |
|    $1$     |   $0$    |   $3$   |    性质4    |
|    $2$     |   $5$   |  $5$   |    性质4    |
|  $3$-$4$   |   $5$   |  $5$   |  性质1   |
|  $5$-$6$   |   $5$   |  $5$   |  性质2   |
|  $7$-$8$   |   $5$   |  $5$   |  性质3   |
|  $9$-$10$  |   $5$   |  $5$   |  性质5   |
| $11$-$12$  |   $10$    |   $10$   |  性质5   |
| $13$-$14$  |   $100$   |  $100$   |  性质5   |
| $15$-$16$  |  $1000$   |  $1000$  |  性质5   |
| $17$-$18$  |  $10000$  | $10000$  |  性质5   |
| $19$-$20$  | $100000$ | $100000$ |  性质5，1.5s   |

性质1：保证所有的人拥有炸弹。

性质2：保证每一手牌花色全部相同。

性质3：保证每一手牌所有数字不同。

性质4：保证数据手造。

性质5：保证数据随机生成。

保证每一局没有重复的牌。

保证每一个人的名字不相同。

保证出题人是${\rm CYJian}$。

保证数据没有锅。

不保证没有人能做出来。

不保证此题代码很长。

## 样例 #1

### 输入

```
0 2 3
CYJian
JerryC
Justin
CYJian
a10 b10 c10 d10 a9
JerryC
cA b2 c3 d4 d5
Justin
aA bA dA a4 c6
CYJian
aA b2 c3 d4 a5
JerryC
bA c2 d3 a4 b5
Justin
cA d2 a3 c4 c5```

### 输出

```
CYJian 220
JerryC -160
Justin -60```

## 样例 #2

### 输入

```
0 3 4
CYJian
JerryC
Samcompu
Hsl2363
CYJian
a2 b5 c8 d4 aA
Samcompu
a2 bA c3 a4 c5
JerryC
aA b2 c7 c4 c6
Hsl2363
aA bA cA dA a10
Samcompu
a2 b2 c2 d2 b10
JerryC
a3 b3 c3 d3 c10
Hsl2363
a5 c6 d8 a9 b9
JerryC
b6 b2 c9 a7 d2
CYJian
b5 d5 c5 a6 d9```

### 输出

```
CYJian 120
JerryC 150
Samcompu -60
Hsl2363 -210
```

# 题解

## 作者：Eason_AC (赞：35)

## Update
- $\texttt{2020.8.18}$ 修改了一些格式上的问题。
- $\texttt{2020.10.26}$ 新增了一个提醒。

## Content
这题不好弄题意简述啊，说个大概吧，就是 $n$ 个人玩 $T$ 局斗牛游戏，问你 $T$ 局过后 $n$ 个人的分数。

规则自己去看题目去。

**数据范围：$0\leqslant T\leqslant 100000,3\leqslant n\leqslant 100000$。**
## Gossip
这题目真的是卡了我好久，调了大概有 $1$ 天吧，反正坑点挺多的就对了。交了大概有 $20$ 多次，之前没过的时候，分数一直在 $40\sim70$之间。

我当时在讨论区里问某个点的时候，某位红名大佬还给我回复道：

![](https://cdn.luogu.com.cn/upload/image_hosting/dqs7mhoj.png)

当时我就被吓着了，什么？迷你[猪国杀](/problem/P2482)？！然而，当时我看到通过数只有可怜的 $29$，于是我就下定了决心要过了这题目。
## Solution
正如出题者 $\texttt{CYJian}$ 大神在当时的赛后题解中所述，这题目就是直接模拟，不过需要考虑很多的细节。

看目前的两篇题解都没解释清楚具体的步骤（包括但不限于直接用注释讲解），所以我在这里将具体步骤跟大家讲讲。

首先要有一个大概的框架。这个大家应该都清楚，我下面就把大致的思路图摆出来。

![](https://cdn.luogu.com.cn/upload/image_hosting/v4s8lblw.png)

没错，一场斗牛就是这四个步骤，首先我们要发牌，发到 $3$ 个人手里（一场斗牛有 $3$ 个玩家），然后再通过预处理，得到每个人的牌型，接着，两两比拼，按照规则加减分，最后将分数统计出来。

那么接下来就是细节化的问题了。

### 0 变量定义 and 注意事项
为了避免之后的过程中造成的误解，我先把每一个变量下个定义：

一位玩家有以下的系数：

- $card_j$ 表示该玩家拥有的第 $j$ 个牌的点数。
- $col_j$ 表示该玩家拥有的第 $j$ 个牌的花色。特别注意！在这里，我们默认花色用一个**大于等于 $1$ 且小于等于 $4$ 的整数**表示，并且 $1$ 代表方块，$2$ 代表梅花，$3$ 代表红桃，$4$ 代表黑桃。接下来会讲到这么做的用意。
- $num_j$ 表示该玩家拥有的点数为 $j$ 的牌的个数，接下来会讲到这么做的用意。
- $sum$ 表示该玩家拥有的所有的牌的点数之和，即为$\sum\limits_{j=1}^5card_j$。接下来会讲到这么做的用意。
- $niu$ 表示该玩家所拥有的这副牌的牛数，其中**牛牛在此处用 $10$ 表示**，牛一至牛九则用 $1\sim9$表示，至于无牛就用 $0$ 来表示。接下来会讲到这么做的用意。
- $tieban$ 表示该玩家拥有的这幅牌的铁板的点数。**没有铁板用 $0$ 表示**。
- $bomb$ 表示该玩家拥有的这幅牌的炸弹的点数，**没有炸弹用 $0$ 表示**。
- $maxx$ 表示该玩家拥有的这副牌中点数最大的牌的点数。接下来会讲到这么做的用意。
- $idd$ 表示该玩家拥有的这副牌中点数最大的牌的**最大花色**。接下来会讲到这么做的用意。
- $score$ 表示该玩家目前的分数。

还有，不保证本题解不会很长，所以请做好心理准备。

### 1 发牌
发牌是以上这四个步骤中算比较简单的一步，但是需要注意的地方也很多。

发完牌之后最重要的一步就是处理出这张牌的点数和花色。我们发现，只有点数为 $10$ 时，这张牌用题目所用的字符串中的第二个字符为 $1$；只有点数为 $1$ ，这张牌用题目所用的字符串中的第二个字符为 $\text{A}$。

所以，处理点数时，我们只需要特判上面两种情况，剩下的就直接将数字字符转换为数字了，这里想必无需多说。

花色也只需要对应存储就行。

你以为发牌到这里就完了？

那么我上面用的这么多变量岂不都是摆设了吗？

那么之后预处理该怎么办？

所以，我们需要用到上面这些变量来存储信息。具体来说，$sum$ 需要加上这张牌的点数，$num$ 将这张牌的点数在这副牌中出现的次数加 $1$，并且更新 $maxx$ 和 $idd$ 的值。尤其要注意更新 $maxx$ 和 $idd$ 的操作，就是因为这里出现了差错导致我的程序一直超不过 $70$ 分。在这里特别讲一下。

首先，我们假设手里有这样两张牌：黑桃10和红桃10，并假设红桃10是在比较之前 $maxx$ 和 $idd$ 的所属牌。那么，由于红桃10的花色比黑桃10的要小，所以肯定首选是黑桃10，用黑桃10的点数和花色信息将 $maxx$ 和 $idd$ 更新。

所以发牌的过程就模拟完了。

### 2 预处理出牌型
接下来就要预处理牌型了。

**笔者提醒：在看这一部分时强烈建议去做 P6014，这样的话可以对这一部分有更加深的理解。另外，您也可以参考 P6014 处理好这一部分的细节问题。**

根据大小顺序，我们先把炸弹处理，再把铁板和牛数一起处理。

那么这里 $num$ 就起到作用了。它直接可以判定是否有炸弹和铁板（根据定义显然可以推出来）。所以我们可以利用 $num$ 将炸弹和铁板处理出来。注意，一旦有炸弹，后面就不要再处理了，但是有铁板，千万不要立马退出，因为比较牌型的时候是按照**牛数**排序，所以我们要等在没有铁板的情况下的牛数处理完再去比较，权衡一下利弊。

那么一般情况的牛数怎么算呢？

我们都知道，$5^2=25,5^3=125$。但这有什么用呢？

我们这么想，如果我们直接枚举三个牌的点数，那么它的循环次数就是 $5^3=125$ 次，对于 $T\leqslant 100000,n\leqslant 100000$ 的数据来说有些玄，那么我们能否有减少循环次数的办法呢？

如果我们只用枚举两个牌的点数的话，循环次数就是 $5^2=25$，大大减少了时间。那么能够想到什么办法？

还记得我们之前提到的 $sum$ 吗？

这里就应该让它起作用了！

因为前面我们已经预处理出了 $sum$，所以我们直接枚举两个牌的点数，将 $sum$ 减去这两张牌的点数就是剩下三张牌的点数！

那么判断该如何呢？

设我们枚举的两张牌的点数分别是 $card_a$ 和 $card_b$。我们都知道，两个被一个数取模有相同余数的两个数相减得到的数，必定被这个模数整除。所以，我们的判断条件即为是否有 $card_a+card_b\equiv sum \pmod{10}$ 。有的话更新这个牛数。特别注意，如果 $10\mid card_a+card_b$ 的话，那么这牌就是最好的**牛牛**，我们更新牛数的时候将其更新为 $10$，这样就能和其他牛数以及无牛相区分开来了。

那么这里的牛数弄完之后，我们再和之前铁板的牛数相比较，如果铁板的牛数**大于等于**没有铁板的牛数，那么有铁板的情况肯定是最优的。这时我们将最终的牛数定为有铁板时的牛数。否则，因为我们首先要比较牛数，所以应该将没有铁板时的牛数定为最终的牛数。这里特别说明一下有铁板的牛数等于一般情况的牛数的情况。因为有铁板的话还可以翻倍，所以肯定它的牌型是比没铁板时的高的，所以我们应该选有铁板的牌型。

那么预处理牌型也弄完了。

### 3 两两比拼
这里有很多的坑点，可以说是本题的关键。

因为炸弹是最大的牌型，所以我们先比较炸弹。

因为在前面我们定义了如果没有炸弹则将 $bomb$ 记为 $0$，所以直接比较就好了，有炸弹或者炸弹大的狂加 $100$ 分，没炸弹或者炸弹小的狂扣 $100$ 分。

对于测试点 $3,4$，就相当于一个炸弹大战了。

那么炸弹比较完我们再来比较牛数。如果牛数大就是牛数大的那方赢，所以直接根据大的一方的牛数翻倍就好了，如果牛数大的那方还有铁板，分数就再 $\times2$。如果牛数相等的话，就看有没有铁板，因为没有铁板是我们也规定将 $tieban$ 变为 $0$，所以也是直接比较一下，如果一方有铁板或者铁板大就是那一方赢，并且因为TA有铁板，所以分数 $\times2$。但是如果两方都没有铁板呢？那么根据其最大的牌的点数进行比较，如果还是相等？根据花色进行比较。这里 $maxx$ 和 $idd$ 就起到了作用。如果比出来了结果，就再根据胜方的牛数进行翻倍，至于铁板……因为没有铁板就没必要再去比较了。

如果都是无牛牌型呢？题目里已经讲得很明白，就和相同牛数且均无铁板时的处理办法一样，这里不再赘述了。

那么到这里，两两比拼也结束了。

### 4 统计分数
这个倒没什么必要讲的，直接利用 $score$ 来储存分数就行，到最后一把输出完事。

---

那么这个题目到这里就讲完了，自己去代码实现的时候注意一~~亿~~些细节就好。希望我这篇题解能够帮到更多人！（鞠躬

## Code
目前我的 $5$ 个 $\color{MediumSpringGreen}\texttt{AC}$ 记录中的最优记录是 $\texttt{1.36s/26.60MB}$，在所有 $\color{MediumSpringGreen}\texttt{AC}$ 记录中排第 $4$，虽说空间占得有点多（估计是因为这么多变量的原因），但是时间上还是比较快速的。很神奇的是将这个最优的代码开 $\texttt{O2}$ 后再交居然比原来不开 $\texttt{O2}$ 还要多出 $\dfrac{1}{5}$的时间。

Orz排在我前面的三位巨佬 [$\texttt{So\underline{ }Interesting}$](https://www.luogu.com.cn/user/2889)（$\texttt{1.05s/16.37MB}$），[$\texttt{Richard\underline{ }for\underline{ }OI}$](https://www.luogu.com.cn/user/31537)（$\texttt{1.09s/11.62MB}$） 和 [$\texttt{wjyyy}$](https://www.luogu.com.cn/user/63539)（$\texttt{1.21s/12.14MB}$）（截至$\texttt{2020.8.17}$）。

（$\texttt{Update on 2020.8.18)}$

忽然发现用 $\texttt{unordered\underline{ }map}$会快很多，于是超越了 $\texttt{wjyyy}$ 巨佬。不过还是得膜TA。

引用 $\texttt{Konjacq}$ 巨佬的原文所述，``unordered_map``内部实现是``hash``表，``map``内部实现是平衡树，所以可以大大提高算法效率。

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <unordered_map>
#define F(i,a,b) for(int (i) = (a); (i) <= (b); ++(i))
using namespace std;

int useless, t, n;
struct player {
	string name;
	int card[7], num[17], col[7], sum, niu, tieban, maxx, bomb, idd;
	long long score;
	/*
		card：记每个牌的点数
		num：记每种点数出现在的牌的数量
		col：记每张牌的花色 
		sum：记所有牌点数的和 
		niu：记牌的类型
			niu=0-10 无牛、牛一至九、牛牛 
		tieban：记录铁板的点数，如果没有铁板则记为0。 
		maxx：记录所有牌中最大的点数
		bomb：记录炸弹的点数，如果没有炸弹则记为0. 
	*/
}a[100007];
unordered_map<string, int> hashmap;

inline void cle(int id) {
	memset(a[id].card, 0, sizeof(a[id].card));
	memset(a[id].num, 0, sizeof(a[id].num));
	memset(a[id].col, 0, sizeof(a[id].col));
	a[id].sum = a[id].niu = a[id].tieban = a[id].maxx = a[id].bomb = a[id].idd = 0;
}
inline void premission(int t3) {
	F(i, 1, 5) {
		string cards;
		cin >> cards;
		if(cards[1] == '1' && cards[2] == '0')	a[t3].card[i] = 10;
		else if(cards[1] == 'A')	a[t3].card[i] = 1;
		else	a[t3].card[i] = cards[1] - '0';
		a[t3].sum += a[t3].card[i];
		a[t3].num[a[t3].card[i]]++;
		if(cards[0] == 'a')	a[t3].col[i] = 4;
		if(cards[0] == 'b')	a[t3].col[i] = 3;
		if(cards[0] == 'c')	a[t3].col[i] = 2;
		if(cards[0] == 'd')	a[t3].col[i] = 1;
		if(a[t3].card[i] > a[t3].maxx) {
			a[t3].maxx = a[t3].card[i];
			a[t3].idd = a[t3].col[i]; 
		} else if(a[t3].card[i] == a[t3].maxx && a[t3].col[i] > a[t3].idd)
			a[t3].idd = a[t3].col[i];
	}
	F(i, 1, 5) {
		if(a[t3].num[a[t3].card[i]] == 4) {
			a[t3].bomb = a[t3].card[i];
			break;
		}
		if(a[t3].num[a[t3].card[i]] == 3) {
			a[t3].tieban = a[t3].card[i];
			if(!((a[t3].sum - a[t3].card[i] * 3) % 10))	a[t3].niu = 10;
			else	a[t3].niu = (a[t3].sum - a[t3].card[i] * 3) % 10;
		}
		F(j, 1, 5) {
			if(i == j)	continue;
			if((a[t3].card[i] + a[t3].card[j]) % 10 == a[t3].sum % 10) {
				int p = a[t3].niu;
				if(!((a[t3].card[i] + a[t3].card[j]) % 10))	a[t3].niu = 10;
				else	a[t3].niu = max(a[t3].niu, (a[t3].card[i] + a[t3].card[j]) % 10);
				if(a[t3].niu > p)	a[t3].tieban = 0;
			}
		}
	}
}
inline void pk(int id1, int id2) {
	int difen = 10, sf = 0;
	if(a[id1].bomb > a[id2].bomb) {
		sf = 1;
		difen *= 10;
	} else if(a[id1].bomb < a[id2].bomb) {
		sf = 2;
		difen *= 10;
	} else if(!a[id1].bomb && !a[id2].bomb) {
		if(a[id1].niu > a[id2].niu) {
			if(a[id1].niu == 10)
				difen *= 3;
			else if(a[id1].niu >= 7 && a[id1].niu <= 9)
				difen *= 2;
			else
				difen *= 1;
			if(a[id1].tieban)	difen *= 2;
			sf = 1;
		} else if(a[id1].niu < a[id2].niu) {
			if(a[id2].niu == 10)
				difen *= 3;
			else if(a[id2].niu >= 7 && a[id2].niu <= 9)
				difen *= 2;
			else
				difen *= 1;
			if(a[id2].tieban)	difen *= 2;
			sf = 2;
		} else if(a[id1].niu == a[id2].niu && a[id1].niu) {
			if(a[id1].tieban > a[id2].tieban) {
				if(a[id1].niu == 10)	difen *= 3;
				else if(a[id1].niu >= 7 && a[id1].niu <= 9)	difen *= 2;
				else	difen *= 1;
				difen *= 2;
				sf = 1;
			} else if(a[id1].tieban < a[id2].tieban){
				if(a[id2].niu == 10)	difen *= 3;
				else if(a[id2].niu >= 7 && a[id2].niu <= 9)	difen *= 2;
				else	difen *= 1;
				difen *= 2;
				sf = 2;
			} else if(a[id1].tieban == a[id2].tieban) {
				if(a[id1].maxx > a[id2].maxx)
					sf = 1;
				else if(a[id1].maxx < a[id2].maxx)
					sf = 2;
				if(sf == 1) {
					if(a[id1].niu == 10)	difen *= 3;
					else if(a[id1].niu >= 7 && a[id1].niu <= 9)	difen *= 2;
					else 	difen *= 1;
					if(a[id1].tieban)	difen *= 2;
				} else if(sf == 2) {
					if(a[id2].niu == 10)	difen *= 3;
					else if(a[id2].niu >= 7 && a[id2].niu <= 9)	difen *= 2;
					else	difen *= 1;
					if(a[id2].tieban)	difen *= 2;
				}
				else {
					if(a[id1].idd > a[id2].idd) {
						sf = 1;
						if(a[id1].niu == 10)	difen *= 3;
						else if(a[id1].niu >= 7 && a[id1].niu <= 9)	difen *= 2;
						else	difen *= 1;
						if(a[id1].tieban)	difen *= 2;
					}
					else if(a[id1].idd < a[id2].idd) {
						sf = 2;
						if(a[id2].niu == 10)	difen *= 3;
						else if(a[id2].niu >= 7 && a[id2].niu <= 9)	difen *= 2;
						else	difen *= 1;
						if(a[id2].tieban)	difen *= 2;
					}
				}
			}
		} else if(!a[id1].niu && !a[id2].niu) {
			if(a[id1].maxx > a[id2].maxx)
				sf = 1;
			else if(a[id1].maxx < a[id2].maxx)
				sf = 2;
			else {
				if(a[id1].idd > a[id2].idd)
					sf = 1;
				else if(a[id1].idd < a[id2].idd)
					sf = 2;
			}
		}
	} 
	if(sf == 1)	a[id1].score += difen, a[id2].score -= difen;
	else	a[id1].score -= difen, a[id2].score += difen; 
}

int main() {
	scanf("%d%d%d", &useless, &t, &n);
	F(i, 1, n) {
		cin >> a[i].name;
		hashmap[a[i].name] = i;
	}
	while(t--) {
		string s1, s2, s3;
		int t1, t2, t3;
		cin >> s1; t1 = hashmap[s1];
		premission(t1);
		cin >> s2; t2 = hashmap[s2];
		premission(t2);
		cin >> s3; t3 = hashmap[s3];
		premission(t3);
		pk(t1, t2);
		pk(t1, t3);
		pk(t2, t3);
		cle(t1), cle(t2), cle(t3);
	}
	F(i, 1, n) {
		cout << a[i].name;
		printf(" %lld\n", a[i].score);
	}
	return 0;
}
```

看在我写了这么多的份上，不点个赞再走嘛qwq。

---

## 作者：159号程序员 (赞：9)

$$\LARGE{Pre-knowledge}$$

- [在线与离线](https://www.luogu.com.cn/paste/8jsekoqc)

- 打擂台等基础知识

- 一个聪慧的大脑和一颗坚韧不拔的心

$$\LARGE{Solving\,idea}$$

对于大模拟，首先分析题面，大部分大模拟只要把题面看懂了，就能AC。

本题我们可以使用**在线**的方式，可以更加清晰的解决问题。

为了梳理思路，我们可以画出流程图：

$$\boxed{\text{初始化}\raisebox{9pt}{\kern{1pt}}}$$
$$\Downarrow$$
$$\boxed{\,\,\,\text{计算手牌类型
}\raisebox{9pt}{\kern{1pt}}}$$
$$\Downarrow$$
$$\boxed{\,\,\text{两两对战
}\raisebox{9pt}{\kern{1pt}}}$$
$$\Downarrow$$
$$\boxed{\text{\,\,\,输出
}\raisebox{9pt}{\kern{1pt}}}$$


大事化小，小事化了，我们通过这个流程图，一步步实现最终目标。

$$\LARGE{Solution}$$

$$\Large{Part\,1}$$

我们先实现最简单的**定义变量和程序框架**。

此程序中，我们需要三个函数：`main`、`card_calculation`、`battle`，分别为**主函数、计算手牌、对战**。

需要的变量：

- `int n, T, id, p`：$n,T,id$ 见题面，$p$ 为一局中玩家的下标。

- `string name[100100]`：存储每名玩家的姓名。

- `long long score[100100]`：存储每名玩家的分数。

- `map <string, int> hashm`：将每名玩家的姓名和分数对应。

还需要一个结构体：
```
struct player
{
    int card[5], num[10], max_color, max_card, zhadan, tieban, color[5], niu, sum;
}a[3];
```

- `card[5]`：存储每名玩家的手牌。

- `num[10]`：存储每名玩家的手牌出现的次数，用于统计炸弹和铁板。

- `max_color`：最大手牌的花色，用于比较。

- `max_card`：最大手牌，用于比较。

- `zhadan`：炸弹的点数（**没有炸弹为0**）

- `tieban`：铁板的点数（**没有铁板为0**）

- `color[5]`：每张手牌的花色。

- `niu`：牛数，**无牛为0，牛牛为10**。

- `sum`：手牌和，即为$\sum\limits_{i=1}^5card_i$。

可得到程序框架：
```cpp
#include <bits/stdc++.h>
using namespace std;
int id, n, T, p;
string name[100100];
long long score[100100];
map <string, int> hashm; // 用map将名字和分数对应

struct player // 结构体存储信息
{
  
}

void battle() // 对战
{

}

int main()
{
    cin >> id >> T >> n;
    for(int i = 0; i < n; i++)
    {
        cin >> name[i];
        hashm[name[i]] = i;
    }
    while(T--) // 回合制
    {
        
    }
    for(int i = 0; i < n; i++) cout << name[i] << " " << score[i] << endl; // 循环输出
    return 0;
}
```

$$\Large{Part\,2}$$

下面我们来完善main函数。

众所周知，一般的cin会在读到空格时中断，我们可以利用这个特性来读入手牌。

核心代码：`for(int i = 0; i < 5; i++) cin >> cards[i]; // 利用cin读到空格中断的特性，读入手牌`

但要切记，一定要更新 $p$，笔者就因为这个挂了好多次。

得到代码：

```cpp
int main()
{
    cin >> id >> T >> n;
    for(int i = 0; i < n; i++)
    {
        cin >> name[i];
        hashm[name[i]] = i;
    }
    while(T--) // 回合制
    {
        string cards[5], name1, name2, name3;
        p = 0;
        cin >> name1;
        for(int i = 0; i < 5; i++) cin >> cards[i]; // 利用cin读到空格中断的特性，读入手牌
        card_calculation(cards); // 计算手牌
        p = 1; // 记得更新p
        cin >> name2;
        for(int i = 0; i < 5; i++) cin >> cards[i];
        card_calculation(cards);
        p = 2;
        cin >> name3;
        for(int i = 0; i < 5; i++) cin >> cards[i];
        card_calculation(cards);
        battle(0, 1, hashm[name1], hashm[name2]); //两两之间对战
        battle(0, 2, hashm[name1], hashm[name3]);
        battle(1, 2, hashm[name2], hashm[name3]);
    }
    for(int i = 0; i < n; i++) cout << name[i] << " " << score[i] << endl; // 循环输出
    return 0;
}
```

$$\Large{Part\,3}$$

现在我们来完善**初始化+计算手牌**（也就是`card_calulation`）

初始化很简单，几个`memset`搞定：

```cpp
// 初始化变量
memset(a[p].card, 0, sizeof(a[p].card));
memset(a[p].num, 0, sizeof(a[p].num));
memset(a[p].color, 0, sizeof(a[p].color));
a[p].max_card = a[p].max_color = a[p].zhadan = a[p].tieban = a[p].niu = a[p].sum = 0;
```

第二步，我们来遍历手牌，记录一些手牌的信息：

```cpp
    // 遍历所有手牌，记录信息
    for(int i = 0; i < 5; i++)
    {
        switch(cards[i][0]) // 利用 switch 简洁的判断花色
        {
            case 'a' : a[p].color[i] = 4; break; // 切记加上 break
            case 'b' : a[p].color[i] = 3; break;
            case 'c' : a[p].color[i] = 2; break;
            case 'd' : a[p].color[i] = 1;
            /*
                a  黑桃  4
                b  红桃  3
                c  梅花  2
                d  方片  1
            */
        }
        if(cards[i][1] == '1' && cards[i][2] == '0') a[p].card[i] = 10; // 特判10（有两位数字）
        else if(cards[i][1] == 'A') a[p].card[i] = 1; // 特判A（为字母）
        else a[p].card[i] = cards[i][1] - '0'; // 字符串基本操作：一个 char 类型的数字 -'0' 为其表示的值
        a[p].sum += a[p].card[i]; // 更新手牌总和
        a[p].num[a[p].card[i] - 1]++; // 利用桶的思想，更新每张手牌出现的次数
        if(a[p].card[i] > a[p].max_card)
        {
            a[p].max_card = a[p].card[i]; // 打擂台更新最大手牌
            a[p].max_color = a[p].color[i]; // 切记，更新花色！
        }
        // a[p].max_card = max(a[p].max_card, a[p].card[i]) 这种写法也可以实现最终目的，但还要加上更新最大花色的步骤
        else if(a[p].card[i] == a[p].max_card && a[p].color[i] > a[p].max_color) a[p].max_color = a[p].color[i]; // 如果当前手牌与最大手牌相等，且花色大于最大花色，更新最大花色
    }
```

这里需要注意的是，巧妙地判断花色，把花色的大小关系和数字联系起来，方便计算。同时也要注意**10和A是需要特判的**。

可能有同学会问，为什么需要更新最大手牌的同时更新最大花色？

因为**手牌一样，看花色比较大小**，举个例子：考试的时候，分数一样，时间越快排名越靠前，反之亦然。**花色也是会影响最终结果的**，所以需要更新最大花色。

第三步，我们根据这些信息，来计算牛数及牌型。

```cpp
    //利用刚刚得到的手牌信息，计算牛数或手牌类型
    for(int i = 0; i < 5; i++)
    {
        if(a[p].num[a[p].card[i] - 1] == 4) // 判断炸弹
        {
            a[p].zhadan = a[p].card[i]; // 更新炸弹
            break; // 炸弹肯定要大于其它牌型（铁板牛牛才60分，炸弹都100分了）
        }
        if(a[p].num[a[p].card[i] - 1] == 3) // 判断铁板（不需要 break，因为可能会比铁板还好的情况）
        {
            a[p].tieban = a[p].card[i]; // 更新铁板
            if((a[p].sum - a[p].tieban * 3) % 10 == 0) a[p].niu = 10; // 特判牛牛
            else a[p].niu = (a[p].sum - a[p].tieban * 3) % 10; //其他情况
        }
        for(int j = 0; j < 5; j++) // 枚举组成10的倍数的两张牌，降低复杂度
        {
            if(i == j) continue; // 两张牌不能是同一张
            if((a[p].sum - a[p].card[i] - a[p].card[j]) % 10 == 0) // 剩下三张是10的倍数
            {
                int q = a[p].niu;
                if((a[p].card[i] + a[p].card[j]) % 10 == 0) a[p].niu = 10; // 特判牛牛
                else a[p].niu = max((a[p].card[i] + a[p].card[j]) % 10, a[p].niu); // 其他情况
                if(q < a[p].niu) a[p].tieban = 0; // 比铁板还好
            }
        }
    }
```

为了降低算法的复杂度，我们在最后枚举手牌相加为10的倍数时，不需要像人一样思考，直接枚举剩下的两张牌，这样复杂度就从 $O(n^3)$ 降低到 $O(n^2)$ 了。

例如 `a2 b3 a5 b5 d5` 这手牌，铁板的话为铁板牛五（$555\,23$），底分 $\times 2$，但是还可以凑出牛牛（$235\,55$），底分 $\times 3$，显然后者比前者好。所以我们在判断完铁板后，不能直接 `break`，需要进行进一步的判断。

$$\Large{Part\,4}$$

本题最富有技巧、最难的部分——`battle` 函数

首先比较炸弹，炸弹大的底分直接 $\times 10$ 再 `break`。注意两边都要判断（即判断完 `a炸弹是否大于b炸弹` 后还要判断 `b炸弹是否大于a炸弹`）

核心代码：

```cpp
if(a[p1].zhadan > a[p2].zhadan) // 比较双方炸弹
{
	bottom_score *= 10; // 炸弹底分 * 10
	winer = 1; // 更新胜方
}
```

如果双方都没有炸弹，那么比较牛数。注意，牛牛底分 $\times 3$，牛七~牛九底分 $\times 2$，其余底分不变，还有铁板的附加 $\times 2$。注意，两边还都要判断。

核心代码：

```cpp
if(a[p1].niu > a[p2].niu) // 比较牛数
{
	winer = 1; // 更新胜方
	if(a[p1].niu == 10) bottom_score *= 3; // 牛牛 底分*3
	else if(a[p1].niu <= 9 && a[p1].niu >= 7) bottom_score *= 2; // 牛七~牛九 底分*2
	else bottom_score = bottom_score; // 牛一~牛六 底分不变（*1）
	if(a[p1].tieban) bottom_score *= 2; // 铁板 底分 * 2
}
```

如果牛数依然相同且不为无牛呢？比较铁板。代码和上述的一样，只是 `if` 条件不同而已，故不放代码。

如果牛数、铁板都相同呢？比较最大手牌。如果最大手牌还是相同呢？比较最大花色。其余部分和上述基本一样。

核心代码：

```cpp
if(a[p1].max_card > a[p2].max_card) winer = 1; // 比较最大手牌
else if(a[p1].max_card < a[p2].max_card) winer = 2; // 反之亦然
if(winer == 1) // 按照上面的判断即可
{
	if(a[p1].niu == 10) bottom_score *= 3;
	else if(a[p1].niu <= 9 && a[p1].niu >= 7) bottom_score *= 2;
	else bottom_score = bottom_score;
	if(a[p1].tieban) bottom_score *= 2;
}
else if(winer == 2) // 反之亦然
{
	(基本同上，只需要修改变量名称)
}
else
{
	if(a[p1].max_color > a[p2].max_color) // 相同牛数且相同铁板且最大手牌相同判断花色大小
	{
		(依然同上)
	}
}
```

如果双方都没有牛呢？判断最大手牌及花色。

核心代码：

```cpp
if(a[p1].max_card > a[p2].max_card) winer = 1;
else if(a[p1].max_card < a[p2].max_card) winer = 2;
else
{
	if(a[p1].max_color > a[p2].max_color) winer = 1;
	else if(a[p1].max_color < a[p2].max_color) winer = 2;
}
```

最后，别忘了统计分数：

```cpp
if(winer == 1) score[place1] += bottom_score, score[place2] -= bottom_score; // 计算分数
else score[place1] -= bottom_score, score[place2] += bottom_score;
```

$$\LARGE{Summary}$$

本题的最终代码长达213行，为了不影响阅读体验，放到了[云剪贴板](https://www.luogu.com.cn/paste/rt8enn84)里，有需要的同学可以使用，但也希望大家有自己的思考。

本题我们学会了**把一个大问题分解成若干个小问题**的重要思想，这会在我们以后的编程道路中广泛运用到。

后置习题：

[P2586 [ZJOI2008]杀蚂蚁](https://www.luogu.com.cn/problem/P2586)

[P3695 CYaRon!语（笔者已AC）](https://www.luogu.com.cn/problem/P3695)

[P2482 [SDOI2010]猪国杀](https://www.luogu.com.cn/problem/P2482)

---

## 作者：cjh20090318 (赞：5)

# 题解 [P5013 水の斗牛](https://www.luogu.com.cn/problem/P5013)

校内的考试考到了这题，但是因为组题人数据错误没能过，在正确数据下过了，记录一下。

## 题意

模拟题，很简单，没什么好说的，按照题目来就行。

## 分析

梳理一下模拟题的流程：

1. 确定牌型。
2. 比较大小。
3. 胜负计分。

我们按照上面的三步流程来分析一下这道题目。

### 1. 确定牌型

#### （1）炸弹

直接在 $5$ 张牌中枚举 $4$ 张来判断点数是否相等，找到一组就立即存下来跳出循环。

#### （2）牛牛

见下面的（3）牛，根据给出的大小关系可以直接将牛牛理解为牛十。

#### （3）牛

直接在 $5$ 张牌枚举 $3$ 张牌判断点数是否相等（铁板）或相加为 $10$ 的倍数，为了让分数最大需要取最大值。

#### （4）无牛

枚举找不到满足的牛，记为牛零。

### 2. 比较大小

题目给出的关系中，牛牛大于牛九，牛一大于无牛，这就是为什么前文要将牛牛记为牛十，无牛记为牛零。

比较大小时先比较炸弹，再比较牛数，其次比较铁板，最后比较最大牌。

### 3. 胜负计分

直接根据题意，两两比较大小后判断胜负，再按照题目给出的规则更新得分即可。

模拟题具体实现就看代码吧，毕竟思路就是按照题面的顺序来。

## 代码

```cpp
//the code is from chenjh
#include<iostream>
#include<unordered_map>
#include<string>
#include<utility>
#include<vector>
#define MAXN 100005
using namespace std;
const int pn=5;//每个人的手牌数量。
int id,T,n;
string nm[MAXN];//每位玩家的名字。
unordered_map<string,int> ud;//名字对应的玩家编号。
struct PLAYER{
	pair<char,int> p[pn];//牌（花色，点数） 
	int mp;//最大的一张牌编号。
	vector<int> sp;//特殊牌型：炸弹、牛牌的编号。 
	int ss,ssp;//牌点数之和，特殊牌型点数之和。
	int niu(const int x)const{return x%10?x%10:10;}//获取牛数，如果为 0 即为牛牛。
	void init(){
		sp.clear();
		mp=ss=ssp=0;
		for(int i=0;i<pn;i++) ss+=p[i].second;//手牌点数之和。
		for(int i=1;i<pn;i++)
			if(p[i].second>p[mp].second||(p[i].second==p[mp].second&&p[i].first<p[mp].first)) mp=i;//获取最大牌。
		for(int i=0;i<pn;i++)for(int j=i+1;j<pn;j++)if(p[i].second==p[j].second)
			for(int k=j+1;k<pn;k++)if(p[i].second==p[k].second)
				for(int l=k+1;l<pn;l++)if(p[i].second==p[l].second){sp={i,j,k,l};break;}//枚举寻找炸弹。
		if(sp.empty())//如果没有找到炸弹就寻找牛。
			for(int i=0;i<pn;i++)for(int j=i+1;j<pn;j++)for(int k=j+1;k<pn;k++)
				if((!((p[i].second+p[j].second+p[k].second)%10)&&(sp.empty()||niu(ss-(p[i].second+p[j].second+p[k].second))>niu(ss-ssp)))||//牌的点数和为 10 的倍数。
				((p[i].second==p[j].second&&p[i].second==p[k].second)&&(sp.empty()||niu(ss-(p[i].second+p[j].second+p[k].second))>=niu(ss-ssp)))){//三张相同牌且点数更优。（能够取等的原因是铁板有着更为优秀的性质）
					sp={i,j,k},ssp=0;
					for(const int x:sp) ssp+=p[x].second;
				}
		ssp=0;for(const int x:sp) ssp+=p[x].second;
	}
	int BM()const{return sp.size()==4?p[sp[0]].second:0;}//判断炸弹。 
	int FE()const{return sp.size()==3&&p[sp[0]].second==p[sp[1]].second&&p[sp[1]].second==p[sp[2]].second?p[sp[0]].second:0;}//判断铁板，即三张牌点数相等。 
	int CW()const{return sp.size()==3?niu(ss-ssp):0;}//牛的分数。
	bool operator < (const PLAYER&B)const{//注意这里是重载的小于运算符。
		if(B.BM()!=BM()) return BM()<B.BM();//炸弹点数更小。
		else{
			if(CW()!=B.CW()) return CW()<B.CW();//牛数不等判断牛数大小。
			else if(CW()&&B.CW()&&FE()!=B.FE()) return FE()<B.FE();//有牛判断铁板。
			else return p[mp].second<B.p[B.mp].second||(p[mp].second==B.p[B.mp].second&&p[mp].first>B.p[B.mp].first);//都没有比较最大的牌。
		}
		return 0;
	}
}a[MAXN];
int b[MAXN];
void solve(){
	vector<int> pl(3);//当前对局的三个人。
	for(int i=0,x;i<3;i++){
		string nnm;cin>>nnm;
		x=ud[nnm];//获取到选手的编号。
		for(int j=0;j<pn;j++){
			cin>>nnm;//获取当前手牌。
			a[x].p[j]=nnm.size()==3?make_pair(nnm[0],10):make_pair(nnm[0],nnm[1]=='A'?1:nnm[1]-'0');//牌长度为 3 即点数为 10，第 2 个字符为 A 即点数为 1.
		}
		a[x].init();//初始化玩家。
		pl[i]=x;//记录对局选手编号。
	}
	for(int x=0;x<3;x++)for(int y=x+1;y<3;y++){//两两比较，计算分数得失。
		int i=pl[x],j=pl[y],d=1;
		if(a[i]<a[j]) swap(i,j);//交换后满足条件玩家 i 胜 j 负。
		if(a[i].BM()) d=10;//有炸弹底分倍数为 10。
		else{
			if(a[i].CW()==10) d=3;//牛牛倍数为 3。
			else if(7<=a[i].CW()&&a[i].CW()<=9) d=2;//牛七/牛八/牛九倍数为 2。
			else if(a[i].CW()<=6) d=1;//牛六~牛一/无牛倍数为 1.
			if(a[i].FE()) d<<=1;//单独计算铁板的翻倍。
		}
		b[i]+=d,b[j]-=d;//得失分数。
	}
}
int main(){
	ios::sync_with_stdio(false),cin.tie(nullptr);
	cin>>id>>T>>n;
	for(int i=1;i<=n;i++) cin>>nm[i],ud[nm[i]]=i;
	while(T--) solve();
	for(int i=1;i<=n;i++) cout<<nm[i]<<' '<<10*b[i]<<'\n';//乘上底分 10.
	return 0;
}

```

---

## 作者：luojun_nb (赞：4)

## 题意简述
平时玩扑克应该都摸过牛牛吧，规则基本一致。如果没玩过的话建议回去再读一遍[题目](https://www.luogu.com.cn/problem/P5013)。
## 解题思路
题目还是有点难度的，写了一下午，晚上还调了一会才  AC。题目类型和猪国杀很像，都是模拟一个简单的游戏。  

在写这种码量大的题目的时候可以先考虑在主函数里写好主体思路，函数名起好放在里面，内容可以先放放。然后就是尽量多用函数和结构体，变量名起得要让自己能认得出来，写完一个函数最好就测试一下有没有问题，不要写完了再盯着几百行代码~~调个两年半~~看半天。  

写这种时间比较宽裕的题就可以对自己好一点了,string 什么的都可以拿出来用用，有效减短代码长度，一般不会 TLE 的~~当然，是“一般不会”，除非遇到眉目出题人~~。  

**详细的过程我就写在注释里了，赶时间的可以直接看代码。**
## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
//#define int long long
#define maxn 100005
#define inf 0x3f3f3f3f
typedef struct pkp{//扑克牌  
	int hs,ds;//花色和点数 
	pkp(){
		hs=0;
		ds=0;
	}
	//朴实无华的构造函数，可以不写 
	pkp(int a,int b){
		hs=a;
		ds=b;
	}
}pkp;
typedef struct sp{//手牌：记录牌型 
	int zd;//记录有没有炸弹，因为没有点数为0的牌，所以用0标记没有炸弹 
	int fe;// Fe==铁 通俗易懂，记录方式同上 
	int cow;//懂点English的都知道，记录是牛几 
	pkp maxp;//最大的那张牌 
	sp(){
		zd=0;
		fe=0;
		cow=0;
	}
	sp(int a,int b,int c,pkp p){
		zd=a;
		fe=b;
		cow=c;
		maxp=p;
	}
	bool operator<(const sp &a)const{
		if(zd>a.zd){
			return 0;
		}
		else if(zd<a.zd){
			return 1;
		}
		if(cow>a.cow){
			return 0;
		}
		else if(cow<a.cow){
			return 1;
		}
		if(fe>a.fe){
			return 0;
		}
		else if(fe<a.fe){
			return 1;
		}
		if(maxp.ds>a.maxp.ds){
			return 0;
		}
		else if(maxp.ds<a.maxp.ds){
			return 1;
		}
		if(maxp.hs<a.maxp.hs){
			return 0;
		}
		else{
			return 1;
		}
	}//根据题意一条条地翻译就行了，既不大于也不小于的只能是相等，往下传就行了 
}sp;
map<string,int> wj;// 记录每个玩家的分数，因为私人测试点的玩家名字没有规律，用map映射 
string s1[10];//每轮人名暂存 
sp s2[10];//每轮手牌暂存
string s3[maxn];//总的人名顺序 
int tmp[10];//每轮分数暂存
int is_zd(pkp* s){//判断有没有炸弹，有的话返回点数 
	int cnt[15];//一个简单的哈希，没什么好说的 
	memset(cnt,0,sizeof(int)*15);
	for(int i=1;i<=5;i++){
		cnt[s[i].ds]++;
	}
	for(int i=1;i<=10;i++){
		if(cnt[i]==4){
			return i;
		}
	}
	return 0;
}
void fj(pkp* s,int n,sp &ans){//这个函数将在下面的fe_cow用到，可以从下面开始看 
	int is_fe=0,fe=0,cnt=0,ps=0,ns=0,db=0;
	//is_fe记录有没有铁板
	//cnt记录有几张一样的牌
	//db记录3张牌能否凑成整十
	//ps==牌数，如果不是3张就是非法枚举 
	//ns==牛数，记录在cow里面，表示是牛几 
	for(int i=1;i<=5;i++){
		if(n&1){//拆分传进来的n 
			if(fe==0){//记录有几张点数相同的牌 
				fe=s[i].ds;
				cnt++;
			}
			else{
				if(s[i].ds==fe){
					cnt++;
				}
				else if(!is_fe){
					cnt=0;
					fe=0;
				}
			}
			db+=s[i].ds;//不是铁板的情况，有铁板也不影响 
			ps++;
		}
		else{
			ns+=s[i].ds;//是剩下的两张里的，加到牛数里 
		}
		n>>=1;
	}
	if(ps!=3){
		return;
	}
	if(cnt==3){//有没有铁板 
		is_fe=1;
	}
	//cout<<"is_fe: "<<is_fe<<endl;
	//cout<<"cnt: "<<cnt<<endl;
	if(ns%10==0&&ns!=0){//牛牛记为10 
		ns=10;
	}
	else{
		ns%=10;
	}
	if(is_fe){
		if(ns>=ans.cow){//铁板比同牛数的普通牌大，可以取等号 ，换了肯定不会亏 
			ans.cow=ns;
			ans.fe=fe;
		}
	}
	if(db%10==0){
		if(ns>ans.cow){//普通牌牛数相同时乱搞可能会丢失最优解 
			ans.cow=ns;
			ans.fe=0;
		}
	}
	//没牛默认都是0，不用处理 
}
void fe_cow(pkp* s,sp &ans){//二进制枚举 
	for(int i=0;i<32;i++){
		fj(s,i,ans);
	}
}
sp js(pkp* s){//对牌组进行计算，结果存在ans里返回 
	sp ans; 
	int t1=is_zd(s);//判炸弹 
	ans.zd=t1;
	fe_cow(s,ans);//判牛数 
	return ans;
}
sp mp(){//摸牌，读取五张牌，并进行计算 
	string s;
	pkp now[10];
	pkp maxpk;
	for(int i=1;i<=5;i++){
		cin>>s;
		now[i].hs=s[0]-'a'+1;//数字小的花色大，判断的时候是个坑点 
		int len=s.size();
		if(len==3){//10是2位数，单拎出来 
			now[i].ds=10;
		}
		else{
			if(s[1]=='A'){//A也特殊处理 
				now[i].ds=1;
			}
			else{
				now[i].ds=s[1]-'0';
			}
		}
		if(now[i].ds>maxpk.ds){//找最大的牌 
			maxpk=now[i];
		}
		else if(now[i].ds==maxpk.ds){//点数一样就看花色 
			if(now[i].hs<maxpk.hs)
			maxpk=now[i];
		}
	}
	sp ans=js(now);
	ans.maxp=maxpk;
//	cout<<endl;
//	cout<<"zd: "<<ans.zd<<endl<<"fe: "<<ans.fe<<endl<<"cow: "<<ans.cow<<endl<<"maxp: "<<ans.maxp.hs<<" "<<ans.maxp.ds<<endl;
//	cout<<endl;
	return ans;//没事打印中间变量看看是个好习惯 
//	for(int i=1;i<=5;i++){
//		cout<<now[i].hs<<" "<<now[i].ds<<endl;
//	}
}
int jf(sp a){//计算倍率，按题目说的来就好了 
	int df=10;
	if(a.zd){
		return df*10;//有炸弹就不可能在翻倍了 
	}
	if(a.cow==10){
		df*=3;
	}
	else if(a.cow>=7&&a.cow<=9){
		df*=2;
	}
	if(a.fe){
		df*=2;
	}
	return df;
}
void money(int n){//刚开始题目看错了，以为每轮n个玩家都参加，照这样写的，还想了半天为什么复杂度不会超 
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){//两两博弈 
			if(s2[i]<s2[j]){
				int fs=jf(s2[j]);//翻倍以胜者为准 
				tmp[j]+=fs;
				tmp[i]-=fs;
//				cout<<endl;
//				cout<<s1[i]<<" -"<<fs<<endl;
//				cout<<s1[j]<<" +"<<fs<<endl;
//				cout<<endl;
//				cout<<endl;
//				cout<<"winer: "<<s1[j]<<endl;
//				cout<<"fs: "<<fs<<endl;
//				cout<<endl;
			}
			else{
				int fs=jf(s2[i]);
				tmp[i]+=fs;
				tmp[j]-=fs;
//				cout<<endl;
//				cout<<s1[j]<<" -"<<fs<<endl;
//				cout<<s1[i]<<" +"<<fs<<endl;
//				cout<<endl;
//				cout<<endl;
//				cout<<"winer: "<<s1[i]<<endl;
//				cout<<"fs: "<<fs<<endl;
//				cout<<endl;
			}
		}
	}
}
signed main(){
	int id,t,n;
	cin>>id>>t>>n;
	for(int i=1;i<=n;i++){
		cin>>s3[i];
	}
	for(int i=1;i<=t;i++){
		memset(tmp,0,sizeof(int)*10);//一定要记得初始化！！！ 
		for(int j=1;j<=3;j++){//每轮固定是3个人 
			cin>>s1[j];
			s2[j]=mp();
		}
		money(3);
		for(int j=1;j<=3;j++){//把分数结算到对应的玩家头上 
			wj[s1[j]]+=tmp[j];
		}
	}
	for(int i=1;i<=n;i++){
		cout<<s3[i]<<" ";
		cout<<wj[s3[i]]<<"\n";
	}
	return 0;//愉快的结束了，完美AC 
}
```
## 后记
这道题比起别的毒瘤题目还是好多了，没有什么大的坑点。适合锻炼码力，从颓废中找回自己。

---

## 作者：高木木 (赞：3)

写这个题不会, 想搞明白却看不到题解是很难受的QAQ所以我来上传第一篇15kb题解。。。

鉴于本题是个大模拟，注释就不怎么详细。。给和我一样的人提供一个思路。。

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<map>
#define ll long long
using namespace std;
inline void read(ll &x)
{
    x=0;ll p=1;
    char c=getchar();
    while(c<'0'||c>'9')
    {
        if(c=='-') p=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9')
    {
        x=x*10+c-'0';
        c=getchar();
    }
    x*=p;
}
map<string,ll>q;
map<char,ll>p;
ll id,t,n,c[21];
struct node
{
    string name;
    long long num=0,num1=0,num2=0,num3;// num记录最大的牌，num1记录花色，num2记录当有牛且牛数、铁板数相同时最大牌的大小，num3记录铁板的大小
    long long dscore=0;// dscore记录牌的分数
    bool vis=0,vis1=0,vis3=0;// vis判断有无炸弹，vis1判断有无牛，vis3判断有无铁板。
}a[100001];
struct node1
{
    long long num;
    char flower;
};
inline void write()
{
    p['a']=10,p['b']=9,p['c']=8,p['d']=7;
    read(id),read(t),read(n);
    for(ll i=1;i<=n;i++)
    {
        cin>>a[i].name;
        q[a[i].name]=i;
    }
    while(t--)
    {
        node d[4];
        for(ll j=1;j<=3;j++)
        {
            memset(c,0,sizeof(c));
            string s;
            cin>>s;
            d[j].name=s;
            node1 f[6];
            ll sum=0,sum1=0,sum3=0;
            for(ll i=1;i<=5;i++)
            {
                char s1[5];
                cin>>s1;ll k;
                char b=s1[0];
                if(s1[1]=='A') k=1;
                else
                {
                	if(s1[2]=='0') k=10;
                	else k=s1[1]-'0';
                }
                sum3+=k;
                if(k>=sum)
                {
                    if(k==sum) sum1=max(sum1,p[b]);
                    else sum=k,sum1=p[b];
                }
                c[k]++;
                f[i].flower=b;f[i].num=k;
                if(c[k]==4)
                {
                    d[j].vis=1;
                    d[j].num=k;
                }
                if(c[k]==3)
                {
                    d[j].vis1=1;
                    d[j].vis3=1;
                    d[j].num3=k;
                }
            }
            if(d[j].vis)// 炸弹直接 跳过 
            {
                continue;
            }
            if(d[j].vis1)// ¡§?D¡§?¡§2???¡§o?¨¤ 
            {
            	for(ll i=1;i<=5;i++)
            	{
            		for(ll k=1;k<=5;k++)
            		{
            			if(i!=k&&c[f[i].num]!=3&&c[f[k].num]!=3)
            			{
            				long long ans2;
            				if((f[i].num+f[k].num)%10==0) ans2=100;
            				else ans2=(f[i].num+f[k].num)%10;
            				d[j].num=max(d[j].num,ans2);
                        }
                    }
                }
            }
            for(ll i=1;i<=5;i++)
            for(ll k=1;k<=5;k++)
           	{
            	if(i!=k&&(sum3-f[i].num-f[k].num)%10==0)
            	{
            		d[j].vis1=1;
            		ll ans2;
            		if((f[i].num+f[k].num)%10==0) ans2=100;
            		else ans2=(f[i].num+f[k].num)%10;
            		if(d[j].num<ans2)
            		{
            			d[j].num=ans2;
            			d[j].vis3=0;
                    }
                }
            }
            d[j].num2=sum;
            d[j].num1=sum1;
            if(d[j].vis1) continue ;
            if(!d[j].vis&&!d[j].vis1)
            {
                d[j].num=sum;
                d[j].num1=sum1;
                continue;
            }
        }
        // 开始比较两个人牌的大小：
        for(ll i=1;i<3;i++)
        {
            for(ll k=i+1;k<=3;k++)
            {
                if(d[i].vis)// i的牌中有炸弹
                {
                    if(d[k].vis)// k的牌中也有炸弹，那么就按炸弹的比较方法和得分方法来比较
                    {
                        if(d[i].num>d[k].num)
                        {
                            ll ans=10,op,op1;
                            op=q[d[i].name];op1=q[d[k].name];
                            a[op].dscore+=ans*10;
                            a[op1].dscore-=ans*10;
                        }
                        if(d[i].num<d[k].num)
                        {
                            ll ans=10,op,op1;
                            op=q[d[i].name];op1=q[d[k].name];
                            a[op1].dscore+=ans*10;
                            a[op].dscore-=ans*10;
                        }
                    }
                    if(!d[k].vis)// k中没有炸弹，那么肯定是i大，i直接加分就好了
                    {
                        ll ans=10,op,op1;
                        op=q[d[i].name];op1=q[d[k].name];
                        a[op].dscore+=ans*10;
                        a[op1].dscore-=ans*10;
                    }
                    continue ;
                }
                if(d[i].vis1)// i有牛
                {
                	if(d[k].vis)// k有炸弹，k大，直接给k加分
                	{
                		ll ans=10;
                        ll op,op1;
                        op=q[d[i].name];op1=q[d[k].name];
                        a[op].dscore-=ans*10;
                        a[op1].dscore+=ans*10;
                        continue;
                    }
                	if(d[k].vis1)// k也有牛
                	{
                		if(d[i].num>d[k].num)// 先比较牛数，牛数大的给加分
                        {
                            ll ans=10,ans1=1;
                            if(d[i].vis3) ans1=2;
                        	if(d[i].num==100) ans1*=3;
                        	else if(d[i].num<=9&&d[i].num>=7) ans1*=2;
                        	ll op,op1;
                        	op=q[d[i].name];op1=q[d[k].name];
                            a[op].dscore+=ans*ans1;
                            a[op1].dscore=a[op1].dscore-ans*ans1;
                        }
                        if(d[i].num<d[k].num)
                        {
                            ll ans=10,ans1=1;
                            if(d[k].vis3) ans1=2;
                        	if(d[k].num==100) ans1*=3;
                        	else if(d[k].num<=9&&d[k].num>=7) ans1*=2;
                        	ll op,op1;
                        	op=q[d[i].name];op1=q[d[k].name];
                            a[op].dscore-=ans*ans1;
                            a[op1].dscore+=ans*ans1;
                        }
                        if(d[i].num==d[k].num)// 牛数相同时比较有无铁板，有铁板的直接加分
                        {
                        	if(d[i].vis3&&!d[k].vis3)
                        	{
                        		ll ans=10,ans1=1;
                                if(d[i].vis3) ans1=2;
                        		if(d[i].num==100) ans1*=3;
                        		else if(d[i].num<=9&&d[i].num>=7) ans1*=2;
                        		ll op,op1;
                        		op=q[d[i].name];op1=q[d[k].name];
                            	a[op].dscore+=ans*ans1;
                            	a[op1].dscore-=ans*ans1;
							}
							if(!d[i].vis3&&d[k].vis3)
							{
								ll ans=10,ans1=1;
                                if(d[k].vis3) ans1=2;
                        		if(d[k].num==100) ans1*=3;
                        		else if(d[k].num<=9&&d[k].num>=7) ans1*=2;
                        		ll op,op1;
                        		op=q[d[i].name];op1=q[d[k].name];
                            	a[op].dscore-=ans*ans1;
                            	a[op1].dscore+=ans*ans1;
							}
							if(d[i].vis3&&d[k].vis3)// 都有铁板时先比较铁板数
							{
								if(d[i].num3>d[k].num3)
								{
									ll ans=10,ans1=1;
                                	if(d[i].vis3) ans1=2;
                        			if(d[i].num==100) ans1*=3;
                        			else if(d[i].num<=9&&d[i].num>=7) ans1*=2;
                        			ll op,op1;
                        			op=q[d[i].name];op1=q[d[k].name];
                            		a[op].dscore+=ans*ans1;
                            		a[op1].dscore-=ans*ans1;
								}
								if(d[i].num3<d[k].num3)
								{
									ll ans=10,ans1=1;
                                	if(d[k].vis3) ans1=2;
                        			if(d[k].num==100) ans1*=3;
                        			else if(d[k].num<=9&&d[k].num>=7) ans1*=2;
                        			ll op,op1;
                        			op=q[d[i].name];op1=q[d[k].name];
                            		a[op].dscore-=ans*ans1;
                            		a[op1].dscore+=ans*ans1;
								}
								if(d[i].num3==d[k].num3)// 铁板数相同比较最大牌的大小
								{
									if(d[i].num2>d[k].num2)
	                        		{
	                        			ll ans=10,ans1=1;
	                               	 	if(d[i].vis3) ans1=2;
	                        			if(d[i].num==100) ans1*=3;
	                        			else if(d[i].num<=9&&d[i].num>=7) ans1*=2;
	                        			ll op,op1;
	                        			op=q[d[i].name];op1=q[d[k].name];
	                            		a[op].dscore+=ans*ans1;
	                            		a[op1].dscore-=ans*ans1;
	                            	}
	                            	if(d[i].num2<d[k].num2)
	                            	{
	                               	 	ll ans=10,ans1=1;
	                                	if(d[k].vis3) ans1=2;
	                        			if(d[k].num==100) ans1*=3;
	                        			else if(d[k].num<=9&&d[k].num>=7) ans1*=2;
	                        			ll op,op1;
	                        			op=q[d[i].name];op1=q[d[k].name];
	                            		a[op].dscore-=ans*ans1;
	                            		a[op1].dscore+=ans*ans1;
	                            	}
	                            	if(d[i].num2==d[k].num2)// 最大牌也相同比较花色
	                            	{
	                                	if(d[i].num1>d[k].num1)
	                                	{
	                                    	ll ans=10,ans1=1;
	                                    	if(d[i].vis3) ans1=2;
	                        				if(d[i].num==100) ans1*=3;
	                        				else if(d[i].num<=9&&d[i].num>=7) ans1*=2;
	                        				ll op,op1;
	                        				op=q[d[i].name];op1=q[d[k].name];
	                            			a[op].dscore+=ans*ans1;
	                            			a[op1].dscore-=ans*ans1;
	                                	}
	                                	if(d[i].num1<d[k].num1)
	                                	{
	                                	    ll ans=10,ans1=1;
	                                    	if(d[k].vis3) ans1=2;
	                        				if(d[k].num==100) ans1*=3;
	                        				else if(d[k].num<=9&&d[k].num>=7) ans1*=2;
	                        				ll op,op1;
	                        				op=q[d[i].name];op1=q[d[k].name];
	                            			a[op].dscore-=ans*ans1;
	                            			a[op1].dscore+=ans*ans1;
	                                	}
	                            	}
								}	
							}
							if(!d[i].vis3&&!d[k].vis3)// 双方都没有铁板直接比较最大的牌
							{
								if(d[i].num2>d[k].num2)
	                        	{
	                        		ll ans=10,ans1=1;
	                                if(d[i].vis3) ans1=2;
	                        		if(d[i].num==100) ans1*=3;
	                        		else if(d[i].num<=9&&d[i].num>=7) ans1*=2;
	                        		ll op,op1;
	                        		op=q[d[i].name];op1=q[d[k].name];
	                            	a[op].dscore+=ans*ans1;
	                            	a[op1].dscore-=ans*ans1;
	                            }
	                            if(d[i].num2<d[k].num2)
	                            {
	                                ll ans=10,ans1=1;
	                                if(d[k].vis3) ans1=2;
	                        		if(d[k].num==100) ans1*=3;
	                        		else if(d[k].num<=9&&d[k].num>=7) ans1*=2;
	                        		ll op,op1;
	                        		op=q[d[i].name];op1=q[d[k].name];
	                            	a[op].dscore-=ans*ans1;
	                            	a[op1].dscore+=ans*ans1;
	                            }
	                            if(d[i].num2==d[k].num2)// 最大的牌也相同比较花色
	                            {
	                                if(d[i].num1>d[k].num1)
	                                {
	                                    ll ans=10,ans1=1;
	                                    if(d[i].vis3) ans1=2;
	                        			if(d[i].num==100) ans1*=3;
	                        			else if(d[i].num<=9&&d[i].num>=7) ans1*=2;
	                        			ll op,op1;
	                        			op=q[d[i].name];op1=q[d[k].name];
	                            		a[op].dscore+=ans*ans1;
	                            		a[op1].dscore-=ans*ans1;
	                                }
	                                if(d[i].num1<d[k].num1)
	                                {
	                                    ll ans=10,ans1=1;
	                                    if(d[k].vis3) ans1=2;
	                        			if(d[k].num==100) ans1*=3;
	                        			else if(d[k].num<=9&&d[k].num>=7) ans1*=2;
	                        			ll op,op1;
	                        			op=q[d[i].name];op1=q[d[k].name];
	                            		a[op].dscore-=ans*ans1;
	                            		a[op1].dscore+=ans*ans1;
	                                }
	                            }
							}
                        	
                        }
                        continue;
                    }
                    ll ans=10,ans1=1;
                    if(d[i].vis3) ans1=2;
                    if(d[i].num==100) ans1*=3;
                    else if(d[i].num<=9&&d[i].num>=7) ans1*=2;
                    ll op,op1;
                    op=q[d[i].name];op1=q[d[k].name];
                    a[op].dscore+=ans*ans1;
                    a[op1].dscore-=ans*ans1;
                    continue;
                }

                if(d[k].vis)// k有炸弹i无炸弹 直接给k加
                {
                    ll ans=10;
                    ll op,op1;
                    op=q[d[i].name];op1=q[d[k].name];
                    a[op].dscore-=ans*10;
                    a[op1].dscore+=ans*10;
                    continue;
                }
                if(d[k].vis1)// k有牛i无牛
                {
                    ll ans=10,ans1=1;
                    if(d[k].vis3) ans1=2;
                    if(d[k].num==100) ans1*=3;
                    else if(d[k].num<=9&&d[k].num>=7) ans1*=2;
                    ll op,op1;
                    op=q[d[i].name];op1=q[d[k].name];
                    a[op].dscore-=ans*ans1;
                    a[op1].dscore+=ans*ans1;
                    continue;
                }
                if(!d[i].vis&&!d[k].vis1&&!d[i].vis1&&!d[k].vis)// 都没有牛和炸弹，硬比较就行了
                {
                    if(d[i].num>d[k].num)
                    {
                        ll ans=10;
                        ll op,op1;
                        op=q[d[i].name];op1=q[d[k].name];
                        a[op].dscore+=ans;
                        a[op1].dscore-=ans;
                    }
                    if(d[i].num<d[k].num)
                    {
                        ll ans=10;
                        ll op,op1;
                        op=q[d[i].name];op1=q[d[k].name];
                        a[op1].dscore+=ans;
                        a[op].dscore-=ans;
                    }
                    if(d[i].num==d[k].num)
                    {
                        if(d[i].num1>d[k].num1)
                        {
                            ll ans=10;
                            ll op,op1;
                        	op=q[d[i].name];op1=q[d[k].name];
                            a[op].dscore+=ans;
                            a[op1].dscore-=ans;
                        }
                        if(d[i].num1<d[k].num1)
                        {
                            ll ans=10;
                            ll op,op1;
                        	op=q[d[i].name];op1=q[d[k].name];
                            a[op1].dscore+=ans;
                            a[op].dscore-=ans;
                        }
                    }
                }
            }
        }
    }
    for(ll i=1;i<=n;i++) cout<<a[i].name<<' '<<a[i].dscore<<endl;
}
int main()
{
    write();
    return 0;
}
```
~~400多行累死本蒟蒻~~

还是要感谢出题人 [暮雪﹃紛紛](https://www.luogu.org/space/show?uid=20782) 和讨论区一些人的指导，再者由于代码太多，注释可能会有所遗漏，望发现者及时指出，thanks！


---

## 作者：BMTXLRC (赞：2)

$\texttt{P.S.}$ 此题我发现有人抄题解（

点名表扬 $\texttt{sw05\_lijinying}$，$\texttt{雷痕小祥}$。

[博客食用可能会更佳（](https://www.luogu.com.cn/blog/BMTX/p5013-shui-dou-niu)

### Part 1: 输入
------------
输入直接用 $\texttt{cin}$ 输入字符串即可，在这里我们用一个 $\texttt{map}$ 来存储所有人的名字。（我的代码中定义 $card_{i,j}$ 为第 $i$ 个人的第 $j$ 张牌）。
### Part 2: 牌的预处理
------------
用一个结构体来存储每个人的牌的属性，包括每张牌的点数，花色，以及这套牌究竟是怎样的一副牌。

首先看花色的处理，$type_{i,j}$ 表示第 $i$ 个人的第 $j$ 张牌的花色。可以直接用已获得的字符转成数字，但考虑到之后可能有一个比较花色的环节，我们用 $5$ 减去我们已获得的花色。

（注意字符串从 $0$ 开始啊啊啊）

```cpp
a[i].type[j]=5-(card[i][j][0]-'a'+1);
```
再看每张牌的点数，分为三种情况：

- 此牌为 $\texttt{A}$，`a[i].score[j]=1;`

- 此牌为 $\texttt{10}$，`a[i].score[j]=10;`

- 此牌既不是 $\texttt{A}$ 也不是 $\texttt{10}$，`a[i].score[j]=card[i][j][1]-'0';`

那么这一段的代码自然就出来了，用 $\texttt{if}$ 讨论即可。

```cpp
if(card[i][j][1]=='1'&&card[i][j][2]=='0') a[i].score[j]=10;
else if(card[i][j][1]=='A') a[i].score[j]=1;
else a[i].score[j]=card[i][j][1]-'0';
```
最后是关于这五张牌的处理，包括五张牌的点数和 $sum$，五张牌中最大的牌 $maxn$，以及五张牌中最大的牌的花色 $maxc$。

$sum$ 很好处理，关键在于 $maxn$ 和 $maxc$。如果判断不对极有可能导致 $95$ 分。（$95$ 分的同学看这里啊）

更新最大牌分为两种情况：

- 此牌比我已经记下的最大牌要大；

- 此牌跟我已经记下的最大牌一样大，但花色比我最大牌要大；

此时最好不要用两个 $\texttt{if}$ 进行讨论（尽管我没试过是不是错的）。

```cpp
if(a[i].score[j]>a[i].maxn){
	a[i].maxn=a[i].score[j];
	a[i].maxc=a[i].type[j];
}else if(a[i].score[j]==a[i].maxn&&a[i].type[j]>a[i].maxc) a[i].maxc=a[i].type[j];
```

牌的处理包括桶排这一部分，因为我不能暴力枚举五张牌是否存在炸弹或者板子，时间复杂度会很大，所以在这里我们加上一个地方，进行桶排。（记 $b_i$ 为 $i$ 这个数存在了多少次）

```cpp
a[i].b[a[i].score[j]]++;
```
至此，我们每张牌的预处理就搞定了。下面放下这一部分的代码：

```cpp
void work_card(){
	for(register int i=1;i<=3;i++){
		for(register int j=1;j<=5;j++){
			a[i].type[j]=5-(card[i][j][0]-'a'+1);
			if(card[i][j][1]=='1'&&card[i][j][2]=='0') a[i].score[j]=10;
			else if(card[i][j][1]=='A') a[i].score[j]=1;
			else a[i].score[j]=card[i][j][1]-'0';
			a[i].sum+=a[i].score[j];
			if(a[i].score[j]>a[i].maxn){
				a[i].maxn=a[i].score[j];
				a[i].maxc=a[i].type[j];
			}else if(a[i].score[j]==a[i].maxn&&a[i].type[j]>a[i].maxc) a[i].maxc=a[i].type[j];
			a[i].b[a[i].score[j]]++;
		}
	}
}
```
### Part 3: 牌型的处理
------------

炸弹优先于其他牌型，所以先判炸弹。

比较简单，看每一张牌所属的桶有多少元素即可。

```cpp
for(register int i=1;i<=3;i++){
	for(register int j=1;j<=5;j++){
		if(a[i].b[a[i].score[j]]==4){
			a[i].bomb=a[i].score[j];
			break;
		}
	}
}
```
接下来是板子，跟炸弹类似，看每一张牌所属的桶，如果有 $3$ 个，那么进行讨论：

- 剩下两张牌加起来为 $10$，此牌牌型为牛十；

- 剩下两张牌加起来不为 $10$，就是其他的牌型。

我们定义 $board$ 为此牌的板子点数，之后比较是用得上的。

```cpp
for(register int i=1;i<=3;i++){
	for(register int j=1;j<=5;j++){
		if(a[i].b[a[i].score[j]]==3){
			a[i].board=a[i].score[j];
			if((a[i].sum-a[i].score[j]*3)%10==0) a[i].niu=10;
			else a[i].niu=(a[i].sum-a[i].score[j]*3)%10;
		}
	}
}
```
最后就是正常牛的处理。

由于枚举三张牌，看其加起来是否为 $10$ 的倍数时间复杂度太大，我们将问题转为枚举两张牌，看剩下的三张牌是否为 $10$ 的倍数。

注意如果我们找到了存在这样的三张牌，我们先定义 $x$ 为当前的牛数，之后如果更新了 $x$，就将 $board$ 设为 $0$。因为牌型变得更好了。

这一部分应该不难（

```cpp
void work_cow(){
	for(register int i=1;i<=3;i++){
		for(register int j=1;j<=5;j++){
			if(a[i].b[a[i].score[j]]==4){
				a[i].bomb=a[i].score[j];
				break;
			}
			if(a[i].b[a[i].score[j]]==3){
				a[i].board=a[i].score[j];
				if((a[i].sum-a[i].score[j]*3)%10==0) a[i].niu=10;
				else a[i].niu=(a[i].sum-a[i].score[j]*3)%10;
			}
			for(register int k=1;k<=5;k++){
				if(j==k) continue;
				if((a[i].sum-a[i].score[j]-a[i].score[k])%10==0){
					int x=a[i].niu;
					if((a[i].score[j]+a[i].score[k])%10==0) a[i].niu=10;
					else a[i].niu=max(a[i].niu,(a[i].score[j]+a[i].score[k])%10);
					if(a[i].niu>x) a[i].board=0;
				}
			}
		}
	}
}
```
### Part 4: 两两对战
------------

用 $win$ 表示谁赢，用 $p$ 表示底分，这是会翻倍的。

翻倍有规则，我们定义一个超级加倍函数（

根据题意：

- 胜者牛数为 $10$，`p*=3;`

- 胜者牛数介于 $7$ 和 $9$ 之间，`p*=2;`

- 胜者如果存在板子，`p*=2;`

然后就直接讨论吧（

- 如果 $x$ 的炸弹大于 $y$ 的炸弹 `p*=10,win=x;`

- 如果 $y$ 的炸弹大于 $x$ 的炸弹 `p*=10,win=y;`

- 如果 $x$ 的炸弹等于 $y$ 的炸弹

	- 如果 $x$ 的牛数大于 $y$ 的牛数
    
    - 如果 $y$ 的牛数大于 $x$ 的牛数
    
    - 如果 $x$ 的牛数等于 $y$ 的牛数
    
    	- 如果 $x$ 的板子大于 $y$ 的板子
        
        - 如果 $y$ 的板子大于 $x$ 的板子
        
        - 如果 $x$ 的板子等于 $y$ 的板子
        
        	- 如果 $x$ 的最大牌大于 $y$ 的最大牌
            
            - 如果 $y$ 的最大牌大于 $x$ 的最大牌
            
            - 如果 $x$ 的最大牌等于 $y$ 的最大牌
            	
                - 如果 $x$ 的最大牌花色大于 $y$ 的最大牌花色
                
                - 如果 $y$ 的最大牌花色大于 $x$ 的最大牌花色
                
	- 如果 $x$ 赢，`CJJB(x);`
    
    - 如果 $y$ 赢，`CJJB(y);`（此处是因为炸弹加倍不与其他加倍同时进行）
                
没啥细讲的，用 $\texttt{if}$ 判断就行了。

```cpp
void CJJB(int win){
	if(a[win].niu==10) p*=3;
	else if(a[win].niu>=7&&a[win].niu<=9) p*=2;
	if(a[win].board!=0) p*=2;
}
void work_PK(int x,int y,int u,int v){
	p=10;int win=0;
	if(a[x].bomb>a[y].bomb) p*=10,win=x;
	else if(a[y].bomb>a[x].bomb) p*=10,win=y;
	else if(a[x].bomb==0&&a[y].bomb==0){
		if(a[x].niu>a[y].niu) win=x;
		else if(a[y].niu>a[x].niu) win=y;
		else if(a[x].niu==a[y].niu){
			if(a[x].board>a[y].board) win=x;
			else if(a[y].board>a[x].board) win=y;
			else if(a[x].board==a[y].board){
				if(a[x].maxn>a[y].maxn) win=x;
				else if(a[y].maxn>a[x].maxn) win=y;
				else if(a[x].maxn==a[y].maxn){
					if(a[x].maxc>a[y].maxc) win=x;
					if(a[y].maxc>a[x].maxc) win=y;
				}
			}
		}
		if(win==x) CJJB(x);
		if(win==y) CJJB(y);
	}
	if(win==x) ans[u]+=p,ans[v]-=p;
	if(win==y) ans[v]+=p,ans[u]-=p;
}
```
### Part 5: 最后的输出处理以及一些小坑
------------

用 $\texttt{map}$ 做好处理，千万别搞错了，不要把得分存到 $\texttt{map}$ 里。

坑：

- 每回合 $\texttt{memset}$ 了吗？

- 你调用了函数吗？（也只有我犯这种错误了）

- 你枚举两张牌的时候，板子考虑清空了吗？

- 你的花色处理对了吗？

总代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int id,T,n,p,ans[N];
string card[6][6],s[N];
struct CARD{
	int score[6],b[15],maxn,maxc;
	int type[6],sum,bomb,board,point,niu;
}a[10];
void work_card(){
	for(register int i=1;i<=3;i++){
		for(register int j=1;j<=5;j++){
			a[i].type[j]=5-(card[i][j][0]-'a'+1);
			if(card[i][j][1]=='1'&&card[i][j][2]=='0') a[i].score[j]=10;
			else if(card[i][j][1]=='A') a[i].score[j]=1;
			else a[i].score[j]=card[i][j][1]-'0';
			a[i].sum+=a[i].score[j];
			if(a[i].score[j]>a[i].maxn){
				a[i].maxn=a[i].score[j];
				a[i].maxc=a[i].type[j];
			}else if(a[i].score[j]==a[i].maxn&&a[i].type[j]>a[i].maxc) a[i].maxc=a[i].type[j];
			a[i].b[a[i].score[j]]++;
		}
	}
}
void work_cow(){
	for(register int i=1;i<=3;i++){
		for(register int j=1;j<=5;j++){
			if(a[i].b[a[i].score[j]]==4){
				a[i].bomb=a[i].score[j];
				break;
			}
			if(a[i].b[a[i].score[j]]==3){
				a[i].board=a[i].score[j];
				if((a[i].sum-a[i].score[j]*3)%10==0) a[i].niu=10;
				else a[i].niu=(a[i].sum-a[i].score[j]*3)%10;
			}
			for(register int k=1;k<=5;k++){
				if(j==k) continue;
				if((a[i].sum-a[i].score[j]-a[i].score[k])%10==0){
					int x=a[i].niu;
					if((a[i].score[j]+a[i].score[k])%10==0) a[i].niu=10;
					else a[i].niu=max(a[i].niu,(a[i].score[j]+a[i].score[k])%10);
					if(a[i].niu>x) a[i].board=0;
				}
			}
		}
	}
}
void CJJB(int win){
	if(a[win].niu==10) p*=3;
	else if(a[win].niu>=7&&a[win].niu<=9) p*=2;
	if(a[win].board!=0) p*=2;
}
void work_PK(int x,int y,int u,int v){
	p=10;int win=0;
	if(a[x].bomb>a[y].bomb) p*=10,win=x;
	else if(a[y].bomb>a[x].bomb) p*=10,win=y;
	else if(a[x].bomb==0&&a[y].bomb==0){
		if(a[x].niu>a[y].niu) win=x;
		else if(a[y].niu>a[x].niu) win=y;
		else if(a[x].niu==a[y].niu){
			if(a[x].board>a[y].board) win=x;
			else if(a[y].board>a[x].board) win=y;
			else if(a[x].board==a[y].board){
				if(a[x].maxn>a[y].maxn) win=x;
				else if(a[y].maxn>a[x].maxn) win=y;
				else if(a[x].maxn==a[y].maxn){
					if(a[x].maxc>a[y].maxc) win=x;
					if(a[y].maxc>a[x].maxc) win=y;
				}
			}
		}
		if(win==x) CJJB(x);
		if(win==y) CJJB(y);
	}
	if(win==x) ans[u]+=p,ans[v]-=p;
	if(win==y) ans[v]+=p,ans[u]-=p;
}
map<string,int> m;
int main(){
	scanf("%d %d %d",&id,&T,&n);
	for(register int i=1;i<=n;i++) cin>>s[i],m[s[i]]=i;
	while(T--){
		string x,y,z;
		memset(a,0,sizeof(a));
		cin>>x;for(register int i=1;i<=5;i++) cin>>card[1][i];
		cin>>y;for(register int i=1;i<=5;i++) cin>>card[2][i];
		cin>>z;for(register int i=1;i<=5;i++) cin>>card[3][i];
		work_card(),work_cow();
		work_PK(1,2,m[x],m[y]),work_PK(1,3,m[x],m[z]),work_PK(2,3,m[y],m[z]);
	}
	for(register int i=1;i<=n;i++) cout<<s[i],printf(" %d\n",ans[i]);
}
```


---

## 作者：Konnyaku_ljc (赞：2)

## 赶时间的请跳过前150行，第一个代码65pt，第二个AC且解释比较详细
毕竟都是废话

做这道题做了好久……忽然发现有了一篇题解！！！  
非常开心！！！！！！！  
然而…… =_=  四百三十六行的题解真心看不懂  
强烈谴责出题人的不负责任的不给数据点下载

开始，我的代码是这样的

### 暴力初始版
```cpp
#include<bits/stdc++.h>
using namespace std;
int ID,t,n,ssum=1;
string ss;
struct bb{//人名与分数
    string ks;
    int aans;
}b[100005];
struct aa{//各人牌型
    string s;
    int aa[10],bb[10];
    int c,d,e,f,id;//c是牛数，炸弹是11，d是最大值，e是花色，f是铁板判断，id是分数
}a[500005];
void check(int x)//搜状态
{
    a[x].d=max(a[x].bb[1],a[x].bb[2]);
    a[x].d=max(a[x].d,a[x].bb[3]);
    a[x].d=max(a[x].d,a[x].bb[4]);
    a[x].d=max(a[x].d,a[x].bb[5]);//最大数
    for(int i=1;i<=5;i++)
    {
        if(a[x].bb[i]==a[x].d)
        {
            a[x].e=max(a[x].e,a[x].aa[i]);//最大花色
        }
    }
    for(int i=1;i<=5;i++)//一个一个来，总次数少，但3/4层循环
    {
        for(int j=i+1;j<=5;j++)
        {
            for(int k=j+1;k<=5;k++)
            {
                for(int l=k+1;l<=5;l++)
                {
                    if(a[x].bb[i]==a[x].bb[j]&&a[x].bb[j]==a[x].bb[k]&&a[x].bb[k]==a[x].bb[l])//炸弹
                    {
                        a[x].c=11,a[x].d=a[x].bb[i],a[x].f=0;//结束搜
                    }
                }
                if(a[x].bb[i]==a[x].bb[j]&&a[x].bb[j]==a[x].bb[k])//铁板
                {
                    int sum=(a[x].bb[1]+a[x].bb[2]+a[x].bb[3]+a[x].bb[4]+a[x].bb[5]-a[x].bb[i]-a[x].bb[j]-a[x].bb[k])%10;//分及所有状态
                    if(sum==0){sum=10;}
                    a[x].c=max(a[x].c,sum);
                    if(a[x].c==sum){a[x].f=a[x].bb[i];}
                }
                if((a[x].bb[i]+a[x].bb[j]+a[x].bb[k])%10==0)//牛
                {
                    int sum=(a[x].bb[1]+a[x].bb[2]+a[x].bb[3]+a[x].bb[4]+a[x].bb[5]-10)%10;//分及所有状态
                    if(sum==0){sum=10;}
                    a[x].c=max(a[x].c,sum);
                    if(a[x].c==sum){a[x].f=0;}
                }
            }
        }
    }
}
void cp(int w,int z)//积分函数，按题意来，铁板再来一次
{
    if(a[w].c==11){a[w].id+=100;a[z].id-=100;}
    if(a[w].c==10){a[w].id+=30;a[z].id-=30;if(a[w].f!=0){a[w].id+=30;a[z].id-=30;}}
    if(a[w].c>=7&&a[w].c<=9){a[w].id+=20;a[z].id-=20;if(a[w].f!=0){a[w].id+=20;a[z].id-=20;}}
    if(a[w].c>=0&&a[w].c<=6){a[w].id+=10;a[z].id-=10;if(a[w].f!=0){a[w].id+=10;a[z].id-=10;}} 

}
void compare(int x,int y)//比较函数，不想写注释……
//一层一层来
{
    if(a[x].c>a[y].c){cp(x,y);}
    if(a[x].c<a[y].c){cp(y,x);}
    if(a[x].c==a[y].c)
    {
        if(a[x].f>a[y].f){cp(x,y);}
        if(a[x].f<a[y].f){cp(y,x);}
        if(a[x].f==a[y].f)
        {
            if(a[x].d>a[y].d){cp(x,y);}
            if(a[x].d<a[y].d){cp(y,x);}
            if(a[x].d==a[y].d)
            {
                if(a[x].e>a[y].e){cp(x,y);}
                if(a[x].e<a[y].e){cp(y,x);}
            }

        }
    }
}
int main()
{
    cin>>ID>>t>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>b[i].ks;
    }
    for(int kkk=1;kkk<=t;kkk++)
    {
        for(int i=ssum;i<=ssum+2;i++)
        {
            a[i].c=0,a[i].d=0,a[i].e=0,a[i].f=0;//清空
        }
        for(int i=ssum;i<=ssum+2;i++)//输入
        {
            cin>>a[i].s;
            for(int j=1;j<=5;j++)
            {
                cin>>ss;
                if(ss[0]=='a'){a[i].aa[j]=4;}//判断
                if(ss[0]=='b'){a[i].aa[j]=3;}
                if(ss[0]=='c'){a[i].aa[j]=2;}
                if(ss[0]=='d'){a[i].aa[j]=1;}
                if(ss.length()==2)
                {
                    if(ss[1]=='A'){a[i].bb[j]=1;}
                    else{a[i].bb[j]=ss[1]-48;}
                }
                else{a[i].bb[j]=10;}
            }
            check(i);
        }
        ssum+=3;//往后存，不然RE
    }
    for(int i=1;i<ssum;i+=3)
    {
        compare(i,i+1),compare(i,i+2),compare(i+2,i+1);//一一比较
    }
    for(int i=1;i<ssum;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(a[i].s==b[j].ks)
            {
                b[j].aans+=a[i].id;//加分
            }
        }
    }
    for(int i=1;i<=n;i++)//输出
    {
        cout<<b[i].ks<<" "<<b[i].aans<<endl;
    }
    return 0;
}
```

这140行只有65pt！！！
结果不是WA就是TLE
蒟蒻疯了…… 请教了众多dalao之后，凭借我努力学习知识的精神才有了——

## 模拟进阶版
不想写注释……算了，请各位巨佬自行学习，反正是模拟，技术含量不是很高

```cpp
#include <bits/stdc++.h>
using namespace std; 
struct Card {
    int x;//卡牌编号 
    int col;//卡牌花色 

    friend bool operator>(Card a,Card b)//比较 
	{
        return a.x==b.x?a.col<b.col:a.x>b.x;
    }
};
struct Score {
    int Point;//最大分值 
    bool Boom;int Boom_Num;//是否有炸弹，有的话多大 
    bool Board;int Board_Num;//是否有铁板，铁板的数值 
    Card Num;//最大值
};
int T;
int n;
string Name[100001];
map<string,int>points;//姓名与分数的映射，结构体也行 
void fu_zhi(Score&a)
{
    a.Point=a.Boom_Num = a.Board_Num = 0;
    a.Boom=a.Board=false;
    a.Num=(Card){0, 0};
}
bool cmp(Card a,Card b)//比较大小 
{
    return a > b;
}
Score Get()
{
    Score Have;fu_zhi(Have);
    Card a[5];
    char str[5];
    int sum=0;
    for(int i=0;i<5;i++)
	{
        str[0]=str[1]=str[2]=0;//清空 
        cin>>str;//输入 
        a[i].col=str[0]-'a';//花色 
        a[i].x=str[2]=='0'?10:(str[1]=='A'?1:str[1]-48);
        //牌数 
        sum+=a[i].x;
    }
    bool OK=false;
    sort(a,a+5,cmp);//排一下序 
    Have.Num=a[0];//最大值 
    //检查是否有炸弹及赋分 
    if(a[1].x==a[2].x&&a[2].x==a[3].x)
        if(a[0].x==a[1].x||a[4].x==a[1].x)
		{
            Have.Boom=1;
            Have.Boom_Num=a[1].x;
            return Have;
        }
    //检查是否有分 
    int Point=0;
    for(int i=0;i<5;i++)
        for(int j=i+1;j<5;j++)
            if((a[i].x+a[j].x)%10==sum%10)
			{
                OK=true;
                break;
            }
    if(OK)Point=(sum-1)%10+1;//有分 
    bool Board=false;
    int Num=0;
    int Sum=0;
    //是否有铁板及赋分 
    for(int i=0;i<3;i++)
        if(a[i].x==a[i+1].x&&a[i+1].x==a[i+2].x)
		{
            Board=true;
            Num=a[i].x;
            Sum=sum-a[i].x*3;
        }
    Sum=(Sum-1)%10+1;
    if(!OK&&!Board)//无牛 
	{
        return Have;
    }
    if(Point<=Sum)//铁板是最大的时 
	{
        Have.Board=true;
        Have.Board_Num=Num;
        Have.Point=Sum;
        return Have;
    }
    else//正常是最大的时 
	{
        Have.Point = Point;
        return Have;
    }
}
void calc(string a,Score A,string b,Score B)
{
    if(A.Boom||B.Boom)//都有炸弹 
	{
        if(A.Boom_Num>B.Boom_Num)//A比B大 
		{
            points[a]+=100;
            points[b]-=100;
        }
        else//A比B小 
		{
            points[a] -= 100;
            points[b] += 100;
        }
    }
    else 
	{
        if(A.Point>B.Point||(A.Point==B.Point&&((A.Board&&!B.Board)||(A.Board&&B.Board&&A.Board_Num>B.Board_Num)||(!A.Board&&!B.Board&&A.Num>B.Num))))
		{//总而言之，A大于B的所有情况时，计分 
            int mul=1;
            if(A.Board)mul*=2;
            if(A.Point>=7)mul*=2;
            if(A.Point==10)mul=(mul>>1)*3;
            points[a]+=mul*10;
            points[b]-=mul*10;
        }
        else//B大于A时 
		{
            int mul=1;
            if(B.Board)mul*=2;
            if(B.Point>=7)mul*=2;
            if(B.Point==10)mul=(mul>>1)*3;
            points[a]-=mul*10;
            points[b]+=mul*10;
        }
    }
}
int main()
{
    int id;
    cin>>id;
    cin>>T>>n;
    for(int i=1;i<=n;i++)cin>>Name[i];//各人姓名 
    while(T--)
	{
        string a,b,c;
        cin>>a;//人名1 
        Score aCard=Get();//牌1 
        cin>>b;//同上 
        Score bCard=Get();
        cin>>c;
        Score cCard=Get();
        calc(a,aCard,b,bCard);
        calc(b,bCard,c,cCard);
        calc(a,aCard,c,cCard);
    }
    for(int i=1;i<=n;i++)cout<<Name[i]<<' '<<points[Name[i]]<<endl;
    //出分了 
    return 0;
}
```
AC ~~我有点想做[P2484](https://www.luogu.org/problemnew/show/P2482)了~~   
谢谢观赏

---

## 作者：LXcjh4998 (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P5013)
# 题意
现有 $n$ 个人玩斗牛游戏，一共进行了 $t$ 轮，**每轮都只有 $3$ 个人参加游戏**，每个人的初始的分都为 $0$。

斗牛的规则如下：
> ### 发牌
>
> 在每轮斗牛开始前，每位玩家都会拿到 $5$ 张牌。
>
> 每张牌一定是一个 $2$ 至 $10$ 的整数或 $\texttt{A}$（表示 $1$）。
>
> 每张牌都有一个花色，分别用 $\texttt{a}$、$\texttt{b}$、$\texttt{c}$、$\texttt{d}$ 来表示。

> ### 牌型
> $5$ 张牌中，除了炸弹和无牛型牌，都分为两个部分：牛和分。
>
> 牛包括 $3$ 张点数相同的牌（铁板）和 $3$ 张点数之和为 $10$ 的倍数的牌；分为剩下 $2$ 张牌，一套牌的分即这 $2$ 张牌点数之和模 $10$ 的余数。
> - 炸弹：$4$ 张点数相同的牌。
> - 牛牛：分恰好为 $0$。
> - 牛：分不为 $0$，分和牛数的数值相同。例如，如果一套牌的分为 $5$，则被称为牛五。
> - 无牛：不存在 $3$ 张牌，其点数相同或其点数之和为 $10$ 的倍数。

> ### 牌型大小比较
> 首先比较牌型：
> 
> - 炸弹 $>$ 牛牛 $>$ 牛九 $>$ 牛八 $>$ 牛七 $>$ 牛六 $>$ 牛五 $>$ 牛四 $>$ 牛三 $>$ 牛二 $>$ 牛一 $>$ 无牛。
> 
> 否则按如下规则来比较：
> - 双方都有炸弹时，炸弹点数更大一方的更大。
> - 只有一方有铁板时，有铁板的一方更大。
> - 双方都有铁板时，铁板点数更大的一方更大。
> - 双方都没有铁板或都无牛时，比较双方点数最大的牌，点数更大的一方更大；如果双方点数最大的牌点数相同，则花色更大的一方更大，花色大小为 $\texttt{a}>\texttt{b}>\texttt{c}>\texttt{d}$。

> ### 计分
> 一局游戏的底分为 $10$ 分，即每位玩家都会押 $10$ 分。
>
> 对于其中 $2$ 名玩家，我们在比较完双方的牌型后，选择牌型更大的一方的牌型来计算得失分数的翻倍，具体如下：
> - 炸弹：底分 $\times 10$。
> - 牛牛：底分 $\times 3$。
> - 牛七、牛八、牛九：底分 $\times 2$。
> - 无牛、牛一至牛六：底分。
> - 铁板：计算完牌型得分后，在牌型得分的基础上 $\times 2$。
> - **注意：铁板翻倍不与炸弹翻倍同时进行。**
> 
> 计分时，采用两两计分的方式。
>
> 具体的，对于三名玩家 A、B、C，先计算 A 和 B 之间的分数得失，再计算 A 和 C 之间的分数得失，最后计算 B 和 C 之间的分数得失。

假设所有玩家都会打出他们手上的牌中的最大牌型，求这 $t$ 轮游戏结束后，每位玩家的得分。
> ### 输入格式
> 第一行三个整数 $id$、$t$、$n$，$id$ 表示测试点编号，若是样例则为 $0$。
>
> 接下来 $n$ 行，每行一个仅包括大小写字母和数字的长度少于 $11$ 的字符串表示玩家名称。
>
> 接下来 $t$ 组，每组数据 $6$ 行，可分为 $3$ 个相同的部分：
> - 第一行一个字符串，表示玩家名称。
> - 第二行五个字符串表示该玩家手中的手牌。每一个字符串的第一个字符表示花色，其余字符表示牌的大小。

> ### 输出格式
> 共 $n$ 行，每行一个字符串和一个数字，中间用空格隔开，表示一名玩家和他的最终得分
>
> **请按玩家名称的输入顺序输出。**
# 思路
> ### 约定
> 为避免讲述过程中的歧义，先规定以下变量的意义：
> - $num_i$：第 $i$ 张牌的点数。
> - $id_i$：第 $i$ 张牌的花色。$\texttt{a}$ 为 $4$，$\texttt{b}$ 为 $3$，$\texttt{c}$ 为 $2$，$\texttt{d}$ 为 $1$。
> - $bomb$：炸弹的点数，没有则为 $0$。
> - $tieban$：铁板的点数，没有则为 $0$。
> - $fen$：牛数，牛牛为 $10$，无牛为 $0$。
> - $max_{num}$：$5$ 张牌中的最大点数。
> - $max_{id}$：在点数为 $max_{num}$ 的牌中的最大花色。
> - $sum$：$5$ 张牌的点数之和。
> - $cnt_i$：点数为 $i$ 的牌有几张。
> - $name_i$：第 $i$ 个人的名字。
> - $score_i$：第 $i$ 个人的分数。


> ### 人名
> 用 ```map``` 记录人名所对应的下标即可。

> ### 发牌
> 读入 $5$ 个字符串。
>
> 首先处理 $id_i$。
>
> 然后处理 $num_i$。
>
> 详见程序。

> ### 处理牌型
> 首先遍历一遍，处理 $cnt_i$、$sum$、$max_{num}$ 和 $max_{id}$。
>
> 然后遍历 $cnt_i$，看是否存在 $i$ 使得 $cnt_i=4$，若存在，则 $bomb\gets i$，并直接退出。
>
> 否则再遍历 $cnt_i$，看是否存在 $i$ 使得 $cnt_i=3$，若存在，则 $tieban\gets i$，并计算此时的 $fen$。
>
> 若既不存在炸弹，也不存在铁板，则判断是否有牛：
> - 让有序对 $(i,j)$ 遍历所有状态，若存在有序对 $(i,j)$，使得 $num_i+num_j\equiv sum\pmod {10}$，则有牛，并计算此时的 $fen$ 。
> - 若此时的 $fen$ 比之前的大，则 $tieban$ 清 $0$，并更新 $fen$（因为优先比较 $fen$，并且 $fen$ 相同时铁板更优）。

> ### 计分
> 先比较 $bomb$，如果有，则直接计算，并返回。
>
> 然后比较 $fen$ 的大小，若 $fen$ 不相同直接计算。
>
> 若 $fen$ 相同，则比较 $tieban$，若 $tieban$ 不相同直接计算。
>
> 若 $tieban$ 相同，则比较 $max_{num}$；若 $max_{num}$ 仍相同，则比较 $max_{id}$。
>
> 详见程序。

> ### 输出
> 按照输入顺序依次输出 $name_i$ 和 $score_i$ 即可。
# 程序
[AC 记录](https://www.luogu.com.cn/record/204797862)
```cpp
#include<cstdlib>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<queue>
#include<cstdio>
#include<iostream>
#include<vector>
#include<map>
#include<cmath>
#include<iomanip>
#include<string>
#include<stack>
#define re register
#define ll long long
#define ull unsigned long long
#define vl __int128
#define ld long double
#define LL 2e18
#define INT 1e9
#define INF 0x3f3f3f3f
#define lb(x) (x&(-x))
#ifdef __linux__
#define gc getchar_unlocked
#define pc putchar_unlocked
#else
#define gc _getchar_nolock
#define pc _putchar_nolock
#endif
int T=1;
using namespace std;
inline bool blank(const char x){return !(x^32)||!(x^10)||!(x^13)||!(x^9);}
template<typename Tp>inline void read(Tp &x){x=0;re bool z=true;re char a=gc();for(;!isdigit(a);a=gc())if(a=='-')z=false;for(;isdigit(a);a=gc())x=(x<<1)+(x<<3)+(a^48);x=(z?x:~x+1);}
inline void read(double &x){x=0.0;re bool z=true;re double y=0.1;re char a=gc();for(;!isdigit(a);a=gc())if(a=='-')z=false;for(;isdigit(a);a=gc())x=x*10+(a^48);if(a!='.')return x=z?x:-x,void();for(a=gc();isdigit(a);a=gc(),y/=10)x+=y*(a^48);x=(z?x:-x);}
inline void read(ld &x){x=0.0;re bool z=true;re ld y=0.1;re char a=gc();for(;!isdigit(a);a=gc())if(a=='-')z=false;for(;isdigit(a);a=gc())x=x*10+(a^48);if(a!='.')return x=z?x:-x,void();for(a=gc();isdigit(a);a=gc(),y/=10)x+=y*(a^48);x=(z?x:-x);}
inline void read(char &x){for(x=gc();blank(x)&&(x^-1);x=gc());}
inline void read(char *x){re char a=gc();for(;blank(a)&&(a^-1);a=gc());for(;!blank(a)&&(a^-1);a=gc())*x++=a;*x=0;}
inline void read(string &x){x="";re char a=gc();for(;blank(a)&&(a^-1);a=gc());for(;!blank(a)&&(a^-1);a=gc())x+=a;}
template<typename T,typename ...Tp>inline void read(T &x,Tp &...y){read(x),read(y...);}
template<typename T>inline void read(T *begin,T *end){re T *i;if(begin<end)for(i=begin;i<end;++i)read(*i);else for(i=begin-1;i>=end;--i)read(*i);}
template<typename Tp>inline void write(Tp x){if(!x)return pc(48),void();if(x<0)pc('-'),x=~x+1;re int len=0;re char tmp[64];for(;x;x/=10)tmp[++len]=x%10+48;while(len)pc(tmp[len--]);}
inline void write(const double x){re int a=6;re double b=x,c=b;if(b<0)pc('-'),b=-b,c=-c;re double y=5*powl(10,-a-1);b+=y,c+=y;re int len=0;re char tmp[64];if(b<1)pc(48);else for(;b>=1;b/=10)tmp[++len]=floor(b)-floor(b/10)*10+48;while(len)pc(tmp[len--]);pc('.');for(c*=10;a;a--,c*=10)pc(floor(c)-floor(c/10)*10+48);}
inline void write(const ld x){re int a=6;re ld b=x,c=b;if(b<0)pc('-'),b=-b,c=-c;re ld y=5*powl(10,-a-1);b+=y,c+=y;re int len=0;re char tmp[64];if(b<1)pc(48);else for(;b>=1;b/=10)tmp[++len]=floor(b)-floor(b/10)*10+48;while(len)pc(tmp[len--]);pc('.');for(c*=10;a;a--,c*=10)pc(floor(c)-floor(c/10)*10+48);}
inline void write(const pair<int,double>x){re int a=x.first;if(a<7){re double b=x.second,c=b;if(b<0)pc('-'),b=-b,c=-c;re double y=5*powl(10,-a-1);b+=y,c+=y;re int len=0;re char tmp[64];if(b<1)pc(48);else for(;b>=1;b/=10)tmp[++len]=floor(b)-floor(b/10)*10+48;while(len)pc(tmp[len--]);a&&(pc('.'));for(c*=10;a;a--,c*=10)pc(floor(c)-floor(c/10)*10+48);}else printf("%.*lf",a,x.second);}
inline void write(const pair<int,ld>x){re int a=x.first;if(a<7){re ld b=x.second,c=b;if(b<0)pc('-'),b=-b,c=-c;re ld y=5*powl(10,-a-1);b+=y,c+=y;re int len=0;re char tmp[64];if(b<1)pc(48);else for(;b>=1;b/=10)tmp[++len]=floor(b)-floor(b/10)*10+48;while(len)pc(tmp[len--]);a&&(pc('.'));for(c*=10;a;a--,c*=10)pc(floor(c)-floor(c/10)*10+48);}else printf("%.*Lf",a,x.second);}
inline void write(const char x){pc(x);}
inline void write(const bool x){pc(x?49:48);}
inline void write(char *x){fputs(x,stdout);}
inline void write(const char *x){fputs(x,stdout);}
inline void write(const string &x){fputs(x.c_str(),stdout);}
template<typename T,typename ...Tp> inline void write(T x,Tp ...y){write(x),write(y...);}
template<typename T>inline void write(T *begin,T *end,const char c=' '){re T *i;for(i=begin;i<end;++i)write(*i,c);}
template<typename T>inline void init(T *begin,T *end,const T& val=T()){re T* i;for(i=begin;i<end;++i)*i=val;}
template<typename T>inline T max(T *begin,T *end){re T *ans,*i;for(i=begin;i<end;++i)if(i==begin||*ans<*i)ans=i;return *ans;}
template<typename T>inline T min(T *begin,T *end){re T *ans,*i;for(i=begin;i<end;++i)if(i==begin||*i<*ans)ans=i;return *ans;}
template<typename T>inline T calc_sum(T *begin,T *end,const T& val=T()){re T ans=val,*i;for(i=begin;i<end;++i)ans+=*i;return ans;}
template<typename T>inline bool is_equal(T *begin,T *end,const T& val=T()){re T *i;for(i=begin;i<end;++i)if(*i!=val)return false;return true;}

ll mod=0;
const int MAXN=1e5;
const int N=MAXN+10;
//#define DEBUG
//#define more_text

struct card{
	int num[5],id[5];   //点数、花色 a->4 b->3 c->2 d->1 
	
	int bomb;           //炸弹的点数 0表示没有炸弹
	int tieban;         //铁板的点数 0表示没有铁板
	int fen;            //分的点数，即牛数 牛牛点数为10，无牛为0，其他照常 
	int max_num,max_id; //最大点数 最大点数中的最大花色 
	
	int sum;            //所有点数的和 
	int cnt[11];        //cnt[i]表示点数为i的牌有几张 
	
	void init(){
		sum=max_num=max_id=bomb=tieban=fen=0;
		for(int i=1;i<=10;++i)cnt[i]=0;
		
		//处理sum、cnt[]、max_num、max_id 
		for(int i=0;i<5;++i){
			sum+=num[i];
			++cnt[num[i]];
			if(max_num<num[i])max_num=num[i],max_id=id[i];
			else if(max_num==num[i]&&max_id<id[i])max_id=id[i];
		}
		
		//处理炸弹
		for(int i=1;i<=10;++i){
			if(cnt[i]==4){
				bomb=i;
				return;
			}
		}
		
		//处理铁板
		int tieban_fen=0; //如果有铁板其所对应的分 否则为0 
		for(int i=1;i<=10;++i){
			if(cnt[i]==3){
				tieban=i;
				tieban_fen=(sum-3*i)%10;
				if(tieban_fen==0)tieban_fen=10;
				break;
			}
		}
		
		//处理非铁板的牛 
		int normal_fen=0,tmp_fen; //忽略铁板的牛所对应的分 没有则为0
		for(int i=0;i<4;++i){
			for(int j=i+1;j<5;++j){
				if(sum%10==(num[i]+num[j])%10){
					tmp_fen=(num[i]+num[j])%10;
					if(tmp_fen==0)tmp_fen=10;
					normal_fen=max(normal_fen,tmp_fen);
				}
			}
		}
		
		if(tieban_fen>=normal_fen)fen=tieban_fen;
		else tieban=0,fen=normal_fen;
	}
};
inline void read(card &x){
	char s[5][4];
	read(s[0],s[1],s[2],s[3],s[4]);
	for(int i=0;i<5;++i){
		x.id[i]='e'-s[i][0];
		if(s[i][1]=='A')x.num[i]=1;
		else if(s[i][1]=='1'&&s[i][2]=='0')x.num[i]=10;
		else x.num[i]=s[i][1]-'0';
	}
}

int id,n;string name[N],str[3];card arr[N];

map<string,int> mp;int score[N];

void judge(int x,int y){
	//双方至少有一个 bomb 
	
	if(arr[x].bomb>arr[y].bomb){
		score[x]+=100,score[y]-=100;
		return;
	}
	if(arr[x].bomb<arr[y].bomb){
		score[x]-=100,score[y]+=100;
		return;
	}
	
	int times;
	
	if(arr[x].fen>arr[y].fen){
		if(arr[x].fen==10)times=3;
		else if(arr[x].fen>6)times=2;
		else times=1;
		if(arr[x].tieban)times*=2;
	}
	else if(arr[x].fen<arr[y].fen){
		if(arr[y].fen==10)times=-3;
		else if(arr[y].fen>6)times=-2;
		else times=-1;
		if(arr[y].tieban)times*=2;
	} //fen 不相同 
	else if(arr[x].tieban>arr[y].tieban){
		if(arr[x].fen==10)times=3;
		else if(arr[x].fen>6)times=2;
		else times=1;
		times*=2;
	}
	else if(arr[x].tieban<arr[y].tieban){
		if(arr[y].fen==10)times=-3;
		else if(arr[y].fen>6)times=-2;
		else times=-1;
		times*=2;
	} //fen 相同，但 tieban 不相同 
	else if(arr[x].max_num*10+arr[x].max_id>arr[y].max_num*10+arr[y].max_id){
		if(arr[x].fen==10)times=3;
		else if(arr[x].fen>6)times=2;
		else times=1;
		if(arr[x].tieban)times*=2;
	}
	else if(arr[x].max_num*10+arr[x].max_id<arr[y].max_num*10+arr[y].max_id){
		if(arr[y].fen==10)times=-3;
		else if(arr[y].fen>6)times=-2;
		else times=-1;
		if(arr[y].tieban)times*=2;
	} //fen 和 tieban 都相同 
	score[x]+=times*10,score[y]-=times*10;
}

void solve(int step){
	read(id,T,n);
	for(int i=1;i<=n;++i){
		read(name[i]);
		mp[name[i]]=i;
	}
	while(T--){
		for(int i=0;i<3;++i){
			read(str[i]);
			read(arr[mp[str[i]]]);
			arr[mp[str[i]]].init();
		}
		judge(mp[str[0]],mp[str[1]]);
		judge(mp[str[1]],mp[str[2]]);
		judge(mp[str[2]],mp[str[0]]); //两两比较 
	}
	for(int i=1;i<=n;++i)write(name[i],' ',score[i],'\n');
}
/*
Input:

Output:

Outline:

*/
int main(){
	#ifdef DEBUG
	freopen("test.in","r",stdin);freopen("test.out","w",stdout);
	#endif
	#ifdef more_text
	read(T);
	#endif 
	for(int i=0;i<T;++i)solve(i);
	#ifdef DEBUG
	fclose(stdin);fclose(stdout);
	#endif
	return 0;
}
```

---

## 作者：HYdroKomide (赞：1)

### 题意：

模拟一个简单版斗牛游戏。

### 思路：
在写大模拟的时候，很多人会选择完全顺着思路写，想到哪写到哪。这样很容易导致代码量巨大，调试困难。为了缩短代码长度，降低后期调试难度，我们应该将变量名设清晰，并且在写之前规划清晰的结构。

这里我们用 unordered_map 存所有人名对应的分数。对于每局的每名玩家，预处理时存储所有可能参与比大小的牌型信息（没有此牌型就是 $0$），依照重要性排序分别为：炸弹大小、牛数、铁板大小、最大牌数字、最大牌最大花色。

当然，以上某些牌型信息就算不会用到，也可以储存下来。这样代码可以更简洁（少一些特判），并且更容易调试。

首先，关于输入牌型的问题。当使用 cin 输入单个字符类型时，程序会尝试寻找第一个非空字符。因此，对于每张牌，我们都可以先输入一个字符（代表花色），再输入一个字符串代表数字。注意，**根据某篇题解的说法，第二个测试点有使用 `1` 代替 `A` 的情况**，需要格外注意。

由于最大牌数字、最大牌最大花色是独立于其它牌型信息的，因此可以将它们可以单独处理。这里需要注意：

1. 花色 ASCII 码越小，花色越大，因此最大牌最大花色需要预处理到极大值；
2. 最大牌数字更新时，花色应该强制赋值为那个牌的花色；

用一个桶数组，存每个数字的牌出现次数。只要有炸弹，就没有铁板、牛之类的牌型了，可以直接跳出循环。

**因为铁板的重要性相较于牛数更靠后**，有更高牛数时甚至可能抛弃铁板，因此我们可以把对铁板的识别放在靠前的地方。如果发现任意有三张牌相同，就可以直接更新牛数。

到了后面的循环，我们循环枚举两张牌的“牛”那一部分，看其余的牌之和是否可以凑成十的倍数，进而算出这种出法的牛数。如果发现有更高的牛数即可更新牛数的值，并且铁板更新为 $0$。

最后的比大小环节，三个人之间两两比较。具体地，先把炸弹特判一下，然后依照重要性的顺序排出两个人牌的大小，乘上较大人牛数的倍率（和是否有铁板的二倍）即可。倍率可以写到数组里直接用。

### 程序如下：
```cpp
#include<iostream>
#include<cstring>
#include<unordered_map>
using namespace std;
const int N=1e5+5;
const int MUL[]={1,1,1,1,1,1,1,2,2,2,3};//预存不同牛数的倍率
int id,t,n;
string name[N];
unordered_map<string,int>ans;
struct MAN{
	int bomb,tieban,niu,maxnum;
	char maxcol;
}a[4];//三个人的牌型
void calc(int k){
	char col[6];
	int num[6],buc[11],sum=0;
	memset(buc,0,sizeof(buc));
	a[k].maxcol='z';
	for(int i=1;i<=5;i++){
		string numstr;
		cin>>col[i]>>numstr;
		if(numstr[0]=='A')num[i]=1;//需要特别注意数据问题
		else if(numstr[0]=='1'&&numstr[1]=='0')num[i]=10;
		else num[i]=numstr[0]-'0';
		buc[num[i]]++;
		sum+=num[i];
		if(a[k].maxnum<num[i]){//单独算最大牌
			a[k].maxnum=num[i];
			a[k].maxcol=col[i];
		}
		else if(a[k].maxnum==num[i])a[k].maxcol=min(a[k].maxcol,col[i]);
	}
	for(int i=1;i<=10;i++)
		if(buc[i]==4){
			a[k].bomb=i;
			return;
		}
	for(int i=1;i<=10;i++)
		if(buc[i]==3){
			int niu=0;
			a[k].tieban=i;
			for(int j=1;j<=5;j++)
				if(num[j]!=i)
					niu+=num[j];
			if(niu%10==0)a[k].niu=10;//发现铁板直接更新牛数
			else a[k].niu=niu%10;
			break;
		}
	for(int i=1;i<5;i++)
		for(int j=i+1;j<=5;j++)
			if((sum-num[i]-num[j])%10==0){
				int niu;
				if((num[i]+num[j])%10==0)niu=10;
				else niu=(num[i]+num[j])%10;
				if(niu>a[k].niu){
					a[k].niu=niu;
					a[k].tieban=0;//换更大牛数需要清除铁板
				}
			}
}
void comp(int kx,int ky,string x,string y){
	if(a[kx].bomb<a[ky].bomb){
		ans[x]-=100;
		ans[y]+=100;
		return;
	}
	else if(a[kx].bomb>a[ky].bomb){
		ans[x]+=100;
		ans[y]-=100;
		return;
	}
	if(a[kx].niu>a[ky].niu){
		swap(kx,ky);
		swap(x,y);
	}
	else if(a[kx].niu==a[ky].niu){
		if(a[kx].tieban>a[ky].tieban){
			swap(kx,ky);
			swap(x,y);
		}
		else if(a[kx].tieban==a[ky].tieban){
			if(a[kx].maxnum>a[ky].maxnum){
				swap(kx,ky);
				swap(x,y);
			}
			else if(a[kx].maxnum==a[ky].maxnum){
				if(a[kx].maxcol<a[ky].maxcol){
					swap(kx,ky);
					swap(x,y);
				}
			}
		}
	}
	int mul=MUL[a[ky].niu];
	if(a[ky].tieban!=0)mul*=2;
	ans[x]-=10*mul;
	ans[y]+=10*mul;
}
int main(){
	cin>>id>>t>>n;
	for(int i=1;i<=n;i++){
		cin>>name[i];
		ans[name[i]]=0;
	}
	while(t--){
		string nm1,nm2,nm3;
		memset(a,0,sizeof(a));
		cin>>nm1;
		calc(1);
		cin>>nm2;
		calc(2);
		cin>>nm3;
		calc(3);
		comp(1,2,nm1,nm2);
		comp(2,3,nm2,nm3);
		comp(3,1,nm3,nm1);
	}
	for(int i=1;i<=n;i++)cout<<name[i]<<" "<<ans[name[i]]<<"\n";
	return 0;
}
```
### THE END

---

## 作者：tallnut (赞：1)

一道非常毒的大模拟。

# 整体思路
## 读入牌并存储
建一个结构体 $card$ 用来存储牌型，设置一个成员函数用来读入。

这部分的思路没啥好讲的，代码：
```
//记录一张牌
struct card
{
	int point;
	//type表示花色，a为4，b为3，以此类推（为了方便比较花色）
	int type;
	//获取一张牌的信息
	void read()
	{
		char c;
		//忽略空白字符
		while ((c = cin.get()) && isspace(c));
		//获取花色
		type = 'e' - c;
		//获取点数
		c = cin.get();
		if (c == 'A') point = 1;
		else if (c == '1')
		{
			if ((!cin.eof()) && (cin.get() != ' ')) point = 10;
			else point = 1;
		}
		else point = (c - '0');
	}
};
```
## 玩家信息
**注：这一部分的思路参考了 Eason_AC  大佬，在此表示感谢。**

该大佬的题解链接如下：[link](https://www.luogu.com.cn/blog/EasonBlog1/solution-p5013)

### 变量&数组
秉承着“空间换时间”的思想，我设立了如下变量和数组：

1. $zhadan$ 变量 如果有炸弹则为炸弹点数，否则为 $0$。

2. $tieban$ 变量 如果有铁板则为铁板点数，否则为 $0$。

3. $niu$ 变量 如果有牛则为牛数，无牛则为 $0$，**特殊地，牛牛用 $10$ 表示**。

4. $cards$ 数组 存储每一张牌。

5. $sum$ 变量 存储所有牌点数之和。

6. $cnt$ 数组 开桶记录每一张牌的点数。

7. $maxpoint$ 变量 存储所有牌中点数最大者。

8. $maxtype$ 变量 存储所有牌中点数最大者之中的花数最大者。

### 更新玩家信息
首先，调用 $cards$ 数组中的 read()  函数读入内容。

然后遍历一次 $cards$ 数组，更新 $sum$、$cnt$、$maxpoint$、$maxtype$ 变量或数组，注意 $maxtype$  变量修改时的细节。

接着判断炸弹或铁板，将 $cnt$ 数组扫一遍即可。

最后判断和为 $10$ 的三张牌，利用 $sum$ 变量使得只需要暴力枚举两张牌，剩下的通过 $sum$ 做减法即可得到和。
**记得更新 $tieban$ 变量！！！**（我被坑了好久qwq）

最好也要写一个 clear() 函数来清空所有值。（其实使用 memset() 来清空数组更快，~~不过反正我也过了就不用管这些了~~）

代码：
```
//记录一个玩家的信息
struct player
{
	//无炸弹则为0，有炸弹则为炸弹点数
	int zhadan;
	//无铁板则为0，有铁板则为铁板点数
	int tieban;
	//无牛则为0，有牛但无牛牛则为牛数，牛牛则为10
	int niu;
	//记录所有牌
	card cards[5];
	//记录所有牌点数之和
	int sum;
	//记录每一个点数有几张牌
	int cnt[11];
	//记录所有牌中点数最大的
	int maxpoint;
	//点数最大的一张牌的花色
	int maxtype;
	//更新炸弹、铁板等信息
	void update_cardtype()
	{
		//更新sum、cnt、maxpoint、maxtype
		for (int i = 0;i < 5;i++)
		{
			sum += cards[i].point;
			cnt[cards[i].point]++;
			if (cards[i].point > maxpoint)
			{
				maxpoint = cards[i].point;
				maxtype = cards[i].type;
			}
			else if (cards[i].point == maxpoint) maxtype = max(maxtype,cards[i].type);
		}
		//判断有没有炸弹或铁板
		for (int i = 1;i <= 10;i++)
			if (cnt[i] == 4)
			{
				zhadan = i;
				break;
			}
			else if (cnt[i] == 3)
			{
				tieban = i;
				niu = (sum - i * 3) % 10;
				if (niu == 0) niu = 10;
				break;
			}
		//判断有没有三张牌和为10
		//暴力枚举两张牌，剩下三张用sum快速判断
		for (int i = 0;i < 4;i++)
			for (int j = i + 1;j < 5;j++)
				if ((sum - (cards[i].point + cards[j].point)) % 10 == 0)
				{
				    int tmpn = niu;
					if ((cards[i].point + cards[j].point) % 10 != 0) niu = max(niu,(cards[i].point + cards[j].point) % 10);
					else niu = 10;
					if (tmpn < niu) tieban = 0;
				}
	}
	//清空所有信息
	void clear()
	{
		zhadan = 0;
		tieban = 0;
		niu = 0;
		sum = 0;
		maxpoint = 0;
		maxtype = 0;
		for (int i = 0;i < 5;i++)
			cards[i].point = cards[i].type = 0;
		for (int i = 1;i < 11;i++)
			cnt[i] = 0;
	}
};
```
## 两两比拼
这里我用了一个结构体存储分数得失，不过其实也没必要这样。

依题意模拟即可，只不过判断条件有点多，代码复杂。

先判炸弹，再判牛，接着铁板，最后最大点数、最大花色。

此时就可以用上我们之前准备的 $maxpoint$，$maxtype$ 变量了。代码：
```//存储两个人的分数得失
struct score_info
{
	int first;
	int second;
};
//比较两个玩家的牌，若第一个赢则返回true
score_info cmp(const player& first,const player& second)
{
	//如果至少有一方有炸弹
	if (first.zhadan > 0 || second.zhadan > 0)
	{
		if (first.zhadan > second.zhadan) return {100,-100};
		else return {-100,100};
	}
	//如果牛数不相同
	if (first.niu > second.niu)
	{
		int tmpscore;
		if (first.niu == 10) tmpscore = 30;
		else if (first.niu >= 7) tmpscore = 20;
		else tmpscore = 10;
		if (first.tieban) tmpscore *= 2;
		return {tmpscore,-tmpscore};
	}
	else if (first.niu < second.niu)
	{
		int tmpscore;
		if (second.niu == 10) tmpscore = 30;
		else if (second.niu >= 7) tmpscore = 20;
		else tmpscore = 10;
		if (second.tieban) tmpscore *= 2;
		return {-tmpscore,tmpscore};
	}
	//牛数相同且均无炸弹
	//至少有一方有铁板
	if (first.tieban > 0 && second.tieban == 0)
	{
		if (first.niu == 10) return {60,-60};
		else if (first.niu >= 7) return {40,-40};
		else return {20,-20};
	}
	else if (first.tieban == 0 && second.tieban > 0)
	{
		if (second.niu == 10) return {-60,60};
		else if (second.niu >= 7) return {-40,40};
		else return {-20,20};
	}
	//双方都有铁板
	else if (first.tieban > 0 && second.tieban > 0)
	{
		int tmpscore;
		//由于现在已经可以判定first和second的牛数相同，所以用first.niu还是second.niu都行
		if (first.niu == 10) tmpscore = 60;
		else if (first.niu >= 7) tmpscore = 40;
		else tmpscore = 20;
		if (first.tieban > second.tieban) return {tmpscore,-tmpscore};
		else return {-tmpscore,tmpscore};
	}
	//双方均无铁板
	//如果双方最大的牌点数不同
	if (first.maxpoint != second.maxpoint)
	{
		int tmpscore;
		if (first.niu == 10) tmpscore = 30;
		else if (first.niu >= 7) tmpscore = 20;
		else tmpscore = 10;
		if (first.maxpoint > second.maxpoint) return {tmpscore,-tmpscore};
		else return {-tmpscore,tmpscore};
	}
	//则需要比较最大点数牌的花色
	int tmpscore;
	if (first.niu == 10) tmpscore = 30;
	else if (first.niu >= 7) tmpscore = 20;
	else tmpscore = 10;
	if (first.maxtype > second.maxtype) return {tmpscore,-tmpscore};
	else return {-tmpscore,tmpscore};
}
```
## 主函数&全局变量
定义一些全局变量来存储输入内容。

开一个 string 数组存储所有选手的名称，一个 unordered_map 存储所有选手得分，另一个 unordered_map 存储选手名称和选手结构体之间的映射。$id$ 对于像我们这样想 $\texttt{\color{#92E82F}AC}$ 的人来说根本没用，可以直接用后续输入的内容覆盖掉。

代码：
```
int t,n;
string stmp,name1,name2,name3;
string players[1000001];
unordered_map<string,player> mp;
unordered_map<string,long long> score;
score_info scoreinfotmp;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	//id对于想AC的人来说根本没用，所以直接忽略
	cin >> t >> t >> n;
	for (int i = 1;i <= n;i++)
		cin >> players[i];
	while (t--)
	{
		//读入
		cin >> name1;
		mp[name1].clear();
		for (int j = 0;j < 5;j++)
			mp[name1].cards[j].read();
		mp[name1].update_cardtype();
		cin >> name2;
		mp[name2].clear();
		for (int j = 0;j < 5;j++)
			mp[name2].cards[j].read();
		mp[name2].update_cardtype();
		cin >> name3;
		mp[name3].clear();
		for (int j = 0;j < 5;j++)
			mp[name3].cards[j].read();
		mp[name3].update_cardtype();
		//两两斗牛
		scoreinfotmp = cmp(mp[name1],mp[name2]);
		score[name1] += scoreinfotmp.first;
		score[name2] += scoreinfotmp.second;
		scoreinfotmp = cmp(mp[name1],mp[name3]);
		score[name1] += scoreinfotmp.first;
		score[name3] += scoreinfotmp.second;
		scoreinfotmp = cmp(mp[name2],mp[name3]);
		score[name2] += scoreinfotmp.first;
		score[name3] += scoreinfotmp.second;
	}
	for (int i = 1;i <= n;i++)
		cout << players[i] << ' ' << score[players[i]] << '\n';
}
```
# AC代码
[AC记录](https://www.luogu.com.cn/record/124822390)，代码中有注释。
```
#include <iostream>
#include <cctype>
#include <unordered_map>
using namespace std;
//记录一张牌
struct card
{
	int point;
	//type表示花色，a为4，b为3，以此类推（为了方便比较花色）
	int type;
	//获取一张牌的信息
	void read()
	{
		char c;
		//忽略空白字符
		while ((c = cin.get()) && isspace(c));
		//获取花色
		type = 'e' - c;
		//获取点数
		c = cin.get();
		if (c == 'A') point = 1;
		else if (c == '1')
		{
			if ((!cin.eof()) && (cin.get() != ' ')) point = 10;
			else point = 1;
		}
		else point = (c - '0');
	}
};
//记录一个玩家的信息
struct player
{
	//无炸弹则为0，有炸弹则为炸弹点数
	int zhadan;
	//无铁板则为0，有铁板则为铁板点数
	int tieban;
	//无牛则为0，有牛但无牛牛则为牛数，牛牛则为10
	int niu;
	//记录所有牌
	card cards[5];
	//记录所有牌点数之和
	int sum;
	//记录每一个点数有几张牌
	int cnt[11];
	//记录所有牌中点数最大的
	int maxpoint;
	//点数最大的一张牌的花色
	int maxtype;
	//更新炸弹、铁板等信息
	void update_cardtype()
	{
		//更新sum、cnt、maxpoint、maxtype
		for (int i = 0;i < 5;i++)
		{
			sum += cards[i].point;
			cnt[cards[i].point]++;
			if (cards[i].point > maxpoint)
			{
				maxpoint = cards[i].point;
				maxtype = cards[i].type;
			}
			else if (cards[i].point == maxpoint) maxtype = max(maxtype,cards[i].type);
		}
		//判断有没有炸弹或铁板
		for (int i = 1;i <= 10;i++)
			if (cnt[i] == 4)
			{
				zhadan = i;
				break;
			}
			else if (cnt[i] == 3)
			{
				tieban = i;
				niu = (sum - i * 3) % 10;
				if (niu == 0) niu = 10;
				break;
			}
		//判断有没有三张牌和为10
		//暴力枚举两张牌，剩下三张用sum快速判断
		for (int i = 0;i < 4;i++)
			for (int j = i + 1;j < 5;j++)
				if ((sum - (cards[i].point + cards[j].point)) % 10 == 0)
				{
				    int tmpn = niu;
					if ((cards[i].point + cards[j].point) % 10 != 0) niu = max(niu,(cards[i].point + cards[j].point) % 10);
					else niu = 10;
					if (tmpn < niu) tieban = 0;
				}
	}
	//清空所有信息
	void clear()
	{
		zhadan = 0;
		tieban = 0;
		niu = 0;
		sum = 0;
		maxpoint = 0;
		maxtype = 0;
		for (int i = 0;i < 5;i++)
			cards[i].point = cards[i].type = 0;
		for (int i = 1;i < 11;i++)
			cnt[i] = 0;
	}
};
//存储两个人的分数得失
struct score_info
{
	int first;
	int second;
};
//比较两个玩家的牌，若第一个赢则返回true
score_info cmp(const player& first,const player& second)
{
	//如果至少有一方有炸弹
	if (first.zhadan > 0 || second.zhadan > 0)
	{
		if (first.zhadan > second.zhadan) return {100,-100};
		else return {-100,100};
	}
	//如果牛数不相同
	if (first.niu > second.niu)
	{
		int tmpscore;
		if (first.niu == 10) tmpscore = 30;
		else if (first.niu >= 7) tmpscore = 20;
		else tmpscore = 10;
		if (first.tieban) tmpscore *= 2;
		return {tmpscore,-tmpscore};
	}
	else if (first.niu < second.niu)
	{
		int tmpscore;
		if (second.niu == 10) tmpscore = 30;
		else if (second.niu >= 7) tmpscore = 20;
		else tmpscore = 10;
		if (second.tieban) tmpscore *= 2;
		return {-tmpscore,tmpscore};
	}
	//牛数相同且均无炸弹
	//至少有一方有铁板
	if (first.tieban > 0 && second.tieban == 0)
	{
		if (first.niu == 10) return {60,-60};
		else if (first.niu >= 7) return {40,-40};
		else return {20,-20};
	}
	else if (first.tieban == 0 && second.tieban > 0)
	{
		if (second.niu == 10) return {-60,60};
		else if (second.niu >= 7) return {-40,40};
		else return {-20,20};
	}
	//双方都有铁板
	else if (first.tieban > 0 && second.tieban > 0)
	{
		int tmpscore;
		//由于现在已经可以判定first和second的牛数相同，所以用first.niu还是second.niu都行
		if (first.niu == 10) tmpscore = 60;
		else if (first.niu >= 7) tmpscore = 40;
		else tmpscore = 20;
		if (first.tieban > second.tieban) return {tmpscore,-tmpscore};
		else return {-tmpscore,tmpscore};
	}
	//双方均无铁板
	//如果双方最大的牌点数不同
	if (first.maxpoint != second.maxpoint)
	{
		int tmpscore;
		if (first.niu == 10) tmpscore = 30;
		else if (first.niu >= 7) tmpscore = 20;
		else tmpscore = 10;
		if (first.maxpoint > second.maxpoint) return {tmpscore,-tmpscore};
		else return {-tmpscore,tmpscore};
	}
	//则需要比较最大点数牌的花色
	int tmpscore;
	if (first.niu == 10) tmpscore = 30;
	else if (first.niu >= 7) tmpscore = 20;
	else tmpscore = 10;
	if (first.maxtype > second.maxtype) return {tmpscore,-tmpscore};
	else return {-tmpscore,tmpscore};
}
int t,n;
string stmp,name1,name2,name3;
string players[1000001];
unordered_map<string,player> mp;
unordered_map<string,long long> score;
score_info scoreinfotmp;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	//id对于想AC的人来说根本没用，所以直接忽略
	cin >> t >> t >> n;
	for (int i = 1;i <= n;i++)
		cin >> players[i];
	while (t--)
	{
		//读入
		cin >> name1;
		mp[name1].clear();
		for (int j = 0;j < 5;j++)
			mp[name1].cards[j].read();
		mp[name1].update_cardtype();
		cin >> name2;
		mp[name2].clear();
		for (int j = 0;j < 5;j++)
			mp[name2].cards[j].read();
		mp[name2].update_cardtype();
		cin >> name3;
		mp[name3].clear();
		for (int j = 0;j < 5;j++)
			mp[name3].cards[j].read();
		mp[name3].update_cardtype();
		//两两斗牛
		scoreinfotmp = cmp(mp[name1],mp[name2]);
		score[name1] += scoreinfotmp.first;
		score[name2] += scoreinfotmp.second;
		scoreinfotmp = cmp(mp[name1],mp[name3]);
		score[name1] += scoreinfotmp.first;
		score[name3] += scoreinfotmp.second;
		scoreinfotmp = cmp(mp[name2],mp[name3]);
		score[name2] += scoreinfotmp.first;
		score[name3] += scoreinfotmp.second;
	}
	for (int i = 1;i <= n;i++)
		cout << players[i] << ' ' << score[players[i]] << '\n';
}
```

---

## 作者：江户川·萝卜 (赞：1)

**注意，出题人脚造的第二个点中存在用 `1` 代表 `Ace` 牌的情况。**

----
大模拟常规操作：建立结构体/类。

这里我建了两个，分别是卡牌和玩家两个结构体。

```cpp
struct card{//创建card结构体
    char h;//花色
    int d;//点数
};
struct player{//创建player结构体
    string name;//名字
    card c[5];//存储玩家拥有的牌
    int px;//牌型
    int pt;//玩家的分数
    void pdpx();//判断牌型函数
    void cardempty(){
    	for(int i=0;i<5;i++) c[i].h=' ',c[i].d=0;
    	px=0;
    	return;
	};//清空玩家手牌 
}pl[100001];
```

其中 `pdpx` 函数是本题要实现的重点之一，下一部分单独讲。

----

`pdpx` 函数具体实现方法如下：

首先先把牌排序一下，这样方便找出相同的牌，也方便在之后判断大小的过程中快速判断。

牌大小以

> 点数更大的一方更大；若双方点数最大的一张牌点数相同，则花色更大的一方更大，花色大小为黑桃>红桃>梅花>方块。

为准。

之后暴力枚举三张牌组成10的倍数，算出牌型，特判一下铁板和炸弹。

注意：若铁板牌型比原来牌型要差，应选择原来牌型。
```cpp
bool cmp(card x, card y){
    return x.d>y.d||(x.d==y.d&&x.h<y.h);
    //点数从大到小排序，如点数一样，花色从小到大排序。 
    //因为黑桃(a)>红桃(b)>梅花(c)>方块(d)，所以从小到大 
}
void player::pdpx(){
    sort(c,c+5,cmp);
    int sum=0;
    for(int i=0;i<5;i++) sum+=c[i].d;//记录总和
    bool flag=false;
		for(int i=0;i<5&&!flag;i++)
			for(int j=i+1;j<5&&!flag;j++)
				for(int k=j+1;k<5&&!flag;k++){//枚举三张牌组成整十数
					if((c[i].d+c[j].d+c[k].d)%10==0){
						flag=true;
						px=(sum-1)%10+1;//算牛几
					}
				}
	if(!flag) px=0;
    int xt=1,st=0;//记录相同的数的个数 及 连续相同的数起始点 
    for(int i=1;i<5;i++){
        if(c[i].d==c[i-1].d) xt++;
        else {
			if(xt<3) xt=1,st=i;
        	else break;
        }
    }
    if(xt==3){//说明存在铁板
        if((sum-c[st].d*3-1)%10+1>=px){//若用铁板的牌型优于原牌型
    	    for(int i=0;i<=2;i++) swap(c[i],c[i+st]);//将铁板移至最前面 
    	    px=100+(c[3].d+c[4].d-1)%10+1;
    	}
    }
    else if(xt==4){//说明是炸弹
    	px=11;
		if(c[0].d!=c[1].d)//说明炸弹不在前四个而在后四个 
			for(int i=1;i<5;i++) swap(c[i],c[i-1]);//将单张移到最后  
	}
	return;
}
```
---
然后是计分函数。

感觉解释起来有点太过于冗长，配合如下代码食用。

```cpp
const int df=10;//底分
int a[12]={1,1,1,1,1,1,1,2,2,2,3,10};
//a数组存储每一种牌型的分数是底分的多少倍。
//0指无牛，1~9指牛一~牛九，10指牛牛，11指炸弹，100+x指铁板牛x。
void xwin(player &x,player &y){ 
    int s;
    s=a[x.px%100]/*除了铁板的分值*/*df*((x.px>100)+1)/*如是铁板乘2，否则乘1*/; 
    x.pt+=s;
    y.pt-=s;
    return;
}
void ywin(player &x,player &y){//同上 
    int s;
    s=a[y.px%100]*df*((y.px>100)+1);
    x.pt-=s;
    y.pt+=s;
    return;
}
void jf(player &x, player &y){
    if(x.px%100>y.px%100) xwin(x,y);//因为有铁板的关系，所以要%100
    else if(y.px%100>x.px%100) ywin(x,y);
    else if(y.px%100==x.px%100){//当牌型（去铁板）相同时
        if(y.px>100&&x.px<100) ywin(x,y);
        else if(y.px<100&&x.px>100) xwin(x,y);
        else if(y.px==x.px){//当双方都有/没有铁板时
			if(x.c[0].d>y.c[0].d) xwin(x,y);
            else if(y.c[0].d>x.c[0].d) ywin(x,y);
            else if(y.c[0].d==x.c[0].d){//当第一张牌点数相同时
                if(x.c[0].h<y.c[0].h) xwin(x,y);
                else ywin(x,y);
            }
        }
    }
    //cout<<x.px<<" "<<y.px<<" "<<x.pt<<" "<<y.pt<<endl;
    return;
}
```
---
最后就是输入输出处理一下。
```cpp
map<string,int> P;
void work(){
    int id;
	cin>>id>>T>>N;
	for(int i=1;i<=N;i++) {
		cin>>pl[i].name;P[pl[i].name]=i;//用map记录，快速找到名字对应编号
	}
	for(int k=1;k<=T;k++){
		string nm;//名字 
		string s;//牌
		int ds,p[3];//点数 存储玩家编号 
		for(int i=0;i<=2;i++){
			cin>>nm;
			p[i]=P[nm];
			pl[p[i]].cardempty();//清空
			for(int j=0;j<5;j++){
				cin>>s;
				pl[p[i]].c[j].h=s[0];
				if(s.length()==3) pl[p[i]].c[j].d=10;//形如a10，长度为3
				else if(s[1]=='A') pl[p[i]].c[j].d=1; 
				else pl[p[i]].c[j].d=s[1]-'0'; 
			}
			pl[p[i]].pdpx();
		}
		jf(pl[p[0]],pl[p[1]]);
		jf(pl[p[0]],pl[p[2]]);
		jf(pl[p[1]],pl[p[2]]);//三人轮流
	}
	for(int i=1;i<=N;i++) cout<<pl[i].name<<" "<<pl[i].pt<<'\n';
	return;
}
```

---


# 跑酷

## 题目背景

[赛时答疑](https://www.luogu.org/discuss/show/80694)  

跑酷这东西，还是得看人品的（比如 zm 和 mt）…

## 题目描述

在 Minecraft 中，跑酷可以算得上是一门技术了，Steve 现在想在一个跑道上（二维）进行跑酷。但是 Steve 不知道能不能跑到终点，于是他便查询了 MC Wiki，来获得更多的知识。内容具体如下：

### 生命值

1. 我们规定每个玩家的初始生命为 $20$ 点。
2. 掉落伤害的计算:
   - 如果玩家的高度为 $3$ 格或以下，免除此伤害。
   - 如果玩家的高度为 $4$ 格或以上，便会造成 $x-3$ 点伤害，$x$ 为摔落的高度。
   - 这里的高度均指相对高度，即当前方块与下一个方块之间的高度差。
3. 掉落伤害降低的情况：见特殊方块。

4. 当生命值为 $0$ 的时候，视为不能到达终点。

### 跑酷

1. 对于站在一个方块上的玩家来说，玩家最多可以往前面跳 $3$ 格并且可以往上跳一个格子。
2. 对于站在一个方块上的玩家来说，玩家最多也可以往前跳 $4$ 格，但是不能向上跳一个格子。
3. 为了计算方便，我们规定下落时玩家不会移动，也就是说，如果下一个方块比现在方块的高度要低的话，我们只能正好下落到下一个方块的位置。
4. 默认终点为最后一个方块。

### 特殊方块

1. **粘液块**：会使你跳跃至 $60\%$ 坠落距离的高度，如果有小数，我们向下取整。当你达到最高点的时候，只能往前再移动一格。当然，如果落在前方的方块上，同样要受到摔落伤害。你也可以按住 Shift 键来免除反弹。我们认为在粘液块上面进行跑酷不受减速的限制。  
2. **蜘蛛网**：下落时会让你免除伤害。我们也认为玩家在蜘蛛网上跑酷不受减速的限制。  

Steve 找到了你，让你帮他去解决这个问题。判断 Steve 能不能到达终点。

- 如果能到达终点，输出最少的跳跃次数；
- 如果不能到达终点，请输出：`qwq`。

## 说明/提示



### 数据范围及约定

数据保证输入的横坐标单调递增。每一个横坐标只有一格方块。

数据保证不会在相邻的横坐标中间出现两个特殊方块。

对于方块而言，默认是都没有浮空方块的存在；也就是说，所有方块下面都会有支撑柱。

为了方便，不能先跳跃再下落。也就是说，只能下落到前面一格的方块。

对于 $30\%$ 的数据 $n\le 10$；  
对于另外 $20\%$ 的数据，保证不存在特殊方块；  
对于这前面的 $50\%$ 的数据，保证 Steve 往前跳只能跳四格远或者三格远一格高；  
对于 $100\%$ 的数据 $1\le n\le 1000$，$1\le x_{\rm max}\le 10000$，$1\le height\le 1000$。

保证数据有一定梯度。

## 样例 #1

### 输入

```
2
1 4 P
4 5 P```

### 输出

```
1```

## 样例 #2

### 输入

```
3
1 6 P
2 4 N
3 4 P```

### 输出

```
0```

## 样例 #3

### 输入

```
2
5 8 P
7 11 P```

### 输出

```
qwq```

# 题解

## 作者：南城忆潇湘 (赞：7)

解法1：  
我有信仰，我是MC玩家，输出qwq，预计得分10分。

解法2:  
我会模拟，直接模拟，要么走4格，要么走3远一高，要么摔下去。预计得分50分。（qwq这都有50分惹）

解法3：  
我会广搜，直接广搜来搞。根据自己愿意模拟的程度来决定得分。预计得分20-80分。（我也不知道为啥有这么高分）

解法4：  
我会dp,$f[i][j]$表示到第$i$格方块，有$j$格血时候的最小跳跃次数。然后进行状态转移。  
第一种，这个格子为普通方块的时候：  
$f[i][j]=f[i-x][j]+1$  
第二种，这个格子比前面格子高的时候:  
$f[i][j]=f[i-x][j+shuailuo]$  
第三种，这个格子为粘液块的时候（最恶心的就是这种情况）  
$f[i+x2][j]=f[i-x1][j+shuailuo']$（当且仅当前面格子与这个格子差大于这个格子与后面格子高度差的$3/5$的时候）  
预计得分:100分

代码：（100pts）
```
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
struct block{
    int x,y;
    char p;
}a[10001];
int f[10001][21];
bool pd;
int shuailuo(int h){
    h=(h<=0)?-h:h;
    if(h<=3)	return 0;
    return h-3;
}
int main(){
    int n;
    cin>>n;
    memset(f,127,sizeof(f));
    for(int i=1;i<=n;i++)
        scanf("%d %d %c",&a[i].x,&a[i].y,&a[i].p);
    f[1][20]=0;
    for(int i=1;i<n;i++){	
        pd=1;
        for(int k=1;k<=20;k++)
            if(f[i][k]!=f[0][0])	pd=0;
        if(pd==1){
            cout<<"qwq";
            return 0;
        }
        for(int j=i+1;j<=n;j++){
            int h=a[j].y-a[i].y,w=a[j].x-a[i].x;//up
            if(w>4)	break;
            if((h>=0&&h<=1&&w>0&&w<=3)||(h==0&&w==4))
                for(int k=1;k<=20;k++)
                    f[j][k]=min(f[j][k],f[i][k]+1);
        }
        int h=a[i+1].y-a[i].y,w=a[i+1].x-a[i].x;
        if(h<0&&w==1){
              if(a[i+1].p=='P')
                   for(int k=shuailuo(h)+1;k<=20;k++)	
						f[i+1][k-shuailuo(h)]=min(f[i+1][k-shuailuo(h)],f[i][k]);
               if(a[i+1].p=='Z'||a[i+1].p=='N')
                    for(int k=1;k<=20;k++)	
                        f[i+1][k]=min(f[i+1][k],f[i][k]);
            } 
		if(a[i].p=='N'){
		int hl=a[i-1].y-a[i].y,wl=a[i].x-a[i-1].x,h=a[i+1].y-a[i].y;//down
            if(hl<=0||wl!=1)	continue;
            if(hl*3/5>=h){
                for(int k=shuailuo(hl*3/5-h)+1;k<=20;k++)
                    f[i+1][k-shuailuo(hl*3/5-h)]=min(f[i+1][k-shuailuo(hl*3/5-h)],f[i][k]);
            }
        }
    }
    int ans=999999;
    for(int k=1;k<=20;k++)
        ans=min(f[n][k],ans);
    if(ans==999999)	cout<<"qwq";
    else cout<<ans;
    return 0;
}
```

---

## 作者：书雪 (赞：1)

这道题题目描述的稍微有些问题，我来重新描述一下：

3格及3格以内可以跳高一格，

4格只能平着跳。

然后注意：题面描述的下落不能跳，指的是要向下跳时只能直挺挺地走下去，落到前面一格QAQ。

注意下落不算跳(这个坑了我好久)。

以方块为1维，体力为1维进行dp,```f[i][k]```表示第 $i$ 格 $k$ 血量时的最小跳跃次数，因为4格以上的距离跳不到，所以可以以第 $i$ 格为起跳点，看能不能跳到第 $j$ 格。

当3格以内向上跳或4格平着跳时，由于不会受到摔落伤害，所以

```f[j][k]=min(f[j][k],f[i][k]+1)```

当下落时，设第i格高度为h1，第j格高度为h2。

如果是普通方块：

```f[j][k-max(0,h1-h2-3)]=min(f[j][k-max(0,h1-h2-3)],f[i][k])```

如果是蜘蛛网：

```f[j][k]=min(f[j][k],f[i][k])```

如果是粘液块，判断两次：

第一次，不弹时：```f[j][k]=min(f[j][k],f[i][k])```

第二次，如果能弹，设 $j+1$ 格高度为 $h3$ ，弹起的高度为 $h4=(h1-h2)*0.6$  。

因为弹的过程中只能向前一步，所以

```f[j+1][k-max(0,h2+h4-h3-3)]=min(f[j+1][k-max(0,h2+h4-h3-3)],f[i][k])```


之后就没什么难的了，数据范围dp现象明显，就注意一下弹起的高度必须先向下取整，粘液块其实也不太难算，注释部分放到代码里，如下:
```
#include<bits/stdc++.h>
using namespace std;
int n,f[1010][30];
struct node{
	int h,l;
	char m;
}a[1010];
int main(){
	memset(f,0x3f3f3f3f,sizeof(f));//初始化
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i].l,&a[i].h);
		cin>>a[i].m;
	}
	f[1][20]=0;
	for(int i=1;i<n;i++){//因为它说输入的方块递增，所以按输入顺序进行dp
		if(i!=1){//判断如果这一个方块并不能被落到上边，就跳过这个方块。
			int aaa=20;
			for(int j=1;j<=20;j++){
				if(f[i][j]==0x3f3f3f3f) aaa--;
			}
			if(aaa==0) {
            continue;	
			}
		}
		for(int j=i+1;j<=min(i+4,n);j++){//向前跳
			
			int qwq1=a[j].h-a[i].h,qwq2=a[j].l-a[i].l;
			if(qwq2>4) break;//如果距离超过4，怎么也跳不到，跳过
			if(qwq2<4&&qwq1>1) break;//跳不到
			if(qwq2==4&&qwq1>0) break;//还是跳不到
			if(qwq2<4&&qwq1>=0){//如果向高跳，不失去体力
				for(int k=20;k>=1;k--){
					if(f[i][k]!=0x3f3f3f3f) f[j][k]=min(f[j][k],f[i][k]+1);//dp
				}
			}
			else if(qwq1<0&&qwq2==1){//下落
				if(a[j].m=='P'){
					for(int k=20;k>=1;k--){
						
						if(k-max(0,-1*qwq1-3)<0) break;//再跳就死了，不跳
						f[j][k-max(0,-1*qwq1-3)]=min(f[j][k-max(0,-1*qwq1-3)],f[i][k]);//dp
					}
				}
				else if(a[j].m=='Z'){
					for(int k=20;k>=1;k--){
						
						f[j][k]=min(f[j][k],f[i][k]);//不失去体力
					}
				}
				else if(a[j].m=='N'){
					int qwq3=-1*qwq1*0.6,qaq=max(0,qwq3); 
					for(int k=20;k>=1;k--){
						f[j][k]=min(f[j][k],f[i][k]);//如果不弹
						if(a[j+1].l==a[j].l+1&&qaq>=a[j+1].h-a[j].h){//如果可以弹
							f[j+1][k-max(0,qaq+a[j].h-a[j+1].h-3)]=min(f[i][k],f[j+1][k-max(0,qaq+a[j].h-a[j+1].h-3)]);
						}
					}
				}
			}
			if(qwq2==4&&qwq1==0){
				for(int k=20;k>=1;k--){
					if(f[i][k]!=0x3f3f3f3f) f[j][k]=min(f[j][k],f[i][k]+1);//平着跳，还是不损失体力
			}
		}
	}
	int ans=0x3f3f3f3f;
	for(int i=20;i>=1;i--){//取答案
		ans=min(ans,f[n][i]);
	}
	if(ans==0x3f3f3f3f) cout<<"qwq";
	else cout<<ans;
	return 0;
}
```

---


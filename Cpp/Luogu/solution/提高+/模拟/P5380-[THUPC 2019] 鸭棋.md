# [THUPC 2019] 鸭棋

## 题目描述

#### 题目背景

鸭棋是一种风靡鸭子界的棋类游戏。事实上，它与中国象棋有一些相似之处，但规则不尽相同。在这里，我们将为你介绍鸭棋的规则。

**同时，我们下发了一个模拟鸭棋规则的玩具，你可以结合这个玩具理解题目**（也可以在 AK 后与你的队友进行对弈）。详情请见「玩具使用说明」。

鸭棋在一个 $10\times 9$（$10$ 行 $9$ 列）的网格棋盘上进行，网格上的每个格点都可以有棋子停留。对弈双方一方执红（`red`）棋、另一方执蓝（`blue`）棋，双方轮流执行操作，轮到一位玩家操作时，他必须选择一枚自己的棋子，并按照规则进行一步移动。

鸭棋发明者鸭子德规定一局鸭棋由红方执先手，并设计了初始棋盘布局如下：

![initial_board.png](https://cdn.luogu.com.cn/upload/pic/58700.png)

##### 棋子类型与走子规则

棋子分为 $7$ 类，下面介绍了它们的名字以及它们的移动规则。介绍移动规则时，我们默认棋子所处位置为 $\left( x,y\right)$（表示第 $x$ 行的第 $y$ 列，下同），并列出它可以到达的位置：

* **王**（`captain`)：可达的位置共 $4$ 个，包括 $\left(x\pm 1,y\right)$ 及 $\left(x,y\pm 1\right)$。
* **士**（`guard`）：可达的位置共 $4$ 个，包括 $\left(x\pm 1,y\pm 1\right)$ 及 $\left(x\pm 1,y\mp 1\right)$。
* **象**（`elephant`）：可达的位置至多 $4$ 个，对于任意 $s_x,s_y\in \left\{ 1,-1\right\}$，分别有：
    * 如果位置 $\left(x+s_x\times 1 ,y+ s_y\times 1\right)$ 上**无任意一方**的棋子停留，则 $\left( x+s_x \times 2,y+s_y \times 2\right)$ 为一个可达的位置。
* **马**（`horse`）：可达的位置至多 $8$ 个，对于任意 $s_x,s_y\in \left\{ 1,-1\right\}$，分别有：
    * 如果位置 $\left(x+s_x\times 1 ,y\right)$ 上**无任意一方**的棋子停留，则 $\left( x+s_x \times 2,y+s_y \times 1\right)$ 为一个可达的位置。
    * 如果位置 $\left(x ,y+ s_y \times 1 \right)$ 上**无任意一方**的棋子停留，则 $\left( x+s_x \times 1,y+s_y \times 2\right)$ 为一个可达的位置。
* **车**（`car`）：可在**不跨越其他棋子**的前提下，到达同行或同列的所有其他位置。
* **鸭**（`duck`）：可达的位置至多 $8$ 个，对于任意 $s_x,s_y\in \left\{ 1,-1\right\}$，分别有：
    * 如果位置 $\left(x+s_x\times 2 ,y+s_y \times 1\right),\left(x+s_x\times 1 ,y\right)$ 上均**无任意一方**的棋子停留，则 $\left( x+s_x \times 3,y+s_y \times 2\right)$ 为一个可达的位置。
    * 如果位置 $\left(x+s_x \times 1 ,y+ s_y \times 2 \right),\left(x ,y+ s_y \times 1 \right)$ 上均**无任意一方**的棋子停留，则 $\left( x+s_x \times 2,y+s_y \times 3\right)$ 为一个可达的位置。
* **兵**（`soldier`）：可达的位置共 $8$ 个，包括 $\left(x\pm 1,y\right)$ 及 $\left(x,y\pm 1\right)$ 及 $\left(x\pm 1,y\pm 1\right)$ 及 $\left(x\pm 1,y\mp 1\right)$。

**除上面描述的规则之外，棋子移动还有如下额外规则：**

* 不能将棋子移动到棋盘外的某个位置。
* 玩家不能将棋子移动到**已经停留了己方棋子**的位置。
* 如果玩家将棋子移动到了一个**已经停留了对方棋子**的位置，那么原本停留在该位置上的这个**对方棋子**将被移出游戏。

##### 胜利条件与将军局面

玩家在这个游戏中的目标是将对方的**王**移出游戏。一旦一方的**王**被移出游戏，则另一方立即宣告胜利。

对于一个棋盘的状态，如果存在一方有一步合法的操作能够将另一方的**王**移出游戏，则我们说当前局面是一个**将军**的局面。需要友情提示的是，根据定义，将军局面的形成包括（但不限于）如下这些可能：

1. 一方将一枚棋子移动到可以攻击对方**王**的位置

2. 在己方**王**受到威胁时不采取措施躲避

3. 主动将**王**移动至会受到攻击的位置

**除此之外，需要特别说明的是，游戏结束后，由于双方不可再操作，因此不可能出现将军局面，即便此时另一方王处于被「攻击」的位置。**

#### 题目描述

今年的 IDCC（International Duck Chess Competition，国际鸭棋大赛）正在如火如荼地进行着。你观摩了一场精彩绝伦的比赛，但你对对弈过程的记忆已经模糊不清了，只有系统留下的他们的**操作序列**，序列中的每个**操作**为当前操作者试图移动某个位置的棋子至另一个位置。你希望用这个序列，来复现出整局棋局的对弈过程。即，对于每步操作，你需要**首先判其是否合法**，若合法，则**进一步求出**：

1. 这步操作移动了哪个棋子。
2. 这步操作后，是否存在棋子被移出游戏，如有则还需求出被移出游戏的棋子。
3. 这步操作后，是否形成将军局面。
4. 这步操作后，游戏是否结束。

可能包含的不合法情况如下：

* 此步移动的初始位置无己方棋子停留。
* 此步移动的初始位置有己方棋子停留，但移动不符合规则。
* 游戏已经结束。

序列中的不合法操作是需要被忽略的。比如，如果轮到红方移动，此时序列中的当前操作恰好是不合法的，则这个操作将被忽略，序列中的下一步操作将成为红方这步的操作（如仍不合法则继续忽略，直至出现合法的操作）。

## 说明/提示

##### 玩具使用说明

你可以在玩具所在目录下执行如下命令来运行玩具（链接: <https://pan.baidu.com/s/12MJGgZB9zKcE3qgRbRozGw> 提取码: 4d5c）：

```
./duckchess
```

特别地，在**初次运行前**，你需要执行如下命令为它添加运行权限：


```
chmod +x duckchess
```

##### 版权信息

来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。

## 样例 #1

### 输入

```
18
0 0 7 0
9 0 8 0
0 1 1 3
0 2 2 0
0 3 1 2
0 4 0 3
9 4 8 4
3 2 2 3
7 0 4 2
7 0 5 3
9 2 7 4
2 0 4 3
9 1 8 3
4 3 6 6
7 4 9 2
8 4 9 4
6 6 9 4
9 8 8 8```

### 输出

```
Invalid command
Invalid command
Invalid command
Invalid command
red guard;NA;no;no
Invalid command
blue captain;NA;no;no
red soldier;NA;no;no
Invalid command
Invalid command
blue elephant;NA;no;no
red duck;NA;no;no
blue horse;NA;no;no
red duck;blue soldier;no;no
Invalid command
blue captain;NA;yes;no
red duck;blue captain;no;yes
Invalid command```

# 题解

## 作者：Pengsibo (赞：231)

**距离CSP还有10天整的时候，发现自己的算法能力已经崩溃了，百般无奈之下开刷黑模拟，于是在三天之后有了这篇题解**

我们先整理一下题目大意：

1、这是一道模拟，模拟一种神奇的棋类游戏

2、棋盘和棋子题目已给出，记得多看几遍（其中鸭的移动方式更是需要好好理解）

3、输入是一堆操作，把(a,b)上的棋移到(c,d)上

4、输出分两种：不合法输出"Invalid command"，合法则输出移动的棋，被吃的棋，是否形成将军，游戏是否结束

**题意梳理完毕，那我们开始思索解决这道题的方法**

**1、用二维数组存储地图，用数字代替每一种棋（其实用字符也行，但比较麻烦）**
	
+ 我们大可以用1~7分别表示王，士，象，马，车，鸭，兵
+ 因为有红蓝方，我们可以通过十位是否为1来判断是哪一方

**2、移动步骤**

+ 看到好多大佬都像搜索那样存储移动，但我觉得太麻烦了，还不如在函数中判断当前棋子是哪一种，再直接枚举移动方式

**3、判断将军**

+ 一开始我的想法是将移动函数和将军函数合成一个，因为他们都可以利用棋子的移动判断 ~~(从而减少码量)~~ ,但后来咕了所以拆成了两个

**4、输出结果**

+ 输出结果其实不是很复杂，记录该次移动被吃的棋，最后输出就是了

**一道模拟题本来没有什么难度，但是为什么也能排成黑题呢？**

+ 有些人说，模拟题考察代码能力啊！ 我反对，因为代码能力指明白了算法后把它打出来，而不是单纯的暴力 ~~(像我就只会暴力算法垃圾)~~

+ 有些人说，模拟题考察人的耐心啊！我半赞成，因为有的模拟题真的是打着打着就不想做了

+ 那模拟题考察什么呢？

+ 我认为啊，模拟题考察人的整理和逻辑 (蒟蒻观点大佬勿喷)

+ 你要同时考虑很多的事情，比如这里需不需要特判，那里需不需要return，最后需不需要换行，中间是否要break等等

+ 所以，我将以蒟蒻的亲身体验，指出本题容易掉坑的一些地方:

**1、 每次移动的的时候记得将原来棋子所在的位置清零，并处理它要去的地方**

**2、注意处理红蓝关系的转换，以及棋盘的边界问题（被卡一次）**

**3、复制粘贴的时候记得进行彻底的修改，要不然这道题都打完了再去找非常痛苦（被卡三次，总计时间一天）**

**4、王被抓了以后判断游戏结束，但同时也要记录是哪个王被抓了（被卡一次）**

**5、每一次移动棋子的时候有很多的限制条件，其中马、象、鸭注意撇腿，车注意中间不能有子（马、鸭、车各被卡了一次）**

**6、这种大模拟一次写过很难，所以必定调试，注意有一些多余的不该出现的东西要删除（为此CE一次）**

那我们开始分析代码吧：

```
inline void init()			//初始化棋盘 
{
	mapp[0][4]=1,mapp[9][4]=11;
	mapp[0][3]=2,mapp[0][5]=2,mapp[9][3]=12,mapp[9][5]=12;
	mapp[0][2]=3,mapp[0][6]=3,mapp[9][2]=13,mapp[9][6]=13;
	mapp[0][1]=4,mapp[0][7]=4,mapp[9][1]=14,mapp[9][7]=14;
	mapp[0][0]=5,mapp[0][8]=5,mapp[9][0]=15,mapp[9][8]=15;
	mapp[2][0]=6,mapp[2][8]=6,mapp[7][0]=16,mapp[7][8]=16;
	mapp[3][0]=7,mapp[3][2]=7,mapp[3][4]=7,mapp[3][6]=7,mapp[3][8]=7;
	mapp[6][0]=17,mapp[6][2]=17,mapp[6][4]=17,mapp[6][6]=17,mapp[6][8]=17;
}
```

**主函数其实只需包含几个分函数**

```
int main()
{
	init();

	scanf("%d",&Q);
	
	for(register int i=1;i<=Q;i++)
	{
		scanf("%d%d%d%d",&a,&b,&c,&d);	//读入
		
		if(capture) {puts("Invalid command");continue;}	//如果游戏已结束，那后续操作都不合法
		
		initmove();	//初始化移动
		move();		//移动
	
		if(flagout) continue;	//如果移动中不合法则继续（输出在函数中判断）
		
		check();	//检查是否将军
		
		print();
		
		if(turn==0) turn=1;	//转换红蓝方
		else turn=0;
	}
	
	return 0;
}
```

**初始化：**

```
inline void initmove()		// 初始化 move() 
{
	gai=0;
	flagout=0;
	extra=0;
	capture=0;
	jiang=0;
}
```

**移动**
+ 关于移动，我打了一张大大的表
+ 在把表放出来之前，先说明几个define


```
#define out {flagout=1;puts("Invalid command");return;}
#define bounce (a>=0&&a<=9&&b>=0&&b<=8&&c>=0&&c<=9&&d>=0&&d<=8)
```

其中out是如果输入不合法，标记，输出，返回

bounce是确保起点终点都在边界之内


```
if(turn==1) extra=10;	//因为我用十位来判断红蓝方，所以蓝方则加十
```

+ 我们需要判断棋子的落点的子

+ 举个例子，如果落点没有子，那当然可以走

+ 如果红棋的落点为蓝棋，那也可以走

+ 但红棋落点为红棋就不能走

+ 所以：

```
bool fang(bool turn)		// 是哪一方在动 & bounce
{
	if(turn==0) return (mapp[c][d]==0||mapp[c][d]>10);
	else return (mapp[c][d]==0||mapp[c][d]<10);
}

```

+ 棋子落地之后我们要判断有无棋子被吃：


```
void lose(int c,int d)		//判断吞兵 
{
	if(mapp[c][d]==1) capture=1,gai=1;			//王被吃了标记
	else if(mapp[c][d]==11) capture=2,gai=11;
	else if(mapp[c][d]>10) gai=mapp[c][d],lan--;	//标记被吃的棋
	else if(mapp[c][d]>0) gai=mapp[c][d],hong--;	//hong和lan用来计数，但发现其实没有什么用
}
```

+ 最后我们要把棋子放过去


```
void exchange(int e,int extra)
{
	mapp[a][b]=0,mapp[c][d]=e+extra;
	which=e+extra;
}
```

**该放表了**


```
inline void move()
{
	//条件 ：符合该棋的移动 路上||终点无棋 终点敌方？ 没越界
	
	if(turn==1) extra=10;
	
	if(mapp[a][b]==1+extra)
	{
		if(bounce==0) out		//前面提到 边界
		if(c-a==1&&b==d&&fang(turn)) 	{lose(c,d);exchange(1,extra);return;}	//符合移动规则和移动方，则判断吃子和移动
		if(a-c==1&&b==d&&fang(turn)) {lose(c,d);exchange(1,extra);return;}
		if(a==c&&b-d==1&&fang(turn)) {lose(c,d);exchange(1,extra);return;}
		if(a==c&&d-b==1&&fang(turn)) {lose(c,d);exchange(1,extra);return;}
		out
	}
	
	if(mapp[a][b]==2+extra)
	{
		if(bounce==0) out
		if(c-a==1&&b-d==1&&fang(turn)) {lose(c,d);exchange(2,extra);return;}
		if(a-c==1&&b-d==1&&fang(turn)) {lose(c,d);exchange(2,extra);return;}
		if(c-a==1&&d-b==1&&fang(turn)) {lose(c,d);exchange(2,extra);return;}
		if(a-c==1&&d-b==1&&fang(turn)) {lose(c,d);exchange(2,extra);return;}
		out
	}
	
	if(mapp[a][b]==3+extra)
	{
		if(bounce==0) out
		if(c==a+2&&d==b+2&&fang(turn)&&mapp[a+1][b+1]==0) {lose(c,d);exchange(3,extra);return;}
		if(c==a+2&&d==b-2&&fang(turn)&&mapp[a+1][b-1]==0) {lose(c,d);exchange(3,extra);return;}
		if(c==a-2&&d==b+2&&fang(turn)&&mapp[a-1][b+1]==0) {lose(c,d);exchange(3,extra);return;}
		if(c==a-2&&d==b-2&&fang(turn)&&mapp[a-1][b-1]==0) {lose(c,d);exchange(3,extra);return;}
		out
	}
	
	if(mapp[a][b]==4+extra)
	{
		if(bounce==0) out
		if(c-a==2&&d-b==1&&fang(turn)&&mapp[a+1][b]==0) {lose(c,d);exchange(4,extra);return;}
		if(c-a==1&&d-b==2&&fang(turn)&&mapp[a][b+1]==0) {lose(c,d);exchange(4,extra);return;}
		if(c-a==-1&&d-b==2&&fang(turn)&&mapp[a][b+1]==0) {lose(c,d);exchange(4,extra);return;}
		if(c-a==-2&&d-b==1&&fang(turn)&&mapp[a-1][b]==0) {lose(c,d);exchange(4,extra);return;}
		if(c-a==-2&&d-b==-1&&fang(turn)&&mapp[a-1][b]==0) {lose(c,d);exchange(4,extra);return;}
		if(c-a==-1&&d-b==-2&&fang(turn)&&mapp[a][b-1]==0) {lose(c,d);exchange(4,extra);return;}
		if(c-a==1&&d-b==-2&&fang(turn)&&mapp[a][b-1]==0) {lose(c,d);exchange(4,extra);return;}
		if(c-a==2&&d-b==-1&&fang(turn)&&mapp[a+1][b]==0) {lose(c,d);exchange(4,extra);return;}
		out
	}
	
	if(mapp[a][b]==5+extra)
	{
		if(bounce==0) out
		if(a==c)
		{	
			if(d>b)
			{
				for(register int i=b+1;i<d;i++) if(mapp[a][i]) out					//有障碍 
				if(fang(turn)) {lose(c,d);exchange(5,extra);return;}			//判断吃，更新 
			}
			
			else if(d<b)
			{
				for(register int i=b-1;i>d;i--) if(mapp[a][i]) out
				if(fang(turn)) {lose(c,d);exchange(5,extra);return;}
			}
			
			else out
		}
		
		else if(b==d)
		{
			if(c>a)
			{
				for(register int i=a+1;i<c;i++) 
				if(mapp[i][b]) out
				if(fang(turn)) {lose(c,d);exchange(5,extra);return;}
			}
			
			else if(c<a)
			{
				for(register int i=a-1;i>c+1;i--)
				if(mapp[i][b]) out
				if(fang(turn)) {lose(c,d);exchange(5,extra);return;}
			}
			
			else out
		}
		
		else out
	}
	
	if(mapp[a][b]==6+extra)		//这里一定要仔细。。。
	{
		if(bounce==0) out
		if(c-a==2&&d-b==3&&fang(turn)&&mapp[a][b+1]==0&&mapp[a+1][b+2]==0) {lose(c,d);exchange(6,extra);return;}
		if(c-a==3&&d-b==2&&fang(turn)&&mapp[a+1][b]==0&&mapp[a+2][b+1]==0) {lose(c,d);exchange(6,extra);return;}
		if(c-a==-2&&d-b==3&&fang(turn)&&mapp[a][b+1]==0&&mapp[a-1][b+2]==0) {lose(c,d);exchange(6,extra);return;}
		if(c-a==-3&&d-b==2&&fang(turn)&&mapp[a-1][b]==0&&mapp[a-2][b+1]==0) {lose(c,d);exchange(6,extra);return;}
		if(c-a==2&&d-b==-3&&fang(turn)&&mapp[a][b-1]==0&&mapp[a+1][b-2]==0) {lose(c,d);exchange(6,extra);return;}
		if(c-a==3&&d-b==-2&&fang(turn)&&mapp[a+1][b]==0&&mapp[a+2][b-1]==0) {lose(c,d);exchange(6,extra);return;}
		if(c-a==-2&&d-b==-3&&fang(turn)&&mapp[a][b-1]==0&&mapp[a-1][b-2]==0) {lose(c,d);exchange(6,extra);return;}
		if(c-a==-3&&d-b==-2&&fang(turn)&&mapp[a-1][b]==0&&mapp[a-2][b-1]==0) {lose(c,d);exchange(6,extra);return;}
		out
	}
	
	if(mapp[a][b]==7+extra)
	{
		if(bounce==0) out
		if(c-a==1&&b==d&&fang(turn)) {lose(c,d);exchange(7,extra);return;}
		if(a-c==1&&b==d&&fang(turn)) {lose(c,d);exchange(7,extra);return;}
		if(a==c&&b-d==1&&fang(turn)) {lose(c,d);exchange(7,extra);return;}
		if(a==c&&d-b==1&&fang(turn)) {lose(c,d);exchange(7,extra);return;}
		if(c-a==1&&b-d==1&&fang(turn)) {lose(c,d);exchange(7,extra);return;}
		if(a-c==1&&b-d==1&&fang(turn)) {lose(c,d);exchange(7,extra);return;}
		if(c-a==1&&d-b==1&&fang(turn)) {lose(c,d);exchange(7,extra);return;}
		if(a-c==1&&d-b==1&&fang(turn)) {lose(c,d);exchange(7,extra);return;}
		out
	}
	
	out
}
```

**接下来是判断将军**

+ 其实我们发现，将军函数的代码和move中大部分重合

+ 其实我们发现，将军函数本可以和move结合

+ 但我就不 ~~(原因是我这么写然后写挂了改了半个小时才改回来)~~


```
inline void check()			// 检查将军 
{
	for(register int i=0;i<=9;i++)
	{
		for(register int j=0;j<=8;j++)		//暴力枚举每一个点
		{
			if(mapp[i][j]==0) continue;
			
			checkmate(i,j);					//有棋则搜
			
			if(jiang) return;				//如果搜到了也就没必要继续了
		}
	}
}
```

+ 再来一个define


```
#define checkok {jiang=1;return;}	//符合将军条件则标记，返回
```

**放表：**


```
inline void checkmate(int p,int q)
{
	if(mapp[p][q]>10) checkturn=1,checkextra=10;	//checkturn是这颗棋的目标,checkextra和move中的extra同理
	else checkturn=11,checkextra=0;
	
	if(mapp[p][q]==1+checkextra)
	{
		if(mapp[p+1][q]==checkturn&&0<=p+1&&p+1<=9&&0<=q&&q<=8) checkok		//一定要判断边界
		if(mapp[p-1][q]==checkturn&&0<=p-1&&p-1<=9&&0<=q&&q<=8) checkok		//虽然理论上不判断也可以
		if(mapp[p][q+1]==checkturn&&0<=p&&p<=9&&0<=q+1&&q+1<=8) checkok		//因为边界之外的棋不会有目标编号
		if(mapp[p][q-1]==checkturn&&0<=p&&p<=9&&0<=q-1&&q-1<=8) checkok		//但是我没判断就是死了，所以。。。
	}
	
	if(mapp[p][q]==2+checkextra)
	{
		if(mapp[p+1][q+1]==checkturn&&0<=p+1&&p+1<=9&&0<=q+1&&q+1<=8) checkok
		if(mapp[p-1][q+1]==checkturn&&0<=p-1&&p-1<=9&&0<=q+1&&q+1<=8) checkok
		if(mapp[p+1][q-1]==checkturn&&0<=p+1&&p+1<=9&&0<=q-1&&q-1<=8) checkok
		if(mapp[p-1][q-1]==checkturn&&0<=p-1&&p-1<=9&&0<=q-1&&q-1<=8) checkok
	}
	
	if(mapp[p][q]==3+checkextra)
	{
		if(mapp[p+2][q+2]==checkturn&&mapp[p+1][q+1]==0&&0<=p+2&&p+2<=9&&0<=q+2&&q+2<=8) checkok
		if(mapp[p-2][q+2]==checkturn&&mapp[p-1][q+1]==0&&0<=p-2&&p-2<=9&&0<=q+2&&q+2<=8) checkok
		if(mapp[p+2][q-2]==checkturn&&mapp[p+1][q-1]==0&&0<=p+2&&p+2<=9&&0<=q-2&&q-2<=8) checkok
		if(mapp[p-2][q-2]==checkturn&&mapp[p-1][q-1]==0&&0<=p-2&&p-2<=9&&0<=q-2&&q-2<=8) checkok
	}
	
	if(mapp[p][q]==4+checkextra)
	{
		if(mapp[p+1][q+2]==checkturn&&mapp[p][q+1]==0&&0<=p+1&&p+1<=9&&0<=q+2&&q+2<=8) checkok
		if(mapp[p+2][q+1]==checkturn&&mapp[p+1][q]==0&&0<=p+2&&p+2<=9&&0<=q+1&&q+1<=8) checkok
		if(mapp[p+2][q-1]==checkturn&&mapp[p+1][q]==0&&0<=p+2&&p+2<=9&&0<=q-1&&q-1<=8) checkok
		if(mapp[p+1][q-2]==checkturn&&mapp[p][q-1]==0&&0<=p+1&&p+1<=9&&0<=q-2&&q-2<=8) checkok
		if(mapp[p-1][q-2]==checkturn&&mapp[p][q-1]==0&&0<=p-1&&p-1<=9&&0<=q-2&&q-2<=8) checkok
		if(mapp[p-2][q-1]==checkturn&&mapp[p-1][q]==0&&0<=p-2&&p-2<=9&&0<=q-1&&q-1<=8) checkok
		if(mapp[p-2][q+1]==checkturn&&mapp[p-1][q]==0&&0<=p-2&&p-2<=9&&0<=q+1&&q+1<=8) checkok
		if(mapp[p-1][q+2]==checkturn&&mapp[p][q+1]==0&&0<=p-1&&p-1<=9&&0<=q+2&&q+2<=8) checkok
	}
	
	if(mapp[p][q]==5+checkextra)
	{
		for(register int i=p+1;i<=9;i++)
		{
			if(mapp[i][q]==checkturn) checkok
			if(mapp[i][q]!=0) return;
		}
		
		for(register int i=p-1;i>=0;i--)
		{
			if(mapp[i][q]==checkturn) checkok
			if(mapp[i][q]!=0) return;
		}
		
		for(register int i=q+1;i<=8;i++)
		{
			if(mapp[p][i]==checkturn) checkok
			if(mapp[p][i]!=0) return;
		}
		
		for(register int i=q-1;i>=0;i--)
		{
			if(mapp[p][i]==checkturn) checkok
			if(mapp[p][i]!=0) return;
		}
	}
	
	if(mapp[p][q]==6+checkextra)
	{
		if(mapp[p+2][q+3]==checkturn&&mapp[p][q+1]==0&&mapp[p+1][q+2]==0&&0<=p+2&&p+2<=9&&0<=q+3&&q+3<=8) checkok
		if(mapp[p+3][q+2]==checkturn&&mapp[p+1][q]==0&&mapp[p+2][q+1]==0&&0<=p+3&&p+3<=9&&0<=q+2&&q+2<=8) checkok
		if(mapp[p+3][q-2]==checkturn&&mapp[p+1][q]==0&&mapp[p+2][q-1]==0&&0<=p+3&&p+3<=9&&0<=q-2&&q-2<=8) checkok
		if(mapp[p+2][q-3]==checkturn&&mapp[p][q-1]==0&&mapp[p+1][q-2]==0&&0<=p+2&&p+2<=9&&0<=q-3&&q-3<=8) checkok
		if(mapp[p-2][q-3]==checkturn&&mapp[p][q-1]==0&&mapp[p-1][q-2]==0&&0<=p-2&&p-2<=9&&0<=q-3&&q-3<=8) checkok
		if(mapp[p-3][q-2]==checkturn&&mapp[p-1][q]==0&&mapp[p-2][q-1]==0&&0<=p-3&&p-3<=9&&0<=q-2&&q-2<=8) checkok
		if(mapp[p-3][q+2]==checkturn&&mapp[p-1][q]==0&&mapp[p-2][q+1]==0&&0<=p-3&&p-3<=9&&0<=q+2&&q+2<=8) checkok
		if(mapp[p-2][q+3]==checkturn&&mapp[p][q+1]==0&&mapp[p-1][q+2]==0&&0<=p-2&&p-2<=9&&0<=q+3&&q+3<=8) checkok
	}
	
	if(mapp[p][q]==7+checkextra)
	{
		if(mapp[p+1][q]==checkturn&&0<=p+1&&p+1<=9&&0<=q&&q<=8) checkok
		if(mapp[p-1][q]==checkturn&&0<=p-1&&p-1<=9&&0<=q&&q<=8) checkok
		if(mapp[p][q+1]==checkturn&&0<=p&&p<=9&&0<=q+1&&q+1<=8) checkok
		if(mapp[p][q-1]==checkturn&&0<=p&&p<=9&&0<=q-1&&q-1<=8) checkok
		if(mapp[p+1][q+1]==checkturn&&0<=p+1&&p+1<=9&&0<=q+1&&q+1<=8) checkok
		if(mapp[p-1][q+1]==checkturn&&0<=p-1&&p-1<=9&&0<=q+1&&q+1<=8) checkok
		if(mapp[p+1][q-1]==checkturn&&0<=p+1&&p+1<=9&&0<=q-1&&q-1<=8) checkok
		if(mapp[p-1][q-1]==checkturn&&0<=p-1&&p-1<=9&&0<=q-1&&q-1<=8) checkok
	}
}
```

**最后我们来输出**


```
inline void print()			//输出 
{
	if(mapp[c][d]==1) printf("red captain;");		//直接判终点的那颗棋
	else if(mapp[c][d]==2) printf("red guard;");		//因为在起点的那颗被移过来了
	else if(mapp[c][d]==3) printf("red elephant;");
	else if(mapp[c][d]==4) printf("red horse;");
	else if(mapp[c][d]==5) printf("red car;");
	else if(mapp[c][d]==6) printf("red duck;");
	else if(mapp[c][d]==7) printf("red soldier;");
	else if(mapp[c][d]==11) printf("blue captain;");
	else if(mapp[c][d]==12) printf("blue guard;");
	else if(mapp[c][d]==13) printf("blue elephant;");
	else if(mapp[c][d]==14) printf("blue horse;");
	else if(mapp[c][d]==15) printf("blue car;");
	else if(mapp[c][d]==16) printf("blue duck;");
	else if(mapp[c][d]==17) printf("blue soldier;");
	
	if(gai==1) printf("red captain;");		//gai记录被修改的
	else if(gai==2) printf("red guard;");
	else if(gai==3) printf("red elephant;");
	else if(gai==4) printf("red horse;");
	else if(gai==5) printf("red car;");
	else if(gai==6) printf("red duck;");
	else if(gai==7) printf("red soldier;");
	else if(gai==11) printf("blue captain;");
	else if(gai==12) printf("blue guard;");
	else if(gai==13) printf("blue elephant;");
	else if(gai==14) printf("blue horse;");
	else if(gai==15) printf("blue car;");
	else if(gai==16) printf("blue duck;");
	else if(gai==17) printf("blue soldier;");
	else printf("NA;");						//注意没有的话输出NA
	
	if(capture==0&&jiang) printf("yes;");
	else printf("no;");
	
	if(capture) puts("yes");				//注意这里输出没有分号！！！
	else puts("no");
}
```

**于是我们愉快的A掉了这道题**


**放代码（我提交的时候的代码，内含我写这道题时自己放的注释）：**


```
//记得每次移动前加 lose(c,d) 
//注意转换turn 
//注意移动时清空之前的格子 
//复制粘贴时记得进行必要修改 
//注意棋盘的边界 

//check时修改extra
//发现其实extra是turn的10倍，但是懒得改了
//记得captain被抓了也要标记修改了哪颗棋 
//记得动车的时候fang()

#include <bits/stdc++.h>
//#include <windows.h>																//////////////
using namespace std;
#define out {flagout=1;puts("Invalid command");return;}
#define bounce (a>=0&&a<=9&&b>=0&&b<=8&&c>=0&&c<=9&&d>=0&&d<=8)
#define checkok {jiang=1;return;}													//////////


int Q;
int a,b,c,d;
																							// 全局变量区
																							
																							
int mapp[12][12];						//列 行 : 如 mapp[4][3]表红方第二个兵 
bool turn=0;		// 红0 蓝1		//王1 士2 象3 马4 车5 鸭6 兵7  红单位，蓝双位

int checkturn;		//记录check的时候对方的王 
int hong=16,lan=16,gai;		//总兵数  被吃兵 
																							// 红蓝变量区
																							
																							
bool flagout;	//判断是否被out掉 
bool capture=0,jiang=0;	// 1为被抓/将军
int extra,checkextra;		// move的时候结果是什么兵的修改
int which;		// move的时候调用的什么兵 
																							//特殊辅助区 
										
//int yhong=1,ylan=2,ybai=3;													
//void Color(int a){
//    if(a==1) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED);
//    if(a==2) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_BLUE|FOREGROUND_GREEN);
//    if(a==3) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_GREEN|FOREGROUND_BLUE|FOREGROUND_RED);
//}


inline void init()			//初始化棋盘 
{
	mapp[0][4]=1,mapp[9][4]=11;
	mapp[0][3]=2,mapp[0][5]=2,mapp[9][3]=12,mapp[9][5]=12;
	mapp[0][2]=3,mapp[0][6]=3,mapp[9][2]=13,mapp[9][6]=13;
	mapp[0][1]=4,mapp[0][7]=4,mapp[9][1]=14,mapp[9][7]=14;
	mapp[0][0]=5,mapp[0][8]=5,mapp[9][0]=15,mapp[9][8]=15;
	mapp[2][0]=6,mapp[2][8]=6,mapp[7][0]=16,mapp[7][8]=16;
	mapp[3][0]=7,mapp[3][2]=7,mapp[3][4]=7,mapp[3][6]=7,mapp[3][8]=7;
	mapp[6][0]=17,mapp[6][2]=17,mapp[6][4]=17,mapp[6][6]=17,mapp[6][8]=17;
}

void lose(int c,int d)		//判断吞兵 
{
	if(mapp[c][d]==1) capture=1,gai=1;
	else if(mapp[c][d]==11) capture=2,gai=11;
	else if(mapp[c][d]>10) gai=mapp[c][d],lan--;
	else if(mapp[c][d]>0) gai=mapp[c][d],hong--;
}

bool fang(bool turn)		// 是哪一方在动 & bounce
{
	if(turn==0) return (mapp[c][d]==0||mapp[c][d]>10);
	else return (mapp[c][d]==0||mapp[c][d]<10);
}

void exchange(int e,int extra)
{
	mapp[a][b]=0,mapp[c][d]=e+extra;
	which=e+extra;
}

inline void move()
{
	//条件 ：符合该棋的移动 路上||终点无棋 终点敌方？ 没越界
	
	if(turn==1) extra=10;
	
	if(mapp[a][b]==1+extra)
	{
		if(bounce==0) out
		if(c-a==1&&b==d&&fang(turn)) {lose(c,d);exchange(1,extra);return;}
		if(a-c==1&&b==d&&fang(turn)) {lose(c,d);exchange(1,extra);return;}
		if(a==c&&b-d==1&&fang(turn)) {lose(c,d);exchange(1,extra);return;}
		if(a==c&&d-b==1&&fang(turn)) {lose(c,d);exchange(1,extra);return;}
		out
	}
	
	if(mapp[a][b]==2+extra)
	{
		if(bounce==0) out
		if(c-a==1&&b-d==1&&fang(turn)) {lose(c,d);exchange(2,extra);return;}
		if(a-c==1&&b-d==1&&fang(turn)) {lose(c,d);exchange(2,extra);return;}
		if(c-a==1&&d-b==1&&fang(turn)) {lose(c,d);exchange(2,extra);return;}
		if(a-c==1&&d-b==1&&fang(turn)) {lose(c,d);exchange(2,extra);return;}
		out
	}
	
	if(mapp[a][b]==3+extra)
	{
		if(bounce==0) out
		if(c==a+2&&d==b+2&&fang(turn)&&mapp[a+1][b+1]==0) {lose(c,d);exchange(3,extra);return;}
		if(c==a+2&&d==b-2&&fang(turn)&&mapp[a+1][b-1]==0) {lose(c,d);exchange(3,extra);return;}
		if(c==a-2&&d==b+2&&fang(turn)&&mapp[a-1][b+1]==0) {lose(c,d);exchange(3,extra);return;}
		if(c==a-2&&d==b-2&&fang(turn)&&mapp[a-1][b-1]==0) {lose(c,d);exchange(3,extra);return;}
		out
	}
	
	if(mapp[a][b]==4+extra)
	{
		if(bounce==0) out
		if(c-a==2&&d-b==1&&fang(turn)&&mapp[a+1][b]==0) {lose(c,d);exchange(4,extra);return;}
		if(c-a==1&&d-b==2&&fang(turn)&&mapp[a][b+1]==0) {lose(c,d);exchange(4,extra);return;}
		if(c-a==-1&&d-b==2&&fang(turn)&&mapp[a][b+1]==0) {lose(c,d);exchange(4,extra);return;}
		if(c-a==-2&&d-b==1&&fang(turn)&&mapp[a-1][b]==0) {lose(c,d);exchange(4,extra);return;}
		if(c-a==-2&&d-b==-1&&fang(turn)&&mapp[a-1][b]==0) {lose(c,d);exchange(4,extra);return;}
		if(c-a==-1&&d-b==-2&&fang(turn)&&mapp[a][b-1]==0) {lose(c,d);exchange(4,extra);return;}
		if(c-a==1&&d-b==-2&&fang(turn)&&mapp[a][b-1]==0) {lose(c,d);exchange(4,extra);return;}
		if(c-a==2&&d-b==-1&&fang(turn)&&mapp[a+1][b]==0) {lose(c,d);exchange(4,extra);return;}
		out
	}
	
	if(mapp[a][b]==5+extra)
	{
		if(bounce==0) out
		if(a==c)
		{	
			if(d>b)
			{
				for(register int i=b+1;i<d;i++) if(mapp[a][i]) out					//有障碍 
				if(fang(turn)) {lose(c,d);exchange(5,extra);return;}			//判断吃，更新 
			}
			
			else if(d<b)
			{
				for(register int i=b-1;i>d;i--) if(mapp[a][i]) out
				if(fang(turn)) {lose(c,d);exchange(5,extra);return;}
			}
			
			else out
		}
		
		else if(b==d)
		{
			if(c>a)
			{
				for(register int i=a+1;i<c;i++) 
				if(mapp[i][b]) out
				if(fang(turn)) {lose(c,d);exchange(5,extra);return;}
			}
			
			else if(c<a)
			{
				for(register int i=a-1;i>c+1;i--)
				if(mapp[i][b]) out
				if(fang(turn)) {lose(c,d);exchange(5,extra);return;}
			}
			
			else out
		}
		
		else out
	}
	
	if(mapp[a][b]==6+extra)
	{
		if(bounce==0) out
		if(c-a==2&&d-b==3&&fang(turn)&&mapp[a][b+1]==0&&mapp[a+1][b+2]==0) {lose(c,d);exchange(6,extra);return;}
		if(c-a==3&&d-b==2&&fang(turn)&&mapp[a+1][b]==0&&mapp[a+2][b+1]==0) {lose(c,d);exchange(6,extra);return;}
		if(c-a==-2&&d-b==3&&fang(turn)&&mapp[a][b+1]==0&&mapp[a-1][b+2]==0) {lose(c,d);exchange(6,extra);return;}
		if(c-a==-3&&d-b==2&&fang(turn)&&mapp[a-1][b]==0&&mapp[a-2][b+1]==0) {lose(c,d);exchange(6,extra);return;}
		if(c-a==2&&d-b==-3&&fang(turn)&&mapp[a][b-1]==0&&mapp[a+1][b-2]==0) {lose(c,d);exchange(6,extra);return;}
		if(c-a==3&&d-b==-2&&fang(turn)&&mapp[a+1][b]==0&&mapp[a+2][b-1]==0) {lose(c,d);exchange(6,extra);return;}
		if(c-a==-2&&d-b==-3&&fang(turn)&&mapp[a][b-1]==0&&mapp[a-1][b-2]==0) {lose(c,d);exchange(6,extra);return;}
		if(c-a==-3&&d-b==-2&&fang(turn)&&mapp[a-1][b]==0&&mapp[a-2][b-1]==0) {lose(c,d);exchange(6,extra);return;}
		out
	}
	
	if(mapp[a][b]==7+extra)
	{
		if(bounce==0) out
		if(c-a==1&&b==d&&fang(turn)) {lose(c,d);exchange(7,extra);return;}
		if(a-c==1&&b==d&&fang(turn)) {lose(c,d);exchange(7,extra);return;}
		if(a==c&&b-d==1&&fang(turn)) {lose(c,d);exchange(7,extra);return;}
		if(a==c&&d-b==1&&fang(turn)) {lose(c,d);exchange(7,extra);return;}
		if(c-a==1&&b-d==1&&fang(turn)) {lose(c,d);exchange(7,extra);return;}
		if(a-c==1&&b-d==1&&fang(turn)) {lose(c,d);exchange(7,extra);return;}
		if(c-a==1&&d-b==1&&fang(turn)) {lose(c,d);exchange(7,extra);return;}
		if(a-c==1&&d-b==1&&fang(turn)) {lose(c,d);exchange(7,extra);return;}
		out
	}
	
	out
}

inline void initmove()		// 初始化 move() 
{
	gai=0;
	flagout=0;
	extra=0;
	capture=0;
	jiang=0;
}

inline void checkmate(int p,int q)
{
	if(mapp[p][q]>10) checkturn=1,checkextra=10;
	else checkturn=11,checkextra=0;
	
	if(mapp[p][q]==1+checkextra)
	{
		if(mapp[p+1][q]==checkturn&&0<=p+1&&p+1<=9&&0<=q&&q<=8) checkok
		if(mapp[p-1][q]==checkturn&&0<=p-1&&p-1<=9&&0<=q&&q<=8) checkok
		if(mapp[p][q+1]==checkturn&&0<=p&&p<=9&&0<=q+1&&q+1<=8) checkok
		if(mapp[p][q-1]==checkturn&&0<=p&&p<=9&&0<=q-1&&q-1<=8) checkok
	}
	
	if(mapp[p][q]==2+checkextra)
	{
		if(mapp[p+1][q+1]==checkturn&&0<=p+1&&p+1<=9&&0<=q+1&&q+1<=8) checkok
		if(mapp[p-1][q+1]==checkturn&&0<=p-1&&p-1<=9&&0<=q+1&&q+1<=8) checkok
		if(mapp[p+1][q-1]==checkturn&&0<=p+1&&p+1<=9&&0<=q-1&&q-1<=8) checkok
		if(mapp[p-1][q-1]==checkturn&&0<=p-1&&p-1<=9&&0<=q-1&&q-1<=8) checkok
	}
	
	if(mapp[p][q]==3+checkextra)
	{
		if(mapp[p+2][q+2]==checkturn&&mapp[p+1][q+1]==0&&0<=p+2&&p+2<=9&&0<=q+2&&q+2<=8) checkok
		if(mapp[p-2][q+2]==checkturn&&mapp[p-1][q+1]==0&&0<=p-2&&p-2<=9&&0<=q+2&&q+2<=8) checkok
		if(mapp[p+2][q-2]==checkturn&&mapp[p+1][q-1]==0&&0<=p+2&&p+2<=9&&0<=q-2&&q-2<=8) checkok
		if(mapp[p-2][q-2]==checkturn&&mapp[p-1][q-1]==0&&0<=p-2&&p-2<=9&&0<=q-2&&q-2<=8) checkok
	}
	
	if(mapp[p][q]==4+checkextra)
	{
		if(mapp[p+1][q+2]==checkturn&&mapp[p][q+1]==0&&0<=p+1&&p+1<=9&&0<=q+2&&q+2<=8) checkok
		if(mapp[p+2][q+1]==checkturn&&mapp[p+1][q]==0&&0<=p+2&&p+2<=9&&0<=q+1&&q+1<=8) checkok
		if(mapp[p+2][q-1]==checkturn&&mapp[p+1][q]==0&&0<=p+2&&p+2<=9&&0<=q-1&&q-1<=8) checkok
		if(mapp[p+1][q-2]==checkturn&&mapp[p][q-1]==0&&0<=p+1&&p+1<=9&&0<=q-2&&q-2<=8) checkok
		if(mapp[p-1][q-2]==checkturn&&mapp[p][q-1]==0&&0<=p-1&&p-1<=9&&0<=q-2&&q-2<=8) checkok
		if(mapp[p-2][q-1]==checkturn&&mapp[p-1][q]==0&&0<=p-2&&p-2<=9&&0<=q-1&&q-1<=8) checkok
		if(mapp[p-2][q+1]==checkturn&&mapp[p-1][q]==0&&0<=p-2&&p-2<=9&&0<=q+1&&q+1<=8) checkok
		if(mapp[p-1][q+2]==checkturn&&mapp[p][q+1]==0&&0<=p-1&&p-1<=9&&0<=q+2&&q+2<=8) checkok
	}
	
	if(mapp[p][q]==5+checkextra)
	{
		for(register int i=p+1;i<=9;i++)
		{
			if(mapp[i][q]==checkturn) checkok
			if(mapp[i][q]!=0) return;
		}
		
		for(register int i=p-1;i>=0;i--)
		{
			if(mapp[i][q]==checkturn) checkok
			if(mapp[i][q]!=0) return;
		}
		
		for(register int i=q+1;i<=8;i++)
		{
			if(mapp[p][i]==checkturn) checkok
			if(mapp[p][i]!=0) return;
		}
		
		for(register int i=q-1;i>=0;i--)
		{
			if(mapp[p][i]==checkturn) checkok
			if(mapp[p][i]!=0) return;
		}
	}
	
	if(mapp[p][q]==6+checkextra)
	{
		if(mapp[p+2][q+3]==checkturn&&mapp[p][q+1]==0&&mapp[p+1][q+2]==0&&0<=p+2&&p+2<=9&&0<=q+3&&q+3<=8) checkok
		if(mapp[p+3][q+2]==checkturn&&mapp[p+1][q]==0&&mapp[p+2][q+1]==0&&0<=p+3&&p+3<=9&&0<=q+2&&q+2<=8) checkok
		if(mapp[p+3][q-2]==checkturn&&mapp[p+1][q]==0&&mapp[p+2][q-1]==0&&0<=p+3&&p+3<=9&&0<=q-2&&q-2<=8) checkok
		if(mapp[p+2][q-3]==checkturn&&mapp[p][q-1]==0&&mapp[p+1][q-2]==0&&0<=p+2&&p+2<=9&&0<=q-3&&q-3<=8) checkok
		if(mapp[p-2][q-3]==checkturn&&mapp[p][q-1]==0&&mapp[p-1][q-2]==0&&0<=p-2&&p-2<=9&&0<=q-3&&q-3<=8) checkok
		if(mapp[p-3][q-2]==checkturn&&mapp[p-1][q]==0&&mapp[p-2][q-1]==0&&0<=p-3&&p-3<=9&&0<=q-2&&q-2<=8) checkok
		if(mapp[p-3][q+2]==checkturn&&mapp[p-1][q]==0&&mapp[p-2][q+1]==0&&0<=p-3&&p-3<=9&&0<=q+2&&q+2<=8) checkok
		if(mapp[p-2][q+3]==checkturn&&mapp[p][q+1]==0&&mapp[p-1][q+2]==0&&0<=p-2&&p-2<=9&&0<=q+3&&q+3<=8) checkok
	}
	
	if(mapp[p][q]==7+checkextra)
	{
		if(mapp[p+1][q]==checkturn&&0<=p+1&&p+1<=9&&0<=q&&q<=8) checkok
		if(mapp[p-1][q]==checkturn&&0<=p-1&&p-1<=9&&0<=q&&q<=8) checkok
		if(mapp[p][q+1]==checkturn&&0<=p&&p<=9&&0<=q+1&&q+1<=8) checkok
		if(mapp[p][q-1]==checkturn&&0<=p&&p<=9&&0<=q-1&&q-1<=8) checkok
		if(mapp[p+1][q+1]==checkturn&&0<=p+1&&p+1<=9&&0<=q+1&&q+1<=8) checkok
		if(mapp[p-1][q+1]==checkturn&&0<=p-1&&p-1<=9&&0<=q+1&&q+1<=8) checkok
		if(mapp[p+1][q-1]==checkturn&&0<=p+1&&p+1<=9&&0<=q-1&&q-1<=8) checkok
		if(mapp[p-1][q-1]==checkturn&&0<=p-1&&p-1<=9&&0<=q-1&&q-1<=8) checkok
	}
}

inline void check()			// 检查将军 
{
	for(register int i=0;i<=9;i++)
	{
		for(register int j=0;j<=8;j++)
		{
			if(mapp[i][j]==0) continue;
			
			checkmate(i,j);
			
			if(jiang) return;
		}
	}
}

inline void print()			//输出 
{
	if(mapp[c][d]==1) printf("red captain;");
	else if(mapp[c][d]==2) printf("red guard;");
	else if(mapp[c][d]==3) printf("red elephant;");
	else if(mapp[c][d]==4) printf("red horse;");
	else if(mapp[c][d]==5) printf("red car;");
	else if(mapp[c][d]==6) printf("red duck;");
	else if(mapp[c][d]==7) printf("red soldier;");
	else if(mapp[c][d]==11) printf("blue captain;");
	else if(mapp[c][d]==12) printf("blue guard;");
	else if(mapp[c][d]==13) printf("blue elephant;");
	else if(mapp[c][d]==14) printf("blue horse;");
	else if(mapp[c][d]==15) printf("blue car;");
	else if(mapp[c][d]==16) printf("blue duck;");
	else if(mapp[c][d]==17) printf("blue soldier;");
	
	if(gai==1) printf("red captain;");
	else if(gai==2) printf("red guard;");
	else if(gai==3) printf("red elephant;");
	else if(gai==4) printf("red horse;");
	else if(gai==5) printf("red car;");
	else if(gai==6) printf("red duck;");
	else if(gai==7) printf("red soldier;");
	else if(gai==11) printf("blue captain;");
	else if(gai==12) printf("blue guard;");
	else if(gai==13) printf("blue elephant;");
	else if(gai==14) printf("blue horse;");
	else if(gai==15) printf("blue car;");
	else if(gai==16) printf("blue duck;");
	else if(gai==17) printf("blue soldier;");
	else printf("NA;");
	
	if(capture==0&&jiang) printf("yes;");
	else printf("no;");
	
	if(capture) puts("yes");
	else puts("no");
}

int main()
{
//	freopen("2test.in","r",stdin);
//	freopen("test.out","w",stdout);
	
	init();
//	Color(ybai);					/////
//	int cc=0;
	
//	for(register int i=9;i>=0;i--)
//	{
//		for(register int j=8;j>=0;j--)
//		{
//			cout<<setw(5)<<mapp[i][j];
//		}
//		puts("");
//	}
	
	scanf("%d",&Q);
	
	for(register int i=1;i<=Q;i++)
	{
//		cout<<i<<" ";					////
		
		scanf("%d%d%d%d",&a,&b,&c,&d);
		
		if(capture) {puts("Invalid command");continue;}
		
		initmove();
		move();
	
		if(flagout) continue;
		
//		if(i<=586) 
//		system("cls");								/////
//		for(register int i=9;i>=0;i--)
//		{
//			for(register int j=0;j<=8;j++)
//			{
//				if(mapp[i][j]<10&&mapp[i][j]!=0)
//				{
//					Color(yhong),cout<<setw(5)<<mapp[i][j],Color(ybai);
//				}
//				else if(mapp[i][j]>10)
//				{
//					Color(ylan),cout<<setw(5)<<mapp[i][j],Color(ybai);
//				}
//				else Color(ybai),cout<<setw(5)<<mapp[i][j];
//			}
//			puts("");
//		}
//		puts(""),puts("");											/////
		
		check();
		
		print();
		
		if(turn==0) turn=1;
		else turn=0;
		
//		if(i>=590) system("pause");
//		if(i>=357) 
	}
	
	return 0;
}
```

**写题解不易，兹磁一下呗!**
$ \color{white}\texttt{By Possible} $

---

## 作者：Li_Dicker (赞：33)

**距离CSP还有10天整的时候，发现自己的算法能力已经崩溃了，百般无奈之下开刷黑模拟，于是在三天之后有了这篇题解**

——by本机房第一个A掉此题的大佬[possible](https://www.luogu.org/user/86062)

就在那天，本萌新由于代码能力超弱

~~特别是和我旁边几位编出了很多游戏的大佬们[Carb_Dave](https://www.luogu.org/user/65502)和[马脸兔](https://www.luogu.org/user/92860)比起来~~

于是，本萌新发了一篇帖子：[怎么提升自己的代码能力啊QwQ](https://www.luogu.org/discuss/show/163661)，得到了各路大佬的真传，终于走向了刷模拟之路

~~由于本萌新语文太差，所以[猪国杀](https://www.luogu.org/problem/P2482)和[河童重工的计算机](https://www.luogu.org/problem/P4911)根本写不出来。看着旁边的possible大佬马上就要A掉这道黑模拟了，于是本萌新也开始了最后的逆袭~~

**好了我们废话不多说，先来分析一下题目吧**

一、鸭棋棋盘共有10行9列，需要特别注意的是：这里的地图需要从0开始计算。
	
所以为了方便改变地图，我们将地图初始化为如下样子

```cpp
char mp[11][11][11]=
{
{"rC","rH","rE","rG","rK","rG","rE","rH","rC"},
{"0","0","0","0","0","0","0","0","0"},
{"rD","0","0","0","0","0","0","0","rD"},
{"rS","0","rS","0","rS","0","rS","0","rS"},
{"0","0","0","0","0","0","0","0","0"},
{"0","0","0","0","0","0","0","0","0"},
{"bS","0","bS","0","bS","0","bS","0","bS"},
{"bD","0","0","0","0","0","0","0","bD"},
{"0","0","0","0","0","0","0","0","0"},
{"bC","bH","bE","bG","bK","bG","bE","bH","bC"},
};
```

我们会发现这里的棋盘和原题的题目中棋盘是反着的

![鸭棋棋盘](https://cdn.luogu.com.cn/upload/pic/58700.png)

所以我们同样为了在后面调试的时候方便看地图，我们将地图的行号倒叙输出，列号正序输出

```cpp
//输出地图现在形态 
void print_map()//输出现在的地图
{
	for (int i=9;i>=0;i--)//由于为了方便存取，将地图以题目告知的形式存储
	{//所以行号倒叙输出，但是输出之后形式依然为左下角为(0,0)
		cout<<setw(5)<<i;//输出纵坐标
		for (int j=0;j<=8;j++)
			cout<<setw(5)<<mp[i][j];
		printf("\n");
	}
	cout<<setw(5)<<" ";
	for (int i=0;i<=8;i++)
		cout<<setw(5)<<i;//输出横坐标
	printf("\n\n");
}
```
二、棋子的移动规则
在原题中，棋子的移动规则看上去比较麻烦，于是我们就可以将它翻译为通俗易懂的图形与文字语言

//下方局部棋盘中大写字母表示该棋子，y1或y表示可以到达的地方，a1或a表示与y对应的不应该有棋子的地方

~~有的地方为了一眼能看懂，所以有的不能有棋的地方我就必须靠一丢丢的意会来理解~~

//由于王（Captain和车Car的首字母相同，我们将王叫做King）

1.王（K)

n y n

y K y

n y n


2.士（G）

y n t

n G n

y n y


3.象（E）

y1 no no no y2

no a1 no a2 no

no no El no no

no a3 no a4 no

y3 no no no y4

在a没有棋子的情况下可以到达对应的y


4.马（H）

no y1 no y2 no

y3 no aa no y4

no a5 Ho a6 no

y5 no ab ad y6

no y7 no y8 no

马走日，先走长边，再走短边，长边的中间上不能有棋子


5.车（C）

no up no

le Ca ri

no do no

走一条直线上的任意长度，但是在走的这条线段上不能有任何棋子


6.鸭子（D）

no y1 no no no y2 no 

y3 no a1 no a2 no y4

no a3 no aa no a4 no 

no no a3 Du a4 no no

no a5 no aa no a6 no 

y5 no a7 no a8 no y6 

no y7 no no no y8 no 

鸭走目


7.兵（S）

y y y

y S y

y y y 

周围八个都可以走

三、下棋顺序

1.红方先下

2.如果上一步操作不合法，那么这一步还是该上一步下的那个人下

四、其他规则
1.将一个颜色的棋子在允许的范围内移动到不同颜色的棋子上，那一颗棋子视为被吃掉

2.棋盘只有10x9，不能越界

3.任意一方的王在对方某个棋子的攻击范围内，即视为将军

四、输入与输出
1.输入四个数字，为两组坐标，分别为要移动的棋子的坐标与移动到的位置的坐标

2.如果合法，输出

(1)这步操作移动了哪一颗棋子；格式：[颜色]+[类型] 

(2)存在移出游戏的棋子：输出被移出的棋子？输出NA

(3)这步操作后是否存在将军界面 

(4)这步操作后是否游戏结束 （用yes和no表示） 

3.结果在一行内输出，用分号隔开. 

4.在游戏结束之后所以的操作都不合法

**规则就（ju）只（ran）有这（na）么多，下面我们开始分析思路**

首先，棋盘的存储我们已经说过，就不再继续说

然后我们开始处理输入

先看输入的要移动的那个点

首先我们分析这个点上是否有棋子，如果没有就直接输出不合法

然后再判断这个棋子的颜色，其实就是在判断这个棋子的回合是否正确

这时候我们再来移动这颗棋子。当然在移动这颗棋子之前我们要先判断这是一颗什么棋子，然后再根据不同类型的棋子做出不同的合法判断

在这里我们判断棋子只用判断到达的点与开始的点之间的横坐标与纵坐标就行了，然后再开始判断应该没有棋的地方是否有棋

当然车比较例外，所以车这里我们就需要从这个点开始向到达的那个点进行判断：1.必须在同一行或者同一列   2.中间不能有棋

对于所有的棋子的移动，我们都是相同的模板（其实可以写成一个函数，但是由于不知道怎么的就没改）

```cpp
char ss[11];
strcpy(ss,"0");//定义并为字符串赋初值
if (mp[xxx][yyy][0]==mp[xx][yy][0])
{
	printf("Invalid command\n");
	return ;
}
if (strcmp(mp[xxx][yyy],"0")!=0)//如果走到的地方不为空
	strcpy(ss,mp[xxx][yyy]);//记录下这个地方的棋子
strcpy(mp[xxx][yyy],mp[xx][yy]);//替换掉这个地方的棋子
strcpy(mp[xx][yy],"0");//将原来移动的棋子那个地方表示为空
check_game(xxx,yyy,ss);//检查并输出游戏
return ;
```

在这里ss用来存储到达的那个点上原来是什么，如果是棋子就将棋子记录下来，否则就是0,

最后我们开始检查并输出游戏

首先我们要输出动的那个棋子

然后我们要判断到达的点上有没有棋子

我们还要判断游戏是否结束

**注意**：游戏结束之后就没有将军的说法了

最后我们还要判断将军

如下
```cpp
//判断棋局并且输出
void check_game(int xxx,int yyy,char ss[])
{
	print_piece(mp[xxx][yyy]);//输出当前这个点的棋子（也就是移动的棋子
	if (strcmp(ss,"0")==0)//如果走到的这个点原来没有棋子
		printf("NA;");//输出NA;
	else//否则
		print_piece(ss);//输出这个棋子
	if (strcmp(ss,"rK")==0||strcmp(ss,"bK")==0)//如果这个棋子为某一方的王
	{
		printf("no;yes\n");//输出未将军，并且游戏已结束
		gameover=1;//标记游戏以结束
		goon_game();
		return ;//停止操作
	}
	else if (check_generals())//否则检查是否将军
	{
		printf("yes;no\n");//输出将军，并且游戏未结束
		goon_game();
		return ;		
	}
	printf("no;no\n");//都不满足输出no;no
	goon_game();
}
```

那么我们又如何判断是否将军呢？

首先我们要找到王在哪里

然后我们再来根据每种棋子的特性来判断

所以这里我们就必须用到像dfs迷宫的那个dx和dy了

~~这一步特别容易写错，本萌新在这里挂了无数次~~

这一步的代码我们就在后面再说（因为这一步和移动棋子这一步是整个题最容易出错的地方，也是代码最多的地方）

不过本萌新想特别说一下找王这个部分。其实本来我们可以特别记录王的位置的，但是由于这样容易出错（明明是我懒得改），所以我们就遍历棋盘找王。但是又有一个问题，我们要找的坐标是两个数字和一个字符（王的颜色），但是return却只支持输出一个变量，怎么办呢QwQ

有的大佬说：我们可以将它转化为结构体的形式，或者是用STL的pair

当然可以，但是我却不想那么麻烦，所以我用到了降维的思想，我们知道任意一个高维数组一定可以化成低维数组，反之亦然，所以我们可以将棋盘的坐标转化为一个数，由于棋盘的长和宽是一定的，所以我们就可以用以下方式来写:

```cpp
//找王
int find_king(int a)
{
	int xx,yy;
	for (int i=a+1;i<=90;i++)
	{
		xx=(i-1)/9,yy=(i-1)%9;
		if (strcmp(mp[xx][yy],"rK")==0)
			return i;
		if (strcmp(mp[xx][yy],"bK")==0)
			return -i;
	}
	return 0;
}

bool check_generals()
{
	//找第一个王 
	//find_king用了二维数组降维的思想 
	k=find_king(0);//从0开始找 
	if (k==0)
		return 0;//错误的情况可以不考虑 
	if (k<0)//先找到的是什么颜色的王 
		color_find_king='b',k=-k;
	else
		color_find_king='r';
	int xx=(k-1)/9,yy=(k-1)%9,kk=k;//一维转二维，计算出坐标 
	if (find_king_Car(xx,yy)
		||find_king_S_and_G(xx,yy)
		||find_king_Ele(xx,yy)
		||find_king_horse(xx,yy)
		||find_king_duck(xx,yy))
		return 1;//将军 
	
	k=find_king(kk+1);//懒得记录第一次的王的位置，就再算一遍，从它的下一个开始计算 
	if (k==0)
		return 0;
	if (k<0)
		color_find_king='b',k=-k;
	else
		color_find_king='r';//原理同上 
	xx=(k-1)/9,yy=(k-1)%9;
	if (find_king_Car(xx,yy)
		||find_king_S_and_G(xx,yy)
		||find_king_Ele(xx,yy)
		||find_king_horse(xx,yy)
		||find_king_duck(xx,yy))
		return 1;//同上将军 
	
	return 0;//没有将军 
}
```

这个样子我们就可以找出王的坐标了（变量名有点丑，大家请原谅哦QwQ）

整个程序的技术部分大概就只有这些可说的了

那么我们继续说一下代码调试的问题

首先，根据旁边编游戏的大佬建议：写这种大模拟（游戏也是一样），尽量把每一个部分写成一个函数，这样便于修改和调试；

其次，在写代码的时候一定要记得写注释，并且要做一步写一步，觉得这一步无误了之后再去写下一步

代码结构一定要清晰：特别是那种码风丑得像马蜂窝一样的码风，还要那些大括号一上一下的缩进一多一少的那种，一定不要（虽然本萌新的码风也不是很好看，但是本萌新还是觉得能一眼看清结构比较整齐（尤其是在看代码略缩图的时候））；最后，变量名和函数名一定要取得有意义，按照英文和拼音来取都可以，不要什么都取pig之类的，要确保自己能一眼看出来这个函数是什么意思

用Dev-C++的都知道，Dev-C++在调试的时候经常出锅（比如啥突然就崩溃了，或者没法调试，或者换个函数那个相同变量名的变量他就不变了之类的）

所以我们不能只依靠Dev-C++，我们还要手动调试，比如输出中间变量啊，或者system("pause")暂停程序之类的，都很重要

相信各位的教练都告诉过大家：一定要记得注释输出中间变量语句之类的话，的确，这也很重要（而且有的头文件也要注释，比如windows.h或者con（这些都不再万能头里面））

最后，我们还是来看一下完整代码吧（配详细注释的哦）

```cpp
#include<bits/stdc++.h>
//#include<windows.h>
using namespace std;
int q,X1,X2,Y1,Y2,k;
bool term=1,gameover;
char color_find_king;
char mp[11][11][11]=
{
{"rC","rH","rE","rG","rK","rG","rE","rH","rC"},
{"0","0","0","0","0","0","0","0","0"},
{"rD","0","0","0","0","0","0","0","rD"},
{"rS","0","rS","0","rS","0","rS","0","rS"},
{"0","0","0","0","0","0","0","0","0"},
{"0","0","0","0","0","0","0","0","0"},
{"bS","0","bS","0","bS","0","bS","0","bS"},
{"bD","0","0","0","0","0","0","0","bD"},
{"0","0","0","0","0","0","0","0","0"},
{"bC","bH","bE","bG","bK","bG","bE","bH","bC"},
};

//输出地图现在形态 
void print_map()//输出现在的地图
{
	for (int i=9;i>=0;i--)//由于为了方便存取，将地图以题目告知的形式存储
	{//所以行号倒叙输出，但是输出之后形式依然为左下角为(0,0)
		cout<<setw(5)<<i;//输出纵坐标
		for (int j=0;j<=8;j++)
			cout<<setw(5)<<mp[i][j];
		printf("\n");
	}
	cout<<setw(5)<<" ";
	for (int i=0;i<=8;i++)
		cout<<setw(5)<<i;//输出横坐标
	printf("\n\n");
}

//找王
int find_king(int a)
{
	int xx,yy;
	for (int i=a+1;i<=90;i++)
	{
		xx=(i-1)/9,yy=(i-1)%9;
		if (strcmp(mp[xx][yy],"rK")==0)
			return i;
		if (strcmp(mp[xx][yy],"bK")==0)
			return -i;
	}
	return 0;
}

//判断是否有车
int find_king_Car(int xx,int yy)
{
	k=xx+1;
	while (strcmp(mp[k][yy],"0")==0&&k<=8)
		k++;
	if (mp[k][yy][0]!=color_find_king&&mp[k][yy][1]=='C')
		return 1;

	k=xx-1;
	while (strcmp(mp[k][yy],"0")==0&&k>=0)
		k--;
	if (mp[k][yy][0]!=color_find_king&&mp[k][yy][1]=='C')
		return 1;

	k=yy+1;
	while (strcmp(mp[xx][k],"0")==0&&k<=9)
		k++;
	if (mp[xx][k][0]!=color_find_king&&mp[xx][k][1]=='C')
		return 1;

	k=yy-1;
	while (strcmp(mp[xx][k],"0")==0&&k>=0)
		k--;
	if (mp[xx][k][0]!=color_find_king&&mp[xx][k][1]=='C')
		return 1;
	return 0;
}

//判断是否有兵和士
int find_king_S_and_G(int xx,int yy)
{
	int dx[11]={0,1,1,-1,-1},dy[11]={0,1,-1,1,-1};
	for (int i=1;i<=4;i++)
		if (color_find_king!=mp[xx+dx[i]][yy+dy[i]][0]&&(mp[xx+dx[i]][yy+dy[i]][1]=='S'||mp[xx+dx[i]][yy+dy[i]][1]=='G'))
			return 1;
	int dx1[11]={0,1,0,-1,0},dy1[11]={0,0,1,0,-1};
	for (int i=1;i<=4;i++)
		if (color_find_king!=mp[xx+dx1[i]][yy+dy1[i]][0]&&(mp[xx+dx1[i]][yy+dy1[i]][1]=='S'||mp[xx+dx1[i]][yy+dy1[i]][1]=='K'))
			return 1;
	return 0;
}

//判断是否有象
int find_king_Ele(int xx,int yy)
{
	int dx[11]={0,2,2,-2,-2},dy[11]={0,2,-2,2,-2};
	int dx1[11]={0,1,1,-1,-1},dy1[11]={0,1,-1,1,-1};
	for (int i=1;i<=4;i++)
		if (strcmp(mp[xx+dx1[i]][yy+dy1[i]],"0")==0&&mp[xx+dx[i]][yy+dy[i]][0]!=color_find_king&&mp[xx+dx[i]][yy+dy[i]][1]=='E')
			return 1;
	return 0;
}

//判断是否有马
int find_king_horse(int xx,int yy)
{
	int dx[11]={0,1,-1,2,-2,2,-2,1,-1},dy[11]={0,-2,-2,-1,-1,1,1,2,2};
	int dx1[11]={0,1,-1,1,-1,1,-1,1,-1},dy1[11]={0,-1,-1,-1,-1,1,1,1,1};
	for (int i=1;i<=8;i++)
		if (strcmp(mp[xx+dx1[i]][yy+dy1[i]],"0")==0&&mp[xx+dx[i]][yy+dy[i]][0]!=color_find_king&&mp[xx+dx[i]][yy+dy[i]][1]=='H')
			return 1;
	return 0;
}

//判断是否有鸭
int find_king_duck(int xx,int yy)
{
	int dx[11]={0,2,-2,3,-3,3,-3,2,-2},dy[11]={0,-3,-3,-2,-2,2,2,3,3};
	int dx1[11]={0,2,-2,2,-2,2,-2,2,-2},dy1[11]={0,-2,-2,-2,-2,2,2,2,2};
	int dx2[11]={0,1,-1,1,-1,1,-1,1,-1},dy2[11]={0,-1,-1,-1,-1,1,1,1,1};
	for (int i=1;i<=8;i++)
		if (strcmp(mp[xx+dx1[i]][yy+dy1[i]],"0")==0&&strcmp(mp[xx+dx2[i]][yy+dy2[i]],"0")==0&&mp[xx+dx[i]][yy+dy[i]][0]!=color_find_king&&mp[xx+dx[i]][yy+dy[i]][1]=='D')
			return 1;
	return 0;
}

//判断是否将军
bool check_generals()
{
	//找第一个王 
	//find_king用了二维数组降维的思想 
	k=find_king(0);//从0开始找 
	if (k==0)
		return 0;//错误的情况可以不考虑 
	if (k<0)//先找到的是什么颜色的王 
		color_find_king='b',k=-k;
	else
		color_find_king='r';
	int xx=(k-1)/9,yy=(k-1)%9,kk=k;//一维转二维，计算出坐标 
	if (find_king_Car(xx,yy)
		||find_king_S_and_G(xx,yy)
		||find_king_Ele(xx,yy)
		||find_king_horse(xx,yy)
		||find_king_duck(xx,yy))
		return 1;//将军 
	
	k=find_king(kk+1);//懒得记录第一次的王的位置，就再算一遍，从它的下一个开始计算 
	if (k==0)
		return 0;
	if (k<0)
		color_find_king='b',k=-k;
	else
		color_find_king='r';//原理同上 
	xx=(k-1)/9,yy=(k-1)%9;
	if (find_king_Car(xx,yy)
		||find_king_S_and_G(xx,yy)
		||find_king_Ele(xx,yy)
		||find_king_horse(xx,yy)
		||find_king_duck(xx,yy))
		return 1;//同上将军 
	
	return 0;//没有将军 
}

void print_piece(char s[])
{
	if (s[0]=='r')
		cout<<"red ";
	else if (s[0]=='b')
		cout<<"blue ";//判断颜色 
	if (s[1]=='K')
		cout<<"captain;";
	else if (s[1]=='G')
		cout<<"guard;";
	else if (s[1]=='E')
		cout<<"elephant;";
	else if (s[1]=='H')
		cout<<"horse;";
	else if (s[1]=='C')
		cout<<"car;";
	else if (s[1]=='S')
		cout<<"soldier;";
	else if (s[1]=='D')
		cout<<"duck;";//判断兵型 
}

//下一回合
void goon_game()
{
	if (term==0)//上一个是红色下一个就是绿色
		term=1;
	else//vice versa
		term=0;
}

//判断棋局并且输出
void check_game(int xxx,int yyy,char ss[])
{
	print_piece(mp[xxx][yyy]);//输出当前这个点的棋子（也就是移动的棋子
	if (strcmp(ss,"0")==0)//如果走到的这个点原来没有棋子
		printf("NA;");//输出NA;
	else//否则
		print_piece(ss);//输出这个棋子
	if (strcmp(ss,"rK")==0||strcmp(ss,"bK")==0)//如果这个棋子为某一方的王
	{
		printf("no;yes\n");//输出未将军，并且游戏已结束
		gameover=1;//标记游戏以结束
		goon_game();
		return ;//停止操作
	}
	else if (check_generals())//否则检查是否将军
	{
		printf("yes;no\n");//输出将军，并且游戏未结束
		goon_game();
		return ;		
	}
	printf("no;no\n");//都不满足输出no;no
	goon_game();
}

//走王
void move_K(int xx,int yy,int xxx,int yyy)
{
	if ((abs(xxx-xx)==1&&abs(yyy-yy)==0)||(abs(xxx-xx)==0&&abs(yyy-yy)==1))
	{//如果是只往上或下或左或右走：合法
		char ss[11];
		strcpy(ss,"0");//定义并为字符串赋初值
		if (mp[xxx][yyy][0]==mp[xx][yy][0])
		{
			printf("Invalid command\n");
			return ;
		}
		if (strcmp(mp[xxx][yyy],"0")!=0)//如果走到的地方不为空
			strcpy(ss,mp[xxx][yyy]);//记录下这个地方的棋子
		strcpy(mp[xxx][yyy],mp[xx][yy]);//替换掉这个地方的棋子
		strcpy(mp[xx][yy],"0");//将原来移动的棋子那个地方表示为空
		check_game(xxx,yyy,ss);//检查并输出游戏
		return ;
	}
	printf("Invalid command\n");//不满足就输出不合法
} 

//走士 
void move_G(int xx,int yy,int xxx,int yyy)
{
	if (abs(xxx-xx)==1&&abs(yyy-yy)==1)
	{//如果只能斜着走一步为合法
		char ss[11];
		strcpy(ss,"0");//定义并为字符串赋初值
		if (mp[xxx][yyy][0]==mp[xx][yy][0])
		{
			printf("Invalid command\n");
			return ;
		}
		if (strcmp(mp[xxx][yyy],"0")!=0)//如果走到地方不为空
			strcpy(ss,mp[xxx][yyy]);//记录下这个地方的棋子
		strcpy(mp[xxx][yyy],mp[xx][yy]);//移动棋子
		strcpy(mp[xx][yy],"0");//将原来这个棋子所在的地方变成空
		check_game(xxx,yyy,ss);//检查并输出游戏
		return ;
	}
	printf("Invalid command\n");//不合法就输出不满足
} 

//走象 
void move_E(int xx,int yy,int xxx,int yyy)
{
	if (abs(xxx-xx)==2&&abs(yyy-yy)==2&&strcmp(mp[(xx+xxx)/2][(yy+yyy)/2],"0")==0)
	{//象走日并且日字中间一点没有棋子
		char ss[11];
		strcpy(ss,"0");
		if (mp[xxx][yyy][0]==mp[xx][yy][0])
		{
			printf("Invalid command\n");
			return ;
		}
		if (strcmp(mp[xxx][yyy],"0")!=0)
			strcpy(ss,mp[xxx][yyy]);
		strcpy(mp[xxx][yyy],mp[xx][yy]);
		strcpy(mp[xx][yy],"0");
		check_game(xxx,yyy,ss);
		return ;//同上
	}
	printf("Invalid command\n");
} 

//走马 
void move_H(int xx,int yy,int xxx,int yyy)
{
	if ((abs(xxx-xx)==2&&abs(yyy-yy)==1&&strcmp(mp[(xxx+xx)/2][yy],"0")==0)||(abs(xxx-xx)==1&&abs(yyy-yy)==2&&strcmp(mp[xx][(yy+yyy)/2],"0")==0))
	{
		char ss[11];
		strcpy(ss,"0");
		if (mp[xxx][yyy][0]==mp[xx][yy][0])
		{
			printf("Invalid command\n");
			return ;
		}
		if (strcmp(mp[xxx][yyy],"0")!=0)
			strcpy(ss,mp[xxx][yyy]);
		strcpy(mp[xxx][yyy],mp[xx][yy]);
		strcpy(mp[xx][yy],"0");
		check_game(xxx,yyy,ss);
		return ;//同上
	}
	printf("Invalid command\n");
} 

//走车 
void move_C(int xx,int yy,int xxx,int yyy)
{//车走直线
	if (xx!=xxx&&yy!=yyy)
	{
		printf("Invalid command\n");
		return ;
	}
	if (xx==xxx)//如果在同一行
	{
		for (int i=min(yy,yyy)+1;i<=max(yy,yyy)-1;i++)//搜索走的路径中有没有棋子
			if (strcmp(mp[xx][i],"0")!=0)//有棋子
			{
				printf("Invalid command\n");
				return ;//不合法
			}
	}
	else if (yy==yyy)//在同一列上
	{
		for (int i=min(xx,xxx)+1;i<=max(xx,xxx)-1;i++)//搜索路径
			if (strcmp(mp[i][yy],"0")!=0)//判断中间是否有棋子
			{
				printf("Invalid command\n");
				return ;
			}
	}
	char ss[11];
	strcpy(ss,"0");
	if (mp[xxx][yyy][0]==mp[xx][yy][0])
	{
		printf("Invalid command\n");
		return ;
	}
	if (strcmp(mp[xxx][yyy],"0")!=0)
		strcpy(ss,mp[xxx][yyy]);
	strcpy(mp[xxx][yyy],mp[xx][yy]);
	strcpy(mp[xx][yy],"0");
	check_game(xxx,yyy,ss);
	return ;//同上
} 

//走兵 
void move_S(int xx,int yy,int xxx,int yyy)
{
	if ((abs(xxx-xx)==1&&abs(yyy-yy)==1)||(abs(xxx-xx)==1&&abs(yyy-yy)==0)||(abs(xxx-xx)==0&&abs(yyy-yy)==1))
	{//兵只能在周围的8个里面走
		char ss[11];
		strcpy(ss,"0");
		if (mp[xxx][yyy][0]==mp[xx][yy][0])
		{
			printf("Invalid command\n");
			return ;
		}
		if (strcmp(mp[xxx][yyy],"0")!=0)
			strcpy(ss,mp[xxx][yyy]);
		strcpy(mp[xxx][yyy],mp[xx][yy]);
		strcpy(mp[xx][yy],"0");
		check_game(xxx,yyy,ss);
		return ;//同上
	}
	printf("Invalid command\n");
} 

//走鸭
void move_D(int xx,int yy,int xxx,int yyy)
{
	if (  (xxx-xx==3&&yyy-yy==2&&strcmp(mp[xx+1][yy],"0")==0&&strcmp(mp[xx+2][yy+1],"0")==0)
		||(xxx-xx==3&&yy-yyy==2&&strcmp(mp[xx+1][yy],"0")==0&&strcmp(mp[xx+2][yy-1],"0")==0)
		||(xx-xxx==3&&yyy-yy==2&&strcmp(mp[xx-1][yy],"0")==0&&strcmp(mp[xx-2][yy+1],"0")==0)
		||(xx-xxx==3&&yy-yyy==2&&strcmp(mp[xx-1][yy],"0")==0&&strcmp(mp[xx-2][yy-1],"0")==0)
		||(xxx-xx==2&&yyy-yy==3&&strcmp(mp[xx][yy+1],"0")==0&&strcmp(mp[xx+1][yy+2],"0")==0)
		||(xxx-xx==2&&yy-yyy==3&&strcmp(mp[xx][yy-1],"0")==0&&strcmp(mp[xx+1][yy-2],"0")==0)
		||(xx-xxx==2&&yyy-yy==3&&strcmp(mp[xx][yy+1],"0")==0&&strcmp(mp[xx-1][yy+2],"0")==0)
		||(xx-xxx==2&&yy-yyy==3&&strcmp(mp[xx][yy-1],"0")==0&&strcmp(mp[xx-1][yy-2],"0")==0))
	{//鸭子的八个方向
		char ss[11];
		strcpy(ss,"0");
		if (mp[xxx][yyy][0]==mp[xx][yy][0])
		{
			printf("Invalid command\n");
			return ;
		}
		if (strcmp(mp[xxx][yyy],"0")!=0)
			strcpy(ss,mp[xxx][yyy]);
		strcpy(mp[xxx][yyy],mp[xx][yy]);
		strcpy(mp[xx][yy],"0");
		check_game(xxx,yyy,ss);
		return ;//同上
	}
	printf("Invalid command\n");
} 

//判断是属于红方(0)还是蓝方(1)
bool check_color(int xx,int yy)
{
	if (strcmp(mp[xx][yy],"rK")==0||strcmp(mp[xx][yy],"rG")==0||strcmp(mp[xx][yy],"rE")==0||strcmp(mp[xx][yy],"rH")==0||strcmp(mp[xx][yy],"rC")==0||strcmp(mp[xx][yy],"rS")==0||strcmp(mp[xx][yy],"rD")==0)
		return 0;//是红色返回0
	return 1;//蓝色返回1
} 

//判断回合是否正确 (第一局是从红色开始，所以它的上一个是蓝色1)
bool check_term(int xx,int yy)//判断走的这个棋的颜色是否与上一次正确的颜色相同
{
	if ((term==0&&check_color(xx,yy)==1)||(term==1&&check_color(xx,yy)==0))
	{//上一个是红色这个就是蓝色或者上一个是蓝色这一个是红色
		return true;//返回为正确
	}
	return false;//否则为错误
} 
//判断是否越界
void check(int xx,int yy,int xxx,int yyy)
{
	if (gameover==1)//如果游戏结束过了
	{
		printf("Invalid command\n");
		return ;
	}
	if (strcmp(mp[xx][yy],"0")==0)//如果这个点没有棋子
	{
		printf("Invalid command\n");
		return ;
	}
	if (check_term(xx,yy)==false)//如果回合不对
	{
		printf("Invalid command\n");
		return ;
	}
	//判断这个点是什么棋子(不看颜色),只看最后一个字母
	if (mp[xx][yy][1]=='K')
		move_K(xx,yy,xxx,yyy);//走王
	else if (mp[xx][yy][1]=='G')
		move_G(xx,yy,xxx,yyy);//走士
	else if (mp[xx][yy][1]=='E')
		move_E(xx,yy,xxx,yyy);//走象
	else if (mp[xx][yy][1]=='H')
		move_H(xx,yy,xxx,yyy);//走马
	else if (mp[xx][yy][1]=='C')
		move_C(xx,yy,xxx,yyy);//走车
	else if (mp[xx][yy][1]=='S')
		move_S(xx,yy,xxx,yyy);//走兵
	else if (mp[xx][yy][1]=='D')
		move_D(xx,yy,xxx,yyy);//走鸭
}

int main()
{
//	freopen("2.in","r",stdin);
	scanf("%d",&q);//输入询问数 
//	print_map();
	// system("pause");
	for (int i=1;i<=q;i++)
	{
		scanf("%d%d%d%d",&X1,&Y1,&X2,&Y2);//输入每一个询问 
		check(X1,Y1,X2,Y2);//检查从(X1,Y1)到(X2,Y2)
//		print_map();
		// system("pause");
	}
	return 0;
}
```

完结撒花

谢谢大家的支持与观看QwQ

阿里嘎多very much

   *by  Li_Dicker*

---

## 作者：火车司机 (赞：22)

## 梳理题意

读入一个操作，判断是否合法，不合法输出 $Invalid\ command$

合法输出以下四个问题的答案，**用分号隔开**：

- 被移动的棋子

- 被吃掉的棋子，没有输出 $NA$

- 是否形成将军局面

- 游戏是否结束

此题同时也十分良心的给出了所有不合法的情况：

- 将棋子移动到棋盘外的某个位置

- 此步移动的初始位置无己方棋子停留

- 此步移动的初始位置有己方棋子停留，但移动不符合规则

- 此步移动的终止位置有己方棋子停留

- 游戏已经结束

给出了一个**坑点**：

- 游戏结束时，无需判断是否形成将军局面

综上所述，此题作为一道大模拟，已经无需做其他多余的考虑，直接按照题意模拟即可

**但是！！！**

像这种大模拟题，直接按照题意模拟肯定码量惊人，不是我们希望看到的，因此，我们可以进行一些简化，思路具体请见 @洛谷神鸭 的题解

~~因为本人太菜了，所以我这个简化函数中并没有将“车”包含在内~~

```cpp

int fx[4]= {1,1,-1,-1},fy[4]= {1,-1,1,-1},a[6]= {0,1,2,1,0,3},b[6]= {1,1,2,2,0,2};
inline int move(int f,int sx,int sy,int tx,int ty) {
	int minn=min(a[f],b[f])-(a[f]==b[f]);	//防止判断到起始和终止位置
	for (ri i=0; i<4; i++) {
		int x=sx+a[f]*fx[i],y=sy+b[f]*fy[i],flag=0;
		if (x<0||x>9||y<0||y>8) continue;	//是否超出棋盘
		if (x==tx&&y==ty) {
			for (ri j=1; j<=minn&&!flag; j++)	//判断是否有障碍物
				if (mp[x-j*fx[i]][y-j*fy[i]]) flag=1;
			if (!flag) return 1;
		}
	}
	for (ri i=0; i<4; i++) {	//马和鸭可以走8个方向，所以统一判断
		int x=sx+b[f]*fx[i],y=sy+a[f]*fy[i],flag=0;
		if (x<0||x>9||y<0||y>8) continue;
		if (x==tx&&y==ty) {
			for (ri j=1; j<=minn&&!flag; j++)
				if (mp[x-j*fx[i]][y-j*fy[i]]) flag=1;
			if (!flag) return 1;
		}
	}
	return 0;
}

```
经过以上码量优化，我们就可以写出以下90行AC代码了AwA

## 完整代码

```cpp

#include <bits/stdc++.h>
#define ri register int
using namespace std;
int Q,sx,sy,tx,ty,flag=0,playerid=0;	//代表红色执子
int fx[4]= {1,1,-1,-1},fy[4]= {1,-1,1,-1},a[6]= {0,1,2,1,0,3},b[6]= {1,1,2,2,0,2};
int id[10][9]= {
	{1,1,1,1,1,1,1,1,1},{0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,1},{1,0,1,0,1,0,1,0,1},
    {0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0},{2,0,2,0,2,0,2,0,2},{2,0,0,0,0,0,0,0,2},
    {0,0,0,0,0,0,0,0,0},{2,2,2,2,2,2,2,2,2}
};
int mp[10][9]= {
	{5,4,3,2,1,2,3,4,5},{0,0,0,0,0,0,0,0,0},{6,0,0,0,0,0,0,0,6},{7,0,7,0,7,0,7,0,7},
    {0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0},{7,0,7,0,7,0,7,0,7},{6,0,0,0,0,0,0,0,6},
    {0,0,0,0,0,0,0,0,0},{5,4,3,2,1,2,3,4,5}	//预先打表出整张棋盘
};
inline void out(int x) {
	playerid?printf("blue "):printf("red ");
	if (x==1) printf("captain;");
	else if (x==2) printf("guard;");
	else if (x==3) printf("elephant;");
	else if (x==4) printf("horse;");
	else if (x==5) printf("car;");
	else if (x==6) printf("duck;");
	else if (x==7) printf("soldier;");
}
inline int move(int f,int sx,int sy,int tx,int ty) {
	int minn=min(a[f],b[f])-(a[f]==b[f]);	//防止判断到起始和终止位置
	for (ri i=0; i<4; i++) {
		int x=sx+a[f]*fx[i],y=sy+b[f]*fy[i],flag=0;
		if (x<0||x>9||y<0||y>8) continue;	//是否超出棋盘
		if (x==tx&&y==ty) {
			for (ri j=1; j<=minn&&!flag; j++)	//判断是否有障碍物
				if (mp[x-j*fx[i]][y-j*fy[i]]) flag=1;
			if (!flag) return 1;
		}
	}
	for (ri i=0; i<4; i++) {	//马和鸭可以走8个方向，所以统一判断
		int x=sx+b[f]*fx[i],y=sy+a[f]*fy[i],flag=0;
		if (x<0||x>9||y<0||y>8) continue;
		if (x==tx&&y==ty) {
			for (ri j=1; j<=minn&&!flag; j++)
				if (mp[x-j*fx[i]][y-j*fy[i]]) flag=1;
			if (!flag) return 1;
		}
	}
	return 0;
}
inline int illegal(int sx,int sy,int tx,int ty) {
	if (flag||sx<0||sx>9||sy<0||sy>8||tx<0||tx>9||ty<0||ty>8) return 1;
	if (mp[sx][sy]==5) {	//“车”单独判断
		int ax=min(sx,tx),bx=max(sx,tx),ay=min(sy,ty),by=max(sy,ty);
		if (sx!=tx&&sy!=ty) return 1;
		if (sx==tx) {
			for (ri i=ay+1; i<by; i++) if (mp[sx][i]) return 1;
		} else for (ri i=ax+1; i<bx; i++) if (mp[i][sy]) return 1;
		return 0;
	} else if (mp[sx][sy]==7) return!(move(0,sx,sy,tx,ty)||move(1,sx,sy,tx,ty)));//兵可以分解为王和士
    else return (!move(mp[sx][sy]-1,sx,sy,tx,ty));
}
inline int gameover() {
	int cnt=0;
	for (ri i=0; i<10; i++)
		for (ri j=0; j<9; j++)
			if (mp[i][j]==1) cnt++;
	return cnt<2;	//王的数量少于1代表游戏结束
}
inline int general(int f) {
	int x=0,y=0;
	for (ri i=0; !x&&i<10; i++)
		for (ri j=0; !x&&j<9; j++)
			if (mp[i][j]==1&&id[i][j]==f) x=i,y=j;	//找到王的位置
	for (ri i=0; i<10; i++)
		for (ri j=0; j<9; j++)
			if (mp[i][j]&&id[i][j]!=f) if(!illegal(i,j,x,y)) return 1;
	return 0;	//能走到王的位置代表形成将军局面
}
int main() {
	scanf("%d",&Q);
	for (ri i=0; i<Q; i++) {
		scanf("%d%d%d%d",&sx,&sy,&tx,&ty);
		if (illegal(sx,sy,tx,ty)||((playerid+1)!=id[sx][sy])||((playerid+1)==id[tx][ty])) {
			printf("Invalid command\n");
			continue;
		}
		out(mp[sx][sy]),playerid^=1;	//执子者换人
		if (id[tx][ty]) out(mp[tx][ty]);
		else printf("NA;");
		id[tx][ty]=id[sx][sy],mp[tx][ty]=mp[sx][sy],id[sx][sy]=mp[sx][sy]=0;
		if (gameover()) flag=1;	//先判断游戏是否结束
		general(1)||general(2)?printf("yes;"):printf("no;");	//再判断是否形成将军局面
		flag?printf("yes\n"):printf("no\n");
	}
	return 0;
}

```


---

## 作者：平衡树森林 (赞：11)

#### 小蒟蒻第一次A了黑题>.<~~（虽然是一道纯模拟）~~
特此献上一篇具有纪念性的题解

并对各路奆佬以衷心的膜拜~~和求赞~~Orz

------------
以下是正题

看到如此长的一道题目，首先我们来捋一捋题意：

## 1.棋子
鸭棋中有很多种棋子，且每种棋子都有一种颜色（红色或蓝色），每种棋子有自己独特的走法，行走时也有相应的限制。但所有棋子在行走时都有一些**共同的限制**：

- 不能出界
- 行走的目标处不能有己方（同色）的棋子

此外，部分棋子在移动时有自己的限制（比如“马”在行走时不能被“蹩马腿”），这个后面再分析

同时，如果一个棋子所走的目标位置存在敌方（异色）棋子，这个棋子就会被吃掉（移除棋盘）

## 2.胜负判断
据题目中所说，一方获胜，当且仅当**另一方的“王”被吃了**

然后是一种特殊情况“将军”：当有一方可以在下一步吃掉对方的“王”时被称为将军。这里需要注意两点：
1. 双方都可以将军（并不一定走完这一步的人才能将军）
2. 将军只能对于对方的“王”，不能对自己的“王”将军

需要注意的是，**一旦有人获胜，一切都结束了，所有操作均为不合法，所有将军均无效**
## 3.游戏规则&操作规则
根据规定，红棋先走，每走一步先手轮换，当前改红棋走就只能且必须走红棋，否则操作不合法

对于不合法的操作，直接输出Invalid command并忽略改操作。

不合法分为以下情况：

1. 移动的位置没有棋子
2. 所选棋子不能移动到目标处
3. 所选棋子的颜色不是本回合应该走的颜色
4. 游戏已经结束

### 这样题目就捋清了~


------------
考虑实现方法

首先，不管我们要做什么操作，我们先要将各种棋子表示出来。

观察发现，棋子只有两个属性：颜色和行走方式（类别）。细分开来，行走方式分为两部分：棋子可以到达的位置和对应的限制条件。

可以发现，绝大部分棋子（只有车除外）都满足这样一个特性：只能往固定的几个位置行进。这意味着我们可以**把车特判**，剩下的棋子这样定义：

```cpp
struct piece{
	string name;
	string col;     //颜色
	LL n;           //一共可以走的位置数
	LL dir[20][2];  //所有可以走的位置
};
```
然后考虑限制条件。所谓限制条件，就是指行走时有的位置不能有棋子。容易发现，棋子分为四类：

- 无限制条件（王、士、兵）
- 有一处限制（马，象）
- 有两处限制（鸭）
- 特殊限制（车）
可以发现限制条件的定义和可以走的位置类似，这样我们就能完整地定义棋子了：
```cpp
struct piece{
	string name;
	string col;		//颜色
	LL n;			//一共可以走的位置数
	LL pn;			//限制条件数
	LL dir[20][2];	//所有可以走的位置
	LL pd1[8][2];	//第一种限制条件
	LL pd2[8][2];	//第二种限制条件
};
```

这样，我们就可以把14种棋子（7种* 2种颜色）完整地表示出来了（车要特判）：
```cpp
const piece pc[15]={//0:NULL   1~7:red   8~14:blue
null,
{"captain" ,"red",4,0,{{0,1},{1,0},{0,-1},{-1,0}}},
{"guard"   ,"red",4,0,{{1,1},{1,-1},{-1,1},{-1,-1}}},
{"elephant","red",4,1,{{2,2},{2,-2},{-2,2},{-2,-2}},
					  {{1,1},{1,-1},{-1,1},{-1,-1}}},
{"horse"   ,"red",8,1,{{1,2},{1,-2},{-1,2},{-1,-2},{2,1},{2,-1},{-2,1},{-2,-1}},
					  {{0,1},{0,-1},{-0,1},{-0,-1},{1,0},{1,-0},{-1,0},{-1,-0}}},
{"car"     ,"red"},			
{"duck"    ,"red",8,2,{{2,3},{2,-3},{-2,3},{-2,-3},{3,2},{3,-2},{-3,2},{-3,-2}},
					  {{0,1},{0,-1},{-0,1},{-0,-1},{1,0},{1,-0},{-1,0},{-1,-0}},
					  {{1,2},{1,-2},{-1,2},{-1,-2},{2,1},{2,-1},{-2,1},{-2,-1}}},
{"soldier" ,"red",8,0,{{1,0},{0, 1},{-1,0},{0 ,-1},{1,1},{1,-1},{-1,1},{-1,-1}}},

{"captain" ,"blue",4,0,{{0,1},{1,0},{0,-1},{-1,0}}},
{"guard"   ,"blue",4,0,{{1,1},{1,-1},{-1,1},{-1,-1}}},
{"elephant","blue",4,1,{{2,2},{2,-2},{-2,2},{-2,-2}},
					   {{1,1},{1,-1},{-1,1},{-1,-1}}},
{"horse"   ,"blue",8,1,{{1,2},{1,-2},{-1,2},{-1,-2},{2,1},{2,-1},{-2,1},{-2,-1}},
					   {{0,1},{0,-1},{-0,1},{-0,-1},{1,0},{1,-0},{-1,0},{-1,-0}}},
{"car"     ,"blue"},			
{"duck"    ,"blue",8,2,{{2,3},{2,-3},{-2,3},{-2,-3},{3,2},{3,-2},{-3,2},{-3,-2}},
					   {{0,1},{0,-1},{-0,1},{-0,-1},{1,0},{1,-0},{-1,0},{-1,-0}},
					   {{1,2},{1,-2},{-1,2},{-1,-2},{2,1},{2,-1},{-2,1},{-2,-1}}},
{"soldier" ,"blue",8,0,{{1,0},{0, 1},{-1,0},{0 ,-1},{1,1},{1,-1},{-1,1},{-1,-1}}},
};
```

那么现在我们可以开始思考需要做些什么：

题目要求：
```
对于每步操作，你需要首先判其是否合法，若合法，则进一步求出：
这步操作移动了哪个棋子。
这步操作后，是否存在棋子被移出游戏，如有则还需求出被移出游戏的棋子。
这步操作后，是否形成将军局面。
这步操作后，游戏是否结束。
```
这意味着我们至少完成这几个函数：
```cpp
struct game{
	LL chess[10][9]={//初始棋盘
		{12,11,10, 9, 8, 9,10,11,12},
		{ 0, 0, 0, 0, 0, 0, 0, 0, 0},
		{13, 0, 0, 0, 0, 0, 0, 0,13},
		{14, 0,14, 0,14, 0,14, 0,14},
		{ 0, 0, 0, 0, 0, 0, 0, 0, 0},
		{ 0, 0, 0, 0, 0, 0, 0, 0, 0},
		{ 7, 0, 7, 0, 7, 0, 7, 0, 7},
		{ 6, 0, 0, 0, 0, 0, 0, 0, 6},
		{ 0, 0, 0, 0, 0, 0, 0, 0, 0},
		{ 5, 4, 3, 2, 1, 2, 3, 4, 5}
	};
	LL B=0; //B=0/1该谁走
	bool ifover(){...}//判断是否结束
	bool ifmove(point x,point y,bool pB){...}//判断移动操作是否合法（pB表示判断时是否考虑本回合该谁走）
	void move(point x,point y,LL&M,LL&O){...}//执行移动操作并返回移动的棋子M，被吃的棋子O
	bool ifkilling(){...}//判断是否在将军

}G;
```
此外，我们还需要一个函数find来查找一个棋子的位置：
```cpp
	point find(LL id)
	{
		for (LL i=0;i<10;i++)
		{
			for (LL j=0;j<9;j++)
			{
				if (chess[i][j]==id) return (point){i,j};
			}
		}
		return (point){-1,-1};
	}
```
有了find，ifover函数就很容易实现了，因为判断游戏结束的条件非常简单（有一方的王被吃了）：
```cpp
	bool ifover()
	{
		point redcap=find(1),blackcap=find(8);//分别找到红王和蓝王的位置
		if (redcap.x+redcap.y==-2 || blackcap.x+blackcap.y==-2) return true;//其中之一没有找到就结束了
		return false;
	}
```
然后，我们便需要实现最核心的一个函数：ifmove。整理一下发现，一个操作合法需要这样几个条件：

- 游戏未结束
- 所移动的初始位置有子
- 在考虑该谁走的情况下（pB==1）是否颜色符合
- 初始位置的子那么走是否合法

ps.为什么要加入是否判断考虑谁走的条件呢？因为在判断将军时我们也需要这个函数，但将军**不考虑该谁走**，不这么写就会错（血的教训）

前三个条件都很容易实现，重点是第四个。我们先把它同样抽象成一个函数：
```cpp
bool ifmove(LL x,point pos,point vec)//判断x型的棋子当前在pos的位置是否可以进行vec的相对位置移动（vec可以理解为向量）
```
难么就可以把原先的ifmove函数写出来了：
```cpp
	bool ifmove(point x,point y,bool pB)
	{
		if (ifover()) return false;//游戏是否结束
		LL id=chess[x.x][x.y];
		if (!id) return false;//是否有子可以移动
		if (pB && pc[id].col!=(B==0?"red":"blue")) return false;//颜色是否符合
		if (!ifmove(id,x,(point){y.x-x.x,y.y-x.y})) return false;//移动是否合法
		return true;
	}
```
具体考虑里面嵌套的那个ifmove函数。我们发现，判断移动是否合法要满足一下几个条件：

- 不能出界
- 不能吃己方的子
- 移动操作需要存在
- 限制1需要满足（如果存在）
- 限制2需要满足（如果存在）

同时，**车要特判**

那么这段代码就很容易写出来了：
```cpp
	bool ifmove(LL x,point pos,point vec)
	{
		piece p=pc[x];
		point to={pos.x+vec.x,pos.y+vec.y};
		piece p_to=pc[chess[to.x][to.y]];
		if (to.x<0 || to.x>9 || to.y<0 || to.y>8) return false; //是否出界
		if (p_to.col==p.col) return false;        //不能吃己方子
		if (p.name=="car")   //车要特判
		{
			LL dx=(vec.x>0?1:-1),dy=(vec.y>0?1:-1);
			if (vec.x==0) dx=0;
			else if (vec.y==0) dy=0;
			else return false;
			for (LL i=1;i<abs(vec.x+vec.y);i++) 
				if (chess[pos.x+dx*i][pos.y+dy*i]) return false;
		}
		else
		{
			LL d=-1;
			for (LL i=0;i<p.n;i++) if (vec.x==p.dir[i][0] && vec.y==p.dir[i][1]) d=i;
			if (d==-1) return false;								//移动方式是否存在
			if (p.pn>0 && chess[pos.x+p.pd1[d][0]][pos.y+p.pd1[d][1]]) return false;           //限制1
			if (p.pn>1 && chess[pos.x+p.pd2[d][0]][pos.y+p.pd2[d][1]]) return false;           //限制2
		}
		return true; 
	}
```
move函数非常好解决，直接把子移过去就行了：
```cpp
	void move(point x,point y,LL&M,LL&O)
	{
		if (!ifmove(x,y,1)) return;
		M=chess[x.x][x.y];
		O=chess[y.x][y.y];
		chess[y.x][y.y]=M;
		chess[x.x][x.y]=0;
		B^=1;
	}
```
有了ifmove函数，ifkilling函数也很好写，枚举棋盘上的每一个点，判断能否移动到王的位置，不过要注意先判断游戏是否已经结束：
```cpp
	bool ifkilling()
	{
		if (ifover()) return false;
		point redcap=find(1),blackcap=find(8);
		for (LL i=0;i<10;i++)
		{
			for (LL j=0;j<9;j++)
			{
				LL id=chess[i][j];
				if (pc[id].col=="blue" && ifmove((point){i,j},redcap  ,0)) return true;
				if (pc[id].col=="red"  && ifmove((point){i,j},blackcap,0)) return true;
			}
		}
		return false;
	}
```
这样，所有的操作都完成了。那么主函数中直接调用就行了：
```cpp
void print(LL id)
{
	if (id)cout<<pc[id].col<<" "<<pc[id].name<<";";
	else cout<<"NA;";
}

int main()
{
	LL Q;
	cin>>Q;
	for (LL i=1;i<=Q;i++)
	{
		point u,v;
		cin>>u.x>>u.y>>v.x>>v.y;
		u.x=9-u.x;
		v.x=9-v.x;
		if (!G.ifmove(u,v,1)) cout<<EOR<<endl;
		else
		{
			LL M,O;
			G.move(u,v,M,O);
			print(M); print(O);
			cout<<(G.ifkilling()?"yes":"no")<<";"<<(G.ifover()?"yes":"no")<<endl;
		}
	}
	return 0;
}
```
最后献上我丑陋的170+行的代码（ps.我把程序都写完了才发现自己以左上角为原点(应该是左下角）QAQ。只好在读入时把坐标换过来QAQ）
```cpp
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
using namespace std;

const string EOR="Invalid command";

struct piece{
	string name;
	string col;
	LL n,pn;
	LL dir[20][2];
	LL pd1[8][2];
	LL pd2[8][2];
};

struct point{
	LL x,y;
};

const piece null={"","",0,0};
const piece pc[15]={//0:NULL   1~7:red   8~14:blue
null,
{"captain" ,"red",4,0,{{0,1},{1,0},{0,-1},{-1,0}}},
{"guard"   ,"red",4,0,{{1,1},{1,-1},{-1,1},{-1,-1}}},
{"elephant","red",4,1,{{2,2},{2,-2},{-2,2},{-2,-2}},
					  {{1,1},{1,-1},{-1,1},{-1,-1}}},
{"horse"   ,"red",8,1,{{1,2},{1,-2},{-1,2},{-1,-2},{2,1},{2,-1},{-2,1},{-2,-1}},
					  {{0,1},{0,-1},{-0,1},{-0,-1},{1,0},{1,-0},{-1,0},{-1,-0}}},
{"car"     ,"red"},			
{"duck"    ,"red",8,2,{{2,3},{2,-3},{-2,3},{-2,-3},{3,2},{3,-2},{-3,2},{-3,-2}},
					  {{0,1},{0,-1},{-0,1},{-0,-1},{1,0},{1,-0},{-1,0},{-1,-0}},
					  {{1,2},{1,-2},{-1,2},{-1,-2},{2,1},{2,-1},{-2,1},{-2,-1}}},
{"soldier" ,"red",8,0,{{1,0},{0, 1},{-1,0},{0 ,-1},{1,1},{1,-1},{-1,1},{-1,-1}}},

{"captain" ,"blue",4,0,{{0,1},{1,0},{0,-1},{-1,0}}},
{"guard"   ,"blue",4,0,{{1,1},{1,-1},{-1,1},{-1,-1}}},
{"elephant","blue",4,1,{{2,2},{2,-2},{-2,2},{-2,-2}},
					   {{1,1},{1,-1},{-1,1},{-1,-1}}},
{"horse"   ,"blue",8,1,{{1,2},{1,-2},{-1,2},{-1,-2},{2,1},{2,-1},{-2,1},{-2,-1}},
					   {{0,1},{0,-1},{-0,1},{-0,-1},{1,0},{1,-0},{-1,0},{-1,-0}}},
{"car"     ,"blue"},			
{"duck"    ,"blue",8,2,{{2,3},{2,-3},{-2,3},{-2,-3},{3,2},{3,-2},{-3,2},{-3,-2}},
					   {{0,1},{0,-1},{-0,1},{-0,-1},{1,0},{1,-0},{-1,0},{-1,-0}},
					   {{1,2},{1,-2},{-1,2},{-1,-2},{2,1},{2,-1},{-2,1},{-2,-1}}},
{"soldier" ,"blue",8,0,{{1,0},{0, 1},{-1,0},{0 ,-1},{1,1},{1,-1},{-1,1},{-1,-1}}},
};

struct game{
	LL chess[10][9]={
		{12,11,10, 9, 8, 9,10,11,12},
		{ 0, 0, 0, 0, 0, 0, 0, 0, 0},
		{13, 0, 0, 0, 0, 0, 0, 0,13},
		{14, 0,14, 0,14, 0,14, 0,14},
		{ 0, 0, 0, 0, 0, 0, 0, 0, 0},
		{ 0, 0, 0, 0, 0, 0, 0, 0, 0},
		{ 7, 0, 7, 0, 7, 0, 7, 0, 7},
		{ 6, 0, 0, 0, 0, 0, 0, 0, 6},
		{ 0, 0, 0, 0, 0, 0, 0, 0, 0},
		{ 5, 4, 3, 2, 1, 2, 3, 4, 5}
	};
	LL B=0;
	bool ifover()
	{
		point redcap=find(1),blackcap=find(8);
		if (redcap.x+redcap.y==-2 || blackcap.x+blackcap.y==-2) return true;
		return false;
	}
	bool ifmove(LL x,point pos,point vec)
	{
		piece p=pc[x];
		point to={pos.x+vec.x,pos.y+vec.y};
		piece p_to=pc[chess[to.x][to.y]];
		if (to.x<0 || to.x>9 || to.y<0 || to.y>8) return false; //是否出界
		if (p_to.col==p.col) return false;        //不能吃己方子
		if (p.name=="car")   //车要特判
		{
			LL dx=(vec.x>0?1:-1),dy=(vec.y>0?1:-1);
			if (vec.x==0) dx=0;
			else if (vec.y==0) dy=0;
			else return false;
			for (LL i=1;i<abs(vec.x+vec.y);i++) 
				if (chess[pos.x+dx*i][pos.y+dy*i]) return false;
		}
		else
		{
			LL d=-1;
			for (LL i=0;i<p.n;i++) if (vec.x==p.dir[i][0] && vec.y==p.dir[i][1]) d=i;
			if (d==-1) return false;								//移动方式是否存在
			if (p.pn>0 && chess[pos.x+p.pd1[d][0]][pos.y+p.pd1[d][1]]) return false;           //限制1
			if (p.pn>1 && chess[pos.x+p.pd2[d][0]][pos.y+p.pd2[d][1]]) return false;           //限制2
		}
		return true; 
	}
	bool ifmove(point x,point y,bool pB)
	{
		if (ifover()) return false;
		LL id=chess[x.x][x.y];
		if (!id) return false;
		if (pB && pc[id].col!=(B==0?"red":"blue")) return false;
		if (!ifmove(id,x,(point){y.x-x.x,y.y-x.y})) return false;
		return true;
	}
	void move(point x,point y,LL&M,LL&O)
	{
		if (!ifmove(x,y,1)) return;
		M=chess[x.x][x.y];
		O=chess[y.x][y.y];
		chess[y.x][y.y]=M;
		chess[x.x][x.y]=0;
		B^=1;
	}
	point find(LL id)
	{
		for (LL i=0;i<10;i++)
		{
			for (LL j=0;j<9;j++)
			{
				if (chess[i][j]==id) return (point){i,j};
			}
		}
		return (point){-1,-1};
	}
	bool ifkilling()
	{
		if (ifover()) return false;
		point redcap=find(1),blackcap=find(8);
		for (LL i=0;i<10;i++)
		{
			for (LL j=0;j<9;j++)
			{
				LL id=chess[i][j];
				if (pc[id].col=="blue" && ifmove((point){i,j},redcap  ,0)) return true;
				if (pc[id].col=="red"  && ifmove((point){i,j},blackcap,0)) return true;
			}
		}
		return false;
	}
}G;

void print(LL id)
{
	if (id)cout<<pc[id].col<<" "<<pc[id].name<<";";
	else cout<<"NA;";
}

int main()
{
	LL Q;
	cin>>Q;
	for (LL i=1;i<=Q;i++)
	{
		point u,v;
		cin>>u.x>>u.y>>v.x>>v.y;
		u.x=9-u.x;
		v.x=9-v.x;
		if (!G.ifmove(u,v,1)) cout<<EOR<<endl;
		else
		{
			LL M,O;
			G.move(u,v,M,O);
			print(M); print(O);
			cout<<(G.ifkilling()?"yes":"no")<<";"<<(G.ifover()?"yes":"no")<<endl;
		}
	}
	return 0;
}
```


------------
最后，还是向各位奆佬衷心地膜拜~~和求赞~~Orz。写这么长，很希望得到支持Orz。有问题请多指正Orz。

**求赞Orz求赞Orz求赞Orz**


------------
updata:修复了一些错误，感谢@暴力出奇迹

---

## 作者：ReModer (赞：9)

## 本题可以大致分为一下几个功能模块：
1. 判断移动是否合法   
2. 判断是否存在将军局面
3. 移动棋子，按要求输出

## 再看一下输出要求：

#### 若移动不合法，输出 ```Invalid command``` 。很简单，用模块1判断即可。

#### 若移动合法，输出 ```移动棋子、被移除棋子、是否将军、游戏是否结束```：
- 移动棋子：移动时输出即可。
- 被移除棋子：若移动终点为对方棋子，则移除并输出，否则输出 ```NA```。
- 是否将军：记录双方Captain的位置，通过模块1暴力枚举每个棋子能否到达对方Captain处。
- 游戏是否结束：若被移除的棋子是Captain，则游戏结束。

## 具体实现
首先，数组存棋盘，并初始化为初始状态。将 王士象马车鸭兵 分别与 1234567 对应，负值表示红方，正值表示蓝方。

用两个pair记录双方Captain的位置，同样需要初始化。

用数组处理各棋子的移动规则，绊马\象\鸭腿的情况另开数组，与移动数组保证对应。

接下来是各个模块：

#### 模块1：

- 游戏结束 或 移动位置非本方棋子，返回false
- 按规则可以移动到终点且终点不为本方棋子，返回true
- 无法完成第2条，返回false

##### 代码：
```cpp
bool judge(int player, int sx, int sy, int gx, int gy){
    /*游戏结束 或 初始位置不是自己的棋子 不合法*/
    if (finished || player * matrix[sx][sy] <= 0) return false;
    /*matrix[gx][gy] * player <= 0 表示 目的地为空或对方棋子*/
    switch (matrix[sx][sy]*player) {
        case 1: //Captain
            for (int i = 1; i <= CapX[0]; i++)
                if (sx+CapX[i] == gx && sy+CapY[i] == gy && matrix[gx][gy] * player <= 0) return true;
            break;
        case 2: //Guard
            for (int i = 1; i <= GuaX[0]; i++)
                if (sx+GuaX[i] == gx && sy+GuaY[i] == gy && matrix[gx][gy] * player <= 0) return true;
            break;
        case 3: //Elephant
            for (int i = 1; i <= EleX[0]; i++)
                if (!matrix[sx+EleXr[i]][sy+EleYr[i]] && sx+EleX[i] == gx && sy+EleY[i] == gy && matrix[gx][gy] * player <= 0) return true;
            break;
        case 4: //Horse
            for (int i = 1; i <= HorX[0]; i++)
                if (!matrix[sx+HorXr[i]][sy+HorYr[i]] && sx+HorX[i] == gx && sy+HorY[i] == gy && matrix[gx][gy] * player <= 0) return true;
            break;
        case 5: //Car
            if (sx == gx){ //横着走
                for (int i = sy + 1; i < gy; i++) if (matrix[gx][i]) return false;
                for (int i = sy - 1; i > gy; i--) if (matrix[gx][i]) return false;
                return matrix[gx][gy] * player <= 0;
            } else if (sy == gy){ //竖着走
                for (int i = sx + 1; i < gx; i++) if (matrix[i][gy]) return false;
                for (int i = sx - 1; i > gx; i--) if (matrix[i][gy]) return false;
                return matrix[gx][gy] * player <= 0;
            }
            break;
        case 6: //Duck
            for (int i = 1; i <= DucX[0]; i++)
                if (!matrix[sx+DucXp[i]][sy+DucYp[i]] && !matrix[sx+DucXr[i]][sy+DucYr[i]] && sx+DucX[i] == gx && sy+DucY[i] == gy && matrix[gx][gy] * player <= 0) return true;
            break;
        case 7: //Soldier
            for (int i = 1; i <= SolX[0]; i++)
                if (sx+SolX[i] == gx && sy+SolY[i] == gy && matrix[gx][gy] * player <= 0) return true;
            break;
    }
    /*运行到这里表明无法按规则移动，不合法*/
    return false;
}
```

#### 模块2：
暴力枚举对方的每个棋子，判断能否移动到本方Captain处。

##### 代码：
```cpp
bool checkmate(int player){
    for (int i = 0; i < 10; i++)
        for (int j = 0; j < 9; j++)
            if (matrix[i][j] * player < 0){ //对方棋子
                if (judge(-player,i,j,player>0 ? BC.first : RC.first, player>0 ? BC.second : RC.second))
                    return true;
            }
    return false;
}
```

#### 模块3：
基本按以下步骤进行：  
1. 若移动不合法，直接输出并返回false
2. 输出移动的棋子
3. 若移动终点是对方棋子，移除并输出
4. 移动棋子
5. 若移动的是Captain，更新pair
6. 用 模块2 判断是否将军并输出
7. 若移除的棋子是Captain，游戏结束

##### 代码：
```cpp
bool move(int player, int sx, int sy, int gx, int gy){
    /*不合法情况*/ 
    if (finished || !judge(player,sx,sy,gx,gy)) {printf("Invalid command\n"); return false;}

    /*输出移动的棋子 */
    int now = matrix[sx][sy];
    outRole(player,now);

    /*移除并输出*/
    int killed = 0;
    if (matrix[gx][gy] * player < 0) killed = matrix[gx][gy], matrix[gx][gy] = 0;
    if (!killed) printf("NA;"); else outRole(-player,killed);

    /*移动*/
    swap(matrix[sx][sy],matrix[gx][gy]);

    /*更新Captain位置*/
    if (abs(now) == 1)
        player>0 ? BC = M(gx,gy) : RC = M(gx,gy);

    /*判断是否将军*/
    if (checkmate(player) || checkmate(-player)) printf("yes;"); 
    else printf("no;");

    /*判断游戏是否结束*/
    if (abs(killed) == 1) finished = 1;
    if (finished) printf("yes\n"); else printf("no\n");

    return true;
}
```

##  全代码
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>
#include <cmath>
#define M(x,y) make_pair((x),(y))
using namespace std;

const int maxn = 10 + 5;
const int CapX[] = {4,1,0,0,-1};
const int CapY[] = {4,0,-1,1,0};
const int GuaX[] = {4,1,1,-1,-1};
const int GuaY[] = {4,1,-1,1,-1};
const int EleX[] = {4,2,-2,-2,2};
const int EleY[] = {4,2,2,-2,-2};
const int EleXr[] = {4,1,-1,-1,1};
const int EleYr[] = {4,1,1,-1,-1};
const int HorX[] = {8,2,1,1,2,-2,-1,-1,-2};
const int HorY[] = {8,1,2,-2,-1,1,2,-2,-1};
const int HorXr[] = {8,1,0,0,1,-1,0,0,-1};
const int HorYr[] = {8,0,1,-1,0,0,1,-1,0};
const int DucX[] = {8,3,2,2,3,-3,-2,-2,-3};
const int DucY[] = {8,2,3,-3,-2,2,3,-3,-2};
const int DucXr[] = {8,2,1,1,2,-2,-1,-1,-2};
const int DucYr[] = {8,1,2,-2,-1,1,2,-2,-1};
const int DucXp[] = {8,1,0,0,1,-1,0,0,-1};
const int DucYp[] = {8,0,1,-1,0,0,1,-1,0};
const int SolX[] = {8,1,-1,0,0,1,-1,-1,1};
const int SolY[] = {8,0,0,1,-1,1,-1,1,-1};
string role[maxn] = {"","captain","guard","elephant","horse","car","duck","soldier"};
int matrix[maxn][maxn] = {
    {-5,-4,-3,-2,-1,-2,-3,-4,-5},
    {0,0,0,0,0,0,0,0,0},
    {-6,0,0,0,0,0,0,0,-6},
    {-7,0,-7,0,-7,0,-7,0,-7},
    {0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0},
    {7,0,7,0,7,0,7,0,7},
    {6,0,0,0,0,0,0,0,6},
    {0,0,0,0,0,0,0,0,0},
    {5,4,3,2,1,2,3,4,5},
};
int n, sx, sy, gx, gy, player;
bool finished;
pair<int,int> RC,BC;

bool judge(int,int,int,int,int);     //移动是否合法
bool checkmate(int,int,int);         //是否存在将军局面
void outRole(int,int);               //输出棋子
bool move(int,int,int,int,int);      //移动，返回值表示是否能移动
void debug();                        //输出棋盘
void test();                         //自由行棋，测试

int main(){
    BC = M(9,4); RC = M(0,4);
    scanf("%d",&n); int p = -1;
    for (int i = 1; i <= n; i++){
        scanf("%d%d%d%d",&sx,&sy,&gx,&gy);
        if (move(p,sx,sy,gx,gy)) p = -p;
    }
    return 0;
}

bool checkmate(int player){
    for (int i = 0; i < 10; i++)
        for (int j = 0; j < 9; j++)
            if (matrix[i][j] * player < 0){
                if (judge(-player,i,j,player>0 ? BC.first : RC.first, player>0 ? BC.second : RC.second))
                    return true;
            }
    return false;
}

bool judge(int player, int sx, int sy, int gx, int gy){
    /*游戏结束 或 初始位置不是自己的棋子 不合法*/
    if (finished || player * matrix[sx][sy] <= 0) return false;
    /*matrix[gx][gy] * player <= 0 表示 目的地为空或对方棋子*/
    switch (matrix[sx][sy]*player) {
        case 1: //Captain
            for (int i = 1; i <= CapX[0]; i++)
                if (sx+CapX[i] == gx && sy+CapY[i] == gy && matrix[gx][gy] * player <= 0) return true;
            break;
        case 2: //Guard
            for (int i = 1; i <= GuaX[0]; i++)
                if (sx+GuaX[i] == gx && sy+GuaY[i] == gy && matrix[gx][gy] * player <= 0) return true;
            break;
        case 3: //Elephant
            for (int i = 1; i <= EleX[0]; i++)
                if (!matrix[sx+EleXr[i]][sy+EleYr[i]] && sx+EleX[i] == gx && sy+EleY[i] == gy && matrix[gx][gy] * player <= 0) return true;
            break;
        case 4: //Horse
            for (int i = 1; i <= HorX[0]; i++)
                if (!matrix[sx+HorXr[i]][sy+HorYr[i]] && sx+HorX[i] == gx && sy+HorY[i] == gy && matrix[gx][gy] * player <= 0) return true;
            break;
        case 5: //Car
            if (sx == gx){ //横着走
                for (int i = sy + 1; i < gy; i++) if (matrix[gx][i]) return false;
                for (int i = sy - 1; i > gy; i--) if (matrix[gx][i]) return false;
                return matrix[gx][gy] * player <= 0;
            } else if (sy == gy){ //竖着走
                for (int i = sx + 1; i < gx; i++) if (matrix[i][gy]) return false;
                for (int i = sx - 1; i > gx; i--) if (matrix[i][gy]) return false;
                return matrix[gx][gy] * player <= 0;
            }
            break;
        case 6: //Duck
            for (int i = 1; i <= DucX[0]; i++)
                if (!matrix[sx+DucXp[i]][sy+DucYp[i]] && !matrix[sx+DucXr[i]][sy+DucYr[i]] && sx+DucX[i] == gx && sy+DucY[i] == gy && matrix[gx][gy] * player <= 0) return true;
            break;
        case 7: //Soldier
            for (int i = 1; i <= SolX[0]; i++)
                if (sx+SolX[i] == gx && sy+SolY[i] == gy && matrix[gx][gy] * player <= 0) return true;
            break;
    }
    /*运行到这里表明无法按规则移动，不合法*/
    return false;
}

void outRole(int player, int id){
    if (player < 0) printf("red "); else printf("blue ");
    cout << role[abs(id)]; printf(";");
}

bool move(int player, int sx, int sy, int gx, int gy){
    /*不合法情况*/ 
    if (finished || !judge(player,sx,sy,gx,gy)) {printf("Invalid command\n"); return false;}

    /*输出移动的棋子 */
    int now = matrix[sx][sy];
    outRole(player,now);

    /*移除并输出*/
    int killed = 0;
    if (matrix[gx][gy] * player < 0) killed = matrix[gx][gy], matrix[gx][gy] = 0;
    if (!killed) printf("NA;"); else outRole(-player,killed);

    /*移动*/
    swap(matrix[sx][sy],matrix[gx][gy]);

    /*更新Captain位置*/
    if (abs(now) == 1)
        player>0 ? BC = M(gx,gy) : RC = M(gx,gy);

    /*判断是否将军*/
    if (checkmate(player) || checkmate(-player)) printf("yes;"); 
    else printf("no;");

    /*判断游戏是否结束*/
    if (abs(killed) == 1) finished = 1;
    if (finished) printf("yes\n"); else printf("no\n");

    return true;
}

void debug(){
    printf("\n");
    for (int i = 9; i >= 0; i--){
        for (int j = 0; j < 9; j++)
            printf("%-4d",matrix[i][j]);
        printf("\n");
    }
    printf("\n");
}

void test(){
    int a,b,c,d,e;
    while (cin >> a >> b >> c >> d >> e) 
        if (move(a,b,c,d,e)) debug();
}
```




---

## 作者：Bear203 (赞：9)

## 题目描述

#### 题目背景

鸭棋在一个$10\times 9$的网格棋盘上进行。双方一方执红棋、另一方执蓝棋轮流操作，操作时，必须选择一枚自己的棋子，并按规则进行一步移动。红方执先手，初始棋盘如下：
![initial_board.png](https://cdn.luogu.com.cn/upload/pic/58700.png)

#### 题目描述

操作序列中的每个操作为当前操作者试图移动某个位置的棋子至另一个位置。对于每步操作，你需要首先判其是否合法，若合法，则**进一步求出**：

1. 移动了哪个棋子。
2. 被移出游戏的棋子。
3. 是否将军。
4. 游戏是否结束。

不合法情况如下：

- 此步移动的初始位置无己方棋子停留。
- 此步移动的初始位置有己方棋子停留，但移动不符合规则。
- 游戏已经结束。

序列中的不合法操作是**需要被忽略的**。

------------

用$1\sim7$代替车、马、象、士、将、兵、鸭，$0,1$代替红、蓝，直接模拟即可。  
蒟蒻代码中的一些数组和函数：  
$name[i]$:棋子名称。  
$col[i]$:颜色。  
$mp[i][j]$:$(i,j)$棋子。  
$go[i][j][k]$:$name[i]$第$j$种行走。  
$err[i][j][k]$:绊$name[i]$第$j$种行走的腿。  
$ducke[i][j]$:绊鸭第$i$种行走的腿。  
$check\left(sx,sy,ex,ey\right):\left(sx,sy\right)$棋子是否能一步到达$(ex,ey)$。   
$check()$:是否将军。  
**初始棋盘**   

```cpp
int mp[11][11]={
	{1,2,3,4,5,4,3,2,1},
	{0,0,0,0,0,0,0,0,0},
	{7,0,0,0,0,0,0,0,7},
	{6,0,6,0,6,0,6,0,6},
	{0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0},
	{14,0,14,0,14,0,14,0,14},
	{15,0,0,0,0,0,0,0,15},
	{0,0,0,0,0,0,0,0,0},
	{9,10,11,12,13,12,11,10,9}
};
```

**行棋**  

```cpp
int go[8][8][2]={
	{{0}},{{0}},
	{{1,2},{2,1},{-1,2},{-2,1},{1,-2},{2,-1},{-1,-2},{-2,-1}},
	{{2,2},{-2,2},{2,-2},{-2,-2}},
	{{1,1},{-1,1},{1,-1},{-1,-1}},
	{{1,0},{0,1},{-1,0},{0,-1}},
	{{1,1},{1,0},{0,1},{1,-1},{-1,1},{0,-1},{-1,0},{-1,-1}},
	{{2,3},{3,2},{-2,3},{3,-2},{-3,2},{2,-3},{-2,-3},{-3,-2}}
};

```

**处理绊腿**  

```cpp
int err[8][8][2]={
	{{0}},{{0}},
	{{0,1},{1,0},{0,1},{-1,0},{0,-1},{1,0},{0,-1},{-1,0}},//绊马腿
	{{1,1},{-1,1},{1,-1},{-1,-1}},//绊象腿
	{{0}},{{0}},{{0}},
	{{0,1},{1,0},{0,1},{1,0},{-1,0},{0,-1},{0,-1},{-1,0}}//绊鸭腿(1)
};
int ducke[8][2]={{1,2},{2,1},{-1,2},{2,-1},{-2,1},{1,-2},{-1,-2},{-2,-1}};//绊鸭腿(2)
```

$check(sx,sy,ex,ey)$  

```cpp
bool check(int sx,int sy,int ex,int ey){
	const int t1=mp[sx][sy]&7;Re int i;
	if(!t1)return 0;
	if(t1==1){//车行走
		if(sy==ey){//同一列
			if(sx<ex){FOR(i,sx+1,ex)if(mp[i][sy])return 0;
				return 1;}//向下
			else{FOR(i,ex+1,sx)if(mp[i][sy])return 0;
				return 1;}//向上
		}
		if(sx==ex){//同一行
			if(sy<ey){FOR(i,sy+1,ey)if(mp[sx][i])return 0;
				return 1;}//向右
			else{FOR(i,ey+1,sy)if(mp[sx][i])return 0;
				return 1;}//向左
		}
	}
	if(t1==7){For(i,0,7)
		if(sx+go[7][i][0]==ex&&sy+go[7][i][1]==ey){
			if(!mp[sx+err[7][i][0]][sy+err[7][i][1]]&&!mp[sx+ducke[i][0]][sy+ducke[i][1]])return 1;
			return 0;}//鸭行走
	}
	For(i,0,7)if(sx+go[t1][i][0]==ex&&sy+go[t1][i][1]==ey){
		if(!(err[t1][i][0]||err[t1][i][1])||!mp[sx+err[t1][i][0]][sy+err[t1][i][1]])return 1;
		return 0;}//其他棋子行走
	return 0;} 
```

$check()$  

```cpp
bool check(){int kng[2][2];Re int p,i,j;
	For(i,0,9)For(j,0,8)if((mp[i][j]&7)==5)
		kng[(mp[i][j]&8)>>3][0]=i,kng[(mp[i][j]&8)>>3][1]=j;//找王
	For(p,0,1)For(i,0,9)For(j,0,8)
		if((((mp[i][j]&8)>>3)^p)&&check(i,j,kng[p][0],kng[p][1]))return 1;//枚举所有棋子，判断是否能吃掉对方的王
	return 0;}

```

蒟蒻丑陋的代码： 

```cpp
#include<cstdio>
#include<iostream>
#include<string>
#define For(i,a,b) for(i=a;i<=b;i++)
#define FOR(i,a,b) for(i=a;i<b;i++)
#define NO goto haha
#define Re register
std::string name[8]={"NA","car","horse","elephant","guard","captain","soldier","duck"},col[2]={"red ","blue "}; 
int mp[11][11]={
	{1,2,3,4,5,4,3,2,1},
	{0,0,0,0,0,0,0,0,0},
	{7,0,0,0,0,0,0,0,7},
	{6,0,6,0,6,0,6,0,6},
	{0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0},
	{14,0,14,0,14,0,14,0,14},
	{15,0,0,0,0,0,0,0,15},
	{0,0,0,0,0,0,0,0,0},
	{9,10,11,12,13,12,11,10,9}
};//初始棋盘
int go[8][8][2]={
	{{0}},{{0}},
	{{1,2},{2,1},{-1,2},{-2,1},{1,-2},{2,-1},{-1,-2},{-2,-1}},
	{{2,2},{-2,2},{2,-2},{-2,-2}},
	{{1,1},{-1,1},{1,-1},{-1,-1}},
	{{1,0},{0,1},{-1,0},{0,-1}},
	{{1,1},{1,0},{0,1},{1,-1},{-1,1},{0,-1},{-1,0},{-1,-1}},
	{{2,3},{3,2},{-2,3},{3,-2},{-3,2},{2,-3},{-2,-3},{-3,-2}}
};//行走
int err[8][8][2]={
	{{0}},{{0}},
	{{0,1},{1,0},{0,1},{-1,0},{0,-1},{1,0},{0,-1},{-1,0}},//绊马腿
	{{1,1},{-1,1},{1,-1},{-1,-1}},//绊象腿
	{{0}},{{0}},{{0}},
	{{0,1},{1,0},{0,1},{1,0},{-1,0},{0,-1},{0,-1},{-1,0}}//绊鸭腿(1)
};
int ducke[8][2]={{1,2},{2,1},{-1,2},{2,-1},{-2,1},{1,-2},{-1,-2},{-2,-1}};//绊鸭腿(2)
bool check(int sx,int sy,int ex,int ey){
	const int t1=mp[sx][sy]&7;Re int i;
	if(!t1)return 0;
	if(t1==1){//车行走
		if(sy==ey){//同一列
			if(sx<ex){FOR(i,sx+1,ex)if(mp[i][sy])return 0;
				return 1;}//向下
			else{FOR(i,ex+1,sx)if(mp[i][sy])return 0;
				return 1;}//向上
		}
		if(sx==ex){//同一行
			if(sy<ey){FOR(i,sy+1,ey)if(mp[sx][i])return 0;
				return 1;}//向右
			else{FOR(i,ey+1,sy)if(mp[sx][i])return 0;
				return 1;}//向左
		}
	}
	if(t1==7){For(i,0,7)
		if(sx+go[7][i][0]==ex&&sy+go[7][i][1]==ey){
			if(!mp[sx+err[7][i][0]][sy+err[7][i][1]]&&!mp[sx+ducke[i][0]][sy+ducke[i][1]])return 1;
			return 0;}//鸭行走
	}
	For(i,0,7)if(sx+go[t1][i][0]==ex&&sy+go[t1][i][1]==ey){
		if(!(err[t1][i][0]||err[t1][i][1])||!mp[sx+err[t1][i][0]][sy+err[t1][i][1]])return 1;
		return 0;}//其他棋子行走
	return 0;} 
bool check(){int kng[2][2];Re int p,i,j;
	For(i,0,9)For(j,0,8)if((mp[i][j]&7)==5)
		kng[(mp[i][j]&8)>>3][0]=i,kng[(mp[i][j]&8)>>3][1]=j;//找王
	For(p,0,1)For(i,0,9)For(j,0,8)
		if((((mp[i][j]&8)>>3)^p)&&check(i,j,kng[p][0],kng[p][1]))return 1;//枚举所有棋子，判断是否能吃掉对方的王
	return 0;}
int main(){bool fl=0;//游戏结束标志
	Re int p,sx,sy,ex,ey;int T;
	scanf("%d",&T);
	For(p,1,T){//(p&1):当前操作方
		scanf("%d%d%d%d",&sx,&sy,&ex,&ey);
		const int t1=(mp[sx][sy]&7),t3=(mp[ex][ey]&7);//棋子类型
		const bool t2=(bool)(mp[sx][sy]&8),t4=(bool)(mp[ex][ey]&8);//棋子归属
		if(fl||t2==(p&1)||t4==t2&&t3||!check(sx,sy,ex,ey))NO;
        	//结束后移动、移动对方棋子、吃掉己方棋子、移动至无法到达点均为非法操作 
		mp[ex][ey]=mp[sx][sy];mp[sx][sy]=0;//行走
		std::cout<<col[t2]<<name[t1]<<";";//输出移动的棋子
		if(t3)std::cout<<col[t4]<<name[t3];//输出被吃棋子
		else printf("NA");//没有棋子被吃
		if(t3==5)printf(";no;yes\n"),fl=1;//游戏结束了
		else if(check())printf(";yes;no\n");//将军局面
		else printf(";no;no\n");
		continue;
		haha:T--,p--,printf("Invalid command\n");}//非法操作，不转换操作方
}
```

---

## 作者：normalpcer (赞：5)

# P5380 鸭棋 题解

## 题意简述
一款在中国象棋基础上制作的游戏“鸭棋”，把棋子“炮”替换为了“鸭”。其中，“鸭”的移动规则是沿着 $2\times 3$ 网格的对角线上移动，但是如果在如图的两个红点处有其他棋子，则会“别鸭腿”，移动失败。
![鸭的移动规则](https://cdn.luogu.com.cn/upload/image_hosting/bvt7malu.png)

接下来，给出 $Q$ 次移动的起点 $\left(x_1, y_1\right)$ 和终点 $\left(x_2, y_2\right)$，对于每一个步骤，要求求出：
- 这一步移动的棋子，输出所处阵营和棋子类型，例如 `red horse`。
- 这一步吃掉的棋子。
- 这一步后是否构成“将军”。
- 这一步后游戏是否结束。

如果不合法，输出 `Invalid command`。

其中，“不合法”的情况包括：
- 没有选中或者选中敌方棋子。
- 试图攻击己方棋子。
- 试图移动到棋盘外。
- 游戏已经结束。

一方的王（将帅）被吃掉则游戏结束，一步之内可以使游戏结束被称为“将军”。特别地，王被吃掉的那一轮不能算作将军。

## 题目分析
本题数据范围很小，按照题意模拟即可。主要包括以下步骤：
- 选中棋子。
- 判断合法性。
- 移动棋子。
- 判断是否将军和游戏是否结束。

这篇题解将会在判断合法性时采用较为新颖的方法，可以优化编码体验。同时，也会带有一定的面向对象编程的思想。对于模拟题，我的代码通常以追求可读性为主。

接下来按照我会大致按照自己的编码顺序，从大体框架开始介绍。

### 大体框架
对于棋盘的存储，我选择了直接存储所有棋子及其位置信息。

考虑把棋子抽象成一个类。那么，它需要包括三个属性：类型，位置和队伍。进一步，位置包含 $x$ 坐标和 $y$ 坐标两个属性。我们用一个二维向量表示位置。之所以叫做向量，是因为我们接下来会用到一部分的向量运算。

接下来就可以一层一层地定义了。向量类：
```cpp
struct Vec2d {
    int x, y;
    Vec2d operator+(const Vec2d &other) const { return {x+other.x, y+other.y}; } // 加
    Vec2d operator-(const Vec2d &other) const { return {x-other.x, y-other.y}; } // 减
    Vec2d operator*(const int other) const { return {x*other, y*other}; } // 数乘
    Vec2d operator/(const int other) const { return {x/other, y/other}; } // 乘以 1/other
    int operator*(const Vec2d &other) const { return x*other.x + y*other.y; } // 数量积
    int cross(const Vec2d &other) const { return x*other.y - y*other.x; } // 叉乘的模长
    bool operator==(const Vec2d &other) const { return x==other.x and y==other.y; } // 相等
    bool operator!=(const Vec2d &other) const { return x!=other.x or y!=other.y; } // 不等

    int sqrDistance(const Vec2d &other) const { // 两点间欧几里得距离的平方
        return (x-other.x)*(x-other.x)+(y-other.y)*(y-other.y); 
    }
    int manhattan(const Vec2d &other) const { return abs(x-other.x)+abs(y-other.y); } // 曼哈顿距离
    int chebyshev(const Vec2d &other) const { return std::max(abs(x-other.x), abs(y-other.y)); } // 切比雪夫距离

    int sqrAbs() const { return x*x+y*y; }  // 模长的平方
};
```

这里，我们实现了两点间的三种距离也是为下文做准备。叉乘的结果是一个三维向量，这里为了方便直接返回模长。对于欧几里得距离（和模长），我们省略了开平方操作（这会引入浮点数的误差），直接采用开方前的结果。

阵营枚举：
```cpp
enum Team {
    Red,
    Blue,
};
```
按照定义顺序，`Team::Red` 和 `Team::Blue` 分别为 0 和 1。所以我们可以直接使用“异或”操作进行阵营的轮换。

接下来我们定义棋子类和棋子列表。
```cpp
struct Piece;  // 预先声明，解决循环引用问题
vector<Piece> pieces;

struct Piece {
    string  name;   // 棋子类型，如 horse, elephant
    Vec2d   pos;    // 棋子位置
    Team    team;   // 棋子阵营

    bool reachable(Vec2d dest) {  // 能否到达目标地点
        // To be done.
    }
};
```
这里有一个小问题，后面我们在实现 `reachable` 方法的时候会用到 `pieces` 数组，所以采用了预先声明的办法解决循环引用问题。当然，也可以在类外定义 `reachable` 方法。

绝大多数定义在这一步就完成了。

### 判断合法性
我们先不考虑其他因素，只处理两点的位置和“别脚”问题。

对于相对位置，我们使用上文的三种距离筛选。我们先简要介绍一下这三种距离。

对于两个点 $\left(x_1, y_1\right)$ 和 $\left(x_2, y_2\right)$，我们令 $\Delta x=\lvert x_1-x_2 \rvert, \Delta y=\lvert y_1-y_2 \rvert$。则两点的欧几里得距离是 $\Delta x^2+\Delta y^2$，曼哈顿距离是 $\Delta x+\Delta y$，切比雪夫距离是 $\max{\left\{\Delta x, \Delta y\right\}}$。

感性地理解，曼哈顿距离下的“圆”是一个斜着的正方形，切比雪夫距离下的“圆”是一个正置的正方形。

接下来，我们用 $d$ 表示欧几里得距离，$m$ 表示曼哈顿距离，$c$ 表示切比雪夫距离。各种棋子便有如下的筛法：
- 王：$d=1$
- 士：$m=2, c=1$（或者 $d=\sqrt{2}$）
- 象：$m=4, c=2$（或者 $d=2\sqrt{2}$）
- 马：$d=\sqrt{5}$
- 车：$m=c\neq 0$
- 鸭：$d=\sqrt{13}$
- 兵：$c=1$

接下来处理“别脚”的情况。这里我们就用到向量筛选。我们设 $Q$ 是当前棋盘上的一个棋子，出发点是 $O$，终点是 $P$。为了简便，令 $\vec{a}=\overrightarrow{OP}, \vec{b}=\overrightarrow{OQ}$。

对于象，不难发现 $2\vec{b}=\vec{a}$ 会构成压象眼。

接下来考虑别马脚。注意到，别马脚的子距离起点长度一定为 $1$，即 $\lvert \vec{b} \rvert=1$。此外，我们注意到，这两条向量的夹角永远是不变的，同时模长不变，自然想到利用数量积筛选。做 $\vec{b}$ 在 $\vec{a}$ 上的投影，显然有 $\vec{a}\cdot\vec{b}=2$。我们也可以用 GeoGebra 的画图功能来验证这个筛选。
![](https://cdn.luogu.com.cn/upload/image_hosting/76liyz5f.png)

红色直线上的点符合数量积要求，蓝色圆上的点符合模长要求，同时由于两个轴上的坐标都是整数，所以点 $Q$ 是唯一的——这个点也确实会别到马脚。

对于鸭子，有了处理别马脚的经验，也能很快的想出结论。第一种可能，$\lvert \vec{b} \rvert=1$ 且 $\vec{a}\cdot\vec{b}=3$；第二种可能，$\lvert \vec{b} \rvert=\sqrt{5}$ 且 $\vec{a}\cdot\vec{b}=8$。

对于车，要求中间没有挡道的棋子。不难想到，如果一个棋子要“挡道”，需要符合以下条件：
- $\vec{a}$ 和 $\vec{b}$ 共线。
- $\vec{a}$ 和 $\vec{b}$ 同向。
- $0<\lvert \vec{b} \rvert<\lvert \vec{a} \rvert$。

使用向量运算描述一下，即为以下条件：
$$
\begin{cases}
    \vec{a}\times\vec{b}=\vec0 \\
    \vec{a}\cdot\vec{b}>0 \\
    \lvert \vec{b} \rvert<\lvert \vec{a} \rvert
\end{cases}
$$

最后，再检测一下落点是否在棋盘上，以及是否在攻击己方棋子就可以了。

代码如下：
```cpp
struct Piece {
    // ...
    // 检查是否可以到达目标位置，但是只对位置进行判断
    bool reachable_pos(Vec2d dest) {
        if (name == "captain") {
            return pos.sqrDistance(dest) == 1;
        } else if (name == "guard") {
            return pos.manhattan(dest) == 2 and pos.chebyshev(dest) == 1;
        } else if (name == "elephant") {
            return pos.manhattan(dest) == 4 and pos.chebyshev(dest) == 2 and 
                not pieces.some(lambda(p, (p.pos-pos)*2==(dest-pos))); 
        } else if (name == "horse") {
            return pos.sqrDistance(dest) == 5 and 
                not pieces.some(lambda(p, 
                    p.pos.sqrDistance(pos) == 1 and (p.pos-pos)*(dest-pos)==2));
        } else if (name == "car") {
            auto a = dest-pos;
            return pos.chebyshev(dest) == pos.manhattan(dest) and not pieces.some([&](auto p) {
                auto b = p.pos-pos;
                return b.cross(a)==0 and b.sqrAbs()<a.sqrAbs() and b*a>0;
            });
        } else if (name == "soldier") {
            return pos.chebyshev(dest) == 1;
        } else {  // duck
            auto a = dest-pos;
            return pos.sqrDistance(dest) == 13 and not pieces.some([&](auto p) {
                auto b = p.pos-pos;
                return (a*b==8 and b.sqrAbs()==5) or (a*b==3 and b.sqrAbs()==1);
            });
        }
    }

    bool reachable(Vec2d dest) {  // 能否到达目标地点
        return 0<=dest.x and dest.x<_X and
            0<=dest.y and dest.y<_Y and
            reachable_pos(dest) and 
            not pieces.some(lambda(p, p.pos==dest and p.team==team));
    }
}
```

这里为了方便，我继承了 `std::vector`，即代码中的 `vector`，并添加了 `some(func)` 方法，用于判断是否存在任意一个元素 `i`，使得 `func(i)` 返回真。

```cpp
template <typename T> struct vector: public std::vector<T> {
    template <class Func>
    bool some(const Func&& f) {
        for (auto& i: *this) {
            if (f(i))  return true;
        }
        return false;
    }
};
```

而 `lambda` 是一个宏，定义如下：
```cpp
#define lambda(arg, expr) [&](auto arg){return expr;}
```

### 其他流程
这里就不多加阐述了，可以见代码注释
```cpp
void solve() {
    init();
    // 双方的王
    Piece& kingRed = pieces[0];
    Piece& kingBlue = pieces[1];

    bool round = 0;
    bool gameOver = false;
    from(_, 1, Q) {
        if (gameOver) {  // 游戏结束一定不合法
            cout << "Invalid command\n";
            continue;
        }
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        auto src = Vec2d{x1, y1};  // 起点
        auto dest = Vec2d{x2, y2};  // 终点

        auto selected = std::find_if(pieces.begin(), pieces.end(), 
            lambda(p, p.pos==src and p.team==round));  // 筛选，要求位置一致并且阵营正确
        if (selected == pieces.end()) {  // 没找到
            cout << "Invalid command\n";
            continue;
        }

        bool available = selected->reachable(dest);  // 判断终点位置是否可达
        if (not available) {
            cout << "Invalid command\n"; continue;
        }
        // 主语
        cout << (selected->team==Team::Red? "red ": "blue ") << selected->name << ';';

        // 宾语
        bool isKingKilled = false;  // 王被击杀，判断游戏结束
        auto attackedIter = std::find_if(pieces.begin(), pieces.end(), lambda(p, p.pos==dest));
        selected->pos = dest;
        if (attackedIter == pieces.end()) {
            cout << "NA;";  // 移到空格子
        } else {
            isKingKilled = (attackedIter->name=="captain");  // 游戏结束
            // 输出宾语
            cout << (attackedIter->team==Team::Red? "red ": "blue ") << attackedIter->name << ';';
            pieces.erase(attackedIter);  // 移除被吃的子
        }
        bool isKingInDanger = false;  // 被将军
        isKingInDanger &= !isKingKilled;  // 特判，王已经死了
        isKingInDanger |= pieces.some(lambda(p, p.reachable(kingRed.pos) and p.team==Team::Blue));
        isKingInDanger |= pieces.some(lambda(p, p.reachable(kingBlue.pos) and p.team==Team::Red));
        cout << (isKingInDanger? "yes;": "no;") << (isKingKilled? "yes": "no") << '\n';
        gameOver |= isKingKilled; 
        round ^= 1;  // 当且仅当操作合法，进行轮换
    }
}
```

### 初始化
初始化主要用于处理棋子的初始位置。

我采用了一些宏定义简化代码。宏定义有时可以减少枯燥乏味的代码，不过也要慎用，避免出现一些很难调的 bug。

```cpp
int Q;
void init() {
    std::ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    // 添加一个子
    #define add(name,px,py,team) pieces.push_back(Piece{name, {px, py}, Team::team});
    // 添加四个中心对称的子
    #define four(name,dx,dy) add(name,4-dx,4+dy,Red) add(name,4-dx,4-dy,Red) \
        add(name,5+dx,4-dy,Blue) add(name,5+dx,4+dy,Blue)
    // 添加底线上的一个子
    #define bottom(name,dy) four(name,4,dy);
    add("captain",0,4,Red) add("captain",9,4,Blue)
    bottom("car",4)bottom("horse",3)bottom("elephant",2)bottom("guard",1)
    four("duck",2,4)
    four("soldier",1,4)four("soldier",1,2)add("soldier",3,4,Red)add("soldier",6,4,Blue)
    cin >> Q;
}
```
那么这个代码就完成了。

### 警示后人
在写这个代码时，我被一个引用造成的 bug 卡了四个小时，原因是我在引用了 `vector` 上的一个元素之后，删除了另一个元素，导致内存上这个位置发生了变化，于是这个引用指向了其他元素。引用其实也是指向一个内存上的地址，和指针一样，所以不要掉以轻心，尤其是对可变容器中一个对象的引用，更要万分小心。（例如，`vector.push_back` 看上去人畜无害，但是如果触发了扩容，这个 `vector` 上的所有引用都会失效）

## 总结
本文中，我们采用了一些数学方法转换和简化了检查棋子的过程，感觉思路比较新颖，希望管理能够通过。

模拟题最重要的是对于题意的理解和保持思路的清晰。不过，这么长的代码，如果出现 bug，调起来还是很头疼的，所以还是要细心一些，并且记录一些平时遇到的 bug，在以后的代码中也多注意这些问题。

在文化课中学习向量时，我有时想，“这么抽象的东西到底有什么用”，直到编写这份代码的时候，我鬼使神差地给两个位置做了减法——这就是向量。于是，那些尘封在课本中的知识涌入脑海，前文的那些步骤也很自然了。把这些冗长的规则，都转变成了一个个简短的式子，也许这就是数学的魅力吧。

不知不觉也写了不少了，感谢您的观看。

## 完整代码
```cpp
/**
 * @link https://www.luogu.com.cn/problem/P5380
 */

#include <bits/stdc++.h>
#define from(i,b,e) for(int i=(b);i<=(e);i++)
#define lambda(arg, expr) [&](auto arg){return expr;}

using std::string, std::cin, std::cout;

template <typename T> struct vector: public std::vector<T> {
    template <class Func>
    bool some(const Func&& f) {
        for (auto& i: *this) {
            if (f(i))  return true;
        }
        return false;
    }
};

const int _X = 10;
const int _Y = 9;

struct Vec2d {
    int x, y;
    Vec2d operator+(const Vec2d &other) const { return {x+other.x, y+other.y}; } // 加
    Vec2d operator-(const Vec2d &other) const { return {x-other.x, y-other.y}; } // 减
    Vec2d operator*(const int other) const { return {x*other, y*other}; } // 数乘
    Vec2d operator/(const int other) const { return {x/other, y/other}; } // 乘以 1/other
    int operator*(const Vec2d &other) const { return x*other.x + y*other.y; } // 数量积
    int cross(const Vec2d &other) const { return x*other.y - y*other.x; } // 叉乘的模长
    bool operator==(const Vec2d &other) const { return x==other.x and y==other.y; } // 相等
    bool operator!=(const Vec2d &other) const { return x!=other.x or y!=other.y; } // 不等

    int sqrDistance(const Vec2d &other) const { // 两点间欧几里得距离的平方
        return (x-other.x)*(x-other.x)+(y-other.y)*(y-other.y); 
    }
    int manhattan(const Vec2d &other) const { return abs(x-other.x)+abs(y-other.y); } // 曼哈顿距离
    int chebyshev(const Vec2d &other) const { return std::max(abs(x-other.x), abs(y-other.y)); } // 切比雪夫距离

    int sqrAbs() const { return x*x+y*y; } // 模长的平方
};

enum Team {
    Red,
    Blue,
};

struct Piece;  // 预先声明，解决循环引用问题
vector<Piece> pieces;

struct Piece {
    string  name;   // 棋子类型，如 horse, elephant
    Vec2d   pos;    // 棋子位置
    Team    team;   // 棋子阵营

    // 检查是否可以到达目标位置，但是只对位置进行判断
    bool reachable_pos(Vec2d dest) {
        if (name == "captain") {
            return pos.sqrDistance(dest) == 1;
        } else if (name == "guard") {
            return pos.manhattan(dest) == 2 and pos.chebyshev(dest) == 1;
        } else if (name == "elephant") {
            return pos.manhattan(dest) == 4 and pos.chebyshev(dest) == 2 and 
                not pieces.some(lambda(p, (p.pos-pos)*2==(dest-pos))); 
        } else if (name == "horse") {
            return pos.sqrDistance(dest) == 5 and 
                not pieces.some(lambda(p, 
                    p.pos.sqrDistance(pos) == 1 and (p.pos-pos)*(dest-pos)==2));
        } else if (name == "car") {
            auto a = dest-pos;
            return pos.chebyshev(dest) == pos.manhattan(dest) and not pieces.some([&](auto p) {
                auto b = p.pos-pos;
                return b.cross(a)==0 and b.sqrAbs()<a.sqrAbs() and b*a>0;
            });
        } else if (name == "soldier") {
            return pos.chebyshev(dest) == 1;
        } else {  // duck
            auto a = dest-pos;
            return pos.sqrDistance(dest) == 13 and not pieces.some([&](auto p) {
                auto b = p.pos-pos;
                return (a*b==8 and b.sqrAbs()==5) or (a*b==3 and b.sqrAbs()==1);
            });
        }
    }

    bool reachable(Vec2d dest) {  // 能否到达目标地点
        return 0<=dest.x and dest.x<_X and
        0<=dest.y and dest.y<_Y and
        reachable_pos(dest) and 
        not pieces.some(lambda(p, p.pos==dest and p.team==team));
    }
};

namespace Solution {
    int Q;
    void init() {
        std::ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
        // 添加一个子
        #define add(name,px,py,team) pieces.push_back(Piece{name, {px, py}, Team::team});
        // 添加四个中心对称的子
        #define four(name,dx,dy) add(name,4-dx,4+dy,Red) add(name,4-dx,4-dy,Red) \
            add(name,5+dx,4-dy,Blue) add(name,5+dx,4+dy,Blue)
        // 添加底线上的一个子
        #define bottom(name,dy) four(name,4,dy);
        add("captain",0,4,Red) add("captain",9,4,Blue)
        bottom("car",4)bottom("horse",3)bottom("elephant",2)bottom("guard",1)
        four("duck",2,4)
        four("soldier",1,4)four("soldier",1,2)add("soldier",3,4,Red)add("soldier",6,4,Blue)
        cin >> Q;
    }

    void solve() {
        init();
        // 双方的王
        Piece& kingRed = pieces[0];
        Piece& kingBlue = pieces[1];

        bool round = 0;
        bool gameOver = false;
        from(_, 1, Q) {
            if (gameOver) {  // 游戏结束一定不合法
                cout << "Invalid command\n";
                continue;
            }
            int x1, y1, x2, y2;
            cin >> x1 >> y1 >> x2 >> y2;
            auto src = Vec2d{x1, y1};  // 起点
            auto dest = Vec2d{x2, y2};  // 终点

            auto selected = std::find_if(pieces.begin(), pieces.end(), 
                lambda(p, p.pos==src and p.team==round));  // 筛选，要求位置一致并且阵营正确
            if (selected == pieces.end()) {  // 没找到
                cout << "Invalid command\n";
                continue;
            }

            bool available = selected->reachable(dest);  // 判断终点位置是否可达
            if (not available) {
                cout << "Invalid command\n"; continue;
            }
            // 主语
            cout << (selected->team==Team::Red? "red ": "blue ") << selected->name << ';';

            // 宾语
            bool isKingKilled = false;  // 王被击杀，判断游戏结束
            auto attackedIter = std::find_if(pieces.begin(), pieces.end(), lambda(p, p.pos==dest));
            selected->pos = dest;
            if (attackedIter == pieces.end()) {
                cout << "NA;";  // 移到空格子
            } else {
                isKingKilled = (attackedIter->name=="captain");  // 游戏结束
                // 输出宾语
                cout << (attackedIter->team==Team::Red? "red ": "blue ") << attackedIter->name << ';';
                pieces.erase(attackedIter);  // 移除被吃的子
            }
            bool isKingInDanger = false;  // 被将军
            isKingInDanger &= !isKingKilled;  // 特判，王已经死了
            isKingInDanger |= pieces.some(lambda(p, p.reachable(kingRed.pos) and p.team==Team::Blue));
            isKingInDanger |= pieces.some(lambda(p, p.reachable(kingBlue.pos) and p.team==Team::Red));
            cout << (isKingInDanger? "yes;": "no;") << (isKingKilled? "yes": "no") << '\n';
            gameOver |= isKingKilled; 
            round ^= 1;  // 当且仅当操作合法，进行轮换
        }
    }
}


int main() {
    Solution::solve();
    return 0;
}
```

---

## 作者：chenxinyang2006 (赞：5)

做完这种题，不发题解真感觉对不起自己。

讲一下我自己的思路：

用map[i][j]表示i行j列棋子的种类（车1，马2，象3，士4，王5，兵6，鸭7，没有就是0）；

col[i][j]表示i行j列棋子的颜色(红色0，蓝色1，没有是-1）；

cnt表示已经执行了几个有效回合，显然cnt%2==0就说明当前是红色的回合，cnt%2==1说明现在是蓝色的回合

move(a,b,c,d）表示位于（a，b）的棋子能否到达（c，d）（不实际操作），name(a,b)表示输出位于（a，b）的棋子的名字

这样的话，判断是否是有效操作，需要判断这几点

（1）move（a，b，c，d）是否为真

（2）（a，b）是否存在棋子

（3）移动的棋子（a，b）颜色是否和当前应移动的颜色相同

（4）到达的点是否没有同色棋子（没有或者异色都可以）

（5）游戏是否结束

如果无效，直接输出“Invalid command”

否则需要回答：

（1）移动的棋子名称

解析：直接调用name(a，b）

（2）到达的点的棋子名称

解析：直接调用name(c，d）

（3）是否存在将军情况

解析：设红色将军位于（rx，ry），蓝色将军位于（bx，by）。

那么对于每一个红色棋子（i，j），如果move(i，j，bx，by）为1，存在将军局面；对于每一个蓝色棋子（i，j），如果move（i，j，rx，ry）为1，存在将军局面。

注意：此步需要在将位于（a，b）的棋子移动到（c，d）之后进行，否则会出问题。

（4）游戏是否结束

解析：如果map[c][d]为5，那么游戏结束。

你可能已经发现了一个问题：1、2、4问需要在将（a，b）实际移动到（c，d）之前进行，而第3问需要在移动之后进行。所以按顺序做不行，要存下第四问答案之后输出。

最后放出代码。由于我随便翻了几个AC代码发现有抄题解的，所以只有核心函数move。（其实其他的都比这个好写）

```cpp
int s1[4] = {1,1,-1,-1};
int s2[4] = {1,-1,1,-1};
int s3[4] = {0,1,0,-1};
int s4[4] = {1,0,-1,0};

bool move(int a,int b,int c,int d){
    if(map[a][b] == 1){
    	if(a == c){
    		if(b > d){
    			swap(b,d);
    		}
    		for(int i = b + 1;i < d;i++){
    			if(map[a][i]){
    				return 0;
    			}
    		}
    		return 1;
    	}else if(b == d){
            if(a > c){
    			swap(a,c);
    		}
    		for(int i = a + 1;i < c;i++){
    			if(map[i][b]){
    				return 0;
    			}
    		}
    		return 1;
    	}
    	return 0;
    }
    if(map[a][b] == 2){
    	for(int i = 0;i < 4;i++){
    		if(map[a + s1[i]][b] == 0 && a + s1[i] * 2 == c && b + s2[i] == d){
    			return 1;
    		}
    		if(map[a][b + s2[i]] == 0 && a + s1[i] == c && b + s2[i] * 2 == d){
    			return 1;
    		}
    	}
    	return 0;
    }
    if(map[a][b] == 3){
    	for(int i = 0;i < 4;i++){
    		if(map[a + s1[i]][b + s2[i]] == 0 && a + s1[i] * 2 == c && b + s2[i] * 2 == d){
    			return 1;
    		}
    	}
    	return 0;
    }
    if(map[a][b] == 4){
    	for(int i = 0;i < 4;i++){
    		if(a + s1[i] == c && b + s2[i] == d){
    			return 1;
    		}
    	}
    	return 0;
    }
    if(map[a][b] == 5){
        for(int i = 0;i < 4;i++){
        	if(a + s3[i] == c && b + s4[i] == d){
        		return 1;
        	}
        }
        return 0;
    }
    if(map[a][b] == 6){
    	for(int i = 0;i < 4;i++){
    		if(a + s1[i] == c && b + s2[i] == d){
    			return 1;
    		}
    		if(a + s3[i] == c && b + s4[i] == d){
    			return 1;
    		}
    	}
    	return 0;
    }
    if(map[a][b] == 7){
    	for(int i = 0;i < 4;i++){
    		if(map[a + s1[i] * 2][b + s2[i]] == 0 && map[a + s1[i]][b] == 0 && a + s1[i] * 3 == c && b + s2[i] * 2 == d){
    			return 1;
    		}
    		if(map[a + s1[i]][b + s2[i] * 2] == 0 && map[a][b + s2[i]] == 0 && a + s1[i] * 2 == c && b + s2[i] * 3 == d){
    			return 1;
    		}
    	}
    	return 0;
    }
}
```


---

## 作者：zbr2005 (赞：5)

终于把这篇题解制造出来了233

这道题本质上是一个大模拟，但对于窝这个蒟蒻鸭子来说写对它还是很不容易的，窝写了10.43KB ~~（压行后）~~，可某些鸭子却只写了4.19KB~~玄学~~

第一部分：初始化

```cpp
for(int i=0;i<=9;i++)
for(int j=0;j<=8;j++) f[i][j]=-1;//初始化棋盘颜色，-1：无棋子，0：红方，1：蓝方 
b[1]="captain";b[2]="guard";b[3]="elephant";b[4]="horse";b[5]="car";b[6]="duck";b[7]="soldier";//每一个棋子的数字代号，1：王，2：士，以此类推 
for(int i=0;i<=8;i+=2) {p[3][i]=7;f[3][i]=0;}p[2][0]=6;f[2][0]=0;p[2][8]=6;f[2][8]=0;
for(int i=0;i<=8;i+=2) {p[6][i]=7;f[6][i]=1;}p[7][0]=6;f[7][0]=1;p[7][8]=6;f[7][8]=1;
for(int i=0;i<=8;i++) {f[0][i]=0;f[9][i]=1;}p[0][0]=5;p[0][8]=5;p[9][0]=5;p[9][8]=5;p[0][1]=4;p[0][7]=4;p[9][1]=4;p[9][7]=4;p[0][2]=3;p[0][6]=3;p[9][2]=3;p[9][6]=3;p[0][3]=2;p[0][5]=2;p[9][3]=2;p[9][5]=2;p[0][4]=1;p[9][4]=1;
//初始化棋盘，p[x][y]:当前位置棋子的数字代号，0则代表无棋子。
```
第二部分：初步判断走法是否符合规则
```cpp
cin>>q;
for(int i=1;i<=q;i++)
{
cin>>x>>y>>x2>>y2;
if(x<0||y<0||x2>9||y2>8||x>9||y>8||x2<0||y2<0) cout<<"Invalid command"<<endl;//判断是否越界 
else if(p[x][y]==0) cout<<"Invalid command"<<endl;//判断此处是否有子 
else if(p[x2][y2]!=0&&f[x2][y2]==f[x][y]) cout<<"Invalid command"<<endl;//判断落子的位置是否有已方棋子 
else if(f[x][y]!=r||f[x2][y2]==r) cout<<"Invalid command"<<endl;//判断走的是不是己方棋子 
else if(la==1) cout<<"Invalid command"<<endl;//判断是否终局 
else if(x==x2&&y==y2) cout<<"Invalid command"<<endl;//判断终点是否和起点重合 
else
{
if(p[x][y]==1) checkcp(x,y,x2,y2);
if(p[x][y]==2) ckg(x,y,x2,y2);
if(p[x][y]==3) cke(x,y,x2,y2);
if(p[x][y]==4) ckh(x,y,x2,y2);
if(p[x][y]==5) ckc(x,y,x2,y2);
if(p[x][y]==6) ckd(x,y,x2,y2);
if(p[x][y]==7) cks(x,y,x2,y2);r=1-r;}//判断棋子状态，更新颜色 }
```
第三部分：判断棋子状态，输出

以士为例：
```cpp
void pd()
{
for(int j=0;j<=9;j++)
for(int k=0;k<=8;k++)
{
if(p[j][k]>=1)
{
int e,d=p[j][k];
e=0;if(d==1) e=max(e,cjcp(j,k,f[j][k]));
if(d==2) e=max(e,cjshi(j,k,f[j][k]));
if(d==3) e=max(e,cjele(j,k,f[j][k]));
if(d==4) e=max(e,cjhor(j,k,f[j][k]));
if(d==5) e=max(e,cjcar(j,k,f[j][k]));
if(d==6) e=max(e,cjduck(j,k,f[j][k]));
if(d==7) e=max(e,cjsold(j,k,f[j][k]));
if(e==1) {cout<<"yes;no"<<endl;psc=0;return;}
}
} 
//判断是否存在将军状态，函数cjcp,cjshi等用来判断王、士等是否将军对方王 
}
void ckg(int aa,int bb,int cc,int dd)
{
if(abs(aa-cc)>1||abs(bb-dd)>1){cout<<"Invalid command"<<endl;r=1-r;return;}
if(aa==cc||bb==dd) {cout<<"Invalid command"<<endl;r=1-r;return;}//判断是否符合棋子走法,如不符合更新一遍颜色,因主程序中如果进入函数就会自动更新一遍颜色，所以再更新一遍使下棋方不受影响
if(r==0) cout<<"red"<<" ";else cout<<"blue"<<" ";cout<<"guard"<<";";
if(f[cc][dd]!=-1)//如果落子位有棋子 
{
int l=f[cc][dd];
if(l==0) cout<<"red"<<" ";if(l==1) cout<<"blue"<<" ";cout<<b[p[cc][dd]]<<";";
if(cw(cc,dd)==1&&f[cc][dd]!=f[aa][bb]){cout<<"no;yes"<<endl;la=1;return;}//判断是否终局 
p[cc][dd]=p[aa][bb];f[cc][dd]=f[aa][bb];p[aa][bb]=0;f[aa][bb]=-1;//更新信息 
}
else {cout<<"NA;";p[cc][dd]=p[aa][bb];f[cc][dd]=f[aa][bb];p[aa][bb]=0;f[aa][bb]=-1;}//更新信息 
psc=1;pd();if(psc==1) cout<<"no;no"<<endl;//判断是否将军 
}
```
最后上完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int q,x,y,x2,y2,p[100][100],f[100][100],r,la,psc;
string b[10];
int cjcp(int xx,int yy,int ya)
{
	if(xx<9) 
	if(p[xx+1][yy]==1&&f[xx+1][yy]!=ya){return 1;}
	if(yy<8) 
	if(p[xx][yy+1]==1&&f[xx][yy+1]!=ya){return 1;}
	if(xx>0) 
	if(p[xx-1][yy]==1&&f[xx-1][yy]!=ya){return 1;}
	if(yy>0) 
	if(p[xx][yy-1]==1&&f[xx][yy-1]!=ya){return 1;}
	return 0;
}
int cjshi(int xx,int yy,int ya)
{
	if(xx<9&&yy<8) 
	if(p[xx+1][yy+1]==1&&f[xx+1][yy+1]!=ya){return 1;}
	if(yy<8&&xx>0) 
	if(p[xx-1][yy+1]==1&&f[xx-1][yy+1]!=ya){return 1;}
	if(xx>0&&yy>0) 
	if(p[xx-1][yy-1]==1&&f[xx-1][yy-1]!=ya){return 1;}
	if(yy>0&&xx<9) 
	if(p[xx+1][yy-1]==1&&f[xx+1][yy-1]!=ya){return 1;}
	return 0;
}
int cjele(int xx,int yy,int ya)
{
	if(xx<8&&yy<7) 
	if(p[xx+2][yy+2]==1&&p[xx+1][yy+1]==0&&f[xx+2][yy+2]!=ya){return 1;}
	if(yy<7&&xx>1) 
	if(p[xx-2][yy+2]==1&&p[xx-1][yy+1]==0&&f[xx-2][yy+2]!=ya){return 1;}
	if(xx>1&&yy>1) 
	if(p[xx-2][yy-2]==1&&p[xx-1][yy-1]==0&&f[xx-2][yy-2]!=ya){return 1;}
	if(yy>1&&xx<8) 
	if(p[xx+2][yy-2]==1&&p[xx+1][yy-1]==0&&f[xx+2][yy-2]!=ya){return 1;}
	return 0;
}
int cjhor(int xx,int yy,int ya)
{
	if(xx<8&&yy<8) 
	if(p[xx+2][yy+1]==1&&p[xx+1][yy]==0&&f[xx+2][yy+1]!=ya){return 1;}
	if(yy<8&&xx>1) 
	if(p[xx-2][yy+1]==1&&p[xx-1][yy]==0&&f[xx-2][yy+1]!=ya){return 1;}
	if(xx>1&&yy>0) 
	if(p[xx-2][yy-1]==1&&p[xx-1][yy]==0&&f[xx-2][yy-1]!=ya){return 1;}
	if(yy>0&&xx<8) 
	if(p[xx+2][yy-1]==1&&p[xx+1][yy]==0&&f[xx+2][yy-1]!=ya){return 1;}
	if(xx<9&&yy<7) 
	if(p[xx+1][yy+2]==1&&p[xx][yy+1]==0&&f[xx+1][yy+2]!=ya){return 1;}
	if(yy<7&&xx>0) 
	if(p[xx-1][yy+2]==1&&p[xx][yy+1]==0&&f[xx-1][yy+2]!=ya){return 1;}
	if(xx>0&&yy>1) 
	if(p[xx-1][yy-2]==1&&p[xx][yy-1]==0&&f[xx-1][yy-2]!=ya){return 1;}
	if(yy>1&&xx<9) 
	if(p[xx+1][yy-2]==1&&p[xx][yy-1]==0&&f[xx+1][yy-2]!=ya){return 1;}
	return 0;
}
int cjcar(int xx,int yy,int ya)
{
	for(int j=yy-1;j>=0;j--) if(p[xx][j]>0){if(p[xx][j]==1&&f[xx][j]!=ya) return 1;break;}
	for(int j=yy+1;j<=8;j++) if(p[xx][j]>0){if(p[xx][j]==1&&f[xx][j]!=ya) return 1;break;}
	for(int j=xx-1;j>=0;j--) if(p[j][yy]>0){if(p[j][yy]==1&&f[j][yy]!=ya) return 1;break;}
	for(int j=xx+1;j<=9;j++) if(p[j][yy]>0){if(p[j][yy]==1&&f[j][yy]!=ya) return 1;break;}
	return 0;
}
int cjduck(int xx,int yy,int ya)
{
	if(xx<7&&yy<7) 
	if(p[xx+2][yy+1]==0&&p[xx+1][yy]==0&&p[xx+3][yy+2]==1&&f[xx+3][yy+2]!=ya){return 1;}
	if(yy<7&&xx>2) 
	if(p[xx-2][yy+1]==0&&p[xx-1][yy]==0&&p[xx-3][yy+2]==1&&f[xx-3][yy+2]!=ya){return 1;}
	if(xx>2&&yy>1) 
	if(p[xx-2][yy-1]==0&&p[xx-1][yy]==0&&p[xx-3][yy-2]==1&&f[xx-3][yy-2]!=ya){return 1;}
	if(yy>1&&xx<7) 
	if(p[xx+2][yy-1]==0&&p[xx+1][yy]==0&&p[xx+3][yy-2]==1&&f[xx+3][yy-2]!=ya){return 1;}
	if(xx<8&&yy<6) 
	if(p[xx+1][yy+2]==0&&p[xx][yy+1]==0&&p[xx+2][yy+3]==1&&f[xx+2][yy+3]!=ya){return 1;}
	if(yy<6&&xx>1) 
	if(p[xx-1][yy+2]==0&&p[xx][yy+1]==0&&p[xx-2][yy+3]==1&&f[xx-2][yy+3]!=ya){return 1;}
	if(xx>1&&yy>2) 
	if(p[xx-1][yy-2]==0&&p[xx][yy-1]==0&&p[xx-2][yy-3]==1&&f[xx-2][yy-3]!=ya){return 1;}
	if(yy>2&&xx<8) 
	if(p[xx+1][yy-2]==0&&p[xx][yy-1]==0&&p[xx+2][yy-3]==1&&f[xx+2][yy-3]!=ya){return 1;}
	return 0;
}
int cjsold(int xx,int yy,int ya)
{
	if(cjcp(xx,yy,ya)==1||cjshi(xx,yy,ya)==1) return 1;
	return 0;
}
int cw(int z,int  zx)
{
	if(p[z][zx]==1) return 1;
	return 0; 
}
void pd()
{
	for(int j=0;j<=9;j++)
	for(int k=0;k<=8;k++)
	{
		if(p[j][k]>=1)
		{
			int e,d=p[j][k];
			e=0;if(d==1) e=max(e,cjcp(j,k,f[j][k]));if(d==2) e=max(e,cjshi(j,k,f[j][k]));if(d==3) e=max(e,cjele(j,k,f[j][k]));if(d==4) e=max(e,cjhor(j,k,f[j][k]));if(d==5) e=max(e,cjcar(j,k,f[j][k]));if(d==6) e=max(e,cjduck(j,k,f[j][k]));if(d==7) e=max(e,cjsold(j,k,f[j][k]));if(e==1) {cout<<"yes;no"<<endl;psc=0;return;}
		}
	} 
}
void checkcp(int aa,int bb,int cc,int dd)
{
	if(abs(aa-cc)>1||abs(bb-dd)>1){cout<<"Invalid command"<<endl;r=1-r;return;}
	if(aa!=cc&&bb!=dd){cout<<"Invalid command"<<endl;r=1-r;return;}
	if(r==0) cout<<"red"<<" ";else cout<<"blue"<<" ";cout<<"captain"<<";";
	if(f[cc][dd]!=-1)
	{
		int l=f[cc][dd];
		if(l==0) cout<<"red"<<" ";else cout<<"blue"<<" ";cout<<b[p[cc][dd]]<<";";
		if(cw(cc,dd)==1){cout<<"no;yes"<<endl;la=1;return;}
		p[cc][dd]=p[aa][bb];f[cc][dd]=f[aa][bb];p[aa][bb]=0;f[aa][bb]=-1;
	}
	else {cout<<"NA;";p[cc][dd]=p[aa][bb];f[cc][dd]=f[aa][bb];p[aa][bb]=0;f[aa][bb]=-1;}
	psc=1;pd(); if(psc==1) cout<<"no;no"<<endl;
}
void ckg(int aa,int bb,int cc,int dd)
{
	if(abs(aa-cc)>1||abs(bb-dd)>1){cout<<"Invalid command"<<endl;r=1-r;return;}
	if(aa==cc||bb==dd) {cout<<"Invalid command"<<endl;r=1-r;return;}
	if(r==0) cout<<"red"<<" ";else cout<<"blue"<<" ";cout<<"guard"<<";";
	if(f[cc][dd]!=-1) 
	{
		int l=f[cc][dd];
		if(l==0) cout<<"red"<<" ";if(l==1) cout<<"blue"<<" ";cout<<b[p[cc][dd]]<<";";
		if(cw(cc,dd)==1&&f[cc][dd]!=f[aa][bb]){cout<<"no;yes"<<endl;la=1;return;} 
		p[cc][dd]=p[aa][bb];f[cc][dd]=f[aa][bb];p[aa][bb]=0;f[aa][bb]=-1;
	}
	else {cout<<"NA;";p[cc][dd]=p[aa][bb];f[cc][dd]=f[aa][bb];p[aa][bb]=0;f[aa][bb]=-1;}
	psc=1;pd();if(psc==1) cout<<"no;no"<<endl;
}
void cke(int aa,int bb,int cc,int dd)
{
	if(abs(aa-cc)!=2||abs(bb-dd)!=2) {cout<<"Invalid command"<<endl;r=1-r;return;}
	if(p[(aa+cc)/2][(bb+dd)/2]!=0) {cout<<"Invalid command"<<endl;r=1-r;return;}
	if(r==0) cout<<"red"<<" ";else cout<<"blue"<<" ";cout<<"elephant"<<";";
	if(f[cc][dd]!=-1)
	{
		int l=f[cc][dd];
		if(l==0) cout<<"red"<<" ";if(l==1) cout<<"blue"<<" ";cout<<b[p[cc][dd]]<<";";
		if(cw(cc,dd)==1&&f[cc][dd]!=f[aa][bb]) {cout<<"no;yes"<<endl;la=1;return;}
		p[cc][dd]=p[aa][bb];f[cc][dd]=f[aa][bb];p[aa][bb]=0;f[aa][bb]=-1;
	}
	else {cout<<"NA;";p[cc][dd]=p[aa][bb];f[cc][dd]=f[aa][bb];p[aa][bb]=0;f[aa][bb]=-1;}
	psc=1;pd();if(psc==1) cout<<"no;no"<<endl;
}
void ckh(int aa,int bb,int cc,int dd)
{
	if(abs(aa-cc)>2||abs(bb-dd)>2) {cout<<"Invalid command"<<endl;r=1-r;return;}
	if(aa==cc||bb==dd){cout<<"Invalid command"<<endl;r=1-r;return;}
	if(abs(aa-cc)==1&&abs(bb-dd)==1){cout<<"Invalid command"<<endl;r=1-r;return;}
	if(abs(aa-cc)==2&&abs(bb-dd)==2){cout<<"Invalid command"<<endl;r=1-r;return;}
	if(abs(aa-cc)==2&&abs(bb-dd)==1){if(p[(aa+cc)/2][bb]!=0){cout<<"Invalid command"<<endl;r=1-r;return;}}
	if(abs(aa-cc)==1&&abs(bb-dd)==2){if(p[aa][(bb+dd)/2]!=0){cout<<"Invalid command"<<endl;r=1-r;return;}}
	if(r==0) cout<<"red"<<" ";else cout<<"blue"<<" ";cout<<"horse"<<";";
	if(f[cc][dd]!=-1)
	{
		int l=f[cc][dd];
		if(l==0) cout<<"red"<<" ";if(l==1) cout<<"blue"<<" ";cout<<b[p[cc][dd]]<<";";
		if(cw(cc,dd)==1&&f[cc][dd]!=f[aa][bb]) {cout<<"no;yes"<<endl;la=1;return;}
		p[cc][dd]=p[aa][bb];f[cc][dd]=f[aa][bb];p[aa][bb]=0;f[aa][bb]=-1;
	}
	else {cout<<"NA;";p[cc][dd]=p[aa][bb];f[cc][dd]=f[aa][bb];p[aa][bb]=0;f[aa][bb]=-1;}
	psc=1;pd();if(psc==1) cout<<"no;no"<<endl;
}
void ckc(int aa,int bb,int cc,int dd)
{
	if(aa!=cc&&bb!=dd){cout<<"Invalid command"<<endl;r=1-r;return;}
	if(aa!=cc)for(int j=min(aa,cc)+1;j<max(aa,cc);j++) if(p[j][bb]!=0){cout<<"Invalid command"<<endl;r=1-r;return;}
	if(bb!=dd)for(int j=min(bb,dd)+1;j<max(bb,dd);j++) if(p[aa][j]!=0){cout<<"Invalid command"<<endl;r=1-r;return;}
	if(r==0) cout<<"red"<<" ";else cout<<"blue"<<" ";cout<<"car"<<";";
	if(f[cc][dd]!=-1)
	{
		int l=f[cc][dd];
		if(l==0) cout<<"red"<<" ";if(l==1) cout<<"blue"<<" ";cout<<b[p[cc][dd]]<<";";
		if(cw(cc,dd)==1&&f[cc][dd]!=f[aa][bb]) {cout<<"no;yes"<<endl;la=1;return;}
		p[cc][dd]=p[aa][bb];f[cc][dd]=f[aa][bb];p[aa][bb]=0;f[aa][bb]=-1;
	}
	else {cout<<"NA;";p[cc][dd]=p[aa][bb];f[cc][dd]=f[aa][bb];p[aa][bb]=0;f[aa][bb]=-1;}
	psc=1;pd();if(psc==1) cout<<"no;no"<<endl;
}
void ckd(int aa,int bb,int cc,int dd)
{
	int sx,sy;
	if(aa<cc) sx=1;else sx=-1;
	if(bb<dd) sy=1;else sy=-1;
	if(abs(aa-cc)>3||abs(bb-dd)>3){cout<<"Invalid command"<<endl;r=1-r;return;}
	if(abs(aa-cc)<2||abs(bb-dd)<2){cout<<"Invalid command"<<endl;r=1-r;return;}
	if(abs(aa-cc)==abs(bb-dd)){cout<<"Invalid command"<<endl;r=1-r;return;}
	if(abs(aa-cc)==3){if(p[aa+sx*1][bb]!=0){cout<<"Invalid command"<<endl;r=1-r;return;}if(p[aa+sx*2][bb+sy*1]!=0){cout<<"Invalid command"<<endl;r=1-r;return;}}
	if(abs(bb-dd)==3){if(p[aa][bb+sy*1]!=0){cout<<"Invalid command"<<endl;r=1-r;return;}if(p[aa+sx*1][bb+sy*2]!=0){cout<<"Invalid command"<<endl;r=1-r;return;}}
	if(r==0) cout<<"red"<<" ";else cout<<"blue"<<" ";cout<<"duck"<<";";
	if(f[cc][dd]!=-1)
	{
		int l=f[cc][dd];
		if(l==0) cout<<"red"<<" ";if(l==1) cout<<"blue"<<" ";cout<<b[p[cc][dd]]<<";";
		if(cw(cc,dd)==1&&f[cc][dd]!=f[aa][bb]) {cout<<"no;yes"<<endl;la=1;return;}
		p[cc][dd]=p[aa][bb];f[cc][dd]=f[aa][bb];p[aa][bb]=0;f[aa][bb]=-1;
	}
	else {cout<<"NA;";p[cc][dd]=p[aa][bb];f[cc][dd]=f[aa][bb];p[aa][bb]=0;f[aa][bb]=-1;}
	psc=1;pd(); if(psc==1) cout<<"no;no"<<endl;
}
void cks(int aa,int bb,int cc,int dd)
{
	if(abs(aa-cc)>1||abs(bb-dd)>1){cout<<"Invalid command"<<endl;r=1-r;return;}
	if(r==0) cout<<"red"<<" ";else cout<<"blue"<<" ";cout<<"soldier"<<";";
	if(f[cc][dd]!=-1)
	{
		int l=f[cc][dd];
		if(l==0) cout<<"red"<<" ";if(l==1) cout<<"blue"<<" ";cout<<b[p[cc][dd]]<<";";
		if(cw(cc,dd)==1&&f[cc][dd]!=f[aa][bb]) {cout<<"no;yes"<<endl;la=1;return;}
		p[cc][dd]=p[aa][bb];f[cc][dd]=f[aa][bb];p[aa][bb]=0;f[aa][bb]=-1;
	}
	else {cout<<"NA;";p[cc][dd]=p[aa][bb];f[cc][dd]=f[aa][bb];p[aa][bb]=0;f[aa][bb]=-1;}
	psc=1;pd();if(psc==1) cout<<"no;no"<<endl;
}
int main()
{
for(int i=0;i<=9;i++)
for(int j=0;j<=8;j++) f[i][j]=-1;
b[1]="captain";b[2]="guard";b[3]="elephant";b[4]="horse";b[5]="car";b[6]="duck";b[7]="soldier";
for(int i=0;i<=8;i+=2) {p[3][i]=7;f[3][i]=0;}p[2][0]=6;f[2][0]=0;p[2][8]=6;f[2][8]=0;
for(int i=0;i<=8;i+=2) {p[6][i]=7;f[6][i]=1;}p[7][0]=6;f[7][0]=1;p[7][8]=6;f[7][8]=1;
for(int i=0;i<=8;i++) {f[0][i]=0;f[9][i]=1;}p[0][0]=5;p[0][8]=5;p[9][0]=5;p[9][8]=5;p[0][1]=4;p[0][7]=4;p[9][1]=4;p[9][7]=4;p[0][2]=3;p[0][6]=3;p[9][2]=3;p[9][6]=3;p[0][3]=2;p[0][5]=2;p[9][3]=2;p[9][5]=2;p[0][4]=1;p[9][4]=1;
cin>>q;
for(int i=1;i<=q;i++)
{
	cin>>x>>y>>x2>>y2;
	if(x<0||y<0||x2>9||y2>8||x>9||y>8||x2<0||y2<0) cout<<"Invalid command"<<endl;
	else if(p[x][y]==0) cout<<"Invalid command"<<endl;
	else if(p[x2][y2]!=0&&f[x2][y2]==f[x][y]) cout<<"Invalid command"<<endl; 
	else if(f[x][y]!=r||f[x2][y2]==r) cout<<"Invalid command"<<endl;
	else if(la==1) cout<<"Invalid command"<<endl; 
	else if(x==x2&&y==y2) cout<<"Invalid command"<<endl;
	else{if(p[x][y]==1) checkcp(x,y,x2,y2);if(p[x][y]==2) ckg(x,y,x2,y2);if(p[x][y]==3) cke(x,y,x2,y2);if(p[x][y]==4) ckh(x,y,x2,y2);if(p[x][y]==5) ckc(x,y,x2,y2);if(p[x][y]==6) ckd(x,y,x2,y2);if(p[x][y]==7) cks(x,y,x2,y2);r=1-r;}
	}
	return 0;
}
```
这样我们就AC了这道题鸭





---

## 作者：zhangchenyuan (赞：4)

此题就是一个大模拟，但是同其他模拟一样，有很多坑点，坑点如下：

1、题目中说将军局面的形成包括（**但不限于**）如下这些可能。所以我们需要考虑把王移到对方能将军的地方的情况。

2、结束游戏后全部输出Invalid command

3、要判当前回合是不是选择颜色的棋走

4、和象棋不同的是，双王面对面不会形成将军局面

具体见代码

```cpp
#include<bits/stdc++.h>
using namespace std;
char q[11][10];
int col[11][10];
string f[200];
int wrx,wry,wbx,wby;
string c[3];
void init()
{
    for(int i=0;i<10;i++)
    for(int j=0;j<10;j++)
    q[i][j]='.';
    f['w']="captain";
    f['s']="guard";
    f['x']="elephant";
    f['m']="horse";
    f['c']="car";
    f['y']="duck";
    f['b']="soldier";
    c[1]="red";
    c[2]="blue";
    q[0][0]=q[9][0]=q[0][8]=q[9][8]='c';
    q[0][1]=q[9][1]=q[0][7]=q[9][7]='m';
    q[0][2]=q[9][2]=q[0][6]=q[9][6]='x';
    q[0][3]=q[9][3]=q[0][5]=q[9][5]='s';
    q[0][4]=q[9][4]='w';
    q[2][0]=q[7][0]=q[2][8]=q[7][8]='y';
    q[3][0]=q[3][2]=q[3][4]=q[3][6]=q[3][8]='b';
    q[6][0]=q[6][2]=q[6][4]=q[6][6]=q[6][8]='b';//初始化棋盘
    col[0][0]=col[0][8]=1;
    col[9][0]=col[9][8]=2;
    col[0][1]=col[0][7]=1;
    col[9][1]=col[9][7]=2;
    col[0][2]=col[0][6]=1;
    col[9][2]=col[9][6]=2;
    col[0][3]=col[0][5]=1;
    col[9][3]=col[9][5]=2;
    col[0][4]=1;
    col[9][4]=2;
    col[2][0]=col[2][8]=1;
    col[7][8]=col[7][0]=2;
    col[3][0]=col[3][2]=col[3][4]=col[3][6]=col[3][8]=1;
    col[6][0]=col[6][2]=col[6][4]=col[6][6]=col[6][8]=2;//初始化颜色
    wrx=0;
    wry=4;
    wbx=9;
    wby=4;
}
bool checkgo(int x,int y,int u,int v)//判断能否走到
{
    if(q[x][y]=='w')
    {
        if((x==u&&abs(y-v)==1)||(abs(x-u)==1&&y==v))
        return true;
        else return false;
    }
    if(q[x][y]=='b')
    {
        if(abs(x-u)<=1&&abs(y-v)<=1)
        return true;
        else return false;
    }
    if(q[x][y]=='s')
    {
        if(abs(x-u)==1&&abs(y-v)==1)
        return true;
        else return false;
    }
    if(q[x][y]=='x')
    {
        if(abs(x-u)==2&&abs(y-v)==2&&q[(x+u)/2][(y+v)/2]=='.')
        return true;
        else return false;
    }
    if(q[x][y]=='m')
    {
        if(abs(x-u)+abs(y-v)==3&&abs(x-u)!=0&&abs(y-v)!=0)
        {
            if(abs(x-u)==2)
            {
                if(q[(x+u)/2][y]=='.')
                return true;
                else return false;
            }
            else
            {
                if(q[x][(y+v)/2]=='.')
                return true;
                else return false;
            }
        }
        else return false;
    }
    if(q[x][y]=='c')
    {
        if(abs(x-u)==0||abs(y-v)==0)
        {
            int t;
            if(abs(x-u)==0)
            {
                if(y>v)
                t=-1;
                else t=1;
                for(int i=y+t;i!=v;i+=t)
                if(q[x][i]!='.')
                return false;
                return true;
            }
            else
            {
                if(x>u)
                t=-1;
                else t=1;
                for(int i=x+t;i!=u;i+=t)
                if(q[i][y]!='.')
                return false;
                return true;
            }
        }
        else return false;
    }
    if(q[x][y]=='y')
    {
        if(abs(x-u)+abs(y-v)==5&&abs(x-u)>=2&&abs(y-v)>=2)
        {
            int t;
            if(abs(x-u)==2)
            {
                if(y>v)
                t=-1;
                else t=1;
                if(q[x][y+t]=='.'&&q[(x+u)/2][y+2*t]=='.')
                return true;
                else return false;
            }
            else
            {
                if(x>u)
                t=-1;
                else t=1;
                if(q[x+t][y]=='.'&&q[x+2*t][(y+v)/2]=='.')
                return true;
                else return false;
            }
        }
        else return false;
    }
    return true;
   	//以上就是分类讨论
}
const int bx[9]={0,1,1,1,0,0,-1,-1,-1};
const int by[9]={0,1,0,-1,1,-1,1,0,-1};
const int wx[5]={0,1,-1,0,0};
const int wy[5]={0,0,0,1,-1};
const int sx[5]={0,1,1,-1,-1};
const int sy[5]={0,1,-1,1,-1};
const int xx[5]={0,2,2,-2,-2};
const int xy[5]={0,2,-2,2,-2};
const int mcx[9]={0,1,1,-1,-1,1,-1,1,-1};//
const int mcy[9]={0,1,-1,1,-1,1,1,-1,-1};//
const int mx[9]={0,2,2,-2,-2,1,-1,1,-1};
const int my[9]={0,1,-1,1,-1,2,2,-2,-2};
const int ycx1[9]={0,1,1,-1,-1,1,-1,1,-1};//
const int ycy1[9]={0,1,-1,1,-1,1,1,-1,-1};//
const int ycx2[9]={0,2,2,-2,-2,2,-2,2,-2};//
const int ycy2[9]={0,2,-2,2,-2,2,2,-2,-2};//
const int yx[9]={0,3,3,-3,-3,2,-2,2,-2};
const int yy[9]={0,2,-2,2,-2,3,3,-3,-3};
//在这里我的方法是从王开始倒推以不能按照题目意思判能否走
//具体见注释行
bool check(int x,int y)//判断是否形成将军局面
{
    for(int i=1;i<=4;i++)
    {
        int ax=x+wx[i],ay=y+wy[i];
        if(ax>=0&&ax<=9&&ay>=0&&ay<=8&&q[ax][ay]=='w'&&col[x][y]!=col[ax][ay])
        return true;
    }//判断会不会被对方王将军
    for(int i=1;i<=4;i++)
    {
        int ax=x+sx[i],ay=y+sy[i];
        if(ax>=0&&ax<=9&&ay>=0&&ay<=8&&q[ax][ay]=='s'&&col[x][y]!=col[ax][ay])
        return true;
    }//判断会不会被对方士将军
    for(int i=1;i<=8;i++)
    {
        int ax=x+bx[i],ay=y+by[i];
        if(ax>=0&&ax<=9&&ay>=0&&ay<=8&&q[ax][ay]=='b'&&col[x][y]!=col[ax][ay])
        return true;
    }//判断会不会被对方兵将军
    for(int i=1;i<=4;i++)
    {
        int ax=x+xx[i],ay=y+xy[i];
        if(ax>=0&&ax<=9&&ay>=0&&ay<=8&&q[ax][ay]=='x'&&col[x][y]!=col[ax][ay]&&q[x+sx[i]][y+sy[i]]=='.')
        return true;
    }//判断会不会被对方象将军
    for(int i=1;i<=8;i++)
    {
        int ax=x+mx[i],ay=y+my[i];
        int ax1=x+mcx[i],ay1=y+mcy[i];
        if(ax>=0&&ax<=9&&ay>=0&&ay<=8&&q[ax][ay]=='m'&&col[x][y]!=col[ax][ay]&&q[ax1][ay1]=='.')
        return true;
    }//判断会不会被对方马将军
    for(int i=1;i<=8;i++)
    {
        int ax=x+yx[i],ay=y+yy[i];
        int ax1=x+ycx1[i],ay1=y+ycy1[i];
        int ax2=x+ycx2[i],ay2=y+ycy2[i];
        if(ax>=0&&ax<=9&&ay>=0&&ay<=8&&q[ax][ay]=='y'&&col[x][y]!=col[ax][ay]&&q[ax1][ay1]=='.'&&q[ax2][ay2]=='.')
        return true;
    }//判断会不会被对方鸭将军
    int ax=x,ay=y;
    while(++ax>=0&&ax<=9&&ay>=0&&ay<=8)
    {
        if(q[ax][ay]=='c'&&col[x][y]!=col[ax][ay])
        return true;
        if(q[ax][ay]!='.')
        break;
    }
    ax=x,ay=y;
    while(--ax>=0&&ax<=9&&ay>=0&&ay<=8)
    {
        if(q[ax][ay]=='c'&&col[x][y]!=col[ax][ay])
        return true;
        if(q[ax][ay]!='.')
        break;
    }
    ax=x,ay=y;
    while(ax>=0&&ax<=9&&++ay>=0&&ay<=8)
    {
        if(q[ax][ay]=='c'&&col[x][y]!=col[ax][ay])
        return true;
        if(q[ax][ay]!='.')
        break;
    }
    ax=x,ay=y;
    while(ax>=0&&ax<=9&&--ay>=0&&ay<=8)
    {
        if(q[ax][ay]=='c'&&col[x][y]!=col[ax][ay])
        return true;
        if(q[ax][ay]!='.')
        break;
    }
    //判断会不会被对方车将军
    return false;
}
int main()
{
    init();
    int n,u,v,x,y,turn=1,over=0;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d%d%d",&x,&y,&u,&v);
        if(turn!=col[x][y]||q[x][y]=='.'||col[x][y]==col[u][v]||over) //不管棋看能否走
        puts("Invalid command");
        else
        {
            bool cmp=checkgo(x,y,u,v);//根据棋子类型判断能否走到
            if(!cmp)
            {
                puts("Invalid command");
                continue;
            }
            turn=3-turn;//过了1个回合
            cout<<c[col[x][y]]<<' '<<f[q[x][y]]<<';';
            if(q[u][v]=='.')
            cout<<"NA;";
            else cout<<c[col[u][v]]<<' '<<f[q[u][v]]<<';';
            if(q[u][v]=='w')
            {
                puts("no;yes");
                over=1;
                continue;
            }//判断是否结束
            if(q[x][y]=='w')
            {
                if(col[x][y]==1)
                {
                    wrx=u;
                    wry=v;
                }
                else
                {
                    wbx=u;
                    wby=v;
                }
            }//更新王的位置
            q[u][v]=q[x][y];
            q[x][y]='.';
            col[u][v]=col[x][y];
            col[x][y]=0;//更新走的棋的位置
            bool f1=check(wrx,wry),f2=check(wbx,wby);//判断是否形成将军局面
            if(f1||f2)
            cout<<"yes;";
            else cout<<"no;";
            puts("no");
        }
    }
    return 0;
}

```

---

## 作者：pyqpyq (赞：3)

既然是首黑就留下一篇题解纪念一下吧……

先把[题目链接](https://www.luogu.com.cn/problem/P5380)放上，然后步入正题：
# 题目分析
首先分析题目五个问题：

* 判断移动其是否合法。
* 这步操作移动了哪个棋子。
* 这步操作**后**，是否存在棋子被移出游戏，如有则还需求出被移出游戏的棋子。
* 这步操作**后**，是否形成将军局面。
* 这步操作**后**，游戏是否结束。

第二、三、五个问题都很好解决，只需要在棋盘的对应位置上找到对应棋子就行。如果移出棋子是王，则游戏结束。

而第一、四个问题有一点复杂。

对于操作是否合法，我们先判断被移动的棋子是否存在、是否会移走同一个人的棋子等~~奇奇怪怪的东西~~，然后按照被移走的棋子种类分类讨论。

而对于是否将军，我们逐个枚举棋盘上的棋是否对王造成威胁，又转换成第一个问题了。

$Q$: 枚举？不会$TLE$？

$A$: 不存在的，棋盘这么小，怎么瞎搞都不可能$TLE$的（除非死循环）。
# 代码分析
题目分析完了就开工吧。
## 基本定义
```cpp
#include<bits/stdc++.h>
using namespace std;
char playe[3][5]= {"","red","blue"},chess[9][9]= {"","captain","guard","elephant","horse","car","duck","soldier"};
int board[11][9]=
{
	{+5,+4,+3,+2,+1,+2,+3,+4,+5},
	{0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 },
	{+6,0 ,0 ,0 ,0 ,0 ,0 ,0 ,+6},
	{+7,0 ,+7,0 ,+7,0 ,+7,0 ,+7},
	{0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 },
	{0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 },
	{-7,0 ,-7,0 ,-7,0 ,-7,0 ,-7},
	{-6,0 ,0 ,0 ,0 ,0 ,0 ,0 ,-6},
	{0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 },
	{-5,-4,-3,-2,-1,-2,-3,-4,-5}
},s=1,l=1;
int owner(int x,int y)
{
	if(board[x][y]==0)return 0;
	if(board[x][y]>0)return 1;
	if(board[x][y]<0)return 2;
}
int dtype(int x,int y)
{
	if(owner(x,y)==0)return 0;
	if(owner(x,y)==1)return board[x][y];
	if(owner(x,y)==2)return -board[x][y];
}
```
`playe`和`chess`分别是玩家和棋子的英文名称。

`board`是棋盘，上面的棋子用符号表示所属玩家，绝对值表示棋子种类，$0$则为空。（具体对应关系见`playe`和`chess`）

`s`和`l`分别表示游戏是否结束（**未结束是1**）和轮到哪一方。

`owner` 和 `dtype` 分别用来求在某个位置的棋子的所属玩家和种类。

$Q$: 为什么要把这两个函数单独列出来呢？

$A$: 便于调试。如果把这两个函数翻译到代码里，写错的话改起来很麻烦。拿出来就只要改一处了。
## 分类讨论
```cpp
bool cacar(int fx,int fy,int tx,int ty)
{
	if(fx==tx&&fy<ty)
	{
		for(int i=fy+1; i<ty; ++i)if(owner(fx,i))return 0;
		return 1;
	}
	if(fx==tx&&fy>ty)
	{
		for(int i=ty+1; i<fy; ++i)if(owner(fx,i))return 0;
		return 1;
	}
	if(fx<tx&&fy==ty)
	{
		for(int i=fx+1; i<tx; ++i)if(owner(i,fy))return 0;
		return 1;
	}
	if(fx>tx&&fy==ty)
	{
		for(int i=tx+1; i<fx; ++i)if(owner(i,fy))return 0;
		return 1;
	}
	return 0;
}
bool caduc(int fx,int fy,int tx,int ty)
{
	if(!owner(fx+2,fy+1)&&!owner(fx+1,fy)&&fx+3==tx&&fy+2==ty)return 1;
	if(!owner(fx+2,fy-1)&&!owner(fx+1,fy)&&fx+3==tx&&fy-2==ty)return 1;
	if(!owner(fx-2,fy+1)&&!owner(fx-1,fy)&&fx-3==tx&&fy+2==ty)return 1;
	if(!owner(fx-2,fy-1)&&!owner(fx-1,fy)&&fx-3==tx&&fy-2==ty)return 1;
	if(!owner(fx+1,fy+2)&&!owner(fx,fy+1)&&fx+2==tx&&fy+3==ty)return 1;
	if(!owner(fx+1,fy-2)&&!owner(fx,fy-1)&&fx+2==tx&&fy-3==ty)return 1;
	if(!owner(fx-1,fy+2)&&!owner(fx,fy+1)&&fx-2==tx&&fy+3==ty)return 1;
	if(!owner(fx-1,fy-2)&&!owner(fx,fy-1)&&fx-2==tx&&fy-3==ty)return 1;
	return 0;
}

```
这个部分用来分类讨论每种棋子移动是否合法，每种棋子打一个函数。这部分怎么搞都可以，我直接把所有可能的情况打到 `if` 的括号里了。如果合法就返回 $1$，否则返回 $0$。

这里就只放了最复杂的鸭和最特殊的车。不全放了，有三个 $KB$，其它以鸭类推就行。

## 判断合法
```cpp
bool cango(int fx,int fy,int tx,int ty)
{
	if(!owner(fx,fy)||owner(fx,fy)==owner(tx,ty))return 0;
	if(dtype(fx,fy)==1)return cacap(fx,fy,tx,ty);
	if(dtype(fx,fy)==2)return cagua(fx,fy,tx,ty);
	if(dtype(fx,fy)==3)return caele(fx,fy,tx,ty);
	if(dtype(fx,fy)==4)return cahor(fx,fy,tx,ty);
	if(dtype(fx,fy)==5)return cacar(fx,fy,tx,ty);
	if(dtype(fx,fy)==6)return caduc(fx,fy,tx,ty);
	if(dtype(fx,fy)==7)return casol(fx,fy,tx,ty);
}
```
下面的七个 `if` 就是把分类讨论汇总。
而第一个 `if` 用来判断原位置是否有棋和是否移走同一队的棋。和上面一样，如果合法就返回 $1$，否则返回 $0$。

$Q$: 为啥不把汇总放分类讨论上面？

$A$: $C++$ 不准这么干……如果非要这样不可，需要在汇总前面加函数声明，代码就长了。（关于函数声明可自行百度）
## 判断将军
```cpp
bool attac()
{
	if(!s)return 0;
	int rx,ry,bx,by;
	for(int i=0; i<10; ++i)
		for(int j=0; j<9; ++j)
			if(dtype(i,j)==1)
			{
				if(owner(i,j)==1)rx=i,ry=j;
				else if(owner(i,j)==2)bx=i,by=j;
			}
	for(int i=0; i<10; ++i)
		for(int j=0; j<9; ++j)
		{
			if(cango(i,j,rx,ry))return 1;
			else if(cango(i,j,bx,by))return 1;
		}
	return 0;
}
```
正如前面所讲，先枚举出每个王的位置，在枚举其它棋是否对王造成威胁。第一个 `if` 用来处理题面中的加粗的注意事项。还是如果将军就返回 $1$，否则返回 $0$。
## 处理移动
```cpp
void dmove(int fx,int fy,int tx,int ty)
{
	if(!cango(fx,fy,tx,ty)/*移动是否合法*/||!s/*游戏是否结束*/||owner(fx,fy)!=l/*是否轮到该玩家*/)/*问题一*/
	{
		printf("Invalid command\n");/*输出无解*/ 
		return;/*结束该步骤*/ 
	}
	if(dtype(tx,ty)==1)s=0;/**/
	printf("%s %s;",playe[owner(fx,fy)],chess[dtype(fx,fy)]);/*问题二*/ 
	if(owner(tx,ty))printf("%s %s;",playe[owner(tx,ty)],chess[dtype(tx,ty)]);/*问题三*/ 
	else printf("NA;");
	board[tx][ty]=board[fx][fy];/*移动棋子，顺便覆盖*/ 
	board[fx][fy]=0;/*原位置变空*/ 
	if(attac())printf("yes;");/*问题四*/
	else printf("no;"); 
	if(s)printf("no\n");/*问题五*/
	else printf("yes\n");
	l=3-l;/*换人*/ 
}
```
这是最核心的部分，也是所有问题的汇总。一定要注意操作顺序（这就是为什么要我在列问题时要把“后”加粗）。其它的都写在注释里了。
## 主函数
```cpp
int main()
{
	int q,fx,fy,tx,ty;
	scanf("%d",&q);
	while(q--)scanf("%d%d%d%d",&fx,&fy,&tx,&ty),dmove(fx,fy,tx,ty);
}
```
没什么好讲的……
# 最后
完整代码不放了，把上面的代码拼起来就行。

细节还是很多的，一不小心就 $WA$ 。建议造几组数据$hack$掉自己的程序。~~还可以和同学用自己的程序玩一局来找BUG。~~ 否则就就静态查错（瞪眼观察法）吧……

题目中也有很多细节，要认真读题。

$BUG$ 找完就 $AC$ 了！（完结撒花\\(^o^)/ ）

---

## 作者：shentao1 (赞：2)

~~坑爹题目，毁我青春~~

这是一道很烦很烦的大模拟，我用了大概4h才AC

我的思路是这样的：

1、初始化：初始化棋盘，使用[结构体]完成，col表示颜色，qz表示棋子类型，将颜色初始化为红色，是否结束为未结束
(https://baike.baidu.com/item/%E7%BB%93%E6%9E%84%E4%BD%93/3709485?fr=aladdin)

2、判断是否合法，其中又分为n小点：

2.1 游戏已经结束

2.2 起点无己方棋子

### 己方！己方！

2.3 终点无对方棋子

2.4 路线不正确

2.5 有绊马/象/鸭腿的情况

3、回答第一个问题：用数组存序号，直接输出colour[x]和chess[x]就可以了

4、回答第二个问题，同样简单

5、吃棋子并移动

6、回答第三个问题（是否将军），我发现@zhangchenyuan 大佬的题解中说“和象棋不同的是，双王面对面不会形成将军局面”，我并不认同
~~（毕竟我没有特判也A了）~~

7、回答第四个问题，这个问题就很简单了，在回答第二个问题时一起判好就行了。

我认为的坑点：

#### 1、序列中的不合法操作是需要被忽略的。比如，如果轮到红方移动，此时序列中的当前操作恰好是不合法的，则这个操作将被忽略，序列中的下一步操作将成为红方这步的操作（如仍不合法则继续忽略，直至出现合法的操作）。

#### 2、除此之外，需要特别说明的是，游戏结束后，由于双方不可再操作，因此不可能出现将军局面，即便此时另一方王处于被「攻击」的位置。

last but not least,代码闪亮登场：

```
#include<bits/stdc++.h>
using namespace std;
struct duck_chess{
    int qz,col;
}a[11][11];//the chess
const string chess[8]={"","car","horse","elephant","guard","captain","duck","soldier"};
const string colour[3]={"","red","blue"};
//horse
const int pd_horse_x[8]={1,-1,0,0,1,-1,0,0};
const int pd_horse_y[8]={0,0,1,-1,0,0,1,-1};
const int dx_horse[8]={2,-2,1,1,2,-2,-1,-1};
const int dy_horse[8]={1,1,2,-2,-1,-1,2,-2};
//elephant
const int pd_elephant_x[4]={1,-1,1,-1};
const int pd_elephant_y[4]={-1,1,1,-1};
const int dx_elephant[4]={2,-2,2,-2};
const int dy_elephant[4]={-2,2,2,-2};
//guard
const int dx_guard[4]={1,-1,1,-1};
const int dy_guard[4]={-1,1,1,-1};
//captain
const int dx_captain[4]={1,-1,0,0};
const int dy_captain[4]={0,0,1,-1};
//duck
const int pd_duck_x[16]={1,-1,0,0,1,-1,0,0,2,-2,1,1,2,-2,-1,-1};
const int pd_duck_y[16]={0,0,1,-1,0,0,1,-1,1,1,2,-2,1,1,2,-2};
const int dx_duck[8]={3,-3,2,2,3,-3,-2,-2};
const int dy_duck[8]={2,2,3,-3,-2,-2,3,-3};
//soldier
const int dx_soldier[8]={1,-1,0,0,1,1,-1,-1};
const int dy_soldier[8]={0,0,1,-1,1,-1,1,-1};
//judge and checkmate
int n,colo,end;
inline void init(){//Initialization
    cin>>n;
    for (register int i=1;i<=9;i++) a[1][i].col=1,a[10][i].col=2;//car horse elephant guard captain
    for (register int i=1;i<=9;i+=2) a[4][i].col=1,a[7][i].col=2;//soldier
    for (register int i=1;i<=9;i+=8) a[3][i].col=1,a[8][i].col=2;//duck
    for (register int i=1;i<=5;i++) a[1][i].qz=a[1][10-i].qz=a[10][i].qz=a[10][10-i].qz=i;//the same
    for (register int i=1;i<=9;i+=2) a[4][i].qz=a[7][i].qz=7;
    for (register int i=1;i<=9;i+=8) a[3][i].qz=a[8][i].qz=6;
    colo=1;//At first the colour is red;
    end=0;//The game didn't end;
}
int main(){
    init();
    while (n--){
        int sx,sy,ex,ey;
        cin>>sx>>sy>>ex>>ey;
        sx++;
        sy++;
        ex++;
        ey++;//start from 1
        //to decide if it is wrongful
        if (end==1) {//If the game ends
            cout<<"Invalid command"<<endl;
            continue;
        }
        if (a[sx][sy].col!=colo) {//If there isn't any chess
            cout<<"Invalid command"<<endl;
            continue;
        } 
        if (a[ex][ey].col==colo) {
            cout<<"Invalid command"<<endl;
            continue;
        }//If where the chess will go has a same_color chess on it
        if (a[sx][sy].qz==1) {//car
            if (ex!=sx&&ey!=sy) {//If the line isn't straight
                cout<<"Invalid command"<<endl;
                continue;
            }
            int f=0;
            if (ex==sx) {//across
                for (int j=min(sy,ey)+1;j<max(sy,ey);j++) 
                    if (a[sx][j].col!=0) {//If there's chess on the way
                        cout<<"Invalid command"<<endl;
                        f=1;
                        break;
                    }
                if (f==1) continue;//over
            }
            else {//straight
                for (int j=min(sx,ex)+1;j<max(sx,ex);j++) 
                    if (a[j][sy].col!=0) {//If there's chess on the way
                        cout<<"Invalid command"<<endl;
                        f=1;
                        break;
                    }
                if (f==1) continue;//over
            }
        }
        if (a[sx][sy].qz==2) {//horse
            int f=0,tx=abs(sx-ex),ty=abs(sy-ey);
            int dx=sx-ex>0?1:-1,dy=sy-ey>0?1:-1;
            if (max(tx,ty)!=2||min(tx,ty)!=1) {//If the way is wrongful
                cout<<"Invalid command"<<endl;
                continue;
            }
            if (a[sx-(tx-1)*dx][sy-(ty-1)*dy].col!=0) {
                cout<<"Invalid command"<<endl;
                continue;
            }//If there's chess on the way
        }
        if (a[sx][sy].qz==3) {//elephant
            int f=0,tx=abs(sx-ex),ty=abs(sy-ey);
            int dx=sx-ex>0?1:-1,dy=sy-ey>0?1:-1;
            if (tx!=2||ty!=2) {//If the way is wrongful
                cout<<"Invalid command"<<endl;
                continue;
            }
            if (a[sx-dx][sy-dy].col!=0) {
                cout<<"Invalid command"<<endl;
                continue;
            }//If there's chess on the way
        }
        if (a[sx][sy].qz==4) {//guard
            int f=0,tx=abs(sx-ex),ty=abs(sy-ey);
            if (tx!=1||ty!=1) {//If the way is wrongful
                cout<<"Invalid command"<<endl;
                continue;
            }
        }
        if (a[sx][sy].qz==5) {//captain
            int f=0,tx=abs(sx-ex),ty=abs(sy-ey);
            if (max(tx,ty)!=1||min(tx,ty)!=0) {//If the way is wrongful
                cout<<"Invalid command"<<endl;
                continue;
            }
        }
        if (a[sx][sy].qz==6) {//duck
            int f=0,tx=abs(sx-ex),ty=abs(sy-ey);
            int dx=sx-ex>0?1:-1,dy=sy-ey>0?1:-1;
            if (max(tx,ty)!=3||min(tx,ty)!=2) {//If the way is wrongful
                cout<<"Invalid command"<<endl;
                continue;
            }
            if (a[sx-(tx-1)*dx][sy-(ty-1)*dy].col!=0||a[sx-(tx-2)*dx][sy-(ty-2)*dy].col!=0) {
                cout<<"Invalid command"<<endl;
                continue;
            }//If there's chess on the way
        }
        if (a[sx][sy].qz==7) {//soldier
            int f=0,tx=abs(sx-ex),ty=abs(sy-ey);
            if (max(tx,ty)!=1||(min(tx,ty)!=0&&min(tx,ty)!=1)) {
                cout<<"Invalid command"<<endl;
                continue;
            }//If the way is wrongful
        }
        cout<<colour[colo]<<' '<<chess[a[sx][sy].qz]<<';';//the start chess
        if (a[ex][ey].col!=0) //the end chess
            cout<<colour[a[ex][ey].col]<<' '<<chess[a[ex][ey].qz]<<';';
        else cout<<"NA;";
        if (a[ex][ey].qz==5) {end=1;cout<<"no;yes"<<endl;continue;}
        a[ex][ey].qz=a[sx][sy].qz;
        a[ex][ey].col=a[sx][sy].col;//eat it
        a[sx][sy].qz=a[sx][sy].col=0;//move it
        int f=0;
        for (int i=1;i<=10;i++){
            for (int j=1;j<=9;j++) {
                if (a[i][j].qz==1) {//car
                    for (int k=i-1;k>0;k--) //up
                        if (a[k][j].qz!=0&&a[k][j].qz!=5) break;
                        else if (a[k][j].qz==5&&a[k][j].col!=a[i][j].col) {f=1;break;}
                        else if (a[k][j].qz==5) break;
                    if (f==1) break;
                    for (int k=i+1;k<=10;k++) //down
                        if (a[k][j].qz!=0&&a[k][j].qz!=5) break;
                        else if (a[k][j].qz==5&&a[k][j].col!=a[i][j].col) {f=1;break;}
                        else if (a[k][j].qz==5) break;
                    if (f==1) break;
                    for (int k=j-1;k>0;k--) //left
                        if (a[i][k].qz!=0&&a[i][k].qz!=5) break;
                        else if (a[i][k].qz==5&&a[i][k].col!=a[i][j].col) {f=1;break;}
                        else if (a[i][k].qz==5) break;
                    if (f==1) break;
                    for (int k=j+1;k<=9;k++) //right
                        if (a[i][k].qz!=0&&a[i][k].qz!=5) break;
                        else if (a[i][k].qz==5&&a[i][k].col!=a[i][j].col) {f=1;break;}
                        else if (a[i][k].qz==5) break;
                    if (f==1) break;
                }
                if (f==1) break;
                if (a[i][j].qz==2) {//horse
                    for (int k=0;k<8;k++) {
                        int tx=i+pd_horse_x[k],ty=j+pd_horse_y[k];
                        if (a[tx][ty].qz!=0) continue;
                        //judge if I can move the chess
                        int dx=i+dx_horse[k],dy=j+dy_horse[k];
                        if (dx>0&&dx<11&&dy>0&&dy<10&&a[dx][dy].qz==5&&a[dx][dy].col!=a[i][j].col) {f=1;break;}
                        //to check if there's checkmate
                    }
                    if (f==1) break;
                }
                if (f==1) break;
                if (a[i][j].qz==3) {//elephant
                    for (int k=0;k<4;k++) {
                        int tx=i+pd_elephant_x[k],ty=j+pd_elephant_y[k];
                        if (a[tx][ty].qz!=0) continue;
                        //judge if I can move the chess
                        int dx=i+dx_elephant[k],dy=j+dy_elephant[k];
                        if (dx>0&&dx<11&&dy>0&&dy<10&&a[dx][dy].qz==5&&a[dx][dy].col!=a[i][j].col) {f=1;break;}
                        //to check if there's checkmate
                    }
                    if (f==1) break;
                }
                if (f==1) break;
                if (a[i][j].qz==4) {//guard
                    for (int k=0;k<4;k++) {
                        int dx=i+dx_guard[k],dy=j+dy_guard[k];
                        if (dx>0&&dx<11&&dy>0&&dy<10&&a[dx][dy].qz==5&&a[dx][dy].col!=a[i][j].col) {f=1;break;}
                        //to check if there's checkmate
                    }
                    if (f==1) break;
                }
                if (f==1) break; 
                 if (a[i][j].qz==5) {//captain
                 	for (int k=0;k<4;k++) {
                 		int dx=i+dx_captain[k],dy=j+dy_captain[k];
                 		if (dx>0&&dx<11&&dy>0&&dy<10&&a[dx][dy].qz==5&&a[dx][dy].col!=a[i][j].col) {f=1;break;}
                 		//to check if there's checkmate
                 	}
                 	if (f==1) break;
                }
                if (f==1) break;
                if (a[i][j].qz==6) {//duck
                    for (int k=0;k<8;k++) {
                        int tx=i+pd_duck_x[k],ty=j+pd_duck_y[k];
                        if (a[tx][ty].qz!=0) continue;
                        tx=i+pd_duck_x[k+8],ty=j+pd_duck_y[k+8];
                        if (a[tx][ty].qz!=0) continue;
                        //judge if I can move the chess(twice)
                        int dx=i+dx_duck[k],dy=j+dy_duck[k];
                        if (dx>0&&dx<11&&dy>0&&dy<10&&a[dx][dy].qz==5&&a[dx][dy].col!=a[i][j].col) {f=1;break;}
                        //to check if there's checkmate
                    }
                    if (f==1) break;
                }
                if (a[i][j].qz==7) {//soldier
                    for (int k=0;k<8;k++) {
                        int dx=i+dx_soldier[k],dy=j+dy_soldier[k];
                        if (dx>0&&dx<11&&dy>0&&dy<10&&a[dx][dy].qz==5&&a[dx][dy].col!=a[i][j].col) {f=1;break;}
                        //to check if there's checkmate
                    }
                    if (f==1) break;
                }
            }
            if (f==1) break;
        }
        if (f==1) cout<<"yes;";
        else cout<<"no;";//checkmate
        cout<<"no"<<endl;
        if (colo==1) colo=2;
        else colo=1;//change the colour
    }
    return 0;
}

```
注释什么的都在代码里了qwq

这样我们就A了THUPC2019H题了鸭，开心开心

---

## 作者：Phykyer (赞：1)

**完完全全的一道细节考查题**  

首先读题面：题目首先给出了一定的下棋规则（~~和原本中国象棋基本就没有差别，出题人也是有够懒的~~），以及判定一步棋下完后盘面状况的规则，要求输入一局游戏的进程让你对于每步棋判断它下完后的盘面情况。  

读题可以知道这是一道显然的大模拟题，而且是纯模拟，考察的就是对于细节的判断。  

这里给出一些要**特别注意**的点：  
$1.$ 如果当前这一步棋不合法，则下棋方不用改变  
$2.$ 对于马、象和鸭要记得判断是否会被其他棋子堵了棋眼  
$3.$ 对于车移动的判断需要注意从起点到目标点之间不能有其他的棋子  
$4.$ 对于将军的情况需要判断**双方的王**而不是仅当前行动方的王  
$5.$ **游戏只要一结束就不存在将军情况**，所以对于游戏结束的那一步棋的将军情况要直接输出 $no$ 。  

其他的部分就是简单的模拟，只不过码量非常大，很考验耐心和细心。具体的操作见以下代码，应该非常好理解。  

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
using namespace std;

int n, sx, sy, tx, ty;
bool now; // 判断当前轮到哪一方下棋 0为red, 1为blue
bool game_over;//判断游戏是否结束
int a[11][10] = {//初始棋盘
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	0,  8,  6,  4,  2,  1,  3,  5,  7,  9,
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	0, 10,  0,  0,  0,  0,  0,  0,  0, 11,
	0, 12,  0, 13,  0, 14,  0, 15,  0, 16,
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	0, 28,  0, 29,  0, 30,  0, 31,  0, 32,
	0, 26,  0,  0,  0,  0,  0,  0,  0, 27,
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	0, 24, 22, 20, 18, 17, 19, 21, 23, 25
};
// 1~16 red 17~32 blue
// 1 captain, 2~3 guard, 4~5 elephant, 6~7 horse, 8~9 car, 10~11 duck, 12~16 soldier
// 17 captain, 18~19 guard, 20~21 elephant, 22~23 horse, 24~25 car, 26~27 duck, 28~32 soldier

string name[33] = {"", "red captain", "red guard", "red guard", "red elephant", "red elephant", "red horse", 
					"red horse", "red car", "red car", "red duck", "red duck", "red soldier", "red soldier",
					"red soldier", "red soldier", "red soldier",
					"blue captain", "blue guard", "blue guard","blue elephant", "blue elephant", "blue horse",
					"blue horse", "blue car", "blue car", "blue duck", "blue duck", "blue soldier", "blue soldier",
					"blue soldier", "blue soldier", "blue soldier"};

int captain_x[5] = {0, 1, -1, 0, 0}, captain_y[5] = {0, 0, 0, 1, -1};
int guard_x[5] = {0, 1, -1, 1, -1}, guard_y[5] = {0, 1, -1, -1, 1};
int elephant_x[5] = {0, 2, -2, 2, -2}, elephant_y[5] = {0, 2, -2, -2, 2};
int elephant_lim_x[5] = {0, 1, -1, 1, -1}, elephant_lim_y[5] = {0, 1, -1, -1, 1};
int horse_x[9] = {0, 2, 2, 1, -1, -2, -2, -1, 1}, horse_y[9] = {0, 1, -1, -2, -2, -1, 1, 2, 2};
int horse_lim_x[9] = {0, 1, 1, 0, 0, -1, -1, 0, 0}, horse_lim_y[9] = {0, 0, 0, -1, -1, 0, 0, 1, 1};
int duck_x[9] = {0, 3, 3, 2, -2, -3, -3, -2, 2}, duck_y[9] = {0, 2, -2, -3, -3, -2, 2, 3, 3};
int duck_lim1_x[9] = {0, 2, 2, 1, -1, -2, -2, -1, 1}, duck_lim1_y[9] = {0, 1, -1, -2, -2, -1, 1, 2, 2};
int duck_lim2_x[9] = {0, 1, 1, 0, 0, -1, -1, 0, 0}, duck_lim2_y[9] = {0, 0, 0, -1, -1, 0, 0, 1, 1};
int soldier_x[9] = {0, 1, 1, 1, 0, -1, -1, -1, 0}, soldier_y[9] = {0, 1, 0, -1, -1, -1, 0, 1, 1};
//每种棋子可以走的方向 , lim数组中为棋眼位置

inline bool move_captain(int ssx, int ssy, int ttx, int tty) {
	int x, y;
	for (int i = 1; i <= 4; i++) {
		x = ssx + captain_x[i], y = ssy + captain_y[i];
		if (x == ttx && y == tty) break;
	}
	if (x != ttx || y != tty) return 0;//简单的模拟
	return 1;
}

inline bool move_guard(int ssx, int ssy, int ttx, int tty) {
	int x, y;
	for (int i = 1; i <= 4; i++) {
		x = ssx + guard_x[i], y = ssy + guard_y[i];
		if (x == ttx && y == tty) break;
	}
	if (x != ttx || y != tty) return 0;
	return 1;
}

inline bool move_elephant(int ssx, int ssy, int ttx, int tty) {
	int x, y, lx, ly;
	for (int i = 1; i <= 4; i++) {
		lx = ssx + elephant_lim_x[i], ly = ssy + elephant_lim_y[i];
		if (a[lx][ly]) continue;//如果棋眼被堵直接跳过 , 下同 
		x = ssx + elephant_x[i], y = ssy + elephant_y[i];
		if (x == ttx && y == tty) break;
	}
	if (x != ttx || y != tty) return 0;
	return 1;
}

inline bool move_horse(int ssx, int ssy, int ttx, int tty) {
	int x, y, lx, ly;
	for (int i = 1; i <= 8; i++) {
		lx = ssx + horse_lim_x[i], ly = ssy + horse_lim_y[i];
		if (a[lx][ly]) continue;
		x = ssx + horse_x[i], y = ssy + horse_y[i];
		if (x == ttx && y == tty) break;
	}
	if (x != ttx || y != tty) return 0;
	return 1;
}

inline bool move_car(int ssx, int ssy, int ttx, int tty) {
	//车的判断比较特殊需要向四个方向跑且遇到别的棋子就要退出
	int x = ssx, y = ssy;
	bool find = 0;
	while (1) {
		x -= 1; if (x < 1) break;
		if (x == ttx && y == tty) {find = 1; break;}
		else if (a[x][y]) break;
	}
	if (!find) {
		x = ssx; y = ssy;
		while (1) {
			x += 1; if (x > 10) break;
			if (x == ttx && y == tty) {find = 1; break;}
			else if (a[x][y]) break;
		}
	}
	if (!find) {
		x = ssx; y = ssy;
		while (1) {
			y -= 1; if (y < 1) break;
			if (x == ttx && y == tty) {find = 1; break;}
			else if (a[x][y]) break;
		}
	}
	if (!find) {
		x = ssx; y = ssy;
		while (1) {
			y += 1; if (y > 9) break;
			if (x == ttx && y == tty) {find = 1; break;}
			else if (a[x][y]) break;
		}
	}
	if (x != ttx || y != tty) return 0;
	return 1;
}

inline bool move_duck(int ssx, int ssy, int ttx, int tty) {
	int x, y, l1x, l1y, l2x,l2y;
	for (int i = 1; i <= 8; i++) {
		l1x = ssx + duck_lim1_x[i], l1y = ssy + duck_lim1_y[i];
		if (a[l1x][l1y]) continue;
		l2x = ssx + duck_lim2_x[i], l2y = ssy + duck_lim2_y[i];
		if (a[l2x][l2y]) continue;
		x = ssx + duck_x[i], y = ssy + duck_y[i];
		if (x == ttx && y == tty) break;
	}
	if (x != ttx || y != tty) return 0;
	return 1;
}

inline bool move_soldier(int ssx, int ssy, int ttx, int tty) {
	int x, y;
	for (int i = 1; i <= 8; i++) {
		x = ssx + soldier_x[i], y = ssy + soldier_y[i];
		if (x == ttx && y == tty) break;
	}
	if (x != ttx || y != tty) return 0;
	return 1;
}

inline bool jiang_jun() {
	// 将军要判断双方的王是否被将
	// 红方的王
	int px = 0, py = 0;
	for (int i = 1; i <= 10; i++) {
		for (int j = 1; j <= 9; j++) {
			if (a[i][j] == 1) {px = i; py = j; break;}
		}
		if (px) break;
	}
	// 找王的位置
	int ret = 0;
	for (int i = 1; i <= 10; i++) {
		for (int j = 1; j <= 9; j++) {
			if (a[i][j] == 17) ret = move_captain(i, j, px, py);
			else if (a[i][j] >= 18 && a[i][j] <= 19) ret = move_guard(i, j, px, py);
			else if (a[i][j] >= 20 && a[i][j] <= 21) ret = move_elephant(i, j, px, py);
			else if (a[i][j] >= 22 && a[i][j] <= 23) ret = move_horse(i, j, px, py);
			else if (a[i][j] >= 24 && a[i][j] <= 25) ret = move_car(i, j, px, py);
			else if (a[i][j] >= 26 && a[i][j] <= 27) ret = move_duck(i, j, px, py);
			else if (a[i][j] >= 28 && a[i][j] <= 32) ret = move_soldier(i, j, px, py);
			if (ret) return 1;
		}
	}
	// 对于蓝方的每个棋子判断下一步是否能走到王即可
	// 蓝方的王
	px = 0; py = 0;
	for (int i = 1; i <= 10; i++) {
		for (int j = 1; j <= 9; j++) {
			if (a[i][j] == 17) {px = i; py = j; break;}
		}
		if (px) break;
	}
	ret = 0;
	for (int i = 1; i <= 10; i++) {
		for (int j = 1; j <= 9; j++) {
			if (a[i][j] == 1) ret = move_captain(i, j, px, py);
			else if (a[i][j] >= 2 && a[i][j] <= 3) ret = move_guard(i, j, px, py);
			else if (a[i][j] >= 4 && a[i][j] <= 5) ret = move_elephant(i, j, px, py);
			else if (a[i][j] >= 6 && a[i][j] <= 7) ret = move_horse(i, j, px, py);
			else if (a[i][j] >= 8 && a[i][j] <= 9) ret = move_car(i, j, px, py);
			else if (a[i][j] >= 10 && a[i][j] <= 11) ret = move_duck(i, j, px, py);
			else if (a[i][j] >= 12 && a[i][j] <= 16) ret = move_soldier(i, j, px, py);
			if (ret) return 1;
		}
	}
	return 0;
}

inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') {if (ch == '-') f = -1; ch = getchar();}
	while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
	return x * f;
}

int main() {
	n = read();
	while (n--) {
		sx = read() + 1; sy = read() + 1; tx = read() + 1; ty = read() + 1;
		//因为题目棋盘坐标从0开始 , 为方便这里统一 +1 
		if (game_over) { puts("Invalid command"); continue; }//游戏结束直接判断不合法 
		if (!a[sx][sy]) { puts("Invalid command"); continue; }//移动点无棋子判断不合法
		if (sx < 1 || sx > 10 || sy < 1 || sy > 9) { puts("Invalid command"); continue; }
		if (tx < 1 || tx > 10 || ty < 1 || ty > 9) { puts("Invalid command"); continue; }
		//移动点和要移到的点在棋盘外不合法
		int ret = 0;
		if (!now) {
		//	红方回合
			if (a[sx][sy] > 16) { puts("Invalid command"); continue; }
			// 移动的是蓝方的棋不合法
			if (a[tx][ty] < 17 && a[tx][ty] > 0) { puts("Invalid command"); continue; }
			// 移到自己方的棋上不合法
			if (a[sx][sy] == 1) ret = move_captain(sx, sy, tx, ty);
			else if (a[sx][sy] >= 2 && a[sx][sy] <= 3) ret = move_guard(sx, sy, tx, ty);
			else if (a[sx][sy] >= 4 && a[sx][sy] <= 5) ret = move_elephant(sx, sy, tx, ty);
			else if (a[sx][sy] >= 6 && a[sx][sy] <= 7) ret = move_horse(sx, sy, tx, ty);
			else if (a[sx][sy] >= 8 && a[sx][sy] <= 9) ret = move_car(sx, sy, tx, ty);
			else if (a[sx][sy] >= 10 && a[sx][sy] <= 11) ret = move_duck(sx, sy, tx, ty);
			else if (a[sx][sy] >= 12 && a[sx][sy] <= 16) ret = move_soldier(sx, sy, tx, ty);
			if (!ret) { puts("Invalid command"); continue; }
			cout << name[a[sx][sy]] << ";";
			if (a[tx][ty]) {
				cout << name[a[tx][ty]] << ";";
				if (a[tx][ty] == 1 || a[tx][ty] == 17) game_over = 1;
				//如果王死了那么判断游戏结束
			}
			else cout << "NA;";
			a[tx][ty] = a[sx][sy]; a[sx][sy] = 0;
			//将棋子移动
			if (game_over) cout << "no;";//这里注意如果游戏结束将军状况为no
			else if (jiang_jun()) cout << "yes;";
			else cout <<"no;";
			if (game_over) cout << "yes" << endl;
			else cout << "no" << endl;
			now = 1;//换方执棋
		}
		else {
		//	蓝方回合 , 操作同上
			if (a[sx][sy] < 17 && a[sx][sy] > 0) { puts("Invalid command"); continue; }
			if (a[tx][ty] > 16) { puts("Invalid command"); continue; }
			if (a[sx][sy] == 17) ret = move_captain(sx, sy, tx, ty);
			else if (a[sx][sy] >= 18 && a[sx][sy] <= 19) ret = move_guard(sx, sy, tx, ty);
			else if (a[sx][sy] >= 20 && a[sx][sy] <= 21) ret = move_elephant(sx, sy, tx, ty);
			else if (a[sx][sy] >= 22 && a[sx][sy] <= 23) ret = move_horse(sx, sy, tx, ty);
			else if (a[sx][sy] >= 24 && a[sx][sy] <= 25) ret = move_car(sx, sy, tx, ty);
			else if (a[sx][sy] >= 26 && a[sx][sy] <= 27) ret = move_duck(sx, sy, tx, ty);
			else if (a[sx][sy] >= 28 && a[sx][sy] <= 32) ret = move_soldier(sx, sy, tx, ty);
			if (!ret) { puts("Invalid command"); continue; }
			cout << name[a[sx][sy]] << ";";
			if (a[tx][ty]) {
				cout << name[a[tx][ty]] << ";";
				if (a[tx][ty] == 1 || a[tx][ty] == 17) game_over = 1;
			}
			else cout << "NA;";
			a[tx][ty] = a[sx][sy]; a[sx][sy] = 0;
			if (game_over) cout << "no;";
			else if (jiang_jun()) cout << "yes;";
			else cout <<"no;";
			if (game_over) cout << "yes" << endl;
			else cout << "no" << endl;
			now = 0;
		}
	}
	return 0;
}
```  
觉得码风奇怪的还请见谅


---


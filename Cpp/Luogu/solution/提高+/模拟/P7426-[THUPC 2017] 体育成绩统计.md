# [THUPC 2017] 体育成绩统计

## 题目背景

正所谓「无体育，不清华」。为了更好地督促同学们进行体育锻炼，更加科学地对同学们进行评价，五道口体校的老师们在体育成绩的考核上可谓是煞费苦心。然而每到学期期末时，面对海量的原始数据，如何对数据进行处理，得到同学们的体育总评成绩却又成了体育部老师的一大难题。

## 题目描述

对于大一的同学们来说，体育课的总评成绩由五部分组成：体育课专项成绩（满分 $50$ 分）、长跑测试成绩（满分 $20$ 分）、「阳光长跑」成绩（满分 $10$ 分）、体质测试成绩（满分 $10$ 分）、「大一专项计划」成绩（满分 $10$ 分）。

体育课专项成绩将由任课体育老师直接给出。

长跑测试成绩将由期末长跑测试确定，其中男生需进行 $3000$ 米测试，女生需进行 $1500$ 米测试，具体评分标准为：
|  | $20$ | $18$ | $16$ | $14$ | $12$ | $10$ | $8$ | $6$ | $4$ | $2$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 男生 | $12'30''$ | $13'00''$ | $13'30''$ | $14'00''$ | $14'30''$ | $15'10''$ | $15'50''$ | $16'30''$ | $17'10''$ | $18'00''$ |
| 女生 | $6'40''$ | $6'57''$ | $7'14''$ | $7'31''$ | $7'50''$ | $8'05''$ | $8'20''$ | $8'35''$ | $8'50''$ | $9'00''$ |

「阳光长跑」是通过手机 App 来记录同学们的课外长跑情况，根据对原始跑步数据进行筛选，得到课外长跑的合法次数，来最终确定此部分的成绩。

一条合法的锻炼记录需同时满足：

男生长跑距离 $3000$ 米以上（包含 $3000$ 米），女生长跑距离 $1500$ 米以上（包含 $1500$ 米）；

平均速度（运动距离/(结束时间-开始时间)）不慢于 $2$ 米／秒，且不快于 $5$ 米／秒；

总暂停时间不得超过 $4$ 分 $30$ 秒；

平均步幅（距离／步数）不超过 $1.5$ 米；

开始时间需与上条合法记录的结束时间间隔 $6$ 小时以上（包含 $6$ 小时）；

「阳光长跑」的合法次数与该部分得分的对应如下：
| 分数 | $10$ | $9$ | $8$ | $7$ | $6$ | $4$ | $2$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 次数 | $[21,+∞)$ | $[19,20]$ | $[17,18]$ | $[14,16]$ | $[11,13]$ | $[7,10]$ | $[3,6]$ |

对于体质测试部分，若达到合格标准则得到该部分满分 $10$ 分，否则该部分不得分。

「大一专项计划」的 $10$ 分由两部分组成：出勤次数占 $5$ 分，期末检测占 $5$ 分。

其中出勤次数为「班级训练营」的参加次数和「阳光长跑」的合法次数之和，出勤得分与出勤次数的对应如下：
| 分数 | $5$ | $4$ | $3$ | $2$ | $1$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 次数 | $[18,+∞)$ | $[15,17]$ | $[12,14]$ | $[9,11]$ | $[6,8]$ |

不难看出，要想准确无误地计算出每个人的体育成绩并不是一件轻松的事，于是体育部的老师找到了正在打校赛的你，他将提供所有需要用到的数据，希望你帮他算算清华大一同学的体育总评成绩及等级。

百分制成绩与等级、绩点对应如下：
| A | A- | B+ | B | B- | C+ | C | C- |D+  | D | F |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $[95,100]$ | $[90,95)$ | $[85,90)$ | $[80,85)$ | $[77,80)$ | $[73,77)$ | $[70,73)$ | $[67,70)$ | $[63,67)$ | $[60,63)$ | $[0,60)$ |


## 说明/提示

对于 $100\%$ 的数据，$n\le 10^4,0\le a,b\le 59,0\le c\le 100,m\le 1.5\times 10^5,0\le l\le 100,0\le s\le 10^6$。
#### 版权信息
来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2017。

## 样例 #1

### 输入

```
1
2015011233 M 34 14'30" P 3 3
8
20170508 2015011233 17:02:33 17:19:33 2.99 0'0" 3333
20170509 2015011233 17:12:15 17:38:46 3.01 2'3" 4300
20170510 2015011233 22:03:06 22:13:08 3.05 0'0" 2772
20170511 2015011233 22:08:05 22:28:13 3.02 5'3" 3775
20170512 2015011233 18:03:12 18:17:56 3.02 0'0" 2001
20170513 2015011233 17:30:23 17:46:08 3.01 0'0" 3020
20170513 2015011233 22:03:34 22:20:08 3.04 2'0" 3058
20170514 2015011233 07:16:22 07:32:34 3.00 0'0" 3244```

### 输出

```
2015011233 59 F```

# 题解

## 作者：Eason_AC (赞：40)

## Update
- $\texttt{2021.3.11}$ 修复了一个笔误。

## Content
太长了，请直接跳转回[题面](https://www.luogu.com.cn/problem/P7426)查看。

**数据范围：$n\leqslant 10^4$，$0\leqslant a,b\leqslant 59$，$0\leqslant c\leqslant 100$，$m\leqslant 10^5$，$0\leqslant l\leqslant 100$，$0\leqslant s\leqslant 10^6$。**

变量含义同原题面。
## Solution
很烦人的一道大模拟。

既然题目说成绩分五部分，那我们的程序也分五部分进行：
### Part 1 体育课专项成绩
这个直接输入完就往总分数里面加，不需要多讲。
### Part 2 长跑成绩
读入的时候运用了一个小 trick：我们知道 `scanf` 是可以按照格式读入的，所以直接用 `"%d'%d\""` 的格式读入即可【**注意！在字符串里面想要打入 `"` 需要在其前面加一个反斜杠（`\`）**】。

然后，直接拿分钟数和秒数去对比显然有点麻烦，我们不妨直接将其转化为秒数。我们都知道 $1$ 分钟有 $60$ 秒，所以将读入的时间直接转化成秒数就是 $a\times 60+b$。再去比对题目中的表格。把题目中的表格中的时间转化成秒数，得到一个新的表格（建议去题解界面查看）：

| 长跑得分 | $20$ | $18$ | $16$ | $14$ | $12$ | $10$ | $8$ | $6$ | $4$ | $2$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 男生/秒 | $750$ | $780$ | $810$ | $840$ | $870$ | $910$ | $950$ | $990$ | $1030$ | $1080$ |
| 女生/秒 | $400$ | $417$ | $434$ | $451$ | $470$ | $485$ | $500$ |  $515$ | $530$ | $540$ |

然后直接一波 if-else 搞定。
### Part 3 阳光长跑
本题的**重头戏**，因为要考虑的情况实在是太多了。

首先要将对应的长跑数据转入到对应的人中。这里如果直接开数组的话，显然，$10^4\times 1.5\times 10^5=1.5\times 10^ 9$ 显然空间爆炸，所以考虑开个 `vector`，读入的时候将所有的数据储存到一个结构体变量当中，再直接转入到对应的人中去。

这里又有一个 trick：我们通过 STL 中的 `map`，将所有的人的学号映射到其在输入数据中的编号，这样处理起来就很简单，不需要再去暴力循环找了。

所有的长跑原始数据都转移到对应的人上面去后，我们注意到，在每个人底下的长跑原始数据并不一定是有序的，然而题目当中 **开始时间需与上条合法记录的结束时间间隔 $6$ 小时以上（包含 $6$ 小时）** 这个条件要求我们一定要对这些数据进行一定程度的排序。

既然这样那就对这些数据排序吧，这里你可以直接在结构体下面定义重载运算符，也可以直接弄一个 `compare` 函数，都能够起到自定义排序的作用。

这道题目对于阳光长跑的合法条件实在是多，但我们只能够一个一个去对了，建议按照以下次序：

- 如果男生跑步路程 $<3000$ 米，女生跑步路程 $<1500$ 米，那么这条记录就不合法。
- 否则，如果跑步速度 $<2\operatorname{m/s}$，或者 $>5\operatorname{m/s}$，或者平均步幅 $>1.5\operatorname{m/s}$，或者总休息时间 $>270$ 秒（同样也是用的处理长跑成绩时的 trick），那么这条记录不合法。
- 否则，如果目前记录是这位同学的第 $1$ 条长跑记录，那么这条记录就已经是合法的了，计入计数器。
- 如果这条记录不是第 $1$ 条记录，那么继续往下判断。提取出上条记录的结束时间的年、月、日、时、分、秒和目前记录的开始时间的年、月、日、时、分、秒。
- 如果月份不一样，那么判断是否超过了 $1$ 个月。超过了一个月的话这条记录就是合法的。
- 否则这两条记录就是相邻月份的，然后我们再看上次合法记录的结束时间是不是在上一个月的最后一天，且该条记录的开始时间是不是在本月的第一天。如果不是，那么这条记录就是合法的。
- 否则，这两天其实只相隔一天，我们再看看它们的间隔时间是否大于 $6$ 小时，也就是 $21600$ 秒即可。月份不一样的就算处理完了。
- 接下来，如果这两个日期不在同一天，我们再看相隔天数，如果超过 $1$ 天，那么这个记录就是合法的。
- 否则，那么这两个日期相隔天数正好一天，我们只需要看这两个记录的间隔时间是否大于 $6$ 小时即可。天份不一样的情况也处理完了。
- 最后，这两个日期正好是在同一天，直接拿两个时间相减看时间是否大于 $6$ 小时即可。

合法记录的数量就这样搞定了。那么从这里开始就很简单了！首先，这一部分的分数只需要一波 if-else 就能够搞定。
### Part 4 体质测试成绩
只需要看给出的字符是否是 `P`，是的话分数 $+10$，否则不变。
### Part 5 大一专项计划
这里又分为两部分。
#### Part 5.1 出勤
由题目可知，次数就等于班级训练营的参加次数和在 Part 3 里面处理完的阳光长跑合法记录次数的和。得到出勤次数之后又是一波 if-else 搞定分数。
#### Part 5.2 期末检测
这个直接输入完就往总分数里面加，不需要多讲。

最后的输出等第也是直接一波 if-else 搞定。

那么这道题目也就算做完了。最后友情提示，做这道题目的时候一定要沉下心来一步一步去做！不然稍有个一不留神 $100$ 分就**全没有了**。

下面给出具体代码实现，配有详细注释，仅供参考，请勿抄袭。
## Code
```cpp
struct sunnyrun {
	int y, m, d, hs, ms, ss, ht, mt, st, rest, step;
	double l;
	bool operator < (const sunnyrun& tmp) const {
		//按照记录开始时间排序
		if(y != tmp.y) return y < tmp.y;
		else if(m != tmp.m) return m < tmp.m;
		else if(d != tmp.d) return d < tmp.d;
		else if(hs != tmp.hs) return hs < tmp.hs;
		else if(ms != tmp.ms) return ms < tmp.ms;
		return ss < tmp.ss;
	}
};
struct student {
	int mf, s, a, b, pf, f, c, score, num2, num;
	ll p;
	vector<sunnyrun> q;
	/*
		mf：1 表示男生，0 表示女生
		pf：1 表示通过，0 表示没有通过	
	*/
}a[10007];
const int mm[17] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
double l;
map<ll, int> vis;

inline int calcms(int a, int b) {return a * 60 + b;}
// 分秒形式的时间转换成秒
inline int calchms(int a, int b, int c) {return a * 3600 + b * 60 + c;}
// 时分秒形式的时间转换成秒
inline int s1(int x) {return a[x].s;} //直接计入分数
inline int s2(int x) {
	if(a[x].mf) {
		if(calcms(a[x].a, a[x].b) <= 750) return 20;
		else if(calcms(a[x].a, a[x].b) > 750 && calcms(a[x].a, a[x].b) <= 780) return 18;
		else if(calcms(a[x].a, a[x].b) > 780 && calcms(a[x].a, a[x].b) <= 810) return 16;
		else if(calcms(a[x].a, a[x].b) > 810 && calcms(a[x].a, a[x].b) <= 840) return 14;
		else if(calcms(a[x].a, a[x].b) > 840 && calcms(a[x].a, a[x].b) <= 870) return 12;
		else if(calcms(a[x].a, a[x].b) > 870 && calcms(a[x].a, a[x].b) <= 910) return 10;
		else if(calcms(a[x].a, a[x].b) > 910 && calcms(a[x].a, a[x].b) <= 950) return 8;
		else if(calcms(a[x].a, a[x].b) > 950 && calcms(a[x].a, a[x].b) <= 990) return 6;
		else if(calcms(a[x].a, a[x].b) > 990 && calcms(a[x].a, a[x].b) <= 1030) return 4;
		else if(calcms(a[x].a, a[x].b) > 1030 && calcms(a[x].a, a[x].b) <= 1080) return 2;
		else return 0; // 如果上面的都不符合一定要记得 return 0！不然可能会 RE
	} else {
		if(calcms(a[x].a, a[x].b) <= 400) return 20;
		else if(calcms(a[x].a, a[x].b) > 400 && calcms(a[x].a, a[x].b) <= 417) return 18;
		else if(calcms(a[x].a, a[x].b) > 417 && calcms(a[x].a, a[x].b) <= 434) return 16;
		else if(calcms(a[x].a, a[x].b) > 434 && calcms(a[x].a, a[x].b) <= 451) return 14;
		else if(calcms(a[x].a, a[x].b) > 451 && calcms(a[x].a, a[x].b) <= 470) return 12;
		else if(calcms(a[x].a, a[x].b) > 470 && calcms(a[x].a, a[x].b) <= 485) return 10;
		else if(calcms(a[x].a, a[x].b) > 485 && calcms(a[x].a, a[x].b) <= 500) return 8;
		else if(calcms(a[x].a, a[x].b) > 500 && calcms(a[x].a, a[x].b) <= 515) return 6;
		else if(calcms(a[x].a, a[x].b) > 515 && calcms(a[x].a, a[x].b) <= 530) return 4;
		else if(calcms(a[x].a, a[x].b) > 530 && calcms(a[x].a, a[x].b) <= 540) return 2;
		else return 0; // 同上
	}
}
inline int s3(int x) {
	int cnt = 0, flg1 = 0; sunnyrun lst;
	sort(a[x].q.begin(), a[x].q.end()); //按照记录开始时间排序
	int sze = a[x].q.size();
	F(i, 0, sze - 1) {
		sunnyrun now = a[x].q[i];
		if(now.l < (a[x].mf ? 3.0 : 1.5)) continue; //路程不达标，不合法
		int ts = calchms(now.hs, now.ms, now.ss), tt = calchms(now.ht, now.mt, now.st);
		double v = now.l * 1000.0 / (tt - ts), pe = now.l * 1000.0 / now.step;
		if(v < 2 || v > 5 || pe > 1.5 || now.rest > 270) continue; //速度、步幅、总休息时间中任意一个不达标，不合法
		if(!flg1) {flg1 = 1, lst = a[x].q[i], cnt++; continue;} //以上条件都达标且是第一个记录，合法
		ts = calchms(lst.ht, lst.mt, lst.st), tt = calchms(now.hs, now.ms, now.ss); //开始时间和结束时间
		if(now.m != lst.m) { //不是一个月
			if(now.m - 1 != lst.m) {lst = now, cnt++; continue;} //间隔超过一个月，合法
			else {
				if(mm[lst.m] != lst.d || now.d != 1) {lst = now, cnt++; continue;} //上条合法记录的结束时间是上个月的最后一天、该条记录的开始时间是这个月的第一天当中有一条不符合，合法
				else if(86400 + tt - ts < 21600) continue; //间隔只有一天，并且间隔时间小于 6 小时，不合法
			}
		} else if(now.d != lst.d) { //不是同一天
			if(now.d - 1 != lst.d) {lst = now, cnt++; continue;} //间隔天数超过 1 天，合法
			else if(86400 + tt - ts < 21600) continue; //间隔只有一天，并且间隔时间小于 6 小时，不合法
		} else if(tt - ts < 21600) continue; //间隔时间小于 6 小时，不合法
		lst = now, cnt++; //合法
	}
	a[x].num2 = cnt; //计入次数
	if(a[x].num2 >= 21) return 10;
	else if(a[x].num2 >= 19 && a[x].num2 <= 20) return 9;
	else if(a[x].num2 >= 17 && a[x].num2 <= 18) return 8;
	else if(a[x].num2 >= 14 && a[x].num2 <= 16) return 7;
	else if(a[x].num2 >= 11 && a[x].num2 <= 13) return 6;
	else if(a[x].num2 >= 7 && a[x].num2 <= 10) return 4;
	else if(a[x].num2 >= 3 && a[x].num2 <= 6) return 2;
	else return 0;
}
inline int s4(int x) {return a[x].pf ? 10 : 0;} //直接计入分数
inline int s5(int x) {
	a[x].num = a[x].c + a[x].num2;
	if(a[x].num >= 18) return 5 + a[x].f; //出勤次数和期末检测成绩综合判断
	else if(a[x].num >= 15 && a[x].num <= 17) return 4 + a[x].f;
	else if(a[x].num >= 12 && a[x].num <= 14) return 3 + a[x].f;
	else if(a[x].num >= 9 && a[x].num <= 11) return 2 + a[x].f;
	else if(a[x].num >= 6 && a[x].num <= 8) return 1 + a[x].f;
	else return a[x].f;
}

int main() {
	int n = Rint;
	F(i, 1, n) {
		a[i].p = Rll; char ch[2]; scanf("%s", ch);
		a[i].mf = (ch[0] == 'M'); //性别是否是男
		a[i].s = Rint;
		scanf("%d'%d\"", &a[i].a, &a[i].b); //强制按照 a'b" 的格式读入 a,b
		scanf("%s", ch); a[i].pf = (ch[0] == 'P');
		a[i].f = Rint, a[i].c = Rint; vis[a[i].p] = i; //建立映射关系
	}
	int m = Rint;
	F(i, 1, m) {
        sunnyrun ins; //待插入元素
		int date = Rint; ins.y = date / 10000, ins.m = date % 10000 / 100, ins.d = date % 100;
		ll px = Rll; int id = vis[px]; //映射出该学生在输入数据中的编号
		scanf("%d:%d:%d %d:%d:%d", &ins.hs, &ins.ms, &ins.ss, &ins.ht, &ins.mt, &ins.st); //强制按照 hh:mm:ss hh:mm:ss 的格式读入该条记录的开始时间和结束时间的时分秒
		scanf("%lf", &ins.l); //路程
		int ax, bx; scanf("%d'%d\"", &ax, &bx); ins.rest = calcms(ax, bx), ins.step = Rint; //强制按照 a'b" 的格式读入 a,b
		a[id].q.push_back(ins); //插入对应结构体元素下的 vector 中
	}
	F(i, 1, n) {
		a[i].score = s1(i) + s2(i) + s3(i) + s4(i) + s5(i); //五个部分的分数合计
		printf("%lld %d ", a[i].p, a[i].score);
		if(a[i].score >= 95 && a[i].score <= 100) puts("A"); //判断等第
		else if(a[i].score >= 90 && a[i].score < 95) puts("A-");
		else if(a[i].score >= 85 && a[i].score < 90) puts("B+");
		else if(a[i].score >= 80 && a[i].score < 85) puts("B");
		else if(a[i].score >= 77 && a[i].score < 80) puts("B-");
		else if(a[i].score >= 73 && a[i].score < 77) puts("C+");
		else if(a[i].score >= 70 && a[i].score < 73) puts("C");
		else if(a[i].score >= 67 && a[i].score < 70) puts("C-");
		else if(a[i].score >= 63 && a[i].score < 67) puts("D+");
		else if(a[i].score >= 60 && a[i].score < 63) puts("D");
		else puts("F");
	}
	return 0;
}
```

---

## 作者：囧仙 (赞：19)

这是一篇当前 $(\verb!2021.3.30!)$ 最短题解。

尽管这题是一道非常无脑的模拟题，但我仍希望你能获得一些关于模拟的技巧。

## 题解

因为这题比较长，所以这里先讲几个下文会用到的函数。

- $\verb!trans(m,s)!$ ，用于将 $m$ 分 $s$ 秒转换为秒。即 $trans(m,s)=60\times m+s$ 。这个函数主要用于将二元组 $(m,s)$ 转换为单个数。

- $\verb!date(m,d)!$ ，用于将 $m$ 月 $d$ 日转换为日。实现起来比 $\verb!trans!$ 稍微麻烦一些，你需要记录 $2017$ 年每月的日期数 $D_i$ ，然后返回 $d+\sum_{i<m} D_i$ 。这个函数主要用于定位绝对日期。

- $\verb!find(w,*P,*Q)!$ ，找到第一个 $P_x$ 满足 $P_x\le w$ ，然后返回 $Q_x$ 。这个函数主要用于查表。

有了这三个函数，我们处理这题就非常简单了。

我们用一个结构体 $P_i=\{name,sex,score,count_1,count_2,date\}$ 描述每个学神。里面存储每个人的标号、性别、总分、阳光长跑次数、班级训练营参加次数、上一次合法阳光长跑的绝对日期。其他项目可以在输入的时候就进行处理，于是就不存放在结构体里了。

- **体育课专项成绩**直接输入。这是最容易处理的一项。

- **长跑测试成绩**虽然麻烦一些,但也是比较容易处理的。我们输入每个人的长跑成绩 $(a,b)$ 后，直接使用 $trans(a,b)$ 计算出所用秒,然后根据性别查表就行了。查表使用函数 $find$ 。

- **阳光长跑**比较难处理。当我们读入每条阳光长跑记录时，先找到学号所对应的那个学生。对于每条记录，我们需要一一比对题目给出的条件（长跑的长度、速度、步长、开始时间距离上一次合法记录结束时间的时间差、休息时间），进而决定这条记录是否合法。这里建议将所有出现过的时间利用 $trans$ 和 $date$ 函数转换为以秒为单位的绝对时间，这样可以节省很多的工作量。如果合法，就计入到该名学生的 $count_1$ 当中。等统计完 $m$ 条记录，我们就根据每名学生合法阳光长跑的个数，通过查表获取对应分数。查表使用 $find$ 函数。

- **大一专项计划**相对阳光长跑就非常简单了。期末考核分数直接加到 $score$ 上，出勤分数根据 $count_1$ 和 $count_2$ 的总和进行查表。查表仍然使用 $find$ 函数。

最后我们可以计算出每名学生的最终得分。我们继续查表，然后分配对应的等第。按照学号直接排序后输出。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(register int i=l,END##i=r;i<=END##i;++i)
using namespace std;
typedef long long i64;
const int MAXN =1e4+3,INF=1<<30;
struct Node{
	char sx; i64 nm; int sc,c,t,d; bool operator <(Node t){return nm<t.nm;}
}P[MAXN]; 
#define trs(x,y) (x*60+y)
const int A[]={trs(12,30),trs(13, 0),trs(13,30),trs(14, 0),trs(14,30),trs(15,10),trs(15,50),trs(16,30),trs(17,10),trs(18,0),INF};
const int B[]={trs( 6,40),trs( 6,57),trs( 7,14),trs( 7,31),trs( 7,50),trs( 8,5 ),trs( 8,20),trs( 8,35),trs( 8,50),trs( 9,0),INF};
const int C[]={20,18,16,14,12,10,8,6,4,2,0};
const int D[]={2,6,10,13,16,18,20,INF},E[]={0,2,4,6,7,8,9,10};
const int F[]={      5,8,11,14,17,INF},G[]={  0,1,2,3,4,5   };
const int H[]={59,62,66,69,72,76,79,84,89,94,100},I[]={0,1,2,3,4,5,6,7,8,9,10};
const int J[]={31,28,31,30,31,30,31,31,30,31,30,31};
const char W[][3]={"F","D","D+","C-","C","C+","B-","B","B+","A-","A"};
int dat(int m,int d){int s=0; up(1,m-1,i) s+=J[i-1]; return s+d;}
int fnd(int w,const int *P,const int *Q){
	up(0,INF,i) if(w<=P[i]) return Q[i]; return 0;
}
int f,a,b,d,n,m,a1,a2,a3,dd=-INF/2,b1,b2,b3,c1,c2,d1,d2,d3,s; i64 x; float l; char ps; map<i64,int> M;
int main(){
	scanf("%d",&n); up(1,n,i){
		scanf("%lld%*c%c%d%d%*c%d%*c%*c%c%d%d",&P[i].nm,&P[i].sx,&P[i].sc,&a,&b,&ps,&f,&P[i].c);
		P[i].sc+=(ps=='P'?10:0)+f+fnd(trs(a,b),P[i].sx=='M'?A:B,C),M[P[i].nm]=i,P[i].d=-INF/2;
	}
	scanf("%d",&m); up(1,m,i){
		scanf("%d%lld%d%*c%d%*c%d%d%*c%d%*c%d%f%d%*c%d%*c%d",&d,&x,&a1,&a2,&a3,&b1,&b2,&b3,&l,&c1,&c2,&s);
		d1=dat(d%10000/100,d%100)*86400,d2=a1*3600+trs(a2,a3),d3=b1*3600+trs(b2,b3),x=M[x];
		if(d1+d2-P[x].d>=6*3600&&l+1e-9>=(P[x].sx=='M'?3:1.5)&&trs(c1,c2)<=trs(4,30)&&
		   l*1e3/s-1e-9<=1.5&&2.0-1e-9<=l*1e3/(d3-d2)&&l*1e3/(d3-d2)<=5.0+1e-9)
		P[x].d=d1+d3,++P[x].t;
	}
	up(1,n,i) P[i].sc+=fnd(P[i].t,D,E)+fnd(P[i].t+P[i].c,F,G);
	sort(P+1,P+1+n); up(1,n,i){
		printf("%lld %d %s\n",P[i].nm,P[i].sc,W[fnd(P[i].sc,H,I)]);
	}
	return 0;
}
```

---

## 作者：critnos (赞：15)

这个题目相当简单。

事实上除了长跑测试成绩，阳光长跑和大一专项计划的出勤次数，其他的输入都已经给出或者通过非常简单的判断就能搞定。

为了让单位统一，我把所有的时间都转为秒，所有的距离都转为米。

然后根本不用 if-else 来进行繁琐的判断好吧。。直接用数组存下 $\{\text{获得这个分数的下限},\text{获得的分数}\}$，扫一遍就可以了（甚至不用判断边界，丢个 $\{\inf,0\}$ 就行）。

接下来的事情就非常清新自然——输入学生的时候求出所有除了阳光长跑和大一专项计划的出勤次数的东西。

至于阳光长跑，按题意模拟（什么 $6$ 小时之类的因为已经把时间都转化为秒了所以就很容易判断了）。

我调的时候遇到的坑（都是阳光长跑里面的）：

* 忘记把天转换为的秒数加到时间上

* `pre` 数组，即上一次合法的阳光长跑的合法时间，初始化时不要设成一个很大的负数，否则会爆 int

代码为了增加一些可读性，没有特意压行，反而增加了一些行数，但仍是截止现在（2021.3.13 15:44）洛谷上通过的人中代码最短的。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct student
{
	string p;
	char sex;
	int s;
	int c;
	friend bool operator <(student x,student y)
	{
		return x.p<y.p;
	}
}a[10005];
unordered_map<string,int> cl;
int pre[10005];
int he[10005];
const int nvs[]={20,18,16,14,12,10,8,6,4,2,0};
const int na[]={12*60+30,13*60,13*60+30,14*60,14*60+30,15*60+10,15*60+50,16*60+30,17*60+10,18*60,1000000000};
const int nv[]={6*60+40,6*60+57,7*60+14,7*60+31,7*60+50,8*60+5,8*60+20,8*60+35,8*60+50,9*60,1000000000};
const int mon[]={0,31,28,31,30,31,30,31,31,30,31,30,31};
const int ygc[]={21,19,17,14,11,7,3,0};
const int ygs[]={10,9,8,7,6,4,2,0};
const int dyc[]={18,15,12,9,6,0};
const int dys[]={5,4,3,2,1,0};
const int dj[]={95,90,85,80,77,73,70,67,63,60,0};
const string djf[]={"A","A-","B+","B","B-","C+","C","C-","D+","D","F"};
int gettime()
{
	int a,b;
	char del;
	cin>>a>>del>>b>>del;
	return a*60+b;
}
int getday()
{
	string a;
	cin>>a;
	int m=(a[4]-'0')*10+a[5]-'0',d=(a[6]-'0')*10+a[7]-'0',i;
	for(i=1;i<m;i++)
		d+=mon[i];
	return d;
}
int getjd()
{
	int a,b,c;
	char del;
	cin>>a>>del>>b>>del>>c;
	return a*60*60+b*60+c;
}
void print(int x)
{
	int i;
	for(i=0;x<dj[i];i++);
	cout<<djf[i]<<endl;
}
int main()
{
	int n,m,i,j,s,f,ti,h,zan,st,ed;
	string p;
	double l;
	char op;
	cin>>n;
	for(i=1;i<=n;i++)
	{
		pre[i]=-1e8;
		cin>>a[i].p>>a[i].sex>>a[i].s;
		ti=gettime();
		cin>>op>>f>>a[i].c;
		a[i].sex=a[i].sex=='M';
		if(op=='P') a[i].s+=10;
		a[i].s+=f;
		cl[a[i].p]=i;
		if(a[i].sex)
			for(j=0;ti>na[j];j++);
		else
			for(j=0;ti>nv[j];j++);
		a[i].s+=nvs[j];
	}
	cin>>m;
	while(m--)
	{
		ti=getday()*24*60*60;
		cin>>p;
		st=getjd(),ed=getjd();
		cin>>l;
		l*=1000;
		h=cl[p];
		zan=gettime();
		cin>>s;	
		if(!h) continue;
		if(a[h].sex&&l<3000||!a[h].sex&&l<1500) continue;
		if(l<2*(ed-st)||l>5*(ed-st)) continue;
		if(zan>4*60+30) continue;
		if(l>1.5*s) continue;
		if(st+ti-pre[h]<6*60*60) continue;
		pre[h]=ed+ti;
		he[h]++;
	}
	for(i=1;i<=n;i++)
	{
		a[i].c+=he[i];
		for(j=0;he[i]<ygc[j];j++);
		a[i].s+=ygs[j];
		for(j=0;a[i].c<dyc[j];j++);
		a[i].s+=dys[j];
	}
	sort(a+1,a+1+n);
	for(i=1;i<=n;i++)
		cout<<a[i].p<<' '<<a[i].s<<' ',print(a[i].s);
}
```

---

## 作者：Leianha (赞：7)

[题目链接](https://www.luogu.com.cn/problem/P7426)

写这道题最重要的是条理清晰。

除了阳光长跑外，其他的都能在读入的时候处理掉。

处理阳光长跑最头疼的就是处理时间。

把时间单位都变成秒就好啦。

我们算出从 $2017$ 年 $1$ 月 $1$ 日 $0$ 点到这时刻有多少秒就行啦。

代码注释很详细，具体看代码吧。

```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<map>
#define LD long double
using namespace std;
int n,m;
const int N=4010;
map<int,int>mp;
int read()
{
    int res=0;char ch=getchar();bool XX=false;
    for(;!isdigit(ch);ch=getchar())(ch=='-') && (XX=true);
    for(;isdigit(ch);ch=getchar())res=(res<<3)+(res<<1)+(ch^48);
    return XX?-res:res;
}
/*---------以下是得分--------------*/
void dengji(int x)//等级 
{
	if(95<=x&&x<=100)printf("A");
	if(90<=x&&x<=94)printf("A-");
	if(85<=x&&x<=89)printf("B+");
	if(80<=x&&x<=84)printf("B");
	if(77<=x&&x<=79)printf("B-");
	if(73<=x&&x<=76)printf("C+");
	if(70<=x&&x<=72)printf("C");
	if(67<=x&&x<=69)printf("C-");
	if(63<=x&&x<=66)printf("D+");
	if(60<=x&&x<=62)printf("D");
	if(0<=x&&x<=59)printf("F");
}
int yangguang(int x)//阳光得分 
{
	if(21<=x)return 10;
	if(19<=x&&x<=20)return 9;
	if(17<=x&&x<=18)return 8;
	if(14<=x&&x<=16)return 7;
	if(11<=x&&x<=13)return 6;
	if(7<=x&&x<=10)return 4;
	if(3<=x&&x<=6)return 2;
	return 0;
}
int chuqin(int x)//出勤 
{
	if(18<=x)return 5;
	if(15<=x&&x<=17)return 4;
	if(12<=x&&x<=14)return 3;
	if(9<=x&&x<=11)return 2;
	if(6<=x&&x<=8)return 1;
	return 0;
}
int ti(int a,int b){return a*60+b;}//分钟转化为秒 
int changpao(char x,int t)//长跑  
{
	int res=0;
	if(x=='M')
	{
		if(t<=ti(18,0) )res=2;
		if(t<=ti(17,10))res=4;
		if(t<=ti(16,30))res=6;
		if(t<=ti(15,50))res=8;
		if(t<=ti(15,10))res=10;
		if(t<=ti(14,30))res=12;
		if(t<=ti(14,0) )res=14;
		if(t<=ti(13,30))res=16;
		if(t<=ti(13,0) )res=18;
		if(t<=ti(12,30))res=20;
	}
	else 
	{
		if(t<=ti(9,0) )res=2;
		if(t<=ti(8,50))res=4;
		if(t<=ti(8,35))res=6;
		if(t<=ti(8,20))res=8;
		if(t<=ti(8,5) )res=10;
		if(t<=ti(7,50))res=12;
		if(t<=ti(7,31))res=14;
		if(t<=ti(7,14))res=16;
		if(t<=ti(6,57))res=18;
		if(t<=ti(6,40))res=20;
	}
	return res;
}
/*------------以上是得分---------*/
struct xuesheng//学生 
{
	int id,ans,cnt,tot,las;//ans:总得分 cnt和tot:出勤 las：最后一次合法记录时间 
	char xb;//性别 
	friend bool operator <(const xuesheng &x,const xuesheng &y)
	{
		return x.id<y.id;
	}
}a[N];
void duru()
{
	int lin,x,y;char xxx[10];
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		a[i].id=read();
		
		scanf("%s",xxx);
		a[i].xb=xxx[0];

		lin=read();a[i].ans+=lin;//体育课专项成绩

		x=read();y=read();a[i].ans+=changpao(a[i].xb,ti(x,y));//长跑测试成绩
		
		scanf("%s",xxx);if(xxx[0]=='P')a[i].ans+=10;//体质测试成绩
		
		lin=read();a[i].ans+=lin;//期末检测成绩
		a[i].cnt=read();//参加班级训练营的次数
		a[i].las=-9999999;
	}
	sort(a+1,a+1+n);
	for(int i=1;i<=n;++i)mp[a[i].id]=i;
}
int yyy[15]={0,31,28,31,30,31,30,31,31,30,31,30,31};//记录每个月有多少天 
int sj(int yue/*月*/,int ri/*日*/)//返回从1月1日0点到这一天有多少秒 
{
	int res=0;
	for(int i=1;i<yue;++i)res+=yyy[i];
	res+=ri;
	return res*24*60*60;//秒 
}
int Ti(int a,int b,int c)//小时转化为秒 
{
	return a*3600+b*60+c;//秒 
}
void yang_guang_chang_pao()//处理阳光长跑数据 
{
	int rq,hao,t1,t2,t3,t4,t5,t6,t7,t8,stp,T1,T2,T;
	long double jl;
	cin>>m;
	while(m--)
	{
		rq=read();rq%=10000;T=sj(rq/100,rq%100);//rq：日期 
		hao=read();  hao=mp[hao];//学号 
		t1=read();t2=read();t3=read();//开始时间 
		t4=read();t5=read();t6=read();//结束时间 
		cin>>jl;jl*=1000;//距离 
		t7=read();t8=read();//暂停时间 
		stp=read();
		T1=Ti(t1,t2,t3);T2=Ti(t4,t5,t6);//转化为秒	
		if((a[hao].xb=='M'&&jl<3000) || (a[hao].xb=='F'&&jl<1500))continue;//不符合要求1
		if(jl/((LD)T2-T1) < 2 || jl/((LD)T2-T1) > 5)continue;//不符合要求2
		if(ti(t7,t8)>ti(4,30))continue;//不符合要求3
		if(jl/(LD)stp>1.5)continue;//不符合要求4
		
		
		if(T + T1 - a[hao].las < Ti(6,0,0))continue;
		++a[hao].tot;a[hao].las=T+T2;//记得更新最后一条合法记录的结束时间 
	}
}
void shuchu()
{
	for(int i=1;i<=n;++i)
	{
		a[i].ans+=yangguang(a[i].tot); 
		a[i].ans+=chuqin(a[i].cnt+a[i].tot);//出勤分数 
		printf("%d %d ",a[i].id,a[i].ans);dengji(a[i].ans);
		puts("");
	}
}
int main()
{
	duru();//读入 
	yang_guang_chang_pao();//处理阳光长跑的数据 
	shuchu();//输出 
	fclose(stdin);fclose(stdout);
	return 0;
}
```

---

## 作者：BMTXLRC (赞：6)

随机跳到的这道题（x

观察到有五个部分，其中一，二，四是很好解决的，那就考虑先解决掉这三个部分。

### Part 0: 准备阶段

------------

**我们需要些什么？**

- 一个结构体，存储每个学生的各项信息，包括五项成绩，学号，“阳光长跑” 的合法次数，一个 $\texttt{vector}$ 用来存储 “阳光长跑” 的记录，以及这个学生的性别。

- 一个 $\texttt{map}$，用来建立学号与输入顺序的关系，因为开不了那么大的数组。

- 另一个结构体，表示 “阳光长跑” 的记录信息，包括时间，距离和步数，这里会给结构体配置一个用于比较的函数。

- 一颗准备好肝的心（x

**如何输入？**

$\texttt{scanf}$ 能够很好地满足题目要求的输入，以 `%d'%d\"` 输入就好了。

### Part 1: 体育课专项成绩

------------

按照题目输入的，直接加进去就好啦。

```cpp
void subtask1(int node,int x){a[node].x1=x;}
```

### Part 2: 长跑测试成绩

------------

长跑测试成绩给出了一个表格，当你的成绩满足 $a_i\leq k < a_{i+1}$ 时，获得的分数就是 $f_i$。（我用循环打了一下结果没过）

如果你也像我一样打了个循环结果不行，那就暴力用 $\texttt{if-else if}$ 判吧。

|坑点 $1$：长跑测试成绩没有考虑性别问题|
|----|

为了方便 $\texttt{if}$ 的判断，我们可以先将 $a$ 分 $b$ 秒转化为 $a\times 60+b$ 秒。

**务必注意代码的整洁，否则你不会想着查代码的。**

```cpp
void subtask2(int node,int x,int y){
	int s=x*60+y;
	if(a[node].sex==1){
		if(s>1080)                   a[node].x2=0;
		else if(s>1030&&s<=1080)     a[node].x2=2;
		else if(s> 990&&s<=1030)     a[node].x2=4;
		else if(s> 950&&s<= 990)     a[node].x2=6;
		else if(s> 910&&s<= 950)     a[node].x2=8;
		else if(s> 870&&s<= 910)     a[node].x2=10;
		else if(s> 840&&s<= 870)     a[node].x2=12;
		else if(s> 810&&s<= 840)     a[node].x2=14;
		else if(s> 780&&s<= 810)     a[node].x2=16;
		else if(s> 750&&s<= 780)     a[node].x2=18;
		else                         a[node].x2=20;
	}else{
		if(s>540)                  a[node].x2=0;
		else if(s>530&&s<=540)     a[node].x2=2;
		else if(s>515&&s<=530)     a[node].x2=4;
		else if(s>500&&s<=515)     a[node].x2=6;
		else if(s>485&&s<=500)     a[node].x2=8;
		else if(s>470&&s<=485)     a[node].x2=10;
		else if(s>451&&s<=470)     a[node].x2=12;
		else if(s>434&&s<=451)     a[node].x2=14;
		else if(s>417&&s<=434)     a[node].x2=16;
		else if(s>400&&s<=417)     a[node].x2=18;
		else                       a[node].x2=20;
	}
}
```
### Part 3: 体质测试成绩

------------

题目已经给出来了：

- 如果输入为 $\texttt{P}$，则此部分得 $10$ 分；

- 如果输入为 $\texttt{F}$，则此部分的 $0$ 分。

```cpp
void subtask4(int node,char ch){
	if(ch=='P') a[node].x4=10;
	if(ch=='F') a[node].x4=0;
}
```

### Part 4: 阳光长跑

------------

整个题最难的一部分，但是不要怕，我们慢慢分析。

我刚刚说到，学生的结构体中有一个专门用于存 “阳光长跑” 记录的 $\texttt{vector}$，这里就要用到。

|坑点 $2$：对于每一个人的记录，没有进行一定程度的排序。|
|----|

为了方便存储我们上条记录，定义一个 $\texttt{lst}$ 就好。

|坑点 $3$：$\texttt{lst}$ 没被赋值为第一条满足条件的记录。|
|----|

对于这一个，我们定义 $\texttt{flag}$ 来表示当前是否为第一条满足条件的记录，如果是，这条记录一定满足条件，并将 $\texttt{lst}$ 赋值为这一条记录。

|坑点 $4$：第一条满足条件的记录并非是当前这个人的第一条记录。|
|----|

如何对一条记录进行处理？

其实除了时间限制，其他都是很容易判断的。

按照题目要求一个一个来：

- 如果是男生，距离需不小于 $3000$ 米；如果是女生，距离需不小于 $1500$ 米。

|坑点 $5$：没有考虑性别对记录中距离的影响。|
|----|

- 暂停时间不得大于 $270$ 秒。

- 速度应满足 $v\in [2,5]$。

- 步幅不能大于 $1.5$。

最后就是考虑与上条时间间隔的限制。

- 如果不在同一月

	观察是否在相邻两个月，如果不是，这条记录就满足条件。
    
    如果在相邻两个月，上一条记录得在该月最后一天，这一条记录得在 $1$ 号，如果不是，就满足条件
    
    如果上述条件均满足，要考虑是否相差 $6$ 小时，如果不是，则这条记录满足条件。
    
- 如果在同一个月
	
    观察是否在相邻的两天，如果不是，这条记录就满足条件。
    
    如果在相邻两天，那就看是否相差 $6$ 小时，如果相差至少 $6$ 小时，这条记录就满足条件，不是就不满足。
    
    如果在同一天，就看是否相差 $6$ 小时就好了。
    
|坑点 $6$：没有考虑不同月份或是不同天的情况。|
|----|

~~听上去很简单，快试试看吧！~~

```cpp
void subtask3(int node){
	sort(a[node].s.begin(),a[node].s.end());
	record lst;
	bool flag=false;
	for(register int i=0;i<a[node].s.size();i++){
		record now=a[node].s[i];
		if(a[node].sex==1&&now.l<3.0) continue;
		if(a[node].sex==0&&now.l<1.5) continue; 
		int S=now.s1*3600+now.s2*60+now.s3;
		int T=now.t1*3600+now.t2*60+now.t3;
		double v=now.l*1000.0/(T-S),p=now.l*1000.0/now.p;
		if(v<2||v>5||p>1.5||now.q>270) continue;
		if(!flag){
			flag=true;
			lst=a[node].s[i],a[node].cnt++;
			continue;
		}
		S=lst.t1*3600+lst.t2*60+lst.t3,T=now.s1*3600+now.s2*60+now.s3;
		if(now.M!=lst.M){
			if(now.M-1!=lst.M){
				lst=now;a[node].cnt++;
				continue;
			}else{
				if(cal[lst.M]!=lst.D||now.D!=1){
					lst=now;a[node].cnt++;
					continue;
				}else if(86400+T-S<21600) continue;
			}
		}else if(now.D!=lst.D){
			if(now.D-1!=lst.D){
				lst=now,a[node].cnt++;
				continue;
			}else if(86400+T-S<21600) continue;
		}else if(T-S<21600) continue;
		lst=now,a[node].cnt++;
	}
	if(a[node].cnt>=21)                       a[node].x3=10;
	else if(a[node].cnt>=19&&a[node].cnt<=20) a[node].x3=9;
	else if(a[node].cnt>=17&&a[node].cnt<=18) a[node].x3=8;
	else if(a[node].cnt>=14&&a[node].cnt<=16) a[node].x3=7;
	else if(a[node].cnt>=11&&a[node].cnt<=13) a[node].x3=6;
	else if(a[node].cnt>= 7&&a[node].cnt<=10) a[node].x3=4;
	else if(a[node].cnt>= 3&&a[node].cnt<= 6) a[node].x3=2;
	else                                      a[node].x3=0;
}
```

### Part 5: 大一专项计划

------------

根据我们从 $\texttt{subtask 3}$ 得到的满足条件的记录条数，就可以很顺利的推出这一部分。

```cpp
void subtask5(int node){
	a[node].ans=a[node].m+a[node].cnt;
	if(a[node].ans>=18)                       a[node].x5=5+a[node].n;
	else if(a[node].ans>=15&&a[node].ans<=17) a[node].x5=4+a[node].n;
	else if(a[node].ans>=12&&a[node].ans<=14) a[node].x5=3+a[node].n;
	else if(a[node].ans>= 9&&a[node].ans<=11) a[node].x5=2+a[node].n;
	else if(a[node].ans>= 6&&a[node].ans<= 8) a[node].x5=1+a[node].n;
	else                                      a[node].x5=a[node].n;
}
```

至此所有代码就完成了，如果还是不对，就仔细看看有没有一些基础性的错误（

### Part 6: 总代码

------------

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+5;
struct record{
	int s1,s2,s3,t1,t2,t3,q,M,D,p;
	double l;
	bool operator < (const record &x) const{
		if(M!=x.M) return M<x.M;
		else if(D!=x.D) return D<x.D;
		else if(s1!=x.s1) return s1<x.s1;
		else if(s2!=x.s2) return s2<x.s2;
		return s3<x.s3;
	}
};
struct student{
	ll node;
	int x1,x2,x3,x4,x5,cnt,ans;
	bool sex;
	int n,m;
	vector<record> s;
}a[N];
int T,n;
int cal[20]={0,31,28,31,30,31,30,31,31,30,31,30,31};
map<ll,int> f;
void subtask1(int node,int x){a[node].x1=x;}
void subtask2(int node,int x,int y){
	int s=x*60+y;
	if(a[node].sex==1){
		if(s>1080)                   a[node].x2=0;
		else if(s>1030&&s<=1080)     a[node].x2=2;
		else if(s> 990&&s<=1030)     a[node].x2=4;
		else if(s> 950&&s<= 990)     a[node].x2=6;
		else if(s> 910&&s<= 950)     a[node].x2=8;
		else if(s> 870&&s<= 910)     a[node].x2=10;
		else if(s> 840&&s<= 870)     a[node].x2=12;
		else if(s> 810&&s<= 840)     a[node].x2=14;
		else if(s> 780&&s<= 810)     a[node].x2=16;
		else if(s> 750&&s<= 780)     a[node].x2=18;
		else                         a[node].x2=20;
	}else{
		if(s>540)                  a[node].x2=0;
		else if(s>530&&s<=540)     a[node].x2=2;
		else if(s>515&&s<=530)     a[node].x2=4;
		else if(s>500&&s<=515)     a[node].x2=6;
		else if(s>485&&s<=500)     a[node].x2=8;
		else if(s>470&&s<=485)     a[node].x2=10;
		else if(s>451&&s<=470)     a[node].x2=12;
		else if(s>434&&s<=451)     a[node].x2=14;
		else if(s>417&&s<=434)     a[node].x2=16;
		else if(s>400&&s<=417)     a[node].x2=18;
		else                       a[node].x2=20;
	}
}
void subtask3(int node){
	sort(a[node].s.begin(),a[node].s.end());
	record lst;
	bool flag=false;
	for(register int i=0;i<a[node].s.size();i++){
		record now=a[node].s[i];
		if(a[node].sex==1&&now.l<3.0) continue;
		if(a[node].sex==0&&now.l<1.5) continue; 
		int S=now.s1*3600+now.s2*60+now.s3;
		int T=now.t1*3600+now.t2*60+now.t3;
		double v=now.l*1000.0/(T-S),p=now.l*1000.0/now.p;
		if(v<2||v>5||p>1.5||now.q>270) continue;
		if(!flag){
			flag=true;
			lst=a[node].s[i],a[node].cnt++;
			continue;
		}
		S=lst.t1*3600+lst.t2*60+lst.t3,T=now.s1*3600+now.s2*60+now.s3;
		if(now.M!=lst.M){
			if(now.M-1!=lst.M){
				lst=now;a[node].cnt++;
				continue;
			}else{
				if(cal[lst.M]!=lst.D||now.D!=1){
					lst=now;a[node].cnt++;
					continue;
				}else if(86400+T-S<21600) continue;
			}
		}else if(now.D!=lst.D){
			if(now.D-1!=lst.D){
				lst=now,a[node].cnt++;
				continue;
			}else if(86400+T-S<21600) continue;
		}else if(T-S<21600) continue;
		lst=now,a[node].cnt++;
	}
	if(a[node].cnt>=21)                       a[node].x3=10;
	else if(a[node].cnt>=19&&a[node].cnt<=20) a[node].x3=9;
	else if(a[node].cnt>=17&&a[node].cnt<=18) a[node].x3=8;
	else if(a[node].cnt>=14&&a[node].cnt<=16) a[node].x3=7;
	else if(a[node].cnt>=11&&a[node].cnt<=13) a[node].x3=6;
	else if(a[node].cnt>= 7&&a[node].cnt<=10) a[node].x3=4;
	else if(a[node].cnt>= 3&&a[node].cnt<= 6) a[node].x3=2;
	else                                      a[node].x3=0;
}
void subtask4(int node,char ch){
	if(ch=='P') a[node].x4=10;
	if(ch=='F') a[node].x4=0;
}
void subtask5(int node){
	a[node].ans=a[node].m+a[node].cnt;
	if(a[node].ans>=18)                       a[node].x5=5+a[node].n;
	else if(a[node].ans>=15&&a[node].ans<=17) a[node].x5=4+a[node].n;
	else if(a[node].ans>=12&&a[node].ans<=14) a[node].x5=3+a[node].n;
	else if(a[node].ans>= 9&&a[node].ans<=11) a[node].x5=2+a[node].n;
	else if(a[node].ans>= 6&&a[node].ans<= 8) a[node].x5=1+a[node].n;
	else                                      a[node].x5=a[node].n;
}
record ins;
int main(){
	scanf("%d",&T);
	for(register int i=1;i<=T;i++){
		char sex,ch;
		int x,s,t;
		scanf("%lld %c %d %d'%d\" %c %d %d",&a[i].node,&sex,&x,&s,&t,&ch,&a[i].n,&a[i].m);
		if(sex=='M') a[i].sex=1;
		if(sex=='F') a[i].sex=0;
		subtask1(i,x),subtask2(i,s,t),subtask4(i,ch);
		f[a[i].node]=i;
	} 
	scanf("%d",&n);
	for(register int i=1;i<=n;i++){
		int date,s1,s2,s3,t1,t2,t3,q1,q2,p;
		ll node;double l;
		scanf("%d %lld %d:%d:%d %d:%d:%d %lf %d'%d\" %d",&date,&node,&s1,&s2,&s3,&t1,&t2,&t3,&l,&q1,&q2,&p);
		ins.M=date%10000/100,ins.D=date%100,ins.s1=s1,ins.s2=s2,ins.s3=s3,ins.t1=t1,ins.t2=t2,ins.t3=t3;
		ins.l=l,ins.q=q1*60+q2,ins.p=p;
		a[f[node]].s.push_back(ins);
	}
	for(register int i=1;i<=T;i++){
		subtask3(i),subtask5(i);
		int k=a[i].x1+a[i].x2+a[i].x3+a[i].x4+a[i].x5;
		printf("%lld %d ",a[i].node,k);
		if(k>=95&&k<=100)    puts("A");
		else if(k>=90&&k<95) puts("A-");
		else if(k>=85&&k<90) puts("B+");
		else if(k>=80&&k<85) puts("B");
		else if(k>=77&&k<80) puts("B-");
		else if(k>=73&&k<77) puts("C+");
		else if(k>=70&&k<73) puts("C");
		else if(k>=67&&k<70) puts("C-");
		else if(k>=63&&k<67) puts("D+");
		else if(k>=60&&k<63) puts("D");
		else                 puts("F");
	}
}
```


---

## 作者：alvis (赞：4)

## 蒟蒻的第一篇题解

#### [题面传送站](https://www.luogu.com.cn/problem/P7426)
$Updata$:感谢 @Eason_AC 的提示。由于输入时是按学号字典序输入，所以输出的时候不用 $\text{sort}$ 了。

## 正文
只看一眼，便知这是一道大模拟的~~水题~~恶心题目。

根据题意，体育课的总评成绩由五部分组成，所以很快啊，我们就能~~使用松果蚕豆闪电五连鞭~~自然而然的将题目要求分成五个·····啊呸，是六个板块。

### 0.输入
在这里，我用了 $\text{map}$  (STL大法好)，将学籍号**离散化**~~我才不会告诉你是因为我前几天刚学会用 map~~，并且在后面的程序中便于搜找位置。

用了$\text{struct}$，用了$\text{struct}$，~~小麦亩产一千八~~ 元素联结真方便（不会吧不会吧，都$\mathrm{1202}$年了，还有人不会用结构体吗。

对于字符串的输入，由于它的特殊结构（数字+$\mathrm{1}$个字符+数字+$\mathrm{1}$个字符），我们可以**先输入数字，再输入字符，再数字**·····

#### 代码如下
```cpp
struct node{
	unsigned int name;
	char coup,pas;
	int sc1,sc2,rtm,tms,rtms;
	int ssc;
	long long tf;
	long long tfd;
}a[10001];
map<long long ,int> maps;
······
int x1,x2;
char y1,y2;
for(int i = 1;i <= n;i ++){
	cin >> k;
	maps[k]=i;
	a[i].name = k;
	cin >> a[i].coup;
	cin >> a[i].sc1;
	cin >> x1 >> y1 >> x2 >> y2;
	a[i].rtm = x1*60 + x2;
	cin >> a[i].pes;
	cin >> a[i].sc2 >> a[i].tms;
}
······
```

### 1.体育课专项成绩 + 期末成绩
没什么好说的，很显然，直接加。

另外，方便起见，这两项可以直接加的成绩，我把他们放到一起。

### 2.长跑测试成绩

对于我这样的学生来说~~一千真恶心~~跑步是强身健体的好方法。

分与秒之间的比较不是那么容易，但秒与秒之间的比较是较简单的。

我们可以将输入的分和秒全部转化为秒，这样一来，~~可以少打一些代码~~代码会更加简洁。

剩下的不必多说，$\text{if - if else - else }$补上即可。
### 3.【阳光长跑】

在这里，我们通过 $\text{map}$ 的离散化，将~~长长的~~学号映射为~~短短的~~数组下标，这样，我们就可以方便的处理。

在这里，我们同样可以将分与秒的比较，转化为秒的比较。如此一来，我们可以较为方便的对**平均速度**和**开始时间与上次结束时间相隔大于$\mathrm{6}$小时**的判断。

平均速度不必多说，直接除就可以。

对于**开始时间与上次结束时间相隔大于$\mathrm{6}$小时**的判断，因为题目中已经给出了时间保证有序，所以我们可以将上次合法结束时间直接与本次开始时间进行比较。

我们知道上次合法的日期和具体时间和本次的日期与时间。对于日期，实际上只有**两种**情况：相同或不相同。如果相同，我们可以直接对时间进行比较；如果不相同，那么我们的本次时间就要加上日期间的相差小时数。

虽说如此，对于大于等于 $\mathrm{2}$ 天的日期差，我们只需要加上 $\mathrm{48}$ 小时就可以了，因为~~太懒了~~它们是等效的。

平均步幅也不必多说，直接除。（记得要把 $\text{km}$ 换成 $\text{m}$，要用  $\text{double}$）

总暂停时间直接比较即可。

男女生的跑步距离直接 $\text{if}$ 判断即可。

最后记录合法跑步次数，并存储合法的结束时间和日期。

$\text{if}$ 判断所得分数。

### 4.体质测试
直接判断即可。

### 5.出勤

这个直接将**课程次数**与**合法跑步次数**相加，进行判断即可。

出于个人习惯，我将大部分上文中的分数加减放在一起，便于检查。

## 完整代码
#### 我知道你们在等这个（
##### 码风简陋，将就着看吧。
```cpp
#include <bits/stdc++.h>
using namespace std;
int mond[12]={31,28,31,30,31,30,31,31,30,31,30,31};
struct node{
	unsigned int name;
	char coup,pas;
	int sc1,sc2,rtm,tms,rtms;
	int ssc;
	long long tf;
	long long tfd;
}a[10001];
map <long long,int> maps;
bool cmp(node x,node y){
	return x.name < y.name;
}
int main(){
	int n;
	cin >> n;
	long long x1,x2,x3,xx,l;
	char y1,y2;
	int k;
	//输入 
	for(int i = 1;i <= n;i ++){
		cin >> k;
		maps[k]=i;
		a[i].name = k;
		cin >> a[i].coup;
		cin >> a[i].sc1;
		cin >> x1 >> y1 >> x2 >> y2;
		a[i].rtm = x1*60 + x2;
		cin >> a[i].pas;
		cin >> a[i].sc2 >> a[i].tms;
	}
	int m;
	cin >> m;
	int dt,steps;
	int js,ks;
	map<long long,int> :: iterator iter;
	//跑步记录 
	for(int i = 1;i <= m;i ++){
		cin >> dt >> k;
		iter = maps.find(k);
		k=iter->second;
		cin >>x1 >> y1 >> x2 >> y2 >> x3 ;
		ks = x1*3600 + x2 *60 + x3;
		cin >>x1 >> y1 >> x2 >> y2 >> x3 ;
		js = x1*3600 + x2 * 60 +x3;
		xx = js-ks;
//		cout << xx << endl;
		cin >> x1 >> y1 >> x2;
		l=x1*1000 + x2*10;
		cin >> x1 >> y1 >> x2 >> y2;
		cin >> steps;
		double fl = double(l)/double(xx);
		if(fl < 2 || fl > 5)continue;
		if(double(l)/double(steps) > 1.5)continue;
		if(x1 == 4 && x2 >30 || x1 > 4)continue;
		if(ks - a[k].tf < 6*3600){
			int sec=1;
			if(dt == a[k].tfd)continue;
			else {
				if(a[k].tfd/10000 != dt/10000){
					if(a[k].tfd%10000/100 != 12 && a[k].tfd%100 != 31
					&& dt%10000/100 != 1 && dt % 100 != 1) sec = 2;
				}else {
					if(a[k].tfd%10000/100 != dt%10000/100){
						if(a[k].tfd%100 != mond[a[k].tfd%10000/100] 
						&& dt % 100 != mond[dt%10000/100]) sec = 2;
					} else {
						if(dt%100-a[k].tfd % 100 >= 2)sec = 2;
					}
				}
			}
			if(ks+sec*24*3600-a[k].tf < 6*3600)continue;	
		}
		if(a[k].coup == 'M' && l < 3000)continue;
		if(a[k].coup == 'F' && l < 1500)continue;
		a[k].rtms ++;
		a[k].tf = js;
		a[k].tfd = dt;
	}
	//处理
	for(int i=1;i<=n;i++){
		//体育课 + 期末测试 
		a[i].ssc = a[i].sc1+a[i].sc2;
//		cout << a[i].ssc << " ";
		//课外长跑 
		if(a[i].rtms>=21)a[i].ssc += 10;
		else if(a[i].rtms >= 19)a[i].ssc +=9;
		else if(a[i].rtms >= 17)a[i].ssc += 8;
		else if(a[i].rtms >= 14)a[i].ssc += 7;
		else if(a[i].rtms >= 11)a[i].ssc+=6;
		else if(a[i].rtms >= 7)a[i].ssc += 4;
		else if(a[i].rtms >= 3)a[i].ssc+=2;
//		cout << a[i].ssc << " ";
		//出勤
		int cq=a[i].rtms + a[i].tms; 
		if(cq >= 18)a[i].ssc += 5;
		else if(cq >= 15)a[i].ssc +=4;
		else if(cq >= 12)a[i].ssc +=3;
		else if(cq >= 9)a[i].ssc +=2;
		else if(cq >= 6)a[i].ssc +=1;
//		cout << a[i].ssc <<" ";
		//体质 
		if(a[i].pas == 'P')a[i].ssc +=10;
		//长跑测试
		//男 
		if(a[i].coup == 'M'){
			if(a[i].rtm <= 12*60 + 30)a[i].ssc+=20;
		else if(a[i].rtm <= 13*60)a[i].ssc+=18;
		else if(a[i].rtm <= 13*60 + 30)a[i].ssc+=16;
		else if(a[i].rtm <= 14*60)a[i].ssc+=14;
		else if(a[i].rtm <= 14*60 + 30)a[i].ssc+=12;
		else if(a[i].rtm <= 15*60 + 10)a[i].ssc+=10;
		else if(a[i].rtm <= 15*60 + 50)a[i].ssc+=8;
		else if(a[i].rtm <= 16*60 + 30)a[i].ssc+=6;
		else if(a[i].rtm <= 17*60 + 10)a[i].ssc+=4;
		else if(a[i].rtm <= 18*60)a[i].ssc+=2;
		} 
		//女 
		else {
			if(a[i].rtm <= 6*60 + 40)a[i].ssc+=20;
		else if(a[i].rtm <= 6*60 + 57)a[i].ssc+=18;
		else if(a[i].rtm <= 7*60 + 14)a[i].ssc+=16;
		else if(a[i].rtm <= 7*60 + 31)a[i].ssc+=14;
		else if(a[i].rtm <= 7*60 + 50)a[i].ssc+=12;
		else if(a[i].rtm <= 8*60 + 5)a[i].ssc+=10;
		else if(a[i].rtm <= 8*60 + 20)a[i].ssc+=8;
		else if(a[i].rtm <= 8*60 + 35)a[i].ssc+=6;
		else if(a[i].rtm <= 8*60 + 50)a[i].ssc+=4;
		else if(a[i].rtm <= 9*60)a[i].ssc+=2;
		} 
//		cout << a[i].ssc <<" ";

	} 
	for(int i=1;i<=n;i++){
		cout << a[i].name <<" " << a[i].ssc <<" ";
//		cout << a[i].rtm << " " << a[i].rtms  <<" " << a[i].ssc << " "<<a[i].tms;
		if(a[i].ssc >= 95)cout << "A";
		else if(a[i].ssc >= 90)cout << "A-";
		else if(a[i].ssc >= 85)cout << "B+";
		else if(a[i].ssc >= 80)cout << "B";
		else if(a[i].ssc >= 77)cout << "B-";
		else if(a[i].ssc >= 73)cout << "C+";
		else if(a[i].ssc >= 70)cout << "C";
		else if(a[i].ssc >= 67)cout << "C-";
		else if(a[i].ssc >= 63)cout << "D+";
		else if(a[i].ssc >= 60)cout << "D";
		else cout << "F";
		cout << endl;
	}
return 0;
}


```

---

## 作者：wyc2022 (赞：3)

稍微看下题目  
很明显，本题是一个大模拟·····  
那就不多说了，上思路！！！ 

我的思路是——（~~没思路~~）题目咋说咱咋来（~(￣▽￣)~*）。 
##

### 定义：
针对此题，我们可以构造两个结构体 $a_{i}$ 和 $b_{i}$，分别表示每位学生和每次的“阳光长跑”。
### 输入：
题目有说，就按照题目表述来构造代码就行了(～￣▽￣)～。 

### Solve：
$1$、对于每一个学生来说，我们可以直接将其的体育课专项成绩和「大一专项计划」的期末检测成绩直接加入这位学生的总分数。  
$2$、对于每一个学生来说，我们可以通过题目给出的判断条件将其的体质测试成绩、期末长跑测试成绩计算出来，而后加入这位学生的总分数。  
$3$、对于每一个学生来说，最难也是最重要的就是其的“阳光长跑”：  
$\ \ \ \ \ (1)$ 判断其的性别，然后再根据题目给的判断条件判断是否合法  
$\ \ \ \ \ (2)$ 判断其的平均速度、总暂停时间、平均步幅是否合法。  
$\ \ \ \ \ (3)$ 与其上一次的合法记录进行比较，判断是否合法。（用两个数组存储每一个学生的上一条合法记录的完成日期和时间）。  
$4$、利用题目中的判断条件判断每一位学生“阳光长跑”的成绩和「大一专项计划」的出勤分，然后加入该学生的总分数。  
$5$、利用题目中的“百分制成绩与等级、绩点”，算出每位学生的等级。

## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=11111,maxm=2e5;
int read() {
	int x = 0, f = 1;
	char ch = getchar();
	while (!isdigit(ch))f = ch == '-' ? -1 : 1, ch = getchar();
	while (isdigit(ch))x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return x * f;
}
void write(int x) {
	if (x < 0) x = -x, putchar('-');
	if (x > 9) write(x / 10);
	putchar(x % 10 + '0');
}
struct student{
	int id;
	char sex;
	int mark_PE;
	int runpts;
	char body;
	int fin;
	int cla;
	int mark;
	int lastdate;
	int lasttime;
	int timess;
}a[maxn];
struct run
{
	int day;
	int id;
	int start;
	int end;
	double dis;
	int stop;
	int step;
}b[maxm];
int runptsboy(int x)
{
	if(x<=750)return 20;
	if(x<=780)return 18;
	if(x<=810)return 16;
	if(x<=840)return 14;
	if(x<=870)return 12;
	if(x<=910)return 10;
	if(x<=950)return 8;
	if(x<=990)return 6;
	if(x<=1030)return 4;
	if(x<=1080)return 2;
	return 0;
}
int runptsgirl(int x)
{
	if(x<=400)return 20;
	if(x<=417)return 18;
	if(x<=434)return 16;
	if(x<=451)return 14;
	if(x<=470)return 12;
	if(x<=485)return 10;
	if(x<=500)return 8;
	if(x<=515)return 6;
	if(x<=530)return 4;
	if(x<=540)return 2;
	return 0;
}
map<int,int>mp;
bool sunrunning(int x){
	if(b[x].dis/(b[x].end-b[x].start)<2||b[x].dis/(b[x].end-b[x].start)>5) return false;
	if(b[x].stop>270) return false;
	if(b[x].dis/b[x].step>1.5) return false;
	if(a[mp[b[x].id]].sex=='M')
		if(b[x].dis<3000) return false;	
	if(a[mp[b[x].id]].sex=='F')
		if(b[x].dis<1500) return false;
	if(b[x].day==a[mp[b[x].id]].lastdate)
		if(b[x].start-21600<a[mp[b[x].id]].lasttime) return false;
	if(b[x].day-1==a[mp[b[x].id]].lastdate)
		if(b[x].start+(86400-a[mp[b[x].id]].lasttime)<21600) return false;
	a[mp[b[x].id]].lastdate=b[x].day;
	a[mp[b[x].id]].lasttime=b[x].end;
	return true;
}
int SunRun(int x){
	if(x>=21) return 10;
	if(x>=19) return 9;
	if(x>=17) return 8;
	if(x>=14) return 7;
	if(x>=11) return 6;
	if(x>=7)  return 4;
	if(x>=3) return 2;
	return 0;
}
int work(int x){
	if(x>=18) return 5;
	if(x>=15) return 4;
	if(x>=12) return 3;
	if(x>=9) return 2;
	if(x>=6) return 1;
	return 0;
}
string grade(int x){
	if(x>=95) return "A";
	if(x>=90) return "A-";
	if(x>=85) return "B+";
	if(x>=80) return "B";
	if(x>=77) return "B-";
	if(x>=73) return "C+";
	if(x>=70) return "C";
	if(x>=67) return "C-";
	if(x>=63) return "D+";
	if(x>=60) return "D";
	return "F";                  
}
int n,m;
main() {
	n=read();
	for (int i = 1; i <= n; i++) {
		a[i].id=read();cin>>a[i].sex;a[i].mark_PE=read();
		int x, y;char c;
		mp[a[i].id] = i;
		scanf("%lld%c%lld%c%c", &x, &c, &y, &c, &c);
		a[i].runpts = x * 60 + y;
		cin >> a[i].body;a[i].fin=read();a[i].cla=read();
		if (a[i].sex == 'M')a[i].mark += runptsboy(a[i].runpts);
		else a[i].mark += runptsgirl(a[i].runpts);
		a[i].mark += a[i].mark_PE;
		a[i].mark+= a[i].fin;
		if (a[i].body == 'P') a[i].mark+= 10;
	}
	m=read();
	for (int i = 1; i <= m; i++) {
		int x, y, z;char c;
		b[i].day=read();b[i].id=read();
		scanf("%lld:%lld:%lld", &x, &y, &z);
		b[i].start = x * 3600 + y * 60 + z;
		scanf("%lld:%lld:%lld", &x, &y, &z);
		b[i].end = x * 3600 + y * 60 + z;
		cin >> b[i].dis;
		b[i].dis*=1000.0;
		scanf("%lld%c%lld%c%c", &x, &c, &y, &c, &c);
		b[i].stop = x * 60 + y;
		b[i].step=read();
		if(sunrunning(i)) a[mp[b[i].id]].timess++;
	}
	for(int i=1;i<=n;i++){
		a[i].mark+=SunRun(a[i].timess);
		a[i].mark+=work(a[i].timess+a[i].cla);
		string s=grade(a[i].mark);
		printf("%lld %lld ",a[i].id,a[i].mark);
		cout<<s;
		puts("");
	}
	return 0;
}
```

---

## 作者：Cerisier (赞：3)

**我的代码长度较其他题解更长，但是个人认为比较好理解。**

这道题是一道思维难度很低，但是比较难调的一道题。

首先，我们看输入格式，了解信息是如何被储存的。这里我们可以使用两个结构体储存信息，然后内部再建立一个读入的函数。

```cpp
struct 「美元符号」YangGuang {
	int wanchengnian, wanchengyue, wanchengri;
	string laiyuanxuehao;
	int kaishishijianh, kaishishijianm, kaishishijians;
	int jieshushijianh, jieshushijianm, jieshushijians;
	double yundongjvli;
	int zantingshijiana, zantingshijianb;
	int zongbushu;
};

struct 「美元符号」Student {
	string xuehao;
	bool xingbie;
	int tiyukezhuanxiangchengji;
	int tiyuchangpaoceshichengjia, tiyuchangpaoceshichengjib;
	bool tizhiceshitongguo;
	int dayizhuanxiangjihua;
	int banjixunlianying;
	vector<「美元符号」YangGuang> dat;
} stu[maxn];
```

为了方便理解，题目中的变量我都换成了中文拼音。**这里有个坑点**，就是「阳光长跑」数据中，运动距离单位并不是 $\text m$，而是 $\text{km}$，所以需要乘上 $1000$ 将其转化为 m。否则，在后面计算判断数据合法的时候，计算平均速度和步幅时会有错误。对于每个学生，他的阳光长跑信息**需要通过一个 $\text{vector}$ 来储存**，因为 $\text{vector}$ 是动态分配空间的，如果你开了一个长度为 $m$ 的数组，这样总空间就会变成 $n\times m$，是储存不下的。

为了读入，我们可以在结构体里面建立一个 $\text{read}$ 函数来输入数据。对于输入方式是 $\texttt{a:b:c}$ 或者是 $\texttt{a'b"}$ 的情况，我们可以使用 $\text{scanf}$。当然，你可以以建立一个 $\text{char}$ 类型变量来吞掉中间无用的 $\texttt{:}$ 和 $\texttt{'}$。

「阳光长跑」数据的读入方式：

```cpp
void read() {
    string tmp;
    cin >> tmp;
    wanchengnian = strtol(tmp.substr(0, 4));
    wanchengyue = strtol(tmp.substr(4, 2));
    wanchengri = strtol(tmp.substr(6, 2));
    cin >> laiyuanxuehao;
    scanf("%lld:%lld:%lld", &kaishishijianh, &kaishishijianm, &kaishishijians);
    scanf("%lld:%lld:%lld", &jieshushijianh, &jieshushijianm, &jieshushijians);
    cin >> yundongjvli;
    yundongjvli *= 1000;
    scanf("%lld'%lld\"", &zantingshijiana, &zantingshijianb);
    cin >> zongbushu;
}
```

学生的数据的读入方式：

```cpp
void read(int i) {
    cin >> xuehao;
    mp[xuehao] = i;
    char tmp;
    cin >> tmp;
    tmp == 'M' ? xingbie = 1 : xingbie = 0;
    cin >> tiyukezhuanxiangchengji;
    scanf("%lld'%lld\"", &tiyuchangpaoceshichengjia, &tiyuchangpaoceshichengjib);
    cin >> tmp;
    tmp == 'P' ? tizhiceshitongguo = true : false;
    cin >> dayizhuanxiangjihua;
    cin >> banjixunlianying;
}
```

这里我们建立了一个 $\text{map}$ 类型的 $\text{mp}$ 来储存对应学号的下标。如果我们暴力查找每个学号对应下标的话，总时间复杂度会变成 $\mathcal{O}(nm)$，**会超时**。

然后，我们需要判断一个阳光长跑数据是否合法，这里面比较麻烦的就是如何判断当前数据和上一个合法数据相距的时间超过了 $\text{6h}$，这里我展示一下我的代码：

```cpp
「美元符号」YangGuang last = stu.dat[stu.dat.size() - 1];
if (now.wanchengyue != last.wanchengyue) {
    if (now.wanchengyue - 1 != last.wanchengyue) {
        return true;
    }
    else {
        if (month[last.wanchengyue] != last.wanchengri || now.wanchengri != 1) {
            return true;
        }
        else if (86400 + now.kaishishijianh * 60 * 60 + now.kaishishijianm * 60 + now.kaishishijians - last.jieshushijianh * 60 * 60 - last.jieshushijianm * 60 - last.jieshushijians < 21600) {
            return false;
        }
    }
}
else if (now.wanchengri != last.wanchengri) {
    if (now.wanchengri - 1 != last.wanchengri) {
        return true;
    }
    else if (86400 + now.kaishishijianh * 60 * 60 + now.kaishishijianm * 60 + now.kaishishijians - last.jieshushijianh * 60 * 60 - last.jieshushijianm * 60 - last.jieshushijians < 21600) {
        return false;
    }
}
else if (now.kaishishijianh * 60 * 60 + now.kaishishijianm * 60 + now.kaishishijians - last.jieshushijianh * 60 * 60 - last.jieshushijianm * 60 - last.jieshushijians < 21600) {
    return false;
}
return true;
```

我分了四种情况讨论：

1. 不在同一月
2. 不在同一日
3. 其他

只需要将当前日期和上次日期转化为秒，然后相减看相差时间是否大于 $21600$ 秒，也就是 $\text{6h}$ 即可。我们可以先读入这些信息的同时判断这个信息是否合法，如果合法的话，就加入到学号对应的学生信息中的 $\text{vector}$ 数组里面。

输入过后，我们就从 $1$ 开始枚举每个学生，然后计算出对应的成绩即可。

```cpp
for (int i = 1; i <= n; i++) {
    int score = 0;
    score += stu[i].tiyukezhuanxiangchengji;

    if (stu[i].xingbie) {
        int cost = stu[i].tiyuchangpaoceshichengjia * 60 + stu[i].tiyuchangpaoceshichengjib;
        if (cost <= 12 * 60 + 30) {
            score += 20;
        }
        else if (cost <= 13 * 60) {
            score += 18;
        }
        else if (cost <= 13 * 60 + 30) {
            score += 16;
        }
        else if (cost <= 14 * 60) {
            score += 14;
        }
        else if (cost <= 14 * 60 + 30) {
            score += 12;
        }
        else if (cost <= 15 * 60 + 10) {
            score += 10;
        }
        else if (cost <= 15 * 60 + 50) {
            score += 8;
        }
        else if (cost <= 16 * 60 + 30) {
            score += 6;
        }
        else if (cost <= 17 * 60 + 10) {
            score += 4;
        }
        else if (cost <= 18 * 60) {
            score += 2;
        }
    }
    else {
        int cost = stu[i].tiyuchangpaoceshichengjia * 60 + stu[i].tiyuchangpaoceshichengjib;
        if (cost <= 6 * 60 + 40) {
            score += 20;
        }
        else if (cost <= 6 * 60 + 57) {
            score += 18;
        }
        else if (cost <= 7 * 60 + 14) {
            score += 16;
        }
        else if (cost <= 7 * 60 + 31) {
            score += 14;
        }
        else if (cost <= 7 * 60 + 50) {
            score += 12;
        }
        else if (cost <= 8 * 60 + 5) {
            score += 10;
        }
        else if (cost <= 8 * 60 + 20) {
            score += 8;
        }
        else if (cost <= 8 * 60 + 35) {
            score += 6;
        }
        else if (cost <= 8 * 60 + 50) {
            score += 4;
        }
        else if (cost <= 9 * 60) {
            score += 2;
        }
    }

    int ygtimes = stu[i].dat.size();
    if (ygtimes >= 3 && ygtimes <= 6) {
        score += 2;
    }
    else if (ygtimes >= 7 && ygtimes <= 10) {
        score += 4;
    }
    else if (ygtimes >= 11 && ygtimes <= 13) {
        score += 6;
    }
    else if (ygtimes >= 14 && ygtimes <= 16) {
        score += 7;
    }
    else if (ygtimes >= 17 && ygtimes <= 18) {
        score += 8;
    }
    else if (ygtimes >= 19 && ygtimes <= 20) {
        score += 9;
    }
    else if (ygtimes >= 21) {
        score += 10;
    }


    if (stu[i].tizhiceshitongguo) {
        score += 10;
    }

    int times = ygtimes + stu[i].banjixunlianying;
    if (times >= 6 && times <= 8) {
        score += 1;
    }
    else if (times >= 9 && times <= 11) {
        score += 2;
    }
    else if (times >= 12 && times <= 14) {
        score += 3;
    }
    else if (times >= 15 && times <= 17) {
        score += 4;
    }
    else if (times >= 18) {
        score += 5;
    }
    score += stu[i].dayizhuanxiangjihua;

    cout << stu[i].xuehao << ' ' << score << ' ';
    if (score < 60) {
        puts("F");
    }
    else if (score < 63) {
        puts("D");
    }
    else if (score < 67) {
        puts("D+");
    }
    else if (score < 70) {
        puts("C-");
    }
    else if (score < 73) {
        puts("C");
    }
    else if (score < 77) {
        puts("C+");
    }
    else if (score < 80) {
        puts("B-");
    }
    else if (score < 85) {
        puts("B");
    }
    else if (score < 90) {
        puts("B+");
    }
    else if (score < 95) {
        puts("A-");
    }
    else {
        puts("A");
    }
}
```

到此，这道题就结束了。

[附上代码](https://www.luogu.com.cn/paste/p4gbxgss)

---

## 作者：happy_dengziyue (赞：3)

### 前言

本题思路和代码较长，有些东西在题解页面看得不是很舒服。

建议点击右上角的“在 TA 的博客中查看”。

另外，接下来的标题有 $3$ 层，注意区分。

### 思路

#### 1 输入学生信息与初步计算

可以使用[结构体](https://www.runoob.com/cprogramming/c-structures.html)来存储数据。

##### 1.1 学号与性别

输入学号，不需要字符串，只需要 `long long` 就可以了。记得多来一个 `getchar`。

性别使用 `getchar` 直接输入，使用 `bool` 存储。它接下来有很大影响。

##### 1.2 体育课专项成绩

输入一个整数，然后存好，待会算进总分。

感觉这是所有分数中最简单的一个。

##### 1.3 长跑测试成绩

使用 `scanf` 输入长跑数据。

对于形如 `a'b"` 的数据，我们可以这样写 `scanf`：

```
scanf("%d'%d\"",&a,&b);
```

注意倒数第二个 `"` 的前面有一个 `\`，`\` 是转义字符。

然后将时间转换成秒，为 $a\times60+b$。

接下来，将计分标准的分钟转化为秒：

| 分数 | $20$ | $18$ | $16$ | $14$ | $12$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 男生标准（秒） | $750$ | $780$ | $810$ | $840$ | $870$ |
| 女生标准（秒） | $400$ | $417$ | $434$ | $451$ | $470$ |

| 分数 | $10$ | $8$ | $6$ | $4$ | $2$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 男生标准（秒） | $910$ | $950$ | $990$ | $1030$ | $1080$ |
| 女生标准（秒） | $485$ | $500$ | $515$ | $530$ | $540$ |

然后用一个函数 `askcp` 来转化。

记得多来一个 `getchar`。

##### 1.4 体质测试成绩

使用 `getchar` 输入一个字符，再判断，要么 $10$ 分，要么抱铃。

##### 1.5 期末检测成绩和班级训练营参加次数

先输入好，到时候处理大一专项成绩的时候要用。

##### 1.6 标识学生

排一下序，定义 `find` 函数，采用二分法，通过学号返回下标。

#### 2 阳光长跑记录的输入与初步处理

##### 2.1 日期与学号

输入好，日期用 `int`，学号用 `long long`。

另外，实测所有的日期都是在 $2017$ 年的同一个月。敲代码时没考虑到，但是最后过了。

##### 2.2 时间

首先输入好开始时间与结束时间。

设开始于 $sh:sm:ss$，结束于 $eh:em:es$。那么持续时间 $s$（单位是秒）就是：

$$s=eh\times3600+em\times60+es-sh\times3600-sm\times60-ss$$

待会要用。

##### 2.3 距离、暂停时间与步数

输入进去，暂停时间转化成秒数好计算。

#### 3 判断阳光长跑是否合法

##### 3.1 基本数据

首先计算出基本数据（就是不涉及其它记录的数据），如果这都过不了就肯定不合法了，直接 `continue`。

##### 3.2 距离

判断一下即可。这跟性别有关，记得分类讨论。不合法就 `continue`。

##### 3.3 时间间隔

我们可以设 $la$ 数组，第 $i$ 个学生的上一条合法记录为第 $la_i$ 号记录。

如果这是这个学生的第一条记录就是合法的。

如果天数间隔大于等于 $2$ 就是合法的。

设当前记录开始于 $sh:sm:ss$，上一条合法记录结束于 $eh:em:es$，天数间隔为 $k$。那么这也是合法的：

$$sh\times 3600+sm\times60+ss-eh\times3600-em\times60-es+k\times86400\ge21600$$

### 4 最终成绩计算

#### 4.1 阳光长跑次数

对于每一条合法的阳光长跑，进行次数累加。

#### 4.2 阳光长跑分数

我们可以整理出这个表格：

| 分数 | $10$ | $9$ | $8$ | $7$ | $6$ | $4$ | $2$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 次数 | $21$ | $19$ | $17$ | $14$ | $11$ | $7$ | $3$ |

用一个函数 `askyg` 就可以计算了。

#### 4.3 大一专项成绩

算好出勤总次数。也可以有一张表格：

| 分数 | $5$ | $4$ | $3$ | $2$ | $1$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 次数 | $18$ | $15$ | $12$ | $9$ | $6$ |

设分数为 $s$，次数为 $t$，则：

$$s=\left\lfloor(t-3)\div3\right\rfloor$$

#### 4.4 总分和等级

计算总分和等级。

可以将等级分为 $11$ 等，然后输出时再转化。

| 等级 | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 总分 | $95$ | $90$ | $85$ | $80$ | $77$ | $73$ |

| 等级 | $7$ | $8$ | $9$ | $10$ | $11$ |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 总分 | $70$ | $67$ | $63$ | $60$ | $0$ |

很明显，样例中的学生距离及格只差 $1$ 分，$8$ 条阳光长跑记录只有 $2$ 条合法。

### 代码与记录

这道大模拟代码有 $227$ 行，比较长。注意认真研究后再好好想。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define max_n 10000
int n;//人数
struct S;
struct Y;
int askcp(int a,int b,bool x);
int askcq(int cs);
bool cmp(S a,S b);
int find(long long xh);
int askcq(int cq);
struct S{//学生
	//主要信息
	long long xh;//学号
	bool xb;//性别 0男 1女
	int ty;//体育专项课成绩
	int cp;//长跑测试成绩
	int yg;//阳光长跑成绩
	int tz;//体质测试成绩
	int dy;//大一专项计划成绩
	int sum;//总分
	int dj;//等级
	//次要信息
	int cq;//出勤次数（大一专项计划）
	int qm;//期末检测成绩（大一专项计划）
	int bj;//班级训练营参加次数（出勤次数）
	int ygcs;//阳光长跑次数（阳光长跑成绩、出勤次数）
	//函数
	S(){//初始化
		ygcs=0;
	}
	int askcq(){//询问出勤次数
		cq=bj+ygcs;
		return cq;
	}
	int asksum(){//询问总分
		sum=ty+cp+yg+tz+dy;
		return sum;
	}
	int askdj(){//询问等级
		if(sum>=95)return 1;
		if(sum>=90)return 2;
		if(sum>=85)return 3;
		if(sum>=80)return 4;
		if(sum>=77)return 5;
		if(sum>=73)return 6;
		if(sum>=70)return 7;
		if(sum>=67)return 8;
		if(sum>=63)return 9;
		if(sum>=60)return 10;
		return 11;
	}
}s[max_n+2];//学生
int la[max_n+2];//上一条合法记录
#define max_m 150000
int m;//阳光长跑记录数
struct Y{//阳光长跑
	//主要信息
	int rq;//日期
	long long xh;//学号
	int s;//秒数
	float jl;//运动距离
	int zt;//总暂停秒数
	int bs;//总步数
	bool u;//是否有用
	//次要信息
	int sh,sm,ss;//开始时间（秒数）
	int eh,em,es;//结束时间（秒数）
	//函数
	Y(){//初始化
		u=false;
	}
	bool askuse(){//是否有用
		float sd=jl*1000/s;//速度
		float bf=jl*1000/bs;//步幅
		int x=find(xh);
		if(sd<2||sd>5||zt>270||bf>1.5)u=false;
		else u=true;
		return u;
	}
}y[max_m+2];//阳光长跑
int askcp(int a,int b,bool x){//询问长跑成绩
	int ans=a*60+b;
	if(x==0){//男生
		if(ans<=750)return 20;
		if(ans<=780)return 18;
		if(ans<=810)return 16;
		if(ans<=840)return 14;
		if(ans<=870)return 12;
		if(ans<=910)return 10;
		if(ans<=950)return 8;
		if(ans<=990)return 6;
		if(ans<=1030)return 4;
		if(ans<=1080)return 2;
	}
	else{//女生
		if(ans<=400)return 20;
		if(ans<=417)return 18;
		if(ans<=434)return 16;
		if(ans<=451)return 14;
		if(ans<=470)return 12;
		if(ans<=485)return 10;
		if(ans<=500)return 8;
		if(ans<=515)return 6;
		if(ans<=530)return 4;
		if(ans<=540)return 2;
	}
	return 0;
}
int askyg(int cs){//询问阳光长跑成绩
	if(cs>=21)return 10;
	if(cs>=19)return 9;
	if(cs>=17)return 8;
	if(cs>=14)return 7;
	if(cs>=11)return 6;
	if(cs>=7)return 4;
	if(cs>=3)return 2;
	return 0;
}
bool cmp(S a,S b){//排序
	return a.xh<b.xh;
}
int find(long long xh){//寻找下标
	int l=1,r=n;
	int mid;
	while(l<=r){
		mid=(l+r)>>1;
		if(s[mid].xh<xh)l=mid+1;
		else if(s[mid].xh>xh)r=mid-1;
		else return mid;
	}
	return mid;
}
int askcq(int cq){//询问出勤分数
	if(cq>=18)return 5;
	if(cq>=15)return 4;
	if(cq>=12)return 3;
	if(cq>=9)return 2;
	if(cq>=6)return 1;
	return 0;
}
int main(){
	#ifndef ONLINE_JUDGE
	freopen("P7426_1.in","r",stdin);
	freopen("P7426_1.out","w",stdout);
	#endif
	scanf("%d",&n);//输入人数
	for(int i=1,a,b;i<=n;++i){//输入学生信息
		scanf("%lld",&s[i].xh);getchar();//输入学号
		if(getchar()=='M')s[i].xb=0;
		else s[i].xb=1;//输入性别
		scanf("%d",&s[i].ty);//输入体育课专项成绩
		scanf("%d'%d\"",&a,&b);//输入长跑测试
		s[i].cp=askcp(a,b,s[i].xb);getchar();//计算长跑成绩
		if(getchar()=='P')s[i].tz=10;
		else s[i].tz=0;//输入体质测试成绩
		scanf("%d",&s[i].qm);//输入期末检测成绩
		scanf("%d",&s[i].bj);//输入班级训练营参加次数
	}
	sort(s+1,s+n+1,cmp);//排序
	scanf("%d",&m);//输入阳光长跑记录数
	for(int i=1,a,b;i<=m;++i){//输入阳光长跑记录
		scanf("%d",&y[i].rq);//输入日期
		scanf("%lld",&y[i].xh);//输入学号
		scanf("%d:%d:%d",&y[i].sh,&y[i].sm,&y[i].ss);//输入开始时间
		scanf("%d:%d:%d",&y[i].eh,&y[i].em,&y[i].es);//输入结束时间
		y[i].s=y[i].eh*3600+y[i].em*60+y[i].es-y[i].sh*3600-y[i].sm*60-y[i].ss;//计算持续时间
		scanf("%f",&y[i].jl);//输入距离
		scanf("%d'%d\"",&a,&b);//输入暂停时间
		y[i].zt=a*60+b;//计算暂停秒数
		scanf("%d",&y[i].bs);//输入总步数
	}
	for(int i=1,x;i<=m;++i){//处理阳光长跑合不合法
		if(!y[i].askuse())continue;//基本信息已经不合法
		x=find(y[i].xh);
		if((s[x].xb==0&&y[i].jl<3)||(s[x].xb==1&&y[i].jl<1.5)){
			y[i].u=false;
			continue;
		}
		if(la[x]==0){//没有上一条合法记录
			la[x]=i;
			y[i].u=true;
			continue;
		}
		if(y[i].rq-y[la[x]].rq>=2){//日期差距大于等于2天
			la[x]=i;
			y[i].u=true;
			continue;
		}
		if(y[i].sh*3600+y[i].sm*60+y[i].ss-y[la[x]].eh*3600-y[la[x]].em*60-y[la[x]].es+(y[i].rq-y[la[x]].rq)*86400>=21600){//时间差距大于等于6小时
			la[x]=i;
			y[i].u=true;
			continue;
		}//这条if很长，好好记
		y[i].u=false;
	}
	for(int i=1,x;i<=m;++i){//记录与成绩的转化
		if(!y[i].u)continue;
		x=find(y[i].xh);
		++s[x].ygcs;
	}
	for(int i=1;i<=n;++i){
		s[i].yg=askyg(s[i].ygcs);
		s[i].askcq();
		s[i].dy=askcq(s[i].cq)+s[i].qm;
		s[i].asksum();
		s[i].dj=s[i].askdj();
	}
	for(int i=1,a;i<=n;++i){
		printf("%lld %d ",s[i].xh,s[i].sum);
		a=s[i].dj;
		if(a==1)printf("A");
		if(a==2)printf("A-");
		if(a==3)printf("B+");
		if(a==4)printf("B");
		if(a==5)printf("B-");
		if(a==6)printf("C+");
		if(a==7)printf("C");
		if(a==8)printf("C-");
		if(a==9)printf("D+");
		if(a==10)printf("D");
		if(a==11)printf("F");
		printf("\n");
	}
	return 0;
}
```

[记录传送门](https://www.luogu.com.cn/record/55386760)

By **dengziyue**

---

## 作者：Alarm5854 (赞：3)

这道题目的题意还是好理解的，就是根据一系列的信息计算分数并评级，然而要注意的细节很多。分数的计算可以分为几个部分，所以程序也可以分为以下部分。

### 处理时分秒

这些时分秒的输入太麻烦了，用 `scanf` 还要格式化输入。然而，一个快读解决一切输入格式的问题，因为快读只关心数字是否连续，至于中间是什么字符不关心，所以用快读即可。

为了处理问题方便，应该把时分秒转化为秒数 $t$，计算公式如下：

$$t=3600h+60m+s$$

这个公式在之后的计算十分有用，因为这样处理后，就不用再考虑什么进位退位的事情了。

### 处理日期

题目保证日期都是 `2017MMDD` 的形式，所以可以将每个日期减去 $20170000$，分离出 `MM` 和 `DD` 就可以了。最后返回的时候再乘上 $86400$，便于之后判断时间间隔是否合法（跨天的情况）。

### 处理跑步成绩

对题目中给出的表格稍作修改（同处理时分秒），就可以只根据一个量来计算成绩，很方便。

### 处理一些杂七杂八的成绩

对于体质测试成绩，如果是 `P` ，总成绩就加 $10$，否则不变。对于期末检测成绩，直接将读入的数据加到总成绩里面即可。初始出勤次数就是参加班级训练营的次数。

### 处理阳光长跑的成绩（重难点）

这个部分是最最最关键的部分，十分烦人。先将初始的输入数据装成一个结构体并按学号排序，接着用 `map` 来做一个学号到考号的映射，这样就可以把考号转化为编号。日期的处理方法和两个关于时间的计算根据上面的处理方法进行计算即可。跑步的距离单位是 `km`，要把它转化为 `m`，就得将 $l$ 乘以 $1000$。暂停时间也按上面的处理方法进行计算。再直接输入总步数。注意，就算输入没输完就已知非法了，也要把这一行的输入输完，否则接下来会死的很惨（连锁反应）。

接下来的处理步骤如下：

- 看这个人这次的开始时间与上次的结束时间之差，如果小于 $21600$，就非法。
- 看这个人的平均速率，如果不在规定的范围内，就非法。
- 看这个人跑的路程与步数的比值，如果大于 $1.5$，就非法。
- 看这个人的暂停时间，如果大于 $270$，就非法。
- 分性别判断跑步的距离是否合法。

如果这些都合法，就更新这个人的最近一次合法记录、阳光长跑合法次数和出勤次数。

### 输出答案

直接按排完序后的结构体遍历，更新一下分数（还未处理阳光长跑合法次数和出勤次数），根据题意输出即可。

### 代码

```cpp
#include<map>
#include<ctime>
#include<cstdio>
#include<cctype>
#include<algorithm>
#define ll long long
using namespace std;
const ll N=1e4+7;
ll read(){
	char c;
	ll x=0,f=1;
	while(!isdigit(c=getchar()))
		f-=2*(c=='-');
	while(isdigit(c)){
		x=x*10+f*(c-48);
		c=getchar();
	}
	return x;
}
struct stu{
	ll n,se,sc,ot,sun,las;
	bool operator <(stu b){
		return n<b.n;
	}
};
void out(ll s){//根据分数输出等级
	if(s<60){
		puts("F");
		return;
	}
	if(s<63){
		puts("D");
		return;
	}
	if(s<67){
		puts("D+");
		return;
	}
	if(s<70){
		puts("C-");
		return;
	}
	if(s<73){
		puts("C");
		return;
	}
	if(s<77){
		puts("C+");
		return;
	}
	if(s<80){
		puts("B-");
		return;
	}
	if(s<85){
		puts("B");
		return;
	}
	if(s<90){
		puts("B+");
		return;
	}
	if(s<95){
		puts("A-");
		return;
	}
	puts("A");
}
ll calc(ll h,ll m,ll s){//计算时分秒
	return h*3600+m*60+s;
}
ll n,m;
stu a[N];
map<ll,ll>r;
ll test(ll m,ll s,ll se){//根据跑步成绩及性别计算分数
	ll t=calc(0,m,s);
	if(se){
		if(t>1080)
			return 0;
		if(t>1030)
			return 2;
		if(t>990)
			return 4;
		if(t>950)
			return 6;
		if(t>910)
			return 8;
		if(t>870)
			return 10;
		if(t>840)
			return 12;
		if(t>810)
			return 14;
		if(t>780)
			return 16;
		if(t>750)
			return 18;
		return 20;
	}
	if(t>540)
		return 0;
	if(t>530)
		return 2;
	if(t>515)
		return 4;
	if(t>500)
		return 6;
	if(t>485)
		return 8;
	if(t>470)
		return 10;
	if(t>451)
		return 12;
	if(t>434)
		return 14;
	if(t>417)
		return 16;
	if(t>400)
		return 18;
	return 20;
}
ll rev(ll s){//2017****转化为这一年里面的第某天乘以86400
	s-=20170000;
	ll m=s/100;
	ll d=s%100;
	switch(m){
		case 12:
			d+=30;
		case 11:
			d+=31;
		case 10:
			d+=30;
		case 9:
			d+=31;
		case 8:
			d+=31;
		case 7:
			d+=30;
		case 6:
			d+=31;
		case 5:
			d+=30;
		case 4:
			d+=31;
		case 3:
			d+=28;
		case 2:
			d+=31;
	}
	return d*86400;
}
ll csun(ll c){//根据阳光长跑合法次数计算成绩
	if(c<3)
		return 0;
	if(c<7)
		return 2;
	if(c<11)
		return 4;
	if(c<14)
		return 6;
	if(c<17)
		return 7;
	if(c<19)
		return 8;
	if(c<21)
		return 9;
	return 10;
}
ll caot(ll c){//根据出勤次数计算成绩
	if(c<6)
		return 0;
	if(c<9)
		return 1;
	if(c<12)
		return 2;
	if(c<15)
		return 3;
	if(c<18)
		return 4;
	return 5;
}
int main(){
	n=read();
	for(ll i=1;i<=n;++i){
		a[i].n=read();
		char c=0;
		while(!isalpha(c))
			c=getchar();
		a[i].se=c=='M';//0为女性，1为男性
		a[i].sc=read();//读入初始分数
		ll mi=read();
		ll s=read();
		a[i].sc+=test(mi,s,a[i].se);
		c=0;
		while(!isalpha(c))
			c=getchar();
		a[i].sc+=10*(c=='P');//根据是否通过测试更新成绩
		a[i].sc+=read();//直接加上期末检测成绩
		a[i].ot=read();//ot为出勤次数
	}
	sort(a+1,a+n+1);//按照学号排序
	for(ll i=1;i<=n;++i)
		r[a[i].n]=i;//映射
	m=read();
	for(ll i=1;i<=m;++i){
		ll d=rev(read());
		ll id=r[read()];
		ll h=read();
		ll mi=read();
		ll s=read();
		ll st=calc(h,mi,s)+d;
		h=read();
		mi=read();
		s=read();
		ll ed=calc(h,mi,s)+d;
		double dis;
		scanf("%lf",&dis);
		dis*=1000;//要乘以1000，转换单位
		mi=read();
		s=read();
		ll pa=calc(0,mi,s);
		ll cnt=read();
		if(pa>270)
			continue;
		ll ti=ed-st;
		if(st-a[id].las<21600)
			continue;
		double sp=dis/ti;
		if(sp<2||sp>5)
			continue;
		if(dis/cnt>1.5)
			continue;
		if(a[id].se){
			if(dis<3000)
				continue;
		}
		else{
			if(dis<1500)
				continue;
		}
		a[id].las=ed;
		++a[id].sun;
		++a[id].ot;
	}
	for(ll i=1;i<=n;++i){
		a[i].sc+=csun(a[i].sun);
		a[i].sc+=caot(a[i].ot);
		printf("%lld %lld ",a[i].n,a[i].sc);
		out(a[i].sc);
	}
	return 0;
}
```



---

## 作者：TheSky233 (赞：2)

## Description

[$\color{blue}\texttt{【题目传送门】}$](https://www.luogu.com.cn/problem/P7426)

## Solution

### Part 1 几个定义

#### Part 1.1 结构体

先创建几个结构体 $\tt Time,runInfo,studentInfo$，分别存储时间点、跑步信息、每名学生的学号，性别等信息。

```cpp
struct Time{
	int mon,d,h,m,s;
	ll absoluteTime;
};
struct runInfo{
	ll endTime;
	ll p;
	int sh,sm,ss;
	int eh,em,es;
	double runDist;
	int rm,rs;
	int runStep;
};
struct studentInfo{
	ll num;			//学号
	char sex;		//性别
	int PEScore;		//体育课专项成绩
	int lrm,lrs;		//长跑时间 分/秒
	char bodyTest;		//体质测试成绩
	int endTermScore;	//期末成绩
	int trainingTime;	//参加「班级训练营」的次数
	int totScore;		//总分
	int runT;		//「阳光长跑」的合法次数
	vector<runInfo> run;	//跑步信息
}stu[N];
```

#### Part 1.2 判定区间

定义几个数组分别存储每个区间的底线分数，这样就省去了很多 `if-else` 语句。

这里我们把所有 `mm'ss"` 之类的数据全变为以秒存储，会简单很多。

```cpp
pair<int,string> score[20]={{95,"A"},{90,"A-"},{85,"B+"},{80,"B"},{77,"B-"},{73,"C+"},{70,"C"},{67,"C-"},{63,"D+"},{60,"D"},{0,"F"}};

string Phigros(int sc){ //随便取的函数名（逃
	for(int i=0;i<11;i++) if(sc>=score[i].first) return score[i].second;
	return "φ";
}
```

### Part 2 五个分数

#### Part 2.1 体育课专项成绩

直接加到总分即可。

#### Part 2.2 长跑测试成绩

扫一遍判定数组，加到总分。

#### Part 2.3 「阳光长跑」成绩

本题重点来袭！

这里我们引入一个“绝对时间”的概念，即 $\tt absoluteTime$，定义为从 `2022/1/1 01:00` 开始经过的秒数，这个可以 $\mathcal O(1)$ 求出，随后比较两个时间时比较绝对时间即可。

对于每一条记录，我们先判断它是否满足题面前四个条件，满足且之前还没有记录就设为最后一条合法记录，否则再比较当前和现在的绝对时间是否小于 $6 \times 60 \times 60$ 即可。注意开始时间需与上条合法记录的结束时间间隔 $6$ 小时以上 **（包含 $6$ 小时）**；

- 如果你 $90$ pts，看看你是不是没包含 $6$ 小时。

最后记录一下合法记录数量，供 Part 2.5 使用。

#### Part 2.4 体质测试成绩

判断字符是否为 $\tt P$，随后加入总分即可。

#### Part 2.5 「大一专项计划」成绩

按照题面模拟加分即可。

## Code

因代码太长，放[云剪贴板](https://www.luogu.com.cn/paste/jsawzg4x)中。

## Conclusion

一定要沉下气写，不然小小的一个错误也会让评测结果从 $\color{green}\tt AC$ 变为 $\color{red} \tt WA$。


---

## 作者：Dr_Gilbert (赞：2)

# P7426 [THUPC2017] 体育成绩统计

【题目大意】[传送门](https://www.luogu.com.cn/problem/P7426)

这可以说是是 $\text{THUPC}$ 最简单的一道大模拟吧……毕竟这道题在模拟上几乎没有思维难度，要求模拟的事件仅仅是判断一个记录的合法性和对于每个学生算分，算比较简单的一道模拟。这道题也是我为数不多仅靠样例不看题解不求调 $\text{1A}$ 的大模拟。

本来并不想写这道题的题解，但刚才水讨论的时候又看见一个这道题爆零的可怜人，甚至还是因为数组开小全部 $\text{RE}$ 的，同时看到他对于时间的处理十分令人捉急，有感而发，在这里介绍一些我做这道题时的技巧和方法，希望能对大家有帮助。



## Part I. 读题

做大模拟的首要步骤就是读题，认真仔细地读，注意需要模拟的和与模拟密切相关的关键信息。

> 对于大一的同学们来说，体育课的总评成绩由五部分组成：体育课专项成绩（满分 $50$ 分）、长跑测试成绩（满分 $20$ 分）、「阳光长跑」成绩（满分 $10$ 分）、体质测试成绩（满分 $10$ 分）、「大一专项计划」成绩（满分 $10$ 分）。

从这段话我们可以发现，本题要求我们模拟的是一个计算总分的过程，而总成绩由 $5$ 部分组成，那不妨运用面向对象的思想，将每个学生作为一个整体对象计算成绩，开成一个结构体存储信息。根据这里我们可以得出这个类的初步结构如下：

```cpp
struct stu{
	int speclass,ttest;
	int stest,sbody,sfinal; 
}
```

进一步读题，发现长跑测试成绩需要进行一手转化，而且和性别有关。具体怎么转化先放在一边。我们可以继续完善学生类，添加性别一项。由于字符比对时打字比较多，不妨设男生为 $1$，女生为 $0$。继续读题，又发现一个需要模拟的对象，即 “阳光长跑” 记录。发现一条合法的 “阳光长跑” 记录有一个和其它限制都不同的限制，那就是：

> 开始时间需与上条合法记录的结束时间间隔 $6$ 小时以上（包含 $6$ 小时）。

为什么说它不同？因为其它限制都只和这条记录本身的状态，或者和确定的状态相关（学生性别不同，可以直接确认）；而这条限制既和这个学生有关，还和其它的记录有关。所以不妨将最终有效记录的事件也记录到学生类里，具体怎么记录稍后分析。发现一名学生的 “阳光长跑” 成绩和他的有效次数有关，那么学生类里还需要一个记录有效次数的量。

体质测试部分没啥好说的，“大一专项计划” 里期末测试成绩也给出了，就剩一个 “班级训练营” 的参加次数还没处理。由于最终需要统计一个 “出勤次数分”，而出勤次数还需要加上阳光长跑次数，同时长跑次数需要独立计算成绩，所以两种次数分开存储，最终计算时再合在一起。经过上面的分析，我们已经对究竟要干什么了如指掌，开始的 “学生类” 也已经完善如下：

```cpp
struct stu{
	string id;bool sex;// 学生学号，性别
	int speclass,ttest; // 体育课成绩，
	int stest,sbody,sfinal,tclass;// 测试分、体质分、期末分、班级训练次数
	int tsunrun,ssunrun,sattend;// 长跑次数、分数，出席分
	int stotal,grade; // 总分，等第（采用整数存储，输出时映射）
	long long tprerec; // 上次长跑时间
	bool operator <(const stu& a) const{
		return id<a.id; // 输出时排个序
	}
}stu[10010];
```

另外，对于需要维护很多信息的结构体，变量名别起成 $a,b,c\ldots$ 这种，一定要能让自己清楚地知道这个变量是干嘛用的，否则调代码调不出来的时候崩溃的就是自己，并且没人会帮你调。

## Part II. 处理

明确题意后，目前的问题就是确认，面对不同格式的数据如何进行处理。首先不难发现，本题和时间关系十分密切，而又因为出现了两个时刻间时间间隔的计算，所以分别存储年月日时分秒会非常麻烦。联想到我们日常使用的计算机处理时间间隔时，都是将时刻转换为一个整数 “时间戳” 进行计算。又因为本题中时间都在 $2017$ 年，不妨以 $2016$ 年 $12$ 月 $31$ 日 $00:00$ 为 $0$ 点（为什么选这个时间，接下来会说明），计算任意时间点到 $0$ 点经过的秒数作为时间戳，可以非常方便地计算时间间隔。

怎么将年月日时分秒的时间转化为时间戳呢？只需要先考虑经过了几天，然后考虑在当天经过了几秒即可。而怎么计算经过的天数呢？把月和日分开计算即可。例如：$2017$ 年 $2$ 月 $2$ 日 $04:10:05$，先考虑月，$1$ 月有 $31$ 天，又经过了 $2$ 天，所以总共经过了 $33$ 天。但这样会出现一个问题，那就是事实上 $2$ 月 $2$ 日即当天并没有经过。所以我们就有了一个方便的解决方案，将 $0$ 点前移一天即可。这部分的代码如下：

```cpp
int sday[13]={0,31,59,90,120,151,181,212,243,273,304,334,365};
// 2017 年是平年，2 月有 29 天。这里预处理一下月份的前缀和方便计算
long long gettime(string date, string time){
	long long ret=0;
	date=date.substr(4);// 截掉年份
	int mon=(date[0]-'0')*10+date[1]-'0'; // 截取月份和日期
	int day=(date[2]-'0')*10+date[3]-'0';
	ret+=(sday[mon-1]+day)*86400; // 计算经过天数 每天有 86400 秒
	int second=0,minute=0,hour=0;
	hour=(time[0]-'0')*10+time[1]-'0'; // 分离时分秒
	minute=(time[3]-'0')*10+time[4]-'0';
	second=(time[6]-'0')*10+time[7]-'0';
	ret+=hour*3600+minute*60+second;
	return ret;
}
```

但是我们还发现，还有一种时间的表示方式 `x'y"` ，而且长度不固定。但这里的计算非常简单，我们为了方便可以写一个函数计算。

攻克了处理时间这个问题，我们考虑如何进行某些指标和最终分数的转换。不难发现这些转换都是 “查表” 转换，所以不妨模拟一下我们查表时的做法，按得分从高到低顺序遍历表中的标准，遍历到某个得分时如果满足条件，那么这个得分就是最终得分。只需要手动把这个表打出来循环判断即可，代码简洁很多。

## Part III. 总结

事实上，经过前面的分析，发现这道题其实并没有多难，只是需要注意一些细节的处理和模拟的技巧，同时需要优秀的代码能力。但说起来容易，真正地做起来你就会发现还有各种小问题需要解决，所以仍然建议不要停留于 “口胡”，要真正动手写一遍。大模拟并不是纯粹的 “码农题”，它很好地考验了选手的心态、分析能力和代码能力，这些都是作为一名 $\text{OIer}$ 所必备的品质 。本题我含调试时注释的代码长度为 $4.25\text{KB}$，但删去注释后会更短。完整代码如下：

```cpp
#include <bits/stdc++.h>
//#define endl '\n'
using namespace std;
unordered_map<string,int> id;
unordered_map<int,string> grade;
struct stu{
	string id;bool sex;
	int speclass,ttest;
	int stest,sbody,sfinal,tclass;
	int tsunrun,ssunrun,sattend;
	int stotal,grade;
	long long tprerec;
	bool operator <(const stu& a) const{
		return id<a.id;
	}
}stu[10010];
int sday[13]={0,31,59,90,120,151,181,212,243,273,304,334,365};
int stestm[21]={0,1080,1080,1030,1030,990,990,950,950,910,910,
				870,870,840,840,810,810,780,780,750,750};
int stestf[21]={0,540,540,530,530,515,515,500,500,485,485,470,
				470,451,451,434,434,417,417,400,400};
int sattend[6]={0,6,9,12,15,18};
int ssunrun[11]={0,3,3,7,7,11,11,14,17,19,21};
int lgrade[11]={0,60,63,67,70,73,77,80,85,90,95};
long long gettime(string date, string time){
	long long ret=0;
	date=date.substr(4);
	int mon=(date[0]-'0')*10+date[1]-'0';
	int day=(date[2]-'0')*10+date[3]-'0';
	ret+=(sday[mon-1]+day)*86400;
	int second=0,minute=0,hour=0;
	hour=(time[0]-'0')*10+time[1]-'0';
	minute=(time[3]-'0')*10+time[4]-'0';
	second=(time[6]-'0')*10+time[7]-'0';
	ret+=hour*3600+minute*60+second;
	return ret;
}
int getdur(string s){
	int x=0,a=0,b=0;
	while (s[x]!='\''){
		a*=10;a+=s[x]-'0';x++;
	}
	x++;
	while (s[x]!='"'){
		b*=10;b+=s[x]-'0';x++;
	}
	return a*60+b;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(nullptr);cout.tie(nullptr);
	grade[0]="F";grade[1]="D";grade[2]="D+";grade[3]="C-";
	grade[4]="C";grade[5]="C+";grade[6]="B-";grade[7]="B";
	grade[8]="B+";grade[9]="A-";grade[10]="A";
	int n,m;cin>>n;
	for (int i=1;i<=n;i++){
		cin>>stu[i].id;
		char sex;cin>>sex;
		stu[i].sex=(sex=='M')?1:0;
		cin>>stu[i].speclass;
		string ttest;cin>>ttest;
		int timet=getdur(ttest);
		if (stu[i].sex){
			for (int j=20;j>=0;j--){
				if (timet<=stestm[j]){
					stu[i].stest=j;break;
				}
			}
		}else{
			for (int j=20;j>=0;j--){
				if (timet<=stestf[j]){
					stu[i].stest=j;break;
				}
			}
		}
		char pass;cin>>pass;
		if (pass=='P') stu[i].sbody=10;
		else stu[i].sbody=0;
		cin>>stu[i].sfinal>>stu[i].tclass;
		id[stu[i].id]=i;
	}
	cin>>m;
	while (m--){
		string date,studentid,stime,etime;
		cin>>date>>studentid>>stime>>etime;
		double dist;int step;string pdur;
		cin>>dist>>pdur>>step;
		int dis=dist*1000;
		int stuid=id[studentid];
		long long tstart=gettime(date,stime);
		if (tstart-stu[stuid].tprerec<21600){
//			cout<<"Time less than 6hrs"<<endl;
			continue;
		}
		if (stu[stuid].sex){
			if (dis<3000){
//				cout<<"Distance not enough"<<endl;
				continue; 
			}
		}else if (dis<1500){
//			cout<<"Distance not enough"<<endl;
			continue; 
		}
		int tpause=getdur(pdur);
		if (tpause>270){
//			cout<<"Pause too long"<<endl;
			continue;
		}
		double adis=(double)dis/step;
		if (adis>1.50) {
//			cout<<"Average distance too long"<<endl;
			continue;
		}
		long long tend=gettime(date,etime);
		int tdlt=tend-tstart;
		double aspeed=(double)dis/tdlt;
		if (aspeed<2.0||aspeed>5.0){
//			cout<<"Average speed too fast or slow"<<endl;
			continue;
		}
		stu[stuid].tsunrun++;
		stu[stuid].tprerec=tend;
//		cout<<"Record Valid"<<endl;
	}
	for (int i=1;i<=n;i++){
		int tmp=stu[i].tclass+stu[i].tsunrun;
		for (int j=10;j>=0;j--){
			if (stu[i].tsunrun>=ssunrun[j]){
				stu[i].ssunrun=j;break;
			}
		}
		for (int j=5;j>=0;j--){
			if (tmp>=sattend[j]){
				stu[i].sattend=j;break;
			}
		}
		stu[i].stotal=stu[i].sattend+stu[i].speclass+stu[i].stest;
		stu[i].stotal+=stu[i].ssunrun+stu[i].sbody+stu[i].sfinal;
		for (int j=10;j>=0;j--){
			if (stu[i].stotal>=lgrade[j]){
				stu[i].grade=j;break;
			}
		}
	}
	sort(stu+1,stu+1+n);
	for (int i=1;i<=n;i++){
//		cout<<"ID:" <<stu[i].id<<"  Sex:"<<stu[i].sex<<endl;
//		cout<<"Total Score:"<<stu[i].stotal<<"  Grade:"<<grade[stu[i].grade]<<endl;
//		cout<<"SunRun Score:"<<stu[i].ssunrun<<"  Valid Count:"<<stu[i].tsunrun<<endl; 
//		cout<<"Test Score:"<<stu[i].stest<<"  Body Score:"<<stu[i].sbody<<endl;
//		cout<<"Class Score:"<<stu[i].speclass<<"  Final Score:"<<stu[i].sfinal<<endl;
//		cout<<"Attend Count:"<<stu[i].tsunrun+stu[i].tclass<<"  Attend Score:"<<stu[i].sattend<<endl;
		cout<<stu[i].id<<' '<<stu[i].stotal<<' '<<grade[stu[i].grade]<<endl; 
	}
	return 0;
} 
```

到此结束，完结撒花 $\sim$

---

## 作者：PrefixAMS (赞：2)

### 首先，没啥，就是个大模拟(R.I.P)。

######  ~~就是考试整这个题挺不做人的。~~

专项成绩，长跑成绩，体质测试，大一专项是比较简单的部分，主要的难点在于如何处理阳光跑步。

对于学号，是个十位数，数组不太好开，就用 map<string , int> 解决，用一个 string 记录学号

## 变量解释
```cpp
struct node {
	int score,Run,Sun,phi,Fir,Cla;
	int sum;
	char Male,Is;
	string name;
    
   //score为专项,Run为长跑,phi为体质,Fir为大一的前5分
   //sum为总分,Male为性别,Cla为出勤次数。
   //name为学号
}q[4010];


struct Q {
	int id,St,Ed;
   //这个是记录跑步记录
   //id是所属学号
   //St,Ed分别为转化成秒后的起止时间
}fk[maxn];

int bow[4010];
```

## 代码实现

那我们来分块处理：

###  专项成绩
		
 直接输入即可。
 
###  长跑测试
		
   对于男女分别处理，按照成绩段赋分即可。
        
   ```cpp
	int x,y;
		scanf("%d'" , &x);
		scanf("%d" , &y);
		getchar();
		x = x * 100 + y;
		if(q[cnt].Male == 'M') {
			if(x <= 1230) q[cnt].Run = 20;
			if(x > 1230 and x <= 1300) q[cnt].Run = 18;
			if(x > 1300 and x <= 1330) q[cnt].Run = 16;
			if(x > 1330 and x <= 1400) q[cnt].Run = 14;
			if(x > 1400 and x <= 1430) q[cnt].Run = 12;
			if(x > 1430 and x <= 1510) q[cnt].Run = 10;
			if(x > 1510 and x <= 1550) q[cnt].Run = 8;
			if(x > 1550 and x <= 1630) q[cnt].Run = 6;
			if(x > 1630 and x <= 1710) q[cnt].Run = 4;
			if(x > 1710 and x <= 1800) q[cnt].Run = 2;
			if(x > 1800) q[cnt].Run = 0;
		}
		if(q[cnt].Male == 'F') {
			if(x <= 640) q[cnt].Run = 20;
			if(x > 640 and x <= 657) q[cnt].Run = 18;
			if(x > 657 and x <= 714) q[cnt].Run = 16;
			if(x > 714 and x <= 731) q[cnt].Run = 14;
			if(x > 731 and x <= 750) q[cnt].Run = 12;
			if(x > 750 and x <= 805) q[cnt].Run = 10;
			if(x > 805 and x <= 820) q[cnt].Run = 8;
			if(x > 820 and x <= 835) q[cnt].Run = 6;
			if(x > 835 and x <= 850) q[cnt].Run = 4;
			if(x > 850 and x <= 900) q[cnt].Run = 2;
			if(x > 900) q[cnt].Run = 0;
		}
		q[cnt].sum+=q[cnt].Run;
```

其中 Run 为长跑测试分数，sum 为总分。

### 体质测试

同专项成绩，直接输入即可。

### 大一专项

这个分数分为两部分，一部分为直接给出，另一部分靠出勤次数加上阳光跑步成功次数。

所以我们先将出勤次数记录下来最后加上阳光跑步次数。

```cpp
		cin >> q[cnt].Is;//体质是否合格
		if(q[cnt].Is == 'P') q[cnt].phi = 10;
		else q[cnt].phi = 0; 
		q[cnt].sum += q[cnt].phi;
		q[cnt].Fir = read();//第一部分分
		q[cnt].sum += q[cnt].Fir;
		q[cnt].Cla = read();//出勤次数
```
## 阳光跑步（本题难点）

如果直接用两次时间比较，我们会产生许多的特判条件。十分麻烦且易错。所以我们不如将时间转化成秒，题目中已经说到时间为 2017 年所以我们并不需要转化闰年此类 ex 的特判。若我们将其转化成秒（到 2017.1.1)，需要一个大小为 $365 * 24 * 60 * 60 = 31104000$ 的数储存，显然， int 能做到这一切。

P.S. 本人较笨，就用朴素方法转化成秒了，应该很好理解。

```cpp
int to_second(int x , int a , int b , int c) {
	//x为日期,abc,分别为h min s
	int ans = 0;
	x = x % 10000;
	int mon = x / 100,day = x % 100;
	if(mon == 1) {
		ans += (day - 1) * 24 * 60 * 60;
	}
	else if(mon ==  2) {
		ans += 31 * 24 * 60 * 60;
		ans += (day - 1) * 24 * 60 * 60;
	}
	else if(mon ==  3) {
		ans += 31 * 24 * 60 * 60;
		ans += 29 * 24 * 60 * 60;
		ans += (day - 1) * 24 * 60 * 60;
	}
	else if(mon ==  4) {
		ans += 31 * 24 * 60 * 60;
		ans += 29 * 24 * 60 * 60;
		ans += 31 * 24 * 60 * 60;
		ans += (day - 1) * 24 * 60 * 60;
	}
	else if(mon ==  5) {
		ans += 31 * 24 * 60 * 60;
		ans += 29 * 24 * 60 * 60;
		ans += 31 * 24 * 60 * 60;
		ans += 30 * 24 * 60 * 60;
		ans += (day - 1) * 24 * 60 * 60;
	}
	ans += a * 60 * 60 + b * 60 + c;
	return ans;
}
```
以此类推即可。

再看到我们的 $n$ 是 $4000$ 的用 sort 要用到字符串的比较，所以我就在 sort 之前提前把不合适的筛掉，最后判断间隔时间。

```cpp
bool cmp(Q a , Q b) {
	if(a.id != b.id) return a.id < b.id;
   //先按照学号排
	return a.Ed < b.Ed;
   //再按照终止(起始也可以)排序
} 
```

```cpp
int last;
	for(int i = 1 ; i <= n ; i ++) {
		
		q[i].Sun = 1;last = fk[++tot].Ed;
		for(int j = 2 ; j <= bow[i] ; j ++) {
        //bow是i除间隔时间的合法个数
			tot ++;
			int st = fk[tot].St;
			if(st - last >= 6 * 60 * 60) q[i].Sun ++,last = fk[tot].Ed;
			//,cout << tot << endl;
			
		}
	}
```
现在再筛间隔时间就十分方便啦。

需要注意的是 last（上次合法的结束时间）必须要在合法累计答案的时候再更新。

由于代码量过长（9kb），这里就不再粘出来了。

---

## 作者：NATO (赞：1)

## 题目简析

### 一、体育课专项成绩

已经直接给出，直接加入总成绩即可。

### 二、长跑测试成绩

将给定时间转换为秒（$t=a\times 60+b$）按照给定性别和表格（表格也转换为秒），```else if ```  判断分数即可。

### 三、阳光长跑

比较麻烦，读入时，先将读入日期去掉年份（都是 $2017$ 年，没有意义）后转换为秒，再将开始、结束、暂停时间也转换为秒。判断时，先判断该学生最后一次合法记录时间（学生学号与最后一次合法记录时间可以用 ```map ``` 对应）与此次时间间隔是否，然后判断合法性别判断距离是否合法，再暂停时间是否不超过 $270$ 秒，最后按照 $l\times1000/s$ 判断步幅， $l\times1000/(last-begin)$ 判断合法性。

**如果合法，要记得更新该学生最后一次合法记录时间，给该同学的阳光长跑合法次数 $+1$。**

### 四、体质测试成绩

判断是否是 $P$ 即可，是就分数 $+10$。

### 五、「大一专项计划」成绩

将阳光长跑合法次数加上读入的 $c$ 算出出勤次数再将出勤次数按照表格所对应分数赋分后加上 $f$ 即可。

### 汇总

将上述成绩累加后按分数赋等级再按照学号排序输出即可

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll sus,n,s,ac,b,get_to,phy_sum,f,c,class_run,m,ans[10005],qu_m,leg=21600,ti;
ll tw_mo[18]={0,31,28,31,30,31,30,31,31,30,31,30,31};
double l,lm,w,stri;
string p,id[10005];
map<string,ll>c_sum,run_sum;
map<string,ll>sc;
map<string,ll>mf;
char gen,phy;
struct zid
{
	string name;
	ll grade;
	string lev;
}ak[10005];//成绩结构体
bool cmp(zid a,zid b)
{
	return a.name<b.name;
}
ll long_run(ll time,char mn)
{
	if(mn=='M')
	{
		if(time<=750)
			return 20;
		else if(time<=780)
			return 18;
		else if(time<=810)
			return 16;
		else if(time<=840)
			return 14;
		else if(time<=870)
			return 12;
		else if(time<=910)
			return 10;
		else if(time<=950)
			return 8;
		else if(time<=990)
			return 6;
		else if(time<=1030)
			return 4;
		else if(time<=1080)
			return 2;
		else
			return 0;
	}
	else
	{
		if(time<=400)
			return 20;
		else if(time<=417)
			return 18;
		else if(time<=434)
			return 16;
		else if(time<=451)
			return 14;
		else if(time<=470)
			return 12;
		else if(time<=485)
			return 10;
		else if(time<=500)
			return 8;
		else if(time<=515)
			return 6;
		else if(time<=530)
			return 4;
		else if(time<=540)
			return 2;
		else
			return 0;
	}
}//长跑测试成绩计算
ll get_camp(ll sum)
{
	if(sum>=18)
		return 5;
	else if(sum>=15)
		return 4;
	else if(sum>=12)
		return 3;
 	else if(sum>=9)
		return 2;
 	else if(sum>=6)
		return 1;
	else
		return 0;
}//「大一专项计划」出勤次数成绩计算
ll get_day()
{
	ll a=45,mo,da,s=0;
	cin>>a;
	a-=20170000;
	da=a%100;
	mo=(a-da)/100;
	for(ll i=1;i<mo;++i)
		s+=tw_mo[i];
	s+=da;
	return s*86400;
}//阳光长跑中记录的完成日期转秒
ll get_begin()
{
	ll ht,mt,s;
	char s1,s2;
	cin>>ht>>s1>>mt>>s2>>s;
	return ht*3600+mt*60+s;
}//阳光长跑中记录的起始时间转秒
ll get_sus()
{
	ll a,b;
	char ls1,ls2;
	cin>>a>>ls1>>b>>ls2;
	return a*60+b;
}//期末长跑测试成绩转秒
string get_lev(ll gr)
{
	if(gr>=95)
		return "A";
	else if(gr>=90)
		return "A-";
 	else if(gr>=85)
		return "B+";
 	else if(gr>=80)
		return "B";
	else if(gr>=77)
		return "B-";
 	else if(gr>=73)
		return "C+";
	else if(gr>=70)
		return "C";
	else if(gr>=67)
		return "C-";
 	else if(gr>=63)
		return "D+";
 	else if(gr>=60)
		return "D";
 	else
		return "F";
}//打等级
ll get_long(ll sum)
{
	if(sum>=21)
	return 10;
	else if(sum>=19)
	return 9;
	else if(sum>=17)
	return 8;
	else if(sum>=14)
	return 7;
	else if(sum>=11)
	return 6;
	else if(sum>=7)
	return 4;
	else if(sum>=3)
	return 2;
	else
	return 0;
}//阳光长跑的合法次数计算成绩
int main()
{
	ios::sync_with_stdio(0);
	cin>>n;
	char ls1,ls2;
	for(ll i=1;i<=n;++i)
	{
	cin>>p;
	cin>>gen;
	cin>>s;
	cin>>ac>>ls1>>b>>ls2;
	get_to=long_run(ac*60+b,gen);
	cin>>phy;
	if(phy=='P')
		phy_sum=10;
	else
		phy_sum=0;
	cin>>f>>c;
	ans[i]=f+phy_sum+get_to+s;
	c_sum[p]=c;
	sc[p]=0;
	mf[p]=gen;
	id[i]=p;
	}
	ll mp;
	cin>>mp;
	ll begin,last;
	char xb;
	for(ll i=1;i<=mp;++i)
	{
		ti=get_day();
		cin>>p;
		begin=get_begin()+ti;
		last=get_begin()+ti;
		cin>>l;
		lm=l*1000.00*1.00;
		sus=get_sus();
		cin>>s;
		xb=mf[p];//上次合法记录时间
		if(xb=='M')
		{
			if(l<3.00)
			continue;
		}
		else
		{
			if(l<1.50)
			continue;
		}//判断距离
		if(sus>270)
		{
			continue;
		}//判断休息时间
		w=double(lm/(double(last-begin)*1.00));//平均速度
		if(w>5.00||w<2.00)
		continue;
		stri=lm/double(s*1.00);//平均步幅
		if(stri>1.50)
		continue;
		if(begin-sc[p]<21600)
			continue;
		sc[p]=last;++run_sum[p];
	}
	for(ll i=1;i<=n;++i)
	{
		ans[i]+=get_camp(c_sum[id[i]]+run_sum[id[i]])+get_long(run_sum[id[i]]);
		ak[i].grade=ans[i];
		ak[i].name=id[i];
		ak[i].lev=get_lev(ans[i]);
	}
	sort(ak+1,ak+1+n,cmp);
	for(ll i=1;i<=n;++i)
		cout<<ak[i].name<<" "<<ak[i].grade<<' '<<ak[i].lev<<'\n';
}
```





---

## 作者：Areka6219 (赞：1)

## 题意分析

- 给你一堆学生的信息，再给你一堆学生的跑步记录，你需要**正确**的处理跑步记录并且统计每个学生有多少条记录是符合规定的。

### 吐槽

- 这题我昨天我们机房的模拟赛题，是 `T3`，放 `T3` 很~~良心~~凉心，因为第一题是个神仙期望，第二题是个神仙概率……

### 处理读入

- 首先给出几个结构体，便于理解我的代码：

  ```cpp
  class Student {
  	public:
  		int num; //离散化后的编号 
  		long long id; //学号 
  		bool sex; //性别 
  		int Pes; //体育专项成绩 
  		int mit, sed; //长跑分，秒
  		bool pass; //是否通过体育测试
  		int Pef; // 期末成绩
  		int c; //参加班级训练营的次数 
  		int cnt; //阳光长跑合格次数 
  		int g1, g2;
  		inline bool operator < (const Student a) const {
  			return a.id > id;
  		}
  };
  ```

  ```cpp
  class Sun_Running {
  	public:
  		int mon, dy; //月、日
  		long long id; //学号
  		int shr, smit, ssed; //开始时，分，秒 
  		int ehr, emit, esed; //结束时，分，秒 
  		double ln; // 运动距离
  		int spa, spb; //暂停时间
  		int s; // 运动步数 
  };
  ```

  ```cpp
  class Day {
  	public:
  		int hr, mit, sed;
  		int ddy;
  		//时分秒 
  };
  ```

  

- 然后发现读入的时候可以通过 `scanf` 的骚操作来特别方便的处理，

- 像下面这样：

  ```cpp
  for(int i = 1; i <= n; ++i) {
  		scanf("%lld", &st[i].id);
  		st[i].num = i;
  		char x; cin >> x;
  		st[i].sex = x == 'M' ? true : false;
  		scanf("%lld", &st[i].Pes);
  		int a1, b1;
  		scanf("%lld\'%lld\"", &a1, &b1);
  		st[i].mit = a1, st[i].sed = b1;
  		cin >> x;
  		st[i].pass = x == 'P' ? true : false;
  		scanf("%lld", &st[i].Pef);
  		scanf("%lld", &st[i].c);
  		M[st[i].id] = i;
  	}
  ```

- 然后读题发现除了**阳光跑步**剩下的都很好处理，因为阳光跑步还要额外处理跑步记录

### 处理阳光跑步

- 首先，我写了一个函数，来求出两个时间的间隔秒数：

  ```cpp
  inline int Get_Time(Day a, Day b); //得到两个时间相邻的秒数 
  
  inline int Get_Time(Day a, Day b) {
  	int ha = a.hr, mia = a.mit, sea = a.sed;
  	int hb = b.hr, mib = b.mit, seb = b.sed;
  	int ch = 0, cm = 0, cs = 0;
  	//差几小时 差几分钟 差几秒 
  	//先把a、b换算成整点，然后求差值
  	
  	int nha = ha, nhb = hb;
  	int nmia = mia, nmib = mib;
  	if(sea != 0) {
  		nmia++;
  		if(nmia == 60) {
  			nha++;
  			nmia = 0;
  		}
  		cs += 60 - sea;
  		sea = 0;
  	}
  	if(nmia != 0)  {
  		nha++;
  		if(nha == 24)
  			nha = 0;
  		cm += 60 - nmia;
  		nmia = 0;
  	}
      //用 ddy 来判断两个时间是否处于同一天
  	if(a.ddy != b.ddy) {
  		int x1 = 24 - nha, x2 = nhb;
  		ch += (nha == 0) ? x2 : (x2 + x1);
  	}
  	else
  		ch += (nhb - nha);
  	cm += nmib;
  	cs += seb;
  	cm += ch * 60;
  	cs += cm * 60;
  	return cs;
  }
  ```

- 我们读入时对记录本身判断是否合法：

  ```cpp
  inline bool check2(Sun_Running x); // 判断记录本身是否合格
  for(int i = 1; i <= m; ++i) { // 读入
  	string ddy;
  	cin >> ddy;
  	int x1 = (ddy[4] - '0') * 10 + ddy[5] - '0';
  	int x2 = (ddy[6] - '0') * 10 + ddy[7] - '0';
  	rc[i].mon = x1, rc[i].dy = x2;
  	scanf("%lld", &rc[i].id);
  	scanf("%lld:%lld:%lld", &rc[i].shr, &rc[i].smit, &rc[i].ssed);
  	scanf("%lld:%lld:%lld", &rc[i].ehr, &rc[i].emit, &rc[i].esed);
  	scanf("%lf", &rc[i].ln);
  	rc[i].ln *= 1000; // 注意这里的单位换算
  	scanf("%lld\'%lld\"", &rc[i].spa, &rc[i].spb);
  	scanf("%lld", &rc[i].s);
  	int num = Get_num(rc[i].id);
  	if(check2(rc[i]))
  		srun[num].push_back(i);
  }
  inline bool check2(Sun_Running x) {
  	int num = Get_num(x.id); // 得到 id
  	bool sex = st[num].sex; // 通过 id 得到性别
      // 判断距离是否够大
  	if(sex) {
  		if(x.ln < 3000)
  			return false;
  	}
  	if(!sex) {
  		if(x.ln < 1500)
  			return false;
  	}
      // 求出跑步时间
  	Day x1, x2;
  	x1.hr = x.shr, x1.mit = x.smit, x1.sed = x.ssed;
  	x2.hr = x.ehr, x2.mit = x.emit, x2.sed = x.esed;
  	x1.ddy = x2.ddy = 1;
  	int Tsimes = Get_Time(x1, x2);
  	double tmm = Tsimes;
  	double v = x.ln / tmm;
  	if(v < 2.0 or v > 5.0)
  		return false;
      // 求速度
  	x1.hr = 0, x1.mit = 0, x1.sed = 0;
  	x2.hr = 0, x2.mit = x.spa, x2.sed = x.spb;
  	x1.ddy = x2.ddy = 1;
  	// 计算暂停时间
  	int ddd = Get_Time(x1, x2);
  	if(ddd > 270)
  		return false;
      // 暂停时间不超过 4'30"
  	double xs = x.s * 1.0;
  	double xx = x.ln / xs;
  	if(xx > 1.5)
  		return false;
      // 步幅不超过 1.5
  	return true;
  }
  ```

- 记录合法，则我们将它放入每个人所对应的 `vector` 来判断两个相邻合法记录是否超过 `6h`：

  ```cpp
  inline bool check1(Sun_Running a, Sun_Running b); // 判断 a、b 两条记录是否相差 6 小时
  inline bool check1(Sun_Running a, Sun_Running b) {
  	int ma = a.mon, mb = b.mon, da = a.dy, db = b.dy;
  	// a、b 的年月日
  	int ha = a.ehr, mia = a.emit, sea = a.esed;
  	// a的结束时间
  	int hb = b.shr, mib = b.smit, seb = b.ssed;
  	
  	if(ma < mb) {
  		if(da == Month[ma] and db == 1) {
  			Day x1, x2;
  			x1.hr = ha, x1.mit = mia, x1.sed = sea, x1.ddy = 1;
  			x2.hr = hb, x2.mit = mib, x2.sed = seb, x2.ddy = 2;
  			return check0(x1, x2);
              // a、b 分别为两个月的相邻记录
  		}
  		else
  			return true;
  	}
  	if(da != db) {
  		if(db != da + 1)
  			return true;
          // a、b天数不相邻
  		Day x1, x2;
  		x1.hr = ha, x1.mit = mia, x1.sed = sea, x1.ddy = 1;
  		x2.hr = hb, x2.mit = mib, x2.sed = seb, x2.ddy = 2;
  		return check0(x1, x2);
  	}
  	else {
  		if(hb - ha <= 4)
  			return false;
          //如果时差小于 4 小时，那么分和秒肯定凑不够 6小时，直接返回 true
  		Day x1, x2;
  		x1.hr = ha, x1.mit = mia, x1.sed = sea, x1.ddy = 1;
  		x2.hr = hb, x2.mit = mib, x2.sed = seb, x2.ddy = 1;
  		return check0(x1, x2);
  	}
  }
  ```

- 判断完了之后就计数，记录每个人有多少条合法的记录：

  ```cpp
  inline int G_Sun_Run(Student x); // 得到阳光跑步成绩
  //用 V 表示每条记录是否合法
  inline int G_Sun_Run(Student x) {
  	int cnt = 0, num = Get_num(x.id);
  	if(srun[num].size() == 0)
  		return 0;
  	memset(V, 0, sizeof(V));
  	V[0] = true;
  	for(int i = 0; i < srun[num].size() - 1; ++i) {
  		int j = i + 1;
  		if(check1(rc[srun[num][i]], rc[srun[num][j]])) {
  			V[j] = true;
  		}
  		else {
  			bool flag = false;
  			int k;
  			for(k = j + 1; k < srun[num].size(); ++k) {
  				if(check1(rc[srun[num][i]], rc[srun[num][k]]))
  					break;
  				if(k == srun[num].size() - 1) {
  					flag = true;
  					break;
  				}
  			}
  			if(flag) {
  				break;
  			}
  			else {
  				i = k - 1, V[k] = true;
  			}
  		}
  	}
  	
  	for(int i = 0; i < srun[num].size(); ++i)
  		cnt += (V[i] == true);
  	return cnt;
  }
  ```

- 这样处理完阳光跑步后，本题的核心就结束了。

### 给出完整代码

Code：进[剪切板](https://www.luogu.com.cn/paste/gk6ju3v2)看我 `600` 行裹脚代码

---


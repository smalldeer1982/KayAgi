# [HAOI2006] 均分数据

## 题目描述

已知 $n$ 个正整数 $a_1,a_2 ... a_n$ 。今要将它们分成 $m$ 组，使得各组数据的数值和最平均，即各组数字之和的均方差最小。均方差公式如下：

$$\sigma = \sqrt{\frac 1m \sum\limits_{i=1}^m(\overline x - x_i)^2},\overline x = \frac 1m \sum\limits_{i=1}^m x_i$$

其中 $\sigma$ 为均方差，$\bar{x}$ 为各组数据和的平均值，$x_i$ 为第 $i$ 组数据的数值和。

## 说明/提示

样例解释：$1,6$、$2,5$、$3,4$ 分别为一组

【数据规模】

对于 $40\%$ 的数据，保证有 $m \le n \le 10$，$2 \le m \le 6$

对于 $100\%$ 的数据，保证有 $m \le n \le 20$，$2 \le m \le 6$


## 样例 #1

### 输入

```
6 3
1 2 3 4 5 6
```

### 输出

```
0.00```

# 题解

## 作者：ysner (赞：29)

这题好像只能试出答案。。。

于是，时间复杂度低却又玄学的搜索“模拟退火”走起。

这不连续分组看起来很不好弄，我们可以把它转化为一个熟悉的问题：连续分组问题。这个问题可以用简单DP完成（设状态为f[i][j]，表示前i个数分j组）。

怎么实现转化呢？用于连续分组的序列 改下顺序 不就成了不连续分组的问题吗?

所以，用模拟退火rand序列，再DP统计答案，取其小者即可。

如果通不过就改改SA中的参数吧。

```
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<ctime>
#define ll long long
#define re register
#define il inline
#define pf(x) ((x)*(x))
#define fp(i,a,b) for(re int i=a;i<=b;i++)
#define fq(i,a,b) for(re int i=a;i>=b;i--)
using namespace std;
const int N=50;
int n,m,a[N],s[N];
double ans=1e100,f[N][N],ysn;
il int gi()
{
  re int x=0,t=1;
  re char ch=getchar();
  while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
  if(ch=='-') t=-1,ch=getchar();
  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
  return x*t;
}
il double work()
{
  memset(f,127,sizeof(f));
  fp(i,1,n) s[i]=s[i-1]+a[i];//注意到数列不固定，因此不能预处理
  f[0][0]=0;
  fp(i,1,n)
    fp(j,1,i)
    fp(k,0,i-1)
    f[i][j]=min(f[i][j],f[k][j-1]+pf(s[i]-s[k]-ysn));
  ans=min(ans,f[n][m]);
  return f[n][m];
}//DP处理rand出的序列
il double Rand(){return rand()%100000/100000.00;}
il void SA(re double T)
{
  double now=ans;
  while(T>1e-3)
    {
      re int x=rand()%n+1,y=rand()%n+1;
      if(x==y) continue;
      swap(a[x],a[y]);//rand出新序列
      re double  nw=work();
      if(nw<now||exp(now-nw)/T>Rand()) now=nw;//一定概率接受当前状态
      else swap(a[x],a[y]);
      T*=0.99;
    }
  fp(i,1,10000)
    {
      re int x=rand()%n+1,y=rand()%n+1;
      if(x==y) continue;
      swap(a[x],a[y]);work();swap(a[x],a[y]);
    }
}
il double Time(){return (double)clock()/CLOCKS_PER_SEC;}
int main()
{
  srand(19260817);
  n=gi();m=gi();
  fp(i,1,n) a[i]=gi();
  fp(i,1,n) ysn+=1.0*a[i]/m;
  work();
  while(Time()<0.75)//通过增加rand的次数保证正确性
    SA(10000);
  printf("%.2lf\n",sqrt(ans/m));
  return 0;
}

```

---

## 作者：Smallbasic (赞：21)

看到题应该都能想到一个明显的贪心。

由小学奥数可得$x_i$的值越接近答案越小，于是把每个数加到当前和最小的组里。

但是用脚造数据也能Hack这种方法。。。于是可以随机化，进行多次贪心。每次贪心都把序列打乱，多次运算取最优解得到的答案正确率会大大提高（当然还是要看人品）

具体看代码吧

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath> 
#include <ctime>

using namespace std;

int n, m, a[105], b[105], clc = 200000, sum = 0;
double ans = 10000000.0, pj;

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; ++i) { scanf("%d", &a[i]); sum += a[i]; }
	pj = (double)sum / (double)m;
	while (clc--) {
		random_shuffle(a + 1, a + n + 1);
		memset(b, 0, sizeof(b));
		int t = 1; double sm = 0;
		for (int j = 1; j <= n; ++j) {
			for (int i = 2; i <= m; ++i)
				if (b[i] < b[t]) t = i;
			b[t] += a[j]; t = 1;
		}
		for (int i = 1; i <= m; ++i) sm += (double)(pj - b[i]) * (double)(pj - b[i]);
		sm /= (double)m; if (ans > sm) ans = sm;
	} printf("%.2lf", sqrt(ans)); return 0;
}
```


---

## 作者：WJiannan (赞：13)

论如何乱搞：


看看原式：$$\sigma=\sqrt{\sum_{i=1}^n\ (x_i-\bar{x})^2 \over n}\quad\bar{x}={\sum_{i=1}^n\ x_i \over n}$$


同时开方：$$n\sigma^2=\sum_{i=1}^n\ (x_i-\bar{x})^2$$


拆开算式：$n\sigma^2=\sum_{i=1}^n x_i^2-2\bar{x}\sum_{i=1}^{n}x_i + \sum_{i=1}^{n}\bar{x}^2$


我们知道 $-2\bar{x}\sum_{i=1}^{n}x_i + \sum_{i=1}^{n}\bar{x}^2$ 都是定值，


也可以推测出当 $\sum_{i=1}^{n}x_i$ 为定值，每个 $x$ 尽量接近时，$\sum_{i=1}^n x_i^2$ 最大。


于是我们可以将数组 random\_shuffle 若干次，每次贪心的取值，使每个 $x$ 尽量相等（例如你可以把新加进来的数，加给最小 $x$），取最大值，然后就 AC 了！！！


大胆猜想，不要证明！


```cpp
//小范围我写了个暴力，我做这题时也只是抱着试试看的心态，如果WA，请加大 random_shuffle 次数，或者加个卡时。
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#define R register
#define Min(_A, _B) (_A < _B ? _A : _B)
int n, m;
namespace Part1
{
    const double Inf1 = 1e9, Inf = 1e8;
    int sum[1 << 20 | 10], a[25];
    double f[1 << 20 | 10][7], ave;    
    void main()
    {
        for(R int i = 0; i < n; i++) scanf("%d", &a[i]);
        R int Full = 1 << n;
        for(R int i = 0; i < Full; i++)
            for(R int j = 0; j < n; j++)
                if(!((i >> j) & 1)) sum[i | 1 << j] = sum[i] + a[j];
        ave = (double) sum[Full - 1] / m;
        for(R int i = 0; i < Full; i++)
            for(R int j = 0; j <= m; j++)
                f[i][j] = Inf1;
        f[0][0] = 0;
        for(R int i = 0; i < Full; i++)
        {
            for(R int j = 0; j < m; j++)
                if(f[i][j] < Inf)
                {
                    R int u = ~i & (Full - 1); 
                    for(R int t = u; t; t = (t - 1) & u) 
                    {
                        R double tmp = f[i][j] + (sum[t] - ave) * (sum[t] - ave);
                        f[i | t][j + 1] = Min(tmp, f[i | t][j + 1]);
                    }    
                }
        }
        printf("%.2lf", sqrt(f[Full - 1][m] / m));
    }
}
namespace Part2
{
    int a[25], sum, d[8];
    void main()
    {
        R double Ans = 1e9;
        for(R int i = 1; i <= n; i++) scanf("%d", &a[i]);
        for(R int i = 1; i <= n; i++) sum += a[i];
        R double Ave = (double) sum / m;
        R double Tmp = Ave * Ave * m - 2 * Ave * sum;
        for(R int i = 1; i <= 200000; i++)
        {
            std::random_shuffle(a + 1, a + 1 + n);
            for(R int j = 1; j <= m; j++) d[j] = 0;
            for(R int j = 1; j <= n; j++)
            {
                R int Pos = 1;
                for(R int k = 2; k <= m; k++)
                    if(d[Pos] > d[k]) Pos = k;
                d[Pos] += a[j];
            }
            R double tt = 0;
            for(R int j = 1; j <= m; j++) tt += d[j] * d[j];
            Ans = Min(Ans, tt + Tmp);
        }
        printf("%.2lf", sqrt(Ans / m));
    }
}
int main()
{
    scanf("%d %d", &n, &m);
    R long long t = 1;
    for(R int i = 1; i <= n; i++) t *= 3;
    if(t * m <= 1e8) Part1::main();
    else Part2::main();
    
}
```

---

## 作者：attack (赞：11)

看到楼下貌似都用了DP？

其实这题直接强上模拟退火也是可以的

随机出每个位置在哪个地方

然后每次任意取出一个元素，加到最小的分组中

exp的设定就按套路来，用更新后的值减去之前的值
```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<cmath>
#include<ctime>
#include<cstdlib> 
#include<algorithm>
#include<cstring>
#define sqr(x) ((x)*(x))
const int MAXN = 31;
const double eps = 1e-15;
const int INF = 1e9 + 10;
using namespace std;
inline int read() {
    char c = getchar();int x = 0, f = 1;
    while(c < '0' || c > '9') {if(c == '-') f = -1;c = getchar();}
    while(c >= '0' && c <= '9') {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}
int N, M;
int belong[MAXN], a[MAXN];
double sum[MAXN], Aver = 0, Best = 1e20;
void MoNiTuiHuo() {
    memset(sum, 0, sizeof(sum));
    const double DeltaT = 0.99;
    double ans = 0;
    for(int i = 1; i <= N; i++) belong[i] = rand() % M + 1, sum[ belong[i] ] += a[i];
    for(int i = 1; i <= M; i++) ans += sqr(sum[i] - Aver);
    for(double T = 10000; T > eps; T *= DeltaT) {
        int P = min_element(sum + 1, sum + M + 1) - sum;//找出最小的位置 
        int X = rand() % N + 1;//这里直接随机就可以 
        double Pre = ans;
        ans -= sqr(sum[ belong[X] ] - Aver) + sqr(sum[P] - Aver);
        sum[ belong[X] ] -= a[X]; sum[P] += a[X];
        ans += sqr(sum[ belong[X] ] - Aver) + sqr(sum[P] - Aver);		
        if((ans < Pre) || (exp( (ans-Pre)/T ) * RAND_MAX  < rand() )) belong[X] = P;//以一定概率接受最优解 
        else ans = Pre, sum[ belong[X] ] += a[X], sum[P] -= a[X];	//不更新 
    }
    if(ans < Best) 
        Best = ans;
}
int main() {
    #ifdef WIN32
    freopen("a.in", "r", stdin);
    #endif
    srand(19260817);
    N = read(); M = read();
    for(int i = 1; i <= N; i++) a[i] = read(), Aver += a[i];
    Aver /= M;
    for(int i = 1; i <= 1000; i++) MoNiTuiHuo();
    printf("%.2lf",sqrt(Best / M));//因为y=sqrt(x)这个函数具有单调性，所以最后在开根就可以 
    return 0;
}
```

---

## 作者：破忆 (赞：9)

题目相信大家都看过了，一道硬核的数学题

如果还是没有看懂题目，下面稍微解释一下。

把n个数分成k组，每组单独求和，使这k个数的方差最小


------------

### 解法一

#### 模拟退火

一种玄学算法，其他几篇题解已经说的挺详细的了，这里就不介绍了。


------------


### 解法二

#### 搜索+剪枝

把n个数分成m组，不剪枝的话有n^m的复杂度，极端数据64000000，再加上一些常数，很容易超时。

这里手动@一下 LYP巨佬，他提供的解法如下
```
#include<bits/stdc++.h>
#define re register
#define il inline
using namespace std;
double ans=1e99,X;
int n,m,a[25],len,sff[25];
il int read(){
	int red=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){ if(ch=='-') f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') red=red*10+ch-48,ch=getchar();
	return red*f;
}
il void DFS(int x){
	int sff_[25];
	sort(sff+1,sff+1+m); //尽量先算当前加和比较小的
	for(re int i=1;i<=m;i++) sff_[i]=sff[i]; //先存一下当前的加和
	if(x>n){
		double now=0;
		for(re int i=1;i<=m;i++) now+=(X-sff[i])*(X-sff[i]);
		ans=min(ans,now/m);
		return;
	}
	if((double)clock()/CLOCKS_PER_SEC>0.95){printf("%.2lf",sqrt(ans));exit(0);} //卡时，时间不够就弹最优解
	for(re int i=1;i<=m;i++){
		sff[i]+=a[x];DFS(x+1);
		for(re int j=1;j<=m;j++) sff[j]=sff_[j]; //读取之前存过的结果
	}
}
int main(){
	freopen("data.in","r",stdin);
	freopen("data.out","w",stdout);
	n=read(),m=read();
	for(re int i=1;i<=n;i++) a[i]=read(),X+=a[i];
	X/=m;
	sort(a+1,a+1+n);reverse(a+1,a+1+n);
	DFS(1);
	printf("%.2lf",sqrt(ans));
	return 0;
}
```
出题人可能是有意卡这种解法，只能拿到90分，再次感谢LYP巨佬


------------


### 解法三

#### 随机排序+堆优化

方差的前提是平均数，稍微推导就可以知道，平均数是不变的，那么只要让着k个加和的离散程度最小即可。

那么自然而然就会想到贪心，对于每个数据，在之前的加和中找最小的，由于贪心的反例很多，需要多排序几次，重复做这个事情

对于其中的一次计算，每个数字每次找最小，复杂度为(n*m)

如果采用堆优化，就可以缩减到（n*logm）

效果虽然不是很明显，但节省下来的时间可以多算几次
~~适用于博主这样的非酋~~
下面请看代码
```
#include<bits/stdc++.h>
#define IN inline
#define RE register
using namespace std;
int n,m,a[25],hep[10],len;
double ave,ans=1e100;
double sqr(double x){return x*x;}
IN void put(int x){
	hep[++len]=x;
	int son=len;
	while(son>1&&hep[son]<hep[son>>1]) swap(hep[son],hep[son>>1]),son>>=1;
}
IN int get(){
	int ret=hep[1];
	int fa=1,son;
	hep[1]=hep[len--];
	while((fa<<1)<=len){
		if((fa<<1|1)>len||hep[fa<<1]<hep[fa<<1|1]) son=fa<<1;else son=fa<<1|1;
		if(hep[son]<hep[fa]) swap(hep[fa],hep[son]),fa=son;else break;
	}
	return ret;
}
IN void calc(){
	len=0;
	memset(hep,0,sizeof hep);
	double now=0;
	for(RE int i=1;i<=m;i++) put(a[i]); //每组先塞一个
	for(RE int i=m+1;i<=n;i++) put(a[i]+get()); //挑最小的加上当前的数字
	for(RE int i=1;i<=m;i++) now+=sqr(ave-get());
	if(now<ans) ans=now;
}
int main(){
	freopen("data.in","r",stdin);
	freopen("data.out","w",stdout);
	srand(20050614);//种子可以随便选
	scanf("%d%d",&n,&m);
	for(RE int i=1;i<=n;i++) scanf("%d",&a[i]),a[0]+=a[i];
	ave=(double)a[0]/m;
	calc();
	while((double)clock()/CLOCKS_PER_SEC<0.9){ //卡时，只要时间没到，一直算就是了
		random_shuffle(a+1,a+1+n); //随机排序
		calc();
	}
	printf("%.2lf\n",sqrt(ans/m));
	return 0;
}
```
这个算法有一定的偶然性~~虽然我一遍就过了~~，仅供参考用

---

## 作者：tosania (赞：5)

这道题是一道很好的~~暴力~~模拟退火题。（我也是被czy巨佬拉过来做的）

首先，我们考虑，要是方差最小，那么做好就是将数分成尽量靠近的M份

那么，怎么分呢？我们可以这么做：新建M个数组，从1扫到n，将当前的数插入数值最小的那个数组中，这样尽量保证了得到的方差最小。但很显然，这样的正确性却没有保证，所以我们需要将之前的数组以不同的形式排列，才可以得到正确答案。

嗯，看上去暴力全排列也不是很大，只有$20!$,明显~~不会爆~~,为了不TLE，我们必须采用一种人类历史上最伟大的算法：玄学打乱！之前的全排列复杂度我们吃不消，但打乱的复杂度我们还是可以接受的，那么正确性呢，建议大家出门前洗把脸，这样就会高一点了（确信

嗯，这里推荐大家一个函数，random_shuffle(数组名+1,数组名+排序位数+1);这个stl自带函数我一直以为没毛用，没想到竟然在这里用上了。

好那么下面我们将真正的模拟退火：

[浅谈玄学算法——模拟退火](https://m-sea.blog.luogu.org/qian-tan-SA). 

好，讲完了（不过说实话上面这篇文章确实写得很好。）

下面是代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
double anss=1000000000,pin,sum,a[21],b[21];
int n,m,minn,wei;
void print()
{
	double lans=0;
	sum=0;
	for(int i=1;i<=m;i++)
	sum+=b[i];
	pin=(double)sum/(double)m;
	for(int i=1;i<=m;i++)
	{
		lans+=(pin-b[i])*(pin-b[i]);
	}
	lans/=m;
	lans=sqrt(lans);
	if(lans<anss)
	anss=lans;
}
int main()
{
	srand(time(0));
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
}
	for(int i=1;i<=1000000;i++)
	{
		memset(b,0,sizeof(b));
		random_shuffle(a+1,a+n+1);
		for(int j=1;j<=n;j++)
	    {
	    	minn=b[1];
	    	wei=1;
	    	for(int k=2;k<=m;k++)
	    	{
	    	if(minn>b[k])
	    	minn=b[k],wei=k;
			}
			b[wei]+=a[j];
		}
		print();
		//getchar();
	}
	printf("%.2lf",anss);
}
```
ps:如果你有几个点WA了，建议洗把脸，重新试一次。

---

## 作者：JMercury (赞：4)

首先先把题目解释一下。。。

题意是，把n个数以分为m组，计算每一组的和，求得到的这m个数的方差。由于分法是任意的，我们要求这些方差中的最小值

我是先做了[P2210 Haywire](https://www.luogu.org/problemnew/show/P2210)以后再做的。

首先给定一个序列，计算当前状态的最小方差的方法是，按照顺序加入，每次将数加入和最小的一个集合，最后计算方差。

那么改变答案的方法就是改变序列的顺序。这里我用到的是交换其中的两个数，如果答案变小了就更新，否则有一定概率保留，一定概率换回去。

那么附上AC代码

```cpp
#include<bits/stdc++.h>
const int maxn=25;
const int maxm=10;
using namespace std;

int n,m,a[maxn],s;
double ave;
double best,now;
double be[maxn],no[maxn];

double Calc()
{
    double num[maxm];
    memset(num,0,sizeof(num));
    for(int i=1;i<=n;i++)
    {
        int p=1;
        for(int j=1;j<=m;j++)
            if(num[j]<num[p]) p=j;
        num[p]+=no[i];
    }
    double tmp=0;
    for(int i=1;i<=m;i++) tmp+=(num[i]-ave)*(num[i]-ave);
    return sqrt((double)tmp/m);
}

int main()
{
    srand(time(0)),srand(rand());
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]),no[i]=be[i]=a[i],s+=a[i];
    ave=(double)s/m;
    best=Calc();
    for(int t=1;t<=30;t++)
    {
        now=best;
        for(int i=1;i<=n;i++) no[i]=be[i];
        for(double dt=100000;dt>=1e-14;dt*=0.97)
        {
            int x=rand()%n+1,y=rand()%n+1;
            while(y==x) y=rand()%n+1;
            swap(no[x],no[y]);
            double tmp=Calc();
            if(tmp<best)
            {
                best=tmp;
                for(int i=1;i<=n;i++) be[i]=no[i];
            }
            if(tmp<now || (double)(tmp-now)/dt<(double)rand()/RAND_MAX) now=tmp;
            else swap(no[x],no[y]);
        }
    }
    printf("%.2f",best);
    return 0;
}
```

---

## 作者：SIGSEGV (赞：3)

其实用不着dp的，纯模拟退火就可以A掉本题

(调参数让我累死)


%你退火步骤：
> 每次随机更改一个数的分组，然后计算答案

其他的步骤和普通模拟退火一样（这份代码其实有个bug，但不影响最终出的解）

~~我是非洲大酋长~~
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,a[25],grp[25],sum[25];//a:数字 grp:对应的组的编号 sum：组里数字的和
double ans,avg;//avg:均值 
const double d = 0.992;
double get_val() //计算答案
{
    double val = 0;
    for (int i = 1;i <= m;i++) 
        val += (sum[i] - avg) * (sum[i] - avg);
    return val / m;//最后开方
}
void ch_grp(int pos,int target) //将第pos个数的分组改为target
{
    sum[grp[pos]] -= a[pos];
    sum[target] += a[pos];
    grp[pos] = target;
}
void SA() //模拟退火
{
    double T = 3000,cur_ans = ans;
    while (T > 1e-10)
    {
        int pos = rand() % n + 1,target = rand() % m + 1;
        int origin = grp[pos]; 
        ch_grp(pos,target);
        double nans = get_val(),diff = nans - cur_ans;
        if (diff < 0)
        {
            cur_ans = nans;if (cur_ans < ans) ans = cur_ans;
        }
        else if (RAND_MAX * exp(-diff / T) <= rand()) ch_grp(pos,origin);//如果取新解失败就换回去
        T *= d;
    }
}
int main ()
{
    srand(time(0));
    scanf("%d%d",&n,&m);
    for (int i = 1;i <= n;i++) 
    {
        scanf("%d",&a[i]);avg += a[i];
    }
    avg /= m;
    for (int i = 1;i <= n;i++)
    {
        grp[i] = rand() % m + 1;sum[grp[i]] += a[i];
    }
    ans = get_val();
    for (int i = 1;i <= 1000;i++) SA();
    printf("%.2lf",sqrt(ans));
    return 0;
}
```

### 跑1000遍SA也没有TLE。。。

### 附：bug就是可能会出现一组里没有任何数的情况

---

## 作者：critnos (赞：3)

怎么说呢……模拟退火是很有趣的一类题目。

这道题结合了模拟退火和贪心。

有一种假的贪心方法：对这个数组扫过去，每个数放到当前和最小的一组里面。

对于这种贪心方法，我发现，用来做模拟退火的估价函数很合适！

就是这个伢子：

```cpp
double ask()
{
	int q[25]={0},i,j,w,mn;
	double sum=0;
	for(i=0;i<n;i++)
	{
		mn=1e9;
		for(j=0;j<m;j++)
			if(q[j]<mn)
				mn=q[j],w=j;
		q[w]+=a[i];
	}
	for(i=0;i<m;i++)
		sum+=(xx-q[i])*(xx-q[i]);
	return sqrt(sum/m);
}
```
M_sea 姐姐用的是随机贪心，就是每次随机打乱数组。用模拟退火珂能比随机打乱好些。

直接从 P3878	[TJOI2010]分金币 改过来的……几乎没调参

唯一要说的，就是最后一个点不太友好，执行 $1000$ 次 SA 不一定能过。

所以，珂以卡时限。

因为%你退火运行越多次，得出正确解的概率越高，运行时常也越长。所以让程序压着时限过就行。

就可以用这个卡时间神器：

```cpp
while(clock()<900000)
	SA();
```
这样可以让程序运行到大约 $900$ms 的时候结束。至于为什么是 $900000$ 而不是 $900$ 还有待考究。在洛谷上让时间 $\times 1000$（ms）就行。

UPD：当天：https://www.luogu.com.cn/discuss/show/213037

> linux下1000000为1s——@AK新手村 

感谢神仙@AK新手村

同时可以使用 `CLOCKS_PER_SEC`。同样是 $1s$。


```cpp
#include<bits/stdc++.h>
using namespace std;
int a[25];
int n,m;
double mn=1e9,xx;
const double o=0.95,e=1e-8;
double ask()
{
	int q[25]={0},i,j,w,mn;
	double sum=0;
	for(i=0;i<n;i++)
	{
		mn=1e9;
		for(j=0;j<m;j++)
			if(q[j]<mn)
				mn=q[j],w=j;
		q[w]+=a[i];
	}
	for(i=0;i<m;i++)
		sum+=(xx-q[i])*(xx-q[i]);
	return sqrt(sum/m);
}
void SA()
{
	double s=3000,ans;
	int w1,w2;
	for(;s>e;s*=o)
	{
		w1=rand()%n,w2=rand()%n;
		swap(a[w1],a[w2]);
		ans=ask();
		if(ans<mn)
			mn=ans;
		else if(exp((ans-mn)/s)*RAND_MAX<rand())
			swap(a[w1],a[w2]);
	}
}
int main()
{
	srand(time(0));
	int i;
	cin>>n>>m;
	for(i=0;i<n;i++)
	{
		cin>>a[i];
		xx+=a[i];
	}
	xx/=m;
	while(clock()<900000)
		SA();
	printf("%.2f",mn);
} 
```
改完之后一遍稳过。

更新后的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[25];
int n,m;
double mn=1e9,xx;
const double o=0.95,e=1e-8;
double ask()
{
	int q[25]={0},i,j,w,mn;
	double sum=0;
	for(i=0;i<n;i++)
	{
		mn=1e9;
		for(j=0;j<m;j++)
			if(q[j]<mn)
				mn=q[j],w=j;
		q[w]+=a[i];
	}
	for(i=0;i<m;i++)
		sum+=(xx-q[i])*(xx-q[i]);
	return sqrt(sum/m);
}
void SA()
{
	double s=3000,ans;
	int w1,w2;
	for(;s>e;s*=o)
	{
		w1=rand()%n,w2=rand()%n;
		swap(a[w1],a[w2]);
		ans=ask();
		if(ans<mn)
			mn=ans;
		else if(exp((ans-mn)/s)*RAND_MAX<rand())
			swap(a[w1],a[w2]);
	}
}
int main()
{
	srand(time(0));
	int i;
	cin>>n>>m;
	for(i=0;i<n;i++)
	{
		cin>>a[i];
		xx+=a[i];
	}
	xx/=m;
	while(clock()<CLOCKS_PER_SEC*0.9)
		SA();
	printf("%.2f",mn);
} 
```


---

## 作者：G_A_TS (赞：1)

题解同步发布于[blog](https://www.cnblogs.com/wzzorz/articles/10364306.html)  

------------
**模拟退火**套**dp**  
关于基础的模拟退火[欢迎来踩blog](https://www.cnblogs.com/wzzorz/articles/10360087.html)  
代码正确时交两次A两次(种子随机)  
~~Woc这不是mo你退火的风格啊嘎嘎嘎~~  
看我那篇博文的平衡点辛酸史。。。  
这道题其实就是**连续**分组，**用模拟退火打乱**不就随机了吗？  
然后就只有计算稍微难一点了(描述对一个初二蒟蒻相当不友好啊喂！**(σ｀д′)σ** )  
最后放出代码

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,A[30],s[30];
double xs=0.95;//降温系数
double ans=1000000000,qwq,dp[30][30];
double calc()
{
	for(int i=0;i<=n;i++)
	{
		for(int j=0;j<=m;j++)
		{
			dp[i][j]=10000;
		}
	}
	for(int i=1;i<=n;i++)
	{
		s[i]=s[i-1]+A[i];
	}
	dp[0][0]=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=i;j++)
		{
			for(int k=0;k<i;k++)
			{
				dp[i][j]=min(dp[i][j],dp[k][j-1]+(s[i]-s[k]-qwq)*(s[i]-s[k]-qwq));
			}		
		}
	}
	ans=min(ans,dp[n][m]);
	return dp[n][m];
}
int SA()//模拟退火
{
	double t=10000,now=ans;
	while(t>0.0001)
	{
		int x=rand()%n+1,y=rand()%n+1;//随机匹配
		swap(A[x],A[y]);
		double res=calc();
		double ch=res-now;
		if(ch<0||exp(-ch)/t>(double)(rand()%100/100.00))
		{
			now=res;
		}
		else
		{
			swap(A[x],A[y]);
		}
		t*=xs;
	}
}
int main()
{
	srand(time(NULL));//随机种子
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>A[i];
		qwq+=1.0*A[i]/m;
	}
	calc(); 
	while((double)clock()/CLOCKS_PER_SEC<0.8)//卡时限
	{
		SA();
	}
	printf("%.2lf",sqrt(ans/m));
}
```

---

## 作者：HTensor (赞：1)

水题。。。

看起来很玄妙，实际上每次随机打乱序列，贪心一下就过了。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <ctime>

using namespace std;

int n, m, a[105], b[105];
double ans = 0x3f3f3f3f, pj = 0;

int main() {
    srand((unsigned)time(NULL));
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i]; pj += a[i];
    }
    pj = (double)pj / (double)m;
    for (int i = 1; i <= 500000; ++i) {
        random_shuffle(a + 1, a + n + 1);
        memset(b, 0, sizeof(b));
        for (int j = 1; j <= n; ++j) {
            int mn = 1;
            for (int k = 2; k <= m; ++k)
                if (b[mn] > b[k]) mn = k;
            b[mn] += a[j];
        } double sum = 0;
        for (int j = 1; j <= m; ++j) sum += (double)(b[j] - pj) * (double)(b[j] - pj);
        sum = (double)sum / (double)m; if (sum < ans) ans = sum;
    } printf("%.2lf", sqrt(ans)); return 0;
}
```


---

## 作者：Agakiss (赞：1)

[原题地址](https://www.luogu.org/problemnew/show/P2503)

比平衡点还裸的模拟退火模板题，但是窝就是不会打，

太菜了

n个数分m组，让方差最小，就是对于ai把ai放到最小的xi中（1<=x<=n）

对于n个数随机重组

退火很迷的我对着大佬的参数一个一个试下来（真开心嘤嘤嘤）

走好

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
int n,m,a[25],grp[25],sum[25];
double ans,avg;
const double d = 0.992;
double get_val()
{
    double val = 0;
    for (int i = 1;i <= m;i++) 
        val += (sum[i] - avg) * (sum[i] - avg);
    return val / m;
}
void ch_grp(int pos,int target)
{
    sum[grp[pos]] -= a[pos];
    sum[target] += a[pos];
    grp[pos] = target;
}
void SA()
{
    double T = 3000,cur_ans = ans;
    while (T > 1e-10)
    {
        int pos = rand() % n + 1,target = rand() % m + 1;
        int origin = grp[pos]; 
        ch_grp(pos,target);
        double nans = get_val(),diff = nans - cur_ans;
        if (diff < 0)
        {
            cur_ans = nans;if (cur_ans < ans) ans = cur_ans;
        }
        else if (RAND_MAX * exp(-diff / T) <= rand()) ch_grp(pos,origin);
        T *= d;
    }
}
int main ()
{
    srand(time(0));
    scanf("%d%d",&n,&m);
    for (int i = 1;i <= n;i++) 
    {
        scanf("%d",&a[i]);avg += a[i];
    }
    avg /= m;
    for (int i = 1;i <= n;i++)
    {
        grp[i] = rand() % m + 1;sum[grp[i]] += a[i];
    }
    ans = get_val();
    for (int i = 1;i <= 1000;i++) SA();
    printf("%.2lf",sqrt(ans));
    return 0;
}
```
放弃吧，假的参数，我才不会给你真的呢。

---


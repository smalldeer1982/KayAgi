# [JSOI2008] 球形空间产生器

## 题目描述

有一个球形空间产生器能够在 $n$ 维空间中产生一个坚硬的球体。现在，你被困在了这个 $n$ 维球体中，你只知道球面上 $n+1$ 个点的坐标，你需要以最快的速度确定这个 $n$ 维球体的球心坐标，以便于摧毁这个球形空间产生器。

## 说明/提示

提示：给出两个定义：

1. 球心：到球面上任意一点距离都相等的点。
2. 距离：设两个 $n$ 维空间上的点 $A,B$ 的坐标为 $(a_1, a_2, \cdots , a_n), (b_1, b_2, \cdots , b_n)$，则 $A,B$ 的距离定义为：$dist = \sqrt{ (a_1-b_1)^2 + (a_2-b_2)^2 + \cdots + (a_n-b_n)^2 }$。


## 样例 #1

### 输入

```
2
0.0 0.0
-1.0 1.0
1.0 0.0```

### 输出

```
0.500 1.500```

# 题解

## 作者：Gary818 (赞：217)

## A Solution For P4035 Problem ##
写了两天终于搞懂了！！！  
坚持写小白都能看懂的题解！！！  
  
说实话，本蒟蒻是第一次学习高斯消元，写这篇题解旨在加深自己的理解，以及帮助一下打算学习高斯消元的同学。  
以下一部分来自李煜东老师的《算法竞赛——进阶指南 0x35》（详见P155）



* ## 什么是高斯消元  
高斯消元是一种求解线性方程组的方法。  
所谓线性方程组，是由M个N元一次方程共同构成的。  
我们可以利用每个方程的所有系数及等号右侧的常数，  
写成一个M行N+1列的“**增广矩阵** ”。  
然后对这个矩阵进行一系列操作得到方程组的解所用到的方法  
我们称之为：高斯消元  
* ## 举个栗子 ##
给定一个三元一次方程组：  
$ x_1+2x_2-x_3=-6 $  
$ 2x_1+x_2-3x_3=-9 $  
$ -x_1-x_2+2x_3=7 $   
变形为增广矩阵：  
![](https://cdn.luogu.com.cn/upload/pic/61850.png)
凑活着看吧，不太精通Markdown和LaTeX（抱歉了，客官们~）  
求解这种增广矩阵我们有三种操作：  
1.用一个非零的数乘上某一行。  
2.把其中的一行的若干倍加到另一行上。  
3.交换两行的位置。  
这三种操作呗称作叫初等行变换  
同样的，我们可以定义初等列变换  
那么上面的表格就动了起来，像这样  
![](https://cdn.luogu.com.cn/upload/pic/61845.png)  


![](https://cdn.luogu.com.cn/upload/pic/61847.png)  


![](https://cdn.luogu.com.cn/upload/pic/61848.png)


![](https://cdn.luogu.com.cn/upload/pic/61849.png)


![](https://cdn.luogu.com.cn/upload/pic/61867.png)


![](https://cdn.luogu.com.cn/upload/pic/61867.png)

至此，我们最后得到的是“**阶梯型矩阵**”  
该矩阵表达的是：  
$ x_1+2x_2-x_3=-6 $  
$ x_2+x_3=1 $  
$ x_3=3 $  
我们已经知道了$ x_3 $的值，所以能够代入求解  
如果我们对方程组进一步化简，能够得到下面的表格：  
![](https://cdn.luogu.com.cn/upload/pic/61868.png)

最后： 
![](https://cdn.luogu.com.cn/upload/pic/61869.png)  
这个最终的矩阵叫“**简化阶梯型矩阵**”  
引出定义：  
**通过初等行变换把增广矩阵变为简化阶梯型矩阵的线性方程组求解算法就是高斯消元算法**  
* ## 特例 ## 
$ x_1+2x_2-x_3=3 $  
$ 2x_1+4x_2-8x_3=0 $  
$ -x_1-2x_2+6x_3=2 $  
对这个方程组手模一遍（懒得打表了QAQ）得到：  
$ x_1=4-x_2 $  
$ x_3=1 $  
可见，$ x_2 $取任何值都有一个对应的$x_1$，并且使原方程组成立  
也就是说，该方程组有无穷多个解  
我们把$x_1,x_3$这样的未知量称为“**主元**”  
而$x_2$叫“**自由元**”  

**综上所述，可以大致分为三种情况：**   
**1.高斯消元完成后，若存在系数全为0、常数不为0的行，则方程组无解。**  
**2.若系数不全为0的行恰好有$n$个，则主元有$n$个，方程组有唯一解。**  
**3.若系数不全为0 的行有$k<n$个，则主元有$k$个，自由元有$n-k$个，方程组有无穷多个解  **  

到这里，我们的基础知识就讲完了，你，看懂了吗？  


------------

* ## 来看例题[P4035球形空间产生器](https://www.luogu.org/problemnew/show/P4035)  
一个球体上的所有点到球心距离相等，因此我们只需求出一个点（$x_1,x_2,x_3……x_n$），使得：  
$  \sum_{j=0}^{n} $ $ (a_{i,j}-x_j)^2=C $  
其中C为常数，$a_{i,j}$是点的坐标。  
改方程组由$n+1$个$n$元二次方程构成，当然不是线性的，怎么办呢？？  
我们可以通过相邻两个方程做差，变成$n$个$n$元一次方程组，消去常数C  
有点像数学中数列求通项公式或者前$n$项和  
于是有：  
$ \sum_{j=1}^{n} $ $ (a_{i,j}^2-a_{i+1,j}^2-2x_j(a_{i,j}-a_{i+1,j}))=0 $  
把变量放左边，常数放右边：  
$ \sum_{j=1}^{n} $ $ 2(a_{i,j}-a_{i+1,j})x_j$ = $ \sum_{j=1}^{n}(a_{i,j}^2-a_{i+1,j}^2)$  $ (i=1,2,3……n) $
    
    
so,我们要对这个增广矩阵进行高斯消元：  
![](https://cdn.luogu.com.cn/upload/pic/61894.png)


下面就是代码时间啦：
```cpp
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <cstring>
#include <cmath>
using namespace std;

inline int read(){
	int x=0,w=1;
	char ch=getchar();
	for(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') w=-1;
	for(;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';
	return x*w;
}

double a[20][20],b[20],c[20][20];//c:矩阵系数  b:常数  两者构成增广矩阵  
int n;

int main(){
	n=read();
	for(int i=1;i<=n+1;i++)
		for(int j=1;j<=n;j++)
			scanf("%lf",&a[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			c[i][j]=2*(a[i][j]-a[i+1][j]);
			b[i]+=a[i][j]*a[i][j]-a[i+1][j]*a[i+1][j];
		}
	//高斯消元（数据保证有唯一解）
	for(int i=1;i<=n;i++){//找到x[i]系数不为0的一个方程
		for(int j=i;j<=n;j++){
			if(fabs(c[j][i]>1e-8)){
				for(int k=1;k<=n;k++)
					swap(c[i][k],c[j][k]);
				swap(b[i],b[j]);
			}
		}
	//消去其他方程x[i]的系数
		for(int j=1;j<=n;j++){
			if(i==j) continue;
			double rate=c[j][i]/c[i][i];
			for(int k=i;k<=n;k++) c[j][k]-=c[i][k]*rate;
			b[j]-=b[i]*rate;
		}
	}
	for(int i=1;i<n;i++)
		printf("%0.3lf ",b[i]/c[i][i]);
	printf("%.3lf\n",b[n]/c[n][n]);
	return 0;
}
```
emmmm，终于写完啦，希望讲懂了（逃~
    
    


---

## 作者：Memory_of_winter (赞：38)

[我的博客](https://www.cnblogs.com/Memory-of-winter/p/10054140.html)

**题目大意：** 给你$n$个点坐标，要你求出圆心

**题解：** 随机化，可以随机一个点当圆心，然后和每个点比较，求出平均距离$r$，如果到这个点的距离大于$r$，说明离这个点远了，就给圆心施加一个向这个点的力；若小于$r$，说明近了，就施加一个远离这个点的力。所有点比较完后，把假设的圆心按合力方向移动一个距离，距离和当前温度有关。时间越久，温度越低

**卡点：** 第$8$个点精度总是不够，拼命调参，调好后第$3$个点就$Tle$了，最后卡时过的



**C++ Code：**
```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <ctime>
#define maxn 12
int n;
struct Point {
	double x[maxn], w;
	inline friend Point operator + (const Point &lhs, const Point &rhs) {
		Point res;
		for (register int i = 0; i < n; i++) res.x[i] = lhs.x[i] + rhs.x[i];
		return res;
	}
	inline friend Point operator - (const Point &lhs, const Point &rhs) {
		Point res;
		for (register int i = 0; i < n; i++) res.x[i] = lhs.x[i] - rhs.x[i];
		return res;
	}
	inline void operator /= (const int &rhs) {
		for (register int i = 0; i < n; i++) x[i] /= rhs;
	}
} s[maxn], ans;

inline double sqr(double x) {return x * x;}
inline double abs(const Point &O) {
	double res = 0;
	for (int i = 0; i < n; i++) res += sqr(O.x[i]);
	return sqrt(res);
}
inline double dis(Point O) {
	double res = 0;
	for (int i = 0; i <= n; i++) res += abs(O - s[i]);
	return res;
}

const double ST = 5000, delT = 0.99995, eps = 1e-5;
const int Tim = 1, __Tim = 250000;
double V[maxn];
void SA() {
	double T = ST;
	while (T > eps) {
		double sum = dis(ans) / (n + 1);
		for (int i = 0; i < n; i++) {
			V[i] = 0;
			for (int j = 0; j <= n; j++) {
				V[i] += (abs(ans - s[j]) - sum) * (s[j].x[i] - ans.x[i]);
			}
			V[i] /= n + 1;
		}
		for (int i = 0; i < n; i++) {
			ans.x[i] += T * V[i];
		}
		T *= delT;
	}
	for (int Tim = 0; Tim < __Tim && 1. * clock() / CLOCKS_PER_SEC < .9; Tim++) {
		double sum = dis(ans) / (n + 1);
		for (int i = 0; i < n; i++) {
			V[i] = 0;
			for (int j = 0; j <= n; j++) {
				V[i] += (abs(ans - s[j]) - sum) * (s[j].x[i] - ans.x[i]);
			}
			V[i] /= n + 1;
		}
		for (int i = 0; i < n; i++) {
			ans.x[i] += T * V[i];
		}
	}
}

int main() {
	scanf("%d", &n);
	for (int i = 0; i <= n; i++) {
		for (int j = 0; j < n; j++) scanf("%lf", s[i].x + j);
		ans = ans + s[i];
	}
	ans /= n + 1;
	for (int i = 0; i < Tim; i++) SA();
	for (int i = 0; i < n; i++) {
		 printf("%.3lf", ans.x[i]);
		 putchar(i == n - 1 ? '\n' : ' ');
	}
	return 0;
}
```


---

## 作者：a2956331800 (赞：31)

# 17次提交终于调好参的爬山

这个题模拟退火的做法我觉得还是比较显然的。十分粗暴思路就是每次迭代求ans和每个点的距离，把距离取平均值；取完之后依次处理每个点，如果这个点和ans的距离大于平均值，就把ans往它拉，否则反方向推；拉或推的距离根据两个点每一维坐标的差值定。把每个点给ans的移动加和之后乘T（类似模拟退火的T）加到ans上

然后就是注意事项

ans和每个的点的距离每次迭代**只求一次**并存下来，后面直接用（可以优化掉一个n来增加次数）

T要从一个比较大的数（为了开始时ans能尽快移动到圆心附近）到小于精度的数（保证答案精度），迭代次数尽量多（就是不TLE的情况下T每次乘的数尽量接近1）（具体看代码）

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;

struct point
{
    double num[11];
};
point p[12],ans,delta;

int n,i,j;

double dist(point a,point b)
{
    double ret=0;
    for(int i=1;i<=n;i++)
      ret+=(a.num[i]-b.num[i])*(a.num[i]-b.num[i]);
    return sqrt(ret);
}

double dis[12];

int main()
{
    cin>>n;
    for(i=1;i<=n+1;i++)
      for(j=1;j<=n;j++)
        cin>>p[i].num[j],ans.num[j]+=p[i].num[j]/(n+1);
    for(double T=10000;T>=0.0001;T*=0.9999)//核心部分
    {
        double ave=0;
        for(i=1;i<=n+1;i++)
          dis[i]=dist(ans,p[i]),ave+=dis[i];
        ave/=n+1;
        for(i=1;i<=n;i++)
          delta.num[i]=0;
        for(i=1;i<=n+1;i++)
          for(j=1;j<=n;j++)
            delta.num[j]+=(dis[i]-ave)*(p[i].num[j]-ans.num[j])/ave;
        for(i=1;i<=n;i++)
          ans.num[i]+=delta.num[i]*T;
    }
    for(i=1;i<=n;i++)
      printf("%0.3f ",ans.num[i]);
    return 0;
}
```

---

## 作者：YoungLove (赞：20)


[Youngsc](https://youngscc.github.io/)

**一道~~赤果果~~的高斯消元**

**把球心的$n$维坐标设成$n$个变量，但是数据给了$n+1$个方程**

**根据出题人从来不会多给任何数据的经验，再加上仅凭着$n$个变量并不能得到完整的方程**

**因此我们要再设一个变量$r$,表示这个高维球体的半径**

**(蒟蒻的大脑无法想象高维空间暂且理解为半径)。**

**然后由距离公式$r=\sqrt{\sum_{i=1}^n(a_i-b_i)^2}$可得**

**$\sum_{i=1}^n(a_i-b_i)^2= r^2$  其中$a\_i$是高维球面上某一个点的坐标，$b\_i$是球心的坐标。**

**化简得 $\sum_{i=1}^n({a_i}^2-2a_ib_i+{b_i}^2)=r^2$ **  

**移项得$\sum_{i=1}^n(-2a_ib_i)+\sum_{i=1}^n{b_i}^2-r^2=\sum_{i=1}^n({-a_i}^2)$**

**其中$\sum_{i=1}^n{b_i}^2-r^2$与球面上的点无关，因此我们可以将其看做一个系数为$1$的变量，右边是常量**

**然后我们就成功的得到了$n+1$个$n+1$项的方程组，然后高斯消元解方程组就可以了**


```cpp
# include <bits/stdc++.h>
# define R register
# define LL long long
# define eps 1e-8
# define db double
using namespace std;
 
int n;
db a[13][13];
 
template <typename T> inline void in(R T& a){
    R char c=getchar();R T x=0,f=1;
    while(!isdigit(c)){if(c=='-') f=-1; c=getchar();}
    while(isdigit(c)) x=(x<<1)+(x<<3)+c-'0',c=getchar();
    a=x*f;
}
 
template <typename T> inline T ab(R T& a){return a<0? -a:a;}
 
inline void gauss(){
    for(R int i=1; i<=n; ++i){
        R int k=i;
        for(R int j=k+1; j<=n; ++j) if(ab(a[k][i])<ab(a[j][i])) k=j;
        swap(a[i],a[k]);
        for(R int j=i+1; j<=n+1; ++j) a[i][j]/=a[i][i];
        a[i][i]=1.0;
        for(R int j=1; j<=n; ++j){
            if(i==j) continue;
            for(R int k=i+1; k<=n+1; ++k) a[j][k] -= a[j][i]*a[i][k];
            a[j][i] = 0;
        }
    }
}
 
int main(){
    // freopen("heoi2016_sort.in","r",stdin);
    // freopen("heoi2016_sort.out","w",stdout);
    scanf("%d",&n); n++;
    for(R int i=1; i<=n; ++i)
    {
        for(R int j=1; j<n; ++j)
            scanf("%lf",&a[i][j]),a[i][n+1]-=a[i][j]*a[i][j],a[i][j]*=-2.0;
        a[i][n] = 1;
    }
    gauss();
    for(R int i=1; i<n; ++i){
        printf("%.3lf",a[i][n+1]);
        if(i<n-1) printf(" ");
    }
    return 0;
}
```

---

## 作者：宁_缺 (赞：18)

## $\color{yellow}\text{祭第三次没用SA做标签中有模拟退火的题目}$

昨天晚上八点左右看到这题，首先想到的方法：

对于当前球心，枚举到每个点的距离，近的对球心看做推力，远的看做拉力，然后按[$\color{blue}\text{P1337我的做法}$](https://www.luogu.com.cn/blog/ytxnqwl/solution-p1337)，对合力**正交分解**，再向合力方向移动，移动距离不断缩小，小到一定程度时结束

但是，我只学过二维的正交分解，**n维**怎么办呢？

按照二维的方法推，那么n维的仍是将斜边转换成直边，不过斜边有所不同，要抽象一点，比如四维中的一条直线（但我我实在想象不出来w,x,y,z轴互相垂直的样子），将它向w、x、y、z轴各做一条垂线就行了，公式是lon/dis*x[i]，其中lon是斜边长，dis是两点之间的距离，x[i]是两点在第i维的坐标之差

**lon的值赋为当前球心到该点的距离减去当前球心到各点的平均距离，这样就轻松解决了推力与拉力的问题**

$\color{red}\text{然后就发现了一个严峻的问题：两点重合怎么办？？？}$

理论分析这是会有较大的推力，但是dis为0，在力学中分析力为0，直接除会爆掉，否则又不知道方向

因为这个问题，我想到1点多，早上仍想不出来，换用**模拟退火**，发现**时间和正确率都很堪忧**，于是又回到这个问题上……

没办法，百度了这题，结果发现还真有用我这思路的，这位dalao的处理方式是**将上文中的dis改成了所有dis的平均值**，（dis平均值为0意味着所有点重合，题目保证有解，这种情况可以忽略）尽管这样一来我也说不出来这个公式变成了什么鬼东西，不过调大一点参数，就过掉了（~~反正不严谨就用时间换正确率嘛~~）

至于怎么移动的，应该能自己想出来，实在不行可以看下上面P1337题解的链接（蓝色字部分）

然后貌似也没啥好说的了，有不明白的结合代码理解吧
```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define E(x) ((x)*(x))
using namespace std;
int n;double z[12][12];
double w[12],r[12],d[12];
double lon=5000,g[12];
inline void mov(double l){
	memset(d,0,sizeof(d));
	memset(w,0,sizeof(w));
	double s=0.0,f=0.0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<n;j++)
			d[i]+=E(r[j]-z[i][j]);
	for(int i=1;i<=n;i++)
		d[i]=g[i]=sqrt(d[i]),s+=g[i];
	s/=(double)n;
	for(int i=1;i<=n;i++)g[i]-=s;
	for(int j=1;j<n;j++)
		for(int i=1;i<=n;i++)
			w[j]+=g[i]*(z[i][j]-r[j])/s;
	for(int j=1;j<n;j++)f+=E(w[j]);
	f=sqrt(f);if(!f)return;
	for(int j=1;j<n;j++)r[j]+=l/f*w[j];
}
int main(){
	scanf("%d",&n),n++;
	for(int i=1;i<=n;i++)
		for(int j=1;j<n;j++)
			scanf("%lf",&z[i][j]);
	while(lon>1e-11)
		mov(lon),lon*=0.999;
	for(int j=1;j<n;j++)
		printf("%.3lf ",r[j]);
	return 0*puts("");
}
```
$\color{red}\text{注：}$
```cpp
代码长：36行，858B(目前应该算很短的了）
用时：92~102ms
正确率:在当前数据中为100%
```


---

## 作者：_Lemon_ (赞：13)

[更好的阅读体验](https://www.cnblogs.com/Le-mon/p/9641230.html)

## Solution ##


这个题目N维的话确实不好想，反正三维就已经把我搞懵了，所以只好拿二维类比。

首先因为球心到边上的点距离相等，所以我们可以列出三个式子：

设 球心坐标为($x_0$，$y_0$)

$(x_1^2-x_0^2 )+(y_1^2-y_0^2)=r^2$

$(x_2^2-x_0^2 )+(y_2^2-y_0^2)=r^2$

$(x_3^2-x_0^2 )+(y_3^2-y_0^2)=r^2$

三个式子中都有r和平方项不好计算，所以我们用1式减2式，2式减3式，就得到两个式子：
$x_1^2-x_2^2-2x_1x_0+2x_2x_0+y_1^2-y_2^2-2y_1y_0+2y_2y_0=0$

$x_2^2-x_3^2-2x_2x_0+2x_3x_0+y_2^2-y_3^2-2y_2y_0+2y_3y_0=0$

而$x_1,y_1,x_2,y_2,x_3,y_3$都是已知的，可以看成常数项和系数。

再整理一下：

$2(x_2-x_1)x_0+2(y_2-y_1)y_0=x_2^2-x1^2+y_2^2-y_1^2$

$2(x_3-x_2)x_0+2(y_3-y_2)y_0=x_3^2-x2^2+y_3^2-y_2^2$

很明显一个二元一次方程组，然后使用高斯消元就可以求出球心。
这样就很容易推到N维了，这里就不一一写出，大家自己手推一下吧。~~主要是太麻烦了~~


### Coding ###



```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 105;
double s[N][N],ans[N],A[N][N];
int n,flag=1;
void Solve(int x)
{
  if(x==n){  ans[x]=s[x][n+1]/s[x][x]; return; }
  for(int i=x+1;i<=n;i++)
  {
    double box=abs(s[x][x])/abs(s[i][x]);
    if(s[x][x]*s[i][x]>0)
      for(int j=x;j<=n+1;j++)
        s[i][j]*=box,s[i][j]=s[i][j]-s[x][j];
    else
      for(int j=x;j<=n+1;j++)
        s[i][j]*=box,s[i][j]=s[i][j]+s[x][j];
  }
  Solve(x+1);
  for(int i=n;i>=x+1;i--)
  	s[x][n+1]-=(ans[i]*s[x][i]); 
  ans[x]=s[x][n+1]/s[x][x];
  return ;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n+1;i++)
        for(int j=1;j<=n;j++)
        scanf("%lf",&A[i][j]);
    for(int i=2;i<=n+1;i++)
        for(int j=1;j<=n;j++)
        {
            s[i-1][j]=2*(A[i][j]-A[i-1][j]);
            s[i-1][n+1]+=(A[i][j]*A[i][j]-A[i-1][j]*A[i-1][j]);
        }
    Solve(1);
    for(int i=1;i<=n;i++)
    printf("%.3lf ",ans[i]);
    return 0;
}
```

---

## 作者：浅色调 (赞：13)

### Solution：

　　我们所求的是$n$维的球心坐标，可以肯定的是$\forall i,i\in[1,n+1]$，都有$\sum\limits_{j=1}^{j\leq n}{(o_j-x_{ij})^2}=R^2$其中$o$为圆心、$R$是个常数代表半径。

　　题目中给了$n+1$个这样的式子，我们相邻的两式相减，就能得到$n$个消去了$R$的等式$\sum\limits_{j=1}^{j\leq n}{[(o_j-x_{ij})^2+(o_j-x_{i+1j})^2]}=0$，展开可以得到$\sum\limits_{j=1}^{j\leq n}{[2*o_j*(x_{ij}-x_{i+1j})]}=\sum\limits_{j=1}^{j\leq n}{(x_{ij}^2-x_{i+1j}^2)}$，等式左边我们直接作为$n$个$n$元方程，右边就是每个方程所对应的常数。

　　处理出这个$n$元方程组，直接高斯消元求解就好了。
  
$\;\;\quad$欢迎来踩博客：[five20](https://www.cnblogs.com/five20/p/9362948.html)（蒟蒻写题解不易，转载请注明出处，万分感谢！）

### 代码：
```cpp
#include<bits/stdc++.h>
#define il inline
#define ll long long
#define For(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)
#define Bor(i,a,b) for(int (i)=(b);(i)>=(a);(i)--)
using namespace std;
const int N=25;
int n,now;
double a[N][N],b[N][N];

int main(){
    scanf("%d",&n);
    For(i,1,n+1) For(j,1,n) scanf("%lf",&b[i][j]);
    For(i,1,n) For(j,1,n) {
        a[i][j]=2*(b[i][j]-b[i+1][j]);
        a[i][n+1]+=(b[i][j]*b[i][j]-b[i+1][j]*b[i+1][j]);
    }
    For(i,1,n) {
        now=i;
        For(j,i+1,n) if(fabs(a[j][i])>fabs(a[now][i]))now=j;
        if(now!=i) For(j,i,n+1) swap(a[now][j],a[i][j]);
        For(k,i+1,n){
            double t=a[k][i]/a[i][i];
            For(j,i,n+1) a[k][j]-=a[i][j]*t;
        }
    }
    Bor(i,1,n){
        For(j,i+1,n) a[i][n+1]-=a[j][n+1]*a[i][j];
        a[i][n+1]/=a[i][i];
    }
    For(i,1,n) printf("%.3lf ",a[i][n+1]);
    return 0;
}
```

---

## 作者：FriedrichC (赞：9)

[题目传送门](https://www.luogu.com.cn/problem/P4035)

## 命题分析
对于这样一个求 $n$ 维球心坐标的问题，很显然的，通过归纳论证我们便可以得知：

只要我们知道 $n+1$ 个球面上的点的坐标，我们就可以设圆心坐标，设圆的半径，然后通过这 $n+1$ 个点到圆心的**欧式距离**相等，就可以列出 $n+1$ 个方程求解出这 $n+1$ 个未知数。

事实证明，以上做法是可行的。

## 算法研究
但是，如果我们换一个思路，这样一个求**圆心**的问题十分类似于求一个**最优的平衡状态**或**最优的平衡点**的问题。

这就不由得让我们想起了随机化算法。

考虑这样一个问题，若随机选取圆上的一个点，那么我们是否有**能行性**的方法判断该点离圆心的远近呢？答案是肯定的。（具体方法在后文介绍）

那么，假设我们有一个初步的解，我们当然可以判断要朝什么“方向”改变就可以让当前的解逼近圆心，得到最优解。

并且，注意这样一点，由于圆心是定点，点离圆心近或远是既定的，所以一个解远离或靠近圆心的过程，解和圆心之间的“差量”必然满足一个**单调性**的变化。

也就是说，“差量”的变化曲线，或者解的可量化的“优劣性”变化的曲线大致是一个**单峰函数**。

分析到此，我们发现随机化的算法看来确确实实是可行的，并且由于我们不用担心**局部最优解**影响我们答案的准确性，我们便可以使用**爬山算法**。

## 具体实现
具体来说，我们每次要怎么更新解呢？

我们用一个数组 $ans$ 记录最终解，用二维数组 $a$ 记录点坐标。

首先初始化，初始化解为各个给定点的**重心**（其各维坐标均为所有给定点对应维度坐标的平均值）。

对于当前的解，求出每个点到当前解的欧式距离，用 $dis$ 数组记录，然后求所有距离的**平均值**，用 $sum$ 记录，因为圆心是到所有的点的欧式距离相等，所以每次爬山时解都要向着平均值靠拢。

我们用 $change$ 数组记录每一维度的解的更新值，由于解向着平均值靠拢，于是，**一个点贡献的**，解在**某一维度**上的更新值可以理解为该点和解的欧氏距离与平均值的**差值**在**该维**方向上的**投影**。

一般的，对于一个点 $i$，在 $j$ 维度上，我们有：

$change(j)=\dfrac{dis(i)-sum}{sum}\cdot (a(i,j)-ans(j))$

差值为正，说明距离大于平均值，解向正方向更新；差值为负，说明平均值大于距离，解向负方向更新。

这个过程可以形象地转化成一个新的球心，在空间里往返运动，如果离某个点太远，就往点的方向拉一点，反之就往点的反方向推一点。

最终解在某一维度的更新值就是每个点在此维度的更新值贡献之和。

即 $\sum\limits_{j=1}^{n}change(j)$

最后，在每一轮爬山结束后，将每个维度更新值乘以温度加到解的对应维度上就完成了一次更新。

## 附上代码
```cpp
#include<bits/stdc++.h>
#define MAX_TIME 0.995 //非常极限的卡时间 
using namespace std;
double ans[20],a[20][20],change[20],dis[20];
const double eps=1e-4;
int n;
inline void climb_hill()
{
	double sum=0;
	for(int i=1;i<=n+1;++i)
	{
		dis[i]=0;
		change[i]=0;
		for(int j=1;j<=n;++j)
			dis[i]+=(ans[j]-a[i][j])*(ans[j]-a[i][j]);
		dis[i]=sqrt(dis[i]);//求出每个点到当前解的欧式距离 
		sum+=dis[i];
	}
	sum/=(n+1);
	for(int i=1;i<=n+1;++i)
		for(int j=1;j<=n;++j)
			change[j]+=(dis[i]-sum)*(a[i][j]-ans[j])/sum;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n+1;++i)
		for(int j=1;j<=n;++j)
		{
			cin>>a[i][j];
			ans[j]+=a[i][j];
		}
	for(int i=1;i<=n;++i)ans[i]/=(n+1);
	double t=2000;
	while(t>eps&&(double)clock()/CLOCKS_PER_SEC<MAX_TIME)
	{
		climb_hill();
		for(int i=1;i<=n;++i)ans[i]+=change[i]*t;
		t*=0.99999;
		//t*=0.99997 是真正合适的降温参数 
	}
	for(int i=1;i<=n;++i)
		printf("%.3lf ",ans[i]);
	return 0;
}
```
## 一些细节
### 易错点
首先要说的就是，在具体代码实现的过程中，很容易一下子搞不清楚 $i$ 和 $j$ 这两个维度，导致写循环时数组写错下标。

那么需要注意的是：

- 只有坐标数组是二维的，其他全是一维数组。

- 在双层循环中 $i$ 维度指称点的下标，$j$ 维度指称坐标维度，所以前者循环至 $n+1$ 而后者至 $n$。

- 具体意义方面，$dis$ 数组只表示前一维，$change$ 数组和 $ans$ 数组只表示后一维，这在双层循环中可以看得很清楚。

那么根据上述几点，就很好判断下标写 $i$ 还是 $j$ 了。

### 关于卡时间
众所周知，对于爬山算法，**降温参数**和**初始温度**是至关重要的，参数太大就容易 `TLE` 太小了又容易 `WA`。

选取合适的常数真的是一门玄学，往往是没那么容易选中的，甚至要失败几十次，有时常数之间仅仅有 $10^{-5}$ 的误差，效果却千差万别。

这就是为什么类似的随机算法都需要**卡时技术**，这样就可以在时间允许的范围内尽量多的爬山/降温。而不用担心因为参数选择失误而导致错误，不用苦苦寻求一个精确无比的参数。

相关细节可以参考[此处](https://oi-wiki.org/misc/simulated-annealing/)，本文不再过多赘述。

上面的代码去掉卡时语句时，合适的降温参数大概是 $0.9997$，但这也是十次尝试之后才得来的结果，最终效果时间上是挺平均的。

效果如下：

![](https://s2.loli.net/2022/08/04/ZBXhq6pRgfz7y9F.png)

应用卡时之后的效果：

![](https://s2.loli.net/2022/08/04/aT7pRXCYrl1I8dz.png)

可以达到极限的 $999ms$。

总而言之，卡时技术，非常强大。


---

## 作者：HNFMS_Zbr (赞：6)

## [点击这里](https://blog.csdn.net/Zbr162/article/details/90680672)

<font size="6"> $$球型空间产生器$$ </font><br/>
___
<font size="6"> [$\mathcal{Description}$](https://www.luogu.org/problemnew/show/P4035) </font><br/>

有一个球形空间产生器能够在 $n$ 维空间中产生一个坚硬的球体。现在，你被困在了这个 n 维球体中，你只知道球面上 $n+1$ 个点的坐标，你需要以最快的速度确定这个 $n$ 维球体的球心坐标，以便于摧毁这个球形空间产生器。
$n <= 10$
___

<font size="6"> $\mathcal{Solution}$</font><br/>

题意: 求 $n$维点 $O$($a_1,a_2,...,a_n$), 使 $O$ 距离 球面上 $n+1$ 个点的 __距离相等__,

使用 式子 表示出来, 即
$$
(a_1-b_{1,1})^2+(a_2-b_{1,2})^2+...+(a_n-b_{1,n})^2=D^2\\
\ \\
(a_1-b_{2,1})^2+(a_2-b_{2,2})^2+...+(a_n-b_{2,n})^2=D^2\\
. \\
. \\
. \\
\ \\
(a_1-b_{n+1,1})^2+(a_2-b_{n+1,2})^2+...+(a_n-b_{n+1,n})^2=D^2
$$

相邻式子相减消去 $D^2$, 得到
$$
(2a_1-b_{1,1}-b_{2,1})(b_{2,1}-b_{1,1})+...+(2a_n-b_{1,n}-b_{2,n})(b_{2,n}-b_{1,n})=0\\
. \\
. \\
略
$$

发现已经是一个 **线性方程组** 了, 

__系数__ $$A[i,j]=2*(b[i+1,j]-b[i,j])$$
	
__常数__ $$A[i,n+1]=\sum_{j=1}^n \ (b[i,j] + b[i+1,j])\ *\ (b[i+1,j]-b[i,j])$$

**高斯消元** $O(N^3)$ 求解 .
___

<font size="6"> $\mathcal{Code}$</font><br/>
```cpp
#include<bits/stdc++.h>
#define reg register

const int maxn = 15;

int N;
double A[maxn][maxn];
double B[maxn][maxn];

int main(){
        scanf("%d", &N);
        for(reg int i = 1; i <= N+1; i ++)
                for(reg int j = 1; j <= N; j ++) scanf("%lf", &B[i][j]);
        for(reg int i = 1; i <= N; i ++){
                for(reg int j = 1; j <= N; j ++) A[i][j] = 2.0*(B[i+1][j] - B[i][j]);
                A[i][N+1] = 0;
                for(reg int j = 1; j <= N; j ++)
                        A[i][N+1] += (B[i][j]+B[i+1][j])*(B[i+1][j] - B[i][j]);
        } 
        for(reg int i = 1; i <= N; i ++){
                int max_id = i;
                for(reg int j = i+1; j <= N; j ++)
                        if(fabs(A[max_id][i]) < fabs(A[j][i])) max_id = j;
                std::swap(A[i], A[max_id]);
                double tmp = A[i][i];
                for(reg int j = i; j <= N+1; j ++) A[i][j] /= tmp;
                for(reg int j = i+1; j <= N; j ++){
                        tmp = A[j][i];
                        for(reg int k = i; k <= N+1; k ++)
                                A[j][k] -= A[i][k] * tmp;
                }
        }
        for(reg int i = N; i >= 1; i --)
                for(reg int j = i+1; j <= N; j ++) A[i][N+1] -= A[i][j]*A[j][N+1];
        for(reg int i = 1; i <= N; i ++) printf("%.3lf ", A[i][N+1]);
        return 0;
}

```


---

## 作者：FlashHu (赞：6)

[洛谷题目传送门](https://www.luogu.org/problemnew/show/P4035)

球啊球 ~~@[xzz_233](https://www.luogu.org/space/show?uid=23118) qaq~~

高斯消元模板题，关键在于将已知条件转化为方程组。

可以发现题目要求的未知量有$n$个，题目却给了我们$n+1$个点的坐标，这其中必有玄机。

由高中数学知识可以知道，三点定圆（二维），四点定球（三维）······以此类推，应该是$n+1$个点才能确定一个$n$维空间下的球。

那么隐藏的另一个关键未知量在哪里呢？

想想圆的标准方程$(x-x_0)^2+(y-y_0)^2=r^2$，除了圆心坐标，半径不也对这个圆起到决定性作用么？

接下来，额外设一个未知量——球的半径$r$，开始试着对条件式进行变换。

对于$n+1$个点，它们与球心的距离是定值$r$，那么我们可以得到形式如下的$n+1$个方程（a为球面点坐标，x为球心坐标）

$$(a_1-x_1)^2+(a_2-x_2)^2+···+(a_n-x_n)^2=r^2$$

显然我们要把已知量和未知量分开，于是展开，移项

$$a_1^2-2a_1x_1+x_1^2+a_2^2-2a_2x_2+x_2^2+···+a_n^2-2a_nx_n+x_n^2=r^2$$

$$2a_1x_1+2a_2x_2+···+2a_nx_n+r^2-x_1^2-x_2^2-···-x_n^2=a_1^2+a_2^2+···+a_n^2$$

发现$r^2-x_1^2-x_2^2-···-x_n^2$与$a$无关，所以考虑换元，设$t=r^2-x_1^2-x_2^2-···-x_n^2$（实际上我们并不用求$r$）

终于，我们可以看到一个关于$x_1,x_2,···,x_n,t$的$(n+1)$元方程组了，上高斯消元

具体实现看代码

```cpp
#include<cmath>
#include<cstdio>
#define R register
#define init for(i=1;i<=n;++i)ne[i-1]=pr[i+1]=i
const int N=19;
int p[N],pr[N],ne[N];
double a[N][N];
int main(){
    R int n,i,j,k,x;
    R double mx,d;
    scanf("%d",&n);++n;
    init;//链表初始化，为了实现交换行
    for(i=1;i<=n;++i){
        for(j=1;j<n;++j){
            scanf("%lf",&d);//处理系数
            a[i][j]=d*2;a[i][n+1]+=d*d;
        }
        a[i][n]=1;//t的系数为1
    }
    for(k=1;k<=n;++k){
        mx=0;//蒟蒻没有交换主元，而是交换行
                //这样做防掉精度的效果可能不如交换主元
        for(i=ne[0];i;i=ne[i])
            if(mx<fabs(a[i][k]))
                mx=fabs(a[i][k]),x=i;
        d=a[p[k]=x][k];//选择当前a最大的一行
        pr[ne[pr[x]]=ne[x]]=pr[x];
        for(j=1;j<=n+1;++j)
            a[x][j]/=d;
        for(i=ne[0];i;i=ne[i])
            for(d=a[i][j=k];j<=n+1;++j)
                a[i][j]-=d*a[x][j];
    }//高斯消元
    init;
    for(k=n;k;--k){
        d=a[x=p[k]][n+1];
        pr[ne[pr[x]]=ne[x]]=pr[x];
        for(i=ne[0];i;i=ne[i])
            a[i][n+1]-=d*a[i][k];
    }//回代
    for(k=1;k<n;++k)
        printf("%.3f ",a[p[k]][n+1]);
    puts("");
    return 0;
}
```

---

## 作者：Siyuan (赞：6)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io/articles/problem-JSOI-2008-Sphere-Space-Generator/)

---

## Description

> 题目链接：[Luogu 4035](https://www.luogu.org/problemnew/show/P4035)

有一个球形空间产生器能够在 $n$ 维空间中产生一个坚硬的球体。现在，你被困在了这个 $n$ 维球体中，你只知道球面上 $n+1$ 个点的坐标 $(x_{i,1},x_{i,2},\dots,x_{i,n})$，你需要以最快的速度确定这个 $n$ 维球体的球心坐标，以便于摧毁这个球形空间产生器。答案保留 $3$ 位小数。

数据范围：$1\le n\le 10$，$\vert x_{i,j}\vert\le 20000$

------

## Solution

得到 $n+1$ 个等式：
$$\begin{cases}(x_1-p_{1,1})^2+(x_2-p_{1,2})^2+(x_3-p_{1,3})^2+\cdots+(x_n-p_{1,n})^2=R^2 \\(x_1-p_{2,1})^2+(x_2-p_{2,2})^2+(x_3-p_{2,3})^2+\cdots+(x_n-p_{2,n})^2=R^2 \\\vdots \\(x_1-p_{n,1})^2+(x_2-p_{n,2})^2+(x_3-p_{n,3})^2+\cdots+(x_n-p_{n,n})^2=R^2 \\(x_1-p_{n+1,1})^2+(x_2-p_{n+1,2})^2+(x_3-p_{n+1,3})^2+\cdots+(x_n-p_{n+1,n})^2=R^2\end{cases}$$
然后用第 $n+1$ 个等式去消去前 $n$ 个等式的 ${x_i}^2$ 项，这样就得到了一个标准的 $n$ 元 $1$ 次方程组，直接高斯消元求出 $n$ 个未知数。

**时间复杂度**：$O(n^3)$

------

## Code

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>

const int N=15;
int n;
double p[N][N],a[N][N],b[N],x[N];

void Gauss(int n) {
	for(int i=1;i<=n;++i) {
		int p=i;
		for(int k=i+1;k<=n;++k) if(fabs(a[k][i])>fabs(a[p][i])) p=k;
		if(i!=p) std::swap(a[i],a[p]),std::swap(b[i],b[p]);
		for(int k=i+1;k<=n;++k) {
			double d=a[k][i]/a[i][i];
			b[k]-=d*b[i];
			for(int j=i;j<=n;++j) a[k][j]-=d*a[i][j];
		}
	}
	for(int i=n;i>=1;--i) {
		for(int j=i+1;j<=n;++j) b[i]-=x[j]*a[i][j];
		x[i]=b[i]/a[i][i];
	}
}
void init() {
	for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) {
		a[i][j]=2.0*(p[n+1][j]-p[i][j]),b[i]+=p[n+1][j]*p[n+1][j]-p[i][j]*p[i][j];
	}
}
int main() {
	scanf("%d",&n);
	for(int i=1;i<=n+1;++i) for(int j=1;j<=n;++j) scanf("%lf",&p[i][j]);
	init();
	Gauss(n);
	for(int i=1;i<=n;++i) printf("%.3lf%c",x[i]," \n"[i==n]);
	return 0;
}
```



---

## 作者：Refined_heart (赞：5)

蒟蒻第一个自己$A$掉的高斯消元紫题$qwq$因为刚刚学高斯消元，于是来写一篇题解。

题目大意：给定$n+1$个到目标点距离相同的点，求目标点的坐标。每个点都是$n$维的。

先想想咋把高斯消元套进去，那应该可以想到**把目标点的坐标设成未知数**。但是题目中给了$n+1$个点啊，这多出的一个应该怎么用呢？

别着急，待会就知道了。这也是在暗示，本题有$n+1$个未知数。

观察一下距离公式，我们可以自然想到把根号去掉。因为当$\sqrt{a}=\sqrt{b}$的时候，一定有$a=b$.

所以我们得到了一个这样形式的式子：设目标点的坐标为$x_1,x_2...x_n$,

$dist=\sqrt{\sum_{i=1}^{n+1}(a_i-x_i)^2}$,去掉根号有：

$dist^2=\sum_{i=1}^{n+1}(a_i-x_i)^2$.发现这个东东的每一项展开后，里面是有二次项的，$Guess$消元不能解。

先把它展开：

$dist^2=\sum_{i=1}^{n+1} a_i^2+x_i^2-2a_ix_i$

发现，对于每一个$i$,这个式子的$x^2$是相等的。

那么我们可以考虑消掉$x^2$.此时，我们已经无限接近正解了。

如果消掉，我们发现，我们不知道原有距离，而消去之后也会将原有距离修改。

上面那个$\sum_{i=1}^{n+1} a_i^2+x_i^2-2a_ix_i$,来转化一下：

消掉$x^2:$ $\sum_{i=1}^{n+1} a_i^2-2a_ix_i$

发现我们已知$a_i^2$.把它作为每一个式子的常数项，则继续化简为：

$\sum_{i=1}^{n+1} -2a_ix_i$

此时，$-2a_i$显然就是每一个未知数对应的系数了。

那，等号右边怎么写呢？

我们增设一个未知数$z$,使得$(\sum_{i=1}^{n+1} -2a_ix_i)+z=-\sum a_i^2$

这样我们就写好了方程。

那么，这个$z$，对于不一样的方程，它是不是一样呢？我们证明一下：

对于一般项：

$(\sum_{i=1}^{n+1} -2a_ix_i)+z=-\sum a_i^2$

移项，再加上每一个等式都相等的未知数平方得到：

$(\sum_{i=1}^{n+1} x^2-2a_ix_i+a_i^2)=-z$

由题意知，这样的每一个等式的左边都等于$dist^2$.故它们所对的等式右边也就相等了。

这也是为什么题目给了$n+1$个点，对应$n+1$个未知数。

讲到这里，题目一目了然了。

代码：

```cpp

#include<bits/stdc++.h>
using namespace std;
typedef double db;
int n;
db a[50][50];
db mp[50][50];
db ans[500];
db row[500];
const db eps=1e-7;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n+1;++i)
        for(int j=1;j<=n;++j)
            scanf("%lf",&a[i][j]);//输入对应坐标
    for(int i=1;i<=n+1;++i)
        for(int j=1;j<=n;++j)
            row[i]+=a[i][j]*a[i][j];//预处理ai方
    for(int i=1;i<=n+1;++i){
        for(int j=1;j<=n+2;++j){
            if(j!=n+2&&j!=n+1)mp[i][j]=-2*a[i][j];//未知数系数
            else if(j==n+1)mp[i][j]=1;//z的系数
            else mp[i][j]=-row[i];//等号右边
        }
    }
    n++;//方便处理
    for(int i=1;i<=n;++i){
        int r=i;
        for(int j=i+1;j<=n;++j)
            if(fabs(mp[r][i])<fabs(mp[j][i]))
                r=j;//找主元
        if(i!=r)swap(mp[i],mp[r]);//换一下，只处理当前行
        db div=mp[i][i];//系数化1的除数
        for(int j=i;j<=n+1;++j)mp[i][j]/=div;//系数化一
        for(int j=i+1;j<=n;++j){
            div=mp[j][i];//加减消元
            for(int k=i;k<=n+1;++k)mp[j][k]-=mp[i][k]*div;
        }
    }
    ans[n]=mp[n][n+1];//回带过程
    for(int i=n-1;i>=1;--i){
        ans[i]=mp[i][n+1];
        for(int j=i+1;j<=n;++j)ans[i]-=(mp[i][j]*ans[j]);
    }
    //注意n已经+1
    for(int i=1;i<n;++i)printf("%.3lf ",ans[i]);//前n个未知数解即为所求
    return 0;
}
```

---

## 作者：Yeji_ (赞：5)

## 球形空间产生器
### 前言
窝这个蒟蒻终于要来打模拟退火了（太菜了）

### 思路
我们可以非常清楚的知道，这题正解还是比较难想的，所以我们开始水分

但，正解还是要想一想的

嗯，这道题似乎是用高斯消元？？？（反正我不会）

然后水分，似乎是用模拟退火？？？

如果不会模拟退火的同学，那就可以去日报里学一学

这道题很显然的做法，随机乱搞出来一个点，然后就开始求和其他的几个点的距离

如果大了，就往里走，小了，就往外走，套一个模拟退火的模板就可以了，所以说还是比较水的了

### 代码
```cpp
#include<iostream>
#include<cstdio>
#define re register
#include<cmath>
using namespace std;
struct node
{
    double num[120];
};
node p[12],ans,now;
int n,i,j;double dis[12];
double dist(node a,node b)
{
    double hans=0;
    for (re int i=1;i<=n;i++)
      	hans+=(a.num[i]-b.num[i])*(a.num[i]-b.num[i]);
    return sqrt(hans);
}
int read()
{
    int ans=0,x=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
            x=-x;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        ans=(ans<<1)+(ans<<3)+(ch^48);
        ch=getchar();
    }
    return ans;
}
int main()
{
    n=read();

    for (re int i=1;i<=n+1;i++)
      	for (re int j=1;j<=n;j++)
      	{
      		cin>>p[i].num[j];
            ans.num[j]+=p[i].num[j]/(n+1);
        }   
    for(re double T=10005;T>=0.0001;T*=0.99997)
    {
        double ave=0;
        for (re int i=1;i<=n+1;i++)
          	dis[i]=dist(ans,p[i]),ave+=dis[i];
        ave/=n+1;
        for (re int i=1;i<=n;i++)
          	now.num[i]=0;
        for (re int i=1;i<=n+1;i++)
          	for (re int j=1;j<=n;j++)
            	now.num[j]+=(dis[i]-ave)*(p[i].num[j]-ans.num[j])/ave;
        for (re int i=1;i<=n;i++)
          	ans.num[i]+=now.num[i]*T;
    }
    for(re int i=1;i<=n;i++)
      	printf("%0.3f ",ans.num[i]);
}
```
这个精度就非常玄学，总是第8个点WA，调好第8个，2，3，4就超时了，所以说我才会把我的参数写上去

希望给大家一点帮助

---

## 作者：haiwenhan (赞：5)

**真的很裸的一道$Gauss$消元的题。**

题目的大概意思就是给你$n+1$个$n$维坐标 ($x_1$, $x_2$, ... , $x_3$)，它们都在一个n维球面上，让你计算出球心的坐标。

很容易就可以对于每一个坐标列出方程（设球心坐标为未知数$y_1$...$y_n$，球的半径为r）：

则对于一组$x_1$...$x_n$：$(x_1-y_1)^2+...+(x_n-y_n)^2=r^2$

对于另一组$x_1'$...$x_n'$：$(x_1'-y_1)^2+...+(x_n'-y_n)^2=r^2$

对于这两组看似很诡异的二次方程，但当你暴力展开$+$上下做差时，你会发现——未知数的二次项消掉了！！~~（真是令人惊讶）~~

$(x_1^2-x_1'^2+...+x_n^2-x_n'^2)-(2\cdot (x_1-x_1')\cdot y_1+...+2\cdot (x_n-x_n')\cdot y_n)=0$

然后，你发现左边的括号里是常数，右边括号里是一次的。你就可以相邻两式相互做差，然后Gauss消元了。$\color{lightgreen}\text{AC!}$

康康代码：

```
#include<bits/stdc++.h>
#define maxN 15
#define EPS (1e-8)//诡异的EPS
using namespace std;
int n;
double a[maxN][maxN];
void Gauss()//瓜斯小猿
{
	int i,j,k;
	for(i=1;i<=n;i++)
	{
		for(k=i;k<=n;k++)
			if(fabs(a[k][i])>EPS)
				for(j=1;j<=n+1;j++)
					swap(a[k][j],a[i][j]);
		for(k=1;k<=n;k++)
		{
			if(k==i||fabs(a[k][i])<=EPS) continue;
			double c=a[k][i]/a[i][i];
			for(j=1;j<=n+1;j++)
				a[k][j]-=c*a[i][j];
		}
	}
}
double pos[maxN][maxN];
int main()
{
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    int i,j;
    scanf("%d ",&n);
    for(i=1;i<=n+1;i++)
    	for(j=1;j<=n;j++)
    		scanf("%lf",&pos[i][j]);
    for(i=1;i<=n;i++)//处理小猿数组
    {
    	for(j=1;j<=n;j++)
    		a[i][j]=((pos[i+1][j]-pos[i][j])*2.0);
    	for(j=1;j<=n;j++)
    		a[i][n+1]-=pos[i][j]*pos[i][j]-pos[i+1][j]*pos[i+1][j];//常数项挪到等号另一边
    }
    Gauss();
    for(i=1;i<=n;i++)
    	printf("%.3lf ",(a[i][n+1]/a[i][i]));//输出答案，保证有解
    putchar('\n');
	return 0;
}
```cpp

---

## 作者：doctorZ_ (赞：4)

设球心的坐标为$(x_1,x_2\cdots x_n)$，球体的半径为$r$，$a_{i,j}$为第$i$个球体上的点的第$j$维坐标

根据球体的定义可得：
$$\sqrt{\sum\limits_{j=1}\limits^{n}(a_{i,j}-x_j)^2}=r(i\in [1,n])$$
即：
$$\sum\limits_{j=1}\limits^{n}(a_{i,j}-x_j)^2=r^2(i\in [1,n])$$
设$i_1,i_2(i_1\neq i_2,i_1\in[1,n],i_2\in[1,n])$    
由$\sum\limits_{j=1}\limits^{n}(a_{i,j}-x_j)^2=r^2(i\in [1,n])$得：
$$\sum\limits_{j=1}\limits^{n}(a_{i_1,j}-x_j)^2=\sum\limits_{j=1}\limits^{n}(a_{i_2,j}-x_j)^2$$
$$\sum\limits_{j=1}\limits^{n}(a_{i_1,j}^2-2a_{i_1,j}\cdot x_j+x_j^2)=\sum\limits_{j=1}\limits^{n}(a_{i_2,j}^2-2a_{i_2,j}\cdot x_j+x_j^2)$$
$$\sum\limits_{j=1}\limits^{n}(a_{i_1,j}^2-2a_{i_1,j}\cdot x_j)=\sum\limits_{j=1}\limits^{n}(a_{i_2,j}^2-2a_{i_2,j}\cdot x_j)$$
$$\sum\limits_{j=1}\limits^{n}a_{i_1,j}^2 -\sum\limits_{j=1}\limits^{n}2a_{i_1,j}\cdot x_j=\sum\limits_{j=1}\limits^{n}a_{i_2,j}^2 -\sum\limits_{j=1}\limits^{n}2a_{i_2,j}\cdot x_j$$
$$\sum\limits_{j=1}\limits^{n}2a_{i_1,j}\cdot x_j -\sum\limits_{j=1}\limits^{n}2a_{i_2,j}\cdot x_j=\sum\limits_{j=1}\limits^{n}a_{i_1,j}^2 -\sum\limits_{j=1}\limits^{n}a_{i_2,j}^2\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ $$
$$\sum\limits_{j=1}\limits^{n}2(a_{i_1,j}-a_{i_2,j})\cdot x_j =\sum\limits_{j=1}\limits^{n}(a_{i_1,j}^2 -a_{i_2,j}^2)\ \ \ \ \ \ \ \ \ $$
然后这就变成了一个线性方程       
由于一共有$n+1$个点，所以就可以组成一个线性方程组
$$\begin{cases}2(a_{1,1}-a_{2,1})\cdot x_1+2(a_{1,2}-a_{2,2})\cdot x_2+\cdots+2(a_{1,n}-a_{2,n})\cdot x_n=\sum\limits_{j=1}\limits^{n}(a_{1,j}^2 -a_{2,j}^2)\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \cdots\\2(a_{n,1}-a_{n+1,1})\cdot x_1+2(a_{n,2}-a_{n+1,2})\cdot x_2+\cdots+2(a_{n,n}-a_{n+1,n})\cdot x_n=\sum\limits_{j=1}\limits^{n}(a_{n,j}^2 -a_{n+1,j}^2)\end{cases}$$
最后用高斯消元求解即可
## $code:$
```cpp
#include<iostream>
#include<cstdio>
#define N 20
using namespace std;
int n;
long double a[N+1][N+1],powa[N+1],map[N+1][N+1];
long double X[N+1];
const long double eps=0.000000001;
long double Fabs(long double x)
{
	if(x<0)
		return -x;
	return x;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n+1;i++)
	{
		for(int j=1;j<=n;j++)
		{
			scanf("%Lf",&a[i][j]);
			powa[i]+=a[i][j]*a[i][j];
			if(i!=1)
				map[i-1][j]=2*(a[i-1][j]-a[i][j]);
		}
		if(i!=1)
			map[i-1][n+1]=powa[i-1]-powa[i];
	}
	for(int i=1;i<=n;i++)
	{
		int r=i;
		for(int j=i+1;j<=n;j++)
			if(Fabs(map[r][i])>Fabs(map[j][i]))
				r=j;
		swap(map[r],map[i]);
		long double div=map[i][i];
		for(int j=i;j<=n+1;j++)
			map[i][j]/=div;
		for(int j=i+1;j<=n;j++)
		{
			div=map[j][i];
			for(int k=i;k<=n+1;k++)
				map[j][k]-=map[i][k]*div;
		}
	}
	for(int i=n;i>=1;i--)
	{
		X[i]=map[i][n+1];
		for(int j=i+1;j<=n;j++)
			X[i]-=X[j]*map[i][j];
	}
	for(int i=1;i<=n;i++)
		printf("%.3Lf ",X[i]);
	return 0;
}
```


---

## 作者：破壁人五号 (赞：3)

[博客](https://wallbreaker5th.github.io/2018/%E9%A2%98%E8%A7%A3-P4035-JSOI2008-%E7%90%83%E5%BD%A2%E7%A9%BA%E9%97%B4%E4%BA%A7%E7%94%9F%E5%99%A8/)

洛谷题号：P4035

bzoj题号：1013

---

题目：

> ## Description

> 有一个球形空间产生器能够在n维空间中产生一个坚硬的球体。现在，你被困在了这个n维球体中，你只知道球
面上n+1个点的坐标，你需要以最快的速度确定这个n维球体的球心坐标，以便于摧毁这个球形空间产生器。

> ## Input

> 第一行是一个整数n(1<=N=10)。接下来的n+1行，每行有n个实数，表示球面上一点的n维坐标。每一个实数精确到小数点
后6位，且其绝对值都不超过20000。

> ## Output

> 有且只有一行，依次给出球心的n维坐标（n个实数），两个实数之间用一个空格隔开。每个实数精确到小数点
后3位。数据保证有解。你的答案必须和标准输出一模一样才能够得分。

> ## Sample Input

> > 2

> > 0.0 0.0

> > -1.0 1.0

> > 1.0 0.0

> ## Sample Output

> > 0.500 1.500

> ## HINT

> 提示：给出两个定义：1、 球心：到球面上任意一点距离都相等的点。

> 2、 距离：设两个n为空间上的点A, B的坐标为(a1, a2, …, an), (b1, b2, …, bn)，
则AB的距离定义为：$dist = \sqrt{(a1-b1)^2 + (a2-b2)^2 + ... + (an-bn)^2}$

---

这是一道高斯消元比较裸的题目了，除了板题以外这题是我AC的第一道高斯消元题目。

我们假设这N+1个点的坐标分别为：


$P_1    (a[1][1]  ,a[1][2]  ,...a[1][n])$

$P_2    (a[2][1]  ,a[2][2]  ,...a[2][n])$

$...$

$P_{n+1}(a[n+1][1],a[n+1][2],...a[n+1][n])$

圆心的坐标为：

$P_0(a[0][1]  ,a[0][2]  ,...a[0][n])$

那么$|P_1P_0|=|P_2P_0|=......=|P_{n+1}P_0|$

单独拿$|P_1P_0|=|P_2P_0|$出来：

- $|P_1P_0|=|P_2P_0|$

- $|P_1P_0|^2=|P_2P_0|^2$

- $(a[0][1]-a[1][1])^2+(a[0][2]-a[1][2])^2+...+(a[0][n]-a[1][n])^2$

$=(a[0][1]-a[2][1])^2+(a[0][2]-a[2][2])^2+...+(a[0][n]-a[2][n])^2$

- $a[0][1]^2-2a[0][1]a[1][1]+a[1][1]^2+...+a[0][n]^2-2a[0][n]a[1][n]+a[1][n]^2$

$=a[0][1]^2-2a[0][1]a[2][1]+a[2][1]^2+...+a[0][n]^2-2a[0][n]a[2][n]+a[2][n]^2$

- $2(a[1][1]-a[2][1])a[0][1]+2(a[1][2]-a[2][2])a[0][2]+...+2(a[1][n]-a[2][n])$

$=a[1][1]^2-a[2][1]^2+a[1][2]^2-a[2][2]^2+...+a[1][n]^2-a[2][n]^2$

（公式太长只能换行，为清楚用了无序列表）

也就是关于$a[0][1],a[0][2],...,a[0][n]$的一个线性方程，把$|P_1P_0|=|P_3P_0|,|P_1P_0|=|P_4P_0|,...,|P_1P_0|=|P_{n+1}P_0|$都转化一下，就可以得到一个线性方程组，用高斯消元就可以解出来。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=105;
double a[N][N+1];
bool u[N];
double x[N+1][N];
int main(){
	int n;
	cin>>n;
	cout<<fixed<<setprecision(3);
	for(int i=0;i<n+1;i++){
		for(int j=0;j<n;j++){
			cin>>x[i][j];
		}
	}
	for(int i=0;i<n;i++){//第i+1个点 
		for(int j=0;j<n;j++){
			a[i][j]=2*(x[0][j]-x[i+1][j]);
			a[i][n]+=x[0][j]*x[0][j]-x[i+1][j]*x[i+1][j];
		}
	}
	for(int i=0;i<n;i++){
		bool ok=false;
		int j=0;
		for(;j<n;j++){
			if(a[j][i]&&!u[j]){
				ok=true;
				u[j]=true;
				break;
			}
		}
		if(!ok){
			cout<<"No Solution";
			return 0;
		}
		if(a[j][i]==0){
			cout<<"No Solution";
			return 0;
		}
		double orz=a[j][i];
		for(int k=0;k<n+1;k++){
			a[j][k]/=orz;
		}
		for(int k=0;k<n;k++){
			if(k==j)continue;
			orz=a[k][i]/a[j][i];
			for(int l=0;l<n+1;l++){
				a[k][l]-=orz*a[j][l];
			}
		}
		/*for(int i=0;i<n;i++){
			for(int j=0;j<n+1;j++){
				cout<<a[i][j]<<" ";
			}
			cout<<endl;
		}
		cout<<endl;*/
	}
	for(int i=0;i<n;i++){
		cout<<a[i][n]<<" ";
	}
	return 0;
}
```

---

## 作者：Jμdge (赞：2)

终于不是纯抄题解 A 的高斯消元啦！（好吧偷瞄公式了）

其实高斯消元这算法没什么难的，关键就是推式子了...

令球心坐标为 $O_{1-n}$ 共 n 维

球面上某点坐标为 $X_{i , 1-n}$ 共 n 维

则球面上某点到球心的距离（即半径，用 $R$ 表示）满足：

$$R^2=\sum_{j=1}^n (O_j-X_{i,j})^2$$

那么我们可以由题意列出 n+1 个式子，然后每一个式子和下一个式子联立，得到 n 个消去了 $R$ 的式子，即：

$$\sum_{j=1}^n (O_j-X_{i,j})^2=\sum_{j=1}^n (O_j-X_{i+1,j})^2$$

然后移一下项


$$\sum_{j=1}^n (O_j-X_{i,j})^2-(O_j-X_{i+1,j})^2=0 $$

接着展开


$$\sum_{j=1}^n 2\times O_j\times (X_{i,j}-X_{i+1,j})=\sum_{j=1}^n X_{i,j}^{~~~~~2}-X_{i+1,j}^{~~~~~~~~~~2} $$


上面提到，这样的式子共有 n 个，那么我们就可以构造矩阵进行高斯消元求解了$QAQ$

```
//by Judge
#include<cmath>
#include<cstdio>
#include<iostream>
#define ll long long
using namespace std;
const int M=13;
const double eps=1e-6;
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(int x,char chr='\n'){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]=chr;
} inline double dread(){ double x=0,y=0.1,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0';
	for(c=='.'&&(c=getchar());isdigit(c);c=getchar())
		x=x+(c-48)*y,y*=0.1; return x*f;
} int n; double x[M][M],A[M][M];
inline void Gauss(){ double tp;
	for(int i=1,j;i<=n;++i){
		for(j=i;j<=n&&fabs(A[j][i])<eps;++j);
		if(j>n) continue; if(i^j) swap(A[i],A[j]);
		for(j=i+1;j<=n+1;++j)
			A[i][j]/=A[i][i]; A[i][i]=1;
		for(int j=1;j<=n;++j) if(j^i&&A[j][i]){
			tp=A[j][i],A[j][i]=0;
			for(int k=i+1;k<=n+1;++k)
				A[j][k]-=tp*A[i][k];
		}
	}
	for(int i=1;i<=n;++i)
		printf("%.3lf ",A[i][n+1]);
}
int main(){ n=read();
	for(int i=1;i<=n+1;++i)
		for(int j=1;j<=n;++j) x[i][j]=dread();
	for(int i=1;i<=n;++i) for(int j=1;j<=n;++j)
		A[i][n+1]+=x[i][j]*x[i][j]-x[i+1][j]*x[i+1][j],
		A[i][j]=2*(x[i][j]-x[i+1][j]); return Gauss(),0;
}
```







---

## 作者：chihik (赞：1)

设原形坐标为 $O$,圆上一点坐标为 $A$

由提示得：

$$r=\sqrt{\sum_{i=1}^n(A_i-O_i)^2}$$

$$r^2=\sum_{i=1}^n(A_i-O_i)^2$$

$$r^2=\sum_{i=1}^n{A_i^2+O_i^2-2A_iO_i}$$

$$r^2-\sum_{i=1}^nO_i^2-2A_iO_i=\sum_{i=1}^n{A_i^2}$$

$$\sum_{i=1}^n2A_iO_i+(r^2-\sum_{i=1}^nO_i^2)=\sum_{i=1}^n{A_i^2}$$

括号內的式子与 $A$ 无关，可单独看作一个变量。

因为有 $n+1$ 个点，就有 $n+1$ 组 $A_i$ ，列出 $n+1$ 个方程消元即可。

~~我不会告诉你因为我这题SA打挂了才用的这种方法。~~

```cpp
#include <cmath>
#include <cstdio>
#include <iostream>
using namespace std;
#define eps 1e-12

const int MAXN = 10;
int n;
double a[ MAXN + 5 ][ MAXN + 5 ];

void Gauss( ) {
    for( int i = 1 ; i <= n ; i ++ ) {
        int pos = i;
        for( int j = i + 1 ; j <= n ; j ++ )
            if( fabs( a[ j ][ i ] ) > fabs( a[ pos ][ i ] ) ) pos = j;
        swap( a[ pos ] , a[ i ] );
        for( int j = 1 ; j <= n ; j ++ )
            if( i != j ) {
                double t = a[ j ][ i ] / a[ i ][ i ];
                for( int k = i ; k <= n + 1 ; k ++ )
                    a[ j ][ k ] -= t * a[ i ][ k ];
            } 
    }
}

int main( ) {
    scanf("%d",&n); n ++;
    double A;
    for( int i = 1 ; i <= n ; i ++ ) {
    	for( int j = 1 ; j <= n - 1 ; j ++ )
            scanf("%lf",&A) , a[ i ][ j ] = 2 * A , a[ i ][ n + 1 ] += A * A;
        a[ i ][ n ] = 1;
	}
    Gauss( );
    for( int i = 1 ; i <= n - 1 ; i ++ ) printf("%.3f ", a[ i ][ n + 1 ] / a[ i ][ i ] );
    return 0;
}
```

---

## 作者：xsap (赞：1)

- 考点：Gauss消元（[模版题戳这里](https://www.luogu.com.cn/problem/P3389)以及[判断有无解](https://www.luogu.com.cn/problem/P2455)）
- 题意：其实就是给出n + 1个n维坐标$(a_1 , a_2 , a_3...a_{n + 1})$。求出这n+1个点所处的球体的中心（当然，也是n维的坐标）。
- 解法：观察给的式子$dist = \sqrt{(a_1 - b_1) ^ 2 + (a_2 - b_2) ^ 2 + ... + (a_n - b_n )^2}$。左右同时平方，假设半径为r,得到$r^2 = \sum_{i = 1}^{n}{a_{i}^2} + \sum_{i = 1}^{n}{b_{i}^2} - \sum_{i = 1}^{n}{a_i * b_{i} * 2}$其中$a_{i}$均为常数，但是出现了$\sum_{i = 1}^{n}{b_{i}^2}$是二次项且未知。不能直接使用Gauss消元。但是注意到对于每个点，二次项都是$\sum_{i = 1}^{n}{b_{i}^2}$。故将任两个点得到的式子相减（其实只需要将编号相邻的式子相减），即可消去二次项。之后直接Gauss消元即可
- 代码：

```.cpp
# include <iostream>
# include <cstdio>
# include <cmath>

using namespace std ;

const double eps = 1e-6 ;

double b[15][15] ;
int n ;
double a[15][15] ;

int Gauss()
{
	int c , r ;
	// print() ;
	for ( c = 1 , r = 1 ; c <= n ; c++ )
	{
		// printf("cal:%d\n" , c) ;
		// 找最大
		int t = r ;
		for ( int i = r ; i <= n ; i++ )
		{
			if ( fabs( a[i][c] ) > fabs( a[t][c] ) )
				t = i ;
		}
		if ( fabs( a[t][c] ) < eps )
		{
			return 0 ;
		}
		// printf("findmax:%d\n" , t) ;
		// 交换
		for ( int i = c ; i <= n + 1 ; i++ )
		{
			swap( a[t][i] , a[r][i] ) ;
		}
		// print() ;
		// 归一
		double tmp = a[r][c] ;
		for ( int i = n + 1 ; i >= c ; i-- ) 
			a[r][i] /= a[r][c] ;
		// print() ;
		// 消元
		for ( int i = r + 1 ; i <= n ; i++ )
		{
			if ( fabs( a[i][c] ) < eps ) continue ;
			for ( int j = n + 1 ; j >= c ; j-- )
			{
				a[i][j] -= a[r][j] * a[i][c] ;
			}
		}
		// print() ;
		r ++ ;
	}
	// print() ;
	for ( int i = n ; i >= 1 ; i-- )
	{
		for ( int j = i + 1 ; j <= n ; j++ )
			a[i][n + 1] -= a[j][n + 1] * a[i][j] ;
	}
	return 1 ;
}

int main()
{
	scanf("%d" , &n) ;
	for ( int i = 1 ; i <= n + 1 ; i++ )
	{
		for ( int j = 1 ; j <= n ; j++ )
		{
			scanf("%lf" , &b[i][j]) ;
		}
	}
	for ( int i = 1 ; i <= n ; i++ )
	{
		for ( int j = 1 ; j <= n ; j++ )
		{
			a[i][j] = 2 * ( b[i + 1][j] - b[i][j] ) ;
			a[i][n + 1] += b[i + 1][j] * b[i + 1][j] - 
			b[i][j] * b[i][j] ;
		}
	}
	Gauss() ;
	for ( int i = 1 ; i <= n ; i++ )
		printf("%.3lf " , a[i][n + 1]) ;
	puts("") ;
	return 0 ;
}
```

---

## 作者：杨铠远 (赞：1)

我的做法好像和巨佬们不太一样呢

以$n=2$为例，令读入的数为$a,b$

设球心坐标为$x,y$,半径为$r$

则有
$\sqrt{(a-x)*(a-x)+(b-y)*(b-y)}=r$

$a * a - 2 * a * x + x * x + b * b - 2 * b * y + y * y = r * r$

移项

$2 * a * x + 2 * b * y - ( x * x + y * y - r * r) = a * a + b * b$

令$x * x + y * y - r * r$为$t$

最后

$2 * a * x + 2 * b * y - t = a * a + b * b$

因为$x,y,r$是未知量，设成什么都无所谓了

可得$n+1$个方程高斯消元以后$x,y$可以解出

### code:

```cpp
//Code by : Y-k-y
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <queue>
#include <vector>
#include <set>
#include <map>
#define ll long long
const int N=100010;
using namespace std;
inline int rnd(){
	int res=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){res=res*10+ch-'0';ch=getchar();}
	return res*f;
}
inline void wr(int x){
	if(x<0){putchar('-');x=-x;}if(x>9) wr(x/10);putchar(x%10+'0');
}
int n;
double a[110][110],ans[110];
int main(){
	cin>>n;
	for(int i=1;i<=n+1;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
			a[i][n+2]+=a[i][j]*a[i][j];//方程等号右面的值 
			a[i][j]*=2;//前n项的系数 
		}
		a[i][n+1]=-1.0;//t的系数 
	}
	n++;
	for(int i=1;i<=n;i++){
		int r=i;
		for(int j=i+1;j<=n;j++){
			if(fabs(a[r][i])<fabs(a[j][i]))r=j;
		}
		if(i!=r)swap(a[i],a[r]);
		double div=a[i][i];
		for(int j=i;j<=n+1;j++)a[i][j]/=div;
		for(int j=i+1;j<=n;j++){
			div=a[j][i];
			for(int k=i;k<=n+1;k++)
			a[j][k]-=a[i][k]*div;
		}
	}
	ans[n]=a[n][n+1];
	for(int i=n-1;i>=1;i--){
		ans[i]=a[i][n+1];
		for(int j=i+1;j<=n;j++)ans[i]-=(a[i][j]*ans[j]);
	}
	for(int i=1;i<n;i++){
		printf("%.3lf ",ans[i]);
	}
	return 0;
}

```


---

## 作者：陈雪森 (赞：1)

**性质：一个球体上的所有点到球心的距离相等。**

1.由性质得只需求出一个点（x1,x2,…,xn）,
 
2.使得for(j,0,n)(a[i][j]-x[j]=C;(C为常数);
 
3.将相邻两个方程作差就可得到n个一元一次方程,同时消去常数C;
 
4.最后用高斯消元求解方程组即可;

```cpp
#include<cstdio>
#include<cmath>
#include<iostream> 
using namespace std;
double a[20][20],b[20],c[20][20];
int n;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n+1;i++)
	   for(int j=1;j<=n;j++)
	   	    scanf("%lf",&a[i][j]);//输入点的坐标； 
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=n;j++) {
	   		c[i][j]=2*(a[i][j]-a[i+1][j]);//c为系数矩阵，b为常数，一起构成增广矩阵； 
	   		b[i]+=a[i][j]*a[i][j]-a[i+1][j]*a[i+1][j];
	    }
	//用高斯消元求解（数据保证有唯一解）； 
	for(int i=1;i<=n;i++) {
		for(int j=i;j<=n;j++)//找到x[i]的系数不为零的一个方程； 
	   		if(fabs(c[j][i])>1e-8) {
	   			for(int k=1;k<=n;k++) swap(c[i][k],c[j][k]);//进行 行列变换； 
	   			swap(b[i],b[j]);
	   		}
	   	for(int j=1;j<=n;j++){//消去其他方程的x[i]的系数； 
	   		if(i==j)continue;//i和j为行，k为列； 
	   		double rate=c[j][i]/c[i][i];
	   		for(int k=i;k<=n;k++) c[j][k]-=c[i][k]*rate;
	   		b[j]-=b[i]*rate;
	   	}
	}
	   for(int i=1;i<n;i++) printf("%.3f ",b[i]/c[i][i]);//常数除以系数矩阵的对角线得出最终答案； 
	   printf("%.3f\n",b[n]/c[n][n]);
	   return 0;
}
```


---

## 作者：xryjr233 (赞：1)

设中心点坐标$B=(b_1,b_2,b_3,...,b_n)$,球面上的点的坐标A=$(a_1,a_2,a_3,...,a_n)$

则

$dist_{A,B}=\sqrt{(a_1-b_1)^2+(a_2-b_2)^2+(a_3-b_3)^2+...+(a_n-b_n)^2}$

$(a_1-b_1)^2+(a_2-b_2)^2+(a_3-b_3)^2+...+(a_n-b_n)^2=dist_{A,B}^2$

$a_1^2-2a_1b_1+b_1^2+a_2^2-2a_2b_2+b_2^2+a_3^2-2a_3b_3+b_3^2+...+a_n^2-2a_nb_n+b_n^2=dist_{A,B}^2$

$-2a_1b_1-2a_2b_2-2a_3b_3-...-2a_nb_n=dist_{A,B}^2-(a_1^2+a_2^2+a_3^2+...+a_n^2)-(b_1^2+b_2^2+b_3^2+...+b_n^2)$

设$dist_{A,B}^2-(b_1^2+b_2^2+b_3^2+...+b_n^2)=k$

得$2a_1b_1+2a_2b_2+2a_3b_3+...+2a_nb_n+k=a_1^2+a_2^2+a_3^2+...+a_n^2$

由于$a_1,a_2,a_3,...,a_n$都是常数,所以这实际上是一个$n+1$元一次方程。

我们有$n+1$个这样的方程。

比如样例,可得以下方程:

$0b_1+0b_2+k=0$

$-2b_1+2b_2+k=2$

$2b_1+0b_2+k=1$

解得$b_1=\frac{1}{2},b_2=\frac{3}{2},k=0$

至于算法,[高斯消元](https://www.luogu.org/blog/xryjr233/post-20181218-gao-si-xiao-yuan-suan-fa-post)求解即可。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
struct equation{
	double n[15],x;
}e[15];
int n;
double ans[15];
void Printeq(){//debug
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)cout<<e[i].n[j]<<" ";
		cout<<"=>"<<e[i].x<<"\n";
	}
}
void Work(int x,int y){
	double v=-e[y].n[x]/e[x].n[x];
	for(int i=1;i<=n;i++)e[y].n[i]+=e[x].n[i]*v;
	e[y].x+=e[x].x*v;
}
void Solve(){
	for(int i=1;i<n;i++){
		for(int j=i;j<=n;j++){
			if(e[j].n[i]){
				swap(e[j],e[i]);
				break;
			}
		}
		for(int j=i+1;j<=n;j++)Work(i,j);
	}
	ans[n]=e[n].x/e[n].n[n];
	double k=0;
	for(int i=n-1;i>=1;i--,k=0){
		for(int j=i+1;j<=n;j++)k+=ans[j]*e[i].n[j];
		ans[i]=(e[i].x-k)/e[i].n[i];
	}
}
int main(){
	scanf("%d",&n);
	n++;
	for(int i=1;i<=n;i++){
		for(int j=1;j<n;j++)scanf("%lf",&e[i].n[j]),e[i].x+=e[i].n[j]*e[i].n[j],e[i].n[j]*=2;
		e[i].n[n]=1.0;
	}
	Solve();
	for(int i=1;i<n;i++)printf("%.3lf ",ans[i]);
	return 0;
}
```

---

## 作者：lgswdn_SA (赞：1)

## 一丢丢数学推理+高斯消元法

公式渲染可能有点问题（管理说的~）所以

[**个人博客食用更加**](https://www.luogu.com.cn/blog/forever-captain/solution-p4035)


嫌数学推导有点多？不怕，其实**简单的一匹**

> 题目 简而言之就是找n维空间到达空间上的n+1个点距离相同的点  

我们先看到题目的提示
> 球心：到球面上任意一点距离都相等的点。

### 数学推导

（这里渲染可能有问题，放张我的博客的图片）
![](https://public.noi.top/image/1582172803805.png)

### [高斯消元](https://www.luogu.com.cn/problem/P3389)……？

emmm 好的我们来看一下模板（由于这不是高斯消元的主场，我们就不细讲了，你可以去看一下模板题的题解）

如果大家有自己版本的高斯消元，那么就用你们自己的吧

```cpp
int find(int r,int c){
	int ret=r;
	for(int i=r;i<=n;i++) if(fabs(a[i][c])>fabs(a[ret][c])) ret=i;
	return ret;
}
int swp(int p,int q){
	for(int i=1;i<=n+1;i++)  swap(a[p][i],a[q][i]); 
}
void unify(int r,int c){
	for(int i=1;i<=n+1;i++) if(i!=c) a[r][i]/=a[r][c];
	a[r][c]=1;
}
void eliminate(int r,int c){
	for(int i=r+1;i<=n;i++){
		double p=a[i][c]/a[r][c];
		for(int j=1;j<=n+1;j++){
			a[i][j]-=a[r][j]*p;
		}
	}
}
int gauss(){
	int c=1,r=1;
	for(;c<=n;c++){
		int x=find(r,c); if(fabs(a[x][c])<eps) continue; 
		swp(x,r);unify(r,c);eliminate(r,c);
		z[r]=c; r++;
	} 
	if(r<=n) for(int i=r;i<=n;i++) if(fabs(a[i][n+1])>eps) return -1;
	return r-1;
}
void cal(int r){
	if(!r) return;
	int c=z[r];
	ans[c]=a[r][n+1];
	for(int i=1;i<r;i++) a[i][n+1]-=ans[c]*a[i][c];
	cal(r-1);
}
```



在输入后处理一下重新计算出$a$数组

```cpp
//我们这里假设输入进来的是b数组
//然后计算出来等号右边的东西是a[i][n+1]
scanf("%d",&n);
for(int i=1;i<=n+1;i++)
	for(int j=1;j<=n;j++) scanf("%lf",&b[i][j]);
for(int i=2;i<=n+1;i++){
	for(int j=1;j<=n;j++){
		a[i-1][j]=2*(b[1][j]-b[i][j]),a[i-1][n+1]+=b[1][j]*b[1][j]-b[i][j]*b[i][j];
	}
}
```
那么总体算法流程：
- 处理输入
- 高斯消元
- 回代计算结果

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=29; const double eps=1e-8; 
int n,z[N];
double a[N][N],b[N][N],ans[N];
int find(int r,int c){
	int ret=r;
	for(int i=r;i<=n;i++) if(fabs(a[i][c])>fabs(a[ret][c])) ret=i;
	return ret;
}
int swp(int p,int q){
	for(int i=1;i<=n+1;i++)  swap(a[p][i],a[q][i]); 
}
void unify(int r,int c){
	for(int i=1;i<=n+1;i++) if(i!=c) a[r][i]/=a[r][c];
	a[r][c]=1;
}
void eliminate(int r,int c){
	for(int i=r+1;i<=n;i++){
		double p=a[i][c]/a[r][c];
		for(int j=1;j<=n+1;j++){
			a[i][j]-=a[r][j]*p;
		}
	}
}
int gauss(){
	int c=1,r=1;
	for(;c<=n;c++){
		int x=find(r,c); if(fabs(a[x][c])<eps) continue; 
		swp(x,r);unify(r,c);eliminate(r,c);
		z[r]=c; r++;
	} 
	if(r<=n) for(int i=r;i<=n;i++) if(fabs(a[i][n+1])>eps) return -1;
	return r-1;
}
void cal(int r){
	if(!r) return;
	int c=z[r];
	ans[c]=a[r][n+1];
	for(int i=1;i<r;i++) a[i][n+1]-=ans[c]*a[i][c];
	cal(r-1);
}
void solve(){
	int res=gauss(); cal(n); //这里珂以把自己的高斯消元版本放上去
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n+1;i++)
		for(int j=1;j<=n;j++) scanf("%lf",&b[i][j]);
	for(int i=2;i<=n+1;i++){
		for(int j=1;j<=n;j++){
			a[i-1][j]=2*(b[1][j]-b[i][j]),a[i-1][n+1]+=b[1][j]*b[1][j]-b[i][j]*b[i][j];
		}
	}
	solve();
	for(int i=1;i<=n;i++) printf("%.3lf ",ans[i]);
	return 0;
}
```

---

## 作者：Agakiss (赞：1)

### Description
[[JSOI2008]球形空间产生器sphere](https://www.lydsy.com/JudgeOnline/problem.php?id=1013)
### Solution
以二维的时候为例

球面上三个点分别为$(a_1,a_2)$，$(b_1,b_2)$，$(c_1,c_2)$

设球心的点为$(x_1,x_2)$，球的半径为$T$
列式得
$\left\{
\begin{aligned}
(a_1-x_1)^2+(a_2-x_2)^2&=(a_1)^2-2a_1x_1+(x_1)^2+(a_2)^2-2a_2x_2+(x_2)^2&=T\\
(b_1-x_1)^2+(b_2-x_2)^2&=(b_1)^2-2b_1x_1+(x_1)^2+(b_2)^2-2b_2x_2+(x_2)^2&=T\\
(c_1-x_1)^2+(c_2-x_2)^2&=(c_1)^2-2c_1x_1+(x_1)^2+(c_2)^2-2c_2x_2+(x_2)^2&=T
\end{aligned}
\right.$
联立方程
$(a_1-x_1)^2+(a_2-x_2)^2=(b_1-x_1)^2+(b_2-x_2)^2=(c_1-x_1)^2+(c_2-x_2)^2$
暴力展开
$(a_1)^2-2a_1x_1+(x_1)^2+(a_2)^2-2a_2x_2+(x_2)^2=(b_1)^2-2b_1x_1+(x_1)^2+(b_2)^2-2b_2x_2+(x_2)^2=(c_1)^2-2c_1x_1+(x_1)^2+(c_2)^2-2c_2x_2+(x_2)^2$
整理得
$(a_1)^2-2a_1x_1+(a_2)^2-2a_2x_2=(b_1)^2-2b_1x_1+(b_2)^2-2b_2x_2=(c_1)^2-2c_1x_1+(c_2)^2-2c_2x_2$
也可以写成这个样子
$\left\{
\begin{aligned}
(a_1)^2-2a_1x_1+(a_2)^2-2a_2x_2&=(b_1)^2-2b_1x_1+(b_2)^2-2b_2x_2\\
(b_1)^2-2b_1x_1+(b_2)^2-2b_2x_2&=(c_1)^2-2c_1x_1+(c_2)^2-2c_2x_2
\end{aligned}
\right.$
移来移去
$\left\{
\begin{aligned}
-2a_1x_1-2a_2x_2+2b_1x_1+2b_2x_2&=-(a_1)^2-(a_2)^2+(b_1)^2+(b_2)^2\\
-2b_1x_1-2b_2x_2+2c_1x_1+2c_2x_2&=-(b_1)^2-(b_2)^2+(c_1)^2+(c_2)^2
\end{aligned}
\right.$
移来移去
$\left\{
\begin{aligned}
(2b_1-2a_1)x_1+(2b_2-2a_2)x_2&=-(a_1)^2-(a_2)^2+(b_1)^2+(b_2)^2\\
(2c_1-2b_1)x_1+(2c_2-2b_2)x_2&=-(b_1)^2-(b_2)^2+(c_1)^2+(c_2)^2
\end{aligned}
\right.$
然后我们发现它成了一个$n$元一次方程组，于是我们来高斯消元就行了
### Code
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
#define eps 1e-7
#define N 20
int n;
double c[N][N], a[N][N], ans[N];
inline int read() {
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}
int main() {
	n = read();
	for (register int i = 1; i <= n + 1; i++)
		for (register int j = 1; j <= n; j++)
			scanf("%lf", &c[i][j]);
	for (register int i = 1; i <= n; i++)
		for (register int j = 1; j <= n; j++)
			a[i][j] = - 2 * c[i][j] + 2 * c[i + 1][j],
			a[i][n + 1] += - c[i][j] * c[i][j] + c[i + 1][j] * c[i + 1][j];
	for (register int i = 1; i <= n; i++) {
		int r = i;
		for (register int j = i + 1; j <= n; j++)
			if (fabs(a[r][i]) < fabs(a[j][i]))
				r = j;
		if (fabs(a[r][i]) < eps) break;
		if (i != r) swap(a[i], a[r]);
		double div = a[i][i];
		for (register int j = i; j <= n + 1; j++)
			a[i][j] /= div;
		for (register int j = i + 1; j <= n; j++) {
			div = a[j][i];
			for (register int k = i; k <= n + 1; k++)
				a[j][k] -= a[i][k] * div;
		}
	}
	ans[n] = a[n][n + 1];
	for (register int i = n - 1; i; i--) {
		ans[i] = a[i][n + 1];
		for (register int j = i + 1; j <= n; j++)
			ans[i] -= a[i][j] * ans[j];
	}
	for (register int i = 1; i <= n; i++)
		printf("%.3lf ", ans[i]);
	return 0;
}
```

---

## 作者：未见堇开 (赞：1)

大部分题解是(标准方程+高斯消元)或者随机算法。

这里贴一个用一般方程的思想题的方法。

我们知道，对于一个$n$维的球面，它的方程是这样的：
$$\sum _{i=1}^{n}(x_{i}-c_{i})^{2}=r^{2}$$
其中$c_{i}$表示圆心在第$i$维上的坐标；

类比圆的一般方程，我们设$n$维球面的一般方程为：
$$C+\sum _{i=1}^{n}x_{i}^{2}+\sum _{i=1}^{n}x_{i}y_{i}=0$$
其中$y_{i}$为参数。

显然$c_{i}=-\dfrac {y_{i}} {2}$，用高斯消元法求出$y_{i}$就能完成此题。

这里只给出构造方程组的代码：
```cpp
#define reg register
#define MAXN 12
using namespace std;

double matrix[MAXN+1][MAXN+2];
double val[MAXN+1][MAXN];
int n;

inline void construct()
{
	for(reg int i=1;i<=n+1;i++)
	{
		for(reg int j=1;j<=n;j++)
			matrix[i][j]=val[i][j],matrix[i][n+2]+=val[i][j]*val[i][j];
		matrix[i][n+1]=1;
	}
	return;
}
```

---

## 作者：Strelitzia (赞：0)

[题目穿送门](https://www.luogu.com.cn/problem/P4035)

---

其实知道了这道题是高斯消元后不是很难，但你可能不知道……

读了题目，可以发现一个问题，求的点只有 $\operatorname n$ 个，但给出了 $\text{n + 1}$ 个点的坐标。

我们设圆心的 $\text{n}$ 个坐标分别为 $x_1,x_2\dots x_n$。

然后我们可以得到一个等式。

$$
\sqrt{(a_1-x_1)^2+(a_2-x_2)^2+\dots+(a_n-x_n)^2}=\sqrt{(b_1-x_1)^2+(b_2-x_2)^2+\dots+(b_n-x_n)^2}
$$

两边来个平方

$$
(a_1-x_1)^2+(a_2-x_2)^2+\dots+(a_n-x_n)^2=(b_1-x_1)^2+(b_2-x_2)^2+\dots+(b_n-x_n)^2
$$

展开并且移项可得

$$
(a_1-b_1)x_1+(a_2-b_2)x_2+\dots+(a_n-b_n)x_n=(a_1^2-b_1^2)+(a_2^2-b_2^2)+\dots+(a_n^2-b_n^2)
$$

我们根据相邻两式子加减，可得 $\text{n}$ 个式子，代个高斯消元就行了。

```cpp
#include <cmath>
#include <cstdio>
#include <cctype>
#include <cstring>
#include <iostream>
#include <algorithm>
#define eps 1e-18
using namespace std;

template<typename T>void read(T &x) {
	x = 0;T f = 1;char ch = getchar();
	while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}
	while (isdigit(ch)) {x = (x << 3) + (x << 1) + ch - '0';ch = getchar();}
	x *= f;
}
template<typename T>void print(T x) {
	if (x < 0) putchar('-'),x = -x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
template<typename T>T Min(T x,T y) {return x < y ? x : y;}
template<typename T>T Max(T x,T y) {return x > y ? x : y;}
template<typename T>T Abs(T x) {return x < 0 ? -x : x;}

const int maxn = 105;
int n;
double a[maxn][maxn],now[maxn][maxn],ans[maxn];

int main() {
	read(n);
	for (int i = 1 ; i <= n + 1 ; ++ i)
		for (int j = 1 ; j <= n ; ++ j)
			scanf("%lf",&now[i][j]);
	for (int i = 1 ; i <= n ; ++ i) {
		for (int j = 1 ; j <= n ; ++ j) {
			a[i][n + 1] += now[i][j] * now[i][j] - now[i + 1][j] * now[i + 1][j];
			a[i][j] = 2 * (now[i][j] - now[i + 1][j]);
		}
	}
	for (int i = 1 ; i <= n ; ++ i) {
		int pos = i;
		for (int j = i + 1 ; j <= n ; ++ j) {
			if (Abs(a[pos][i]) < Abs(a[j][i])) {
				pos = j;
			}
		}
		swap(a[pos],a[i]);
		if (Abs(a[i][i]) < eps) continue;
		double d = a[i][i];
		for (int j = i ; j <= n + 1 ; ++ j) a[i][j] /= d;
		for (int j = 1 ; j <= n ; ++ j) {
			if (i != j) {
				d = a[j][i];
				for (int k = i ; k <= n + 1 ; ++ k)
					a[j][k] -= a[i][k] * d;
			}
		}
	}
	for (int i = 1 ; i <= n ; ++ i)
		printf("%.3lf ",(a[i][n + 1] / a[i][i]) == 0 ? 0 : a[i][n + 1] / a[i][i]);
	return 0;
}
```

---

## 作者：CNF_Acceptance (赞：0)

#### 方法：高斯消元

题意简述：给定 $n$ 个球面上的点的坐标，求球心坐标。

首先，可以肯定的是球面上每个点到球心的距离都是一样的。

则我们看其中一点 $a_1$ ，它的坐标为 $(a_{1,1},a_{1,2},\cdots,a_{1,n})$ ，设球心为 $G$ ，坐标为 $(G_1,G_2,\cdots,G_n)$ ，各个点到球心的距离 $r$ 。

根据题目给我们的公式，可以知道：

$$r=\sqrt{(a_{1,1}-G_1)^2+(a_{1,2}-G_2)^2+\cdots+(a_{1,n}-G_n)^2}$$

$$\therefore r^2=(a_{1,1}-G_1)^2+(a_{1,2}-G_2)^2+\cdots+(a_{1,n}-G_n)^2$$

将括号拆开，得：

$$r^2=(a_{1,1})^2-2a_{1,1}G_1+(G_1)^2+(a_{1,2})^2-2a_{1,2}G_2+(G_2)^2+\cdots+(a_{1,n})^2-2a_{1,n}G_n+(G_n)^2$$

移项，得：

$$2(a_{1,1}G_1+a_{1,2}G_2+\cdots+a_{1,n}G_n)+r^2-(G_1)^2-(G_2)^2-\cdots-(G_n)=(a_{1,1})^2+(a_{1,2})^2+\cdots+(a_{1,n})^2$$

因为 $a$ 的坐标题目都给我们了， $(a_{1,1})^2+(a_{1,2})^2+\cdots+(a_{1,n})^2$ 的值可以直接求出来，将它的值设为 $b_1$ 。

对于每一个点 $a_i$ 我们都有以上的条件，所以 $r^2-(G_1)^2-(G_2)^2-\cdots-(G_n)$ 可以全部抵消，则可以列出方程组：

$\begin{cases}a_{1,1}G_1+a_{1,2}G_2+\cdots+a_{1,n}G_n=b_1
\\a_{2,1}G_1+a_{2,2}G_2+\cdots+a_{2,n}G_n=b_2\\\vdots\\a_{n,1}G_1+a_{n,2}G_2+\cdots+a_{n,n}G_n=b_n\\\end{cases}$

利用[高斯消元](https://www.luogu.com.cn/blog/400-1234567/gao-si-xiao-yuan#)求解即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const double eps=1e-8;
int n;
double zg[102][102],b[102][102];
void gaos(){
	for(int i=1;i<=n;i++){
		int p=i;
		for(int j=i+1;j<=n;j++){
			p=(abs(zg[j][i])>abs(zg[p][i])?j:p);
		}
		if(abs(zg[p][i])<eps){
			return ;
		}
		if(p!=i){
			for(int j=i;j<=n+1;j++){
				swap(zg[i][j],zg[p][j]);
			}
		}
		for(int j=i+1;j<=n;j++){
			if(i==j) continue;
			double x=zg[j][i]/zg[i][i];
			for(int k=i;k<=n+1;k++){
				zg[j][k]=zg[j][k]-zg[i][k]*x;
			}
		}
	}
	for(int i=n;i;i--){
		for(int j=i+1;j<=n;j++){
			zg[i][n+1]=zg[i][n+1]-zg[j][n+1]*zg[i][j];
		}
		zg[i][n+1]=zg[i][n+1]/zg[i][i];
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n+1;i++){
		for(int j=1;j<=n;j++){
			cin>>b[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			zg[i][j]=2*(b[i][j]-b[i+1][j]);
			zg[i][n+1]+=b[i][j]*b[i][j]-b[i+1][j]*b[i+1][j];
		}
	}
	gaos();
	for(int i=1;i<=n;i++){
		printf("%.3lf ",zg[i][n+1]);
	}
	return 0;
}
```


---

## 作者：chenzida (赞：0)

## 题面分析：

在一个 $n$ 维的球面中有 $n+1$ 个点，求球心坐标。

## 思路解析：

如果不会高斯消元点[这里](https://www.luogu.com.cn/blog/chenzidaCZD-648/p3389-mu-ban-gao-si-xiao-yuan-fa)，高斯消元的使用范围是多元一次方程，但是在提示中是平方级别，即二次方程，是不满足的，所以我们要降次。先把原式列在下面：

$$\sum_{i=1}^{n} (a_{t,i}-x_i)^2 = R$$

现在我们要将这个问题变成一次的问题，我们要怎么降次呢？首先我们把这个式子展开，也就是：

$$\sum_{i=1}^{n} (a_{t,i}^2+x_i^2-2\times a_{t,i}\times x_i)$$

那我们的目标就是将这个 $x_i^2$ 给消掉，而我们只能使用加减消元将它消掉，所以必须要找到另一个等于 $x_i^2$ 的值才能消掉。因为 $x_i$ 是一个未知数，所以我们唯一能考虑的就是另一个 $x_i^2$，因为对于每一个 $t$ 都有 $x_i^2$，所以我们考虑将相邻的 $t$ 直接做一个减法，消掉二次，顺便也将 $R$ 消掉。

这样的话式子会变为:

$$\sum_{i=1}^n a_{t,i}^2-a_{t+1,i}^2-2\times x_i\times(a_{t,i}-a_{t+1,i})=0$$

然后我们现在就拥有一个一次的方程，就可以来做了。当然我们要先将这个问题的未知数和常数分开，这样的话式子会变为：

$$\sum_{i=1}^n 2\times x_i\times (a_{t,i}-a_{t+1,i})=\sum_{i=1}^n a_{t,i}^2-a_{t+1,i}^2$$

这样我们就能列出方程之后用高斯消元来做了。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int NR=20;
const double eps=1e-9;
int n;
double a[NR][NR];
double x[NR][NR];
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
int main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	n=read();
	for(int i=1;i<=n+1;i++)
		for(int j=1;j<=n;j++)
			scanf("%lf",&x[i][j]);
	
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			a[i][j]=2*(x[i][j]-x[i+1][j]);
			a[i][n+1]+=(x[i][j]*x[i][j])-(x[i+1][j]*x[i+1][j]);
		}
	}
	
	for(int i=1;i<=n;i++)
	{
		int p=i;
		while(fabs(a[p][i])<=eps&&p<=n)
			p++;
		if(p>n) return 0;
		for(int j=1;j<=n+1;j++)
			swap(a[p][j],a[i][j]);
		
		double tmp=a[i][i];
		for(int j=1;j<=n+1;j++)
			a[i][j]/=tmp;
			
		for(int j=1;j<=n;j++)
		{
			if(i==j) continue;
			double t=a[j][i];
			for(int k=1;k<=n+1;k++)
				a[j][k]-=t*a[i][k];
		}
	}
	
	for(int i=1;i<=n;i++)
		printf("%.3f ",a[i][n+1]);
	return 0;
}

```

---

## 作者：loceaner (赞：0)

# 洛谷 P4035 [JSOI2008]球形空间产生器

## 思路

> 高斯消元

**题意：在$n$维的球形空间中给定$n+1$个点，求到所有$n+1$个点的距离相等的点的坐标**

由题意易知我们要求出在$n$维空间中的一个点$(x_1,x_2,x_3,…x_n)$，满足：

$$\forall i\in[1,n+ 1],\sum\limits_{j = 1}^{n}(a_{i,j} - x_j)^2 = R$$

其中$R$是一个常数，第$i$个点的坐标为$(a_{i,1},a_{i,2},a_{i,3},…a_{i,n})$

假设有$i_1,i2\in[1,n+1],i1≠i2$，由$\sum\limits_{j = 1}^{n}(a_{i_1,j} - x_j)^2 = R$和$\sum\limits_{j = 1}^{n}(a_{i_2,j} - x_j)^2 = R$得

$$\sum\limits_{j = 1}^{n}(a_{i_1,j} - x_j)^2 = \sum\limits_{j = 1}^{n}(a_{i_2,j} - x_j)^2$$

展开式子得

$$\sum\limits_{j = 1}^{n}(a_{i_1,j}^2 + x_j^2 - 2 *(a_{i_1,j}* x_j))=\sum\limits_{j = 1}^{n}(a_{i_2,j}^2 + x_j^2 - 2 *(a_{i_2,j}* x_j))$$

进一步化简

$$\sum\limits_{j = 1}^{n}(a_{i_1,j}^2 - 2 *(a_{i_1,j}* x_j))=\sum\limits_{j = 1}^{n}(a_{i_2,j}^2 - 2 *(a_{i_2,j}* x_j))$$

$$\sum\limits_{j = 1}^{n} 2 *(a_{i_1,j} - a_{i_2,j})x_j= \sum\limits_{j = 1}^{n}(a_{i_1,j}^2 - a_{i_2,j}^2)$$

这样就转化成了一个线性方程组，由此可以用每个$i$和$i+1$两两组合，得出$n$个线性方程组，则最后的矩阵为

$$\begin{bmatrix}2(a_{1,1}-a_{2,1})\  2(a_{1,2}-a_{2,2})\ … 2(a_{1,n}-a_{2,n})\sum\limits_{j=1}^{n}(a^2_{1,j}-a^2_{2,j})\\2(a_{2,1}-a_{3,1})\  2(a_{2,2}-a_{3,2})\ … 2(a_{2,n}-a_{3,n})\sum\limits_{j=1}^{n}(a^2_{2,j}-a^2_{3,j})\\2(a_{3,1}-a_{4,1})\  2(a_{3,2}-a_{4,2})\ … 2(a_{3,n}-a_{4,n})\sum\limits_{j=1}^{n}(a^2_{3,j}-a^2_{4,j})\\…\\2(a_{n,1}-a_{n+1,1})\  2(a_{n,2}-a_{n+1,2})\ … 2(a_{n,n}-a_{n+1,n})\sum\limits_{j=1}^{n}(a^2_{n,j}-a^2_{n+1,j})\end{bmatrix}$$

对此矩阵进行高斯消元求解即可，由于保证有解，所以直接做就好了

## 代码

```CPP
/*
Author:loceaner
*/
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define eps 1e-8
using namespace std;

const int A = 22;
const int B = 1e6 + 11;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;

inline int read() {
	char c = getchar(); int x = 0, f = 1;
	for( ; !isdigit(c); c = getchar()) if(c == '-') f = -1;
	for( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
	return x * f;
}


int n;
double a[A][A], G[A][A], b[A];
//a是输入的点坐标，G是矩阵序数数组，b是方程右边的常数

int main() {
	n = read();
	for (int i = 1; i <= n + 1; i++) 
		for (int j = 1; j <= n; j++) scanf("%lf", &a[i][j]);
	for (int i = 1; i <= n; i++) 
		for (int j = 1; j <= n; j++) {
			G[i][j] = 2 * (a[i][j] - a[i + 1][j]);
			b[i] = b[i] + a[i][j] * a[i][j] - a[i + 1][j] * a[i + 1][j];
		} 
	for (int i = 1; i <= n; i++) {
		for (int j = i; j <= n; j++) {
			if (fabs(G[i][j]) > eps) {
				for (int k = 1; k <= n; k++) swap(G[i][k], G[j][k]);
				swap(b[i], b[j]);
			}
		}
		for (int j = 1; j <= n; j++) {
			if (i == j) continue;
			double tmp = G[j][i] / G[i][i];
			for (int k = i; k <= n; k++) G[j][k] -= G[i][k] * tmp;
			b[j] -= b[i] * tmp;
		}
	}
	for (int i = 1; i <= n; i++) printf("%.3lf ", b[i] / G[i][i]);
	return 0;
}
```


---

## 作者：pyyyyyy (赞：0)

我们可以根据**球面上任意一点到球心的距离相等来列方程组**

设球心为$(x_1,x_2,x_3……x_n)$，题目中给出的第$i$个点的坐标为$(a_{i.1},a_{i,2}……a_{i,n})$

可以得出$\sum\limits_{j=0}^n(a_{i,j}-x_j)^2=c$

这个方程组是由$n$个$n$元$2$次方程所得,不是线性方程组

我们可以通过相邻的两个方程做差，将它变成线性方程组

这里可以自己用二维的为例算一下^_^

最后得到的矩阵为

$\begin{bmatrix}2(a_{1,1}-a_{2,1})\  2(a_{1,2}-a_{2,2})\ …… \sum\limits_{j=1}^{n}(a^2_{1,j}-a^2_{2,j})\\2(a_{2,1}-a_{3,1})\  2(a_{2,2}-a_{3,2})\ …… \sum\limits_{j=1}^{n}(a^2_{2,j}-a^2_{3,j})\\2(a_{3,1}-a_{4,1})\  2(a_{3,2}-a_{4,2})\ …… \sum\limits_{j=1}^{n}(a^2_{3,j}-a^2_{4,j})\\……\\2(a_{n,1}-a_{n+1,1})\  2(a_{n,2}-a_{n+1,2})\ …… \sum\limits_{j=1}^{n}(a^2_{n,j}-a^2_{n+1,j})\end{bmatrix}$

题目中保证了方程组有唯一解，所有直接对上述矩阵进行**高斯消元**即可

**关于初等行交换的一些问题**

- 初等行交换可以防止当前$i$位置出现$0$详见这个[讨论](https://www.luogu.com.cn/discuss/show/216059?page=1)
- 有$double$进行高斯消元时，初等行交换可以减小误差


进行高斯消元时对两行消

需要除以其中一行的第一个数字

如果这个数字接近$0$

那得到的数字就会很大

$double$精度会出问题

如果把还没有消的行中第一个数字比较大的换上来

除的时候就可以避免精度问题


以上内容来自[学长wxyww](https://www.cnblogs.com/wxyww/)~~有个$nb$的学长是真滴爽，什么时候我也能像学长这么$nb$~~

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=25;
double a[N][N],b[N],c[N][N];
int n; 
int main()
{

//	freopen(".out","w",stdout);
	cin>>n;
	for(int i=1;i<=n+1;++i)
		for(int j=1;j<=n;++j)
			cin>>a[i][j];
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=n;++j)
		{
			c[i][j]=2*(a[i][j]-a[i+1][j]);
			b[i]+=a[i][j]*a[i][j]-a[i+1][j]*a[i+1][j];
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=i;j<=n;++j)
		{
			if(fabs(c[j][i])>1e-8)
			{
				for(int k=1;k<=n;++k) swap(c[i][k],c[j][k]);
				swap(b[i],b[j]);
			}
		}
		for(int j=1;j<=n;++j)
		{
			if(i==j) continue;
			double rate=c[j][i]/c[i][i];
			for(int k=i;k<=n;++k) c[j][k]-=c[i][k]*rate;
			b[j]-=b[i]*rate;
		}
	}
	for(int i=1;i<=n;++i) printf("%.13lf \n",b[i]/c[i][i]);
	return 0;
}

```

---

## 作者：Thomasguo666 (赞：0)

看到这道题，首先我的第一反应是把球心的坐标设出来，然后解方程。

为了简化思路，我们不妨设$n=2$，即这是一个二维平面上的圆，三个点和球心的坐标分别为：
$$ P_1(x_1,y_1) , P_2(x_2,y_2),P_3(x_3,y_3),O(x,y)$$

那么我们有：

$$ (x_1-x)^2+(y_1-y)^2=(x_2-x)^2+(y_2-y)^2=(x_3-x)^2+(y_3-y)^2$$

然后展开并对相邻两式作差得：
$$ \{^{2(x_1-x_2)x+2(y_1-y_2)y=x_1^2-x_2^2+y_1^2-y_2^2}_{2(x_2-x_3)x+2(y_2-y_3)y=x_2^2-x_3^2+y_2^2-y_3^2} $$
当$n$为其它值时，我们的未知数和方程式得数量都在增加，而且显然$x$，$y$的次数均为一次，所以都可以通过高斯消元来解决。

贴代码：

```cpp
#include <bits/stdc++.h>
#define debug printf("Running %s on line %d...\n",__FUNCTION__,__LINE__)
#define in inline
#define re register
#define mid (l+r>>1)
#define sqr(x) ((x)*(x))
using namespace std;
in int read()
{
    int ans=0,f=1;char c=getchar();
    for (;!isdigit(c);c=getchar()) if (c=='-') f=-1;
    for (;isdigit(c);c=getchar()) ans=(ans<<3)+(ans<<1)+(c^48);
    return ans*f;
}
typedef double db;
const db eps=1e-8;
int n;
db x[15][15],f[15][15];
in void work()
{
    for (int i=1;i<=n;i++)
    {
        db maxx=-1e18;
        int p;
        for (int j=i+1;j<=n;j++) 
        {
            if (fabs(x[j][i])>maxx) 
            {
                maxx=fabs(x[j][i]),p=j;
            }
        } 
        swap(x[i],x[p]);
        db w=1.0/x[i][i];
        for (int j=1;j<=n;j++)
        {
            if (i==j) continue;
            db u=x[j][i]*w;
            for (int k=i;k<=n+1;k++) x[j][k]-=x[i][k]*u;
        }
    }
}
int main()
{
    n=read();
    for (int i=1;i<=n+1;i++)
    {
        for (db *S=f[i],*E=f[i]+n;S!=E;) scanf("%lf",++S);
    }
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=n;j++)
        {
            x[i][j]=2*(f[i][j]-f[i+1][j]);
            x[i][n+1]+=sqr(f[i][j])-sqr(f[i+1][j]);
        }
    }
    work();
    for (int i=1;i<=n;i++) printf("%.3lf ",x[i][n+1]/x[i][i]);
    return 0;
}

```





---

## 作者：SIGSEGV (赞：0)

本题的难点在于建方程。

设球半径为$r$，球心为$a1$,$a2$,......,$an$，坐标分别为$P_{1,1}$,$P_{1,2}$,......,$P_{n+1,n}$

考虑$P_1$，有方程
$\sum_{k=1}^{k<=n}(P_{1,k}-a_k)^2=r^2$

展开得
$\sum_{k=1}^{k<=n}(P_{1,k})^2-2(P_{1,k})(a_k)+(a_k)^2=r^2$

同理，考虑$P_2$,有方程
$\sum_{k=1}^{k<=n}(P_{2,k}-a_k)^2=r^2$

展开得
$\sum_{k=1}^{k<=n}(P_{2,k})^2-2(P_{2,k})(a_k)+(a_k)^2=r^2$

两个展开式相减，得
$\sum_{k=1}^{k<=n}[(P_{1,k})^2-2(P_{1,k})(a_k)+(a_k)^2-(P_{2,k})^2+2(P_{2,k})(a_k)-(a_k)^2]=0$

即
$\sum_{k=1}^{k<=n}[(P_{1,k})^2-2(P_{1,k})(a_k)-(P_{2,k})^2+2(P_{2,k})(a_k)]=0$

得

$\sum_{k=1}^{k<=n}[-2(P_{1,k})(a_k)+2(P_{2,k})(a_k)]=\sum_{k=1}^{k<=n}[-(P_{1,k})^2+(P_{2,k})^2]$

此时原方程次数为1，可以求解。

上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
double a[15][15];
long double mat[15][15],ans[15];
inline double sqr(double x) {return x * x;}
const long double EPS = 1e-10;
int main ()
{
	scanf("%d",&n);
	for (int i = 1;i <= n + 1;i++) 
		for (int j = 1;j <= n;j++) scanf("%lf",&a[i][j]);//读入
	for (int i = 1;i <= n;i++)
		for (int j = 1;j <= n;j++) 
		{
			mat[i][j] = 2 * (a[i + 1][j] - a[i][j]);//未知数系数
			mat[i][n + 1] += sqr(a[i + 1][j]) - sqr(a[i][j]);//常数（
		}
	for (int i = 1;i <= n;i++)//高斯消元
	{
		auto mx = abs(mat[i][i]);int pos = i;
		for (int j = i + 1;j <= n;j++)//寻找系数绝对值最大的列提高精度
			if (abs(mat[j][i]) > mx)
			{
				mx = abs(mat[j][i]);pos = j;
			}
		swap(mat[i],mat[pos]);
		for (int j = i + 1;j <= n;j++)//消元
		{
			auto d = mat[j][i] / mat[i][i];
			for (int k = i + 1;k <= n + 1;k++) mat[j][k] -= mat[i][k] * d;
			mat[j][i] = 0;
		}
	}
	for (int i = n;i > 0;--i)//回代
	{
		for (int j = i + 1;j <= n;j++)
			mat[i][n + 1] -= ans[j] * mat[i][j];
		ans[i] = mat[i][n + 1] / mat[i][i];
	}
	for (int i = 1;i <= n;i++) printf("%.3Lf ",ans[i]);
	return 3;
}
```

---

## 作者：wanghanjun (赞：0)

高维不太好想，先说一下三维：

已知量：球上四个点坐标(x_i,y_i,z_i)，1<=i<=4

未知量：球心坐标(x,y,z)以及球半径r

然后列出方程组：(x-x_i)^2+(y-y_i)^2+(z-z_i)^2=r^2，1<=i<=4（^不是异或）

展开，得：x^2+y^2+z^2+x_i^2+y_i^2+z_i^2-2·x·x_i-2·y·y_i-2·z·z_i=r^2，1<=i<=4

多元的二次方程不会解，那就相邻两式相减消去二次项

得：2·(x_(i+1)-x_i)·x+2·(y_(i+1)-y_i)·y+2·(z_(i+1)-z_i)=x_(i+1)^2+x_i^2+y_(i+1)^2+y_i^2+z_(i+1)^2+z_i^2

得到一个三元方程组，用高斯消元解即可

更高次也差不多，就是元数多了

代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;

const int MAXN=12;
double a[MAXN][MAXN],b[MAXN],pos[MAXN][MAXN];
int n;

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n+1;i++){
		for(int j=1;j<=n;j++){
			scanf("%lf",&pos[i][j]);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			a[i][j]=2*(pos[i+1][j]-pos[i][j]);
			b[i]+=(pos[i+1][j]*pos[i+1][j]-pos[i][j]*pos[i][j]);
		}
	}
	for(int i=1;i<=n;i++){
		int id=i;
		for(int j=i+1;j<=n;j++){
			if(fabs(a[j][i])>fabs(a[id][i])){
				id=j;
			}
		}
		for(int j=1;j<=n;j++){
			swap(a[i][j],a[id][j]);
		}
		swap(b[i],b[id]);
		for(int j=1;j<=n;j++){
			if(i!=j){
				double t=a[j][i]/a[i][i];
				for(int k=i+1;k<=n;k++){
					a[j][k]-=a[i][k]*t;
				}
				b[j]-=b[i]*t;
			}
		}
	}
	for(int i=1;i<=n;i++){
		printf("%.3lf ",b[i]/a[i][i]);
	}
	return 0;
}
```


---


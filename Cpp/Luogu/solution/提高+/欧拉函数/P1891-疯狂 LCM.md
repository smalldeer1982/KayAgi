# 疯狂 LCM

## 题目背景

众所周知，czmppppp 是数学大神犇。一天，他给众蒟蒻们出了一道数论题，蒟蒻们都惊呆了。

## 题目描述

给定 $n$，求

$$\sum_{i = 1}^n \operatorname{lcm}(i, n)$$

其中 $\operatorname{lcm}(i, j)$ 表示 $i$ 和 $j$ 的最小公倍数。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $T \leq 5$，$n \leq 10^5$。
- 对于 $100\%$ 的数据，$1 \leq T \leq 3 \times 10^5$，$1 \leq n \leq 10^6$。


## 样例 #1

### 输入

```
3
1
2
5
```

### 输出

```
1
4
55```

# 题解

## 作者：pufanyi (赞：42)

挺妙的一道题。

要求的是$\sum_{i=1}^{n}lcm(i, n)$，一看好像没什么思路（可能是本人菜）。~~当然只会想到暴力打表和看题解了……????~~

首先这步应该~~地球人~~都会去试：
$$\sum_{i=1}^{n}lcm(i, n) = n \sum_{i=1}^{n}\frac{i}{\gcd(i, n)}$$
然后很关键的一步是添一个$\sum$（说一句废话），式子就变成了：
$$n\sum_{d\mid n}\sum_{i=1}^{n}\frac{i}{d}[d=\gcd(i, n)]$$
中括号里是一个类似布尔型的变量。

对于中括号里的式子，两边同除以$d$：
$$n\sum_{d\mid n}\sum_{i=1}^{n}\frac{i}{d}[\gcd(\frac{i}{d}, \frac{n}{d}) = 1]$$
把$\frac{i}{d}$变成$i$，得到：
$$n\sum_{d\mid n}\sum_{i=1}^{\frac{n}{d}}i[\gcd(i, \frac{n}{d}) = 1]$$
把$d$倒着枚举，我们就得到了酱紫的东西：
$$n\sum_{d\mid n}\sum_{i=1}^{d}i[\gcd(i,d) = 1]$$
然后我们来看$\sum_{i=1}^{d}i[\gcd(i,d) = 1]$：与$d$互质的所有数之和。

如果是个数就好求了……

等等，个数？我们是否可以从个数出发？

想一想，对于$\gcd(i, d) = 1$，$\gcd(d-i, d)$是什么？显然也是$1$。

所以$i$是成对出现的（$d=1$除外）。

于是我们发现（当$d \not= 1$时）：
$$\sum_{i=1}^{d}i[\gcd(i,d) = 1] = \frac{\varphi(d)}{2} d$$
$O(n)$预处理$\varphi$，对于每次询问$O(\sqrt{n})$枚举$d$回答。

这种算法有点卡，注意能不开`long long`的地方就别开`long long`。

---

## 作者：虞皓翔 (赞：23)

裸数论题不解释，直接上图片：

 ![](https://cdn.luogu.com.cn/upload/pic/4170.png) 

然后上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

ll n, i, pn;
ll p[90000], h[1000040];
 
int make(ll n){
    ll i, j, v, ii, jj;
    memset(h, -1, sizeof h);
    pn = 0;
    h[1] = 1;
    for(i = 2; i <= n; i++){
        if(h[i] < 0)
            h[i] = i * (i - 1) + 1, p[pn++] = i;
        for(j = 0; j < pn; j++){
            v = i * p[j];
            if(v > n) break;
            if(i % p[j] == 0){ //(i, p[j]) > 1，提取所有 p[j] 
                ii = i; jj = p[j];
                while(ii % p[j] == 0) ii /= p[j], jj *= p[j];
                if(ii > 1)
                    h[v] = h[ii] * h[jj];
                else // i 是 p[j] 的幂 
                    h[v] = h[i] * p[j] * p[j] - p[j] + 1;
                //printf("h[%lld] = %lld\n", v, h[v]);
                break;
            }else
                h[v] = h[i] * h[p[j]]; //(i, p[j]) = 1
            //printf("h[%lld] = %lld\n", v, h[v]);
        }
    }
    return 0;
}
int main(){
    int T;
    make(1000000);
    cin >> T;
    while(T--){
        cin >> n;
        cout << (h[n] + 1 >> 1) * n << '\n';
    }
    return 0; 
}
```cpp

---

## 作者：suxxsfe (赞：21)

## 题意  
求$\sum_{i=1}^n\operatorname{lcm}(i,n)$  
多测，$T\leq 3\cdot 10^5,1\leq n\leq 10^6$  

---------  

## 题解  

看这数据范围也能知道是个预处理+$O(1)$查询之类的东西  
很容易想到的变形：  
$$\sum_{i=1}^n\operatorname{lcm}(i,n)=\sum_{i=1}^n\frac{i\cdot n}{\gcd(i,n)}=n\sum_{i=1}^n\frac{i}{\gcd(i,n)}$$  

~~然后就不会了~~  

其实是要加一层$\sum$，这个不看题解是真想不到，不过这可能是个挺套路的东西？  
$$n\sum_{d | n}\sum_{i=1}^n\frac{i}{d}\cdot[\gcd(i,n)=d]$$  
虽然看起来比较废话但很关键  

然后再变形，中括号里除以$d$变成$\gcd(\dfrac{i}{d},\dfrac{n}{d})=1$，其实就是如果$\dfrac{i}{d}$和$\dfrac{n}{d}$互质，那么他们都乘$d$以后的$\gcd$就是$d$  

$$n\sum_{d | n}\sum_{i=1}^n\frac{i}{d}\cdot[\gcd(\frac{i}{d},\frac{n}{d})=1]$$  
然后让$i$替代$\dfrac{i}{d}$  
$$n\sum_{d|n}\sum_{i=1}^{\frac{n}{d}}i\cdot[\gcd(i,\frac{n}{d})=1]$$  
又因为这个$\dfrac{n}{d},d$是$n$的“一对”因数，所以这个式子可以直接写成一个更好看的形式：  
$$n\sum_{d|n}\sum_{i=1}^{d}i\cdot[\gcd(i,d)=1]$$  

然后这就有点欧拉$\varphi$函数的意思了  
关键是那个$i$很碍眼，~~所以当然是要再看一波题解~~  

由于$\gcd(i,d)=\gcd(d-i,d)$  
这个和欧几里得法求$\gcd$很像，具体证明可以去[这里看](https://www.cnblogs.com/suxxsfe/p/12527185.html)  
所以考虑$\sum_{i=1}^{d}i\cdot[\gcd(i,d)=1]$里的每一个$i$和$d-i$，如果$\gcd(i,d)\neq 1$肯定就不用管，如果等于$1$，那么这两项的值就是$d$  
那么有多少**对**$\gcd(i,d)=\gcd(d-i,d)=1$？肯定是$\dfrac{\varphi(d)}{2}$，注意这里说的是多少**对**  
但是很容易发现，$d=1$是上面式子成$0$了，不成立，所以应该给$\sum$中的分子加上$1$然后下取整，就避免了这个情况  
然后更准确的答案就表述为：  
$$n\sum_{d|n}\lfloor\frac{\varphi(d)\cdot d+1}{2}\rfloor$$  
其实这时已经可以$O(\sqrt n)$回答了，但还可以做的更好  

$O(n\log \log n)$跑一个类似于埃氏筛的过程，我们设$f_j=\sum_{d|j}\lfloor\dfrac{\varphi(d)\cdot d+1}{2}\rfloor$，应该都知道埃氏筛里面$j$一般代表啥吧  
然后对于每一个枚举到的$i$，实际上就是上式中的每一个$d$，然后按公式给$f_j$加上就好  

-------------  

## 小总结  

~~当然我做的题太少可能说的不全~~  
其实这种$\gcd,\operatorname{lcm}$有关的问题，很多都是转变成$[\gcd=\cdots]\times \cdots$的形式，$\cdots$都是数，然后和$\varphi$结合起来  
有时这个转换的方式就是通过加上一个$\sum_{d|n}$，其它的还没遇见，遇见了可能会写在这里  
反正$\gcd$这种最容易联想到的就是$\varphi$了  

```cpp  
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<iomanip>
#include<cstring>
#define reg register
#define EN std::puts("")
#define LL long long
inline int read(){
	register int x=0;register int y=1;
	register char c=std::getchar();
	while(c<'0'||c>'9'){if(c=='-') y=0;c=std::getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}
	return y?x:-x;
}
int n=1e6;
LL phi[1000006],f[1000006];
int prime[500006],notprime[1000006];
inline void get_phi(){
	phi[1]=1;
	for(reg int i=2;i<=n;i++){
		if(!notprime[i]) prime[++prime[0]]=i,phi[i]=i-1;
		for(reg int j=1;j<=prime[0]&&i*prime[j]<=n;j++){
			notprime[i*prime[j]]=1;
			if(!(i%prime[j])){
				phi[i*prime[j]]=prime[j]*phi[i];
				break;
			}
			else phi[i*prime[j]]=phi[i]*(prime[j]-1);
		}
	}
}
int main(){
	get_phi();
	for(reg int i=1;i<=n;i++)
		for(reg int j=i;j<=n;j+=i)
			f[j]+=(phi[i]*i+1)>>1;//要加1，如果i=1的话式子就是1了符合要求，如果不是和没加一样不用管 
	int T=read();while(T--){
		n=read();
		std::printf("%lld\n",f[n]*n);
	}
	return 0;
}
```

---

## 作者：Tony102 (赞：11)

[Link](https://www.luogu.com.cn/problem/P1891)

[更好的阅读体验](https://tony102.xyz/index.php/2020/11/14/luogu1891-%e7%96%af%e7%8b%82-lcm/)

### Sol

主要考察的是 $gcd$ 和 $lcm$ 关系的一个性质: $lcm(a, b) = \frac{a \times b}{gcd(a,b)}$

那么我们用这个式子来替换现在的式子

$$\sum_{i=1}^{n} \frac{i \times n}{gcd(i,n)}$$

把乘的 $n$ 这个常数项直接提到外面来,稍微改改

$$n \times \sum_{i=1}^{n} \frac{i}{gcd(i,n)}$$

**常见套路:有整除,gcd,约数的时候,把枚举的东西改成枚举约数,再改成枚举倍数**

那么我们先枚举约数试试

$$n \times \sum_{d|n} \sum_{i=1}^{n} \frac{i}{d} [gcd(i,n) = d]$$

再把中括号(布尔表达式)内的东西同时除一个 $d$

$$n \times \sum_{d|n} \sum_{i=1}^{n} \frac{i}{d} [gcd(\frac{i}{d}, \frac{n}{d}) = 1]$$

再写成枚举倍数的

$$n \times \sum_{d|n} \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} i [gcd(i,\frac{n}{d}) = 1]$$

注意到因为 $d|n$,所以 $\frac{n}{d}$ 与 $d$ 等价,全部改成枚举到 $d$

$$n \times \sum_{d|n} \sum_{i=1}^{d} i [gcd(i,d) = 1]$$

现在应该很显然, $[gcd(i,d)=1]$ 就是 $\varphi(d)$

实际上因为 $n$ 的约数是成对出现的,那么一共会有 $\frac{d}{2}$ 对约数,直接把后面的东西利用这个性质算出来.

所以现在就是

$$n \times \sum_{d|n} \frac{\varphi(d)}{2} \times d $$



### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int SIZE = 1e6 + 5;

int T, n, tot;
int prime[SIZE], phi[SIZE], isPrime[SIZE], ans[SIZE];

namespace ae86 {
	const int bufl = 1 << 15;
	char buf[bufl], *s = buf, *t = buf;
	inline int fetch() {
		if (s == t) { t = (s = buf) + fread(buf, 1, bufl, stdin); if (s == t) return EOF; }
		return *s++;
	}
	inline int read() {
		int a = 0, b = 1, c = fetch();
		while (!isdigit(c))b ^= c == '-', c = fetch();
		while (isdigit(c)) a = a * 10 + c - 48, c = fetch();
		return b ? a : -a;
	}
}
using ae86::read;

inline void euler()
{
	int siz = 1e6 + 1;
	phi[1] = isPrime[1] = 1;
	for (register int i = 2; i <= siz; ++ i) {
		if (!isPrime[i]) {
			prime[++ tot] = i, phi[i] = i - 1;
		}
		for (register int j = 1; j <= tot && i * prime[j] <= siz; ++ j) {
			isPrime[i * prime[j]] = 1;
			if (i % prime[j])  phi[i * prime[j]] = phi[i] * phi[prime[j]];
			else {
				phi[i * prime[j]] = phi[i] * prime[j];
				break;
			}
		}
	}
}

signed main()
{
	// freopen("code.in", "r", stdin);
	// freopen("code.out", "w", stdout);
	T = read();
	euler(); int siz = 1e6 + 1;
	for (int i = 1; i <= siz; ++ i) {
		for(int j = 1; i * j <= siz; ++ j) 
			ans[i * j] += (i == 1 ? 1 : 1ll * phi[i] * i / 2);
	}
	while (T --) {
		n = read();
		printf("%lld\n", ans[n] * n * 1ll);
		// puts("");
	}
	return 0;
}
```



---

## 作者：丛雨 (赞：7)

本题题目比较简单，是莫比乌斯反演的好题。

题目要求
$\sum\limits_{i=1}^n\operatorname{lcm}(i,n)$

开始推式子

$$
\sum_{i=1}^n\operatorname{lcm}(i,n)
$$
$$
=\sum_{i=1}^n\frac{ni}{\gcd(i,n)}
$$
$$
=\sum_{d|n}\sum_{i=1}^{\frac{n}{d}}\varepsilon(\gcd(i,\frac{n}{d}))ni\ \ [ps:\varepsilon(x)=[x==1]]
$$
$$
=\sum_{d|n}\sum_{i=1}^{\frac{n}{d}}\sum_{f|\gcd(i,\frac{n}{d})}\mu(f)ni[Möbius\ inversion\ formula]
$$
$$
=n\sum_{d|n}\sum_{f|\frac{n}{d}}\mu(f)f\sum_{i=1}^{\frac{n}{df}}i
$$
设$F(x)=\sum\limits_{i|x}\mu(i)i\sum\limits_{j=1}^{\frac{x}{i}}i$

原式$=n\sum\limits_{d|n}F(\frac{n}{d})$

所以筛 $ 2 $ 次,第一遍筛出$F(x)$,第二次筛出所求值（后需$*n$）

时间复杂度$O(n\log_2n)$,证明见无穷级数相关


```cpp
#include<map>
#include<cmath>
#include<stack>
#include<deque>
#include<queue>
#include<cstdio>
#include<vector>
#include<climits>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
# define Type template<typename T>
# define ll long long
# define read read1<ll>()
Type T read1(){
    T t=0;char k;
    bool v=0;
    do (k=getchar())=='-'&&(v=1);while('0'>k||k>'9');
    while('0'<=k&&k<='9')t=(t<<3)+(t<<1)+(k^'0'),k=getchar();
    return v?-t:t;
}
# define mod 20101009
int u[1000005],pr[1000005];
bool vis[1000005];
ll v[1000005],va[1000005];
ll Get(ll x,ll y){return x*(x+1)/2%mod*(y*(y+1)/2%mod)%mod;}
void init(int N=1000000){
    u[1]=1;
    for(int i=2;i<=N;++i){
        if(!vis[i]){
            pr[++pr[0]]=i;
            u[i]=-1;
        }
        for(int j=1;j<=pr[0]&&pr[j]*i<=N;++j){
            vis[i*pr[j]]=1;
            if(!(i%pr[j]))break;
            u[i*pr[j]]=-u[i];
        }
    }
    for(int i=1;i<=N;++i)
        for(int j=1;j*i<=N;++j)
            v[i*j]+=1ll*u[i]*i*j*(j+1)>>1;
    for(int i=1;i<=N;++i)
        for(int j=i;j<=N;j+=i)
            va[j]+=v[j/i];
}
int main(){
    init();
    for(int T=read;T--;){
        int x=read;
        printf("%lld\n",va[x]*x);
    }
    return 0;
}
```

---

## 作者：jszjinshengzhi (赞：7)

# Luogu P1891 疯狂的LCM

题意：求$\sum_{i=1}^{n}lcm(i,n)$

数据范围：多组数据，$1≤T≤300000$，$1≤N≤1000000$

分析：根据数据范围，容易猜测应在对于每组询问都应在$O(1)$的时间内给出答案，

也就是说应在$O(n)$的时间内筛出$1\sim1000000$范围内的解。

于是就可以开心的推柿子了。



$Ans=\sum_{i=1}^{n}lcm(i,n)=\sum_{i=1}^{n}\frac{i\cdot n}{gcd(i,n)}$

$=n\cdot\sum_{i=1}^{n}\frac i{gcd(i,n)}=n\cdot\sum_{d|n}\sum_{i=1}^{\frac nd}i\cdot gcd(i,\frac nd)==1$（套路：枚举$gcd$）

设$\quad g(x)=\sum_{i=1}^{x}i\cdot(gcd(i,x)==1)$

基本结论：$gcd(x,y)=gcd(x,ax+y)\Rightarrow gcd(i,x)=gcd(x-i,x)$

$g(x)=\frac 12\sum_{i=1}^{x}(i\cdot(gcd(i,x)==1)+(x-i)\cdot(gcd(x-i,x)==1))$

$=\frac 12\cdot x\sum_{i=1}^{x}(gcd(i,x)==1)=\frac {x\cdot\varphi(x)}2\qquad(x>1)$

$g(1)=1$

$Ans=n\cdot\sum_{d|n}g(\frac nd)=n\cdot\sum_{d|n}g(d)$

此时，如果$g(d)$为积性函数的话，则$\sum_{d|n}g(d)$也为积性函数（可看做单位函数$I$与$g(d)$的卷积）

但$g(x)$中的$x\cdot\varphi(x)$是积性函数，而$\frac 12$不是，所以我们将$\frac 12$提出来

此外还要注意一点，将$\frac 12$提出来后，$g(1)$就变成了2，不再是积性

而注意到$\forall n$均有$1|n$，即$\sum_{d|n}g(d)$中必定含有$g(1)$项

所以我们先将$g(1)$减掉$1$，最后再加上$1$即可

设$\quad g(x)=x\cdot\varphi(x)\quad Ans=n\cdot\frac{1+\sum_{d|n}g(d)}{2}$

于是，问题就转化为了线性筛$\sum_{d|n}g(d)$

设$\quad f(n)=\sum_{d|n}g(d)$

因为此时$f(n)$是积性函数，所以考虑用欧拉筛来写

欧拉筛中的关键就在于求出$f(p)$和$f(p\cdot q)\ p|q$

$f(p)=g(p)+g(1)=p\cdot(p-1)+1$

对于$f(p\cdot q)\ p|q$我们无法直接推出一个式子，所以只能将$q$中的质因子$p$除尽

变为$f(p^k\cdot r)\ gcd(r,p)=1$，此时结果为$f(p^k)\cdot f(r)$

$f(p^k)=\sum_{i=0}^kg(p^i)=\sum_{i=0}^kp^i\cdot\varphi(p^i)=1+(p-1)\cdot\sum_{i=1}^{k}p^{2\cdot i-1}$

$f(p^{k-1})=1+(p-1)\cdot\sum_{i=1}^{k-1}p^{2\cdot i-1}$

$f(p^k)=1+p^2-p+(p-1)\cdot\sum_{i=2}^{k}p^{2\cdot i-1}=p^2\cdot f(p^{k-1})-p+1$

$Ans=n\cdot\frac{f(n)+1}2$



$Code(Part):$

```cpp
void init(){
    int i,j,x,y;
    f[1]=1;
    for(int i=2;i<=maxn;++i){
        if(!f[i]){
            f[i]=i*(i-1)+1;
            prime[++cnt]=i;
        }
        for(j=1;j<=cnt&&i*prime[j]<=maxn;++j){
            if(i%prime[j]==0){
                x=prime[j],y=i;
                for(;y%prime[j]==0;x*=prime[j],y/=prime[j]);
                if(y==1)f[i*prime[j]]=f[i]*prime[j]*prime[j]-prime[j]+1;
                else f[x*y]=f[x]*f[y];
                break;
            }
            f[i*prime[j]]=f[i]*f[prime[j]];
        }
    }
}
```



---

## 作者：I_am_Accepted (赞：6)

**Update 2021-8-23:加上了线性时间复杂度的代码。**

**Update 2021-8-19:优化了时间复杂度（感谢 [@wkywkywky](https://www.luogu.com.cn/user/133954)）。**

**Update 2021-8-17:改正公式错误（感谢 [@wsyear](https://www.luogu.com.cn/user/169574)）。**

### 这是一篇清晰的、有思考过程的、有详细码析的数论题解。

如有任何问题评论区见。

步入正题。

## 题目简述

求 ${\rm lcm}$ 的前缀和。

## 题目分析

直接推公式：

$$\sum\limits_{i=1}^n{\rm lcm}(i,n)$$

$$=\sum\limits_{i=1}^n\frac{i\times n}{\gcd(i,n)}$$

$$=n\sum\limits_{i=1}^n\frac{i}{\gcd(i,n)}$$

**重点1：转换枚举顺序，先枚举 $\gcd$,再枚举  $\gcd$ 的倍数 $i$。**

$$=n\sum\limits_{d|n}\sum\limits_{i=1}^n[\gcd(i,n)=d]\frac{i}{d}$$

$$=n\sum\limits_{d|n}\sum\limits_{i=1}^n[d|i][\gcd(\frac{i}{d},\frac{n}{d})=1]\frac{i}{d}$$

**重点2：转换枚举的东西，枚举 $i$ 变成枚举 $\frac{i}{d}$。**

$$=n\sum\limits_{d|n}\sum\limits_{i=1}^{\frac{n}{d}}[\gcd(i,\frac{n}{d})=1]i$$

**重点3：最内层的求和实际上是在 $1$ 至 $\frac{n}{d}$ 中，与 $\frac{n}{d}$ 互素的数的总和，想到欧拉函数。**

$$=n\times (1+\sum\limits_{d|n \ d<n}\frac{n}{2d}\times \varphi(\frac{n}{d}))$$

**难懂？**

* 当 $\frac{n}{d}=1$ 时，总和为 $1$（她本身）。

* 当 $\frac{n}{d}>1$ 时，举个例子：

![](https://i.loli.net/2021/08/18/yjiCB9dFlHNRDLe.png)

任取一 $k\in\mathbb{N}$ 且 $k<\frac{n}{d}$，则：

$$[\gcd(k,\frac{n}{d})=1]=[\gcd(\frac{n}{d}-k,\frac{n}{d})=1]$$

（你猜这和辗转相除法有什么关系）

**所以在 $1$ 至 $\frac{n}{d}$ 中，与 $\frac{n}{d}$ 互素的数的平均数是 $\frac{n}{2d}$。($\frac{n}{d}>1$)**

**重点4：积性函数能线性筛！！！**

所以将 $\frac{1}{2}$ 从求和中提出来：

$$=n\times (\frac{1}{2}+\sum\limits_{d|n}\frac{n}{2d}\times \varphi(\frac{n}{d}))$$

$$=\frac{n}{2}\times (1+\sum\limits_{d|n}\frac{n}{d}\times \varphi(\frac{n}{d}))$$

$$=\frac{n}{2}\times (1+\sum\limits_{d|n}d\times \varphi(d))$$

其中设 $f(n)=\sum\limits_{d|n}d\times \varphi(d)$，她是积性函数（证明交给读者）

$$=\frac{n}{2}\times(1+f(n))$$

时间复杂度：$O(n\log n+T)$

(感谢 [wkywkywky](https://www.luogu.com.cn/user/133954) 大佬指出的错误：这个 $log(n)$ 是下面代码 `while(ii%p[j]==0)` 得到的，所以不算严格的**线性**筛)

## 注意细节

线性筛时，素数（及素数的幂）的初值自己推一下。

## 完整代码

**禁  止  抄  袭**

```cpp
//https://www.luogu.com.cn/problem/P1891
#include<bits/stdc++.h>
#define For(i,j,k) for(register int i=j;i<=k;i++)
#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
using namespace std;
#define N 1000000
#define int long long//不开longlong见祖宗 

int n;
bool vis[N+10];//是否被筛过 
int p[N+10];//素数表 
int f[N+10];//积性函数 
void sieve(){//线性筛 
	f[1]=1;//积性函数f(1)=1 
	int k;
	int ii,jj;//替身 
	For(i,2,N){
		if(!vis[i]){//素数 
			f[i]=i*(i-1)+1;//素数初值
			p[++p[0]]=i; 
		}
		For(j,1,p[0]){//枚举最小素因子 
			k=i*p[j];
			if(k>N)break;//>max
			vis[k]=1;//你永远失去了当素数的机会 
			ii=i;
			jj=p[j];
			while(ii%p[j]==0){
				ii/=p[j];
				jj*=p[j];
			}
			//至此ii与jj互素 
			if(ii>1){
				f[k]=f[ii]*f[jj];
			}
			else{//k是p[j]的幂次 
				ii*=p[j];
				jj/=p[j];
				f[k]=f[jj]+k*(k-k/p[j]);//素数幂次递推 
			}
			if(i%p[j]==0) break;//最小素因子为p[j] 
		}
	} 
}
signed main(){
	IOS;
	sieve();
	int T;
	cin>>T;
	while(T--){
		cin>>n;
		//f[n]必为奇数 
		cout<<(1+f[n])/2*n<<endl;
	}
    return 0;
}
```

## Update 2021-8-19

![](https://i.loli.net/2021/08/18/CKNI5J9ODvbQupf.png)

所以存一下每个 $x\in[1,n]$ 中最小素因子的个数，将时间复杂度降到 $O(n+T)$（虽然 $O(n\log n+T)$ 也能过）。

代码先鸽着（记得催我）。

## Update 2021-8-23

不鸽了，开干~

**同  样  禁  止  抄  袭**

```cpp
#include<bits/stdc++.h>
#define For(i,j,k) for(register int i=j;i<=k;i++)
#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
using namespace std;
#define N 1000000
#define int long long//不开longlong见祖宗 

int n;
int part[N+10];//除最小素因子外剩余部分的值 
bool vis[N+10];//是否被筛过 
int p[N+10];//素数表 
int f[N+10];//积性函数 
void sieve(){//线性筛 
	f[1]=1;//积性函数f(1)=1 
	part[1]=1;
	int k;
	For(i,2,N){
		if(!vis[i]){//素数 
			f[i]=i*(i-1)+1;//素数初值
			p[++p[0]]=i; 
			part[i]=1;//本身就是最小素因子
		}
		For(j,1,p[0]){//枚举最小素因子 
			k=i*p[j];
			if(k>N)break;//>max
			vis[k]=1;//你永远失去了当素数的机会 
			if(i%p[j]){//不整除
				part[k]=i;
				f[k]=f[i]*f[p[j]];
			}else{
				part[k]=part[i];
				if(part[i]>1){//你心里还有别人
					f[k]=f[part[i]]*f[i/part[i]*p[j]]; 
				}else{//你心里没有别人
					f[k]=f[i]+k*(k-k/p[j]);//素数幂次递推 
				}
				break;
			} 
		}
	} 
}
signed main(){
	IOS;
	sieve();
	int T;
	cin>>T;
	while(T--){
		cin>>n;
		cout<<(1+f[n])/2*n<<endl;
	}
    return 0;
}
```

还是非常快的 OvO [评测记录](https://www.luogu.com.cn/record/56747682)

---

## 作者：VenusM1nT (赞：6)

欧拉函数。

$$\sum_{i=1}^{n}lcm(i,n)=\sum_{i=1}^{n}{in\over gcd(i,n)}=n\sum_{i=1}^{n}{i\over gcd(i,n)}$$

转化 $gcd$：

$$=n\sum_{d|n}\sum_{i=1}^{n}{i\over d}[gcd(i,n)=d]$$

$$=n\sum_{d|n}\sum_{i=1}^{n\over d}{i\over d}[gcd(id,n)=d]$$

$$=n\sum_{d|n}\sum_{i=1}^{n\over d}i[gcd(i,{n\over d})=1]$$

$$=n\sum_{d|n}\sum_{i=1}^{d}i[gcd(i,d)=1]$$

后面这个等于 ${φ(d)d}\over 2$，所以原式最终为：

$$=n\sum_{d|n}{{φ(d)d}\over 2}$$

可以预处理时把每个 $i$ 的倍数加上 ${φ(i)i}\over 2$，然后最后输出时乘上 $n$。（$i$ 等于 $1$ 时值为 $1$）。

```cpp
#include<bits/stdc++.h>
#define MAXN 1000000
#define ll long long
using namespace std;
int pri[MAXN+5],tot,phi[MAXN+5];
ll f[MAXN+5];
bool isp[MAXN+5];
void GetPrime()
{
	phi[1]=1;
	isp[1]=1;
	for(int i=2;i<=MAXN;i++)
	{
		if(!isp[i])
		{
			pri[++tot]=i;
			phi[i]=i-1;
		}
		for(int j=1;j<=tot && i*pri[j]<=MAXN;j++)
		{
			isp[i*pri[j]]=1;
			if(i%pri[j]) phi[i*pri[j]]=phi[i]*phi[pri[j]];
			else
			{
				phi[i*pri[j]]=phi[i]*pri[j];
				break;
			}
		}
	}
	for(int i=1;i<=MAXN;i++)
	{
		for(int j=1;i*j<=MAXN;j++) f[i*j]+=(i==1?1:1ll*phi[i]*i/2);
	}
}
int main()
{
	GetPrime();
	int Time;
	scanf("%d",&Time);
	while(Time--)
	{
		int n;
		scanf("%d",&n);
		printf("%lld\n",f[n]*1ll*n);
	}
	return 0;
}
```

---

## 作者：chihik (赞：5)

$$\sum_{i=1}^n lcm(i,n)$$

$$\sum_{i=1}^n \frac{i*n}{gcd(i,n)}$$

$$n\sum_{i=1}^n \frac{i}{gcd(i,n)}$$

$$n\sum_{d|n}\sum_{i=1}^n [gcd(i,n)=d]\frac{i}{d}$$

$$n\sum_{d|n}\sum_{i=1}^{\frac{n}{d}} [gcd(i,\frac{n}{d})=1]i$$

$$n\sum_{d|n}\sum_{i=1}^{d} [gcd(i,d)=1]i$$

令 $f(n)=\sum_{i=1}^ni[gcd(i,n)=1] , g(n)=\sum_{i|n} f(i)$

$$f(n)=\frac{1}{2} \sum_{i=1}^n i[gcd(i,n)=1]+(n-i)[gcd(n-i,n)=1]$$

$$=\frac{1}{2} \sum_{i=1}^n n[gcd(i,n)=1]$$

$$=\frac{n}{2} \sum_{i=1}^n [gcd(i,n)=1]$$

$$=\frac{n \times \varphi(n)}{2}$$

枚举因数预处理 $g(n)$，注意一下 $f(1)=1$。

答案为：$n \times g(n)$

```cpp
#include <cstdio>

const int MAXN = 1000000;
int t , n , k , prime[ MAXN + 5 ] , phi[ MAXN + 5 ];
long long g[ MAXN + 5 ];
bool vis[ MAXN + 5 ];

void sieve( ) {
	phi[ 1 ] = 1;
	for( int i = 2 ; i <= MAXN ; i ++ ) {
		if( !vis[ i ] ) {
			prime[ ++ k ] = i;
			phi[ i ] = i - 1;
		}
		for( int j = 1 ; j <= k && i * prime[ j ] <= MAXN ; j ++ ) {
			vis[ i * prime[ j ] ] = 1;
			if( i % prime[ j ] == 0 ) {
				phi[ i * prime[ j ] ] = phi[ i ] * prime[ j ];
				break;
			}
			phi[ i * prime[ j ] ] = phi[ i ] * ( prime[ j ] - 1 );
		}
	}

	for( int i = 1 ; i <= MAXN ; i ++ )
		for( int j = i ; j <= MAXN ; j += i )
			g[ j ] += i == 1 ? 1 : 1ll * phi[ i ] * i / 2;
}

int main( ) {
	sieve( );
	scanf("%d",&t);
	while( t -- ) {
		scanf("%d",&n);
		printf("%lld\n", n * g[ n ] );
	}
	return 0;
}
```


---

## 作者：xiaohuang (赞：1)

[更好的阅读体验](https://xiaohuang888.github.io/2019/08/01/%E3%80%8E%E9%A2%98%E8%A7%A3%E3%80%8FBZOJ2226%20[Spoj%205971]%20LCMSum)

### Solution

题目中的式子可以化简为：

$$\begin{aligned} \sum^{n}_{i = 1}{\text{lcm}(i, n)} &= \sum^{n}_{i = 1}{\frac{i \times n}{\gcd(i, n)}} \\ & = n \times \sum^{n}_{i = 1}{\frac{i}{\gcd(i, n)}} \\ & = n \times \sum_{d | n}\sum_{i = 1}^{n}\frac{i}{d} \times (d == \gcd(i, n)) \\ & = \frac{n}{d} \times \sum_{d | n}\sum^{n}_{i = 1}d == \gcd(i, n) \end{aligned}$$

$$\text{当}\gcd(i, n) == 1 \text{时，} \gcd(n - i, n) == 1 (i, n - i \ne 1) $$ 

$$\therefore \frac{n}{d} \times \sum_{d \mid n}\sum^{n}_{i = 1} d == \gcd(i, n)$$

$$= \sum_{i = 1}^{n} i \times (\gcd(i, n) == 1) = \frac{\varphi(d)}{2} \times n$$

### Code

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>

using namespace std;

typedef long long LL;
const int MAXN = 1000005;
int T;
LL n, cnt, ans[MAXN], phi[MAXN], prime[MAXN];
inline void calc_phi() {//计算phi函数
    phi[1] = 1;
    for (int i = 2; i <= MAXN; i++) {
        if (!phi[i]) {
            prime[++cnt] = i;
            phi[i] = i - 1;
        }
        for (int j = 1; j <= cnt; j++) {
            if (i * prime[j] >= MAXN) break;
            if (i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            } else phi[i * prime[j]] = phi[i] * (prime[j] - 1);
        }
    }
}
int main() {
    scanf("%d", &T);
    calc_phi();
    for (int i = 1; i <= MAXN; i++)
        for (int j = i; j <= MAXN; j += i)
            ans[j] += phi[(j / i)] * (j / i) + 1 >> 1;//最后推出的式子
    while (T--) {
        scanf("%lld", &n);
        printf("%lld\n", n * ans[n]);//最后主题要×n
    }
    return 0;
}
```

---

## 作者：liuzhangfeiabc (赞：1)

题意：给定n，求$\sum_{i=1}^n lcm(n,i)$

多组数据，t<=3e5,n<=1e6。

不同于各位julao推出来的线性式子，由于我实在是太菜了不会推式子，只好推一个不是很优秀但是勉强能算的式子凑个数啦。

看到t和n的范围差不多大，我们猜这可能是一个预处理所有答案然后O（1）查询的题。

于是我们开始愉快地推式子：

$\sum_{i=1}^n lcm(n,i)$

$=\sum_{i=1}^n \frac {n*i}{gcd(n,i)}$ //把lcm展开

$=n*\sum_{d|n} \sum_{i=1}^\frac {n}{d} \frac {i*d*[gcd(n,i)==d]}{d}$ //枚举n与i的gcd

$=n*\sum_{d|n} \sum_{i=1}^\frac {n}{d} i*[gcd(\frac{n}{d},i)==1]$ //同除以d

$=n*\sum_{d|n} \sum_{i=1}^\frac {n}{d} i \sum_{p|\frac{n}{d},p|i} \mu(p)$ //经典的反演

$=n*\sum_{d|n} \sum_{p|\frac{n}{d}} \mu(p) \sum_{i=1}^\frac {n}{dp} i*p $ //交换求和顺序

$=n*\sum_{d|n} \sum_{p|\frac{n}{d}} \frac{p*\mu(p)*\frac{n}{dp}*(\frac{n}{dp}+1)}{2}$ //等差数列求和

好推到这里我就推不下去了，我们看看我们得到了什么。

乍一看两层枚举很吓人，但定睛一看。。。这式子真的不能直接算吗？

因为枚举其实是在枚举一个数的因数的因数，而1~1e6范围内每个数的因数的因数个数之和并不是一个特别大的数字（在1e8这个量级左右）。

于是我们就可以枚举d,枚举p,再枚举它们乘积的倍数n来统计答案。

还可以加一些常数优化比如在最外层枚举p，这样可以省去计算$\mu(p)=0$时的不少位置的值。

于是这个题就这么过去了。。。过去了。。。去了。。。了。。。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define gc getchar()
#define pc putchar
#define li long long
inline li read(){
	li x = 0,y = 0,c = gc;
	while(!isdigit(c)) y = c,c = gc;
	while(isdigit(c)) x = (x << 1) + (x << 3) + (c ^ '0'),c = gc;
	return y == '-' ? -x : x;
}
inline void print(li q){
	if(q < 0) pc('-'),q = -q;
	if(q >= 10) print(q / 10);
	pc(q % 10 + '0');
}
li as[1000010];
bool notp[1000010];
int p[1000010],cnt,mu[1000010];
int main(){
	register int i,j,k,cnt = 0,t,n;
	notp[1] = mu[1] = 1;for(i = 2;i <= 1000000;++i){
		if(!notp[i]) p[++cnt] = i,mu[i] = -1;
		for(j = 1;j <= cnt && i * p[j] <= 1000000;++j){
			notp[i * p[j]] = 1;
			if(i % p[j] == 0) break;
			else mu[i * p[j]] = -mu[i];
		}
	}
	for(i = 1;i <= 1000000;++i) if(mu[i]) for(j = 1;i * j <= 1000000;++j) for(k = 1;i * j * k <= 1000000;++k) as[i * j * k] += 1ll * mu[i] * i * i * j * k * k * (k + 1) / 2;
	t = read();while(t--) print(as[read()]),pc('\n');
	return 0;
}
```

---


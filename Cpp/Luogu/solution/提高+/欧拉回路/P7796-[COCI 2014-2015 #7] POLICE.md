# [COCI 2014/2015 #7] POLICE

## 题目描述

在图书管理员 Jurica 的图书馆里有 $n$ 个书架，每个书架有 $m$ 个位置，从左往右编号为 $1$ 到 $m$，并且每个位置上都可以放一本书。Jurica 是一个好的图书管理员，所以他决定对图书馆进行清点，如果有必要，就把不在自己位置上的书放回原来的位置。具体来说，现在第 $i$ 个书架上的第 $j$ 个位置上面摆着编号为 $a_{i,j}$ 的书（如果 $a_{i,j}=0$ 说明这个位置上面现在没有书），而原来在这个位置上摆着编号为 $b_{i,j}$ 的书（如果 $b_{i,j}=0$ 说明这个位置上面原来没有书）。他以下列操作移动书籍：

- 操作 $1$：如果左边或右边有空位，可以在书架上向左或向右移动图书。
- 操作 $2$：从书架上取下一本书，放在该书架或其他书架的空位上。

细心的 Jurica 如果手中有书，就不能移动书。此外，他**不能同时拿多于一本书**。

自从他不得不把维基百科印刷版的所有书卷从一楼搬到二楼后，Jurica 就一直背痛。因为他的背很疼，所以现在他想把所有的书放好，尽量少搬。请告诉他需要的执行**操作 $2$ 的次数**最少是多少，或者告诉他根本不可能把这些书搬回原来的位置。

## 说明/提示

**【样例 1 解释】**

以下是 Jurica 的操作序列：

1. 操作 $1$：把 $1$ 号书籍移动到它右边的位置，也就是它所在书架上的第二个位置。
2. 操作 $2$：把 $2$ 号书籍搬到它所在书架上的第一个位置。
3. 操作 $2$：把 $5$ 号书籍搬到它所在书架上的第二个位置。

可以证明没有更少执行操作 $2$ 的方案。

**【数据范围】**

对于 $50\%$ 的数据，保证每本书在初始和最终状态下都会在同一个书架上。  
对于所有数据，$1\leqslant n,m\leqslant 1000$。

**【题目来源】**

本题来源自 **_[COCI 2014-2015](https://hsin.hr/coci/archive/2014_2015/) [CONTEST 7](https://hsin.hr/coci/archive/2014_2015/contest7_tasks.pdf) T6 POLICE_**，按照原题数据配置，满分 $160$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
2 4
1 0 2 0
3 5 4 0
2 1 0 0
3 0 4 5```

### 输出

```
2```

## 样例 #2

### 输入

```
3 3
1 2 3
4 5 6
7 8 0
4 2 3
6 5 1
0 7 8```

### 输出

```
4```

## 样例 #3

### 输入

```
2 2
1 2
3 4
2 3
4 1```

### 输出

```
-1```

# 题解

## 作者：little_sheep917 (赞：6)

> 图书馆里有 $n$ 个书架，每个书架可以放 $m$ 本书。小C是一位优秀的图书管理员，所以他决定整理图书馆中的所有图书，如果可以的话，把所有图书放回它们原来的位置。他打算用下面的方法来整理图书：
>
>   1.如果书架上的某本书的左边或右边是空的，就可以把这本书书向左或向右移动。
>
>   2.把一本书从书架上拿起来，再放回到另一个空的位置（可以是任意一个书架）。
>
> 可是没过多久小 C 就累了。如果他手上已经有了一本书，他就不能再移动其他的书。而且因为把书拿出来又放回去实在太麻烦了，所以小 C 希望尽可能少地将书从书架上拿起来（即步骤2）。请帮小 C 算出，他最少需要将书拿出来多少次。
>
> $1\leq n,m\leq 1000$

感觉做法挺奇妙的 . 

一行一行地考虑 .

先考虑当前行和最终行出现书本相同的情况 . 此时，又分出来两种 ，有空位和无空位 .

1. 有空位，相当于，找到一本书，再放到它原本的位置上 . 那么，要选出 $k$ 本书，这 $k$ 本书相对顺序是正确的，其他的书要根据这 $k$ 本书的位置放入 . 会发现，这是一个 lis 的问题 . 那么，可以 $O(n\log n)$ 地解决.
2. 没有空位，此时分为两种情况 .
   - 当前行与目标行相同 . 无需操作 .
   - 当前行与目标行不同，如果其他书架上没有空位，则输出 -1 . 否则，将当前行中一本不位于 $k$ 本书中的书放到其他书架上，再将当前行排序，排完序后直接插入正确的位置，时间复杂度为 $O(n\log n)$ .

考虑玩当前行和最终行出现书本相同的情况，下面就是不同的 .

如果最终应该出现在第 $j$ 行的书出现在了第 $i$ 行，那么，由 $i$ 向 $j$ 连一条有向边 ，得到一个有向图 $G_1$ ；将 $G_1$ 中的有向边变成无向，可以得到一个无向图 $G_2$ . 对于 $G_2$ 中的每一个连通块，在 $G_1$ 中可以加上一些虚构的有向边，是的其变成一个具有欧拉回路的图 . 

那么，对于这个欧拉回路，就是一个移动的方案，但是，这个方案的开始，必定是存在一个连通块中的行有一个空位 . 如果其他的行没有空位的话，那么，必定是不可行的，要输出 -1 .否则，如果连通块不存在空位，需要拿出一本书放在另一行中，然后再移动 ，代价加 $1$ . 

因为从当前书架拿起，放到其他书架的书必定花费代价 $1$ ，而且必定会放到正确的相对位置上 . 代价就是原来就同时存在与当前和最终行中的书的和 - 当前和最终行中的书的和的 lis + 在最终行但不在当前行的书的数量 . 再加上启动时可能需要的 $1$ 代价. 

时间复杂度 : $O(nm\log n)$

空间复杂度 : $O(nm)$

code

```c++
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	int res=0;
	while(ch>='0'&&ch<='9'){
		res=res*10+ch-'0';
		ch=getchar();
	}
	return res;
}
inline void print(int res){
	if(res==0){
		putchar('0');
		return;
	}
	int a[8],len=0;
	while(res>0){
		a[len++]=res%10;
		res/=10;
	}
	for(int i=len-1;i>=0;i--)putchar(a[i]+'0');
}
const int inf=1e9+10;
int n,m;
int a[1010][1010],b[1010][1010],nu[1010*1010];
int pos[1010*1010];
bool ok[1010],spare=false;
int exist[1010*1010];
int ans=0;
int bit[1010];
inline void upd(int i,int val){
	while(i<=m){
		bit[i]=max(bit[i],val);
		i+=i&-i;
	}
}
inline int qry(int i){
	int res=0;
	while(i){
		res=max(res,bit[i]);
		i-=i&-i;
	}
	return res;
}
vector<int>v,g[1010];
bool vis[1010];
void dfs(int x){
	vis[x]=true;v.push_back(x);
	for(int i=0;i<(int)g[x].size();i++){
		int to=g[x][i];
		if(!vis[to])dfs(to);
	}
}
int solve(int id){
//	cout<<endl;
//	for(int i=0;i<m;i++)cout<<a[id][i]<<" ";cout<<endl;
//	for(int i=0;i<m;i++)cout<<b[id][i]<<" ";cout<<endl;
	int cnt=0;
	for(int i=0;i<m;i++)if(a[id][i]>0)nu[a[id][i]]=cnt++;
	for(int i=0;i<=m;i++)bit[i]=0;
	for(int i=0;i<m;i++)if(b[id][i]>0)
		upd(nu[b[id][i]]+1,qry(nu[b[id][i]])+1);
	int mx=0;
	for(int i=1;i<=cnt;i++)mx=max(mx,qry(i));
	return mx;
}
int na[1010],nb[1010];
void solve(vector<int>v){
	bool sp=false;
	for(int i=0;i<(int)v.size();i++){
		int id=v[i];
		for(int j=0;j<m;j++)if(a[id][j]==0)sp=true;
	}
	int cnt=0;
	for(int i=0;i<(int)v.size();i++){
		int id=v[i];
		for(int j=0;j<m;j++)if(a[id][j]>0)exist[a[id][j]]++,cnt++;
		for(int j=0;j<m;j++)if(b[id][j]>0)exist[b[id][j]]++;		
		for(int j=0;j<m;j++)na[j]=a[id][j];
		for(int j=0;j<m;j++)nb[j]=b[id][j];
		for(int j=0;j<m;j++)if(a[id][j]>0&&exist[a[id][j]]<2)a[id][j]=0;
		for(int j=0;j<m;j++)if(b[id][j]>0&&exist[b[id][j]]<2)b[id][j]=0;
		ans-=solve(id);
		for(int j=0;j<m;j++)a[id][j]=na[j];
		for(int j=0;j<m;j++)b[id][j]=nb[j];
		for(int j=0;j<m;j++)if(a[id][j]>0)exist[a[id][j]]--;
		for(int j=0;j<m;j++)if(b[id][j]>0)exist[b[id][j]]--;
	}
//	putchar('\n');
	ans+=cnt;
	if(!sp){
		if(!spare){
			putchar('-');
			putchar('1');
			exit(0);
		}
		else ans++;
	}
}
int main(){
//	freopen("test.txt","r",stdin);
	n=read();m=read();
	for(int i=0;i<n;i++)for(int j=0;j<m;j++)a[i][j]=read();
	for(int i=0;i<n;i++)for(int j=0;j<m;j++)b[i][j]=read();
	for(int i=0;i<n;i++)for(int j=0;j<m;j++)if(a[i][j]==0)spare=true;
	for(int i=0;i<n;i++){
		bool flag=true;
		int cnt=0;
		for(int j=0;j<m;j++){
			if(a[i][j]>0){
				exist[a[i][j]]=true;
				cnt++;
			}
		}
		for(int j=0;j<m;j++){
			if(b[i][j]>0){
				if(!exist[b[i][j]])
					flag=false;
				else exist[b[i][j]]=false;
			}
		}
		for(int j=0;j<m;j++){
			if(exist[a[i][j]]){
				flag=false;
				exist[a[i][j]]=false;
			}
		}
		if(flag){
			ok[i]=true;
			int tmp=cnt-solve(i);
			ans+=tmp;
			if(cnt==m&&tmp!=0){
				if(!spare){					
					putchar('-');
					putchar('1');
					return 0;
				}
				else ans++;
			}
		}
	}
//	for(int i=0;i<n;i++)print(ok[i]),putchar(' ');
//	putchar('\n');
	for(int i=0;i<n;i++)for(int j=0;j<m;j++)if(a[i][j]>0&&(!ok[i]))pos[a[i][j]]=i;
	for(int i=0;i<n;i++)for(int j=0;j<m;j++){
		if(b[i][j]>0&&(!ok[i])&&pos[b[i][j]]!=i){
		//	print(pos[b[i][j]]);putchar(' ');print(i);putchar('\n');
			g[pos[b[i][j]]].push_back(i);
			g[i].push_back(pos[b[i][j]]);
		}
	}
	for(int i=0;i<n;i++)if((!ok[i])&&(!vis[i])){
		v.clear();
		dfs(i);
	//	for(int j=0;j<(int)v.size();j++)print(v[j]),putchar(' ');
		solve(v);
	}	
	print(ans);
	return 0;
}
/*inline? ll or int? size? min max?*/

```



---

## 作者：elbissoPtImaerD (赞：4)

挺有意思的。
# 
先考虑特殊性质：每本书初始和最终状态下都会在同一个书架上。

这相当于 [CF1839D](http://codeforces.com/problemset/problem/1839/D)。

按 $b$ 的出现顺序重标号之后求个 LIS 即可。

特别地，当当前书架没有空位时，我们要花费额外的一次操作将某一本书移到别的书架上。

复杂度 $\mathcal{O(nm\log m)}$。
# 
再考虑存在书本初始书架和最终书架不同。

套路地，如果某一本书要从 $i$ 书架移到 $j$ 书架，我们连边 $(i,j)$（我们称为操作边）。

显然每条操作边都要被经过一次。

而且每条操作边只需恰好经过一次：考虑，我们重复执行以下操作直至所有点入度和出度相等：选择任一个入度大于出度的点和任一个出度大于入度的点，将他们连一条边（记作辅助边），这样整幅图就存在一条欧拉回路，我们走操作边相当于移动书本，走辅助边相当于无事发生。

所以操作次数要加上边的条数。

特别地，将有向边视为无向边，则若当前连通块中没有一个书架存在空位，我们也要额外操作一次，将某本书移到别的书架上。

使用并查集维护连通块信息，复杂度 $\mathcal{O(nm\log n)}$。

总复杂度 $\mathcal{O(nm\log nm)}$。
# 
最后，由于我们的做法默认了至少有一个书架存在空位，所以无解当且仅当没有书架存在空位且初态不等于末态。
# 
细节看代码：
```cpp
const int N=1e3+3;
int n,m,a[N][N],b[N][N],cnt,h[N*N];
pii e[N*N];
struct BITS
{
  int c[N],n;
  BITS(int n_){n=n_,sd fill(c+1,c+n+1,0);}
  il void _M(int x,int y)
  {
    for(;x<=n;cx(c[x],y),x+=x&-x);
    return;
  }
  il int _Q(int x)
  {
    int s=0;
    for(;x;cx(s,c[x]),x-=x&-x);
    return s;
  }
};
il int Calc(int id)
{
  BITS S(m);
  sd vector<pii>_;
  sd vector<int>c(m+1);
  for(int i=1;i<=m;++i) if(a[id][i]) _.pb(a[id][i],i);
  sd stable_sort(begin(_),end(_));
  for(int i=0;i<_.size();++i) c[_[i].y]=i+1;
  for(int i=1;i<=m;++i) if(a[id][i]&&e[a[id][i]].x==e[a[id][i]].y) S._M(c[i],S._Q(c[i]-1)+1);
  return sd count_if(a[id]+1,a[id]+m+1,[&](int x){return x&&e[x].x==e[x].y;})-S._Q(m);
}
struct DSU
{
  int f[N],g[N];
  DSU(int n)
  {
    sd iota(f+1,f+n+1,1),sd fill(g+1,g+n+1,0);
    for(int j=1;j<=n;++j) for(int i=1;i<=m;++i) g[j]|=!a[j][i]||!b[j][i];
    for(int j=1;j<=n;++j)
    {
      bool tg=true;
      for(int i=1;i<=m;++i) tg&=a[j][i]==b[j][i];
      if(tg) g[j]=1;
    }
  }
  int F(int x){return f[x]^x?f[x]=F(f[x]):x;}
  il void _M(int x,int y){if((x=F(x))^(y=F(y))) f[x]=y,g[y]|=g[x];}
};
il void Solve()
{
  rd(n),rd(m);
  bool tg=true;
  for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) rd(a[i][j]);
  for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) rd(b[i][j]);
  for(int i=1;i<=n;++i) for(int j=1;j<=m;++j)
    if(b[i][j]) e[h[b[i][j]]=++cnt].x=i,b[i][j]=cnt;
    else tg=false;
  for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) if(a[i][j])
    e[a[i][j]=h[a[i][j]]].y=i;
  if(tg)
  {
    tg=false;
    for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) tg|=a[i][j]!=b[i][j];
    wrt(tg?-1:0);
    return;
  }
  int ans=0;
  for(int i=1;i<=n;++i) ans+=Calc(i);
  DSU S(n);
  for(int i=1;i<=cnt;++i) if(e[i].x^e[i].y) ++ans,S._M(e[i].x,e[i].y);
  for(int i=1;i<=n;++i) if(S.f[i]==i) ans+=!S.g[i];
  wrt(ans);
  return;
}
```
[$\color{green}{\checkmark}$](https://www.luogu.com.cn/record/135501902)。

---

## 作者：fydj (赞：3)

# [P7796 [COCI2014-2015#7] POLICE](https://www.luogu.com.cn/problem/P7796)

### 题目大意

有 $n$ 个书架，每个书架有 $m$ 个位置，现在第 $i$ 个书架上第 $j$ 个位置放着编号为 $a_{i,j}$ 的书，$a_{i,j}=0$ 表示这个位置没有书，目标是把第 $i$ 个书架上第 $j$ 个位置书架上书的状态变为 $b_{i,j}$，有这样两个操作：

* 如果左边或右边有空位，可以在书架上向左或向右移动图书，不耗费代价。
* 从书架上取下一本书放在空位上，耗费一代价。

求变为目标状态最少耗费多少代价。

### 思路

先考虑特殊性质。保证每本书在初始和最终状态下都会在同一个书架上时，把书按照目标状态上的书架从左到右按顺序标号，这样每本书都有它的编号。每一个书架上不需要被移动的书是编号在初始书架的最长上升子序列中的书，其它的书本都是需要被移动的。求有几本书不需要被移动实际上就是求原书架的 LIS 就行了。

再考虑一般情况。一本书如果要移动到其它书架上，假设它从 $i$ 书架一道 $j$ 书架上，那么往点 $i$ 到点 $j$ 连一条边。可以发现，对于一个连通块，总可以找到一种移动方法来让书移动到正确的地方。一开始启动的时候要有一个空位，那么如果一个连通块没有空位，就要额外移动一次去创造一个空位。连通块有没有空位可以用并查集维护。如果一本书开始时在哪个书架最后就在哪个书架，那么把这些书单独拿出来，做一遍特殊性质。

所以最后的答案就是：书的本数 - 每一行的 LIS + 启动代价。

### 代码

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#define N 1099
using namespace std;
typedef long long ll;
char chart; bool fushu;
template <typename T> void read(T &a) { a=fushu=0; do chart=getchar(); while((chart<48||chart>57)&&chart!='-'); if(chart=='-') fushu=1,chart=getchar(); do a=(a<<1)+(a<<3)+(chart^48),chart=getchar(); while(chart>47&&chart<58); if(fushu) a=-a; return ; }
template <typename T,typename ...Args> void read(T &a,Args &...args) { read(a); read(args...); return ; }
int n,m,a[N][N]={},b[N][N]={},v[N*N]={},ceng[N*N]={},cnt[N]={},cv=0,fa[N]={},tag[N]={},ans=0;
struct BITS {
	#define lowbit(x) ((x)&-(x))
	int tr[N*4];
	int get(int x) {
		int rey=0;
		while(x)
			rey=max(rey,tr[x]),
			x-=lowbit(x);
		return rey;
	}
	void put(int x,int val) {
		while(x<=m)
			tr[x]=max(tr[x],val),
			x+=lowbit(x);
		return ;
	}
	#undef lowbit
};
int lis(int u)
{
	int i,x,dp,rey=0;
	BITS f={};
	for(i=1;i<=m;++i)
		if(a[u][i]&&ceng[a[u][i]]==u) {
			x=v[a[u][i]];
			dp=f.get(x-1)+1;
			rey=max(rey,dp);
			f.put(x,dp);
		}
	return rey;
}
int father(int x) { return fa[x]=fa[x]==x?x:father(fa[x]); }
void link(int x,int y) { fa[father(x)]=father(y); return ; }
bool ok()
{
	int i,j;
	for(i=1;i<=n;++i)
		for(j=1;j<=m;++j)
			if(a[i][j]!=b[i][j])
				return false;
	return true;
}
bool oks(int x)
{
	int i;
	for(i=1;i<=m;++i)
		if(a[x][i]!=b[x][i])
			return false;
	return true;
}
int main()
{
//	freopen("librarian.in","r",stdin);
//	freopen("librarian.out","w",stdout);
	int i,j,ckflag=0;
	read(n,m);
	for(i=1;i<=n;++i) {
		for(j=1;j<=m;++j) {
			read(a[i][j]);
			if(a[i][j])
				++cnt[i];
		}
		if(cnt[i]!=m) ckflag=true;
	}
	for(i=1;i<=n;++i) {
		for(j=1;j<=m;++j) {
			read(b[i][j]);
			if(b[i][j])
				v[b[i][j]]=++cv,
				ceng[b[i][j]]=i;
		}
		fa[i]=i,tag[i]=0,ans+=cv,cv=0;
	}
	if(!ckflag) {
		if(ok()) printf("0");
		else printf("-1");
		return 0;
	}
	for(i=1;i<=n;++i)
		for(j=1;j<=m;++j)
			link(i,ceng[a[i][j]]);
	for(i=1;i<=n;++i)
		if(cnt[i]!=m)
			tag[father(i)]=true;
	for(i=1;i<=n;++i) {
		ans-=lis(i);
		if(i==father(i)&&!tag[i]&&!oks(i))
			++ans;
	}
	printf("%d",ans);
}
```

### 时空复杂度

时间复杂度 $O(nm \log m)$。

空间复杂度 $O(nm)$。

---

## 作者：chenwenmo (赞：1)

先判掉无解或初始就满足的情况，那就是初始一个空格都没有。

考虑 $50\%$ 的部分分，我们单独考虑每一行：

- 若这一行没满，由于每个数至多进行一次 操作2，那么我们肯定想让最多的数不操作，于是求最长上升子序列即可。

- 否则，需要把某个需要移动的数移到其他行，然后进行上面的计算，最后再移回来，最后答案 $+1$。

考虑正常情况：

对于所有不在目标行的数，它需要移动到目标行。

显然直接考虑会太复杂，关系太乱了，我们考虑建图。

以每一行作为节点，这个点的每个出边代表这一行需要移动一次到其他行。

然后我们把有向边换成无向边，发现可以对于每个连通块分别考虑：

- 若一个连通块一个空格都没有，那么每个点的入度等于出度，于是这个连通块代表的有向图构成一个欧拉回路。那么我们从任意一个不在目标行的数开始，把它移动到其他连通块的空格上，然后沿着反向边走，每条边只走一次，每次把终点的数移动到起点。然后回到原点之后，再把这个原点代表的数移到目标位置。

- 若有空格，那这个图不一定是欧拉回路。

  我们可以每次任意选两个点，满足一个点入度大于出度，一个点入度小于出度，然后 "入度大于出度" 连有向边到 "入度小于出度"。一直进行这样的操作，直到这个图是欧拉回路。

  称后面加进来的边为虚拟边。

  我们初始从空格开始，沿着反向边走，若走的是原来的边，就把终点的数移到起点；若走的是虚拟边，不进行操作。

  那么需要保证虚拟边反向边的终点一定存在空格：因为这个终点一定是入度大于出度的，因此它的空格个数一定 $\ge$ 入度减出度。

于是只需要知道每个连通块的边数，以及空格数，就可以计算出答案。这样就考虑完了行间的移动。

考虑行内，

- 发现，若一个行代表的节点不是孤点，那么它一定存在某一时刻有空格（因为它有出度或者入度，不然就是孤点了），那么在第一次有空格的时刻（其他数还没移进来），我们可以把 目标行就是当前行 的数，按照 $50\%$ 的做法排好序，然后有数插入时，直接插入到正确位置即可。就不需要再判断是否有空格。

- 那如果是孤点的话，那就按照部分分的判断和计算方法即可。

具体细节见代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
using UI = unsigned int;
using ULL = unsigned long long;
using DB = double;
using LDB = long double;
using PII = pair<int, int>;
using PLL = pair<LL, LL>;
#define CP(x) complex<x>
#define fst first
#define snd second
#define popcnt(i) __builtin_popcount(i)

const int N = 1e3 + 5, V = 1e6 + 5;

int n, m, a[N][N], b[N][N], cnt0[N], pos[V];
int des[V]; // destination
bool vis[N];

struct DSU {
    int fa[N], siz[N], cnt[N], sum[N];

    void init(int n) {
        for (int i = 1; i <= n; i++) {
            fa[i] = i;
            sum[i] = cnt0[i];
            siz[i] = 1;
        }
    }

    int find(int x) { return (fa[x] == x ? x : fa[x] = find(fa[x])); }

    bool merge(int x, int y) {
        int fx = find(x), fy = find(y);
        if (fx == fy) {
            cnt[fy]++;
            return false;
        }
        fa[fx] = fy;
        siz[fy] += siz[fx];
        sum[fy] += sum[fx];
        cnt[fy] += cnt[fx] + 1;
        return true;
    }
} D;

void solve() {
    cin >> n >> m;
    int tot = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> a[i][j];
            if (!a[i][j]) {
                tot++;
                cnt0[i]++;
            }
        }
    }
    bool flag = true;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> b[i][j];
            if (b[i][j]) des[b[i][j]] = i;
            if (a[i][j] != b[i][j]) flag = false;
        }
    }

    if (!tot) {
        cout << (flag ? 0 : -1) << '\n';
        return;
    }

    int ans = 0;

    D.init(n);

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (a[i][j] && des[a[i][j]] != i) D.merge(i, des[a[i][j]]);
        }
    }

    vector<int> f;
    for (int i = 1; i <= n; i++) {
        int num = 0;
        for (int j = 1; j <= m; j++) {
            if (des[a[i][j]] == i) {
                pos[a[i][j]] = j;
                num++;
            }
        }
        f.clear();
        for (int j = 1; j <= m; j++) {
            if (pos[b[i][j]]) {
                if (f.empty() || pos[b[i][j]] > f.back()) f.push_back(pos[b[i][j]]);
                else f[upper_bound(f.begin(), f.end(), pos[b[i][j]]) - f.begin()] = pos[b[i][j]];
            }
        }
        if (num != f.size()) ans += num - f.size() + (D.siz[D.find(i)] == 1 && !cnt0[i]);
    }

    for (int i = 1; i <= n; i++) {
        int f = D.find(i);
        if (vis[f]) continue;
        vis[f] = true;
        if (D.cnt[f]) ans += D.cnt[f] + (!D.sum[f]);
    }

    cout << ans << '\n';
}

int main() {
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    solve();
    return 0;
}
```

---


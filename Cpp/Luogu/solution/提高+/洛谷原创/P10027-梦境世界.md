# 梦境世界

## 题目背景

哆来咪爱旅行。

## 题目描述

有一个长为 $n$ 宽为 $m$ 的网格，其左上角编号为位置 $(1, 1)$ 而右下角编号为位置 $(n, m)$。哆来咪想要从左上角走到右下角，每次她可以往右或向下走一格，但不能超出 $n\times m$ 的网格边界。除此之外，有 $s$ 个禁止点是哆来咪无法走到的。

哆来咪有 $k$ 个神奇药水，喝药水可以撤销之前最后一次没有被撤销的行走操作，但移动序列并不会删去最后一个元素。当然，在 $(1, 1)$ 位置时不能使用药水，且 **药水不会撤销上一个药水的操作**。例如：从 $A$ 到 $B$ 后，在 $B$ 处喝了药水，则移动序列为 $A \to B \to A$；从 $A$ 走到 $B$ 再走到 $C$，连续喝下两次药水，移动序列为 $A \to B \to C \to B \to A$。

哆来咪认为一次 **旅行** 是指一次最终走到 $(n, m)$ 的行走路线。哆来咪想要求本质不同的 **旅行** 个数，答案对给定 $p$ 取模。哆来咪认为两次 **旅行** 不同，当且仅当两次旅行记录的移动序列不同。

## 说明/提示

### 样例解释 1

七种路线如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/0t9so91p.png)

### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 0（10pts）：$1 \le n, m \le 100$，$k=0$。
- Subtask 1（15pts）：$1 \le n, m \le 10$，$k=1$。
- Subtask 2（15pts）：$n=1$，$m \le 100$，$k \le 100$。
- Subtask 3（25pts）：$1 \le n, m \le 100$，$k \le 10$。
- Subtask 4（35pts）：无特殊限制。


对于所有数据，保证 $1 \le n, m \le 100$，$0 \le k \le 100$，$2 \le p \le 10^9 + 9$，$0 \le s \le n \times m$，$1 \le x_i \le n$，$1 \le y_i \le m$，且 $(x_i, y_i)$ 互不相同。


## 样例 #1

### 输入

```
2 2 2 998244353 1
1 2```

### 输出

```
7```

## 样例 #2

### 输入

```
5 5 0 114514 0```

### 输出

```
70```

## 样例 #3

### 输入

```
5 5 3 998244353 3
3 4
2 5
4 4```

### 输出

```
13782```

# 题解

## 作者：saixingzhe (赞：8)

# 题意

求二元组序列 $A_s$ 的数量，满足：

1. $A_1 = (1, 1), A_s = (n, m), \forall A_i = (x, y), 1 \leq x \leq n \land 1 \leq y \leq m \land (x, y) \notin F$；
2. 对于 $A$ 的每相邻两个元素 $A_i(x_0, y_0), A_{i+1}(x_1, y_1)$，要么：
+ $x_0 = x_1, y_0 = y_{1 + 1}$；
+ $y_0 = y_1, x_0 = x_{1 + 1}$；
+ $\exist k, s.t. A_{i+1} = A_{(i+1)-2k}, A_{i} = A_{i-2(k-1)}$（撤销操作，很抽象而且可能有问题，所以需要参考原题面理解）。

并且：所有满足第三步的 $i, i+1$ 对数 $\leq k$。

求合法 $A$ 数量 $\bmod\ p$。

$1 \leq n, m, k \leq 100, 2\leq p \leq 10^9 + 9, 0 \leq \lvert F \rvert \leq n\times m$。

# 思路

一看就是一个类 dp 状物。

dp 从 $(1, 1)$ 走到某个特定的格子感觉很难做，因为后面有很多我们暂时还没有 dp 到的东西！（显然我们需要把撤销操作写进状态。）

于是考虑倒着 dp，令 $f_{i,j,k}$ 表示从 $(i, j)$ 出发使用 $k$ 次撤销操作走到 $(n, m)$ 的方案数，$g_{i,j,k}$ 表示从 $(i, j)$ 出发使用 $k$ 次前进和撤销操作后**恰好回到** $(i, j)$ 的方案数，$h_{i, j, k}$ 表示从 $(i, j)$ 出发使用 $k$ 次前进和撤销操作后**回到** $(i, j)$ 的方案数。计数时调用方式 $f \gets h \gets g$，初始状态 $f_{n,m,0} = g_{n,m,0} = h_{n,m,0} = 1$，特判 $(n, m)$ 有障碍特殊情况。

+ Step 1：计算 $g$

显然根据方格取数的方法，$g_{i,j,k} = h_{i,j+1,k-1}+h_{i+1,j,k-1}$（这里右边不是 $g$！否则你可能只有 $20$ 分）。

+ Step 2：计算 $h$

枚举上一个在这个点出去的 $g$ 是多少，则 $h_{i,j,0} = 1, h_{i,j,k} = \sum\limits_{l=1}^k g_{i,j,l}\times h_{i,j,k-l}$。

+ Step 3：计算 $f$

枚举在这个点往外撤销了多少步，则 $f_{i,j,k} = \sum\limits_{l=0}^k h_{i,j,l} \times (f_{i+1,j,k-l} + f_{i,j+1,k-l})$。

所有不合法状态：$i \gt n, j \gt m, (i, j)$ 处有障碍，这时应将 $f,h,g$ 视为 $0$。

然后求个和就结束了。空间复杂度 $\mathcal O(nmk)$，时间复杂度 $\mathcal O(nmk^2)$。

# 代码

```cpp
#include <bits/stdc++.h>

#define MAXN 105
bool var[MAXN][MAXN];

#define MAXK 101
int f[MAXN][MAXN][MAXK], g[MAXN][MAXN][MAXK], h[MAXN][MAXN][MAXK];

int N, M, K, P, S;
inline void add(int& a, int b) { (a += b) >= P && (a -= P); }
inline int sum(int a, int b) { return (a += b) < P ? a : a - P; }
int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr), std::cout.tie(nullptr);
	std::cin >> N >> M >> K >> P >> S;
	for (int i = 1, x, y; i <= S; ++i) 
		std::cin >> x >> y, var[x][y] = true;
	for (int i = N; i; --i) for (int j = M; j; --j) {
		if (i == N && j == M) {
			if (var[i][j]) return std::cout << 0, 0;
			f[i][j][0] = g[i][j][0] = h[i][j][0] = 1;
			continue;
		}
		if (var[i][j]) continue;
		h[i][j][0] = g[i][j][0] = 1;
		f[i][j][0] = sum(f[i + 1][j][0], f[i][j + 1][0]);
		for (int k = 1; k <= K; ++k) {
			g[i][j][k] = sum(h[i + 1][j][k - 1], h[i][j + 1][k - 1]);
			for (int l = 1; l <= k; ++l) 
				add(h[i][j][k], 1ll * h[i][j][k - l] * g[i][j][l] % P);
			for (int l = 0; l <= k; ++l) 
				add(f[i][j][k], 1ll * h[i][j][l] * (f[i + 1][j][k - l] + f[i][j + 1][k - l]) % P);
		}
	}
	int ans = 0;
	for (int k = 0; k <= K; ++k) add(ans, f[1][1][k]);
	return std::cout << ans, 0;
}
```

---

## 作者：tobie (赞：7)

药水喝一瓶少一瓶，人只能往右下走不能回头，非常满足无后效性，考虑dp。

每一次行走可以认为是多次前进+回溯的过程。所以我们定义 $F_{i,j,k}$ 表示当前在 $(i,j)$，喝 $k$ 瓶药水，并且**最终回到** $(i,j)$ 的情况数。

然后我们再定义 $G_{i,j,k}$ 表示当前在 $(i,j)$，手上有 $k$ 瓶药水，并且**在终点前全部喝完**的情况数。

那么就可以愉快地 dp 了~

$$F_{i,j,k}\leftarrow F_{i,j,t}\times(F_{i+1,j,k-t-1}+F_{i,j+1,k-t-1})$$
$$G_{i,j,k}\leftarrow F_{i,j,t}\times(G_{i+1,j,k-t}+G_{i,j+1,k-t})$$

注意一下循环顺序以及一些代码细节，那么这题就做完了~
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define int long long
const int N=109;
int ma[N][N],mod;
int n,m,k,s;
int f[N][N][N],g[N][N][N];
signed main()
{
	scanf("%lld%lld%lld%lld%lld",&n,&m,&k,&mod,&s);
	for(int i=1,x,y;i<=s;i++) scanf("%lld%lld",&x,&y),ma[x][y]=1;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	if(!ma[i][j]) f[i][j][0]=1;
	for(int k1=1;k1<=k;k1++)
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	if(!ma[i][j])
	{
		for(int k2=0;k2<k1;k2++)
		f[i][j][k1]=(f[i][j][k1]+f[i][j][k2]*(f[i+1][j][k1-k2-1]+f[i][j+1][k1-k2-1])%mod)%mod;
	}
	g[n][m][0]=1;
	for(int k1=0;k1<=k;k1++)
	{
		for(int i=n;i>=1;i--)
		for(int j=m;j>=1;j--)
		if(!ma[i][j])
		for(int k2=0;k2<=k1;k2++)
		g[i][j][k1]=(g[i][j][k1]+f[i][j][k2]*(g[i+1][j][k1-k2]+g[i][j+1][k1-k2])%mod)%mod;
	}
	int ans=0;
	for(int k1=0;k1<=k;k1++) ans=(ans+g[1][1][k1])%mod;
	printf("%lld\n",ans);
}
```

---

## 作者：Missa (赞：3)

场切了这题，写个题解。

看到对本质不同的序列计数，先考虑什么样的序列是合法的。发现好像不是那么好做。然后考虑走的过程能不能分阶段考虑。发现，去掉撤回的所有操作后，剩下的所有操作构成起点到终点的、不回头的路径。我们需要不回头的性质，这样才可以 dp。

把所有被撤回的操作拎出来考虑，发现一段连续的被撤回的操作的实质是从一个点出发绕圈后回到这个点。仔细一想发现所有合法序列都可以如此描述：先生成起点到终点的不撤回序列，在每个点处绕圈后回到这个点。

设辅助 dp 数组 $f_{u, i}$ 表示：从点 $u$ 出发，走 $i$ 步并撤回这 $i$ 步的方案数。注意这里直接在删掉不可走点后形成的 DAG 上考虑问题。

怎么不重不漏呢。考虑枚举走出的第一步以及撤回这一步的时间，$f_{u, i} = \sum _{(u, v) \in E}f_{v, j} f_{u, i-j-1}$。注意那个 $-1$ 就是撤回 $u \to v$。

设 $g_{u, i}$ 表示走到 $u$ 并已经撤回了 $i$ 步。更新时枚举那条没有被撤回的边。走到一个点时先处理在这个点处绕圈的情况。也就是 $g_{u, i} \to g_{v, u}, (u, v) \in E$ 以及 $g_{u, i} \gets g_{u, j} f_{u, i-j}$，注意第二个转移只在每个点被更新完后发生一次。

若被撤回的边为虚边，其余边为实边，我们把虚边缩在一起，挂在那个绕了一圈回到的点上，按照实边、虚环、实边、虚环的顺序转移，因为实边是 DAG 上的边，显然不会算重。显然这也不会算漏。

代码实现中事实上把描述中的点 $u$ 变成了 $(x, y)$ 并只保留了合法点。自认为很清晰。请开 c++20 编译。

```cpp

int main() {
  int n, m, sum, q; scanf("%d %d %d %d %d", &n, &m, &sum, &mod, &q);
  #define valid(x, y) (0 <= x && x < n && 0 <= y && y < m && a[x][y])
  std::vector f(n, std::vector(m, std::vector<modint>(sum + 1)));
  auto g = f;
  std::vector a(n, std::vector<int>(m, 1));
  for (int i = 0, x, y; i < q; i++) {
    scanf("%d %d", &x, &y), --x, --y;
    a[x][y] = 0;
  }
  for (int i = n - 1; i >= 0; i--) {
    for (int j = m - 1; j >= 0; j--) {
      f[i][j][0] = 1;
      for (int k = 1; k <= sum; k++) {
        if (valid(i + 1, j)) {
          for (int s = 0; s < k; s++)
            f[i][j][k] += f[i + 1][j][s] * f[i][j][k - s - 1];
        }
        if (valid(i, j + 1)) {
          for (int s = 0; s < k; s++)
            f[i][j][k] += f[i][j + 1][s] * f[i][j][k - s - 1];
        }
      }
    }
  }
  g[0][0][0] = 1;
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) if (a[i][j]) {
      for (int k = sum; k >= 0; k--) 
        for (int s = 0; s < k; s++)
          g[i][j][k] += g[i][j][s] * f[i][j][k - s];
      // 上面处理虚环，下面处理实边
      for (int k = 0; k <= sum; k++) {
        if (valid(i + 1, j))
          g[i + 1][j][k] += g[i][j][k];
        if (valid(i, j + 1))
          g[i][j + 1][k] += g[i][j][k];
      }
    }
  }
  modint ans(0);
  for (int i = 0; i <= sum; i++)
    ans += g[n - 1][m - 1][i];
  printf("%d\n", ans);
}
```

modint 板子见 [此](https://www.luogu.com.cn/paste/hq681ejc)。

---

## 作者：_O_v_O_ (赞：2)

设 $dp1_{i,j,k}$ 为从 $(i,j)$ 喝 $k$ 瓶药走到 $(N,M)$ 的方案数，$dp2_{i,j,k}$ 为 $(i,j)$ 喝 $k$ 瓶药恰好回到 $(i,j)$，$dp3_{i,j,k}$ 为 $(i,j)$ 喝 $k$ 瓶药回到 $(i,j)$ 的方案数。

很显然答案为 $\sum_{i=1}^kdp1_{1,1,i}$。

那么我们考虑倒着枚举 $i$，$j$，在枚举一个 $k$：

很显然当 $(i,j)$ 有障碍时 $dp1_{i,j,k}=dp2_{i,j,k}=dp3_{i,j,k}=0$。

首先，我们计算 $dp2$，很显然，$(i,j)$ 可以从 $(i+1,j)$ 和 $(i,j+1)$ 转移而来，所以 $dp2_{i,j,k}=dp3_{i+1,j,k-1}+dp3_{i,j+1,k-1}$。

其次是 $dp3$，很显然我们可以先往后走再绕一圈回来再往后走，那么根据乘法原理 $dp3_{i,j,k}=\sum_{l=1}^Kdp3_{i,j,k}\times dp2_{i,j,l}$。

最后是 $dp1$，我们发现还是可以像 $dp3$ 一样，所以 $dp1_{i,j,k}=\sum_{l=0}^kdp3_{i,j,k}\times(dp1_{i+1,j,k-l}+dp1_{i+1,j,k-l})$。

那么直接模拟即可。

---

## 作者：Erica_N_Contina (赞：2)

## 思路

这是个 dp 啊啊啊！不是 bfs（可以计算出，bfs 是 $O(2^{nm})$ 并且想必你已经想到了。

设 $f_{i,j,k}$ 表示走到 $(i,j)$ 且花费了 $k$ 次药水的方案数量。

那么转移方程即可写成：

$$f_{i,j,k}=\sum\limits_{l=0}^k (f_{i-1,j,k-l}+f_{i,j-1,k-l})\times h_{i,j,l}$$

$$f_{i,j,0}=f_{i-1,j,0}+f_{i,j-1,0}$$

这里的 $h_{i,j,l}$ 表示从 $(i,j)$ 出发，使用 $l$ 次药水后回到了 $(i,j)$ 的方案数量。

需证明这个转移式包含了所有的情况。

现在我们来考虑怎么样求出 $h_{i,j,l}$。这里提一句，这个转移的优化有一点向完全背包的感觉（参考历年 noip 飞扬的小鸟）

首先考虑从 $(i,j)$ 走一步后撤销，并如此循环往复。那么这样就相当于在 $(i,j)$ 最个点上选了一个物品。那么 $h_{i,j,l}$ 其实就是表示在 $[(i,j)(n,m)]$ 矩形中选了 $l$ 个物品的方案数，约束是选择的物品的坐标必须构成一个联通块。

如果只是一来一回，那么 $h_{i,j,l}=h_{i+1,j,l-1}+h_{i,j+1,l-1}$。扩展到所有情况就是

- $h_{i,j,0}=1$

- $h_{i,j,l}=\sum\limits_{k=0}^l (h_{i+1,j,l-k}+h_{i,j+1,l-k})\times h_{i,j,k-1}$（之所以少了一次是因为要从 $(i-1,j)$ 或者 $(i,j-1)$ 退回 $(i,j)$ 需要一次）

那么求 $h$ 我们反过来跑一次即可。

注意一些点不可以访问！

---

为了方便，这里坐标反过来。

```C++
#include<bits/stdc++.h>
#define rep(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define per(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
#define int long long
#define pii pair<int,int>

#define lc(x) (x<<1)
#define rc(x) (x<<1|1)

#define rd read()
inline int read()
{
	int xx=0,ff=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') ff=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') xx=xx*10+(ch-'0'),ch=getchar();
	return xx*ff;
}
inline void write(int out)
{
	if(out<0) putchar('-'),out=-out;
	if(out>9) write(out/10);
	putchar(out%10+'0');
}

const int N=1e2+5;
const int INF=1e18+5;
int MOD;
int ans,n,m,s,K;
int mp[N][N];
int f[N][N][N],h[N][N][N];

signed main(){
	n=rd,m=rd,K=rd,MOD=rd,s=rd;
	for(int i=1;i<=s;i++){
		int a=rd,b=rd;
		mp[a][b]=1;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(!mp[i][j])h[i][j][0]=1;
		}
	}
	for(int l=1;l<=K;l++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				if(mp[i][j])continue;

				for(int k=0;k<l;k++){
					h[i][j][l]+=(h[i+1][j][l-k-1]+h[i][j+1][l-k-1])*h[i][j][k];
					h[i][j][l]%=MOD;
					
				}
				
			}
		}
	}
	f[n][m][0]=1;
//	for(int i=0;i<=K;i++)f[0][1][i]=1;
	
	for(int i=n;i;i--){
		for(int j=m;j;j--){
			
			if(mp[i][j])continue;
			for(int k=0;k<=K;k++){
				for(int l=0;l<=k;l++){
					f[i][j][k]+=(f[i+1][j][k-l]+f[i][j+1][k-l])*h[i][j][l];
					f[i][j][k]%=MOD;
				}
			}
			
		}
	}
	for(int i=0;i<=K;i++){
		ans+=f[1][1][i];
		ans%=MOD;
	}
	cout<<ans<<endl;
	return 0;
}

```




---


# 半彩三重奏

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/6205nazm.png)

帆帆不满足于只构建一棵深蓝之树，他觉得深蓝之树只有深蓝色太单调了，于是想给这棵树染上颜色。

## 题目描述

由于现在已经来到了魔幻的龙年，帆帆的深蓝之树已经被染上了颜色，结点 $i$ 的颜色为 $a_i$。

帆帆是一个喜新厌旧的人，在接下来的 $q$ 天中，他每天都会改变他喜欢的颜色，第 $i$ 天他喜欢的两种颜色是 $x_i,y_i$（$x_i\neq y_i$）。

但是为了照顾自己的树，他需要经常在树上移动，并且只会经过自己喜欢的颜色。

具体来说，第 $i$ 天，帆帆会选择一个有序结点对 $(u,v)$，然后沿着 $u\to v$ 的唯一简单路径移动，并且中间经过的结点（包含 $u,v$）颜色必须 $\in \{x_i,y_i\}$（$u$ 可以等于 $v$），之后可以抽取一次宵宫。

每一天你都需要抽取一个满命宵宫，然后告诉帆帆有多少种可能的选择有序结点对的方案。

## 说明/提示

### 【样例 $1$ 解释】

树的形态如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/w65i5hof.png)

对于第一组询问，合法的路径有且仅有 $\{1,2,3\}$ 中一点到另一点的路径。

对于第二组询问，合法的路径有且仅有 $1\to 1,1\to 3,3\to 1,3\to 3,4\to 4,5\to 5$。

### 【子任务约束】

本题采用子任务捆绑测试。

对于 $100\%$ 的数据，有 $1\le n\le 10^6$，$1\le q\le 2\times 10^6$，$1\le a_i,x,y\le n$，$x\neq y$。保证 $p_i<i$。

| 子任务编号 |        $n$         |        $q$         | 特殊性质 | 分值 | 依赖子任务 | 
| :--------: | :----------------: | :----------------: | :------: | :--: | :--: |
| Subtask \#1 |     $\le 100$      |     $\le 100$      |    无    | $7$  |无|
| Subtask \#2 |     $\le 2000$     |     $\le 2000$     |    无    | $18$ |$1$|
| Subtask \#3 |     $\le 10^5$     | $\le 2\times 10^5$ |    A     | $5$  |无|
| Subtask \#4 |     $\le 10^5$     | $\le 2\times 10^5$ |    B     | $19$ |无|
| Subtask \#5 |     $\le 10^5$     | $\le 2\times 10^5$ |    无    | $21$ |$1,2,3,4$|
| Subtask \#6 | $\le 2\times 10^5$ | $\le 5\times 10^5$ |    无    | $10$ |$5$|
| Subtask \#7 | $\le 10^6$ | $\le 2\times 10^6$ |    无    | $20$ |$6$|

特殊性质 A：$p_i=1$。

特殊性质 B：$p_i=i-1$。


## 样例 #1

### 输入

```
5 3
1 2 1 3 3
1 1 2 2
1 2
1 3
2 3```

### 输出

```
9
6
9```

# 题解

## 作者：云浅知处 (赞：15)

## $O(n\sqrt{q})$ 做法

不难发现本题实际上是要算：

- 只保留树上颜色为 $x$ 或者 $y$ 的点，求此时树上所有连通块大小的平方之和。

设 $c_x$ 表示颜色 $x$ 出现的次数。

那么，对于一组询问 $x,y$，如果我们能设计出 $O(\min(c_x,c_y))$ 的算法并进行记忆化，总的复杂度就不会超过 $O(n\sqrt{q})$：

- 若 $\min(c_x,c_y)\le \frac{n}{\sqrt{q}}$，则这部分复杂度不超过 $q\times \frac{n}{\sqrt{q}}=n\sqrt{q}$。
- 若 $\min(c_x,c_y)>\frac{n}{\sqrt{q}}$，这样的 $x$ 至多 $\sqrt{q}$ 个，对于每个 $x$，由于 $y$ 同样也只有 $\sqrt{q}$ 个，对所有 $c_y>\frac{n}{\sqrt{q}}$ 的 $y$ 求和 $\min(c_x,c_y)$ 的结果不会超过 $\sum_y c_x+c_y\le n+c_x\times \sqrt{q}$，再把这一结果对 $x$ 求和就得到了这部分的复杂度同样是 $O(n\sqrt{q})$。

对每组询问 $(x,y)$，若 $c_x<c_y$ 则交换 $x,y$，我们将这组询问 $(x,y)$ 挂在颜色 $x$ 上。接下来对每种颜色 $x$ 分别处理：考虑维护树上的点集形成的连通块，我们将每个连通块的信息放在这个连通块的根的位置，则插入一个点时只需考虑它的若干儿子，以及它的父亲处可能存在的信息合并。

考虑提前预处理出每个颜色为 $x$ 的连通块的根，接下来按照深度从大到小依次插入所有颜色为 $y$ 的点。这样插入一个点时，父亲处若存在信息合并，必然是完整的 $x$ 连通块，我们可以在 $O(1)$ 的时间内将其若干儿子的连通块的信息提到总的连通块的根上面，就在 $O(1)$ 时间内完成了插入。

总的时间复杂度为 $O(n\sqrt{q})$。

## $O(n+q)$ 做法

可以发现，对于给出的颜色 $x_i,y_i$ ，若树上不存在一条边 $i$ 满足 $i$ 两端点的颜色分别是 $x_i,y_i$ ，那么 $x_i,y_i$ 的点会形成若干独立的连通块，可以预处理后直接计算。

其余的颜色对一共最多只有 $n-1$ 种，就是每条边端点的颜色对集合。

首先把两端点颜色相同的边缩点。

枚举每一种可能的颜色对 $x_i,y_i$，把树上这样的边连上，计算形成的连通块的大小的平方和即可。

使用哈希表存答案，然后建边后再树上跑 DFS，可以做到 $O(n+m)$，如果使用 `std::map` 或者可撤销并查集也能通过。 

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6+7;
int n,m,q;
int c[N];
int idx=0;struct dsu
{
	int fa[N],siz[N];
	int find(int x)
	{
		if(x==fa[x])return x;
		return fa[x]=find(fa[x]);
	}
	void merge(int x,int y)
	{
		if(find(x)==find(y))return;
		x=find(x);y=find(y);
		fa[x]=y;
		siz[y]+=siz[x];
	}
}A,B;
struct edge 
{
	int a,b,next,id;
}e[N];
const int M = 1e6+7;
int flink[M],t=0;
int get(int a,int b)
{
	int h=(1ll*a*131%M+b)%M;
	for(int i=flink[h];i;i=e[i].next)
	if(e[i].a==a&&e[i].b==b)return e[i].id;
	e[++t].a=a;
	e[t].b=b;
	e[t].id=++idx;
	e[t].next=flink[h];
	flink[h]=t;
	return idx;
}
int qry(int a,int b)
{
	int h=(1ll*a*131%M+b)%M;
	for(int i=flink[h];i;i=e[i].next)
	if(e[i].a==a&&e[i].b==b)return e[i].id;
	return 0;
}
#define PII pair<int,int>
#define mk(x,y) make_pair(x,y)
#define X(x) x.first
#define Y(x) x.second
typedef long long LL;
inline int read() {
	char ch = getchar(); int x = 0;
	while (!isdigit(ch)) {ch = getchar();}
	while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();}
	return x;
}
void write(LL x) {
	if (!x) return;
	write(x / 10); putchar(x % 10 + '0');
}
inline void print(LL x, char ch = '\n') {
	if (!x) putchar('0');
	else write(x);
	putchar(ch);
}
vector<int> E[N];
LL ans[N];
int U[N],V[N];
int seq[2*N],tot=0;
bool mark[N];
LL ext[N];
int vis[N],tag;
int main()
{
	n = read(); q = read();
	for(int i=1;i<=n;i++)
	{
		c[i] = read();
		A.fa[i]=i;
		A.siz[i]=1;
	}
	for(int i=2;i<=n;i++)
	{
		int x;
		x = read();
		if(c[i]==c[x]) A.merge(x,i);
		else 
		{
			int cx=c[x],cy=c[i];
			if(cx>cy)swap(cx,cy);
			++m;
			U[m]=x;
			V[m]=i;
			E[get(cx,cy)].push_back(m);
		}
	}
	for(int i=1;i<=m;i++)
	{
		U[i]=A.find(U[i]);
		V[i]=A.find(V[i]);
		mark[U[i]]=1;
		mark[V[i]]=1;
	}
	for(int i=1;i<=n;i++)
	if(A.find(i)==i)
	ext[c[i]]+=1ll*A.siz[i]*A.siz[i];
	for(int r=1;r<=idx;r++)
	{
		tot=0;++tag; 
		for(auto p:E[r])
		{
			int x=U[p],y=V[p];
			if(vis[x]!=tag)vis[x]=tag,seq[++tot]=x;
			if(vis[y]!=tag)vis[y]=tag,seq[++tot]=y;
		}
		LL res=0;
		for(int i=1;i<=tot;i++)
		{
			B.fa[seq[i]]=seq[i];
			B.siz[seq[i]]=A.siz[seq[i]];
			res-=1ll*A.siz[seq[i]]*A.siz[seq[i]];
		}
		for(auto p:E[r])
		{
			int x=U[p],y=V[p];
			B.merge(x,y);
		}
		for(int i=1;i<=tot;i++)
		{
			int x=seq[i];
			if(B.find(x)==x)
			res+=1ll*B.siz[x]*B.siz[x];
		}
		ans[r]=res;
	}
	while(q--)
	{
		int x,y;
		x = read(); y = read();
		assert(x != y);
		if(x>y)swap(x,y);
		LL res=ext[x]+ext[y];
		if(qry(x,y))res+=ans[qry(x,y)];
		print(res);
	}
	return 0;
}
```

---

## 作者：sgl654321 (赞：11)

通过这一题，来学习一下可撤销并查集。

## 题目大意
- 给定一个 $n$ 个节点的树，每个点 $i$ 上有一个颜色 $a_i$。
- 每次询问，给定两个颜色 $x,y$。你需要找到树上有多少个点对 $(u,v)$，满足 $(u,v)$ 的简单路径上（包括 $u,v$），所有点的颜色要么是 $x$，要么是 $y$。
- $(u,v)$ 和 $(v,u)$ 算两种不同的，$u=v$ 时也算两种不同的。

## 解题思路

### $\text{25 pts}$：
对于每次询问，拿出树中颜色为 $x$ 和颜色为 $y$ 的节点，进行连边，将会得到一个森林。

设得到了 $s$ 个连通块，每个连通块的大小为 $siz_i$，则答案为 $\sum_{i=1}^s siz_i^2$。 

时间复杂度 $O(nq)$。

### $\text{100 pts}$:
上面 $25$ 分的思路，最慢的地方就在于“拿出树中颜色为 $x$ 和颜色为 $y$ 的节点，进行连边”了。

我们发现，对于树上一条连着两个**相同颜色**节点的边，它被重复拿出来了好几次。而这个贡献其实是可以预处理的。

具体地，我们先把树上同一颜色并且互相连通的点，缩成一个连通块。这个我们可以用普通并查集来实现。然后我们就可以得到，单独在一个颜色中，可以互达的点对个数。

设颜色 $i$ 有 $s_i$ 个连通块 $a_{i,1},a_{i,2},\cdots,a_{i,s_i}$，每个联通块的大小为 $siz_{i,j}$，那么这个颜色中可以互达的点对个数 $inans_i=\sum_{j=1}^{s_i}siz_{i,j}$。

但是现在每次询问都会给你两个颜色 $x,y$，你还要加上**不同颜色之间**的贡献。这个怎么办呢？

由于树上的边的总数为 $n-1$，所以树上连接不同颜色的边的个数也至多为 $n-1$，这样的**颜色对**的个数也至多为 $n-1$。

我们把每个颜色对通过 `map`，映射成一个值，并用 `vector` 存储下是这个颜色对的边有哪些。现在，我们再来考虑，一个颜色对 $(x,y)$，它们跨颜色之间的贡献有多少。

先来看个图：
![](https://cdn.luogu.com.cn/upload/image_hosting/ujlg7gwl.png)

假设连接黑色集合和绿色集合的边，共有上面的三条。我们依次进行连接。

第一次连接，一个集合的大小为 $4$，另一个为 $3$。两两之间互达，又由于是有序点对，所以贡献加上 $2\times4\times 3$。

第二次连接，一个集合大小为 $1$，另一个为 $2$，贡献加上 $2\times 1\times 2$。

第三次连接，一个集合大小为 $7$，另一个为 $3$，贡献加上 $2\times 7\times3$。

加起来就是跨黑绿颜色之间的贡献了。我们要时时刻刻知道，一条跨颜色树边的两个端点，**当前分别在哪个连通块中**，以及**当前所处连通块的大小为多少**，加完贡献后，进行**连边**。

然后呢？我们处理完一个颜色对之后，我们要把刚才我们所做的连边**全部都撤销了**。这样，才能保证处理下一个颜色对时不会发生影响。

### 数据结构——可撤销并查集

带路径压缩的并查集，无法进行撤销，因为我们进行路径压缩时，就把以前的信息都压缩没了，当然撤销不到原来的版本状态。

因此我们的可撤销并查集，应当用不路径压缩，而是**启发式合并并查集**。父亲就是父亲，祖先就是祖先，不能像路径压缩一样乱来。合并的时候，**把 $size$ 较小的一个集合，给连向 $size$ 较大的一个**，用于保证最终的复杂度是 $O(n\log n)$ 的。

为什么是 $O(n\log n)$？因为对于一个点，每次进行合并，如果属于较小集合，合并后，所处集合的大小至少变成了原先的 $2$ 倍，也就是**大小翻倍，深度加一**。最大的大小就是 $n$，因此 `find` 操作找集合代表元的时间复杂度为 $O(n\log n)$。

接下来是最动人心弦的撤销操作。撤销时，我们要更改的有父亲数组 $fa$ 和集合大小数组 $size$。

我们在每次合并两个集合之前，先记录下较小集合的父亲 $fa_x$ 是谁，再记录下较大集合的 $size_y$ 是谁。这个东西我们可以用栈来存储，因为你对每个颜色是**现做现撤回**的。

然后撤销时，直接拿出栈顶的信息，进行复原，再弹栈即可。

这样，我们就可以知道每个颜色对 $(x,y)$，跨颜色之间的贡献是多少了。设把 $(x,y)$ 映射了之后变成了值 $i$，我们把贡献记作 $stans_i$

### 最后一步
对于每一个询问 $(x,y)$，答案就是 $inans_x+inans_y+stans_{map[(x,y)]}$。


### 注意点
1. 每一个颜色对 $(x,y)$，你在记录的时候都保证 $x<y$。
2. 写可撤销并查集的时候，小集合 $x$ 的 $size$ 不要把它设成 $0$ 了，因为在撤回的时候这个信息还是要的。
3. 如果直接对一个 `pair` 用 `map` 进行映射会 TLE，然后 `pair` 又是不能直接用 `unordered_map` 映射的。所以说，我们先把这个 `pair` $(x,y)$ 给映射成一个整数 $x\times 10^6+y$，再用 `unordered_map` 进行映射。这样就可通过此题。
4. 记得关流！

## 参考代码
```cpp
#include<bits/stdc++.h>
#define maxn 1000010
using namespace std;
typedef long long ll;
typedef pair<ll,ll> pll;
struct edge{
	ll x,y;
}e[maxn];
ll n,q,a[maxn],x,fa1[maxn],siz1[maxn],y;
ll xx,yy,colp,col,tp;
//colp shows how many color_pairs in edges have appeared
//we can simply prove that colp <= n-1

ll find1(ll x){
	if(fa1[x]==x)return x;
	fa1[x]=find1(fa1[x]);return fa1[x];
}
ll tmp;
unordered_map<ll,ll>mp;
vector<edge>ve[maxn];
//use vector, record that the edges which have color_pair i. 

ll inans[maxn],stans[maxn];
//inans shows don't stride different colors, the answer of color i
//stans shows color_pair i, can add how many answers
//use these two ans_array, we can get the true answer

ll fa[maxn],siz[maxn],ans;//this is a revokable_DSU
stack<ll>sta1;
//sta1 shows the roots that we have merged to other ones.
stack<pll>sta2;
//sta2 shows the roots's size, which we have merged to others.
ll find(ll x){
	if(fa[x]==x)return x;
	return find(fa[x]);
}
void merge(ll x,ll y){
	xx=find(x);yy=find(y);
	if(xx==yy)return;
	if(siz[xx]>siz[yy])swap(xx,yy);
//Heuristic merge. small one xx should merge to big one yy
	sta1.push(xx);
	sta2.push(make_pair(yy,siz[yy]));
	siz[yy]+=siz[xx];
	fa[xx]=yy;
}
void undo(){
	//revoke the operation we acted at last.
	fa[sta1.top()]=sta1.top();//it was a root before
	siz[sta2.top().first]=sta2.top().second;
	//it didn't have such a big size before
	sta1.pop();sta2.pop();
}

int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++){
		cin>>a[i],fa1[i]=i;
		col=max(col,a[i]);
	}
	for(int i=2;i<=n;i++){
		cin>>x;
		if(a[x]==a[i]){
			//just merge them
			xx=find1(x);yy=find1(i);
			fa1[xx]=yy;
		}else{
			if(a[x]<a[i])tmp=a[x]*1e6+a[i];
			else tmp=a[i]*1e6+a[x];
			
			if(mp.find(tmp)==mp.end())
				mp[tmp]=++colp;
			tp=mp[tmp];
			ve[tp].push_back(edge{x,i});
		}
	}
	for(int i=1;i<=n;i++)
		fa1[i]=find1(i),siz1[fa1[i]]++;
	for(int i=1;i<=n;i++)
		if(fa1[i]==i)
			inans[a[i]]+=siz1[i]*siz1[i];
	
	for(int i=1;i<=n;i++)fa[i]=fa1[i];
	for(int i=1;i<=n;i++)siz[i]=siz1[fa1[i]];
	
	for(int i=1;i<=colp;i++){
		//we should use revokable_DSU, to count the answer
	
		for(int j=0;j<ve[i].size();j++){
			xx=find(ve[i][j].x);yy=find(ve[i][j].y);
			stans[i]+=siz[xx]*siz[yy]*2;
			merge(ve[i][j].x,ve[i][j].y);
		}
		for(int j=0;j<ve[i].size();j++)undo();
	} 
	while(q--){
		cin>>x>>y;
		ans=inans[x]+inans[y];
		if(x>y)swap(x,y);
		tmp=x*1e6+y;
		if(mp.find(tmp)==mp.end())cout<<ans<<'\n';
		//no edges join x to y
		else{
			tp=mp[tmp];
			ans+=stans[tp];
			cout<<ans<<'\n';
		}
	}	
	return 0;
}
```



---

## 作者：elbissoPtImaerD (赞：6)

为什么不写又好写又快的线性做法。

考虑到影响树边的颜色对只有 $O(n)$，我们考虑将这些询问答案预处理出来，平凡的询问拆成两个颜色分别做然后简单相加即可。

预处理询问答案可以通过按树边枚举有效颜色对，加边时记录有效点，然后 dfs 统计连通块大小做到 $O(n)$。

代码实现得很丑，所以带一个排序的 $\log$，可以用桶排去掉。

```cpp
struct DSU
{
  ve<int>fa;
  DSU(int n){fa.resize(n),sd iota(all(fa),0);}
  il int F(int x){return x^fa[x]?fa[x]=F(fa[x]):x;}
  il void _M(int x,int y){if((x=F(x))^(y=F(y))) fa[x]=y;}
  il bool _Q(int x,int y){return F(x)==F(y);}
};
il void Solve()
{
  int n,q;
  rd(n),rd(q);
  ve<int>a(n);
  for(int&x:a) rd(x),--x;
  ve<int>p(n);
  DSU S(n);
  for(int i=1;i<n;++i) {
    rd(p[i]),--p[i];
    if(a[p[i]]==a[i]) S._M(i,p[i]);
  }
  int nn=0;
  ve<int>nid(n,-1),sz(n);
  ve<LL>cans(n);
  for(int i=0;i<n;++i)
    if(S.fa[i]==i) sz[nn]=1,nid[i]=nn++,++cans[a[i]];
    else {
      cans[a[i]]-=1ll*sz[nid[S.F(i)]]*sz[nid[S.F(i)]];
      ++sz[nid[S.F(i)]];
      cans[a[i]]+=1ll*sz[nid[S.F(i)]]*sz[nid[S.F(i)]];
    }
  ve<sd tuple<int,int,int,int>>e;
  for(int i=1;i<n;++i) if(!S._Q(i,p[i])) {
    if(a[i]<a[p[i]]) e.pb(a[i],a[p[i]],nid[S.F(i)],nid[S.F(p[i])]);
    else e.pb(a[p[i]],a[i],nid[S.F(i)],nid[S.F(p[i])]);
  }
  sd stable_sort(all(e));
  pii pre={-1,-1};
  sd unordered_map<LL,LL>ecans;
  auto hsh=[&](pii x){return 1ll*x.x*n+x.y;};
  ve<int>todo;
  ve<ve<int>>G(n);
  ve<int>vis(n);
  auto Calc=[&]
  {
    LL s=0;
    int cnt=0;
    sd function<void(int)>dfs=[&](int u)
    {
      cnt+=sz[u],s-=1ll*sz[u]*sz[u],vis[u]=1;
      for(int v:G[u]) if(!vis[v]) dfs(v);
      G[u].clear();
    };
    for(int x:todo) if(!vis[x]) {
      cnt=0,dfs(x),s+=1ll*cnt*cnt;
    }
    for(int x:todo) vis[x]=0;
    todo.clear();
    return s;
  };
  for(int i=0;i<e.size();++i) {
    auto&[cu,cv,u,v]=e[i];
    if(pii(cu,cv)!=pre) {
      ecans[hsh(pre)]=Calc();
      pre=pii(cu,cv),--i;
    }
    else {
      G[u].pb(v),G[v].pb(u),todo.pb(u),todo.pb(v);
    }
  }
  ecans[hsh(pre)]=Calc();
  for(int x,y;q--;) {
    rd(x),rd(y),--x,--y;
    if(x>y) sd swap(x,y);
    if(ecans.count(hsh({x,y}))) wrt(cans[x]+cans[y]+ecans[hsh({x,y})],'\n');
    else wrt(x^y?cans[x]+cans[y]:cans[y],'\n');
  }
  return;
}
```

[$\color{green}{\checkmark}$](https://www.luogu.com.cn/record/147867678)

---

## 作者：_Ch1F4N_ (赞：4)

考虑设计 $dp$ 状态，$dp_{u,i}$ 表示考虑点 $u$ 为根的子树，选择的另一种颜色为 $i$，显然有 $i \in col_{v}$ 这里 $v \in son_u$。

所以总的状态数其实只有 $O(n)$ 个。

考虑转移，每次把儿子 $v$ 的答案添加进来，为了方便处理我们把所有颜色相同的连通块缩成一个点，然后一定是两个颜色交替出现，所以贡献量是 $(sz_v + f_{v,col_u}) \times (sz_u + f_{u,col_v})$。然后更新 $f_{u,col_v}$。

然后考虑如何贡献到答案上，考虑离线下所有贡献，然后按照第一维排序，按照第二维分类，把答案也离线下来按照第一维排序，第二维分类，双指针移动处理贡献即可，时间复杂度为小常数的 $O((n+q) \log n)$。

下面赛时代码。

```cpp
#include<bits/stdc++.h>
//#define lowbit(x) (x&(-x))
using namespace std;
const int maxn = 1e6+114;
unordered_map<long long,int> f[maxn];
int fa[maxn];
int sz[maxn];
int col[maxn];
int found(int u){
	return fa[u]=(fa[u]==u?u:found(fa[u]));
}
inline long long Hash(long long u){
	return (u >> 5) * 114 % 514 + u % 1145141919ll * u % 1145141 + 4546465 * u;
}
vector< pair<int,long long> > value[maxn];//(colv,k)
vector< pair<int,int> > Query[maxn];//(colv,id)
long long answer[maxn<<1];
long long ans[maxn];
vector<int> E[maxn];
void dfs(int u,int fa){
	for(int v:E[u]){
		if(v==fa) continue;
		dfs(v,u);
		value[min(col[u],col[v])].push_back(make_pair(max(col[u],col[v]),1ll*(sz[v]+f[v][Hash(col[u])])*(f[u][Hash(col[v])]+sz[u])));
		f[u][Hash(col[v])]+=1ll*(f[v][Hash(col[u])]+sz[v]);
	}
	ans[col[u]]+=1ll*sz[u]*sz[u];
}
int n,q;
pair<int,int> e[maxn];
vector<int> p;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>col[i],fa[i]=i,sz[i]=1;
	for(int i=2;i<=n;i++){
		cin>>e[i-1].first;
		e[i-1].second=i;
		if(col[e[i-1].first]==col[e[i-1].second]){
			int u=found(e[i-1].first);
			int v=found(e[i-1].second);
			if(u!=v){
				fa[v]=u;
				sz[u]+=sz[v];
			}
		}
	}
	for(int i=1;i<n;i++){
		if(found(e[i].first)!=found(e[i].second)){
			E[found(e[i].first)].push_back(found(e[i].second));
			E[found(e[i].second)].push_back(found(e[i].first));
		}
	}
	set<int> d;
	for(int i=1;i<=n;i++){
		if(found(i)==i) p.push_back(i),d.insert(col[i]);
	}
	dfs(p[0],0);
	for(int i=1;i<=q;i++){
		int x,y;
		cin>>x>>y;
		if(x>y) swap(x,y);
		answer[i]+=ans[x]+ans[y];
		Query[x].push_back(make_pair(y,i));
	}
	for(int u:d){
		sort(value[u].begin(),value[u].end());
		sort(Query[u].begin(),Query[u].end());
		long long sum=0;
		int t=0;
		if(Query[u].size()==0||value[u].size()==0) continue;
		int lstcol=-1;
		for(pair<int,int> now:Query[u]){
			while(value[u][t].first<now.first&&t<value[u].size()) t++;
			if(now.first!=lstcol) sum=0;
			lstcol=now.first;
			while(value[u][t].first==now.first&&t<value[u].size()) sum+=value[u][t].second,t++;
			answer[now.second]+=2ll*sum;
		}
	}
	for(int i=1;i<=q;i++) cout<<answer[i]<<'\n';
	return 0;
}
/*
5 1
1 2 1 3 3
1 1 2 2
1 2
*/
```


---

## 作者：Lucky_Xiang (赞：3)

## 题目

[P10180](https://www.luogu.com.cn/problem/P10180)

## 分析

假如可以走的连通块大小分别为 $A_1,A_2\dots A_k$，则答案就是 $\sum_{i=1}^k A_i^2$。

现在有两个大小分别为 $A$ 和 $B$ 的连通块，如果新增一条边将它们**合并**，则答案的变化量是 $(A+B)^2-A^2-B^2$。

于是有一个暴力的做法。先将**单个颜色**的答案都预处理出来，询问时枚举**连接两种颜色**的边，将连通块合并即可。在进行下一次询问前，将并查集的合并操作**撤销**即可。


假如现在要合并颜色 $X$ 和 $Y$。因为连接颜色 $X$ 的边非常多，暴力枚举连接颜色 $X$ 的所有边肯定会 TLE；如果将连接颜色 $(X,Y)$ 的所有边都单独开个桶存下来呢？$(X,Y)$ 的数对是 $O(n^2)$ 的，肯定会 MLE。

我们发现树上只有 $n-1$ 条边，也就是说**有效**询问 $(X,Y)$ 的数量是 $O(n)$ 的，而对于其他询问，连通块**不会合并**，直接将预处理的答案累加即可。这样以来，我们只存树上出现的 $(X,Y)$ 数对，就不会 MLE 了。

这样做时间复杂度是否正确？我们存下的所有边**数量之和**是 $O(n)$ 的，只要查询时加一个**记忆化**，就能使所有**有效询问**均摊 $O(n)$。因为使用了**可撤销并查集**，所以总复杂度是 $O(n\log n)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int mn=1000010;
const int mod=1145141;
struct state
{
    LL x,y;
};
struct HASH
{
    vector<state>vec[mod];
    void insert(LL x,LL y)
    {
        vec[x%mod].push_back({x,y});
    }
    LL query(LL x)
    {
        for(auto k:vec[x%mod])
        {
            if(k.x==x)return k.y;
        }
        return -1;
    }
};
int n,q;
int a[mn];
vector<int>P[mn];
vector<int>E[mn];
LL res,ans[mn];
LL s[mn];
int fa[mn];
vector<state>VEC[mn];
vector<state>stk;
int gf(int x)
{
    while(x!=fa[x])x=fa[x];
    return x;
}
void merge(int u,int v)
{
    u=gf(u); v=gf(v);
    if(s[u]>s[v])swap(u,v);
    res-=s[u]*s[u]; res-=s[v]*s[v];
    fa[u]=v; s[v]+=s[u];
    res+=s[v]*s[v];
    stk.push_back({u,v});
}
LL x,y;
int cur;
int tot;
HASH id,RES;
LL get(int x,int y)
{
    return (LL)x*1000000+y;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin>>n>>q;
    for(int i=1;i<=n;i++)cin>>a[i],P[a[i]].push_back(i),ans[a[i]]++;
    for(int i=1;i<=n;i++)fa[i]=i,s[i]=1;
    for(int i=2;i<=n;i++)
    {
        cin>>x;
        E[x].push_back(i);
        E[i].push_back(x);
        if(a[i]==a[x])
        {
            int u=i,v=x;
            u=gf(u); v=gf(v);
            if(s[u]>s[v])swap(u,v);
            ans[a[i]]-=s[u]*s[u]; ans[a[i]]-=s[v]*s[v];
            fa[u]=v; s[v]+=s[u];
            ans[a[i]]+=s[v]*s[v];
            //预处理出单个颜色的答案
        }
    }
    for(int u=1;u<=n;u++)
    {
        for(auto v:E[u])
        {
            if(a[u]<a[v])
            {
                x=get(a[u],a[v]);
                if(id.query(x)<0)id.insert(x,++tot);
                VEC[id.query(x)].push_back({u,v});
                //记录连接颜色 (X,Y) 的所有边
            }
        }
    }
    while(q--)
    {
        cin>>x>>y;
        if(x>y)swap(x,y);
        res=RES.query(get(x,y));
        if(res>=0) //记忆化
        {
            cout<<res<<'\n';
            continue;
        }
        res=ans[x]+ans[y];
        cur=id.query(get(x,y));
        if(cur>=0)
        {
            for(auto p:VEC[cur])merge(p.x,p.y);
        }
        cout<<res<<'\n';
        RES.insert(get(x,y),res);
        //并查集的撤销
        while(!stk.empty())
        {
            auto P=stk.back(); 
            fa[P.x]=P.x; s[P.y]-=s[P.x];
            stk.pop_back();
        }
    }
    return 0;
}
```

---

## 作者：hgckythgcfhk (赞：1)

提供一种不一样的实现方法，不需要任何并查集。

先说思路，考虑只有一次询问怎么做，设这次询问的两个颜色是 $(x,y)$，能产生贡献的有颜色为 $(x,x),(y,y),(x,y)$ 的边和颜色为 $x$ 或 $y$ 的单点，答案是包含且只包含这些点和边的连通块的大小的平方和。

不难发现，我们把所有的用颜色相同的点组成的连通块缩成一个点，然后把这个点与原来的连通块内的点直接相连的连通块外的点连边并不影响结果，但这样对于每次询问，我们不需要考虑颜色为 $(x,x)$ 和 $(y,y)$ 的边。由于我们最多有 $n-1$ 条边，所以最多有 $n-1$ 种颜色的边需要特殊处理，对于其他的询问，答案为所有颜色为 $x$ 和颜色为 $y$ 的点的大小的平方和，其中，定义大小表示如果这个点是缩点得到的点则为其中点的个数，否则为 $1$。

如果我们能预处理这不超过 $n-1$ 种颜色就做完了，对于每种可能的颜色每次建边单独求答案，到这里，整体思路和其他大部分题解一样，但是我发现有很多题解已经讲完了，并没有讲具体实现，只是提了一句可撤销并查集。

无论是我自己想到这里的想法，还是看了其他题解到这一步理解的字面意思，我都没想到为什么要用并查集，其实完全可以真的重新建边，求完后真的把边删掉，具体方法是先用 ```map<pair<int,int>,vector<pair<int,int>>>``` 把所有颜色相同的边扔到一起，然后用一个 ```set``` 记录出现在这些边里的所有点，我们只以这些点为根进行 ```dfs```，然后清空时只清空这些点相关的数据，比如 ```dfs``` 时用到的 $vis$ 数组和连边用的 ```vector```，这样的时间复杂度均摊下来也是 $O(n\log n)$ 的。

最后讲一下卡常，首先，存答案的 ```map``` 是常数很大的 $\log n$，而询问有 $2\times 10^6$ 次，这里影响其实是最大的，也是这种写法不太容易注意到的，需要把 ```pair``` 映射成一个 ```long long``` 然后用 ```unordered_map``` 存答案。

其他部分虽然看起来常数更大，但实际上很难跑满，不过也有卡常空间，首先，```pair``` 要比手写结构体慢，一般情况下不用考虑这个问题，但在本题的数据下效果比较明显。然后，我们用到的存出现过的点的 ```set``` 其实只是为了排序去重，注意，这里排序很重要，不排序会出现从子树中的点开始遍历的情况，这样要么得保留连向父亲的边且多次判断是否访问过从而增加码量和常数，要么会导致算重。虽然排序重要但我们并不需要关心排序方式，```set``` 要远慢于 ```sort```。最后，对于每种颜色的边，先开个临时变量把答案记录下来，最后再直接赋值，这样可以减少 ```map``` 的调用次数。

为防止因火车头导致无法过审，仅给出核心程序和部分可能会引起歧义的宏定义。

```cpp
#define rg register
#define cit const rg unsigned
#define int rg unsigned
#define vint vector<unsigned>
#define vector basic_string

il unsigned rd(){int char c=ge;int s=0;while(c<48||c>58)c=ge;while(c<59&&c>47)s=s*10+(c&0b1111),c=ge;return s;}
void wt(int ll x){if(!x){pu(48);pu(10);return;}static unsigned char c[15];int char s=0;while(x)c[++s]=x%10|48,x/=10;while(s)pu(c[s--]);pu(10);}
struct E{unsigned u,v;il bool operator<(const E a)const{return u==a.u?v<a.v:u<a.u;}};
vint a[N];unsigned f[N],id[N],cnt,c[N],d[N];
map<E,vector<E > >s;vint g;bool vis[N];
ull res,b[N],sz[N];ump<ull,ull>ans;unsigned n,q;
void init(){n=rd(),q=rd();id[1]=++cnt;sz[1]=1;
	for(int i=1;i<=n;++i)c[i]=rd();
	d[1]=c[1];for(int i=2;i<=n;++i){f[i]=rd();
		if(c[i]==d[id[f[i]]])id[i]=id[f[i]],++sz[id[i]];
else d[id[i]=++cnt]=c[i],a[id[f[i]]]+=cnt,sz[cnt]=1;}
}
void dfs(cit u){vis[u]=1;res+=sz[u];for(cit&v:a[u])dfs(v);}
void solve(){init();
	for(int i=1;i<=cnt;++i)b[d[i]]+=sz[i]*sz[i];
	for(int i=1;i<=cnt;++i)for(cit&j:a[i])f[j]=i;
	for(int i=2;i<=cnt;++i){E t=E{d[i],d[f[i]]};
		if(t.u>t.v){cit _=t.u;t.u=t.v;t.v=_;}
		s[t]+=E{i,f[i]};a[i]=vint();}a[1]=vint();
	for(auto i:s){for(E e:i.se){cit u=e.u,v=e.v;
		g+=u,g+=v;a[v]+=u;}int ll tans=b[i.fi.u]+b[i.fi.v];
		sort(g.begin(),g.end());vint h;if(!g.SZ)continue;
		h+=g[0];for(int j=1;j<g.SZ;++j)if(g[j]>g[j-1])h+=g[j];
	for(cit&rt:h)if(!vis[rt])dfs(rt),tans+=res*res,res=0;
	for(cit&rt:h)a[rt]=vint(),vis[rt]=0,tans-=sz[rt]*sz[rt];
	ans[1ll*i.fi.u*N+i.fi.v]=tans;g=vint();}
	while(q--){int x=rd(),y=rd();if(x>y){cit _=x;x=y,y=_;}
		cit ll t=1ll*x*N+y;if(ans.count(t))wt(ans[t]);
		else wt(b[x]+b[y]);}
}signed main(){open;int t=1;//cin>>t;
	while(t--)solve();}
```
剩余的宏定义没有给出，但根据字面意思很容易理解。

---

## 作者：gdf_yhm (赞：1)

[P10180](https://www.luogu.com.cn/problem/P10180)

### 思路

首先答案是所有连通块大小的平方和。

先用并查集将相同颜色合起来，记录 $sum_i$ 表示只看颜色 $i$ 的答案。

如果对于询问 $u,v$ 不存在 $e(i,j)$ 满足 $a_i=u,a_j=v$，答案为两个颜色单独的答案之和。

否则只有至多 $n-1$ 对 $(u,v)$ 的至多 $n-1$ 条边，需要考虑两种颜色合起来。可以用可撤销并查集，枚举所有对应的颜色对，将对应的边加入并查集，记录答案，再删去。复杂度 $O(n\log n)$。只要不是写的太臭就可以。

### code

```cpp
int n,q,a[maxn];
int f[maxn],siz[maxn];
int fd(int x){
	if(x==f[x])return x;
	return fd(f[x]);
}
int st[maxn][2],tp;
void merge(int u,int v){
	if(u==v)return ;
	if(siz[u]<siz[v])swap(u,v);
	st[++tp][0]=v,st[tp][1]=siz[v];
	f[v]=u;siz[u]+=siz[v];
}
#define pii pair<int,int>
unordered_map<int,int>mp;pii id[maxn];
vector<pii> ans[maxn];int idx;
int res[maxn],sum[maxn];
int get(int u,int v){return min(u,v)*n+max(u,v);}
void work(){
	n=read();q=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=n;i++)f[i]=i,siz[i]=1;
	for(int i=2;i<=n;i++){
		int u=read();
		if(a[u]==a[i])merge(fd(u),fd(i));
		else{
			int p=get(a[u],a[i]);
			if(!mp[p])mp[p]=++idx,id[idx]={a[u],a[i]};
			ans[mp[p]].push_back(make_pair(u,i));
		}
	}
	for(int i=1;i<=n;i++)if(f[i]==i)sum[a[i]]+=siz[i]*siz[i];
	for(int i=1;i<=idx;i++){
		// cout<<id[i].first<<" "<<id[i].second<<" a\n";
		res[i]=sum[id[i].first]+sum[id[i].second];
		int lst=tp;
		for(pii j:ans[i]){
			int u=fd(j.first),v=fd(j.second);
			res[i]+=2*siz[u]*siz[v];
			merge(u,v);
		}
		while(tp!=lst){
			siz[f[st[tp][0]]]-=st[tp][1];
			f[st[tp][0]]=st[tp][0];
			tp--;
		}
		// for(int j=1;j<=n;j++)if(j==f[j])cout<<j<<" "<<f[j]<<" "<<siz[j]<<"\n";
	}
	while(q--){
		int u=read(),v=read();
		if(mp.count(get(u,v)))printf("%lld\n",res[mp[get(u,v)]]);
		else printf("%lld\n",sum[u]+sum[v]);
	}
}
```


---

## 作者：nullqtr_pwp (赞：1)

容易将问题转化为树上 $x,y$ 颜色组成的连通块大小平方和。

与出现次数挂钩，其实第一眼看到的是根号分治做法，但是在 $n=10^6,q=2\times 10^6$ 的数据范围是很难卡过去的。

平方和其实是一个难以转化的问题，意味着我们需要直接维护所有连通块的信息。

想到 [[SNOI2024] 树 V 图](https://loj.ac/p/4038) 的 trick，考虑将一个极大同色连通块缩在一起，只保留原树上异色的边，以及原树上一个连通块的点。建立一棵重构树，每个点有两种权值，$cnt_u,col_u$。其中 $cnt_u$ 为 $u$ 这个点所在的原树上这个极大同色连通块的大小，$col_u$ 为连通块的颜色。

注意到在重构树上，考虑 $x,y$ 的连通块合并，只需要对每个 $x$ 的连通块的点合并邻域中颜色为 $y$ 的即可。这样做是因为新树中 $(x,y)$ 的相邻可以的合并边一定是都会合并完的。注意到 $q=2\times 10^6$，需要记忆化。所以可以考虑用带撤销并查集维护，由于每条边在所有询问中最多被合并一次，所以一共并查集会合并 $O(n)$ 次。

带撤销并查集不能使用路径压缩，因此带 $\log$。时间复杂度为 $O(n\log n+q)$。不要使用 ```gp_hash_table```，建议使用 ```unordered_map```，这题不卡这个。

```cpp
// Problem: P10180 半彩三重奏
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P10180
// Memory Limit: 512 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define fi first
#define se second
#define inf 1e9
#define pii pair<int,int>
#define F(i,a,b) for(int i=a;i<=(b);i++)
#define dF(i,a,b) for(int i=a;i>=(b);i--)
#define wh(lzm) while(lzm--)
#define lowbit(x) (x&(-x))
#define HH printf("\n")
#define eb emplace_back
using namespace std;
int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*f;
}
const int mod=998244353,maxn=3000005;
int n,m,a[maxn];
ll tot=0;
namespace DSU{
	tuple<int,int>st[maxn];
	int stktop,sz[maxn],dsu[maxn];
	int find(int x){
		return dsu[x]==x?x:x=find(dsu[x]);
	}
	void merge(int x,int y){
		x=find(x),y=find(y);
		if(x==y) return;
		tot-=1ll*sz[x]*sz[x];
		tot-=1ll*sz[y]*sz[y];
		if(sz[x]>sz[y]) swap(x,y);
		st[++stktop]=make_tuple(x,y);
		dsu[x]=y,sz[y]+=sz[x];
		tot+=1ll*sz[y]*sz[y];
	}
	void rickroll(int lst){
		for(;stktop>lst;--stktop){
			auto [x,y]=st[stktop];
			dsu[x]=x,sz[y]-=sz[x];
		}
	}
}
using namespace DSU;
unordered_map<ll,ll>mp;
ll ans[maxn],tc[maxn];
vector<int>g[maxn],vec[maxn];
vector<pii>qu[maxn];
int fa[maxn],top[maxn],cnt;
bool vis[maxn];
void dfs(int u,int tt){
	top[u]=tt;
	for(int v:g[u]) if(a[u]==a[v]) dfs(v,tt);
}
unordered_map<ll,vector<int>>mpe;
signed main(){
	n=read(),m=read();
	F(i,1,n) a[i]=read(),vec[a[i]].pb(i),vis[a[i]]=1;
	F(i,2,n) g[fa[i]=read()].pb(i);
	F(i,1,n) if(!top[i]) dfs(i,i);
	F(i,1,n) sz[dsu[i]=top[i]]++;
	F(i,1,n) tc[a[i]]+=1ll*sz[i]*sz[i];
	F(i,2,n) if(a[i]^a[fa[i]]) {
		int x=a[i],y=a[fa[i]];
		if(x>y) swap(x,y);
		ll hsh=1ll*(x-1)*n+y;
		mpe[hsh].push_back(i);
	}
	F(i,1,m){
		int x=read(),y=read();
		if(!tc[x]||!tc[y]){ printf("%lld\n",tc[x]|tc[y]); continue; }
		if(x>y) swap(x,y);
		ll hsh=1ll*(x-1)*n+y,ans=tc[x]+tc[y];
		if(mp.find(hsh)!=mp.end()){ printf("%lld\n",mp[hsh]); continue; }
		int lst=stktop;
		tot=0;
		if(mpe.find(hsh)!=mpe.end()) for(int j:mpe[hsh]) merge(j,fa[j]);
		ans+=tot;
        printf("%lld\n",mp[hsh]=ans);
        rickroll(lst);
	}
}
```

---

## 作者：DengDuck (赞：0)

非常好卡常题，使我昨天没有 AC 蓝紫黑。

首先路径数量显然是所有满足条件的点组成的所有连通块的大小的平方之和。

首先容易想到对于一个相同颜色的连通块可以缩点，然后我们发现每次询问只需要把所有连接一个颜色为 $x$ 的点，一个颜色为 $y$ 的点的边尝试连起来，算出所有连通块的答案就行，之后再撤销这些连边。

我们考虑用按秩合并并查集来做，这样可以删边，然后我们维护每个连通块的大小，不断更新答案即可。

加一个记忆化来处理重复的询问，这要我们每种边都只会加一次，因此每个边都只会加一次，所以时间复杂度为 $\mathcal O(n+q)$。

需要卡常。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define LF long double
#define pLL pair<LL,LL>
#define pb push_back
#define fir first
#define sec second
using namespace std;
//const LL inf;
const LL N=1e6+5;
//const LL M;
//const LL mod;
//const LF eps;
//const LL P;
LL n,q,a[N],fa[N],tot,c[N],in[N],sz[N],Sz[N],cnt[N],Tot;
vector<LL>V[N],v[N];
unordered_map<LL,LL>nam;
vector<pLL>B[N];
LL find(LL x)
{
	if(fa[x]==x)return x;
	return find(fa[x]);
}
void dfs(LL x,LL y)
{
	if(!y)y=++tot,c[y]=a[x];
	in[x]=y,sz[y]++;
	for(LL i:V[x])
	{
		if(a[i]==a[x])dfs(i,y);
		else
		{
			dfs(i,0),v[y].pb(in[i]);
			LL X=a[i],Y=a[x];
			if(X>Y)swap(X,Y);
			if(!nam.count(X*n+Y))nam[X*n+Y]=++Tot;
			B[nam[X*n+Y]].pb({in[i],y});
		}
	}
}
unordered_map<LL,LL>Ans;
int main()
{
	scanf("%lld%lld",&n,&q);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
	}
	for(int i=2;i<=n;i++)
	{
		LL x;
		scanf("%lld",&x);
		V[x].pb(i);
	}
	dfs(1,0);
	for(int i=1;i<=tot;i++)cnt[c[i]]+=sz[i]*sz[i],fa[i]=i,Sz[i]=1;
	while(q--)
	{
		LL x,y;
		scanf("%lld%lld",&x,&y);
		if(x>y)swap(x,y);
		if(Ans.count(x*n+y))
		{
			printf("%lld\n",Ans[x*n+y]);
			continue;
		}
		LL ans=cnt[x]+cnt[y];
		stack<LL>q;
		if(!nam.count(x*n+y))
		{
			printf("%lld\n",ans);
			continue;
		}
		for(auto i:B[nam[x*n+y]])
		{
			LL xx=find(i.fir),yy=find(i.sec);
			if(Sz[xx]<Sz[yy])swap(xx,yy);
			ans-=sz[xx]*sz[xx]+sz[yy]*sz[yy];
			Sz[xx]+=Sz[yy],sz[xx]+=sz[yy],fa[yy]=xx;
			ans+=sz[xx]*sz[xx];
			q.push(yy);
		}
		while(!q.empty())
		{
			LL t=q.top();
			Sz[fa[t]]-=Sz[t],sz[fa[t]]-=sz[t],fa[t]=t;
			q.pop();
		}
		printf("%lld\n",Ans[x*n+y]=ans);
	}
	return 0;
}
//RP++
```

---

## 作者：Tachibana_Kimika (赞：0)

### 题目解析

树上每个点都有颜色，然后每次选定两种颜色，询问有都少无序点对满足两点路径上所有点都是这两种颜色之一。

我们发现，对于一个连通块，答案就是连通块大小的平方。所以我们可以先预处理每个同色连通块的大小，然后每次询问只需要合并两种颜色的连通块就行。

我们找到两边分别是两种颜色的边，然后使用并查集维护连通块即可。

撤销的话，我们可以直接记录修改了哪些东西，暴力改回来就行。

因为 umap 不能存 pair，所以可以先把颜色哈希了，再存。

umap 跑的比 gp_hash_table 快一点儿。

赛时代码，奇丑，大概看看就行。

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/hash_policy.hpp>
#include<ext/pb_ds/assoc_container.hpp>
using namespace std;
using namespace __gnu_pbds;


const int N=3e6+10;

int a[N];

long long ltksiz[N];

int fk[N];
int fkid[N];
int fkcnt;//撤销并查集

int fa[N];
int find(int x){
	if(fa[x]==x) return x;
	fk[++fkcnt]=fa[x];
	fkid[fkcnt]=x;
	return fa[x]=find(fa[x]);
}

struct node{
	int to,nxt,from;
	pair<int,int> w;
}edge[N*2]; int head[N],cnt;
void add(int u,int v){
	edge[++cnt].to=v;
	edge[cnt].from=u;
	edge[cnt].nxt=head[u];
	head[u]=cnt;
	if(a[u]>a[v]) edge[cnt].w={a[v],a[u]};
	else edge[cnt].w={a[u],a[v]};
}
void adde(int u,int v){
	add(u,v); add(v,u);
}

long long ans[N];
long long tot;

long long H(pair<int,int> a){//哈希
	return a.first*10000001ll+a.second;
}


unordered_map<long long,int>mp; int cnt2;
unordered_map<long long,long long>lastans;
//gp_hash_table<long long,int>bk;
vector<int>E[N];


int vis[N];

void dfs(int u,int f,int lt//预处理连通块
	tot++; vis[u]=1; fa[u]=lt;
	for(int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to; if(v==f||vis[v]) continue;
		if(edge[i].w.first!=edge[i].w.second) continue;
		dfs(v,u,lt);
	}
}

inline int read(){
	int x=0; char ch=getchar();
	while(ch>'9'||ch<'0') ch=getchar();
	while('0'<=ch&&ch<='9'){
		x=(x<<1)+(x<<3); x=x+ch-'0';
		ch=getchar();
	}
	return x;
}

int mcnt;
int modify[N][2];//撤销连通块

void fake_main(){
	int n,q; n=read(); q=read();
	for(int i=1;i<=n;++i) fa[i]=i;
	for(int i=1;i<=n;++i) a[i]=read();
	for(int i=2;i<=n;++i){
		int p; p=read();
		adde(i,p);
		
		pair<int,int> k=edge[cnt].w;
		long long hsh=H(k);
		if(!mp[hsh]) mp[hsh]=++cnt2;
		E[mp[hsh]].push_back(cnt);
	}
	
	for(int i=1;i<=n;++i){
		tot=0;
		if(!vis[i]){
			dfs(i,0,i);
			ans[a[i]]+=tot*tot;
			ltksiz[i]=tot;
		}
	}
	for(int i=1;i<=q;++i){
		int u,v; u=read(); v=read();
		pair<int,int> colt;
		if(u>v) colt={v,u};
		else colt={u,v};
		
		long long tmpans=ans[u]+ans[v];
		int ttk=mp[H(colt)];
		
		if(!ttk){
			cout<<tmpans<<"\n";
			continue;
		}
		if(lastans[ttk]){
			cout<<lastans[ttk]<<"\n";
			continue;
		}
		
		
		
		for(auto j:E[ttk]){
			int x=edge[j].from;
			int y=edge[j].to;
			
			x=find(x); y=find(y);
			
			fk[++fkcnt]=fa[y];
			fkid[fkcnt]=y;
			
			tmpans+=ltksiz[x]*ltksiz[y]*2ll;//合并
			fa[y]=x;
			ltksiz[x]+=ltksiz[y];
			

			modify[++mcnt][0]=y;
			modify[mcnt][1]=x; 

		}
		
		for(int j=mcnt;j>=1;--j){//撤销
			int x=modify[j][1];
			int y=modify[j][0];
			//fa[y]=y;
			ltksiz[x]-=ltksiz[y];
		}
		for(int j=fkcnt;j>=1;--j){
			fa[fkid[j]]=fk[j];
		}
		mcnt=0; fkcnt=0;
		
		cout<<tmpans<<"\n";
		lastans[ttk]=tmpans;
	}
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	int t; t=1;
	while(t--) fake_main();
}
```

---

## 作者：TernaryTree (赞：0)

定义一条边的边权是两端结点的无序颜色对。

考虑 $x=y$ 如何做。找出 $(x,x)$ 的所有边，并且合并两端点，更新每个连通块大小的平方和。记忆化一下，总合并边数最多是 $n-1$，这就是对的。

考虑 $x\neq y$，此时假定我们已经合并好了 $(x,x),(y,y)$ 的连通块，那么，我们只需要合并 $(x,y)$。这个时候记忆化完合并边数也是 $\Theta(n)$。

于是我们预处理 $x=y$ 的连通块，并查集处理即可。要使用一个数组维护可撤销并查集。

```
#include <bits/stdc++.h>
#include <ext/pb_ds/hash_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#define ll long long
#define fs first
#define sc second
#define cc_hash_table unordered_map

using namespace std;
using namespace __gnu_pbds;
using pii = pair<int, int>;
using edge = pair<pii, pii>;
using query = pair<pii, int>;

struct ios {
    inline char read() {
        static const int inlen = 1 << 18 | 1;
        static char buf[inlen], *s, *t;
        return (s == t) && (t = (s = buf) + fread(buf, 1, inlen, stdin)), s == t ? -1 : *s++;
    }
    template<typename T> inline ios& operator>> (T &x) {
        static char c11, boo;
        for (c11 = read(), boo = 0; !isdigit(c11); c11 = read()) {
            if (c11 == -1) return *this;
            boo |= c11 == '-';
        }
        for (x = 0; isdigit(c11); c11 = read()) x = x * 10 + (c11 ^ '0');
        boo && (x = -x);
        return *this;
    }
} fin;

struct exios {
    template<typename _CharT, typename _Traits = char_traits<_CharT>>
    struct typ {
        typedef basic_ostream<_CharT, _Traits>& (* end) (basic_ostream<_CharT, _Traits>&);
    };

    template<typename T> friend exios &operator<<(exios &out, T num) {
        if (num < 0) putchar('-'), num = -num;
        if (num >= 10) out << num / 10;
        putchar(num % 10 + '0');
        return out;
    }

    friend exios &operator<<(exios &out, const char * s) { printf("%s", s); return out; }
    friend exios &operator<<(exios &out, string s) { cout << s; return out; }
    friend exios &operator<<(exios &out, typ<char>::end e) { puts(""); return out; }
} fout;

const int maxn = 3e6 + 10;
const ll N = 1e9;

int n, m;
int a[maxn];
edge e[maxn];
query q[maxn];
cc_hash_table<ll, ll> mp;
cc_hash_table<ll, vector<int>> pe;
int vis[maxn], vs[maxn];
vector<int> g[maxn];

int qfa[maxn];
int qsiz[maxn];
int fa[maxn], siz[maxn];
ll qwq[maxn];
int qaq[maxn], vqaq[maxn], sqaq[maxn], idx;

int find(int x) {
	if (x == fa[x]) return x;
	qaq[++idx] = x;
	vqaq[idx] = fa[x];
	sqaq[idx] = 0;
	return fa[x] = find(fa[x]);
}

int otto;

void dfs(int u, int rt, int f) {
	qfa[u] = rt;
	++otto;
	for (int v : g[u]) {
		if (v == f) continue;
		if (a[v] == a[rt]) dfs(v, rt, u);
	}
}

signed main() {
	fin >> n >> m;
	for (int i = 1; i <= n; i++) fin >> a[i], vis[a[i]]++;
	for (int i = 2, f; i <= n; i++) {
		fin >> f;
		g[i].push_back(f), g[f].push_back(i);
		ll x = a[i], y = a[f];
		if (x > y) swap(x, y);
		e[i] = {{i, f}, {x, y}};
		ll hsh = (x == y ? x : (ll) x * N + y);
		if (pe.find(hsh) == pe.end()) pe[hsh] = vector<int> ();
		pe[hsh].push_back(i);
	}
	for (int i = 1; i <= n; i++) {
		if (!qfa[i]) {
			otto = 0;
			dfs(i, i, 0);
			qsiz[i] = otto;
			qwq[a[i]] += (ll) otto * otto;
		}
	}
	for (int i = 1; i <= n; i++) {
		fa[i] = qfa[i];
		siz[i] = qsiz[i];
	}
	for (int i = 1; i <= m; i++) {
		ll x, y;
		fin >> x >> y;
		if (x > y) swap(x, y);
		if (!vis[x] && !vis[y]) {
			fout << 0 << endl;
			continue;
		}
		if (!vis[x]) {
			fout << qwq[y] << endl;
			continue;
		}
		if (!vis[y]) {
			fout << qwq[x] << endl;
			continue;
		}
		ll hsh = (ll) x * N + y;
		if (mp.find(hsh) != mp.end()) {
			cout << mp[hsh] << endl;
			continue;
		}
		ll cur = qwq[x] + qwq[y];
		idx = 0;
		if (pe.find(hsh) != pe.end()) {
			for (int j : pe[hsh]) {
				int u = find(e[j].fs.fs), v = find(e[j].fs.sc);
				qaq[++idx] = v;
				vqaq[idx] = fa[v];
				sqaq[idx] = siz[v];
				fa[v] = u;
				cur -= (ll) siz[v] * siz[v];
				cur -= (ll) siz[u] * siz[u];
				siz[u] += siz[v];
				cur += (ll) siz[u] * siz[u];
			}
		}
		fout << cur << endl;
		mp[hsh] = cur;
		while (idx) {
			int u = qaq[idx], f = vqaq[idx];
			siz[fa[u]] -= sqaq[idx];
			fa[u] = f;
			idx--;
		}
	}
	return 0;
}
```

---


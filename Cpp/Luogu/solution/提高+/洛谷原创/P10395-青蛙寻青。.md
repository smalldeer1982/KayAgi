# 青蛙寻青。

## 题目背景

数次失败后，小青蛙的思想开始发生变化。

他开始寻找自己为青蛙之本。

他开始寻找其他青蛙帮忙。

他在发生蜕变。

他在升华。

他，将变成光！

他给自己取了新名字 —— 青蛙青（qwq），因为名字很可爱。

## 题目描述

白色光可以被分解成青色光还有很多其他颜色的光。

$\{a\}$ 是一个长度为 $n$，有 $k$ 种不同颜色的序列，第 $i$ 个元素颜色为 $a_i$（保证颜色 $1\sim k$ 都在 $a$ 中出现过）。

$\{b\}$ 是一个长度为 $m$ 的序列，第 $i$ 个元素颜色为 $b_i$（保证每个 $b_i$ 都是 $k$ 种颜色中的一种，但不保证 $k$ 种颜色都在 $b$ 中出现过）。我们可以修改 $b$ 中若干个位置的颜色，得到一个长度仍为 $m$ 的序列 $b'$。

我们对 $b'$ 与 $a$ 中颜色相同的点连这种颜色的一条线段。

如 $n=3,m=4,k=3,a=\{1,2,3\},b'=\{1,3,2,2\}$，它们之间的连线是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/kmi8og83.png)

要求**不同颜色的线段两两不交**，**且 $k$ 种颜色都要在 $b$ 中出现**，请问最少修改次数是多少？

形式化的，设你修改后的符合要求的序列为 $b'$，那么你需要最小化：

$$
\sum_{i=1}^{m}[b_i\ne b'_i]
$$

对于上述 $a=\{1,2,3\},b'=\{1,3,2,2\}$ 的情况，它们之间的连线（红色的 $2$ 与紫色 $3$ 之间）出现了相交。

但如果我们把 $b$ 修改成 $\{1,2,3,3\}$，它们之间的连线没有相交，满足上述条件：

![](https://cdn.luogu.com.cn/upload/image_hosting/9a1ljv02.png)

注意：

- $b' = \{1,1,4,5\}$ 的情况连线也没有相交，但是 $b'$ 包含了 $k$ 种颜色之外的颜色（有 $4$ 和 $5$），因此这个 $b'$ 不合法。
- $b' = \{1,1,1,1\}$ 的情况连线也没有相交，但是 $b'$ 中没有包含 $1\sim k$ 中所有的颜色（没有 $2$ 和 $3$），因此这个 $b'$ 也不合法。

特别的，如果无论怎样修改都无法满足要求，请输出 `-1`。

## 说明/提示

**【样例 #1 解释】**

将 $\{1,3,2,2\}$ 修改为 $\{1,2,2,3\}$。

可以证明这是修改次数最少的方式。

**【样例 #2 解释】**

将 $\{1,2,3,3,3\}$ 修改为 $\{1,2,3,3,4\}$。

可以证明这是修改次数最少的方式。

---

**本题开启捆绑测试以及子任务依赖。**

**本题时限 2s。**

|$\text{Subtask}$| $n,m\le$ | 分数 | 子任务依赖 |
|:---:|:---:|:---:|:---:|
| $1$ | $5$ | $5$ | 无 |
| $2$ | $5000$| $35$ | $1$ |
| $3$ | $10^5$| $30$ | $1,2$ |
| $4$ | $2\times 10^6$| $30$ | $1,2,3$ |

- 对于 $100\%$ 的数据，保证 $1\le n,m\le 2\times 10^6$，$1\le a_i,b_i \le n$。设 $\max\limits_{i=1}^n{a_i} = k$，保证 $1\sim k$ 均在 $a$ 中出现过，且 $1\le k \le n$。

## 样例 #1

### 输入

```
3 4
1 2 3
1 3 2 2```

### 输出

```
2```

## 样例 #2

### 输入

```
5 5
1 2 3 4 4
1 2 3 3 3```

### 输出

```
1```

## 样例 #3

### 输入

```
5 10
1 2 3 4 5
1 2 2 3 2 2 2 4 5 4```

### 输出

```
3```

## 样例 #4

### 输入

```
10 2
1 2 1 2 2 2 2 2 2 2
2 2```

### 输出

```
-1```

# 题解

## 作者：_maojun_ (赞：8)

首先给 $a,b$ 按颜色在 $a$ 中出现的顺序重新编号，如果 $a$ 重新编号不单调不降则无解。

于是问题就变为求一个单调不降的 $b'$ 使得 $\sum\left[b_i\ne b'_i\right]$ 最小，我们称这个值为不同程度。

首先状态 $n^2$ 的 dp 应该是没前途的，考虑点 $O(n)$ 状态的。

设 $dp_i$ 表示 $b'_i=b_i$ 时前 $i$ 个数的最小不同程度。

可以枚举上一个使得 $b'_j=b_j$ 的 $j$，从 $j$ 转移。考虑 $j$ 满足的条件。

首先 $b_j\le b_i$，然后因为每种颜色都需要出现，所以 $i-j\ge b_i-b_j$，再加上 $j<i$，可以得到一个三维偏序：

$$
\left\{\begin{matrix}
j<i\\b_j\le b_i\\j-b_j\le i-b_i
\end{matrix}\right.
$$

则有 dp 式：

$$dp_i=\max\limits_{j<i,b_j\le b_i,j-b_j\le i-b_i}dp_j+1$$

$$\mathrm{ans}=m-\max\limits_{m-i\ge k-b_i}dp_i$$

乍一看不太好做，但是发现如果把后两条式子相加即可以得到 $j\le i$，而 $i\ne j$ 是很好保证的。也就是当 $i\ne j$ 时条件 $1$ 弱于条件 $2,3$，一定成立。

只考虑后面两个限制，则变成一个二位偏序问题。

单点修改前缀 $\max$ 可以直接树状数组。复杂度 $O(n\log n)$。

```cpp
const int N=2e6+5;
int n,m,a[N],b[N],k=0,p[N];

#define pi pair<int,int>
#define fi first
#define se second
#define mp make_pair
pi c[N];
const int INF=0x3f3f3f3f;
inline void ckmx(int&x,int y){x<y&&(x=y);}
int tr[N+N];								// 由于 i-b[i] 可能为负数，要加上偏移量
inline void upd(int p,int k){for(p+=N;p<N+N;p+=p&-p)ckmx(tr[p],k);}
inline int qry(int p){int r=-INF;for(p+=N;p;p^=p&-p)ckmx(r,tr[p]);return r;}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){scanf("%d",&a[i]);!p[a[i]]&&(p[a[i]]=++k);}
	for(int i=2;i<=n;i++)if(p[a[i-1]]>p[a[i]]){puts("-1");return 0;}
	for(int i=1;i<=m;i++){
		scanf("%d",&b[i]);b[i]=p[b[i]];		// 按 a 的顺序重新编号
		c[i]=mp(b[i],i-b[i]);				// 二维偏序
	}
	sort(c+1,c+m+1);
	memset(tr,0xc0,sizeof tr);upd(0,0);
	int res=0;
	for(int t=1;t<=m;t++){
		int i=c[t].fi+c[t].se;
		int dp=qry(c[t].se)+1;
		upd(c[t].se,dp);
		if(m-i>=k-b[i])ckmx(res,dp);
	}
	printf("%d\n",m-res);
	return 0;
}
```

---

## 作者：SamHJD (赞：7)

## [青蛙寻青。](https://www.luogu.com.cn/problem/P10395)

### Description

给出长为 $n$ 的序列 $a$ 和长为 $m$ 的序列 $b$。定义 $b$ 是好的，仅当$a$ 中的所有数都在 $b$ 中出现过，且不存在 $1\le i<j\le n,a_i\ne a_j$，$b$ 中 $a_i$ 的位置在 $a_j$ 之后。

求使 $b$ 变为好的最少修改几个元素，或输出无解。

### Solution

显然 $a$ 中相同的数必需处在一个连续的区间内。把 $a$ 中的数去重后，将 $b$ 中的每一个数修改为其在 $a$ 中的位置，最终我们要使 $b$ 不降。

$b$ 的第一位必为 $1$，第 $m$ 位必为 $a$ 去重后的大小，这两位直接判断计入答案，方便后面的计算。

此时可用朴素的 $O(nm)$ 动态规划获得 $40$ 分，状态为前 $i$ 位最后一位为 $j$ 的最小修改次数，空间可以压到 $n$，不过并没有什么用。

设最终 $b$ 不修改的位置集合为 $S$，则需对任意 $1\le j < i \le m$ 满足 $S_i-S_j\ge b_i-b_j\ge 0$，我们要最大化 $S$ 的大小。

将 $b$ 从小到大排序后，我们可以去掉不小于 $0$ 这一限制，上式变为 $S_i-S_j\ge b_i-b_j$。移项得 $S_i-b_i\ge S_j-b_j$。

于是将 $b$ 排序后，设 $c_i=i-b_i$，问题转化为求 $c$ 的最长不降子序列。参考导弹拦截一题，复杂度可以做到 $O(n\log n)$。

### Code

```cpp
#include<bits/stdc++.h>
#define rep(i,s,t) for(int i=s;i<=t;++i)
#define per(i,t,s) for(int i=t;i>=s;--i)
using namespace std;
template<typename T>
inline void read(T &x) {
	x=0;int f=1;char c=getchar();
	for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=x*10+c-'0';
	x*=f;
}
const int N=2e6+10;
int n,m,a[N],b[N],id[N],f[N],k,ans;
pair<int,int> q[N];
int main(){
	read(n);read(m);
	rep(i,1,n) read(a[i]);
	rep(i,1,m) read(b[i]);
	rep(i,1,n){
		if(a[i]!=a[i-1] && id[a[i]]){
			printf("-1");
			return 0;
		}
		else if(a[i]!=a[i-1]) id[a[i]]=++k;
	}
	rep(i,1,m) b[i]=id[b[i]];
	if(b[1]!=1) ans++,b[1]=1;
	if(b[m]!=k) ans++,b[m]=k;
	rep(i,1,m) q[i]=make_pair(b[i],i-b[i]);
	sort(q+1,q+m+1);
	rep(i,1,m) b[i]=q[i].second;
	int res=1;f[1]=b[1];
	rep(i,2,m){
		if(b[i]>=0&&b[i]<=b[m]){
			if(b[i]>=f[res]){
				++res;
				f[res]=b[i];
				continue;
			}
			int l=1,r=res;
			while(l<r){
				int mid=(l+r)>>1;
				if(f[mid]<=b[i]) l=mid+1;
				else r=mid;
			}
			f[r]=min(f[r],b[i]);
		}
	}
	printf("%d",ans+(m-res));
	return 0;
}

---

## 作者：TTpandaS (赞：5)

首先可以发现我们需要把 $b$ 变成几段连续的相同字符，每一段去匹配一段 $a$ 中连续的相同字符。

考虑如何判断 -1，可以发现如果 $a$ 中相同字符在几个不同的段中出现，连线一定交叉。此外，如果 $a$ 分的段数大于了 $b$ 的长度，$b$ 一定也是匹配不完的。

想到了 $b$ 与 $a$ 的匹配，于是设计 $dp_{i,j}$ 表示 $b$ 的前 $i$ 个字符匹配了 $a$ 中 $j$ 段的最小修改次数。

那么 $ dp_{i,j}=\min(dp_{i-1,j-1},dp_{i-1,j})+[b_i \neq a_j] $。

时间复杂度 $O(n^2)$，但是数据较水，$a$ 中段数不是很多，可以过 1e5 的数据，赛时 70 pts。

考虑如何优化。

转换一下，设计 $dp_{i,j}$ 表示 $b$ 的前 $i$ 个字符匹配了 $a$ 中 $j$ 段的最大匹配次数，最后即用 $b$ 的长度减去不用修改的次数（即匹配的次数）。

那么 $ dp_{i,j}=\max(dp_{i-1,j-1},dp_{i-1,j})+[b_i = a_j] $。

可以发现就是一个 $n \times m$ 的矩阵（$n$ 为 $a$ 分的段数），每一行都有一个特殊点（$b_i=a_j$ 的时候），从 $(1,1)$ 开始，每次可以向下走或向右走，问走到 $(n,m)$ 能遇到的最多特殊点数量。

设计 $f_i$ 表示走到第 $i$ 行特殊点上时遇到的最多特殊点数量。

那么 $f_i= 1+ \max_{j=1}^{i-1} [b_j < b_i , b_i-b_j<i-j]f_j$。

这样显然是一个二维偏序关系，此时可以用 CDQ 和树状数组做到 $\log^2$，没有试过，不知道能不能过。

考虑进一步优化。如果将 $b_i$ 排序，按照 $b_i$ 的大小顺序来 DP，可以发现此时也是正确的，因为将不等式结合一下是显然成立的，那么就可以直接用树状数组优化。

时间复杂度 $O(n \log n)$。

---

## 作者：gan1234 (赞：5)

### 分析

首先将 $a$ 看作是一堆颜色段。 显然，如果一个颜色段出现了两次，必定存在交叉。

在 $a$ 没有重复颜色段的情况下，什么样子的 $b$ 是合法的呢？发现只有 $b$ 中所有颜色出现的顺序与 $a$ 相同才行。换句话说，将一个颜色段当成一个元素时，$b$ 完全与 $a$ 相同。


将所有颜色按 $a$ 出现的顺序标号。最小化修改数等价于最大化不修改数。而修改后的 $b$ 出现的颜色顺序与 $a$ 相同，因此不修改的数构成了一个不降子序列。

那么直接对 $b$ 求不降子序列就完了吗？

并不是，因为还有一个约束是要求 $b$ 中必须出现所有颜色。

这意味着不降子序列中相邻的两个元素 $b_j,b_i$，之间至少要有 $b_i-b_j$ 的间隔使得其间能填的下 $[b_j+1,b_i-1]$ 里所有数，也就是 $b_i-b_j\le i-j$，并且子序列的开头 $b_i\le i$，子序列的结尾 $b_i \ge n-i$。

为了方便起见，将 $b_i-b_j\le i-j$ 变成 $b_i-i\le b_j-j$。

因此我们 dp 转移时有三个条件：

- $b_j\le b_i$
- $j<i$
- $b_i-i\le b_j-j$

对于所有满足条件的 $j$，我们有 dp 转移 $f_i=\max(f_j+1)$。

这是典型的三维偏序问题，能在 $O(n\log^2 n)$ 时间做完。

观察发现，第二个约束其实没有用，因为当 $b_j<b_i$ 且 $b_i-i\le b_j-j$ 时，一定满足 $j<i$。

这样我们就变成了二维偏序，和正常的求最长不降子序列没有区别，直接随便按一维排序，另一维用线段树维护即可。

复杂度 $O(n\log n)$。

最后不要忘记了子序列的开头 $b_i\le i$，子序列的结尾 $b_i \ge n-i$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans,cnt;
int a[2000005],b[2000005];
const int hshmod=1145141;
struct Hsh{
	vector<int>v1[hshmod],v2[hshmod];
	int& operator[](int k){
		int t=k%hshmod;
		for(int i=0;v1[t].size()>i;i++)
			if(v1[t][i]==k)return v2[t][i];
		v1[t].push_back(k);
		v2[t].push_back(0);
		return v2[t].back();
	}
}ma;
struct Node{
	int x,y;
}p[2000005];
struct Seg{
	int l,r;
	int mx;
}dat[8000005];
inline int Max(int x,int y){
	return x>y?x:y;
}
void build(int l,int r,int k){
	dat[k].l=l;dat[k].r=r;
	if(l==r)return ;
	int m=(l+r)/2;
	build(l,m,k+k);
	build(m+1,r,k+k+1);
} 
void update(int x,int z,int k){
	if(dat[k].l==x&&dat[k].r==x){
		dat[k].mx=Max(dat[k].mx,z);
		return ;
	}
	int m=(dat[k].l+dat[k].r)/2;
	if(x<=m)update(x,z,k+k);
	else update(x,z,k+k+1);
	dat[k].mx=Max(dat[k+k].mx,dat[k+k+1].mx);
}
int query(int x,int y,int k){
	if(x>y)return 0;
	if(dat[k].l==x&&dat[k].r==y)return dat[k].mx;
	int m=(dat[k].l+dat[k].r)/2;
	if(y<=m)return query(x,y,k+k);
	else if(x>m)return query(x,y,k+k+1);
	else return Max(query(x,m,k+k),query(m+1,y,k+k+1));
}
int cmp(Node n1,Node n2){
	if(n1.y==n2.y)return n1.x<n2.x;
	return n1.y>n2.y;
}
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;n>=i;i++)cin>>a[i];
	for(int i=1;m>=i;i++)cin>>b[i];
	for(int i=1;n>=i;i++)
		if(ma[a[i]]&&a[i]!=a[i-1]){
			cout<<-1<<endl;
			return 0;
		}else if(!ma[a[i]]){
			ma[a[i]]=++cnt;
		}
	for(int i=1;m>=i;i++)b[i]=ma[b[i]];
	for(int i=1;m>=i;i++)p[i].x=b[i],p[i].y=b[i]-i;
	sort(p+1,p+m+1,cmp);
	build(1,cnt,1);
	for(int i=1;m>=i;i++){
		int t=query(1,p[i].x,1);
		if(p[i].y<=0)t++;
		update(p[i].x,t,1);
		if(p[i].y>=cnt-m&&p[i].x)ans=max(ans,t);
	}
	cout<<m-ans<<endl;
	return 0;
}
```

---

## 作者：良心WA题人 (赞：3)

首先一个很显然的事实，如果存在一个颜色使得它在 $a$ 串不连续，则必然会产生不同色的相交线段。不难发现无解只有这种和 $m<k$ 两种情况。

于是我们把相同颜色缩成一个点，可以发现要连线不交即 $b$ 串进行类似操作后和 $a$ 串相同。

考虑用每种颜色去染色 $b$，则染色的权值是 $b_l$ 到 $b_r$ 中颜色不为 $a_i$ 的颜色的个数。于是就有一个很显然的 $n^2$ dp，设 $f_{i,j}$ 为染完了 $b$ 的前 $j$ 个位置，颜色用到了 $a_i$ 的最小花费。

这个 $dp$ 是二维的所以看上去很不好优化。若 $b$ 中每个位置都被染色了则花费为 $m$，否则一定存在一个位置和原来的颜色相同。于是考虑换一个定义：$f_i$ 表示染完了 $b$ 的前 $i$ 个位置，颜色用到了 $b_i$ 的最小花费。即钦定了位置 $i$ 是最后一个没产生花费的位置。

下令 $c_{a_i}=i$。

此时 $f_i$ 可以从 $f_j+i-j-1$ 转移。不过需要满足 $c_i\ge c_j$ 且 $c_i-c_j-1\le i-j-1$。

第二个式子可以变成 $c_i-i\le c_j-j$，可以直接树状数组优化 dp。

第一个也很好处理，因为若 $i<j$ 且 $c_i>c_j$ 的时候一定不满足第二个式子，所以 dp 顺序变成按第一关键字为 $c_i$，第二关键字为 $i$ 从小到大转移就好。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NN=2e6+4;
int a[NN],id[NN],tr[NN],m;
vector<int>g[NN];
int lowbit(int x)
{
	return x&-x;
}
void add(int u,int v)
{
	while(u<=m)
	{
		tr[u]=min(tr[u],v);
		u+=lowbit(u);
	}
}
int ask(int u)
{
	int res=1e9;
	while(u)
	{
		res=min(res,tr[u]);
		u-=lowbit(u);
	}
	return res;
}
int main()
{
	int n,k=0;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(!id[a[i]])
			id[a[i]]=++k;
		else if(a[i-1]!=a[i])
		{
			printf("-1");
			return 0;
		}
	}
	if(m<k)
	{
	    printf("-1");
	    return 0;
	}
	for(int i=1;i<=m;i++)
	{
		int x;
		scanf("%d",&x);
		g[id[x]].push_back(i);
	}
	memset(tr,0x3f,sizeof(tr));
	add(1,0);
	int ans=m;
	for(int i=1;i<=k;i++)
		for(int p:g[i])
			if(p>=i&&m-p>=k-i)
			{
				int w=p-1+ask(p-i+1);
				ans=min(ans,w+m-p);
				add(p-i+1,w-p);
			}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：是青白呀 (赞：2)

首先要会判断无解。当 $a$ 中存在下标 $i,j,k$ 使得 $i<j<k$ 且 $a_i=a_k\neq a_j$，则引出的连线一定会相交，无解。否则一定有解。在有解的情况下，我们可以对 $a$ 序列去重，使得一个数最多在 $a$ 中出现 $1$ 次。下文出现的 $n$ 均表示去重后序列 $a$ 的长度。

朴素的做法是设 $dp_{i,j}$ 表示考虑到 $b$ 序列的第 $i$ 个数，已经匹配到 $a$ 序列的第 $j$ 个数的最小修改次数。转移是 $dp_{i,j}=\min(dp_{i-1,j},dp_{i-1,j-1})+[a_j\neq b_i]$。这里可以做到 $O(nm)$，期望得分 $40$。

考虑转移的路径。若将 $dp_{i,j}$ 写入 $m\times n$ 的矩阵，则每次转移等价于往正下方或右下方的格子走一步，并根据到达的格子 $(x,y)$ 是否满足 $a_y\neq b_x$ 决定花费是否增加 $1$。于是，整个 dp 的过程可以被看作是从 $(0,0)$ 开始，每次往正下方或右下方的格子走一步，最终走到 $(m,n)$ 的一条路径，最终答案即为路径上格子权值和的最小值。

我们发现，从起始点 $(0,0)$ 开始走到 $(m,n)$ 结束的路径，其长度必定为 $m$。同时，由于去重后的序列 $a$ 中所有元素均不相同，不满足 $a_y\neq b_x$ 的格子 $(x,y)$ 仅有 $m$ 个。那么，一条路径的权值和可以表示为 $m$ 减去途径的满足 $a_y=b_x$ 的格子 $(x,y)$ 的个数所得到的值。因此，我们希望最大化经过的满足 $a_y=b_x$ 的格子 $(x,y)$ 的数量。

我们可以把所有合法的格子坐标按 $x$ 从小到大排序，设 $f_i$ 表示以第 $i$ 个格子结尾，能走到的格子数量的最大值。有转移 $f_i=f_j+1$，其中 $j$ 需要满足 $j<i$ 且 $y_i-y_j\in[0,i-j]$。考虑到两侧的限制中，含 $j$ 的变量不同，这个转移方程仍然不容易优化。

存在这样复杂限制的原因是在原始的矩阵中，存在着向右下方的走法。于是我们考虑把向右下方走一步转换成向右走一步。我们把原本坐标为 $(x,y)$ 的格子的坐标重新设为 $(x-y,y)$，这样向下方走一步仍然是 $x$ 坐标 $+1$，向右下方走一步就转化为了 $y$ 坐标 $+1$ 而 $x$ 坐标不变。此时，我们再将所有合法的格子坐标按新的 $x$ 从小到大排序，转移方程不变，而限制变为了 $j\leq i$ 且 $y_j\leq y_i$。我们对 $y$ 坐标开树状数组维护前缀最大值，即可在 $O(\log n)$ 的复杂度内完成一步转移。最终答案为 $m-\max_i f_i$。

时间复杂度 $O(m\log n)$。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) x*2
#define rs(x) x*2+1
#define lowbit(x) x&(-x)
#define pii pair<int,int>
#define mp make_pair
#define fir first
#define sec second 
#define qingbai 666
using namespace std;
typedef long long ll;
const int N=2e6+5,M=25,mo=1e9+7,inf=1e9+7,bs=19491001;
const double eps=1e-8;
inline void read(int &p){
	int x=0,w=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int n,m,a[N],b[N],dp[N],pos[N],cntp;
bool vis[N];
struct BIT{
	int t[N];
	void add(int x,int v){
		for(int i=x;i<=n;i+=lowbit(i))
		    t[i]=max(t[i],v);
	}
	int query(int x){
		int res=0;
		for(int i=x;i;i-=lowbit(i))
		    res=max(res,t[i]);
		return res;
	}
}T;
pii tp[N];
int main(){
	read(n),read(m);
	rep(i,1,n)
		read(a[i]);
	rep(i,1,m)
	    read(b[i]);
    rep(i,1,n){
	    if(!vis[a[i]]||a[i]==a[i-1]){
	    	vis[a[i]]=1;
	    	continue;
	    }
	    puts("-1");
	    return 0;
	}
	n=unique(a+1,a+n+1)-a-1;
	rep(i,1,n)
	    pos[a[i]]=i;
	rep(i,1,m)
	    if(i>=pos[b[i]])tp[++cntp]=mp(i-pos[b[i]],pos[b[i]]);
	if(n>m){
		puts("-1");
		return 0;
	}
	tp[++cntp]=mp(m-n,n);
	sort(tp+1,tp+cntp+1);
	int ans=0;
	rep(i,1,cntp){
		dp[i]=T.query(tp[i].sec)+1;
		T.add(tp[i].sec,dp[i]);
		if(tp[i].fir==m-n&&tp[i].sec==n){
			ans=m-dp[i]+1;
			break;
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：yzy1 (赞：2)

首先若存在 $a_x,a_y,a_z$ 满足 $x<y<z$ 且 $a_x = a_z \ne a_y$，则无论如何调整 $b$ 总存在颜色为 $a_x$ 的线段与颜色为 $a_y$ 的线段相交．因此有解的 $a$ 一定是每种颜色均形成一个连续段．考虑把每种颜色按照在 $a$ 中第一次出现的数字排序，然后把 $b_i$ 替换为 $b_i$ 的 rank．此时题意转化为调整 $b$ 中的值使得 $b$ 中包含 $[1,k]$ 中所有数字且不降．

令 $\operatorname{dp}(i,j)$ 表示将 $b$ 的 $[1,i]$ 子序列变为以 $j$ 结尾的符合题目要求的序列的最小代价，可得递推式：

$$
\operatorname{dp}(i,j) = \min\{\operatorname{dp}(i-1,j-1), \operatorname{dp}(i-1,j)\} + [b_i \ne j].
$$

这个 DP 是两维的，看起来不好优化．正难则反，考虑最大化最终的 $b$ 序列中和最开始一样的位置的个数．即选择 $b$ 的一个子序列保持不变，显然这样的子序列一定严格不降．同时，为保证修改其他元素后序列中 $[1,k]$ 各出现至少一次，子序列相邻两个元素的差值不大于两个元素在原序列下标之差．

重新令 $\operatorname{dp}(i)$ 表示选出的子序列最后一个元素是 $i$ 的情况下，子序列长度的最大值．显然只有 $i$ 满足 $i \ge b_i$ 且 $n-i \ge K-b_i$ 时 $\operatorname{dp}(i)$ 有意义．结合以上分析，可以得到转移：

$$
\operatorname{dp}(i) = \max_{\begin{subarray}{c}j<i\\b_j \le b_i\\b_i-b_j \le i-j\end{subarray}}\{\operatorname{dp}(j+1)\} + 1.
$$

第三个限制可变化为 $b_i - i \le b_j - j$，此时限制是三维的，若直接用二维数据结构维护，则时间复杂度为 $\operatorname{O}(n (\log n)^2)$，无法通过本题．

注意到若 $b_i - i \le b_j - j$ 且 $b_i \ge b_j$，则一定有 $i \le j$．所以若一开始按照 $b_i$ 而非 $i$ 排序，则条件仅剩下一维，可以用线段树直接维护．时间复杂度为 $\operatorname{O}(n \log n)$，可以通过本题．

代码参考见 [外部剪贴板](https://paste.debian.net/1315744/)．

---

## 作者：_•́へ•́╬_ (赞：1)

## 思路

如果一种颜色在 $a$ 中的出现不连续，那么夹在中间的就肯定交叉了，无解。

把颜色按在 $a$ 中的出现次数重新编号为 $1\sim k$。

把问题转化为，最大化不修改的位置个数。

然后你会发现这个有点像对 $b$ 数组直接做 LIS，不同之处在于每种颜色都要在修改之后的 $b$ 中出现。

传统 dp 做法是三维偏序，复杂度 $\mathcal O(n\log^2n)$，~~没写，数据水不造能不能草过去~~。

考虑把两维转一下，对着数值扫，对下标维护答案。这个答案显然是一个凸包，`map` 维护即可。

具体地，设当前外层转移到数值 $i$，转移方程为 $f[i][j]=\max(f[i][j-1],f[i-1][j-1]+[b_j==i])$。

前者意味着维护凸包，后者需要支持单点加一，下标上需要支持整体向左平移一位。

复杂度 $\mathcal O(n\log n)$。~~数据太水了，`map` 都能跑 $2\times 10^6$ 了。~~

## code

```cpp
#include<stdio.h>
#include<vector>
#include<map>
#define N 2000009
using namespace std;
inline char nc()
{
	static char buf[99999],*l,*r;
	return l==r&&(r=(l=buf)+fread(buf,1,99999,stdin),l==r)?EOF:*l++;
}
inline void read(int&x)
{
	char c=nc();for(;c<'0'||'9'<c;c=nc());
	for(x=0;'0'<=c&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=nc());
}
int n,m,p,a[N],b[N],id[N],cnt[N];map<int,int>mmp;vector<int>c[N];
main()
{
	read(n);read(m);
	for(int i=0;i<n;read(a[i++]));
	for(int i=1;i<=m;read(b[i++]));
	for(int i=0;i<n;++i)if(!i||(a[i]^a[i-1]))
		if(id[a[i]]){printf("-1");return 0;}
		else id[a[i]]=++p;
	if(p>m){printf("-1");return 0;}
	for(int i=1;i<=m;b[i]=id[b[i]],++cnt[b[i++]]);
	for(int i=1;i<=p;c[i].reserve(cnt[i]),++i);
	for(int i=1;i<=m;c[b[i]].emplace_back(i),++i);
	mmp[0]=0;
	for(int i=1;i<=p;++i)
	{
		if(mmp.rbegin()->first>m-i)mmp.erase(--mmp.end());
		for(int j=0;j<c[i].size();++j)if(c[i][j]-i>=0)
		{
			mmp[c[i][j]-i]=(--mmp.upper_bound(c[i][j]-i))->second+1;
			map<int,int>::iterator it=mmp.lower_bound(c[i][j]-i);
			for(;;)
			{
				map<int,int>::iterator it2=it;++it2;
				if(it2==mmp.end()||it2->second>it->second)break;
				mmp.erase(it2);
			}
		}
	}
	printf("%d",m-mmp.rbegin()->second);
}
```

---

## 作者：irris (赞：1)

> dp / CDQ 分治 / 优化偏序 / LIS

## Solution

显然，$a$ 中每种数必须要成为一个连续段，否则无论如何都会有相交线。简单遍历把 $a$ 中的所有数从左向右依次离散化为 $1 \sim k$，并且把 $b_1\dots b_m$ 也对应修改。另外 $k > m$ 无解。

接下来我们想要把 $b$ 改成一个值域 $[1, k]$ 的每种数都出现的不降序列。考虑 dp，经典地，设 $f_i$ 表示 $b'_i = b_i$，考虑到下标 $1\dots i$ 的最小修改次数，有

$$f_i = \min_{0 \leq j < i, b_j \leq b_i, i - j \geq b_i - b_j} (f_j + i - j - 1)$$

答案用所有 $m - i \geq k - b_i$ 的 $f_i + m - i$ 更新即可。

直接写 $\mathcal O(m^2)$，CDQ 分治优化 $\mathcal O(m\log^2 m)$。

注意到 $b_j \leq b_i$，$i - j \geq b_i - b_j$ 成立时一定有 $j \leq i$，因此这是二维的。因此抛弃 dp 的形式，改为对 $(b_i, i - b_i)$ 这个二元组序列按 $b$ 排序后做最长不降子序列，就可以得到最多有多少个数字可以不改。

## Code

只有核心部分。有一些简单的细节上文未提及，供参考。

```cpp
std::vector<int> var;
for (int i = 1; i <= M; ++i) var.push_back(i);
std::sort(var.begin(), var.end(), [&](int p, int q) -> bool { return b[p] == b[q] ? p - b[p] < q - b[q] : b[p] < b[q]; });
for (auto u : var) if (u >= b[u]) {
	int f = query(u - b[u]) + 1;
	chkmax(u - b[u], f);
	if (M - u >= K - b[u]) res = std::max(res, f);
}
```

---

## 作者：CommandSR (赞：0)

## 题意

[link](https://www.luogu.com.cn/problem/P10395)

## Subtask 1

写一个爆搜，一个颜色可以跟上一个相同，也可以是接在上一个颜色后面新开一个颜色，最后递归出口要判每个颜色是或否全部出现。

## Subtask 2

显然有一个 $O(n^2)$ 的 dp，设 $f_{i,j}$ 表示 $b$ 序列中前 $i$ 个数用 $j$ 种颜色填的最小修改次数。状态转移：

```
f[i][j] = min(f[i-1][j], f[i-1][j-1]) + (b[i] != c[j]);
```

## Subtask 3

上面那个 dp 看起来没有前途，所以尝试以颜色划分阶段。

首先对相同颜色的段“缩点”，最后目标状态的 $b$ 和 $a$ 是相同的，为了方便处理把 $a$ 映射成一个递增的序列。

然后 $f_i$ 可以从 $f_j + i-j+1$ 转移，其中 $j<i$，$c_j\le c_i$，$c_i-c_j\le i-j$，第三个条件相当于要留足够的位置填所有颜色。

然后问题转化为三维偏序问题，复杂度 $O(n\log^2 n)$。

## Subtask 4

考虑在上面 dp 的基础上优化，首先我们按照颜色转移，可以确定 $c_j\le c_i$，然后发现 $i<j$ 时一定不满足第三个式子，把第三个式子化为 $c_i-i\le c_j-j$。最后以 $c_i$ 为第一关键字，$i$ 为第二关键字为顺序转移，最后用树状数组优化即可。复杂度 $O(n\log n)$。

## Code

```cpp
// Problem: P10395
#include <bits/stdc++.h>
#define db double
#define ll long long
#define pc putchar
#define gc getchar
#define sz(x) ((int)x.size())
#define F(i, a, b) for (int i = (a); i <= (b); ++i)
#define D(i, a, b) for (int i = (a); i >= (b); --i)
#define TM cout<<fabs(&Med-&Mbe)/1048576.0<<"MB "<<1.0*clock()/CLOCKS_PER_SEC*1000<<"ms\n"
bool Mbe;
using namespace std;
namespace IO {
#define typ ll
	inline typ rd() {
		typ x = 0; bool f = 1; char ch = gc();
		while (ch < '0' || ch > '9') { if (ch == '-') f = 0; ch = gc(); }
		while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = gc();
		return (f ? x : (-x));
	}
	inline void wr(typ x) {
		if (x < 0) pc('-'), x = -x;
		if (x > 9) wr(x / 10); pc(x % 10 + '0');
	}
}
using namespace IO;
// ----------------- Main Code -----------------
const int N = 2e6 + 5;
int n, m, a[N], c[N], id[N], k;
vector<int> G[N];
void upd(int p, int x) { ++p; for (int i = p; i <= m + 1; i += (i & -i)) c[i] = min(c[i], x); }
int qry(int p) { ++p; int res = 1e9; for (int i = p; i; i -= (i & -i)) res = min(res, c[i]); return res; }
int main() {
	n = rd(), m = rd();
	F(i, 1, n) {
		a[i] = rd();
		if (!id[a[i]]) id[a[i]] = ++k;
		else if (a[i] != a[i-1]) { wr(-1), pc('\n'); return 0; }
	}
	if (m < k) { wr(-1), pc('\n'); return 0; }
	F(i, 1, m) {
		int x = rd();
		G[id[x]].push_back(i);
	}
	memset(c, 0x3f, sizeof c);
	int ans = m;
	upd(0, 0);
	F(i, 1, k) {
		for (int v : G[i]) if (v >= i && m-v >= k-i) {
			int p = v - i; // 缩点后的编号
			int f_v = qry(p) + v - 1; // 树状数组中存的值是 f_i - i
			ans = min(ans, f_v + m - v);
			upd(p, f_v - v);
		}
	}
	wr(ans), pc('\n');
	return 0;
}
```

---


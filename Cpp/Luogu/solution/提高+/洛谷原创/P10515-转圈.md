# 转圈

## 题目描述

小 $\delta$ 喜欢转圈圈。

他有一个圈，被均匀分成了 $n$ 个格子，神奇的是，$n$ 是一个质数。第 $i$ 个格子上写着一个数 $i \times m$，他现在站在第一个格子上。

接下来他会看看脚下踩着的数是多少，然后向前走这么多格。他会一直反复这么做。

求最终被小 $\delta$ 踩到过的格子的数量。由于小 $\delta$ 有很多圈圈，所以他会问你很多次。

## 说明/提示

**【样例解释】**

以第一次询问为例，小 $\delta$ 依次经过的格子编号为 $1 \to 3 \to 4 \to 2 \to 1 \to \cdots$，因此被踩到过的格子个数为 $4$。

**【数据范围】**

- 对于 $20\%$ 的数据，$n \le 10^3$，$T \le 2 \times 10^3$。
- 对于另外 $40\%$ 的数据，$T \le 3 \times 10^3$。
- 对于另外 $40\%$ 的数据，无特殊性质。

对于所有数据，$1 \le m < n \le 10^7$，$1 \le T \le 4 \times 10^5$。保证 $n$ 是质数。


## 样例 #1

### 输入

```
6
5 2
11 10
17 12
23 8
31 12
9999901 114514```

### 输出

```
4
2
4
11
30
16260```

# 题解

## 作者：ZhongYuLin (赞：5)

以下令 $P=n$。

考虑将标号整体左移，重新标号为 $0,1,2\dots n-2,n-1$。不难发现，题目中的操作为一个线性变换，具体地，目前处于点 $i$，根据题目要求，他将移动到 $i+(i+1)m\bmod P$，即 $(m+1)i+m \bmod P$。

于是，记 $A=\begin{bmatrix}  1+m& m\\  0&1\end{bmatrix}$：

$$T(\textbf{x})=A\textbf{x} \bmod P$$

经过写暴力，我们发现我们即要求最小的 $k$，使得 $T^k(\textbf{x})=\textbf{x}$。也即：

$$A^k\equiv I \bmod P$$

进行特征分解：

$$(\begin{bmatrix}  1& -1\\  0&1\end{bmatrix}\begin{bmatrix}  m+1& 0\\  0&1\end{bmatrix}\begin{bmatrix}  1& 1\\  0&1\end{bmatrix})^k \equiv I \bmod P$$

$$\begin{bmatrix}  1& -1\\  0&1\end{bmatrix}\begin{bmatrix}  m+1& 0\\  0&1\end{bmatrix}^k\begin{bmatrix}  1& 1\\  0&1\end{bmatrix} \equiv I \bmod P$$

$$\begin{bmatrix}  1& -1\\  0&1\end{bmatrix}\begin{bmatrix}  (m+1)^k& 0\\  0&1\end{bmatrix}\begin{bmatrix}  1& 1\\  0&1\end{bmatrix} \equiv I \bmod P$$

$$\begin{bmatrix}  (1+m)^k& (m+1)^k-1\\  0&1\end{bmatrix}\equiv I \bmod P$$

于是，有 $(1+m)^k\equiv 1 \bmod P$。

根据费马小定理，$k=P-1$ 时式子成立。考虑去除其中的每一个质因子，然后判断是否仍然成立，成立则可以去除。我们便在 $O(\sqrt n\log n)$ 的时间复杂度内解决了单个问题。

然后你发现过不了样例，集中注意力，发现 $m=n-1$ 时答案为 $2$，这是显然的。

以下是湖南省标准分先生 @EnofTaiPeople 编写的程序：

![](https://cdn.luogu.com.cn/upload/image_hosting/qdm8c797.png
)


```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int N=1e7+3;
int n,P,tot,b[N],bt;
int p[N];
bitset<N>vis;
ll fp(ll a,ll b=P-2){ll ans=1;for(;b;b>>=1,a=a*a%P)if(b&1)ans=ans*a%P;return ans;}
void solve(){
    cin>>P>>n;int v=P-1,v2=v;++n;
    if(n==P){puts("2");return;}
    for(int j=1;p[j]*p[j]<=v2;++j){
        while(v%p[j]==0&&fp(n,v/p[j])==1)v/=p[j];
        while(v2%p[j]==0)v2/=p[j];
    }if(v2>1&&fp(n,v/v2)==1)v/=v2;
    printf("%d\n",v);
}
int main(){
    ios::sync_with_stdio(cin.tie(cout.tie(0)));
    for(int i=2;i<N;++i){
        if(!vis[i])p[++tot]=i;
        for(int j=1;j<=tot&&p[j]*i<N;++j){
            vis[i*p[j]]=1;
            if(i%p[j]==0)break;
        }
    }
    int T;for(cin>>T;T--;)solve();
    return 0;
}
```

---

## 作者：chenly8128 (赞：4)

分析一下看似复杂的移动过程。

从 $i$ 号节点移动一次，会到达 $i + i \times m \mod n$ 号节点（这里 $0$ 号节点等价于 $n$ 号节点，这不重要），整理一下，就是到达了 $i\times(m+1) \mod n$ 号节点。那么显然，如果移动 $k$ 次，就会到达 $i \times (m+1)^k \mod n$ 号节点。

题目要我们求开始循环前共走了几个格子。由于我们是从一号节点出发的，所以需要求 $(m+1)^k \equiv 1 \mod n$，$k$ 的最小正整数解。

这就是求 $m+1$ 对于 $n$ 的阶。

由于 $n$ 是质数，所以 $\varphi(n) = n-1$。于是我们可以通过用 $n-1$ 的质因数试除，然后快速幂判断是否可行的方法，找出 $m+1$ 对于 $n$ 的阶。
质因数可以通过欧拉筛的方法快速找出。

复杂度预处理 $O(n)$，单次查询为试除和快速幂的复杂度之积 $O(\log_2^2n)$。总复杂度 $O(n+T\log_2^2n)$。


```cpp

// Author: chenly8128
// Created: 2025-02-25 20:37:35

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN = 1e7;
int sf[MAXN+10],T,n,m;
vector <int> pr;
ll qpow (ll a,ll k,ll mod) {
	ll ans = 1;
	while (k) {
		if (k&1) ans = ans * a % mod;
		a = a * a % mod;
		k >>= 1;
	}
	return ans;
}
int main (void) {
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	sf[1] = 1;
	for (int i = 2;i <= MAXN;i++) {
		if (!sf[i]) {
			sf[i] = i;
			pr.push_back(i);
		}
		for (int j : pr) {
			if (i * j > MAXN) break;
			sf[i*j] = j;
			if (i % j == 0) break;
		}
	}
	cin >> T;
	while (T--) {
		cin >> n >> m;
		if (n == m+1) {
			cout << 2 << '\n';
			continue;
		}
		int x = n-1,ans = n-1;
		while (x > 1) {
			if (qpow(m+1,ans/sf[x],n) == 1) ans /= sf[x];
			x /= sf[x];
		}
		cout << ans << '\n';
	}
	return 0;
}
```

---

## 作者：251Sec (赞：1)

记第 $n$ 个位置的下标为 $0$，注意到走 $i$ 步到达的位置为 $(m+1)^i$，则特判 $m=n-1$ 后，令 $s=m+1$，问题变为求最小的 $k$ 使得 $s^k \equiv 1 \pmod n$。这是经典的求阶问题。

我们简述做法：对 $(n-1)$ 质因数分解，令 $t=n-1$，依次对每个 $n-1$ 的质因数 $p$ 检验 $s^{\frac{t}{p}}$ 是否模 $n$ 余 $1$，如果是则令 $t \gets \frac{t}{p}$，最终 $t$ 即为答案。其中质因数分解的部分可以用线性筛预处理出每个 $1 \sim 10^7$ 的数的最小质因子。最终复杂度 $O(n+T \log^2n)$。

---

## 作者：NTT__int128 (赞：0)

假设现在停留在格子 $i$，那么下一次应该停留在格子 $i+mi\equiv i(m+1)\pmod n$。这里，用格子 $0$ 代替格子 $n$。

那么走了 $k$ 步后，小 $\delta$ 会停留在格子 $(m+1)^k\bmod n$。

发现此时就是求模 $n$ 意义下的 $\delta_{m+1}$。

对于 $\varphi(n)=n-1$ 的每个因数 $p$，试除（判断当前求出的阶 $t$ 除以 $p$ 之后 $x^{\frac tp}\bmod n$ 是否为 $1$，为 $1$ 则将 $t$ 除去 $p$）。

时间复杂度：$\Theta(T\sqrt{n-1}\log n)$

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
int qp(ll a,int b,int p){ll s=1;while(b){if(b&1)s=s*a%p;a=a*a%p,b>>=1;}return s;}
int t,n,d,p[105],cnt,ph;
void get(int x){
	cnt=0;
	for(int i=2;i*i<=x;i++){
		if(x%i)continue;
		while(x%i==0)x/=i;
		p[++cnt]=i;
	}
	if(x>1)p[++cnt]=x;
}
int get_delta(int x){
	for(int i=1;i<=cnt;i++)while(ph%p[i]==0&&qp(x,ph/p[i],n)==1)ph/=p[i];
	return ph;
}
void work(){
	cin>>n>>d;
	d++;
	if(d==n){
		cout<<"2\n";
		return;
	}
	ph=n-1;
	get(ph);
	cout<<get_delta(d)<<'\n';
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>t;
	while(t--)work();
	return 0;
}
```

---

## 作者：fzitb7912 (赞：0)

题解摘自[做题记录](https://www.luogu.com.cn/article/7iw3x35p)。

## 分析

记我们当前在 $x$，那么下一步就会走到 $x+xm=x(m+1)$。不难发现，每一步都是走到了当前的 $m+1$ 倍的格子。那么第 $i$ 步就会走到 $(m+1)^i$。所以我们只需要找到一个最小的 $x(x>0)$，使得 $(m+1)^x \equiv 1 \pmod n$。然后这个求一个 $(m+1)$ 的阶就行了。

当 $m+1=n\lor n=m$ 的时候特判一下就行了。

## 代码

```cpp
il void init(){
	f[1]=1;
	for(re int i=2;i<N;++i){
		if(!vis[i]) pri[++cnt]=i,f[i]=i;
		for(re int j=1;i*pri[j]<N&&j<=cnt;++j){
			vis[i*pri[j]]=1;
			f[i*pri[j]]=pri[j];
			if(!(i%pri[j])) break;
		}
	}
	return ;
}

il void solve(){
	n=rd,m=rd;
	if(n==m) return printf("1\n"),void(0);
	if(n-1==m) return printf("2\n"),void(0);
	int x=n-1,ans=x;++m;
	while(x>1){
		int y=qmi(m,ans/f[x],n);
		if(y==1) ans/=f[x];
		x/=f[x];
	}
	printf("%lld\n",ans);
    return ;
}
```

---


# 数据结构

## 题目背景

小 M 很喜欢数据结构。但是很遗憾，他没有进入省队。

人生有梦，各自精彩。

## 题目描述

给定两个长度为 $n$ 的序列 $a_i$ 和 $b_i$。有以下三种操作：

1. 给定区间 $[l,r]$ 以及参数 $k,t$，把区间内满足 $a_i\times b_i\leq k$ 的位置的 $a_i$ 和 $b_i$ 分别加上 $t$。
2. 给定 $i$ 和 $x,y$，将 $a_i$ 改为 $x$，$b_i$ 改为 $y$。
3. 查询区间内每个位置 $a_i+b_i$ 的和。

## 说明/提示

**【样例解释】**

第一次修改后，序列 $a_i$ 为：$\left\{23,4,4,4,8\right\}$；序列 $b_i$ 为 $\left\{54,29,8,2,3\right\}$。

第二次修改后，序列 $a_i$ 为：$\left\{23,7,4,4,8\right\}$；序列 $b_i$ 为 $\left\{54,9,8,2,3\right\}$。

**【数据范围】**

- 对于 $5\%$ 的数据，$n,m\le 5$；
- 对于 $10\%$ 的数据，$n,m\leq 100$；
- 对于 $25\%$ 的数据，$n,m\leq 5000$；
- 对于另外 $5\%$ 的数据，没有前两种操作；
- 对于另外 $10\%$ 的数据，没有第一种操作；
- 对于另外 $20\%$ 的数据，没有第二种操作；

对于所有数据，$1\leq n,m\leq 10^5$，$0\leq a_i,b_i,k,t,x,y\leq10^5$。

## 样例 #1

### 输入

```
5 5
23 4 3 3 7
54 29 7 1 2
1 1 5 114 1
2 2 7 9
3 1 5
3 1 2
3 3 4```

### 输出

```
122
93
18```

# 题解

## 作者：喵仔牛奶 (赞：8)

# Solution

操作二三用线段树容易维护。对于操作一，$t=0$ 的操作是无意义的，直接跳过；否则有 $t>0$，容易发现一个数至多连续被进行 $\sqrt{k}$ 次操作一。

初始有 $n$ 个数，修改最多带来新的 $q$ 个数，所以所有操作一总的影响的数不超过 $(n+q)\sqrt{k}$ 个。因为 $k$ 很小，直接暴力操作即可。

具体地，在线段树上每个结点维护子树内 $a_i\times b_i$ 的最小值，操作一进行时若 $x$ 大于该最小值则直接返回，否则递归修改。

时间复杂度 $\mathcal{O}((n+q)\sqrt{k}\log n)$。

# Code

```cpp
#include <bits/stdc++.h>
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
#define pb emplace_back
#define mems(x, v) memset((x), (v), sizeof(x))
using namespace std;
namespace Milkcat {
	typedef long long LL;
	typedef pair<LL, LL> pii;
	const int N = 1e6 + 5;
	namespace SGT {
		struct node {
			LL a, b, s, mn;
			void set(LL x, LL y) { a = x, b = y, s = x + y, mn = x * y; }
		} s[N << 2];
		node merge(const node& x, const node& y) {  return {0, 0, x.s + y.s, min(x.mn, y.mn)}; }
		void pushup(int p) { s[p] = merge(s[p << 1], s[p << 1 | 1]); }
		void upd(int p, int l, int r, int t, int x, int y) { // 操作二
			if (l == r) { s[p].set(x, y); return; }
			int mid = (l + r) >> 1;
			if (t <= mid) upd(p << 1, l, mid, t, x, y);
			if (t > mid) upd(p << 1 | 1, mid + 1, r, t, x, y);
			pushup(p);
		}
		void add(int p, int l, int r, int nl, int nr, int x, int y) { // 操作一
			if (s[p].mn > x || !y) return;
			if (l == r) { s[p].set(s[p].a + y, s[p].b + y); return; }
			int mid = (l + r) >> 1;
			if (nl <= mid) add(p << 1, l, mid, nl, nr, x, y);
			if (nr > mid) add(p << 1 | 1, mid + 1, r, nl, nr, x, y);
			pushup(p);
		}
		node ask(int p, int l, int r, int nl, int nr) {  // 操作三
			if (nl <= l && r <= nr) return s[p];
			int mid = (l + r) >> 1;
			if (nl <= mid && nr > mid) return merge(ask(p << 1, l, mid, nl, nr), ask(p << 1 | 1, mid + 1, r, nl, nr));
			if (nl <= mid) return ask(p << 1, l, mid, nl, nr);
			if (nr > mid) return ask(p << 1 | 1, mid + 1, r, nl, nr);
	    }
	}
	int n, q, op, l, r, x, y, a[N], b[N];
	int main() {
		cin >> n >> q;
		REP(i, 1, n) cin >> a[i];
		REP(i, 1, n) cin >> b[i], SGT::upd(1, 1, n, i, a[i], b[i]);
		REP(test, 1, q) {
			cin >> op;
			if (op == 1) cin >> l >> r >> x >> y, SGT::add(1, 1, n, l, r, x, y);
			if (op == 2) cin >> l >> x >> y, SGT::upd(1, 1, n, l, x, y);
			if (op == 3) cin >> l >> r, cout << SGT::ask(1, 1, n, l, r).s << '\n';
		}
		return 0;
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	int T = 1;
	while (T --) Milkcat::main();
	return 0;
}
```

---

## 作者：听取MLE声一片 (赞：7)

### 数据结构题解

以下假定 $n,m,V$ 同阶。

势能线段树。注意到若无二操作，**有效**一操作至多会进行 $O(\sqrt n)$ 次，也就是可以对每个位置暴力修改。对于线段树上每个区间记录区间最小值，若当前区间最小值不大于 $k$ 则对其子树递归修改。直到找到每个单点，暴力修改即可。

二操作单点修改总共只会更新至多 $O(n)$ 个数，给一操作的总修改数增加 $O(n\sqrt n)$ 次，时间复杂度是正确的。

区间和用单点修改线段树的写法即可。

注意要特判 $t=0$ 的情况。

一操作至多进行 $O(n\sqrt n)$ 次单点修改，总时间复杂度为 $O(n\sqrt n\log n)$，实际达不到上界。


```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<set>
#include<bitset>
#include<ctime>
#include<random>
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N=1e5+10;
int n,m,a[N],b[N];
struct Tree{
	#define ls (p<<1)
	#define rs (p<<1|1)
	#define mid ((l+r)>>1)
	int sum[N<<2],minn[N<<2];
	inline void pushup(int p){
		sum[p]=sum[ls]+sum[rs];
		minn[p]=min(minn[ls],minn[rs]);
	}
	void build(int p,int l,int r){
		if(l==r){
			sum[p]=a[l]+b[l];
			minn[p]=a[l]*b[l];
			return;
		}
		build(ls,l,mid);
		build(rs,mid+1,r);
		pushup(p);
	}
	void update(int L,int R,int p,int l,int r,int k,int t){
		if(minn[p]>k)return;
		if(l==r){
			a[l]+=t;
			b[l]+=t;
			sum[p]=a[l]+b[l];
			minn[p]=a[l]*b[l];
			return;
		}
		if(L<=mid)update(L,R,ls,l,mid,k,t);
		if(R>mid) update(L,R,rs,mid+1,r,k,t);
		pushup(p);
	}
	void modify(int pos,int p,int l,int r,int x,int y){
		if(l==r){
			a[pos]=x;
			b[pos]=y;
			sum[p]=a[l]+b[l];
			minn[p]=a[l]*b[l];
			return;
		}
		if(pos<=mid)modify(pos,ls,l,mid,x,y);
		if(pos>mid) modify(pos,rs,mid+1,r,x,y);
		pushup(p);
	}
	int query(int L,int R,int p,int l,int r){
		if(L<=l&&r<=R)
			return sum[p];
		int res=0;
		if(L<=mid)res+=query(L,R,ls,l,mid);
		if(R>mid) res+=query(L,R,rs,mid+1,r);
		return res;
	}
	#undef ls
	#undef rs
	#undef mid
}T;
signed main()
{
	//freopen("020.in","r",stdin);
	//freopen("020.out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=1;i<=n;i++)
		b[i]=read();
	T.build(1,1,n);
	while(m--){
		int opt=read();
		if(opt==1){
			int l=read(),r=read(),k=read(),t=read();
			if(!t)continue;
			T.update(l,r,1,1,n,k,t);
		}
		if(opt==2){
			int pos=read(),x=read(),y=read();
			T.modify(pos,1,1,n,x,y);
		}
		if(opt==3){
			int l=read(),r=read();
			cout<<T.query(l,r,1,1,n)<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：wang6w6 (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P10516)

# 思路

对两个序列进行区间修改，单点修改和区间查询，暴力显然超时，考虑线段树维护。

不妨设 $val$ 为区间和，$mi$ 为区间乘的**最小值**。

之所以要用区间乘的最小值，是因为如果要更新最大值，可能会出现最大值大于 $k$，区间里存在小于等于 $k$ 的情况，但是如果最小值都大于 $k$ 了，那区间里肯定不存在小于等于 $k$ 的情况。

在操作中可以省去存储 $a$ 和 $b$，直接更新 $mi$ 和 $val$。

对于操作一，首先要**特判** $t = 0$ 这种情况，然后我们可以剪枝找到 $mi \le k$ 的叶节点，再进行修改，这里要用到公式推导，代码中已给出。

对于操作二，直接遍历到叶节点进行单点修改即可。

对于操作三，遍历线段树查询区间和即可。

# 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+5;
ll n,m,a[N],b[N],op,l,r,k,t,j,x,y;
struct stu{
	ll val,mi,l,r;//不直接存a和b，直接推导值的变化 
}f[N<<2];//4倍空间 
ll rd(){
	ll f=1,x=0;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while('0'<=c&&c<='9'){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return f*x;
}//快读 
void push_up(ll p){
	f[p].val=f[p<<1].val+f[p<<1|1].val;
	f[p].mi=min(f[p<<1].mi,f[p<<1|1].mi);
	return ;
}
void build(ll p,ll l,ll r){
	f[p].l=l;f[p].r=r;
	if(l==r){
		f[p].val=a[l]+b[l];
		f[p].mi=a[l]*b[l];
		return ;
	}
	ll mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	push_up(p);
	return ;
}
void add(ll p,ll l,ll r,ll k,ll t){
	if(l>f[p].r||r<f[p].l) return ;//不在区间内直接跳过 
	if(f[p].l==f[p].r){
		f[p].mi+=f[p].val*t+t*t;//数学公式(a+t)*(b+t)=a*b+t*(a+b)+t*t
		f[p].val+=2*t;//数学公式(a+t)+(b+t)=a+b+2*t
		return ;
	}
	ll mid=(f[p].l+f[p].r)>>1;
	//剪枝，只看mi小于等于k的子树 
	if(l<=mid&&f[p<<1].mi<=k) add(p<<1,l,r,k,t);
	if(r>mid&&f[p<<1|1].mi<=k) add(p<<1|1,l,r,k,t);
	push_up(p);
	return ;
}
void change(ll p,ll x,ll a,ll b){
	if(f[p].l==x&&x==f[p].r){//单点修改 
		f[p].mi=a*b;
		f[p].val=a+b;
		return ;
	}
	ll mid=(f[p].l+f[p].r)>>1;
	if(x<=mid) change(p<<1,x,a,b);
	else change(p<<1|1,x,a,b);
	push_up(p);
	return ;
}
ll fin(ll p,ll l,ll r){
	if(l<=f[p].l&&f[p].r<=r){
		return f[p].val;
	}
	ll mid=(f[p].l+f[p].r)>>1;
	ll ans=0;
	if(l<=mid) ans+=fin(p<<1,l,r);
	if(r>mid) ans+=fin(p<<1|1,l,r);
	return ans;
}
int main(){
	n=rd(),m=rd();
	for(ll i=1;i<=n;i++) a[i]=rd();
	for(ll i=1;i<=n;i++) b[i]=rd();
	build(1,1,n);
	while(m--){
		op=rd();
		if(op==1){
			l=rd(),r=rd(),k=rd(),t=rd();
			if(t==0) continue;//t=0时无意义，可以跳过
			add(1,l,r,k,t);
		}
		if(op==2){
			j=rd(),x=rd(),y=rd();
			change(1,j,x,y);
		}
		if(op==3){
			l=rd(),r=rd();
			printf("%lld\n",fin(1,l,r));//开long long记得输出用%lld 
		}
	}
	return 0;
}
```

---

## 作者：2c_s (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P10516)

## 思路

乍一看好像线段树会超时，达到 $\mathcal{O}(n^2)$ 的时间复杂度，可是我们想一想优化，就会发现这是道很明显的线段树题。

我们用线段树维护的变量有：

`l`：线段左端点；

`r`：线段右端点；

`sum`：线段的 $a$ 数组与 $b$ 数组之和；

`mi`：线段的 $a$ 数组与 $b$ 数组之积的最小值。

由于每次查询都要满足 $a_i\times b_i\le k$，所以无论如何，每个线段在**不修改**的情况下，最多能被**增加** $\sqrt{k}$ 次。因此我们可以开一个变量记录 $a_i\times b_i$ 的最小值，每次**增加**的时候如果发现当前遍历到的线段的最小值还 $>k$，说明这条线段无论如何都不可能被**增加**，直接退出即可。每次**增加**平均时间复杂度 $\mathcal{O}(\sqrt{k}\log n)$。同时如果增加的值为 $0$ 就相当于**不增加**，不进行操作（如果不这样做，最后一个点会 `TLE`）。

由于**修改**是单点的，所以每次修改的时候暴力枚举即可。时间复杂度 $\mathcal{O}(\log n)$。

查询的时候和普通线段树的查询是一样的。时间复杂度 $\mathcal{O}(\log n)$。

综上所述，这题根本不想想象中的那样难。总时间复杂度 $\mathcal{O}((n+q)\sqrt k\log n)$，但远远达不到。

- 记得开 `long long`。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll read(){//快读。
	ll k=0,flag=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')flag=-1;c=getchar();}
	while(c>='0'&&c<='9'){k=(k<<1)+(k<<3)+(c^48);c=getchar();}
	return k*flag;
}
const int N=1e5+10;
int n,m;
ll a[N],b[N];
struct node{
	int l,r;
	ll sum,mi;
}tr[N<<2];//线段树开 4 倍空间。
void pushup(int i){
	tr[i].sum=tr[i<<1].sum+tr[i<<1|1].sum;
	tr[i].mi=min(tr[i<<1].mi,tr[i<<1|1].mi);
	return ;
}
void build(int i,int l,int r){
	tr[i].l=l;
	tr[i].r=r;
	if(l==r){
		tr[i].sum=a[l]+b[l];
		tr[i].mi=a[l]*b[l];
		return ;
	}
	int mid=l+r>>1;
	build(i<<1,l,mid);
	build(i<<1|1,mid+1,r);
	pushup(i);
	return ;
}
void add(int i,int l,int r,ll k,ll t){
	if(tr[i].mi>k)return ;//大于 k 就跳过。
	if(tr[i].l==tr[i].r){
		a[tr[i].l]+=t;
		b[tr[i].l]+=t;
		tr[i].sum+=2*t;
		tr[i].mi=a[tr[i].l]*b[tr[i].l];
		return ;
	}
	int mid=tr[i].l+tr[i].r>>1;
	if(l<=mid)add(i<<1,l,r,k,t);
	if(mid<r)add(i<<1|1,l,r,k,t);
	pushup(i);
	return ;
}
void change(int i,int j,ll x,ll y){
	if(tr[i].l==tr[i].r){
		a[j]=x;
		b[j]=y;
		tr[i].sum=a[j]+b[j];
		tr[i].mi=a[j]*b[j];
		return ;
	}
	int mid=tr[i].l+tr[i].r>>1;
	if(j<=mid)change(i<<1,j,x,y);
	else change(i<<1|1,j,x,y);
	pushup(i);
	return ;
}
ll query(int i,int l,int r){
	if(l<=tr[i].l&&tr[i].r<=r)return tr[i].sum;
	int mid=tr[i].l+tr[i].r>>1;
	ll res=0;
	if(l<=mid)res+=query(i<<1,l,r);
	if(mid<r)res+=query(i<<1|1,l,r);
	return res;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;++i)a[i]=read();
	for(int i=1;i<=n;++i)b[i]=read();
	build(1,1,n);
	while(m--){
		int op=read();
		if(op==1){
			int l=read(),r=read();
			ll k=read(),t=read();
			if(!t)continue;//对 t=0 进行优化。
			add(1,l,r,k,t);
		}
		else if(op==2){
			int i=read();
			ll x=read(),y=read();
			change(1,i,x,y);
		}
		else{
			int l=read(),r=read();
			printf("%lld\n",query(1,l,r));
		}
	}
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/159773560)

---

## 作者：CCCCOrz (赞：3)

给一个不带 $\log$ 的做法。

## 分析

用 $V$ 表示值域大小

首先易知 $1$ 操作造成的单点修改总次数是 $O((n+m)\sqrt V)$ 的，本题的其他题解也有说。

换句话说我们可以用 $O((n+m)\sqrt V)$ 次 $2$ 操作来完成所有 $1$ 操作。

问题在于怎样找到需要进行的操作，以及如何进行操作。

## 实现

我们审视一下 $1$ 操作：

修改所有下标**在 $l$ 到 $r$ 之间** 以及 $a,b$ 乘积**在 $0$ 到 $k$ 之间**的点

也就是说这是一个二维的限制。

直接分块的话光维护第一维限制就需要在 $O(\sqrt n)$ 个整块里分别操作，每个块就只剩 $O(1)$ 的操作空间了。

因此考虑在分块的基础上再次分块。

首先，将整个序列分为 $O(\sqrt n)$ 个小块，每个块长 $O(\sqrt n)$ 。

然后，相邻的 $O(n^{\frac 1 4})$ 个小块拼成一个大块，每个大块长 $O(n^{\frac 3 4})$。

这样，我们就将 $1$ 操作涉及的区间分成了 $O(n^{\frac 1 4})$ 个大块、 $O(n^{\frac 1 4})$ 个小块和 $O(\sqrt n)$ 个单点。

![-](https://cdn.luogu.com.cn/upload/image_hosting/qi2qlsbk.png)

这样，维护第一维就只需要处理好 $O(n^{\frac 1 4})$ 个整块（毕竟大块和小块的维护方式是一样的）。

维护整块内值域用类似的方法，对值域分三次块，分别是 $O(V^{\frac 1 4})$ 个长 $O(V^{\frac 3 4})$ 的块，$O(\sqrt V)$ 个长 $O(\sqrt V)$ 的块，$O(V^{\frac 3 4})$ 个长 $O(V^{\frac 1 4})$ 的块，每个块和每个单点都开一个链表存所有乘积在这个块内的下标。

这样我们查找整块内所有乘积在 $0$ 到 $k$ 之间的点就只需要 $O(V^{\frac 1 4})$ 的时间了。

最终时间复杂度 $O((n+m)\sqrt V + m (nV)^{\frac 1 4} )$

然而空间复杂度是 $O(m (nV)^{\frac 1 4} )$ ，还有 $8$ 倍常数，直接炸了。

然而可以离线下来，每次只维护序列上一个大块，空间复杂度 $O(m V^{\frac 1 4} )$ 。

代码：
```cpp
#include <cstdio>
inline int rd(){
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')x=x*10+(c^48),c=getchar();
	return x;
}
const int mx=100000,blen=5000,slen=500,klen=18;
const int klen_2=klen*klen,klen_3=klen*klen*klen;
int n,m,a[100010],b[100010],l[100010],r[100010],k[100010],t[100010];
struct node{
	int pre,nxt;
	inline void init(const int at){pre=nxt=at;}
}dt[5600000];
int tot,que[100010],sz;
struct line{
	node *l;
	inline void init(const int len){
		l=dt+tot,tot+=len;
		for(int i=1;i<=len;++i)l[i].init(i);
	}
	inline void link(const int u,const int v){
		l[u].nxt=v,l[v].pre=u;
	}
	inline void add(const int u,const int to){
		link(u,l[to+n+1].nxt),link(to+n+1,u);
	}
	inline void dlt(const int p){
		l[l[p].nxt].pre=l[p].pre;
		l[l[p].pre].nxt=l[p].nxt;
		l[p].pre=l[p].nxt=p;
	}
	inline void pick(int plc)const{
		plc+=n+1;
		for(int u=l[plc].nxt;u!=plc;u=l[u].nxt)
			que[++sz]=u;
	}
};
typedef long long ll;
struct block{
	line s[4];
	ll sum;
	inline void init(){
		sum=0;
		s[0].init((mx+1)<<1);
		s[1].init(mx+1+klen_3);
		s[2].init(mx+1+klen_2);
		s[3].init(mx+1+klen);
	}
	inline void add(const int p,const ll to){
		sum+=a[p]+b[p];
		if(to>mx)return;
		s[0].add(p,to);
		if(to){
			s[1].add(p,(to+klen-1)/klen);
			s[2].add(p,(to+klen_2-1)/klen_2);
			s[3].add(p,(to+klen_3-1)/klen_3);
		}
	}
	inline void dlt(const int p){
		sum-=a[p]+b[p];
		s[0].dlt(p),s[1].dlt(p),s[2].dlt(p),s[3].dlt(p);
	}
	inline void sele(int k)const{
		s[0].pick(0);
		int nw=klen_3;
		for(int i=1;nw<=k;nw+=klen_3,++i)s[3].pick(i);
		nw+=klen_2-klen_3;
		for(int i=nw/klen_2;nw<=k;nw+=klen_2,++i)s[2].pick(i);
		nw+=klen-klen_2;
		for(int i=nw/klen;nw<=k;nw+=klen,++i)s[1].pick(i);
		for(nw+=1-klen;nw<=k;++nw)s[0].pick(nw);
	}
}blk[11];
ll ans[100010];
inline void add(const int p){
	ll v=(ll)a[p]*b[p];
	blk[0].add(p,v);
	blk[((p-1)%blen)/slen+1].add(p,v);
}
inline void dlt(const int p){
	blk[0].dlt(p);
	blk[((p-1)%blen)/slen+1].dlt(p);
}
inline void chg(const int p,const int x,const int y){
	dlt(p),a[p]=x,b[p]=y,add(p);
}
inline void adv(const int p,const int v){chg(p,a[p]+v,b[p]+v);}
inline void sol(const int at){
	const int vt=t[at];
	if(!vt)return;
	blk[0].sele(k[at]);
	for(int i=1;i<=sz;++i)
		adv(que[i],vt);
	sz=0;
}
inline bool chkq(const int p){return r[p] && k[p]==0 && t[p]==0;}
inline void pros(const int p,const int at,const int tp){
	if(tp){ans[at]+=a[p]+b[p];return;}
	ll v=(ll)a[p]*b[p];
	if(v<=k[at])adv(p,t[at]);
}
inline void part(const int l,const int r,const int at){
	if(t[at]==0 && k[at])return;
	int tl=(l-1)%blen/slen+1,tr=(r-1)%blen/slen+1,bg=l-l%blen,tp=chkq(at);
	if(tl==tr){
		for(int i=l;i<=r;++i)pros(i,at,tp);
		return;
	}
	int el=bg+tl*slen,br=bg+(tr-1)*slen+1;
	for(int i=l;i<=el;++i)pros(i,at,tp);
	for(int i=br;i<=r;++i)pros(i,at,tp);
	for(int i=tl+1;i<tr;++i){
		if(tp)ans[at]+=blk[i].sum;
		else blk[i].sele(k[at]);
	}
	if(tp)return;
	for(int i=1;i<=sz;++i)
		adv(que[i],t[at]);
	sz=0;
}
inline void file(){
	freopen("a.in","r",stdin);
	freopen("a.out","w",stdout);
}
int main(){
//  file();
	n=rd(),m=rd();
	for(int i=1;i<=n;++i)a[i]=rd();
	for(int i=1;i<=n;++i)b[i]=rd();
	for(int i=1,tp;i<=m;++i){
		tp=rd();
		if(tp==2)l[i]=rd(),k[i]=rd(),t[i]=rd();
		else if(tp==3)l[i]=rd(),r[i]=rd();
		else{
			l[i]=rd(),r[i]=rd(),k[i]=rd(),t[i]=rd();
			if(chkq(i))k[i]=1;
		}
	}
	for(int bg=1,ed;bg<=n;bg+=blen){
		ed=(bg+blen>n?n:bg+blen-1);
		tot=0;
		blk[0].init();
		for(int kb=bg,ke,at=1;kb<=ed;kb+=slen,++at){
			ke=(kb+slen>ed?ed:kb+slen-1);
			blk[at].init();
			for(int i=kb;i<=ke;++i)add(i);
		}
		for(int i=1;i<=m;++i){
			if(!r[i]){
				const int p=l[i];
				if(p<bg || p>ed)continue;
				chg(p,k[i],t[i]);
			}
			else{
				if(l[i]>ed || r[i]<bg)continue;
				if(l[i]<=bg && r[i]>=ed){
					chkq(i)?ans[i]+=blk[0].sum:(sol(i),0);
					continue;
				}
				if(l[i]<=bg){
					part(bg,r[i],i);
					continue;
				}
				if(r[i]>=ed){
					part(l[i],ed,i);
					continue;
				}
				part(l[i],r[i],i);
			}
		}
	}
	for(int i=1;i<=m;++i)
		if(chkq(i))printf("%lld\n",ans[i]);
	return 0;
}
```

然而时间也有 $8$ 倍常数，而且基本一定是跑满的，所以甚至跑不过线段树做法（

---

## 作者：jyb1 (赞：2)

# 思路

题目的意思很明确，我们可以通过用线段树进行三种不同的操作来解题。

对于操作一，我们要先判断 $t$ 是否为 0，若 $t = 0$，则此操作无需进行，若 $t \ne 0$，则判断区间乘积最小值是否满足 $mi \le k$，若区间乘积最小值不满足，则此区间不符合要求，否则递归修改子区间。

对于操作二，直接单点赋值修改即可。

对于操作三，最普通的线段树查询区间和。

代码如下：

```cpp
#include<iostream>
#define int long long
using namespace std;
int read(){
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-'0';
		c=getchar();
	}
	return x;
}
void write(int x){
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
//快读快写 
int n,m;
int a[100005],b[100005];
struct node{
	int sum,mi;//sum存储和，mi存储乘积最小值 
};
node tree[400005];
void pushup(int p){
	tree[p].sum=tree[p<<1].sum+tree[p<<1|1].sum;
	tree[p].mi=min(tree[p<<1].mi,tree[p<<1|1].mi);
} 
void build(int l,int r,int p){
	if(l==r){
		tree[p].sum=a[l]+b[l];
		tree[p].mi=a[l]*b[l];
		return ;
	}
	int mid=(l+r)>>1;
	build(l,mid,p<<1);
	build(mid+1,r,p<<1|1);
	pushup(p);
	return ;
}
void change1(int l,int r,int x,int y,int p,int k,int t){
	if(l==r){
		tree[p].mi+=tree[p].sum*t+t*t;
		tree[p].sum+=2*t;
		return ;
	}
	int mid=(l+r)>>1;
	//当最小值 mi<=k 时才对此区间进行修改 
	if(x<=mid&&tree[p<<1].mi<=k)change1(l,mid,x,y,p<<1,k,t);
	if(y>mid&&tree[p<<1|1].mi<=k)change1(mid+1,r,x,y,p<<1|1,k,t);
	pushup(p);
	return ;
}
void change2(int l,int r,int x,int y,int p,int wx,int wy){
	//单点赋值修改并向上更新即可 
	if(x<=l&&y>=r){
		tree[p].mi=wx*wy;
		tree[p].sum=wx+wy;
		return ;
	}
	int mid=(l+r)>>1;
	if(x<=mid)change2(l,mid,x,y,p<<1,wx,wy);
	if(y>mid)change2(mid+1,r,x,y,p<<1|1,wx,wy);
	pushup(p);
	return ;
}
int query(int l,int r,int x,int y,int p){
	if(x<=l&&y>=r)return tree[p].sum;
	int mid=(l+r)>>1;
	int ans=0;
	if(x<=mid)ans+=query(l,mid,x,y,p<<1);
	if(y>mid)ans+=query(mid+1,r,x,y,p<<1|1);
	return ans;
}
signed main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=n;i++)b[i]=read();
	build(1,n,1);
	for(int i=1;i<=m;i++)
	{
		int op=read();
		if(op==1){
			int l=read(),r=read(),k=read(),t=read();
			if(t==0)continue;//t=0时无需修改 (不写这个判断可能会超时)
			change1(1,n,l,r,1,k,t);
		}
		if(op==2){
			int j=read(),x=read(),y=read();
			change2(1,n,j,j,1,x,y);
		}
		if(op==3){
			int l=read(),r=read();
			write(query(1,n,l,r,1));
			putchar('\n');
		}
	}
}
```

如果有问题可以指出

---

## 作者：All_Wrong_Answer (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10516)

## 思路：

第一眼看起来没有那么显然的线段树。

对于操作二和操作三，都是很经典的线段树操作，不再赘述。

对于操作一，注意到 $k \le 10^5$，构造操作次数极限，即 $a_i=b_i=0 ,k=10^5,t=1$ 最多也只能进行 $\lceil \sqrt {10^5} \rceil = 317$ 次，而题目给的初值和操作的数量均大于等于 $0$，所以现实中远达不到 $317$ 次的上界，所以对于操作一可以考虑暴力修改。

但是枚举每一个 $i$ 显然是不可取的，注意到操作二和操作三都是线段树维护，那就可以在维护线段树时多维护一个值：区间 $a_i \times b_i$ 最小值，记为 $mina$，在操作一时，若当前节点所覆盖区间的 $mina > k$ 则它所覆盖的区间中不会有满足 $a_i \times b_i \le k$ 的点，直接 ```return``` 掉即可。

时间复杂度的上界为为 $O(n \sqrt n \log n)$，且现实中远达不到上界，可以通过此题。

## 完整代码：

记得开 ```long long```。


```cpp
#include <bits/stdc++.h>
#define le q<<1
#define ri q<<1|1
#define zqj tre[q].l
#define yqj tre[q].r
using namespace std;
inline long long read()
{
	long long x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
long long n,m;
long long a[100005],b[100005];
struct xds{
	long long l,r;
	long long sum;
	long long mina;
	void oin(long long ll,long long rr){
		l=ll;
		r=rr;
		sum=a[ll]+b[ll];
		mina=a[ll]*b[ll];
	}
}tre[500005];

void pushup(long long q){
	tre[q].sum=tre[le].sum+tre[ri].sum;
	tre[q].mina=min(tre[le].mina,tre[ri].mina);
}

void build(long long q,long long l,long long r){
	tre[q].oin(l,r);
	if(l==r) return ;
	long long mid=l+r>>1;
	build(le,l,mid);
	build(ri,mid+1,r);
	pushup(q);
}

void add(long long q,long long ml,long long mr,long long k,long long t){
	if(yqj<ml||zqj>mr) return ;
	if(tre[q].mina>k) return ;
	if(tre[q].mina<=k&&zqj==yqj){
		a[zqj]+=t;
		b[zqj]+=t;
		tre[q].sum=a[zqj]+b[zqj];
		tre[q].mina=a[zqj]*b[zqj];
		return ;
	}
	add(le,ml,mr,k,t);
	add(ri,ml,mr,k,t);
	pushup(q);
}

void change(long long q,long long mb,long long x,long long y){
	if(zqj==mb&&yqj==mb){
		a[zqj]=x;
		b[zqj]=y;
		tre[q].sum=a[zqj]+b[zqj];
		tre[q].mina=a[zqj]*b[zqj];
		return ;
	}
	long long mid=zqj+yqj>>1;
	if(mb<=mid) change(le,mb,x,y);
	if(mb>mid) change(ri,mb,x,y);
	pushup(q);
}

long long query(long long q,long long ml,long long mr){
	if(zqj>=ml&&yqj<=mr) return tre[q].sum;
	long long mid=zqj+yqj>>1;
	long long da=0;
	if(ml<=mid) da+=query(le,ml,mr);
	if(mr>mid) da+=query(ri,ml,mr); 
	return da;
}

int main(){
	n=read();
	m=read();
	for(long long i=1;i<=n;i++) a[i]=read();
	for(long long i=1;i<=n;i++) b[i]=read();
	build(1,1,n);
	for(long long i=1;i<=m;i++){
		long long op=read();
		if(op==1){
			long long l=read(),r=read(),k=read(),t=read();
			if(t!=0) add(1,l,r,k,t);
		}
		if(op==2){
			long long ii=read(),x=read(),y=read();
			change(1,ii,x,y);
		}
		if(op==3){
			long long l=read(),r=read();
			cout<<query(1,l,r)<<endl;
		}
	}
	return 0;
}
```

---

## 作者：dyc2022 (赞：1)

小清新势能线段树。

## 1. 什么是势能线段树？

本质上是一种区间暴力修改技术。

考虑普通的区修线段树，我们使用 lazytag 来记录区间修改信息，在访问到当前节点之后再将当前节点的 tag 下传。

然而，有很多信息是不好下传的（不满足交换或结合律），于是我们就无法使用 tag 来记录区修信息。但有的题目每一个操作都有潜在的操作次数上限，我们可以先判断该区间有没有需要操作的节点，有的话遍历到叶子节点进行修改，没有的话返回。

## 2. 这题如何使用势能线段树？

设 $n,m,k$ 同阶。

注意到，对于每个 $i$，$t \not = 0$ 的操作 1 最多操作 $O(\sqrt n)$ 次。而由于带修，每个数最多被修改 $O(n\sqrt n)$ 次。

由于使用线段树，暴力区修复杂度低达 $O(n \log n \sqrt n)$，但是似乎常数较大，可以通过本题，但可以通过构造极限数据卡掉。

## 3. AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
#define N 100006
using namespace std;
namespace IO
{
	int read()
	{
		int ret=0,bas=1;char ch=getchar();
		while(!isdigit(ch)&&ch!='-')ch=getchar();
		if(ch=='-')bas=-1,ch=getchar();
		while(isdigit(ch))ret=(ret<<3)+(ret<<1)+ch-'0',ch=getchar();
		return bas*ret;
	}
	void write(int k)
	{
		if(!k)return;
		write(k/10);
		putchar((char)(k%10+'0'));
	}
	void print(int k)
	{
		if(k==0)putchar('0');
		else if(k<0)putchar('-'),write(-k);
		else write(k);
	}
}
using namespace IO;
int minn[N<<2],sum[N<<2];
int a[N],b[N],n,m;
void push_up(int p)
{
	minn[p]=min(minn[p<<1],minn[p<<1|1]);
	sum[p]=sum[p<<1]+sum[p<<1|1];
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		minn[p]=a[l]*b[l],sum[p]=a[l]+b[l];
		return;
	}
	int mid=l+r>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	push_up(p);
}
void update0(int p,int l,int r,int L,int R,int k,int x)
{
	if(minn[p]>k)return;
	if(l==r)
	{
		minn[p]+=x*sum[p]+x*x;
		sum[p]+=x<<1;
		return;
	}
	int mid=l+r>>1;
	if(L<=mid)update0(p<<1,l,mid,L,R,k,x);
	if(R>mid)update0(p<<1|1,mid+1,r,L,R,k,x);
	push_up(p);
}
void update1(int p,int l,int r,int k,int x,int y)
{
	if(l==r)
	{
		minn[p]=x*y,sum[p]=x+y;
		return;
	}
	int mid=l+r>>1;
	if(k<=mid)update1(p<<1,l,mid,k,x,y);
	else update1(p<<1|1,mid+1,r,k,x,y);
	push_up(p);
}
int query(int p,int l,int r,int L,int R)
{
	if(L<=l&&r<=R)return sum[p];
	int mid=l+r>>1,ret=0;
	if(L<=mid)ret+=query(p<<1,l,mid,L,R);
	if(R>mid)ret+=query(p<<1|1,mid+1,r,L,R);
	return ret;
}
main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=n;i++)b[i]=read();
	build(1,1,n);
	while(m--)
	{
		int opt=read();
		if(opt==1)
		{
			int l=read(),r=read(),k=read(),x=read();
			if(x>0)update0(1,1,n,l,r,k,x);
		}
		if(opt==2)
		{
			int k=read(),x=read(),y=read();
			update1(1,1,n,k,x,y);
		}
		if(opt==3)
		{
			int l=read(),r=read();
			print(query(1,1,n,l,r));
			putchar('\n');
		}
	}
	return 0;
}
```

---

## 作者：Genius_Star (赞：1)

### 思路：

考虑线段树维护区间 $a_i \times b_i$ 的最小值 $Min$，若 $Min>k$，则不需要修改；否则递归到叶子节点进行修改。

**时间复杂度分析：**

- 注意到操作 $1$ 相当于令 $a \times b$ 变为 $(a + \sum t) \times (b + \sum t) = a \times b + \sum t \times (a+b)  + (\sum t)^2$。

- 因为 $k \le W$，则当 $(\sum t)^2 \ge W$ 即 $\sum t \ge \sqrt{W}$ 时，操作 $1$ 是修改不了当前位置的值的。

- 则若没有操作 $2$，每个位置最多有 $\sqrt{W}$ 次操作。

- 对于操作 $2$，每次最多将一个位置的操作重置。

- 则总时间复杂度为 $O((N+Q) \sqrt{N} \log N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
using namespace std;
typedef long long ll;
typedef long double db;
const ll N=100100;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
struct Node{
	int l,r;
	ll sum;
	ll Min;
}X[N<<2];
int n,m,op,l,r,pos,x,y;
ll a[N],b[N];
inline void pushup(int k){
	X[k].sum=X[k<<1].sum+X[k<<1|1].sum;
	X[k].Min=min(X[k<<1].Min,X[k<<1|1].Min);
}
inline void build(int k,int l,int r){
	X[k].l=l,X[k].r=r;
	if(l==r){
		X[k].Min=a[l]*b[l];
		X[k].sum=a[l]+b[l];
		return ;
	}
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	pushup(k);
}
inline void update(int k,int l,int r,int v,int t){
	if(X[k].Min>v)
	  return ;
	if(X[k].l==X[k].r){
		a[X[k].l]+=t,b[X[k].l]+=t;
		X[k].Min=a[X[k].l]*b[X[k].l];
		X[k].sum=a[X[k].l]+b[X[k].l];
		return ;
	}
	int mid=(X[k].l+X[k].r)>>1;
	if(r<=mid)
	  update(k<<1,l,r,v,t);
	else if(l>mid)
	  update(k<<1|1,l,r,v,t);
	else{
		update(k<<1,l,mid,v,t);
		update(k<<1|1,mid+1,r,v,t);
	}
	pushup(k);
}
inline void update(int k,int i,int x,int y){
	if(X[k].l==i&&i==X[k].r){
		a[i]=x,b[i]=y;
		X[k].Min=a[i]*b[i];
		X[k].sum=a[i]+b[i];
		return ;
	}
	int mid=(X[k].l+X[k].r)>>1;
	if(i<=mid)
	  update(k<<1,i,x,y);
	else
	  update(k<<1|1,i,x,y);
	pushup(k);
}
inline ll query(int k,int l,int r){
	if(X[k].l==l&&r==X[k].r)
	  return X[k].sum;
	int mid=(X[k].l+X[k].r)>>1;
	if(r<=mid)
	  return query(k<<1,l,r);
	else if(l>mid)
	  return query(k<<1|1,l,r);
	else
	  return query(k<<1,l,mid)+query(k<<1|1,mid+1,r);
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	  a[i]=read();
	for(int i=1;i<=n;i++)
	  b[i]=read();
	build(1,1,n);
	while(m--){
		op=read();
		if(op==1){
			l=read(),r=read(),x=read(),y=read();
			if(!y)
			  continue;
			update(1,l,r,x,y);
		}
		else if(op==2){
			pos=read(),x=read(),y=read();
			update(1,pos,x,y);
		}
		else{
			l=read(),r=read();
			write(query(1,l,r));
			putchar('\n');
		}
	}
	return 0;
}
```

---

## 作者：qinmingze (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10516)

### 思路

#### 维护变量

首先，我们先根据题目描述整理一下我们需要维护的变量。

```cpp
struct node{
	int l, r;
	ll a, b, sum, minmul;
}tree[N * 4];
```

$l$ 代表当前节点维护的区间的左端点。

$r$ 代表当前节点维护的区间的右端点。

$a$ 代表当前节点维护的点所对应的 $a$ 的值。

$b$ 代表当前节点维护的点所对应的 $b$ 的值。

$sum$ 代表当前节点维护的区间的区间和。

$minmul$ 代表当前节点维护的区间的最小乘积。

**注**：因为 $a$ 和 $b$ 的值在接下来的操作中只会在单点中去应用，因此在对变量的介绍中，不以区间来解释。

#### 第一个操作

按照题意，我们可以对每个点都进行枚举，但这样很明显，我们的代码将会超时，因此这时我们维护的 $minmul$ 就会起到作用，我们可以在每次向下遍历的时候，判断当前区间**是否满足** $minmul \le k$，如果小于，便说明下面的区间中，**有需要进行操作的点**，如果大于，则说明没有，我们就**不需要**向下继续遍历了。

```cpp
void add(int i, int l, int r, ll k, ll t){
	if(tree[i].l == tree[i].r){//单点修改。
		tree[i].a += t; tree[i].b += t;//对两个值都进行处理。
		tree[i].sum += (t + t);//更新区间和。
		if(tree[i].a > MAX || tree[i].b > MAX) tree[i].minmul = MAX;
		else if(tree[i].a * tree[i].b > MAX) tree[i].minmul = MAX;
		else tree[i].minmul = tree[i].a * tree[i].b;
		return ;
	}
	int mid = tree[i].l + tree[i].r >> 1;
	if(tree[i << 1].minmul <= k && l <= mid) add(i << 1, l, r, k, t);//左区间中有需要操作的点。
	if(tree[i << 1 | 1].minmul <= k && r >= mid + 1) add(i << 1 | 1, l, r, k, t);//右区间中有需要操作的点。
	pushup(i);
}
```

#### 第二个操作

看完第二个操作，我们不难看出，第二个操作是一个单点修改，对于单点修改，我们只需要从上到下进行寻找，最后找到当前点，依照题意，对维护的变量进行更新即可。

```cpp
void change(int i, int l, int r, ll x, ll y){
	if(tree[i].l >= l && tree[i].r <= r){//在范围内。
		tree[i].sum = x + y;//更新区间和。
		tree[i].a = x; tree[i].b = y;//单点修改。
		if(tree[i].a > MAX || tree[i].b > MAX) tree[i].minmul = MAX;
		else if(tree[i].a * tree[i].b > MAX) tree[i].minmul = MAX;
		else tree[i].minmul = tree[i].a * tree[i].b;
		return ;
	}
	int mid = tree[i].l + tree[i].r >> 1;
	if(l <= mid) change(i << 1, l, r, x, y);//遍历左区间。
	if(r >= mid + 1) change(i << 1 | 1, l, r, x, y);//遍历右区间。
	pushup(i);
}
```

后面的第三个操作，并没有什么难处，因此在这里不再过多赘述。

#### 注意事项

- $a_i \times b_i$ 的值可能会**非常大**，因此在 $minmul$ 中进行存储时，要对 $a_i$ 和 $b_i$ 的**值和乘积分别进行特判**，只有都在范围内的时候，才能存储两个数的乘积，否则存储一个**最大数**即可。

- 当第一个操作的 $t$ 的值为 $0$ 时，这个操作其实是**无效**的，因为它不会导致我们维护的任何一个变量更改，因此我们需要**进行特判**。

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long

using namespace std;

const int N = 1e5 + 10;

const ll MAX = 1e9;

ll a[N], b[N];

struct node{
	int l, r;
	ll a, b, sum, minmul;
}tree[N * 4];

void pushup(int i){
	tree[i].sum = tree[i << 1].sum + tree[i << 1 | 1].sum;//维护区间和。
	tree[i].minmul = min(tree[i << 1].minmul, tree[i << 1 | 1].minmul);//查找最小乘积。
}

void build(int i, int l, int r){//建树。
	tree[i].l = l; tree[i].r = r;
	if(l == r){
		tree[i].a = a[l]; tree[i].b = b[l];
		tree[i].sum = a[l] + b[l]; 
		if(a[l] > MAX || b[l] > MAX) tree[i].minmul = MAX;
		else if(a[l] * b[l] > MAX) tree[i].minmul = MAX;
		else tree[i].minmul = a[l] * b[l];
		return ;
	}
	int mid = l + r >> 1;
	build(i << 1, l, mid); build(i << 1 | 1, mid + 1, r);
	pushup(i);
}

void add(int i, int l, int r, ll k, ll t){//第一个操作，区间修改。
	if(tree[i].l == tree[i].r){
		tree[i].a += t; tree[i].b += t;
		tree[i].sum += (t + t);
		if(tree[i].a > MAX || tree[i].b > MAX) tree[i].minmul = MAX;
		else if(tree[i].a * tree[i].b > MAX) tree[i].minmul = MAX;
		else tree[i].minmul = tree[i].a * tree[i].b;
		return ;
	}
	int mid = tree[i].l + tree[i].r >> 1;
	if(tree[i << 1].minmul <= k && l <= mid) add(i << 1, l, r, k, t);
	if(tree[i << 1 | 1].minmul <= k && r >= mid + 1) add(i << 1 | 1, l, r, k, t);
	pushup(i);
}

void change(int i, int l, int r, ll x, ll y){//单点修改。
	if(tree[i].l >= l && tree[i].r <= r){
		tree[i].sum = x + y;
		tree[i].a = x; tree[i].b = y;
		if(tree[i].a > MAX || tree[i].b > MAX) tree[i].minmul = MAX;
		else if(tree[i].a * tree[i].b > MAX) tree[i].minmul = MAX;
		else tree[i].minmul = tree[i].a * tree[i].b;
		return ;
	}
	int mid = tree[i].l + tree[i].r >> 1;
	if(l <= mid) change(i << 1, l, r, x, y);
	if(r >= mid + 1) change(i << 1 | 1, l, r, x, y);
	pushup(i);
}

ll find(int i, int l, int r){//查找区间和。
	if(tree[i].l >= l && tree[i].r <= r) return tree[i].sum;
	int mid = tree[i].l + tree[i].r >> 1;
	ll ans = 0;
	if(l <= mid) ans += find(i << 1, l, r);
	if(r >= mid + 1) ans += find(i << 1 | 1, l, r);
	return ans;
}

int main(){
	int n, m;
	cin >> n >> m;
	for(int i = 1; i <= n; i++) scanf("%lld", &a[i]);
	for(int i = 1; i <= n; i++) scanf("%lld", &b[i]);
	build(1, 1, n);
	while(m--){
		int op;
		cin >> op;
		if(op == 1){
			ll l, r, k, t;
			scanf("%lld%lld%lld%lld", &l, &r, &k, &t);
			if(t != 0)add(1, l, r, k, t);
			else if(t == 0) continue;//进行特判，当 t = 0 时，这个操作等价于是无效的，不用进行操作。
		}else if(op == 2){
			ll t, x, y;
			scanf("%lld%lld%lld", &t, &x, &y);
			change(1, t, t, x, y);
		}else if(op == 3){
			int l, r;
			scanf("%d%d", &l, &r);
			printf("%lld\n", find(1, l, r));
		}
	}
}
```

---

## 作者：I_will_AKIOI (赞：1)

赛时写出一道数据结构，上大分！

首先这种区间修改首选线段树。观察操作 $1$，需要满足 $a_i\times b_i\le k$，而 $k$ 的范围只有 $10^5$。并且操作 $1$ 是区间修改，操作 $2$ 只能单点修改。所以在很多情况 $a_i\times b_i$ 都比 $k$ 大，这无疑会浪费很多时间。

所以我们可以维护区间内 $a_i\times b_i$ 的最小值，如果区间的最小值都比 $k$ 大，那么这个区间就没有必要修改了。接着暴力修改操作 $1$。

注意要特判 $t=0$，不然会挂 $5$ 分。

```cpp
#include<bits/stdc++.h>
#define N 100005
using namespace std;
struct Data
{
  int l,r,a,b,minn,ok;
  long long sum;
}t[400005];
int n,m,a[N],b[N];
void build(int k,int l,int r)
{
  t[k].l=l,t[k].r=r;
  if(l==r)
  {
    t[k].sum=a[l]+b[l];
    t[k].a=a[l];
    t[k].b=b[l];
    if(a[l]>N&&b[l]>N) t[k].minn=INT_MAX;
    else if((long long)a[l]*b[l]>N) t[k].minn=INT_MAX;
    else t[k].minn=a[l]*b[l];
    return;
  }
  int mid=l+r>>1;
  build(k*2,l,mid);
  build(k*2+1,mid+1,r);
  t[k].sum=t[k*2].sum+t[k*2+1].sum;
  t[k].minn=min(t[k*2].minn,t[k*2+1].minn);
  return;
}
void update1(int k,int l,int r,int x,int y)
{
  if(t[k].minn>x||y==0) return;
  if(t[k].l==t[k].r)
  {
    t[k].a+=y;
    t[k].b+=y;
    t[k].sum+=y+y;
    if(t[k].a>N&&t[k].b>N) t[k].minn=INT_MAX;
    else if((long long)t[k].a*t[k].b>N) t[k].minn=INT_MAX;
    else t[k].minn=t[k].a*t[k].b;
    return;
  }
  int mid=t[k].l+t[k].r>>1;
  if(l<=mid) update1(k*2,l,r,x,y);
  if(r>mid) update1(k*2+1,l,r,x,y);
  t[k].sum=t[k*2].sum+t[k*2+1].sum;
  t[k].minn=min(t[k*2].minn,t[k*2+1].minn);
  return;
}
void update2(int k,int l,int x,int y)
{
  if(t[k].l==t[k].r&&t[k].l==l)
  {
    t[k].a=x;
    t[k].b=y;
    t[k].sum=x+y;
    if(t[k].a>N&&t[k].b>N) t[k].minn=INT_MAX; 
    else if((long long)t[k].a*t[k].b>N) t[k].minn=INT_MAX;
    else t[k].minn=t[k].a*t[k].b;
    return;
  }
  int mid=t[k].l+t[k].r>>1;
  if(l<=mid) update2(k*2,l,x,y);
  if(l>mid) update2(k*2+1,l,x,y);
  t[k].sum=t[k*2].sum+t[k*2+1].sum;
  t[k].minn=min(t[k*2].minn,t[k*2+1].minn);
  return;
}
long long query(int k,int l,int r)
{
  if(l<=t[k].l&&t[k].r<=r) return t[k].sum;
  int mid=t[k].l+t[k].r>>1;
  long long ans=0;
  if(l<=mid) ans+=query(k*2,l,r);
  if(r>mid) ans+=query(k*2+1,l,r);
  return ans;
}
signed main()
{
  ios::sync_with_stdio(0);
  cin>>n>>m;
  for(int i=1;i<=n;i++) cin>>a[i];
  for(int i=1;i<=n;i++) cin>>b[i];
  build(1,1,n);
  while(m--)
  {
    int op,x,y,z,w;
    cin>>op>>x>>y;
    if(op==1) cin>>z>>w,update1(1,x,y,z,w);
    if(op==2) cin>>z,update2(1,x,y,z);
    if(op==3) cout<<query(1,x,y)<<"\n";
  }
  return 0;
}
```

---

## 作者：LG086 (赞：0)

线段树，维护区间中每个 $a_i+b_i$ 的和 $sum$ 以及区间中 $a_i\times b_i$ 的最小值 $mul$。

一个节点 $k$ 包含的信息是 $l,r,sum_k,mul_k$，表示这个节点包含区间的左右端点、区间和、区间乘积最小值。\
我们用 $ls$ 和 $rs$ 代表节点 $k$ 的左右孩子的编号。因此有下面的两行代码。
```cpp
#define ls k<<1
#define rs k<<1|1
```
在 $pushup$ 操作中更新 $sum_k \leftarrow sum_{ls}+sum_{rs},mul_k \leftarrow \min(mul_{ls},mul_{rs})$。\
在 $build$ 函数中，若当前节点 $k$ 的 $l=r$，则 $sum_k\leftarrow a_l+b_l,mul_k\leftarrow a_l\times b_l$。否则继续递归左右孩子。

下面给出两个函数的代码。

```cpp
void pushup(int k){
 sum[k]=sum[ls]+sum[rs];
 mul[k]=min(mul[ls],mul[rs]);
 return;
}
void build(int k,int l,int r){
 if(l==r){
  sum[k]=a[l]+b[l];
  mul[k]=a[l]*b[l];
  return;
 }
 int mid=(l+r)>>1;
 build(ls,l,mid);
 build(rs,mid+1,r);
 pushup(k);
 return;
}
```

接下来看三种操作。

对于操作一，暴力美学是遍历 $l$ 到 $r$，判断每个 $a_i \times b_i$ 的值是否小于等于 $K$，若 $a_i \times b_i \gt K$ 则不进行修改。\
如果一整个区间内最小的一个 $a_i \times b_i$ 都比 $K$ 大，就没必要再看了。于是维护区间中 $a_i\times b_i$ 的最小值，$mul_k$ 代表的是节点 $k$ 所包含的区间的最小的 $a_i\times b_i$ 的值。每次只在 $mul_k \le K$ 的范围内找需要修改的位置。\
这样找下去，当某个节点 $k$ 的 $l$ 和 $r$ 相等，说明 $a_l \times b_l \le k$，那么修改 $mul_k$ 和 $sum_k$。因为有 $(a_l+t)\times(b_l+t) = a_l\times b_l+a_l\times t + b_l\times t+t\times t = mul_k+sum_k\times t+t^2$，所以修改时 $mul_k \leftarrow mul_k+sum_k\times t+t^2$，而 $sum_k \leftarrow sum_k+2t$。\
**注意**，在操作一的时候，如果 $t=0$，则修改无意义，需要跳过，否则超时。

操作一的代码如下。

```cpp
void upd1(int k,int l,int r,int x,int y,ll val,ll K){
 if(l==r){
  mul[k]+=sum[k]*val+val*val;
  sum[k]+=(ll)(r-l+1)*2*val;
  return;
 }
 int mid = (l+r)>>1;
 if(x<=mid and mul[ls]<=K)upd1(ls,l,mid,x,y,val,K);
 if(y>=mid+1 and mul[rs]<=K)upd1(rs,mid+1,r,x,y,val,K);
 pushup(k);
 return;
}
```

对于操作二，单点修改 $a_p$ 和 $b_p$ 的值为 $val_a$ 和 $val_b$。找到一个节点 $k$ 满足 $l=r$ 且 $l=p$，然后更新 $sum_k$ 和 $mul_k$ 的值。有 $sum_k \leftarrow val_a + val_b$ 和 $mul_k \leftarrow val_a\times val_b$。

下面给出操作二的代码。

```cpp
void upd1(int k,int l,int r,int x,int y,ll val,ll K){
 if(l==r){
  mul[k]+=sum[k]*val+val*val;
  sum[k]+=(ll)(r-l+1)*2*val;
  return;
 }
 int mid = (l+r)>>1;
 if(x<=mid and mul[ls]<=K)upd1(ls,l,mid,x,y,val,K);
 if(y>=mid+1 and mul[rs]<=K)upd1(rs,mid+1,r,x,y,val,K);
 pushup(k);
 return;
}
```

对于操作三，区间查询 $x$ 到 $y$ 的每个 $a_i+b_i$ 的和。按模板来写就行。对于一个节点 $k$，如果 $x \le l \le r \le y$，说明节点 $k$ 包含的区间被包含在查询的区间内，那么返回 $sum_k$。否则记 $mid = \frac{l+r}{2}$，分成 $l$ 到 $mid$ 和 $mid+1$ 到 $r$ 的两个部分，如果 $x \le mid$，那么查询 $l$ 到 $mid$ 的区间，即左孩子包含的区间，同时如果 $y \le mid+1$，那么查询 $mid+1$ 到 $r$ 的区间，即右孩子包含的区间。

如下是操作三代码。

```cpp
ll query(int k,int l,int r,int x,int y){
 if(x<=l and r<=y)return sum[k];
 int mid = (l+r)>>1;
 ll res = 0;
 if(x<=mid)res=query(ls,l,mid,x,y);
 if(y>=mid+1)res+=query(rs,mid+1,r,x,y);
 return res;
}
```

主函数部分，只给出 $m$ 次询问的代码：

```cpp
while(m--){
 cin>>op;
 if(op==1){cin>>l>>r>>k>>t;if(t!=0)upd1(1,1,n,l,r,t,k);}
 else if(op==2)cin>>p>>x>>y,upd2(1,1,n,p,x,y);
 else cin>>l>>r,cout<<query(1,1,n,l,r)<<"\n";
}
```

完整代码自己拼。

---

## 作者：RyanLi (赞：0)

**简要题意**：维护两个序列 $a$ 和 $b$，要求支持区间加、单点赋值、区间查询。

对于这些操作，我们考虑使用线段树。

考虑操作一需要维护的信息。题目要求给 $a_i \times b_i \le k$ 的位置的 $a_i$ 和 $b_i$ 各加上 $t$，显然需要维护的是与 $a_i \times b_i$ 相关的信息。对于线段树上的节点，如果我们要给每个 $\le k$ 的区间都修改，那么要保证当前节点代表的区间也 $\le k$，这样才能够递归下去。

这时，我们就可以想到维护区间内 $a_i \times b_i$ 的最小值。这样，如果一个节点代表的区间的最小值 $\le k$，那么代表这个区间内一定有满足 $a_i \times b_i \le k$ 的子区间，即可递归进行修改。

操作二就是朴素的单点修改。

操作三为查询区间和。注意到，每次查询只关心 $a_i + b_i$ 是多少，而不关心 $a_i$ 和 $b_i$ 具体的值。因此，我们直接维护区间 $a_i + b_i$ 和即可。

这样，操作二就变为将位置 $i$ 的和修改为 $x + y$，积修改为 $x \times y$。

值得注意的是，在操作一中，$t = 0$ 时仍然进行修改将耗费大量的时间，因此还需要对这一情况进行特判。

``` cpp
#include <iostream>
#define ls(p) t[p].lson
#define rs(p) t[p].rson
#define mid (l + r >> 1)
using namespace std;
using ll = long long;

const int N = 1e5 + 10;
const ll INF = 1e18;
ll n, m, a[N], b[N], op, l, r, k, t, x, y, ans;
struct seg_tree {
    int rt[N << 1], tot;
    struct node {
        int lson, rson;
        ll sum, minprod;
    } t[N << 1];

    void pushup(int p) {
        t[p].sum = t[ls(p)].sum + t[rs(p)].sum;
        t[p].minprod = min(t[ls(p)].minprod, t[rs(p)].minprod);
    }

    void build(int &p, int l, int r) {
        p = ++tot;
        t[p].minprod = INF;
        if (l == r) return t[p].sum = a[l] + b[l], t[p].minprod = a[l] * b[l], void();
        build(ls(p), l, mid);
        build(rs(p), mid + 1, r);
        pushup(p);
    }

    ll query(int p, int l, int r, int L, int R) {
        if (l > R || r < L) return 0;
        if (l >= L && r <= R) return t[p].sum;
        return query(ls(p), l, mid, L, R) + query(rs(p), mid + 1, r, L, R);
    }

    void update_add(int p, int l, int r, int L, int R, int k, int x) {
        if (l > R || r < L || t[p].minprod > k) return;
        if (l == r) return t[p].sum += (x << 1), t[p].minprod = (a[l] += x) * (b[l] += x), void();
        update_add(ls(p), l, mid, L, R, k, x);
        update_add(rs(p), mid + 1, r, L, R, k, x);
        pushup(p);
    }

    void update_assign(int p, int l, int r, int k, int x, int y) {
        if (l > k || r < k) return; 
        if (l == r) return t[p].sum = x + y, t[p].minprod = 1ll * x * y, void();
        update_assign(ls(p), l, mid, k, x, y);
        update_assign(rs(p), mid + 1, r, k, x, y);
        pushup(p);
    }
} tree;

int main() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    for (int i = 1; i <= n; ++i) cin >> b[i];
    tree.build(tree.rt[1], 1, n);
    while (m--) {
        cin >> op;
        if (op == 1) {
            cin >> l >> r >> k >> t;
            if (!t) continue;
            tree.update_add(tree.rt[1], 1, n, l, r, k, t);
        } else if (op == 2) cin >> l >> x >> y, a[l] = x, b[l] = y, tree.update_assign(tree.rt[1], 1, n, l, x, y);
        else cin >> l >> r, cout << tree.query(tree.rt[1], 1, n, l, r) << '\n';
    } return 0;
}
```

---


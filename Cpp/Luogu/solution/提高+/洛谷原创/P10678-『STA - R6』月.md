# 『STA - R6』月

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/azq4hrv9.png)

## 题目描述

对于一棵有 $n$ 个节点的树 $T$，定义其直径 $\operatorname{diam}(T)$ 为任意两个节点之间距离的最大值。

给定正整数 $n$ 和每个点 $i$ 的度数 $d_i$，你需要构造一棵树 $T^\prime$，同时最小化 $\operatorname{diam}(T^\prime)$。

保证至少存在一棵符合要求的树，若存在多个符合要求的答案，输出任意一个即可。

## 说明/提示

**【样例解释】**

对于最后一组数据，所构造出的树如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/3mjz6jmf.png)

其直径等于点 $5,7$ 之间或点 $6,7$ 之间的距离，为 $4$。可以证明，不存在满足条件的直径小于 $4$ 的树。

**【数据范围】**

**本题采用捆绑测试。**

对于 $100\%$ 的数据：

- $2 \le n \le 2 \times 10^5$；
- $1 \le T \le 10^5$；
- $\sum n \le 2 \times 10^5$；
- $1 \le d_i < n$；
- 保证至少存在一个合法的解。

具体部分分分配如下：

|Subtask 编号|数据范围|分值|
|:--------:|:--------:|:--------:|
|1|$n \le 5$|$17$|
|2|$d_i \le 2$|$23$|
|3|$d$ 中只含有两种本质不同的元素|$26$|
|4|无特殊限制|$34$|

## 样例 #1

### 输入

```
4
2
1 1
3
1 1 2
5
1 1 2 2 2
7
1 3 2 3 1 1 1```

### 输出

```
2 1
1 3
3 2
5 4
4 2
3 1
3 5
4 2
3 2
1 2
5 4
6 4
7 3```

# 题解

## 作者：User_Unauthorized (赞：28)

首先我们有如下两条结论：

- 对于任意一棵最大深度为 $d$ 的有根树，其直径长度不大于 $2 \times d$。

- 若某棵树的直径长度为 $l$，那么取直径中点为根可以得到最大深度为 $\lceil\frac{l}{2}\rceil$ 的有根树。

因此我们不妨在构造过程中尽可能地最小化该树的最大深度。若我们最终构造出的最大深度为 $d$，因此我们可以得出一定不存在长度不大于
$2 \times (d - 1)$ 的直径。否则我们可以得到一棵最大深度为 $d - 1$ 的有根树，与最小的构造不符。

同时我们可以知道满足最大深度为 $d$ 的树一定满足直径长度为 $[2 \times d - 1, 2 \times d]$。因此我们考虑该树直径长度能否取到
$2 \times d - 1$，发现此种情况当且仅当该树根节点仅有一个儿子节点的子树内的节点最大深度为 $d$，其余儿子节点子树内的节点最大深度均为
$d - 1$。同时可以发现第 $d$ 层中的节点一定均为度数为 $1$ 的叶子节点，因此问题转化为了能否最大化一棵子树的叶子节点数量。

考虑如下构造方法：将所有节点按度数降序排列，从前之后依次考虑每个节点，将其连接在排列中第一个还可以被连接的节点。

我们按照上述的两个要求证明此构造方案的合理性。

1. 要求最小化最大深度，可以发现，若存在节点 $u, v$，满足 $dep_u < dep_v$ 且 $d_u < d_v$，那么交换 $u, v$ 一定可以使得该树容纳更多的节点。

2. 要求尽可能地使得仅有一棵子树最大深度为 $d$，可以发现，在第一条的限制下，每一层可以填的节点都是固定的，因此将每一层度数大的节点优先填到一棵子树内一定不劣。

因此上述构造方案一定不劣。

复杂度为 $\mathcal{O}(\sum n \log n)$，瓶颈在于排序。

---

## 作者：wmrqwq (赞：10)

upd:

哎哎哎，原来的题解没怎么写证明被叉了 /yun

所以我来补下证明。

upd2:

修改代码，增加代码可读性。

# 题目链接

[P10678 『STA - R6』月](https://www.luogu.com.cn/problem/P10678)

# 解题思路

时间复杂度优于官解的做法。

首先我们观察到一个性质就是 $\sum a_i = 2 \times (n - 1)$，因为一个树有 $n - 1$ 条边。

注意到一棵树**必定有**叶子结点。

于是我们每次给树连边只需要拿一个剩余需连的边数为 $1$ 的点和剩余需连的边数大于 $1$ 的点相连即可，**注意**，如果没有剩余需连的边数大于 $1$ 的点，需要特判，让另一个度数为 $1$ 的点与这个点相连。

~~正确性显然。~~

下面是证明：

你注意到，你可以把一次加边操作看为将两个点的剩余度数减去 $1$ 的操作，并且加边操作有**至少一个点**剩余的度数为 $1$，因此，一个点连接的所有点的数量减去一的点的数量都是因为该点的度数为 $1$，而另外一个点则是因为该点度数为 $1$ 因此连接下一个点。

也就是说，最后形成的树可以抽象的看成菊花状，并且只要能连点，那么当前剩余需连度数为 $1$ 的点都被尽量连到了同一个点上，并且树的直径大小一定是两个度数为 $1$ 的点的路径长度，因此这样的连边方式也就保证了最后的树的直径最小。

时间复杂度 $O(\sum n)$。

# 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define forl(i,a,b) for(register long long i=a;i<=b;i++)
#define forr(i,a,b) for(register long long i=a;i>=b;i--)
#define forll(i,a,b,c) for(register long long i=a;i<=b;i+=c)
#define forrr(i,a,b,c) for(register long long i=a;i>=b;i-=c)
#define pb push_back
#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
#define endl '\n'
#define QwQ return 0;
#define ll long long
ll t;
ll n;
queue<ll>q[200010];
ll a[200010],b[200010];
void solve()
{
	cin>>n;
	ll ma=0;
	forl(i,1,n)
		cin>>a[i],ma=max(ma,a[i]),b[a[i]]++,q[a[i]].push(i);
	ll S=0;
	while(S<n-1)
	{
		ll id1=q[1].front();
		q[1].pop();
		cout<<id1<<' ';
		ll pd=0;
		forl(j,2,ma)
		{
			if(!q[j].empty())
			{
				id1=q[j].front();
				cout<<id1<<endl;
				S++;
				q[j].pop();
				q[j-1].push(id1);
				ll L=j-1;
				while(L>=2)
				{
					id1=q[L].front();
					cout<<id1<<' ';
					cout<<q[1].front()<<endl;
					S++;
					q[1].pop();
					q[L].pop();
					q[--L].push(id1);	
				}
				pd=1;
				break;
			}
		}
		if(!pd)
		{
			id1=q[1].front();
			cout<<id1<<endl;
			S++;
			q[1].pop();
		}
	}
}
int main()
{
	IOS;
	t=1;
 	cin>>t;
	while(t--)
		solve();
	QwQ;
}
```

---

## 作者：M4rkSELby (赞：9)

~~不~~ 简易结论题。

首先明确一下树的直径的定义（也许就我这种蒟蒻赛前都不知道树的直径是啥）：**树中距离最远的两个点之间的距离**被称为树的直径。

那么根据定义我们直接想到一个结论：每次从父节点到子节点连边时我们尽量找度数更多的节点当儿子，先把度数多的节点解决了。

这个其实很容易想明白。先把需要连的边多的节点连掉，后面整棵树连边才会更均匀，才能尽量拉近最远两点间的距离。

依据这个策略我们开始构造，这里我们用变量 $now$ 动态维护当前连到第几个点：先对所有点按度数排序，然后遍历节点，从 $now$ 号点开始，往下不断找，找到一个能连的边就直接与当前节点连边并将其两个节点的度数减 $1$，并将 $now$ 加 $1$，直到当前节点度数为 $0$。因为第一个点只能先往二号点连边，所以 $now$ 初始为 $2$。

容易发现连边复杂度为 $O(n)$，排序复杂度为 $O(n\log{n})$，复杂度稳过。

附上代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define il inline
#define pii pair<int,int>
#define mk make_pair
#define mod 100000000
using namespace std;
il int rd(){
    int jya=0,tl=1;char jyt=getchar();
    while(!isdigit(jyt)){if(jyt=='-')tl=-1;jyt=getchar();}
    while(isdigit(jyt)){jya=(jya<<1)+(jya<<3)+(jyt-'0');jyt=getchar();}
    return jya*tl;
}
il void wr(int jjy){
    if(jjy<0)putchar('-'),jjy=-jjy;
    if(jjy>9)wr(jjy/10);
    putchar(jjy%10+48);
}
il int max(int x,int y){return x>=y?x:y;}
il int min(int x,int y){return x<=y?x:y;}
const int JYAAKIOI=1145141919810;
struct node{
	int id,x;
}a[200086],b[200086];
int T,n,now;
vector<int>l,r;
il bool cmp(node x,node y){
	return x.x>y.x;
}
signed main(){
	//freopen("jytwcsnm.in","r",stdin);
	//freopen("jytwcsnm.out","w",stdout);
	T=rd();
	while(T--){
		l.clear();r.clear();
		n=rd();
		for(int i=1;i<=n;++i)a[i].x=rd(),a[i].id=i;
		sort(a+1,a+1+n,cmp);
		now=2;
		for(int i=1;i<=n;++i){
			for(int j=1;j<=a[i].x;++j){
				l.push_back(a[i].id);
				r.push_back(a[now].id);
				--a[now].x;
				++now;
			}
		}
		for(int i=0;i<l.size();++i){
			wr(l[i]),putchar(' '),wr(r[i]),putchar('\n');
		}
	}
	return 0;
}
```

---

## 作者：Reunite (赞：9)

### P10678 『STA - R6』月 题解

真的很难理解么？

---

稍微复述以下题解做法：对于一个已经确定的无根树，我们想办法把它调整，使其直径中点为根，设此时深度为 $d$，那直径一定在 $[2d-1,2d]$ 之间，分别对应根有且仅有一个子树 $maxdep=d$，且剩下所有子树 $maxdep=d-1$，和有 $>1$ 子树 $maxdep=d$。

这个需要说明么？还是详细说一下吧：

- $len=2d-1$，容易说明，上述条件是充分的，考虑必要性，如果 $maxdep$ 大于 $1$ 个 $=d$，显然 $len=2d$，若无，则 $len<2d-1$，若存在一个 $maxdep \notin [d,d-1]$，则可以向最深的那个移动一步，或者说此时的根根本就不是直径中点。全部矛盾。

- $len=2d$，这个是显然的，因为 $2\mid len$，直径中点唯一。

注意到，对于 $\forall_{i,j}i<j $，其对因可能的 $len(maxdep=i)$ 一定是严格小于 $len(maxdep=j)$，因为由上：$len(maxdep=x)\in[2x-1,2x]$。

因此我们先要最小化 $maxdep$，然后在此基础上，尽量使其取到 $2x-1$。

---

先想想怎么最小化 $maxdep$，一个我觉得显然的贪心是，按照 $d_u$ 降序排序，然后从前往后，直接能连就连。

下面我将证明这一步贪心的正确性：

> 考虑刻画树形态。形式化地，我们这样连出来的树，其 bfs 序对应的 $d_u$ 显然是单调不升的。也就是，$\forall_{i,j,dep_i=dep_j,bfs_i<bfs_j} d_i\ge d_j$，$\forall_{i,j,dep_i<dep_j} d_i \ge d_j$
。分别对应，同层之内从左到右不升，在深度上任意偏序满足不升。这样显然唯一确定了我们贪心连的树。
>
> 假设我们知道了一个最优的树 $T$，满足其 $maxdep$ 最小，我们希望通过交换调整，使其满足上面的性质。
>
> 显然第一个限制是无所谓的，因为同层之间交换儿子的顺序不会影响深度，只需要在满足 $maxdep$ 不变且满足第二个性质即可。考察 $\forall_{i,j},dep_i<dep_j,d_i<d_j$，那么我们试图把 $i,j$ 交换，但是 $j$ 显然有多的儿子连不到换过来的 $i$ 上，只需要任意选择 $d_j-d_i$ 个 $j$ 的子树跟着 $j$ 向上移动到 $i$ 的位置即可。这个过程中，只会把子树向上移，$maxdep$ 一定不会变大。
>
> 通过这样的调整，我们一定能满足限制二，限制一只需要再满足限制二之后，同层平移排一下即可。所以这样一定是最优的。

---

这样我们解决了一部分这题，已经能保证 $maxdep$ 能取到最小了，现在再来考虑怎么才能尽量取到 $2maxdep-1$。

同样考虑逆向交换调整证明：

> 设一个树 $T$ 满足它在 $maxdep$ 最小，且满足根仅有一个子树方向 $maxdep=d$，剩下全是 $maxdep=d-1$。这时候交换 $dep$ 不同的同上简单，不会影响，但是同层交换此时并不显然，因为可能把 $maxdep=d$ 的那棵子树叶子的小分支换走，造成 $>1$ 个 $maxdep=d$。
>
> 但这些不是问题，强制要求 $maxdep=d$ 的那部分，能到 $dep=d$ 的叶子的那些分支，全部选同层最大 $d_u$，若本身就是最大，无影响，否则的话会在上方带来一些空位，可以把较深的点往上挪，也保证了能取到 $maxdep=d$ 的所有部分仍在这个原来子树的方向上。证毕。

---

现在我们用了两次证明说明了，按照 $d_u$ 降序顺次连，同时恰好满足了两个最优条件，因此直接这样连就可以了。

本质上还是，从任意树到这样的 bfs 偏序树，无论怎样都能在更靠上的位置带来空位，使得可以把较深的点往上移，也当然保证了正确性。只是做题的话，想到了这个就可以了吧。

代码：没写。

---

## 作者：是青白呀 (赞：8)

首先能感性地得到一个做法：在不限制度数的情况下，最优情况应当是一个菊花。那么我们尝试趋向菊花的方向构造。具体地，将点按度数从大往小排序，从第二个点开始，将每一个点连到排序后序列中最靠前的、还有空余度数的点上去即可。

下面尝试对该做法给出证明。

不妨将度数最大的点作为根。你发现对于按照上述流程构造出来的树，排序后的序列实际上就是它的 BFS 序。因此，叶子结点的深度差最大为 $1$。假设叶子结点的深度为 $x$ 和 $x+1$，则不经过根节点的路径长度最大为 $2x$，经过根节点的路径长度最大值至少为 $2x+1$，故**该树的直径一定过根节点**。

此时，我们要最小化直径，也就是要最小化深度最大和次大的叶子的深度和。

先考虑最小化深度最大的叶子的深度，也即一棵树的深度。你发现对于一棵确定了点数的树，最小化深度等价于最大化每一层能放下的点数。我们考虑一层一层地加点，当上一层放的点数固定的时候，上一层点的总度数越大，这一层能放的点越多。又因为第一层只能放 $1$ 个点，是固定的，所以我们把所有点按照度数从大到小的顺序排序，依次 BFS 地加点，这样得到的树的深度是最小的。因此，按照上述方法构造出来的树，满足其深度是最小的。

在叶子深度仅有 $x$ 和 $x+1$ 的情况下，你会发现任意一组修改都只会使直径不变或增大，因为有删除就有插入，由于你不能变换根节点，且变换的那个点的度数不变，因此，变换节点位置一定会导致某些叶子的深度增大 $1$，而某些叶子的深度至多减少 $1$，因此构造叶子直径尽可能相同的树，可以使得树的直径取得最小值。

综上，该构造方案可以使得树的直径取得最小值。

---

## 作者：Jadonyzx (赞：4)

N 方过十万，暴力碾标算。

观察样例容易发现度较大的点连接在一起，合理猜测将度较大的全部优先连接在一起即为最优解，因此打出优美的 N 方暴力代码。

由于某个名为[沉石鱼惊旋](https://www.luogu.com.cn/user/516346)的敬业审核员认为解法说明不足，下面给出详细证明和说明：

首先假设我们构造出了一颗深度为 $d$ 的树，容易得出：

树的最大直径要么为 $2\times d + 1$，要么为 $2\times d$。不难发现要使树的最大直径最小，我们需要使叶子结点最多，因此要使度数大的节点最多地连在一起。

故我们开一个结构体存节点并根据结点度数排序。

从最大的节点开始枚举，依次往下枚举，若遇到的节点仍存在度数且相连时不会产生环，则与之连接，并且两点度数都减一，不难发现这是优美的 $O(n^2)$。

然而如何判断是否产生环呢？

根据我们的策略，如果有一个点的度数排第三大，那么假设我们现在枚举到第二大的点，假设其有剩余度数那么可以证明之前我们一定将它与最大的点相连了，而第二大的点也一定与最大的点相连了，因此会产生环。

将这个结论推广到一般情况：

第 $i$ 个点已经连接到了树上，现在我们在枚举第 $j$ 个点，并且满足 $j>i$。假设第 $i$ 个点已经与第 $k$ 个点相连，由于 $j>i$，一定有第 $j$ 个点已经与第 $k$ 个点相连，因此不能连接第 $i$ 个点和第 $j$ 个点，否则会产生环。

根据这个结论，我们可以开一个 $vis$ 数组用来存每个点是否已经连在了树上，每次判定一下即可。

代码如下：

```cpp
#include<bits/stdc++.h>
#define maxn 200010
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
	return x*f;
}
inline void write(int x){
	if(x<0){
		putchar('-');
		write(-x);
		return;
	}
	if(x>=10)write(x/10);
	putchar(x%10+'0');
	return;
}
int T,n;
struct node{
	int id,dgr;
}tre[maxn];
bool cmp(node ccf,node ioi){
	return ccf.dgr<ioi.dgr;
}
bool vis[maxn];
signed main()
{
	T=read();
	while(T--){
		n=read();
		for(int i=1;i<=n;++i){
			tre[i].dgr=read();tre[i].id=i;
		}
		sort(tre+1,tre+1+n,cmp);
		for(int i=n;i>=1;--i){
			int mmax=tre[i].dgr;
			for(int j=i-1;mmax>0;--j){
				if(tre[j].dgr>0&&i!=j&&!vis[j]){
					cout<<tre[i].id<<' '<<tre[j].id<<'\n';
					tre[j].dgr--;mmax--;tre[i].dgr--;
					vis[i]=1;vis[j]=1;
				}
			}
		}
		for(int i=1;i<=n;++i)vis[i]=0;
	}
	return 0;
}
```

[提交记录](https://www.luogu.com.cn/record/163470741)

然后就发现只 T 了一个点（狂喜）。

也就是说 N 方有希望。

优化一：我们的 $vis$ 数组每次都得一个一个赋值，时间开销较大，故使用 `memset`。代码：

```cpp
memset(vis,0,sizeof vis);
```

[还是 T 了](https://www.luogu.com.cn/record/163470907)

再次观察发现，如果有一个点在判断时发现其度数已用完，那么下一次判这个点就会浪费很多时间，然而由于我们的度数是按照单调不减排列的，而使用时又是从大到小，因此如果一个点的度数用完了，它之前的点都一定用完了度数，可以跳过，用一个 $minn$ 维护目前最大的还有度数的点，每次从这个点开始枚举。

代码：

```cpp
#include<bits/stdc++.h>
#define maxn 200010
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
	return x*f;
}
inline void write(int x){
	if(x<0){
		putchar('-');
		write(-x);
		return;
	}
	if(x>=10)write(x/10);
	putchar(x%10+'0');
	return;
}
int T,n;
struct node{
	int id,dgr;
}tre[maxn];
bool cmp(node ccf,node ioi){
	return ccf.dgr<ioi.dgr;
}
bool vis[maxn];
signed main()
{
	T=read();
	while(T--){
		n=read();
		for(int i=1;i<=n;++i){
			tre[i].dgr=read();tre[i].id=i;
		}
		sort(tre+1,tre+1+n,cmp);
		int minn=n;
		for(int i=n;i>=1;--i){
			int mmax=tre[i].dgr;
			for(int j=min(i-1,minn);mmax>0;--j){
				if(tre[j].dgr>0&&i!=j&&!vis[j]){
					write(tre[i].id);putchar(' ');write(tre[j].id);putchar('\n');
					tre[j].dgr--;mmax--;tre[i].dgr--;
					vis[i]=1;vis[j]=1;minn=j;
				}
			}
		}
		memset(vis,0,sizeof vis);
	}
	return 0;
}
```

[AC](https://www.luogu.com.cn/record/164090310)

N 方过十万，暴力碾标算。

---

## 作者：佬头 (赞：2)

## Description
给定正整数 $n$ 和每个节点 $i$ 的度数 $d_i$，请构造一棵树 $T$，并最小化 $T$ 的直径。

## Solution
构造思路：确定一个**度数最大**的点为 $T$ 的根，再用其他度数大于 $1$ 的点与之相连，同时使每个子节点**深度尽量平均**，最后再把叶子节点补上即可。

### Proof
- 显然一棵树的直径两端必然是叶子节点（即度数为 $1$）。
- 记通过上述思路构造出来的树的叶子节点的平均深度为 $P$，则所有叶子节点的深度为 $\lfloor P\rfloor$ 或 $\lfloor P\rfloor+1$。
- 由于 $2\times\left[\left(\lfloor P\rfloor+1\right)-1\right]\lt\lfloor P\rfloor+(\lfloor P\rfloor+1)$，则直径必过根节点。
- 若子节点数是分子（即 $n-1$），根的度数为分母，则分母越大，均摊到根的每条边的节点数就越少，从而使得所有节点的平均深度越小（或 $P$ 越小），因此树的直径越小。

代码时间复杂度 $\mathcal O(\sum n)$。

## Code
```cpp
#include <iostream>
using namespace std;
const int N = 200005;
int t, n, head[N], nex[N], used[N];
int read(){
	int x = 0;
	char a = getchar();
	while(a < '0' || '9' < a) a = getchar();
	while('0' <= a && a <= '9') x = (x << 1) + (x << 3) + (a ^ 48), a = getchar();
	return x;
}
void write(int x){
	if(x > 9) write(x / 10);
	putchar(x % 10 | 48);
}
int main(){
	t = read();
	while(t --){
		n = read();
		for(int i = 1; i <= n; ++ i){
			int d = read();
			nex[i] = head[d];
			head[d] = i; //度数为i的节点组成的链的链头
			used[i] = 0;
		}
		for(int i = n - 1, j = 0, x = 0; i >= 1; -- i)
			while(head[i]){
				if(!j) j = i, x = nex[head[i]];
				while(used[head[i]] < i)
					if(used[x] == j) x = nex[x];
					else if(x){
						write(head[i]), putchar(' '), write(x), putchar('\n');
						++ used[head[i]], ++ used[x], x = nex[x];
					}
					else x = head[-- j];
				head[i] = nex[head[i]];
			}
	}
	return 0;
}
```

---

## 作者：fish_love_cat (赞：2)

注意到**最优**树的直径是一棵树中最深的点和第二深的点的深度和。

**解释：**

我们不妨设树根为 $r$ 且树上存在点 $a$ 和点 $b$ 两个点，并满足 $a$ 和 $b$ 不是同一个点且不是树根。

假设从 $a$ 到 $b$ 的路径经过 $r$，且其中点 $a$ 有儿子节点点 $c$。可以发现，$c$ 到 $b$ 的距离一定大于 $a$ 到 $b$ 的距离。

假设从 $a$ 到 $b$ 的路径不经过 $r$，且其中点 $a$ 是点 $b$ 的儿子。可以发现，$a$ 到 $r$ 的距离一定大于 $a$ 到 $b$ 的距离。假设还有一点 $c$ 在树上且从 $a$ 到 $c$ 的路径经过 $r$，那么 $a$ 到 $r$ 的距离会小于 $a$ 到 $c$ 的距离。

假设从 $a$ 到 $b$ 的路径不经过 $r$，且其中点 $c$ 是 $a$ 和 $b$ 的最近公共祖先，而且 $a$ 与 $b$ 都是叶节点。可以发现，此时若 $a$ 到 $b$ 的距离是树的直径，那么这个直径**可能**不是最优的。我们让 $r$ 度数尽可能的大，然后让以 $c$ 为根节点的子树中的节点不断接到其他分支上。**一直接下去，直径可能会变小，但绝对不会变大**，直到直径重新经过 $r$。此时又变为了上面的情况。

综上可以得出，**最优**树的直径是一棵树中最深的点和第二深的点的深度和。

---

根据上面的理论，为了使直径更小，我们应令最大深度最小化。

而且上面也要求构造深度低的点度数需要尽量多，而且这会使更多的点的深度尽量低，使树的深度更低，让直径更优。

因为每个点都接在当前深度最低的叶节点上，所以这么构造出来的树的叶节点深度差最大不超过 $1$。那么对于这棵树直径两端的叶节点，根即为这条直径的中点。

所以我们可以让点按度数降序排序，第一个最大的作为根节点。注意除了根节点都有一边连向父亲，在连儿子时记得减掉。

然后跑一个 BFS 构造就行了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct fish{
    int x,id;
}a[200005];
bool cmp(fish x,fish y){
    return x.x>y.x;
}
int n;
void bfs(){
    queue<fish>q;
    int top=1;
    q.push(a[top++]);
    while(top<=n){
        fish cat=q.front();
        q.pop();
        for(int i=1;i<=cat.x;i++){
            cout<<cat.id<<' '<<a[top].id<<'\n';
            q.push(a[top++]);
        }
    }
}
int main(){
    int t;
    cin>>t;
    while(t--){
        cin>>n;
        for(int i=1;i<=n;i++)
        cin>>a[i].x,a[i].id=i;
        sort(a+1,a+1+n,cmp);
        for(int i=2;i<=n;i++)
        a[i].x--;
        bfs();
    }
    return 0;
}
// 第六版
// /kk
```

---

感谢 irris 和 sevenki 的修改意见。

---

## 作者：gghack_Nythix (赞：1)

### 前言:

[题目传送门](https://www.luogu.com.cn/problem/P10678)

### 分析:

看完题目之后容易想到一种构造方法：将 $d_i$ 以降序排列，每次选择一个他前面还没有被使用的点连接一条树边，最后答案一定最小。

如何证明？

考虑以下两种情况:

- 当 $diam(T)$ 中所有的节点全部不经过整棵树的根时，而是经过某个子树的根时:


设该子树的根是 $R$，按照上述构造方法，在除了菊花图与完美二叉树外的最理想情况下（也就是完全二叉树），他的 $diam(T)$ 是 $dep+dep-1=2dep-1$。其中 $dep$ 是从 $R$ 出发的最大深度。用类似的方法可以知道在一般情况下 $\min_{diam(T)}$ 是 $2dep-x$。其中 $x$ 作为一个不确定的量。但是根据上面的方法，我们可以发现：构造出来的这一颗树实际上是可以看成按照类似 BFS 的顺序一个个加点的，所以说这棵树实际上最深与次深的点的深度差为 $1$。如果深度差大于 $1$，我们可以将新增后度数最大的节点旋转至根，或者是将他往上移动，使得他满足上文构造方法所刻画出来的树形态。依次，上文的 $x$ 最次就是 $1$。

这时候我们发现：如果最次都只能是 $1$。那么这棵树的直径一定经过树根。因为我们可以进行一次上述构造，使得深度差不符合要求的节点换位排列（和上文方法类似）。

那么现在，想要求得 $\min_{diam(T)}$ 也就相当于求得 $\min_{dep+dep'}$。$dep$ 和 $dep'$ 分别是最深和次深。

注意到菊花图形态下的树深度为 $1$，因此我们应该尽量构造菊花图，同时使得菊花图的个数最少，也就是让每一个菊花尽量大，换句话说，就是让一个节点尽量连多个节点。

然后你会发现就是上面的构造方法，所以就可以写代码了。

时间复杂度 $O(\sum{n \log n})$。

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int id,val;
	bool operator < (const node & hh) const {
		return val > hh.val;
	}
}q[200005];
vector<int>g[200005];
void solve(){
	int n;
	cin >> n;
	for(int i = 1;i <= n;++i) g[i].clear(),q[i].val = q[i].id = 0;
	for(int i = 1;i <= n;++i) cin >> q[i].val,q[i].id = i;
	sort(q + 1,q + n + 1);
	int p = 2;
	for(int i = 1;i <= n;){
#define pb push_back
		while(q[i].val != 0 && p <= n) {
			g[q[i].id].pb(q[p++].id);
			q[i].val--;
			q[p - 1].val--;
		}
		if(p > n) goto Penguly_is_the_best_pvper;
		++i;
	}
	Penguly_is_the_best_pvper:;
	int trst = 0;
	for(int now = 1;now <= n;++now) for(auto x : g[now])  {cout << now << " " << x << '\n';++trst;}
	return ;
}
signed main(){
	int T;
	cin >> T;
	while(T-->0)solve();
}
```

---

## 作者：Magallan_forever (赞：0)

题目要求：共 $ T $ 次询问，每次给出 $ n $ 个点及其度数，构造任意一颗该条件下直径最小的树。

不难理解构造时要尽力减小树的深度，猜得到应该让树有更多分支。

如果在靠近根节点的位置用度数低的点进行连接，和用度数更高的点相比，会导致更多的点被挤到离根节点更远的位置，树的深度不会减少（并且整棵树的深度和一定会增加，虽然跟这个题没关系），**因此以度数从大到小排序并依次连接是最优构造方案**。

上面是用于理解的部分，以下是证明：

首先这种构造填充较为均匀，最大深度节点和（并列）第二大深度节点的连线一定可以过根节点，**即在这种构造下根节点一定在直径上**。

其次**任何一个点的度数不小于深度大于其的点的度数**

如果将构造过程等效为从根节点开始逐层以度数从高到低的顺序添加节点，~~注意到~~**以任何一个点为根节点的子树的最大深度，不小于以深度大于其的任何一个点为根节点的子树的最大深度**

（以下将`编号为i的节点`统称为`节点i`）

假设根节点的子节点数为 $ 2 $，那么任意交换不会改变结果（这棵树最大度数是 $ 2 $，相当于一条链）。

假设根节点的子节点数多于 $ 2 $，现在将以 $ i $ 点为根节点的子树与以 $ j $ 点为根节点的子树交换（$ j $ 在 $ i $ 下方，并且 $ \operatorname{lca}(i,j)=r $，因为如果 $ \operatorname{lca}(i,j) \ne r $，这个交换不会改变结果）。

如果这两个点分别在最长链和次长链上，结果不会出现变化。

在其他情况下，这个交换不会使最大深度减少，同理次大深度也不会减少（因为如果把最长链删了，次长链就是最长链）。

**所以靠近根节点的位置应该用度数更高的点进行连接，同理根节点应该是度数最高的点（之一）**，达到尽可能增加分支的要求，算是一道贪心题目。

复杂度就是排序的 $ N \log_2N (N=\sum n) $。

代码上还是有一些细节需要多注意。

我已经 AFO 4 年了，刚刚高考完，正在复习自己学的信息竞赛知识，水平不算很高~~还是 C++98 老登~~，如果有纰漏希望可以喷的轻一点（
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int fr(){//TLE了，所以用了一点快读，但实际上是后面的一个地方可以优化
	int cnt=0,temp=getchar();
	while(temp=='\n'||temp=='\r'||temp==' ') temp=getchar();
	while(temp!='\n'&&temp!='\r'&&temp!=' '/*&&temp!=EOF*/) cnt=((cnt<<3)+(cnt<<1))+temp-'0',temp=getchar();
	return cnt;
}
struct node{
	int cnt,index;//cnt是一个点的剩余度数
	node(int c=0,int id=0): cnt(c),index(id) {}
}edge[200001];
const bool operator<(const node& a,const node& b){
	return a.cnt>b.cnt;
}//便于度数排序
int n;
bool mark[200001];//标记某个节点是否已经被加入这棵树
void bfs(){//这个不断从根节点出发构造树的方式比较像bfs，但我并没有用队列求解
	for(int i=1;i<=n;++i) mark[i]=false;//太久没写了，忘了这里可以fill(mark+1,mark+1+n,false)
	sort(edge+1,edge+1+n),mark[edge[1].index]=true;//度数最大的节点是根节点，可以直接用edge的下标而不是变量的index标记mark，这里是方便我查错
	for(int i=1,temp=2;i<=n;++i,temp=(temp<=i?i+1:temp))/*temp记录已经把边全部连完的点，优化时间复杂度*/
      for(int j=temp;edge[i].cnt;++j)
      	if(!(mark[edge[i].index]&&mark[edge[j].index]))/*如果两个点至少有一个不在树里，连边(实际上前一个点必定在树内)*/
        	--edge[i].cnt,--edge[j].cnt,/*更新可连边的数量*/
            printf("%d %d\n",edge[i].index,edge[j].index),mark[edge[i].index]=mark[edge[j].index]=true,
            temp=edge[j].cnt?temp:j+1/*如果j这个位置已经连完了，后续点就可以从j的后面开始*/;
}
int main(){
	int T;
	T=fr();//之前写的是scanf，所以忘了改成int T=fr();
	while(T--){
		n=fr();
		for(int i=1;i<=n;++i) edge[i].cnt=fr(),edge[i].index=i;
		bfs();
	}
	return 0;
}
```

---


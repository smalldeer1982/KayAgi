# 檐牙覆雪

## 题目背景

“雨打在窗沿，下坠，一级一级。”

但这次是雪啦！天依与阿绫靠在窗边，赏着乍到的飞雪。

## 题目描述

还是熟悉的地方：一共有 $n$ 级窗沿，从高到低编号，最高层编号为 $1$，最底层编号为 $n$。天依注意到，每一级窗沿上的积雪都可以看作包含若干雪团的可重集合，一开始，第 $1$ 级窗沿上有一团体积为 $1$ 的雪，其他窗沿上没有任何积雪。忽然，一阵夹杂着雪的风刮过，片刻间积雪产生了 $n$ 次变换——

第 $i$ 次变换中，第 $i$ 级窗沿上的**每一团**雪都会被卷起，由于奇妙的物理原因，所有编号是 $i$ 的整数倍（**不包括** $i$ 自身）的窗沿都会接收到新的积雪。具体地，设一团被卷起的雪体积为 $V$，则在上述窗沿中，编号最大者会得到一团体积为 $V+1$ 的积雪，次大者会得到一团体积为 $V+2$ 的积雪，以此类推。最后，被卷起的雪团神奇地回到第 $i$ 级窗沿，也就是说本次变换后，第 $i$ 级窗沿上的积雪没有任何变化。

阿绫知道天依正在好奇：$n$ 次变换之后，每级窗沿上**体积最大的一团**雪的总体积是多少呢？既然她们正静静赏雪，就由你来回答这个问题叭！

## 说明/提示

**样例解释**

$n=5$ 时的终态如下：

第 $1$ 级窗沿上有体积为 $1$ 的雪团；  
第 $2$ 级窗沿上有体积为 $5$ 的雪团；  
第 $3$ 级窗沿上有体积为 $4$ 的雪团；  
第 $4$ 级窗沿上有体积为 $3,6$ 的雪团；  
第 $5$ 级窗沿上有体积为 $2$ 的雪团；  

体积最大值之和为 $1+5+4+6+2=18$。

### 数据规模与约定

**本题采用捆绑测试。** 仅当你通过了该子任务的全部测试数据才能获得该子任务的分值。

对于 $100\%$ 的数据，$1\le T\le5\times10^5$，$1\le n\le2\times10^6$。

对于不同的子任务，作如下约定：

| 子任务编号 | $T$ | $n$ | 子任务分值 |
| :---: | :---: | :---: | :---: |
| 1 | $\leq 100$ | $\leq 3\times10^4$ | $15$ |
| 2 | $\leq 100$ | $\leq 2\times10^6$ | $35$ |
| 3 | $\leq 3\times10^4$ | $\leq 3\times10^4$ | $15$ |
| 4 | $\leq 2\times10^5$ | $\leq 2\times10^5$ | $15$ |
| 5 | $\leq 5\times10^5$ | $\leq 2\times 10^6$ | $20$ |

## 样例 #1

### 输入

```
5
1
5
3
114514
2000000```

### 输出

```
1
18
6
18057023450
5575638612615```

# 题解

## 作者：sbno333 (赞：23)

很玄乎的题。

考虑暴力就是直接枚举，调和级数做到 $O(Tn\log n)$。

这没啥前途，硬做是做不了的，找找性质。

我们尝试思考这个最大值是由谁转移来的？

我们不妨换一个转移方式，我们对于第 $i$ 层，考虑最大雪堆只有可能从它的因子（不包括它自己）而来。

这个因子可能是谁呢？

我们考虑如果存在 $j,k$，使得 $j\not=k$，并且 $i$ 是 $j$ 的倍数，$j$ 是 $k$ 的倍数，显然有 $i$ 是 $k$ 的倍数。

我们发现这时候不可能由 $k$ 转移而来，因为 $k$ 转移以后 $j$ 得到的一定比 $i$ 多，然后 $j$ 还可以加点给 $i$，于是不优，所以得证。

这时候我们发现这个性质很强了，能够让因子只有为数不多的几个 $i$ 除以它的每一种质因子得到的结果。

我们既然想到了质数，我们可以先想想质数的情况，发现显然由 $1$ 转移来的。

而其它数呢？先从两个质数乘积尝试，发现我们更愿意让它由比较小的质数转移，因为它自己就多，然后多加的也多。

我们不妨猜测所有数都是除以的最大质因子得到的因子转移而来。

其实也容易证明，首先这个数本身小，多给的效益高。

其次我们也能看出来这个尽量小的数其实前途也很好，它比别的数转移的时候找的数总能小点，效益大点，于是它本身效益其实也是大的。

于是我们知道咋转移了。

欧拉筛维护最大质因子，最小质因子。

我们可以去掉 $\log n$。

做到 $O(Tn)$。

大抵上是有 $50$ 分的，这也启示我们离正解走了一半了。

发现性质没啥挖掘空间了，考虑从代码层面入手。

我们是 $dp_i=dp_{\frac{i}{p_i}}+1-p_i+\frac{n}{\frac{i}{p_i}}$。

其中 $p_i$ 表示 $i$ 最大的质因子。

我们只想知道 $dp_i$ 的和。

我们可以对于每一项都考虑出现了几次。

先从简单的 $1-p_i$ 入手，我们如果转移的时候不加上这个，我们最后要加上 $ans_n$，我们怎么维护 $ans_n$。

枚举 $i$，然后这个 $i$ 贡献的 $1-p_i$，在 $dp_{i\times j}$ 中被统计到当且尽当 $i\times j$ 能去掉几次最大质数变成 $i$，也就是 $j$ 的最小质数不小于 $i$ 的最大质数。

所以调和级数就行，枚举 $j$，找到一个 $j$ 在 $ans_{i\times j}$ 上统计一次，最后跑一下前缀和即可。

然后我们考虑 $\frac{n}{\frac{i}{p_i}}$ 这个复杂的东西。

我们首先需要对 $\frac{i}{p_i}$ 进行调和级数，我们不能枚举 $i$，然后调 $\frac{i}{p_i}$，容易证明会超时。

所以我们枚举 $\frac{i}{p_i}$，然后类似的方法，但是我们要记录几个用到了它，以及它实时的值，最后跑前缀和。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define N 2000000
bool vis[N+9];
int q[N/10+9];
int inn;
int ap[N+9];
int ip[N+9];
int as[N+9];
int an[N+9];
int query(int n){
	return an[n]+n;
}
signed main(){
	ap[1]=ip[1]=1;
	vis[1]=1;
	for(int i=2;i<=N;i++){
		if(!vis[i]){
			q[++inn]=i;
			ap[i]=i,ip[i]=i;
		}
		for(int j=1;j<=inn&&q[j]*i<=N;j++){
			vis[q[j]*i]=1;
			ap[q[j]*i]=ap[i];
			ip[q[j]*i]=q[j];
			if(i%q[j]==0){
				break;
			}
		}
	}
	for(int i=2;i<=N;i++){
		an[i]+=1-ap[i];
		for(int j=2;i*j<=N;j++){
			if(ip[j]>=ap[i]){
				an[i*j]+=1-ap[i];
			}
		}
	}
	for(int i=1;i<=N;i++){
		int cc;
		cc=0;
		for(int j=2;i*j<=N;j++){
			an[i*j]+=cc;
			if(ip[j]>=ap[i]){
				an[i*j]+=j;
				cc++;
			}
		}
	}
	for(int i=2;i<=N;i++){
		an[i]+=an[i-1];
	}
	int t;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		cout<<query(n)<<endl;
	}
	return 0;
}
```

---

## 作者：E_firework (赞：6)

### 简要题意

有一个长为 $n$ 的序列 $a$。一开始 $a_1=1$，$a_i=0(i\ne1)$。对序列进行 $n$ 次操作，第 $i$ 次操作时，对每一个不超过 $n$ 且大于 $i$ 的 $i$ 的倍数 $j$，设 $j$ 为这样的数中第 $k$ 大的数，将 $a_j$ 更新为 $a_j$ 与 $a_i+k$ 的最大值。求出 $n$ 次操作后 $a$ 序列中元素和。多组询问。

### 算法一


我们知道在 $1\sim n$ 中，$i\cdot j$ 是 $i$ 的第 $\left\lfloor\frac{n}{i}\right\rfloor-j + 1$ 大的倍数。每次操作时直接枚举 $i$ 的倍数模拟。

时间复杂度为调和级数的 $O(\sum n\log n)$。

期望得分：$15$。

### 算法二

我们需要发掘一些性质。

首先，$a_i$ 的最大值一定是由 $a_{\frac{i}{p}}$ 转移来的，其中 $p$ 是 $i$ 的一个质因子。因为如果有三个数 $i,j,k$ 满足 $k<j<i,k|j|i$，从 $k$ 转移到 $i$ 的结果 $a_k+\lfloor\frac{n}{k}\rfloor-\frac{i}{k} + 1$ 一定小于从 $k$ 先转移 $j$ 到再转移到 $i$ 的结果 $a_k+\lfloor\frac{n}{k}\rfloor-\frac{j}{k}+1+\lfloor\frac{n}{j}\rfloor-\frac{i}{j}+1$。所以如果 $a_i$ 的最大值是由 $a_k$ 转移来的，那么一定不存在一个数 $j$ 使得 $k<j<i,k|j|i$，也就是说 $\frac{i}{k}$ 一定是一个质数。

更进一步的，$a_i$ 的最大值一定是由 $a_{\frac{i}{mp_i}}$ 转移来的，其中 $mp_i$ 表示 $i$ 的最大质因子。证明如下：

让我们考虑 $i$ 如何转移到 $i\cdot p_a\cdot p_b$ 才是最优的，其中 $p_a,p_b$ 是两个不等的质数且 $p_a<p_b$。从 $i$ 先转移到 $i\cdot p_a$ 再转移到 $i\cdot p_a\cdot p_b$ 的结果是 $a_i+\lfloor\frac{n}{i}\rfloor-p_a+1+\lfloor\frac{n}{i\cdot p_a}\rfloor-p_b+1$；从 $i$ 先转移到 $i\cdot p_b$ 再转移到 $i\cdot p_a\cdot p_b$ 的结果是 $a_i+\lfloor\frac{n}{i}\rfloor-p_b+1+\lfloor\frac{n}{i\cdot p_b}\rfloor-p_a+1$。消掉相同项之后两式分别剩下 $\lfloor\frac{n}{i\cdot p_a}\rfloor$ 和 $\lfloor\frac{n}{i\cdot p_b}\rfloor$，可以发现前者一定大于后者。所以从 $1$ 到 $i$ 的转移路径上每次乘上的质因数一定是递增的。所以 $a_i$ 的最大值一定是由 $a_{\frac{i}{mp_i}}$ 转移来的。

于是我们先预处理 $mp_i$，再从 $2$ 到 $n$ 依次计算每一个 $a_i$。

时间复杂度为 $O(\sum n)$。

期望得分：$50$。

### 算法三

我们发现从 $\frac{i}{mp_i}$ 到 $i$ 的转移可以形成一棵树。考虑如果 $n$ 增加了 $1$，答案将会如何变化。首先树上会增加一个叶子，算出这个叶子的答案只需要遍历一遍到根的路径。然后对于那些 $\lfloor\frac{n}{i}\rfloor$ 增加了 $1$ 的 $i$，$i$ 的子树中除了 $i$ 的节点 $j$ 的答案都会增加 $1$，答案总共增加以 $i$ 为根的子树大小减 $1$。增加一个叶子后子树大小的变化也是好维护的。

于是我们从 $1$ 到可能的最大值枚举 $n$，按照上述做法预处理出所有的答案，询问时直接查表。

因为这颗树的树高是 $O(\log n)$ 的，而 $\lfloor\frac{n}{i}\rfloor$ 总共也只会变化 $O(n\log n)$ 次，所以这个做法的时间复杂度为 $O(n\log n+T)$。

期望得分：$100$。

---

## 作者：woshishabi11451444 (赞：6)

考虑对于每一个 $n$，设 $s_i$ 表示在 $i$ 级窗口的最大学的体积值。

根据题意：

$$s_{i} = \max \limits_{j 整除 i} s_j + \lfloor \frac{n}{j} \rfloor - \lfloor \frac{i}{j} \rfloor + 1$$

首先第一个性质：若 $j$ 整除 $i$，则必然有 $s_i \ge s_j$。

接着，考虑若 $s_j$ 将它的值转移给 $s_k$ 且 $i$ 是 $j$ 的因子，显然此时不需要将 $s_i$ 转移给 $s_k$。

所以对于每一个 $s_i$，他的最优化转移一定是 $i$ 除以他的某个质因子。

考虑观察 $n = 10$ 的情况：

其中 $s_2, s_3, s_5, s_7$ 的最优化转移为 $s_1$，$s_4, s_6, s_{10}$ 的最优化转移为 $s_2$，$s_8$ 的最优化转移为 $s_4$，$s_9$ 的最优化转移为 $s_3$。

令 $p_i$ 表示将 $i$ 质因数分解后，最大的质数。

此时通过观察和推理得到，$s_i$ 的最优化转移一定是 $s_{\frac{i}{p_i}}$。

考虑预处理答案。

对于每次加入元素 $n$，那么只有当编号为 $n$ 的因子的窗口进行操作才会和只有 $n - 1$ 个元素时的状态不同。

那么若让 $i$ 连向 $\frac{i}{p_i}$ 连一条边，此时加入元素 $n$ 的操作可以看作是给编号为 $n$ 的因子的子树全体加一，为了方便处理，新加入的元素我们直接暴力算 $s_n$，这样并不影响时间复杂度。

接着由于枚举因子不好实现，考虑枚举倍数，那么相当于固定住了要进行加一操作的子树，而相应的因为树高只有 $O(\log_n)$ 级别，所以在枚举倍数时可以暴力算出当前有多少个点在要进行加一操作的子树内，然后统计答案。

注意这样算出来的结果相当于是对答案数组做了一个差分，记得最后还得对这个答案数组前缀和。

时间复杂度：$O(n \log_{2} n \times \log_{2} n)$。

空间复杂度：$O(n)$。

由于常数较小并且树高跑不满，所以可以通过此题。

代码入下：

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 2e6 + 5;

int T, n, id, p[N], siz[N];
long long ans[N];

long long get(int x, int n){
	if(x == 1) return 1;
	return get(p[x], n) + n / p[x] - x / p[x] + 1;
}

void init(int n){
	p[1] = 0;
	for(int i = 2; i <= n; i++){
		if(!p[i]){
			p[i] = i;
			for(int j = (i << 1); j <= n; j += i) p[j] = max(p[j], i);
		}
	}
	for(int i = 2; i <= n; i++){
		p[i] = i / p[i];
	}
  for(int i = 1; i <= n; i++){
    int sum = 1;
		for(int j = (i << 1); j <= n; j += i){
      if(sum > 1) ans[j] += sum - 1;
      for(int k = j; k; k = p[k]){
        if(k == i) sum++;
      }
		}
	}
	siz[1] = 1;
	for(int i = 2; i <= n; i++){
    ans[i] += ans[i - 1];
		ans[i] += get(i, i);
	}
}

int main(){
	ios::sync_with_stdio(0), cin.tie(0);
	init(N - 5);
	cout << p[8] << '\n';
	cin >> T;
	while(T--){
		cin >> n;
		cout << ans[n] + 1 << '\n';
	}
	return 0;
}

```

---

## 作者：CQ_Bab (赞：4)

# 前言

大力卡常题（当然仅限我这种煞笔的做法）。

# 思路

## 15pts

首先考虑暴力，你会发现对于一个数 $i$ 的集合只有最大的那个有用，那么我们定义 $f_i$ 为第 $i$ 个的最大值，那么直接转移即可。

代码很简单。

```cpp
  int n;
	in(n);
	rep(i,1,n) f[i]=0;
	f[1]=1;
	int s=0;
	rep(i,1,n) {
		int cnt=n/i;
		rep(j,2,n/i) {
			f[i*j]=max(f[i*j],f[i]+cnt-j+1);
		}
		s+=f[i];
	}
	cout<<s<<endl;
```

时间复杂度 $O(Tn\ln n)$。

## 50pts

有了这个之后你打一个表可以发现 $i$ 一定是由 $i$ 除以最大质因子转移过来，那么便可以预处理 $i\div Max_i$ 即可，其中 $Max_i$ 表示最大质因子。

代码很少。

```
  int n;
	in(n);
	f[1]=1;
	ll s=0;
	rep(i,2,n) {
		int j=mx[i];
		f[i]=f[j]+(n/j)-(i/j)+1;
		s+=f[i];
	}
	printf("%lld\n",s+1);
```

## 100pts

考虑从 $i\to i+1$ 的变化，当然会有 $i+1$ 的值还有你会发现转移时只有 $\frac{j}{n}$ 会变，而 $j$ 只能去 $i+1$ 的因数，对于每一个因数我们发现会变的值的点为从 $x$ 转移到的点又继续向外递归能到的点的数量，我们发现如果 $i$ 想 $mx_i$ 连边会构成一棵树，而树高不超过 $\log(n)$ 所以对于答案的贡献为 $siz_x$ 然后我们加入一个 $i+1$ 时只用暴力跳链修改 $siz$ 即可。

# 代码

```cpp
#include <bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#include <ext/rope>
using namespace __gnu_pbds;
using namespace std;
#define pb push_back
#define rep(i,x,y) for(register int i=x;i<=y;++i)
#define ll long long
#define fire signed
#define il inline
il void print(ll x) {
	if (x > 9) print(x / 10);
	putchar(x % 10 ^ 48);
}
namespace FastIO {
#include<sys/mman.h>
inline static const char *_read_ptr = (const char *)mmap(nullptr, 0x7fffffff, 1, 2, 0, 0);
#define getchar() (*_read_ptr++)
inline void read(int &x) {
   static char ch; x=0;
   while(!isdigit(ch=getchar())) ; 
   for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch&0xf);
}
} using FastIO::read;
int T=1;
const int N=2e6+10;
ll g[N];
int mx[N];
int fa[N],siz[N];
int vlen[N];
int bg[N],ed[N],pl[N];
int vve[N*15];
il int dfs(int x,int n) {
	return (x==1)?1:dfs(fa[x],n)+(n/fa[x])-(x/fa[x])+1;
}
fire main() {
	read(T);
	static int query[N];
	int MMM=0;
	rep(i,1,T) read(query[i]),MMM=max(MMM,query[i]);
	int Max=MMM;
	rep(i,2,Max) if(!mx[i]) {
		mx[i]=1;
		rep(j,2,Max/i) mx[j*i]=j;
	}
	rep(i,1,Max/2)
		rep(j,2,Max/i)
			++vlen[j*i];
	rep(i,2,Max) ed[i]=bg[i]=bg[i-1]+vlen[i-1];
	ll res=1;
	g[1]=1;
	siz[1]=0;
	rep(j,2,Max) vve[ed[j]++]=1;
	rep(i,2,Max){
		rep(j,2,Max/i)
			vve[ed[j*i]++]=i;
		rep(j,bg[i],ed[i]-1) {
			res+=siz[vve[j]];
		}
		fa[i]=mx[i];
		int now=fa[i];
		while(now) {
			siz[now]++;
			now=fa[now];
		}
		int pl=dfs(i,i);
		res+=pl;
		g[i]=res;
	}
	for(register int i=1;i<=T;i++) print(g[query[i]]),putchar('\n');
	return false;
}
```

---

## 作者：chenwenmo (赞：3)

[P11770 檐牙覆雪](https://www.luogu.com.cn/problem/P11770)

PS：自己想到的做法，记录一下 QwQ。

### 题目描述

一共有 $n$ 级窗沿，从高到低编号，最高层编号为 $1$，最底层编号为 $n$。每一级窗沿上的积雪都可以看作包含若干雪团的可重集合，一开始，第 $1$ 级窗沿上有一团体积为 $1$ 的雪，其他窗沿上没有任何积雪。积雪产生了 $n$ 次变换。

第 $i$ 次变换中，第 $i$ 级窗沿上的**每一团**雪都会被卷起，所有编号是 $i$ 的整数倍（**不包括** $i$ 自身）的窗沿都会接收到新的积雪。具体地，设一团被卷起的雪体积为 $V$，则在上述窗沿中，编号最大者会得到一团体积为 $V+1$ 的积雪，次大者会得到一团体积为 $V+2$ 的积雪，以此类推。最后，被卷起的雪团回到第 $i$ 级窗沿，也就是说本次变换后，第 $i$ 级窗沿上的积雪没有任何变化。

求出 $n$ 次变换之后，每级窗沿上**体积最大的一团**雪的总体积是多少。

$1\le T\le5\times10^5$，$1\le n\le2\times10^6$。

### 题解

首先，$i$ 的最大堆一定是由它的某个约数 $j$ 的**最大堆**产生的。这是显然的，因为 $j$ 的所有堆都是加上一个**相同的量**贡献给 $i$。

设 $f(i)$ 表示最后 $i$ 的最大堆有多少单位雪，转移有，$f(i) = \max\limits_{j\mid i}\{f(j) + \lfloor\frac{n}{j}\rfloor - \frac{i}{j}+1\}$。就是 $i$ 的某个约数 $j$ 的最大堆，加上 $i$ 是 $j$ 的 $n$ 以内的倒数（shu，第三声）第几个倍数。

然后直接转移是 $O(Tn\log n)$ 的。

然后我赛时通过打表发现，对于任意 $i$ 的转移点 $j$，是和 $n$ 无关的，也就是不变的。

> 证明：
> 
> 考虑有 $i<j<k$ 满足 $i\mid j$ 且 $j\mid k$，因为 $i$ 的所有约数提供给它的雪，肯定也会提供给 $j$，因此 $f(j)>f(i)$，所以 $f(k)$ 肯定由 $f(j)$ 转移。
> 
> 那么这时候就有 $f(i)=\max\limits_{p\mid i,p\in prime} f(\frac{i}{p}) + \lfloor\frac{n}{\frac{i}{p}}\rfloor - p+1$。
>
> 由于 $p$ 是质数，因此无论 $f(i)$ 当前选择了哪个 $p$，后面那部分 $-p+1$ 肯定会以 $\sum\limits_{p\mid i,p\in prime} -p+1$ 的形式累加到 $f(i)$ 中。
>
> 那么现在就要求 $\lfloor\frac{n}{\frac{i}{p}}\rfloor$ 最大，显然 $p$ 取 $i$ 的最大质因子即可。
>
> 因此所有 $f(i)$ 的转移点为 $i$ 除以其最大质因子。

于是我们可以预处理出所有转移点，即可做到 $O(Tn)$。

将 $i$ 的转移点记为 $p_i$，$f(i)=f(p_i)+\lfloor\frac{n}{p_i}\rfloor - \frac{i}{p_i}+1$，我们每次都要重新算一遍，就是因为转移方程里有一个 $\lfloor\frac{n}{p_i}\rfloor$。

能不能直接把转移方程变为 $f(i)=f(p_i)- \frac{i}{p_i}+1$，预处理出 $sum_n=\sum\limits_{i=1}^{n}f(i)$，然后对于每个 $n$ 直接计算多出来的 $\lfloor\frac{n}{p_i}\rfloor$ 的总贡献呢？

如果我们从 $p_i$ 到 $i$ 连一条有向边，那么整个图就构成一棵以 $1$ 为根的内向树。那么容易发现，对于 $n$，总答案会在 $sum_n$ 的基础上，增加 $\sum\limits_{i=1}^{n} h_i \times \frac{n}{i}$，其中 $h_i=siz_i-1$，$siz$ 是子树大小。

也就是对于每个 $n$，答案是 $sum_n + \sum\limits_{i=1}^{n} h_i \times \frac{n}{i}$，

但是注意，上面说到的那棵内向树，只能是由 $\le n$ 的点构成的，也就是我们还是有 $n$ 这个限制。

变换一下，$\sum\limits_{i=1}^{n} h_i \times \frac{n}{i} = \sum\limits_{i=1}^{n}\sum\limits_{j\mid i} h_j$，

如果我们已经计算出了 $n-1$ 的答案，考虑在 $n$ 的时候，我们可以不断从 $n$ 跳 $p_n$，然后把除了 $n$ 以外，路径上的所有 $h_i$ 都加 $1$。由于跳的次数为 $O(\log n)$，那么这样就可以维护所有 $h_i$。

然后我们要算的是 $\sum\limits_{i=1}^{n}\sum\limits_{j\mid i} h_j$ 这个式子在 $n-1\to n$ 时的增量，这个增量分为两部分。
  - 对于上面说到的加了 $1$ 的 $h_i$，增量会增加 $\lfloor\frac{n-1}{i}\rfloor$，这里 $n-1$ 是为了避免和下面的情况重复计算。

  - 然后增量还会增加 $\sum\limits_{j\mid n}h_j$。这里必须在 $O(约数个数)$ 的时间内遍历 $n$ 的所有约数，可以分解质因数，然后 DFS 枚举。

还要记得更新 $sum$，$sum_n = sum_{n-1} + f(n)$，（这里 $f$ 的转移方程是改变之后的）。

最后可以离线处理，也可以算出所有 $n$ 的答案然后 $O(1)$ 查询。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
using ULL = unsigned long long;
using PII = pair<int, int>;

const int N = 2e6 + 5;

int n, pre[N];
int prime[N], vis[N], cnt;
LL f[N], h[N], ans[N], sum;
vector<PII> rec;

struct Query { int n, id; } Q[N];

// 枚举 x 的约数
void dfs(int x, int div, int idx) {
    if (idx == rec.size()) {
        sum += h[div];
        return;
    }
    int p = 1;
    for (int i = 0; i <= rec[idx].second; i++) {
        dfs(x, div * p, idx + 1);
        p *= rec[idx].first;
    }
}

void work(int x) {
    sum += f[x];
    int cur = x;
    while (pre[cur]) {
        cur = pre[cur];
        h[cur]++;
        sum += (x - 1) / cur;
    }
    rec.clear();
    while (x > 1) { // 质因数分解
        if (rec.empty() || vis[x] != rec.back().first) {
            rec.push_back({vis[x], 1});
        } else {
            rec[rec.size() - 1].second++;
        }
        x /= vis[x];
    }
    dfs(x, 1, 0);
}

int main() {
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);

    n = 2e6;

    for (int i = 2; i <= n; i++) {
        if (!vis[i]) {
            vis[i] = i;
            prime[++cnt] = i;
        }
        for (int j = 1; j <= cnt && prime[j] <= n / i; j++) {
            vis[prime[j] * i] = prime[j];
            if (i % prime[j] == 0) break;
        }
    }

    f[1] = 1;
    for (int i = 1; i <= n / 2; i++) {
        for (int j = i + i; j <= n; j += i) {
            LL now = f[i] + n / i - j / i + 1;
            if (now > f[j]) {
                f[j] = now;
                pre[j] = i;
            }
        }
    }
    
    // for (int i = 1; i <= 100; i++) {
    //     cout << i << ":" << pre[i] << '\n';
    // }
    // cout << '\n';

    f[1] = 1;
    for (int i = 2; i <= n; i++) f[i] = f[pre[i]] - i / pre[i] + 1;

    int T;
    cin >> T;
    for (int i = 1; i <= T; i++) {
        cin >> Q[i].n;
        Q[i].id = i;
    }
    sort(Q + 1, Q + 1 + T, [&] (auto a, auto b) { return a.n < b.n; });

    int lst = 1;
    sum = 1;
    for (int i = 1; i <= T; i++) {
        if (Q[i].n > lst) {
            for (int j = lst + 1; j <= Q[i].n; j++) work(j);
        }
        ans[Q[i].id] = sum;
        lst = Q[i].n;
    }

    for (int i = 1; i <= T; i++) cout << ans[i] << '\n';

    return 0;
}
```

---

## 作者：XYstarabyss (赞：2)

不得不说这一次洛谷月赛用心了，~~第一题就把我这样的蒟蒻打爆了。~~

# Solution 1

妈妈我会暴力！

时间复杂度 $O(Tn \log n)$，期望得分 $15 pts$。

# Solution 2

对于这道题，我们可以探索一下性质，这里我们以 $n=10$ 为例。

![](https://cdn.luogu.com.cn/upload/image_hosting/qwwwsbut.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/jd6gho47.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/58dxdl3c.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/d8cfp1n8.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/tjsos29l.png)

如图所示，对于编号为 $i$ 的窗沿，它最大的一坨积雪肯定是由它编号除以它编号的最大质因数转移的。

感性理解一下，首先考虑质数，在 $1$ 号的雪吹完之后，更小的质因数意味着基础数值 $V$ 更大，在相同的 $n$ 内可以吹到的窗沿更多，积雪也就越大。

然后，被这些质数吹到的合数肯定能获得较大 $V$ 的雪球，又可以贡献给它编号的倍数对应的窗沿。

由此对于编号为 $i$ 的窗沿，它的最大雪球应该是编号为 $\frac{i}{max_{p_i}}$ 的窗沿的最大雪球的 $V$ 加上 $1-max_{p_i}+\frac{n}{\frac{i}{max_{p_i}}}$，用欧拉筛把每一个数的最大质因数和最小质因数预处理，就可以去掉一只 $\log$，荣获 $50 pts$。

# Solution 3

我们发现这道题的性质已经挖掘得差不多了，那么有什么代码能够再优化一下时间复杂度呢？

有的，兄弟，有的。

因为我们答案只关注在一个 $n$ 下所有窗沿的最大 $V$ 雪球的体积和，而非在一个 $n$ 下单个窗沿的最大 $V$ 雪球的体积。

所以我们可以考虑注意到一个可以预处理出所有 $n$ 下所有窗沿的最大 $V$ 雪球的体积和。

此时我们可以想如何推出新增一个窗沿对答案造成的贡献，只要推出来这个做一次前缀和答案就出来了。

然后我们可以反向思考，从 $\frac{i}{max_{p_i}}$ 去推它给 $i$ 的贡献，即对于一个 $i$，它贡献的 $1−max_{p_i}$ 在 $i×j$ 中被统计到当且仅当 $i×j$ 能除掉几个最大质因数变成 $i$，翻译成人话就是 $j$ 的最小质因数不小于 $i$ 的最大质因数。

这样时间复杂度为 $O(n \log n + T)$，就不会炸了。

# Code

结合代码理解一下。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define f(n,m,i) for (register long long i(n);i <= m;++ i)
#define fc(n,m,i) for (register long long i(n);i >= m;-- i)
#define dbug(x) cerr<<(#x)<<':'<<x<<' ';
#define ent cerr<<'\n';
#define max(a,b) (((a)>(b))?(a):(b))
inline void C(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0),cerr.tie(0);
}
bool inp[2000005];//不是质数的
long long prime[2000005];//质数
long long cnt,t(-1),n,ans[2000005];//顾名思义
long long maxp[2000005],minp[2000005];//最大&最小质因数
inline void pre(){//预处理
    maxp[1] = minp[1] = 1;
    f(2,2000000,i){
        if(!inp[i]){
            prime[++ cnt] = maxp[i] = minp[i] = i;
        }//质数的最大质因数和最小质因数都是自身
        f(1,cnt,j){
            long long c(prime[j] * i);
            if (c > 2000000){
                break;
            }
            inp[c] = true;//显然
            maxp[c] = maxp[i];//修改最大质因数
            minp[c] = prime[j];//修改最小质因数
            if(!(i % prime[j])){
                break;
            }
        }
    }
    f(2,2000000,i){
        ans[i] += 1 - maxp[i];
        long long man(2000000 / i);
        f(2,man,j){
            if(minp[j] >= maxp[i]){//j的最小质因数不小于i的最大质因数
                ans[i * j] += 1 - maxp[i];
            }
        }//从ans[i/maxpi]转移到ans[i]并预先加上1 - maxpi
    }
    f(1,2000000,i){
        long long tot(0),man(2000000 / i);
        f(2,man,j){
            ans[i * j] += tot;
            if(minp[j] >= maxp[i]){
                ans[i * j] += j;
                ++ tot;
            }
        }//考虑n/i/maxpi
    }
    f(2,2000000,i){
        ans[i] += ans[i - 1];
    }//前缀和
    return;
}
int main(){
    Genshin_Impact:
    if (t == -1){
        C(),pre();
        cin >> t;
    }
    if (!t){
        dbug(clock())
        return 0;
    }
    long long n;
    cin >> n;
    cout << ans[n] + n << endl;//最后加上个n，就是来自第一个窗沿的V的转移
    -- t;
    goto Genshin_Impact;
}
/*
g++ t1.cpp -o code
./code

5
1
5
3
114514
2000000

*/
```

---

## 作者：diqiuyi (赞：1)

考虑三个数 $i,j,k(i<j<k)$，若 $i\mid j\land j\mid k$，那么显然 $k$ 的最大值不会从 $i$ 处转移来。因为只考虑 $i$ 处的转移时 $j$ 的答案比 $k$ 大，那么 $j$ 转移到 $k$ 显然只会更大。

设 $f(i)$ 表示最后 $i$ 处最大雪团的体积。

所以 $i$ 的答案会从 $\dfrac{i}{p}$ 转移而来，即 $f(i)=\max f(\dfrac{i}{p})+\dfrac{n}{\frac{i}{p}}-p+1$。这可以看成是一条从 $i$ 走到 $1$ 的路径，显然所有的 $-p+1$ 都是要走到的，那么我们只要 $\dfrac{n}{\frac{i}{p}}$ 最大，所以 $i$ 会从 $\dfrac{i}{\operatorname{maxp}(i)}$ 处转移而来。

此时我们已经写出了 $f(i)$ 的计算方法，每次直接做就是 $O(Tn\log\log n)$ 的。

考虑优化，我们从小到大枚举 $n$，那么我们首先要加上 $f(n)$ 的贡献。然后我们需要考虑维护出 $\dfrac{n}{\frac{i}{p}}$ 的变化。显然这个东西变化当且仅当 $\frac{i}{p}$ 是 $n$ 的因数，它的贡献是它在所有 $f$ 的路径中出现的次数，直接枚举因数计算就可以做到 $O(T+n\log n)$。

但是直接存储所有因数会炸空间，我们存下每个数的最小质因子，然后质因数分解每个数，再 dfs 出所有因数即可。
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int t,n,tot,p[30],k[30],len,prime[214514],cnt[2000005],minp[2000005];
bitset<2000005> vis;
ll ans[2000005];
void dfs(int x,int now,int P){
	if(x>len){
		ans[P]+=cnt[now];
		return ;
	}
	for(int i=0;i<=k[x];i++){
		dfs(x+1,now,P);
		if(i<k[x]) now*=p[x];
	}
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0);
	for(int i=2;i<=2000000;i++){
		if(!vis[i]) prime[++tot]=i,minp[i]=i;
		for(int j=1;prime[j]*i<=2000000;j++){
			vis[i*prime[j]]=1,minp[i*prime[j]]=prime[j];
			if(j==minp[i]) break;
		}
	}
	ans[1]=cnt[1]=1;
	for(int i=2;i<=2000000;i++){
		ans[i]=ans[i-1],len=0;
		int j=i,now,lst=0;
		while(j>1){
			if(minp[j]==lst) now++;
			else{
				if(lst) p[++len]=lst,k[len]=now;
				lst=minp[j],now=1;
			}
			j/=minp[j];
		}
		p[++len]=lst,k[len]=now;
		for(int o=len,nw=i;o;o--)
			for(int z=1;z<=k[o];z++)
				ans[i]+=i/(nw/p[o])-p[o]+1,nw/=p[o];
		dfs(1,1,i);
		for(int o=len,nw=i;o;o--)
			for(int z=1;z<=k[o];z++)
				cnt[nw/=p[o]]++;
	}
	cin>>t;
	while(t--) cin>>n,cout<<ans[n]<<'\n';
	return 0;
}
```

---

## 作者：0zhouyq (赞：1)

赛时乍一看没什么思路，那就从暴力开始。

显然其实某级窗沿上只有最大的那团雪有用。记 $f_i$ 为第 $i$ 级窗沿上最大的那团雪的体积。显然 $f_1=1$。从 $1$ 枚举到 $n$，每级窗沿向后更新。于是就打出这份暴力代码。获得 $15$ 分的成绩。时间复杂度 $O(Tn\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll f[2000005],frm[2000005],ans;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	ll T;
	cin>>T;
	f[1]=1;
	while(T--){
		ll n;
		cin>>n;
		for(ll i=2;i<=n;i++) f[i]=n-i+2,frm[i]=1;
		for(ll i=2;i<=n;i++){
			ll k=n/i-1;
			for(ll j=i*2;j<=n;j+=i){
				if(f[j]<f[i]+(k-(j-i)/i+1)){
					f[j]=f[i]+(k-(j-i)/i+1);
					frm[j]=i;
				}
			}
		}
		ans=1;
		for(ll i=2;i<=n;i++){
			ans+=f[i];
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```

顺手记录一下每级窗沿最大的雪团从哪里来（也就是上面的 $frm_i$）。~~通过打表~~注意到 $\frac{i}{frm_i}$ 是一个大质数，且为 $i$ 的因数。合理猜测 $\frac{i}{frm_i}$ 的结果为 $i$ 的最大质因子 $maxx_i$。

证明一下：如果设 $x= \prod _{i=1}^{k}p_i^{c_i}$，其中 $p_i$ 为质数。显然的是，$x$ 一定从某一个 $\frac{x}{p_i}$ 转移过来。则 $f_x=\max_{i=1}^{k}{f_{\frac{x}{p_i}}+\frac{n}{\frac{x}{p_i}}-p_i}$。想要 $f_x$ 尽量大，首先最后的 $-p_i$ 可以放在最后一起求和，不用管。可以理解为，每一步，$f_x$ 会加上 $\frac{1}{\frac{x}{p_i}}$（把 $\frac{n}{\frac{x}{p_i}}$的分子 $n$ 提到外面去），然后 $x$ 变为 $\frac{x}{p_i}$。直到 $x=1$ 时结束。每一步想变大，则 $\frac{x}{p_i}$ 越小越好。那每一步取最大的 $p_i$ 就是最优解。贪心是正确的，因为 $\frac{x}{p_i}$ 是 $x$ 的一个因子。当 $\frac{x}{p_i}$ 取最小时，下一步的 $x$ 也更小，下一步的 $\frac{x}{p_i}$ 也是更小的。

于是，就可以线性筛出每个数的最大因子 $maxx_i$。打出如下代码，其中的 $num_i$ 即为 $\frac{i}{maxx_i}$ 的结果，$minx_i$ 为 $i$ 的最小因子 。获得 $50$ 分的成绩。时间复杂度 $O(Tn)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll f[2000005],ans;
int minx[2000005],maxx[2000005],num[2000005];
vector<int> p;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int T;
	cin>>T;
	f[1]=1;
	minx[1]=maxx[1]=1;
	for(int i=2;i<=2000000;i++){
		if(minx[i]==0){
			minx[i]=maxx[i]=i;
			p.push_back(i);
		}
		else maxx[i]=max(maxx[i/minx[i]],minx[i]);
		for(auto x:p){
			if(i*x>2000000) break;
			if(minx[i*x]==0) minx[i*x]=x;
			if(i==i/x*x) break;
		}
		num[i]=i/maxx[i];
	}
	f[1]=1;
	while(T--){
		ll n;
		cin>>n;
		ans=1;
		for(int i=2;i<=n;i++){
			f[i]=f[num[i]]+n/num[i]+1-maxx[i];
			ans+=f[i];
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```

推一下柿子，可以得到转移式：$f_i=f_{num_i}+\frac{n}{num_i}+(maxx_i-1)$。然后我就卡住了。

注意到，原题并没有强制在线。那我们就离线下来操作。将询问的 $n$ 排序，从小到大解决。考虑 $n$ 增加一时答案如何改变。

对于 $1$ 到 $n-1$ 的部分，如果 $num_i$ 是 $n$ 的因子，那么 $\frac{n}{num_i}$ 的部分会加一。所以对于所有满足 $num_{i}\mid n$ 的 $i$ ，$f_i$ 增加一。同样的，如果 $f_{num_i}$ 增加了一，那么 $f_i$ 也会增加一。也就是说所有满足 $num_{num_i}\mid n$ 的 $i$，$f_i$ 也会增加一。以此类推。考虑边界条件，将 $num_1$ 设置为正无穷即可。对 $num_i$ 设置一个桶进行计数。由于在数据范围内一个数至多进行 $21$ 次操作 就会变成正无穷，所以只需要开 $20$ 个桶分别计数即可。下面称 $tot_{j,i}$ 为第 $j$ 个桶的第 $i$ 位。暴力枚举 $n$ 的所有因数 $x$，加上 $\sum_{i=1}^{20}tot_{i,x}$ 即可。

对于 $n$ ，我们可以暴力递归解决 $f_n$ 的初始值问题。并将这个值加在答案上。最后将这个 $n$ 造成的影响加在桶上。

就可以写出如下代码，获得 $80$ 分的成绩。由于从 $1$ 到 $n$ 的因数个数之和为 $nlnn$ 级别的，时间复杂度 $O(n\ln n\log n+T\log T)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll nans=1;
int minx[2000005],maxx[2000005],num[2000005],tot[20][2000005],cf[20],dd,n=1;
vector<int> p,ys[2000005];
struct node{
	int n,t;
	ll ans;
}q[500005];
bool cmp(node a,node b){
	return a.n<b.n;
}
bool cmp2(node a,node b){
	return a.t<b.t;
}
int get_f(int x){
	if(x==1) return 1;
	return get_f(num[x])+n/num[x]-maxx[x]+1;
}
void dfs(int h,int now){
	if(h==ys[n].size()){
		for(int i=0;i<20;i++) dd+=tot[i][now];
	}
	else{
		for(int j=0;j<=cf[h];j++){
			dfs(h+1,now);
			now=now*ys[n][h];
		}
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int T;
	cin>>T;
	minx[1]=maxx[1]=1;
	num[1]=2000001;
	for(int i=2;i<=2000000;i++){
		if(minx[i]==0){
			minx[i]=maxx[i]=i;
			p.push_back(i);
			ys[i].push_back(i);
		}
		else{
			maxx[i]=max(maxx[i/minx[i]],minx[i]);
			ys[i]=ys[i/minx[i]];
			if(i/minx[i]%minx[i]!=0) ys[i].push_back(minx[i]);
		}
		for(auto x:p){
			if(i*x>2000000) break;
			if(minx[i*x]==0) minx[i*x]=x;
			if(i==i/x*x) break;
		}
		num[i]=i/maxx[i];
	}
	for(int i=1;i<=T;i++){
		cin>>q[i].n;
		q[i].t=i;
	}
	sort(q+1,q+T+1,cmp);
	for(int i=1;i<=T;i++){
		while(n<q[i].n){
			n++;
			int lnn=n;
			for(int j=0;j<ys[n].size();j++){
				while(lnn/ys[n][j]*ys[n][j]==lnn){
					lnn/=ys[n][j];
					cf[j]++;
				}
			}
			dd=0;
			dfs(0,1);
			for(int j=0;j<ys[n].size();j++) cf[j]=0;
			nans=nans+dd;
			nans=nans+get_f(n);
			int now=n,cnt=0;
			while(num[now]<=n){
				tot[cnt][num[now]]++;
				now=num[now];
				cnt++;
			}
		}
		q[i].ans=nans;
	}
	sort(q+1,q+T+1,cmp2);
	for(int i=1;i<=T;i++) cout<<q[i].ans<<"\n";
	return 0;
}
```

我一开始以为这应该能过，但是最后一个子任务平均超时了 $0.07$ 秒，结果就开始卡常。把两个将询问排序的过程改成了桶。此时就应该能过了。（然而我还是超时了一丢丢）

突然发现对 $tot$ 查询时只关心第二维，那我们将 $tot$ 数组去掉第一维，压缩成一维。时间复杂度变为 $O(n\ln n+n\log n+T)$，可以 $100$ 分了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll nans=1,ans[2000005];
int minx[2000005],maxx[2000005],num[2000005],tot[2000005],dd,n=1,pcnt,p[200000];
short siz,cf[20];
vector<int> ys[2000005];
struct node{
	int n,t;
	ll ans;
}q[500005];
bool cmp(node a,node b){
	return a.n<b.n;
}
int get_f(int x){
	if(x==1) return 1;
	return get_f(num[x])+n/num[x]-maxx[x]+1;
}
void dfs(short h,int now){
	if(h==siz) dd+=tot[now];
	else{
		for(short j=0;j<=cf[h];j++){
			dfs(h+1,now);
			now=now*ys[n][h];
		}
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int T;
	cin>>T;
	minx[1]=maxx[1]=1;
	num[1]=2000001;
	for(int i=2;i<=2000000;i++){
		if(minx[i]){
			maxx[i]=max(maxx[i/minx[i]],minx[i]);
			ys[i]=ys[i/minx[i]];
			if(i/minx[i]/minx[i]*minx[i]!=i/minx[i]) ys[i].push_back(minx[i]);
		}
		else{
			minx[i]=maxx[i]=i;
			ys[i].push_back(i);
			p[++pcnt]=i;
		}
		for(int j=1;j<=pcnt&&i*p[j]<=2000000;j++){
			if(minx[i*p[j]]==0) minx[i*p[j]]=p[j];
			if(i==i/p[j]*p[j]) break;
		}
		num[i]=i/maxx[i];
	}
	for(int i=1;i<=T;i++){
		cin>>q[i].n;
		q[i].t=i;
	}
	sort(q+1,q+T+1,cmp);
	for(int i=1;i<=T;i++){
		while(n<q[i].n){
			n++;
			siz=ys[n].size();
			int lnn=n;
			for(int j=0;j<siz;j++){
				while(lnn/ys[n][j]*ys[n][j]==lnn){
					lnn/=ys[n][j];
					cf[j]++;
				}
			}
			dd=0;
			dfs(0,1);
			for(int j=0;j<siz;j++) cf[j]=0;
			memset(cf,0,siz*sizeof(short));
			nans+=dd;
			nans+=get_f(n);
			int cnt=0;lnn=n;
			while(num[lnn]<=n){
				tot[num[lnn]]++;
				lnn=num[lnn];
				cnt++;
			}
		}
		ans[q[i].t]=nans;
	}
	for(int i=1;i<=T;i++) cout<<ans[i]<<"\n";
	return 0;
}
```

---

## 作者：zzzyyyyhhhhh (赞：1)

首先可以证明对于所有 $k\ge i$，使 $i$ 取到最大值的位置 $j$ 是不变的，也就是每个值由另外一个位置转移过来，那么另外一个位置在无论 $n$ 取多少的时候都是不变的。

那么只需要枚举这个数的所有因数就可以得到这个数是从哪个位置转移过来的。

观察数据范围发现我们多半不能在线处理询问，而是要预处理出所有答案，于是考虑从 $i$ 到 $i+1$ 答案会增大多少。首先会增大 $i+1$ 此时的值，对于其他的数，一个数 $x$ 是从一条链 $a_1\rightarrow a_2\rightarrow ...\rightarrow a_n$ 转移过来的，那么显然 $x$ 的增加量就是 $a$ 数组中为 $i+1$ 因数的数的个数，开一个桶记录因数有某一个数时的增加量即可。

注意预处理因数常数巨大，赛时时限 1s 需要一些手法才能通过，不过时限开大后以下代码就可以通过了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e6+1;
long long cnt[N],ans[N],mx[N],cc[N];
int *p[N],siz[N],pos[N];
signed main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int st=clock();
	for(int i=2;i<N;i++)
		for(int j=i+i;j<N;j+=i)
			siz[j]++;
	for(int i=1;i<N;i++)p[i]=new int[siz[i]],siz[i]=0;
	cerr<<(double)(clock()-st)/CLOCKS_PER_SEC<<'\n';
	for(int i=2;i<N;i++)
		for(int j=i+i;j<N;j+=i)
			p[j][siz[j]++]=i;
	cerr<<(double)(clock()-st)/CLOCKS_PER_SEC<<'\n';
	pos[1]=1;
	mx[1]=1;
	cc[1]=1;
	ans[0]=-1;
	int tmp;
	for(int i=1;i<N;i++)
	{
		for(int e=0,j;e<siz[i];e++)
		{
			j=p[i][e];
			if(cc[j]*(i/j-1)+mx[j]+1>mx[i])mx[i]=cc[j]*(i/j-1)+mx[j]+1,pos[i]=j;	
		}
		if(2>mx[i])mx[i]=2,pos[i]=1;
		tmp=i;
		ans[i]=ans[i-1]+mx[i];
		ans[i]+=cnt[1];
		for(int e=0,j;e<siz[i];e++)
		{
			j=p[i][e];
			ans[i]+=cnt[j];
		}
		while(pos[tmp]!=1)cnt[pos[tmp]]++,cc[i]+=i/pos[tmp],tmp=pos[tmp];
		if(i!=1)cnt[pos[tmp]]++,cc[i]+=i;
	}
	cerr<<(double)(clock()-st)/CLOCKS_PER_SEC<<'\n';
	int t,n;
	cin>>t;
	while(t--)cin>>n,cout<<ans[n]<<'\n';
}
```

---

## 作者：_lmh_ (赞：1)

先考虑 $n$ 固定的情况下 $x$ 位置的答案 $f_x$。

不妨假设答案的转移路径是 $1=a_0\rightarrow a_1\rightarrow a_2\rightarrow\cdots\rightarrow a_m=x$，则答案为 $1+\sum_{i=1}^{m}(\lfloor \frac{n}{a_{i-1}}\rfloor - \frac{a_i}{a_{i-1}}+1)$。盯着这个式子会发现让转移次数变多显然不劣，并且我们优先转移较大的质因子。

现在我们对 $n$ 做扫描线，每次 $n$ 增大时暴力算出 $f_n$ 同时记录 $\lfloor \frac{n}{i}\rfloor$ 的出现次数 $c_i$，对每个 $x|n$ 将答案累加 $c_x$。

这样暴力做的话复杂度是 $O(T\log T+n\log n)$ 的，但我们要记录每个数的因子，空间复杂度无法承受，且常数极大。

考虑优化。只存储满足 $x^2\le n$ 的 $x|n$，并对 $\le B=10$ 的因子单独处理，这样只用存储 $<1\times 10^7$ 个数，可以通过。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
constexpr ll N=2000007,B=10;
ll ans[N],now;
int T,n=2000000,cnt[N],p[N],prime[N],nP,ok[N];
vector<int> q[N],d[N];
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	p[1]=1;
	for (int i=2;i<=n;++i){
		if (!ok[i]){prime[++nP]=p[i]=i;}
		for (int j=1;i*prime[j]<=n;++j){
			ok[i*prime[j]]=1;p[i*prime[j]]=p[i];
			if (i%prime[j]==0) break;
		}
	}
	for (int i=B+1;i*i<=n;++i) for (ll j=i*i;j<=n;j+=i) d[j].emplace_back(i);
	cin>>T;
	for (int x,i=1;i<=T;++i){cin>>x;q[x].emplace_back(i);}
	for (int i=now=1;i<=n;++i){
		for (int x=2;x<=B&&x*x<=i;++x) if (i%x==0){
			now+=cnt[x];
			if (x*x!=i) now+=cnt[i/x];
		}
		for (auto x:d[i]){
			now+=cnt[x];
			if (x*x!=i) now+=cnt[i/x];
		}
		now+=i-1;
		int x=i;
		while(x!=1){
			now-=p[x]-1;x/=p[x];
			now+=i/x;++cnt[x];
		}
		for (auto x:q[i]) ans[x]=now;
	}
	for (int i=1;i<=T;++i) cout<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：Engulf (赞：0)

思路参考：[@chenwenmo 的题解](https://www.luogu.com.cn/article/0oz3p41a)。

### 单次询问 $O(n \ln n) \to \Theta(n)$

有个朴素的 $O(n \ln n)$ 暴力。

设 $a_i$ 表示窗沿 $i$ 最大积雪体积，暴力地枚举 $i$ 的因数转移。

取了多次 $\max$，是不是每次都是必要的？显然不是，打表可以发现，若记 $d_i$ 为 $i$ 的最大质因数，**记 $j = \dfrac{i}{d_i}$（请记住 $j$ 的定义）**，那么 $i$ 一定由 $j$ 转移过来。

$$a_i = a_j + \left\lfloor \dfrac{n}{j} \right\rfloor - \dfrac{i}{j} + 1$$

且

$$a_1 = 1$$

这样就有了单次询问 $\Theta(n)$ 的做法。

---

### 单次询问 $\Theta(n) \to O(1)$

要加速单次询问，要么是 $\log$，要么是预处理好 $O(1)$ 查询。

观察转移方程

$$a_i = \color{blue}a_j + \color{red}\left\lfloor \dfrac{n}{j} \right\rfloor \color{blue} - \dfrac{i}{j} + 1$$

只有红色的部分与 $n$ 相关。可以把答案分成两部分，与 $n$ 无关的部分直接预处理好，计算前缀和，我们 **重定义** $a$ 的转移

$$a_i = a_j - \dfrac{i}{j} + 1$$

$$a_1 = 1$$

再令

$$pre_n = \sum_{i = 1}^{n}a_i$$

就是蓝色部分的贡献。

接下来考虑计算红色部分的贡献，记为 $sum$。

如果连边 $j \to i$，会形成一棵树，转移就是一条到根的链。

那么红色部分的贡献就是

$$\sum_{j=1}^n (siz_j - 1)\left\lfloor \dfrac{n}{j} \right\rfloor$$

因为一个 $\left\lfloor \dfrac{n}{j} \right\rfloor$ 会贡献到子树内（不含 $j$）每一个 $i$。

交换求和顺序

$$\sum_{j=1}^n (siz_j - 1)\left\lfloor \dfrac{n}{j} \right\rfloor \ = \ \sum_{i=1}^n \sum_{j \ | \ i} siz_j - 1$$

每次新加入一个 $i$，就相当于添加一个叶子。由于树高是 $\log$ 的，暴力跳父亲更新 $siz$。

我们递推维护 $sum$。在 $n-1\to n$ 的过程中，$sum$ 的变化量 $\Delta$ 由两部分组成。
- 由于 $siz$ 更新了，对于每个更新了的 $siz_k$，每个的增量是 $1$，增加贡献 $\left\lfloor\dfrac{\color{red}n-1}{k}\right\rfloor$，因为每个 $k$ 会在 $k$ 的倍数处都算一遍，红色部分是为了不重复计算；
- 另一部分是 $\sum\limits_{j \ | \ n} siz_j - 1$，这样的 $j$ 在 $2\cdot 10^6$ 的值域内是很少的，所以线性筛的时候记录每个数的最小质因数，$\log $ 时间分解质因数，dfs 就可以 $\Theta(d(n))$ 时间内找出所有 $n$ 的因数，$d(n)$ 表示 $n$ 的因数个数。

那么 $n$ 处的答案就是对应的 $sum + pre_n$。

预处理 $O(n \log n)$，单次询问 $O(1)$，总时间复杂度 $O(T + n\log n)$。

:::success[实现]
```cpp line-numbers
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using pii = pair<int, int>;

#ifdef ONLINE_JUDGE
#define debug(...) 0
#else
#define debug(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)
#endif

const int N = 2e6 + 5;

int a[N];
int siz[N];

bool notprime[N];
vector<int> primes;
int d[N], mp[N];

ll pre[N];
ll ans[N];

vector<pii> divisors[N];

ll dfs(int u, vector<pii> &vec, int x) {
    if (u == vec.size()) return siz[x] - 1;
    ll res = 0;
    for (int i = 0; i <= vec[u].second; i++)
        res += dfs(u + 1, vec, x * pow(vec[u].first, i));
    return res;
}

void sieve(int n) {
    for (int i = 2; i <= n; i++) {
        if (!notprime[i]) primes.emplace_back(i), d[i] = i, mp[i] = i;
        for (int j = 0; primes[j] * i <= n; j++) {
            notprime[primes[j] * i] = 1;
            d[primes[j] * i] = d[i];
            mp[primes[j] * i] = primes[j];
            if (i % primes[j] == 0) break;
        }
    }

    for (int i = 2; i <= n; i++) {
        int t = i;
        while (t > 1) {
            int lst = mp[t], cnt = 0;
            while (mp[t] == lst) cnt++, t /= mp[t];
            divisors[i].emplace_back(lst, cnt);
        }
    }

    d[1] = 1e9;
    a[1] = pre[1] = ans[1] = siz[1] = 1;
    ll sum = 0;
    for (int i = 2; i <= n; i++) {
        int j = i / d[i];
        a[i] = a[j] - i / j + 1;
        pre[i] = pre[i - 1] + a[i];
        for (int k = i; k; k = k / d[k])
            siz[k]++, sum += (i - 1) / k;
        sum += dfs(0, divisors[i], 1);
        ans[i] = pre[i] + sum;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    sieve(N - 5);

    int tt;
    cin >> tt;
    while (tt--) {
        int n; cin >> n;
        cout << ans[n] << "\n";
    }
    return 0;
}
```
:::

---


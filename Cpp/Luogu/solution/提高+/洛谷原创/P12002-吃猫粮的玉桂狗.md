# 吃猫粮的玉桂狗

## 题目描述

扶苏养了一只吃猫粮的玉桂狗。

扶苏有一个 $n$ 个点的树。她还买了 $m$ 种猫粮。对于第 $i$ 种猫粮，她买了 $c_i$ 份。**保证 $c_i \geq \lfloor\frac{n}{2}\rfloor$**。扶苏想在这棵树的每个节点上都放上一份猫粮。

扶苏的玉桂狗会从 $1$ 号节点出发在树上进行移动。每次移动时，它会从与当前节点相邻的节点中，选择一个**还没到达过**的节点，并移动到该节点。如果相邻的节点中没有未到达的节点，则移动停止。在移动过程中，每次到达一个新的节点（包括在节点 $1$），玉桂狗就会吃掉这个节点上的猫粮。

因为猫粮的成分各有不同，有 $t$ 个限制。第 $i$ 个限制是 $(a_i, b_i)$。表示当玉桂狗吃完种类为 $a_i$ 的猫粮后，不能**立刻**吃种类为 $b_i$ 的猫粮（但是可以吃至少一个其他种类的猫粮后再吃该种类的猫粮），否则狗会生病。

扶苏想知道有多少方案，使得她能在这棵树上的每个节点都放上一份猫粮，且无论玉桂狗在树上沿任何路径移动，它都不会生病。

两种方案不同当且仅当存在一个节点 $u$，使得 $u$ 在两种方案里放的猫粮的种类不同。

因为方案数太大，所以扶苏只关心这个数字除以 $353,442,899$ 的余数。

## 说明/提示

### 数据规模与约定

- 对 $30\%$ 的数据，$n,m \leq 5$。
- 对 $60\%$ 的数据，$n,m \leq 20$。
- 对 $100\%$ 的数据，保证 $1 \leq n, m \leq 50$，$1 \leq u_i, v_i \leq n$，$1 \leq a_i, b_i \leq m$，$1 \leq t \leq m^2$，$\lfloor\frac{n}{2}\rfloor \leq c_i \leq n$，不存在 $i \neq j$ 使得 $(a_i, b_i) = (a_j, b_j)$。

## 样例 #1

### 输入

```
5 2 1
3 3
1 2
1 3
2 4
2 5
1 2```

### 输出

```
5```

# 题解

## 作者：一扶苏一 (赞：8)

又拿这个套路炒了一波冷饭。看赛时榜好像大家还是不太会，所以希望这个题能对这个套路有一定普及作用。

猜你想搜：

- [P5664 Emiya 家今天的饭](https://www.luogu.com.cn/problem/P5664)
- [P8202 染色](https://www.luogu.com.cn/problem/P8202)
- [CF1487G String Counting](https://www.luogu.com.cn/problem/CF1487G)

考虑这个每种猫粮的数量多于一半有什么用：在满足位置限制（所有的 $(a_i, b_i)$ 对）时，任意不合法方案都只有一种猫粮超出数量限制。因为如果有两种猫粮 $x,y$  超出了限制，假设分别放了 $w_1, w_2$ 个，那么有 $w_1 > c_x \geq \lfloor\frac{n}{2}\rfloor$，$ w_2>c_y \geq \lfloor\frac{n}{2}\rfloor$，则 $w_1 + w_2 > n$。而所有猫粮加起来只会选 $n$ 个，所以这种情况不会存在。

可以考虑枚举那个超限制的猫粮 $x$，那么其它猫粮都可以随便选，假设种类 $x$ 的猫粮超限制的方案数是 $A(x)$，在不考虑猫粮数量限制时的方案数是 $S$，则可以容斥一下合法方案数就是 $S - \sum_{x= 1}^m A(x)$。考虑计算 $A(x)$。

注意到我们关于位置的限制（所有的 $(a_i, b_i)$ 对）其实等价于：以 $1$ 为根的树，不存在任何父亲-孩子对使得父亲的猫粮是 $a_i$，孩子的猫粮是 $b_i$。考虑枚举超限制的猫粮种类 $x$，进行树形 DP：$f_{u,i,j}$ 表示以 $u$ 为根的子树，$u$ 的猫粮种类是 $i$，且种类为 $x$ 的猫粮已经放了 $j$ 个的方案数。可以进行树上背包转移：

枚举 $u$ 的孩子 $v$，设 $u$ 当前已经转移的孩子放了 $i$ 个猫粮 $x$，$v$ 这个孩子选了 $j$ 个猫粮 $x$，$u$ 的猫粮种类是 $h$，$v$ 的猫粮种类是 $k$，当前已转移的孩子的状态放在 $f'$ 里，有：
$$
f(u,h,i+j) \leftarrow \sum_{k = 1}^m (f(v,k,j) \times f'(u, h,i) \times[\mathrm{ok}(h,k)])
$$


这里当 $(h,k)$ 这个限制不存在时，$[\mathrm{ok}(h,k)]=1$，否则为 $0$。

如果不理解树上背包转移可以去看代码。

如果把第二维拿掉，那么这个 dp 是在做标准树上背包。所以上式是在树上背包的基础上枚举了 $h$ 和 $k$ 两维。标准树上背包的复杂度是 $O(n^2)$，因此上面这个 dp 的复杂度是 $O(n^2m^2)$。算上我们外面枚举的不合法的猫粮种类 $x$，总的复杂度是 $O(n^2m^3)$。

那么 $A(t) = \sum_{i= 1}^m \sum_{j = c_{t} + 1}^nf(1,i,j)$

对 $S$（总方案数）的计算也是简单的，直接把记录猫粮 $x$ 的数量一维删掉即可。
$$
g(u,h) \leftarrow g'(u,h) \times \sum_{k = 1}^m g(v,k)\times[\mathrm{ok}(h,k)]
$$
减一下就做完了。

注意树上 DP 的过程里不要对最后一维有无效的枚举，否则复杂度是不对的。

```cpp
#include <bits/stdc++.h>

const int p = 353'442'899;

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, m, t;
  std::cin >> n >> m >> t;
  std::vector<int> c(m + 1);
  for (int i = 1; i <= m; ++i) std::cin >> c[i];
  std::vector e(n + 1, std::vector<int>()), lim(m + 1, std::vector<int>(m + 1, 0));
  for (int i = 1, u, v; i < n; ++i) {
    std::cin >> u >> v;
    e[u].push_back(v);
    e[v].push_back(u);
  }
  for (int u, v; t; --t) {
    std::cin >> u >> v;
    lim[u][v] = 1;
  }
  std::vector g(n + 1, std::vector(m + 1, 0));
  auto Dfs = [&](auto &&dfs, int u, int pre) -> void {
    for (int col = 1; col <= n; ++col) g[u][col] = 1;
    for (auto v : e[u]) if (v != pre) {
      dfs(dfs, v, u);
      for (int curCol = 1; curCol <= m; ++curCol) {
        int sum = 0;
        for (int childCol = 1; childCol <= m; ++childCol) if (!lim[curCol][childCol]) {
          (sum += g[v][childCol]) %= p;
        }
        g[u][curCol] = 1ll * g[u][curCol] * sum % p;
      }
    }
  };
  Dfs(Dfs, 1, 0);
  int ans = 0;
  for (int col = 1; col <= m; ++col) {
    (ans += g[1][col]) %= p;
  }
  for (int tarCol = 1; tarCol <= m; ++tarCol) {
    std::vector f(n + 1, std::vector(m + 1, std::vector(n + 1, 0)));
    std::vector<int> sz(n + 1);
    auto dfs = [&](auto &&dfs, int u, int pre) -> void {
      sz[u] = 1;
      for (int curCol = 1; curCol <= m; ++curCol) {
        f[u][curCol][curCol == tarCol] = 1;
      }
      for (auto v : e[u]) if (v != pre) {
        dfs(dfs, v, u);
        for (int curCol = 1; curCol <= m; ++curCol) {
          std::vector curf(sz[u] + sz[v] + 1, 0);
          for (int childCol = 1; childCol <= m; ++childCol) if (!lim[curCol][childCol]) {
            for (int lsh = 0; lsh <= sz[u]; ++lsh) {
              for (int rsh = 0; rsh <= sz[v]; ++rsh) {
                curf[lsh + rsh] += 1ll * f[v][childCol][rsh] * f[u][curCol][lsh] % p;
                curf[lsh +rsh] %= p;
              }
            }
          }
          for (int i = 0; i <= sz[u] + sz[v]; ++i) f[u][curCol][i] = curf[i];
        }
        sz[u] += sz[v];
      }
    };
    dfs(dfs, 1, 0);
    for (int i = c[tarCol] + 1; i <= n; ++i) {
      for (int col = 1; col <= m; ++col) {
        ans -= f[1][col][i];
        ans = (ans + p) % p;
      }
    }
  }
  std::cout << ans << std::endl;
}
```

不知道下次把这个精品小套路掏出来扔到比赛里会是什么时间。

---

## 作者：Starrykiller (赞：6)

令 $u$ 点权为 $a_u$。问题转化为，$\forall u,v$（$v\in \mathrm{son}(u)$），都有 $(a_u,a_v)$ 没有被 ban，且每个点权 $i$ 的出现次数都不大于 $c_i$ 的方案数。

考虑关键性质：$c_i\ge n/2$。这意味着，若 $i$ 的出现次数超出了限制，别的点权的出现次数必然合法，考虑枚举这个不合法的容斥（Emiya 家今天的饭）。

首先总方案数是好算的：令 $f(u,i)$ 表示 $a_u=i$ 的方案数，合并就是 $f(u,i)\gets f(u,i)\prod_{(i,j)\text{ is valid}} f(v,j)$。

枚举点权 $x$ 的出现次数超出限制，只需要再记一维 $j$，表示 $x$ 的出现次数。这样合并就是一个树上背包，时间复杂度 $\Theta(m\cdot n^2m^2)=\Theta(n^2m^3)$，可以通过。

鲜花：原本此题的数据范围是 $n,m\le 100$，我验题的时候写了个暴力过了，才得知实际数据范围。

---

## 作者：Wei_Han (赞：3)

场上一直没想到只有至多一种不够有什么用，还是太菜。

不考虑 $c$ 的限制，对于方案数的统计只需要设 $f_{i,j}$ 表示以 $i$ 为根的子树内，$i$ 的值为 $j$，符合条件的方案数有多少种，把限制记录下来直接做就好了。

然后再算上 $c$，由于 $c_i \geq \left\lfloor \frac{n}{2}\right \rfloor$，也就是说最多只有一种值会不够用，考虑容斥，我们记录每种颜色不够用的方案数，然后用总方案一减就好了。

设 $g_{i,j,k}$ 表示以 $i$ 为根的子树内，$i$ 的权值为 $j$，当前要求不够用的颜色 $p$ 已经有了 $k$ 个的合法方案数，转移比较简单，见代码，注意树上背包的滚动。

树上背包的复杂度是 $O(n^2m^2)$，再算上一个枚举 $p$ 的，总复杂度 $O(n^2m^3)$，可以通过。

```cpp
const ll N=55,M=2e4+5,mod=353442899;
ll n,m,t,vis[N][N],c[N],f[N][N],g[N][N][N],siz[N],f1[N][N],g1[N][N][N];
vector<ll> G[N];
inline void ad(ll &x,ll y,ll z=0){x=((x+y+mod)%mod+z+mod)%mod;}
inline void dfs(ll x,ll fa)
{
	ll cnt=0;
	fo(1,i,m) f[x][i]=1;
	for(ll y:G[x])
	{
		if(y==fa) continue;++cnt;
		fo(1,i,m) f1[x][i]=f[x][i],f[x][i]=0;dfs(y,x);
		fo(1,i,m) fo(1,j,m) if(!vis[i][j]) 
			ad(f[x][i],f1[x][i]*f[y][j]%mod);
	}
}
inline void dfs1(ll x,ll fa,ll k)
{
	ll cnt=0;siz[x]=1;
	fo(1,i,m) if(i==k) g[x][i][1]=1;else g[x][i][0]=1;
	for(ll y:G[x])
	{
		if(y==fa) continue;++cnt;
		dfs1(y,x,k);
		fo(1,i,m) fo(0,j,siz[x]) g1[x][i][j]=g[x][i][j],g[x][i][j]=0;
		fo(1,i,m) fo(1,j,m) Fo(siz[x],k1,0) fo(0,k2,siz[y])
			if(!vis[i][j]) ad(g[x][i][k1+k2],g1[x][i][k1]*g[y][j][k2]%mod);
		siz[x]+=siz[y];
	}
}
signed main(){
	read(n),read(m),read(t);
	fo(1,i,m) read(c[i]);
	ll u,v;fo(1,i,n-1) read(u),read(v),G[u].pb(v),G[v].pb(u);
	fo(1,i,t) read(u),read(v),vis[u][v]=1;
	dfs(1,0);ll sum=0;fo(1,i,m) ad(sum,f[1][i]);
	fo(1,i,m){
		mem(g,0),mem(g1,0),dfs1(1,0,i);
		fo(1,k,m) fo(c[i]+1,j,n) ad(sum,-g[1][k][j]);
	}
	wr(sum),pr;
	return 0;
}
``````

---

## 作者：dengjunhaodejia09 (赞：2)

看到这道题，就发现了一个不寻常的一点。**保证 $c_i \geq \lfloor\frac{n}{2}\rfloor$**。

但这有什么用呢，发现若是不考虑颜色是否超过限制是好处理的，但题目给了限制，这该怎么办呢。

根据性质发现单次最多只有一种颜色会超过限制，而且题目的复杂度要求很松，考虑枚举超过的那个颜色。

对于每一个超过的颜色考虑，树形动态规划，记录选这个颜色的次数和当前点是什么颜色，后者可用来判断是否满足限制。

然后用平方级别的树形动态规划即可。

然后求出总的，减去不合法的即可。

具体转移其他题解已经十分清晰了，此处为大致思路。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int mod=353442899;
int C[55];
vector<int> g[55];
bool xian[55][55];
int siz[55],Now,dp[55][55][55],Dp[55][55][55];
int n,m,t;
void dfs(int cur,int fa){
    dp[1][cur][Now]=1;
    for(int j=1;j<=m;j++){
        if(j!=Now){
            dp[0][cur][j]=1;
        }
    }
    siz[cur]=1;
    for(int i=0;i<g[cur].size();i++){
        int v=g[cur][i];
        if(v==fa){
            continue;
        }
        dfs(v,cur);
        memset(Dp,0,sizeof(Dp));
        for(int id=1;id<=m;id++){
            for(int idd=1;idd<=m;idd++){
                if(xian[id][idd]){
                    continue;
                }
                for(int j=0;j<=siz[cur];j++){
                    for(int k=0;k<=siz[v];k++){
                        Dp[j+k][cur][id]+=dp[j][cur][id]*dp[k][v][idd];
                        Dp[j+k][cur][id]%=mod;
                    }
                }
            }
        }
        siz[cur]+=siz[v];
        for(int id=1;id<=m;id++){
            for(int j=0;j<=siz[cur];j++){
                dp[j][cur][id]=Dp[j][cur][id];
            }
        }
    }
}
int G[55][55];
void Dfs(int cur,int fa){
    for(int j=1;j<=m;j++){
        G[cur][j]=1;
    }
    for(int i=0;i<g[cur].size();i++){
        int v=g[cur][i];
        if(v==fa){
            continue;
        }
        Dfs(v,cur);
        for(int j=1;j<=m;j++){
            int ans=0;
            for(int k=1;k<=m;k++){
                if(xian[j][k])continue;
                ans+=G[v][k];
            }
            G[cur][j]*=ans;
            G[cur][j]%=mod;
        }
    }
}
signed main(){
    cin>>n>>m>>t;
    for(int i=1;i<=m;i++){
        cin>>C[i];
    }
    for(int i=1;i<n;i++){
        int u,v;
        cin>>u>>v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    for(int i=1;i<=t;i++){
        int u,v;
        cin>>u>>v;
        xian[u][v]=1;
    }
    int Ans=0;
    for(int i=1;i<=m;i++){
        Now=i;
        memset(dp,0,sizeof(dp));
        dfs(1,0);
        for(int j=C[i]+1;j<=n;j++){
            for(int k=1;k<=m;k++){
                Ans=(mod+Ans-dp[j][1][k]);
            }
        }
    }
    memset(siz,0,sizeof(siz));
    Dfs(1,0);
    for(int i=1;i<=m;i++){
        Ans+=G[1][i];
        Ans%=mod;
    }
    cout<<Ans;
    return 0;
}
```

---

## 作者：suzhikz (赞：2)

好题。

题目的意思就是一些东西有个数限制，要把东西丢到树上，然后有几个东西不能按照某种顺序摆。

考虑容斥。

我们先放弃这个个数限制，先算出这种情况下的答案数。

显然，每个点只要记录下这个点是某个颜色的方案数，转移只要把符合条件的儿子乘起来就好了。这一部分是 $O(n^4)$ 的。

代码如下。
```cpp
void dfs1(int x,int fa){
	if(g[x].size()==1&&fa){
		for(int i=1;i<=m;i++)dp[x][i][0]=1;
	} 
	for(int i:g[x]){
		if(i==fa)continue;
		dfs1(i,x);
		for(int j=1;j<=m;j++){
			ll tmp=0;
			for(int k=1;k<=m;k++){
				if(!s[j][k]){
					if(dp[x][j][0]==0&&dp[i][k][0]!=0)dp[x][j][0]=1;
					tmp+=dp[i][k][0];
					tmp%=mod;
				}
			}
			dp[x][j][0]*=tmp;
			dp[x][j][0]%=mod;
		}
	}
}
```

然后考虑某个东西个数不够的情况，显然这个东西我们不能直接容斥，不然就爆了，但是题目有个条件还没用到，就是 $c_i\ge\frac{n}{2}$，这个东西有啥用呢？就是没有两个东西同时用超过的情况，否则放的东西就比 $n$ 还多了。

所以我们可以枚举下每个超出的物品 $i$，然后每个点记录下这个点的颜色，和 $i$ 的个数。

朴素的 dp 是 $O(n^6)$ 的，代码长这样。


```cpp
void dfs2(int x,int fa){
	for(int i=1;i<=m;i++)dp[x][i][0]=1;
	for(int i:g[x]){
		if(i==fa)continue;
		dfs2(i,x);
		ll f[N][N]={0};
		for(int j=1;j<=m;j++){
			for(int k=0;k<=n;k++){//当前节点的颜色和标记数量 
				int tmp=0;
				for(int l2=0;l2<=k;l2++){
					for(int l=1;l<=m;l++){
						if(s[j][l])continue;
						f[j][k]+=dp[x][j][k-l2]*dp[i][l][l2];
					}
				}
			}
		}
		for(int j=1;j<=m;j++)for(int k=0;k<=n;k++)dp[x][j][k]=f[j][k];
	}
	for(int j=n;j>=1;j--)dp[x][mark][j]=dp[x][mark][j-1];
	dp[x][mark][0]=0;
}
```

考虑如何优化这玩意，其实就是因为枚举每个点使用被标记的东西的个数，导致了统计多次儿子对某个东西的贡献，所以这玩意先与处理下直接用即可，复杂度 $O(n^5)$。

代码如下。


```cpp
void dfs2(int x,int fa){
	for(int i=1;i<=m;i++)dp[x][i][0]=1;
	for(int i:g[x]){
		if(i==fa)continue;
		dfs2(i,x);
		ll f[N][N]={0};
		for(int j=1;j<=m;j++){
			for(int k=0;k<=n;k++){//当前节点的颜色和标记数量 
				int tmp=0;
				for(int l2=0;l2<=k;l2++){
					f[j][k]+=dp[x][j][k-l2]*summ[i][j][l2]%mod;
					f[j][k]%=mod;
				}
			}
		}
		for(int j=1;j<=m;j++)for(int k=0;k<=n;k++)dp[x][j][k]=f[j][k];
	}
	for(int j=n;j>=1;j--)dp[x][mark][j]=dp[x][mark][j-1];
	dp[x][mark][0]=0;
	for(int j=1;j<=m;j++){
		for(int k=0;k<=n;k++){
			for(int l=1;l<=m;l++){
				if(s[j][l])continue;
				summ[x][j][k]+=dp[x][l][k];
			}
		}
	}
}
```

---

## 作者：UniGravity (赞：1)

首先发现移动路径一定是从根节点到叶子的一条路径。因此一个限制 $(a_i,b_i)$ 相当于不能存在一个点使得其权值为 $b_i$ 且父亲的权值为 $a_i$。

接下来如果直接弄不太好做。

因此我们考虑 $c_i\ge\left\lfloor\frac n2\right\rfloor$ 会带来什么性质。考虑如果一个数选到大于 $\left\lfloor\frac n2\right\rfloor$，则显然其它猫粮的数量均小于等于 $\left\lfloor\frac n2\right\rfloor$，即此时对其它猫粮的数量没有限制。

那么如果存在一个猫粮的数量超过一半我们就会做了：记 $g_{x,t,v,c}$ 表示 $x$ 的子树内 $x$ 的值为 $t$ 且出现了 $v$ 次值 $c$ 的合法方案数。这是一个树上背包，复杂度是 $O(n^5)$ 的（$n,m$ 同阶）。

然后考虑如果全部猫粮出现次数都小于 $\left\lfloor\frac n2\right\rfloor$ 怎么做。发现如果正着记录出现次数防止超过一半很困难。因此考虑容斥，先 dp 出不考虑猫粮次数限制的合法答案，然后减去存在一个猫粮出现次数大于一半的答案。这些都可以在树形 dp 时顺便处理出来。

```cpp
const int N=55,P=353442899;
int n,m,t,c[N];
vector<int>e[N];
bool lim[N][N];

int f[N][N],g[N][N][N][N];// point i cnt[j]=k
int tf[N],tg[N][N][N],s[N][N],siz[N];
il void addto(int &x,int y){x+=y;if(x>=P)x-=P;}
il void delto(int &x,int y){x-=y;if(x<0)x+=P;}
// int cnt1=0;
il void dfs(int x,int fa){
    siz[x]=1;
    forto(c,1,m){
        f[x][c]=1;
        forto(c2,1,m)g[x][c][c2][0]=1;
        g[x][c][c][0]=0,g[x][c][c][1]=1;
    }
    for(int y:e[x])if(y!=fa){
        dfs(y,x),siz[x]+=siz[y];
        forto(tp,1,m){
            tf[tp]=f[x][tp],f[x][tp]=0;
            forto(val,1,m)forto(cnt,0,n)tg[tp][val][cnt]=g[x][tp][val][cnt],g[x][tp][val][cnt]=0;
        }
        forto(tp,1,m){
            forto(val,1,m)forto(cnt,0,n)s[val][cnt]=0;
            forto(ptp,1,m){
                if(lim[tp][ptp])continue;
                addto(f[x][tp],1ll*tf[tp]*f[y][ptp]%P);
                forto(val,1,m)forto(cnt,0,n)addto(s[val][cnt],g[y][ptp][val][cnt]);
            }
            forto(val,1,m)forto(cnt,0,n)forto(c1,0,cnt){
                addto(g[x][tp][val][cnt],1ll*tg[tp][val][c1]*s[val][cnt-c1]%P);//cnt1++;
            }
        }
    }
}

signed main(){
    n=read(),m=read(),t=read();
    forto(i,1,m)c[i]=read();
    int x,y;forto(i,2,n)x=read(),y=read(),e[x].eb(y),e[y].eb(x);
    forto(i,1,t)x=read(),y=read(),lim[x][y]=1;
    dfs(1,0);//cerr<<cnt1<<'\n';
    int ans=0;
    forto(v,1,m){
        addto(ans,f[1][v]);//cerr<<v<<": "<<f[1][v]<<'\n';
        forto(val,1,m)forto(cnt,c[val]+1,n)delto(ans,g[1][v][val][cnt]);
    }
    printf("%d\n",ans);
    return 0;
}
```

---


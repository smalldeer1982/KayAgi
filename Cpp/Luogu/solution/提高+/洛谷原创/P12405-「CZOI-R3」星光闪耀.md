# 「CZOI-R3」星光闪耀

## 题目背景

> 今夜星光闪闪 我爱你的心满满 ……

## 题目描述

天空中有一个包含 $n$ 颗星星的星团。

小 K 认为天空中只有一个星团不够浪漫，因此她准备施展魔法。若在她施展魔法前第 $i$ 个星团包含 $a_i$ 颗星星，且 $a_i\ge2$；则施展魔法后天空中**分别**增加包含 $1\sim a_i-1$ 颗星星的星团（注意原本的星团会被保留）。

小 K 定义一个包含 $v$ 颗星星的星团的**闪耀度**为 $k^v$。求她施展 $m$ 次魔法后，天空中所有星团的**闪耀度**之和，对 $998244353$ 取模。

------------
**【形式化题意】**

给定一个可重集 $S_0$，初始 $S_0$ 中只有一个数 $n$。

定义一次操作为：新建一个可重集 $S_1$，对于 $\forall1\le i\le|S_0|$，若 $S_{0,i}\ge 2$，则对于 $\forall1\le j\le S_{0,i}-1$，将 $j$ 加入 $S_1$。在这次操作的最后，将 $S_1$ 中所有元素加入 $S_0$。

求进行了 $m$ 次操作后的 $\sum_{i=1}^{|S_0|} k^{S_{0,i}}$，对 $998244353$ 取模。

## 说明/提示

**【样例解释】**

以下记 $L_i$ 表示包含 $i$ 颗星星的星团的个数，即 $S_{0,j}=i$ 的个数。

第 $1$ 组测试数据中：
- 第一次施展魔法（进行操作）后 $L_1=1,L_2=1,L_3=1$。
- 第二次施展魔法（进行操作）后 $L_1=3,L_2=2,L_3=1$。
- 第三次施展魔法（进行操作）后 $L_1=6,L_2=3,L_3=1$。
- 第四次施展魔法（进行操作）后 $L_1=10,L_2=4,L_3=1$。

因此答案为 $10\times6^1+4\times6^2+1\times6^3=420$。

第 $2$ 组测试数据中：
- 第一次施展魔法（进行操作）后 $\forall1\le i\le n,L_i=1$。
- 第二次施展魔法（进行操作）后 $\forall1\le i\le n,L_i=n-i+1$。

因此答案为 $\sum_{i=1}^n(n-i+1)5^i=610340$。

**【数据范围】**

**本题采用捆绑测试**。

记 $\sum n,\sum m$ 分别为单个测试点内 $n,m$ 的和。

- Subtask #1（$5\text{ pts}$）：$k=0$。
- Subtask #2（$10\text{ pts}$）：$n\le5$ 且 $m\le5$。
- Subtask #3（$10\text{ pts}$）：$m\le3$。
- Subtask #4（$10\text{ pts}$）：$k=1$。
- Subtask #5（$10\text{ pts}$）：$n\le2\times10^2$ 且 $m\le2\times10^2$ 且单个测试点内的 $k$ 相等。
- Subtask #6（$10\text{ pts}$）：$n\le2\times10^3$ 且 $m\le2\times10^3$ 且单个测试点内的 $k$ 相等。
- Subtask #7（$15\text{ pts}$）：$\sum n\le2\times10^7$。
- Subtask #8（$15\text{ pts}$）：$\sum m\le2\times10^6$。
- Subtask #9（$15\text{ pts}$）：无特殊限制。

对于 $100\%$ 的数据，$1\le T\le5\times10^5$，$1\le n\le2\times10^6$，$1\le m\le2\times10^6$，$\sum m\le2\times10^7$，$0\le k\le998244352$。

**本题 IO 量较大，请采用较快的 IO 方式。**

## 样例 #1

### 输入

```
5
3 4 6
8 2 5
501 501 6
11451 41919 313172124
824431 960532 10000007```

### 输出

```
420
610340
520860091
95420244
42443525```

# 题解

## 作者：CaiZi (赞：12)

观察一下每次施展魔法后 $S_0$ 的变化，可以得到最终答案为：
$$\sum_{i_1=1}^{n}\sum_{i_2=1}^{i_1}\cdots\sum_{i_{m-1}=1}^{i_{m-2}}\sum_{i_m=1}^{i_{m-1}}k^{i_m}$$

考虑用一次等比数列求和公式，得到答案为：
$$\dfrac{\sum_{i_1=1}^{n}\sum_{i_2=1}^{i_1}\cdots\sum_{i_{m-1}=1}^{i_{m-2}}(k^{i_{m-1}+1}-k)}{k-1}$$
拆开括号，得：
$$\dfrac{(\sum_{i_1=1}^{n}\sum_{i_2=1}^{i_1}\cdots\sum_{i_{m-1}=1}^{i_{m-2}}k^{i_{m-1}+1})-k(\sum_{i_1=1}^{n}\sum_{i_2=1}^{i_1}\cdots\sum_{i_{m-1}=1}^{i_{m-2}}1)}{k-1}$$
我们发现前一个括号里面又是一个等比数列求和，可以递归下去继续算，直到算到没有 $\sum$。

然后我们要求出：
$$\sum_{i_1=1}^{n}\sum_{i_2=1}^{i_1}\cdots\sum_{i_{p-1}=1}^{i_{p-2}}\sum_{i_p=1}^{i_{p-1}}1$$

然后我们不难发现，这个式子等价于值域为 $[1,n]$、长度为 $p$、单调不递增的序列 $\{i_p\}$ 的个数。我们设 $a_j$ 表示 $j$ 在 $\{i_p\}$ 中的出现次数，由于序列 $\{i_p\}$ 单调不递增，所以每个 $\{i_p\},\{a_n\}$ 唯一对应。于是我们可以把问题转化为，求 $\sum_{j=1}^{n}a_j=p$ 的非负整数序列 $\{a_n\}$ 的个数。这是一个典型的[插板法](https://oi-wiki.org/math/combinatorics/combination/#%E9%9D%9E%E8%B4%9F%E6%95%B4%E6%95%B0%E5%92%8C%E7%9A%84%E6%95%B0%E7%9B%AE)问题，答案为 $\dbinom{n+p-1}{p}$。注意 $p=0$ 时值为 $1$。

注意当 $k=1$ 时不能用等比数列求和公式，但本质就是上面的 $p=m$ 的情况，直接输出 $\dbinom{n+m-1}{m}$ 即可。

实际实现时，可以把递归改成递推，避免被卡常。

$O(1)$ 求组合数，时间复杂度为 $O(n+\sum m)$。

代码展示：
```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 998244353
using namespace std;
int t,n,m,k,fac[4000001],inv[4000001],facinv[4000001],invk1,invk2,ans;
inline int qpow(int a,int b,int c=1){
	while(b){
		if(b&1){
			c=c*a%mod;
		}
		a=a*a%mod;
		b>>=1;
	}
	return c;
}
inline int binom(int a,int b){
	return fac[a]*facinv[b]%mod*facinv[a-b]%mod;
}
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	fac[0]=facinv[0]=inv[1]=1;
	for(int i=2;i<=4000000;i++){
		inv[i]=mod-inv[mod%i]*(mod/i)%mod;
	}
	for(int i=1;i<=4000000;i++){
		fac[i]=fac[i-1]*i%mod;
		facinv[i]=facinv[i-1]*inv[i]%mod;
	}
	cin>>t;
	while(t--){
		cin>>n>>m>>k;
		if(k==1){
			ans=binom(n+m-1,m);
		}
		else{
			invk1=qpow(k,mod-2);
			invk2=qpow(k-1,mod-2);
			ans=qpow(k,n+m);
			k=qpow(k,m);
			for(int i=1;i<=m;i++){
				ans=(ans-binom(n+i-2,i-1)*k%mod+mod)%mod*invk2%mod;
				k=k*invk1%mod;
			}
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```
最后来玩个游戏吧，把 $n=656,m=960,k=17$ 时的答案写在纸上，快速塞给你同桌并唱出题目背景给出的歌，然后后把同桌的反应分享在评论区（doge）。

---

## 作者：Monomial (赞：11)

看到奇怪的限制 $\sum m \leq 2 \times 10^{7}$，考虑从这上面入手。

我们考虑一轮中的 $k^{v}$ 会对下一轮产生什么贡献，其应当是 $k^{v-1},k^{v-2},\dots,k^{2},k^{1}$。这个是等比数列的形式，只是缺掉了 $k^{0}$。

那么，$k^{v}$ 对下一轮的贡献就是 $\frac{k^{v}-1}{k-1}-1$，总贡献是 $-c+\sum \frac{k^{a_{i}}-1}{k-1}$，$\frac{1}{k-1}$ 提出来得到 $-c+\frac{1}{k-1} \sum k^{a_{i}}-1$，也就是 $-c+\frac{1}{k-1} ((\sum k^{a_{i}})-c)$，其中 $c$ 为当前轮的星团总数。

$\sum k^{a_{i}}$ 是前一轮的答案，可以直接得到。$c$ 的计算同样比较简单，设当前为第 $x$ 轮（最初为第 $1$ 轮），那么 $c=\binom{n+x-1}{x}$。考虑证明。我们把序列倒过来，即 $k^{n}$ 的出现次数在前面，$k^{1}$ 的在后面，那么有第 $i$ 轮的第 $j$ 个位置为 $\binom{i+j-2}{j-1}$，就有 $c=\sum\limits_{i=1}^{n} \binom{x+i-2}{i-1}=\sum\limits_{i=0}^{n-1} \binom{x+i-1}{i}=\sum\limits_{i=0}^{n-1} \binom{x+i-1}{x-1}=\binom{n+x-1}{x}$，最后一步是组合恒等式。

注意 $k\leq 1$ 要特判，而且不要忘了加上前一轮的答案。

时间复杂度 $\mathcal{O}(\sum m)$。

---

## 作者：LostKeyToReach (赞：8)

我们定义 $f_{k}(i)$ 为操作 $k$ 步后大小为 $i$ 的星团数量，那么答案为：

$$
a_m = \sum_{i = 1} ^ n f_{m}(i)k^i.
$$

开始推导 $a$：

$$
\begin{aligned}
a_x &= a_{x - 1} + \sum_{i = 2} ^ n f_{x - 1}(i)\frac{k(k^{i - 1} - 1)}{k - 1} \\
&= a_{x - 1} + \frac{k}{k - 1}\left(\sum_{i = 2} ^ n f_{x - 1}(i)k^{i - 1} - \sum_{i = 2} ^ n f_{x - 1}(i)\right) \\ &= a_{x - 1} + \frac{k}{k - 1}\left\{\frac{a_{x - 1}}{k} - f_{x - 1}(1) - \left[{n+ x - 2 \choose x - 1} - f_{x - 1}(1)\right]\right\} \\
&= a_{x - 1} + \frac{k}{k - 1}\left[\frac{a_{x - 1}}{k} - {n +x - 2 \choose x - 1}\right] \\
&= a_{x - 1} +\frac{a_{x - 1} - k{n + x - 2 \choose x - 1}}{k - 1} \\
&= \frac{k}{k - 1}\left[a_{x - 1} - {n + x - 2 \choose x - 1}\right].
\end{aligned}
$$

$O(m)$ 递推即可。

---

## 作者：hyk2019 (赞：7)

$\gdef\mat#1#2{\begin{pmatrix}#1\\#2\end{pmatrix}}$

upd：由于赛后发现了捷径，将 $k=1$ 更换为简便解法。

部分分：
- $k=0$：所有星团的闪耀度都是 $0$，所以总和还是 $0$。
- $k=1$：数星团个数，见下。

---

正解：巧妙的推式子。

这里先假设 $k\ge2$。

一个大小为 $v$ 的星团，会生出大小为 $1\sim v-1$ 之间所有整数的星团。按照题目的要求，我们最终要求所有星团的闪耀度之和，而一个星团的闪耀度是 $k^v$。想一想，一次操作后会对星团的闪耀度之和有什么影响？

$$
k^v\rightarrow\sum_{i=1}^{v-1}k^i
$$

右边是等比数列，如何求和？

$$
\sum_{i=1}^{v-1}k^i=(\sum_{i=0}^{v-1}k^i)-1=\frac{k^v-1}{k-1}-1
$$

如果 $u_{a,i}$ 表示经过 $a$ 次操作后大小为 $i$ 的星团的数量，那么闪耀度之和 $S_a$ 可以看成什么？

$$
S_a=\sum_{i=1}^nu_{a,i}\times k^i
$$

如何转移到 $S_{a+1}$？

$$
\begin{aligned}
S_{a+1}
&=S_a+\sum_{i=1}^nu_{a,i}\times (\frac{k^i-1}{k-1}-1)\\
&=S_a+\frac1{k-1}\times((\sum_{i=1}^nu_{a,i}\times k^i)-(\sum_{i=1}^nu_{a,i}))-(\sum_{i=1}^nu_{a,i})\\
&=S_a+\frac{S_a-T_a}{k-1}-T_a
\end{aligned}
$$

上面的 $T_a=\sum_{i=1}^nu_{a,i}$ 表示的就是星团个数。

---

$k=1$ 部分分：解 $T_a$ 的值。

$u_{a,i}$ 的递推规则如下：

$$
u_{a,i}=\sum_{j=i}^nu_{a-1,j}
$$

如何将其简化？

当 $a>0$ 时：

$$
u_{a,i}=\begin{cases}1&i=n\\u_{a-1,i}+u_{a,i+1}&1\le i<n\end{cases}
$$

当 $a=0$ 时：

$$
u_{0,i}=\begin{cases}1&i=n\\0&1\le i<n\end{cases}
$$

实际上，当 $a=1$ 时，$u_{1,i}=1$。所以接下来的这一部分看着很像杨辉三角？

这样，当 $a\ge1$ 时，就可以进一步将递推公式简化成通项公式：

$$
u_{a,i}=\mat{a+n-i-1}{a-1}
$$

因为每一个星团在下一次操作中都要生成一个大小为 $1$ 的星团（包括自己），所以：

$$
T_{a}=u_{a+1,1}=\mat{a+n-1}a
$$

如果赛时不会推式子，也可以打表，可以得出同样的结论。

---

$T_a$ 解决了，$S_a$ 也解决了，那么整条思路就打通了。

我们已知 $S_0=k^n$，接下来只要根据公式 $S_{a+1}=S_a+\frac{S_a-T_a}{k-1}-T_a$ 和 $T_{a}=\mat{a+n-1}a$ 转移到 $a=m$ 即可。

预处理每个数的逆元，最终时间复杂度 $O(\sum m)$。

---


```cpp
#include <bits/stdc++.h>
using namespace std;

const long long MOD = 998244353;
int T, N, M;
long long K, I[4000006], F[4000006];

long long power(long long x, long long y) {
    if(y == 0)
        return 1;
    if(y == 1)
        return x;
    long long w = power(x * x % MOD, y >> 1);
    if(y & 1)
        return w * x % MOD;
    else
        return w;
}

int main() {
    F[0] = 1;
    int U = 4000005;
    for(int i = 1; i <= U; i ++)
        F[i] = F[i - 1] * i % MOD;
    I[U] = power(F[U], MOD - 2);
    for(int i = U - 1; i; i --)
        I[i] = I[i + 1] * (i + 1) % MOD;
    I[0] = 1;
    scanf("%d", &T);
    while(T --) {
        scanf("%d%d%lld", &N, &M, &K);
        if(K == 0) {
            puts("0");
            continue;
        }
        long long w = power(K, N), inv = power(K - 1, MOD - 2), C = 1;
        for(int i = 1; i <= M; i ++) {
            if(K > 1)
                w = ((w + (w - C) * inv - C) % MOD + MOD) % MOD;
            C = F[N + i - 1] * I[i] % MOD * I[N - 1] % MOD;
        }
        printf("%lld\n", K == 1 ? C : w);
    }
    return 0;
}
```

---

## 作者：H3PO4 (赞：7)

Let $a_{j,x}=|\{i:S_{j,i}=x\}|$ where $S_j$ denotes $S_0$ after $j$ operations. Let $b_{j,x}=a_{j,n-x}$. Then the initial state is $b_{0,0}=a_{0,n}=1$ and the $j$th operation can be expressed as $\forall x=1,2,\dots,n: b_{j,x}\gets \sum_{t=0}^x b_{j-1,t} \space (a_{j,x} \gets \sum_{t=x}^n a_{j-1,t})$. The final answer is obviously $\sum_{x=1}^n a_{m,x} k^x$.

Let $B_j(z)=\sum_{k\geqslant 0}b_{j,k} z^k$. Then $B_0(z)=1$ and $B_j(z)=\frac{1}{1-z} B_{j-1}(z)$. Thus $B_j(z)=(1-z)^{-j}=\sum_{k\geqslant 0}\binom{k+j-1}{j-1}z^k \implies a_{m,x}=b_{m,n-x}=\binom{m'+n-x}{m'}$ where $m'=m-1$.

Denote the final answer as $S_{m'}=\sum_{x=1}^n \binom{m'+n-x}{m'} k^x$. Let $S_j=\sum_{x=1}^n \binom{j+n-x}{j} k^x=k^n \sum_{x=0}^{n-1} \binom{j+x}{j} k^{-x}=k^n s_j(\frac{1}{k})$. Then
$$\begin{aligned}
s_j(t)&=\sum_{x=0}^{n-1} \binom{j+x}{j} t^x\\
&=\sum_{x=0}^{n-1} \left(\binom{j+x-1}{j}+\binom{j+x-1}{j-1}\right) t^x\\
&=t\sum_{x=-1}^{n-2} \binom{j+x}{j} t^x + s_{j-1}(t)\\
&=t s_j(t) - \binom{j+n-1}{j} t^n+ s_{j-1}(t)\\
s_j(t)&=\frac{s_{j-1}(t)-\binom{j+n-1}{j} t^n}{1-t}\quad(t\neq 1)
\end{aligned}$$
and $s_0(t)=\sum_{x=0}^{n-1}t^x=\frac{1-t^n}{1-t}\space(t\neq 1)$. If $t=1$ then $k=1$ and $S_{m'}=\sum_{x=0}^{n-1} \binom{m'+x}{m'}=\frac{n}{m}\binom{m'+n}{n}$. A direct implementation of this with proper precalculation can achieve a time complexity of $O(n+\sum m)$.

```cpp
#include<bits/stdc++.h>
using I=uint64_t;
template<class T>using V=std::vector<T>;
template<class T,I N>using A=std::array<T,N>;
int main(){
  const I P=998244353;
  A<I,10+(I)4e6>inv,fac,finv;
  fac[0]=finv[0]=fac[1]=finv[1]=inv[1]=1;
  for(I i=2;i<inv.size();i++){
    inv[i]=(P-P/i)*inv[P%i]%P;
    fac[i]=i*fac[i-1]%P;
    finv[i]=inv[i]*finv[i-1]%P;
  }
  
  auto C=[&](I n,I k){return fac[n]*finv[k]%P*finv[n-k]%P;};
  auto pw=[&](I x,I y){I w=1;for(;y;x=x*x%P,y>>=1)if(y&1)w=w*x%P;return w;};

  auto solve=[&](){
    I n,m,k;std::cin>>n>>m>>k;m--;
    if(k==0){std::cout<<"0\n";return;}
    if(k==1){std::cout<<n*C(m+n,m)%P*inv[m+1]%P<<'\n';return;}
    I v=pw(k,P-2);  

    I vn=pw(v,n),vv=pw(1-v+P,P-2);
    I w=(1-pw(v,n)+P)%P*vv%P;
    for(I i=1;i<=m;i++)w=(w-C(i+n-1,i)*vn%P+P)*vv%P;
    w=w*pw(k,n)%P;
    std::cout<<w<<'\n';
  };

  std::cin.tie(0)->sync_with_stdio(0);
  I t;std::cin>>t;while(t--)solve();
  return 0;
}
```

After the contest, many have claimed that they had easily simplified the expression of the final answer. As my solution is quite complicated, I wonder what simple solutions they had thought of.

---

## 作者：yzljy (赞：3)

[到我的博客获得更佳阅读体验](https://yzljyawa.github.io/OI/洛谷-P12405-「CZOI-R3」星光闪耀/)

题意在此就不再简述了，主要是提供另一种做法。

## 观察

通过观察样例解释一，不难猜想其符合杨辉三角，通过打表简单验证一下发现是正确的，具体的证明过程这里就不放了。  
于是到此，你便获得了一个 $O(\sum n)$ 的做法。  
但本题只限制了 $\sum m$ 的值，并没有限制 $\sum n$，于是你只能通过 sub2，sub5，sub7，获得 $35$ 分。  
似乎优化是没有什么前途的，但实际上，我们可以通过推式子，将其转化为 $O(\sum m)$ 的。

## 思路

我们不妨先写出前面 $O(\sum n)$ 的式子。  

$$
ans=\sum_{i=0}^{n-1}
  \begin{pmatrix}
    m-1+i\\
    m-1\\
  \end{pmatrix}
  k^{n-i}\\
$$

在下文中，为了方便，我们都先将 $m$ 减少 $1$。

那么原式子就变成了：

$$
ans=\sum_{i=0}^{n-1}
  \begin{pmatrix}
    m+i\\
    m\\
  \end{pmatrix}
  k^{n-i}\\
$$

发现这个式子类似于 $\sum\limits_{i=0}^{n-1}k_{i}a^{i}$，不难想到利用类似于等比数列求和的方式来解决。  
我们令：

$$
f(m)=\sum_{i=0}^{n-1}\begin{pmatrix}m+i\\m\\\end{pmatrix}k^{n-i}
$$

两边同时乘以 $k$，得到：

$$
kf(m)=\sum_{i=0}^{n-1}\begin{pmatrix}m+i\\m\\\end{pmatrix}k^{n-i+1}
$$

这两个式子相减，得到：

$$
(k-1)f(m)=
  k^{n+1}+
  \sum_{i=0}^{n-2}
  \left(
  \begin{pmatrix}
    m+i+1\\
    m\\
  \end{pmatrix}-
  \begin{pmatrix}
    m+i\\
    m\\
  \end{pmatrix}
  \right)
  k^{n-i}-
  \begin{pmatrix}
    m+n-1\\
    m\\
  \end{pmatrix}
  k
$$

中间的两个组合数相减是可以化简的，等于 $\begin{pmatrix}m+i\\m-1\\\end{pmatrix}$。

那么我们的 $f(m)$，也就等于：

$$
f(m)=
  \dfrac{
  k^{n+1}+
  \sum\limits_{i=0}^{n-2}
  \begin{pmatrix}
    m+i\\
    m-1\\
  \end{pmatrix}
  k^{n-i}-
  \begin{pmatrix}
    m+n-1\\
    m\\
  \end{pmatrix}
  k}
  {k-1}\\
$$

我们将中间的 $\sum\limits_{i=0}^{n-2}\begin{pmatrix}m+i\\m-1\\\end{pmatrix}k^{n-i}$ 单独提出来考虑。

发现我们枚举的范围，从 $[0,n-1]$ 变成了 $[0,n-2]$，同时组合数中，下面的数，也从 $m$ 变成了 $m-1$。  
那么我们不妨将原来的 $f(m)$ 改写成如下形式：

$$
f(m)=
  \sum_{i=0}^{n-1-(M-m)}
  \begin{pmatrix}
    M+i\\
    m\\
  \end{pmatrix}
  k^{n-i}\\
$$

其中式子中的 $M$ 表示的是**输入**的 $m$ 的值减少 $1$，**式子中**的 $m$ 则表示一个自变量。

重新推一下式子：

$$
\begin{aligned}
  f(m)=&
  \sum_{i=0}^{n-1-(M-m)}
  \begin{pmatrix}
    M+i\\
    m\\
  \end{pmatrix}
  k^{n-i}\\
  kf(m)=&
  \sum_{i=0}^{n-1-(M-m)}
  \begin{pmatrix}
    M+i\\
    m\\
  \end{pmatrix}
  k^{n-i+1}\\
  (k-1)f(m)=&
  \begin{pmatrix}
    M\\
    m\\
  \end{pmatrix}
  k^{n+1}+
  \sum_{i=0}^{n-2-(M-m)}
  \left(
  \begin{pmatrix}
    M+i+1\\
    m\\
  \end{pmatrix}-
  \begin{pmatrix}
    M+i\\
    m\\
  \end{pmatrix}
  \right)
  k^{n-i}-
  \begin{pmatrix}
    m+n-1\\
    m\\
  \end{pmatrix}
  k^{1+(M-m)}\\
  (k-1)f(m)=&
  \begin{pmatrix}
    M\\
    m\\
  \end{pmatrix}
  k^{n+1}+
  \sum_{i=0}^{n-2-(M-m)}
  \begin{pmatrix}
    M+i\\
    m-1\\
  \end{pmatrix}
  k^{n-i}-
  \begin{pmatrix}
    m+n-1\\
    m\\
  \end{pmatrix}
  k^{1+(M-m)}\\
  (k-1)f(m)=&
  \begin{pmatrix}
    M\\
    m\\
  \end{pmatrix}
  k^{n+1}+
  f(m-1)-
  \begin{pmatrix}
    m+n-1\\
    m\\
  \end{pmatrix}
  k^{1+(M-m)}\\
  f(m)=&
  \dfrac{
  \begin{pmatrix}
    M\\
    m\\
  \end{pmatrix}
  k^{n+1}+
  f(m-1)-
  \begin{pmatrix}
    m+n-1\\
    m\\
  \end{pmatrix}
  k^{1+(M-m)}
  }
  {k-1}\\
\end{aligned}
$$

不难发现是一个递归的形式，$f(0)=\sum\limits_{i=0}^{n-M-1}k^{n-i}=\sum\limits_{i=0}^{n}k^{i}-\sum\limits_{i=0}^{M}k^{i}$，这个是可以通过两个等比数列求和公式在 $O(1)$ 的时间内得到的。  

于是，我们便将原来 $O(n)$ 的式子，转化成了递归形式的 $O(m)$ 的式子。

## 细节

首先，我们观察到 $f(m)$ 的式子中，随着 $m$ 的降低，$\sum\limits_{i=0}^{n-1-(M-m)}$ 中的 $n-1-(M-m)$ 是在不断减少的。  
那么当 $n-1-(M-m)$ 先减到 $-1$ 的时候，也就是当 $n\le M$ 的时候，这个式子就寄掉了，但是这个时候，我们又可以用最开始的式子了。

还有一处细节。  
当 $k=0$ 或者 $k=1$ 的时候，我们推导出来的式子也不管用了。  
这时候简单推一下，可以得出 $O(1)$ 的计算公式，这个式子我就不推了。

最后，因为 $\sum m\le 2\times 10^7$，这是比较大的。我们要减少快速幂的使用，所以对于原先的递归式子，我们在实现的时候，写成迭代，这样在迭代求解的过程中，是可以不用到快速幂的。

## 代码

```cpp
// Problem: P12405 「CZOI-R3」星光闪耀
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P12405
// Memory Limit: 512 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=4e6+10;
const int mod=998244353;
const int inf_int=0x7f7f7f7f;
const long long inf_long=0x7f7f7f7f7f7f7f7f;
const double eps=1e-9;
char Buf[1<<23],*P1=Buf,*P2=Buf;
#define getchar() (P1==P2&&(P2=(P1=Buf)+fread(Buf,1,1<<23,stdin),P1==P2)?EOF:*P1++)
template<typename type>
inline void read(type &x){
	x=0;
	bool f=false;
	char ch=getchar();
	while(ch<'0'||ch>'9') f|=ch=='-',ch=getchar();
	while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=getchar();
	if(f) x=-x;
}
template<typename type,typename... args>
inline void read(type &x,args&... y){
	read(x),read(y...);
}

int T,n,m,k,ans,fac[MAXN],inv[MAXN];

int C(int a,int b){
	return fac[a]*inv[b]%mod*inv[a-b]%mod;
}

int qpow(int x,int y){
	int res=1;
	while(y){
		if(y&1) res=res*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return res;
}

signed main(){
	read(T);
	fac[0]=1;
	for(int i=1;i<=4e6;i++) fac[i]=fac[i-1]*i%mod;
	inv[4000000]=qpow(fac[4000000],mod-2);
	for(int i=4e6-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;
	while(T--){
		read(n,m,k);m--;
		ans=0;
		int invk=qpow(k,mod-2);
		if(k==0) ans=0;
		else if(k==1) ans=C(m+n,m+1);
		else if(n<=m+1){
			int z=qpow(k,n);
			for(int i=0;i<=n-1;i++){
				(ans+=C(m+i,i)*z%mod)%=mod;
				z=z*invk%mod;
			}
		}
		else{
			int val1=qpow(k,n+1),val2=qpow(k-1,mod-2),val3=qpow(k,m);
			ans=((val1-1+mod)%mod*val2%mod-(qpow(k,m+1)-1+mod)%mod*val2%mod+mod)%mod;
			for(int i=1;i<=m;i++){
				ans=(C(m,i)*val1%mod+ans-C(i+n-1,i)*val3%mod+mod)%mod*val2%mod;
				val3=val3*invk%mod;
			}
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：cly312 (赞：3)

令 $C_t(i)$ 表示第 $t$ 次操作后大小为 $i$ 的星团的数量。

容易得到 $C_t = \binom{n+t-1}{t}$。

定义 $P_t(x)=\sum_{i\ge1}C_t(i)x^i$。

要求的答案就是 $P_m(k)=\sum_{i\ge1}C_m(i)k^i \pmod {998244353}$。

分析每次操作：对于每个大小为 $i\ge2$ 的星团（有 $C_t(i)$ 个），都增加了 $\sum_{j=1}^{i-1} x^j$ 到总和中。

$$P_{t+1}(x)=P_t(x)+\sum_{i\ge2}C_t(i)\sum_{j=1}^{i-1} x^j$$
$$
\begin{aligned}
&= \frac{x}{x-1} \sum_{i\ge2} C_t(i) (x^{i-1} - 1) \\
&= \frac{x}{x-1} \left[ \sum_{i\ge2} C_t(i) x^{i-1} - \sum_{i\ge2} C_t(i) \right] \\
&= \frac{x}{x-1} \left[ \frac{1}{x} (P_t(x) - C_t(1)x) - (C_t - C_t(1)) \right] \\
&= \frac{1}{x-1} \left( P_t(x) - C_t(1)x \right) - \frac{x}{x-1} \left( C_t - C_t(1) \right) \\
&= \frac{P_t(x)}{x-1} - \frac{C_t(1)x}{x-1} - \frac{x C_t}{x-1} + \frac{x C_t(1)}{x-1} \\
&= \frac{P_t(x)}{x-1} - \frac{x C_t}{x-1}.
\end{aligned}
$$

令 $Ans(t)$ 表示第 $t$ 次操作后所有星团的闪耀度之和。即 $Ans(t)=P_t(k)$。

将 $x=k$ 代入上式（需要 $k\neq 1$)，得 $  Ans(t+1)=Ans(t) \cdot \frac{k}{k-1} -\frac{kC_t}{k-1}\pmod {P}$。

令 $K=\frac{k}{k-1} \pmod{P}$。

递推关系变为：$Ans(t+1) = K \cdot Ans(t) - K \cdot C_t \pmod{P}$，直接递推即可。

边界情况：$k=1$，总闪耀度就是星团的总个数，$m$ 次操作后的总个数为 $C_m = \binom{n+m-1}{m}$。直接计算即可。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll P=998244353;
ll qpow(ll a,ll b){
	ll res=1;
	a%=P;
	while(b>0){
		if(b&1) res=(res*a)%P;
		a=(a*a)%P;
		b/=2;
	}
	return res;
}
ll mod_inv(ll n){
	return qpow(n,P-2);
}
const int MAXN=4000005;
ll fact[MAXN],invfact[MAXN];
void pre(){
	fact[0]=1;
	for(int i=1;i<MAXN;i++){
		fact[i]=(fact[i-1]*i)%P;
	}
	invfact[MAXN-1]=mod_inv(fact[MAXN-1]);
	for(int i=MAXN-2;i>=0;i--){
		invfact[i]=(invfact[i+1]*(i+1))%P;
	}
}
ll binom(int n,int k){
	if(k<0||k>n||n<0) return 0;
	ll term1=fact[n];
	ll term2=invfact[k];
	ll term3=invfact[n-k];
	return (((term1*term2)%P)*term3)%P;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	pre();
	int T;
	cin>>T;
	while(T--){
		int n,m;
		ll k;
		cin>>n>>m>>k;
		if(k==1){
			cout<<binom(n+m-1,m)<<'\n';
			continue;
		}
		ll k_minus_1=(k-1+P)%P;
        ll k_minus_1_inv=mod_inv(k_minus_1);
        ll K_val=(k*k_minus_1_inv)%P;
        ll ans=qpow(k,n);
        for (int t=0;t<m;++t) {
             ll C_t=binom(n+t-1,t);
             ll sub=(K_val*C_t)%P;
             ans=(K_val*ans)%P;
             ans=(ans-sub+P)%P;
        }
        cout<<ans<<'\n';
	}
}
```

---

## 作者：jiangjiangQwQ (赞：2)

### 思路
设 $S(n,m,k)$ 表示一组 $n,m,k$ 的答案，那么 $S = S(n,m,k) = \sum_{i_1=1}^n \sum_{i_2=1}^{i_1} \cdots \sum_{i_m=1}^{i_{m-1}} k^{i_m}$，相当于对原数组做 $m$ 次后缀和。但这样显然不够优秀，所以考虑将 $m$ 次后缀和转换成组合数快速求解。下面进行分类讨论：
1. 当 $k=1$，直接输出 $m$ 次操作之后的项数即可。
2. 当 $k=0$，无论如何都无贡献。

考虑 $k\notin{0,1}$ 的情况，应用等比数列求和公式到最内层求和：$\sum_{i_m=1}^{i_{m-1}} k^{i_m} = \frac{k^{i_{m-1}+1} - k}{k-1}$。

因此可以重写为：
$S(n,m,k) = \frac{1}{k-1} \left[ \sum_{i_1=1}^n \cdots \sum_{i_{m-1}=1}^{i_{m-2}} k^{i_{m-1}+1} - k \sum_{i_1=1}^n \cdots \sum_{i_{m-1}=1}^{i_{m-2}} 1 \right]$。

发现这是一个递归柿子：

$S(n,m,k) = \frac{S(n+1,m-1,k) - k \cdot S(n,m-1,1)}{k-1}$。

将其进行展开，建议读者用纸笔亲自推导，发现其最终形式为：

$S(n,m,k) = \frac{k^{n+m} - \sum_{i=1}^m \binom{n+i-2}{i-1} k^{m-i+1}}{(k-1)^m}$。

这里补充一下一个关键推导，对于 $S(n,m,1)$，是可以变成 $\dbinom{n+m-1}{m}$。这是为什么呢？借用官方题解的解释就是：我们可以将其看做是一个求解在值域为 $[1,n]$、长度为 $m$ 的单调不递增的序列个数，这是经典的运用插板法的组合数学问题，可以看做是有 $n+m-1$ 块板，如果我们将数字插到前 $n$ 块板上等价于存在于一个序列中，数字可以相同因此可以占用同一块板，问题就转换成了在 $n+m-1$ 个数中选出 $m$ 个，直接组合数即可，所以 $S(n,m,1)=\dbinom{n+m-1}{m}$。
### 吐槽
除了官方题解外其他几乎没有题解提到上述那一步关键推导，直接抛出来。这对于初学读者其实是非常不友好的。

---

## 作者：arrow_king (赞：2)

UPD. 证明补完了 /ll

$O(\sum m+T\log \mathrm{mod}+T\log n)$ 做法。

首先观察一下题目的限制，发现就是个前缀和。（每次操作，元素 $1$ 会对 $2\sim n$ 都产生一次贡献，其他同理）

~~众所周知~~，对序列 $a_0=1,a_n=0$（$n>0$）进行 $m$ 次前缀和之后有通项公式 $a_i=\dbinom{i+m-1}i$。因此上式可以写出通项为：
$$
b_{i+1}=\dbinom{i+m-1}{i}k^{i+1},\quad \forall 1\le i\le n
$$
对于 $k=1$ 的特殊情况，直接输出组合数即可。

考虑对原始序列 $b_n=k^n$ 快速进行 $m$ 次前缀和（要求进行一次前缀和的时间复杂度为 $O(1)$）。

不妨设 $s_m(n)$ 为进行 $m$ 次操作后 $n$ 位置的前缀和。可以证明，有递推公式：
$$
\begin{aligned}
s_0(n)&=k^n\\
s_i(n)&=\dfrac{k}{k-1}\left[s_{i-1}-\dbinom{n+i-1}{i}\right]
\end{aligned}
$$
~~证明可以归纳，占篇幅不写了。~~

![](https://cdn.luogu.com.cn/upload/image_hosting/tz0iw2xj.png)

$s_0$ 的式子是显然的，考虑归纳，通过写出接下来几个 $s$ 的式子可以看出：
$$
\begin{aligned}
s_1(n)&=\sum_{i=1}^nk^i=\dfrac{k}{k-1}\left(k^n-1\right)=\dfrac{k}{k-1}(s_0(n)-1)\\
s_2(n)&=\sum_{i=1}^ns_1(i)=\dfrac k{k-1}\sum_{i=1}^n(k^i-1)=\dfrac{k}{k-1}\left(s_1(n)-n\right)\\
s_3(n)&=\sum_{i=1}^ns_2(i)=\dfrac{k}{k-1}\sum_{i=1}^n(s_1(i)-i)=\dfrac{k}{k-1}\left[s_2(n)-\dbinom{n+1}2\right]
\end{aligned}
$$
以此类推，可以得到：
$$
\begin{aligned}
s_{m+1}(n)&=\sum_{i=1}^ns_m(i)=\dfrac{k}{k-1}\sum_{i=1}^n\left[s_{m-1}(i)-\dbinom{i+m-1}i\right]\\
&=\dfrac{k}{k-1}\left[s_m(n)-\dbinom{n+m}{m+1}\right]
\end{aligned}
$$
归纳证明完毕。

预处理逆元、组合数即可 $O(1)$ 转移，就做完了。

---

## 作者：TJB_LHY (赞：1)

#### 一些闲话

这道题我已经考了两次试了！开（nan）心（ping）！写个题解纪念一下。

## 考试思路

看了看题面，~~不懂~~。再看看样例解析，看着像……杨辉三角！发现答案似乎是
$$\sum_{i=1}^{n}C^{i-1}_{m-1+(i-1)}\times k^{n-(i-1)}$$
。想到了二项式定理，但写不出来。遗憾打表暴力计算，40 pts。
```cpp
#include<bits/stdc++.h>//赛时代码 
#define ll long long
using namespace std;
const ll mod=998244353;
void read(ll &x) {
	x=0;
	char y=getchar();
	bool flag=0;
	while(y<'0' || y>'9') {
		if(y=='-')flag=1;
		y=getchar();
	}
	while((y>='0' && y<='9')) {
		x=(x<<1)+(x<<3)+(y-'0');
		y=getchar();
	}
	if(flag)x=-x;
}
void write(ll x) {
	if(x<0) {
		putchar('-');
		x=-x;
	}
	if(x<10)putchar(x+'0');
	else {
		write(x/10);
		putchar(x%10+'0');
	}
}
ll n,m,k,kk,ans,fact[20000005],inv[20000005];
ll num;
ll sqr(ll a,ll b){
	num=1;
	a%=mod;
	while(b){
		if(b&1)num=num*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return num;
}//快速幂 
ll C(ll a,ll b){
	if(a<b)return 0;
	return fact[a]*inv[a-b]%mod*inv[b]%mod;
}//阶乘求组合数 
ll la;
signed main() {
	fact[0]=inv[0]=fact[1]=inv[1]=1;
	la=2;
	ll t;
	read(t);
	while(t--){
		read(n);
		read(m);
		read(k);
		if(k==0)puts("0");
		else{
			for(int i=la;i<=n+m;i++){
				fact[i]=fact[i-1]*i%mod;
				inv[i]=sqr(fact[i],mod-2);
			}
			la=max(n+m+1,la);//预处理阶乘 
			ans=0;
			k%=mod;
			kk=k;
			for(int i=n;i>=1;i--,kk=k*kk%mod)ans=(ans+C(m+i-2,i-1)*kk)%mod;//暴力计算 
			write(ans);
			puts("");
		}
	}
	return 0;
}
```
# 思路

我们发现数据范围十分奇怪，有一个 $\sum m\le 2\times 10^7$。我们尝试将 $O(\sum n)$ 转化为 $O(\sum m)$ 的复杂度。于是，~~我们查看了一下[题解](https://www.luogu.com.cn/article/zmv1kp68)~~，发现答案同样可以化为
$$\sum_{x_1=1}^n\sum_{x_2=1}^{x_1}\sum_{x_3=1}^{x_2}\dots\sum_{x_m=1}^{x_{m-1}}k^{x_m}$$
。接下来就很考验推柿子了，由[等比数列求和公式](https://baike.baidu.com/item/%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97%E6%B1%82%E5%92%8C%E5%85%AC%E5%BC%8F/7527367)（$\sum_{i=1}^{n}k^i = (k^{n+1}-k)\times\frac{1}{k-1}$）可知：
$$\begin{aligned}\sum_{x_1=1}^n\sum_{x_2=1}^{x_1}\sum_{x_3=1}^{x_2}\dots\sum_{x_m=1}^{x_{m-1}}k^{x_m} &=\frac{1}{k-1}\sum_{x_1=1}^n\sum_{x_2=1}^{x_1}\sum_{x_3=1}^{x_2}\dots\sum_{x_{m-1}=1}^{x_{m-2}}(k^{x_{m-1}+1}-k)\\&=(\sum_{x_1=1}^n\sum_{x_2=1}^{x_1}\sum_{x_3=1}^{x_2}\dots\sum_{x_{m-1}=1}^{x_{m-2}}k^{x_{m-1}+1}-\sum_{x_1=1}^n\sum_{x_2=1}^{x_1}\sum_{x_3=1}^{x_2}\dots\sum_{x_{m-1}=1}^{x_{m-2}}k)\times\frac{1}{k-1}\\&=(k\sum_{x_1=1}^n\sum_{x_2=1}^{x_1}\sum_{x_3=1}^{x_2}\dots\sum_{x_{m-1}=1}^{x_{m-2}}k^{x_{m-1}}-k\sum_{x_1=1}^n\sum_{x_2=1}^{x_1}\sum_{x_3=1}^{x_2}\dots\sum_{x_{m-1}=1}^{x_{m-2}}1)\times\frac{1}{k-1}\end{aligned}$$
我们设 $f(i)=\sum_{x_1=1}^n\sum_{x_2=1}^{x_1}\sum_{x_3=1}^{x_2}\dots\sum_{x_i=1}^{x_i-1}k^{x_i}$，变形式子为：
$$f(i) = \frac{k\times f(i-1)}{k-1}-(\sum_{x_1=1}^n\sum_{x_2=1}^{x_1}\sum_{x_3=1}^{x_2}\dots\sum_{x_{i-1}=1}^{x_{i-2}}1)\times\frac{k}{k-1}$$
。答案就是 $f(m)$。目前最大的难题就是如何计算 $\sum_{x_1=1}^n\sum_{x_2=1}^{x_1}\sum_{x_3=1}^{x_2}\dots\sum_{x_{i-1}=1}^{x_{i-2}}1$。
这时候我们很容易想到[隔板法](https://www.cnblogs.com/dx123/p/16782224.html)求方案，即上式等价于在 $n$ 个球中插入 $(i-1)$ 个板子且每个板子可在相同的位置的方案数，比较难求。我们可以将球数增多，将原问题变为在 $(n+i-1)$ 个球中插入 $(i-1)$ 个板子且每个板子在不同的位置的方案数，由于 $(n+i-1)$ 个球中有 $(n+i-2)$ 个空，所以方案数即为 $C_{n+i-2}^{i-1}$。变形最后的式子得：
$$\begin{aligned}f(i)&=\frac{k\times f(i-1)}{k-1}-C_{n+i-2}^{i-1}\times\frac{k}{k-1}\\&=(f(i-1)-C_{n+i-2}^{i-1})\times\frac{k}{k-1}\end{aligned}$$
递推得到 $f(m)$ 即可。加上预处理的 $O(\max n+m)$，时间总复杂度为：$O(\max n+\sum m)$。$n\le m$ 时用我考试时的式子更快！
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll mod=998244353;
void read(ll &x) {
	x=0;
	char y=getchar();
	bool flag=0;
	while(y<'0' || y>'9') {
		if(y=='-')flag=1;
		y=getchar();
	}
	while((y>='0' && y<='9')) {
		x=(x<<1)+(x<<3)+(y-'0');
		y=getchar();
	}
	if(flag)x=-x;
}
void write(ll x) {
	if(x<0) {
		putchar('-');
		x=-x;
	}
	if(x<10)putchar(x+'0');
	else {
		write(x/10);
		putchar(x%10+'0');
	}
}
ll n,m,k,kk,invk1,invk2,ans,fact[4000005],inv[4000005],a[4000005];
ll num,la;
ll sqr(ll a,ll b){
	num=1;
	a%=mod;
	while(b){
		if(b&1)num=num*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return num;
}
ll C(ll a,ll b){
	if(a<b)return 0;
	return fact[a]*inv[a-b]%mod*inv[b]%mod;
}
signed main() {
	a[1]=fact[0]=inv[0]=fact[1]=inv[1]=1;
    a[0]=0;
    la=2;
	ll t;
	read(t);
	while(t--){
		read(n);
		read(m);
		read(k);
		for(int i=la;i<=n+m;i++){
            a[i]=mod-(mod/i)*a[mod%i]%mod;
			inv[i]=inv[i-1]*a[i]%mod;
			fact[i]=fact[i-1]*i%mod;
		}
		la=max(n+m+1,la);
		if(k==0)puts("0");
        else if(k==1){
            write(C(n+m-1,m));
            puts("");
        }
		else{
			k%=mod;/*
            if(n<m){
                kk=k;
                ans=0;
                for(int i=n;i>=1;i--,kk=k*kk%mod)ans=(ans+C(m+i-2,i-1)*kk)%mod;
    			write(ans);
    			puts("");
                continue;
            }*/
            kk=sqr(k,m);
            invk1=sqr(k,mod-2);
            invk2=sqr(k-1,mod-2);
            ans=sqr(k,m+n);
            for(int i=1;i<=m;i++){
                ans=(ans-C(n+i-2,i-1)*kk%mod+mod)%mod*invk2%mod;
                kk=invk1*kk%mod;
            }
            ans=(ans%mod+mod)%mod;
			write(ans);
			puts("");
		}
	}
	return 0;
}
```
去掉注释快了 100ms：[去掉前](https://www.luogu.com.cn/record/227708474)、[去掉后](https://www.luogu.com.cn/record/227708775)。完结撒花！

---

## 作者：_O_v_O_ (赞：1)

很显然，题目叫你求：

$$\sum_{i_1=1}^n\sum_{i_2=1}^{i_1}\sum_{i_3=1}^{i_2}\cdots\sum_{i_m=1}^{i_{m-1}} k^{i_m}$$

那么我们推一下式子：

$$\begin{aligned}\text{原式}&=\sum_{i_1=1}^n\sum_{i_2=1}^{i_1}\sum_{i_3=1}^{i_2}\cdots\sum_{i_m=1}^{i_{m-1}} k^{i_m} \\ &=\frac{\sum_{i_1=1}^n\sum_{i_2=1}^{i_1}\sum_{i_3=1}^{i_2}\cdots\sum_{i_{m-1}=1}^{i_{m-2}} k^{i^{m}+1}-k}{k-1} \\ &=\frac{\sum_{i_1=1}^n\sum_{i_2=1}^{i_1}\sum_{i_3=1}^{i_2}\cdots\sum_{i_{m-1}=1}^{i_{m-2}} k^{i^{m}+1}}{k-1}-\frac{k}{k-1} \sum_{i_1=1}^n\sum_{i_2=1}^{i_1}\sum_{i_3=1}^{i_2}\cdots\sum_{i_{m-1}=1}^{i_{m-2}} 1\end{aligned}$$

前面一坨继续处理下去就行了，关键在于后面那一坨。

我们注意到，后面那一坨 $\sum_{i_1=1}^n\sum_{i_2=1}^{i_1}\sum_{i_3=1}^{i_2}\cdots\sum_{i_{m-1}=1}^{i_{m-2}}1$ 等价于求有多少个值域在 $[1,n]$ 的单调不增的数列 $(i_1,i_2,i_3,\cdots ,i_{m-1})$。

我们设 $a_x$ 表示 $x$ 在 $i$ 中的出现次数，那么一个 $a$ 对应一个 $i$，那么就变成了求有多少个 $a_{1,2,3,\cdots ,n}$ 满足 $\sum a=m$，这个玩意儿很显然等于 $n+m-2\choose m-1$。

那么我们就这样递归下去即可。

---

## 作者：sbno333 (赞：1)

我们考虑 $O(nm)$。

设 $i$ 次操作后大小为 $j$ 的星团个数为 $f_{i,j}$。

显然有 $f_{i,j}=f_{i-1,j}+f_{i,j+1}$。

可以变成一维，就是做 $m$ 次后缀和，其实后缀和显然可以优化成组合数，然后 $O(n)$，但是这不重要。

我们设初始大小星团为 $n$，$m$ 次操作后权值为 $f_m(n)$。

我们有 $f_1(n)=\frac{k^{n+1}-1}{k-1}-1$。

根据上述后缀和略一推导可得 $f_m(n)=\sum_{i=1}^n f_{m-1}(i)$。

通过推导，可以得到 $O(m)$ 计算的式子。

具体式子参考代码。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int jc[4000009];
int ny[4000009];
#define mod 998244353ll
inline int ksm(int a,int b){
	int ans;
	ans=1;
	while(b){
		if(b&1){
			ans*=a;
			ans%=mod;
		} 
		a*=a;
		a%=mod;
		b>>=1;
	}
	return ans;
}
inline int c(int n,int m){
	return jc[n]*ny[m]%mod*ny[n-m]%mod;
}
inline void _main(){
	int n,m,k;
	cin>>n>>m>>k;
	k%=mod;
	if(k==0){
		cout<<0<<"\n";
		return;
	}
	if(k==1){
		cout<<c(n+m-1,m)<<"\n";
		return;
	}
	int ans;
	ans=0;
	int y;
	y=ksm(k-1,mod-2);
	ans=ksm(k,n+m)-1+mod;
	ans%=mod;
	ans*=y;
	ans%=mod;
	int gg;
	gg=ksm(k,m+1);
	int yy;
	yy=ksm(k,mod-2);
	for(int i=m-1;i>=1;i--){
		gg*=yy;
		gg%=mod;
		ans-=(gg-1)*y%mod*c(m-1-i+n-1,m-1-i)%mod+c(m-i+n-1,m-i);
		ans+=mod+mod;
		ans%=mod;
		ans*=y;
		ans%=mod;
	}
	ans-=c(n+m-2,m-1);
	ans+=mod;
	ans%=mod;
	cout<<ans<<"\n";
}
signed main(){
    std::ios::sync_with_stdio(0);
	jc[0]=1;
	for(int i=1;i<=4000000;i++){
		jc[i]=jc[i-1]*i%mod;
	}
	ny[4000000]=ksm(jc[4000000],mod-2);
	for(int i=3999999;i>=0;i--){
		ny[i]=ny[i+1]*(i+1)%mod;
	}
	int t;
	cin>>t;
	while(t--){
		_main();
	}
	return 0;
}
```

---


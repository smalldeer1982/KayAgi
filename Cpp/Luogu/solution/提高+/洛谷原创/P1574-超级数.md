# 超级数

## 题目描述

设x的约数个数为 $f(x)$，若 $\forall i\in [1,n)\cap \mathbb{Z^+},f(n)>f(i)$，就把 $n$ 称作 `supernumber`。

给出 $m$ 个数 $a_1,a_2,\ldots,a_m$，请分别输出不大于 $a_1$，不大于 $a_2$，...，不大于 $a_m$ 的最大 `supernumber`。

## 说明/提示

#### 数据规模与约定

- 对于 $40\%$ 的数据，$m=1$。
- 对于 $50\%$ 的数据，$a_i\le1000$。
- 对于 $70\%$ 的数据，$a_i\le 2\times10^7$。
- 对于 $100\%$ 的数据，$m\le10^5$，$a_i\le10^{17}$。

## 样例 #1

### 输入

```
2
8
13```

### 输出

```
6
12```

# 题解

## 作者：沉冥Charming (赞：7)

题目中的超级数跟反素数的定义是一样的

反素数就是尽可能地让因子数量最大，但是数值最小。
    
性质一:一个反素数的质因子必然是从2开始连续的质数.

性质二:p= (2^t1)(3^t2)(5^t3)(7^t4).....
必然t1>=t2>=t3>=....

但是似乎没有人发生成反素数表的代码呢……

蒟蒻决定~~凑个热闹~~发一个生成反素数表的代码

根据数据范围，我们很容易想到暴力+打表


根据反素数的两条性质枚举，求出含有i个因数的最小正整数

所以我们先要打出一张质数表
代码如下：
```cpp
#include<iostream>
#include<fstream>
using namespace std;
bool isprime(int x)
{
    if (x<2)
        return false;
    for (int i=2; i*i<=x; i++)
        if (x%i==0)
            return false;
    return true;
}
int main()
{
    freopen("prime.txt","w",stdout);
    int a=0;
    for (int i=1;i<=100;i++)
    {
        if (isprime(i))
        {
            cout<<i<<",";
            a++;
        }
        if (a==5)
        {
            cout<<endl;
            a=0;
        }
    }
    return 0;
}
/*
1:2
2:6
3:30
4:210
5:2310
6:30030
7:510510
8:9699690
9:223092870
10:6469693230
11:200560490130
12:7420738134810
13:304250263527210
14:13 08276 13316 70030
*/
```
将这些质数乘起来，显而易见在题目数据范围内，只需要用到前13个质数

于是我们用暴搜打出反素数表
代码如下：
```cpp
#include<iostream>
#include<cstring>
#include<fstream>
#define ll long long
#define mmax 0x3f3f3f3f3f3f3f3f
using namespace std;
ll p[26]=
{
    0,
    2,3,5,7,11,
    13,17,19,23,29,
    31,37,41,43,47,
    53,59,61,67,71,
    73,79,83,89,97
};
ll ap[100001];
void dfs (ll n,ll y,ll t,ll x)
{
    if (n>=14)
        return;
    ll k=t;
    for (ll i=1; i<=x; i++)
    {
        k*=p[n];
        if (k>1e17)
            break;
        int ys=y*(i+1);
        if (k<ap[ys])
            ap[ys]=k;
        dfs(n+1,ys,k,i);
    }
}
int main()
{
    freopen("antiprime.txt","w",stdout);
    int hh=0;
    memset(ap,0x3f,sizeof(ap));
    ap[0]=0,ap[1]=1;
    dfs(1,1,1,60);
    for (int i=0; i<=100000; i++)
        if(ap[i]!=mmax)
        {
            int flag=0;
            for (int j=i; j<=100000; j++)
                if (ap[i]>ap[j])
                {
                    flag=1;
                    break;
                }
            if (!flag)
            {
                hh++;
                cout<<ap[i]<<",";
            }
            if (hh==5)
            {
                cout<<endl;
                hh=0;
            }
        }
    return 0;
}
```

打出反素数表之后就很容易ac了，但是要注意读入是用long long，不然就只有70分了

~~十年 OI 一场空，不开 long long 见祖宗~~

由于是打表，题目中的询问次数不超过十万次，而数据范围内的反素数并不多，所以连二分查找都不需要就能轻松ac

ac代码就不附了，毕竟可以看其他大佬的题解QwQ

---

## 作者：Ervin (赞：5)

# 反素数模板题

$\quad\quad$其实这个题目就是裸裸的反素数模板题，先讲一下什么是反素数吧$!!$

## 反素数：$Supernumber==$反素数?

- 反素数,是在$ACM$中常见的数论考点,所以对于冲刺$ACM$的$dalao$们来说,学习这个算法是必须的。


## 1. 定义：

$\quad\quad$~~和题目给的条件一模一样,我就不用说了吧。~~

## 2. 常见题型：

- 求约数最多而且数字最小的那个数

- 求约数刚好等于$n$的最小的那个数

- 求区间里的反素数$[begin,end]$

- 其实看到这些题目，最先想到的应该就是穷举,然而,这些题目的数据范围一般都不是~~让人看的~~....所以就需要我们这个反素数

## 3. 对定义的拓展：

- 一个反素数的所有质因子必然是从$2$开始的连续若干个质数，因为反素数是保证约数个数为$x$的这个数$n$尽量小
- 同样,如果$n=2^{t1}\times 3^{t2}\times 5^{t3} \times 7^{t4} \times ...$,那么必有$t1\ge t2 \ge t3 \ge t4 \ge ...$

### 综上所述,~~反素数有个毛线用~~$!!!$
----

----

## 好了,可以介绍这道题目了
- 这道题目有很深的套路,因为这道题数据范围太大
- 看了看其他题库里的题,比如$BZOJ$,$POJ$里边的数据都没有这个强
- 所以这道题就不能用裸的模板
- 不过只需要加一点点的优化就可以$AC$了


#### 1. 我们可以发现,其实算反素数是时间是很短的,但是因为$m$有$10^5$所以会超时,我们只需要想一下对每次询问实现$O(logn)\quad (n$是反素数的数量$)$,这样就可以避免$TLE$啦$!!$
#### 2. 在输入时,找到最大的一个数,求出距它最近的反素数,然后求这个反素数-1的最近的反素数,以此类推,就可以把所有的反素数全部求出来了
#### 3. 然后对于每一个询问,只需要二分查找就可以了

----

## 代码：

$\quad$上边已经讲的~~非常清楚~~了,代码就不加注释了

~~~cpp
#include<cstdio>
#include<algorithm>
#define inf 0x7fffffffffffffff
using namespace std;
int p[17]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,57};
int num,tot;
long long a[100010],ans,n,b[100010],maxx;
inline void read(long long &x)
{
	x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')
		ch=getchar();
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	return;
}
void print(long long x)
{
    if(x<0)
    {
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
inline void dfs(long long x,int dep,long long tmp,int now)
{
	if(dep>=17)
		return;
	if(now>num)
		num=now,
		ans=tmp;
	if(now==num&&ans>tmp)
		ans=tmp;
	for(int i=1;i<=100;i++)
	{
		if(tmp>x/p[dep])
			break;
		dfs(x,dep+1,tmp*=p[dep],now*(i+1));
	}
}
void work(long long x)
{
	int l=1,r=tot,mid=l+r>>1;
	while(l!=r)
	{
		if(b[mid]>x)
			l=mid+1;
		else
			r=mid;
		mid=l+r>>1;
	}
	while(b[mid-1]<x&&b[mid-1])
		mid--;
	while(b[mid]>x)
		mid++;
	print(b[mid]);
	return;
}
int main()
{
//	freopen("testdata.in","r",stdin);
//	freopen("1.out","w",stdout);
	read(n);
	for(int i=1;i<=n;i++)
	{
		read(a[i]);
		maxx=max(maxx,a[i]);
	}
	while(maxx!=1)
	{
		ans=inf;
		num=0;
		dfs(maxx,0,1,1);
		b[++tot]=ans;
		maxx=ans-1;
	}
	for(int i=1;i<=n;i++)
		work(a[i]),
		printf("\n");
	return 0;
}
~~~~




---

## 作者：Ginger_he (赞：3)

# 题解
题目中的 supernumber 即为[反素数](https://baike.baidu.com/item/%E5%8F%8D%E7%B4%A0%E6%95%B0/8005979?fr=aladdin)  
不妨设 $n=a_1^{p_1}\times a_2^{p_2}\times... \times a_k^{p_k}$。若 $n$ 为反素数，则有 $a_i(i=1,2,...,k)$ 为从 $2$ 开始的连续质数以及 $p_i(i=1,2,...,k)$ 非严格递减。  
利用这两条性质我们就可以爆搜打表出反素数，然后对于每次询问都进行二分即可，再加上快读快写就能成为最优解。
## 代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,pos,a[200]={*******}; 
inline long long read()
{
    long long x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
	{
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
	{
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
inline void write(long long x)
{
	if(x<0)
	{
		putchar('-');
		x=-x;
	}
	if(x>9)
		write(x/10);
	putchar(x%10+'0');
}
int main()
{
	m=read();
	while(m--)
	{
		n=read();
		pos=upper_bound(a+1,a+163,n)-a-1;
		write(a[pos]);
		putchar('\n');
	}
	return 0;
}
```


---

## 作者：litc (赞：3)

首先，我们应该知道：若x=p1^k2\*p2^k2\*...pi^ki，那么f(x)=(k1+1)\*(k2+1)\*...\*(ki+1)。其中p1,p2,...,pi为质数。

其次，我们还应知道：若p1<p2<p3<…<pi，那么k1>=k2>=k3>=…>=ki。否则交换不符合条件的ki和k(i+1)，会使x更小，但约数个数不变。

接着，根据这条性质暴搜，找出所有符合条件的数（其实很少）。

最后，回答询问。


---

## 作者：一只书虫仔 (赞：2)

#### Description

> 给定 $N$，求不超过 $N$ 的最大反素数。      
> 教练版本：$N \le 10^{18}$，100ms 下文按此版本

#### Solution

首先回观反素数的定义，不难发现题目可以转化为求不超过 $N$ 的约数最多的数，如果有多个的话，要取最小的，因为如果存在 $n_1,n_2$ 的约数个数一样多，$n_1>n_2$，那么 $g(n_1)=g(n_2)$，$n_2$ 就不是反素数了。

假设满足要求的数为 $n$，我们将其标准分解：

$$n=p_1^{a_1}p_2^{a_2}\cdots p_k^{a_k}$$

约数个数 $R$ 即为：

$$R=\prod\limits_{i=1}^n (a_i+1)$$

那么 $R$ 一样的两个数，怎么取最小呢？肯定是取下标 $p_i$ 最小的。因此可以考虑从 $2$ 开始枚举，我们看见已经给定范围了（$N \le 10^{18}$），因此考虑第一个质数 $p'$ 使得所有小于等于 $p'$ 的质数乘积大于等于 $10^{18}$ 即可。

利用计算器可得 $p'=47$。

然后在枚举过程中，也不需要从 $1$ 枚举到 $n$，对于每个质数 $t$，他都对应着一个上限 $t'$ 使得 $t^{t'} \ge 10^{18}$。

另外根据小学奥数，如果要给两个质数 $p_1,p_2$ 分配指数 $a_1,a_2$（$p_1<p_2$，$a_1<a_2$），那么不难发现：

$$p_1^{a_1}p_2^{a_2} \ge p_1^{a_2}p_2^{a_2}$$

因此给较小的质数分配较大的指数，具体地：

$$a_1\ge a_2 \ge \cdots\ge a_k$$

结合上面的上限说明，我们发现 $62$ 就是那个上界，因此我们考虑上界剪枝，从 $[1,47]$ 枚举，dfs 函数上传一个指数上界，从 $1$ 枚举到指数上界即可，接下来枚举中得到的指数就可以作为新的一个指数上界。

然后加一些零碎的剪枝（比如判断是否超从乘法改成除法）即可。

---

## 作者：Lin1043 (赞：2)

这道题似乎有一个有理有据的做法，不难发现超级数的定义是等价于反素数的，所以就可以运用反素数的搜索做法

这里就不展开说明了。我们主要考虑怎么处理多个询问，不难发现反素数的个数即使在1e17级别也不算太多，且

间隔较大，考虑将询问按询问值大小排序。对于排序后第i个询问的答案来说， 必然是满足小于等于当前询问值的

超级数，若此时答案小于第i-1个询问的询问值，那么第i个询问的答案也必然是第i-1个询问的答案。因为我们

便可以将询问的答案继承。复杂度与询问值的分布相关。但跑个1e5似乎很轻松啊

    #include <iostream>
    #include <cstdio>
    #include <cstdlib>
    #include <algorithm>
    #define rep(i,l,r) for(int i=l;i<=r;++i)
    #define per(i,r,l) for(int i=r;i>=l;--i)
    using namespace std;
    typedef long long LL;
    namespace unPri
    {
    
    	const int N = 100 + 5;
    	const int pri[14] = {0 , 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37};
    	LL val , s[N] , ans , mx;
    	void dfs(int pos , LL sum , LL mult)
    	{
       		if(pos > 12) return;
        	if(sum > mx || (sum == mx && mult < ans)) mx = sum , ans = mult;
        	s[pos] = 0; LL next;
        	while(mult * pri[pos] <= val && s[pos] < s[pos - 1])
        	{
            	s[pos]++; mult *= pri[pos];
            	next = sum * (s[pos] + 1);
            	dfs(pos + 1 , next , mult);
        	}
    	}
    	LL Answer(LL _val)
    	{ 
    		val = _val; s[0] = N * N;
    		mx = ans = 0;
    		dfs(1 , 1 , 1);
    		return ans;
    	}
    }
    namespace Solve
    {
    	const int N = 100000 + 5;
    	struct Query
    	{
    		int idx; LL ask , ans;
    		Query() { idx = ask = ans = 0;  }
    		bool operator < (const Query &rhx) const
    		{
    			return ask < rhx.ask;
    		}
    	} Q[N];
    	LL Ans[N];
    	void put(int n)
    	{
    		sort(Q + 1 , Q + 1 + n);
    		per(i , n , 1)
    		{
    			if(Q[i + 1].ans <= Q[i].ask && i != n)
    			{
    				Q[i].ans = Q[i + 1].ans;
    				Ans[Q[i].idx] = Q[i].ans;
    				continue;
    			}
    			Q[i].ans = unPri::Answer(Q[i].ask);
    			Ans[Q[i].idx] = Q[i].ans;
    		}
    		rep(i , 1 , n) printf("%lld\n" , Ans[i]);
    	}
    }
    int n;
    int main()
    {
        scanf("%d" , &n);
    	rep(i , 1 , n) scanf("%lld" , &Solve::Q[i].ask) , Solve::Q[i].idx = i;
    	Solve::put(n);
        return 0;
    }






---

## 作者：Augen_stern (赞：1)

## Part 1：分析题目

这道题目的本质就是求一个数，满足比它小的正整数的因子数量都比这个数的少；

由题很容易联想到一道蓝题[反素数](https://www.luogu.com.cn/problem/P1463)，只不过这道题就是反素数的升级版，所以建议你先做了反素数，再来想想优化。

## Part 2：代码实现

这里是反素数的代码，思路是爆搜，在这道题上跑，如果开 $O_2$ 大约可以得到 $70$~$80$ 分：

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
long long ans=1,n,maxx=0;
int s[15]= {0,2,3,5,7,11,13,17,19,23,29}; // 质数表；
void dfs_Enumerate(long long now,long long TFIS,long long x,long long v) {
	if(maxx<TFIS||(maxx==TFIS&&ans>now)) {
		maxx=TFIS;
		ans=now;
	}
	for(int i=1; i<=x; i++) {
		now*=s[v];
		if(now>n) return ;
		if(v+1>10) return ; // 减枝；
		dfs_Enumerate(now,TFIS*(i+1),i,v+1);
	}
}
int main() {
	scanf("%lld",&n);
	dfs_Enumerate(1,1,25,1);
	printf("%lld",ans);
	return 0;
}
```

所以我们在这个代码上进行改进：

1，因为原本的数据范围是 $1\leq N\leq 2\times 10^9$，所以质数打表打到 $\log_22\times 10^9\approx30$ 就够了；

而现在数据范围是 $1\leq a_i\leq 10^{17}$ （这里的 $a_i$ 就是上文的 $N$），所以要把质数打表打到 $\log_210^{17}\approx57$ 才可以；

2，多组数据，搜索多次固然麻烦，所以在输入时取最大值，一次性操作，并记录对于每一个数的反素数，最后再二分查找；

```cpp
int main() {
	scanf("%d",&t);
	for(int i=1; i<=t; i++) {
		scanf("%lld",&ask[i]);
		maxxx=max(maxxx,ask[i]); // 求最大；
	}
	n=maxxx;
	while(n!=1) {
		ans=1;
		maxx=0;
		dfs_Enumerate(1,1,57,1); // 爆搜，同反素数；
		anss[++o]=ans; // 反素数储存；
		n=ans-1;
	}
	sort(anss+1,anss+o+1);
	for(int i=1; i<=t; i++) {
		int pos=upper_bound(anss+1,anss+o+1,ask[i])-anss-1; // 二分，直接用 STL 库里的就行了；
		printf("%lld\n",anss[pos]);
	}
	return 0;
}
```
3，接下来优化爆搜部分：

核心思想还是剪枝；

```cpp
void dfs_Enumerate(long long now,long long TFIS,long long x,long long v) {
	if(now>n||v+1>=17) return ; // 疯狂减枝；
	if(maxx<TFIS) {
		ans=now;
		maxx=TFIS; // 记录答案，情况一；
	}
	if(maxx==TFIS&&ans>now) {
		ans=now; // 记录答案,情况二；
	}
	for(int i=1; i<=x; i++) {
		if(now*s[v]>n) break;
		now*=s[v];
		dfs_Enumerate(now,TFIS*(i+1),i,v+1); // 同反素数部分；
	}
}
```
写到这里，一切海阔天空，柳暗花明；

## Part 3：CODE

经过三次优化讨论，我们已经可以得到 AC 代码，或许优化方式还有许多，有待你的发现。

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int t=1;
long long ans=1,n,maxx=0,maxxx=0,o=0;
long long ask[100005],anss[100005];
int s[20]= {0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53}; // 质数表；
void dfs_Enumerate(long long now,long long TFIS,long long x,long long v) {
	if(now>n||v+1>=17) return ; // 疯狂减枝；
	if(maxx<TFIS) {
		ans=now;
		maxx=TFIS;
	}
	if(maxx==TFIS&&ans>now) {
		ans=now;
	}
	for(int i=1; i<=x; i++) {
		if(now*s[v]>n) break;
		now*=s[v];
		dfs_Enumerate(now,TFIS*(i+1),i,v+1); // 同反素数部分；
	}
}
int main() {
	scanf("%d",&t);
	for(int i=1; i<=t; i++) {
		scanf("%lld",&ask[i]);
		maxxx=max(maxxx,ask[i]); // 求最大；
	}
	n=maxxx;
	while(n!=1) {
		ans=1;
		maxx=0;
		dfs_Enumerate(1,1,57,1); // 爆搜，同反素数；
		anss[++o]=ans; // 反素数储存；
		n=ans-1;
	}
	sort(anss+1,anss+o+1);
	for(int i=1; i<=t; i++) {
		int pos=upper_bound(anss+1,anss+o+1,ask[i])-anss-1; // 二分，直接用 STL 库里的就行了；
		printf("%lld\n",anss[pos]);
	}
	return 0;
}
```

~~这道题真就挺暴力的，汗汗```~~！

2021.9.28 初稿成。

---

## 作者：panyf (赞：1)

【思路】：

约数个数公式：

设m=p1^t1* p2^t2* ……* pn^tn(pi为质数）

则m的约数个数为：（t1+1)* (t2+1)* …… * (tn+1)

再证明一个定理：

对于任意超级数m，均满足m=2^t1* 3^t2* …… * p^tk(p为第k大的质数），并且t1>=t2>=……>=tk

证明：

若m=2^t1* 3^t2* ……* p^tk且不满足t1>=t2>=……>=tk，可将t1,t2……tk从大到小排序为T1,T2……Tk，满足T1>=T2>=……>=Tk,则m2=2^T1* 3^T2* ……* p^Tk，满足m与m2约数个数相同且m2<m，故m不为超级数。

【详细注释代码】：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long L;//用long long防止溢出
L x,ans[9999],t,G,k,n,p[29]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};
  //ans数组为最终的超级数，p数组为质数表
struct SP{
    L g,x;
}sp[99999];
  //存储可能的超级数，x为数值，g为约数个数
bool cmp(SP x,SP y){
    return x.x<y.x;//从小到大按数值排序
}
void dfs(L x,L y,L z,L g){
    //x为当前乘的质数，y为最多乘的幂次，z为当前数值，g为约数个数
    if(z>1e17)return;//剪枝，剪掉超出范围的数
    sp[k].x=z,sp[k++].g=g;
    L u=1;
    for(int i=1;i<=y;i++){
        if(z>1e17)return;//剪枝
        z*=p[x],u++;
        dfs(x+1,i,z,g*u);
  //保证下一个质数的幂次不超过当前质数
    }
}
int main(){
    cin>>n;
    dfs(0,39,1,1);
    sort(sp,sp+k,cmp);//排序
    for(int i=0;i<k;i++)if(sp[i].g>G)G=sp[i].g,ans[t++]=sp[i].x;
  /*如果一个数的约数个数大于小于它的所有数，
  就将它放入ans数组*/
    while(n--){
    	cin>>x;
    	cout<<*(upper_bound(ans,ans+t,x)-1)<<endl;
        //二分查找（STL）提高效率
	}
}
```


---

## 作者：happybob (赞：1)

其实就是求反质数，与[这题](https://www.luogu.com.cn/problem/P1463)很像，只不过数据范围变了。考虑打表即可。

关于反质数的更多信息，请看[这里。](https://baike.baidu.com/item/%E5%8F%8D%E7%B4%A0%E6%95%B0/8005979?fr=aladdin)


因为在 $[1, 10^{17}]$ 中的反质数其实是很少的，所以在输出答案时其实不需要二分，暴力即可。

```cpp
#include <cstdio>
using namespace std;

#define int long long
int ans[] = {1, 2, 4, 6, 12, 24, 36, 48, 60, 120, 180, 240, 360, 720, 840, 1260, 1680, 2520, 5040, 7560, 10080, 15120, 20160, 25200, 27720, 45360, 50400, 55440, 83160, 110880, 166320, 221760, 277200, 332640, 498960, 554400, 665280, 720720, 1081080, 1441440, 2162160, 2882880, 3603600, 4324320, 6486480, 7207200, 8648640, 10810800, 14414400, 17297280, 21621600, 32432400, 36756720, 43243200, 61261200, 73513440, 110270160, 122522400, 147026880, 183783600, 245044800, 294053760, 367567200, 551350800, 698377680, 735134400, 1102701600, 1396755360, 2095133040, 2205403200, 2327925600, 2793510720, 3491888400, 4655851200, 5587021440, 6983776800, 10475665200, 13967553600, 20951330400, 27935107200, 41902660800, 48886437600, 64250746560, 73329656400, 80313433200, 97772875200, 128501493120, 146659312800, 160626866400, 240940299600, 293318625600, 321253732800, 481880599200, 642507465600, 963761198400, 1124388064800, 1606268664000, 1686582097200, 1927522396800, 2248776129600, 3212537328000, 3373164194400, 4497552259200, 6746328388800, 8995104518400, 9316358251200, 13492656777600, 18632716502400, 26985313555200, 27949074753600, 32607253879200, 46581791256000, 48910880818800, 55898149507200, 65214507758400, 93163582512000, 97821761637600, 130429015516800, 195643523275200, 260858031033600, 288807105787200, 391287046550400, 577614211574400, 782574093100800, 866421317361600, 1010824870255200, 1444035528936000, 1516237305382800, 1732842634723200, 2021649740510400, 2888071057872000, 3032474610765600, 4043299481020800, 6064949221531200, 8086598962041600, 10108248702552000, 12129898443062400, 18194847664593600, 20216497405104000, 24259796886124800, 30324746107656000, 36389695329187200, 48519593772249600, 60649492215312000, 72779390658374400, 74801040398884800, 106858629141264000, 112201560598327200, 149602080797769600, 224403121196654400, 299204161595539200, 374005201994424000, 448806242393308800, 673209363589963200, 748010403988848000, 897612484786617600, 1122015605983272000, 1346418727179926400, 1795224969573235200, 2244031211966544000, 2692837454359852800};

signed main()
{
	int total = sizeof(ans) / sizeof(int), n;
	scanf("%lld", &n);
	while (n--)
	{
		int k;
		scanf("%lld", &k);
		for (int i = 0; i < total; i++)
		{
			if (ans[i] <= k && ans[i + 1] > k)
			{
				printf("%lld\n", ans[i]);
				break;
			}
		}
	}
	return 0;
}
```

提一个细节，打表后我们通常不知道数组有多大，我们可以用 `vector` 的 `size` 函数统计大小，但是正常数组怎么获得数组元素个数呢？我们知道 C++ 中有这样的一个函数 `sizeof()`，在本题中，我们的打表数组是 `ans`，那么我们只需要用 `sizeof(ans) / sizeof(long long)` 即可求出数组元素个数。我的代码用了 `#define int long long` 所以直接写成 `sizeof(int)` 也是可以的。

---

## 作者：Genius_Star (赞：0)

### 题意简述：
额，裸的一道模板题目学过反素数的伙伴们，肯定非常眼熟，没错，这就是求我们不大于 $a_i$ 的最大反素数。
### 思路：
~~网上搜索反素数表，开个数组存下来，然后二分查一以下……~~

上述事情是不可能发生的，就算打表，作为新时代的好少年们肯定也必须自己写代码来记录下来打表。

首先，先跟大家说一下反素数的定义（其实和题目没什么大区别）：

- 对于任何正整数 $x$，其约数的个数记作 $g(x)$。例如 $g(1)=1$、$g(6)=4$。

- 如果某个正整数 $x$ 满足：$g(x)>g(i)(0<i<x)$，则称 $x$ 为反质数。例如，整数 $1,2,4,6$ 等都是反质数。

然后，说一下反素数的性质：

1. 一个反素数的质因子必然是从 $2$ 开始连续的质数.

2. $p=2^{t_1}+3^{t_2}+5^{t_3}+7^{t_4} \dots$，必然 $t_1 \ge t_2 \ge t_3 \dots$。

所以接下来我们需要求反素数！
### 求反素数：
#### 1.暴力：
考虑直接暴力枚举以及的因数，时间复杂度约为 $O(n^2 \log_2 n)$。
```cpp
#include <cstdio>
int yz(int t) {
    int ans=0;
    for(int i=1; i<=t; i++) {
        if(t%i==0) {
            ans++;
        }
    }
    return ans;
}
bool pd(int x) {
    int dz=yz(x);
    for(int i=1; i<=x-1; i++) {
        if(yz(i)>=dz) {
            return false;
        }
    }
    return true;
}
int main() {
    int n=0;
    scanf("%d",&n);
    for(int i=n; ; i--) {
        if(pd(i)==true) {
            printf("%d",i);
            break;
        }
    }
    return 0;
}
```
#### 2.暴力优化：
还是考虑直接暴力枚举 $x$，但是我们可以通过优化枚举因数的时间复杂度来降低整个程序的时间复杂度，这种方法的时间复杂度约为 $O(n \log_2 n \sqrt{t})$。
```cpp
#include <cstdio>
#include <cmath>
int yz(int t) {
 
    int ans=0;
    int mj=sqrt(t);
    for(int i=1; i<=mj; i++) {
        if(t%i==0) {
            ans+=2;
        }
    }
    if(mj*mj==t) {
        ans--;
    }
    return ans;
}
bool pd(int x) {
    int dz=yz(x);
    for(int i=1; i<=x-1; i++) {
        if(yz(i)>=dz) {
            return false;
        }
    }
    return true;
}
int main() {
    int n=0;
    scanf("%d",&n);
    for(int i=n; ; i--) {
        if(pd(i)==true) {
            printf("%d",i);
            break;
        }
    }
    return 0;
}
```
#### 3.满分思路：
什么是反素数？

反素数就是区间内约数个数最多的那个数。根据题目要求，如果有多个满足，选取最小的一个。

如果我们要求的区间就是 $[1,10]$。

那么我们怎么求反素数呢？

如果我们设为 $p$ 指数，$k$ 为指数的话，那么如果一个数可以被分成如下形式：

$$x=\prod\limits_{i=1}^np_i^{k_i}$$

那么 $x$ 的因数个数就是 $\prod\limits_{i=1}^nk_{i}+1$。

如果设 $p_i$ 严格递增，并且 $k_i=0$ 也算在内，则如果 $k_x<k_y$ 并且 $x<y$，那么显然这个数不可能是反素数，因为交换 $k_x$ 和 $k_y$ 会更好。 

所以当递增时是递减的，这个数才可能是反素数。

所以我们可以据此搜索。

素数表可以筛一波，也可以这样：

因为前 $12$ 个素数的积 $>2 \times 10^9$，所以最多用到 $12$ 个素数，手动打素数表即可。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
long long p[20]= {0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53};
long long maxn=-1,ans=-1;
long long n=0;
void get(long long m,long long f,long long t,long long pr) {
    //f为当前质数的编号，当前指数<pr
//t为当前约数的个数， m表示当前可能成为最优解的数
    if(t>maxn || (t==maxn && m<ans)) { //更新最优解
        ans=m,maxn=t;
    }
    long long i=m,j=0;
    long long nt=0;
    while(j<pr) { //j表示的是当前正在搜索的指数
        j++;
        if(n/i<p[f]) { //若不满足条件就跳出循环（i表示的是当前的m）
            break;
        }
        nt=t*(j+1),i*=p[f];//更新新数以及它的因子个数。
        if(i<=n) { //若i（即当前的m）在区间[1,n]内就继续搜索。
            get(i,f+1,nt,j);
        }
    }
}
int main() {
    scanf("%lld",&n);
    get(1,1,1,30);
    printf("%lld",ans);
    return 0;
}
```
### 完整代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 10;
const int p[] = {0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47}; //打表 
int n, tid[maxn];
ll now, res, val, Q[maxn], ans[maxn];
void dfs(int pos, ll sum, ll tot, int lst){ //搜索找反素数 
    for (ll i = 0, t = sum; i <= lst; i++, t *= p[pos]){
    	if (pos < 16) //前16个素数还没有搜完 
		  dfs(pos + 1, t, tot * (i + 1), i);
    	if ((res >= t && val <= tot) || (res < t && val < tot))
          res = t, val = tot;
    	if (t * p[pos] > now) 
		  break;
    }
}
bool cmp(int x,int y){
	return Q[x]>Q[y];
}
int main(){
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
      scanf("%lld", Q + i), tid[i] = i;
    sort(tid + 1, tid + n + 1,cmp);
    for (int i = 1; i <= n; i++){
    	if (i > 1 && ans[tid[i - 1]] < Q[tid[i]])
          ans[tid[i]] = ans[tid[i - 1]];
    	else{
        	res = val = 1;
        	now = Q[tid[i]];
        	dfs(1, 1, 1, 1000);
        	ans[tid[i]] = res;
    	}
    }
    for (int i = 1; i <= n; i++)
      printf("%lld\n", ans[i]);
    return 0;
}
```

---

## 作者：XL4453 (赞：0)



------------
解题思路：

超级数什么的，其实就是反素数，这两者的定义是一模一样的，所以下面直接介绍反素数。

首先，大家应该都知道素因子分解（看到紫题还点进来的一般都会吧 $QwQ$ ）。即： $num=p1^{k1}\times p2^{k2} \times p3^{k3}\times ... \times pn^{kn}$ 其中 p 是素数， k 是指数。

那么考虑一般的求反素数方法，就是对于一个范围内数，对其进行素因子分解，然后与 ans 来比较。

显而易见，这种算法效率很低。究其本质，其实是有很多数的因数很少，这种算法却无法预知这种数，而不得不一点一点的排查。

由此，我们可以想到主动构造反素数。

------------

首先给出一条结论：

所有的反素数在素因子分解后 k 数组是不上升的（p数组递增的情况下）。

这个可以用反证法证明：

假设有这样一个反素数 num 其素因子分解后有 $k_i < k_j$ 且 $ p_i < p_j $ ，那么，如果将 $k_i$ 和 $k_j$ 这两者交换一下，很明显新的数要比原来的小，同时两者因数个数相等，都等于 $(k_1+1)\times (k_2+1)\times(k_3+1)\times ... \times(k_n+1)$ ，而根据反素数的定义，反素数的因数个数是比其小的所有数中最大的（不包含等于），这与反素数的定义矛盾，所以 num 一定不是反素数。命题得证。

有这个结论可以很容易推出反素数一定是从最小素数2开始的连续素数的幂次的乘积。

所以说，我们可以枚举反素数在素因数分解后的素数个数，然后枚举每个素数的幂次，构造反出素数。（其实就是个 dfs ）

代码如下：

```cpp
#include<cstdio>
using namespace std;
int pri[30]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47};
//乘积等于614889782588491410恰好比1e17大一点 
//乘上下一个素数53就是32589158477190044730，有点浪费了 
long long ans_num,ans_tot,n,T;
void dfs(int now,long long num,long long tot,long long top){
	//   当前素数     当前数值     当前因数数     能取到的最大i
	if(num>n||now>=15)return;//15，数组从0开始 
	if(tot>ans_tot){ans_tot=tot;ans_num=num;}
	if(tot==ans_tot&&ans_num>num){ans_num=num;}
	//优先因数个数，其次保证最小
	for(int i=1;i<=top;i++){
		if(num*pri[now]>n)break;
		num*=pri[now];
		dfs(now+1,num,tot*(i+1),i);
	}
}
int main(){
	scanf("%lld",&T);
	while(T--){
		scanf("%lld",&n);
		ans_num=0;ans_tot=0;
		dfs(0,1,1,57);
		//2^57=1.44115188075855872e+17，恰好比1e17大一点 
		printf("%lld\n",ans_num);
	}
	return 0;
}
```
------------

然后就 TLE 了两个点。

重新读题，发现其实算反素数效率已经很高了，但架不住 $m\leq 10^5$ 的数据范围。

然后我们就想到可以把反素数全都算出来再应付询问。这里可以打表。也可以算出一个反素数后再算从一到比这个反素数小一的反素数。效率都挺高的，就是打表有点难看。

代码如下（稍微改改即可）：

```cpp
#include<algorithm>
#include<cstdio>
using namespace std;
long long max(long long a,long long b){if(a<b)return b;return a;}
int pri[30]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47};
//乘积等于614889782588491410恰好比1e17大一点 
//乘上下一个素数53就是32589158477190044730，有点浪费了 
long long ans_num,ans_tot,n,T,ask[100005],maxn,rec[100005],len;
void dfs(int now,long long num,long long tot,long long top){
	//   当前素数     当前数值     当前因数数     能取到的最大i
	if(num>n||now>=15)return;//15，数组从0开始 
	if(tot>ans_tot){ans_tot=tot;ans_num=num;}
	if(tot==ans_tot&&ans_num>num){ans_num=num;}
	//优先因数个数，其次保证最小
	for(int i=1;i<=top;i++){
		if(num*pri[now]>n)break;
		num*=pri[now];
		dfs(now+1,num,tot*(i+1),i);
	}
}
int main(){
	scanf("%lld",&T);
	for(int i=1;i<=T;i++){
		scanf("%lld",&ask[i]);
		maxn=max(maxn,ask[i]);
	}
	n=maxn;
	while(n!=1){
		ans_num=0;ans_tot=0;
		dfs(0,1,1,57);
		len++;
		rec[len]=ans_num;
		n=ans_num-1;
	}
	sort(rec+1,rec+len+1);
	for(int i=1;i<=T;i++){
		int pos=upper_bound(rec+1,rec+len+1,ask[i])-rec-1;
		printf("%lld\n",rec[pos]);
	}
	return 0;
}

```


---


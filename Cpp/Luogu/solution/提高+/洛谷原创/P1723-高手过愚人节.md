# 高手过愚人节

## 题目背景

高手组织大家过愚人节、联欢会要打出一些横幅。高手想表现得文艺一点，于是他就用一些普通人看不懂的乱码作为横幅内容。但是在这个时候，他也想让横幅更美观。


## 题目描述

现在给出 $n$ 个著名的乱七八糟的乱码，高手要知道每条乱码的最美观连续子序列的长度，在高手的心目中，只有回文串才是美观的。这代表着他纯洁的爱情，又有着回环往复的美，最重要的是，对于转回了一年级的高手来说，想要求出这个太难了，因此他找到了你。（OIer 无所不能！）


## 说明/提示

### 数据范围及约定

对于全部数据，$1\le n\le 10$，$1\le |s_i|\le 10^7$。

## 样例 #1

### 输入

```
1
aaaaa```

### 输出

```
5```

# 题解

## 作者：三好代表 (赞：15)

简要说一下思路，我们先复制一遍模板（甚至变量都不用改

然后唯一的区别就是要求的是最长连续回文子串长度

那么我们就在Manacher函数里在最后统计一下最大值就行

~~优秀的代码在这里~~
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 21000000;
char s[N],str[N];
int p[N],n;
int init(){
    int len=strlen(s);
    str[0]='@',str[1]='#';
    int j=1;
    for(int i=0;i<len;++i){
        str[++j]=s[i];
        str[++j]='#';
    }
    str[++j]='\0';
    return j;
}
int Manacher(){
    int id=1,mx=1,maxn=0,len=init();
    for(int i=1;i<len;++i){
        if(i<mx) p[i]=min(p[id*2-i],mx-i);
        else p[i]=1;
        while(str[i-p[i]]==str[i+p[i]]) p[i]++;
        if(i+p[i]>mx){
            mx=i+p[i];
            id=i;
        }
        maxn=max(maxn,p[i]-1);//敲黑板，唯一的区别
    }
    return maxn;
}
int main(){
    cin>>n;
    while(n--){
        memset(p,0,sizeof(p));
        cin>>s;
        cout<<Manacher()<<endl;
    }
    return 0;
}
```


---

## 作者：MuYC (赞：4)

#### 前言

貌似这就是一个模板题？而且貌似数据范围没有给清楚。。

看到就进来了，发现manacher有点生疏了.....

#### 思路

就是manacher算法模板，转化为了多组数据。

在这里就讲一下manacher算法:

### 字符回文串算法

好了扯谈结束.

ＯＩ中一直有一个经典的问题，求回文子串。

然后大概有三种算法来解决这个问题：

+ 中心扩展法
+ 动态规划法
+ *Manacher算法*

这里讲的就是Manacher算法.

为什么上面两个它们不行？

第一个不能处理偶回文(找不到中心!)而且时间复杂度O($n^2$)，

第二个时间复杂度O($n^2$)，显然也不大行的样子

但是我们的*Manacher算法*，它的时间复杂度为O(n),并且可以适应奇回文和偶回文！这个算法大大滴好！

所以我们用Manacher 来解决问题.

### Manacher 算法

#### 算法思想：

将偶回文串转化为奇回文串，同时利用已经处理过的信息，借助对称(回文串具有对称的性质)来对当前处理的点进行扩展。

### 规定算法概念:

**定义**$R$是**当前扩展到的所有回文串的最右边界**

**定义**$pos$ 是右边界为$R$且**第一次**扩展到$R$的时候对应的中心点

**定义**$L$是$R$关于$pos$的对称点(也就是以$pos$为对称中心的回文串的左端点),$L = 2* pos - R$

**定义**$x$的*回文半径*是我们求到的以$x$为中心的最长回文串的左边界到$x$的长度,规定为$p[x]$

**定义**$i$是当前处理到的，要求以*$i$为中心的回文半径*

#### 算法流程:

第一步，先把偶回文转化为奇回文,这个的处理就是在原串的基础上，每两个字符中间加上一个奇奇怪怪的字符

放张图片:

[![BnH0Ug.png](https://s1.ax1x.com/2020/10/26/BnH0Ug.png)](https://imgchr.com/i/BnH0Ug)

你数一数是不是偶回文就变成了奇回文了呀?

细心的小伙伴已经注意到了,第一个加入的字符和最后一个加入的字符不一样　！这个是为了处理边界，后面会用到

第二步,对于新串中的每一个点求它们的回文半径.

按照前面的规定，我们现在知道了*$R$以及$pos$*，还有当前我们*要求回文半径的点为$i$*，同时显然$i > pos$，而且我们已经知道了扩展后的字符串的$i$前面字符的所有$p[j]$,$(0 <= j < i)$

**我们规定$i$关于$pos$对称的点为$i'$ , $i' = 2 * pos - i$**

然后**分情况讨论**:

### 以下内容为算法核心!!

+ $i$ < $R$:

那么$i'$就会大于$L$小于$pos$

$1.$如果$p[i'] + i <= R$，这就告诉我们，以$i'$为中心的回文串被包含在回文串$[L,R]$(也就是当前右端点最右的回文串).

那么因为$[L,R]$是一个回文串，这个串$[L,R]$ 就具有对称性，那么$p[i] = p[i']$

$2.$ 如果$p[i'] + i > R$,这就告诉我们，以$i'$为中心的回文串 *一定不是* 完全包含在回文串$[L,R]$中。

但是至少我们可以知道，以$i'$为中心的回文串包含在回文串$[L,R]$中间的部分，根据对称性,以$i$为中心的回文串的长度一定大于等于这部分,然后我们再进行暴力扩展.

综合上面两种情况，我们可以得到一条核心~~伪~~代码:
```cpp      
p[i] = min(p[i'],R - i + 1);//前面是代表的被完全包含的情况，后面则是没有被完全包含的情况，两种情况因为是求可行情况，所以是求min
```
$i'$实际代码是写成$2 * pos - i$

+ $i$ >= $R$

这没办法，前面的信息已经用不上了，暴力修改，同时更新$R$以及 $pos$,此时初始化$p[i]等于1$

核心~~伪~~代码:
```cpp
      while(str[i + p[i]] == str[i - p[i]])p[i] ++;
       // 这里就是暴力扩展，然后前面的伏笔边界处理就在此用上了，因为边界字符不同，所以我们不会把边界算进去
```

### 算法核心到此结束

然后就算法至此完结撒花了,给出算法核心代码:
```cpp
int manacher()
{
	int R = 0 , pos = 0 ,maxlen = 0;
	for(int i = 1 ; i <= lenstr ; i ++)
	{
		if(i <= R)
			p[i] = min(p[2 * pos - i],R - i + 1);
		else p[i] = 1;
		while(str[i - p[i]] == str[i + p[i]])p[i] ++;//暴力枚举
		if(i + p[i] - 1 > R)
		{
			R = i + p[i] - 1;
			pos = i;//更新Ｒ以及pos
		}
		maxlen = max(maxlen,p[i] - 1);//更新maxlen
	}
	return maxlen;
}
```

严谨时间复杂度证明: [这篇博客](https://segmentfault.com/a/1190000008484167)  翻到最下面

### Code

最后还是贴一下这个题完整代码(居然是蓝题......)


```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
char a[1000005];
char s[2000005];
int p[2000005];
int main()
{
	cin >> n;
	for(int i = 1 ; i <= n ; i ++)
	{
		cin >> a + 1;
		int len = strlen(a + 1);
        //与模板一样
		for(int j = 1 ; j <= 2 * len + 1; j ++)
		{
			if(j & 1)
			s[j] = '#';
			else s[j] = a[j / 2];
		}
		s[0] = '&';s[2 * len + 2] = '*';
		int R = 0 , mid = 0,maxlen = -1;
		for(int j = 1 ; j <= 2 * len + 1; j ++)
		{
			if(j <= R)p[j] = min(p[mid * 2 - j],R - j + 1);
			else p[j] = 1;
			while(s[j + p[j]] == s[j - p[j]])p[j] ++;
			if(j + p[j] - 1 > R)
			{
				mid = j;
				R = j + p[j] - 1;
			}
			maxlen = max(maxlen,p[j] - 1);
		}
		cout << maxlen << endl;//输出最长长度
	}
	return 0;
}
```

---

## 作者：Eason_AC (赞：2)

## Content
有 $n$ 次询问，每次询问给定一个字符串 $s$，求这个字符串最长的回文子串的长度。

**数据范围：$n$ 无解（至少从题面来看是这样的），字符串长度目测应该在 $10^7$ 范围内。**
## Solution
这道题目显然会要用到 manacher 算法，关于这个算法的详情可以看 [$\texttt{P3805}$ 的题解](https://www.luogu.com.cn/problem/solution/P3805) 或者[这篇博客](https://www.luogu.com.cn/blog/codesonic/manacheralgorithm)，这里不再赘述了。

本题相对于 $\texttt{P3805}$ 而言只是多了一个多组询问而已，其它的本质都是一样的。所以，直接将 $\texttt{P3805}$ 的代码稍微改一下就可以过这道题目了。
## Code
```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>
using namespace std;

char s[22000007], ss[22000007];
int p[22000007], n, cnt, ans;

void pre(char* s) {
	int len = strlen(s);
	ss[++cnt] = '`', ss[++cnt] = '#';
	for(int i = 0; i < len; ++i) {
		ss[++cnt] = s[i];
		ss[++cnt] = '#';
	}
}
void manacher(char* s) {
	for(int t = 1, r = 0, mid = 0; t < cnt; ++t) {
		if(t <= r) p[t] = min(p[mid * 2 - t], p[mid] + mid - t);
		else	p[t] = 1;
		for(; ss[t + p[t]] == ss[t - p[t]]; p[t]++);
//		while(ss[t + p[t]] == ss[t - p[t]])	p[t]++;
		if(p[t] + t - 1 > r)	r = p[t] + t - 1, mid = t;
	}
}

int main() {
	int n;
	scanf("%d", &n);
	while(n--) {
		memset(p, 0, sizeof(p));
		cnt = ans = 0;
		scanf("%s", s);
		pre(s);
		manacher(s);
		ans = 0;
		for(int i = 0; i < cnt; ++i)	ans = max(ans, p[i]);
		printf("%d\n", ans - 1);
	}
}
```

---

## 作者：Mars_Dingdang (赞：2)

一道裸的求最长回文子串的题目，考察 Manacher 算法。

## 题目大意
现在有一个字符串 `c#@ai#%as!vbad@`，由各种乱码组成，求其最长回文子串的长度。

最长回文子串或最长对称因子问题是在一个字符串中查找一个最长的连续的回文的子串，例如 `banana` 最长回文子串是 `anana` 。最长回文子串并不一定是唯一的，比如 `abracadabra` ，没有超过3的回文子串，但是有两个回文字串长度都是 3：`ada` 和 `aca`。在一些应用中，我们求出全部的极大回文子串（不被其他回文串包含的回文子串）。

## 大体思路
首先，最容易想到的显然是**穷举法**：枚举一个字符串，找出其所有的子串，判断回文，然后输出最大长度。
```cpp
bool check(){ 
   int mid = strlen(s) / 2;
   int last = strlen(s) - 1;
   for (int i = 0; i < mid; i++ ){
   		if (s[i] != s[last - i]) {
          return false;        
      }    
   }
	return true;
}
string find(){
    int last = strlen(s) - 1;
    string longest = string(s[0]);
    for (int i = 0; i < last; i++ ){ 
       for (int j = i + 1;j <= last; j++) { 
          if check(s[j + 1]) && j + 1 - i > strlen(longest) { 
               longest = s[j+1];
           } 
  }   
 } 
   return longest;
}
```
其中，判断的时间复杂度是 $O(n)$，寻找子串的时间复杂度是 $O(n^2)$，整个代码的时间复杂度为 $O(n^3)$，显然不合格。

解决本题也可以用动态规划，满足
$$dp(i,j)=\begin{cases}dp(i+1,j-1),s_i=s_j\\0,s_i\neq s_j\end{cases}$$

其时间复杂度为 $O(n^2)$。

不过，最好的方法肯定是：$\huge\text{Manacher}$。

这是一个专门用作处理最长回文子串的方法，思想很巧妙，比较难以理解，这里直接借用了别人的讲解方法。其实主要思想是，把给定的字符串的每一个字母当做中心，向两边扩展，这样来找最长的子回文串，这个叫中心扩展法，但是这个方法还要考虑到处理 abba 这种偶数个字符的回文串。Manacher 法将所有的字符串全部变成奇数个字符。

Manacher 算法原理：

首先，Manacher 算法提供了一种巧妙地办法，将长度为奇数的回文串和长度为偶数的回文串一起考虑，具体做法是，在原字符串的每个相邻两个字符中间插入一个分隔符，同时在首尾也要添加一个分隔符，分隔符的要求是不在原串中出现，一般情况下可以用 `#` 号。

Manacher 算法用一个辅助数组 $Len[i]$ 表示以字符 $T[i]$ 为中心的最长回文字串的最右字符到 $T[i]$ 的长度，比如以 $T[i]$ 为中心的最长回文字串是 $T[l,r]$，那么 $Len[i]=r-i+1$。

Len 数组有一个性质，那就是 $Len[i]-1$ 就是该回文子串在原字符串S中的长度，至于证明，首先在转换得到的字符串T中，所有的回文字串的长度都为奇数，那么对于以 $T[i]$ 为中心的最长回文字串，其长度就为 $2\times Len[i]-1$，经过观察可知，$T$ 中所有的回文子串，其中分隔符的数量一定比其他字符的数量多 1，也就是有 $Len[i]$ 个分隔符，剩下 $Len[i]-1$ 个字符来自原字符串，所以该回文串在原字符串中的长度就为 $Len[i]-1$。

有了这个性质，那么原问题就转化为求所有的 $Len[i]$。下面介绍如何在线性时间复杂度内求出所有的 $Len$。

首先从左往右依次计算 $Len[i]$，当计算 $Len[i]$ 时，$Len[j](0\le j<i)$ 已经计算完毕。设 $P$ 为之前计算中最长回文子串的右端点的最大值，并且设取得这个最大值的位置为 $po$，分两种情况：

第一种情况：$i\le P$

那么找到 $i$ 相对于 $po$ 的对称位置，设为 $j$，那么如果 $Len[j]<P-i$，如下图：

![](https://img-blog.csdn.net/20141221160212654)

那么说明以 $j$ 为中心的回文串一定在以 $po$ 为中心的回文串的内部，且 $j$ 和 $i$ 关于位置 $po$ 对称，由回文串的定义可知，一个回文串反过来还是一个回文串，所以以 $i$ 为中心的回文串的长度至少和以 $j$ 为中心的回文串一样，即 $Len[i]\ge Len[j]$。因为 $Len[j]<P-i$，所以说 $i+Len[j]<P$。由对称性可知 $Len[i]=Len[j]$。
 
如果 $Len[j]>=P-i$,由对称性，说明以 $i$ 为中心的回文串可能会延伸到 $P$ 之外，而大于 $P$ 的部分我们还没有进行匹配，所以要从 $P+1$ 位置开始一个一个进行匹配，直到发生失配，从而更新 $P$ 和对应的 $po$ 以及 $Len[i]$。

![](https://img-blog.csdn.net/20141221160232375)

第二种情况: $i>P$  暴力。

时间复杂度：$O(n)$。
## 完整代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=5000001;
char s[MAXN];
char s_new[MAXN<<1];//存添加字符后的字符串 
int p[MAXN<<1];
int Init(){//形成新的字符串 
    int len=strlen(s);//len是输入字符串的长度
    s_new[0]='#';//处理边界，防止越界 
    s_new[1]='#';
    int j=2; 
    for(int i=0;i<len;i++) {
        s_new[j++]=s[i];
        s_new[j++]='#';
    } 
    s_new[j]='\0';//处理边界，防止越界（容易忘记） 
    return j;// 返回s_new的长度 
}
int Manacher(){//返回最长回文串 
    int len=Init();//取得新字符串的长度， 完成向s_new的转换
    int max_len=-1;//最长回文长度
    int id;
    int mx=0;
    for(int i=1;i<=len;i++) {
        if(i<mx)
            p[i]=min(p[2*id-i],mx-i);//上面图片就是这里的讲解 
        else p[i]=1;
        while(s_new[i-p[i]]==s_new[i+p[i]])//不需边界判断，因为左有'$'，右有'\0'标记；
            p[i]++;//mx对此回文中点的贡献已经结束，现在是正常寻找扩大半径
        if(mx<i+p[i]) {//每走移动一个回文中点，都要和mx比较，使mx是最大，提高p[i]=min(p[2*id-i],mx-i)效率 
            id=i;//更新id 
            mx=i+p[i];//更新mx 
        }
        max_len=max(max_len,p[i]-1); 
    } 
    return max_len; 
}
#define re register
#define gg getchar()
inline int read(){
    re int x=0,f=-1;
    re char c=gg;
    while(!isdigit(c)){
        if(c=='-') f=-1;
        c=gg;
    }
    while(isdigit(c)){//使用时把这个改了
        x=(x<<1)+(x<<3)+(c^48);
        c=gg;
    }
    return x*f;
}//快读
int main(){
    int t;
    scanf("%d",&t);
    while(t--){
        memset(p,0,sizeof(p));
        scanf("%s",&s);
        printf("%d\n",Manacher());//计算输出
    }
    return 0;
}

//manacher算法经典题目
```

---

## 作者：user2004 (赞：2)

不给数据范围，肯定$O(n^3)$暴力走起阿~~~

结果TLE＝　＝＃

仔细一看，原来是manacher的一道题

不会点我>>[P3805 【模板】manacher算法](https://www.luogu.org/problem/P3805)

关键在换行符上，不注意就本机AC，提交爆零了...
```cpp
#include<cstring>
#include<algorithm>
#include<cstdio>
#include<iostream>
#define maxn 22000007
char data[maxn];
int _length[maxn];
int tot;
void readin()
{
	getchar();
	getchar();
	data[0]='$';
	data[1]='/';
	int count=2;
	char c=getchar();
	while(c<='z'&&c>='a') 
	{
		data[count++]=c;
		data[count++]='/';
		c=getchar();
	}
	tot=count;
}
void manacher()
{
	int maxright=0,mid;
	for(int i=1;i<tot;i++)
	{
		if(i<maxright)
    	_length[i]=std::min(_length[(mid*2)-i],_length[mid]+mid-i);
    	else _length[i]=1;
    	for(;data[i+_length[i]]==data[i-_length[i]];++_length[i]);
        if(_length[i]+i>maxright)
        {
            maxright=_length[i]+i;
            mid=i;
        }	
	}
}
void print()
{
	int _max=0;
	for(int i=1;i<tot;i++)
	_max=std::max(_max,_length[i]);
	std::cout<<_max-1<<"\n";
}
void clean()
{
	memset(_length,0,sizeof(_length));
	memset(data,0,sizeof(_length));	
}
int main()
{
	int n;
	std::cin>>n;
	for(int i=1;i<=n;i++)
	{
	readin();
	manacher();
	print();
	clean();
	}
}
```


---

## 作者：说好不哭 (赞：2)

# 题解 P1723 【高手过愚人节】
## 首先想说明一下写此题解的目的：1.算是对自己学习的一个算法的总结；2.想提一下Manacher算法中一个小优化的原理（我看到无论是[重题](https://www.luogu.org/problemnew/show/P3805)，还是此题，题解中均无提及）
## 下面先上代码，对于还不理解Manacher的同学，先大致看一下别的代码理解一下，我的题解主要是帮助大致有数但是卡在算法优化上的人的。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e7+1e6+5;
int p[2*N];
char s[N],str[2*N];

inline int change(){ 
//manacher算法预处理，注意，开头和结尾不能相同，中间插入的字符要与原有字符均不相同 
int len=strlen(s);	
str[0]='^';
str[1]='$';
int j=2;
	for (int i=0; i<len; i++)
	{
	str[j++]=s[i];
	str[j++]='$';
	}
str[j]='&';
return j;
}

inline int manacher(){
int len=change(); 
int mid=1,mx=1,ans=-1;//定义mx和mid，表示目前找到的回文串的右端的最右是mx，中心是mid。
	for (int i=1; i<len; i++)
	{
	if (i<mx) p[i]=min(mx-i,p[mid*2-i]);  //此句优化算法
//对于此句的理解：如果已经搜到的mx比i,说明 mid-p[mid]+1 ~ mid+p[mid]-1（边界有错忽略，大致是这个）,这个区间是回文字符串 
//所以 str[i]=str[mid*2-i],
//所以 str[i+1]=str[mid*2-i-1],str[i+2]=str[mid*2-i-2]...... 
//所以 str[i-1]=str[mid*2-i+1],str[i-2]=str[mid*2-i+2]......
//所以 p[i]=p[mid*2-i], 而p[mid*i-2]已经得出答案，所以可以小优化算法
//这里要注意,这个 p[i]值不能超过 mx-i,这应该是显然的。所以,对于这个min的理解,不应该主观理解为取较小值，
//而是应该理解为： p[i]的值可以用 p[mid*2-i]来代替，但由于 i+p[mid*2-i]可能会超过mx,使得算法错误，所以用一个mx-i来限制，
//使得这个值永远在mx以内 ，从而在保证算法正确性的基础上做到算法的优化 
	else p[i]=1;
	while (str[i+p[i]]==str[i-p[i]]) p[i]++; //此句保证算法正确性 
	if (i+p[i]>mx) mid=i,mx=i+p[i]; //对于当前搜到的最大的右端点，赋值。
	//此句优化算法 
	ans=max(ans,p[i]-1);//此句保证算法正确性 
	}
return ans;
}

int main(){
scanf("%s",s);
printf("%d\n",manacher());
return 0;
}
```
## 代码中的注释很详细了，里面提及的是，为什么p[i]=min(mx-i,p[mid*2-i])能够保证算法的正确性和优化性，所以这里不多说了。而Manacher算法正是用了这句核心语句，使得许多重复的累加判断省略，得到的复杂度是近似O（n）。


---

## 作者：JuRuo_QAQ (赞：2)

妥妥的 manacher 裸题。。。。。

不会 manacher 的左转 P3805。

只需要把 manacher 的模板写一遍就可以了，注意字符数组开大点防止 RE。

~~白嫖一道蓝题真不戳。~~

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int m=1.2e7;
char s[m<<1],c[m];
int p[m<<1];
int mid=1,r=1,ans,n;
int main(){
	cin>>n;
	while(n--){
		mid=1,r=1,ans=0;
	   	scanf("%s",c);
	        int len=strlen(c),cnt=2;
		s[0]='^';s[1]='#';
		for (int i=0;i<len;i++)s[cnt++]=c[i],s[cnt++]='#';
		s[cnt]='@';
		for (int i=1;i<cnt;i++){
		    if (i<r)p[i]=min(r-i,p[mid*2-i]);
		    else p[i]=1;
		    while (s[i-p[i]]==s[i+p[i]])p[i]++;
		    if (r<p[i]+i)mid=i,r=p[i]+i;
		    ans=max(ans,p[i]);
		}//manacher模板
		printf("%d\n",ans-1);
	}
	return 0;
}
```


---

## 作者：decoqwq (赞：2)

pam 板子题

(~~其实是因为不会manacher~~)

在有关回文串的题目中常用 pam ，即回文自动机来解决问题，pam 是由两棵树组成的，分别存储长度为奇数的回文串和偶数的回文串，每一个节点都代表了一个**回文串**。

接下来是几个数组的含义：

`next[x][y]` 表示 $x$ 节点在前后都增加一个字符 `y` 转移到的节点。

`len[x]` 表示 $x$ 节点代表的回文串长度，显然 `len[next[x][y]]=len[x]+2`。

`fa[x]` 表示 $x$ 节点所代表的回文串的**最长回文后缀**的节点（注意这里的最长回文后缀是指长度小于原串的最长回文后缀）。

我们令两个根节点 $0,1$ 中，$0$ 代表偶数长度的根，$1$ 
代表奇数长度的根，为了方便，令 `len[0]=1,len[1]=-1`，且 `fa[0]=1,fa[1]=0`

考虑插入一个新的字符，我们从上一次插入的节点开始，每次判断 `s[n]` 是否等于 `s[n-len[last]-1]`，如果不等于就一直将 `last` 赋值为 `fa[last]` ，等于的时候 `last` 就是新节点的父亲，就算一直不相等，最后一定会停在 $1$ 号点，此时自己等于自己，新的节点的含义也就是一个长度为 $1$ 的回文串（如果这个节点已经存在无视即可）

用之前说的，新节点的 $len$ 是原来的加二，类似于 AC自动机，考虑新节点的 $fa$ ，找到使 `x=fa[x]` ，末尾加入字符 `s[i]` 之后，再找一次最长回文后缀即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
char s[1000010];
int n,m;
struct PAM
{
	int len[1000010],fa[1000010],next[1000010][26];
	int last=0,tot=1,ans=0;
	void clear()
	{
		last=0,tot=1;
		fa[0]=1,fa[1]=0,len[0]=0,len[1]=-1;
		memset(next[0],0,sizeof(next[0]));
		memset(next[1],0,sizeof(next[1]));
	}
	int newnode(int x)
	{
		len[++tot]=x;
		memset(next[tot],0,sizeof(next[tot]));
		fa[tot]=0;
		return tot;
	}
	int find(int x)
	{
		while(s[n-len[x]-1]!=s[n])
		{
			x=fa[x];
		}
		return x;
	}
	void ins(int x)
	{
		int u=find(last);
		if(!next[u][x])
		{
			int now=newnode(len[u]+2);
			int v=find(fa[u]);
			fa[now]=next[v][x];
			next[u][x]=now;
		}
		last=next[u][x];
		ans=max(ans,len[last]);
	}
}A;
int main()
{
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		scanf("%s",s+1);
		int mxl=strlen(s+1);
		A.clear();
		for(n=1;n<=mxl;n++)
		{
			A.ins(s[n]-'a');
		}
		cout<<A.ans<<"\n";
	}
}
```

---

## 作者：Deny_小田 (赞：2)

# 我不会告诉你我做了[h1][b][i][color="blue"]26次[/color][/i][/b][/h1]才AC！！

## 今天小田要让大家失望了。

# 大家可以看看我的血泪史，填满了整整一页啊！！


刚开始我用的暴力方法，50分，不说了，咋剪枝都不行。

然后@度娘，找到了一种名为“Manacher”的算法，有兴趣的同学可以看看。

manacher的具体做法我不说了，推荐几个链接：


http://blog.csdn.net/heavenrhell/article/details/37512195

http://www.cnblogs.com/kuangbin/archive/2012/11/09/2763466.html

string类型UAC了！！string类型UAC了！！string类型UAC了！！重要的事情说3遍。

我最后借鉴的@shengmingkexue 同学。非常感激TA！TA用的是char[]类型，就AC了。


因为涉及版权问题，本题解不引用TA的代码。

实在想抄？我给你提供一个我写的60分代码，然后。。你自己看着办吧，因为TA加入了代码公开计划，so可以chao（抄），要不然我都得UAC！！


附：





        
        





```cpp
#include <cstdio>
#include <string>
#include <iostream>
using namespace std;
const int size = 1000005;
int p[2*size],n;
string str,newstr;
int min(int a,int b){ return a<b?a:b; }
int max(int a,int b){ return a>b?a:b; }
void change(){
    newstr = "#";
    for(int i = 0; i < str.size(); i++){ newstr += "#"; newstr += str[i]; }
    newstr += "#";
}
int Manacher(int len){
    int id,ans = 1,maxid = 0;
    for(int i = 0; i < len; i++){
        if(maxid > i) p[i] = min(p[2*id-i],maxid-i);
        else p[i] = 1;    
        while((newstr[i+p[i]] == newstr[i-p[i]])&&(i-p[i] >= 0)&&(i+p[i] < len)) p[i]++;
        if(p[i]+i > maxid){
            maxid = p[i]+i;
            id = i;
        }
        ans = max(ans,p[i]);
    }
    return ans-1;
}
int main(int argc, char const *argv[]){
    scanf("%d",&n); getchar();
    while(n--){
        cin >> str;
        change();
        printf("%d\n",Manacher(newstr.size()));
    }
    return 0;
}
PS：本人乃蒟蒻王国的高级将领，本题解难免有错误之处。欢迎各位童鞋骚年指出，我在这里非常感激！（套话。。。）
```

---

## 作者：星之海 (赞：1)

难道就没有用manacher算法直接套模板的吗？

这是一道裸的模板

每次算之前初始化一下就可以了

直接贴代码：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define maxn 5000001
using namespace std;
int n,lache[maxn],ans,t;
char a[maxn],s[maxn<<1];
void malache()
{
    int maxright=0,mid;
    for(int i=1;i<n;i++)
    {
        if(i<maxright)
            lache[i]=min(lache[(mid<<1)-i],lache[mid]+mid-i);
        else
            lache[i]=1;
        for(;s[i+lache[i]]==s[i-lache[i]];++lache[i]);
        if(lache[i]+i>maxright)
        {
            maxright=lache[i]+i;
            mid=i;
        }
    }
}
void change()
{
    s[0]=s[1]='#';
    for(int i=0;i<n;i++)
    {
        s[i*2+2]=a[i];
        s[i*2+3]='#';
    }
    n=n*2+2;
    s[n]=0;
}
int main()
{
	cin>>t;
	while(t--)
	{
	    cin>>a;
	    n=strlen(a);
	    memset(lache,0,sizeof(lache));
	    change();
	    malache();
	    ans=1;
	    for(register int i=0;i<n;i++)
	    ans=max(ans,lache[i]);
	    cout<<ans-1<<endl;
	}
    return 0; 
}
```

---


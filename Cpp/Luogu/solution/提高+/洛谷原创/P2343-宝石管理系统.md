# 宝石管理系统

## 题目描述

GY 君购买了一批宝石放进了仓库。有一天 GY 君心血来潮，想要清点他的宝石，于是把 $m$ 个宝石都取出来放进了宝石管理系统。每个宝石 $i$ 都有一个珍贵值 $v_i$，他希望你能编写程序查找到从大到小第 $n$ 珍贵的宝石。但是现在问题来了，他非常不小心的留了一些宝石在仓库里面，有可能要往现有的系统中添加宝石。这些宝石的个数比较少。他表示非常抱歉，但是还是希望你的系统能起作用。


## 说明/提示

对于 $50\%$ 的数据，没有 $c=2$ 的情况；

对于 $100\%$ 的数据，$m\leq 100000$，$c=2$ 的情况不超过 $10000$ 次，$q\leq 30000$，$0 \leq v_i \lt 2^{31}$。


## 样例 #1

### 输入

```
5 3
1 3 2 5 6
1 3
2 4
1 6
```

### 输出

```
3
1```

# 题解

## 作者：归褯雾嵊 (赞：11)

------------------------
题目大意：开始给出m个宝石，~~她~~它们有各自的价值，然后会有好多询，或后者添加宝石操作，添加宝石就是把新宝石加入宝石堆里，询问的话是找价值第n大的宝石。

-----------------------
我一看这题就想到了一个叫做平衡树的东西，平衡树是二叉搜索树和堆合并构成的新数据结构，所以它的名字取了Tree和Heap各一半，叫做Treap，非常好用，而且这道题并不需要打整颗平衡树，只需要插入宝石到数中，在rank就行了

![](https://img-blog.csdn.net/20160619172814634)

这个就是一个平衡树。不会的话就顺便去这里：(https://blog.csdn.net/qq_21120027/article/details/51713248)
学一个新的数据结构吧。。。


```
/*
ID:wang1441
LANG: C++
TASK:
*/
#include<bits/stdc++.h>
#define ll long long

using namespace std;

inline int read()
{
    int x=0;
    char ch=getchar();
    char c=ch;
    while(ch>'9'||ch<'0')c=ch,ch=getchar();
    while(ch<='9'&&ch>= '0')x=x*10+ch-'0',ch=getchar();
    if(c=='-')x=x*-1;
    return x;
}
//const int maxn=,maxm=;
struct node{
	node *wudi[2];
	int r,v,s;
	int cmp(int x)const
	{
		return x>v?0:1;
	}
	void maintain(){
		s=wudi[0]->s+wudi[1]->s+1;
	}
}*null,*root;

int a[100010];
int n,m;
int q,c;

void wwwwww(node * &o,int d)
{
	node * k=o->wudi[d^1];
	o->wudi[d^1]=k->wudi[d];
	o->maintain();
	k->maintain();
	k->wudi[d]=o;
	o=k;
}

void eeeeee(node * &o,int x)
{
	if(o==null){
		o=new node();
		o->wudi[0]=o->wudi[1]=null;
		o->v=x;
		o->r=rand();
		o->maintain();
	}
	else{
		int d=o->cmp(x);
		eeeeee(o->wudi[d],x);
		if(o->wudi[d]->r>o->r)
		    wwwwww(o,d^1);
		o->maintain();
	}
}

void tttttttttt()
{
	null=new node();
	null->s=0;
	root=null; 
}


void rrrrrrrrrrr(node * o,int x)
{
	if(o==null)
	    return ;
	int d=o->wudi[0]->s;
	if(x==d+1){
		printf("%d\n",o->v);
		return ;
	}
	if(x<d+1)
	    rrrrrrrrrrr(o->wudi[0],x);
	else
	    rrrrrrrrrrr(o->wudi[1],x-d-1);
}

int main()
{
    //freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	tttttttttt();
	m=read();
	q=read();
	srand(time(NULL));
	for(register int i=1;i<=m;i++){
		a[i]=read();
		eeeeee(root,a[i]);
	}
	for(register int i=1;i<=q;i++){
		c=read();
		n=read();
		if(c==1){
			rrrrrrrrrrr(root,n);
		}
		if(c==2){
			eeeeee(root,n);
		}
	}
}

```

---

## 作者：huang_yue (赞：10)

其实这一题只用暴力枚举就行了，记得用register加快一点速度。

读入时首先存入数组排序，然后可以轻松处理c==1的情况；而由于c==2的情况较少，使用数组也可以处理。

```
//头文件已省略
int v[200010];

int main() {
	int m, q; cin >> m >> q;
	for (register int i = 0; i < m; ++i) cin >> v[i]; //读入数据
	sort(v, v + m, greater<int>()); //记得是从大到小排列
	for (register int i = 0; i < q; ++i) {
		int x, y; cin >> x >> y;
        //从0开始存储，所以y要减一
		if (x == 1) cout << v[y - 1] << endl;
		if (x == 2) {
        	//其实不需要用lower_bound什么的，直接顺序遍历找到插入位置即可
			register int* w = v;
			for (; w != v + m && *w > y; ++w);
            //元素向后移动一位
			for (register int* q = v + m - 1; q >= w; --q)
				*(q + 1) = *q;
			*w = y; ++m;
		}
	}
}
```

---

## 作者：Katsura_Hinagiku (赞：7)

好像还没有人写fhq treap的

~~我先水一篇~~

其实就是维护一棵可以求区间第k大的平衡树（~~模板题~~）。

废话不多说，上代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
	int l,r,sz,pri,val;
}tree[150005];
int tot=0,root,m,q;
int newnode(int x)
{
	tree[++tot].val=x;
	tree[tot].pri=rand();
	tree[tot].sz=1;
	return tot;
}
void pushup(int u)
{
	tree[u].sz=tree[tree[u].l].sz+tree[tree[u].r].sz+1;
}
void split(int u,int x,int &l,int &r)
{
	if(!u)
	{
		l=r=0;
		return;
	}
	if(tree[u].val<=x)
	{
		l=u;
		split(tree[u].r,x,tree[u].r,r);
	}
	else
	{
		r=u;
		split(tree[u].l,x,l,tree[u].l);
	}
	pushup(u);
}
int merge(int l,int r)
{
	if(!l||!r)return l+r;
	if(tree[l].pri<tree[r].pri)
	{
		tree[l].r=merge(tree[l].r,r);
		pushup(l);
		return l;
	}
	else
	{
		tree[r].l=merge(l,tree[r].l);
		pushup(r);
		return r;
	}
}
int kth(int u,int rank)
{
	while(1)
	{
		if(rank<=tree[tree[u].l].sz)
		{
			u=tree[u].l;
		}
		else if(rank==tree[tree[u].l].sz+1)
		{
			return tree[u].val;
		}
		else
		{
			rank=rank-tree[tree[u].l].sz-1;
			u=tree[u].r;
		}
	}
}
void ins(int x)
{
	int L,R;
	split(root,x,L,R);
	root=merge(merge(L,newnode(x)),R);
}
int main()
{
	srand(19260817);
	scanf("%d%d",&m,&q);
	for(int i=1;i<=m;++i)
	{
		int v;
		scanf("%d",&v);
		ins(v);
	}
	for(int i=1;i<=q;++i)
	{
		int c,n;
		scanf("%d%d",&c,&n);
		if(c==1)
		{
			printf("%d\n",kth(root,tree[root].sz-n+1));
		}
		if(c==2)
		{
			ins(n);
		}
	}
	return 0;
}
```

---

## 作者：ADay (赞：6)

[更好的阅读体验](https://aday526.github.io/%E9%A2%98%E8%A7%A3%20P2343%20%E3%80%90%E5%AE%9D%E7%9F%B3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E3%80%91/)

好像还没有`vector`水过的题解~~赶紧水一发~~

我们可以维护一个 $\texttt{元素有序的}$ `vector`,以方便询问操作。

那么这时对于插入操作，因为我们已经保证了它是有序的，我们可以**二分查找出小于此数的最大元素**，用`insert`函数插入在它前面即可。

而`insert`函数，它的复杂度在我看来是$\mathcal {O}(\text{玄学})$，看上去它是$\mathcal O(log\;n)$，但有很多大佬说是$\mathcal O(n)$，只是常数小罢了。总之，能过此题

但要注意一下，因为我懒不想自己写二分，就用了`STL`的`upper_bound`取大于它的最小数，所以每次我们插入时要插入那个数的相反数，同理询问也取相反数

思路的确挺简单，上代码

```cpp
#include<bits/stdc++.h>
#define upp(x) (upper_bound(a.begin(),a.end(),x))//懒qwq
using namespace std;

inline int read()//快读
{
    int s=0,f=1;
    char ch=getchar();
    while(!isdigit(ch))
    {
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        s=s*10+ch-48;
        ch=getchar();
    }
    return s*f;
}

int m,q,c,n;
vector<int>a;//就是那个vector

int main()
{
    m=read();q=read();
    while(m--)
    {
        n=read();
        a.insert(upp(-n),-n);//插入相反数
    }
    while(q--)
    {
        c=read();n=read();
        if(c==1)
            printf("%d\n",-a[n-1]);//询问相反数
        else
            a.insert(upp(-n),-n);//插入相反数
    }
    return 0;
}
```

---

## 作者：123456zmy (赞：6)

~~看到还没用题解用块状链表的，赶紧来水一发。~~
___
题意：  
给你 $m$ 个数，$q$ 次操作，每次加入一个数 $n$ 或查询全局第 $k$ 大。
___
其实就是用分块优化的暴力。先找到是对哪一块操作，再加个暴力即可，如果一块过大，则强行拆成两块，插入和查询都是 $O(\sqrt{m})$ 的。因为我写的是从小到大排序，所以每次查询要稍微改一点。

代码：（码风邪教，复杂度：$O((m+q)\sqrt{m})$，开 O2 之后跑得飞起）
```cpp
#include<bits/stdc++.h>
using namespace std;
int c,n,m,q,a[501][501],al[501],an=1,v0,nxt[501],h=1;
void ins(int k)//插入
{
	int i,j;
	for(j=h;nxt[j]&&a[nxt[j]][1]<k;j=nxt[j]);
	for(i=1;i<=al[j]&&a[j][i]<k;i++);
	++al[j];
	for(;i<=al[j];i++)swap(k,a[j][i]);
	if(al[j]==500)
	{
		nxt[++an]=nxt[j];
		nxt[j]=an;
		al[j]=al[an]=250;
		for(i=251;i<=500;i++)swap(a[an][i-250],a[j][i]);
	}
}
int find(int k)//查询
{
	int j,n1=0;
	for(j=h;nxt[j]&&n1+al[j]<k;j=nxt[j])n1+=al[j];
	return a[j][k-n1];
}
int main()
{
	scanf("%d%d",&m,&q);
	for(int i=1;i<=m;i++)scanf("%d",&v0),ins(v0);//其实可以用sort来优化的。
	while(q--)
	{
		scanf("%d%d",&c,&n);
		if(c==1)printf("%d\n",find(m-n+1));
		else ins(n),++m;
	}
	return 0;
}
```

---

## 作者：Anoxiacxy (赞：5)

### 二分+树状数组

树状数组大法好，看楼下一堆平衡树级别的高级数据结构，不仅打个寒颤（不会平衡树），然后乱搞搞出了这么一个玩意

大致就是离散化之后维护一个权值树状数组，加入宝石就在相应的位置+1，然后查询时二分答案，用树状数组算出当前宝石的排名，进而调整答案，总复杂度O(q log^2m)，代码如下


```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <cmath>
#include <queue>
#include <cmath>
#define LL long long
#define mp make_pair
#define pb push_back
using namespace std; 
int n,m,tot;
struct BIT{
    int s[200200],sum;
    void add(int p){for(int i=p;i<=tot;i+=i&(-i))s[i]++;sum++;}
    int query(int p){int rtn=0;for(int i=p;i;i-=i&(-i))rtn+=s[i];return rtn;}
}S;
struct Qry{
    int c,v;
};
vector<Qry>q;
int a[200200];
int num[200200];
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]),num[++num[0]]=a[i];
    for(int i=1;i<=m;i++){
        int x,y;scanf("%d%d",&x,&y);
        if(x==2)num[++num[0]]=y;
        q.pb({x,y});
    }
    sort(num+1,num+1+num[0]);
    num[0]=unique(num+1,num+1+num[0])-num-1;
    tot=num[0];
    for(int i=1;i<=n;i++){
        int rnk=lower_bound(num+1,num+1+num[0],a[i])-num;
        S.add(rnk);
    }
    for(int i=0;i<m;i++){
        if(q[i].c==1){
            int l=1,r=tot;
            while(l<r){
                int mid=l+r>>1;
                if(S.sum-S.query(mid)>=q[i].v)l=mid+1;
                else r=mid;
            }
            printf("%d\n",num[l]);
        }else {
            int rnk=lower_bound(num+1,num+1+num[0],q[i].v)-num;
            S.add(rnk);
        }
    }    
}
```

---

## 作者：Fraction (赞：4)

把$4$版题解翻了个遍，发现好像没有权值线段树的做法，那么就由我来补一个吧。

首先我们要先了解一下什么是权值线段树。

既然它的名字里有一个线段树，就说明它肯定是通过线段树维护的。通过进一步的了解，我们就会发现，它维护的东西非常特殊。在离散化之后，它的叶节点（标号顺序从左往右）存的就是每个数字出现的次数。

如果你觉得我讲得有一点抽象，或者是你朦朦胧胧听懂了一点但是没有很明白，那么请继续往下看。

我们以数组$[11,11,422,422,422,3472,4197,4197]$为例。

在离散化之后，数组变为$[1,1,2,2,2,3,4,4]$

对这个数组建一颗权值线段树，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/4w0tsrf0.png)

用这个权值线段树，我们可以办到很多平衡树能够办到的事情。

- **求一个数x的排名**

这个应该很好理解，我们可以用线段树求出区间$[1,x-1]$的区间和，然后再$+1$，就能够得到$x$的排名。

```cpp
int rank(int x, int nowl, int nowr, int wantl, int wantr) {
	int ret = 0;
	if(wantl <= nowl && nowr <= wantr) {
		return tree[x];
	}
	int mid = (nowl + nowr) >> 1;
	if(wantl <= mid) ret += rank(ls(x), nowl, mid, wantl, wantr);
	if(wantr > mid) ret += rank(rs(x), mid+1, nowr, wantl, wantr);
	return ret;
}
```

- **求排名为k的数**

这个和平常的线段树有一点点不一样。

如果当前节点左儿子的权值$\geq k$，就说明排名为$k$的数肯定在左子树，否则就在右子树。

```cpp
int kth(int x, int l, int r, int k) {
	if(l == r) {
		return l;
	}
	int mid = (l + r) >> 1;
	if(tree[ls(x)] >= k) return kth(ls(x), l, mid, k);
	if(tree[ls(x)] < k) return kth(rs(x), mid+1, r, k-tree[ls(x)]);//注意这里，k要变成k-tree[ls(x)]，因为我们减去了左子树的权值
}
```

- **求一个数x的前驱**

这个操作可以用上面$rank$操作和$kth$操作共同完成。

首先求出$x$的排名，再减去$1$就可以了。

就算有重复的元素，我们这里求出来的排名是当前所有重复元素的第一个，减去$1$就是前面一种元素的最后一个，并不碍事。

```cpp
int used = lower_bound(use+1, use+1+maxsize, xx[i])-use;
int rankx = rank(1, 1, maxsize, 1, used-1)+1;
printf("%d\n", use[kth(1, 1, maxsize, rankx-1)]);
```

- **求一个数x的后继**

这个操作和上面那个操作差不多，似乎更简单一点。

首先求出$[1,x]$的区间和，再加上1，就可以得到$x+1$的排名，再用$kth$函数求出$x$的后继即可。

在本题，我们只需要$kth$操作。

如果想要实现以上的操作，请移步[**【模板】普通平衡树**](https://www.luogu.org/problem/P3369)。

下面是本题的思路。

首先离散化，然后把已经取出的宝石加入线段树（我太懒了不想额外再写一个建树，所以直接$O(nlogn)$把宝石加进去了），最后处理$q$个操作，$c[i]=1$就用$kth$函数，$c[i]=2$更新线段树即可。

有两个要注意的地方：

1.本题的空间应该开到$M+Q$，我一开始只开了$M$的空间，$WA$成了$90pts$

2.习惯上，我喜欢按离散化顺序从小到大建树（事实上这种写法更也不容易错），然而这题是要求价值第$n$大的宝石。所以我定义了一个$nowsize$来表示当前有多少个宝石已经加入系统。

代码如下：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define ls(x) (x << 1)
#define rs(x) (x << 1 | 1)
using namespace std;

int m, q;
int cnt;
int v[200010], use[200010], opt[200010], c[200010];
int tree[200010 << 2]; 

void update(int x, int l, int r, int num) {
	if(l == r) {
		tree[x]++;
		return ;
	}
	int mid = (l + r) >> 1;
	if(num <= mid) update(ls(x), l, mid, num);
	else update(rs(x), mid+1, r, num);
	tree[x] = tree[ls(x)] + tree[rs(x)];
	return ;
}

int kth(int x, int l, int r, int k) {
	if(l == r) {
		return l;
	}
	int mid = (l + r) >> 1;
	if(k <= tree[ls(x)]) return kth(ls(x), l, mid, k);
	else return kth(rs(x), mid+1, r, k-tree[ls(x)]);
}

void init() {
	scanf("%d%d", &m, &q);
	for(register int i = 1; i <= m; i++) {
		scanf("%d", &v[i]);
		use[i] = v[i];
	}
	cnt = m;
	for(register int i = 1; i <= q; i++) {
		scanf("%d%d", &opt[i], &c[i]);
		if(opt[i] == 2) {
			use[++cnt] = c[i];
		}
	}
   return ;
}

void solve() {
	sort(use+1, use+1+cnt);
	int used, nowsize = m, maxsize = unique(use+1, use+1+cnt) - use - 1;
	for(register int i = 1; i <= m; i++) {
		used = lower_bound(use+1, use+1+maxsize, v[i]) - use;
		update(1, 1, maxsize, used);
	}
	for(register int i = 1; i <= q; i++) {
		if(opt[i] == 1) {
			printf("%d\n", use[kth(1, 1, maxsize, (nowsize-c[i]+1))]);
		}
		else {
			used = lower_bound(use+1, use+1+maxsize, c[i]) - use;
			update(1, 1, maxsize, used);
			++nowsize;
		}
	}
   return ;
}

int main() {
	init();
	solve();
	return 0;
}
```

---

## 作者：Hatsune_Miku (赞：2)

随机跳题跳到了这一题。第一眼看上去，嗯，平衡树裸题。插入和查询 $k$ 大的经典操作。

### 算法 0：优雅的暴力

实际上，我们不需要写任何的高级数据结构即可完成这道题目。我们注意到题目中的一句关键的话：

> 有可能要往现有的系统中添加宝石。这些宝石的个数比较少。

这意味着我们不需要处理太多次插入操作。加之数列的长度为 $10^5$，询问次数也非常少（$10^4$ 级别），所以我们可以作出一个大胆的假设：

> 这个数列在大多数时间**几乎**是静态的。

所以我们只需要用一个 `vector` 搞一下事情即可（其实用 `vector` 也能水过一些数据不是太强的平衡树的题）。虽然说 `vector` 自带的 `insert()` 函数时间复杂度为 $\mathcal{O}(n)$ 的，但是面对数据不是太强的题目还是绰绰有余的。于是我们在线处理所有的插入和询问操作，使用 `lower_bound()` 函数查找数应该插入的位置即可。所有插入操作最差情况下总复杂度为 $\mathcal{O}(n^2\log n)$，但是实际上并不能达到这一复杂度（没有特殊构造数据的话每一次插入最小的一个数是不现实的）。

只需要注意一个细节，由于我们需要从大到小排序，所以把每个数都变成它的相反数再插入即可。

```cpp
// luogu-judger-enable-o2
// 697ms 1.27M with O2
#include <cstdio>
#include <vector>
#include <cassert>
#include <algorithm>
using namespace std;
vector<int> BST;
inline void Insert(int v) {
  BST.insert(upper_bound(BST.begin(), BST.end(), v), v);
}
inline void Query(int rank) {
  assert(rank <= int(BST.size()));
  printf("%d\n", -BST[rank - 1]);
}
int m, q, x, opt;
int main() {
  scanf("%d%d", &m, &q);
  while(m--) {
    scanf("%d", &x);
    Insert(-x);
  }
  while(q--) {
    scanf("%d%d", &opt, &x);
    if(opt & 1) Query(x);
    else Insert(-x);
  }
  return 0;
}
```

### 算法 1：更优雅的暴力

如果感觉暴力插入会 TLE 的话，可以对一开始插入的所有数（没有查询的一部分）使用 `sort()` 进行排序，复杂度为 $\mathcal{O}(n\log_2n)$，这一部分的复杂度不到 180 万。后期强制在线的部分为 $3\times10^4$ 次，其中插入不超过 $10^4$ 次，最差情况下总复杂度为 $\mathcal{O}(10^4\times\log_210^5\times10^5)\approx\mathcal{O}(18\times 10^9)$，其中 $18$ 太小了可以看作常数，每次查询都是严格 $\mathcal{O}(1)$ 的。这样的话我们就可以以最差情况下 $\mathcal{O}(10^9)$ 的复杂度通过这道题目了。这显然是可以在 1s 内通过的，并且也不太可能会达到这个最差的复杂度（暴力 AC）。

不管理论还是实践都证明了这样不会太慢，这下可以放心了吧？

```cpp
// luogu-judger-enable-o2
// 158ms 1.47M with O2
#include <cstdio>
#include <vector>
#include <cassert>
#include <algorithm>
using namespace std;
vector<int> BST;
inline void Insert(int v) {
  BST.insert(upper_bound(BST.begin(), BST.end(), v), v);
}
inline void Query(int rank) {
  assert(rank <= int(BST.size()));
  printf("%d\n", -BST[rank - 1]);
}
int m, q, x, opt;
int main() {
  scanf("%d%d", &m, &q);
  while(m--) {
    scanf("%d", &x);
    BST.push_back(-x);
  }
  sort(BST.begin(), BST.end());
  while(q--) {
    scanf("%d%d", &opt, &x);
    if(opt & 1) Query(x);
    else Insert(-x);
  }
  return 0;
}
```
（几乎就是上一份代码稍微改了一下）

### 算法 2：不会写平衡树者的平衡树—— 01-Trie

上述两个算法大概都是卡复杂度过去的，效率不是太好。我们再回来看看这道题目，实际上我们并不需要写一棵平衡树（显然并不是只有平衡树这一个数据结构才能维护这两个简单的信息），我们考虑 01-Trie 这一数据结构。它就能胜任这一任务了。

将每一个数转换成二进制存入 Trie 树中，对于 Trie 树上的每一个节点，我们都额外开一个 `size` 保存以它为根的子树的大小，插入的时候顺便直接更新节点的 `size` 值。查询的话，只需要在 Trie 树上按照 `size` 的指引搜索即可，单次查询和搜索的时间复杂度为 $\mathcal{O}(\log_2\max(a_i))$，那么最差情况下总的时间复杂度为 $\mathcal{O}(1.3\times10^5\log_2\mathrm{INT\_MAX})\approx\mathcal{O}(4.16\times10^6)$，是一个相当优秀的复杂度了。

并且这样写常数也比较小【比常用的平衡树常数小很多，能达到十分接近红黑树的效率（76ms 过普通平衡树）】，编码难度和调试难度都很小（相对于平衡树压行后近 100 行的长度，01-Trie 可以在 50 行之内完成，并且几乎不需要任何调试）。

可持久化什么的也十分容易（别告诉我您不会 Trie 树的可持久化）。缺陷在于不能区间打标记、空间占用较大【最多是平衡树占用空间的平方的常数~~（真的不小）~~倍】等等，但在一般情况下替代平衡树还是可以的。

```cpp
// luogu-judger-enable-o2
// 191 ms 19.48M with O2
#include <cstdio>
using namespace std;
const int maxn = 120000 * 35;
const int fix = 2147483647, full = 33;
struct node {
  node *ch[2];
  int size;
}*nil, *root, mem[maxn];
int cnt;
inline void newnode(node *&p) {
  mem[cnt].ch[0] = mem[cnt].ch[1] = nil;
  p = mem + cnt++;
}
inline void Insert(node *rt, long long x) {
  x += fix;
  for(register int i = full; ~i; --i) {
    bool op = x >> i & 1;
    if(rt->ch[op] == nil) newnode(rt->ch[op]);
    rt = rt->ch[op];
    rt->size += 1;
  }
}
inline void Query(node *rt, int k) {
  long long res = 0;
  for(register int i = full; ~i; --i) {
    if(k > rt->ch[0]->size)
      k -= rt->ch[0]->size, res |= 1 << i, rt = rt->ch[1];
    else rt = rt->ch[0];
  }
  printf("%lld\n", fix - res);
}
int main() {
  int m, opt, q;
  long long x;
  newnode(nil), nil->ch[0] = nil->ch[1] = nil; newnode(root);
  scanf("%d%d", &m, &q);
  while(m--) {
    scanf("%lld", &x);
    Insert(root, -x);
  }
  while(q--) {
    scanf("%d%lld", &opt, &x);
    if(opt & 1) Query(root, x);
    else Insert(root, -x);
  }
  return 0;
}
```

我太失败了，在 `int` 边界的数据一直爆，然后时间复杂度和空间复杂度都不是很好，被暴力吊打了……

后面两个算法 Rank 都不差的样子呢~


---

## 作者：Great_Influence (赞：2)

论熟练掌握pbds的重要性。

一眼就可以看出可以用平衡树。需要查rank无法使用set，可以用pbds中的tree。但是pbds不支持重复元素，不过可以发现，元素总数不超过1e6级别，只需要用double存储，每个数字加上一个1e7级别的数便可以解决重复问题了。代码量贼短，安利学一波。

代码：

```cpp
    #include<bits/stdc++.h>
    #include<cctype>
    #include<ext/pb_ds/assoc_container.hpp>
    #include<ext/pb_ds/tree_policy.hpp>
    #define For(i,a,b) for(i=(a),i##end=(b);i<=i##end;++i)
    #define Forward(i,a,b) for(i=(a),i##end=(b);i>=i##end;--i)
    #define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
    #define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
    using namespace std;
    template<typename T>inline void read(T &x){
        T s=0,f=1;char k=getchar();
        while(!isdigit(k)&&k^'-')k=getchar();
        if(!isdigit(k)){f=-1;k=getchar();}
        while(isdigit(k)){s=s*10+(k^48);k=getchar();}
        x=s*f;
    }
    void file(void){
        #ifndef ONLINE_JUDGE
        freopen("water.in","r",stdin);
        freopen("water.out","w",stdout);
        #endif
    }
    using namespace __gnu_pbds;
    tree<double,null_type,greater<double>,rb_tree_tag,tree_order_statistics_node_update>G;
    static int n,m;
    const double eps=1e-7;
    void init()
    {
        read(n);read(m);
        static int x;
        Rep(i,1,n)read(x),G.insert(x+eps*i);
    }
    void solve()
    {
        static int opt,x;
        Rep(i,1,m)
        {
            read(opt);read(x);
            if(opt==2)G.insert(x+eps*(++n));
            else printf("%d\n",(int)floor(*G.find_by_order(x-1)));
        }
    }
    int main(void){
        file();
        init();
        solve();
        return 0;
    }

```

---

## 作者：EternalEpic (赞：1)

## 此题有陷阱！

拿到此题，插入和查询kth，第一反应：平衡树；

陷阱1：有人会开值域树状数组或线段树，但他没有说明值域大小很可能开错RE
虽然题解里有人给出，但这很冒险！！！

于是，我愉快的打了个Splay。（Treap && FHQ Treap 靠脸吃饭）

但是。。。 价值第k大是从到小排的（或称降序kth） 而传统平衡树维护的是升序kth。所以要维护find_kth（cnt（总数）- kth + 1）

好，那我贴出Splay模板（如有不懂左转 P3369 【模板】普通平衡树）：

```cpp
struct Splay {
    int root, total;
    int child[Maxn][2], size[Maxn], cnt[Maxn];
    int father[Maxn], data[Maxn];
    
    Splay () {
        root = total = 0; Ms(data, 0);
        Ms(child, 0); Ms(size, 0);
        Ms(cnt, 0); Ms(father, 0);
    }
    
    inline bool get(int pos) {
        return pos == child[father[pos]][1];
    }
    
    inline void update(int pos) {
        size[pos] = cnt[pos] + size[child[pos][0]];
        size[pos] += size[child[pos][1]]; return;
    }
    
    inline void rotate(int pos) {
        if (father[pos] == 0) return;
        int f = father[pos], g = father[f];
        bool tmp = get(pos), tnp = get(f);
        child[f][tmp] = child[pos][tmp ^ 1];
        if (child[pos][tmp ^ 1])
            father[child[pos][tmp ^ 1]] = f;
        child[pos][tmp ^ 1] = f;
        father[f] = pos; father[pos] = g;
        if (g) child[g][tnp] = pos;
        update(f); update(pos); return;
    }
    
    inline void splay(int pos) {
        for (int f = father[pos]; (f = father[pos]); rotate(pos))
            if (get(pos) == get(f)) rotate(f);
            else rotate(pos); root = pos; return;
    }
    
    inline void insert(int val) {
        if (root == 0) {
            root = ++total;
            data[root] = val;
            cnt[1] = size[1] = 1;
            return;
        } int now = root;
        for (; ;) {
            if (val == data[now]) {
                ++cnt[now]; splay(now); return;
            } bool tmp = data[now] < val;
            if (child[now][tmp]) now = child[now][tmp];
            else {
                child[now][tmp] = ++total;
                father[total] = now;
                data[total] = val;
                cnt[total] = size[total] = 1;
                splay(total); return;
            }
        }
    }
    
    inline int rank(int val) {
        int now = root, ans = 1;
        for (; ;) {
            if (data[now] <= val) {
                ans += size[child[now][0]];
                if (data[now] == val) {
                    splay(now); return ans;
                } ans += cnt[now]; 
                now = child[now][1];
            } else now = child[now][0];
        }
    }
    
    inline int pre_idx(void) {
        int now = child[root][0];
        while (child[now][1])
            now = child[now][1];
        return now;
    }
    
    inline int suc_idx(void) {
        int now = child[root][1];
        while (child[now][0])
            now = child[now][0];
        return now;
    }
    
    inline void remove(int val) {
        int tmp = rank(val);
        if (cnt[root] >= 2) {
            cnt[root]--;
            size[root]--;
            return;
        }
        
        if (child[root][0] == 0 && child[root][1] == 0)
        {
            root = 0; return;
        }
        
        if (child[root][0] == 0) {
            root = child[root][1];
            father[root] = 0;
            return;
        }
        
        if (child[root][1] == 0) {
            root = child[root][0];
            father[root] = 0;
            return;
        }
        
        splay(pre_idx());
        child[root][1] = child[child[root][1]][1];
        father[child[root][1]] = root;
        update(root);
    }
    
    inline int findkth(int x) {
        int now = root;
        for (; ;) {
            if (x <= size[child[now][0]]) now = child[now][0];
            else {
                x -= size[child[now][0]];
                if (x <= cnt[now]) {
                    splay(now);
                    return data[now];
                }
                x -= cnt[now];
                now = child[now][1];
            }
        }
    }
    
    inline int pred(int val) {
        insert(val);
        int ans = data[pre_idx()];
        remove(val); return ans;
    }
    
    inline int succ(int val) {
        insert(val);
        int ans = data[suc_idx()];
        remove(val); return ans;
    }

} splaytree;
```

## CODE：
```cpp
//Program written by Liu Zhaozhou ~~~
#include <bits/stdc++.h>
#include <algorithm>
#include <queue>
#include <set>
#include <vector>
#include <deque>
#include <string>

#define lowbit(x) x & -x

#pragma GCC optimize(3)

using namespace std;

namespace Base {
inline char gc(void)
{
    static char buf[100000], *p1 = buf, *p2 = buf;
    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;
}

#define gc() getchar()

template <class T> inline void read(T &x)
{
    T flag = 1; x = 0; register char ch = gc();
    for (; !isdigit(ch); ch = gc()) if (ch == '-') flag = -1;
    for (; isdigit(ch); ch = gc()) x = (x << 1) + (x << 3) + (ch & 15);
    x *= flag; return;
}

template <class T> inline void write(T x) {
    if (x < 0) putchar('-'), x = -x;
    register T y = 1; int len = 1;
    for (; y <= x / 10; y *= 10) ++len;
    for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);
}

template <class T> inline void writeln(T x) {write(x); puts("");}
template <class T> inline void writeln(T x, char c) {write(x); putchar(c);}
template <class T> inline void writeln(char c, T x) {putchar(c); write(x);}

template <class T> inline void chkmax(T &x, const T y) {x > y ? x = x : x = y;}
template <class T> inline void chkmin(T &x, const T y) {x < y ? x = x : x = y;}

typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;

#define Ms(arr, opt) memset(arr, opt, sizeof(arr))
#define Mp(x, y) make_pair(x, y)

inline void file(string str) {
    freopen((str + ".in").c_str(), "r", stdin);
    freopen((str + ".out").c_str(), "w", stdout);
}
}

using namespace Base;

enum {
    Maxn = 100005
};

struct Splay {
    int root, total;
    int child[Maxn][2], size[Maxn], cnt[Maxn];
    int father[Maxn], data[Maxn];
    
    Splay () {
        root = total = 0; Ms(data, 0);
        Ms(child, 0); Ms(size, 0);
        Ms(cnt, 0); Ms(father, 0);
    }
    
    inline bool get(int pos) {
        return pos == child[father[pos]][1];
    }
    
    inline void update(int pos) {
        size[pos] = cnt[pos] + size[child[pos][0]];
        size[pos] += size[child[pos][1]]; return;
    }
    
    inline void rotate(int pos) {
        if (father[pos] == 0) return;
        int f = father[pos], g = father[f];
        bool tmp = get(pos), tnp = get(f);
        child[f][tmp] = child[pos][tmp ^ 1];
        if (child[pos][tmp ^ 1])
            father[child[pos][tmp ^ 1]] = f;
        child[pos][tmp ^ 1] = f;
        father[f] = pos; father[pos] = g;
        if (g) child[g][tnp] = pos;
        update(f); update(pos); return;
    }
    
    inline void splay(int pos) {
        for (int f = father[pos]; (f = father[pos]); rotate(pos))
            if (get(pos) == get(f)) rotate(f);
            else rotate(pos); root = pos; return;
    }
    
    inline void insert(int val) {
        if (root == 0) {
            root = ++total;
            data[root] = val;
            cnt[1] = size[1] = 1;
            return;
        } int now = root;
        for (; ;) {
            if (val == data[now]) {
                ++cnt[now]; splay(now); return;
            } bool tmp = data[now] < val;
            if (child[now][tmp]) now = child[now][tmp];
            else {
                child[now][tmp] = ++total;
                father[total] = now;
                data[total] = val;
                cnt[total] = size[total] = 1;
                splay(total); return;
            }
        }
    }
    
    inline int rank(int val) {
        int now = root, ans = 1;
        for (; ;) {
            if (data[now] <= val) {
                ans += size[child[now][0]];
                if (data[now] == val) {
                    splay(now); return ans;
                } ans += cnt[now]; 
                now = child[now][1];
            } else now = child[now][0];
        }
    }
    
    inline int pre_idx(void) {
        int now = child[root][0];
        while (child[now][1])
            now = child[now][1];
        return now;
    }
    
    inline int suc_idx(void) {
        int now = child[root][1];
        while (child[now][0])
            now = child[now][0];
        return now;
    }
    
    inline void remove(int val) {
        int tmp = rank(val);
        if (cnt[root] >= 2) {
            cnt[root]--;
            size[root]--;
            return;
        }
        
        if (child[root][0] == 0 && child[root][1] == 0)
        {
            root = 0; return;
        }
        
        if (child[root][0] == 0) {
            root = child[root][1];
            father[root] = 0;
            return;
        }
        
        if (child[root][1] == 0) {
            root = child[root][0];
            father[root] = 0;
            return;
        }
        
        splay(pre_idx());
        child[root][1] = child[child[root][1]][1];
        father[child[root][1]] = root;
        update(root);
    }
    
    inline int findkth(int x) {
        int now = root;
        for (; ;) {
            if (x <= size[child[now][0]]) now = child[now][0];
            else {
                x -= size[child[now][0]];
                if (x <= cnt[now]) {
                    splay(now);
                    return data[now];
                }
                x -= cnt[now];
                now = child[now][1];
            }
        }
    }
    
    inline int pred(int val) {
        insert(val);
        int ans = data[pre_idx()];
        remove(val); return ans;
    }
    
    inline int succ(int val) {
        insert(val);
        int ans = data[suc_idx()];
        remove(val); return ans;
    }

} splaytree;

int n, m, cnt = 0;
int opt, x;

signed main(void) {
    //file("");
	read(n); read(m);
	for (int i = 1; i <= n; i++)
		read(x), splaytree.insert(x), ++cnt;
	
	while (m--) {
		read(opt); read(x);
		if (opt == 2)
			 splaytree.insert(x), ++cnt;
		else writeln(splaytree.findkth(cnt - x + 1));
	}
    return 0;
}


```

谢谢资瓷！！！


---

## 作者：FendtSilence (赞：1)

本来以为一定会有平衡树的题解，结果没有，那我就来一个；

这个题考虑只有两种操作，我们可以使用一种叫做treap的平衡树，没有听说过的可以去自学一下，非常巧妙

这里我们只写一颗小treap，支持插入和rank就行了

```cpp
#include<iostream>
#include<stdio.h> 
#include<time.h>
#include<stdlib.h>
using namespace std;
struct Node
{
    Node *ch[2];
    int r,v,s;
    int cmp(int x) const 
    {
        return x>v?0:1;
    }
    void maintain()
    {
        s=ch[0]->s+ch[1]->s+1;
    }
}*null,*root;

void rot(Node* &o,int d) 
{
    Node* k=o->ch[d^1];
    o->ch[d^1]=k->ch[d];
    o->maintain();
    k->maintain();
    k->ch[d]=o;
    o=k;
}
void insert(Node* &o,int x)
{
    if (o==null) 
    {
        o=new Node();
        o->ch[0]=o->ch[1]=null;
        o->v=x;
        o->r=rand();
        o->maintain();
    }
    else 
    {
        int d=o->cmp(x);
        insert(o->ch[d],x); if (o->ch[d]->r > o->r ) rot(o,d^1);
        o->maintain();
    }
}
void init()
{
    null=new Node(); null->s=0; root=null;
}
void print(Node *o)
{
    if (o==null) return;
    print(o->ch[0]);
    printf("%d %d\n",o->v,o->s);
    print(o->ch[1]);
}
void find(Node* o,int x) 
{
    if (o==null) return;
    int d=o->ch[0]->s;
    if (x==d+1) 
    {
        printf("%d\n",o->v);
        return;
    }
    if (x<d+1) find(o->ch[0],x);
    else find(o->ch[1],x-d-1);
}
int n,m,ch,x;
inline void solve()
{
    init();
    cin>>n>>m;
    srand(time(NULL));
    for(int i=1;i<=n;i++) scanf("%d",&x),insert(root,x);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&ch,&x);
        if(ch==1) find(root,x);
        else insert(root,x);
    }
}
int main()
{
    solve(); 
    return 0;
}
```

---

## 作者：nekko (赞：1)

这不是数据结构xjb维护的裸题。。。

插入＋kth


好吧直接暴力移动就行了。。。

做法就是二分一下需要插入的位置，然后看一下这个位置左面有多少个数，右面有多少个数，然后看那个少往哪里暴力移动（这么做是logn+n/2的，由于数据范围是可以勉强艹过）。当然往左移动的时候会出现负数下标，保存的时候从数组中间开始保存数据就行（大概）。


```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#include <cmath>
#include <set>

using namespace std;

const int N = 100010;

int ch[N * 35][2], cnt[N * 35], tot = 1;

#define walk for(int i = 31, bit, rt = 1 ; (bit = ((x >> i) & 1)), i >= 0 ; i --)

void ins(int x) {
    walk {
        if(!ch[rt][bit]) ch[rt][bit] = ++ tot;
        cnt[rt = ch[rt][bit]] ++;
    }
}

int kth(int x) {
    int ret = 0;
    walk {
        if(x > cnt[ch[rt][0]]) x -= cnt[ch[rt][0]], rt = ch[rt][1], ret |= 1 << i;
        else rt = ch[rt][0];
    }
    return ret;
}

int n, q;

int main() {
    scanf("%d%d", &n, &q);
    for(int i = 1, x ; i <= n ; i ++) {
        scanf("%d", &x);
        ins(x);
    }
    for(int i = 1, x, y ; i <= q ; i ++) {
        scanf("%d%d", &x, &y);
        if(x == 1) {
            printf("%d\n", kth(n - y + 1));
        } else {
            n ++;
            ins(y);
        }
    }
}
```

---

## 作者：lichenxi (赞：1)

这题没有splay怎么能行呢
看到一大堆写暴力的，如果数据加强不久过不了了么
虽然splay也不算快
怎么也算个正经写法
操作还是很少的
插入，查rank两个操作就好了
我写的还是比较丑的，而且我这splay数是反着建的（谁让这题是从大到小的）
下面代码：
```cpp
#include<cstdio>
int n,m,rt,cnt,v[110001],size[110001],f[110001],ch[110001][2];
void update(int x)
{
	size[x]=size[ch[x][0]]+size[ch[x][1]]+1;
}
void move(int x,int &k)
{
	int tmp=ch[f[x]][1]==x,fa=f[x],faa=f[fa];
	if(fa==k)k=x;
	else ch[faa][ch[faa][1]==fa]=x;
	ch[fa][tmp]=ch[x][tmp^1];
	f[ch[x][tmp^1]]=fa;
	ch[x][tmp^1]=fa;
	f[fa]=x;
	f[x]=faa;
	update(fa),update(x);
}
void splay(int x,int &k)
{
	while(x!=k)
		{
			int y=f[x],z=f[y];
			if(y!=k)
				{
					if(ch[z][0]==y&&ch[y][0]==x)move(y,k);
					else move(x,k);
				}
			move(x,k);
		}
}
void ins(int x)
{
	if(!rt)
		{
			rt=++cnt;
			v[cnt]=x;
			size[cnt]=1;
			return ;
		}
	int now=rt;
	while(1)
		{
			if(v[now]>x)
				{
					if(!ch[now][1])
						{
							f[++cnt]=now;
							ch[now][1]=cnt;
							size[cnt]=1;
							v[cnt]=x;
							update(cnt),update(now);
							splay(cnt,rt);
							break;
						}
					else now=ch[now][1];
				}
			else 
				{
					if(!ch[now][0])
						{
							f[++cnt]=now;
							ch[now][0]=cnt;
							size[cnt]=1;
							v[cnt]=x;
							update(cnt),update(now);
							splay(cnt,rt);
							break;
						}
					else now=ch[now][0];
				}
		}
}
int find(int x,int k)
{
	if(x==size[ch[k][0]]+1)return v[k];
	if(x<=size[ch[k][0]])return find(x,ch[k][0]);
	return find(x-size[ch[k][0]]-1,ch[k][1]);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1,x;i<=n;i++)
		scanf("%d",&x),ins(x);
	for(int i=1,x,y;i<=m;i++)
		{
			scanf("%d%d",&x,&y);
			if(x==1)printf("%d\n",find(y,rt));
			else ins(y);
		}
}
```

---

## 作者：Strelitzia (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2343)

---

题目要求我们求什么，~~我们就求什么~~，求第$\texttt{n}$珍贵的宝石，

同时支持插♂入。

我们可以想到什么呢？当然是平衡树啦！！！

$\texttt{Ps:}$其实这道题还挺版的，评分好像评高了（毕竟数据水）。

----

说句闲话：这题面让我想到了《宝石商人理查德的谜鉴定》，然后又想到了$\texttt{BL}$，然后就上了下贴吧，然后有人拍了拍我肩......

----

这里提供的是$\texttt{splay}$，优化过的，还不算太慢。

```cpp
#include <cmath>
#include <queue>
#include <cstdio>
#include <cstring>
#include <climits>
#include <iostream>
#include <algorithm>
using namespace std;
template<typename T>void read(T &x) {
	T f = 1;x = 0;char s = getchar();
	while(s < '0' || s > '9') {if(s == '-')f = -1;s = getchar();}
	while(s >= '0' && s <= '9') {x = x * 10 + s - '0';s = getchar();}
	x *= f;
}
template<typename T>void print(T x) {
	if(x < 0) putchar('-'),x = -x;
	if(x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
const int maxn = 3e5 + 5;
struct Node {
	int fa,ch[2],val,cnt,sz;
} spl[maxn];
int root,cnt,n,m;

void update(int x) {
	spl[x].sz = spl[spl[x].ch[0]].sz + spl[spl[x].ch[1]].sz + spl[x].cnt;
}

bool ident(int x,int f) { return spl[f].ch[1] == x;}

void connect(int x,int f,int s) {
	spl[f].ch[s] = x;
	spl[x].fa = f;
}

void rotate(int x) {
	int f = spl[x].fa,ff = spl[f].fa,k = ident(x,f);
	connect(spl[x].ch[k ^ 1],f,k);
	connect(x,ff,ident(f,ff));
	connect(f,x,k ^ 1);
	update(f),update(x);
}

void splaying(int x,int top) {
	if (!top) root = x;
	while (spl[x].fa != top) {
		int f = spl[x].fa,ff = spl[f].fa;
		if (ff != top) ident(f,ff) ^ ident(x,f) ? rotate(x) : rotate(f);
		rotate(x);
	}
}

void newnode(int &now,int fa,int val) {
	spl[now = ++ cnt].val = val;
	spl[now].fa = fa;
	spl[now].sz = spl[now].cnt = 1;
}

void ins(int val,int &now = root,int fa = 0) {
	if (!now) newnode(now,fa,val),splaying(now,0);
	else if (val < spl[now].val) ins(val,spl[now].ch[0],now);
	else if (val > spl[now].val) ins(val,spl[now].ch[1],now);
	else spl[now].cnt ++,spl[now].sz ++,splaying(now,0);
}

int getrank(int val) {
	int x = root,rank = 1;
	while (x) {
		if (spl[x].val == val) {
			rank += spl[spl[x].ch[0]].sz;
			splaying(x,0);
			break;
		}
		if (val <= spl[x].val) x = spl[x].ch[0];
		else {
			rank += spl[spl[x].ch[0]].sz + spl[x].cnt;
			x = spl[x].ch[1];
		}
	}
	return rank;
}

int getnum(int rank) {
	int x = root;
	while (x) {
		int lsz = spl[spl[x].ch[0]].sz;
		if (lsz + 1 <= rank && rank <= lsz + spl[x].cnt) {
			splaying(x,0);
			break;
		}
		else if (lsz >= rank) x = spl[x].ch[0];
		else {
			rank -= lsz + spl[x].cnt;
			x = spl[x].ch[1];
		}
	}
	return spl[x].val;
}

int id(int x) {
	int now = root;
	while (now) {
		if (x == spl[now].val) return now;
		else now = spl[now].ch[x > spl[now].val];
	}
}

void delnode(int x) {
	splaying(x,0);
	if (spl[x].cnt > 1) spl[x].cnt --,spl[x].sz --,splaying(x,0);
	else if (spl[x].ch[1]) {
		int p = spl[x].ch[1];
		while (spl[p].ch[0]) p = spl[p].ch[0];
		splaying(p,x);
		connect(spl[x].ch[0],p,0);
		root = p;
		spl[p].fa = 0;
		update(root);
	}
	else root = spl[x].ch[0],spl[root].fa = 0;
}

void del(int val,int now = root) {
	if (val == spl[now].val) delnode(now);
	else if (val < spl[now].val) del(val,spl[now].ch[0]);
	else del(val,spl[now].ch[1]);
}

int kth(int x) {
	int now = root;
	while (1) {
		if (spl[now].ch[0] && x <= spl[spl[now].ch[0]].sz) now = spl[now].ch[0];
		else {
			int tmp = spl[spl[now].ch[0]].sz + spl[now].cnt;
			if (x <= tmp) return spl[now].val;
			x -= tmp;
			now = spl[now].ch[1];
		}
	}
}

void Find(int x) {
	int u = root;
	if (!u) return;
	while (spl[u].ch[x > spl[u].val] && spl[x].val != x) u = spl[u].ch[x > spl[u].val];
	splaying(u,0);
}

int Next(int x,int f) {
	Find(x);
	int u = root;
	if ((spl[u].val > x && f) || (spl[u].val < x && !f)) return u;
	u = spl[u].ch[f];
	while (spl[u].ch[f ^ 1]) u = spl[u].ch[f ^ 1];
}

int main() {
	read(n);read(m);
	int x,y;
	for (int i = 1 ; i <= n ; ++ i) {
		read(x);ins(x);
	}
	while (m --) {
		read(x);read(y);
		if (x == 1) printf("%d\n",kth(spl[root].sz - y + 1));
		else ins(y);
	}
	return 0;
}
```

---

## 作者：Wall_breaker (赞：0)

还没有人写Splay诶，那我就来恰一发。

正如写了题解的一群巨佬所言，这题是一道平衡树。treap、fhq-treap等等都有大佬写过了，那我就来一发Splay吧。

Splay学习链接恰一发(https://baijiahao.baidu.com/s?id=1613228134219334653&wfr=spider&for=pc)

这里，唯一有一点不同的是，查询的变成了区间第K大，而不是第K小，那么我们就把查询第K大改为查询第（n-k+1）小的数，就能达到目的了。不要忘记，n在插入数的时候要++哦！

上代码：
```c++
#include<bits/stdc++.h>
using namespace std;
template <typename T>
inline void read(T &x) {
	x = 0;
	T f = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
	for (; isdigit(c); c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);
	x *= f;
}
template <typename T>
inline void w(T x) {
	if (x > 9) w(x / 10);
	putchar(x % 10 + 48);
}
template <typename T>
inline void write(T x, char c) {
	if (x < 0){
		putchar('-');
		x = -x;
	}
	w(x);
	putchar(c);
}
struct info{
	int child[2], cnt, siz, fa;
	long long val;
}t[5000005];
int rt, tot;
inline void upd(int x) {
	t[x].siz = t[t[x].child[0]].siz + t[t[x].child[1]].siz + t[x].cnt;
}
inline bool  ask(int x) {
	return x == t[t[x].fa].child[1];
}
inline void rot(int x) {
	int f = t[x].fa, g = t[f].fa;
	int tmp = ask(x), tnp = ask(f);
	if (g) t[g].child[tnp] = x;
	t[x].fa = g;
	t[f].child[tmp] = t[x].child[tmp ^ 1];
	t[t[x].child[tmp ^ 1]].fa = f;
	t[x].child[tmp ^ 1] = f;
	t[f].fa = x;
	upd(f);
	upd(x);
}
inline void splay(int x) {
	int y, z;
	while(t[x].fa) {
		y = t[x].fa; z = t[y].fa;
		if (z) {
			if (ask(x) == ask(y)) rot(y);
			else rot(x);
		}
		rot(x);
	}
	rt = x;
	upd(rt);
	return;
}
inline void ins (long long x) {
	int cur = rt, f = 0;
	while(cur) {
		if (t[cur].val == x) break;
		f = cur;
		cur = t[cur].child[x > t[cur].val];
	}
	if (cur) t[cur].cnt ++, t[cur].siz ++;
	else {
		cur = ++ tot;
		if (f) t[f].child[x > t[f].val] = cur;
		t[cur].fa = f;
		t[cur].child[1] = t[cur].child[0] = 0;
		t[cur].cnt = t[cur].siz = 1;
		t[cur].val = x;
	}
	splay(cur);
	return;
}
inline long long kth(int k) {
	int cur = rt;
	while(cur) {
		if (k > t[cur].cnt + t[t[cur].child[0]].siz) {
			k -= t[cur].cnt + t[t[cur].child[0]].siz;
			cur = t[cur].child[1];
		}
		else if (k <= t[t[cur].child[0]].siz) cur = t[cur].child[0];
		else{
			splay(cur);
			return t[rt].val;
		}
	}
}
int main(){
	int n, m;
	read(n); read(m);
	for (int i = 1; i <= n; i ++) {
		long long x;
		read(x);
		ins(x);
	}
	for (int i = 1; i <= m; i ++) {
		int opt;
		long long sum;
		read(opt); read(sum);
		if (opt & 1) {
			write(kth(n - sum + 1), '\n');
		}
		else ins(sum), n ++;
	} 
	return 0;
}
```


---

## 作者：rediserver (赞：0)

# P2343 宝石管理系统
[原题地址](https://www.luogu.org/problem/P2343)

[Github题集](https://github.com/jerrykcode/luogu)

## 思路

### 大部分平衡树的题解是Splay，好像还没有用SBT的

使用依据结点数量平衡的SBT树。
* 对于插入操作，将新结点插入SBT即可
* 对于查询操作，排名为n即有n - 1个元素大于它，用函数``` int rank(Tree tree, int n) ```查询tree中有n个结点比它大的结点 ，
	那么```rank(n - 1)```就是查询的答案。
	rank函数的实现：由于SBT树的每个结点记录了以该结点为根的树的结点数量(size)，从根结点tree开始递归：
	设`tree的右子树的size`为`rightSize`
	* 若n == rightSize，则正好有n个结点比tree大，那么tree就是查询的结点。
	* 若n < rightSize，则递归```rank(tree->right, n)```
	* 若n > rightSize，则递归```rank(tree->left, n - rightSize - 1)```

## 代码

### C

```c
#include "stdio.h"
#include "stdlib.h"

typedef struct TNode {
	int key;
	size_t size;
	struct TNode * left;
	struct TNode * right;
} *Tree;

#define SIZE(tree) (tree ? tree->size : 0)

Tree newTNode(int key) {
	Tree tree = (Tree)malloc(sizeof(struct TNode));
	tree->key = key;
	tree->size = 1;
	tree->left = tree->right = NULL;
	return tree;
}

Tree leftRotate(Tree tree);
Tree rightRotate(Tree tree);

Tree maintain(Tree tree);
Tree maintainLeft(Tree tree);
Tree maintainRight(Tree tree);

Tree insert(Tree tree, int key);
int rank(Tree tree, int n);

void deleteTree(Tree tree);

Tree leftRotate(Tree tree) {
	Tree k = tree->right;
	tree->right = k->left;
	k->left = tree;
	tree->size = SIZE(tree->left) + SIZE(tree->right) + 1;
	k->size = tree->size + SIZE(k->right) + 1;
	return k;
}

Tree rightRotate(Tree tree) {
	Tree k = tree->left;
	tree->left = k -> right;
	k->right = tree;
	tree->size = SIZE(tree->left) + SIZE(tree->right) + 1;
	k->size = SIZE(k->left) + tree->size + 1;
	return k;
}

Tree maintain(Tree tree) {
	tree = maintainLeft(tree);
	tree = maintainRight(tree);
	return tree;
}

Tree maintainLeft(Tree tree) {
	if (tree == NULL) return tree;
	if (tree->left == NULL) return tree;
	if (tree->left->left && tree->left->left->size > SIZE(tree->right)) {
		tree = rightRotate(tree);
		tree->right = maintain(tree->right);
		tree = maintain(tree);
	}
	if (tree->left->right && tree->left->right->size > SIZE(tree->right)) {
		tree->left = leftRotate(tree->left);
		tree = rightRotate(tree);
		tree->left = maintain(tree->left);
		tree->right = maintain(tree->right);
		tree = maintain(tree);
	}
	return tree;
}

Tree maintainRight(Tree tree) {
	if (tree == NULL) return tree;
	if (tree->right == NULL) return tree;
	if (tree->right->right && tree->right->right->size > SIZE(tree->left)) {
		tree = leftRotate(tree);
		tree->left = maintain(tree->left);
		tree = maintain(tree);
	}
	if (tree->right->left && tree->right->left->size > SIZE(tree->left)) {
		tree->right = rightRotate(tree->right);
		tree = leftRotate(tree);
		tree->left = maintain(tree->left);
		tree->right = maintain(tree->right);
		tree = maintain(tree);
	}
	return tree;
}

Tree insert(Tree tree, int key) {
	if (tree == NULL) {
		return newTNode(key);
	}
	tree->size++;
	if (key < tree->key) {
		tree->left = insert(tree->left, key);
		tree = maintainLeft(tree);
	}
	else {
		tree->right = insert(tree->right, key);
		tree = maintainRight(tree);
	}	
	return tree;
}

int rank(Tree tree, int n) {
	int right_size = SIZE(tree->right);
	if (n == right_size) {
		return tree->key;
	}
	else if (n < right_size) {
		return rank(tree->right, n);
	}
	else {
		return rank(tree->left, n - right_size - 1);
	}
}

void deleteTree(Tree tree) {
	if (tree == NULL) return;
	if (tree->left) deleteTree(tree->left);
	if (tree->right) deleteTree(tree->right);
	free(tree);
}

int main() {
	Tree tree = NULL;
	int m, q;
	scanf("%d %d", &m, &q);
	int c, n;
	for (int i = 0; i < m; i++) {
		scanf("%d", &n);
		tree = insert(tree, n);
	}	
	for (int i = 0; i < q; i++) {
		scanf("%d %d", &c, &n);
		if (c == 1) {
			printf("%d\n", rank(tree, n - 1));
		}
		else {
			tree = insert(tree, n);			
		}
	}
	deleteTree(tree);
	return 0;
}
```

---

## 作者：Infinity_shl (赞：0)

本人今天初学Splay，为了巩固练习Splay的基本操作，我特意用Splay实现这个程序

**Description**

设计一种数据结构，支持插入元素，查询排名为x的值。

**Solution**

这是Splay的基本操作，我们明确后文代码中函数的作用

1. update函数用于维护节点的sum信息
2. connect用于连接父子关系
3. rotate函数用于实现Splay的旋转
4. splay函数用于实现平衡树的伸展操作，使得某一节点伸展到另一节点
5. insert函数用于插入元素
6. query函数用于返回询问的答案

我们讲一下两种操作如何实现

1. insert，我们可以利用二叉查找树的性质，找到待插入元素应该在哪个位置，如果该位置没有节点，那么我们新建一个节点，否则我们就将该节点重复次数+1即可。为了维护Splay，插入完成后我们调用splay()将当前节点伸展至树根。

2. query，注意，本题所指的“排名为i”指的是从大到小，所以我们转化成从小到大即可。我们利用二叉查找树的性质找到相应节点返回即可。

**Code**

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
inline int read() {
	int ret = 0, op = 1;
	char c = getchar();
	while (!isdigit(c)) {
		if (c == '-') op = -1; 
		c = getchar();
	}
	while (isdigit(c)) {
		ret = ret * 10 + c - '0';
		c = getchar();
	}
	return ret * op;
}
struct Splay {
	int sum, fa, val, ch[2], cnt;
} a[100010];
int n, m, root, tot;
void update(int now) {
	a[now].sum = a[a[now].ch[0]].sum + a[a[now].ch[1]].sum + a[now].cnt;
}
void connect(int x, int fa, int op) {
	a[x].fa = fa;
	a[fa].ch[op] = x;
}
void rotate(int x) {
	int y = a[x].fa;
	int z = a[y].fa;
	int xson = a[y].ch[1] == x ? 1 : 0;
	int yson = a[z].ch[1] == y ? 1 : 0;
	int B = a[x].ch[xson ^ 1];
	connect(B, y, xson); connect(y, x, xson ^ 1); connect(x, z, yson);
	update(y); update(x);
}
void splay(int from, int to) {
	while (a[from].fa != to) {
		int y = a[from].fa;
		int z = a[y].fa;
		if (z != to)
			(a[y].ch[0] == from) ^ (a[z].ch[0] == y) ? rotate(from) : rotate(y);
		rotate(from);
	}
	if (to == 0) root = from;
}
void insert(int val) {
	int now = root, fa = 0;
	while (now && a[now].val != val) fa = now, now = a[now].ch[val > a[now].val];
	if (now) a[now].cnt++;
	else {
		now = ++tot;
		a[now].val = val;
		a[now].sum = a[now].cnt = 1;
		a[now].ch[0] = a[now].ch[1] = 0;
		a[now].fa = fa;
		if (fa) a[fa].ch[val > a[fa].val] = now;
	}
	splay(now, 0);
}
int query(int x) {
	int now = root;
	if (a[now].sum < x) return 0;
	while (1) {
		if (x <= a[a[now].ch[0]].sum) now = a[now].ch[0];
		else if(x > a[a[now].ch[0]].sum + a[now].cnt) {
			x -= a[a[now].ch[0]].sum + a[now].cnt;
			now = a[now].ch[1];
		}
		else return a[now].val;
	}
}
int main() {
	int n = read(), m = read();
	insert(-2147483647);
	insert(2147483647);
	for (register int i = 1; i <= n; ++i) insert(read());
	while (m--) {
		int op = read(), x = read();
		if (op == 1) printf("%d\n", query(n - x + 2));
		else insert(x), ++n;
	} 
	return 0;
}
```


---

## 作者：Ireliaღ (赞：0)

**本题第一篇替罪羊树题解**

题解里以Splay和Treap为主。但是如果只做权值树，感觉替罪羊树码量最小，跑的还最快。~~毕竟暴力出奇迹~~

## 题目大意

给一组数据和两种操作，分别为插入一个数和查询**第$k$大**

## 解法

- 使用替罪羊树维护，注意**数据是从大到小排的**

- 对于给出的数据，**降序**排序后二分建树~~如果懒的话一个一个insert也问题不大，多个$log$无伤大雅~~

- 对于两种操作，平衡树板子

## 代码

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include <iostream>
#include <vector>
#include <cstdlib>

using namespace std;

const int MAXN = 1e5 + 5;
const double A = 0.8;

int a[MAXN];

struct Node{
    int val, siz;
    Node *ch[2];
    
    Node(int val): val(val) {
        siz = 1;
        ch[0] = ch[1] = NULL;
    }

    void Update() {
        siz = (ch[0] ? ch[0]->siz : 0) + (ch[1] ? ch[1]->siz : 0) + 1;
    }

    bool Bad() {
        int ls = ch[0] ? ch[0]->siz : 0, rs = ch[1] ? ch[1]->siz : 0;
        return (double)ls > (double)siz * A || (double)rs > (double)siz * A;
    }
};

Node *rt = NULL;

vector<Node*> vec;

void Build(Node *&now, int l, int r) {
    if (l > r) return;
    int mid = l + r >> 1;
    now = new Node(a[mid]);
    Build(now->ch[0], l, mid - 1);
    Build(now->ch[1], mid + 1, r);
    now->Update();
}

void Dfs(Node *now) {
    if (!now) return;
    Dfs(now->ch[0]);
    Node *tmp = now->ch[1];
    now->ch[0] = now->ch[1] = NULL;
    now->siz = 1;
    vec.push_back(now);
    Dfs(tmp);
}

void Rebuild(Node *&now, int l, int r) {
    if (l > r) return;
    int mid = l + r >> 1;
    now = vec[mid];
    Rebuild(now->ch[0], l, mid - 1);
    Rebuild(now->ch[1], mid + 1, r);
    now->Update();
}

void Insert(Node *&now, int val) {
    if (now == NULL) {
        now = new Node(val);
        return;
    } else {
        Insert(val > now->val ? now->ch[0] : now->ch[1], val);
        now->Update();
        if (now->Bad()) {
            vec.clear();
            Dfs(now);
            int tot = vec.size();
            Rebuild(now, 0, tot - 1);
        }
    }
}
/*
int Kth(Node *now, int k) {
    if (!now) return 0;
    int ls = now->ch[0] ? now->ch[0]->siz : 0;
    if (k <= ls) return Kth(now->ch[0], k);
    else if (k == ls + 1) return now->val;
    else return Kth(now->ch[1], k - ls - 1);
}
*/
int Kth(int rank) {
    if (!rt) return 1;
    Node *now = rt, *prev = NULL;
    while (now) {
        prev = now;
        int ls = now->ch[0] ? now->ch[0]->siz : 0;
        if (rank <= ls) now = now->ch[0];
        else if (rank <= ls + 1) break;
        else rank -= ls + 1, now = now->ch[1];
    }
    return prev->val;
}

int cmp(const void *a, const void *b) {
    return *(int*)b - *(int*)a;
}

int main() {
    ios :: sync_with_stdio(false); cin.tie(NULL);
    int m, q;
    cin >> m >> q;
    for (int i = 1; i <= m; i++) cin >> a[i];
    qsort(a + 1, m, sizeof(int), cmp);
    Build(rt, 1, m);
    for (int i = 1; i <= q; i++) {
        int op, x;
        cin >> op >> x;
        if (op == 1) 
            cout << Kth(x) << endl;
        else
            Insert(rt, x);
    }
    return 0;
}

```

---

## 作者：AFOier (赞：0)

提供一个比较简洁的$splay$题解

其实只需要两个基本操作：$insert$和$find$_$rank$(查排名)

操作2直接$insert$即可，而操作1由于找的是珍贵值第n**大**，所以可以统计宝石总个数(代码中的$final$)，然后通过$find$_$rank$输出第$final-n+1$小的珍贵值

~~我知道treap跑的比splay快，不过反正都能过嘛~~

$Code$:

```
#include <cstdio>
#include <iostream>
using namespace std;
int n,m,opt,x,final;
int root,tot;
const int INF=0x7fffffff;
struct tree{
    int val,siz,cnt;
    int son[2],fa;
}a[200001];
void update(int p){
    if(!p)return;
    a[p].siz=a[a[p].son[0]].siz+a[a[p].son[1]].siz+a[p].cnt;
}
int fson(int p){
    return p==a[a[p].fa].son[1];
}
void contact(int son,int father,int lr){
    a[father].son[lr]=son;
    a[son].fa=father;
}
void rotate(int p){
    int father=a[p].fa,gfather=a[father].fa,lr=fson(p);
    contact(a[p].son[!lr],father,lr);
    contact(p,gfather,fson(father));
    contact(father,p,!lr);
    update(p);update(father);update(gfather);
}
void splay(int p,int to){
    if(p==to||!p)return;
    while(a[p].fa!=to){
        int father=a[p].fa,gfather=a[father].fa;
        if(gfather==to)rotate(p);
        else{
            if(fson(p)==fson(father))rotate(father);
            else rotate(p);
        }
        update(p);update(father);update(gfather);
    }
    if(!to)root=p;
}
void New(int val,int father){
    a[++tot].val=val;
    a[tot].siz=a[tot].cnt=1;
    contact(tot,father,val>a[father].val);
    if(!root)root=tot;
    splay(tot,0);
}
void find(int val){
    if(!root)return;
    int now=root;
    while(a[now].son[val>a[now].val]&&a[now].val!=val)
    now=a[now].son[val>a[now].val];
    splay(now,0);
}
int find_rank(int p,int val){
    if(!p)return 0;
    if(a[a[p].son[0]].siz>=val)return find_rank(a[p].son[0],val);
    else if(a[a[p].son[0]].siz+a[p].cnt>=val)return a[p].val;
    else find_rank(a[p].son[1],val-a[a[p].son[0]].siz-a[p].cnt);
}
void ins(int p,int val,int las){
    if(!p){New(val,las);return;}
    if(a[p].val==val){a[p].cnt++;update(p);return;}
    ins(a[p].son[val>a[p].val],val,p);
    update(p);
}
int main(){
    scanf("%d%d",&n,&m);final=n;
    for(int i=1;i<=n;i++){
    	scanf("%d",&x);
    	ins(root,x,0);
    }
    for(int i=1;i<=m;i++){
        scanf("%d%d",&opt,&x);
        switch(opt){
            case 1:printf("%d\n",find_rank(root,final-x+1));break;
            case 2:ins(root,x,0);final++;break;
        }
    }
}
```

---

## 作者：King丨帝御威 (赞：0)

一个平衡树的比较裸的题目，就是查询区间第k大，就相当于查询区间第n-k+1小。

可以脑补一下，不会平衡树的同学可以先去看一下这道题：

[普通平衡树](https://www.luogu.org/problemnew/show/P3369)

最后，代码奉上：
``` cpp
#include<cstdio>
#include<cctype>
#define maxn 100007
using namespace std;
int rt,tot,n,fa[maxn],cnt[maxn],siz[maxn],val[maxn],ch[maxn][2],q;
const int inf=0x3f3f3f3f;
inline int qread() {
  char c=getchar();int num=0,f=1;
  for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
  for(;isdigit(c);c=getchar()) num=num*10+c-'0';
  return num*f;
}
inline void pushup(int k) {
  siz[k]=siz[ch[k][0]]+siz[ch[k][1]]+cnt[k];
}
inline void rotate(int x) {
  int y=fa[x],z=fa[y];
  int k=ch[y][1]==x;
  ch[z][ch[z][1]==y]=x;
  fa[x]=z;
  ch[y][k]=ch[x][k^1];
  fa[ch[x][k^1]]=y;
  ch[x][k^1]=y,fa[y]=x;
  pushup(y),pushup(x);
}
void splay(int x, int k) {
  while(fa[x]!=k) {
  	int y=fa[x],z=fa[y];
  	if(z!=k) (ch[z][0]==y)^(ch[y][0]==x)?rotate(x):rotate(y);
  	rotate(x);
  }
  if(!k) rt=x;
}
void insert(int x) {
  int u=rt,f=0;
  while(u&&val[u]!=x) {
  	f=u;
  	u=ch[u][x>val[u]];
  }
  if(u) ++cnt[u];
  else {
  	u=++tot;
  	if(f) ch[f][x>val[f]]=u;
  	fa[u]=f,val[u]=x;
  	cnt[u]=siz[u]=1;
  }
  splay(u,0);
}
inline int kth(int x) {
  int u=rt;
  if(siz[u]<x) return 0;
  while(233) {
  	int y=ch[u][0];
  	if(x>siz[y]+cnt[u]) {
  	  x-=siz[y]+cnt[u];
	  u=ch[u][1];	
	}
	else if(siz[y]>=x) u=y;
	else return val[u];
  }
}
int main() {
  n=qread(),q=qread();
  for(int i=1,x;i<=n;++i) x=qread(),insert(x);
  while(q--) {
  	int c=qread();
  	if(c==2) {
  	  int x=qread();
	  insert(x);	
	  ++n;
	}
	else {
	  int x=qread();
	  printf("%d\n",kth(n-x+1));
	}
  }
  return 0;
}
```

---

## 作者：什么叫中二呀 (赞：0)

## 本题我做了四遍……（本人蒟蒻）

这题……我用了暴力的数组（大佬勿喷）

看有一个题解用了指针，我就发个简单的

~~巨简单~~，会数组和快排就行

------------
先排序，我用的快排，省时间嘛。

之后，scanf("%d%d",&c,&n)

如果c==1，输出a[n-1]

如果c==2,把n放到数组后面，再排序

### 贴代码：

------------
```
#include<cstdio>
#include<iostream>
int m,q,c,d[130001],n;
void qsort(int l,int r)//快排
{
    int i=l,j=r,mid=d[(l+r)/2];
    while(i<=j)
    { while(d[i]>mid)i++;
      while(d[j]<mid)j--;
      if(i<=j){std::swap(d[i],d[j]);i++;j--;} 
    }//            ↑懒得打using……的后果
    if(i<r)qsort(i,r);
    if(l<j)qsort(l,j);
}
void work()
{
    scanf("%d%d",&m,&q);
    for(int i=0;i<m;i++)scanf("%d",&d[i]);
    qsort(0,m-1);
    for(int i=0;i<q;i++)
    { scanf("%d%d",&c,&n);
      if(c==1)printf("%d\n",d[n-1]);
      else{m++;d[m-1]=n;qsort();}
    }
}
int main()
{
    work();
    return 0;
}
```

------------

谁发了这个题解谁作死。因为

# 只有60分，剩下的TLE掉了……

因为快排在部分有序的情况下，还不如改进的冒泡……

思路：最后一个小于前面就交换，大于前面就跳出

再贴代码

------------
```
#include<cstdio>
#include<iostream>
int m,q,c,d[130001],n;
void sort()
{
    for(int i=m-1;i>0;i--)
      if(d[i]>d[i-1])
        std::swap(d[i],d[i-1]);//同上
      else return;
} 
void qsort(int l,int r)
{
    int i=l,j=r,mid=d[(l+r)/2];
    while(i<=j)
    { while(d[i]>mid)i++;
      while(d[j]<mid)j--;
      if(i<=j){std::swap(d[i],d[j]);i++;j--;} 
    }//            同上
    if(i<r)qsort(i,r);
    if(l<j)qsort(l,j);
}
void work()
{
    scanf("%d%d",&m,&q);
    for(int i=0;i<m;i++)scanf("%d",&d[i]);
    qsort(0,m-1);
    for(int i=0;i<q;i++)
    { scanf("%d%d",&c,&n);
      if(c==1)printf("%d\n",d[n-1]);
      else{m++;d[m-1]=n;sort();}
    }
}
int main()
{
    work();
    return 0;
}
```


------------

这题解……又是过不了的，90分……

所以，
### 要开O2优化！
## 要开O2优化！
# 要开O2优化！
这样才能100分啊！

本题解专门防抄袭……求管理员给过！

---

## 作者：bobble (赞：0)

Tags: 模拟,思维,二分


戳着链接食用=>    <www.cnblogs.com/tonylim/p/6849927.html>



## **Pre**


好把，这题其实是zyf小盆友叫我去做的，一开始想用数组next模拟链表，结果打了个错误百出的版本交了上去，

然后就WA+TLE了然后猛然意识到这题直接模拟链表的时复超高


所以开始想用树状数组来记录，然后就怂了，开始寻找其他方法……


暴力qsort一遍，然后每次加入后再qsort = 60 points


for一遍尝试找第一比他小的，可以直接插入到它前面 ，然后平移数组= 80 points


 
## **Solution**



**// 注意：感觉这似乎不是正解qwq**

于是进入正题


首先既然我们可以直接插入加平移数组，既然可以往右平移，为啥不能往左呢？


**所以我们可以在平移时加个优化判断向左平移方便还是向右平移方便**


**------------ubuntu上的gdb坏了，于是只能用write来debug .... 【欲哭无泪】**


好,处理完后啦，还是80 points ？



于是乎，机智的你想到了二分

没错再加上二分找第一比他小的 就AC啦

 
原来这么水。。。



Codes:





   






```cpp
program wonder;
var
  n,q,i,c,x,left,right,aa,bb:longint;
  a:array[-110000..110000] of longint;
procedure qsort(l,r:longint);  //从大到小qsort
var i,j,m,x:longint;
begin
    i:=l;  j:=r;  m:=a[(l+r) div 2];
    repeat
    while a[i]>m do inc(i);
    while a[j]<m do dec(j);
    if i<=j then begin
                  x:=a[i];a[i]:=a[j];a[j]:=x;
                  inc(i);dec(j);
                end;
    until i>j;
    if i<r then qsort(i,r);
    if j>l then qsort(l,j);
end;
procedure add;
var
   ii,jj,m:longint;
begin
  ii:=left;  jj:=right;
  while ii<jj do
    begin
      m:=ii+(jj-ii) div 2;
      if a[m]>x then ii:=m+1
        else jj:=m-1;
    end;                    //二分查找第一个比他小的
  for ii:=ii to right do    //insert
   if x>a[ii] then
    begin
      bb:=n-ii+1;          //bb为右移数组的花费
      aa:=n-bb;            //aa为左移数组的花费
      inc(n);              //n为元素个数                          
      if bb<aa then begin
                      inc(right); 
                      for jj:= right downto ii+1 do a[jj]:=a[jj-1];
                      a[ii]:=x;
                    end
      else  begin
               dec(left);
               for jj:= left to ii-2 do a[jj]:=a[jj+1];
               a[ii-1]:=x;
             end;
       break;
    end;
end;
begin
  readln(n,q);
  for i:= 1 to n do
    read(a[i]);
  qsort(1,n);
  left:=1;  right:=n;
  for i:= 1 to q do
  begin
   readln(c,x);
    if c=1 then writeln(a[left+x-1])  
      else add;              
  end;
end.

```

---


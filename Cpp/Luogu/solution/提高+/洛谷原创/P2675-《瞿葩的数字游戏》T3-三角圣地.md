# 《瞿葩的数字游戏》T3-三角圣地

## 题目背景

国王1带大家到了数字王国的中心：三角圣地。

## 题目描述

数字王国的中心是由一个倒三角构成。

倒三角一共 $N$ 层，从上往下第 $i$ 层有 $N-i+1$ 个数字。倒三角的第 $1$ 层必须是 $1 \sim N$ 的全排列之一，即必须使用 $1 \sim N$ 之间的所有数字且不能重复。从第 $2$ 层开始以后每一层的数字都是由其左上方和右上方两个数字相加得到的。例如，下面是一个合法的倒三角形：

```plain
1   2   3   4
  3   5   7
    8   12
      20
```

这个倒三角形的 $N$ 为 $4$，其最后一层的数字为 $20$。

数字王国称最后一层的数字为“基”，请你编程求出“基”的最大值对 $10007$ 取模的结果。

## 说明/提示

### 样例解释

一种可行的方案为：

```plain
1   3   4   2
  4   7   6
    11  13
      24
```

可以证明没有比这更好的方法。

### 数据范围

对于 $20\%$ 的数据，$N \le 100$。

对于 $50\%$ 的数据，$N \le 3000$。

对于 $100\%$ 的数据，$0 \le N \le {10}^6$。

## 样例 #1

### 输入

```
4```

### 输出

```
24```

## 样例 #2

### 输入

```
1125```

### 输出

```
700```

# 题解

## 作者：yjjr (赞：22)

**首先声明：本题目前无法保证题解，标程，数据的正确性！如果有错，希望大家指出！原出题人标程的确有锅（因为现在找不到出题人，只好由我们管理员负责）**

思路：观察发现越大的数排在中间位置对答案越有利，所以就可以贪心了

而不同位置对答案有不同的贡献次数

拿样例举例

1 3 4 2

那么第一个位置1对答案贡献1次

第二个位置3对答案贡献3次

第三个位置4对答案贡献3次

第四个位置2对答案贡献1次


不难发现这个贡献次数为杨辉三角（就是组合数）


我们可以O(n^2)求出组合数对10007的取模


$ ans=\sum_{i=1}^n C(n,i)*i$


当然答案要取模，在计算的过程中防止负数的出现，要加入判断



O(n^2)求组合数就可以获得50分了

但是觉得这题太水了点，于是加强了下数据范围。



N<=1000000

快速求出组合数，模数也那么小，当然是Lucas定理了！


套个lucas定理的板子就可以了，不知道Lucas的出门右转百度


此题感谢@BFSBFSBFSBFS @siyuan 的交流和支持


      
      
```cpp
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cmath>
    #include<cstring>
    #include<algorithm>
    #define rep(i,a,b) for(int i=a;i<=b;i++)
    #define dep(i,a,b) for(int i=a;i>=b;i--)
    #define ll long long
    #define mem(x,num) memset(x,num,sizeof x)
    #define reg(x) for(int i=last[x];i;i=e[i].next)
    using namespace std;
    inline ll read()//快速读入
    {
        ll f=1,x=0;char ch=getchar();
        while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
        return x*f;
    }
    const int p=10007;  
    ll fac[p],inv[p],n;//注意要用long long否则会爆掉
    ll ans;  
    void work()  
    {  
        fac[0]=fac[1]=inv[0]=inv[1]=1;  
        rep(i,2,p-1)fac[i]=fac[i-1]*i%p;  //阶乘预处理
        rep(i,2,p-1)inv[i]=(p-p/i)*inv[p%i]%p;  
        rep(i,1,p-1)inv[i]=inv[i-1]*inv[i]%p;  //逆元预处理
    }  
    ll C(ll n,ll m)  
    {  
        if(n<m)return 0;  //舍去组合数无意义的情况
        if(n<p&&m<p)return fac[n]*inv[m]%p*inv[n-m]%p;  
        return C(n/p,m/p)*C(n%p,m%p)%p;  
    }  
    int main()  
    {  
        //freopen("data20.in","r",stdin);
        //freopen("data20.ans","w",stdout);
        work();  //预处理出乘法逆元和阶乘
        n=read();
        rep(i,1,n){
            if(i%2==0){ans=(ans+((ll)(i*C(n-1,n-i/2)))%p)%p;if(ans<0)ans+=p;}
            else{ans=(ans+((ll)(C(n-1,(i+1)/2-1)*i))%p)%p;if(ans<0)ans+=p;}//这个数本身*这个数贡献的次数，将其累加到答案中去
        }
        cout<<ans<<endl;
        return 0;  
}
```

---

## 作者：Windows_XP (赞：8)

那个啥，这不是比下面管理员大大快了那么20ms荣登此题rank1,所以来~~装13~~
讲一讲 ~~谁都会就是懒得写的~~ 优化方法，顺便说一下我惨挖的经历....

相信大家都知道，其实组合数是可以递推来求的。通过杨辉三角可以完成O(n2)的递推。通过仔细 ~~观察杨辉三角~~ 推导公式还可以得到O(n)的递推方法。
对于C(n,m) 除了

C(n,m)=C(n-1,m-1)+C(n-1,m)

以外，还可以等于

C(n,m)=((n+1) - m)/m*C(n,m-1)。

比如C(4,2)=6 C(4,1)=4 然后((n+1) - m)/m=(5-2)/2=3/2 4*3/2=6

这个通过公式来看真的是显然可证。C(n,m-1)中分母的(n+1-m)!的(n+1-m)项被约掉，(m-1)!与m相乘变为m!。

~~捣鼓了半天不知道咋加图片~~

所以如果建立一个变量d来保存组合数的值就可以O(1)的递推。看起来这样能得到一个O(n)的做法，但是有一个致命的问题。如果出现n,m过大的情况，d%10007==0后，就。一。蹶。不。振。了。而lucas不会出现这种情况。当分母中出现了10007的倍数时，依然可以正确的约掉10007并得解。

怎么办呢？

。

。

我想了半天。好像没啥办法。

我又不愿意白写一遍递推，我就试了试数据，发现每当递推到10007的倍数时lucas都会从之前的0变出数来(10007项开始被约掉了)。所以干脆每当i%10007==0时，我再用lucas算出d的值。

......

复杂度O(n-n/10007+n/10007*log(n))。多么优良的复杂度。~~虽然说看起来好像真的没啥用。不过就是标程快啊~~

应该是我写的丑。好像可以再快一点的说。

```cpp
#include <bits/stdc++.h>
#define rap(i,s,n) for(int i=s;i<=n;i++)
#define drap(i,s,n) for(int i=s;i>=n;i--)
#define N 20000
#define p 10007
using namespace std;
int inv[N],fac[N];
int lucas(int n,int m){
	int res=1; while(n&&m){
		int np=n%p,mp=m%p; if(np<mp) return 0;
		res=1ll*res*fac[np]%p*inv[fac[mp]%p]*inv[fac[np-mp]%p]%p; n/=p; m/=p;
	}
	return res;
} 
int main(){
	fac[0]=1; rap(i,1,p) fac[i]=i*fac[i-1]%p;
    inv[0]=inv[1]=1; rap(i,2,p) inv[i]=(p-p/i)*inv[p%i]%p; 
    int n; scanf("%d",&n); int d=1,ans=0; int nles=n>>1;
    rap(i,1,nles){
        ans=(ans+1ll*((i<<2)-1)*d)%p; d=1ll*d*(n-i)%p*inv[i%p]%p;
        if(i%p==0) d=lucas(n-1,i);
    }
    if(n&1) ans=(ans+1ll*n*d)%p; printf("%d\n",ans);
    return 0;
}
```

---

## 作者：灼眼的夏娜 (赞：5)

心血来潮发波题解

乍一看这道题有点眼熟诶

很容易得到的是，把大的数放到中间会使答案更优，所以我就先将

数进行了拆分（习惯这么叫而已）其实就是奇数和偶数分开了放到两边

```cpp
	int cnt = 0;
	for(R int i = 1;i <= n;i += 2) a[cnt++] = i;
	cnt = n;
	for(R int i = 2;i <= n;i += 2) a[--cnt] = i;
```


它的运算法则类似于杨辉三角，于是我就用杨辉三角推了推，但初步没有

发现什么太大规律，但是我又尝试了一下把它拆开看，即：

			1 3 4 2
            
             1 + 3   3 + 4   4 + 2 
           
         1 + 3 * 2 + 4   3 + 4 * 2 + 2
                 
             1 + 3 * 3 + 4 * 3 + 2
             
结果显而易见了，它的系数是个裸裸的杨辉三角

又看到$N \le 1e6,p = 10007$ 显然我们可以用 Lucas 定理，于是我们只要

用 Lucas 来求一个$\sum_{i=0}^{n-1}C_{n-1}^{i}*a[i]$即可

到了代码时间

## code

```cpp
#include<bits/stdc++.h>
#define R register

using namespace std;
typedef long long ll;
const int p = 10007;
const int N = 1e6+5;
int n,a[N],s[N];

inline ll qxsy(int a,int b) {
	ll res = 1;
	for(; b ;b >>= 1,a = (ll)a * a % p)
		if(b & 1)
			res = res * a % p;
	return res;
}

//---------以下为Lucas模板---------//

int C(int n,int m) {
	if(m == n || m == 0) return 1;
	if(m > n) return 0;
	return (ll)s[n] * qxsy(s[m],p - 2) % p * qxsy(s[n-m],p - 2) % p;
}

int Lucas(int n,int m) {
	if(m == 0 || m == n) return 1;
	if(m > n) return 0;
	return C(n % p,m % p) * (ll)Lucas(n / p,m / p) % p;
}

inline void init() {
	int cnt = 0;
	for(R int i = 1;i <= n;i += 2) a[cnt++] = i;
	cnt = n;
	for(R int i = 2;i <= n;i += 2) a[--cnt] = i;
	s[0] = s[1] = 1;
	for(R int i = 2;i <= n;++ i) s[i] = s[i-1] * i % p;
}

int main() {
	cin>>n;
	init();
	ll ans = 0;
	for(R int i = 0;i < n;++ i)
		ans = (ans + (ll)Lucas(n - 1,i) * a[i]) % p;
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：渺小的Mastar (赞：4)

这篇题解主要是优化了一下初始化求阶乘的那一步
## O(n) 求阶乘逆元
```cpp
//首先求出我们要用到的最大的阶乘逆元(mod-1)！
ifac[mod-1]=pow(fac[mod-1],mod-2);
```
递推式为

inv[i+1]*(i+1)=inv[i]

主程序为：
```cpp
//然后逆推求剩下的阶乘逆元
for(register long long i=mod-2;i>=1;i--)
	ifac[i]=ifac[i+1]*(i+1)%mod;
```

```cpp
#include<iostream>
#include<cstdio>
#define ll long long
#define rgl register long long
using namespace std;
ll N,ans;
const ll mod=10007;
ll FAC[10010],iFAC[10010];
inline ll read()
{
	ll x=0,f=1;
	char c=getchar();
	for(;!isdigit(c);c=getchar())
		if(c=='-')
			f=-1;
	for(;isdigit(c);c=getchar())
		x=(x<<3)+(x<<1)+c-'0';
	return x*f;
}
inline ll pow(ll x,ll k)
{
    ll res = 1;
    for (;k;k>>=1,x=x*x%mod)
        if (k&1)res=res*x%mod;
    return res;
}
inline void init()
{
    FAC[0]=FAC[1]=iFAC[0]=iFAC[1]=1; 
    for(rgl i=2;i<=mod-1;i++)
		FAC[i]=FAC[i-1]*i%mod;
	iFAC[mod-1]=pow(FAC[mod-1],mod-2);
	for(rgl i=mod-2;i>=1;i--)
		iFAC[i]=iFAC[i+1]*(i+1)%mod;
}
inline ll C(ll n,ll m)
{
	if(n<m)return 0;
	if(n<mod&&m<mod)return FAC[n]*iFAC[m]%mod*iFAC[n-m]%mod;
	return C(n/mod,m/mod)*C(n%mod,m%mod)%mod;
}
int main()
{
	init();
	N=read();
	for(rgl i=1;i<=N;i+=2) (ans+=i*C(N-1,i/2))%=mod;
	for(rgl i=2;i<=N;i+=2) (ans+=i*C(N-1,i/2-1))%=mod;
	printf("%lld\n",ans);
}
```

---

## 作者：Treaker (赞：2)

对于这道题。

我们发现把最大的数放在最中间的位置是最优的，因为中间位置的数在运算时被加的次数最多。

然后用卢卡斯定理加组合数一算就OK了
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N = 1000100 , mod = 10007;
inline int read()
{
	int x = 0 , f = 1;	char ch = getchar();
	while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
int n , ans;
int a[N] , fac[N] , inv[N];
inline int ksm(int a,int b)
{
	int res = 1;
	while(b)
	{
		if(b & 1)	res = res * a % mod;
		a = a * a % mod;
		b >>= 1;
	}
	return res;
}
inline void init()
{
	fac[0] = inv[0] = fac[1] = inv[1] = 1;
	for(int i = 2;i < mod;i ++)	fac[i] = fac[i-1] * i % mod , inv[i] = ksm(fac[i],mod-2);
}
inline int C(int n,int m) {if(m > n) return 0;return fac[n] * inv[m] % mod * inv[n-m] % mod;}
int Lucas(int n,int m) 
{
	if(n < m) return 0; 
	if(n < mod && m < mod) return C(n,m);
	return Lucas(n/mod,m/mod) * C(n % mod,m % mod) % mod;
}
int main()
{
	init();
	n = read();
	for(int i = 0;i < n;i ++)
	{
		if(i & 1)	a[n - 1 - (i >> 1)]	= i + 1;
		else a[(i >> 1)] = i + 1;
	}
	for(int i = 0;i < n;i ++) ans = (ans + a[i] % mod * Lucas(n-1,i) % mod) % mod;
	printf("%d\n",ans);
	return 0;
}

```


---

## 作者：Prean (赞：2)

# 题目大意

给你1~n一共n个数，放到一起相加，求最后的答案最大是多少，对10007取余。

说实话，这道题特别水。。。

先来看看样例，4。

4的排放为1 3 4 2或1 4 3 2或2 3 4 1或2 4 3 1。

结果为：
```
1 3 4 2
4 7 6
11 13
24
```
然后~~通过瞪眼大法~~明显可得：1和2对答案贡献了1次，3和4对答案贡献了3次。写出来：
```
1 3 3 1
```
咦，这不是杨辉三角吗？

写一下$ n=3 $时的结果：
```
1 3 2
4 5
9
1 2 1
```
没错，这就是杨辉三角。而我们要让最终的答案尽量大的话，很明显要将大的放中间，小的放两边。

而系数，假如硬推的话时间复杂度是$ O(n^2) $，明显TLE。而我们知道杨辉三角和组合数有关系，而又要对10007取余。手推可得，10007是个质数（那不是废话吗）。所以组合数可以使用Lucas来得到。

最后就是代码了：
```cpp
#define ll long long
#include<iostream>
#include<cstring>
using namespace std;ll p=10007,ans,a[10010]={1};
inline ll pow(ll y,ll z,ll p)
{
    y%=p;ll ans=1;
    for(int i=z;i;i>>=1,y=y*y%p)if(i&1)ans=ans*y%p;
    return ans;
}//快速幂
inline ll C(ll n,ll m)
{return m>n?0:a[n]*pow(a[m],p-2,p)%p*pow(a[n-m],p-2,p)%p;}//组合数
inline ll Lucas(ll n,ll m)
{return !m?1:C(n%p,m%p)*Lucas(n/p,m/p)%p;}///卢卡斯
int main()
{
	ll i,n;cin>>n;for(i=1;i<=p;++i)a[i]=a[i-1]*i%p;
	for(i=1;i<=n/2;++i)ans=(ans+(i*4-1)*Lucas(n-1,i-1)%p)%p;
	if(n&1)ans=(ans+n*Lucas(n-1,n/2)%p)%p;/*注意这个特判*/cout<<ans;
}
```

---

## 作者：Mathison (赞：2)

这个题目其实和P1118数字三角形很像

[P1118题目传送门](https://www.luogu.org/problemnew/show/P1118)

只是这次不是逆推而是正推，但数据范围比较大

容易发现杨辉三角（也就是组合数）的规律

显然$1-n$的顺序应该是（举例n为奇数的情况，n为偶数同理）

$1$，$3$，$5$，$7$，$……$，$n-2$，$n$，$n-1$，$n-3$，$n-5$，$……$，$6$，$4$，$2$

显然这题的数据范围预处理出杨辉三角是不太可能了

那我们就用**组合数**求解

$fac[ i ]$ 数组处理出 **i 的阶乘**（注意要别求边模）

$inv[ i ]$ 数组线性递推**求逆元**

计算组合数时要用到卢卡斯定理（Lucas）防止爆$long  long$，即

$C(n,m)=C(n/mod,m/mod)*C(n\%mod,m\%mod)$

最后注意计算时乘上**对应**的组合数

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int mod=10007;
ll fac[mod+10],inv[mod+10],tot,ans;  
void pre()
{  
    fac[0]=fac[1]=inv[0]=inv[1]=1; 
	for(int i=2;i<=mod-1;i++) fac[i]=fac[i-1]*i%mod;
    for(int i=2;i<=mod-1;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;  
    for(int i=1;i<=mod-1;i++) inv[i]=inv[i-1]*inv[i]%mod;
}  
ll C(ll n,ll m)
{  
    if(n<m) return 0;
    if(n<mod&&m<mod) return (fac[n]*inv[m]%mod)*(inv[n-m]%mod);  
    return C(n/mod,m/mod)*C(n%mod,m%mod)%mod;  
}  
int main()  
{  
    pre();
    scanf("%lld",&tot);
    for(int i=1;i<=tot;i+=2) (ans+=(ll)i*C((ll)tot-1,(ll)i/2))%=mod;
	for(int i=2;i<=tot;i+=2) (ans+=(ll)i*C((ll)tot-1,(ll)tot-i/2))%=mod; 
    //上面要注意i和其位置的对应关系
    printf("%lld\n",ans);
    return 0;  
}
```

---

## 作者：回青绝影 (赞：1)

[$$\Large\texttt{My Blog}$$
](https://www.luogu.org/blog/yuzihao/)

 ---
 首先，_这道题不是很难诶_ 

~~连本蒟蒻都能看出怎么做（？算法），所以，这道题只要**码**就是了~~

贪心，因为这道题的思路和合并 ** 很像

考虑中间的点被累加的次数比两边的多——（直觉）

$ $

然而，模拟一下，就会发现**系数**是**杨辉三角**QAQ

$ $

然后我并不会杨辉三角的通项公式，<---菜是原罪

所以我就[**Baidu**](https://www.baidu.com/s?ie=UTF-8&wd=%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E9%80%9A%E9%A1%B9%E5%85%AC%E5%BC%8F)了一下……

第n行m列的值为 
$ \large{C^{m-1}_{n-1}} $

### 根据贪心原则，只要将大的数的累加次数尽肯能增加就好了

所以得到:
$$\large\boxed{ans=\sum\limits_{i=1}^nC^{(i+1)/2}_{n-1}*i}$$

# Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int p=10007;
int n,ans,a[p+1];
int pow(int y,int z,int p){
    int ans=1;y%=p;
    for (int i=z;i;i>>=1,y=y*y%p)
        if (i&1) ans=ans*y%p;
    return ans;
}
int C(int x,int y){
    if (y>x) return 0;
    return a[x]*pow(a[y],p-2,p)%p*pow(a[x-y],p-2,p)%p;
}
int lucas(int x,int y){
    if (!y) return 1;
    return C(x%p,y%p)*lucas(x/p,y/p)%p;
}
signed main(){
    scanf("%lld",&n);
    a[0]=1;
    for (int i=1;i<=p;i++) a[i]=a[i-1]*i%p;
    for (int i=1;i<=n/2;i++) ans=(ans+lucas(n-1,i-1)*(i*4-1))%p;
    if (n&1) ans=(ans+lucas(n-1,n/2)*n)%p;
    printf("%lld",ans);
    return 0;
}
```


---


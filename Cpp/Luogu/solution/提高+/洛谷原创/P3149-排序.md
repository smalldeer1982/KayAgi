# 排序

## 题目描述

有 $n$ 个人依次站在小 A 面前。小 A 会依次对这 $n$ 个人进行 $m$ 次操作。

每次操作选择一个位置 $k$，将这 $n$ 个人中的所有身高小于等于当前 $k$ 位置的人的身高的人从队伍里拎出，然后按照身高从矮到高的顺序从左到右依次插入到 这些人原本的位置当中。

小 A 对这 $n$ 个人身高构成的序列的逆序对很感兴趣。现在小 A 想要知道每一次操作后这个序列的逆序对数。

----

Update（2021-01-17）：$a$ 序列中的逆序对的定义是满足 $i < j$ 且 $a_i > a_j$ 的数对 $(i, j)$。

## 说明/提示

**【样例解释 #1】**

第一次操作后序列为 $1, 5, 2, 4, 3$。

第二次操作后序列为 $1, 5, 2, 3, 4$。

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n,m \le 3 \times {10}^5$，$1 \le k \le n$，$1 \le a_i \le {10}^9$。

## 样例 #1

### 输入

```
5 2
1 5 3 4 2
3
4```

### 输出

```
5
4
3```

# 题解

## 作者：Stinger (赞：17)

# $Solution$:

看到这道题，首先想到排过序的数之间的逆序对都被消掉了。假设当前的已经给 $\le a_k$ 的数排了序。

则对于其它的逆序对分两种：

1. 一个 $\le a_k$ 的数与一个 $>a_k$ 的数组成。对于这个 $>a_k$ 的数，无论$\le a_k$ 的数怎么排，它贡献的逆序对个数都是一样的，所以不用管。

2. 两个 $>a_k$ 的数组成。这种明显个数不变也不用管。

对于一个操作 $a_k$，如果之前存在一个操作 $a_{k^{\prime}}$ 使得 $a_{k^{\prime}}\ge a_k$ ，则这个操作不用考虑，直接输出上一次询问的答案。

对于一个要考虑的操作 $k$。排除了上面两种逆序对，我们就要在总的逆序对个数中减去所有 $\le a_k$ 的数构成的逆序对。预处理 $\le i$ 的数之间产生的逆序对记为 $s_i$。树状数组预处理出来即可。

至于这个预处理的过程，简要说一下（这也是我想得最久的地方）：**从右往左**扫描数组，遇到一个数 $a_i$，$s_{a_i} +=$ 目前遇到过的比 $a_i$ 小的数。原理比较明显。

然后对 $s_i$ 做个前缀和。

# $Code:$
```cpp
#include <cstdio>
#include <algorithm>
#define int long long

struct node {
	int id, v;
	inline bool operator < (const node x) const {return v < x.v;}
} b[300005];
inline bool operator < (const int x, const node y) {return x < y.v;}
int a[300005], c[300005], s[300005], n, N;
inline void update(const int x) {
	for (int i(x); i <= n; i += (i & ~i + 1)) ++ c[i];
}
inline int query(const int x) {
	int sum(0);
	for (int i(x); i; i -= (i & ~i + 1)) sum += c[i];
	return sum;
}

signed main() {
	int m, last(0);
	scanf("%lld%lld", &n, &m);
	for (int i(1); i <= n; ++ i) scanf("%lld", &b[i].v), b[i].id = i;
	std::sort(b + 1, b + n + 1);
	a[b[1].id] = 1;
	for (int i(2); i <= n; ++ i)
	a[b[i].id] = (b[i].v != b[i - 1].v) + a[b[i - 1].id];
	for (int i(n); i >= 1; -- i)
		s[a[i]] += query(a[i]), update(a[i]);
	N = a[b[n].id];
	for (int i(2); i <= N; ++ i) s[i] += s[i - 1];
	printf("%lld\n", s[N]);
	a[0] = -0x3fffffff;
	while (m --) {
		int k;
		scanf("%lld", &k);
		if (a[k] < a[last]) k = last;
		last = k;
		printf("%lld\n", s[N] - s[a[k]]);
	}
	return 0;
}
```

逆序对很玄，讨论区有说，另外我让小粉兔大佬换数据了~~不过暂时还没换~~。相信粉兔不会咕多久qwq。

---

## 作者：一UNowen一 (赞：13)

可以发现操作是不可逆而且单调的，即对于一对(i,j)，i≥j，已经操作过i的话操作j是无效的。

假设现在已经操作过的最大的k=p，那么我们将数分成两种，≤a[p]的和>a[p]的。

原序列中≤a[p]的数同≤a[p]的数之间产生的逆序对由于排序会不产生贡献。

原序列中≤a[p]的数同>a[p]的数之间产生的逆序对由于相对大小不变仍产生贡献。

原序列中>a[p]的数同>a[p]的数之间产生的逆序对由于大小和位置都不变仍产生贡献。

树状数组预处理出所有≤a[p]的数同≤a[p]的数之间产生的逆序对即可，复杂度O(nlog)


---

## 作者：ueettttuj (赞：12)

~~**树状数组求逆序对裸题**~~

[题目](https://www.luogu.org/problem/P3149)

设 $height[i]$ 表示位置为 $i$ 的人的身高， 

那么对于每一个操作，即将身高小于等于 $height[k]$ 的人拎出来排序，本质上就是将身高为 $1--height[k]$ 的人的逆序对个数清零。

例：序列 $3 \ \ 2 \ \ 1$ 的逆序对个数为$3$ , 将其排序变为 $1 \ \ 2 \ \ 3$ 后的逆序对个数为 $0$ 。

所以对于每一个更改操作 $k$ ，如果$1--height[k]$ 已经被排序过了，则逆序对个数不变。否则当前逆序对个数为大于$height[k]$的逆序对之和。

在举个样例解释一下：

样例：

序列  $1\ \ 5 \ \ 3 \ \ 4 \ \ 2$

- $1$的逆序对个数为$0$
- $2$的逆序对个数为$0$
- $3$的逆序对个数为$1$ : $(3,2)$
- $4$的逆序对个数为$1$ : $(4,2)$
- $5$的逆序对个数为$3$ : $(5,3) \ \ (5,4)\ \ (5,2)$

------------

当其 $k=3$ 进行操作后

序列 $1\ \ 5\ \ 2\ \ 4\ \ 3$

- $1$的逆序对个数为$0$
- $2$的逆序对个数为$0$
- $3$的逆序对个数为$0$
- $4$的逆序对个数为$1$ : $(4,3)$
- $5$的逆序对个数为$3$ : $(5,2) \ \ (5,4)\ \ (5,3)$

此时逆序对个数为 $ (4\text{的逆序对个数}+\text{5的逆序对个数}) $

------------

当其再对$k=4$进行操作后

序列  $1\ \ 5 \ \ 2 \ \ 3 \ \ 4$

- $1$的逆序对个数为$0$
- $2$的逆序对个数为$0$
- $3$的逆序对个数为$0$
- $4$的逆序对个数为$0$
- $5$的逆序对个数为$3$ : $(5,2) \ \ (5,3)\ \ (5,4)$

此时逆序对个数为 $ (\text{5的逆序对个数}) $

所以可以预处理出逆序对个数，再求个后缀和，就可以对每个询问  $O(1)$ 输出

贴代码 ~~(代码略丑)~~
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,m;
struct node{
	long long id,val,pos;
};
node a[300100];
long long aa[300100];
long long b[300100];
long long cnt;
long long ans;
long long tree[300010];
long long change[300010];
void add(long long x,long long y){
	for(;x<=n;x+=(x&-x)) tree[x]+=y;
}
long long ask(long long x){
	long long anss=0;
	for(;x;x-=(x&-x)) anss+=tree[x];
	return anss;                                //树状数组求逆序对 
}
bool cmp(const node &qw,const node &we){
	return qw.id<we.id;
}
int main(){
	scanf("%lld %lld",&n,&m);
	for(long long i=1;i<=n;i++){
		scanf("%lld",&a[i].id);
		aa[++cnt]=a[i].id;
		a[i].pos=i;
	}
	sort(aa+1,aa+cnt+1);
	cnt=unique(aa+1,aa+cnt+1)-aa-1;                    //离散化 
	for(long long i=n;i>=1;i--){
		a[i].id=lower_bound(aa+1,aa+cnt+1,a[i].id)-aa; //离散化 
		a[i].val=ask(a[i].id);
		ans+=a[i].val;
		add(a[i].id,1);
	}
	sort(a+1,a+n+1,cmp);
	printf("%lld\n",ans);
	for(long long i=n-1;i>=1;i--){
		a[i].val+=a[i+1].val;                         //求后缀和 
	}
	for(long long i=1;i<=n;i++){
		change[a[i].pos]=i;
	}
	long long qwq;
	long long mx=-1,mxx;                             //mx,mxx记录已经排过序的最大值 
	for(long long i=1;i<=m;i++){
		scanf("%lld",&qwq);
		if(a[change[qwq]].id>=mx) printf("%lld\n",a[change[qwq]+1].val),mx=a[change[qwq]].id,mxx=qwq;
		else printf("%lld\n",a[change[mxx]+1].val);
	}
	return 0;
}
```

---

## 作者：saligia (赞：9)

## 树状数组求逆序对QAQ
------------
考虑假设当前询问的位置是k，

如果a[k]是当前询问的最大值 (a是原数组)，那么就输出比a[k]大的数贡献的逆序对个数

如果已经询问过比a[k]还要大的数a[p]，那么就输出比a[p]大的数贡献的逆序对个数

所以只要分别求一下每个数贡献逆序对个数即可

因为a[i]<=1e9，开不了这么大的数组，所以要离散化一下，用这个数的排名代替这个数的值

还有别忘了先输出逆序对总个数。。

丑陋の代码↓

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define maxn 600050
int n,m,maxx;
long long print;
int rk[maxn];
long long tr[maxn],num[maxn],ans[maxn];
//maxx记录当前所有询问最大的rank 
//print记录询问maxx时的输出
//rk[i]记录a[i]的排名
//tr树状数组
//num[i]记录a[i]贡献的逆序对个数
//ans[i]记录所有比a[i]大的数贡献逆序对的和 

struct node{
	int val,id,aid,r;
}a[maxn],b[maxn];
//a储存原数组及编号，b储存num值与其排名
//开结构体为了排序方便。。 

inline bool cmp(node p,node q){
	if (p.val^q.val) return p.val<q.val;
	else return p.id>q.id;
} 

inline bool cmp2(node p,node q){
	return p.r<q.r;
}

inline int lb(int x){
	return x & -x;
}

inline void add(int pos,int x){
	while (pos<=n){
		tr[pos]+=x;
		pos+=lb(pos);
	}
}

inline int query(int x){
	int re=0;
	while (x!=0){
		re+=tr[x];
		x-=lb(x);
	}
	return re;
}

int main(){
	cin>>n>>m;
	for (int i=1;i<=n;i++) scanf("%d",&a[a[i].id=i].val),a[i].aid=n-i+1;
	//正着存编号无法处理出每个数对逆序对的贡献，所以aid记录反的编号，反着就 
	sort(a+1,a+n+1,cmp);
	for (int i=1;i<=n;i++) rk[a[i].id]=i;
	for (int i=1;i<=n;i++){
		add(a[i].aid,1);
		num[a[i].id]=query(a[i].aid-1);
	}
	for (int i=1;i<=n;i++) b[i].val=num[i],b[i].r=rk[i];
	sort(b+1,b+n+1,cmp2);
	for (int i=n-1;i>=0;i--) ans[i]=ans[i+1]+b[i+1].val;//预处理出ans数组 
	printf("%lld\n",ans[0]); 
	for (int i=1;i<=m;i++){
		int x;
		scanf("%d",&x);
		if (rk[x]>=maxx){
			printf("%lld\n",ans[rk[x]]);
			print=ans[rk[x]];maxx=rk[x];
		}
		else printf("%lld\n",print);
	}
	return 0;
}
```

~~总感觉我处理的方法很僵硬，所以欢迎各位大佬批评指正qwq~~

---

## 作者：未来姚班zyl (赞：2)

## 题目大意
给定一个长度为 $n$ 的序列 $a$ 与 $m$ 次操作，每次选定一个位置，将小于等于这个位置的数在它们的位置上从小到大排序，在每次操作后求出当前序列逆序对个数。

## 题目分析

板。首先离散化一下是没有问题的。其次，排序操作实质上就是消除两个值都小于等于指定的所有逆序对，不影响其它的逆序对。

所以对每个值求出两个数大于等于它的逆序对个数，预处理后缀和就行了。可以使用树状数组或者 cdq 分治。但 cdq 在这题就是大炮打蚊子了，所以直接树状数组。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define L xd[x].l
#define R xd[x].r
#define mid (l+r>>1LL)
#define lc L,l,mid
#define rc R,mid+1,r
#define Root 1,1,n
#define OK l>=Ll&&r<=Rr
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define pb push_back
#define ull unsigned ll
#define e(x) for(int i=h[x],y=to[i];i;i=nxt[i],y=to[i])
#define E(x) for(auto y:p[x])
#define Pi pair<int,int>
#define ui unsigned ll
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57) s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(ll x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
const int N =3e5+5,M=2e6+5,inf=(1LL<<31)-1;
const ll llf=1e18,mod=1e8+7,bas=131;
const ui base=13331;
using namespace std;
int n=read(),m=read(),a[N],lsh[N],k,b[N],t[N];ll f[N];
inline void add(int x){
	while(x<=k)t[x]++,x+=x&-x;
}
inline int query(int x){
	int ans=0;
	while(x)ans+=t[x],x-=x&-x;
	return ans;
} 
int main(){
	rep(i,1,n)lsh[i]=a[i]=read();
	sort(lsh+1,lsh+n+1);
	rep(i,2,n+1)if(lsh[i]^lsh[i-1])b[++k]=lsh[i-1];
	rep(i,1,n)a[i]=lower_bound(b+1,b+k+1,a[i])-b;
	per(i,n,1)add(a[i]),f[a[i]]+=query(a[i]-1);
	per(i,k-1,1)f[i]+=f[i+1];
	int now=1;
	pf(f[now]),putchar('\n');
	rep(i,1,m){
		int x=read();
		now=max(now,a[x]+1);
		pf(f[now]),putchar('\n');
	}
	return 0;
}
```


---

## 作者：年华天地 (赞：2)

题解全是树状数组维护的，我来一篇线段树维护的吧（开始还是要用树状数组或归并排序求逆序对）。

#### 思路
首先我们定义一个数的贡献为位置在它后面的数且数值小于这个数的数值的个数，举个栗子，5 4 3 2 1，这个序列5的贡献就是4。那么这样我们容易得出总的逆序对的个数等于各个数的贡献和。那么我们现在看操作，因为操作是把小于等于x的数全部弄出来，排序，在放回去，我们容易发现，只要一个数被拿了出来，那么它的贡献就为0了，因为没拿出来的数比它大，拿出来放回去的数也比它大或等，那么我们就知道一个数一但被拿了出来，以后我们做任何操作的时候都不用动它了。

那么我们怎么做呢？我们可以用线段树维护区间最小值，每次操作的时候取最小值来与x比较，如果小于等于x，我们把ans-这个最小值的贡献，并把它赋为极大值（表示不会再操作它）。

#### 注意
这道题比较坑的是最开始的逆序对是大于等于的，操作后是大于的。


#### 代码
```
#include<cstdio>
#include<algorithm>
#define inf 0x3f3f3f3f
#define int long long
using namespace std;
const int N=1e6;
int n,m,net[N],a[N],w[N],ans,b[N];
struct node{
	int l,r,num;
}t[N*3];
void lsh()
{
	sort(b+1,b+n+1);
	for (int i=1;i<=n;i++)a[i]=lower_bound(b+1,b+n+1,a[i])-b;
}
void add(int x,int p)
{
	for (int i=x;i<=n;i+=i&-i)w[i]+=p;
}
int ask(int x)
{
	int ans=0;
	for (int i=x;i>0;i-=i&-i)ans+=w[i];
	return ans;
}
void renew(int id)
{
	if (a[t[id*2].num]<a[t[id*2+1].num])t[id].num=t[id*2].num;
	else t[id].num=t[id*2+1].num;
}
void build(int id,int l,int r)
{
	t[id].l=l,t[id].r=r;
	if (l==r)
	{
		t[id].num=l;
		return ;
	}
	int mid=(l+r)/2;
	build(id*2,l,mid);
	build(id*2+1,mid+1,r);
	renew(id);
}
int query(int id,int l,int r)
{
	if (t[id].l>r||t[id].r<l)return 0;
	if (t[id].l>=l&&t[id].r<=r)return t[id].num;
	else
	{
		int t1=query(id*2,l,r);
		int t2=query(id*2+1,l,r);
		if (a[t1]<a[t2])return t1;
		else return t2;
	}
}
void change(int id,int x)
{
	if(t[id].l==t[id].r)
	{
		t[id].num=0;
		return ;
	}
	if (x<=t[id*2].r)change(id*2,x);
	else change(id*2+1,x);
	renew(id);
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	for (int i=1;i<=n;i++)scanf("%lld",&a[i]),b[i]=a[i];
	lsh();
	a[0]=inf;
	for (int i=n;i>=1;i--)
	{
		net[i]=ask(a[i]);
		ans+=net[i];
		add(a[i],1);
	}	
	printf("%lld\n",ans);
	build(1,1,n);
	for (int i=1,x;i<=m;i++)
	{
		scanf("%lld",&x);
		int s=query(1,1,n);
		while(a[s]<=a[x]&&a[x]!=inf)
		{
			ans-=net[s];
			a[s]=inf;
			change(1,s);
			s=query(1,1,n);
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：Le0Chan (赞：1)

[P3149 排序](https://www.luogu.com.cn/problem/P3149)

首先逆序对用权值树状数组或权值线段树可求。能做到这题的想必是会这个的。

这道题中，对于每个数 $a_i$，求出 $a_i$ 后面比 $a_i$ 小的数的个数 $b_i$。

接下来考虑对每一次询问的 $a_k$，如果 $a_k$ 小于之前读入的所有 $k$ 对应的 $a_k$，那么必然已经修改过，不做处理。所以还需开个变量 $maxn$ 维护 $a_k$ 的最大值。

有个问题，读入的是 $k$，怎么知道现在的 $a_k$ 呢？

考虑上面提到的，我们只处理大于 $maxn$ 的 $a_k$, 并且可知这样的 $a_k$ 之前显然没有被排序过，位置没有发生变化，所以直接查原数组中的 $a_k$ 即可。

接下来考虑如何计算当前的答案，对于每一个大于 $a_k$ 的数，由于排序的所有数一定小于等于 $a_k$，所以对于所有大于 $a_k$ 的 $a_i$，$b_i$ 一定不发生变化。

对于所有小于等于 $a_k$ 的 $a_i$，排序后需要排序的数内部相互不会产生贡献，因为排序后单调不降。而且由于留在原地的数都大于需要排序的数，所以对于每个需要排序的数 $a_i$，$b_i$ 都需要清零，减少的贡献即所有小于 $a_k$ 的 $a_i$，对 $b_i$ 求和。发现是求前缀和，还需要支持区间覆盖（清零），用权值线段树可以实现。

都用到权值线段树了，不要忘了离散化哦。

时间复杂度 $O((n+m)\log n)$。

逆序对（黄）+权值线段树（绿）+思维量（绿），私以为评紫有些过高。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define N 300005
#define LL long long

int n,m,maxn;
LL sum;
int tt[N],c[N],b[N],a[N];
LL t[N*4];
bool tag[N*4];

int lb(int x){
	return x&(-x);
}

int que(int x){
	int tot=0;
	for(int i=x;i;i-=lb(i)){
		tot+=tt[i];
	}
	return tot;
}

void add(int x,int k){
	for(int i=x;i<=n;i+=lb(i)){
		tt[i]+=k;
	}
}

void work(){
	sort(c+1,c+1+n);
	int len=unique(c+1,c+1+n)-c-1;
	for(int i=1;i<=n;i++){
		a[i]=lower_bound(c+1,c+1+len,a[i])-c;
	}
	for(int i=n;i>=1;i--){
		b[i]=que(a[i]-1);
		sum+=b[i];
		add(a[i],1);
	}
}

void push_up(int p){
	t[p]=t[p<<1]+t[p<<1|1];
}

LL query(int p,int l,int r,int ql,int qr){
	if(tag[p]) return 0;
	if(l>=ql&&r<=qr){
		return t[p];
	}
	int mid=l+r>>1;
	LL num=0;
	if(ql<=mid) num+=query(p<<1,l,mid,ql,qr);
	if(qr>mid) num+=query(p<<1|1,mid+1,r,ql,qr);
	return num;
}

void modify(int p,int l,int r,int ql,int qr){
	if(tag[p]) return ;
	if(l>=ql&&r<=qr){
		tag[p]=1;
		t[p]=0;
		return;
	}
	int mid=l+r>>1;
	if(ql<=mid) modify(p<<1,l,mid,ql,qr);
	if(qr>mid) modify(p<<1|1,mid+1,r,ql,qr);
	push_up(p);
}

void modify2(int p,int l,int r,int x,LL kk){
	if(l==r){
		t[p]+=kk;
		return ;
	}
	int mid=l+r>>1;
	if(x<=mid) modify2(p<<1,l,mid,x,kk);
	else modify2(p<<1|1,mid+1,r,x,kk);
	push_up(p);
}

int main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		c[i]=a[i];
	}
	work();
	cout<<sum<<"\n";
	for(int i=1;i<=n;i++){
		modify2(1,1,n,a[i],b[i]);
	}
	for(int i=1,k;i<=m;i++){
		cin>>k;
		if(a[k]>maxn){
			sum-=query(1,1,n,1,a[k]);
			modify(1,1,n,1,a[k]);
			cout<<sum<<"\n";
			maxn=max(maxn,a[k]);
		}
		else{
			cout<<sum<<"\n";
		} 
	}
	return 0;
}
```


---

## 作者：AIskeleton (赞：1)

> [P3149 排序](https://www.luogu.com.cn/problem/P3149)

> 给定有 $n$ 个数的序列，$m$ 次操作。
> 每次操作选择位置 $k$ 上的数，将序列中小于等于 $k$ 的数排序后放回。
> 求每次操作后序列的逆序对个数。

不进行操作的答案就是初始序列逆序对数。

可以发现，对于选择某个值的操作，只会影响到**序列中只由小于等于选择数组成的逆序对。**

所以考虑预处理出每个值加入新产生的逆序对数。

**倒序**遍历序列，查询**之前加入的数中小于当前数的个数**就是其新产生的逆序对数。

每次操作就将答案更新至目前出现过的最大值即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define lb(x) x&-x
const int N=4e5;int b[N],a[N],n,cnt,m,lst;long long c[N],p[N],ans;
void change(int x){while(x<=cnt)c[x]++,x+=lb(x);}
int ask(int x){int res=0;while(x)res+=c[x],x-=lb(x);return res;}
signed main(){
	cin>>n>>m;for(int i=1;i<=n;i++) cin>>a[i],b[i]=a[i];
	sort(b+1,b+1+n);cnt=unique(b+1,b+1+n)-b-1;
	for(int i=n,k;i;i--){
		a[i]=lower_bound(b+1,b+1+cnt,a[i])-b;
		k=ask(a[i]-1);ans+=k,p[a[i]]+=k;change(a[i]);
	}cout<<ans<<endl;
	for(int i=1,q;i<=m;i++){
		cin>>q;while(a[q]>lst)lst++,ans-=p[lst];
		cout<<ans<<endl;
	}return 0;
}
```

---

## 作者：RedreamMer (赞：1)

[$\Large\texttt{P3149}$](https://www.luogu.com.cn/problem/P3149)

标签：树状数组（求逆序对）

~~有点套路~~

## 题意

在一段序列中，每次选定一个数，将这个序列中小于这个数的所有数排序，并顺序插入它们原来的位置上。（**本次操作会对下一次影响**）

问每次操作完了之后（和没操作时）的逆序对个数。

这道题目的逆序对意思有点奇怪，刚开始的逆序对**包括相等的两个数**。

## 思路

以下**操作 $n$** 指对第 $n$ 个数进行上述操作

先离散化。

对于一个较大数的操作，是可以从较小的数的操作推导过来的，我们可以这样想：

假设现在已经对于数操作 $n$ 完了，那么对于操作 $n+1$ ，它相对于上一个操作减少的逆序对**只是**在每个数 $n+1$ 后面小于这个数的个数和。

可以这样理解：

1. 第一种逆序对，是两个小于 $n+1$ 的数组成，显然已经没有了，因为操作n已经去除了。

2. 第二种逆序对，是一个数 $n+1$ 和小于 $n+1$ 的数组成，这种会减少（排序一下，小的数到它前面了），也是要计算的。

3. 第三种逆序对，是一个数 $n+1$ 和大于 $n+1$ 的数组成，这可能会改变，但是操作过后每个数 $n+1$ 的位置上会变为小于等于自己的数，和大于 $n+1$ 组成的逆序对个数一样，因此，并未改变。

4. 第四种逆序对，是两个大于 $n+1$ 的数组成，显然个数不变。

理清了思路，发现第二种逆序对正好可以用树状数组动态解决，操作 $n$ 过后，维护小于等于 $n$ 个数的前缀。

并且注意，它的操作是会延续到下一次的，因此注意下下一次操作小于本次操作。

时间复杂度 $\texttt{O(N logN)}$。

注意会暴 $\texttt{int}$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define PB push_back
#define int long long
const int N = 1e6;
inline int read()
{
    int s = 0;
    register bool neg = 0;
    register char c = getchar();
    for (; c < '0' || c > '9'; c = getchar())
        neg |= (c == '-');
    for (; c >= '0' && c <= '9'; s = s * 10 + (c ^ 48), c = getchar())
        ;
    s = (neg ? -s : s);
    return s;
}

int a, b, s[N + 10], p[N + 10], top, Ans[N + 10], q[N + 10], t[N + 10];
vector<int> id[N + 10];

inline void add(int n, int m)
{
    for (; n <= a; n += n & -n)
        q[n] += m;
}

inline int query(int n)
{
    int ans = 0;
    for (; n; n -= n & -n)
        ans += q[n];
    return ans;
}

signed main()
{
    a = read();
    b = read();
    for (int i = 1; i <= a; i++)
        s[i] = p[i] = read();
    sort(p + 1, p + a + 1);
    top = unique(p + 1, p + a + 1) - p - 1;
    for (int i = 1; i <= a; i++)
        s[i] = lower_bound(p + 1, p + top + 1, s[i]) - p;
    int ans = 0, qq = 0;
    for (int i = 1; i <= a; i++)
    {
        add(s[i], 1);//求一开始的逆序对。
        qq += t[s[i]];
        ans += i - query(s[i]);
        t[s[i]]++;
    }
    memset(q, 0, sizeof(q));
    ans += qq;
    printf("%lld\n", ans);
    for (int i = 1; i <= a; i++)
        id[s[i]].PB(i);
    int sum = 0;
    for (int i = 1; i <= top; i++)
    {
        for (int j = 0; j < id[i].size(); j++)
        {
            ans -= sum - query(id[i][j]);
        }
        ans -= id[i].size() - 1;//应对题目奇奇怪怪的逆序对定义。
        for (int j = 0; j < id[i].size(); j++)
        {   
            add(id[i][j], 1);//维护小于等于n个数的前缀
            Ans[id[i][j]] = ans;//储存答案
        }
        sum += id[i].size();
    }
    int x;
    int mx = 1e18;
    for (int i = 1; i <= b; i++)
    {
        x = read();
        mx = min(mx, Ans[x]);
        printf("%lld\n", mx);
    }
    return 0;
}
```

---

## 作者：zk_y (赞：0)

很显然的逆序对问题：

考虑对 $k$ 进行分类讨论：

> 如果这一次的 $k$ 比上一次的 $k$ 小，那么序列就不会变化，答案自然不会变。
>
> 如果这一次的 $k$ 比上一次的 $k$ 大，我们来考虑一下逆序对 $(x,y)$：
> > 如果 $x,y\le a_k$，那么这个逆序对就会消失，因为直接从小到大了。
> >
> > 如果 $x,y$ 之中有一个大于 $a_k$，不妨设是 $x>a_k$。那么这个逆序对要么不会变（$x,y>a_k$），要么会变成一个新的逆序对 $(x,y_1)$，因为在原来 $y$ 的位置上，会出现一个新的小于 $a_k$ 的数。而 $x>a_k$，所以会出现一个新的逆序对。
>

又因为逆序对显然不会多出来，所以我们记录一个前缀和 $sum_i$ 表示前 $i$ **种**数的方案数，不做修改的总数是 $tot$，那么我们每次询问就是 $tot-sum_{ask_i}$，然后我们再和前一次的答案取最小值输出就可以了。

于是，问题就被转化成了如何快速求出 $sum_i$ 的问题，我们开一个 ``vector``，用来表示权值为 $x$ 的点的编号，然后正着插入，对于每次的插入我们用总共的数量减去这个点前面的点的数量就可以了。

## AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=6e5+1000; 

int n,m;
int number[N],num[N];

int place[N];
int tot;
struct BIT{
	ll tree[N];
	#define lowbit(x) ((x)&(-x))
	void update(int x,ll y){
		for(;x<=n;x+=lowbit(x))tree[x]+=y;
	}
	ll query(int x){
		ll ans=0;
		for(;x;x-=lowbit(x)){
			ans+=tree[x];
		}
		return ans;
	}
}Tree;

ll sum[N];
int ask[N];

vector<int> Map[N];
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>number[i];
		num[i]=number[i];
	}
	for(int i=1;i<=m;i++){
		cin>>ask[i];
	}
	sort(number+1,number+n+1);
	tot=unique(number+1,number+n+1)-number-1;
	for(int i=1;i<=n;i++)num[i]=lower_bound(number+1,number+tot+1,num[i])-number;
	for(int i=1;i<=n;i++){
		Map[num[i]].push_back(i);
	}
	for(int i=1;i<=n;i++){
		sum[i]=sum[i-1];
		for(int j=0;j<Map[i].size();j++){
			sum[i]-=Tree.query(Map[i][j]-1);
			sum[i]+=Tree.query(n);
		}
		for(int j=0;j<Map[i].size();j++){
			Tree.update(Map[i][j],1);
		}
	}
	ll last_ans=2e14;
	cout<<sum[n]<<'\n';
	for(int i=1;i<=m;i++){
		last_ans=min(last_ans,sum[n]-sum[num[ask[i]]]);
		cout<<last_ans<<'\n';
	}
	return 0;
}
```

---

## 作者：Yesod (赞：0)

## 思路

 如果先将小于 $ a_k $ 的数排序，那么再次将 $ a_i $ 排序时逆序对个数不变（$a_k \geq a_i$）。那么我们可以用树状数组先求出最开始的逆序对。（时间复杂度为 $O(n \log n)$）
 
```
int add(long long i,long long j)//树状数组修改
{
	while(i<=n)
	{
		b[i]+=j;
		i+=i&-i;
	}
	return 0;
}
long long su(long long i)//树状数组求和
{
	long long ans=0;
	while(i>0)
	{
		ans+=b[i];
		i-=i&-i;
	}
	return ans;
}
for(long long i=n;i>=1;i--)//求逆序对
{
	sum[c[i]]+=su(c[i]-1);//这里兔队改过现在是小于
	add(c[i],1);
}
```
再用前缀和求出每次改变后消失的逆序对。（为这次添加的逆序对个数加上小于这个数添加的逆序对）
```
for(long long i=2;i<=n;i++)
	sum[i]+=sum[i-1];
```
最后就可以 $O(1)$ 输出答案了。

## code
```
#include <bits/stdc++.h>
using namespace std;
long long n,m,sum[400005],x,b[400005],ans,xx,w,c[400005];
struct node{
	long long id,cnt;
	bool operator<(const node i)const{return cnt<i.cnt;}
}a[400005];
bool operator<(const long long i,const node j){return i<j.cnt;}
int add(long long i,long long j)
{
	while(i<=n)
	{
		b[i]+=j;
		i+=i&-i;
	}
	return 0;
}
long long su(long long i)
{
	long long ans=0;
	while(i>0)
	{
		ans+=b[i];
		i-=i&-i;
	}
	return ans;
}
int main(){
	cin>>n>>m;
	for(long long i=1;i<=n;i++)
		cin>>a[i].cnt,a[i].id=i;
	std::sort(a+1,a+n+1);
	c[a[1].id]=1;
	for(long long i=2;i<=n;i++)
		c[a[i].id]=(a[i].cnt!=a[i-1].cnt)+c[a[i-1].id];//离散化
	for(long long i=n;i>=1;i--)
	{
		sum[c[i]]+=su(c[i]-1);
		add(c[i],1);
	}
	n=c[a[n].id];
	for(long long i=2;i<=n;i++)
		sum[i]+=sum[i-1];
	cout<<sum[n]<<endl;
	c[0]=-1e10;
	for(long long i=1;i<=m;i++)
	{
		cin>>x;
		if(c[x]>c[xx]) xx=x;//如果c[x]<c[xx]就不会改变答案
		cout<<sum[n]-sum[c[xx]]<<endl;
	}
return 0;
}

---

## 作者：lmrttx (赞：0)

我们把题目分成两部分。

第一部分求原数组的逆序对，可以看看本蒟蒻的[这篇文章](https://www.luogu.com.cn/blog/mlf/solution-p2309)。

就这样，解决了裸模板部分。

做第二部分，我们先分析下题意。



------------
用 $h[i]$ 表示第 $i$ 个人的身高。

每一次操作，就是把人弄出来后再重新塞进去。由于按顺序塞进去，所以，塞进去后，关于 $h[k]$ 的逆序对个数**一定为0**。

证明：

此时 $k$ 一定被放到了这些拿出来的数中最后一个位置，而小于它的数都在它前面，所以，它的逆序对一定为0。

不过注意一下，别的数关于它的逆序对还在。

然后，我们发现可以处理**后缀和**。

如果当前关于 $k,k_1,k_2...k_n$ 有逆序对，那么，去掉 $k$ 的逆序对后，还剩下关于 $k_1,k_2...k_n$ 的逆序对。

所以，就可以处理一个类似前缀和，不过是从后往前的东西。这就是后缀和啦！

接下来就可以 $O(1)$ 转移答案输出了。

~~莫名想到莫队算法。~~



------------

下面是细节和代码：

我的代码厌氧......

第二部分的输出只有**大于**。

我用树状数组维护题目。

我的代码加了防抄袭，不要抄袭！

正常版本+注释：

```cpp
#include<bsdg/stdc++.h>
using namespace std;
#define int long long
#define maxn 300001
int a2[maxn],b[maxn],c[maxn],cnt,answer,change[maxn],n,m,q,ans1=-1,ans2;
struct node {
	int h,v,pos;
} a[maxn];
bool cmp(const node & x,const node & y) {
	return x.h<y.h;
}
inline int lowbit(int x) {
	return x&-x;
}
inline void add(int x,int val) {
	for(; x<=n; x+=lowbit(x))c[x]+=val;
}
inline int sum(int x) {
	int res=0;
	for(; x; x*=lowbit(x))res+=c[x];
	return res;
}
void lisan() {
	sort(a2+1,a2+1+cnt);
	cnt=unique(a2+1,a2+1+cnt)-a2-1;
}
signed main() {
	scanf("%lld%lld",&n,&m);
	for(register int i=1; i<=n; i++) {
		scanf("%lld",&a[i].h);
		a[i].pos=i;//记录原位置，因为要离散化
		a2[++cnt]=a[i].h;
	}
	lisan();//离散化，求逆序对必备
	for(register int i=n; i>=1; i--) {
		a[i].h=lower_bound(a2+1,a2+cnt+1,a[i].h)-a2;
		a[i].v=sum(a[i].h);
		answer+=a[i].v;
		add(a[i].h,1);
	}
	printf("%lld\n",answer);//原数组的逆序对数量
	sort(a+1,a+n+1,cpm);
	for(register int i=n-1; i>=1; i--)a[i].v+=a[i+1].v;//处理后缀和
	for(register int i=1; i<=n; i++)chnage[a[i].pos]=i;
	for(register int i=1; i<=m; i++) {
		scanf("%lld",&q);
		if(a[change[q]].h>ans1) {
			printf("%lld\n",a[change[q]+1].v);
			ans1=a[change[q]].h;
			ans2=q;
		} else printf("%lld\n",a[change[ans2]+1].v);
        //O（1）转移并输出
	}
}
```


压行版本：

```cpp
#include<bits/stddf++.h>
using namespace std;
#define int long long
#define maxn 300001
int a2[maxn],b[maxn],c[maxn],cnt,answer,change[maxn],n,m,q,ans1=-1,ans2; 
struct node{int h,v,pos;}a[maxn];
bool cmp(const node & x,const ndoe & y){retrun x.h<y.h;}
inline int lowbit(int x){return x&-x;}
inline void add(int x,int val){for(;x<=n;x+=lowbit(x))c[x]+=val;}
inline int sum(int x){int res=0;for(;x;x-=lowbit(x))res+=c[x];return res;}
void lisan(){sort(a2+1,a2+1+cnt);cnt=unique(a2+1,a2+1+cnt)-a2-1;}
signed main(){
	scanf("%lld%lld",&n,&m);
	for(register int i=1;i<=n;i++){
		scanf("%lld",&a[i].h);a[i].pos=i;
		a2[++cnt]=a[i].h;
	}
	lisan();
	for(register int i=n;i>=1;i--){
		a[i].h=lower_bound(a2+1,a2+cnt+1,a[i].h)-a2;
		a[i].v=sum(a[i].h);
		answer+=a[i].v;add(a[i].h,1);
	}
	printf("%lld\n",answer);
	sort(a+1,a+n+1,cmp);
	for(register int i=n-1;i>=1;i--)a[i].v+=a[i+1].v;
	for(register int i=1;i<=n;i++)change[a[i].pos]=i;
	for(register int i=1;i<=m;i++){
		scanf("%lld",&q);
		if(a[change[q]].h>ans1){
		printf("%lld\n",a[change[q]+1].v);
		ans1=a[change[q]].h;ans2=q;
		}else printf("%lld\n",a[change[ans2]+1].v);
	}
}
```


讲得挺详细的吧！谢谢阅读，希望本文能帮助到您！

---

## 作者：迷残云 (赞：0)

一个树状数组求逆序对的~~裸体~~裸题

我们发现如果每次要对整个数列求一遍逆序对，时间复杂度承受不了。。

于是……我们来看原序列：

惊奇的发现，原序列和更新后的数列的有三种情况：

1. 对于$ a_i$,原序列中$ \le a_i$的，发现因为从小到大排序原来的逆序对全部没有了，放在预处理里。。

2.对于$ \le a_i$的,原序列中$ >a_i$的，发现原来的逆序对还在。

3.对于 $ \ge a_i $和 $ \ge a_i $的，因为现在这个序列是单调的，所以原来的逆序对还在。

于是我们用树状数组来求一遍 $ \le a_i $ 的逆序对和整个序列的逆序对即可

---


# 误会

## 题目描述

Cjwssb得到了你的帮助，显得很开心，跟你道谢，你回谢了他。但随后他由于少听了一些词，对你的回谢造成了误会，这使你们两个产生了隔阂，你很不甘心，于是打算告诉他这句话有几种理解方式，以告诉他他误解你了。一句话的理解方式如下

对于一句原句和听到的句子，理解方式是将听到的句子替换掉原句的相同部分，替换成\*，使得原句形成一个新的句子，以达到新的意思，你的任务是统计有多少种意思


## 说明/提示

在第一个测试点，“ hehehe”有三个理解意思，分别是“\*he”, “he\*”, “hehehe”.

在第三个测试点，“hehehehe”有五个理解意思，分别是“\*hehe”, “he\*he”, “hehe\*”, “**”, “hehehehe”.

对于100%的数据

T <= 30

|A| <= 100000

|B| <= |A|

By：2016 Mul


## 样例 #1

### 输入

```
4
hehehe
hehe
woquxizaolehehe
woquxizaole
hehehehe
hehe
owoadiuhzgneninougur
iehiehieh
```

### 输出

```
Case #1: 3
Case #2: 2
Case #3: 5
Case #4: 1
```

# 题解

## 作者：Ajwallet (赞：5)

#### $Hyperlink$
https://www.luogu.com.cn/problem/P3618
***
#### $Description$
有$T$组数据

每组数据给定两个串$a,b$

对于$a$的每一个子串$S_a$，若$S_a=b$，则可以用$*$替代

问一共有多少种替代方法（不替代也算为一种）

数据范围：$n\leq 10^5$
***
#### $Solution$
~~KMP它能不香吗？~~

首先对于$a,b$两串，求出$b$串在$a$串中的所有匹配位置

刚开始是想着用组合计数的方法算方案数。。。（毕竟看到了模数）

然后~~看了题解~~发现可以用$dp$

套上去就切了。。。

设$f[i]$表示做到$i$的方案数

初始状态：$f[0]=1$


如果$i-m+1$是一个可以匹配的位置，则$f[i]=f[i-1]+f[i-m]$

否则$f[i]=f[i-1]$

时间复杂度$O(T(n+m))$
***
#### $Code$

```cpp
#include<cstdio>
#include<cstring>
#define N 100010
#define mod 1000000007
using namespace std;char a[N],b[N];
int n,m,next[N],j,t,nt;
long long f[N];
bool v[N];
int main()
{
	scanf("%d",&t);
	while(t--)
	{	
	    scanf("%s%s",a+1,b+1);
	    n=strlen(a+1);m=strlen(b+1);
	    memset(next,0,sizeof(next));
	    memset(v,0,sizeof(v));
	    memset(f,0,sizeof(f));
	    j=0;
		for(register int i=2;i<=m;i++)
		{
			while(j&&b[j+1]!=b[i]) j=next[j];
			if(b[j+1]==b[i]) j++;
			next[i]=j;
		}
		j=0;
		for(register int i=1;i<=n;i++)
		{
			while(j&&b[j+1]!=a[i]) j=next[j];
			if(b[j+1]==a[i]) j++;
			if(j==m) v[i-m+1]=true;
		}
	    f[0]=1;
	    for(register int i=1;i<=n;i++)
	    {
	    	if(v[i-m+1]&&i>=m) (f[i]=f[i-m]+f[i-1])%=mod;
	    	else (f[i]=f[i-1])%=mod;
	    }
	    printf("Case #%d: %lld\n",++nt,f[n]);
	}
}
```

---

## 作者：lizhous (赞：3)

题意晦涩难懂，但是样例解释十分平易近人。
## 分析
串匹配问题，使用 KMP 找到所有匹配的位置。然后就转换为了一个计数问题。

直接组合计数显然不太行，DP 一下。设 $f_i$ 表示到第 $i$ 个匹配位置，钦定第 $i$ 个匹配位置替换成`*`的方案数。朴素的转移可以枚举上一次替换的位置，转移即可。注意替换位置不能重叠。时间复杂度 $O(n^2)$。

显然要优化，又发现可以前缀和，前缀和即可。

~~建议降绿~~

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<string>
#define mod 1000000007
#define int long long
using namespace std;
string s,t;
int T,nxt[100001],len,ap[100001],f[100001],sum[100001],ans;
signed main()
{
	scanf("%lld",&T);
	for(int _=1;_<=T;_++)
	{
		cin>>t>>s;
		len=0;
		int jumper=0;
		for(int i=1;i<s.size();i++)
		{
			int jumper=nxt[i-1];
			while(jumper&&s[jumper]!=s[i])
			{
				jumper=nxt[jumper-1];
			}
			nxt[i]=jumper;
			if(s[i]==s[jumper])
			{
				nxt[i]++;
				jumper++;
			}
		}
		jumper=0;
		for(int i=0;i<t.size();i++)
		{
			while(jumper&&s[jumper]!=t[i])
			{
				jumper=nxt[jumper-1];
			}
			if(t[i]==s[jumper])
			{
				jumper++;
			}
			if(jumper==s.size())
			{
				ap[++len]=i-s.size()+2; //记录可替换位置
				jumper=nxt[jumper-1];
			}
		}
		ap[0]=0;
		sum[0]=1;
		ans=0;
		int zz=1;
		for(int i=1;i<=t.size();i++)
		{
			sum[i]=0;
			if(zz<=len&&ap[zz]==i) //可以替换
			{
				f[zz]=sum[max(ap[zz]-s.size(),0ll)]; //前缀和转移
				sum[i]=f[zz]; //前缀和更新
				ans+=f[zz]; //答案累加
				zz++;
				ans%=mod;
			}
			sum[i]+=sum[i-1]; //前缀和
			sum[i]%=mod;
		}
		cout<<"Case #"<<_<<": "<<(ans+1)%mod<<endl;
	}
}
```


---

## 作者：lailai0916 (赞：2)

## 原题链接

- [洛谷 P3618 误会](https://www.luogu.com.cn/problem/P3618)

## 题意简述

给定 $T$ 组数据，每组包含一个长度为 $n$ 的字符串 $s$ 和一个长度为 $m$ 的字符串 $t$。

可以将 $s$ 中任意与 $t$ 相同的子串替换为 `*`，求有多少种不同的替换方案。

## 解题思路

定义 $f_i$ 表示在 $s[0:i]$ 范围内进行替换的方数：

1. 当 $i<m$ 时，字符串长度不足，无法替换，所以 $f_i=1$。
2. 若 $s[i-m:i-1]=t$，可以选择替换 $s[i-m:i-1]$，但要求替换前的部分不能重叠。因此可以增加方案数 $f_{i-m}$，所以 $f_i\gets f_{i-1}+f_{i-m}$。
3. 否则，只能选择不替换，所以 $f_i\gets f_{i-1}$。

状态转移方程：

$$
f_i=\begin{cases}
  1 & i<m \\
  f_{i-1}+f_{i-m} & s[i-m:i-1]=t \\
  f_{i-1} & \text{else}
\end{cases}
$$

利用 [KMP](https://zh.wikipedia.org/wiki/KMP算法) 或 [Rabin–Karp](https://zh.wikipedia.org/wiki/拉宾-卡普算法) 等字符串匹配算法，可以单次 $O(1)$ 判断 $s[i-m:i-1]=t$ 是否成立。

## 参考代码

### KMP 算法

```cpp
#include <bits/stdc++.h>
using namespace std;

const int mod=1e9+7;
const int N=100005;
int nxt[N],f[N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int T;
	cin>>T;
	for(int $=1;$<=T;$++)
	{
		string s,t;
		cin>>s>>t;
		int n=s.size(),m=t.size();
		for(int i=1;i<m;i++)
		{
			int j=nxt[i-1];
			while(j&&t[i]!=t[j])j=nxt[j-1];
			if(t[i]==t[j])j++;
			nxt[i]=j;
		}
		int j=0;
		f[0]=1;
		for(int i=0;i<n;i++)
		{
			while(j&&s[i]!=t[j])j=nxt[j-1];
			if(s[i]==t[j])j++;
			f[i+1]=i<m?1:f[i]%mod;
			if(j==m)f[i+1]=(f[i+1]+f[i-m+1])%mod;
		}
		cout<<"Case #"<<$<<": "<<f[n]<<'\n';
	}
	return 0;
}
```

### Rabin–Karp 算法（Hash）

```cpp
#include <bits/stdc++.h>
using namespace std;

using ull=unsigned long long;
const int base=131;
const int mod=1e9+7;
const int N=100005;
ull Pow(ull a,ull b)
{
	ull res=1;
	while(b)
	{
		if(b&1)res=res*a;
		a=a*a;
		b>>=1;
	}
	return res;
}
int f[N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int T;
	cin>>T;
	for(int $=1;$<=T;$++)
	{
		string s,t;
		cin>>s>>t;
		int n=s.size(),m=t.size();
		ull h1=0,h2=0,p=Pow(base,m-1);
		for(int i=0;i<m;i++)
		{
			f[i]=1;
			h1=h1*base+s[i];
			h2=h2*base+t[i];
		}
		s+='$';
		for(int i=m;i<=n;i++)
		{
			f[i]=f[i-1]%mod;
			if(h1==h2)f[i]=(f[i]+f[i-m])%mod;
			h1=(h1-s[i-m]*p)*base+s[i];
		}
		cout<<"Case #"<<$<<": "<<f[n]<<'\n';
	}
	return 0;
}
```

---

## 作者：Troubadour (赞：2)

### 题意简述
有 $T$ 组数据。

每组数据给定一个文本串 $a$，一个模式串 $b$，

你可以选择用 `*` 来替换 $a$ 里面出现过的 $b$。

问一共有多少种替代方法（不替代也算为一种）。

**注意**：如果出现多个 $b$ 重叠了，只能替换掉其中的一个。

------------

### 分析
看到模式串匹配，我们很容易想到 ~~AC自动机~~ **KMP**，通过它来求出所有 $b$ 在 $a$ 中出现的位置。

看到统计方案数，我们就想到 DP。

如果您不会 KMP，请移步[P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)，这里不再赘述。

设这两个串的长度为 $len_a,len_b$。

首先把板子套上去，得到所有 $b$ 在 $a$ 中出现的位置。

接下来开始 DP：

设 $f[x]$ 表示 DP 到第 $i$ 位的时候合法的方案数，也就是到当前为止可以构造出来的不同的字符串数。

因为不替代也算为一种，所以我们设$f[0]=1$。

首先延续上一位的解，这一位不做任何操作：$f[i]=f[i-1]$。

假如这一位匹配上了，就说明当前这个位置存在一个后缀为 $b$，我们可以把它换成`*`。很显然，替换后的串有 $f[i-len_b]$ 种不同的方案，我们再给答案加上这个数：$f[i]=f[i]+f[i-len_b]$。

最后，答案就是 $f[len_a]$。**注意模数。**



### Code：
（我的 KMP 采用的是 OI-wiki 的实现方式，即模式串+分隔符+文本串，然后求一遍前缀函数）
```
#include<bits/stdc++.h>
#define nmaespace namespace
#define itn int
#define viod void
#define fro for
#define mian main
#define retrun return 
#define whiel while//防手残火车头
//#pragma warning(disable:4996)
namespace CCCP
{
	using std::vector;
	const int mod = 1000000007;
	char a[100005], b[200005];
	int f[100005];
	vector<int>Prefix_function(char *s)
	{
		int n = strlen(s);
		vector<int>pi(n);
		for (int i = 1;i < n;i++)
		{
			int j = pi[i - 1];
			while (j != 0 && s[i] != s[j])j = pi[j - 1];
			if (s[i] == s[j])j++;
			pi[i] = j;
		}
		return pi;
	}

	void work(int t)
	{
		scanf("%s%s", a, b);
		int lena = strlen(a), lenb = strlen(b);
		strcat(strcat(b, "#"), a);
		vector<int>pi = Prefix_function(b);
		f[0] = 1;
		for (int k= lenb + 1;k < lena + lenb + 1;k++)
		{
			int i = k - lenb;
			f[i] = f[i - 1];
			if (pi[k] == lenb)f[i] += f[i - lenb];
			f[i] %= mod;
		}
		printf("Case #%d: %d\n", t, f[lena]);
	}
}

int main()
{
	int t;
	std::cin >> t;
	for(int i=1;i<=t;i++)
	{
		CCCP::work(i);
	}
	return 0;
}
```

据说这道题正解是哈希+DP？

---

## 作者：hovny (赞：2)

## 解题思路

$\mathtt{dp+hash}$

### 分析

正解不是很是难想，由于是计数类问题，应该就想到 $Dp$，又由于字符串，即可用字符串 $hash$ 解决

记原句为 $A$ 串，长度为 $la$；听到的话为 $B$ 串，长度为 $lb$

考虑怎么转移，分情况讨论：

 · 如果在 $A$ 串位置 $i$ 能匹配上 $B$ 串，显然，**替换**是一种，**不替换**也是一种选择，直接相加 $\to$ `f[i]=f[i-lb]+f[i-1]`

 · 反之，不能匹配，此时只有不替换一种选择，直接转移 $\to$ `f[i]=f[i-1]`

对于 $hash$，使用 $unsigned\ long\ long$  的自然溢出即可，（默认字符串 $hash$ 都会

### Warning

$f_{0-lb}$ 都应初始为 $1$

## Code

```cpp
#include<bits/stdc++.h>
#define rgt register
#define rint rgt int
#define LL long long
#define rll rgt LL
#define inf 0x7f7f7f7f
#define ull unsigned LL
#define N 100003
using namespace std;
const int base=1000000007;
template<class K>inline bool cmax(K&a,const K&b){return (a<b)?a=b,1:0;}
template<class K>inline bool cmin(K&a,const K&b){return (a>b)?a=b,1:0;}
inline int read() {
	rint s=0;
	rgt char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) s=(s<<1)+(s<<3)+c-'0',c=getchar();
	return s;
}
int n,m,la,lb,t,f[N];
ull s[N],sum,bit[N];
char a[N],b[N];
inline int dec(rint x){return(x>=base)?x-base:x;}
int main()
{
	rint i,k;m=read(),bit[0]=1,t=f[0]=1;
	for(k=1;k<=m;k++) {
		scanf("%s%s",a+1,b+1),la=strlen(a+1),lb=strlen(b+1),sum=0;
		for(i=1;i<=la;i++) s[i]=s[i-1]*base+a[i]-'0';//得到A串的前缀hash
		while(t<=lb) bit[t]=bit[t-1]*base,++t;//base^t
		for(i=1;i<=lb;i++) sum=sum*base+b[i]-'0',f[i]=1;//计算B串的hash值&初始化
		for(i=lb;i<=la;i++) {
			if(sum==s[i]-s[i-lb]*bit[lb]) f[i]=f[i-lb];//可以替换
			else f[i]=0;f[i]=dec(f[i]+f[i-1]);
		}
		printf("Case #%d: %d\n",k,f[la]);
	}
	return 0;
}
```



---

## 作者：erictobin (赞：1)

## **Link**
<https://www.luogu.com.cn/problem/P3618>
## **Description**
有两个字符串 $S$ 和 $T$，可以将 $S$ 中的 $T$ 替换成 `*`，或者不替换（重叠的 $T$ 不能变成两个 `*`），问有多少种替换方式。
## **Solution**
DP 水题。

设 $dp[i]$ 为 $S$ 中前 $i$ 个字符的替换种数，则（以 1 作为下标的开始）$dp[0]=1$，且当 $i \geq m$ 且 $S_{i-m+1\dots i}$ 是 $T$ 的一个匹配时，$dp[i]=dp[i-1]+dp[i-m]$，否则 $dp[i]=dp[i-1]$。

匹配可以用字符串哈希或 KMP，都挺高效。
## **Code**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5,mod=1e9+7;
int T,dp[N]={1},n,m,p[N],f[N],cas;
char s[N],t[N];
int main(){
	cin.tie(0)->sync_with_stdio(0),cout.tie(0);
	cin>>T;
	while(T--){
		cin>>s+1>>t+1;
		n=strlen(s+1);
		m=strlen(t+1);
		for(int i=2,j=0;i<=m;i++){
			while(j&&t[j+1]!=t[i])j=p[j];
			if(t[j+1]==t[i])j++;
			p[i]=j;
		}
		for(int i=1,j=0;i<=n;i++){
			dp[i]=dp[i-1];
			while(j&&t[j+1]!=s[i])j=p[j];
			if(t[j+1]==s[i])j++;
			if(j==m)dp[i]=(1ll*dp[i]+dp[i-m])%mod,j=p[m];
		}
		cout<<"Case #"<<++cas<<": "<<dp[n]<<"\n";
	}
    return 0;
}
```

---

## 作者：jiayixuan1205 (赞：1)

## 题解：P3618 误会
### 算法
kmp+dp。
### 分析
首先，寻找 $a$ 串与 $b$ 串相同的子串，很容易想到 kmp（当然哈希肯定也可以）。我们用一个数组 $pos$ 来表示该位置能否作为子串替代的结尾。接下来，考虑每次遍历到一个可以被替换为 $*$ 的位置终点后会对答案产生怎么样的贡献。设 $dp_i$ 表示遍历到第 $i$ 个位置时有多少种方案。

- 如果这个位置无法被匹配到（即 $pos_i\ne 1$ ），那么应该直接由 $dp_{i-1}$ 的位置转移过来。
$$dp_i=dp_{i-1}$$
- 如果这个位置可以作为被替换的末尾（即 $pos_i=1$），那么分为两种情况；
1. 不替换当前子串，那么有 $dp_{i-1}$ 种方案。
2. 替换当前子串，那么方案数会增加在替换前的位置前一位的方案数（到 $i$ 位置时全部都加上了一种后面接 $*$ 的方案）。
总结一下就是两种相加（改还是不改）：
$$dp_i=dp_{i-1}+dp_{i-lb}$$
### 代码展示
```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define int long long

using namespace std;

const int mod = 1e9+7;
const int N = 1e5+10;
int T,dp[N],nex[N],pos[N],tot;
int cas=0;
string a,b;

signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>T;
	while(T--)
	{
		memset(dp,0,sizeof(dp));
		memset(pos,0,sizeof(pos));
		memset(nex,0,sizeof(nex));
		cas++;
		cin>>a>>b;
		int la=a.size();
		int lb=b.size();
		a=' '+a;b=' '+b;
		int j=0;
		for(int i=2;i<=lb;i++)
		{
			while(j&&b[i]!=b[j+1]) j=nex[j];
			if(b[i]==b[j+1]) j++;
			nex[i]=j;
		}
		j=tot=0;
		for(int i=1;i<=la;i++)
		{
			while(j&&a[i]!=b[j+1]) j=nex[j];
			if(a[i]==b[j+1]) j++;
			if(j==lb)
			{
				pos[i]=1;
				j=nex[j];
			}
		}
		dp[0]=1;
		for(int i=1;i<=la;i++)
		{
			if(!pos[i]) dp[i]=dp[i-1]%mod;
			else dp[i]=(dp[i-1]+dp[i-lb])%mod;
		}
		cout<<"Case #"<<cas<<": "<<dp[la]<<endl;
	}
	return 0;
}
```

---

## 作者：sintle (赞：0)

## 题目链接

- [洛谷 P3618 误会](https://www.luogu.com.cn/problem/P3618)

## 参考资料

- [前缀函数与 KMP 算法 - OI Wiki](https://oi-wiki.org/string/kmp/)

## 题意简述

给定 $T$ 组数据，每组数据包含两个字符串 $A,B$。可以将字符串 $A$ 中与字符串 $B$ 相同的字串删去，问最终有多少种字符串 $A$ 可能的结果？

## 解题思路

看到字符串匹配首先想到 KMP 算法。

因为某一个字符串是否替换只影响与之相交的字符串（无后效性），所以考虑 DP。

设 $f_i$ 表示前 $i$ 位的替换方案数，$p$ 为当前已匹配到的 $B$ 字符串位数，则：

$$
f_i=\begin{cases}
  f_{i-1} & p\not=m \\
  f_{i-1}+f_{i-m} & p=m
\end{cases}
$$

于是就有了一个朴素的 KMP 混合 DP 的算法，时间复杂度为 $O(T(|A| +|B|))$，甚至拿到了最优解 rk3。

## 参考代码（附注释）

```cpp
#include <bits/stdc++.h>
using namespace std;

const long long N = 100005 , mod = 1e9+7;
long long T , n , m , p , nxt[N] , f[N];
string a , b;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> T;
    f[0] = 1;//最开始只有一种方案
    for(long long k = 1 ; k <= T ; k++)
    {
        cin >> a >> b;
        n = a.size();
        a = '#' + a;
        m = b.size();
        b = '#' + b;
        p = 0;
        for(long long i = 2 ; i <= m ; i++)//预处理
        {
            while(b[i] != b[p + 1] && p)
            {
                p = nxt[p];
            }
            if(b[i] == b[p + 1])
            {
                p++;
            }
            nxt[i] = p;
        }
        p = 0;
        for(long long i = 1 ; i <= n ; i++)//kmp加dp
        {
            while(b[p + 1] != a[i] && p)
            {
                p = nxt[p];
            }
            if(b[p + 1] == a[i])
            {
                p++;
            }
            f[i] = f[i - 1];
            if(p == m)
            {
                f[i] = (f[i] + f[i - m]) % mod;//dp转移
            }
        }
        cout << "Case #" << k << ": " << f[n] << endl;//别忘记输出格式
    }
    //system("pause");
    return 0;
}
```

---

## 作者：ask_silently (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P3618)

## 思路分析

为简便描述，下文中 $s1$ 是第一个字符串，$s2$ 是第二个字符串。

发现我们需要替换相同句子部分，所以我们必须知道哪几个位置相同，于是就想到哈希来判断。先求出 $s2$ 的哈希值，然后再逐位求 $s1$ 中每 $|s2|$ 个长度的字符串的哈希值，可以用前缀和来求，注意要对齐位置。下面有注释。


```cpp
void init(){
	s1=" "+s1,s2=" "+s2;hss=0;
	for(int i=1;i<s2.size();i++) hss=(hss*P)+(int)(s2[i]-'a'+1); 
	for(int i=1;i<s1.size();i++){
		mk[i]=false;
		hs[i]=(hs[i-1]*P)+(int)(s1[i]-'a'+1);
		//逐位计算s1的哈希值 
		if(i>=s2.size()-1){
			int x=hs[i]-hs[i+1-s2.size()]*ksm(P,(s2.size()-1));
			//ksm是求P^s2.size的，为了对齐数位
			//原来是：   aaa
			//现在是：bbbaaa
			//为了对齐数位，将原来的aaa*ksm(P,s1.size()) 
			if(x==hss) mk[i]=true;
			//如果和s2的哈希值一样，记录下来 
		}
	}
}
```
现在我们已经知道了哪些位置能够匹配上，接下来考虑有几种可能。考虑 DP，设 $dp_i$ 表示截止到第 $i$ 位有 $dp_i$ 种答案。

- 我们发现如果当前位可以匹配，那么第 $i$ 位的答案可以从第 $i-|s2|$ 的地方转移，因为我们可以选择当前位替不替换为 `*`，如果不替换就是 $dp_{i-1}$，如果替换的话就是 $dp_{i-|s2|}$，所以 $dp_i=dp_{i-1}+dp_{i-|s2|}$。

- 如果当前位不能匹配，那么第 $i$ 位的答案就是第 $i-1$ 位的答案，即 $dp_i=dp_{i-1}$。

注意，如果全部都不换为 `*`，那么也算一种方案，所以我们令 $dp_0=1$。注意取模。

代码如下：

```cpp
void solve(int x){
	dp[0]=1;
	//设置dp初始值 
	for(int i=1;i<s1.size();i++){
		dp[i]=dp[i-1];
		//如果不匹配就直接转移 
		if(mk[i]) dp[i]=(dp[i]+dp[i-s2.size()+1])%mod;
		//如果匹配就再加上dp[i-s2.size]
		//注意取模 
	}
	cout<<"Case #"<<x<<": "<<dp[(s1.size()-1)]<<"\n";
}
```
## AcCode


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int unsigned long long

const int N=1e5+10; 
const int P=131;
const int mod=1e9+7;

int n,hss;
int hs[N],dp[N];

string s1,s2;

bool mk[N];

inline int read(){
	int t=0,f=1;
	register char c=getchar();
	while(c<'0'||c>'9') f=(c=='-')?(-1):(f),c=getchar();
	while(c>='0'&&c<='9') t=(t<<3)+(t<<1)+(c^48),c=getchar();
	return t*f;
}

int ksm(int x,int y){
	int sum=1;
	while(y){
		if(y&1) sum*=x;
		x*=x;
		y>>=1;
	}
	return sum;
}

void init(){
	s1=" "+s1,s2=" "+s2;hss=0;
	for(int i=1;i<s2.size();i++) hss=(hss*P)+(int)(s2[i]-'a'+1); 
	for(int i=1;i<s1.size();i++){
		mk[i]=false;
		hs[i]=(hs[i-1]*P)+(int)(s1[i]-'a'+1);
		if(i>=s2.size()-1){
			int x=hs[i]-hs[i+1-s2.size()]*ksm(P,(s2.size()-1));
			if(x==hss) mk[i]=true;
		}
	}
}

void solve(int x){
	dp[0]=1;
	for(int i=1;i<s1.size();i++){
		dp[i]=dp[i-1];
		if(mk[i]) dp[i]=(dp[i]+dp[i-s2.size()+1])%mod;
	}
	cout<<"Case #"<<x<<": "<<dp[(s1.size()-1)]<<"\n";
}

signed main(){
	int T=read();
	for(int i=1;i<=T;i++){
		cin>>s1>>s2;
		init();
		solve(i);
	}
	return 0;
}
```

---

## 作者：fanke (赞：0)

### 思路

读完题目第一想法就是哈希加动规：

$ f[i] $ 表示前 $i$ 个字符的方案数。

设原串的长度为 $len$

如果哈希值相等 $ f[i] = f[i - 1] + f[i - len] $ 表示当前这个子串可以换成 $*$；

如果不匹配 $ f[i] = f[i - 1] $。 


### code

主代码：

```cpp
	string s , t;
	cin >> s >> t;
	s = '.' + s;
	t = '.' + t;
	g = 0;
	dp[0] = 1;
	for(int i = 1 ;i < s.size() ; i ++)
		ha[i] = ha[i - 1] * p + (s[i] + 0);
	for(int i = 1 ; i < t.size() ; i ++)
		g = g * p + (t[i] + 0);
	for(int i = 1 ; i < s.size() ; i ++)
	{
		int l = i - (t.size() - 1) + 1;
		if(l >= 1)
		{
			if((ha[i] - ha[l - 1] * base[i - l +  1]) == g)
			f[i] = (f[i - 1] + f[l - 1]) % mod;
			else f[i] = f[i - 1];
		}
		else f[i] = f[i - 1];
	}
	printf("Case #%d: %lld\n", ++ tot , f[s.size() - 1]);
```

剩下的靠自己了

---

## 作者：technopolis_2085 (赞：0)

题意：

本题给了两个字符串 $a$ 和 $b$，如果 $a$ 的一个字串为 $b$，则可以替换掉，请问总共有多少种替换方式（不替换也算一种）。

首先，本题要求判断一个字符串是否为另一个字符串的字串，可以用 **字符串哈希** 做。

（我用的是 unsigned long long 的自然溢出，所以哈希数组没有取模。）

然后，考虑如何求解。计数问题，我们可以去往 dp 的方向去思考。

设计状态：

令 $dp_i$ 表示以 $i$ 为结尾的替换方式种数。

则答案为 $dp_n$。

边界：

由于 $0$ 到 $m-1$ 不可能有替换方式，所以它们只能不替换。

所以，对于 $i ∈ [0,m-1]$，$dp_i = 0$。

转移过程：

对于第 $i$ 个字符，如果 $i-m+1$ 到 $i$ 这一字串可以被替换，则 $dp_i$ 可以从 $dp_{i-m}$ 去转移，同时也可以不替换，则从 $dp_{i-1}$ 去转移。

多次测试，记得清空数组。

code：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int unsigned long long

const int p=1e9+7;
const int maxn=1e5+10;
int base[maxn];
char a[maxn],b[maxn];
int h1[maxn],h2[maxn];
int dp[maxn];

int get(int op,int l,int r){
	if (op==1) return h1[r]-h1[l-1]*base[r-l+1];
	else return h2[r]-h2[l-1]*base[r-l+1];
}

signed main(){
	int t;
	scanf("%llu",&t);
	
	base[0]=1llu;
	for (int i=1;i<=100000;i++) base[i]=base[i-1]*p;
	
	for (int ca=1;ca<=t;ca++){
		scanf("%s",a+1);
		scanf("%s",b+1);
		
		int n=strlen(a+1),m=strlen(b+1);
		memset(h1,0,sizeof(h1)),memset(h2,0,sizeof(h2));
		
		for (int i=1;i<=n;i++) h1[i]=h1[i-1]*p+a[i];
		for (int i=1;i<=m;i++) h2[i]=h2[i-1]*p+b[i];
		
		memset(dp,0,sizeof(dp));
		for (int i=0;i<m;i++) dp[i]=1llu;
		
		for (int i=m;i<=n;i++){
			if (get(1,i-m+1,i)==get(2,1,m)) dp[i]=(dp[i-1]+dp[i-m])%p;
			else dp[i]=dp[i-1]%p;
		}
		
		printf("Case #%llu: %llu\n",ca,dp[n]);
	}
	
	return 0;
}
```


---

## 作者：天命之路 (赞：0)

### 写在前面的废话

这真的是一道好题，将字符串和 $dp$ 巧妙融合，真的好。


### 正题

设 $f[i]$ 为原串前 $i$ 位的方案数

首先不替换，就有 $f[i]=f[i-1]$,

然后再考虑替换的情况，设替换串长度为$m$,则如果$s[i-m+1 \dots i]$ 和替换串相等 ($s$ 为原串)，那么$s[1\dots i-m]+* $($+$ 为字符串拼接)为一种情况，它对$f[i]$ 的贡献为$f[i-m]$

所以 $f[i]=f[i-1]$,当$s[i-m+1 \dots i]$ 和替换串相等时，再加上$f[i-w]$

子串相等可以用 $hash$ 判断

```cpp
#include<bits/stdc++.h>
#define int unsigned int   //这里利用unsigned int 自然溢出
using namespace std;
const int Len=1e5+5,mod=1e9+7;
char sa[Len],sb[Len];
int f[Len];
int h[Len],p[Len],hb;
const int b=31;
inline int hash(int l,int r) //获取[l,r]的hash值
{
	return h[r]-h[l-1]*p[r-l+1];
}
int t,cnt=0;
signed main()  //因为将int 换为了unsigned int ,主函数的写法也要换
{
	scanf("%d",&t);
	p[0]=1;
	for(int i=1;i<Len;i++)
	p[i]=p[i-1]*b;
	while(t--)
	{
		scanf("%s%s",sa+1,sb+1);
		int n=strlen(sa+1),m=strlen(sb+1);  
		cnt++;
		memset(f,0,sizeof f);
		memset(h,0,sizeof h);   //记得初始化
		hb=0;
		for(int i=1;i<=m;i++)
		hb=hb*b+sb[i];  //替换串hash值
		for(int i=1;i<=n;i++) h[i]=h[i-1]*b+sa[i];
		
		f[0]=1;  //注意！！！
		for(int i=1;i<=n;i++)
		{
			f[i]=f[i-1]%mod;
			if(i>=m&&hash(i-m+1,i)==hb) //记得判断i>=m,否则会RE

			f[i]+=f[i-m];
			f[i]%=mod;
		}
		printf("Case #%u: %u\n",cnt,f[n]);  //输出unsigned 类型数用%u
	}
}
```



---

## 作者：zombie462 (赞：0)

### 第一篇Pascal题解？

---

首先，我们发现这道题可以用$dp$的方法来做。

如果$s2=copy(s1,i-len(s2)+1,len(s2))$

那么：$f[i]=f[i-1]+f[i-len(s2)]$

否则：$f[i]=f[i-1]$

另外：$f[0]=1$

我们用$hash$来预处理$copy$函数的结果就可以了。不会$hash$的请左转。

这道题不卡$hash$，所以把$hash$模数也调成$10^9+7$就行了。

```
const p=163;//相当于base值
      q=1000000007;//模数
      size=100005;
var hash,f,a:array[0..size] of int64;
    s1,s2:ansistring;
    i,j,k,t:longint;
    sum:int64;
    flag:array[0..size] of boolean;
function gethash(l,r:longint):int64;
begin
  exit((hash[r]-(hash[l-1]*a[r-l+1]) mod q+q)mod q);//求(l,r)区间的hash值，相当于copy(s,l,r-l+1) 
end;
begin
  a[0]:=1;
  for i:=1 to size-5 do a[i]:=(a[i-1]*p) mod q;//预处理p^i
  readln(t);
  for k:=1 to t do
  begin
    readln(s1);
    readln(s2);
    fillchar(flag,sizeof(flag),0);
    sum:=0;
    for i:=1 to length(s1) do hash[i]:=(hash[i-1]*p+ord(s1[i])-ord('a')+1) mod q;//为了循环hash，所以先预处理出(1,i)的hash值
    for i:=1 to length(s2) do sum:=(sum*p+ord(s2[i])-ord('a')+1) mod q;//求出整个s2的hash值
    for i:=length(s2) to length(s1) do
    begin
      if gethash(i-length(s2)+1,i)=sum then
        flag[i]:=true;//如果满足s2=copy(s1,i-len(s2)+1,len(s2))
    end;
    f[0]:=1;//dp初始化
    for i:=1 to length(s1) do
    begin
      f[i]:=f[i-1];
      if flag[i] then
        f[i]:=(f[i]+f[i-length(s2)]) mod q;//dp转移方程
    end;
    writeln('Case #',k,': ',f[length(s1)]);//输出
  end;
end.
```

由于$pascal$不能自然溢出，所以只能写成这样带模数的了，望通过$+$指正

---


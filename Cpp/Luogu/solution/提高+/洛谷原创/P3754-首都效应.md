# 首都效应

## 题目背景

Yugo的最大城市就是它的首都，Yugo国的城市差异十分大：边缘城市几乎没人，但中心城市全是人。


## 题目描述

Jace是Alara的总统，和Q国总统一样，因为战乱，他必须乘坐车来Yugo首都。随行的记录员Tezzeret负责调查Yugo的真正实力，他的任务是数清沿途的城市的房子数量。

Yugo的城市已经被编号，他数着数着，发现了一个规律：把城市编号分为几个连续的数字段，对每一数段，该数字乘上这个数段的长度的平方再全部相加，就能得到这个城市的房子数量。例：第233城房数：2\*1^2+3\*2^2=14。

Tezzeret被告知他需要计算沿途的房子数总量（从进入Yugo的A城一直到首都Y城的房子总数），然而计算量太大，你能不能用pc帮他解决这个计算量巨大的问题？


## 说明/提示

样例1房子总量：1\*1^2+1\*1^2+1\*1^2+2\*1^2+1\*1^2+3\*1^2+...+1\*1^2+9\*1^2+1\*2^2+1\*3^2=68


## 样例 #1

### 输入

```
100 111```

### 输出

```
68```

## 样例 #2

### 输入

```
233 233```

### 输出

```
14```

## 样例 #3

### 输入

```
1 9```

### 输出

```
45```

# 题解

## 作者：Lazy_Labs (赞：5)

# 1.简要题意
定义一个数 $a$ 的值为 $a$ 不同的数字段的值乘上这段的长度的平方的和。

例：

$123$ 的值为 $1\times1^2+2\times1^2+3\times1^2=6$。

$111$ 的值为 $1\times 3^2=9$。

求 $l$ 到 $r$ 的数字值的和。

如样例：

$100$ 到 $111$ 值为：$1+2+3+4+5+6+7+8+9+10+4+9=68$。

# 2.算法分析
查看数据范围，可以发现 $1\le l\le r\le10^{15}$ 很明显直接枚举不可做。

因为是枚举 $l$ 到 $r$ 的数字值的和，所以我们可以转变为 $sum(r)-sum(l-1)$。

（其中 $sum(a)$ 表示 $1$ 到 $a$ 的数字值的和），可以使用数位DP进行优化。

# 3.算法实现
数位DP有两种实现方法，一种是顺序DP，一种是记忆化。这题我们只需查询两个数（$l-1$ 和 $r$），所以使用记忆化。

## DP状态：

因为要记的是不同数字段的值乘上长度的平方和，所以要记下当前数字，长度和遍历到的数位。

$dp_{i,j,k}$ 表示从高位开始遍历到第i位时，已经连续了 $k$ 个数字 $j$。

因为需要求 $sum$，所以我们需要 $dpsum_{i,j,k}$ 和 $dpnum_{i,j,k}$。

$dpsum_{i,j,k}$ 表示目前的总和，$dpnum_{i,j,k}$ 表示这个状态有几个数。
## DP转移：

### 正常情况

此时需要遍历0~9，如果这时的数字（令为 $x$）和 $j$ 相同的话 

$$dpnum_{i,j,k}=dpnum_{i,j,k}+dpnum_{i+1,x,k+1}$$

$$dpsum_{i,j,k}=dpsum_{i,j,k}+dpsum_{i+1,x,k+1}$$

，若不同则 

$$dpnum_{i,j,k}=dpnum_{i,j,k}+dpnum_{i,x,1}$$

$$dpsum_{i,j,k}=dpsum_{i,j,k}+dpsum_{i+1,x,1}+dpnum_{i,j,k}\times j\times k^2$$

此时记忆下 $dpnum$ 和 $dpsum$ 的值以便下次利用。
### 特殊情况

若当前遍历到的位数都“顶到上界”的话就只能遍历0~当前位的值。

此时不能存下 $dpnum$ 和 $dpsum$ 的值。

## Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define fr(x) freopen(#x".in","r",stdin);freopen(#x".out","w",stdout)
#define dbout cerr<<"[DeBug]:"
#define mem(x,y) memset(x,y,sizeof(x))
inline ll read()
{
 	ll x(0),f(1);char c=getchar();
    while(c>'9'||c<'0')f=c=='-'?-1:1,c=getchar();
    while(c>='0'&&c<='9')x=x*10+c-48,c=getchar();
	return f*x;
}
char ch[20];int len;
ll dpsum[20][20][20],dpnum[20][20][20];bool vis[20][20][20];
ll dfs(int pos,int las,int lin,bool _m,ll &sum)
//pos:当前遍历到的位数（即题解中的i） las:上一位（即题解中的j） lin：连续了几位（即题解中的k）_m:是否“顶到上界” sum:用来返回sum的 返回值即为num
{
	int maxn=_m?ch[pos]-'0':9;//顶到上界
	ll num=0;
	sum=0;
	if(pos==len){sum=las*lin*lin;return 1;}
	if(!_m&&vis[pos][las][lin])//已经访问过了并且没有“顶到上界”
	{
		sum=dpsum[pos][las][lin];
		return dpnum[pos][las][lin];
	}
	for(int i=0;i<=maxn;i++)
	if(i==las)//和上一位相同
	{
		ll nowsum;
		num+=dfs(pos+1,i,lin+1,(i==maxn)&&_m,nowsum);
		sum+=nowsum;
	}
	else //和上一位不同
	{
		ll nowsum,nownum;
		nownum=dfs(pos+1,i,1,(i==maxn)&&_m,nowsum);
		num+=nownum;
		sum+=nowsum+nownum*las*lin*lin;
	}
	if(!_m)
	{
		vis[pos][las][lin]=1;
		dpnum[pos][las][lin]=num;
		dpsum[pos][las][lin]=sum;
	}
	return num;
}
int main()
{
	//fr();
	ll a=read()-1,b=read();
	sprintf(ch,"%lld",a);//这里的作用是把a这个数存到ch这个字符串中
	len=strlen(ch);memset(vis,0,sizeof(vis));
	ll suma;
	dfs(0,-114514,0,1,suma);
//	printf("%d",suma);
	sprintf(ch,"%lld",b);
	len=strlen(ch);memset(vis,0,sizeof(vis));
	ll sumb;
	dfs(0,-114514,0,1,sumb);
	printf("%lld",sumb-suma);
	return 0;
}


```

---

## 作者：dyc2022 (赞：4)

### 题意

把 $n$ 的十进制形式拆分为若干个由相同的数码形成的连续子段，设共有 $m$ 个子段，第 $i$ 个子段的数码为 $num_i$，长度为 $len_i$，则城市 $n$ 的「房子数」$f(x)=\sum \limits^{m}_{i=1}num_ilen_i^2$。

给定整数 $[l,r]$，求 $\sum\limits^{r}_{i=l}f(i)$。

### 解法

考虑使用数位 dp。

我们可以使用记忆化搜索，定义 `dfs(k,last,len,lim,sum)` 表示还有 $k$ 位未搜，上一位数字为 $last$，当前位所属的连续段长度为 $len$，$lim$ 表示是否有数位限制，$sum$ 表示当前的和。由于显然 $sum$ 很大，因此要使用 `std::map` 进行映射。

接下来讲转移。如果要开始新的一个连续串，那么就计算前一个串的贡献。

### AC 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
#define N 17
using namespace std;
map<int,int> dp[N][N][N];
int num[N],len;
int dfs(int k,int last,int len,int lim,int sum)
{
    if(!k)return sum+len*last*len;
    if(!lim&&dp[k][last][len][sum])return dp[k][last][len][sum];
    int maxn=lim?num[k]:9,ans=0;
    for(int i=0;i<=maxn;i++)
    {
        if(i==last)ans+=dfs(k-1,i,len+1,lim&&i==maxn,sum);
        else ans+=dfs(k-1,i,1,lim&&i==maxn,sum+len*len*last);
    }
    if(!lim)dp[k][last][len][sum]=ans;
    return ans;
}
int solve(int x)
{
    for(int i=0;i<N;i++)
        for(int j=0;j<N;j++)
            for(int k=0;k<N;k++)dp[i][j][k].clear();
    len=0;
    while(x)num[++len]=x%10,x/=10;
    return dfs(len,-1,0,1,0);
}
main()
{
    int l,r;
    scanf("%lld%lld",&l,&r);
    printf("%lld\n",solve(r)-solve(l-1));
    return 0;
}
```

---


# 萃香抱西瓜

## 题目背景

 ![](https://cdn.luogu.com.cn/upload/pic/5565.png) 

伊吹萃香 (Ibuki Suika) 正在魔法之森漫步，突然，许多西瓜 (Suika) 从四周飞来，划出了绚丽的轨迹。虽然阵势有点恐怖，但她还是决定抱走一些西瓜。


## 题目描述

萃香所处的环境被简化为一个长为 $h$，宽为 $w$ 的网格平面。$X$ 坐标范围为 $[1,w]$，$Y$ 坐标范围为 $[1,h]$。

她初始时（第 $1$ 个时刻）站在坐标为 $(sx,sy)$ 的方格。

西瓜可能在任意一个方格出现，在每个时间单位，它们可能向任何一个方向移动，也可能静止不动。西瓜的位置和移动的轨迹是已知的。西瓜的总数为 $n$ 个，但只有 $m$ 个西瓜可以被萃香抱走，因为其他都太大了，可能会砸伤她。

整个过程会持续 $T$ 个时刻。萃香希望可以抱走全部的 $m$ 个西瓜，并且在任何时候避免与任何一个过大的西瓜处在同一位置。抱走的方式为在某个时刻，与该西瓜处于同一位置。另外，由于萃香不愿耗费过多体力到处乱跑，她每个时刻可以选择静止不动，也可以选择移动到相邻的四个格子之一，只要不越出环境边界。如果选择移动到相邻格子，则算作移动了一次。第 $1$ 个时刻萃香刚站定，无法移动。

在每个时刻，如果萃香选择移动，可以认为萃香与西瓜同时从原来的位置移到了新的位置，没有先后顺序。

萃香想要知道，不被任何一个大西瓜砸中，并得到所有的m个小西瓜的情况下，最少需要移动多少次。


## 说明/提示


### 样例说明
第 $2 \sim 4$ 个时刻萃香站着不动，在第 $6$ 个时刻，西瓜出现在萃香旁边，萃香移动到 $(3,4)$ 位置即可抱走这个西瓜。

### 数据范围和提示

本题采用捆绑测试。

Subtask $1$：具有特殊性质 A 和 B；

Subtask $2 \sim 3$：仅具有特殊性质 A；

Subtask $4 \sim 5$：仅具有特殊性质 B；

Subtask $6 \sim 10$：不具有任何一个特殊性质。

特殊性质 A：对于所有西瓜，均满足 $t1=1,t2=T+1$。
所有西瓜全程都静止在原地，不会发生移动。

特殊性质 B：$m=0$。

对于全部子任务，满足：

$1 \le x \le w,1 \le y \le h$

$1\le n \le 20,
0 \le m \le 10,
m \le n$

$1 \le h,w \le 5,
1 \le T \le 100,
1 \le t1 \le T,
2 \le t2 \le T+1,
t1< t2$


保证一个位置不会同时出现两个或两个以上西瓜。

## 样例 #1

### 输入

```
5 5 10 3 3
1 1
1 11
1
3 4
5 2
3 5
1 1
5 4
3 4
2 1
1 1
1 1
5 5```

### 输出

```
1```

# 题解

## 作者：lwyz123 (赞：10)

最短路作为广为人知的算法，肯定不可能考模板的啦（~~毒奶一口~~）

### 今天看到p3786 萃香抱西瓜： 

前两天的胡策题，(~~毒瘤出题人,根本不理解！！！~~）

在一天半之后，我终于" 做 "掉了他;

其实呢这个题并不是多么毒瘤，看到h ,w 只有5！！！, 需要杀的人小于10个！！

你有什么想法呢！！

状压就完了

### 主题思路： 状压+spfa；

关键变量：

dis[x][y][t][S]
//前三维不多说最后一维记状态；
有了这个！！
你也可以想到vis数组的魔改版；
vis[x][y][t][s];

这个思路呢你可以去做做
（bfs好题[p1301 魔鬼之城](https://www.luogu.org/problem/P1301)）

空间够大就用空间来换时间!!!

并且还能保证你答案的正确性！！

血赚不亏；

剩下的需要一个map[x][y][t] 来记录点

注意不能抱走的西瓜 我们可以定义一个wm_big随便开一个值只要不会和小西瓜重复

剩下的可以抱走的西瓜就可以按照输入的顺序来编号cnt  

然后map[x][y][t]=(1<<(cnt-1))

注意位运算的顺序

剩下的就可以根据楼上神仙们的题解代码来理解了
我就不贴了；


---

## 作者：s_a_b_e_r (赞：6)

##状态压缩+spfa

考虑到西瓜的数量很少,可行的西瓜m<=10;对于每一个需要拿走的西瓜我们给他一个重新的编号0~m-1;对这m个西瓜用一个单独没有出现过的二进制的一位表示。于是拿走西瓜并判断以前有无拿过这个西瓜就是当前已经拿的状态now或**( | )**当前西瓜所在的二进制位,所得的数就是当前拿到西瓜的状态。

对于没有西瓜的位置当前位置是0(当前数**或(|)**0还是他本身),走到没有西瓜的位置对当前答案没有贡献。


###转移

用dis[i][j][t][now]表示当前所在点(i,j)时间为t,当前已拿到西瓜的状态为now,当前的西瓜用x表示``(x=1<<y)y是重新分配后当前西瓜的编号``

- 1.当前点的状态是now,当前所在点下一秒有一个西瓜,于是就有dis[i][j][t+1][now|x]=dis[i][j][t][now](没西瓜x=0)

- 2.当前点的状态是now,要到达的地点(to\_x,to\_y)上有一个可获得的西瓜(x),那么到达这个点的转移是dis[to\_x][to\_y][t+1][now|x]=dis[i][j][t][now]+1

- 3.当前点的状态是now,要到达的地点(to\_x,to\_y)上有一个不可获得的西瓜,那么这个点不能转移.

- 4.当前点的状态是now,要到达的地点(to\_x,to\_y)没有西瓜,dis[to\_x][to\_y][t+1][now]=dis[i][j][t][now]+1

- 这样通过上面的4步就可以使在当前状态合法,~~不用考虑后续~~


于是想到可行的状态很少,就可以采用bfs,来实现转移优化,spfa,从(sx,sy)开始把当前状态&时间,当前所到的点压成结构体放进队列.最后拿到所有西瓜的状态就是dis[1~h][1~w][T][(1<<m)-1]

因为用到了spfa,所以最终得到的一定是最小的答案。

特殊的,当初始点有一个不可获得的西瓜时或最后得到的答案是INF,输出-1。(不可到达)

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstring>
#include<queue>
#define ll long long
const int Suika_big=2333333;
const int maxx=1<<20;
using namespace std;
const int tx[6]={0,0,0,1,-1};
const int ty[6]={0,1,-1,0,0};
inline int read(){
    int an=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while('0'<=ch&&ch<='9'){an=(an<<3)+(an<<1)+ch-'0';ch=getchar();}
    return an*f;
}
int map[7][7][109],dis[7][7][109][1<<12];
int n,m,h,w,sx,sy,T,cnt;
int ans=maxx;
bool flag;
bool vis[7][7][109][1<<12];
void prepare(){
    h=read();w=read();T=read();sx=read();sy=read();
    n=read();m=read();
    for(int i=1;i<=n;i++){
        int xx;
        int t1=read(),t2=read(),Suika_p=read();
        if(Suika_p)cnt++,xx=1<<cnt-1;
        else xx=Suika_big;
        for(int j=t1;j<=min(T,t2-1);j++){
            int x=read(),y=read();
            map[x][y][j]=xx;
        }
    }
    if(map[sx][sy][1]==Suika_big){
        cout<<"-1";flag=1;return;
    }
    for(int i=0;i<=h;i++)
    for(int j=0;j<=w;j++)
    for(int t=1;t<=T;t++)
    for(int l=0;l<=(1<<m);l++)
    dis[i][j][t][l]=maxx;
}
struct saber{
int x,y,Suika,t;
}now;
queue<saber>q;
void spfa(){
    q.push((saber){sx,sy,map[sx][sy][1],1});
    dis[sx][sy][1][map[sx][sy][1]]=0;
    while(!q.empty()){
        now=q.front();q.pop();
        vis[now.x][now.y][now.t][now.Suika]=0;
        if(now.t>T)continue;
        for(int i=0;i<=4;i++){
            int xx=now.x+tx[i];
            int yy=now.y+ty[i];
            int melon=now.Suika;
            if(xx<1||yy<1)continue;
            if(xx>h||yy>w)continue;
            int t=now.t+1;
            if(map[xx][yy][t]==Suika_big)continue;
            int diss=dis[now.x][now.y][now.t][now.Suika]+(i!=0);
            melon|=map[xx][yy][t];
            if(dis[xx][yy][t][melon]>diss){
                dis[xx][yy][t][melon]=diss;
                if(!vis[xx][yy][t][melon]){
                    q.push((saber){xx,yy,melon,t});
                    vis[xx][yy][t][melon]=1;
                }
            }
        }
    }
}
int main(){
    prepare();
    if(flag){return 0;}
    spfa();
    for(int i=1;i<=h;i++)
        for(int j=1;j<=w;j++)
        ans=min(ans,dis[i][j][T][(1<<m)-1]);
    if(ans==maxx)cout<<"-1";
    else cout<<ans;
    return 0;
}
```
~~似乎出题人没有考虑到站的初始位置有一个小西瓜的点,被没考虑的同学过去了,膜拜出题人~~


---

## 作者：老莽莽穿一切 (赞：4)

[更好的阅读体验](https://www.cnblogs.com/LaoMang-no-blog/p/15379823.html)

**算法：状压 + 三维 bfs**

这道题目虽然顶着紫题的名头，但是难度却只有黄题或绿题左右，思维和码量都适中，可以作为普转提的题目来刷。

通过观察数据规模，我们可以发现整个数据规模很小，地图和时间都只有 $100$ ，要拿的西瓜只有 $10$ 个，所以我们可以思考二进制状压存储某个西瓜有没有被拿过。

观察题面，把时间转化成一维存起来，发现这道题是一道三维最短路，其中边权只有 $0$（原地等待）和 $1$（向四个方向移动），所以可以很自然地想到双端队列 bfs 解决，接下来这道题就解决了。

### 复杂度分析

bfs 的复杂度取决于状态数，本题状态开了四维，分别是一维时间，两维地图，再加一维状压表示西瓜有没有拿过，但因为大西瓜阻挡等因素，不一定跑满，所以时间复杂度就是 $\text{O}(nms\cdot2^{c_2})$ ，空间复杂度是 $\Theta(nms\cdot2^{c_2})$

[c++ 代码](https://www.cnblogs.com/LaoMang-no-blog/p/15379823.html)

---

## 作者：orangebird (赞：3)

子任务1:所有西瓜始终出现且不动，并且没有要抱走的。

解法:只需要判断初始位置是否被大西瓜挡住，挡住输出-1，否则输出0即可

子任务2~3:所有西瓜始终出现且不动。

解法:由于要抱走的西瓜最多为10个，考虑用长度为10的0/1串来表示某个西瓜是否已经获取。状压spfa或dp即可解决。

子任务4~5:没有需要抱走的西瓜

解法:将时间看做一个维度，构建好三维的地图，把西瓜看做障碍，做三维的最短路或dp即可。

正解:

结合子任务2~3和4~5的做法，做一个四维的状压最短路或dp即可解决。

代码:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
int mp[6][6][103];
int dis[6][6][103][1024];
bool vis[6][6][103][1024];
const int dx[5]={0,1,-1,0,0};
const int dy[5]={0,0,0,1,-1};
int my,mx,T,sx,sy;
int n,m;
```
/\*0x3f3f3f3f empty
233 big melon

0~m-1 small melon

\*/
```cpp
int cnt=-1;
queue<int>q;
void spfa()
{
    q.push(1*100+sx*10+sy);
    memset(dis,0x3f,sizeof(dis));
    dis[sx][sy][1][0]=0;
    while(!q.empty())
    {
        int now=q.front();
        q.pop();
        int nows=now/100000;
        int nowt=(now%100000)/100;
        int nowx=(now%100)/10;
        int nowy=now%10;
        //cout<<nowx<<" "<<nowy<<" "<<nowt<<" "<<nows<<endl;
        vis[nowx][nowy][nowt][nows]=0;
        if(nowt==T)continue;
        for(int f=0;f<5;++f)
        {
            int nexx=nowx+dx[f];
            int nexy=nowy+dy[f];
            int next=nowt+1;
            int nexs;
            if(nexx<1||nexx>mx)continue;
            if(nexy<1||nexy>my)continue;
            if(mp[nexx][nexy][next]==233)continue;
            if(mp[nexx][nexy][next]==0x3f3f3f3f)nexs=nows;
            else nexs=nows|(1<<mp[nexx][nexy][next]);
            if(dis[nexx][nexy][next][nexs]<=dis[nowx][nowy][nowt][nows]+!!f)continue;
            dis[nexx][nexy][next][nexs]=dis[nowx][nowy][nowt][nows]+!!f;
            if(!vis[nexx][nexy][next][nexs])
            {
                vis[nexx][nexy][next][nexs]=true;
                q.push(nexs*100000+next*100+nexx*10+nexy);
            }
        }
    }
}
int main()
{
    scanf("%d%d%d%d%d",&my,&mx,&T,&sx,&sy);
    scanf("%d%d",&n,&m);
    memset(mp,0x3f,sizeof(mp));
    for(int i=1;i<=n;++i)
    {
        int t1,t2,a;
        scanf("%d%d",&t1,&t2);
        scanf("%d",&a);
        if(a==0)a=233;
        else a=++cnt;
        for(int i=t1;i<t2;++i)
        {
            int x,y;
            scanf("%d%d",&x,&y);
            mp[x][y][i]=a;
        }
    }
    if(mp[sx][sy][1]==233)
    {
        printf("-1\n");
        return 0;
    }
    spfa();
    int ans=0x3f3f3f3f;
    for(int i=1;i<=mx;++i)
        for(int j=1;j<=my;++j)
            ans=min(ans,dis[i][j][T][(1<<m)-1]);
    if(ans==0x3f3f3f3f)ans=-1;
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Kazdale (赞：2)

做法：记忆化搜索（填表法 DP）

- ## 确定状态

	首先看到求最少移动次数，就容易想到 DP，接下来就是确定状态。
    
    非常显然地，我们的状态中会有 $x$，$y$ 两维表示萃香当前的位置。
    
    然而，西瓜的位置会随着时间 $t$ 的变化而变化，显然时间也有关，将时间加入状态。
    
    同时，我们可能多次遇见同一个小西瓜，所以我们想要知道每一个小西瓜是否已经拿了，看到 $0\leq m\leq10$ 的数据范围，不难想到状压。
    
    于是我们确定了状态 $f_{xg,t,x,y}$ 表示 $t$ 时刻，萃香在 $(x, y)$ 位置上，已经拿走的小西瓜状态为 $xg$ 所需的最少移动次数。
    
    所以答案为 $\min_{i=1}^{h}\min_{j=1}^{w}\;f_{2^{m}-1, T, i, j}$。
    
    总时间复杂度为 $\mathcal{O(2^{m}Thw + Tn)}$，总空间复杂度为 $\mathcal{O(2^{m}Thw)}$，两者的值均约在 $2e6$ 左右，可以通过本题。

- ## 确定转移

	首先萃香在位置上有五种变化，不动，向上，向下，向左，向右（除了不动外剩下四种状态在转移时都要将步数加 $1$）。
    
    时间自然为当前时间的前一刻，即 $t - 1$。
    
    考虑 $xg$ 的变化，不难发现，若设 $xg'$ 为 $xg$ 的子集，那么对于 $\forall xg$，都有 $f_{xg,t,x,y} \geq f_{xg',t,x,y}$。
    
    很好证明，因为对于子集 $xg'$ 来说要捡的小西瓜相较于 $xg$ 更少，有些不需要捡的小西瓜不需要再做额外的移动。
    
    所以若当前位置有小西瓜，我们可以直接定义上一个状态的 $xg$ 为没有捡起这个小西瓜的状态，因为这样必定不亏。
    
    设当前位置的西瓜状态为 $ml$，不难想到，上一个状态的小西瓜状态 $xg'$ 为 $xg \operatorname{and} (xg \operatorname{xor} ml)$（异或消掉当前位置上的小西瓜，取与消去异或后出现的多余的 $1$）。
    
	转移方程为 $f_{xg,t,x,y} = \min(f_{xg',t-1,x,y},f_{xg',t-1,x-1,y}+1,f_{xg',t-1,x,y-1}+1,f_{xg',t-1,x+1,y}+1,f_{xg',t-1,x,y+1}+1)$，需要注意第 $1$ 个时刻萃香无法移动，只能向 $f_{xg',t-1,x,y}$ 转移。
    
- ## 确定边界

	首先设 $f_{0,0,sx,sy}$ 为初始状态，赋值成 $0$，将 $t$ 设为 $0$ 是因为会出现第 $1$ 个时刻位置上出现大小西瓜的特殊情况。
    
    然后设剩下所以 $t=0$ 以及在当前的时间当前位置存在大西瓜的情况为非法情况，赋值成 INF，同时 $ans$ 的初值也赋值成 INF。
    
    若记忆化搜索逐个取 $\min$ 后 $ans$ 仍为 INF，则说明无解，输出"-1"。

- ## 代码

```cpp
#include <iostream>
using namespace std;
constexpr int INF(0x3f3f3f3f);
int f[1077][107][7][7], vis[1077][107][7][7];
int dg[107][7][7], ml[107][7][7];
int h, w, T, sx, sy;
int n, m, cnt;
int maxn, ans = INF;
inline void read(int &temp) { cin >> temp; }
int dfs(int xg, int t, int x, int y) {
	if (vis[xg][t][x][y])  return f[xg][t][x][y];
	vis[xg][t][x][y] = 1;
	if (dg[t][x][y])  return f[xg][t][x][y] = INF;
	if (!xg && !t && x == sx && y == sy)  return f[xg][t][x][y] = 0;
	if (!t)  return f[xg][t][x][y] = INF;
	f[xg][t][x][y] = INF;
	int lst = (xg & (xg ^ ml[t][x][y]));
	f[xg][t][x][y] = min(f[xg][t][x][y], (vis[lst][t - 1][x][y] ? f[lst][t - 1][x][y] : dfs(lst, t - 1, x, y)));
	if (x > 1 && t > 1)  f[xg][t][x][y] = min(f[xg][t][x][y], (vis[lst][t - 1][x - 1][y] ? f[lst][t - 1][x - 1][y] : dfs(lst, t - 1, x - 1, y)) + 1);
	if (y > 1 && t > 1)  f[xg][t][x][y] = min(f[xg][t][x][y], (vis[lst][t - 1][x][y - 1] ? f[lst][t - 1][x][y - 1] : dfs(lst, t - 1, x, y - 1)) + 1);
	if (x < h && t > 1)  f[xg][t][x][y] = min(f[xg][t][x][y], (vis[lst][t - 1][x + 1][y] ? f[lst][t - 1][x + 1][y] : dfs(lst, t - 1, x + 1, y)) + 1);
	if (y < w && t > 1)  f[xg][t][x][y] = min(f[xg][t][x][y], (vis[lst][t - 1][x][y + 1] ? f[lst][t - 1][x][y + 1] : dfs(lst, t - 1, x, y + 1)) + 1);
	return f[xg][t][x][y];
}
int main() {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	read(h), read(w), read(T), read(sx), read(sy);
	read(n), read(m);
	for (int i(1), op, ed, tp; i <= n; ++i) {
		read(op), read(ed), read(tp);
		if (tp == 1)  ++cnt;
		for (int j(op), x, y; j < ed; ++j) {
			read(x), read(y);
			if (!tp)  dg[j][x][y] = 1;
			else  ml[j][x][y] |= (1 << (cnt - 1));
		}
	}
	maxn = (1 << m) - 1;
	for (int i(1); i <= h; ++i)
		for (int j(1); j <= w; ++j)  ans = min(ans, dfs(maxn, T, i, j));
	if (ans == INF)  return cout << "-1" << endl, 0;
	return cout << ans << endl, 0;
} 
```


---

## 作者：Yansuan_HCl (赞：0)

每个时刻每个西瓜都不一样，所以要分别处理。显然可以状压当前已经抱走了哪些西瓜，于是 dp 即可。状压的时候，要处理当前位置上有西瓜的情况，要抱走。

$$f[t][x][y][S | 2^{m[x][y]}]=\min \{ f[t-1][dx][dy][S]+1,  f[t-1][x][y][S] \} $$

```cpp
int dp[105][6][6][1 << 10];
int flag[105][6][6];
int h, w, T, sx, sy;
int n, m;
const int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};

int main() {
    ms(dp, 0x3f); ms(flag, 0xc0);
    rd(h, w, T, sx, sy, n, m);
    int mCnt = 0;
    U (i, 1, n) {
        int t1, t2, a; rd(t1, t2, a);
        U (j, t1, t2 - 1) {
            int x, y; rd(x, y);
            flag[j][x][y] = a ? mCnt : -1;
        }
        mCnt += a;
    }
    dp[1][sx][sy][0] = 0 | ((flag[1][sx][sy] >= 0) ? (1 << (flag[1][sx][sy])) : 0);
    U (t, 2, T) U (x, 1, w) U (y, 1, h) if (flag[t][x][y] != -1) 
        U (s, 0, (1 << m) - 1) {
            int cs = s | ((flag[t][x][y] >= 0) ? (1 << flag[t][x][y]) : 0);
            dp[t][x][y][cs] = min(dp[t][x][y][s], dp[t - 1][x][y][s]);
            U (i, 0, 3) {
                int cx = x + dx[i], cy = y + dy[i];
                if (cx < 1 || cy < 1 || cx > w || cy > h) continue;
                dp[t][x][y][cs] = min(dp[t][x][y][cs], dp[t - 1][cx][cy][s] + 1);
            }
        }
    int ans = 0x3f3f3f3f;
    U (x, 1, w) U (y, 1, h)
        ans = min(ans, dp[T][x][y][(1 << m) - 1]);
    printf("%d", (ans == 0x3f3f3f3f) ? -1 : ans);
    return 0;
}
```

[~~随便写写就冲到最优解榜二了。~~](https://www.luogu.com.cn/record/77870423)

---

## 作者：Zxsoul (赞：0)

## 题面 
- 一个 $w\times h$ 的矩阵，矩阵中存在可移动的 $0$ 点 和 $1$ 点

- $0$点不可到达，$1$ 可到达

- 给定一个起点 $(sx,sy)$, 求给定时间 $T$ 内可到达 $m$ 个  $1$ 所用的最小步数

## 数据范围
>> $1\le h,\  w\le 5,\  1\le T\le 100,\ 1\le t1\le T$
>> 
>> $2\le t,\ 2\le T+1,\ t1<t2$
>> 
>> $1\le n\le 20,\ 0\le m\le 10,\ m\le n$

## 思路
- 数据范围不大，可以状压$DP$

- 用二进制数表示当前已有西瓜的状态，转移时就需要位运算 

- $$f[t][i][j][k]$$ 

- 表示在 $T$ 时刻,坐标为（$i ,j$）点上已经获得 $k$ 个西瓜的最小步数

- 我们可用以个 $s[t][i][j]$ 记录 $T$ 时刻,坐标为（$i ,j$) 点上可获得西瓜的数量

- 因此就可方程转移啦

- $$f[t][i][j][k \ |\  s[t][i][j]] = min{(f[t - 1][qx][qy][k])+1}$$

-  ($qx\ qy$)表示 $T - 1$ 时刻的位置

- 字面上说，当前状态是由$f[t-1][i][j][k]$状态 $+1$ 转移来的

- 初始状态是$f[1][sx][sy][s[1][sx][sy]]\ =\ 0$,其他为 $INF$

## Code
```cpp
#include <iostream>
#include <cstdio>
#include <string.h>
using namespace std;
typedef long long ll;
const int inf = 0x3f3f3f3f;
inline int read() {
  char c = getchar(); int x = 0, f = 1;
  for ( ; !isdigit(c); c = getchar()) if (c == '-') f = -1;
  for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
  return x * f;
}
int sum,h,w,t,sx,sy,n,m,t1[manx],t2[manx];
int dx[5] = {0, 0, 0, 1, -1};
int dy[5] = {0, 1, -1, 0, 0};
int s[109][10][10],f[109][10][10][(1 << 10) + 1];
int main(){
	h = read();w = read();t = read();sx = read();sy = read();n = read();m = read();
	//预处理部分 
	for(int i = 1;i <= n; i++){
		t1[i] = read();t2[i] = read();
		int p = read();
		if(p) sum ++;
		for(int j = t1[i];j < t2[i]; j++){
			int x = read(),y = read();
			if(p == 0) s[j][x][y] = -1;//只要当前时间（x,y）有一个是大西瓜，那么这个格子就不能走 
			else s[j][x][y] = 1 << (sum - 1);//-1的原因同下 
		} 
	}
	if(s[1][sx][sy] == -1){cout<<-1;return 0;} //特判：落地成盒 
	ll bz = (1 << m) - 1;//10000000000(10) - 1=111111111(9)
	memset(f, 0x3f, sizeof (f)); //初始化 
	f[1][sx][sy][s[1][sx][sy]] = 0;//初始化 
	//正解开始 
	for(int i = 2; i <= t;i ++) 
		for(int x = 1;x <= w;x ++)
			for(int y = 1; y <= h;y ++){
				if(s[i][x][y] == -1) continue;
				for(int j = 0;j <=4; j++){
					int qx = x + dx[j],qy = y + dy[j];
					if(qx < 1||qy > h||qy < 1|| qx > w) continue;
					if(s[i - 1][qx][qy] == -1) continue; 
					for(int k = 0;k <= bz;k ++){
						f[i][x][y][k | s[i][x][y]] = min(f[i][x][y][k | s[i][x][y]],
													   f[i - 1][qx][qy][k] + (j > 0)); //转移方程式 
					}
				}
			}
	int ans = f[0][0][0][0];
	for(int x = 1;x <= w; x ++)
		for(int y = 1;y <= h; y++){
	 		ans = min(ans,f[t][x][y][bz]); //枚举满足条件的f 
		 } 
	if(ans < inf) cout<<ans;
	else cout<<-1;			
	return 0;
}


```


---

## 作者：红尘仙 (赞：0)

## 疑点解释：

1.考试的时候做到了，考试的时候我想到了状态压缩$DP$，然后我觉得，西瓜的状态我就多设一维来表吧，好理解，还容易推状态转移方程（然而，我并没有推出来，只好打了个暴力，骗了点分）

2.首先说一下为什么不能多设一维表示状态，按学长的话，就是多设一维的后对答案没有贡献，只是判断了下一个点是能够走罢了

##   解题思路：
1.我们对西瓜进行状态压缩，然后我们设一个all将m转化成状态压缩，然后我们在读入的时候，进行一下预处理，预处理的就是类似于画一个地图 $s$,然后$s_{t,x,y}$就表示在t时刻,坐标为$（x,y）$的西瓜的存在状态；

 2.同时我们设一个 $f_{time,x,y,sum}$表示t时刻，到坐标$（x,y）$取得sum个西瓜的最小的步数
 
 3.同时我们所求的为最短路径，那么我们也就可以直接将$f$预处理为最大值，既能跑最短路还能判断一下是否能得到 $m$个西瓜，自然要是$ans==inf$ 那就代表走不了，（既包含不能得到$m$个西瓜，也包含无路可走的情况（一样，无路可走也就没办法获得$m$个西瓜了））

4.转移时枚举每个时刻每个位置，从能到达该位置的上个时刻的位置 (x′,y′) 转移过来，还需要枚举上个位置的小西瓜状态;

所以状态转移方程就出来了：
### $f_{t,x,y, s| s_{t,x,y}}=min{f_{t-1,x',y's}+1}$;

代码：
```
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <cstring>
#define LL long long
const int maxn = 1024 + 1;
const int inf = 0x3f3f3f3f;
const int dx[5] = {0, 0, 0, 1, -1};
const int dy[5] = {0, 1, -1, 0, 0};
int h, w, t, sx, sy;
int n, m, all, t1, t2;
int f[101][10][10][maxn];
int sum, s[101][10][10];
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){ if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){ x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
void swapmin(int &a, int b) 
{
  if (b < a) a= b;
}
void prepare() 
{
  h = read(), w = read(), t = read();
  sx = read(), sy = read();
  n = read(), m = read();
  for (int i = 1; i <= n; ++ i) 
  {
    t1 = read(), t2 = read();
    int type = read();
    if (type) sum ++;
    for (int j = t1; j < t2; ++ j) 
	{
      int x = read(), y = read();
      if(type)
      {
      	s[j][x][y]=(1<<(sum-1));
	  }
	  else 
	  {
	  	s[j][x][y]=-1;
	  }
    }
  }
}
int main() 
{
  prepare();
  if (s[1][sx][sy] == -1) 
  {
    printf("-1");
    return 0;
  }
  
  all = (1 << m) - 1;
  memset(f, 0x3f, sizeof (f));
  f[1][sx][sy][s[1][sx][sy]] = 0;
  for (int i = 2; i <= t; ++ i) 
  {
    for (int x = 1; x <= w; ++ x) 
	{
      for (int y = 1; y <= h; ++ y) 
	  {
        if (s[i][x][y] == -1) continue ;
        for (int j = 0; j <= 4; ++ j) 
		{
          int fx = x + dx[j], fy = y + dy[j];
          if (fx < 1 || fx > w || fy < 1 || fy > h) continue ;
          if (s[i - 1][fx][fy] == -1) continue ;
          for (int k = 0; k <= all; ++ k) 
		  {
			  	swapmin(f[i][x][y][k | s[i][x][y]],f[i - 1][fx][fy][k]+(j>0));
			  //否则就是原地不动， 
          }
        }
      }
    }
  }
  
  int ans = f[0][0][0][0];
  for (int x = 1; x <= w; ++ x) 
  {
    for (int y = 1; y <= h; ++ y) 
	{
      swapmin(ans, f[t][x][y][all]);
    }
  }
  printf("%d\n", ans < inf ? ans : -1);
  return 0;
}
```

---

## 作者：S_S_H (赞：0)

### 又是一道很好的练状压DP的题

题目大意就是有一个人，他需要抱走全部m个西瓜，但是还有n-m个西瓜不可以抱，需要躲避。题目会给出你在每个时刻时西瓜的位置，而这个人每个时刻可以选择不动或向周围四个方向移动。

现给定你初始位置，求t时刻后他能不能抱走所有西瓜？如果能就输出最少操作次数。

数据范围地图1<=x,y<=5,0<=m<=10,1<=n<=20，1<=t<=100

是不是数据范围极小！！！

正常情况下记忆化搜索+DP或状压DP或优化的最短路+DP都是可以的

但是归根结底，状态转移方程是一样的

因为有t时刻，还要记录每个时刻的位置与状态

所以dp[i][j][t][s]应然而生

他表示t时刻到(i,j)这个位置已取过的西瓜状态为s的最短路

记得是已取过的西瓜！！！n-m个需要躲避的大西瓜不需要取，也就不需要状压，我们只需在转移的时候在地图上判断一下就好了

状态转移方程也很好想，

dp[ i ][ j ][ t ][ s ] = min(dp[ i-p ][ j-q ][ t-1 ][ s^k ])

其中p={ 0 , -1 , 1 , 0 , 0 };

相应q={ 1 , 0 , 0 , 1 , -1 , 1};

k∈s且map[i-p][j-q]=k,也就是有k号西瓜可以取

代码实现部分可以考虑用纯O(h×w×t×(1<<10))暴力DP可以实现

（本人就是这么做的）

或s_a_b_e_r 大佬的SPFA转移也是一样的，因为数据范围小

好了不多说，代码部分（s_a_b_e_r大佬队列式）：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#define ll long long
using namespace std;
struct node{
	int x,y,num,t;
}now;
queue<node>q;
const int inf=0x3f3f3f3f;
const int tx[6]={0,0,0,1,-1};
const int ty[6]={0,1,-1,0,0};
int map[10][10][110],dp[10][10][110][(1<<11)-1];
int n,m,h,w,sx,sy,T,cnt,d,t1,t2,ans=inf;
bool vis[10][10][110][(1<<11)-1],flag;
int main(){
    scanf("%d%d%d%d%d%d%d",&h,&w,&T,&sx,&sy,&n,&m);
    for(int i=1;i<=n;i++){
        int f;
        scanf("%d%d%d",&t1,&t2,&d);
        if(d) f=1<<((++cnt)-1);
        else f=-1;
        for(int j=t1;j<=t2-1;j++){
            int x,y;
            scanf("%d%d",&x,&y);
            map[x][y][j]=f;
        }
    }
    if(map[sx][sy][1]==-1){
    	printf("-1");
		return 0;
    }//起始点特判
    for(int i=1;i<=h;i++)
    	for(int j=1;j<=w;j++)
    		for(int t=1;t<=T;t++)
    			for(int k=0;k<=(1<<m);k++)
    				dp[i][j][t][k]=inf;
	q.push((node){sx,sy,map[sx][sy][1],1});
	dp[sx][sy][1][map[sx][sy][1]]=0;
	while(!q.empty()){
        now=q.front();q.pop();
        vis[now.x][now.y][now.t][now.num]=0;
        if(now.t>T) continue;
        for(int i=0;i<5;i++){
            int xx=now.x+tx[i];
            int yy=now.y+ty[i];
            int melon=now.num;
            if(xx<1||xx>h||yy<1||yy>w)continue;
            int t=now.t+1;
            if(map[xx][yy][t]==-1)continue;
            int dis=dp[now.x][now.y][now.t][now.num]+(i!=0);
            melon|=map[xx][yy][t];
            if(dp[xx][yy][t][melon]>dis){
                dp[xx][yy][t][melon]=dis;
                if(!vis[xx][yy][t][melon]){
                    q.push((node){xx,yy,melon,t});
                    vis[xx][yy][t][melon]=1;
                }
            }
        }
    }   
	for(int i=1;i<=h;i++)
        for(int j=1;j<=w;j++)
        	ans=min(ans,dp[i][j][T][(1<<m)-1]);
    if(ans==inf) printf("-1");
    else printf("%d",ans);
    return 0;
}
```

自己写的纯暴力转移代码：

```cpp
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;
const int inf=0x3f3f3f3f;
const int tx[6]={0,0,0,1,-1};
const int ty[6]={0,1,-1,0,0};
int map[10][10][110],dp[10][10][110][(1<<11)-1];
int n,m,h,w,sx,sy,T,cnt,d,t1,t2,ans=inf;
int main(){
    scanf("%d%d%d%d%d%d%d",&h,&w,&T,&sx,&sy,&n,&m);
    for(int i=1;i<=n;i++){
        int f;
        scanf("%d%d%d",&t1,&t2,&d);
        if(d) f=1<<((++cnt)-1);
        else f=-1;
        for(int j=t1;j<=t2-1;j++){
            int x,y;
            scanf("%d%d",&x,&y);
            map[x][y][j]=f;
        }
    } 
    if(map[sx][sy][1]==-1){
    	printf("-1");
		return 0;
    }
    for(int i=1;i<=h;i++)
    	for(int j=1;j<=w;j++)
    		for(int t=1;t<=T;t++)
    			for(int k=0;k<=(1<<m);k++)
    				dp[i][j][t][k]=inf;
	dp[sx][sy][1][map[sx][sy][1]]=0;
	for(int t=1;t<T;t++){
		for(int i=1;i<=h;i++){
			for(int j=1;j<=w;j++){
				for(int s=0;s<=(1<<m)-1;s++){
					if(dp[i][j][t][s]!=inf){
						for(int k=0;k<5;k++){
							int kx=i+tx[k];
							int ky=j+ty[k];
							if(kx>h||kx<1||ky>w||ky<1) continue;
							if(map[kx][ky][t+1]==-1) continue;
							dp[kx][ky][t+1][s|map[kx][ky][t+1]]=min(dp[kx][ky][t+1][s|map[kx][ky][t+1]],dp[i][j][t][s]+(k!=0));
                            				//以每一个可以转移的点向四个方向转移，记得如果没动路程不需要+1，tx[k]=ty[k]=0;
						}
					}
				}
			}
		}
	}
	for(int i=1;i<=h;i++)
        for(int j=1;j<=w;j++)
        	ans=min(ans,dp[i][j][T][(1<<m)-1]);
    if(ans==inf) printf("-1");
    else printf("%d",ans);
    return 0;
}
```
### 最后祝愿大家2019CSP  NOI XXXXOI RP++! ! !


---


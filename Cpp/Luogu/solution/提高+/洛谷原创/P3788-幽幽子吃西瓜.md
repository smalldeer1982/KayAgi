# 幽幽子吃西瓜

## 题目背景

 ![](https://cdn.luogu.com.cn/upload/pic/5575.png) 

西行寺幽幽子是冥界的亡灵，她是一个标准的吃货，现在她的面前摆着一个妖梦替她准备的大西瓜。


## 题目描述

妖梦费了好大的劲为幽幽子准备了一个大西瓜，甚至和兔子铃仙打了一架。现在妖梦闲来无事，就蹲在一旁看幽幽子吃西瓜。西瓜可以看作一个标准的球体，瓜皮是绿色的，瓜瓤是红色的，瓜皮的厚度可视为0。妖梦恰好以正视的角度看着这个西瓜。幽幽子是一个吃货，妖梦一走神，自己背后的刀就不见了，而西瓜也被切掉了一块。幽幽子切西瓜时刀面始终垂直于桌面，并且切下的一块在俯视图中正好是一个以西瓜中心为顶点，半径为西瓜半径的扇形。如图所示，是一种满足条件的情况

俯视:

 ![](https://cdn.luogu.com.cn/upload/pic/5576.png) 

正视:

 ![](https://cdn.luogu.com.cn/upload/pic/5577.png) 

妖梦看着红红绿绿的西瓜，忽然陷入思考，红色的西瓜瓤占整个西瓜可视面积的百分之多少呢？但她对几何一窍不通，于是想问问幽幽子，但幽幽子正抱着切下来的西瓜大吃特吃，没有理会妖梦。于是她想让你来帮她解决这个问题。

为了方便描述问题，我们为俯视图建立一个平面极坐标系，极点在俯视图圆形(扇形)的正中央，极轴方向竖直向下。极轴所对应的角度为0度，角度逆时针依次增加，直到转一圈又回到极轴。因此角度范围是[0,360)。幽幽子会切掉西瓜从a°到b°的这一整块。


## 说明/提示

样例说明:

第一个样例中，切掉的西瓜恰好在背面，在妖梦的角度看起来与未切过的西瓜并无区别，因此输出0%。第二个样例中，切掉了从315°~45°这一部分,经过计算，得到答案为sqrt(2)/2，化成小数得到0.707,即70.7%

本题目共有10个测试点。

对于第1个测试点，a,b∈{0,90,180,270}。

对于第2个测试点，270<=a<=359,0<=b<=90。

对于第3,4个测试点，180<=a<=359,0<=b<=179。

对于全部测试点，0<=a,b<=359,a≠b。

1<=T<=10000

命题人:orangebird


## 样例 #1

### 输入

```
2
90 270
315 45```

### 输出

```
0.0%
70.7%```

# 题解

## 作者：离散小波变换° (赞：10)

$\texttt{upd 2021.6.14}$ ：修了一点排版。

## 题目大意

> 有一个 $\stackrel{\texttt{suika}}{\small\textsf{西瓜}}$ 。现在挖去俯视图上 $[a\degree,b\degree]$ 这一块（特别地，若 $a>b$ ，则是挖去 $[a\degree,360)\cap[0,b]$），询问主视图中红色部分占可见部分的比例。  
> $T$ 组数据。 $1\le T\le 10^4;0\le a,b<360$ 且 $a,b\in \Bbb{Z};a\neq b$ 。

## 题解

### 前置知识

由于我们要求出看到的西瓜的面积，所以把切面转换到主视图非常重要。

> 令投射线通过点或其他物体，向选定的投影面投射，并在该面上得到图形的方法称为投影法。  
> $$\kern{1pt}\tag*{\small\text{——百度百科}}$$  
> 考虑这样的图形：  
> ![](https://cdn.luogu.com.cn/upload/image_hosting/5ckgpxft.png)  
> 这就是一个非常简单的将直线投影到 $x$ 轴上的例子。

我们要做的就是把一个圆投影到平面上，并且计算出它的面积。关于投影，有一个非常重要的结论：**投影后的图片的面积，就是投影前的面积乘上夹角的余弦值**。显然这个结论对于矩形成立，而我们可以类比微分，把一个圆分成无数个矩形再分别投影。因此我们根据俯视图上，一个圆与主视图的夹角就可计算出这个圆在主视图上的面积。

此外，下文还会用到**弧度制**。在角度制里，一个完整的圆对应的度数是 $360\degree$，而弧度制里这个值是 $2\pi$。将角度制转换为弧度制非常简单，对于角度制下的数值 $a$ ，转换为弧度制就是 $\dfrac{a}{360}\times 2\pi=\dfrac{a}{180}\pi$。

在讨论各种复杂情况之前，我们先考虑一个更加简单的问题，也就是 $a,b\in[0,180)$ 的情况，并且我们**仅考虑主视图右半部分**。这种情况同样可以细分分为两类，每类三种。在下文中，我们认为西瓜的半径为 $1$，这显然不会影响答案。

- **第一类**： $a<b$ 。观察下面三张图：  
![](https://cdn.luogu.com.cn/upload/image_hosting/s8nv0380.png)  
  - 第一种情况， $a,b\in[0,\dfrac{1}{2}\pi)$。此时可视范围是 $\dfrac{1}{2}\pi$，瓜瓢部分为 $\dfrac{1}{2}\pi(\cos(b)-\cos(a))$。
  - 第二种情况， $a\le \dfrac{1}{2}\pi\le b$。此时可视范围是 $\dfrac{1}{2}\pi\max\{\cos(a),\cos(b)\}$，瓜瓢部分是 $\max\{0,\dfrac{1}{2}\pi(\cos(b)-\cos(a))\}$。
  - 第三种情况， $a,b\in[\dfrac{1}{2}\pi,\pi)$。此时可视部分是 $\dfrac{1}{2}\pi$，看不到瓜瓢。
- **第二类**： $a>b$ 。同样地，有三张图：  
![](https://cdn.luogu.com.cn/upload/image_hosting/ispx11h8.png)  
  - 第一种情况， $a,b\in[0,\dfrac{1}{2}\pi)$。此时可视部分是 $\dfrac{1}{2}\pi \cos(b)$，瓜瓢部分是 $\dfrac{1}{2}\pi \cos(a)$。  
  - 第二种情况， $a\le \dfrac{1}{2}\pi\le b$。此时可视部分是 $\dfrac{1}{2}\pi$，瓜瓢部分是 $\dfrac{1}{2}\pi\cos(a)$。
  - 第三种情况， $a,b\in[\dfrac{1}{2}\pi,\pi)$。此时可视部分与瓜瓢部分相同，同样是 $\dfrac{1}{2}\pi\cos(a)$。
  
讨论完了这么多情况，快快封装到一个函数里吧。

---

显然，左半边的情况应当与右半边相似。我们只要想办法关于 $x$ 轴翻转即可。一般地，对于左边的角度 $\theta$，翻到右边变成 $\theta'$，应该有：

$$\theta-\pi=\pi-\theta'$$

因此 $\theta'=2\cdot \pi-\theta$。下面开始最终的讨论。

- $a,b$ 都在同一个半圆（即同在 $[0,\pi)$ 或者同在 $[\pi,2\pi)$ 内）。这个时候，对于同时处在的半圆，直接套用刚刚的大讨论。如果 $a<b$，那么另外一个半圆可视部分就是 $\dfrac{1}{2}\pi$，看不到瓜瓢；否则另外一个半圆无可视部分和瓜瓢部分。
- $a,b$ 在分别两个半圆当中。那么把这部分拆成两块，每块都相当于在一个半圆上挖去了一块，所以丢回刚刚的大讨论就行了。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
const double pi =acos(-1);
double l,r;	
void slv(double s,double t,bool f){	 //l/r
	if(t<=0.5*pi){
		if(f) l+=sin(s),r+=sin(t); else l+=(sin(t)-sin(s)),r+=1;
	}else if(0.5*pi<=s){
		if(f) l+=sin(s),r+=sin(s); else r+=1;
	} else{
		if(f) l+=sin(s),r+=1;
		else  l+=max(0.0,sin(t)-sin(s)),r+=max(sin(s),sin(t));
	}
}
int main(){
	int T; scanf("%d",&T); up(1,T,TT){
		double a,b; scanf("%lf%lf",&a,&b); l=r=0,a=pi*a/180,b=pi*b/180;
		if(a<=pi&&b<=pi){
			if(a<b) slv(a,b,0),r+=1; else slv(b,a,1);
		} else if(a>pi&&b>pi){
			if(a<b) slv(2*pi-b,2*pi-a,0),r+=1;
			else	slv(2*pi-a,2*pi-b,1);
		} else {
			if(a<b) slv(a,pi,0),slv(2*pi-b,pi,0);
			else	slv(0,b ,0),slv(0,2*pi-a,0);
		}
		printf("%.1lf%%\n",100.0*l/r);
	}
	return 0;
}
```

$$%偷偷藏个图片源码，没人发现吧
%\documentclass[UTF-8,border=10pt]{standalone}
%\usepackage{listings,xcolor,tikz}
%\usetikzlibrary{calc}
%\newcommand{\suika}[2]{
%	\filldraw[fill=green!40!white,draw=green!60!black,thick] (0,0) circle (3);
%
%	\draw[very thick,->] (-3.8,0) -- (3.8,0);
%	\draw[very thick,->] (0,-3.8) -- (0,3.8);
%	\node[anchor=south] at (3.8,0) {$x$};
%	\node[anchor=west ] at (0,3.8) {$y$};
%	
%	\coordinate (O) at (0,0);
%	\coordinate (A) at (#1:3);
%	\coordinate (B) at (#2:3);
%	
%	\filldraw[fill=green!90!black,thick] (0,0) -- (A) arc(#1:#2:3) -- (0,0);
%	\node at ($(A)+(#1:0.2)$) {$a$};
%	\node at ($(B)+(#2:0.2)$) {$b$};
%
%	\draw[dashed,thick] (A) -| (O) (B) -| (O);
%}
%\begin{document}
%	\begin{tikzpicture}
%		\begin{scope}
%			\suika{-75}{-30}; \node[anchor=north] at (0,-4) {Figure 1};
%		\end{scope}
%		\begin{scope}[xshift=8cm]
%			\suika{-75}{ 30}; \node[anchor=north] at (0,-4) {Figure 2};
%		\end{scope}
%		\begin{scope}[xshift=16cm]
%			\suika{ 25}{ 54}; \node[anchor=north] at (0,-4) {Figure 3};
%		\end{scope}
%\end{tikzpicture}
%\end{document}
$$

---

## 作者：Fasterfaster (赞：5)

不用分类讨论的做法。

首先，将 正面看西瓜能看到面积的比例 转化为 正面看任意截面能看到长度 的比例，这两个显然是相等的，看下面的图理解一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/j88ne585.png)

如图，这是任意截面（等同于俯视图），从蓝色箭头方向看过去红色的地方能被看到，绿色的地方不能被看到。注意投影是一条线段。

所以我们只需要求出从 $a^{\circ}$ 到 $b^{\circ}$ 的扇形的正面投影中绿色部分和投影长度就可以了。

注意投影长度不一定是扇形半径，因为可能会出现这种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/bx1uybs5.png)

蓝色部分既不是瓜皮也不是瓜肉，所以不会被算在总长度里面。

所以现在问题转化为两个：
1. 求出投影的总长度。
2. 求出红色部分的长度。

这里不需要去分讨。

我们假设西瓜截面的半径为 $1$。

首先我们预处理出数组 $p_i(0\le i<360)$。$p_i=1$ 当且仅当瓜的 $i^{\circ}$ 到 $(i+1)^{\circ}$ 没有被切掉。

对于问题 1，我们首先求出切割的边界的投影 $a'=\sin a^{\circ}, b'=\sin b^{\circ}$。如果瓜的最右边被覆盖（即 $p_{89}=1\vee p_{90}=1$），那么投影的右边界一定是 $1$，否则投影的右边界为 $\min(a',b')$。投影的左边界求法同理。

对于问题 2，可以用投影的总长度减去被绿色覆盖的长度，得到红色的长度。我们把正面的西瓜每一度分成一个部分，然后枚举哪些部分被绿色覆盖。即对于 $270\le i< 359$ 和 $0\le i< 90$，若 $p_i=1$ 则代表 $i^{\circ}$ 到 $(i+1)^{\circ}$ 的部分被绿色覆盖，这样绿色覆盖的长度会增加 $\sin(i+1)^{\circ}-\sin i^{\circ}$。

把绿色覆盖的部分累计起来，再用投影的总长度减去，就得到了红色部分的长度。

实现细节：
1. $p$ 数组表示的是段的覆盖情况，而不是点。
2. 注意输出时 +eps 以防止被 ```cout``` 的 ```fixed``` 和 ```setprecision``` 模式向下取整使最后一位少 1。

代码懒了没写注释。
```cpp
// Solution Demonstration Code
#include<bits/stdc++.h>
#define F(i,x,y) for (int i=(x);i<=(y);i++)
#define MT int testcases;cin>>testcases;while(testcases--)
using namespace std;

const double pi=3.14159265358;
int a,b;
bool p[360];
int main () {
	ios::sync_with_stdio(false);
	cin.tie (0);
	MT {
		F(i,0,359)p[i]=0; 
		cin>>a>>b;
		swap(a,b); 
		double al=sin(a*pi/180),bl=sin(b*pi/180);
		for (int i=a;i!=b%360;i=(i+1)%360) p[i]=1;
		double tl,tr;
		if(p[270]||p[269]) tl=-1;
		else tl=min(0.0,min(al,bl));
		if(p[90]||p[89]) tr=1;
		else tr=max(0.0,max(al,bl));
		double vis=tr-tl;
		for (int i=270;i!=90;i=(i+1)%360){
			if (p[i]) {
				vis-=sin((i+1)*pi/180)-sin(i*pi/180);
			}
		}	
		double ans=vis/(tr-tl);
		cout<<fixed<<setprecision(1)<<(ans+1e-9)*100<<"%\n";
	}
	return 0;
}

---

## 作者：pinkex (赞：4)

PS:本题实在太玄。。。

首先，要看懂题目的意思，题目就是说给你一个西瓜，给出俯视图，并在俯视图上向瓜心方向切2刀，每一刀的距离都是瓜的半径。要你求出，在正视图中，红色的面积是正视图总面积的多少。

出题者很友善地给出了部分特殊情况，那我们一起来分析下：

10%：
由于a,b∈{0,90,180,270}，我们可以全用来特判；

20%(10%+10%)：

由于270<=a<=359,0<=b<=90，说明正视图的总面积是π\*r\*r。那么，我们只需求出红色的总面积，具体见P1；

40%(10%+10%+20%)：

这种情况就开始比较复杂了，可以自己推一下；

100%：

本蒟蒻仍然将每种情况都推了一遍。。。唯一要注意的是，一定要把目光放在留下来的西瓜上面，见P2。

另外的：注意cmath里的sin什么的都是弧度，我们要把角度转成弧度再用，弧度=π\*角度/180°。

![Luogu](http://a1.qpic.cn/psb?/V13rNqLo2pBVxF/k987zD6JSQz4JVjZD2892HWnw0f2u\*LSXzYSxLMXFWc!/b/dGwBAAAAAAAA&ek=1&kp=1&pt=0&bo=UAXoAQAAAAADF44!&tm=1497103200&sce=60-4-3&rf=viewer\_4)

![Luogu](http://a1.qpic.cn/psb?/V13rNqLo2pBVxF/JMoOptcxHudNtgCn2dPobQzf.6b8HBDFVsQzsVKukFo!/b/dG4BAAAAAAAA&bo=UAXoAQAAAAADAJk!&rf=viewer\_4)

下见代码：

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const double pi=3.14159265358980;
inline int read(){
    int x=0; char ch=getchar();
    while (ch<'0'||ch>'9') ch=getchar();
    while (ch>='0'&ch<='9') x=x*10+ch-'0',ch=getchar();
    return x;
}
double chg(int x){
    return pi*x/180;
}
void situ1(int d1,int d2){
    if (d1==0||d2==0){
        if (d1==0){if (d2==90) puts("50.0%"); else puts("0.0%");}
        else{if (d1==270) puts("50.0%"); else puts("0.0%");}
    }else
    if (d1==90||d2==90){
        if (d1==90) puts("0.0%"); else puts("100.0%");
    }else
    if (d1==180||d2==180){
        if (d1==180) puts("0.0%"); else puts("100.0%");
    }
}
void situ2(int d1,int d2){
    double del=chg(360-d1),ret=sin(del);
    del=chg(d2),ret+=sin(del),ret*=100/2;
    printf("%.1f%c\n",ret,'%');
}
void situ3(int d1,int d2){
    if (d1<=270&&d2>=90) puts("100.0%");
    else{
        double del=chg(90-abs(270-d1)),ret=0,tot=0; if (d1!=180) ret=sin(del);
        if (d1>=270) tot=1; else tot=ret;
        del=chg(90-abs(90-d2)),ret+=sin(del);
        if (d2<=90) tot+=1; else tot+=sin(del);
        ret=ret/tot*100;
        printf("%.1f%c\n",ret,'%');
    }
}
void situelse(int d1,int d2){
    double del=0,ret=0,tot=0;
    if (d1<d2){
        if (0<=d1&&d1<90){
            if (90-d1<=d2-90) puts("0.0%");
            else{
                if (d2<=90) del=chg(d2),ret=sin(del),tot++;
                if (d2>90) del=chg(180-d2),tot=ret=sin(del);
                del=chg(d1),ret-=sin(del),tot++;
                ret=ret/tot*100;
                printf("%.1f%c\n",ret,'%');
            }
        }else
        if (90<=d1&&d1<180) puts("0.0%"); else
        if (180<=d1&&d1<270){
            if (270-d1>=d2-270) puts("0.0%");
            else{
                del=chg(d1-180),tot=ret=sin(del),tot++;
                del=chg(360-d2),ret-=sin(del);
                ret=ret/tot*100;
                printf("%.1f%c\n",ret,'%');
            }
        }else
        if (270<=d1&&d1<360){
            del=chg(360-d1),ret=sin(del),tot=2;
            del=chg(360-d2),ret-=sin(del);
            ret=ret/tot*100;
            printf("%.1f%c\n",ret,'%');
        }
    }else{
        if (0<d1&&d1<=90){
            del=chg(d1),tot=sin(del);
            del=chg(d2),ret=sin(del);
            ret=ret/tot*100;
            printf("%.1f%c\n",ret,'%');
        }else
        if (90<d1&&d1<=180){
            if (d2>=90) puts("100.0%"); else{
                tot=1;
                del=chg(d2),ret=sin(del);
                ret=ret/tot*100;
                printf("%.1f%c\n",ret,'%');
            }
        }else
        if (180<d1&&d1<=270){
            del=chg(d1-180),ret=sin(del),tot++;
            if (90<=d2) ret=tot=1;
            if (0<d2&&d2<90) del=chg(d2),ret+=sin(del),tot++;
            ret=ret/tot*100;
            printf("%.1f%c\n",ret,'%');
        }else
        if (270<d1&&d1<360){
            del=chg(360-d1),ret=sin(del),tot++;
            if (270<d2) del=chg(360-d2),tot=sin(del);
            if (90<=d2&&d2<180) del=chg(180-d2),ret+=sin(del),tot+=sin(del);
            if (0<d2&&d2<90) del=chg(d2),ret+=sin(del),tot++;
            ret=ret/tot*100;
            printf("%.1f%c\n",ret,'%');
        }
    }
}
inline void _solve(){
    int dg_s=read(),dg_t=read();
    if (dg_s%90==0&&dg_t%90==0) situ1(dg_s,dg_t); else
    if (270<=dg_s&&dg_s<360&&0<=dg_t&&dg_t<=90) situ2(dg_s,dg_t); else
    if (180<=dg_s&&dg_s<360&&0<=dg_t&&dg_t<180) situ3(dg_s,dg_t); else
    situelse(dg_s,dg_t);
}
int main(){
    for (int T=read(); T; T--) _solve();
    return 0;
}
```

---

## 作者：orangebird (赞：4)

计算几何问题。

第一个测试点，只会在90°倍数的地方切开，这样答案只能是0.0%,50.0%,100.0%，分情况讨论即可。

第二个测试点，只会切掉面向自己的一小部分，我们将左右两部分分开考虑，每部分的正视图将会是

一个半圆包含一个半椭圆，由于要求计算比例，无需算出圆和椭圆的面积，只要用椭圆短半轴长除以西瓜的半径即可。

设西瓜半径为r,在俯视图中根据三角函数原理得知短半轴长度为sin(degree)\*r，因此比例为sin(degree)，最后需要合并左右两部分的答案。

对其它测试点，情况稍微复杂，依然是左右两部分分开考虑。先计算出西瓜总可视面积，

然后再分情况讨论几个椭圆的重叠关系，利用简单的加减法即可得到答案。

具体操作时同样无需计算椭圆面积，只计算短半轴与西瓜半径的比例即可。

我的代码似乎比较复杂...

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int T,a,b;
const double pi=3.1415926535897932;
enum type
{
    EMPTY=0,
    FULL=1,
    FLE=2, 
    FGE=3,
    ELF=4,
    EGF=5,
    FLEFL=6,
    FGEFL=7,
    FLEFG=8,
    ELFEL=9,
    EGFEL=10,
    ELFEG=11,
};
void gettype(int a,int b,int& tar,int& t1,int& t2)
{
    if(a>=180)
    {
        if(b>a)tar=FULL;
        else if(b<=90)tar=FGE,t1=b;
        else if(b<180)tar=FLE,t1=b;
        else tar=EMPTY;
    }else if(a<90)
    {
        if(b>=180||b==0)tar=EGF,t1=a;
        else if(b>90)tar=FLEFL,t1=b,t2=a;
        else if(b>a)tar=FGEFL,t1=b,t2=a;
        else if(b>0)tar=EGFEL,t1=a,t2=b;
    }else if(a>=90)
    {
        if(b>=180||b==0)tar=ELF,t1=a;
        else if(b<=90)tar=ELFEL,t1=a,t2=b;
        else if(b<a)tar=ELFEG,t1=a,t2=b;
        else if(b<180)tar=FLEFG,t1=b,t2=a;
    }
}
double torad(double d)  
{  
    return pi/180.0*d;
}  
double gettotal(int t,double t1,double t2)
{
    if(t==EMPTY)return 0.0;
    if(t==FULL)return 1.0;
    if(t==FLE)return sin(t1);
    if(t==FGE)return 1.0;
    if(t==ELF)return 1.0;
    if(t==EGF)return sin(t1);
    if(t==FLEFL)return max(sin(t1),sin(t2));
    if(t==FGEFL)return 1.0;
    if(t==FLEFG)return 1.0;
    if(t==ELFEL)return 1.0;
    if(t==EGFEL)return sin(t1);
    if(t==ELFEG)return sin(t2);
}
double getred(int t,double t1,double t2)
{
    if(t==EMPTY)return 0.0;
    if(t==FULL)return 0.0;
    if(t==FLE)return sin(t1);
    if(t==FGE)return sin(t1);
    if(t==ELF)return 0.0;
    if(t==EGF)return 0.0;
    if(t==FLEFL)return max(0.0,sin(t1)-sin(t2));
    if(t==FGEFL)return sin(t1)-sin(t2);
    if(t==FLEFG)return 0.0;
    if(t==ELFEL)return sin(t2);
    if(t==EGFEL)return sin(t2);
    if(t==ELFEG)return sin(t2);
}
int tl,tr;
int tl1,tl2,tr1,tr2;
int main()
{
    cin>>T;
    while(T--)
    {
        cin>>a>>b;
        gettype(a,b,tr,tr1,tr2);
        a=(-a+360)%360;
        b=(-b+360)%360;
        swap(a,b);
        gettype(a,b,tl,tl1,tl2);
        double totl=gettotal(tl,torad(tl1),torad(tl2));
        double totr=gettotal(tr,torad(tr1),torad(tr2));
        double redl=getred(tl,torad(tl1),torad(tl2));
        double redr=getred(tr,torad(tr1),torad(tr2));
        printf("%.1lf%%\n",(redl+redr)*100.0/(totl+totr));
    }
    return 0;
}
```

---


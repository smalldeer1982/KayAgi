# 小D的地下温泉

## 题目背景

小D最喜欢泡温泉了。小D找某奸商租下了一块$N$行$M$列的地，左上角为$(1,1)$，右下角为$(N,M)$。小D本以为这块地里全是温泉，结果这块地极不稳定，曾经发生过一些地形变动，所以其中一些地方全是土。


## 题目描述

一开始他会告诉你当前这块地的情况，但是小D有一些假操作，希望你操作给他看：

1. 由小D指定$w$个位置，他希望知道其中哪个位置下水泡温泉的范围最大。泡温泉的范围定义为指定位置通过向上下左右四个方向能到达的位置的个数。若询问的位置为土，则范围为0。如果如果有多个位置均为最大，输出给出顺序较前的那个。位置编号为$1,2,...,w$。

2. 由小D指定$w$个位置，他会使用膜法按顺序翻转这$w$个地方的地形。即若原位置是土，则该位置变为温泉；若原位置是温泉，则该位置变为土。因为小D不希望活动范围减少得太快，所以他在将温泉变为土时不会将一个区域分割。


## 说明/提示

对于30%的数据，$N,M\le 100,\sum w\le 100$

对于70%的数据，$N,M\le 1000$

对于100%的数据，$1\le N\times M,Q\le 10^{6},\sum w\le 10^{6},w\geq 1$

数据在windows下制作


## 样例 #1

### 输入

```
5 5
.*...
.****
*....
*****
.....
3
1 2 1 1 1 3
2 1 3 1
1 2 1 1 1 3```

### 输出

```
2
1
```

# 题解

## 作者：FlierKing (赞：8)

##对于30%的数据

对于每个点的询问，我们可以直接暴力BFS，直接比较即可。


##对于70%的数据

直接将图存在一个$1000\times 1000$的数组里。然后将每个联通块的块的大小存在一个点上。如果将温泉变为土，由于不会将一个块分割，所以直接v[fa(x)]--即可；如果将土变为温泉，那么为这块地新开一个位置，然后将这个点四周的大小合并到这个点上即可。以上均可以用并查集来维护。


##对于100%的数据

只需在70分的基础上加一些小技巧将图存在一个$10^{6}$的数组里即可。

另外，不推荐使用在原位置直接重开点的方法维护大小，可能会导致一些本不联通的联通块的数据联通的情况。


以上为被dalaoD翻的水题题解


最后感谢Ditoly和FallDream帮助验题。


---

## 作者：_J_C_ (赞：4)

楼上的巨佬讲的都很对，但由于他们太巨了，讲的并不是很详细。

**~~前方剧透高能警告~~**

大家应该都能想到用并查集把所有相连的温泉合并起来维护。

存图嘛……二维降到一维，没什么好说的。

初始化并查集就不多讲了，但是值得一提的是初始化并不用搜索（广、深搜），只要在输入的时候考虑这块温泉上方、左方（即已经输入的两个方向）是否是温泉就好了。如果是，就合并。

在并查集的根部维护一个权，表示这个并查集的大小。

首先我们很容易想到当把温泉变成泥土时，只要给并查集的权-1就好了。这样子虽然这个点还在集里，也不再起作用了。（注意并查集是没有分裂集合的操作的）

但泥土变成温泉时，就有点复杂了。见下面的例子：

(1) .....

(2) ***..

(3) ..*..

我们发现，当泥土变成温泉时，它仍然会回到原来的集合内，而事实上它和原来的集合却未必连通。

然而并查集又没有裂点操作……这个点的belong值是不能随便更改的，因为你说不准路径压缩有没有完全。

(如1->2,2->3,我们不能将belong[2]随便乱改，因为1所属的集合也会被更改)


怎么办呢、、

方法是新开一个编号，用来表示这块土地，而丢弃旧编号。

比如有下面的地图

**

**

原来的编号如下：

12

34

现在我们要把(1,1)变成温泉了，那么我们给它新分配一个编号：

52

34

那么这个新编号现在不属于任何集（没有上述奇怪的历史遗留问题），我们令belong[newpos] = newpos，cnt[newpos] = 1(权为1)，然后考虑合并它与相邻的温泉就好了。

对于这个新编号，我们仅在与并查集相关的操作中使用它，而访问地图时仍然使用旧的编号（如上个样例，我们仍然用map[1]访问(1,1)，因为它的位置没有变）

由于翻转操作总次数小于10^6（数据范围），所以并查集的数组开两倍（2*10^6）就可以了

代码见下（稍微有点注释吧）：

```cpp

#include <cstdio>
#include <cstdlib>

#define PTOI(x,y) ((x) * cy + (y))//将二维坐标降为一维


int cnt[2123456];//并查集的权
int belong[2123456];//并查集

int newone[1123456];//当前这个点的编号

int iEnd;//下一个未分配的编号
int find(int n)//并查集
{
	return n == belong[n] ? n : belong[n] = find(belong[n]);
}

void combine(int a, int b)//并查集-合并
{
	int f(find(a)), s(find(b));
	if (f != s)
	{
		if (cnt[f] > cnt[s]) f ^= s ^= f ^= s;
		cnt[f] += cnt[s];
		belong[s] = f;
	}
}

char map[1123456];//一维存图
int cx, cy, n;//行，列，询问

char read_char()
{
	char ret(getchar());
	while (ret != '.' && ret != '*') ret = getchar();
	return ret;
}

int main()
{
	for (int i(0); i != 1123456; ++i)
	{
		newone[i] = i;//初始化编号与并查集
		belong[i] = i;
		cnt[i] = 1;
	}
	scanf("%d%d", &cx, &cy);
	iEnd = PTOI(cx - 1, cy - 1) + 1;//已经被分配的编号范围为[PTOI(0,0),PTOI(cx-1,cy-1)]
	for (int i(0); i != cx; ++i)
	{
		for (int j(0); j != cy; ++j)
		{
			int pos(PTOI(i,j));
			map[pos] = read_char();
			if (map[pos] == '.')
			{
				if (i != 0 && map[PTOI(i-1,j)] == '.') combine(pos, PTOI(i-1,j));//考虑它左边和上方是否是温泉，是否要合并
				if (j != 0 && map[PTOI(i,j-1)] == '.') combine(pos, PTOI(i,j-1));
			}
			else cnt[pos] = 0;//如果这一块是土地，权为0
		}
	}
	scanf("%d", &n);
	for (int i(0); i != n; ++i)
	{
		int cmd, m;
		scanf("%d%d", &cmd, &m);
		if (cmd == 1)
		{
			int max(0), rank(1);//回答询问
			for (int i(0); i != m; ++i)
			{
				int x, y;
				scanf("%d%d", &x, &y);
				--x; --y;
				int pos(PTOI(x,y));
				if (map[pos] == '.' && cnt[find(newone[pos])] > max)
				{
					max = cnt[find(newone[pos])];
					rank = i + 1;
				}
			}
			printf("%d\n", rank);
		}
		else
		{
			for (int i(0); i != m; ++i)
			{
				int x, y;
				scanf("%d%d", &x, &y);
				--x; --y;
				int pos(PTOI(x,y));
				if (map[pos] == '.')
				{
					map[pos] = '*';
					--cnt[find(newone[pos])];//减去权值
				}
				else
				{
					newone[pos] = iEnd++;//分配新的编号
					map[pos] = '.';
					belong[newone[pos]] = newone[pos];
					cnt[newone[pos]] = 1;
					if (x != 0 && map[PTOI(x - 1, y)] == '.')//考虑左上右下是否需要合并
					{
						combine(newone[pos], newone[PTOI(x - 1, y)]);
					}
					if (x != cx - 1 && map[PTOI(x + 1, y)] == '.')
					{
						combine(newone[pos], newone[PTOI(x + 1, y)]);
					}
					if (y != 0 && map[PTOI(x, y - 1)] == '.')
					{
						combine(newone[pos], newone[PTOI(x, y - 1)]);
					}
					if (y != cy - 1 && map[PTOI(x, y + 1)] == '.')
					{
						combine(newone[pos], newone[PTOI(x, y + 1)]);
					}
				}
			}
		}
	}
	return 0;
}

```


---

## 作者：Musity (赞：3)

说在前面：看到题目一眼并查集，还在想我什么时候能秒蓝题了，结果交完之后 20pts，发现没注意全是泥土的情况。再交 50pts，原来是删点不完全，一个下午的努力终于 100pts。

感觉和今年做 csp-s 第二题时一样，看完题后马上写完代码，结果发现缺少很多特殊情况的处理，这题调了半天终于 AC 了，但考试题在考完后才发现算的位移可能是负的。所以以后凭直觉想到的东西先看能不能分类讨论，多想点特殊的情况，免得最后还得花半天重构代码。


改完后觉得自己代码比之前 WA 的简洁多了，发篇题解纪念一下。


---



50pts 思路
---






首先，题目让我们合并温泉，想到并查集，但又不想建结构体标记点，于是写了：
```cpp
#define  id(x,y)  (x-1)*m+y;
```
这样每一点刚好有一个编号，可以用并查集。
初始化所有的温泉连起来，土地就不管了。每次合并操作将点与旁边四个点连起来。同时维护集合的大小。


```cpp
void merge(int x,int y){
	x=get(x);y=get(y);
	if(x==y)return; 
	siz[y]+=siz[x];
	fa[x]=y;
	siz[x]=0;
}
```

删除一个点我想的是，让 $x$ 变成独立的节点，即:
```
void delete(int x){
    size[get(x)]--;
    fa[x]=x;
    size[x]=1;
}
```
为了以后可以继续用 $x$ 与其它点合并，将 `size[x]` 设成了一。自以为思维严密，结果只得了 50pts。
因为若 $x$ 有子节点（右图），那么查询它们所在温泉的大小的时候会查到 $x$ 这个位置，而该集合已被抽出且大小设为了一。
![](https://cdn.luogu.com.cn/upload/image_hosting/i5ukygvq.png)





正解
---



根据上面讨论，发现只要不删 $x$ 这个点，查询工作就不会被打乱。只要让 $x$ 成为一个新点不就好了，留着删掉的那个点来继续维持着并查集的结构，但在集合的大小上减一表示它并不是温泉，只是起承接作用。

不过前面我们令 $id_{(x,y)} \gets (x-1) \times m+y$，其中 $id_{(x,y)}$ 是定值，并不好建点。由新建节点想到邻接表中新建边的操作，改用数组来存。

这样每次建温泉只要让 `f[x][y]=newnode()`，$f$ 与上面 $id$ 的区别在于 $id$ 是一种运算，把每个点定义成了唯一的数值，而 $f$ 是数组，可以把一点指向新的内存：

```cpp
int newnode(){
	fa[++tot]=tot;
	siz[tot]=1;
	return tot;
}
```

50pts 时遇到的删点情况就解决了。

由于 $N \times M \le 10^6$，所以用`vector`来存。


---


此外发现每个点联通只和上下左右有关，可以不广搜，边读入边合并。




```cpp
if(a[i][j]){
	f[i][j]=newnode();
	if(a[i][j]==a[i-1][j])merge(f[i][j],f[i-1][j]);
	if(a[i][j]==a[i][j-1])merge(f[i][j],f[i][j-1]);
}
```








完整代码
---


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6+500;

vector<int> a[N],f[N];
char s[N];
int n,m,Q,tot,fa[N<<1],siz[N<<1];
int mvx[4]={0,0,1,-1},mvy[4]={1,-1,0,0};

int newnode(){
	fa[++tot]=tot;
	siz[tot]=1;
	return tot;
}
bool valid(int x,int y){
	return 1<=x&&x<=n&&1<=y&&y<=m;
}
int get(int x){
	if(fa[x]==x)return x;
	return fa[x]=get(fa[x]);
}
void merge(int x,int y){
	x=get(x);y=get(y);
	if(x==y)return; 
	fa[x]=y;
	siz[y]+=siz[x];siz[x]=0;
}
void inital(){
	for(int i=0;i<=n;i++){
		 a[i].resize(m+3,0);//千万别开m+1
		f[i].resize(m+3,0);
	}	
}
void change(int x,int y){
	a[x][y]^=1;
	if(!a[x][y])//delete 
		siz[get(f[x][y])]--;
	else{       //new lake
		f[x][y]=newnode();
		for(int k=0;k<4;k++){
			int xx=x+mvx[k],yy=y+mvy[k];
			if( !valid(xx,yy) || a[x][y]!=a[xx][yy])continue;
			merge(f[xx][yy],f[x][y]);
		}	
	}
}
int main(){
	scanf("%d%d",&n,&m);tot=0;
	inital();
	for(int i=1;i<=n;i++){
		scanf("%s",s+1);
		for(int j=1;j<=m;j++){
			a[i][j] = (s[j]=='.');
			if(a[i][j]){
				f[i][j]=newnode();
				if(a[i][j]==a[i-1][j])merge(f[i][j],f[i-1][j]);
				if(a[i][j]==a[i][j-1])merge(f[i][j],f[i][j-1]);
			}
		}
	}
	scanf("%d",&Q);
	while(Q--){
		int op,w;
		scanf("%d%d",&op,&w);
		int ans=0,ret=1;
		for(int i=1,x,y;i<=w;i++){
			scanf("%d%d",&x,&y);
			if(op==1){
				if(a[x][y]&&siz[get(f[x][y])]>ans)
					ans=siz[get(f[x][y])],ret=i;
			}
			else change(x,y);
		}
		if(op==1)
			printf("%d\n",ret); 
	}
	return 0;
}
```


---

此外，以上用 `f[x][y]` 只是为了解释得简洁，我们完全可以在50pts的做法上写 `f[id(x,y)]` 来表示点 $(x,y)$ 真正使用的节点，用数组模拟链表的形式可以进一步节省空间和时间。


> 改用数组模拟链表并加入快读快写和 `inline` 后，我只跑了六百多毫秒，是目前最快的。
> 
> [评测记录于此。](https://www.luogu.com.cn/record/184305027)

---

## 作者：「QQ红包」 (赞：3)

终于用并查集过了，

开始用的一种方法bug太多，各种特判

其实思路还是比较清晰的，细节处理要注意

先用dfs/bfs搜连通块，并且标号，

然后修改，分两种情况，土变成温泉，要和周围的连通块合并

温泉变成土，面积直接减

然后查询，直接一个一个扫就行。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
using namespace std;
const int Max=1001000;
int n,m,Q,d;//n*m的矩阵，Q：询问次数  d:记录是第几个爸爸了 
char ch;//读入用的 
int a[Max];//记录是温泉是土 
int f[Max];//记所属连通块 
bool flag[Max];//记录是否搜过 
int s[Max];//记面积 
int i,j;//循环控制变量 
int T,w;//T：操作1/2 w：点数 
int ans,sum;//ans:标号   sum：最大块面积 
int xx,yy; //坐标 
int fa[Max]; //记爸爸 
int ff;//存些东西 
int read()//读入 
{
    char ch=getchar();
    int x=0;
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar(); 
    return x;
}
int gf(int x)//找爸爸 
{
    if (fa[x]==x) return x;
    fa[x]=gf(fa[x]);
    return fa[x];
}
void dfs(int x,int y)//搜连通块 
{
    int id=(x-1)*m+y;
    if (flag[id]||a[id]==0) return;//找过，或者这地方是土，就不搜 
    flag[id]=1;//标记 
    f[id]=d;//标记该地方属于连通块D 
    s[d]++; 
    if (x>1) dfs(x-1,y);//四个方向搜 
    if (y>1) dfs(x,y-1);
    if (x<n) dfs(x+1,y);
    if (y<m) dfs(x,y+1);
}
void merge(int x,int y,int x1,int y1)//把两个坐标所处的连通块合并 
{
    int d1=(x-1)*m+y;
    int d2=(x1-1)*m+y1;
    int f1=gf(f[d1]);
    int f2=gf(f[d2]);
    if (a[d1]==0||a[d2]==0||f1==f2) return;//如果某个点是土或者是同一个爸爸就不搜 
    s[f1]+=s[f2];//把面积加起来 
    s[f2]=0;//s[f2]清空 
    fa[f2]=f1;
}
int main()
{
    freopen("1.in","r",stdin);
    freopen("1.out","w",stdout);
    n=read();
    m=read();
    for (i=1;i<=n;i++)//温泉：1  土：0 
        for (j=1;j<=m;j++)
        {
            ch=getchar();
            while (ch!='.'&&ch!='*') ch=getchar();
            if (ch=='.') a[(i-1)*m+j]=1;//标记
```
}//为'.'（1代表温泉）或'\*'（0代表土）
    
```cpp
    for (i=1;i<=n;i++) 
        for (j=1;j<=m;j++)//dfs搜连通块 
        {
            if (a[(i-1)*m+j]==1&&!flag[(i-1)*m+j])//没扫过而且是温泉 
            {
                d++;
                dfs(i,j); 
            }
        }
    for (i=1;i<=d;i++)
        fa[i]=i;
    Q=read();
    while (Q--)
    {
        T=read();
        w=read();
        if (T==1)//查询 
        {
            ans=1;//点的标号 
            sum=0;//大小 
            for (i=1;i<=w;i++)
            {
                xx=read();
                yy=read();
                ff=gf(f[(xx-1)*m+yy]);
                if (a[(xx-1)*m+yy]==0) continue;//如果是土就不管 
                if (s[ff]>sum)//找面积最大的连通块 
                {
                    sum=s[ff];
                    ans=i;
                }
            } 
            printf("%d\n",ans);
        } else //翻转 
        {
            while (w--)
            {
                xx=read();
                yy=read();
                if (a[(xx-1)*m+yy]==1)//温泉变成土
                {
                    a[(xx-1)*m+yy]=0;//标记
                    ff=gf(f[(xx-1)*m+yy]);
                    s[ff]--;//面积--
                    f[(xx-1)*m+yy]=0;//去掉爸爸 
                } else //新开一个连通块，然后和周围四个合并 
                {
                    a[(xx-1)*m+yy]=1;
                    d++;
                    f[(xx-1)*m+yy]=d;
                    fa[d]=d;
                    s[d]++;
                    if (xx>1) merge(xx,yy,xx-1,yy);
                    if (yy>1) merge(xx,yy,xx,yy-1);
                    if (xx<n) merge(xx,yy,xx+1,yy);
                    if (yy<m) merge(xx,yy,xx,yy+1);
                }
            }
        }    
    }
    return 0;
}
```

---

## 作者：y553546436 (赞：2)

比赛炸掉的原因竟然是关掉流同步以后还是手残又用cin又用scanf...

丢一个启发式合并的题解  记录每个点属于的连通块编号及连通块大小

温泉变成土直接size-- 土变成温泉找旁边最大的一个连通块然后把它自己和其他相邻连通块并起来就好了

时间复杂度10^6log10^6 常数很小 比标算慢不了多少


code:
```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define per(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
typedef long long ll;
typedef long double ld;
const int dx[]={0,0,-1,1};
const int dy[]={-1,1,0,0};
int n,m,q,cnt,size[2000005];
string s[1000005];
vector<vector<int> > bl;
bool judge(int x,int y) {
    return x>=0&&x<n&&y>=0&&y<m;
}
void bfs(int x,int y,int id) {
    static int qx[1000005],qy[1000005],qN;
    if(bl[x][y]!=id) size[bl[x][y]]=0,bl[x][y]=id,size[id]++;
    qx[1]=x,qy[1]=y,qN=1;
    rep(i,1,qN) {
        x=qx[i],y=qy[i];
        rep(d,0,3) {
            int xx=x+dx[d],yy=y+dy[d];
            if(judge(xx,yy)&&s[xx][yy]=='.'&&bl[xx][yy]!=id) {
                size[bl[xx][yy]]=0,bl[xx][yy]=id,size[id]++;
                qx[++qN]=xx,qy[qN]=yy;
            }
        }
    }
}
int main() {
    ios::sync_with_stdio(false);
    cin>>n>>m;
    rep(i,0,n-1) cin>>s[i];
    static vector<int> vi(m,0);
    rep(i,0,n-1) bl.push_back(vi);
    rep(i,0,n-1)
        rep(j,0,m-1) if(s[i][j]=='.'&&!bl[i][j]) {
            ++cnt;
            bfs(i,j,cnt);
        }
    cin>>q;
    while(q--) {
        int op,w,x,y;
        cin>>op>>w;
        if(op==1) {
            int ans=-1,id;
            rep(i,1,w) {
                cin>>x>>y; x--,y--;
                if(size[bl[x][y]]>ans) ans=size[bl[x][y]],id=i;
            }
            cout<<id<<endl;
        }
        else {
            rep(i,1,w) {
                cin>>x>>y; x--,y--;
                if(s[x][y]=='*') {
                    int maxsz=-1,id=0;
                    rep(d,0,3) {
                        int xx=x+dx[d],yy=y+dy[d];
                        if(judge(xx,yy)&&s[xx][yy]=='.'&&size[bl[xx][yy]]>maxsz)
                            maxsz=size[bl[xx][yy]],id=bl[xx][yy];
                    }
                    if(!id) bl[x][y]=++cnt,size[cnt]=1;
                    else {
                        bl[x][y]=id,size[id]++;
                        rep(d,0,3) {
                            int xx=x+dx[d],yy=y+dy[d];
                            if(judge(xx,yy)&&s[xx][yy]=='.'&&bl[xx][yy]!=id)
                                bfs(xx,yy,id);
                        }
                    }
                    s[x][y]='.';
                }
                else {
                    size[bl[x][y]]--,bl[x][y]=0;
                    s[x][y]='*';
                }
            }
        }
    }
    return 0;
}
```

---

## 作者：summ1t (赞：0)

# Solution

这道题前前后后调了两个多小时，终于过了，细节是真的多，我几乎把所有坑都踩过了，就在此总结一下。

对于此题做法并不难想，维护集合大小和连通性，很容易想到并查集来维护。我们把二维降到一维，先预处理出每块温泉的大小，再处理操作。

$1$ 操作很容易，对于 $2$ 操作，如果该点是温泉，由于题中明确说将温泉变为土时不会将一个区域分割，所以直接将其所在连通块大小减 $1$；如果是土块，需要新建一个编号表示这块地。

接下来诸多我踩过的坑见代码注释
# CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+10;//原矩阵n*m<=1e6,再加上1e6次操作，所以空间大小开2e6
 
int n,m,q,fa[N],sz[N],c[N],tot,newpos[N];
char ch,mp[N];
 
int cal(int i,int j){//二维降到一维，而我写成(i-1)*n+1
	return (i-1)*m+j;
}
 
int find(int x){
	if(x!=fa[x]) fa[x]=find(fa[x]);
	return fa[x];
}
 
void unionn(int a,int b){//合并操作最好单独写一个函数，不然很容易写乱
	int x=find(a),y=find(b);
	if(x==y) return;
	sz[x]+=sz[y],fa[y]=x;
}
 
void init(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(mp[cal(i,j)]=='*'){sz[cal(i,j)]=0;continue;}//如果是土块就重置它的sz，并continue
			if(i-1>=1&&mp[cal(i-1,j)]=='.') unionn(cal(i,j),cal(i-1,j));
			if(j-1>=1&&mp[cal(i,j-1)]=='.') unionn(cal(i,j),cal(i,j-1));
		}
	}
}
 
 
 
void solve(int pos,int x,int y){
    //给该地新分配一个编号，并初始化
	newpos[pos]=tot++,mp[pos]='.',fa[newpos[pos]]=newpos[pos],sz[newpos[pos]]=1;
	if(x-1>=1&&mp[cal(x-1,y)]=='.') unionn(newpos[pos],newpos[cal(x-1,y)]);
	if(y-1>=1&&mp[cal(x,y-1)]=='.') unionn(newpos[pos],newpos[cal(x,y-1)]);
	if(x+1<=n&&mp[cal(x+1,y)]=='.') unionn(newpos[pos],newpos[cal(x+1,y)]);
	if(y+1<=m&&mp[cal(x,y+1)]=='.') unionn(newpos[pos],newpos[cal(x,y+1)]);
}
 
int main(){
	
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>ch;mp[cal(i,j)]=ch;
		}
	}
	for(int i=1;i<N;i++) newpos[i]=i,fa[i]=i,sz[i]=1;
	tot=cal(n,m)+1;init();
	cin>>q;
	while(q--){
		int opt,w;cin>>opt>>w;
        //接下来的操作要分清newpos数组和pos，千万不要搞混
		if(opt==1){
			int res=0,ans=1;//ans初值设为1，不要设为0，可能有都是土块的情况。
			for(int i=1;i<=w;i++){
				int x,y;cin>>x>>y;
				int pos=cal(x,y);
				if(sz[find(newpos[pos])]>res&&mp[pos]=='.') res=sz[find(newpos[pos])],ans=i;
			}
			cout<<ans<<endl;
		}
		else{
			for(int i=1;i<=w;i++){
				int x,y;cin>>x>>y;
				int pos=cal(x,y);
				if(mp[pos]=='.') mp[pos]='*',sz[find(newpos[pos])]--;
				else solve(pos,x,y);
			}
		}
	}
	
	return 0;
}
```

---

## 作者：boynext_door (赞：0)

思路还是比较好想的，因为每个方块变成土的时候不会把联通块断开，所以联通块温泉只会-1，然后再与联通块断开，

因为要支持可撤回，我一开始以为直接按秩合并，不路径压缩就行，后面想一下好像直接新建一个点就行，变成温泉

就直接连接联通块就行，然后就完了，第一次交数组忘开两倍(因为新建了结点)，只有20分，第二次过了，结果只按

秩合并，忘记路径压缩了，第三次加了路径压缩还更慢了。。。。。










```cpp
#include <bits/stdc++.h>
#define RG register
const int N = 1000050;
using namespace std;
inline int gi(){
    RG char ch=getchar();RG int x=0,q=0;
    while(ch<'0' || ch>'9') ch=='-'?(q=1):0,ch=getchar();
    while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
    return q?(-x):x;
}
inline int gc(){
    RG char ch=getchar();
    while(ch!='.' && ch!='*') ch=getchar();
    return ch=='.';
}
vector<int>xh[N];
int n,m,w[N*2],sum[N*2],fa[N*2],cnt,siz[N*2];
inline int find(int x){
    return x==fa[x]?x:find(fa[x]);
}
inline void work(int x,int y){
    int a,b,c;
    if (x>1&&(a=find(xh[x][y]))!=(b=find(c=xh[x-1][y]))&&w[c]){siz[a]>siz[b]?c=a,a=b,b=c:0;fa[a]=b,siz[b]+=siz[a],sum[b]+=sum[a];}
    if (x<n&&(a=find(xh[x][y]))!=(b=find(c=xh[x+1][y]))&&w[c]){siz[a]>siz[b]?c=a,a=b,b=c:0;fa[a]=b,siz[b]+=siz[a],sum[b]+=sum[a];}
    if (y>1&&(a=find(xh[x][y]))!=(b=find(c=xh[x][y-1]))&&w[c]){siz[a]>siz[b]?c=a,a=b,b=c:0;fa[a]=b,siz[b]+=siz[a],sum[b]+=sum[a];}
    if (y<m&&(a=find(xh[x][y]))!=(b=find(c=xh[x][y+1]))&&w[c]){siz[a]>siz[b]?c=a,a=b,b=c:0;fa[a]=b,siz[b]+=siz[a],sum[b]+=sum[a];}
    return;
}
int main(){
    n=gi(),m=gi(); RG int i,j,d,t,x,y,k,mx,ans;
    for (i=1; i<=n; ++i){
        xh[i].push_back(0);
        for (j=1; j<=m; ++j)
            xh[i].push_back(++cnt),fa[cnt]=cnt,siz[cnt]=1,w[cnt]=gc(),sum[cnt]=w[cnt]?1:0;
    }
    int q=gi();
    for (x=1; x<=n; ++x)
        for (y=1; y<=m; ++y)
            if (w[xh[x][y]])
                work(x,y);
    for (i=1; i<=q; ++i){
        t=gi(),k=gi();
        if (t&1){
            mx=0,ans=1;
            for (j=1; j<=k; ++j){
                x=gi(),y=gi();
                if (!w[xh[x][y]]) continue;
                if (sum[d=find(xh[x][y])]>mx) mx=sum[d],ans=j;
            }
            printf("%d\n",ans);
        }
        else {
            for (j=1; j<=k; ++j){
                x=gi(),y=gi();
                if (!w[xh[x][y]]) sum[xh[x][y]]=w[xh[x][y]]=1,work(x,y);
                else --sum[find(xh[x][y])],xh[x][y]=++cnt,fa[cnt]=cnt;
            }
        }
    }
    return 0;
}
```

---


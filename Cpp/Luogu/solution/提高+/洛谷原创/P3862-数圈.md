# 数圈

## 题目描述

求 $n$ 个点的无向完全图删去一条边之后圈的个数，答案模 $998244353$。


注：圈指的是任选一个顶点为起点，沿着不重复的边，经过不重复的顶点为途径，之后又回到起点的闭合途径。


## 说明/提示

前 $10\%$ 的数据满足 $3 \leq n \leq 10$

另外 $20\%$ 的数据满足 $ 9.99\times 10^2  \leq n \leq 10^3$

另外 $30\%$ 的数据满足 $ 9.99\times 10^4 \leq n \leq 10^5$

另外 $40\%$ 的数据满足 $ 9.99\times 10^8 \leq n \leq 10^9$

所有数据满足 $1 \leq T \leq 10$


## 样例 #1

### 输入

```
4
3
4
5
6```

### 输出

```
0
3
22
133```

# 题解

## 作者：MloVtry (赞：10)

虽然月赛题有官方题解但是空荡荡的不是很难看吗。。。

这个题显然是有规律的啦….虽然我的方法并不是很好


首先我们来看看


 ![](https://cdn.luogu.com.cn/upload/pic/8131.png) 

对于5去掉一条边，我们能够发现，这是一个四个点的完全图加上一个点引出三

条边

那么，四个点的完全图有的环，这个图也一定有；而这个图比4点完全图多出来


的环，一定要经过第五个点（红的那个）。


为了形成环，肯定是一边进，一边出，选择有C(3,2)种，而任意一种选择，肯定要落在4点完全图的两个点上，所以我们还要知道四个点的完全图中从任意A开始到任意B有几种方案


可以数出来，是5


用it[i]，表示i个点的完全图，任取A、B，A->B的方案数有多少


last[i]，表示i个点的完全图，有多少个环


那么 ans[n]=c(n-2,2)\*it[n-1]+last[n-1]


到这里，60%已经可以解决了


接下来是AC


用计算器可以发现一个事情，剩下的40%只有100W的范围


所以…我们可以预（打）处（表）理一下


然后…就可以A了…

关于it以及last的推导关系。。。我并不会证明，但是通过样例可以推出来一个不知对错的式子，这时候就要看胆子了2333333

```cpp
#include<iostream>
#include<cstdio>
#define mod 998244353
#define M 999000000-2
#define ll long long
using namespace std;
ll T,n;
ll c[100021],it[100021];
ll last[100021];
void get_c()
{
    c[2]=1;
    for(ll i=3;i<=100020;i++)
    {
        c[i]=(i-1)*i/2;
        c[i]%=mod;
    }
    it[3]=2;
    for(ll i=4;i<=100020;++i)
    {
        it[i]=it[i-1]*(i-2)+1;
        it[i]%=mod;
    }
    last[3]=1;
    for(ll i=4;i<=100020;++i)
    {
        last[i]=c[i-1]*it[i-1]+last[i-1];
        last[i]%=mod;
    }
}
ll cb[1000010],lastb[1000010],itb[1000010];
void get_b()
{
    cb[0]=1420232,lastb[0]=876466444,itb[0]=141309211;
    ll to=1000005;
    for(ll i=1;i<=1000005;++i)
    {
        ll num=i+M;
        cb[i]=cb[i-1]+num-1;
        cb[i]%=mod;
        lastb[i]=cb[i-1]*itb[i-1]+lastb[i-1];
        lastb[i]%=mod;
        itb[i]=itb[i-1]*(num-2)+1;
        itb[i]%=mod;
    }
}
int main()
{
    scanf("%lld",&T);
    get_c();
    get_b();
    while(T--)
    {
        scanf("%lld",&n);
        if(n>M)
        {
            n%=M;
            ll ans=cb[n-2]*itb[n-1]+lastb[n-1];
            ans%=mod;
            printf("%lld\n",ans);
            continue;
        }
        ll ans=c[n-2]*it[n-1]+last[n-1];
        ans%=mod;
        printf("%lld\n",ans);
    }
}
//今天也依旧没有捞到47岛风厌战呢
```

---

## 作者：Φρανκ (赞：1)

题意：求 $n$ 个点的无向完全图删去一条边之后圈的个数。

核心思想：递推

解：

出于个人能力限制，本题解在少数位置使用了OEIS。希望严谨数学证明的观者麻烦移步[该处](https://oeis.org/search?q=1%2C+7%2C+37%2C+197&sort=&language=english&go=Search)。

所求等于完全图中环的总数减去任意一条边所在的环数（每条边是等价的）。

对于一个 $n$ 点的完全图，$i$ 个点构成的环有 $\frac{(i-1)!}{2}C_n^i$ 个（选点有 $C_n^i$ 种方法，排列这些点有 $(n-1)!$ 种方法，顺逆相同故再除以 $2$），共有 $\frac{i!}{2}C_n^i$ 条边，故每条边在 $\frac{\frac{i!}{2}C_n^i}{\frac{n(n-1)}{2}}=\frac{n!}{n(n-1)(n-i)!}=\frac{(n-2)!}{(n-i)!}$ 个环上。

因此所求即为 $\sum^n_{i=3}\frac{(i-1)!}{2}C_n^i-\sum^n_{i=3}\frac{(n-2)!}{(n-i)!}$。对于右边一项有 $\sum^n_{i=3}\frac{(n-2)!}{(n-i)!}=\sum^n_{i=4}\frac{(n-2)!}{(n-i)!}+n-2=(n-2)(\sum_{i=3}^{n-1}\frac{(n-3)!}{(n-i-1)!}+1)$，因此可以递推。左边一项构成数列A002807并具有递推式 $a_n=\frac{(n-1)(n-2)}{2}+na_{n-1}-(n-1)a_{n-2}$，因此也可以递推。

注意到 $10^9$ 的数据范围容易让 $O(n)$ 的递推超时（优化一下应可避免），先打表打出 $10^6|n$ 时的左项和右项，之后分别递推并相减即可。

代码：
```
#include <bits/stdc++.h>
using namespace std;
const long long mod=998244353;
long long preb[1001]=//打表右项
long long prea[1001]=
long long prpa[1001]=//打表左项及其次项（因为左项是二阶递推）
long long t, n, a[3], b;
int main()
{
	cin>>t;
	for(int j=1; j<=t; j++)
	{
		cin>>n;
		if(n%1000000==0)//特判
			cout<<(prea[n/1000000]-preb[n/1000000]+mod)%mod<<endl;
		else if(n%1000000==1)//特判
			cout<<(prea[n/1000000]-(n-2)*(preb[n/1000000]+1)+mod)%mod<<endl;
		else if(n<1000000)//n小于1000000时递推始点与大于时不同，因此也需特判
		{
			for(int i=0; i<=2; i++)
				a[i]=0;
			b=0;//初始化
			for(long long i=3; i<=n; i++)
			{
				a[i%3]=((i-1)*(i-2)/2%mod+i*a[(i+2)%3]%mod-(i-1)*a[(i+1)%3]%mod+mod)%mod;
				b=(i-2)*(b+1)%mod;
			}//运算
			cout<<(a[n%3]-b+mod)%mod<<endl;//输出
		}
		else//递推
		{
			b=preb[n/1000000];
			a[n/1000000*1000000%3]=prea[n/1000000];
			a[(n/1000000*1000000+1)%3]=prpa[n/1000000];
			a[(n/1000000*1000000+2)%3]=0;//初始化
			for(long long i=n/1000000*1000000+1; i<=n; i++)
				b=(i-2)*(b+1)%mod;
			for(long long i=n/1000000*1000000+2; i<=n; i++)
				a[i%3]=((i-1)*(i-2)/2%mod+i*a[(i+2)%3]%mod-(i-1)*a[(i+1)%3]%mod+mod)%mod;//运算
			cout<<(a[n%3]-b+mod)%mod<<endl;//输出
		}
	}
	return 0;
}

```

---

## 作者：qyzyq (赞：0)

看数据范围

——题记

[传送门](https://www.luogu.com.cn/problem/P3862)

考虑记

$f_i$ 表示有 $i$ 个点的完全图的圈数

$g_i$ 表示有 $i$ 个点的完全图中一个点到另一个点不同路径的方案数

$ans$ 表示答案

容易知道递推式

$$f_i=g_{i-1} \times C_{i-1}^2+f_{i-1}$$

$$g_i=g_{i-1} \times (i-2) + 1$$

$$ans=f_{n-1}+g_{n-1}\times C_{n-2}^2$$

因为 $f_i$ 和 $g_i$ 只跟 $f_{i-1}$ 和 $g_{i-1}$ 有关，所以使用滚动数组

然后看**数据范围**

$$9.99\times 10^8\le n\le 10^9$$

我们发现，哪怕是最后一个数据范围，假如知道了 $f_{9.99\times 10^8}$ 和 $g_{9.99\times 10^8}$，最多只用计算 $10^6$ 就可以算出答案（~~原来是这样解决的吗？太神奇了。我想了一小时才想出来~~）

预处理就好，不用多久（用上面那个递推式计算，等一分钟就好了）

上代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll mod=998244353;
ll T,n,f,g;
ll t1=876466444,t2=141309211;
int main()
{
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%lld",&n);
		if(n==3)
		{
			puts("0");
			continue;
		}
		if(n<=1000000)
		{
			f=1,g=2;
			for(ll i=4;i<n;i++) //注意这里假如是 int 的话会爆 int，因为下面有 (i-1)*(i-2) 
			f=(f+g*(((i-1)*(i-2)/2)%mod)%mod)%mod,g=(g*(i-2)%mod+1)%mod;
			printf("%lld\n",(f+g*(((n-2)*(n-3)/2)%mod)%mod)%mod);//同理 n 也要 long long
		}
		else
		{
			f=t1,g=t2;
			for(ll i=998999999;i<n;i++)
			f=(f+g*(((i-1)*(i-2)/2)%mod)%mod)%mod,g=(g*(i-2)%mod+1)%mod;
			printf("%lld\n",(f+g*(((n-2)*(n-3)/2)%mod)%mod)%mod);
		}
	}
	return 0;
}
```

---


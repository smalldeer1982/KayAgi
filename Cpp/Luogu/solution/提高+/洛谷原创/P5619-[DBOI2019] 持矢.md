# [DBOI2019] 持矢

## 题目背景

```cpp
吾射不亦精乎？
——doby
```

## 题目描述

$doby$是一个弓箭手，他很喜欢拿箭。

这天，他来到一个射箭场，发现射箭场老板放好了$n$个靶子（从$1-n$标号），中间画了$n-1$条线，使得这$n$格靶子和$n-1$条线组成了一个**根为**$1$的树。每个靶子上都有分数。

他为了历练自己，选择了一个点（称为父点），然后对它子树（包括它）的每个靶子射一次，每个靶子射中概率为$50\%$。每次射完一个子树，他获得的总分为射中的所有靶子的分数之**积**。

现在他想知道，选择不同的点作为父点，他期望总分为多少？由于总分可能很大，你需要把结果对$19260817$（质数）取模。

## 说明/提示

### 注意：由于模数较大，请注意求逆元时中间结果的溢出。

如果你不需要卡常，使用快速幂求逆元就够用了。

【样例#$1$说明】

答案为$\frac{5}{4}$，可能的总分有$0$，$1$，$2$。

【样例#$2$说明】

答案分别为$9630410$、$10834247$、$15047607$，即$\frac{3}{2}$、$\frac{599}{16}$、$\frac{2999}{32}$。

$Subtask$ #$1$（$10$分）： 

$1\leq n,m\leq 10$。

$Subtask$ #$2$（$40$分）： 

$1\leq n,m\leq 100000$。

$Subtask$ #$3$（$50$分）： 

$1\leq n,m\leq 2000000$。

所有测试点的时间限制统一为$1.5s$，内存限制统一为$125M$。

### 题目提供者：$1jia1$

## 样例 #1

### 输入

```
2 1
1 2
2 1
1```

### 输出

```
14445614```

## 样例 #2

### 输入

```
5 3
4 4 3 4 5
1 2
3 2
2 4
5 4
3
2
1```

### 输出

```
16251447```

# 题解

## 作者：1jia1 (赞：3)

题目大意：给定一棵有根树及每个点的权值，多次询问一个点的子树中所有点的权值构成的多重集中，等概率随机选一个子集，这个子集中所有元素的乘积的期望。

由于题目中每个点被打中的概率都是50%，肉眼可见所有子集被选中概率都是相等的。

题目要求的这个东西，如果看不懂，可以理解成在一个序列中的某一段区间中，所有 子序列的元素乘积 之和。

我们先设一个点的子树中的所有点在一个多重集中，为$x_1$,$x_2$,$x_3$,...

将一个集合中所有元素的乘积表示van。

于是，我们可以列出这个多重集的所有子集的van 之和的计算式：

$$-1+\sum_{i=1}^n (x_i+1)$$

右边的和式的意义是，每个点都有概率被选中。这样，它被选中时对van的贡献就是乘上它本身的数值，没被选中时对van的贡献就是乘1，也就是对答案没有贡献。

左边有一个-1，是因为一个也没打中时的得分是0而不是1，但右边的和式多计算了一个1，所以把它减掉。

具体实现中，只需要一遍dfs，预处理出每个点的size和prod，prod为子树中所有点的权值+1之积。每次询问时，我们便可以O(1)回答。

对于点x，答案就是$\frac{prod[x]-1}{2^{size[x]}}$。

需要注意的是，分母不能简单地用位运算，否则会爆long long。


代码如下：

```cpp
#include <iostream>
#include <cstdio>
#define N 20000001
#define ha 19260817
#define ll long long
int n,m,num[N], h[N],cnt, size[N],prod[N];
struct edge{
	int next,to;
}e[N<<1];
inline void read(int &out)
{
	out=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while('0'<=c&&c<='9')out=out*10+c-'0',c=getchar();
	return;
}
inline void add(int u,int v)
{
	e[++cnt].next=h[u];
	h[u]=cnt;
	e[cnt].to=v;
	return;
}
inline long long div(ll x)
{
	int k=ha-3;
	long long out=x,xx=x;
	while(k)
	{
		if(k&1)out=(out*xx)%ha;
		xx=(xx*xx)%ha;
		k>>=1;
	}
	return out;
}
inline long long pow(ll x,int k)
{
	long long out=x,xx=x;
	k--;
	while(k)
	{
		if(k&1)out=(out*xx)%ha;
		xx=(xx*xx)%ha;
		k>>=1;
	}
	return out;
}
inline void dfs(int x,int fa)
{
	size[x]=1,prod[x]=num[x];
	for(int i=h[x],v;i;i=e[i].next)
	{
		v=e[i].to;
		if(v==fa)continue;
		dfs(v,x);
		size[x]+=size[v],prod[x]=(int)((ll)prod[x]*(ll)prod[v]%ha);
	}
	return;
}
int main()
{
	read(n),read(m);
	for(int i=1;i<=n;i++)read(num[i]),num[i]=(num[i]+1)%ha;
	for(int i=1,u,v;i<n;i++)
	{
		read(u),read(v);
		add(u,v);add(v,u);
	}
	dfs(1,1);
	ll out=0;
	for(int i=1,x;i<=m;i++)
	{
		read(x);
		out=(out+(ll)(prod[x]-1)*(ll)div(pow(2,size[x])))%ha;
	}
	printf("%d\n",out);
	return 0;
}
```


---

## 作者：zzzyyyyhhhhh (赞：1)

根据期望的线性性，设每个点得分期望为 $p_i$，则 

$$p_i=(\frac{1}{2}+\frac{\text{score}_i}{2})\times \displaystyle\prod_{j\in \text{son}_i}p_j$$

发现一个问题，这样计算的话所有点都没射中的情况会对答案有 $\frac{1}{\text{可能结果数}}$ 的贡献，但实际它的贡献为 0 ，所以 $ans_i=p_i-\frac{1}{2^{siz_i}}$，其中$siz_i$ 为 $i$ 的子树大小。

然后树形 dp 求出答案即可，这时会发现一个问题，交上去只有 50，剩下的点全 MLE 了。

为什么呢？两个数组是一定没有问题的，那么问题就出在了 vector 上。因为 vector 本身五元素就占据一定空间且在扩容后会预留 1.5 或 2 倍空间，只能是 vector 导致 MLE 了。但 vector 封装的很好，想要减少空间几乎是不可能的，于是就只能手写一个 vector 了。手写 vector 自身所占空间极小，在读入完成后还可以把预留的空间全部释放，这样和 vector 有关的空间就是严格的 $3\times n+m$ 倍了。卡时间常数可以使用 barret 约减快速取模并预处理 2 的逆元。

下面附上使用 vector 的代码。

```cpppppppppppppppppppppp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e6+1,mod=19260817;
int n,m;
struct Barret{
    long long m,p;
    void init(int pp){m=((__int128)1<<64)/pp;p=pp;}
    long long operator ()(long long x){
        return x-((__int128(x)*m)>>64)*p;
    }
}Ba;
struct vectorr
{
	signed *p;
	signed siz,maxsiz;
	vectorr()
	{
		p=new signed[2];
		maxsiz=2;
	}
	inline void nnew()
	{
		signed *p1=p;
		maxsiz*=1.77;
		p=new signed[maxsiz];
		memcpy(p,p1,siz<<2);
		delete p1;
	}
	inline void push_back(signed x)
	{
		if(siz>=maxsiz-1)
		{
			nnew();
		}
		p[siz++]=x;
	}
	inline signed& operator[](signed x)
	{
		if(x>=siz)return siz;
		return p[x];
	}
	inline signed* begin()
	{
		return p;
	}
	inline signed* end()
	{
		return p+siz;
	}
	inline void era()
	{
		if(siz==0)return;
		siz--;
	}
	void ok()
	{
		signed *p1=p;
		maxsiz=siz;
		p=new signed[maxsiz];
		memcpy(p,p1,siz<<2);
		delete p1;
	}
};
vectorr a[N];
signed qpow(long long x,signed y)
{
	int res=1;
	while(y)
	{
		if(y&1)res=Ba(res*x);
		x=Ba(x*x);
		y>>=1;
	}
	return res;
}
signed f[N];
signed siz[N];
const int ttt=9630409;
void dfs(signed x,signed fa)
{
	siz[x]=1;
	int son=1;
	for(auto i:a[x])
	{	
		if(i==fa)continue;
		dfs(i,x);
		son=Ba(son*f[i]);
		siz[x]+=siz[i];
	}
	f[x]=Ba(son*ttt+son*ttt*f[x]);
}
signed main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	Ba.init(mod);
	signed tmp;
	cin>>tmp;
	n=tmp;
	cin>>tmp;
	m=tmp;;
	for(signed i=1;i<=n;i++)
	{
		cin>>tmp;
		f[i]=tmp;
	}
	int x,y;
	for(signed i=1;i<n;i++)
	{
		cin>>tmp;
		x=tmp;
		cin>>tmp;
		y=tmp;
		a[x].push_back(y);
		a[y].push_back(x);
	}
	for(int i=1;i<=n;i++)
	{
		a[i].ok();
	}
	dfs(1,0);
	int ans=0;
	for(signed i=1;i<=m;i++)
	{
		cin>>tmp;
		x=tmp;
		ans=Ba(ans+Ba(f[x]-qpow(qpow(2,siz[x]),mod-2))+mod);
	}
	cout<<(long long)ans;
}
```

题目名称好评，做完建议去做这次比赛的另一道题捡币。

---

## 作者：caohan (赞：0)

# 思路

先说一下离散随机的期望（本题的）：每个答案乘其出现次数的和除所有答案的出现次数。

套定义：明显发现，这是一个完全二分开的状态，即只有相等的选不选的两种概念。则用乘法原理知,在射中以 $x$ 为根，有 $y$ 个节点的树时，总方案数量为 $\frac{1}{2^y}$。且每种方案只有一次出现机会。即只知道方案总和是多少就行。

在 $x_1\cdots x_n$ 为 $x$ 的子树的点的点权时，方案总和为：

$x_1 \times x_2\times x_3 \cdots x_n+x_1x_2x_4\cdots +\cdots+0$。

可以发现，该式和 $\prod_{1}^{n}(x_i+1)$ 很是相似，就少了一个 $1$。

将其带入后，是 $\prod_{1}^{n}(x_i+1)-1$。

这就可以用 dfs 线性处理了。

再一次套定义后就知道每次的答案是 ${\Large \frac{\prod_{j\in sontree(x)}(x_j+1)}{2^{size(x)}}}$。

最后加点小细节就行了。

# 代码

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int mod=19260817;
struct edge
{
	int to,next;
}es[10000001];
int head[20000001];
int cnt;
inline void add(int u,int v)
{
	es[++cnt].to=v;
	es[cnt].next=head[u];
	head[u]=cnt;
}//链式前向星 
int v[20000001];
int dp[20000001];
int size[20000001];
int n;
int m;
int ans;//定义 
inline long long ksm(long long x,int k)
{
	long long out=1,xx=x;
	while(k)
	{
		if(k&1)out=(out*xx)%mod;
		xx=(xx*xx)%mod;
		k>>=1;
	}
	return out;
}//快速幂 
inline void dfs(int root,int fa)
{
	dp[root]=(v[root])%mod;
	size[root]=1;//加上自己的 
	for(int i=head[root];i;i=es[i].next)//遍历出边 
	{
		int v=es[i].to;
		if(v==fa)
		{
			continue;
		}//不回头 
		dfs(v,root);//先处理下一层 
		dp[root]=(int)((long long)(dp[root])*(long long)(dp[v])%mod);//直接用下层数据，不怕重复 
		size[root]+=size[v];//同理 
	}
}
signed main()
{
	ios::sync_with_stdio(0);
	cin>>n;
	cin>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>v[i];
		v[i]+=1;
		v[i]%=mod;
	}
	for(int i=1;i<n;i++)
	{
		int x,y;
		cin>>x>>y;
		add(x,y);
		add(y,x);
	}//输入，加边 
	dfs(1,1);
	for(int i=1;i<=m;i++)
	{
		int x;
		cin>>x;
		ans=(int)((long long)ans+(long long)(dp[x]-1)*(long long)ksm(ksm(2,size[x]),mod-2)%mod)%mod;//把分数算出来，求和 
	}
	cout<<ans;
    return 0;
}
```


---

## 作者：Daidly (赞：0)

期望：总概率乘以其结果总和。

总概率：$\frac{1}{2^{size(i)}}$，其中 $size(i)$ 表示以 $i$ 为根的子树的大小。

结果总和：

考虑一个简单问题：$n=3,a_1=1,a_2=2,a_3=3$。

共有一下几种情况：$1\times2\times3+1\times2+1\times3+2\times3+1+2+3+0$

共八种情况，其中都不选为 $0$。

发现上面和 $x_1x_2x_3+x_1x_2+x_1x_3+x_2x_3+x_1+x_2+x_3+1$ 很像（几乎一样，但是有一个 $0$ 和 $1$ 的区别）。

$$\prod_{i=1}^3(x_i+1)=(x_1+1)(x_2+1)(x_3+1)=(x_1x_2+x_1+x_2+1)(x_3+1)=x_1x_2x_3+x_1x_3+x_2x_3+x_3+x_1x_2+x_1+x_2+1=x_1x_2x_3+x_1x_2+x_1x_3+x_2x_3+x_1+x_2+x_3+1$$

可以发现以 $i$ 为根的子树的所有方案的答案之和为：

$$\prod_{j\in sontree(i)}(a_j+1)-1$$

其中：

$(a_j+1)$：子树中的每一个点若是被选中则贡献为 $a_i$，若没被选中则贡献为 $1$（乘积不变），加和得到的。

$-1$：因为多项式常数项为 $1$ 最后有剩余，而根据题意为 $0$。

每次询问答案即为：

$$\frac{\prod_{j\in sontree(i)}(a_j+1)-1}{2^{size(i)}}$$

子树大小和贡献可以通过 $O(n)$ dfs 求得。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long

inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}

inline void print(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)print(x/10);
	putchar(x%10^48);
}

const int mod=19260817;

int qpow(int a,int b){
	int ans=1;
	while(b){
		if(b&1)ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}

const int MAXN=2e6+5;
int n,m,a[MAXN],f[MAXN],siz[MAXN],ans;
struct node{
	int next,to;
}e[MAXN<<1];
int head[MAXN],num;

void add(int u,int v){
	e[++num].to=v;
	e[num].next=head[u];
	head[u]=num;
}

void dfs(int x,int fa){
	f[x]=(a[x]+1)%mod;
	siz[x]=1;
	for(int i=head[x];i;i=e[i].next){
		if(e[i].to==fa)continue;
		dfs(e[i].to,x);
		f[x]=f[x]*f[e[i].to]%mod;
		siz[x]+=siz[e[i].to];
	}
}

signed main(){
	n=read(),m=read();
	for(int i=1;i<=n;++i)a[i]=read();
	for(int i=2;i<=n;++i){
		int u=read(),v=read();
		add(u,v);
		add(v,u);
	}
	dfs(1,1);
	for(int i=1;i<=m;++i){
		int x=read();
		ans=(ans+(f[x]-1)*qpow(qpow(2,siz[x]),mod-2)%mod)%mod;
	}
	print((ans+mod)%mod);
	return 0;
}
```

---

## 作者：Tommy_clas (赞：0)

	什么嘛，我打的不是挺准的吗？
    ——1jia1
    你 打 中 了 吗（震声
    ——Tommy_clas
[传送门](https://www.luogu.org/problem/P5619)

题目大意：有一棵$n$个点的有根树，每个点有一个权值，每次从树上的某个子树中获得分数，分数的大小是该子树中所有已经选择的点的权值的**积**，而每个点有$\frac{1}{2}$的概率被选到。求$m$次操作后的分数的**和**的期望值。

由于题目没有修改操作，我们可以把树上每一个子树的答案提前求出，然后求和。

既然是期望，那就直接走期望的线性性，期望$DP$完事了。

但是在测试样例后我们发现答案是错误的。

考虑原因，我们能发现之前的期望$DP$一般都是**和**的期望值，而很少是**积**的期望值，这是因为期望的线性性是：

$E(a+b)=E(a)+E(b)$

而不是：

$E(a\times b)=E(a)\times E(b)$

手动计算一下样例也可以证明这种期望$DP$的做法是错误的。

既然求积不行，我们将点权$v$转化对数$logv$，然后根据公式：

$log(a\times b)=loga+logb$

求出总期望后再转回去如何？

别忘了这是取模求答案，就算不取模，精度也很可能有很大误差。

期望$DP$不行，干脆直接暴力期望？

这里有一个很好的性质：**每个点选与不选的概率是一样的**。由于一棵子树的每一种选择方案的概率都是$\frac{1}{2^{size}}$。

再根据：期望$=$概率$\times$结果

所以我们可以先求出该子树所有选择方案的答案的和，然后乘上概率就行了。但是如何求和呢？

因为每个点的状态是要么选，要么不选，且每个方案的答案是所有已选点的权值的积。所以我们可以考虑一下生成函数。

设$sum_i$表示以$i$为根的子树的所有选取方案的答案的总和。

则有$sum_i=(\prod_{j∈T_i}(v_j+1))-1$

根据多项式乘多项式原理，上述式子涵盖了所有的方案的答案，之所以减$1$，是因为当所有点都不选时，答案应当是$0$。

至于$sum_i$的求法，我们可以在$dfs$树的时候顺便求出，具体可以看代码。

这样就有$ans_i=\frac{sum_i}{2^{size_i}}$

对于每次询问将对应的$ans_i$加起来，然后求和即可。

上代码：
```cpp
//走期望线性性就失败了
//直接暴力期望就可以了 
#include<cstdio>
#define N 2000005
#define ll long long
using namespace std;
int n,m,head[N],cnt,siz[N];
ll dp[N],sum[N],ans=0,inv2[N],v[N];
const ll mod=19260817;
struct edge
{
	int to,nxt;
}w[2*N];
ll quick_pow(ll base,ll x)
{
	ll res=1;
	while(x)
	{
		if(x&1)res=res*base%mod;
		base=base*base%mod,x>>=1;
	}
	return res;
}
void add(int x,int y)
{
	w[++cnt]=(edge){y,head[x]};
	head[x]=cnt;
}
void dfs(int x,int last)
{
	siz[x]=1;
	sum[x]=(v[x]+1)%mod;
	bool tag=0;
	for(int i=head[x];i;i=w[i].nxt)
	{
		int y=w[i].to;
		if(y==last)continue;
		dfs(y,x),tag=1;
		siz[x]+=siz[y];
		sum[x]=sum[x]*sum[y]%mod;
	}
	dp[x]=((sum[x]-1)*inv2[siz[x]]%mod+mod)%mod;
}
void init()
{
	inv2[0]=1;
	ll base=quick_pow(2,mod-2);
	for(int i=1;i<=n;i++)
		inv2[i]=inv2[i-1]*base%mod;
}
int main()
{
	scanf("%d %d",&n,&m);
	init();
	for(int i=1;i<=n;i++)scanf("%lld",&v[i]);
	for(int i=1,x,y;i<n;i++)
		scanf("%d %d",&x,&y),add(x,y),add(y,x);
	dfs(1,0);
	for(int i=1,x;i<=m;i++)
		scanf("%d",&x),ans=(ans+dp[x])%mod;
	printf("%lld\n",ans);
	return 0;
}
```


---


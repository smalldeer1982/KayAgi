# 【L&K R-03】射击场决战

## 题目描述

【如果不想看题面请阅读分割线以下部分】

小 L 与小 K 是两个帮派的首领，也是死敌。某年某月，两个帮派发生了大规模的冲突。小 K 因为实力不敌，被小 L 的爪牙团团包围，最终被逼近了一个大型射击场。小 K 自知大势已去，正准备与小 L 拼死一战时，却传来消息，说小 L 要邀请自己与他来玩一场游戏。小 K 知道其中有鬼，但却别无它计，只能只身前往小 L 指定的会面点。

会面点在射击场旁。小 L 站在场上，满脸笑容地对走来的小 K 招手。“啊，小 K ，好久不见。我记得上次我们见面的时候，还是在那个小酒馆。当时，我与你谈笑风生，指点江山，不亦乐乎。没想到，如今，我们竟到此地步啊！”小 L 顿了顿，继续说道：“你是我曾经的兄弟，我不想以暴力的方式了解你我。正好，我有一个好方法：不如我们用游戏的方式来场决战吧！这样如何，小 K ？”小 K 知道，自己并没有否定小 L 的余地。于是，小 K 点了点头。小 L 看到小 K 点头，又露出了笑容，开始讲起了游戏的规则。

“如你所见，我们的游戏要在这片射击场上进行。射击场总共有 $n$ 行 $m$  列，共 $n\times m$ 个靶。为了方便，取行的方向为左右，列的方向为前后。这个射击场有一个特点：每个靶上都有一个计数器。击中一个靶，这个靶的计数器示数就会加一。但是，每个靶的示数有一个范围，只能是不小于 $0$，不大于 $k$ 的整数。倘若击中一个靶，而在未击中此靶前此靶计数器的示数已经为 $k$，那么击中时，此靶计数器示数就会溢出清 $0$，并产生溢出错误的信号，经电线开始传递。由于靶场电线的特殊布置，信号只会往右侧传递。信号传递过程中会影响若干其它同行靶的计数器。如果这些被影响到的靶计数器示数为 $k$，其同样会溢出清 $0$ 并产生溢出错误信号，与之前的信号叠加（但加一效果不会叠加）；否则，其示数会加一，并发出纠正讯息，截断信号传播，即在其右侧的靶不会继续被信号影响。当然，如果信号一直传递而未被截断，那么它最终会传入信息管理终端。由于信号在传递过程中不断叠加，再加之信息管理终端要处理庞大的信息，纠正错误信号的能力较差，可能会导致终端死机甚至发生爆炸的危险，这是违规的。

“我与你会轮流选择其中一个靶进行一次射击，射击哪个靶由射击者自行决定。如果轮到某个人射击，但他无法进行不违规的射击，那么他就输了。因为这是我设计的游戏，先手当然是我。但是，我也会给你一些选择。靶场上每个靶计数器的初始示数不一定为 $0$，是可以被我设置的。我这里恰好有几种设置方案，但我不知道该选哪种好，可否请你帮我选一选？”

小 L 从口袋里抽出了几张纸条。小 K 一看，每张纸条却没有写每个靶计数器的初始示数，只写着三个数字 $a,b,c$。小 L 所不知道的是，小 K 有着惊人的观察能力，在小 L 讲刚才那一番话之时，小 K 就已经通过分析靶上示数的变化以及电路的布置，得出了计数器初始示数生成的规律。靶场上靶的计数器初始示数是一个个按顺序生成的。并且，生成的顺序是按行优先，从左到右，从上到下。具体来说，是按照第 $1$ 行第 $1,2,\ldots ,m$ 个，第 $2$ 行第 $1,2,\ldots ,m$ 个，……，第 $n$ 行第 $1,2,\ldots ,m$ 个的顺序生成。生成一个计数器的示数需要用到 $a,b,c$ 作为参数。并且，每生成一个计数器的示数，$a,b,c$ 都会产生变化。具体来说，每生成一个计数器的示数，便引用一次以下的函数：

```
typedef unsigned long long ull; 
inline ull generate(ull&a,ull&b,ull&c,ull&k)
{ 
	a<<=19;a+=b+c;
	a<<=26;a^=c+=a+81;b--;
	a<<=7;a>>=(b^c^1145)&14;
	c*=a;a|=b+=c;a^=b&c;
	return a%(k+1);
}
```

函数的返回值即为生成的计数器示数。容易发现，初始示数均为不小于 $0$，不大于 $k$ 的整数，不违反规则。

小 K 知道小 L 是绝顶聪明的人，且一定会以自己的胜利为目标进行游戏。当然，小 K 因为掌握了许多这个游戏的信息，水平不会落后于小 L。小 K 不能违反小 L 制定的规则，否则可能惹恼小 L，使冲突再次爆发。但是，小 K 可以通过计算，得出小 L 给出的方案中哪些是小 L 必胜，哪些是自己必胜的，并选择一个自己必胜的方案进行游戏。

可惜时间不允许小 K 做太长时间的计算。恰好，会编程的你可以帮助小 K 在较短的时间内得出结果。请你帮小 K 算算，在小 L 给出的所有方案中，哪些小 L 必胜，哪些小 L 必败。

-----------------------

考虑到小 L 说的话可能太长以至于难以理解，小 K 决定更为简洁地叙述这个问题。小 L 提供了一个 $n$ 行 $m$ 列的数阵。小 L 与小 K 二人轮流操作，每次可以将数阵中的某个数加上 $1$。若加 $1$ 后此数大于 $k$，则此数清零，将加 $1$ 操作传递给其右侧的数。若某个数需要传递操作，但其右侧没有数，则这个操作对应的人的初始操作将不可进行。最后无法操作的人败。小 L 为先手，二人都绝顶聪明。若小 L 会赢则输出 `YES`，否则输出 `NO`。

数阵里初始的数由小 L 提供。小 L 提供了若干个填充数阵的方案，每个方案中数阵里的数由上文的函数生成，生成顺序从左到右，从上到下。方案的互异性体现在参数 $a,b,c$ 的不同。请你对每种方案给出答案。 **保证生成方式与题目的正确解法无关。** 注意对于每种方案，小 L 实际上提供了六个参数 $k,n,m,a,b,c$，即 $k,n,m$ 在每种方案中也可能各不相同。

## 说明/提示

【样例解释】

两种方案中射击场上都只有一个靶。

对于方案一，此靶计数器上的初始数值为 $0$。小 L 先手射击此靶使其计数器加 $1$。轮到小 K 时，计数器示数为 $1$，不存在不违规射击方案，小 K 输，小 L 赢。

对于方案二，此靶计数器上的初始数值为 $1$，不存在不违规射击方案，小 L 输。

【数据范围】

最多 $20$ 种方案。

| 数据编号 | $n$ 的范围 | $m$ 的范围 | $k$ 的范围 | 特殊性质 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $n=1$ | $1\le m\le5$ | $1\le k\le 5$ | 无 |
| $2$ | $n=1$ | $1\le m\le20$ | $1\le k\le 5$ | 无 |
| $3$ | $n=1$ | $1\le m\le100000$ | $1\le k\le 10^{18}$ | 无 |
| $4$ | $1\le n \le2$ | $1\le m\le100000$ |$1\le k\le 10^{18}$  | 无 |
| $5$ | $1\le n \le100000$ | $m=1$ | $1\le k\le 10^{18}$ | 无 |
| $6$ | $1\le n \le1000$ | $1\le m\le1000$ | $1\le k\le 10^{18}$ | $k$为偶数 |
| $7$ | $1\le n \le50000$ | $1\le m\le20$ | $1\le k\le 10^{18}$ | $k$为偶数 |
| $8$ | $1\le n \le10$ | $1\le m\le100000$ | $1\le k\le 10^{18}$ | $k$为偶数 |
| $9\sim 11$ | $1\le n \le1000$ |$1\le m\le1000$  | $1\le k\le 10^{18}$ | 无 |
| $12\sim 14$ | $1\le n \le50000$ | $1\le m\le20$ | $1\le k\le 10^{18}$ | 无 |
| $15\sim 17$ | $1\le n \le10$| $1\le m\le100000$ | $1\le k\le 10^{18}$ | 无 |

对于所有数据，$k,n,m,a,b,c$ 均为正整数，$1\le a,b,c\le10^{18}$。各数据点分值分布如下：编号为 $1$ 的数据点分值为 $7$；编号为 $9$、$12$、$15$ 的数据点分值为 $5$；其余数据点分值为 $6$。

## 样例 #1

### 输入

```
2
1 1 1 1 1 1
1 1 1 2 2 2```

### 输出

```
YES
NO```

# 题解

## 作者：KesdiaelKen (赞：6)

本题为博弈论+数论题目，只需转化一下模型即可。

生成函数只是个随机函数，按题意生成数据。~~其实是因为直接给数据文件太大无法上传~~

下面分数据编号进行讲评。

## $1$

$m\le5$，用$bool$数组$f[i][j][k][s][t]$表示某个状态下为必胜或必败（指的是面对当前局面人的胜负状态）。$f[k][k][k][k][k]$为末状态，必败。每个状态可以有若干个下接状态（进行一次设计后可以形成的不违规状态）。容易想到，如果所有下接状态均为必胜，则此状态必败；否则必胜。记忆化搜索即可。

## $2$

用$k$减去每个初始示数，题意就可以理解为在任意一个位置上减$1$，不够减则借位。每个数从$0$到$k$。这不就是$k+1$进制的减法吗？于是，题意转化为：给出$n$个数，每次减去$(k+1)^i$，$i$为任意自然数，不能减到小于$0$，轮流操作，问谁会面对全$0$的局面。则考虑每个数的胜负情况（记为$f[i]$）。

对于此点$n=1$，只需考虑一个数的$f[i]$。由于$2$点$m,k$范围较大，不能像$1$那样枚举下接状态。考虑$f[i]$是否具有规律。发现对于$k$的奇偶不同，规律不同：下面分情况证明：

对于$k$为偶数，当$2|i$时$f[i]=false$（败），否则为$true$（胜）。证明：数学归纳法。当$i=0,1$时成立。当$i>1$，由于$2|k$，$2\not|(k+1)^i$，$i-(k+1)^i$与$i$不同奇偶，则若$i$为偶，所有$i-(k+1)^i$为奇，$f[i-(k+1)^i]=true$，则$f[i]=false$。$i$为奇同理。

对于$k$为奇数，当$i>k+1$，$f[i]\equiv f[i\mod (k+2)]$；当$i\le k+1$，$f[i]=true$时$(2\not|i )or(i=k+1)$，$f[i]=false$时$(2|i)and(i\not=k+1)$。证明：数学归纳法。当$i=0\space to\space k+1$时易知成立。当$i>k+1$时，$(k+1)^i=1\space or\space -1(\mod k+2)$，则类似$k$为偶数时进行归纳。

$k$为偶数的时候也可以转化为$f[i]$以$k+2$为循环的规律。

规律得出，则可做。

## $3$

存不下转换后的数。但考虑到最后的数要对$k+2$取模，可以在读入的时候同时取模。因为是$k+1$进制，对于奇数位，模$k+2$的值为$-1$乘此位上的数；对于偶数位，模$k+2$的值为$1$乘上此位上的数。

## $6-8$

有多个数，$k$为偶数。先求出每个初始数的$f$。由以上证明可看到$k$为偶数时，赢状态的所有下接状态都为输状态，而输状态的所有下接状态都为赢状态。末状态所有数都为$0$，有偶数个赢状态。对于所有数，一次射击只能将一个数的$f$变为相反的一个状态。因此对于一个人，他面对的所有数中赢状态总数一定。所以，若先手面对奇数个赢状态则必赢，偶数个则必输。

## $5$

每个数都小于等于$k$，即不可能取到$k$为奇数的特殊状态$i\equiv k+1(\mod k+2)$，等同于$k$为偶数的状态，即赢状态只接输状态，输状态只接赢状态。做法同上。

## $4$

只有两个数，可以进行特殊讨论解决。

## $9-17$

$f[i]$只保存赢或输不能为解决复杂的博弈信息提供足够有效信息。需要使用$sg$**函数**解决（不懂可看[sg函数详解](https://blog.csdn.net/m0_38033475/article/details/80272171)或自行查找资料）。令$f[i]$表示数$i$的$sg$函数值。同上用数学归纳法可证明：$k$为偶数时，将$true$转为$1$，$false$转为$0$即可；$k$为奇数时，对于$i\not\equiv k+1(\mod k+2)$，同上转换，否则$f[i]=2$。之后将每个数的$sg$函数值异或，异或值为$0$时必败，否则必胜。

事实上这个结论不用$sg$函数也可以推的出来。

标程：

```
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<iostream>
#include<string>
using namespace std;
unsigned long long k,a,b,c,sg,x,lc;
inline unsigned long long generate(unsigned long long&a,unsigned long long&b,unsigned long long&c,unsigned long long&k)
{ 
	a<<=19;a+=b+c;
	a<<=26;a^=c+=a+81;b--;
	a<<=7;a>>=(b^c^1145)&14;
	c*=a;a|=b+=c;a^=b&c;
	return a%(k+1);
}
int main()
{
	int n,m,t;scanf("%d",&t);
	while(t--)
	{
		scanf("%lld%d%d%lld%lld%lld",&k,&n,&m,&a,&b,&c);
		x=0;
		for(int i=1;i<=n;i++,x^=sg)
		{
			sg=0;
			for(int j=1;j<=m;j++)
			{
				lc=generate(a,b,c,k);
				sg=(sg+((j&1)?(k-lc):(lc+2)))%(k+2);
			}
			if((k&1)&&sg==k+1)sg=2;
			else sg&=1;
		}
		if(x)printf("YES\n");else printf("NO\n");
	}
	return 0;
}
```

---


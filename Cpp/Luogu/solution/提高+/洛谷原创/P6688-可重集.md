# 可重集

## 题目描述

给出一个长度为 $n$ 的非负整数序列 $a_1,a_2,a_3,\ldots, a_n$，给出 $q$ 次操作，每次先给出一个参数 $op$：

- $op=0$，接下来给出 $2$ 个参数 $x,y$，把 $a_x$ 修改为 $y$。

- $op=1$，接下来给出 $4$ 个参数 $ l_1,r_1,l_2,r_2$（保证 $r_1-l_1=r_2-l_2$），你需要判断区间 $[l_1,r_1]$ 与区间 $[l_2,r_2]$ 是否本质相同，如果本质相同输出 `YES`，否则输出 `NO`。

本质相同的定义：令区间长度为 $\text{len}$ ，序列 $p_{1}\dots p_{\text{len}}$ 为 $a_{l_1}\dots a_{r_1}$ 升序排序后的结果，序列 $q_{1}\dots q_\text{len}$ 为 $a_{l_2}\dots a_{r_2}$ 升序排序后的结果，存在一个整数 $k$ 使得满足 $\forall i,p_i+k=q_i$。

## 说明/提示



- Subtask1 （$25$ pts）：$1\leq n,q \leq 1000$。

- Subtask2 （$25$ pts）：$1\leq n,q \leq 10^5$，$0\leq a_i,y\leq 100$。

- Subtask3 （$25$ pts）：$1\leq n,q \leq 10^5$。

- Subtask4 （$25$ pts）：无特殊限制。

你只有通过 subtask 中的所有测试点才能获得该 subtask 的分数。

对于所有数据满足：$1\leq n,q \leq 10^6$，$1\leq x \leq n$，$0\leq a_i,y \leq  10^6$ 。且对于所有 $l,r$ 有 $1\leq l\leq r\leq n$。



## 样例 #1

### 输入

```
12 6
1 1 4 5 1 4 2 2 5 2 3 3
1 1 3 7 9
1 2 3 5 6
1 1 3 2 4
0 7 1
1 1 4 2 5
1 5 7 8 10```

### 输出

```
YES
YES
NO
YES
YES```

# 题解

## 作者：skydogli (赞：21)

sol of D:

下文令n，q同阶

## subtask1

按照题意模拟，每次把两个区间排序并一一比较即可。时间复杂度$O(n^2\log_2n)$

## subtask2
题意其实是要你判断区间排序后差分数组是否相同，且有一个显然的结论：$k$只有可能是$\min \{a_{l_2}\dots a_{r_2}\}-\{\min a_{l_1}\dots a_{r_1}\}$，于是我们暴力判断2个区间对应的数字个数是否相同即可。可以用树状数组做到$O(nV\log n)$,使用大家高超的分块技巧可以做到时间复杂度$O(n\sqrt{n}+nV)$

## subtask3

维护区间k次方和，然后$O(k^2)$地对于任意$1\leq d \leq k$求出$\sum (a_i+b)^d$，依次比较是否相同即可，时间复杂度$O(nk\log n+nk^2)$,k需要开到$\log n$才能保证正确性。

[k较小的hack方法](https://www.luogu.com.cn/discuss/show/105778)

## subtask4

我们本质上是要求每个数在区间中出现的次数相同，如果给每个数一个随机的映射值$\operatorname{Hash_v}$，两个区间的映射值是否相同就可以作为两区间是否本质相同的依据。

现在关键问题变成了如何把$a_l\dots a_r$的哈希值快速转化为$a_l+k\dots a_r+k$的哈希值？

令$\operatorname{Hash_v}=\operatorname{g^v}$即可快速转换。


tips:很多人被卡常都是因为使用了线段树，用线段树是因为要求带修区间最小值，事实上并不必要，两区间的和之差除以区间长度就是题目中的k，所以可以直接用树状数组维护。

---

## 作者：Singercoder (赞：11)

# 构造特征函数

首先可重集这个标题很有启示作用，这也是题意要求我们的，把序列中的每个区间看做一个可重集。

那么询问两个区间本质是否相同，实际上就是要我们对区间维护一个特征函数，使得其可以代表这个可重集。

而且因为忽略可重集的差值，所以这个特征函数，还必须是在自变量加减后容易得到对应函数值的。（比如$\log(x)$就不是很合适，因为对x加减后的函数值并不容易得出）

容易想到的是一些奇奇怪怪的多项式函数或者指数函数，在数据点确定的情况下可以很好地通过此题，但刻意构造数据将其hack也是完全可行的。（~~也就是说在cf早就火葬场了~~）

所以我们最终选择一个非常好用且基本无法被hack的特征函数：$\sin(x)$

# 线段树维护

形式化地来说，对于一个区间，我们要维护的是$\sum \sin(a_i - \min(a_i))$

因此需要用线段树维护的信息有：$\sin(a_i),\cos(a_i),\min(a_i)$

```cpp
#include<bits/stdc++.h>

#define gc() getchar()

#define ri register int 
#define db double

#define inf 0x3f3f3f3f

using std::min;

inline int read()
{
	int ret=0;char ch=gc();
	while(!isdigit(ch))ch=gc();
	while(isdigit(ch))
	{
		ret=ret*10+ch-'0';
		ch=gc();
	}
	return ret;
}

const int MAXN=1e6+10;

int n,m;
int b[MAXN];

struct node
{
	int v;
	db s,c;
	node(int V=0,db S=0,db C=0):v(V),s(S),c(C){}
};

struct Segment_tree
{
	node a[MAXN*4];
	#define ls (u<<1)
	#define rs (u<<1|1)
	inline void push_up(int u)
    {
        a[u]=node(min(a[ls].v,a[rs].v),a[ls].s+a[rs].s,a[ls].c+a[rs].c);
   	}
	void build(int u,int l,int r)
	{
		if(l==r)
			a[u]=node(b[l],sin(b[l]),cos(b[l]));
		else
		{
			int mid=(l+r)/2;
			build(ls,l,mid);
			build(rs,mid+1,r);
			push_up(u);
		}
	}
	void assign(int u,int l,int r,int p,int v)
	{
		if(l==r)
			a[u]=node(v,sin(v),cos(v));
		else
		{
			int mid=(l+r)/2;
			if(p<=mid)assign(ls,l,mid,p,v);
			else assign(rs,mid+1,r,p,v);
			push_up(u);
		}
	}
	node ask(int u,int l,int r,int ql,int qr)
	{
		if(ql<=l && r<=qr)
            return a[u];
		else
		{
			int mid=(l+r)/2;
			node ret=node(inf,0,0);
			if(ql<=mid)ret=ask(ls,l,mid,ql,qr);
			if(mid+1<=qr)
			{
				node t=ask(rs,mid+1,r,ql,qr);
				ret=node(min(ret.v,t.v),ret.s+t.s,ret.c+t.c);
			}
			return ret;
		}
	}
	#undef ls
	#undef rs
}tree;

int main()
{
//	freopen("in.in","r",stdin);
	
	n=read();m=read();
	for(ri i=1;i<=n;++i)b[i]=read();
	tree.build(1,1,n);
	
	ri op,l1,r1,l2,r2;
	for(ri i=1;i<=m;++i)
	{
		op=read();
		if(!op)
		{
			l1=read();r1=read();
			tree.assign(1,1,n,l1,r1);
		}
		else
		{
			l1=read();r1=read();
			l2=read();r2=read();
			node a1=tree.ask(1,1,n,l1,r1);
			node a2=tree.ask(1,1,n,l2,r2);
			db ans1=a1.s*cos(a1.v)-a1.c*sin(a1.v);
			db ans2=a2.s*cos(a2.v)-a2.c*sin(a2.v);
			if(fabs(ans1-ans2)<1e-9)puts("YES");
			else puts("NO");
		}
	}
	
	return 0;
}
```

---

然而由于卡时限，最后一个subtask怎么也过不去，所以我们考虑用zkw线段树实现。

事实证明其常数很小，最慢的一个点也只跑了700ms

```cpp
#include<bits/stdc++.h>

#define gc() getchar()

#define ri register int 
#define db double

#define inf 0x3f3f3f3f

using std::min;

inline int read()
{
	int ret=0;char ch=gc();
	while(!isdigit(ch))ch=gc();
	while(isdigit(ch))
	{
		ret=ret*10+ch-'0';
		ch=gc();
	}
	return ret;
}

const int MAXN=1e6+10;

int n,m;

struct node
{
	int v;
	db s,c;
	node(int V=0,db S=0,db C=0):v(V),s(S),c(C){}
};

struct Segment_tree
{
	int sz=1;
	node a[MAXN*4];
	#define ls (u<<1)
	#define rs (u<<1|1)
	inline void push_up(int u)
    {
        a[u]=node(min(a[ls].v,a[rs].v),a[ls].s+a[rs].s,a[ls].c+a[rs].c);
    }
	void build()
	{
		while(sz<n+2)sz<<=1;
		for(ri i=1;i<=n;++i)
		{
			int v=read();
			a[i+sz]=node(v,sin(v),cos(v));
		}
		a[sz]=node(inf,0,0);
		for(ri i=n+1+sz;i<=sz-1+sz;++i)a[i]=node(inf,0,0);
		for(ri i=sz-1;i>=1;--i)push_up(i);
	}
	void assign(int p,int v)
	{
		p+=sz;
		a[p]=node(v,sin(v),cos(v));
		p>>=1;
		while(p){push_up(p);p>>=1;}
	}
	node ask(int l,int r)
	{
		l+=sz-1;r+=sz+1;
		node ret=node(inf,0,0);
		while(l!=(r^1))
		{
			if(!(l&1))ret=node(min(ret.v,a[l^1].v),ret.s+a[l^1].s,ret.c+a[l^1].c);
			if(r&1)ret=node(min(ret.v,a[r^1].v),ret.s+a[r^1].s,ret.c+a[r^1].c);
			l>>=1;r>>=1;
		}
		return ret;
	}
	#undef ls
	#undef rs
}tree;

int main()
{
//	freopen("in.in","r",stdin);
	
	n=read();m=read();
	tree.build();
	
	ri op,l1,r1,l2,r2;
	for(ri i=1;i<=m;++i)
	{
		op=read();
		if(!op)
		{
			l1=read();r1=read();
			tree.assign(l1,r1);
		}
		else
		{
			l1=read();r1=read();
			l2=read();r2=read();
			node a1=tree.ask(l1,r1);
			node a2=tree.ask(l2,r2);
			db ans1=a1.s*cos(a1.v)-a1.c*sin(a1.v);
			db ans2=a2.s*cos(a2.v)-a2.c*sin(a2.v);
			if(fabs(ans1-ans2)<1e-9)puts("YES");
			else puts("NO");
		}
	}
	
	return 0;
}
```



---

## 作者：Piwry (赞：8)

~~先提前码好题解等开放通道了交~~

话说今天讲课时有听到一道类似的题目

然后底下就有人提到 "luogu月赛"，于是我就去月赛翻了翻，然后找到了这道题qwq

## 解析

题目相当于是询问两个数列区间排序后对应的相邻元素的差是否完全相等，并且支持单点修改

想要比较区间是否相等，有一个思路就是将所有元素分别乘一个 $\text{base}$ 值的幂并求和，用哈希比较。一般来说 $\text{base}$ 的幂是按元素在**序列内位置**来决定的

但题目还要求我们将这些元素排序。这时就可以想到在 $\text{base}$ 的幂上做手脚；具体来说，因为此时**元素在序列内的位置不再重要**，我们不按元素在序列内位置，而是按**元素的值**来决定 $\text{base}$ 的幂

例如设 $\text{base}$ 为 $3$，则序列 $1, 1, 4, 5, 1, 4$ 的哈希值就为 $3^1+3^1+3^4+3^5+3^1+3^4$

至于 "相邻元素的差"，我们再维护一个区间最小值，在比较前给最小值较小的区间的哈希值乘上一个**补偿值**，使得它们哈希值式子的最小幂次相等，这样就可以比较了

## CODE

代码方面没什么好说的，标准线段树就行了

$\text{base}$ 的值~~应该随便选个数都可以~~（upd）建议比 $n$ 要大（避免底幂的 $\text{base}$ 组合成高幂的 $\text{base}$）（代码里就懒得改了qwq），而哈希的模数为了避免冲突最好选尽量大的质数

另外注意有几个点有点卡常，可以每次查询一次性查区间哈希和最小值，节省些常数

```cpp
#include <cstdio>
#include <iostream>
using std::min;
using std::pair;
using std::swap;
typedef pair<int, int> pad;

const int MAXN =1e6+50;
const int X =2, M =1e9+7;

/*------------------------------Seg------------------------------*/

int mn[MAXN<<2], sum[MAXN<<2], pow[MAXN];
int N =1;

inline void pushup(int x){
	mn[x] =min(mn[x<<1], mn[(x<<1)|1]);
	sum[x] =(sum[x<<1]+sum[(x<<1)|1])%M;
}

void modify(int pos, int val, int x =1, int nl =1, int nr =N){
	if(nl == nr){
		mn[x] =val;
		sum[x] =pow[val];
		return;
	}
	int mid =(nl+nr)>>1;
	if(pos <= mid) modify(pos, val, x<<1, nl, mid);
	else modify(pos, val, (x<<1)|1, mid+1, nr);
	pushup(x);
}

/*first -> mn, second -> sum*/
pad query(int l, int r, int x =1, int nl =1, int nr =N){
	if(l == nl && r == nr)
		return pad(mn[x], sum[x]);
	int mid =(nl+nr)>>1;
	if(r <= mid) return query(l, r, x<<1, nl, mid);
	else if(l >= mid+1) return query(l, r, (x<<1)|1, mid+1, nr);
	else{
		pad ret1 =query(l, mid, x<<1, nl, mid),
			ret2 =query(mid+1, r, (x<<1)|1, mid+1, nr);
		(ret1.second +=ret2.second) %=M;
		ret1.first =min(ret1.first, ret2.first);
		return ret1;
	}
}

/*------------------------------Main------------------------------*/

inline int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return x;
}

inline void prepow(){
	pow[0] =1;
	for(int i =1; i < MAXN; ++i)
		pow[i] =1ll*pow[i-1]*X%M;
}

int main(){
	prepow();
	int n =read(), m =read();
	while(N < n) N <<=1;
	for(int i =N; i < N+n; ++i)
		mn[i] =read(), sum[i] =pow[mn[i]];
	for(int i =N-1; i >= 1; --i)
		pushup(i);
	for(int i =0; i < m; ++i){
		int op =read();
		if(op == 0){
			int x =read(), y =read();
			modify(x, y);
		}
		else{
			int l1 =read(), r1 =read(), l2 =read(), r2 =read();
			pad q1 =query(l1, r1), q2 =query(l2, r2);
			if(q1.first > q2.first)
				swap(q1, q2);
			if(1ll*q1.second*pow[q2.first-q1.first]%M == q2.second)
				puts("YES");
			else
				puts("NO");
		}
	}
}
```

---

## 作者：a___ (赞：6)

## 序：
这题其实不难，就是在线段树上用 hash 维护一个值。结果我比赛时光想到数组、`bitset`、`string` 都不能用，就是没想到用哈希。。。（wtcl）   

___

## 引言：   
考虑如何表示一个数在集合中出现了几次。最简单的方法是使用数组维护一个桶，即：   
```cpp
int i,tot[M];
for(i=1;i<=n;i++)
	++tot[a[i]];//这个数每出现一次，它的出现次数加一
for(i=0;i<=m;i++)
	printf("%d\n",tot[i]);
```    
其中 $n$ 表示数集大小， $m$ 表示数的范围上界，$tot_i$ 表示数 $i$ 的出现次数。    

但是使用一个数组表示显然太麻烦，我们考虑使用字符串的形式表示，如：   
```cpp
string s;
s.resize(M);
for(i=0;i<=m;i++)
	s[i]=tot[i];
```   
显然这样表示一个数集时空复杂度仍然是 $\mathbf O(M)$ ，且一个 `char` 也存不下 `int` ，仍然不可行。   

然而，我们可以就此从字符串哈希中得到灵感。我们可以 **把之前那个假想的字符串哈希成一个值**！在字符串哈希的正确率下，如果哈希值相等，则两字符串相同；**同理，如果我们对 $tot_i$ 数组哈希，哈希值相等的具有相同的 $tot_i$ 数组，即具有相同的数集**！ 

____

## 可行性证明：   
以下证明均建立在整数哈希完全正确的假设下：    
考虑一个数组 $a_0,a_1,a_2,\dots,a_m$ 取值范围在 $[0,n]\cap N$ 之内。我们用一个 **大于$n$** 的值 $base$ 为基数进行哈希。那么我们可以把哈希值（不取模）表示为一个 $base$ 进制数 $\overline{a_m\dots a_2a_1a_0}$，相当于 $a_0 + a_1 * base + a_2 * base^2 + \dots + a_m * base^m$。   
因为对于 $\forall i$ ，   
1. $base$ 进制下 $\forall X=\overline{x_{i-1}\dots x_2x_1x_0}$ 即 $x_0 + x_1 * base + x_2 * base^2 + \dots + x_{i-1} * base^{i-1}$ ，有 $X<1 * base^i$    
2. $base$ 进制下 $\forall X=\overline{x_m\dots x_{i+2}x_{i+1}0\dots 0}$ 即 $x_{i+1} * base^{i+1} + x_{i+2} * base^{i+2} + \dots + x_m * base^m$ ，有 $X> (base-1) * base^i $  

所以两哈希值相等任意两位上的数相同。   

简单理解一下，考虑对于数 $a_i$ ，$a_i * base^i$ 一定不等于任意另外一个 $a_j * base^j$ 因为 $base^i$ 和 $base^j$ 至少差了 $base$ 倍，而 $a_i$ 取值最大只有 $n<=base-1$ 。    
实在不明白可以参考字符串哈希基数为什么要取131，因为131比任何一个字符的ASCII值都大。   
由于以上已经证明本算法同整数哈希正确性相同，故正确率应为整数哈希或字符串哈希正确率。   

______

## 具体实现：   
以上，我们拥有了一个 $\mathbf O(N+M)$ 计算， $\mathbf O(1)$ 比较两数集是否相同的算法。我们首先可以得到一个 $\mathbf O(N)$ 计算哈希值的做法：   
（预处理出所有 $base^i$ 后，）为了计算 $tot_0 + tot_1 * base + tot_2 * base^2 + \dots + tot_m * base^m$，显然，对于一个数 $i$ 对答案的贡献是 $1 * base^i$ （考虑 $tot_i$ 个 $i$ 对答案的贡献为 $tot_i * base^i$）。    
于是：   
```cpp
for(i=1;i<=n;i++)
	hashnum+=base_pow[a[i]];
```   
同时，我们恰好可以容易地得到一个 $\mathbf O(1)$ 比较两个数集是否刚好对应项差 $k$ 的算法：因为
$$tot_0 * base^{0+k} + tot_1 * base^{1+k} + tot_2 * base^{2+k} + \dots + tot_m * base^{m+k}$$   
$$=(tot_0 + tot_1 * base + tot_2 * base^2 + \dots + tot_m * base^m) * base^k$$   
所以对应项差 $k$ 的两数集刚好差 $base^k$ 倍。  

到现在为止，一切预先准备结束了，我们终于可以开始考虑线段树了。考虑如果用线段树维护区间哈希值（区间合并时直接相加，~~想一想为什么qwq~~）和最值，单点修改，区间查询，询问时直接算最值相差的大小 $\Delta$，比较区间对应项差值是否刚好等于 $\Delta$ 即可。

___

## 代码：
使用双哈希以保证正确性，线段树维护区间，最慢点用时少于1s。   
[代码（有多处细节错误）](https://www.luogu.com.cn/paste/frimehgz)   
[正解（代码公开计划）](https://www.luogu.com.cn/record/35849961)   
你可以在最优解第5页（可能你们看到这篇题解时已经被各位dalao挤到第6页了qwq）看到我的AC记录。   

ps：~~谁说这题卡常的，我双哈希都没跑满1s。qwq~~（加了IO的不配说这句话）   
ps2：~~这题总时间算法咋这么毒瘤，竟然每个subtask选最快点求和。~~   
ps3：~~数据真的水，我第一次交忘了 `pushup`，竟然只是每个 `task` WA了一个点。~~     
ps4：出题人说基数用1145141（这数字，绝了），因为可能是原根，但这属于整数哈希算法正确性问题，不予讨论。~~（其实是我不会qwq）~~    

____

## HACK：
上述证明可以证明我的算法是正确的，相反，有些哈希方法则是错误的，以下举例进行hack。  
1. 维护区间和   
	显然错误，例
    ```plain
    10 1
    1 2 3 4 5 1 3 3 3 5
    1 1 5 6 10
    ```
    正解为 `NO` ，输出为 `YES` 。
2. 维护较小值的次方和（哈希基数过小）   
	会出现 $base * base^i = 1 * base^{i+1} $的情况，以基数（底数）为 $3$ 的为例
    ```plain
    12 1
	1 3 3 3 6 7 1 4 5 5 5 7
	1 1 6 7 12
    ```
    正解为 `NO` ，输出为 `YES` 。   
    这里提供一份能生成一组数据卡掉全部基数（底数）为 $[1,1e5]$ 的数据生成器：[这里](https://www.luogu.com.cn/paste/zhbf9ifw)   
3. 其他
	1. 乱七八糟的错误哈希法   
    	随便卡卡就好   
        例如维护了%2余数，%3余数以及区间和的做法：   
        ```plain
        10 1
        1 2 97 100 1 7 92 100
        1 1 5 6 10
        ```   
        正解为 `NO` ，输出为 `YES` 。  
        
        听说出题人还构造了一组数据卡掉了求次方和的做法Orz qwq   
        其实还有一种sincos的做法，应该也可以卡掉，但我懒得算实数。。。    
    2. 单哈希   
    	参考字符串哈希中卡单哈希的做法   
    3. 双哈希   
    	~~毒瘤出题人难道还想卡双哈希？？？qwq~~   

____

## THE END.

---

## 作者：ADay (赞：4)


[更好的阅读体验](https://www.cnblogs.com/-aday/p/solution-p6688.html)

一种rp只要好一点就不会被hack的玄学方法。。。

首先还是构造特征函数。对于一段区间，我们维护它的和与最大值。显然在两个满足题意的区间中， $max_1=max_2+k;sum_1=sum_2+k\times len$ 。如果我们直接这么判断，有很大概率被hack掉。

 注意到一个性质： $X^a \cdot X^b=X^{a+b}$ ，则不难发现 $(\sum X^{a_i})\cdot X^b=\sum X^{a_i+b}$ 。那么因为对于两个满足题意的区间有 $\sum\limits_{i=l1}^{r1}(a_i+k)=\sum\limits_{i=l2}^{r2}a_i$ ，所以 $(\sum\limits_{i=l1}^{r1}X^{a_i})\cdot X^k=\sum\limits_{i=l2}^{r2}X^{a_i}$ 。

如果我们维护一个区间的 $sum'=\sum\limits_{i=l}^r X^{a_i}$与 $max$ ， 那若 $sum'_1\cdot X^{max_2-max_1}=sum'_2$ ，则满足条件。

这里的 $X$ 取多少呢？其实这就是玄学所在， $X$ 取随机值！只要 $X\not=1$ 就行。

然后用zkw线段树维护 $sum'$ 和 $max$ 即可。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define rg register
#define il inline
#define cs const
#define sta static
#define opr operator
#define inf LONG_LONG_MAX
#define fp(i,x,y) for(rg int i=(x);i<=(y);++i)
#define fd(i,x,y) for(rg int i=(x);i>=(y);--i)
il int read()
{//快读
    int _s=0,_f=1;char _ch=getchar();
    for(;!isdigit(_ch);_ch=getchar())if(_ch=='-')_f=-1;
    for(;isdigit(_ch);_ch=getchar())_s=_s*10+_ch-'0';
    return _s*_f;
}
cs int N=1e6+5,mod=1e9+7,X=rand()+1;//保证X>1
int n,m,q;
int powX[N];//X的幂
struct node
{
    int sum,//区间sum'
        maxv;//区间max
    il node opr+(cs node& x)cs{return (node){(sum+x.sum)%mod,max(maxv,x.maxv)};}
    //定义加法
}a[N<<2];
void build()
{
    n=read();q=read();
    for(m=1;m<=n+1;m<<=1)"YOU AK WC2020";//stO
    fp(i,m+1,m+n)a[i].maxv=read(),a[i].sum=powX[a[i].maxv];
    fd(i,m-1,1)a[i]=a[i<<1]+a[i<<1|1];//即pushup
}
il void mdf(int s,int k)
{//单点修改
    a[s+=m].sum=powX[k];
    a[s].maxv=k;//直接修改叶子节点
    for(s>>=1;s;s>>=1)a[s]=a[s<<1]+a[s<<1|1];
    //一层层pushup
}
il node ask(int s,int t)
{//区间查询
    node res=(node){0,-inf};
    for(s=m+s-1,t=m+t+1;s^t^1;s>>=1,t>>=1)
    {//重载加法的用处↓
        if(~s&1)res=res+a[s^1];
        if(t&1)res=res+a[t^1];
    }
    return res;
}
il bool check(int l1,int l2,int r1,int r2)
{//检查是否满足
    node l=ask(l1,l2),r=ask(r1,r2);
    int m1=l.maxv,m2=r.maxv,s1=l.sum,s2=r.sum;
    if(m1==m2&&s1==s2)return 1;//都相等
    if(m1<m2)return s1*powX[m2-m1]%mod==s2;
    //计算判断
    else return s2*powX[m1-m2]%mod==s1;
}
signed main()
{
    srand(time(0));//当然也可以srand(1******7)
    powX[0]=1;fp(i,1,N)powX[i]=powX[i-1]*X%mod;
    build();
    while(q--)
    {
        int op=read(),x=read(),y=read(),xx,yy;
        if(op==0)mdf(x,y);
        else xx=read(),yy=read(),puts(check(x,y,xx,yy)?"YES":"NO");
    }
    return 0;
}
```

听说`WC2020`快出分了，祝各位神仙`rp++`!

---

## 作者：Vocalise (赞：4)

赛时没过，只有 `50 pts`。

下面会讲到 `Subtask` $1,2$ 及 $4$。

## Subtask1

显然可以每次直接单点修改，暴力抽取区间排序检查。复杂度是 $O(qn\log n)$ 的。这里 `25pts`。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>

inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
	do x = x * 10 + ch - 48, ch = getchar(); while(ch >= '0' && ch <= '9');
	return x * f;
}

const int MAXN = 100001;

int n,q,a[MAXN],t1[MAXN],t2[MAXN];

int main() {
	n = read(), q = read();
	if(n > 1000 || q > 1000) return 0;
	for(int i = 1;i <= n;i++) a[i] = read();
	while(q--) {
		int op = read(),l1,r1,l2,r2;
		if(op == 0) l1 = read(), r1 = read(), a[l1] = r1;
		else {
			l1 = read(), r1 = read(), l2 = read(), r2 = read();
			for(int i = l1;i <= r1;i++) t1[i - l1] = a[i];
			for(int i = l2;i <= r2;i++) t2[i - l2] = a[i];
			std::sort(t1,t1 + r1 - l1 + 1);
			std::sort(t2,t2 + r2 - l2 + 1);
			bool ok = true;
			for(int i = 1;i < r1 - l1 + 1;i++)
				if(t2[i] - t1[i] != t2[0] - t1[0]) {
					ok = false; break;
				}
			if(ok) std::puts("YES");
			else std::puts("NO");
		}
	}
	return 0;
}
```

## Subtask2

这里有非常小的值域 $0\le\forall a_i,y\le 100$，于是我们想到每种颜色分开统计即可。

考虑单点修改，区间求和。显然可以树状数组，即每一个值域有一个树状数组，修改时对应位置修改 $2$ 次，询问时值域次求和，得到区间上的分布。

那么这两个区间的分布是否合法，显然可以用它们的能否平移得到另一个来判断了。

复杂度 $O(nV\log n)$，$V$ 为值域。

结合 `Subtask1` 有 `50pts`。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>

const int MAXN = 1000001;
const int SIZE = 201;

inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
	do x = x * 10 + ch - 48, ch = getchar(); while(ch >= '0' && ch <= '9');
	return x * f;
}

int n,q,a[MAXN];
int t1[MAXN],t2[MAXN];
int f[SIZE][MAXN],s1[SIZE],s2[SIZE];

int lowbit(int x) { return x & (-x); }

void Add(int i,int j,int x) {
	for(;j <= n;j += lowbit(j))
		f[i][j] += x;
}

int Query(int i,int j) {
	int res = 0;
	for(;j;j -= lowbit(j)) res += f[i][j];
	return res;
}

int main() {
	n = read(), q = read();
	if(n <= 1000 && q <= 1000) {
		for(int i = 1;i <= n;i++) a[i] = read();
		while(q--) {
			int op = read(),l1,r1,l2,r2;
			if(op == 0) l1 = read(), r1 = read(), a[l1] = r1;
			else {
				l1 = read(), r1 = read(), l2 = read(), r2 = read();
				for(int i = l1;i <= r1;i++) t1[i - l1] = a[i];
				for(int i = l2;i <= r2;i++) t2[i - l2] = a[i];
				std::sort(t1,t1 + r1 - l1 + 1);
				std::sort(t2,t2 + r2 - l2 + 1);
				bool ok = true;
				for(int i = 1;i < r1 - l1 + 1;i++)
					if(t2[i] - t1[i] != t2[0] - t1[0]) {
						ok = false; break;
					}
				if(ok) std::puts("YES");
				else std::puts("NO");
			}
		}
	} else {
		for(int i = 1;i <= n;i++) f[a[i] = read()][i]++;
		for(int i = 0;i <= 100;i++)
			for(int j = 1;j <= n;j++)
				if(j + lowbit(j) <= n) f[i][j + lowbit(j)] += f[i][j];
		while(q--) {
			int op = read(),l1,r1,l2,r2;
			if(op == 0) {
				l1 = read(), r1 = read();
				Add(a[l1],l1,-1); Add(r1,l1,1);
				a[l1] = r1;
			} else {
				l1 = read(), r1 = read(), l2 = read(), r2 = read();
				for(int i = 0;i <= 100;i++) {
					s1[i] = Query(i,r1) - Query(i,l1 - 1);
					s2[i] = Query(i,r2) - Query(i,l2 - 1);
				}
				// for(int i = 0;i <= 10;i++) std::printf("%d ",s1[i]);
				// std::putchar('\n');
				// for(int i = 0;i <= 10;i++) std::printf("%d ",s2[i]);
				// std::putchar('\n');
				int i1 = 0; while(!s1[i1]) i1++;
				int i2 = 0; while(!s2[i2]) i2++;
				// std::printf("i1 = %d i2 = %d\n",i1,i2);
				bool ok = true;
				for(;i1 <= 100 && i2 <= 100;i1++, i2++)
					if(s1[i1] != s2[i2]) ok = false;
				if(ok) std::puts("YES");
				else std::puts("NO");
			}
		}
	}
	return 0;
}
```

但出题人说也可以分块做。

具体地，对每种颜色维护：整块前缀和与块中前缀和。

容易发现预处理是 $O(nV)$ 的。

对于修改操作，显然直接改即可，单次 $O(\sqrt n)$。

同时它的查询可以做到单次 $O(V)$，对于每种颜色用整块和减去左右端散块和即可。

总复杂度是 $O(nV+q\sqrt n +qV)$ 即 $O(n\sqrt n+nV)$ 的。因为值域太小，所以我们可以用这个方法。

同样可以得到 `50pts`。下面只有 `Sub2` 分块的部分。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>

const int MAXN = 1000001;
const int MAXS = 1003;

inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
	do x = x * 10 + ch - 48, ch = getchar(); while(ch >= '0' && ch <= '9');
	return x * f;
}

int n,q,a[MAXN];
int len,bs,lf[MAXS],rg[MAXS],bl[MAXN];
int sum[101][MAXS],p[101][MAXS][MAXS];
int t1[101],t2[101];

int main() {
	n = read(), q = read();
	for(int i = 1;i <= n;i++) a[i] = read();
	len = sqrt(n), bs = n / len;
	for(int i = 1;i <= bs;i++) {
		lf[i] = (i - 1) * len + 1;
		rg[i] = i * len;
	}
	if(n % len) {
		bs++;
		lf[bs] = rg[bs - 1] + 1;
		rg[bs] = n;
	}
	for(int i = 1;i <= n;i++) bl[i] = (i - 1) / len + 1;
	for(int i = 1;i <= bs;i++) {
		for(int j = 0;j <= 100;j++) sum[j][i] = sum[j][i - 1];
		for(int j = lf[i];j <= rg[i];j++) sum[a[j]][i]++;
		for(int j = lf[i];j <= rg[i];j++) {
			for(int k = 0;k <= 100;k++) p[k][i][j - rg[i - 1]] = p[k][i][j - rg[i - 1] - 1];
			p[a[j]][i][j - rg[i - 1]]++;
		}
	}
	int op,l1,r1,l2,r2,x,y;
	while(q--) {
		op = read();
		if(op == 0) {
			x = read(), y = read();
			for(int i = bl[x];i <= bs;i++) sum[a[x]][i]--, sum[y][i]++;
			for(int i = x;i <= rg[bl[x]];i++) p[a[x]][bl[x]][i - rg[bl[x] - 1]]--, p[y][bl[x]][i - rg[bl[x] - 1]]++;
			a[x] = y;
		} else {
			l1 = read(), r1 = read(), l2 = read(), r2 = read();
			memset(t1,0,sizeof(t1)), memset(t2,0,sizeof(t2));
			for(int i = 0;i <= 100;i++) {
				t1[i] = sum[i][bl[r1]] - sum[i][bl[l1] - 1];
				t1[i] -= p[i][bl[l1]][l1 - 1 - rg[bl[l1] - 1]];
				t1[i] -= sum[i][bl[r1]] - sum[i][bl[r1] - 1] - p[i][bl[r1]][r1 - rg[bl[r1] - 1]];
			}
			for(int i = 0;i <= 100;i++) {
				t2[i] = sum[i][bl[r2]] - sum[i][bl[l2] - 1];
				t2[i] -= p[i][bl[l2]][l2 - 1 - rg[bl[l2] - 1]];
				t2[i] -= sum[i][bl[r2]] - sum[i][bl[r2] - 1] - p[i][bl[r2]][r2 - rg[bl[r2] - 1]];
			}
			int i1 = 0; while(!t1[i1]) i1++;
			int i2 = 0; while(!t2[i2]) i2++;
			bool ok = true;
			for(;i1 <= 100 && i2 <= 100;i1++, i2++)
				if(t1[i1] != t2[i2]) ok = false;
			if(ok) std::puts("YES");
			else std::puts("NO");
		}
	}
	return 0;
}

```

`Sub3` 说是维护 $k$ 次幂和，但是并不会。不过思路和 `Sub4` 接近。

## Subtask4

发现似乎比前面更简单（？）

回归题目，我们只需判定即可，不必要还原整段数据。又没有什么好的方法来维护排序后的区间。

于是考虑用类似 $\operatorname{Hash}$ 的方法来判定区间合法。

区间和？太不精确。

区间平方甚至 $k$ 次方和？可以，但能卡。

~~区间 $\sin$，$\cos$？没错的确可以，不过作者还是不会。~~

区间指数和。

在 $\pmod p$ 下讨论。

首先考虑判定，显然有原题面中 $k$ 为 $\min_a[l2,r2]-\min_a[l1,r1]$。

则设选定的底数为 $g$，当 $[l1,r1]$ 区间和 $\times g^k=$ $[l2,r2]$ 区间和时合法。

于是线段树上单点修改，维护 $\min$，指数和即可。

为什么这个 $\operatorname{Hash}$ 比较优秀呢？

首先我们发现两个区间，只有每种数出现次数相同才会判定相同。两种数的和差或其它关系不作考虑。于是把数放上指数再做和，解决了这个问题。

其次我们选定的 $p$ 最好有一个不小的原根，$g$ 即为原根，因为原根的阶是最大的，所以保证了模意义下的幂不会冲突。

原根稍大（最好大于 $10^6$，即值域）的原因是可能有数等于原根的幂。不过作者取了 $p=998244353,g=3$ 没有问题。

然后这个也很好维护。

最后是，这题挺卡常的，线段树的实现细节改一下后面 $3$ 到 $5$ 个点就可能过不去。具体就是在每个结点开头判返回还是在父结点判进入的不同。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <stdio.h>
#include <string.h>
#include <algorithm>

typedef long long ll;
const int MAXN = 1000001;
const int inf = 2147483627;
const int p = 998244353;

inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
	do x = x * 10 + ch - 48, ch = getchar(); while(ch >= '0' && ch <= '9');
	return x * f;
}

int n,q,a[MAXN],p3[MAXN],min[MAXN << 2],s[MAXN << 2];

#define lc(k) k << 1
#define rc(k) k << 1 | 1
int mmin(const int a,const int b) { return a < b ? a : b; }

void Build(int k,int l,int r) {
	if(l == r) return min[k] = a[l], void(s[k] = p3[a[l]]);
	int mid = (l + r) >> 1;
	Build(lc(k),l,mid);
	Build(rc(k),mid + 1,r);
	min[k] = mmin(min[lc(k)],min[rc(k)]);
	s[k] = (s[lc(k)] + s[rc(k)]) % p;
	return;
}

void Update(int k,int l,int r,int x,int y) {
	if(l == r) return min[k] = y, void(s[k] = p3[y]);
	int mid = (l + r) >> 1;
	if(x <= mid) Update(lc(k),l,mid,x,y);
	else Update(rc(k),mid + 1,r,x,y);
	min[k] = mmin(min[lc(k)],min[rc(k)]);
	s[k] = (s[lc(k)] + s[rc(k)]) % p;
	return;
}

int Querymin(int k,int l,int r,int x,int y) {
	// if(l > y || r < x) return inf;
	if(l >= x && r <= y) return min[k];
	int mid = (l + r) >> 1;
	if(y <= mid) return Querymin(lc(k),l,mid,x,y);
	else if(x > mid) return Querymin(rc(k),mid + 1,r,x,y);
	else return mmin(Querymin(lc(k),l,mid,x,y),Querymin(rc(k),mid + 1,r,x,y));
}

int Querysum(int k,int l,int r,int x,int y) {
	// if(l > y || r < x) return 0;
	if(l >= x && r <= y) return s[k];
	int mid = (l + r) >> 1;
	if(y <= mid) return Querysum(lc(k),l,mid,x,y);
	else if(x > mid) return Querysum(rc(k),mid + 1,r,x,y);
	return (Querysum(lc(k),l,mid,x,y) + Querysum(rc(k),mid + 1,r,x,y)) % p;
}

int main() {
	n = read(), q = read();
	for(register int i = 1;i <= n;i++) a[i] = read();
	p3[0] = 1;
	for(register int i = 1;i < MAXN;i++) p3[i] = p3[i - 1] * 3ll % p;
	Build(1,1,n);
	int op,x,y,l1,r1,l2,r2,m1,m2; ll s1,s2;
	while(q--) {
		op = read();
		if(op == 0) {
			x = read(), y = read();
			Update(1,1,n,x,y);
		} else {
			l1 = read(), r1 = read(), l2 = read(), r2 = read();
			m1 = Querymin(1,1,n,l1,r1), m2 = Querymin(1,1,n,l2,r2),
			s1 = Querysum(1,1,n,l1,r1), s2 = Querysum(1,1,n,l2,r2);
			if(m1 <= m2) s1 = s1 * p3[m2 - m1] % p;
			else s2 = s2 * p3[m1 - m2] % p;
			if(s1 == s2) std::puts("YES");
			else std::puts("NO");
		}
	}
	return 0;
}

```

---

## 作者：MatKave (赞：3)

核心做法是使用三个 $hash:$

第一个 $hash$： 

求出 $\sum a_i,\sum {a_i}^2$，容易通过两个区间 $\sum a_i$ 的差值求出 $k$，然后可以由 $(a_i+k)^2={a_i}^2+k^2+2ka_i$ 求出区间 $1$ 对应 $+k$ 后的值，这个过程最大的数不超过 $10^{18}$，$long$ $long$ 存储。

------------

第二个 $hash:$

求出 $\sum p{a_i}$，$p$ 为某一质数，通过第一个 $hash$ 求出 $k$，然后可以由 $p^{k+a_i}=p^{k}p^{ai}$，求出区间 $1$ 对应 $+k$ 后的值，这个过程要用到自然溢出（或者取模），如果是自然溢出要用 $unsigned$ $long$ $long$ 存储。

------------

由于前两个 $hash$ 只能拿到 $50pts$，因此需要第 $3$ 个 $hash$。

第三个 $hash:$

求出 $\sum pr \left[\ a_i \right]$，其中 $pr \left[\ x \right]$ 表示第$x$ 个质数，这种只能判断两个区间是否完全相同，无法处理 $+k$，但加上去就能 $AC$。

满分的做法大家可以自己尝试一下，这里给出 $75pts$ 的代码。

$75pts$ 的做法核心就是维护 $18$ 次方和，还是很毒瘤的。


感谢 @[chenxinyang2006](https://www.luogu.com.cn/user/49776) 神仙

毕竟……

> 暴力也许不能出奇迹，但暴力多套几层，就出奇迹了

$code$

```cpp
#include<bits/stdc++.h>
using namespace std;

struct node{
	long long val[20];
	int mn,mx;
}tree[400005];
#define ls (rt*2)
#define rs (rt*2+1)

node Merge(node a,node b)
{
	node c;
	c.mn=min(a.mn,b.mn);
	c.mx=max(a.mx,b.mx);
	for(int i=1;i<=18;i++)
	{
		c.val[i]=(a.val[i]+b.val[i])%1000000007;
	}
	return c;
}

void build(int rt,int l,int r)
{
    if(l==r)
	{
    	cin>>tree[rt].val[1];
    	
    	for(int i=2;i<=18;i++)
		{
    		tree[rt].val[i]=tree[rt].val[i-1]*tree[rt].val[1]%1000000007;
    	}
    	tree[rt].mn=tree[rt].mx=tree[rt].val[1];
    	return;
    }
    
    int mid=l+r>>1;
    build(ls,l,mid);
    build(rs,mid+1,r);
    tree[rt] = Merge(tree[ls],tree[rs]);
}

void modify(int rt,int l,int r,int id,int C)
{
	if(l==r)
	{
		tree[rt].val[1]=C;
		for(int i=2;i<=18;i++)
		{
			tree[rt].val[i]=tree[rt].val[i - 1]*tree[rt].val[1]%1000000007;
		}
		
		tree[rt].mn=tree[rt].mx=C;
		return;
	}
	
	int mid=l+r>>1;
	
	if(id<=mid)
	{
		modify(ls,l,mid,id,C);
	}
	else
	{
		modify(rs,mid+1,r,id,C);
	}
	
	tree[rt]=Merge(tree[ls],tree[rs]);
}

node query(int rt,int l,int r,int L,int R)
{
	if(l==L&&r==R) 
	{
		return tree[rt];
	}
	int mid=l+r>>1;
	
	if(R<=mid)
	{
		return query(ls,l,mid,L,R);
	}
	else if(L>mid)
	{
		return query(rs,mid+1,r,L,R);
	}
	else
	{
		return Merge(query(ls,l,mid,L,mid),query(rs,mid+1,r,mid+1,R));
	}
}

long long x[25][25];

void check(node a,node b,int d,int len)
{
	for(int i=1;i<=18;i++)
	{
		long long tmp=0,dd=1;
		for(int j=i;j>=1;j--)
		{
			tmp=(tmp+dd*b.val[j]%1000000007*x[i+1][i-j+1])%1000000007;
			dd=dd*d%1000000007;
		}
		
		tmp=(tmp+dd*len)%1000000007;
		if((tmp-a.val[i])%1000000007!=0)
		{
			cout<<"NO"<<endl;
			return;
		}
	}
	cout<<"YES"<<endl;
}

int main()
{
	for(int i=1;i<=20;i++)
	{
        x[i][1]=x[i][i]=1;
        
        for(int j=2;j<i;j++)
		{
        	x[i][j]=(x[i-1][j-1]+x[i-1][j])%1000000007; 
        }
	}
	
	int n,q,op,x,y,l1,r1,l2,r2;	
    
	cin>>n>>q;
    
    build(1,1,n);
    
	for(int i=1;i<=q;i++)
	{
        cin>>op;
        if(op==0)
		{
        	cin>>x>>y;
        	modify(1,1,n,x,y);
        }
		else
		{
        	cin>>l1>>r1>>l2>>r2;
        	
        	node a=query(1,1,n,l1,r1),b=query(1,1,n,l2,r2);
        	if(a.mx-b.mx!=a.mn-b.mn)
			{
        		cout<<"NO"<<endl;
        		continue;
        	}
        	
        	int d=a.mx-b.mx;
        	check(a,b,d,r1 - l1 + 1);
        }
    }
    
	return 0;
}

```

---

## 作者：Varuxn (赞：3)

>[推销](https://www.cnblogs.com/Varuxn/p/15116075.html)

# 解题思路
**一定不要用自动溢出的 Hash！！！！！！！**

~~（当然也可以学 zxb 用合数取 $\bmod$ 20052526）~~

我真的是调吐了。。。

思路非常简单明了 : 需要我们创新一下  Hash。

首先我们的 Hash 要满足无序性。。

因此我们可以把 Hash 值的意义更改一下。

例如： $x$  的 Hash 值是 $base^x$

在每两个区间维护两个值：**原序列**最小值以及 Hash 值的加和

这里不可以记录 Hash 因为取 $\bmod$ 之后大小就不一定了。。

然后直接线段树维护就好了。。。

**一定不要用自动溢出的 Hash！！！！！！！**

不然哪怕是用 6 个 Hash 也过不了（[记录](https://www.luogu.com.cn/record/55311223)）

然后拍了大概 1e5 组数据，也没拍出错来。。。

![](https://cdn.luogu.com.cn/upload/image_hosting/9wb0t0s8.png)

感谢@OMA dalao 指出要 取 $\bmod$，不然我就要 N Hash 了。。

# code
```cpp
#include<bits/stdc++.h>
#define int long long
#define ull unsigned long long
#define f() cout<<"Pass"<<endl
#define ls x<<1
#define rs x<<1|1
using namespace std;
inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch>'9'||ch<'0')
	{
		if(ch=='-')	f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
const int N=1e6+10,INF=1e18,mod=998244353;
const ull base=168717137ull;
int n,m,s[N];
ull p[N];
long double p6[N];
struct Node
{
	int mn;
	ull has;
	long double has6;
	Node friend operator + (Node x,Node y)
	{
		return (Node){min(x.mn,y.mn),(x.has+y.has)%mod};
	}
};
struct Segment_Tree
{
	int mn;
	ull has;
	long double has6;
}tre[N<<2];
void push_up(int x)
{
	tre[x].has=(tre[ls].has+tre[rs].has)%mod;
	tre[x].mn=min(tre[ls].mn,tre[rs].mn);
}
void insert(int x,int l,int r,int pos,int num)
{
	if(l==r)
	{
		tre[x].has=p[num]%mod;
		tre[x].mn=num;
		return ;
	}
	int mid=(l+r)>>1;
	if(pos<=mid)	insert(ls,l,mid,pos,num);
	else	insert(rs,mid+1,r,pos,num);
	push_up(x);
}
Node query(int x,int l,int r,int L,int R)
{
	if(L<=l&&r<=R)	return (Node){tre[x].mn,tre[x].has};
	int mid=(l+r)>>1;
	Node ans1=(Node){INF,0ull},ans2=(Node){INF,0ull};
	if(L<=mid)	ans1=query(ls,l,mid,L,R);
	if(R>mid)	ans2=query(rs,mid+1,r,L,R);
	return ans1+ans2;
}
signed main()
{
	n=read();
	m=read();
	p[0]=1;
	for(int i=1;i<N;i++)	p[i]=p[i-1]*base%mod;
	for(int i=1;i<=n;i++)
		s[i]=read();
	for(int i=1;i<=n;i++)
		insert(1,1,n,i,s[i]);
	for(int i=1,opt,x,y,l1,r1,l2,r2;i<=m;i++)
	{
		opt=read();
		if(!opt)
		{
			x=read();y=read();
			insert(1,1,n,x,y);
			continue;
		}
		l1=read();r1=read();l2=read();r2=read();
		Node ans1=query(1,1,n,l1,r1);
		Node ans2=query(1,1,n,l2,r2);
		if(ans1.mn<ans2.mn)	swap(ans1,ans2);
		if(p[ans1.mn-ans2.mn]*ans2.has%mod==ans1.has%mod)
			printf("YES\n");
		else	printf("NO\n");
	}
	return 0;
}
```

---

## 作者：lndjy (赞：2)

只讲思路。代码我还没卡完常。不过这个思路正确性复杂度都是对的。

这个东西很复杂，直接维护是肯定不行的。[大母神这题](https://www.luogu.com.cn/problem/P3792)和这个差不多，那题用的哈希，所以可以考虑哈希判断。

常见的方法是维护区间最大最小，区间和区间平方和。但是这种方法被出题人卡死了。

我们可以维护 $sin$ 和 $cos$。这个东西很难卡。当答案为`YES`时，$k$ 都一样，那么随便维护一个最大值的差就是 $k$.再维护一个 $sin$ 一个 $cos$ 就行了，单点修改不需要考虑懒标记。

那么怎么算出来加 $k$ 后的 $sin$ 和 $cos$ 值呢，这个可以用和差角公式

$$\sin(x+y)=\sin(x)\cos(y)+\cos(x)\sin(y)$$

$$\cos(x+y)=\cos(x)\cos(y)-\sin(x)\sin(y)$$

直接算一下再判相等就可以了。

这题好像线段树会被卡常，需要重口味线段树。

---

## 作者：一架飞机 (赞：1)

首先考虑怎么判断区间 $[l_1,r_1]$ 与区间 $[l_2,r_2]$ 是否本质相同。有一个很重要的东西，就是 $k$ 是可以直接算出来的。排序肯定不现实。但是我们可以看到 $a_i$ 只有 $10^6$。所以可以转化为：对于每个数 $x$，判断区间 $[l_1,r_1]$ 中 $x$ 的个数是否等于区间 $[l_2,r_2]$ 中 $x+k$ 的个数。**桶比排序好转化很多**。

然后怎么优化呢。主席树好像可以。这里我们用更简单的**hash**来做。一个 hash 就表示有序集合 $\{ton[x]|0\leq x\leq 10^6 \}$，值为 $(\sum ton[x]\times P^{x})\mod M$。($ton[x]$:一个区间内 $x$ 的个数，$P$ 和 $M$ 是两个常数)

然后怎么从位置 $x$ 移到 $x+k$ 呢，就是 $hash=hash\times p^k$

```cpp
//前面省略
#define int long long
const int P=13331,MOD=1e9+7;
int a[M],n;

//emm。。。我懒得写%mod了
struct node{int x;}PP,n0;
inline node operator+(const node&a,const node&b){
	//return (node){a.x+b.x>=MOD?a.x+b.x-MOD:a.x+b.x};
	return (node){(a.x+b.x)%MOD};
}
inline node operator-(const node&a,const node&b){
	//return (node){a.x-b.x<0?a.x-b.x+MOD:a.x-b.x};
	return (node){((a.x-b.x)%MOD+MOD)%MOD};
}
inline node operator*(const node&a,const node&b){
	return (node){1ll*a.x*b.x%MOD};
}
inline bool operator==(const node&a,const node&b){
	return a.x==b.x;	
}

node po[M*2];

//高级的树状数组
node ch[M];
void addh(int x,node y){
	if(x<=0)return;
	for(;x<=n;x+=x&-x)ch[x]=ch[x]+y;
}
node askh(int x){
	if(x<=0)return n0;
	node res=n0;for(;x;x-=x&-x)res=res+ch[x];return res;
}
ll cs[M];
void adds(int x,ll y){
	if(x<=0)return;
	for(;x<=n;x+=x&-x)cs[x]+=y;
}
ll asks(int x){
	if(x<=0)return 0;
	ll res=0;for(;x;x-=x&-x)res+=cs[x];return res;
}

signed main(){
	int q,opt,x,y,l1,l2,r1,r2;read(n),read(q);
	PP=(node){P};
	po[0].x=1;for(int i=1;i<=2*M-5;i++)po[i]=po[i-1]*PP;
	for(int i=1;i<=n;i++)read(a[i]),addh(i,po[a[i]]),adds(i,a[i]);
	while(q--){
		read(opt);
		if(opt==0){
			read(x),read(y);
			addh(x,n0-po[a[x]]),adds(x,-a[x]);
			addh(x,po[y]),adds(x,y);
			a[x]=y;
		}else{
			read(l1),read(r1),read(l2),read(r2);
			if(l1>r1)swap(l1,r1),swap(l2,r2); 
			ll k=(asks(r2)-asks(l2-1))-(asks(r1)-asks(l1-1));
			if(k<0){
				swap(l1,l2),swap(r1,r2);
				k=-k;
			}
			if(k%(r1-l1+1)!=0){
				puts("NO");
				continue;
			}
			k=k/(r1-l1+1);
			if(askh(r2)-askh(l2-1)==(askh(r1)-askh(l1-1))*po[k]){
				puts("YES");
			}else puts("NO");
		}
	}
	return 0;
}
```

---


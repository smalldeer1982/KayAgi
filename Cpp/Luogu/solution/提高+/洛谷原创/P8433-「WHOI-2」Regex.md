# 「WHOI-2」Regex

## 题目背景

 _JP 版は下記のリンクをクリックしてダウンロードしてください。_ 

正则表达式是文本处理的一个有用的工具。

3022 年，你看到了你以前写过的一个 Python 程序，用来某插画交流网站上面下载图片。

你很感兴趣，决定试着运行一下。结果因为年代久远，里面的正则表达式损坏了。你得恢复这个正则表达式。

然而损坏的程度有点严重……

## 题目描述

在这里我们只考虑正则表达式的一个子集。

- **单字符**，即单独的—个字符，必须为小写字母或数字。

- **单元表达式**，指的是形如 `<x>-<y>` 的三个字符组成的字符串。其中的 `<x>` 和 `<y>` 为单字符。注意：`<x>` 和 `<y>` 必须**类型相同**，即均为数字或均为小写字母。并且 `<x>` 的 ASCII 码值必须**严格小于** `<y>`。比如 `3-5`、`a-d` 是合法的，而 `7-b`、`z-3`、`8-2` 是不合法的。

- **表达式**，指的是用**中括号**括起来的**一个或多个**单元表达式或单字符，比如 `[1-2]`、`[0-9a-f]`、
`[a-chg-k]`。在这里中括号**不允许嵌套**。在右括号后面可以有星号 `*` 或加号 `+` 修饰（两者最多只能有一个，**不能同时出现**）。比如 `[3-5]*`、`[pixi-v]+`。

- 一个合法的正则表达式由**一个或多个**表达式或单字符组成。比如 `0x[0-9af]*`、`1[3-7]2345`、`0[7-9]*1`。


现在你知道这个残缺的正则表达式，其中残缺的字符用问号 `?` 表示。

你需要计算出原来的正则表达式有多少种可能。
答案可能过大，对 $1000000007$ 取模即可。



## 说明/提示

- 样例 #1： 两个问号可以任意填数字和字母，总方案数为 $36 \times 36 = 1296$；
- 样例 #2：除了数字字母，还可以填括号形成 `[a]`，总方案数为 $1297$；
- 样例 #3：验题人没有给出解释。

| 测试点编号 | 字符串长度范围 | 分值 |
| :-----------: | :-----------: | :-----------: |
| 1 | $\leq 5$ | 20 |
| 2 | $\leq 7$ | 20 |
| 3 | $\leq 100$ | 20 |
| 4 | $\leq 1000$  | 20 |
| 5 | $\leq 5000$  | 20 |
| 6 | $\leq 10^5$ | 0 |
| 7 | $\leq 5 \times 10^5$ | 0 |
| 8 | $\leq 10^6$ | 0 |
| 9 | $\leq 5 \times 10^6$ | 0 |
| 10 | $\leq 10^7$ | 0 |

字符串中只会出现**小写字母、数字、问号**中的一种或几种。

- **提示**：本题存在 $O(kn)$ 的解法，其中 $k$ 为常数。

使用 $O(n^2)$ 的做法可以在本题得到 $100$ 分，但是会由于后五个测试点无法通过而显示为 Unaccepted。可能需要注意常数。

## 样例 #1

### 输入

```
??```

### 输出

```
1296```

## 样例 #2

### 输入

```
?a?```

### 输出

```
1297```

## 样例 #3

### 输入

```
a?bc??```

### 输出

```
46730```

# 题解

## 作者：daniEl_lElE (赞：9)

看官方是 $O(n^2)$ 的，我来一发 $O(n)$ 解法。

## 思路

考虑 $dp_{i,1/2/3}$，依次表示看到第 $i$ 位，不属于任何 `[]` 中；属于一个 `[]` 中且目前该括号内没有字母或数字；属于一个 `[]` 中且目前该括号内有若干字母或数字。

考虑转移：

* 这一位放置一个单个字母：

若$s_i='?'$：$dp_{i,1}+=dp_{i-1,1}\times36,dp_{i,3}+=(dp_{i-1,2}+dp_{i-1,3})\times36$。

若$s_i\not='?'$：$dp_{i,1}+=dp_{i-1,1},dp_{i,3}+=(dp_{i-1,2}+dp_{i-1,3})$。

* 这一位放置一个 `[`：

$dp_{i,2}+=dp_{i-1,1}$。

* 这一位放置一个 `]`：

$dp_{i,1}+=dp_{i-1,3}$。

$dp_{i+1,1}+=dp_{i-1,3}\times2$。

* 这三个位置放置一对 `<x>-<y>`：

考虑 $s_i$ 和 $s_{i+2}$ 是 数字/字母/问号，依次枚举即可。

如果 $s_i$ 和 $s_{i+2}$ 均为问号，方案数为 $\binom{26}{2}+\binom{10}{2}$。

若其中一个是问号，只需用另一个减去边界即可。

如果全是填出的 数字/字母，直接判断是否可行即可

时间复杂度 $O(n)$。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int dp[10000005][4];
signed main(){
	string s;
	cin>>s;
	dp[0][1]=1;
	s=" "+s;
	for(int i=1;i<s.size();i++){
		if((s[i]>='0'&&s[i]<='9')||(s[i]>='a'&&s[i]<='z')){
			dp[i][1]=(dp[i][1]+dp[i-1][1])%mod;
			dp[i][3]=(dp[i][3]+dp[i-1][2]+dp[i-1][3])%mod;
		}
		if(s[i]=='?'){
			dp[i][1]=(dp[i][1]+dp[i-1][1]*36)%mod;
			dp[i][3]=(dp[i][3]+dp[i-1][2]*36+dp[i-1][3]*36)%mod;
		}
		if(s[i]=='['||s[i]=='?'){
			dp[i][2]=(dp[i][2]+dp[i-1][1])%mod;
		}
		if(s[i]==']'||s[i]=='?'){
			dp[i][1]=(dp[i][1]+dp[i-1][3])%mod;
			if((i!=(s.size()-1))&&(s[i+1]=='*'||s[i+1]=='?')) dp[i+1][1]=(dp[i+1][1]+dp[i-1][3])%mod;
			if((i!=(s.size()-1))&&(s[i+1]=='+'||s[i+1]=='?')) dp[i+1][1]=(dp[i+1][1]+dp[i-1][3])%mod;
		}
		if((i<(s.size()-2))&&(s[i+1]=='-'||s[i+1]=='?')){
			if(s[i]=='?'&&s[i+2]=='?'){
				dp[i+2][3]=(dp[i+2][3]+dp[i-1][2]*370+dp[i-1][3]*370)%mod;
			}
			if(s[i]=='?'&&s[i+2]>='0'&&s[i+2]<='9'){
				dp[i+2][3]=(dp[i+2][3]+dp[i-1][2]*(s[i+2]-'0')+dp[i-1][3]*(s[i+2]-'0'))%mod;
			}
			if(s[i]=='?'&&s[i+2]>='a'&&s[i+2]<='z'){
				dp[i+2][3]=(dp[i+2][3]+dp[i-1][2]*(s[i+2]-'a')+dp[i-1][3]*(s[i+2]-'a'))%mod;
			}
			if(s[i+2]=='?'&&s[i]>='0'&&s[i]<='9'){
				dp[i+2][3]=(dp[i+2][3]+dp[i-1][2]*('9'-s[i])+dp[i-1][3]*('9'-s[i]))%mod;
			}
			if(s[i+2]=='?'&&s[i]>='a'&&s[i]<='z'){
				dp[i+2][3]=(dp[i+2][3]+dp[i-1][2]*('z'-s[i])+dp[i-1][3]*('z'-s[i]))%mod;
			}
			if(s[i+2]>='a'&&s[i+2]<='z'&&s[i]>='a'&&s[i]<='z'){
				dp[i+2][3]=(dp[i+2][3]+dp[i-1][2]*(s[i]<s[i+2])+dp[i-1][3]*(s[i]<s[i+2]))%mod;
			}
			if(s[i+2]>='0'&&s[i+2]<='9'&&s[i]>='0'&&s[i]<='9'){
				dp[i+2][3]=(dp[i+2][3]+dp[i-1][2]*(s[i]<s[i+2])+dp[i-1][3]*(s[i]<s[i+2]))%mod;
			}
		}
	}
	cout<<dp[s.size()-1][1];
} 
```

## 建议

建议加强数据加一个 $0$ 分的 $\text{Subtask}$。

感谢出题人的迅速回应，题解已修改为新数据可通过的代码了。

---

## 作者：Exschawasion (赞：2)

这里是 WHOI 官方题解。

***

计数动态规划题。

**状态设计**。发现表达式必须被中括号包含，且不能嵌套。这说可能需要采用三个核心函数：

1. 一个 dp 用于计算将输入串的 **$[1, x]$ 区间**拆成多个表达式、单字符的组合可以有多少种方式，记作 $f(x)$；

2. 一个 dp 用于计算将输入串的 **$[l, r]$ 区间**拆成单元表达式、单字符的组合能有多少种方式，记作 $g(l,r)$。这里钦定 $[l, r]$ **不包含**左右中括号，即第 $l-1$ 个字符是左括号，第 $r+1$ 个字符是右括号。

3. 还有一个 dp，计算 $[x, x+2]$ 中可能的单元表达式的个数记作 $m(x)$。严格来说这不算 dp，可以直接计算。

以上两个 dp 的调用方向是 $f \rightarrow g$，因为在表达式内不出现嵌套的表达式，所以不出现 $g$ 回调 $f$ 的情况。

为了方便，这里记 $c_x$ 表示输入串的第 $x$ 个字符；记 $h(x)$ 表示第 $x$ 个位置可以填的**字母或数字**的数量。如果 $c_x$ 是问号，则 $h(x)=36$，因为字母和数字可以任意填；否则 $h(x)=1$。

**状态转移**。首先思考 $f(x)$ 的转移：

- 将第 $x$ 个字符作为**单字符**处理，则状态转移为 $f(x) \rightarrow f(x+1) \times h(x)$；
- 在 $x+L-1\leq n$ 的条件下，枚举 $L$：
  - 将第 $x$ 到第 $x + L - 1$ 个字符作为**表达式**处理，且**没有后缀修饰**。则状态转移为 $f(x) \rightarrow f(x+L),~g(x+1,x+L-2)$；
  
  
  这里将左右端点分别加一减一，相当于去掉括号，剩下的留给 $g$ 函数去计算。可结合下图理解：
  
  ![](https://i.bmp.ovh/imgs/2022/06/17/91c35d663bff6dd3.png)
  
  - 将第 $x$ 到第 $x + L - 1$ 个字符作为**表达式**处理，且**有后缀修饰**。则状态转移为 $f(x) \rightarrow f(x+L),~g(x+1,x+L-3) \times 2$。
  
  右端点比上面的情况又多减了 $1$，相当于在末尾多加了修饰符。乘以二是因为存在两种修饰符。
  
  ![](https://i.bmp.ovh/imgs/2022/06/17/f8db3fb0b3f15650.png)
  

接下来思考 $g(l, r)$ 的转移：


- 将第 $l$ 个字符作为**单字符**处理。则状态转移为 $g(x) \rightarrow g(x+1) \times h(x)$；

- 如果 $c_{l+1}$ 是问号，说明可以在此处填写减号 `-`（输入串中不会有减号，所以判断问号即可）。将 $[l, l+2]$ 作为一个**单元表达式**处理，则状态转移为 $g(x) \rightarrow g(l+3,r),~m(l)$。


以上的转移均需要注意**边界问题**。

$m(x)$ 的转移相对简单：

- 如果 $c_x$ 和 $c_{x+2}$ 都不是问号，且它们类型不同，返回 $0$；类型相同，且 $c_{x+2} > c_x$ 则返回 $1$。

- 如果 $c_x$ 和 $c_{x+2}$ 中有一个是问号，根据不是问号的那个字符的类型计算返回值；

- 如果 $c_x$ 和 $c_{x+2}$ 均为问号，返回 $370$（可能的单元表达式的总数）。

***

代码如下：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 5000 + 5;
const int mod = 1e9 + 7;

#define int long long

char s[maxn];
int n;

inline int condi_unit(char from, char to) {
	if (from != '?' && to != '?') {
		return isalpha(from) == isalpha(to) && to > from;
	}
	else if (from != '?' && to == '?') {
		return (isalpha(from) ? 'z' : '9') - from;
	}
	else if (from == '?' && to != '?') {
		return to - (isalpha(to) ? 'a' : '0');
	}
	else if (from == '?' && to == '?') {
		return 
			25 + 24 + 23 + 22 + 21 + 20 + 19 + 18 + 17 + 16 + 15 +
			14 + 13 + 12 + 11 + 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 + 45;
	}
}

inline int single_unit(char c) {
	return c != '?' ? 1 : 36;
} 

bool vis2[maxn][maxn];
int f2[maxn][maxn];

int dp2(int L, int R) {
	if (vis2[L][R]) {
		return f2[L][R];
	}
	if (L > R) {
		return 1;
	}
	else {
		int ans = 0;
		if (L + 2 <= R && s[L + 1] == '?') {
			int tmp = 1;
			tmp *= condi_unit(s[L], s[L + 2]), tmp %= mod;
			tmp *= dp2(L + 3, R), tmp %= mod;
			ans += tmp, ans %= mod;
		}
		ans += dp2(L + 1, R) * single_unit(s[L]);
		ans %= mod;
		vis2[L][R] = true;
		return f2[L][R] = ans;
	}
}

inline bool check(char a, char b) {
	return (a == '?' || a == '[') &&
		(b == '?' || b == ']');
}

inline bool check_star(char c) {
	return c == '?' || c == '*' || c == '+';
}

bool vis[maxn];
int f[maxn];
int dp(int loc) {
	if (vis[loc]) return f[loc];
	if (loc > n) {
		return 1;
	}
	else {
		int ans = 0;
		ans += dp(loc + 1) * single_unit(s[loc]), ans %= mod;
		for (int len = 1; len + loc - 1 <= n; len++) {
			int tmp1 = 0, tmp2 = 0, L, R;
			L = loc, R = loc + len - 1;
			if (L + 1 <= R - 1) {
				if (check(s[L], s[R])) {
					tmp1 += dp2(L + 1, R - 1), tmp1 %= mod;
					tmp1 *= dp(len + loc), tmp1 %= mod;
				}
			}
			L = loc, R = loc + len - 2;
			if (L + 1 <= R - 1 && check_star(s[R + 1])) {
				if (check(s[L], s[R])) {
					tmp2 += dp2(L + 1, R - 1) * 2, tmp2 %= mod;
					tmp2 *= dp(len + loc), tmp2 %= mod;
				}
			}
			ans += tmp1 + tmp2, ans %= mod;
		}
		vis[loc] = true;
		return f[loc] = ans;
	}
}

signed main() {
	scanf("%s", s + 1); n = strlen(s + 1); cout << dp(1) << endl;
	return 0;
}
```

***

### 关于本题

- 上面这份代码能够在赛时获得 $100$ 分。

- 考虑到本题存在 $O(kn)$ 的做法，我们在原题加了部分 $0$ 分的数据，若要解法请访问 [Daniel_lele  的题解](https://www.luogu.com.cn/blog/116664/P8433-tijie#)。

- 出题组有人提出过本题的 $O(kn)$ 解法，但是由于不敢完全保证正确性，最终选择了较为可靠的 $O(n^2)$ 解法。今后请各位选手们多多指教，感谢对 $\color{red}\texttt{WHOI Round 2}$ 的支持。

---


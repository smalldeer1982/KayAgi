# [DTOI 2023] D. Goodbye 2022

## 题目背景

> 我用烟花宣告，用挥手告别，用鞠躬感谢，过去的都已经过去，接下来的路我要悠闲地走，愉悦地走，脚步如同时间不会停止，下一年，我们还会再会。


## 题目描述

这次的题目背景和 luanmenglei 没有一点关系。

给定 $n,k,p$，求有多少有序 $p$ 元组 $(a_1,a_2,\cdots,a_p)$ 满足

- $\forall i \in [1,p]$，$a_i\in [1,n]$。

- $\forall i\in [1,p)$，$\operatorname{popcount}(a_i\oplus a_{i+1})=k$。

- $\forall i,j\in[1,p],i\neq j$，$a_i\neq a_j$。

答案对 $998244353$ 取模。

---

- 其中 $\operatorname{popcount}(x)$ 表示 $x$ 在二进制表达下 $1$ 的个数。
- $\oplus$ 表示按位异或操作。
- 两个有序 $p$ 元组 $(a_1,a_2,\dots,a_p)$，$(b_1,b_2,\dots,b_p)$ 不同当且仅当存在 $i\in[1,p]$ 使得 $a_i\neq b_i$。


## 说明/提示

对于所有测试数据，保证 $1\leq n \leq 1000$，$1\leq k\leq \lfloor \log_2 n\rfloor$，$1 \leq p \leq 5$。

每个测试点的具体限制见下表：

|  测试点编号  |      $n\leq$ | $p =$ |
| :-: | :-: |:-:|
| $1$ | $1000$ | $1$ |
|  $2 \sim 3$  |       $1000$       |$2$|
| $4 \sim 5$ | $300$ |$3$|
|  $6 \sim 12$  |      $1000$      |$3$|
| $13 \sim 15$ | $1000$ |$4$|
| $16 \sim 21$ | $300$ |$5$|
| $22 \sim 25$ | $1000$ |$5$|


## 样例 #1

### 输入

```
5 1 2```

### 输出

```
8```

## 样例 #2

### 输入

```
6 1 3```

### 输出

```
12```

## 样例 #3

### 输入

```
7 1 4```

### 输出

```
48```

## 样例 #4

### 输入

```
8 3 5```

### 输出

```
6```

## 样例 #5

### 输入

```
9 2 5```

### 输出

```
72```

## 样例 #6

### 输入

```
114 3 3```

### 输出

```
106624```

## 样例 #7

### 输入

```
514 3 4```

### 输出

```
296097032```

## 样例 #8

### 输入

```
1000 7 5```

### 输出

```
569405945```

## 样例 #9

### 输入

```
1000 7 1```

### 输出

```
1000```

# 题解

## 作者：kbtyyds (赞：9)

# P8941 题解

建议在[博客](https://www.luogu.com.cn/blog/453059/solution-p8941)里食用：

[题目链接](https://www.luogu.com.cn/problem/P8941)

--- 

## 题目描述

给定 $n,k,p$，求有多少有序 $p$ 元组 $(a_1,a_2,\cdots,a_p)$ 满足

- $\forall i \in [1,p]$，$a_i\in [1,n]$。

- $\forall i\in [1,p)$，$\operatorname{popcount}(a_i\oplus a_{i+1})=k$。

- $\forall i,j\in[1,p],i\neq j$，$a_i\neq a_j$。

（此处分别记为约束 1,2,3）

答案对 $998244353$ 取模。

## 前置知识：

bitset，不会的可以参考[这个](https://blog.csdn.net/qq_44872284/article/details/116741628)。

## 1. 预处理

我们先定义 $n$ 个长度为 $n$ 的 bitset，记为 $b$

```cpp
bitset < Size > b[Size];
```

接着，枚举 $i,j$，并让 $b[i][j]=[\operatorname{popcount}(i\oplus j)=k]$

再记：

$$f[i]=\sum_{j=1}^n[\operatorname{popcount}(i\oplus j)=k]=b[i].\operatorname{count}()$$

$$g[i][j]=\sum_{l=1}^n[\operatorname{popcount}(i\oplus l)=k][\operatorname{popcount}(j\oplus l)=k]=(b[i]\&b[j]).\operatorname{count}()$$

此处复杂度为 $\mathcal O(\dfrac {n^3} w)$，稍后会讲这两个数组的用途。

## 2. 计算

看题目数据范围的 $1\le p\le 5$ 可以知道我们要对 $p$ 分类讨论！

---

### $p=1$

显然，约束 2,3 在只有一个数的情况下没有用。因此只需考虑约束 1 的值域约束。

显然 $ans=n$。

### $p=2$

我们可以枚举 $a_1$，那么前文提到的 $f[a_1]$ 就是 $a_2$ 的合法数量。

所以 $ans=\sum\limits_{i=1}^n f[i]$

### $p=3$

类似于 $p=2$，我们可以枚举 $a_2$，那么 $a_1$ 的可行方案数为 $f[a_2]$，$a_3$ 的可行方案数为 $f[a_2]-1$。（因为题目规定 $a_1\ne a_3$，因此要减去 $1$）

由乘法原理知 $ans=\sum\limits_{i=1}^n f[i](f[i]-1)$

### $p=4$

~~说实话我不知道为什么联想到了 CSP-S 2022 T1。~~

考虑枚举 $a_2,a_3$，由约束 2 知只有当 $b[a_2][a_3]$ 为 $1$ 时，才有符合的 $p$ 元组。

那么 $a_1$ 的合法数量为 $f[a_2]-1$（因为 $a_1\ne a_3$），$a_4$ 的合法数量为 $f[a_3]-1$（因为 $a_2\ne a_4$）

但是，我们多算了 $a_1=a_4$ 的情况，因此要减去（即 $g[a_2][a_3]$）。

易得 $ans=\sum\limits_{i=1}^n\sum\limits_{j=1}^n[b[i][j]=1]((f[i]-1)(f[j]-1)-(g[i][j]))$

### $p=5$

类似的思路，枚举 $a_2,a_4$（首先要保证 $a_2\ne a_4$），那么 $a_3$ 的合法数量为 $g[a_2][a_4]$

接下来分两种情况讨论：

1. $b[a_2][a_4]=1$。此时 $a_1$ 的合法数量为 $f[a_2]-2$（除去 $a_3,a_4$）,$a_5$ 的合法数量为 $f[a_4]-2$（除去 $a_2,a_3$）。
2. $b[a_2][a_4]=0$。此时 $a_1$ 的合法数量为 $f[a_2]-1$（除去 $a_3$）,$a_5$ 的合法数量为 $f[a_4]-1$（除去 $a_3$）。

当然，不要忘记舍去 $a_1=a_5$ 的情况。由于 $a_3$ 已经占了一个 $g[a_2][a_4]$ 的位置，因此 $a_1=a_5$ 的数量为 $g[a_2][a_4]-1$

那么 $ans=\sum\limits_{i=1}^n\sum\limits_{j=1}^n [i\ne j]\begin{cases}g[i][j](f[i]-2)(f[j]-2)-(g[i][j]-1)& b[i][j]=1\\g[i][j](f[i]-1)(f[j]-1)-(g[i][j]-1)&b[i][j]=0\end{cases}$

---

## 代码

可以直接根据上方公式计算，于是代码放[云剪切板](https://www.luogu.com.cn/paste/5ng9l2c9)。

时间复杂度 $\mathcal O(\dfrac {n^3} w)$，空间复杂度 $\mathcal O(n^2)$，可以通过本题（而且跑的飞快）。



---

## 作者：InoueTakina (赞：6)

我知道 cocoly 出的这题巨几把恶臭，但是标算真的不需要 `std::bitset`。

~~虽然被 `std::bitset` 吊打了。~~

## 算法 1

- 检验读题成果，暴力枚举计算即可。
- 时间复杂度 $\mathcal{O}(n^p)$。

## 算法 2

- 当 $p = 3$ 时，不难想到我们可以先对每一个 $i$ 预处理出所有满足条件的 $j$ 的个数，记为 $f_i$。然后对于那个三元组，枚举中间的那个数，不难发现每一个 $i$ 做为中间的那个数的贡献为 $f_i * (f_i - 1)$，且没有重复的情况，所以最终答案即为 $\sum^n_{i=1}{f_i * (f_i - 1)}$。
- 时间复杂度 $\mathcal{O}(n ^2)$。

## 算法 3

- 受算法 $2$ 启发，当 $p=4$ 时，我们也可以枚举 $2, 3$ 位置上的数，同时通过 $f$ 数组计算答案。
- 但由于题目要求 $p$ 元组的元素互异，所以 $1$ 位置与 $4$ 位置相同的情况会被多算一次。
- 记 $a, b, c$ 分别为 $2, 3, (1/4)$ 位置上的数，如果我们将 $i$ 向所有满足 $\operatorname{popcount}(i \oplus j) = k$ 的 $j$ 连边，多算的情况的个数其实就是这个有向图上三元环的个数。
- 由于 $n$ 只有 $1000$，不难想到直接用 `bitset` 优化暴力枚举的过程，枚举 $1, 3$ 两个点，然后通过 `bitset` 进行与操作得出 $2$ 点的个数，即可计算出三元环的个数。
- 时间复杂度 $\mathcal{O}(\dfrac{n^3}{\omega})$。

## 算法 4

- 受到算法 $2,3$ 的启发，当 $p=5$ 时，我们可以故技重施，枚举 $2,4$ 两个位置的值，然后通过 `bitset` 优化可以轻松求出位置 $3$ 满足的数的个数，同时 $1,5$ 位置的答案我们也可以通过容斥算出。
- 考虑一下哪几种情况我们需要容斥，记我们枚举的 $2,4$ 位置的数分别为 $a,b$，中间位置满足的数的个数为 $mid$。

> 1. $1,3,5$ 位置均无限制，这种情况的个数为 $f_{a} \times f_b \times mid$。
> 2. $1, 3$ 位置相等，$5$ 位置无限制，这种情况个数是 $mid \times f_b$。
> 3. $3,5$ 位置相等，$1$ 位置无限制，这种情况的个数是 $mid \times f_a$。
> 4. $1,5$ 位置相等，$3$ 位置无限制，这种情况的个数是 $mid \times mid$。
> 5. $1,3,5$ 位置相等，这种情况的个数是 $mid$。

- 不难发现情况 $2,3,4$ 其实是包含情况 $5$ 的，由于情况 $5$ 应该只能被算一次，所以我们只要将情况 $1$ 的个数减去情况 $2,3,4$ 的个数再加上两倍情况 $5$ 的个数就是 $p=5$ 时的答案了。

- 时间复杂度 $\mathcal{O}(\dfrac{n^3}{\omega })$。
- 综合算法 $1,2,3,4$ 即可获得本题的全部分数。

## 算法 5（如何优雅的抛弃掉 `std::bitset`）

注意到我们对 $\operatorname{popcount}(a_i\oplus a_{i+1})=k$ 的性质运用不够深，出题人为什么不给你一个 $0/1$ 矩阵或者其他的东西呢？

事实上，这个条件的感性含义是两个数二进制下不同的位数个数 $=k$。

注意到上述使用 `bitset` 的瓶颈是求两个数的邻域集合的交集的**大小**，考虑有没有不同的做法，能够不使用 `bitset`。

其实是有的，注意到每个数的邻域集合大小其实只有不超过 $\binom{10}{5}=252$ 个，我们可以枚举**交集**而非枚举两个数，然后枚举这个数的邻域，并统计到相应位置，这部分的复杂度 $1000\times 252\times 252$，略高于 $\frac{n^3}{\omega}$，但是可以通过。

可能说的比较抽象，给出参考代码：

```c++
for(int i = 1; i <= n; ++ i)
	for(auto j : b[i])
    	for(auto k : b[i])
            if(j != k) ++ m[j][k];
```

其中 $b_i$ 表示 $i$ 的邻域集合构成的 `vector`，最后的 $m_{i,j}$ 就表示 $i$ 和 $j$ 的邻域集合的交集的大小。


---

## 作者：hegm (赞：1)

### [P8941 [SSOI 2023 easy Round] D. Goodbye 2022](https://www.luogu.com.cn/problem/P8941)

大型暴力现场。

看到题目两眼抓瞎，看到范围两眼放光。

`pop_count` 是可以通过函数 `__builtin_popcount()` $O(1)$ 求的。

考虑类似于 `2022 csp-s T1` 的东西，首先分讨。

- $p=1$ 显然答案为 $n$。

- $p=2$ 暴力枚举答案显然。

- $p=3$ 接下来考虑先预处理出 $f_{i,j}$ 表示 $i$ 和 $j$ 的异或 $1$ 的个数是否为 $k$，这玩意可以用 `bitset` 存储下来，考虑枚举位置 $1,3$ 那么位置 $2$ 必须既能和 $1$ 满足也能和 $3$ 满足。

```cpp
for(int i=1;i<=n;i++)
{
	for(int j=1;j<=n;j++)
	{
		if(i==j)continue;
		ans+=(s[i]&s[j]).count();
		ans%=mod;
	}
}
```

其中的 `count()` 函数是返回 `bitset` 中有多少 $1$ 的。

- $p=4$ 这玩意也好算，暴力枚举 $2,3$ 位置，那么 $1,4$ 位置就确定了，有四种情况 ：
	 1. $1,4$ 填的分别只属于 $f_2,f_3$。
     
    2. $1$ 填的属于 $f_2\cap f_3$ ,$4$ 只属于 $f_3$。
    3. 与二情况类似， $1$ 只属于 $f_2$，$4$ 属于 $f_2\cap f_3$。
    4. $1,4$ 都属于 $f_2\cap f_3$。
    
    注意要把 $i,j$ 分别从 $f_i,f_j$ 中剖掉。
    
```cpp
for(int i=1;i<=n;i++)
{
	for(int j=1;j<=n;j++)
	{
		if(s[i][j]!=1)continue;
		int a=s[i].count()-1;
		int b=s[j].count()-1;
		int c=(s[i]&s[j]).count();
		ans+=(a-c)*(b-c)+c*(b-c)+(a-c)*c+c*(c-1);
		ans%=mod;
	}
}
```

- $p=5$ 与上面类似。

```cpp
for(int i=1;i<=n;i++)
{
	for(int j=1;j<=n;j++)
	{
		if(i==j)continue;
		int a=s[i].count()-(__builtin_popcount(i^j)==k);
		int b=s[j].count()-(__builtin_popcount(i^j)==k);
		int c=(s[i]&s[j]).count();
		ans+=c*(a-c)*(b-c)+c*(c-1)*(b-c)+c*(a-c)*(c-1)+c*(c-1)*(c-2);
		ans%=mod;
	}
}
```

然后就没了。

---

## 作者：yangjunhan1 (赞：0)

# [题目](https://www.luogu.com.cn/problem/P8941)
## 思路
$8941$ 是一个吉祥的数字。

题目有三个约束条件，看了就令人头晕。但当我们注意到数据范围： $p \le 5$。$p$ 是如此的小，实在很难不想到最~暴力~高效的方法——**分类讨论**。

首先可以处理一下数组中的关系。

不妨设 $ff_{i,j}$ 为 $i$ 在 $1$ ~ $n$ 中所有满足 $ \operatorname{popcount}{ i \oplus j } = k $ 的 $j$。

$vis_{i,j}$ 表示 $i$ 和 $j$ 是否满足 $ \operatorname{popcount}{ i \oplus j } = k $，满足为 $1$，不满足为 $2$。

$f_{i,j}$ 表示 $p=i$ 时，第一个枚举 $j$ 有多少种情况。则 $ans=\sum\limits_{i = 1}^n f_{p,i}$。


### 当 $p=1$ 时：
显然 $f_{1,j}=1$，则 $ans=n$。

```cpp
for(int i=1;i<=n;i++)   f[1][i]=1;
```

### 当$p=2$ 时：
第一个枚举 $a_1$，则 $f_{2,j}=ff_{i}$ 的大小。$ans=\sum\limits_{i=1}^nf_{2,i}$。

```cpp
for(int i=1;i<=n;i++)   f[2][i]=ff[i].size();
```

### 当 $p=3$ 时：
枚举 $a_1$、$a_2$，因为要**减去以 $a_2$ 为开头的二元组中含 $a_1$ 的组数**，所以 $f_{3,i}=\sum\ f_{2 ,ff_{i,j}}-1 $。$ans=\sum\limits_{i=1}^nf_{3,i}$。

```cpp
    for(int i=1;i<=n;i++){
        int s=0;
        for(int j=0;j<ff[i].size();j++)
            s=(s-1+f[2][ff[i][j]])%mod;
        f[3][i]=s;
    }
```

### 当 $p=4$ 时：
枚举 $a_1$ 和 $a_3$，设 $s$ 为同时满足 $a_1$ 和 $a_2$ 的数的个数， $fs$ 为 $ff_j$ 的大小，则当 $i$ 和 $j$ 不满足条件时 $f_{4,i}=\sum\ s*(fs-1)$，当 $i$ 和 $j$ 满足条件时 $f_{4,i}=\sum\ s*(fs-2)$。$ans=\sum\limits_{i=1}^nf_{4,i}$。
```cpp
for(int i=1;i<=n;i++){
        int ss=0;
        for(int j=1;j<=n;j++){
            if(i==j)    continue;
            int s=0;
            for(int ks=0;ks<ff[i].size();ks++)
                if(vis[j][ff[i][ks]])   s=(s+1)%mod;
            if(vis[i][j])   s=s*(ff[j].size()-2)%mod;
            else    s=s*(ff[j].size()-1)%mod;
            ss=(ss+s)%mod;
        }
        f[4][i]=ss;
    }
```
### 当 $p=5$ 时：
枚举 $a_2$ 和 $a_4$，设 $s1$ 为满足 $a_1$ 条件的数的个数，$s2$ 为满足 $a_5$ 条件的数的个数，其余大致与 $p=4$ 时相同。 
```cpp
    for(int i=1;i<=n;i++){
        int ss=0;
        for(int j=1;j<=n;j++){
            if(i==j)    continue;
            int s=0;
            for(int ks=0;ks<ff[i].size();ks++)
                if(vis[j][ff[i][ks]])   s=(s+1)%mod;
            int s1=ff[i].size()-(vis[i][j]);
		    int s2=ff[j].size()-(vis[i][j]);
		    ss+=s*(s1-s)*(s2-s)%mod+s*(s-1)*(s2-s)%mod+s*(s1-s)*(s-1)%mod+s*(s-1)*(s-2)%mod;
            ss%=mod;
        }
        f[5][i]=ss;
    }
```


# 完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e3+10,mod=998244353;
int n,k,p,f[6][N];
bool vis[N][N];
vector<int> ff[N];
int pc(int x){
    int s=0;
    while(x){
        if(x&1) s=(s+1)%mod;
        x>>=1;
    }
    return s;
}
signed main(){
    cin>>n>>k>>p;
    for(int i=1;i<n;i++)
        for(int j=i+1;j<=n;j++){
            vis[i][j]=vis[j][i]=(pc(i^j)==k);
            if(pc(i^j)==k){
                ff[i].push_back(j);
                ff[j].push_back(i);
            }
        }
    for(int i=1;i<=n;i++)   f[1][i]=1;
    for(int i=1;i<=n;i++)   f[2][i]=ff[i].size();
    for(int i=1;i<=n;i++){
        int s=0;
        for(int j=0;j<ff[i].size();j++)
            s=(s-1+f[2][ff[i][j]])%mod;
        f[3][i]=s;
    }
    for(int i=1;i<=n;i++){
        int ss=0;
        for(int j=1;j<=n;j++){
            if(i==j)    continue;
            int s=0;
            for(int ks=0;ks<ff[i].size();ks++)
                if(vis[j][ff[i][ks]])   s=(s+1)%mod;
            if(vis[i][j])   s=s*(ff[j].size()-2)%mod;
            else    s=s*(ff[j].size()-1)%mod;
            ss=(ss+s)%mod;
        }
        f[4][i]=ss;
    }
    for(int i=1;i<=n;i++){
        int ss=0;
        for(int j=1;j<=n;j++){
            if(i==j)    continue;
            int s=0;
            for(int ks=0;ks<ff[i].size();ks++)
                if(vis[j][ff[i][ks]])   s=(s+1)%mod;
            int s1=ff[i].size()-(vis[i][j]);
		    int s2=ff[j].size()-(vis[i][j]);
		    ss+=s*(s1-s)*(s2-s)%mod+s*(s-1)*(s2-s)%mod+s*(s1-s)*(s-1)%mod+s*(s-1)*(s-2)%mod;
            ss%=mod;
        }
        f[5][i]=ss;
    }
    int ans=0;
    for(int i=1;i<=n;i++)   ans=(ans+f[p][i])%mod;
    cout<<ans;
    return 0;
}

---

## 作者：ryanright (赞：0)

看见 $p\le5$，于是大力分类讨论。

## $p=1$

在 $[1,n]$ 中任选一个数作为 $a_1$，共 $n$ 种方案。

```cpp
if (p == 1)
    cout << n << endl;
```

## $p=2$

直接枚举全部 $n^2$ 个有序二元组并判断是否合法即可。

为了方便后面的部分展开，此处预处理了

$$pd_{i}= \{j|\operatorname{popcount}(i\oplus j)=k\}$$

并以 `std::bitset` 的形式储存。

则答案即为

$$\sum_{i=1}^n\operatorname{card}(pd_i)$$

```cpp
if (p == 2) {
    int ans = 0;
    for (int i = 1; i <= n; i++)
        ans += pd[i].count();
    cout << ans << endl;
}
```

## $p=3$

不能再枚举每个数了，只能枚举合法的 $a_1$ 和 $a_2$。后面的 $a_3$ 可以从 $pd_{a_2}$ 中随便选一个接上去，但是要注意 $a_1$ 肯定是在 $pd_{a_2}$ 中的，因此计算的时候需将其扣除。

$$\sum_{i=1}^n\sum_{j=1}^npd_{i,j}(\operatorname{card}(pd_j)-1)$$

```cpp
if (p == 3) {
    int ans = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if (pd[i][j])
                ans = (ans + pd[j].count() - 1) % mod;
    cout << ans << endl;
}
```

## $p=4$

$p$ 增加了，然而我们最多还是只能枚举两个数。那肯定枚举中间两个 $a_2$ 和 $a_3$ 啊，这样就不用担心连锁效应了。

和 $p=3$ 时类似的，在前后各挂一个合法的，但是这里需要注意挂上去的 $a_1$ 和 $a_4$ 可能是相同的，需要算出有多少个数挂前面和挂后面都是合法的，并将这种方案扣除。

$$\sum_{i=1}^n\sum_{j=1}^npd_{i,j}[(\operatorname{card}(pd_i)-1)(\operatorname{card}(pd_j)-1)-\operatorname{card}(pd_i\cap pd_j)]$$

上面的两个 $\operatorname{card}$ 都减了 $1$，这是因为 $a_2$ 和 $a_3$ 都在对方的 $pd$ 中，不能挂。后面的又没有减，因为 $a_2$ 和 $a_3$ 都不会在两个 $pd$ 的交集中。

```cpp
if (p == 4) {
    int ans = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if (pd[i][j]) {
                int ret = (pd[i].count() - 1) * (pd[j].count() - 1) % mod;
                ret = (ret - (pd[i] & pd[j]).count() + mod) % mod;
                ans = (ans + ret) % mod;
            }
    cout << ans << endl;
}
```

## $p=5$

这次就枚举 $a_2$ 和 $a_4$，最好不要有连续的不枚举的数，不然可能会有连锁反应，难以计算。为了方便计算，这里我们先把 $a_2$ 和 $a_4$ 从对方的 $pd$ 中删除（如果在里面的话），本轮计算过后再恢复。

$a_3$ 需要从两个 $pd$ 的交集里面选一个，因为要同时满足 $a_2$ 和 $a_4$。之后所有的 $\operatorname{card}$ 全部都要减 $1$。然后剩下的部分同 $p=4$：

$$\sum_{i=1}^n\sum_{j=1}^npd_{i,j}\times\operatorname{card}(pd_i\cap pd_j)\times[(\operatorname{card}(pd_i)-1)(\operatorname{card}(pd_j)-1)-\operatorname{card}(pd_i\cap pd_j) + 1]$$

前面的两个 $\operatorname{card}$ 只减了 $1$ 是因为预处理去掉了两个 $pd$ 中的 $a_2$ 和 $a_4$。

```cpp
if (p == 5) {
    int ans = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if (i != j) {
                bool cur = pd[i][j];
                pd[i][j] = pd[j][i] = 0;
                if (pd[i].count() >= 1 && pd[j].count() >= 1 &&
                (pd[i] & pd[j]).count() >= 1 && (pd[i] | pd[j]).count() >= 3) {
                    int ret = (pd[i].count() - 1) * (pd[j].count() - 1) % mod;
                    ret = (ret - ((pd[i] & pd[j]).count() - 1) + mod) % mod;
                    ans = (ans + ret * (pd[i] & pd[j]).count() % mod) % mod;
                }
                pd[i][j] = pd[j][i] = cur;
            }
    cout << ans << endl;
}
```

总时间复杂度为 $O(\frac{n^3}{w})$。

完整代码：

```cpp
#include <iostream>
#include <bitset>
#define int long long
#define mod 998244353
using namespace std;
bitset<1005> pd[1005];
signed main() {
    int n, k, p;
    cin >> n >> k >> p;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            pd[i][j] = (__builtin_popcount(i ^ j) == k);
    if (p == 1)
        cout << n << endl;
    else if (p == 2) {
        int ans = 0;
        for (int i = 1; i <= n; i++)
            ans += pd[i].count();
        cout << ans << endl;
    } else if (p == 3) {
        int ans = 0;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                if (pd[i][j])
                    ans = (ans + pd[j].count() - 1) % mod;
        cout << ans << endl;
    } else if (p == 4) {
        int ans = 0;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                if (pd[i][j]) {
                    int ret = (pd[i].count() - 1) * (pd[j].count() - 1) % mod;
                    ret = (ret - (pd[i] & pd[j]).count() + mod) % mod;
                    ans = (ans + ret) % mod;
                }
        cout << ans << endl;
    } else {
        int ans = 0;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                if (i != j) {
                    bool cur = pd[i][j];
                    pd[i][j] = pd[j][i] = 0;
                    if (pd[i].count() >= 1 && pd[j].count() >= 1 && (pd[i] & pd[j]).count() >= 1 && (pd[i] | pd[j]).count() >= 3) {
                        int ret = (pd[i].count() - 1) * (pd[j].count() - 1) % mod;
                        ret = (ret - ((pd[i] & pd[j]).count() - 1) + mod) % mod;
                        ans = (ans + ret * (pd[i] & pd[j]).count() % mod) % mod;
                    }
                    pd[i][j] = pd[j][i] = cur;
                }
        cout << ans << endl;
    }
    return 0;
}
```

---

## 作者：mc123456 (赞：0)

## 分析

~~什么飞龙一般的分讨容斥。~~

### 预处理

下文中简写 $\mathrm{popcount}$ 为 $\mathrm{p}$。

令 $f_{i, j} = [\mathrm{p}(i \oplus j) = k]$，用 `bitset` 存储可以加快速度。

记 $\mathrm{p}(f_i) = \sum\limits_{i = 1}^{n}{f_{i, j}}$（该定义和 $\mathrm{popcount}$ 类似，故均记为 $\mathrm{p}$）。记 $f_i \wedge f_j = x$，则 $x_k = [f_{i, k} \wedge f_{j, k}]$。

### $p = 1$

显然答案为 $n$。

### $p = 2$

枚举 $a_1$，那么 $a_2$ 共有 $\mathrm{p}(f_{a_1})$ 种选法。

故答案为 $\sum\limits_{i = 1}^{n}{\mathrm{p}(f_i)}$。

### $p = 3$

枚举 $a_2$，因为有 $a_1 \neq a_3$，根据容斥原理 $a_1, a_3$ 共有 $\mathrm{p}(f_{a_2}) \cdot \mathrm{p}(f_{a_2}) - \mathrm{p}(f_{a_2}) = \mathrm{p}(f_{a_2}) \cdot (\mathrm{p}(f_{a_2}) - 1)$ 种选法。

故答案为 $\sum\limits_{i = 1}^{n}{\mathrm{p}(f_i) \cdot (\mathrm{p}(f_i) - 1)}$。

### $p = 4$

枚举 $a_2$ 和 $a_3$。当 $f_{a_2, a_3} = 1$ 时，$a_1$ 共有 $\mathrm{p}(f_{a_2}) - 1$ 种选法（$a_1 \neq a_3$），$a_4$ 共有 $\mathrm{p}(f_{a_3}) - 1$ 种选法（$a_4 \neq a_2$），此时多计算了 $a_1 = a_4$ 的情况，故还要再减掉 $\mathrm{p}(f_{a_2} \wedge f_{a_3})$。

故答案为 $\sum\limits_{i = 1}^{n}\sum\limits_{j = 1}^{n}{f_{i, j} \cdot ((\mathrm{p}(f_i) - 1) \cdot (\mathrm{p}(f_j) - 1) - \mathrm{p}(f_i \wedge f_j))}$。

### $p = 5$

枚举 $a_2$ 和 $a_4$（$a_2 \neq a_4$），$a_3$ 共有 $\mathrm{p}(f_{a_2} \wedge f_{a_4})$ 种选法。

+ 若 $f_{a_2, a_4} = 1$，说明 $a_1$ 共有 $\mathrm{p}(f_{a_2}) - 2$ 种选法（$a_1 \neq a_3, a_1 \neq a_4$），说明 $a_5$ 共有 $\mathrm{p}(f_{a_4}) - 2$ 种选法（$a_5 \neq a_3, a_5 \neq a_2$）。

+ 若 $f_{a_2, a_4} = 0$，说明 $a_1$ 共有 $\mathrm{p}(f_{a_2}) - 1$ 种选法（$a_1 \neq a_3$），说明 $a_5$ 共有 $\mathrm{p}(f_{a_4}) - 1$ 种选法（$a_5 \neq a_3$）。

这些选法减去 $a_1 = a_5$ 的 $\mathrm{p}(f_{a_2} \wedge f_{a_4}) - 1$ 种选法（$a_1 = a_5 \neq a_3$），再乘上 $a_3$ 的选法，即为答案。

故答案为 $\sum\limits_{i = 1}^{n}\sum\limits_{j = 1}^{n}{[i \neq j] \cdot ((\mathrm{p}(f_i) - 1 - f_{i, j}) \cdot (\mathrm{p}(f_j) - 1 - f_{i, j}) - (\mathrm{p}(f_i \wedge f_j) - 1)) \cdot \mathrm{p}(f_i \wedge f_j)}$。

总时间复杂度 $O\left(\dfrac{n^3}{\omega}\right)$。

## 代码

把上述五种情况合在一起即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 1e3 + 10, MOD = 998244353;

int n, k, p;
bitset<N> bs[N];
int ans;

signed main()
{
    cin.tie(0), cout.tie(0), ios::sync_with_stdio(0);
    cin >> n >> k >> p;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if (i != j)
                bs[i][j] = (__builtin_popcount(i ^ j) == k);
    if (p == 1)
        ans = n;
    if (p == 2)
        for (int i = 1; i <= n; i++)
            ans += bs[i].count(), ans %= MOD;
    if (p == 3)
        for (int i = 1; i <= n; i++)
            ans += bs[i].count() * (bs[i].count() - 1), ans %= MOD;
    if (p == 4)
        for (int i = 1; i <= n; i++)
            for (int j = i + 1; j <= n; j++)
                ans += bs[i][j] * ((bs[i].count() - 1) * (bs[j].count() - 1) - (bs[i] & bs[j]).count()) * 2, ans %= MOD;
    if (p == 5)
        for (int i = 1; i <= n; i++)
            for (int j = i + 1; j <= n; j++)
                ans += ((bs[i].count() - 1 - bs[i][j]) * (bs[j].count() - 1 - bs[i][j]) - (bs[i] & bs[j]).count() + 1) * (bs[i] & bs[j]).count() * 2, ans %= MOD;
    cout << (ans % MOD + MOD) % MOD << endl;
}
```

---

## 作者：luogu_gza (赞：0)

大型 bitset 题。

你需要分类讨论来做。

首先有一些预处理如下。

```
fo(i,1,n) fo(j,1,n) b[i][j]=__builtin_popcount(i^j)==k;
fo(i,1,n) f[i]=b[i].count();
fo(i,1,n) fo(j,1,n) g[i][j]=(b[i]&b[j]).count();
```

### $p=1$

这一部分直接输出 $n$ 即可。

### $p-2$

这一部分考虑枚举两个数，但是更为简洁的方法是：

$$\sum_{i=1}^{n}f_i$$

### $p=3$

考虑枚举 $a_2$，那么答案就是：

$$\sum_{i=1}^{n}\binom{f_i}{2}$$

### $p=4$

枚举 $a_2$ 与 $a_3$，发现去除 $a_1=a_3$ 与 $a_4=a_2$ 的情况后，答案就是：

$$\sum_{i=1}^{n}\sum_{j=1}^{n}(f_i-1)(f_j-1)-g_{i,j}$$

为什么要减去 $g_{i,j}$ 呢？这是为了防止 $a_1=a_4$。

### $p=5$

枚举 $a_2$ 与 $a_4$，去除相等的情况。

这一部分是看了题解才会的。

答案就是：

```
fo(i,1,n) fo(j,1,n) if(i!=j)
{
	if(b[i][j]) (ans+=g[i][j]*((f[i]-2)%mod*(f[j]-2)%mod-g[i][j]+1)%mod+mod)%=mod;
	else (ans+=g[i][j]*((f[i]-1)%mod*(f[j]-1)%mod-g[i][j]+1)%mod+mod)%=mod;
}
```

所乘上的 $g_{i,j}$ 是 $a_3$ 的种数，剩余的则是 $a_1$ 与 $a_5$ 的部分。

根据 $b_{i,j}$ 分类讨论，是为了去除 $a_1$，$a_2$，$a_4$ 和 $a_5$ 互相相同的非法情况。

---

完整代码如下：

```
// Problem: P8941 [SSOI 2023 easy Round] D. Goodbye 2022
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P8941
// Memory Limit: 128 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
#define int long long
#define pb push_back
#define MT int TTT=R;while(TTT--)
#define pc putchar
#define R read()
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define rep(i,a,b) for(int i=a;i>=b;i--)
#define m1(a,b) memset(a,b,sizeof a)
namespace IO
{
	inline int read()
	{
	    int x=0;
	    char ch=getchar();
	    bool f=0;
	    while(!isdigit(ch)){if(ch=='-') f=1;ch=getchar();}
	    while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	    if(f) x=-x;
	    return x;    
	}
	template<typename T> inline void write(T x)
	{
	    if(x<0)
	    {
	        pc('-');
	        x=-x;
	    }
	    if(x>9) write(x/10);
	    pc(x%10+'0');
	}
};
namespace math
{
	inline int gcd(int a,int b)
	{
		return b?gcd(b,a%b):a;
	}
	inline int qmi(int a,int b,int p)
	{
		int res=1;
		while(b)
		{
			if(b&1) res=res*a%p;
			a=a*a%p;
			b>>=1;
		}
		return res;
	}
	inline int inv(int a,int p)
	{
		return qmi(a,p-2,p);
	}
	const int MAXN=2e6+10;
	int my_fac[MAXN],my_inv[MAXN];
	void init_binom(int mod)
	{
		my_fac[0]=1;fo(i,1,min(MAXN,mod)-1) my_fac[i]=my_fac[i-1]*i%mod;
		my_inv[min(MAXN,mod)-1]=qmi(my_fac[min(MAXN,mod)-1],mod-2,mod);rep(i,min(MAXN,mod)-2,0) my_inv[i]=my_inv[i+1]*(i+1)%mod;
	}
	int binom(int a,int b,int mod)
	{
		return my_fac[a]*my_inv[b]%mod*my_inv[a-b]%mod;
	}
}
using namespace IO;
using namespace math;

const int N=1010,mod=998244353;
int n,k,p,ans;
bitset<N> b[N];
int f[N],g[N][N];
signed main(){
	n=R,k=R,p=R;
	fo(i,1,n) fo(j,1,n) b[i][j]=__builtin_popcount(i^j)==k;
	fo(i,1,n) f[i]=b[i].count();
	fo(i,1,n) fo(j,1,n) g[i][j]=(b[i]&b[j]).count();
	if(p==1)
	{
		write(n);
	}
	else if(p==2)
	{
		fo(i,1,n) ans+=f[i];
		write(ans);
	}
	else if(p==3)
	{
		fo(i,1,n) (ans+=f[i]*(f[i]-1))%=mod;
		write(ans);
	}
	else if(p==4)
	{
		fo(i,1,n) fo(j,1,n) if(b[i][j]) (ans+=(f[i]-1)*(f[j]-1)-g[i][j]+mod)%=mod;
		write(ans);
	}
	else if(p==5)
	{
		fo(i,1,n) fo(j,1,n) if(i!=j)
		{
			if(b[i][j]) (ans+=g[i][j]*((f[i]-2)%mod*(f[j]-2)%mod-g[i][j]+1)%mod+mod)%=mod;
			else (ans+=g[i][j]*((f[i]-1)%mod*(f[j]-1)%mod-g[i][j]+1)%mod+mod)%=mod;
		}
		write(ans);
	}
}
```

---


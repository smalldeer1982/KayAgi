# 「DROI」Round 1 下坠

## 题目背景

下坠是有终点的吗？

## 题目描述

$f$ 是定义在 $\mathbb{N^+}$ 上的函数。

我们令 $a_i$ 表示 $x$ 从低到高第 $i$ 位，那么 $f(x)= \prod_{i=1}^{len} (a_i+1)$（$len$ 表示 $x$ 的位数）。

如果对于一个数 $x$，存在 $y$ 使得 $f(y)=x$，那我们称 $x$ 是下坠数。

现在有 $Q$ 次询问，每次询问会给出一个正整数 $k$。

令 $x$ 表示所有下坠数中第 $k$ 小的下坠数，那么请你找到一个**最小的** $y$，使得 $f(y)=x$。若不存在一个 $y \in [1,10^{18}]$ 满足条件，则输出 $-1$。

## 说明/提示

#### 样例解释 #1

注意到 $f$ 的定义域是 $\mathbb{N^+}$，所以 $1$ 不是下坠数。则前三个下坠数分别为 $2,3,4$，对应的 $y$ 值则为 $1,2,3$。

------------

#### 样例解释 #2

第 $9$ 和 $14$ 个下坠数分别为 $10$ 和 $18$，其对应的 $y$ 值则为 $9$ 和 $18$。可以证明，第 $46666666$ 个下坠数对应的 $y > 10^{18}$。

------------

#### 数据范围

对于 $100\%$ 的数据满足：$Q \leq 10^5$，$k \leq 5 \times 10^7$。

其中对于 $10\%$ 的数据满足：$k \leq 100$。

对于 $30\%$ 的数据满足：$k \leq 5 \times 10^3$。

对于另外 $20\%$ 的数据满足：对于所有被询问到的下坠数 $x$，都有 $\vert x-y \vert \leq 100$ 或者 $y > 10^{18}$。

**请注意不同寻常的时间限制。**

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
1 2 3```

## 样例 #2

### 输入

```
3
9 14 46666666```

### 输出

```
9 18 -1```

# 题解

## 作者：masonpop (赞：2)

非常好的一道题。感觉是一道数学题和一个魔幻贪心的拼接。
* 感谢出题组和负责人对蒟蒻的热情帮助。
* 回归正题。发现每一位 $+1$ 的范围是 $[2,10]$。 注意到，带 $0$ 的位是没有作用的，因为不会改变数值，而且对最小值没有任何帮助。
* 由于是 $2$ 到 $10$ 内的数相乘得到，那么 $f(y)$ 能取到的值必定形如 $2^a3^b5^c7^d$。 反之容易验证也成立。
* 这是重要的一步。做题多的同学可以想到 [P1748](https://www.luogu.com.cn/problem/P1748) 正好说的就是这件事。那么，我们就可以维护四个指针 $a,b,c,d$， 表示可能通过乘 $ 2,3,5,7$ 得到当前数的位置。(听不懂的同学可以参考那道题第一篇题解或者手动模拟下我这个过程，也可以先 $\color{green}\text{A}$ 了那道题再来看这道题）。
* 而且，注意到如果 $y\leq 10^{18}$， 那么 $f(y)$ 也一定不超过 $10^{18}$ 的范围。这是因为显然当 $y$ 取 $10^{18}-1$ 即 $18$ 个 $9$ 时，$f(y)$ 取最大值 $10^{18}$。 但反之，不是所有的下坠数对应的最小 $y$ 都满足范围。因此，我们可以先生成 $[1,10^{18}]$ 的所有下坠数，实在不行就暴力生成再排序（指数不可能太大）。这部分的复杂度是 $O(T),T$ 是范围内下坠数的个数。代码如下。
```cpp
int a=0,b=0,c=0,d=0;
h[0]=1;
for(int i=1;i;i++)
{
    	h[i]=min(min(h[a]*2,h[b]*3),min(h[c]*5,h[d]*7));
    	if(h[i]>1e18)break;
    	tot=i;
    	if(h[i]==h[a]*2)a++;
    	if(h[i]==h[b]*3)b++;
    	if(h[i]==h[c]*5)c++;
    	if(h[i]==h[d]*7)d++;
}
```
* 打完表发现这样的数出去 $1$ 只有 $66060$ 个。因此如果 $k>66060$ 就可以直接报告无解了。
* 再考虑怎么根据 $f(y)$ 的值求最小的 $y$。 显然要将 $y$ 拆成 $[2,10]$ 的数相乘，再减一依次输出。 这里有一步贪心，即如下结论。

**结论：从大到小，能拆分就一定拆分。**
* 我们可以简单证明一下，就以 $10$ 为例吧。
* 比如你在一个数 $x$ 中有 $10$ 的时候不去拆 $10$，考虑到质因子 $2,5$ 一定在 $2,4,5,8$ 中，而无论是拆成 $4,5$ 还是 $5,8$ 显然没有 $2,10$ 和 $4,10$ 优。拆成 $2,5$ 显然不可取，因为位数增加了。
* 其他数类似，从大到小依次证明即可。
* 那么按照上述过程拆分即可。
* 注意一个小细节，就是上面所说的，我们需要判断拆分成的这个最小的数是否在 $[1,10^{18}]$ 内。直接判断其位数与 $18$ 的大小关系即可，若 $>18$  就报告无解。
* 这部分的时间复杂度是 $O(1)$，最坏运算 $20$ 次左右。
* 总时间复杂度是 $O(T+Qc),c$ 是一个小常数。
* 代码可能没有出题人的简单，因为询问是直接一个一个除的，但是清晰易懂。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int unsigned long long
int t,k;
int h[114514];
int tot;
signed main()
{
    int a=0,b=0,c=0,d=0;
    h[0]=1;
    for(int i=1;i;i++)
    {
    	h[i]=min(min(h[a]*2,h[b]*3),min(h[c]*5,h[d]*7));
    	if(h[i]>1e18)break;
    	tot=i;
    	if(h[i]==h[a]*2)a++;
    	if(h[i]==h[b]*3)b++;
    	if(h[i]==h[c]*5)c++;
    	if(h[i]==h[d]*7)d++;
	}
	scanf("%llu",&t);
    while(t--)
    {
    	int k;
    	scanf("%llu",&k);
    	if(k>tot)printf("-1 ");
    	else
    	{
    		int tmp=h[k];
    		int cnt2,cnt3,cnt4,cnt5,cnt6,cnt7,cnt8,cnt9,cnt10;
    		cnt2=cnt3=cnt4=cnt5=cnt6=cnt7=cnt8=cnt9=cnt10=0;
    		while(tmp && tmp%10==0)tmp/=10,cnt10++;
    		while(tmp && tmp%9==0)tmp/=9,cnt9++;
    		while(tmp && tmp%8==0)tmp/=8,cnt8++;
    		while(tmp && tmp%7==0)tmp/=7,cnt7++;
    		while(tmp && tmp%6==0)tmp/=6,cnt6++;
    		while(tmp && tmp%5==0)tmp/=5,cnt5++;
    		while(tmp && tmp%4==0)tmp/=4,cnt4++;
    		while(tmp && tmp%3==0)tmp/=3,cnt3++;
    		while(tmp && tmp%2==0)tmp/=2,cnt2++;
    		if(cnt2+cnt3+cnt4+cnt5+cnt6+cnt7+cnt8+cnt9+cnt10>18)
    		{
    			printf("-1 ");
    			continue;
			}
    		for(int i=1;i<=cnt2;i++)printf("1");
    		for(int i=1;i<=cnt3;i++)printf("2");
    		for(int i=1;i<=cnt4;i++)printf("3");
    		for(int i=1;i<=cnt5;i++)printf("4");
    		for(int i=1;i<=cnt6;i++)printf("5");
    		for(int i=1;i<=cnt7;i++)printf("6");
    		for(int i=1;i<=cnt8;i++)printf("7");
    		for(int i=1;i<=cnt9;i++)printf("8");
    		for(int i=1;i<=cnt10;i++)printf("9");
    		printf(" ");
		}
	}
    return 0;
}
```

总结：遇到这种带有数学性质的题目时，要好好分析题目里面的条件，大胆猜结论，先猜后证，避免朝一个方向上死磕。

希望这篇题解能帮到其他同学，写这篇题解同样加深了我对这道题的理解。

---

## 作者：Demeanor_Roy (赞：2)

- 出题人题解。

------------

要找第 $k$ 小的下坠数，还是要从函数 $f$ 本身入手。

不难发现正整数 $f(x)$ 一定可以表示成若干个不超过 $10$ 的数的乘积，于是推广可得引理一。

**引理1：当且仅当正整数 $x$ 没有 $2,3,5,7$ 以外的质因子时，$x$ 为下坠数。**

考虑证明：

- 充分性：这样的 $x$ 一定可以表示成 $2^{k1}3^{k2}5^{k3}7^{k4}$ 的形式，于是令 $y$ 为 $k1$ 个 $1$，$k2$ 个 $2$，$k3$ 个 $4$，$k4$ 个 $6$ 顺次拼接而成，则一定有 $f(y)=x$。

- 必要性：若 $x$ 有 $2,3,5,7$ 以外的质因子，则 $x$ 一定无法表示成若干个不超过 $10$ 的数的乘积，这与下坠数的性质不符。

看到这儿，做题多的读者就应该感到一些似曾相识。我们发现，下坠数与这道题的 [H数](https://www.luogu.com.cn/problem/P1748) 几乎等价，于是考虑维护四个单调不减的指针，在线性的时间求出前 $n$ 个下坠数。

那 $n$ 到底应该取几呢？这时就需要另一个结论。

**引理2：当 $x \leq 10^{18}$时，必然不存在 $f(x) > 10^{18}$。**

这是因为当 $x \in [1,10^{18}]$ 时，$f(x)$ 在 $x = 10^{18} -1$ 时取到最大，为 $10^{18}$，所以结论得证。

因为题意要求当 $y > 10^{18}$ 时输出 $-1$，所以将 $[1,10^{18}]$ 中所有下坠数都筛出来，就可以保证所有对应 $y$ 值在 $[1,10^{18}]$ 的下坠数被筛出来。据此可得 $n=66061$，于是当输入的 $k > n$ 时，输出 $-1$ 即可。

于是现在只剩下一个问题，已知 $x$ 的情况下，如何得到对应的 $y$。

我们不妨将 $x$ 分解成 $[2,10]$ 之间的数的乘积，之后将这些数减一后从小到大顺次拼接得到整数 $y$，不难发现最小的使得 $f(y)=x$ 的 $y$ 一定能这样得到。接下来思考如何分解是最优的，根据贪心可得引理三。

**引理3：从大到小，能分解则分解一定是最优的贪心策略。**

引理三可以从大到小用反证法顺次证明。这里以 $10$ 为例：若最优策略在能分解成 $10$ 的前提不分解成 $10$，考虑到质因子 $2,5$ 一定在 $2,4,5,8$ 中，于是对于任意一种情况，如 $4,5$ 替换成 $2,10$，$8,5$ 替换成 $4,10$ 都能得到更小的 $y$，于是可以反证出能分解为 $10$ 一定分解为 $10$，顺次证明可得引理三。

于是我们预处理出所有 $[1,10^{18}]$ 中的下降数及其对应 $y$ 值，若 $y > 10^{18}$ 则保存 $-1$，$O(1)$ 回答询问即可。时间复杂度 $O(nc+Q)$，其中 $n$ 是下坠数个数，$c$ 是一个小常数。

这里顺便阐明一下部分分依据：

1. 第一档给的是纯暴力，基本写了就能过。

2. 第二档应该打表加会最后一个贪心能过，没细算，可能会被玄学算法卡过。

3. 第三档就是给不会最后那个贪心的同学，找到下坠数暴力算 $y$ 即可。

至此这道题解决完毕，下附代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
const int N=1e5+10;
const LL maxn=1e18;
int n,m,p[5]={0,2,3,5,7},it[5],cur[5],cost[11][5];
vector<int> vec;
struct node
{
	int d[5];LL val,res;
}f[N];
inline void find(int now)
{
	memcpy(cur,f[now].d,sizeof cur);
	for(int i=10;i>=2;i--) 
	{
		bool vaild=true;
		while(vaild)
		{
			for(int j=1;j<=4;j++) if(cur[j]<cost[i][j]) vaild=false;
			if(vaild) 
			{
				vec.push_back(i-1);
				for(int j=1;j<=4;j++) cur[j]-=cost[i][j];				
			}
		}
	}
	reverse(vec.begin(),vec.end());
	if(vec.size()>18) f[now].res=-1;
	else for(auto x:vec) f[now].res=f[now].res*10+x;
	vec.clear();
}
inline void prework()
{
	for(int i=2;i<=10;i++)
	{
		int tmp=i;
		for(int j=1;j<=4;j++) while(tmp%p[j]==0) tmp/=p[j],cost[i][j]++;
	}
	f[++n].val=it[1]=it[2]=it[3]=it[4]=1;	
	while(f[n].val<=maxn)
	{
		f[++n].val=maxn<<1;
		for(int i=1;i<=4;i++) 
			if(f[it[i]].val*p[i]<=f[n].val) 
			{
				f[n].val=f[it[i]].val*p[i];
				memcpy(f[n].d,f[it[i]].d,sizeof f[n].d);
				f[n].d[i]++;
			}
		find(n);
		for(int i=1;i<=4;i++) while(f[it[i]].val*p[i]<=f[n].val) it[i]++;
	}
}
int main()
{
	prework();
	scanf("%d",&m);
	while(m--)	
	{
		int x;
		scanf("%d",&x);
		printf("%lld ",f[min(n,x+1)].res);
	}
	return 0;
}
```






---

## 作者：RAY091016 (赞：0)

### 1. 题目解释

定义一个数 $x$ 的下坠数为 $\prod\limits_{i=0}^{\left\lfloor log_{10}n\right\rfloor}(x/10^i) \bmod 10$，现询问使得其下坠数为第 $i$ 个下坠数的数 $p$。

（为了严谨一点就这么写了，仔细体会。）

### 2. 思路

感觉是道缝合题，做题多的同学可以参考 [P1748 H 数](https://www.luogu.com.cn/problem/P1748)和 [P2821 变幻数](https://www.luogu.com.cn/problem/P2821)理解。

首先我们发现题目中有多组询问，考虑预处理下坠数。

我们可以发现，由于一个数各位数字的范围在 $[0,9]$ 之间，故其下坠数的质因数必然在 $[2,10]$ 之间，即其质因数只有 $2$，$3$，$5$，$7$。

这就让我们想到 P1748 中 H 数的构造了。

而这题有一个坑是 $1$ 不是下坠数，所以要定义 $h_0=1$ 而非 $h_1=1$，这样 $h_i$ 才是第 $i$ 个下坠数。

而且这题要求 $p\le 10^{18}$，因此我们在预处理时，只要 $h_i>10^{18}$ 就直接退出循环。

然后就是下坠数的求解了。

这里有一个贪心：从 $10$ 开始试除，只要能除尽就直接除。

这是基于 P2821 的一个贪心，具体可见[这篇文章](https://www.luogu.com.cn/article/lyrvwhn0)中一个类似的想法。

最后，如果总位数超过 $18$（即除了超过 $18$ 次），就输出 $-1$。

代码可利用 P1748 和 P2821 稍加改动得到，就不放了。

---


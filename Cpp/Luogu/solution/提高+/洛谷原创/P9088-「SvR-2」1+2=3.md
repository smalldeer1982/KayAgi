# 「SvR-2」1+2=3

## 题目描述

你有一些木棒，每个木棒左边有一个数，右边有一个数，数只有 $0,1,2$，你要将所有木棒拼起来，使相邻的数和为 $3$ 的对数最大。

例如，$1\text{ - }2$ 和 $1\text{ - }0$ 两个木棒，如果按 $1\text{ - }0,1\text{ - }2$ 这样拼，相邻的数和为 $3$ 的对数是 $0$；而按 $1\text{ - }\textcolor{red}{\underline{\textbf 2}},\textcolor{red}{\underline{\textbf 1}}\text{ - }0$ 这样拼相邻的数和为 $3$ 的对数是 $1$，因为 $2+1=3$。

## 说明/提示

#### 数据规模与约定

对于全部数据，保证 $1\le T\le 10^5$，记 $a_{i,j}$ 表示 $i\text-j$ 木棒的个数，保证 $0\le a_{i,j}\le 10^9$。

**本题自动开启捆绑测试和 O2 优化。**

记 $sum$ 表示一个测试点中所有数据的所有 $a_{i,j}$ 之和。

| Subtask | $T$ | $sum$ | 特殊性质 |分值 |
| :------: | :------: | :------: | :------: | :------: |
| $1$ | $1 \leq T \leq 10$ | $1\le sum\le 10$ |无| $10 \operatorname{pts}$ |
| $2$ | $1 \leq T \leq 50$ | $1\le sum\le 80$ | 无|$20 \operatorname{pts}$ |
| $3$ | 无特殊限制 | 无特殊限制 |A| $15\operatorname{pts}$ |
| $4$ | 无特殊限制 | 无特殊限制 |B| $20 \operatorname{pts}$ |
| $5$ | $1\le T\le 1000$ | 无特殊限制 |C| $20 \operatorname{pts}$ |
| $6$ | 无特殊限制 | 无特殊限制 |无| $15 \operatorname{pts}$ |

特殊性质 A：$a_{i,j}$ 在 $[0,10^9]$ 中均匀随机生成。

特殊性质 B：所有 $a_{i,j}>0$。

特殊性质 C：所有 $a_{i,j}\le 100$。

## 样例 #1

### 输入

```
3
4 1 3 4 7 7 9 10 3
6 3 6 4 3 4 5 6 6
6 10 7 1 4 2 6 4 2
```

### 输出

```
31
23
19
```

# 题解

## 作者：lndjy (赞：12)

官方题解

第一个部分分是爆搜，第二个是记忆化。

A 性质是随便写的贪心就能过。C 性质是给的推出来贪心策略而不是直接求答案的人。

众所周知我是良心出题人，所以这题必然不可能让你巨大分类讨论，你首先要坚信这题有简单做法。

直接考虑构造策略是困难的，可以换个角度，考虑答案的上界，有一个比较明显的是 $\min(1-?,?-2)+\min(2-?,?-1)$。如果上界能取到的话，也就是说每个 $\min$ 里面较小的值对应的每一个木棒都能和对应的拼上。可以发现 B 性质满足条件。想到这里的话造小数据对拍不断修正应该就可以得到正解了。

考虑为什么有时会不够每一个都能和对应的拼上。如果所有的都是 $1-2$，你需要拼成一条链，就有一个拼不上。$2-1$ 同理。

但这样还不够。按照上面方式计算出的是所有木棒围成一个环的答案，而要求的是一条链，所以计算出的答案等于所有非 $0-0$ 木棒数量的和，那么答案要减一。

如果对这个做法的可行性有疑问，可以这样理解，这也是构造方案：对于一个 $i-1$ 和 $2-j$，把这两个“粘贴”在一起，答案+1，同时把这两个删除，变成一个 $i-j$。$2+1$ 同理。这样就能构造出上面求的答案，而最优性上面已经说了。

赛时发现了很多其他做法，欢迎来写题解！

---

## 作者：Zwb0106 (赞：9)

**[原题链接](https://www.luogu.com.cn/problem/P9088)**

------------

~~你说得对，但是《分类讨论》……后面忘了。~~

提供一个分类讨论的构造做法。


------------
## 思路

首先木棒只有 9 种，要做的就是尽可能凑出 $1+2=3$ 这样的数对，并求出最多配对数目，我们考虑用什么方式能简化这个问题。

目标就是尽可能地多配对，直到无法配对为止。

可以发现有这样三个性质：

1. 假设有 $k$ 个 $1-2$ 或 $2-1$ 型的木棒，那么我们能将它们通过首尾相接的方式变为 $1$ 个 $1-2$ 或 $2-1$ 型的木棒，并且造成 $k-1$ 的贡献；
2. 假设有 $a$ 个 $1-1$ 和 $b$ 个 $2-2$，不妨设 $a>b$，那么我们可以用 $b+1$ 个 $1-1$ 和 $b$ 个 $2-2$ 交错相接，变为 $1$ 个 $1-1$，即 $a \leftarrow a-b$，并造成 $2b$ 的贡献（$a<b$ 时同理，特别地，$a=b$ 时可在 $1-2$ 与 $2-1$ 中任选其一）；
3. 若 $1-1$ 和 $2-2$ 中有一种初始数目不为 $0$，且此时 $1-2$ 或 $2-1$ 的数目不为 $0$，可以通过与 $1-1$ 或 $2-2$ 连接的方式消去，该操作不会影响 $1-1$ 和 $2-2$ 的数目，造成 $1$ 的贡献（根据性质 $1$，最多剩 $1$ 个）。

此外，$0-0$ 不会对答案造成任何影响，这一点显然。

按以上性质操作，此时 $1-1$ 和 $2-2$ 最多只会有其中一种，且 $1-2$ 和 $2-1$ 的数目不为 $0$ 当且仅当 $1-1$ 和 $2-2$ 的数目相等。

于是我们按照以下情况分类讨论：

1. $1-1$ 的数目多于 $2-2$ 的数目；
2. $1-1$ 的数目少于 $2-2$ 的数目；
3. $1-1$ 的数目等于 $2-2$ 的数目，且均不为 $0$；
4. $1-1$ 的数目与 $2-2$ 的数目均为 $0$。

对于剩余的 $1-1,2-2,1-2,2-1$，尽可能多地让 $0-?,?-0$ 类型的木棒与之配对，在此之后，这些木棒若仍剩余，不会造成更多贡献，此时尽可能多地进行 $0-1$ 与 $2-0$ 以及 $0-2$ 与 $1-0$ 的配对即可。

以上是大概做法，写起来还是有不少细节，具体见代码。

------------
### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define db double
#define ldb long double
#define gc getchar
#define pc putchar
#define lowbit(x) (x&-x)
#define mp make_pair
#define fs first
#define sc second
using namespace std;
int T;
ll a[3][3],ans;
ll read()
{
	ll x=0,f=1;
	char ch=gc();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=gc();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+(ch^48),ch=gc();
	}
	return x*f;
}
void print(ll x)
{
	if(x<0)pc('-'),x=-x;
	if(x>9)print(x/10);
	pc(x%10+48);
}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	
	T=read();
	while(T--)
	{
		ans=0;
		for(int i=0;i<=2;i++)
			for(int j=0;j<=2;j++)a[i][j]=read();
		
		if(a[1][2])ans+=a[1][2]-1,a[1][2]=1;
		if(a[2][1])ans+=a[2][1]-1,a[2][1]=1;
		
		if(a[1][1]>a[2][2])
		{
			ans+=a[2][2]*2,a[1][1]-=a[2][2];
			
			if(a[1][2])ans++;
			if(a[2][1])ans++;
			
			ll tmp=0;
			
			tmp=min(a[0][2],a[1][1]);
			ans+=tmp;
			a[0][1]+=tmp,a[0][2]-=tmp,a[1][1]-=tmp;
			
			tmp=min(a[1][1],a[2][0]);
			ans+=tmp;
			a[1][0]+=tmp,a[1][1]-=tmp,a[2][0]-=tmp;
			
			ans+=min(a[0][1],a[2][0])+min(a[0][2],a[1][0]);
		}
		else if(a[1][1]<a[2][2])
		{
			ans+=a[1][1]*2,a[2][2]-=a[1][1];
			
			if(a[1][2])ans++;
			if(a[2][1])ans++;
			
			ll tmp=0;
			
			tmp=min(a[0][1],a[2][2]);
			ans+=tmp;
			a[0][2]+=tmp,a[0][1]-=tmp,a[2][2]-=tmp;
			
			tmp=min(a[2][2],a[1][0]);
			ans+=tmp;
			a[2][0]+=tmp,a[2][2]-=tmp,a[1][0]-=tmp;
			
			ans+=min(a[0][1],a[2][0])+min(a[0][2],a[1][0]);
		}
		else
		{
			if(a[1][1])
			{
				if(a[1][2])ans++;
				if(a[2][1])ans++;
				
				ans+=a[1][1]*2-1;
				
				if(a[0][2]||a[1][0]||a[0][1]||a[2][0])ans++;
				
				ans+=min(a[0][2],a[1][0])+min(a[0][1],a[2][0]);
			}
			else
			{
				ans+=min(a[1][2],a[1][0])+min(a[0][1],a[2][1]);
				a[1][2]-=min(a[1][2],a[1][0]);
				a[2][1]-=min(a[0][1],a[2][1]);
				
				ans+=min(a[0][2],a[1][2])+min(a[2][1],a[2][0]);
				a[1][2]-=min(a[0][2],a[1][2]);
				a[2][1]-=min(a[2][1],a[2][0]);
				
				ans+=min(a[0][2],a[1][0])+min(a[0][1],a[2][0]);
			}
		}
		print(ans),pc('\n');
	}
	return 0;
}
```

---

## 作者：CF_1_2_3_4_5_9 (赞：6)

首先 $0-0$ 显然是无用的。

记每组输入中的 $9$ 个数分别为 $a_1,a_2,a_3,a_4,a_5,a_6,a_7,a_8,a_9$。

为了方便以下的阅读，给出对应表格。

|木棒类型|对应编号|
|:-:|:-:|
|$0-0$|$a_1$|
|$0-1$|$a_2$|
|$0-2$|$a_3$|
|$1-0$|$a_4$|
|$1-1$|$a_5$|
|$1-2$|$a_6$|
|$2-0$|$a_7$|
|$2-1$|$a_8$|
|$2-2$|$a_9$|

最优情况下，每一个以 $1$ 开头的木棒都和一个以 $2$ 结尾的木棒匹配；每一个以 $2$ 开头的木棒都和一个以 $1$ 结尾的木棒匹配，此时答案为 $\min(a_2+a_5+a_8,a_7+a_8+a_9)+\min(a_3+a_6+a_9,a_4+a_5+a_6)$。

显然，这个最优情况并不能在所有时候都取到，考虑什么时候答案需要微调。

- 对于可以“自匹配”的两种木棒，即 $a_6$ 和 $a_8$，我们发现按照上面的计算方式，当只有这两种类型的木棒中的恰好一种时，算出的答案即为该种木棒的数量，但这是错误的。例如有 $3$ 个 $1-2$ 的时候，由于要求拼出的是“链形”而非“环形”，所以只能拼出 $(1-2)-(1-2)-(1-2)$，答案为 $2$，所以结论是，当只有 $a_6$ 或者 $a_8$ 的类型的木棒时，答案需要 $-1$。

- 在完成第一次微调之后，如果此时答案仍然为所有非 $0-0$ 木棒数量之和，显然这是不可能的，由于 $0-0$ 对答案的贡献是 $0$，可以先不考虑它，则其他所有木棒数量和为 $a_2+a_3+a_4+a_5+a_6+a_7+a_8+a_9$，只会产生 $a_2+a_3+a_4+a_5+a_6+a_7+a_8+a_9-1$ 个相邻木棒数对，所以答案在这种情况下也需要 $-1$（另一种解释是：此时的答案依然是“环形”的，即最后一个木棒的第二个数与第一个木棒的第一个数的和为 $3$，而这一组也被计算进了答案里，由于题目要求为链，选择任意一个位置断环成链即可，答案减少 $1$）。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	int t;
	cin>>t;
	while(t--){
		int a[15];
		for(int i=1;i<=9;i++){
			cin>>a[i];	
		}
		cout<<max(0ll,min(a[2]+a[5]+a[8],a[7]+a[8]+a[9])+min(a[3]+a[6]+a[9],a[4]+a[5]+a[6])-(a[2]+a[5]+a[8]==a[8]&&a[7]+a[8]+a[9]==a[8]&&a[7]+a[8]+a[9])-(a[3]+a[6]+a[9]==a[6]&&a[4]+a[5]+a[6]==a[6]&&a[3]+a[6]+a[9])-(a[2]+a[3]+a[4]+a[5]+a[6]+a[7]+a[8]+a[9]==min(a[2]+a[5]+a[8],a[7]+a[8]+a[9])+min(a[3]+a[6]+a[9],a[4]+a[5]+a[6])-(a[2]+a[5]+a[8]==a[8]&&a[7]+a[8]+a[9]==a[8]&&a[7]+a[8]+a[9])-(a[3]+a[6]+a[9]==a[6]&&a[4]+a[5]+a[6]==a[6]&&a[3]+a[6]+a[9])))<<endl;
	}
}
```

---

## 作者：int08 (赞：4)

## 前言
不会证明，但是过了。
## Solution
我们充分相信出题人是善良的，这题应该不会巨大分讨。

有 $9$ 种木棍，太多了，我们考虑删一些。

首先 $0-0$ 直接忽略。

其次发现 $1-2,2-1$ 非常特殊，每一种如果有多个，可以自己连起来缩成一个，中间全部能贡献，而且以 $1-2$ 为例，只要外面有 $0-2,2-2,1-0,1-1$ 中任何一个，就可以直接把所有 $1-2$ 全部给过去，产生 $a_6$ 的贡献，否则只有 $a_6-1$。

现在只剩六种了，$0-1,0-2,1-0,1-1,2-0,2-2$。

显然有一个答案上界是 $\min(a_2+a_5,a_7+a_9)+\min(a_4+a_5,a_3+a_9)$，意思是取左侧是 $1$ 和右侧是 $2$ 的最小值加上左侧是 $2$ 和右侧是 $1$ 的最小值。

不过我们发现这个上界似乎很容易取到，因为有大量的 $0$，拿它们来作为缓冲就好了，就算 $0$ 很少，当两边数量差得多的时候也可以拿一边缓冲。

如果完全没有 $0$，而且各项的出现次数相等，就取不到上界（最左侧和最右侧两数无法匹配），此时将答案减 $1$ 就行了。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int T,i,a[10];
signed main()
{
	cin.tie(0)->sync_with_stdio(0);cout.tie(0);
	cin>>T;
	while(T--)
	{
		for(i=1;i<=9;i++) cin>>a[i];
		int ans=0;
		if(a[8])
		{
			ans+=a[8]-1;
			if(a[2]||a[5]||a[7]||a[9]) ans++;
		}
		if(a[6])
		{
			ans+=a[6]-1;
			if(a[3]||a[4]||a[5]||a[9]) ans++;
		}
		ans+=min(a[2]+a[5],a[7]+a[9])+min(a[4]+a[5],a[3]+a[9]);
		if(!a[2]&&!a[3]&&!a[4]&&!a[7]&&a[5]==a[9]&&a[5]) ans--;
		cout<<ans<<endl;
	}
	return 0;
 } 
```
# The End.

---

## 作者：_Cheems (赞：1)

菜鸡看完官方题解后恍然大悟，有感而发。

首先 $(0,0)$ 就是个 fw，排除它计算就好。

能产生贡献的配对无非只有：$(?,1)\to (2,?)$、$(?,2)\to (1,?)$。

考虑其中一种形式，看起来像是个二分图匹配，应当是两边的点集大小取 $\min$。

但是若有 $(2,1)$ 这种同时算作二分图两个点集的，就可能会影响答案，不妨让 $(2,1)$ 向对面点集连一条虚边，不能选但是可用来判断是否有环。

那么只会在全都是 $(2,1)$ 时必然出现环、多算 $1$。对于其它情况，可以让最后一个 $(2,1)$ 向其它数对连边，避免成环。$(1,2)$ 同理。

所以应该得到若干条链，将它们首尾相连即可。那么最后答案就是两种形式的和。

但是，这样还是可能出现环！若每个木棒的左右都有对应匹配（即答案为非 $(0,0)$ 数对之和），那么必然构成环，而且可以证明这是唯一一种有环的方案（类比前面构造）。于是答案会多算 $1$，记得特判。
#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
int T, a[3][3], sm, ans;

signed main(){
	cin >> T;
	while(T--){
		sm = 0;
		for(int i = 0; i < 3; ++i)
			for(int j = 0; j < 3; ++j) scanf("%lld", &a[i][j]), sm += a[i][j];
		int cnt1 = a[0][1] + a[1][1] + a[2][1], cnt2 = a[2][0] + a[2][1] + a[2][2];
		int _cnt1 = a[0][2] + a[1][2] + a[2][2], _cnt2 = a[1][0] + a[1][1] + a[1][2]; 
		ans = min(cnt1, cnt2) + min(_cnt1, _cnt2);
		if(cnt1 == a[2][1] && cnt2 == a[2][1] && cnt1) --ans;
		if(_cnt1 == a[1][2] && _cnt2 == a[1][2] && _cnt1) --ans;
		if(ans && sm - a[0][0] == ans) --ans;
		printf("%lld\n", ans);
	}
	return 0;
}
```

---


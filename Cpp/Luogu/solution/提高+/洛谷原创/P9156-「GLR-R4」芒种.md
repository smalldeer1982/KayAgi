# 「GLR-R4」芒种

## 题目背景

&emsp;&emsp;「晴云轻漾，熏风无浪，开樽避暑争相向」

---

&emsp;&emsp;“高考周啊……”

&emsp;&emsp;今天倒是没有抢场的压力，不过甚至没人敢出训练室，毕竟对面教学楼就是正在进行高考的考场。

&emsp;&emsp;“我们明年说不定就在对面了。”虽然下午的训练结束，但今天食堂安排特殊，天依和阿绫还得在休息室里腻歪好一会儿。

&emsp;&emsp;“阿绫，饿……”像是听不见食物以外的话题，天依躺在沙发上，手指绕着头发——绕着阿绫的头发，抱怨着。

&emsp;&emsp;“来玩个游戏吧。”


---

&emsp;&emsp;**芒种**&emsp;「冰苏打烦躁气泡都融化
　慵懒的风快趁虚而入吧」

## 题目描述

&emsp;&emsp;*双重神经衰弱* 是一个极其考验记忆力的卡牌游戏，其规则如下。

&emsp;&emsp;有 $n$ 种不同类型的卡牌，每种两张，初始时这 $2n$ 张牌全部倒扣在桌面上。两位玩家轮流操作，每次操作选择两张**不同的**牌**同时**翻起，这两张牌将对双方展示，此后：

- 若两张牌类型相同，则操作者得 $1$ 分，将这两张牌拿走。下一次操作由**当前操作者**继续进行。

- 否则，操作者将这两张牌扣回。下一次操作轮到**对方**进行。

&emsp;&emsp;当所有牌全部被拿走时，游戏结束。

&emsp;&emsp;两位玩家的目标都是最大化自己的最终得分。此外，在**双方同意**的情况下，两人可以选择和局。设和局时还剩下 $2n'$ 张牌，则双方各获得 $n'/2$ 分，游戏结束。为避免游戏无法结束的情况，我们认为：当选择和局同时是双方的最优选择**之一**时，双方会立即和局。

---

&emsp;&emsp;现在，阿绫和天依想来玩玩这个游戏。因为太饿，负责摆牌的天依不小心把 $2n$ 张牌中的 $m$ 张牌牌面朝上地摆放了，**这 $m$ 张牌的的类型恰好两两不同**，双方悄悄记住了它们的类型和位置，并将它们扣回，然后开始游戏。我们假定天依和阿绫过目不忘且聪明绝顶，能够记住所有被展示过的牌（包括最初 $m$ 张牌）的类型和位置，也都会采取最优策略最大化自己的期望得分。作为先手方的阿绫想要知道自己的期望得分，你可以帮帮她吗？

&emsp;&emsp;由于她们真的要在休息室腻歪好一会儿，所以你需要对 $T$ 组的 $(n,m)$ 分别求出答案。

## 说明/提示

#### 样例 #1 解释

对于第一组数据，先手翻起的一对牌类型必然相同，将其拿走，游戏结束。先手期望得分为 $1$。

对于第三组数据，可以证明，双方会在游戏开始时同意和局。先后手期望得分都是 $1$。

### 数据规模与约定

对于 $100\%$ 的数据，$1\le n\le5\times10^3$，$0\le m\le n$。

对于不同的子任务，作如下约定：

| 子任务编号 |      $n,m$       |       $T$        | 特殊性质 | 子任务分值 |
| :--------: | :--------------: | :--------------: | :------: | :--------: |
|    $1$     |      $\le2$      |      $\le5$      |    无    |    $10$    |
|    $2$     |      $\le8$      |     $\le44$      |    无    |    $20$    |
|    $3$     | $\le5\times10^3$ | $\le5\times10^3$ |    有    |    $10$    |
|    $4$     | $\le5\times10^3$ |       $=1$       |    无    |    $20$    |
|    $5$     | $\le5\times10^3$ | $\le5\times10^3$ |    无    |    $40$    |

-   特殊性质：$n=m$。


## 样例 #1

### 输入

```
4
1 0
2 1
2 2
3 3```

### 输出

```
1.000000
1.333333
1.000000
1.500000```

# 题解

## 作者：Rainybunny (赞：7)

# $\mathscr{Description}$

&emsp;&emsp;[Link](), 懒得概括题意.jpg

# $\mathscr{Solution}$

&emsp;&emsp;**Subtask 1** $(n,m\le2)$&emsp;一共只有五种情况, 样例已经给出了三种, 剩下两种自己手玩就行啦!

&emsp;&emsp;**Subtask 2** $(n,m\le8)$&emsp;奇奇怪怪的状压, 或者忘记记忆化的各色搜索应该都能得到这档.

&emsp;&emsp;**Subtask 3** $(n=m)$&emsp;观察样例可以发现, 此时也许有 $\textit{ans}=n/2$, 特别的, 当 $n=m=1$ 时, $\textit{ans}=1$. 严谨的说, 我们可以证明, 当 $n=m>1$ 时, 双方一开始就会和局.

&emsp;&emsp;尝试归纳证明. 假设当 $2\le n\le n_0$ 时, 先手期望得分不低于后手. 现在, 我们来考虑 $n=n_0+1$ 的情况. 此时先手一共只有三种决策:

1.  选择两张未知牌 (未知牌共 $2n-m=n=m$ 张);

2.  选择一张已知牌 (已知牌共 $m$ 张), 一张未知牌;

3.  选择两张已知牌.

&emsp;&emsp;对于第一种决策, 因为已知牌中 $n$ 种类型都已经出现, 所以先手不可能拿到相同类型的牌. 此时先手必然结束自己的回合. 而后手可以立马 "捡漏", 将先手翻出的两张牌和已知的两张牌分别配对, 得到 $2$ 分. 接着, 后手变为先手, 面对 $n\gets n-2$ 的情况. 根据归纳假设, 此时的先手期望得分不劣于后手, 所以在这种决策下, 原先手的期望得分低于后手.

&emsp;&emsp;对于第二种决策, 类似的, 先手有 $1/n$ 的概率直接拿出一对同类卡牌, 以 $(n-1)/n$ 的概率给后手 "打工", 而二者都会递归到 $n\gets n-1$ 的情况. 设 $n\gets n-1$ 时, 先手期望得分为 $x~(x\ge (n-1)/2)$, 那么原来先手的期望得分为:
$$
\begin{aligned}
	E &= \frac{1}{n}(1+x)+\frac{n-1}{n}(n-1-x)\\
	&= \frac{1}{n}+\frac{(n-1)^2}{n}-\frac{n-2}{n}x\\
	&\le \frac{1}{n}+\frac{(n-1)^2}{n}-\frac{(n-1)(n-2)}{2n}\\
	&= \frac{2+2n^2-4n+2-n^2+3n-2}{2n}\\
	&= \frac{n}{2}-\frac{1}{2}+\frac{1}{n}.
\end{aligned}
$$
可见 $n\ge2$ 时都有 $E\le\frac{n}{2}$, 也即是原先手期望得分低于后手.

&emsp;&emsp;于是, 先手选择了第三种决策! 第三种决策没有任何效果, 仅仅是 "摆烂" 地过掉自己回合, 轮到对方操作. 此时对方又面临这三种决策的选择, 他又会 "摆烂" 过掉自己的回合 ... 双方都无法让自己的期望得分高于对方, 那么此时双方都会同意和局! 两人得分 $n/2$, 我们完成了归纳, 也顺带证明了游戏一开始即和局结束.&emsp;&emsp;$\square$

&emsp;&emsp;**Subtask 4** $(T=1)$&emsp;大概有什么一次只能求出一个答案的算法?

&emsp;&emsp;**Subtask 5**&emsp;来讲正解啦. 在 subtask 3 的证明过程中, 我们已经自然地引入了 "先手得分是否低于后手" 的讨论. 进一步的, 由于双方得分之和一定是 $n$, 所以我们可以用双方得分之差来刻画先手得分. 令 $f(n,m)$ 表示 $n$ 对牌, $m$ 张已知时, 先手期望得分 $-$ 后手期望得分的值. 还是来做一做同 subtask 3 证明过程中的三种讨论:

-   先手选择一张已知牌, 一张未知牌, 此时要求 $m\ge1$, 有转移:
    $$
    \begin{array}{ccl}
    f(n,m) & \overset{\max}{\longleftarrow} & \frac{1}{2n-m}(1+f(n-1,m-1))-\frac{m-1}{2n-m}(1+f(n-1,m-1))\\
    & & -\frac{2n-2m}{2n-m}f(n,m+1).
    \end{array}
    $$
    
-   先手选择两张未知牌, 此时要求 $2n-m\ge2$, 有转移:
    $$
    \begin{array}{ccl}
    f(n,m) & \overset{\max}{\longleftarrow} & \frac{n-m}{\binom{2n-m}{2}}(1+f(n-1,m))-\frac{\binom{m}{2}}{\binom{2n-m}{2}}(2+f(n-2,m-2))\\
    & & -\frac{m(2n-2m)}{\binom{2n-m}{2}}(1+f(n-1,m))-\frac{2(n-m)(n-m-1)}{\binom{2n-m}{2}}f(n,m+2).
    \end{array}
    $$

-   先手选择两张已知牌, 此时要求 $m\ge2$. 注意这里不是 $f(n,m)\overset{\max}{\longleftarrow}-f(n,m)$, 如果这种决策是优秀的, 双方会直接和局, 所以有:
    $$
    \begin{array}{ccl}
    f(n,m) & \overset{\max}{\longleftarrow} & 0.
    \end{array}
    $$

&emsp;&emsp;边界为 $f(0,0)=0$. 转移过程有很多细小情况的讨论, 可能会引入非法状态, 但这些非法状态的转移系数必然为 $0$, 所以不必过分担心. 直接递推或者记忆化搜索, 就能 $\mathcal O(nm)$ 求出所有 $f$. 最终答案即为 $(n+f(n,m))/2$.

## $\mathscr{Code}$

```cpp
/*+Rainybunny+*/

#include <bits/stdc++.h>

#define rep(i, l, r) for (int i = l, rep##i = r; i <= rep##i; ++i)
#define per(i, r, l) for (int i = r, per##i = l; i >= per##i; --i)

typedef double VType;
// typedef long double VType;

template <typename Tp>
inline void chkmin(Tp& u, const Tp& v) { v < u && (u = v, 0); }
template <typename Tp>
inline void chkmax(Tp& u, const Tp& v) { u < v && (u = v, 0); }
template <typename Tp>
inline Tp imin(const Tp& u, const Tp& v) { return u < v ? u : v; }
template <typename Tp>
inline Tp imax(const Tp& u, const Tp& v) { return u < v ? v : u; }

const int MAXN = 5e3;
bool vis[MAXN + 5][MAXN + 5];
VType f[MAXN + 5][MAXN + 5];

inline VType calc(const int n, const int m) {
    if (n <= 0 || m < 0 || n < m) return 0;
    VType& cur = f[n][m];
    if (vis[n][m]) return cur;
    vis[n][m] = true, cur = -1e100;
    if (m >= 1) {
        chkmax(cur, (1 + calc(n - 1, m - 1)
        - (m - 1) * (1 + calc(n - 1, m - 1))
        - 2 * (n - m) * calc(n, m + 1))
        / (2 * n - m));
    }
    if (2 * n - m > 1) {
        chkmax(cur, 2 * ((n - m) * (1 + calc(n - 1, m))
        - m * (m - 1) / 2 * (2 + calc(n - 2, m - 2))
        - 2 * m * (n - m) * (1 + calc(n - 1, m))
        - 2 * (n - m) * (n - m - 1) * calc(n, m + 2))
        / ((2 * n - m) * (2 * n - m - 1)));
    }
    if (m >= 2) chkmax(cur, 0.);
    return cur;
}

int main() {
    int T, n, m;
    scanf("%d", &T);
    while (T--) {
        scanf("%d %d", &n, &m);
        printf("%.12f\n", (n + calc(n, m)) / 2);
    }
    return 0;
}

```



---

## 作者：Vsinger_洛天依 (赞：6)

#### 思路

一眼期望（阿绫都问期望得分了能不是期望吗），开推。

- 选择一张已知牌一张未知牌的得分概率为 $p= \dfrac{1}{2n-m}$，后手得分的概率为 $p=\dfrac{m-1}{2n-m}$，先手得分则概率为$p= \dfrac{2n-2m}{2n-m}$，转移方程为
$$dp(n,m)=\max(dp(n,m),\dfrac{1+ dp(n-1,m-1) - (m-1)(1+dp(n-1,m-1)) - 2(n-m)\times dp(n,m+1)}{2n-m})$$

- 选择两张未知牌的先手得分概率为 $p=\dfrac{n-m}{((2n - m) \times ( 2n - m - 1))}$ 后手得分概率为$p=\dfrac{m\times(m-1)/2}{((2n - m) \times (2n - m - 1))}$，如果先手得分则概率变为$p=\dfrac{(n-m) \times (n-m-1)}{((2n - m) \times (2n - m - 1))}$。 转移方程为
$$dp(n,m)=\max(dp(n,m),\dfrac{2\times((n-m)\times(1+dp(n-1,m)) - m\times(m-1)/2 
\times(2+dp(n-2,m-2)) - 2\times m\times (n-m) \times (1+dp(n-1,m))
-2\times(n-m)\times(n-m-1) \times dp(n,m+2) }{(2*n-m)\times(2*n-m-1)})$$

- 先手选两张已知牌：如果这个是最优解后手也会选已知牌，那么会直接和棋，转移方程为
$$dp(n,m)=\max(dp(n,m),0)$$

然后组合一下这题就出来了。

#### 代码

感觉代码比上面那一堆简单多了。
```cpp
#include <bits/stdc++.h>
using namespace std;
inline long long read(){
    long long s=0,w=1;char ch=getchar();
    while(ch<'0'||ch>'9'){ if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){ s=s*10+ch-'0';ch=getchar();}
    return s*w;
}
bool vis[7120][7120];
double f[7120][7120];

inline double dp(const int n, const int m) {
    if(n<=0||m<0||n<m)
        return 0;
    double &dp1=f[n][m];
    if(vis[n][m])
        return dp1;
    vis[n][m]=1;
	dp1=-0x66ccff0712;
    dp1=max(dp1,(1+dp(n-1,m-1)-(m-1)*(1+dp(n-1,m-1))-2*(n-m)*dp(n,m+1))/(2*n-m));
	dp1=max(dp1,(2*((n-m)*(1+dp(n-1,m))-m*(m-1)/2*(2+dp(n-2,m-2))-2*m*(n-m)*(1+dp(n-1,m))-2*(n-m)*(n-m-1)*dp(n,m+2))/((2*n-m)*(2*n-m-1))));
	dp1=max(dp1,0.);
    return dp1;
}
int main() {
    int T=read();
    for(int i=1;i<=T;i++){
        int n=read(),m=read();
        printf("%.6f\n",(n+dp(n,m))/2);
    }
}
```


---


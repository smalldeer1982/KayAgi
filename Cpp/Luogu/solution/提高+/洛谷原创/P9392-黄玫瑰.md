# 黄玫瑰

## 题目描述

给定一张包含 $n$ 个点的简单有向无环图 $G$，点 $i$ 的点权设为 $w_i$，但**点权不是给定的**。

你需要构造一个包含至多 $2\times n$ 个点和恰好 $n$ 条边的有向无环图 $G'$，你需要为 $G'$ 的每条边钦定某个 $w_i$ 作为它的边权，使得 $G'$ 和 $G$ 的**最长路**长度相等。

在 $G$ 中一条路径的长度定义为其中所有点权和，$G'$ 中则为所有边权和。

然而，所有 $w_i$ 都不是给定的，所以你构造的 $G'$ 需要满足：对于任何一种可能的**正数**序列 $[w_1,\ldots,w_n]$，$G$ 和 $G'$ 的最长路长度都要相等。

请构造 $G'$，或说明它不存在。

## 说明/提示

**【样例 #1 解释】**

如下图，左为 $G$，右为 $G'$，颜色相同的点/边表示权值相同：

![](https://cdn.luogu.com.cn/upload/image_hosting/i0wuxctf.png)

注意这只是一种可能的答案，其他正确的答案也可通过。

---

**【样例 #2 解释】**

下图为 $G$，不存在合法的 $G'$：

![](https://cdn.luogu.com.cn/upload/image_hosting/tek49neu.png)

---

**【数据范围】**

对于全部数据：$1\leq n\leq 20000$，$1\leq m\leq 3\times 10^5$，$1\leq x,y\leq n$，保证给定的图无环且无重边。

|     子任务编号     | $n\leq$ |    $m\leq$     |           特殊性质            | 分值 |
| :----------------: | :-----: | :------------: | :---------------------------: | :--: |
| $\text{Subtask 1}$ | $5000$  |     $4999$     | $m=n-1$，每个点入度不超过 $1$ | $18$ |
| $\text{Subtask 2}$ | $5000$  |     $4999$     | $m=n-1$，每个点出度不超过 $1$ | $19$ |
| $\text{Subtask 3}$ |  $20$   |      $50$      |              无               | $20$ |
| $\text{Subtask 4}$ | $5000$  |    $10000$     |              无               | $21$ |
| $\text{Subtask 5}$ | $20000$ | $3\times 10^5$ |              无               | $22$ |

---

![](https://cdn.luogu.com.cn/upload/image_hosting/jepg6g1u.png)

## 样例 #1

### 输入

```
7 8
1 2
1 3
2 3
2 6
3 4
5 2
5 7
6 7
```

### 输出

```
7
1 2 1
1 2 5
2 3 2
3 4 3
3 5 6
4 6 4
5 7 7
```

## 样例 #2

### 输入

```
7 8
1 2
2 3
2 6
4 5
4 7
5 3
7 3
7 6
```

### 输出

```
-1
```

# 题解

## 作者：Cynops (赞：14)



称 $f(x)$ 为 $x$ 在 $G'$ 中对应的边。

### 引理1

对于 $G$ 中 $x \rightarrow y$ 这条边，由于边权大于 $0$，那么 $G$ 中若存在 $x \rightarrow u \rightarrow y $，$x \rightarrow y$ 就不可能成为最长路 $S$ 中的边。

### 引理2

对于 $G$ 中 $x \rightarrow u,y \rightarrow u$ ，那么在 $G'$ 中，$f(x),f(y)$ 的终点是相同的，且它们能到达的点集也相同。

#### 推论

如果存在 $x\rightarrow u,y \rightarrow u,x \rightarrow v$ 且 $y$ 不可达 $v$ 显然无解，由引理 $2$ 可证。

### 做法

由引理 1，对于这种边的寻找，我们可以先求出每个点能到达哪些点。设 $g(x)$ 表示 $x$ 能到达的点集，而显然有 $f(x) = \large{\cup_{\exists x \rightarrow y}} \small{g(y)}$，容易发现这个转移方程的递推顺序为 $G$ 的逆拓扑序。所以我们可以先求出 $G$ 的逆拓扑序，然后按照其递推。如果未更新 $x \rightarrow y$ 且 $y \in g(x)$，那么 $f(x)\rightarrow f(y)$ 无必要存在于 $G'$ 中，将其删去。这一步的复杂度为 $\Theta(m \frac{n}{w})$。

将每个点能到达的点集用并查集维护，如果出现 $|f(x)| \ne |f($可达 $f(x))|$，即出现 $x\rightarrow u,y \rightarrow u,x \rightarrow v$ 且 $y$ 不可达 $v$，那么输出 `-1`。

最终将每个点集看作一个点，枚举 `1..n` 将 $i$ 所属的点集的代表元向 $f(i)$ 所属的点集的代表元连一条以 $w_i$ 为权的边，若 $f(i)$ 为空集，将 $i$ 所属的点集的代表元向虚点连一条以 $w_i$ 为权的边。

至此，此题就完成了，复杂度为 $\Theta(m \frac{n}{w} + n + m)$。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e4 + 5;
int n, m;
int in[N];
int col[N], cnt;
int top[N], tt;
int fa[N], siz[N],vis[N];
bitset<N> g[N];
vector<int> G[N], able[N];
void init()
{
    for (int i = 1; i <= n; i++)
        fa[i] = i, siz[i] = 1;
    return;
}
int find(int x)
{
    if (fa[x] == x)
        return x;
    return fa[x] = find(fa[x]);
}
void merge(int x, int y)
{
    int fx = find(x), fy = find(y);
    if (fx != fy)
        fa[fx] = fy, siz[fy] += siz[fx];
    return;
}
void Topo_Sort()
{ // 为了求出Topo序
    queue<int> q;
    for (int i = 1; i <= n; i++)
        if (!in[i])
            q.push(i);
    while (q.size())
    {
        int u = q.front();
        q.pop();
        top[++tt] = u;
        for (auto y : G[u])
            if (--in[y] == 0)
                q.push(y);
    }
    return;
}
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        int a, b;
        cin >> a >> b;
        G[a].push_back(b);
        in[b]++;
    }
    Topo_Sort();
    init();
    for (int i = n; i; i--)
    {
        int x = top[i];
        for (int j = 0; j < G[x].size(); j++)
        {
            int y = G[x][j];
            vis[j] = g[x][y];
            g[x] |= g[y];
        }
        g[x].reset();
        g[x][x] = 1;
        for (int j = G[x].size() - 1; j >= 0; j--)
        {
            int y = G[x][j];
            vis[j] |= g[x][y];
            g[x] |= g[y];
            if (!vis[j])
                able[x].push_back(y);
        }
        for (auto y : able[x])
            merge(able[x][0], y);
    }
    for (int i = 1; i <= n; i++)
    {
        if (find(i) == i)
            col[i] = ++cnt;
        if (able[i].size() && siz[find(able[i][0])] != able[i].size())
        {
            cout << -1;
            return 0;
        }
    }
    cout << (++cnt) << '\n';
    for (int i = 1; i <= n; i++)
        if (able[i].size())
            printf("%d %d %d\n", col[find(i)], col[find(able[i][0])], i);
        else
            printf("%d %d %d\n", col[find(i)], cnt, i);
    return 0;
}
```

---

## 作者：Schi2oid (赞：5)

本题关键结论证明思路启发自：@[OIerLKL2578](https://www.luogu.com.cn/user/557754)

### 题意简述

给定一张 $n$ 个点 $m$ 条边的 DAG，点有未确定的正点权，要求构造一张新图，至多有 $2n$ 个点，恰好有 $n$ 条边，且需要为每条边对应一个原图上的点，这条边的边权与这一个点的点权相等。要求，无论原图上的点权如何赋值，原图上的路径最大权和新图上的路径最大权都应相等（原图上的路径权定义为点权和，新图上为边权和）。

### 思路分析

下文中小写字母在原图上代表点，新图上代表边，在新图上，$u_{to}$ 表示 $u$ 指向的点，$u_{from}$ 表示 $u$ 出发的点。

若 $(u,v)$ 删去后仍存在路径 $u\rightarrow v$，那么直接去掉。可以借助 bitset 优化递推出每个点可抵达的点的集合，然后再判断每一条边是否有效。

加强原题，规定原图上的路径一一对应于新图上的路径。那么如果原图上存在 $(u,v)$，那么新图上应该有 $u_{to}=v_{from}$。这是由于从 $u$ 直接走到 $v$ 的路径应同时存在于两张图上。

在这种情况下，我们将每个原图上的点拆分成入点和出点，此时图上最多有 $2n$ 个结点。我们借助并查集，将符合上述条件的入点和出点进行合并，处于相同集合的点视为同一点，就可以生成出一张暂时的新图。

但是此时生成的新图可能并不符合我们的规定。因为这样的构造方案不会漏掉路径，但是有可能增添路径。尝试分析这一构造合规的充要条件。

考虑什么情况下会有原图上并不存在的路径出现在新图中。即不存在于原图中的边 $(u,v)$ 存在于新图中，即 $u_{to}=v_{from}$。又由于 $(u,v)$ 不存在，我们并不会将其入出点直接合并，那么一定是由于存在 $(u,w),(x,v)$，此时 $S =\{u_{to},w_{from}\},T=\{x_{to},v_{from}\}$。然后又存在 $(x,w)$，那么 $S,T$ 发生合并，集合变成 $S\cup T =\{u_{to},w_{from},x_{to},v_{from}\}$。此时，$u_{to}$ 和 $v_{from}$ 同属于一个集合，故产生了原本并不存在的边。

上述不合规情况可以被概括成：$u,x$ 都存在指向 $w$ 的边，而只有 $x$ 存在指向 $v$ 的边。则构造合规的充要条件：任意两个原图上结点的出度集合要么无交，要么相等。

接下来我们论证若构造不合规，即存在 $u,x$ 都存在指向 $w$ 的边，而只有 $x$ 存在指向 $v$ 的边，则原图无解。

提出一个引理，任何一个原图中的极长路径包含的点集，一定唯一对应一个新图中的极长路径包含的边集。反之亦然。可以考虑按照 $2^i$ 赋权，在极长路径上的点赋为更高的幂次即可证得。

反证法。选取原图上包含 $(u,w)$ 但不包含 $x,v$ 的一条极长路径，再选取包含 $(x,w)$ 但不包含 $u,v$ 的一条极长路径。这是一定可以做到的，因为删去多余的边保证了 $u,x$ 之间不会存在路径相连。同理，$w,v$ 之间也一定不存在路径相连。则新图上关于这两条路径的边可以划分为这两条路径重合/不重合的部分。$w$ 一定出现在重合部分，而 $u,x,v$ 一定出现在不重合部分。则新图上存在一条同时包含 $w,v$ 的极长路径而原图中并不存在。推出矛盾，证毕。

那么，我们只需要先对合规情况进行判定，然后生成构造，最终输出答案。对所有点的出度集合进行哈希即可。总时间复杂度为 $O(\frac{nm}{w}+n+m)$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
mt19937 ra(time(0));
struct node{
	int to,ban;
};
vector<node>edge[20005];
bitset<20005>out[20005];
int topo[20005],tcnt=0;
bool vis[20005];
unsigned long long val[20005];
unsigned long long nex[20005];
void dfs(int x){
	vis[x]=1;
	for(int i=0;i<edge[x].size();i++){
		int v=edge[x][i].to;
		if(vis[v]) continue;
		dfs(v);
	}
	topo[++tcnt]=x;
}
map<unsigned long long,bool>M;
int fa[40005];
int find(int x){
	if(x==fa[x]) return x;
	fa[x]=find(fa[x]);
	return fa[x];
}
signed main(){
	int n,m,u,v;
	cin>>n>>m;
	for(int i=1;i<=n;i++) val[i]=ra();
	for(int i=1;i<=m;i++){
		scanf("%lld%lld",&u,&v);
		edge[u].push_back((node){v,0});
	}
	for(int i=1;i<=n;i++) if(!vis[i]) dfs(i);
	for(int i=1;i<=n;i++) out[i][i]=1;
	for(int p=1;p<=n;p++){
		int i=topo[p];
		for(int j=0;j<edge[i].size();j++){
			int v=edge[i][j].to;
			for(int k=0;k<edge[i].size();k++){
				if(k==j||edge[i][k].ban) continue;
				int vv=edge[i][k].to;
				if(out[vv][v]){
					edge[i][j].ban=1;
					break;
				}
			}
			if(edge[i][j].ban==1) continue;
			out[i]|=out[v];
		}
		for(int j=0;j<edge[i].size();j++){
			int v=edge[i][j].to;
			if(!edge[i][j].ban) nex[i]+=val[v];
		}
	}
	memset(vis,0,sizeof vis);
	for(int i=1;i<=n;i++){
		if(M[nex[i]]) continue;
		M[nex[i]]=1;
		for(int j=0;j<edge[i].size();j++){
			if(edge[i][j].ban) continue;
			int v=edge[i][j].to;
			if(vis[v]){
				puts("-1");
				return 0;
			}
			vis[v]=1;
		}
	}
	for(int i=1;i<=2*n;i++) fa[i]=i;
	for(int i=1;i<=n;i++){
		for(int j=0;j<edge[i].size();j++){
			int v=edge[i][j].to;
			if(edge[i][j].ban) continue;
			fa[find(i+n)]=find(v);
		}
	}
	printf("%lld\n",2*n);
	for(int i=1;i<=n;i++) printf("%lld %lld %lld\n",find(i),find(i+n),i);
	return 0;
}
```

---


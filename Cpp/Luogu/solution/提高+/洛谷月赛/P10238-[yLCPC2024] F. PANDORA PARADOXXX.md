# [yLCPC2024] F. PANDORA PARADOXXX

## 题目背景

扶苏所在的城市的机厅联合举办了 KING of PerforPandora！

但是因为大雪封路，有些机厅不能到达。她想知道在能互相到达的机厅中距离最远为多少。

## 题目描述

给定一棵 $n$ 个结点的树。一棵树被定义为一个有 $n$ 个点和 $n-1$ 条边的无向连通图。这棵树的边有边权。两点 $u,v$ 间的距离 $\mathrm{dist}(u,v)$ 定义为从 $u$ 到 $v$ 的简单路径边权和。可以证明树上两点间的简单路径是唯一的。特别的，我们规定 $\mathrm{dist}(u, u) = 0$。

现在有 $q$ 次操作，每次会删除这棵树上的一条边。显然在做出至少一次操作后，这棵树会被分成若干个连通块。你需要在每次操作后都求出每个连通块内距离最远的两个点的距离的最大值。

形式化的，每次操作后，你要求出

$$\max\limits_{c \in C}\{\max\limits_{u, v \in c} \mathrm{dist}(u,v)\}$$

其中 $C$ 表示当前所有连通块构成的集合。

## 说明/提示

#### 提示

请注意大量的数据读入和输出对程序效率造成的影响，选择合适的读入输出方式，不要频繁刷新输出缓冲区，避免超时。

## 样例 #1

### 输入

```
2
4 2
1 2 1
2 3 2
3 4 3
2
3
12 2
1 2 1
2 3 1
1 4 3
2 5 4
5 6 3
5 7 2
7 8 1
8 9 1
9 10 1
7 11 5
8 12 3
4
6```

### 输出

```
3
1
10
9```

# 题解

## 作者：ran_qwq (赞：9)

删边过程十分地不好搞，考虑先加没被删过的边，再从后往前将删过的边一条一条加回去，在加边的过程中动态维护答案。每次加边合并两棵树 $s$ 和 $t$。在合并的过程中，树 $s$ 内任意一点 $u$ 和树 $t$ 内任意一点 $v$ 会连通，答案会和 $dis(u,v)$ 取 max。但是，直接暴力更新单次就是 $O(n^2)$ 的，时间复杂度无法承受。

我们容易发现，有很多点对 $(u,v)$ 都不会对答案产生贡献。具体地，设树 $s$ 的一条直径为 $x$ 到 $y$ 的路径，树 $t$ 的一条直径为 $p$ 到 $q$ 的路径，则合并后的树的直径的端点肯定是 $x,y,p,q$ 四点之二。

证明（好像其他题解都没说明白）：

> 引理：到任意点距离最远的点必是树的一条直径的端点。
>
> 证明：
>
> > 设一棵树根为 $r$，直径为 $x$ 到 $y$ 的路径，距离 $r$ 最远的一个节点是 $z$，$x$ 到 $y$ 的 LCA 为 $l$。不妨设 $dis(r,x)\le dis(r,y)$。反证法，如果 $dis(r,y)<dis(r,z)$：
> >
> > 则 $dis(l,y)\le dis(r,y)<dis(r,z)$，将直径中的 $y$ 换成 $z$ 一定更优，$x$ 到 $y$ 的路径不是直径，矛盾，原命题成立。
>
> - 如果合并后树的直径在树 $s$ 内，则一定是 $x$ 到 $y$ 的路径。
> - 如果合并后树的直径在树 $t$ 内，则一定是 $p$ 到 $q$ 的路径。
> - 否则直径经过连接树 $s$ 和树 $t$ 的边，由引理，新树直径端点必为 $x,y,p,q$ 四点之二。
>
> 综上，证毕。

用并查集合并，求距离可以用 LCA+树上差分。

---

## 作者：harmis_yz (赞：6)

## 分析

考虑时光倒流。

对于需要合并的两个连通块 $x,y$，其合并之后的最远点对距离一定是合并之前的两个连通块的最远点对中产生的。在合并的时候枚举最远点对，取距离最大值即可。由于我们是倒着来的，所有连通块的最远点对距离最大值不减，所以能直接在合并之后取最大值。

维护连通块用并查集即可。复杂度 $O(n\log n)$。

对于两个连通块合并之后最远点对必在两个连通块最远点对中出现的证明：

> 设两个连通块通过边 $(x,y)$ 连通，两个连通块内最远点对分别为 $(a,b),(c,d)$。若最远点对不经过边 $(x,y)$，则一定是两个连通块中最远点对距离较大的一组。若最远点对经过 $(x,y)$，由于与 $x$ 距离最远的点为 $a,b$ 中的一个，与 $y$ 距离最远的点为 $c,d$ 中的一个。所以最远点对存在于 $\{a,b,c,d\}$ 中。


## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define re register
#define il inline
#define pii pair<int,int>
#define x first
#define y second
#define gc getchar()
#define rd read()
#define debug() puts("------------")

namespace yzqwq{
	il int read(){
		int x=0,f=1;char ch=gc;
		while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=gc;}
		while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=gc;
		return x*f;
	}
	il int qmi(int a,int b,int p){
		int ans=1;
		while(b){
			if(b&1) ans=ans*a%p;
			a=a*a%p,b>>=1;
		}
		return ans;
	}
	il auto max(auto a,auto b){return (a>b?a:b);}
	il auto min(auto a,auto b){return (a<b?a:b);}
	il int gcd(int a,int b){
		if(!b) return a;
		return gcd(b,a%b);
	}
	il int lcm(int a,int b){
		return a/gcd(a,b)*b;
	}
	il void exgcd(int a,int b,int &x,int &y){
		if(!b) return x=1,y=0,void(0);
		exgcd(b,a%b,x,y);
		int t=x;
		x=y,y=t-a/b*x;
		return ;
	}
	mt19937 rnd(time(0));
}
using namespace yzqwq;

const int N=5e5+10;
int n,m;
int ne[N<<1],e[N<<1],w[N<<1],h[N],idx;
int fa[N],siz[N],s[N][2];
struct edge{
	int x,y,z;
}E[N];
int d[N],vis[N];
int dep[N],dis[N];
int f[N][25];
int Mx[N];
int ans[N],nowmx;

il void add(int a,int b,int c){
	ne[++idx]=h[a],e[idx]=b,w[idx]=c,h[a]=idx;
}
il void dfs(int now,int fa){
	dep[now]=dep[fa]+1,f[now][0]=fa;
	for(re int i=1;i<24;++i) f[now][i]=f[f[now][i-1]][i-1];
	for(re int i=h[now];i;i=ne[i]){
		int j=e[i];if(j==fa) continue;
		dis[j]=dis[now]+w[i];
		dfs(j,now);
	}
	return ;
}
il int lca(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	for(re int i=23;i>=0;--i) if(dep[f[x][i]]>=dep[y]) x=f[x][i];
	if(x==y) return x;
	for(re int i=23;i>=0;--i) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}
il int diss(int a,int b){
	return dis[a]+dis[b]-2*dis[lca(a,b)];
}
il int find(int x){
	return fa[x]==x?x:fa[x]=find(fa[x]);
}
il void merge(int x,int y){
	fa[y]=x;
	int mx=0;
	int now[10]={s[x][0],s[x][1],s[y][0],s[y][1]};
	for(re int i=0;i<4;++i)
	for(re int j=0;j<4;++j){
		int nowx=now[i],nowy=now[j];
		int Dis=diss(nowx,nowy);
		if(Dis>mx){
			mx=Dis,s[x][0]=nowx,s[x][1]=nowy;
			Mx[x]=Dis;
		}
	}
	nowmx=max(nowmx,Mx[x]);
	return ;
}

il void solve(){
	n=rd,m=rd,idx=0,nowmx=0;
	for(re int i=1;i<=n;++i){
		fa[i]=i,siz[i]=s[i][0]=s[i][1]=0;
		s[i][0]=s[i][1]=i;
		h[i]=dep[i]=dis[i]=0;
		ans[i]=0,Mx[i]=0;
		for(re int j=0;j<=24;++j) f[i][j]=0;
		vis[i]=0;
	}
	for(re int i=1;i<n;++i){
		int a=rd,b=rd,c=rd;
		add(a,b,c),add(b,a,c);
		E[i]={a,b,c};
	}
	dfs(1,0);
	for(re int i=1;i<=m;++i)
		d[i]=rd,vis[d[i]]=1;
	for(re int i=1;i<n;++i){
		if(vis[i]) continue;
		int x=E[i].x,y=E[i].y;
		if(dep[x]>dep[y]) swap(x,y);
		merge(find(x),find(y));
	}
	for(re int i=m;i>=1;--i){
		int x=E[d[i]].x,y=E[d[i]].y;
		if(dep[x]>dep[y]) swap(x,y);
		ans[i]=nowmx;
		merge(find(x),find(y));
	}
	for(re int i=1;i<=m;++i) cout<<ans[i]<<"\n";
	return ;
}

signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	int t=rd;while(t--)
	solve();
	return 0;
}
```

---

## 作者：251Sec (赞：5)

把操作倒序，删边变成加边。加边的时候进行启发式合并，暴力 DFS 较小的连通块，这样就可以计算两点的距离等信息。每个连通块维护直径的两个端点，根据经典结论，合并两个连通块之后得到的新连通块的直径一定是这两个连通块的四个直径端点中选两个点，直接枚举选哪两个即可。

但是我启发式合并的目的是算两个点的距离但是一开始我就有树的形态所以为啥我要启发式合并呢可能是因为我脑子有点大病吧。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int T, n, q;
struct Edge {
	int to, next;
	ll w;
} e[200005];
int head[100005], len;
void Insert(int u, int v, ll w) {
	e[++len] = { v, head[u], w };
	head[u] = len;
}
struct EData {
	int u, v;
	ll w;
} et[100005], ed[100005];
bool del[100005];
ll ans;
int bel[100005], siz[100005], prt[100005][20], dep[100005];
ll dis[100005];
int LCA(int u, int v) {
	if (dep[u] > dep[v]) swap(u, v);
	int d = dep[v] - dep[u];
	for (int i = 0; i < 20; i++) if (d >> i & 1) v = prt[v][i];
	if (u == v) return u;
	for (int i = 19; ~i; i--) {
		if (prt[u][i] != prt[v][i]) {
			u = prt[u][i], v = prt[v][i];
		}
	}
	return prt[u][0];
}
ll Dis(int u, int v) { return dis[u] + dis[v] - 2 * dis[LCA(u, v)]; }
struct Diam {
	int u, v;
	Diam operator+(const Diam &b) const {
		int ru = u, rv = v;
		if (Dis(u, b.u) > Dis(ru, rv)) ru = u, rv = b.u;
		if (Dis(v, b.v) > Dis(ru, rv)) ru = v, rv = b.v;
		if (Dis(b.u, b.v) > Dis(ru, rv)) ru = b.u, rv = b.v;
		if (Dis(u, b.v) > Dis(ru, rv)) ru = u, rv = b.v;
		if (Dis(v, b.u) > Dis(ru, rv)) ru = v, rv = b.u;
		return { ru, rv };
	}
} dia[100005];
void DFS(int u, int fa, int b) {
	bel[u] = b, prt[u][0] = fa, dep[u] = dep[fa] + 1;
	for (int i = 1; i < 20; i++) prt[u][i] = prt[prt[u][i - 1]][i - 1];
	for (int i = head[u]; i; i = e[i].next) {
		int v = e[i].to;
		if (v == fa) continue;
		dis[v] = dis[u] + e[i].w;
		DFS(v, u, b);
	}
}
void Ins(int u, int v, ll w) {
	if (siz[bel[u]] < siz[bel[v]]) swap(u, v);
	auto x = dia[bel[u]], y = dia[bel[v]];
	siz[bel[u]] += siz[bel[v]];
	Insert(u, v, w), Insert(v, u, w);
	dis[v] = dis[u] + w, DFS(v, u, bel[u]);
	dia[bel[u]] = x + y;
	ans = max(ans, Dis(dia[bel[u]].u, dia[bel[u]].v));
}
ll tAns[100005];
int main() {
	scanf("%d", &T);
	while (T--) {
		scanf("%d%d", &n, &q);
		for (int i = 1; i < n; i++) scanf("%d%d%lld", &et[i].u, &et[i].v, &et[i].w);
		for (int i = 1; i <= q; i++) {
			int x; scanf("%d", &x);
			ed[i] = et[x];
			del[x] = true;
		}
		for (int i = 1; i <= n; i++) {
			bel[i] = i, siz[i] = 1, dep[i] = 0;
			for (int j = 0; j < 20; j++) prt[i][j] = 0;
			dis[i] = 0, dia[i] = { i, i };
		}
		ans = 0;
		for (int i = 1; i < n; i++) {
			if (!del[i]) {
				Ins(et[i].u, et[i].v, et[i].w);
			}
		}
		for (int i = q; i; i--) {
			tAns[i] = ans;
			Ins(ed[i].u, ed[i].v, ed[i].w);
		}
		for (int i = 1; i <= q; i++) printf("%lld\n", tAns[i]);
		for (int i = 1; i <= n; i++) head[i] = 0, del[i] = false;
		len = 0;
	}
	return 0;
}
```

---

## 作者：BitByBit (赞：4)

# 题意
给定一颗树，每次删除一条边然后求树的直径。
# 分析
**正难则反**。删边太难弄，改成反过来加边。这样就问题变成知道两棵树的直径，把他们合并后快速求出新的树的直径。不难看出新的树的直径的两端肯定是原来两颗树的直径的四个端点中的两个。那只要用并查集维护并记录每棵树直径的两端然后用树剖 lca 求树上两点距离。
# code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define N 300010
int dfn;
basic_string<pair<int,int>>G[N];//玄学basic string存图
int Fa[N],Dep[N],Size[N],hSon[N],Dfn[N],Rank[N],Top[N];
ll Dis[N];
bool Vis[N];
struct E
{
	int x,y,z;
};
E Edge[N];
int Del[N],P[N],Q[N],F[N];
ll Ans[N];
int find(int x)//并查集维护森林
{
	return F[x]==x?x:F[x]=find(F[x]);
}
void merge(int x,int y)
{
	x=find(x);y=find(y);
	if(x!=y)F[x]=y;
}
void dfs1(int x,int f)//树剖求lca然后求距离
{
	Fa[x]=f;
	Dep[x]=Dep[f]+1;
	Size[x]=1;
	hSon[x]=-1;
	for(auto[y,z]:G[x])
	{
		if(y==f)continue;
		Dis[y]=Dis[x]+z;
		dfs1(y,x);
		Size[x]+=Size[y];
		if(hSon[x]==-1||Size[y]>Size[hSon[x]])
			hSon[x]=y;
	}
}
void dfs2(int x,int f)
{
	Dfn[x]=++dfn;
	Rank[dfn]=x;
	Top[x]=f;
	if(hSon[x]==-1)return;
	dfs2(hSon[x],f);
	for(auto[y,z]:G[x])
	{
		if(y==Fa[x]||y==hSon[x])continue;
		dfs2(y,y);
	}
}
int lca(int x,int y)
{
	while(Top[x]!=Top[y])
	{
		if(Dep[Top[x]]<Dep[Top[y]])swap(x,y);
		x=Fa[Top[x]];
	}
	if(Dep[x]>Dep[y])swap(x,y);
	return x;
}
ll dis(int x,int y)
{
	return Dis[x]+Dis[y]-(Dis[lca(x,y)]<<1);
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int t;
	cin>>t;
	while(t--)
	{
		int n,m;
		cin>>n>>m;
		for(int i=1;i<=n;i++)
			G[i].clear();//记得多测清空
		for(int i=1;i<=n-1;i++)
		{
			int x,y,z;
			cin>>x>>y>>z;
			G[x].push_back({y,z});
			G[y].push_back({x,z});
			Edge[i]={x,y,z};
		}
		Dis[1]=0;
		dfs1(1,0);//树剖
		dfs2(1,1);
		memset(Vis,0,sizeof(Vis));
		for(int i=1;i<=m;i++)
		{
			cin>>Del[i];
			Vis[Del[i]]=1;
		}
		for(int i=1;i<=n;i++)
			P[i]=Q[i]=F[i]=i;//p,q表示直径两端，f表示树根
		Ans[m+1]=0;
		for(int i=1;i<=n-1;i++)
			if(!Vis[i])
			{
				int x=find(Edge[i].x),y=find(Edge[i].y);
				ll a=P[x],b=Q[x],c=P[y],d=Q[y];
				ll o=dis(a,b),p=dis(a,c),q=dis(a,d),r=dis(b,c),s=dis(b,d),t=dis(c,d);
				ll z=max(o,max(p,max(q,max(r,max(s,t)))));
				if(x!=y)F[x]=y;
				if(z==o)P[y]=a,Q[y]=b;
				else if(z==p)P[y]=a,Q[y]=c;
				else if(z==q)P[y]=a,Q[y]=d;
				else if(z==r)P[y]=b,Q[y]=c;
				else if(z==s)P[y]=b,Q[y]=d;
				else P[y]=c,Q[y]=d;
				Ans[m+1]=max(Ans[m+1],z);
			}//先把没删除的给合并了
		for(int i=m;i>=1;i--)
		{
			int x=find(Edge[Del[i]].x),y=find(Edge[Del[i]].y);
			ll a=P[x],b=Q[x],c=P[y],d=Q[y];
			ll o=dis(a,b),p=dis(a,c),q=dis(a,d),r=dis(b,c),s=dis(b,d),t=dis(c,d);
			ll z=max(o,max(p,max(q,max(r,max(s,t)))));
			if(x!=y)F[x]=y;
			if(z==o)P[y]=a,Q[y]=b;
			else if(z==p)P[y]=a,Q[y]=c;
			else if(z==q)P[y]=a,Q[y]=d;
			else if(z==r)P[y]=b,Q[y]=c;
			else if(z==s)P[y]=b,Q[y]=d;
			else P[y]=c,Q[y]=d;
			Ans[i]=max(Ans[i+1],z);
		}//倒着合并树
		for(int i=2;i<=m+1;i++)
			cout<<Ans[i]<<'\n';//倒着输出
	}
	return 0;
}

```

---

## 作者：fish_love_cat (赞：3)

巨大[细节](https://www.luogu.com.cn/discuss/1118423)题！

---

考虑倒着做变成加边，有经典结论：

> 合并后新树的任意直径端点，必然是合并前某棵树中某条直径的端点。

:::::info[证明]

合并一定会增加一条边 $(u,v)$。

如果新的直径不过这条边，那么直径仍然是某棵树原本的直径，原命题必然成立。

如果经过这条边，那么就变成要证明在 $u$ 原本所在的树中离它最远的点是该树某条直径的端点，$v$ 同理。

于是就变成了证明这么一个命题：

> 到任意点距离最远的点必是树的一条直径的端点。

这个结论是广为人知的，最常见的应用就是求树的直径，所以证明略去。

所以原命题成立。

:::::

于是就好做了：

先搜一遍把每个点的深度求出来，然后求距离可以转变成求 LCA，这个是板子不说了。

接着并查集维护连通。

对于每个连通块先求直径，并记录端点。

根据结论合并的时候只有四个可能的端点，组合一下总共有六种情况，分讨就做完了，模拟上述过程即可。

除了容易写挂以外没有任何难度，鉴定为大模拟。

坑点见前言。

---

[AC 记录](https://www.luogu.com.cn/record/227684492)及代码：

```cpp
// 途切れていた止まっていた日々が
// 戛然而止 停滞不前的时光

// 輝くよな想い出に
// 化身流光溢彩的回忆

// 埋められていくの
// 被时间沙漏不断埋藏
#include<bits/stdc++.h>
#define int long long
#define mk make_pair
#define pb push_back
using namespace std;
int fa[100005];
int find(int x){
    return(x==fa[x]?x:fa[x]=find(fa[x]));
}
vector<pair<int,pair<int,int> > >ve[100005];
int mi[25][100005],dfn[100005],dfnn;
int get(int u,int v){
    if(dfn[u]<dfn[v])return u;
    else return v;
}
void dfs(int id,int f){
    mi[0][dfn[id]=++dfnn]=f;
    for(pair<int,pair<int,int> > it:ve[id])
    if(it.first!=f)dfs(it.first,id); 
}
int lca(int u,int v){
    if(u==v)return u;
    if((u=dfn[u])>(v=dfn[v])) swap(u, v);
    int d=__lg(v-u++);
    return get(mi[d][u],mi[d][v-(1<<d)+1]);
}
int q[100005];
bool use[100005];
bool vis[100005];
int dep,depid;
pair<int,int>zj[100005];
int ret;
int dis[100005];
void dfs1(int x,int fa){
    for(int i=0;i<ve[x].size();i++){
        if(ve[x][i].first==fa)continue;
        dis[ve[x][i].first]=dis[x]+ve[x][i].second.first;
        dfs1(ve[x][i].first,x);
    }
}
void dfs2(int x,int fath,int dp,bool op){
    vis[x]=op;
    if(dp>dep)dep=dp,depid=x;
    for(int i=0;i<ve[x].size();i++){
        if(vis[ve[x][i].first])continue;
        if(use[ve[x][i].second.second])continue;
        if(ve[x][i].first==fath)continue;
        if(fa[find(ve[x][i].first)]!=find(x))
            fa[find(ve[x][i].first)]=find(x);
        dfs2(ve[x][i].first,x,dp+ve[x][i].second.first,op);
    }
}
int jl(int x,int y){
    return dis[x]+dis[y]-2*dis[lca(x,y)];
}
vector<pair<int,int> >qwq;
void init(int n);
void solve(){
    int n,Q;
    cin>>n>>Q;
    init(n);
    for(int i=1;i<n;i++){
        int u,v,w;
        cin>>u>>v>>w;
        ve[u].pb(mk(v,mk(w,i)));
        ve[v].pb(mk(u,mk(w,i)));
        qwq.push_back(mk(u,v));
    }
    dfs1(1,0);
    dfs(1,0);
    for(int i=1;i<=__lg(n);i++)
    for(int j=1;j<=n-(1<<i)+1;j++)
    mi[i][j]=get(mi[i-1][j],mi[i-1][j+(1<<(i-1))]);
    for(int i=1;i<=Q;i++)
        cin>>q[i],use[q[i]]=1;
    reverse(q+1,q+1+Q);
    for(int i=1;i<=n;i++){
        if(vis[i])continue;
        dep=-1;
        dfs2(i,0,0,0);
        dep=-1;
        zj[find(i)].first=depid;
        dfs2(depid,0,0,1);
        zj[find(i)].second=depid;
        ret=max(ret,dep);
    }
    vector<int>out;
    for(int i=1;i<=Q;i++){
        out.push_back(ret);
        if(i==Q)break;
        int x1=jl(zj[find(qwq[q[i]].first)].first,
                 zj[find(qwq[q[i]].second)].first);
        int x2=jl(zj[find(qwq[q[i]].first)].first,
                 zj[find(qwq[q[i]].second)].second);
        int x3=jl(zj[find(qwq[q[i]].first)].second,
                 zj[find(qwq[q[i]].second)].first);
        int x4=jl(zj[find(qwq[q[i]].first)].second,
                 zj[find(qwq[q[i]].second)].second);
        int x5=jl(zj[find(qwq[q[i]].first)].first,
                 zj[find(qwq[q[i]].first)].second);
        int x6=jl(zj[find(qwq[q[i]].second)].first,
                 zj[find(qwq[q[i]].second)].second);
        int maxx=max({x1,x2,x3,x4,x5,x6});
        if(maxx==x1)
            zj[find(qwq[q[i]].second)]=mk(zj[find(qwq[q[i]].first)].first,
                                     zj[find(qwq[q[i]].second)].first);
        else if(maxx==x2)
            zj[find(qwq[q[i]].second)]=mk(zj[find(qwq[q[i]].first)].first,
                                     zj[find(qwq[q[i]].second)].second);
        else if(maxx==x3)
            zj[find(qwq[q[i]].second)]=mk(zj[find(qwq[q[i]].first)].second,
                                     zj[find(qwq[q[i]].second)].first);
        else if(maxx==x4)
            zj[find(qwq[q[i]].second)]=mk(zj[find(qwq[q[i]].first)].second,
                                     zj[find(qwq[q[i]].second)].second);
        else if(maxx==x5)
            zj[find(qwq[q[i]].second)]=mk(zj[find(qwq[q[i]].first)].first,
                                     zj[find(qwq[q[i]].first)].second);
        else if(maxx==x6)
            zj[find(qwq[q[i]].second)]=mk(zj[find(qwq[q[i]].second)].first,
                                     zj[find(qwq[q[i]].second)].second);
        fa[find(qwq[q[i]].first)]=find(qwq[q[i]].second);
        ret=max(ret,maxx);
    }
    reverse(out.begin(),out.end());
    for(int i=0;i<out.size();i++)
        cout<<out[i]<<'\n';
}
signed main(){
    int t;
    cin>>t;
    while(t--)solve();
    return 0;
}
void init(int n){
    qwq.clear();
    ret=0;
    for(int i=1;i<=n;i++){
        zj[i]=mk(0,0);
        dis[i]=0;
        fa[i]=i;
        for(int j=0;j<25;j++)
            mi[j][i]=0;
        q[i]=use[i]=vis[i]=dfn[i]=0;
        ve[i].clear();
    }
    dep=-1;
    depid=dfnn=0;
    qwq.push_back(mk(0,0));
}
// 忘れないよ覚えてるよこの瞬間を
// 那难以忘怀的瞬间我时刻谨记在心

// 終わりに残す言葉は
// 尘埃落定时相互嘱咐的话语

// 「また会おうね」ふたりの約束
// 竟是「有缘再见」两人的约定

// Last Diary
```

---

## 作者：hzoi_Shadow (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P10238)

# 前置知识

[树链剖分](https://oi-wiki.org/graph/hld/) | [树的直径](https://oi-wiki.org/graph/tree-diameter/) | [最近公共祖先](https://oi-wiki.org/graph/lca/) | [并查集](https://oi-wiki.org/ds/dsu/)

# 解法

正着删边不太可做，考虑离线下来反着加边。

一个显而易见的结论：设点集 $A$ 的直径的两个端点为 $u_{1},v_{1}$，另一个点集 $B$ 的直径的两个端点为 $u_{2},v_{2}$，则 $A \bigcup B$ 的直径端点一定是 $\{ u_{1},v_{1},u_{2},v_{2} \}$ 中的两个。

并查集维护连通块内直径的两个端点即可。

手动实现下清空来保证复杂度正确。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
ll siz[200010],fa[200010],dep[200010],dis[200010],son[200010],top[200010],u[200010],v[200010],x[200010],vis[200010],ans[200010],tot=0,sum=0;
vector<pair<ll,ll> >e[200010];
void add(ll u,ll v,ll w)
{
	e[u].push_back(make_pair(v,w));
}
void dfs1(ll x,ll father,ll w)
{
	siz[x]=1;
	fa[x]=father;
	dep[x]=dep[father]+1;
	dis[x]=dis[father]+w;
	for(ll i=0;i<e[x].size();i++)
	{
		if(e[x][i].first!=father)
		{
			dfs1(e[x][i].first,x,e[x][i].second);
			siz[x]+=siz[e[x][i].first];
			son[x]=(siz[e[x][i].first]>siz[son[x]])?e[x][i].first:son[x];
		}
	}
}
void dfs2(ll x,ll id)
{
	top[x]=id;
	if(son[x]!=0)
	{
		dfs2(son[x],id);
		for(ll i=0;i<e[x].size();i++)
		{
			if(e[x][i].first!=son[x]&&e[x][i].first!=fa[x])
			{
				dfs2(e[x][i].first,e[x][i].first);
			}
		}
	}
}
ll lca(ll u,ll v)
{
	while(top[u]!=top[v])	
	{
		if(dep[top[u]]>dep[top[v]])
		{
			u=fa[top[u]];
		}
		else
		{
			v=fa[top[v]];
		}
	}
	return (dep[u]<dep[v])?u:v;
}
ll ask_dis(ll x,ll y)
{
	return dis[x]+dis[y]-2*dis[lca(x,y)];
}
struct DSU
{
	ll fa[200010],pt[200010][2],tmp[5];
	void init(ll n)
	{
		for(ll i=1;i<=n;i++)
		{
			fa[i]=i;
			pt[i][0]=pt[i][1]=i;
		}
	}
	ll find(ll x)
	{
		return fa[x]==x?x:fa[x]=find(fa[x]);
	}
	void merge(ll x,ll y)
	{
		if(dep[x]>dep[y])
		{
			swap(x,y);
		}
		x=find(x);
		y=find(y);
		fa[y]=x;
		ll maxx=0;
		tmp[1]=pt[x][0];
		tmp[2]=pt[x][1];
		tmp[3]=pt[y][0];
		tmp[4]=pt[y][1];
		for(ll i=1;i<=4;i++)
		{
			for(ll j=i+1;j<=4;j++)
			{
				if(ask_dis(tmp[i],tmp[j])>maxx)
				{
					maxx=ask_dis(tmp[i],tmp[j]);
					pt[x][0]=tmp[i];
					pt[x][1]=tmp[j];
				}
			}
		}
		sum=max(sum,maxx);
	}
}D;
int main()
{
	ll t,n,q,w,i,j;
	scanf("%lld",&t);
	for(j=1;j<=t;j++)
	{
		scanf("%lld%lld",&n,&q);
		D.init(n);
		tot=sum=0;
		for(i=1;i<=n;i++)
		{
			e[i].clear();
			son[i]=vis[i]=0;
		}
		for(i=1;i<=n-1;i++)
		{
			scanf("%lld%lld%lld",&u[i],&v[i],&w);
			add(u[i],v[i],w);
			add(v[i],u[i],w);
		}
		dfs1(1,0,0);
		dfs2(1,1);
		for(i=1;i<=q;i++)
		{
			scanf("%lld",&x[i]);
			vis[x[i]]=1;
		}
		for(i=1;i<=n-1;i++)
		{
			if(vis[i]==0)
			{	
				D.merge(u[i],v[i]);
			}
		}
		for(i=q;i>=1;i--)
		{
			ans[i]=sum;
			D.merge(u[x[i]],v[x[i]]);	
		}
		for(i=1;i<=q;i++)
		{
			printf("%lld\n",ans[i]);
		}
	}
	return 0;
}
```

---

## 作者：I_AM_CIMOTA (赞：3)

看到 [削除](https://baike.baidu.com/item/Sakuzyo/19882268#:~:text=Sakuzyo%EF%BC%88%E5%89%8A%E9%99%A4%EF%BC%89%EF%BC%8C%20%E4%BD%9C%E6%9B%B2%E5%AE%B6%20%EF%BC%8C%E5%AE%A2%E4%B8%B2%E6%80%A7Breakbeats%E5%88%B6%E4%BD%9C%E4%BA%BA%EF%BC%8C%E4%B8%BADIVERSE%20SYSTEM%E5%89%AF%E4%B8%BB%E5%94%B1%20%E3%80%82%20%E6%9B%BE%E4%B8%BA%E3%80%8ACytus%E3%80%8B%E3%80%81%E3%80%8ADeemo%E3%80%8B%E3%80%81%E3%80%8AVOEZ%E3%80%8B%E3%80%81%E3%80%8AZion%E8%BD%BD%E9%9F%B3%E3%80%8B%E3%80%81%E3%80%8A%20Sound,Voltex%20%E3%80%8B%E3%80%81%E3%80%8AMaimai%E3%80%8B%E3%80%81%E3%80%8ACHUNITHM%E3%80%8B%E3%80%81%E3%80%8ACrossbeats%20REV.%E3%80%8B%E7%AD%89%E5%A4%9A%E9%83%A8%E6%B8%B8%E6%88%8F%E4%BE%9B%E6%9B%B2%E3%80%82%20%E5%8F%A6%E6%9C%89%E9%A9%AC%E7%94%B2%EF%BC%9AIS%20Kingdom%E3%80%81Sephar%20Kyne%20) 的 [PANDORA PARADOXXX](https://music.163.com/#/song?id=1459037632) 就点进来了。

大家都用树上差分，可是我做这道题的时候第一时间想到的是 $LCT$ 维护加边树上直径。

删边不好操作，那么我们就把删边操作改为加边操作。不难发现需要求的其实是动态加边的森林的最长直径长度。

如果有两棵树 $T_1$ 和 $T_2$，现在用一条边把两棵树合并成一棵新树，那么新树的直径的端点一定可以是原来两棵树的四个端点中的某两个。证明如下：

> 我们都知道一棵树中距离某个点最远的点一定是直径的端点，那么假设新树的直径不经过新加的这条边，新树的直径一定是原来的两个直径之一，否则假设新加的边是 $(u,v)$ ，新树直径的两个端点必定分别是在原来两棵树中距离 $u$ 和 $v$ 最远的点。所以新树的两个直径端点一定是原来两棵树的四个端点之二。

现在就可以考虑加边操作了。求出合并出的新树的直径，可以直接枚举两棵原来的树的直径端点，一共 $C_4^2=6$ 种可能的方案。对于每种方案求出两个点之间的距离，取最大值即可。这部分我是直接用的 $LCT$ 维护两点之间的距离（可能比较蠢但是我确实没有想到树上差分）。

对于求解动态森林中最长的一条直径，用一个堆即可维护。在合并两棵树时删掉原来的两条直径，再加入新树的直径就行了。

这是长度仅有4K的AC代码：
```cpp
#include <bits/stdc++.h>
#define int long long
#define PII pair<int,int>
using namespace std;

const int N=6e5+5;
struct Edge{
    int u,v,w;
}edge[N];
struct Node{
    int v,id;
    bool operator <(const Node& a)const{return v<a.v;}
};
int T,n,q,ptot,mxdep,mxp,heaptot,qu[N],FA[N],ans[N],to[N];
int fa[N],tr[N][2],st[N],s[N],siz[N],val[N],rtag[N];
PII point[N];
bool vis[N],del[N],deledge[N];
priority_queue<Node>heap;
vector<Edge>g[N];

bool notroot(int u){return tr[fa[u]][0]==u||tr[fa[u]][1]==u;}

void up(int u){s[u]=s[tr[u][0]]+s[tr[u][1]]+val[u];siz[u]=siz[tr[u][0]]+siz[tr[u][1]]+1;}

void rev(int u){swap(tr[u][0],tr[u][1]),rtag[u]^= 1;}

void down(int u){
	if(rtag[u]){
		if(tr[u][0])rev(tr[u][0]);
		if(tr[u][1])rev(tr[u][1]);
		rtag[u]=0;
	}
}

void rot(int x){
	int y=fa[x],z=fa[y],k=(x==tr[y][1]),p=tr[x][k^1];
	if(notroot(y))tr[z][tr[z][1]==y]=x;
	tr[x][k^1]=y,tr[y][k]=p;
	if(p)fa[p]=y;
	fa[y]=x,fa[x]=z;
	up(y);
}

void splay(int x){
	int y=x,tot=0;
	st[++tot]=y;
	while(notroot(y))st[++tot]=y=fa[y];
	while(tot)down(st[tot--]);
	while(notroot(x)){
		y=fa[x];
		int z=fa[y];
		if(notroot(y))rot((tr[y][0]==x)^(tr[z][0]==y)?x:y);
		rot(x);
	}
	up(x);
}

void access(int u){
	int p=0;
	for(int x=u;x;x=fa[p=x])splay(x),tr[x][1]=p,up(x);
}

void mkrt(int u){access(u),splay(u),rev(u);}

void split(int u,int v){mkrt(u),access(v),splay(v);}

void link(int u,int v){mkrt(u),fa[u]=v;}

void cut(int u,int v){split(u,v),tr[v][0]=fa[u]=0;}

int find(int u){return u==FA[u]?u:FA[u]=find(FA[u]);}

int dis(int u,int v){
    split(u,v);
    return s[v];
}

void dfs(int u,int fth,int dep){
    vis[u]=1;
    if(dep>mxdep)mxdep=dep,mxp=u;
    for(Edge i:g[u]){
        int v=i.v,w=i.w;
        if(v!=fth)dfs(v,u,dep+w);
    }
}

void clear(){
    for(int i=1;i<=ptot;i++){
        fa[i]=tr[i][0]=tr[i][1]=rtag[i]=siz[i]=val[i]=FA[i]=s[i]=to[i]=0;
        point[i]={0,0};
        vis[i]=del[i]=deledge[i]=0;
        g[i].clear();
    }
    while(!heap.empty())heap.pop();
    ptot=heaptot=0;
}

signed main(){
    scanf("%lld\n",&T);
    while(T--){
        scanf("%lld%lld",&n,&q);
        for(int i=1;i<n;i++)scanf("%lld%lld%lld",&edge[i].u,&edge[i].v,&edge[i].w);
        for(int i=1;i<=q;i++)scanf("%lld",&qu[i]),deledge[qu[i]]=1;
        ptot=n;
        for(int i=1;i<=n;i++)FA[i]=i,val[i]=0,siz[i]=1;
        for(int i=1;i<n;i++){
            if(!deledge[i]){
                int u=edge[i].u,v=edge[i].v,w=edge[i].w;
                val[++ptot]=w,siz[ptot]=1;
                link(u,ptot),link(ptot,v);
                int fu=find(u),fv=find(v);
                FA[fv]=fu;
                g[u].push_back({0,v,w}),g[v].push_back({0,u,w});
            }
        }
        for(int i=1;i<=n;i++){
            if(!vis[i]){
                int fi=find(i);
                mxdep=-1,dfs(i,0,0);
                point[fi].first=mxp;
                mxdep=-1,dfs(mxp,0,0);
                point[fi].second=mxp;
                to[fi]=++heaptot;
                heap.push({mxdep,heaptot});
            }
        }
        for(int i=q;i>=1;i--){
            while(del[heap.top().id])heap.pop();
            ans[i]=heap.top().v;
            int u=edge[qu[i]].u,v=edge[qu[i]].v,w=edge[qu[i]].w;
            val[++ptot]=w,siz[ptot]=1;
            int fu=find(u),fv=find(v);
            PII a=point[fu],b=point[fv];
            link(u,ptot),link(ptot,v);
            int A=dis(a.first,a.second),B=dis(a.first,b.first),C=dis(a.first,b.second);
            int D=dis(a.second,b.first),E=dis(a.second,b.second),F=dis(b.first,b.second);
            if(A>=max({B,C,D,E,F}))point[fu]={a.first,a.second};
            else if(B>=max({A,C,D,E,F}))point[fu]={a.first,b.first};
            else if(C>=max({A,B,D,E,F}))point[fu]={a.first,b.second};
            else if(D>=max({A,B,C,E,F}))point[fu]={a.second,b.first};
            else if(E>=max({A,B,C,D,F}))point[fu]={a.second,b.second};
            else point[fu]={b.first,b.second};
            FA[fv]=fu;
            del[to[fu]]=del[to[fv]]=1;
            to[fu]=++heaptot;
            heap.push({max({A,B,C,D,E,F}),heaptot});
        }
        for(int i=1;i<=q;i++)printf("%lld\n",ans[i]);
        clear();
    }
	return 0;
}
```

---

## 作者：ZhongYuLin (赞：3)

该题本质上是求删边树上直径，考虑倒序处理，转化为加边树上直径。

有一个经典结论：在一棵边权非负的树上，一条边所连接的两个小连通块所构成的大的连通块的直径端点，必在两个小连通块直径端点之中（下侧给出证明）。于是我们使用并查集维护连通块、树剖计算两点距离即可。

对于一个联通块而言，其他节点到其中**某个直径端点**的距离，相较于到其他节点，要更为远。同时因为直径是极长的，并查集未进行维护的其余的直径不可能使得答案**更优**。于是，考虑新加入的边的两个端点，分别枚举两个联通块内维护的直径端点进行排列组合，一共有 6 种情况，取最优的即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int N=1e5+10;
struct Edge{
    int nxt,to,w,frm;
}e[N<<1];
struct Node{int l,r;};
int head[N],top[N],fa[N],sz[N],son[N],dep[N],f[N],d[N],l[N],r[N];
int tot,n,q,tim;
ll dis[N],ans[N];
ll res;
vector<Edge>Ed,E;
void add(int u,int v,int w){
    e[++tot]={head[u],v,w,u};
    head[u]=tot;
}
void dfs1(int x,int f){
    dep[x]=dep[f]+1;sz[x]=1;fa[x]=f;son[x]=0;
    for(int i=head[x];i;i=e[i].nxt){
        int y=e[i].to;
        if(y==f)continue;
        dis[y]=dis[x]+e[i].w;
        dfs1(y,x);sz[x]+=sz[y];
        if(sz[son[x]]<sz[y])son[x]=y;
    }
}
void dfs2(int x,int topf){
    top[x]=topf;
    if(son[x])dfs2(son[x],topf);
    for(int i=head[x];i;i=e[i].nxt){
        int y=e[i].to;
        if(y==fa[x]||y==son[x])continue;
        dfs2(y,y);
    }
}
int lca(int x,int y){
    while(top[x]^top[y]){
        if(dep[top[x]]<dep[top[y]])swap(x,y);
        x=fa[top[x]];
    }return dep[x]>dep[y]?y:x;
}
ll calc(int x,int y){return dis[x]+dis[y]-2*dis[lca(x,y)];}
int find(int x){return f[x]^x?find(f[x]):x;}
void merge(int x,int y){
    // printf("%d %d\n",x,y);
    x=find(x);y=find(y);
    if(d[x]>d[y])swap(x,y);
    Node nd[]={{l[x],r[x]},{l[x],l[y]},{l[x],r[y]},{r[x],l[y]},{r[x],r[y]},{l[y],r[y]}};
    ll dis[6];
    for(int i=0;i<6;++i)dis[i]=calc(nd[i].l,nd[i].r);
    auto it=max_element(dis,dis+6);
    res=max(res,*it);
    d[y]+=d[x]==d[y];f[x]=y;l[y]=nd[it-dis].l;r[y]=nd[it-dis].r;
    // printf("%d %d\n",l[y],r[y]);
}
void solve(){
    tot=res=0;Ed.clear();Ed.push_back({0,0,0,0});E.clear();E.push_back({0,0,0,0});
    cin>>n>>q;for(int i=1,u,v,w;i<n;++i)cin>>u>>v>>w,add(u,v,w),add(v,u,w),Ed.push_back({0,v,w,u});
    dfs1(1,0);dfs2(1,1);
    for(int i=1;i<=n;++i)l[i]=r[i]=f[i]=i,d[i]=1;
    for(int i=1,x;i<=q;++i)cin>>x,E.push_back(Ed[x]),Ed[x]={0,0,0,0};
    for(auto x:Ed)if(x.to!=0&&x.frm!=0)E.push_back(x);
    reverse(E.begin()+1,E.end());
    for(int i=1;i<n;++i)ans[i]=res,merge(E[i].frm,E[i].to);
    for(int i=n-1;i>=n-q;--i)printf("%lld\n",ans[i]);
    for(int i=1;i<=n;++i)head[i]=top[i]=fa[i]=sz[i]=son[i]=dep[i]=f[i]=d[i]=l[i]=r[i]=0;
}
int main(){ 
    // freopen("in.in","r",stdin);
    ios::sync_with_stdio(cin.tie(cout.tie(0)));
    int T;for(cin>>T;T--;)solve();
    return 0;
}
```

---

## 作者：Iniaugoty (赞：3)

看到这种正着删边就很不好做。

但他没有强制在线，考虑离线下来，倒着加边。

首先对每个连通块都求一遍直径及其端点。

然后考虑如何加边合并两个连通块。

首先并查集维护连通性是显然的。

然后有一个性质，合并后连通块直径两端点一定是，原来两个连通块的四个直径端点，中的两个。因为，假设新的直径端点原来不是旧的直径端点之一，那么换成一个直径端点显然更优。

那么我们维护树上两点距离，分类讨论就行了。

注意到合并后的直径一定不小于合并前的直径，那么每个时刻的答案可以直接从下一个时刻继承过来。

时间复杂度 $\mathcal O (n \log n)$。瓶颈在于求 LCA（或者预处理）。

貌似可以二次离线下来，用 Tarjan LCA 做到严格线性。但我不会。

实现注意多测清空和亿些细节。

很好的细节，使我赛后很快过题。

```cpp
#include <bits/stdc++.h>

#define F(i, a, b) for(int i = (a); i <= (b); ++i)
#define dF(i, a, b) for(int i = (a); i >= (b); --i)

using namespace std;
typedef long long LL;
typedef unsigned long long ull;
typedef unsigned int uint;
const int N = 1e5 + 5;

int _, n, q, u[N], v[N], w[N], op[N]; bool b[N];
struct edge { int v, w; } ; vector<edge> e[N], g[N];

LL dis[N]; int cnt, dfn[N], dep[N], st[18][N];
void Dfs(int u, int f) {
    dep[u] = dep[st[0][dfn[u] = ++cnt] = f] + 1;
    for (auto it : e[u]) if (it.v != f)
        dis[it.v] = dis[u] + it.w, Dfs(it.v, u);
} int Get(int x, int y) { return dep[x] < dep[y] ? x : y; }
int Lca(int u, int v) {
    if (u == v) return u; if (dfn[u] > dfn[v]) swap(u, v);
    int k = log2(dfn[v] - dfn[u]); return Get(st[k][dfn[u] + 1], st[k][dfn[v] - (1 << k) + 1]);
} LL Dis(int u, int v) { return dis[u] + dis[v] - 2 * dis[Lca(u, v)]; }

LL dist[N]; int far;
void Getdis(int u, int f) {
    if (dist[u] > dist[far]) far = u;
    for (auto it : g[u]) if (it.v != f)
        dist[it.v] = dist[u] + it.w, Getdis(it.v, u);
}

int fa[N], be[N], ed[N]; LL mx[N], ans[N]; bool vis[N];
int Find(int x) { return fa[x] == x ? x : fa[x] = Find(fa[x]); }

int main() {
    // freopen("wmyr.in", "r", stdin);
    // freopen("wmyr.out", "w", stdout);
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> _; while (_--) {
        cin >> n >> q; F(i, 1, n - 1)
            cin >> u[i] >> v[i] >> w[i],
            e[u[i]].push_back({v[i], w[i]}), e[v[i]].push_back({u[i], w[i]});
        Dfs(1, 0); F(i, 1, 17) for (int j = 1; j + (1 << i) - 1 <= n; ++j)
            st[i][j] = Get(st[i - 1][j], st[i - 1][j + (1 << i - 1)]);
        F(i, 1, q) cin >> op[i], b[op[i]] = 1;
        F(i, 1, n) fa[i] = i;
        F(i, 1, n - 1) if (!b[i])
            g[u[i]].push_back({v[i], w[i]}), g[v[i]].push_back({u[i], w[i]}),
            fa[Find(u[i])] = Find(v[i]);
        F(i, 1, n) if (!vis[Find(i)]) {
            int u = Find(i); vis[u] = 1;
            dist[far = 0] = -1, dist[u] = 0, Getdis(u, 0), be[u] = far;
            dist[far = 0] = -1, dist[be[u]] = 0, Getdis(be[u], 0), ed[u] = far, far = 0;
            ans[q] = max(ans[q], mx[u] = dist[ed[u]]);
        } dF(i, q, 1) {
            int x = Find(u[op[i]]), y = Find(v[op[i]]);
            LL d1 = Dis(be[x], be[y]), d2 = Dis(be[x], ed[y]);
            LL d3 = Dis(ed[x], be[y]), d4 = Dis(ed[x], ed[y]);
            mx[fa[x] = y] = max(max(max(d1, d2), max(d3, d4)), max(mx[x], mx[y]));
            ans[i - 1] = max(ans[i], mx[y]);
            if (mx[y] == d1) ed[y] = be[x];
            else if (mx[y] == d2) be[y] = be[x];
            else if (mx[y] == d3) ed[y] = ed[x];
            else if (mx[y] == d4)  be[y] = ed[x];
            else if (mx[y] == mx[x]) be[y] = be[x], ed[y] = ed[x];
        } F(i, 1, q) cout << ans[i] << "\n";
        cnt = 0; F(i, 1, n) b[i] = vis[i] = 0, e[i].clear(), g[i].clear();
    }
    return 0;
}
```

---

## 作者：hh弟中弟 (赞：2)

直接进行边的删除是一个很难的问题，通常离线下来倒着做，把删边转化成了加边。\
两个经典结论：
- 树上一个点到一个直径的端点的距离为它能延伸的最远距离。
- 树上两个点集的并集的直径端点一定是这两个集合中的直径端点。

这两个结论都可以由反证法得出。\
知道这两个结论就可以直接做了。预处理 LCA，用并查集维护一下连通性，然后每次合并的时候分讨得到新的直径信息。查询直接根据第一个结论查就可以了。
```cpp
#include<bits/stdc++.h>
#define int long long
typedef long long ll;
typedef unsigned long long ull;
inline int read(){char ch=getchar();int x=0,f=1;for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<3)+(x<<1)+(ch^48);return x*f;}
const int N=2e5+10;
int n,m,st[20][N],dfn[N],dfcnt,dep[N],ans,ANS[N],tot;
bool vis[N];
struct EDGE{int u,v;}e[N];
std::vector<std::pair<int,int>> g[N];
struct OP{int op,x;}o[N];
struct node{int fa,l,r,dis;}fa[N];
inline int find(int x){return fa[x].fa==x?x:fa[x].fa=find(fa[x].fa);}
inline int get(int x,int y){return dep[x]>dep[y]?y:x;}
inline void dfs(int u,int fa){
	dfn[u]=++dfcnt;
	st[0][dfcnt]=fa;
    for(auto it:g[u])if(it.first!=fa)dep[it.first]=dep[u]+it.second,dfs(it.first,u);
}
inline int get_dis(int u,int v){
	if(u==v)return 0;
	int x=u,y=v;
	if((u=dfn[u])>(v=dfn[v]))std::swap(u,v);
	int d=std::__lg(v-u++);
	int lca=get(st[d][u],st[d][v-(1<<d)+1]);
	return dep[x]+dep[y]-2*dep[lca];
}
inline void merge(int i){
	int u=find(e[i].u),v=find(e[i].v);
	fa[u].fa=v;
	int max=std::max(get_dis(fa[v].l,fa[u].l),get_dis(fa[v].l,fa[u].r));
	max=std::max(max,std::max(get_dis(fa[v].r,fa[u].l),get_dis(fa[v].r,fa[u].r)));
	max=std::max(max,std::max(fa[u].dis,fa[v].dis));
	if(get_dis(fa[v].l,fa[u].l)==max){
		fa[v].dis=get_dis(fa[v].l,fa[u].l);
		fa[v].r=fa[u].l;
        ans=std::max(ans,fa[v].dis);
        return;
	}if(get_dis(fa[v].l,fa[u].r)==max){
		fa[v].dis=get_dis(fa[v].l,fa[u].r);
		fa[v].r=fa[u].r;
        ans=std::max(ans,fa[v].dis);
        return;
	}if(get_dis(fa[v].r,fa[u].l)==max){
		fa[v].dis=get_dis(fa[v].r,fa[u].l);
		fa[v].l=fa[u].l;
        ans=std::max(ans,fa[v].dis);
        return;
	}if(get_dis(fa[v].r,fa[u].r)==max){
		fa[v].dis=get_dis(fa[v].r,fa[u].r);
		fa[v].l=fa[u].r;
        ans=std::max(ans,fa[v].dis);
        return;
	}if(fa[u].dis==max){
		fa[v].dis=fa[u].dis;
		fa[v].l=fa[u].l,fa[v].r=fa[u].r;
        ans=std::max(ans,fa[v].dis);
		return;
	}
}
signed main(){
	std::ios::sync_with_stdio(false);std::cin.tie(0);std::cout.tie(0);
    int T=read();
    while(T--){
        n=read(),m=read();
        ans=0;dfcnt=0;
        for(int i=1;i<=n;++i)fa[i]={i,i,i,0},g[i].clear();
        for(int i=1;i<n;++i){
            e[i].u=read(),e[i].v=read();int w=read();
            g[e[i].v].push_back({e[i].u,w});
            g[e[i].u].push_back({e[i].v,w});
        }
        dfs(1,0);
        for(int i=1;i<=std::__lg(n);++i)
            for(int j=1;j+(1<<i)-1<=n;++j)
                st[i][j]=get(st[i-1][j],st[i-1][j+(1<<i-1)]);
        for(int i=1;i<=m;++i)o[i].x=read(),vis[o[i].x]=1;
        for(int i=1;i<n;++i){
            if(!vis[i])merge(i);
            vis[i]=0;
        }
        for(int i=m;i;--i)ANS[++tot]=ans,merge(o[i].x);
        for(;tot;--tot)std::cout<<ANS[tot]<<'\n';
    }
}
```

---

## 作者：11400F (赞：1)

## [P10238 PANDORA PARADOXXX Re:Master Lv.15](https://www.luogu.com.cn/problem/P10238)

[~~有新的旅行伙伴加入了哟！~~](https://11400f.github.io/2025/03/05/R703-practice-log/#p10238-pandora-paradoxxx-remaster-lv.15)


---

题目用人话来说就是给一棵树，每次删边，求所有连通块里最大的直径。

删边之后求直径不好搞，可以考虑正难则反，时光倒流，从后往前加边。

那么我们就可以首先得到一些树形的连通块，然后用两次 DFS 求出这些连通块的直径。

每次用一条边合并两个连通块，然后更新大小较小的连通块的信息，再对于这个新的连通块求新的直径长度。而现在我们要实现的就是如何快速求这个新的直径长度。

假设我们已知之前的那两个连通块的直径分别为 $(a, b)$ 和 $(c, d)$。那么新的直径有 3 种情况：

- $(a,b)$

- $(c,d)$

- 这种情况肯定是一条直径连接了两个连通块。那么肯定经过了连接两个连通块的那条边。设这条边为 $(x,y)$。

  要使这个直径最长，那么第一个端点肯定要选 $x$ 所在的连通块里距离 $x$ 最大的一个点，第二个端点肯定要选 $y$ 所在的连通块里距离 $y$ 最大的一个点。

  而我们知道，两次 DFS 求直径的方法里的第一次 DFS 之后就是拿的距离最大的一个点作为树的直径端点之一。所以第一个端点肯定是 $x$ 的直径的一个端点，第二个端点同理。

于是，就得到了一个性质，新直径的两个端点一定是 $a,b,c,d$ 的其中两个，即原来两个直径的四个端点的其中两个。

利用之前维护的性质，可以在树上记录每一个点到根的距离 $dis$ 和求 LCA 来求出两点之间的距离。然后新的直径就可以确定出来了。

然后倒序记录答案，最后输出答案即可。记得多测要清空！



```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
struct Edge{
    int to, nxt, w, u;
}edge[N<<1];
int h[N], cnt=1;
void _add(int u, int v, int w){
    edge[++cnt] = {v, h[u], w, u};
    h[u] = cnt;
}
void add(int u, int v, int w){
    _add(u, v, w), _add(v, u, w);
}
#define readd(u,v,w) reedge[u].push_back({v,w}), reedge[v].push_back({u,w})
int del[N], siz[N];
bool vis[N];
int belong[N], n, q, belongcnt=1, rt[N];
struct D{
    int l, r;
}p[N];
ll dis[N], maxdis[N];
ll nowmaxdist = 0;
ll ans[N];
const int L = 18;
int anc[N][19];
typedef pair<int, int> pii;
vector<pii> reedge[N];
void dfs(int x, int nowbelong, int fa){
    belong[x] = nowbelong;
    siz[nowbelong] ++;
    if(dis[x] > maxdis[nowbelong]){
        maxdis[nowbelong] = dis[x];
        p[nowbelong].l = x;
    }
    for(int i=h[x];i;i=edge[i].nxt){
        int v = edge[i].to, w = edge[i].w;
        if(v == fa) continue;
        int nowidx = i/2;
        if(vis[nowidx]){
            rt[++belongcnt] = v;
            p[belongcnt].l = v;
            dis[v] = 0;
            dfs(v, belongcnt, x);
        }else{
            readd(x, v, w);
            dis[v] = dis[x] + w;
            dfs(v, nowbelong, x);
        }
    }
}

int dep[N];

void dfs_a(int x, int nowbelong, int fa){
    if(dis[x] > maxdis[nowbelong]){
        maxdis[nowbelong] = dis[x];
        p[nowbelong].r = x;
    }
    anc[x][0] = fa;
    dep[x] = dep[fa] + 1;
    for(int i=1;i<=L;i++) anc[x][i] = anc[anc[x][i-1]][i-1];
    for(pii now: reedge[x]){
        int v = now.first, w = now.second;
        if(v == fa) continue;
        dis[v] = dis[x] + w;
        dfs_a(v, nowbelong, x);
    }
}

void geteverydist(){
    memset(dis, 0, sizeof dis);
    for(int i=1;i<=belongcnt;i++){
        p[i].r = p[i].l;
        maxdis[i] = 0;
        rt[i] = p[i].l;
        dfs_a(rt[i], i, 0);
        nowmaxdist = max(nowmaxdist, dis[p[i].r]);
    }
}

void dfs_b(int x, int fa, int shouldbelongto){
    belong[x] = shouldbelongto;
    anc[x][0] = fa;
    dep[x] = dep[fa] + 1;
    for(int i=1;i<=L;i++) anc[x][i] = anc[anc[x][i-1]][i-1];
    for(pii now: reedge[x]){
        int v = now.first, w = now.second;
        if(v == fa) continue;
        dis[v] = dis[x] + w;
        dfs_b(v, x, shouldbelongto);
    }
}

int getlca(int x, int y){
    if(dep[x] < dep[y]) swap(x, y);
    int sa = dep[x] - dep[y];
    for(int i=L;i>=0&&sa;i--){
        if(sa&(1<<i)){
            sa -= (1<<i);
            x = anc[x][i];
        }
    }
    if(x == y) return x;
    for(int i=L;i>=0;i--){
        if(anc[x][i]^anc[y][i]){
            x = anc[x][i], y = anc[y][i];
        }
    }
    return anc[x][0];
}

ll sum(int x, int y){
    return dis[x] + dis[y] - 2*dis[getlca(x,y)];
}

void solve(){
    cin>>n>>q;
    int u, v, w;
    for(int i=1;i<n;i++){
        cin>>u>>v>>w;
        add(u, v, w);
    }
    for(int i=1;i<=q;i++){
        cin>>del[i];
        vis[del[i]] = 1;
    }
    rt[1] = 1; p[1].l = 1;
    dfs(1, 1, 0);
    geteverydist();
    ans[q] = nowmaxdist;
    int ord[4];
    for(int i=q;i>1;i--){
        
        u = edge[del[i]*2].u, v = edge[del[i]*2].to, w = edge[del[i]*2].w;
        ord[0] = p[belong[u]].l, ord[1] = p[belong[u]].r, ord[2] = p[belong[v]].l, ord[3] = p[belong[v]].r;
        if(siz[belong[u]] < siz[belong[v]]) swap(u, v);
        // u <- v
        siz[belong[u]] += siz[belong[v]];
        readd(u, v, w);
        dis[v] = dis[u] + w;
        dfs_b(v, u, belong[u]);
        ll curmax = 0;
        int maxl=ord[0], maxr=ord[1];
        for(int l=0;l<=3;l++){
            for(int r=l+1;r<=3;r++){
                // cerr<<ord[l]<<' '<<ord[r]<<'\n';
                ll curdis = sum(ord[l], ord[r]);
                if(curdis > curmax){
                    curmax = curdis;
                    maxl = ord[l], maxr = ord[r];
                }
            }
        }
        p[belong[u]].l = maxl, p[belong[u]].r = maxr;
        nowmaxdist = max(nowmaxdist, curmax);
        ans[i-1] = nowmaxdist;
    }
    for(int i=1;i<=q;i++){
        cout<<ans[i]<<'\n';
    }
}
void duoceclear(){
    cnt = 1; belongcnt = 1;
    memset(h, 0, (n+2)<<2);
    for(int i=1;i<=n;i++) siz[i] = 0, rt[i] = 0, belong[i] = 0, vis[i] = 0;
    for(int i=1;i<=n;i++) reedge[i].clear(), reedge[i].shrink_to_fit();
    for(int i=1;i<=n;i++) maxdis[i] = 0;
    nowmaxdist = 0;
}
int main(){
    // freopen("maimai.in", "r", stdin);
    // freopen("maimai.out", "w", stdout);
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int t=1;
    cin>>t;
    while(t--){
        solve();
        duoceclear();
    }
    return 0;
}
```

---

## 作者：happybob (赞：1)

离线倒着做，变成连边，以及询问所有连通块直径最大值。

然后是一个经典结论，就是当边权非负时，两个连通块合并，新的直径端点必然是之前两个连通块的四个端点的其中两个，于是你可以使用并查集维护连通块，以及每个连通块的直径端点。合并的时候大力分讨几种即可。

证明：

考虑新的直径，要么在原来的两个连通块内部，要么横跨连通块。在连通块内部的时候，两个端点就是之前两部分的端点。否则，由于树中离每个点最远的点必然在直径端点上，这个就必然成立了。

```cpp
#include <bits/stdc++.h>
using namespace std;
//#define int long long

using ll = long long;

const int N = 1e5 + 5, MOD = 1e9 + 7, HSMOD = 1610612741, HSMOD2 = 998244353; // Remember to change

int n, m, q, t, a[N];
mt19937 rnd(chrono::system_clock::now().time_since_epoch().count());

long long qpow(long long a, long long b)
{
	long long res = 1ll, base = a;
	while (b)
	{
		if (b & 1ll) res = res * base % MOD;
		base = base * base % MOD;
		b >>= 1ll;
	}
	return res;
}

bool isprime(int x)
{
	if (x == 1) return 0;
	for (int i = 2; 1ll * i * i <= x; i++) if (x % i == 0) return 0;
	return 1;
}

namespace FastIo
{
	#define QUICKCIN ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)
	int read()
	{
		char ch = getchar();
		int x = 0, f = 1;
		while ((ch < '0' || ch > '9') && ch != '-') ch = getchar();
		while (ch == '-')
		{
			f = -f;
			ch = getchar();
		}
		while (ch >= '0' && ch <= '9')
		{
			x = (x << 1) + (x << 3) + (ch ^ 48);
			ch = getchar();
		}
		return x * f;
	}
	template<class T>
	void write(T x)
	{
		if (x < 0)
		{
			putchar('-');
			x = -x;
		}
		if (x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
	template<class T>
	void writeln(T x)
	{
		write(x);
		putchar('\n');
	}
}

template<typename T>
class Bit
{
public:
	T lowbit(T x)
	{
		return x & -x;
	}
	T tr[N];
	void add(T x, T y)
	{
		while (x < N)
		{
			tr[x] += y;
			x += lowbit(x);
		}
	}
	T query(T x)
	{
		T sum = 0;
		while (x)
		{
			sum += tr[x];
			x -= lowbit(x);
		}
		return sum;
	}
};

int u[N],v[N];
ll w[N];
vector<pair<int,ll>> G[N];
int fa[N][21];
ll dis[N];
int dep[N];

void dfs(int u,int f,int d)
{
	fa[u][0]=f;
	dep[u]=d;
	for(auto&[j,w]:G[u])
	{
		if(j!=f)
		{
			dis[j]=dis[u]+w;
			dfs(j,u,d+1);
		}
	}
}

ll res[N];

inline int LCA(int u,int v)
{
	if(u==v) return u;
	if(dep[u]<dep[v]) swap(u,v);
	int k=dep[u]-dep[v],c=0;
	while(k)
	{
		if(k&1) u=fa[u][c];
		c++;
		k>>=1;
	}
	if(u==v) return u;
	for(int i=20;i>=0;i--) if(fa[u][i]^fa[v][i]) u=fa[u][i],v=fa[v][i];
	return fa[u][0];
}

inline ll getdis(int u,int v)
{
	return dis[u]+dis[v]-2*dis[LCA(u,v)];
}

ll ans=-1ll;

class Union_Find
{
public:
	int fa[N];
	pair<int,int> diamt[N];
	void Init()
	{
		for(int i=1;i<=n;i++) fa[i]=i,diamt[i]=make_pair(i,i);
	}
	int find(int u)
	{
		return (fa[u]==u?u:fa[u]=find(fa[u]));
	}
	void merge(int u,int v)
	{
		if((u=find(u))==(v=find(v))) return;
		vector<int> ver;
		ver.emplace_back(diamt[u].first);
		ver.emplace_back(diamt[u].second);
		ver.emplace_back(diamt[v].first);
		ver.emplace_back(diamt[v].second);
		int ru=0,rv=0;
		ll md=-1ll;
		for(int i=0;i<4;i++)
		{
			for(int j=i+1;j<4;j++)
			{
				ll nd=getdis(ver[i],ver[j]);
				if(nd>md) md=nd,ru=ver[i],rv=ver[j];
			}
		}
		ans=max(ans, md);
		fa[v]=u;
		diamt[u]=make_pair(ru,rv);
	}
}dsu;
bool flag[N];

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	cin>>t;
	while(t--)
	{
		cin>>n>>q;
		dsu.Init();
		for(int i=1;i<=n;i++) G[i].clear(),G[i].shrink_to_fit(),flag[i]=0;
		for(int i=1;i<n;i++) 
		{
			cin>>u[i]>>v[i]>>w[i];
			G[u[i]].emplace_back(make_pair(v[i],w[i]));
			G[v[i]].emplace_back(make_pair(u[i],w[i]));
		}
		dfs(1,0,1);
		vector<int> del;
		for(int i=1;i<=q;i++)
		{
			int e;
			cin>>e;
			flag[e]=1;
			del.emplace_back(e);
		}
		ans=0ll;
		reverse(del.begin(),del.end());
		for(int j=1;j<=20;j++) for(int i=1;i<=n;i++) fa[i][j]=fa[fa[i][j-1]][j-1];
		for(int i=1;i<n;i++) if(!flag[i]) dsu.merge(u[i],v[i]);
		int idx=q;
		for(auto&j:del)
		{
			res[idx]=ans;
			idx--;
			dsu.merge(u[j],v[j]);
		}
		for(int i=1;i<=q;i++) cout<<res[i]<<"\n";
	}
	return 0;
}


```

---

## 作者：lhc0707 (赞：0)

删边不好做，所以正难则反，不断加边，然后考虑两个连通块的直径怎么合并，那合并之后的连通块的直径只可能是以下几种：

- 原来两部分各自的直径
- 两个直径拼起来

考虑直径怎么拼，新的直径的端点肯定是原来两个连通块的直径的端点中的两个。证明这个只需要证到任意点距离最远的点一定是直径的两个端点之一。

$\text{proof.}$ 

记 $\text{d}(x,y)$ 表示点 $x$ 和点 $y$ 之间的距离，设直径的两个端点是 $x,y$，当前点是 $u$，不妨设 $\text{d}(u,x)\leq \text{d}(u,y)$。

运用反证法，若 $\exists z\not =x,y$，使 $\text{d}(u,z)>\text{d}(u,y)$，于是我们可以在直径中把 $y$ 换成 $z$，于是 $x$ 和 $y$ 之间的路径不是直径，矛盾，所以 $\text{d}(u,y)$ 一定大于所有 $\text{d}(u,z)$，$\square$。

运用树上差分和 $\text{LCA}$ 求出两点间距离，然后就可以合并了。

代码不好写，所以上代码：

```cpp
#include <algorithm>
#include <cstdio>
#include <iostream>
#include <vector>
#define int long long
using namespace std;
using ui = unsigned int;
using pii = pair<int, int>;
const int INF = 1e18;
const int N = 100005;
int n, q, fa[N], dep[N], siz[N], hson[N], top[N], dis[N], e[N], f[N], mx, ans[N];
vector<int> g[N], c[N];
vector<pii> edge;
pii dia[N];
bool vis[N];
void add(int u, int v, int w) { g[u].push_back(v), c[u].push_back(w); }
void dfs1(int u, int fath)
{
    fa[u] = fath, dep[u] = dep[fath] + 1, siz[u] = 1;
    for (ui i = 0; i < g[u].size(); i++)
    {
        int v = g[u][i], w = c[u][i];
        if (v == fath) continue;
        dis[v] = dis[u] + w;
        dfs1(v, u), siz[u] += siz[v];
        if (!hson[u] || siz[v] > siz[hson[u]]) hson[u] = v;
    }
}
void dfs2(int u, int tp)
{
    top[u] = tp;
    if (hson[u]) dfs2(hson[u], tp);
    for (ui i = 0; i < g[u].size(); i++)
        if (g[u][i] != fa[u] && g[u][i] != hson[u]) dfs2(g[u][i], g[u][i]);
}
int LCA(int x, int y)
{
    while (top[x] != top[y]) dep[top[x]] < dep[top[y]] ? y = fa[top[y]] : x = fa[top[x]];
    return dep[x] < dep[y] ? x : y;
}
int d(int u, int v) { return dis[u] + dis[v] - 2 * dis[LCA(u, v)]; }
int getf(int x) { return f[x] == x ? x : f[x] = getf(f[x]); }
void merge(int x, int y)
{
    int fx = getf(x), fy = getf(y), tmp = 0;
    int tx[] = {dia[fx].first, dia[fx].second};
    int ty[] = {dia[fy].first, dia[fy].second};
    f[fy] = fx;
    int d1 = d(tx[0], tx[1]);
    int d2 = d(ty[0], ty[1]);
    if (d1 > tmp) tmp = d1, dia[fx] = {tx[0], tx[1]};
    if (d2 > tmp) tmp = d2, dia[fx] = {ty[0], ty[1]};
    for (int i = 0; i < 2; i++)
        for (int j = 0; j < 2; j++)
        {
            int ds = d(tx[i], ty[j]);
            if (ds > tmp) tmp = ds, dia[fx] = {tx[i], ty[j]};
        }
    mx = max(mx, tmp);
}
signed main()
{
    cin.tie(0)->sync_with_stdio(false);
    cout.tie(0);
    int tt;
    cin >> tt;
    while (tt--)
    {
        cin >> n >> q;
        mx = dis[1] = dep[0] = 0;
        edge.clear();
        edge.push_back({0, 0});
        for (int i = 1; i <= n; i++)
            g[i].clear(), c[i].clear(), f[i] = i, vis[i] = false, dia[i] = {i, i}, hson[i] = 0;
        for (int i = 1; i < n; i++)
        {
            int u, v, w;
            cin >> u >> v >> w;
            edge.push_back({u, v});
            add(u, v, w), add(v, u, w);
        }
        dfs1(1, 0), dfs2(1, 1);
        for (int i = 1; i <= q; i++) cin >> e[i], vis[e[i]] = true;
        for (int i = 1; i < n; i++)
            if (!vis[i]) merge(edge[i].first, edge[i].second);
        for (int i = q; i >= 1; i--)
        {
            ans[i] = mx;
            merge(edge[e[i]].first, edge[e[i]].second);
        }
        for (int i = 1; i <= q; i++) cout << ans[i] << '\n';
    }
    return 0;
}
```

---

## 作者：HPXXZYY (赞：0)

$\color{blue}{\texttt{[Analysis]}}$

删除，而且没有强制在线，一般就可以考虑时光倒流了。

离线，把删除改为加入。

在加入边前，整个图是由很多棵相互不联通的树组成的，两点间的最大长度就是所有树的直径长度的最大值。

求直径当然是 $O(n)$ 的啦。

考虑加入一条边 $(u,v)$ 对答案有什么影响。

假设加入边 $(u,v)$ 前 $u$ 所在子树的直径两端分别为 $l_{u},r_{u}$，同理，$v$ 所在子树的直径两端分别为 $l_{v},r_{v}$。可以证明加入边 $(u,v)$ 后这棵新树的直径两端一定是 $l_{u},r_{u},l_{v},r_{v}$ 四个点中的两个。

> 证明可以考虑分类讨论：
> 1. 如果新树的直径不经过 $(u,v)$，那它的直径就是原来的两棵子树的直径较长的那一条；即端点要么是 $l_{u},r_{u}$，要么是 $l_{v},r_{v}$。
> 2. 如果新树的直径经过 $(u,v)$，在原来 $u$ 的子树中离 $u$ 最远的点一定是 $l_{u}$ 或者 $r_{u}$，在原来 $v$ 的子树中离 $v$ 最远的点一定是 $l_{v}$ 或者 $r_{v}$。所以新树的直径一定是一端是 $l_{u}$ 或者 $r_{u}$，另一端是 $l_{v}$ 	或者 $r_{v}$。

这样利用 LCA 可以 $O(\log n)$ 求出任意两点间的距离。即每次加入一条边的时间复杂度为 $O(\log n)$。

总的时间复杂度为 $O(q \log n)$。

$\color{blue}{\text{Code}}$

```cpp
struct UnionFind{
	int Fa[N];
	
	void clear(int n){
		for(int i=1;i<=n;i++) Fa[i]=i;
	}
	
	int getf(int x){
		if (Fa[x]==x) return x;
		return Fa[x]=getf(Fa[x]);
	}
	void merge(int x,int y){
		int u=getf(x),v=getf(y);
		Fa[v]=u;//注意次序 
	}
}Reach;//封装一个并查集

struct edge{
	int nxt,to,val;
	
	int operator = (int n){
		return nxt=to=val=n;
	}
}e[N<<1],E[N<<1];
int h[N],ecnt,H[N],Ecnt;
void add(int u,int v,int w){
	e[++ecnt]=(edge){h[u],v,w};h[u]=ecnt;
	e[++ecnt]=(edge){h[v],u,w};h[v]=ecnt;
}
void Add(int u,int v,int w){
	E[++Ecnt]=(edge){H[u],v,w};H[u]=Ecnt;
	E[++Ecnt]=(edge){H[v],u,w};H[v]=Ecnt;
}

int Fa[22][N],n,m,dep[N],Log[N];
ll len[N];

void dfs(int u,int fa){
	dep[u]=dep[fa]+1;
	
	for(int i=h[u];i;i=e[i].nxt){
		int v=e[i].to;
		if (v==fa) continue;
		
		len[v]=len[u]+e[i].val;
		Fa[0][v]=u;
		dfs(v,u);
	}
}
void dispose(){
	for(int i=1;i<=Log[n];i++)
		for(int u=1;u<=n;u++)
			Fa[i][u]=Fa[i-1][Fa[i-1][u]];
}
int LCA(int u,int v){
	if (dep[u]<dep[v]) swap(u,v);
	
	int k=dep[u]-dep[v];
	for(int i=Log[k];i>=0;i--)
		if (dep[u]-dep[v]>=(1<<i))
			u=Fa[i][u];
	
	if (u==v) return u;
	
	for(int i=Log[dep[u]];i>=0;i--)
		if (Fa[i][u]!=Fa[i][v]){
			u=Fa[i][u];v=Fa[i][v];
		}
	return Fa[0][u];
}
ll distance(int u,int v){
	return len[u]+len[v]-(len[LCA(u,v)]<<1);
}

ll dis[N];
int dp(int u,int fa){
	int ret=u;
	for(int i=H[u];i;i=E[i].nxt){
		int v=E[i].to;
		if (v==fa) continue;
		
		dis[v]=dis[u]+E[i].val;
		int tmp=dp(v,u);
		if (dis[tmp]>dis[ret]) ret=tmp;
	}
	
	return ret;
}//求树中离 u 最远的点

ll ans,out[N];bool flag[N];
int del[N],l[N],r[N];

struct linkage{
	int u,v,val;
}Link[N];

void merge(int u,int v){
	u=Reach.getf(u);
	v=Reach.getf(v);
	
	ll d1=distance(l[u],r[u]);
	ll d2=distance(l[v],r[v]);
	ll d3=distance(l[u],r[v]);
	ll d4=distance(l[v],r[u]);
	ll d5=distance(l[u],l[v]);
	ll d6=distance(r[u],r[v]);
	ll D=max(d1,max(d2,max(d3,max(d4,max(d5,d6)))));
	
	ans=max(ans,D);
	if (d2==D){
	    l[u]=l[v];r[u]=r[v];
	}//这里别漏情况
	else if (d3==D){
		l[u]=l[u];r[u]=r[v];
	}
	else if (d4==D){
		l[u]=r[u];r[u]=l[v];
	}
	else if (d5==D){
		l[u]=l[u];r[u]=l[v];
	}
	else if (d6==D){
		l[u]=r[u];r[u]=r[v];
	}
	
	Reach.merge(u,v);//注意次序 
}

void initdata(){
	ecnt=Ecnt=ans=0;
	for(int i=1;i<=(n<<1);i++)
		E[i]=e[i]=0;
	for(int i=1;i<=n;i++){
		l[i]=r[i]=h[i]=H[i]=len[i]=dep[i]=0;
		flag[i]=true;
	}
	for(int i=0;i<=20;i++)
		for(int u=1;u<=n;u++)
			Fa[i][u]=0;
}//类似于 Codeforces 里的要求，不能直接用 memset 清零

int main(){
	Log[0]=-1;
	for(int i=1;i<=1e5;i++)
		Log[i]=Log[i>>1]+1;
	
	for(int T=read();T;T--){
		n=read();m=read();
		
		initdata();
		Reach.clear(n);
		
		for(int i=1;i<n;i++){
			Link[i].u=read();
			Link[i].v=read();
			Link[i].val=read();
			
			add(Link[i].u,Link[i].v,Link[i].val);
		}
		dfs(1,0);
		dispose();
		
		for(int i=1;i<=m;i++){
			del[i]=read();
			flag[del[i]]=false;
		}
		
		for(int i=1;i<n;i++)
			if (flag[i]){
				Add(Link[i].u,Link[i].v,Link[i].val);
				Reach.merge(Link[i].u,Link[i].v);
			}
		
		for(int i=1;i<=n;i++)
			if (Reach.getf(i)==i){
				dis[i]=0;l[i]=dp(i,0);
				dis[l[i]]=0;r[i]=dp(l[i],0);
				ans=max(ans,distance(l[i],r[i]));
			}
		
		for(int i=m;i>=1;i--){
			out[i]=ans;
			merge(Link[del[i]].u,Link[del[i]].v);
		}
		
		for(int i=1;i<=m;i++)
			printf("%lld\n",out[i]);
	}
	
	return 0;
}

ll 表示 long long
```


这份代码能过，不过显得很冗长。因为最开始求各棵子树的直径和最后加边时求新直径用了两种不同的算法。

我们可以使用相同的算法减小代码长度：最开始求子树直径的时候也不一定要 $O(n)$ 的专门算法。开始时视为整个图由 $n$ 棵只有 $1$ 个节点的树组成，在求答案之前把所有不需要删除的边逐条加入图中也可以得到最开始时各棵子树的直径的最大值。

这样做的话，这一部分代码的时间复杂度是线性对数的，不如第一份代码；但是这样做可以减少代码长度，方便调试。


```cpp
struct UnionFind{
	int Fa[N];
	
	void clear(int n){
		for(int i=1;i<=n;i++) Fa[i]=i;
	}
	
	int getf(int x){
		if (Fa[x]==x) return x;
		return Fa[x]=getf(Fa[x]);
	}
	void merge(int x,int y){
		int u=getf(x),v=getf(y);
		Fa[v]=u;//注意次序 
	}
}Reach;

struct edge{
	int nxt,to,val;
	
	int operator = (int n){
		return nxt=to=val=n;
	}
}e[N<<1];int h[N],ecnt;
void add(int u,int v,int w){
	e[++ecnt]=(edge){h[u],v,w};h[u]=ecnt;
	e[++ecnt]=(edge){h[v],u,w};h[v]=ecnt;
}

int Fa[22][N],n,m,dep[N],Log[N];
ll len[N];

void dfs(int u,int fa){
	dep[u]=dep[fa]+1;
	
	for(int i=h[u];i;i=e[i].nxt){
		int v=e[i].to;
		if (v==fa) continue;
		
		len[v]=len[u]+e[i].val;
		Fa[0][v]=u;
		dfs(v,u);
	}
}
void dispose(){
	for(int i=1;i<=Log[n];i++)
		for(int u=1;u<=n;u++)
			Fa[i][u]=Fa[i-1][Fa[i-1][u]];
}
int LCA(int u,int v){
	if (dep[u]<dep[v]) swap(u,v);
	
	int k=dep[u]-dep[v];
	for(int i=Log[k];i>=0;i--)
		if (dep[u]-dep[v]>=(1<<i))
			u=Fa[i][u];
	
	if (u==v) return u;
	
	for(int i=Log[dep[u]];i>=0;i--)
		if (Fa[i][u]!=Fa[i][v]){
			u=Fa[i][u];v=Fa[i][v];
		}
	return Fa[0][u];
}
ll distance(int u,int v){
	return len[u]+len[v]-(len[LCA(u,v)]<<1);
}

ll ans,out[N];bool flag[N];
int del[N],l[N],r[N];

struct linkage{
	int u,v,val;
}Link[N];

void merge(int u,int v){
	u=Reach.getf(u);
	v=Reach.getf(v);
	
	ll d1=distance(l[u],r[u]);
	ll d2=distance(l[v],r[v]);
	ll d3=distance(l[u],r[v]);
	ll d4=distance(l[v],r[u]);
	ll d5=distance(l[u],l[v]);
	ll d6=distance(r[u],r[v]);
	ll D=max(d1,max(d2,max(d3,max(d4,max(d5,d6)))));
	
	ans=max(ans,D);
	if (d2==D){
		l[u]=l[v];r[u]=r[v];
	}
	else if (d3==D){
		l[u]=l[u];r[u]=r[v];
	}
	else if (d4==D){
		l[u]=r[u];r[u]=l[v];
	}
	else if (d5==D){
		l[u]=l[u];r[u]=l[v];
	}
	else if (d6==D){
		l[u]=r[u];r[u]=r[v];
	}
	
	Reach.merge(u,v);//注意次序 
}

void initdata(){
	ecnt=ans=0;
	for(int i=1;i<=(n<<1);i++) e[i]=0;
	for(int i=1;i<=n;i++){
		l[i]=r[i]=i;
		h[i]=len[i]=dep[i]=0;
		flag[i]=true;
	}
	for(int i=0;i<=20;i++)
		for(int u=1;u<=n;u++)
			Fa[i][u]=0;
}

int main(){
	Log[0]=-1;
	for(int i=1;i<=1e5;i++)
		Log[i]=Log[i>>1]+1;
	
	for(int T=read();T;T--){
		n=read();m=read();
		
		initdata();
		Reach.clear(n);
		
		for(int i=1;i<n;i++){
			Link[i].u=read();
			Link[i].v=read();
			Link[i].val=read();
			
			add(Link[i].u,Link[i].v,Link[i].val);
		}
		dfs(1,0);
		dispose();
		
		for(int i=1;i<=m;i++){
			del[i]=read();
			flag[del[i]]=false;
		}
		
		for(int i=1;i<n;i++)//这里是改变的地方
			if (flag[i]) merge(Link[i].u,Link[i].v);
		
		for(int i=m;i>=1;i--){
			out[i]=ans;
			merge(Link[del[i]].u,Link[del[i]].v);
		}
		
		for(int i=1;i<=m;i++)
			printf("%lld\n",out[i]);
	}
	
	return 0;
}
```

---

## 作者：zhengchenxi414 (赞：0)

这里主要是了解一下套路，首先说一下树的直径的性质。

- 1.任何一个点到它所在的联通块中距离最远的点一定是树的直径两点之一。

- 2.两个连通块合并以后，新的树的直径一定为原先两个连通块中树的直径中的两个。


---


了解完这个，我们来看这道题，根据树的直径的性质，我们可以来维护连通块，那一个难点就是删边很难处理，但它是离线操作，我们就可以考虑时光倒流，倒着处理，把删边改为加边。

维护连通性，我们就可以用并查集，然后再不断合并即可。




```cpp
#include<bits/stdc++.h>
using namespace std;


#define int long long
const int N=5e5+10;
int n,m;


int read()
{
	int f=1,s=0;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=(s<<1)+(s<<3)+(ch^48);ch=getchar();}
	return f*s;
} 

int fa[N],s[N][2];
struct lmy
{
	int x,y,z;
}e[N];

int h[N],nxt[N<<1],to[N<<1],w[N<<1],tot;
void add(int x,int y,int dt)
{
	to[++tot]=y;
	nxt[tot]=h[x];
	w[tot]=dt;
	h[x]=tot;
}

int f[N][25],dep[N],dis[N];
void dfs(int u,int fat)
{
	dep[u]=dep[fat]+1,f[u][0]=fat;
	for(int i=1;i<24;++i) f[u][i]=f[f[u][i-1]][i-1];
	
	for(int i=h[u];i;i=nxt[i])
	{
		int v=to[i];
		if(v==fat) continue;
		dis[v]=dis[u]+w[i];
		dfs(v,u);
	}
	return ;
}

int lca(int x,int y)
{
	if(dep[x]<dep[y]) swap(x,y);
	
	for(int i=23;i>=0;i--) if(dep[f[x][i]]>=dep[y]) x=f[x][i];
	if(x==y) return x;
	
	for(int i=23;i>=0;i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}

int get(int a,int b){return dis[a]+dis[b]-2*dis[lca(a,b)];}

int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}

int ans[N],nowmax;
int Mx[N];
void merge(int x,int y)
{
	fa[y]=x;
	int maxx=0;
	int now[10]={s[x][0],s[x][1],s[y][0],s[y][1]};
	for(int i=0;i<4;i++)
	{
		for(int j=0;j<4;j++)
		{
			int nowx=now[i],nowy=now[j];
			int dis=get(nowx,nowy);
			if(dis>maxx)
			{
				maxx=dis,s[x][0]=nowx,s[x][1]=nowy;
				Mx[x]=dis;
			}
		}	
	}
	
	nowmax=max(nowmax,Mx[x]);
	return ;
}

int d[N],vis[N];
void solve()
{
	n=read(),m=read(),tot=0,nowmax=0;
	for(int i=1;i<=n;i++)
	{
		fa[i]=i,s[i][0]=s[i][1]=i;
		h[i]=dep[i]=dis[i]=0;
		ans[i]=0,Mx[i]=0;
		for(int j=0;j<=24;++j) f[i][j]=0;
		vis[i]=0;
	}
	for(int i=1;i<=n-1;i++)
	{
		int a=read(),b=read(),dt=read();
		add(a,b,dt),add(b,a,dt);
		e[i]={a,b,dt};
	}
	dfs(1,0);
	for(int i=1;i<=m;++i) d[i]=read(),vis[d[i]]=1;
	
	for(int i=1;i<n;++i)
	{
		if(vis[i]) continue;
		int x=e[i].x,y=e[i].y;
		if(dep[x]>dep[y]) swap(x,y);
		merge(find(x),find(y));
	}
	for(int i=m;i>=1;i--)
	{
		int x=e[d[i]].x,y=e[d[i]].y;
		if(dep[x]>dep[y]) swap(x,y);
		ans[i]=nowmax;
		merge(find(x),find(y));
	}
	for(int i=1;i<=m;++i) cout<<ans[i]<<"\n";
	return ;
}

signed main()
{
	int t=read();
	while(t--)
	{
		solve();
	}
	
	return 0;
}
```

---


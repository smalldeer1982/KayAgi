# 说唱

## 题目背景

在题目描述末尾有形式化题意。

## 题目描述

ZHY 在一个空旷的房间里练习说唱。

ZHY 初始时会发出一个强度为 $x$ 的声音，这个声音会与墙壁发生碰撞，产生一个强度为 $\lfloor \frac x {10} \rfloor$ 的回声。回声会继续与墙壁碰撞，产生回声的回声……直到这个回声的强度为 $0$。

房间里还有一个收音机，它会记录下来所有的声音（包括初始发出的声音和所有回声）。可惜，ZHY 一不小心把收音机弄坏了。现在，收音机只能显示出记录下的所有声音的强度之和 $y$，你能通过这个仅有的信息计算出 ZHY 初始发出的声音的强度是多少吗？由于收音机太过古老，可能会出现一些故障导致显示的数有误。对于这种情况，你需要输出 $-1$。

**形式化题意**

如下定义一个函数：

$$f(x)=\begin{cases} 0 & x = 0 \\ x+f(\lfloor\frac{x}{10}\rfloor) & x > 0 \end{cases}$$

比如 $f(123)=123+12+1=136$。

给定一个数 $y$，请求出是否存在唯一的一个数 $x$ 满足 $f(x)=y$，如果有则输出 $x$，否则输出 $-1$。

## 说明/提示

| $\mathrm{Subtask} \kern{2pt} \mathrm{id}$ | $y$ | 特殊性质 |分值 |
| :-----: | :-----: | :-----: | :-----: |
| $1$ | $< 1000$ | 无 | $10$ |
| $2$ | $< 10^6$ | 无 | $15$ |
| $3$ | $< 10^{100000}$ | $S\le 9$ | $10$ |
| $4$ | $< 10^{100000}$ | $S\le 10$ | $20$ |
| $5$ | $< 10^{3000}$ | 无 | $15$ |
| $6$ | $< 10^{500000}$ | 无 | $30$ |

特殊性质一栏中，$S\le k$ 表示“若有解，$x$ 中所有位的数字和不超过 $k$”。

对于 $100\%$ 的数据，$1\le T\le 10$，$0 \le y < 10^{500000}$。

## 样例 #1

### 输入

```
2
12
136```

### 输出

```
11
123```

## 样例 #2

### 输入

```
3
10
123
7510```

### 输出

```
-1
111
6761```

# 题解

## 作者：Mortidesperatslav (赞：36)

绝世好题。

赛时写了 $55$ 分，赛后听了讲评过了这题，但感觉讲评讲的太简单了，打算写一篇题解细说。

## 算法 1 25 pts

我会暴力！

暴力枚举 $y$。因为 $x$ 一定不大于 $y$，时间复杂度 $O(Ty)$。

为什么 $x$ 不大于 $y$？

因为考虑到 $\lfloor \dfrac{x}{10} \rfloor \geq 0$，所以 $f(x) \geq x$。题目要求 $f(x) = y$，则有 $y \geq x$。

## 算法 2 35 pts

这是我场上想到的。

因为 $S < 9$，我们首先可以想到假设 $x_i$ 表示 $x$ 从左往右的第 $i$ 位，则 $\displaystyle{\sum_{i=1}^{n}x_i \leq 9}$。然后这就意味着 $y$ 可以分为最多 $10$ 段，每段的所有数都相同，并且 `unique` 去重后递增。

看不懂的话，给一个例子：首先没保证没前导零，那么最极端有类似 $y = 0000111223334445566666677788899$ 的情况，这个时候 $x = 100101001001010000010010010$。

我们记 $a_i$ 表示 $x$ 从左往右第 $i$ 个不为 $0$ 的位的值。那么 $y$ 去掉前导零后，从左往右一定是 $a_1,a_1,\cdots,a_1 + a_2,\cdots,a_1+a_2+a_3,\cdots \displaystyle{\sum_{i = 0}^{k}a_i}$。

$k$ 就是 $y$ 可以分的段数。

或者是我们可以把 $y$ 进行整理，例如 $111223334$ 整理得到 $y = 111111111+111111+1111+1$，会发现每一项都是一个数的重复，每一项重复的数恰巧就是上面讲的 $a_i$！

注意，上面这个很重要，正解就是这玩意。

先放这一部分代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int x, y, ans[100005];
string st;
int f(int x) {
	if (!x)
		return 0;
	return x + f(x / 10);
}
int sti(string x) {
	int res = 0;
	for (int i = 0; i < x.size(); i++)
		res = res * 10 + (x[i] - '0');
	return res;
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> t;
	while (t--) {
		cin >> st;
		if (st.size() > 9) {
			int cnt = 0;
			ans[++cnt] = st[0] - '0';
			for (int i = 1; i < st.size(); i++)
				if (st[i] != st[i - 1])
					ans[++cnt] = st[i] - '0';
			bool r = 1;
			for (int i = 1; i <= cnt; i++)
				if(ans[i] < ans[i - 1])
					r = 0;
			if (!r) {
				cout << "-1\n";
				continue;
			}
			int ns = ans[1];
			if (ns != 0)
				cout << ans[1];
			for (int i = 1; i < st.size(); i++) {
				if (st[i] == 0)
					continue;
				if (st[i] != st[i - 1]) {
					cout << st[i] - '0' - ns;
					ns = st[i] - '0';
				} else
					cout << st[i] - '0' - ns;
			}
			cout << "\n";
		}
		if (st.size() <= 9) {
			y = sti(st);
			int r = 0;
			x = -1;
			for (int i = 0; i <= y; i++) {
				if (f(i) == y) {
					if (x == -1)
						x = i;
					else
						r = 1;
				}
			}
			if (r == 1)
				cout << "-1\n";
			else
				cout << x << "\n";
		}
	}
}
```

## 算法 3 55pts

可能可以 dfs/bfs 搜出来吧。但是我没写。

我相信玄学。

我没看出来我的代码是怎么做到 $55$ 的。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int x, y;
int f(int x){
	if (!x)
		return 0;
	return x + f(x / 10);
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin >> t;
	while (t--){
		cin >> y;
		int r = 0;
		x = -1;
		for (int i = 0; i <= y; i++){
			if (f(i) == y){
				if (x == -1)
					x = i;
				else
					r = 1;
			}
		}
		if (r == 1)
			cout << "-1\n";
		else
			cout << x << "\n";
	}
}
```

## 算法 4 70pts

我们考虑到算法 2 中那个变形。

$\lfloor \dfrac{x}{10}\rfloor$ 实际上是十进制右移，于是那个变形得以推广。

我们会发现，这构成了一个等比数列。

一个数 $x$ 重复 $k$ 次就是 $x + 10x +\dots +10^{k-1}x$。

我们发现，这构成了一个等比数列。

我们知道，等比数列有求和公式。如果不会，可以参考赵思林老师的《初等代数研究》（一本好书）或者直接翻人教 A 版选修二第一章（如果课本重修了请联系我）。

**下面我们的原数用 $X$ 表示。**

反正公式是 $S_n = \dfrac{a_1(1 - q^n)}{1-q}$。

$q$ 为公比， $a_1$ 为首项，$S_n$ 为前 $n$ 项和。

因为我们知道了 $q = 10$ 所以 $S_n = \dfrac{a_1(1-10^n)}{-9}$。

我们用一下分配律：$S_n = \dfrac{a_1-10^na_1}{-9}$。

分子和分母同时乘上 $-1$ 得 $S_n = \dfrac{10^n a_1 - a_1}{9}$。

把 $n = k, a_1 = x$ 代进去得到 $S_n = \dfrac{10^kx-x}{9}$。然后这只是其中的一项，我们把每一项加起来。

把所有的 $-x$ 加起来就是数字根（意思就是一个数每一位加起来的和）的相反数 $-S$。

把所有的 $10^kx$ 加起来得到 $10X$。因为原来从右往左第 $i$ 位在 $10^{i-1}$ 量级。没错吧。

那么得到 $f(x) = \dfrac{10X - S}{9}$。也就是 $9y=10X-S$。

然后就好写了。我们考虑从 $9y$ 开始枚举 $10X$。因为 $X$ 为整数，我们只要枚举 $10$ 的倍数。

因为 $10X-9y$ 每次加 $10$，每次把 $10X$ 加上 $10$ 只要边进位边维护 $S$ 即可，所以空间复杂度是 $O(\log_{10}y)$。这里为了更直观，把底数写上了。下面底数都为 $10$。我就省略了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int x, y;
string st;
int ans[514514];
int f(int x) {
	if (!x)
		return 0;
	return x + f(x / 10);
}
int sti(string x) {
	int res = 0;
	for (int i = 0; i < x.size(); i++)
		res = res * 10 + (x[i] - '0');
	return res;
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> t;
	while (t--) {
		cin >> st;
		if (st == "0"){
			cout << st << "\n";
			continue;
		}
		int n = st.size(), fnd = 0;
		for (int i = n; i <= n + 10; i++)
			ans[i] = 0;
		for (int i = 1; i <= n; i++)
			ans[i] = st[i - 1] - '0';
		for (int i = 1; i <= n / 2; i++)
			swap(ans[i], ans[n - i + 1]);
		int jw = 0;
		for (int i = 1; i <= n; i++) {
			ans[i] = (ans[i] - jw) * 9 + jw;
			ans[i + 1] += ans[i] / 10;
			jw = ans[i] / 10;
			ans[i] %= 10;
			if (ans[n + 1])
				n++;
		}
		long long sum = 0, cha = 0;
		while (ans[1] != 0) {
			ans[1] ++;
			ans[2] += ans[1] / 10;
			ans[1] %= 10;
			cha++;
		}
		for (int i = 1; i <= n; i++)
			if (ans[i] >= 10) {
				ans[i + 1] += ans[i] / 10;
				ans[i] %= 10;
			}
		for (int i = 1; i <= n; i++)
			sum += ans[i];
		if (sum == cha) {
			bool qd = 0;
			for (int i = n; i >= 2; i--) {
				if (ans[i] != 0)
					qd = 1;
				if (ans[i] != 0 || qd == 1)
					cout << ans[i];
			}
			fnd = 1;
			cout << "\n";
			continue;
		}
		while (1) {
			if (cha > 9 * n)
				break;
			cha += 10;
			sum++;
			ans[2]++;
			for (int i = 2; i <= n; i++)
				if (ans[i] >= 10) {
					sum -= 9;
					ans[i] %= 10;
					ans[i + 1] ++;
				}
			//	cout << "\n:::\n";
			//	cout << cha << " " << sum << "\n\n\n";
			if (sum == cha) {
				bool qd = 0;
				for (int i = n; i >= 2; i--) {
					if (ans[i] != 0)
						qd = 1;
					if (ans[i] != 0 || qd == 1)
						cout << ans[i];
				}
				fnd = 1;
				cout << "\n";
				break;
			}
		}
		if (!fnd)
			cout << "-1\n";
	}
}
```

TLE 了， $70$ 分。为什么呢？

因为进位要扫一遍，实际上这样是 $O(T\log^2y)$ 的。我们知道 $\log y$ 在 $5 \times 10^5$ 左右，于是过不了。

## 最终算法 100pts

考虑到进位没必要扫一遍，我们只要不断进位，直到特定的一位没法进位了我们就不用进位了。

加上这个优化就变成了 $O(T\log y)$，当然可以通过。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int x, y;
string st;
int ans[514514];
int f(int x) {
	if (!x)
		return 0;
	return x + f(x / 10);
}
int sti(string x) {
	int res = 0;
	for (int i = 0; i < x.size(); i++)
		res = res * 10 + (x[i] - '0');
	return res;
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> t;
	while (t--) {
		cin >> st;
		if (st == "0"){
			cout << st << "\n";
			continue;
		}
		int n = st.size(), fnd = 0;
		for (int i = n; i <= n + 10; i++)
			ans[i] = 0;
		for (int i = 1; i <= n; i++)
			ans[i] = st[i - 1] - '0';
		for (int i = 1; i <= n / 2; i++)
			swap(ans[i], ans[n - i + 1]);
		int jw = 0;
		for (int i = 1; i <= n; i++) {
			ans[i] = (ans[i] - jw) * 9 + jw;
			ans[i + 1] += ans[i] / 10;
			jw = ans[i] / 10;
			ans[i] %= 10;
			if (ans[n + 1])
				n++;
		}
		long long sum = 0, cha = 0;
		while (ans[1] != 0) {
			ans[1] ++;
			ans[2] += ans[1] / 10;
			ans[1] %= 10;
			cha++;
		}
		for (int i = 1; i <= n; i++)
			if (ans[i] >= 10) {
				ans[i + 1] += ans[i] / 10;
				ans[i] %= 10;
			}
		for (int i = 1; i <= n; i++)
			sum += ans[i];
		if (sum == cha) {
			bool qd = 0;
			for (int i = n; i >= 2; i--) {
				if (ans[i] != 0)
					qd = 1;
				if (ans[i] != 0 || qd == 1)
					cout << ans[i];
			}
			fnd = 1;
			cout << "\n";
			continue;
		}
		while (1) {
			if (cha > 9 * n)
				break;
			cha += 10;
			sum++;
			ans[2]++;
			int i = 2;
			while (ans[i] >= 10) {
				sum -= 9;
				ans[i] %= 10;
				ans[i + 1] ++;
				i++;
			}
			if (sum == cha) {
				bool qd = 0;
				for (int i = n; i >= 2; i--) {
					if (ans[i] != 0)
						qd = 1;
					if (ans[i] != 0 || qd == 1)
						cout << ans[i];
				}
				fnd = 1;
				cout << "\n";
				break;
			}
		}
		if (!fnd)
			cout << "-1\n";
	}
}
```

## 一些其他的话

写了那么多，求管理通过，求大家点赞。

我写 $\LaTeX$ 的时候一直把“floor”写成“florr”，警示后人。

通过记录 rid 为 $151541554$，真吉利。

---

## 作者：STUDENT00 (赞：10)

赛时没做出蓝色 T1，充分论证了我的无知弱小。

emem，切入正题。

$f(x)=\sum\limits_{i=0} \lfloor \frac{x}{10^i}\rfloor$。

颜值为 $0$，需要整形。

为方便整形，不妨设 $x=123$。$f(123)=123+12+1=111+22+3=1\times 111+2\times 11+3\times 1$。

$k$ 位数 $\overline{111...111}=\frac{10^k-1}{9}$。

$P(x)$ 表示 $x$ 的各位数之和，则 $f(x)=\frac{10x-P(x)}{9}$。

颜值为 $100$，整形成功。

问题：已知 $y=f(x)$，求 $x$。

$f(x)$ 单增，因此如果有解，一定是唯一解，我们只需判定是否有解即可。

移项后得 $P(x)=10x-9y$。$L(x)$ 表示 $x$ 的位数，则  $P(x)\le9L(x)\le9L(y)$。

我们枚举 $10x$，判断 $P(x)$ 是否 $=10x-9y$ 即可。枚举范围：$9y\le 10x\le 9(y+L(y))$。

具体步骤：

一、令 $X=9y$，不断 $X+1$，直到 $X$ 为 $10$ 倍数。

二、重复 $L(y)$ 次，每次执行：

1. 判断 $X-9y$ 是否 $=P(\frac{X}{10})$，是则输出 $\frac{X}{10}$，不是则正常运行。

2. $X+10$。

时复分析：$P(\frac{X}{10})$ 可 $O(n)$ 求初值，在高进度加法时 $O(1)$ 更新值。对 $X$ 进行 $L(y)$ 次 $+10$ 操作，第 $i$ 位（第 $0$ 位表示十位）最多更值 $\lfloor\frac{L(y)}{10^i}\rfloor+1$ 次，$\sum\limits_{i=0} (\lfloor\frac{L(y)}{10^i}\rfloor+1)$ 是 $O(n)$ 的。

综上，本算法时复 $O(Tn)$，可过题。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=500005;
int T;
int n;
char sa[N];
int A[N];
//int B[N],m;
int cnt;
void times(){
	for(int i=0;i<n;i++) A[i]*=9;
	for(int i=0;i<n;i++) A[i+1]+=A[i]/10,A[i]%=10;
	if(A[n]) n++;
}
void rem(int x){
	for(;A[x]>9;x++) A[x+1]++,A[x]-=10,cnt-=9;
	if(A[n]) n++;
}
int main(){
	scanf("%d",&T);
	while(T--){
		memset(A,0,sizeof(A));
		scanf("%s",sa);
		n=strlen(sa);
		for(int i=0;i<n;i++) A[i]=(sa[n-i-1]^48);
		times();
		int d=0;
		if(A[0]) d=10-A[0],A[0]=10,rem(0);
		cnt=0;
		for(int i=0;i<n;i++) cnt+=A[i];
		int flag=1;
		for(int i=0;i<n;i++){
			if(cnt==d){
				if(n^1) for(int i=n-1;i>0;i--) putchar(A[i]^48);
				else putchar(48);
				puts("");flag=0;break;
			}
			d+=10,A[1]++,cnt++,rem(1);
		}
		if(flag) puts("-1");
	}
	return 0;
}
```

---

## 作者：wkh2008 (赞：10)

设 $x=\overline{x_1x_2\cdots x_n}$，考虑 $x$ 每一位的贡献，有：

$$y = \sum\limits_{i=1}^n{(x_i\cdot\dfrac{10^{n-i+1} - 1}{9})} = \dfrac{10x-\sum\limits_{i=1}^n{x_i}}{9}$$

令 $x$ 各数位之和 $\sum\limits_{i=1}^n{x_i}=S_x$，易知 $S_x \le 9n$，所以我们枚举 $S_x$，判断 $9y+S_x$ 是否满足被 $10$ 整除且各数位之和为 $S_x$ 即可。

需要实现高精加/乘低精，计算时统一加/乘后再推平（转换为合法十进制数），记录当前的增量 $D$ 来更新 $S_x$，复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using vi = vector<int>;

inline istream & operator>>(istream & S, vi & a) { string s; S >> s; for (auto it = s.rbegin(); it != s.rend(); ++it) a.push_back(*it - '0'); return S; }
inline ostream & operator<<(ostream & S, const vi & a) { for (auto it = a.rbegin(); it != a.rend(); ++it) S << *it; return S; }

int D;

signed main() {
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    auto assign = [](auto & v, bool f) {
        for (size_t i = 0; i + 1 < v.size() && (v[i] > 9) | f; i++)
            if (v[i] > 9) {
                D += v[i] / 10, v[i + 1] += v[i] / 10;
                D += v[i] % 10 - v[i], v[i] %= 10;
            }
        while (v.back() > 9) {
            D += v.back() / 10, v.push_back(v.back() / 10);
            D += v[v.size() - 2] % 10 - v[v.size() - 2], v[v.size() - 2] %= 10;
        }
    };
    auto mul = [&assign](auto & v, int x) { for (auto & _ : v) _ *= x; assign(v, 1); };
    auto add = [&assign](auto & v, int x) { v[0] += x; D = x; assign(v, 0); };
    int T; cin >> T;
    while (T--) {
        vi y; cin >> y;
        if (y.size() == 1 && !y.back()) { cout << 0 << '\n'; continue; }
        mul(y, 9);
        vi x = y;
        int Sx = 0; for (auto & _ : x) Sx += _;
        bool ok = 0;
        for (int s = 1; s <= 5e6; s++) {
            add(x, 1), Sx += D;
            if (!x[0] && Sx == s) {
                x.erase(x.begin()), cout << x << '\n';
                ok = 1; break;
            }
        } if (!ok) cout << -1 << '\n';
    }
    return 0;
}
```

---

## 作者：operator_ (赞：3)

# P10253 说唱

[题目传送门](https://www.luogu.com.cn/problem/P10253)

## 题解

先看子任务 $3,4$ 怎么做。如果用 $a_i$ 表示 $x$ 的第 $i$ 位，即 $x=\sum a_i\times 10^i$，则 $f(x)=\sum a_i\times \dfrac{10^{i+1}-1}{9}$，因此 $f(x)=\dfrac{10x-\sum a_i}{9}$。我们记 $num(x)$ 表示 $x$ 的数字和。那么对于子任务 $3,4$，我们枚举 $num(x)$，再根据 $x=\dfrac{9y+num(x)}{10}$ 算出 $x$ 并检验即可。

如果没有这个 $S$ 的限定呢？发现 $x\le y$，故 $0\le num(x)\le 9\times500000$，所以有 $\dfrac{9}{10}y\le x\le \dfrac{9}{10}y+450000$（取整的相关细节省略），不妨把枚举 $x$ 的过程考虑成不断 $+1$。

然后其实就做完了，复杂度是正确的，~~但本人没想到~~，所以法 $2$：

更进一步，因为 $450000<1000000$，所以在整个不断 $+1$ 的过程中，在第 $6$ 位上最多只会进位一次，换句话说，从第 $7$ 位开始的不同数字和最多只有 $2$ 种，而第 $7$ 位以下最多只有 $55$ 种，总共是大约 $110$ 种不同数字和。这样依然不能过，但是你发现合法的数字和必须满足 $9y+num(x)$ 是 $10$ 的倍数，而这 $110$ 种数字和可以分为两个连续段，因此其中的合法数字和最多只有 $12$ 种，对这 $12$ 个数字和都检验一遍即可。

这样做可以过，不过常数较大。

---

## 作者：Erine (赞：1)

形式化之。记 $x=\sum_{i} x_i10^i$，其中 $0\le x_i\le 9$。那么很显然，

$$
\begin{aligned}
y&=\sum_{i=0}\dfrac{x_i10^{i+1}-1}9 \\
9y&=10x-\sum_{i=0} x_i \\
9y+\sum_{i=0} x_i&=10x
\end{aligned}
$$

枚举 $\sum x_i$。然后我们可以得到一个所谓的 $x$，这个时候我们 check $x$ 的数位和是否和我们枚举的相同。从小到大枚举，那么每次相当于 $+1$。暴力进位并且更新 $x$ 的数位和即可。

可以证明复杂度是线性的。

---

## 作者：Exp10re (赞：1)

有趣题。

## 解题思路

注意到 $y$ 的值可以由以下方式表达：

以 $x=12345$ 为例：

$
\begin{aligned}
&y=10^4 \times (1) \\
&+10^3 \times (2+\color{red}1\color{black})\\
&+10^2 \times (3+\color{red}2+1\color{black})\\
&+10^1 \times (4+\color{red}3+2+1\color{black})\\
&+10^0 \times (5+\color{red}4+3+2+1\color{black})\\
\end{aligned}
$  

如果我们能得到红色部分的值，然后用 $y$ 减去它，那么剩下的黑色部分的和就是 $x$ 的值了。

记红色部分的值为 $k$，那么有：

- $y-k=x$。
- $\begin{aligned}
&k=10^3 \times (1)  \\
&+10^2 \times (2+1)  \\
&+10^1 \times (3+2+1)  \\
&+10^0 \times (4+3+2+1)\end{aligned}$  

注意到 $k$ 的表达形式和 $\lfloor \frac y {10} \rfloor$ 是很像的，那么算出 $y-\lfloor \frac y {10} \rfloor$ 就能算出 $x$ 的值了……吗？

计算 $\frac y {10}-k$ 的时候注意到这个值不为 $0$，也就是说不保证 $\frac y {10}=k$。

考虑其原因，发现计算 $\lfloor \frac y {10} \rfloor$ 的时候会额外计算到个位数部分的进位，即 $\lfloor \frac y {10} \rfloor-k=\lfloor \frac {\operatorname{cnt}(x)} {10} \rfloor$，其中 $\operatorname{cnt}(x)$ 表示 $x$ 各数位之和。

在题目的限制中，这个 $\lfloor \frac {\operatorname{cnt}(x)} {10} \rfloor$ 不会超过 $0.9\times \lg x$，又有 $\lg x \lt \lg y$，则记 $p=x-(y-\lfloor \frac y {10} \rfloor)$，有 $0\leq p\leq 0.9\times\lg x\lt 0.9\times\lg y$。

一个朴素的思路是在 $0\leq p\lt 0.9\times\lg y$ 的范围内枚举 $p$，逐个判断 $f(y-\lfloor \frac y {10} \rfloor+p)$ 是否等于 $y$，如果是，那么 $x=y-\lfloor \frac y {10} \rfloor+p$。

------------

- 如何快速计算 $f(x)$？

$f(x)$ 的 $k$ 次项的系数为 $x$ 后 $m-k+1$ 项的后缀和（$m$ 为 $x$ 的位数），计算系数然后处理进位即可。

建议看代码。

------------

但这样单次询问时间复杂度 $O(\lg^2 y)$，会超时。

注意到 $f(x)=y$ 单调递增，因此枚举的过程可以用二分。

记 $n=\lg y$，时间复杂度 $O(Tn\log n)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long MAXN=501000;
long long a[MAXN],n,ans[MAXN],b[MAXN],c[MAXN];
char s[MAXN];
void add(long long k)//计算 y-y/10+k 
{
	b[1]=c[1]+k;
	ans[1]=0;
	long long i;
	for(i=2;i<=n+10;i++)
	{
		b[i]=c[i];
	}
	for(i=1;i<=n+10;i++)
	{
		b[i+1]+=b[i]/10;
		b[i]%=10;
	}
	return;
}
void getdec()//计算 y-y/10 
{
	long long i;
	for(i=1;i<n;i++)
	{
		c[i]=a[i]-a[i+1];
	}
	c[n]=a[n];
	for(i=1;i<=n;i++)
	{
		while(c[i]<0)
		{
			c[i]+=10;
			c[i+1]--;
		}
	}
	return;
}
long long checksame()//判断 f(y-y/10+p) 是否为 y 
{
	long long k=0,i;
	for(i=n+10;i>=1;i--)
	{
		k+=b[i];
		ans[i]=k;
	}
	for(i=1;i<=n+10;i++)
	{
		ans[i+1]+=ans[i]/10;
		ans[i]%=10;
	}
	k=n+10;
	for(k=n+10;k>=1;k--)
	{
		if(ans[k]!=0)
		{
			break;
		}
	}
	if(k>n)
	{
		return 1;
	}
	if(k<n)
	{
		return -1;
	}
	for(i=n;i>=1;i--)
	{
		if(ans[i]!=a[i])
		{
			if(ans[i]>a[i])
			{
				return 1;
			}
			else
			{
				return -1;
			}
		}
	}
	return 0;
}
void work()
{
	long long i,j,k;
	scanf("\n%s",s+1);
	n=k=strlen(s+1);
	for(i=1;i<=n;i++)
	{
		a[n-i+1]=s[i]-'0';
		b[i]=c[i]=ans[i]=0;
	}
	for(i=n+1;i<=n+100;i++)
	{
		a[i]=0;
		b[i]=c[i]=ans[i]=0;
	}
	if(n==1&&a[1]==0)
	{
		printf("0\n");
		return;
	}
	getdec();
	long long l=0,r=n*0.9,mid;
	while(l<=r)//二分 
	{
		mid=(l+r)/2;
		add(mid);
		k=checksame();
		if(k==0)
		{
			k=n;
			for(i=k;i>=1;i--)
			{
				if(b[i]!=0)
				{
					break;
				}
			}
			for(;i>=1;i--)
			{
				printf("%lld",b[i]);
			}
			printf("\n");
			return;
		}
		else if(k==1)
		{
			r=mid-1;
		}
		else
		{
			l=mid+1;
		}
	}
	printf("-1\n");
	return;
	{
		for(i=k;i>=1;i--)
		{
			if(ans[i]!=0)
			{
				break;
			}
		}
		for(;i>=1;i--)
		{
			printf("%lld",ans[i]);
		}
		printf("\n");
	}
	return;
}
int main()
{
	long long T;
	scanf("%lld",&T);
	while(T--)
	{
		work();
	}
	return 0;
}
```

---

## 作者：xiaosi4081 (赞：1)

## 说唱 题解

不妨转化 $f(x)$。

找一下规律。$f(1234)=1234+123+12+1$，可以发现 $1$ 在千位到个位都出现了一次，$2$ 在百位到个位都出现了一次，$3$ 在十位和百位各出现了一次，$4$ 在个位上出现了一次。所以 $f(1234)$ 又等于 $1111+222+33+4$。

那么可以按位计算贡献。显然 $x$ 中从右到左第 $i$ 位在 $f(x)$ 中的贡献为 $\underbrace{\overline{x_ix_i\cdots x_i}}_{共i个
}=x_i+10x_i+\cdots+10^{i-1}x_i$，善用等比数列求和公式可得其贡献为 $\dfrac{10^{i+1}x_i-x_i}{10-1}$。

对所有位的贡献求和的结果即为 $f(x)$。可以发现 $\sum_{10^i\leq x}10^{i+1}x_i = 10x$。设每一位上的数字的和为 $s$ 也就是 $\sum x_i$。自然就有 $f(x)= \dfrac {10x-s}{9}$。

将 $f(x)=y$ 中的 $f(x)$ 替换，可得 $\dfrac {10x-s} 9 = y $ 也就是 $10x=9y+s$。根据将一个数乘以 $10$ 相当于在这个数后面加一个 $0$ 的性质，可以知道 $10x$ 的数位和与 $x$ 的数位和相等。

设 $n$ 为 $y$ 的位数。由于 $s$ 最多不会超过 $9n$（在很多情况下根本不可能达到 $9n$），所以我们可以暴力枚举 $s$，然后判断 $9y+s$ 的数位和是否等于 $s$ 且 $9y+s$ 是否是 $10$ 的倍数即可，如果满足上述条件，答案即为 $\dfrac {9y+s} {10}$。

我们来想想怎么实现，我们可以先将 $y$ 直接乘以 $9$，再加到第一个 $10$ 的倍数，然后枚举的过程中不断加 $10$ 即可。

高精度实现即可。注意细节如下：

1. 注意一下加法操作的时间复杂度

温馨提示：如果本地测试不断返回一个极大值，可能是本地结构体内不能开那么大的数组。

代码如下：

```c++
#include<bits/stdc++.h>
using namespace std;
int t;
struct Bignum{
	int w,c[1000005],h;
	void init(int siz){
		for(int i=1;i<=siz;i++)c[i]=0;
		w=0;h=0;
	}
	void print(char x=' ',int mode=1){
		for(int i=w;i>=mode;i--){
			cout<<c[i];
		}
		cout<<x;
	}
	Bignum times(int n){
		Bignum ans;
		ans.w=w;
		for(int i=1;i<=w;i++)ans.c[i]=c[i];
		int k=0,lst=0,htmp=h;
		for(int i=1;i<=ans.w;i++){
			lst=ans.c[i];
			ans.c[i]=ans.c[i]*n+k;
			k=ans.c[i]/10;
			ans.c[i]%=10;
			htmp+=ans.c[i]-lst;
		}
		if(k){
			++ans.w;
			for(;k;ans.w++){
				ans.c[ans.w]=0; 
				htmp+=k%10;
				ans.c[ans.w]=k%10;
				k/=10;
			}
			--ans.w;
		}
		ans.h=htmp;
		return ans;
	}
	Bignum plus(int x){
		Bignum ans;
		ans.w=w;
		for(int i=1;i<=w;i++)ans.c[i]=c[i];
		int k=0,lst=0,htmp=h;
		htmp-=ans.c[1];	
		ans.c[1]+=x;
		k+=ans.c[1]/10;
		ans.c[1]%=10;
		htmp+=ans.c[1];
		for(int i=2;i<=ans.w;i++){
			if(k==0)break; 
			lst=ans.c[i];
			ans.c[i]+=k;
			k=ans.c[i]/10;
			ans.c[i]%=10;
			htmp+=ans.c[i]-lst;
		}
		if(k){
			++ans.w;
			for(;k;ans.w++){
				ans.c[ans.w]=0; 
				htmp+=k%10;
				ans.c[ans.w]=k%10;
				k/=10;
			}
			--ans.w;
		}
		ans.h=htmp;
		return ans; 
	}
	void plusd(int x){
		int k=0,lst=0,htmp=h;
		htmp-=c[1];
		c[1]+=x;
		k+=c[1]/10;
		c[1]%=10;
		htmp+=c[1];
		for(int i=2;i<=w;i++){
			if(k==0)break; 
			lst=c[i];
			c[i]+=k;
			k=c[i]/10;
			c[i]%=10;
			htmp+=c[i]-lst;
		}
		if(k){
			++w;
			for(;k;w++){
				c[w]=0; 
				htmp+=k%10;
				c[w]=k%10;
				k/=10;
			}
			--w;
		}
		h=htmp;
	}
	void input(){
		w=h=0;
		char ch;ch=getchar();
		while(!isdigit(ch))ch=getchar();
		while(isdigit(ch)){
			c[++w]=ch-'0';
			h+=c[w];
			ch=getchar();
		}
		for(int i=1;2*i<=w;i++){
			swap(c[i],c[w-i+1]);
		}
	}
};
int main(){
	cin>>t;
	Bignum y;
	while(t--){
		y.input();
		int length=y.w;
		if(y.c[1]==0&&length==1){
			cout<<0<<endl;
			continue;
		}
		y=y.times(9);
		int addict=0;
		while(y.c[1]!=0){
			y.plusd(1);
			++addict;
		}
		if(y.h==addict){
			y.print('\n',2);
		}
		else{
			addict+=10;int flag=0;
			for(;addict<=9*length;addict+=10){
				y.plusd(10);
				if(y.h==addict){
					y.print('\n',2);
					flag=1;
					break; 
				}
			}
			if(!flag){
				cout<<-1<<'\n';
			}
		}
	}
	return 0;
}
```

---

## 作者：diqiuyi (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10253)。

本人赛时使用了 $O(\log^2{y})$ 计算数位和的方法，还没有意识到，喜提 TLE。

考虑拆位算贡献，发现 $x$ 十进制下表示 $10^i$ 的数位 $a_i$ 对 $f(x)$ 的贡献为 $\dfrac{10^{i+1}-1}{9}$。稍作移项可得 $10x-s(x)=9y$，其中 $s(x)$ 表示 $x$ 在十进制下的数位和。

发现 $10x-s(x)$ 是单调递增的。也就是说如果有解，那么解的个数必然为 $1$。考虑二分答案，然后暴力判断是否满足条件。但是因为高精度加法、高精度乘低精度都是 $O(\log{y})$ 的，所以这么做是 $O(\log^2{y})$ 的。

考虑优化。发现显然有 $\dfrac{9}{10y} \le x \le y$，但是这个范围还是太大了。不过注意到 $s(x)$ 是 $\log{n}$ 级别的。显然 $x=\dfrac{s(x)+9y}{10} \le\dfrac{4500000+9y}{10}$。这样的话我们二分区间的长度只有 $O(\log{y})$ 了。

总的时间复杂度是 $O(\log{y}\log\log{y})$，但是有点卡常，要写压位高精。

**CODE**
```cpp
#include <bits/stdc++.h>
#define ull unsigned long long
#define uint unsigned int
#define pii pair<int,int>
using namespace std;
const int md=9,bas=1e8;
int t;
struct bg{
	int a[70005],len;
	friend bg operator +(bg x,bg y){
		x.len=max(x.len,y.len);
		x.a[x.len]=0;
		for(int i=0;i<x.len;i++)
			x.a[i]+=y.a[i],x.a[i+1]+=x.a[i]/bas,x.a[i]%=bas;
		if(x.a[x.len]) x.len++;
		while(x.len>1&&!x.a[x.len-1]) x.len--;
		return x;
	}
	friend bool operator <(bg x,bg y){
		if(x.len<y.len) return 1;
		for(int i=x.len-1;~i;i--)
			if(x.a[i]>y.a[i]) return 0;
			else if(x.a[i]<y.a[i]) return 1;
		return 0;
	}
	friend bool operator ==(bg x,bg y){
		if(x.len^y.len) return 0;
		for(int i=0;i<x.len;i++)
			if(x.a[i]^y.a[i])
				return 0;
		return 1;
	}
	friend bool operator <=(bg x,bg y){
		return !(y<x);
	}
}y,l,r,mid;
void print(bg x){
	while(x.len>1&&!x.a[x.len-1]) x.len--;
	cout<<x.a[x.len-1];
	for(int i=x.len-2;~i;i--){
		char s[20];
		sprintf(s,"%08d",x.a[i]);
		cout<<s;
	}
	cout<<'\n';
}
string s;
int cl(int x){
	int res=0;
	for(;x;x/=10)
		res+=x%10;
	return res;
}
int calc(bg x){
	int res=0;
	for(int i=0;i<x.len;i++)
		res+=cl(x.a[i]);
	return res;
}
bg div(bg x){
	bg res;
	memset(res.a,0,sizeof(res)),res.len=x.len;
	int lst=0;
	for(int i=x.len-1;~i;i--)
		lst=lst*bas+x.a[i],res.a[i]=(lst>>1),lst&=1;
	if(!res.a[res.len-1]&&res.len>1) res.len--;
	return res;
}
bg div10(bg x){
	bg res;
	memset(res.a,0,sizeof(res)),res.len=x.len;
	int lst=0;
	for(int i=x.len-1;~i;i--)
		lst=lst*bas+x.a[i],res.a[i]=lst/10,lst%=10;
	if(!res.a[res.len-1]&&res.len>1) res.len--;
	return res;
}
bg tr(int y){
	bg res;
	memset(res.a,0,sizeof(res.a));
	res.len=0;
	while(y) res.a[res.len++]=y%bas,y/=bas;
	return res;
}
bg sum(bg x,int y){
	return tr(y)+x;
}
bg mul(bg x){
	bg res=x;
	for(int i=0;i<res.len;i++)
		res.a[i]=x.a[i]*md;
	res.len++;
	for(int i=0;i<res.len;i++)
		res.a[i+1]+=res.a[i]/bas,res.a[i]%=bas;
	if(res.len>1&&!res.a[res.len-1]) res.len--;
	return res;
}
bg mul10(bg x){
	bg res;
	res.len=x.len,memset(res.a,0,sizeof(res.a));
	for(int i=0;i<x.len;i++)
		res.a[i]+=x.a[i]*10,res.a[i+1]+=res.a[i]/bas,res.a[i]%=bas;
	if(res.a[res.len]) res.len++;
	return res;
}
int main(){
//	freopen("a.txt","r",stdin);
//	freopen("b.txt","w",stdout);
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>t;
	while(t--){
		memset(y.a,0,sizeof(y.a));
		cin>>s,y.len=(s.size()+7)/8;
		if(s[0]=='0'){
			cout<<"0\n";
			continue;
		}
		reverse(s.begin(),s.end());
//		cout<<s<<endl;
		for(int i=0;i<y.len;i++)
			for(int j=min((int)s.size()-1,i*8+7);j>=i*8;j--)
				y.a[i]=(y.a[i]<<3)+(y.a[i]<<1)+(s[j]&15);
//		print(y);
		y=mul(y);
		l=div10(y),r=sum(l,500000);
//		print(l),print(r);
		while(sum(l,1)<r){
			mid=div(l+r);
//			print(l+r);
			if(mul10(mid)<=sum(y,calc(mid))) l=mid;
        	else r=mid;
		}
		if(mul10(l)==sum(y,calc(l))) print(l);
		else cout<<"-1\n";
	}
    return 0;
}
```

---

## 作者：Wilderness_ (赞：0)

赛时只有 25 pts，但并不影响这是道数学好题。

对了，感谢 [dontwannacry](https://www.luogu.com.cn/user/564225) 大佬的帮助。
## Subtask 1：暴力，25 pts
按题意模拟，$\forall i\in\mathbb{N}$ 求出每一个 $f(i)$ 的值，遍历 $1$ 到 $10^8$ 的函数值匹配输入数字即可。
### code
```
#include<bits/stdc++.h>
using namespace std;
int T;
int s(int i)
{
	if(i==0)return 0;
	return i+s(i/10);
}
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		int n,cnt=0;
		scanf("%d",&n);
		for(int i=0;i<=114514111;i++)
		{
			if(s(i)==n)
			{
				printf("%d\n",i),cnt++;
			}
			if(cnt)break;
		}
		if(!cnt)puts("-1");
	}
	return 0;
}
```
~~就真只有暴力啊~~。

## Subtask 2：100 pts
由于懒，本人定义 $\overline{abc\cdots}(n)$ 表示数字 $\overline{abc\cdots}$ 总共有 $n$ 位。

然后比赛后，再看这道题目发现自己非常弱智，赶紧推式子。
首先，我们可以知道令输入的数为 $\overline{a_1a_2\cdots a_n}(n)$，那么我们能看出 $f(\overline{a_1a_2\cdots a_n}(n))=a_1\times\overline{111\cdots 1}(n)+a_2\times\overline{111\cdots 1}(n-1)+\cdots+a_n$，然后我们惊人的发现 $\overline{111\cdots 1}(n)=\frac{10^n-1}{9}$，那么我们可以推出 $f(\overline{a_1a_2\cdots a_n})=\frac{10\times\overline{a_1a_2\cdots a_n}-(a_1+a_2+\cdots+a_n)}{9}$。这个式子至少比原来相比不必递归了。

接下来考虑如何用函数值求自变量。

易证 $f(x)$ 是单调递增函数，我们可以确定答案具有唯一性。我们先把之前得到的函数表达式转化一下，得到 $(a_1+a_2+\cdots+a_n)=10\times\overline{a_1a_2\cdots a_n}-9\times f(\overline{a_1a_2\cdots a_n})$，那么我们很容易得到 $a_1+a_2+\cdots+a_n\le9\times n\le 9\times f(\overline{a_1a_2\cdots a_n})$ 的位数，那么我们只需要枚举 $10\times \overline{a_1a_2\cdots a_n}$ 的值即可。

我们先令 $S=9\times f(\overline{a_1a_2\cdots a_n})$，然后使 $S$ 的末位满十进一，再循环判定 $S-9\times f(\overline{a_1a_2\cdots a_n})$ 是否等于 $\frac{S}{10}$ 的各个位数之和，是则直接输出 $\frac{S}{10}$，否则 $S\rightarrow S+10$。

根据 dontwannacry 的分析，对于每一个函数值，算法时间复杂度为 $O(n)$，即总时间复杂度为 $O(nT)$。

### Code
```cpp
#include<bits/stdc++.h>
#define M 511415
using namespace std;
char stin[M];
int num[M],sum,len,tenx;
bool fg=0;
int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        memset(num,0,sizeof(num));
	    memset(stin,0,sizeof(stin));
        sum=tenx=fg=0;
        scanf("%s",stin);
        len=strlen(stin);
        for(int i=1;i<=len;++i)num[i]=stin[len-i]-'0';
	    while(!num[len]&&len>1)len--;
        if(len==1&&num[1]==0){puts("0");continue;}
	    for(int i=1;i<=len;++i)num[i]*=9;
        tenx=10-(num[1]%10);
        num[1]+=tenx;
        for(int i=1;i<=len;++i)
        {
            num[i+1]+=num[i]/10;
            num[i]%=10;
            sum+=num[i];
        }
        for(;num[len+1];len++)
        {
            num[len+2]+=num[len+1]/10;
            num[len+1]%=10;sum+=num[len+1];
        }
        for(int reg=1;reg<=500000;++reg)
        {
            if(tenx==sum)
            {
                for(int i=len;i>=2;i--)printf("%d",num[i]);
                puts("");
                fg=1;
                break;
            }
            tenx+=10;++num[2];++sum;
            for(int i=2;i<=len;++i)
            {
                if(num[i]<10)break;
                ++num[i+1];
                num[i]-=10;
                sum-=9;
            }
        }
        if(!fg)puts("-1");
    }    
    return 0;
}
```

---


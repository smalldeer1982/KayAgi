# 括号

## 题目描述

圆给了你一个长度为 $n$ 的字符串 $S$，$S$ 仅由 ```(``` 和 ```)``` 构成。

她会对其做 $m$ 次操作，操作有两种类型：

1. ```1 l r```，她会翻转 $l$ 到 $r$ 的括号，即 ```(``` 变 ```)```，```)``` 变 ```(```。
1. ```2 l r```，她想知道区间 $\left[ l,r\right]$ 中最长合法括号子序列的长度除以 $2$ 的答案。


圆认为以下的括号序列是合法的：

1. 空序列是一个合法序列。

1. 如果 ```A``` 是一个合法序列，则 ```(A)```  也是一个合法序列。

1. 如果 ```A``` 和 ```B``` 都是合法序列，则 ```AB``` 也是一个合法序列。

圆认为，序列 $a$ 的子序列是满足 $1\le i_1<i_2<···<i_k \le n$ 的序列 $[a_{i_1},a_{i_2},...a_{i_k}]$。

由于操作太多了，她算不过来，请你帮帮她吧。


## 说明/提示

**【样例解释】**

- 第一次截取的字符串是 ```()```，答案为 $1$。
- 翻转后字符串变为 ```))(())```。
- 第二次截取的字符串是 ```)(```，答案为 $0$。
- 第三次截取的字符串是 ```())```，答案为 $1$。
- 第四次截取的字符串是 ```(())```，答案为 $2$。

**【数据范围】**

- 对于 $10\%$ 的数据，$1 \leq n,m \leq 500$；
- 对于 $20\%$ 的数据，$1 \leq n,m \leq 5000$；
- 对于 $40\%$ 的数据，$1 \leq n,m \leq 2\times 10^5$；
- 另有 $10\%$ 的数据，满足 $op=2$ 且数据随机生成；
- 另有 $15\%$ 的数据，满足 $op=2$ 但不保证数据随机生成；

对于所有数据，保证 $1\le n \le 5\times 10^5$，$1\le m \le 5 \times 10^5$，$1 \le l \le r \le n$，$op \in \{1,2\}$。数据有梯度。

## 样例 #1

### 输入

```
6
(()())
5
2 2 3
1 1 3
2 2 3
2 4 6
2 3 6```

### 输出

```
1
0
1
2```

# 题解

## 作者：封禁用户 (赞：7)

# P10513 括号

我们考虑使用线段树实现，对于每个区间，可以维护区间内的最大子段和。

为了进行合并我们还需维护剩余的左/右括号个数，在合并时统计跨块的括号对。

具体来讲，左区间剩余的左括号可以与右区间剩余的右括号结合，数量为两者的 $\min$ 值。

```cpp
Node merge(Node x, Node y) {
    int minn = min(x.lv, y.rv);
    return{x.v + y.v + minn,x.lv + y.lv - minn,x.rv + y.rv - minn};
}
```

其中 `v` 是当前区间的答案，`lv` 和 `rv` 分别是剩余的左/右括号个数。

对于区间取反操作，似乎不好直接维护，取反会导致我们维护好的括号全部失配，难以计算。

这里其实有个小 trick，我们可以维护两棵线段树，分别维护正常字符串和取反后的字符串，我们在更新时直接交换两颗树的节点即可。

可以发现，这两颗树只有 `v`，`lv`，`rv` 是不一样的，所以我们可以把这三个变量封成结构体，将它们缩至一棵树，以降低编程复杂度。

时间复杂度 $O(n\log n)$。

## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 5;
struct Node {
    int v, lv, rv; // v: 匹配对数，lv: 左括号剩余，rv: 右括号剩余
};
Node a[N << 2], b[N << 2]; // a: 正常匹配，b: 反转后匹配
bool lazy[N << 2]; // 懒标记，表示是否翻转
char s[N]; // 输入字符串
// 合并两个节点信息
Node merge(Node x, Node y) {
    int minn = min(x.lv, y.rv);
    return{x.v + y.v + minn,x.lv + y.lv - minn,x.rv + y.rv - minn};
}
// 构建线段树
void build(int l, int r, int rt) {
    if (l == r) {
        if (s[l] == '(') a[rt] = {0, 1, 0},b[rt] = {0, 0, 1};
        else if (s[l] == ')') a[rt] = {0, 0, 1},b[rt] = {0, 1, 0};
        else a[rt] = b[rt] = {0, 0, 0};
    }
    else{
        int mid = (l + r) >> 1;
        build(l, mid, rt << 1);
        build(mid + 1, r, rt << 1 | 1);
        a[rt] = merge(a[rt << 1], a[rt << 1 | 1]);
        b[rt] = merge(b[rt << 1], b[rt << 1 | 1]);    
    }
}
// 下推懒标记
void pushdown(int rt) {
    if (lazy[rt]) {
        lazy[rt << 1] ^= 1;
        lazy[rt << 1 | 1] ^= 1;
        swap(a[rt << 1], b[rt << 1]);
        swap(a[rt << 1 | 1], b[rt << 1 | 1]);
        lazy[rt] = 0;
    }
}
// 区间翻转操作
void update(int L, int R, int l, int r, int rt) {
    if (R < l || r < L) return;
    if (L <= l && r <= R) {
        lazy[rt] ^= 1;
        swap(a[rt], b[rt]);
        return;
    }
    pushdown(rt);
    int mid = (l + r) >> 1;
    update(L, R, l, mid, rt << 1);
    update(L, R, mid + 1, r, rt << 1 | 1);
    a[rt] = merge(a[rt << 1], a[rt << 1 | 1]);
    b[rt] = merge(b[rt << 1], b[rt << 1 | 1]);
}
// 查询区间匹配对数
Node query(int L, int R, int l, int r, int rt) {
    if (R < l || r < L) return {0, 0, 0};
    if (L <= l && r <= R) return a[rt];
    pushdown(rt);
    int mid = (l + r) >> 1;
    return merge(query(L, R, l, mid, rt << 1), query(L, R, mid + 1, r, rt << 1 | 1));
}
int n,q;
int main() {
    cin >> n >> s + 1 >> q;
    build(1, n, 1);
    while (q--) {
        int op, x, y;
        cin >> op >> x >> y;
        if (op == 1) update(x, y, 1, n, 1);
        else cout << query(x, y, 1, n, 1).v << "\n";
    }
    return 0;
}
```

---

## 作者：igAC (赞：6)

# $\text{Description}$

既然是小圆的题就来写写题解吧，想吐槽的是为什么这道题是蓝，感觉也就绿题的水平。

[link](https://www.luogu.com.cn/problem/P10513)

简要题意：

给定括号序列，$q$ 次操作：区间取反（`(` 变 `)`，`)` 变 `(`）、问最长合法括号**子序列**长度 $/2$。

# $\text{Solution}$

显然是一道线段树的题目，所以我们考虑如何合并区间。

假设我们已经知道了 $[l,mid]$ 和 $(mid,r]$ 的信息，那么 $[l,r]$ 的答案就是 $[l,mid]$ 的答案和 $(mid,r]$ 的答案之和再加上跨过中点的括号对个数。

跨过中点的括号对就是由若干个左区间的左括号以及右区间的右括号组成的。

也就是需要用线段树维护在保证区间答案最大的情况下，最多能给其他区间多少个左括号以及右括号。

然后就是区间取反操作，其实就是对于原串取反后的串（简称反串）维护以上信息，取反时交换一下原串以及反串的信息即可。

复杂度 $O(n \log n)$。

# $\text{Code}$

如果以上内容理解不了的话可以参照代码理解。

```cpp
#include<bits/stdc++.h>
#define N 500005
using namespace std;
int read(){
	int x=0,f=1,ch=getchar();
	for(;!isdigit(ch);ch=getchar()) f=(ch=='-')?-1:1;
	for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);
	return x*f;
}
int n,q;
string s;
struct Data{
	int ans,lr,rl;
	Data(){ans=lr=rl=0;}
	friend Data operator + (const Data &a,const Data &b){
		Data c;
		int res=min(a.rl,b.lr);//跨过中点的括号对数
		c.ans=a.ans+b.ans+res;
		c.lr=a.lr+b.lr-res;
		c.rl=b.rl+a.rl-res;
		return c;
	}
};
struct Segment{
	int l,r;
	Data ans1,ans2;
	bool tag;
}node[N<<2];
void getnew(int p){
	node[p].ans1=node[p<<1].ans1+node[p<<1|1].ans1;
	node[p].ans2=node[p<<1].ans2+node[p<<1|1].ans2;
}
void build(int p,int l,int r){
	node[p].l=l,node[p].r=r;
	if(l==r){
		node[p].ans1.lr=node[p].ans2.rl=(s[l]==')');
		node[p].ans1.rl=node[p].ans2.lr=(s[l]=='(');
		return;
	}
	int mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	getnew(p);
}
void spread(int p){
	if(node[p].tag){
		swap(node[p<<1].ans1,node[p<<1].ans2);
		swap(node[p<<1|1].ans1,node[p<<1|1].ans2);
		node[p<<1].tag^=1,node[p<<1|1].tag^=1;
		node[p].tag=0;
	}
}
void change(int p,int l,int r){
	if(l<=node[p].l && node[p].r<=r){
		swap(node[p].ans1,node[p].ans2);
		node[p].tag^=1;
		return;
	}
	spread(p);
	int mid=(node[p].l+node[p].r)>>1;
	if(l<=mid) change(p<<1,l,r);
	if(r>mid) change(p<<1|1,l,r);
	getnew(p);
}
Data query(int p,int l,int r){
	if(l<=node[p].l && node[p].r<=r) return node[p].ans1;
	spread(p);
	int mid=(node[p].l+node[p].r)>>1;
	if(r<=mid) return query(p<<1,l,r);
	else if(l>mid) return query(p<<1|1,l,r);
	else return query(p<<1,l,r)+query(p<<1|1,l,r);
}
int main(){
	n=read();cin>>s;s=" "+s;
	build(1,1,n);q=read();
	while(q--){
		int op=read(),l=read(),r=read();
		if(op==1) change(1,l,r);
		else printf("%d\n",query(1,l,r).ans);
	}
	return 0;
}
```

---

## 作者：dyc2022 (赞：4)

先考虑不带修部分。

显然可以使用线段树来维护当前区间的最长合法长度除以二、剩余失配的左括号、剩余失配的右括号。

在考虑如何上传。先计算出会**增加**的最长合法长度，显然为左区间的左括号数量和右区间的右括号数量的**最小值**。再计算失配左括号，为左右区间的失配左括号之和减去增加的答案。

***

再考虑带修部分。

我们可以使用 tag 来记录区间的修改结果。

我们可以开两棵线段树，一棵存储不取反，一棵存储取反了。翻转一个区间时，将两棵树的当前节点交换即可。

***

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
#define N 500005
using namespace std;
namespace IO
{
	int read()
	{
		int ret=0,bas=1;char ch=getchar();
		while(!isdigit(ch)&&ch!='-')ch=getchar();
		if(ch=='-')bas=-1,ch=getchar();
		while(isdigit(ch))ret=(ret<<3)+(ret<<1)+ch-'0',ch=getchar();
		return bas*ret;
	}
	void write(int k)
	{
		if(!k)return;
		write(k/10);
		putchar((char)(k%10+'0'));
	}
	void print(int k)
	{
		if(k==0)putchar('0');
		else if(k<0)putchar('-'),write(-k);
		else write(k);
	}
}
using namespace IO;
char str[N];
int n,m,opt,_l,_r;
struct Node{int lsum,rsum,sum;};
struct Tree_Node{int tag;Node t[2];}tree[N<<2];
Node merge(Node ls,Node rs)
{
	int nowans=min(ls.lsum,rs.rsum);
	Node ret={ls.lsum+rs.lsum-nowans,ls.rsum+rs.rsum-nowans,ls.sum+rs.sum+nowans};
	return ret;
}
void build(int p,int l,int r)
{
	tree[p].tag=0;
	if(l==r)
	{
		int k=(str[l]=='(');
		tree[p].t[0]={k,1-k,0};
		tree[p].t[1]={1-k,k,0};
		return;
	}
	int mid=l+r>>1;
	build(p<<1,l,mid),build(p<<1|1,mid+1,r);
	tree[p].t[0]=merge(tree[p<<1].t[0],tree[p<<1|1].t[0]);
	tree[p].t[1]=merge(tree[p<<1].t[1],tree[p<<1|1].t[1]);
}
void addtag(int p){tree[p].tag^=1;swap(tree[p].t[0],tree[p].t[1]);}
void pushdown(int p)
{
	if(tree[p].tag)
	{
		addtag(p<<1);
		addtag(p<<1|1);
		tree[p].tag=0;
	}
}
void update(int p,int l,int r,int L,int R)
{
	if(L<=l&&r<=R){addtag(p);return;}
	pushdown(p);
	int mid=l+r>>1;
	if(L<=mid)update(p<<1,l,mid,L,R);
	if(R>=mid+1)update(p<<1|1,mid+1,r,L,R);
	tree[p].t[0]=merge(tree[p<<1].t[0],tree[p<<1|1].t[0]);
	tree[p].t[1]=merge(tree[p<<1].t[1],tree[p<<1|1].t[1]);
}
Node query(int p,int l,int r,int L,int R)
{
	if(L<=l&&r<=R)return tree[p].t[0];
	pushdown(p);
	int mid=l+r>>1;
	if(R<=mid)return query(p<<1,l,mid,L,R);
	if(L>=mid+1)return query(p<<1|1,mid+1,r,L,R);
	return merge(query(p<<1,l,mid,L,R),query(p<<1|1,mid+1,r,L,R));
}
main()
{
	n=read(),scanf("%s",str+1);
	build(1,1,n);
	for(m=read();m--;)
	{
		opt=read(),_l=read(),_r=read();
		if(opt==1)update(1,1,n,_l,_r);
		else print(query(1,1,n,_l,_r).sum),putchar('\n');
	}
	return 0;
}
```

---

## 作者：2c_s (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P10513)

## 思路

看到要进行区间修改和查询，马上想到线段树。由于本题需要进行括号序列的翻转，那么我们可以用两个结构体分别保存原始线段和预备翻转线段。要进行翻转的时候交换这两个线段即可。

本题代码在线段树中保存的信息：

`l`：线段左端点；

`r`：线段右端点；

`tag`：线段是否要翻转；

`ori`：原始（即要进行输出的）线段；

`chg`：**预备**更改后替代原始线段的线段；

`ma`：此线段合法括号序列最大长度；

`lcnt`：此线段**多余的**左括号数量；

`rcnt`：此线段**多余的**右括号数量。

```cpp
const int N=5e5+10;
int n,m;
string s;
struct segtree{
	int l,r;
	bool tag;
	struct node{int ma,lcnt,rcnt;}ori,chg;//直接定义在里面方便。
}tr[N<<2];//线段树开 4 倍空间。
```

### 1. 建树

分别处理初始线段和替代线段，如左括号对应初始线段的左括号，对应替代线段的右括号。剩下的和普通线段树相同。

```cpp
void build(int i,int l,int r){
	tr[i].l=l;
	tr[i].r=r;
	if(l==r){
		if(s[l]=='(')tr[i].ori.lcnt=tr[i].chg.rcnt=1;
		else tr[i].ori.rcnt=tr[i].chg.lcnt=1;
		return ;
	}
	int mid=l+r>>1;
	build(i<<1,l,mid);
	build(i<<1|1,mid+1,r);
	pushup(i);//见 2.
	return ;
}
```

### 2. ``pushup`` 和 ``merge`` 操作

在 ``pushup`` 的时候，我们需要对初始线段和替代线段分别进行同一操作，即合并两个线段的左右括号序列的 ``merge`` 操作。

我们找到左线段的**左**括号、右线段的**右**括号剩余数，两者的最小值即为**新增的合法括号对数**。之后用两条线段的左、右括号剩余数分别减去上文中的新增的对数即为新的剩余数。最大合法括号序列长度为原先两条线段的对数和加上新增的合法括号对数。

```cpp
segtree::node merge(segtree::node a,segtree::node b){
	segtree::node k;
	int par=min(a.lcnt,b.rcnt);//新增合法括号对数。
	k.lcnt=a.lcnt+b.lcnt-par;
	k.rcnt=a.rcnt+b.rcnt-par;
	k.ma=a.ma+b.ma+par;
	return k;
}
void pushup(int i){
     //初始线段和替换线段分别处理。
	tr[i].ori=merge(tr[i<<1].ori,tr[i<<1|1].ori);
	tr[i].chg=merge(tr[i<<1].chg,tr[i<<1|1].chg);
	return ;
}
```

### 3. 翻转线段

正如总起段所说，直接交换初始线段和替换线段即可，其余部分与普通线段树相同。记得修改懒标记。

```cpp
void change(int i,int l,int r){
	if(l<=tr[i].l&&tr[i].r<=r){
		tr[i].tag^=1;
		swap(tr[i].ori,tr[i].chg);
		return ;
	}
	pushdown(i);//见 4.
	int mid=tr[i].l+tr[i].r>>1;
	if(l<=mid)change(i<<1,l,r);
	if(mid<r)change(i<<1|1,l,r);
	pushup(i);//见 2.
	return ;
}
```

### 4. ``pushdown`` 操作

和翻转线段原理相似，直接翻转子线段的初始线段和替换线段，并对翻转标记进行操作。

```cpp
void pushdown(int i){
	if(tr[i].tag){
		tr[i<<1].tag^=1;tr[i<<1|1].tag^=1;
		swap(tr[i<<1].ori,tr[i<<1].chg);
		swap(tr[i<<1|1].ori,tr[i<<1|1].chg);
		tr[i].tag=0;//翻转完记得将懒标记归零。
	}
	return ;
}
```

### 5. 查询操作

用结构体型返回，目的是在合并时也进行 ``merge`` 操作。

```cpp
segtree::node query(int i,int l,int r){
	if(l<=tr[i].l&&tr[i].r<=r)return tr[i].ori;//返回初始线段。
	pushdown(i);//见 4.
	int mid=tr[i].l+tr[i].r>>1;
	if(r<=mid)return query(i<<1,l,r);//完全在左边。
	else if(mid<l)return query(i<<1|1,l,r);//完全在右边。
	else return merge(query(i<<1,l,r),query(i<<1|1,l,r));//在中间就要合并。
}
```

### 6. 主函数

这道题输入输出量较大，用 ``cin`` 和 ``cout`` 会导致超时，所以记得替换为 ``scanf`` 和 ``printf`` 或快读快写。

``string`` 类型下标从 $0$ 开始，所以我们要转化为从 $1$ 开始。

查询的 ``query`` 操作返回的是结构体，所以输出的应该是 ``query().ma``。

```cpp
signed main(){
	cin>>n>>s>>m;
	s=" "+s;
	build(1,1,n);
	while(m--){
		int op=read(),l=read(),r=read();
		if(op==1)change(1,l,r);
		else printf("%d\n",query(1,l,r).ma);
	}
	return 0;
}
```

## 完整无注释代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll read(){
	ll k=0,flag=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')flag=-1;c=getchar();}
	while(c>='0'&&c<='9'){k=(k<<1)+(k<<3)+(c^48);c=getchar();}
	return k*flag;
}
const int N=5e5+10;
int n,m;
string s;
struct segtree{
	int l,r;
	bool tag;
	struct node{int ma,lcnt,rcnt;}ori,chg;
}tr[N<<2];
segtree::node merge(segtree::node a,segtree::node b){
	segtree::node k;
	int par=min(a.lcnt,b.rcnt);
	k.lcnt=a.lcnt+b.lcnt-par;
	k.rcnt=a.rcnt+b.rcnt-par;
	k.ma=a.ma+b.ma+par;
	return k;
}
void pushup(int i){
	tr[i].ori=merge(tr[i<<1].ori,tr[i<<1|1].ori);
	tr[i].chg=merge(tr[i<<1].chg,tr[i<<1|1].chg);
	return ;
}
void build(int i,int l,int r){
	tr[i].l=l;
	tr[i].r=r;
	if(l==r){
		if(s[l]=='(')tr[i].ori.lcnt=tr[i].chg.rcnt=1;
		else tr[i].ori.rcnt=tr[i].chg.lcnt=1;
		return ;
	}
	int mid=l+r>>1;
	build(i<<1,l,mid);
	build(i<<1|1,mid+1,r);
	pushup(i);
	return ;
}
void pushdown(int i){
	if(tr[i].tag){
		tr[i<<1].tag^=1;tr[i<<1|1].tag^=1;
		swap(tr[i<<1].ori,tr[i<<1].chg);
		swap(tr[i<<1|1].ori,tr[i<<1|1].chg);
		tr[i].tag=0;
	}
	return ;
}
void change(int i,int l,int r){
	if(l<=tr[i].l&&tr[i].r<=r){
		tr[i].tag^=1;
		swap(tr[i].ori,tr[i].chg);
		return ;
	}
	pushdown(i);
	int mid=tr[i].l+tr[i].r>>1;
	if(l<=mid)change(i<<1,l,r);
	if(mid<r)change(i<<1|1,l,r);
	pushup(i);
	return ;
}
segtree::node query(int i,int l,int r){
	if(l<=tr[i].l&&tr[i].r<=r)return tr[i].ori;
	pushdown(i);
	int mid=tr[i].l+tr[i].r>>1;
	if(r<=mid)return query(i<<1,l,r);
	else if(mid<l)return query(i<<1|1,l,r);
	else return merge(query(i<<1,l,r),query(i<<1|1,l,r));
}
signed main(){
	cin>>n>>s>>m;
	s=" "+s;
	build(1,1,n);
	while(m--){
		int op=read(),l=read(),r=read();
		if(op==1)change(1,l,r);
		else printf("%d\n",query(1,l,r).ma);
	}
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/160092434)

---

## 作者：MadokaKaname (赞：3)

出题人题解。

### subtask 1

枚举左右端点暴力扫，时间复杂度 $O(n^3)$。

### subtask 2

枚举左端点，往右扫的时候用栈去维护一下，时间复杂度 $O(n^2)$。

### subtask 3

考虑一个去掉最长合法子序列之后的串，一定是 ```)))))......((((``` 状的。考虑分块，每个块中维护左侧右括号个数和右侧左括号个数，时间复杂度 $O(n \sqrt{n})$。

### subtask 4

$n\le 5\times 10^5，op=2$，考虑线段树。维护一个 $(l,r,val)$ 的 tag，表示剩余右括号个数，左括号个数，区间的答案，可以发现容易合并，时间复杂度 $O(n \log n)$。

### subtask 5

仍然考虑使用线段树。维护一个 $(l,r,ans,val)$ 的 tag，表示 ```)``` ，```(```，```()```，```)(``` 的个数，发现这个也是容易 $O(1)$ 合并的，时间复杂度 $O(n \log n)$。

solution by @[_Akarin_](https://www.luogu.com.cn/user/363166)

```
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
int n,i,j,k,l,o,p,r,opt,T,a[N];
long long ans;
bool tag[N<<2];
struct nd{
	int c0,c1,ans,anti;
	nd operator+(const nd &p){
		nd tmp;
		tmp.c0=c0+p.c0;
		tmp.c1=c1+p.c1;
		tmp.ans=ans+p.ans+min(c1-ans,p.c0-p.ans);
		tmp.anti=anti+p.anti+min(c0-anti,p.c1-p.anti);
		return tmp;
	}
}tree[N<<2];
char s[N];
inline void pushdown(int k){
	swap(tree[k<<1].c0,tree[k<<1].c1);
	swap(tree[k<<1].ans,tree[k<<1].anti);
	swap(tree[k<<1|1].c0,tree[k<<1|1].c1);
    swap(tree[k<<1|1].ans,tree[k<<1|1].anti);
	//tree[k]=tree[k<<1]+tree[k<<1|1];
	tag[k<<1]^=1;tag[k<<1|1]^=1;
    tag[k]=0;
}
inline void build(int l,int r,int k){
	if(l==r){
		if(a[l])tree[k]={0,1,0,0};
		else tree[k]={1,0,0,0};
		return;
	}
	int mid=l+r>>1;
	build(l,mid,k<<1);
	build(mid+1,r,k<<1|1);
	tree[k]=tree[k<<1]+tree[k<<1|1];
}
inline void rev(int l,int r,int L,int R,int k){
	if(l>=L&&r<=R){
		swap(tree[k].c0,tree[k].c1);
		swap(tree[k].ans,tree[k].anti);
		tag[k]^=1;
		return;
	}
	if(tag[k])pushdown(k);
	int mid=l+r>>1;
	if(L<=mid)rev(l,mid,L,R,k<<1);
	if(R>mid)rev(mid+1,r,L,R,k<<1|1);
	tree[k]=tree[k<<1]+tree[k<<1|1];
}
inline nd query(int l,int r,int L,int R,int k){
	if(l>=L&&r<=R)
		return tree[k];
	if(tag[k])pushdown(k);
	int mid=l+r>>1;
	nd A={0,0,0,0},B={0,0,0,0};
    if(L<=mid)A=query(l,mid,L,R,k<<1);
    if(R>mid)B=query(mid+1,r,L,R,k<<1|1);
	return A+B;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n;
	cin>>s+1;
	for(i=1;i<=n;i++)
	   a[i]=(s[i]=='(');
	build(1,n,1);
	cin>>T;
	while(T--){
		cin>>opt>>l>>r;
		if(opt==1){
			rev(1,n,l,r,1);
		}
		else{
			cout<<query(1,n,l,r,1).ans<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：dyxcj (赞：2)

# [P10513](https://www.luogu.com.cn/problem/P10513)

# 本篇题解是对其他题解的补充

题目描述很清晰，没有太多多余的话（所以可以直接看题面）。

# 思路

假设只有查询，可以维护三个变量 $w$ 与 $lk$ 与 $rk$ 分别表示匹配了多少对括号，剩余的左括号，剩余的右括号。\
我们发现要有很多次加法，如果把结构体的每个变量单独来加就太长了，所以我们可以重载加号（[感谢思路来源](https://www.luogu.com.cn/article/ayu0woqc)）。\
先写出结构体。\
代码：

```cpp
struct wasd{
    int lk,rk,w;
    friend wasd operator +(const wasd x,const wasd y){
        wasd z;
        int n=min(x.lk,y.rk);
        z.w=x.w+y.w+n;
        z.lk=x.lk+y.lk-n;
        z.rk=x.rk+y.rk-n;
        return z;
    }
};
```

查询操作对于我的代码不经是返回 $w$ 的值，也要合并区间中的剩余左括号与剩余右括号，发现重载加干了一切，所以可以直接将 $\operatorname{query}$ 函数定义为 $\operatorname{wasd}$ 类型（注意，文中的 $\operatorname{wasd}$ 类型是我结构体的名字）。\
代码：

```cpp
wasd query(int u,int L,int R,int l,int r){
    if(InRange(L,R,l,r))return t[u].z;
    else if(!OutRange(L,R,l,r)){
        int mid=(L+R)/2;
        pushdown(u);
        return query(u*2,L,mid,l,r)+query(u*2+1,mid+1,R,l,r);
    }else return {0,0,0};
}
```

接下来考虑修改：\
发现如果每次修改直接在原序列上修改，维护将变得困难。\
此时最难的部分来了：这里可以考虑建一课反树，原数组存左括号的话它存右括号，原数组存右括号的话它存左括号。\
此时的修改就变为交换正反树，为求方便，将正反树与懒标记（区间修改要懒标记的）也存入结构体并维护 $\operatorname{pushup}$。\
代码：

```cpp
struct tree{
    bool lazy;
    wasd z,f;
}t[2000005];
void pushup(int u){
    t[u].f=t[u*2].f+t[u*2+1].f;
    t[u].z=t[u*2].z+t[u*2+1].z;
}
```

这里 $\operatorname{pushup}$ 是与 $\operatorname{query}$ 合并原理是相近的，但要同时维护正反树。\
接下来是 $\operatorname{pushdown}$ 与 $\operatorname{maketag}$ 函数。

```cpp
void maketag(int u){
    swap(t[u].f,t[u].z);
    t[u].lazy^=1;
}
void pushdown(int u){
    if(!t[u].lazy)return;
    maketag(u*2);
    maketag(u*2+1);
    t[u].lazy=0;
}
```

这里要确保每次都是正树是我们要的，所以有交换。
接下来就是 $\operatorname{update}$ 函数。\
代码：

```cpp
bool InRange(int L,int R,int l,int r){return (l<=L)&&(r>=R);}
bool OutRange(int L,int R,int l,int r){return (l>R)||(r<L);}
void update(int u,int L,int R,int l,int r){
    if(InRange(L,R,l,r))maketag(u);
    else if(!OutRange(L,R,l,r)){
        int mid=(L+R)/2;
        pushdown(u);
        update(u*2,L,mid,l,r);
        update(u*2+1,mid+1,R,l,r);
        pushup(u);
    }
}
```

这里的 $\operatorname{InRange}$ 与 $\operatorname{OutRange}$ 是判断区间 $[L,R]$ 是否在区间 $[l,r]$ 的包含内。\
接下来是 $\operatorname{build}$ 函数。\
代码：

```cpp
void build(int u,int L,int R){
    if(L==R){
        t[u].z.lk=a[L],t[u].z.rk=(!a[L]);
        t[u].f.lk=(!a[L]),t[u].f.rk=a[L];
        return;
    }
    int mid=(L+R)/2;
    build(u*2,L,mid);
    build(u*2+1,mid+1,R);
    pushup(u);
}
```

与正常的差不多。\
总结：就维护两棵树较难想，实现较容易。

# 代码

```
#include<bits/stdc++.h>
using namespace std;
int n,m;
bool a[500005];
struct wasd{
    int lk,rk,w;
    friend wasd operator +(const wasd x,const wasd y){
        wasd z;
        int n=min(x.lk,y.rk);
        z.w=x.w+y.w+n;
        z.lk=x.lk+y.lk-n;
        z.rk=x.rk+y.rk-n;
        return z;
    }
};
struct tree{
    bool lazy;
    wasd z,f;
}t[2000005];
void pushup(int u){
    t[u].f=t[u*2].f+t[u*2+1].f;
    t[u].z=t[u*2].z+t[u*2+1].z;
}
bool InRange(int L,int R,int l,int r){return (l<=L)&&(r>=R);}
bool OutRange(int L,int R,int l,int r){return (l>R)||(r<L);}
void maketag(int u){
    swap(t[u].f,t[u].z);
    t[u].lazy^=1;
}
void pushdown(int u){
    if(!t[u].lazy)return;
    maketag(u*2);
    maketag(u*2+1);
    t[u].lazy=0;
}
void build(int u,int L,int R){
    if(L==R){
        t[u].z.lk=a[L],t[u].z.rk=(!a[L]);
        t[u].f.lk=(!a[L]),t[u].f.rk=a[L];
        return;
    }
    int mid=(L+R)/2;
    build(u*2,L,mid);
    build(u*2+1,mid+1,R);
    pushup(u);
}
void update(int u,int L,int R,int l,int r){
    if(InRange(L,R,l,r))maketag(u);
    else if(!OutRange(L,R,l,r)){
        int mid=(L+R)/2;
        pushdown(u);
        update(u*2,L,mid,l,r);
        update(u*2+1,mid+1,R,l,r);
        pushup(u);
    }
}
wasd query(int u,int L,int R,int l,int r){
    if(InRange(L,R,l,r))return t[u].z;
    else if(!OutRange(L,R,l,r)){
        int mid=(L+R)/2;
        pushdown(u);
        return query(u*2,L,mid,l,r)+query(u*2+1,mid+1,R,l,r);
    }else return {0,0,0};
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    char w;
    cin>>n;
    for(int i=1;i<=n;i++)cin>>w,a[i]=(w=='(');
    build(1,1,n);
    cin>>m;
    for(int i=1,op,l,r;i<=m;i++){
        cin>>op>>l>>r;
        if(op==1)update(1,1,n,l,r);
        else cout<<query(1,1,n,l,r).w<<"\n";
    }
    return 0;
}
```

感谢大家的观看。

---

## 作者：Union_Find (赞：2)

首先看出来是线段树，自然想到直接维护区间内的最长合法子序列长度。

考虑如何合并。一个节点的答案应该是两个儿子的答案加上跨过 $mid$ 的括号对。所以要额外维护该区间剩余左括号数和剩余右括号数，方便合并。具体合并见代码。

在考虑反转。其实可以开两颗线段树，另一颗存反串的信息，反转时交换即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
#define N 500005
il ll rd(){
	ll s = 0, w = 1;
	char ch = getchar();
	for (;ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;
	for (;ch >= '0' && ch <= '9'; ch = getchar()) s = ((s << 1) + (s << 3) + ch - '0');
	return s * w;
}
ll n = rd(), op, l, r, tag[N << 2];
char s[N];
struct P{
	ll fl, fr, f;
}tr1[N << 2], tr2[N << 2];//tr1 是正串，tr2 是反串
void pu(ll p){//合并
	P a = tr1[p << 1], b = tr1[p << 1 | 1], c = tr2[p << 1], d = tr2[p << 1 | 1];
  	ll res = min(a.fl, b.fr);//res 表示跨过 mid 的括号对
	tr1[p] = P{a.fl + b.fl - res, a.fr + b.fr - res, a.f + b.f + res};
	res = min(c.fl, d.fr);
	tr2[p] = P{c.fl + d.fl - res, c.fr + d.fr - res, c.f + d.f + res};
}void pd(ll p){
	if (tag[p]){
		swap(tr1[p << 1], tr2[p << 1]), swap(tr1[p << 1 | 1], tr2[p << 1 | 1]);
		tag[p << 1] ^= 1, tag[p << 1 | 1] ^= 1, tag[p] = 0;
	}
}
void build(ll p, ll l, ll r){
	if (l == r){
		tr1[p] = P{1, 0, 0}, tr2[p] = P{0, 1, 0};
		if (s[l] == ')') swap(tr1[p], tr2[p]);
		return ;
	}ll mid = (l + r) >> 1;
	build(p << 1, l, mid), build(p << 1 | 1, mid + 1, r);
	pu(p);
}void change(ll p, ll l, ll r, ll nl, ll nr){
	if (nl <= l && r <= nr) return swap(tr1[p], tr2[p]), tag[p] ^= 1, void(0);
	if (nl > r || nr < l) return ;
	ll mid = (l + r) >> 1;pd(p);
	change(p << 1, l, mid, nl, nr), change(p << 1 | 1, mid + 1, r, nl, nr);
	pu(p);
}P ask(ll p, ll l, ll r, ll nl, ll nr){
	if (nl <= l && r <= nr) return tr1[p];
	ll mid = (l + r) >> 1;pd(p);
	if (nr <= mid) return ask(p << 1, l, mid, nl, nr);
	if (nl > mid) return ask(p << 1 | 1, mid + 1, r, nl, nr);
	P a = ask(p << 1, l, mid, nl, nr), b = ask(p << 1 | 1, mid + 1, r, nl, nr);
	ll res = min(a.fl, b.fr);
	return P{a.fl + b.fl - res, a.fr + b.fr - res, a.f + b.f + res};
}
int main(){
	scanf ("%s", s + 1);
	build(1, 1, n);
	for (int T = rd(); T--;){
		op = rd(), l = rd(), r = rd();
		if (op == 1) change(1, 1, n, l, r);
		else printf ("%lld\n", ask(1, 1, n, l, r).f);
	}
	return 0;
}

```

---

## 作者：Hoks (赞：2)

## 前言
明天就期末考了，赶快来写个小圆的题涨涨 RP。

感觉是挺简单的，但是我结构体顺序写错了挂了 $15$ 分钟。
## 思路分析
首先看题面要细心点，注意查询的是**最长合法括号子序列**，不要看成子串了。

考虑怎么处理这个东西。

因为是区间查，比较自然的想到线段树，直接用线段树维护当前区间剩余左右括号个数和答案。

那么就可以一路合并维护出每个区间的答案。

接着来考虑很烦的区间翻转修改操作。

考虑经典 trick，因为不好翻转，而每个点的信息又是打包好的。

所以我们直接把正串反串的两种节点交换即可。

实现时标记个翻转懒标记记得下传即可。

感觉不是很难欸，可能评绿的确够了。
## 代码
```cpp
#include <bits/stdc++.h>
#define ls (p<<1)
#define rs (ls|1)
#define mid ((l+r)>>1)
#define int long long
using namespace std;
const int N=5e5+10,mod=1e9+7,V=1e9,INF=0x3f3f3f3f3f3f3f3f;
struct node{int l,r,ans;node(int x=0,int y=0,int z=0){l=x,r=y,ans=z;}};
struct tree{int tag;node t1,t2;}t[N<<2];
int n,m;char s[N];
namespace Fast_IO
{
    static char buf[1000000],*paa=buf,*pd=buf,out[10000000];int length=0;
    #define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
    inline int read()
    {
        int x(0),t(1);char fc(getchar());
        while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
        while(isdigit(fc)) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
        return x*t;
    }
    inline void flush(){fwrite(out,1,length,stdout);length=0;}
    inline void put(char c){if(length==9999999) flush();out[length++]=c;}
    inline void put(string s){for(char c:s) put(c);}
    inline void print(int x)
    {
        if(x<0) put('-'),x=-x;
        if(x>9) print(x/10);
        put(x%10+'0');
    }
    inline bool chk(char c) { return !(c=='('||c==')'); }
    inline bool ck(char c) { return c!='\n'&&c!='\r'&&c!=-1&&c!=' '; }
    inline void rd(char s[],int&n)
    {
        s[++n]=getchar();
        while(chk(s[n])) s[n]=getchar();
        while(ck(s[n])) s[++n]=getchar();
        n--;
    }
}
using namespace Fast_IO;
node merge(node x,node y)
{
    int cnt=min(x.l,y.r);
    return {x.l+y.l-cnt,x.r+y.r-cnt,x.ans+y.ans+cnt};
    //就这个位置写错了一直挂飞
}
inline void pushup(int p){t[p].t1=merge(t[ls].t1,t[rs].t1);t[p].t2=merge(t[ls].t2,t[rs].t2);}
inline void pushson(int p){swap(t[p].t1,t[p].t2);t[p].tag^=1;}
inline void pushdown(int p){if(!t[p].tag) return;pushson(ls),pushson(rs);t[p].tag=0;}
inline void build(int p,int l,int r)
{
    if(l==r) return t[p].t2.r=t[p].t1.l=(s[l]=='('),t[p].t2.l=t[p].t1.r=(s[l]==')'),void();
    build(ls,l,mid);build(rs,mid+1,r);pushup(p);
}
inline void modify(int p,int l,int r,int s,int e)
{
    if(l>=s&&r<=e) return pushson(p);pushdown(p);
    if(mid>=s) modify(ls,l,mid,s,e);if(mid<e) modify(rs,mid+1,r,s,e);
    pushup(p);
}
inline node query(int p,int l,int r,int s,int e)
{
    if(l>=s&&r<=e) return t[p].t1;pushdown(p);
    if(e<=mid) return query(ls,l,mid,s,e);
    if(s>mid) return query(rs,mid+1,r,s,e);
    return merge(query(ls,l,mid,s,e),query(rs,mid+1,r,s,e));
}
signed main()
{
    read();rd(s,n);m=read();build(1,1,n);
    for(int i=1,op,l,r;i<=m;i++)
    {
        op=read(),l=read(),r=read();
        if(op==1) modify(1,1,n,l,r);
        else print(query(1,1,n,l,r).ans),put('\n');
    }
    genshin:;flush();return 0;
}
```

---

## 作者：Lacuna (赞：1)

### 思路：

考虑线段树。维护当前区间的左括号数量 $l$，右括号数量 $r$，最长合法括号子序列长度 $mat$。

对于取反操作，我们可以建两棵线段树，但主播这里放在一棵树上维护，建一个结构体存上面三个信息，在线段树的结构体里存两个上面的结构体就行，一个存正串，一个存反串。每次操作 swap 一下正串和反串就行。

然后就是如何合并两个子树，我们计算一个区间能新匹配的括号数，也就是左边左括号的个数和右边右括号的个数取最小值。则合并之后的合法括号子序列长度是左边匹配好的长度加右边匹配好的长度加可以新匹配的个数，左括号个数减去新匹配的个数，右括号同理。

懒标记 $tag$ 表示是否要翻转。

### 代码，没删文件流：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define gc getchar
#define pb push_back
#define ls u<<1
#define rs u<<1|1
#define miku
template<typename T>inline void read(T&x){x=0;int f=1;char ch=gc();while(!isdigit(ch)){if(ch=='-') f=-1;ch=gc();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=gc();}x*=f;}
template<typename T,typename ...T1>inline void read(T&x,T1&...x1){read(x);read(x1...);}
const int ri=5e5+5;
int n,m,opt,l,r; string s;
struct __{int l,r,mat;};
struct _{
    __ l,r; bool tag;	
}tr[ri<<2];
__ merge(__ &x,__ &y){
    int cnt=min(x.l,y.r);
    __ Q=(__){x.l+y.l-cnt,x.r+y.r-cnt,x.mat+y.mat+cnt};
    return Q;
} 
void pushup(int u){
	tr[u].l=merge(tr[ls].l,tr[rs].l);
	tr[u].r=merge(tr[ls].r,tr[rs].r);
}
void pushdown(int u){
    if(tr[u].tag){
      swap(tr[ls].l,tr[ls].r);
      tr[ls].tag^=1;
      swap(tr[rs].l,tr[rs].r);
      tr[rs].tag^=1;
      tr[u].tag=0;
	}
}
void build(int u,int l,int r){
	if(l==r){
	  if(s[l]=='('){
	    tr[u].l.l=1,tr[u].l.r=0;
		tr[u].r.l=0,tr[u].r.r=1;
	  }else{
	  	tr[u].l.l=0,tr[u].l.r=1;
		tr[u].r.l=1,tr[u].r.r=0;
	  }
	  return;
	}
	int mid=l+r>>1;
	build(ls,l,mid); build(rs,mid+1,r);
	pushup(u);
}
void change(int u,int l,int r,int x,int y){
	if(x<=l&&r<=y){
	  swap(tr[u].l,tr[u].r);
	  tr[u].tag^=1;
	  return;
	}
	pushdown(u);
	int mid=l+r>>1;
	if(x<=mid) change(ls,l,mid,x,y);
	if(y>mid) change(rs,mid+1,r,x,y);
	pushup(u);
}
__ query(int u,int l,int r,int x,int y){
	if(x<=l&&r<=y) return tr[u].l;
	pushdown(u);
	int mid=l+r>>1; __ L={},R={}; bool a=0,b=0;
	if(x<=mid) L=query(ls,l,mid,x,y),a=1;
	if(y>mid) R=query(rs,mid+1,r,x,y),b=1;
	if(a==1&&b==1) return merge(L,R);
	else return a?L:R;
}
signed main(){
	#ifdef miku
	freopen("sample1.in","r",stdin);
	freopen("miku.out","w",stdout);
	#endif
    read(n); cin>>s; s=" "+s;
	build(1,1,n); read(m);
	while(m--){
	  read(opt,l,r);
	  if(opt==1) change(1,1,n,l,r);
	  else 
	    printf("%lld\n",query(1,1,n,l,r).mat);
	} 
    return 0;
}/*
    I will never forget the beauty of the world
*/
```

---

## 作者：KobeBeanBryantCox (赞：1)

# P10513 括号 题解

--------------------------------

[题目传送门](https://www.luogu.com.cn/problem/P10513)。

~~我真的超级喜欢数据结构，特别是线段树。~~

貌似其他题解都没证明为什么可以这么维护。

-------------------------------

## 思路

显然是线段树。

不考虑翻转，考虑如何用线段树合并两端信息。

假设存在左子树与右子树的个数，那当前节点的个数就是左边的个数加上右边的个数加上跨越中间的括号对的个数。

-----------------------------

### 证明（会的大佬可以跳过了）：

不难看出，每加上一个跨越中间的括号对，等价于在左右两边分别插入一个左括号和右括号，也等价于在整体中插入一个拆开的括号对。

显然整体是一个合法的括号序列，那么现在要证明的就是：

**在一个合法的括号序列中，任意位置插入一对括号，序列依然合法。**

考虑括号序列合法的条件：

1. 序列的任意位置，令前缀左括号个数和为 $sl_i$，前缀右括号个数和为 $sr_i$，则有 $sl_i\ge sr_i$。
2. 序列结尾位置，$sl_n=sr_n$。

这同时也是充要条件，即可以互推。

**所以由于左括号比右括号先插入，则 $sl_i\ge sr_i$ 的条件恒成立，且显然 $sl_n=sr_n$ 依然成立。**

证毕。

-------------------------------

所以我们每个区间要维护的东西就有三个：

1. 失配的左括号的个数；
2. 失配的右括号的个数；
3. 答案。

注意以上失配的括号的个数是在满足答案最大的情况下失配的个数。

符合结合律，所以这方面的处理就很简单了。

考虑加上翻转操作。

**考虑使用经典的 trick，即维护原串和反串，翻转时交换信息，发现是可行的。**

所以就做完了。复杂度 $O(n\log n)$。

----------------------------

## 代码

有些细节，另外可以学学我这种 tag 的写法，很方便。

```cpp
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
int in()
{
	int k=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar();
	return k*f;
}
void out(int x)
{
	if(x<0)putchar('-'),x=-x;
	if(x<10)putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
const int N=5e5+10;
string s;
struct Seg
{
	struct data
	{
		int cntl,cntr,ans;
		data(){cntl=cntr=ans=0;}
		friend data operator+(const data &a,const data &b) // 定义重载会使得合并极为方便
		{
			if(a.cntl+a.cntr+a.ans==0)return b;
			if(b.cntl+b.cntr+b.ans==0)return a; // 存在空的 tag
			int tmp=min(a.cntl,b.cntr);data ret;
			ret.cntl=a.cntl+b.cntl-tmp;
			ret.cntr=a.cntr+b.cntr-tmp;
			ret.ans=a.ans+b.ans+tmp;
			return ret;
		}
	};
	struct node{int l,r;bool rev;data str,revstr;}tr[N<<2];
	#define lc (x<<1)
	#define rc ((x<<1)|1)
	void pushup(int x)
	{
		tr[x].str=tr[lc].str+tr[rc].str;
		tr[x].revstr=tr[lc].revstr+tr[rc].revstr;
	}
	void pushdown(int x) // 下传翻转标记
	{
		if(!tr[x].rev)return;
		tr[lc].rev^=1,tr[rc].rev^=1;
		swap(tr[lc].str,tr[lc].revstr),swap(tr[rc].str,tr[rc].revstr);
		tr[x].rev=false;
	}
	void build(int x,int l,int r)
	{
		tr[x].l=l,tr[x].r=r,tr[x].rev=false;
		if(l==r)
		{
			if(s[l]=='(')tr[x].str.cntl=tr[x].revstr.cntr=1;
			else tr[x].str.cntr=tr[x].revstr.cntl=1; // 也要存反串的信息
			return;
		}
		int mid=(l+r)>>1;
		build(lc,l,mid),build(rc,mid+1,r),pushup(x);
	}
	void change(int x,int l,int r)
	{
		if(tr[x].l>=l&&tr[x].r<=r)
		{
			tr[x].rev^=1,swap(tr[x].str,tr[x].revstr);
			return;
		}
		pushdown(x);int mid=(tr[x].l+tr[x].r)>>1;
		if(l<=mid)change(lc,l,r);
		if(r>mid)change(rc,l,r);
		pushup(x);
	}
	data query(int x,int l,int r)
	{
		if(tr[x].l>=l&&tr[x].r<=r)return tr[x].str;
		pushdown(x);int mid=(tr[x].l+tr[x].r)>>1;data ans;
		if(l<=mid)ans=ans+query(lc,l,r);
		if(r>mid)ans=ans+query(rc,l,r);
		return ans;
	}
}T;
int main()
{
	int n=in();cin>>s,s="#"+s; // 注意从 1 开始
	T.build(1,1,n);int m=in();
	while(m--)
	{
		int op=in(),l=in(),r=in();
		if(op==1)T.change(1,l,r);
		else out(T.query(1,l,r).ans),putchar('\n');
	}
	return 0;
}
```

-----------------------------

后记：~~我真的超级超级喜欢线段树啊啊啊啊啊！！！~~

---

## 作者：__builtin_orz (赞：1)

区间修改 + 区间查询 + 信息可合并 = 线段树

注意是 **子序列** 不是 **子串**。

如何合并？

显然，左区间的游离左括号有些是可以和右区间的游离右括号配对的，所以合并后区间的游离左右括号要减去它们。左区间的游离右括号会保留为合并后区间的游离右括号，右区间的游离左括号会保留为合并后区间的游离左括号。于是就有了如下代码：
```cpp
//区间括号信息结构体
struct Bracket{
//每个区间的游离左括号，答案，游离右括号
	int l,ans,r;
//合并两个区间括号信息
	static Bracket merge(Bracket x,Bracket y){
//新增的答案数量
		int tmp=std::min(x.l,y.r);
//左括号相加然后减掉由于左右括号配对增加的答案数量
//右括号相加然后减掉由于左右括号配对增加的答案数量
//答案相加再加上增量
		return{x.l+y.l-tmp,x.ans+y.ans+tmp,x.r+y.r-tmp};
	}
};
```
如何修改？

预处理出反转后的区间括号信息（指游离的左括号，游离的有括号以及成功配对的对数），修改时直接交换反转后与未反转的括号信息并打上 tag，如果不是完全覆盖就先修改左右自树再更新自己。

如何查询？

和区间求和的原理差不多，但是这里不是简单的加法，要考虑如何合并两个括号信息。

我使用了指针实现线段树，个人认为比数组实现美观些（效率不谈，虽然静态内存池也可以， ~~但懒得写了，就用 new 吧~~ ）

```cpp
#include<cstdio>
#include<algorithm>
#define N 5000005
//区间括号信息结构体
struct Bracket{
//每个区间的游离左括号，答案，游离右括号
	int l,ans,r;
//合并两个区间括号信息
	static Bracket merge(Bracket x,Bracket y){
//新增的答案数量
		int tmp=std::min(x.l,y.r);
//左括号相加然后减掉由于左右括号配对增加的答案数量
//右括号相加然后减掉由于左右括号配对增加的答案数量
//答案相加再加上增量
		return{x.l+y.l-tmp,x.ans+y.ans+tmp,x.r+y.r-tmp};
	}
};
char c[N];
//线段树本体
struct Seg{
//区间左右边界
	int l,r;
//原来的括号信息与反转后的括号信息
	Bracket b,rb;
//反转标记
	bool tag;
//左右子树
	Seg *lc,*rc;
//建树
	static Seg*build(int L,int R){
		Seg*ret=new Seg{L,R,{0,0,0},{0,0,0},false,nullptr,nullptr};
		if(L==R){
			ret->b.l=ret->rb.r=c[L]=='(';
			ret->b.r=ret->rb.l=c[L]==')';
		}else{
			int M=L+R>>1;
			ret->lc=build(L,M);
			ret->rc=build(M+1,R);
			ret->update();
		}
		return ret;
	}
//更新当前节点
	void update(){
		b=Bracket::merge(lc->b,rc->b);
		rb=Bracket::merge(lc->rb,rc->rb);
	}
//下传反转标记
	void spread(){
		if(tag){
			tag=false;
			lc->tag^=true;
			rc->tag^=true;
			std::swap(lc->b,lc->rb);
			std::swap(rc->b,rc->rb);
		}
	}
//判断是否包括当前区间
	bool in(int L,int R){return L<=l&&r<=R;}
//判断是否与当前区间完全不相交
	bool out(int L,int R){return r<L||R<l;}
//反转
	void modify(int L,int R){
		if(in(L,R)){
//打标记
			tag^=true;
//反转
			std::swap(b,rb);
		}else if(!out(L,R)){
//反转前记得下传标记
			spread();
			lc->modify(L,R);
			rc->modify(L,R);
//反转子树后记得更新当前状态（卡了我好久，粗心了）
			update();
		}
	}
//询问
	Bracket query(int L,int R){
		if(in(L,R))
			return b;
		if(!out(L,R)){
//询问前记得下传标记
			spread();
			Bracket tmp=Bracket::merge(lc->query(L,R),rc->query(L,R));
			return tmp;
		}
//完全不相交的话返回这个
//因为(Bracket,merge)群中{0,0,0}确实是单位元
//即不论x是什么，Bracket::merge({0,0,0},x)总是x
		return {0,0,0};
	}
};
int n,m,op,l,r;
int main(){
//读入
	scanf("%d%s",&n,c+1);
//建树
	Seg*root=Seg::build(1,n);
//读入
	scanf("%d",&m);
//处理
	while(m--){
//读入
		scanf("%d%d%d",&op,&l,&r);
//反转
		if(op==1)
			root->modify(l,r);
//询问
		else
			printf("%d\n",root->query(l,r).ans);
	}
	return 0;
}
```

---

## 作者：Rindong (赞：1)

# 题意

给定一个仅包含左右括号的字符串序列，给定两种操作：操作一，翻转一个区间的括号；操作二，输出一个区间中最大的合法的括号个数。

关于合法括号的定义可以读题目得出。

# 思考过程

刚开始看到题目的时候，题目里出现的“**区间**”关键字，我第一时间想到的是树状数组，即：考虑维护两个动态前缀和，一个 $left$，另一个 $right$，其中 $left_i$ 代表字串中 $[1, i]$ 包含的左括号数量；$right_i$ 相应地代表右括号数量。想到这，匹配括号数的子问题“似乎”解决了，那如何表示一个区间翻转了呢？

聪明的我马上想到了！再加一个动态前缀和 $vis$ 用于标记某个位置是否翻转过了，即默认值全部为 $0$，当需要标记 $[l, r]$ 翻转时，使 $vis_l$ 加一，使 $vis_{r + 1}$ 加一。也就是说，想知道某个点是否为翻转状态，只要查询那个位置的 $vis_i$ 是否为奇数，奇数代表翻转，偶数代表不翻转。在树状数组获取某个点的值的时候，如果这个点是翻转状态，就去对面的数组里去取。比如要获取一个区间的左括号数，但是他翻转过了，新的左括号数一定是原来的右括号数。

写到这，我还以为我思考的方向对了，我忽略了一个问题：如何动态地维护匹配的括号数。根据我之前的设计，我只能维护某个区间左右括号的个数，难道只需要简单把两个区间的左右括号取个小就行了吗？考虑以下样例：```))(())``` 现在需要求 $[1, 6]$ 的括号个数，简单使用左右区间括号数进行匹配的话，左边只有一个左括号，右边有两个右括号，得出只匹配了一个括号，而正确答案是匹配两个括号。

稍加思索（~~点开标签~~）后发现，不能只简单考虑两个区间，而是子区间的子区间也得考虑，所以需要使用线段树。

每个节点需要维护区间的左右括号数，还有成功匹配的括号数、成功匹配的反括号数。对于翻转操作，只需要交换对应的变量即可。

那么如何维护成功匹配的括号数呢？发现对于一个区间所有成功匹配的括号数等于左区间未匹配的左括号数加上右区间未匹配的右括号数，这部分是新的匹配，再加上先前已经匹配过的括号数就是当前区间的括号数了！对于反括号，只要镜像维护即可。

# 代码

需要特别注意的是合并的时候不要写错变量了，还有懒标记的处理，因为这个我调了几个小时。

```cpp
#include <iostream>
using namespace std;
#define MAX_N 500005
#define MAX_T MAX_N * 4
#define LC(x) ((x) * 2)
#define RC(x) ((x) * 2 + 1)
#define MID(node) ((tree[node].l + tree[node].r) / 2)
char str[MAX_N] = { 0 };
struct Node { //使用懒标记代表此段是否需要翻转
	int l = 0, r = 0;
	int l_cnt = 0, r_cnt = 0, val = 0,
		anti = 0;
	bool lazy = false;
};
Node tree[MAX_T];
//整合两个节点的信息
void _plus(Node& n, Node& a, Node& b) {
	n.l_cnt = a.l_cnt + b.l_cnt;
	n.r_cnt = a.r_cnt + b.r_cnt;
									//将未匹配的给匹配上
	n.val = a.val + b.val + min(a.l_cnt - a.val, b.r_cnt - b.val);
	n.anti = a.anti + b.anti + min(a.r_cnt - a.anti, b.l_cnt - b.anti);
}
void up_update(int node) {
	_plus(tree[node], tree[LC(node)], tree[RC(node)]);
}
//镜像一个节点
void mirror(int node) {
	swap(tree[node].val, tree[node].anti);
	swap(tree[node].l_cnt, tree[node].r_cnt);
}
void down_update(int node) {
	if (tree[node].lazy == false) return;
	mirror(LC(node));
	mirror(RC(node));
	tree[LC(node)].lazy = !tree[LC(node)].lazy;
	tree[RC(node)].lazy = !tree[RC(node)].lazy;
	tree[node].lazy = false;
}
void build(int l, int r, int node) {
	tree[node].l = l, tree[node].r = r;
	if (l == r) {
		tree[node].l_cnt = (str[l] == '(');
		tree[node].r_cnt = (str[r] == ')');
		return;
	}
	int mid = MID(node);
	build(l, mid, LC(node));
	build(mid + 1, r, RC(node));
	up_update(node);
}
//镜像一段区间
void update(int l, int r, int node) {
	if (l <= tree[node].l && tree[node].r <= r) {
		mirror(node);
		tree[node].lazy = !tree[node].lazy;
		return;
	}
	down_update(node);
	int mid = MID(node);
	if (l <= mid) update(l, r, LC(node));
	if (r > mid) update(l, r, RC(node));
	up_update(node);
}
//查询区间合法括号长度
Node pres(int l, int r, int node) {
	if (l <= tree[node].l && tree[node].r <= r) return tree[node];
	down_update(node);
	int mid = MID(node);
	Node aa, bb, ans;
	if (l <= mid) aa = pres(l, r, LC(node));
	if (r > mid) bb = pres(l, r, RC(node));
	up_update(node);
	//线段树的信息合并
	_plus(ans, aa, bb);
	return ans;
}
int main() {
	int n, m;
	scanf("%d", &n);
	scanf("%s", str + 1);
	build(1, n, 1);
	scanf("%d", &m);
	while (m--) {
		int op, l, r;
		scanf("%d%d%d", &op, &l, &r);
		if (op == 1) update(l, r, 1);
		else {
			//cout << "开始查询：" << l << "  " << r << "\n";
			printf("%d\n", pres(l, r, 1).val);
		}
	}
	return 0;
}
```

# 修改记录
2024/5/22：修改笔误。

---

## 作者：qinmingze (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10513)

### 思路

看完题目，我们不难想到这题考察的算法是线段树。

其中我们需要用线段树维护的**一些**变量如下：

$l$ 代表区间左端点。

$r$ 代表区间右端点。

$tag$ 代表区间的懒惰标记。

我们依照题意将这些变量维护起来，就会发现对于两个操作的具体操作是无法实现的，因此我们需要进行以下操作：

- 对于第一个操作，我们可以定义两个变量，一个变量记录着**原串的信息**，另一个变量则记录**翻转后串的信息**，这样在执行操作一时，我们只需要将两个变量交换即可。

- 对于第二个操作，我们在向下寻找时，要注意寻找的方式。因为本题的答案**需要合并操作**来求出，所以需要改变判断方式，判断方法如下：

```cpp
if(r <= mid) return find(i << 1, l, r);
else if(l >= mid + 1) return find(i << 1 | 1, l, r);
else return merge(find(i << 1, l, r), find(i << 1 | 1, l, r));//合并操作。
```

处理完两个操作，我们还需要注意本题的 pushup 部分，当前的区间个数其实就是**左区间的个数加上右区间的个数**，**最后在加上跨区间的个数**即可。

### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 5e5 + 10;

int n;

string s;

struct node{
	int tmax, lcnt, rcnt;
};

struct seg_tree{
	int l, r;
	node ans1, ans2;
	bool tag;
}tree[N * 4];

node merge(node x, node y){
	node z = {0, 0, 0};
	int tmp = min(x.lcnt, y.rcnt);
	z.lcnt = x.lcnt + y.lcnt - tmp; //统计无法配对的个数。
	z.rcnt = x.rcnt + y.rcnt - tmp;
	z.tmax = x.tmax + y.tmax + tmp;//计算最大长度。
	return z;
}

void pushup(int i){
	tree[i].ans1 = merge(tree[i << 1].ans1, tree[i << 1 | 1].ans1);
	tree[i].ans2 = merge(tree[i << 1].ans2, tree[i << 1 | 1].ans2);
}

void build(int i, int l, int r){
	tree[i].l = l; tree[i].r = r; tree[i].tag = 0;
	if(l == r){
		if(s[l] == '(') tree[i].ans1.lcnt = tree[i].ans2.rcnt = 1;
		else tree[i].ans1.rcnt = tree[i].ans2.lcnt = 1;
		tree[i].ans1.tmax = tree[i].ans2.tmax = 0;
		return ;
	}
	int mid = l + r >> 1;
	build(i << 1, l, mid); build(i << 1 | 1, mid + 1, r);
	pushup(i);
}

void pushdown(int i){
	if(tree[i].tag){
		tree[i].tag ^= 1;
		swap(tree[i << 1].ans1, tree[i << 1].ans2);
		swap(tree[i << 1 | 1].ans1, tree[i << 1 | 1].ans2);
		tree[i << 1].tag ^= 1; tree[i << 1 | 1].tag ^= 1;
	}
}

void change(int i, int l, int r){
	if(tree[i].l >= l && tree[i].r <= r){
		swap(tree[i].ans1, tree[i].ans2);
		tree[i].tag ^= 1;
		return ;
	}
	pushdown(i);
	int mid = tree[i].l + tree[i].r >> 1;
	if(l <= mid) change(i << 1, l, r);
	if(r >= mid + 1) change(i << 1 | 1, l, r);
	pushup(i);
}

node find(int i, int l, int r){
	if(tree[i].l >= l && tree[i].r <= r) return tree[i].ans1;
	pushdown(i);
	int mid = tree[i].l + tree[i].r >> 1;
	if(r <= mid) return find(i << 1, l, r);
	else if(l >= mid + 1) return find(i << 1 | 1, l, r);
	else return merge(find(i << 1, l, r), find(i << 1 | 1, l, r));//合并操作。
}

int main(){
	cin >> n >> s;
	s = " " + s;//让下标从 1 开始。
	build(1, 1, n);
	int m;
	cin >> m;
	while(m--){
		int op, l, r;
		scanf("%d%d%d", &op, &l, &r);
		if(op == 1) change(1, l, r);
		else printf("%d\n", find(1, l, r).tmax);
	}
}
```

---

## 作者：菲斯斯夫斯基 (赞：1)

### 前言

晚修做的题，记录一下从零到 AC 的历程。为啥我能做出来的蓝题都总是有大佬说是绿，我还是太菜了，要练练练。

### 思路

感觉还是挺明显要用线段树做的了。

考虑没有修改操作怎么搞。来个不用脑子的：`(` 和 `)` 要怎么合并。这个简单，维护 $l$ 和 $r$ 表示多出的左右括号，左边的部分贡献多余的 `(`，右边的部分贡献多余的 `)`，合并的时候取最小值作为贡献出来的新的几组括号。

然后加上修改操作。先观察下面的两个字符串：`()()` 和 `(())`。上面两个的答案都是 $2$，但是翻转之后会变成 `)()(` 和 `))((`，答案分别为 $1$ 和 $0$。

上面的例子提示我们要开新的变量来储存答案。

思考一会发现可以提前维护某个区间被翻转了会怎么样。真正翻转之后直接交换答案就行了。

讲的好像有点抽象，建议看代码及注释。

### 代码

下面我把左右括号反了过来存。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+10;
int n,m;
string s;
struct ccf
{
	int x,l,r,x_,l_,r_;//带"_"是假设翻转的 
	bool la;
}f[N<<2];
ccf up(ccf x,ccf y)
{
	int k=min(x.r,y.l),k_=min(x.r_,y.l_);//取最小值为新的几组括号
	return {x.x+y.x+k,x.l+y.l-k,x.r+y.r-k,x.x_+y.x_+k_,x.l_+y.l_-k_,x.r_+y.r_-k_};
}
void down(int k)
{
	if(!f[k].la)return ;
	f[k].la=false;
	int l=k*2,r=k*2+1;
	swap(f[l].x,f[l].x_);
	swap(f[l].l,f[l].l_);
	swap(f[l].r,f[l].r_);
	swap(f[r].x,f[r].x_);
	swap(f[r].l,f[r].l_);
	swap(f[r].r,f[r].r_);//交换左右儿子 
	f[l].la^=1;
	f[r].la^=1;
}
void build(int k,int l,int r)
{
	if(l==r)
	{
		if(s[l]=='(')f[k]={0,0,1,0,1,0,false};
		else f[k]={0,1,0,0,0,1,false};
		return ;
	}
	int mid=(l+r)/2;
	build(k*2,l,mid);
	build(k*2+1,mid+1,r);
	f[k]=up(f[k*2],f[k*2+1]);
}
void change(int k,int l,int r,int x,int y)
{
	if(l>y||r<x)return ;
	if(x<=l&&r<=y)
	{
		f[k].la^=1;
		swap(f[k].x,f[k].x_);
		swap(f[k].l,f[k].l_);
		swap(f[k].r,f[k].r_);//换成翻转的答案
		return ;
	}
	down(k);
	int mid=(l+r)/2;
	change(k*2,l,mid,x,y);
	change(k*2+1,mid+1,r,x,y);
	f[k]=up(f[k*2],f[k*2+1]);
}
ccf ask(int k,int l,int r,int x,int y)
{
	if(l>y||r<x)return {0,0,0,0,0,0,false};
	if(x<=l&&r<=y)return f[k];
	int mid=(l+r)/2;
	down(k);
	return up(ask(k*2,l,mid,x,y),ask(k*2+1,mid+1,r,x,y));
}
int main()
{
	cin>>n;
	cin>>s;
	s=' '+s;
	build(1,1,n);
	cin>>m;
	while(m--)
	{
		int op,l,r;
		scanf("%d%d%d",&op,&l,&r);
		if(op==1)change(1,1,n,l,r);
		else printf("%d\n",ask(1,1,n,l,r).x); 
	}
	return 0;
}

```

---

## 作者：ZhongYuLin (赞：1)

先考虑不修改的部分分。迎合最大子段和问题的解法，我们在每个线段树节点中存储：失配的左括号数量、失配的右括号数量，匹配的括号对数量。

考虑合并贡献。发现左侧子区间的失配右括号可能与右侧子区间的失配左括号形成新的括号匹配对，于是容易写出：

```cpp
struct Node{
        int l,r,sum;
        friend Node operator+(const Node &x,const Node &y){
            int k=min(x.r,y.l);
            return {x.l+y.l-k,x.r+y.r-k,x.sum+y.sum+k};
        }
    };
```

可以通过不修改的部分分。

再考虑下传标记怎么做。发现目前的信息量不足以维护，必须要递归至底层获取信息。我们发现，递归至底层进行更新，本质上是获得两个子区间翻转后的信息，于是我们将这一部分也塞入节点中：

```cpp
struct Seg{
    struct Node{
        int l,r,sum;
        friend Node operator+(const Node &x,const Node &y){
            int k=min(x.r,y.l);
            return {x.l+y.l-k,x.r+y.r-k,x.sum+y.sum+k};
        }
    }a,b;//a 为不取反，b 为取反
    friend Seg operator+(const Seg &x,const Seg &y){
        return {x.a+y.a,x.b+y.b}; 
    }
}t[N<<2];
```

于是不难写出完整代码。

---

## 作者：ny_jerry2 (赞：0)

观察到是区间上的问题，又看一眼数据范围，很自然地想到了线段树。

分两个部分讲述。

## 不带修改
我们线段树中存储这几个值：  

- $x$：区间中左括号的个数（除去已经被配对的括号个数）。
- $y$：区间中右括号的个数（除去已经被配对的括号个数）。
- $num$：区间中合法括号的对数。

那 $pushup$ 的时候也就很简单了。可以先加上子区间的贡献，再算一下进的贡献就好了。

## 带修改
肯定要有懒标记。  
在上面的基础上再开三个对应上面的值。

具体就是修改的时候可以直接交换。  
还有就是因为它是区间翻转，可以知道翻转两次等于原序列，所以懒标记应该是一个布尔类型，每次修改时就异或 $1$ 就好了。

时间复杂度：$O(n \log n)$。

需要一点代码能力。

## 代码
```
#include<iostream>
#include<cstring>
using namespace std;
const int N=5e5+10;
char s[N];
int n;
struct tree{
	int l,r;
	int x,y;
	int x2,y2;
	int num,num2;
	bool tag;
}tr[N<<2];
void push_up(tree &a,tree b,tree c){
	a.num=min(b.x,c.y);
	a.x=b.x+c.x-a.num;
	a.y=b.y+c.y-a.num;
	a.num+=(b.num+c.num);
	
	a.num2=min(b.x2,c.y2);
	a.x2=b.x2+c.x2-a.num2;
	a.y2=b.y2+c.y2-a.num2;
	a.num2+=(b.num2+c.num2);
}
void add(int u){
	tr[u].tag^=1;
	swap(tr[u].num,tr[u].num2);
	swap(tr[u].x,tr[u].x2);
	swap(tr[u].y,tr[u].y2);
}
void push_down(int u){
	if(tr[u].tag==0){
		return;
	}
	add(u<<1);
	add(u<<1|1);
	tr[u].tag^=1;
}
void build(int u,int l,int r){
	tr[u].l=l,tr[u].r=r;
	if(l==r){
		if(s[l]=='('){
			tr[u].x=tr[u].y2=1;
		}else{
			tr[u].y=tr[u].x2=1;
		}
		return;
	}
	int mid=(l+r)>>1;
	build(u<<1,l,mid);
	build(u<<1|1,mid+1,r);
	push_up(tr[u],tr[u<<1],tr[u<<1|1]);
}
tree query(int u,int l,int r){
	if(tr[u].l>=l&&tr[u].r<=r){
		return tr[u];
	}
	push_down(u);
	int mid=(tr[u].l+tr[u].r)>>1;
	if(r<=mid){
		return query(u<<1,l,r);
	}
	if(l>mid){
		return query(u<<1|1,l,r);
	}
	tree a;
	tree b=query(u<<1,l,r),c=query(u<<1|1,l,r);
	push_up(a,b,c);
	return a;
}
void modify(int u,int l,int r){
	if(tr[u].l>=l&&tr[u].r<=r){
		add(u);
		return;
	}
	push_down(u);
	int mid=(tr[u].l+tr[u].r)>>1;
	if(l<=mid){
		modify(u<<1,l,r);
	}
	if(r>mid){
		modify(u<<1|1,l,r);
	}
	push_up(tr[u],tr[u<<1],tr[u<<1|1]);
}
int main(){
	cin>>n;
	scanf("%s",s+1);
	build(1,1,n);
	int m;
	cin>>m;
	while(m--){
		int op,l,r;
		scanf("%d%d%d",&op,&l,&r);
		if(op==1){
			modify(1,l,r);
		}else{
			int ans=query(1,l,r).num;
			cout<<ans<<endl;
		}
	}
}
```

---


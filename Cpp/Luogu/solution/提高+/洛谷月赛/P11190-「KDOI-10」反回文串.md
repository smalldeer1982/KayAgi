# 「KDOI-10」反回文串

## 题目背景

**本场比赛所有题目从标准输入读入数据，输出到标准输出。**

## 题目描述

我们称一个长度为 $m$ 的字符串 $r$ 是回文的，当且仅当 $r_i=r_{m+1-i}$ 对所有 $1\le i\le m$ 均成立。

给定一个长度为 $n$ 的字符串 $s$，你需要把 $s$ 分成若干个非空子序列，使得每一个子序列都**不是**回文的，并最大化划分成的子序列数。

形式化地说，你需要给出一组序列 $(a_1,a_2,\ldots,a_k)$，满足：

- 对于任意 $1\le i\le k$，记 $l_i$ 为 $a_i$ 的长度，则 $l_i\ge 1$，且 $1\le a_{i,1}<a_{i,2}<\cdots<a_{i,l_i}\le n$；
- 对于任意 $1\le i\le n$，恰好存在一个二元组 $(p,q)$，使得 $a_{p,q}=i$；
- 对于任意 $1\le i\le k$，记字符串 $t=s_{a_{i,1}}s_{a_{i,2}}\ldots s_{a_{i,l_i}}$，则 $t$ 不是回文的。

在此基础上，你需要最大化 $k$ 的值；或者判断不存在一种合法的方案。

特别地，如果 $k$ 的值不是最大的，你也可能获得一定的部分分。


## 说明/提示

**【样例 1 解释】**

对于第一组测试数据，显然输出构成一个合法的子序列划分，并且

- 对于第一个子序列，$t=\tt{kd}$ 不是回文的；
- 对于第二个子序列，$t=\tt{oi}$ 不是回文的。

故这是一组合法的输出。可以证明，对于这组测试数据，$2$ 是 $k$ 的最大可能值。

对于第二组数据，它的任意一个子序列都是回文的， 故显然不存在合法的划分方案。

**【样例 2】**

见选手目录下的 `anti/anti2.in` 与 `anti/anti2.ans`。

这个样例共有 $10$ 组数据，均满足 $n=1\,000$。其中第 $1\sim 3$ 组数据满足特殊性质 A，第 $4\sim 6$ 组数据满足特殊性质 B。

***

**【评分方式】**

本题共有 $20$ 个测试点，每个测试点满分 $5$ 分。

本题采用自定义校验器（special judge）评测。每组测试数据可能有多组解，你只需要给出**任意**一组。

在每个测试点中，你的得分是在所有测试数据上得分的最小值。对于每组测试数据：

- 如果你错误地判断了是否有解或者给出了一组不合法的序列，你将会获得 $0$ 分；
- 如果你正确判断了是否有解，并在有解时给出了一组合法的序列：
  - 如果 $k$ 的值不是最大的，你将会获得 $2$ 分；
  - 如果 $k$ 的值是最大的，你将会获得 $5$ 分。
  
***

**【数据范围】**

对于全部的测试数据，保证：

- $1\le q\le 10$；
- $1\le n\le 10^5$；
- $s$ 中仅包含小写英文字母。

|测试点|$n\le$|特殊性质|
|:--:|:--:|:--:|
|$1,2$|$5$|无|
|$3\sim 5$|$18$|无|
|$6\sim 8$|$1\,000$|B|
|$9\sim 11$|$1\,000$|无|
|$12\sim 14$|$10^5$|A|
|$15\sim 17$|$10^5$|B|
|$18\sim 20$|$10^5$|无|

- 特殊性质 A：保证 $n$ 是偶数，且 $s$ 中每个字符的出现次数都不超过 $\frac{n}{2}$；
- 特殊性质 B：保证 $s$ 中仅有 `a` 和 `b`。

***

**【如何使用校验器】**

为了方便选手测试，在附件的 `anti` 目录下我们下发了 `checker.cpp` 文件作为样例校验器，选手可以编译该程序，并使用它校验自己的输出文件的结果是否**合法**。但请注意它与最终评测时所使用的校验器并不完全一致。你也不需要关心其代码的具体内容。

编译命令为：

```sh
g++ -o checker -std=c++14 -O2 checker.cpp
```

`checker` 的使用方式为：

```sh
checker <input-file> <output-file>
```

其中，参数 ` <input-file>` 与 `<output-file>` 依次表示输入文件与你的输出文件。

若你的输出中的数字大小范围不合法，则校验器会给出相应提示并立即退出。否则，校验器输出以下内容：

- 在第 $i$ 行 $(1\le i\le q)$ 中，输出第 $i$ 组测试数据的详细提示信息；
- 在第 $(q+1)$ 行，输出这个测试点的总结信息。

例如，对于样例 1 的输入与输出，校验器将会向屏幕打印如下内容：

```plain
Test case 1: OK. Participant's answer is YES (Huoyu), and k=2.
Test case 2: OK. Participant's answer is NO (Shuiniao).
Test case 3: OK. Participant's answer is YES (Huoyu), and k=3.
Test case 4: OK. Participant's answer is YES (Huoyu), and k=3.
ok 4 / 4 test cases passed. (4 test cases)
```

若将输出改为如下：

```plain
Huoyu
2
2 1 2
2 3 4
Huoyu
1
7 1 2 3 4 5 6 7
Huoyu
3
3 1 2 3
2 4 5
2 6 7
Huoyu
3
2 1 4
3 2 3 5
2 6 7
```

则会向屏幕打印如下内容：

```plain
Test case 1: OK. Participant's answer is YES (Huoyu), and k=2.
Test case 2: Wrong answer. The string t obtained in the subsequence a[1] is palindrome.
Test case 3: OK. Participant's answer is YES (Huoyu), and k=3.
Test case 4: OK. Participant's answer is YES (Huoyu), and k=3.
wrong answer 3 / 4 test cases passed.
```

**请注意：** 样例校验器只会检查你的输出是否合法，而**不会**：

- 检查有解性是否判断正确；
- 检查 $k$ 是否被最大化。

例如，将样例 1 的输出改为如下：

```plain
Shuiniao
Shuiniao
Shuiniao
Shuiniao
```

此时，样例校验器仍会返回 `ok` 的检查结果。


## 样例 #1

### 输入

```
0
4
4
kdoi
7
ccccccc
7
sszcdjr
7
abacaca```

### 输出

```
Huoyu
2
2 1 2
2 3 4
Shuiniao
Huoyu
3
3 1 2 3
2 4 5
2 6 7
Huoyu
3
2 1 4
3 2 3 5
2 6 7
```

# 题解

## 作者：Iniaugoty (赞：33)

### [P11190 「KDOI-10」反回文串](/problem/P11190)

两个特殊性质已经把做法塞你嘴里了。

考虑 A 性质。

如果 $2 \mid n$，这时是可以将颜色不同的两两配对上的。考虑将原序列重排，使颜色相同的放在一起，此时把 $(i, i + \frac n 2)$ 分进一个子序列是可行的（经典思路，因为不存在绝对众数，而颜色相同的是连续的，所以他们颜色不同）。答案最优为 $\frac n 2$。

如果 $2 \nmid n$，把多出来的 $n$ 加进 $(1, 1 + \lfloor \frac n 2 \rfloor)$ 里面就行了，原因同上。答案最优为 $\lfloor \frac n 2 \rfloor$。

考虑 B 性质。

这意味着至少有一种颜色数量达到了 $\lceil \frac n 2 \rceil$，称这种颜色为 X，另一种颜色为 Y。

显然的是分出来的每个子序列都至少有一个 Y，所以所有颜色相同时无解。

当 Y 只有一个时，只能将所有的分在一起。如果此时 $2 \nmid n$ 并且 $s _ {\lfloor \frac n 2 \rfloor}$（即正中心）为 Y 时，它本身就是一个形如 `...XXXYXXX...` 的回文，无解；否则必然不回文，答案为 $1$。

当 Y 有两个时。设第一个 Y 的位置为 $l$，最后一个 Y 的位置为 $r$。把 $[l + 1, n]$ 中的 X 分给 $l$，$[1, l - 1]$ 中的 X 分给 $r$。如果分下来有个 Y 没有 X 的话注意从另一个里面分过来一个。这样会得到形如 `YXXX...` 和 `...XXXY` 的东西。答案最优为 $2$。

当 Y 更多时，延续上面的思路。$[l + 1, r - 1]$ 之间的 Y 没有 X，从 $l$ 或 $r$ 的里面分过来一个就行了。这样会得到形如 `YXXX...`， `...XXXY` 和一大堆 `XY`，`YX`。答案最优为 Y 的数量。

考虑正解。

不存在绝对众数时，用 A 性质做法；否则将绝对众数当成 X，其他颜色当成 Y，用 B 性质做法。

就做完了，时间复杂度是线性，根据实现可能会带点别的什么东西。

```cpp
#include <bits/stdc++.h>
#define F(i, a, b) for(int i = (a); i <= (b); ++i)
#define dF(i, a, b) for(int i = (a); i >= (b); --i)

using namespace std;
typedef long long LL;
typedef unsigned long long ull;
typedef unsigned uint;
typedef pair<int, int> pii;
const int N = 1e5 + 5;

int n, t[140], zyq; char s[N];
int p[N]; vector<int> qu[140];
int cnt; vector<int> ans[N];
void mian() {
  cin >> n, zyq = -1, cnt = 0;
  F(i, 'a', 'z') t[i] = 0, qu[i].clear();
  F(i, 1, n) cin >> s[i], ++t[s[i]];
  F(i, 'a', 'z') if (t[i] >= n + 1 >> 1) zyq = i;
  if (zyq < 0) {
    F(i, 1, n) qu[s[i]].push_back(i);
    cnt = n >> 1; int tot = 0;
    F(i, 'a', 'z') for (auto it : qu[i]) p[++tot] = it;
    F(i, 1, n >> 1) ans[i].push_back(p[i]), ans[i].push_back(p[i + (n >> 1)]);
    if (n & 1) ans[1].push_back(p[n]);
  }
  else {
    if (t[zyq] == n) { return cout << "Shuiniao\n", void(); }
    if (t[zyq] == n - 1) {
      if ((n & 1) && s[n + 1 >> 1] != zyq)
        { return cout << "Shuiniao\n", void(); }
      cout << "Huoyu\n1\n" << n << " ";
      F(i, 1, n) cout << i << " ";
      return cout << "\n", void();
    }
    int l, r; cnt = 2;
    F(i, 1, n) if (s[i] != zyq) { l = i; break; }
    dF(i, n, 1) if (s[i] != zyq) { r = i; break; }
    ans[1].push_back(l), ans[2].push_back(r);
    F(i, l + 1, n) if (s[i] == zyq) ans[1].push_back(i);
    F(i, 1, l - 1) if (s[i] == zyq) ans[2].push_back(i);
    F(i, l + 1, r - 1) if (s[i] != zyq) ans[++cnt].push_back(i);
    F(i, 1, cnt) if (ans[i].size() < 2)
      if (ans[1].size() > 2) ans[i].push_back(ans[1].back()), ans[1].pop_back();
      else ans[i].push_back(ans[2].back()), ans[2].pop_back();
  }
  cout << "Huoyu\n" << cnt << "\n";
  F(i, 1, cnt) {
    cout << ans[i].size() << " ";
    sort(ans[i].begin(), ans[i].end());
    for (auto it : ans[i]) cout << it << " ";
    cout << "\n", ans[i].clear();
  }
}

int main() {
//   freopen("zyq.in", "r", stdin);
//   freopen("zyq.out", "w", stdout);
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  int c, _; cin >> c >> _; while (_--) mian();
  return 0;
}
```

---

## 作者：MatrixGroup (赞：24)

Solution from tester.

## Analysis

Consider an upper bound of $k$.

### When a majority of $s$ doesn't exist

Since a string of length $1$ must be a palindrome, $k$ must be no more than $\left\lfloor\dfrac n2\right\rfloor$. The following algorithm gives such a construction.

Define a **$k-$reduction** is to choose any mode of the $s$ and any other $k-1$ existing character(s) and make them as a subsequence, then delete them from the string. If $n$ is even, do **$2-$reduction** $\dfrac n2$ times. If $n$ is odd, do **$3-$reduction** once and then do **$2-$reduction** $\dfrac{n-3}2$ times. 

One can inductively proves that the algorithm is correct by the fact that after each step, a majority of $s$ still doesn't exist. One can implement the algorithm fast enough by maintaining characters by buckets.

### When a majority of $s$ exists

Let the indices of non-majority characters be $x_1,x_2,\cdots,x_\ell$. Since any string consisting with characters all the same must be a palindrome, $k$ must be no more than $\ell$.

#### When $\ell=0$

$k\le 0$, which means there is no solution.

#### When $\ell=1$

$k\le 1$, which means the only solution is to choose the whole string as a substring, if possible. Just check whether $x_1=\dfrac{n+1}{2}$.

#### When $\ell \ge 2$

The idea is the following: for most non-majority characters, pair them with one majority character each, and add the rest majority characters to some specific subsequences.

##### When $x_1=1$

For every $i=2,3,\cdots,\ell$, choose any majority character left to pair with. Add the rest majority characters to the subsequence containing $s_{x_1}$. Since $x_1=1$, the first character of the subsequence is $s_{x_1}$(non-majority), while the last is majority, therefore the construction is valid.

##### When $x_\ell =n$

For every $i=1,2,\cdots,\ell-1$, choose any majority character left to pair with. Add the rest majority characters to the subsequence containing $s_{x_1}$. Since $x_\ell=n$, the last character of the subsequence is $s_{x_\ell}$(non-majority), while the first is majority, therefore the construction is valid.

##### When $2\le x_i\le n-1$

Let $s_n$ pair with $s_{x_1}$, $s_1$ pair with $s_{x_\ell}$, and for $i=2,3,\cdots,\ell -1$, choose any majority character left to pair with.  For each majority character $s_j$ left, add it to the subsequence containing $s_{x_1}$, if $j>x_1$, otherwise $s_{x_\ell}$. Since $j\le x_1$ implies $j<x_l$, the last character of the subsequence containing $s_{x_\ell}$ is $x_\ell$(non-majority), while the first is majority, and the first character of the subsequence containing $s_{x_1}$ is $s_{x_1}$(non-majority), while the last is majority, therefore the construction is valid.

## Code

```
#include <bits/stdc++.h>
#define rep(i,n) for(int i=0,del##i##verme=int(n);i<del##i##verme;++i)
#define rep1(i,n) for(int i=1,parano##i##a=int(n);i<=parano##i##a;++i)
#define per(i,n) for(int i=int(n)-1;i>=0;--i)
#define per1(i,n) for(int i=int(n);i>=1;--i)
#define pb push_back
#define mp make_pair
#define fi first
#define se second
#define y0 LingLuo
#define y1 VividCycle
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
using namespace std;
const ll mod1=998244353;
const ll mod2=1000000007;
unsigned time_related_rand()
{
	return unsigned(std::chrono::steady_clock::now().time_since_epoch().count());
}
int c,t,n;
string s;
vector<int> idx[28];
vector<int> p,q;
int mod;
vector<int> ans[50004];int cnt;
void report()
{
	cout<<"Huoyu\n";
	cout<<cnt<<"\n";
	rep1(i,cnt)
	{
		cout<<ans[i].size();
		sort(ans[i].begin(),ans[i].end());
		for(int x:ans[i])cout<<" "<<x;
		cout<<'\n';
	}
	return ;
}
void Q()
{
	cin>>n>>s;
	rep1(i,26) idx[i].clear();
	rep(i,n) idx[s[i]&31].pb(i+1);
	mod=0;rep1(i,26) if(int(idx[i].size())*2>n) mod=i;
	rep1(i,n/2) ans[i].clear();
	cnt=0;
	if(mod==0)
	{
		if(n&1)
		{
			rep1(_,n/2)
			{
				int cur=1;rep1(i,26) if(idx[i].size()>idx[cur].size()) cur=i;
				int nxt=1;rep1(i,26) if(i!=cur&&!idx[i].empty()){nxt=i;break;}
				++cnt;
				if(_==1)
				{
					int lst=1;rep1(i,26) if(i!=nxt&&i!=cur&&!idx[i].empty()){lst=i;break;}
					ans[cnt].pb(idx[lst].back());idx[lst].pop_back();
				}
				ans[cnt].pb(idx[cur].back());idx[cur].pop_back();
				ans[cnt].pb(idx[nxt].back());idx[nxt].pop_back();
			}
		}
		else
		{
			rep1(_,n/2)
			{
				int cur=1;rep1(i,26) if(idx[i].size()>idx[cur].size()) cur=i;
				int nxt=1;rep1(i,26) if(i!=cur&&!idx[i].empty()){nxt=i;break;}
				++cnt;
				ans[cnt].pb(idx[cur].back());idx[cur].pop_back();
				ans[cnt].pb(idx[nxt].back());idx[nxt].pop_back();
			}
		}
		report();
		return ;
	}
	p.clear();q.clear();
	rep1(i,26) idx[i].clear();
	rep(i,n) if((s[i]&31)==mod) p.pb(i+1); else q.pb(i+1);
	if(q.empty())
	{
		cout<<"Shuiniao\n";return ;
	}
	if(int(q.size())==1)
	{
		if(q[0]*2-1==n)
		{
			cout<<"Shuiniao\n";return ;
		}
		cnt=1;
		rep1(i,n) ans[1].pb(i);
		report();
		return ;
	}
	if(q[0]==1)
	{
		for(int x:q) if(x!=1)
		{
			ans[++cnt].pb(x);
			ans[cnt].pb(p.back());p.pop_back();
		}
		ans[++cnt].pb(1);
		for(int x:p) ans[cnt].pb(x);
		report();
		return ;
	}
	if(q.back()==n)
	{
		for(int x:q) if(x!=n)
		{
			ans[++cnt].pb(x);
			ans[cnt].pb(p.back());p.pop_back();
		}
		ans[++cnt].pb(n);
		for(int x:p) ans[cnt].pb(x);
		report();
		return ;
	}
	int a=q.back();q.pop_back();
	int b=q.back();q.pop_back();
	ans[++cnt].pb(a);
	ans[++cnt].pb(b);ans[cnt].pb(n);
	p.pop_back();
	for(int x:q)
	{
		ans[++cnt].pb(x);ans[cnt].pb(p.back());p.pop_back();
	}
	for(int x:p)if(x<a) ans[1].pb(x); else ans[2].pb(x);
	report();
}
int main()
{
	ios_base::sync_with_stdio(false);cin.tie(0);
	cin>>c>>t;while(t--)Q();return 0;
}
```

---

## 作者：CarroT1212 (赞：9)

写篇题解庆祝一下成功自己做出了一道有一定价值的构造，~~虽然场上挂成 85 了~~。

没完整打比赛但跟着写了下这题。好像评级吵得挺凶的，个人感觉得紫，虽然不及喵了个喵但是细节也有点多。也可能是我做法复杂了。

+ upd：对比其它题解之后发现确实复杂了点。修了点锅。

和 NOIP2023 T3 一样，此类看上去比较构造的题目一般尝试从特殊性质下手。实际上这题两个特殊性质给得非常合适，基本上只要有意识地去顺着特殊性质想就不至于一点进展都没有。下面都是赛时思路。

---

### 初步观察

先把 $n=1$ 给毙了。

先根据样例无脑猜测一定存在所有子序列长度为 $2$ 或 $3$ 的解，看了眼大样例发现假了。

但最优情况确实是所有字母能以某种方式两两配对，使得没有任何一对字母相同，答案为 $\frac{n}{2}$。

感觉和性质 A 比较契合。开始思考它。

### 特殊性质 A

> 保证 $n$ 是偶数，且每个字符的出现次数不超过 $\frac{n}{2}$。

你猜测满足这个特殊性质的时候一定可以把字符两两配对（因为不满足的时候一定不行），再看眼大样例，发现 A 性质的答案确实都是 $\frac{n}{2}$。考虑怎么配。

随便配对显然是没有办法保证不把相同字符配到一起的。

由于 $n$ 是偶数，考虑把序列分成两部分再做。这里我第一反应是直接劈成左右两半，钦定所有的配对都是左半边配右半边，因为直觉告诉我们偏静态的问题要更好做。

再尝试让不合法的配对（即配对的两个字符相同）尽量少。那么左半边按字符字典序升序排序，右半边降序排序。这时将左右半边按顺序两两配对。如果你运气比较好的话可能直接所有配对都是合法的，但大部分时候还是会有一些配对匹配的两个字符是相同的。先别急着重开，注意到这里的一个性质：每一个不合法的配对重复的字符，只有一种。

换句话说，这么做配出来的不合法的配对中，不会有同时出现 `aa` 和 `bb` 之类的情况，最多就全是 `aa` 或者全是 `bb`，之类的。

设这个重复的字符是 $p$，那么更进一步地，不包含 $p$ 的合法配对个数一定不小于不合法配对（$pp$）数，因为 $p$ 的出现次数都不大于 $\frac{n}{2}$。那么直接拿出一些不包含 $p$ 的合法配对，把它们和不合法配对交换一下就都是合法的了。

+ 补充：这是场上第一时间想的一个复杂弱智做法，实际上我们只要把整个字符串排序然后劈成两半左右配对即可保证不重。不过这个复杂做法似乎可以更丝滑地推广到 B 性质。

（其实和 [ABC178F](https://www.luogu.com.cn/problem/AT_abc178_f) 非常像，不理解的话可以做做这个题）

比如 `abcbbabcba` 这个字符串，劈成两半分别排序得到 `abbbc` 和 `cbbaa`，配对得 `ac`,`bb`,`bb`,`ba`,`ca`，有两个不合法的配对，都是 `b`，而不包含 `b` 的合法配对有 `ac`,`ca`，那么把两个 `bb` 和它们置换一下（交换后一个字符）就可以得到 `ab`,`bc`,`cb`,`ba` 了。

我挂成 85 的死因就是没有判合法配对不包含 $p$，直接拿了几个合法配对交换了一下，结果换完还是有不合法的，大样例没测出来。

这里可以先推广一下：如果 $n$ 是奇数怎么办？

想了一下发现没有很大影响，还是把序列劈成两半，但是中间留一个，最后随便把中间留的这个塞进某个配对里凑成长度为 $3$ 的子序列即可，因为两侧配对的两个字符不同所以把中间的字符加进去一定合法。

做点整理：

+ 序列劈成两半，左半边升序排序，右半边降序排序。
+ 左右两两配对。
+ 如果有不合法配对，那么它们的字符都是相同的。
+ 在合法配对中找到不包含这个字符的。
+ 将选出的合法配对和不合法配对进行置换。
+ 答案一定是 $\frac{n}{2}$。
  + 如果考虑 $n$ 是奇数的情况，那么劈成两半时留下中间那个，最后随便将其加入一个配对。

看起来挺复杂，不过场上想到这里大概耗时 3~4min。信心大增，再想下一个特殊性质。

### 特殊性质 B

> 只有 `a` 和 `b`。

设 `a` 个数为 $a$，`b` 个数为 $b$。

还是考虑尽量让字母两两配对。但是现在做不到了，因为只要 $a\neq b$ 就一定会有一个字母出现次数大于 $\frac{n}{2}$。$a=b$ 的情况是 A 性质，忽略，于是我们可以钦定 $a>b$。

注意这里 $b$ 的出现次数是不大于 $\frac{n}{2}$ 的。

还是跟性质 A 一样先看 $n$ 为偶数的情况试试。一样把序列劈成两半，

假设现在有这么一个序列 `aabaaa|babbaa`，中间的 | 表示把序列劈成两半。考虑找出一些合法子序列。或者是能不能先做一点配对。

比较容易发现，一定可以把左半边的 `b` 和右半边的 `a` 两两配对，左半边的 `a` 和右半边的 `b` 两两配对。因为 $b\le \frac{n}{2}$，两半 `a` 的个数一定是分别都足够和另一半的 `b` 配对的。

比如上面那个字符串，我们可以配对 $(3,8),(1,7),(2,9),(4,10)$。左右各剩下了 $2$ 个 `a`。

而且，配对完之后，左右两边剩余的 `a` 个数恰好都等于 $\frac{n}{2}-b\,(>0)$。显然我们不能让它们单走一个子序列，考虑怎么把它们解决掉。

这是简单的，直接挑一个之前找的配对，把两边剩下的 `a` 按顺序塞进去即可。因为两侧加入的 `a` 数量相同，这样一定没法出回文。唯一的无解情况是之前没找到配对，整个序列都是 `a`，显然无解。

子序列数恰好为 $b$。上面字符串的一组解是 `ba`,`ab`,`ab`,`aaabaa`。

$n$ 为偶数考虑完了来考虑 $n$ 为奇数。

还是一样把序列劈成两半，中间留一个。考虑 `aabaaa|a|babbaa`。

如果中间的是 `a`，那么也一样，把它和配对完后两边剩下的其它 `a` 一起塞进某个配对即可，显然也合法。

但如果中间是 `b`？

你满怀希望地尝试证明把它也塞进之前的配对是最优的，然后被 `abbaa` 卡掉了。说明最大子序列数应该还是 $b$，考虑怎么让中间这个 `b` 单走出一个非回文子序列。

显然我们不能把两边剩下的 `a` 跟它放一起，因为 `a` 两边个数相同，绝对是回文的。

考虑 `aabaaa|b|babbaa`，和之前一样，配对完之后左右各剩下了两个 `a`。

想到可以把右边的两个 `a` 放进左边的那个 `b` 的配对里形成新子序列 `baaa`，然后左边的两个 `a` 和中间的 `b` 接在一起得 `aab`。都是合法的。

当然还有一种情况是左边没有 `b`，那就反过来，(这里如果右边同时没有 `b` 就不合法了）左边剩下的 `a` 放进右边的一个 `b` 的配对里，右边剩下的 `a` 和中间的 `b` 接在一起。

至此我们讨论完了 B 性质的所有情况。也整理一下。

+ 钦定 $a>b$。不是就取反。
+ 将序列分成两半，如果 $n$ 是奇数就中间留一个。
+ 如果左右两半没有出现任何 `b`，无解。
+ 否则，将左半边的 `b` 和右半边的 `a`，左半边的 `a` 和右半边的 `b` 随意配对。左右各剩下 $\lfloor\frac{n}{2}\rfloor-b$ 个 `a`。
  + $n$ 是偶数：直接把剩下的 `a` 和某个配对放到一起。
  + $n$ 是奇数：
    + 中间是 `a`，把中间的 `a` 也随便加进一个配对。
    + 中间是 `b`：
      + 左半边有 `b`：右侧剩下的 `a` 放进左半边的某个 `b` 的配对中，左侧剩下的 `a` 和中间的 `b` 组到一起。
      + 左半边没有 `b`：反过来。
  + 答案一定是 $b$。

有点丑了。

### 正解

其实在想性质的时候就能猜到怎么推广了。有一个容易发现的事实：如果不满足 A 性质（不考虑 $n$ 的奇偶性），那么一定恰好只有一个字符的出现次数是大于 $\frac{n}{2}$ 的。你发现这好像莫名跟 B 性质对上了？

如果我们将这个不符合条件的字符看成是特殊性质 B 里的 `A`，其它的字符看成 `B`，那我们做一遍 B 性质的做法就可以通过此题了。（原问题的限制一定不会强于 B 性质。）

---

当时思考的过程确实基本上一点弯路都没走，上面就是我场上想过的全部内容了（如果有简单做法当我啥都没说），可能是因为和出题人的脑电波频率比较接近？

但不管怎样那两个特殊性质真的功不可没。

虽然想起来比较爽，代码不加简化写出来确实是史山，不过情况只要都列清楚了就不用调多久。

```cpp
#include <bits/stdc++.h>
#define pb push_back
#define fi first
#define se second
using namespace std; bool MEM;
using ll=long long; using ld=long double;
using pii=pair<int,int>; using pll=pair<ll,ll>;
const int I=1e9;
const ll J=1e18,N=1e5+7;
ll n,cnt[28],c[N],has[N];
char str[N];
void mian() {
	memset(cnt,0,sizeof(cnt));
	scanf("%lld%s",&n,str+1);
	if (n==1) return cout<<"Shuiniao\n",void();
	for (ll i=1;i<=n;i++) cnt[str[i]-'a']++;
	if (*max_element(cnt,cnt+26)<=n/2) {
		vector<pll> ans;
		iota(c+1,c+n+1,1);
		sort(c+1,c+n/2+1,[](ll x,ll y){return str[x]<str[y];});
		sort(c+n-(n/2)+1,c+n+1,[](ll x,ll y){return str[x]<str[y];});
		vector<ll> v[2];
		for (ll i=1,j=n;i<=n/2;i++,j--) {
			ans.pb({c[i],c[j]});
			v[str[c[i]]==str[c[j]]].pb(i-1);
		}
		for (ll i=0,j=0;i<v[1].size();i++) {
			while (str[ans[v[0][j]].se]==str[ans[v[1][i]].se]||str[ans[v[0][j]].fi]==str[ans[v[1][i]].fi]) j++;
			swap(ans[v[0][j]].se,ans[v[1][i]].se);
		}
		cout<<"Huoyu\n"<<n/2<<"\n";
		if (n&1) cout<<"3 "<<ans[0].fi<<" "<<n/2+1<<" "<<ans[0].se<<"\n";
		else cout<<"2 "<<ans[0].fi<<" "<<ans[0].se<<"\n";
		for (ll i=1;i<n/2;i++) {
			cout<<"2 "<<ans[i].fi<<" "<<ans[i].se<<"\n";
			if (str[ans[i].fi]==str[ans[i].se]) assert(0);
		}
	}
	else {
		ll p=max_element(cnt,cnt+26)-cnt,flg=1;
		for (ll i=1;i<=n;i++) str[i]=str[i]-'a'==p?'a':'b',has[i]=0;
		for (ll i=1;i<=n/2&&flg;i++) flg&=str[i]=='a'&&str[n-i+1]=='a';
		if (flg) return cout<<"Shuiniao\n",void();
		vector<pll> ans[2]; vector<ll> a[2];
		for (ll i=1,j=n-n/2+1;i<=n/2;i++) if (str[i]=='b') {
			while (str[j]=='b') j++;
			ans[0].pb({i,j}),has[i]=has[j]=1,j++;
		}
		for (ll i=n-n/2+1,j=1;i<=n;i++) if (str[i]=='b') {
			while (str[j]=='b') j++;
			ans[1].pb({j,i}),has[i]=has[j]=1,j++;
		}
		for (ll i=1;i<=n/2;i++) if (str[i]=='a'&&!has[i]) a[0].pb(i);
		for (ll i=n-n/2+1;i<=n;i++) if (str[i]=='a'&&!has[i]) a[1].pb(i);
		cout<<"Huoyu\n";
		ll cnt=0;
		if (n&1^1) {
			cout<<ans[0].size()+ans[1].size()<<"\n";
			for (ll o=0;o<2;o++) for (pll i:ans[o]) {
				if (!cnt) {
					vector<ll> v;
					v.pb(i.fi),v.pb(i.se);
					for (ll j=0;j<2;j++) for (ll k:a[j]) v.pb(k);
					sort(v.begin(),v.end());
					cout<<v.size()<<" ";
					for (ll i:v) cout<<i<<" "; cout<<"\n";
					cnt++;
				}
				else cout<<"2 "<<i.fi<<" "<<i.se<<"\n";
			}
		}
		else {
			if (str[n/2+1]=='a') {
				cout<<ans[0].size()+ans[1].size()<<"\n";
				for (ll o=0;o<2;o++) for (pll i:ans[o]) {
					if (!cnt) {
						vector<ll> v;
						v.pb(i.fi),v.pb(i.se),v.pb(n/2+1);
						for (ll j=0;j<2;j++) for (ll k:a[j]) v.pb(k);
						sort(v.begin(),v.end());
						cout<<v.size()<<" ";
						for (ll i:v) cout<<i<<" "; cout<<"\n";
						cnt++;
					}
					else cout<<"2 "<<i.fi<<" "<<i.se<<"\n";
				}
			}
			else {
				cout<<ans[0].size()+ans[1].size()+1<<"\n";
				for (ll o=0;o<2;o++) for (pll i:ans[o]) {
					if (!cnt) {
						vector<ll> v[2];
						v[o].pb(i.fi),v[o].pb(i.se),v[o^1].pb(n/2+1);
						for (ll j=0;j<2;j++) for (ll k:a[j]) v[j^o^1].pb(k);
						for (ll j=0;j<2;j++) {
							sort(v[j].begin(),v[j].end());
							cout<<v[j].size()<<" ";
							for (ll i:v[j]) cout<<i<<" "; cout<<"\n";
						}
						cnt++;
					}
					else cout<<"2 "<<i.fi<<" "<<i.se<<"\n";
				}
			}
		}
	}
}
bool ORY; int main() {
//	freopen("anti2.in","r",stdin);
//	freopen("anti.in","r",stdin);
//	freopen("anti.out","w",stdout);
//	while (1)
	int t,type; for (scanf("%d%d",&type,&t);t--;)
	mian();
	cerr<<"\n"<<abs(&MEM-&ORY)/1048576<<"MB";
	return 0;
}
```

---

## 作者：ykzzldz (赞：5)

这题的特殊性质是比较有启发性的，于是我们从特殊性质入手。

### Part 1：判断是否有解（40pts）

先说结论，当且仅当一个字符串形如 $s+c+s$ 时无解，其中 $s$ 表示**若干个相同字母**构成的字符串，$c$ 表示**单个**字母。我们在给出构造时进行证明。

分两种情况讨论：

1. 字符串本身不回文，直接输出即可

2. 找到第一个不构成回文的两个位置 $i,j(i<j)$，则子序列 $(1,2,\dots,i-1,i+1,\dots,j)$ 和 $(i,j+1,j+2,\dots,n)$ 不回文。

容易发现，不能用上述方法构造出的只有前文提到的那种字符串，于是我们就得到了 $40$ 分。

### Part 2：特殊性质 A（15pts）

这部分比较简单，只要每次取出出现次数最大和次大的两个不同的字符构成一个子序列即可，答案为 $\frac{n}{2}$。

### Part 3：特殊性质 B（30pts）

这表明至少有一种字母达到了 $\lceil{\frac{n}{2}}\rceil$，可以发现，这恰好与特殊性质 A 是对立的。

设这个达到 $\lceil{\frac{n}{2}}\rceil$ 的字母为 $a$，当 $b$ 的个数为 $2$ 时，可以简单构造出形如 $aaaab$ 和 $baaaa$ 这样的东西。考虑推广，当 $b$ 的个数为 $x$ 时，可以将一个多余的 $b$ 和一个 $a$ 拼在一起形成形如 $ab$ 或 $ba$ 的东西。于是，答案即为 $b$ 的数量。

### Part 4：正解（100pts）

由上面的两个特殊性质，我们的算法大致成型。设 $k=\max(num_a,num_b,\dots,num_z)$，其中 $num_s$ 表示字母 $s$ 的出现次数。则答案一定是小于 $m=\min(\frac{n}{2},n-k)$ 的。

所以，当字符串中有字母的数量达到 $\lceil{\frac{n}{2}}\rceil$ 时，跑特殊性质 B 的做法，否则跑特殊性质 A 的做法。

有一些细节需要注意，在跑特殊性质 A 算法的时候，如果 $n$ 为奇数，需要将最后一个数插入一个另外的子序列中。在跑特殊性质 B 算法的时候，只需要将其他字母当成 $b$ 即可。

### Part 5：随机化（？pts）

首先，我们可以构造出 $m$ 个长度为 $2$ 的子区间，然后把剩下的字符**随机插入**已经分好的子区间中。考虑到题目所给的非回文串的条件其实是较好满足的，所以随机化其实是有正确性的。

---

## 作者：xieziheng (赞：2)

赛时由于脑残，特判一个长度为奇数的串是否除了中间全相等写成了判回文串于是喜提 $45$ 分。不得不说，没爆零是运气真好。

首先注意到一下事实：

- 最优拆分一定满足，每个子序列里恰好出现两种字符。证明显然，若只有一种不合法，$\geq 3$ 中一定可以继续拆。

- 进一步，最优的划分中一定有一种字符只出现一次，证明同理。

- 根据上一步结论，我们可以得到，所有不合法的串一定形如：全相等；或者长度为奇数且除了中间全相等。

- 最多只有一个子序列长度大于 $2$。可以反正然后发现更优。

于是考虑贪心。从小到大枚举每一位，找到后面出现次数最多的那种字符匹配。这个证明可能比较陶，不过感性理解还是很显然的。

维护过程也很陶，具体来说，有一下几种情况。

设 $t$ 表示当前位以及之后尚未被匹配的位形成的字符串。

- 只剩两种字符，且有一种只出现一次：只能全取。

- 只剩两种字符，且有一种字符出现次数为 $2$：分类讨论是哪一种出现 $2$ 次，然后一定有一个可以匹配使得匹配完的串还合法。

- 只剩三种字符，且当前这位只出现一次，还有一种字符也只出现一次：跟上面那个类似。


以上过程可以对每种字符开个 ```set``` 再开个树状数组维护每个位前面还没匹配掉的位数维护。细节过多了。

喜提最劣解。

```cpp
#include <bits/stdc++.h>
#define il inline
using namespace std;
const int N=1e5+5;
int sid,T,n,m,ck,a[N],k,in[26];char s[N];
int tree[N];
il void add(int x,int v){while(x<=n) tree[x]+=v,x+=(x&-x);}
il int get(int x){int ret=0;while(x) ret+=tree[x],x-=(x&-x);return ret;}
set<int> t[26],cur;
vector<int> e[N];
int x,y,z,u,v,w,p;
int main(){
    scanf("%d%d",&sid,&T);
    while(T--){
        scanf("%d%s",&n,s+1);
        ck=1;for(int i=1;i<n;++i) ck&=(s[i]==s[i+1]);
        if(ck){puts("Shuiniao");continue;}
        if(n&1){
            ck=1;
            for(int i=1;i<(n>>1);++i) ck&=(s[i]==s[i+1]);
            for(int i=1;i<=(n>>1);++i) ck&=(s[i]==s[n-i+1]);
            if(ck){puts("Shuiniao");continue;}
        }
        m=0;for(int i=1;i<=n;++i) e[i].clear(),tree[i]=0;
        for(int i=0;i<26;++i) in[i]=0,t[i].clear();cur.clear();
        for(int i=1;i<=n;++i) ++in[s[i]-'a'],t[s[i]-'a'].insert(i),cur.insert(i);
        for(int i=1;i<=n;++i) add(i,1);
        for(int i=1;i<=n;++i){
            if(cur.find(i)==cur.end()) continue;
            ++m,k=cur.size();
            x=0,y=n;for(int j=0;j<26;++j) if(in[j]) ++x,y=min(y,in[j]);
            if((x==2 && y==1) || cur.size()<=3){
                for(int z:cur) e[m].push_back(z);
                break;
            }
            u=-1;for(int j=0;j<26;++j) if(j!=s[i]-'a' && (u<0 || in[j]>in[u])) u=j;
            v=s[i]-'a';
            if(x==2 && y<=2 && in[v]<=2){
                p=0,z=*(--t[v].end());int rk=get(z);
                w=*t[u].begin();
                if(!(k&1) || rk-2-(w<z)!=(k-3)/2) p=w;
                else{
                    w=*(--t[u].end());
                    if(!(k&1) || rk-2-(w<z)!=(k-3)/2) p=w;
                }
                e[m].push_back(i),e[m].push_back(p);
                cur.erase(i),cur.erase(p),t[v].erase(i),t[s[p]-'a'].erase(p);
                add(i,-1),add(p,-1),--in[v],--in[s[p]-'a'];
                continue;
            }
            if(x==2 && y<=2 && in[u]<=2){
                p=0,z=*t[u].begin(),w=*(--t[u].end());
                if(!(k&1) || get(w)-3!=(k-3)/2) p=z;
                else if(!(k&1) || get(z)-2!=(k-3)/2) p=w;
                e[m].push_back(i),e[m].push_back(p);
                cur.erase(i),cur.erase(p),t[v].erase(i),t[s[p]-'a'].erase(p);
                add(i,-1),add(p,-1),--in[v],--in[s[p]-'a'];
                continue;
            }
            if(x==3 && t[v].size()==1){
                w=n;for(int j=0;j<26;++j) if(in[j] && j!=v) w=min(w,in[j]);
                if(w<=1){
                    p=0,z=0;
                    for(int j=0;j<26;++j) if(j!=v && in[j]==1){z=*t[j].begin();break;}
                    int rk=get(z);
                    w=*t[u].begin();
                    if(!(k&1) || rk-2-(w<z)!=(k-3)/2) p=w;
                    else{
                        w=*(--t[u].end());
                        if(!(k&1) || rk-2-(w<z)!=(k-3)/2) p=w;
                    }
                    e[m].push_back(i),e[m].push_back(p);
                    cur.erase(i),cur.erase(p),t[s[i]-'a'].erase(i),t[s[p]-'a'].erase(p);
                    add(i,-1),add(p,-1),--in[v],--in[s[p]-'a'];
                    continue;
                }
            }
            p=*t[u].begin();
            e[m].push_back(i),e[m].push_back(p);
            cur.erase(i),cur.erase(p),t[s[i]-'a'].erase(i),t[s[p]-'a'].erase(p);
            add(i,-1),add(p,-1),--in[v],--in[s[p]-'a'];
        }
        puts("Huoyu");
        printf("%d\n",m);
        for(int i=1;i<=m;++i){
            printf("%d ",e[i].size());
            ck=1;for(int j=0;j<e[i].size();++j) ck&=(e[i][j]==e[i][e[i].size()-1-j]);
            for(int x:e[i]) printf("%d ",x);puts("");
        }
    }
    return 0;
}
```

---

## 作者：sunkuangzheng (赞：2)

非回文串的长度一定不是 $1$，考虑让字符两两配对以最大化 $k$ 的值，当然这不一定能做到。

我们希望配对完剩下的字符尽量少，所以不难想到每次取出现次数前两多的两个字符 $(x,y)$ 配对。

最终剩余的字符应当是若干个 $a$，回滚掉最后一次操作 $(b,c)$。记现在没有被选择的位置集合为 $S$。

- 如果 $b \ne a,c \ne a$，那么由于 $b,c$ 均只在 $S$ 中出现一次，$S$ 一定不回文。
- 否则不妨设 $c = a$。如果现在 $S$ 是回文的，则其回文中心一定是 $b$。考虑任选一个配对 $(x,y)$。
     - 如果 $x \ne a,y \ne a$，直接将一个 $S$ 里的 $a$ 扔进配对 $(x,y)$。
     - 否则假设 $x = a$。根据 $x$ 与 $b$ 的位置关系，交换 $x$ 与 $S$ 开头/结尾的 $a$。
     - 操作完后 $S$ 和 $(x,y)$ 都不是回文的。

容易证明这样构造的最优性。

```cpp
/**
 *    author: sunkuangzheng
 *    created: 13.10.2024 17:04:48
**/
#include<bits/stdc++.h>
#ifdef DEBUG_LOCAL
#include <mydebug/debug.h>
#endif
using ll = long long;
const int N = 5e5+5;
using namespace std;
int T,n,C; string s;
void los(){
    cin >> n >> s;
    vector<vector<int>> ct(26,vector<int>(0)),as; vector<int> id(n,-1);
    for(int i = 0;i < n;i ++) ct[s[i] - 'a'].push_back(i);
    for(int ro = 0;;ro ++){
        vector<int> p(26); iota(p.begin(),p.end(),0);
        sort(p.begin(),p.end(),[&](int x,int y){return ct[x].size() > ct[y].size();});
        int a = p[0],b = p[1];
        // debug(a,b);
        if(!ct[a].size()) break;
        if(ct[a].size() && ct[b].size()){
            int x = ct[a].back(); ct[a].pop_back();
            int y = ct[b].back(); ct[b].pop_back();
            id[x] = id[y] = ro; as.emplace_back(vector<int>{x,y});
        }else{
            assert(ct[a].size());
            if(!ro) return cout << "Shuiniao\n",void();
            auto lt = as.back(); as.pop_back();
            for(int x : lt) id[x] = -1; vector<int> pos; string t;
            for(int i = 0;i < n;i ++) if(id[i] == -1) pos.push_back(i),t += s[i];
            if(t == string(t.rbegin(),t.rend())){
                int fg = 0,p = pos[pos.size() / 2];
                for(int j = 0;j < n;j ++){
                    if(id[j] != -1){
                        int x = as[id[j]][0],y = as[id[j]][1];
                        if(s[x] - 'a' != a && s[y] - 'a' != a){
                            as[id[j]].push_back(pos.back()),pos.pop_back();
                            as.emplace_back(pos);
                        }else{
                            if(s[x] - 'a' != a) swap(x,y);
                            if(x <= p){
                                int r = pos.back(); pos.pop_back(),pos.push_back(x);
                                as[id[j]] = {y,r},as.emplace_back(pos);
                            }else{
                                int r = pos.front(); pos.erase(pos.begin()),pos.push_back(x);
                                as[id[j]] = {y,r},as.emplace_back(pos);
                            }
                        }
                        fg = 1; break;
                    }
                }
                if(!fg) return cout << "Shuiniao\n",void();
                else break;
            }else{
                as.emplace_back(pos); break;
            }
        }
    }
    for(int i = 0;i < as.size();i ++) sort(as[i].begin(),as[i].end());
    cout << "Huoyu\n" << as.size() << "\n";
    for(auto x : as){
        cout << x.size() << " ";
        for(int i : x) cout << i + 1 << " ";
        cout << "\n";
    }
}int main(){
    ios::sync_with_stdio(0),cin.tie(0);
    for(cin >> C >> T;T --;) los();
}   
```

---

## 作者：Shunpower (赞：2)

史诗级分讨王！写一篇题解纪念一下自己的恶臭做法。

---------------

容易想到（也可以通过观察样例）我们构造不回文串应当通过构造两个不同字符配对的方式，这样配对显然会达到答案上界，并且我们可以不关心这两个字符的位置，只要知道它们不相同就行了。

两两配对，容易想到应用绝对众数（出现次数严格大于一半的字符）。

### 如果不存在绝对众数

我们直接把所有字符按照在字母表中的顺序为第一关键字，所在位置为第二关键字排序，然后从中间掰开，从两半的最左边开始一一匹配。由于不存在绝对众数，这样配对完肯定不存在相同字符的配对。

唯一的问题是如果串长是奇数，最后会剩一个字符，但是可以发现这个字符和某一半的开头一定不是同一个字符（否则这两个字符之间都是相同的字符，就有绝对众数了）。所以直接把这个字符扔到两半开头的匹配里面构成一个长度为 $3$ 的非回文串就可以了。

很明显，因为非回文串的长度至少是 $2$，我们这样做一定给这种情况取到了上界。

### 如果存在绝对众数

令绝对众数那种字符是 $c$。其他字符统称为 $t$。

考虑每一个非回文串里面至少有两种字符，所以答案上界应该是所有 $t$ 的数量。

先判定掉 $t$ 的个数为 $0$ 的情况无解，也就是所有字符都一样。

考虑继承刚才的想法，我们继续一一匹配，但是这样造成的问题是最后剩下一堆 $c$，这些 $c$ 需要妥善处理。随便乱插回去可能导致一些匹配恰好变成奇回文串。

考虑如果剩下偶数个 $c$，我们可以直接插回去。因为每个匹配长度为 $2$，并且里面只有恰好一个非 $c$ 的字符，我们插偶数个 $c$ 回去绝不可能让它变成偶回文串。这种情况就解决了。

如果剩下奇数个 $c$，我们可以把第一对匹配拿出来，并且留下位置最靠后的一个 $c$，剩下的转化为偶数插到第一对匹配里面，考虑最后这一个怎么办。

考虑排除被回插的第一对匹配之后，如果存在 $tc$ 状的匹配（$t$ 在 $a$ 前面），那么我们可以直接把最后一个 $c$ 扔过去，$tcc$ 显然是不回文的。这种情况就解决了。

如果不存在，那么除了第一对匹配的所有匹配应该都长成 $ct$ 状，而第一对匹配现在应该形如 $ccc\dots ctccc\dots c$。

考虑如果不存在 $ct$ 状匹配，那么相当于整个串里面只能找出来一对匹配，也就是只有一个字符 $t$，其他全是 $c$。这种情况如果原串是回文就无解，否则答案就是原串，直接特判掉。

考虑存在 $ct$ 状匹配时怎么把它利用起来调整。我们考虑刻画第一对匹配的形态。

下面令第一对匹配的 $t$ 前面 $c$ 的个数为 $l$，后面 $c$ 的个数为 $r$。

#### 如果 $r=l$

可以发现这不可能发生，刚才的构造满足了第一对匹配不可能现在就是回文的。

#### 如果 $|r-l|>1$

此时直接把最后一个 $c$ 丢进第一对匹配绝不会使它成为回文串（偶回文串显然不行，奇回文串无法使得 $t$ 两边字符 $c$ 数量相同），所以直接丢进去就行。

#### 如果 $r=l+1$

此时 $t$ 右侧肯定存在 $c$，而现在等待插回去的最后一个 $c$ 肯定在所有 $c$ 的右侧（我们钦定了留下位置最靠后的一个 $c$）。所以直接插给第一对匹配是贡献给 $r$ 的，不会使得 $l$ 变大导致不合法。

#### 如果 $l=r+1$

考虑这最后一个 $c$ 相对 $t$ 的位置，如果在 $t$ 前面那就无所谓了，可以直接插回去贡献给 $l$，不会导致不合法。

麻烦的是在 $t$ 后面，我们回顾现在整个东西的形态应该是：

$$
c\dots ctc\dots c\ \ ct\ \cdots\ ct\ \ ct\ \ c 
$$

也就是被插回去的第一对匹配，若干个 $ct$，还有最后那个要插回去的字符。

经过一些尝试我们可以发现，我们可以魔改一下前两对匹配，然后把这最后一个字符带回去。我们把第一个匹配左边的 $c$ 拆下来，因为这些 $c$ 在第一个 $t$ 左边，所以肯定也在第二个 $t$ 左边，这样第一个匹配变成 $tc\dots c$，第二个匹配变成 $c\dots ct$，此时再把最后剩下的那个 $c$ 给第一个就行了。

于是所有情况全都考虑到了！直接做完了！想清楚了就很好写。

史山级代码：

```cpp
int id,tc;
int n;
char c[N];
int bol[26];
pair <char,int> d[N];
vector <int> pos;
vector <int> mch;
int maxn;
void solve(){
    cin>>n;
    maxn=0;
    pos.clear();
    mch.clear();
    fr1(i,0,25) bol[i]=0;
    fr1(i,1,n) cin>>c[i],d[i]=mp(c[i],i);
    fr1(i,1,n) bol[c[i]-'a']++;
    bool flg=1;
    fr1(i,0,25) flg&=(bol[i]<=n/2);
    fr1(i,0,25) maxn=max(maxn,bol[i]);
    sort(d+1,d+n+1);
    if(flg){
        if(n&1){
            cout<<"Huoyu\n";
            cout<<n/2<<'\n';
            fr1(i,2,n/2) cout<<"2 "<<min(d[i].se,d[i+n/2].se)<<" "<<max(d[i].se,d[i+n/2].se)<<'\n';
            int tmp[4];
            tmp[1]=d[1].se,tmp[2]=d[n/2+1].se,tmp[3]=d[n].se;
            sort(tmp+1,tmp+4);
            cout<<"3 "<<tmp[1]<<" "<<tmp[2]<<" "<<tmp[3]<<'\n';
        }
        else{
            cout<<"Huoyu\n";
            cout<<n/2<<'\n';
            fr1(i,1,n/2) cout<<"2 "<<min(d[i].se,d[i+n/2].se)<<" "<<max(d[i].se,d[i+n/2].se)<<'\n';
        }
    }
    else{
        if(maxn==n) return cout<<"Shuiniao\n",void();
        fr1(i,1,n){
            if(bol[c[i]-'a']==maxn) pos.pb(i);
            else mch.pb(i); 
        }
        // cout<<"!"<<pos.size()<<" "<<mch.size()<<'\n';
        int rem=mch.size();
        if((pos.size()-mch.size())&1){
            vector <vector<int>> ans;
            bool flg=0;
            fr1(i,1,mch.size()-1){
                // cout<<"?"<<pos[i]<<" "<<mch[i]<<endl;
                // vector <int> tmp;
                if(pos[i]<mch[i]) ans.pb({pos[i],mch[i]});
                else if(flg) ans.pb({pos[i],mch[i]});
                else ans.pb({pos[i],mch[i],pos.back()}),flg=1;
            }  
            vector <int> tmp;
            int lefa=0,riga=0;
            fr1(i,rem,(int)pos.size()-2) tmp.pb(pos[i]),lefa+=(pos[i]<mch[0]),riga+=(pos[i]>mch[0]);
            lefa+=(pos[0]<mch[0]),riga+=(pos[0]>mch[0]);
            tmp.pb(pos[0]);
            tmp.pb(mch[0]);
            ans.pb(tmp);
            if(!flg){
                if(ans.size()==1){
                    bool flg=0;
                    fr1(i,1,n/2) flg|=(c[i]!=c[n-i+1]);
                    if(flg){
                        cout<<"Huoyu\n";
                        cout<<"1\n";
                        cout<<n<<" ";
                        fr1(i,1,n) cout<<i<<" ";
                        cout<<'\n';
                    }
                    else return cout<<"Shuiniao\n",void();
                }
                else{
                    if(lefa==riga+1&&pos.back()>mch[0]){
                        ans.pop_back();
                        tmp.clear();
                        ans[0].pb(pos[0]);
                        fr1(i,rem,(int)pos.size()-2){
                            if(pos[i]<mch[0]) ans[0].pb(pos[i]);
                            else tmp.pb(pos[i]);
                        }
                        tmp.pb(mch[0]);
                        tmp.pb(pos.back());
                        ans.pb(tmp);
                        // cout<<"!"<<endl;
                    }
                    else if(lefa+1==riga&&pos.back()<mch[0]) throw("impossible");
                    else ans[ans.size()-1].pb(pos.back());
                    cout<<"Huoyu\n";
                    cout<<ans.size()<<'\n';
                    for(auto i:ans){
                        sort(i.begin(),i.end());
                        cout<<i.size()<<' ';
                        for(auto j:i) cout<<j<<' ';
                        cout<<'\n';
                    }
                }
            }
            else{
                cout<<"Huoyu\n";
                cout<<ans.size()<<'\n';
                for(auto i:ans){
                    sort(i.begin(),i.end());
                    cout<<i.size()<<' ';
                    for(auto j:i) cout<<j<<' ';
                    cout<<'\n';
                }
            }
        }
        else{
            vector <vector<int>> ans;
            fr1(i,1,mch.size()-1){
                // cout<<"?"<<pos[i]<<" "<<mch[i]<<endl;
                // vector <int> tmp;
                ans.pb({pos[i],mch[i]});
            }  
            vector <int> tmp;
            fr1(i,rem,pos.size()-1) tmp.pb(pos[i]);
            tmp.pb(pos[0]);
            tmp.pb(mch[0]);
            ans.pb(tmp);
            cout<<"Huoyu\n";
            cout<<ans.size()<<'\n';
            for(auto i:ans){
                sort(i.begin(),i.end());
                cout<<i.size()<<' ';
                for(auto j:i) cout<<j<<' ';
                cout<<'\n';
            }
        }
    }
}
// #define Shun cute
int main(){
#ifdef Shun
    freopen("anti2.in","r",stdin);
    freopen("anti.out","w",stdout);
#endif
    ios::sync_with_stdio(false);
    cin>>id>>tc;
    while(tc--) solve();
    ET;
}
//ALL FOR Zhang Junhao.
```

---

## 作者：Jorisy (赞：2)

感觉很牛的一个题。

我的做法比较唐，建议阅读楼上楼下更简洁的做法。

首先考虑没有绝对众数的情况。

不难想到将所有字母升序之后，将第 $i(1\le i\le \left\lceil\dfrac n2\right\rceil)$ 个和第 $i+\left\lceil\dfrac n2\right\rceil$ 个匹配，这样一定是不会匹配上相同的字母的（因为如果是相同的字母那么这个字母就得是绝对众数了）。而且是一定有解的。

然后考虑存在绝对众数的情况。

我们一定是希望可以规约到上一种情况的。

假设绝对众数出现了 $c$ 次，那么非众数的字母只有 $n-c$ 个。

如果我们尽可能地按上一种情况将众数字母和其他字母一一配对，那么必然会剩下有 $c-(n-c)+1=2c-n+1$ 个众数字母和同一个其他字母匹配。

为了避免过多的回文可能，我们考虑用众数子序列的一个长度为 $2c-n+1$ 的子段匹配。

那么我们可以钦定第一个非众数字母和哪个长度为 $2c-n+1$ 的众数序列子段匹配，只要保证这个非众数字母不恰好在子段下标中间即可。

然后就不难发现两种无解情况：
- $c=n$；
- $c+1=n$ 且 $s$ 回文。

于是就做完了。

进行一个赛时的史山代码展示：
```cpp
#include<bits/stdc++.h>
using namespace std;

string s;
vector<vector<int>>ans;
pair<int,int>a[100005];
int n,b[35],maxs,f[100005];

bool ispalin(string t)
{
    string k=t;
    reverse(k.begin(),k.end());
    return k==t;
}

void sol()
{
	cin>>n>>s;
	memset(b,0,sizeof(b));
	maxs=0;
	ans.clear();
	for(int i=0;i<n;i++) maxs=max(maxs,++b[s[i]-97]),f[i+1]=0;
	if(maxs*2>n)//存在绝对众数的情况
	{
        if(maxs==n||maxs+1==n&&ispalin(s))
        {
            puts("Shuiniao");
            return;
        }//无解情况
        char c;
        for(int i=0;i<26;i++)
        {
            if(b[i]==maxs)
            {
                c=i+97;
                break;
            }
        }
        s=' '+s;
        vector<int>v;
        for(int i=1;i<=n;i++)
        {
            if(s[i]==c)
            {
                f[i]=1;
                v.push_back(i);
            }
        }
        int l=0,r=maxs*2-n,p=1;
        while(f[p]) p++;
        int pos=lower_bound(v.begin(),v.end(),p)-v.begin();
        while(pos-l==r-pos+1) l++,r++;//寻找符合要求的众数序列的子段
        // cerr<<"D: "<<l<<','<<r<<' '<<p<<' '<<pos<<endl;
        for(int i=0;i<l;i++) f[v[i]]=0;
        for(int i=r+1;i<v.size();i++) f[v[i]]=0;
        vector<int>v0;
        for(int i=l;i<=r;i++) v0.push_back(v[i]);
        v0.push_back(p);
        f[p]=1;
        ans.push_back(v0);
        int m=0;
        for(int i=1;i<=n;i++)
        {
            if(f[i]) continue;
            a[++m]={s[i],i};
        }
        sort(a+1,a+m+1);
		for(int i=1;i+m/2<=m;i++)
		{
            if(i+m/2==m&&(m&1)) break;
			v0.clear();
			v0.push_back(a[i].second);
			v0.push_back(a[i+m/2].second);
            ans.push_back(v0);
		}
        if(m&1) ans[1].push_back(a[m].second);//特判奇数个的情况，下同
	}
	else
	{
		for(int i=0;i<n;i++) a[i+1]={s[i],i+1};
		sort(a+1,a+n+1);
		for(int i=1;i+n/2<=n;i++)
		{
            if(i+n/2==n&&(n&1)) break;
			vector<int>v;
			v.push_back(a[i].second);
			v.push_back(a[i+n/2].second);
            ans.push_back(v);
		}
		if(n&1) ans[0].push_back(a[n].second);
	}
    printf("Huoyu\n%d\n",ans.size());
    for(auto i:ans)
    {
        printf("%d ",i.size());
        sort(i.begin(),i.end());
        for(auto j:i) printf("%d ",j);
        puts("");
    }
}

int main()
{
	// freopen("anti.in","r",stdin);
	// freopen("anti.out","w",stdout);
	ios::sync_with_stdio(0);
	int c,t;
	cin>>c>>t;
	while(t--) sol();
	return 0;
}
```

---

## 作者：0xyz (赞：1)

注意到非回文串最短 $2$ 个字母，所以答案最大为 $\lfloor\frac{n}{2}\rfloor$。分类讨论，假设 $s$ 中出现次数最多的字母是 $x$，它出现了 $c_x$ 次。
- 如果 $c_x\le\frac{n}{2}$，那么答案就是 $\lfloor\frac{n}{2}\rfloor$，我们每次选择剩下字母中出现次数最多的 $2$ 个字母，然后将它们设置为一个新的非回文串。如果 $n$ 是奇数，最后的非回文串会有 $3$ 个不同的字母。
- 如果 $c_x>\frac{n}{2}$，不难发现答案最多为 $h=n-c_x$，这是因为只有字母 $x$ 的串必定回文。具体的构造需要为每个非 $x$ 的字符搭配一些 $x$。我的构造方法是为前 $h-1$ 个串均是一个 $x$ 搭配一个非 $x$ 字母，第 $h$ 个串是最后一个非 $x$ 字母搭配剩余 $c_x-h+1$ 个 $x$。此时前 $h-1$ 个串绝对不回文，检验最后一个串是否回文即可知道是否有解。当然这样有反例，所以我们可以 `random_shuffle` $x$ 的顺序，如果构造 $9$ 次，最后一个串都回文，那就无解；否则输出这 $h$ 个串即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int _=1e5+5;
int C,T,fl,n,a[26],c,op;
vector<int>b[26],d[26],f[_];
char s[_];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>C>>T;
	while(T--){
		cin>>n>>(s+1);fl=-1;op=0;
		for(int i=0;i<26;i++)a[i]=0,b[i].clear();
		for(int i=1;i<=n;i++)a[s[i]-'a']++,b[s[i]-'a'].push_back(i);
		for(int i=0;i<26;i++)
			if(a[i]*2>n)fl=i;
		if(~fl){
			for(int u=0;u<9;u++){
				c=0;
				for(int i=1;i<=n;i++)f[i].clear();
				for(int i=0;i<26;i++)d[i]=b[i],random_shuffle(d[i].begin(),d[i].end());
				for(int i=1;i<=n;i++)
					if(s[i]-'a'!=fl)f[++c].push_back(d[fl].back()),d[fl].pop_back(),f[c].push_back(i);
				while(d[fl].size())f[c].push_back(d[fl].back()),d[fl].pop_back();
				for(int i=1;i<=c;i++)sort(f[i].begin(),f[i].end());
				for(int i=0;i<f[c].size();i++)
					if(s[f[c][i]]!=s[f[c][f[c].size()-1-i]])op=1;
				if(op)break;
			}
			if(!op||!c)cout<<"Shuiniao\n";
			else{
				cout<<"Huoyu\n"<<c<<'\n';
				for(int i=1;i<=c;i++){
					cout<<f[i].size()<<' ';
					for(auto j:f[i])cout<<j<<' ';
					cout<<'\n';
				}
			}
		}else{
			cout<<"Huoyu\n"<<n/2<<'\n';
			for(int i=1;i<=n/2;i++){
				int mx=-1,sm=-1;
				for(int j=0;j<26;j++)
					if(a[j]>a[mx]||mx==-1)sm=mx,mx=j;
					else if(a[j]>a[sm]||sm==-1)sm=j;
				a[sm]--;a[mx]--;
				vector<int>e;
				e.push_back(b[mx].back());b[mx].pop_back();
				e.push_back(b[sm].back());b[sm].pop_back();
				if(n-i*2==1)
					for(int j=0;j<26;j++)
						if(a[j])e.push_back(b[j].back()),a[j]--;
				sort(e.begin(),e.end());
				cout<<e.size()<<' ';
				for(auto j:e)cout<<j<<' ';
				cout<<'\n';
			}
		}
	}
	return 0;
}
```

---

## 作者：AirQwQ (赞：1)

容易发现只有形如 ```aaa...aaaa``` 或 ```aaa...b...aaa```（ ```b``` 在正中间）才无解，先特判掉。

然后从部分分开始思考正解。

对于特殊性质 A （任何一个数出现不超过 $\frac{n}{2}$ 次）发现一定可以通过如下步骤构造出最优方案：

1. 按字符大小排序。
2. 将第 $i$ 各元素与第 $i+\frac{n}{2}$ 个数配对，注意需要使用排序前下标。
3. 若 $n$ 为奇数，将最后一个数放在第一组。

正确性证明：因为性质 A，同一个字母在排序后数组连续出现长度不超过 $\frac{n}{2}$，而区间 $[i,i+\frac{n}{2}]$ 的长度为 $\frac{n}{2}+1$，故两数必然不相等，不构成回文。类似的，第一个数一定不等于最后一个数，故 $n$ 为奇数同样成立。

最优性证明：单个字符显然不成立，故两两配对最优。

代码实现：

```cpp
sort(t+1,t+n+1,[](pii x,pii y)return x.fi>y.fi;});
int op=n%2;
for(int i=1;i<=n/2;i++){
	ans[++cnt].clear();
	ans[cnt].push_back(t[i].se);
	ans[cnt].push_back(t[i+n/2].se);
}
if(op) ans[cnt].push_back(t[n].se);
```
对于有绝对众数的情况可以沿用以上思想，为了方便表示，钦定 $x$ 为绝对众数，$m$ 为 $x$ 的个数。

1. 先取出 $n-m$ 个 $x$ 与其他配对，剩下 $2m-n$ 个$x$
2. 任取一个配好的对，放入 $2 \times  \left \lfloor \frac{2m-n}{2} \right \rfloor$ （不大于剩余 $x$ 个数的最大偶数）个 $x$。
3. 若 $2m-n$ 为偶数，操作结束；若为奇数，剩余一个 $x$，暴力找到满足条件的放进去就好了（要是运气不好都不满足就随机打乱每一个 $x$ 的配对字符直到满足不是回文串）。

正确性证明：第一步生成的二元组显然满足。接下来放进去偶数个，此时因为每个序列长度都是偶数，且除 $x$ 外的字符个数只有 $1$ 个，所以它们必然不是回文串。（最后一个是暴力找的就不过多赘述）

最优性证明：一个非回文串一定由至少两种字符组成。按照如上方法，每一个序列都只有 $1$ 个数不同于 $x$，故为最优情况。

代码简单就不放了。（只要不像我一样特判错了，交了两页才 A）

---

## 作者：luckydrawbox (赞：0)

[$\text{Link}$](https://www.luogu.com.cn/problem/P11190)

## 题意

将一个长度为 $n$ 的字符串 $s$ 划分为最多的子序列，使 $s$ 每个位置的字符恰好属于一个子序列且每个子序列中的字符按顺序组成的串不为回文串。要求判断有无解，若有解，给出最多的子序列个数 $k$ 和一种方案。

## 分析

单个字符肯定是回文串，所以非回文串至少要两个不同的字符，$k$ 的上界为 $\left\lfloor\frac{n}{2}\right\rfloor$。

先判掉一个显然无解的情况：字符全相同。剩下的就至少有两种字符，我们考虑能否将 $k$ 取到上界。

- 若出现次数最多的字符的数量不超过 $\left\lfloor\frac{n}{2}\right\rfloor$，显然我们可以找到 $\left\lfloor\frac{n}{2}\right\rfloor$ 对不同的字符，每次贪心地取出现次数最多的两个字符即可，可用堆维护。若最后还剩下一个，我们暴力看它能插入到哪个子序列中，能插就插。
- 若出现次数最多的字符的数量超过 $\left\lfloor\frac{n}{2}\right\rfloor$，不妨记这个字符为 $u$，出现次数为 $cnt_u$，此时答案上界为 $n-cnt_u$。此时也可分两种情况讨论：
- - 若 $n$ 为偶数，我们可以这样构造：把每个非 $u$ 字符与位置最前的未配对过的 $u$ 配对，把最后剩下的 $u$ 全扔到最后一个子序列中，由于每个子序列的长度均为偶数，所以一定不存在回文串。
- - 若 $n$ 为奇数，我们把 $n\le 3$ 的情况特判一下，否则，考虑多出来的一个怎么分配。考虑第一个非 $u$ 字符，我们尝试给他分配 $2$ 个 $u$，若有两个 $u$ 在它前面，就分配这两个，否则必然存在两个 $u$ 在它后面，匹配后面两个，这样它一定不会构成回文串。对于剩下的字符，按偶数的情况匹配即可。但是，这样会有一个特殊情况 $\texttt{uuuvuuu}$ 怎么分配都会存在回文串，直接判无解即可。

## 代码

代码很丑。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
long long read(){
	long long x=0,f=1;char ch=getchar();
	while(!isdigit(ch))
	{if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void write(long long x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
const int N=1e5+10;
int C,T,n,tot;
char s[N];
int cnt[27];
vector<int>chs[27];
vector<int>fan[N],e;
int id[N];
void printok(){
	puts("Huoyu");
	printf("%d\n",tot);
	for(int i=1;i<=tot;i++){
		printf("%d ",fan[i].size());
		for(auto x:fan[i]){
			printf("%d ",x);
		}
		puts("");
	}
}
bool cmp(int x,int y){
	return cnt[x]>cnt[y];
}
struct Node{
	int x;
	bool operator<(const Node u)const{
		return chs[x].size()<chs[u.x].size();
	}
};
priority_queue<Node>q;
void work1(){
	int cant=0;
	while(q.size())q.pop();
	for(int i=0;i<26;i++){
		if(chs[i].size()){
			q.push((Node){i});
		}
	}
	while(1){
		if(!q.size()){
			break;
		}
		int i=q.top().x;
		q.pop();
		if(!chs[i].size())break;
		if(!q.size()){
			cant=chs[i].back();
			break;
		}
		int j=q.top().x;q.pop();
		if(!chs[j].size()){
			cant=chs[i].back();
			break;
		}
		int x=chs[i].back(),y=chs[j].back();
		tot++;
		if(x>y)swap(x,y);
		fan[tot].push_back(x);
		fan[tot].push_back(y);
		chs[i].pop_back();chs[j].pop_back();
		if(chs[i].size())q.push((Node){i});
		if(chs[j].size())q.push((Node){j});
	}
	if(n&1){
		for(int i=1;i<=tot;i++){
			e=fan[i];
			e.push_back(cant);
			sort(e.begin(),e.end());
			if(s[e[0]]==s[e[2]])continue;
			fan[i]=e;break;
		}
	}
	printok();
}
void work2(int u){
	int tu=0;
	if(n&1){
		int t=0;
		for(int i=1;i<=n;i++){
			if(s[i]-'a'!=u){
				t=i;break;
			}
		}
		if(chs[u].size()==n-1){
			if(t==n/2+1){
				puts("Shuiniao");
			}
			else{
				tot=1;
				for(int i=1;i<=n;i++){
					fan[1].push_back(i);
				}
				printok();
			}
			return;
		}
		int l=0,r=chs[u].size()-1;
		if(t>2){
			tot=1;
			fan[1].push_back(1);
			fan[1].push_back(2);
			fan[1].push_back(t);
			tu=2;
			for(int i=0;i<26;i++){
				if(i==u)continue;
				while(chs[i].size()){
					int x=chs[i].back();
					chs[i].pop_back();
					if(x==t)continue;
					int y=chs[u][tu++];
					if(x>y)swap(x,y);
					tot++;
					fan[tot].push_back(x);
					fan[tot].push_back(y);
				}
			}
			for(;tu<chs[u].size();tu++){
				fan[tot].push_back(chs[u][tu]);
			}
			sort(fan[tot].begin(),fan[tot].end());
			//printf("case 2.1\n");
			printok();
		}
		else{
			tot=1;
			fan[1].push_back(t);
			fan[1].push_back(chs[u][r-1]);
			fan[1].push_back(chs[u][r]);
			r--;
			for(int i=0;i<26;i++){
				if(i==u)continue;
				while(chs[i].size()){
					int x=chs[i].back();
					chs[i].pop_back();
					if(x==t)continue;
					int y=chs[u][tu++];
					if(x>y)swap(x,y);
					tot++;
					fan[tot].push_back(x);
					fan[tot].push_back(y);
				}
			}
			for(;tu<r;tu++){
				fan[tot].push_back(chs[u][tu]);
			}
			sort(fan[tot].begin(),fan[tot].end());
			//printf("case 2.2\n");
			printok();
		}
	}
	else{
		for(int i=0;i<26;i++){
			if(i==u)continue;
			while(chs[i].size()){
				int x=chs[i].back();
				chs[i].pop_back();
				int y=chs[u][tu++];
				if(x>y)swap(x,y);
				tot++;
				fan[tot].push_back(x);
				fan[tot].push_back(y);
			}
		}
		for(;tu<chs[u].size();tu++){
			fan[tot].push_back(chs[u][tu]);
		}
		sort(fan[tot].begin(),fan[tot].end());
		//printf("case 1\n");
		printok();
	}
}
void solve(){
	bool flag=1;
	for(int i=2;i<=n;i++){
		if(s[i]!=s[i-1])flag=0;
	}
	if(flag){
		puts("Shuiniao");
		return;
	}
	if(n==2){
		puts("Huoyu");
		printf("1\n2 1 2\n");
		return;
	}
	if(n==3){
		if(s[1]==s[3]){
			puts("Shuiniao");
			return;
		}
		puts("Huoyu");
		printf("1\n3 1 2 3\n");
		return;
	}
	memset(cnt,0,sizeof(cnt));
	for(int i=0;i<26;i++)chs[i].clear();
	for(int i=1;i<=n;i++){
		cnt[s[i]-'a']++;
		chs[s[i]-'a'].push_back(i);
		fan[i].clear();
	}
	int mx=0,pos=0;
	tot=0;
	for(int i=0;i<26;i++){
		if(cnt[i]>mx){
			mx=cnt[i],pos=i;
		}
	}
	if(mx<=n/2){
		work1();
	}
	else work2(pos);
}
int main(){
	//freopen("anti2.in","r",stdin);
	//freopen("anti.out","w",stdout);
	C=read();T=read();
	int t1=0;
	while(T--){
		t1++;
		n=read();
		scanf("%s",s+1);
		/*if(t1!=4){
			continue;
		}*/
		solve();
	}
	return 0;
}
```

---

## 作者：M1saka16I72 (赞：0)

## 前言

> upd on 2024.10.16：发现了针对原思路的 hack，修改了不正确的特判部分

[更可爱的阅读体验](https://misaka16172.github.io/solution-p11190.html)

场上写了不用动脑子的 40pts 部分分，挂成 4pts。

比较恶心的分类讨论构造题，但个人觉得比 T2 T4 可做，反正都是我做不出来的题（？）

## 思路

发现这个题的限制似乎不是特别多，非常多的情况下都可以把不一样的字符两两配对，于是应当尽量使最终的解接近这种形式。

这个题的两个特殊性质极为友好，先从特殊性质入手。

先来看性质 A：考虑一张将每个字符出现次数从小到大排序的柱状图，发现如果每次取出其中出现次数最多的两个字符，这张柱状图将越来越平缓，由于保证每个字符出现次数 $\leq \frac{n}{2}$，每个字符最终都能够被配对。于是按照该思路使用大根堆等维护每个字符的出现次数并模拟即可。

将性质 A 的做法推广到串长为奇数的情况：将剩下的最后一个字符随便扔到一个子序列中即可。如果这样不合法，那么所有的 $\lfloor \frac{n}{2} \rfloor$ 个子序列中一定均含有该字符，加上本身后，与“每个字符出现次数 $\leq \lfloor \frac{n}{2} \rfloor$”的限制不符。于是我们解决了串中字符出现次数均 $\leq \lfloor \frac{n}{2} \rfloor$ 的情况。

发现性质 B 也很具有启发性：由于只有两种字符，除了出现次数相等的情况，其余情况出现次数较多的字符的出现次数均 $>\lfloor \frac{n}{2} \rfloor$。

不妨设串中 $\text{a}$ 的出现次数较多。首先特判掉只有一个 $\text{b}$ 居中且长度为奇数的情况，这一定是不合法的。其余情况下，由于不能存在全 $\text{a}$ 串，答案的上界为 $cnt_b$。

先尝试一个朴素的贪心策略：从左到右枚举每个 $\text{a}$，寻找其右边是否还存在 $\text{b}$，若存在则将它们配对。这个过程进行完之后，字符串只会剩下一段 $\text{b}$ 和一段 $a$，且这 $x$ 个 $a$ 一定是原串中最后 $x$ 个。

最后剩下了前缀若干个 $\text{b}$ 的情况是好解决的，由于 $\text{a}$ 出现次数更多，直接把 $\text{a}$ 挂在 $\text{b}$ 后面就做完了。那如果最后剩下的只有 $\text{a}$ 该如何解决呢？

先把后面存在配对过的 $\text{b}$ 的那些 $\text{a}$ 挂在后面的 $\text{b}$ 之前，形成的子序列形如 $\text{aaa...b}$，这样一来就只剩下了原串末尾的若干个 $\text{a}$。考虑将它们挂在 $\text{aaa...b}$ 之后。这时的限制很松，只要有一个子序列前缀 $\text{a}$ 的数量与当前还剩下的个数不同，就可以全部挂在其末尾；否则，挂一个 $\text{a}$ 在第一个子序列中，把剩下的 $\text{a}$ 挂在第二个子序列中即可。似乎做完了？

实际上还存在一种未考虑的 corner case，即后缀 $\text{a}$ 个数为 $1$ 且之前配对的子序列均为 $\text{ab}$ 的情况，进行最后一步操作是不合法的。此时将最后一个 $\text{a}$ 和倒数第二个 $\text{b}$ 配对，然后删除这两个字符，再对剩余的字符串进行原来的解法即可。

于是我们解决了仅有两种字符的问题。其余情况，将出现次数最多的字符当作 $\text{a}$，剩下都当作 $\text{b}$，与原来并无本质区别。

至此所有情况都被考虑周全。代码实现挺复杂的。

## 代码

[link](https://www.luogu.com.cn/paste/71nf6ofd)，写的很丑，仅供参考。

---


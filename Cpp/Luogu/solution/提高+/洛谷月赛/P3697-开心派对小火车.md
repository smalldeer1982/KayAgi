# 开心派对小火车

## 题目描述

Aqours铁路公司旗下有N个站，编号1,2,..,N。

有各停（各站停车）电车特急电车两种。特急车会在$S_1,S_2,...,S_M (1=S_1<S_2 <...<S_M=N)$，一共M个车站停车。


相邻的两站(即编号为i的车站和编号为$i+1$的车站，而不是特急电车停车的相邻的两站)之间，各停电车要运行A分钟，特急需要B分钟。我们认为列车一直匀速运行，不考虑停车和加减速。


现在要加一种快速电车，要求其停站覆盖所有的特急电车的停站，而相邻的两站要运行C分钟。为了要快，决定刚好停K个站（$K>M$，包括特急的所有车站）。如果一个站可以停多种电车，那么旅客可以在这一站换乘。不过只能向前坐车，不能往回坐。


你需要设计一种快速列车的设站方案，要求旅客在T分钟**乘车时间（等车和换乘时间不计）**内，可以从1号站到尽可能多数量的站。你只需要告知能有几站可以达到。


## 说明/提示

【样例解释】

可以设快速列车站为1/5/6/8/10。

2,3,4可以直接乘坐各停慢车，5可以乘坐快速列车，6,10可以乘坐特急列车，7可以到6转慢车，8可以到6传快速列车。9没办法在30分钟的乘车时间内到达

【数据范围】

对于20%的数据，$N \le 300, K-M=2, A \le 10^6 , T \le 10^9$

对于50%的数据，$N \le 1000$

对于100%的数据，$2 \le N \le 10^9, 2 \le M \le K \le 3000, 1 \le B < C < A \le 10^9, i \le T \le 10^{18}$


## 样例 #1

### 输入

```
10 3 5
10 3 5
30
1
6
10
```

### 输出

```
8
```

# 题解

## 作者：gdf_yhm (赞：5)

[P3697](https://www.luogu.com.cn/problem/P3697)

#### 前言

一道学校比赛的题，弄发双倍经验。

赛时想到是贪心，写一半发现写不下去。细节挺多。

另，后来发现的，[AT_joi2017ho_b](https://www.luogu.com.cn/problem/AT_joi2017ho_b)，注意加换行。

### 思路

贪心。

首先，不加快车时，能到达的车站应跟在特急车停的站之后。即对于 $s_i$ 和 $s_{i+1}$ 之间的 $j$，如果 $j$ 可以到达，从 $s_i$ 到 $j$ 的站都符合条件。

再考虑快车。

对于一个站，最快的到达方式是：先坐特急车到最近的站点，再坐快车到最近的站点，最后转慢车。这样 $m$ 个特急车停靠的站点将整条线路分成 $m-1$ 段，分别处理。

在一段之内，从 $s_i$ 出发只坐慢车最远可以到 $pos_1$,自身贡献 $pos_1-s_i+1$ 个站。如果要在这一段增设快车站，最优是设在 $pos_1+1$ 处，最远能到 $pos_2$，贡献 $res_2$ 是 $pos_2-pos_1$。以此类推。直到有 $pos_k \ge s_{i+1}$ 为止。

这样，每段会有一定数量的可以设快车站的点，分别有一定贡献。用优先队列，选出前 $k$ 大贡献即可。

### 实现

思路好想，实现难些。

注意：

- 在 $i$ 到 $j$ 之间有 $j-i+1$ 个点，$j-i$ 个间隔。
- $1$ 号点不算，终点单独算。
- 快车站包含特快车站，$k$ 要先减 $m$。

于是就写了一发：

```cpp
int n,m,k,a,b,c,t;
int pos,res,flag,ans;
int s[maxn];
priority_queue <int> q;

signed main(){
	scanf("%lld%lld%lld",&n,&m,&k);
	k-=m;
	scanf("%lld%lld%lld%lld",&a,&b,&c,&t);
	for(int i=1;i<=m;i++)scanf("%lld",&s[i]);
	for(int i=1;i<m;i++){
		pos=s[i];flag=0;
		while(pos<s[i+1]){
			if(t-(s[i]-1)*b-(pos-s[i])*c<0)break;
			res=(t-(s[i]-1)*b-(pos-s[i])*c)/a+1;
			if(pos+res>=s[i+1]){
				res=s[i+1]-pos;
				pos=s[i+1];
			}
			pos+=res;
			if(!flag){
				ans+=res;
				flag=1;
			}
			else	q.push(res);
		}
	}
	if(t>=(n-1)*b)ans++;
	while(!q.empty() && k){
		k--;
		ans+=q.top();
		q.pop();
	}
	printf("%lld",ans-1);
}
```

80分。MLE。

一组数据：

```
1000000000 2 3000
1000000000 1 2
1000000000
1
1000000000
```

在这里，会找出 $1000000000$ 个贡献为 $1$ 的点并入队。显然，后面是不需要那么多的。

又可以发现，在 每一段中，设置车站的贡献单调不增。所以，对于每一段，只需要入队前 $k$ 个贡献。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=30010;

int n,m,k,a,b,c,t;
int pos,res,cnt,ans;
int s[maxn];
priority_queue <int> q;

signed main(){
	scanf("%lld%d%d",&n,&m,&k);
	k-=m;
	scanf("%lld%lld%lld%lld",&a,&b,&c,&t);
	for(int i=1;i<=m;i++)scanf("%lld",&s[i]);
	for(int i=1;i<m;i++){
//		cout<<i<<" "<<s[i]<<endl;
		pos=s[i];cnt=0;
		while(pos<s[i+1]){
			++cnt;
			if(t-(s[i]-1)*b-(pos-s[i])*c<0)break;
			res=(t-(s[i]-1)*b-(pos-s[i])*c)/a+1;
			if(pos+res>=s[i+1]){
				res=s[i+1]-pos;
				pos=s[i+1];
			}
			pos+=res;
			if(cnt==1){
				ans+=res;
//				cout<<ans<<endl;
			}
			else{
				q.push(res);
//				cout<<res<<endl;	
			}
			if(cnt>k+1)break;
//			cout<<res<<" "<<pos<<endl;
		}
	}
	if(t>=(n-1)*b)ans++;
//	cout<<ans<<endl;
	while(!q.empty() && k){
		k--;
		ans+=q.top();
		q.pop();
//		cout<<ans<<endl;
	}
	printf("%lld",ans-1);
}
```


---

## 作者：Day_Dreamer_H (赞：1)

# P3697 题解

~~好像是双倍经验~~

首先我们要去某个站的时候肯定是从快的做到最近，再转乘做到最近，再转乘，这样时间肯定是最短的。

那我们怎么分配准快车站呢，应该是在没建站之前花费时间正好大于 $T$ 时新建一个站，这样我们转乘的时候就可以从那个准快车站再重新向外拓展，新拓展的站点就是在这里建的价值，丢进优先队列不断拿出来即可。

拓展的时候有一些小细节：不能拓展过下一个快车站那里，拓展不能超过最后一个站点。

然后只要拓展 $K-M$ 个站点就可以了。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,k;
long long a,b,c;
long long t;
long long s[30005];
priority_queue<long long>q;
long long val,result;
int main(){
	cin>>n>>m>>k;
	cin>>a>>b>>c;
	cin>>t;
	k-=m;
	for(int i = 0;i<m;i++){
		cin>>s[i];
	}
	for(int i = 0;i<m-1;i++){
		int counter = 0,cur = s[i];
		while(cur<s[i+1]){
			counter++;
			long long lst = t-(s[i]-1)*b-(cur-s[i])*c;
			if(lst<0){
				break;
			}
			val = lst/a+1;
			if(cur+val>=s[i+1]){//超过最后一个站点了
				val = s[i+1]-cur;
				cur = s[i+1];
			}
			cur+=val;
			if(counter == 1){
				result+=val;
			}else{
				q.push(val);
			}
			if(counter>k+1){
				break;
			}
		}
	}
	if(t>=(n-1)*b){//最后一个站点可以直接做最快的到站那就加一个
		result++;
	}
	while(q.size()&&k){//取k-m个即可
		k--;
		result+=q.top();
		q.pop();
	}
	cout<<result-1<<endl;
}
```

---

## 作者：zzhhtt (赞：1)

M,K只有3000，从这找突破口，根据特急列车停靠点，把站分为M个块，计算每个块内增加一个快速列车站能增加的到达个数，放入堆中，每次取出堆顶并维护，取K-M个就可以了。详见代码。


```
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#define ll long long
struct seg{ll st,ed,m,t;}tr[100005];
ll n,m,k,a,b,c,T,len;
ll s[3005];
using namespace std;
inline ll read()
{
    ll x=0LL;char ch=getchar();
    while (ch<'0'||ch>'9'){ch=getchar();}
    while (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x;
}

ll query_s(ll t,ll l,ll r)
{
    if (l>r) return l;
    if ((ll)t+(ll)(r-l)*a<=T) return r+1;
    else return (T-t)/a+l+1;
}

ll query_m(ll t,ll l,ll r)
{
    if (l>r) return 0;
    if (t>T) return 0;
    if ((ll)t+(ll)(r-l)*a<=T) return r-l+1;
    else return (T-t)/a+(t<=T);
}

void shift_up(ll st,ll ed,ll t,ll m)
{
    len++;
    int p=len;
    tr[p].t=t;
    tr[p].m=m;
    tr[p].st=st;
    tr[p].ed=ed;
    while (p/2>0)
    {
        if (tr[p].m<=tr[p/2].m) break;
        swap(tr[p],tr[p/2]);
        p=p/2;
    }
}

void shift_down()
{
    tr[1]=tr[len];
    len--;
    int p=1;
    while (p*2<=len)
    {
        if (p*2+1>len||tr[p*2].m>tr[p*2+1].m) p=p*2;else p=p*2+1;
        if (tr[p].m<=tr[p/2].m) break;
        swap(tr[p],tr[p/2]);
    }
}

int main()//错了一万遍。。
{
    n=read();m=read();k=read();
    a=read();b=read();c=read();
    T=read();
    for (int i=1;i<=m;i++)
    {
        s[i]=read();
    }
    ll ans=(ll)((ll)s[m]*b-b<=T);
    for (int i=1;i<=m-1;i++)
    {
        ll tim=(ll)s[i]*b-b;
        ans+=query_m(tim,s[i],s[i+1]-1);
        ll p=query_s(tim,s[i],s[i+1]-1);
        tim+=(ll)(p-s[i])*c;
        ll num=query_m(tim,p,s[i+1]-1);
        if (p<=s[i+1]-1&&tim<=T) shift_up(p,s[i+1]-1,tim,num);
    }
    k-=m;
    while (k--&&len)
    {
        ans+=tr[1].m;
        ll tim=(ll)tr[1].t;
        ll s=query_s(tim,tr[1].st,tr[1].ed);
        tim+=(ll)(s-tr[1].st)*c;
        ll num=query_m(tim,s,tr[1].ed);
        ll e=tr[1].ed;
        shift_down();
        if (s<=e&&tim<=T) shift_up(s,e,tim,num);
    }
    printf("%lld",ans-1);
    return 0;
}
```


---

## 作者：skylee (赞：0)

小小的广告：<http://skylee03.cnblogs.com/p/6853537.html>

思路：


贪心。首先从起点出发，开特急电车，对于每一个特急车站si，分别下一次车，计算从当前车站si出发坐各停电车在指定时限内t最远能够到达的车站ri，并保证这个ri不会超过si+1。将得到的站点ri放入一个大根堆中，堆中的每个元素记录两个值，第一个用来保存如果在当前站点开通快速电车，从当前站点坐快速电车总共能到达的站的个数；第二个用来保存当前站的编号ri。最后不断地从堆中挑选最优的站，重复拓展到新的站点，并将新的站点放入堆中。用ans保存能够经过的站的个数，注意最后一个站并不能到达，因此ans初值为−1。


优化：


用pb\_ds的优先队列(3ms)比stl的优先队列(0ms)快。


---

## 作者：ditoly (赞：0)

先计算出不设快车站（或者说先设m个快车站覆盖特急车站）时能到达哪些站，显然要到这些站是先做特急车然后再坐一段慢车，于是我们可以算出从每个特急站下车坐慢车能到的最远的站（但要在下一个特急站之前，为了不重复统计），现在如果要新建一个快车站，自然我们应该建在某个从特急站下车后坐慢车能到的最远的站的下一个站，这样我们从特急站下车后就能直接搭上快车坐到这个站再坐慢车，我们先对每个候选的站都先算出建了这个站后能新到多少站，扔到堆里，每次我们取出最大的建，建了这个站后我们得到一种新的选择，就是在这个快车站下车后坐慢车能到的站的后一个站再建一个快车站，我们重新算一遍再扔回堆里即可。总复杂度O(klogk)，实际上不用堆打个暴力找最大也能过嘛。


参见 http://www.cnblogs.com/ditoly/p/Luogu-2017-4-R1.html


---


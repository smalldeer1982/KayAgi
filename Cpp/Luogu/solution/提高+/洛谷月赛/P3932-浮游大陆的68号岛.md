# 浮游大陆的68号岛

## 题目背景

浮游大陆的 $68$ 号岛，位于浮游大陆的边境地带。平时很少有人造访。

岛上被浓厚的森林覆盖。

![](https://cdn.luogu.com.cn/upload/pic/9282.png) 

在这座边境地区不起眼的浮游岛上，建立着神秘的”兵器“管理仓库——妖精仓库。


## 题目描述

妖精仓库里生活着黄金妖精们，她们过着快乐，却随时准备着迎接死亡的生活。

换用更高尚的说法，是随时准备着为这个无药可救的世界献身。


然而孩子们的生活却总是无忧无虑的，幼体的黄金妖精们过着天真烂漫的生活，自然也无暇考虑什么拯救世界之类的重任。

![](https://cdn.luogu.com.cn/upload/image_hosting/qxdahsft.png)

有一天小妖精们又在做游戏。这个游戏是这样的。

妖精仓库的储物点可以看做在一个数轴上。每一个储物点会有一些东西，同时他们之间存在距离。

每次他们会选出一个小妖精，然后剩下的人找到区间$[l,r]$储物点的所有东西，清点完毕之后问她，把这个区间内所有储物点的东西运到另外一个仓库的代价是多少？

比如储物点$i$有$x$个东西，要运到储物点$j$，代价为


$$x \times \mathrm{dist}( i , j )$$


dist就是仓库间的距离。

当然啦，由于小妖精们不会算很大的数字，因此您的答案需要对19260817取模。

![](https://cdn.luogu.com.cn/upload/pic/9294.png)


## 说明/提示

对于30%的数据，$n , m \le 1000$

对于另外20%的数据，所有储物点间的距离都为1

对于另外20%的数据，所有储物点的物品数都为1

对于100%的数据 ,$ n , m \le 200000 ; a_i , b_i <= 2\cdot 10^9$


## 样例 #1

### 输入

```
5 5
2 3 4 5
1 2 3 4 5
1 1 5
3 1 5
2 3 3
3 3 3
1 5 5
```

### 输出

```
125
72
9
0
70```

# 题解

## 作者：公主殿下MIKU (赞：18)

第一次发题解。

此题暴力肯定不行，需要用前缀和和后缀和来优化。

用sum1[i]表示将从1号仓库到i-1号仓库的物品全转移到i号仓库的代价；

dis1[i]表示从1号仓库到i号仓库的距离；

tot1[i]表示从1号仓库到i号仓库的全部物品的个数；

sum2[i]表示将从n号仓库到i+1号仓库的物品全转移到i号仓库的代价；

dis2[i]表示从n号仓库到i号仓库的距离；

tot2[i]表示从n号仓库到i号仓库的全部物品的个数.

l r与x的关系有三种情况:

①如果x在r右边，将l r移动到x需要从前向后运（前缀和）则有：
(suml[r]-suml[l])将1到 l从l移动到 r，
-totl[l-1]*(disl[r]-disl[l])减去将1到l-1从l移动到r，
+(totl[r]-totl[l-1])*(dis1[x]-disl[r])加上将l到r从r移动到x；

②如果x在l左边，将l r移动到x需从后向前运（后缀和）则有：
(sum2[l]-sum2[r])将n到 r从r移动到 l，
-tot2[r+1]*(dis2[l]-dis2[r])减去将n到r+1从r移动到l，
+(tot2[l]-tot2[r+1])*(dis2[x]-dis2[l])加上将r到l从l移动到x；

③如果x在l和r中间，l到x从前向后运（前缀和），r到x从后向前运(后缀和)：
sum1[x]-sum1[l-1] 将1到l从l移动到x，
+sum2[x]-sum2[r+1]将n到r从r移动到x，
-tot1[l-1]*(dis1[x]-dis1[l-1])减去将 1到l从l移动到x，
–tot2[r+1]*(dis2[x]-dis2[r+1])减去将n到r从r移动到x。

同时,还要注意不断取模，不要到最后再模，以防爆long long。

代码的话，就自己写吧。

---

## 作者：hongzy (赞：16)

这题先把式子写出来，然后利用和式的简单性质进行化简.

用$d(i)$表示点$i$到目标点$1$的距离，$a(i)$表示点上的物品数

若在目标点$x$左边的区间为 \[$l_1, r_1$\]，在$x$右边的区间为 \[$l_2, r_2$\]

对于左边的物体，答案为：

$\sum_{i=l_1}^{r_1} (d(x)-d(i)) * a(i)$

$=\sum_{i=l_1}^{r_1} (d(x) * a(i) - d(i) * a(i))$

$=\sum_{i=l_1}^{r_1} d(x) * a(i) - \sum_{i=l_1}^{r_1}d(i) * a(i)$


$=d(x)*\sum_{i=l_1}^{r_1} a(i) - \sum_{i=l_1}^{r_1}d(i) * a(i)$

上面这个式子可以利用**前缀和** $O(1)$ 得到，因为**求和项只与$i$本身有关**.

对于右边的物体，答案基本一样，位置调换一下：

$\sum_{i=l_2}^{r_2} (d(i)-d(x)) * a(i)$

$=\sum_{i=l_2}^{r_2} (d(i) * a(i) - d(x) * a(i))$

$=\sum_{i=l_2}^{r_2} d(i) * a(i) - \sum_{i=l_2}^{r_2}d(x) * a(i)$

$=\sum_{i=l_2}^{r_2}d(i) * a(i) - d(x)*\sum_{i=l_2}^{r_2} a(i)$

同样，上面这个式子也可以利用前缀和 $O(1)$ 得到.

就这样，读入的时候预处理一下，每次询问就可以 $O(1)$ 解决了.

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

typedef long long LL;

const LL MOD = 19260817;
const int MAXN = 200010;

int n, m;
LL d[MAXN], a[MAXN]; 
LL sum_a[MAXN], sum_d[MAXN], sum_mul[MAXN];

LL calc_ans(int x, int l, int r, bool left) {
	if(l > r) return 0;
	LL ans1 = ((sum_a[r] - sum_a[l-1]) % MOD + MOD) % MOD;
	ans1 = ans1 * sum_d[x] % MOD;
	LL ans2 = ((sum_mul[r] - sum_mul[l-1]) % MOD + MOD) % MOD;
	if(!left) swap(ans1, ans2);
	return ((ans1 - ans2) % MOD + MOD) % MOD;
}


int main() {
	scanf("%d%d", &n, &m);
	for(int i=2; i<=n; i++) {
		scanf("%lld", &d[i]);
		sum_d[i] = (sum_d[i-1] + (d[i] %= MOD)) % MOD;
	}
	for(int i=1; i<=n; i++) {
		scanf("%lld", &a[i]);
		sum_a[i] = (sum_a[i-1] + (a[i] %= MOD)) % MOD;
		sum_mul[i] = (sum_mul[i-1] + a[i] * sum_d[i] % MOD) % MOD;
	}
	for(int i=1, x, l, r; i<=m; i++) {
		scanf("%d%d%d", &x, &l, &r);
		LL ans1 = calc_ans(x, l, min(r, x-1), true);
		LL ans2 = calc_ans(x, max(l, x+1), r, false);
		printf("%lld\n", (ans1 + ans2) % MOD);
	}
	return 0;
}
```

---

## 作者：Nephren_Sakura (赞：7)

题目传送门：[link](https://www.luogu.com.cn/problem/P3932)

设 $a_i$ 表示第 $i$ 处放了多少物品，$dis_i$ 表示第 $i$ 个点离第一个点的距离。

首先，我们可以得到一个公式：将 $l$ 到 $r$ 的所有物品全部移到 $x$ 处，公式为：

$\sum\limits_{i=l}^{x-1}(a_i \times (dis_x-dis_i))+\sum\limits_{i=x+1}^{r}(a_i \times(dis_i-dis_x))$

$=\sum\limits_{i=l}^{x-1}a_i \times dis_x-\sum\limits_{i=l}^{x-1}a_i \times dis_i+\sum\limits_{i=x+1}^{r}a_i \times dis_i- \sum\limits_{i=x+1}^{r}a_i \times dis_x$

这样的话，我们可以预处理出 $a_i$ 与 $a_i \times dis_i$ 的前缀和，就可以 $O(1)$ 求解了。

但是我们还有一个问题没解决：以上只是当 $x$ 在 $l$ 到 $r$ 中间时的答案，若 $x$ 不在 $l$ 到 $r$ 中间怎么办呢？

若 $x$ 在 $1$ 到 $l-1$ 之间，则我们可以先用上面的公式算出将 $1$ 到 $r$ 全部移动到 $x$ 的总代价，再用这个总代价减去 $1$ 到 $l-1$ 的总代价即可。

若 $x$ 在 $r+1$ 到 $n$ 中间，同理可以计算出将 $l$ 到 $n$ 全部移动到 $x$ 的总代价，再用这个总代价减去 $r+1$ 到 $n$ 的总代价即可。

时间复杂度 $O(n+m)$，常数较大。

注意：

1. 要边取模边减，避免爆 long long。

1. 因为我们取了模，所以在做减法时有可能会出现负数，需要先对负数取模，再加一个 $mod$，最后再取模。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=19260817;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int n=read(),q=read(),suma[1000005],sumdis[1000005],a[1000005],dis[1000005];
int query_a(int lt,int rt){
	if(lt>rt)
		return 0;
	return suma[rt]-suma[lt-1];
}
int query_dis(int lt,int rt){
	if(lt>rt)
		return 0;
	return sumdis[rt]-sumdis[lt-1];
}
int help(int l,int r,int x){
	return ((query_a(l,x-1)*dis[x]-query_dis(l,x-1)+query_dis(x+1,r)-query_a(x+1,r)*dis[x])%mod+mod)%mod;//公式
}
signed main(){
	for(int i=2; i<=n; i++)
		dis[i]=dis[i-1]+read(),dis[i]%=mod;//计算从第一个点到当前点的距离
	for(int i=1; i<=n; i++)
		a[i]=read(),suma[i]=suma[i-1]+a[i],suma[i]%=mod;
	for(int i=1; i<=n; i++)
		sumdis[i]=sumdis[i-1]+a[i]*dis[i],sumdis[i]%=mod;//计算前缀和
	while(q--){
		int x=read(),l=read(),r=read();
		if(l<=x&&x<=r)
			cout<<help(l,r,x)%mod<<endl;
		else if(l>x)
			cout<<((help(1,r,x)-help(1,l-1,x))%mod+mod)%mod<<endl;
		else
			cout<<((help(l,n,x)-help(r+1,n,x))%mod+mod)%mod<<endl;
	}
    return 0;
}
```

>所以，现在的我，无论别人怎么说，都一定是世上最幸福的女孩——Chtholly Nota Seniorious

---

## 作者：Eason_AC (赞：6)

## Content
在一个无限长的数轴上有 $n$ 个点。第 $i$ 个点上面有 $a_i$ 件物品，且第 $i$ 个点到第 $i+1$ 个点的距离为 $b_i$。

定义从第 $i$ 个点上面的 $x$ 件物品搬到第 $j$ 个点的花费为 $x\times\operatorname{dist}(i,j)$，其中 $\operatorname{dist}(i,j)$ 即表示第 $i$ 和第 $j$ 个点的距离。

现在有 $m$ 次询问，每次询问给定三个正整数 $x,l,r$，求将所有下标在区间 $[l,r]$ 内的所有点上面的物品全部搬到第 $x$ 个点的总花费是多少。

**答案对 $\bf 19260817$ 取模。**

**数据范围：$1\leqslant n,m\leqslant 2\times 10^5$，$1\leqslant a_i,b_i\leqslant 2\times 10^9$。**

## Solution
首先我们不难写出这样的一个表示答案的式子：

$$\sum\limits_{i=l}^r a_i\times\operatorname{dist}(x,i)$$

直接进行暴力模拟对于这道题目来说肯定是不可行的，所以我们来想一下如何优化。

首先就是这个 $\operatorname{dist}(x,i)$。我们根据定义可以直接推出其用 $b_i$ 表示的式子：

$$\operatorname{dist}(x,i)=\begin{cases}\sum\limits_{j=i}^{x-1}b_j&i<x\\0&i=x\\\sum\limits_{j=x}^{i-1}b_j&\text{otherwise.}\end{cases}$$

乍一看这式子貌似还是不太好看，我们不妨根据 $l,r$ 和 $x$ 的关系分类讨论以分别对应唯一的 $\operatorname{dist}(x,i)$ 的值。

这里以 $r<x$ 为例来具体讲讲。

在这种情况下，所有点上的东西全部往右移。容易发现 $\forall i\in[l,r],i<x$。因此我们直接用上面那坨式子的第一种情况化简成：

$$\sum\limits_{i=l}^r(a_i\times\sum\limits_{j=i}^{x-1}b_j)$$

看到 $\sum\limits_{j=i}^{x-1}b_j$ 马上想到什么？前缀和优化！

设 $dis_i=\sum\limits_{j=1}^{i-1}b_j$，不难想到其实际意义就是第 $i$ 个点到第 $1$ 个点的距离。然后 $\sum\limits_{j=i}^{x-1}b_j=\sum\limits_{j=1}^{x-1}b_j-\sum\limits_{j=1}^{i-1}b_j=dis_x-dis_i$。

于是又可以开始愉快地化简了：

$$\begin{aligned}&\sum\limits_{i=l}^ra_i\times(dis_x-dis_i)\\=&\sum\limits_{i=l}^ra_i\cdot dis_x-\sum\limits_{i=l}^ra_i\cdot dis_i\\=&dis_x\cdot\sum\limits_{i=l}^ra_i-\sum\limits_{i=l}^ra_i\cdot dis_i\end{aligned}$$

然后，仿照上面的套路，我们设 $s_i=\sum\limits_{j=1}^ia_j$，$S_i=\sum\limits_{j=1^i}a_j\cdot dis_j$。原式子就可以化简成：

$$dis_x\cdot (s_r-s_{l-1})-(S_r-S_{l-1})$$

然后你再把 $dis_i,s_i,S_i$ 这三样东西全部都在询问之前先 $\mathcal O(n)$ 预处理一下，就可以 $\mathcal O(1)$ 回答每一次询问了。

$l>x$ 的话，就是所有的东西全部向左移，直接用上面那坨式子的第三种情况化简一下，然后转换成我们设的这三个东西（$dis_i,s_i,S_i$）即可。

$l\leqslant x\leqslant r$ 这个情况稍微复杂一些。我们把区间 $[l,r]$ 以 $x$ 为分界点分开。左边那一部分按照 $r<x$ 那种情况的处理方式去处理，右边那一部分按照 $l>x$ 那种情况的处理方式去处理，最后把两个部分的和加起来即可。

这样，本题的思路就呼之欲出了：

- $\mathcal O(n)$ 预处理出我们上面所提到的 $dis_i=\sum\limits_{j=1}^{i-1}b_j$，$s_i=\sum\limits_{j=1}^ia_j$，$S_i=\sum\limits_{j=1^i}a_j\cdot dis_j$。
- 每次询问分上述三个情况讨论分别 $\mathcal O(1)$ 求出答案。

另外，这题目要时时刻刻注意取模的问题。由于频繁取模写一大堆东西太麻烦，我这里直接用函数实现了两数相加取模、两数相减取模和两数相乘取模，这样写起来就方便很多。

~~虽然但是，我自己写的时候发现最终表示起来也挺复杂的。~~
## Code
为了少考虑些整型溢出的情况，使用了 `#define int ll`。

```cpp
namespace Solution {
#define int ll
	const int N = 2e5 + 7, mod = 19260817;
	int n, q, x, l, r, dis[N], s1[N], s2[N];
	
	ii Add(int x, int y) {return (x + y) % mod;}
	ii Del(int x, int y) {return ((x - y) % mod + mod) % mod;}
	ii Mul(int x, int y) {return 1ll * x * y % mod;}
	
	iv Main() {
		read(n, q);
		F(int, i, 2, n) read(dis[i]), dis[i] %= mod, dis[i] = Add(dis[i], dis[i - 1]);
		F(int, i, 1, n) {
			int x; read(x), x %= mod;
			s1[i] = Add(s1[i - 1], x);
			s2[i] = Add(s2[i - 1], Mul(x, dis[i]));
//			printf("%d %d\n", s1[i], s2[i]);
		}
		while(q--) {
			read(x, l, r);
			if(r < x) println(Del(Mul(dis[x], Del(s1[r], s1[l - 1])), Del(s2[r], s2[l - 1])));
			else if(l > x) println(Del(Del(s2[r], s2[l - 1]), Mul(dis[x], Del(s1[r], s1[l - 1]))));
			else println(Add(Del(Mul(dis[x], Del(s1[x - 1], s1[l - 1])), Del(s2[x - 1], s2[l - 1])), Del(Del(s2[r], s2[x]), Mul(dis[x], Del(s1[r], s1[x])))));
		}
		return;
	}
#undef int
}
```

---

## 作者：RainS (赞：6)

# ~~大家好，我非常喜欢暴力数据结构，所以我用分块过了这道题。~~

### 题面：

[Link](https://www.luogu.com.cn/problem/P3932)

### 题解：

对序列进行分块，记录 $suml_i$ 表示第 $i$ 块内，将块内所有物品移到块的左端点所需要的代价，以及 $sumr_i$ 表示移到右端点所需要的代价，再记录 $dis_i$ 表示前 $i$ 个距离的和（记录 $dis$ 的前缀和）。

查询时分类即可，分 $x$ 在 $\left[l,r \right]$ 区间内还是外。

* 如果 $x$ 在区间外，就先将所有物品移到最左或右端点的位置，再移动到目标点。

* 如果 $x$ 在区间内，直接移动到 $x$ 位置即可。

还有能膜的地方都要膜。

### 代码：

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int N = 5e5 + 10;
const int mod = 19260817;

int n, m, blo;
int bl[N], a[N], dis[N], st[N], ed[N], suml[N], sumr[N], sum[N];

int read() {
    int x = 0;
    char c = getchar();
    while (!isdigit(c)) c = getchar();
    while (isdigit(c)) x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();
    return x;
}

void print(int x) {
    if (x > 9) print(x / 10);
    putchar(x % 10 + 48);
}

void write(int x) {
    while (x < 0) x += mod;
    print(x);
    putchar('\n');
}

void init() {
    blo = 2 * sqrt(n);
    for (int i = 1; i <= blo; i++) st[i] = n / blo * (i - 1) + 1, ed[i] = n / blo * i;
    ed[blo] = n;
    for (int i = 1; i <= blo; i++)
        for (int j = st[i]; j <= ed[i]; j++) {
            bl[j] = i; sum[i] = ((sum[i] + a[j]) % mod + mod) % mod;
            suml[i] = ((suml[i] + a[j] * (dis[j] - dis[st[i]])) % mod + mod) % mod;
            sumr[i] = ((sumr[i] + a[j] * (dis[ed[i]] - dis[j])) % mod + mod) % mod;
        }
}

int left(int x, int l, int r) {
    int tot = 0, res = 0;
    for (int i = l; i <= min(ed[bl[l]], r); i++) {
        tot = ((tot + a[i]) % mod + mod) % mod;
        res = ((res + a[i] * (dis[i] - dis[l])) % mod + mod) % mod;
    }
    if (bl[l] != bl[r])
        for (int i = st[bl[r]]; i <= r; i++) {
            tot = ((tot + a[i]) % mod + mod) % mod;
            res = ((res + a[i] * (dis[i] - dis[l])) % mod + mod) % mod;
        }
    for (int i = bl[l] + 1; i < bl[r]; i++) {
        res = ((res + suml[i] + sum[i] * (dis[st[i]] - dis[l])) % mod + mod) % mod;
        tot = ((tot + sum[i]) % mod + mod) % mod;
    } return ((res + tot * (dis[l] - dis[x])) % mod + mod) % mod;
}

int right(int x, int l, int r) {
    int tot = 0, res = 0;
    for (int i = l; i <= min(ed[bl[l]], r); i++) {
        tot = ((tot + a[i]) % mod + mod) % mod;
        res = ((res + a[i] * (dis[r] - dis[i])) % mod + mod) % mod;
    }
    if (bl[l] != bl[r])
        for (int i = st[bl[r]]; i <= r; i++) {
            tot = ((tot + a[i]) % mod + mod) % mod;
            res = ((res + a[i] * (dis[r] - dis[i])) % mod + mod) % mod;
        }
    for (int i = bl[l] + 1; i < bl[r]; i++) {
        tot = ((tot + sum[i]) % mod + mod) % mod;
        res = ((res + sumr[i] + sum[i] * (dis[r] - dis[ed[i]])) % mod + mod) % mod;
    } return ((res + tot * (dis[x] - dis[r])) % mod + mod) % mod;
}

int mid(int x, int l, int r) {
    int res = 0;
    for (int i = l; i <= min(ed[bl[l]], x); i++) res = ((res + a[i] * (dis[x] - dis[i])) % mod + mod) % mod;
    for (int i = max(st[bl[r]], x); i <= r; i++) res = ((res + a[i] * (dis[i] - dis[x])) % mod + mod) % mod;
    for (int i = bl[l] + 1; i < bl[x]; i++) res = ((res + sumr[i] + sum[i] * (dis[x] - dis[ed[i]])) % mod + mod) % mod;
    for (int i = bl[x] + 1; i < bl[r]; i++) res = ((res + suml[i] + sum[i] * (dis[st[i]] - dis[x])) % mod + mod) % mod;
    if (bl[l] < bl[x])
        for (int i = st[bl[x]]; i <= x; i++)
            res = ((res + a[i] * (dis[x] - dis[i])) % mod + mod) % mod;
    if (bl[x] < bl[r])
        for (int i = x; i <= ed[bl[x]]; i++)
            (res = (res + a[i] * (dis[i] - dis[x])) % mod + mod) % mod;
    return (res % mod + mod) % mod;
}

int work(int x, int l, int r) {
    if (x <= l) return left(x, l, r);
    if (r <= x) return right(x, l, r);
    return mid(x, l, r);
}

signed main() {

    n = read(); m = read();
    for (int i = 2; i <= n; i++) dis[i] = (dis[i - 1] + read()) % mod;
    for (int i = 1; i <= n; i++) a[i] = read();

    init();
    int x, l, r;
    while (m--) {
        x = read(); l = read(); r = read();
        write(work(x, l, r));
    }

    return 0;
}

---

## 作者：Aoki_灏 (赞：4)

## 值得一提的是，这题疯狂卡mod，能mod的地方都要mod！！！并且在输出答案是要(ans+mod*3) % mod ！

##  加一个mod是完全不行的，只要输出了负数就疯狂+mod就行

mmp我就因为这个卡了一面

看了所有题解没有和我一个线段树思路的非常高兴地来写题解里。

首先维护一个前缀和来表示dis这个大家都会

根据题意我们可以轻松知道

          当l>x时，
          ans=a[r]*(sum[r]-sum[x])+a[r-1]*(sum[r-1]-sum[x])+...+a[l]*(sum[l]-sum[x]);
          ans=-(a[r]+a[r-1]+...+a[l])*sum[x]
          +a[r]*sum[r]+a[r-1]*sum[r-1]+...+a[l]*sum[l];
          当r<x时，
          把式子反过来就行了
          其他情况将区间剖开，求(l,x-1)和(x+1,r)就行
          因为从一个点运到同一个点dis=0是要去掉的
          
          于是我们可以发现只要维护一个区间和，和一个a[x]*sum[x]的和就行了
          这不是很简单的线段树操作吗？，连pushdown都不用就显得非常简单了
          
直接上代码！

```
// 把式子一列其实就一目了然了代码清晰易懂
//代码中疯狂mod注意
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#define N 200000+10000
#define lson 2*p
#define rson 2*p+1
#define ll long long
using namespace std;
const ll mod=19260817;
struct node
{
    int lt;
    int rt;
    ll val;
    ll sum;
    ll w;//这就是我上面提到的a[x]*sum[x] 把这个量重新做一个变量
}a[4*N];
int n,m;
ll data[N],w[N],sum[N];
void pushup(int p)//简单的操作，大家都懂
{
   a[p].sum=(a[lson].sum+a[rson].sum)%mod;
   a[p].w=(a[lson].w+a[rson].w)%mod;
}
void build(int p,int l,int r)//基本操作
{
    a[p].lt=l;
    a[p].rt=r;
    if(l==r){a[p].sum=data[l];a[p].w=data[l]*sum[l]%mod;return;}
    int mid=(l+r)/2;
    build(2*p,l,mid);
    build(2*p+1,mid+1,r);
    pushup(p);
}
ll query(int p,int l,int r)
{
    if(a[p].lt==l&&a[p].rt==r)return a[p].sum%mod;
    int mid=(a[p].lt+a[p].rt)/2;
    if(r<=mid)return query(2*p,l,r);
    else if(l>mid)return query(2*p+1,l,r);
         else return (query(2*p,l,mid)+query(2*p+1,mid+1,r))%mod;
}
ll query_w(int p,int l,int r)
{
    if(a[p].lt==l&&a[p].rt==r)return a[p].w%mod;
    int mid=(a[p].rt+a[p].lt)/2;
    if(r<=mid)return query_w(lson,l,r);
    else if(l>mid)return query_w(rson,l,r);
    else return (query_w(lson,l,mid)+query_w(rson,mid+1,r))%mod;
}
//这些都没什么要讲的，全是模板
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=2;i<=n;i++)
    {
        int x;
        scanf("%lld",&x);
        x%=mod;
        sum[i]=sum[i-1]+x;//前缀和操作
        sum[i]%=mod;
    }
    for(int i=1;i<=n;i++){scanf("%lld",&data[i]);data[i]%=mod;}
    build(1,1,n);
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        if(y>z)swap(y,z);
        ll sum1=0,sum2=0;
        if(x==y&&x==z)//特判一下
        {
            printf("0\n");
            continue;
        }
        if(y==x)y++;//因为要避免等于的情况要删掉
        if(z==x)z--;
        if(y>x)
            sum1=query_w(1,y,z)%mod-query(1,y,z)*sum[x]%mod;//这些东西看我列的式子很好理解
         else if(z<x)
           sum2=sum[x]*query(1,y,z)%mod-query_w(1,y,z)%mod;
        else
        {
            sum1=query_w(1,x+1,z)%mod-query(1,x+1,z)*sum[x]%mod;//要把x给空出来！
            sum2=sum[x]*query(1,y,x-1)%mod-query_w(1,y,x-1)%mod;

        }
        ll ans=sum1+sum2;
        printf("%lld\n",(ans+mod*3)%mod);//毒瘤的mod
    }

    return 0;
}


```
          

---

## 作者：moosssi (赞：3)

这是道不错的前缀和练手题

首先，定义几个数组：

 $sum1[i]$ 表示 $1$ 到 $i$ 号仓库中的所有物品全都转移到 $1$ 号仓库所需花费


 $sum2[i]$ 表示 $1$ 到 $i$ 号仓库中的所有物品全都转移到 $n$ 号仓库所需花费
 
 
 $dist[i]$ 表示 $i$ 号仓库到 $1$ 号仓库的距离

 $val[i]$  表示 $1$ 到 $i$ 号仓库中的所有物品的总个数

 这里，我们可以很容易地把以上数组预处理出来，不再赘述，不清楚的可以看看代码。然后，我们来处理询问，先分为三种情况: $x$ 在 $l$ 左边，$x$ 在 $r$  右边， $x$ 在中间。
 
 第一种情况，运用前缀和思想算出 $l\thicksim r$ 仓库物品运到到 $1$ 号所需花费: $(sum1[r]-sum1[l-1])$ ， 多出来的部分便是 $l\thicksim r$ 仓库中物品从 $x$ 到 $1$ 号的花费，则最终答案为:  $(sum1[r]-sum1[l-1])-(val[r]-val[l-1])*dist[x]$ 
 
 第二种情况同理，用 $sum2[]$ 数组计算即可，第三种，就把它拆为左右两部分，用之前的方法分开计算即可
 
 最后，记得开 $long long$ ,还要疯狂取模（能加的地方都加上）。
 
 ```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=200005;
ll a[N],sum1[N],sum2[N],dist[N],val[N];
int n,m,mod=19260817;
ll get1(int l,int r,int x){
	return ((sum1[r]-sum1[l-1])%mod-(val[r]-val[l-1])*dist[x]%mod+mod)%mod;
}
ll get2(int l,int r,int x){
	return ((sum2[r]-sum2[l-1])%mod-(val[r]-val[l-1])*(dist[n]-dist[x])%mod+mod)%mod;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=2;i<=n;i++){
		scanf("%lld",&dist[i]);
		dist[i]=(dist[i]+dist[i-1])%mod;
	}
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		val[i]=(val[i-1]+a[i])%mod;
		sum1[i]=(a[i]*dist[i])%mod;
		sum2[i]=(a[i]*(dist[n]-dist[i]))%mod;
	}
	sum1[1]=sum2[n]=0;
	for(int i=1;i<=n;i++){
		sum1[i]+=sum1[i-1];
		sum2[i]+=sum2[i-1];
	}
	for(int i=1;i<=m;i++){
		int x,l,r;
		ll ans;
		scanf("%d%d%d",&x,&l,&r);
		if(x<=l){
			ans=get1(l,r,x);
			while(ans<0)ans+=mod;
			printf("%lld\n",ans);
		}
		else if(x>l&&x<r){
			ans=(get1(x,r,x)+get2(l,x,x))%mod;
			while(ans<0)ans+=mod;
			printf("%lld\n",ans);
		}
		else if(x>=r){
			ans=get2(l,r,x);
			while(ans<0)ans+=mod;
			printf("%lld\n",ans);
		}
	}
	return 0;
} 
```




---

## 作者：FanYongchen (赞：2)

看问题，发现这道题和距离有关，那就与储物点的编号有关，自然能想到 $x$ 在不同范围时有不同的情况。

我们用 $a_i$ 表示储物点 $i$ 的东西个数，用 $d_i$ 表示储物点 $i$ 距储物点 $1$ 的距离。

对于储物点 $[l,r]$ 中一储物点 $k$，运到 $x$ 所花费的代价为 $\operatorname{dist}(k,x)\times a_k$。

$x$ 在不同范围时，$\operatorname{dist}(k,x)$ 的值会有不同情况，我们可以分成下面三种情况：

- $x<l$，那么 $\operatorname{dist}(k,x)=d_k-d_x$

- $x>r$，那么 $\operatorname{dist}(k,x)=d_x-d_k$

- $l\leq x\leq r$，那么 $\operatorname{dist}(k,x)=\begin{cases}d_x-d_k&l\leq k\leq x\\d_k-d_x&x<k\leq r\end{cases}$

后面的就很好推了，将上面三种情况的费用算出来就行了。

- $x<l$，费用为 $\sum\limits_{i=l}^{r}{(d_i-d_x)\times a_i}$，也就是 $\sum\limits_{i=l}^{r}{d_i\times a_i}-\sum\limits_{i=l}^{r}{d_x\times a_i}$

- $x>r$，费用为 $\sum\limits_{i=l}^{r}{d_x\times a_i}-\sum\limits_{i=l}^{r}{d_i\times a_i}$

- $l\leq x\leq r$，费用为 $\sum\limits_{i=x+1}^{r}{d_i\times a_i}-\sum\limits_{i=x+1}^{r}{d_x\times a_i}+\sum\limits_{i=l}^{x}{d_x\times a_i}-\sum\limits_{i=l}^{x}{d_i\times a_i}$

不难发现，可以用 $s1_i$ 表示 $\sum\limits_{k=1}^{i}a_k$，用 $s2_i$ 表示 $\sum\limits_{k=1}^{i}a_k\times d_k$ 即可。询问时按上面式子直接用就行。

但是不要忘记膜，要把能膜的全部都膜，还有负数的处理。

关于负数，若为 $x\bmod y$，则可以这么弄 $(x\bmod y +y)\bmod y$。

代码如下：

```cpp

#include <iostream>
#include <cstring>
#include <cmath>
#include <ctime>
using namespace std;
#define ms(x,y) memset(x,y,sizeof(x))
#define mc(x,y) memcpy(x,y,sizeof(x))
#define ll long long
const int M=200005;
const int MOD=19260817;
int n,q;
ll d[M],a[M],s1[M],s2[M];//跟上面表达的一样
int main()
{
    clock_t t1=clock();
#ifdef LOCAL
    freopen("in.in","r",stdin);
    freopen("out.out","w",stdout);
#endif

//==================================
    cin>>n>>q;
    for(int i=2;i<=n;i++)
    {
        ll x;
        cin>>x;
        d[i]=(d[i-1]+x)%MOD;
    }
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        s1[i]=(a[i]+s1[i-1])%MOD;
        s2[i]=(a[i]*d[i]%MOD+s2[i-1])%MOD;
    }
    for(int i=1;i<=q;i++)
    {
        int x,l,r;
        cin>>x>>l>>r;
        if(x<l)//都是上面表达的，因为有减法运算，为了保险起见，这边能模的都模了
        {
            cout<<(((s2[r]-s2[l-1])-d[x]*(s1[r]-s1[l-1])%MOD)%MOD+MOD)%MOD<<"\n";
        }
        else if(x<=r)
        {
            cout<<((((d[x]*(s1[x]-s1[l-1])%MOD-(s2[x]-s2[l-1]))%MOD+MOD)%MOD+(((s2[r]-s2[x])-d[x]*(s1[r]-s1[x])%MOD)%MOD+MOD)%MOD)%MOD+MOD)%MOD<<"\n";
        }
        else 
        {
            cout<<((d[x]*(s1[r]-s1[l-1])%MOD-(s2[r]-s2[l-1]))%MOD+MOD)%MOD<<"\n";
        }
    }
//==================================

    cerr<<"Time used:"<<clock()-t1<<"ms"<<"\n";
    return 0;
}


---

## 作者：Excim (赞：2)

```cpp
//其实，并不需要算很多的前缀和的
//a[i]表示i位置之前的物品总数
//dis[i]表示每个储物点与一号的距离 
//sum表示前i个储物点(物品数*距离)的和
//当x<l时，ans=sum[r]-sum[l-1]+dis[x]*(a[r]-a[l-1]) 
//x>r时正好反过来 
//而x>=l&&x<=r时，将区间分为[l,x-1][x+1,r]两部分分别计算即可 
//为了省事，我直接在原来的a和dis数组上算了前缀和 
//注意减法的取模问题，不论是暴力还是正解我都是挂在这个地方。 这题减法比较多，写个函数会更方便些。
#include<cstdio>
const long long c=19260817;
void read(long long &y)
{
    y=0;char x=getchar();
    while(x<'0'||x>'9') x=getchar();
    while(x>='0'&&x<='9')
    {
        y=y*10+x-'0';
        x=getchar();
    }
}
long long ch(long long s,long long t)
{
    return (s-t+c)%c;
}
long long sum[200005],dis[200005],a[200005],x,l,r,ans;
int n,m;
int main()
{
//    freopen("68.in","r",stdin);
    scanf("%d %d",&n,&m);
    for(int i=2;i<=n;i++)
    {
        read(dis[i]);
        dis[i]=(dis[i]+dis[i-1])%c;
    }
    for(int i=1;i<=n;i++)
    {
        read(a[i]);
        sum[i]=(sum[i-1]+(a[i]*dis[i])%c)%c;
        a[i]=(a[i]+a[i-1])%c;
    }
    for(int i=1;i<=m;i++)
    {
        ans=0;
        read(x);read(l);read(r);
        if(x<l) ans=ch(ch(sum[r],sum[l-1]),(dis[x]*ch(a[r],a[l-1]))%c);
        if(x>=l&&x<=r)
        {
            ans+=ch(ch(sum[r],sum[x]),(dis[x]*ch(a[r],a[x]))%c);
            ans+=ch((dis[x]*ch(a[x],a[l-1]))%c,ch(sum[x],sum[l-1]));
            ans%=c;
        }
        if(x>r) ans=ch((dis[x]*ch(a[r],a[l-1]))%c,ch(sum[r],sum[l-1]));
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：CReatiQ (赞：1)

### 题意概述

给定一条数轴上 $n$ 个仓库之间的相对距离，以及这个仓库内的物品数。

$m$ 次询问，求将第 $l \sim r$ 每个仓库内的物品都移动到第 $x$ 个仓库上的最小代价对 $19260817$ 取模的值。

假设仓库 $i$ 有 $obj_i$ 个物品，到目标仓库 $j$ 的距离为 $dist_{i,j}$，则将物品从 $i$ 仓库移动到 $j$ 仓库的代价为：

$$obj_i \times dist_{i,j}$$

$1 \leq n,m \leq 2 \times 10^5 ,1 \leq obj_i,dist_{i,j} \leq 2 \times 10^9$。

---

### 思路

因为计算时需要用到任意两仓库间的相对距离，所以我们先把它们的相对距离转化成绝对坐标（如到第 $1$ 个仓库的距离），两仓库间的相对距离就是它们的绝对坐标之差，相当于前缀和。

设 $pos_i$ 为第 $i$ 个仓库到第 $1$ 个仓库的距离。

区间 $l \sim r$ 每个位置上的物品都移动到 $x$ 位置上的代价为：

$$\sum_{i=l}^r \ \lvert \ pos_i-pos_x \ \rvert \cdot obj_i$$

如果 $l < x < r$，我们将 $l \sim r$ 分为 $[l,x-1],\{x\},[x+1,r]$ 三个区间，以方便将不随 $i$ 改变的 $pos_x$ 项提取。

对于 $\{x\}$，它的贡献一定为 $0$ ，所以可以不计算它。

对于 $[l,x-1]$，它的贡献为：

$$\sum_{i=l}^{x-1} (pos_x-pos_i) \cdot obj_i$$

$$ =(pos_x \cdot \sum_{i=1}^{x-1} obj_i) - (\sum_{i=1}^{x-1} pos_i \cdot obj_i)$$

同理，$[x+1,r]$ 的贡献为：

$$(\sum_{i=x+1}^r pos_i \cdot obj_i) - (pos_x \cdot \sum_{i=x+1}^r obj_i)$$

所以我们只要预处理出 $obj_i$ 与 $pos_i \cdot obj_i$ 的前缀和即可 $\mathcal{O}(1)$ 回答每个询问。

需要注意的是取模，因为计算过程存在减法，所以要先加后模；因为模数较小，所以可能只加一次不足以让数变为正数，所以可以选择一直加或者先模后加再模。

---

### Code

```cpp
#include <cstdio>
#define int long long

const int MAXN=2e5+10,mod=19260817;
int n,m,dis[MAXN],obj[MAXN];
int sumo[MAXN],sumdo[MAXN];
int x,l,r,l1,r1,l2,r2,ans;

inline int comp(int x)
{
	x%=mod;
	if (x<0) x+=mod;
	return x;
}

inline int pl(int x,int y) { return (comp(x)+comp(y))%mod; }

inline int mul(int x,int y) { return comp(x)*comp(y)%mod; }

inline int so(int ql,int qr) { return pl(sumo[qr],-sumo[ql-1]); }

inline int sdo(int ql,int qr) { return pl(sumdo[qr],-sumdo[ql-1]); }

inline int read()
{
	int x=0;char ch=getchar();
	while (ch<'0'||ch>'9') ch=getchar();
	while (ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x;
}

signed main()
{
	n=read(),m=read();
	for (int i=2;i<=n;i++) dis[i]=dis[i-1]+read();
	for (int i=1;i<=n;i++) obj[i]=read();
	for (int i=1;i<=n;i++)
		sumo[i]=pl(sumo[i-1],obj[i]),
		sumdo[i]=pl(sumdo[i-1],mul(dis[i],obj[i]));
	for (int i=1;i<=m;i++)
	{
		ans=0;
		x=read(),l=read(),r=read();
		l1=l,r1=x-1,l2=x+1,r2=r;
		if (x<l) l2=l;
		else if (x>r) r1=r;
		if (l1<=r1)
			ans=pl(mul(dis[x],so(l1,r1)),-sdo(l1,r1));
		if (l2<=r2)
			ans=pl(ans,pl(-mul(dis[x],so(l2,r2)),sdo(l2,r2)));
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：ironwheel (赞：1)

静态问运输距离，不带修改。

我们发现可以开几个前缀后缀和来维护。

清点一下，要开下面几个数组：

距离前缀后缀和；

储物点物品个数前缀后缀和；

以及最重要的：

**$sum1_i$表示将1到i的所有东西全部运到1的花费**

**$sum2_i$表示将i到n的所有东西全部运到n的花费**

然后我们通过x的位置情况讨论一下：

$x < l$时，先算出$[l,r]$全部运到1的花费，再减去$[l,r]$从1运到x的花费

$r < x$时，先算出$[l,r]$全部运到n的花费，再减去$[l,r]$从n运到x的花费

x在$[l,r]$之间时，算出$[l,x]$运到1，$[x + 1,r]$运到n，再减去$[l,x]$从1运到x，$[x + 1,r]$从n运到x的花费。

注意$mod$。注意开$long long$。

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 3e5;
const int inf = 1e9;

int s = 1e5, t = s + 1, tmp = 1, n, m, sum = 0;

struct dt{
    int from, to, f, next;
}e[N];

int head[N], dep[N], cur[N];

bool vis[N];

string s1[N], s2[N];

void add(int a, int b, int val){
    e[++tmp].from = a;
    e[tmp].to = b;
    e[tmp].f = val;
    e[tmp].next = head[a];
    head[a] = tmp;
    e[++tmp].from = b;
    e[tmp].to = a;
    e[tmp].f = 0;
    e[tmp].next = head[b];
    head[b] = tmp;
}

bool bfs(){
	memset(dep, 0x3f, sizeof(dep));
	memset(vis, 0, sizeof(vis));
	for(int i = 1; i <= N; i++)cur[i] = head[i];
	queue<int> q;
	vis[s] = 1;
	dep[s] = 0;
	q.push(s);
	while(!q.empty()){
		register int u = q.front();
		q.pop();
		for(register int i = head[u]; i; i = e[i].next){
			register int v = e[i].to;
			if(dep[v] > dep[u] + 1 && e[i].f){
				dep[v] = dep[u] + 1;
				if(!vis[v])
					q.push(v);
				vis[v] = 1;
			}
		}
	}
	return dep[t] != 0x3f3f3f3f;
}

int dfs(int now, int low){
	int flow = 0;
	if(now == t)return low;
	for(register int i = cur[now]; i; i = e[i].next){
		cur[now] = i;
		int v = e[i].to;
		if(e[i].f && dep[v] == dep[now] + 1){
			if(flow = dfs(v, min(low, e[i].f))){
				e[i].f -= flow;
				e[i ^ 1].f += flow;
				return flow;
			}
		}
	}
	return 0;
}

int dinic(){
	int minflow, maxflow = 0;
	while(bfs()){
		while(minflow = dfs(s, inf))maxflow += minflow;
	}
	return maxflow;
}

int main(){
	cin >> n >> m;
	int yy1, yy2;
	yy1 = yy2 = 0;
	for(int i = 1; i <= n; i++){cin >> s1[i]; if(s1[i] == "YYY") yy1++;}
	for(int i = 1; i <= n; i++){cin >> s2[i]; if(s2[i] == "YYY") yy2++;}
	for(int i = 1; i <= n; i++){
		int hp;
		cin >> hp;
		add(s, i, (s1[i] == "J" ? (hp + yy1) : hp));
	}
	for(int i = 1; i <= n; i++){
		int hp;
		cin >> hp;
		add(i + n, t, (s2[i] == "J" ? (hp + yy2) : hp));
	}
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= n; j++){
			if((s1[i] == "J" && s2[j] == "W") || (s1[i] == "J" && s2[j] == "HK")
			|| (s1[i] == "W" && s2[j] == "YYY") || (s1[i] == "W" && s2[j] == "E")
			|| (s1[i] == "HK" && s2[j] == "W") || (s1[i] == "HK" && s2[j] == "E")
			|| (s1[i] == "YYY" && s2[j] == "HK") || (s1[i] == "YYY" && s2[j] == "J")
			|| (s1[i] == "E" && s2[j] == "YYY") || (s1[i] == "E" && s2[j] == "J"))
				add(i, j + n, 1);
		}
	}
	int tmp = dinic();
	if(tmp >= m) cout << m << endl;
	else cout << tmp << endl;
}
```


---

## 作者：YJMSTR (赞：1)

为了方便区分 以下把询问点位置记为$pos$ 

第$i$个储物点的东西个数记为$a_i$ 

第$i$个储物点到第$i+1$个储物点的距离记为$d_i$

$d_i$的前缀和为$D_i$

$a_i$的前缀和为$s_i$

统计区间$[l,r]$的答案时，需要考虑区间内每个元素与pos的距离

为此，可以实现以下两个函数进行计算

```cpp
ll querypre(int x){
	ll res = 0;
    res = -(sp[x] - sp[pos] + md) % md * d[pos - 1] % md;
    res = (res + g[x] - g[pos] + md) % md + md; res %= md;
    return res;
}//当pos <= x计算[pos, x]的答案
querysuf(int x){
	ll res = 0; 
    res = (sp[pos-1]-sp[x-1] + md) % md * d[pos-1] % md;
    res = (res - g[pos - 1] + g[x - 1] + md) % md;
    return res;
}//当pos >= x计算[x, pos]的答案
```
考虑直接写出$[pos,x]$与$[x, pos]$的答案的式子
$$querypre(x) = \sum_{i=pos}^{x-1}{(D_i-D_{pos-1})\times {a_{i+1}}}=-{D_{pos-1}\times{(s_x-s_pos)}+\sum_{i=pos}^{x-1}D_i\times{a_{i+1}}}$$


$$querysuf(x) = \sum_{i=x}^{pos-1}(D_{pos-1}-D_{i-1})\times{a_i}=D_{pos-1}\times{(s_{pos-1}-s_{x-1})-\sum_{i=x}^{pos-1}D_{i-1}\times{a_{i}}}$$

发现$D_{i-1}\times{a_{i}}$可以预处理并用前缀和优化 记为$f_i$ $f$的前缀和记为$g$ 就得到了上面的代码

计算询问的答案 只要用上面两个函数加加减减以下就可以了
分三种情况讨论:
1. 

	当$pos∈[l,r]$  
	可以分别对[l,pos]和[pos,r]进行计算 求和即可
2.  当$pos < l $ 答案为$querypre(r)-querypre(l-1)$

3.  当$pos > r $ 答案为$querysuf(l)-querysuf(r+1)$

完整代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define Max(_A,_B) (_A>_B?_A:_B)
#define Min(_A,_B) (_A<_B?_A:_B)
const int maxn = 200007, md = 19260817;
int rd(){
    int s = 0, f = 1; char c = getchar();
    while (c > '9' || c < '0') {if(c == '-') f == -1; c = getchar();}
    while (c >= '0' && c <= '9') { s = s * 10 + c - '0'; c = getchar();}
    return s * f;
}    
ll a[maxn];
ll sp[maxn], d[maxn], f[maxn], g[maxn];
//f[i] = d[i] * a[i + 1]
int n, m, l, r, pos;
ll querypre(int x) {
    ll res = 0;
    res = -(sp[x] - sp[pos] + md) % md * d[pos - 1] % md;
    res = (res + g[x] - g[pos] + md) % md + md; res %= md;
    return res;
}
ll querysuf(int x) {
    ll res = 0; 
    res = (sp[pos-1]-sp[x-1] + md) % md * d[pos-1] % md;
    res = (res - g[pos - 1] + g[x - 1] + md) % md;
    return res;
}
int main(){
    n = rd(), m = rd();
    for (int i = 1; i < n; i++) d[i] = rd() % md;
    for (int i = 1; i <= n; i++) d[i] = (d[i - 1] + d[i]) % md;
    for (int i = 1; i <= n; i++) a[i] = rd() % md, f[i] = d[i - 1] * a[i] % md;
    for (int i = 1; i <= n; i++) g[i] = g[i - 1] + f[i], g[i] %= md;
    for (int i = 1; i <= n; i++) {
        sp[i] = sp[i - 1] + a[i]; sp[i] %= md;
    }
    for (int i = 1; i <= m; i++) {
        pos = rd(), l = rd(), r = rd();
        if (pos >= l && pos <= r) {
            printf("%lld\n", (querysuf(l) + querypre(r)) % md);
        } else if (pos < l) {
            printf("%lld\n", (querypre(r) - querypre(l - 1) + md)% md);
        } else if (pos > r) {
            printf("%lld\n", (querysuf(l) - querysuf(r + 1) + md)% md);
        }
    }
    return 0;
} 
```

---

## 作者：Lpy_Now (赞：1)

设ai为每两个仓库之间的距离,bi为两个仓库之间的重物的量

可以这么来思考就是对于区间内的每一个仓库中的东西我们全部让他单独的从他所在的仓库运送到而不是将当前节点的货物运送到更靠近的目标节点的点合并后再一起运输这样子答案其实是等价的，对于这道题分为如下几种情况（数学归纳法）：

当需要转移到的仓库在区间的左边，可以列出如下式子：

Ans=b(l)\*(x(l)-x)+b(l+1)\*(x(l+1)-x)+......+b(r)\*(x(r)=x);

将上式求和化简就是ans=∑(b(i)\*x(i))-x\*∑b(i)

解释一下就是：对第i个点与第i个仓库所拥有的重物的乘积进行一下求和就是将当前位置的重物转移到目标地点的所用的代价，再减去目标仓库与区间内各点重物的和的乘积（数学归纳法）

对于目标仓库在区间的右边：

可以采取同样的方法将式子求和，如下：

Ans=x\*∑b(i)-∑b(i)\*x(i)

其实是式子本质上是相同的（本质上不过是将目标仓库在区间左边的情况中区间的重物反方向移动，所以在公式上添加符号就行了）

目标仓库在区间内：

这种情况其实就可以等价转换为将区间以目标仓库为节点分为左右两部分从而转化为情况一和情况三分别计算就行

由于根据所得的式子要对bi和bi\*xi进行区间的求和，并且对区间没有修改，用两个数组将区间前缀和保存下来，O(1)询问就行

时间复杂度：O(N)

注意一点，求前缀和的时候记得边求边取模这样子爆不了~


---

## 作者：青石巷 (赞：1)

对之前发布的题解进行一下修改……其实只维护前缀和不一定是错的，对于$l<r<x$的情况，只要将$x<l<r$的情况中的最后结果取负（在模意义下）就可以了。这也是月赛的标答。然而我这篇题解是看了月赛题解之前写的……加上自己做题时$l<r<x$的情况没考虑到一心慌就写后缀和了……

---------------------修改分割线---------------------------

看到这种不带修改的区间查询，第一时间想到的应该是前缀和。只是这次维护的不是简单的区间和，而是$\sum_{i=l}^{r}dis_{i,x}\cdot num_i$。

对于$x$,$l$,$r$，先考虑$x<l<r$的情况。

此时可以先通过前缀和维护每个点到编号为1的点的距离$dis_i$，然后再维护$d_{i}=dis_{i}\cdot num_i$并对其求前缀和得到$ds_i$，这样在询问[l,r]时$ds_{r}-ds_{l-1}=\sum_{i=l}^{r}dis_{i}\cdot num_i$。然而题目要求的不是到点1而是到点$x$，因此还需要减去$dis_{x}\cdot \sum_{i=l}^{r}num_i$，后面部分是典型的区间和问题。可以用前缀和维护。

以上是$x<l<r$的情况。

对于$l<x<r$以及$l<r<x$的情况，这样做是会出错的。当$l<r<x$时，可以将序列翻转，以点$n$为起点维护以上所有前缀和，就可以解决了。对于$l<x<r$的情况，可以将其看成将[l,x]运至$x$和[x,r]运至$x$两次操作的代价和，就可以化归到以上两种情况了。

然而我提交时两种代价和忘记取模了qwq

代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
#define sum(a,l,r) (((a[r]-a[l-1])%MOD+MOD)%MOD)
#define lquery(x,l,r) ((sum(lds,l,r)-ldis[x]*sum(ls,l,r)%MOD+MOD)%MOD)
#define rquery(x,l,r) ((sum(rds,l,r)-rdis[x]*sum(rs,l,r)%MOD+MOD)%MOD)
using namespace std;
const int maxn=2e5+10,MOD=19260817;
LL litv[maxn],lnum[maxn],ldis[maxn],ls[maxn],ld[maxn],lds[maxn];
LL ritv[maxn],rnum[maxn],rdis[maxn],rs[maxn],rd[maxn],rds[maxn];
int n,m;LL ans;
template<class T>void read(T &x)
{
    x=0;int f=0;char ch=getchar();
    while(ch<'0'||ch>'9')  {f|=(ch=='-');ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    x=f?-x:x;
    return;
}
int main()
{
    int i,j,x,l,r,tmp,x1,l1,r1;
    cin>>n>>m;
    for(i=2;i<=n;i++){scanf("%lld",&litv[i]);ldis[i]=(ldis[i-1]+litv[i])%MOD;}
    for(i=1;i<=n;i++){scanf("%lld",&lnum[i]);ls[i]=(ls[i-1]+lnum[i])%MOD;}
    for(i=1;i<=n;i++){ld[i]=ldis[i]*lnum[i]%MOD;lds[i]=(lds[i-1]+ld[i])%MOD;}
    //以上是以1为起点维护前缀和 以下是以n为起点维护前缀和 
    for(i=1;i<=n;i++){ritv[i]=litv[n-i+2];rnum[i]=lnum[n-i+1];}
    for(i=1;i<=n;i++){rdis[i]=(rdis[i-1]+ritv[i])%MOD;rs[i]=(rs[i-1]+rnum[i])%MOD;}
    for(i=1;i<=n;i++){rd[i]=rdis[i]*rnum[i]%MOD;rds[i]=(rds[i-1]+rd[i])%MOD;}
    for(i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x,&l,&r);
        x1=n-x+1;l1=n-l+1;r1=n-r+1;
        if(x<=l){printf("%lld\n",lquery(x,l,r));}
        else if(x>=r){printf("%lld\n",rquery(x1,r1,l1));}
        else{printf("%lld\n",(lquery(x,x,r)+rquery(x1,x1,l1))%MOD);}//记得取模...... 
    }
    return 0;
}
```

---

## 作者：三华生 (赞：1)

#【分析】

##首先我们设viv\_ivi​表示第i个位置上的物品数量，维护一个前缀和disidis\_idisi​表示第i个位置到第一个位置的距离

由此我们可以得出以下公式：ans=∑i=1nvi∣disi−disx∣ans=\sum\_{i=1}^{n}v\_i|dis\_i-dis\_x|ans=∑i=1n​vi​∣disi​−disx​∣化简得：ans=∑i=1n∣vidisi−vidisx∣ans=\sum\_{i=1}^{n}|v\_i dis\_i-v\_i dis\_x|ans=∑i=1n​∣vi​disi​−vi​disx​∣我们发现：对于每一个i，它的vidisiv\_i dis\_ivi​disi​是一个定值，那么我们就也用一个前缀和mulimul\_imuli​来维护第i个位置上的物品数量与disidis\_idisi​的乘积
最后在维护一个前缀和sumisum\_isumi​储存前i个位置中物品的总量

当我们求最终答案的时候需要考虑三种情况：

1 对于输入的x、l、r满足x≤lx \leq lx≤l

这种情况的答案ans=(mulr−mull−1)−(sumr−suml−1)disians=(mul\_{r}-mul\_{l-1})-(sum\_{r}-sum\_{l-1})dis\_ians=(mulr​−mull−1​)−(sumr​−suml−1​)disi​

2 对于输入的x、l、r满足r≤xr \leq xr≤x

很显然这种情况的ans=sumr−suml−1)disi−(mulr−mull−1)ans=sum\_{r}-sum\_{l-1})dis\_i-(mul\_{r}-mul\_{l-1})ans=sumr​−suml−1​)disi​−(mulr​−mull−1​)

3 需要注意的就是l≤x≤rl \leq x \leq rl≤x≤r的这种情况

对于区间内x之前的部分，有ans=(sumx−1−suml−1)disx−(mulx−1−mull−1)ans=(sum\_{x-1}-sum\_{l-1})dis\_x-(mul\_{x-1}-mul\_{l-1})ans=(sumx−1​−suml−1​)disx​−(mulx−1​−mull−1​)

对于区间内x之后的部分，有ans=(mulr−mulx)−(sumr−sumx)disxans=(mul\_{r}-mul\_{x})-(sum\_{r}-sum\_{x})dis\_{x}ans=(mulr​−mulx​)−(sumr​−sumx​)disx​

然后我们把两个ans加起来就是这种情况的答案

#【程序】

```cpp
#include<iostream>
#define f(i,l,r) for(i=(l);i<=(r);i++)
using namespace std;
const int MAXN=200010,MOD=19260817;
long long n,m,dis[MAXN],w[MAXN];
long long c1[MAXN],c2[MAXN];
long long Plus(long long a,long long b)
{
    a=(a+MOD)%MOD;b=(b+MOD)%MOD;
    return (a+b)%MOD;
}
long long minu(long long a,long long b)
{
    a=(a+MOD)%MOD;b=(b+MOD)%MOD;
    return (a-b+MOD)%MOD;
}
long long mult(long long a,long long b)
{
    a=(a+MOD)%MOD;b=(b+MOD)%MOD;
    return (a*b)%MOD;
}
int main()
{
    ios::sync_with_stdio(false);
    int i,x,l,r;
    long long ans;
    cin>>n>>m;
    f(i,2,n){
        cin>>dis[i];
        dis[i]=Plus(dis[i],dis[i-1]);
    }
    f(i,1,n){
        cin>>w[i];
        c1[i]=Plus(mult(w[i],dis[i]),c1[i-1]);
        c2[i]=Plus(c2[i-1],w[i]);
    }
    f(i,1,m){
        cin>>x>>l>>r;
        if(x<=l){
            ans=minu(minu(c1[r],c1[l-1]),mult(dis[x],minu(c2[r],c2[l-1])));
        }
        else if(x>=r){
            ans=minu(mult(dis[x],minu(c2[r],c2[l-1])),minu(c1[r],c1[l-1]));
        }
        else{
            ans=minu(mult(dis[x],minu(c2[x],c2[l-1])),minu(c1[x],c1[l-1]));
            ans=Plus(ans,minu(minu(c1[r],c1[x-1]),mult(dis[x],minu(c2[r],c2[x-1]))));
        }
        cout<<(ans+MOD)%MOD<<endl;
    }
    return 0;
}
```

---

## 作者：Ricardo_Y_Li (赞：1)

来自一个蒟蒻的垃圾写法

首先我们设$v_i$表示第i个位置上的物品数量，维护一个前缀和$dis_i$表示第i个位置到第一个位置的距离

由此我们可以得出以下公式：$ans=\sum_{i=1}^{n}v_i|dis_i-dis_x|$
化简得：$ans=\sum_{i=1}^{n}|v_i dis_i-v_i dis_x|$
我们发现：对于每一个i，它的$v_i dis_i$是一个定值，那么我们就也用一个前缀和$mul_i$来维护第i个位置上的物品数量与$dis_i$的乘积

最后在维护一个前缀和$sum_i$储存前i个位置中物品的总量

当我们求最终答案的时候需要考虑三种情况：

**1 对于输入的x、l、r满足$x \leq l$**

这种情况的答案$ans=(mul_{r}-mul_{l-1})-(sum_{r}-sum_{l-1})dis_i$

**2 对于输入的x、l、r满足$r \leq x$**

很显然这种情况的$ans=sum_{r}-sum_{l-1})dis_i-(mul_{r}-mul_{l-1})$

**3 需要注意的就是$l \leq x \leq r$的这种情况**

对于区间内x之前的部分，有$ans=(sum_{x-1}-sum_{l-1})dis_x-(mul_{x-1}-mul_{l-1})$

对于区间内x之后的部分，有$ans=(mul_{r}-mul_{x})-(sum_{r}-sum_{x})dis_{x}$

然后我们把两个ans加起来就是这种情况的答案

需要注意的是，就算开了long long最终的ans也有可能是负值，所以最后要判断

```cpp
if(ans<0) ans+=mod;
```
下面是AC代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

typedef long long LL;
const int maxn=2e5+10;
const LL mod=19260817;
int n,m;
LL dis[maxn],v[maxn];
LL sum_dis[maxn],sum_v[maxn],sum_mul[maxn];

inline LL read(){
    LL Forca=0,Barca=1;
    char c=getchar();
    while(c<'0' || c>'9'){
        if(c=='-')
            Barca=-1;
        c=getchar();
    }
    while(c<='9' && c>='0'){
        Forca=(Forca*10%mod+(LL)(c-'0'))%mod;
        c=getchar();
    }
    return ((Forca%mod)*(Barca%mod)%mod);
}

int main(){
    memset(sum_dis,0,sizeof(sum_dis));
    memset(sum_v,0,sizeof(sum_v));
    memset(sum_mul,0,sizeof(sum_mul));
    n=read(),m=read();
    for(int i=2;i<=n;i++){
        dis[i]=read()%mod;
        sum_dis[i]=(sum_dis[i-1]%mod+dis[i]%mod)%mod;
    }
    for(int i=1;i<=n;i++){
        v[i]=read()%mod;
        sum_v[i]=(sum_v[i-1]%mod+v[i]%mod)%mod;
        sum_mul[i]=(sum_mul[i-1]%mod+((v[i]%mod)*(sum_dis[i]%mod)%mod)%mod)%mod;
    }
    while(m--){
        int x,l,r;
        x=read(),l=read(),r=read();
        LL ans;
        if(x<=l){
            ans=((sum_mul[r]%mod-sum_mul[l-1]%mod)%mod-(sum_v[r]%mod-sum_v[l-1]%mod)%mod*(sum_dis[x]%mod)%mod)%mod;
        }else if(x>=r){
            ans=((sum_v[r]%mod-sum_v[l-1]%mod)%mod*(sum_dis[x]%mod)%mod-(sum_mul[r]%mod-sum_mul[l-1]%mod)%mod)%mod;
        }else if(x<r && x>l){
            LL tmp1,tmp2;
            tmp1=((sum_v[x-1]%mod-sum_v[l-1]%mod)%mod*(sum_dis[x]%mod)%mod-(sum_mul[x-1]%mod-sum_mul[l-1]%mod)%mod)%mod;
            tmp2=((sum_mul[r]%mod-sum_mul[x]%mod)%mod-(sum_v[r]%mod-sum_v[x]%mod)%mod*(sum_dis[x]%mod)%mod)%mod;
            ans=(tmp1%mod+tmp2%mod)%mod;
        }
        if(ans<0) ans+=mod;
        cout<<ans%mod<<endl;
    }
    return 0;
}
```

---

## 作者：Stalker (赞：1)

没赶上模拟赛时间赛后看了一眼...

首先我们观察这题的数据规模，N/M都小于等于200000，那标解时间复杂度要么O(nlogn)要么O(N)。再仔细看题目描述，发现这题是满足前缀和性质的，即算出1~n的前缀和和答案即可在O(1)时间查询每个区间的答案。我们维护4个前缀和：

1.dis[i]表示1到i的距离之和

2.cnt[i]表示1到i的每个点的权值大小之和

3.c[i]表示把1~i的所有点运到n所要的花费

4.c2[i]表示把1~i的所有点运到1所要的花费

那么就有：

if(x>=l&&x>=r)printf("%lld\n",((c[l]-c[r+1]+mod)%mod-(cnt[r]-cnt[l-1])\*(dis[n]-dis[x])%mod+mod)%mod);

else if(x<=l&&x<=r)printf("%lld\n",((c2[r]-c2[l-1]+mod)%mod-(cnt[r]-cnt[l-1]+mod)%mod\*(dis[x]+mod)%mod+mod)%mod);

    else if(x>=l&&x<=r){

        printf("%lld\n",(((c[l]-c[x+1]+mod)%mod-(cnt[x]-cnt[l-1])\*(dis[n]-dis[x])%mod+mod)%mod+((c2[r]-c2[x]+mod)%mod-(cnt[r]-cnt[x]+mod)%mod\*(dis[x]+mod)%mod+mod)%mod)%mod);

    }
AC代码：

```cpp
#include<cstdio>
#include<iostream>
#define ll long long
using namespace std;
const ll mod=19260817;
ll n,m,d[200005],dis[200005],a[200005],cnt[200005],c[200005],c2[200005];
void work(){
    ll x,l,r;
    scanf("%lld%lld%lld",&x,&l,&r);
    if(x>=l&&x>=r)printf("%lld\n",((c[l]-c[r+1]+mod)%mod-(cnt[r]-cnt[l-1])*(dis[n]-dis[x])%mod+mod)%mod);
    else if(x<=l&&x<=r)printf("%lld\n",((c2[r]-c2[l-1]+mod)%mod-(cnt[r]-cnt[l-1]+mod)%mod*(dis[x]+mod)%mod+mod)%mod);
    else if(x>=l&&x<=r){
        printf("%lld\n",(((c[l]-c[x+1]+mod)%mod-(cnt[x]-cnt[l-1])*(dis[n]-dis[x])%mod+mod)%mod/*fff*/+((c2[r]-c2[x]+mod)%mod-(cnt[r]-cnt[x]+mod)%mod*(dis[x]+mod)%mod+mod)%mod)%mod);
    }
}
int main(){
    scanf("%lld%lld",&n,&m);
    for(ll i=2;i<=n;i++){
        scanf("%lld",&d[i]);
        d[i]%=mod;
    }
    for(ll i=1;i<=n;i++){
        scanf("%lld",&a[i]);
        a[i]%=mod;
    }
    for(ll i=1;i<=n;i++){
        dis[i]=(dis[i-1]+d[i])%mod;
    }
    for(ll i=1;i<=n;i++){
        cnt[i]=(cnt[i-1]+a[i])%mod;
    }
    for(ll i=n;i>=1;i--){
        c[i]=c[i+1]+a[i]*(dis[n]-dis[i]+mod)%mod;
        c[i]%=mod;
    }
    for(ll i=1;i<=n;i++){
        c2[i]=(c2[i-1]+a[i]*dis[i])%mod;
    }
    while(m--){
        work();
    }
    return 0;
}

```

---

## 作者：COsm0s (赞：0)

## 暴力算法（非正解）

每次从 $a(i)$ 循环至 $b(i)$，将第 $i$ 项储物点距离减去第 $x$ 项储物点距离，最后累加起来，这样的复杂度为 $O(n^2)$，在一百分 $
n,m\leq 200000$ 的数据下，肯定是过不了的。

## 前缀和优化（正解）

刚才我们从 $a(i)$ 循环至 $b(i)$ 求和用了一重循环，而这一重循环完全可以用前缀和来处理。

+ 当需要转移到的仓库在区间的左边，可以列出如下式子：

$ans=b(l)\times (x(l)-x)+b(l+1)\times (x(l+1)-x)+...+b(r)\times (x(r)=x)$

求和化简，得：

$ans=∑(b(i)\times x(i))-x\times ∑b(i)$

对第 $i$ 个点与第 $i$ 个仓库所拥有的物品的乘积进行一下求和就是将当前位置的物品转移到目标地点的价值，再减去目标仓库与区间内各个物品的和的乘积


------------

+ 对于仓库在区间的右边：

得：

$ans=x\times ∑b(i)-∑b(i)\times x(i)$


------------

+ 注意，边做前缀和边要取模，否则会挂。


Code：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
inline int read() {//快读 
	int k = 0, m = 1;
	char ch = getchar();
	while(!isdigit(ch)) {
		if(ch == '-') m = -1;
		ch = getchar();
	}
	while(isdigit(ch)) {
		k = k * 10 + ch - 48;
		ch = getchar();
	}
	return k * m;
}
const int M = 19260817;
int n, m;
long long d[200050], a[200050];
long long as[200050], ds[200050], cnt[200050];

long long check(int x, int l, int r,bool p) {
	if(l > r) return 0;//区间不存在
	long long x1 = ((as[r] - as[l-1]) % M + M) % M;
	x1 = x1 * ds[x] % M; //区间各值到x的价值
	long long x2 = ((cnt[r] - cnt[l-1]) % M + M) % M;//区间总数个的x价值
	if(!p) 
   	return ((x2 - x1) % M + M) % M;
    else
		return ((x1 - x2) % M + M) % M;
}
//判断函数，注意取模

signed main() {
	n=read(),m=read();
	for(int i=2; i<=n; i++) {
		d[i]=read();
		ds[i] = (ds[i-1] + (d[i] %= M)) % M;//ds[i]表示距离前缀和
	}
	for(int i=1; i<=n; i++) {
		a[i]=read();
		as[i] = (as[i-1] + (a[i] %= M)) % M;//as[i]表示价值前缀和
		cnt[i] = (cnt[i-1] + a[i] * ds[i] % M) % M;//cnt[i]表示价值*距离的前缀和
	}
	long long x,l,r;
	long long ANS1,ANS2;
	for(int i=1; i<=m; i++) {
		x=read(),l=read(),r=read();
		ANS1 = check(x, l, r<x-1?r:x-1,1);//ANS1表示比x大的区间价值
		ANS2 = check(x, l>x+1?l:x+1, r,0);//ANSx表示比x小的区间价值
		cout<<((ANS1 + ANS2) % M)<<endl;
	}
	return 0;
}
```


---

## 作者：XL4453 (赞：0)

    
	抱歉⋯我已经 绝对不可能再获得幸福了
	因为⋯我发现⋯
	其实我⋯
	早就已经被幸福包围了
------------
解题思路：

首先发现从一个点到另一个点的代价其实可以是一个点到中转点的代价减去中转点到目标点的的代价。

然后就想到前缀和所有点到第一个点的代价和，然后算出区间到第一个点的代价和并减去所有物品从第一个点运到中转点的代价即可。

同理，对于中转点在区间之后的可以先将其运到最后一个点然后运至中转点。

对于终点就在区间内的可以将区间拆成两个，一半向后，一半向前。

------------
代码：

```cpp
#include<cstdio>
using namespace std;
long long MOD=19260817;
long long n,m,a[200005],d[200005],sum1[200005],sum2[200005],sumd2[200005],suma[200005],sumd[200005],x,l,r,ans;
int main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<n;i++)scanf("%lld",&d[i]),sumd[i]=(sumd[i-1]+d[i])%MOD;
	for(int i=n-1;i>=1;i--)sumd2[i]=(sumd2[i+1]+d[i])%MOD;
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]),suma[i]=(suma[i-1]+a[i])%MOD;
	for(int i=2;i<=n;i++)sum1[i]=(sum1[i-1]+(a[i]*sumd[i-1])%MOD)%MOD;
	for(int i=n-1;i>=1;i--)sum2[i]=(sum2[i+1]+(a[i]*sumd2[i])%MOD)%MOD;
	for(int i=1;i<=m;i++){
		scanf("%lld%lld%lld",&x,&l,&r);
		if(x<=l)
			ans=(sum1[r]-sum1[l-1]-sumd[x-1]*((suma[r]-suma[l-1]+MOD)%MOD))%MOD;
		else
		if(x>=r)
			ans=(sum2[l]-sum2[r+1]-sumd2[x]*((suma[r]-suma[l-1]+MOD)%MOD))%MOD;
		else
			ans=((sum1[r]-sum1[x-1]-sumd[x-1]*((suma[r]-suma[x-1]+MOD)%MOD))%MOD
				+(sum2[l]-sum2[x+1]-sumd2[x]*((suma[x]-suma[l-1])%MOD)%MOD))%MOD;
		while(ans<0)ans+=MOD;
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：liangs333 (赞：0)

这道题显然可以用线段树水过去。（别问我为什么不是前缀后缀，我也很绝望啊。线段树刷到石乐志看到区间就默认线段树了呀） 好那么接下来我们开始口胡算法。对于每个区间，记录区间内的所有物品转移到区间左端点的花费，即 al （all to left）。还有所有物品到区间右端点的花费，即 ar （all to right） 。还有物品数obj。对于将一个区间内的物品转移至目标点的操作，如果目标点在区间左边，那么花费就为将所有物品转移到区间左端点的花费加上左端点到目标点的距离乘上物品数。即 cost=al+obj\*dis(left point,target point)。如果向右就变成到右边。

如果目标点在区间内，就将一个操作拆分成向左向右两个操作处理。

编写程序的时候注意科学取膜，不要暴力膜，暴力膜不可取，会折寿。考试的时候感觉为调答案莫名成为负数花费的时间远大于敲代码的时间。。（感觉这个膜数很妙妙啊。）

代码如下，其中dis用于获得两点间距。





```cpp
#include<bits/stdc++.h>
#define ls(i) (a[i].ch[0]) 
#define rs(k) (a[k].ch[1]) 
int cnt=1;
struct node{
    long long al,ar,obj;
    int ch[2];
    int l,r;
};
node a[500000];
using namespace std;
int oritim;
int lastim;
long long objc[210000];
long long ps[210000];
long long dis(int a,int b) {
    if(a<b)    swap(a,b);
    return (ps[a]-ps[b])%19260817;
}
inline void iread(int &a) {
    char c;
    a=0;
    c=getchar();
    while(c>'9'||c<'0')
        c=getchar();
    while(c<='9'&&c>='0') {
        a=(a<<3)+(a<<1)+c-'0';
        c=getchar();
    }
    return;
}
inline void lread(long long &a) {
    char c;
    a=0;
    c=getchar();
    while(c>'9'||c<'0')
        c=getchar();
    while(c<='9'&&c>='0') {
        a=(a<<3)+(a<<1)+c-'0';
        c=getchar();
    }
    return;
}
void update(int k) {
    a[k].obj=a[ls(k)].obj+a[rs(k)].obj;
    a[k].obj%=19260817;
    a[k].al=a[ls(k)].al;
    a[k].al+=a[rs(k)].al+(a[rs(k)].obj*dis(a[rs(k)].l,a[k].l));
    a[k].al%=19260817;
    a[k].ar=a[rs(k)].ar;
    a[k].ar+=a[ls(k)].ar+(a[ls(k)].obj*dis(a[ls(k)].r,a[k].r));
    a[k].ar%=19260817;
    return;
}
long long query(int k,int l,int r,int tar,bool mark) {
    if(mark==0) {
        if(l==a[k].l&&r==a[k].r) {
            return (a[k].al+(a[k].obj*dis(a[k].l,tar)));
        }
        int mid=(a[k].l+a[k].r)/2;
        if(l>mid)
            return query(rs(k),l,r,tar,0);
        else if(r<=mid)
            return query(ls(k),l,r,tar,0);
        else
            return (query(ls(k),l,mid,tar,0)+query(rs(k),mid+1,r,tar,0));
    }
    if(mark==1) {
        if(l==a[k].l&&r==a[k].r) {
            return (a[k].ar+(a[k].obj*dis(a[k].r,tar)));
        }
        int mid=(a[k].l+a[k].r)/2;
        if(l>mid)
            return query(rs(k),l,r,tar,1);
        else if(r<=mid)
            return query(ls(k),l,r,tar,1);
        else
            return (query(ls(k),l,mid,tar,1)+query(rs(k),mid+1,r,tar,1));
    }
} 
void build(int k,int l,int r) { 
    a[k].l=l;
    a[k].r=r;
    int mid=(l+r)/2;
    if(l==r) {
        a[k].obj=objc[r];
        a[k].al=0;
        a[k].ar=0;
        return;
    }
    ls(k)=cnt+1;
    build(++cnt,l,mid);
    rs(k)=cnt+1;
    build(++cnt,mid+1,r);
    update(k);
    return;
}
int n,q;
int main() {
    oritim=clock();
    long long jcq;
    scanf("%d%d",&n,&q);
    for(register int i=2;i<=n;++i) {
        lread(jcq);
        ps[i]=ps[i-1]+jcq;
    }
    for(register int i=1;i<=n;++i) {
        lread(objc[i]);
        objc[i]%=19260817;
    }
    build(1,1,n);
    int p1,p2,tar;
    while(q>0) {
        iread(tar);
        iread(p1);
        iread(p2);
        if(p1>p2) swap(p1,p2);
        if(tar>=p2) {
            printf("%lld\n",query(1,p1,p2,tar,1)%19260817);
        }
        else if(tar<=p1) {
            printf("%lld\n",query(1,p1,p2,tar,0)%19260817);
        }
        else {
            printf("%lld\n",(query(1,p1,tar,tar,1)+query(1,tar,p2,tar,0))%19260817);
        }
        q--;
    }
    return 0;
}
```

---

## 作者：Predator_SD (赞：0)

刷一发Chtholly！！！

本题两个坑点：1.前缀和的时候要每步取模

2.减法取模是:(a-b)%p=(a%p-b%p+p)%p

总体思路很简单，把求和式拆开，发现能预处理，再通过前缀和相减维护区间和就可以了


```cpp
#include<bits/stdc++.h>
#define maxn 200005
#define mod 19260817
using namespace std;
typedef unsigned long long ll;
template<typename T>
inline void read(T &x) {
    char ch; while((ch = getchar()), (ch < '0' || ch > '9'));
    x = ch - '0'; while((ch = getchar()), (ch >= '0' && ch <= '9')) x = x * 10 + (ch - '0');
}
ll p[maxn],w[maxn],wp[maxn],dw[maxn],dwp[maxn];
inline ll qw(int l,int r){
    return (dw[r]%mod-dw[l-1]%mod+mod)%mod;
}
inline ll qwp(int l,int r){
    return (dwp[r]%mod-dwp[l-1]%mod+mod)%mod;
}
int main(){
    register int n,m,i,j,x,l,r;
    register ll ans1=0,ans2=0,ans=0;
    read(n),read(m);
    for(i=2;i<=n;++i) read(p[i]),p[i]=(p[i]%mod+p[i-1])%mod;
    for(i=1;i<=n;++i) read(w[i]),wp[i]=w[i]*p[i];
    for(i=1;i<=n;++i) ans1=(ans1+w[i])%mod,ans2=(ans2+wp[i])%mod,dw[i]=ans1,dwp[i]=ans2;
    for(i=0;i<m;++i){
        read(x),read(l),read(r);
        if(x>l&&x<r){ans=((p[x]*(qw(l,x-1)-qw(x+1,r)+mod)%mod)%mod+(qwp(x+1,r)-qwp(l,x-1)+mod)%mod)%mod,printf("%lld\n",ans);continue;}
        if(x<=l){ans=(qwp(l,r)-qw(l,r)*p[x]%mod+mod)%mod,printf("%lld\n",ans);continue;}
        if(x>=r){ans=(qw(l,r)*p[x]%mod-qwp(l,r)+mod)%mod,printf("%lld\n",ans);continue;}
    }
    return 0;
}
![](https://cdn.luogu.com.cn/upload/pic/9424.png)
```

---

## 作者：Great_Influence (赞：0)

唯一一道能做出来的题目。。。太恐怖了，NOIP怕不是会挂

题目本身不难，可以用前缀和和后缀和来模拟搬运过程。可以发现向前搬答案就是加权前缀和减去多出来的部分，记一下加权前缀和和权值前缀和就可以解决了。至于向后搬，只要维护后缀和就可以了。

顺便说一下，数据很多，最好用快读快输处理。（实测不用快输提供大数据1.3s+）

代码：

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
using namespace std;
template<typename T>inline void read(T &x)//快读
{
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&(k^'-'))k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
void file()//文件，方便调试
{
    #ifndef ONLINE_JUDGE
    freopen("68.in","r",stdin);
    freopen("68.out","w",stdout);
    #endif
}
char s[10];
void write(long long x)//快速输出
{
    if(!x)
    {
        putchar('0');
        putchar('\n');
        return;
    }
    int len=0;
    while(x)
    {
        s[len++]=x%10+'0';
        x/=10;
    }
    --len;
    while(len>-1)putchar(s[len--]);
    putchar('\n');
}
const int MAXN=200100;
const long long mod=19260817ll;//膜数（太暴力了还在开十九大呢）
int n,m;
long long w[MAXN],pre[MAXN],suf[MAXN],pos[MAXN],sp[MAXN],ss[MAXN];//前缀和和后缀和
void init()
{
    read(n);read(m);
    int i;
    For(i,1,n-1)read(pos[i+1]),(pos[i+1]+=pos[i])%=mod;//预处理前缀和和后缀和
    For(i,1,n)read(w[i]);
    For(i,2,n)pre[i]=(pre[i-1]+pos[i]*w[i]%mod)%mod;
    Forward(i,n-1,1)suf[i]=(suf[i+1]+(pos[n]-pos[i]+mod)*w[i]%mod)%mod;
    For(i,1,n)sp[i]=(sp[i-1]+w[i])%mod;
    Forward(i,n,1)ss[i]=(ss[i+1]+w[i])%mod;
}
void solve()
{
    int i,x,l,r;
    For(i,1,m)
    {
        read(x);
        read(l);
        read(r);
        if(x<=l)write(((pre[r]-pre[l-1]+mod
                    -pos[x]*(sp[r]-sp[l-1]+mod)%mod+mod)%mod+mod)%mod);//直接输出。推的过程可以画一张图
        else if(x>=r)write(((suf[l]-suf[r+1]+mod
                    -(pos[n]-pos[x]+mod)*(ss[l]-ss[r+1]+mod)%mod+mod)%mod+mod)%mod);
        else write(((suf[l]-suf[x+1]+mod
                    -(pos[n]-pos[x]+mod)*(ss[l]-ss[x+1]+mod)%mod
                +pre[r]-pre[x-1]+mod-pos[x]*(sp[r]-sp[x-1]+mod)%mod+mod)%mod+mod)%mod);
    }
}
int main()
{
file();
init();
solve();
return 0;
}
```

---


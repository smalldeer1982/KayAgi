# 选择题

## 题目描述

docriz 正在考试，他遇到了一个奇怪的选择题：这个选择题共有 $n$ 个选项，其中只有一个选项是正确的。他完全不会做这题，所以只能靠蒙。

蒙这道题分为 $n - 2$ 轮，在第 $1$ 轮开始之前，docriz 会在这 $n$ 个选项中随机蒙一项，之后的每轮流程如下：首先，nocriz 会过来帮他排除一个选项，由于 nocriz 事先知道答案，所以他会在现有的除正确的那一项和 docirz 正在选的那一项外的选项里，随机删去一个。之后，docriz 可以选择是否更换自己蒙的选项，如果更换，则随机更换到除正在选的那一项之外的任意一项。

docriz 在这 $n - 2$ 轮中，由于和 nocriz 达成的神秘协定，需要恰好更换 $k$ 次选项。他想知道，如何更换，使得自己蒙对的概率最大，输出这个概率。为了方便，你需要输出这个概率的分数形式在模 $10^9 + 7$ 意义下的结果。

## 说明/提示

样例 $1$ 到 $4$ 分别为 $\frac{2}{3}, \frac{1}{3}, \frac{3}{4}, \frac{5}{8}$。

对于 $30\%$ 的数据，保证 $5 \leq n \leq 10$。

对于另外 $5\%$ 的数据，保证 $k = 0$。

对于另外 $10\%$ 的数据，保证 $k = 1$。

对于另外 $10\%$ 的数据，保证 $k = n - 2$。

对于另外 $5\%$ 的数据，保证 $n \leq 10^2$。

对于另外 $10\%$ 的数据，保证 $n \leq 10^3$。

对于 $100\%$ 的数据，保证 $5 \leq n \leq 10^5, 0 \leq k \leq n - 2$。

## 样例 #1

### 输入

```
3 1```

### 输出

```
666666672```

## 样例 #2

### 输入

```
3 0```

### 输出

```
333333336```

## 样例 #3

### 输入

```
4 1```

### 输出

```
750000006```

## 样例 #4

### 输入

```
4 2```

### 输出

```
625000005```

## 样例 #5

### 输入

```
100000 99998```

### 输出

```
439903656```

# 题解

## 作者：l_water (赞：4)

关于这只题目：有理数求余+概率数学分析。


------------
前面的大佬解释的够清楚了，于是我来介绍一些东西


------------


看见大佬解释关于什么时候更换答案，对于我这种数学渣渣只能%%%了QAQ。但是作为一个科学虚伪爱好者~~不是哲学哇~~,我将介绍一种很通俗易懂的解法关于什么时候更换选项：

------------

###### 我们先来玩个赢大奖游戏吧
```
这个游戏的玩法如下，非常简单：
1.现场有三扇关闭了的门，其中一扇的后面有辆跑车，而另外两扇门后面则各藏有一只山羊。
2.参赛者需要从中选择一扇门，如果参赛者选中后面有车的那扇门就可以赢得这辆跑车。
3.当参赛者选定了一扇门，但未去开启它的时候，节目主持人会开启剩下两扇门的其中一扇，露出其中一只山羊。
4.接下来参赛者会被问到：是否保持他的原来选择，还是转而选择剩下的那一道门？
```


------------
直觉？换？还是？不换？
# 换？不换？
然而当你纠结的时候您估计是会反抗您的直觉--------都是二分之一（因为就剩下了两个门了），然而如果真滴这么简单，这也不会拿过来考聪明的你啦！


------------
那么到底是换还是不换？这是个问题，emmm！如果您坚持您的直觉------不是二分之一，那么很高兴告诉您，您对啦，但是如果问您现在的几率是多少呢？

------------
正解是2/3！为什么呢？这个需要用到贝叶斯公式了。什么你说你布吉岛什么是贝叶斯公式？？


------------
[这儿！](http://baike.baidu.com/link?url=epdVMpZG3qA1ACqvG15ywHUKRmLp_Cfg8Z1MLYqndBjvfrhZPcdPVsYufdZRYF3cFcnBiiU9RZRiE9iCcnxz9ZF8AsZPZgeQsDRBECAcU45h-v-5i24W49I5F9vHdS0e8ZUMdytONNTjDUDR6yjB3K)
啊哈，如果你已经懂了贝叶斯公式那么问题就迎面而解了！其实这是历史上曾引起众多数学家争论的三门问题，一直到玛丽莲·沃斯·莎凡特（吉尼斯认定的最高智商人类（IQ：228））提出答案之前人们一直认为答案是1/2。什么你还不会概率.....好吧那我用思考的方式告诉您呢！
##### 看
~~摘抄而来~~
------------
```
那么我们具体分析：因为主持人知道门后对应的东西，所以只选择开启有羊的门，于是
~~~主持人一定选择山羊，事件 B 一定发生：P{B|A} = 1
~~~主持人一定选择山羊，事件 B 一定发生：P{B} = 1
那么 P{A|B} = 1/3，所以不换的胜率是1/3，因此一定要换。
那么如果改变条件，主持人并不知道门后有什么东西，那么：P{B|A} = 1而 P{B} = 1/3 * 1 + 2/3 * 1/2 = 2/3，得到 P{A|B} = 1/2 。
```
其实这种东西可以考虑一下粒子群算法，这儿就不介绍了........咳咳言归正传，那么当四门，五门，六门甚至像题目意思的问题该是怎么样的呢？

------------
[四门问题分析](https://www.zhihu.com/question/48402873)
如果您把这个看懂了，那么您根据贝叶斯公式一定可以知道所有的类推式子。
~~其实打表找规律会发现最后的概率一次比一次低，随着数量的上升,光速撤退~~

---

## 作者：Itst (赞：3)

Update On 2020.07.07: 优化阅读体验

------------

题意简述：有 $N$ 个选项，最开始随机蒙，会进行 $N-2$ 次删除操作，**必须**在其中 $K$ 次删除操作后更换自己选择的答案，求最优策略下选到正确答案的概率。

前置知识：概率、有理数取余(不会戳[这里](https://www.luogu.org/problemnew/show/P2613))

---

不妨先考虑直接确定是否选中正解的最后一次更换。设最后一次更换时包括当前选择的选项共有 $x$ 个选项,前 $K-1$ 次更换获得**错解**的概率为 $P$，那么更换后选到正确答案的概率就是 $\frac{P}{x - 1}$。当 $P$ 确定时，$x$ 越小，概率越高。也就是说最后一次更换安排在最后一次删除后，就有 $P$ 的概率选到正解，这个概率显然是最高的。

那么需要考虑 $P$ 如何取得最大值。类似地，设第 $i(i \geq 2)$ 次更换时剩下 $x$ 个选项,前 $i-1$ 次更换获得错解的概率为 $P'$，那么当前选到错误答案的概率是 $P' \frac{x-2}{x-1} + (1-P')=1-\frac{P'}{x-1}$。当 $P'$ 确定时，$x$ 越大，获得错解的概率越高。

那么可以得到最优策略：在前 $K-1$ 次删出错解后更换，第 $K$ 次更换放在最后一次删除错解之后。利用上面的式子可以将概率算出来。

小心 0 的特判。
```cpp
#include<bits/stdc++.h>
#define MOD 100000007
using namespace std;
inline int poww(long long a , int b){
    long long times = 1;
    while(b){
        if(b & 1)	times = times * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return times;
}
int main(){
    int n , k;
    scanf("%d%d" , &n , &k);
    if(k == 0)
        cout << poww(n , MOD - 2);
    else{
        k--;
        long long fz = n - 1 , fm = n;
        n -= 2;
        while(k){
            fz = ((fm = fm * n % MOD) - fz) % MOD;
            k--;
            n--;
        }
        cout << fz * poww(fm , MOD - 2) % MOD;
    }
    return 0;
}
```

---

## 作者：揽月摘星辰 (赞：2)

- 关于此题的思路，前面两位菊苣已经讲的很清楚了。这里就只是简单的说一下，如果已经看懂了两位菊苣的方法，可以直接跳到分割线后观看。
1. 我们不难想到，对于k！=0的情况我们在最后一次排除答案后改变蒙的答案是最优的。但既然我们要改变答案，那么在此之前我们应该保证我们的答案是错误的，这样改变后才有可能正确。
1. 现在问题就变成了找在最后一次改变答案前，答案是错误的概率。我们不妨分两种情况讨论（假设我们此时还有x个答案未排除,达成现在状态的概率为P）：

- 如果我们此时的答案是错误的，那么我们在女友排除了一个后还剩x-1个可选项，而x-1中还有一个正确的。所以我们选择错误的答案的概率为（X-2）/(X-1);
- 如果我们的答案是正确的，那么我们无论怎么选都是错的。所以此时概率为（1-P)。
- 综上，此时概率为（X-2)/(X-1)+(1-P),化简可得为（X-1-P)/(X-1);


------------


------------
- 这里的思路很好理解，如果懂得通过欧拉函数求有理数取余的大佬已经可以通过上两位菊苣的代码过掉此题了。
# - 但是，我并不会欧拉函数，怎么求有理数取余呢？ 
- 我们可以使用扩展gcd来达成。（这里只是简略提一下，详细请看[这里](https://www.luogu.org/problemnew/solution/P2613)
1. 对于a/b=c(mod p),我们可以转换成a%p=c*b,我们不妨设bx=1(mod p),那么原式答案就是a*x%p。此时大家应该都知道如何用exgcd解这个方程了吧;
1. 但现在问题又来了，我们怎么求得a与b呢。我们还是可以通过（X-1-P)/(X-1)这个式子来推。我们先观察分母，明显为X-1。但因为P是分数，我们直接把分母当成X-1计算很麻烦，不如再次化简，乘上P的分母即（X-2)，此时分子为（X-1)*(X-2)-P的分子。


------------


------------
最后附上代码：
```
#include<bits/stdc++.h>
using namespace std;
long long n,k;
long long mod=1000000007;
void exgcd(long long a,long long b,long long &x,long long &y)   //一定要开longlong！！！！
{
	if(b==0){
		x=1;
		y=0;
		return;
	}
	exgcd(b,a%b,y,x);
	y-=x*(a/b);         
}        //exgcd求x
long long Mod(long long a,long long b)
{
	if(b%mod==0)return 0;
    long long x,y;
    exgcd(b,mod,x,y);
    x=(x%mod+mod)%mod;   //处理负数和过大
    return a*x%mod;
}
int main()
{
	cin>>n>>k;
	long long son,mom,son_,mom_;
	if(k==0)  // 特判一下，当k==0时直接计算
	{
		cout<<Mod(1,n);
		return 0;
	}
	son_=n-1;  
	mom_=n;   //赋初值，即第一次选错的概率 
	while(n>=1&&k--)    //用mom和son储存上一次的
	{             //分子和分母，方便计算
		mom=mom_;
		son=son_;
		mom_=--n;
		mom_*=mom;
		mom_%=mod;
		son_=n*mom-son;
		son_%=mod;
	}
	cout<<Mod(son_,mom_);
	return 0;
}
```



---

## 作者：bcbgszyzh (赞：1)

本题有两种解法，分别是
1. 使用欧拉函数解决问题

   * 对于正整数 $n$，$n$ 的欧拉函数 $\varphi(n)$ 表示小于等于 $n$ 且与 $n$ 互质的正整数的个数。
  
   * 可利用以下两个性质解决本题：
  
     1. 如果 $n$ 是质数，那么 $\varphi(n)= n -1$ ，因为只有 $n$ 本身与它不互质。
     2. 如果 $p,q$ 都是质数，那么 $\varphi(pq)=\varphi(p)\varphi(q)=(p-1)(q-1)$。
2. 使用扩展 gcd 来求值
   * 这个太简单了，不想说了。

感谢查看！

---


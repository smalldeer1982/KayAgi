# 恋恋的数学题

## 题目背景

恋恋是个可爱的女孩子，最近她沉迷了做数学题。

## 题目描述

现在恋恋正在处理的题目十分简单：现在有$k \space (2\leq k\leq 4)$个数，恋恋不知道它们分别是几，只知道它们**两两**最大公约数及最小公倍数。

按照套路，恋恋非常想复原出那$k$个数，但是现在她需要假装不会做，于是她就把题目交给了你，如果你顺利解决了这个问题，恋恋就会在你背后疯狂打call……

## 说明/提示

**保证奇数测试点中，第一行（gcd行）数据均为$1$**

|测试点编号　　　|$k$　　　|输入整数不超过　　　|
|-|-|-|
|1,2|2|$100$|
|3,4|2|$1000$|
|5,6|2|$10^7$|
|7,8|3|$100$|
|9,10|3|$10^7$|
|11,12|3|$10^{14}$|
|13,14|4|$100$|
|15,16|4|$10^7$|
|17,18|4|$10^{14}$|
|19,20|4|$10^{18}$|

**保证数据有解**，$T\leq 5$

**SPJ按照每组中的正确比例给分，但如果TLE、RE等会导致无输出而爆零**

## 样例 #1

### 输入

```
1 3
4 6 2
48 144 36```

### 输出

```
16 12 18```

## 样例 #2

### 输入

```
2 4
4 2 4 6 4 2
48 144 16 36 12 36
1 1 1 1 2 1 
56 63 70 72 40 90 ```

### 输出

```
16 12 18 4
7 8 9 10```

# 题解

## 作者：Scarlet (赞：30)

大家好，我出来卖萌了，相信大家这题做的都很开心（

### 题解

$k=2$时，直接输出两数，易知正确

---

$k=3$时，考虑到，$(a,b)[a,b]=ab$，那么六个数乘起来就是$(abc)^2$

因为直接计算$(abc)^2$会爆`__int128`，所以考虑计算$\frac{(a,b)[a,b](a,c)[a,c]}{(b,c)[b,c]}=\frac{a^2bc}{bc}=a^2$，然后就能算出$a$。但是$a^2bc$也会爆 `__int128`，所以先让ab除掉gcd(ab,bc)，再让ac除掉bc/gcd(ab,bc)，就可以把两边直接相乘了。

到此，我们可以枚举三个gcd和三个lcm分别怎么配对，就能分别计算出$a$,$b$,$c$

---

$k=4$时，考虑到对应顺序确定的$k=3$问题的答案是确定的，那么只要枚举某三个和另三个怎么配对，再检验一下剩下三个是否正确就行。

---

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef __int128 LLL;
LLL gcd(LLL a, LLL b) { return b ? gcd(b, a % b) : a; }
LLL lcm(LLL a, LLL b) { return a / gcd(a, b) * b; }
LLL div(LLL a, LLL b, LLL c) //a*b/c;
{
	LLL d1 = gcd(a, c), d2 = c / d1;
	return (a / d1) * (b / d2);
}
LLL sqrt(LLL a)
{
	LLL mid, l = 1, r = 1e18;
	for (; l <= r;)
	{
		mid = l + r >> 1;
		if (mid * mid == a)
			return mid;
		else if (mid * mid < a)
			l = mid + 1;
		else
			r = mid - 1;
	}
	return 0;
}
vector<LL> solve3(LLL g1, LLL g2, LLL g3, LLL l1, LLL l2, LLL l3) //solve (a,b)=g1 (a,c)=g2 (b,c)=g3
{
	LLL ab = g1 * l1, ac = g2 * l2, bc = g3 * l3;
	LLL a2 = div(ab, ac, bc), b2 = div(bc, ab, ac), c2 = div(ac, bc, ab);
	LL a = sqrt(a2), b = sqrt(b2), c = sqrt(c2);
	if (a * b * c == 0)
		return {};
	if (gcd(a, b) == g1 && gcd(a, c) == g2 && gcd(b, c) == g3 && lcm(a, b) == l1 && lcm(a, c) == l2 && lcm(b, c) == l3)
		return {a, b, c};
	else
		return {};
}
LL g[10], l[10];
int k, s;
int work()
{
	s = k * (k - 1) / 2;
	for (int i = 1; i <= s; i++)
		cin >> g[i];
	for (int i = 1; i <= s; i++)
		cin >> l[i];
	if (k == 2)
		printf("%lld %lld\n", l[1], g[1]);
	else if (k == 3)
		for (int _ = 6; _--; next_permutation(g + 1, g + 1 + s))
			for (int __ = 6; __--; next_permutation(l + 1, l + 1 + s))
			{
				auto k = solve3(g[1], g[2], g[3], l[1], l[2], l[3]);
				if (k.size() == 0)
					continue;
				else
					return printf("%lld %lld %lld\n", k[0], k[1], k[2]), 0;
			}
	else
		for (int _ = 720; _--; next_permutation(g + 1, g + 1 + s))
			for (int __ = 720; __--; next_permutation(l + 1, l + 1 + s))
			{
				auto k = solve3(g[1], g[2], g[3], l[1], l[2], l[3]), kk = solve3(g[1], g[4], g[5], l[1], l[4], l[5]);
				if (k.size() == 0 || kk.size() == 0)
					continue;
				if (k[0] != kk[0] || k[1] != kk[1])
					continue;
				vector<LL> ans = {k[0], k[1], k[2], kk[2]};
				if (gcd(ans[2], ans[3]) != g[6] || lcm(ans[2], ans[3]) != l[6])
					continue;
				else
					return printf("%lld %lld %lld %lld\n", ans[0], ans[1], ans[2], ans[3]), 0;
			}
}
int main()
{
	int T;
	for (scanf("%d%d", &T, &k); T--;)
		work();
	return 0;
}
```

---

## 作者：TheLostWeak (赞：8)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/Luogu5316.html)

**大致题意：** 乱序给出$k$个数两两$gcd$和$lcm$，让你求出这$k$个数。

### 前言

比赛时看到这题心想神仙题，然后发现$2\le k\le4$。。。

于是又想快一个小时，才差不多想到了正解。

结果写完之后少加了一句检验，就被卡掉$2$分，只剩$98$了$2333$。

### $k=2$

$k=2$应该是比较简单的，考虑到保证有解，因此直接把给出的数输出即可。

### $k=3$

$k=3$的情况略微复杂。

考虑到乱序不太好做，一个很直接的想法，我们**全排列**来枚举对应顺序。

则最后可以得到：

$$gcd(v_1,v_2),gcd(v_1,v_3),gcd(v_2,v_3)$$

$$lcm(v_1,v_2),lcm(v_1,v_3),lcm(v_2,v_3)$$

然后如果你知道一个很显然的性质，那么这题就很水了：

$$x\cdot y=gcd(x,y)\cdot lcm(x,y)$$

也就是说，我们可以将上面的式子两两相乘得到$v_1\cdot v_2,v_1\cdot v_3,v_2\cdot v_3$的值。（注意相乘会爆$long\ long$，因此需要开$\_\_int128$）

然后，如果我们求出$v_1\cdot v_2,v_1\cdot v_3$的$gcd$，则它就相当于是$v_1\cdot gcd(v_2,v_3)$。

因此，我们用$gcd(v_1\cdot v_2,v_1\cdot v_3)$去除以$gcd(v_2,v_3)$，就得到了$v_1$的值！

而$v_2$和$v_3$既然已知与$v_1$的乘积，就可以直接通过除法算出。

注意在枚举到的一种排列中，有许多无解的情况需要特判，列举如下：

- 两个数对应的$lcm$不能整除这两个数对应的$gcd$。
- $gcd(v_1\cdot v_2,v_1\cdot v_3)$不能整除$gcd(v_2,v_3)$。
- 最后算出的$v_2\cdot v_3$不等于$gcd(v_2,v_3)*lcm(v_2,v_3)$。
- 最后算出的$gcd(v_1,v_2),gcd(v_1,v_3),gcd(v_2,v_3)$与已知数据不符（我就是少判了这个丢了$2$分）。

### $k=4$

知道了$k=3$，$k=4$其实只要在此基础上加一些细节就可以了。

这次我们需要全排列套全排列，才能使得最后的对应顺序恰好为：

$$gcd(v_1,v_2),gcd(v_1,v_3),gcd(v_1,v_4),gcd(v_2,v_3),gcd(v_2,v_4),gcd(v_3,v_4)$$

$$lcm(v_1,v_2),lcm(v_1,v_3),lcm(v_1,v_4),lcm(v_2,v_3),lcm(v_2,v_4),lcm(v_3,v_4)$$

接下来，我们可以像前面一样先求出$v_1,v_2,v_3$的值，然后计算出$v_4$的值并检验即可。

具体实现详见代码。

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define LL long long
using namespace std;
int n,m;__int128 a[10],b[10];
Tp I void read(Ty& x)//读入__int128
{
	char c;x=0;W(!isdigit(c=getchar()));
	W(x=(x<<3)+(x<<1)+(c&15),isdigit(c=getchar()));
}
Tp I Ty gcd(Con Ty& x,Con Ty& y) {return y?gcd(y,x%y):x;}//求gcd
class Dfser_for_Three
{
	private:
		bool vis[10];__int128 s[10];
		I bool Calc()//求答案
		{
			__int128 v1,v2,v3;if(gcd(a[1]*s[1],a[2]*s[2])%a[3]) return 0;//判无解
			v1=gcd(a[1]*s[1],a[2]*s[2])/a[3],v2=a[1]*s[1]/v1,v3=a[2]*s[2]/v1;//求出v1,v2,v3
			if(v2*v3!=a[3]*s[3]||gcd(v1,v2)^a[1]||gcd(v1,v3)^a[2]||gcd(v2,v3)^a[3]) return 0;//判无解
			return printf("%lld %lld %lld\n",(LL)v1,(LL)v2,(LL)v3),1;//输出答案
		}
	public:
		I bool dfs(CI x)//全排列
		{
			if(x>3) return Calc();
			for(RI i=1;i<=3;++i) if(!vis[i]&&!(b[i]%a[x]))//剪枝
			{
				if(vis[i]=1,s[x]=b[i],dfs(x+1)) return vis[i]=0,1;
				vis[i]=0;
			}return 0;
		}
}D3;
class Dfser_for_Four
{
	private:
		bool vis1[10],vis2[10];__int128 s1[10],s2[10];
		I bool Calc()//求答案，与上面类似
		{
			__int128 v1,v2,v3,v4;if(gcd(s1[1]*s2[1],s1[2]*s2[2])%s1[4]) return 0;
			v1=gcd(s1[1]*s2[1],s1[2]*s2[2])/s1[4],v2=s1[1]*s2[1]/v1,v3=s1[2]*s2[2]/v1;//求出v1,v2,v3
			if(s1[3]*s2[3]%v1) return 0;v4=s1[3]*s2[3]/v1;//求出v4
			if(v2*v3!=s1[4]*s2[4]||v2*v4!=s1[5]*s2[5]||v3*v4!=s1[6]*s2[6]) return 0;//判无解
			if(gcd(v1,v2)^s1[1]||gcd(v1,v3)^s1[2]||gcd(v1,v4)^s1[3]) return 0;//判无解
			if(gcd(v2,v3)^s1[4]||gcd(v2,v4)^s1[5]||gcd(v3,v4)^s1[6]) return 0;//判无解
			return printf("%lld %lld %lld %lld\n",(LL)v1,(LL)v2,(LL)v3,(LL)v4),1;//输出答案
		}
		I bool dfs2(CI x)//第二层全排列
		{
			if(x>6) return Calc();
			for(RI i=1;i<=6;++i) if(!vis2[i]&&!(b[i]%s1[x]))
			{
				if(vis2[i]=1,s2[x]=b[i],dfs2(x+1)) return vis2[i]=0,1;
				vis2[i]=0;
			}return 0;
		}
	public:
		I bool dfs1(CI x)//第一层全排列
		{
			if(x>6) return dfs2(1);
			for(RI i=1;i<=6;++i) if(!vis1[i])
			{
				if(vis1[i]=1,s1[x]=a[i],dfs1(x+1)) return vis1[i]=0,1;
				vis1[i]=0;
			}return 0;
		}
}D4;
int main()
{
	RI Ttot,i;cin>>Ttot>>n,m=n*(n-1)>>1;W(Ttot--)
	{
		for(i=1;i<=m;++i) read(a[i]);for(i=1;i<=m;++i) read(b[i]);
		if(n==2) {printf("%lld %lld\n",(LL)a[1],(LL)b[1]);continue;}//对于两个数直接输出
		if(n==3) {D3.dfs(1);continue;}D4.dfs1(1);
	}return 0;
}
```



---

## 作者：ywy_c_asm (赞：3)

首先我们可以暴力$O(4!*4!)$枚举这些$gcd$和$lcm$各自是哪两对的$gcd$和$lcm$，也就相当于知道了两两之间的乘积是啥，我们以$k=3$为例，$ab=A,bc=B,cd=C$，那么显然有$gcd(A,B)=bgcd(a,c)$，而后者已知，那么就能求出$b$，同理这$k$个东西都能这样解出来，判一下合法即可。

另外$k=2$的时候直接把输入的2个数输出即可……因为显然有$lcm(lcm,gcd)=lcm,gcd(gcd,lcm)=gcd$……我打了个pollard_rho之后才意识到这个……

啥？$gcd,lcm<=10^{18}$乘一块爆了？__int128了解一下……~~毕竟python都能用……~~

上代码~

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define ll __int128
#define abs(_o) ((_o < 0) ? -(_o) : _o)
using namespace std;
namespace ywy {
	int id[5][5];
	int a[10], b[10];
	inline ll get() {
	    ll n = 0;
	    char c;
	    while ((c = getchar()) || 23333) {
	        if (c >= '0' && c <= '9')
	            break;
	        if (c == '-')
	            goto s;
	    }
	    n = c - '0';
	    while ((c = getchar()) || 23333) {
	        if (c >= '0' && c <= '9')
	            n = n * 10 + c - '0';
	        else
	            return (n);
	    }
	s:
	    while ((c = getchar()) || 23333) {
	        if (c >= '0' && c <= '9')
	            n = n * 10 - c + '0';
	        else
	            return (n);
	    }
	}
	ll dgcd[10], dlcm[10];
	inline ll gcd(ll a, ll b) {
	    while (b) {
	        ll r = a % b;
	        a = b;
	        b = r;
	    }
	    return (a);
	}
	void print(ll num) {
	    if (num >= 10)
	        print(num / 10);
	    putchar(num % 10 + '0');
	}
	int dx[10], dy[10];
	ll real[5];
	void ywymain() {
	    int t, n;
	    cin >> t >> n;
	    while (t) {
	        t--;
	        if (n == 2) {
	            ll a = get(), b = get();
	            print(a);
	            putchar(' ');
	            print(b);
	            putchar('\n');
	            continue;
	        }
	        int d = (n * (n - 1)) / 2;
	        for (register int i = 1; i <= d; i++) {
	            a[i] = b[i] = i;
	            dgcd[i] = get();
	        }
	        for (register int i = 1; i <= d; i++) dlcm[i] = get();
	        int gn = 1;
	        for (register int i = 1; i <= n; i++) {
	            for (register int j = 1; j < i; j++) id[i][j] = id[j][i] = gn, dx[gn] = i, dy[gn] = j, gn++;
	        }
	        do {
	            for (register int i = 1; i <= d; i++) b[i] = i;
	            do {
	                memset(real, 0, sizeof(real));
	                for (register int i = 1; i <= d; i++) {
	                    for (register int j = 1; j <= d; j++) {
	                        if (dx[i] == dx[j] && dy[i] == dy[j])
	                            continue;
	                        if (dx[i] == dx[j]) {
	                            ll cjr = gcd(dgcd[a[i]] * dlcm[b[i]], dgcd[a[j]] * dlcm[b[j]]) /
	                                     dgcd[a[id[dy[i]][dy[j]]]];
	                            if (!real[dx[i]]) {
	                                real[dx[i]] = cjr;
	                            } else {
	                                if (real[dx[i]] != cjr)
	                                    goto t;
	                            }
	                        }
	                        if (dy[i] == dy[j]) {
	                            ll cjr = gcd(dgcd[a[i]] * dlcm[b[i]], dgcd[a[j]] * dlcm[b[j]]) /
	                                     dgcd[a[id[dx[i]][dx[j]]]];
	                            if (!real[dy[i]]) {
	                                real[dy[i]] = cjr;
	                            } else {
	                                if (real[dy[i]] != cjr)
	                                    goto t;
	                            }
	                        }
	                        if (dy[i] == dx[j]) {
	                            ll cjr = gcd(dgcd[a[i]] * dlcm[b[i]], dgcd[a[j]] * dlcm[b[j]]) /
	                                     dgcd[a[id[dx[i]][dy[j]]]];
	                            if (!real[dy[i]]) {
	                                real[dy[i]] = cjr;
	                            } else {
	                                if (real[dy[i]] != cjr)
	                                    goto t;
	                            }
	                        }
	                        if (dx[i] == dy[j]) {
	                            ll cjr = gcd(dgcd[a[i]] * dlcm[b[i]], dgcd[a[j]] * dlcm[b[j]]) /
	                                     dgcd[a[id[dy[i]][dx[j]]]];
	                            if (!real[dx[i]]) {
	                                real[dx[i]] = cjr;
	                            } else {
	                                if (real[dx[i]] != cjr)
	                                    goto t;
	                            }
	                        }
	                    }
	                }
	                for (register int i = 1; i <= n; i++) {
	                    if (!real[i])
	                        goto t;
	                    for (register int j = 1; j < i; j++) {
	                        if (gcd(real[i], real[j]) != dgcd[a[id[i][j]]])
	                            goto t;
	                        if ((real[i] * real[j]) / gcd(real[i], real[j]) != dlcm[b[id[i][j]]])
	                            goto t;
	                    }
	                }
	                for (register int i = 1; i <= n; i++) print(real[i]), putchar(' ');
	                cout << endl;
	                goto s;
	            t:;
	            } while (next_permutation(b + 1, b + 1 + d));
	        } while (next_permutation(a + 1, a + 1 + d));
	    s:;
	    }
	}
}
int main() {
    ywy::ywymain();
    return (0);
}
```

---

## 作者：BreakPlus (赞：2)

### Update On 2020/8/25 纠正了一个小错误。

[原题传送门](https://www.luogu.com.cn/problem/P5316)

[~~本人的悲惨经历~~](https://www.luogu.com.cn/record/list?user=334727&pid=P5316&page=1)

相信大家都看好题面了，我们进入正题。

首先我们要知道怎么用两两之间的 $\gcd$ 和 $\operatorname{lcm}$ 来求出这些数。

+ 第一步：解决 $k=2$ 的情况

$ \ \ \ \ \ $ 直接输出两个数。。。这些分白送的

+ 第二步：推导公式，得出 $a \times b=\gcd(x,y) \times \operatorname{lcm}(x,y)$

$ \ \ \ \ \ $设 $x=\gcd(a,b)\;\;$,$\;\;y=\operatorname{lcm}(a,b)$ 。

$ \ \ \ \ \ $则 $a=m \times x\;\;$,$\;\;b=n\times x\;\;$,$\;\;m$ 与 $n$ 互质。

$ \ \ \ \ \ $故 $y=m\times n \times x$ 。

$ \ \ \ \ \ $因此 $x\times y=x\times (m\times n\times x)=(m\times x)\times (n\times x)=a\times b$ 即 $a\times b=\gcd(a,b)\times \operatorname{lcm}(a,b)$ 。


+ 第三步：解决 $k=3$ 的情况

$ \ \ \ \ $ 首先我们要知道如何通过两两之间的 $\gcd$ 和 $\operatorname{lcm}$ 来求出这些数。

$ \ \ \ \ $ 第二步的公式派上用场了。

$ \ \ \ \ $ 设 $F$ 为所有的最大公约数，$H$ 为最小公倍数，$A,B,C$代表答案中的三个数。

$ \ \ \ \ $ 假设 $F_1=\gcd(a,b),F_2=\gcd(b,c),F_3=\gcd(a,c)$

$ \ \ \ \ $ $H_1=\operatorname{lcm}(a,b),H_2=\operatorname{lcm}(b,c),F_3=\operatorname{lcm}(a,c)$

$ \ \ \ \ $ 那么根据刚才的公式，得 $\dfrac{F_1 \times H_1 \times F_2 \times H_2}{F_3 \times H_3}=\dfrac{A^2BC}{BC}=A^2$

$ \ \ \ \ $ 但是这样连 ``__int128`` 都会爆炸，所以我们需要把分号的上下边都除掉 $\gcd(AB,BC)$ 即可。


$ \ \ \ \ $ 最后我们按照类似的方法求出 $B,C$。

$ \ \ \ \ $ 枚举 $F$ 和 $H$ 的全排列即可，我们可以用到 ``STL`` 里面的 ``next_permutation`` 函数。

+ 第四步：解决 $k=4$

$ \ \ \ \ $ 这个和 $k=3$ 的方法是差不多的，可以按照上面的公式依次求出 $A,B,C,D$，建议自己推导，我就不详细讲解了。

是不是很简单呢？

上代码。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define ll __int128
ll g[10],l[10];
int t,k,n;
inline ll gcd(ll A,ll B)
{
    if(A==0)
    {
        A=B;B=0;
    }
    return B?gcd(B%A,A):A;
}//最大公约数
inline ll lcm(ll A,ll B)
{
    if(gcd(A,B)==0) return 0;
    return A*B/gcd(A,B);
}//最小公倍数
inline ll Sqrt(ll x)
{
    ll L=1,R=1e18;
    while(L<=R)
    {
        ll MID=(L+R)/2;
        if(MID*MID==x) return MID;
        else if(MID*MID<x) L=MID+1;
        else R=MID-1;
    }
    return -1;
}//二分开根号
inline ll read()
{
    ll f=0;char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') {f=f*10+ch-'0';ch=getchar();}
    return f;
}//读入
inline void write(ll x)
{
    int num[50],cnt=0;
    ll X=x;
    do{
        cnt++;
        num[cnt]=int(X%10);
        X/=10;
    }while(X);
    for(int i=cnt;i>=1;i--) printf("%d",num[i]);
}//输出
inline void work2()
{
    write(g[1]);printf(" ");
    write(l[1]);puts("");
}//k=2 的情况
inline void work3()
{
    sort(g+1,g+4);
    sort(l+1,l+4);
    for(int i=1;i<=6;i++)
    {
        next_permutation(g+1,g+4);
        for(int j=1;j<=6;j++)
        {
            next_permutation(l+1,l+4);
            ll ab=g[1]*l[1],bc=g[2]*l[2],ac=g[3]*l[3];
            ll tg=gcd(ab,bc);
            ll AB=ab/tg,BC=bc/tg;
            ll AA=AB*ac/BC;
            ll A=Sqrt(AA);
            if(A==-1) continue;
            ll B=ab/A;
            ll C=ac/A;
            if(gcd(A,B)==g[1]&&lcm(A,B)==l[1])
            if(gcd(B,C)==g[2]&&lcm(B,C)==l[2])
            if(gcd(A,C)==g[3]&&lcm(A,C)==l[3])
            {
                write(A);printf(" ");
                write(B);printf(" ");
                write(C);puts("");
                return;
            }
        }
    }
}//k=3 的情况
inline void work4()
{
    sort(g+1,g+7);
    sort(l+1,l+7);
    for(int i=1;i<=720;i++)
    {
        next_permutation(g+1,g+7);
        for(int j=1;j<=720;j++)
        {
            next_permutation(l+1,l+7);
            ll ab=g[1]*l[1],ac=g[2]*l[2],ad=g[3]*l[3],bc=g[4]*l[4],bd=g[5]*l[5],cd=g[6]*l[6];
            ll tg=gcd(ab,bc);
            ll AB=ab/tg;ll BC=bc/tg;
            ll AA=AB*ac/BC;
            ll A=Sqrt(AA);
            if(A==-1) continue;
            ll B=ab/A;
            ll C=ac/A;
            ll D=ad/A;
            if(gcd(A,B)==g[1]&&lcm(A,B)==l[1])
            if(gcd(A,C)==g[2]&&lcm(A,C)==l[2])
            if(gcd(A,D)==g[3]&&lcm(A,D)==l[3])
            if(gcd(B,C)==g[4]&&lcm(B,C)==l[4])
            if(gcd(B,D)==g[5]&&lcm(B,D)==l[5])
            if(gcd(C,D)==g[6]&&lcm(C,D)==l[6])
            {
                write(A);printf(" ");
                write(B);printf(" ");
                write(C);printf(" ");
                write(D);puts("");
                return;
            }
        }
    }
}//k=4 的情况
int main()
{
    scanf("%d%d",&t,&k);
    for(int i=1;i<=t;i++)
    {
        int s=k*(k-1)/2;

        for(int j=1;j<=s;j++) g[j]=read();
        for(int j=1;j<=s;j++) l[j]=read();
        if(k==2) work2();
        else if(k==3) work3();
        else if(k==4) work4();
    }
    return 0;
}//主程序

```

---

## 作者：mrsrz (赞：2)

作为一个暴力选手，并不想讨论那么多东西，只需追求暴力美学。

Pollard_Rho+爆搜即可。当然Pollard_Rho只是个板子，精髓在于爆搜（雾）

首先假设给你的\\(\gcd\\)和\\(\rm{lcm}\\)是按顺序排列的。

我们对每个数分解质因数，然后对每种质因数分别考虑。

假设两个数的\\(\gcd\\)中含有\\(p^a\\)，\\(\rm{lcm}\\)中含有\\(p^b\\)，\\(0\leqslant a\leqslant b\\)则必定一个数含有\\(p^a\\)，一个数含有\\(p^b\\)。

那么我们暴力dfs，对每个数给它匹配一下就好了。

乱序怎么办？

反正也就\\(6!\times 6!\\)种不同的对应方式，大不了枚举全排列呗……

枚举其对应方式，对每种对应方式的每个不同质因数爆搜匹配。如果所有质因数都成功匹配了，就说明找到了一组合法解。

这样直接用```__int128```即可，也不用担心什么中间过程会爆了。

实际上速度也就比正解做法差了100ms左右。

~~比赛的时候只枚举了一层全排列还有些细节写挂导致挂成84~~

## Code：
```cpp
#include<cstdio>
#include<map>
#include<vector>
#include<cstdlib>
#include<algorithm>
#include<ctime>
#include<set>
typedef long long LL;
#ifndef ONLINE_JUDGE
#define __int128 LL
#endif
using std::__gcd;
int T,n;
LL GCD[5][5],LCM[5][5],__[20],__2[20];
std::set<LL>ret;
std::map<LL,int>mn[5][5],mx[5][5],___[233],___2[233];
std::set<LL>s;__int128 r[5];
int cnt[5];
int ok=0;
LL P;
inline void chkmax(int&a,int b){a=(a>b)?a:b;}
inline void chkmin(int&a,int b){a=(a<b)?a:b;}
void Write(__int128 x){
	if (x<0) x=-x,putchar('-');
	if (x>9) Write(x/10);
	putchar(x%10+'0');
}
inline LL pow(LL a,int b){
	LL ret=1;
	while(b--)ret*=a;
	return ret;
}
namespace rho{
	inline LL mul(LL a,LL b,const LL&md){
		const LL c=a*b-(LL)((long double)a*b/md+.5)*md;
		return(c>>63&md)+c;
	}
	inline LL pow(LL a,LL b,const LL&md){
		LL ret=1;
		for(;b;b>>=1,a=mul(a,a,md))if(b&1)ret=mul(ret,a,md);
		return ret;
	}
	namespace MR{
		const int P[]={2,3,5,7,11,13,17,19,23,29,31,37};
		bool test(int a,LL n){
			LL x=n-1;int d=0;
			while(!(x&1))++d,x>>=1;
			x=pow(a,x,n);
			while(d--){
				const LL lst=x;
				x=mul(x,x,n);
				if(x==1&&lst!=1&&lst!=n-1)return 0;
			}
			return x==1;
		}
		bool check(LL n){
			for(int i:P)if(n==i)return 1;
			if(!(n&1))return 0;
			for(int i:P)if(!test(i,n))return 0;
			return 1;
		}
	}
	LL find(LL n,int c){
		LL x=rand()%(n-1)+1,y=x,k=2,q=1,t=1;
		for(;;k<<=1,y=x,q=1){
			for(int i=1;i<=k;++i){
				x=mul(x,x,n)+c-n;x+=x>>63&n;
				q=mul(q,llabs(x-y),n);
				if(!(i&127)){
					t=std::__gcd(q,n);
					if(t>1)return t;
				}
			}
			t=std::__gcd(q,n);
			if(t>1)return t;
		}
	}
	void rho(LL n){
		if(n==1)return;
		if(MR::check(n))return (void)ret.insert(n);
		LL p=n;int c=19260817;
		while(p==n)p=find(p,c--);
		while(n%p==0)n/=p;
		rho(p),rho(n);
	}
}
void dfs(int i,int j){
	if(ok)return;
	if(i==n){
		ok=1;
		for(int i=1;i<=n;++i)
		r[i]*=pow(P,cnt[i]);
	}else{
		if(j>n)return dfs(i+1,i+2);
		int mnx=mn[i][j][P],mxx=mx[i][j][P];
		if(mxx==0)mxx=mnx;
		if(cnt[i]==-1){
			if(cnt[j]==-1){
				cnt[i]=mnx,cnt[j]=mxx;
				dfs(i,j+1);
				if(mnx!=mxx)
				cnt[j]=mnx,cnt[i]=mxx,
				dfs(i,j+1);
				cnt[i]=cnt[j]=-1;
			}else{
				if(cnt[j]==mxx)cnt[i]=mnx,dfs(i,j+1);else
				if(cnt[j]==mnx)cnt[i]=mxx,dfs(i,j+1);
				cnt[i]=-1;
			}
		}else{
			if(cnt[j]==-1){
				if(cnt[i]==mxx)cnt[j]=mnx,dfs(i,j+1);else
				if(cnt[i]==mnx)cnt[j]=mxx,dfs(i,j+1);
				cnt[j]=-1;
			}else{
				if(cnt[i]==mnx&&cnt[j]==mxx||cnt[i]==mxx&&cnt[j]==mnx)dfs(i,j+1);
			}
		}
	}
}
int main(){
	srand(time(0));
	scanf("%d%d",&T,&n);
	while(T--){
		s.clear();
		for(int i=1;i<n;++i)
		for(int j=i+1;j<=n;++j)mx[i][j].clear(),mn[i][j].clear();
		for(int i=1;i<n;++i)
		for(int j=i+1;j<=n;++j)
		scanf("%lld",&GCD[i][j]);
		for(int i=1;i<n;++i)
		for(int j=i+1;j<=n;++j)
		scanf("%lld",&LCM[i][j]);
		for(int i=1;i<=n*(n-1)/2;++i)__[i]=__2[i]=i;
		int t=0;
		for(int i=1;i<n;++i)
		for(int j=i+1;j<=n;++j){
			++t;
			___2[t].clear();
			ret.clear();
			LL a=GCD[i][j];
			rho::rho(a);
			for(LL x:ret){
				int cnt=0;
				while(a%x==0)a/=x,++cnt;
				chkmax(___2[t][x],cnt);
				s.insert(x);
			}
		}
		t=0;
		for(int i=1;i<n;++i)
		for(int j=i+1;j<=n;++j){
			++t;
			___[t].clear();
			ret.clear();
			LL a=LCM[i][j];
			rho::rho(a);
			for(LL x:ret){
				int cnt=0;
				while(a%x==0)a/=x,++cnt;
				if(___[t].count(x))chkmin(___[t][x],cnt);else ___[t][x]=cnt;
				s.insert(x);
			}
		}
		do{
			do{
				int t=0;
				for(int i=1;i<n;++i)
				for(int j=i+1;j<=n;++j){
					++t;
					mx[i][j]=___[__[t]];
					mn[i][j]=___2[__2[t]];
				}
				for(int i=1;i<=n;++i)r[i]=1;
				bool yes=1;
				for(LL P:s){
					::P=P;
					ok=0;
					for(int i=1;i<=n;++i)cnt[i]=-1;
					dfs(1,2);
					if(!ok){
						yes=0;break;
					}
				}
				if(yes)goto succ;
			}while(std::next_permutation(__2+1,__2+t+1));
		}while(std::next_permutation(__+1,__+t+1));
		succ:
		for(int i=1;i<n;++i)
		Write(r[i]),putchar(' ');
		Write(r[n]),putchar('\n');
	}
	return 0;
}
```

---

## 作者：AThousandSuns (赞：2)

感谢良心出题人Scarlet~ Q^Q

发现 $k$ 的范围巨小，就可以乱搞了。

对于 $k=2$，显然答案就是输入的两个数。

然后想到 $xy=\gcd(x,y)\operatorname{lcm}(x,y)$，我们可以枚举每对数的 $\gcd$ 和 $\operatorname{lcm}$ 是哪个。

对于 $k=3$，我们已经知道了 $x_1x_2,x_1x_3,x_2x_3$ 的值，那么解个方程看看是不是整数就行了。

对于 $k=4$，可以先解出其中三个未知数，然后判断是否存在合法的第四个数。

然后由于不想用__int128（毕竟CCF系列不给用），就用了long double。怕掉精度，就再加了很多的判断。

时间复杂度 $O((\frac{k(k-1)}{2}!)^2k^2\log v)$，然而基本达不到上界，跑得巨快，所有点都是3ms。（似乎还是最优解？）

赛后听出题人说似乎卡不掉long double，真的良心啊……~~明明是想毒瘤却毒瘤不起来~~

一开始挂在快读没开long long上，结果一下跌到了rk12……本来可以rk1的……

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef long double ld;
typedef pair<int,int> PII;
const int maxn=100010;
#define MP make_pair
#define PB push_back
#define lson o<<1,l,mid
#define rson o<<1|1,mid+1,r
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define ROF(i,a,b) for(int i=(a);i>=(b);i--)
#define MEM(x,v) memset(x,v,sizeof(x))
inline ll read(){
	char ch=getchar();ll x=0,f=0;
	while(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();
	while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
	return f?-x:x;
}
int t,k,n;
ll a[10],b[10],tmp[10],ans[10];
bool check(ld x){	//判断是不是整数
	return min(ceil(x)-x,x-floor(x))<=1e-5;
}
bool equal(ld x,ld y,ld z){	//判断三个数是否相同
	return fabs(x-z)<=1e-5 && fabs(y-z)<=1e-5;
}
ll gcd(ll x,ll y){
	return y?gcd(y,x%y):x;
}
ll lcm(ll x,ll y){
	return x/gcd(x,y)*y;
}
int main(){
	t=read();k=read();n=k*(k-1)/2;
	while(t--){
		FOR(i,1,n) a[i]=read();
		FOR(i,1,n) tmp[i]=read();
		if(k==2) printf("%lld %lld\n",a[1],tmp[1]);
		else{
			sort(a+1,a+n+1);sort(tmp+1,tmp+n+1);
			MEM(ans,0);
			do{
				FOR(i,1,n) b[i]=tmp[i];
				do{
					ld a1,a2,a3;
					a1=sqrt((ld)b[1]/a[3]/b[3]*a[1]*a[2]*b[2]);
					a2=sqrt((ld)b[1]/a[2]/b[2]*a[1]*a[3]*b[3]);
					a3=sqrt((ld)b[3]/a[1]/b[1]*a[3]*a[2]*b[2]);	//解方程
					if(!check(a1) || !check(a2) || !check(a3)) continue;
					if(k==3){
						ans[1]=ll(a1+0.5);
						ans[2]=ll(a2+0.5);
						ans[3]=ll(a3+0.5);
					}
					else{
						ld a4=(ld)a[4]/a1*b[4],a5=(ld)a[5]/a2*b[5],a6=(ld)a[6]/a3*b[6];
						if(check(a4) && equal(a4,a5,a6)){	//如果有合法的第四个未知数
							ans[1]=ll(a1+0.5);
							ans[2]=ll(a2+0.5);
							ans[3]=ll(a3+0.5);
							ans[4]=ll(a4+0.5);
						}
					}
					int cnt=0;
					if(!ans[1]) continue;
					if(k==4) swap(a[3],a[4]),swap(b[3],b[4]);	//由于种种原因必须要这么干（理解了前面的代码应该就懂了）
					FOR(i,1,k){	//为了保险，加个判断
						FOR(j,i+1,k){
							cnt++;
							if(gcd(ans[i],ans[j])!=a[cnt] || lcm(ans[i],ans[j])!=b[cnt]){
								FOR(hhh,1,k) ans[hhh]=0;
							}
							if(!ans[1]) break;
						}
						if(!ans[1]) break;
					}
					if(k==4) swap(a[3],a[4]),swap(b[3],b[4]);
					if(ans[1]) break;
				}while(next_permutation(b+1,b+n+1));
				if(ans[1]) break;
			}while(next_permutation(a+1,a+n+1));
			FOR(i,1,k) printf("%lld ",ans[i]);
			puts("");
		}
	}
}
```

---

## 作者：miaow (赞：1)

这题题意特别简单，乱序给k个数两两的gcd和lcm，求这k个数。

这题的数据范围也特别简单，$2≤k≤4$，$T≤5$，~~一看就是道暴力搜索都能过的水题对不对~~

#### 前言

上面的题解都是用_int128把gcd和lcm乘起来再搞，于是我决定写一个不用_int128的基于拆质因数的题解~~虽然本质上是用了高精度~~

### 题解

首先我们知道$gcd(a/gcd(a,b),b/gcd(a,b))=1$，$lcm(a,b)=a*b/gcd(a,b)$。

那么就有个推论，设$lcm(a,b)/gcd(a,b)$的质因数分解式为$P^{x_{1}}_{1}P^{x_{2}}_{2}...P^{x_{n}}_{n}$，那么对于每一个$1≤k≤n$，要么有$P^{x_{k}}_{k}|a$且$gcd(P^{x_{k}}_{k},b)=1$，要么就反过来。简单来说就是每一个$P^{x_{k}}_{k}$都可以划到a或者b的因数里面去。然后只要知道了这个质因数分解式，就可以枚举a和b了。在$1e18$的范围内一个数最多只有15个质因数，所以$2^n$枚举完全可以接受。

然后就可以枚举每个gcd对应哪个lcm，然后随便取一组对应来枚举两个数$a1$和$a2$，然后分类讨论。

$k=2$ 直接把$a1$和$a2$输出就完事了

$k=3$ 看$a1$能不能整除另外两组对应，由此拆出$a3$，然后验证$a2$和$a3$合起来是不是剩下那组对应

$k=4$ 和$k=3$差不多，就是枚举两组对应用$a1$去拆出$a3$和$a4$，然后验证$a2$、$a3$、$a4$合起来是不是剩下那三组

然后这个做法维护的是每个数的质因数分解式，乘就是逐个加，除就是逐个减，所以不会有爆longlong的地方

至于1e18怎么拆质因数……去抄个pollard-rho板子过来咯

### 代码

代码里用的map维护质因数分解式，考场脑抽用了unordered_map结果忘了这个不是按关键字排序的结果wa+tle得到了65的好分数……

~~本题最长ac代码警告~~

```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<unordered_map>
#include<map>
using namespace std;
typedef long long ll;
const ll INF=1e18+5;
#define um map<ll,int>
#define ui map<ll,int>::iterator
#define ft first
#define sd second
#define mytz __builtin_ctzll

inline ll gcd(ll a,ll b)
{
    if(!a)return b;
    if(!b)return a;
    if(!(a^b))return a;
    int t=mytz(a|b);
    a>>=mytz(a);
    do
    {
        b>>=mytz(b);
        if(a>b)
        {
            ll t=a;
            a=b;
            b=t;
        }
        b-=a;
    }while(b);
    return a<<t;
}
inline ll qc(ll a,ll b,ll p)
{
    a%=p;
    b%=p;
    ll qwe=((long double)a/p*b+1e-8);
    ll asd=(a*b-qwe*p);
    return asd<0?asd+p:asd;
}
inline ll fpow(ll qwe,ll asd,ll zxc)
{
    ll a=1;
    for(;asd;asd>>=1,qwe=qc(qwe,qwe,zxc))
    {
        if(asd&1)a=qc(a,qwe,zxc);
    }
    return a;
}
struct miaow
{
    ll a;
    int b;
    miaow(ll a=0,int b=0):a(a),b(b){}
};
struct pho
{
    inline int mlyz(ll a,ll x)
    {
        int t=0;
        ll x2=x-1,a2;
        while(!(x2&1))x2>>=1,t+=1;
        a=fpow(a,x2,x);
        while(t)
        {
            --t;
            a2=qc(a,a,x);
            if(a2==1&&a!=1&&a!=x-1)return 1;
            a=a2;
        }
        if(a!=1)return 1;
        else return 0;
    }
    inline int mllb(ll x)
    {
        if(x==2||x==3||x==5)return 1;
        if((!(x&1))||(!(x%3))||(!(x%5)))return 0;
        ll a[6]={2,3,5,29,31,37};
        for(int i=0;i<6&&a[i]<x;++i)
        {
            if(mlyz(a[i],x))return 0;
        }
        return 1;
    }
    inline ll prho(ll n,ll m)
    {
        if(!(n&1))return 2;
        if(!(n%3))return 3;
        if(!(n%5))return 5;
        int i=1;
        ll x=rand()%(n-1)+1,y=x,d;
        int k=2;
        while(1)
        {
            ++i;
            x=(qc(x,x,n)-m+n)%n;
            if(!(y^x))return n;
            d=gcd((y-x+n)%n,n);
            if(d!=1&&d!=n)return d;
            if(!(i^k))
            {
                y=x;
                k<<=1;
            }
        }
    }
    inline void fj2(ll x,ll m,um& qwe)
    {
        if(mllb(x))
        {
        	if(x==1)return;
            if(qwe.count(x))qwe[x]+=1;
            else qwe[x]=1;
            return;
        }
        ll y=x,z=m;
        while(!(y^x))
        {
            y=prho(x,--m);
        }
        y>(x/y)?(fj2(y,z,qwe),fj2(x/y,z,qwe)):(fj2(x/y,z,qwe),fj2(y,z,qwe));
    }
    inline void fj(ll x,um& qwe)
    {
        fj2(x,127,qwe);
    }
}pollard;

const int N=31;
ll gc[N],lc[N],lc2[N],su[N];
int mj[N];
int t,k,k2;
um yz[N],gc2[N];
int bj[N]={0};
um sz[N];
vector<miaow> gg;
bool yycf(int a,int b)
{
    for(ui i=gc2[b].begin();i!=gc2[b].end();++i)
    {
        if(!sz[a].count(i->first)||sz[a][i->first]<i->second)return false;
    }
    return true;
}
void cf(int a,int b)
{
    for(ui i=gc2[b].begin();i!=gc2[b].end();++i)
    {
        if(sz[a][i->first]==i->second)sz[a].erase(i->first);
        else sz[a][i->first]-=i->second;
    }
}
void cc(int a,int b)
{
    for(ui j=gc2[b].begin();j!=gc2[b].end();++j)
    {
        if(!sz[a].count(j->first))sz[a][j->first]=j->second;
        else sz[a][j->first]+=j->second;
    }
}
bool yy(int a,int c)
{
    if(yycf(a,c))
    {
        cf(a,c);
        int err=0;
        for(ui i=sz[a].begin();i!=sz[a].end();++i)
        {
            if(!yz[c].count(i->first)||yz[c][i->ft]!=i->second)
            {
                err=1;
                break;
            }
        }
        cc(a,c);
        if(err)return false;
    }
    else
    {
        return false;
    }
    return true;
}
bool yy2(int a,int b,int c)
{
    if(yycf(a,c)&&yycf(b,c))
    {
        cf(a,c);cf(b,c);
        int err=0;
        if(yz[c].size()!=sz[a].size()+sz[b].size())
        {
            err=1;
            goto sssss;
        }
        for(ui i=sz[a].begin();i!=sz[a].end();++i)
        {
            if(!yz[c].count(i->first)||yz[c][i->ft]!=i->second)
            {
                err=1;
                goto sssss;
            }
        }
        for(ui i=sz[b].begin();i!=sz[b].end();++i)
        {
            if(!yz[c].count(i->first)||yz[c][i->ft]!=i->second)
            {
                err=1;
                break;
            }
        }
        sssss:cc(a,c);cc(b,c);
        if(err)return false;
    }
    else
    {
        return false;
    }
    return true;
}
void fg(int a,int b,int c)
{
    sz[b].clear();
    cf(a,c);
    ui wz=sz[a].begin();
    for(ui i=yz[c].begin();i!=yz[c].end();++i)
    {
        while(wz!=sz[a].end()&&wz->first<i->first)++wz;
        if(wz==sz[a].end())
        {
            for(;i!=yz[c].end();++i)sz[b][i->first]=i->second;
            break;
        }
        if(wz->first!=i->first)sz[b][i->first]=i->second;
    }
    cc(a,c);
    cc(b,c);
}
void sc(int x)
{
    ll a=1;
    for(ui i=sz[x].begin();i!=sz[x].end();++i)a*=fpow(i->first,i->second,INF);
    cout<<a<<" ";
}
void solve()
{
    for(int i=1;i<=k2;++i)
    {
        cin>>gc[i];
        gc2[i].clear();
        pollard.fj(gc[i],gc2[i]);
    }
    for(int i=1;i<=k2;++i)cin>>lc2[i];
    for(int i=1;i<=k2;++i)mj[i]=i;
    do
    {
        int err=0;
        for(int i=1;i<=k2;++i)
        {
            lc[i]=lc2[mj[i]];
            if(lc[i]%gc[i]!=0)
            {
                err=1;
                break;
            }
            su[i]=lc[i]/gc[i];
            bj[i]=0;
        }
        if(err)goto sss;
        for(int i=1;i<=k2;++i)
        {
            yz[i].clear();
            pollard.fj(su[i],yz[i]);
        }
        gg.clear();
        for(ui i=yz[1].begin();i!=yz[1].end();++i)
        {
            gg.push_back(miaow(i->first,i->second));
        }
        for(int i=0;i<((1<<gg.size()));++i)
        {
            for(int j=1;j<=k;++j)sz[j].clear();
            for(int j=0;j<gg.size();++j)
            {
                if(i&(1<<j))sz[1][gg[j].a]=gg[j].b;
                else sz[2][gg[j].a]=gg[j].b;
            }
            cc(1,1);cc(2,1);
            if(k==2)
            {
                sc(1);sc(2);cout<<endl;
                goto ssss;
            }
            if(k==3)
            {
                int ye=0;
                if(yy(1,2))
                {
                    fg(1,3,2);
                    if(yy2(2,3,3))
                    {
                        sc(1);sc(2);sc(3);cout<<endl;
                        goto ssss;
                    }
                    else ye=1;
                }
                else ye=1;
                if(ye)
                {
                    if(yy(1,3))
                    {
                        fg(1,3,3);
                        if(yy2(2,3,2))
                        {
                            sc(1);sc(2);sc(3);cout<<endl;
                            goto ssss;
                        }
                    }
                }
            }
            if(k==4)
            {
                int ye=0;
                for(int j=2;j<=k2;++j)
                {
                    if(yy(1,j))
                    {
                        fg(1,3,j);
                        bj[j]=13;
                        for(int l=j+1;l<=k2;++l)
                        {
                            if(yy(1,l))
                            {
                                fg(1,4,l);
                                bj[l]=14;
                                vector<int> asd;
                                for(int p=2;p<=k2;++p)if(!bj[p])asd.push_back(p);
                                if(yy2(2,3,asd[0]))
                                {
                                    if(yy2(2,4,asd[1])&&yy2(3,4,asd[2]))
                                    {
                                        sc(1);sc(2);sc(3);sc(4);cout<<endl;
                                        ye=1;goto ss;
                                    }
                                    if(yy2(3,4,asd[1])&&yy2(2,4,asd[2]))
                                    {
                                        sc(1);sc(2);sc(3);sc(4);cout<<endl;
                                        ye=1;goto ss;
                                    }
                                }
                                if(yy2(2,4,asd[0]))
                                {
                                    if(yy2(2,3,asd[1])&&yy2(3,4,asd[2]))
                                    {
                                        sc(1);sc(2);sc(3);sc(4);cout<<endl;
                                        ye=1;goto ss;
                                    }
                                    if(yy2(3,4,asd[1])&&yy2(2,3,asd[2]))
                                    {
                                        sc(1);sc(2);sc(3);sc(4);cout<<endl;
                                        ye=1;goto ss;
                                    }
                                }
                                if(yy2(3,4,asd[0]))
                                {
                                    if(yy2(2,3,asd[1])&&yy2(2,4,asd[2]))
                                    {
                                        sc(1);sc(2);sc(3);sc(4);cout<<endl;
                                        ye=1;goto ss;
                                    }
                                    if(yy2(2,4,asd[1])&&yy2(2,3,asd[2]))
                                    {
                                        sc(1);sc(2);sc(3);sc(4);cout<<endl;
                                        ye=1;goto ss;
                                    }
                                }
                                ss:int zxczxczxc;
                                if(ye)goto ssss;
                                bj[l]=0;
                            }
                        }
                        bj[j]=0;
                    }
                }
            }
        }
        sss:int qweqweqwe;
    }while(next_permutation(mj+1,mj+k2+1));
    ssss:int asdasdasd;
}
int main()
{
    cin>>t>>k;
    k2=(k*(k-1)/2);
    while(t)
    {
    	--t;
    	solve();
    }
}
```


---


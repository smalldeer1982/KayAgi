# 赛车游戏

## 题目描述

R 君和小伙伴打算一起玩赛车。但他们被老司机 mocania 骗去了秋名山。

秋名山上有 $n$ 个点和 $m$ 条边，R 君和他的小伙伴要从点 $1$ 出发开往点 $n$，每条边都有一个初始的方向。老司机 mocania 拿到了秋名山的地图但却不知道每条路有多长。显然，为了赛车游戏的公平，每条 $1$ 到 $n$ 的路径应当是等长的。mocania 想，我就随便给边标上一个 $1...9$ 的长度，反正傻傻的 R 君也看不出来。

可 mocania 的数学不大好，不知道怎么给边标长度，只能跑来请教你这个 OI 高手了。



## 说明/提示

#### 数据范围

**本题启用 Special Judge 和 Subtask。**

Subtask #1（$30$ 分）：$n \leq 10$，$m \leq 20$；  
Subtask #2（$30$ 分）：$n \leq 100$，$m \leq 200$；  
Subtask #3（$40$ 分）：$n \leq 1000$，$m \leq 2000$。

保证数据中不会出现重边，自环。

## 样例 #1

### 输入

```
10 10
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10
1 10```

### 输出

```
10 10
1 2 1
2 3 1
3 4 1
4 5 1
5 6 1
6 7 1
7 8 1
8 9 1
9 10 1
1 10 9```

# 题解

## 作者：Rbu_nas (赞：25)

题意简述：

给定一些有向边，对她们赋上边权 $w\in[1,9]$，使得每条 $1\to n$ 的简单路径长相等。

---

不得不说这题相当有趣，，

比赛的时候写的是钦定每条在 $1\to n$ 路径上边权为 $1$，统计路径总数以及每条路径的长度和，然后求出公共 gcd 和 lcm，通分后再进行一遍约分。但是很遗憾的是，在钦定边权为 $1$ 时就可能出现 out of range of [1,9] 的情况。每条边的边权无法确认，于是我们只能从题目本身入手

然后就可以发现，，，由于给定的边权 $w\in[1,9]$，又有 $dis_u + w(u,v) = dis_v$，说明 $dis_v - dis_u\in[1,9]$。仔细想想这不就可以建差分约束系统求解了吗？

![](https://ftp.bmp.ovh/imgs/2019/10/d868f9f03e00d068.png)

---

简单介绍一下[差分约束](https://oi-wiki.org/graph/diff-constraints/)，单源最短路中我们有：

$$dis_{to}\le dis_u + w(u,to)$$

故有：

$$dis_{to} - dis_u\le w(u, to)$$

也就是说，如果给定 $x + y \ge z$，就可以转化成 $z - y\le x$，然后 `add(y, z, x)` $y\to z$ 建边。

在这道题中我们有 $a\to b$ 的边，同时有：

$$1\le dis_b - dis_a \color{orange}\Rightarrow \color{c}dis_a - dis_b \le -1$$

$$dis_b - dis_a\le 9$$

所以建边：`add(b, a, -1), add(a, b, 9)`

最后 SPFA 判断差分约束系统是否有解（是否有负环），没了。

没了？没了。

当然还有一些注意事项：

+ 题目给的是有向边，要判断是否能从 $1\to n$

+ 不在 $1\to n$ 路径上的边的边权可以随便标，不会对答案产生影响，所以我们先标记出 $1\to n$ 路上的点，然后再建边。对那些“无用”边建边会让我们得到错误的约束。

---

$\texttt{Code:}$

```cpp
const int MAXN = 1e3 + 3;
const int MAXM = 2e3 + 3;
const int LEN = 1 << 11;

inline int read() {
	int x = 0; bool f = 1; register char c = getchar();
	for(; !std::isdigit(c); c = getchar()) f ^= c == '-';
	for(; std::isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
	return f ? x : -x;
}

int n, m, u[MAXM], v[MAXM], dis[MAXN], times[MAXN]; 
bool inq[MAXN], vis1[MAXN], visn[MAXN];

int fa[MAXN];

inline int find(int x) {
	return fa[x] == x ? x : fa[x] = find(fa[x]);
}
inline void merge(int x, int y) {
	int a = find(x), b = find(y);
	if(a == b) return ;
	fa[a] = b;
}

struct Edges {
	int to, dis, nxt;
	Edges() {}
	Edges(int to, int dis, int nxt): to(to), dis(dis), nxt(nxt) {}
} edge[MAXM << 1];

int head[MAXN];

inline void addEdge(int u, int v, int d) {
	static int cnt = 0;
	edge[++cnt] = Edges(v, d, head[u]);
	head[u] = cnt;
}

std::vector<int> G[MAXN], nG[MAXN];
inline void addEdge(int u, int v, std::vector<int> ver[]) {
	ver[u].push_back(v);
}

void dfs(int x) {
	int size = G[x].size();
	for(int i = 0; i < size; ++i) {
		int to = G[x][i];
		if(vis1[to]) continue;
		
		vis1[to] = 1; dfs(to);
	}
}
void nDfs(int x) {
	int size = nG[x].size();
	for(int i = 0; i < size; ++i) {
		int to = nG[x][i];
		if(visn[to]) continue;
		
		visn[to] = 1; nDfs(to);
	}
}

struct Queue {
	int l, r, q[LEN + 10];
	Queue(): l(1), r(0) {}
	
	inline void push(int x) { q[++r & (LEN - 1)] = x; }
	inline void pop() { ++l; }
	inline int front() { return q[l & (LEN - 1)]; }
	inline bool empty() { return l > r; }
};

inline bool SPFA(int s) {
	std::memset(dis, 0x3f, sizeof dis);
	dis[s] = 0; inq[s] = 1; times[s] = 1;
	Queue q; q.push(s);
	
	while(!q.empty()) {
		int u = q.front(); q.pop();
		inq[u] = 0;
		for(int i = head[u]; i; i = edge[i].nxt) {
			int v = edge[i].to;
			if(dis[u] + edge[i].dis < dis[v]) {
				dis[v] = dis[u] + edge[i].dis;
				if(++times[v] > n) return 0;
				if(!inq[v]) q.push(v), inq[v] = 1;
			}
		}
	}
	return 1;
}

signed main() {
	n = read(), m = read();
	
	for(int i = 1; i <= n; ++i) fa[i] = i;
	
	for(int i = 1; i <= m; ++i) {
		u[i] = read(), v[i] = read();
		addEdge(u[i], v[i], G), addEdge(v[i], u[i], nG);
		merge(u[i], v[i]);
	}
	
	if(find(1) != find(n)) {
		puts("-1");
		return 0;
	}
	
	dfs(1); nDfs(n);
	
	static bool flag[MAXN] = {0};
	for(int i = 1; i <= n; ++i) if(vis1[i] && visn[i]) flag[i] = 1;
	if(!vis1[n]) {
		puts("-1");
		return 0;	
	}
	flag[1] = flag[n] = 1;
	
	for(int i = 1; i <= m; ++i)
		if(flag[u[i]] && flag[v[i]]) addEdge(u[i], v[i], 9), addEdge(v[i], u[i], -1);
	
	if(!SPFA(1)) {
		puts("-1");
		return 0;
	}
	
	printf("%d %d\n", n, m);
	for(int i = 1; i <= m; ++i) {
		printf("%d %d ", u[i], v[i]);
		if(flag[u[i]] && flag[v[i]]) printf("%d\n", dis[v[i]] - dis[u[i]]);
		else puts("1");
	}
	return 0;
}

```

为了能让大家有自己的思考与理解，题解代码中没有注释。详细注释版本的放在[剪贴板](http://ideone.com/mIcphC)中。

另：博主是个菜鸡，如果哪里有误麻烦指出orz

---

## 作者：TEoS (赞：13)

#### 题意分析

给你一张有向图，让你给图上的边赋边权，边权的范围为$[1,9]$，使得$1$到$n$的所有路径等长


------------
#### 思路解析

~~既然题目说了路径等长，那不开一个数组存储路径长度不是很亏吗？~~
所以我们定义一个数组$d$存储节点$1$到每个节点的路径长度。根据题意，边权的范围为$[1,9]$，因此对于图中的所有有向边$(u,v)$，在有解的情况下，有以下式子：
$$1\leq d[v]-d[u]\leq 9$$
~~草，~~
一眼看上去就长得一副差分约束的亚子。~~等等，SPFA……~~
看一眼数据范围，嗯，没毛病，就它了！无耻地安利一波博客：[差分约束系统详解](https://www.cnblogs.com/TEoS/p/11490547.html)

现在考虑什么时候无解。显然，当路径存在环时，肯定是无解的，因为边权范围是$[1,9]$，经过环的路径长度一定是比不经过环的长的，而题目要求路径长度相同，因此此时无解。~~然而不判也可以过。~~
差分约束无解就不多说了，判负环就完事了。



------------
#### 具体实现

怎么建差分约束系统呢？~~暴力~~
一遍dfs，判断该边是否在$1$到$n$的路径上，如果在，就按照上面的关系式建边，即从$u$向$v$连一条边权为$9$的边，从$v$向$u$连一条边权为$-1$的边。

但是，看了一眼数据范围（刚刚不是看过了吗），发现虽然SPFA活了，暴力还是苟延残喘，实测60pts，100%的数据只过了无解的2个点。因此要进行一个剪枝。

显然，在有解的图上是不存在环的。因此，可以存储一个节点能否到达$n$节点，如果能，就不用继续走，直接返回。

最后还有一个问题，差分约束条件是针对路径上的边，因为之前我们没有对不在路径上的边进行约束，因此这些边的边权可能不在$[1,9]$的范围内。然而这些边毫无用处，边权只要在范围内就可以了，因此我们随便给它们赋一个值就行。~~欢迎rand~~

这样这题就解完了！

最后奉上代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<cmath>
using namespace std;
const int N=1e4,M=1e5;
int n,m,tot,tot1;
int head[N],ver[M],Next[M];
int h1[N],v1[2*M],n1[2*M],e1[2*M];
int x[N],y[N],d[N],cnt[N];
bool v[N],p[N];
queue<int> q;
void add(int x,int y)
{
	ver[++tot]=y,Next[tot]=head[x],head[x]=tot;
}//原图
void Add(int x,int y,int z)
{
	v1[++tot1]=y,e1[tot1]=z,n1[tot1]=h1[x],h1[x]=tot1;
}//差分约束系统图
bool spfa()
{
	memset(v,0,sizeof(v));
	memset(d,0x3f,sizeof(d));
	queue<int> q;
	q.push(0);
	d[0]=0,v[0]=1;
	while(q.size())
	{
		int x=q.front();q.pop();v[x]=0;
		for(int i=h1[x];i;i=n1[i])
			if(d[x]+e1[i]<d[v1[i]])
			{
				int y=v1[i];
				d[y]=d[x]+e1[i];
				cnt[y]=cnt[x]+1;
				if(cnt[y]>n)
					return 1;//存在负环，无解
				if(!v[y])
				{
					q.push(y);
					v[y]=1;
				}
			}
	}
	return 0;
}//差分约束
bool dfs(int x)
{
	if(x==n || p[x])
		return 1;//到达n节点以及剪枝
	for(int i=head[x];i;i=Next[i])
		if(!v[i])
		{
			v[i]=1;
			if(dfs(ver[i]))//如果能够到达n节点，即在路径上
			{
				Add(x,ver[i],9),Add(ver[i],x,-1);//建边
				p[x]=1;
			}
		}
	return p[x];
}//建立差分约束系统
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&x[i],&y[i]);
		add(x[i],y[i]);
	}
	for(int i=1;i<=n;i++)
		Add(0,i,0);
	if(!dfs(1) || spfa())
	{
		puts("-1");
		return 0;
	}//不存在路径和无解直接输出
	printf("%d %d\n",n,m);
	for(int i=1;i<=m;i++)
	{
		printf("%d %d ",x[i],y[i]);
		int now=abs(d[x[i]]-d[y[i]]);
		if(now>0 && now<10)
			printf("%d\n",now);//在范围内直接输出
		else
			puts("1");//不在范围内一定不在路径上，随便赋值1~9
	}
	return 0;
}
```

---

## 作者：mzgwty (赞：6)

话说月赛怎么出原题了......~~继3月月赛后再出原题~~

这题和$CF241E$很像，只是那题要求每条边的权值要么是1要么是2罢了。

但作者考场上总会出一些意外的状况，比如被叫去吃饭之类的，所以考场写了个大暴力，一分都没有。

经过某个神仙 @Social_Zhao 指点后，发现了这是差分约束......

对于每一条边，权值≤9，≥1，所以就有

$1<=dis_{to}-dis_{from}<=9$

即$dis_{to}-dis_{from}<=9$且$dis_{from}-dis_{to}<=-1$

然后这就是一个明显的差分约束了。

从$from$到$to$连一条权值为$-1$的边，再从$to$到$from$连一条权值为$9$的边。从$1$跑$spfa$,有负环输出$-1$,否则对于每一条边，权值等于$dis_{to}-dis_{from}$

---

但是，有一些坑点

### 坑点一

比如这个图（脑补一下，点不开作图工具）

$1->2$

$2->3$

$3->4$

$4->5$

$5->6$

$6->7$

$7->8$

$8->9$

$9->10$

$10->11$

$1->11$

$1->12$

显然，你直接跑差分约束是会挂掉的，因为图里从$1$出发有负环。但是从$1$到$n$(即$12$)仅有一条路径，所以肯定是有解的。

那么我们应该怎么办呢？

显然，只需要把不在$1$到$n$的路径上的点和边全部不管，再跑差分约束即可。对于不在指定路径上的边，直接把它们的权值赋为$1-9$的任意整数即可。

对于处理无用点，一般使用两遍$dfs/bfs$,一遍用原边从$1$遍历；另一遍用反向边，从$n$遍历，两次都遍历到的点就在$1->n$的路径上。

### 坑点二

必须要判断$1->n$是否联通，~~不然你会得到30分的高分~~

---

讲完了$QWQ$

$Code:$ 

```cpp
#include<bits/stdc++.h>
#include<queue>
#define R register
#define rep(i,a,b) for(R int i=a ; i<=b ; ++i)
#define dwn(i,a,b) for(R int i=a ; i>=b ; --i)
using namespace std;

inline int read() {
	int res=0,f=1;char ch;
	while(!isdigit(ch=getchar())) if(ch=='-') f=-1;
	do {
		res=res*10+ch-'0';
	} while(isdigit(ch=getchar()));
	return res*f;
}

const int N=2005;

struct Edge {
	int next,from,to,val;
}a[N<<1],b[N<<1],c[N<<1];

int head[N],tail[N],size;

bool ok1[N],ok2[N],ok[N];

inline void add(int u,int v) {
	a[++size].next=head[u],a[size].from=u,a[size].to=v,head[u]=size;
	b[size].next=tail[v],b[size].to=u,tail[v]=size;
}

void dfs1(int u) {
	ok1[u]=1;
	for(R int i=head[u] ; i ; i=a[i].next) {
		int v=a[i].to;
		if(!ok1[v]) dfs1(v);
	}
}

void dfs2(int u) {
	ok2[u]=1;
	for(R int i=tail[u] ; i ; i=b[i].next) {
		int v=b[i].to;
		if(!ok2[v]) dfs2(v);
	}
}

inline void add2(int u,int v,int w) {
	c[++size].next=head[u],c[size].to=v,c[size].val=w,head[u]=size;
}

int dis[N],num[N];

bool inq[N];

int main() {
	int n=read(),m=read();
	rep(i,1,m) {
		int x=read(),y=read();
		add(x,y);
	}
	dfs1(1),dfs2(n);
	rep(i,1,n) ok[i]=ok1[i]&ok2[i];
	size=0,memset(head,0,sizeof(head));
	rep(i,1,m) if(ok[a[i].from]&&ok[a[i].to]) add2(a[i].from,a[i].to,9),add2(a[i].to,a[i].from,-1);
	memset(dis,0x3f,sizeof(dis));
	dis[1]=0;
	queue <int> q;
	q.push(1),num[1]=inq[1]=1;
	while(!q.empty()) {
		int u=q.front();q.pop(),inq[u]=0;
		for(R int i=head[u] ; i ; i=c[i].next) {
			int v=c[i].to;
			if(dis[v]>dis[u]+c[i].val) {
				dis[v]=dis[u]+c[i].val;
				if(!inq[v]) {
					if(num[v]==n) {
						printf("-1");
						return 0;
					}
					q.push(v),inq[v]=1,++num[v];
				}
			}
		}
	}
	if(dis[n]==0x3f3f3f3f) {
		printf("-1");
		return 0;
	}
	printf("%d %d\n",n,m);
	rep(i,1,m) {
		printf("%d %d ",a[i].from,a[i].to);
		if(!ok[a[i].from]||!ok[a[i].to]) printf("1");
		else printf("%d",dis[a[i].to]-dis[a[i].from]);
		puts("");
	}
	return 0;
}
```

---

## 作者：Protons (赞：5)

## 差分约束系统

**定义**：如果一个系统由n个变量和m个约束条件组成，形成m个形如ai-aj≤k的不等式(i,j∈[1,n],k为常数),则称其为差分约束系统(system of difference constraints)。也就是说，差分约束系统是求解关于一组变量的特殊不等式组的方法

如果还不会差分约束系统的同学请先看[差分约束系统的学习笔记](https://blog.csdn.net/dragon60066/article/details/80245797)

我们来看这个题。**题目里说：“随便给边表上一个1...9的长度”**，所以对于每一对给定的边$(u,v)$，**都必须满足$1\le dis[v]-dis[u] \le9$的约束**，这样就可以构建差分约束系统了。

**由于题目求的是变量差的最小值，所以我们把所有不等式都转化成$u-v \ge c$的形式，再构图求最长路**。具体的构建方式就是：对于每一对边$(u,v)$，肯定有$1\le dis[v]-dis[u] \le9$，故从u到v建一条长度为1的有向边，从v到u建一条长度为-9的有向边。

当然，上面只是理论建边方式。由于要求最长路，如果仅仅把spfa松弛时的大于号改了，那岂不是任出题人随便卡？因此，我们在建边时把权值都取相反数，在spfa完后再对dis数组里的每个值去相反数。

如果在差分约束系统上存在负环，那么一定不可解，及时return并输出-1。

本来这样就可以做完了，但是，遗憾的是，这个题可能有一些不必要的点，比如这个图里的2和4点：

![](https://cdn.luogu.com.cn/upload/image_hosting/dzx3udoy.png)

由于2点和4点都不会被从1到n的路径经过，所以如果我们还要把他们的约束条件加到约束方程组里，**我们的答案就会被不必要的约束所约束，是会得到一个错误的答案的**。所以我建了正图和反图，在正图上从1到n跑DFS，在反图上从n到1跑DFS，找出两次都遍历到的点并建新图存下来，然后在新图上构建差分约束系统。

### 注意判断从1到n是否连通！

以下是代码：
```cpp
#include<cmath>
#include<queue>
#include<cstdio>
#include<iostream>
const int maxn=4010;
using namespace std;
inline int read()
{
    int fu=1,x=0;char o=getchar();
    while(o<'0'||o>'9'){if(o=='-')fu=-1;o=getchar();}
    while(o>='0'&&o<='9'){x=(x<<1)+(x<<3)+(o^48);o=getchar();}
    return x*fu;
}
struct Edge
{
	int from,to,dis,nst;
}e1[maxn],e2[maxn],edge[maxn];
int n,m,a,b;
int cnt1,cnt2,cnt;
int dis[maxn],num[maxn],from[maxn],to[maxn],sign[maxn];
bool vis1[maxn],vis2[maxn],vis[maxn];
int head1[maxn],head2[maxn],head[maxn];
inline void add(int a,int b,int c)
{
	edge[++cnt].nst=head[a];
	edge[cnt].to=b;
	edge[cnt].from=a;
	edge[cnt].dis=c;
	head[a]=cnt;
}
inline void add1(int a,int b)
{
	e1[++cnt1].nst=head1[a];
	e1[cnt1].to=b;
	e1[cnt1].from=a;
	head1[a]=cnt1;
}
inline void add2(int a,int b)
{
	e2[++cnt2].nst=head2[a];
	e2[cnt2].to=b;
	e2[cnt2].from=a;
	head2[a]=cnt2;
}
void dfs_forward(int x)
{
	for(int i=head1[x];i;i=e1[i].nst)
	{
		int v=e1[i].to;
		if(vis1[v])continue;
		vis1[v]=1;
		dfs_forward(v);
	}
}
void dfs_reverse(int x)
{
	for(int i=head2[x];i;i=e2[i].nst)
	{
		int v=e2[i].to;
		if(vis2[v])continue;
		vis2[v]=1;
		dfs_reverse(v);
	}
}
bool spfa()
{
	queue <int> q;
	for(int i=1;i<=n;i++)
	dis[i]=1e8,vis[i]=0;
	vis[1]=1;dis[1]=0;
	q.push(1);
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		vis[u]=0;num[u]++;
		for(int i=head[u];i;i=edge[i].nst)
		{
			int v=edge[i].to;
			if(dis[v]>dis[u]+edge[i].dis)
			{
				dis[v]=edge[i].dis+dis[u];
				if(num[v]>n)return 0;
				if(!vis[v]){vis[v]=1;q.push(v);}
			}
		}
	}
	return 1;
}
void debug()
{
	for(int i=1;i<=n;i++)
	{
		if(vis1[i])cout<<i<<" ";
	}
	cout<<"\n";
	for(int i=1;i<=n;i++)
	{
		if(vis2[i])cout<<i<<" ";
	}
	cout<<"\n";
}
int main()
{
	n=read();m=read();
	for(int i=1;i<=m;i++)
	{
		a=read();b=read();
		add1(a,b);add2(b,a);
	}
	dfs_forward(1);dfs_reverse(n);
	for(int i=1;i<=n;i++)
	if(vis1[i]&&vis2[i])sign[i]=1;
	if(!vis1[n]){printf("-1\n");return 0;}
	sign[1]=1;sign[n]=1;
//	debug();
	for(int i=1;i<=m;i++)
	{
		int u=e1[i].from,v=e1[i].to;
		if(sign[u]&&sign[v])
		{
			add(u,v,-1);add(v,u,9);
		}
	}
	if(!spfa()){printf("-1\n");return 0;}
	for(int i=1;i<=n;i++)dis[i]*=-1;
	printf("%d %d\n",n,m);
	for(int i=1;i<=m;i++)
	{
		int u=e1[i].from,v=e1[i].to;
		printf("%d %d ",u,v);
		if(sign[u]&&sign[v])printf("%d\n",dis[v]-dis[u]);
		else printf("1\n");
	}
	return 0;
}
```

---

## 作者：lsoer (赞：4)

本题解已更新，并等待dalao二次hack

### 关于SPFA，它SPFA了

题面：

------------

R 君和小伙伴打算一起玩赛车。但他们被老司机 mocania 骗去了秋名山。

秋名山上有 n 个点和 m 条边，R 君和他的小伙伴要从点 1 出发开往点 n，每条边都有一个初始的方向。老司机 mocania 拿到了秋名山的地图但却不知道每条路有多长。显然，为了赛车游戏的公平，**每条 1 到 n 的路径应当是等长的**。mocania 想，我就随便给边表上一个 1...9 的长度，反正傻傻的 R 君也看不出来。

可 mocania 的数学不大好，不知道怎么给边标长度，只能跑来请教你这个 OI 高手了。

------------

可以看到，只有从1到n的路径需要等长。因此不在从1到n路径上的边可以忽略。

**（1）利用一个DFS筛去不在路径上的边。**

现在只剩下在路径上的边了······

现在考虑距离的限制。

首先，从点A到点B的所有路的距离和都应该是相等的。（为了保证最后的每条路径都等长）

其次，从点A到B的路应该尽量短。如下：
![](https://cdn.luogu.com.cn/upload/image_hosting/cymdw9hj.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/q3xb6r13.png)

那么，对于从A到B来说，可能会有很多条不同的路，而其中经过点最多的的路决定了它最短有多短。

对于这条路径，我们将其上的每条边都设为长度为1（由于它经过点最多这不会有什么问题）。

怎么方便的找到它呢？

把图分层，点1在第一层，点n在最后一层。（层数低的点向层数高的点有边）

利用层数，可以很好的控制距离相等和距离最短。

**（2）把图分层，记录每个点在第几层。**

![](https://cdn.luogu.com.cn/upload/image_hosting/3oyp4cww.png)

**（3）如果有一条边从A到B，那么它的长度为B的层数减去A的层数。**

当然，图可能有环，可能无法到达n点（此时无解）。

当边的长度超出范围时也无解。

代码（期待其他dalao优化）：
```
#include<cstdio>//输入输出 
using namespace std;
struct edg
{
	int fr,to,nex,w,v;//代表 起点 终点 下一条边的位置 长度 状态（0为未遍历，1为在1到n路径上，2为不在） 
}e[2010];//前向星 
int n,m,h[1001],cnt=1,in[1001],dis[1001];//点数 边数 存储起点（前向星用） 当前最后位置（前向星用) 入度 层数  
bool vis[2010];//是否遍历过此点 
int q[1010];//队列 
void build(int x,int y)
{
	e[cnt].fr=x;
	e[cnt].to=y;
	e[cnt].nex=h[x];
	h[x]=cnt++;
}//加边 
bool dfs(int x)
{
	if (x==n)//到达n，返回可行 
	return true;
	bool r=false;//记录是否可行 
	for (register int y=h[x];y;y=e[y].nex)
	if (!vis[e[y].to])
	{
		if (e[y].v)//到过 
		{
			if (e[y].v==1)//成功过 
			r=true;
			continue;
		}
		vis[e[y].to]=true;
		if (dfs(e[y].to))
		{
			r=true;//成功了 
			e[y].v=1;
			in[e[y].to]++;//增加入度 
		}
		else
		e[y].v=2;//失败了 
		vis[e[y].to]=false;
	}
	return r;
}
int main()
{
	scanf("%d%d",&n,&m);
	int x,y;
	while (m--)
	{
		scanf("%d%d",&x,&y);
		build(x,y);
	}
	vis[1]=true;
	dfs(1);//先dfs 
	int st=1,en=1;
	q[st]=1;
	dis[1]=1;//点1第一层
	while (st<=en)//拓扑排序
	{
		x=q[st];
		for (y=h[x];y;y=e[y].nex)
		if (e[y].v==1)//只考虑在路径上的边 
		{
			in[e[y].to]--;
			if (in[e[y].to]==0)
			{
				q[++en]=e[y].to;
				dis[e[y].to]=dis[x]+1;//此点在下一层 
			}
		}
		st++;
	}
	if (!dis[n])//无法达到点n而无解 
	{
		printf("-1");
		return 0;
	}
	
	
	for (int i=en-1;i>0;--i)
	{
		x=q[i];
		for (y=h[x];y;y=e[y].nex)
		if (e[y].v==1&&dis[e[y].to]-dis[x]>9)
		dis[x]=dis[e[y].to]-9;
	}
	/*
	被HACK后的改动
	如果没有这段，那么由于拓扑排序会导致点聚集在较低的层数
	如
	13 13
	1 2
	2 3
	3 4
	4 5
	5 6
	6 7
	7 8
	8 9
	9 10
	10 11
	11 13
	1 12
	12 13
	这时12号点会排在第二层，而导致跟13号点的距离太长 
	*/ 
	
	
	for (register int i=1;i<cnt;++i)
	if (e[i].v==1)//只考虑在路径上的边 
	{
		e[i].w=dis[e[i].to]-dis[e[i].fr];
		if (e[i].w>9||e[i].w<1)//超范围而无解 
		{
			printf("-1");
			return 0;
		}
	}
	else
	e[i].w=1;//不在路径上的边设1即可 
	printf("%d %d\n",n,cnt-1);
	for (register int i=1;i<cnt;++i)
	printf("%d %d %d\n",e[i].fr,e[i].to,e[i].w);
	return 0;
}
```

---

## 作者：JoaoFelix (赞：3)

这道题刚开始看感觉怎么看都不像是差分约束，仔细观察我们大概分几步做。

首先我们判断一下1不能到达n的情况，显然输出-1

紧接着我们需要判断的是一条边是不是在1-n的路径上出现过，这个我们只需要通过正反向dfs以后判断这条边的两条端点是否能够经过。

然后我们就发现求出必要的边以后就可以差分约束，我们考虑对于dis这个条件差分约束，然后我们考虑的就是dis[v]-dis[u]的关系，必须是在1~9的，这我们就可以直接差分约束了。

然后差分约束完毕以后，如果有负环那么我们直接判定无解即可，反之我们直接输出dis[v]-dis[u]即可。

这个思路比较巧妙，我们可以通过差分约束解决一类看似不是差分约束的标号问题。

具体实现我们先两边dfs，然后判断一下1-n不能联通的情况，然后接着我们讲的做就可以了。

代码：
```cpp
#include<bits/stdc++.h>
#define LL long long
#define pb push_back
using namespace std;
const int N=1e3+5,M=2e3+5;
struct Graph{int u,v;}g[M];
struct Edge{int to,w,nxt;}e[M<<1];
int n,m,fst[N],tote,dis[N];bool vis[N],rvis[N];
vector<int>adj[N],radj[N];
void dfs(int u){vis[u]=true;for(auto v:adj[u])if(!vis[v])dfs(v);}
void rdfs(int u){rvis[u]=true;for(auto v:radj[u])if(!rvis[v])rdfs(v);}
void adde(int u,int v,int w){e[++tote]=(Edge){v,w,fst[u]};fst[u]=tote;}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,u,v;i<=m;i++)scanf("%d%d",&u,&v),adj[u].pb(v),radj[v].pb(u),g[i]=(Graph){u,v};
	dfs(1);rdfs(n);
	if(!vis[n]){puts("-1");return 0;}
	for(int i=1,u,v;i<=m;i++){
		u=g[i].u;v=g[i].v;
		if(vis[u]&&rvis[v])adde(u,v,9),adde(v,u,-1);
	}
	for(int t=1;t<=n;t++)for(int u=1;u<=n;u++)for(int i=fst[u],v;i;i=e[i].nxt)dis[e[i].to]=min(dis[e[i].to],dis[u]+e[i].w);
	for(int u=1;u<=n;u++)for(int i=fst[u],v;i;i=e[i].nxt)if(dis[e[i].to]>dis[u]+e[i].w){puts("-1");return 0;}
	printf("%d %d\n",n,m);
	for(int i=1,u,v;i<=m;i++){
		u=g[i].u;v=g[i].v;
		if(vis[u]&&rvis[v])printf("%d %d %d\n",u,v,dis[v]-dis[u]);else printf("%d %d 1\n",u,v);
	} 
	return 0;
}

```


---

## 作者：xiejinhao (赞：2)

# P5590 赛车游戏 题解 

> ## 本文同步发布于 [$My Blog$](https://www.cnblogs.com/Ning-H/p/11668193.html)

------------

写在前面
------------


众所周知这是一篇题解，当然这也是一篇经验的总结。

它源自于洛谷月赛，传送门：[P5590 赛车游戏](https://www.luogu.org/problem/P5590?contestId=22026)

笔者写下这篇题解，一是希望自己这次的错误不要再犯，二是希望能帮助大家。



题解部分
------------


- ### 题面简析

>题意大致可以概括为：给你 $n$ 个点 $m$ 条边的 一张图，你需要给每条边加上边权，使得$1-n$的所有路径的长度均相等。

现在感觉问题简单多了，我们可以想到暴力地添加边权（反正边权也只有 $1 \text{-} 9$）

- ### 解题思路

很明显上面的办法是不能拿满分的。并且我拿到本题并没有想过要打暴力。

我们假设这张图存在两个顶点 $u,v$，它们之间的边权为 $val(u,v)$。

那么就有：$dis[u]+val(u,v)=dis[v]$ （$dis$数组是节点$1$到其他点的路径长度最值）

至于这个最值是什么，稍后再解答。

我提出了上面那个式子，那么很明显我们要求的是 $val(u,v)$，这东西一定满足 $1≤val(u,v)≤9$

好了，现在变形一下式子：$1≤val(u,v)=dis[v]-dis[u]≤9$，看出来什么了吗？

你仔细看看：$1≤dis[v]-dis[u]≤9$，差分约束？

没错，就是差分约束，约束条件：


$$\left\{\begin{aligned} dis[v]-dis[u]≥1 \\dis[u]-dis[v]≥-9 \\\end{aligned}\right.$$



根据差分约束的经验，我们从 $u$ 向 $v$ 连一条边权为 $1$ 的边， 从 $v$ 向 $u$ 连一条边权为 $-9$的边跑最长路即可。

如果 $SPFA$ 跑出来的是负环，那么无解，否则每条边的长度为 $dis[v]-dis[u]$（现在可见 $dis$ 代表最长路径）

## 细节实现

首先你知道知道我们只要 $1~n$ 的路径，所以我们正反图各跑一遍，把那些 $1$ 不能到达的节点和 $n$ 不能到达的节点剔除掉，剩下的节点就是我们真正要进行约束的节点，而那些被剔除掉的节点对应的边可以随便乱赋值的啦……

这个操作可以通过两遍 $dfs$ 或者 $bfs$ 实现。但是由于我只建了一张图，所以我采用正反边异或后编号相等的原则。

这样我只写了一个 $dfs$ 函数

```cpp
void check(int x, bool *flag, int op) {
	if(flag[x]) return;
	flag[x] = 1;
 	for(int i = head[x]; i; i = Next[i]) {
		if(~i & op) continue;
		int y = ver[i];
		check(y, flag, op);
	}
}
```

但是 $op$ 只有 $0$ 和 $1$，与上 $0$ ……崩崩

正确的写法：

```pp
void check(int x, bool *flag, int op) {
	if(flag[x]) return;
	flag[x] = 1;
 	for(int i = head[x]; i; i = Next[i]) {
		if((i & 1) == op) continue;
		int y = ver[i];
		check(y, flag, op);
	}
}
```

然后要注意特判 $1$ 不能到 $n$ 的情况，也要输出 $-1$。

接下来看代码理解吧


------------


$Code:$
------------


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

/*
约束条件
d[a] + val<a,b> = d[b]
1 <= d[b] - d[a] <= 9
*/

const int N = 1e5 + 10, M = N << 2;
int head[N], Next[M], ver[M];
int edge[M], cnt = 1;
struct rec {
	int x, y;
} e[M >> 1];

void add(int x, int y, int v) {
	ver[++cnt] = y, edge[cnt] = v;
	Next[cnt] = head[x], head[x] = cnt;
}

void Add(int x, int y) {
	add(x, y, 0), add(y, x, 0);
}

bool v1[N], v2[N];
void check(int x, bool *flag, int op) {
	if(flag[x]) return;
	flag[x] = 1;
 	for(int i = head[x]; i; i = Next[i]) {
		if((i & 1) == op) continue;
		int y = ver[i];
		check(y, flag, op);
	}
}

int dis[N], tot[N];
bool v[N];
void spfa(int n) {
	memset(dis, ~0x7f, sizeof dis), dis[1] = 0;
	queue<int> q;
	q.push(1), v[1] = 1;

	while(q.size()) {
		int x = q.front();
		q.pop(), v[x] = 0;

		for(int i = head[x]; i; i = Next[i]) {
			int y = ver[i], val = edge[i];
			if(dis[y] < dis[x] + val) {
				dis[y] = dis[x] + val;
				if(!v[y]) q.push(y), tot[y]++, v[y] = 1;
				if(tot[y] > n) puts("-1"), exit(0);
			}
		}
	}
	if(dis[n] < 0) puts("-1"), exit(0);
}

void clear() {
	memset(head, 0, sizeof head);
	memset(Next, 0, sizeof Next);
	memset(ver, 0, sizeof ver);
	cnt = 0;
}

bool is[N];
int main() {
	int n, m;
	scanf("%d %d", &n, &m);
	for(int i = 1; i <= m; i++) {
		scanf("%d %d", &e[i].x, &e[i].y);
		Add(e[i].x, e[i].y);
	}
	check(1, v1, 1), check(n, v2, 0);
	for(int i = 1; i <= n; i++)
		if(v1[i] && v2[i]) is[i] = 1;

	is[1] = is[n] = 1;
	clear();
	for(int i = 1; i <= m; i++) {
		if(is[e[i].x] && is[e[i].y]) {
			add(e[i].x, e[i].y, 1);
			add(e[i].y, e[i].x, -9);
		}
	}
	spfa(n);
	printf("%d %d\n", n, m);
	for(int i = 1; i <= m; i++) {
		printf("%d %d ", e[i].x, e[i].y);
		if(is[e[i].x] && is[e[i].y])
			printf("%d\n", dis[e[i].y] - dis[e[i].x]);
		else printf("1\n");
	}
	return 0;
}
```


$End$
------------


当时考试脑抽没写出来，然后因为那个 $op$ 改了一个下午……

跪了 $Orz$




---

## 作者：hl666 (赞：2)

白天比赛的时候基本上都写出来了，结果判无用边的时候脑抽了一下挂了

~~然而我还以为是后面写跪了一直在魔调233~~

首先看到这题我们先日常考虑一些简单的情况，我们来分析一下：

若起点不可达终点则输出$-1$（题面里之前没加上，可TM坑死人了）

若存在一个点无法从起点到达**或者**是无法到达终点（比赛的时候脑抽写成**且**了233）那么这个点就是无用的，可以把它删掉，那么所有与它相连的边都可以随便赋值

然后考虑将剩下的边再建成图，那么此时出现环的话环上一定不合法，因此也可以判掉

那么我们惊喜地发现现在剩下的图已经是个**DAG**了，并且从起点到每个点的所有路径长度都要相同，那我们按拓扑序逐步转移即可。接下来有两种做法：

第一种是我比赛的时候写的，比较诡异，正确性感觉是对的但是又证明不来

考虑先**拓扑排序**一遍，求出将边长视为$1$时从起点到每个点的路径长度区间范围$[l_i,r_i]$

那么我们考虑化边权为点权，把每个点到它的路径总长作为点权$val_i$，那么显然每个$val_i$的取值范围就是$[r_i,9\times l_i]$

考虑$1$号点的点权可以定下为$0$，那么对于接下来的每个点，如果它的前驱点$j$的点权为$val_j$，那么它的取值区间应该对$[val_j+1,val_j+9]$取交

那么我们得出每个点的取值区间后直接在里面随便取一个值即可（顺手取最小值），同时再判掉一些无解的情况

乍一看随便取可能会错，但是这里的后面的点权范围是在前面的路径情况下考虑过的结果，因此可以通过此题

```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#define RI register int
#define CI const int&
using namespace std;
typedef vector <int>:: iterator VI;
const int N=2005,INF=1e9;
struct interval
{
	int l,r;
	inline interval(CI L=-INF,CI R=INF)
	{
		l=L; r=R;
	}
	friend inline interval operator & (const interval& A,const interval& B)
	{
		return interval(max(A.l,B.l),min(A.r,B.r));
	}
	inline void operator &=(const interval& ots)
	{
		*this=*this&ots;
	}
}v[N]; int n,m,x[N],y[N],z[N],q[N],val[N];
bool f1[N],f2[N]; vector <int> pre[N];
struct Graph
{
	struct edge
	{
		int to,nxt;
	}e[N]; int head[N],cnt,deg[N];
	inline void clear(void)
	{
		memset(head,0,n+1<<2); memset(deg,0,n+1<<2); cnt=0;
	}
	inline void addedge(CI x,CI y)
	{
		e[++cnt]=(edge){y,head[x]}; head[x]=cnt; ++deg[y];
	}
	#define to e[i].to
	inline void BFS(CI st,bool *vis)
	{
		RI H=0,T=1; vis[q[1]=st]=1; while (H<T)
		{
			int now=q[++H]; for (RI i=head[now];i;i=e[i].nxt)
			if (!vis[to]) vis[to]=1,q[++T]=to;
		}
	}
	inline bool Top_Sort(void)
	{
		RI H=0,T=0,i; for (i=1;i<=n;++i) if (!deg[i]) q[++T]=i;
		while (H<T)
		{
			int now=q[++H]; for (i=head[now];i;i=e[i].nxt)
			if (pre[to].push_back(now),!--deg[to]) q[++T]=to;
		}
		return T==n;
	}
	#undef to
}A,B;
int main()
{
	//freopen("CODE.in","r",stdin); freopen("CODE.out","w",stdout);
	RI i,j; for (scanf("%d%d",&n,&m),i=1;i<=m;++i)
	scanf("%d%d",&x[i],&y[i]),A.addedge(x[i],y[i]),B.addedge(y[i],x[i]);
	for (A.BFS(1,f1),B.BFS(n,f2),i=1;i<=m;++i) if (!f1[x[i]]||!f2[x[i]]) z[i]=1;
	if (!f1[n]) return puts("-1"),0;
	for (A.clear(),i=1;i<=m;++i) if (!z[i]) A.addedge(x[i],y[i]);
	if (!A.Top_Sort()) return puts("-1"),0; for (v[1]=interval(0,0),i=2;i<=n;++i)
	{
		int mi=INF,mx=-INF; for (VI it=pre[q[i]].begin();it!=pre[q[i]].end();++it)
		mi=min(mi,v[*it].l+1),mx=max(mx,v[*it].r+1); v[q[i]]=interval(mi,mx);
	}
	for (i=1;i<=n;++i) if (v[i]=interval(v[i].r,9*v[i].l),v[i].l>v[i].r)
	return puts("-1"),0; for (i=2;i<=n;++i)
	{
		interval tp; for (VI it=pre[q[i]].begin();it!=pre[q[i]].end();++it)
		tp&=interval(val[*it]+1,val[*it]+9); v[q[i]]&=tp;
		if (v[q[i]].l>v[q[i]].r) return puts("-1"),0; val[q[i]]=v[q[i]].l;
	}
	for (i=1;i<=m;++i) if (!z[i]) z[i]=val[y[i]]-val[x[i]];
	for (printf("%d %d\n",n,m),i=1;i<=m;++i) printf("%d %d %d\n",x[i],y[i],z[i]);
	return 0;
}
```

当然还有另一种更简单正确性也有保证的做法，我们考虑直接顺推每个点的权值区间，那么此时这个点的取法就会影响到后面了，因此我们可以倒着再做一遍，这样就可以保证正确性

```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#define RI register int
#define CI const int&
using namespace std;
typedef vector <int>:: iterator VI;
const int N=2005,INF=1e9;
struct interval
{
	int l,r;
	inline interval(CI L=-INF,CI R=INF)
	{
		l=L; r=R;
	}
	friend inline interval operator & (const interval& A,const interval& B)
	{
		return interval(max(A.l,B.l),min(A.r,B.r));
	}
	inline void operator &=(const interval& ots)
	{
		*this=*this&ots;
	}
}v[N]; int n,m,x[N],y[N],z[N],q[N],val[N];
bool f1[N],f2[N]; vector <int> pre[N];
struct Graph
{
	struct edge
	{
		int to,nxt;
	}e[N]; int head[N],cnt,deg[N];
	inline void clear(void)
	{
		memset(head,0,n+1<<2); memset(deg,0,n+1<<2); cnt=0;
	}
	inline void addedge(CI x,CI y)
	{
		e[++cnt]=(edge){y,head[x]}; head[x]=cnt; ++deg[y];
	}
	#define to e[i].to
	inline void BFS(CI st,bool *vis)
	{
		RI H=0,T=1; vis[q[1]=st]=1; while (H<T)
		{
			int now=q[++H]; for (RI i=head[now];i;i=e[i].nxt)
			if (!vis[to]) vis[to]=1,q[++T]=to;
		}
	}
	inline bool Top_Sort(void)
	{
		RI H=0,T=0,i; for (i=1;i<=n;++i) if (!deg[i]) q[++T]=i;
		while (H<T)
		{
			int now=q[++H]; for (i=head[now];i;i=e[i].nxt)
			if (pre[to].push_back(now),!--deg[to]) q[++T]=to;
		}
		return T==n;
	}
	#undef to
}A,B;
int main()
{
	//freopen("CODE.in","r",stdin); freopen("CODE.out","w",stdout);
	RI i,j; for (scanf("%d%d",&n,&m),i=1;i<=m;++i)
	scanf("%d%d",&x[i],&y[i]),A.addedge(x[i],y[i]),B.addedge(y[i],x[i]);
	for (A.BFS(1,f1),B.BFS(n,f2),i=1;i<=m;++i) if (!f1[x[i]]||!f2[x[i]]) z[i]=1;
	if (!f1[n]) return puts("-1"),0;
	for (A.clear(),i=1;i<=m;++i) if (!z[i]) A.addedge(x[i],y[i]);
	if (!A.Top_Sort()) return puts("-1"),0; v[1]=interval(0,0);
	for (i=2;i<=n;++i) for (VI it=pre[q[i]].begin();it!=pre[q[i]].end();++it)
	v[q[i]]&=interval(v[*it].l+1,v[*it].r+9);
	for (i=n;i>1;--i) for (VI it=pre[q[i]].begin();it!=pre[q[i]].end();++it)
	v[*it]&=interval(v[q[i]].l-9,v[q[i]].r-1);
	for (i=1;i<=n;++i) if (v[i].l>v[i].r) return puts("-1"),0;
	for (i=1;i<=m;++i) if (!z[i]) z[i]=v[y[i]].l-v[x[i]].l;
	for (printf("%d %d\n",n,m),i=1;i<=m;++i) printf("%d %d %d\n",x[i],y[i],z[i]);
	return 0;
}
```

---

## 作者：Vanilla_chan (赞：1)

[P5590 赛车游戏](https://www.luogu.com.cn/problem/P5590)

## Problem

给一张有向图，请给每一条边赋上边权$w\in[1,9]$使得每一条$1\to n$的路径的长度相等。

## Solution

先来点前置知识：差分约束。

### 简述

将很多对变量之间的差$\le c$的关系转化为图论，再用图论算法来求解这个不等式组的解。

### 步骤

对于$x_j-x_i\le k$，我们会发现它类似最短路网络中的三角不等式$d_v-d_u\le w_{<u,v>}$.我们将每一个变量看作一个点，再建立一个超级原点$x_0$并向每一个点连一条权值为0的有向边。对于每一个不等式$x-y\le k\to x\le y+k$，我们连一条由$y$指向$x$，权值为$k$的有向边，然后跑最短路。

在建图的过程中要先关注具体问题，若求的是**两个变量差的最大值**，那么将所有不等式转变成"**<=**"的形式并且在建图后求**最短路**，反之在转换成"**>=**"的形式，并且求**最长路**。

另外，如果有负环，那么该不等式组无解。我们只要放心大胆的跑SPFA就好。如果一个点**入队次数大于$n$**，说明存在负环。

### Code

见模板题

---

好。接下来回到这道题。

给一张有向图，请给每一条边赋上边权$w\in[1,9]$使得每一条$1\to n$的路径的长度相等。

如果始终想的是**如何让所有$1\to n$的路径相等**那么就想错方向了。

在一个图中进行最短路的时候，$dis_x+w_{x\to v}=dis_v$说明$dis_v-dis_x=w_{x\to v}\in[1,9]$，这样我们才可以用差分约束系统进行求解。

$1\le dis_v-dis_x\le9\longrightarrow dis_v\le dis_x+9\bigvee dis_x\le dis_v-1$，所以我们连一条$x\to v$权值为9的边，一条$v\to x$权值为$-1$的边。

## Code

```c++
/**************************************************************
 * Problem: 5590
 * Author: Vanilla_chan
 * Date: 20210330
 * E-Mail: Vanilla_chan@outlook.com
**************************************************************/
//预编译部分已略
#define N 2010
#define M 8000
int head[N],ver[M],nxt[M],w[M];
int cnt;
void insert(int x,int y,int z)
{
	nxt[++cnt]=head[x];
	head[x]=cnt;
	ver[cnt]=y;
	w[cnt]=z;
}
int f[N];
int getf(int x)
{
	if(f[x]==x) return x;
	return f[x]=getf(f[x]);
}

void merge(int x,int y)
{
	x=getf(x);
	y=getf(y);
	if(x==y) return;
	f[x]=y;
}


int n,m;
vector<int>edge[N],redge[N];
int u[N],v[N];
int useful[N];
bool book[N];
void dfs(int x)
{
	if(book[x]) return;
	book[x]=1;
	useful[x]++;
	for(unsigned int i=0,v;i<edge[x].size();i++)
	{
		v=edge[x][i];
		dfs(v);
	}
}
void rdfs(int x)
{
	if(book[x]) return;
	book[x]=1;
	useful[x]++;
	for(unsigned int i=0,v;i<redge[x].size();i++)
	{
		v=redge[x][i];
		rdfs(v);
	}
}
queue<int>q;
int dis[N];
int tot[N];
bool SPFA(int x)
{
	while(q.size()) q.pop();
	memset(dis,0x3f,sizeof(dis));
	dis[x]=0;
	memset(book,0,sizeof(book));
	book[x]=1;
	q.push(x);
	while(q.size())
	{
		x=q.front();
		q.pop();
		book[x]=0;
		for(int i=head[x],v;i;i=nxt[i])
		{
			v=ver[i];
			if(dis[v]>dis[x]+w[i])
			{
				dis[v]=dis[x]+w[i];
				if(!book[v])
				{
					tot[v]++;
					if(tot[v]>n) return 0;
					book[v]=1;
					q.push(v);
				}
			}
		}
	}
	return 1;
}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	n=read();
	m=read();
	for(int i=1;i<=m;i++)
	{
		u[i]=read();
		v[i]=read();
		edge[u[i]].push_back(v[i]);
		redge[v[i]].push_back(u[i]);
		merge(u[i],v[i]);
	}
	if(getf(1)!=getf(n))
	{
		cout<<"-1"<<endl;
		return 0;
	}
	for(int i=1;i<=n;i++) useful[i]=-1;
	dfs(1);
	memset(book,0,sizeof(book));
	rdfs(n);
	memset(book,0,sizeof(book));
	for(int i=1;i<=n;i++)
	{
		if(useful[i]!=1) useful[i]=0;
	}
	if(useful[1]==0||useful[n]==0)
	{
		cout<<"-1"<<endl;
		return 0;
	}
	for(int i=1;i<=m;i++)
	{
		if(useful[u[i]]&&useful[v[i]])
		{
			insert(u[i],v[i],9);
			insert(v[i],u[i],-1);
		}
	}
	if(SPFA(1)==0)
	{
		cout<<"-1"<<endl;
		return 0;
	}
	cout<<n<<" "<<m<<endl;
	for(int i=1;i<=m;i++)
	{
		cout<<u[i]<<" "<<v[i]<<" ";
		if(useful[u[i]]&&useful[v[i]])
		{
			cout<<dis[v[i]]-dis[u[i]];
		}
		else cout<<rand()%9+1;
		cout<<endl;
	}
	return 0;
}
```



---

## 作者：81179332_ (赞：1)

对于每一个被 $1\rightarrow n$ 的路径经过的边，我们要安排它的边权，显然 $1\le dis_v-dis_u\le 9$

建立差分约束系统，从 $u$ 向 $v$ 连一条边权为 $9$ 的边，从 $v$ 向 $u$ 连一条边权为 $-1$ 的边，跑最短路，表示 $dis_v\le dis_u+9,dis_u\le dis_v-1$

无解的情况有两种：不连通和差分约束出现负环

```cpp
const int N = 1010,M = 200010;
int n,m,x[M],y[M];
struct Dc
{
	EE(1);int dis[N],cnt[N];bool vis[N];
	queue<int> q;
	bool SPFA()
	{
		memset(dis,63,sizeof(dis));
		q.push(0),dis[0] = 0,vis[0] = 1;
		while(!q.empty())
		{
			int u = q.front();q.pop();vis[u] = 0;
			for(int i = head[u];i;i = e[i].nxt)
			{
				int v = e[i].to;
				if(dis[v] > dis[u] + e[i].w)
				{
					dis[v] = dis[u] + e[i].w;
					cnt[v] = cnt[u] + 1;
					if(cnt[v] > n) return 0;
					if(!vis[v]) q.push(v),vis[v] = 1;
				}
			}
		}
		return 1;
	}
}D;
struct Graph
{
	EE(1);bool book[N],vis[N];
	bool dfs(int u)
	{
		if(u == n || book[u]) return 1;
		bool fl = 0;vis[u] = 1;
		for(int i = head[u],v;i;i = e[i].nxt) if(!vis[v = e[i].to])
			if(dfs(v)) D.add(u,v,9),D.add(v,u,-1),fl = 1;
		vis[u] = 0;
		return book[u] = fl;
	}
}G;
int main()
{
	freopen("random.in","r",stdin);
	freopen("sol.out","w",stdout);
	n = read(),m = read();
	for(int i = 1;i <= m;i++) { x[i] = read(),y[i] = read();G.add(x[i],y[i]); }
	for(int i= 1;i <= n;i++) D.add(0,i,0);
	if(!G.dfs(1) || !D.SPFA()) { puts("-1");return 0; }
	pprint(n),fprint(m);
	for(int i = 1;i <= m;i++)
	{
		pprint(x[i]),pprint(y[i]);
		int res = abs(D.dis[x[i]] - D.dis[y[i]]);
		if(res > 0 && res < 10) fprint(res);
		else puts("1");
	}
	return 0;
```

---

## 作者：Luarence (赞：0)

本题苟弱用Java AC 虽然思路可能跟c++类似，但是具体实现方法还是有一定的差异！
**题目分析：** 本题主要分三步，存图，遍历1-n必经的节点，跑SPFA。

需要知道的几个名词:

**差分约束**：不等式之间的转换，实际上是一种转化，把某些问题转化成最短路问题来进行求解

**SPFA**：计算某个点到所有节点最短路的算法

**松弛操作**: 一个值先在上界，当存在比这个值小的值时，更新这个值，这次操作就算一次松弛操作

（画图画的奇丑无比请见谅）
![差分约束](https://cdn.luogu.com.cn/upload/image_hosting/2vmbbfxw.png)
![跑两边dfs的效果](https://cdn.luogu.com.cn/upload/image_hosting/x3yfxm6g.png)

```java
import java.io.*;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;

public class Main {
    public static int n,m;
    public static Roads[] roads1;
    public static Roads[] roads2;
    public static Roads[] roads;
    //判断是否两次都遍历到
    public static int[] signed;
    public static int[] f,t;
    public static int[] nums;
    //寻找1-n的必经之路
    public static void dfs1(int x){
        for (int i = 0; i < roads1[x].others.size(); i++) {
            int to = roads1[x].others.get(i)[0];
            if (roads1[to].ifUse) {
                continue;
            }
            roads1[to].ifUse = true;
            dfs1(to);
        }
    }
    //寻找从n-1的必经之路
    public static void dfs2(int x){
        for (int i = 0; i < roads2[x].others.size(); i++) {
            int to = roads2[x].others.get(i)[0];
            if (roads2[to].ifUse) {
                continue;
            }
            roads2[to].ifUse = true;
            dfs2(to);
        }
    }

    public static boolean spfa(){
        Queue<Integer> queue = new ArrayDeque<>();
        roads[1].dis = 0;
        roads[1].ifUse = true;
        queue.offer(1);
        while (!queue.isEmpty()) {
            int now = queue.poll();
            roads[now].ifUse = false;
            nums[now]++;
            for (int i = 0; i < roads[now].others.size(); i++) {
                int v = roads[now].others.get(i)[0];
                int d = roads[now].others.get(i)[1];
                if (roads[v].dis > roads[now].dis + d) {
                    roads[v].dis = roads[now].dis+d;
                    if (nums[v] > n) {
                        return false;
                    }
                    if (roads[v].ifUse) {
                        continue;
                    }
                    roads[v].ifUse = true;
                    queue.offer(v);
                }
            }
        }
        return true;
    }
    public static void main(String[] args) throws IOException {
        StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));

        ok:
        while (in.nextToken() != StreamTokenizer.TT_EOF) {
            n = (int)in.nval;
            in.nextToken();
            m = (int)in.nval;
            roads1 = new Roads[10010];
            roads2 = new Roads[10010];
            roads = new Roads[10010];
            f = new int[10010];
            t = new int[10010];
            nums = new int[10010];
            signed = new int[10010];
            for (int i = 0; i < roads2.length; i++) {
                roads1[i] = new Roads(i);
                roads2[i] = new Roads(i);
                roads[i] = new Roads(i);
            }
            for (int i = 1; i <= m; i++) {
                in.nextToken();
                int from = (int)in.nval;
                in.nextToken();
                int to = (int)in.nval;
                f[i] = from;
                t[i] = to;
                int[] tmp1 = new int[2];
                int[] tmp2 = new int[2];
                tmp1[0] = to;
                tmp1[1] = 1;
                tmp2[0] = from;
                tmp2[1] = 1;
                roads1[from].others.add(tmp1);
                roads2[to].others.add(tmp2);
            }
            dfs1(1);
            dfs2(n);
            //找到必经之路
            for (int i = 1; i <= n; i++) {
                if (roads1[i].ifUse && roads2[i].ifUse) {
                    signed[i] = 1;
                }
            }
            //n点到不了,更不用说从1-n了
            if (!roads1[n].ifUse) {
                out.println(-1);
                out.flush();
                continue ok;
            }
            //因为遍历不到1和n，强行加上1和n
            signed[1] = 1;
            signed[n] = 1;

            //建图
            for (int i = 1; i <= m; i++) {
                int from = f[i];
                int to = t[i];
                //都是必经之路
                if (signed[from] == 1 && signed[to] == 1) {
                    int[] tmp1 = new int[2];
                    int[] tmp2 = new int[2];
                    tmp1[0] = to;
                    tmp1[1] = -1;
                    tmp2[0] = from;
                    tmp2[1] = 9;
                    roads[from].others.add(tmp1);
                    roads[to].others.add(tmp2);
                }
            }
            if (!spfa()) {
                out.println(-1);
                out.flush();
                continue ok;
            }
            out.println(n+" "+m);
            for (int i = 1; i <= m; i++) {
                out.print(f[i]+" "+t[i]+" ");
                if (signed[f[i]] == 1 && signed[t[i]] == 1) {
                    out.print(roads[t[i]].dis*(-1)-roads[f[i]].dis*(-1));
                }else {
                    out.println(1);
                }
                out.println();
            }
            out.flush();
        }
    }
}
class Roads{
    //点序号
    int index;
    //是否在队列中
    boolean ifUse;
    //存储别的点
    List<int[]> others;
    //存储到这个点的距离
    int dis;

    public Roads(int index) {
        this.index = index;
        ifUse = false;
        others = new ArrayList<>();
        dis = 9999999;
    }
}

```
**题解又不好的地方欢迎各位大佬指出，我积极修正**

---

## 作者：Nemlit (赞：0)

~~果然我还是太$Naive$了~~

首先有一些点/边其实是没有意义的，如果从1出发不能到该点或者从该点不能到n，这个点就可以不用管了。这个过程可以用正反两边$dfs/bfs$实现

然后删掉那些点之后，新图中如果出现了环，那么显然是无解的

然后现在图就转化成了一张$DAG$

由于$1->n$的所有路径是定值，那么$1->$新图中所有点的路径都应该是一个定值（反证一下就知道了）

然后我们发现，对于每一条边$u->v$，实际上是要满足$1≤dis_v - dis_u ≤ 9$，不难发现这是一个**差分约束**模型

移一下项，我们有：$dis_u+1≤dis_v$，$dis_v-9≤dis_u$

于是对于每一条边$(u, v)$，我们连一条$(u, v, 1)$和一条$(u, v, -9)$即可

## $Code:$
~~不知道为什么只有30，先咕一会，调出来再放~~

~~好了调出来了，不连通的那些边的终点起点忘记输出了~~
```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
il int read() {
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define _ 20005
int n, m, head1[_], cnt, head2[_], head3[_], vis[_], dis[_], num[_], pax[_], v1[_], v2[_];
struct edge {
	int u, v, w, next;
}e1[_], e2[_], e3[_ << 1];
il void add1(int u, int v) {
	e1[++ cnt] = (edge){u, v, 0, head1[u]}, head1[u] = cnt;
	e2[cnt] = (edge){v, u, 0, head2[v]}, head2[v] = cnt;
}
il void add2(int u, int v) {
	e3[++ cnt] = (edge){u, v, 1, head3[u]}, head3[u] = cnt;
	e3[++ cnt] = (edge){v, u, -9, head3[v]}, head3[v] = cnt;
}
il void dfs1(int u) {
	v1[u] = 1;
	for(re int i = head1[u]; i; i = e1[i].next) if(!v1[e1[i].v]) dfs1(e1[i].v);
}
il void dfs2(int u) {
	v2[u] = 1;
	for(re int i = head2[u]; i; i = e2[i].next) if(!v2[e2[i].v]) dfs2(e2[i].v);
}
queue<int>q;
il void SPFA() {
	memset(dis, -64, sizeof(dis)), q.push(1), dis[1] = 0;
	while(!q.empty()) {
		int u = q.front(); q.pop(), vis[u] = 0;
		for(re int i = head3[u]; i; i = e3[i].next) {
			int v = e3[i].v;
			if(dis[v] < dis[u] + e3[i].w) {
				dis[v] = dis[u] + e3[i].w;
				if(!vis[v]) q.push(v), vis[v] = 1, ++ num[v];
				if(num[v] > n) puts("-1"), exit(0);
			}
		}
	}
}
int main() {
	n = read(), m = read();
	rep(i, 1, m) {
		int u = read(), v = read();
		add1(u, v);
	}
	dfs1(1), dfs2(n), cnt = 0;
	if(!v1[n]) return puts("-1"), 0;
	rep(i, 1, n) if(v1[i] && v2[i]) pax[i] = 1;
	rep(i, 1, m) if(pax[e1[i].u] && pax[e1[i].v]) add2(e1[i].u, e1[i].v);
	SPFA(), printf("%d %d\n", n, m);
	rep(i, 1, m) {
		if(pax[e1[i].u] && pax[e1[i].v]) {
			printf("%d %d %d\n", e1[i].u, e1[i].v, dis[e1[i].v] - dis[e1[i].u]);
		}
		else printf("%d %d %d\n", e1[i].u, e1[i].v, 9);
	}
	return 0;
}
```

---

## 作者：AThousandSuns (赞：0)

月赛时一直打 T4 的 80pts，结果数据出锅了一直只能拿 70pts，浪费了 1h，导致最后没 rush 出这题。~~不然就有本子拿了。~~

R.I.P.

---
根据直觉，这种题在 DFS 树上会好做很多。

先跑个以 $1$ 为根的 DFS 树。那么走了树上的返祖边肯定就不是简单路径。这些返祖边随便赋值都行。

注意的是图可能不连通，所以如果 $n$ 没有在这次 DFS 中遍历到，先判无解。

发现从点 $1$ 到点 $i$ 的可能距离肯定是连续的一些数（记作 $[l_i,r_i]$）。初始有 $l_1=r_1=0$。

然后因为我们把返祖边全都去掉了，就无环了，就可以拓扑排序了。

对于一个点 $v$，它的区间应该是所有有边连向 $v$ 的点 $u$ 的 $[l_u+1,r_u+9]$ 的交集。

如果有一个点的 $l_i>r_i$，明显无解。否则可以从 $n$ 倒推。倒推方法也差不多，设 $ans_i$ 表示点 $1$ 到点 $i$ 的实际距离。容易发现出度为 $0$ 的点可以在 $[l_i,r_i]$ 中随便选，然后倒推时只要能成功给边赋值而且 $ans$ 都在区间里面就行了。

注意的是图还是可能不连通，所以如果一条边的两个端点中有至少一个没有在 DFS 中遍历到，也可以随便赋值。

下面的代码，由于最后脑子烧坏了，所以长得一点也不像拓扑排序，~~而且还很丑~~，但是本质上是的。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> PII;
const int maxn=2222;
#define MP make_pair
#define PB push_back
#define lson o<<1,l,mid
#define rson o<<1|1,mid+1,r
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define ROF(i,a,b) for(int i=(a);i>=(b);i--)
#define MEM(x,v) memset(x,v,sizeof(x))
inline ll read(){
	char ch=getchar();ll x=0,f=0;
	while(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();
	while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
	return f?-x:x;
}
int n,m,el,head[maxn],to[maxn],nxt[maxn],uuu[maxn],vvv[maxn],lft[maxn],rig[maxn],cnt[maxn],cnt2[maxn],ans[maxn],dep[maxn];
bool ins[maxn],abon[maxn],ist[maxn],vis[maxn];
inline void add(int u,int v){
	to[++el]=v;nxt[el]=head[u];head[u]=el;
}
void dfs(int u){
	ins[u]=true;
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];
		if(dep[v]){
			if(ins[v]) abon[i]=true;
			else cnt[v]++,cnt2[v]++;
		}
		else{
			dep[v]=dep[u]+1;
			ist[i]=true;
			dfs(v);
		}
	}
	ins[u]=false;
}
void dfs2(int u){
	vis[u]=true;
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];
		if(abon[i]) continue;
		if(!ist[i]) cnt[v]--;
		lft[v]=max(lft[v],lft[u]+1);
		rig[v]=min(rig[v],rig[u]+9);
		if(!cnt[v] && !vis[v]) dfs2(v);
	}
}
void dfs3(int u){
	vis[u]=true;
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];
		if(abon[i]) continue;
		if(!ist[i]) cnt2[v]--;
		if(!cnt[v] && !vis[v]) dfs3(v);
		if(!cnt[v]){
			lft[u]=max(lft[u],ans[v]-9);
			rig[u]=min(rig[u],ans[v]-1);
		}
	}
	ans[u]=lft[u];
}
int main(){
	n=read();m=read();
	FOR(i,1,m){
		uuu[i]=read();vvv[i]=read();
		add(uuu[i],vvv[i]);
	}
	MEM(rig,0x3f);
	dep[1]=1;rig[1]=0;
	dfs(1);
	if(!dep[n]) return puts("-1"),0;
//	FOR(i,1,n) printf("%d: %d %d\n",i,lft[i],rig[i]);
	dfs2(1);
	FOR(i,1,n) if(lft[i]>rig[i]) return puts("-1"),0;
	MEM(vis,0);
	dfs3(1);
	printf("%d %d\n",n,m);
	FOR(i,1,m) printf("%d %d %d\n",uuu[i],vvv[i],abon[i]?9:max(1,min(9,ans[vvv[i]]-ans[uuu[i]])));
}
```

---


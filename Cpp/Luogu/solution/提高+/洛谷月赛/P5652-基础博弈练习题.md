# 基础博弈练习题

## 题目背景

YSGH is our red sun.

## 题目描述

YSGH 和 YGSH 在打膈膜，YSGS 在旁边围观。

规则是这样的，先给定一个正整数 $m$ 和一个 $n$ 个数的序列 $b$，一开始有一个棋子在 $b$ 的第一个位置，并将 $b_1$ 减去 $1$。此后双方轮流操作，每次操作，假设当前棋子在 $i$，可以把棋子移到一个位置 $j$，满足 $j \in [i, \min(i + m, n)]$ 且 $b_j > 0$，然后将 $b_j$ 减 $1$，YSGH 先手，谁先不能操作谁输。

众所周知，YSGH 和 YGSH 都是绝顶聪明的，所以两人都会使用最优策略。

而隔膜使用的序列 $b$ 是一个序列 $a$ 的一个连续非空子序列，当然序列 $a$ 和每次隔膜使用的序列 $b$ 都是 YSGS 定的。

现在他们进行了 $q$ 轮游戏，给出每轮游戏使用的区间，请你判断每轮谁会赢。

## 说明/提示

对于 $25\%$ 的数据，$n, m, q \le 10$，$a_i \le 2$。  
对于 $55\%$ 的数据，$n, m, q \le 5 \times {10}^3$。  
另有 $15\%$ 的数据，$n \le {10}^5$，$m \le 5$。  
对于 $90\%$ 的数据，$n, m, q \le {10}^6$。  
对于 $100\%$ 的数据，$1 \le n, m \le {10}^6$，$1 \le q \le {10}^7$，$1 \le a_i \le {10}^9$。

## 样例 #1

### 输入

```
5 2 3 0
2 4 1 2 3
1 5
3 5
3 4```

### 输出

```
5```

# 题解

## 作者：无意识躺枪人 (赞：40)

吹爆这道题！

真的超级爱这题啊！

可以给这篇题解点下赞吗qwq

在这里把考场上的思路完整的说一下

首先考虑倒推，如果最后一格的数是奇数，会怎么样？

以样例为例

![](https://cdn.luogu.com.cn/upload/image_hosting/sd9onyp7.png)

显然，如果我们走到了最后一格，就只能在上面反复横跳，直到这一列的格子完全消失

很容易发现，这样的情况，最后一列就是一个必胜点（这里必胜点定义为先走到这里一定获胜）

那么，在这一列前面m-1列之内，所有列都是必败点（因为如果走到这里，下一步对手一定可以走到必胜点）

用红色表示必胜点，蓝色表示必败点

![](https://cdn.luogu.com.cn/upload/image_hosting/pevwusnz.png)

接着继续考虑，如果要尽量避免走到蓝色的列（必败点），最后两人一定会在第二列上反复横跳，直到这一列消失

是不是很熟悉？对！这是和最开始情况一样的！

但这里，最后一格是偶数，显然它是必败点（先手过去一定会输）

那它前面那一列是什么点呢？因为是偶数，所以继承了前面的情况，也是必败点

到这里，我们已经可以得出一个结论了：

```
倒推，如果最后一列是奇数，那么这一列是必胜点，它前面的m-1列都必败
如果最后一列是偶数，那么这一列是必败点，所有玩家都会尽量避免走到这一列来
```

所以我们可以考虑连边！顺序枚举，对于每一列，把`它前面的第一个必胜点`向他连边，这样的话，连好后的图是一个多叉树形结构！

对于每次的询问l和r，如果l是r的祖先，那么先手必胜，否则后手必胜！

那么现在的问题来了，给出一棵固定形态的树，怎么$\Theta(1)$地判断u是否是v的祖先呢？

**dfs序！**

在dfs的过程中统计一个点第一次被访问到的时间戳，作为其dfn

如果$dfn[u]\leq dfn[v] \leq dfn[u]+size[u]-1$的话，u就是v的祖先！

那么这题就这样解决啦！

具体的看代码吧

```cpp
#include<bits/stdc++.h>
#define mod (1LL<<32)
#define ll long long
#define int long long
#define N 20000005
using namespace std;

int n,m,q,type,l[N],r[N];
int L,a[N],fa[N];//fa->这个点前面的第一个必胜转移点 
ll ans=0;

int A,B,C,P;
inline int rnd(){return A=(A*B+C)%P;}

struct Edge
{
	int next,to;
}edge[N];
int cnt=0,head[N];

inline void add_edge(int from,int to)
{
	edge[++cnt].next=head[from];
	edge[cnt].to=to;
	head[from]=cnt;
}

template<class T>inline void read(T &res)
{
	char c;T flag=1;
	while((c=getchar())<'0'||c>'9')if(c=='-')flag=-1;res=c-'0';
	while((c=getchar())>='0'&&c<='9')res=res*10+c-'0';res*=flag;
}

int siz[N],dfn[N],tms;
void dfs(int u,int fa)
{
//	cout<<"dfs: "<<u<<" "<<fa<<endl;
	siz[u]=1;
	if(!dfn[u]) dfn[u]=++tms;
	for(register int i=head[u];i;i=edge[i].next)
	{
		int v=edge[i].to;
		if(v==fa) continue;
		dfs(v,u);
		siz[u]+=siz[v];
	}
}

signed main()
{
	read(n);read(m);read(q);read(type);//数的个数，区间长度，询问，是否压缩 
	for(register int i=1;i<=n;++i) read(a[i]);
	if(!type)
	{
		for(register int i=1;i<=q;++i)
			read(l[i]),read(r[i]);
	}
	else
	{
		read(A);read(B);read(C);read(P);
		for(register int i=1;i<=q;++i)
		{
			l[i]=rnd()%n+1;
			r[i]=rnd()%n+1;
			if(l[i]>r[i]) swap(l[i],r[i]);
		}
	}
	
	for(register int i=1;i<=n;++i)
	{
		L=max(0LL,i-m-1);
		if(a[i]&1)//奇数是必胜点
		{
			if(a[L]&1) fa[i]=L,add_edge(L,i);
			else fa[i]=fa[L],add_edge(fa[L],i);
		}
		else//偶数，先手必败 
		{
			if(a[i-1]&1) fa[i]=i-1,add_edge(i-1,i);
			else fa[i]=fa[i-1],add_edge(fa[i-1],i);
		}
	}
	//处理出每个点倒序第一个必胜转移点 

	dfs(0,0);//dfs序 
//	for(register int i=1;i<=n;++i) cout<<siz[i]<<endl;
	for(register int i=1;i<=q;++i)
	{
		int u=l[i],v=r[i];
		if(u==v)
		{
			if(a[u]&1) continue;
			else ans=(ans+i*i)%mod;
			continue;
		}
//		cout<<dfn[u]<<" "<<dfn[v]<<" "<<dfn[u]+siz[u]-1<<endl;
		if(dfn[u]<=dfn[v]&&dfn[v]<=dfn[u]+siz[u]-1) continue;//先手必胜，没有贡献 
		ans=(ans+i*i)%mod;
	}
	printf("%lld\n",ans);
	return 0;
}

/*
4 2 1 0
2 2 0 0
1 4
*/
```

---

## 作者：w4p3r (赞：7)

## 一丶前言/闲扯

~~(好久都没写题解了)~~

这道题出得好哇QAQ(但是我觉得C和D应该换一下)

~~（我才不会告诉你我比赛的时候调了半个小时的判断子树）~~

## 二丶思路

看到这道题，我们立刻想到了博弈论（当然）。

**对于博弈论的题，我们应该从最简单的情况开始.** 我们先考虑只有一个数的情况。

显然，若此数为**偶数先手必胜，否则必败。**

然后我们现在考虑只有一次询问，且询问$(1,n)$怎么做

考虑DP，**假设$f_i \in \{ 0,1\}$表示从第$i$个点开始是必败态/必胜态**（$0$必败,$1$必胜）

**注意出发时$B_i$要减1，所以答案即为$f_1$**

由之前得到的结论$f_n=(B_n+1)\quad mod \quad 2$（偶数必胜，奇数必败）

考虑对于一个$i$，若存在$i+1<=j<=i+m$,使得$f_j=0$，则$f_i=1$（若从该点开始能转移到个必败点，则这个点是必胜点）

否则，$f_i=(B_i+1)\quad mod\quad 2$（此时谁先离开$i$谁就必败，所以就跟$n$点的情况一样了）

此时我们就可以得到$55$分的好成绩了（对于每个询问暴力DP）

为了方便理解，贴一下$DP$部分的代码吧

```cpp
inline int calc(int l,int r)
{
	for(register int i=l;i<=r;i++)f[i]=0;num=0;//初始化，num表示在i+1到i+m中有多少个j使得f[j]=0
	for(register int i=r;i>=l;i--)
	{
	   if(i+m+1<=r)num-=(f[i+m+1]^1);//除去i+m+1的影响
		if(num)f[i]=1;/*情况1*/else f[i]=a[i];/*情况2，a[i]=(B[i]+1)%2*/
		num+=(f[i]^1);//加上当前点的影响
	}
	return f[l];//返回答案
}
```
那么正解是什么呢，因为这个$DP$有点特殊，我们考虑继续研究这个$DP$的性质。

假设$f_{i,j}\in\{ 0,1\}$表示从$i$开始以$j$为结尾是必败态/必胜态（跟上面的$f$差不多）

假设我们已经求出了$f_{1,i-1},f_{2,i-1}...f_{i-1,i-1}$，我们来考虑$f_{1,i},f_{2,i}...f_{i,i}$怎么求

首先，$f_{i,i}=(B_i+1)\quad mod \quad2$~~（已经不想再解释了）~~

若$f_{i,i}=1$,则有$f_{i,1}=f_{i-1,1},f_{i,2}=f_{i-1,2},...,f_{i,i-1}=f_{i-1,i-1}$

**（因为一个点的$f$值只跟它后面有没有$0$与它自己的奇偶性有关系，在后面插入$1$显然不会改变前面任何点的答案）**

否则$f_{i,i-1}=f_{i,i-2}=f_{i,i-3}=...=f_{i,i-m}=1$（因为它们都可以直接转移到$f_{i,i}$这个必败态）~~(这个应该是显然把)~~

然后对于$1<=j<=i-m-1$，$f_{j,i}=f_{j,i-m-1}$

(这个的证明与上面类似，大概就是后面多余的$1$不会对前面的状态造成影响)

现在我们要求的是多对$f_{l,r}$，然后我们可以通过上面的结论，得出**类似于**这样的结论:$f_{l,r}=f_{l,r-1}=f_{l,r-2}=f_{l,r-m-3}...$

这差不多是类似于让$r$往前跳的过程，那跳到最后的结果是什么呢？有两种情况：

1.我们得到了一个$f_{l,r}=f_{l,x}$的结论$(l<x<=l+m,f_{x,x}=0)$，此时显然不能往前跳了（再跳就小于$l$了），此时我们可以得到$f_{l,r}=1$

2.我们得到了一个$f_{l,r}=f_{l,l}$的结论，此时我们可以得到$f_{l,r}=(B_l+1)\quad mod \quad 2$

（显然其他情况都可以继续往前跳）

那我们怎么判断一个$l,r$是第一种情况还是第二种情况呢？很简单，我们只要让$r$一直往前跳（假设当前点是$x$,若$f_{x,x}=1$往前跳$1$格，否则往前跳$m+1$格），若能跳到$l$则为第二种情况，否则是第一种情况。

这个跳的过程显然可以倍增，但是只有$90$分，我们怎么$AC$呢。

等等，一个点只能跳到另外一个点，你想到了什么图形结构？

**树！**

接下来的思路就很简单，若$f_{i,i}=1$，则$i-1$是$i$的父亲，否则$i-m-1$是$i$的父亲，问题就转换成了判断$l$是不是$r$的祖先。

这个问题依然可以倍增 ~~（只要你愿意）~~，但是你可以直接利用$dfs$序$O(1)$判断$r$在不在$l$的子树中。（不要离线，光$vector$的$pushback$就可让你和最后两个点说拜拜了，亲测）

~~然后你就成功做对了这道CSP D2T2难度的题了~~

## 三丶代码
```cpp
//WAPER
#include<bits/stdc++.h>
#define inf 1e9
#define eps 1e-6
#define N 1000010
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
inline ll read()
{
	char ch=getchar();
	ll s=0,w=1;
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
struct edge
{
	int next,to;
}e[N<<1];
int head[N],cnt;
int a[N];
int n,m,q,type;
int A,B,C,P,p[N],Time,size[N];
unsigned int ans;//因为是对2^32取模，所以直接用unsigned int就不用取模了
inline int rnd(){return A=(A*B+C)%P;}
inline void add_edge(int from,int to){e[++cnt]=(edge){head[from],to};head[from]=cnt;}
void dfs(int now)
{
	p[now]=++Time;size[now]=1;
	for(register int i=head[now];i;i=e[i].next)
	{
		dfs(e[i].to);size[now]+=size[e[i].to];
	}
}//求dfs序和子树大小
int main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=read(),m=read(),q=read(),type=read();
	for(register int i=1;i<=n;i++)a[i]=(read()+1)%2;//直接把(B[i]+1)%2的值处理出来	
	for(register int i=1;i<=n;i++)
	{
		if(!a[i])add_edge(max(i-m-1,0),i);//f[i][i]=0
		else add_edge(i-1,i);//f[i][i]=1
	}
	dfs(0);
	if(type==1)
	{
		A=read(),B=read(),C=read(),P=read();
		for(register int i=1;i<=q;i++)
		{
			int l=rnd()%n+1,r=rnd()%n+1;if(l>r)swap(l,r);
			if(p[l]<=p[r]&&p[l]+size[l]-1>=p[r])ans=ans+1u*a[l]*i*i;//情况2（r能跳到l）
			else ans=ans+1u*i*i;//情况1(r不能跳到l)
		}
	}
	else
	{
		for(register int i=1;i<=q;i++)
		{
			int l=read(),r=read();
			if(p[l]<=p[r]&&p[l]+size[l]-1>=p[r])ans=ans+1u*a[l]*i*i;//同上
			else ans=ans+1u*i*i;
		}
	}
	printf("%u\n",ans);
	return 0;
}

```
**如果认为我这篇题解对你有帮助的可以给我点一下赞qwq。如果有任何疑问，或者认为我的题解有什么问题的话，请务必私信我，感激不尽！我会努力把我的题解写得最好的!**

~~（为什么我10行头文件就不给我过啊，非要我要用bits，自闭了）~~

UPD:我收回前面的话，这题比CSP D2T2简单多了。。。(只会64自闭)


---

## 作者：泠小毒 (赞：6)

# 基础博弈练习题
给你一个长度为 $n$ 的数组 $A$ ，以及一个 $m$

$q$ 次询问，每次询问在 $A_l-A_r$ 上玩一局游戏

一开始棋子在 $A_l$ 上，并将 $A_l$ 减去 $1$

每次假设你在 $i$ 上，你可以跳到 $j\in[i,min(i+m,r)]$ 且 $A_j\not=0$ ，然后将 $A_j$ 减 $1$

先无法行动的人判输，一局游戏结束后会还原 $A$ 数组

询问每局游戏中先手是否有必胜策略
## 广告插入
在我的博客里看题解使用效果更佳哦QwQ

[慕容琳的后花园](https://muronglin.top/luogu-p5652/)

[博客园(同步更新)](https://www.cnblogs.com/muronglin/p/luogu-p5652.html)
## 解法
首先，如果 $A_r$ 是偶数，那么谁先跳上去谁输，即这个格子是必败态

所以策略是不要跳到这个格子上，即留在前一个格子上，谁先留不住谁输，于是可以把 $r$ 换成 $r-1$

如果 $A_r$ 是奇数，那么谁先跳上去谁赢，即这个格子是必胜态

所以这个格子的前 $m$ 个格子是必败态，策略是不要跳到这个格子的前 $m$ 个格子上

即留在 $A_{r-m-1}$ 上，同理可以把 $r$ 换成 $r-m-1$

通过一直将 $r$ 缩小，可以求得 $A_l$ 的胜负态

我们给 $A_l$ 下的一个定义是后手刚好跳到该格子上且还没有进行减 $1$ 的操作

如果 $A_l$ 是必败态，则先手必胜，反之则先手必败

这样我们就得出了一个 $O(qn)$ 的算法，每次求出一局游戏所有的胜负态

有一个小优化是求出 $f_i$ 表示 $i$ 前面有多少偶数

然后一直跳就可以了，复杂度是 $O(\frac {qn} m)$

这样就可以轻松拿到 $55$ 分啦，上一下代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll mod=(1ll<<32ll);
int A,B,C,P;
inline int rnd(){return A=(A*B+C)%P;}
int n,m,q,type,l,r,a[1000010],f[1000010];
ll ans;
int main()
{
	scanf("%d%d%d%d",&n,&m,&q,&type);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
		f[i]=(a[i]&1)?0:f[i-1]+1;
	if(type)scanf("%d%d%d%d",&A,&B,&C,&P);
	for(int i=1;i<=q;i++)
	{
		if(type)l=rnd()%n+1,r=rnd()%n+1;
		else scanf("%d%d",&l,&r);
		if(l>r)swap(l,r);
		int nw=r;
		while(1)
		{
			if(f[nw])nw-=f[nw];
			if(nw<=l){(ans+=1ll*i*i*(nw<l))%=mod;break;}
			nw-=m+1;
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```
然后我们可以发现，偶数的格子一定是必败态

所以可以扔掉这个 $f$ 数组，换成 $pre$ 数组

$pre_i$ 表示 $i$ 前面的第一个奇数的位置

然后把所有的奇数点看成一棵树

每个奇数点 $i$ 与 $pre_{i-m-1}$ 相连

建立一个 $0$ 号点作为超级源，与所有根相连

这样就变成了一棵树

$A_l$ 是必胜态的充要条件是 $A_{pre_r}$ 是 $A_l$ 的子孙

这个用时间戳来维护就可以了

当 $Tin_l<=Tin_{pre_r}$ 并且 $Tout_{pre_r}<=Tout_l$ 时

我们称 $A_{pre_r}$ 是 $A_l$ 的子孙
## ac代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 1000010
#define pb push_back
using namespace std;
const ll mod=(1ll<<32ll);
int A,B,C,P;
inline int rnd(){return A=(A*B+C)%P;}
vector<int>e[1000010];
int n,m,q,type,l,r,cnt,a[N],pre[N],tin[N],tout[N];
ll ans;
void dfs(int u)
{
	tin[u]=++cnt;
	for(auto v:e[u])
		dfs(v);
	tout[u]=++cnt;
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&q,&type);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
		pre[i]=(a[i]&1)?i:pre[i-1];
	for(int i=1;i<=m;i++)if(a[i]&1)
		e[0].pb(i);
	for(int i=m+1;i<=n;i++)if(a[i]&1)
		e[pre[i-m-1]].pb(i);
	dfs(0);
	if(type)scanf("%d%d%d%d",&A,&B,&C,&P);
	for(int i=1;i<=q;i++)
	{
		if(type)l=rnd()%n+1,r=rnd()%n+1;
		else scanf("%d%d",&l,&r);
		if(l>r)swap(l,r);
		if(a[l]&1)
			(ans+=1ll*i*i*(!(tin[l]<=tin[pre[r]]&&tout[pre[r]]<=tout[l])))%=mod;
		else (ans+=1ll*i*i)%=mod;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：加藤惠 (赞：5)

先考虑给出一个序列$B$，怎么判断是先手赢还是后手赢。

设$f_i$为当一个玩家第一次选到第$i$个位置时他会不会赢。如果$[i+1,i+m]$里有一个先手必胜，那么这个位置就是先手必败，$f_i=0$。否则就要看当前位置上的值的奇偶性了，冷静分析下不难想到这时当$B_i$为偶数时$f_i=0$，为奇数时$f_i=1$。

对$f$稍微分析一下，不难发现我们这个$dp$的过程其实就是先找到$r$左边第一个奇数，然后每次再找从当前位置往左走，最近但中间相隔的数的个数至少为$m$的奇数的那个位置，然后把到过的位置的$f_i$赋值为$1$，其余为$0$。

所以我们只要加速这个过程即可，不难想到倍增，这样做是$O(nlogn+qlogn)$的，但是并不能通过本题。

我们可以对每个点$i$往左边最近但中间相隔的数的个数至少为$m$的奇数的那个位置$j$，连一条边，不难发现这样连边的图是一个森林(把$j$看成是$i$的$father$)，那么每次询问只要查询$r$左边第一个奇数是否在$l$的子树中即可，这个可以通过$dfs$序来判断。

时间复杂度$O(n+q)$，可以通过本题。

```cpp
#include<bits/stdc++.h>
#define For(i,x,y) for (register int i=(x);i<=(y);i++)
#define Rep(i,x,y) for (register int i=(x);i<(y);i++)
#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)
#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define siz(x) ((int)(x).size())
#define all(x) (x).begin(),(x).end()
#define fil(a,b) memset((a),(b),sizeof(a))
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pa;
typedef vector<int> poly;
char buf[1<<23],*ps=buf,*pt=buf;
#define getchar() (ps==pt&&(pt=(ps=buf)+fread(buf,1,1<<23,stdin),ps==pt)?EOF:*ps++)
inline ll read(){
    ll x=0,f=1;char c=getchar();
    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();
    if (c=='-') f=-1,c=getchar();
    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
    return x*f;
}

const int N = 1e6+10;
int n,m,q,type,a[N],pre[N],Pre[N];
vector<int>e[N];

int A,B,C,P;
inline int rnd(){return A=(A*B+C)%P;}

int cnt,L[N],R[N];
inline void dfs(int u){
	L[u]=++cnt;
	for (auto v:e[u]) dfs(v);
	R[u]=cnt;
}

inline int Query(int x,int y){
	y=Pre[y];
	return (L[y]>=L[x]&&L[y]<=R[x]);
}

int main(){
	n=read(),m=read(),q=read(),type=read();
	For(i,1,n) a[i]=read()&1;
	For(i,1,n) Pre[i]=(a[i]?i:Pre[i-1]);
	For(i,1,m+1) e[0].pb(i);
	For(i,m+2,n) pre[i]=Pre[i-m-1],e[pre[i]].pb(i);
	dfs(0);
	unsigned ans=0;
	if (type) A=read(),B=read(),C=read(),P=read();
	for (unsigned i=1;i<=q;++i){
		int l,r;
		if (!type) l=read(),r=read();
			else l=rnd()%n+1,r=rnd()%n+1;
		if (l>r) swap(l,r);
		if (!Query(l,r)) ans+=i*i;
	}
	cout<<ans<<endl;
}
```

---

## 作者：redegg (赞：2)

[博客阅读](https://www.cnblogs.com/redegg/p/11857307.html)

题意要求求 $[l,r]$ 在 $a[l]-1$ 的情况下是否能先手必胜，转化一下，其实题意也可以理解为：先手第一步一定走 $l$ ，是否是后手必胜。

分类讨论，找出性质。

画图逆推以下，在确定右端点下，很明显有以下性质。

1. 第一个到右端点r点的人，若右端点为奇数则胜，为偶数则败。

2. 若第一个到 $i$ 点的人必胜，则第一个到 $[i-m,i-1]$ 的人必输。

3. 若设第一个到 $i$ 点的人必输的点叫必输点，则除了与右端点链接的必输点区间，其它必输点区间都至少含有连续 $m$ 个必输点。

4. 根据第 $2$ 条可得，若 $i+1$ 号点为必输点，则区间 $[i+1,min(i+m,r)]$ 均为必输点，**则等同于右端点在 $i$ 点处**，此时第一个到 $i$ 点的人的胜负状态和第 $1$ 条一样。

根据以上性质，总结出以下性质：

右端点为 $r$ 的情况下，若 $r$ 号点为必输点，则前面的胜负状态可以等价的把 $r-1$ 点作为右端点，若 $r$ 点为必胜点，则可以把 $r-m-1$ 的点等价作为右端点。

那么，我们现在需要找对于 $r$ 点来说， $l$ 点是否是 $r$ 点的必胜点，也可以看做 $r$ 等价往左移后， $l$ 是不是新 $r$ 的必胜点，等价往左移 $r$ 会有两种情况。一种是移动 $r$ 直到 $r$ 不大于 $l$ ，可以刚好落到 $l$ 点上，此时就可以根据 $l$ 是否是奇数判断是否是必胜点，另一种是移动 $r$ 直到 $r$ 不大于 $l$ ，然后发现 $l$ 点无法被等价看作右端点（ 无法落到 $l$ ）。对于第一种情况，$l$ 是否是必胜点由 $a[l]$ 是奇是偶决定，第二种情况，则 $l$ 一定不能作为必胜点。

那么如何快速判断 $l$ 是否是$r$ 必胜点呢？我可以记录pr[i]表示i点作为右端点，除开i点外在 $i$ 点左边的第一个必胜点（没有的话pr[i]=0），那么pr[i]的转移可以写出来：

$a[i]$ 是奇数时，若 $a[i-m-1]$ 是奇数，则 $pr[i]=i-m-1$ ，否则 $pr[i]=pr[i-m-1]$ 。

$a[i]$ 是偶数时，若 $a[i-m-1]$ 是奇数，则 $pr[i]=i-1$ ，否则 $pr[i]=pr[i-1]$ 。

这样处理 $pr$ 后，把 $pr[i]$ 当作 $i$ 的父亲点，则 $i$ 的祖先节点都是以 $i$ 为右端点时的必胜点，简要证明：因为 $pr[i]$ 在 $i$ 是右端点时也可以等价看作右端点，则 $pr[pr[i]]$ 也一定是必胜点，同理，祖先点都是。

那么此时题意就是： $l$ 是否是 $r$ 的祖先点。若是，先手胜，不是，后手胜。把后手胜的贡献加起来就是答案了。当然，若 $a[r]$ 为偶数时，此时的必胜关系必须在 $l\neq r$ 的情况下才满足。构一下树，想一下为什么树的结构是这样的，思考一下为什么 $a[r]$ 为偶数需要特判，如果明白了这个思路基本就没问题了。

至于求是否是祖先点，静态树结构， $dfn$ 序记录一下就行了。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m,Q,cnt,op;
int pr[1000005];
vector<int> q[1000005];
int dfn[1000005];
int siz[1000005];
int a[1000005];

int A,B,C,P;
inline int rnd(){return A=(A*B+C)%P;}

long long ans;
long long mod=(1ll<<32);
void dfs(int x){
    cnt++;dfn[x]=cnt;
    for(int i=0;i<q[x].size();i++){
        int nx=q[x][i];
        dfs(nx);
        siz[x]+=siz[nx];
    }
    siz[x]++;
}

int main(){
    scanf("%d%d%d%d",&n,&m,&Q,&op);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        if(a[i]%2==1){
            int nx=max(i-m-1,0);
            //cout<<nx<<endl;
            if(a[nx]%2)pr[i]=nx;
            else pr[i]=pr[nx];
        }
        else{
            if(a[i-1]%2)pr[i]=i-1;
            else pr[i]=pr[i-1];
        }
        //cout<<i<<"  "<<pr[i]<<endl;
        q[pr[i]].push_back(i);
    }

    dfs(0);

    if(op)scanf("%d%d%d%d",&A,&B,&C,&P);

    for(long long i=1;i<=Q;i++){
        int l,r;
        if(op){
            l=rnd()%n+1,r=rnd()%n+1;
        }
        else{scanf("%d%d",&l,&r);}
        if(l>r)swap(l,r);
        if(l==r){
            if(a[l]%2==0)ans=(ans+i*i)%mod;
            continue;
        }
        if(m==0){
            if(a[l]%2==0)ans=(ans+i*i)%mod;
            continue;
        }
        if(dfn[l]+siz[l]-1>=dfn[r]&&dfn[l]<=dfn[r]){

        }
        else ans=(ans+i*i)%mod;
    }
    printf("%lld\n",ans);
    return 0;
}

```


---

## 作者：HenryYang (赞：1)

# 【洛谷P5652】基础博弈练习题——杨子曰题目




推荐一波：[我的博客](https://blog.csdn.net/HenryYang2018)

---

**题目背景**

YSGH is our red sun.

**题目描述**

YSGH和YGSH在打膈膜，YSGS在旁边围观。

规则是这样的，先给定一个正整数$m$和一个$n$个数序列$B$，一开始有一个棋子在$B$的第一个位置，并将$B_1$
 减去1。此后双方轮流操作，每次操作，假设当前棋子在$i$，可以把棋子移到一个位置$j$，满足$j\in[i,min(i+m,n)]$且$B_j>0$，然后将$B_j$
​	
 减1，YSGH先手，谁先不能操作谁输。

众所周知，YSGH和YGSH都是绝顶聪明的，所以两人都会使用最优策略。

而隔膜使用的序列$B$是一个序列$A$的一个连续非空子序列，当然序列$A$和每次隔膜使用的序列$B$都是YSGS定的。

现在他们进行了$q$轮游戏，给出每轮游戏使用的区间，请你判断每轮谁会赢。

**输入格式**

由于本题数据规模较大，直接输入输出会占用比计算多数倍的时间，因此当询问过多时会对询问的输入输出进行了压缩。

第一行四个正整数$n,m,q,type$，$n,m,q$意义同题面描述，type表示当前数据的类型，type=1说明该组数据进行了压缩，type=0则说明没有，数据保证当$q>10^6$时，$type=1$。
第二行$n$个正整数，第$i$个正整数表示$a_i$，意义同题面描述。

如果$type=1$，第三行四个正整数$A,B,C,P$，表示询问的生成方式。

```cpp
int A,B,C,P;
inline int rnd(){return A=(A*B+C)%P;}
```

每次询问时的调用方法为：

```cpp
l=rnd()%n+1,r=rnd()%n+1;
```

如果生成的$l>r$，则还需要交换$l,r$。

数据保证$0<=A*B<P,\ 0<=C<P,\ P(B+1)<2^{31}-1$

如果$type=0$，接下来$q$行，每行两个正整数$l,r$，意义同题面描述。

输出格式
输出共一行一个正整数，表示($ sum^q_{i=1}i^2*[$第i次询问YSGH会赢$]\ mod \ 2^{32} $)

$[x]$表示若$x$为真则值为$1$，否则为$0$。

**输入输出样例**

**输入 #1**

```cpp
5 2 3 0
2 4 1 2 3
1 5
3 5
3 4
```

**输出 #1**

```cpp
5
```

**说明/提示**

对于25%的数据：$n,m,q\le10, A[i]\le2$

对于55%的数据：$n,m,q\le5000$

另有15%的数据：$n\le10^5, m\le5$

对于90%的数据：$n,m,q\le10^6$
 
对于100%的数据：$n,m\le10^6,q\le10^7, 1\le A[i]\le10^9$

---

题目大意：给出一个数列，对于每个询问$[l,r]$,先手从l开始，玩家可以从左往右跳$[0,m]$格，且跳到的格子不为0（由于数列元素都大于1，其实就是不能在原地待到它变成负数），并给跳到的格子上的数字-1，谁不能跳了谁就输了，询问先手是否有必胜策略。

---

先BB一下：基础博弈练习题???? 这……


再BB一下：你看我多久没有写过题解了，可见这道题给我带来的震撼

---

我们开始曰一下切掉这道题的心路历程：

首先，它作为一道**博弈论**的题目我们自然而然要从最终最简单的情况开始讨论起：

现在轮到我了：而我站在最后一个格元素上，数字为0——啊，我**必败**了

现在轮到我了：而我站在最后一个格元素上，数字为1——哦，我**必胜**了

……

于是我们推出了这样一个结论：**如果最后一个元素如果是偶数，跳上去就必败了；如果最后一个元素是奇数，跳上去就必胜了**

好的，我们现在开始分类讨论：

1. 如果最后一个格子是偶数：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191113191308566.png)


那么，一个智商正常的人都不会往上最后一个格子跳——除非，他站在红格子上，而且红格子上的数字为0，这时他就必败了，←也就是说如果他在红格子前无路可走了，就**必败**，有没有发现如果我们把**最后一个格子删去**，将红色格子作为最后一个格子，**与原问题是完全等价的**，在这种情况下必败，那么原问题就必败。


2. 如果最后一个格子是奇数
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191113193130478.png)


那么有没有发现如果，我们跳到绿色格子上就**必败**了，因为你的对手完全可以把它跳到最后一个格子，然后根据上面的结论我们就输了，So，作为一个智商正常的人，都不会往绿色各自上跳——除非在红色格子上我们无路可走了——我们就不得不跳到一个绿色格子上。如果我们把绿色部分之后的全部删去，把红色格子作为最后一个格子，那么依然**与原问题等价**。

总结一波：我们**从后往前**考虑每个格子的奇偶性：

如果这个格子是**偶数**那么跳到这个格子上就是**必败态**，如果这个格子是奇数，那么跳到这个格子上我们就必胜了，跳到它前面的m个格子我们就必败了，然后继续考虑从这个奇数格子往前数（m+1）个的格子。

对于每一个询问，我们从终点往前模拟，得到了该询问区间内每个格子的胜负状态，答案如何判断涅？

我们可以这样想：先手从左端点出发，就相当于后手先跳到了左边第一个格子，So，我们得到第一个格子的状态，也就是后手的胜负状态取个反就欧了。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=1000006;

int a[maxn],cnt[maxn];

int n,m,q,type;

int query(int l,int r){
	if (l>r) swap(l,r);
	int pos=r;
	for(;;){
		pos-=cnt[pos];
		if (pos==l) return 0;
		if (pos<l) return 1;
		pos-=m+1;
	}
	return 1;
}

int A,B,C,P;
inline int rnd(){return A=(A*B+C)%P;}

int main(){
	scanf("%d%d%d%d",&n,&m,&q,&type);
	for (int i=1;i<=n;i++) scanf("%d",&a[i]);
	for (int i=1;i<=n;i++){
		if (a[i]%2==1) cnt[i]=0;
		else cnt[i]=cnt[i-1]+1;
	}
	long long ans=0;
	if (!type){
		for (int i=1;i<=q;i++){
			int l,r;
			scanf("%d%d",&l,&r);
			if (query(l,r)) (ans+=1ll*i*i)%=(1ll<<32);
		}
	}
	else{
		scanf("%d%d%d%d",&A,&B,&C,&P);
		for (int i=1;i<=q;i++){
			int l=rnd()%n+1,r=rnd()%n+1;
			if (query(l,r)) (ans+=1ll*i*i)%=(1ll<<32);
		}
	}
	cout<<ans;
	return 0;
}
```

妙啊，复杂度是——O(qn)!!!

哦，55分了，我们开始优化：

---

**如果左端点是偶数**，后手一定必败（因为只有奇数的格子才有可能必胜），这种情况就不需要讨论了

**如果左端点是奇数**，那我们就要看这个奇数有没有被其他的奇数覆盖成后手必败态，我们不能从结尾开始模拟，So，我们考虑建一棵树：


对于某一个奇数：我们让这个奇数和在这个奇数左边第一个不会被它覆盖的奇数之间连一条边，让这个奇数成为它左边奇数的儿子，如果某个奇数左边没有不会被他覆盖的奇数了，那我们就让他成为0的儿子。

于是乎，就出现了一个很显然的事情，一条从根节点到叶子节点的路径上的奇数，是不会被覆盖的，如果一个节点不会被另一个节点覆盖，那么他们之间必定是祖先关系。

总结一波：对于堆询问$[l,r]$如果左端点是偶数，先手直接必胜；如果左端点是奇数，我们就看右端点左边第一个奇数和左端点在树上是不是祖先关系就欧了！（如果是祖先关系先手必败，否则先手必胜）

那么祖先关系如何判断捏？——**时间戳**

也就是记录树上每个节点入栈和出栈的时间，看着两个节点的出入栈时间是否是包含关系就欧了！

OK，完事

---
c++代码：


```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=1000005;

struct Edge{
	int next,to;
}edge[maxn*2];

int n,m,q,type,cnt,nedge=0;
int head[maxn],a[maxn],pre[maxn],tin[maxn],tout[maxn];

int A,B,C,P;
inline int rnd(){return A=(A*B+C)%P;}

void addedge(int a,int b){
	edge[nedge].next=head[a];
	edge[nedge].to=b;
	head[a]=nedge++;
}

void dfs(int u,int fa){
	tin[u]=++cnt;
	for (int i=head[u];i!=-1;i=edge[i].next){
		int v=edge[i].to;
		if (v==fa) continue;
		dfs(v,u);
	}
	tout[u]=cnt;
}

int query(int l,int r){
	if (l>r) swap(l,r);
	if (a[l]%2==0) return 1;
	r=pre[r];
	return !(tin[l]<=tin[r] && tout[l]>=tout[r]); 
}

int main(){
	memset(head,-1,sizeof(head));
	scanf("%d%d%d%d",&n,&m,&q,&type);
	for (int i=1;i<=n;i++) scanf("%d",&a[i]);
	for (int i=1;i<=n;i++){
		if (a[i]%2==1) pre[i]=i;
		else pre[i]=pre[i-1];//pre[i]表示i前第一个奇数
	} 
	for (int i=1;i<=m;i++){
		if(a[i]%2==0)continue;
		addedge(0,i);
	}
	for (int i=m+1;i<=n;i++){
		if (a[i]%2==0) continue;
		addedge(pre[i-m-1],i);
	}
	dfs(0,0);
	long long ans=0;
	if (!type){
		for (int i=1;i<=q;i++){
			int l,r;
			scanf("%d%d",&l,&r);
			if (query(l,r)) (ans+=1ll*i*i)%=(1ll<<32);
		}
	}
	else{
		scanf("%d%d%d%d",&A,&B,&C,&P);
		for (int i=1;i<=q;i++){
			int l=rnd()%n+1,r=rnd()%n+1;
			if (query(l,r)) (ans+=1ll*i*i)%=(1ll<<32);
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Thaumaturge (赞：1)

前排～

这题其实蛮基础的。。。反正月赛我永远只会div2前三题qwq

题目讲解也不是很清楚。。。

首先，这是一道博弈论题，所以当然要考虑sg函数之类的东西。我们先从奇偶性下手，从前往后推，设当前点sg函数表示先手能否胜利的情况。

每个点一开始都会-1，这就恰好对应了先手将一个棋子挪到某个位置后，这个位置上的数-1，然后换先手后手顺序的情况，更方便我们讨论

另当前点序号为$i$，如果当前点上的数是偶数，显然，如果区间$[i+1,i+m]$上有必败态，我们就可以跳到这个点上，从而使当前点必胜。如果没有，即全为必胜态，我们就可以跳在当前点上，从而将当前点的奇偶性互换，给后手留一个必败态。（如果在当前点反复跳，显然先手会取掉当前点的最后一个数，造成后手必败）

所以，偶数点的$sg$肯定是$1$。那么奇数点的呢？

我们再来考虑：奇数点必胜，当且仅当$[i+1,i+m]$存在必败态。

由于偶数都是必胜的，对于一个询问区间，我们可以找到最靠右的一个奇数点，这个点显然必败，那么这个点会造成前m个点都必胜，也就是说，下一个必败点就是$[1,i-m-1]$中的最靠右的一个奇数点。

如果$l$是偶数点，就必胜，否则，根据上面的结论，只有当$r$跳奇数点，跳不到$l$时，$l$必胜。

那么呢？就有了题解中的“暴力做法”：我们直接从$r$开始，令$g[i]$表示$[1,i]$中最靠右的奇数点的位置，则我们可以直接这样跳：先从$r$跳至$g[r]$，再$i=g[i-m-1]$不停地跳，如果跳过了$l$（也即没有经过$l$），那么$l$点就必胜了。

考虑优化，可以倍增跳点，这样就能把下限复杂度优化到$O(qlogn)$

但是呢。。。

冷静分析一波，发现事实比想象的简单到不知道哪里去了

我们可以根据g数组构造出一棵树，那么，跳点的过程就相当于查询$l$是否是$r$的祖先

用$dfs$序判断就好了

上代码：

```cpp
/*************************************************************************
	> File Name: T3.cpp
	> Author: The-Out-Land
	> Mail: 2264454706@qq.com 
	> Created Time: 2019年11月13日 星期三 14时51分32秒
 ************************************************************************/

#include <bits/stdc++.h>

#define enter putchar('\n')
#define space putchar(' ')
#define N 1000100
#define M 2000100
#define re register

using namespace std;

const long long mod=0x100000000;

int a[N];

int ver[M],nex[M],head[N],nu,dfn[N],low[N],cnt;

inline void add(int x,int y){
	ver[++nu]=y,nex[nu]=head[x],head[x]=nu;
	return;
}

inline int read(){
	int x=0;char c=getchar();bool y=1;
	for(;c<'0' || c>'9';c=getchar()) if(c=='-') y=0;
	for(;c>='0' && c<='9';c=getchar()) x=(x<<1)+(x<<3)+c-48;
	if(y) return x;
	return -x;
}

int A,B,C,P;

int n,m,q,type;

int x1,x2;

long long ans;

//int f[N][inf+1];

int g[N];

inline int rnd(){
	return A=(A*B+C)%P;
}

void dfs(int x,int fx){
	dfn[x]=++cnt;
	for(int i=head[x];i;i=nex[i]){
		int y=ver[i];
		if(y==fx) continue;
		dfs(y,x);
	}
	low[x]=cnt;
	return;
}

inline void Input(){
	n=read(),m=read(),q=read(),type=read();

	g[0]=n+1;

	for(re int i=1;i<=n;++i){
		a[i]=read();
		if(a[i]&1) g[i]=i;
		else g[i]=g[i-1];
		
		if(i>m)
		add(g[i-m-1],i);
		else add(n+1,i);
	}

	dfs(n+1,n+1);

	return;
}

inline void solve(){
	if(type)
	A=read(),B=read(),C=read(),P=read();
	for(re int i=1;i<=q;++i)
	{
		if(type) {x1=rnd()%n+1,x2=rnd()%n+1;}
		else	x1=read(),x2=read();
		if(x1>x2) swap(x1,x2);
		
		bool judge=0;

		if(a[x1]&1)
		{
			x2=g[x2];
			if(x2!=x1)
			if(!(dfn[x1]<=dfn[x2] && dfn[x2]<=low[x1])) judge=1;
		}
		else 
		judge=1;

		ans=(ans+1ll*judge*i*i)%mod;
	}
	printf("%lld\n",ans);
	return;
}

signed main(){
	Input();
	solve();
	return 0;
}
```

---

## 作者：xht (赞：0)

首先只跟 $a$ 的奇偶性有关。

其次如果 $a_l$ 为偶数则先手必胜。

否则 $l \sim r$ 中最右边的一个先手必败的位置一定是最右边的奇数位置，而它上一个先手必败的位置一定是这个位置的 $m$ 个位置以前的最右边的奇数位置，依次类推。

可以发现这个关系形成一个树形结构，那么判断最右边的奇数位置在不在 $l$ 的子树中即可，可以用 dfs 序判断。

```cpp
const ui N = 1e6 + 7;
int n, m, q, o, a[N], p[N], L[N], R[N], num, A, B, C, P;
ui ans;
vector< int > e[N];

inline int rnd() {
	return A = (A * B + C) % P;
}

void dfs(int x) {
	L[x] = ++num;
	for (ui i = 0; i < e[x].size(); i++) dfs(e[x][i]);
	R[x] = num;
}

int main() {
	rd(n), rd(m), ++m, rd(q), rd(o);
	for (int i = 1, j = 0; i <= n; i++) {
		rd(a[i]), a[i] &= 1;
		if (a[i]) {
			j = i;
			e[p[Max(0,i-m)]].pb(i);
		}
		p[i] = j;
	}
	dfs(0);
	if (o) rd(A), rd(B), rd(C), rd(P);
	for (int i = 1; i <= q; i++) {
		int l, r;
		if (o) {
			l = rnd() % n + 1, r = rnd() % n + 1;
			if (l > r) swap(l, r);
		} else rd(l), rd(r);
		if (!a[l] || L[l] > L[p[r]] || L[p[r]] > R[l]) ans += 1ll * i * i;
	}
	print(ans);
	return 0;
}
```

---

## 作者：TEoS (赞：0)

写的第一道博弈论题，也是CSP2019前最后一道博弈论题，写篇题解纪念一下

~~根据这道题的说法，这道题有填数游戏难度~~ 实际上还是不太难的

之前没有写过博弈论题，不知道该怎么推，现在大概知道了个基础，感谢洛谷月赛



------------
**题意分析**

给出一排石子堆，每次只能取一个石子，并且每次只能从当前堆取或者从之后的$m$堆取，给出多个石子堆区间，判断该区间是否先手必胜。

（~~实际上讲题人的PPT说的也是石子~~）

**思路分析**

很容易看出，对于给定区间的最后一堆石子，如果是奇数，则这堆石子是先手必胜；如果是偶数，则这堆石子是先手必败。以此类推，只有奇数石子的堆可能是先手必胜。

因为每个奇数石子的堆都可能是先手必胜，思考一下，对于一个先手必胜的堆$i$，$[i-m,i-1]$显然都是先手必败，因为后手可以走到$i$对形成必胜局面。而$i$前面的第一个先手必胜堆，就是$i-m$堆之前的第一个奇数石子的堆。

**具体实现**

根据上面的分析，可以看出，对于每一个奇数石子堆，如果它是先手必胜堆，在它之前会对应一些奇数石子堆，它们也是先手必胜堆。若将这些对应的先手必胜堆之间进行连边，可以发现会构成一个树形结构。

如何判断一个区间是先手必胜还是先手必败？显然，区间右端点之前（包括它本身）的第一个奇数石子堆一定是先手必胜堆，然后这个先手必胜堆又对应着它前面的一些奇数石子堆，也就是树上它的祖先节点。因此，我们只需要判断右端点之前的第一个奇数石子堆是否在左端点的子树当中，若在，则该区间先手必胜，不累加答案；若不在，则累加答案。

如何判断一个节点是否在另一个节点的子树当中？按照讲题人的说法，若用倍增，可以拿到90pts的好成绩。但是还有个更高效地方法，就是dfs序。记录每个节点的dfs序$dfn_i$及以其为根的子树大小$siz_i$，则该节点子树的dfs序范围为$[dfn[i],dfn[i]+siz[i]-1]$，判断即可。

最后要注意精度与取模。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define ll long long
using namespace std;
const int N=1e6+100;
int n,m,q,type,tot,num;
int head[N],ver[N],Next[N];
int odd[N],dfn[N],siz[N],a[N];
ll A,B,C,D,P,ans;
bool v[N];
void add(int x,int y)
{
	ver[++tot]=y,Next[tot]=head[x],head[x]=tot;
}
void pre()
{
	for(int i=n;i;i--)
		if(a[i]&1)
			add(odd[max(i-m-1,0)],i);//建树
}
void dfs(int x)
{
	v[x]=1,dfn[x]=++num,siz[x]=1;
	for(int i=head[x];i;i=Next[i])
		if(!v[ver[i]])
			dfs(ver[i]),siz[x]+=siz[ver[i]];
}
ll rnd()
{
	return A=(A*B+C)%D;
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&q,&type);
	P=pow(2,32);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(a[i]&1)
			odd[i]=i;
		else
			odd[i]=odd[i-1];//记录每个节点之前的第一个奇数石子堆
	}
	pre();dfs(0);
	if(type)
	{
		scanf("%lld%lld%lld%lld",&A,&B,&C,&D);
		for(int i=1,l,r;i<=q;i++)
		{
			l=rnd()%n+1,r=rnd()%n+1;
			if(l>r)
				swap(l,r);
			r=odd[r];
			if(dfn[l]>dfn[r] || dfn[l]+siz[l]<=dfn[r])
				ans=(ans+(ll)i*i)%P;
		}
	}
	else
		for(int i=1,l,r;i<=q;i++)
		{
			scanf("%d%d",&l,&r);r=odd[r];
			if(dfn[l]>dfn[r] || dfn[l]+siz[l]<=dfn[r])//判断
				ans=(ans+(ll)i*i)%P;
		}
	printf("%lld",ans);
	return 0;
}
```


---


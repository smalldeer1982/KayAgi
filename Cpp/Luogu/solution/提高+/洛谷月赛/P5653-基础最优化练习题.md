# 基础最优化练习题

## 题目背景

YSGH is our red sun.

## 题目描述

YSGH 有一个数 $x$，初值为 $0$。接下来 $n$ 分钟，每分钟 YSGH 可以给 $x$ 加上整数 $y$，其中 $y \in [-k, k]$，同时 YSGH 需要保证第 $i$ 分钟结束时 $x \le a_i$。

设 $b_i$ 为第 $i$ 分钟结束时 $x$ 的值，现在 YSGH 给你一个 $n$ 个数的序列 $w$，你需要最大化 $\displaystyle \sum_{i = 1}^{n} b_i w_i$。

你只需要输出最大值即可。

## 说明/提示

对于 $10\%$ 的数据，$n \le 10$，$k \le 1$。  
对于 $20\%$ 的数据，$n \le 100$。  
对于 $30\%$ 的数据，$n \le {10}^3$。  
对于 $50\%$ 的数据，$n \le {10}^4$。  
另有 $10\%$ 的数据，$w_i \ge 0$。  
对于 $100\%$ 的数据，$1 \le n \le {10}^6$，$-{10}^6 \le w_i \le {10}^6$，$0 \le a_i \le {10}^8$，$1 \le k \le 100$。

## 样例 #1

### 输入

```
5 1
4 3 2 3 2
5 7 -5 9 -10```

### 输出

```
24```

# 题解

## 作者：CYJian (赞：16)

考虑在第 $i$ 步选择的时候会对后缀都产生影响，所以不妨将 $w_i$ 求后缀和。

令 $S_i = \sum_{j=i}^{n} w_i$，那么如果第 $i$ 次 $x$ 改变了 $l_i$，答案就是 $\sum_{i=1}^{n}S_i \times l_i$

考虑没有 $a_i$ 的限制时，可以直接根据 $S_i$ 是否大于 $0$ 选择 $+k$ 或者 $-k$

如果有了 $a_i$ 的限制，那么就相当于限制了一个 $l_i$ 的前缀和。

考虑到限制都是 $\leq a_i$ 的形式，所以可以考虑每次削减前面选择 $+k$ 的地方。

显然每次选择最小的 $S_i$ 的位置削减是最优的。

那么拿一个堆维护 $S_i$ 以及可以削减的次数 $l_i$ 就好了。

$Code$ :

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int __SIZE = 1 << 18;
char ibuf[__SIZE], *iS, *iT;

#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
#define ri read_int()
#define rl read_ll()
#define FILE(s) freopen(s".in", "r", stdin), freopen(s".out", "w", stdout)

template<typename T>
inline void read(T &x) {
	char ch, t = 0; x = 0;
	while(!isdigit(ch = ge)) t |= ch == '-';
	while(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;
	x = t ? -x : x;
}
inline int read_int() { int x; return read(x), x; }
inline ll read_ll() { ll x; return read(x), x; }

const int MAXN = 1000010;

ll w[MAXN];
int a[MAXN];

struct Node {
	ll w;
	int k;

	Node() {}
	Node(ll w, int k):w(w), k(k) {}

	friend bool operator < (Node a, Node b) { return a.w < b.w; }
	friend bool operator > (Node a, Node b) { return a.w > b.w; }
};

priority_queue<Node, vector<Node>, greater<Node> >q;

int main() {
#ifndef ONLINE_JUDGE
	FILE("d");
#endif
	int n = ri, k = ri;
	for(int i = 1; i <= n; i++) a[i] = ri;
	for(int i = 1; i <= n; i++) w[i] = ri;
	for(int i = n; i >= 1; i--) w[i] += w[i + 1];
	int x = 0; ll res = 0;
	for(int i = 1; i <= n; i++) {
		if(w[i] > 0) res += k * w[i], q.push(Node(w[i], k << 1)), x += k;
		else res -= k * w[i], x -= k;
		int c = x - a[i]; x = min(x, a[i]);
		while(c > 0 && !q.empty()) {
			Node x = q.top(); q.pop();
			int t = min(c, x.k);
			res -= t * x.w;
			c -= t, x.k -= t;
			if(x.k) q.push(x);
		}
	} cout << res << endl;
	return 0;
}
```

---

## 作者：xht (赞：10)

首先不考虑 $a$ 的限制，那么一个位置是加是减取决于这个位置对答案的贡献是正是负，而对答案的贡献显然为 $w$ 的后缀和。

再考虑 $a$ 的限制，如果一个位置超出了限制，则应该不断地从之前贡献最小的位置减掉贡献，直到不超出，用一个堆维护即可。

时间复杂度 $\mathcal O(n \log n)$。

```cpp
const int N = 1e6 + 7;
int n, k, a[N], now;
ll b[N], ans;
pq< pi > q;

int main() {
	rd(n), rd(k);
	for (int i = 1; i <= n; i++) rd(a[i]);
	for (int i = 1; i <= n; i++) rd(b[i]);
	for (int i = n; i; i--) b[i] += b[i+1];
	for (int i = 1; i <= n; i++) {
		if (b[i] >= 0) now += k, ans += k * b[i], q.push(mp(-b[i], k << 1));
		else now -= k, ans -= k * b[i];
		while (now > a[i]) {
			pi o = q.top();
			q.pop();
			int w = Min(o.se, now - a[i]);
			now -= w, ans += w * o.fi;
			if ((o.se -= w)) q.push(o);
		}
	}
	print(ans);
	return 0;
}
```

---

## 作者：加藤惠 (赞：10)

每次可以加上一个负数看上去不是很好做，我们转化一下使得每次加的数为非负数，这个只要把每次操作改成先加上$-k$，再加一个一个$[0,2k]$的数就行，每个$a_i$也应该加上$i*k$，接下来说的都是已经转化后的问题。

然后可以再用单调栈处理出每个点的真实的$a_i$，因为现在只能加一个非负数，所以如果$i$后面有一个$a_j$小于$a_i$，显然$b_i$应该也要满足小于等于$a_j$。

然后我们再来看答案的柿子：
$$
\sum_{i=1}^{n}b_iw_i
$$
差分一下:
$$
\sum_{i=1}^{n}b_iw_i
=\sum_{i=1}^{n}(\sum_{j=1}^{i}b_j-b_{j-1})w_i
=\sum_{i=1}^{n}(b_i-b_{i-1})\sum_{j=i}^{n}w_j
$$
设$c_i=b_i-b_{i-1} ,suf_i=\sum_{j=i}^{n}w_j$
$$
\sum_{i=1}^{n}b_i\sum_{j=i}^{n}w_j
=\sum_{i=1}^{n}c_isuf_i
$$
当然对于每个$i\in[1,n]$都还应该满足$\sum_{j=1}^{i}c_j<=a_i,c_i\in[0,2k]$

接下来考虑贪心一波，$suf_i$大的对应的$c_i$肯定也要尽可能大嘛，$suf_i$是负数的话对应的$c_i$就应该为$0$，于是我们按$suf_i$从大到小$sort$，每次算出$c_i$能取到的最大值，具体可以通过线段树维护后缀$min$实现，时间复杂度$O(nlogn)$，然后这个题就做完了。

```cpp
#include<bits/stdc++.h>
#define For(i,x,y) for (register int i=(x);i<=(y);i++)
#define FOR(i,x,y) for (register int i=(x);i<(y);i++)
#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)
#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define siz(x) ((int)(x).size())
#define all(x) (x).begin(),(x).end()
#define fil(a,b) memset((a),(b),sizeof(a))
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pa;
inline ll read(){
    ll x=0,f=1;char c=getchar();
    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();
    if (c=='-') f=-1,c=getchar();
    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
    return x*f;
}

const int N = 1e6+10;
int n,m,top,stk[N],pos[N];
ll ans,suf[N],a[N],w[N],lim[N];

struct SegmentTree{
	ll t[N<<2],lazy[N<<2];
	inline void push_up(int u){t[u]=min(t[u<<1],t[u<<1^1]);}
	inline void upd(int u,double x){t[u]+=x,lazy[u]+=x;}
	inline void push_down(int u){if (lazy[u]!=0) upd(u<<1,lazy[u]),upd(u<<1^1,lazy[u]),lazy[u]=0;}
	inline void Build(int u,int l,int r){
		if (l==r) return t[u]=lim[l],void(0);
		int mid=l+r>>1;Build(u<<1,l,mid),Build(u<<1^1,mid+1,r);
		push_up(u);
	}
	inline void update(int u,int l,int r,int ql,int qr,int x){
		if (l>=ql&&r<=qr) return upd(u,x),void(0);
		int mid=l+r>>1;push_down(u);
		if (ql<=mid) update(u<<1,l,mid,ql,qr,x);
		if (qr>mid) update(u<<1^1,mid+1,r,ql,qr,x);
		push_up(u);
	}
	inline ll Query(int u,int l,int r,int ql,int qr){
		if (l>=ql&&r<=qr) return t[u];
		int mid=l+r>>1;push_down(u);
		if (qr<=mid) return Query(u<<1,l,mid,ql,qr);
		if (ql>mid) return Query(u<<1^1,mid+1,r,ql,qr);
		return min(Query(u<<1,l,mid,ql,qr),Query(u<<1^1,mid+1,r,ql,qr));
	}
}seg;

int main(){
	n=read(),m=read();
	For(i,1,n) a[i]=read()+1ll*i*m;
	For(i,1,n) w[i]=read(),ans+=(-1ll*i*m)*w[i];
	For(i,1,n){
		while (top&&a[stk[top]]>=a[i]) --top;
		stk[++top]=i;
	}
	For(i,1,top)
		For(j,stk[i-1]+1,stk[i]) lim[j]=a[stk[i]];
	Dow(i,n,1) suf[i]=suf[i+1]+w[i],pos[i]=i;
	sort(pos+1,pos+1+n,[](int a,int b){
		return suf[a]>suf[b];
	});
	seg.Build(1,1,n);
	For(i,1,n){
		if (suf[pos[i]]<=0) break;
		int x=min(seg.Query(1,1,n,pos[i],n),2ll*m);
		ans+=suf[pos[i]]*x,seg.update(1,1,n,pos[i],n,-x);
	}
	printf("%lld\n",ans);
}
```

---

## 作者：bessie_goes_moo (赞：3)

本题大意：构造一个数组$bi$，其两两差值不超过$k$，并满足任意$bi<ai$

由此，我们设第i分钟我们加上的值为$ci∈[-k,k]$

那么答案$Ans=∑ci∑wj |i∈[1,n],j∈[i,n]$

记当前i~n $wj$的和为$Si$

当$Si$小于0的时候，由于他对答案的贡献为负，我们直接把这里的$ci$置为$-k$，这样显然是最优的，且不会让当前$bi$增加

当$Si$大于0的时候，由于他对答案的贡献为正，我们先把这里的$ci$置为$k$

经过上面两类操作后，此时的$b=∑ci$，有可能小于题目所给定的$a$,显然前面某步的$ci$多了，需要扣掉，扣那些$ci$呢？显然是扣$Si$小的$ci$(注意此时扣的$Si$为正，因为负的我们已经不能再扣了)，那么维护一个小根堆，每次需要扣的时候去扣

还有个小细节，每个$ci$最小值为$-k$，也就是我们最多把一个$ci=k$扣掉$2k$，也就是为什么我put((Node){S[i],k+k})

至于复杂度，每一次放入一个点，get操作最多做2N次，为$nlogn$

附代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;
typedef long long LL;
struct IO{
	static const int S=1<<21;
	char buf[S],*p1,*p2;int st[105],Top;
	~IO(){clear();}
	inline void clear(){fwrite(buf,1,Top,stdout);Top=0;}
	inline void pc(const char c){Top==S&&(clear(),0);buf[Top++]=c;}
	inline char gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
	IO&operator >> (char&x){while(x=gc(),x==' '||x=='\n');return *this;}
	template<typename T> IO&operator >> (T&x){
		x=0;bool f=0;char ch=gc();
		while(ch<'0'||ch>'9'){if(ch=='-') f^=1;ch=gc();}
		while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=gc();
		f?x=-x:0;return *this;
	}
	IO&operator << (const char c){pc(c);return *this;}
	template<typename T> IO&operator << (T x){
		if(x<0) pc('-'),x=-x;
		do{st[++st[0]]=x%10,x/=10;}while(x);
		while(st[0]) pc('0'+st[st[0]--]);return *this;
	}
}fin,fout;
int n,k,now,a[maxn],w[maxn],len;
LL S[maxn],Ans;
struct Node{
	LL x,y;
	bool operator <(const Node b)const{return x<b.x;}
}hep[maxn];
inline void put(Node x){
	hep[++len]=x;int son=len;
	while(son>1&&hep[son]<hep[son>>1]) swap(hep[son],hep[son>>1]),son>>=1;
}
inline Node get(){
	Node res=hep[1];hep[1]=hep[len--];int fa=1,son;
	while((fa<<1)<=len){
		if((fa<<1|1)>len||hep[fa<<1]<hep[fa<<1|1]) son=fa<<1;else son=fa<<1|1;
		if(hep[son]<hep[fa]) swap(hep[fa],hep[son]),fa=son;else break;
	}
	return res;
}
int main(){
	fin>>n>>k;
	for(int i=1;i<=n;i++) fin>>a[i];
	for(int i=1;i<=n;i++) fin>>w[i];
	for(int i=n;i;i--) S[i]=S[i+1]+w[i];
	for(int i=1;i<=n;i++){
		if(S[i]>0) now+=k,Ans+=k*S[i],put((Node){S[i],k+k});
		else now-=k,Ans-=k*S[i];
		while(now>a[i]){
			Node x=get();
			if(x.y>(now-a[i])) x.y-=(now-a[i]),Ans-=x.x*(now-a[i]),now=a[i],put(x);
			else now-=x.y,Ans-=x.x*x.y;
		}
	}
	fout<<Ans;
	return 0;
}
```


---

## 作者：MuelsyseU (赞：0)

也算是一个套路了。

我们对于限制类问题，考虑去除限制之后是不是具有显然的最优解。然后考虑调整这个解去满足限制。

而关于调整，考虑若每次调整都具有必要性，那么就可以正确。进而每次调整再进行贪心，就得到最优解。

具体到本题，显然 $b_i=\sum^i_{j=1} a_j$，把 $a_i$ 从前缀和中拆出容易得到无限制情形下 $a_i$ 根据其后缀和，仅有 $k,-k$ 两种取值。

然后考虑这些限制，因为是前缀和的上界限制，所以从前往后满足就具有必要性。对于满足限制，可以发现就是要使得之前的数增加上一个整数，这一增加无论如何都具有负的贡献；在一个位置加上 $-1$ 的贡献都只是乘上其后缀和。

故维护最小后缀和的位置，使其 $a$ 减小。若减小到下界，就需要支持 `extract`，可用堆维护。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1000005;
int n, a[maxn], v[maxn];
long long k, sum, w[maxn], ans;
priority_queue<pair<long long, int> > q;
signed main() {
	scanf("%d%lld", &n, &k);
	for (int i = 1; i <= n; ++i) scanf("%d", a + i);
	for (int i = 1; i <= n; ++i) scanf("%lld", w + i);
	for (int i = n; i >= 1; --i) w[i] += w[i + 1], v[i] = (w[i] >= 0 ? k : -k), ans += v[i] * 1ll * w[i];
	for (int i = 1; i <= n; ++i) {
		long long val = sum + v[i];
		if (w[i] > 0) q.emplace(-w[i], i);
		while (val > a[i] && !q.empty()) {
			int j = q.top().second;
			long long t = v[j] - (-k);
			q.pop();
			long long tmp = min(t, val - a[i]);
			val -= tmp, v[j] -= tmp, ans -= tmp * w[j];
			if (v[j] > -k) q.emplace(-w[j], j);
		}
		sum = min(val, a[i] * 1ll);
	}
	printf("%lld", ans);
	return 0;
}
```

---


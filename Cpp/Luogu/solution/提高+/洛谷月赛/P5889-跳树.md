# 跳树

## 题目背景

兔子喜欢跳树。

## 题目描述

一天，兔子在一棵点数为 $2^n-1$ 完全二叉树上的一个结点上，他准备进行若干次如下的跳跃。

- 跳到这个点的左儿子，保证这个点有左儿子。
- 跳到这个点的右儿子，保证这个点有右儿子。
- 跳到这个点的父亲，**若这个点是根，无视此操作**。

其中，$i$ 号点要么没有儿子，要么有左儿子 $2 \times i$ 和右儿子 $2 \times i + 1$。

兔子会计划性地跳树，他写下了一个长度为 $m$ 的序列 $op$。$op$ 中的每个数都是 $1$, $2$, $3$ 中的一种。操作 $i$ 对应从上到下第 $i$ 种跳跃方式。

每次，兔子会选择一段区间 $[l,r]$，依次进行跳跃 $op_l,op_{l+1},\ldots,op_r$。

有时兔子会对一个点的 $op$ 值进行修改。

现在你需要求出兔子每次会跳到哪个结点。

阅读样例解释可以对题意获得更好的理解。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/jxigowfv.png)

其中红边为第一次跳跃的路径，蓝边为第二次，绿边为第三次。

所有测试数据的范围和特点如下表所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/lost2xr2.png)

对于 $100\%$ 的数据，$1\leq n \leq 30$，$1\leq m,q \leq  5 \times 10^5$，$1\leq op_i\leq 3$。

## 样例 #1

### 输入

```
3 5 4
1 2 3 3 1
1 3 4 5
1 2 2 4
2 3 1
1 1 2 3```

### 输出

```
2
1
6```

# 题解

## 作者：4SunnyH (赞：30)

### [P5889 跳树](https://www.luogu.com.cn/problem/P5889) 

------------
首先大致读一下题，不难发现，每个点的**二进制编码**就是**从$1$号节点到这个节点的路径**。  

最高的1代表根节点，之后的0代表左儿子，1代表右儿子，一直走到最低位，就是这个数对应的节点。  

$example$：  
$10$ -> $00001010$  
从$1$开始，后面是“$010$”，也就是“左右左”，画出树来，从$1$开始，左儿子——$2$，右儿子——$5$，左儿子——$10$！  

显然，由任意节点开始到它孩子的路径都可以按 “左$0$右$1$” 的方式表示。

所以，对于树上任意一个编号为$s$的节点，  
操作1：```s=s<<1```  
操作2：```s=(s<<1)+1```  
操作3：```s=s>>1```  

拓展一步，我们可以表示出  
s的n辈祖先：$s>>n$  
and  
s的n代孩子：$(s<<n)+$ **$s$到这个儿子 的路径**  
因为s表示 **$1$到$s$ 的路径**，我们把它左移$n$位（显然$s$到它的$n$代孩子要走$n$步），再加上$s$到这个孩子要走的路径，得到的也就是 **$1$到孩子 的路径**  

------------

我们考虑用线段树做这道题，那么要维护的就是  
**跳过这段区间后，$s$会如何改变**  

对每个区间定义如下：  
```
struct node(){
    int fstl;	//s最高会跳到它的第几辈祖先上
    int l;      //跳到最高祖先后，s会跳到这个祖先的第几代孩子上（终点与最高祖先的深度差）
    ll num;     //祖先-终点 的路径
};
```
即  

$(max(1,s>>fstl)<<l)+num$  

表示跳过这个区间后$s$的位置（取$max$的意义是避免左移运算使代表根节点的$1$消失）

所以，我们可以把每个操作表示为：  
1：```fstl=1;```  
2：```l=1;```  
3：```l=1,num=1;```  


------------

那么，剩下最大的敌人就是**区间合并**了。  
点$s$先跳过区间$a$，再跳过区间$b$的过程是这样的：
```
s>>=a.fstl; //由于这里s并不是真正的点，我们不把它与1取max
s<<=a.l;
s+=a.num;

s>>=b.fstl; //注意这一步，a.num被b.fstl“去”一部分
s<<=b.l;
s+=b.num;
```
由于代码中要多次用到**区间合并**，我们不妨直接**重载运算符**  
```
node operator + (const node &b) const{
```  

**$a.num$在这里有一部分被b“抹去”了，所以我们可以根据它来分类讨论。**  

设区间a和区间b合并后的结果为区间$ans$：  
```
    node ans;
```  

① $a$、$b$中有一个为空，$ans$=另一个  
```
    if(!b.fstl&&!b.l){
        return *this;
    }
    if(!fstl&&!l){
        return b;
    }
```
② $a$、$b$非空，$a.l>b.fstl$，即$a.num$对$ans$产生了影响： 
```
    if(l>b.fstl){
        ans.fstl=fstl;        //b.fstl全部小于a.l，也就是说不能比跳a区间时达到的最高位置更高
        ans.l=l-b.fstl+b.l;   //剩余的a.num长度加上b.num的长度
        ans.num=((num>>b.fstl)<<b.l)+b.num;
    }
```
   
③ $a$、$b$非空，$a.l<=b.fstl$，即$a.num$被$b.fstl$**全部“抹去**”，对$ans$无影响：
  
```
    else{
        ans.fstl=fstl+b.fstl-l;//原有的部分加上b.fstl的剩余部分
        ans.l=b.l;
        ans.num=b.num;
    }
    return ans;
}
``` 

然后套**线段树**模板即可。


------------
# $Code$：
```
//码风清奇见谅
#include<iostream>
#include<cstdio>
using namespace std;
#define N 500007
typedef long long ll;
//线段树常规def
#define ls (rt<<1)
#define rs ((rt<<1)+1)
#define mid (l+r>>1)
#define lson rt<<1,l,l+r>>1
#define rson rt<<1|1,(l+r>>1)+1,r

ll read(){
    //put your 快读 here
}
template<typename Tp>
void print(Tp a){
    //put your 快写 here
}

struct node{//定义区间
    int fstl,l;
    ll num;
    node operator + (const node &b) const{//合并计算
        if(!b.fstl&&!b.l){
            return *this;
        }
        if(!fstl&&!l){
            return b;
        }
        node ans;
        if(l>b.fstl){
            ans.fstl=fstl;
            ans.l=l-b.fstl+b.l;
            ans.num=((num>>b.fstl)<<b.l)+b.num;
        }
        else{
            ans.fstl=fstl+b.fstl-l;
            ans.l=b.l;
            ans.num=b.num;
        }
        return ans;
    }
};

node tree[N*5];//线段树
ll n,m,sz,now;

void build(int rt,int l,int r){//建树
    if(l==r){
        int x=read();
        if(x==1){
            tree[rt].l=1;
        }
        else if(x==2){
            tree[rt].l=1;
            tree[rt].num=1;
        }
        else{
            tree[rt].fstl=1;
        }
        return;
    }
    build(lson);
    build(rson);
    tree[rt]=tree[ls]+tree[rs];
}
void upd(int rt,int l,int r,int pos,int x){//替换
    if(l==r){
        tree[rt]=(node){0,0,0};
        if(x==1){
            tree[rt].l=1;
        }
        else if(x==2){
            tree[rt].l=1;
            tree[rt].num=1;
        }
        else{
            tree[rt].fstl=1;
        }
        return;
    }
    if(pos>mid){
        upd(rson,pos,x);
    }
    else{
        upd(lson,pos,x);
    }
    tree[rt]=tree[ls]+tree[rs];
}
node query(int rt,int l,int r,int s,int t){//查询
    node ans=(node){0,0,0},lans,rans;
    if(l>t||r<s){
        return ans;
    }
    if(s<=l&&r<=t){
        return tree[rt];
    }
    lans=query(lson,s,t);
    rans=query(rson,s,t);
    return lans+rans;
}

int main(){
    sz=read(),n=read(),m=read();
    build(1,1,n);
    int opt,x,y;
    ll s;//这里用int第10个点会爆
    node r;
    while(m--){
        opt=read();
        if(opt&1){
            s=read(),x=read(),y=read();
            r=query(1,1,n,x,y);

            s=(max(1ll,s>>r.fstl)<<r.l)+r.num;
            print(s),putchar('\n');
        }
        else{
            x=read(),y=read();
            upd(1,1,n,x,y);
        }
    }
    return 0;
}
```
#### 萌新第一篇题解，有问题请务必指出，谢谢！

---

## 作者：xht (赞：14)

## 跳树

显而易见的线段树。

每个线段树的节点维护两个信息：

1. 最多向上走的层数。
2. 走到最上之后，若最上面的点为 $1$ 号点，则会走到几号点。

显然这个信息可以 $\mathcal O(1)$ 合并，分类讨论一下即可。

时间复杂度 $\mathcal O((m + q\log m)n)$，常数较小。

```cpp
const int N = 5e5 + 7;
int n, m, q, x, p[37];
struct T {
	int l, r;
	pi x;
} t[N<<2];

inline int get(int x) {
	if (!x) return 0;
	int y;
	while (x) y = x, x -= x & -x;
	return p[y%37];
}

inline pi operator + (pi a, pi b) {
	int o = get(a.se);
	if (b.fi <= o) {
		o = get(b.se);
		return mp(a.fi, ((a.se >>= b.fi) ? a.se : 1) << o | (b.se ^ (1 << o)));
	}
	return mp(a.fi + b.fi - o, b.se);
}

void build(int p, int l, int r) {
	t[p].l = l, t[p].r = r;
	if (l == r)
		return rd(x), t[p].x = x == 3 ? mp(1, 1) : mp(0, x + 1), void();
	build(ls, l, md), build(rs, md + 1, r);
	t[p].x = t[ls].x + t[rs].x; 
}

pi ask(int p, int l, int r) {
	if (t[p].l >= l && t[p].r <= r) return t[p].x;
	pi o = mp(0, 1);
	if (l <= md) o = o + ask(ls, l, r);
	if (r > md) o = o + ask(rs, l, r);
	return o;
}

void chg(int p, int x, int y) {
	if (t[p].l == t[p].r)
		return t[p].x = y == 3 ? mp(1, 1) : mp(0, y + 1), void();
	chg(x <= md ? ls : rs, x, y);
	t[p].x = t[ls].x + t[rs].x;
}

int main() {
	rd(n), rd(m), rd(q);
	for (int i = 0, j = 1; i <= n; i++, j <<= 1) p[j%37] = i;
	build(1, 1, m);
	while (q--) {
		int o;
		rd(o);
		if (o == 1) {
			int s, l, r;
			rd(s), rd(l), rd(r), print((mp(0, s) + ask(1, l, r)).se);
		} else {
			int x, y;
			rd(x), rd(y), chg(1, x, y);
		}
	}
	return 0;
}
```

---

## 作者：lndjy (赞：7)

### P5889 跳树 题解

这题一开始不会，看了 4SunnyH  大佬的题解才明白。我会把他讲的简略的部分讲的详细一点。

### Part 1 结构体定义

定义 l,r 表示这个节点代表的区间（个人习惯）。

df 为跳到第几个祖先，ds 为跳完祖先后跳到几代孩子，num 为每次跳到右儿子节点编号的 +1，第几位是 1 代表第几位是跳到右儿子。

我内置了一个函数，make 表示将一个操作表示为上面的三个值。
```cpp
void make(int i)
{
	if(i==3) df=1;//如果是操作3，那么跳到1级祖先，就是父亲
	if(i<=2) ds=1;//如果操作12，就是跳到儿子
	if(i==2) num=1;//如果操作2，是右儿子，需要记录
}
```
同时重载了运算符，功能和他的一样，就是走过两个区间的影响，这部分他讲的详细我就不说了。

结构体部分代码：
```cpp
struct tree
{
	int l,r;
	int df,ds,num;
	void make(int i)
	{
		if(i==3) df=1;
		if(i<=2) ds=1;
		if(i==2) num=1;
	}
	tree operator + (const tree &p)
	{
		tree ans;
		if(df==0&&ds==0)
		{
			ans=p;
			ans.l=min(l,p.l);
			ans.r=max(r,p.r);
			return ans;
		}
		if(p.df==0&&p.ds==0)
		{
			ans=*this;
			ans.l=min(l,p.l);
			ans.r=max(r,p.r);
			return ans;
		}
		if(ds>p.df)
		{
			ans.df=df;
			ans.ds=ds-p.df+p.ds;
			ans.num=(num>>p.df)<<p.ds;
			ans.num+=p.num;
		}
		else
		{
			ans.df=df+p.df-ds;
			ans.ds=p.ds;
			ans.num=p.num;
		}
		ans.l=min(l,p.l);
		ans.r=max(r,p.r);
		return ans;
	}
}t[2000005];
```
### Part 2 建树
建树部分有两个点。

第一点是到叶节点后进行make函数，把原操作改成维护的值

第二点是pushup直接用之前重载的加号就行。

代码：
```cpp
void build(int l,int r,int k)
{
	t[k].l=l;t[k].r=r;
	if(l==r)
	{
		t[k].make(a[l]);
		return;
	}
	int mid=(l+r)/2;
	build(l,mid,k*2);
	build(mid+1,r,k*2+1);
	t[k]=t[k*2]+t[k*2+1];
}
```
### Part 3 修改 

修改部分可以直接用make函数，但是一定要注意**要先清零！！！**

同时，修改完了记得**pushup**。

```cpp
void change(int p,int k,int v)
{
	if(t[k].l==t[k].r)
	{
		t[k].df=t[k].ds=t[k].num=0;
		t[k].make(v);
		return;
	}
	if(t[k*2].r>=p)
	change(p,k*2,v);
	else
	change(p,k*2+1,v);
	t[k]=t[k*2]+t[k*2+1];
}
```


### Part 4 查询
这题的查询返回值是一个tree结构体。直接重载运算符就可以解决。

只有8行的代码：
```cpp
tree ask(int l,int r,int k)
{
	tree ans=(tree){t[k].l,t[k].r,0,0,0};
	if(l<=t[k].l&&t[k].r<=r) return t[k];
	if(t[k*2].r>=l) ans=ans+ask(l,r,k*2);
	if(t[k*2+1].l<=r) ans=ans+ask(l,r,k*2+1);
	return ans;
}
```
### Part 5 完整代码
```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
int inline read()
{
	int ans=0,f=1;
	char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-')
		f=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		ans=ans*10+ch-'0';
		ch=getchar();
	}
	return ans*f;
}
int n,m,q;
int a[500005];
struct tree
{
	int l,r;
	int df,ds,num;
	void make(int i)
	{
		if(i==3) df=1;
		if(i<=2) ds=1;
		if(i==2) num=1;
	}
	tree operator + (const tree &p)
	{
		tree ans;
		if(df==0&&ds==0)
		{
			ans=p;
			ans.l=min(l,p.l);
			ans.r=max(r,p.r);
			return ans;
		}
		if(p.df==0&&p.ds==0)
		{
			ans=*this;
			ans.l=min(l,p.l);
			ans.r=max(r,p.r);
			return ans;
		}
		if(ds>p.df)
		{
			ans.df=df;
			ans.ds=ds-p.df+p.ds;
			ans.num=(num>>p.df)<<p.ds;
			ans.num+=p.num;
		}
		else
		{
			ans.df=df+p.df-ds;
			ans.ds=p.ds;
			ans.num=p.num;
		}
		ans.l=min(l,p.l);
		ans.r=max(r,p.r);
		return ans;
	}
}t[2000005];
void build(int l,int r,int k)
{
	t[k].l=l;t[k].r=r;
	if(l==r)
	{
		t[k].make(a[l]);
		return;
	}
	int mid=(l+r)/2;
	build(l,mid,k*2);
	build(mid+1,r,k*2+1);
	t[k]=t[k*2]+t[k*2+1];
}
void change(int p,int k,int v)
{
	if(t[k].l==t[k].r)
	{
		t[k].df=t[k].ds=t[k].num=0;
		t[k].make(v);
		return;
	}
	if(t[k*2].r>=p)
	change(p,k*2,v);
	else
	change(p,k*2+1,v);
	t[k]=t[k*2]+t[k*2+1];
}
tree ask(int l,int r,int k)
{
	tree ans=(tree){t[k].l,t[k].r,0,0,0};
	if(l<=t[k].l&&t[k].r<=r) return t[k];
	if(t[k*2].r>=l) ans=ans+ask(l,r,k*2);
	if(t[k*2+1].l<=r) ans=ans+ask(l,r,k*2+1);
	return ans;
}
signed main()
{
	n=read();m=read();q=read();
	for(int i=1;i<=m;i++)
	a[i]=read();
	build(1,m,1);
	for(int i=1;i<=q;i++)
	{
		int op=read(),a=read(),b=read(),c;
		if(op==1)
		{
			c=read();
			tree now=ask(b,c,1);
			a>>=now.df;
			a=max(a,1ll);
			a<<=now.ds;
			a+=now.num;
			cout<<a<<'\n'; 
		}
		else
		change(a,1,b);
	}
	return 0;
}
```


---

## 作者：zzy2333 (赞：7)

在看了 @xht37 的题解之后恍然大悟，其实再加点优化就可以把复杂度里的 $n$ 给去掉了。。。

于是决定写一篇更详细的题解，这题的思路十分巧妙

看到序列题，首先想到线段树

先确定几个变量:
```cpp
	int minsum;//从l开始的最小前缀和(1,2->1,3->-1)
	int k;
	int change;//操作等价于先走k级祖先然后再走等价0/1串(左->0,右->1) change表示等价01串
	int len;//change的实际长度 
	int point;//如果在最小前缀和处走到根节点则最终会走到哪 
```
$minsum$很好合并，和区间最大子段和是一样的

其他操作呢

首先，如果不考虑走到根节点的情况，也就是先不考虑$point$该怎么合并,我们可以把操作进行等价

$ 1->x=(x<<1) $

$ 2->x=(x<<1|1) $

$ 3->x=(x>>1) $ 

于是我们可以用位运算来实现合并（为了方便，我是通过重载运算符来实现合并的）:
```cpp
node operator +(const node &x)const{
		node ret;
		ret.l=l;
		ret.r=x.r;
		ret.sum=sum+x.sum;
		if(x.k>len){//如果走完左右儿子之后又走回来了
			int tok=k+x.k-len;//相当于向上多走了x.k-len步
			ret.k=tok;
			ret.change=x.change;//走完以后按照右节点的01串走
			ret.len=x.len;
		}
		else{
			int tolen=len-x.k+x.len;//先往上走k步，再往下走
			int tochange=(change>>x.k);//往上走k步
			tochange=((tochange<<x.len)|x.change);//往下走
			ret.len=tolen;
			ret.change=tochange;
			ret.k=k;
		}
		return ret;
}
```
现在考虑合并 $point$

我们平常合并 $minsum$ 是这么合并

```cpp
ret.minsum=min(minsum,sum+x.minsum);
```
如果当前操作过程会让节点走到根，两种情况分别对应在左子节点操作后已经走到根，而且没有回到根，和在进行完左子节点的操作后在右子节点的操作中再次走到根

弄明白这个，合并就很显然了

```cpp
		if(sum+x.minsum<minsum){
			ret.minsum=sum+x.minsum;
			ret.point=x.point;//在右子节点走到根，直接继承右子节点的point
		}
		else{
			ret.minsum=minsum;
			ret.point=(((point>>x.k)<<x.len)|x.change);//和之前合并change一个道理
		}
```

单点修改是基本线段树操作

询问时，查询一下 $l$ 到 $r$ 线段树节点的并

设 $s$ 的深度为 $deep$ (根节点为0)

如果 $minsum\leq -deep$ 那么说明曾经走到过根(往上走 $deep-=1$ ),输出 $point$

否则，按照之前合并$point$的方法，输出 $((s>>k)<<len)|change$

代码写的比较长，其实很多东西是写复杂了的，实际上应该100行左右就能解决

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,q;
int a[500010];
struct node{
	int l;
	int r;
	int sum;
	int minsum;//从l开始的最小前缀和(1,2->1,3->-1)
	int k;
	int change;//操作等价于先走k级祖先然后再走等价0/1串(左->0,右->1) 
	int len;//总操作长 
	int point;//如果走到根节点则最终会走到哪 
	node operator +(const node &x)const{
		node ret;
		ret.l=l;
		ret.r=x.r;
		ret.sum=sum+x.sum;
		if(sum+x.minsum<minsum){
			ret.minsum=sum+x.minsum;
			ret.point=x.point;
		}
		else{
			ret.minsum=minsum;
			ret.point=(((point>>x.k)<<x.len)|x.change);
		}
		if(x.k>len){
			int tok=k+x.k-len;
			ret.k=tok;
			ret.change=x.change;
			ret.len=x.len;
		}
		else{
			int tolen=len-x.k;
			int tochange=(change>>x.k);
			tochange=((tochange<<x.len)|x.change);
			tolen+=x.len;
			ret.len=tolen;
			ret.change=tochange;
			ret.k=k;
		}
		return ret;
	}
}tree[2000010];
void build(int now,int l,int r){
	tree[now].l=l;
	tree[now].r=r;
	if(l==r){
		if(a[l]==1){
			tree[now].minsum=tree[now].sum=1;
			tree[now].len=1;
			tree[now].k=0;
			tree[now].change=0;
			tree[now].point=1;
		}
		else if(a[l]==2){
			tree[now].minsum=tree[now].sum=1;
			tree[now].len=1;
			tree[now].k=0;
			tree[now].change=1;
			tree[now].point=1;
		}
		else{
			tree[now].minsum=tree[now].sum=-1;
			tree[now].len=0;
			tree[now].k=1;
			tree[now].change=0;
			tree[now].point=1;
		}
		return;
	}
	int mid=(l+r)/2;
	build(now*2,l,mid);
	build(now*2+1,mid+1,r);
	tree[now]=tree[now*2]+tree[now*2+1];
//	cout<<"#"<<l<<" "<<r<<endl;
//	cout<<tree[now].point<<" "<<tree[now].change<<endl;
}
void change(int now,int x){
	int l=tree[now].l;
	int r=tree[now].r;
	if(l==r&&l==x){
		if(a[x]==1){
			tree[now].minsum=tree[now].sum=1;
			tree[now].len=1;
			tree[now].k=0;
			tree[now].change=0;
		}
		else if(a[x]==2){
			tree[now].minsum=tree[now].sum=1;
			tree[now].len=1;
			tree[now].k=0;
			tree[now].change=1;
		}
		else{
			tree[now].minsum=tree[now].sum=-1;
			tree[now].len=0;
			tree[now].k=1;
			tree[now].change=0;
		}
		return;
	}
	int mid=(l+r)/2;
	if(x<=mid){
		change(now*2,x);
	}
	else{
		change(now*2+1,x);
	}
	tree[now]=tree[now*2]+tree[now*2+1];
}
node query(int now,int x,int y){
	int l=tree[now].l;
	int r=tree[now].r;
	if(l==x&&r==y){
		return tree[now];
	}
	int mid=(l+r)/2;
	if(y<=mid){
		return query(now*2,x,y);
	}
	else if(x>mid){
		return query(now*2+1,x,y);
	}
	else{
		return query(now*2,x,mid)+query(now*2+1,mid+1,y);
	}
}
int main(){
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=m;i++){
		scanf("%d",&a[i]);
	}
	build(1,1,m);
	while(q--){
		int opt;
		scanf("%d",&opt);
		if(opt==1){
			int s,l,r;
			scanf("%d%d%d",&s,&l,&r);
			node now=query(1,l,r);
			int deep=0;
			for(int i=0;i<=30;i++){
				if((s>>i)&1)deep=i;
			}
			if(now.minsum<=-deep){
				printf("%d\n",now.point);
			}
			else{
				printf("%d\n",((s>>now.k)<<now.len)|now.change);
			}
		}
		else{
			int x,y;
			scanf("%d%d",&x,&y);
			a[x]=y;
			change(1,x);
		}
	}
	return 0;
}
```

---

## 作者：LJ07 (赞：5)

若当前点为 $x$。

操作 $1$ 相当于 ```x << 1```，操作 $2$ 相当于 ```x << 1 | 1```，操作 $3$ 相当于 ```x >> 1```。

这样我们就容易发现对于给定的 $s$ 和区间 $[l,r]$，最终答案形式一定是类似 ```(x>>down)<<up|value``` 的形式。

考虑使用线段树。

对于线段树一个节点，维护所管理区间 $[l,r]$ 的 $down,up,value$。

```cpp
struct Node
{
	int dw,up,val;
}tr[M*4+5];
```

然后发现它是可以合并的，联系上面的 答案形式，容易写出合并。

```cpp
Node operator+(Node a,Node b)
{
	Node c;
	c.val=((a.val>>b.dw)<<b.up)|b.val;
	c.dw=a.dw+max(b.dw-a.up,0)；
	c.up=max(a.up-b.dw,0)+b.up;
	return c;
}
```

最后注意到题目给出的根是 $1$，所以最终的答案其实是 ```((max(x>>res.dw,1)<<res.up)|res.val)```

```cpp
#include <bits/stdc++.h>
using namespace std;
const int M(5e5);
int n,m,q,op[M+5];
struct Node
{
	int dw,up,val;
}tr[M*4+5];
Node operator+(Node a,Node b)
{
	Node c;
	c.val=((a.val>>b.dw)<<b.up)|b.val;
	c.dw=a.dw+max(b.dw-a.up,0);
	c.up=max(a.up-b.dw,0)+b.up;
	return c;
}
Node init(int op)
{
	if(op==1) return Node{0,1,0};
	if(op==2) return Node{0,1,1};
	return Node{1,0,0};
}
#define mid (L+R>>1)
#define Ls rt<<1,L,mid
#define Rs rt<<1|1,mid+1,R
#define Ts int rt=1,int L=1,int R=m
void build(Ts)
{
	if (L==R) return tr[rt]=init(op[L]),void();
	build(Ls),build(Rs),tr[rt]=tr[rt<<1]+tr[rt<<1|1];
}
void modify(int p,int k,Ts)
{
	if (L==R) return tr[rt]=init(k),void();
	p<=mid?modify(p,k,Ls):modify(p,k,Rs);
	tr[rt]=tr[rt<<1]+tr[rt<<1|1];
}
void query(int l,int r,Node &res,Ts)
{
	if (l<=L&&R<=r) return res=res+tr[rt],void();
	if (l<=mid) query(l,r,res,Ls);
	if (r>mid) query(l,r,res,Rs);
	tr[rt]=tr[rt<<1]+tr[rt<<1|1];
}
#undef mid
#undef Ls
#undef Rs
#undef Ts
int main()
{
	cin.tie(0)->sync_with_stdio(0);
	cin>>n>>m>>q;
	for(int i(1);i<=m;++i)cin>>op[i];
	build();
	for (long long typ,x,y,z;q--;)//求教为啥要long long
	{
		cin>>typ>>x>>y;
		if (typ==1)
		{
			cin>>z;
			Node res({0,0,0});
			query(y,z,res);
			cout<<((max(x>>res.dw,1ll)<<res.up)|res.val)<<'\n';
		}else modify(x,y);
	}
	return 0;
}
```

---

## 作者：61satSea (赞：3)

1.3s 5e5 分块 好 ✓

没加啥常数优化，最大点跑了 1.19s，感觉还行（？

---

把这棵二叉树节点编号当作二进制来看，  
那么我们可以发现一个区间的操作仅会影响当前答案的后缀（整体也算）。  
于是考虑分块维护信息，记录一个块整体会影响答案后缀的位数，再记录影响的结果。

具体来讲，假设当前点编号为 $x$，加入一个 3 操作必然会影响其最后一位，那么我们将其记录。  
而先加入 1 再加入 3 则不会影响答案，就不记录。  

在此之后，最后的答案肯定是当前节点子树中的一个点，也即当前节点编号一定是答案的一个前缀。  
那么我们暴力维护答案在当前节点编号后添加的数字（即从根节点开始模拟得到的结果），查询时即可 $\mathcal O(1)$ 查询整块。

散块直接暴力即可。

细节不多。

总复杂度 $\mathcal O(m+q(\frac mB + B))$，$B$ 取 $\sqrt m$ 时最优。

---

代码：

```c
int main() {
    read(n), read(m), read(q); 
    for (int i = 1, rt = 1, ld = 0; i <= m; ++ i) {
        read(op[i]), bl[i] = (i - 1) / blksz + 1; 
        if (bl[i] != bl[i - 1]) 
            lp[bl[i - 1]] = ld, tp[bl[i - 1]] = rt, ct[bl[i - 1]] = 31 - __builtin_clz(rt), ld = 0, rt = 1; 
        if (op[i] == 3) 
            rt == 1? ++ ld: rt >>= 1; 
        if (op[i] == 1) 
            rt = rt << 1; 
        if (op[i] == 2) 
            rt = rt << 1 | 1; 
        if (i == m) 
            lp[bl[m]] = ld, tp[bl[m]] = rt, ct[bl[m]] = 31 - __builtin_clz(rt); 
    }
    bl[m + 1] = bl[m] + 1; 
    while (q --) {
        read(ty); 
        if (ty == 1) {
            read(ans), read(l), read(r); 
            int pl = bl[l - 1] + 1, pr = bl[r + 1] - 1; 
            if (pl > pr) {
                for (int i = l; i <= r; ++ i) {
                    if (op[i] == 3) 
                        ans > 1? ans >>= 1: 0; 
                    if (op[i] == 1) 
                        ans <<= 1; 
                    if (op[i] == 2) 
                        ans = ans << 1 | 1; 
                }
                printf("%d\n", ans); 
                continue; 
            }
            for (int i = l; bl[i] != pl; ++ i) {
                if (op[i] == 3) 
                    ans > 1? ans >>= 1: 0; 
                if (op[i] == 1) 
                    ans <<= 1; 
                if (op[i] == 2) 
                    ans = ans << 1 | 1; 
            }
            for (int i = pl; i <= pr; ++ i) {
                if (lp[i] >= 30 || !(ans >> lp[i])) 
                    ans = tp[i]; 
                else 
                    ans = ans >> lp[i] << ct[i] | (tp[i] ^ (1 << ct[i])); 
            }
            for (int i = pr * blksz + 1; i <= r; ++ i) {
                if (op[i] == 3) 
                    ans > 1? ans >>= 1: 0; 
                if (op[i] == 1) 
                    ans <<= 1; 
                if (op[i] == 2) 
                    ans = ans << 1 | 1; 
            }
            printf("%d\n", ans); 
        }
        else {
            read(l), read(r); 
            op[l] = r; 
            int ld = 0, rt = 1; 
            for (int i = bl[l] * blksz - blksz + 1; i <= bl[l] * blksz && i <= m; ++ i) {
                if (op[i] == 3) 
                    rt == 1? ++ ld: rt >>= 1; 
                if (op[i] == 1) 
                    rt = rt << 1; 
                if (op[i] == 2) 
                    rt = rt << 1 | 1; 
            }
            lp[bl[l]] = ld, tp[bl[l]] = rt, ct[bl[l]] = 31 - __builtin_clz(rt); 
        }
    }
    return 0; 
}
```

---

## 作者：fush (赞：2)

~~蒟蒻还是看了 4SunnyH 大佬的题解才做出来，还是太菜了。~~  
我们把每个节点转化成二进制，除了第一位刚好是**左 $0$ 右 $1$**。  
只要记录经过这断区间的操作后**最高能到达的几级祖先**，**最低孙子与最高祖先的差**，和行走的路径。  
那么只要处理区间合并，再用线段树维护即可。

至于区间合并，由于答案是形如 `(x>>ma)<<l|num` 的，我们分别考虑即可。
```c++
sgs operator +(sgs a, sgs b){
	return sgs{a.ma + max(0, b.ma - a.l),
               max(0, a.l - b.ma) + b.l,
               ((a.num >> b.ma) << b.l) | b.num
    };
}
```
在最终输出答案的时候，我们要写成 `max(x >> ma, 1) << l | num`，因为要保成开头有 $1$。
```c++
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define FL(a,b,c) for(int a=(b),a##end=(c);a<=a##end;++a)
#define FR(a,b,c) for(int a=(b),a##end=(c);a>=a##end;--a)
#define lowbit(x) ((x)&-(x))
#define eb emplace_back
#define ldb long double
#define ll long long
#define sgindex(l, r) ((l)+(r)|(l)!=(r))
#define rt sgindex(l,r)
#define sgls sgindex(l,sgm)
#define sgrs sgindex(sgm+1,r)
#define sgm (l+r>>1)
#define ln l,sgm
#define rn sgm+1,r
#define max(a, b) ({auto b5k5u7 = a;auto tmd67v8 = b;b5k5u7 < tmd67v8 ? tmd67v8 : b5k5u7;})
#define cmax(a, b) ({auto tmd67v8 = b;(tmd67v8 > a) && (a = tmd67v8);})
#define min(a, b) ({auto b5k5u7 = a;auto tmd67v8 = b;b5k5u7 > tmd67v8 ? tmd67v8 : b5k5u7;})
#define cmin(a, b) ({auto tmd67v8 = b;(tmd67v8 < a) && (a = tmd67v8);})
constexpr int N = 1e6 + 10;
#define int long long
struct sgs{int ma, l, num;}sg[N << 1];
void change(sgs&a, int v){a.ma = (v == 3), a.l = (v <= 2), a.num = (v == 2);}
sgs operator +(sgs a, sgs b){
	return sgs{a.ma + max(0, b.ma - a.l), max(0, a.l - b.ma) + b.l, ((a.num >> b.ma) << b.l) | b.num};
}
void build(int l, int r){
	if(l == r)return cin >> sg[rt].num, change(sg[rt], sg[rt].num);
	build(ln), build(rn), sg[rt] = sg[sgls] + sg[sgrs];
}
void modify(int l, int r, int pos, int v){
	if(l == r)return change(sg[rt], v);
	(pos <= sgm) ? modify(ln, pos, v) : modify(rn, pos, v);
	sg[rt] = sg[sgls] + sg[sgrs]; 
}
sgs query(int l, int r, int L, int R){
	if(L <= l && r <= R)return sg[rt];
	if(R <= sgm)return query(ln, L, R);
	if(sgm < L)return query(rn, L, R);
	return query(ln, L, R) + query(rn, L, R);
}
int32_t main(){
    cin.tie(0)->sync_with_stdio(0);
	int n, m, q;
	cin >> n >> m >> q;
	build(1, m);
	while(q--){
		int op, l, r, s;
		cin >> op >> s >> l;
		if(op == 1){
			cin >> r;
			sgs a = query(1, m, l, r);
			cout << ((max(1, s >> a.ma) << a.l) | a.num) << endl;
		}
		else modify(1, m, s, l);
	}
	return 0;
}
```

---

## 作者：Wzhone (赞：1)

蒟蒻不会做，但是蒟蒻会说：

一眼线段树，离线不下来所以我们考虑 merge 操作怎么办。

相当于把左区间的点当做右区间操作的根节点，那么我们考虑会有哪几种情况：

如果右区间是往下走，那么答案就是左区间的位置和右区间相合并。

如果右区间是往上走，那么情况稍显复杂。因为一个区间的相对位置是固定的，所以不好统计。

考虑到这里，我们发现相对位置的记录是这道题的瓶颈。
综上，我们考虑如何记录这个相对位置。

具体实现上，我们考虑一个二叉树上两个相对位置如何唯一确定。

那么提到两个点的相对位置，LCA 必然是绕不开的。所以我们考虑记录 LCA 和位置以及从这个父亲往下走的01串。

那么合并是简单的。暴力跑就好了。

## TIPS
虽然说蒟蒻一开始基本上把题目口胡了七七八八，但是具体实现上有一些细节口胡的时候没有考虑到，在这种情况下下笔是非常危险的，所以也不算口胡成功了把。

总结一下这种题你要保证细节不出问题，你要考虑以下几个东西：

- 具体合并方式及其（意义上的）正确性
- 合并复杂度
- 线段树节点的具体意义
- 线段树节点的信息维护（尽可能简单，但是必须全面）

这几个东西往往可以保证你的想法是可行的，在打代码的时候也不容易打错。

P.S. 如果没有修改，那么这道题大概率可以不用考虑线段树的合并了（直接线段树往往不行），可以考虑离线下来枚举右端点然后线段树维护区间答案等等套路维护一些不好合并的区间查询。

另：像花神游历各国，如果操作变成平方（线段树大爹）并且支持离线，那么可以考虑使用莫队或者分块的离线算法维护。

---

## 作者：NBest (赞：0)

一道挺好的线段树题，确实不好想到。

因为是一棵满二叉树，一个节点 $s$ 的左儿子编号就是 $2s$，右儿子就是 $2s+1$，父亲就是 $\lfloor\dfrac{s}{2}\rfloor$，题目中也给了提示。

那我们考虑如何合并区间信息呢？如果出现很多次跳到父亲的指令，那么之前的跳儿子指令都会被覆盖，所以我们记录一下最高跳到第几代祖宗，然后剩下的部分记跳到最高之后，向下最多跳到多少儿子，因为儿子分成左右，而每次都是按照 $2s$ 或者 $2s+1$ 来，那么跳到最高之后，儿子的部分应该为一段 $01$ 串，所以我们用一个值维护这个 $01$ 串即可。最后我们假设我们从 $st$ 出发，得到的区间操作信息中最高要跳到 $fa$ 级祖先，跳到祖先后可以到达 $de$ 级儿子，儿子的 $01$ 序列为 $val$，那么答案即为 $(\lfloor\dfrac{s}{2^{fa}}\rfloor\times 2^{de})+val$。

我们发现这个 $01$ 串可能很长甚至远远超过 `long long` 的范围怎么办？没关系啊，题目保证了跳跃一定有儿子，所以虽然我们在部分线段树节点维护的不是正确值，但查询的时候我们查到的肯定都是偏小的 $01$ 串，此时将其合并后值不会大于 $2^n-1$，也就是大区间的区间信息虽然假了，但是不会被我们用到。

而题目又让我们判断如果是根就无视操作 $3$ 怎么办？那很简单，如果最高级祖先已经在 $1$ 之上了，那我们在右移的时候会归 $0$，此时无论 $fa$ 多大都是 $0$，然后做完以后把它变成 $1$ 就满足条件了，所以我们将上式改为 $(\max(1,\lfloor\dfrac{s}{2^{fa}}\rfloor)\times 2^{de})+val$ 即可。

区间信息合并有点小麻烦，可以结合代码理解一下。
## $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mid (l+r>>1)
#define lson root<<1,l,mid
#define rson root<<1|1,mid+1,r
int read(){
    int x=0,f=1;char c=getchar();
    for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
    for(;isdigit(c);c=getchar())x=(x<<3)+(x<<1)+(c^48);
    return x*f;
}
struct segment{
    int fa,de;ll v;
    segment(){fa=de=v=0;}
}tr[2000006];
inline segment operator +(const segment &l,const segment &r){
    segment ans;
    if(l.de>r.fa){//如果左边下降的比右边上升的大
        ans.fa=l.fa;//左边就是最高
        ans.de=l.de-r.fa+r.de;//左边下降的顶掉了右边上升的
        ans.v=((l.v>>r.fa)<<r.de)+r.v;//左边的值保留一部分，用右边的更新
    }else{
        ans.fa=l.fa-l.de+r.fa;//高度增加了
        ans.de=r.de;//剩下的就是右边的答案，左边的答案被顶掉了
        ans.v=r.v;
    }
    return ans;
}
void build(int root,int l,int r){
    if(l==r){
        int w=read();//这里赋值写得应该比较清晰
        if(w==1)tr[root].de=1;
        else if(w==2)tr[root].de=1,tr[root].v=1;
        else tr[root].fa=1;
        return;
    }
    build(lson),build(rson);
    tr[root]=tr[root<<1]+tr[root<<1|1];//合并
}
void update(int root,int l,int r,int x,int w){
    if(l==r)return tr[root].de=(w<=2),tr[root].fa=(w==3),tr[root].v=(w==2),void();
    if(mid>=x)update(lson,x,w);
    else update(rson,x,w);
    tr[root]=tr[root<<1]+tr[root<<1|1];//合并
}
segment query(int root,int l,int r,int x,int y){
    if(x<=l&&r<=y)return tr[root];
    segment res;
    if(mid>=x)res=res+query(lson,x,y);//把两边的答案拿来,合并
    if(mid<y)res=res+query(rson,x,y);
    return res;
}
int n,m,q;
int main(){
    n=read(),m=read(),q=read();
    build(1,1,m);
    for(int opt,s,l,r;q--;){
        if((opt=read())&1){
            s=read(),l=read(),r=read();
            segment o=query(1,1,m,l,r);
            printf("%lld\n",(max(1ll,1ll*s>>o.fa)<<o.de)+o.v);//到根不能再上，所以取max
        }else{
            l=read(),r=read();
            update(1,1,m,l,r);
        }
    }
    return 0;
}
```

---

## 作者：bluewindde (赞：0)

20pts：暴力模拟即可。

40pts：预处理从节点 $1$ 开始前若干个 $op$ 可以跳到哪里。

60pts：预处理前若干个 $op$ 可以使点的位置发生什么变化。

到这里可以发现解题思路：维护每一个区间可以使这个节点的位置发生什么变化。

一些基本结论：对于一个完全二叉树上编号为 $u$ 的节点：

- 其父亲为 `max(u >> 1, 1)`。
- 如果其有左子，为 `u << 1`。
- 如果其有右子，为 `u << 1 | 1`。
- 其 $k$ 代祖先为 `max(u >> k, 1)`。
- 其 $k$ 代**最左**孩子为 `u << k`。

类似向量，建一个结构体维护三个信息：跳到孩子的次数，跳到父亲的次数，跳到右孩子的次数（偏移量）。

信息维护见代码。

维护区间想到线段树。

当然，维护这么复杂的数据，容易死活调不出来（就像我），看了 @[4SunnyH](https://www.luogu.com.cn/user/83535) 的题解，恍然大悟可以重载运算符。（还可以直接用线段树模板）

### 代码

```cpp
// 奇怪的麻风是 VSCode 格式化干的，与我无关
#include <iostream>

#define int long long

using namespace std;

int n, m, q;
int a[500005];

struct node
{
    int a = 0; // 跳到第几代祖先
    int b = 0; // 跳到 a 的第几代孩子
    int p = 0; // 终点对于祖先 a 的相对编号（在以 a 为根的完全二叉树中的编号）
    node() { this->a = this->b = this->p = 0; } // 构造函数
    node(const node &nd)                        // 复制构造函数
    {
        this->a = nd.a;
        this->b = nd.b;
        this->p = nd.p;
    }
    ~node() {}                                                  // 析构函数
    inline bool isNull() const { return !this->a && !this->b; } // 方便快捷的判断函数
    inline node &operator=(const node &nd)                      // 重载赋值运算符
    {
        this->a = nd.a;
        this->b = nd.b;
        this->p = nd.p;
        return *this;
    }
    inline node operator+(const node &nd) const
    {
        if (nd.isNull()) // 一些可以确定的结果
            return *this;
        if (this->isNull())
            return nd;
        node ret;
        if (this->b > nd.a) { // 向下跳的次数大于向上跳的次数
            ret.a = this->a;  // 继承
            ret.b = this->b - nd.a + nd.b;
            ret.p = ((this->p >> nd.a) << nd.b) + nd.p;
        } else { // 向上跳的次数大于向下跳的次数
            ret.a = this->a + nd.a - this->b;
            ret.b = nd.b; // 继承
            ret.p = nd.p; // 继承
        }
        return ret;
    }
} d[2000005];
static inline void pushup(int p) { d[p] = d[p << 1] + d[p << 1 | 1]; }
static inline void build(int s, int t, int p)
{
    if (s == t) {
        if (a[s] == 1) {
            d[p].b = 1;
        } else if (a[s] == 2) {
            d[p].b = 1;
            d[p].p = 1;
        } else {
            d[p].a = 1;
        }
        return;
    }
    int mid = (s + t) >> 1;
    build(s, mid, p << 1);
    build(mid + 1, t, p << 1 | 1);
    pushup(p);
}
static inline void update(int x, int s, int t, int c, int p)
{
    if (s == t) {
        d[p].a = d[p].b = d[p].p = 0;
        if (c == 1) {
            d[p].b = 1;
        } else if (c == 2) {
            d[p].b = 1;
            d[p].p = 1;
        } else {
            d[p].a = 1;
        }
        return;
    }
    int mid = (s + t) >> 1;
    if (x <= mid)
        update(x, s, mid, c, p << 1);
    else
        update(x, mid + 1, t, c, p << 1 | 1);
    pushup(p);
}
static inline node query(int l, int r, int s, int t, int p)
{
    if (l > t || r < s)
        return node();
    if (l <= s && r >= t)
        return d[p];
    int mid = (s + t) >> 1;
    node ret;
    if (l <= mid)
        ret = ret + query(l, r, s, mid, p << 1);
    if (r > mid)
        ret = ret + query(l, r, mid + 1, t, p << 1 | 1);
    return ret;
}

signed main()
{
#ifndef ONLINE_JUDGE
    freopen("tmp.in", "r", stdin);
#endif
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m >> q;
    for (int i = 1; i <= m; ++i) {
        cin >> a[i];
    }
    build(1, m, 1); // 序列长度是 m 不是 n ！！！！！！！！！！！！！！！！！！！！！
    while (q--) {
        int op;
        cin >> op;
        if (op == 1) {
            int s, l, r;
            cin >> s >> l >> r;
            node ret = query(l, r, 1, m, 1);
            cout << ((max(1ll, (s >> ret.a)) << ret.b) + ret.p) << endl;
        } else {
            int x, y;
            cin >> x >> y;
            update(x, 1, m, y, 1);
        }
    }
    return 0;
}
```

我爱调线段树，一调一中午。

---


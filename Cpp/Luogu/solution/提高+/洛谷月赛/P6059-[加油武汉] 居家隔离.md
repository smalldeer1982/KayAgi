# [加油武汉] 居家隔离

## 题目背景

为了防止感染，大家要自觉做到居家隔离，少外出少与外人接触。

## 题目描述

居家久了，你需要给自己找点娱乐。于是你看到这么一个游戏：
给定一个 $n$ 元集合 $ \{a_1,a_2,a_3....a_n \}$，元素各不相同。

游戏总共会进行 $n$ 轮，每轮系统会从集合中随机挑出一个元素，记作 $x$。你可以有如下两种选择：

1. 取走 $x$，那么 $x$ 将会是你的最终得分。
2. 舍弃 $x$，此时 $x$ 将会永久的从这个集合中删去，并且进入下一轮。

请注意，若是集合中仅剩唯一一个元素时，该元素无法被舍弃。

由于你很懒，所以你指定了一个很咸鱼的策略：

对于前 $k$ 轮，将得到的数全部舍弃，并且记录下得到的数中的最大值，记作 $y$。

在第 $k$ 轮之后，执行如下策略：

若是取得的 $x > y$，则直接取走 $x$。反之不断舍弃，直到找到了一个满足要求的 $x$ 或是仅剩一个元素。

现在你希望知道，对于 $1$ 到 $n-1$ 的每一个 $k$，你期望下的得分是多少。

所有数请对 $998244353$ 取模。

## 说明/提示

**样例解释**

答案输出的四个数应该分别是 $\frac{39}{10}, \frac{19}{5} ,\frac{69}{20}, 3$，但在模意义下除以一个数相当于乘这个数在模意义下的逆元，因此输出为这些数。举例来说 $\frac{39}{10}\equiv 39\cdot 10^{-1}\equiv 39\cdot 299473306\equiv 698771051\pmod{998244353}$。

提示：如果你不知道如何对一个分数取余，请点这里：<https://www.luogu.com.cn/problem/P2613>


 - 对于 $40\%$ 的数据，满足 $2 \leq n \leq 10$；
 - 对于 $60\%$ 的数据，满足集合为 $[1,n]$ 中所有正整数；
 - 对于 $100\%$ 的数据，满足 $2 \leq n \leq 1000$，集合中所有数字不超过 $10000$。

## 样例 #1

### 输入

```
5
1 2 3 4 5```

### 输出

```
698771051 399297745 349385527 3```

# 题解

## 作者：TheShadow (赞：6)

# 题目链接

[P6059 [加油武汉]居家隔离](https://www.luogu.com.cn/problem/P6059)

# Solution

**以下分析时，默认轮数为 $m$ **。

先分析一下算法大概的框架。

时间复杂度要求是 $O(n^2)$ ，然而我们需要求出对于每一个 $i\in[1,n-1]$ 的答案，这个我们显然是要枚举的，所以对于每一个 $i$ 我们需要 $O(n)$ 算出答案。

然后我们注意到决策中有一个很重要的分解点 $x_k$ ，我们可以尝试枚举这个数是多少。

我们通过期望的定义来计算这道题，即 $E=\frac{res}{sum}$ ，其中 $res,sum$ 分别是指所有方案下答案的总和与方案数。

这道题我们可以看做是对原序列的所有排列来求答案，所以方案数为 $n!$ 。

## 当 $k\in[m,n-1]$ 时。

最后的答案显然是 $x_j,j\in[k+1,n]$ 。

考虑答案是 $x_j$ 时的方案数（我们将它称作贡献），可以发现此时 $x_j$ 是后几个数中最先出现的 。

因为前 $m$ 个数中最大的是 $x_k$ ，所以前 $m$ 个数的选取方案为 $\binom{k-1}{m-1}$ ，考虑顺序，再乘上 $m!$ 。

考虑 $[1,k]$ 中剩下的 $k-m$ 个数，他们一定不会成为答案，所以可以随意放置，方案数为 $\binom{n-m}{k-m}$ ，考虑顺序，再乘上 $(k-m)!$ 。

由于 $x_j$ 是最先出现的，所以剩下的 $n-k$ 个位置中，它一定在最前面，其他的 $n-k-1$ 个数考虑顺序，贡献再乘上 $(n-k-1)!$ 。

可以发现贡献与 $j$ 无关，所以我们通过前缀和优化即可 $O(1)$ 计算分界值为 $x_k$ 时的答案。

## 当 $k=n$ 时。

这时显然不存在 $x>x_k$ ，所以答案就是最后一个取到的数。

我们假设答案是 $x_j$ ，那么我们首先需要从剩下的 $n-1$ 个数中选出前 $m$ 个，因为最后一个必选，所以贡献乘上方案数 $\binom{n-2}{m-1}$ 。

考虑这选出来的 $m$ 个数的顺序，贡献乘上 $m!$ 。

由于默认 $x_j$ 是最后一个，考虑剩下的数的顺序，贡献乘上 $(n-m-1)!$ 。

由于对每一个 $x_j,j\in[1,n-1]$ ，贡献均相同，所以通过前缀和即可 $O(1)$ 算出。

综上，我们得到了一个 $O(n^2)$ 的算法，可以通过本题。

# Code

```c++
#include<bits/stdc++.h>
#define del(a,i) memset(a,i,sizeof(a))
#define ll long long
#define inl inline
#define il inl void
#define it inl int
#define ill inl ll
#define re register
#define ri re int
#define rl re ll
#define INF 0x3f3f3f3f
#define lowbit(x) (x&(-x))
#define mid ((l+r)>>1)
using namespace std;
template<class T>il read(T &x){
	x=0;int f=1;char k=getchar();
	for(;k>'9'||k<'0';k=getchar()) if(k=='-') f=-1;
	for(;k>='0'&&k<='9';k=getchar()) x=x*10+k-'0';
	x*=f;
}
template<class T>il _print(T x){
	if(x>9) _print(x/10);
	putchar(x%10+'0');
}
template<class T>il print(T x){
	if(x<0) putchar('-'),x=-x;
	_print(x);
}
it qpow(int x,int k,int mod){
	int res=1,bas=x;
	while(k){
		if(k&1) res=1ll*res*bas%mod;
		bas=1ll*bas*bas%mod,k>>=1;
	}
	return res;
}
const int N = 1e3+5,mod = 998244353;
int n,fac[N],ifac[N],val[N],sum[N];
it add(int x,int y){return x+y>=mod?x+y-mod:x+y;}
it mul(int x,int y){return 1ll*x*y%mod;}
il inc(int &x,int y){x=add(x,y);}
it C(int n,int m){return m>n?0:mul(mul(ifac[m],ifac[n-m]),fac[n]);}
il Solve(int m){
	int res=0,div=fac[n];
	for(ri i=m;i<n;++i){
		int tval=add(sum[n],mod-sum[i]);
		tval=mul(tval,C(i-1,m-1));
		tval=mul(tval,C(n-m,i-m));
		tval=mul(tval,fac[m]);
		tval=mul(tval,fac[i-m]);
		tval=mul(tval,fac[n-i-1]);
		inc(res,tval);
	}
	int tval=mul(C(n-2,m-1),fac[m]);
	tval=mul(tval,sum[n-1]);
	tval=mul(tval,fac[n-m-1]);
	inc(res,tval);
	print(mul(res,qpow(div,mod-2,mod))),putchar(' ');
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n),fac[0]=1;
	for(ri i=1;i<=n;++i) fac[i]=mul(fac[i-1],i);
	ifac[n]=qpow(fac[n],mod-2,mod);
	for(ri i=n-1;i>=0;--i) ifac[i]=mul(ifac[i+1],i+1);
	for(ri i=1;i<=n;++i) read(val[i]);
	sort(val+1,val+1+n);
	for(ri i=1;i<=n;++i) sum[i]=add(sum[i-1],val[i]);
	for(ri i=1;i<n;++i)
		Solve(i);
	return 0;
}
```



---

## 作者：zcysky (赞：4)

下面是官方题解。

## 暴力

考虑暴力枚举。

枚举全排列，然后根据题意对于每个排列考虑任意的 $k$ 进行模拟。统计答案最后除以排列总数算期望。

时间复杂度 $O(n\times n!)$。

## 正解

对于每一个 $k$，我们尝试算出所有的排列的得分和，之后除以全排列方案数 $n!$ 就是期望了。

显然这个序列要被我们分成两个部分 $1\sim k,k+1\sim n$。对于 $1\sim k$ 这个部分我们只需要知道最大的数是多少。

那么我们去枚举这个最大的数 $i$，显然 $i\geq k$。那么我们现在需要考虑的就是 $k+1\sim n$ 中大于 $i$ 且最靠前的数是多少并且有多少种不同的排列使得其成立。值得注意的是当 $i=n$ 时，这个排列的分数是整个排列的最后一个数，因此我们把它单独拿出来考虑。

当 $i\neq n$ 时，首先我们假设 $k+1\sim n$ 中大于 $i$ 且最靠前的数是 $a$。接着考虑有多少种排列。$1\sim k$ 中，除了需要放 $i$ 这个数以外，还需要在 $i-1$ 个数中选出 $k-1$ 个数把前 $k$ 位填满，因此方案数为 ${i-1\choose k-1} k!$，$k!$ 表示前 $k$ 位可以随意排列。$k+1\sim n$ 中，首先要安排 $i-k$ 个位置把之前没放进去 $<i$ 的数放在排列中，因此选出 ${n-k\choose i-k}$ 个位置，由于这 $i-k$ 个数可以随意排列，因此再乘上 $(i-k)!$。之后考虑放 $>i$ 的数，因为这些数第一个出现的必须是 $a$，又因为这些数能放的位置已经确定，因此再乘上 $(n-i-1)!$。综上，得分为 $a$ 时的得分和为
$$
a\times{i-1\choose k-1}k!\times{n-k\choose i-k}(i-k)!(n-i-1)!
$$

同样对于每一个大于 $i$ 的数我们都可以这样算出贡献，因此我们对原数组从小到大排序并做一个后缀和。那么就可以把 $k$ 确定 $i$ 确定的贡献全部求出来了。

当 $i=n$ 时，这时我们实际上只需要考虑 $i$ 怎么放以及最后一个数是多少就好了，假设最后一个数为 $a$。由于其余的数可以在 $n-2$ 个位置上乱填，因此他们贡献 $(n-2)!$。$i$ 只能在前 $k$ 个数中出现，因此需要再乘上一个 $k$。综上，得分为 $a$ 时的得分和为
$$
a\times k\times (n-2)!
$$

同样对于每一个小于 $n$ 的数都可以这样算，因此也可以利用后缀和省去对 $a$ 的枚举。

时间复杂度 $O(n^2)$。


---

## 作者：xiayuyang (赞：2)

[博客地址](https://blog.csdn.net/wmhtxdy/article/details/104252053)

解法
组合数学问题
思路：首先考虑每个数在前k轮后被选为最大值的概率，然后比它大的数都可能作为答案，这里需要注意特判的是如果前k轮选的最大值就是整个集合的最大值，那么前k轮中剩下的每个数都有均等的机会成为答案。
其实麻烦的是推式子。可以看代码理解

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e3+5,mod=998244353;
inline int read(){
	char c=getchar();int t=0,f=1;
	while((!isdigit(c))&&(c!=EOF)){if(c=='-')f=-1;c=getchar();}
	while((isdigit(c))&&(c!=EOF)){t=(t<<3)+(t<<1)+(c^48);c=getchar();}
	return t*f;
}
int n,a[maxn],pre[maxn],inv[maxn];
inline int ksm(int a,int b){
	int ans=1;
	while(b){
		if(b&1)ans=1ll*ans*a%mod;
		b>>=1;a=1ll*a*a%mod; 
	}
	return ans;
}
inline int C(int n,int m){
	return 1ll*pre[n]*inv[m]%mod*inv[n-m]%mod;
}
int sum[maxn];
int main(){
	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	sort(a+1,a+1+n);
	pre[0]=inv[0]=1;
	for(int i=1;i<=n;i++)pre[i]=1ll*pre[i-1]*i%mod;
	inv[n]=ksm(pre[n],mod-2);
	for(int i=n-1;i>=1;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;
	for(int i=n;i>=1;i--){
		sum[i]=sum[i+1]+a[i];
	}
	for(int i=1;i<n;i++){//枚举k
		int ans=0;
		for(int j=i;j<n;j++){//枚举最大值是哪一个（这里没有考虑最大值是极大值的情况，这个要单独考虑）
			ans=(ans+1ll*C(j-1,i-1)*ksm(C(n,i),mod-2)%mod*sum[j+1]%mod*ksm(n-j,mod-2)%mod)%mod;//前面算的是最大值为j的概率，后面算的是这个情况下答案的期望
		}
		ans=(ans+1ll*C(n-1,i-1)*ksm(C(n,i),mod-2)%mod*(sum[1]-a[n])%mod*ksm(n-1,mod-2)%mod)%mod;//最大值极大的情况
		printf("%d ",ans);
	}
	return 0;
}


```


---

## 作者：arrow_king (赞：0)

# 闲话

这道题很像算法导论上那个面试例题。

# 思路

以下默认 $a_1,a_2,\dots,a_n$ 按照升序排序。

发现可以 $O(n^2)$ 过这个题，所以考虑先枚举 $k$ 再 $O(n)$ 求出对每个 $k$ 的答案。

注意到如果选择的 $k$ 个数中没有 $a_n$ 且最大值是 $a_p$，那么答案一定是 $a_{p+1},\dots,a_n$ 中的一个。所以可以考虑枚举选择的数中的最大值并求出答案。

## $p\not=n$

此时答案一定是 $a_{p+1},\dots,a_n$ 中的一个数。考虑到 $a_1,a_2,\dots,a_{p-1}$ 中还有 $k-1$ 个数要选，选择的方案数是 $\dbinom{p-1}{k-1}$；其次要将这些数排序，方案数乘上 $k!$；最后求出此时的答案。由于 $[p+1,n]$ 中每个数做最后答案的概率都相同，因此这种情况下的总答案就是

$$k!\dbinom{k-1}{p-1}\cdot \dfrac{1}{n-p}\sum_{i=p+1}^na_i$$

## $p=n$

这种情况下答案其实就是选出的最后一个数，情况数是 $(n-1)!$，其期望答案是 $\dfrac{1}{n-1}\sum\limits_{i=1}^{n-1}a_i$，乘起来即可。

最后求期望，总的选择方案数是 $n!$。

# 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
using namespace std;
#define ll long long
#define il inline
#define N 1005
#define mod 998244353
il ll read() {
	ll x=0,f=1;char c=getchar();
	while(c<'0'||c>'9') {if(c=='-') {f=-1;} c=getchar();}
	while(c>='0'&&c<='9') {x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*f;
}
ll n,a[N],s[N];
ll fac[N],inv[N];
il ll qpow(ll a,ll b) {
	ll ans=1;
	while(b) {
		if(b&1) ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}
il ll C(ll x,ll y) {
	return fac[x]*inv[y]%mod*inv[x-y]%mod;
}
il ll A(ll x,ll y) {
	return fac[x]*inv[x-y]%mod;
}
int main() {
	n=read();
	for(int i=1;i<=n;i++) a[i]=read();
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++) s[i]=(s[i-1]+a[i])%mod;
	fac[0]=1;
	for(int i=1;i<=n;i++) fac[i]=(fac[i-1]*i)%mod;
	inv[n]=qpow(fac[n],mod-2);
	for(int i=n-1;i>=0;i--) inv[i]=(inv[i+1]*(i+1))%mod;
	for(int k=1;k<n;k++) {
		ll sum=0; 
		for(int i=n;i>=k;i--) {
			if(i==n) sum=C(n-1,k-1)*A(k,k)%mod*s[n-1]%mod*qpow(n-1,mod-2)%mod;
			else sum=(sum+C(i-1,k-1)*A(k,k)%mod*(s[n]-s[i]+mod)%mod*qpow(n-i,mod-2)%mod)%mod;
		}
		printf("%lld ",sum*qpow(A(n,k),mod-2)%mod);
	}
	putchar('\n');
	return 0;
}

```

---


# [EER2] 相同的数字

## 题目描述

每天早上在黑板上会写有 $n$ 个固定的数字，但是这些数字太无序了，所以每天晚上兔子想把他们变成相同的数字。

有两种操作 :

* 选择一个下标 $k$，将 $a_k$ 替换为 $a_k+1$。一次操作花费 $c_1$ 的时间。

* 选择一个下标 $k$，将 $a_k$ 替换为大于 $a_k$ 的最小质数。一次操作花费 $c_2$ 的时间。

兔子很懒，所以他不想花费太多的时间，你需要帮他计算出将所有数变相同的最小时间。

总共会有 $q$ 天。兔子每天的状态不同，所以每一天会有不同的 $c_1$ 和 $c_2$。但是黑板上的数不会变。

第一天花费的时间当然会影响第二天的状态。每天真实的 $c_1 = c'_1\oplus
 (T \times (lastans \bmod 2^{17}))$，$c_2 = c'_2 \oplus
 (T\times (lastans \bmod 2^{17}))$。其中 $\oplus$ 为 $\operatorname{xor}$ 运算，$lastans$ 为上一次的答案，最初 $lastans = 0$。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$1 \leq a_i \leq 10^7$，$0 \leq T \leq 1$，$1 \leq q \leq 10^6$，$1 \leq c_1, c_2, c'_1, c'_2< 2^{17}$。

| 测试点编号 | 分值 | $n\leq$ | $a_i\leq$ | $T=$ | $q\leq$ |特殊性质|
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $10$ | $100$ | $100$ | $0$ | $5$ |  所有 $a_i$ 都是质数，$c_1, c_2\leq 10^4$|
| $2$ | $10$ | $10^5$ | $10^5$ | $0$ | $5$ | |
| $3$ | $25$ | $10^5$ | $10^7$ | $0$ | $5$ |  |
| $4$ | $10$ | $10^5$ | $10^7$ | $1$ | $5$ | 所有 $a_i$ 都是质数||
| $5$ | $20$ | $10^5$ | $10^7$ | $0$ | $10^5$ |  |
| $6$ | $22$ | $10^5$ | $10^7$ | $1$ | $10^6$ | |
|$7$ | $\color{red}3$ | $10^5$ | $10^7$ | $1$ | $10^6$ | $\color{red}{时限}$ $\color{red}{700ms}$ |

## 样例 #1

### 输入

```
5 2 0
3 5 8 14 16
2 3
1 3
```

### 输出

```
41
32
```

## 样例 #2

### 输入

```
4 2 1
2 3 5 8
1 2
12 9
```

### 输出

```
14
28
```

# 题解

## 作者：xht (赞：10)

最后那个相同的数只可能是 $m = \max_{i=1}^{n} a_i$ 或者 $\ge m$ 的最小质数，每次算两种的答案然后取 $\min$ 即可。

算答案的时候，将每个数加到目标值的过程按照质数划分成若干段，可以差分实现。对于长度为 $k$ 的一段，选择用 $c_1$ 还是 $c_2$ 取决于 $kc_1$ 和 $c_2$ 哪个大，显然这玩意儿是单调的，那么前缀和一下即可。

注意如果目标值是 $m$ 且 $m$ 不为质数，每个数加到 $m$ 的最后一段可能只能使用 $c_1$。

总时间复杂度 $\mathcal O(n + m + q)$。

```cpp
const int N = 1e5 + 7, M = 1 << 17 | 1, P = 1e7 + 20;
int n, m, q, o, a[N], v[P], f[P], c1, c2;
vi p;
vector<ll> c[2], e[2];
ll g[2], ans;

inline void add(int o, int x, int k) {
	if (!x) return;
	if ((int)c[o].size() < x + 1) c[o].resize(x + 1);
	c[o][x] += k;
}

inline void prework(int o, int m) {
	vi d(p.size());
	for (int i = 1; i <= n; i++) {
		int x = a[i];
		if (v[x] == v[m]) add(o, m - x, 1);
		else {
			add(o, v[x] - x, 1);
			if (m == v[m]) add(o, m - p[f[v[m]]-1], 1);
			else g[o] += m - p[f[v[m]]-1];
			++d[f[v[x]]];
		}
	}
	for (ui i = 0; p[i+1] < v[m]; i++) {
		if (i) d[i] += d[i-1];
		add(o, p[i+1] - p[i], d[i]);
	}
	e[o].resize(c[o].size());
	for (ui i = 0; i < c[o].size(); i++) {
		e[o][i] = c[o][i] * i;
		if (i) e[o][i] += e[o][i-1], c[o][i] += c[o][i-1];
	}
}

inline ll solve(int o) {
	int k = min((int)1.0 * c2 / c1, (int)c[o].size() - 1);
	return (e[o][k] + g[o]) * c1 + (c[o].back() - c[o][k]) * c2;
}

int main() {
	for (int i = 2; i < P; i++) {
		if (!v[i]) p.pb(v[i] = i), f[i] = p.size() - 1;
		for (ui j = 0; j < p.size() && i * p[j] < P && p[j] <= v[i]; j++)
			v[i*p[j]] = p[j];
	}
	for (int i = P - 1; i; i--) if (v[i] != i) v[i] = v[i+1];
	rd(n), rd(q), rd(o);
	for (int i = 1; i <= n; i++) rd(a[i]), m = max(m, a[i]);
	prework(0, m), prework(1, v[m]);
	for (int i = 1; i <= q; i++) {
		rd(c1), rd(c2), c1 ^= o * ans, c2 ^= o * ans;
		print(ans = min(solve(0), solve(1)));
		ans &= M - 2;
	}
	return 0;
}
```

---

## 作者：chenxinyang2006 (赞：4)

- **闲话**

	先放一张我在比赛中成绩的图：

	![](https://cdn.luogu.com.cn/upload/image_hosting/bp9esjm2.png?x-oss-process=image/resize,m_lfit,h_510,w_775)

	没错，我竟然过了最毒瘤的卡常点，然后别的测试点没过……

- **题意**

  给你 $n$ 个数 $a_i$ ，每次可以给一个数 $+1$ 或者变为它的下一个质数，最后让所有数一样
  
  两种操作各有花费，需要求在 $q$ 种花费情况下，分别的最小总花费
  
  $n \le 10 ^ 5$，$a_i \le 10 ^ 7$，$q \le 10 ^ 6$，强制在线
  
- **解析**  
  
  乍一看这个东西似乎十分不可做，我一开始以为是什么动态dp……
  
  但是仔细思考一下，就会发现，当最后那个一样的数确定时，对于每一个数的最小花费挺好求的
  
  为了方便表示，设这个最后的数为$x$
  
  就是每次考虑一下直接跳到下一个质数好，还是一直$+1$加到下一个质数好（当然，是在下一个质数不超过$x$的情况下）
  
  然后考虑枚举最后的数，再枚举每个数进行模拟计算出最小花费
  
  恭喜你，获得了10pts的高分！（这题部分分着实毒瘤……）
  
 - **优化1**
 
   显然，$x$的值还是比较好确定的，$x \ge a_i$ ，而 $x$ 如果太大肯定比较亏
   
   所以你可能觉得 $x$ 就是 $max(a_i)$ ，然后你就WA飞了
   
   考虑下面一组数据：
   
	~~~cpp
    3 1 0
	3 3 4
	3 1
   ~~~
   
   在这组数据中，全部跳到 $5$ 才是最优解，因为这个时候   $+1$ 的费用很贵，甚至比跳下一个质数还要贵，这样还不如全部跳到 $x$ 的下一个质数比较好
   
   所以，一共要分类讨论两种情况：
   
   - $x$ 为 $max(a_i)$
   
   - $x$ 为 $max(a_i)$ 的下一个质数
   
- **优化2**

  如果你仔细想一想，你就会发现，这样一次一次模拟跳跃实在是没有必要，因为 $x$ 是固定的，$a_i$ 也是固定的，每次只要更改决策就行了
  
  通过小学知识知道，$len\le c_2 /c_1$ 的段 $+1$ 比较好，$> c_2 / c_1$的段跳质数
  
  所以，我们只需要统计每次在跳跃过程中，多少个 $ len \le p$ （$p = c_2 / c_1$）就行，设这个为 $total_{len}$
  
  当然，如果你暴力模拟跳跃的话，还是10pts（草，这什么毒瘤题）
  
- **优化3**

  现在，我们需要解决这样一个问题：
  
  - 从 $a_i$ 跳到 $x$ ，计算出经过的每个段的段长 $len$，然后 $total_{len} + 1$（每到一个质数或到 $x$ 算为一段）
  
  这个有两个解决方法：
  
  - 官方题解的解法，考虑每个数会经过哪些段，然后给对应段打上 $ + 1$ 的标记（边角的 $total$ 直接加），最后扫一遍所有段，算出 $total$ 数组
  
  - 反向考虑，考虑每个段会被多少个数经过， $a_i$ 排序后，使用双指针计算（边角的 $total$ 也要讨论）
  
  代码应该都不好写，毕竟还有一个优化1的分类讨论
  
- **tips**

  1. 如果使用官方题解的做法，打标记的时候要使用差分
  
  2. 算出 $total$ 后暴力计算的话，可能会被卡，建议前缀和 + 后缀和快速统计
  
  3. 最后一段是要分类讨论的，所以不能直接加到 $total$，得另开一个，最后和跳到最大值取$min$
  
  4. 筛质数的时候要筛到 $10 ^ 7 + 50$ 的样子，因为可能会跳到 $\ge 10 ^ 7$ 的第一个质数（我因为这个被搞到23分……错失AK）
  
  5. 这题要卡常，否则只能 97pts 
  
时间复杂度：$O(a_i\ log\ log\ a_i + n\ log\ n + q)$

空间复杂度：$O(a_i + n)$

其实时间复杂度可以做到 $O(a_i + n + q)$，就是用欧拉筛、官方题解的 $total$ 计算法，但是意义不大

```cpp
#include <cstdio>
#include <algorithm>
#define max(a,b) ((a) > (b) ? (a) : (b))
#define min(a,b) ((a) < (b) ? (a) : (b))
#define ll long long
int n,q,T;
int a[100005],mx;
int b[100005];

namespace IO{
	inline void read(int &x){
		x = 0;char ch = getchar();
		while(ch < '0' || ch > '9') ch = getchar();
		while(ch >= '0' && ch <= '9') {x = x * 10 + ch - '0';ch = getchar();}
	}
	void W(ll x){
		if(x > 9) W(x / 10);
		putchar(x % 10 + '0');
	}
	inline void write(ll x){
		if(x < 0){ putchar('-');x = -x;}
		W(x);putchar('\n');
	}
};using namespace IO;

int s[10000055];
int p[1000005],cnt; 

void init(){
	register int i,j;
	for(i = 2;i <= 10000050;++i){
		if(s[i]) continue;
		else p[++cnt] = i;
		for(j = 2 * i;j <= 10000050;j += i) s[j] = 1;
	}
}

ll total[205],ex_total[205],extra;//total[i]如题解内意思,ex_total[i]是最后一段的total,extra是跳到mx所需的步数 
ll pre[205],ex_pre[205],suf[205],ex_suf[205];//pre[i]是total[i]的前缀和(带权,因为要计算跳的步数),suf[i]是total[i]的后缀和(不带权),ex_pre[i]意思如ex_total 

void calc(){
	int i,j;
	std::sort(b + 1,b + n + 1);
	j = 0;
	for(i = 1;i <= cnt && p[i] <= mx;i++){//p[i] <= mx是为了后面写着方便 
		while(b[j + 1] <= p[i - 1] && j < n){//b[j + 1] <= p[i - 1]表示j + 1完全经过p[i - 1] ~ p[i] 这一段 
			total[p[i - 1] - b[j + 1]]++;//把b[j + 1]跳到p[i - 1]的一段加入 
			j++;
		}
		total[p[i] - p[i - 1]] += j; 
	}
	while(b[j + 1] <= p[i - 1] && j < n){//注意：这里可能会还有数 
		total[p[i - 1] - b[j + 1]]++;
		j++;
	}
	i--;//现在保证p[i] <= mx,且最大了,本来被++了一次 
	for(j = 1;j <= n;j++){
		extra += mx - max(p[i],a[j]);//注意p[i]和a[j]要取max 
	}
	for(i = 1;i <= 200;i++){//计算前缀和 
		pre[i] = pre[i - 1] + i * total[i];
		ex_pre[i] = ex_pre[i - 1] + i * ex_total[i];
	}
	for(int i = 200;i >= 1;i--){//后缀和 
		suf[i] = suf[i + 1] + total[i];
		ex_suf[i] = ex_suf[i + 1] + ex_total[i];
	}
}

ll solve(ll c1,ll c2){
	ll cut = min(c2 / c1,200);//注意取个min,否则会RE 
	return pre[cut] * c1 + c2 * suf[cut + 1] + min(extra * c1,ex_pre[cut] * c1 + ex_suf[cut + 1] * c2);//自己看一下,应该不难理解 
}

int main(){
	read(n),read(q),read(T);
	for(int i = 1;i <= n;i++){
		read(a[i]);
		mx = max(mx,a[i]);
		b[i] = a[i];
	}
	init();
	calc();
	int c1,c2;
	ll lastans = 0;
	for(int i = 1;i <= q;i++){
		read(c1),read(c2);
		c1 = c1 ^ (T * (lastans % 131072));
		c2 = c2 ^ (T * (lastans % 131072));
		lastans = solve(c1,c2);
		write(lastans);
	}
	return 0;
}
```

但我还是觉得，如果这题写正解去世的话，好歹给点部分分吧……

现在是一个点想不出来直接炸到10pts

---

## 作者：BFqwq (赞：3)

# P6104
由于本题中的 $a$ 序列的顺序对题目没有任何影响，我们不妨设 $a$ 序列递增。

然后我们令 $p$ 序列是从 $2$ 开始的连续质数序列，其中 $p_m$ 为大于等于 $a_n$ 的最小质数。

那么一个显然的贪心是：最终的答案不是 $a_n$ 就是 $p_m$。

由于我们发现相邻的两个素数之间的差最大不超过 $160$，我们可以预处理出到 $a_n$ 和到 $p_m$，每一段不同长度的跨度分别出现了几次，然后按照 $c_1,c_2$ 的值暴力计算。

预处理的地方可以用 $lower\_bound$ 函数先找到里每个数最近的质数，然后前缀和处理。

复杂度 $\operatorname{O}(n\log n+160\times q)$。

（其实这种做法的复杂度比正解高了好多，但是即使卡常还是能过）

```cpp
#include <bits/stdc++.h>
#define rg register
#define il inline
#define ll long long
using namespace std; 
inline int read(){
	register int x=0;
	register bool f=0;
	register char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-48;
		c=getchar();
	}
	return f?-x:x;
}
il void write(rg ll x){
    if(x<0) putchar('-'), x=-x;
    if(x>=10) write(x/10);
    putchar('0'+x%10);
}
int n,q,T;
const int maxn=10000020;
ll ans;
int a[100010];
int pri[1000000];
bool vis[maxn];
ll cst[200];
ll nxt[200];
ll tomx[200];
ll tomxp[200];
int cnt[1000000];
int mx_p,mx;
il void prime(){
    for(rg int i=2;i<=maxn;i++) {
        if(!vis[i]){
            pri[++pri[0]]=i;
        }
        for(rg int j=1;j<=pri[0] && i*pri[j]<=maxn;j++) {
            vis[i*pri[j]]=1;
            if (i%pri[j]==0) {
                break;
            }
        }
    }
}
signed main(){
	prime();
	n=read();q=read();T=read();
	for(rg int i=1;i<=n;i++){
		a[i]=read();
		mx=max(a[i],mx);
	}
	mx_p=lower_bound(pri+1,pri+pri[0]+1,mx)-pri;
	for(rg int i=1;i<=n;i++){
		int now=lower_bound(pri+1,pri+pri[0]+1,a[i])-pri;
		if(now<mx_p){
			nxt[pri[now]-a[i]]++;
			cnt[now]++;
			tomx[mx-pri[mx_p-1]]++;
			tomxp[pri[mx_p]-pri[mx_p-1]]++;
		}
		else{
			tomx[mx-a[i]]++;
			tomxp[pri[mx_p]-a[i]]++;
		}
	}
	
	for(rg int i=1;i<mx_p-1;i++){
		nxt[pri[i+1]-pri[i]]+=cnt[i];
		cnt[i+1]+=cnt[i];
	}
//	for(int i=1;i<=10;i++){
//		cerr<<nxt[i]<<" "<<cnt[i]<<" "<<tomx[i]<<" "<<tomxp[i]<<endl;
//	}
	for(rg int _=1;_<=q;_++){
		ll c1=read(),c2=read();
		if(T) c1^=ans,c2^=ans;
		for(int i=1;i<=160;i++){
			cst[i]=min(i*c1,c2);
		}
		ans=0;
		for(int i=1;i<=160;i++){
			ans+=nxt[i]*cst[i];
		}
		ll mx1=0,mx2=0;
		for(int i=1;i<=160;i++){
			mx1+=tomx[i]*c1*i;
			mx2+=tomxp[i]*cst[i];
		}
		ans+=min(mx1,mx2);
		write(ans);
		ans%=(1<<17);puts("");
	}
	return 0;
}
```
表示没看懂stdqaq

---

## 作者：一叶知秋。 (赞：2)

竟然被 T3 的超短DP吊起来打，调了那么久 qwq，相比之下，T4 还是简单很多的

~~然而我还是错了那么多次~~

思路应该很容易想到，就是让 $a_i$ 都往下一个质数跳

很显然，从一个质数（也有可能 $a_i$ 大于这个质数，但都是相同的）跳到下一个要么一个一个加，要么直接跳上去。

假如跳一会儿再往上直接跳显然没有直接跳花费少

但注意，最后要考虑是都跳到最大的数还是下一个质数，在这里要分类讨论

很显然，直接跳明显会超时，我们可以在询问前处理从这个质数与下一个质数的差，然后看有多少个，树状数组维护即可（懒得想开了 4 个）

具体实现看代码：

```cpp
#include<cstdio>
#include<cctype>

// ↓ 记得开 long long
#define int long long
#define mod 131072
#define maxn 111111
#define maxp 1011101
#define maxc 1111111
#define maxN 10001111
#define lowbit(k) (k&(-k))
//MaxN 也要稍微大于 1e7，maxc 打表吧，看看质数间距最大多少，这里懒得算

inline int read(){
	int r=0,f=0;
	char c;
	while(!isdigit(c=getchar()))f|=(c=='-');
	while(isdigit(c))r=(r<<1)+(r<<3)+(c^48),c=getchar();
	return f?-r:r;
}

inline int max(int a,int b){
	return a>b?a:b;
}

inline int min(int a,int b){
	return a<b?a:b;
}

int n,q,t,sum,Max,Maxp,s_p,app[maxp],p[maxp],a[maxn],b[maxn];

bool n_p[maxN];

struct C{
	
	int c[maxc+1000];
	
	inline void add(int x,int k){
		while(x<=maxc){
			c[x]+=k;
			x+=lowbit(x);
		}
	}
	
	inline int sum(int x){
		int s=0;
		while(x){
			s+=c[x];
			x-=lowbit(x);
		}
		return s;
	}
	
}c,cc,ccc,cccc;//具体看main函数
//P.S. ccc 和 cccc 都是处理的最后，不跳最大数，而是跳向下一个质数
long long ans,c1,c2;

inline void init(){//线性筛
	n=maxN-11;//一定要有一个大于等于 1e7 的质数，因为最大的数也可能往上跳
	for(int i=2;i<=n;i++){
		if(!n_p[i])p[++s_p]=i;
		for(int j=1;j<=s_p&&p[j]<=n/i;j++){
			n_p[i*p[j]]=1;
			if(!(i%p[j]))break;
		}
	}
}

inline int find(int x){
	int l=0,r=s_p+1;
	while(l+1<r){
		int mid=(l+r)>>1;
		if(p[mid]<=x)l=mid;
		else r=mid;
	}
	return l;
}

inline void work(){//比 c2/c1 大的距离都不如一次跳，应该很好算出来吧
	c1=read()^(t*(ans%mod)),c2=read()^(t*(ans%mod));
	int s=c.sum(c2/c1),ss=cc.sum(c2/c1),sss=ccc.sum(c2/c1),ssss=cccc.sum(c2/c1);
	ans=1ll*s*c1+1ll*(cc.sum(maxc)-ss)*c2;
    // ↑ 肯定都要跳到 p[Maxp]，不用分类讨论
	ans+=min(1ll*sum*c1,1ll*sss*c1+1ll*(cccc.sum(maxc)-ssss)*c2);
   	// ↑ 分类讨论是都跳到最大的数还是都跳到 p[Maxp+1]
	printf("%lld\n",ans);
}

signed main(){
	init();
	n=read(),q=read(),t=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		b[i]=find(a[i]);//小于等于 a[i] 的最大质数
		Max=max(Max,a[i]);
		Maxp=max(Maxp,b[i]);
		app[b[i]]++;//大于等于 p[b[i]] 小于 p[b[i]+1] 的数多了一个
	}
	for(int i=1;i<=n;i++){//为了防止 a[i] 不是质数，第一次往上跳要注意
		if(b[i]<Maxp){//小于p[Maxp]才算，因为等下要对最后的两种跳法取小
			c.add(p[b[i]+1]-a[i],p[b[i]+1]-a[i]);//这是用来计算一次一次跳的
			cc.add(p[b[i]+1]-a[i],1);//这是用来计算直接跳的
		}
		ccc.add(p[Maxp+1]-max(a[i],p[Maxp]),p[Maxp+1]-max(a[i],p[Maxp]));//一次一次跳
		cccc.add(p[Maxp+1]-max(a[i],p[Maxp]),1);//直接跳
		sum+=Max-max(a[i],p[Maxp]);//sum处理跳最大数（肯定就只能一次次跳了）
	}// ↓ 一次性处理从 p[i] 往 p[i+1] 跳（记得乘上有多少个需要跳）
	for(int i=Maxp,gs=app[Maxp];i>=1;i--){
		gs+=app[i-1];//大于等于 p[i-1] 小于 p[i] 的上一个循环已经处理了
		c.add(p[i]-p[i-1],(p[i]-p[i-1])*(n-gs));
		cc.add(p[i]-p[i-1],n-gs);
	}
	while(q--)work();
	return 0;
}
```


场后AK可还行 QAQ

P.S. 好吧，我太 naive 了，没有修改，为什么要用树状数组，普通前缀和就可以了啊 QAQ

然而树状数组常数竟然这么小 

---

## 作者：xgzc (赞：1)

先将序列 $a$ 排序，那么最后变成的数字只可能是 $a_n$ 或者是大于 $a_n$ 的第一个质数。

设跳到大于这个数的第一个质数是一步，那么考虑开一个桶维护每种长度所对应的步数，这个桶很小。

询问时判断 $c_2 / c_1$ 的大小，小于这个值的就暴跳，大于这个值的就用 $c_2$ 的代价跳。

用前缀和维护即可。当然如果最后一步是跳到 $a_n$ 的话就只能一步一步跳。

具体的实现细节见[代码](https://paste.ubuntu.com/p/qCHqW44SsB/)。

---

## 作者：lemondinosaur (赞：1)

[传送门](https://www.luogu.com.cn/problem/P6104)

---
# 题目大意
有$n$个数，可以在一个单位时间内用$c1$的花费

使$x$变为$x+1$，用$c2$的花费使$y$变为$\min_{y'\in prime,y'>y}y'$

每次询问$c1,c2$都会改变，但是原来的$n$个数在询问后恢复原状，

问使$n$个数相同的最小花费（强制在线）

---
# 分析
考场的时候想到伪50分的做法，但是被我弄成了10分的暴力

（然而就是暴力），只要记忆化答案应该能够卡常卡到五十分

首先考场的时候想到第一条性质：这$n$个数要么变成$\max_{1\leq i\leq m}a_i$，

要么变成$\max_{1\leq i\leq m}a_i'$(注意那个'和之前的定义相同)

首先线性筛所有范围里的质数（$\approx 6.6\times 10^4$个）。

然后预处理每个数$x$的$x'$，询问时跳到下一个质数

（因为一个一个跳总会跳到下一个质数）

~~暴力跳，终于拿到了10分，还跑得很慢~~

考后询问julao解法，预处理出跳到$\max$或$\max'$的每种长度需要跳的次数，

然后解不等式$len\times c1<c2$
那么当$len<\lfloor\frac{c2}{c1}\rfloor$时选择跳一步(花$c1$)，否则跳到质数（花$c2$），

这个可以用前缀和$O(1)$实现，所以总时间复杂度应该是

$$O(\max_{1\leq i\leq n}a_i+n+q)$$

瓶颈主要是询问和预处理

等等，预处理怎么弄？~~代码又长又丑~~

分成两种情况，这里以预处理$a_j$到$\max$为例，

首先把头尾长度单独加入答案，然后中间部分考虑差分，就是在开头加1，结尾的下一个减1，然后差分数组最后跑前缀和

是不是听起来很简单，按照julao的解法，我成功地WA了

主要有两个细节问题

1. 跳一步需要记录长度，所以不仅要记录次数，而且要记录长度$\times$次数

2. 对于跳到$\max$的情况有一段是不能计入跳到质数的（因为跳到$\max$不一定到的是质数）

改完之后，成功获得了一份常数巨大的正解（记得开$\text {long long}$）

![AC提交记录](https://cdn.luogu.com.cn/upload/image_hosting/8gytq1f2.png)

---
# 代码
```cpp
#include <cstdio>
#include <cctype>
#define rr register
using namespace std;
const int N=10001001,M=666666; int cnt,n,Q,Is_Last,mx,mx1,mx2;
long long sL1[201],sL2[201],xz1,sN1[201],sN2[201];
int prime[M],v[N],nx[N],cf1[M],cf2[M],a[M/6];
inline signed iut(){
	rr int ans=0; rr char c=getchar();
	while (!isdigit(c)) c=getchar();
	while (isdigit(c)) ans=(ans<<3)+(ans<<1)+(c^48),c=getchar();
	return ans;
}
inline void print(long long ans){
	if (ans>9) print(ans/10);
	putchar(ans%10+48);
}
inline signed max(int a,int b){return a>b?a:b;}
inline void pro(int N){//线性筛
	for (rr int i=2;i<=N;++i){
		if (!v[i]) prime[++cnt]=i,v[i]=cnt;
		rr int t=N/i;
		for (rr int j=1;prime[j]<=t;++j){
			v[i*prime[j]]=j;
			if (i%prime[j]==0) break;
	    }
	}
	for (rr int i=N-1,j=cnt;i;--i){
		nx[i]=prime[j];
		if (i==prime[j-1]) --j;
	}	
}
signed main(){
	n=iut(),Q=iut(),Is_Last=iut();
	for (rr int i=1;i<=n;++i) mx=max(mx,a[i]=iut());
	pro(mx+500),mx1=prime[v[nx[mx]]-1],mx2=nx[mx];
   //1.x->mx1->mx 2.x->mx2
	for (rr int i=1;i<=n;++i){
     //上面一坨是第一种情况
		if (nx[a[i]]>mx&&mx!=a[i]){
			if (prime[v[mx]]==mx) sL1[mx-a[i]]+=mx-a[i],++sN1[mx-a[i]];
			    else xz1+=mx-a[i];//这一段不能加
		}
		else if (mx!=a[i]){
			++sN1[nx[a[i]]-a[i]],sL1[nx[a[i]]-a[i]]+=nx[a[i]]-a[i];
			if (prime[v[mx]]==mx) sL1[mx-mx1]+=mx-mx1,++sN1[mx-mx1];
			    else xz1+=mx-mx1;
			++cf1[v[nx[a[i]]]],--cf1[v[mx1]];
		}
    //----------------------
		sL2[nx[a[i]]-a[i]]+=nx[a[i]]-a[i],++sN2[nx[a[i]]-a[i]];
		++cf2[v[nx[a[i]]]],--cf2[v[mx2]];
    //差分
	}
	for (rr int i=1;i<=cnt;++i) cf1[i]+=cf1[i-1],cf2[i]+=cf2[i-1];//前缀和
  //sL长度乘次数前缀和，sN次数前缀和
	for (rr int i=1;i<cnt;++i)
	    sN1[prime[i+1]-prime[i]]+=cf1[i],sN2[prime[i+1]-prime[i]]+=cf2[i],
	    sL1[prime[i+1]-prime[i]]+=cf1[i]*(prime[i+1]-prime[i]),
	    sL2[prime[i+1]-prime[i]]+=cf2[i]*(prime[i+1]-prime[i]);
	for (rr int i=1;i<=170;++i)
	    sL1[i]+=sL1[i-1],sL2[i]+=sL2[i-1],
	    sN1[i]+=sN1[i-1],sN2[i]+=sN2[i-1];
	for (rr long long lans=0,c1,c2,c3;Q;--Q){
		lans%=131072,c1=iut(),c2=iut();
		if (Is_Last) c1^=lans,c2^=lans;
		lans=0,c3=c2/c1>160?160:c2/c1;//解不等式
		rr long long s1=(sL1[c3]+xz1)*c1+(sN1[170]-sN1[c3])*c2,
		             s2=sL2[c3]*c1+(sN2[170]-sN2[c3])*c2;
		print(lans=s1<s2?s1:s2),putchar(10);
	}
	return 0;
}
```

---

## 作者：rizynvu (赞：0)

[我的博客](https://www.cnblogs.com/rizynvu/p/18282367)。

令 $\text{nxt}_i$ 为 $i$ 之后的第一个质数。

考虑最后 $a_i$ 会变成什么。  
首先第一种就是直接变为 $\max a_i$。  
其次还发现可能变为 $\operatorname{nxt}_{\max a_i}$。  
对于其他的，可以证明一定不优于这两种，因为其他的情况无非就是在这基础上继续跳 $\operatorname{nxt}$ 或 $+1$，并没有更快的“捷径”能够跳到这些地方，要到达这个状态肯定要通过上述说过的两种状态。

于是就只需要解决目标是其中之一的最小值，最后取 $\min$ 即可。

接下来就考虑怎么求最小值。  
不难发现对于其中一个 $a_i$ 的路径，可以拆为，先跳若干次 $\operatorname{nxt}$，最后再一直 $+1$（因为 $\operatorname{nxt}$ 已经大于了目标）。  
对于后面 $+1$ 的明显只能用 $c1$ 处理。  
但对于前面跳 $\operatorname{nxt}$，可以记录下跳的距离 $d$，当 $c_1 d\le c_2$ 即 $d\le \frac{c_1}{c_2}$，用 $c_1$ 去替代更优。  
上述提到的过程都可以用前缀和来优化。

时间复杂度 $\mathcal{O}(V\log \log V + n + q)$，$V$ 为值域。  
用欧拉筛即可以使 $V$ 部分的复杂度变为线性。

```cpp
#include<bits/stdc++.h>
using ll = long long;
#define gc getchar_unlocked
inline int read() {
   int x = 0, c = gc();
   while (! isdigit(c)) c = gc();
   while (isdigit(c)) x = (x << 1) + (x << 3) + (c ^ 48), c = gc();
   return x;
}
const int maxn = 1e5 + 10, limm = (int)1e7 + 19, limcnt = 664580, limd = 154;
const ll lim = (1 << 17) - 1;
std::bitset<limm + 2> vis;
int pr[limcnt + 2], cnt, nxt[limm + 2];
std::unordered_map<int, int> id;
int a[maxn];
int to[2];
ll c1[2], c2[2][limd + 2], s2[2][limd + 2]; int sum[limcnt + 2];
int main() {
   for (int i = 2; i * i <= limm; i++)
      if (! vis[i]) {
         for (int j = i * i; j < limm; j += i)
            vis[j] = 1;
      }
   for (int i = 2; i <= limm; i++)
      ! vis[i] && (pr[++cnt] = i, id[i] = cnt);
   for (int i = limm, w = -1; i; i--)
      nxt[i] = w, ! vis[i] && (w = i);
   int n = read(), m = read(), T = read();
   for (int i = 1; i <= n; i++) a[i] = read();
   int mx = a[1];
   for (int i = 2; i <= n; i++) mx = std::max(mx, a[i]);
   to[0] = mx, to[1] = nxt[mx];
   for (int op : {0, 1}) {
      int ed = to[op], pre = 0;
      for (int i = cnt; i; i--)
         if (pr[i] <= ed) {pre = i; break;}
      memset(sum, 0, sizeof(sum));
      for (int i = 1, x; i <= n; i++) {
         x = a[i];
         if (nxt[x] <= ed) {
            c2[op][nxt[x] - x]++, s2[op][nxt[x] - x] += nxt[x] - x;
            x = nxt[x];
            sum[id[x]]++;
            x = pr[pre];
         }
         c1[op] += ed - x;
      }
      for (int i = 1; i < pre; i++) {
         sum[i] += sum[i - 1];
         c2[op][pr[i + 1] - pr[i]] += sum[i], s2[op][pr[i + 1] - pr[i]] += 1ll * sum[i] * (pr[i + 1] - pr[i]);
      }
      for (int i = 1; i <= limd; i++)
         c2[op][i] += c2[op][i - 1], s2[op][i] += s2[op][i - 1]; 
   }
   for (ll w1, w2, ans = 0; m--; ) {
      w1 = read() ^ (T ? (ans & lim) : 0), w2 = read() ^ (T ? (ans & lim) : 0);
      ans = 1e18;
      for (int op : {0, 1})
         ans = std::min(ans, w1 * (c1[op] + s2[op][std::min((int)(w2 / w1), limd)]) + w2 * (c2[op][limd] - c2[op][std::min((int)(w2 / w1), limd)]));
      printf("%lld\n", ans);
   }
   return 0;
}
```

---

## 作者：lyhqwq (赞：0)

# Solution

提供一个简单好写的做法。

我们的每次操作一定会让一个数变大，所以最终相同的数一定是 $\max\{a_i\}$ 或最大值后面第一个质数。我们分两种情况处理。

对于每个数，我们将这个数跳到下一个质数算作一段，预处理出 $sum_x$ 表示长度为 $x$ 的段出现了几次。而两个质数的差最大为 $160$。我们枚举 $x$，答案为 $\sum sum_x\times \min(x\times c1,c2)$。

接着考虑如何预处理，对于每个数跳的过程，我们把它分成三部分：这个数到下一个质数，最后一个质数到目标，中间完整的从质数跳到质数的所有段。对于前两部分我们单独处理，最后一部分我们差分注意如果目标不是质数，最后一段只能一步一步跳。

我们用欧拉筛筛质数，时间复杂度 $O(\max\{a_i\}+n+cq)$，$c=160$，可以卡过。

# Code
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=100005;
const int M=1000005;
const int maxV=1e7+50;
int n,m,pm,q,T,mx;
int vis[maxV];
int a[N],p[M];
LL sum[205][2],ex[205],cnt[M][2];
void init(){
    for(int i=2;i<maxV;i++){
        if(!vis[i]) p[++m]=i;
        for(int j=1;j<=m&&i*p[j]<maxV;j++){
            vis[i*p[j]]=1;
            if(i%p[j]==0) break;
        }
    }
}
void solve(int x,int op){
    for(int i=1;i<=n;i++){
        int nxt=lower_bound(p+1,p+1+m,a[i])-p;
        if(nxt==pm){
            if(!op) ex[x-a[i]]++;
            else sum[x-a[i]][op]++;
        }
        else{
            sum[p[nxt]-a[i]][op]++;
            cnt[nxt][op]++;
            if(!op) ex[x-p[pm-1]]++;
            else sum[x-p[pm-1]][op]++;
        }

    }
    for(int i=2;i<=pm-1;i++){
        sum[p[i]-p[i-1]][op]+=cnt[i-1][op];
        cnt[i][op]+=cnt[i-1][op];
    }
}
int main(){
    scanf("%d%d%d",&n,&q,&T);
    init();
    for(int i=1;i<=n;i++) scanf("%d",&a[i]),mx=max(mx,a[i]);
    pm=lower_bound(p+1,p+1+m,mx)-p;
    solve(mx,0),solve(p[pm],1);
    LL lstans=0;
    while(q--){
        int c1,c2;
        scanf("%d%d",&c1,&c2);
        c1=c1^(T*(lstans%(1<<17))),c2=c2^(T*(lstans%(1<<17)));
        LL sum0=0,sum1=0;
        for(int i=1;i<=150;i++) sum0+=sum[i][0]*min(i*c1,c2),sum1+=sum[i][1]*min(i*c1,c2);
        for(int i=1;i<=150;i++) sum0+=ex[i]*i*c1;
        printf("%lld\n",lstans=min(sum0,sum1));
    }
    return 0;
}

```

---


# 回首过去

## 题目背景

>明天你是否会想起
>
>昨天未调完的题
>
>明天你是否还惦记
>
>考场写挂的暴力

[OEIS 入口](http://oeis.org/)

## 题目描述

在小学时，小 Z 就已经开始学
 OI 了。

有一次，在数学课上，老师问了这样一个问题：
求出有序整数对 $(x,y)$ 的个数，满足 $1\le x,y\le 5$ 且 $\frac{x}{y}$ 可以表示为十进制有限小数。

当然，小 Z 很快就算了出来。

但因为他是学了 OI 的，所以他就推广了一下：

**给定正整数 $n$，求出有序整数对 $(x,y)$ 的个数，满足 $1\le x,y\le n$ 且 $\frac{x}{y}$ 可以表示为十进制有限小数。**

当时，他还是一个菜鸡，只会
 $O(n^2)$ 的暴力。

过了几年，他偶然又翻到了这道题。现在他会了一种更好的方法，于是就把这题出了出来，给你来做做。

## 说明/提示

**样例 1 解释**

$\frac{1}{1}$，$\frac{1}{2}$，$\frac{2}{1}$，$\frac{2}{2}$，$\frac{3}{1}$，$\frac{3}{2}$，$\frac{3}{3}$ 都可以表示为十进制有限小数。

**数据规模与约定**

* Subtask 1（40 分），$1 \le n \le 10^3$；
* Subtask 2（40 分），$1 \le n \le 10^7$；
* Subtask 3（20 分），$1 \le n \le 10^{12}$。

## 样例 #1

### 输入

```
3```

### 输出

```
7```

## 样例 #2

### 输入

```
5```

### 输出

```
21```

# 题解

## 作者：syksykCCC (赞：61)

zrm 哥哥自己不写 sol 做 ppt 差评 /kel

好，那么官方题解只能我来写了 /kk

## 十进制有限小数

什么样子的分数可以表示为十进制有限小数？

约分后，分母只含 $2, 5$ 两种因子的分数可以。

感性证明：

写成十进制有限小数的充要条件显然是分数可以通分为 $\frac{a}{100\dots}$ 的形式，也就是对于一个整数左移小数点。

而形如 $10^x$ 的数必然 $=2^x\times 5^x$，所以，分母只含 $2, 5$ 两个因子即可。


## 子任务 1：$n \le 10^3$

### 做法 1

显然，枚举 $p$，枚举 $q$，暴力约分，判断 $q$ 约分后是不是只含 $2, 5$ 两种因子是可行的。

枚举的时间复杂度为 $O(n^2)$，约分的时间复杂度为 $O(\log n)$，判断分母的时间复杂度也为 $O(\log n)$，后面两者并列，所以，时间复杂度为 $O(n^2  log n)$。

至此，你还没有当年的小 Z 厉害（

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int n, ans = 0;
	cin >> n;
	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= n; j++)
		{
			int p = i, q = j;
			int g = __gcd(p, q);
			p /= g; q /= g;
			while(q % 2 == 0) q /= 2;
			while(q % 5 == 0) q /= 5;
			if(q == 1) ans++;
		}
	}
	cout << ans << endl;
	return 0;
}
```

### 做法 2

把分数分解一下，可以写为以下的形式：

$$\frac{bc}{ac}$$

$a$ 本身**只含** $2, 5$ 两种因子，$c$ 本身**不含** $2, 5$ 两种因子（也就是把分母需要约分的部分拆出来），$b$ 为任意数，显然，这样的分数都是合法的，而且任何合法的分数都是这种形式。

那么，依次在 $[1, n]$ 范围枚举 $a$（合法的 $a$ 的表可以预处理）在 $[1, \lfloor\frac{n}{a} \rfloor]$ 范围枚举合法的 $c$，在 $[1, \lfloor\frac{n}{c} \rfloor]$ 的范围内枚举 $b$，每枚举到一次就把答案加 $1$，时间复杂度 $O(n^2)$。


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, x[100000], cnt, ans;
signed main()
{
	cin >> n;
	for(int i = 1; i <= n; i *= 2)
		for(int j = i; j <= n; j *= 5)
			x[++cnt] = j;
	sort(x + 1, x + cnt + 1);
	for(int i = 1; i <= cnt; i++)
	{
		int a = x[i];
		for(int b = 1; a * b <= n; b++)
		{
			if(b % 2 == 0 || b % 5 == 0) continue;
			for(int c = 1; b * c <= n; c++)
			{
				ans++;
			}
		}
	}
	cout << ans << endl;
	return 0;
}
```

## 子任务 2：$n \le 10^7$

被极短的 $O(n \log n)$ 切了，长见识了 qwq

### 做法 1

观察上一个做法，发现不知道最后一重循环在干啥 /发抖

也就是说，枚举完一组 $a$ 和 $c$ 后，它对答案的贡献就是分子所能取的数量，即 $[1, \lfloor\frac{n}{c} \rfloor]$，直接加上这个贡献就好了。

那么省掉了一重循环，因为分母的枚举是 $n$ 个不重不漏，时间复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, x[100000], cnt, ans;
signed main()
{
	cin >> n;
	for(int i = 1; i <= n; i *= 2)
		for(int j = i; j <= n; j *= 5)
			x[++cnt] = j;
	sort(x + 1, x + cnt + 1);
	for(int i = 1; i <= cnt; i++)
	{
		int a = x[i];
		for(int b = 1; a * b <= n; b++)
		{
			if(b % 2 == 0 || b % 5 == 0) continue;
			ans += n / b;
		}
	}
	cout << ans << endl;
	return 0;
}
```

### 做法 2

想要继续优化，发现很难了，回到 $O(n^2 )$ 的做法，能不能通过转换顺序来达到优化时间的目的呢？

$$\frac{bc}{ac}$$

尝试先枚举 $c$，那么，$b$ 的取值依然是 $[1, \lfloor\frac{n}{c} \rfloor]$ 的任何数，而 $a$ 的取值就变为了 $[1, \lfloor\frac{n}{c} \rfloor]$ 中任何**只含** $2, 5$ 两种因子的数，发现，$a$ 的取值的个数随着 $c$ 的增大而单调减小，所以可以在总共 $O(n)$ 的时间中计算，也就是，对于每个 $c$，记合法的 $a$ 的个数为 $d$，则它对答案的贡献为 $d \times \lfloor\frac{n}{c} \rfloor$。

时间复杂度依然是 $O(n)$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, x[100000], cnt, ans;
signed main()
{
	cin >> n;
	for(int i = 1; i <= n; i *= 2)
		for(int j = i; j <= n; j *= 5)
			x[++cnt] = j;
	sort(x + 1, x + cnt + 1);
	int a = cnt;
	for(int b = 1; b <= n; b++) 
	{
		if(b % 2 == 0 || b % 5 == 0) continue; 
		while(a && x[a] > n / b) a--;
		ans += a * (n / b);
	}
	cout << ans << endl;
	return 0;
}
```

## 子任务 3：$n \le 10^{12}$

不妨把 $d$ 写的更直接一点，换成 $f(x)$，表示 $[1, x]$ 中**只含** $2, 5$ 两个因子的数的个数。前面那个式子等价于：

$$f\left(\left\lfloor\frac{n}{c} \right\rfloor\right)\times\left\lfloor\frac{n}{c} \right\rfloor$$

发现，这个是一种经典的整除分块形式，直接整除分块，可以把时间复杂度加速到 $O(\sqrt{n})$。

真的这么简单么？

别忘了，$c$ 的取值并不是 $[1, n]$ 当中的每一个数，而是不含 $2, 5$ 因子的数。

之前枚举的是 $c$，所以可以直接判断 $c \bmod 2$ 和 $c \bmod 5$ 是不是为 $0$，但现在我们要整段的处理 $c$，怎么办呢？

先忽略这个限制，把 $c$ 的取值范围当作 $[1, n]$ 当中的每一个数处理。比如 $c\in[l, r]$ 时贡献相同，就可以通过容斥计算出 $[l,r ]$ 中实际的合法的 $c$ 的个数。

$$ e= g([l, r], 1)-g([l, r], 2)-g([l, r], 5)+g([l, r], 10) $$


$g([l,  r], x)$ 表示 $[l,  r]$ 中 $x$ **的倍数**的个数，可以类似前缀和得到。（即 $g([1, r], x) - g([1, l], x)$，左端点为 $1$ 显然除一除就好了）


那么，这一段的贡献就是 $e\times f\left(\left\lfloor\frac{n}{c} \right\rfloor\right)\times\left\lfloor\frac{n}{c} \right\rfloor$，时间复杂度 $O(\sqrt{n})$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, x[100000], cnt, ans;
signed main()
{
	cin >> n;
	for(int i = 1; i <= n; i *= 2)
		for(int j = i; j <= n; j *= 5)
			x[++cnt] = j;
	sort(x + 1, x + cnt + 1);
	int a = cnt;
	for(int l = 1, r; l <= n; l = r + 1)
	{
		int t = n / l;
		r = t == 0 ? n : n / t;
		while(a && x[a] > t) a--;
		int valid = r - l + 1;
		valid -= r / 2 - (l - 1) / 2;
		valid -= r / 5 - (l - 1) / 5;
		valid += r / 10 - (l - 1) / 10;
		ans += valid * a * t; 
	}
	cout << ans << endl;
	return 0;
}
```

水一句：比神花还短（（光速逃

---

## 作者：皎月半洒花 (赞：26)

2333333333
 
考虑首先合法的答案一定是分数约分后分母的质因数只有 $2,5$。也就是说

$$
\frac{x}{y}=\frac{\frac{x}{\gcd(x,y)}}{2^p5^q}
$$

其中 $p,q$ 都是极大的。稍微化一下可以发现

$$
y=\gcd(x,y)\times 2^p5^q
$$

那么就可以对每一个 $y$ 求有多少个 $x$ 是合法的。考虑 $x$ 一定可以写作 $d\times \gcd(x,y)$，那么也就是说由于 $\gcd(x,y)$ 固定(因为 $2^p5^q$ 极大)要统计有多少个本质不同的 $d$ ，因为 $x$ 只能在 $[1,n]\cap \mathbb {Z_+}$ 中取值，所以不难发现一共有 $\left\lfloor\dfrac{n}{\gcd(x,y)}\right\rfloor$ 种取法。所以 $80$ 分可以这么写

```cpp
        for (int i = 1 ; i <= n ; ++ i){
            int j = i, o ;
            while (j % 2 == 0) j /= 2 ;
            while (j % 5 == 0) j /= 5 ;
            ans += n / j ;
        }
```
考虑这个式子是一个下取整的形式，即

$$
\sum _{i=1}^n\left\lfloor\dfrac{n}{\zeta(i)}\right\rfloor \qquad(1)
$$

其中 $\zeta(i)$ 是最大的不含质因子 $2,5$ 的 $i$ 的因子。考虑调换枚举顺序，枚举 $\zeta(i)$，会有

$$
(1)=\sum_{k=1}^{n}\left\lfloor\dfrac{n}{k}\right\rfloor\times [2\nmid k]\times[5\nmid k]\times {\rm count(}\left\lfloor\dfrac{n}{k}\right\rfloor)
$$

其中最后一个 $\rm count(t)$ 表示 $1\sim t$ 之间有多少只包含 $2,5$ 作为质因数的数。原因很简单，因为我们枚举的是 $\zeta(i)$，$\zeta(i)$ 需要搭配上 $2^p5^q$ 才会有效，所以计数有多少 $\leq n$ 的数包含 $k$ 就是相当于计数有多少 $\leq  \left\lfloor\dfrac{n}{k}\right\rfloor$ 的数包含 $2^p5^q$。于是这么做就是 $O(\sqrt n\log ^2 n)$ 的了。稍微预处理一下 $\rm count$ 就可以做到 $\sqrt n$ 了。

```cpp

ll n ;
ll res ;
ll ans ;

#define gcd __gcd

ll sum(ll x){
    return (x - (x / 5) - (x >> 1) + (x / 10)) ;
}
ll all_2_5(ll x){
    ll ret = 0 ;
    ll re2 = log(x) / log(2) + 1 ;
    ll re5 = log(x) / log(5) + 1 ;
    ll sum2 = 1 ; ll sum5 ;
    for (int i = 0 ; i <= re2 ; ++ i){
        sum5 = 1 ;
        for (int j = 0 ; j <= re5 ; ++ j){
            if (sum5 * sum2 > x) break ;
            sum5 = 5ll * sum5 ; ++ ret ;
        }
        sum2 = sum2 * 2ll ;
    }
    return ret ;
}

int main(){
    cin >> n ;
    if (n <= 10000000){
        for (int i = 1 ; i <= n ; ++ i){
            int j = i, o ;
            while (j % 2 == 0) j /= 2 ;
            while (j % 5 == 0) j /= 5 ;
//        while (j % 10 == 0) j /= 10, re10 *= 10 ;
		//cout << re2 << " " << re5 << " " << re10 << '\n' ;
//		cout << j << '\n' ;
            ans += n / j ;
//		cout << ans << '\n' ;
        }
    }
    else {
//        cout << all_2_5(10) << '\n' ;
        for (ll l = 1, r ; l <= n ; l = r + 1){
            r = n / (n / l) ;
            ans += (sum(r) - sum(l - 1)) * 1ll * (n / l) * all_2_5(n / l) ;
        }
    }
    cout << ans << '\n' ;
    return 0 ;
}

```

---

## 作者：一扶苏一 (赞：14)

## 【莫比乌斯反演】【P6583】 回首过去

智商不够搞容斥的，就只能硬上反演推式子这样维持生活。

### Analysis

首先~~通过百度~~可以知道，一个分数可以化成有限小数当且仅当约分后分母不含除了 $2$ 和 $5$ 以外的素因子。

考虑把式子写出来。

设集合 $A$ 是素因子只可能有 $2$ 和 $5$ 的不大于 $n$ 的正整数构成的集合。因为分母为 $1$ 的情况比较特殊，我们单独处理。这里的集合 $A$ 不包含 $1$。

除非特殊说明，下面的式子都不包括约分后分母为 $1$ 的情况。

我们枚举约分后的最简分数，将分子分母同时乘上一个倍数就能取到所有合法的分数。

设

$$\begin{aligned}F(n) = \sum_{y \in A}^n \sum_{x = 1}^n \sum_{t = 1}^{\lfloor\frac n {\max(x, y)}\rfloor} [\gcd(x, y) = 1]\end{aligned}$$

这里 $y$ 是分母，$x$ 是分子，$t$ 是同乘的倍数。我们约定 $\sum\limits_{i \in S}^{j}$ 表示取集合 $S$ 中所有不大于 $j$ 的整数。

求和变换一下

$$\begin{aligned}F(n) &= \sum_{y \in A}^n \sum_{x = 1}^n \sum_{t = 1}^{\lfloor\frac n {\max(x, y)}\rfloor} [\gcd(x, y) = 1] \\ &= \sum_{t = 1}^n \sum_{x = 1}^{\lfloor\frac n t\rfloor} \sum_{y \in A}^{\lfloor\frac n t\rfloor} [\gcd(x, y) = 1] \end{aligned} $$

看到后半部分就知道可以反演了。

设

$$\begin{aligned}G(n) &= \sum_{i = 1}^n \sum_{j \in A}^n [\gcd(i, j) = 1] \\ &=\sum_{i = 1}^n \sum_{j \in A}^n \epsilon(\gcd(i, j))\end{aligned}$$

后面是反演的基操，因为 $\mu \circ I = \epsilon$，所以

$$\begin{aligned}G(n) &= \sum_{i = 1}^n \sum_{j \in A}^n \sum_{d \mid i \land d \mid j} \mu(d) \\ &= \sum_{d = 1}^n \mu(d) \lfloor\frac n d \rfloor \sum_{i = 1}^{\lfloor\frac n d \rfloor} [id \in A] \end{aligned}$$

把 $G$ 带回 $F$，得到

$$\begin{aligned}F(n)  &= \sum_{t = 1}^n \sum_{y \in A}^{\lfloor\frac n t\rfloor} \sum_{x = 1}^{\lfloor\frac n t\rfloor} [\gcd(x, y) = 1] \\&= \sum_{t = 1}^n G(\lfloor\frac n t\rfloor) \\ &= \sum_{t = 1}^n \sum_{d = 1}^{\lfloor\frac n t\rfloor} \mu(d) \lfloor\frac {n} {td} \rfloor \sum_{i = 1}^{\lfloor\frac n {td} \rfloor} [id \in A] \\ &= \sum_{d = 1}^n \mu(d) \sum_{t = 1}^{\lfloor\frac n {d} \rfloor}\lfloor\frac {n} {td} \rfloor \sum_{i = 1}^{\lfloor\frac n {td} \rfloor} [id \in A] \end{aligned} $$

观察 $F(n)$，我们注意到只有 $id \in A$ 时，对答案才有贡献。而 $id$ 只有素因子只可能有 $2, 5$ 的必要条件是 $d$ 的素因子只可能有 $2, 5$。换句话说，只有 $d$ 可以分解成 $2$ 的某个幂乘上 $5$ 的某个幂时对答案才可能有贡献。但是注意整个式子乘上了莫比乌斯函数 $\mu(d)$。在 $d$ 有平方因子时，$\mu(d)$ 为 $0$，对答案没有贡献。因此只有 $d = 1, 2, 5, 10$ 这四种情况时，整个式子对答案有贡献。

因此

$$\begin{aligned}F(n)  &= \sum_{d = 1, 2, 5, 10} \mu(d) \sum_{t = 1}^{\lfloor\frac n {d} \rfloor}\lfloor\frac {n} {td} \rfloor \sum_{i = 1}^{\lfloor\frac n {td} \rfloor} [id \in A] \end{aligned} $$

注意到当 $d \neq 1$ 时，因为 $d \in A$，所以 $id \in A$ 的充要条件是 $i = 1$ 或 $i \in A$。设 $B = A \bigcup \{1\}$，则有 

$$\begin{aligned}F(n)  &= \sum_{d = 1, 2, 5, 10} \mu(d) \sum_{t = 1}^{\lfloor\frac n {d} \rfloor}\lfloor\frac {n} {td} \rfloor \sum_{i = 1}^{\lfloor\frac n {td} \rfloor} ([i \in B] - [d = 1][i = 1]) \\ &= \sum_{d = 1, 2, 5, 10} \mu(d) \sum_{t = 1}^{\lfloor\frac n {d} \rfloor}\lfloor\frac {n} {td} \rfloor (H(\lfloor\frac {n} {td} \rfloor) - [d = 1])\end{aligned} $$

其中 $H(x)$ 表示 $B$ 中不大于 $x$ 的元素个数。这里要减掉 $[d = 1][i = 1]$ 的原因是当 $d = i = 1$ 时，$i \in B$，但是 $id \in A$，不能产生贡献。

考虑如何计算 $H(x)$：如果能算出 $B$ 集合中不大于给定的 $n$ 的所有元素，就能快速计算 $H(x)$。注意到 $B$ 集合中不大于 $n$ 的元素可以这样构造：首先写出所有不大于 $n$ 的 $2$ 的幂的值，放入 $B$ 集合，再将每一个 $2$ 的幂不断乘 $5$ 直到结果大于 $n$，将得到的所有数字都放入 $B$ 集合。这样就可以不重不漏的得到 $B$ 集合中不大于 $n$ 的所有元素。不大于 $n$ 的 $2$ 的幂共有 $O(\log n)$ 个，每个幂都最多乘 $O(\log n)$ 次 $5$ 就会大于 $n$，因此 $B$ 集合的元素个数不会超过 $O(\log^2 n)$。因此可以按照上述方法求出 $B$ 集合中的所有元素并排序，每次求 $H(x)$ 时在集合里 `std::upper_bound` 即可。

设

$$\begin{aligned} f(n) = \sum_{t = 1}^n \lfloor\frac{n}{t}\rfloor H(\lfloor\frac{n}{t}\rfloor) \end{aligned}$$

注意到 $f$ 是一个整除分块的形式，可以 $O(\sqrt n \log \log ^2 n)$ 求出它的值。其中 $O(\log \log^2 n)$ 是在一个长度为 $O(\log^2 n)$ 的数组上进行 `std::upper_bound` 求 $H$ 的复杂度。

则

$$\begin{aligned} F(n)  &=   \sum_{d = 1, 2, 5, 10} \mu(d)  f(\lfloor\frac {n} {d} \rfloor) - [d = 1] \sum_{t = 1}^{\lfloor\frac {n} {d} \rfloor}\lfloor\frac {n} {td} \rfloor \end{aligned} $$

就可以 $O(\sqrt n \log \log ^2 n)$ 求出了（后面那一项可以在乘除分块时一起处理）。

注意我们的 $F(n)$ 不包括化简后分母为 $1$ （即为整数）的情况，这些情况要单独累加答案。

对于整数 $i$，分子分母可以同乘 $1$ 到 $\lfloor \frac n i \rfloor$ 这些数，得到不同的分数。因此答案需要加上

$$\sum_{i = 1}^n \lfloor \frac n i \rfloor $$

这是一个非常标准的整除分块，直接计算即可。

二者累加，就可以得到最终答案。总时间复杂度 $O(\sqrt n \log \log^2 n)$。

P.S. dzy 鸽鸽以前好像教育过我莫比乌斯函数的一个意义就是某个容斥系数，所以这个反演做法是不是和官方的容斥做法本质相同啊，有没有鸽鸽来教育一下我啊 /dk

### Code

```cpp
#include <queue>
#include <vector>
#include <iostream>
#include <algorithm>

typedef long long int ll;

int mu[15];
const int dd[] = {1, 2, 5, 10};
std::queue<ll> Q;
std::vector<ll> v;

void GetMu();

inline ll CountSize(const ll x) {
  return std::upper_bound(v.begin(), v.end(), x) - v.begin();
}

int main() {
  ll n;
  std::cin >> n;
  for (ll t = 1; t <= n; t <<= 1) {
    Q.push(t);
  }
  for (ll u; !Q.empty(); Q.pop()) {
    v.push_back(u = Q.front());
    if ((u * 5) <= n) Q.push(u * 5);
  }
  GetMu();
  std::sort(v.begin(), v.end());
  ll ans = 0;
  for (ll i = 1; i <= n; ++i) {
    ll x = n / i, y = n / x;
    ans += (y - i + 1) * x;
    i = y;
  }
  for (int d : dd) {
    ll x = n / d;
    for (ll t = 1; t <= x; ++t) {
      ll a = x / t, b = x / a;
      ans += CountSize(a) * mu[d] * a * (b - t + 1);
      if (d == 1) ans -= a * (b - t + 1);
      t = b;
    }
  }
  std::cout << ans << std::endl;
  return 0;
}

void GetMu() {
  mu[1] = 1;
  mu[2] = mu[5] = -1;
  mu[10] = 1;
}
```

---

## 作者：_Atyou (赞：7)

## 算法：整除分块

#### Part 1 - Subtask1 (40分)

分析一下 $\frac{x}{y}$ 可以表示为十进制有限小数的条件 : 

若 $\frac{x}{y}$ 可以表示为十进制有限小数，则存在 $k$ 使得 $\frac{x \times 10^{k}}{y}$ 为整数。

考虑 $\frac{x}{y}$ 最简的情况（不是最简的可以化成最简）的情况下， $x$ 和 $y$ 已不含相同质因子，则 $y$ 在只含质因子 $2$ 或 $5$ 的情况下， $\frac{x}{y}$ 可以表示为十进制有限小数。

于是可以 $O(n^2)$ 枚举 $x$ 和 $y$ ，先约分，再判断 $y$ 是否只含质因子 $2$ 或 $5$ 即可。

复杂度貌似是 $O(n^2\log n)$

#### Part 2 - Subtask2 (80分)

考虑对于 $y$ ，$x$ 满足包含 $y$ 除了 $2$ 或 $5$ 之外的所有质因子，且每个质因子的个数大于等于 $y$ 中该质因子的个数。简单来说，就是 $y$ 去掉质因子 $2$ 或 $5$ 之后， $x$ 是 $y$ 的倍数。

对于每个 $y$，这样的 $x$ 为 $\lfloor \frac{n}{\frac{y}{2^α \times 5^β}} \rfloor$ 个。则题目变成统计 $\sum_{i=1}^n \lfloor \frac{n}{\frac{i}{2^α \times 5^β}} \rfloor$， $α$ 和 $β$ 对应 $i$ 中 $2$ 和 $5$ 的质因子个数。

复杂度貌似是 $O(n\log n)$

#### Part 3 - Subtask3 (100分)

##### 前置知识 ： 整除分块（已补充于文章结尾，已经掌握的可以忽略，并确保掌握后再阅读 Part 3 的内容）

考虑更快的计算 $\sum_{i=1}^n \lfloor \frac{n}{\frac{i}{2^α \times 5^β}} \rfloor$ 这个式子。感觉它很像能整除分块的形式 $\sum \lfloor \frac{n}{i} \rfloor$。

令 $\frac{i}{2^α \times 5^β}=t$ ，就差不多能用整除分块来处理了。


但注意这里 $t$ 是有限制条件的 : 

1. $t \times 2^α \times 5^β = i  \le n$ 得到 $t \le \lfloor \frac{n}{2^α \times 5^β} \rfloor$
2. $t$ 不含质因子 $2$ 和 $5$

则题目变成枚举 $α$ 和 $β$ 利用整除分块快速统计 $\sum_{t=1}^{\lfloor \frac{n}{2^α \times 5^β} \rfloor } \lfloor \frac{n}{t} \rfloor$ 再累加即可。

至于怎么枚举 $α$ 和 $β$ ， 发挥对数的功底即可。（具体可参考程序里的循环语句，对应 $i$ 和 $j$）

至于怎么剔除含质因子 $2$ 和 $5$ 的数，用容斥原理即可。（具体可参考程序里的 $calc$ 函数）

复杂度算不太懂，貌似是 $O(\sqrt n + \log^3 n)$

补充 ： 其实可以发现枚举 $α$ 和 $β$ 时改变的只是整除分块 $t$ 的上限，所以可以优先处理出整除分块的分块端点和前缀和，要统计时直接利用二分，加上完整块的和，再补上不完整的一部分即可。这样去掉了枚举 $α$ 和 $β$ 里整除分块的那层循环，用二分降下时间复杂度，才得以顺利通过此题。

#### Part 3 code ： 
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 2000000 + 5;

typedef long long LL;

LL power(LL a, LL b) {
	LL ans = 1;
	for (; b; b >>= 1, a *= a)
		if (b & 1) ans *= a;
	return ans;
}

LL n, ans, pos[MAXN], sum[MAXN];

LL calc(LL l, LL r) {
	return (r - l + 1 - r / 2 + (l - 1) / 2 - r / 5 + (l - 1) / 5 + r / 10 - (l - 1) /  10);
}

int main() {
	cin >> n;
	int cnt = 0;
	for (LL l = 1, r; l <= n; l = r + 1) {
		pos[++cnt] = r = n / (n / l);
		sum[cnt] = sum[cnt - 1] + calc(l, r) * (n / l);
	}
	int p2 = log(n) / log(2); LL t1 = power(2, p2); 
	for (int i = p2; i >= 0; --i, t1 /= 2) {
		int p5 = log(n / t1) / log(5); LL t2 = power(5, p5);
		for (int j = p5; j >= 0; --j, t2 /= 5) {
			LL lim = n / t1 / t2;
			int x = lower_bound(pos + 1, pos + cnt + 1, lim) - pos - 1;
			ans += sum[x] + calc(pos[x] + 1, lim) * (n / lim);
		}
	}
	cout << ans << endl;
	return 0;
}

```

#### Part X : 整除分块

有些时候会遇上形如 $\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor$ 的式子， $O(n)$ 是最显而易见的统计方法。

但当 $n$ 的值很大的时候， $O(n)$ 显然不能满足需要。

考虑用 $O(n)$ 的方式打表找找关于 $\lfloor \frac{n}{i} \rfloor$ 的规律。

当 $n=10$ 时，大概是这样的

| n | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $\lfloor \frac{n}{i} \rfloor$ | 10 | 5 | 3 | 2 | 2 | 1 | 1 | 1 | 1 | 1 |

可以发现有许多相等的 $\lfloor \frac{n}{i} \rfloor$连在一块，形象来说成块状分布。

于是我们针对那些$\lfloor \frac{n}{i} \rfloor$相等的块，确定左右端点 $l$ 和 $r$，就可以分块处理了。对于每个块的总和是 $(r-l+1) \times \lfloor \frac{n}{i} \rfloor $

左端点只要在上一个块的右端点上加 $1$ 即可，而右端点是对于 $\lfloor \frac{n}{i} \rfloor$ 最大的 $i$, 可以发现为 $r=\lfloor \frac{n}{\lfloor \frac{n}{l} \rfloor} \rfloor$ (可以自己尝试证明)

对于 $\lfloor \frac{n}{i} \rfloor$ 最多只有 $2 \sqrt n $ 种取值，所以整除分块的时间复杂度是 $O( \sqrt n )$

#### Part X code : 
```cpp
for (int l = 1, r; l <= n; l = r + 1) {
	r = n / (n / l);
	ans += (r - l + 1) * (n / l);
}
```


---

## 作者：August_Light (赞：6)

# P6583 回首过去 题解

[题目传送门](https://www.luogu.com.cn/problem/P6583)

好题。

更新（2023-12-05）：把代码和 $\LaTeX$ 改得更好看了。

## 题意简述

给定正整数 $n$，求出有序整数对 $(x, y)$ 的个数，满足 $1 \le x,y \le n$ 且 $\dfrac x y$ 可以表示为十进制有限小数。

$1 \le n \le 10^{12}$。

## 前置知识

- 数论分块

## 解法

### Subtask 1 $O(n^2 \log n)$

根据小学奥数知识可知，一个分数在十进制下为有限小数，当且仅当约分后的分母的质因数分解只有 $2$ 和 $5$。

暴力验证每一个范围内的分数。

### Subtask 2 $O(n \log n)$

根据上文的结论，设 $y = 2^a 5^b d, x = \lambda d$。**其中 $d$ 与 $2$ 和 $5$ 互质**。

首先需要知道这样一件事：

记 $f(x)$ 为 $[1,x]$ 中有几个数是 $2^a 5^b$ 的形式，其中 $a,b$ 可以等于 $0$。

我们可以在 $O(\log n)$ 的时间内快速计算 $f(n)$：

$$f(n) = \sum\limits_{i=0}^{\log_2 n} \left(\left\lfloor\log_5 \dfrac n {2^i}\right\rfloor+1\right)$$

在代码中 $\log_5 x$ 可以用 $\dfrac {\ln x}{\ln 5}$ 来计算。

```cpp
ll f(ll x) {
    ll ret = 0;
    for (ll i = 0; (1ll << i) <= x; i++)
        ret += ll(log(x >> i) / log(5)) + 1;
    return ret;
}
```

记 $val = \left\lfloor \dfrac n d \right\rfloor$。

所以我们可以枚举 $d$，那么 $y$ 的个数即为 $f(val)$，$x$ 的个数即为 $val$。

即答案为：

$$\sum\limits_{d=1}^n [2 \nmid d][5 \nmid d] \times f(val) \times val$$

```cpp
        ll ans = 0;
        for (ll d = 1; d <= n; d++) {
            if (d % 2 == 0 || d % 5 == 0)
                continue;
            ll val = n / d;
            ans += val * f(val);
        }
        cout << ans << '\n';
```

### Subtask 3 $O(\sqrt n \log n)$

注意到 $val$ 的形式长得很像数论分块，考虑使用数论分块将其加速到根号级别。

在 $val$ 为定值的区间内，$f(val) \times val$ 为一定值，但是 $[2 \nmid d][5 \nmid d]$ 会变。

也就是说，我们需要知道在一个区间 $[l,r]$ 内有几个数满足 $2 \nmid d$ 且 $5 \nmid d$。

考虑前缀和，设 $g(x)$ 为 $[1,x]$ 内有几个数满足 $2 \nmid d$ 且 $5 \nmid d$。

根据容斥，有 $g(x) = x - \left\lfloor \dfrac x 2 \right\rfloor - \left\lfloor \dfrac x 5 \right\rfloor + \left\lfloor \dfrac x {10} \right\rfloor$。

区间 $[l,r]$ 内满足 $2 \nmid d$ 且 $5 \nmid d$ 的数的个数则为 $g(r) - g(l-1)$。

此时可以使用数论分块了。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

ll f(ll x) {
    ll ret = 0;
    for (ll i = 0; (1ll << i) <= x; i++)
        ret += ll(log(x >> i) / log(5)) + 1;
    return ret;
}

ll g(ll x) {
    return x - x / 2 - x / 5 + x / 10;
}

int main() { ios::sync_with_stdio(0); cin.tie(0);
    ll n; cin >> n;
    ll ans = 0;
    for (ll l = 1, r; l <= n; l = r + 1) {
        ll val = n / l;
        r = n / val;
        ans += (g(r) - g(l-1)) * val * f(val);
    }
    cout << ans << '\n';
    return 0;
}
```


---

## 作者：NaCly_Fish (赞：5)

感觉今天被这题打成 SB 了，，写篇题解纪念一下。
****
首先不难想到，对于**最简分数** $\dfrac{x}{y}$，若能表示为有限小数，则 $y$ 必然能表示为 $2^a5^b$ 的形式。

那么枚举 $a,b$ 把下面这个和式的结果都加起来，即是答案：

$$\sum_{i=1}^n\sum_{j=1}^n \left[ \frac{i}{\gcd(i,j)}=2^a5^b\right]$$
发现 $i$ 一定是 $2^a5^b$ 的倍数，可以化为：

$$\sum_{k=1}^{n/2^a5^b}\sum_{j=1}^n[\gcd(2^a5^bk,j)=k]$$
把后一个和式中的 $k$ 除掉，就有
$$\sum_{k=1}^{n/2^a5^b}\sum_{j=1}^{n/k}[\gcd(2^a5^b,j)=1]$$
由于只有 $2,5$ 两个因子，后面就容易展开
$$\sum_{k=1}^{n/2^a5^b}(n/k)-[a>0](n/k)/2-[b>0](n/k)/5+[ab>0](n/k)/10$$
（除法向下取整）  

由此就能得到 80 分代码
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#define ll long long
#define reg register
using namespace std;

ll n,ans;

inline ll solve(ll a,ll b){
    ll res = 0,lim = n/(a*b),tmp,d;
    for(reg ll l=1,r;l<=lim;l=r+1){
        d = n/l;
        tmp = d,r = n/d;
        if(a>1) tmp -= d/2;
        if(b>1) tmp -= d/5;
        if(a>1&&b>1) tmp += d/10;
        res += tmp*(r-l+1);
    }
    return res;    
}

int main(){
    scanf("%lld",&n);
    for(reg ll a=1;a<=n;a<<=1)
    for(reg ll b=1;a*b<=n;b*=5)
        ans += solve(a,b);
    printf("%lld",ans);
    return 0;   
}
```
优化成满分做法其实很简单，，，注意到和式中虽然上界在变，但其中 $n/k$ 的形式没变。

所以就把除法分块中每一段预处理好，做个前缀和，这样对每一组 $a,b$ 就可以 $\Theta(\log n)$（即 lower\_bound 的复杂度）计算。

时间复杂度应该是 $\Theta(\sqrt n + \log^3n)$。

满分做法（可以不用编译优化）：  
```cpp
#pragma GCC optimize (2)
#pragma GCC optimize ("unroll-loops")
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
#define N 1000003
#define ll long long
#define reg register
using namespace std;

struct node{
    ll s1,s2,s5,s10;
}pre[N<<1];

ll R[N<<1];
int cnt;

inline void prepare(ll n){
    ll d;
    for(reg ll l=1,r;l<=n;l=r+1){
        d = n/l,++cnt;
        R[cnt] = r = n/d;
        pre[cnt].s1 = d*(r-l+1),pre[cnt].s2 = (d/2)*(r-l+1);
        pre[cnt].s5 = (d/5)*(r-l+1),pre[cnt].s10 = (d/10)*(r-l+1);
    }
    for(reg int i=2;i<=cnt;++i){
        pre[i].s1 += pre[i-1].s1,pre[i].s2 += pre[i-1].s2;
        pre[i].s5 += pre[i-1].s5,pre[i].s10 += pre[i-1].s10;
    }
    R[cnt+1] = 1ll<<60;
}

ll n,ans;

inline ll solve(ll a,ll b){
    ll r,d,res = 0,lim = n/(a*b);
    int pos = upper_bound(R+1,R+cnt+2,lim)-R-1;
    r = R[pos],d = n/(r+1);
    res = pre[pos].s1+d*(lim-r);
    if(a>1) res -= pre[pos].s2+(d/2)*(lim-r);
    if(b>1) res -= pre[pos].s5+(d/5)*(lim-r);
    if(a>1&&b>1) res += pre[pos].s10+(d/10)*(lim-r);
    return res;    
}

int main(){
    scanf("%lld",&n);
    prepare(n);
    for(reg ll a=1;a<=n;a<<=1)
    for(reg ll b=1;a*b<=n;b*=5)
        ans += solve(a,b);
    printf("%lld",ans);
    return 0;   
}
```

---

## 作者：EAlivn (赞：4)



**解析问题**

若$(\dfrac{x}{y})$是十进制有限小数, 则 $(\dfrac{y}{gcd(x,y)})$ 的质因子只有 $2$ 和 $5$.

枚举 $i,j,d$ , 表示 $y=2^i5^j*d$ , 则 $x$ 的数量为 ⌊$(\dfrac{n}{d})$⌋ , 可以数论分块.

枚举 $d$ 的时候, 需要满足 $d$ 不能整除 $2$ 或 $5$ , 所以数论分块的时候要容斥一下.

因为每 $10$ 个数中必定有 $6$ 个数是 $2$ 或 $5$ 的倍数, 所以数论分块的时候先处理整十的部分, 对于剩下的暴力枚举一下即可.


```C++
#include<bits/stdc++.h>
using namespace std;
long long q[40000],cnt,tmp;
bool cmp(long long x,long long y) {
	return x>y;
}
inline long long read() {
	long long x;
	scanf("%lld",&x);
	return x;
}
int main() {
	long long n=read();
	long long t1=0,t2=1,t3=t1,t4=3,t5=t4;
	while(t2<=n) {
		t5=1;
		while(t2*t5<=n){
			q[++cnt]=t2*t5;
			long long tmp=5;
			t5*=tmp;
		}
		long long tmp=2;
		t2*=tmp;
	}
	long long sum=0;
	q[0]=n+1;
	sort(q+1,q+1+cnt,cmp);
   long long ans=0;
	for(int p=1; p<=cnt; p++) {
		for(long long i=n/q[p-1]+1,j; i<=n/q[p]; i=j+1) {
			j=min(n/q[p],n/(n/i));
			long long k=(j-i+1)/10,num=4*k;
			for(k=i+k*10; k<=j; k++)
				if(k%2&&k%5) num++;
			sum+=num*(n/i);
		}
		ans+=sum;
	}
	printf("%lld\n",ans);
	return 0;
}
```

这是我的第一篇题解,求通过!

---

## 作者：Mophie (赞：4)

emmm……这题是个月赛题呢……

考试时候想了大约2个小时，最后想出来个奇奇怪怪的算法（？）

反正跑得也不慢，考试时候加上O3更快了……

那接下来就大概讲讲我的思路吧

先搞清楚这个问题：怎么使$x/y$是个十进制有限小数？

你可以~~BFS(Baidu First Search)或者凭借义务教育的经验~~得到：

将这个分数约分成最简分数，当分母为一个$2^{x}5^{y}$形式时即可。

## Subtask1:$n<=1e3$

嗯……有了上面的铺垫，$O(n^2logn)$应该不是很难想吧

直接暴力即可。

## Subtask2:$n<=1e7$

这里就需要一点想法，就是我该怎么将一部分的$O(n)$->$O(1)$。

我们可以固定分母y，然后看看怎么算出有几种x的取法。

首先当它有个2时或有个5时都不重要，因为多出一个2或5无所谓。

所以一个分母y对应多少个x等同于把所有的2和5都干掉后的y对x。

那么现在我们可以得到一个y使得与2,5互质。我们可以发现若分子不是y的倍数的话那么就不可能是最简的。

那么就是从1~n中可以被y整除的数的个数喽。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int isbad(int x)
{
	while(x%2==0)x/=2;
	while(x%5==0)x/=5;
	return x;
}
int n;
long long ans;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int k=isbad(i);
		ans+=n/k;
	} 
	cout<<ans<<endl;
	return 0;
}
```

## Subtask 3:$n<=1e12$

根据上道题我们会发现最后是一个整除类型的求和。

想到分块了没有？

我们可以把这个n分成$[1,1]$,$[2,2]$……$[\sqrt{n},\sqrt{n}]$,……,$[n/3,n/2],$$[n/2,n]$

我们可以首先先把所有与2和5互质的数的和给求出来。

每一块中有这样的数的个数十分好求，而且每个这样的数除n都是相等的，所以我们能够十分轻易的求出。

但现在问题来了：怎么求2或5的倍数呢？

我们拿9举个栗子：

先分成了$[1,1]$,$[2,2]$,$[3,3]$,$[4,4]$,$[5,9]$这样5块

那么比如说2,4,5，**我们可以通过1转移过来**

接下来只要统计有多少个数可以从1跳过来即可。

先把这部分的代码放一下：

```cpp
long long cal(long long x)
{
	long long res=1,now=1,tot=0;
	while(res*2*x<=n)res*=2,now++;
	tot+=now;
	while(res%2!=1&&res!=0)
	{
		while(res*5*x>n&&res%2==0)res=res/2,now--;
		if(res*5*x>n)break;
		res*=5,tot+=now;
	}
	return tot;
}
```
再解释一下：

我首先先是1，然后可以统计$5^0$时可以到几个$2^x$次，$5^1$次……就这样往下。

这大概就是cal函数的主要动能，就是统计包括它自己有多少个数可以从1跳过来。

那么应该讲的够清晰的，不懂的看看注释吧。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,p[1000009],q;
long long ans,i;
long long cal(long long x)//核心部分 
{
	long long res=1,now=1,tot=0;//res就是2^x，now是当为res是有几种方法可以扩展，tot是统计答案 
	while(res*2*x<=n)res*=2,now++;//算出可以扩展到2的几次方 
	tot+=now;
	while(res%2!=1&&res!=0)//当res是5^y就可以直接跳出了 
	{
		while(res*5*x>n&&res%2==0)res=res/2,now--;
		if(res*5*x>n)break;
		res*=5,tot+=now; 
	}
	return tot;
}
long long sum(long long L,long long R)
{
	L--; 
	return (R-(R/2+R/5-R/10))-(L-(L/2+L/5-L/10));
}//统计[l,r]中有多少个时只要算[1,r]-[1,l-1]即可 
long long l,r;
signed main()
{
	cin>>n;
	for(i=1;i*i<=n;i++)//单独枚举 
	{
		if(i%2==0||i%5==0)continue; 
		ans+=cal(i)*(n/i);//有多少个与它的值 
	}
	for(i=1;(i+1)*(i+1)<=n;i++)
	{
		l=n/(i+1)+1,r=n/i;//左区间右区间的分界点不要搞错 
		ans+=cal(r)*sum(l,r)*(n/l);//cal(r)是可以拓展几个数，sum(i,j)是有多少个与2,5互质的数，(n/l)为它的值 
	}
	l=n/(i+1)+1,r=n/i;
	if(l*l>n)ans+=cal(r)*sum(l,r)*(n/l);//临界点单独考虑 
	cout<<ans<<endl;//输出答案 
	return 0;//完结撒花 
}
```


---

## 作者：EternalEpic (赞：3)

题目要求要枚举十进制有限小数，认真听过小学数学课的童鞋都知道，形如 $\dfrac{a}{b}$ 且 $b / \gcd(a, b)$只有2和5两种质因子的分数可为十进制有限小数。

来变个形：$\dfrac{bc}{ac}$ 其中$a$含2和5两种质因子，而$c$不含任何2和5质因子。

我们只需要去枚举满足条件的$c$,然后在$\left\lfloor\frac{n}{c}\right\rfloor$ 的范围内枚举合法的$a$的个数。

令$a$的个数为$d$，则最后答案就是： $\sum \left\lfloor\frac{n}{c}\right\rfloor d_{\left\lfloor\frac{n}{c}\right\rfloor}$

至此我们已经得到了趋近于线性复杂度的算法，可以过Subtask1和2了，你有了快乐的80分。

$80 scores' CODE$ :

```cpp
ll n, ans = 0;

signed main(void) {
//	file("");
	read(n);
	for (ll i = 1; i <= n; i++) { ll ret = 0;
		if (!(i % 2) || !(i % 5)) continue;
		for (ll j = 1; j <= n; j <<= 1) {
			for (ll k = 1; k <= n; k *= 5) {
				if (j * k * i > n) break; ++ret;
			}
		} ans += ret * (n / i);
	} writeln(ans);
//	fwrite(pf, 1, o1 - pf, stdout);
	return 0;
}
```

考虑进一步优化，令$f(i) = d_i$，则$ans = \sum f(\left\lfloor\frac{n}{ci}\right\rfloor)\left\lfloor\frac{n}{c}\right\rfloor $

我们惊讶地发现，这可以整除分块！！！

可是$c$的选取不连续，并不是$1-n$中每一个数都选，而要不含质因子2和5的数，就可以考虑容斥。

令$g(l, r, d)$为当前区间中是$d$的倍数的数的个数。

先假设连续取值，计算答案，再在每一段上乘上一个系数（当前这段可以选的$c$的个数，拿$(r - l + 1) - g(l, r, 2) - g(l, r, 5) + g(l, r, 10) $）即可。

$100 scores' CODE$ :

```cpp
ll n, ans = 0;
inline ll f(ll x) { ll ret = 0;
	for (ll i = 1; i <= x; i <<= 1)
		for (ll j = 1; j <= x; j *= 5) {
			if (i * j > x) break; ++ret;
		} return ret;
}

#define g(l, r, d) (r / d - (l - 1) / d)

signed main(void) {
//	file("");
	read(n);
	for (ll l = 1, r; l <= n; l = r + 1) {
		r = n / (n / l);
		ans += (ll)((r - l + 1) - g(l, r, 2) - g(l, r, 5) + g(l, r, 10)) * f(n / l) * (n / l);
	} writeln(ans);
//	fwrite(pf, 1, o1 - pf, stdout);
	return 0;
}
```


---

## 作者：fsy_juruo (赞：3)

upd:时间复杂度写错，已经修正。

### 40 pts

枚举 $x$，$y$，看 $\frac{x}{y}$ 是否为有限小数。

时间复杂度 $O(n^2 \log n)$，预计得分 $40$ 分。

### 80 pts

由学龄前数学可知：一个最简分数 $\frac{x}{y}$，当且仅当 $y = 2^i5^j (i,j \geq 0)$ 时，该分数为有限小数。

故考虑枚举分母 $y$，将其表示为 $2^i5^j \times g$ 的形式，所以只有当分子 $x$ 是 $g$ 的倍数时，原分数是有限小数。又因为 $x \leq n$，故符合条件的 $x$ 有 $\lfloor \frac{n}{g} \rfloor$ 个。

故答案为 $\sum_{i=1}^{n} \lfloor \frac{n}{g} \rfloor$，$O(n)$ 计算即可。预计得分 $80$ 分。

### 100 pts

即使 $n$ 很大，但是 $\lfloor \frac{n}{g} \rfloor$ 的可能取值只有 $2 \sqrt{n}$ 种。

为什么？我们取 $s = \sqrt{n}$，则对于 $i \leq s$，总共只有 $s$ 个数，故此部分最多有 $s$ 种取值。而对于 $i > s$，有 $\frac{n}{i} < \sqrt{n}$，故此部分最多有 $s$ 种取值。综上，$\lfloor \frac{n}{g} \rfloor$ 的可能取值只有 $2 \sqrt{n}$ 种。

考虑分类处理。

对于 $g \leq \sqrt{n}$，可以考虑枚举 $g$，算出除尽所有 $2$，$5$ 后，正好为 $g$ 的数字的个数 $cnt$，故这个 $g$ 对答案的贡献为 $cnt \times \lfloor \frac{n}{g} \rfloor$。至于 $cnt$ 的计算，由于 $2^{40} > 10^{12}$，$5^{18} > 10^{12}$，可以暴力枚举二者的指数，也可以枚举其中一个数的指数，用 $\log$ 算出第二个指数的取值范围。

对于 $g > \sqrt{n}$，考虑枚举 $\lfloor \frac{n}{g} \rfloor$ 的值，算出 $g$ 的取值范围后，再算出这个范围中，完全不含质因子 $2$，$5$ 的数字数量 $Num$，再算出除尽所有 $2$，$5$ 后，正好为 $g$ 的数字的个数 $cnt$，则此部分对答案的贡献为 $Num \times cnt \times \lfloor \frac{n}{g} \rfloor$。

啥，你问我 $g$ 不同怎么算 $cnt$？其实对于同一个区间的 $g$，其 $cnt$ 都相同。

为什么？因为我们本质上是要算出满足 $2^i5^j \times g \leq n$ 的 $(i,j)$ 数对的个数。移项变成 $2^i5^j \leq \frac{n}{g}$。左边是整数，故 $2^i5^j \leq \lfloor \frac{n}{g} \rfloor$。同一段区间中的 $\lfloor \frac{n}{g} \rfloor$ 相等，故同一个区间的 $g$，其 $cnt$ 都相同。

综上，两部分时间复杂度均为 $O(\sqrt{n})$，总时间复杂度为 $O(\sqrt{n})$，预计得分 $100$ 分。

**代码：**

```cpp
#include <bits/stdc++.h>
#pragma GCC optimize(2)
#define byfakioi true
#define srftxdy true
#define _rep(i, x, y) for(int i = x; i <= y; i++)
#define _per(i, x, y) for(int i = x; i >= y; i--)
#define LL long long
using namespace std;
template <typename T>
inline void read(T &x) {
    x = 0; T f = (T) 1;
    char c = getchar();
    for (; !isdigit(c); c = getchar())
        if (c == '-') f = -f;
    for (; isdigit(c); c = getchar()) x = x * 10 + c - 48;
    x *= f;
}
template <typename T>
inline void write(T x) {
	if(x < 0) {putchar('-'); x = -x;}
	if(x > 9) write(x / 10);
	putchar(x % 10 + '0');
}
template <typename T>
inline void writesp(T x, char sp = '\n') {
	write(x); putchar(sp);
}
LL gcd(LL x, LL y) {
	if(!x || !y) return x + y;
	return gcd(y, x % y);
}
int flg[3000010];
int log5(LL x) { // 浮点数的 log 太慢了所以暴力写了个 log
	if(x < 5) return 0;
	if(x < 25) return 1;
	if(x < 125) return 2;
	if(x < 625) return 3;
	if(x < 3125) return 4;
	if(x < 15625) return 5;
	if(x < 78125) return 6;
	if(x < 390625) return 7;
	if(x < 1953125) return 8;
	if(x < 9765625) return 9;
	if(x < 48828125ll) return 10;
	if(x < 244140625ll) return 11;
	if(x < 1220703125ll) return 12;
	if(x < 6103515625ll) return 13;
	if(x < 30517578125ll) return 14;
	if(x < 152587890625ll) return 15;
	if(x < 762939453125ll) return 16; 
	else return 17;
}
int main() {
	LL n; read(n);
	int Q = (int)sqrt(n);
	LL ans = 0;
	_rep(i, 1, Q) {
		LL y = i;
		while(!(y & 1ll)) y >>= 1ll;
		while(!(y % 5ll)) y /= 5ll;
		if(flg[y]) continue;
		flg[i] = 1;
		LL Pos = 0ll;
		LL P = n / i;
		_rep(j, 0, 39) {
			if(j) P >>= 1ll;
			if(P == 0) break;
			int q = log5(P) + 1;
			Pos += q;	
		}
		ans += (Pos) * (n / i);
	}
	_per(i, n / (Q + 1), 1) {
		LL Lb = n / (i + 1) + 1;
		LL Rb = n / i;
		LL Len = Rb - Lb + 1;
		LL Div2 = Rb / 2 - (Lb - 1) / 2;
		LL Div5 = Rb / 5 - (Lb - 1) / 5;
		LL Div10 = Rb / 10 - (Lb - 1) / 10;
		LL Pos = 0; LL P = i; 
		_rep(j, 0, 39) {
			if(j) P >>= 1ll;
			if(P == 0) break;
			Pos += log5(P) + 1;
		}
		ans += 1ll * Pos * i * (Rb - Lb + 1 - Div2 - Div5 + Div10); // 容斥原理计算 num
	}
	writesp(ans);
	return 0;
}
```

---

## 作者：littleKtian (赞：3)

做这题你首先要知道的数学知识：

一个分数要能被表示成**十进制有限小数**，**当且仅当**这个分数**被化简至最简分数时分母**可以被表示成 $2^p\times 5^q(p,q\in N)$。

设 $f(x)$ 为最大的满足 $f(x)\mid x,2\nmid f(x),5\nmid f(x)$ 的正整数，利用 [OEIS](http://oeis.org/) 可以发现 $f(x)$ 就是[数列A132740](http://oeis.org/A132740)~~（然而这并没有什么用。）~~。

容易发现所有形如 $\dfrac{k\times f(x)}{x}(k,x\in N^+)$ 的分数都可以表示成十进制有限小数。结果即为 $\sum\limits_{i=1}^{n}\left\lfloor\dfrac{n}{f(i)}\right\rfloor$。

发现 $f(x)$ 容易 $O(n)$ 求出，于是就有了一个比较简单的 $O(n)$ 做法。不过这还不是我们想要的做法。

因为 $\sum\limits_{x=1}^n\left\lfloor\dfrac{n}{x}\right\rfloor$ 是可以利用整除分块做到 $O(\sqrt n)$ 求出的，所以考虑是否可以用类似的方法求出之前的式子。

我们分成以下几步来求解：

1. 求满足 $f(i)=k$（$k$ 为定值）的 $i$ 的个数。

+ 若 $k$ 能被 $2$ 或 $5$ 整除，显然无解。

+ 若 $k$ 不被 $2$ 或 $5$ 整除，容易发现所有的 $i=k\times 2^p\times 5^q$ 都满足，而满足的 $2^p\times 5^q$ 的个数很容易求出。

+ 因为 $1 \leqslant i\leqslant n$，所以只要求出 $1$ 到 $\left\lfloor\dfrac{n}{k}\right\rfloor$ 范围内满足的数即可。

2. 求 $l$ 到 $r$（$l,r$ 给定）范围内不被 $2$ 或 $5$ 整除的数的个数。

+ 设 $g(x)$ 为 $1$ 到 $x$ 之间不能被 $2$ 或 $5$ 整除的数的个数（$g(0)=0$），显然结果为 $g(r)-g(l-1)$。

+ 容易发现 $g(x)=x-\left\lfloor\dfrac{x}{2}\right\rfloor-\left\lfloor\dfrac{x}{5}\right\rfloor+\left\lfloor\dfrac{x}{10}\right\rfloor$（可以用容斥证明）。

现在考虑对目标式子求解。

设 $h(x,k)$ 表示 $1$ 到 $k$ 之间 $f(i)=x$ 的个数。

$\sum\limits_{i=1}^{n}\left\lfloor\dfrac{n}{f(i)}\right\rfloor=\sum\limits_{i=1}^{n}h(i,\left\lfloor\dfrac{n}{i}\right\rfloor)\times\left\lfloor\dfrac{n}{i}\right\rfloor$。

结合上面的 1 和 2 可以求出 $h(i,\left\lfloor\dfrac{n}{i}\right\rfloor)$。

上面式子就可以利用整除分块求出了。

最劣复杂度 $O(\sqrt n \log^2 n)$，实际上跑不满。

主要部分代码如下。

```cpp
ll f(ll x){return x/2+x/5-x/10;}
ll g(ll x){return x-f(x);}
ll ff(ll x)
{
	ll xx=0;
	for(ll i=1;i<=x;i*=5)
	{
		ll j=i;
		while(j<=x)++xx,j<<=1;
	}
	return xx;
}
int main()
{
	n=dr();
	for(ll i=1;i<=n;i++)
	{
		ll k=n/i,j=n/k;
		ans+=(g(j)-g(i-1))*ff(k)*k,i=j;
	}
	printf("%lld",ans);
}
```


---

## 作者：Erotate (赞：2)

### Solution

首先我们来想一想在什么情况下，$\dfrac{x}{y}$ 可以表示为十进制有限小数。我们令 $t=\gcd(x,y)$ 则如果 $\dfrac{y}{t}=2^p \times 5^q$，其中 $p,q$ 为正整数，$\dfrac{x}{y}$ 就是一个十进制有限小数。

然后我们先把 $1$ 到 $n$ 以内所有只含质因数 2 和 5 的数处理出来（其实就是枚举 $p$ 和 $q$），存入一个数组  $a$ 里。之后我们考虑枚举这个 $t$，那么这时候符合要求的数的个数就是小于等于 $\dfrac{n}{t}$ 的 $a$ 的个数，最后累计一下答案即可。

显然，可以使用**数论分块**来枚举 $t$，这样时间复杂度就是 $O(\sqrt n)$ 的，可以通过。

### code
```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
const int N=1e5+5;
int n,m,a[N],ans;
signed main(){
	ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i<<=1)
		for(int j=i;j<=n;j*=5) a[++m]=j;//处理出符合要求的数
	sort(a+1,a+m+1);//因为枚举的 t 是单调递增的，所以给 a 数组排一下序会更方便
	for(int l=1,r;l<=n;l=r+1){//数论分块
		int tmp=n/l;
		r=(tmp?n/tmp:n);
		while(m && a[m]>tmp) m--;
		ans+=((r-l+1)-(r/2-(l-1)/2)-(r/5-(l-1)/5)+(r/10-(l-1)/10))*m*tmp;//这里就是统计符合要求的答案，运用到了容斥原理来求，读者可以自己想一想为什么要这样统计。
	}
	cout<<ans<<endl;
	return 0;
}

```


---

## 作者：WanderOvO (赞：2)

题目大意：对于$x,y\in[1,n]$，求有多少对这样的有序对$(x,y)$，使得$\frac{x}{y}$能写成有限小数。

这里首先要知道一件事情：之所以一个分数$\frac{x}{y}$能够化成有限小数，是因为这个分数能够在保证分子为整数的情况下把分母化成$10^k$的形式。也就是说，$\frac{x}{y} $**化成最简分数之后**，$y$不能有$2,5$以外的素因子。才能将分数转化为有限小数。知道这个事情，才有可能得到比小Z高效的算法。

我们一步一步来：

## n=1e3

根据刚才说的那件事情，我们有一个朴素的想法是枚举$x,y$，然后利用$\gcd$化成最简分数$\frac{\frac{x}{\gcd(x,y)}}{\frac{y}{\gcd(x,y)}}$，再判断一下$y$是否有$2,5$之外的素因子。本算法复杂度$O(n^2log_2n)$ ，预计得分$40pts$。

代码如下：

```cpp
for(ll i=1;i<=n;i++){
	for(ll j=1;j<=n;j++){
		ll tmpj=j;
		ll g=gcd(i,j); 
		tmpj=j/g; //把分母除以gcd，得到化为最简分数时的分母
		while(tmpj%2==0){
			tmpj/=2;
		}
		while(tmpj%5==0){
			tmpj/=5;
		}
		if(tmpj==1){
			ans++;
		} 
	}
}
printf("%lld\n",ans);
```

于是我在考场上的得分也就止步于此。

## n=1e7

考完之后，正好我该学数学相关的算法了，所以这几天就做了一些数学相关的题目，见到了一些套路，于是又想出了$80pts$的解法。

数学题有一种套路是先写出最后结果的表达式，然后再化简式子简化运算。所以我先给出这个题目的结果：$ans=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}[\frac{i}{j}\ is\ finite\ decimal?1:0]$ 。

这道题给人的感觉是，分母比分子要重要，所以**先枚举分母，然后枚举合法的分子比较有目的性，可能枚举更少**。所以我们改变枚举顺序：$ans=\sum\limits_{j=1}^{n}\sum\limits_{i=1}^{n}[\frac{i}{j}\ is\ finite\ decimal?1:0]$ 。

根据前面的分析，当分母$j=2^p5^q(p\geq 0,q\geq0)$时，分子随便选，否则，分子就得保证把分母除了$2,5$之外的素因子消掉。也就是说，设$j=2^p5^qi$ ，其中$i\%2!=0,i\%5!=0$，则分子必须是$i$的整数倍。这样的话，我们就需要在知道$j=2^p5^qi$的情况下，看看$[1,n]$里面有多少$i$的倍数，显然这个数是$\lfloor\frac{n}{i}\rfloor$。所以结果就是$ans=\sum\limits_{j=1}^{n}\lfloor\frac{n}{i}\rfloor=\sum\limits_{j=1}^{n}\lfloor\frac{2^p5^qn}{j}\rfloor$ ，复杂度接近于$O(n) $ 。预期得分$80pts$。

代码如下：

```cpp
#include <bits/stdc++.h>
#define ll long long 
using namespace std;
int main(){
	ll n,ans=0;
	scanf("%lld",&n);
	for(ll j=1;j<=n;j++){
		ll tmp=j;
		while(tmp%2==0){
			tmp/=2;
		}
		while(tmp%5==0){
			tmp/=5;
		}
		ans+=(n/tmp);
	}
	printf("%lld\n",ans);
	return 0;
} 
```



## n=1e12

对于这个数据范围，在这几天做了一些数学题之后，我很容易想到可能需要整除分块，没学过整除分块的同学还请先自行学习一下。理解下面方法的基础是我们已经会用$O(\sqrt n)$的算法求$\sum\limits_{i=1}^{n}\lfloor\frac{n}{i}\rfloor$。

刚才部分分得到的计算式是$ans=\sum\limits_{i=1}^{n}[\frac{2^p5^qn}{i}]$ 。 这种式子有点像能够分块的样子。但是带着和$i$相关的$2^p5^q$，不太好处理，把$2^p5^q$拿到前面去更容易分块。在看了题目相关讨论帖之后，我发现可以把式子变成这样：$ans=\sum2^p5^q\sum\limits_{i=1}^{n}[\frac{n}{i}\ if\ i\%2!=0\ and\ i\%5!=0]$ 。这个式子的意思是，我们只枚举那些不含有$2,5$素因子的分母$i$，在我们选定了一个$i$之后，我们看在$[1,n]$里面有多少个能分解成$2^p5^q$的数，使得$2^p5^qi\leq n$。容易发现，对于相邻的一些$i$，对应的$2^p5^q$的个数是一样多的。

但是我们不能保证一个块内相邻的几个$i $都满足$i\%2!=0,i\%5!=0$，所以在分块统计时我们应该只让那些合法的$i$对于答案有贡献。

为了方便，我们记$f(n)$为$[1,n]$中的只含有$2,5$这两种素因子的数的个数，至于求法，我们可以先生成$[1,1e12]$内所有的形如$2^p5^q$的数，排一下序，然后对于特定的$n$，二分查找就能得到。引入$f(n)$函数之后，$ans=\sum\limits_{i=1}^{n}f([\frac{n}{i}])[\frac{n}{i}\ if\ i\%2!=0\ and\ i\%5!=0]$ 。

如果没有$i$的那两个限制，则某个块$[l,r]$的贡献当然就是$(r-l+1)*f([\frac{n}{i}])*[\frac{n}{i}]$ ，现在由于不合法，所以就不能无脑乘$r-l+1$，需要用一些方法统计一下$[l,r]$中有用的数的个数。**什么叫做有用的数呢？就是$[l,r]$中不含$2,5$两种素因子的数的个数**。我们知道，区间$[1,r]$中含有的某给定数$x$的倍数的个数是$\lfloor\frac{r}{x}\rfloor$ ，而$[l,r]$中的可以用前缀和，即$\lfloor\frac{r}{x}\rfloor-\lfloor\frac{l-1}{x}\rfloor$。 根据上面的分析，我们很容易算出来$[l,r] $中有多少个$2$的倍数，有多少个$5$的倍数，根据容斥原理，只要用$[l,r]$中所有的数的个数，减去$2$的倍数和$5$的倍数的个数，再加上$lcm(2,5)=10$的倍数的个数，就是有用的数的个数了。记$[l,r]$中有用的数的个数为$g$，则$[l,r]$的贡献就是$g*f([\frac{n}{i}])*[\frac{n}{i}]$。整个算法复杂度是$O(\sqrt nloglogn)$ 吧。

代码如下：

```cpp
#include <bits/stdc++.h>
#define ll long long 
using namespace std;
const int N=1e7+9;
const ll M=1e12+9;
ll only_2_5[N],cnt,n;
void get_2_5();
ll getf(ll x);
ll getg(ll l,ll r);
int main(){
	ll ans=0,l=1,r,f,g;
	scanf("%lld",&n);
	get_2_5(); //生成2^p5^q
	for(l=1;l<=n;l=r+1){
		r=(n/(n/l));
		f=getf(n/l);
		g=getg(l,r);
		ans+=f*g*(n/l);
	}
	printf("%lld\n",ans); 
	return 0;
} 
ll getg(ll l,ll r){
	ll g1,g2,g5,g10;
	g1=r-l+1; //[l,r]所有数个数
	g2=(r/2)-(l-1)/2; //[l,r]2的倍数个数
	g5=(r/5)-(l-1)/5; //[l,r]5的倍数个数
	g10=(r/10)-(l-1)/10;//[l,r]10的倍数个数
	return g1-g2-g5+g10; 
}
ll getf(ll x){
	return upper_bound(only_2_5,only_2_5+cnt,x)-only_2_5; //求f(x) 
}
void get_2_5(){
	for(ll i=1;i<M;i*=2){ //生成数
		for(ll j=i;j<M;j*=5){
			only_2_5[cnt++]=j;
		}
	}
	sort(only_2_5,only_2_5+cnt);
}
```



---

## 作者：Transfixion_ (赞：1)

题目链接：[$\texttt{Link}$](https://www.luogu.com.cn/problem/P6583)

为了美观，在行内公式中用 $x / y$ 表示 $\dfrac{x}{y}$。

## $\textbf{Description}$

给定 $n \le 10^{12}$，求出满足一下要求的有序整数对 $(x,y)$ 的个数：

- $x, y \in [1, n]$；

- $x / y$ 为十进制有限小数。

## $\textbf{Solution}$

根据小学数学，$x / y$ 为十进制小数 $\iff$ $x / y$ 化简后分母不含除 $2$ 和 $5$ 之外的质因子。

写成数学语言就是（下面 $p,q$ 均为整数）：

$$\dfrac{y}{\gcd(x, y)}=2^p\times 5^q$$

那么我们考虑先把所有「$2^p\times 5^q$ 型数」都预处理出来，扔到一个 `std::vector` 中。

然后枚举 $\gcd$，求出 $\le (n/\gcd)$ 的「$2^p\times 5^q$ 型数」的个数并累加进答案就完了。

设 $\le x$ 的「$2^p\times 5^q$ 型数」的个数为 $F(x)$，把上面的东西写成和式就是：

$$\sum_{\gcd}F\left(\left\lfloor\dfrac{n}{\gcd}\right\rfloor\right)\left\lfloor\dfrac{n}{\gcd}\right\rfloor$$

暴力可以做到 $\mathcal O(n)$。当然你应该用数论分块算这个和式，做到 $\mathcal O(\sqrt n)$。

我们设区间 $[l,r]$ 内 $d
$ 的倍数的个数为 $g(l,r,d)$，根据前缀和的思想有：

$$g(l,r,d) = \dfrac {r}{d}-\dfrac{l-1}{d}$$

容斥一下，区间 $[l,r]$ 内的「$2^p\times 5^q$ 型数」的个数就是（省略 $l,r$）：


$$g(1)-g(2)-g(5)+g(10)$$

全部乘起来然后累加即可。

---

- 记得开 `long long`；

- 二分比直接找慢一点，但这不重要。


## $\textbf{AC Code}$

```cpp
namespace Main {
	typedef long long i64;
	static i64 n, ans;
	static std::vector<i64> vec;
	#define g(s) (r / s - (l - 1) / s)
	
	static inline void main() {
		std::cin.tie(nullptr) -> sync_with_stdio(false);
		std::cin >> n;
		for(i64 p = 1; p <= n; p <<= 1) {
			for(i64 q = 1; p * q <= n; q *= 5) {
				vec.push_back(p * q);
			}
		}
		std::sort(vec.begin(), vec.end());
		for(i64 l = 1, r; l <= n; l = r + 1) {
			i64 f = n / l; r = f ? n / f : n;
			while(!vec.empty() && vec.back() > f) vec.pop_back();
//			vec.erase(std::upper_bound(vec.begin(), vec.end(), f), vec.end());
			ans += 1ll * vec.size() * (g(1) - g(2) - g(5) + g(10)) * f;
		}
		std::cout << ans << '\n';
		return ;
	}
}
```

---

## 作者：accomplishment (赞：1)

如果一个分数化成小数是有限的，则这个分数约分后的分母只能含有质因子 $2$ 和 $5$。

假设这个分数为：

$$\frac{bc}{ac}$$

保证 $a = 2^n \times 5^m$，$(c,2)=(c,5)=1$，$b \in \mathbb{N}^{+}$。

### $\text{80 pts: }$

我们可以枚举 $c$，那么 $a$ 不能超过 $\left\lfloor \frac{n}{c} \right\rfloor$，满足条件的 $a$ 的个数可以预处理求出来。$b$ 是不超过 $ \left\lfloor \frac{n}{c} \right\rfloor$ 的所有数字，所以我们可以枚举 $c$ 求出方案数，总复杂度 $O(n)$，想 AC 还需要优化。

### $\text{100 pts: }$

$\left\lfloor \frac{n}{c} \right\rfloor$ 在一段区间内的值是固定不变的，那么我们就可以整除分块来批量计算，但是 $c$ 并不能取到所有的值，只能 $2 \nmid c$ 且 $5 \nmid c$，$c$ 的个数可以容斥原理计算，即总数量 $-$ $($ $2$ 的倍数数量 $+$ $5$ 的倍数数量 $-$ $10$ 的倍数数量 $)$。

预处理 $\text{Time Complexity: }O(\log_2n·\log_5n)$。

计算答案 $\text{Time Complexity: }O(\sqrt{n})$。

$\text{AC Code: }$

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

long long _maxi = 0;
long long _res = 0;

int main () {
	
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	
	cin >> _maxi;
	 
	vector<long long> theList;
	
	// find all num that only 2|num or 5|num 
	for (long long i = 1; i < _maxi + 1; i *= 2) {
		for (long long m = i; m < _maxi + 1; m *= 5) {
			theList.push_back(m);
		}
	}
	
	sort(theList.begin(), theList.end());
	
	long long numA = theList.size();
	
	for (long long left = 1, right = 0; left < _maxi + 1; left = right + 1) {
		long long num = _maxi / left; // floor(n / c)
		
		right = _maxi / num;
		
		// find a num that <= num
		while (theList[numA - 1] > num) {
			numA--;
		}
		
		long long numC = right - left + 1; // all [l, r]
		long long num2 = right / 2 - (left - 1) / 2; // n∈[l, r], 2 | n
		long long num5 = right / 5 - (left - 1) / 5; // n∈[l, r], 5 | n 
		long long num10 = right / 10 - (left - 1) / 10; // n∈[l, r], 10 | n 
		
		numC -= (num2 + num5 - num10); // c num
		_res += num * numA * numC; // update res
	}
	
	cout << _res << '\n';
	
	return 0;
	
} 
```


---

## 作者：Plozia (赞：1)

宣传博客 $\to$ [link](https://www.cnblogs.com/Plozia/p/16808658.html)

不错的 Idea。~~当然如果熟练莫反就是另一回事，但我不熟练（~~

注意到如果最简分数 $\dfrac{x}{y}$ 是有限小数，那么 $y$ 只能含有 $2,5$ 这两个质因子（当然可以为 $1$）。

然而分数并不一定最简，所以考虑将分数变成 $\dfrac{xg}{yg},xg,yg\le n$ 这个形式，其中保证 $\dfrac{x}{y}$ 最简，$y$ 只含有 $2,5$ 这两个质因子（或者为 $1$），$x$ 任意，$g$ 不能含有 $2,5$ 这两个质因子。

显然合法的小于等于 $n$ 的 $y$ 可以预处理，因此考虑枚举 $y,g$，注意到枚举 $y$ 时 $y$ 限制过大不好化简，只能枚举出符合条件的 $(y,g)$ 二元组的个数（人话：只能做到 $O(n)$，可以自己手玩一下），因此考虑枚举 $g$，此时 $y\in[1,\lfloor\dfrac{n}{g}\rfloor]$，然后由于 $y$ 只含有 $2,5$ 这两个质因子，所以个数是很少的，又因为 $g$ 递增时 $y$ 递减，所以是单调的，能做到 $O(n)$（实际上枚举 $y$ 也是利用这一点）。

注意到 $n\le10^{12}$ 因此猜想应该是个根号算法，考虑令 $f(\lfloor\dfrac{n}{g}\rfloor)$ 表示当前枚举 $g$ 时合法的 $y$ 的个数，那么最终答案如下：

$$\sum_{1\le g\le n,2\nmid g,5\nmid g}f(\lfloor\dfrac{n}{g}\rfloor)\lfloor\dfrac{n}{g}\rfloor$$

发现这是个整除分块的形式，但讨厌的是限制条件 $2\nmid g,5\nmid g$，考虑去掉这个限制条件，整除分块过程中处理出一段 $\lfloor\dfrac{n}{g}\rfloor$ 相同的区间 $[l,r]$ 后，考虑计算这个区间内满足限制条件的 $g$ 的个数 $c$，这个可以简单容斥，$c=g(l,r,1)-g(l,r,2)-g(l,r,5)+g(l,r,10)$，$g(l,r,x)$ 表示 $[l,r]$ 内 $x$ 的倍数的个数，处理出 $c$ 后整个区间的贡献就是 $c\times f(\lfloor\dfrac{n}{g}\rfloor)\lfloor\dfrac{n}{g}\rfloor$。

Code：

```cpp
/*
========= Plozia =========
	Author:Plozia
	Problem:P6583 回首过去
	Date:2022/10/20
========= Plozia =========
*/

#include <bits/stdc++.h>
typedef long long LL;

const int MAXN = 1e6 + 5;
LL n, a[MAXN], cnta;

LL Read()
{
	LL sum = 0, fh = 1; char ch = getchar();
	for (; ch < '0' || ch > '9'; ch = getchar()) fh -= (ch == '-') << 1;
	for (; ch >= '0' && ch <= '9'; ch = getchar()) sum = (sum << 3) + (sum << 1) + (ch ^ 48);
	return sum * fh;
}
LL Min(LL fir, LL sec) { return (fir < sec) ? fir : sec; }
LL g(LL l, LL r, LL x) { return r / x - (l - 1) / x; }

int main()
{
	n = Read(); for (LL i = 1; i <= n; i <<= 1) for (LL j = i; j <= n; j *= 5) a[++cnta] = j;
	LL ans = 0; int p = cnta; std::sort(a + 1, a + cnta + 1);
	for (LL l = 1, r; l <= n; l = r + 1)
	{
		if (n / l == 0) r = n; else r = Min(n / (n / l), n);
		while (p > 0 && a[p] > n / l) --p;
		ans += (g(l, r, 1) - g(l, r, 2) - g(l, r, 5) + g(l, r, 10)) * (n / l) * p;
	}
	printf("%lld\n", ans); return 0;
}
```

---

## 作者：绝顶我为峰 (赞：1)

题意：给定 $n$，求 $\frac xy$ 是有限小数的有序数对 $(x,y)$ 的个数。

不加证明地给出一个结论：$\frac xy$ 在 $p$ 进制下是有限小数当且仅当 $y$ 所含的质因子集合是 $p$ 包含的质因子集合的子集。

这里 $p=10$，那么也就是说 $y$ 的质因子只含有 $2,5$。

考虑枚举 $y$，显然 $y$ 的个数是 $O(\log^2n)$ 的，然后对于每个 $y$ 找和 $y$ 互质的 $x$，然后放缩求答案。

考虑对于一个固定的数 $y$，我们有：

$\sum\limits_{i=1}^n[\gcd(i,y)=1]\lfloor\frac n{\max(i,y)}\rfloor$

$=\lfloor\frac ny\rfloor\sum\limits_{i=1}^y[\gcd(i,y)=1]+\sum\limits_{i=y+1}^n[\gcd(i,y)=1]\lfloor\frac ni\rfloor$

$=\lfloor\frac ny\rfloor\varphi(y)+\sum\limits_{i=y+1}^n\lfloor\frac ni\rfloor\sum\limits_{d|i,d|y}\mu(d)$

$=\lfloor\frac ny\rfloor\varphi(y)+\sum\limits_{d|y}\mu(d)\sum\limits_{i=\lceil\frac{y+1}d\rceil}^{\lfloor\frac nd\rfloor}\lfloor\frac {\lfloor\frac nd\rfloor}i\rfloor$

前面这部分容易算，后面这部分因为 $y$ 的质因子只有 $2,5$，所以事实上只有 $d=1,2,5,10$ 时 $\mu(d)\neq 0$，需要计算贡献。

后面的东西显然是个整除分块，容易计算。

这样看起来是 $O(\sqrt n\log^2n)$ 的，过不去？

输出一下这个算法的算量，在 $n=10^{12}$ 时算量只有 $5\times 10^8$，扔进 wolframalpha 里面算一下这个复杂度也确实是 $O(\sqrt n\log n)$，理论上可以通过。

但是交上去只有 80 分，极限数据要跑 13s，怎么会是呢？

发现整除分块中用了大量除法运算，实际测速 long long 除法一秒只能进行大约 $10^8$ 次，而我们的除法运算数量大约在 $10^9$ 次左右。

注意到其实我们每次整除分块在 $d$ 相同的情况下分界点其实是一样的，那么我们不妨先整体进行一次整除分块，记录下分界点和值，然后每次算贡献的时候先二分出来起点在哪个块中，然后直接向后跑一遍就可以了。这样就可以通过本题。

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
#define int long long
int n,ans;
vector<int> v[4],val[4];
inline int solve(int x)
{
    int res=0,tmp=x;
    if(x&1^1)
        tmp>>=1;
    if(x%5==0)
        tmp=(tmp/5)<<2;
    res=n/x*tmp;
    bool flag=1;
    for(int i=upper_bound(v[0].begin(),v[0].end(),x+1)-v[0].begin()-1;i<(int)v[0].size()-1;++i)
    {
        res+=val[0][i]*(v[0][i+1]-(flag? x+1:v[0][i]));
        flag=0;
    }
    if(x&1^1)
    {
        flag=1;
        for(int i=upper_bound(v[1].begin(),v[1].end(),(x>>1)+1)-v[1].begin()-1;i<(int)v[1].size()-1;++i)
        {
            res-=val[1][i]*(v[1][i+1]-(flag? (x>>1)+1:v[1][i]));
            flag=0;
        }
    }
    if(x%5==0)
    {
        flag=1;
        for(int i=upper_bound(v[2].begin(),v[2].end(),x/5+1)-v[2].begin()-1;i<(int)v[2].size()-1;++i)
        {
            res-=val[2][i]*(v[2][i+1]-(flag? x/5+1:v[2][i]));
            flag=0;
        }
    }
    if(x%10==0)
    {
        flag=1;
        for(int i=upper_bound(v[3].begin(),v[3].end(),x/10+1)-v[3].begin()-1;i<(int)v[3].size()-1;++i)
        {
            res+=val[3][i]*(v[3][i+1]-(flag? x/10+1:v[3][i]));
            flag=0;
        }
    }
    return res;
}
signed main()
{
    cin>>n;
    for(int i=1,j=0;i<=n;i=j+1)
    {
        v[0].emplace_back(i);
        val[0].emplace_back(n/i);
        j=n/(n/i);
    }
    v[0].emplace_back(n+1);
    int maxn=n>>1;
    for(int i=1,j=0;i<=maxn;i=j+1)
    {
        v[1].emplace_back(i);
        val[1].emplace_back(maxn/i);
        j=maxn/(maxn/i);
    }
    v[1].emplace_back(maxn+1);
    maxn=n/5;
    for(int i=1,j=0;i<=maxn;i=j+1)
    {
        v[2].emplace_back(i);
        val[2].emplace_back(maxn/i);
        j=maxn/(maxn/i);
    }
    v[2].emplace_back(maxn+1);
    maxn=n/10;
    for(int i=1,j=0;i<=maxn;i=j+1)
    {
        v[3].emplace_back(i);
        val[3].emplace_back(maxn/i);
        j=maxn/(maxn/i);
    }
    v[3].emplace_back(maxn+1);
    for(int i=1;i<=n;i<<=1)
        for(int j=i;j<=n;j*=5)
            ans+=solve(j);
    cout<<ans<<'\n';
    return 0;
}
```

---

## 作者：lfxxx (赞：0)

令 $\gcd(x,y) = k$

$\frac{x}{y} = \frac{\frac{x}{k}}{\frac{y}{k}}$ 它可以被表示为一个十进制有限小数的充要条件是 $\frac{y}{k} = 2^p \times 5^q$。

可以被表示成 $2^q \times 5^p$ 的数其实是很好算的，因为 $p,q \leq \log V$。

所以我们可以 $O(\log^2 V)$ 预处理处所有可以被表示成 $2^q \times 5^p$ 的数
然后等于说是有一个集合 $S$ 询问有多少组 $(x,y)$ 满足 $\frac{y}{\gcd(x,y)} \in S$。

不妨枚举 $\frac{y}{\gcd(x,y)} \in S$ 我们假设这个数是 $r$。

那么问题变成找到统计使得 $\frac{y}{\gcd(x,y)} = r$ 的数的数量。

找一个与 $r$ 互质的数 $t$ 然后其实你以任意数作为最大公因数都是可行的。

但是你要满足 $\max(r \times \gcd(x,y),t \times \gcd(x,y)) \leq n$。

也就是说 $\gcd(x,y)$ 的取值范围是 $[1,\min(\frac{n}{r},\frac{n}{t})]$。

现在问题变成求解 $\sum_{t=1}^{n} \min(\frac{n}{r},\frac{n}{t}) \times [\gcd(t,r) = 1]$。

$ans = \sum_{t=1}^{r} \frac{n}{r} \times [\gcd(t,r) = 1] + \sum_{t=r+1}^{n} \times \gcd[gcd(t,r) = 1]$。

$ans = \varphi(r) \times \frac{n}{r} + \sum_{t=r+1}^{n} \frac{n}{t} \times [\gcd(t,r) = 1]$

因为 $r = 2^p \times 5^q$ 所以说与其互质的充分必要条件是 $t$ 不是 $2$ 的倍数也不是 $5$ 的倍数

那么互质的限制可用容斥消除，上面那个式子转变为多个数论函数前缀和，整除分块处理即可，复杂度 $O(\log^3 V + \sqrt V)$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,ans;
bool flag=false;
vector<int> S;
unordered_map<int,int> mp,mp2,mp5,mp10;
int fin(int n) {
  int ans = n;
  for (int i=2;i<=5;i+=3)
    if (n%i==0) {
      ans=ans/i*(i-1);
      while (n%i==0) n/=i;
    }
  if (n>1) ans=ans/n*(n-1);
  return ans;
}
int qpow(int a,int b){
    if(b==0) return 1;
    if(b==1) return a;
    int res=qpow(a,b/2);
    res*=res;
    if(b%2==1) res*=a;
    return res;
}
int gsum(int x){
    if(flag==true) return mp[x];
    int lt=1,rt=1,sum=0;
    int now=-1;
    while(lt<=x){
        rt=min(x,n/(n/lt));
        while(S[now+1]<=rt&&now<(int)S.size()-1){
            now++;
            mp[S[now]]=sum+(S[now]-lt+1)*(n/lt);
        }
        sum+=(n/lt)*(rt-lt+1);
        lt=rt+1;
    }
    return mp[x]=sum;
}
int v2(int lt,int rt){
    int Lt=ceil(lt*1.0/2),Rt=rt/2;
    return Rt-Lt+1;
}
int v5(int lt,int rt){
    int Lt=ceil(lt*1.0/5),Rt=rt/5;
    return Rt-Lt+1;
}
int v10(int lt,int rt){
    int Lt=ceil(lt*1.0/10),Rt=rt/10;
    return Rt-Lt+1;
}
int g2(int x){
    if(flag==true) return mp2[x];
    int lt=1,rt=1,sum=0;
    int now=-1;
    while(lt<=x){
        rt=min(x,n/(n/lt));
        while(S[now+1]<=rt&&now<(int)S.size()-1){
            now++;
            mp2[S[now]]=sum+v2(lt,S[now])*(n/lt);
        }
        sum+=(n/lt)*v2(lt,rt);
        lt=rt+1;
    }
    return mp2[x]=sum;
}
int g5(int x){
    if(flag==true) return mp5[x];
    int lt=1,rt=1,sum=0;
    int now=-1;
    while(lt<=x){
        rt=min(x,n/(n/lt));
        while(S[now+1]<=rt&&now<(int)S.size()-1){
            now++;
            mp5[S[now]]=sum+v5(lt,S[now])*(n/lt);
        }
        sum+=(n/lt)*v5(lt,rt);
        lt=rt+1;
    }
    return mp5[x]=sum;
}
int g10(int x){
    if(flag==true) return mp10[x];
    int lt=1,rt=1,sum=0;
    int now=-1;
    while(lt<=x){
        rt=min(x,n/(n/lt));
        while(S[now+1]<=rt&&now<(int)S.size()-1){
            now++;
            mp10[S[now]]=sum+v10(lt,S[now])*(n/lt);
        }
        sum+=(n/lt)*v10(lt,rt);
        lt=rt+1;
    }
    return mp10[x]=sum;
}
int g(int x,int tp){
    if(tp%2==0&&tp%5==0) return gsum(x)-g2(x)-g5(x)+g10(x);
    else if(tp%2==0) return gsum(x)-g2(x);
    else if(tp%5==0) return gsum(x)-g5(x);
    else return gsum(x);
}
int f(int x,int l,int r){   
    return g(r,x)-g(l-1,x);
}
signed main(){
    cin>>n;
    for(int i=0;qpow(2,i)<=n;i++){
        for(int j=0;qpow(2,i)*qpow(5,j)<=n;j++){
            S.push_back(qpow(2,i)*qpow(5,j));
        }
    }
    sort(S.begin(),S.end());
    gsum(n);
    g2(n);
    g5(n);
    g10(n);
    flag=true;
    for(int x:S){
        ans+=fin(x)*(n/x);
        ans+=f(x,x+1,n);
    }
    cout<<ans<<'\n';
    return 0;
}
```




---


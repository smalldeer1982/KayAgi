# [Cnoi2020] 梦原

## 题目背景

> 成熟是一种明亮而不刺眼的光辉，一种圆润而不腻耳的音响，一种不再需要对别人察言观色的从容，一种终于停止向周围申述求告的大气，一种不理会哄闹的微笑，一种洗刷了偏激的淡漠,一种无须声张的厚实，一种并不陡峭的高度。勃郁的豪情发过了酵，尖利的山风收住了劲，湍急的溪流汇成了湖。  
——余秋雨《文化苦旅》

在一个偶然的梦境中，Cirno 发现了一棵树，在一望无际的昏暗平原上，发出了淡淡的蓝色荧光。

Here lies $\ \ \ \ \ \ \ \ \ $.  

## 题目描述

不幸的是，这棵树尚未长成，只有一个根节点 $1$。

Cirno 只能知道这棵树将会有 $n$ 个结点，上面分别有 $a_1,a_2,\ldots,a_n$ 颗果实，却无法知道树的形状。

但是树的生长总是具有某种规律。

对于结点 $i$，它会**等概率地**从 $[i-k,i-1] \cap N^+$ 中选择一个结点连接，并成为那个节点的子节点。

其中，$k$ 是一个 Cirno 已经测出的常数。

为了摘下所有的果实，在树长成之后，Cirno 会多次使用魔法。其中每次会在树上选一个联通块，并从联通块内每个结点上摘取一个果子（必须保证该联通块内**每个结点都有果子**）。

显然，Cirno 会采取**最佳策略**使得使用魔法的次数最少。

现在，Cirno 已经知道了 $n$，$k$ 和每个结点将会长出的果子数 $a_i$，请你帮她计算出她最少使用的魔法次数的数学期望。为了简单起见，你只需要输出答案除以 $998244353$ 的余数。

## 说明/提示

## 样例 1 解释：

可能长成的树有如下两种（黑色为结点编号，红色为结点上果子数）：

![](https://cdn.luogu.com.cn/upload/image_hosting/9vpdxwme.png)

最佳方案是对联通块 $\{1,2,3\}$ 和 $\{1\}$ 各使用一次魔法，$\{3\}$ 使用两次，共四次。

![](https://cdn.luogu.com.cn/upload/image_hosting/nnbwq0af.png)

最佳方案对联通块 $\{1,2,3\},\{1,3\}$ 和 $\{3\}$ 各使用一次魔法，共三次。

所以答案为 $\frac{7}{2}\equiv 499122180\pmod{998244353}$

## 数据范围与约定

对于 $100\%$ 的数据，保证 $1\le k<n\le 10^6$，$0\le a_i<998244353$。

### 子任务「本题采用捆绑测试」

- Subtask1（$10\%$）: $k=1$。
- Subtask2（$10\%$）: $n \le 10$，$a_i \in \{0,1\}$。
- Subtask3（$10\%$）: $n \le 10$。
- Subtask4（$10\%$）: $n \le 1000$。
- Subtask5（$60\%$）: 无特殊限制。

## 样例 #1

### 输入

```
3 2
2 1 3```

### 输出

```
499122180```

## 样例 #2

### 输入

```
10 1
580461319 261515299 384092031 741339597 746815717 566875585 354719606 821499852 330315651 349091676```

### 输出

```
553073655```

## 样例 #3

### 输入

```
10 9
497873025 114058764 159468194 207476408 138162972 678927661 223886159 325207554 470061543 658861685```

### 输出

```
180853894```

# 题解

## 作者：览遍千秋 (赞：10)

这个题目可以被划分为两部分来做：树形态的概率和树形态确定后的贡献。

---

容易发现，当树的形态确定后，问题就是 积木大赛 / 铺设道路 放到树上的版本。

和上述两个问题同样，此时的答案为 $\sum \max \{a_x - a_{fa},0\}, x \in V$

这样，本题的第二部分就解决了。

---

下面考虑本题的第一部分，树形态的概率。

观察上面第二部分的答案式，发现答案只与所有的父子关系有关，所以我们只需要考虑每个结点的父亲的概率，并不需要关心整棵树的样子。

根据题意，对于结点 $i$， 其父节点是在 $[\max \{1, i - k\},i - 1]$ 随机选择的点。

那么当结点 $i$ 的父节点为 $x$ 时，对答案期望的贡献$E(i \oplus x)=\dfrac{\max \{a_x - a_{x},0\}}{i - \max \{1, i - k\}}$

答案为 $\sum\limits_{i=1}^n {\sum\limits_{x=\max \{1, i - k\}}^{i-1}}{E(i \oplus x)}$ 

**算法一**

可以通过暴力枚举每个结点及其可能的父节点，暴力统计答案，时间复杂度 $O(n^2)$，可以获得 $\mathrm{40pts}$ 。

（代码中的注释部分）

**算法二**

对于每一个结点 $x$ 可以贡献的期望答案，实际上为其所有可能父节点 $f$ 中，$f$ 权值比 $x$ 大时，获得 $a_x-a_f$ 的答案，再乘上选择这个父节点的概率。

发现算法一的时间复杂度瓶颈在于枚举所有父节点，考虑用树状数组来优化这一过程。

用两棵树状数组，一棵统计$a_f \le a_x$ 的父节点数量，一棵统计 $\forall f$，满足 $a_f \le a_x$ 的权值和。

使用这两棵树状数组维护的信息替代算法一中的枚举父节点，即可获得满分。

---

Code

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long

template < typename Tp >
void read(Tp &x) {
	x = 0; int fh = 1; char ch = 1;
	while(ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
	if(ch == '-') fh = -1, ch = getchar();
	while(ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
	x *= fh;
}

const int mod = 998244353;
const int maxn = 1000000 + 7;

int n, k;
int a[maxn], b[maxn];
int s[maxn]; 

int lowbit(int x) {
	return x & (-x);
}

struct BIT { 
	int c[maxn], N;
	void build(int x) {N = x;}
	void add(int pos, int k) {
		for(int i = pos; i <= N; i += lowbit(i)) c[i] = ((c[i] + k) % mod + mod) % mod;
	}
	int query(int x) {
		int res = 0;
		while(x) {
			res = (res + c[x]) % mod;
			x -= lowbit(x);
		}
		return res;
	}
}T, T1;

void Init(void) {
	read(n); read(k);
	for(int i = 1; i <= n; i++) {
		read(a[i]);
		s[i] = s[i - 1] + a[i];
	}
}

int fpow(int x, int p){
	int res = 1;
	while(p) {
		if(p & 1) res = res * x % mod;
		x = x * x % mod; p >>= 1;
	}
	return res;
}

void Work(void) {
	int ans = 0;
	for(int i = 1; i <= n; i++) b[i] = a[i];
	sort(b + 1, b + n + 1);
	int M; M = unique(b + 1, b + n + 1) - b - 1;
	T.build(M), T1.build(M);
	for(int i = 1; i <= n; i++) a[i] = lower_bound(b + 1, b + M + 1, a[i]) - b;
	for(int i = 1; i <= n; i++) {
		T.add(a[i], b[a[i]]); T1.add(a[i], 1);
		int st;
		if(i - k - 1 >= 1) {
			T.add(a[i - k - 1], -b[a[i - k - 1]]);
			T1.add(a[i - k - 1], -1);
		}
		st=max(1ll, i - k);
		int p = i - st;
		int sum = T.query(a[i]), sour = T1.query(a[i]);
		sum = ((-sum + sour * b[a[i]] % mod) % mod + mod) % mod;
		sum = sum * fpow(p, mod - 2) % mod;
		ans = (ans + sum) % mod;
//		for(int j = st; j < i; j++) {
//			ans = (ans + (max(0ll, a[i] - a[j]) * fpow(p, mod - 2) % mod) % mod) % mod;
//		}
	}
	ans = (ans + b[a[1]]) % mod;
	printf("%lld\n", ans);
}

signed main(void) {
	Init();
	Work();
	return 0;
}
```

---

## 作者：tommymio (赞：6)

赛后才做出来，果然 $\color{green}\text{tommy}$ 日常降智。

想想 $k=1$ 时怎么做。树的形态固定为一条链，这是 $\text{NOIP}$ 原题。$ans=\sum_{i=1}^n \max(a_i-a_{i-1},0)$。

再想想固定树的形态怎么做。我们可以将一个连通块进行操作，如果对点 $x$ 操作了，也可以顺带对它的儿子进行操作，前提是对它的儿子操作后更优。仍然是差分，同积木大赛，$ans=\sum_{x} \max(a_x-a_{fa_x},0)$。

然而原题不确定树的形态，而是随机连边，怎么办？我们发现答案只和每个 $x$ 和它的父亲有关。于是我们可以计算每条边的贡献再把它们加起来。对于 $y\to x$ 的一条边（其中 $y$ 是 $x$ 的父亲），它的贡献为 $\frac{\max(a_x-a_y,0)}{i-\max(1,i-k)}$，可以得到答案为：

$$
a_1+\sum_{i=2}^n\frac{1}{i-\max(1,i-k)}\sum_{j=\max(1,i-k)}^{i-1}\max(a_i-a_j,0)
$$

时间复杂度为 $O(n^2)$，只能够得到 $40\text{pts}$。

考虑优化，瓶颈在 $\sum\limits_{j=\max(1,i-k)}^{i-1}\max(a_i-a_j,0)$ 的求解上。可以抽象出一个区间加，询问区间 $>x$ 的值的和与个数的模型。经典问题，使用分块可以做到 $O(n\sqrt n\log n)$，但不够优秀。

换个想法，观察一下上式，只需要维护区间 $[\max(1,i-k),i-1]$ 内有多少 $a_j>a_i$，和这样的 $a_j$ 的和即可，主席树是可以胜任的，但是会 $\text{MLE}$。于是我们可以使用树状数组，由于区间的左端点单调不减，右端点单调递增，一个 $\text{two-pointer}$ 随时更新树状数组内的值即可。

时间复杂度为 $O(n \log n)$，空间复杂度为 $O(n)$，可以通过本题。

离散化之类什么常见的 $\text{trick}$ 没啥好说的，直接看代码。

**Show the Code**

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define int ll
typedef long long ll;
const ll mod=998244353;
int num=0;
int f[1000005],a[1000005],s[1000005][2],d[1000005],c[1000005];
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
inline int pow(int x,int p) {int res=1;for(;p;p>>=1) {if(p&1) res=res*x%mod; x=x*x%mod;} return res;}
inline int max(const int &x,const int &y) {return x>y? x:y;} 
inline void add(int x,int val1,int val2) {for(;x<=num;x+=x&(-x)) s[x][0]=(s[x][0]+val2)%mod,s[x][1]=(s[x][1]+val1+mod)%mod;}
inline int ask(int x,int val) {int res=0;for(;x;x-=x&(-x)) res=(res+(s[x][1]+val*s[x][0]%mod)%mod)%mod;return res;}
signed main() {
	int n=read(),k=read(),cur=1,ans=0;
	for(register int i=1;i<=n;++i) c[++num]=a[i]=read(); ans=a[1];
	std::sort(c+1,c+1+num); num=std::unique(c+1,c+1+num)-c-1;
	for(register int i=1;i<=n;++i) {d[i]=std::lower_bound(c+1,c+1+num,a[i])-c;a[i]%=mod;}
	add(d[1],-a[1],1);
	for(register int i=2;i<=n;++i) {
		int lim=max(1,i-k),sum=0; 
		while(cur<lim) {add(d[cur],a[cur],-1);++cur;}
		ans=(ans+ask(d[i]-1,a[i])*pow(i-lim,mod-2))%mod;
		add(d[i],-a[i],1);
	}
	printf("%lld\n",ans%mod);
	return 0;
}
```





---

## 作者：Alarm5854 (赞：5)

这道题目虽说是个期望，但实际上也没有想象中的那么可怕，一步步来即可。



首先考虑 $k=1$ 的情况。当 $k=1$ 的时候，显然这棵树的形态是确定的，按照贪心的思路，如果 $a_i>a_{i-1}$，则答案就加上 $a_i-a_{i-1}$ ，因为在采摘果实的时候，采摘第 $i$ 个果实的时候一定会顺带把第 $i-1$ 个果实采摘完的，所以答案为 $\sum_{i=1}^n\max(0,a_i-a_{i-1})$。时间复杂度为 $O(n)$ ，得分：$10$ 分，代码不贴了。



那么，对于 $k>1$ 的情况，怎么办呢？一个最暴力的做法，就是搜到一个节点的时候，枚举这个节点是哪个节点的儿子，搜到一种形态之后，就求出答案。怎么求答案呢？用 `dfs` 求，如果是个叶子结点，就不需要搜了，否则，设这个节点为 $u$，儿子为 $v$  ，求出 $\sum_{i=1}^{size_u}\max(0,a_v-a_u)$，并以儿子继续搜索。时间复杂度看似为 $O(n^k)$ ，实际上远远跑不满，得分：$30$ 分，代码如下：

```cpp
#include<cctype>
#include<cstdio>
#include<vector>
#include<algorithm>
#define ll long long
using namespace std;
const ll N = 1e6 + 10;
const ll MOD = 998244353;
ll quickpow(ll a, ll b) {
    ll res = 1;
    for (; b; b >>= 1, a = a * a % MOD) if (b & 1) res = res * a % MOD;
    return res;
}
ll read() {
    char c = 0; ll x = 0;
    while (c = getchar(), !isdigit(c));
    while (isdigit(c)) x = x * 10 + c - 48, c = getchar();
    return x;
}
vector<ll> vec[N];
ll n, k, ans, cnt, a[N];
ll getans(ll x) {
	ll size = vec[x].size(), res = 0; if (!size) return 0;
	for (ll i = 0; i < size; ++i) {
		ll y = vec[x][i]; (res += max(0ll, a[y] - a[x])) %= MOD;
		(res += getans(y)) %= MOD;
	} return res;
}
void dfs(ll x) {
	if (x > n) {
		(ans += getans(0)) %= MOD, ++cnt; return;
	}
	for (ll i = max(1ll, x - k); i < x; ++i) {
		vec[i].push_back(x);
		dfs(x + 1);
		vec[i].pop_back();
	}
}
int main() {
	n = read(), k = read(), vec[0].push_back(1);
	for (ll i = 1; i <= n; ++i) a[i] = read();
	dfs(2), (ans *= quickpow(cnt, MOD - 2)) %= MOD;
	return 0 & printf("%lld", ans);
}
```



如何优化呢？来看这组数据：

```
4 3
19 260 8 17
```

记 $f_i$ 表示到第 $i$ 个节点的时候次数的期望值。

首先，就一个节点，显然，$f_1=19$。

第二个点加入的时候，也一样的，只是 $1$ 号节点挂着 $2$ 号节点 ，此时，$f_2=f_1+\max(0,a_2-a_1)=260$。

第三个点加入的时候就有一点不一样了，因为，有两种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/nvuv8d1k.png)

可得 $f_3=f_2+(\max(0,a_3-a_2)+\max(0,a_3-a_1))/2=260$。  

第四个点加入的时候情况更复杂，有 $6$ 种情况，当它挂在 $1$ 号节点下时，有两种情况，但本质相同，两种情况都是 $f_3+\max(0,a_4-a_1)=260$。当它挂在 $2$ 号节点下时，也有两种情况，本质也相同，均为 $f_3+\max(0,a_4-a_2)=260$，挂在 $3$ 号节点下时，同样，为 $f_3+\max(0,a_4-a_3)=269$。所以 $f_4=263$。

因此，可以得出 $f_i=f_{i-1}+(\sum_{j=\max(1,n-k)}^{n-1}\max(0,a_i-a_j))/\min(n-1,k)$。时间复杂度为 $O(nk)$，得分：$40$ 分，代码如下：

```cpp
#include<cstdio>
#include<algorithm>
#define ll long long
using namespace std;
const ll N = 1e6 + 10;
const ll MOD = 998244353;
ll quickpow(ll a, ll b) {
    ll res = 1;
    for (; b; b >>= 1, a = a * a % MOD) if (b & 1) res = res * a % MOD;
    return res;
}
ll n, k, a[N], f[N];
int main() {
    scanf("%lld%lld", &n, &k);
    for (ll i = 1; i <= n; ++i) {
        scanf("%lld", a + i);
        if (i == 1) {f[1] = a[1]; continue;}
        for (ll j = 1; j <= k && j < i; ++j)
            (f[i] += max(0ll, a[i] - a[i - j]) + f[i - 1]) %= MOD;
        (f[i] *= quickpow(min(i - 1, k), MOD - 2)) %= MOD;
    }
    return 0 & printf("%lld", f[n]);
}
```

事实上，不难看出效率瓶颈在于 $\sum_{j=\max(1,n-k)}^{n-1}\max(0,a_i-a_j)$，只要这个地方优化好了，问题就解决啦。如何进一步优化呢？其实不难发现，只有当 $\max(1,i-k)<j<i$ 且 $a_j<a_i$ 的情况下，才对答案有贡献，记录一个 $g$ 数组来表示，设 $g_i=\sum_{j=\max(1,n-k)}^{n-1}\max(0,a_i-a_j)$，化简，则有 $g_i=cnt_i\times a_i-(\sum_{j=\max(1,n-k)}^{n-1}a_j[a_j\le a_i])$，其中 $cnt_i$ 表示在范围内有多少个数小于等于 $a_i$，这个可以将数列排序，然后用树状数组优化，做到 $O(n\log n)$ 的算法，得分：$100$ 分，代码如下 。

```cpp
#include<cctype>
#include<cstdio>
#include<algorithm>
#define ll long long
#define L(x) ask(x, p - min(p, k + 1))
#define R(x) ask(x, p)
using namespace std;
const ll N = 1e6 + 10;
const ll MOD = 998244353;
struct node {
    ll num, val;
    node(ll num = 0, ll val = 0): num(num), val(val){}
    friend bool operator <(node a, node b) {return a.val < b.val;}
} a[N];
ll quickpow(ll a, ll b) {
    ll res = 1;
    for (; b; b >>= 1, a = a * a % MOD) if (b & 1) res = res * a % MOD;
    return res;
}
ll read() {
    char c = 0; ll x = 0;
    while (c = getchar(), !isdigit(c));
    while (isdigit(c)) x = x * 10 + c - 48, c = getchar();
    return x;
}
ll n, k, f[N], g[N], c[2][N];
void add(ll d, ll p, ll x) {for (ll i = p; i <= n; i += i & -i) c[d][i] += x;}
ll ask(ll d, ll p) {ll res = 0; for (ll i = p; i; i -= i & -i) res += c[d][i]; return res;}
int main() {
    n = read(), k = read();
    for (ll i = 1; i <= n; ++i) a[i] = node(i, read());
    f[1] = a[1].val, sort(a + 1, a + n + 1);
    for (ll i = 1, p = a[i].num; i <= n; p = a[++i].num) g[p] = (R(0) - L(0)) * a[i].val - (R(1) - L(1)) % MOD, add(0, p, 1), add(1, p, a[i].val);
    for (ll i = 2; i <= n; ++i) f[i] = (g[i] + min(i - 1, k) * f[i - 1]) % MOD, (f[i] *= quickpow(min(i - 1, k), MOD - 2)) %= MOD;
    return 0 & printf("%lld", f[n]);
}
```





---

## 作者：VinstaG173 (赞：3)

我们计算在一棵树上加上一个叶子对使用魔法总次数的贡献。

我们发现一个点的果子数不大于其父亲的果子数时，其对使用魔法总次数不产生贡献，否则其对使用魔法总次数的贡献为其上果子数减去其父亲果子数。

于是我们得到了一个式子：

$$ans=\sum_{i=1}^{n}\dfrac{\sum_{t=1}^{\min\{i-1,k\}}[a_i>a_{i-t}](a_i-a_{i-t})}{\sum_{t=1}^{\min\{i-1,k\}}[a_i>a_{i-t}]}$$

我们可以离散化然后用树状数组维护信息。

人菜常数大，加了一定的卡常。

Code:
```cpp
#include<cstdio>
#include<algorithm>
#include<unordered_map>
#define rg register
typedef long long ll;
typedef __uint128_t L;
typedef unsigned long long ull;
using std::sort;
using std::unique;
using std::unordered_map;
const int ntf=998244353;
int n,k,m;
ll a[1000003];
int vl[1000003];
ll _inv[1000003];
int cnt[1000003];
int mpa[1000003];
unordered_map<int,int>mp;
struct FastMod
{
    ull b,m;
    FastMod(ull b):b(b),m(ull((L(1)<<64)/b)){}
    ull reduce(ull a)
    {
        ull q=(ull)((L(m)*a)>>64);
        ull r=a-q*b;
        return r>=b?r-b:r;
    }
};
FastMod F(2);
int lb[1000003];
ll s[1000003],_s[1000003];
inline void add(int x,ll v)
{
	while(x<=m)s[x]+=v,(s[x]>=ntf)&&(s[x]-=ntf),x+=lb[x];
}
inline ll sum(int x)
{
	ll r=0;
	while(x)r+=s[x],(r>=ntf)&&(r-=ntf),x-=lb[x];
	return r;
}
inline void _add(int x,ll v)
{
	while(x<=m)_s[x]+=v,(_s[x]>=ntf)&&(_s[x]-=ntf),x+=lb[x];
}
inline ll _sum(int x)
{
	ll r=0;
	while(x)r+=_s[x],(r>=ntf)&&(r-=ntf),x-=lb[x];
	return r;
}
inline char rc()
{
	static char buf[1000000],*pn=buf,*pe=buf;
	return (pn==pe)&&(pe=(pn=buf)+fread(buf,1,1000000,stdin),pn==pe)?EOF:*pn++;
}
inline int read()
{
	int x=0;
	char cc=rc();
	while(cc<'0'||cc>'9')cc=rc();
	while(cc>='0'&&cc<='9')x=x*10+cc-'0',cc=rc();
	return x;
}
inline ll _read()
{
	ll x=0;
	char cc=rc();
	while(cc<'0'||cc>'9')cc=rc();
	while(cc>='0'&&cc<='9')x=x*10+cc-'0',cc=rc();
	return x;
}
int main()
{
	F=FastMod(ntf);
	n=read(),k=read();
	for(rg int i=1;i<=n;++i)a[i]=_read(),vl[i]=a[i];
	if(k==1)
	{
		int ans=a[1];
		for(rg int i=2;i<=n;++i)(a[i]>a[i-1])&&(ans+=a[i]-a[i-1]),(ans>=ntf)&&(ans-=ntf);
		return 0&printf("%d\n",ans);
	}
	sort(vl+1,vl+n+1),m=unique(vl+1,vl+n+1)-vl-1;
	for(rg int i=1;i<=m;++i)mp[vl[i]]=i,lb[i]=i&(-i);
	for(rg int i=1;i<=n;++i)mpa[i]=mp[a[i]];
	_add(mpa[1],1);
	for(rg int i=2;i<=n;++i)cnt[i]=_sum(mpa[i]),_add(mpa[i],1),(i>k)&&(_add(mpa[i-k],ntf-1),1);
	ll ans=a[1];add(mpa[1],a[1]);
	_inv[1]=1;
	for(rg int i=2;i<=n;++i)
	{
		ll t,val=F.reduce(F.reduce(a[i]*cnt[i])+ntf-sum(mpa[i]));
		(k<i)?(t=k):(t=i-1,_inv[i]=F.reduce(_inv[ntf%i]*(ntf-ntf/i)));
		ans+=F.reduce(val*_inv[t]),(ans>=ntf)&&(ans-=ntf),(i>k)&&(add(mpa[i-k],ntf-a[i-k]),1),add(mpa[i],a[i]);
	}
	return 0&printf("%lld\n",ans);
}
```

---

## 作者：Warriors_Cat (赞：2)

比较巧妙的一道数学期望+数据结构维护题。

---

### $Solution:$

首先一看题就知道这题分成了两个部分：

$1.$ 确定树的形态。

$2.$ 对于每个形态后所算出来的答案。

顺难则逆，先看第二问，很显然这就是被 NOIp 搞得梅开二度的 [NOIp2018 铺设道路](https://www.luogu.com.cn/problem/P5019)/[NOIp2013 积木大赛](https://www.luogu.com.cn/problem/P1969) 的树上版本。那么其贡献类比这两道题，可得：

$$g_u = \max\{a_u-a_{fa_u}, 0\}$$

其中 $g_u$ 为 $u$ 节点对答案的贡献。

我们会发现这个答案只跟 $u$ 的父亲是谁有关系，所以我们考虑计算两点之间父子关系所有的贡献。

由于节点 $u$ 的父节点的取值范围为 $[\max\{1, u - k\}, u - 1]$，所以节点 $fa_u$ 为节点 $u$ 的父亲的概率为 $\dfrac{1}{u - \max\{1, u - k\}}=\dfrac{1}{\min\{k, u - 1\}}$

于是最终的答案为：

$$\begin{aligned}Ans&=\sum_{u=1}^n \dfrac{g_u}{\min\{k, u - 1\}}\\&=\sum_{u=1}^n\sum_{fa_u=\max\{u-k, 1\}}^{u-1}\dfrac{\max\{a_u-a_{fa_u}, 0\}}{\min\{k, u - 1\}}\end{aligned}$$

暴力求这个答案的复杂度是 $O(nk)$ 的，考虑进行优化。

很明显分子中当 $a_u > a_{fa_u}$ 的时候才会对答案有贡献，所以对于每一个节点 $u$，我们只需要计算出在 $[\max\{u-k, 1\}, u-1]$ 的节点中，有多少个节点 $v$ 满足 $a_u > a_v$ 且这些 $a_v$ 的和，如果分别记为 $s$ 和 $t$ 的话，那么这些贡献的和就为 $s\times a_u - t$。至于怎么求，就是一个树状数组板子了……

于是这题就做完了，时间复杂度为 $O(n\log n)$

注意树状数组存不下 $\max\{a_i\}$ 的数组的大小，故需要离散化。

如果觉得根节点不好弄就先把根节点的贡献单独算出来就行了。

### $Code:$

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
inline int read(){
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9'){ x = x * 10 + (ch ^ 48); ch = getchar(); }
	return x * f;
}
const int N = 1000010, mod = 998244353;
int n, m, lsh[N], a[N], b[N], len, ans;
inline int fpow(int x, int p){ int ans = 1; for(; p; p >>= 1, x = 1ll * x * x % mod) if(p & 1) ans = 1ll * ans * x % mod; return ans; }
struct BIT{
	int c[N]; inline int lb(int x){ return x & -x; }
	inline void change(int x, int y){ for(; x <= len; x += lb(x)) c[x] = ((c[x] + y) % mod + mod) % mod; }
	inline int query(int x){ int ans = 0; for(; x; x -= lb(x)) ans = ((ans + c[x]) % mod + mod) % mod; return ans; }
}tree[2];//树状数组封装
inline int id(int x){ return lower_bound(lsh + 1, lsh + len + 1, x) - lsh; }
int main(){
	n = read(); m = read(); for(int i = 1; i <= n; ++i) lsh[i] = a[i] = read();
	sort(lsh + 1, lsh + n + 1); len = unique(lsh + 1, lsh + n + 1) - lsh - 1;
	for(int i = 1; i <= n; ++i) b[i] = id(a[i]); ans = a[1];
	tree[0].change(b[1], a[1]); tree[1].change(b[1], 1);
	for(int i = 2; i <= n; ++i){
		int s = tree[0].query(b[i] - 1), t = tree[1].query(b[i] - 1);
		ans = (ans + 1ll * (1ll * t * a[i] % mod - s + mod) % mod * fpow(min(i - 1, m), mod - 2) % mod) % mod;
		if(i > m) tree[0].change(b[i - m], -a[i - m]), tree[1].change(b[i - m], -1);//注意随时更新范围
		tree[0].change(b[i], a[i]); tree[1].change(b[i], 1);
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：fighter (赞：2)

## 分析

首先我们可以发现，题目中所说的“最优策略”，实际上就是每次不停地选尽量大的连通块，直到连通块中有一个节点上地果子被取完。此时这个节点相当于从树上被删去了，并且将它所在的连通块分割成了若干个小连通块。所以一个连通块能完整存在的时间，取决于连通块中$a_i$的最小值。

于是我们先来考虑一种最简单的情况：如果一开始一条边都没有，我们所需的操作次数即为$\sum\limits_{i=1}^na_i$。

然后我们考虑加上一条边，假设此时这条边连接了$i$和$j$，那么根据上面的分析，这条边能为我们节省的操作次数应该为$min(a_i, a_j)$。

然后根据题目中的连边方式，我们发现我们可以很方便地统计出一个点能连到的点的信息。具体来说，如果一个点$i$向前连边，连到值比它大的，那么这条边的贡献即为$a_i$；否则如果连到一个值比它小的$j$，那么贡献为$a_j$。由于每条边被连的概率相同，我们可以直接统计出总贡献，再乘上相应的概率。

那么问题就转换为一个数据结构题了：统计序列连续的一段中比给定数字大(或小)的数的和以及个数。那么我们可以用一棵权值线段树，通过动态加入和删除数字，保证区间范围符合题意即可。

## 代码

线段树操作有点多，常数较大，容易T。

```cpp
#include <bits/stdc++.h>
#define P 998244353
#define ll long long
#define MAX 4000005
#define lc(x) (x<<1)
#define rc(x) (x<<1|1)
#define mid ((l+r)>>1)
using namespace std;

#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;
template<typename T>
void read(T &n){
    n = 0;
    T f = 1;
    char c = getchar();
    while(!isdigit(c) && c != '-') c = getchar();
    if(c == '-') f = -1, c = getchar();
    while(isdigit(c)) n = n*10+c-'0', c = getchar();
    n *= f;
}
template<typename T>
void write(T n){
    if(n < 0) putchar('-'), n = -n;
    if(n > 9) write(n/10);
    putchar(n%10+'0');
}

void add(ll &x, ll y){
    x += y;
    if(x >= P) x -= P;
    if(x < 0) x += P;
}

int n, m;
ll a[MAX], b[MAX];
ll s[MAX], t[MAX];
void update(int p, int l, int r, int u, ll k){
    if(l == r){
        add(s[p], b[l]*k);
        add(t[p], k);
        return;
    }
    if(mid >= u) update(lc(p), l, mid, u, k);
    else update(rc(p), mid+1, r, u, k);
    s[p] = (s[lc(p)]+s[rc(p)])%P;
    t[p] = (t[lc(p)]+t[rc(p)])%P;
}
ll query1(int p, int l, int r, int ul, int ur){
    if(l >= ul && r <= ur) return t[p];
    ll res = 0;
    if(mid >= ul) add(res, query1(lc(p), l, mid, ul, ur));
    if(mid < ur) add(res, query1(rc(p), mid+1, r, ul, ur));
    return res;
}
ll query2(int p, int l, int r, int ul, int ur){
    if(l >= ul && r <= ur) return s[p];
    ll res = 0;
    if(mid >= ul) add(res, query2(lc(p), l, mid, ul, ur));
    if(mid < ur) add(res, query2(rc(p), mid+1, r, ul, ur));
    return res;
}

ll ans;
ll inv[MAX];

void init(){
    inv[1] = 1;
    for(int i = 2; i <= m; i++) inv[i] = (P-P/i)*inv[P%i]%P;
}

int main()
{
    cin >> n >> m;
    init();
    for(int i = 1; i <= n; i++) read(a[i]), b[i] = a[i], ans += a[i];
    sort(b+1, b+n+1);
    int len = unique(b+1, b+n+1)-b-1;
    for(int i = 1; i <= n; i++){
        a[i] = lower_bound(b+1, b+len+1, a[i])-b;
    }
    update(1, 1, len+1, a[1], 1);
    for(int i = 2; i <= n; i++){
        int l = min(i-1, m);
        ll x = query2(1, 1, len+1, 1, a[i]), y = query1(1, 1, len+1, a[i]+1, len+1);
        ll sum = (x+y*b[a[i]]%P)%P;
        add(ans, -sum*inv[l]%P);

        update(1, 1, len+1, a[i], 1);
        if(i-m > 0) update(1, 1, len+1, a[i-m], -1);
    }
    cout << ans << endl;

    return 0;
}
```

---

## 作者：tiger2005 (赞：2)

## 题意简述

有一个包含 `N` 个节点的树，节点上有点权。每个节点将随机选择前 `k` 个节点之一作为父亲。

定义对树 `T` 的一次操作为：在树上选取一个连通块且该连通块上所有点的点权不为 0，然后将连通块内所有点的点权减 1。

对于一棵树，计算将所有点的点权删至 0 的最少步数，求出这个步数的期望。

## 分析

想想发现这棵树好像符合那么一点小根堆的性质。每个点只会加在前面的点后面，好像可以从前往后 DP。

具体来讲就是：在枚举到一个点 `x` 的时候，假设它的父亲是 `fa`，那么删父亲的点权的时候带上这个点最优（毕竟这个点往外的通路也就只有父亲了）。最后花点时间暴力删除该节点的点权，那么总答案就是：

$f_x=\dfrac{\sum\limits_{fa\in[x-k,x-1]\cap N^+}f_{x-1}+\operatorname{max}(a_x-a_{fa},0)}{\sum\limits_{fa\in[x-k,x-1]\cap N^+}1}$

这个时候我们找到了暴力的做法。但是很明显这个式子可以优化。

观察到这个式子中需要暴击计算的式子只有 $\sum\limits_{fa\in[x-k,x-1]\cap N^+}\operatorname{max}(a_x-a_{fa},0)$，也就是计算 (所有 (点权比 `x` 的点权小的点) 和 `x` 点权之差 ) 之和。

这个时候就可以使用离散化加支持单点修改区间查询的数据结构完成这一项的计算。可以使用两个树状数组分别储存点权和和点权数量，取值计算后根据覆盖区间修改就行，一次只会修改两个地方。

## 代码

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <set>
#include <map>
using namespace std;
int N,K,A[1000010];
long long DP[1000010];
const long long M=998244353;
long long ksm(int x,int y){
	long long ret=1,bas=x;
	while(y){
		if(y&1)	(ret*=bas)%=M;
		(bas*=bas)%=M;y>>=1;
	}
	return ret;
}
set<int> ST;
map<int,int> MP;
int P,L[1000010],IDX[1000010];
struct BIT{
	long long tr[1000010];
	inline void ad(int a,long long x){
		for(;a<=P;a+=(a&(-a)))	tr[a]+=x;
	}
	inline long long sm(int a){
		long long ret=0;
		for(;a;a-=(a&(-a)))	ret+=tr[a];
		return ret;
	}
}B1,B2;
inline int read(){
	register int ret=0;
    char ch=getchar();
    while(ch<'0') ch=getchar();
    while(ch>='0') ret=(ret<<3)+(ret<<1)+ch-'0',ch=getchar();
    return ret;
}
int main(){
	N=read();K=read();
	for(int i=1;i<=N;i++)
		A[i]=read(),L[++P]=A[i];
	sort(L+1,L+P+1);P=unique(L+1,L+P+1)-L-1;
	for(int i=1;i<=N;i++)
		IDX[i]=lower_bound(L+1,L+P+1,A[i])-L;
	DP[1]=A[1];B1.ad(IDX[1],A[1]);B2.ad(IDX[1],1);
	for(int i=2;i<=N;i++){
		DP[i]=DP[i-1]*(i-max(1,i-K))%M;
		DP[i]+=(B2.sm(IDX[i])*A[i]-B1.sm(IDX[i])%M+M)%M;
		(DP[i]*=ksm(i-max(1,i-K),M-2))%=M;
		B1.ad(IDX[i],A[i]);B2.ad(IDX[i],1);
		if(i-K>0)
			B1.ad(IDX[i-K],-A[i-K]),B2.ad(IDX[i-K],-1);
	}
	printf("%lld",DP[N]);
	return 0;
}
```

---

## 作者：big_news (赞：1)

考虑如果给出一颗形态固定的树，我们应该怎样算答案？

只需要把 $w[u]$ 变成 $w[ fa[u] ]-w[u]$（就是树上差分），然后把所有 $w[u]>0$ 的 $w[u]$ 加起来就可以了。也就是我们只考虑把多出来的那部分算到费用里面，容易发现这样一定是最优的，这个方法见于某道橙色题目[积木大赛](https://www.luogu.com.cn/problem/P1969)。

然后考虑 $i$ 的父亲大概有 $\min i - 1,k$ 种可能，根据期望的线性性，只需对这些可能求个概率加权和就好了。设 $m=\min i-1, k$，得到答案是：

$$\sum\limits_{i=1}^n\sum\limits_{j=i-m}^{i-1}\frac{1}{m}[a_j<a_i](a_i-a_j)$$ 

实际上就是个二维数点，由于区间是定长，因此直接拿个树状数组维护即可，复杂度 $O(n\log n)$。

~~所以说这题标签里是不是会出现主席树啊qwq~~

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
using namespace std;

const int CN = 1e6 + 6;
const int P = 998244353;

int qp(int a,int b) {int r = 1; while(b) {if(b & 1) r = 1ll * r * a % P; a = 1ll * a * a % P; b >>= 1;} return r;}

int n, m, a[CN], val[CN];

int id(int x) {return lower_bound(val + 1, val + val[0] + 1, x) - val;}

class BIT {
  public: int d[CN], cnt[CN], n;
    int lb(int x) {return x & (-x);}
    void add(int p, int x) {while(p <= n) d[p] = (d[p] + x) % P, cnt[p]++, p += lb(p);}
    void minus(int p, int x) {while(p <= n) d[p] = (d[p] - x + P) % P, cnt[p]--, p += lb(p);}
    int qu(int p) {int r = 0; while(p) r = (r + d[p]) % P, p -= lb(p); return r;}
    int quc(int p) {int r = 0; while(p) r += cnt[p], p -= lb(p); return r;}
} D;

int main()
{
    D.n = n = read(), m = read();
    for(int i = 1; i <= n; i++) a[i] = read(), val[ ++val[0] ] = a[i];
    
    sort(val + 1, val + val[0] + 1); int tmp = 1;
    for(int i = 2; i <= val[0]; i++) if(val[i] ^ val[i - 1]) val[++tmp] = val[i]; val[0] = tmp;

    int ans = a[1]; 
    D.add(id(a[1]), a[1]);
    for(int i = 2; i <= n; i++){
        int k = qp(min(i - 1, m), P - 2), si = D.qu( id(a[i]) ), cnt = D.quc( id(a[i]) );
        si = (1ll * cnt * a[i] % P - si + P) % P;
        ans = (1ll * k * si % P + ans) % P;
        D.add( id(a[i]) , a[i]);
        if(i >= m + 1) D.minus( id(a[i - m]), a[i - m] );
    }

    printf("%d", ans);
}
```

---

## 作者：JasonL (赞：1)

### P6834 [Cnoi2020]梦原

[题目传送门](https://www.luogu.com.cn/problem/P6834)

~~第一眼看上去以为比T4更难~~

#### 分析

重要的词语在题面里已经加粗。

首先我们分析当树**确定**时的**最佳策略**。

我们可以贪心，每次选择一个极大联通块，然后不断施加魔法直到联通块中有节点变为0。重复这个操作直到所有节点都变成0为止。可以证明这一种策略，即“能选就选”的策略是最佳策略。

下面我们分析向一棵**确定**的树中添加节点时，**新节点的贡献**。

假如我们现在有一个节点$i$，需要将它连到前面$i-1$个节点构成的树上，与之连接的节点为$j$。两个节点的果子数分别为$a_i$和$a_j$。

当$a_i\le a_j$时，我们可以这样做：将节点$i$添加到原来涉及到节点$j$的魔法对应的极大联通块中（或者说，在消除$a_j$的同时消除$a_i$，直到$a_i=0$）。这时新节点的贡献为0（操作数没有增加，也没有减少）。

当$a_i>a_j$时，涉及节点$j$的魔法“拓展”并不能让$a_i$变为0。这时我们的新节点只能“自立门户”“单打独斗”，以自己作为一个联通块进行魔法操作，而这一操作的次数即为新节点的贡献。为了让贡献尽可能小，我们可以让$a_i$尽可能地被与$a_j$相关的魔法消除，此时这一最小贡献值为$a_i-a_j$。

综上所述，我们新节点的贡献应该为$\max(0,a_i-a_j)$。

发现上面的式子其实与整棵树不相关，只与所连接的节点的权值$a_j$相关。因而对于一个新节点，根据它的**期望贡献**即为

$\sum\limits_j \frac{\max(0,a_i-a_j)}{p_i},j\in[i-k,i-1] \cap N^+,$

其中$p_i$表示当前节点$i$所能选择的点的个数（即$|[i-k,i-1]\cap N^+|$）。$\frac{1}{p_i}$即为每个点选到的概率。（**等概率**）

笔者选择采用递推的方式，先处理前$i-1$个节点的期望次数，再加上当前点$i$的期望贡献，最后得到答案。

显然$p_i$容易得到，而其模意义下的逆元可以$O(k)$预处理出。麻烦在于如何快速求出$\sum\limits_j \max(0,a_i-a_j)$。

我们可以先读入所有权值，对其进行离散化，然后利用树状数组记录比$a_i$小的权值的和与权值的个数。这样就可以在$O(\log n)$的时间内求出上式的值。

（即为$da_i-\sum\limits_{a_j<a_i} a_j$，其中$d$为满足条件的权值个数。这一式子与原式等价）

使用树状数组时要注意消去已经不在可选节点集合内的节点贡献。即，当$j<i-k$时，我们要将$j$的贡献消去。

时间复杂度$O(n\log n)$。

对代码的解释：

笔者代码中添加的权值和为$-a_j$（在模意义下可以转化为$mod-a_j$）。因而在代码中其计算公式为$da_i+sum_i$而非$da_i-sum_i$。

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<map>
using namespace std;
const int maxn=1010000,mod=998244353;
int n,k,ans;
int a[maxn],rk[maxn],no[maxn],sz;//权值，离散化
int Tr[maxn],cnt[maxn];//树状数组
int pr[maxn],mpr[maxn];//预处理逆元(mpr)
inline int read(){
	int res=0;
	char ch=getchar(),ch1=ch;
	while(!isdigit(ch))ch1=ch,ch=getchar();
	while(isdigit(ch))res=(res<<3)+(res<<1)+ch-'0',ch=getchar();
	return ch1=='-'?-res:res;
}
int qmod(int x){
	return x>=mod?x-mod:x;
}
int qpow(int a,int b){
	int res=1;
	while(b){
		if(b&1)
			res=1ll*res*a%mod;
		a=1ll*a*a%mod;
		b>>=1;
	}
	return res;
}
void add(int p,int x,int op){
	while(p<=sz){
		Tr[p]=qmod(Tr[p]+x);
		cnt[p]+=op;
		p+=p&-p;
	}
}
int query(int p,int d){
	int res=0,res2=0;
	while(p){
		res=qmod(res+Tr[p]);
		res2=qmod(res2+cnt[p]);
		p-=p&-p;
	}
	return qmod(res+1ll*res2*d%mod);
}
void reset(){
	pr[0]=1;
	for(register int i=1;i<=k;++i)
		pr[i]=1ll*pr[i-1]*i%mod;
	mpr[k]=qpow(pr[k],mod-2);
	for(register int i=k;i;--i){
		mpr[i-1]=1ll*mpr[i]*i%mod;
		mpr[i]=1ll*mpr[i]*pr[i-1]%mod;
	}
}
int main()
{
	n=read();k=read();
	for(register int i=1;i<=n;++i)
		a[i]=rk[i]=read();
	sort(rk+1,rk+1+n);
	sz=unique(rk+1,rk+1+n)-rk-1;
	reset();
	for(register int i=1,tp;i<=n;++i){
		no[i]=lower_bound(rk+1,rk+sz+1,a[i])-rk;
		if(i==1)
			ans=a[i];
		else{
			tp=min(k,i-1);
			ans=qmod(ans+1ll*query(no[i],a[i])*mpr[tp]%mod);
		}
		add(no[i],mod-a[i],1);
		if(i>k)add(no[i-k],a[i-k],-1);
	}
	printf("%d",ans);
	return 0;
} 
```


---

## 作者：YLWang (赞：1)

出得非常可以的一道题。

首先我们考虑这个东西在一棵固定的树上怎么算。

根据某个在 NOIP 中出现两次的贪心题的理论，答案就是 $(\sum \max\{a_i - a_{f_i}, 0\}) + a_1$。这个贪心如果不会可以出门右转[NOIP2018铺设道路题解](https://www.luogu.com.cn/problem/solution/P5019)。

然后我们根据期望的可加性把他放到期望上。拿两棵树状数组维护。

具体地，我们对于每一个 $i$，维护出 $a_{[\max\{i - k, 1\}, i]}$ 的权值树状数组。然后我们每次 $query$ 比 $a_i$ 小的数的和 $\operatorname{sum}$ 与个数 $\operatorname{cnt}$，则有 $a_i$ 对答案的贡献是 $\dfrac{\operatorname{cnt} \cdot\ a_i - \operatorname{sum}}{\min\{i - 1, k\}}$。把所有贡献加起来即可。

注意还需要线性推一手逆元 + 离散化一下。

代码链接：https://www.luogu.com.cn/paste/4uaq19lu

---

## 作者：Fairicle (赞：1)

假定现在在长第 $i$ 个果实，考虑它对答案的影响，记它的父亲是 $fa$。

若 $a_{fa} \ge a_i$ 则不改变答案，因为消去父亲的时候顺便就能消去 $i$ 

同理若 $a_{fa}< a_i$ 则答案必增加 $a_i-a_{fa}$，因为最后一定要多花这些操作去消去它而不能和它的祖宗同步消去。

那么模型就很明了了，对于每个 $i\in[2,n]$ 统计 $\sum_{j=max(1,i-k)}^{i-1}(a_i-a_j)$，且 $a_i>a_j$。

接下来发现需要维护序号单增且 $a$ 值单增，在线做不太好做~~其实是做不来~~于是考虑离线。

对于 $a_j>a_i$ 的 $j$ 对 $i$ **没有贡献**。

于是有这样的做法：开桶记录每个 $a$ 所属的**果实编号**，从小到大枚举 $a$（因为离散化过了值域在 $1e6$ 内）。这样就保证了计算时没有更大的 $a$ 值在 BIT 中，然后 BIT 下标代表果实编号，就可以计算了。

其他需要注意的点：1 号果实**始终**对答案有大小为 $a_1$ 的贡献，对 $a$ 数组离散化，预处理逆元。

code：
```cpp
#include"bits/stdc++.h"
using namespace std;
#define ri register int
#define ll long long
#define N 1000010
#define mod 998244353
#define de puts("666");
ll n,k,a[N],c[N][2],b[N],inv[N],pre[N],ans;
inline int lowbit(int x){return x & ( - x ) ;}
inline void add(int x,ll v,int op){
	if(op==0) for(ri i=x;i<=n;i+=lowbit(i)) c[i][op]+=v,c[i][op]%=mod;
	if(op==1) for(ri i=x;i<=n;i+=lowbit(i)) c[i][op]+=v;
}
inline ll sum(int x,int op){
	ll ans=0;
	if(op==0) for(ri i=x;i>0;i-=lowbit(i)) ans+=c[i][op],ans%=mod;
	if(op==1) for(ri i=x;i>0;i-=lowbit(i)) ans+=c[i][op];
	return ans;
}
inline void init(){//invs
	inv[0]=1,inv[1]=1;
	for(ri i=2;i<=n;++i) inv[i]=(mod-(mod/i))*inv[mod%i]%mod;
}
vector<int>buc[N];//桶
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>k;init();for(ri i=1;i<=n;++i) cin>>a[i],b[i]=a[i];
	sort(b+1,b+1+n);
	int m=unique(b+1,b+1+n)-b-1;
	for(ri i=1;i<=n;++i){
		int val=a[i];
		a[i]=lower_bound(b+1,b+1+m,a[i])-b;
		pre[i]=val;
		buc[a[i]].push_back(i);
	}
	ans=pre[1];//1号果实的贡献
	for(ri i=1;i<=m;++i){
		int siz=buc[i].size();
		for(ri j=0;j<siz;++j){
			ll l=max(1ll,buc[i][j]-k);
			ll s=sum(buc[i][j]-1,0)-sum(l-1,0),num=sum(buc[i][j]-1,1)-sum(l-1,1);
			ll add=(num*pre[buc[i][j]]%mod-s+mod)%mod;
			add=add*inv[buc[i][j]-l]%mod;
			ans=(ans+add)%mod;
		}
		for(ri j=0;j<siz;++j) add(buc[i][j],pre[buc[i][j]],0),add(buc[i][j],1,1);
	}
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：dead_X (赞：1)

## 前言
题目还不错 QAQ
## 思路
1. 一个结论：对于一棵树，需要的魔法次数为 $x+\sum_{i=2}^n f(u)$ ，其中 $x$ 代表根节点的果实数，$f(u)$ 代表 $u$ 的节点数减去 $u$ 的父亲的果实数后与 $0$ 取最大值的值。

这个结论相当于一个一个点来，每次竟可能取到最多，~~其实就是 P1969 的结论套到树上。~~

2. 一个板子：插入一个数，删除一个数，求大于等于 $x$ 的所有数的和可以用树状数组写。我们先离散化值域，然后就可以单点修改区间求和了。

因此这道题就可做了。首先，因为 $1$ 号节点是根，我们直接将 $1$ 号节点的果实数量加入答案。

对于接下来的每一个节点，我们可以先处理出 $[i-k,i)$ 节点的树状数组。还记得上面的那个结论吗？因为这个节点和谁连边并不重要，我们只需要计算这一条边连边的期望权值，即大于 $a_i$ 的所有数减去 $a_i$ 后再除以 $i-min(i-k,1)$。
## 代码
```
#include<bits/stdc++.h>
#define int long long
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
const int p=998244353;
long long qp(long long x,int y)
{
    if(y==1) return x;
    long long tmp=qp(x*x%p,y>>1);
    if(y&1) tmp*=x,tmp%=p;
    return tmp;
}
using namespace std;
int a[1000003],rk[1000003],lsh[1000003];
int n=read(),k=read();
long long ans,tree[1000003];
int cnt[1000003];
long long find(int x) { long long res=0; while(x) res+=tree[x],x-=x&(-x); return res%p; }
int getcnt(int x) { int res=0; while(x) res+=cnt[x],x-=x&(-x); return res; }
void add(int x,int y,int z) { while(x<=n) tree[x]+=y,cnt[x]+=z,x+=x&(-x); return ; }
signed main()
{
	for(int i=1; i<=n; i++) lsh[i]=a[i]=read();
	sort(lsh+1,lsh+n+1),ans=a[1];
	int len=unique(lsh+1,lsh+n+1)-lsh-1; 
	for(int i=1; i<=n; i++) rk[i]=lower_bound(lsh+1,lsh+len+1,a[i])-lsh;
	add(rk[1],a[1],1);
	for(int i=2; i<=n; i++) 
	{
		if(i-k-1>0) add(rk[i-k-1],-a[i-k-1],-1); 
		ans+=(p-find(rk[i])+1ll*a[i]*getcnt(rk[i])%p)%p*qp(min(k,i-1),p-2)%p,ans%=p;
		add(rk[i],a[i],1);
	}
	printf("%lld\n",ans);
	return 0;
}
```

---


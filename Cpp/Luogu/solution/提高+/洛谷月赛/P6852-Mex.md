# Mex

## 题目背景

忘掉种过的花/重新的出发/放弃理想吧。

## 题目描述

小 G 曾经有一个 $0$ 到 $n$ 的排列（下标从 $0$ 开始），但他忘记了这个排列。

现在他想把这个排列找回来，他努力地回想，只能回想起关于这个排列的 $m$ 条信息，每条信息形如 $(l,r,val)$，表示区间 $[l,r]$ 的 ${\rm mex}$ 值为 $val$。一个区间的 ${\rm mex}$ 值是最小的没有在这个区间中出现的自然数。

小 G 把 $n$ 和这 $m$ 条信息告诉了你，希望你能帮他还原出一个排列，或者告诉他他的回忆出现了问题。



## 说明/提示

**本题采用捆绑测试**。你只有通过 subtask 中的所有测试点才能获得该 subtask 的分数。

- Subtask 1(15 points)：$n,m\le 10$；
- Subtask 2(20 points)：$n,m\le 20$；
- Subtask 3(10 points)：$val=0$；
- Subtask 4(15 points)：数据随机生成；
- Subtask 5(10 points)：$n\le 10^5$；
- Subtask 6(30 points)：无特殊限制。

对于所有的数据满足：$1 \le n,m\le 5\times 10^5$，$ 0\le l,r\le n$，$0\le val\le n+1$。

Subtask4 的数据生成方式为：随机生成一个排列，再随机 $m$ 个区间求出它们的 ${\rm mex}$ 值作为条件。

本题输入输出量较大，请注意使用效率较高的 IO 方式。

## 样例 #1

### 输入

```
3 4
0 0 0
0 1 1
0 2 2
1 3 3```

### 输出

```
3 0 1 2```

## 样例 #2

### 输入

```
5 7
0 1 0
4 5 0
1 3 1
0 5 6
0 5 6
2 5 3
2 3 1```

### 输出

```
4 3 5 0 1 2 ```

# 题解

## 作者：disposrestfully (赞：21)

考虑一个特征对排列的限制,最终小于$val$的数都必须出现在$[l,r]$中,$val$一定不能出现在$[l,r]$中.


把所有数从小到大放到排列里面,设数$x$能放的位置集合是$S(x)$,显然$S(x)$是所有$mex$大于$xs$的区间的交,从中去掉$mex$恰好等于$x$的区间.可以发现$S(x)$要么是$S(x+1)$的子集,要么和$S(x+1)$没有交.所以我们只要在能放的位置里随便找一个放即可.

$O(n)$.

这题的难度定位是“普及组选手能做出来的题”，所以并不需要线段树。下面给出核心代码。

```cpp
int main(){
	n=read(),m=read();
	for (int i=0;i<=n;++i)
		pl[i]=0,pr[i]=n,ql[i]=n,qr[i]=0;
	for (int i=1;i<=m;++i){
		int l=read(),r=read(),val=read();
		if (val){
			pl[val-1]=max(pl[val-1],l);
			pr[val-1]=min(pr[val-1],r);
		}else ++s[l],--s[r+1];
		ql[val]=min(ql[val],l);
		qr[val]=max(qr[val],r);
	}
	for (int i=1;i<=n;++i) s[i]+=s[i-1];
	for (int i=n-1;i>=0;--i){
		pl[i]=max(pl[i],pl[i+1]);
		pr[i]=min(pr[i],pr[i+1]);
		if (pl[i]>pr[i]) return puts("-1"),0;
	}
	for (int i=pl[0];i<=pr[0];++i)
		if (!s[i]) sta.push_back(i),vis[i]=1;
	if (sta.empty()) return puts("-1"),0;
	ans[sta.back()]=0,sta.pop_back();
	for (int i=pl[0];i<=pr[0];++i)
		if (!vis[i]) sta.push_back(i),vis[i]=1;
	for (int i=1;i<=n;++i){
		if (ql[i]<=qr[i]){
			for (int j=pl[i];j<ql[i] && j<=pr[i] && !vis[j];++j)
				sta.push_back(j),vis[j]=1;
			for (int j=pr[i];j>qr[i] && j>=pl[i] && !vis[j];--j)
				sta.push_back(j),vis[j]=1;
		}
		if (sta.empty() || (sta.back()>=ql[i] && sta.back()<=qr[i]))
			return puts("-1"),0;
		ans[sta.back()]=i,sta.pop_back();
		for (int j=max(pl[i],ql[i]);j<=pr[i] && !vis[j];++j)
			sta.push_back(j),vis[j]=1;
		for (int j=min(pr[i],qr[i]);j>=pl[i] && !vis[j];--j)
			sta.push_back(j),vis[j]=1;
	}
	for (int i=0;i<=n;++i)
		printf("%d ",ans[i]);
	puts("");
	return 0;
}
```



---

## 作者：7KByte (赞：16)

观察一下发现从大到小考虑每个数，每个数能填的区间只会缩小。

所以我们从小到大考虑每个数，这样决策集合单增。

$\operatorname{mex}$还需要满足一个神奇的条件，就是区间$[l,r]$中不能包含$k$。这我们需要特殊处理一下。由于不能包含的是连续一段，我们可以用线段树来处理。

注意，不能包含条件不具有传递性，换句话说，一个区间$\operatorname{mex}$限制只对一个数有不能包含限定。

线段树每个节点只用维护对应区间内是否有空位置，然后支持单点修改和区间查询空位。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define pre(i,a,b) for(int i=a;i>=b;i--)
#define N 500005
using namespace std;
int n,m,Lm[N],Rm[N],c[N],u[N],col[N],hav[N],ll[N],rr[N];
struct node{
	int l,r,val;
}a[N<<2];
#define L a[x].l
#define R a[x].r
#define ls (x<<1)
#define rs (ls|1)
#define S a[x].val
void build(int x,int l,int r){
	L=l;R=r;S=0;if(l==r)return;
	int mid=(l+r)>>1;build(ls,l,mid);build(rs,mid+1,r);
}
void change(int x,int pos,int val){
	if(L==R)S=val;
	else{
		int mid=(L+R)>>1;
		if(mid>=pos)change(ls,pos,val);
		if(mid<pos)change(rs,pos,val);
		S=a[ls].val|a[rs].val;
	}
}
int get(int x,int l,int r){
	if(l>r)return ~0;
	if(!a[x].val)return ~0;
	if(L==R)return L;
	if(L>=l&&R<=r){
		if(a[ls].val)return get(ls,l,r);
		if(a[rs].val)return get(rs,l,r);
		return ~0;
	}
	int mid=(L+R)>>1;
	if(mid>=l){
		int now=get(ls,l,r);
		if(~now)return now;	
	}
	if(mid<r){
		int now=get(rs,l,r);
		if(~now)return now;
	}
	return ~0;
}
int main(){
	scanf("%d%d",&n,&m);
	n++;rep(i,1,n)Lm[i]=1,Rm[i]=n,ll[i]=n+1,rr[i]=0; 
	build(1,1,n);
	rep(i,1,m){
		int x,y,z;scanf("%d%d%d",&x,&y,&z);
		x++;y++;z++;
		if(z==1)col[x]++,col[y+1]--;
		else hav[z]=1;
		Lm[z-1]=max(Lm[z-1],x);Rm[z-1]=min(Rm[z-1],y);
		ll[z]=min(ll[z],x);rr[z]=max(rr[z],y);
	}
	rep(i,1,n)col[i]+=col[i-1];
	int ban=0;
	pre(i,n-1,1)Lm[i]=max(Lm[i],Lm[i+1]),Rm[i]=min(Rm[i],Rm[i+1]);
	rep(i,Lm[1],Rm[1])if(!col[i]){ban=i;c[1]=i;break;}
	if(!ban){puts("-1");return 0;}
	rep(i,Lm[1],Rm[1])if(i!=ban)change(1,i,1);//,cout<<"Add "<<i<<endl;
	rep(i,2,n){
		rep(j,Lm[i],Lm[i-1]-1)change(1,j,1);//,cout<<"Add "<<j<<endl;//,cout<<j<<endl;
		rep(j,Rm[i-1]+1,Rm[i])change(1,j,1);//,cout<<"Add "<<j<<endl;//,cout<<j<<endl;
		if(hav[i]){
			int now=get(1,Lm[i],ll[i]-1);
			if(~now)c[i]=now,change(1,now,0);//,cout<<"Del "<<now<<endl;
			else{
				//cout<<rr[i]+1<<" "<<Rm[i]<<endl; 
				now=get(1,rr[i]+1,Rm[i]);
				if(~now)c[i]=now,change(1,now,0);//,cout<<"Del "<<now<<endl;
				else {puts("-1");return 0;}
			}
		}
		else{
			int now=get(1,Lm[i],Rm[i]);
			if(~now)c[i]=now,change(1,now,0);//,cout<<"Del "<<now<<endl;
			else {puts("-1");return 0;}
		}
	}
	//rep(i,1,n)printf("%d ",c[i]);putchar('\n');
	rep(i,1,n)u[c[i]]=i-1;
	rep(i,1,n)printf("%d ",u[i]);putchar('\n');
	return 0;
}
```

---

## 作者：hsfzLZH1 (赞：12)

区间 $[l,r]$ 的 $\operatorname{mex}$ 值为 $val$ 这一条件等价于：

值 $0,1,2,\ldots ,val-1$ 必然出现在区间 $[l,r]$ 中；值 $val$ 不能出现在区间 $[l,r]$ 中。

对于值 $=0$ 的所有条件，可以合并为必须出现的一个区间（ $[0,n]$ ）和不能出现的若干区间。

对于值 $v\neq 0$ 的所有条件，可以合并为必须出现的一个区间和不能出现的一个区间（所有不能出现在的区间的并）。

观察到值增大的过程中，必须出现的区间不变或不断扩展。值 $1,2,\ldots ,v-1$ 必须出现的区间，必然包含在值 $v$ 不能出现的区间中。

所以，我们提出构造序列的策略，从小到大填入值 $v$ ，每次随便在 $v$ 必须出现的区间中， $v$ 不能出现的区间外选择一个点，填入 $v$ 这个值，这样必对后面的构造没有影响。如果没有这样的点，说明不存在这样的排列。

我们可以用 `set` 来维护可以选择的点。每次用 `lower_bound` 找到还可以选择的，第一个大于等于必须出现区间左端点的位置，判断它是否在不能出现的区间中，如果不在，说明可以在这个位置填入这个值；否则就找到第一个大于不能出现区间右端点的位置，试着填入这个值。

由于 $0$ 有多个不能出现的区间，所以特判处理 $0$ 的位置，方法是 $O(n)$ 扫一遍。

时间复杂度 $O(n\log n)$ 。

#### 参考代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<set>
using namespace std;
const int maxn=500010;
int n,m,x,y,v,Lok[maxn],Rok[maxn],Lban[maxn],Rban[maxn],pre[maxn],ans[maxn];
bool findans;
set<int>st;
template <typename T>
inline void read(T &ans)
{
    ans=0;
    char ch=getchar(),f=1;
    for(;ch<'0'||ch>'9';ch=getchar())
    if(ch=='-')f=0;
    for(;ch>='0'&&ch<='9';ch=getchar())
    ans=(((ans<<2)+ans)<<1)+(ch^'0');
    ans=f?ans:-ans;
}
void write(int x)
{
	if(x>=10)write(x/10);
	putchar(x%10+'0');
}
int main()
{
	read(n);read(m);
	for(int i=0;i<=n;i++)st.insert(i);
	for(int i=0;i<=n+1;i++)Lok[i]=0,Rok[i]=n,Lban[i]=n+1,Rban[i]=-1;
	for(int i=1;i<=m;i++)
	{
		read(x);read(y);read(v);
		if(v)Lok[v-1]=max(Lok[v-1],x),Rok[v-1]=min(Rok[v-1],y),
		Lban[v]=min(Lban[v],x),Rban[v]=max(Rban[v],y);
		else pre[x]++,pre[y+1]--;
	}
	for(int i=n;i>=0;i--)Lok[i]=max(Lok[i],Lok[i+1]),Rok[i]=min(Rok[i],Rok[i+1]);
	for(int i=0;i<=n;i++)
	{
		pre[i]+=pre[i-1];
		if(Lok[0]<=i&&i<=Rok[0]&&pre[i]==0){ans[i]=0;st.erase(i);break;}
	}
	for(int i=1;i<=n;i++)
	{
		set<int>::iterator t=st.lower_bound(Lok[i]);
		if(t!=st.end()&&*t<=Rok[i]&&(Lban[i]>*t||*t>Rban[i]))ans[*t]=i,st.erase(t);
		else if(Rban[i]!=-1)
		{
			t=st.lower_bound(Rban[i]+1);
			if(t!=st.end()&&*t<=Rok[i])ans[*t]=i,st.erase(t);
		}
	}
	if(!st.empty()){printf("-1\n");return 0;}
	for(int i=0;i<=n;i++)write(ans[i]),putchar(' ');printf("\n");
	return 0;
}
```

注：

`st.lower_bound(x)` 和 `lower_bound(st.begin(),st.end(),x)` 有时间复杂度上的差别。即第一种写法为 $O(\log n)$ ，第二种为 $O(n)$ 。

---

## 作者：fmj_123 (赞：9)

提供一种码量相对不大的方法，目前不开O2最优解第二页。

首先对于每个限制，都意味着 $[0,val-1]$ 都必须在该区间内，$val$ **必须不在该区间内**。特别的，$val=0$ 意味着 $0$ 不在该区间内。

因为若 $val$ 被限定在区间 $[l,r]$ 内，则 $val-1$ 亦必须在该区间内（若出现矛盾则无解），所以从后往前，数可放置的**位置减少**，且除 $0$ 外，可放置区间是**连续的**。

因此，我们应考虑将数从前往后放置，并维护可放数的位置和不能放置的位置。对于$0$的放置，因可放置区间不连续，需要特判。对于 $[1,n]$，枚举可放置位置，若找到一个合法空位，则放置即可。若遇到不可放置区间（显然也是连续的），则整段跳过。

按照上文所述的性质，这样放置不会导致无解（除非原本就无解）。因此，除非无解，这个方法一定可以构造合法方案。

现在可得 $45$ 分。考虑优化。程序时间使用最多的是查询未使用的位置。使用并查集维护每个位置的状况，每个连通块的最后一个位置为**未使用**。若某个位置被使用，则将该位置所在的连通块（设为 $x$）与**后面一个位置**所在的连通块(设为 $y$)合并，合并时应使 $fa_x=fa_y$，即前面的接到后面的。

由于原来每个连通块都是未被使用，合并后每个联通块仍旧有**一个位置未被使用**。且按照上文的合并方法，因为合并时前面指向后面，因此连通块的根节点一定是该块的**最后一个位置**，亦即未使用的位置。

优化后，查询未使用的位置时间大大减少，可以通过本题。

上代码
```c++
#include<bits/stdc++.h>
using namespace std;
int n,m,pl[500100],pr[500100],ql[500010],qr[500010],z[500100];
int l,r,val,q[500100];int fa[500100];
int getfa(int x)
{
	if (fa[x]==x) return x;
	return fa[x]=getfa(fa[x]);
} 
void hebing(int x,int y)
{
	x=getfa(x);y=getfa(y);
	fa[x]=y;
}
int main()
{
//p数组维护可放位置，q数组维护不可放位置
	scanf("%d%d",&n,&m);
	for (int i=0;i<=n;i++)
	  pr[i]=n,ql[i]=n+1;
	for (int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&l,&r,&val);
		ql[val]=min(ql[val],l);qr[val]=max(qr[val],r);
		if (!val) z[l]++,z[r+1]--;
		else
		{
			pl[val-1]=max(pl[val-1],l),pr[val-1]=min(pr[val-1],r);
		}
	}
	for (int i=n-1;i>=0;i--)
	{
		pl[i]=max(pl[i],pl[i+1]);
		pr[i]=min(pr[i],pr[i+1]);
	}//p求后缀最大值和最小值
	for (int i=1;i<=n;i++)
	  fa[i]=i;
	for (int i=0;i<=n;i++)//特判0的情况
	{
		if (i) z[i]+=z[i-1];
		if (pl[0]<=i&&pr[0]>=i&&!z[i]) {q[i]=0;hebing(i,i+1);break;}
		if (i==n) 
		{
			cout<<"-1\n";
		  	return 0;
		}//无法寻找到可放置的空位，即无解。下同
	}
	for (int i=1;i<=n;i++)
	{
		bool ok=false;
		for (int j=pl[i];j<=pr[i];j++) 
		{
      	 j=getfa(j);//直接找到空位
		  if (j>=ql[i]&&j<=qr[i]) {j=qr[i];continue;}//是否进入不合法区间
		  if (j<=pr[i]) {q[j]=i;hebing(j,getfa(j)+1);ok=true;break;}//找到空位
		}  
		if (!ok) 
		{
			cout<<"-1\n";
			return 0;
		}
	}
	for (int i=0;i<=n;i++) cout<<q[i]<<" ";
	return 0; 
}

```
PS：一开始 $val$ 不在该区间内这一限制被我忽略了导致WA了好久

---

## 作者：Purslane (赞：3)

## Solution

欸 , 并查集 .

首先 , 如果 $[l,r]$ 的 $\text{mex}$ 是 $k$ , 相当于 :

- $[0,k-1]$ 都在 $[l,r]$ 中出现了 ;
- $k$ 不可以在 $[l,r]$ 中出现了 .

所以你就可以算出每个数应该在哪个区间里出现 . 而且数越小 , 它的限制越严格 . 所以你就知道每个数都包含比它小的那个数的区间 . 所以可以从小到大填数 .

如果一个数 $k$ 它对应的区间没有公共部分 , 那么显然它无解 ; 所以就知道了 , 如果有解 , 它对应的那部分不能出现的区间是连续的 .

然后现在证明 : 你在你能填数的范围里乱填一个 , 对答案没有影响 .

不妨设这个数是 $k$ .

其实你的顾虑就是后效性 , 填在了一个后面的人唯一可去的地方 , 而自己还有更多的路 .

分类讨论一下 :

- 如果后面的数 $x$ 有过一次约束 , 那么 $k$ 能填的地方 $x$ 一定不能填 , 所以 $k$ 乱填没有什么 .
- 后面的数 $x$ 一次约束都没有 , 那么 $k$ 和 $x$ 能填的范围其实是一样的 . 谁先谁后无所谓嘛 .

那就模拟呗 ! 最后解决填数的问题 .

你其实就关心这个区间内第一个没有被填的数是谁 . 这是一个经典技巧 , 用并查集维护 , 参见 [Link](https://www.luogu.com.cn/problem/P2391) ( 啊这是一道蓝题 ) 

欸我的复杂度远优于线段树 . 气不气 .

code :

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=5e5+10;
int n,m,pre[MAXN],ans[MAXN],nxt[MAXN],l[MAXN],r[MAXN],v[MAXN],L[MAXN],R[MAXN],ll[MAXN],rr[MAXN];
//L R 表示这个数必须在那个区间里出现
//ll rr 表示这个数不能再那个区间里出现
//如果有解 , 那么一个数不能出现的区间肯定是连续段 所以可以合并
vector<int> upd[MAXN];
void Or(int& l,int& r,int L,int R) {
	if(l==-1) return l=L,r=R,void();
	l=min(l,L),r=max(r,R);
	return ;
}
void And(int& l,int& r,int L,int R) {
	if(R<l||L>r) {cout<<-1;exit(0);}
	l=max(l,L),r=min(r,R);
	return ;
}
int find(int k) {return (nxt[k]==k)?k:(nxt[k]=find(nxt[k]));}
void merge(int u,int v) {u=find(u),v=find(v),nxt[v]=u;return ;}
int try_to_ask(int l,int r) {
	l=find(l);
	if(l<=r) {
		merge(l+1,l);
		return l;
	}
	return -1;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m; ffor(i,0,n+1) nxt[i]=i;
	ffor(i,1,m) cin>>l[i]>>r[i]>>v[i];
	ffor(i,1,m) upd[v[i]].push_back(i);
	ffor(i,0,n) L[i]=0,R[i]=n; memset(ll,-1,sizeof(ll));
	ffor(i,1,n+1) {
		for(auto t:upd[i]) {
			Or(ll[i],rr[i],l[t],r[t]);
			And(L[i-1],R[i-1],l[t],r[t]);
		}
	}
	roff(i,n-1,0) And(L[i],R[i],L[i+1],R[i+1]);
	//从0开始考虑 0 特殊考虑随便搞
	for(auto t:upd[0]) pre[l[t]]++,pre[r[t]+1]--;
	ffor(i,1,n) pre[i]+=pre[i-1];
	int flg=0;
	ffor(i,L[0],R[0])
		if(pre[i]==0) {flg=1,merge(i+1,i),ans[i]=0;break;}
	if(!flg) {cout<<-1;return 0;}
	ffor(i,1,n) {
		if(ll[i]<=L[i]&&R[i]<=rr[i]) {cout<<-1;return 0;}
		if(ll[i]==-1) {
			int k=try_to_ask(L[i],R[i]);
			if(k==-1) {cout<<-1;return 0;}
			ans[k]=i;
		}
		else {
			int k=try_to_ask(L[i],min(R[i],ll[i]-1));
			if(k!=-1) {ans[k]=i;continue;}
			k=try_to_ask(max(rr[i]+1,L[i]),R[i]);
			if(k==-1) {cout<<-1;return 0;}
			ans[k]=i;
		}
	}
	ffor(i,0,n) cout<<ans[i]<<' ';
	return 0;
}
```

这题主要就是发现 $\text{mex}$ 的性质 , 以及对于 **不是无解** 这个已知条件的运用 .

PS : 去年我不会这道题 , 今年想了 20 min , 是不是没有什么长进啊 .

---

## 作者：kkxacj (赞：1)

十分有趣的题。

#### 思路

区间 $l,r$ 的 $\verb!mex!$ 为 $val$ 等同于告诉你 $\left[l,r\right]$ 里一定出现了 $\left[0,val-1\right]$，且 $val$ 不能在 $\left[l,r\right]$ 出现。

考虑从小到大填数，假设现在需要填 $i$ 的区间的交集为 $\left[l,r\right]$，当然若没有交集显然就是无解，因为**题目要求要构造一个排列**，显然选区间里任意一个点都是可以的。

在填 $i$ 时，所有 $value = i-1$ 的区间并和之前选过的区间是不能选的，考虑开一颗线段树，维护单点覆盖，区间翻转，区间查询，每个线段树上的节点表示为区间 $\left[l,r\right]$ 内任意一个没有被选的点的下标，没有设为 $0$。

单点覆盖是将每次选的点覆盖，区间翻转是将所有 $val = i-1$ 的并集翻转一下，之后在翻转回来，区间查询就是从所有需要 $i$ 的区间的交集里找出一个点。

注意区间翻转由于是翻转并集所以对 $val$ 相同的按左端点排序，然后分讨一下即可，具体可以自行画图或看代码。

**code**

```cpp
#include<bits/stdc++.h>
#define int long long
#define mid ((c[p].l+c[p].r)>>1)
#define ls (p<<1)
#define rs ((p<<1)+1)
using namespace std;
#define getchar() (p1 == p2 && (p2 = (p1 = buf1) + fread(buf1, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf1[1 << 23], *p1 = buf1, *p2 = buf1, ubuf[1 << 23], *u = ubuf;
namespace IO
{
	template<typename T>
	void read(T &_x){_x=0;int _f=1;char ch=getchar();while(!isdigit(ch)) _f=(ch=='-'?-1:_f),ch=getchar();while(isdigit(ch)) _x=_x*10+(ch^48),ch=getchar();_x*=_f;}
	template<typename T,typename... Args>
	void read(T &_x,Args&...others){Read(_x);Read(others...);}
	const int BUF=20000000;char buf[BUF],to,stk[32];int plen;
	#define pc(x) buf[plen++]=x
	#define flush(); fwrite(buf,1,plen,stdout),plen=0;
	template<typename T>inline void print(T x){if(!x){pc(48);return;}if(x<0) x=-x,pc('-');for(;x;x/=10) stk[++to]=48+x%10;while(to) pc(stk[to--]);}
}
using namespace IO;
const int N = 5e5+10;
int n,m,a[N],L[N],R[N],id,mx,cnt,cnt1,mr;
struct w
{
	int l,r,val;
}b[N];
struct w1
{
	int l,r,bj,dat,dat1;
}c[N<<2];
void build(int p,int l,int r)
{
	c[p].l = l,c[p].r = r;
	if(l == r)
	{
		c[p].dat = l;
		return;
	}
	build(ls,l,mid),build(rs,mid+1,r);
	c[p].dat = c[ls].dat;
}
inline void push(int p)
{
	swap(c[ls].dat,c[ls].dat1);
	swap(c[rs].dat,c[rs].dat1);
	c[ls].bj ^= 1,c[rs].bj ^= 1;
	c[p].bj = 0;
}
void change(int p,int l)
{
	if(c[p].l == c[p].r)
	{
		c[p].dat = 0;
		return;
	}
	if(c[p].bj) push(p);
	if(l <= mid) change(ls,l);
	else change(rs,l);
	if(c[ls].dat) c[p].dat = c[ls].dat;
	else c[p].dat = c[rs].dat;
	if(c[ls].dat1) c[p].dat1 = c[ls].dat1;
	else c[p].dat1 = c[rs].dat1;
}
void rechange(int p,int l,int r)
{
	if(l <= c[p].l && c[p].r <= r)
	{
		c[p].bj ^= 1,swap(c[p].dat,c[p].dat1);
		return;
	}
	if(c[p].bj) push(p);
	if(l <= mid) rechange(ls,l,r);
	if(mid < r) rechange(rs,l,r);
	if(c[ls].dat) c[p].dat = c[ls].dat;
	else c[p].dat = c[rs].dat;
	if(c[ls].dat1) c[p].dat1 = c[ls].dat1;
	else c[p].dat1 = c[rs].dat1;
}
void query(int p,int l,int r)
{
	if(l <= c[p].l && c[p].r <= r)
	{
		mx = max(mx,c[p].dat);
		return;
	}
	if(c[p].bj) push(p);
	if(l <= mid) query(ls,l,r);
	if(mid < r) query(rs,l,r);
}
inline bool cmp(w x,w y)
{
	if(x.val == y.val) return x.l<y.l; 
	return x.val < y.val;
}
signed main()
{
	read(n),read(m); n++;
	for(int i = 1;i <= m;i++) read(b[i].l),read(b[i].r),read(b[i].val),b[i].l++,b[i].r++;
	sort(b+1,b+1+m,cmp); build(1,1,n); R[m+1] = 1e15; cnt = cnt1 = 1;
	for(int i = m;i >= 1;i--) L[i] = max(L[i+1],b[i].l),R[i] = min(R[i+1],b[i].r);//取交集 
	for(int i = 0;i < n;i++)
	{
		mr = 0;
		while(cnt1 <= m && b[cnt1].val == i) 
		{
			if(mr < b[cnt1].r) rechange(1,max(mr+1,b[cnt1].l),b[cnt1].r);//由于按l排序，[l,mr]肯定都被翻转过，翻转[mr+1,r]  
			//否则这个区间已经被翻转过 
			mr = max(mr,b[cnt1].r),cnt1++;
		}
		if(cnt1 > m) L[cnt1] = 1,R[cnt1] = n; //没有限制了，设为[1,n] 
		if(L[cnt1] > R[cnt1]){cout<<-1; return 0;} mx = 0; query(1,L[cnt1],R[cnt1]);
		if(mx == 0){cout<<-1; return 0;} change(1,mx); a[mx] = i;//无解 
		mr = 0;
		while(cnt < cnt1) 
		{
			if(mr < b[cnt].r) rechange(1,max(mr+1,b[cnt].l),b[cnt].r);
			mr = max(mr,b[cnt].r),cnt++;
		}
	}
	for(int i = 1;i <= n;i++) print(a[i]),pc(' ');
	flush();
	return 0;
} 
/*
对于每个区间，有两个限制（多与两个要么相同要么无解）：
(1,x-1)一定出现过,x一定没有出现过
从小到大贪心的放点，放最少的点满足 
唐完了，前提是这是个排列！！
对于每个点，有一个可以选择的区间，显然是可以随便放的
不过唯一要注意的是x不能出现过这个限制，写个线段树看区间内为0的点是否存在 
有个单点覆盖，区间翻转，区间查询，随便写 
如果没有可选的就只好输出无解了 
翻转多了，可以排个序搞
任意两个区间一定相交
*/
```

---

## 作者：xiaosi4081 (赞：0)

考虑一个限制：$[l_1, r_1],[l_2,r_2],\cdots,[l_m, r_m]$ 区间 $\operatorname{mex}$ 值为 $x$，且 $x>0$。

则有：$\forall 1 \leq i \leq m, [l_i, r_i]$ 包含 $0\sim x-1$ 的所有数，且不包含 $x$。

如果存在两个区间没有交，则没有满足条件的解（因为 $0$ 要同时放在两个区间里）。

既然所有区间都有交，那它们的并必然也是一段区间。所以 $x$ 能出现的位置就是一段**大区间**减另一段**小区间**。定义 $x$ 能出现的位置为 $S(x)$。

如果只考虑**大区间** $|S(x)|$ 随着 $x$ 变小而减少。我们就可以做后缀区间交。然后减掉的**小区间**必然是 $\operatorname{mex}$ 值为 $x$ 的区间的并，显然区间并包含区间交，所以当有 $\operatorname{mex}$ 值为 $x$ 的位置后，$S(x)$ 与 $S(x-1)$ 没有交。否则 $S(x)$ 就相当于 $S(x-1)$ 加上 $\operatorname{mex}$ 值为 $x-1$ 的区间的并所对应区间的一段。

然后我们从小到大做。每次把 $S(x)$ 拓展的位置加进 stack，判断是否符合条件即可。注意到加小区间的时候可以在小区间对应的 $x$ 处理完后直接加。因为有要么包含要么不交的性质，**大区间**又会随着 $x$ 的变大而变大，所以我们可以随便放 $x$。

小区间加的时候可能中间会有一段已经加了（不难发现已经加入 stack 的位置必然是一段区间），所以要从两头加到中间。

**由于以上讨论在 $x = 0$ 时不成立，所以 $x = 0$ 需要提前处理**。

然后就是 $O(n)$ 的了，注意一下边界。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 5e5+5;
int n, m, a[N], vis[N], inq[N];
struct query{ int l, r, v; } s[N];
struct seq{
	int l, r;
	seq operator + (seq b) const{ return {max(l, b.l), min(r, b.r)}; }
	seq operator * (seq b) const{ return {min(l, b.l), max(r, b.r)}; }
} s1[N], s2[N];
stack<int> q;
void add(int x){ inq[x] = 1, q.push(x); }
int main(){
	cin >> n >> m;
	for(int i = 0; i <= n; i++) s1[i] = {0, n}, s2[i] = {n, 0};
	for(int i = 1; i <= m; i++){
		cin >> s[i].l >> s[i].r >> s[i].v;
		s1[s[i].v-1] = s1[s[i].v-1]+seq{s[i].l, s[i].r};
		s2[s[i].v] = s2[s[i].v]*seq{s[i].l, s[i].r};
		if(!s[i].v) vis[s[i].l]++, vis[s[i].r+1]--;
	} for(int i = 1; i <= n; i++) vis[i] += vis[i-1];
	for(int i = n-1; i >= 0; i--){
		s1[i] = s1[i]+s1[i+1];
		if(s1[i].r < s1[i].l) return cout << "-1\n", 0; 
	}
	for(int i = s1[0].l; i <= s1[0].r; i++) if(!vis[i]) add(i);
	if(q.empty()) return cout << "-1\n", 0;
	q.pop();
	for(int i = s1[0].l; i <= s1[0].r; i++) if(!inq[i]) add(i);
	for(int i = 1; i <= n; i++){
		if(s2[i].l <= s2[i].r){
			for(int j = s1[i].l; j < s2[i].l && j <= s1[i].r && !inq[j]; j++) add(j);
			for(int j = s1[i].r; j > s2[i].r && j >= s1[i].l && !inq[j]; j--) add(j);
		} if(q.empty() || (s2[i].l <= q.top() && q.top() <= s2[i].r)) return cout << "-1\n", 0;
		a[q.top()] = i; q.pop();
		for(int j = max(s1[i].l, s2[i].l); j <= s1[i].r && !inq[j]; j++) add(j);
		for(int j = min(s1[i].r, s2[i].r); j >= s1[i].l && !inq[j]; j--) add(j);
	} for(int i = 0; i <= n; i++) cout << a[i] << " ";
	return 0;
}
```

---


# 「EZEC-5」魔法

## 题目描述

小明是一个魔法师。

他有一个可以被施魔法的数列 $A$ 。

他有两种魔法：

1. 花费 $a$ 魔法值，选择 $A$ 中的一个区间 $[l,r]$ ，将 $A_{l},A_{l+1}...A_{r}$ 全部 $+1$ 。
2. 花费 $b$ 魔法值，选择 $A$ 中的一个区间 $[l,r]$ ，将 $A_{l},A_{l+1}...A_{r}$ 全部 $\times 2$ 。

现在小明想对 $A$ 序列施若干次魔法，使其存在一个子区间元素之和不小于 $s$ 。请求出小明需要花费的最小魔法值。

## 说明/提示

【本题开启捆绑测试】

对于 $10\%$ 的数据，$n \leq 5， |A_i|,s\le 100$。

对于另外 $20\%$ 的数据，$n = 10^3$。

对于另外 $5\%$ 的数据，$A_i \ge 0$。

对于另外 $25\%$ 的数据，$a,b \le 3$。

对于 $100\%$ 的数据，$1 \leq n \leq 10^{5}$ , $1 \leq a,b \leq 10^9$ , $- 10^{9} \leq A_{i} \leq  10^{9}$ , $1 \leq s \leq 10^{9}$

【样例解释】：

对于样例，最佳方法之一为使用一次魔法 1 改变 (1,4)，三次魔法 1 改变 (2,5)，三次魔法 2 改变 (2,5)。

```
-3 -1 1 -2 0

-2 0 2 -1 0
-2 1 3 0 1
-2 2 4 1 2
-2 3 5 2 3
-2 6 10 4 6
-2 12 20 8 12
-2 24 40 16 24

-2+24+40+16+24 >= 102
```

## 样例 #1

### 输入

```
5 2 3 102
-3 -1 1 -2 0```

### 输出

```
17```

# 题解

## 作者：Licykoc (赞：22)

# 题意：

给定一个长度为 $n$ 的数列，每次可以选择一段区间 $\times2$ 或 $+1$ ，不同操作有不同的代价。问在有一段**连续子区间**和 $>\ S$ 的情况下，最小代价为多少。

# $\mathcal{Sol:}$ 

蒟蒻一开始看到题目毫无思路，便开始看数据范围。

发现 $1 \le n \le 10^5$ ！这不妥妥的 $\mathcal{O(n\ log\ n)}$ 算法嘛。稍微一想便可以明确主要算法为**二分**。

好了回归正题：既然要使用二分，那么该问题的单调性是什么呢？

`魔法1` ：如果使用 $n$ 次可以满足要求，那么 $n+1$ 次的魔法也**一定满足要求** 。

`魔法2` ：如果使用 $n$ 次可以满足要求，那么 $n+1$ 次的魔法也**一定满足要求** 。

好了，单调性找到了。似乎两个魔法都可以二分，但是 `魔法1` 的最大操作次数是 $S\ (1 \le S \le 10^9)$ ，如果枚举该魔法肯定凉凉。所以考虑枚举 `魔法2` ，该魔法最大操作次数约为 $\mathcal{log (S)}$ ，效率还是很可观的。

那么既然确定了二分的魔法是`魔法1`，那我们就来思考二分怎么写，首先二分的模版如下（笔者习惯的打法）：

```cpp
bool check (int now) {
	//something
}
int l = 0, r = MAX;
while (l <= r) {
	int mid = l + (r - l) / 2;
   if ( check(mid) ) r = mid - 1; 
   		else l = mid + 1;
}
```
 
这个 `check` 函数是用来判断 `魔法1` 使用次数为 $now$ ，在枚举的 `魔法2` 使用次数下，能否满足有一个子序列和 $>\ S$ 。

这里需要用到一个贪心的思想：因为 `魔法2` 使用的是乘法，对一个负数使用的话会使和更小，所以我们只对**和为正数的子序列**使用魔法。这就类似于求最大子段和的方法，若您想更对的地了解关于最大子段和的求法，可以参考[这道题](https://www.luogu.com.cn/problem/P1115)的题解，这里不再赘述，直接给出代码。
```cpp
bool check (int now) {
	int t = 0, ans = (-1) * 1ll << 62;
	for (int i = 1 ; i <= n ; ++ i) {
		if (t < 0) t = 0;
		t += a[i] + x;
		ans = max(ans, t);
	}
	return ans >= ceil(S * 1.0 / (1ll << k));
    //这里的k就是枚举的魔法2次数，用除法是为了防爆long long
}
```

综上，我们得到了一个复杂度为 $\mathcal{O}(n\times log(S)\times 63)$ 的算法。

# $Code:$

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
template<typename T>
void read (T& x) {
	char c=getchar(); int w=0; x=0;
	for (;!isdigit(c);c=getchar()) w^=!(c^45);
	for (;isdigit(c);c=getchar()) x=(x*10)+(c^48);
	x=w?-x:x;
}
const int MAXN=2e5+10;
typedef long long ll;
int n,k,A,B,S;
int l,r,mid;
ll ans=1ll<<62-1ll;
ll a[MAXN];
bool check (int x) {
	int t=0,ans=(-1)*1ll<<62;
	for (int i=1;i<=n;++i) {
		if (t<0) t=0;
		t+=a[i]+x;
		ans=max(ans,t);
	}
	return ans>=ceil(S*1.0/(1ll<<k));
}
signed main () {
	ans=ans*2ll;
	read(n),read(A),read(B),read(S);
	for (int i=1;i<=n;++i) read(a[i]);
	for (k=0;k<=32;++k) {
		l=0; r=1e18; //上界记得开大，不然会WA
		while (l<=r) {
			mid=l+(r-l)/2;
			if (check(mid)) r=mid-1; else l=mid+1;
		}
		ans=min(ans,(ll)A*l+B*k);
	}
	printf("%lld",ans);
}


```

## Upd:

1.感谢SSerxhs提醒，修改sb错误。

2.感谢SSerxhs的hack，修改了部分代码。


---

## 作者：wsyhb (赞：12)

## 分析 + 题解

由于数量级为 $10^9$ 级别，考虑**贪心**。

$+1$ 和 $\times 2$ 的顺序显然：**先执行若干次 $+1$，再执行若干次 $\times 2$。**（这样 $+1$ 操作会被放大若干倍）对于 $+1$ 操作，显然每次执行区间为 $[1,n]$，现在考虑 $\times 2$ 操作对哪些区间执行。

设**最终元素和最大**的区间为 $[l,r]$，则 $[l,r]$ 元素之和不小于 $s$。（$1 \le s \le 10^9$） 另一方面，**所有操作相当于只对区间 $[l,r]$ 中的数执行，执行与 $[l,r]$ 不相交的区间的操作是多余的**。

注意到最大子段和的一个**性质**：对于 $\forall \; l \le k \le r$，区间 $[l,k]$ 元素之和与区间 $[k,r]$ 元素之和 $\ge 0$。（否则去掉这一段后元素之和更大，注意这是在 $s \ge 0$ 的前提下）因此，任意只作用在 $[l,r]$ 这一段区间中部分数的 $\times 2$ 操作，改为作用在 $[l,r]$ 整段区间会更优。进一步，**$+1$ 和 $\times 2$ 操作作用的区间均应为 $[1,n]$**。

那么我们只需关心两种操作的次数——设 $+1$ 操作次数为 $x$，$\times 2$ 操作次数为 $y$。$x$ 可能很大，可以达到 $10^9$ 级别，**但 $y \le \lceil \log_2s \rceil$，于是枚举 $y$。**（$\times 2$ 操作必定对元素和 $\ge 1$ 的区间执行）问题转化为：$x$ 至少为多少时，存在一个子区间元素之和大于 $\lceil \dfrac{s}{2^y} \rceil$。此问题显然具有二分性质，且可以 $O(n)$ check，**二分**即可。

**时间复杂度**：$O(\log_2{s} \cdot n \log_2{10^9})$

PS：上文中有一步提到一个前提，为 $s \ge 0$，事实上，$s<0$ 时只需使用 $+1$ 操作，只需二分一次。（也就是说 $s<0$ 也可以做）

## 代码实现

注意答案的上限为 $2 \times 10^{18}$。（使用 $2 \times 10^9$ 次 $+1$ 操作，当然这不是精确值）

如果还有什么不清楚的话，请见代码（有注释）。

``` cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,s;
const int max_n=1e5+5;
int A[max_n],need;//need 记录 s 除以 2^y 的值（向上取整） 
long long dp[max_n];//dp 计算最大子段和以 check 
inline bool check(long long x)//开 long long 
{
	for(int i=1;i<=n;++i)
	{
		dp[i]=(A[i]+x)+max(dp[i-1],0ll);//注意此时元素为 A[i]+x 
		if(dp[i]>=need)
			return true;//一旦找到 >=need 的子段就说明 x 合法 
	}
	return false;
}
int main()
{
	scanf("%d%d%d%d",&n,&a,&b,&s);
	for(int i=1;i<=n;++i)
		scanf("%d",A+i);
	long long ans=2e18;
	for(int i=1,j=0;;i<<=1,++j)//i=2^j，j 为枚举的 *2 的次数 
	{
		need=(s+i-1)/i;
		long long l=0,r=2e9,mid,res=-1;//注意 l+r 可能会爆 int 
		while(l<=r)
		{
			mid=(l+r)>>1;
			if(check(mid))
				res=mid,r=mid-1;
			else
				l=mid+1;
		}
		if(res!=-1)//res=-1 说明找不到这样的 x （即不存在大于 0 的数）
			ans=min(ans,1ll*b*j+1ll*a*res);
		if(i>=s)//此处等价于 need==1 
			break;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：灵乌路空 (赞：6)

更好的阅读体验：[My blog](https://www.cnblogs.com/luckyblock/p/14323863.html)。

[原题面](https://www.luogu.com.cn/problem/P7287)。

Updated on 2021.1.26：之前极值设小被被[神SSerxhs](https://www.luogu.com.cn/discuss/show/294171)鲨了= = 

## 简述

>给定一长度为 $n$ 的数列 $A$，给定参数 $s$，给定两种操作：  
>1. 花费 $a$ 的代价，将数列 $A$ 中任意一个子串中的元素全部加 1。  
>2. 花费 $b$ 的代价，将数列 $A$ 中任意一个子串中的元素全部乘 2。  
>
>两种操作进行的顺序任意，可以进行任意多次，求至少花费多少代价能使得数列 $A$ 中存在一个子区间的元素之和不小于 $s$。  
>$1\le n\le 10^5$，$1\le |A_i|,s,a,b\le 10^9$。  
>1S，128MB。

## 分析

首先有两个显然的结论，所有操作 1 一定是全局使用的。操作 1 一定在 操作 2 之前。正确性显然，可以通过反证法得到不满足结论一定不会更优。  
记操作 $1$、$2$ 进行的次数分别为 $\operatorname{cnt}_a, \operatorname{cnt}_b$。由于$s\le 10^9$，则 $\operatorname{cnt}_b$ 一定不大于 $\log 10^9$ 次。   
考虑枚举操作 $b$ 进行的次数，问题转化为找到一个最小的非负整数 $\operatorname{cnt}_a$，满足：  

$$\exists 1\le l\le r\le n,\ 2^{\operatorname{cnt}_b}\times\sum_{i=l}^{r} (A_i + \operatorname{cnt}_a)\ge s$$

$\operatorname{cnt}_a$ 越大，$\sum_{i=l}^{r} (A_i + \operatorname{cnt}_a)$ 越大，越容易满足上述条件，则上式左侧满足单调性。考虑二分 $\operatorname{cnt}_a$，找到最小的满足上式的值即为最优的 $\operatorname{cnt}_a$。`Check` 时将 $A_i + \operatorname{cnt}_a$ 作为新数列， $O(n)$ 地求得其的最大子段和，并检查是否满足上式即可。  
总复杂度 $O(n\log^2 w)$ 级别。

注意某些地方可能会炸 LL。

```cpp
//知识点：二分答案，DP
/*
By:Luckyblock
*/
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <cstring>
#include <climits>
#define LL long long
const int kMaxn = 1e5 + 10;
const LL kInf = LLONG_MAX;
//=============================================================
LL n, a, b, s, ans = kInf, val[kMaxn];
//=============================================================
inline int read() {
  int f = 1, w = 0;
  char ch = getchar();
  for (; !isdigit(ch); ch = getchar())
    if (ch == '-') f = -1;
  for (; isdigit(ch); ch = getchar()) w = (w << 3) + (w << 1) + (ch ^ '0');
  return f * w;
}
void Chkmax(LL &fir_, LL sec_) {
  if (sec_ > fir_) fir_ = sec_;
}
void Chkmin(LL &fir_, LL sec_) {
  if (sec_ < fir_) fir_ = sec_;
}
bool Check(LL mid_, LL x_) {
  LL sum = 0;
  for (int i = 1; i <= n; ++ i) {
    if (sum > 0) {
      sum += val[i] + mid_;
    } else {
      sum = val[i] + mid_;
    }
    if (1.0 * sum >= 1.0 * s / x_) return true; //如果写成 (x_ * sum > s) 会炸 LL
  }
  return false;
}
//=============================================================
int main() {
  n = read(), a = read(), b = read(), s = read();
  for (int i = 1; i <= n; ++ i) val[i] = read();
  for (LL i = 0, x = 1; i <= 32; ++ i, x <<= 1ll) {
    LL numa = kInf;
    for (LL l = 0, r = kInf; l <= r; ) {
      LL mid = (l + r) >> 1ll;
      if (Check(mid, x)) {
        numa = mid;
        r = mid - 1;
      } else {
        l = mid + 1;
      }
    }
    Chkmin(ans, numa * a + b * i);
  }
  printf("%lld\n", ans);
  return 0;
}
```

感谢涛哥！

赛时阿空的另一种理解方式。考虑把上面的式子再化一下：  

$$\begin{aligned}
  \exists 1\le l\le r\le n,\ 2^{\operatorname{cnt}_b}\times\sum_{i=l}^{r} (A_i + \operatorname{cnt}_a)&\ge s\\
  (r - l + 1)\operatorname{cnt}_a + \sum_{i=l}^{r} A_i &\ge \dfrac{s}{2^{\operatorname{cnt}_b}}\\
  \operatorname{cnt}_a&\ge \dfrac{\dfrac{s}{2^{\operatorname{cnt}_b}} - \sum\limits_{i=l}^{r} A_i}{r - l + 1}
\end{aligned}$$

显然 $\operatorname{cnt}_a = \frac{\frac{s}{2^{\operatorname{cnt}_b}} - \sum_{i=l}^{r} A_i}{r - l + 1}$ 时最优。发现这个式子是一个并不显然的 01 分数规划的形式。它可以看做有 $n$ 个物品 $(A_i,1)$，钦定必须选连续的一段物品，最小化：
$$\dfrac{\dfrac{s}{2^{\operatorname{cnt}_b}} - \sum\limits_{i=1}^{n} w_i \cdot A_i}{\sum\limits_{i=1}^{n}w_i\cdot 1}$$

考虑二分答案最小化 $\operatorname{cnt}_a$。

$$\begin{aligned}
  \dfrac{\dfrac{s}{2^{\operatorname{cnt}_b}} - \sum\limits_{i=l}^{r} A_i}{r - l + 1} &\le mid\\
  \dfrac{s}{2^{\operatorname{cnt}_b}} - \sum\limits_{i=l}^{r} A_i &\le (r - l + 1)mid\\
  \sum\limits_{i=l}^{r} (A_i + mid)&\ge \dfrac{s}{2^{\operatorname{cnt}_b}}
\end{aligned}$$

得到了与上面本质相同的式子。

---

## 作者：liu_yi (赞：6)

## 题目大意

给定一个长度为 $n$ 的数列 $A$，给定参数 $s$，$a$，$b$。
对于数列 $A$，有两个操作：

1. 花费 $a$ 代价，将数列 $A$ 中任意一个连续区间中的元素全部加 $1$。
2. 花费 $b$ 代价，将数列 $A$ 中任意一个连续区间中的元素全部乘 $2$。

两种操作的操作顺序随意，可进行任意次，求最少花费多少代价能使得数列 $A$ 中存在一个子区间的元素之和大于等于 $s$。

$1 \leq n \leq 10^{5}$ ， $1 \leq a,b \leq 10^9$ ， $- 10^{9} \leq A_{i} \leq  10^{9}$ ， $1 \leq s \leq 10^{9}$。

## 解法

题目有三个性质：
- 操作一定是对于整个区间的
- 操作一定是先加后乘，这样求和后一定是最大的
- 最优的答案一定是操作过后的最大子段和

考虑暴力枚举两个操作的个数，枚举加法的时间复杂度是 $\Theta(s - \max\{A_i\})$，枚举乘法的时间复杂度是 $\Theta(\log s)$，找最大子段和是  $\Theta(n)$ 的，显然不够优秀，考虑优化。

显然，操作次数越多，按照最优策略找到的最大子段和是更大的，具有单调性，所以考虑二分。由于枚举加法的时间复杂度要大于枚举乘法的时间复杂度，所以可以枚举乘法的操作次数，二分加法的操作次数。求出操作后的最大子段和，若大于 $s$，就更新答案，最后取最小值即可，总的时间复杂度为 $\Theta(n\log^2 s)$。

注意，```check()``` 求出最大子段和后，不要直接乘枚举的乘法操作的值，否则会爆 ```long long```。

## AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

int n,a,b,s,c[100010],dp[100010],POW=1,l,r,mid,ans,ANS=9e18,res,sum;
inline int read(){
	register int step=1,s=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
	    if(ch=='-')step=-1;
	    ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
	    s=(s<<1)+(s<<3)+(ch^48);
	    ch=getchar();
	}
	return step*s;
}
inline bool check(register int mid){
    sum=-9e18,res=0;//赋极小值
    for(register int i=1;i<=n;i++){
        if(res<0)res=0;
        res+=c[i]+mid;
        sum=max(sum,res);
    }//求出操作后的最大子段和
    return sum>=ceil(s*1.0/POW);
    //return sum*POW>=s;这样写会溢出
}
signed main(){
    n=read(),a=read(),b=read(),s=read();
    for(register int i=1;i<=n;i++)c[i]=read();
    for(register int i=0;i<=31;i++){
        l=0,r=2e9;
        while(l<=r){
            mid=l+r>>1;
            if(check(mid))r=mid-1,ans=mid;
            else l=mid+1;
        }
        POW*=2;
        ANS=min(ANS,ans*a+i*b);
    }
    printf("%lld",ANS);
    return 0;
}
```

---

## 作者：SSerxhs (赞：6)

可以证明，所有的 $1,2$ 操作都会对整个区间进行，并且先做 $1$ 操作后做 $2$ 操作。末处补充证明~~性感理解~~。

考虑 2 操作对 $s$ 的影响，则 $2^ksum\ge s$ 意味着 $sum\ge \frac{s}{2^k}$，这时我们发现 2 操作可以不视为对序列操作而是视为对 $s$ 操作。

2 操作次数显然是可以枚举的，所以题目转化为求最小 1 操作次数。

对于同一长度，同样操作次数加的值是一样的，也就是说同一长度只要保留最大子段和就可以了。

那么可以考虑计算所有不同长度的子段的最大子段和。由于修改只有整体加，那么类似斜率优化可以知道有用的 $(len,s_{len})$ 构成一个凸包。那么可以发现

这玩意不就是[世上最幸福的女孩](https://www.luogu.com.cn/problem/P5073)？？

所以跑个闵科夫斯基和合并凸包，再枚举 2 操作次数即可。

总时间复杂度 $O(n\log n+nloga)$，空间复杂度 $O(n\log n)$，明显会 MLE

那题写线性空间挺烦的，我们可以考虑最终只需要全局最大子段和，不需要保存每一层的凸包，那么滚动数组就好了。

另外根据斜率优化的原理应该可以轻易做到 $O(n\log n+\log a)$，这里不展开。

以下是证明部分

先证明先做 1 后做 2

因为 2 操作是乘法，那么考虑 1 对 2 的贡献可证明。

1 操作对整个区间做十分显然，不叙

关于 2 操作，首先考虑到所有子段进行完 1 操作后与长度没有关系，可以直接选出同样 1 操作次数的最大子段和，由于选取的是最大子段和 $[l,r]$，那么不存在 $i\in [l,r]$ 使得 $\max([l,i],[i,r])>[l,r]$，则若 2 操作对 $[ll,rr]$ 做更优，则观察增量 $[ll,rr]\times 2>[l,r]*2$，分别令 $i=ll,i=rr$ 可推出与上式矛盾。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+2,M=4e5+2,K=2;
const ll inf=-9e18;
struct pt
{
	int x;
	ll y;
	pt(int a=0,ll b=inf):x(a),y(b){}
	bool operator<(register pt o) {return ((ll)x*o.y<(ll)y*o.x)||((ll)x*o.y==(ll)y*o.x)&&(x+y<o.x+o.y);}//顺时针
	pt operator+(register pt &o) {return pt(x+o.x,y+o.y);}
	pt operator-(register pt &o) {return pt(x-o.x,y-o.y);}
	ll operator*(register pt o) {return (ll)x*o.y-(ll)y*o.x;}
	void operator+=(register pt &o) {x+=o.x;y+=o.y;}
	void operator-=(register pt &o) {x-=o.x;y-=o.y;}
};
pt sl[K][N],sr[K][N],ss[K][N];
pt st[N],la[N],lb[N];
ll sa[N];
int l[M],a[N],r[M],cs[M],lcd[M],rcd[M],scd[M];
int n,i,j,x,y,z;
inline void mx(register ll &x,const ll y)
{
	if (x<y) x=y;
}
inline void read(int &x)
{
	int c=getchar(),fh=1;
	while (c<48||c>57) 
	{
		if (c=='-') {c=getchar();fh=-1;break;}
		c=getchar();
	}
	x=c^48;c=getchar();
	while ((c>=48)&&(c<=57))
	{
		x=x*10+(c^48);
		c=getchar();
	}
	x*=fh;
}
void tb(register pt *a,int pre,register int &n)
{
	register int i,tp=pre;
	for (i=tp+1;i<=n;i++)
	{
		while (tp)
		{
			if (a[tp].y<=a[i].y) --tp;
			else if ((tp>1)&&(a[i]-a[tp-1]<a[tp]-a[tp-1])) --tp;
			else break;
		}
		a[++tp]=a[i];
	}
	n=tp;
}
void maintain(register pt *a,const int n,const int m)
{
	register int i;
	for (i=m;i>n;i--) a[a[i].x=i].y=inf;
	for (i=n;i;i--) {a[a[i].x]=a[i];a[a[i].x=i].y=inf;}
}
void spemaintain(register pt *a,const int n,const int m)
{
	register int tp=0,i;
	for (i=1;i<=m;i++) st[st[i].x=i].y=inf;
	for (i=1;i<=n;i++) mx(st[a[i].x].y,a[i].y);
	memcpy(a+1,st+1,m*sizeof(pt));
}
int order(register pt *a,register int n)
{
	register int i=1,tp=0;
	for (i=1;i<=n;i++) if (a[i].y>inf) a[++tp]=a[i];
	tb(a,1,tp);return tp;
}
int sum(pt *a,pt *b,pt *c,int n,int m,int len)//a+b=c
{
	int i,j,tp=2;
	c[1]=a[1]+b[1];
	for (i=1;i<n;i++) la[i]=a[i+1]-a[i];la[n]=a[1]-a[n];
	for (i=1;i<m;i++) lb[i]=b[i+1]-b[i];lb[m]=b[1]-b[m];
	for (i=j=1;(i<=n)||(j<=m);++tp) {if ((j>m)||(i<=n)&&(la[i]<lb[j])) c[tp]=c[tp-1]+la[i++]; else c[tp]=c[tp-1]+lb[j++];}
	--tp;spemaintain(c,tp,len);tp=order(c,len);tb(c,1,tp);return tp;
}
void build(int x)
{
	if (l[x]==r[x])
	{
		lcd[x]=rcd[x]=scd[x]=1;sl[cs[x]][l[x]]=sr[cs[x]][l[x]]=ss[cs[x]][l[x]]=pt(1,a[l[x]]);
		return;
	}
	register int c,cd;
	register ll ys;
	l[c=x<<1]=l[x];r[c]=l[x]+r[x]>>1;
	l[c|1]=r[c]+1;r[c|1]=r[x];
	cs[c]=cs[c|1]=cs[x]^1;
	build(c);build(x<<1|1);c=x<<1;
	memset(ss[cs[x]]+l[x],0,(r[x]-l[x]+1)*sizeof(pt));
	memset(sl[cs[x]]+l[x],0,(r[x]-l[x]+1)*sizeof(pt));
	memset(sr[cs[x]]+l[x],0,(r[x]-l[x]+1)*sizeof(pt));
	scd[x]=sum(sr[cs[c]]+l[c]-1,sl[cs[c]]+l[c|1]-1,ss[cs[x]]+l[x]-1,rcd[c],lcd[c|1],r[x]-l[x]+1);
	maintain(ss[cs[x]]+l[x]-1,scd[x],r[x]-l[x]+1);
	for (register int i=0;i<scd[c];i++) mx(ss[cs[x]][l[x]+ss[cs[c]][l[c]+i].x-1].y,ss[cs[c]][l[c]+i].y);
	memcpy(sl[cs[x]]+l[x],sl[cs[c]]+l[c],lcd[c]*sizeof(pt));lcd[x]=lcd[c];cd=r[c]-l[c]+1;ys=sa[r[c]]-sa[l[c]-1];c|=1;
	for (register int i=0;i<lcd[c];i++) sl[cs[x]][l[x]+(lcd[x]++)]=pt(sl[cs[c]][l[c]+i].x+cd,ys+sl[cs[c]][l[c]+i].y);
	tb(sl[cs[x]]+l[x]-1,lcd[c^1],lcd[x]);
	for (register int i=0;i<scd[c];i++) mx(ss[cs[x]][l[x]+ss[cs[c]][l[c]+i].x-1].y,ss[cs[c]][l[c]+i].y);
	scd[x]=order(ss[cs[x]]+l[x]-1,r[x]-l[x]+1);
	memcpy(sr[cs[x]]+l[x],sr[cs[c]]+l[c],rcd[c]*sizeof(pt));rcd[x]=rcd[c];cd=r[c]-l[c]+1;ys=sa[r[c]]-sa[l[c]-1];c^=1;
	for (register int i=0;i<rcd[c];i++) sr[cs[x]][l[x]+(rcd[x]++)]=pt(sr[cs[c]][l[c]+i].x+cd,ys+sr[cs[c]][l[c]+i].y);
	tb(sr[cs[x]]+l[x]-1,rcd[c^1],rcd[x]);
}
int main()
{
	ll ans=9e18;
	int aa,bb,sss;
	read(n);read(aa);read(bb);read(sss);
	for (i=1;i<=n;i++) read(a[i]),sa[i]=sa[i-1]+a[i];
	r[l[1]=1]=n;build(1);
	for (i=1;i<=scd[1];i++)
	{
		x=ss[cs[1]][i].x;
		ll y=ss[cs[1]][i].y;int s=sss;
		for (j=0;s>y&&s>1;j++)
		{
			ans=min(ans,(ll)bb*j+(ll)aa*((s-y-1)/x+1));
			s=s+1>>1;
		}
		if (s>y) ans=min(ans,(ll)bb*j+(ll)aa*((s-y-1)/x+1)); else ans=min(ans,(ll)bb*j);
	}
	printf("%lld",ans);
}
```

---

## 作者：AKPC (赞：5)

### 思路
先考虑暴力枚举第二种操作的次数（因为第二种最多只有 $\log_210^9$ 次，约为 $30$ 次，但是第一种最多 $10^9$ 次，所以必然考虑枚举第二种），记为 $i$。

然后考虑二分第一次操作的次数，`check` 的时候假设第一次操作次数为 $k$，给每个数列的元素加上 $k$（操作一直接给所有数加，是比其他方式没有坏处的，因为这样必定会让元素变大的），然后计算最大子段和，判断它是否大于 $\frac{S+2^i-1}{2^i}$ 即可（根据上段的计算）。根据 $i$ ，二分后的值记为 $f(i)$。

最后计算答案，即 $\displaystyle\min_{i=0}^{32}(a\times i+b\times f(i))$。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define mpr make_pair
#define fr first
#define sc second
inline int read(){
	int x=0;bool f=1;register char c=getchar();
	while(c<48||c>57){if(c=='-') f=0;c=getchar();}
	while(c>=48&&c<=57){x=x*10+(c^48);c=getchar();}
	return f?x:-x;
}
int n,x,y,s,a[100005],f[100005],ans=1e18;
bool check(int k,int sum){
    int ans=-1e18,l=1;
    for (int i=1;i<=n;i++) f[i]=f[i-1]+a[i]+k;
	for (int i=1;i<=n;i++){
		if (f[i-1]-f[l-1]<=0) l=i;
		ans=max(ans,f[i]-f[l-1]);
	}
    return ans>=sum;
}
signed main(){
    cin>>n>>x>>y>>s;
    for (int i=1;i<=n;i++) cin>>a[i];
    for (int i=0;i<=30;i++){
        const int sum=(s+(1<<i)-1)/(1<<i);
        int l=0,r=2e9;
        while (l<=r){
            int mid=(l+r)/2;
            if (check(mid,sum)) r=mid-1;
            else l=mid+1;
        }
        ans=min(ans,l*x+i*y);
    }
    cout<<ans;
    return 0;
}
```


---

## 作者：lndjy (赞：3)

首先是两个显然的结论：

- 一定是先加后乘，因为这样加的也会被乘一遍，否则加的不会被乘。

- 操作一定对于全局，因为加法操作不加白不加，乘法操作不影响最大子段和的区间。

这题的关键点是乘 $2$，也就是说最多乘 $logs$ 次。然后我们就可以枚举乘法次数，二分加法次数，取答案的最小值，然后就做完了。

时间复杂度 $O(nloga_ilogs)$。

```cpp
#include<iostream>
#define int long long
using namespace std;
const int N=1e5+5;
int a[N],n,x,y,s;
__int128 b[N];
bool check(__int128 add,__int128 mul)
{
	for(int i=1;i<=n;i++)
	b[i]=(a[i]+add)*mul;
	int maxx=0,now=0;
	for(int i=1;i<=n;i++)
	{
		now=max(now+b[i],b[i]);
		maxx=max(now,maxx);
	}
	return maxx>=s;
} 
int getans(int mul)
{
	int ans=mul*y;
	int l=0,r=2e9;
	while(l<r)
	{
		int mid=(l+r)>>1;
		if(check(mid,1ll<<mul)) r=mid;
		else l=mid+1;
	}
	ans+=l*x;
	return ans;
}
signed main()
{
	cin>>n>>x>>y>>s;
	for(int i=1;i<=n;i++)
	cin>>a[i];
	int ans=1e18;
	for(int i=0;i<=30;i++)
	ans=min(ans,getans(i));
	cout<<ans;
 	return 0;
}
```


---

## 作者：wjh2011 (赞：3)

由于正数做多乘 $30$ 次，负数乘了对答案不优，所以我们最多只会乘 $30$ 次。

我们可以直接枚举乘多少次。显然，先加再乘是最优的，因为加的数都会被乘一个大于一的数，而魔法一一定是所有数一起操作，因为这样能让任意一个子段变大。

当操作二的次数不变时，如果进行 $x$ 次操作一可以满足条件，那么进行 $x+1$ 次操作一一定也能满足条件。所以我们可以考虑二分魔法一操作的次数，并用最大子段和判断是否满足条件。

时间复杂度为 $O(n \log 10^9 \log S)$。

**注意：最大值一定要足够大，最小值一定要足够小，否则会 WA。**

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define N 100005
int n, x, y, s, Sum, a[N], dp[N], Ans = 9e18;
bool check(int k) {
    int Max = -9e18;
    for (int i = 1; i <= n; i++) {
        dp[i] = max(dp[i - 1] + a[i] + k, a[i] + k);
        Max = max(Max, dp[i]);
    }
    return Max >= Sum;
}
signed main() {
    cin >> n >> x >> y >> s;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 0; i <= 30; i++) {
        Sum = (s + (1 << i) - 1) / (1 << i);
        int Left = 0, Right = 2e9, Min = 9e18;
        while (Left <= Right) {
            int Mid = Left + Right >> 1;
            if (check(Mid)) Right = Mid - 1, Min = min(Mid, Min);
            else Left = Mid + 1;
        }
        Ans = min(Ans, Min * x + i * y);
    }
    cout << Ans;
    return 0;
}
```

---

## 作者：fanfansann (赞：3)

首先考虑题目中的一些性质：

我们考虑加法对于全局的影响更大，因为先加再乘贡献更大，这一次加法的贡献直接翻倍，所以考虑先加后乘。然后选择区间，样例解释还只加了一小块，实际上 $+1$ 和 $\times 2$ 的两个操作对全局生效贡献最大。

分析题意，我们发现实际上就是一个最大子段和的问题，因为题目要求存在一个子区间元素和大于等于 $s$ 即可。

然后思考如何解决。

我们发现要求的答案是最小的魔法值，也就是最小花费，有点二分那味了。


我们首先思考能不能枚举加法次数，因为乘法每次乘2，也就是说是一个**倍增**的操作，对于给定的 $s$，只要存在一个子段和大于 $0$ 的子段存在，那么我们最多只需要$log_2s$次就可以找到答案。这样先用加法加到存在一个大于暴力$0$的子段然后枚举加法次数在直接使用$log_2s$需要的乘法次数，暴力可以骗一些分。

然后我们可以枚举加法，为什么不能枚举乘法呢？上面也说了只要存在一个大于 $0$ 的子段和，我们最多只需要$log_2s$次乘法。

第一反应的直接枚举加法，很难操控具体的加法次数，而我们这里实际上最多只有$logs$次乘法，所以我们可以直接$logs$枚举乘法次数，有了乘法次数之后，我们只需要找到需要最少先有几次加法之后再乘上枚举到的乘法次数$mul$，也就是乘上$2^{mul}$，使得先加后乘之后，序列存在一个最大子段和大于等于 $s$ 。那么查找一个满足单调性的最小解，很明显就是二分查找。所以我们只需要二分查找加法次数 $mid$ ，使得序列加上 $mid$ 之后的最大子段和乘上枚举到的$2^{mul}$，也就是乘法次数（每次乘 $2$ 嘛），得到的最大子段和刚好大于等于  $s$ 。然后用二分查找到的加法次数和当前枚举到的乘法次数，根据题目中的费用，更新答案即可。

至于求最大子段和，就是一个很经典的DP问题了，这里不再赘述。


时间复杂度为 $O(nlognlogs)$。

然后就是一些细节上的问题，我们发现数据最大范围为$1e9$，所以我们二分的边界就定为最小的数，和 $s$ 与最大的数的差，因为我们加上这么多就一定能大于等于 $s$。所以我们的INF设为$1e9$。

然后更新答案的时候，两种操作费用以及期望值 $s$ ：$-1e9≤A[i]≤1e9$，$a,b,s≤1e9$，所以我们理论上最大的总费用为 $1e18+2.9e10$ ，所以我们更新答案之前，答案 `ans` 初始化为 $2e18$ 即可。

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <map>
#include <queue>
using namespace std;
typedef long long ll;
typedef int itn;
typedef pair<int, int>PII;
const int N = 2000007, mod = 1e9 + 7, INF = 2e9;

ll n, m, mul = 1;
ll a, b, s, ans = 2e18;
ll A[N], B[N];

bool check(ll x, ll y)
{
    ll sum = 0;//经典最大子段和
    for(int i = 1; i <= n; ++ i) {
        sum = (A[i] + x) * mul + max(sum, 0ll);
        if(sum >= s) return true;
    }
    return false;
}

int main()
{
    scanf("%lld%lld%lld%lld", &n, &a, &b, &s);
    ll maxx = - INF;
    for(int i = 1; i <= n; ++ i)
        scanf("%lld", &A[i]), maxx = max(maxx, A[i]);

    ll deer = log2(s) + 1;//乘法最多的次数

    for(int i = 0; i <= deer; ++ i) {//枚举乘法次数
        ll l = max((ll)0, - maxx);
        ll r = s - maxx;
        while(l < r) {//二分加法的次数
            ll mid = (l + r) >> 1;
            if(check(mid, i)) r = mid;
            else l = mid + 1;
        }
        if(check(r, i))
            ans = min(ans, 1ll * i * b + 1ll * r * a);
        mul *= 2;
    }
    printf("%lld\n", ans);
    return 0;
}
```



---

## 作者：wxzzzz (赞：2)

### 思路

几个性质：

1. 在每种操作数确定的情况下，显然先加再乘更优。

1. 操作 $2$ 的次数在 $[0,\log_2(s)+1]$ 范围内，可以直接枚举。

1. 操作 $1$ 的操作次数具有单调性，可以二分答案。

1. 答案子区间一定是最大子段和区间。

然后就可以直接写了，但是答案最大可能为 $2s×\displaystyle\sum_{i=1}^n (a_i+2s)$，要用  int128 存。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
inline __int128 read() {
    __int128 x = 0;
    bool f = 1;
    char c = getchar();

    while (c < 48 || c > 57) {
        if (c == '-')
            f = 0;

        c = getchar();
    }

    while (c >= 48 && c <= 57) {
        x = x * 10 + (c ^ 48);
        c = getchar();
    }

    return f ? x : -x;
}
inline void write(__int128 x) {
    if (x < 0)
        putchar('-'), x = -x;

    if (x > 9)
        write(x / 10);

    putchar(x % 10 + 48);
}  //快读快写，int128 不能用自带函数读写
__int128 n = read(), a = read(), b = read(), s = read(), ans = 1e18, w[1000005];
inline bool check(__int128 x, __int128 k) {
    __int128 sum = 0, maxn = -1e18;

    for (__int128 i = 1; i <= n; i++) {
        sum = max(sum + w[i] + x, w[i] + x);
        maxn = max(maxn, sum);
    }

    return maxn * k >= s;
}
int main() {
    for (__int128 i = 1; i <= n; i++)
        w[i] = read();

    for (__int128 i = 0; (1 << i - 1) <= s; i++) {
        __int128 l = 0, r = 1e18, mid;

        while (l <= r) {
            mid = l + r >> 1;

            if (check(mid, 1 << i))
                ans = min(ans, mid * a + i * b), r = mid - 1;
            else
                l = mid + 1;
        }
    }

    write(ans);
    return 0;
}
```

---

## 作者：Fairicle (赞：2)

妙妙题.

这种题首先要考虑的是贪心，尝试去寻找性质。

能发现哪些性质呢？

1.如果做加法，显然全局加是最优的。

2.先乘后加不如先加后乘。假设原子段和为 $x$，长度为 $len$，先加后乘为 $2\times (x+len)$，先乘后加为 $2\times x+len$。

于是我们可以知道，操作序列一定是先对整个序列做了若干次全局加，再对当前最大子段进行若干次乘法。

那么不妨反过来，枚举乘法次数 $k$，那么只需要一个最大子段大于等于 $ceil(\dfrac{n}{2^k})$ 即可。要通过多少次加法能得到这样的一个最大子段？不知道，于是二分加法次数，每次 $O(n)$ check 即可。而 $k$ 的大小是 $logW$($W$ 表示值域），所以时间复杂度是 $O(nlog^2W)$.

code：
```cpp
#include"bits/stdc++.h"
using namespace std;
#define ri register int
#define ll long long
inline int rd(){
    int x=0,flg=1;char ch=getchar();
    while(!isdigit(ch)) {if(ch=='-') flg=-1;ch=getchar();}
    while(isdigit(ch)) {x=x*10+(ch^48);ch=getchar();}
    return x*flg;
}
#define N 100010
int n,a,b,s,c[N],d[33],bas,lim;
ll tmp,mx,ans=9e18;
inline bool check(int x){
    ll mx=0,tmp=0;
    for(ri i=1;i<=n;++i){
        tmp+=c[i]+x;
        if(tmp<0) tmp=0;
        mx=max(mx,tmp);
    }
    //cout<<mx<<" "<<lim<<" "<<x<<endl;
    if(mx>=lim) return 1;
    return 0;
}
inline void chkmin(ll &x,ll y){if(x>y) x=y;}
int main(){
    n=rd(),a=rd(),b=rd(),s=rd();
    bas=1;d[0]=1;
    for(ri i=1;i<=n;++i) c[i]=rd();
    for(ri i=1;i<=30;++i) bas*=2,d[i]=bas;
    for(ri k=0;k<=30;++k){
        lim=(s+d[k]-1)/d[k];
        ll l=0,r=(ll)2e9;
        ll t=r;
        while(l<=r){
            //cout<<l<<" "<<r<<" "<<k<<endl;
            int mid=(l+r)>>1;
            if(check(mid)) t=mid,r=mid-1;
            else l=mid+1;
        }
        //cout<<lim<<" "<<t<<endl;
        chkmin(ans,(ll)b*k+(ll)a*t);
    }
    printf("%lld",ans);
    return 0;
}
```


---

## 作者：囧仙 (赞：2)

## 题目大意

> 给定一个 $n$ 项数列 $a_i$ 。有两种操作：

> - $1.$ 任取一个区间 $[l,r]$ ，令 $a_i\gets a_i+1,i\in[l,r]$ 。花费为 $a$ 。

> - $2.$ 任取一个区间 $[l,r]$ ，令 $a_i\gets a_i\times 2,i\in[l,r]$ 。花费为 $b$ 。

> 询问使得存在区间 $[l,r]$ 满足 $\sum_{i=l}^ra_i\ge S$ 的最小花费。

## 题解

显然， $(a_i+1)\times 2=a_i\times 2+2>a_i\times 2+1$ 。于是永远是先做操作 $1$ ，再做操作 $2$ 最优。

看到 $\times 2$ ，显然是一个经典的套路……因为 $2^{30}>10^9\ge S$ ，所以操作 $2$ 的总步数显然不会超过 $30$ 次。不妨枚举操作 $2$ 的总次数 $p$ 。

由于我们要使得存在 $[l,r]$ 满足条件，所以第一个操作当然是全局加最好，多多益善。显然，操作 $1$ 做的越多，越有可能出现满足条件的 $[l,r]$ ，于是固定了操作 $2$ 的次数后，答案具有单调性。

在这种情况下，我们直接二分操作 $1$ 的总次数 $q$ 就行了，每次找到权值和最大的子段，判断它乘以 $2^p$ 能否大于 $S$。找到这样的最小的 $q$ 后，更新答案， $ans=\min(ans,a\times q+b\times p)$ 。

总体而言这题比第二题还要简单……复杂度是 $\mathcal O(n\log n\log s)$ 。

### $\text{upd 2021.1.26}$ 

如果你极值设为 $10^{18}$ 什么的，会被极限数据鲨掉。

所以建议设个更大的极值，比如 $9\times 10^{18}$ 。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int MAXN =1e6+3;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int n,a,b,p,A[MAXN],B[MAXN]; i64 ans=9e18;
int clc(int a,int b){
    i64 t=b,c=0; while(t<a) ++c,t*=b; return c;
}
bool chk(int w,int x){
    up(1,n,i) B[i]=A[i]+w; i64 s=0;
    up(1,n,i){
        s+=B[i]; if(s<0) s=0; if(s>=x) return true;
    }
    return false;
}
int main(){
    n=qread(),a=qread(),b=qread(),p=qread();
    up(1,n,i) A[i]=qread();
    up(0,30,i){
        int t=(p>>i)+((p&((1<<i)-1))!=0),o=0;
        if(chk(0,t)) ans=min(ans,1ll*i*b); else {
            dn(30,0,j) if(!chk(o|(1<<j),t)) o|=1<<j; ++o; 
            ans=min(ans,1ll*i*b+1ll*o*a);
        }
        
    }
    printf("%lld\n",ans);
    return 0;
}
/*
1 3 5 3 4
*/
```

---

## 作者：Auto_Accepted (赞：2)

考虑第二种操作的操作次数，正数最多乘 $\log s+1$ 次即可超过 $s$，负数乘了并没有更优，所以最多乘 $\log s+1$ 次。

然后这个数很小，考虑枚举第二种操作的操作次数，这个时候再枚举第一个操作的操作次数显然不太现实，又因为加的次数具有单调性，考虑二分加的次数。

容易发现加变成全局加一定不会更劣，同时加全部放在乘之前也一定不会更劣。

然后 `check` 函数的代码就非常容易写出：
```cpp
inline bool check(int mid , int cnt){//mid是二分的第一次操作次数，cnt是枚举的第二次操作次数
	int now = 0 , sum = 0;
	for(int i = 0;i < n;i++){
		now = max(now , 0ll);
		sum = max(sum , (now += (x[i] + mid)));
	}
	return (sum >= (s * 1.0/*因为这个调1h，shit*/ / (1ll << cnt)));
	//这里是为了防止爆long long
} 
```

然后在所有可以的方案中取个最小花费就完事了。

注意二分上界要开到 `1e18`，还要开 `long long`。

代码：
```
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n , a , b , s , ans = 7e18;
vector <int> x;
inline int read(){
	int f = 1 , s = 0;
	char c = getchar();
	while(c < '0' || c > '9'){
		if(c == '-') f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9'){
		s = (s << 1) + (s << 3) + c - '0';
		c = getchar();
	}
	return s * f;
}
inline bool check(int mid , int cnt){
	int now = 0 , sum = 0;
	for(int i = 0;i < n;i++){
		now = max(now , 0ll);
		sum = max(sum , (now += (x[i] + mid)));
	}
	return (sum >= (s * 1.0/*因为这个调1h，shit*/ / (1ll << cnt)));
} 
signed main(){
//	freopen("magic.in" , "r" , stdin);
//	freopen("magic.out" , "w" , stdout);
	n = read() , a = read() , b = read() , s = read();
	x.resize(n);
	for(int i = 0;i < n;i++){
		x[i] = read();
	}
	for(int i = 0;i <= __lg(s) + 1;i++){
		int tmp = 0 , l = 0 , r = 1e18;
		while(l <= r){
			int mid = (l + r) >> 1;
			if(check(mid , i)){
				r = mid - 1;
			}
			else{
//				tmp = mid;
//				又不要加上面那句，fuck 
				tmp = l = mid + 1;
			}
		}
		int w = a * tmp + b * i;
		ans = min(ans , w);
	}
	cout << ans;
	return 0;
}

```

---

## 作者：InversionShadow (赞：1)

首先：肯定要先执行魔法 1 再来执行魔法 2，这是肯定的。因为 $a_i$ 有可能小于 $0$，而魔法 2 是乘法，所以会越乘越小。

然后我们考虑怎么算出最优的次数呢？显然枚举魔法 2 的次数是最快的，因为最多会执行 $\log_2$ 次，然后我们就可以二分去枚举魔法 1 的次数。因为如果执行 $x$ 次魔法一，那么在魔法 2 次数相同的情况下，执行 $x+1$ 次魔法 1 肯定可行，所以满足单调性。但是 `check` 函数怎么写呢？

类似于最大子段和的操作，设当前二分的值为 $mid$，那么 $a_i\rightarrow a_i+mid$，然后去求出最大字段和，去执行魔法 2 就可以啦。

还有，在 `check` 函数判断的时候有可能会爆 `long long`，所以我开了 `__int128` 来实现。  

跑的很慢的代码，用时 2.09s：

```cpp
#include <bits/stdc++.h>
#define int __int128

using namespace std;

const int MAXN = 1e5 + 200, N = 1e18;

int n, a, b, s, c[MAXN], dp[MAXN];

inline int read() {
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-') {
			f = -1;
			ch = getchar();
		}
	}
	while (ch >= '0' && ch <= '9') {
		x = x * 10 + ch - '0';
		ch = getchar();
	}
	return x * f;
}

void write(int x) {
	if (x < 0) {
		putchar('-');
		x = -x;
	}
	if (x > 9) {
		write(x / 10);
	}
	putchar(x % 10 + '0');
	return ;
}

bool check(int mid, int k) { // 最大子段和
	int maxx = 0;
	memset(dp, 0, sizeof(dp));
	for (int i = 1; i <= n; i++) {
		dp[i] = max(dp[i - 1] + c[i] + mid, c[i]);
		maxx = max(dp[i], maxx);
		dp[i] = max(dp[i], (__int128)0); // 什么都不选是 0
	}
	return maxx >= k;
}

/*
-3 -1 1 -2 0	
0 2 5 
*/

signed main() {
	n = read(), a = read(), b = read(), s = read();
	for (int i = 1; i <= n; i++) {
		c[i] = read();
	}
	int ans = 1e18;
	for (int k = 0; k <= 30; k++) { 
		int l = 0, r = 2e18 + 100;
		while (l <= r) {
//			write(l);
//			cout << ' ';
//			write(r);
//			cout << '\n';
			int mid = l + r >> 1;
//			write(l);
//			cout << ' ';
//			write(r);
//			cout << '\n';
			if (check(mid, ceil(1.0 * s / (1 << k)))) {
				ans = min(ans, b * k + mid * a);
				r = mid - 1;
			} else {
				l = mid + 1;
			}
		}
	}
	write(ans);
	return 0;
}
```


---

## 作者：XL4453 (赞：1)

### 解题思路：

对于操作一，容易发现将其操作的范围扩大到整个数组一定不劣。对于操作二，考虑任意一个可能的最大字段，将其所有的位置上都乘以 $2$ 一定优于将某一个部分乘以 $2$，由此得出将操作二扩展到整个数组同样不劣。

另一个容易发现的事实是将所有的操作一放到所有的操作二之前进行一定不劣。

---
由此问题就只需要解决使用几次操作一和操作二了。操作一的数量可能很大，但是操作二的操作一定不超过 $\log A$，其中 $A$ 为值域。而对于操作一，有一个较为显然的单调性，即固定操作二，对于一个操作一的次数 $x$，若其能够满足条件，则 $x+1$ 一定也能满足条件。

由此问题的解法就比较清晰了，首先枚举操作二的次数，然后二分操作一的进行次数，每一次找出最大字段和进行判断即可。最后的总复杂度为 $O(n\log ^2 A)$，其中 $A$ 为值域。


---
### 代码：

```
#include<cstdio>
#include<algorithm>
using namespace std;
#define int long long
int n,s,a,b,num[100005],l,r,mid,t,ans=-1;
bool check(int p,int m){
	int now=0,ans=0;
	for(int i=1;i<=n;i++){
		now+=p+num[i];
		ans=max(ans,now);
		if(now<0)now=0;
	}
	return ans>=m;
}
signed main(){
	scanf("%lld%lld%lld%lld",&n,&a,&b,&s);
	for(int i=1;i<=n;i++)scanf("%lld",&num[i]);
	for(int i=0;i<=30;i++){
		l=0;r=2e9;t=1<<i;
		while(l<=r){
			mid=(l+r)>>1;
			if(check(mid,s/t+(s%t!=0))){
				if(ans==-1)ans=mid*a+i*b;
				ans=min(ans,mid*a+i*b);
				r=mid-1;
			}
			else l=mid+1;
		}
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：Okimoto (赞：1)

# P7287 【「StOI-3」魔法】
### 算法： 二分 + 倍增思想
这题数据范围好大，本蒟蒻一看就只能看出是二分或者倍增。

二分肯定是围绕着代价进行二分的，关键是check函数的写法。

如果先枚举加法肯定TLE，所以不能枚举加法的次数。

我们知道：代价一定，加法所用的代价一定，乘法所用的代价等与前两者之差。
则反之，亦然：代价一定，乘法所用的代价一定，加法所用的的代价等于前两者之差。

因为乘法可以表示为： $x \times a ^ i$ ，所以我们只需要枚举 $i$ 便可。

整个程序的复杂度为： $O(nlog^2n)$

```cpp
#include <stdio.h>
#include <math.h>
#include <algorithm>
#include <string.h>
using namespace std;
long long n, a, b, s;
long long ans;
long long arr[100007];
long long buf[100007];
bool check(long long v)
{
    bool yes = false;
    for(long long i = 0; i <= 31; i++)
    {
        long long w = v - i * b;
        long long p = pow(2, i);
        long long x = w / a;
        if(w < 0){ continue; }
        for(long long j = 1; j <= n; j++)
        {
            buf[j] = arr[j] + x;
        }
        long long mx = 0;
        long long cmx = 0;
        for(long long j = 1; j <= n; j++)
        {
            if(cmx >= 0)
            {
                cmx += buf[j];
            }
            else
            {
                cmx = buf[j];
            }
            if(cmx > mx)
            {
                mx = cmx;
            }
        }
        yes |= ((mx * p) >= s);
    }
    return yes;
}
int main()
{
    scanf("%lld%lld%lld%lld", &n, &a, &b, &s);
    for(long long i = 1; i <= n; i++)
    {
        scanf("%lld", &arr[i]);
    }
    long long l = 0;
    long long r = 4000000000;
    while(l <= r)
    {
        long long mid = (l + r) >> 1;
        if(check(mid))
        {
            ans = mid;
            r = mid - 1;
        }
        else
        {
            l = mid + 1;
        }
    }
    printf("%lld", ans);
    return 0;
}

```


---

## 作者：RemiliaScar1et (赞：0)

## P7287 「EZEC-5」魔法

~~第一眼会认为是数据结构的题~~

首先我们可以发现，若魔法 2 的操作子段和是正整数，那么它的最高操作次数是 $\log S$ 级别的。当它操作的子段和是负数的时候，它会使得和越来越小。

其次我们发现，对于固定的操作次数，最优解一定是先加再乘。先加可以将后来加的数的贡献最大化，而且一开始可能还需要加操作来弥补负数。但是加操作的次数是 $2S$ 级别的，我们不可能枚举。

不过比较明显 ~~(但容易忽略)~~ 的性质是：若 $x$ 次操作可以达到目标，那么 $x+1$ 次操作也一定可以。换句话说，操作次数具有单调性。而两种操作的代价都是正的，代价的增加与次数的增加成正比。所以我们可以考虑使用二分。

对于乘法操作，枚举次数复杂度就是 $\log s$  级，我们只需要二分加法次数即可。

对于二分的 `check` 函数的设置。现在我们已经猜测了一个加操作的执行次数，需要判断是否有解。这里，可以贪心地得出最大子段和并对其做乘法操作。另外，本题可能爆 `long long` ，请使用一些措施来避免。这里我将其转成了 `__int128`。

完整code :

```cpp
#include <bits/stdc++.h>
using namespace std;
/*
	两个操作都有可二分的性质
	考虑枚举一个，二分另外一个
	由于魔法1最大次数更多，故二分魔法1的次数
*/
typedef long long ll;
const int N=5e6+10;

ll n,a,b,s;
ll arr[N];

bool check(ll mid,ll k)
{
	ll t=0,ans=-1e18;
	for(int i=1;i<=n;i++)
	{
		if(t<0) t=0;
		t+=arr[i]+mid;
		ans=max(t,ans);
	}
	return (__int128)ans*(1LL<<k)>=(__int128)s;
}

int main()
{
	scanf("%lld%lld%lld%lld",&n,&a,&b,&s);
	for(int i=1;i<=n;i++)  scanf("%lld",&arr[i]);
	ll anss=1e18;
	for(ll k=0;k<=40;k++)
	{
		ll l=0,r=1e16,ans=0;
		while(l<=r)
		{
			ll mid=(r-l)/2+l;
			if(check(mid,k)) ans=mid,r=mid-1;
			else l=mid+1;
		}
		anss=min(anss,a*ans+b*k);
	}
	printf("%lld",anss);
	return 0;
}
```

---

## 作者：raincity (赞：0)

## 分析
首先容易看出两个性质：

1. 选择的区间 $[l,r]$ 一定是 $[1,n]$
2. 一定是先用多次第一种魔法，再用多次第二种魔法。

那么我们可以枚举第二种魔法的使用次数 $magic1$（不超过 $\log s$），然后二分第一种魔法的使用次数 $magic2$（二分次数不超过 $\log s$），求出使用第一种魔法之后的最大子段和 $maxsum$，判断 $maxsum\times 2^{magic2}$ 是否 $\ge s$ 即可。

（注意是 $\ge$ 不是 $>$，不然可能得到 30pts 的好成绩）

总时间复杂度 $O(n\log^2s)$。

## 解决
```cpp
#include <iostream>
#include <cstdio>

using namespace std;

const int N = 1e5 + 5;
int n, a, b, s, A[N];
long long ans = 2e18;

inline bool check(int magic1, int magic2) {
	register long long maxsum = -2e18, sum = 0;
	for (register int i = 1; i <= n; i++) {
		sum = sum + A[i] + magic1;
		if (sum > maxsum)
			maxsum = sum;
		if (sum < 0)
			sum = 0;
	}
	if (maxsum < 0)
		return false;
	if (maxsum > s)
		return true;
	while (magic2--) {
		maxsum <<= 1;
		if (maxsum > s)
			return true;
	}
	return false;
}

inline void read(int &ret) {
	ret = 0;
	char ch = getchar(), flag = 0;
	while ((ch < '0' || ch > '9') && ch != '-') ch = getchar();
	if (ch == '-')
		flag = 1, ch = getchar();
	while (ch >= '0' && ch <= '9') ret = ret * 10 + ch - '0', ch = getchar();
	if (flag)
		ret = -ret;
}

int main() {
	cin >> n >> a >> b >> s;
	for (register int i = 1; i <= n; i++) read(A[i]);
	for (register int magic2 = 0; magic2 <= 32; magic2++) {
		register int l = 0, r = 2e9, mid, res;
		while (l <= r) {
			mid = l + ((r - l) >> 1);
			if (check(mid, magic2))
				res = mid, r = mid - 1;
			else
				l = mid + 1;
		}
		ans = min(ans, 1LL * a * res + 1LL * b * magic2);
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：cmll02 (赞：0)

先看操作顺序。假如选择 $s$ 个数和为 $a$，先加后乘得到 $2s+2a$，先乘后加得到 $2s+a$，显然不如先加后乘。

其次我们发现我们要操作干脆直接整个数组加/乘就行了。

我们试着枚举乘的次数，然后发现加法操作的数量可以二分。

再写个最大子断和来判断即可，复杂度 $n\log s\log (2\times 10^9)$。

Code:（注意本代码爆 LL，`__int128` 需要。）
```
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <assert.h>
#include <stdlib.h>
#include <time.h>
#define int __int128
inline int read()
{
	int num = 0,f=1; char c = getchar();
	while (c<48 || c>57)f=(c=='-'?-1:f),c = getchar();
	while (c >= 48 && c <= 57)num = (num << 3) + (num << 1) + (c ^ 48), c = getchar();
	return num*f;
};
int a[100005],f[100005];
int LIS(int n,int x)
{
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		f[i]=a[i]+x;
		if(f[i-1]>0)f[i]+=f[i-1];
		ans=ans>f[i]?ans:f[i];
	}
	return ans;
}
int erfen(int n,int b,int s)
{
	int L=0,R=2000000001,ans;
	while(L<=R)
	{
		int M=(L+R)>>1;
		int u=LIS(n,M);
	//	printf("LIS %lld %lld %lld %lld %lld\n",n,M,u,b,s);
		if(u>=s)ans=M,R=M-1;
		else L=M+1;
	}
	return ans;
}
inline void wt(int a)
{
    if(a>9)wt(a/10);putchar(a%10+48);
}
signed main()
{
	int ans=0x3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f,n=read(),aa=read(),b=read(),s=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=0;s>1;i++)
	{
		int p=erfen(n,i,s),q=p*aa+i*b;
			ans=ans<q?ans:q;
		s=(s+1)/2;
		if(s==1)
		{
			i++;
			int p=erfen(n,i,s),q=p*aa+i*b;
			ans=ans<q?ans:q;
		}
	}	
	wt(ans);
	return 0;
}
```

---


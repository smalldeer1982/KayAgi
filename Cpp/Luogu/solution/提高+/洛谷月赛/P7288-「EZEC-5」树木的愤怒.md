# 「EZEC-5」树木的愤怒

## 题目背景

小 L 总是在卑微地被强大的人吊打，其中包括小 Y。

## 题目描述

小 L 和 小 Y 是好朋友。有一天，小 L 拿来了一棵 $n$ 个点的有权值的树。第 $u$ 个点的权值为 $a_u$。但是小 Y 讨厌树，所以二话不说直接把树上的一条边给断了。

小 L 很愤怒，但是为了保持该有礼貌，他决定做好事情后再把这条边连起来。但是，他总是操作失误，导致不但没法连起来，还会有另一条边被断掉。于是，这棵树就被分成了 $3$ 个连通块。

小 Y 看不下去了，于是在割掉边后，开始思考一个对他来说很难的问题。他想知道，在割掉第 $x$ 条边后，由于小 L 还会因为操作失误割掉一条边，则最后所形成的 **3 个连通块的权值和的乘积的所有情况的总和** 是多少。即设这三个连通块分别为 $a,b,c$，求在已经割掉一条边的情况下 

$$
(\sum_{u\in a} a_u)\times (\sum_{u\in b} a_u) \times (\sum_{u\in c} a_u)
$$

的总和。

由于愤怒，每次你算好后，小 L 都会对你帮助小 Y 算出的答案不理不顾，于是小 Y 只好把图恢复到原来那棵树，再割掉一条边，你也得再帮助小 Y 算一次，即再进行一次可能不一样的询问。你需要这样帮助小 Y 一共 $q$ 次，即回答 $q$ 个询问。又因为小 L 和小 Y 都很讨厌太大的数，所以请你用输出这个总和对 $99991$ 取模的结果。又因为输出太耗费时间，你只需要输出所有询问的答案对 $99991$ 取模的总和以及异或和即可。

## 说明/提示

**样例说明**

对于样例一的第一个询问。已经割掉了第一条边（即边 $(1,2)$）。若小 L 再割掉的边是 $(2,3)$，那么 3 个连通块的权值和的乘积为 $1\times 2\times (3+4)=14$。若小 L 再割掉的边是 $(3,4)$，那么 3 个连通块的权值和的乘积为 $1\times (2+3)\times 4=20$。所以输出为 $14+20=34$。

对于样例一的第二个询问。已经割掉了第二条边（即边 $(2,3)$）。若小 L 再割掉的边是 $(1,2)$，那么 3 个连通块的权值和的乘积为 $1\times 2\times (3+4)=14$。若小 L 再割掉的边是 $(3,4)$，那么 3 个连通块的权值和的乘积为 $(1+2)\times 3\times 4=36$。所以输出为 $14+36=50$。

同理，我们可以求出样例一的第三个询问，答案为 $20+36=56$。

所以三个答案的总和是 $140$，异或和是 $40$。

---
**数据规模**

$\texttt{Subtask 1 (1 pts) } a_i=0$。  
$\texttt{Subtask 2 (5 pts) } n,q\le 300$。  
$\texttt{Subtask 3 (14 pts) } n\le 300$。  
$\texttt{Subtask 4 (20 pts) } n\le 5000$。  
$\texttt{Subtask 5 (10 pts) } u=v-1$。  
$\texttt{Subtask 6 (50 pts) }$ 没有特殊限制。

对于全部数据，满足 $2 \le n, q \le {10}^6$，$0 \le a_i \le {10}^6$。

---

idea by lgswdn  
tested by LHQing, Karry5307

## 样例 #1

### 输入

```
4 3
1 2 3 4
1 2
2 3
3 4
1
2
3
```

### 输出

```
140
40```

## 样例 #2

### 输入

```
7 2
1 1 1 1 1 1 1
1 2
1 3
2 6
2 4
1 5
3 7
2
6```

### 输出

```
70
52```

# 题解

## 作者：wsyhb (赞：8)

## 题意简述

给定一棵 $n$ 个节点的树，第 $u$ 个点的权值为 $a_u$。有 $q$ 次查询，每次询问给出一个编号 $id$，表示询问“**删除第 $id$ 条边和其余某条边后 $3$ 个连通块点权和的乘积**”的**所有情况之和**。

**数据范围**：$n,q \le 10^6$

## 分析 + 题解

由于询问数量 $q$ 与 $n$ 同阶，该问题需要对**任意一个连通块**求**点权和**以及**删除其中某条边后的 $2$ 个连通块点权和乘积的所有情况之和**，前一个问题很好处理，后一个问题不难想到**换根**（严格来说不算 DP）。

此处以**对以 $x$ 为根的子树求解**上述问题为例进行讲解。

设 $x$ 子树的点权和为 $sum_x$，对 $x$ 子树求解上述问题所得结果为 $ans_x$，则有：

$$ans_x=\sum_{y \in subtree_x}sum_y(sum_x-sum_y)=sum_x \cdot (\sum_{y \in subtree_x} sum_y)-(\sum_{y \in subtree \;x} sum^2_y)$$

其中 $subtree_x$ 表示 $x$ 子树中包括 $x$ 的点组成的集合。

设 $dp_x=\sum_{y \in subtree_x} sum_y$，$dp2_x=\sum_{y \in subtree_x} sum^2_y$，则上式化简为：

$$ans_x=sum_x \cdot dp_x - dp2_x$$

而 $dp_x$ 和 $dp2_x$ 都很好求：

$$dp_x=sum_x+\sum_{y \in son_x}dp_y ,dp2_x=sum^2_x+\sum_{y \in son_x}dp2_y$$

再加上这是一个求和式，**无需采用“前缀+后缀”的换根形式**，只需使用简单的换根即可，具体实现见代码。

## 代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int P=99991;//注意模数 
inline void add(int &a,int b)
{
	a=a+b-(a+b>=P?P:0);
}
inline void sub(int &a,int b)
{
	a=a-b+(a-b<0?P:0);
}
inline int get_sum(int a,int b)
{
	return a+b-(a+b>=P?P:0);
}
inline int get_dif(int a,int b)
{
	return a-b+(a-b<0?P:0);
}
inline int get_pro(int a,int b)
{
	return 1ll*a*b%P;
}
inline int get_square(int x)
{
	return 1ll*x*x%P;
}
//以上是模意义运算 
const int max_n=1e6+5;
int End[max_n<<1],Last[max_n],Next[max_n<<1],e;
inline void add_edge(int x,int y)
{
	End[++e]=y;
	Next[e]=Last[x];
	Last[x]=e;
	End[++e]=x;
	Next[e]=Last[y];
	Last[y]=e;
}
int a[max_n],fath[max_n],sum_in[max_n],dp_in[max_n],dp2_in[max_n];//in 表示子树内 
void dfs1(int x,int fa)
{
	fath[x]=fa;
	sum_in[x]=a[x];
	for(int i=Last[x];i;i=Next[i])
	{
		int y=End[i];
		if(y!=fa)
		{
			dfs1(y,x);
			add(sum_in[x],sum_in[y]);
			add(dp_in[x],dp_in[y]);
			add(dp2_in[x],dp2_in[y]);
		}
	}
	add(dp_in[x],sum_in[x]);
	add(dp2_in[x],get_square(sum_in[x]));
}
int sum_out[max_n],dp_out[max_n],dp2_out[max_n],sum_all;//out 表示子树外 
void dfs2(int x,int fa)
{
	if(fa!=0)
	{
		dp_out[x]=get_sum(dp_out[fa],sum_out[x]);//这两项分别对应下图的红色和黄色部分 
		add(dp_out[x],dp_in[fa]);
		sub(dp_out[x],get_sum(sum_in[fa],dp_in[x]));//这两行对应下图中的蓝色部分 
		dp2_out[x]=get_sum(dp2_out[fa],get_square(sum_out[x]));
		add(dp2_out[x],dp2_in[fa]);
		sub(dp2_out[x],get_sum(get_square(sum_in[fa]),dp2_in[x]));
	}
	for(int i=Last[x];i;i=Next[i])
	{
		int y=End[i];
		if(y!=fa)
			dfs2(y,x);
	}
}
int ans_in[max_n],ans_out[max_n];//ans 与上文所述含义相同 
bool vis_in[max_n],vis_out[max_n];
inline int work_in(int x)//记忆化求解 
{
	if(vis_in[x])
		return ans_in[x];
	vis_in[x]=true;
	ans_in[x]=get_dif(get_pro(dp_in[x],sum_in[x]),dp2_in[x]);
	return ans_in[x];
}
inline int work_out(int x)
{
	if(vis_out[x])
		return ans_out[x];
	vis_out[x]=true;
	ans_out[x]=get_dif(get_pro(dp_out[x],sum_out[x]),dp2_out[x]);
	return ans_out[x];
}
int u[max_n],v[max_n];//存储边的端点 
int main()
{
	int n,q;
	scanf("%d%d",&n,&q); 
	for(int i=1;i<=n;++i)
	{
		scanf("%d",a+i);
		a[i]%=P;//记得读入时模一次 
		add(sum_all,a[i]);//sum_all 记录 n 个点的点权和 
	}
	for(int i=1;i<=n-1;++i)
	{
		scanf("%d%d",u+i,v+i);
		add_edge(u[i],v[i]);
	}
	dfs1(1,0);
	for(int i=1;i<=n-1;++i)
	{
		if(fath[v[i]]==u[i])
			swap(u[i],v[i]);//使 u[i] 是 v[i] 的儿子 
	}
	for(int i=1;i<=n;++i)
		sum_out[i]=get_dif(sum_all,sum_in[i]);
	dfs2(1,0);
	long long ans1=0;//开 long long 
	int ans2=0;
	while(q--)
	{
		int id;
		scanf("%d",&id);
		int x=u[id];
		int ans=get_pro(work_in(x),sum_out[x]);//讨论删除 x 子树内边的情况 
		add(ans,get_pro(sum_in[x],work_out(x)));//讨论删除 x 子树外边的情况
		ans1+=ans,ans2^=ans;
	}
	printf("%lld\n%d\n",ans1,ans2);
	return 0;
}
```

代码中提到的图片如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/ibsnc9pv.png)

可结合图片理解换根部分的代码。

---

## 作者：渡鸦2007 (赞：4)

## 题意

现有一棵树，给出一条删去的边，要你再删去一条边，将树分成三个连通块。求：所有删边方案获得的**连通块权值和的积**的和。

## 分析

该题难度较大，主要在于繁琐的预处理与讨论后的边界情况。接下来我们一步步分析。

### 约定记法

我们先把它转成一颗有根树，不失一般性，以节点 $1$ 为根。对于边 $(u,v)$，其中 $u$ 是 $v$ 的**父亲**，此处为方便书写记它为 $e_v$。

再记节点 $u$ 的子树（特别的，包含 $u$ 自身）为 $ST_u$，节点 $u$ 到节点 $1$ 的路径（不包括节点 $1,u$）为 $R_u$。

### 位置讨论

那么我们思考，对于题目给出的边 $e_x$，我们新删去的一条边 $e_i$，有几种不同的位置情况？我们分析，什么情况下，分割成的连通块会“相互影响”。

显然当 $i \in ST_x$ 或 $i \in R_x$ 时，连通块不是子树本身。否则，连通块就是两颗子树与剩余部分，即 $ST_u,ST_i,\complement_{ST_1}(ST_u \cup ST_i)$。

于是，我们将 $i$ 分为三类：

-   $i$ 是 $x$ 的后代，即 $i \in ST_x$。
-   $i$ 是 $x$ 的祖先，这里 $i \neq 1$，因为并不存在 $e_1$。即 $i\in R_x$。
-   其它所有情况，即 $i\notin ST_x$ 且 $i\notin R_x$。

### 答案统计

我们约定， $ST_x$ 中所有值的和为 $sum_x$。

#### 情况1，后代

分成的三个连通块分别为 $ST_i,\complement_{ST_x}ST_i,\complement_{ST_1}ST_x$。

如下图，若 $x=5$，则可取的 $i$ 只能有 $i=8$。

故而此时 $ ST_i=\{8\} , ST_x=\{5,8\} , \complement_{ST_x}ST_i=\{5\} $。

这种情况下，显然答案为：

$$\sum_{i \in ST_x} sum_i \times (sum_x-sum_i) \times (sum_1-sum_x) $$

将不变的 $sum_x,sum_1$ 提取，得到上式

$$=(sum_1-sum_x) \times \sum_{i \in ST_x} (sum_x \times sum_i -sum_i^2)$$

于是，我们预处理出 $ST_x$ 内所有可能的 $sum_i$ 的和与平方和，分别记为 $ss_x,sss_x$，这里包括 $x$ 本身。

也即：
$$ss_x=\sum_{i\in ST_i}sum_i(i \neq x),sss_x=\sum_{i\in ST_i}sum_i^2 (i \neq x)$$

显然这可以通过一次搜索预处理出来。

故本情况答案为： 
$$(sum_1-sum_x) \times (sum_x\times (ss_x-sum_x) - (sss_x-sum_x^2))$$

![](https://cdn.luogu.com.cn/upload/image_hosting/xd09twra.png)

#### 情况2 祖先

分成的三个连通块分别为 $ST_x,\complement_{ST_i}ST_x,\complement_{ST_1}ST_i$。

如下图，若 $x=5$，则只能有 $i=2$。此时 $ST_x=\{5,8\},\complement_{ST_i}ST_x=\{2,4\}$。

答案为：
$$\sum_{i \in Rx} sum_x \times (sum_i-sum_x) \times (sum_1-sum_i)$$

$$=sum_x \times\sum_{i \in Rx} (-sum_1\times sum_x + sum_i \times(sum_1-sum_x) - sum_i^2)$$

类似的，我们记录 $rs_x=\sum _{i\in R_x}sum_i,rss_x=\sum{i \in R_x} sum_i^2$。

于是上式
$$=sum_x \times (-sum_1\times sum_x + rs_x \times (sum_1-sum_x) - rss_x)$$

#### 情况3 其它

我们记该情况下 $i \in Able$，显然，$Able=ST_1-ST_x-R_x-\{1\}$。那么所有可能的 $i$ 的和与平方和是显然容易求出的。

分别将其记为 $ss_{Able},sss_{Able}$，则 $ss_{Able}=ss_1-ss_x-rss_x-sum_1$，$sss_{Able}$ 也类似容斥可得。

分成的三个联通块分别是 $ST_x,ST_i,\complement_{ST_1}(ST_x \cup ST_i)$。

答案为：
$$\sum _{i \in Able} sum_x \times sum_i \times (sum_1-sum_x-sum_i)$$

$$=sum_x \times \sum_{i \in Able} ( (sum_1-sum_x) \times sum_i - sum_i^2)$$

$$= sum_x \times ((sum_1-sum_x) \times ss_{Able} -sss_{Able} )$$

---

这样，我们讨论了三种不同的情况，不重不漏地将所有的可能方案分为三类。

并且，我们可以通过 $O(n)$ 的预处理，进行 $O(1)$ 统计答案。

### 易错提醒

-   预处理时要注意顺序。
    
-   计算中必须及时取模。
    
-   询问给出的是边而非点。
    
-   输出不需要取模，只有每次统计需要。
    

## 代码
以下代码在经过少量优化后用时为 $1.60s$，是本题最优解。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int read()
{
	char c=getchar();bool f=0;int ret=0;
	while (!isdigit(c))
	{
		if (c=='-') f=1;
		c=getchar();
	}
	while (isdigit(c))
	{
		ret*=10;ret+=c-'0';
		c=getchar();
	}
	if (f) return -ret;else return ret;
}
const int S=1e6+5;
struct edge
{
	int t,nxt;
}e[S<<1];int cnt=1;int head[S];
void add(int f,int t)
{
	e[++cnt].t =t;e[cnt].nxt =head[f];head[f]=cnt;
}
int val[S];
int sum[S];int dep[S];
int s_sum[S];int s_s_sum[S];//include x_self
int r_s_sum[S],r_s_s_sum[S];//not include self,not include 1 
const int mod=99991;
void pre(int id,int fa)//处理sum
{
	sum[id]=val[id];
	dep[id]=dep[fa]+1;
	for (int i=head[id];i;i=e[i].nxt )
	{
		if (e[i].t ==fa) continue;
		pre(e[i].t ,id);
		sum[id]+=sum[e[i].t ];sum[id]%=mod; 
	}
	
}
void dfs(int id,int fa)//处理ss,sss
{
	s_sum[id]=sum[id];s_s_sum[id]=sum[id]*sum[id]%mod;
	for (int i=head[id];i;i=e[i].nxt )
	{
		if (e[i].t ==fa) continue;
		dfs(e[i].t ,id);
		s_sum[id]+=s_sum[e[i].t ];s_sum[id]%=mod;
		s_s_sum[id]+=s_s_sum[e[i].t ];s_s_sum[id]%=mod;	
	}
	
}
void dfs2(int id,int fa)//处理rs,rss
{
	if (dep[id]>2)
	{
		r_s_sum[id]+=sum[fa];r_s_s_sum[id]%=mod;
		r_s_s_sum[id]+=sum[fa]*sum[fa];r_s_s_sum[id]%=mod;
	}
	for (int i=head[id];i;i=e[i].nxt )
	{
		if (e[i].t ==fa) continue;
		if (id!=1) 
		{
			r_s_sum[e[i].t]=r_s_sum[id];r_s_sum[e[i].t]%=mod;
			r_s_s_sum[e[i].t]=r_s_s_sum[id];r_s_s_sum[e[i].t]%=mod;
		}
		dfs2(e[i].t ,id);
	}
	
}
int out1=0,out2=0;
void solve(int x)
{
	int ans=0;
	//Case 1:后代
	ans+=(sum[1]-sum[x])*((sum[x]*(s_sum[x]-sum[x])%mod)-(s_s_sum[x]-sum[x]*sum[x]%mod))%mod;ans%=mod;
	//Case 2:祖先
	ans+=sum[x]*((sum[1]*(r_s_sum[x])%mod)-r_s_s_sum[x])%mod;ans%=mod;
	ans+=(sum[x]*sum[x]%mod)*((-sum[1]*(dep[x]-2)%mod)+r_s_sum[x])%mod;ans%=mod;
	//Case 3:其它
	ans+=(sum[x]*(s_sum[1]-s_sum[x]-r_s_sum[x]-sum[1])%mod)*(sum[1]-sum[x])%mod;ans%=mod;
	ans-=sum[x]*(s_s_sum[1]-s_s_sum[x]-r_s_s_sum[x]-sum[1]*sum[1]%mod)%mod;ans%=mod;
  	
	ans+=mod;ans%=mod;
	out1+=ans;
	out2^=ans;
}
signed main()
{
	int n,q;n=read();q=read();
	for (int i=1;i<=n;++i)
	{
		val[i]=read();
	}
	for (int i=1;i<n;++i)
	{
		int u,v;u=read();v=read();add(u,v);add(v,u);
	}
	pre(1,0);
	dfs(1,0);
	dfs2(1,0);
	for (int i=1;i<=q;++i)
	{
		int q;q=read();
		int ask=e[q<<1].t ;if (dep[ask]<dep[e[(q<<1)^1].t ]) ask=e[(q<<1)^1].t ;
        //处理点，因为我的边编号从1开始并存双向
		solve(ask);
	}
	cout<<out1<<'\n'<<out2;
	return 0;
}


```

---

## 作者：xgzc (赞：4)

提供一个更加简便的 dp 方法。

可以发现这题的重点在于边，所以可以考虑枚举边算贡献，同时以边为状态做 dp，注意这里的边都是有向边。

设 $f_{(u, v)}$ 表示忽略边 $u \to v$，在 $v$ 子树内删掉一条边的权值和，$g_{(u, v)}$ 表示忽略边 $u \to v$，在 $v$ 子树内删掉一条边，删掉的的子树大小之和，$s_{(u, v)}$ 表示忽略这条边之后 $v$ 子树的大小，可以发现，只要能够求出 $f$ 就能很方便计算答案。

那么有转移：

$$
\begin{aligned}
f_{(u, v)} &= \sum_{w \neq u, (v, w) \in E} g_{(v, w)} + s_{(v, w)} (s_{u, v} - s_{v, w}) + f_{(v, w)}\\
g_{(u, v)} &= \sum_{w \neq u, (v, w) \in E} g_{(v, w)} + s_{(v, w)}
\end{aligned}
$$

记忆化搜索一下就可以了，感觉会比换根 dp 好写很多。

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
#define file(x) freopen(#x".in", "r", stdin), freopen(#x".out", "w", stdout)

inline int read()
{
	int data = 0, w = 1; char ch = getchar();
	while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
	if (ch == '-') w = -1, ch = getchar();
	while (ch >= '0' && ch <= '9') data = data * 10 + (ch ^ 48), ch = getchar();
	return data * w;
}

const int N(1e6 + 10), Mod(99991);
inline int upd(const int &x) { return x + (x >> 31 & Mod); }
struct edge { int next, to; } e[N << 1];
int n, Q, a[N], siz[N << 1], vis[N << 1], f[N << 1], g[N << 1], head[N], e_num = 1;
inline void add_edge(int from, int to)
	{ e[++e_num] = (edge) {head[from], to}, head[from] = e_num; }

void dfs(int e)
{
	if (vis[e]) return; int x = ::e[e].to;
	vis[e] = 1, siz[e] = a[x], f[e] = g[e] = 0;
	for (int i = head[x]; i; i = ::e[i].next) if (i != (e ^ 1))
		dfs(i), siz[e] = upd(siz[e] + siz[i] - Mod), g[e] = (g[e] + siz[i] + g[i]) % Mod, f[e] = upd(f[e] + f[i] - Mod);
	for (int i = head[x]; i; i = ::e[i].next) if (i != (e ^ 1))
		f[e] = (f[e] + 1ll * (g[i] + siz[i]) * (siz[e] - siz[i] + Mod)) % Mod;
}

int main()
{
#ifndef ONLINE_JUDGE
	file(cpp);
#endif
	n = read(), Q = read();
	for (int i = 1; i <= n; i++) a[i] = read() % Mod;
	for (int i = 1, a, b; i < n; i++)
		a = read(), b = read(), add_edge(a, b), add_edge(b, a);
	long long s1 = 0, s2 = 0;
	while (Q--)
	{
		int x = read() << 1, y = x | 1, res = 0; dfs(x), dfs(y);
		res = (1ll * f[x] * siz[y] + 1ll * f[y] * siz[x]) % Mod;
		s1 += res, s2 ^= res;
	}
	printf("%lld\n%lld\n", s1, s2);
	return 0;
}
```

---

## 作者：ghr_226 (赞：2)

## Description

删除两条边，将树分成三个连通块 $A,B,C$，贡献为连通块点权和之积

删去一条边，问再删去任意一条边后的贡献和

## Solution

考虑预处理出所有答案

先将边下放到子节点

$O(n^2)$ 做法：

枚举删除的任意两条边，算出贡献，累加到两条边上

考虑优化

发现删去一条边后，再删第二条边时，对于很多情况，都会有一个连通块不变，考虑剩下连通块的贡献一起算，再乘上这个连通块的贡献

分类讨论

定义 $s_u$ 为子树 $u$ 的点权和

- 删的第二条边在子树内

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210126212858351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdrb25ncmVwb3J0ZXI=,size_16,color_FFFFFF,t_70)

贡献为

$$
(s_1-s_u)\sum_{v\in son_u}(s_u-s_v)s_v\\
=(s_1-s_u)\sum_{v\in son_u}(s_us_v-s_v^2)\\
=(s_1-s_u)(s_u\sum_{v\in son_u}s_v-\sum_{v\in son_u}s_v^2))
$$

将 $s$ 做子树和，平方的子树和，$O(n)$ 统计贡献

- 删的第二条边在到根的路径上

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210126213342414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdrb25ncmVwb3J0ZXI=,size_16,color_FFFFFF,t_70)

贡献为

$$
s_u\sum_{v\in road_{1,u}}(s_1-s_v)(s_v-s_u)\\
=s_u\sum_{v\in road_{1,u}}(s_1s_v-s_1s_u-s_v^2+s_us_v)\\
=s_u(s_1\sum_{v\in road_{1,u}}s_v-\sum_{v\in road_{1,u}}s_1s_u-\sum_{v\in road_{1,u}}s_v^2+s_u\sum_{v\in road_{1,u}}s_v)
$$

发现$\sum_{v\in road_{1,u}}s_1s_u=s_1s_u(dep_u-1)$

从根向下 **dfs**，维护路径权值和，权值平方和，$O(n)$ 统计贡献

- 删的第二条边在其他部分

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210126213747334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdrb25ncmVwb3J0ZXI=,size_16,color_FFFFFF,t_70)

贡献为

$$
s_u\sum_{v\notin son_u,v\notin road_{1,u}} s_v(s_1-s_u-s_v)\\
=s_u\sum_{v\notin son_u,v\notin road_{1,u}}(s_1s_v-s_us_v-s_v^2)\\
=s_u(s_1\sum_{v\notin son_u,v\notin road_{1,u}}s_v-s_u\sum_{v\notin son_u,v\notin road_{1,u}}s_v-\sum_{v\notin son_u,v\notin road_{1,u}}s_v^2)
$$

先将节点到根的路径上的点算进来，将 $s$ 做子树和，平方的子树和，$O(n)$ 统计贡献

再从根向下 **dfs**，维护路径权值和，权值平方和，减去节点到根的路径上多余的贡献

将以上三个贡献累加到一起，这道题就 $O(n)$ 做完了

## Code

放个没压行的

```cpp
#include <bits/stdc++.h>
using namespace std;

#define re register
#define LL long long
typedef unsigned int uint;
typedef unsigned long long ull;

#define int long long

#define Pr pair<int, int>
#define fir first
#define sec second
#define pb push_back
#define mp make_pair

namespace IO {
char buf_[1 << 21], *p1_ = buf_, *p2_ = buf_;
#define ch()                                                                 \
  (p1_ == p2_ &&                                                             \
           (p2_ = (p1_ = buf_) + fread(buf_, 1, 1 << 21, stdin), p1_ == p2_) \
       ? EOF                                                                 \
       : *p1_++)
inline int in() {
  int s = 0, f = 1;
  char x = ch();
  for (; x < '0' || x > '9'; x = ch())
    if (x == '-') f = -1;
  for (; x >= '0' && x <= '9'; x = ch()) s = (s * 10) + (x & 15);
  return f == 1 ? s : -s;
}
char _buf[1 << 21];
int _pos = -1;
inline void flush() { fwrite(_buf, 1, _pos + 1, stdout), _pos = -1; }
inline void pc(char x) {
  if (_pos == (1 << 21) - 1) flush();
  _buf[++_pos] = x;
}
inline void out(int x) {
  char k[30];
  int pos = 0;
  if (!x) return pc('0');
  if (x < 0) pc('-'), x = -x;
  while (x) k[++pos] = (x % 10) | 48, x /= 10;
  for (int i = pos; i; i--) pc(k[i]);
}
inline void out(string x) {
  int len = x.size();
  for (int i = 0; i < len; i++) pc(x[i]);
}
}  // namespace IO
using namespace IO;

const int A = 1e6 + 5;
const int mod = 99991;
inline int add(int x, int y) { return x + y >= mod ? x + y - mod : x + y; }
inline int dec(int x, int y) { return x - y < 0 ? x - y + mod : x - y; }
inline int mul(int x, int y) { return x * y % mod; }
inline void Add(int &x, int y) { x = add(x, y); }
inline void Dec(int &x, int y) { x = dec(x, y); }
inline void Mul(int &x, int y) { x = mul(x, y); }
int n, Q;
int a[A];
struct Node {
  int x, y;
  Node(int _x = 0, int _y = 0) { x = _x, y = _y; }
} r[A];
int head[A], tot_road;
struct Road {
  int nex, to;
} road[2 * A];
inline void edge(int x, int y) {
  road[++tot_road] = (Road){head[x], y}, head[x] = tot_road;
}
int dep[A], down[A];
int ans[A];

int s[A];

inline void DFS0(int fa, int x) {
  dep[x] = dep[fa] + 1, s[x] = a[x];
  for (int y = head[x]; y; y = road[y].nex) {
    int z = road[y].to;
    if (z == fa) continue;
    DFS0(x, z);
    Add(s[x], s[z]);
  }
  return;
}

int s1[A], s2[A];

inline void DFS1(int fa, int x) {
  s1[x] = s[x], s2[x] = mul(s[x], s[x]);
  for (int y = head[x]; y; y = road[y].nex) {
    int z = road[y].to;
    if (z == fa) continue;
    DFS1(x, z);
    Add(s1[x], s1[z]);
    Add(s2[x], s2[z]);
  }
  return;
}

inline void calc_in() {
  for (int i = 1; i <= n; i++)
    Add(ans[i], mul(dec(s[1], s[i]), dec(mul(s[i], s1[i]), s2[i])));
  return;
}

inline void DFS2(int fa, int x, int ss1, int ss2) {
  Dec(ans[x], mul(s[x], dec(mul(dec(s[1], s[x]), ss1), ss2)));
  Add(ss1, s[x]);
  Add(ss2, mul(s[x], s[x]));
  for (int y = head[x]; y; y = road[y].nex) {
    int z = road[y].to;
    if (z == fa) continue;
    DFS2(x, z, ss1, ss2);
  }
  return;
}

inline void calc_out() {
  for (int i = 1; i <= n; i++)
    Add(ans[i], mul(s[i], dec(mul(dec(s[1], s[i]), dec(s1[1], s1[i])),
                              dec(s2[1], s2[i]))));
  DFS2(0, 1, 0, 0);
  return;
}

inline void DFS3(int fa, int x, int ss1, int ss2) {
  Add(ans[x], mul(mul(s[x], s[1]), ss1));
  Dec(ans[x], mul(s[x], ss2));
  Add(ans[x], mul(mul(s[x], s[x]), ss1));
  Add(ss1, s[x]);
  Add(ss2, mul(s[x], s[x]));
  for (int y = head[x]; y; y = road[y].nex) {
    int z = road[y].to;
    if (z == fa) continue;
    DFS3(x, z, ss1, ss2);
  }
  return;
}

inline void calc_fa() {
  for (int i = 1; i <= n; i++)
    Dec(ans[i], mul(mul(s[i], s[i]), mul(s[1], dep[i] - 1)));
  DFS3(0, 1, 0, 0);
  return;
}

signed main() {
  n = in(), Q = in();
  for (int i = 1; i <= n; i++) a[i] = in() % mod;
  for (int i = 1; i < n; i++) {
    int u = in(), v = in();
    r[i] = Node(u, v);
    edge(u, v), edge(v, u);
  }
  DFS0(0, 1);
  for (int i = 1; i < n; i++) {
    if (dep[r[i].x] > dep[r[i].y])
      down[i] = r[i].x;
    else
      down[i] = r[i].y;
  }
  DFS1(0, 1);
  calc_in();
  calc_out();
  calc_fa();
  int res1 = 0, res2 = 0;
  while (Q--) {
    int x = in();
    res1 += ans[down[x]];
    res2 ^= ans[down[x]];
  }
  out(res1), pc('\n'), out(res2), pc('\n');
  flush();
  return 0;
}
```


---

## 作者：MatKave (赞：0)

## 题目大意


有一棵大小为 $n$ 的无根树，节点上有权值 $w_i$ 。

定义三个连通块 $A,B,C$ 的权值为：


$$f(A,B,C)=\left(\sum_{u\in A} w_u\right)\times \left(\sum_{u\in B} w_u\right)\times \left(\sum_{u\in C} w_u\right)$$

有 $q$ 次询问，每次选定一条边删去。现在询问，枚举删去另外一条边，分裂出的三个连通块 $A,B,C$ 的权值的所有情况的和。

## 题解

算是 $\text{Div2}$ 里面最反人类的一道题目了……

虽然题目中给出的是无根树，但是我们仍然固定节点 $1$ 为根节点。

- 定义 $e_u$ 表示节点 $u$ 与父亲节点所连的那条边。特别的， $e_1$ 无定义。

- 定义 $T(u)$ 表示根节点为 $u$ 的这棵子树，它包含了里面所有的点和边（不包括 $v_u$ ）， $T(1)$ 就是原树；同时 $D(u)$ 是节点 $u$ 到树根的距离， $(1,u)$ 表示 $1$ 到 $u$ 这条路径的集合，**不包括端点**。 

- 定义 $S(u)$ 为子树 $u$ 中所有节点的权值和，即 $S_u=\sum_{v\in T(u)}w_v$ ； $P(A)$ 表示 $\sum_{v\in A} S(v)$ ，$Q(A)$ 表示 $\sum_{v\in A} S^2(v)$ 。

每个询问相当于删除了 $e_x$ 。那么删除的第二条边 $e_y$ ，可以作为三种情况进行讨论：

- $1.$ 删除的那条 $e_y$ 在 $x$ 子树中。

- $2.$ 删除的那条 $e_y$ 在 $(1,x)$ 这条路径上。

- $3.$ 其他所有情况。

为什么是这样呢？

先讲一个非常简单又容易理解的小引理，它能告诉我们应该维护什么东西。

$$\begin{aligned}
\sum_{v\in A}(x-S(v))(S(v))&=\sum_{v\in A}\left( xS(v)-S(v)^2\right) \cr
&=x\sum_{v\in A} S(v)-\sum_{v\in A} S^2(v) \cr
&=xP(A)-Q(A)
\end{aligned}$$

于是要想计算左式 ，只要维护 $P(A),Q(A)$ 就行了。

### 情形 $1$ ， $e_y\in T_x/\{x\}$

这时候，分裂出的三个块的权值和分别为：$S(y),S(x)-S(y),S_1-S(x)$ 。简单计算一下这部分的贡献 $W_1$ 。

$$\begin{aligned}
W_1&=\sum_{y\in T(x)/\{x\}}S(y)\cdot (S(x)-S(y))\cdot (S_1-S(x)) \cr
&=(S_1-S(x))\sum_{y\in T(x)/\{x\}}S(y)\cdot (S(x)-S(y)) \cr
&=(S_1-S(x))\Big(S(x)P\big(T(x)/\{x\}\big)-Q\big(T(x)/\{x\}\big)\Big)
\end{aligned}$$

我们只要维护一下， $P(T(x)/\{x\}),Q(T(x)/\{x\})$ 就行了。

### 情形 $2$ ， $e_y\in (1,x)$

这时候，分裂出的三个块的权值和分别为： $S(y),S(x),S(1)-S(y)$ 。同样的，我们计算出这一块的贡献 $W_2$ 。

$$\begin{aligned}
W_1&=\sum_{y\in (1,x)}(S(y)-S(x))\cdot S(x)\cdot (S(1)-S(y)) \cr
&=S(x)\sum_{y\in (1,x)}(S(y)-S(x))(S(1)-S(y)) \cr
&=\left(S(x)\sum_{y\in (1,x)}(S(1)-S(y))S(y)\right)-\left(S^2(x)\sum_{y\in (1,x)}(S(1)-S(y))\right) \cr
&=S(x)\Big(S(1)P((1,x))-Q((1,x))\Big)-S^2(x)\Big(D(x)-2-P((1,x))\Big)
\end{aligned}$$

其中 $D(x)$ 是 $x$ 的深度。

尽管柿子比较丑陋，但是我们仍然只要维护 $P((1,x))$ 和 $Q((1,x))$ 就行了。

### 情形 $3$ ， $e_y$ 在其他地方

不妨设 $y$ 所处的集合为 $O$ 。同样的，分裂出的三个块的大小应该是 $S(x),S(y),S(1)-S(x)-S(y)$ 。推出这部分柿子的总贡献 $W_3$ 。


$$\begin{aligned}
W_3&=\sum_{y\in O} S(x)S(y)\Big(S(1)-S(x)-S(y)\Big) \cr
&=S(x)\sum_{y\in O}S(y)\Big(S(1)-S(x)-S(y)\Big) \cr
&=S(x)\Big((S(1)-S(x))P(O)-Q(O)\Big) \cr
\end{aligned}$$

其中 $P(O),Q(O)$ 可以通过容斥得到。显然，

$$\begin{aligned}
P(O)&=P(T(1))-P(T(x))-P((1,x))-S(1) \cr
Q(O)&=Q(T(1))-Q(T(x))-Q((1,x))-S^2(1) \cr
\end{aligned}$$

最终的答案就出来了：

$$ans=W_1+W_2+W_3$$

我们可以在 $\text{dfs}$ 的同时顺带将各种东西求出来。于是该题在 $\mathcal O(n)$ $\sout{+\text{巨大多常数}}$ 复杂度内解决。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
const int MOD =99991;
const int MAXN=1e6+3;
int head[MAXN*2],ver[MAXN*2],nxt[MAXN*2],tot;
void add(int u,int v){
    ver[++tot]=v,nxt[tot]=head[u],head[u]=tot;
}
int n,q,A[MAXN],S[MAXN],D[MAXN];
int F[MAXN],G[MAXN],P[MAXN],Q[MAXN]; i64 ans1,ans2;
i64 mod(i64 t){ return ((t%MOD)+MOD)%MOD;}
void dfs1(int u,int fa){
    // printf("%d\n",u);
    S[u]=A[u]; for(int i=head[u],v;i;i=nxt[i]){
        v=ver[i]; if(v==fa) continue;
        D[v]=D[u]+1,dfs1(v,u),S[u]=mod(S[u]+S[v]);
    }
}
void dfs2(int u,int fa){
    for(int i=head[u],v;i;i=nxt[i]){
        v=ver[i]; if(v==fa) continue;
        P[v]=mod(P[v]+P[u]+S[u]),Q[v]=mod(1ll*Q[v]+1ll*Q[u]+1ll*S[u]*S[u]);
        if(u==1) P[v]=Q[v]=0; dfs2(v,u);
        F[u]=mod(F[u]+S[v]+F[v]),G[u]=mod(1ll*G[u]+1ll*G[v]+1ll*S[v]*S[v]);
    }
}
int clc(int a,int b,int s){return mod(1ll*s*a-b);}
int U[MAXN],V[MAXN];
signed main(){
    n=qread(),q=qread(); up(1,n,i) A[i]=qread();
    up(1,n-1,i){
        U[i]=qread(),V[i]=qread(); add(U[i],V[i]),add(V[i],U[i]);
    }
    D[1]=-1,dfs1(1,0),dfs2(1,0);
    up(1,q,i){
        int x=qread(),u,s1=0,s2=0,s3=0; u=D[U[x]]>D[V[x]]?U[x]:V[x];
        s1=mod(1ll*clc(F[u],G[u],S[u])*(S[1]-S[u]));
        int t1=mod(1ll*P[u]-1ll*D[u]*S[u]);
        int t2=mod(-2ll*S[u]*P[u]+1ll*Q[u]+1ll*S[u]*S[u]*D[u]);
        s2=mod(1ll*clc(t1,t2,S[1]-S[u])*S[u]);
        int p1=mod(1ll*F[1]-S[u]-F[u]-P[u]);
        int p2=mod(-1ll*S[u]*S[u]+G[1]-G[u]-Q[u]);
        s3=mod(1ll*clc(p1,p2,S[1]-S[u])*S[u]);
        int o=(s1+s2+s3)%MOD; ans1+=o,ans2^=o;
        // printf("%d,%d,%d\n",s1,s2,s3);
        // printf("%d\n",o);
    }
    printf("%lld\n%lld\n",ans1,ans2);
    return 0;
}
```




---


# 「PMOI-4」排列变换

## 题目描述

给定常数 $k$。对于一个长度为 $n$ 的**排列** $a$，定义

$$f(a)=\{\max_{1 \le i \le k} \{a_i\},\max_{2 \le i \le k+1} \{a_i\},\cdots,\max_{n-k+1 \le i \le n} \{a_i\}\}$$

对于一个长度为 $n$ 的**序列** $a$，定义其权值 $w(a)$ 为 $a$ 中不同的数的个数。

现在，$\text{ducati}$ 想知道，对于所有长度为 $n$ 的排列 $p$，它们的 $w(f(p))$ 之和。

## 说明/提示

【样例解释】

- $p=\{1,2,3\}$，$f(p)=\{2,3\}$，则 $w(f(p))=2$。
- $p=\{1,3,2\}$，$f(p)=\{3,3\}$，则 $w(f(p))=1$。
- $p=\{2,1,3\}$，$f(p)=\{2,3\}$，则 $w(f(p))=2$。
- $p=\{2,3,1\}$，$f(p)=\{3,3\}$，则 $w(f(p))=1$。
- $p=\{3,1,2\}$，$f(p)=\{3,2\}$，则 $w(f(p))=2$。
- $p=\{3,2,1\}$，$f(p)=\{3,2\}$，则 $w(f(p))=2$。

答案为 $2+1+2+1+2+2=10$。 

【数据范围】

**本题采用捆绑测试**。

- Subtask 1（10pts）：$n \le 8$。
- Subtask 2（10pts）：$n \le 11$。
- Subtask 3（30pts）：$n \le 100$。
- Subtask 4（20pts）：$n \le 400$。
- Subtask 5（20pts）：$n \le 4000$。
- Subtask 6（10pts）：无特殊限制。

对于 $100\%$ 的数据满足，$1 \le k \le n \le  5 \times 10^5$。

【提示】

1. $p$ 是一个长度为 $n$ 的排列，当且仅当每个在 $[1,n]$ 中的整数都在 $p$ 中**恰好出现了一次**。
例如，$\{1,5,3,2,4\}$ 与 $\{4,2,1,3\}$ 分别是长度为 $5,4$ 的排列，而 $\{1,2,2\}$ 不是长度为 $3$ 的排列，$\{5,4,3,2,1\}$ 不是长度为 $6$ 的排列，$\{1.5,3,1\}$ 不是长度为 $3$ 的排列。

2. 本题并不难。

## 样例 #1

### 输入

```
3 2```

### 输出

```
10```

## 样例 #2

### 输入

```
500000 200000```

### 输出

```
840847204```

# 题解

## 作者：infinities (赞：16)

upd:修改最后一个式子的一个小错误

挖掘一下题意。

就是给定一个长度为 $k$ 的滑动窗口在长度为 $n$ 的排列上滑，问滑动窗口中的 $\max$ 变化了多少次。（滑动窗口不懂的可以理解成序列中连续 $k$ 个数。这里之所以不写不同数的个数而是变化次数，是因为题目求的是排列，而排列满足所有数各不相同，所以变化次数加 $1$ 就等于不同 $\max$ 个数）

可以发现，因为枚举全排列中的每一个 $i$ 都可以变成 $n-i+1$（$n!$ 个排列仍然完整），所以我们计算答案，求 $\min$ 和 $\max$ 其实是等价的。（当 $\max$ 做也可以，不过我觉得当 $\min$ 做比较好推式子，以下都当成 $\min$ 做）

接着考虑在什么情况下，滑动窗口在排列上从左往右滑动 $1$ 长度的时候，答案会增加 $1$（即 $\min$ 值发生变化）。

因为向右滑动 $1$ 长度的情况下，只有窗口最左的数会出窗口，而右边紧邻的那个数会进入窗口，所以我们实际上只需要对于每个窗口看最左边的数是否是窗口滑动之前的最小值，以及新加入的最右边的数是否是窗口滑动之后新的最小值即可。

对于最左边的数是窗口滑动之前是窗口最小值，进行一波推式子之后，可以发现它对答案的贡献有：

$$\sum_{i=1}^n C(n-i,k-1)(n-k)!(k-1)!(n-k)$$ 

其中从左往右，求和符合是枚举这个最小值的大小，组合数是令窗口中剩余的 $k-1$ 个数大于最小值的值的个数，两个阶乘分别是窗口外面的数任意排列和窗口内部除去最小值外任意排列，最后一个 $n-k$ 是计算排列中窗口可以在的位置有 $n-k$ 个。（其实总窗口有 $n-k+1$ 个，就是最左边那个无法移动了）

然后对于新进入的最右边的数是新的窗口最小值，式子是可以类比的：

$$\sum_{i=1}^nC(n-i,k)(n-k-1)!k!(n-k)$$

含义是类似的，只不过计算的是新加进去最右边那个数。

当然，只将这两部分加起来还有一些问题，实际上我们还会算重一部分，既满足最左边是窗口最小值，又满足新加入的是窗口的新最小值（且小于最左边的，或者你可以强制令最右边的是最小的，最左边的小于最右边的，实际上两种方法的式子是一样的），这部分答案需要减掉：

$$\sum_{i=1}^nC(n-i,k-1)(n-k-1)!(k-1)!(n-k)(i-1)$$

前面同样是类似的，最后的 $i-1$ 是最右边小于最左边的个数，或者你也可以理解成是最左边小于最右边的个数。

注意最后还需要加上每个排列都缺少的 $1$ 答案，也就是总答案加上 $n!$，因为我们最开始忽略了这部分。

于是简单线性预处理一下组合数，套一下式子就可以了。

核心代码：
```cpp
    for(int i = 1; i <= n - k; i++){//枚举只到n-k是因为i再大答案就都是0了
		ans += C(n - i, k - 1) * (n - k) % mod * A[n - k] % mod * A[k - 1] % mod;//A是阶乘
		ans %= mod;
		ans += A[n - k - 1] * C(n - i, k) % mod * (n - k) % mod * A[k] % mod;
		ans %= mod;
		ans -= C(n - i, k - 1) * (n - k) % mod * A[n - k - 1] % mod * (i - 1) % mod * A[k - 1] % mod;
		ans %= mod; 
	}
    cout << ((A[n] + ans + mod) % mod + mod) % mod;
    ```

---

## 作者：yxzy4615 (赞：10)

### 前言
楼上已经讲的很清楚了，但看着这么长的柿子，就想压一下。
### 题面
给定常数 $k$。对于一个长度为 $n$ 的排列 $a$，定义

$$f(a)=\{\max_{1 \le i \le k} \{a_i\},\max_{2 \le i \le k+1} \{a_i\},\cdots,\max_{n-k+1 \le i \le n} \{a_i\}\}$$


对于一个长度为 $n$ 的序列 $a$，定义其权值 $w(a)$ 为 $a$ 中不同的数的个数。

求对于所有长度为 $n$ 的排列 $p$，它们的 $w(f(p))$ 之和。

### $\text{Solution}$
柿子楼上给出了，那我们来化简：

+ #### 第一部分
$ s_1=\sum\limits_{i=1}^nC_{n-i}^{k-1} \times(n-k)!\ \times (k-1)! \ \times (n-k) $

$\ \ \ \ \ =\sum\limits_{i=1}^n \frac{(n-i)!}{(k-1)!(n-k-i+1)!} \times(n-k)!\ \times (k-1)! \ \times (n-k) $

$\ \ \ \ \ =\sum\limits_{i=1}^n \frac{(n-i)!}{(n-k-i+1)!} \times(n-k)! \ \times (n-k)$

$\ \ \ \ \  =\sum\limits_{i=1}^n \frac{(n-k)}{(n-k-i+1)!} \times(n-k)! \ \times (n-i)!$

+ #### 第二部分

$ s_2=\sum\limits_{i=1}^nC_{n-i}^k \times(n-k-1)!\ \times k! \ \times (n-k) $

$ \ \ \ \ \ =\sum\limits_{i=1}^n \frac{(n-i)!}{k!(n-k-i)!} \times(n-k)!\ \times k! $

$ \ \ \ \ \ =\sum\limits_{i=1}^n \frac{1}{(n-k-i)!} \times(n-k)!\ \times (n-i)! $


+ #### 第三部分

$ s_3=\sum\limits_{i=1}^nC_{n-i}^{k-1} \times(n-k-1)!\ \times (k-1)! \ \times (n-k) \times (i-1)$

$ \ \ \ \ \ =\sum\limits_{i=1}^n\frac{(n-i)!}{(k-1)!(n-k-i+1)!} \times(n-k)!\ \times (k-1)! \times (i-1)$

$ \ \ \ \ \ =\sum\limits_{i=1}^n\frac{(i-1)}{(n-k-i+1)!} \times(n-k)! \times (n-i)!$

到这你会发现 $s_1-s_3=s_2$。所以 $ans=2 \times s_2 + n!$

但是，我们还不满足。

$s_2=\sum\limits_{i=1}^n \frac{1}{(n-k-i)!} \times(n-k)!\ \times (n-i)! $

$\ \ \ \ \ =(n-k)!\ \sum\limits_{i=1}^n \frac{(n-i)!}{(n-k-i)!}  $

$\ \ \ \ \ =(n-k)!\times k!\ \sum\limits_{i=1}^n \frac{(n-i)!}{(n-k-i)!k!}  $

$\ \ \ \ \ =(n-k)!k!\ \sum\limits_{i=1}^n C_{n-i}^k $

$\ \ \ \ \ =(n-k)!k!\times (C_{n+1}^{k+1}-C_n^k) $

$\ \ \ \ \ =\frac{(n+1)!}{k+1}-n! $

将 $s_2$ 带回 $ans=2 \times s_2+n!$ 得：
$$ans=\frac{2(n+1)!}{k+1}-n! $$

直接求 $(k+1)$ 的逆元和 $(n+1)!$ 及 $n!$ 即可。

### $\text{Code}$
这里仅贴关键代码， $\text{qpow}$ 是快速幂。
```cpp
for(int i=1;i<=n+1;i++){
	ans=(ans*i)%p;
	if(i==n) t=ans;
}
printf("%lld",(2*ans*qpow(k+1,p-2)%p-t+p)%p);
```


---

## 作者：Qerrj (赞：8)

# 前言

提供一种不需要容斥，直接计数的方法。

# 思路

考虑每个数的贡献，然后就枚举这个数是 $i$ ，接着我们枚举这个数出现在 $f(a)$ 中的 $j$ 位置，因为要去重，所以我们保证 $i$ 在 $f(a)$ 中出现的第一次为 $j$ 即可。 

接着就是计数，我们发现 $i$ 要出现在 $j$ 位置，那么对应的原排列中，$i$ 应该在 $[j, j + k - 1]$ 中，并且 $i$ 是最大的，所以就有 $\dbinom {i - 1} {k - 1} (k - 1)!$ 然后我们考虑 $i$ 在 $[j,j + k - 1]$ 的哪个位置，如果是在 $j + k - 1$，那么其他位置随便排即可，这一定是 $i$ 在 $f(a)$ 中第一次出现，如果实在 $[j, j + k -2]$， 原排列中 $j - 1$ 位置一定要是大于 $i$ 的数，所以我们随便选一个，即为 $\dbinom {n - k} 1(n - k - 1)!$，因为有 $k - 1$ 个可以放 $i$ 的位置，所以还要乘以 $k - 1$，注意当 $j = 1$ 时，就不用考虑前面的，所以 其他的数随便排。

那么总的式子就是：
$$
\begin{aligned}
&= \sum_{i = 1}^n (\sum_{j = 2}^{n - k + 1} \dbinom {i - 1} {k - 1} (k - 1)! ((n - k)! + (n - i) (n - k - 1)! (k - 1))) + \dbinom {i - 1} {k - 1} k! (n - k)!
\\ 
&= \sum_{i = 1}^n (n - k) \dbinom {i - 1} {k - 1} (k - 1)! ((n - k)! + (n - i) (n - k - 1)! (k - 1))) + \dbinom {i - 1} {k - 1} k! (n - k)!
\end{aligned}
\\
$$
其实到这里已经可以通过这道题了，但是我们还可以继续化简，接下来讲两个组合恒等式。

$$\sum_{i = 0}^n \dbinom i k = \dbinom {n + 1} {k + 1}$$

$$\sum_{i = 0}^n \dbinom i k (i + 1) = (k + 1) \dbinom {n + 2} {k + 2}$$

有这两个恒等式，上面的式子就可以消掉 $\sum$ 了，然后就是合并同类项，读者可以自行化简，就可以得到如下式子。

$$\frac{n!}{k}((k - 1)\frac{n - k}{k + 1} + n)$$

跑了 20ms，最优解第一页。
## 代码

```
#include<bits/stdc++.h>
using namespace std;
const int mod = 998244353;
int mul(int x, int y) { return 1ll * x * y % mod; }
int add(int x, int y) { return x + y >= mod ? x + y - mod : x + y; }
int sub(int x, int y) { return x - y < 0 ? x - y + mod : x - y; }
int qpow(int a, int b) {
	int res = 1;
	for( ; b; b >>= 1, a = mul(a, a)) if(b & 1) res = mul(res, a);
	return res;
}
int n, k, ans = 1;
int main() {
	scanf("%d%d", &n, &k);
	for(int i = 1; i <= n; i++) ans = mul(ans, i);
	ans = mul(ans, mul(qpow(k, mod - 2), add(mul(k - 1, mul(n - k, qpow(k + 1, mod - 2))), n)));
	printf("%d", ans); 
	return 0;
}
```

---

## 作者：longlinyu7 (赞：5)

# 题目分析
对于一个长度为 $n$ 的排列 $a$，可以知道这个排列的最大值是一定可以做出贡献的。而这样的排列有 $n!$ 种，则仅最大值的贡献就有 $n!$ 种。

设 $f_n$ 表示长度为 $n$ 的所有排列 $a$ 产生的权值和。

考虑枚举最大值 $i$ 的位置，则这个最大值可以将整个序列分成两段，因为中间有一个最大值，所以左右两段互不干扰，可以分别讨论左右两段的贡献。

设最大值的位置为 $i$，首先，除了最大值 $n$ 之外，还剩下 $n-1$ 个数，需要选取 $i-1$ 个数字到左区间，方案数为 $C_{n-1}^{i-1}$。

根据乘法原理，当左区间确定时，右区间的每一种不同排列方式都会产生一次贡献，而右区间有 $(n-i)!$ 种不同的排列方式，仅左区间的权值和为 $f_{i-1}$，则左区间的贡献为 $(n-i)!f_{i-1}$，同理，右区间的贡献为 $(i-1)!f_{n-i}$。

则可以列出下面的式子：
$$ f_n = n!+ \sum_{i=1}^{n} C_{n-1}^{i-1}((n-i)! f_{i-1}+(i-1)!f_{n-i})$$
把 $C_{n-1}^{i-1}$ 拆开成 $\frac{(n-1)!}{(n-i)!(i-1)!}$，再提到括号里面，得：
$$f_n = n!+ \sum_{i=1}^{n} \frac{(n-1)!}{(i-1)!} f_{i-1}+\sum_{i=1}^{n}\frac{(n-1)!}{(n-i)!} f_{n-i} $$

对于 $\sum_{i=1}^{n}\frac{(n-1)!}{(n-i)!} f_{n-i}$ 这一项，可以当作是倒序枚举 $i$，则它与 $ \sum_{i=1}^{n} \frac{(n-1)!}{(i-1)!} f_{i-1}$ 仅仅在枚举顺序上有区别，可以当作同类项进行合并。

最终结果：
$$f_n = n!+ 2\sum_{i=1}^{n} \frac{(n-1)!}{(i-1)!} f_{i-1} $$

当然，题目中还有个要求是长度为 $k$ 的区间，易知， $i<k$ 时，$f_i=0$。

考虑可以前缀和优化，设 $S_n=\sum_{i=1}^{n} \frac{(n-1)!}{(i-1)!} f_{i-1} $。

则:
$$f_i=2S_i+i!$$
观察式子，可以推出 $S_i$ 的递推式为：
$$S_i=S_{i-1}(i-1)+f_{i-1}$$

则 $O(n)$ 递推即可。

# 代码
```
#include<bits/stdc++.h>
using namespace std;
#define ll  long long  
const int N=1e6+5;
const int MOD=998244353;
ll s[N],g[N],fac[N];
ll n,k;
int main(){
    cin>>n>>k;
    fac[0]=1;
    for(int i=1;i<=n;i++){
        fac[i]=fac[i-1]*i%MOD;
        s[i]=(((i-1)%MOD*s[i-1]%MOD)%MOD+g[i-1]%MOD)%MOD;  // 注意勤取模
        if(i>=k)
        g[i]=((2*s[i]%MOD)%MOD+fac[i])%MOD;
    }
    cout<<g[n];
    return 0;
}

```

---

## 作者：TianTian2008 (赞：5)

需要组合计数和一点容斥思想。

显然，$f(a)$ 出现新的元素时，即 $\max\limits_{l\leqslant t\leqslant l+k-1}(a_t)\neq\max\limits_{l+1\leqslant t\leqslant l+k}(a_t)$，当且仅当 $\max\limits_{l\leqslant t\leqslant l+k-1}(a_t)=a_l$（原本的最大值被移出区间）或 $\max\limits_{l+1\leqslant t\leqslant l+k}(a_t)=a_{l+k}$（新出现的元素是最大值），对两种情况分别计数，再去掉交集。

 $\max\limits_{l\leqslant t\leqslant l+k-1}(a_t)=a_l$ 会产生 $S_1=(n-k)(k-1)!(n-k)!\sum_{m=1}^n\tbinom{m-1}{k-1}$ 个不同元素。$n-k$ 表示长度为 $k$ 的区间有 $n-k$ 位置可以放置（区间 $[n-k+1,n]$ 无法再向后移动，故不计入其中），$(k-1)!$ 表示区间内元素排列的方案数（需要保证最大值排在最左端，故只有 $k-1$ 个元素进行排列），$(n-k)!$ 表示区间之外的元素进行排列的方案数，$m$ 是枚举的最大值，$\tbinom{m-1}{k-1}$ 表示区间内最大值之外的元素的选择方案数（要保证 $m$ 是最大值，其余元素只能在 $[1,m)$ 内取值）。

 $\max\limits_{l+1\leqslant t\leqslant l+k}(a_t)=a_{l+k}$ 会产生 $S_2=(n-k)k!(n-k-1)!\sum_{m=1}^n\tbinom{m-1}{k}$ 个不同元素。$n-k$ 表示长度为 $k$ 的区间有 $n-k$ 位置可以放置，$k!$ 表示区间内元素排列的方案数（此时最大值在区间之外，故有 $k$ 个元素进行排列），$(n-k-1)!$ 表示区间之外的元素进行排列的方案数（需要保证最大值是区间右端点的下一个元素，故只有 $n-k-1$ 个元素进行排列），$m$ 是枚举的最大值，$\tbinom{m-1}{k}$ 表示区间内最大值之外的元素的选择方案数（此时最大值在区间之外，故区间内有 $k$ 个元素需要进行选择）。

用容斥原理去掉交集。考虑$\max\limits_{l\leqslant t\leqslant l+k-1}(a_t)=a_l$ 和 $\max\limits_{l+1\leqslant t\leqslant l+k}(a_t)=a_{l+k}$ 同时成立时，有 $S_3=(n-k)(k-1)!(n-k-1)!\sum_{m=1}^n\tbinom{m-1}{k-1}(n-m)$ 个元素被重复计数。$n-k$ 表示长度为 $k$ 的区间有 $n-k$ 位置可以放置，$(k-1)!$ 表示区间内元素排列的方案数，$(n-k-1)!$ 表示区间之外的元素进行排列的方案数，$m$ 是枚举的一个最大值，$\tbinom{m-1}{k-1}$ 表示区间内最大值之外的元素的选择方案数，$n-m$ 表示另一个最大值的取值方案数（需要限制一个最大值小于另一个才能使计算的方案数不重不漏）。

最终答案 $Ans=S_1+S_2-S_3+n!$（每种排列的 $f(a)$ 的首个元素都未被计入，故需要加上 $n!$）。

略微化简 $S_1,S_2,S_3,Ans$。

$S_1=(n-k)(k-1)!(n-k)!\sum_{m=1}^n\tbinom{m-1}{k-1}$

$=(n-k)!\sum_{m=1}^n\frac{(m-1)!}{(m-k)!}(n-k)$

$S_2=(n-k)k!(n-k-1)!\sum_{m=1}^n\tbinom{m-1}{k}$

$=(n-k)!\sum_{m=1}^n\frac{(m-1)!}{(m-k)!}(m-k)$

$S_3=(n-k)(k-1)!(n-k-1)!\sum_{m=1}^n\tbinom{m-1}{k-1}(n-m)$

$=(n-k)!\sum_{m=1}^n\frac{(m-1)!}{(m-k)!}(n-m)$

$Ans=S_1+S_2-S_3+n!$

$=2(n-k)!k!\sum_{m=1}^n\tbinom{m-1}{k}+n!$

$=2(n-k)!k!\tbinom{n}{k+1}+n!$

$=\frac{2(n-k)n!}{(k+1)}+n!$

到此，得出了此题的思路。

```
#include <iostream>
#include <cstdio>
#define mod 998244353
using namespace std;
typedef long long ll;
ll n,k,fac;
ll ksm(ll x,ll y)
{
	ll res=1;
	while(y)
	{
		if(y&1) res=res*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return res;
}
ll inv(ll a)
{
	return ksm(a,mod-2);//998244353是质数，可以用费马小定理求逆元
}
int main()
{
	scanf("%lld%lld",&n,&k);
	fac=1;
	for(int i=1;i<=n;++i) fac=fac*i%mod;//预处理n!
	printf("%lld",(fac*(n-k)%mod*inv(k+1)%mod*2+fac)%mod);
	return 0;
}
```

---

## 作者：Ice_function (赞：3)

提供一个简单的做法。

#### 结论

$ans=\sum_{x=1}^{n}\binom{x-1}{k}\times k!\times (n-k-1)!\times 2 \times (n-k) + n!$

看着有点点复杂，其实原理很简单。

#### 性质

- 考虑序列 $f(a)$ ，所有相同的数一定都在一起。

因为一个当前区间的最大值 $x$，当 $k$ 加一后它不是最大值，只有一下两种情况。


1. 有更大的值进入区间。


显然，因为 $x$ 先进入区间，所以一定比新的数先出，所以 $x$ 不再是最大值。

2. 退出区间。

显然，不会再是最大值。

#### 式子

我们观察到，对于位置 $i$ 与上一个位置不同当且仅当区间 $[i-k,i]$ 的最大值在 $i-k$ 或者 $i$ 上。因为这样的话当 $k$ 减一最值一定改变。否则最值一定不变。

对于上述的 $i$ 都有 $k+1\le i$ 因为我们把每个 $f(a)$ 的非第一项拿出算，对于每个第一项，一定都不重，我们加上情况数的值即可，即 $n!$，剩下总共有 $(n-k)$ 个数，乘上每一个位置的贡献即可。

对于每一个位置的贡献的解释，$\binom{x-1}{k}$ 表示在比 $x$ 小的数中选 $k$ 个，剩下两个阶乘是确定选出来的数的排列。

时间复杂度是 $\mathcal O(n)$。

code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=5e5+10,mod=998244353;

int n,k;

int fac[N],inv[N];
int powmod(int x,int y)
{
	int ans=1,p=x;
	while (y)
	{
		if (y & 1) ans=1ll*ans*p%mod;
		p=1ll*p*p%mod;
		y>>=1;
	}
	return ans;
}
int C(int a,int b)
{
	if (a<b) return 0;
	return 1ll*fac[a]*inv[b]%mod*inv[a-b]%mod;
}

int main()
{
	fac[0]=inv[0]=1;
	for (int i=1;i<=N-10;i++) fac[i]=1ll*fac[i-1]*i%mod;
	inv[N-10]=powmod(fac[N-10],mod-2);
	for (int i=N-11;i>=1;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;
	
	scanf("%d %d",&n,&k);
	
	int ans=0;
	for (int x=1;x<=n;x++) ans=(1ll*ans+1ll*C(x-1,k)*fac[k]%mod*fac[n-k-1]%mod*2%mod)%mod;
	ans=1ll*ans*(n-k)%mod;
	ans=(1ll*ans+1ll*fac[n])%mod;
	
	printf("%d\n",ans);
	
	return 0;
}
```

---

## 作者：Jsxts_ (赞：3)

一开始的思路是对于每个数考虑贡献，后来发现不太好做，转而考虑窗口移动时能否出现新的最大值，发现要么是 $l$ 为 $[l,r+1]$ 的最大值，要么 $r+1$ 为 $[l,r+1]$ 的最大值。

第一类：$l$ 为 $[l,r+1]$ 的最大值

考虑枚举 $l$ 的值，之后 $[l+1,r+1]$ 中填比 $a_l$ 小的数，其他地方任意，并且共有 $n-k$ 个区间（最后的区间移动不了所以减 $1$），注意乘上全排列数。

$$ans=\sum_{i=1}^nC(i-1,k)\times k!\times(n-k-1)!\times(n-k)$$

第二类：$r+1$ 为 $[l,r+1]$ 的最大值

发现本质和上面相同，所以答案一样。

最后，我们发现每个排列会被少算一次（因为我们统计的是变化的次数，变化 $x-1$ 次就有 $x$ 个不同的），所以要加上 $n!$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int inf = 2e9;
int read() {
	int s = 0,f = 1;char ch = getchar();
	while (!isdigit(ch)) f = ch == '-' ? -1 : 1, ch = getchar();
	while (isdigit(ch)) s = s * 10 + ch - '0', ch = getchar();
	return s*f;
}
void write(int x) {
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) write(x / 10);
	putchar(x % 10 + 48);
}
int jc[500010],ivjc[500010];
const int mod = 998244353;
int C(int n,int m) {
	return n < m ? 0 : 1ll * jc[n] * ivjc[m] % mod * ivjc[n - m] % mod;
}
int qpow(int a,int b) {
	int res = 1;
	while (b) {
		if (b & 1) res = 1ll * res * a % mod;
		b >>= 1, a = 1ll * a * a % mod;
	}
	return res;
}
int main() {
	int n = read(),k = read();jc[0] = ivjc[0] = 1;
	for (int i = 1;i <= n;i ++ ) jc[i] = 1ll * jc[i - 1] * i % mod;
	ivjc[n] = qpow(jc[n],mod - 2);
	for (int i = n - 1;i;i -- ) ivjc[i] = 1ll * ivjc[i + 1] * (i + 1) % mod;
	int ans = 0;
	for (int i = 1;i <= n;i ++ ) {
		ans = (ans + 1ll * C(i - 1,k) * jc[k] % mod * jc[n - k - 1] % mod * (n - k) % mod) % mod;
	}
	printf("%lld\n",(ans * 2ll + jc[n]) % mod);
	return 0;
}
```


---

## 作者：gan1234 (赞：2)

对于一个排列 $p$，$f(p)$ 相当于求有多少个值，存在一个长度为 $k$ 的区间使得该值是最大值。

首先这个排列的最大值无论是什么排列一定能对 $f(p)$ 做出贡献，所以有 $n!$ 的贡献。且这个最大值会把排列分成两段，而这两段对 $f(p)$ 的贡献一定独立，互不影响。

设 $g_n$ 表示长度为 $n$ 的所有排列的 $w$ 值和，考虑枚举长度为 $n$ 的排列最大值位置 $i$。

将一个序列分成两段相当于左段从剩下的数选若干个，其余分给右端，有 $\binom{n-1}{i-1}$ 种分法。同时根据乘法原理，对于左侧段的贡献，右边每一种排列都需要看作是一种新的方案计算一次，总共计算 $(n-i)!$ 次，右侧段同理，因此我们有

$$g_n=n!+\sum^{n}_{i=1}\binom{n-1}{i-1}((n-i)!g_{i-1}+(i-1)!g_{n-i})$$

$$=n!+\sum^{n-1}_{i=0}\binom{n-1}{i}(n-i-1)!g_i+\sum^{n-1}_{i=0}\binom{n-1}{i}i!g_{n-i}$$

$$=n!+\sum^{n-1}_{i=0}\frac{(n-1)!}{i!}g_i+\sum^{n-1}_{i=0}\frac{(n-1)!}{(n-i)!}g_{n-i}$$

$$=n!+2\sum^{n-1}_{i=0}\frac{(n-1)!}{i!}g_i$$

其中当 $i<k$ 时，$g(i)=0$。

考虑前缀和优化。

令 $S_i=\sum^{i-1}_{j=0}\frac{(i-1)!}{j!}g_j$，我们有：

$$S_i=(i-1)S_{i-1}+g_{i-1}$$

$$g_i=2S_i+i!$$

$O(n)$ 递推即可。

---

## 作者：快斗游鹿 (赞：2)

## 思路

直接统计不太好做，考虑什么情况下权值会增加。对于一个长度为 $k$ 的区间，在往右挪一格时，如果权值增加了，有两种可能情况：

第一，当前区间最左端的数是区间内的最小值，移动后区间最小值一定会改变。我们可以枚举这个最小数 $i$，则它能产生贡献的方案数为 $C(n-i,k-1)(k-1)!(n-k)!(n-k)$，$C(n-i,k-1)$ 是除去 $i$ 后，这个区间内其他数的可能取值方案数，$k-1$ 是区间内除去 $i$ 后，其他数的排列方案数，$(n-k)!$ 是除去这个长度为 $k$ 的区间后，其他数的排列方案数，$n-k$ 是这个区间可能的位置数。实际上可以取到 $n-k+1$ 个区间，但要考虑挪动时，至少需要两个区间，所以应当减一。

第二，当前区间右端的数成为了新的最小值。类似的，它能产生的贡献为 $C(n-i,k)k!(n-k-1)!(n-k)$，$C(n-i,k)$ 是原区间内数的可能取值方案数，$k$ 是区间内的数的排列方案数，$(n-k-1)!$ 是除去这个长度为 $k$ 的区间和右端的数后，其他数的排列方案数，$n-k$ 是这个区间可能的位置数。

但这样加有问题，因为可能会出现第一个和第二个同时满足的情况，所以要减掉这部分答案，这时候要考虑的就是一个长度为 $k$ 的区间外加其右端的点。这部分数量为 $C(n-i,k-1)(k-1)!(n-k-1)!(i-1)(n-k)$。$i-1$ 表示钦定最左端的数更大时，右端的数的取值数量。

最后还要加上 $n!$，因为我们只考虑了区间出现挪动的情况，没有加上每个排列本来就该有的 $1$ 的贡献。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int mod=998244353;
const int N=5e5+5;
int n,k,ans,fac[N],inv[N];
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
int C(int n,int m){
	if(!m)return 1;
	if(n<m)return 0;
	return fac[n]%mod*inv[m]%mod*inv[n-m]%mod;
}
signed main(){
	n=read();k=read();
	inv[0]=1;inv[1]=1;fac[1]=1;fac[0]=1;
	for(int i=2;i<=n;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;
	for(int i=2;i<=n;i++)inv[i]=inv[i]*inv[i-1]%mod;
	for(int i=2;i<=n;i++)fac[i]=fac[i-1]*i%mod;	
	for(int i=1;i<=n-k;i++){
		ans=ans+(C(n-i,k-1)%mod*(n-k)%mod*fac[n-k]%mod*fac[k-1]%mod)%mod;ans%=mod;
		ans=ans+(C(n-i,k)%mod*(n-k)%mod*fac[n-k-1]%mod*fac[k]%mod)%mod;ans%=mod;
		ans=ans-(C(n-i,k-1)%mod*(n-k)%mod*(i-1)%mod*fac[n-k-1]%mod*fac[k-1]%mod)%mod;
	}
	cout<<(ans%mod+fac[n]%mod+mod)%mod;
	return 0;
}

```


---

## 作者：beauty_son_whm (赞：2)

设 $f_n$ 表示长度为 $n$ 的排列的答案。我们考虑如何递推。可以枚举 $n$ 的位置在哪算贡献。

$$f_n=\sum_{i=1}^n((n-1)!+f_{i-1}\cdot \binom{n-1}{i-1}\cdot(n-i)!+f_{n-i}\cdot \binom{n-1}{i-1}\cdot (i-1)!)$$

含义就是，我们枚举 $n$ 的位置在哪，那么如果一个区间扫到 $n$。这个 $n$ 的贡献可以直接加入答案，因为 $n$ 是独一无二的在这个位置，他贡献了 $(n-1)!$ 。剩下的位置被我们分割成了两个子区间，并且满足互不干扰。因为中间的 $n$ 将他们隔开了。每个区间的贡献首先得乘一个组合数，然后它的另外一个区间随便排。

简单化简一下：

$$f_n=n!+2\cdot \sum_{i=0}^{n-1}f_i\cdot \binom{n-1}{i}\cdot(n-i-1)!$$

我们把组合数拆开来继续化简。

$$f_n=n!+2\cdot\sum_{i=0}^{n-1}f_i\cdot\frac{(n-1)!}{i!(n-1-i)!}\cdot(n-1-i)!$$

$$f_n=n!+2\cdot (n-1)!\sum_{i=0}^{n-1}\frac{f_i}{i!}$$

然后就能随便前缀和优化一下做啦。边界条件 $f_k=k!$ 。答案 $f_n$ 。

---

## 作者：starrylasky (赞：2)

[博客食用更佳](https://www.cnblogs.com/hhhsky001/articles/16807647.html)

发现直接算某个序列的贡献好像很难。

所以我们考虑去算每种能产生贡献的贡献次数。

什么时候会产生贡献呢？

显然要么是加入的是最大值，要么弹出的是最大值

考虑弹出是 $\max$。

产生的方案数：$(n-k)(n-k)!(k-1)!\sum\limits_{m=k}^n \binom {m-1}{k-1}$。

$n-k$ 不 $+1$ 的原因是因为他向后移动了。下面同理。

考虑加入是 $\max$。

产生的方案数：$(n-k)(n-k)!(k-1)!\sum\limits_{m=k}^n\binom{m-1}{k-1}$。

考虑弹出的和加入的都是 $ \max$。

弹出的大于加入的产生的方案数：$(n-k)(n-k-1)!(k-1)!\sum\limits_{m=k+1}^n\binom{m-1}{k}$。

加入的大于弹出的产生的方案数：$(n-k)(n-k-1)!(k-1)!\sum\limits_{m=k+1}^n \binom {m-1} {k}$。

答案稍微容斥一下就好了。

这是您会发现您连样例都过不了。

原因是每种情况开始都会产生 $1$ 个贡献。

将之前加上这个及为答案。

```cpp
#include<bits/stdc++.h>
#define fep(i,l,r) for(int i=l;i<=r;++i)
#define feb(i,r,l) for(int i=r;i>=l;--i)
#define For(i,u) for(int i=head[u];i;i=e[i].nxt)
#define pr pair<int,int>
#define mpr make_pair
#define LL long long
//#define int long long
using namespace std;

const int N = 5e5+5,mod = 998244353;
int n,k,inv[N],fac[N],ifac[N];

inline int read()
{
	int s=0,w=1; char ch=getchar();
	while(!(ch<='9'&&ch>='0')) {if(ch=='-') w=-1; ch=getchar();}
	while(  ch<='9'&&ch>='0')  {s=(s<<1)+(s<<3)+ch-'0'; ch=getchar();}
	return s*w;
}
inline int Mod(int x) {return x>=mod?x-mod:x;}

inline void init()
{
	inv[1]=fac[0]=ifac[0]=1;
	fep(i,1,n)
	{
		if(i^1) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
		fac[i]=1ll*fac[i-1]*i%mod;
		ifac[i]=1ll*ifac[i-1]*inv[i]%mod;
	}
}

inline int C(int x,int y)
{
	return 1ll*fac[x]*ifac[y]%mod*ifac[x-y]%mod;
}

inline int query(int x)
{
	int ans=0;
	fep(i,x+1,n)
	{
		ans=Mod(ans+C(i-1,x));
	}
	return ans;
}

signed main()
{
	n=read(),k=read();
	init();
	int ans=Mod(2ll*(n-k)*fac[n-k]%mod*fac[k-1]%mod*query(k-1)%mod-2ll*(n-k)*fac[n-k-1]%mod*fac[k-1]%mod*query(k)%mod);
	ans=Mod(ans+fac[n]); ans=Mod(ans+mod);
	printf("%d",ans);
	return 0;
}

```

---

## 作者：ycy1124 (赞：2)

### 题意
对于所有长度为 $n$ 的排列，他的价值为他所有长度为 $k$ 的连续子段中最大的那个数不同的个数，现在要求所有排列的价值和。
### 思路
发现这个东西有点像滑动窗口，每次窗口里最大值变化就会带来价值。我们考虑什么时候会带来价值，第一种是窗口左端的最大值被弹出，第二种是窗口右端新进了一个最大值。其实这两种的贡献是相等的，因为我们可以将第二种看作从右向左扫的滑动窗口，而每个排列都一定会有其对称的排列，于是这两个贡献相等。

考虑计算其中一个，首先所有的数要小于左端的，那么我们可以枚举左端的数的大小，设这个数为 $i$，那么他的贡献是 $C_{i-1}^{k-1}(n-k)(k-1)!(n-k)!$。由于左端是最小的，所以窗口内的数只能取 $1\sim i-1$，我们从中选 $k-1$ 个出来。然后只有 $n-k$ 个位置能使得左端点被弹出。并且选出来的数交换位置是不同的方案，所以要乘上 $(k-1)!$。最后乘上剩下的数的排列方案。

但是这两种方案会有重复，即左端点被弹出后右端点进来是最大的，这个贡献被算了两遍。去掉这个多余的贡献也很简单，我们先假设左端点是小于右端点的，对于每个左端点的值 $i$，贡献重复的个数为 $C_{i-1}^{k-1}(n-i)(n-k)(k-1)!(n-k-1)!$。首先一样是窗口内其他数的可能，然后是右端点可能的数和区间可能的位置数，接下来是计算排列窗口内的数的方案，最后乘上剩余数的方案就是贡献。至于右端点小于左端点的，我们依旧可以换个方向滑动窗口，这两个的贡献还是一样的。

最后由于一开始滑动窗口的初始区间的贡献没有计算，于是需要加上一个 $n!$。
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define md 998244353
using namespace std;
int n,d[500005],ans,sum[500005],inv[500005],k,js;
inline int power(int w){//快速幂求逆元
    int qwq=md-2,base=w,Sum=1;
    while(qwq){
        (qwq&1)?Sum*=base,Sum%=md:qwq;
        qwq>>=1;
        base*=base;
        base%=md;
    }
    return Sum;
}
inline void getsum(int n){//预处理阶乘
	sum[0]=inv[0]=1;
    for(int i=1;i<=n;i++){
        sum[i]=sum[i-1]*i%md;
    }
}
inline void getinv(int n){//预处理逆元
	for(int i=1;i<=n;i++){
		inv[i]=power(sum[i]);
	}
}
inline int C(int n,int m){
	if(n<m){
		return 0;
	}
	return sum[n]*inv[n-m]%md*inv[m]%md;
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>k;
	getsum(n);
	getinv(n);
	for(int i=1;i<=n;i++){//计算贡献，由于后面有一些常量，只需要累加含有变量i的数值后面再乘上即可
		js+=C(i-1,k-1);
		js%=md;
	}
	ans+=(n-k)*sum[n-k]%md*sum[k-1]%md*js%md*2%md;//计算贡献
	ans%=md;
	ans+=sum[n];//加上初始区间的贡献
	ans%=md;
	js=0;
	for(int i=1;i<=n;i++){//计算重复贡献
		js+=C(i-1,k-1)*(n-i)%md;
	}
	ans-=2*js%md*(n-k)%md*sum[k-1]%md*sum[n-k-1]%md;//减去
	ans=(ans+md)%md;//小心负数
	cout<<ans;
	return 0;
}
[AC 记录](https://www.luogu.com.cn/record/206631203)。
```

---

## 作者：CrTsIr400 (赞：1)

感觉此题别的题解都有点麻烦了。

首先这题不需要容斥（大部分题解的做法是算三个数加起来再化简），只需要想好你算的是什么就行了。

考虑两种情况：

1. 当 $x$ 滑出窗口之后，这个滑动窗口的答案**一定更差**。
2. 当 $x$ 滑进窗口之后，这个滑动窗口的答案**一定更优**。

根据定义，发现这两种情况是等价的。通过把窗口左移，我们可以把第二种情况转化为第一种情况。

设这样的方案数为 $S$。想必大家都会根据最后一位为 $i$ 的情况推式子：

$$S=(n-k-1)!(n-k)k!\sum_{i=1}^n\dbinom{i-1}{k}=(n-k)!k!\dbinom{n}{k+1}$$

它的意义，这道题目很多题解已经解释过了。这里不细讲。

现在来证明 $2S+n!$ 就是答案。

分类讨论一下，把 $x$ 滑出窗口时候，

1. 这个窗口的答案会更优，这是第二种情况，此时是 $(x+k)$ 号节点对答案做贡献。
2. 这个窗口的答案会更劣，这是第一种情况，此时是 $x$ 号节点对答案做贡献。

所以，无论每个节点的移动操作都会贡献答案两次（这两个贡献是相等的），此时 $2S+n!$ 就是答案。

```cpp
const I N=5e5+10,mod=998244353;
struct mo{I x;mo(I a=0){x=a%mod;}
	mo operator +(const mo&a)const{return mo(x+a.x);}
	mo operator *(const mo&a)const{return mo(1ll*x*a.x%mod);}
}iv[N],fac[N];
mo C(I n,I m){if(n<m)return 0;
	return fac[n]*iv[m]*iv[n-m];}
I main(){fac[0]=1;
	fo(i,1,N-1)fac[i]=fac[i-1]*mo(i);
	iv[1]=1;
	fo(i,2,N-1)iv[i]=iv[mod%i]*mo(mod-mod/i);
	iv[0]=1;fo(i,2,N-1)iv[i]=iv[i-1]*iv[i];
	I n,k;in(n,k);
	mo ans=mo(2)*fac[n-k]*fac[k]*C(n,k+1)+fac[n];
	printf("%d\n",ans.x);
	return 0;
}

```

---

## 作者：CatFromMars (赞：0)

萌萌计数题，感觉不太难的样子呢（小声

很显然是把贡献拆到每个数上，下面计数。我们不难发现这个形如滑动窗口的数列 $f$ 里面，每个数出现的位置一定是一个区间，所以我们就按照区间的左端点来计数。

对于数 $x$，手玩一下可以得到下面三种统计类型：
- 出现在 $[1, k]$ 中。要求里面出现一个 $x$，剩下 $(k - 1)$ 个数中全是 $1\sim (x - 1)$ 里的，剩下的数字随便排。方案数 $kA_{x - 1}^{k - 1}(n - k)!$。

- 作为“窗口中最后一个出现的数，替换之前出现的最大值”，那么这个窗口前 $(k - 1)$ 个数都要是 $1\sim (x - 1)$ 以内的数，窗口外的数字随便排。长度为 $k$ 的窗口一共有 $(n - k + 1)$ 个，但是由于这里面不能和上面重复要扣掉最开始的窗口，实际上是 $(n - k)$ 个。方案数 $(n - k)A_{x - 1}^{k - 1}(n - k)!$。
  
- 作为“上一个窗口内出现过，但是这一次替换掉了原最大值”。那么上一个窗口最后一个数就要比 $x$ 大，有 $(n - x)$ 种。窗口内还是 $kA_{x - 1}^{k - 1}$，除此之外有 $(n - k - 1)!$ 种排列方法。这样的区间段一共有 $(n - k)$ 个。

因此对于 $x$，实际上贡献就是 $kA_{x - 1}^{k - 1}(n - k)! + (n - k)!A_{x - 1}^{k - 1}(n - k) + (n - k)(n - k-1)!A_{x - 1}^{k - 1}(k - 1)(n - x)$。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 5e5;
const ll Mod = 998244353;
ll qpow(ll n, ll m) {
	ll res = 1;
	while(m) {
		if(m & 1) res = res * n % Mod;
		n = n * n % Mod;
		m >>= 1;
	}
	return res;
}
ll fac[N + 10], invf[N + 10];
void init() {
	fac[0] = 1;
	for(int i = 1; i <= N; i++)
		fac[i] = fac[i - 1] * i % Mod;
	invf[N] = qpow(fac[N], Mod - 2);
	for(int i = N - 1; i >= 0; i--)
		invf[i] = invf[i + 1] * (i + 1) % Mod;
}

ll A(int n, int m) {
	if(n < m) return 0;
	return fac[n] * invf[n - m] % Mod;
}
int main() {
	init();
	int n, k; cin >> n >> k;
	if(k == n) {
		cout << fac[n] << endl;
		return 0;
	}
	ll ans = 0;
	for(int x = 1; x <= n; x++) {
		ans = (ans + k * A(x - 1, k - 1) % Mod * fac[n - k] % Mod) % Mod;
		ans = (ans + fac[n - k] * A(x - 1, k - 1) % Mod * (n - k) % Mod) % Mod;
		ans = (ans + (n - k) * fac[n - k - 1] % Mod * A(x - 1, k - 1) % Mod * (k - 1) % Mod * (n - x) % Mod) % Mod;
	}
	cout << ans << endl;
}
```

---

## 作者：aeiouaoeiu (赞：0)

看到滑动窗口，首先从单调队列来观察，因为是排列，每个数在单调队列里存在的时间都是一个区间。更进一步地，$f(a)$ 一定形如 $\{x_1,x_1,\ldots,x_1,x_2,x_2,\ldots,x_2,\cdots,x_m,x_m,\ldots,x_m\}$，其中 $x_i$ 互不相同。

这引导我们讨论其中一个 $x_i$ 的贡献。现在我们需要求出对于一个数 $x$，有多少个排列 $a$ 满足 $x$ 出现在 $f(a)$ 中，也就是存在一个长度为 $k$ 的窗口，其中 $x$ 在这个窗口中，且这个窗口的其他值都小于 $x$。

先枚举 $y$ 表示 $x$ 的位置。为去重，可以以第一个以 $x$ 为最大值的窗口作为关键点，枚举 $x$ 在这个窗口中的位置 $z$。

当 $z=k\vee y=z$ 时，此时这个窗口要么是第一个碰到 $x$ 的窗口，要么是整个排列的第一个窗口，此时不需要额外保证第一个以 $x$ 为最大值的条件。在 $x-1$ 个数中选取 $k$ 个来保证 $x$ 在窗口内最大，其他 $n-k$ 个数任意排列，方案数为 $\binom{x-1}{k-1}(k-1)!(n-k)!$。

否则，需要额外保证这是第一个以 $x$ 为最大值的窗口，也就是窗口左端的左边一个数必须大于 $x$。方案数为 $(n-x)\binom{x-1}{k-1}(k-1)!(n-k-1)!$，需要额外特判 $n=k$ 的情况。

一共有 $n-k+1$ 个窗口，窗口中的位置有 $k$ 个，故 $z=k\vee y=z$ 的情况总共有 $n$ 个，其他均为另一种情况。

直接求和即可，时间复杂度 $\mathcal{O}(n)$。

```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define mp make_pair 
#define pob pop_back
using namespace std;
typedef long long ll;
const ll maxn=500007,ee=1e18,p=998244353;
ll n,k,frac[maxn],inv[maxn],ans;
ll qpow(ll a,ll b){ll E=1; for(;b;b>>=1,a=a*a%p)if(b&1) E=E*a%p; return E;}
ll C(ll a,ll b){return (a<b||b<0)?0:(frac[a]*inv[b]%p*inv[a-b]%p);}
void init(void){
	frac[0]=1;
	for(ll i=1;i<maxn;i++) frac[i]=frac[i-1]*i%p;
	inv[maxn-1]=qpow(frac[maxn-1],p-2);
	for(ll i=maxn-1;i>=1;i--) inv[i-1]=inv[i]*i%p;
}
int main(void){
	//freopen("data.in","r",stdin); 
	//freopen("data.out","w",stdout);
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>k; init();
	for(ll x=1,fr;x<=n;x++){
		if(n==k) fr=0; else fr=frac[n-k-1];
		ans=(ans+n*C(x-1,k-1)%p*frac[k-1]%p*frac[n-k]%p+(k*(n-k+1)%p-n+p)%p*(n-x)%p*C(x-1,k-1)%p*frac[k-1]%p*fr%p)%p;
	}
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：candy0014 (赞：0)

显然 $f$ 数组是由若干个互不相同的连续段构成的，于是我们只需要对连续段进行计数即可。

因为连续段的数量等于「相邻两个数不同的对数」再加 $1$，所以对于每一个 $i$，考虑 $f(p)_i \not= f(p)_{i+1}$ 的排列 $p$ 的数量。

注意到 $f(p)_i$ 和 $f(p)_{i+1}$ 是两个相邻的长度为 $k$ 的区间的最大值，那么他们不相同等价于：这两个区间的并（一个长度为 $k+1$ 的区间）的最大值位于这个大区间的头或尾。而在一共 $n!$ 个排列中，这个长度为 $k+1$ 的区间的最大值位于区间首尾的概率为 $\dfrac{2}{k+1}$，故共有 $n!\times \dfrac{2}{k+1}$ 个排列满足：对于某个固定的 $i$，有 $f(p)_i \not= f(p)_{i+1}$。

这个式子与 $i$ 无关，所以直接将其乘上 $i$ 的数量（即 $n-k$）即为答案。

故答案为 $n!\times \dfrac{2}{k+1}\times (n-k)+n!$（最后加的 $n!$ 是因为每个排列有额外的 $1$ 的贡献）。

---

## 作者：lyhqwq (赞：0)

# Solution

挺好的数学题。

题目本质上是求滑动窗滑动的过程中最大值变化了多少次。

当滑动窗 $[l,l+k-1]$ 向右滑动时，当且仅当 $[l,l+k-1]$ 的最大值为 $a_l$ 或 $[l+1,l+k]$ 的最大值为 $a_{l+k}$ 时最大值会变化。我们分别计算左边删除的数和右边添加的数的贡献。

左边的数的贡献为 $\sum\limits_{i=1}^n\binom{i-1}{k-1}(k-1)!(n-k)!(n-k)$。右边数的贡献为 $\sum\limits_{i-1}^n\binom{i-1}{k}k!(n-k-1)!(n-k)$。

注意要去除重复的贡献 $\sum\limits_{i=1}^n\binom{i-1}{k-1}(n-i)(n-k-1)!(k-1)!(n-k)$。

最后加上每种排列的第一段的贡献 $n!$。

# Code
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=500005;
const int Mod=998244353;
int n,k;
LL ans1,ans2,ans3;
LL fac[N];
LL qpow(LL a,int b){
	LL ans=1;
	for(;b;b>>=1,a=a*a%Mod) if(b&1) ans=ans*a%Mod;
	return ans;
}
LL C(int n,int m){
	if(n<m) return 0;
	return fac[n]*qpow(fac[m],Mod-2)%Mod*qpow(fac[n-m],Mod-2)%Mod;
}

int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%d%d",&n,&k);
	fac[0]=1;
	for(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%Mod;
	for(int i=1;i<=n;i++) ans1=(ans1+C(i-1,k-1)*fac[k-1]%Mod*fac[n-k]%Mod*(n-k)%Mod)%Mod;
	if(k<n) for(int i=1;i<=n;i++) ans2=(ans2+C(i-1,k)*fac[k]%Mod*fac[n-k-1]%Mod*(n-k)%Mod)%Mod;
	if(k<n) for(int i=1;i<=n;i++) ans3=(ans3+C(i-1,k-1)*(n-i)%Mod*fac[n-k-1]%Mod*fac[k-1]%Mod*(n-k)%Mod)%Mod;
	printf("%lld\n",(ans1+ans2-ans3+fac[n]+Mod)%Mod);
	return 0;
}

```

---


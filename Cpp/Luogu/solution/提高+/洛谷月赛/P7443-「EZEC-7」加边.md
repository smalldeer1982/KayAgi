# 「EZEC-7」加边

## 题目背景

> 暴力怎么做？暴力是不是，加边！加边！加边！然后，并查集查询！

Alice 不喜欢并查集，但是她喜欢加边。

## 题目描述

给定一棵 $n$ 个节点的树，节点从 $1$ 开始编号，$1$ 号节点是根节点，每条边的方向是从父亲到儿子。每个点有一个点权 $a_i$。Alice 和 Bob 在玩游戏，他们在根节点上放了一个棋子，Alice 和 Bob 轮流将棋子沿边移动，谁不能移动谁输。

已知 Alice 是先手或是后手。在游戏开始前，Alice 可以在树上添加一条有向边 $u\to v$（$1\le u,v\le n$），然后和 Bob 在形成的图上玩这个游戏，她希望自己存在必胜策略。**她也可以选择不加边。如果无法决出胜负则不算胜利。**

给定正整数 $A,B$，Alice 添加边 $u\to v$ 的代价是 $A\times a_u+B\times  a_v$。选择不加边的代价为 $0$。

Alice 要最小化她的代价。如果她怎么加边都不满足要求，输出 $-1$。

Alice 会做出 $T$ 次询问，你需要对每个询问输出答案。

## 说明/提示

**【样例解释】**

在第 $1$ 组询问中，Alice 是后手，她无论怎么添加边都无法拥有必胜策略，所以输出 $-1$。  
在第 $2$ 组询问中，Alice 是后手，她不需要添加边就拥有必胜策略，所以代价为 $0$。  
在第 $3$ 组询问中，Alice 是先手，她只能添加一条 $1\to 3$ 的边使自己必胜，此时代价为 $2\times 4+7\times 2=22$。  
在第 $4$ 组询问中，Alice 是后手，她可以添加一条 $9\to 5$ 的边使自己必胜，此时代价为 $523\times 109+182\times 162=86491$。她还有其他使自己必胜的方法，但是可以发现 $86491$ 是最小代价。  

------------


**【数据范围】**

**本题采用捆绑测试。**


- Subtask 1（10 points）：$n\le 10$，$T=1$；
- Subtask 2（15 points）：$\sum n\le 200$；
- Subtask 3（15 points）：$\sum n\le 2000$；
- Subtask 4（10 points）：$f_i=i-1$；
- Subtask 5（10 points）：$f_i=1$；
- Subtask 6（20 points）：$\sum n\le 5\times 10^5$；
- Subtask 7（20 points）：无特殊限制。

对于 $100\%$ 的数据，满足 $1\le T\le 2\times10^3$，$2\le n\le2\times 10^5$，$\sum n\le 5\times 10^6$，$1\le a_i,A,B\le 10^9$，$f_i<i$，$t\in\{0,1\}$。


------------
**【提示】**

请使用较快的输入方式。

## 样例 #1

### 输入

```
4
3 1 2 7
1 1
4 3 2
3 1 2 7
1 2
4 3 2
3 0 2 7
1 2
4 3 2
9 1 523 182
1 1 2 2 2 3 3 1
3 23 18 293 162 483 574 384 109```

### 输出

```
-1
0
22
86491```

# 题解

## 作者：Little09 (赞：7)

迟到了的出题人题解。

------------


部分分如下：

- Subtask 2：枚举一下加哪条边，然后按照有向图博弈去做。
- Subtask 4：在一个自己能到达的必败点，连一条边到后面的另一个必败点。可以后缀 min 处理。
- Subtask 5：先手则 0，后手则 -1。

------------

考虑必胜点和必败点的思想。当一个点指向的所有点都是必胜点，这个点是必败点。否则是必胜点。叶子节点是必败点。

先不考虑加边，处理出每个点是必胜点还是必败点。接着处理出每个点的改变会不会影响到根的改变。

先考虑加边形成环的情况，是不会使得必败变成必胜的。只会使局面变成平局或不变。[证明](https://www.luogu.com.cn/paste/tbca17f9)。

不形成环的情况，就是 $v$ 不在 $u$ 到根的路径上。**考虑一个 $u$ 改变会影响根**。对于这个点是必胜点，肯定是无法改变的。对于这个点是必败点，只要把它连到一个必败点上去，它就能改变。要计算出最小的不在这个点到根路径上的必败点。

**接下来的问题是要计算出最小的不在这个点到根路径上的必败点。**

- Subtask 3：每次暴力扫一遍。
- Subtask 6：发现要维护单点插入、删除和整体 min，用 multiset 等数据结构维护。
- Subtask 7：在树上跑两遍 dfs，一遍从左往右，一遍从右往左。每次便遍历顺序是先儿子再父亲。会发现在第一次遍历 $x$ 节点前的所有点是树上在 $x$ 左边的点和 $x$ 子树的点，第二次遍历 $x$ 节点前的所有点是树上在 $x$ 右边的点和 $x$ 子树的点。两次的并就是不在 $x$ 到根路径上的点。做个前缀 min 即可。
- 也还有其他很多的线性做法。


正解复杂度线性。貌似被堆的 log 过去了，但是我不想卡了。

代码细节比较多，但是思路算是清晰的。写得比较丑，就不给代码了。

---

## 作者：0x3F (赞：7)

首先考虑不加边的情况。

在何时一棵树满足先手必胜？

**当且仅当 TA 的所有儿子中至少有一个是先手必败的。**

也就是说，你往先手必败的儿子那里走，对手就完蛋了。

**如果 TA 的每一个儿子都是先手必胜的，那他就是先手必败的。**

也就是说，不管你往哪里走，你都只能眼睁睁看着对手获胜。

那么边界条件是怎么样的呢？

**显而易见，叶子节点一定是先手必败的。**

于是我们可以判断出来每一个点是先手必胜还是先手必败。

由于从根出发，所以如果**根节点先手必胜**，而且 **Alice 是先手**，那么答案就是 $0$。

如果**根节点先手必败**，而且 **Alice 是后手**，那么答案也是 $0$。

如果不是上述两种情况之一呢？

加边！加边！加边！

加的边应该满足什么性质呢？

首先，这条边**不能构成环**，否则游戏就结束不了了。

也就是说，**不能从子孙连到祖先**。

其次，这条边必须**只能让 Alice 走**。

再次，Alice 必须能到达**这条边的起点**。

最后，由于 Alice 走完这条边以后是 Bob 走，所以这条边的**终点一定要是先手必败的**。

综上：

1. Alice 必须可以到达这条边的起点。
1. 这条边的终点一定要是先手必败的点。
1. 这条边不能从子孙连到祖先。

后两条没什么难度，但是第一条就有些难了。

需要注意的是，Bob 会~~不讲武德~~主动避开 Alice 连的边。

我们可以进行 DFS，模拟 Alice 和 Bob 轮流走的过程。

1. 如果当前是 Alice 走，那 TA 可以向所有方向走。
1. 如果当前是 Bob 走，而且该节点只有一个儿子，或者所有儿子中只有一个可以让 Bob 获胜，那 TA 只能走这里。
1. 如果当前是 Bob 走，而且该节点的儿子中有多个可以使 Bob 获胜，那么就停止 DFS ，因为 Bob 会挑 Alice 没有加边的子树走。

如果**没有边符合上述条件**，那么答案就是 $-1$。

否则，答案就是其中**代价最小**的一条边的代价。

用**贪心**，具体方法就不展开说了。

另外，说明一下我的代码：`win` 表示使得先手必胜的**方案数**。

`vis` 表示该节点 **Alice 是否可达**。

我使用**左子右兄**的方法存储这棵树。

还有：

$$\Large{\texttt{十年 OI 一场空，不开 long long 见祖宗!!!}}$$

```cpp
#include <bits/stdc++.h>
#define _ 5000010
using namespace std;
int T, n, t, f[_], w[_], dep[_], lson[_], rbro[_], mxu[_], mxv[_], siz[_], win[_];
bool vis[_];
long long a, b, ans;

inline int read()
{
	int s=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		s=s*10+ch-'0';
		ch=getchar();
	}
	return s*f;
}

inline void write(long long x)
{
    if(x<0){
    	putchar('-');
		x=-x;
	}
    if(x>9) 
		write(x/10);
    putchar(x%10+'0');
}

void dfs(int p, bool a) {
	vis[p] = a;
	if (siz[p] == 0) return;
	if (a || win[p] == 1) {
		for (int i = lson[p]; i; i = rbro[i]) if (a || !win[i]) dfs(i, !a);
	}
}

int main() {
	ios::sync_with_stdio(false);
	T = read();
	while (T--) {
		n = read();
		t = read();
		a = read();
		b = read();
		for (int i = 1; i <= n; i++) {
			vis[i] = dep[i] = win[i] = siz[i] = lson[i] = rbro[i] = 0;
			mxu[i] = mxv[i] = 0x3F3F3F3F;
		}
		for (int i = 2; i <= n; i++) {
			f[i] = read();
			dep[i] = dep[f[i]] + 1;
			rbro[i] = lson[f[i]];
			lson[f[i]] = i;
			siz[f[i]]++;
		}
		for (int i = 1; i <= n; i++) {
			w[i] = read();
		}
		for (int i = n; i >= 1; i--) {
			if (!win[i]) win[f[i]]++;
		}
		if ((win[1]!=0) ^ t) {
			puts("0");
			continue;
		}
		dfs(1, !t);
		ans = 0x3F3F3F3F3F3F3F3Fll;
		for (int i = n; i >= 1; i--) {
			if (vis[i]) mxu[i] = min(mxu[i], w[i]);
			if (!win[i]) mxv[i] = min(mxv[i], w[i]);
			if (siz[i]) {
				int mmxu = mxu[lson[i]], mmxv = mxv[lson[i]];
				for (int j = rbro[lson[i]]; j; j = rbro[j]) {
					if (mmxu != 0x3F3F3F3F && mxv[j] != 0x3F3F3F3F) ans = min(ans, a*mmxu+b*mxv[j]);
					if (mmxv != 0x3F3F3F3F && mxu[j] != 0x3F3F3F3F) ans = min(ans, a*mxu[j]+b*mmxv);
					mmxu = min(mmxu, mxu[j]);
					mmxv = min(mmxv, mxv[j]);
				}
				mxu[i] = min(mxu[i], mmxu);
				mxv[i] = min(mxv[i], mmxv);
				if (vis[i] && mmxv != 0x3F3F3F3F) ans = min(ans, a*w[i]+b*mmxv);
			}
		}
		if (ans != 0x3F3F3F3F3F3F3F3Fll) write(ans), puts("");
		else puts("-1");
	}
	return 0;
}
```


---

## 作者：Macesuted (赞：6)

[点击此处以获得更佳用户体验](https://www.macesuted.cn/article/lg7443/)

[题面](https://www.luogu.com.cn/problem/P7443)

~~比赛时一急以为可以加多条边导致没写出来（（~~

# 分析

考虑 $f[i][j](1 \le i \le n,j \in \{0,1\})$ 表示将 $i$ 号点变为先手必败/必胜所需要的最小花费。

初始时先手必胜的点 $f[i][1]=0$，初始时先手必败的点 $f[i][0]=0$。

接下来考虑加边的情况。显然如果一个先手必败点要作为这条加上去的边的起点，那么终点一定是树上所有**非祖先**先手必败点中 $B \times a_i$ 最小的点。因为一个先手必败点连到另一个先手必败点上后，这个点就会变为先手必胜点。而先手必胜点再往外连边不会使答案更优。如果一个点向自己的一个祖先连边也并不会使答案更优（显然如果你想通过这种方法使自己更优，对手在下一轮也会通过相同的方法使自己更优，造成无限循环）。

这个可以在 DFS 过程中记录。先采用这个方法将所有 $f[i][0]=0$ 的点（先手必败点）的 $f[i][1]$ 赋上值。

接着考虑转移。当一个点的所有孩子节点均为必胜点时这个点为必败点；当一个点存在一个孩子节点为必败点时这个点为必胜点。

如果这个点为必败点，只需要找到一个必败的孩子节点，用它的值来更新自己就可以了。

$$f[i][1]=\min\{f[son_i][0]\}$$

如果这个点要为必胜点，则所有孩子都必须为必败点。如果原来有两个甚至更多的孩子节点是先手必胜的，显然这次就将无法转移（因为我们最多只能让其中的一个孩子节点转变状态）。如果原来没有孩子是先手必胜的，则赋初值时已经考虑该情况。仅当有一个孩子是先手必胜时我们需要在这里进行转移。下面令 $son$ 表示这个儿子。

$$f[i][0]=f[son][1]$$

具体实现见代码。

# 代码

实现并不是很简单。

~~可能是因为我的代码实现能力比较弱~~

```cpp
/**
 * @author Macesuted
 * @date 2021-03-22
 * 
 * @copyright Copyright (c) 2021
 * 
 */

#include <bits/stdc++.h>
using namespace std;

using io::getch;
using io::putch;
using io::read;
using io::write;

#define maxn 200005
#define inf 4000000000000000000LL

vector<vector<int> > graph;
int a[maxn];
long long f[maxn][2], minVal[maxn];
int n, t;
long long A, B;

void dfs(int p) {
    for (vector<int>::iterator i = graph[p].begin(); i != graph[p].end(); i++) {
        dfs(*i);
        if (f[*i][0] == 0) f[p][1] = 0;
        minVal[p] = min(minVal[p], minVal[*i]);
    }
    if (f[p][1]) f[p][0] = 0, minVal[p] = min(minVal[p], B * a[p]);
    return;
}
void update(int p, long long val) {
    long long best1 = inf, best2 = inf;
    for (vector<int>::iterator i = graph[p].begin(); i != graph[p].end(); i++)
        if (minVal[*i] < best1)
            best2 = best1, best1 = minVal[*i];
        else if (minVal[*i] < best2)
            best2 = minVal[*i];
    int cnt1 = 0;
    long long cntVal = 0;
    for (vector<int>::iterator i = graph[p].begin(); i != graph[p].end(); i++) {
        update(*i, min(val, minVal[*i] == best1 ? best2 : best1));
        f[p][1] = min(f[p][1], f[*i][0]);
        if (!f[*i][0]) {
            cnt1++;
            cntVal = f[*i][1];
        }
    }
    for (vector<int>::iterator i = graph[p].begin(); i != graph[p].end(); i++)
        val = min(val, minVal[*i]);
    f[p][1] = min(f[p][1], A * a[p] + val);
    if (cnt1 == 1) f[p][0] = min(f[p][0], cntVal);
    return;
}

int main() {
    int T = read<int>();
    while (T--) {
        n = read<int>(), t = read<int>(), A = read<long long>(), B = read<long long>();

        for (register int i = 1; i <= n; i++) f[i][0] = f[i][1] = minVal[i] = inf;

        graph.resize(n + 1);
        for (register int i = 2; i <= n; i++) graph[read<int>()].push_back(i);
        for (register int i = 1; i <= n; i++) a[i] = read<int>();

        dfs(1), update(1, inf);

        write(f[1][!t] == inf ? -1 : f[1][!t]), putch('\n');

        graph.clear();
    }
    return 0;
}
```

---

## 作者：cirnovsky (赞：6)

B·不会清数组·H

首先我们求出原树的 $SG$ 函数，这个东西很容易：$SG(\text{leaves})=0,SG(x)\text{ or\_eq }SG(y\in\text{son}(x))\text{ xor }1$。

然后考虑枚举附加边的起点 $u$。我们可以发现一个结论：我们不会去连返祖边。

简单证明一下（只考虑 Alice 先手，后手同理），当 $SG(u)=1$ 也就是在 $u$ 我们是先手必胜，那么显然我们不会去连边；当 $SG(u)=0$，此时先手必败，如果你连一个偶环没有意义，连一个奇环的话 Alice 跑完成必胜则 Bob 也可以跑一次从必败变成必胜，会形成无意义的无限循环，证毕。

那么我们的终点就是**树上除了 $u$ 到根的路径上的所有满足 $SG$ 函数值为 $0$ 的点中的一个**，我们当然贪心选择点权最小的。

那么此时有两种实现方法，一种是 $1~\log$ 的权值线段树，还有就是维护最小和次小，复杂度线性。

$\mathcal{O}(n\log_{2}n)$ （60 points）：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
vector<int> pri;
LL T,n,t,A,B,poi[200010],head[200010],nxt[400010],to[400010],cntot,sg[200010],mx,expoi[200010],mp[200010];
void dfs(LL x){sg[x]=0; for(LL i=head[x];i;i=nxt[i])	dfs(to[i]),sg[x]|=(!sg[to[i]]);}
LL nodes[800010];
void ins(LL l,LL r,LL x,LL pos,LL val)
{
	if(l^r)
	{
		LL mid=(l+r)>>1;
		if(mid>=pos)	ins(l,mid,x<<1,pos,val);
		else	ins(mid+1,r,x<<1|1,pos,val);
		nodes[x]=nodes[x<<1]+nodes[x<<1|1];
	}
	else	nodes[x]+=val;
}
LL find(LL l,LL r,LL x)
{
	if(l^r)
	{
		LL mid=(l+r)>>1;
		if(nodes[x<<1])	return find(l,mid,x<<1);
		else	return find(mid+1,r,x<<1|1);
	}
	else	return mp[l];
}
LL getans(LL x,LL ty)
{
	if(!ty)
	{
		if(!sg[x])
		{
			ins(1,mx,1,expoi[x],-1);
			LL s=find(1,mx,1);
			if(!nodes[1])	s=-1;
			if(s==-1)	return ins(1,mx,1,expoi[x],1),-1; 
			LL res=A*poi[x]+B*s,tmp=0;
			for(LL i=head[x];i;i=nxt[i]) res=min(res,(tmp=getans(to[i],ty^1))==-1?LL(1e18):tmp);
			ins(1,mx,1,expoi[x],1);
			return res;
		}
		else	return 0;
	}
	else
	{
		LL num=0;
		for(LL i=head[x];i;i=nxt[i])	if(!sg[to[i]])	++num;
		if(num>1)	return -1;
		LL tmp=1e18;
		for(LL i=head[x];i;i=nxt[i]) if(!sg[to[i]])	tmp=min(tmp,getans(to[i],ty^1));
		return tmp;
	}
}
int main()
{
	scanf("%lld",&T); while(T--)
	{
		scanf("%lld %lld %lld %lld",&n,&t,&A,&B);
		for(LL i=2,f;i<=n;++i)
		{
			scanf("%lld",&f);
			nxt[++cntot]=head[f];
			to[cntot]=i;
			head[f]=cntot;
		}
		for(LL i=1;i<=n;++i)	scanf("%lld",&poi[i]),mx=max(mx,poi[i]),pri.push_back(poi[i]);
		sort(pri.begin(),pri.end()),pri.erase(unique(pri.begin(),pri.end()),pri.end());
		mx=pri.size();
		for(LL i=1;i<=n;++i)	mp[expoi[i]=lower_bound(pri.begin(),pri.end(),poi[i])-pri.begin()+1]=poi[i];
		dfs(1);
		if(sg[1]^t)	puts("0");
		else
		{
			for(LL i=1;i<=n;++i)	if(!sg[i]) ins(1,mx,1,expoi[i],1);
			printf("%lld\n",getans(1,t));
		}
		cntot=0,pri.clear();
		for(LL i=1;i<=n;++i)	head[i]=poi[i]=expoi[i]=0;
		for(LL i=1;i<=(n<<2);++i)	nodes[i]=0;
	}
	return 0;
}
```

$\mathcal{O}(n)$ （100 points）：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL INF=1e18;
LL T,n,t,A,B,poi[200010],head[200010],nxt[400010],to[400010],cntot,sg[200010],_fmin[200010],smin[200010];
void dfs(LL x)
{
	sg[x]=0,_fmin[x]=smin[x]=INF;
	for(LL i=head[x];i;i=nxt[i])
	{
		LL y=to[i];
		dfs(y),sg[x]|=(!sg[y]);
		if(_fmin[y]<_fmin[x])
		{
			smin[x]=min(_fmin[x],smin[y]);
			_fmin[x]=_fmin[y];
		}
	}
	if(!sg[x]&&poi[x]<_fmin[x])	smin[x]=_fmin[x],_fmin[x]=poi[x];
	else if(!sg[x]&&poi[x]<smin[x])	smin[x]=poi[x];
}
LL getans(LL x,LL ty,LL ho)
{
	if(!ty)
	{
		if(!sg[x])
		{
			LL tmp=ho,fmn=INF,smn=INF,pos=0;
			for(LL i=head[x];i;i=nxt[i])
			{
				LL y=to[i];
				tmp=min(tmp,_fmin[y]);
				if(_fmin[y]<fmn)	smn=fmn,fmn=_fmin[y],pos=y;
				else if(_fmin[y]<smn)	smn=_fmin[y];
			}
			if(tmp==INF)	return -1;
			LL res=A*poi[x]+B*tmp;
			for(LL i=head[x];i;i=nxt[i])
			{
				LL y=to[i];
				LL extmp=0;
				if(pos^y)	extmp=getans(y,ty^1,min(ho,fmn));
				else	extmp=getans(y,ty^1,min(ho,smn));
				if(~extmp)	res=min(res,extmp);
			}
			return res;
		}
		else	return 0;
	}
	else
	{
		LL num=0;
		for(LL i=head[x];i;i=nxt[i])	if(!sg[to[i]])	++num;	else ho=min(ho,_fmin[to[i]]);
		if(num>1)	return -1;
		for(LL i=head[x];i;i=nxt[i]) if(!sg[to[i]])	return getans(to[i],ty^1,ho);
	}
}
int main()
{
	scanf("%lld",&T); while(T--)
	{
		scanf("%lld %lld %lld %lld",&n,&t,&A,&B);
		for(LL i=2,f;i<=n;++i)
		{
			scanf("%lld",&f);
			nxt[++cntot]=head[f];
			to[cntot]=i;
			head[f]=cntot;
		}
		for(LL i=1;i<=n;++i)	scanf("%lld",&poi[i]);
		_fmin[0]=INF,dfs(1);
		if(sg[1]^t)	puts("0");
		else	printf("%lld\n",getans(1,t,INF));
		cntot=0;
		for(LL i=1;i<=n;++i)	head[i]=poi[i]=0;
	}
	return 0;
}
```

---

## 作者：water_tomato (赞：5)

本文同步发表于个人博客：[Link](https://www.watertomato.com/p7443-%e3%80%8cezec-7%e3%80%8d%e5%8a%a0%e8%be%b9-%e9%a2%98%e8%a7%a3/)。

update 21/3/24：更新了部分 latex。

## 题意

[题目链接](https://www.luogu.com.cn/problem/P7443)

树上的棋子博弈，每个点有权值。你可以添加一条边以试图反败为胜，不同的加边方法根据权值有一个代价，需要最小化这个代价。

## 解析

我们首先定义一个结点先手必败是 lose，先手必胜是 win，容易发现，叶子结点一定是 ​lose，然后对于每一个非叶子结点，只要它有一个儿子是 ​lose，它就是 win，否则，该结点也是 lose。一遍 dfs 可以求出每一个点的初始状态，从而判断是否输出零。

对于输出非零的情况，我们发现对于这棵尚未加边的树，从起点开始走的话，win 结点一定是对方会走，且会走向一个 lose 结点，而 lose 结点时我们在走。我们考虑怎么连边。显然，我们会从一个 lose 结点向外连边，因为 win​ 结点是对方在走，连了边是没意义的。

接着我们发现，我们一定不会连一条返祖边。因为我们连了返祖边之后，如果走到一个 win 结点，就是对方在走，我们没有办法胜利，如果连到一个 lose​ 结点，那么就使对方变成了我们在那个点时的状态，这样对方走到连出边的这个结点时又可以通过返祖边走到祖先，游戏永远也不会结束。

因此，在放弃了返祖边之后，我们连完一条边后，肯定仍然是一张 DAG（虽然不是树了），显然的，我们只需要连向一条 lose​ 边，并走到那条边，就可以获胜。

接着考虑怎么使代价最小。我们从 $1$ 号点开始 dfs，dfs 时我们走到若干个点，如果是一个 lose 点，那么就是我们走，我们将他试图连向非祖点中权值最小的那个，并更新答案；如果是一个 win 点，那么是对方在走，首先他肯定不会向 win 点走，然后我们观察这个点的儿子中有几个 lose 点，如果有至少两个，那就不用继续 dfs 下去了，因为我们在这个点后面操作一定输，无论我们怎么加边，他都可以选择走子树中没有加边的那个 lose 点。如果儿子中只有一个 lose 点，那么我们走那个点就可以了。

接着又出现了一个问题，我们怎么维护非祖点中权值最小的那个？dead_X 说可以两遍 dfs 或 ST 表，但是我并不会两遍 dfs ，也不想写 ST 表。于是我用了另一种维护方法：第一遍 dfs 时，我们将每一个 lose 点添加到优先队列中，第二遍 dfs 时，我们每 dfs 到一个点，就将这个点标记一下，然后我们弹出优先队列队首的若干个标记过的元素，再取弹出后的队首，这个元素就是我们要找的非祖点中权值最小的那个点，然后再 dfs 结束时，我们将标记取消，且由于这个点可能被弹出了，我们索性：如果这个点是 lose 的话，就再次把这个点扔进优先队列里去。

容易发现这个算法复杂度是 $O(n\log n)$ 的，但是并跑不满，因此通过这题不成问题。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
using namespace std;
const int N=2e5+5;
char buf[1<<21],*p1=buf,*p2=buf;
template <typename T>
inline void read(T& r) {//快读
    r=0;bool w=0; char ch=getchar();
    while(ch<'0'||ch>'9') w=ch=='-'?1:0,ch=getchar();
    while(ch>='0'&&ch<='9') r=r*10+(ch^48), ch=getchar();
    r=w?-r:r;
}
int T,n,t,A,B,a[N];
struct edge{
	int to,nxt;
}e[N<<1];
int head[N],cnt,fl[N];//1=win 0=lose
inline void add(int u,int v){
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
struct node{
	int id,val;
	bool operator<(const node &x)const{
		return x.val<val;
	}
};
priority_queue<node> q;
bool vis[N];
inline void dfs1(int u){//dfs1 判断初始状态
	fl[u]=0;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		dfs1(v);if(!fl[v]) fl[u]=1;
	}
	if(!fl[u]) q.push((node){u,a[u]});
}
int ans;
inline void dfs2(int u){
	vis[u]=1;//标记一下
	if(fl[u]==0){//lose 点，自己走
		while(!q.empty()&&vis[q.top().id]) q.pop();
		if(q.empty()){//没有可以用的点了就退出
			vis[u]=0;
			if(!fl[u]) q.push((node){u,a[u]});
			return;
		}
		ans=min(ans,A*a[u]+B*a[q.top().id]);
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].to;dfs2(v);
		}
	}
	else{//win 点，对方走
		int CNT=0;
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].to;
			if(fl[v]) continue;
			CNT++;
		}
		if(CNT>=2) return;//有两个 lose 儿子，退出
		for(int i=head[u];i;i=e[i].nxt){//仅有一个 lose 儿子，走
			int v=e[i].to;
			if(fl[v]) continue;dfs2(v);
		}
	}
	vis[u]=0;//撤销标记
	if(!fl[u]) q.push((node){u,a[u]});//这个点处理完了再加回去
}
signed main(){
	read(T);
	while(T--){
		while(!q.empty()) q.pop();
		read(n);read(t);read(A);read(B);cnt=0;ans=2e18+5;
		for(int i=1;i<=n;i++) head[i]=0;
		for(int i=1;i<=n;i++) vis[i]=0;
		for(int i=2,x;i<=n;i++){
			read(x);add(x,i);
		}
		for(int i=1;i<=n;i++){
			read(a[i]);
		}
		dfs1(1);
		if(t==0){
			if(fl[1]==1){//初始就能赢
				printf("0\n");continue;
			}
			dfs2(1);
			if(ans==2e18+5) printf("-1\n");//ans 没有可以更新的，输出 -1
			else printf("%lld\n",ans);
		}
		else{
			if(fl[1]==0){
				printf("0\n");continue;
			}
			dfs2(1);
			if(ans==2e18+5) printf("-1\n");
			else printf("%lld\n",ans);
		}
	}
	return 0;
}
```



---

## 作者：VinstaG173 (赞：4)

题外话：考场上不到十分钟就胡出来了，然后不想写了，事实证明以我现在的码力估计也写不出来了 /kk

假设现在我们已经将每个点的胜败情况处理出来了，并且 Alice 还不能获胜，需要加边。

首先我们考虑返祖边的问题。如果加了一条返祖边，那么会形成一个环。若必胜策略是走到环上，那么必定会在某个地方跳出环走到一个必败点，但是加的这条边在环上，所以不可能是那条跳出环走到必败点上的边。也就是说，这条边我们不加，Alice 一样能必胜，矛盾！所以不可能加一条返祖边。

然后我们考虑如何改变一个结点的胜败状态。分必胜态转必败态和必败态转必胜态讨论。

如果是必胜态转必败态，那么我们要将它的所有子结点都变成必胜态。显然我们加一条边最多能改变其一个子结点的状态，于是我们只考虑它只有一个必败子结点的情况。这时候问题就是改变这个必败子结点的状态，变为必胜。

然后处理必败态转必胜态。显然我们要做的是从这个必败点向一个非其祖先的必败点连一条边的代价和将其某个子结点变成必败的代价取最小值。因此我们只要处理出除这个点及其祖先外所有必败点权值的最小值就能做出第一部分，第二部分等同于必胜态转必败态。因此我们只要 `dfs` 一下就可以做到。

问题是如何快速处理出除了某个必败点及其祖先外所有必败点的权值最小值。显然它可以分为两部分：这个点的子树中除它以外的必败点权值最小值和这个点的某个祖先的所有子结点中除去同为它的祖先（或它自己）的子结点外其他所有子结点子树里的权值最小值。简单来说就像下面这个图这样，我们要的就是所有三角形区里的权值最小值：

![](https://cdn.luogu.com.cn/upload/image_hosting/cadko11k.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

我们要求这个，只要对于每个点的子结点设序，并预处理出每个点子树内的必败点权值最小值，再求出子结点子树最小值的前缀最小值和后缀最小值，就能 $O(1)$ 处理出我们要的最小值。显然这些都能在最开始处理胜败状态的那次搜索里预处理出来。

总时间复杂度 $O(n)$。

Code:
```cpp
#include<cstdio>
#define rg register
#define ll long long
#define min(a,b) (((a)<(b))?(a):(b))
const ll INF=3e18;
const int inf=1e9+7;
inline char rc()
{
	static char buf[524288],*pn=buf,*pe=buf;
	return (pn==pe)&&(pe=(pn=buf)+fread(buf,1,524288,stdin),pn==pe)?EOF:*pn++;
}
inline int read()
{
	int x=0;
	char cc=rc();
	while(cc<'0'||cc>'9')cc=rc();
	while(cc>='0'&&cc<='9')x=x*10+cc-'0',cc=rc();
	return x;
}
inline ll _read()
{
	ll x=0;
	char cc=rc();
	while(cc<'0'||cc>'9')cc=rc();
	while(cc>='0'&&cc<='9')x=x*10+cc-'0',cc=rc();
	return x;
}
ll a,b;
int t,n,opt,f;
int v[200003];//结点权值
int mn[200003];//子树（除自身外）内必败结点的权值最小值
int ls[200003];//必败子结点对应入边的编号
int sc[200003];//子结点数
int lsc[200003];//必败子结点数
int win[200003];//胜败状态
int head[200003],cnt;
struct edge
{
	int nxt,pre,to;
	int lmn,rmn;//前缀最小值，后缀最小值
}e[200003];
inline void add(int x,int y)
{
	e[++cnt].nxt=head[x],e[head[x]].pre=cnt,e[cnt].pre=0;
	e[cnt].to=y,head[x]=cnt;
}
inline void dfs(int x)
{
	mn[x]=inf;
	win[x]=lsc[x]=0;
	if(!sc[x])return;
	for(rg int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].to;
		dfs(y);
		int mnv=mn[y];
		if(!win[y])
		{
			win[x]=1;
			++lsc[x],ls[x]=i;
			mnv=min(mnv,v[y]);
		}
		e[i].lmn=e[i].rmn=mnv;
		mn[x]=min(mn[x],mnv);
	}
	if(sc[x]>1)//预处理前缀后缀最小值
	{
		rg int i;
		for(i=head[x];e[i].nxt;i=e[i].nxt)e[e[i].nxt].lmn=min(e[e[i].nxt].lmn,e[i].lmn);
		for(;i!=head[x];i=e[i].pre)e[e[i].pre].rmn=min(e[e[i].pre].rmn,e[i].rmn);
	}
}
inline ll solve(int x,int mnv)
{
	ll res=INF;
	if(!sc[x])(mnv<inf)&&(res=a*v[x]+b*mnv);
	else if(mnv<inf||mn[x]<inf)
	{
		res=a*v[x]+b*min(mnv,mn[x]);
		for(rg int i=head[x];i;i=e[i].nxt)
		{
			int y=e[i].to,pr=e[i].pre,nx=e[i].nxt;
			int z=e[ls[y]].to,pe=e[ls[y]].pre,nt=e[ls[y]].nxt;
			if(lsc[y]>1)continue;
			int tmv=min(mnv,min(\
			min(((pr)?e[pr].lmn:inf),((nx)?e[nx].rmn:inf)),\
			min(((pe)?e[pe].lmn:inf),((nt)?e[nt].rmn:inf))));
			res=min(res,solve(z,tmv));
		}
	}
	return res;
}
int main()
{
	t=read();
	while(t--)
	{
		n=read(),opt=read(),a=_read(),b=_read();
		for(rg int i=2;i<=n;++i)f=read(),++sc[f],add(f,i);
		for(rg int i=1;i<=n;++i)v[i]=read();
		dfs(1);
		if(win[1]^opt)puts("0");
		else if(opt)
		{
			if(lsc[1]>1)puts("-1");
			else
			{
				ll mnv=min(((e[ls[1]].pre)?e[e[ls[1]].pre].lmn:inf),((e[ls[1]].nxt)?e[e[ls[1]].nxt].rmn:inf));
				ll res=solve(e[ls[1]].to,mnv);
				if(res<INF)printf("%lld\n",res);
				else puts("-1");
			}
		}
		else
		{
			ll res=solve(1,inf);
			if(res<INF)printf("%lld\n",res);
			else puts("-1");
		}
		for(rg int i=1;i<n;++i)head[i]=0;
		cnt=0;
	}
	return 0;
}
```

---

## 作者：zimujun (赞：2)

可以考虑先 DP 一遍求出在不加边的情况下，每个节点是必胜态还是必败态。

首先显然在根节点与 Alice 的先后手操作状态相符合时根本不需要加边。

然后需要证明一个结论：**加的这一条边，一定不会是一条回边。**

证明也很简单，因为如果是回边的话，那么在这条加入的边起点上，如果是必胜态，那么当前操作者一定不会进入回边，如果是必败态，当前操作者一定会选择走向回边，然后构成循环。

因此，加入回边，要么不会影响结果，要么会使得操作过程陷入死循环。

**如何修改一个点的状态？**

考虑加边的影响，加这条边只可能将一个必败点转变为必胜点。

将一个必败节点转为必胜态，只需要其中一个节点转变为必败态，或者加一条边连接一个合法的必败态节点即可。

将一个必胜节点转为必败节点。一个必胜节点能被改为必败节点，当且仅当其子节点只有一个必败节点，修改的代价为将这个必败子节点转变为必胜点的代价。

那么，在遍历的时候，可以对于必胜节点，处理一下这个节点是否只有一个必败子节点以及这个子节点的编号。

对于必败节点，则只需对所有子节点代价取最小值，然后再与直接加边取个最小值即可。

**如何求直接加边的代价**

发现题目中的式子，对于固定的起点，$a$ 的值和系数都是固定的，所以要取的点一定是 $b$ 值最小的满足条件的必败态节点。

这个可以用线段树实现。每次将在搜索栈中的节点标记为不可抵达（即将线段树对应位置上的权值标记为无穷大）访问完毕时再单点修改回来即可。查询时访问全局最小值。

线段树常数太大？被卡成 90pts。因为只需要单点修改，查询全局最值，那就用 zkw 树。复杂度带 $\log$ 但是常数很小，可以通过。

**Ex：这个步骤一种线性实现的方式**

遍历时对每个节点处理出以该节点为根的最小值，以及每个点所有出点按遍历顺序的前后缀最小值。

第二次遍历的时候进入下一层子节点的时将 当前节点的答案 与即将进入节点遍历顺序 $\pm 1$ 位置的 前/后缀最小值 取个最小值即可。

对当前节点查询的时候取的点为 当前节点的答案 与 所有子节点的子树的最小值 的最小值。

这段话说的好乱啊，希望断句有点帮助吧。

代码：

只有用了 zkw 树的。

```cpp
#include <bits/stdc++.h>

#define LL __int128

using namespace std;

template <typename Temp> inline void read(Temp & res) {
	Temp fh = 1; res = 0; char ch = getchar();
	for(; !isdigit(ch); ch = getchar()) if(ch == '-') fh = -1;
	for(; isdigit(ch); ch = getchar()) res = (res << 3) + (res << 1) + (ch ^ '0');
	res = res * fh;
}
template <typename Temp> inline void Checkmin(Temp & num, Temp comp) {
	if(comp < num) num = comp;
}

const int Maxn = 2e5 + 5;
const LL INF = 0x7fffffffffffffff / 2;

struct e {
	int to, nxt;
} b[Maxn];
int head[Maxn], ecnt;
void add(int u, int v) {b[++ecnt] = (e) {v, head[u]}; head[u] = ecnt;}

bool g[Maxn], h[Maxn]; LL f[Maxn];

int n, w, x, L;
LL A, B, a[Maxn];

#define ls t << 1
#define rs t << 1 | 1
LL data[Maxn << 2];
void modify(int pos, LL d) {
	pos += L; data[pos] = d;
    while(pos >>= 1) data[pos] = min(data[pos << 1], data[pos << 1 | 1]);
}
#undef ls
#undef rs

void dfs1(int t) {
	int cnt = 0;
	for(int i = head[t]; i; i = b[i].nxt) {
		dfs1(b[i].to);
		if(!g[b[i].to]) cnt++;
	}
	if(cnt == 0) g[t] = 0, h[t] = 0;
	else g[t] = 1, h[t] = (cnt == 1);
	return;
}

void dfs2(int t) {
	if(g[t] == 0) modify(t, INF);
	for(int i = head[t]; i; i = b[i].nxt) {
        dfs2(b[i].to);
        if(!g[t]) Checkmin(f[t], f[b[i].to]);
        else if(h[t]) {
            if(!g[b[i].to]) f[t] = f[b[i].to];
        }
    }
 	if(!g[t]) Checkmin(f[t], A * a[t] + B * data[1]);
	if(g[t] == 0) modify(t, a[t]);
}

inline void Main() {
	read(n); read(w); read(A); read(B); ecnt = 0; L = 1; while(L <= n) L <<= 1;
	for(int i = 1; i <= n; ++i) head[i] = 0, f[i] = INF;
  	for(int i = 1; i <= (n << 2); ++i) data[i] = INF;
	for(int i = 2; i <= n; ++i) read(x), add(x, i);
	for(int i = 1; i <= n; ++i) read(a[i]);
	dfs1(1);
  	if((w == 0 && g[1]) || (w == 1 && (!g[1]))) {printf("0\n"); return;}
	for(int i = 1; i <= n; ++i) if(!g[i]) modify(i, a[i]);
	dfs2(1);
	printf("%lld\n", (f[1] != INF ? f[1] : -1));
	return;
}

int main() {
	int T; read(T);
	while(T--) Main();
	return 0;
}
```

---


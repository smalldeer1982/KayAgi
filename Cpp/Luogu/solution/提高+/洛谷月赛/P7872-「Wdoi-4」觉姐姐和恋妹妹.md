# 「Wdoi-4」觉姐姐和恋妹妹

## 题目背景

古明地觉和古明地恋是居住在地灵殿的觉妖怪。古明地觉拥有读心程度的能力，但她的妹妹古明地恋却不具备读心能力。

地灵殿是旧地狱上层的极为空旷的大型别墅建筑。正因如此，古明地恋经常在地灵殿里探索新奇好玩的东西。地灵殿可以被划分出好多好多的房间，每个房间里都有一个装饰物。在古明地恋眼里，每个装饰物都有一个新奇程度（特别地，新奇程度可能为负数，代表恋恋觉得这个物件非常枯燥无味）。

喜欢闲逛的古明地恋，有一天想要探索整个地灵殿。作为姐姐的古明地觉，自然不希望恋恋会失望。也就是说，古明地觉可以通过搬运房间内的物件，移动到新的房间里，来提升恋恋整个游览过程的愉悦程度（即恋恋看到的所有物件的新奇程度之和）。

然而，古明地觉向来是不擅长运动的，因此她不会走很长的路。你现在要做的，就是告诉古明地觉，经过她的清理后，恋恋最多可以获得的愉悦程度的最大值。

## 题目描述

地灵殿可以看作有一个有 $n\times m$ 间房间组成的矩阵，我们用 $(x,y)$ 描述一个房间的位置。其中，位于 $(i,j)$ 的房间里拥有的物件的新奇程度为 $w_{i,j}$，用一个整数表示（可能为负数）。古明地恋的愉悦度被定义为她看到的所有物件的新奇程度之和。

打扫房间的古明地觉，将会从 $(1,1)$ 走到 $(x_s,y_s)$ 。期间，古明地觉**只能走到下侧或者右侧的房间**（假设古明地觉当前在 $(i,j)$，那么她下一步只能走到 $(i+1,j)$ 或者 $(i,j+1)$，并且她不会走出地灵殿）。古明地觉走到一个房间时，可以**捡起房间内的物件**放入背包；她也可以**从背包里取出任意若干件物件**放在该房间（可以既捡起物品又放置物品）。当然，古明地觉不希望带出地灵殿里的物件，因此**结束打扫时，觉的背包里应该没有物件**。初始时，背包为空。

接下来，古明地恋将会从 $(1,1)$ 走到 $(x_k,y_k)$，进行自己的旅行。古明地恋将会看到一个房间里**所有的**物件，并且取得相应的新奇程度。和古明地觉相同，古明地恋**同样**只会向下侧或者右侧的房间行走。

古明地觉想知道，按照这样的规则，恋恋最终得到的愉悦程度最大是多少。

## 说明/提示

样例 $3$ 见下发的附件 $\textbf{\textit{koishi3.in}/\textit{koishi3.out}}$。

---

### 样例解释

#### 样例 1 解释

- 古明地觉的行走路线是 $(1,1)\to(2,1)\to(2,2)\to(2,3)\to(3,3)$，**遇到**的物件的新奇程度分别是 $0,3,2,-1,-3$。期间，她把在 $(2,1)$ 拿起的价值为 $3$ 的物件放置在了 $(2,2)$。
- 古明地恋的行走路线是 $(1,1)\to(1,2)\to(2,2)\to(3,2)\to(4,2)\to(4,3)\to(4,4)$，**看到**的物件的新奇程度分别是 $0,4,2+3,3,4,2,4$。加起来得到愉悦程度为 $22$。

可以证明，不存在更优的方案。

---

### 数据范围及约定

- 对于前 $10\%$ 的数据，满足 $1\le n,m\le 3;|w_{i,j}|\le 10$。
- 对于前 $30\%$ 的数据，满足 $1\le n,m\le 5;|w_{i,j}|\le 10^2$。
- 对于前 $60\%$ 的数据，满足 $1\le n,m\le 70;|w_{i,j}|\le 10^5$。
- 另有 $15\%$ 的数据，保证 $w_{i,j}$ 为**非负整数**。
- 对于 $100\%$ 的数据，满足 $1\le n,m\le 300;|w_{i,j}|\le 10^6$。


## 样例 #1

### 输入

```
4 4
0 4 5 3
3 2 -1 2
-1 3 -3 -1
0 4 2 4
3 3 4 4
```

### 输出

```
22
```

## 样例 #2

### 输入

```
8 8
46 90 58 59 33 64 66 93
52 25 91 51 96 11 21 6
11 1 68 25 50 90 86 94
73 83 48 80 46 46 81 16
60 61 80 55 83 97 67 47
78 96 59 96 39 7 94 66
29 68 15 61 69 43 7 38
31 29 67 79 71 17 0 97
5 3 2 5
```

### 输出

```
509
```

# 题解

## 作者：_lbw_ (赞：7)

官方题解对这题的理解完全不够，那篇题解弱化了条件，但弱化后的问题和原问题并不等价。

我们可以看成两人同时走，这样不会出现后效性。

我们考虑固定两人的路径，觉觉会怎么做呢？

可以看出在两人重合的点上会把正数放上去，如果有负数就拿起，如果两人分离就把负数扔掉。

但是不能把负数扔掉时不会拿起负数。

而觉觉走到终点后，若固定恋恋的位置，则最优答案是唯一的，可以通过简单网格图 dp 算出。

我们先假设最后可以丢掉负数和放上正数，有 dp1：

$f_{px,py,qx,qy}$ 表示觉觉在 $(px,py)$，恋恋在 $(qx,qy)$，注意到 $px+py=qx+qy$，代码：

```cpp
	F(k,2,x1+y1)F(Px,1,n)F(Qx,1,x1)if(k-Px<=m&&k-Qx<=y1){
		ll Py=k-Px,Qy=k-Qx,mx=-1e9;if(Py<1||Qy<1)continue;
		F(p,0,1)F(q,0,1)cmax(mx,dp[k-1][Px-p][Qx-q]);
		if(mx==-1e9)mx=0;
		if(Px==Qx)dp[k][Px][Qx]=mx+max(0,w[Px][Py]);
		else dp[k][Px][Qx]=mx+w[Px][Py]+max(0,w[Qx][Qy]);
	}
```


而觉觉走到终点前，不能轻易的假设两人将会重合或者分离，于是我们可以设计状态 $f_{px,py,qx,qy,k,l}$ 表示觉觉在 $(px,py)$，恋恋在 $(qx,qy)$，此时正数和为 $k$，负数和为 $l$ 的答案，转移是显然的，时间复杂度 $\mathcal{O}(n^3(\sum|w|)^2)$，可得 30pts。

考虑优化，我们感觉记录的信息是在太多，因为大多数情况下两人都将会重合或者分离，那怎么优化呢？

我们将条件弱化为觉觉随时都可以当作自己走到终点，显然不会使答案变大。

分为两种情况讨论，分别是觉觉走到终点时是否与恋恋在一起。

这里只阐述一种情况，另一种情况是类似的，具体可以参见代码。

假设不在一起，则上文 dp 中 l 的记录显然是不必要的，这样 dp 的时间复杂度为 $\mathcal{O}(n^3\sum |w|)$，依旧是 30pts。

考虑进一步优化，对觉觉来说，重要的只是最后一次在一起的时刻，考虑分段 dp。

第一段 dp 可以发现一定可以丢掉负数和放上正数。

于是我们做上文所述 dp1，并在 dp 后只保留 $px=qx$ 的状态。

第二段 dp 我们可以只考虑丢掉负数，于是可以设计出一个与上文 dp1 类似的 dp。

于是此题就得到了解决，时间复杂度 $\mathcal{O}(n^3)$。

卡空间。需要将两次的用同一个 dp 数组。

```cpp
#include<map>
#include<set>
#include<ctime>
// #include<cmath>
#include<queue>
#include<bitset>
#include<cstdio>
#include<vector>
#include<random>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define ll int
using namespace std;
#define I inline ll
#define her1 20090115
#define IV inline void
#define cht 998244353
#define ld long double
#define Aestas16 392699
#define ull unsigned long long
#define mem(x,val)memset(x,val,sizeof x)
#define D(i,j,n)for(register int i=j;i>=n;i--)
#define E(i,now)for(register int i=first[now];i;i=G[i].nxt)
#define F(i,j,n)for(register int i=j;i<=n;i++)
#define DL(i,j,n)for(register ll i=j;i>=n;i--)
#define EL(i,now)for(register ll i=first[now];i;i=G[i].nxt)
#define FL(i,j,n)for(register ll i=j;i<=n;i++)
//#define D(i,j,n)for(int i=j;i>=n;i--)
//#define E(i,now)for(int i=first[now];i;i=G[i].nxt)
//#define F(i,j,n)for(int i=j;i<=n;i++)
//#define DL(i,j,n)for(ll i=j;i>=n;i--)
//#define EL(i,now)for(ll i=first[now];i;i=G[i].nxt)
//#define FL(i,j,n)for(ll i=j;i<=n;i++)
ll read(){
	ll ans=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')ans=ans*10+c-'0',c=getchar();
	return ans*f;
}
mt19937 rnd(her1);
const int maxn = 3e2+5;
#define x1 sdfkjah
#define y1 dsafpisjh
ll dp[maxn*2][maxn][maxn],x1,y1,xk,yk;
ll n,m,w[maxn][maxn],suf[maxn][maxn];
IV cmax(ll&x,ll val){x<val?x=val,0:0;}
int main(){
	// freopen("1.in","r",stdin);
	// freopen("1.out","w",stdout);
	n=read();m=read();
	F(i,1,n)F(j,1,m)w[i][j]=read();
	x1=read();y1=read();xk=read();yk=read();
	F(i,0,n+1)F(j,0,m+1)suf[i][j]=-1e9;
	D(i,xk,1)D(j,yk,1){
		ll mx=-1e9;
		if(j+1<=yk)cmax(mx,suf[i][j+1]);
		if(i+1<=xk)cmax(mx,suf[i+1][j]);
		if(mx==-1e9)mx=0;suf[i][j]=mx+w[i][j];
	}
	ll ans=-1e9;
	// F(i,0,n+1){
	// 	F(j,0,m+1)cout<<suf[i][j]<<' ';
	// 	puts("");
	// }
	F(i,0,x1+y1)F(j,0,n)F(k,0,x1)dp[i][j][k]=-1e9;
	F(k,2,x1+y1)F(Px,1,n)F(Qx,1,x1)if(k-Px<=m&&k-Qx<=y1){
		ll Py=k-Px,Qy=k-Qx,mx=-1e9;if(Py<1||Qy<1)continue;
		F(p,0,1)F(q,0,1)cmax(mx,dp[k-1][Px-p][Qx-q]);
		if(mx==-1e9)mx=0;
		if(Px==Qx)dp[k][Px][Qx]=mx+max(0,w[Px][Py]);
		else dp[k][Px][Qx]=mx+w[Px][Py]+max(0,w[Qx][Qy]);
	}
	F(k,2,x1+y1)F(Px,1,n)F(Qx,1,x1)if(Px==Qx)
		dp[k][Px][Qx]=-1e9;
	// cout<<dp[5][3][4]<<endl;
	F(k,2,x1+y1)F(Px,1,n)F(Qx,1,x1)if(k-Px<=m&&k-Qx<=y1){
		ll Py=k-Px,Qy=k-Qx,mx=-1e9;if(Py<1||Qy<1)continue;
		F(p,0,1)F(q,0,1)cmax(mx,dp[k-1][Px-p][Qx-q]);
		if(mx==-1e9)mx=0;
		if(Px==Qx)cmax(dp[k][Px][Qx],mx+w[Px][Py]);
		else cmax(dp[k][Px][Qx],mx+w[Px][Py]+max(0,w[Qx][Qy]));
	}
	F(k,2,x1+y1)F(Px,1,n)F(Qx,1,x1)if(k-Px>0&&k-Qx>0&&k-Px<=m&&k-Qx<=y1&&Px==Qx)
		cmax(ans,dp[k][Px][Qx]+suf[Px][k-Px]-w[Px][k-Px]);

	F(i,0,x1+y1)F(j,0,n)F(k,0,x1)dp[i][j][k]=-1e9;
	F(k,2,x1+y1)F(Px,1,n)F(Qx,1,x1)if(k-Px<=m&&k-Qx<=y1){
		ll Py=k-Px,Qy=k-Qx,mx=-1e9;if(Py<1||Qy<1)continue;
		F(p,0,1)F(q,0,1)cmax(mx,dp[k-1][Px-p][Qx-q]);
		if(mx==-1e9)mx=0;
		if(Px==Qx)dp[k][Px][Qx]=mx+max(0,w[Px][Py]);
		else dp[k][Px][Qx]=mx+w[Px][Py]+max(0,w[Qx][Qy]);
	}
	F(k,2,x1+y1)F(Px,1,n)F(Qx,1,x1)if(Px!=Qx)
		dp[k][Px][Qx]=-1e9;
	F(k,2,x1+y1)F(Px,1,n)F(Qx,1,x1)if(k-Px<=m&&k-Qx<=y1){
		ll Py=k-Px,Qy=k-Qx,mx=-1e9;if(Py<1||Qy<1)continue;
		F(p,0,1)F(q,0,1)cmax(mx,dp[k-1][Px-p][Qx-q]);
		if(mx==-1e9)mx=0;
		if(Px==Qx)cmax(dp[k][Px][Qx],mx+max(0,w[Px][Py]));
		else cmax(dp[k][Px][Qx],mx+w[Px][Py]);
	}
	F(k,2,x1+y1)F(Px,1,n)F(Qx,1,x1){
		if(k-Px>0&&k-Qx>0&&k-Px<=m&&k-Qx<=y1&&(Px!=Qx||(k!=x1+y1&&k==xk+yk&&Px==xk)))
			cmax(ans,dp[k][Px][Qx]+suf[Px][k-Px]-w[Px][k-Px]);
	}

	return cout<<ans,0;
}
```


---

## 作者：幽云蓝 (赞：6)

由于小波的原 std 被叉爆了所以自己写个题解给大家谢罪了。/kt

首先对恋恋预处理出数组 $f_{i,j}$ 代表从位置 $(i,j)$ 走到她的终点能获得的最大愉悦程度。这里不用考虑觉的影响。

如果假设觉和恋在一起行动（这是经典 trick），那么可以设计 dp 状态。$dp_{i,j,k}$ 代表觉和恋一起走了 $i$ 步，觉有 $j$ 步向左，恋有 $k$ 步向左的最大愉悦程度。但这看起来很不可做。我们考察觉和恋的移动过程。如果觉和恋分开，那么觉会收集愉悦程度为正数的物品，并在她们相遇时把这些物品都给恋。如果觉和恋相遇，那么觉会带走愉悦程度为负数的物品，并把它们在两人不在同一格子时丢弃掉。

麻烦的地方在于，你不知道觉和恋之后会不会相遇/离开，而觉的行动是依赖于这个的。我的思路是不妨首先假设觉一定能把物品带给恋恋/把负数物品带走。然后在觉和恋切换状态（即，相遇变成分离，分离变成相遇）时对答案进行统计。也就是说假设这步后恋一个人走到终点不受觉的影响，然后和 $ans$ 进行 $\text{chkmax}$。

注意特判一下，如果恋的终点可以到觉的终点，那么觉和恋都在恋的终点的这种状态也是合法的，和 $ans$ 也要 $\text{chkmax}$。

附一份代码，大约拍了 600 组。有 hack 可以私我。

```cpp
#include <bits/stdc++.h>
using namespace std;

int w[310][310];
long long dp[610][310][310];
long long f[310][310];
int e1_x, e1_y, e2_x, e2_y;

int satori_dis;
int koishi_dis;

bool chk(int xa, int ya, int xb, int yb){
	return xa <= e1_x && ya <= e1_y && xb <= e2_x && yb <= e2_y;
}

bool same(int xa, int ya, int xb, int yb){
	return xa == xb && ya == yb;
}

int main(){
//	freopen("1.in","r",stdin);
//    freopen("3.out","w",stdout);
	ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++){
			cin >> w[i][j];
		}
	cin >> e1_x >> e1_y >> e2_x >> e2_y;
	satori_dis = e1_x + e1_y - 2;
	koishi_dis = e2_x + e2_y - 2;
	int cangt = 0;
	if (satori_dis > koishi_dis && e1_x >= e2_x && e1_y >= e2_y){
		cangt = 1;//shaber xiaobo fnfnfnfnfnfn
	}
	for (int i = 0; i <= n; i++) for (int j = 0; j <= m; j++) f[i][j] = LONG_LONG_MIN;
	for (int i = e2_x; i >= 1; i--){
		for (int j = e2_y; j >= 1; j--){
			if (i == e2_x){
				if (j == e2_y) f[i][j] = w[i][j];
				else f[i][j] = w[i][j] + f[i][j + 1];
			}
			else{
				if (j == e2_y) f[i][j] = w[i][j] + f[i + 1][j];
				else f[i][j] = w[i][j] + max(f[i][j + 1], f[i + 1][j]);
			}
		}
	}
	for (int i = 0; i <= n + m; i++)
		for (int j = 0; j <= n; j++)
			for (int k = 0; k <= n; k++){
				dp[i][j][k] = LONG_LONG_MIN;
			}
	dp[0][0][0] = max(0, w[1][1]);
	long long ans = f[1][1];
	for (int i = 0; i <= min(satori_dis, koishi_dis) - 1; i++){
		for (int j = 0; j <= min(i, e1_x - 1); j++)
			for (int k = 0; k <= min(i, e2_x - 1); k++){
				for (int p = 0; p <= 1; p++)
					for (int q = 0; q <= 1; q++){
						int nxa = 1 + j + p;
						int nya = 1 + (i - j) + (1 - p);
						int nxb = 1 + k + q;
						int nyb = 1 + (i - k) + (1 - q);
						if (!chk(nxa, nya, nxb, nyb)) continue;
						int xa = 1 + j;
						int ya = 1 + (i - j);
						int xb = 1 + k;
						int yb = 1 + (i - k);
						if (same(xa, ya, xb, yb) != same(nxa, nya, nxb, nyb)){
							ans = max(ans, dp[i][j][k] + f[nxb][nyb]);
						}
						if (same(nxa, nya, nxb, nyb)){
							dp[i + 1][j + p][k + q] = max(dp[i + 1][j + p][k + q], dp[i][j][k] + max(0, w[nxa][nya]));
						}
						else{
							dp[i + 1][j + p][k + q] = max(dp[i + 1][j + p][k + q], dp[i][j][k] + max(0, w[nxa][nya]) + w[nxb][nyb]);
						}
					}
			}
	}
	if (cangt){
		ans = max(ans, dp[koishi_dis][e2_x - 1][e2_x - 1]);
	}
	cout << ans << endl;
	return 0;
}

```


---


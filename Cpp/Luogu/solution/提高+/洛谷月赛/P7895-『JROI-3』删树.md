# 『JROI-3』删树

## 题目背景

**本题数据已加强，建议场上过了的同学再次提交确定做法正确性。**

> 千万不要看错题！

——command_block 《考前小贴士》

你在 2021 年在洛谷打了一场比赛叫做 EZEC Round
 6，其中里面有一道[造树题](https://www.luogu.com.cn/problem/P7390)你觉得特别水，随手就切了它。（所以没做过链接里题的人快来做啊！！！）
 
现在你在打 JROI-3 的月赛，你觉得造树太水了想删掉树，于是良心的出题人给了你一个机会。但是，在删除树之前，djy 想先知道树的边权和。

## 题目描述

**这是一道交互题。**

有一个 $n$ 个节点的带边权的树，编号为 $1-n$。每个点的度数是已知的。djy 想知道树上所有边的权值和，但他太菜了，不会去算如此简单的问题，因此把这个题扔给了您。

由于您很强，所以您可以对这棵树进行一些改变：删除所有度数为 $1$ 的节点，得到剩下点的个数和每个点的度数。

您可以向交互库进行三种类型的提问：

- 对于当前树上存在的一个点，询问它的 dfs 序$^1$。
- 对于当前树上存在的一对节点，询问它们之间的距离$^2$。
- 删除当前树上所有度数为 $1$ 的节点，同时删除与这些节点相邻的边，并且将所有未被删除的节点进行重新编号。**保证剩下的节点的编号分别为 $1-k$，其中 $k$ 是剩下的节点个数。**

你需要操作**不超过 142 次（包括提交答案）**，并在树**删空**之前求出**当前**树上所有边的权值和。

---
注：
- dfs 序$^1$：dfs 序指从当前的 $1$ 号节点进行 [深度优先搜索](https://baike.baidu.com/item/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/5224976) ，每个节点被第一次访问的顺序。一棵树的 dfs 序不唯一。每次删除操作后 dfs 序会被重置。保证 dfs 序不随着其他操作而改变，即两次询问同一节点的 dfs 序的询问中间如果没有删除操作，保证回答相同的值。
- 距离$^2$：指在树上两点路径上的边权和。特别地，两个相同节点的距离为 $0$。

## 说明/提示

**样例仅供理解交互过程，可能不符合逻辑。**

【样例解释】

![](https://cdn.luogu.com.cn/upload/image_hosting/cpyygh22.png)

树的形态如上。

第一次询问节点 $1$ 的 dfs 序，为 $1$。

第二次询问节点 $2$ 与节点 $6$ 的距离，为 $5$。

当前树上所有边的边权和为 $17$。

-----
【数据范围】

**「本题采用捆绑测试」**
- Subtask 1（1pts）：$n \le 2$。
- Subtask 2（4pts）：$n \le 4$。
- Subtask 3（20pts）：$n\le 150$。
- Subtask 4（10pts）：树是一条链。
- Subtask 5（30pts）：保证度数为 $1$ 的点不超过 $50$ 个。
- Subtask 6（20pts）：$n\le 2000$。
- Subtask 7（15pts）：无特殊限制。

对于 $100\%$ 的数据，$1\le n\le 5000$，每条边的边权不大于 $10^5$ **且为正整数**。

**如果有假做法过了，请私信联系出题人加强数据。（如果有hack更好了）。**

## 样例 #1

### 输入

```
6
3 1 2 1 1 2

1

5

```

### 输出

```


dfn 1

dis 6 2

! 17```

# 题解

## 作者：mrsrz (赞：18)

令 $x$ 表示某时刻的叶结点个数。

我们的思路是，当 $x$ 较大的时候用 `del` 操作删叶子，当 $x$ 较小的时候不进行删叶子操作，直接求出当前的树的答案。

经过一些尝试，可以发现我们最多使用 $2x$ 次操作来得到答案。

我们先来证明一下 $2x$ 次操作是足够的。若当前还剩下 $k$ 次操作，我们需要 $1$ 次操作报告答案，因此剩下 $k-1$ 次操作可用。我们将其全部用于计算答案，那么此时叶子的个数最多为 $\lfloor\frac{k-1}2\rfloor$，若更多的话操作数将不够。也就是说，还剩 $k$ 次操作时，若选择删叶子，则至少删除 $\lfloor\frac{k-1}2\rfloor$ 个叶子。

可以发现：$\sum_{i=1}^{142}\left(\lfloor\frac{k-1}2\rfloor+1\right)\gt 5000$。因此这样是合理的。

于是我们只需要一个能够在 $2x$ 次操作以内求出有 $x$ 个叶子的树的边权和的做法。

令 $\mathrm{dist}(x,y)$ 表示点 $i$ 与 $j$ 的距离，$d_i$ 表示点 $i$ 的度数。

我们直接对每条边计算是没法做的，因为边数太多了。所以一次查询距离我们要得到很多边的信息。

我们尝试使用每个点到根的距离进行计算（之后默认将 $1$ 当做根）。经过一些推导和尝试，可以发现答案就是下面的式子：

$$
\sum_{i=2}^n \mathrm dist(1,i)\cdot(2-d_i)
$$

我们来证明一下这个东西。

对每条边考虑它被计算了几次。

定义 $S(u)$ 表示 $u$ 子树内的点集，$|S(u)|$ 表示 $S(u)$ 的大小，也就是 $u$ 的子树大小。

对于 $u$ 到它父亲的边，$u$ 子树内的点到根的路径上都包含这条边，因此它被计算的次数是 $\sum_{v\in S(u)}(2-d_v)$。

对于一个非根结点 $u$，它连向儿子的边数就是它的度数减一。而一棵 $n$ 个结点的树（$n\ge 1$）的点数恰好是边数加一。因此我们有 $|S(u)|=\sum_{v\in S(u)}(d_v-1)$。

然后我们再对之前的式子进行转化，可以得到：

$$
\sum_{v\in S(u)}(2-d_v)=\sum_{v\in S(u)}1-\sum_{v\in S(u)}(d_v-1)=|S(u)|-(|S(u)|-1)=1
$$

这说明了每条边的贡献恰好计算了 $1$ 次，于是我们用来计算答案的式子是对的。

利用这个式子，我们只需要对 $d_u\neq 2$ 的结点询问到 $1$ 的距离就可以得到答案。

对于一个有 $x$ 个叶子的有根树，它度数为 $2$ 的非根结点一定不在包含这 $x$ 个叶子的虚树上，而包含指定的 $x$ 个点的虚树最多有 $2x-1$ 个点。也就是说，度数不为 $2$ 的非根结点加上根结点以后也不超过 $2x-1$ 个点。由于一些性质，根结点一定在虚树上，而它的贡献是无需计算的，所以我们最坏只需要 $2x-2$ 次 `dis` 操作就能够得到答案。

标算需要 $2x$ 次操作，我的做法是比标算更优的。

**而且并不需要用到 `dfn` 操作**。

## Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
int k=142,n,deg[5005];
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;++i)cin>>deg[i];
	while(1){
		int t=0;
		for(int i=2;i<=n;++i)if(deg[i]!=2)++t;
		if(t<k){
			LL ans=0;
			for(int i=2;i<=n;++i)if(deg[i]!=2){
				LL v=0;
				cout<<"dis 1 "<<i<<endl;
				cin>>v;
				ans+=v*(2-deg[i]);
			}
			cout<<"! "<<ans<<endl;
			break;
		}else{
			cout<<"del"<<endl;
			--k;
			cin>>n;
			for(int i=1;i<=n;++i)cin>>deg[i];
		}
	}
	return 0;
}
```

---

## 作者：Odalys (赞：10)


> 一棵以 $1$ 为根的树，边权未知，你可以进行三种操作：
>
> 1. 询问一个点的 dfn
> 2. 询问一条路径上边权和
> 3. 删除所有度数为 $1$ 的点，并重标号
>    要求在 $142$ 次操作内得到当前树的边权总和。
>    $$n\le 5000$$

### Solution:

从[这题](https://www.luogu.com.cn/problem/CF176E)中，我们得到一个关于 dfn 的小 $trick$ ，就是若你知道一些关键点的 dfn ，那么这些关键点的生成子图边权和等于按 dfn 排序后相邻点距离加最后一个点与第一个点距离除以 $2$ 。
	
证明个人觉得还是十分简单的，考虑沿着 dfn 顺序，若为子树内节点则向下拉一条覆盖边，否则则向上拉到另一棵子树内，不难发现这样会一来一回经过生成子图上的边两次。	

然后在本题中，我们考虑找到一些关键点，使其生成子图为整棵树，那么不难发现取的这些关键点是根 $1$ + 所有叶子。

那么对于一个大小为 $s$ 的关键点集合，我们想要借以求出整棵树的边权和，需要 $2s$ 次询问， $s$ 次询问求集合 dfn ， $s$ 次询问求两两路径和。设当前剩余操作次数为 $cur$ ， 若 $2s \le cur - 1$ ，那就可以直接做了，否则我们需要删掉所有度数为 $1$ 的点直到 $2s \le cur - 1$ 为止。为什么可以直接删？因为当不满足条件时叶子数是大于 $cur \over 2$ 的，所以你每次起码会删掉大于 $cur \over 2$ 个叶子。而这题点数 $5000$ ，注意到 $71 + 70 + 70 + 69 + 69 + 68 +68 + \dots = 5041 > 5000$ ，所以一定会在删完前得到一组可以计算的答案。

```cpp
/* ==============================
 *  Author : Odalys 
 *
 *  Mail : minyuenu@gmail.com
 * =============================== */
#include <bits/stdc++.h>
using namespace std;
template <typename T> inline void read(T &a){
	T w=1; a=0;
	char ch=getchar();
	for(;ch < '0' || ch > '9';ch=getchar()) if(ch == '-') w=-1;
	for(;ch>='0'&&ch<='9';ch=getchar()) a=(a<<3)+(a<<1)+(ch^48);
	a*=w;
}
template <typename T> inline void ckmax(T &a, T b){a = a > b ? a : b;}
template <typename T> inline void ckmin(T &a, T b){a = a < b ? a : b;}
#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define pii pair<int, int> 
#define vi vector<int> 
#define Debug(x) cout << #x << " = " << x << endl
#define For(i,l,r) for (int i = l; i <= r; ++i) 
#define foR(i,l,r) for (int i = l; i >= r; --i)
#define mck fflush(stdin)
#define gra fflush(stdout)
const int N = 5050;
int du[N];
int n;
int ck () {
	int res = 0;
	For (i, 1, n) if (du[i] == 1) res++; 
	if (du[1] != 1) res++; 
	return res;
}
struct Node {
	int id, dfn;
	Node( int Id = 0, int Dfn = 0) {
		id = Id, dfn = Dfn;
	}
	bool operator < (const Node &x) const {
		return dfn < x.dfn;
	}
} s[N];
int Get (int x) {
	printf ("dfn %d\n", x); mck, gra;
	int xx; read(xx); return xx;
}
int Val (int x, int y) {
	printf ("dis %d %d\n", x, y); mck, gra;
	int xx; read(xx); return xx;
}
int main() {
	read(n);
	For (i, 1, n) read(du[i]);
	int rem = 142;
	while (ck() > (rem - 1) / 2) {
		printf ("del\n"); mck, gra;
		rem--;
		read(n);
		For (i, 1, n) read(du[i]); 
	}
	int cnt = 0;
	For (i, 1, n) 
		if (du[i] == 1) s[++cnt] = Node(i, Get(i)); 
	if (du[1] != 1) s[++cnt] = Node(1, 1);
	sort (s + 1, s + cnt + 1); 
	int Ans = 0;
	For (i, 1, cnt - 1) {
		Ans += Val(s[i].id, s[i + 1].id);
	}
	Ans += Val(s[cnt].id, s[1].id);
	printf ("! %d\n", Ans / 2); mck, gra;
	return 0;
}
```

---

## 作者：Tony102 (赞：6)

[Link](https://www.luogu.com.cn/problem/P7895)

[My Blog](https://tony102.com/archives/135/)

## Sol

赛时可以很 naive 地可以不停地 `del` 直到只有 $\leq 2$ 个点的时候问一下。

链的情况很好做对吧，只要找到链顶和链尾问一下距离就可以了。

至于树，但是你想想怎么优化一下这个过程，树均匀的情况下叶子应该是有不少的，那么每次只要 `del`  之后看一下是不是成一条链了，是链了就套用链的做法。这样可以获得 85 分。

考虑怎么做到 100 分，我们每次把叶子抠出来，然后按照 dfs 序排序，若叶子数 + `del` 数 $\leq $ 140 的话，可以直接询问两个相邻叶子之间的距离，注意最后一个要和第一个一起问。否则就不断 `del` 直到满足该条件。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef vector < int > vec;
const int SIZE = 5e3 + 5;

int n;
vec deg, leaf;

int io() {
    fflush(stdout);
    std::cin >> n;
    deg.resize(n + 1); deg.clear();
    for (int i = 1; i <= n; ++ i) std::cin >> deg[i];
    return n > 2;
}

namespace chain {
    int s = 0, t = 0;    
    int judge() {
        int cnt1 = 0, cnt2 = 0;
        for (int i = 1; i <= n; ++ i) {
            if (deg[i] == 1) ++ cnt1;
            if (deg[i] == 2) ++ cnt2;
        }
        if (cnt1 == 2 && cnt2 == n - 2) {
            s = 0, t = 0;
            for (int i = 1; i <= n; ++ i) {
                if (deg[i] == 1 && !s) s = i;
                else if (deg[i] == 1 && s)  { t = i; break; }
            }
            return 1;
        }
        else return 0;
    }
    void main() {
        std::cout << "dis " << s << " " << t << endl;
        fflush(stdout);
        int ans; std::cin >> ans;
        std::cout << "! " << ans << endl;
        fflush(stdout);
    }
}

namespace subtask1 {
    void main() {
        if (n == 1 || n == 0) return puts("! 0"), void();
        puts("dis 2 1");
        fflush(stdout);
        int ans; scanf("%d", &ans);
        printf("! %d\n", ans);
        fflush(stdout);
    }
}

namespace subtask2 {
    void main() {
        int flag = 1;
        do {
            puts("del");
            fflush(stdout);
            flag = io();
            if (!flag) break;
            if (chain::judge()) return chain::main(), void();
        } while (flag);
        return subtask1::main(), void();
    }
}

vec dfn;
namespace sol {
    int getLeaf() {
        leaf.clear();
        for (int i = 1; i <= n; ++ i) {
            if (deg[i] == 1) leaf.emplace_back(i);
        }
        return (int) leaf.size();
    }

    int check() {
        int N = leaf.size();
        dfn.clear(); dfn.resize(n + 1);
        for (int i = 0, x; i < N; ++ i) {
            std::cout << "dfn " << leaf[i] << endl;
            fflush(stdout); std::cin >> x;
            dfn[leaf[i]] = x;
        }
        return N;
    }

    int get() {
        int N = check(), ans = 0, x = 0;
        std::sort(leaf.begin(), leaf.end(), [] (int a, int b) { return dfn[a] < dfn[b]; });
        for (int i = 0; i < N - 1; ++ i) {
            std::cout << "dis " << leaf[i] << " " << leaf[i + 1] << endl;
            fflush(stdout); std::cin >> x; ans += x;
        }
        std::cout << "dis " << leaf[0] << " " << leaf[N - 1] << endl;
        fflush(stdout); std::cin >> x; ans += x;
        return ans / 2;
    }

    void sol() {
        int ans = get();
        std::cout << "! " << ans << endl;
    }

    void main() {
        int dl = 0, N = getLeaf();
        if (2 * N + dl <= 140) return sol(), void();
        while (n) {
            if (2 * N + dl <= 140) return sol(), void();
            else {
                ++ dl; leaf.clear();
                std::cout << "del" << endl;
                fflush(stdout);
                io(); 
                if (chain::judge()) return chain::main(), void();
                else N = getLeaf();
            }
        }
    }
}

int main() {
    // freopen("code.in", "r", stdin);
    io();
    // return subtask2::main(), 0;
    if (n <= 2) return subtask1::main(), 0;
    if (n <= 2000) return subtask2::main(), 0;
    else return sol::main(), 0; 
    return 0;
}
```

---

## 作者：lndjy (赞：5)

官方题解

考虑通过询问叶子节点得到权值和。

先询问所有叶子节点的 dfs 序，然后从小到大排序。

然后询问第 $i$ 个和第 $i+1$ 个的距离，特别的，定义第 $n+1$ 个叶子是第 $1$ 个。

得到的距离和除以 $2$ 就是权值和。

证明：考虑每个边的贡献，正好被这些路径覆盖两次。

对叶子个数分治，叶子节点较少时执行以上算法，较多时删除。

交互次数证明：

设当前叶子个数为 $B$。

询问次数为 $T(n)=\min(T(n-B)+1,2B+1)$。分别对应删除和求出。

提前预处理出每个 $n$ 分治的界即可。通过写程序 dp 可以发现上界是 $141$。

更简单的方法是直接判断是否到 $142$ 次，超过 $142$ 次时删除。


---

## 作者：Daidly (赞：4)

**结论**：

在一棵树中，所有相邻叶子节点的距离和等于二倍边权和。

形式化的说：

对于一棵带权有根树，记根为 $1$，$S_i$ 为以 $i$ 为根的子树边权和，叶子节点为 $l_1$ 到 $l_m$ 且 $l_{m+1}=l_1$，使得 ${\rm{dfn(l_1)}}<{\rm{dfn(l_2)}}<\dots<{\rm{dfn(l_m)}}$，则：

$$\sum_{i=1}^m{\rm{dist(l_i,l_{i+1})}}=2S_1$$

**证明**：

记所有叶子节点的父节点去重后为 $f_1$ 到 $f_k$，设 $f_i$ 所包含的叶子节点为 $l_{x_i}$ 到 $l_{y_i}$，也可以说 $f_i$ 所包含的叶子节点的下标 $\in[x_i,y_i]$，$w_{i,j}$ 为 $i$ 和 $j$ 之间连边的权值。

如下图，叶子节点为 $5,6,7,8,9,10,11$，所有叶子节点的父节点去重后为 $1,3,4$。

- 如果 $l_i$ 和 $l_{i+1}$ 的父节点是同一个，即都在以 $f_j$ 为根的子树内：

这就好办了，可以将这个子树单拎出来算边权，这个子树的形状就是一个菊花图，菊花图内相邻叶子节点的距离和（不算菊花图中第一个点到最后一个点的距离）就是 $2S_{f_i}-w_{f_i,l_{x_i}}-w_{f_i,l_{y_i}}$。

- 如果 $l_i$ 和 $l_{i+1}$ 的父节点不是同一个呢？

可以把菊花图（以 $f_i$ 为根的子树）中第一个点到最后一个点的距离算上，即为 $2S_{f_i}$，然后把这棵子树看成一个点，这个点就变成了叶子节点。

那么 ${\rm{dis(l_{x_i-1},l_{x_i})}}$ 和 ${\rm{dis(l_{y_i},l_{y_i+1})}}$ 就可以通过 $w_{f_i,l_{x_i}}$ 和 $w_{f_i,l_{y_i}}$ 以及“缩点”后的叶子节点的距离一次一次迭代算出。

到了最后，整棵树变成了一个点，而这个点就代表着 $\sum_{i=1}^m{\rm{dist(l_i,l_{i+1})}}$，而经过上面的论证，这就等于 $2S_1$。

可以发现这个过程和 `del` 很像。

![](https://cdn.luogu.com.cn/upload/image_hosting/gvd67zjm.png)



------------

还可以用数学归纳法证明，这里不再赘述。

结论证完了，**回到题目**：

若一棵树叶节点数为 $m$，记剩余询问次数为 $t$，这里去掉输出的一次（即初始值为 $141$）。

- 若 $t\ge2m$，则用 $m$ 次操作询问 ${\rm{dfn(l_i)}}$，然后排序，最后询问 $m$ 次 ${\rm{dist}}$，共 $2m$ 次，按照上面结论计算出答案，除以 $2$ 输出即可。

- 若 $t<2m$，用 `del` 操作消除 $m$ 个叶子节点，然后重新标号，并且 `t--`，更新 $m$。

**正确性**：

发现一旦 $t\ge2m$ 就能通过上面的方法求出答案，考虑能不能被 `hack`。

想要证明上面的解法是错的，唯一的方法就是证明有一组数据可以使 $t<2m$ 一直成立。

- 结论：删去入度为一的点的的个数不增。

也就是：第一次 `del` 删去 $k$ 个点，往后继续 `del`，每次删去点数不可能大于 $k$。

应该是树的特殊性质吧。

所以这组想卡掉上面做法的数据最好形如很多条链的链顶被一个点连接起来的样子：

![](https://cdn.luogu.com.cn/upload/image_hosting/986telba.png)

一直成立？这个链长怎么确定？

$t<2m$

$t$ 怎么变化？每 `del` 一次减一。

$m$ 怎么变化才能使**带有系数** $2$ 的 $2m>t$？

只需要让每两次 `del` $m$ 减少 $1$ 即可。

可以构造出这样一组数据：

很多条链，链长呈等差数列，公差为 $2$。

接下来就要用计算算出这个数据了：

设 最后一条链长 $2x+k$，有 $x$ 条链，链上总点数为 $4999$（去掉链接链的点）。

由于最后一条链可能会有剩余，取整。

$\frac{(2+2x)x}{2}=4999$，解一元二次方程的正根取整得 $70$。

可算出 $k=4999-\frac{(2+138)\times69}{2}-140=29$。

所以链长为 $2,4,6,8...136,138,169$

这会使用 `del` 多少次呢？

发现到当使用 `del` $136$ 次后，$t=141-136=5>2m=2\times2=4$，停止 `del`，可以计算出答案，最终会使用 $141$ 次操作（包括输出）。

所以题目中的 $142$ 次是放宽了的。

可以证明没有比上面那组数据更能卡上面的算法了，所以正确性得以证明。

小提一嘴：这个正确性的证明不是很严谨，但思路大概是对的：证明最坏情况无法使结论错误，大家可以就当一个极限数据看看。

- 如果您觉得本题解还不错的话就点个赞呗，谢谢大家！

**代码如下**：

```cpp
#include<bits/stdc++.h>
using namespace std;

inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}

inline void print(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)print(x/10);
	putchar(x%10^48);
}

const int MAXN=5e3+5;
int t=141,n,in[MAXN];

int dfn(int x){
	cout<<"dfn "<<x<<endl;
	int ans=read();
	return ans;
}

int dis(int x,int y){
	cout<<"dis "<<x<<" "<<y<<endl;
	int ans=read();
	return ans;
}

void del(){
	cout<<"del"<<endl;
}

int num,sum,b[MAXN];

struct node{
	int x,y;
}p[MAXN];

bool cmp(node p,node q){
	return p.x<q.x;
}

int main(){
	n=read();
	for(int i=1;i<=n;++i)in[i]=read();
	for(int i=1;i<=n;++i){
		if(in[i]==1)num++;
	}
	while(2*num>t){
		del();
		t--;
		n=read();
		num=0;
	    for(int i=1;i<=n;++i)in[i]=read();
		for(int i=1;i<=n;++i){
		    if(in[i]==1)num++;
	    }
	}
	num=0;
	for(int i=1;i<=n;++i){
		if(in[i]==1){
			++num;
			p[num].x=dfn(i);
			p[num].y=i;
		}
	}
	sort(p+1,p+num+1,cmp);
	for(int i=1;i<num;++i){
		sum+=dis(p[i].y,p[i+1].y);
	}
	sum+=dis(p[1].y,p[num].y);
	cout<<"! ",print(sum>>1),cout<<endl;
	return 0;
}
```

---

## 作者：wf1594937223 (赞：2)

好题啊！~~让我体验了一把div1rk2~~

开局看了看T1没思路，就开始看T2

~~一开始还以为T2错了~~

然后想了想142是什么意思……开始以为是log的多少倍，后来才想到和根号关系比较密切……

本文中“叶子”均指度数为1的点。

---

看到这里有个dfn序，有求距离，然后又告诉你度数，求的是树边权和，很自然的想到一个trick：

按dfn序(1-n)排序，答案就是 $\dfrac{dis(1,2)+dis(2,3)+...+dis(n,1)}{2}$

证明：考虑因为是dfn序，所以一条边必定会且仅会被扫到两次（进这个子树，出这个子树）

然后题目给出删叶子，根号的次数也提醒我们：可以边删边判断是否可做；当叶子个数 $\le \lfloor \dfrac{remain}{2} \rfloor$ 时，我们可以直接求解；否则我们考虑删掉这些叶子，这样做一定是可行的。

接下来用反证法证明：如果要卡，那么一定是每一次删的叶子尽可能少，而这些叶子个数 $> \lfloor \dfrac{remain}{2} \rfloor$，所以最多需要删 $71+71+70+70+...+1+1 =5112$ 个点，不符合 $n \le  5000$，证毕。

---

彩蛋：关于最大可能的n：

我们容易发现，在叶子个数 $= 3$ 时，我们只需要三次询问即可；在叶子个数 $= 2$ 时，我们只需要一次询问即可；在叶子个数 $= 1$ 时，我们甚至不需要问。

因此，在题目的条件下，我们其实可以做 $71+71+...+4+4+4+4+4+3+3+1 = 5119$ 个点。

~~体现了良心出题人本质~~

有锅欢迎联系作者~

---

## 作者：bunH2O (赞：1)

[P7895 『JROI-3』删树](https://www.luogu.com.cn/problem/P7895)

近几场中最良心的一个D

~~开始把题看错了还以为是要求最开始的树的边权和还在想为什么要删点QwQ~~

-------------

此题用到了一个小trick，想不到的话就过不了这题。形式大概如下：

给定一棵树，其中所有度数为 $\texttt{1}$ 的点按 $\texttt{dfn}$ 值从小到大排成一个**环**后，相邻的两个点的距离之和刚好等于边权和的**两倍**。

这里给一个不算严谨的证明：

![](https://cdn.luogu.com.cn/upload/image_hosting/rxq2u23l.png)

考虑 $\texttt{1-2}$ 这条边。

- 显然子树 $\texttt{1}$ 之内必然有度数为 $\texttt{1}$ 的点，子树 $\texttt{2}$ 同理。

- 而由于所有度数为 $\texttt{1}$ 的点分布呈**环状**，所以必然**有且仅有**一条路径从子树 $\texttt{1}$ 到子树 $\texttt{2}$ ，同理也必然**有且仅有**一条路径从子树 $\texttt{2}$ 到子树 $\texttt{1}$ ，共计算两次。

同理，对于任意一条边，都会只经过两次。

------------

有了这个结论，我们就可以通过查询叶子节点的 $\texttt{dfn}$ 值和距离来得到结果。

我们假设此时度数为 $\texttt{1}$ 的点的个数为 $m$ ，则我们可以通过 $2m+1$ 次操作完成。即 $m$ 次 $\texttt{dfn}$ , $m$ 次 $\texttt{dis}$ , 以及 $1$ 次输出。 而通过简单的思考可得，每一次**删除操作**后度数为 $\texttt{1}$ 的点必然会**保持不增**。所以我们可以通过简单的判断得到何时应该**删除操作**。

具体内容可以参照代码。

-----------

关于正确性的证明：可以参照[官方题解](https://djy-juruo.blog.luogu.org/solution-p7895)，这里给一个简单的证明。

- 不难发现，若第一次进行删除，这就代表着第一层度数为 $\texttt{1}$ 的点至少有 $\texttt{71}$ 个。

- 同理，若第 $i$ 次进行删除，则第 $i$ 层度数为 $\texttt{1}$ 的点至少有 $\left\lceil\dfrac{142-i}{2}\right\rceil$ 个。

- 若该算法错误，则该树至少有 $71+70+70+69+69+......+1+1=5041$ 个结点，而该题中 $n\leq5000$ 。

因此该算法的正确性可以得到保证。

-----------

------------

Code:（码风不喜勿喷）

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cassert>
using namespace std;
typedef long long ll;
struct Node
{
	ll dfn;
	ll pos;
}tree[5001];
ll a[10001],n,cnt,ans;
void erase() // 删除操作 
{
	cout<<"del"<<endl;
	cout.flush();
	cin>>n;
	memset(a,0,sizeof(a));
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
}
void getdfn(ll u) // 求dfn 
{
	cout<<"dfn "<<u<<endl;
	cout.flush();
	cin>>tree[++cnt].dfn;
	tree[cnt].pos=u;
}
void getdis(ll u,ll v) // 求dis 
{
	cout<<"dis "<<tree[u].pos<<" "<<tree[v].pos<<endl;
	cout.flush();
	ll res;
	cin>>res;
	ans+=res;
}
void print() // 输出 
{
	cout<<"! "<<ans/2<<endl;
	cout.flush();
}
bool cmp(Node x,Node y)
{
	return x.dfn<y.dfn;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int j=0;;j++)
	{
		memset(tree,0,sizeof(tree));
		if(n==1){print();break;}
		cnt=0;
		for(int i=1;i<=n;i++)if(a[i]==1)cnt++;
		if(cnt*2+j+1>142){erase();continue;} // 简单的判断 
		cnt=0;
		for(int i=1;i<=n;i++)if(a[i]==1)getdfn(i);
		sort(tree+1,tree+cnt+1,cmp);
		for(int i=1;i<cnt;i++)getdis(i,i+1);
		getdis(cnt,1);
		print();break;
	}
	return 0;
}
```


---

## 作者：vectorwyx (赞：1)

如果树的规模较大，在规定次数内得到答案显然是困难的。注意到 $3$ 操作是删掉所有叶子，恰好能减小树的规模。所以一个初步的思路是先不断删点，直到某一次所能删的点数较少，即叶子数较少时再采用某种策略问出答案。

怎么利用叶子数较少这一性质问出答案呢？有一个结论是如果把所有叶子按照 dfs 序排序，那么 $\frac{\sum_{i=1}^{cnt}dis(a_i,a_{i+1})}{2}$ 即为整棵树的权值和，其中 $cnt$ 为叶子数，$a_i$ 表示 dfs 序第 $i$ 小的叶子，特别地，$a_{cnt+1}=a_1$。

我们可以从欧拉序的角度来理解这个结论。欧拉序是从根出发，按 dfs 的顺序绕树一圈再回到根结点，到达某个点或离开某个点时把该点记录下来得到的序列。

![](https://cdn.luogu.com.cn/upload/image_hosting/5vxpf0tm.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

上图就是一个欧拉序的实例，不难发现它会恰好经过每条边两次，dfs 序实际上是欧拉序只保留到达时记录的点所得到的结果。而对叶子来说，到达即离开，因此$dis(a_i,a_i+1)$ 其实就是在模拟到达一个叶子后离开前往下一个叶子的过程，那么  $\sum_{i=1}^{cnt}dis(a_i,a_{i+1})$ 就是整个环游的过程，它会把每条边都经过恰好两次，除以 $2$ 就是只经过一次的结果，即树的边权和。

这样当树的规模为 $n$，叶子数为 $cnt$ 时交互次数为 $T(n)=min(T(n-cnt)+1,2cnt+1)$，可以拿 dp 暴力解一下，不多不少刚刚好。

代码如下（码字不易，点个赞再走好不好QAQ）：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
#include<queue>
#include<map>
#define pii pair<int,int>
#define pb push_back
#define sml(x,y) (x=min(x,y))
#define big(x,y) (x=max(x,y))
#define ll long long
#define db double
#define fo(i,x,y) for(int i=x;i<=y;++i)
#define go(i,x,y) for(int i=x;i>=y;--i)
using namespace std;
inline int read(){int x=0,fh=1; char ch=getchar(); while(!isdigit(ch)){if(ch=='-') fh=-1; ch=getchar();} while(isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0'; ch=getchar();} return x*fh;}
inline void out(int *a,int l,int r){fo(i,l,r) printf("%d ",*(a+i));puts("");}

const int N=5005;
int n,a[N],top,d[N],dfn[N],dis[N],res=142;

int qdfn(int x){
	res--;
	printf("dfn %d\n",x);
	cout.flush();
	return read();
} 

int qdis(int x,int y){
	res--;
	printf("dis %d %d\n",x,y);
	cout.flush();
	return read();
}

void qdel(){
	res--;
	puts("del");
	cout.flush();
	n=read();
	fo(i,1,n) d[i]=read();
	return;
}

bool cmp(int x,int y){return dfn[x]<dfn[y];} 

int main(){
	cin>>n;
	fo(i,1,n) d[i]=read();
	while(1){
		top=0;
		fo(i,1,n) if(d[i]==1) a[++top]=i;
		if(top*2+1<=res){
			int ans=0;
			fo(i,1,top) dfn[a[i]]=qdfn(a[i]);
			sort(a+1,a+1+top,cmp);
			a[top+1]=a[1]; 
			fo(i,1,top) ans+=qdis(a[i],a[i+1]);
			printf("! %d",ans/2);
			return 0;
		}else qdel();
	}
	return 0;
}
/*
-------------------------------------------------
*/
```



---

## 作者：云浅知处 (赞：0)

注意到一个结论：

>对于一棵有根树 $T$，设其所有叶子结点为 $L_1,L_2,\cdots,L_m$。

>记 $S$ 为树上所有边边权之和，若 $\text{DFN}(L_1)<\text{DFN}(L_2)<\cdots<\text{DFN}(L_m)$，则 

> $$2S=\sum_{i=1}^m\text{dist}(L_i,L_{i+1})\tag{\#}$$

> 其中 $\text{DFN}(u)$ 表示 $u$ 的 dfs 序，$\text{dist}(u,v)$ 表示 $u,v$ 间路径上所有边的边权之和，$L_{m+1}=L_1$。

其中的道理不难讲：我们考虑一条边 $(u,v)$ 在答案中的系数。不妨设 $u$ 为 $v$ 的父节点，由于叶子节点按照 dfs 序升序排列，因此 $v$ 子树内的叶子结点必然是原来这些叶子结点的一个子区间。

具体来说，存在 $x,y$ 使得 $L_{x},L_{x+1},\cdots,L_{y}$ 在 $v$ 的子树内，而其他的叶子结点在 $v$ 的子树外。因此，只有计算 $\text{dist}(L_{x-1},L_x)$ 以及 $\text{dist}(L_{y},L_{y+1})$ 时会计算到 $(u,v)$ 这条边。换言之，每条边的边权在 $\text{(\#)}$ 式中的系数均为 $2$，这也就证明了结论。

由上述结论，设叶节点的个数为 $m$，我们先用 $m$ 次操作问出来所有叶节点的 dfs 序并依此排序，然后询问 $m$ 次 $\text{dist}$ 即可，所需操作次数为 $2m$。

因此，设剩余的操作次数为 $t$（初始为 $142$），叶节点数为 $m$，我们考虑以下的算法：

- 若 $2m\le t$，那么直接按照上面的询问一遍并输出答案。
- 若 $2m>t$，那么进行一次 `del` 操作，将 $t$ 减去 $1$，并更新 $m$。

关于这样做的正确性（操作次数必然不超过限制），其实从 $142$ 这个数就已经可以看出来了：

> $$2\left\lfloor\sqrt{5000}\right\rfloor+1=141$$

注意到这点后，算法正确性的证明已经呼之欲出了。~~留做习题~~

```cpp
#include<bits/stdc++.h>

#define int long long

using namespace std;

inline int read(){
    int x=0,f=1;char c=getchar();
    for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
    for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
    return x*f;
}

const int MN=5005;
int n;

struct Node{
    int dfn,id;
    Node(int D,int I):dfn(D),id(I){}
    Node(){}
};
Node val[MN];

bool cmp(Node x,Node y){return x.dfn<y.dfn;}

int cnt;
void init(){
    cin>>n;cnt=0;
    for(int i=1;i<=n;i++)if(read()==1)val[++cnt]=Node(0,i);
}

signed main(void){

    init();int t=142;
    while(cnt*2>=t){
        cout<<"del"<<endl;
        t--,init();
    }
    for(int i=1;i<=cnt;i++){
        cout<<"dfn "<<val[i].id<<endl;
        val[i].dfn=read();
    }
    sort(val+1,val+cnt+1,cmp);
    cout<<"dis "<<val[1].id<<" "<<val[cnt].id<<endl;
    int ans=read();
    for(int i=1;i<cnt;i++){
        cout<<"dis "<<val[i].id<<" "<<val[i+1].id<<endl;
        ans+=read();
    }
    cout<<"! "<<ans/2<<endl;

    return 0;
}
```

---


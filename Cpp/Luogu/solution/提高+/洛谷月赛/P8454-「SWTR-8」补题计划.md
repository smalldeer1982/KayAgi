# 「SWTR-8」补题计划

## 题目背景

因为写博客，小 A 欠下了很多题没有补。

## 题目描述

小 A 一共有 $n$ 道题目没有补。评估后，他认为第 $i$ 题的难度为 $x_i$。

同时，他对自己的水平有评估值 $w$。他的水平会波动，因此 $w$ 会改变。

小 A 认为补难度和自己水平相近的题目（相差不超过 $b_1$）能带来收益 $inc$；相反，如果相差过大（相差超过 $b_2$）则浪费了时间，导致负收益 $dec$。因此，补第 $i$ 道题的收益为

$$
\begin{cases}
inc & |x_i - w| \leq b_1 \\
0 & b_1 < |x_i - w| \leq b_2 \\
dec & |x_i - w| > b_2 \\
\end{cases}
$$

保证 $b_1 \leq b_2$ 且 $dec < 0 < inc$。

此外，小 A 有一些喜欢和讨厌的题。如果他没有补任何喜欢的题，或补了任何讨厌的题，就会不高兴。

小 A 将选择一段编号连续的题目进行补题。他希望补每道题的收益之和最大，并且补完题目后不会不高兴。请你告诉他这个最大值。

**任意询问之间独立**。

## 说明/提示

**「样例解释」**

$w = 1$ 时，每道题目的收益分别为 $2, 2, -3, 0, -3, 2, 2$。

第一次询问必须要补第 $4$ 题，不能补第 $3$ 题，最优方案为 $[4, 7]$，收益为 $1$。

第二次询问必须要补第 $3$ 题或第 $4$ 题，最优方案为 $[1, 7]$，收益为 $2$。

第三次询问必须要补第 $2$ 题或第 $4$ 题，最优方案为 $[1, 2]$，收益为 $4$。

$w = 1064$ 时，所有题目的收益均为 $-3$。

第四次询问必须要补第 $1$ 题，最优方案为 $[1, 1]$，收益为 $-3$。

$w = 5$ 时，每道题目的收益分别为 $-3, -3, 2, 2, 0, 0, 0$。

第五次询问必须要补第 $2$ 题或第 $7$ 题，不能补第 $4$ 题和第 $6$ 题，最优方案为 $[7, 7]$，收益为 $0$。

**「数据范围与约定」**

**本题采用捆绑测试**。

- Subtask #1（7 points）：$n, q\leq 100$。
- Subtask #2（12 points）：$n, q\leq 500$。依赖 Subtask #1。
- Subtask #3（20 points）：$n, q\leq 4 \times 10 ^ 3$。依赖 Subtask #2。
- Subtask #4（25 points）：$w, x_i \leq 100$。
- Subtask #5（11 points）：$l = 1$，$h = 0$。
- Subtask #6（15 points）：$w, x_i \leq 10 ^ 5$。依赖 Subtask #4。
- Subtask #7（10 points）：无特殊限制。依赖 Subtask #3，#5，#6。

对于 $100\%$ 的数据：

- $1\leq n, q \leq 10 ^ 5$。
- $0\leq w, x_i \leq 10 ^ 9$，$0\leq b_1 \leq b_2$ 且 $b_2$ 不大于 $w, x_i$ 上界的一半。
- $-10 ^ 4 \leq dec < 0 < inc \leq 10 ^ 4$。
- $1\leq l, il_i, ih_j \leq n$，$0 \leq h < n$，$l + h\leq 5$。
- 保证 $il$，$ih$ 递增，且一组询问每个下标至多出现一次。

**「帮助与提示」**

请注意 IO 优化。

**「题目来源」**

- [Sweet Round 8](https://www.luogu.com.cn/contest/73382) C
- Idea & Solution：[tzc_wk](https://www.luogu.com.cn/user/115194)。
- Tester：[Alex_Wei](https://www.luogu.com.cn/user/123294) & [chenxia25](https://www.luogu.com.cn/user/138400)。

## 样例 #1

### 输入

```
0
7 7 1 2 3 2 -3
1 0 6 4 8 2 2
1 1 1
4
3
1 2 0
3 4

1 2 0
2 4

2 1064
1 1 0
1

2 5
1 2 2
2 7
4 6```

### 输出

```
1
2
4
-3
0```

# 题解

## 作者：Alex_Wei (赞：6)

> [P8454 「SWTR-8」补题计划](https://www.luogu.com.cn/problem/P8454)

### 题目描述

小 A 一共有 $n$ 道题目没有补。评估后，他认为第 $i$ 题的难度为 $x_i$。

同时，他对自己的水平有评估值 $w$。他的水平会波动，因此 $w$ 会改变。

小 A 认为补难度和自己水平相近的题目（相差不超过 $b_1$）能带来收益 $inc$；相反，如果相差过大（相差超过 $b_2$）则浪费了时间，导致负收益 $dec$。因此，补第 $i$ 道题的收益为

$$
\begin{cases}
inc & |x_i - w| \leq b_1 \\
0 & b_1 < |x_i - w| \leq b_2 \\
dec & |x_i - w| > b_2 \\
\end{cases}
$$

保证 $b_1 \leq b_2$ 且 $dec < 0 < inc$。

此外，小 A 有一些喜欢和讨厌的题。如果他没有补任何喜欢的题，或补了任何讨厌的题，就会不高兴。

小 A 将选择一段编号连续的题目进行补题。他希望补每道题的收益之和最大，并且补完题目后不会不高兴。请你告诉他这个最大值。

### 数据范围

- Subtask #1（7 points）：$n, q\leq 100$。
- Subtask #2（12 points）：$n, q\leq 500$。依赖 Subtask #1。
- Subtask #3（20 points）：$n, q\leq 4 \times 10 ^ 3$。依赖 Subtask #2。
- Subtask #4（25 points）：$w, x_i \leq 100$。
- Subtask #5（11 points）：$l = 1$，$h = 0$。
- Subtask #6（15 points）：$w, x_i \leq 10 ^ 5$。依赖 Subtask #4。
- Subtask #7（10 points）：无特殊限制。依赖 Subtask #3，#5，#6。

对于 $100\%$ 的数据：

- $1\leq n, q \leq 10 ^ 5$。
- $0\leq w, x_i \leq 10 ^ 9$，$0\leq b_1 \leq b_2$ 且 $b_2$ 不大于 $w, x_i$ 上界的一半。
- $-10 ^ 4 \leq dec < 0 < inc \leq 10 ^ 4$。
- $1\leq l, il_i, ih_j \leq n$，$0 \leq h < n$，$l + h\leq 5$。
- 保证 $il$，$ih$ 递增，且一组询问每个下标至多出现一次。

### Sol 1

考虑 $n, q \leq 500$。

容易发现，讨厌的题将序列割成若干连续段。连续段之间独立，因此单独考虑一个连续段。

对于当前区间 $[l, r]$，枚举其所有子区间，检查是否有喜欢的题落在其中并更新答案。

时间复杂度 $\mathcal{O}(n ^ 2q)$。

### Sol 2

考虑 $n, q \leq 4\times 10 ^ 3$。

注意到对于每个位置，合法的右端点形成一段区间 $[l, r)$，从 $p$ 右边第一个喜欢的题 $l$ 开始，第一个讨厌的题 $r$ 结束。

将区间求和差分转化为端点最值，每次改变 $w$ 时暴力重新求前缀和，区间最值用线段树或 ST 表维护。

时间复杂度 $\mathcal{O}(nq \log n)$。

### Sol 3

考虑 $x_i, w \leq 100$。

回答询问考虑直接枚举包含的喜欢的题，则对应的合法区间左右端点均为一段区间（被讨厌的题所限制）。区间查询前缀和最大最小值即可。

可能的 $w$ 仅有 $100$ 种取值。对每种 $w$ 的取值的对应序列建线段树维护之。

时间复杂度 $\mathcal{O}(nw + q\log n)$。

### Sol 4

考虑正解。

当 $w$ 从 $1$ 增大到 $10 ^ 9$ 时，仅有 $\mathcal{O}(n)$ 次改变某个位置上的贡献的操作。

单点修改相当于对前缀和区间修改，将所有询问离线回答，用线段树维护区间加法区间最值。

时间复杂度 $\mathcal{O}(n(l\log n + h))$，空间复杂度线性。

### 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;
bool Mbe;
constexpr int N = 1e5 + 5;
int S, n, q, w, b1, b2, inc, dec;
struct event {
  int type, x, id, dt;
  bool operator < (const event &rhs) {
    if(x != rhs.x) return x < rhs.x;
    return type < rhs.type;
  }
} c[N * 5];
int cnt, ans[N];
vector<int> l[N], h[N];
int laz[N << 2], mx[N << 2], mn[N << 2];
void tag(int x, int v) {laz[x] += v, mx[x] += v, mn[x] += v;}
void down(int x) {if(laz[x]) tag(x << 1, laz[x]), tag(x << 1 | 1, laz[x]), laz[x] = 0;}
void push(int x) {
  mx[x] = max(mx[x << 1], mx[x << 1 | 1]);
  mn[x] = min(mn[x << 1], mn[x << 1 | 1]);
}
void build(int l, int r, int x) {
  if(l == r) return mx[x] = mn[x] = ::dec * l, void();
  int m = l + r >> 1;
  build(l, m, x << 1), build(m + 1, r, x << 1 | 1);
  push(x);
}
void modify(int l, int r, int ql, int qr, int x, int v) {
  if(ql <= l && r <= qr) return tag(x, v);
  int m = l + r >> 1;
  down(x);
  if(ql <= m) modify(l, m, ql, qr, x << 1, v);
  if(m < qr) modify(m + 1, r, ql, qr, x << 1 | 1, v);
  push(x);
}
int query(int l, int r, int ql, int qr, int x, int type) {
  int ans = type ? -1e9 : 1e9;
  if(ql > qr) return ans;
  if(ql <= l && r <= qr) return type ? mx[x] : mn[x];
  int m = l + r >> 1;
  down(x);
  if(ql <= m) ans = query(l, m, ql, qr, x << 1, type);
  if(m < qr) {
    int v = query(m + 1, r, ql, qr, x << 1 | 1, type);
    ans = type ? max(ans, v) : min(ans, v);
  }
  return ans;
}
bool Med;
int main() {
  fprintf(stderr, "%.3lf\n", (&Mbe - &Med) / 1048576.0);
#ifdef ALEX_WEI
  freopen("0.in", "r", stdin);
  freopen("0.out", "w", stdout);
#endif
  cin >> S;
  cin >> n >> q >> w >> b1 >> b2 >> inc >> ::dec;
  for(int i = 1, x; i <= n; i++) {
    cin >> x;
    c[++cnt] = {1, x - b2, i, -::dec};
    c[++cnt] = {1, x - b1, i, inc};
    c[++cnt] = {1, x + b1 + 1, i, -inc};
    c[++cnt] = {1, x + b2 + 1, i, ::dec};
  }
  for(int i = 1; i <= q; i++) {
    int op, L, H, il, ih;
    cin >> op;
    if(op == 2) {cin >> w; continue;}
    cin >> L >> H;
    while(L--) cin >> il, l[i].push_back(il);
    while(H--) cin >> ih, h[i].push_back(ih);
    c[++cnt] = {2, w, i};
  }
  sort(c + 1, c + cnt + 1);
  build(0, n, 1);
  for(int i = 1; i <= cnt; i++) {
    event t = c[i];
    if(t.type == 2) {
      int id = t.id, res = -1e9, lst = 0, pt = 0;
      h[id].push_back(n + 1);
      for(int it : l[id]) {
        while(it > h[id][pt]) lst = h[id][pt++];
        res = max(res, query(0, n, it, h[id][pt] - 1, 1, 1) - query(0, n, lst, it - 1, 1, 0));
      }
      ans[id] = res;
    }
    else modify(0, n, t.id, n, 1, t.dt);
  }
  for(int i = 1; i <= q; i++) if(l[i].size()) printf("%d\n", ans[i]);
  return 0;
}
```

---

## 作者：Dantal10n (赞：3)

标题其实是这样的，但是太长了写不下：  
>零★点☆讨★论　离☆线★问☆询  
哈☆希★离☆散　数★组☆重★排  
后★缀☆修★改　区☆间★最☆值  
细☆节★塞☆爆　耐★力☆考★验  
３★Ｋ☆代★码　邀☆您★来☆爽

[题目描述](https://www.luogu.com.cn/problem/P8454)[ ](https://vdse.bdstatic.com//192d9a98d782d9c74c96f09db9378d93.mp4)[link ](https://www.luogu.com.cn/problem/P8454)

我们先不管毒瘤的收益计算和全局修改，出一道简化版的题：
>给定一个长为 $n$ 的整数序列，$q$ 次询问合法的最大子段和。  
合法的定义是`喜欢的题`至少选一道并且`不喜欢的题`一道都不选。  
数据范围：$\max{\{n,q\}}\le10^5$，每次询问的`喜欢的题`和`不喜欢的题`加起来最多 $5$ 道。

显然喜欢的题目互不干扰，可以一道一道处理。

对于每个喜欢的题目 $p$，包含它的一个子段一定能表示成 “$1\sim p$ 的一个后缀 $\cup$ $p+1\sim n$ 的一个前缀”的形式；而由于合法子段不能包含不喜欢的题，这个后缀和前缀的边界其实是离此题最接近的不喜欢的题的编号。

于是我们现在的问题是动态问询区间前 / 后缀最大和。一个简单的发现是区间和可以表示成前缀和的差；而由于左 / 右端点固定，我们要求的是另一端点的区间最值。可以使用线段树、ST 表等数据结构维护。

我们引入单点修改，则依然可以使用带标记线段树轻松解决。

现在的问题是序列的全局修改难以处理。我们来观察一下原题的收益计算方式：$\text{\color{white}{这段方程是用 exlg 贺来的，fx 白丝 lg /qiang}}$

$$
\begin{cases}
inc&|x_i-w|\leq b_1\\
0&b_1<|x_i-w|\leq b_2\\
dec&|x_i-w|>b_2\\
\end{cases}
$$

显然每个元素的收益最多只有 $3$ 种取值；事实上，在固定 $x_i$ 的情况下，可以将所有 $w$ 的取值划分成 $5$ 个连续区间，使得每个区间内最终的收益计算值相同。

对于每个 $x_i$ 都画出这 $5$ 个区间可以得到下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/naj7ehum.png)

于是我们有一个美好的幻想：如果 $w$ 的修改是单调的，我们可以直接将区间分界点排序双游标修改，最终最多 $4n$ 次单点修改！这事 ao 的！！1

不难发现本题没有强制在线，于是可以将问询与前驱修改绑定然后按 $w$ 赠序处理。美梦成真！

>目前思维难度：下位绿  
实际代码难度：上位蓝  
分析结果：没有恶评 :/

是的，实现的时候还有很多细节要考虑。（注意不是易错点，而是一些“我大概知道这里要干啥，但是好难写啊”的地方）

1. 如何把问询和修改绑定？  
你可以开一个结构体代表，然后向邻接表里插入，这样w也顺便桶排好了。但这样会带来第二个问题：
2. 值域太大了 vector 开不下怎么办？  
~~摆烂拿部分分~~ 离散化就行。
3. 离散化要先全部存下来，代码好长……  
你可以一边读入一边把没出现过的插入哈希表，然后再按照实际值构造置换。

还有就是易错点比如：
- 用于维护前缀和的线段树忘记开 0 的下标位置，以及初始化值写错。
- 忘 pushdown/up，最大最小值写错等线段树板子错误。
- 区间分界点没考虑开闭乱写导致修改位置错误。
- 不知道 `dec` 是 ambiguous 的，开了全局变量，被编译器坑惨。（CE\*114514）

[３★Ｋ☆代★码](https://www.luogu.com.cn/paste/vvdcgti4)[ ](https://vdse.bdstatic.com//192d9a98d782d9c74c96f09db9378d93.mp4)[link](https://www.luogu.com.cn/paste/vvdcgti4)

[剪贴板](https://www.luogu.com.cn/paste/p5ln1eir)[ ](https://vdse.bdstatic.com//192d9a98d782d9c74c96f09db9378d93.mp4)[备份](https://www.luogu.com.cn/paste/p5ln1eir)

---

## 作者：KemononeRou (赞：3)

赛时调了半天结果是线段树左右区间合并写挂了 /kx

设 $v_i$ 为 $i$ 的收益。

假如 $w$ 不变，我们发现 $v_i$ 的值是固定的，考虑如何处理询问。

发现每次询问的喜欢的位置的数量很少，可以枚举每个喜欢的位置 $pos$，求包含 $pos$，并且不包含不喜欢的位置的区间 $[l,r]$ 的 $\sum_{i=l}^rv_i$ 的最大值。  
（此处的 $l$ 和题面中的 $l$ 含义不一样）

把区间 $[l,r]$ 按 $pos$ 分成 $[l,pos]$ 和 $[pos+1,r]$ 两段。

我们要找到一个 $l$，使得 $\sum_{i=l}^{pos} v_i$ 最大并且 $[l,pos]$ 不包含不喜欢的位置。$r$ 同理。（$l\leq pos$，$r\ge pos-1$，因为 $pos$ 必须选）

因为不喜欢的位置也很少，所以我们可以双指针求出一个喜欢的位置左边和右边的第一个不喜欢的位置 $p$ 和 $q$。（假设 $0$ 和 $n+1$ 也是不喜欢的位置）

于是我们要求的就是区间 $[p+1,pos]$ 的后缀和的最大值与区间 $[pos+1,q-1]$ 的前缀和的最大值。这是线段树的经典问题。（可以参考[此题](https://www.luogu.com.cn/problem/SP1043)）

但是 $w$ 是动态变化的，因此我们考虑如何维护 $v_i$。

我们将 $v_i$ 看作关于 $|x_i-w|$ 的函数，发现 $|x_i-w|$ 不断变大的时候，$v_i$ 的值只会在两个位置发生改变。

更进一步，$w$ 从 $-\infty$ 到 $+\infty$ 不断变大的时候，$v_i$ 的值会在四个位置发生改变，即分成五段。

- $w\in[-\infty,x_i-b2)$，$v_i=dec$。

- $w\in[x_i-b2,x_i-b1)$，$v_i=0$。

- $w\in[x_i-b1,x_i+b1]$，$v_i=inc$。

- $w\in(x_i+b1,x_i+b2]$，$v_i=0$。

- $w\in(x_i+b2,+\infty)$，$v_i=dec$。

我们发现 $w$ 不断变大的过程中，所有 $v_i$ 的值总共变化 $4n$ 次。

考虑将询问离线并按 $w$ 排序，处理出每个 $v_i$ 会被哪些 $w$ 改变，在线段树上单点修改即可。

[code](https://www.luogu.com.cn/paste/nxeugzra)

---

## 作者：BreakPlus (赞：1)

提供一个个人认为好写的做法。

离线后按 $w$ 排序，发现每道题目的收益一共只会变化 $\mathcal{O}(n)$ 次，线段树维护最大子段和。

但是每次有一些**强制不能选**和**至少选一个**的数。为了避免分讨可以这样处理：

+ 定义 $\infty$ 为一个较大的数（如 $\infty = 10^{16}$）。
+ 对于**强制不能选**的数，将其权值暂时赋为 $-\infty$；
+ 对于**至少选一个**的数，枚举其中一个，钦定它必选。把它的权值加 $\infty$，求出全局答案，再把得到的答案减 $\infty$。


这样我们连区间询问都不用写就做完了。

```cpp
#include<vector>
#include<cstdio>
#include<cstring>
#include<cassert>
#include<algorithm>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll,ll> Pr;
#define fi first
#define se second
#define mkp make_pair
#define pb emplace_back
#define mid ((l+r)>>1)
#define popcnt __builtin_popcountll
inline ll read(){
	ll x=0, f=1; char ch=getchar();
	while(ch<'0' || ch>'9') { if(ch=='-') f=-1; ch=getchar(); }
	while(ch>='0' && ch<='9') x=x*10+ch-'0', ch=getchar();
	return x*f;
}
struct Qr{
	ll l,h,w,L[10],H[10],id;
	Qr(){
		l=h=w=0;
		memset(L,0,sizeof(L)); memset(H,0,sizeof(H));
	}
}q[100005];
ll n,qq,w,b1,b2,inc,dec,Q;
ll x[100005], now[100005], seq[100005], ans[100005], vis[100005];
vector<Pr>upd[100005];
struct Tree{
	ll l,r,ans,sum;
}t[400005];
Tree operator+ (Tree A, Tree B){
	Tree C;
	C.l=max(A.l, A.sum+B.l);
	C.r=max(B.r, B.sum+A.r);
	C.ans=max({A.ans, B.ans, A.r+B.l});
	C.sum=A.sum+B.sum;
	return C;
}
void pushup(ll pos){
	t[pos] = t[pos<<1] + t[pos<<1|1];
}
void update(ll l,ll r,ll x,ll w,ll pos){
	if(l==r){
		t[pos].l = t[pos].r = t[pos].ans = t[pos].sum = w;
		return;
	}
	if(x<=mid) update(l,mid,x,w,pos<<1);
	else update(mid+1,r,x,w,pos<<1|1);
	pushup(pos);
}
const ll inf = 1e16;
int main(){
	n=read(),qq=read(),w=read(),b1=read(),b2=read();
	inc=read(),dec=read();
	for(ll i=1;i<=n;i++) x[i]=read();
	for(ll i=1;i<=qq;i++){
		ll op=read();
		if(op==2){
			w=read();
		}else{
			Q++; vis[i]=1;
			q[Q].l=read(); q[Q].h=read(); q[Q].w=w;
			q[Q].id=i;
			for(ll j=1;j<=q[Q].l;j++) q[Q].L[j]=read();
			for(ll j=1;j<=q[Q].h;j++) q[Q].H[j]=read();
		}
	}
	sort(q+1, q+Q+1, [](Qr A, Qr B){ return A.w < B.w; });
	for(ll i=1;i<=Q;i++) seq[i]=q[i].w;
	for(ll i=1;i<=n;i++){
		// inc: w <= x[i] + b1 && w >= x[i] - b1
		// dec: w > x[i] + b2 || w < x[i] - b2
		ll t1 = lower_bound(seq+1, seq+Q+1, x[i]-b2) - seq;
		upd[1].pb(i, dec); upd[t1].pb(i, 0);
		ll t2 = lower_bound(seq+1, seq+Q+1, x[i]-b1) - seq,
		   t3 = upper_bound(seq+1, seq+Q+1, x[i]+b1) - seq;
		upd[t2].pb(i, inc); upd[t3].pb(i, 0);
		ll t4 = upper_bound(seq+1, seq+Q+1, x[i]+b2) - seq;
		upd[t4].pb(i, dec);
	}
	for(ll i=1;i<=Q;i++){
		for(auto p: upd[i]){
			now[p.fi] = p.se;
			update(1, n, p.fi, p.se, 1);
		}
		for(ll j=1; j<=q[i].h; j++) update(1, n, q[i].H[j], -inf, 1);
		ans[q[i].id] = -inf;
		for(ll j=1; j<=q[i].l; j++){
			update(1, n, q[i].L[j], now[q[i].L[j]]+inf, 1);
			ans[q[i].id] = max(ans[q[i].id], t[1].ans);
			update(1, n, q[i].L[j], now[q[i].L[j]], 1);
		}
		for(ll j=1; j<=q[i].h; j++) update(1, n, q[i].H[j], now[q[i].H[j]], 1);
	}
	for(ll i=1;i<=qq;i++){
		if(vis[i]) printf("%lld\n", ans[i]-inf);
	}
}

```

---

## 作者：耶梦加得 (赞：1)

~~分块人报到~~

根据~~数据范围~~可以发现，我们可以对每个喜欢的题目 $il_j$，找到包含 $il_j$ 且不包含不喜欢的题的极大区间，然后在这个区间内找到包含 $il_j$ 的最大子段和，假设这个子段为 $[l, r]$，那么最大字段和可以进一步拆分成三部分：$[l, il_j - 1]$，$il_j$本身，以及 $[il_j + 1, r]$。易知分别最大化第一和第三部分即可。

以下仅讨论第一部分，即区间最大后缀和。第三部分（区间最大前缀和）仿照第一部分即可。

可以观察到这应该是一道 DS 题目。~~正常人现在应该在考虑线段树~~我观察到数据范围 $n,q$ 均小于 $1e5$，考虑分块。假设我们要求出 $[l,r]$ 区间的最大后缀和，记 $blk[i]$ 表示 $i$ 所在的块，$B$ 表示块大小，当前考虑的后缀记为 $[p, r]$

首先对于 $blk[p] = blk[r]$ 的情况暴力即可，复杂度 $O(B)$。

对于 $blk[l] < blk[p] < blk[r]$ 的情况，枚举每一个 $blk[p]$，容易发现此时只要知道 $[blk[p] + 1, blk[r])$ 这些块的总和，以及 $blk[p]$ 的块内最大后缀，就可以 $O(\frac{N}{B})$（枚举的复杂度）求出此时的答案。这些就是我们要预处理的内容。

对于一个固定的 $w$，换而言之，一个固定的收益（值）序列，我们可以对每个块 $O(B)$ 暴力求出最大后缀和以及总和。问题在于 $w$ 一共有 $O(Q)$ 种，如果对于每个 $w$ 都暴力算一遍，复杂度将是 $O(NQ)$，不能接受。

仔细考虑，我们其实并不在乎 $w$ 是否有变化，我们仅考虑块内值是否发生变化。考虑对于块内每一道题 $i$，仅仅在 $w$ 越过 $x_i - b_1, x_i - b_2, x_i + b2, x_i + b1$ 这四个分界点时值会产生变化。考虑对所有 $w$ 排序，那么所有值分别只会变化四次，我们只需要暴力算 $O(B)$ 次即可。单块复杂度 $O(B^2)$，最终总复杂度为 $O(NB)$。

要判断值是否发生变化，我们可以把所有分界点排序，记一个指针表示 $w$ 当前在哪个分界点之前。注意开闭区间问题。（我代码用的 upper_bound 多一个 log）。

最后对于 $blk[p] = blk[l]$ 的情况，利用刚才求出的 $(blk[l], blk[r])$ （这是开区间）的块总和，$O(B)$ 暴力即可，注意 $blk[r]$ 内的值不要漏了（虽然代码实现上，就算你真的忘了，答案也不太会漏掉这部分 :)。

处理询问的总复杂度 $O(QB + \frac{NQ}{B})$

总复杂度 $O(QB + NB + \frac{NQ}{B})$，正常取 $B = \sqrt N$ 即可。

```cpp
#include<algorithm>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<queue>
#include<vector>
#define getu() getchar_unlocked()
#define miu 100007
using namespace std;
inline int read() {
    register int x = 0, f = 1; register char ch = getu();
    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getu();}
    while(ch >= '0' && ch <= '9') {x = x * 10 + ch - 48; ch = getu();}
    return x * f;
}
int S;
int n, m, B;
int b1, b2, v1, v2;
int a[miu], blk[miu], lb[327], rb[327];
int rm[miu][327], lm[miu][327], sum[miu][327];
vector<int> s[327];
struct alter {
    int w, id;
    inline bool operator < (const alter & b) const {
        return w < b.w;
    }
}e[miu];
struct query {
    int id, l, h;
    int il[5], ih[5];
}q[miu];
int op[miu];
inline int chk(int nowd) {
    return nowd <= b1 ? v1 : (nowd > b2 ? v2 : 0);
}
int decy[miu];
signed main() {
    S = read();
    n = read(); m = read(); e[0].w = read(); b1 = read(); b2 = read(); v1 = read(); v2 = read();
    B = sqrt(n);
    for(int i = 1; i <= n; ++i) {
        a[i] = read();
        blk[i] = (i - 1) / B + 1;
        s[blk[i]].push_back(a[i] - b2);
        s[blk[i]].push_back(a[i] - b1);
        s[blk[i]].push_back(a[i] + b1 + 1);
        s[blk[i]].push_back(a[i] + b2 + 1);
    }
    for(int i = 1; i <= blk[n]; ++i) {
        lb[i] = (i - 1) * B + 1;
        rb[i] = i * B;
    }
    rb[blk[n]] = n;
    lb[blk[n + 1] = blk[n] + 1] = n + 1;
    int nowid = 0, qid = 0;
    for(int i = 1; i <= m; ++i) {
        op[i] = read();
        if(op[i] == 2) {
            if(op[i - 1] == 1) ++nowid;
            e[nowid].w = read();
            e[nowid].id = nowid;
        } else {
            q[++qid].id = nowid; q[qid].l = read(); q[qid].h = read();
            for(int k = 0; k < q[qid].l; ++k) {
                q[qid].il[k] = read();
            }
            for(int k = 0; k < q[qid].h; ++k) {
                q[qid].ih[k] = read();
            }
        }
    }
    sort(e, e + nowid + 1);
    for(int i = 0; i <= nowid; ++i) {
        decy[e[i].id] = i;
    }
    for(int i = 1; i <= blk[n]; ++i) {
        sort(s[i].begin(), s[i].end());
        int tmpr = 0, tmpl = 0, tl = upper_bound(s[i].begin(), s[i].end(), e[0].w) - s[i].begin();
        for(int j = lb[i]; j <= rb[i]; ++j) {
            sum[0][i] += chk(abs(a[j] - e[0].w));
            lm[0][i] = max(lm[0][i], sum[0][i]);
        }
        for(int j = rb[i]; j >= lb[i]; --j) {
            tmpr += chk(abs(a[j] - e[0].w));
            rm[0][i] = max(rm[0][i], tmpr);
        }
        for(int k = 1; k <= nowid; ++k) {
            int nxt = upper_bound(s[i].begin(), s[i].end(), e[k].w) - s[i].begin(); 
            if(tl == nxt) {
                sum[k][i] = sum[k - 1][i];
                lm[k][i] = lm[k - 1][i];
                rm[k][i] = rm[k - 1][i];
                continue;
            }
            int & nows = sum[k][i], & nowl = lm[k][i], & nowr = rm[k][i];
            tl = nxt; tmpr = 0;
            for(int j = lb[i]; j <= rb[i]; ++j) {
                nows += chk(abs(a[j] - e[k].w));
                nowl = max(nowl, nows);
            }
            for(int j = rb[i]; j >= lb[i]; --j) {
                tmpr += chk(abs(a[j] - e[k].w));
                nowr = max(nowr, tmpr);
            }
        } 
    }
    for(int i = 1; i <= qid; ++i) {
        int tm = decy[q[i].id], fans = -1000000000;
        for(int px = 0; px < q[i].l; ++px) {
            int x = q[i].il[px];
            int ll = 0, rr = n + 1;
            for(int py = 0; py < q[i].h; ++py) {
                int y = q[i].ih[py];
                if(y < x) ll = max(ll, y);
                else if(y > x) rr = min(rr, y);
            }
            int lans = 0, lsum = 0;
            if(blk[ll + 1] == blk[x]) {
                for(int j = x - 1; j > ll; --j) {
                    lsum += chk(abs(e[tm].w - a[j]));
                    lans = max(lans, lsum);
                }
            } else {
                for(int j = x - 1; j >= lb[blk[x]]; --j) {
                    lsum += chk(abs(e[tm].w - a[j]));
                    lans = max(lans, lsum);
                }
                for(int J = blk[x] - 1; J > blk[ll]; --J) {
                    lans = max(lans, lsum + rm[tm][J]);
                    lsum += sum[tm][J];
                }
                for(int j = rb[blk[ll]]; j > ll; --j) {
                    lsum += chk(abs(e[tm].w - a[j]));
                    lans = max(lans, lsum);
                }
            }
            int rans = 0, rsum = 0;
            if(blk[rr - 1] == blk[x]) {
                for(int j = x + 1; j < rr; ++j) {
                    rsum += chk(abs(e[tm].w - a[j]));
                    rans = max(rans, rsum);
                }
            } else {
                for(int j = x + 1; j <= rb[blk[x]]; ++j) {
                    rsum += chk(abs(e[tm].w - a[j]));
                    rans = max(rans, rsum);
                }
                for(int J = blk[x] + 1; J < blk[rr]; ++J) {
                    rans = max(rans, rsum + lm[tm][J]);
                    rsum += sum[tm][J];
                }
                for(int j = lb[blk[rr]]; j < rr; ++j) {
                    rsum += chk(abs(e[tm].w - a[j]));
                    rans = max(rans, rsum);
                }
            }
            fans = max(fans, lans + rans + chk(abs(e[tm].w - a[x])));
        }
        printf("%d\n", fans);
    }
    return 0;
}

```


关于常数，一点闲话：

~~观察提交记录可以得知~~我赛时 T 了。这一方面是复杂度的问题（多了个 log），一方面也是常数的问题。

本实现有两个重要卡常。

1.剔除无用询问，可以看到通过记录 $op$ 实现，这是 trivial 的。

2.减少 Cache miss。 按照我上面这份实现，如果把 $rm, lm, sum$ 数组内外两层互换，会直接从 2.7s AC T 成 3.7s！这是因为在 $J$ 的循环中，出现了$O(
\frac{NQ}{B})$ 的 Cache miss……

---

## 作者：qiucr (赞：0)

[查看原题戳这里](https://www.luogu.com.cn/problem/P8454)
### 思路：
首先简化问题，我们先不考虑 $w$ 的改变。\
我们可以枚举喜欢的节点位置 $pos$，然后找其最左边第一个不喜欢的节点 $l$，右边第一个不喜欢的节点 $r$，现在就变成了这样一个问题：\
就是找 $[l,r]$ 包含 $pos$ 的**最大子区间**，我们想到可以用前缀和来处理，找 $[pos+1,r-1]$ 的最大前缀和减去 $[l+1,pos]$ 的最小前缀和，我们可以用**线段树**来进行这种操作，正确性显然。\
现在考虑 $w$ 修改的请况：\
$w$ 从负无穷到正无穷不断变大的时候，点的贡献的值会在四个位置发生改变，即分成五段，且每个点的贡献之后变化 $4$ 次，所以我们考虑进行离线处理。
```
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5+100;
int n,q,w,b1,b2,inc,Dec,cnt;
int ans[N];
vector<int> l[N],h[N];
struct Node{
    int type,x,id,val;
}c[N];
struct node{
    int l,r;
    int maxx,minn;
    int tag;
}tr[N*4];
void pushup(int u){
    tr[u].maxx=max(tr[u<<1].maxx,tr[u<<1|1].maxx);
    tr[u].minn=min(tr[u<<1].minn,tr[u<<1|1].minn);
}
void evil(int u,int k){
    tr[u].tag+=k;
    tr[u].maxx+=k,tr[u].minn+=k;
}
void pushdown(int u){
    if(!tr[u].tag) return;
    evil(u<<1,tr[u].tag),evil(u<<1|1,tr[u].tag);
    tr[u].tag=0;
}
void build(int u,int l,int r){
    tr[u]={l,r};
    if(l==r){
        tr[u].maxx=tr[u].minn=l*Dec;
        return;
    }
    int mid=l+r>>1;
    build(u<<1,l,mid),build(u<<1|1,mid+1,r);
    pushup(u);
}
void modify(int u,int l,int r,int k){
    if(tr[u].l>=l&&tr[u].r<=r){
        evil(u,k);
        return;
    }
    pushdown(u);
    int mid=tr[u].l+tr[u].r>>1;
    if(l<=mid) modify(u<<1,l,r,k);
    if(r>mid) modify(u<<1|1,l,r,k);
    pushup(u);
}
int query(int u,int l,int r,int type){
    if(tr[u].l>=l&&tr[u].r<=r){
        if(type) return tr[u].maxx;
        else return tr[u].minn;
    }
    pushdown(u);
    int mid=tr[u].l+tr[u].r>>1;
    int res;
    if(type) res=-0x3f3f3f3f;
    else res=0x3f3f3f3f;
    if(l<=mid) res=query(u<<1,l,r,type);
    if(r>mid){
        int s=query(u<<1|1,l,r,type);
        if(type) res=max(res,s);
        else res=min(res,s);
    }
    return res;
}
bool cmp(Node a,Node b){
    if(a.x!=b.x) return a.x<b.x;
    else return a.type<b.type;
}
signed main(){
    ios::sync_with_stdio(false);
    int S;
    cin>>S;
    cin>>n>>q>>w>>b1>>b2>>inc>>Dec;
    for(int i=1,x;i<=n;i++){
        cin>>x;
        c[++cnt]={1,x-b2,i,-Dec};
        c[++cnt]={1,x-b1,i,inc};
        c[++cnt]={1,x+b1+1,i,-inc};
        c[++cnt]={1,x+b2+1,i,Dec};
    }
    for(int i=1;i<=q;i++){
        int op,L,H,il,ih;
        cin>>op;
        if(op==2) cin>>w;
        else{
            cin>>L>>H;
            while(L--) cin>>il,l[i].push_back(il);
            while(H--) cin>>ih,h[i].push_back(ih);
            c[++cnt]={2,w,i};
        }
    }
    sort(c+1,c+1+cnt,cmp);
    build(1,0,n);
    for(int i=1;i<=cnt;i++){
        if(c[i].type==2){
            int id=c[i].id,res=-1e9,last=0,ne=0;
            h[id].push_back(n+1);
            for(int it:l[id]){
                while(h[id][ne]<it) last=h[id][ne],ne++;
                res=max(res,query(1,it,h[id][ne]-1,1)-query(1,last,it-1,0));
            }ans[id]=res;
        }else modify(1,c[i].id,n,c[i].val);
    }
    for(int i=1;i<=q;i++){
        if(l[i].size()) cout<<ans[i]<<endl;
    }
    return 0;
}

```

---

## 作者：xu2237803016 (赞：0)


## 前言

*这道题我一开始本来准备用 java写的，在 TLE 了无数次之后还是妥协用 c++ 写了。。。*

花了1天左右的时间终于给做出来了(老菜鸡了)，难到我的并不是线段树，而是那个分段。大佬们的代码的写的有亿点复杂，对我这种菜鸡很不友好。

后面把大佬的代码学习(~~抄~~)了一遍(我是 java 写的，交上去结果 T 了)，总算是大致给理明白了，然后自己写了一个简化的版本，应该很容易就能看懂。

我的代码里面线段树部分写的很拉，如果你不会线段树求最大子段和的话请先去做一下这道题: [P4513 小白逛公园](https://www.luogu.com.cn/problem/P4513)

## 思路
这里主要讲分段的写法，线段树就不说了。


如果你看过别的题解，应该知道我们会把输入的 $w$ 存起来，然后按照递增的方式进行处理，那么为什么要递增呢？

**先来看如果不递增：**

对于每次 $op$ == 2 我们只能对所有节点进行遍历修改，这样肯定会直接 T 掉，而且我们也很难写出什么比较好的算法来优化这个过程，如果有的话，每次更新至少要处理 $n$ 次( $n$ 个节点遍历一次)，因为更新不是连续的，只能每个节点一个一个的检查。

一句话来概括，就是边输入边处理，修改操作非常麻烦！

**如果按照递增处理**

对于任意一道题，都可以给它分成5个区间( $b1$ = $b2$ 时为3个，此时没有权值为0的区间)

![演示](https://cdn.luogu.com.cn/upload/image_hosting/xn901hen.png)

红色部分代表收益为 $dec$，蓝色为`0`，绿色为 $inc$

如果我们准备一条线，从下往上扫上去，可以发现**每道题最多更新4次**，也就是整体最多更新 4$n$ 次。

那么我们该怎么去更新呢？

其实就跟图上面一样，把每道题分成4块，为什么不是5块呢？因为我们起始的时候从最底下开始，也就是说每道题的收益都是从 $dec$ 开始，然后再开始往上遍历输入的 $w$，这样从逻辑上会更好处理一些。

来看代码:
```c++
struct Endpoint {
    // pos相当于记录每个区间下端点的位置
    int pos;
    // 对应的是哪个题目
    int questionId;
    // 收益
    int income;
    bool operator<(const Endpoint& p)const{
        return pos < p.pos;
    }
} endpoints[MAX_N * 4];

// ...

int main() {
    // ...
    int endpointSize = 0;
    for (int i = 1; i <= n; i++) {
        difficulty[i] = read();
        // 这里后面讲
        currentValue[i] = dec;
        if (b1 != b2) {
       	    // b1等于b2了就没有收益为0的区间了
            endpoints[++endpointSize] = (Endpoint) {difficulty[i] - b2, i, 0};
            endpoints[++endpointSize] = (Endpoint) {difficulty[i] + b1 + 1, i, 0};
        }
        endpoints[++endpointSize] =  (Endpoint){difficulty[i] - b1, i, inc};
        endpoints[++endpointSize] =  (Endpoint){difficulty[i] + b2 + 1, i, dec};
    }
    std::sort(endpoints + 1, endpoints + endpointSize + 1);
}
```
这是很基础的代码，相信大家都能看懂。

之后我们来处理输入，直接上代码了，很简单，具体地方会给出注释：
```c++
struct Update {
    // 这次更新后，从哪次查询开始
    int start;
    // 这次更新的权重
    int weight;
    // 这次更新到哪个查询结束
    int end;
    bool operator<(const Update& upd) const {
        return weight < upd.weight;
    }
}updates[MAX_N];

std::vector<int> likes[MAX_Q];
std::vector<int> hates[MAX_Q];

int main(){
    // ...
    
    // 可以把这个理解为 op = 1 时，输入的数据组 id 号
    int mark = 0;
    // 有次更新
    int updateIndex = 1;
    // 第一次更新，在 query 之前的那次更新
    updates[0] = (Update){1, w};
    for(int i = 0; i < q; i++) {
        int op = read();
        int unk = read();
        if (op == 2) {
            w = unk;
            // 又有一次更新, 这个时候我们只知道它管理的起始点，不知道终点
            updates[updateIndex] = (Update){mark + 1, w};
            if (updateIndex - 1 >= 0) {
            	// 这里可以直接给上一个更新赋终点
                updates[updateIndex - 1].end = mark;
            }
            updateIndex++;
            continue;
        }
        int h = read();
        ++mark;
        for(int j = 0; j < unk; j++) {
            likes[mark].push_back(read());
        }
        for(int j = 0; j < h; j++) {
            hates[mark].push_back(read());
        }
    }
    // 这里不要掉了
    updates[updateIndex - 1].end = mark;
    // 按权值排序一下
    std::sort(updates, updates + updateIndex);
}
```

之后就是遍历 $updates$ 数组，处理答案了：
```c++
// 用来标记当前遍历到哪个片段了
int endpointIndex = 1;
// 建树，将所有节点的值都标记为 dec
build(1, 1, n);
for (int i = 0; i < updateIndex; i++) {
    Update upd = updates[i];
    int weight = upd.weight;
    // 在这里处理更新，当endpoint的pos小于等于当前更新的权值w就更新
    while (endpointIndex < endpointSize && endpoints[endpointIndex].pos <= weight) {
        Endpoint endpoint = endpoints[endpointIndex];
        // 这里算一个小枝剪??(雾), 其实作用几乎为0......
        if (endpoint.income != currentValue[endpoint.questionId]) {
            update(1, endpoint.questionId, endpoint.income);
            currentValue[endpoint.questionId] = endpoint.income;
        }
        endpointIndex++;
    }
    // 这里就是查询操作了, 直接遍历就可以了，十分滴无脑
    for (int j = upd.start; j <= upd.end; j++) {
        int l = 0, r = 0;
        int _ans = MIN_VALUE;
        std::vector<int> hate = hates[j];
        hate.push_back(n + 1);
        for (int like : likes[j]) {
            while (hate[r] < like) {
                l = hate[r++];
            }
            _ans = max(_ans, queryLeft(like + 1, hate[r] - 1) + queryRight(l + 1, like));
        }
        ans[j] = _ans;
    }
}
```
最后直接输入答案即可

## 代码
[代码](https://www.luogu.com.cn/paste/olbf00ak)

最后跑了 1.03s，还是能看的。

由于继承了我 Java 开发的习惯，写的很长，**建议直接跳到main方法观看**，外面的函数全是关于线段树的。


---


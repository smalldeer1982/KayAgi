# 『JROI-8』颅脑损伤 2.0（加强版）

## 题目背景

注意到本题特殊的时间限制。

[普通版](https://www.luogu.com.cn/problem/P8591)。

## 题目描述

给定 $n$ 条线段，第 $i$ 条是 $[l_i,r_i]$，将他们染成红色或黑色，要求：

1. 任意两条红色不相交
2. 任意一条黑色**至少**和一条红色相交。

请最小化红色线段的长度和，并输出这个长度和。

一条线段 $[l_i,r_i]$ 的长度定义为 $r_i-l_i$，两条线段 $[l_i,r_i],[l_j,r_j]$ 交**当且仅当**存在 $k\in[l_i,r_i]$ 且 $k\in[l_j,r_j]$。

## 说明/提示

**数据范围**

|测试点编号|$n\le$|
| :----------: | :----------: |
|$1\sim10$|$5\times 10^5$|

对于所有数据，满足 $-10^9\le l_i<r_i\le10^9$。

本题采用捆绑测试。

## 样例 #1

### 输入

```
5
-6 5
1 3
-4 9
-1 10
6 8
```

### 输出

```
4```

# 题解

## 作者：jr_linys (赞：3)

2023/8/9 把这篇烂题解翻了出来，优化了分析，没那么烂了

2023/8/12 对最新数据进行更新。

## 题目传送门:[普通版](https://www.luogu.com.cn/problem/P8591) [加强版](https://www.luogu.com.cn/problem/P8592)

## 前言
赛时第 $3$ 题推了个柿子调不出来，直接开摆，没看第4题。赛后一看好像还挺简单，小WA一下，开个 `long long` 就 AC 了。

$O(n^2)$ 和 $O(n\log n)$ 本题解都有。
- - -

## 题目~~大意~~直接 copy
给定 $n$ 条线段，第 $i$ 条是 $[l_i,r_i]$。将每一条线段染成红色或黑色，要求：

1. 任意两条红色线段不相交。
2. 任意一条黑色线段**至少**和一条红色线段相交。

请最小化红色线段的长度和，并输出这个长度和。

一条线段 $[l_i,r_i]$ 的长度定义为 $r_i-l_i$，两条线段 $[l_i,r_i],[l_j,r_j]$ 交**当且仅当** $l_i\le r_j$ 且 $l_j\le r_i$。

**数据范围**

$n\le3000,-10^9\le l_i<r_i\le10^9$

困难版 $n\le5\times 10^5$
- - -

## $O(n^2)$
普通版扫一眼数据范围，按出题套路肯定是 $O(n^2)$ **DP**。

**排序** 一般来说，需要给线段排个序，最基础的两种就是按前端排序和按后端排序。
考虑按后端排序，后端相等按前端排序，那么定义 $f_i$ 为**按排序后第 $i$ 条线段染成红色,保证前 $i$ 条线段合法，红色线段的总长度**。
 
**状态转移 设左端点为 $x$，右端点为 $y$，上一条红线为第$j$ 条**（$0\le j<i$）（$j=0$ 时第 $i$ 条线段为第 $1$ 条红线，不妨使 $x_0=y_0=-\infty$）。
 
1. 因为**两条红线不可重叠**，所以要保证 $y_j<x_i$。
 
2. 又要保证中间剩下的黑线（$j<k<i$）**至少接触一条红线**，对于 $x_i \le y_k$ 的黑线可以**接触到第 $i$ 条线段**，所以只要保证 $x_i>y_k$ 的线段要**接触第 $j$ 条线段**。

设 $p_i$ 为满足 $y_k<x_i$ 的最后后一条线段。
则要保证 $\max^{p_i}\limits_{k=j+1} x_k \le y_j$。由于 $l \in[0,j],x_l\le y_l\le y_j$，等价于 $\max^{p_i}\limits_{k=0} x_k \le y_j$。

3. 那么加上第 $i$ 条**线段长度** $y_i-x_i$，总得（"[ ]"内的表示条件）

$$
f_i= \min^{p_i}\limits_{j=0}
[\max^{p_i}\limits_{k=0} x_k \le y_j]
f_j+y_i-x_i
$$

**统计** 红色线段要把所有黑色线断覆盖,对于每一个 $i$，若 $\max^{n} \limits_{j=0} x_j \le y_i$，则在**保证前面合法的情况下，后面的线段也能被这条线段覆盖**，所以可以作为最后一条红线。

- - -
#### $O(n^2)$ 代码
*可结合注释李姐*

[提交记录](https://www.luogu.com.cn/record/91668632)
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

const int N=3*1e3,IINF=1e9+10;
const long long INF=1e18;
long long f[N+5],ans=INF;
struct stu{int x,y;}a[N+3];
bool cmp(stu a,stu b){//按后端排序，后端相等按前端排序
	if(a.y==b.y) return a.x<b.x;
	return a.y<b.y;
}
int main(){
	int n,zmax=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i].x,&a[i].y);
		zmax=max(zmax,a[i].x);//记录最大的左端点
	}
	sort(a+1,a+1+n,cmp);//排序
	a[0].x=-IINF,a[0].y=-IINF;//j=0时第i条线段为第1条红线,不妨使x[0]=y[0]=-无限
	for(int i=1;i<=n;i++){
		int j;
		for(j=i-1;a[j].y>=a[i].x;j--);//跳过y[j]>=x[i]的线段，这些线段能被第i条线段覆盖
		int maxx=-IINF;f[i]=INF;
		for(;j>=0&&a[j].y>=maxx;j--) f[i]=min(f[i],f[j]),maxx=max(maxx,a[j].x);//要满足中间的黑线对第i,j条线，至少触碰一条
		f[i]+=a[i].y-a[i].x;//加上本条线段长度
		if(a[i].y>=zmax) ans=min(ans,f[i]);//判断能否覆盖后面所有的线段，作为最后一条线段 更新
	}
	printf("%lld",ans);
}
```

## $O(n\log n)$
26号，突然看见有困难版，便想用 双指针+线段树 优化，然后一直 WA，打了两个小时之后才发现被证伪了......别问为什么，问就是我太睿智了。[普通版提交寄录](https://www.luogu.com.cn/record/91660336)

回归正题。其实上面 $O(n^2)$ 的代码已经有雏形了。

不难看出，第 $p_i$ 条线段一定可以满足转移的条件。
而以此线段为右端点向左扩展，$y_j$ 满足不上升，$\max^{p_i}\limits_{k=0} x_k \le y_j$ 满足不下降。

**换句话说，可转移的上一条红线是一段区间，而且右端点可以二分，从右端点往左拓展也满足单调性。**

所以可以二分左右端点，右端点为 $p_i$，左端点为满足 $\max^{p_i}\limits_{k=0} x_k \le y_j$ 的第一条。可用数组 $maxx[i]$ 表示 $\max^{i} \limits_{k=0} x_k$。


然后用线段树区间查询求出 $[l,r]$ 区间最小的 `f[j]`，然后插入 `f[i]`。

#### $O(n\log n)$ 代码
[提交记录](https://www.luogu.com.cn/record/119755820)
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;

const int N=5e5,IINF=1e9+10;
const long long INF=1e18;
struct stu{int x,y;}a[N+5];
int maxx[N+5];
long long f[N+5],ans=INF,tree[5*N];
void updata(int l,int r,int rt,int x,long long y){//模板而已
	if(l==r){
		tree[rt]=y;
		return;
	}
	int mid=l+r>>1;
	if(x<=mid) updata(l,mid,rt<<1,x,y);
	else updata(mid+1,r,rt<<1|1,x,y);
	tree[rt]=min(tree[rt<<1],tree[rt<<1|1]);
}
long long ask(int l,int r,int rt,int x,int y){
	if(x<=l&&r<=y) return tree[rt];
	int mid=l+r>>1;long long ans=INF;
	if(x<=mid) ans=min(ans,ask(l,mid,rt<<1,x,y));
	if(y>mid) ans=min(ans,ask(mid+1,r,rt<<1|1,x,y));
	return ans;
}

int main(){
	int n,zmax=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i].x,&a[i].y);
		zmax=max(zmax,a[i].x);
	}
	sort(a+1,a+1+n,
	[](stu a,stu b){
		if(a.y==b.y) return a.x<b.x;
		return a.y<b.y;
	});//一种奇妙的写法
	
	for(int i=1;i<=4*n+100;i++) tree[i]=INF;
	a[0].x=a[0].y=maxx[0]=-IINF;
	updata(0,n,1,0,0);//注意下
	for(int i=1;i<=n;i++){
		maxx[i]=max(maxx[i-1],a[i].x);//更新最大的x
		int l,r,x,y;
		x=0,y=i;
		while(y-x>1){
			int mid=x+y>>1;
			if(a[mid].y<a[i].x) x=mid;
			else y=mid;
		}r=x;//二分右端点
		x=-1,y=r;
		while(y-x>1){
			int mid=x+y>>1;
			if(a[mid].y>=maxx[r]) y=mid;//右端点r就是最后一个满足a[r].y<a[i].x的线段
			else x=mid;
		}l=y;//二分左端点
		
		f[i]=ask(0,n,1,l,r)+a[i].y-a[i].x;
		updata(0,n,1,i,f[i]);//要不断插入
		if(a[i].y>=zmax) ans=min(ans,f[i]);
	}
	printf("%lld",ans);
}
```

---

## 作者：xieyikai2333 (赞：3)

- [题目传送门-洛谷](https://www.luogu.com.cn/problem/P8592)

---

# 0x00 闲话


- 这是一篇 $\Theta(n)$ 的题解。

---

# 0x01 第一部分

## 解题思路

- 先将线段按照左端点排序。

- 考虑一个 DP。令 $dp_{i}$ 表示第 $i$ 条线段被染红，并且前 $i-1$ 条线段都满足条件的最小答案。

- 考虑状态转移方程。显然是 $dp_{i}=\min\{dp_j\}+(r_i-l_i)$ 的形式。现在要考虑哪些 $j$ 可以用来转移 $i$。

- 首先我们要知道右端点严格小于 $l_i$ 的线段中，左端点最大的线段的左端点的位置，记为 $pos$。看起来很别扭，其实就是：
	$$pos=\max_{r_{j} \lt l_{i}}\{l_{j}\}$$

- 这个位置，是前 $i-1$ 条线段中线段 $i$ 覆盖不到的最后位置。所以对于任意 $j$，若 $dp_{j}$ 可以更新 $dp_{i}$，那么 $r_{j} \ge pos$ 是必须的。此时线段 $j$ 覆盖了 $pos$，那么由 $pos$ 的定义可知，前 $i-1$ 条线段都已满足条件。又因为两条红线段不能相交，于是 $j$ 与 $i$ 不能相交，即 $r_{j} \lt l_i$。

- 总结一下：
	$$dp_{i}=\min_{pos \leq r_{j} \lt l_{i}}\{dp_{j}\}$$

- 只要线段 $i$ 可以覆盖到最后一条线段，$dp_{i}$ 就有机会成为最终答案：
	$$ans=\min_{r_{i} \geq l_{n}}\{dp_{i}\}$$

- 时间复杂度是 $\Theta(n^{2})$。

---

## 代码实现

**AC 代码：**

```cpp
#include <bits/stdc++.h>
#define l first
#define r second
using namespace std;
const int N=3005;
long long dp[N];
pair<int,int> a[N];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d %d",&a[i].l,&a[i].r);
	sort(a+1,a+n+1);
	long long ans=LLONG_MAX;
	a[0].r=INT_MIN;
	for(int i=1;i<=n;i++)
	{
		dp[i]=LLONG_MAX/3;
		int pre=INT_MIN;
		for(int j=1;j<i;j++)if(a[j].r<a[i].l&&a[j].l>pre)pre=a[j].l;
		for(int j=0;j<i;j++)if(a[j].r<a[i].l&&a[j].r>=pre)dp[i]=min(dp[i],dp[j]+(a[i].r-a[i].l));
		if(a[i].r>=a[n].l)ans=min(ans,dp[i]);
	}
	printf("%lld",ans);
	return 0;
}
```

- 这个时候有的读者就要问了：说好的 $\Theta(n)$ 呢？请往下看。

---

# 0x02 第二部分

## 解题思路

- 观察到我们的时间复杂度瓶颈在求 $pos$ 以及 $dp_{i}$ 上，考虑优化。

- 先离散化。

- 对于 $pos$，我们预先记录下每一个右端点对应的左端点，然后对于所有小于 $l_{i}$ 的位置求其对应的左端点位置的最大值即为 $pos$。因为 $l_{i}$ 有序且数据经过离散化，所以可以一个指针扫过去，这样求 $pos$ 的操作**总共**只会进行 $\Theta(n)$ 次。

- 对于 $dp_{i}$，根据刚才的状态转移方程可以看出它很像一个区间最值问题。我们将 $dp_{j}$ 存在线段树上 $r_{j}$ 的位置，这样只要查询线段树上区间 $[pos,l_{i})$ 的最小值即可。于是我们可以在 $\Theta(\log n)$ 的时间复杂度内求出 $dp_{i}$。

- 至此，时间复杂度优化至 $\Theta(n \log n)$。

---

## 代码实现


**AC 代码：**

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=3005;
int tmp[N<<1],pos[N<<1],dp[N];
struct node
{
	int l,r,x;
	bool operator < (const node &o)const
	{
		return this->l<o.l;
	}
}a[N];
struct SGT
{
	int mi[N<<3];
	SGT(){memset(mi,0x3f,sizeof(mi));}
	void modify(int p,int l,int r,int x,int v)
	{
		if(l==r)return mi[p]=min(mi[p],v),void();
		int mid=(l+r)>>1;
		if(x<=mid)modify(p<<1,l,mid,x,v);
		else modify(p<<1|1,mid+1,r,x,v);
		mi[p]=min(mi[p<<1],mi[p<<1|1]);
		return;
	}
	int query(int p,int l,int r,int x,int y)
	{
		if(x>r||y<l)return LLONG_MAX;
		if(x<=l&&r<=y)return mi[p];
		int mid=(l+r)>>1;
		return min(query(p<<1,l,mid,x,y),query(p<<1|1,mid+1,r,x,y));
	}
}sgt;
int lsh(int n)
{
	for(int i=1;i<=n;i++)tmp[2*i-1]=a[i].l,tmp[2*i]=a[i].r;
	sort(tmp+1,tmp+2*n+1);
	int len=unique(tmp+1,tmp+2*n+1)-tmp-1;
	for(int i=1;i<=n;i++)
	{
		a[i].x=a[i].r-a[i].l;
		a[i].l=lower_bound(tmp+1,tmp+len+1,a[i].l)-tmp;
		a[i].r=lower_bound(tmp+1,tmp+len+1,a[i].r)-tmp;
	}
	return len;
}
signed main()
{
	int n;
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)scanf("%lld %lld",&a[i].l,&a[i].r);
	sort(a+1,a+n+1);
	int m=lsh(n),p=1,pre=0,ans=LLONG_MAX;
	for(int i=1;i<=n;i++)pos[a[i].r]=a[i].l;
	sgt.modify(1,0,m,0,0);
	for(int i=1;i<=n;i++)
	{
		while(p<a[i].l)pre=max(pre,pos[p++]);
		dp[i]=sgt.query(1,0,m,pre,a[i].l-1)+a[i].x;
		sgt.modify(1,0,m,a[i].r,dp[i]);
		if(a[i].r>=a[n].l)ans=min(ans,dp[i]);
	}
	printf("%lld",ans);
	return 0;
}
```

- 这个时候有的读者就要问了：说好的 $\Theta(n)$ 呢？请往下看。

---

# 0x03 第三部分

## 解题思路

- 观察到 $pos$ 和 $l_{i}$ 都单调递增，可以用单调队列代替线段树。

- 当然，不要忘记使用 **基数排序**。

- 至此，时间复杂度优化至 $\Theta(n)$。

---

## 代码实现


**AC 代码：**

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
typedef pair<int,int> PII;
const int N=5e5+5,S=3.2e4;
int pos[N<<1],dp[N<<1],c[(S<<1)+5];
PII b[N<<1],t[N<<1];
struct node{int l,r,x;}a[N],tmp[N];
deque<int> q;
void SORT(int n)
{
	for(int i=1;i<=n;i++)
	{
		tmp[i].x=a[i].r-a[i].l;
		b[(i<<1)-1]=PII(a[i].l,(i<<1)-1);
		b[i<<1]=PII(a[i].r,i<<1);
	}
	for(int i=0;i<=(S<<1);i++)c[i]=0;
	for(int i=1;i<=(n<<1);i++)c[b[i].first%S+S]++;
	for(int i=1;i<=(S<<1);i++)c[i]+=c[i-1];
	for(int i=1;i<=(n<<1);i++)t[++c[b[i].first%S+S-1]]=b[i];
	for(int i=0;i<=(S<<1);i++)c[i]=0;
	for(int i=1;i<=(n<<1);i++)c[t[i].first/S+S]++;
	for(int i=1;i<=(S<<1);i++)c[i]+=c[i-1];
	for(int i=1;i<=(n<<1);i++)b[++c[t[i].first/S+S-1]]=t[i];
	int cnt=0,tot=0;
	b[0].first=INT_MIN;
	for(int i=1;i<=(n<<1);i++)
	{
		if(b[i].first!=b[i-1].first)cnt++;
		int id=b[i].second;
		if(id&1)tmp[(id>>1)+1].l=cnt;
		else tmp[id>>1].r=cnt;
	}
	for(int i=1;i<=(n<<1);i++)
	{
		int id=b[i].second;
		if(id&1)a[++tot]=tmp[(id>>1)+1];
	}
	return;
}
signed main()
{
	int n;
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)scanf("%lld %lld",&a[i].l,&a[i].r);
	SORT(n);
	for(int i=1;i<=n;i++)pos[a[i].r]=a[i].l;
	int p=1,pre=0,ans=LLONG_MAX;
	memset(dp,0x3f,sizeof(dp));
	dp[0]=0,q.push_back(0);
	for(int i=1;i<=n;i++)
	{
		while(p<a[i].l)
		{
			pre=max(pre,pos[p]);
			while(!q.empty()&&dp[q.back()]>=dp[p])q.pop_back();
			q.push_back(p++);
		}
		while(!q.empty()&&q.front()<pre)q.pop_front();
		dp[a[i].r]=min(dp[a[i].r],dp[q.front()]+a[i].x);
		if(a[i].r>=a[n].l)ans=min(ans,dp[a[i].r]);
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Lucyna_Kushinada (赞：1)

好题。

按照套路，我们先按右端点排序，为了方便转移，我们让 $l_0=r_0=-2\times 10^9$，即赋一个极小值。

令 $dp_i$ 为给 $i$ 染为红色的最小答案，显然我们需要枚举上一条染红色的线段 $j$ 来转移到 $i$。

则线段 $j(j<i)$ 能转移到 $dp_i$ 当且仅当它不与 $i$ 有交，且 $j+1\sim i-1$ 之间的线段要么与 $j$ 交要么与 $i$ 有交，因为它们染为黑色，必须和一条红色线段相交。

我们猜测对于 $i$，能转移到 $i$ 的线段编号构成了一个区间 $[x,y]$。

则 $y$ 显然为从右往左第一个使得 $r_y<l_i$ 的线段，那么 $x$ 就是使得 $r_x\ge\max_{k=0}^y l_k$ 的最小 $x$，因为排序后 $r$ 是单调的，所以都能二分出来，然后这个题显然可以再用线段树把复杂度优化成 $O(n \log_2 n)$。

所以转移方程就是，

$$dp_i=\min_{j=x}^y dp_j+r_i-l_i$$

需要注意到是并不是所有 $dp_i$ 对答案有贡献，$i$ 能对答案有贡献当且仅当 $r_i\ge\max_{j=i+1}^n l_j$，即可以与后面的线段都有交，不然就不合法了。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i,l,r) for(int i=(l);i<=(r);++i)
#define per(i,l,r) for(int i=(r);i>=(l);--i)
#define pr pair<int,int>
#define fi first
#define se second
#define pb push_back

#define N 1000010
#define int long long

const int lim=1e6+5;
int n,dp[N],mx[N];

struct ln{
    int l,r;
}a[N];

inline bool cmp(ln x,ln y){
    if(x.r!=y.r){
        return x.r<y.r;
    }

    return x.l<y.l;
}

struct SEGT{
    int tr[N<<2];

    inline void un(int k){
        tr[k]=min(tr[k*2],tr[k*2+1]);
    }

    inline void build(int k,int l,int r){
        if(l==r){
            tr[k]=1e17;
            return;
        }

        int mid=(l+r)>>1;

        build(k*2,l,mid);
        build(k*2+1,mid+1,r);

        un(k);
    }

    inline void upd(int L,int k,int l,int r,int d){
        if(l==r){
            tr[k]=d;
            return;
        }

        int mid=(l+r)>>1;

        if(L<=mid){
            upd(L,k*2,l,mid,d);
        }
        else{
            upd(L,k*2+1,mid+1,r,d);
        }

        un(k);
    }

    inline int ask(int L,int R,int k,int l,int r){
        if(L<=l&&R>=r){
            return tr[k];
        }

        int mid=(l+r)>>1,ans=1e17;

        if(L<=mid){
            ans=ask(L,R,k*2,l,mid);
        }
        if(R>mid){
            ans=min(ans,ask(L,R,k*2+1,mid+1,r));
        }

        return ans;
    }
}b;

inline int getr(int k){
    int l=0,r=k-1,mid,ans=-1;

    while(l<=r){
        mid=(l+r)>>1;

        if(a[mid].r<a[k].l){
            ans=mid;
            l=mid+1;
        }
        else{
            r=mid-1;
        }
    }

    return ans;
}

inline int getl(int R){
    int l=0,r=R,mid,ans=-1;

    while(l<=r){
        mid=(l+r)>>1;

        if(a[mid].r>=mx[R]){
            ans=mid;
            r=mid-1;
        }
        else{
            l=mid+1;
        }
    }

    return ans;
}

signed main(){
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);

    int lmx=-1e9;

    cin>>n;
    rep(i,1,n){
        cin>>a[i].l>>a[i].r;

        lmx=max(lmx,a[i].l);
    }

    sort(a+1,a+1+n,cmp);
    a[0].l=a[0].r=-2e9;

    int ans=1e17;

    b.build(1,0,lim);
    b.upd(0,1,0,lim,0);//dp[0]

    mx[0]=-2e9;
    rep(i,1,n){
        mx[i]=max(mx[i-1],a[i].l);
    }

    rep(i,1,n){
        int r=getr(i);
        int l=getl(r);

        if(r==-1||l==-1){
            continue;
        }

        dp[i]=b.ask(l,r,1,0,lim)+a[i].r-a[i].l;
        b.upd(i,1,0,lim,dp[i]);

        if(a[i].r>=lmx){
            ans=min(ans,dp[i]);
        }
    }
    
    cout<<ans;

    return 0;
}
```

---

## 作者：nullqtr_pwp (赞：1)

既然只与红色线段长度有关，那么我们 dp 就对着红色线段考虑。排序对答案没有影响，先让所有线段按照左端点排序。

令 $dp[i]$ 表示第 $i$ 条线段染成红色，且已经对编号为 $[1,i]$ 的所有线段染色的最小长度之和。

初始化，显然是 $dp[i]=+\infty,i>1$，以及 $dp[0]=0$。考虑转移。我们需要从所有可能的 $j$ 转移，有 $dp[i]\leftarrow dp[j]+r_i-l_i,j\text{ satisfy the condition}$。

考虑转移的条件。我们需要让编号为 $(j,i)$ 的所有线段均与红色线段有交点。显然我们要求这些线段的右端点均与 $[l_i,r_i]$ 有交，这是因为左端点已经排序。

考虑维护决策点 $j$。我们发现可以的决策点一定是一段连续的区间。我们找到 $p$，使得 $p$ 是最大的 $l_j$，满足 $[l_j,r_j]$ 不交于 $[l_i,r_i]$ 即 $r_j<l_i$。发现这段 $j$ 的区间是 $[p,r_i)$。我们可以从这段区间中的最小值转移，考虑数据结构维护 $dp$ 值。可以离散化后，拿线段树查询区间最小并且支持单点修改即可。

对于每个 $i$ 的 $p$，可以用树状数组维护前缀最大值。

时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ll long long
#define pb push_back
#define fi first
#define se second
#define inf 1e18
#define pii pair<int,int>
#define F(i,a,b) for(int i=a;i<=(b);i++)
#define dF(i,a,b) for(int i=a;i>=(b);i--)
#define wh(lzm) while(lzm--)
#define lowbit(x) (x&(-x))
#define HH printf("\n")
#define eb emplace_back
using namespace std;
int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*f;
}
const int maxn=1000005;
int n,m,lsh[maxn*2],dp[maxn];
struct seg{
	int l,r,len;
	bool operator<(const seg &a)const{
		return l<a.l;
	}
}a[maxn];
void chkmin(int &x,int y){
	x=min(x,y);
}
void chkmax(int &x,int y){
	x=max(x,y);
}
namespace BIT{
	int c[maxn*2];
	void add(int x,int y){
		for(;x<=m;x+=lowbit(x)) chkmax(c[x],y);
	}
	int query(int x){
		int rt=0;
		for(;x;x^=lowbit(x)) chkmax(rt,c[x]);
		return rt;
	}
}
using namespace BIT;
namespace segmenttree{
	int t[maxn<<2];
	#define ls (o<<1)
	#define rs (o<<1|1)
	void update(int o,int l,int r,int pos,int x){
		if(l==r) return chkmin(t[o],x),void();
		int mid=(l+r)>>1;
		(pos<=mid)?update(ls,l,mid,pos,x):update(rs,mid+1,r,pos,x);
		t[o]=min(t[ls],t[rs]);
	}
	int query(int o,int l,int r,int ql,int qr){
		if(ql>qr) return inf;
		if(ql<=l&&qr>=r) return t[o];
		int rt=inf,mid=(l+r)>>1;
		if(ql<=mid) rt=query(ls,l,mid,ql,qr);
		if(qr>mid) chkmin(rt,query(rs,mid+1,r,ql,qr));
		return rt;
	}
}
using namespace segmenttree;
signed main(){
	n=read();
	F(i,1,n) a[i].l=read(),a[i].r=read(),a[i].len=a[i].r-a[i].l;
	F(i,1,n) lsh[i]=a[i].l,lsh[i+n]=a[i].r;
	sort(lsh+1,lsh+2*n+1);
	int len=unique(lsh+1,lsh+2*n+1)-lsh-1;
	sort(a+1,a+n+1);
	F(i,1,n){
		a[i].l=lower_bound(lsh+1,lsh+len+1,a[i].l)-lsh;
		a[i].r=lower_bound(lsh+1,lsh+len+1,a[i].r)-lsh;
	}
	m=len;
	int ans=inf;
	F(i,1,(m+3)<<2) t[i]=inf;
	vector<int>fr(m+1,0);
	F(i,1,n) add(a[i].r,a[i].l);
	update(1,0,m,0,0);
	F(i,1,n){
		int l=a[i].l,r=a[i].r;
		int val=query(1,0,m,query(l-1),l-1)+a[i].len;
		//printf("%lld %lld %lld %lld\n",l,r,val,query(l-1));
		update(1,0,m,r,val);
		if(r>=a[n].l) chkmin(ans,val);
	}
	printf("%lld",ans);
}
```

---

## 作者：reductt (赞：0)

挺久以前写过的题了，复习发现竟然还能交题解，来贡献一发。

感觉这个题就是线段树优化 DP 板子啊。

---

**先把线段以右端点为第一关键字，左端点为第二关键字升序排一下，方便后面转移。（如果下面有哪处突然看不懂了，请回来看这句话）**

我们先来考虑 $O(n^2)$ 的做法怎么做。

设 $f_i$ 为第 $i$ 条线段为红色线段，考虑前 $i$ 条线段的答案。

可以枚举上一条红色线段 $j$，则 $f_i=\min\{f_j+len\}$，$len$ 就是线段 $i$ 的长度。

重点是 $j$ 什么时候是合法的。

- `任意两条红色不相交`，也就是 $r_j<l_i$。
- `任意一条黑色至少和一条红色相交。`，因为上一条红色线段是 $j$，也就是 $[j+1,i-1]$ 都是黑色线段，则 $[j+1,i-1]$ 这些线段要么与 $i$ 交，或者是 $j$。

我们设 $t$ 就是那个最大的 $j$ 满足 $r_j<l_i$，则 $[t+1,i-1]$ 这些黑色线段肯定都与 $i$ 有交。

也就是说 $j$ 要合法转移的话就是 $[j+1,t]$ 都与 $j$ 有交。

可以考虑记 $L_i$ 为 $[1,i]$ 中线段左端点的最大值，形式化地，$L_i=\max_{j=1}^{i} \{l_j\}$。则如果 $L_t \leq r_j$ 的话就可以转移，比较显然。

我们记 $s$ 为最小的 $j$ 满足 $L_t\leq r_j$。则 $[s,t]$ 都是合法的转移点。

$O(n^2)$ code，可以过掉 [弱化版](https://www.luogu.com.cn/problem/P8591)。

```cpp
const int N=5e5+10,INF=1e10;
struct Seg{int l,r,len;}seg[N];
int n,f[N],maxl[N];
signed main(){
	n=rd();
	FOR(i,1,n)seg[i].l=rd(),seg[i].r=rd(),seg[i].len=seg[i].r-seg[i].l;
	sort(seg+1,seg+n+1,[&](Seg s1,Seg s2){return s1.r!=s2.r?s1.r<s2.r:s1.l<s2.l;});
		
	memset(f,0x3f,sizeof(f)),maxl[0]=-INF;
	FOR(i,1,n)maxl[i]=max(maxl[i-1],seg[i].l);
	int ans=INF;
	FOR(i,1,n){
		int t=0;
		FOR_(j,1,i-1)if(seg[j].r<seg[i].l){t=j;break;}
		if(!t)f[i]=seg[i].len;//corner case，这样的话i这个线段就可以和[1,i-1]都交，只用i这一个就好了
		int s=t;
		FOR_(j,1,t)
			if(seg[j].r>=maxl[t])s=j;
			else break;
		FOR(j,s,t)ckmin(f[i],f[j]+seg[i].len);
		if(seg[i].r>=maxl[n])ckmin(ans,f[i]);
	}
	print(ans,'\n');
	return 0;
}
```

---

说实话我自己都感觉上面讲的 $O(n^2)$ 做法太磨叽了。

相信聪明的各位读者看到上文的 $[s,t]$ 应该已经会了。

如果你还是不会，往下看。

因为线段已经按 $r$ 值升序排过了，所以 $s,t$ 都可以直接二分。

然后就上一个线段树来查询 $[s,t]$ 中 $f$ 的最小值，支持单点修改，区间查询。

看到这里总该会了吧。。。

时间复杂度 $O(n\log n)$。code：


```cpp
const int N=5e5+10,INF=1e10;
struct SegTree{
	int minv[N<<2],ll[N<<2],rr[N<<2];
	void upd(int p,int x){ckmin(minv[p],x);}
	bool in(int l,int r,int p){return l<=ll[p]&&rr[p]<=r;}
	bool out(int l,int r,int p){return r<ll[p]||rr[p]<l;}
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
	void up(int p){minv[p]=min(minv[ls(p)],minv[rs(p)]);}
	void build(int l=0,int r=N-1,int p=1){
		ll[p]=l,rr[p]=r,minv[p]=INF;
		if(l==r)return;
		int mid=(l+r)>>1;
		build(l,mid,ls(p)),build(mid+1,r,rs(p));
	}
	void modify(int x,int k,int p=1){
		if(out(x,x,p))return;
		if(in(x,x,p))return upd(p,k),void();
		modify(x,k,ls(p)),modify(x,k,rs(p)),up(p);
	}
	int query(int l,int r,int p=1){
		if(out(l,r,p))return INF;
		if(in(l,r,p))return minv[p];
		return min(query(l,r,ls(p)),query(l,r,rs(p)));
	}
#undef ls
#undef rs
}ds;
struct Seg{int l,r,len;}seg[N];
int n,f[N],maxl[N];
signed main(){
	n=rd();
	FOR(i,1,n)seg[i].l=rd(),seg[i].r=rd(),seg[i].len=seg[i].r-seg[i].l;
	sort(seg+1,seg+n+1,[&](Seg s1,Seg s2){return s1.r!=s2.r?s1.r<s2.r:s1.l<s2.l;});
		
	memset(f,0x3f,sizeof(f)),maxl[0]=-INF,ds.build();
	FOR(i,1,n)maxl[i]=max(maxl[i-1],seg[i].l);
	int ans=INF;
	FOR(i,1,n){
		int L=1,R=i,t=0,s=0;
		while(L<R){
			int mid=(L+R)>>1;
			if(seg[mid].r<seg[i].l)L=mid+1,t=mid;
			else R=mid;
		}
		if(!t)f[i]=seg[i].len;
		
		L=1,R=t,s=t;
		while(L<R){
			int mid=(L+R)>>1;
			if(seg[mid].r>=maxl[t])R=mid,s=mid;
			else L=mid+1;
		}	
		ckmin(f[i],ds.query(s,t)+seg[i].len);
		ds.modify(i,f[i]);
		if(seg[i].r>=maxl[n])ckmin(ans,f[i]);
	}
	print(ans,'\n');
	return 0;
}
```

~~怎么感觉这篇题解有点头重脚轻~~

---

## 作者：Targanzqq (赞：0)

主要思路：单调队列优化 dp。

### Part 1：设计 dp 状态

我们设的状态和其他大佬们的差不多，仍然是用 $f_i$ 表示按**左端点排序**后，第 $i$ 条及以前的线段都已经染色完，且第 $i$ 条线段染成**红色**的最小代价。

假设上一条可以被染成红色的线段为 $j$，我们需要满足 $r_j<l_i$，与 $[l_j,r_i]$ 相交的其它线段都与 $i,j$ 相交。也就是说不存在一条黑色线段 $k$ 满足 $l_k>r_j$ 且 $r_k<l_i$，因此我们找到 $r_k<l_i$ 且 $l_k$ 最大的 $k$ 对于所有合法的 $j$，满足 $r_j\ge l_k$。因此 $f_i=len_i+\min\limits_{r_j\ge l_k,r_j\le l_i}f_j$。

但是如果我们枚举所有的 $j$，它的时间复杂度是 $O(n^2)$ 的。我们考虑优化找最小 $f_j$ 的过程。

我们发现，如果我们按照右端点排序，所有能满足条件的线段是连续的。如果我们按照左端点排序，所有的 $pos_i$ 是单调不降的。难点转化为把这两个性质合并起来。

我们考虑到，每条线段实际端点的位置并不需要关心，我们只关心它们的**长度**以及与其它线段的**相交情况**。因此我们可以先离散化。离散化以后，我们对 $f_i$ 做一下修改：$f_i$ 表示离散化后如果第 $i$ 个位置有一条线段的**右端点**，这条线段及**左端点**在这条线段以前的其它线段已经染色完成，且这条线段被染成**红色**的最小代价。

这样上面两个性质在离散化后的值域上都成立。因此我们使用双指针，$i$ 表示当前枚举到的右端点，$pos$ 表示当前枚举到的满足 $r_j<l_i$ 的线段右端点 $r_j$，同时记录一个 $maxn$ 表示上面的 $k$，即以 $i$ 为右端点的线段的 $k$。我们还需要预处理出 $h_i$ 表示以 $i$ 为右端点的线段对应的左端点。这是所有需要记录的数据。

这样我们就可以轻松维护 $j\in[pre,i]$ 的所有 $f_j$ 的最小值，不难想到线段树，但是我们每次查询的左右端点都是单调不降的，所以我们使用一种好写，时间复杂度低，但是不好理解而且直接用起来不是很方便的数据结构——单调队列。

### Part 2：单调队列详解
单调队列常用到一个条件，一个性质和两个操作。一个条件是查询范围**连续**且左右端点**位置单调不减**，一个性质是队列内的所有元素都满足**单调递增**或**单调递减**，两个操作是从**队头**弹出不在范围内的元素，以及从**队尾**维护单调性。由于每个元素只会进队和出队**各一次**，因此单调队列的时间复杂度是 $O(n)$ 的。

我们先考虑维护单调性。因为我们要在过程中维护，因此我们假设队列中的元素具有单调性。当我们加入元素时，会弹出所有队尾相对于当前元素不优的所有元素。也就是说弹出所有需要弹出元素后，其余元素与位于队尾的当前元素保持单调性不变。当我们删除队头元素时，单调性显然保持不变。

然后我们考虑查询。首先我们考虑到，队列里的元素下标显然是单调递增的，因此我们从队头弹出元素，直到队头元素在范围内，这个元素一定是最优的。比如说我们需要求最小值，那我们维护单调递增，在从队头弹出所有不在范围内的元素后，此时队头的元素一定是范围内的最小值，如果求最大值则维护单调递减。

**正确性证明**：我们试图将一个元素放进队内时，会删除所有**不比它更优**的元素，而对于每个元素我们都删掉了它前面不比它更优的元素，并且不会被后面不如它优的元素删除，且队内维护了单调性（如果求**最小值**则维护单调**递增**，如果求**最大值**则维护单调**递减**），因此队头的元素一定是最优的。

对于这个题我们需要按左端点排序后，枚举每一条线段，并查询 $j\in[pre,i]$ 的所有 $f_j$ 的最小值，因此我们将值域上每个点的答案都使用单调队列更新（如果没有线段以这个点为右端点，那么这个点的答案不会被更新，也就是 $+∞$）。

更新贡献的方式是将 $pos$ 向右移动，直到  $pos=l_i-1$，此时我们加入了原来的 $pos$ 到 $l-1$ 中所有点的贡献。然后我们维护 $maxn$，具体来说就是在更新 $pos$ 的同时将 $maxn$ 更新为所有枚举到的线段右端点所对应的左端点的最大值。这样我们就找到了更新答案的左端点。然后我们将队列中所有小于这个左端点的值都弹出队列，这样我们得到的队头就是上面需要求的 $\min\limits_{r_j\ge l_k,r_j\le l_i}f_j$。然后我们把这个值加上 $len_i$ 的长度，就是我们所求的 $f_i$。

最后我们需要求答案。最后一个线段的颜色不确定，因此上一条红色线段可以是所有与它相交的点或它自己。因此如果当前线段和最后一条线段相交，那么我们可以用当前的 $f_i$ 去更新 $ans$。

总时间复杂度 $O(n\log n)$，复杂度瓶颈在于离散化和排序。

源代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define INF 1e9+7
#define N 1000005
#define em q.empty()
using namespace std;

int n;
struct segment{
	int l,r,len;
	friend bool operator<(segment a,segment b){
		return a.r<b.r;
	}
}a[N];
bool mycmp(segment a,segment b){
	return a.l<b.l;
}
int p[2*N],h[2*N],top;

int binary(int x,int l,int r){
	while(1){
		if(l>r)break;
		int mid=(l+r)/2;
		if(p[mid]<x)l=mid+1;
		else r=mid-1;
	}
	if(p[l]==x)return l;
	else return r;
}

void lsh(){
    for(int i=1;i<=n;i++)p[++top]=a[i].l,p[++top]=a[i].r;
	sort(p+1,p+top+1);
	int len=unique(p+1,p+top+1)-p-1; 
	for(int i=1;i<=n;i++){
		a[i].l=binary(a[i].l,1,len);
		a[i].r=binary(a[i].r,1,len);
	}
}

int f[2*N];
deque<int> q;

signed main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].l>>a[i].r;
		a[i].len=a[i].r-a[i].l;
	}
	sort(a+1,a+n+1,mycmp);
	lsh();
	int ans=INF;
	for(int i=1;i<=2*n;i++)f[i]=INF;
	for(int i=1;i<=n;i++)h[a[i].r]=a[i].l;
	f[0]=0;q.push_back(0);
	for(int i=1,pos=1,maxn=0;i<=n;i++){
	    while(pos<a[i].l){
	        maxn=max(maxn,h[pos]);
			while(!em&&f[q.back()]>=f[pos])q.pop_back();
			q.push_back(pos++);
		}
		while(!em&&q.front()<maxn)q.pop_front();
	    f[a[i].r]=min(f[a[i].r],f[q.front()]+a[i].len);
	    if(a[i].r>=a[n].l)ans=min(ans,f[a[i].r]);
	}
	cout<<ans;
}
```

对了，最后再提一句，梦熊的数据直接写很可能会 TLE，我当时被卡了两个小时，然后我在脑子不清醒的状态下把 $sort$ 换了个位置，就神奇的过了，有谁可以解释一下吗？

---


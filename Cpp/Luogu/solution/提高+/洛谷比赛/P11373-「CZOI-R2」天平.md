# 「CZOI-R2」天平

## 题目描述

你有 $n$ 个**砝码组**，编号为 $1$ 至 $n$。对于第 $i$ 个**砝码组**中的砝码有共同的正整数质量 $a_i$，每个**砝码组**中的**砝码**数量无限。

其中，有 $q$ 次操作：

- `I x v`：在第 $x$ 个**砝码组**后新增一组单个**砝码**质量为 $v$ 的**砝码组**，当 $x=0$ 时表示在最前面新增；
- `D x`：删除第 $x$ 个**砝码组**；
- `A l r v`：把从 $l$ 到 $r$ 的所有**砝码组**中的砝码质量加 $v$；
- `Q l r v`：判断能否用从 $l$ 到 $r$ 的**砝码组**中的砝码，称出质量 $v$。每个砝码组中的砝码可以使用任意个，也可以不用。

对于操作 `I` 和 `D`，操作后编号以及 $n$ 的值自动变化。

称一些**砝码**可以称出质量 $v$，当且仅当存在将这些砝码分别放在天平两边的摆放方法，使得将 $1$ 个质量为 $v$ 的物体摆放在某边可以让天平平衡。

## 说明/提示

**【样例解释】**

对于样例组 $1$，最后有 $5$ 个中的**砝码组**，质量分别为 $5,18,9,16,2$。在天平左边放上 $1$ 个**砝码组一**中的**砝码**，右边放上 $1$ 个**砝码组三**的砝码，即可称出质量 $4$。

![](https://cdn.luogu.com.cn/upload/image_hosting/lwd6643t.png)

**【数据范围】**

**本题采用捆绑测试**。

记 $m_1$ 为所有时刻中 $a_i$ 与 $v$ 的最小值，$m_2$ 为所有时刻中 $a_i$ 与 $v$ 的最大值。

- Subtask #1（$5\text{ pts}$）：$1\le n,q\le 10$，$1\le m_1\le m_2 \le50$。
- Subtask #2（$15\text{ pts}$）：$1\le n,q\le 4\times10^2$。
- Subtask #3（$20\text{ pts}$）：没有操作 `I` 与操作 `D`。
- Subtask #4（$60\text{ pts}$）：无特殊性质。

对于 $100\%$ 的数据，$1\le n,q\le 10^5$，$1\le m_1\le m_2\le 10^{18}$，保证所有操作合法，且任意时刻至少存在一个砝码组。

## 样例 #1

### 输入

```
5 5
1 10 8 4 2
I 2 1
A 1 4 4
A 2 4 4
D 5
Q 1 4 4```

### 输出

```
YES```

## 样例 #2

### 输入

```
10 10
2 2 1 4 2 10 8 7 10 6
Q 5 6 1
Q 5 7 7
I 5 1
Q 4 5 3
Q 2 9 2
A 3 5 1
Q 7 8 5
D 7
A 3 9 7
Q 3 7 6```

### 输出

```
NO
NO
NO
YES
NO
YES```

# 题解

## 作者：A6n6d6y6 (赞：8)

## 「CZOI-R2」天平 题解

### 题目分析

首先解决如何判断一个质量是否能被表出的问题。

形式化的，需要判断是否存在一个序列 $c$，满足 $\forall c_i\in \Z$，使得 $a_lc_l+a_{l+1}c_{l+1}+\cdots+a_rc_r=v$。

这是裴蜀定理可以推广到 $n$ 个整数的情形，存在序列 $c$ 当且仅当 $\gcd\{a_l,a_{l+1},\cdots,a_r\}\mid v$。

所以只需判断 $v$ 是否是 $\gcd\{a_l,a_{l+1},\cdots,a_r\}$ 的倍数即可。

### 实现方法

#### SubTask #1

留给没有看出转化成 $\gcd$ 问题的人，暴力 dfs 也许能拿到？

#### SubTask #2

因为 $1\le n,q\le 4\times 10^2$，所以可以暴力维护所有操作，时间复杂度 $O(qn\log m)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define GCD __gcd
using namespace std;
int n,q;vector<int>f;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	f.push_back(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++){
		int a;cin>>a;
		f.push_back(a);
	}
	while(q--){
		char op;cin>>op;
		if(op=='I'){
			int x,v;cin>>x>>v;
			f.insert(f.begin()+x+1,v);
		}
		if(op=='D'){
			int x;cin>>x;
			f.erase(f.begin()+x);
		}
		if(op=='A'){
			int l,r,v;cin>>l>>r>>v;
			for(int i=l;i<=r;i++)f[i]+=v;
		}
		if(op=='Q'){
			int l,r,v;cin>>l>>r>>v;
			int g=0;
			for(int i=l;i<=r;i++)g=GCD(g,f[i]);
			cout<<(v%g?"NO":"YES")<<endl; 
		}
	}
	return 0;
}
```

#### SubTask #3

没有插入和删除，可以使用线段树静态查询，思考如何实现区间 $\gcd$。

这里我们可以配合差分过后的序列 $b$ 维护区间 $\gcd$，思考一下为什么：

$$
\gcd\{a\}=\gcd\{\gcd\{a_1,a_2\},\gcd\{a_2,a_3\},\cdots,\gcd\{a_{n-1},a_n\}\}
$$
又因**更相减损术**（古人的智慧）：$\gcd(x,y)=\gcd(x,y-x)$，可以得到

$$
\gcd\{a\}=\gcd\{\gcd\{a_1,a_2-a_1\},\gcd\{a_2,a_3-a_2\},\cdots,\gcd\{a_{n-1},a_n-a_{n-1}\}\}
$$

发现 $a_2,a_3,\cdot\cdot\cdot,a_{n-1}$ 已经被左边两项囊括，所以原式等于 $\gcd\{a_1,b_2,b_3,\cdots,b_n\}$。

这可以推广到左端点和右端点任意的情况，于是我们在上的每一个节点分别存原值、差分后的值、差分后的值的 $\gcd$，最后每次询问回答 $\gcd(a_l,\gcd\{b_{l+1},b_{l+2},\cdots,b_r)$ 的值就行了。

时间复杂度：$O((n+q\log n)\log m)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define GCD __gcd
using namespace std;
const int maxn=1e6+10;
struct tree{int sum,gcd;}t[maxn<<2];
int n,q,a[maxn];
int ls(int p){return p<<1;}
int rs(int p){return p<<1|1;}
void pushup(int p){t[p]={t[ls(p)].sum+t[rs(p)].sum,GCD(t[ls(p)].gcd,t[rs(p)].gcd)};}
void build(int l,int r,int p){
	if(l==r)return t[p]={a[l]-a[l-1],a[l]-a[l-1]},void();
	int mid=(l+r)>>1;
	build(l,mid,ls(p)),build(mid+1,r,rs(p)),pushup(p);
}
void update(int l,int r,int k,int v,int p){
	if(l==r){
		t[p].sum+=v,t[p].gcd+=v;
		return;
	}
	int mid=(l+r)>>1;
	if(k<=mid)update(l,mid,k,v,ls(p));
	else update(mid+1,r,k,v,rs(p));
	pushup(p);
}
int qsum(int l,int r,int le,int ri,int p){
	if(l>=le&&r<=ri)return t[p].sum;
	int mid=(l+r)>>1;int ans=0;
	if(le<=mid)ans+=qsum(l,mid,le,ri,ls(p));
	if(ri>mid)ans+=qsum(mid+1,r,le,ri,rs(p));
	return ans;
}
int qgcd(int l,int r,int le,int ri,int p){
	if(l>=le&&r<=ri)return t[p].gcd;
	int mid=(l+r)>>1;int ans=0;
	if(le<=mid)ans=GCD(ans,qgcd(l,mid,le,ri,ls(p)));
	if(ri>mid)ans=GCD(ans,qgcd(mid+1,r,le,ri,rs(p)));
	return ans;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++)cin>>a[i];
	build(1,n,1);
	while(q--){
		char op;int l,r,v;
		cin>>op>>l>>r>>v;
		if(op=='A'){
			update(1,n,l,v,1);
			if(r!=n)update(1,n,r+1,-v,1);
		}
		if(op=='Q'){
			int g=abs(GCD(qgcd(1,n,l+1,r,1),qsum(1,n,1,l,1)));
			cout<<(v%g?"NO\n":"YES\n");
		}
	}
	return 0;
}
```

#### SubTask #4

换成平衡树维护序列，这里采用无旋 treap，这里讲一些实现细节。

首先，这道题目空间并不紧张，你可以不用平衡树节点回收（虽然 std 用了）。

其次，分裂和合并的时候不要无脑复制粘贴（std因为这个锅了一次），对于特殊情况要注意分类讨论。

时间复杂度：$O((n+q)\log n\log m)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define GCD __gcd
using namespace std;
const int maxn=2e5+10;
struct Treap{
	int rt,cnt,num[maxn],val[maxn],gcd[maxn],ls[maxn],rs[maxn],siz[maxn],plz[maxn],rnd[maxn];
	queue<int>del;mt19937 maker;
	Treap(){maker.seed(time(0));}
	int newnode(int x){
		int idx;
		if(del.empty()){idx=++cnt;}else{idx=del.front(),del.pop();}
		num[idx]=x;siz[idx]=1;ls[idx]=rs[idx]=plz[idx]=0;rnd[idx]=maker();
		return idx; 
	}
	void pushdown(int x){
		if(ls[x])num[ls[x]]+=plz[x],plz[ls[x]]+=plz[x];
		if(rs[x])num[rs[x]]+=plz[x],plz[rs[x]]+=plz[x];
		plz[x]=0;
	}
	void pushup(int x){
		siz[x]=siz[ls[x]]+siz[rs[x]]+1;
		gcd[x]=GCD(GCD(gcd[ls[x]],gcd[rs[x]]),val[x]);
	}
	void split(int x,int k,int &rt1,int &rt2){
		if(!x){rt1=rt2=0;return;}
		pushdown(x);
		if (siz[ls[x]]<k)rt1=x,split(rs[x],k-siz[ls[x]]-1,rs[x],rt2);
		else rt2=x,split(ls[x],k,rt1,ls[x]);
		pushup(x);
	}
	int merge(int x,int y){
		if(!x||!y)return x+y;
		pushdown(x),pushdown(y);
		if(rnd[x]<rnd[y]){ls[y]=merge(x,ls[y]),pushup(y);return y;}
		else{rs[x]=merge(rs[x],y),pushup(x);return x;}
	}
	int getidx(int x){
		int rt1,rt2,rt3,ans;
		split(rt,x-1,rt1,rt2),split(rt2,1,rt2,rt3),ans=rt2;
		rt=merge(merge(rt1,rt2),rt3);
		return ans;
	}
	int getgcd(int l,int r){
		int rt1,rt2,rt3,ans;
		split(rt,l-1,rt1,rt2),split(rt2,r-l+1,rt2,rt3),ans=gcd[rt2];
		rt=merge(merge(rt1,rt2),rt3);
		return ans;
	}
	void insert(int x,int y){
		int rt1,rt2,rt3,node=newnode(y);
		val[node]=gcd[node]=y-num[getidx(x)];
		split(rt,x,rt1,rt3),split(rt3,1,rt2,rt3);
		if(rt2)val[rt2]=gcd[rt2]=num[rt2]-y;
		rt=merge(merge(rt1,node),merge(rt2,rt3));
	}
	void remove(int x){
		int rt1,rt2,rt3,tmp=num[getidx(x-1)];
		split(rt,x,rt1,rt2),split(rt2,1,rt2,rt3),val[rt2]=gcd[rt2]=num[rt2]-tmp;
		rt=merge(merge(rt1,rt2),rt3);
		split(rt,x-1,rt1,rt2),split(rt2,1,rt2,rt3),del.push(rt2);
		rt=merge(rt1,rt3);
	}
	void update(int l,int r,int x){
		int rt1,rt2,rt3;
		split(rt,l-1,rt1,rt2),split(rt2,r-l+1,rt2,rt3);
		num[rt2]+=x,plz[rt2]+=x,rt=merge(merge(rt1,rt2),rt3);
		split(rt,l-1,rt1,rt2),split(rt2,1,rt2,rt3);
		val[rt2]+=x,gcd[rt2]+=x,rt=merge(merge(rt1,rt2),rt3);
		split(rt,r,rt1,rt2),split(rt2,1,rt2,rt3);
		if(rt2)val[rt2]-=x,gcd[rt2]-=x;
		rt=merge(merge(rt1,rt2),rt3);
	}
	int query(int l,int r){return GCD(num[getidx(l)],getgcd(l+1,r));}
}t;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int n,q;cin>>n>>q;
	for(int i=1;i<=n;i++){
		int a;cin>>a;t.insert(i-1,a);
	}
	while(q--){
		char op;cin>>op;
		if(op=='I'){
			int x,v;cin>>x>>v;
			t.insert(x,v);
		}if(op=='D'){
			int x;cin>>x;
			t.remove(x);
		}if(op=='A'){
			int l,r,v;cin>>l>>r>>v;
			t.update(l,r,v);
		}if(op=='Q'){
			int l,r,v;cin>>l>>r>>v;
			cout<<(v%t.query(l,r)?"NO\n":"YES\n");
		}
	}
	return 0;
}
```

---

## 作者：破壁人罗辑 (赞：1)

### 题意简述

给出一个序列 $a$，可以进行增、删、区间加和询问操作。询问操作为给定 $v$ 问是否存在一组解 $x_l,x_{l+1},\cdots,x_r$，使得 $\sum_{i=l}^ra_ix_i=v$.

### 前置数学知识

#### 辗转相除法

$$\gcd(a,b)=\gcd(b-a,a)=\begin{cases}
b,&a=0\\
\gcd(b\bmod a,a),&a\neq0
\end{cases}$$

#### 裴蜀定理

关于 $x_1,x_2,\cdots,x_n$ 的方程 $\sum_{i=1}^na_ix_i=b$，$a_i,b\in\mathbb{Z}$ 有整数解的充要条件是 $\gcd(a_1,a_2,\cdots,a_n)\mid b$.

### 解题思路

根据翡蜀定理，每次询问操作相当于问区间最大公约数是否能整除给定的值。

能够使用 $O(\log n)$ 进行区间修改、增、删、查的数据结构最经典的就是平衡树。

假设进行 $[l,r]$ 区间加操作前的序列为 $a$，操作后的序列为 $a'$，则可以发现 $\gcd(a_l-a_{l+1},a_{l+1}-a_{l+2},\cdots,a_{r-1}-a_r)=\gcd(a'_l-a'_{l+1},a'_{l+1}-a'_{l+2},\cdots,a'_{r-1}-a'_r)$，而根据辗转相除法的原理，$\forall i\in[l,r],\gcd(a_l,a_{l+1},\cdots,a_r)=\gcd(a_i,\gcd(a_l-a_{l+1},a_{l+1}-a_{l+2},\cdots,a_{r-1}-a_r))$.

所以我们可以使用平衡树，每个节点维护两个值：序列中的一个值、子树区间的差值的最大公约数。

为了单次操作都是 $O(\log n)$，区间加需要使用懒标记。

总时间复杂度 $O(n\log n)$.

### AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int root,tot;
struct node{
    int siz,cc,ls,rs;
	long long val,gcd,tag;
}nd[200010];
long long a[100000];
long long gcd(long long a,long long b){return a?gcd(b%a,a):b;}
void pushdown(int x){//标记下传
	nd[x].val+=nd[x].tag;
	if(nd[x].rs)nd[nd[x].rs].tag+=nd[x].tag;
	if(nd[x].ls)nd[nd[x].ls].tag+=nd[x].tag;
	nd[x].tag=0;
}
void update_gcd(int n){//更新区间差值gcd
	if(nd[n].tag)pushdown(n);
	if(nd[n].ls&&nd[nd[n].ls].tag)pushdown(nd[n].ls);
    if(nd[n].rs&&nd[nd[n].rs].tag)pushdown(nd[n].rs);
    nd[n].gcd=gcd(nd[n].ls?gcd(nd[nd[n].ls].gcd,abs(nd[nd[n].ls].val-nd[n].val)):0
				,nd[n].rs?gcd(nd[nd[n].rs].gcd,abs(nd[nd[n].rs].val-nd[n].val)):0);
}
void split(int n,int siz,int &L,int &R){//分裂
    if(!n){L=R=0;return;}
    if(nd[n].siz==siz){L=n;R=0;return;}
    if(!siz){L=0;R=n;return;}
    if(nd[n].tag)pushdown(n);
    if((nd[n].ls?nd[nd[n].ls].siz:0)==siz)
    {L=nd[n].ls;R=n;nd[n].ls=0;}
    else if((nd[n].ls?nd[nd[n].ls].siz:0)<siz)
    {L=n;split(nd[n].rs,siz-(nd[n].ls?nd[nd[n].ls].siz:0)-1,nd[n].rs,R);}
    else{R=n;split(nd[n].ls,siz,L,nd[n].ls);}
    nd[n].siz=1+(nd[n].ls?nd[nd[n].ls].siz:0)+(nd[n].rs?nd[nd[n].rs].siz:0);
    update_gcd(L);update_gcd(R);
}
int merge(int L,int R){//合并
    if(!(L&&R))return L|R;
    if(nd[L].tag)pushdown(L);
	if(nd[R].tag)pushdown(R);
    if(nd[L].cc<nd[R].cc){
        nd[L].rs=merge(nd[L].rs,R);
        nd[L].siz=1+(nd[L].ls?nd[nd[L].ls].siz:0)+(nd[L].rs?nd[nd[L].rs].siz:0);
        update_gcd(L);
        return L;
    }
    else{
        nd[R].ls=merge(L,nd[R].ls);
        nd[R].siz=1+(nd[R].ls?nd[nd[R].ls].siz:0)+(nd[R].rs?nd[nd[R].rs].siz:0);
        update_gcd(R);
        return R;
    }
}
int build(long long *L,int n,int cc=-1000000000){
//从数组区间建树
    if(!n)return 0;
    int r=++tot;
    nd[r].val=L[n>>1];nd[r].cc=cc+1+rand();nd[r].tag=0;
    nd[r].ls=build(L,n>>1,nd[r].cc);
    nd[r].rs=build(L+(n>>1)+1,n-1-(n>>1),nd[r].cc);
    nd[r].siz=1+(nd[r].ls?nd[nd[r].ls].siz:0)+(nd[r].rs?nd[nd[r].rs].siz:0);
    nd[r].gcd=gcd(nd[r].ls?gcd(nd[nd[r].ls].gcd,abs(nd[nd[r].ls].val-nd[r].val)):0,
				nd[r].rs?gcd(nd[nd[r].rs].gcd,abs(nd[nd[r].rs].val-nd[r].val)):0);
    return r;
}
long long check_gcd(int Lsiz,int Rsiz){
//查询区间[Lsiz,Rsiz]的gcd
    int L,M,R;
    split(root,Rsiz,M,R);split(M,Lsiz-1,L,M);
    long long ret=gcd(nd[M].gcd,nd[M].val+nd[M].tag);
    root=merge(L,merge(M,R));
    return ret;
}
void add(long long val,int Lsiz,int Rsiz){
//[Lsiz,Rsiz]区间加
	int L,M,R;
    split(root,Rsiz,M,R);split(M,Lsiz-1,L,M);
	nd[M].tag+=val;
    root=merge(L,merge(M,R));
}
void insert(int pos,long long val){
//插入
    int L,R;
    split(root,pos,L,R);
    nd[++tot].cc=rand();nd[tot].siz=1;
    nd[tot].val=val;
	nd[tot].gcd=nd[tot].tag=nd[tot].ls=nd[tot].rs=0;
    root=merge(L,merge(tot,R));
}
void del(int pos){
//删除
    int L,M,R;
    split(root,pos-1,L,M);split(M,1,M,R);
    root=merge(L,R);
}
int main(){
	int n,q;scanf("%d%d",&n,&q);
	for(int i=0;i<n;i++)scanf("%lld",a+i);
	root=build(a,n);
	while(q--){
		char c=getchar();
		while(c<'A'||c>'Q')c=getchar();
		if(c=='I'){
			int x;long long v;scanf("%d%lld",&x,&v);
			insert(x,v);n++;
		}else if(c=='D'){
			int x;scanf("%d",&x);
			del(x);n--;
		}else if(c=='A'){
			int l,r;long long v;scanf("%d%d%lld",&l,&r,&v);
			add(v,l,r);
		}else{
			int l,r;long long v;scanf("%d%d%lld",&l,&r,&v);
			puts(v%check_gcd(l,r)==0?"YES":"NO");
		}
	}
	return 0;
}
```

---


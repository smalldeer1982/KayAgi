# 「RiOI-6」帝国少女

## 题目背景

![](bilibili:BV1Ni4y1g7oN)

小萝卜喜欢帽子哥哥。有多喜欢呢？每次和他出去玩都要计划好久的！

萝卜呢，有很多件好看的衣服。因此计划的一部分就是：每次出去玩都和上次穿的不一样。

可是原先的计划表非常不合理，因此小萝卜需要花很多时间来修改。因为出去玩的时间非常宝贵，所以她认为修改次数要尽量小。

## 题目描述

萝卜有 $m$ 件衣服，计划表为长为 $n$ 的序列 $a$，则 $a_i$ 为 $[1,m]$ 中的整数，表示当天穿的是哪一件衣服。**萝卜保证他的衣服至少有两件。**

萝卜每次修改可以将 $a_i$ 修改为 $[1,m]$ 中任何一个整数。对于一个序列 $a$，他的**困难程度**定义为：使得 $a_1,a_2,\cdots,a_n$ 中任意相邻两个数都不同的最小操作次数。设这个值为 $f(a,m)$。

对于序列 $a$，萝卜想请你求出其所有子段的困难程度之和，即：

$$\sum_{1\le l\le r\le n}f([a_l,a_{l+1},\cdots,a_r],m)$$

## 说明/提示

**【样例解释】**

对于样例 $1$ 的整个原序列，一种最优的修改方案是将其修改为 $[2,1,2,1,2,1,2,1,2,1]$，修改次数是 $4$，故困难程度为 $4$。

对于样例 $2$，所有子段及其困难程度如下：

- $[2]$，困难程度为 $0$。
- $[2,2]$，困难程度为 $1$。
- $[2,2,3]$，困难程度为 $1$。
- $[2]$，困难程度为 $0$。
- $[2,3]$，困难程度为 $0$。
- $[3]$，困难程度为 $0$。

故总和为 $2$。

对于样例 $3$，暂时不能给你一个明确的答复。

**【数据范围】**

**本题开启捆绑测试。**

|子任务|分数|$n\le$|$m\le$|特殊性质|
|:-:|:-:|:-:|:-:|:-:|
|$1$|$10$|$10$|$10$||
|$2$|$20$|$10^3$|$10^9$||
|$3$|$30$|$2\times10^5$|$10^9$|$m>2$|
|$4$|$40$|$2\times10^5$|$10^9$||

对于 $100\%$ 的数据，$1\le n\le 2\times10^5$，$2\le m\le 10^9$。

## 样例 #1

### 输入

```
10 2
1 1 2 2 2 1 1 2 2 1
```

### 输出

```
81```

## 样例 #2

### 输入

```
3 3
2 2 3
```

### 输出

```
2```

## 样例 #3

### 输入

```
30 30
26 4 4 4 20 28 13 13 2 2 2 2 2 24 24 24 24 24 24 24 29 29 29 29 29 2 2 2 2 2
```

### 输出

```
1905```

# 题解

## 作者：Cybher (赞：7)

# P12391 「RiOI-6」帝国少女 题解

## 思路产生

首先显然 $m>2$ 和 $m=2$ 是两种情况需要分讨。

### 我们先考虑 $m>2$ 的情况：

有一个贪心策略就是对于任意一段相同的数的连续段，都把在这个连续段中的偶数位的数变成一个不同于其左右相邻的数。

比如 `2 1 1 1 1 1 1 2` 就要变成 `2 1 2 1 2 1 3 2`。

这个贪心策略的正确性是显然的，因为对于任意一对相邻且相同的数，都要选择一个选择其中一个，给成另一个数字，因为我们的可以选择换成的数字至少有 $3$ 个，一定可以做到改完后和左右相邻的数各不相同。我们只需要考虑怎么做可以让相邻的数对尽可能少。对于奇数长度的段我们都改变偶数位的数一定更优的，而对于偶数长度的段我们改变偶数位的数一定是不劣的。

有了贪心策略，我们就要想怎么才能在时间复杂度限制内求出答案。

我们考虑每一个数对会对多少个子段产生贡献。我们求出来每一个子段的左端点的有多少种取法，右端点有多少种取法，这样根据乘法原理，我们就能求出来能让点对做出贡献的子段数。

对于右端点，只要大于等于点对的右端点是都能取的。

对于左端点，在小于点对左端点的同时，还要满足让点对的右端点成为一段连续相同的数的连续段的偶数位。

这些都是可求的，根据连续段长度奇偶分讨一下就好了。

### 我们接下来考虑 $m=2$ 的情况

$m=2$ 和 $m>2$ 的情况有一个显著的不同就是：可以选择换成的数字只有了两种选择，这样就会导致我们贪心策略出现问题，因为你无法保证只把连续段的偶数换成另一个数就能保证合法。

比如按照原来的贪心策略：`2 1 1 1 1 1 1 2` 就要变成 `2 1 2 1 2 1 2 2` 然后你就发现假了。

这该怎么办？

考虑把所有的 $2$ 都替换成 $0$，这样对于一个子区间，我们都要转换成 $0101010 \dots$ 或者 $1010101\dots$

感觉 $01$ 交替有点抽象。我们直接把原序列上的所有偶数位的数全部都 $01$ 反转，这样我们就只需要求把一段区间变成全 $1$ 或者全 $0$ 就好了。

这样我们又有了一个贪心策略：对于一个子区间，$1$ 的个数多就把区间所有 $0$ 变成 $1$， $0$ 的个数多就把区间所有 $1$ 变成 $0$。

那么我们就把题转化成了求：

$$\sum\limits_{i=1}^{n}\sum\limits_{j=i}^{n}\operatorname{g}(i,j)$$

这里 $\operatorname{g}(i,j)$ 表示对于从 $i$ 到 $j$ 的子区间，$0$ 的个数和 $1$ 的个数较小值。

我们前缀和分别维护出区间 $0$ 和 $1$ 的个数，然后枚举区间，这样 $O(n^2)$ 的做法就做好了，拿到 $60$ 分。

考虑优化。设子区间有 $a$ 个 $0$ 和 $b$ 个 $1$，那么有：
$$\min(a,b)=\dfrac{a+b-|a-b|}2$$
而我们要求的所有子区间最小值之和可转化为：
$$\dfrac{(\sum (a+b) - \sum |a+b|)}2$$

其中 $\sum (a+b)$ 代表的是所有子区间长度之和，$\sum (a+b)$ 代表的是所有子区间 $0$ 和 $1$ 数量差的绝对值之和。

对于前者我们发现长度为 $1$ 的区间有 $n$ 个，长度为 $2$ 的区间有 $n-1$ 个，长度为 $3$ 的区间有 $n-2$ 个，以此类推……

那么前者其实就是：

$$ \sum\limits_{i=1}^n i\times(n-i+1)\\
=\sum\limits_{i=1}^nn\times i-\sum\limits_{i=1}^ni^2+\sum\limits_{i=1}^n i\\
=\frac{n(n+1)^2}2-\frac{n(n+1)(2n+1)}{6}+\frac{n(n+1)}{2}\\
=\frac{n(n+1)(n+2)}{2}
$$

那么下面就是求后者了。

我们再进行进一步的转化：

将 $0$ 视作 $-1$，则子区间的 $1$ 和 $0$ 的个数差就等于该区间的和。我们再做一下前缀和。设前缀和数组为 $s$ 问题就又转换成了对于所有的 $i<j$ 的 $|s[j]-s[i]|$ 的和。

我们考虑拆绝对值。

对于每个$s[j]$，贡献值为：
$$\sum_{i<j}|s[j]-s[i]|$$

拆分为两部分：

- $s[j] > s[i]$：贡献为 $s[j] - s[i]$，总贡献为 $s[j]\times$ 较小元素的个数 $-$ 较小元素的和。
- $s[j] \le s[i]$：贡献为 $s[i] - s[j]$，总贡献为较大元素的和 $-s[j]\times$ 较大元素的个数。

我们可以开两个权值树状数组分别记录次数和总和，由于前缀和数组可能有负数，所以不要忘了离散化一下。

然后在枚举 $j$ 的同时，快速求出所有上文所提到的较小元素的个数，较大元素个数，较小元素的和，较大元素的和。然后每求出一个 $j$ 的贡献再把 $j$ 加到权值树状数组里面。

最后根据公式求一下就好了，最后时间复杂度是$O(n\log n)$。

附上代码。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+5;
int a[N],s[N],b[N];
int lowbit(int x){
	return x&(-x);
}
struct Tree{
	int n;
	vector<int> tr;
	Tree(int n):n(n),tr(n+2){}
	void update(int x,int c){
		for (;x<=n;x+=lowbit(x)) tr[x]+=c;
	}
	int query(int x){
		int res=0;
		for (;x;x-=lowbit(x)) res+=tr[x];
		return res;
	}
};
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	if(m>2){
		int ans=0;
		int nw=0,len=0;
		for(int i=1;i<n;i++){
			if(a[i]==nw){
				len++;
			}else{
				nw=a[i];
				len=1;
			}
			if(a[i]==a[i+1]){
				if(len%2==0){
					ans+=(len/2)*(n-i);
				}else{
					ans+=(len/2+(i-len)+1)*(n-i);
				}
			}			
		}
		cout<<ans<<"\n";
	}else{
		for(int i=1;i<=n;i++){
			if(a[i]==2)a[i]=0;
		}
		for(int i=2;i<=n;i+=2){
			a[i]^=1;
		}
		for (int i=1;i<=n;i++) a[i]=(a[i]==0?1:-1);
		for(int i=1;i<=n;i++){
			s[i]=a[i]+s[i-1];
			b[i]=s[i];
		}
		sort(b+1,b+n+1);
		int tot=unique(b+1,b+n+1)-b-1;
		Tree cnt(tot),sum(tot);
		int ans=0;
		for (int i=0;i<=n;i++){
			int x=s[i];
			int k=lower_bound(b+1,b+tot+1,x)-b;
			int cl=cnt.query(k-1),sl=sum.query(k-1);
			int ct=cnt.query(tot),st=sum.query(tot);
			int cs=ct-cl,ss=st-sl;
			ans+=x*cl-sl+ss-x*cs;
			cnt.update(k,1);
			sum.update(k,x);
		}
		cout<<(n*(n+1)*(n+2)/6-ans)/2;
	}
}
```

---

## 作者：Register_int (赞：7)

直接对一个子段暴力是典题。若 $m=2$ 序列只有可能 $1,2$ 交替，枚举两种情况算操作次数最小值即可。对于 $m>2$，一段长度为 $l$ 的极长同色段最少需要操作 $\lfloor l/2\rfloor$ 次，全加起来就是答案。

然后考虑原题，你需要对所有子段求和。对于 $m>2$ 是简单的，原序列中的同色段只有以下四种情况：

- 作为一段前缀出现。
- 作为一段后缀出现。
- 完整出现。
- 自己把子段包含住。

都是好统计的，可以做到线性。难的是 $m=2$。首先你套路性将奇数位翻转，那么一个子段的操作次数就是 $1$ 的个数与 $2$ 的个数的最小值。设这俩为 $c_1,c_2$。你实际上会发现：

$$\min(c_1,c_2)=\frac{c_1+c_2-|c_1-c_2|}2$$

所以你将所有 $2$ 替换成 $-1$，问题转化为所有子段和的绝对值之和。前缀和一下变成任意两数差的绝对值之和，排个序做就好了。容易发现值域是 $[-n,n]$，桶排可以做到线性，没啥必要就是了（双关）。

~~其中一个验题人认为本题是紫题并提出了一个分块做法。~~

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 2e5 + 10;

int n, m, a[MAXN], s[MAXN]; ll sum, ans;

int main(){
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
	if (m == 2) {
		for (int i = 1; i <= n; i++) a[i]--, (i & 1) && (a[i] ^= 1);
		for (int i = 1; i <= n; i++) s[i] = s[i - 1] + (a[i] ? 1 : -1);
		sort(s, s + n + 1);
		for (int i = 1; i <= n; i++) ans += (ll)i * (n - i + 1); 
		for(int i = 0; i <= n; i++) ans -= (ll)s[i] * i - sum, sum += s[i];
		printf("%lld", ans >> 1); return 0;
	}
	for (int i = 0, k = 0; i <= n; i++) {
		if (a[i] == a[i + 1]) { k++; continue; }
		for (int j = 1; j < k; j++) ans += (ll)j / 2 * (k - j + 1);
		ans += (ll)k / 2 * (i - k + 1) * (n - i + 1);
		for (int j = 1; j < k; j++) ans += (ll)j / 2 * (n - k);
		k = 1;
	}
	printf("%lld", ans);
}
```

---

## 作者：shuqiang (赞：2)

先分析函数 $f(a,m)$。

- 当 $m=2$ 时，显然序列只能修改成 $1,2,1,2,1 \cdots$ 或 $2,1,2,1,2 \cdots$，所以修改成修改次数最少一个即可。
- 当 $m \ge 3$ 时，当遇到相邻的数相等，就将中间的数全部修改，比如序列 $2,2,2,2,2$，就可以改成 $2,1,2,1,2$，注意要改成除了旁边两个数字以外的数字，所以要保证 $m \ge 3$，这个条件已经在分类讨论里了，所以不用管，所以 $x$ 个相邻的数相等对答案的贡献为 $\lfloor \frac{x}{2} \rfloor$。

接下来我们来拆贡献。

对于 $m \ge 3$，把一段连续的数字分成三个贡献，假设这段连续的数字区间为 $[l,r]$，总区间长度为 $n$。
- 如果这段区间被完全包含，那么贡献为 $\lfloor \frac{r-l+1}{2} \rfloor$，这样的区间一共有 $l \times (n-r+1)$ 个，对答案的贡献为 $\lfloor \frac{r-l+1}{2} \rfloor \times l \times (n-r+1)$。
- 如果这段区间的部分被包含，另一端在区间外，那么区间内端点在左边时的贡献为 $\sum^r_{i=l} \lfloor \frac{i-l+1}{2} \rfloor \times l$，在右边时的贡献为 $\sum^r_{i=l} \lfloor \frac{r-i+1}{2} \rfloor \times (r-l+1)$。
- 如果两个端点都在这段区间内，注意，这次的分类讨论选的端点在区间的端点上时已经被讨论过了，所以我们实际要算的长度是原来长度减 $2$，此时，贡献为 $\sum^{r-l-1}_{i=1} \lfloor \frac{i}{2} \rfloor \times (r-l-i)$，这个可以用两次前缀和预处理一下。

这样，我们就能愉快的拿下 $30$ 分了。

接下来讨论 $m=2$，可以发现，直接判断 $1,2,1,2,1 \cdots$ 或 $2,1,2,1,2 \cdots$ 会很麻烦，我们可以让每一个数字都减 $1$，然后奇数位 $01$ 反转，这样就变成了判断操作成全 $0$ 还是全 $1$，设它前 $i$ 个数的和为 $s_i$，答案即为：

$$\sum_{1\le l\le r\le n} \min(s_r-s_{l-1},r-l+1-s_r+s_{l-1})$$

暴力判断显然为 $\mathcal{O}(n^2)$。

~~这里的优化是这题唯一的难点。~~

考虑使用公式：

$$\min(a,b)=\frac{a+b-|a-b|}{2}$$

拆完后式子变为：

$$\sum_{1\le l\le r\le n} \frac{r-l+1-|2s_r-2{s_{l-1}}-r+l-1|}{2}$$

前者可以直接计算，后者可以令 $c_i=i-s_i$ 可以转化为：

$$\sum_{1\le l\le r\le n} \frac{|c_r-c_{l-1}|}{2}$$

排序后分别计算正贡献和负贡献即可。

时间复杂度 $\mathcal{O}(n \log n)$。


```cpp
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;
typedef long long ll;

const int N = 2e5 + 10;
int n, m, a[N], b[N*2]; ll ans = 0;
ll f[N], s[N];

struct Group{
	int l, r;
};
vector<Group> gp;


void upd(int x){
	x += N;
	while(x <= n){
		b[x]++;
		x += x & -x;
	}
}

int chk(int x){
	x += N;
	int res = 0;
	while(x){
		res += b[x];
		x -= x & -x;
	}
	return res;
}

int main(){
	cin >> n >> m;
	for(int i = 1; i <= n; i++) cin >> a[i];
	if(m == 2){
		for(int i = 1; i <= n; i++) a[i]--;
		for(int i = 1; i <= n; i += 2) a[i] ^= 1;
		for(int i = 2; i <= n; i++) a[i] += a[i-1]; 
		for(int i = 1; i <= n; i++){
			ans += (ll)i * (i+1) / 2;
		}
		for(int i = 1; i <= n; i++) a[i] = i-2*a[i];
		sort(a, a + n + 1);
		for(int i = 1; i <= n; i++){
			ans += a[i-1]*(n-i+1);
			ans -= a[i]*i;
		}
		cout << ans/2 << '\n';
	}
	else{
		for(int i = 2; i <= n; i++){
			s[i] = s[i-1] + (i/2);
		}
		for(int i = 1; i <= n; i++){
			f[i] = f[i-1] + s[i];
		}
		int lst = 1; 
		for(int i = 2; i <= n; i++){
			if(a[i] != a[i-1]){
				gp.push_back({lst, i-1});
				lst = i;
			}
		}
		gp.push_back({lst, n});
		for(int i = 0; i < gp.size(); i++){
			ll lt = gp[i].l, rt = n-gp[i].r+1, sz = gp[i].r - gp[i].l + 1;
			ans += lt * rt * (sz/2);
			if(sz >= 4) ans += f[sz-2];
			for(int j = gp[i].l+1; j < gp[i].r; j++){
				ll al = (j - gp[i].l + 1)/2, ar = (gp[i].r - j + 1)/2;
				ans += al * lt;
				ans += ar * rt;
			}
		}
		cout << ans << '\n';
	}
	return 0;
}
```

---

## 作者：P2441M (赞：2)

$\text{Upd 2025/5/4}$：修正了一些笔误。

## 题意
给定 $m$ 和一个长度为 $n$ 的序列 $a$，对于 $1\leq i\leq n,a_i\in[1,m]\cap\mathbb{Z}$。现在可以进行若干次修改，每次修改可以选定一个 $a_i$，将其修改为 $[1,m]$ 中的一个整数。对于一个序列 $b$，定义它的权值为最小的修改次数，使得 $b$ 中任意相邻两数不同。求出 $a$ 中所有子段的权值和。$1\leq n\leq 2\times 10^5$，$2\leq m\leq 10^9$。

## 题解
先做比较好做的 $m>2$ 的情况。考虑此时一个序列的权值如何计算，我们按照极长同色段进行划段，对每个段计算最小修改次数。容易发现长度为 $len$ 的段的最小修改次数就是 $\left\lfloor\frac{len}{2}\right\rfloor$。

那么我们就是要快速计算所有子区间的 $\sum\left\lfloor\frac{len}{2}\right\rfloor$ 之和。我们类似扫描线去扫右端点 $r$，当 $r\leftarrow r+1$ 时，维护所有以 $r$ 为右端点的区间的贡献和 $s$。这个不难算，考虑 $r$ 所在的极长段 $[pre_r,r]$：
- 对于 $1\leq l<pre_r$ 的区间 $[l,r]$，从 $[l,r-1]$ 变成 $[l,r]$ 增加的贡献，就是从 $\left\lfloor\frac{r-pre_r}{2}\right\rfloor$ 变成 $\left\lfloor\frac{r-pre_r+1}{2}\right\rfloor$ 增加的贡献。因此若 $r-pre_r+1$ 为奇数，令 $s\leftarrow s+pre_r-1$ 即可。
- 对于 $pre_r\leq l\leq r$ 的区间 $[l,r]$，增加的贡献就是从 $\sum_{i=0}^{pre_r-r}\left\lfloor\frac{i}{2}\right\rfloor$ 变成 $\sum_{i=0}^{pre_r-r}\left\lfloor\frac{i+1}{2}\right\rfloor$ 增加的贡献。因此令 $s\leftarrow s+\left\lfloor\frac{r-pre_r+1}{2}\right\rfloor$ 即可。

这部分是 $\mathcal{O}(n)$ 的，可以获得 $40$ 分。

再来做 $m=2$。这时候我们换种思路，注意到只会把序列改成 $0,1,0,\cdots$ 或者 $1,0,1,\cdots$，那么一个序列的权值自然就是两种修改方式的操作次数取最小值。容易看出两种修改方式操作次数之和就是序列的长度。我们预处理 $pre_i$ 表示将 $a[1,i]$ 修改成 $0,1,0,\cdots$ 的最小操作次数，那么我们要求的就是
$$
\sum_{1\leq l\leq r\leq n}\min(pre_r-pre_{l-1},r-l+1-pre_r+pre_{l-1})
$$

看起来不好优化，考虑拆 $\min$，也就是考虑
$$
\min(x,y)=\frac{x+y-|x-y|}{2}
$$

我们**略去** $\frac{1}{2}$，于是原式变为
$$
\begin{align*}
&\sum_{1\leq l\leq r\leq n}r-l+1-\sum_{1\leq l\leq r\leq n}|r-l+1-2pre_r+2pre_{l-1}|\\
=&\sum_{r=1}^n\frac{r(r+1)}{2}-\sum_{1\leq l\leq r\leq n}|(r-2pre_r)-(l-1-2pre_{l-1})|
\end{align*}
$$

令 $b_i=i-2pre_i$，则原式即
$$
\sum_{r=1}^n\frac{r(r+1)}{2}-\sum_{1\leq l\leq r\leq n}|b_r-b_{l-1}|
$$

后面的求和相当于 $b_0,\cdots,b_n$ 中两两的差的绝对值之和，这就很典了。我们对 $b$ 排序，然后用前缀和累加答案即可。

拼接两部分做法即可通过本题。时间复杂度 $\mathcal{O}(n\log{n})$，瓶颈在于排序。

## 代码
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

#define lowbit(x) ((x) & -(x))
#define chk_min(x, v) (x) = min((x), (v))
#define chk_max(x, v) (x) = max((x), (v))
typedef long long ll;
typedef pair<int, int> pii;
const int N = 2e5 + 5;

int n, m, a[N], b[N], pre[N];
ll ans, s;

int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    if (m > 2) {
	    for (int r = 1; r <= n; ++r) {
	    	if (a[r] == a[r - 1]) pre[r] = pre[r - 1];
    		else pre[r] = r;
	    	int p = pre[r];
	    	if (!((r - p + 1) & 1)) s += p - 1;
	    	s += (r - p + 1) >> 1;
	    	ans += s;
	    }
	} else {
		for (int i = 1; i <= n; ++i) {
			pre[i] = pre[i - 1] + (a[i] - 1 == (i & 1));
			b[i] = i - (pre[i] << 1);
			ans += 1ll * i * (i + 1) / 2;
		}
		sort(b, b + n + 1);
		pre[0] = b[0];
		for (int i = 1; i <= n; ++i) pre[i] = pre[i - 1] + b[i];
		for (int i = 1; i <= n; ++i) ans -= 1ll * (i + 1) * b[i] - pre[i];
		ans >>= 1;
	}
    cout << ans;
    return 0;
}
```

---

## 作者：StarRoam (赞：1)

**[P12391 「RiOI-6」帝国少女](https://www.luogu.com.cn/problem/P12391)**

可以看出需要对 $n$ 的范围进行分类求解。

- 对于 $n > 2$。因为我们每个位置至少有 $3$ 种用法，则我们不必担心连续相同数字的长度是偶数的情况。

  易得，对于一个长是 $l$ 的子段，它的贡献是 $\lfloor  \frac{l}{2} \rfloor$，于是我们只要对包含了这个子段的串及这个子段的子串分别求解即可，复杂度是 $O(n)$。

- 对于 $n=2$。我们先考虑暴力的做法。因为所得序列无非就两种情况，即第一个是 $1$ 或者第一个是 $2$，令这两种的贡献分别是 $cst_1$ 与 $cst_2$，我们要求的便是 $\min(cst_1,cst_2)$。暴力可以做到 $O(n^2)$。


  推一下式子，有：$\min(cst_1,cst_2)=\frac{cst_1+cst_2-|cst_1-cst_2|}{2}$
  
  $cst_1+cst_2$ 的值就是子段长，能够直接求解。

  对于$|cst_1-cst_2|$，我们可以使用前缀和优化并且使用排序去掉绝对值符号。总复杂度也是 $O(n)$。


  
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=2e5+5;
int n,m;
ll ans,cst[N],sum1[N],sum2[N];
ll cnt[N],tot[N];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	if(m>2)
	{
		int now=0,beg=0;
		for(int i=2;i<=n;i++)
		{
			int len=(i/2);
			cst[i]=cst[i-1]+(1+len)*1ll*len;
			if(i%2==0) cst[i]-=len; 
		}
		for(int i=1;i<=n;i++)
		{
			int a;
			cin>>a;
			if(a!=now){
				ll l1=(beg-1),l2=(n-i+1);
				ll len=(i-beg)/2;
				len=(len+1)*len;
				if((i-beg)%2==0) len-=(i-beg)/2;
				ll add=((i-beg)/2)*(l1*l2)+cst[i-beg]+(l1+l2)*len;
				ans+=add;
				now=a,beg=i;
			}
		}
		ll l1=(beg-1),l2=0;
		ll len=(n+1-beg)/2;
		len=(len+1)*len;
		if((n+1-beg)%2==0) len-=(n+1-beg)/2;
		ll add=((n+1-beg)/2)*(l1*l2)+cst[n+1-beg]+(l1+l2)*len;
		ans+=add;
		cout<<ans;
	}
	else{
		int s1=0,s2=0;
		for(int i=1;i<=n;i++)
		{
			int a;
			cin>>a;
			s1=s1+((i&1)?a==1:a==2);
			s2=s2+((i&1)?a==2:a==1);
			cnt[i]=s2-s1;
		}
		sort(cnt+1,cnt+n+1);
		ll ans=0;
		for(int i=1;i<=n;i++)
			ans+=1ll*i*(n-i+1);
		for(int i=1;i<=n;i++)
		{
			ans-=cnt[i]*(i-1)-tot[i-1];
			tot[i]=tot[i-1]+cnt[i];
			ans-=abs(cnt[i]);
		}
		cout<<ans/2;
	} 
	return 0;
}
/*
 
*/
```

---

## 作者：哈哈人生 (赞：1)

# 题外话
讲个笑话，赛时打的是两个树状数组还没调出来。

# 思路
首先把题目分为两部分，$m$ 大于二或等于二：
1. $m>2$ 时做法比较简单，遇到相邻相同的两个数肯定可以通过一次修改解决。我们把原序列的连续的相同的数分为一段，则每个包含这段的原序列子段，设其长度为 $x$，则需要 $\lfloor \frac{x}{2} \rfloor$ 的修改次数。而我们设这段的左端点和右端点分别为 $l,r$，则显然有 $l\times (n-r+1)$ 个原序列子段包含这段，相乘即可。需要注意这一段的子段也对答案有贡献，暴力枚举长度（长度最多也不会超过本段的长度，不会影响时间复杂度），类似以上统计贡献即可。时间复杂度 $O(n)$。
2. $m=2$ 比较难，有个很巧妙的方法。由于取值只有一和二，我们把 $a[i]-1\equiv i \pmod 2$ 的位置 $i$ 的权值设为 $1$，反之设为 $-1$。我们发现一个合法的子段要么全是 $1$ 要么全是 $-1$，否则就要通过把所有 $1$ 变为 $-1$ 或者把所有 $-1$ 变为 $1$ 来修改，所以一个子段中 $1$ 的个数和 $-1$ 的个数的最小值就是答案，因此对于子段 $[l,r]$，其贡献为 $(r-l+1-|b_r-b_{l-1}|)\div 2$，其中 $b$ 为前缀和数组。观察这个式子，由乘法分配律拆开，发现前半部分就是所有子段的长度之和，后半部分就是 $b$ 数组两两相减的绝对值。把 $b$ 数组排序，相当于去掉绝对值，再直接减完相加即可。这样的话 $O(n\log n)$ 的做法就呼之欲出了，瓶颈在排序。

# 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,a[200005],b[200005];
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1; i<=n; i++)cin>>a[i];
	if(m==2) {
		for(int i=1; i<=n; i++) {
			if(a[i]-1==i%2)a[i]=1;
			else a[i]=-1;
			b[i]=b[i-1]+a[i];
		}
		int ans=0,sum=0;
		for(int i=1;i<=n;i++){
			ans+=i*(n-i+1);
		}
		sort(b,b+n+1);
		for(int i=0;i<=n;i++){
			ans-=b[i]*i-sum;
			sum+=b[i];
		}		
		cout<<ans/2;
		return 0;
	}
	int ls=1,ans=0;
	for(int i=2; i<=n+1; i++) {
		if(a[i]!=a[i-1]) {
			for(int j=1; j<=i-ls-1; j++) {
				ans+=j/2*(ls+n-i+2)+j/2*(i-ls-2-j+1);
			}
			ans+=(i-ls)/2*ls*(n-i+2);
			ls=i;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：gghack_Nythix (赞：1)

## 前言：

没打这场比赛，但是感觉这题蛮有意思的，所以花了一点时间做了一下。虽然我的代码很抽象，但是思路比较好理解。

## 分析：

首先注意到一个特殊性质 $m>2$，那么说明这个应该比较简单，先从这个入手。

对于 $m>2$，一个大小为 $x$ 的连续段（值都一样）的修改次数为 $\left \lfloor \frac{x}{2} \right \rfloor $，这个是显然的。

那么你找到一个极长连续段，统计它和它的子段的答案即可。

具体的，对于一个极长段 $[l,r]$ 答案存在这几种形式：

- $[l_1,r_1]$，其中 $l< l_1\leq r_1 < r$。

- $[l,r]$，即自己本身。

- $[l-k,r+k]$，其中 $k\ne 0,l-k\ge 1,r+k\leq n$。

- $[l,r+k]$，其中 $k\ne 0,r+k\leq n$。

-  $[l-k,r]$，其中 $k\ne 0,l-k\ge 1$。

那么这些你随便统计一下即可，代码大概长这个样：

```cpp
		int len = 1;
		for (int i = 1;i < n;++i) {
			if (a[i] == a[i + 1]) { ++ len ; continue; }
			for (int j = 1;j < len;++j) ans += j / 2ll * (len - j + 1ll);
			ans += len / 2ll * (i - len + 1ll) * (n - i + 1ll);
			for (int j = 1;j < len;++j) ans += j / 2ll * (n - len);
			len = 1;
		}
		if (a[n] == a[n - 1]) {
			for (int j = 1;j < len;++j) ans += j / 2ll * (len - j + 1ll);
			ans += len / 2ll * (n - len + 1ll) * (n - n + 1ll);
			for (int j = 1;j < len;++j) ans += j / 2ll * (n - len);
			len = 1;
		}
//这份代码合并了一些情况。
```

然后考虑 $m=2$，发现一个区间只能被改成两种情况，第一种形如 $1,2,1\cdots$，第二种形如 $2,1,2\cdots$。

一个区间的答案即这两个改的方式的最小值。

发现你用一个 $s_{1_i}$ 和 $s_{2_i}$ 记录一下从开头开始的形如 $1,2,1\cdots$，$2,1,2\cdots$ 的情况的与 $a_{[1,i]}$ 不一样的个数的前缀即可，然后枚举区间，将这两者取个最小值即可。

```cpp
		for (int i = 1;i <= n;++i) sum1[i] = sum1[i - 1] + ( a[i] != 1 + (i % 2 == 0) );
		for (int i = 1;i <= n;++i) sum2[i] = sum2[i - 1] + ( a[i] != 1 + (i % 2 == 1) );
		for (int i = 1;i <= n;++i) for (int j = i;j <= n;++j) 
		ans += min (sum1[j] - sum1[i - 1] , sum2[j] - sum2[i - 1]);
```

现在考虑怎么优化这个过程：很难注意到 $\min(a,b)=\frac{a+b-\left | a-b \right | }{2}$。设 $add_i=s_{1_i}+s_{2_i}$，$dif_i=s_{1_i}-s_{2_i}$，对于一个区间 $[i,j]$，答案即为 $\frac{add_j-add_{i-1}-\left | dif_{j}-dif_{i-1}\right |}{2}$。

发现 $add$ 部分是好弄的，一个树状数组扫过去即可，$dif$ 部分的话，你考虑排一个序，那么答案就是 $\sum\limits_{i=0}^{n}(i\times dif_i-\sum\limits_{j=0}^{i-1}dif_j)$，这个式子的实质就是排序去掉大小差异以去掉绝对值，因为排序后有 $\forall i > j,dif_{i}>dif_{j}$。

那么这个题就做完了。

```cpp
# include <bits/stdc++.h>
# define int long long
# define lob(i) (i & -i)
using namespace std;
const int N = 2e5 + 5;
int n , m , a[N] , ans , sum1[N] , sum2[N] , add[N] , dif[N];
int btr[N];
void A (int x , int y) { for (int i = x;i < N;i += lob(i)) btr[i] += y; }
int Q (int x) { int z = 0; for (int i = x; i ; i -= lob(i)) z += btr[i]; return z; }
signed main () {
	cin >> n >> m;
	for (int i = 1;i <= n;++i) cin >> a[i];
	if (m != 2) {
		int len = 1;
		for (int i = 1;i < n;++i) {
			if (a[i] == a[i + 1]) { ++ len ; continue; }
			for (int j = 1;j < len;++j) ans += j / 2ll * (len - j + 1ll);
			ans += len / 2ll * (i - len + 1ll) * (n - i + 1ll);
			for (int j = 1;j < len;++j) ans += j / 2ll * (n - len);
			len = 1;
		}
		if (a[n] == a[n - 1]) {
			for (int j = 1;j < len;++j) ans += j / 2ll * (len - j + 1ll);
			ans += len / 2ll * (n - len + 1ll) * (n - n + 1ll);
			for (int j = 1;j < len;++j) ans += j / 2ll * (n - len);
			len = 1;
		}
	}
	else {
		for (int i = 1;i <= n;++i) sum1[i] = sum1[i - 1] + ( a[i] != 1 + (i % 2 == 0) );
		for (int i = 1;i <= n;++i) sum2[i] = sum2[i - 1] + ( a[i] != 1 + (i % 2 == 1) );
		for (int i = 1;i <= n;++i) add[i] = sum1[i] + sum2[i] , dif[i] = sum1[i] - sum2[i];
		A (1 , 0); for (int i = 1;i <= n;++i) ans += i * add[i] - Q (i + 1) , A (i + 1 , add[i]);
		sort (dif , dif + n + 1); int sum = 0;
		for (int i = 0;i <= n;++i) ans -= i * dif[i] - sum , sum += dif[i];
		ans >>= 1;
	}
	return cout << ans << '\n' , 0;
}
```

---

## 作者：Lele_Programmer (赞：0)

# P12391 题解

## 思路

分类讨论，将 $m$ 的取值分为 $2$ 与 $\ge 3$ 两种情况。

先看比较简单的 $m \ge 3$ 的情况，很显然，相同数字组成的连通块，块与块之间的修改不会互相影响。假设有两个 $a$ 连在一起，需要修改的值的旁边有一个 $b (b \neq a)$，那么我们总可以找到一个 $c (c \neq a, c \neq b)$，将这个 $a$ 换成 $c$。

假设从 $i$ 开始的 $cnt_i$ 个数字相同，并且 $[i,i+cnt_i-1]$ 被完全包含（不完全重叠），那么右端点的取值 $r$ 有 $n-(i+cnt_i)+1$ 种，若 $a_i \neq a_{i-1}$ 则左端点的取值 $l$ 有 $i$ 种，否则有 $1$ 种，若有交集，则对于每一个长度 $j$ 满足 $j \le cnt_i, j \neq 1$，每一个长度都能产生一次 $\lfloor\frac{j}{2}\rfloor$ 的贡献，能够合并起来就是 $l \times (r \times \lfloor\frac{cnt_i}{2}\rfloor+\sum\limits_{j=2}^{cnt_i} \lfloor\frac{j}{2}\rfloor)$。

接下来分析 $m=2$ 的情况，很显然，要么呈现 $[1,2,1,2,\cdots]$ 的结构，要么呈现 $[2,1,2,1,\cdots]$ 的结构，对于前者，我们设 $k_i$ 表示第 $i$ 位是否需要修改，对于后者，我们设 $p_i$ 表示第 $i$ 位是否需要修改。

然后，对于每一个区间求最小值，再求它们的和，可以列出这样一个式子：

$$
\sum\limits_{l=1}^n\sum\limits_{r=l}^n\min(\sum\limits_{i=l}^r k_i, \sum\limits_{i=1}^r p_i)
$$

由 $\min(a,b) = \frac{a+b+|a-b|}{2}$，原式可转化为：

$$
\sum\limits_{l=1}^n\sum\limits_{r=l}^n\frac{\sum\limits_{i=l}^r k_i+\sum\limits_{i=1}^r p_i-|(\sum\limits_{i=l}^r k_i-\sum\limits_{i=1}^r p_i)|}{2}
$$

拆一下式子，进一步转化为：

$$
\frac{\sum\limits_{l=1}^n\sum\limits_{r=l}^n\sum\limits_{i=l}^r k_i+\sum\limits_{l=1}^n\sum\limits_{r=l}^n\sum\limits_{i=1}^r p_i}{2}-\frac{\sum\limits_{l=1}^n\sum\limits_{r=l}^n|\sum\limits_{i=l}^r(k_i- p_i)|}{2}
$$

前面那部分可以用前缀和刷一遍 $\mathcal{O}(n)$ 求出来，后面那部分继续化简，令 $P_i=k_i-p_i$，则减号后的部分化简为：

$$
\frac{\sum\limits_{l=1}^n\sum\limits_{r=l}^n|\sum\limits_{i=l}^r P_i|}{2}
$$

显然 $\sum\limits_{i=l}^r P_i$ 可以用前缀和再进一步化简，令 $s_i = \sum\limits_{j=1}^{i}P_j$，则式子继续化简为：

$$
\frac{\sum\limits_{l=1}^n\sum\limits_{r=l}^n|s_r-s_{l-1}|}{2}
$$

化简得差不多了，这一个式子与前面不同的是，多了一个绝对值，现在要看看怎么做掉它。

从小到大枚举每一个 $i$，答案会加上 $\sum\limits_{j=1}^{i} |s_i-s_j|$，根据其正负性，将绝对值符号拆掉，式子化为 $\sum\limits_{j=1}^{i}[s_i-s_j>0](s_i-s_j)+\sum\limits_{j=1}^{i}[s_i-s_j<0](s_j-s_i)$，这样一来，括号又可以拆掉，对于 $s_i-s_j>0$ 的 $s_j$，假设有 $x$ 个，则答案会加上 $s_i x - \sum s_j$，另一者同理。

$s_i x$ 这个是可以直接求的，现在要求 $\sum s_j$，也就是把正的加起来，负的加起来取相反数。

由于 $i$ 向 $i+1$ 推进时，$i$ 所对应的位置向后移动，自然对应的 $s_i$ 会发生变化，线段树里面维护的是 $s_i-s_j$ 的值，那么所有值会整体同时向同一个方向移动相同的距离，那怎么把正负分开呢？这里可以不移动线段树里面的数字，而只移动数值 $0$ 所对的位置。

## 代码

```cpp
const int N=200005;
const int M=N*2+1000;

int n,m;
int a[N];
int cnt[N];
int f[N];
int k[N]; // 1 2 1 2 ...
int p[N]; // 2 1 2 1 ...
int s[N];

void init() {
    f[1]=0;
    _rep(i,2,N-1) f[i]=f[i-1]+i/2;
}

struct Seg {
    int l,r;
    int v,c;
} tr[M<<2];

void pushup(int u) {
    tr[u].v=tr[u<<1].v+tr[u<<1|1].v;
    tr[u].c=tr[u<<1].c+tr[u<<1|1].c;
}

void modify(int u,int p) {
    if (tr[u].l==p && tr[u].r==p) tr[u].v+=p,tr[u].c++;
    else {
        int mid=tr[u].l+tr[u].r>>1;
        if (p<=mid) modify(u<<1,p);
        else modify(u<<1|1,p);
        pushup(u);
    }
}

pii operator + (const pii& a,const pii& b) {
    return {a.first+b.first,a.second+b.second};
}

pii query(int u,int l,int r) {
    if (tr[u].l>=l && tr[u].r<=r) return pii{tr[u].v,tr[u].c};
    int mid=tr[u].l+tr[u].r>>1;
    pii ans={0,0};
    if (l<=mid) ans=ans+query(u<<1,l,r);
    if (r>mid) ans=ans+query(u<<1|1,l,r);
    return ans;
}

void build(int u,int l,int r) {
    tr[u]={l,r,0};
    if (l==r) return;
    int mid=l+r>>1;
    build(u<<1,l,mid);
    build(u<<1|1,mid+1,r);
    pushup(u);
}

i32 main() {
    init();
    read(n),read(m);
    _rep(i,1,n) read(a[i]);
    _rrep(i,n,1) if (a[i]==a[i+1]) cnt[i]=cnt[i+1]+1; else cnt[i]=1;
    if (m>2) {
        int ans=0;
        _rep(i,1,n) {
            if (cnt[i]==1) continue;
            int r=n-(i+cnt[i])+1,l;
            if (i==1) l=1;
            else if (cnt[i-1]!=cnt[i]+1) l=i;
            else l=1;
            ans+=l*(r*(cnt[i]/2)+f[cnt[i]]);
        }
        write(ans);
    } else {
        _rep(i,1,n) {
            if ((i%2 && a[i]==2) || (i%2==0 && a[i]==1)) k[i]=1;
            else p[i]=1;
        }
        _rep(i,1,n) s[i]=k[i]-p[i];
        _rep(i,1,n) s[i]+=s[i-1];
        // printf("k: "); _rep(i,1,n) writesp(k[i]); putchar(10);
        // printf("p: "); _rep(i,1,n) writesp(p[i]); putchar(10);
        // printf("s: "); _rep(i,1,n) writesp(s[i]); putchar(10);
        int ans=0,sum=0;
        // _rep(i,1,n) ans+=k[i]*i-sum,sum+=k[i],
        // sum=0;
        // _rep(i,1,n) ans+=p[i]*i-sum,sum+=p[i];
        _rep(i,1,n) ans+=k[i]*i*(n-i+1);
        _rep(i,1,n) ans+=p[i]*i*(n-i+1);
        int zero=N+100;
        build(1,1,M);
        modify(1,zero);
        zero-=s[1];
        _rep(i,1,n) {
            modify(1,zero);
            pii r=query(1,zero+1,M);
            pii l=query(1,1,zero-1);
            ans-=zero*l.second-l.first;
            ans-=r.first-r.second*zero;
            if (i!=n) {
                int k=s[i+1]-s[i];
                zero-=k;
            }
        }
        write(ans>>1);
    }
    return 0;
}
```

---


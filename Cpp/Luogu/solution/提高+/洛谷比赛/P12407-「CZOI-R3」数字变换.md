# 「CZOI-R3」数字变换

## 题目描述

你有一个长度为 $n$ 的序列 $x$ 和一个数 $a=p$。

序列 $x$ 的第 $i$ 个数具有一个花费序列 $w_{i,1},w_{i,2},\dots,w_{i,k}$。

你可以将 $a$ 变换成 $i$（$1\le i\le n$，$a$ 可以等于 $i$），**当前**是你的第 $j$ 次操作，则花费为 $w_{i,j} + 2\times(L-(x_a \mathbin{\&} x_i))$，其中 $\mathbin{\&}$ 是按位与，即 C++ 中的 `&`。

$L$ 是序列 $x$ 中所有数的最大值，即 $\max\limits_{1\le i\le n}x_i$。

你需要对所有 $1\le i\le n$ 求出**在第 $k$ 步操作结束时**将 $a$ 变成 $i$ 的**最小**花费。询问之间互相独立，每次询问不会影响其他次询问的答案。

## 说明/提示

**【样例解释】**

$x = \{3, 1, 3\},w_1 = \{834731, 259456\},w_2 = \{471501, 271389\} ,w_3 = \{902700, 566748\},a=1,L=3$。

将 $a$ 变为 $2$ 的最优操作是第一次 $a\to 2$ 花费 $w_{2,1} + 2\times(3-3\& 1)= 471505$，第二次 $a\to 2$ 花费 $w_{2,2} + 2\times(3-1\& 1)= 271393$，总花费为 $742898$。

**【数据范围】**

- Subtask #1（$15\text{ pts}$）：$k = 1$，$x_i < 2^{12}$。
- Subtask #2（$25\text{ pts}$）：$c\le 10^3$（最多只有 $10^3$ 种不同的 $x_i$），$x_i < 2^{12}$。
- Subtask #3（$25\text{ pts}$）：$\max\{\text{popcount}(x_i)\} \le 5$。其中 $\text{popcount}(x_i)$ 表示 $x_i$ 在二进制下 $1$ 的个数。
- Subtask #4（$35\text{ pts}$）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 2 \times 10^5$，$1 \le k \le 10$，$0\le x_i<2^{16}$，$1 \le  p \le n$，$0\le w_{i,j}<10^6$。$1\le seed \le 2\times 10^9$，$1\le c \le 2^{16}$，$0 \le y_i < 2^{16}$。

## 样例 #1

### 输入

```
3 1 2 3 1025032617
1 2 3```

### 输出

```
730965 742898 1038257```

# 题解

## 作者：HP_Serenity (赞：5)

第一次场蓝，写篇题解纪念下。

关于符号的说明：$\operatorname{and}$ 代表按位与。

给定一个长度为 $n$ 的序列 $x$ 和一个初始位置 $a=p$，每次操作可将 $a$ 移至任意位置，而第 $j$ 次操作花费为 $w_{i,j}+2 \times (L-(x_a \operatorname{and} x_i))$。$L$ 为序列 $x$ 的最大值，目标是求出第 $k$ 次操作结束时，将 $a$ 转移到每个位置 $i$ 的最小总花费。

考虑 dp 做法。定义 $dp_{i,j}$ 为 $j$ 次操作后 $a$ 位于位置 $i$ 的最小总花费。因为在 $j$ 次操作时可以从任意位置 $v$ 移到 $u$，所以令 $w_{i,j}$ 为第 $j$ 次操作转移到 $u$ 的花费，推出动态转移方程：

$
dp_{j,u}=\displaystyle\min_{1 \le i \le n} (dp_{j-1,v}+w_{u,j}+2 \times (L-x_v \operatorname{and} x_u))
$。

但是时间复杂度为 $O(n^2 \times k)$，显然超时。

观察到 $0 \le x_i < 2^{16}$，考虑位运算优化。将 $x_i$ 拆成高低 $8$ 位。令 $high_i=(\lfloor\frac{x_i}{2^8} \rfloor) \operatorname{and} (2^8-1)$ 而 $low_i=x_i \operatorname{and} (2^8-1)$。根据按位与的性质，可将 dp 式子拆成高低 $8$ 位的贡献，即

$
dp_{j,u}=\displaystyle\min_{1 \le i \le n} (dp_{j-1,v}+w_{u,j}+2 \times L-2 \times (high_v \operatorname{and} high_u) \times 256-2 \times (low_v \operatorname{and} low_u))
$。

最后再通过预处理最小值进一步优化即可。

记 $P$ 为 $2^{24}$，则时间复杂度：$O(k \times P)$。空间复杂度：$O(n \times k)$。可以通过。

[AC 记录](https://www.luogu.com.cn/record/215809794)，[代码](https://www.luogu.com.cn/paste/4xgjt2v3)。

---

## 作者：chaynflow (赞：5)

容易发现本题的难点在于最短路建模。

## subtask 1 & 2

对值暴力即可。

## subtask 3

可能是一些分讨，或者是想了一半的正解。

## subtask 4 & Std

考虑一张点权按 popcount 划分层的 DAG。

两层之间的 $A,B(A<B)$ 有边，当且仅当 $A \And B = A$，边权为 $A \oplus B$。

建两张 DAG，一张边向上，一张向下，两张 DAG 之间对应点连边权为 $0$ 的边。

考虑对两个点 $u_0,v_1$（$0/1$ 表示在第一/二张 DAG 上）他们之间的最短路径长度就是 $u + v - 2(u \And v)$。考虑证明。

显然，若选择能从 $u$ 到 $x$ 且从 $x$ 跨图后能到 $v$ 必须满足 $x \And u = x, x \And v = x$，即 $x \And (u \And v) = x$，显然取 $x = u \And v$ 最优，$u$ 的花费为从 $u$ 到 $0$ 的 $u$ 减去从 $x$ 到 $0$ 的 $0$ 的 $x$，为 $u-x$，同理 $v$ 为 $v-x$，故 $u$ 到 $v$ 的最短路长度就是 $u + v - 2(u \And v)$。

至于如何变成 $2(L - (u \And v)) + w_{v,j}$，只需要将 $u$ 进入第一张 DAG 的边权设为 $L - u$，从第二张 DAG 出到 $v$ 的边权设为 $L - v + w_{v,j}$ 即可。

给个图例（这里把两张 DAG 画一起了，实际实现时要拆开，防止逆行）：

![](https://cdn.luogu.com.cn/upload/image_hosting/ok1ds77k.png)

至此，我们只需要跑 $k$ 遍 dijkstra 即可解决问题。每次将上一次到 $h$ 的长度变成这一次从超级源点到 $h$ 的长度即可。

复杂度分析：显然最主要的边在两张 DAG 上，还有 $O(n+V)$ 条额外边，这不重要。

为方便分析，设 $V = 2^t$。

一共有 $2^{t-1}$ 个有第 $p$ 位的数，有 $t$ 个第 $p$ 位，有两张 DAG，故边数为 $O(2^{t-1} \times 2 \times t) = O(t2^t )$。

dijkstra 的复杂度是 $O(m \log m)$，单次 dijkstra 复杂度为 $O(2^t \times t \times (t + \log t))$，或者说 $O(V \log V (\log V  + \log \log V))$，$k$ 次即 $O(k V \log V (\log V  + \log \log V))$，大概是 $2\times10^8$ 量级的，std 极限点跑了 $1.35s$ 左右。

---

## 作者：LostKeyToReach (赞：3)

我们令 $f_{i, j}$ 为第 $i$ 次操作 $a$ 序列变成 $j$ 的最小代价，那么有转移：

$$
f_{i, j} = w_{j, i} + 2L + \min_{k} \left\{f_{i - 1, k} - 2(x_j \& x_k)\right\}. 
$$

考虑按照 $x_k$ 来合并 dp 数组，记为 $a_i$，则：

$$
a_i = \min_{x_k = i} \left\{f_{i - 1, k}\right\}.
$$

那么转移方程改写为：

$$
f_{i, j} = w_{j, i} + 2L + \min_{k} \left\{a_k - 2(k \& x_j)\right\}.
$$

接下来考虑求解这个转移式后面部分。

$$
\min_{k} \left\{a_k - 2(k \& x_j)\right\} = \min_{u \subseteq x_j}\min_{v \supseteq u} \left\{a_v - 2u\right\}.
$$

你对上面式子分别做两次 SOS DP 就行了，时间复杂度 $\mathcal{O}(kV \log V)$。

赛时代码：

```cpp
/*
 * author: LostKeyToReach
 * created time: 2025-05-03 15:57:56
 */
#include <bits/stdc++.h>
#define int long long
#define vi vt<int>
using ll = long long; using pii = std::pair<int, int>;
template<typename T> using vt = std::vector<T>;
#define all(x) (x).begin(),(x).end()
#define sz(x) ((int)(x).size())
#define For(i, a, b) for(int i = (a); i <= (b); ++i)
#define Rof(i, a, b) for(int i = (a); i >= (b); --i)
#define S std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0)
template<typename T> T chkmax(T& x, T y) {
    return (x < y) ? (x = y, y) : x;
} template<typename T> T chkmin(T& x, T y) {
    return (x > y) ? (x = y, y) : x;
}int fio = (S, 0); constexpr int N = 2e5 + 5;
int c, y[1 << 16], x[N], w[N][11], n, k, p, l; 
unsigned long long seed; int get_rand(int mod) {
    seed ^= seed << 14, seed ^= seed >> 7, seed ^= seed << 19, seed ^= seed << 23;
    return seed % mod;}
void get_input() { For(i, 1, n) chkmax(l, x[i] = y[get_rand(c)]);
        For(i, 1, n) For(j, 1, k) w[i][j] = get_rand(1000000);
}int32_t main() { std::cin >> n >> p >> k >> c >> seed; For(i, 0, c - 1) std::cin >> y[i];
    get_input(); int b = 0; while ((1 << b) <= l) b += 1; vt<vi> f(2, vi(n + 1, 4e18)); f[0][p] = 0;
    For(i, 1, k) { vi a(1 << b, 4e18); For(j, 1, n) chkmin(a[x[j]], f[i & 1 ^ 1][j]);
        For(j, 0, b - 1) For(kk, 0, (1 << b) - 1) if ((kk & (1 << j)) == 0)
            chkmin(a[kk], a[kk | (1 << j)]); For(j, 0, (1 << b) - 1) a[j] -= 2 * j;
        For(j, 0, b - 1) For(kk, 0, (1 << b) - 1) if ((kk & (1 << j)))
            chkmin(a[kk], a[kk ^ (1 << j)]); For(j, 1, n) f[i & 1][j] = 2 * l + w[j][i] + a[x[j]];
    } For(i, 1, n) std::cout << f[k & 1][i] << " \n"[i == n];
}
```

吐槽一下这道题：

1. 代价里面加的 $L$ 对做题没有任何帮助，纯凑数而已。
2. 感觉 dp 状态太好设计了，甚至比 C 简单。
3. 出题人的 std 实现并不优秀，多了只 log 导致我的代码运行速度为 std 的 $\frac{1}{15}$。
4. 暴力枚举子集的方法 $O(k \cdot 3^t)$ 可以通过本题，导致这道题没啥意义了。

---

## 作者：swate114514 (赞：3)

## 题意

题目要求进行 $k$ 次操作，每次将当前位置 $a$ 转移到任意位置 $i$，每次操作的花费为 $w[i][j] + 2 \times (L - (x_a \& x_i))$，其中 $L$ 是数组 $\{x\}$ 的最大值。目标是在 $k$ 次操作后，求出所有位置的最小总花费。

## 思路

一眼 dp。

设 $dp_{j,i}$ 表示第 $j$ 次操作后转移到位置 $i$ 的最小花费。初始时 $dp_{0,p} = 0$，其余为无穷大。

直接转移的复杂度为 $O(kn^2)$，需要优化。考虑将 $x_i$ 的 16 位二进制拆分为高 8 位 $h_i$ 和低 8 位 $l_i$，则按位与运算可分解为：

$$x_v \& x_u = \left( (h_v \& h_u) \times 2^8 \right) + (l_v \& l_u)$$

代入转移方程：

$$dp_{j,u} = \min_{v} \left( dp_{j-1,v} - 2 \times \left( (h_v \& h_u) \times 256 + (l_v \& l_u) \right) \right) + w_{u,j} + 2L$$

考虑**分组优化。**

先预处理分组最小值：
- 对每个高位 $h$ 和低位 $l$，记录所有 $h_v = h$ 且 $l_v = l$ 的最小 $dp_{j-1,v}$：


$$
\text{minv}_{h,l} = \min_{\substack{v \\ h_v = h, l_v = l}} dp_{j-1,v}
$$

二次分组预处理：
- 对每个高位 $h_v$ 和查询的低位 $l_q$，预处理低位的最优解：

$$
\text{miin}_{h_v,l_q} = \min_{l_v} \left( \text{minv}_{h_v,l_v} - 2 \times (l_v \& l_q) \right)
$$

枚举所有可能的高位 $h_v$，计算总贡献：

$$
\text{sum} = \text{miin}_{h_v,l_u} - 2 \times (h_v \& h_u) \times 256
$$
最终 $dp_{j,u}$ 取所有 $h_v$ 的最小值，加上 $w_{u,j} + 2L$。

---

## Code

```cpp
#include <bits/stdc++.h>
#define LL long long
#define INF 1e18

using namespace std;

const int N = 2e5 + 10;
const int M = 11;

int n, p, k, c;
unsigned LL seed;
int x[N];
int w[N][M];
int y[65536];
int L;

int get_r&(int mod) {
	seed ^= seed << 14;
	seed ^= seed >> 7;
	seed ^= seed << 19;
	seed ^= seed << 23;
	return seed % mod;
}

void init() {
	for (int i = 1; i <= n; i++) x[i] = y[get_r&(c)];
	for (int i = 1; i <= n; i++) 
		for (int j = 1; j <= k; j++) 
			w[i][j] = get_r&(1000000);
}

int main() {
	cin >> n >> p >> k >> c >> seed;
	for (int i = 0; i < c; i++) cin >> y[i];
	init();
	
	L = *max_element(x + 1, x + n + 1);
	
	vector<LL> dp(n + 1, INF);
	dp[p] = 0;
	
	for (int step = 1; step <= k; step++) {
		vector<vector<LL>> minv(256, vector<LL>(256, INF));
		for (int v = 1; v <= n; v++) {
			if (dp[v] == INF) continue;
			int h = (x[v] >> 8) & 0xff; // 高8位
			int l = x[v] & 0xff;        // 低8位
			minv[h][l] = min(minv[h][l], dp[v]);
		}
		
		vector<vector<LL>> miin(256, vector<LL>(256, INF));
		for (int h = 0; h < 256; h++) {
			for (int lq = 0; lq < 256; lq++) {
				LL tmp = INF;
				for (int lv = 0; lv < 256; lv++) {
					if (minv[h][lv] != INF) {
						LL val = minv[h][lv] - 2LL * (lv & lq);
						tmp = min(tmp, val);
					}
				}
				miin[h][lq] = tmp;
			}
		}
		
		vector<LL> dp2(n + 1, INF);
		for (int u = 1; u <= n; u++) {
			int xu = x[u];
			int hu = (xu >> 8) & 0xff;
			int lu = xu & 0xff;
			LL min_cost = INF;
			for (int hv = 0; hv < 256; hv++) {
				if (miin[hv][lu] == INF) continue;
				LL cost = miin[hv][lu] - 2LL * (hv & hu) * 256;
				min_cost = min(min_cost, cost);
			}
			if (min_cost != INF)
				dp2[u] = min_cost + w[u][step] + 2LL * L;
		}
		
		dp = move(dp2);
	}
	
	for (int i = 1; i <= n; i++) cout << dp[i] << " ";
	cout << endl;
	
	return 0;
}
```

---

## 附：段子

> 比赛时写完了代码，结果忘交了。后来发现结果又忘交了……在打完 T3 的 0 分代码突然记起，交完 T3 后 5 秒后交了本题代码。

---

## 作者：冷却心 (赞：2)

锐评一下难度，B 放困难推式子推半天不会做发现 CD 都是简单题，/tuu。再锐评一下出题人怎么不卡暴力枚举子集的 $O(3^v)$ 做法。

dp。定义状态 $f_{i,j}$ 表示操作 $i$ 次恰好变为 $j$ 的最小代价。直接转移那么有：

$$ f_{i,j} = w_{i,j}+ \min_{k=1}^n \{f_{i-1,k}+2(L-(x_k \operatorname{AND} x_i))\}. $$ 

略微变形得到：

$$ f_{i,j}=2L + w_{i,j}+\min_{k=1}^n \{f_{i-1, k} - 2 (x_k \operatorname{AND} x_i)\}. $$ 

我们应当着手于后面的最小值。注意到这个值只和 $x_k$ 和 $x_i$ 有关。我们记 $\operatorname{bit}(x)$ 表示 $x$ 在二进制下为 $1$ 的位的集合。考虑一下按位与的性质，与得的结果一定是原数的子集，所以我们可以枚举 $x_i$ 与 $x_k$ 的按位与，然后考虑 $x_k$ 转移的贡献。哥们把贡献传到每个子集上，记辅助数组 $\displaystyle g_S=\min_{\operatorname{bit}(x_j) = S} f_{i-1,j}$，以及 $\displaystyle h_T=\min_{T \subseteq S} g_S$。那么我们就有转移 

$$ f_{i,j} = w_{i,j} + 2L + \min_{T \subseteq \operatorname{bit}(j)} \{h_T-2T\}. $$ 

会发现你枚举的 $T$ 不一定恰好等于两个数的与，可能是两个数的与的子集，但这个转移是对的，原因是：假如正确的按位与得到的是 $T_0$，而枚举到了一个 $T_1 \subset T_0$，在 $h_{T_0}= h_{T_1}$ 的情况下，显然 $2T_0 > 2T_1$，后者的转移不优。故转移有正确性。然后做完了。一共 $k$ 层转移，每次转移要枚举子集，设 $x_i$ 的值域为 $O(2^v)$，如果暴力枚举就是 $O(3^v)$，如果用 FMT 实现就是 $O(v 2^v)$，再加上最后转移回到 $f$ 数组还带一个 $O(n)$。根据实现的不同，总复杂度 $O((n+3^v) k)$ 或者 $O((n+v 2^v)k)$。

代码是 FMT 版本，和赛时写的暴力枚举子集相比总用时快了六倍。

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 2e5 + 10;
const int V = 16;
int n, K, P, X[N], W[N][11];

namespace RAND {
	int c, y[65536]; unsigned long long seed;
	int get_rand(int mod)
	{
		seed ^= seed << 14;
		seed ^= seed >> 7;
		seed ^= seed << 19;
		seed ^= seed << 23;
		return seed % mod;
	}
	void get_input()
	{
		for (int i = 0; i < c; i ++) cin >> y[i];
		for (int i = 1; i <= n; i++) X[i] = y[get_rand(c)];
		for (int i = 1; i <= n; i++) for (int j = 1; j <= K; j++) W[i][j] = get_rand(1000000);
	}
}

LL DP[11][N], tmp[1 << 16], g[1 << 16]; int popc[1 << 16];

int main() {
	freopen(".in", "r", stdin); freopen(".out", "w", stdout);
	ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin >> n >> P >> K >> RAND::c >> RAND::seed; RAND::get_input();
	int mx = 0;
	for (int i = 1; i <= n; i ++) mx = max(mx, X[i]);
	memset(DP, 0x3f, sizeof DP); DP[0][P] = 0;
	for (int i = 1; i <= K; i ++) {
		memset(tmp, 0x3f, sizeof tmp); memset(g, 0x3f, sizeof g);
		for (int j = 1; j <= n; j ++) g[X[j]] = min(g[X[j]], DP[i - 1][j]);
		for (int j = 0; j < V; j ++) for (int k = 0; k < (1 << V); k ++)
			if ((k >> j) & 1) g[k ^ (1 << j)] = min(g[k ^ (1 << j)], g[k]);
		for (int j = 0; j < (1 << V); j ++) g[j] -= 2 * j;
		for (int j = 0; j < V; j ++) for (int k = 0; k < (1 << V); k ++)
			if ((k >> j) & 1) g[k] = min(g[k], g[k ^ (1 << j)]);
		for (int j = 1; j <= n; j ++) DP[i][j] = g[X[j]] + 2 * mx + W[j][i];
	}
	for (int i = 1; i <= n; i ++) cout << DP[K][i] << " \n"[i == n];
	return 0;
}
```

---

## 作者：hyk2019 (赞：2)

$\gdef\and{\operatorname{and}}$

$\gdef\zaj{z\and j}$

省流：DP+子集枚举+高维前缀和。

---

一个显然的 DP 是，设 $dp_{i,j}$ 为第 $i$ 次操作后 $a=j$ 的最小代价。转移方程如下：

$$
dp_{i,j}:=\min_{z=1}^n(dp_{i-1,z}+w_{j,i}+2\times(L-(x_z\and x_j)))
$$

按上面的方式转移，时间复杂度是 $O(n^2k)$，显然超时。

注意到 $x_i<2^{16}$，因此 $n$ 个数里面肯定会有很多相同的。可以考虑从这一点下手。

定义 $r_{i,j}$ 为所有满足 $a_z=i$ 的整数 $z$（$1\le z\le n$）中 $w_{z,j}$ 的最小值，若不存在则设为 $+\infty$。

重新设计状态。设 $dp_{i,j}$ 为第 $i$ 次操作后 $x_a=j$ 的最小代价。转移方程如下：

$$
dp_{i,j}:=\min_{z=0}^L(dp_{i-1,z}+r_{j,i}+2\times(L-(\zaj)))
$$

这样转移可以得 $40$ 分。

---

求序列最小值时，一般会考虑提取公共项。上面的转移方程提取公共项后如下：

$$
dp_{i,j}:=(\min_{z=0}^Ldp_{i-1,z}-2\times(\zaj))+r_{j,i}+2\times L
$$

因此转移时只需要考虑如何求 $dp_{i-1,z}-2\times(\zaj)$ 的最小值即可。

由于 $0\le z<2^{16}$，因此实际上不同的 $\zaj$ 的数量不多。可以考虑子集枚举，将相同的 $\zaj$ 放在一起处理。用以下 Python 代码可以算出子集枚举的操作次数：

```py
sum(2 ** bin(i).count('1') for i in range(1 << 16))
```

结果是 $43046721$，乘上 $k$ 仍可以接受。

然而一个 $\zaj$ 可能对应了多个不同的 $z$，该如何求 $dp_{i-1,z}$ 的最小值呢？

把所有对应同一个 $\zaj$ 的 $z$ 对应的 $dp_{i,z}$ 都合并到一起，可以用高维前缀和处理。具体实现见代码。

完成以上这些处理之后，注意 $a=i$ 的答案是 $dp_{k,x_i} - r_{x_i,k} + w_{i,k}$，因为求的不是 $x_a=x_i$。


```cpp
#include <bits/stdc++.h>
using namespace std;

int n, p, k;

int c, y[65536], x[200005];
long long w[11][200005];
unsigned long long seed;
int get_rand(int mod)
{
    seed ^= seed << 14;
    seed ^= seed >> 7;
    seed ^= seed << 19;
    seed ^= seed << 23;
    return seed % mod;
}
void get_input()
{
    for (int i = 1; i <= n; i++) x[i] = y[get_rand(c)];
    for (int i = 1; i <= n; i++) for (int j = 1; j <= k; j++) w[j][i] = get_rand(1000000);
}

long long dp[11][1 << 16], lw[11][1 << 16];

int main() {
    memset(dp, 0x3f, sizeof dp);
    memset(lw, 0x3f, sizeof lw);
    scanf("%d%d%d%d%llu", &n, &p, &k, &c, &seed);
    for(int i = 0; i < n; i ++)
        scanf("%d", y + i);
    get_input();
    dp[0][x[p]] = 0;
    int L = 0;
    for(int i = 1; i <= n; i ++) {
        L = max(L, x[i]);
        for(int j = 1; j <= k; j ++)
            lw[j][x[i]] = min(lw[j][x[i]], w[j][i]);
    }
    for(int i = 1; i <= k; i ++) {
        for(int j = 0; j < 16; j ++)
            for(int z = 0; z < (1 << 16); z ++)
                dp[i - 1][z] = min(dp[i - 1][z], dp[i - 1][z | 1 << j]);
        for(int j = 0; j < (1 << 16); j ++) {
            dp[i][j] = 0x7fffffff;
            for(int z = j;; z = (z - 1) & j) {
                dp[i][j] = min(dp[i][j], dp[i - 1][z] - 2 * z);
                if(!z)
                    break;
            }
            dp[i][j] += 2 * L + lw[i][j];
        }
    }
    for(int i = 1; i <= n; i ++)
        printf("%lld ", dp[k][x[i]] - lw[k][x[i]] + w[k][i]);
    return 0;
}
```

---

## 作者：cly312 (赞：1)

### 题意描述
我们有一个由 $n$ 个“状态”（索引为 $1\ldots n$）组成的序列，每个状态的值 $x_i \in [0,2^{16})$。你从状态 $a=p$ 开始，在每一步 $j=1\ldots k$ 中，你可以从当前状态 $u$ 跳转到任意一个状态 $i$。跳转的代价是：

$$
 w_{i,j}\;+\;2\bigl(L - (x_u \,\&\, x_i)\bigr)
$$

其中：$L = \max_{1\le i\le n}x_i$。

你需要恰好进行 $k$ 次跳跃，并最终到达状态 $i$。我们要计算对于每个状态 $i$ 来说，达到它的最小总代价。

---

### 动态规划方法

朴素的动态规划公式如下：

$$
 \mathrm{dp}_{j,i}
 = \min_{u}\bigl\{\mathrm{dp}_{j-1,u}\;+\;w_{i,j}\;+\;2(L - (x_u\&x_i))\bigr\},
$$

如果直接实现这个式子，复杂度是 $O(n^2k)$，当 $n \approx 2 \cdot 10^5$、$k \le 10$ 时，这显然是不可行的。

我们可以将代价拆解为：

$$
 2(L - (x_u\&x_i)) = 2L - 2(x_u\&x_i),
$$

从而动态规划式变为：

$$
 \mathrm{dp}_{j,i} = w_{i,j} + 2L + \min_{u}\bigl\{\mathrm{dp}_{j-1,u} - 2(x_u\&x_i)\bigr\}.
$$

定义：

$$
 F_{u_{\rm mask}} = \min_{\{u\mid x_u=u_{\rm mask}\}}\mathrm{dp}_{j-1,u},
$$

然后对所有 $v_{\rm mask} < 2^{16}$，计算：

$$
 H_{v_{\rm mask}} = \min_{u_{\rm mask}} \Bigl\{F_{u_{\rm mask}} - 2(u_{\rm mask}\,\&\,v_{\rm mask})\Bigr\},
$$

最后：

$$
 \mathrm{dp}_{j,i} = w_{i,j} + 2L + H_{x_i}.
$$

---

### 关键优化：快速计算 $H_v$

我们需要高效地计算：

$$
 H_v = \min_{u}\bigl\{F_u - 2(u\;\&\;v)\bigr\},
$$

观察发现：

$$
 -2(u\&v) = \sum_{t=0}^{15} [-2 \cdot 2^t] \times ((u\gg t)\bmod2 \times (v\gg t)\bmod2),
$$

这是一个**可分离**的位操作函数，因此可以使用一种称为 **SOS-DP** 的技巧，逐位处理。

具体步骤如下：

1. 初始化数组 `arr`，使其等于 `F[]`；
2. 对每一位 $t = 0\ldots15$ 进行如下操作：
   - 如果当前 mask 的第 $t$ 位是 0：
     ```cpp
     newarr[mask]=min(arr[mask],arr[mask|(1<<t)]);
     ```
   - 如果当前 mask 的第 $t$ 位是 1：
     ```cpp
     newarr[mask]=min(arr[mask^(1<<t)], arr[mask]-2*(1<<t));
     ```
3. 最终 `arr[v]` 就是 $\min_u\{F_u - 2(u\&v)\}$。
---

### 代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll INF=(1LL<<60);
const int MAXK=12,D=16,M=65536,MAXN=200005;
int n,p,k,c;
unsigned ll seed;
int y[M],x[MAXN],w[MAXN][MAXK];
ll dp_prev[MAXN],dp_cur[MAXN];
ll F[M],arr1[M],arr2[M];
int get_rand(int mod){
    seed ^= seed << 14;
    seed ^= seed >> 7;
    seed ^= seed << 19;
    seed ^= seed << 23;
    return seed % mod;
}
void get_input(){
    for (int i = 1; i <= n; i++) x[i] = y[get_rand(c)];
    for (int i = 1; i <= n; i++) for (int j = 1; j <= k; j++) w[i][j] = get_rand(1000000);
}

int main(){
    cin>>n>>p>>k>>c>>seed;
    for(int i=0;i<c;i++){
        cin>>y[i];
    }
    get_input();
    int L=0;
    for(int i=1;i<=n;i++){
        if(x[i]>L) L=x[i];
    }

    for(int i=1;i<=n;i++){
        dp_prev[i]=(i==p?0:INF);
    }

    for(int step=1;step<=k;step++){
        for(int mask=0;mask<M;mask++){
            F[mask]=INF;
        }
        for(int i=1;i<=n;i++){
            int m=x[i];
            ll v=dp_prev[i];
            if(v<F[m]) F[m]=v;
        }

        ll* arr_old=arr1,*arr_new=arr2;
        for(int mask=0;mask<M;mask++){
            arr_old[mask]=F[mask];
        }

        for(int t=0;t<D;t++){
            int bit=1<<t;
            ll dt=2LL*bit;
            for(int mask=0;mask<M;mask++){
                if(mask&bit){
                    ll a0=arr_old[mask^bit];
                    ll a1=arr_old[mask]-dt;
                    arr_new[mask]=(a0<a1?a0:a1);
                }else{
                    ll a0=arr_old[mask];
                    ll a1=arr_old[mask|bit];
                    arr_new[mask]=(a0<a1?a0:a1);
                }
            }
            swap(arr_old,arr_new);
        }

        ll twoL=2LL*L;
        for(int i=1;i<=n;i++){
            int m=x[i];
            dp_cur[i]=(ll)w[i][step]+twoL+arr_old[m];
        }

        for(int i=1;i<=n;i++){
            dp_prev[i]=dp_cur[i];
        }
    }

    for(int i=1;i<=n;i++){
        if(i>1) cout<<' ';
        cout<<dp_prev[i];
    }
    cout<<"\n";
    return 0;
}
```

---

## 作者：sbno333 (赞：1)

让我想起某次校内模拟的技巧。

这里实现的常数比较大。

首先我们设 $dp_{i,j}$ 表示 $j$ 此操作后 $a$ 变成 $i$ 的最小代价，可以 $O(n^2k)$。

我们可以改成建图，连 $dp_{a,j-1}$ 到 $dp_{b,j}$ 的边，边权如题面所示。

复杂度没变，但是我们有前途了。

首先题面给的边权很大部分只跟终点有关，甚至只是常数。

我们可以把这部分去掉，变成点权，在每一层处理完最小值后再加就行。

剩下的就是 $-2(x_a\&x_b)$。

转移的时候我们发现我们只在意 $x_a$ 不同的，相同的取 $dp_{a,j-1}$ 最小。

答案统计的时候不加点权 $x_b$ 相同，答案就相同。

所以我们可以按照 $x_a$ 来建点，建 $2^{16}$ 个点，编号为 $0$ 到 $2^{16}-1$，表示 $x_a$ 取为这个编号时的节点。

如果这个节点在 $x$ 中出现过，初始时它的权值就是对应的最小 DP 值，否则就是正无穷。

考虑 $-a\&b=2^{16}-1-a\&b-(2^{16}-1)=(2^{16}-1-a)\|(2^{16}-1-b)-(2^{16}-1)$。

每个节点就是可以建 $16$ 条边，表示更改某位的权值，我们不妨让 $i$ 初始权值加上 $2^{16}-1-i$。

一条边权值如下：

这一位从 $0$ 变成 $1$，边权为 $0$。

这一位从 $1$ 变 $0$，权值为这一位的权值。

这样我们就能实现 $i$ 到 $j$ 的最短路（不妨设 $i$ 初始点权为 $2^{16}-1-i$，最短路考虑这个点权）是 $(2^{16}-1-a)\|(2^{16}-1-b)$。

然后跑一边 dijkstra。

做完了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,p,k;
int c, y[65536]; unsigned long long seed;
signed get_rand(signed mod)
{
    seed ^= seed << 14;
    seed ^= seed >> 7;
    seed ^= seed << 19;
    seed ^= seed << 23;
    return seed % mod;
}
int w[200009][19];
int x[1000009];
void get_input()
{	
	cin>>n>>p>>k>>c>>seed;
	for(int i=0;i<c;i++){
		cin>>y[i];
	}
    for (signed i = 1; i <= n; i++) x[i] = y[get_rand(c)];
    for (int i = 1; i <= n; i++) for (signed j = 1; j <= k; j++) w[i][j] = get_rand(1000000);
}
int d[1000009];
int an[200009];
#define pii pair<int,int>
priority_queue<pii,vector<pii>,greater<pii> > q;
void dj(){
	for(int i=0;i<(1ll<<17);i++){
		q.push({d[i],i});
	}
	while(q.size()){
		int t;
		t=q.top().second;
		int g;
		g=q.top().first;
		q.pop();
		if(d[t]<g){
			continue;
		}
		for(int i=0;i<17;i++){
			int s;
			s=(t^(1ll<<i));
			int zz;
			zz=0;
			if(t&(1ll<<i)){
				zz=(1ll<<i);
			}
			if(d[s]>d[t]+zz){
				d[s]=d[t]+zz;
				q.push({d[s],s});
			}
		}
	}
}
signed main(){
	get_input();
	int L;
	L=0;
	for(int i=1;i<=n;i++){
		L=max(L,x[i]);
		x[i]*=2;
	}
	L*=2;
	L-=(1ll<<17)-1;
	
	for(int i=1;i<=n;i++){
		an[i]=1e16;
	}
	an[p]=0;
	int z;
	z=1;
	while(k--){
		for(int i=0;i<(1ll<<17);i++){
			d[i]=1e16;
		}
		for(int i=1;i<=n;i++){
			d[x[i]]=min(d[x[i]],an[i]);
		}
		for(int i=0;i<(1ll<<17);i++){
			d[i]+=(1ll<<17)-i-1;
		}
		dj();
		for(int i=1;i<=n;i++){
			an[i]=1e16;
		}
		for(int i=1;i<=n;i++){
			an[i]=min(an[i],d[x[i]]);
		}
		for(int i=1;i<=n;i++){
			an[i]+=L+w[i][z];
		}
		z++;
	}
	for(int i=1;i<=n;i++){
		cout<<an[i]<<" ";
	}
	return 0;
}
```

时间复杂度 $O(nk+kx\log x\log\log x)$。

---

## 作者：_ayaka_ (赞：0)

### 思路

你发现前面的决策不会影响后面的决策，你开始考虑 DP。

你定义了 DP 式 $dp_{i,j}$，表示你在第 $j$ 次操作结束后以第 $i$ 个数为结尾的最小值。你发现 $w_{i,j}+2\times L$ 可以直接放入 $dp_{i,j}$ 中，需要处理的只有 $-2(x_a \& x_i)$ 这一部分。

你设 $r=x_a \& x_i$，发现 $2r=x_a+x_i-r \oplus x_a-r \oplus x_i$。于是你有了一个精妙的想法：

设 $h_{i,j}$ 为在进行第 $j-1$ 次转移到第 $j$ 次时 $r=i$ 的最小值。你对每个 $dp_{i,j-1}$ 枚举 $x_i$ 的子集 $p$ 转移进 $h_{p,j}$，值为 $dp_{i,j-1}-x_i+r\oplus x_i$。做完后对于每个 $dp_{i,j}$ 同样枚举 $x_i$ 的子集 $p$ 并取 $w_{i,j}+h_{p,j}-x_i+r\oplus x_i+2\times L$ 的最小值，就成功完成了转移。

然后你做 $k$ 次转移后，就完成了本题。如果将 $x_i$ 相同的数合并，时间复杂度为 $O(k3^v)$，$v$ 为最高位数。

### 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ll (k<<1)
#define rr (k<<1|1)
int n, p, k, x[500005], w[15][300005], L, dp[15][500005], h[500005];
//代码中的 i，j 与题解中定义相反 
int c, y[500005];
unsigned long long seed;
int get_rand(int mod) {
	seed ^= seed << 14;
	seed ^= seed >> 7;
	seed ^= seed << 19;
	seed ^= seed << 23;
	return seed % mod;
}
void get_input() {
	for (int i = 1; i <= n; i++) x[i] = y[get_rand(c)], L = max(L, x[i]);
	for (int i = 1; i <= n; i++) for (int j = 1; j <= k; j++) w[j][i] = get_rand(1000000);
}
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n >> p >> k >> c >> seed;
	for (int i = 0; i < c; i++) cin >> y[i];
	get_input();
	memset(dp, 0x3f, sizeof dp);
	for (int i = 1; i <= k; i++) {
		if (i == 1) {
			for (int j = 1; j <= n; j++) dp[i][j] = w[i][j] + 2 * (L - (x[p] & x[j]));
			continue;
		}//特殊处理 i=1 
		memset(h, 0x3f, sizeof h);
		for (int j = 1; j <= n; j++) {
			for (int r = x[j];; r = (r - 1)&x[j]) {
				h[r] = min(h[r], dp[i - 1][j] - x[j] + (r ^ x[j]));
				if (r == 0) break;
			}
		}
		for (int j = 1; j <= n; j++) {
			for (int r = x[j];; r = (r - 1)&x[j]) {
				dp[i][j] = min(dp[i][j], w[i][j] + h[r] - x[j] + (r ^ x[j]) + 2 * L);
				if (r == 0) break;
			}
		}//实际可以把所有 x_i 相等的数合并，w_i,j 取最小，以保证复杂度正确。但是我懒得写了。 
	}
	for (int i = 1; i <= n; i++) cout << dp[k][i] << " ";
	return 0;
}
```

---


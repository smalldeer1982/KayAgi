# [HNOI2002] 彩票

## 题目描述

某地发行一套彩票。彩票上写有 $1$ 到 $M$ 这 $M$ 个自然数。彩民可以在这 $M$ 个数中任意选取 $N$ 个不同的数打圈。每个彩民只能买一张彩票，不同的彩民的彩票上的选择不同。

每次抽奖将抽出两个自然数 $X$ 和 $Y$。如果某人拿到的彩票上，所选 $N$ 个自然数的倒数和，恰好等于 $\dfrac{X}{Y}$，则他将获得一个纪念品。

已知抽奖结果 $X$ 和 $Y$。现在的问题是，必须准备多少纪念品，才能保证支付所有获奖者的奖品。

## 说明/提示

$1 \leq X, Y \leq 100$，$1 \leq N \leq 10$，$1 \leq M \leq 50$。

输入数据保证输出结果不超过 $10^5$。

## 样例 #1

### 输入

```
2 4 3 4```

### 输出

```
1```

# 题解

## 作者：Ryo_Yamada (赞：22)

这题数据好像加强了，看到题解区里的都是远古题解了，（看上去）都是 $60pts \sim 80pts$ 的，来写一篇题解。

首先，这题卡精度，需要加上 `const double eps = 1e-10;` 感觉都会，就不多说了。

### $10pts$ 做法

直接爆搜+一个最常见的剪枝，如果比 $\dfrac{x}{y}$ 大就返回。

```cpp
#include <bits/stdc++.h>

using namespace std;

const double eps = 1e-10;

int n, m;
int ans;
double need;

void dfs(int st, double now, int last) {
    if(now - need > eps) return ;
    if(st == n) {
        if(fabs(now - need) < eps) ++ans;
        return ;
    }
    for(int i = last + 1; i <= m; i++) {
        dfs(st + 1, now + 1.0 / i, i);
    }
}

int main() {
    int x, y;
    cin >> n >> m >> x >> y;
    need = 1.0 * x / y;
    dfs(0, 0.0, 0);
    cout << ans << endl;
    return 0;
}
```
至此就能得到 $10pts$ ~~的好成绩~~。若是没时间了，写这样一个爆搜骗分是很不错的选择。

### $60 pts$ 做法

其实也很容易想，在上面代码的基础上加一个上下界剪枝就可以了。这个做法开 $O2$ 是可以过的，还跑的飞快，但是考试上是没有 $O2$ 选项的，所以我们需要思考更优的解法。

```cpp
#include <bits/stdc++.h>

using namespace std;

const double eps = 1e-10;

int n, m;
int ans;
double need;

void dfs(int st, double now, int last) {
    if(st == n) {
        if(fabs(now - need) < eps) ++ans;
        return ;
    }
    if(now > need + eps) return ;
    if(now + 1.0 * (n - st) / m > need + eps) return ;
    if(now + 1.0 * (n - st) / (last + 1) < need - eps) return ;
    for(int i = last + 1; i <= m; i++) {
        dfs(st + 1, now + 1.0 / i, i);
    }
}

int main() {
    int x, y;
    cin >> n >> m >> x >> y;
    need = 1.0 * x / y;
    dfs(0, 0.0, 0);
    cout << ans << endl;
    return 0;
}
```

### $80 pts \sim 100pts$ 做法

我们知道，除法（特别是浮点数除法）是非常慢的，在搜索中我们有很多多余的除法操作，如果把除法变成减法就会快很多。所以我们使用前缀和优化，使用 $pre_i$ 记录 $\dfrac{1}{1} + \dfrac{1}{2} + \dots + \dfrac{1}{i}$。同时或许还能剪掉很少的冗余状态，就拿下界剪枝来说，原来的下界是 $now + \dfrac{n - st}{m}$，而现在的是 $now + \dfrac{1}{m - n + st + 1} + \dots + \dfrac{1}{m}$。当然，这点优化可以忽略不计。可以看到，$\texttt{TLE}$ 的点最慢的是 $1.03s$，在这个基础上卡卡常[是能过的](https://www.luogu.com.cn/record/38380186)。

```cpp
#include <bits/stdc++.h>

using namespace std;

const double eps = 1e-10;

int n, m;
int ans;
double need;
bool vis[55];
double pre[55];

void dfs(int st, double now, int last) {
    if(st == n) {
        if(fabs(now - need) < eps) ++ans;
        return ;
    }
    if(now > need + eps) return ;
    if(now + pre[m] - pre[m - n + st] > need + eps) return ;
    if(now + pre[last + n - st] - pre[last] < need - eps) return ;
    for(int i = last + 1; i <= m; i++) {
        if(!vis[i]) {
            vis[i] = true;
            dfs(st + 1, now + 1.0 / i, i); 
            vis[i] = false;
        }
    }
}

int main() {
    int x, y;
    cin >> n >> m >> x >> y;
    need = 1.0 * x / y;
    for(int i = 1; i <= m; i++) pre[i] = pre[i - 1] + 1.0 / i;
    dfs(0, 0.0, 0);
    cout << ans << endl;
    return 0;
}
```

### $100pts$ 做法

在前面的代码中，每次搜索都是循环向后选择下一个增加的倒数，这就造成了很多多余的状态，不论后来有没有被剪掉，都或多或少会造成影响。（例如，后面剩下的数全部选择也不够 $n$ 个）

我们换个方式搜索，对于 $i$，我们搜索 选 或 不选。同时在前面加上对于个数的剪枝。此时，不开 $O2$ 最慢的点也只有 $790ms$ 了。

```cpp
#include <bits/stdc++.h>

using namespace std;

const double eps = 1e-10;

int n, m;
int ans;
double need;
bool vis[55];
double pre[55];

void dfs(int st, double now, int cnt) {
    if(m - st + 1 < n - cnt) return ;
    if(now + pre[m] - pre[m + cnt - n] > need + eps) return ;
    if(now + pre[st + n - cnt - 1] - pre[st - 1] < need - eps) return ;
    if(cnt == n) {
        ++ans;  
        return ;
    }
    dfs(st + 1, now, cnt);
    dfs(st + 1, now + 1.0 / st, cnt + 1);
}

int main() {
    int x, y;
    scanf("%d%d%d%d", &n, &m, &x, &y);
    need = 1.0 * x / y;
    for(int i = 1; i <= m; i++) pre[i] = pre[i - 1] + 1.0 / i;
    dfs(1, 0.0, 0);
    printf("%d\n", ans);
    return 0;
}
```


---

## 作者：pengym (赞：15)

- 不知道这道HNOI的题为什么没人发题解~~(是太水了么)~~

- 先说一下题意：很显然，题意要求从m个自然数中选择n个使得**倒数之和**为x/y，输出满足条件的方案数。(m<=50,n<=10)

- 数据范围就一定说明了很多，显然就是一个搜索剪枝。最基本的剪枝就是如果比x/y大就返回。还有两个剪枝就比较常见了。1.如果当前的值加上最大可能的值小于答案那就返回；2.如果当前的值加上最小可能的值大于答案那就返回。我抱着试一试的想法，然后就A了。不过肯定还有更多的剪枝，但是这样已经能过。
- 下附代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline void read(int &x)
{
	x=0;
	static int p;p=1;
	static char c;c=getchar();
	while(!isdigit(c)){if(c=='-')p=-1;c=getchar();}
	while(isdigit(c)) {x=(x<<1)+(x<<3)+(c-48);c=getchar();}
	x*=p;
}
const double eps=1e-10;
int n,m,x,y,ans;
double tag;
bool vis[60];
void dfs(int x,double sum,int last)
{
	if(sum-tag>eps)return;
	if(sum+(double)(n-x+1)*1.0/(double)(last+1)+eps<tag)return;
	if((sum+(double)(n-x+1)*1.0/(double)m)>tag+eps)return;
	if(x==n+1)
	{
		if(fabs(sum-tag)<=eps)ans++;
		return ;
	}
	for(int i=last+1;i<=m;i++)
	{
		if(!vis[i])
		{
			vis[i]=true;
			dfs(x+1,sum+1.0/(double)i,i);
			vis[i]=false;
		}
	}
}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n);read(m);read(x);read(y);
	tag=(double)x/(double)y;
	dfs(1,0,0);
	cout<<ans<<endl;
	return 0;
}

```

---

## 作者：郎赤娜 (赞：5)

大家好本蒟蒻来写题解了。

其实这道题就是一道DFS嘤嘤嘤。但是还是有很多要注意的点的。

首先写一个比较正常的爆搜，其长相大概如下
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,x,y,ans,a[55];
bool book[55];
double s[55],po;
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void dfs(register int step,register int num,register double sum)
{
	if(sum>po) return;
	if(step==n+1)
	{
		if(sum==po) ans++;
		return;
	}
	for(register int i=num+1;i<=m;i++)
	{
		if(!book[i])
		{
			book[i]=true;
			dfs(step+1,i,sum+1.0/(double)i);
			book[i]=false;
		}
	}
	return;
}
int main()
{
	n=read(),m=read(),x=read(),y=read();
	po=(double)x/(double)y;
	dfs(1,0,0.0);
	printf("%d",ans);
	return 0;
}
```
除去快读我想应该学过DFS人都能写这个趴。然后，我们就会获得~~10分的~~好成绩。
![](https://cdn.luogu.com.cn/upload/image_hosting/jl06av6v.png)
仔细看，~~罪恶的~~出题人竟然卡了精度！！！！
于是加上eps表示精度，注意这里要设成1e-10

还有一些剪枝，不然会TLE。也是一些常规剪枝啦，比如说当前的和加上后面的所有数还凑不到要求的x/y时return、当前的和加上最小的数还比x/y大时return...

一通瞎搞，就完美了。
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,x,y,ans,a[55];
bool book[55];
const double eps=1e-10;
double s[55],po;
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline double abs(double a)
{
	if(a>0) return a;
	return -a;
}
inline void dfs(register int step,register int num,register double sum)
{
	if(sum>eps+po) return;
	if(sum+(double)(n-step+1)*1.0/(double)(num+1)+eps<po)return;
    if((sum+(double)(n-step+1)*1.0/(double)m)>po+eps)return;
	if(step==n+1)
	{
		if(abs(sum-po)<=eps) ans++;
		return;
	}
	for(register int i=num+1;i<=m;i++)
	{
		if(!book[i])
		{
			book[i]=true;
			dfs(step+1,i,sum+1.0/(double)i);
			book[i]=false;
		}
	}
	return;
}
int main()
{
	n=read(),m=read(),x=read(),y=read();
	po=(double)x/(double)y;
	dfs(1,0,0.0);
	printf("%d",ans);
	return 0;
}
```

绿啦绿啦~

  本蒟蒻写这道题的题解有一个很重要的原因，当本蒟蒻被精度卡死的时候试图翻一下题解看看为什么就10分，这个时候我发现题解里的所有题解居然~~都是一模一样的并且变量名都不改~~，好啦大家知道为什么了趴。
  
而且我在题解里看到了今年最危险的OI言论——

![](https://cdn.luogu.com.cn/upload/image_hosting/kiseyy3c.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

emm，只能说本蒟蒻坚持快读死不悔改。

好啦本篇题解就到这里，祝大家~~NOIP~~CSP好成绩、RP++！

---

## 作者：_outcast_ (赞：3)

发现一个效率极高的做法

本质上还是爆搜 + 剪枝优化

### 题意转化
集合 $A\ = \{ x\mid x\leqslant m,x\in N^+\} $，$B$是$A$的$n$元子集满足 $\sum_{i=1}^n \frac{1}{a_i} = \frac{x}{y}$，($a_i\in B$ 且 $\bigcup_{i=1}^n\{ a_i\}=B$)，求 $B$ 的个数
### 分析
显然有一个递推做法

设 $f(i,j,k)$ 表示包含于 $\{1,2,3,…,i\}$ 且元素倒数和为 $k$ 的 $j$ 元集合个数，有递推方程：
$$
f(i,j,k)=
\left
\{\begin{array}{cc} 
		\sum f(i-1,j-1,k-\dfrac{1}{i})+f(i-1,j,k), k\ge   \dfrac{1}{i}\\
	    f(i-1,j,k),k<\dfrac{1}{i}
\end{array}\right.
$$
但是我们可以发现 $k$ 是一个分数,很难用数组储存

把式子写出来看看:

$\dfrac{1}{a_1}+\dfrac{1}{a_2}+…\dfrac{1}{a_n}=\dfrac{x}{y}$

两边同时乘$m!$

$\dfrac{m!}{a_1}+\dfrac{m!}{a_2}+…\dfrac{m!}{a_n}=\dfrac{xm!}{y}$

因为对于任意 $a_i$ 有 $a_i|m!$，于是 $f(i,j,k)$ 就可以改写成没有分数的形式

不过 $k$ 是 $m!$ 级别的巨大整数，肯定爆空间，怎么办呢？看起来这条路似乎走不通

观察到$m$和$n$的范围都比较小，再结合题目很自然能想到爆搜的做法

(我上面说的递推做法不是没有用处，等会再说)
### 搜索
首先普通的爆搜是 $O(C_n^m)$，显然会TLE，所以要加上剪枝
- 剪枝1

>一个比较显然的剪枝，假设已经枚举了 $k-1$ 个数，他们的倒数和为 $w$，当前枚举的数为 $a$，
设 $u=w+\sum_{i-1}^{n-k}\frac{1}{a+i}$，$v=w+\sum_{i=0}^{n-k-1}\frac{1}{m-i}$ 可以吧 $u，v$ 设定为上下界，即只要$\frac{x}{y}-w\notin[u,v]$ 就剪枝

>相对于纯暴力这个已经快很多了，优化一些常数后已经可以AC了

>我们发现 $v-u\ge \dfrac{1}{49}-\dfrac{1}{50}\approx0.0004$，看起来似乎很小，但是大部分情况下 $v-u$ 是远远大于这个值的，如此看来我们的上下界还不够严格
- 剪枝2

>这时我们再回过去考虑之前的递推式子，其不可行的关键在于 $k$ 的范围过大，考虑一下怎么缩小 $k$ 的范围，当然是——取！模！

>（注意我们剪枝的目的是减少状态规模，设定上下界时没必要与答案完全一样，而是尽量接近答案）

>用 mod 运算减少 $k$ 的规模，将其分为若干个剩余类，并且把 $f(i,j,k)$ 改为判定(True or False)，只要剩余类中有一个为True，就把此剩余类中所有的 $f$ 设为True

>这样会出现一个问题，就是会造成误判，但是对于剪枝则是一个很好的参考，而只要满足 $k$ 足够大，是可以保证其准确性的 (这是因为误判的比例随 $k$ 范围增大而减小) 然而我们不能无限的增加 $k$ 的范围，因为当 $k$ 增大时计算 $f$ 函数的时间和储存 $f$ 函数的空间都会增大

>我们要做的就是找到一个尽量平衡的模数(然而蒟蒻的我只有用尝试的方法找到一个数)

>好了，理论上做到这一步，我们的搜索已经很优了，但事实上还能更优！
- 剪枝2.5

>我们发现三元函数 $f$ 的值域只有(True or False)，可以联想到优化其中一维，具体操作如下：

>设 $f'(i,k)$ 表示包含于 $\{ i…m\}$ 的元素倒序和属于 $k$ 剩余系所需元素的最小值，于是：
$$
f'(i,k)=min
\left
\{\begin{array}{cc} 
	f'(i+1,k)\\
    f'(i+1,[k-\dfrac{m!}{i}])+1   
\end{array}\right.
$$
>(上面的中括号 $[$ $]$表示相关的取模运算)

>新的函数在给定了 $i$ 和 $k$ 时，就给出了 $j$ 的限制
### 代码实现

具体见注释 ( 剪枝1 + 剪枝2.5 )
```cpp
#include<iostream>
const int maxval=9973,inf=2147483647;
const double eps=1e-10;
int t,m,n,x,y,p,q,ans;
double target,s[81][81],w[81];
int v[81],f[81][9974];
inline void dfs(int cur,int count,double sum,int vv){
	if(count==m){ans++;return;}
	for(int i=cur+1;i<=n-(m-count)+1;i++){//上界限制 
		if(sum+s[i][i+(m-count)-1]-target< -eps) return;
		q=(t+maxval-vv)%maxval;//f函数限制 
		if(f[i][q]>m-count) return;//下界限制 
		if(sum+w[i]+s[n-(m-count-1)+1][n]-target<=eps)
		    dfs(i,count+1,sum+w[i],(vv+v[i])%maxval);
	}
}
inline int read(){
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^'0'),ch=getchar();
	return x;
}
signed main(){
	m=read(),n=read(),x=read(),y=read();
	target=x*1.0/y;
	for(int i=1;i<=n;i++) w[i]=1.0/i,s[i][i]=w[i];
	for(int i=1;i<=n;i++)
	    for(int j=i+1;j<=n;j++) s[i][j]=s[i][j-1]+w[j];//预处理i~j的倒数和 
	for(int i=1;i<=n;i++){
		v[i]=1;
		for(int j=2;j<=n;j++)
		    if(i!=j) v[i]=(v[i]*j)%maxval;
		v[i]=(v[i]*y)%maxval;
	}
	for(int i=0;i<=n+1;i++)
	for(int j=0;j<=maxval;j++) f[i][j]=inf;
	f[n+1][0]=0;t=x;
	for(int i=2;i<=n;i++) t=(t*i)%maxval;
	for(int i=n+1;i>=2;i--)//预处理f函数 
	    for(int j=0;j<=maxval;j++){
	    	p=(j+v[i-1])%maxval;
	    	if(f[i][j]<inf){
	    		if(f[i-1][j]>f[i][j]) f[i-1][j]=f[i][j];
	    		if(f[i][j]+1<f[i-1][p]) f[i-1][p]=f[i][j]+1;	
			}
	    }
	for(int i=n-m+1;i>=1;i--)
	    if(w[i]-target<=-eps) dfs(i,1,w[i],v[i]); 
	    else break;
	printf("%d",ans);
}
```
这个做法的效率[戳这里](https://www.luogu.com.cn/record/53244805)，可以看到即使是最慢的点也只有 22ms


虽然这个做法效率较高，但是依赖于数据范围，且实现比较困难，一般用剪枝1就够了




---

## 作者：Shikita (赞：3)

# 刚开始看这题似乎暴力可以莽一手，但是稍微想了一下就发现这题暴力肯定会T
50！/10！*40！=10272278170，看起来就知道可能性非常多，刚开始想用动态规划，但是这是实数于是泡汤，最后看数据不是很大，于是采用搜索加上剪枝
## 代码
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
int n,m,ans;
double cnt,x,y;
const double eps=1e-10;
double sum[60];
void dfs(int now,int rest,double tot)//当前数，剩下次数，目前总和
{
    double maxn=tot+sum[now+(n-rest)-1]-sum[now-1];
    double minn=tot+sum[m]-sum[m-(n-rest)];
    if(minn-cnt>eps||maxn-cnt<-eps) return;
    //如果加上最大也不能达到该值，那么剪枝；
    //如果加上最小值也超出该值，那么剪枝
    if(rest==n)//如果剩下次数做完
    {
        ++ans;
        return;
    }
    if(now==m+1) return;
    dfs(now+1,rest,tot);//不选
    dfs(now+1,rest+1,tot+1.0/now);//选
}
int main()
{
    cin>>n>>m>>x>>y;
    cnt=x/y;
    int bt;
    for(int i=1;i<=m;++i)
        if(1.0/i>cnt)
            bt=i;
//如果就选这一个都要超出范围，那么就绝对不选
//（虽然dfs里面也可以自己退出但是能省时间就省时间吧）
    for(int i=1;i<=m;i++)
        sum[i]=sum[i-1]+1.0/i;
    dfs(1,0,0.0);
    cout<<ans<<endl;
}
```
### 实测小聪明分析
1.这题用scanf比cin慢大概1060ms，不知道为什么

2.用了读入优化会比cin慢84ms（这无所谓）

3.在dfs之前的小剪枝
```
for(int i=1;i<=m;++i)
        if(1.0/i>cnt)
            bt=i；
```
这段如果不加会T，可能刚好对某个点起大作用，不过不加也应该没有问题

就写到这里，欢迎大佬们多多指教

---

## 作者：米奇奇米 (赞：2)

## 题解- [HNOI2002]彩票

### 题目意思：
 很小清新，就是给你一个$m$个数的排列中选择$n$个数多次(不能重复)，每次得到$n$个数的倒数和等于$x/y$的方案数量
 
### $Solution$
一开始以为是一道数论题目，后来想想数据范围不大可以用暴力解决。

* $20ptc$ **惨惨**

没有任何剪枝的暴力，但是值得注意的是**精度问题**。所以当搜索中每次得到的答案在一定小的误差内也可以算一种方案。

* $100ptc$

其实也很简单，就是多了几个简直而已。

* **剪枝1**： 如果当前得到的分数已经大于$x/y$就直接退出


* **剪枝2**： 如果当前的分数加上最大可能得到的分数都还小于$x/y$他也就可以退出。也就是当$(n-s+1)*(1/(las+1))+eps<x/y$ 。其中$las+1$就是当前可能得到最大的一项，那么把他乘上剩余项$(n-s+1)$都小于$x/y$，就可以$return$


* **剪枝3**： 如果当前的分数加上最小可能得到的分数都还大于$x/y$他也就可以退出。也就是当$(n-s+1)*1/m-eps>x/y$。和剪枝$2$同理


### $Code$
```cpp
#include <bits/stdc++.h>
#define eps 1e-10

using namespace std;

struct IO {
	#define gc getchar
	#define pt putchar

	inline int read() {
		int sum=0,ff=1; char ch=gc();
		while(!isdigit(ch)) {
			if(ch=='-') ff=-1;
			ch=gc();
		}
		while(isdigit(ch))
			sum=sum*10+(ch^48),ch=gc();
		return sum*ff;
	}

	inline void write(int x) {
	    if(x<0)
			pt('-'),x=-x;
	    if(x>9)
			write(x/10);
	    pt(x%10+48);
	}

	inline void writeln(int x) {
		write(x);
		pt('\n');
	}
} fast;

int n,m,x,y,ans,vis[55];
double goal;

#define db double

inline void Dfs(int s,double sum,int las) {
	if(sum-goal>eps) return;
//	printf("%.11lf\n",sum+(db)(n-s+1)*(db)(1/(db)las)+eps);
	if(sum+(db)(n-s+1)*(db)(1/(db)las)+eps<goal) return;
//	printf("%.11lf\n",sum+(db)(n-s+1)*(db)(1/(db)m)-eps);
	if(sum+(db)(n-s+1)*(db)(1/(db)m)-eps>goal) return;
	if(s==n+1) {
		if(fabs(sum-goal)<=eps) ans++;
		return;
	}
	for ( int i=las+1;i<=m;i++ ) 
		if(!vis[i]) {
			vis[i]=1;
			Dfs(s+1,sum+1/(double)i,i);
			vis[i]=0;
		}
}

int main() {
	n=fast.read();
	m=fast.read();
	x=fast.read();
	y=fast.read();
	goal=(double)x/(double)y;
	Dfs(1,0,0);
	fast.writeln(ans);
	return 0;
}

```


---

## 作者：lgswdn_SA (赞：2)

# 题解:P2236彩票（搜索剪枝）
题面：  

>某地发行一套彩票。彩票上写有1到M这M个自然数。彩民可以在这M个数中任意选取N个不同的数打圈。每个彩民只能买一张彩票，不同的彩民的彩票上的选择不同。  
每次抽奖将抽出两个自然数X和Y。如果某人拿到的彩票上，所选N个自然数的倒数和，恰好等于X/Y，则他将获得一个纪念品。  
已知抽奖结果X和Y。现在的问题是，必须准备多少纪念品，才能保证支付所有获奖者的奖品。  

数据范围： m<=50 。。。  
那么算法时间复杂度,不是次数很高的多项式就是指数级别，又因为DP根本(对我这个蒟蒻来说)~~不可实现~~，所以我们选择  
**暴力搜索！**  
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M = 59;
int n,m,x,y,ans;
double k;
void dfs(int pos,int cnt,double now){ //dfs(pos,cnt,now)代表枚举到第pos个数,之前选了cnt个数,总和为now  
	if(now>k) return;
	if(cnt==n){ans++;return;}
	if(pos==m+1) return;
	dfs(pos+1,cnt,now);
	dfs(pos+1,cnt+1,now+p[pos]);
}
int main(){
	cin>>n>>m>>x>>y;
	k=1.*x/y;
	for(int i=1;i<=m;i++) p[i]=1./i;
	dfs(1,0,0.);
	cout<<ans;
	return 0;
}
```


------------


当然做人不能太暴力，加上对  
**TLE**三个字母的~~惧怕~~，剪枝是必要的  

这道题最有效的剪枝是上下界剪枝，就是判断这种情况是不是一定会太大或者太小。

太大就是说这个情况加上可以的最小值还大于规定值，太小就是说这个情况加上可以的最大值还小于规定值。


------------

例如（比较简单的）
有一个队列  
 #### {6,8,9,14,16,29,31,32}  
求两两相加等于40的有多少个。（当然这道题也可以用二分来做）  

如果我们去枚举每一种可能性时，我们会发现6加上最大的32也不会超过40,那么选择6就一定不是可行的情况。


------------

运用到这道题来，就是
#### 如果当前的和加上之后能获得的最大值小于k或者加上之后能获得的最小值大于k，那么就byebye~
代码：  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M = 59;
const double eps=1e-9;
int n,m,x,y,ans;
double k,sum[M],p[M];
void dfs(int pos,int cnt,double now){ 
	double curmin=now+sum[m]-sum[m-n+cnt];//取之后的几个数（最小可能情况）
	double curmax=now+sum[pos+n-cnt-1]-sum[pos-1];
   //取最后几个数（最大可能情况）
	if((curmin-k>eps)||(k-curmax>eps)) return;//上下界剪枝
	if(cnt==n){ans++;return;}
	if(pos==m+1) return;
	dfs(pos+1,cnt,now);
	dfs(pos+1,cnt+1,now+p[pos]);
   //转移到下一个状态
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m>>x>>y;
	k=1.*x/y;
	for(int i=1;i<=m;i++) sum[i]=sum[i-1]+1./i;
   //sum是前缀和，用来计算之后能获得的最大or最小值
	for(int i=1;i<=m;i++) p[i]=1./i;
	dfs(1,0,0.);
	cout<<ans;
	return 0;
}
```
有问题! 问题（我曾经犯下的错误）在于  
```cpp
const double eps=1e-9
```
~~邪恶的~~出题人给我们卡了精度。。。  
于是应该是
```cpp
const double eps=1e-10
```
......  
正确代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M = 59;
const double eps=1e-9;
int n,m,x,y,ans;
double k,sum[M],p[M];
void dfs(int pos,int cnt,double now){ 
	double curmin=now+sum[m]-sum[m-n+cnt];//取之后的几个数（最小可能情况）
	double curmax=now+sum[pos+n-cnt-1]-sum[pos-1];
   	//取最后几个数（最大可能情况）
	if((curmin-k>eps)||(k-curmax>eps)) return;//上下界剪枝
	if(cnt==n){ans++;return;}
	if(pos==m+1) return;
	dfs(pos+1,cnt,now);
	dfs(pos+1,cnt+1,now+p[pos]);
  	//转移到下一个状态
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m>>x>>y;
	k=1.*x/y;
	for(int i=1;i<=m;i++) sum[i]=sum[i-1]+1./i;
   	//sum是前缀和，用来计算之后能获得的最大or最小值
	for(int i=1;i<=m;i++) p[i]=1./i;
	dfs(1,0,0.);
	cout<<ans;
	return 0;
}
```

---

## 作者：CaoXian (赞：1)

## [$\color{blue}\texttt{P2236 [HNOI2002]彩票}$](https://www.luogu.com.cn/problem/P2236) $\color{blue}\texttt{题解}$

暴搜和剪枝优化。

题目其实就是求在 `m` 个数中选 `n` 个数的倒数和有多少个结果为 $\dfrac{x}{y}$ 。直接搜索选哪些数，在加上两个可行性剪枝优化。

- 1. 如果剩下的数少于了需要的数，那么可以直接退出。
- 2. 如果当前的和加上可选的最小的几个数都大于需要的结果，可以直接退出。如果当前的和加上可选的最大的几个数都小于需要的结果同理。

对于需要重复计算的值（比如需要的结果 $\dfrac{x}{y}$ ，以及最大和最小的倒数和）可以提前计算或用前缀和优化。

再把 `eps` 取 $10 ^ {-10}$ 就可以了。

Code：
```cpp
#include <stdio.h>
const double eps = 1e-10;
int n, m, x, y, ans;
double t, sum[64];
void dfs(int s, int l, double v) {
	if(m - l < n - s || v + sum[m] - sum[m - n + s] - eps > t || v + sum[l + n - s] - sum[l] + eps < t) return;
	if(s == n) {++ans; return;}
	dfs(s, l + 1, v); dfs(s + 1, l + 1, v + 1.0 / (l + 1));
}
int main() {
	scanf("%d%d%d%d", &n, &m, &x, &y);
	for(int i = 1; i <= m; ++i) sum[i] = sum[i - 1] + 1.0 / i;
	t = x * 1.0 / y;
	dfs(0, 0, 0.0);
	printf("%d", ans);
	return 0;
}
```


---

## 作者：qzhwlzy (赞：1)

### [传送门](https://www.luogu.com.cn/problem/P2236)
## 思路
本题题目并不复杂，在 $1$ ~ $m$ 中找 $n$ 个数的倒数和相加等于 $x/y$ ，看起来只是一道简单的深搜，但是，只有10分。这道题的难点在于剪枝的点很多，基本上很难想全面，下面给出我的思路。  
首先，需要剪枝的情况有以下3种：  
1. 最简单的，已选的数之和大于 $k$ （ $k=x/y$ ，下同）；
2. 目前的和加上剩下数的最大和都小于 $k$ ；
3. 目前的和加上剩下数的最小和都大于 $k$ 。  

其次，本题的一大坑点在于，出题人卡精度（用 $eps$ 表示），设为 $1e-10$ 即可。（注： $1e-10$ 表示 1的-10次方）
## 代码片段
1. 深搜：  

这里以 $i$ 为已选的数字数（阶段数）， $j$ 为已经选了的数字范围， $sum$ 存储和。
```cpp
dfs(i+1,j+1,sum+1.0/(j+1));
dfs(i,j+1,sum);
```

2. 三种剪枝情况：
```cpp
if(sum>eps+k){
	return;
}else if(sum+(n-i)*1.0/(j+1)+eps<k){
	return;
}else if((sum+(n-i)*1.0/m)>k+eps){
   return;
}
```
## AC代码
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define eps 1e-10
#define maxn 55
using namespace std;
int n,m,x,y,ans=0,a[maxn];
double s[55],k;
void dfs(int i,int j,double sum){
	if(sum>eps+k){
		return;
	}else if(sum+(n-i)*1.0/(j+1)+eps<k){
		return;
	}else if((sum+(n-i)*1.0/m)>k+eps){
    		return;
	}else if(i==n){
		if(abs(sum-k)<=eps){//和满足要求且数量满足要求
			ans++;
		}
		return;
	}
	dfs(i+1,j+1,sum+1.0/(j+1));//要选这个数（即j+1）
	dfs(i,j+1,sum);//不选这个数
}
int main(){
	scanf("%d%d%d%d",&n,&m,&x,&y);
	k=(double)x/y;
	dfs(0,0,0.0);//初始阶段0，选到0（从1开始选），和为0
	printf("%d",ans);
	return 0;
}

```


---

## 作者：qwaszx (赞：1)

题意就是埃及分数.

一开始想手写分数类，$T$到飞起，于是改用实数了.

思想就是暴力枚举每一个埃及分数.

关于剪枝，dalao们说得已经十分清楚了.

有一个技巧是除法很慢，预处理出来直接用.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define eps 1e-10
using namespace std;
int n,m,ans;
double s[100],h[100];
void dfs(int t,int lst,double f)
{
    if(s[m]-s[m-(n-t+1)]-f>eps)return;//如果全都取最小的还是不能满足
    if(t>n&&(f<eps)){ans++;return;}
    for(int i=lst+1;i<=m-(n-t);i++)
    {
        if(h[i]+s[i+n-t]-s[i]-f<-eps)return;//如果全都取最大的还是不能满足
        dfs(t+1,i,f-h[i]);
    }
}
int main()
{
    int x,y;
    cin>>n>>m>>x>>y;int lst=0;double f=1.*x/y;
    for(int i=1;i<=m;i++)s[i]=s[i-1]+1./i;
    for(int i=1;i<=m;i++)h[i]=1./i;
    for(int i=m;i>=1;i--)if(h[i]>f){lst=i;break;}
    dfs(1,lst,1.*x/y);
    cout<<ans<<endl;
}
```

---


# [SDOI2015] 排序

## 题目描述

小 A 有一个 $1\sim 2^N$ 的排列 $A_1\sim A_{2^N}$，他希望将 $A$ 数组从小到大排序,小 $A$ 可以执行的操作有 $N$ 种，每种操作最多可以执行一次，对于所有的 $i(1\le i\le N)$，第 $i$ 种操作为将序列从左到右划分为 $2^{N-i+1}$ 段，每段恰好包括 $2^{i-1}$ 个数,然后整体交换其中两段。

小 A 想知道可以将数组 $A$ 从小到大排序的不同的操作序列有多少个。小 A 认为两个操作序列不同，当且仅当操作个数不同，或者至少一个操作不同（种类不同或者操作位置不同）。

下面是一个操作事例: $N=3,A=[3,6,1,2,7,8,5,4]$。
- 第一次操作，执行第 $3$ 种操作，交换 $A[1..4]$ 和 $A[5..8]$，交换后的 $A$ 为$[7,8,5,4,3,6,1,2]$。
- 第二次操作，执行第 $1$ 种操作，交换 $A[3]$ 和 $A[5]$，交换后的 $A$ 为$[7,8,3,4,5,6,1,2]$。
- 第三次操作，执行第 $2$ 种操作，交换 $A[1..2]$ 和 $A[7..8]$，交换后的 $A[1..8]$ 为$[1,2,3,4,5,6,7,8]$。

## 说明/提示

$100\%$ 的数据, $1\le N\le 12$。


## 样例 #1

### 输入

```
3
7 8 5 6 1 2 4 3```

### 输出

```
6```

# 题解

## 作者：MrMorning (赞：15)

#Brief Description

小A有一个1-2^N的排列A[1..2^N],他希望将A数组从小到大排序,小A可以执行的操作有N种,**每种操作最多可以执行一次**,对于所有的i(1<=i<=N),第i中操作为将序列从左到右划分为2^{N-i+1}段,每段恰好包括2^{i-1}个数,然后整体交换其中两段.小A想知道可以将数组A从小到大排序的\*不同\*的操作序列有多少个,小A认为两个操作序列不同,当且仅当操作个数不同,或者至少一个操作不同(种类不同或者操作位置不同).


#Algorithm Design

首先不难发现操作顺序不影响答案, 我们只需要考察每种操作是否选中, 若选中交换哪两块就好了. 一个合法的操作序列如果有$n$个操作, 那么可以给答案$contribute\ n!$.  我们从小到大考察每一种操作, 首先, 可以知道, 对于操作$2^i$, 序列肯定已经被分成了$2^{n-i+1}$个有序数列, 我们首先检查是否有序, 如果有问题直接$return$. 然后扫描每个块, 每两个块都必须是有序的, 否则要交换. 如果$tot \geqslant 4$那么一定不合法. 代码表达的非常清楚.


#Code
```cpp
#include <algorithm>
#include <cstdio>
#define ll long long
const int maxn = 1 << 13;
int n;
int a[maxn];
ll po[13];
ll ans;
bool check(int k) {
  for (int i = 1; i <= (1 << (n - k)); i++)
    if (a[(i - 1) * (1 << k) + 1] + (1 << (k - 1)) !=
        a[(i - 1) * (1 << k) + (1 << (k - 1)) + 1])
      return 0;
  return 1;
}
void swap(int i, int j, int k) {
  for (int m = 1; m <= k; m++)
    std::swap(a[i + m - 1], a[j + m - 1]);
}
void dfs(int now, int num) {
  if (now && !check(now))
    return;
  if (now == n) {
    ans += po[num];
    return;
  }
  dfs(now + 1, num);
  int tmp[5], tot = 0;
  for (int i = 1; i <= (1 << (n - now)); i += 2)
    if (a[i * (1 << now) + 1] != a[(i - 1) * (1 << now) + 1] + (1 << now)) {
      if (tot == 4)
        return;
      tmp[++tot] = i;
      tmp[++tot] = i + 1;
    }
  if (!tot)
    return;
  for (int i = 1; i <= tot; i++)
    for (int j = i + 1; j <= tot; j++) {
      swap((1 << now) * (tmp[i] - 1) + 1, (1 << now) * (tmp[j] - 1) + 1,
           1 << now);
      dfs(now + 1, num + 1);
      swap((1 << now) * (tmp[i] - 1) + 1, (1 << now) * (tmp[j] - 1) + 1,
           1 << now);
    }
}
int main() {
  // freopen("input", "r", stdin);
  po[0] = 1;
  for (int i = 1; i <= 12; i++)
    po[i] = po[i - 1] * i;
  scanf("%d", &n);
  for (int i = 1; i <= 1 << n; i++)
    scanf("%d", &a[i]);
  dfs(0, 0);
  printf("%lld", ans);
}
```
[我的博客](http://www.cnblogs.com/gengchen/p/6593071.html)


---

## 作者：Orion545 (赞：14)

# 广告

[这里观赏体验更佳](https://www.cnblogs.com/dedicatus545/p/9255850.html)

# 思路

## UPD@191114

经过评论区@yybakioi同学指出，这篇题解少了点东西

在有两个不连续递增段的情况中，我提到要考虑四种情况。然而，**注意到四种交换里面最多只有两种是合法的**，因此时间复杂度其实是$O(n^2\ast2^n\ast2^n)$，即$O(2415919104)$，的确超出了正常范围。

不过，感谢万能的dfs，让我通过本题

## 原文

首先，这道题目有一个非常显然（但是我不会严格证明，只能意会一下）的结论：一个合法的操作序列中，任意两个操作是可以互换的

那么，这个结论加上本题极小的数据范围，为什么不搜索一下呢？

ok说干就干

既然顺序不重要，我们就从交换两个长度为1的序列开始搜索

这时，就有另外一个性质：因为我们每种交换能且只能做一次，所以有的情况下我们是一定无法完成的

考虑交换两个长度为$2^k$的序列，这时我们把整个序列分成长度为$2^{k+1}$的段

如果这些段全部都是连续且递增（也就是3,4,5,6这样）的，说明这个操作不用做

如果这些段里面有一个不是连续递增的，就把这个段的前后两半交换

如果这些段里面有两个不是连续递增的，那么我们对于这两段的两半，讨论四种交换的情况，分别判断它们是否合法

如果这些段里面有超过两个不是连续递增的，那么可以证明此时我们一定无法完成排序，可以把这个搜索枝剪掉

这样操作以后，我们会发现，对于所有合法的长度为$2^k$的序列的交换，完成之后的序列，一定由若干个长度为$2^{k+1}$的连续递增序列构成

这时我们再递归到下一层处理，递归n层以后要判断一下最终序列是否是1-n，然后用当前这个操作序列中的操作个数的阶乘加到答案上（因为可以随意改变操作顺序）

总时间复杂度为$O(2^{24})$，但是远远达不到这个值

# Code

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
#include<vector>
using namespace std;
inline ll read(){
    ll re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
} 
ll n,a[5010],tmp[5010][15];
vector<int>ans;//不同的操作序列的操作个数
void dfs(ll k,ll num){
    ll i,j,t,cnt=0,m1,m2;//cnt是非连续递增的段的个数，m1m2是前两个的起点
    if(k==n+1){
        for(i=1;i<=(1<<n);i++) if(tmp[i][k]!=i) return;
        ans.push_back(num);return;//注意到
    }
    for(i=1;i<=(1<<n);i+=(1<<k)){//统计cnt
        t=tmp[i][k];
        for(j=i+1;j<i+(1<<k);j++){
            if(tmp[j][k]!=t+j-i){
                if(cnt==2) return;
                cnt++;
                if(cnt==1) m1=i;
                else m2=i;
                break;
            }
        }
    }
    if(cnt>2) return;
    for(i=1;i<=(1<<n);i++) tmp[i][k+1]=tmp[i][k];
    if(cnt==0){
        dfs(k+1,num);return;
    }
    if(cnt==1){
        for(j=m1;j<m1+(1<<k-1);j++) swap(tmp[j][k+1],tmp[j+(1<<k-1)][k+1]);
        dfs(k+1,num+1);return;
    }
    bool flag=1;//这里开始枚举四种情况
    for(i=1;i<=(1<<k-1);i++) swap(tmp[m1+i-1][k+1],tmp[m2+i-1][k+1]);
    for(i=1;i<=(1<<k);i++) if(tmp[m1+i-1][k+1]-tmp[m1][k+1]!=i-1) flag=0;
    for(i=1;i<=(1<<k);i++) if(tmp[m2+i-1][k+1]-tmp[m2][k+1]!=i-1) flag=0;
    if(flag) dfs(k+1,num+1);
    flag=1;
    for(i=1;i<=(1<<n);i++) tmp[i][k+1]=tmp[i][k];
    for(i=1;i<=(1<<k-1);i++) swap(tmp[m1+(1<<k-1)+i-1][k+1],tmp[m2+i-1][k+1]);
    for(i=1;i<=(1<<k);i++) if(tmp[m1+i-1][k+1]-tmp[m1][k+1]!=i-1) flag=0;
    for(i=1;i<=(1<<k);i++) if(tmp[m2+i-1][k+1]-tmp[m2][k+1]!=i-1) flag=0;
    if(flag) dfs(k+1,num+1);
    flag=1;
    for(i=1;i<=(1<<n);i++) tmp[i][k+1]=tmp[i][k];
    for(i=1;i<=(1<<k-1);i++) swap(tmp[m1+i-1][k+1],tmp[m2+(1<<k-1)+i-1][k+1]);
    for(i=1;i<=(1<<k);i++) if(tmp[m1+i-1][k+1]-tmp[m1][k+1]!=i-1) flag=0;
    for(i=1;i<=(1<<k);i++) if(tmp[m2+i-1][k+1]-tmp[m2][k+1]!=i-1) flag=0;
    if(flag) dfs(k+1,num+1);
    flag=1;
    for(i=1;i<=(1<<n);i++) tmp[i][k+1]=tmp[i][k];
    for(i=1;i<=(1<<k-1);i++) swap(tmp[m1+(1<<k-1)+i-1][k+1],tmp[m2+(1<<k-1)+i-1][k+1]);
    for(i=1;i<=(1<<k);i++) if(tmp[m1+i-1][k+1]-tmp[m1][k+1]!=i-1) flag=0;
    for(i=1;i<=(1<<k);i++) if(tmp[m2+i-1][k+1]-tmp[m2][k+1]!=i-1) flag=0;
    if(flag) dfs(k+1,num+1);
}
int main(){
    n=read();ll i,tans=1,out=0,j;
    for(i=1;i<=(1<<n);i++) a[i]=read(),tmp[i][1]=a[i];
    dfs(1,0);
    for(i=0;i<ans.size();i++){//阶乘更新答案
        tans=1;
        for(j=1;j<=ans[i];j++) tans*=j;
        out+=tans;
    }
    cout<<out;
}
```

---

## 作者：ez_lcw (赞：3)

仔细审题：

> 两个操作序列不同,当且仅当操作个数不同,或者至少一个操作不同（种类不同或者操作位置不同（注意，这里的“操作位置”指的是操作顺序））。

也就是说操作序列对答案的贡献多与少和你某一次操作交换哪两段数字没有关系。

还有一个：

> 每种操作最多可以执行一次。

这是一个很重要的条件。

考场上手玩了一下样例，发现操作结果和操作顺序没有关系（结论1，证明是赛后才想出来的）。

那么我们把操作种类都相同的操作序列都归为一类。显然，根据结论1，如果某一类中的某一个操作序列（设其长度为 $len$）能实现将数组 $A$ 从小到大排序，那么这一类的所有操作序列（显然，这一类的所有操作序列都是 $len$）都可以实现将数组 $A$ 从小到大排序，那么这一类的所有操作序列对答案的贡献是 $len!$。

那么对于一类操作序列，我们就先钦定操作序列的操作种类是从小到大的，然后再看能不能满足题意。比如说对于一类操作序列 $\{132,123,213,231,312,321\}$，我们就看操作序列 $123$ 能不能满足题意。

考虑用 dfs 枚举每一种操作做不做，最后得出一个操作种类从小到大排的操作序列，时间复杂度 $O(2^n)$。

关键是如何判断一种操作序列能不能满足题意。

不妨设当前的操作序列是 $k_1,k_2,\dots,k_m$，有 $k_1<k_2<\dots<k_m$。

~~接下来的时间点可能会有点复杂，请耐心阅读。~~

假设我们现在要执行操作 $k_i$，那么就要将序列从左到右划分为 $part=2^{n-k_i+1}$ 段,每段恰好包括 $len=2^{k_i-1}$ 个数,然后整体交换其中两段。那么有：

1. 如果某一段内的数不是已经排好序的话，这种操作序列不可能满足题意，因为之后的操作都比这一次操作大，段内的顺序是不可能再改变的了。

2. 如果某一段的开头不是 $len\times t+1 (t\in \mathbb{N})$ 的话，这种操作也不可能满足题意。

假设我们现在要执行操作 $k_i$，且满足上面的两个条件，那么我们现在要为**下一次执行操作**做准备，也就是说要把每段内的数排好序（**这里的“段”是指按操作 $k_i+1$ 分的段**）。

也就是说要保证：把**当前**数组分的段**两两合并成一段后**，每一段内是要排好序的。比如**当前** $56|78|34|12$（“$|$”是分段的意思），**两两合并成一段后**得保证每段内要排好序，也就是要把**当前**的第 $1$、$2$ 段交换，再两两合并：$56|78|34|12\rightarrow 56|78|12|34 \rightarrow 5678|1234$。

那么我们可以先按照下一次操作的分法，得出有哪些段（**这里的“段”是指按操作 $k_i+1$ 分的段**）是不符合要求的，然后分情况讨论：

1. 有大于 $2$ 段不符合条件，不能满足题意，因为一次交换操作最多只能改变两段。

1. 所有段都符合条件，那么不用执行操作 $k_i$，直接向下递归。

1. 只有 $1$ 段不符合条件，那么就把这段的两个小段（**小段是指按操作 $k_i$ 分的段**）前后交换，因为我们已经保证了这两个小段是满足条件的。

1. 恰有 $2$ 段不符合条件，设这两段为 $x$、$y$，$x$ 分出来的两个小段为 $a$、$b$，$y$ 分出来的两个小段为 $c$、$d$。那么我们分四种情况看符不符合题意：$\operatorname{swap}(a,c)$、$\operatorname{swap}(a,d)$、$\operatorname{swap}(b,c)$、$\operatorname{swap}(b,d)$。

最后一直到 $k_i=n$ 都满足条件的话，就可以记录并返回了。

因为我们是按操作种类来枚举的，所以每个答案都要阶乘一下，而且要用状压记录一下操作种类防止算重（代码中有注释）。

代码如下：

```cpp
#include<bits/stdc++.h>

#define P 4100
#define ll long long

using namespace std;

ll ans;
int n,pown,a[P];
bool vis[P];//状压记录每个序列种类

ll A(int x)//阶乘
{
	ll ans=1;
	for(int i=1;i<=x;i++)
		ans*=i;
	return ans;
}

void swapp(int st1,int ed1,int st2,int ed2)//将A[st1,ed1]与A[st2,ed2]交换
{
	for(int l=st1,r=st2;l<=ed1;l++,r++)
		swap(a[l],a[r]);
}

bool check(int st,int ed,int len)//看A[st,ed]是否满足题解中说到的两个条件
{
	if((a[st]-1)%len) return false;//条件2
	for(int i=st+1;i<=ed;i++)
		if(a[i]!=a[i-1]+1)//条件1
			return false;
	return true;
}

void dfs(int k,int sum,int sta)
{
	if(k==n)//退出
	{
		if(!vis[sta])//判断防止算重
		{
			ans+=A(sum);
			vis[sta]=true;
		}
		return;
	}
	int len=1<<(k+1),part=1<<(n-k-1);
	vector<int>wrong;//有哪些段是不符合条件的
	wrong.clear();
	for(int i=1;i<=part;i++)
	{
		int st=(i-1)*len+1,ed=i*len;
		if(!check(st,ed,len)) wrong.push_back(i);
	}
	if(wrong.size()>2) return;//大于2不符合题意
	if(!wrong.size())//等于0直接向下递归
	{
		dfs(k+1,sum,sta);
		return;
	}
	if(wrong.size()==1)//等于1交换前后两个小段
	{
		int id=wrong[0];
		int st=(id-1)*len+1,ed=id*len,mid=(st+ed)/2;
		swapp(st,mid,mid+1,ed);
		dfs(k+1,sum+1,sta|(1<<k));
		swapp(st,mid,mid+1,ed);
		return;
	}
   //等于2分四种情况讨论
	int id1=wrong[0],id2=wrong[1];
	int st1=(id1-1)*len+1,ed1=id1*len,mid1=(st1+ed1)/2;
	int st2=(id2-1)*len+1,ed2=id2*len,mid2=(st2+ed2)/2;
	
	swapp(st1,mid1,st2,mid2);
	if((check(st1,ed1,len)&&check(st2,ed2,len))) dfs(k+1,sum+1,sta|(1<<k));
	swapp(st1,mid1,st2,mid2);
	
	swapp(st1,mid1,mid2+1,ed2);
	if((check(st1,ed1,len)&&check(st2,ed2,len))) dfs(k+1,sum+1,sta|(1<<k));
	swapp(st1,mid1,mid2+1,ed2);
	
	swapp(mid1+1,ed1,st2,mid2);
	if((check(st1,ed1,len)&&check(st2,ed2,len))) dfs(k+1,sum+1,sta|(1<<k));
	swapp(mid1+1,ed1,st2,mid2);
	
	swapp(mid1+1,ed1,mid2+1,ed2);
	if((check(st1,ed1,len)&&check(st2,ed2,len))) dfs(k+1,sum+1,sta|(1<<k));
	swapp(mid1+1,ed1,mid2+1,ed2);
}

int main()
{
	scanf("%d",&n);
	pown=1<<n;
	for(int i=1;i<=pown;i++)
		scanf("%d",&a[i]);
	dfs(0,0,0);
	printf("%lld\n",ans);
	return 0;
}
/*
2
1 3 2 4
*/
/*
3
3 6 1 2 7 8 5 4
*/
/*
2
1 4 2 3
*/
```

---

## 作者：zero4338 (赞：3)

##  Solution
首先有结论  
>对于任意一个操作序列 , 操作之间之间的顺序可以任意交换 .   

应该比较显然 , 手模一下应该就可以发现 .  
既然操作序列的顺序可以交换 , 那么我们可以找出所有的操作种类递增的操作序列 , 然后把它们序列长度的阶乘相加起来就是答案 .   
现在的问题是 , 如何找出所有操作递增的序列 .   
容易发现 , 在第 $i$ 次操作时 , 必须将所有 $[k* 2^i,k* 2^i+2^i]\  k\in N$ 的区间全部变为单调递增 . 因为如果在这次操作时没有把它变为单调递增 , 那么后面的所有操作都不能再对这段区间进行操作 . 那么每次操作时都要找出当前需要更改的点 , 如果不能用一次操作使之合法就返回 .   
但直接这么写可能不太好实现 , 这里提供一种比较好写的思路 .  
首先考虑第一次操作 .  
目标序列中显然奇数一定在奇数位上 , 故我们先找出所有数字奇偶性与位置奇偶性不相同的数字 , 如果可以通过一次操作实现 , 那么这些数字一定是一奇一偶 , 这时我们交换它们 , 同时记录我们已经执行了操作 , 若奇偶性全都相同则不记录 .  
然后再对整个序列进行遍历寻找不符合递增的数对 , 并记录他们 , 如果前面已经执行了奇偶的交换 , 那么如果在这里一旦发现不符合的数对 , 直接返回 . 如果全都满足递增 , 那么我们就直接向下递归 . 如果不符合的数对大于两个 , 那么就不可能 . 否则就交换两个数对前面的数或者后面的数 , 分别递归 .  
注意到已经排好序的序列没有继续保存的必要 , 所以向下递归时可以把序列长度减少一半 , 并将所有奇数位数字 $x$ 变为 $(x+1)/2$ , 这样处理后递归下去的情况处理就可以和第一次一样 .   
具体实现见代码 .  
#### 时间复杂度  
因为每次dfs是最多进入两个分支 , 所以dfs树上第 $i$ 层最多只有 $2^i$ 个点 , 而在每次向下递归时都将序列长度缩小了一半 , 所以对于第 $i$ 层的节点 , 求解出它们的操作的复杂度为 $O(2^{n-i})$ , 所以总时间复杂度为 $\sum\limits_{i=0}^n 2^i* 2^{n-i} =(n+1)* 2^n$ , 当 $n$ 取最大 $12$ 时为 $53248$ , 可以通过 . 
## Code
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int maxn=1<<13;
int read()
{
    int ret=0;char c=getchar();
    while(c>'9'||c<'0')c=getchar();
    while(c>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+(c^48),c=getchar();
    return ret;
}
int n;
int a[maxn];
int ans,fac[13];
void dfs(int now,int p[],int tim)//now 记录当前进行哪种操作 p[] 记录当前序列 tim 记录已经操作次数
{
    if(now==n+1)//处理完毕
    {
        ans+=fac[tim];return;
    }
    int x1=0,x2=0;
    int oflag=0,flag=0;//oflag 表示奇偶性不同的个数 flag 表示不满足递增的个数 
    for(int j=1;j<=(1<<(n-now+1));j++)
    {
        if(p[j]%2!=j%2)
        {
            oflag++;
            if(!x1)x1=j;
            else x2=j;
        }
    }
    if(oflag>2)return;
    if(oflag==2)swap(p[x1],p[x2]);
    for(int j=1;j<=(1<<(n-now+1));j+=2)
    {
        if(p[j]!=p[j+1]-1)
        {
            if(oflag)return;//如果同时有不满足奇偶和递增那么一次操作一定无法满足
            flag++;
            if(!x1)x1=j;
            else x2=j;
            if(flag>2)return;
        }
    }
    for(int j=1;j<=(1<<(n-now+1));j+=2)p[(j+1)>>1]=(p[j]+1)>>1;//对序列进行处理
    if(flag==0)
    {
        if(!oflag)dfs(now+1,p,tim);
        else dfs(now+1,p,tim+1);//如果进行了奇偶调换那么要增加当前次数
        return;
    }
    int tmp[maxn];//临时保存数组
    for(int i=1;i<=(1<<(n-now));i++)tmp[i]=p[i];
    dfs(now+1,p,tim+1);
    for(int i=1;i<=(1<<(n-now));i++)p[i]=tmp[i];
    swap(p[(x1+1)>>1],p[(x2+1)>>1]);//与上一个dfs分别对应交换前面的数和交换后面的数
    dfs(now+1,p,tim+1);
    return;
}
int main()
{
    n=read();
    for(int i=1;i<=(1<<n);i++)a[i]=read();
    fac[0]=1;
    for(int i=1;i<=n;i++)fac[i]=fac[i-1]*i;
    dfs(1,a,0);
    printf("%d",ans);
    return 0;
}
```


---

## 作者：shiroi (赞：2)

### 题目大意

给定一个长度为 $2^n$ 的排列，现在将序列分成每段长 $2^{(i-1)}$ 的 $2^{(n-i+1)}$ 段，然后任选两段交换，求有多少操作序列能把序列排出来。

### 题目分析

观察题目发现操作顺序和答案是无关的。

我们需要确定某个操作序列中每个操作选不选，因此可以考虑用搜索。从小到大DFS，对于第 $i$ 次操作我们将序列分成 $2^{(n-i)}$ 段，每段长度为 $2^i$ 。

之后找出序列中不合法的段数，如果这样的段超过2个，那么直接判定为无解。

如果有一个这样的段，判断将这个段的前后交换后是否合法，如果是就交换然后继续DFS。

如果有两个这样的段就分类讨论然后DFS。

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int read()
{
	int x=0; int f=1; char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-')f=-1; ch=getchar();}
	while(isdigit(ch)) {x=x*10+ch-'0'; ch=getchar();}
	return x*f;
}

const int MAXN = 5005;
int bin[20],fac[20],a[MAXN];
long long ans,n;

inline bool check(int x,int k)
{
	for(int i=1; i<bin[k]; i++)
		if(a[x+i]!=a[x+i-1]+1) return 0;
	return 1;
}

inline void swap(int x,int y,int k)
{
	for(int i=0; i<bin[k]; i++)
		swap(a[x+i],a[y+i]);
}

void dfs(int k,int cur)
{
	if(k==n+1)
	{ans+=fac[cur]; return;}
	int t1=0,t2=0;
	for(int i=1; i<=bin[n]; i+=bin[k])
		if(!check(i,k))
		{
			if(!t1) t1=i;
			else if(!t2) t2=i;
			else return;
		}
	if(!t1 && !t2) dfs(k+1,cur);
	else if(t1 && !t2)
	{
		swap(t1,t1+bin[k-1],k-1);
		dfs(k+1,cur+1);
		swap(t1,t1+bin[k-1],k-1);
	}
	else
	{
		for(int x=0; x<=1; x++)
			for(int y=0; y<=1; y++)
			{
				swap(t1+x*bin[k-1],t2+y*bin[k-1],k-1);
				if(check(t1,k) && check(t2,k))
				{
					dfs(k+1,cur+1);
					swap(t1+x*bin[k-1],t2+y*bin[k-1],k-1);
					break;
				}
				swap(t1+x*bin[k-1],t2+y*bin[k-1],k-1);
			}
	}
}

int main(int argc, char const *argv[])
{
	n=read(); bin[0]=1; fac[0]=1;
	for(int i=1; i<20; i++)
		bin[i]=bin[i-1]<<1;
	for(int i=1; i<=12; i++)
		fac[i]=fac[i-1]*i;
	for(int i=1; i<=bin[n]; i++)
		a[i]=read();
	dfs(1,0); printf("%lld",ans);
	return 0;
}
```

---

## 作者：_Toz (赞：1)

首先正如楼上几位所说，操作顺序不影响结果。

那么我们只要考虑操作的集合。

所以对于每一种可行的操作集合 $S$ ，它对答案的贡献为 $|S|$$!$ 。转化为求所有可行的集合。

因为每个操作最多做一次，我们从小到大DFS，这样就可以保证当前区域内一定时严格连续递增的。对于第$i$次操作我们将序列分成$2^{n-i}$段，每段长度$2^i$。
我们去找序列中不是严格连续递增的区域。

如果没有这样的一段区域，无需执行这个操作

如果有一个这样的区域，判断将这个段的前半部分和后半部分交换后是否连续递增，如果是就交换然后继续DFS

如果有两个这样的段，判断把每个段分成两份，两两交换，共四种交换情况然后DFS。


```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 20;

int n, a[5000], Fac[N + 10], Pow_2[N + 10], ans;

void Init() {
	
	cin >> n;
	
	Pow_2[0] = 1;
	for (int i = 1; i <= 12; i ++)
		Pow_2[i] = Pow_2[i - 1] * 2;
	
	Fac[0] = 1;
	for (int i = 1; i <= 12; i ++)
		Fac[i] = Fac[i - 1] * i; 
		
	for (int i = 1; i <= Pow_2[n]; i ++)
		cin >> a[i];
}

void Swap(int pos_1, int pos_2, int cur) {
	for (int i = 0; i < Pow_2[cur]; i ++) swap(a[pos_1 + i], a[pos_2 + i]);
	return ;
}

bool Check(int pos, int cur) {
	for (int i = 1; i < Pow_2[cur]; i ++)
		if (a[pos + i] != a[pos + i - 1] + 1) return 0;
	
	return 1;
}

void DFS(int cur, int dep) {
	 
	if (cur > n) {
		ans += Fac[dep];
		return ;
	}
	
	int Pos_1, Pos_2;
	
	Pos_1 = Pos_2 = 0;
	
	for (int i = 1; i <= Pow_2[n]; i += Pow_2[cur]) {
		if (!Check(i, cur)) {
			if (!Pos_1) Pos_1 = i;
			else if (!Pos_2) Pos_2 = i;
		}
	}
	
	if (!Pos_1 && !Pos_2) DFS(cur + 1, dep);
	else if (Pos_1 && !Pos_2) {
		Swap(Pos_1, Pos_1 + Pow_2[cur - 1], cur - 1);
		if (Check(Pos_1, cur)) DFS(cur + 1, dep + 1);
		Swap(Pos_1, Pos_1 + Pow_2[cur - 1], cur - 1);
	}
	else {
		for (int x = 0; x <= 1; x ++)
			for (int y = 0; y <= 1; y ++) {
				Swap(Pos_1 + x * Pow_2[cur - 1], Pos_2 + y * Pow_2[cur - 1], cur - 1);
				
				if (Check(Pos_1, cur) && Check(Pos_2, cur)) {
					DFS(cur + 1, dep + 1);
					Swap(Pos_1 + x * Pow_2[cur - 1], Pos_2 + y * Pow_2[cur - 1], cur - 1);
					break;
				}
				
				Swap(Pos_1 + x * Pow_2[cur - 1], Pos_2 + y * Pow_2[cur - 1], cur - 1);
			}
	}
}

int main() {

	ios :: sync_with_stdio(false);
	
	Init();
	
	DFS(0, 0);
		
	cout << ans << endl;
	
	return 0;
}

```
注意：我的代码里面考虑的当前操作是cur-1


---

## 作者：Musity (赞：0)

## 结论
对于先交换两个小区间，再交换它们所在的两个大区间的操作我们可以先交换两个大区间，再到大区间里面找到对应的小区间来交换，以达到一样的效果，所以和同一种操作应该与顺序无关。区间更多的情况感性理解一下，应该也是成立的（~~其实我也不会证~~）。

# 思路

所以我们只用从小到大枚举操作，最后再全排列一下（乘以阶乘）就好了。

以下说的有序指的是像 $ [5,6,7,8 ] $，这样的连续数字构成的单调上升序列。

当我们进行的操作是交换长度为 $l$ 的区间时，所有长度为 $l$ 区间的内部必须是有序的，因为以后它们的相对位置都不会改变，若现在已无序以后一定不会排好。

用 $dfs(x, cnt)$ 表示长度为 $2^x$ 的区间都已有序时的操作个数为 $cnt$，显然初始为 $dfs(0, 0)$，当搜索到 $dfs(n, cnt)$ 时整个序列已经有序，用 $cnt$ 的阶乘来累加答案。

考虑怎么往下转移，所以我们看能不能把 $l \times 2$ 的区间都变为有序，这样下一步才是有意义的。

使用该次长度为 $l$ 的操作，最多修改两个 $l  \times 2 $ 的区间，例子见下 $(l=2)$。（以下写两行是为了方便看 $l \times 2$ 的区间改动了几个）

**修改一个的如：**

 $[5,6],[7,8],[9, 10],[11,12],{\color{green}[3,4]},{\color{green}[1,2]},[13,14],[15,16]$
 
 $~[5,6,7,8]~,~[9,10,11,12]~,~{\color{red}[3,4,1,2]}~,~[13,14,15,16]$
 
 交换绿色部分后：
 
  $[5,6],[7,8],[9, 10],[11,12],{\color{green}[1,2]},{\color{green}[3,4]},[13,14],[15,16]$
  
  $~[5,6,7,8]~,~[9,10,11,12]~,~{\color{blue}[1,2,3,4]}~,~[13,14,15,16]$
  
 **修改两个的如**：

 $[5,6],{\color{green}[1,2]},[9, 10],[11,12],{\color{green}[7,8]},[3,4],[13,14],[15,16]$
 
 $~{\color{red}[5,6,1,2]}~,~[9,10,11,12]~,~{\color{red}[7,8,3,4]}~,~[13,14,15,16]$


 交换绿色部分后：
 
  $[5,6],{\color{green}[7,8]},[9, 10],[11,12],{\color{green}[1,2]},[3,4],[13,14],[15,16]$
  
  ${~\color{blue}[5,6,7,8]}~,~[9,10,11,12]~,~{\color{blue}[1,2,3,4]}~,~[13,14,15,16]$


 **综上：** 

  若下一步的区间里面有超过三个是无序的则无法解决，有两个是无序的就在对应的四个子区间里面找一种合适的方案交换，如果只有一个无序区间就将该区间的两个子区间交换

# 优化
检查有没有序可以 $O(N)$ 扫描数组一遍，但既然长度为 $l$ 的区间已经有序，只要长度为 $l \times 2$ 的区间右半段的开头减左半段的开头是 $l$ 即可说明它有序。

改变两个大区间时枚举四种情况，每次都交换区间比较费时，可以先利用四个小区间的开头判断合法性后再交换。

优化后快了 $4ms$，虽然微不足道，但让我跑到了第二。
# Code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1<<13;

ll n, m, a[N], mul[13], ans;

void Swap(int x, int y, int l) {
	for (int i=0; i<l; i++)
		swap(a[x+i], a[y+i]);
}
bool pd(int A, int B, int l) { //B A是否有序
	return a[A]-a[B]==l;
}
void dfs(int x, int cnt) {
	if (x == n) { ans += mul[cnt]; return;}
	int l = 1<<x; vector<int> unsort;
	for (int i = 1; i <= m; i += l*2)// 无序区间 
		if( !pd(i+l, i, l) ) unsort.push_back(i);
	if(unsort.size() >  2)
		return;
	else if(unsort.size() == 0)
		dfs(x+1, cnt);
	else if(unsort.size() == 1) {
		int A=unsort[0], B=A+l;
		Swap(A, B, l),dfs(x+1, cnt+1),Swap(A, B, l);
	}
	else if(unsort.size() == 2) {
		int A=unsort[0], B=A+l, C=unsort[1], D=C+l;
		if (pd(B, C, l) && pd(D, A, l)) Swap(A, C, l), dfs(x+1, cnt+1), Swap(A, C, l);
		if (pd(B, D, l) && pd(A, C, l)) Swap(A, D, l), dfs(x+1, cnt+1), Swap(A, D, l);
		if (pd(C, A, l) && pd(D, B, l)) Swap(B, C, l), dfs(x+1, cnt+1), Swap(B, C, l);
		if (pd(D, A, l) && pd(B, C, l)) Swap(B, D, l), dfs(x+1, cnt+1), Swap(B, D, l);
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n; 
	m = 1<<n; mul[0] = 1;
	for (int i = 1; i <= 12; i++) mul[i] = mul[i-1]*i;
	for (int i = 1; i <= m; i++)  cin >> a[i];
	dfs(0, 0);
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：xixisuper (赞：0)

# P3322 [SDOI2015] 排序 题解

CSP-S 考前冲刺，刷到了之前没口出来的一道题，花了一点时间赶了出来。

## 思路

我来一步一步说明我是如何得到正解的。

首先注意到每次只能操作长度为 $2$ 的整数次幂的块，所以说假设我们排序的方案是从块长小的到块长大的来做的话，长块内的元素必须是已经排好序的，才能保证最后的序列是有序的。

那么我们提出一个引理：**单次交换两个长度为 $2^{i-1}$ 的块，至多使两个长度为 $2^i$ 的块从无序变成有序。**

这个证明是显然的，由于这交换的两个长为 $2^{i-1}$ 的块要么处于同一个长度为 $2^i$ 的块中，要么分别处于两个不同的长为 $2^i$ 的块中，交换至多改变两个长为 $2^i$ 的块，所以显然成立。

于是我们就有一个可以判断无解的方法，扫一遍整个序列，如果出现了超过两个无序的长为 $2^i$ 的块，那么必然无法使最后的序列变得有序。

然后我们继续思考，假设我现在已经得到了一个合法的操作序列，那么**先进行交换长块的操作并不会影响小块的有序性**，所以我们可以再提出一个引理：**如果某个操作序列合法，则该操作序列的全排列都合法。**

假设我们已知某个操作序列交换了 $x$ 次，则答案会累加 $A_x^x=x!$ 次。

这时我们又注意到，对于一次交换，**至多只有两种可能使得交换合法**，这一点你只需要枚举一下序列长度为 $4$ 的时候的所有情况就能证明了，于是，**对于所有的 $n$ 种操作，至多有 $2^n$ 种合法的操作序列。**

然后我们惊人的发现 $2^n$ 是可以直接爆搜出来的，于是你就切掉了这一题。

最后我们做一下时间复杂度分析，第 $i$ 种操作至多会被搜到 $2^{i-1}$ 次，进行第 $i$ 次操作需要把长度为 $2^{n-i+1}$ 的序列扫一次，于是我们搜索的时间复杂度就为：

$$
O\left(\sum_{i=1}^n2^{i-1}\times 2^{n-i+1}\right)=O(n2^n)
$$

在本题的数据范围下跑的飞快。

## 代码

```cpp
#include <iostream>
#include <algorithm>
#define ll long long
#define IT int
using namespace std;
const ll N=(1LL<<12)+1;
ll ans;
IT a[13][N],n;
void solve(ll step,ll x);
inline void nxt(ll step,ll x,ll ps1,ll ps2,ll sp1,ll sp2){
	if(a[step][ps1]+1==a[step][ps2]&&a[step][sp1]+1==a[step][sp2]){
		a[step+1][ps2>>1]=(a[step][ps2]>>1);
		a[step+1][sp2>>1]=(a[step][sp2]>>1);
		solve(step+1,x+1);
	}
}
void solve(ll step,ll x){
	if(step==n){
		ll ret=1;
		for(ll i=2;i<=x;i++) ret*=i;
		ans+=ret;
		return;
	}
	ll al=(1LL<<(n-step)),cnt=0,apos=-1,bpos=-1;
	for(ll i=1;i<=al;i+=2){
		if(a[step][i]+1==a[step][i+1]&&(a[step][i]&1)) a[step+1][(i+1)>>1]=(a[step][i+1]>>1);
		else{
			cnt++;
			if(apos==-1) apos=i;
			else bpos=i;
		}
	}
	if(cnt>2) return;
	if(cnt==2){
		IT ps1=apos,ps2=apos+1;
		IT sp1=bpos,sp2=bpos+1;
		
		swap(a[step][ps1],a[step][sp1]);
		nxt(step,x,ps1,ps2,sp1,sp2);
		swap(a[step][ps1],a[step][sp1]);
		
		swap(a[step][ps1],a[step][sp2]);
		nxt(step,x,ps1,ps2,sp1,sp2);
		swap(a[step][ps1],a[step][sp2]);
		
		swap(a[step][ps2],a[step][sp1]);
		nxt(step,x,ps1,ps2,sp1,sp2);
		swap(a[step][ps2],a[step][sp1]);
		
		swap(a[step][ps2],a[step][sp2]);
		nxt(step,x,ps1,ps2,sp1,sp2);
		swap(a[step][ps2],a[step][sp2]);
	}
	if(cnt==1){
		a[step+1][(apos+1)>>1]=(a[step][apos]>>1);
		solve(step+1,x+1);
	}
	if(!cnt) solve(step+1,x);
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(ll i=1;i<=(1LL<<n);i++) cin>>a[0][i];
	solve(0,0);
	cout<<ans;
	return 0;
} 
```

---

## 作者：nahidaa (赞：0)

## [传送门](https://www.luogu.com.cn/problem/P3322)
## 思路:
容易发现：一个符合条件的操作集合中，各个操作的前后顺序可以随意交换。则此时的数量为 $ans!$ 。

那么只需要从操作 $1$ 开始模拟至操作 $n$，最后计算 $ans!$ 就可以了吗？

然而，对于一个操作，可能存在两种交换情况。
如：对于数列 $1,4,3,2$，可以通过操作 $1$，变成 $1,2,3,4$，也可以变成 $3,4,1,2$,因此我们还需要通过dfs进行累加。

每一次操作完后都需要保证区间 $[1+k\times 2^x,k\times 2^x]$ 依次递增，由于每种操作只能进行一次，否则不可能完成排序。

## 代码附上:
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,a[500005],mid,b[500005],ge,ans;
bool t;
struct duan{
	int x,y;
}duan1,duan2,bduan[4];
struct baocun{
	struct duan bduan[4];
	ll a[500005];
}bao[15];
bool pan(int x,int y){
	for(int i=x+1;i<=y;++i){
		if(a[i]==a[i-1]+1){
			
		}else return 0;
	}return 1;
}
void dfs(int depth,int ge){
	if(depth==n+1){
		if(ge==0){
			ans++;
			return;
		}
		int k=1;
		for(int i=2;i<=ge;++i){
			k*=i;
		}
		ans+=k;
		return;
	}
	bool o=0;
	duan1=duan2=(duan){0,0};
	for(int j=1;j<=(1<<n);j+=(1<<depth)){
		if(!pan(j,j+(1<<depth)-1)){
			if(!o){
				duan1=(duan){j,j+(1<<depth)-1};
				o=1;
			}else{
				if(!duan2.x){
					duan2=(duan){j,j+(1<<depth)-1};
				}else return ;
			}
		}
	}
	if(!o){
		dfs(depth+1,ge);
		return;
	}
	if(!duan2.x){
		mid=(duan1.x+duan1.y)>>1;
		bduan[0]=(duan){duan1.x,mid};
		bduan[1]=(duan){mid+1,duan1.y};
		for(int j=1;j<=(1<<n);++j){
			b[j]=a[j];
		}
		for(int l=bduan[0].x,r=bduan[1].x;l<=bduan[0].y;++l,++r){
			b[l]=a[r],b[r]=a[l];
		}
		for(int i=1;i<=(1<<n);++i){
			a[i]=b[i];
		}
		dfs(depth+1,ge+1);
		return;
	}
	mid=(duan1.x+duan1.y)>>1;
	bduan[0]=(duan){duan1.x,mid};
	bduan[1]=(duan){mid+1,duan1.y};
	mid=(duan2.x+duan2.y)>>1;
	bduan[2]=(duan){duan2.x,mid};
	bduan[3]=(duan){mid+1,duan2.y};
	for(int j=1;j<=(1<<n);++j){
		b[j]=a[j];
	}
	o=0;
	for(int j=0;j<=3;++j){
		for(int k=j+1;k<=3;++k){
			for(int l=bduan[j].x,r=bduan[k].x;l<=bduan[j].y;++l,++r){
				b[l]=a[r],b[r]=a[l];
			}
			if(b[bduan[0].y]==b[bduan[1].x]-1&&b[bduan[2].y]==b[bduan[3].x]-1){
				for(int i=1;i<=(1<<n);++i){
					bao[depth].a[i]=a[i];
					a[i]=b[i];
				}
				for(int j=0;j<=3;++j){
					bao[depth].bduan[j]=bduan[j];
				}
				dfs(depth+1,ge+1);
				for(int i=1;i<=(1<<n);++i){
					b[i]=a[i]=bao[depth].a[i];
				}
				for(int j=0;j<=3;++j){
					bduan[j]=bao[depth].bduan[j];
				}
			}else for(int l=bduan[j].x,r=bduan[k].x;l<=bduan[j].y;++l,++r){
				b[l]=a[l],b[r]=a[r];
			}
		}
	}
	return;
}
int main()
{
	cin>>n;
	for(int i=1;i<=(1<<n);++i){
		cin>>a[i];
	}
	dfs(1,0);
	cout<<ans<<"\n";
	
	return 0;
}
/*
2
1 4 3 2 
*/
```

---

## 作者：C_Pos_Princess (赞：0)

# 题解：P3322 [SDOI2015] 排序
写在前面：这道题处理起来比较有意思。

前置条件：

模拟一下样例，简单一想——嗯，如果说一个序列可行，那么他的全排列一定都可以。
所以从小到大搜索，最后累计全排列。

让我们先来证明一些东西：

最后答案的序列是否是唯一的，是不是 $ans$ 只需要统计一次就结束。

不是的。
模拟下面这组样例：

- 3
- 5 6 7 8 3 2 1 4

如果统计一次就返回，输出可能为 $2$ 或 $6$, 但是正确答案是 $8$ 。

2：我们从小到大枚举交换的区间长度为 $2^x$ ,则小于 $x$  的区间内一定都已经有序，否则后面就永远不会交换到这个了。

每次枚举，找出所有 $2^x$ 大小的区间中，不满足递增条件的，记录一下，然后直接进入 dfs 即可（这里处理的比较巧妙，详见代码）。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

int n;
int t[(1<<12)+10];
int pw[20];
int jc[20];
ll ans;
void change(int a,int b,int k){
	for(int i = 0;i<k;i++){
		swap(t[a+i],t[b+i]);
	}
}

int check(int x){
	if(x == 0) return true; 
//	x--;
	int cnt = 0;
  //由于前面的已经保证块内有序了，只需要判断每个块第一个数即可
	for(int i = 1;i<=(1<<(n-x));i++){
		if(t[(i-1)*(1<<x)+1]+(1<<(x-1)) != t[(i-1)*(1<<x)+(1<<(x-1))+1]){
			return false;
		}
	}	
	return true;
} 


void dfs(int x,int k){
//	if(ans) return;
	if(!check(x)) return;  //还有 
	if(x == n) {
		ans+=jc[k];
		return; 
	}
//	cout<<1<<endl;
	dfs(x+1,k);
	int mp[10];
	int tot = 0;
	for(int i = 1;i<=(1<<n-x);i+=2){
		if(t[(i-1)*(1<<x)+1]+(1<<x)!=t[i*(1<<x)+1]){
			mp[++tot] = i-1;
			mp[++tot] = i;
			if(tot>4) return;
		}
	}
	for(int i = 1;i<=tot;i++){
		for(int j = i+1;j<=tot;j++){
			change((1<<x)*mp[i]+1,(1<<x)*mp[j]+1,1<<x);
			dfs(x+1,k+1);
			change((1<<x)*mp[i]+1,(1<<x)*mp[j]+1,1<<x);
		}
	}
}



int main(){
	cin>>n;
	for(int i = 1;i<=1<<n;i++){
		scanf("%d",&t[i]);
	}
	pw[0] = 1;
	jc[0] = 1;
	for(int i = 1;i<=15;i++)
		pw[i] = pw[i-1]*2,jc[i] = jc[i-1]*i;	
	dfs(0,0);
	cout<<ans<<endl;
	return 0;
} 
```

---

## 作者：cpu_gal (赞：0)

# P3322 [SDOI2015] 排序
注意这题操作位置不同的意思不是在数组上不同的位置操作，而是两个方案中操作序列上某个位置的操作不同……

首先有个结论，就是如果我们能用 $x$ 次操作完成排序，那么这 $x$ 次操作可以任意交换，对答案的贡献就是 $x$。

因此考虑区间 $i$ 从小到大枚举操作，由于是从小到大，因此必须要保证第 $i$ 次操作后所有长度为 $2$。

$i$ 的区间都排了序且相邻两项差值为 $1$，否则后面的操作肯定不能再影响这个小区间。

考虑 dfs 处理，下面以 $i=1$ 为例，剩下的情况可以在递归时修改数列变成 $i=1$。

接下来考虑什么情况下能够通过一次操作完成上面说的排序，注意到只有以下两种情况且只能有其中一个情况：只有一个区间逆序，剩下的全满足条件。

有两个区间顺序，但是这两个区间不满足差值为 $1$，剩下的全满足条件。

这两个条件都可以 $O(n)$ 扫一遍判定，如果都不满足这次操作就不用动，都满足那就非法。

如果满足第一个条件，将这个区间内的两个数都交换即可。

如果满足第二个条件，设这两个区间为 $(a+1,a+2)$,$(a,a+3)$（也只可能是这种情况），此时我们有两种方式，交换 $a,a+2$ 或者交换 $a+1,a+3$。

这样我们得到了一个可以往下递归的数列，至于递归时显然要满足 $a \equiv i \pmod 2$，因此我们每两个区间合并成一个数，新数的大小就是这个区间内偶数除以 $2$ 或者奇数加一之后除以 $2$，这样就可以递归了。
```c
#include <bits/stdc++.h>
typedef long long LL;

const int MAXN = 20 + 5, MAXS = (1 << 20) + 5;
int n, a[MAXS];
LL ans = 0, fact[MAXN];

int Read()
{
	int sum = 0, fh = 1; char ch = getchar();
	for (; ch < '0' || ch > '9'; ch = getchar()) fh -= (ch == '-') << 1;
	for (; ch >= '0' && ch <= '9'; ch = getchar()) sum = (sum << 3) + (sum << 1) + (ch ^ 48);
	return sum * fh;
}
void Swap(int &x, int &y) { int t = x; x = y; y = t; }

void dfs(int now, int cnt)
{
	if (now == n + 1) { ans += fact[cnt]; return ; }
	int m = 1 << (n - now + 1), opt = 0, flag = 0, f1 = 0, f2 = 0, p1 = 0, p2 = 0;
	for (int i = 1; i <= m; ++i)
		if (a[i] % 2 != i % 2) { ++opt; if (f1 == 0) f1 = i; else f2 = i; }
	if (opt > 2) return ; if (opt == 2) Swap(a[f1], a[f2]);
	for (int i = 1; i <= m; i += 2)
		if (a[i] != a[i + 1] - 1) { ++flag; if (p1 == 0) p1 = i; else p2 = i; }
	if (opt && flag) return ; if (flag > 2) return ;
	if (flag == 0)
	{
		for (int i = 1; i <= (m >> 1); ++i) a[i] = ((a[(i << 1) - 1] + 1) >> 1);
		if (opt) dfs(now + 1, cnt + 1);
		else dfs(now + 1, cnt); return ;
	}
	int tmp[MAXS]; for (int i = 1; i <= m; ++i) tmp[i] = a[i];
	Swap(tmp[p1], tmp[p2]); for (int i = 1; i <= (m >> 1); ++i) a[i] = ((tmp[(i << 1) - 1] + 1) >> 1);
	dfs(now + 1, cnt + 1); Swap(tmp[p1], tmp[p2]); Swap(tmp[p1 + 1], tmp[p2 + 1]);
	for (int i = 1; i <= (m >> 1); ++i) a[i] = ((tmp[(i << 1) - 1] + 1) >> 1);
	dfs(now + 1, cnt + 1);
}

int main()
{
	n = Read(); for (int i = 1; i <= (1 << n); ++i) a[i] = Read();
	fact[0] = 1; for (int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i;
	dfs(1, 0); printf("%lld\n", ans); return 0;
}
```

---

## 作者：Varuxn (赞：0)

## 解题思路
最基本的一个思想：**结果与操作的顺序无关**，因为在更换的时候无论先换哪一个最后排列都是一定的。

因此我们肯定会用到 $A_n^n$ 也就是 n 的阶乘，需要初始化一下，这里用的 jc 数组记录。

然后就可以 ~~**愉快**~~ 搜索了。

* 先是 **check** 函数;

	$\operatorname{check}(x)$ 用来检查所有长度为 $1<<x$ 的块是否满足递增，
    
    有一个非常妙的地方：我们已经知道这个序列是由 $1\sim2^n$ 组成的了。
    
    因此在判断的时候只需要循环，看第 i 块的第一个数是否和第 j 块的第一个数正好差一个块长就好了。
    ```cpp
   bool check(int x)
	{
		for(int i=1;i<=(1<<(n-x));i++)
			if(s[(i-1)*(1<<x)+1]+(1<<(x-1))!=s[(i-1)*(1<<x)+(1<<(x-1))+1])
			return false;
		return true;
	}
    ```
* 再谈**交换**函数：
	$\operatorname{swap}(i,j,k)$ 表示将分别以 i 和 j 开始长度为 k 的序列互换。
    ```cpp
 	   void swap(int i,int j,int k)
	{
		for(int l=1;l<=k;l++)
			swap(s[i+l-1],s[j+l-1]);
	}
    ```
* 最后是 **dfs** 函数
	
    $\operatorname{dfs}(x,num)$ 表示交换到块长为 $1<<x$ 了，并且此前进行了 num 个操作。
    
    如果这个块不是单调递增的，直接 return 就好，毕竟他对于答案是没有贡献的。
    
    对于 $x=n$ 时表明整个序列已经整完了，然后直接给 ans 加上 $jc_{num}$ 就好了。
    
    然后直接向下进行 $\operatorname{dfs}(x+1,num)$ 不做任何处理。
    
    对于进行处理的情况，把整个序列两块两块的看，如果不符合条件（判断方法与上面的 $\operatorname{check}$ 同）记录到一个 t 数组里，一会处理，
    如果需要处理的总数超过 4 的话直接 break ，剩下的直接交给后面就可以了。
    
    然后**暴力两两枚举**操作，进行交换后，直接进行下一层 $\operatorname{dfs}$ 以及回溯就好了。

## $code$
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e3;
int n,ans,jc[13],s[N];
bool check(int x)//check函数检查是否符合
{
	for(int i=1;i<=(1<<(n-x));i++)
		if(s[(i-1)*(1<<x)+1]+(1<<(x-1))!=s[(i-1)*(1<<x)+(1<<(x-1))+1])
		return false;
	return true;
}
void swap(int i,int j,int k)//暴力交换
{
	for(int l=1;l<=k;l++)
		swap(s[i+l-1],s[j+l-1]);
}
void dfs(int x,int num)//搜索主函数
{
	if(x&&!check(x))//不符合返回
		return ;
	if(x==n)/累加
	{
		ans+=jc[num];
		return ;
	}
	dfs(x+1,num);
	int t[5],tot=0;
	for(int i=1;i<=(1<<(n-x));i+=2)
		if(s[i*(1<<x)+1]!=s[(i-1)*(1<<x)+1]+(1<<x))
		{
			if(tot==4)
				break;
			t[++tot]=i;
			t[++tot]=i+1;
		}
	if(!tot)
		return ;
	for(int i=1;i<=tot;i++)
		for(int j=i+1;j<=tot;j++)
		{
			swap((1<<x)*(t[i]-1)+1,(1<<x)*(t[j]-1)+1,1<<x);
			dfs(x+1,num+1);		
			swap((1<<x)*(t[i]-1)+1,(1<<x)*(t[j]-1)+1,1<<x);
		}
}
#undef int
int main()
{
	#define int long long
	scanf("%lld",&n);
	jc[0]=1;
	for(int i=1;i<=n;i++)//预处理阶乘
		jc[i]=jc[i-1]*i;
	for(int i=1;i<=(1<<n);i++)
		scanf("%lld",&s[i]);
	dfs(0,0);//搜索
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：楠枫 (赞：0)

## 题解

仔细审题，我们会发现 

>小 $A$ 认为两个操作序列不同，当且仅当操作个数不同，或者至少一个操作不同（种类不同或者操作位置不同）。
>

所以，对于一种操作，不管是交换哪两段，都算作同一种操作，只会对答案贡献一次。

引理

>对于一个合法的操作序列，其中的操作可以互换位置，仍为合法序列。
>

可以自己手动模拟一下，结论很显然。

那么对于每一次操作，设此次操作的长度为 $len=2^x$，我们将从头开始每 $len$ 的长度分为一个块，则有 $2^{n-x}$ 个块。

对于每一个块，我们要保证他是一个合法的有序序列，又因为 $2^x$ 是由 $2^{x-1}$ 的块调整顺序转移而来的，那么对于每个 $2^{x-1}$ 的块，我们就要找出有多少个两两的块不符合顺序递增。如果有**超过**两对不合理，则我们可以直接判定此分支下无解，
原因就是对于每种操作，我们只能用一次。

当到边界时且合法时，我们需要加上用到的操作数的阶乘。（原因见引理）

$AC \kern 0.5emCODE:$
```cpp
#include<bits/stdc++.h>
#define ri register int
#define p(i) ++i
using namespace std;
namespace IO{
    char buf[1<<21],*p1=buf,*p2=buf;
    inline char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
    inline int read() {
        ri x=0,f=1;char ch=gc();
        while(ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=gc();}
        while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+(ch^48);ch=gc();}
        return x*f;
    }
}
using IO::read;
namespace nanfeng{
    static const int N=12;
    int num[(1<<N)+7],p[N+7],n, ans;
    inline void Swap(int i,int j,int k) {
        int len=1<<k,si=(i-1)*len,sj=(j-1)*len;
        for (ri l(1);l<=len;p(l)) swap(num[si+l],num[sj+l]);
    }
    inline int check(int x) {//用于判断交换后的块是否符合要求顺序递增
        int len=1<<x;
        for (ri i(1);i<=(1<<n-x);i+=2) if (num[i*len]+1!=num[i*len+1]) return 0;
        return 1;
    }
    inline void dfs(int x,int cnt) {
        if (x&&!check(x-1)) return;
        if (x==n) {ans+=p[cnt];return;} 
        dfs(x+1,cnt);
        ri ch[5],tot=0,len=1<<x;//一定不要设成全局数组，因为若要定义为全局，向下递归时分支会将他改变，之后回溯时会炸。
        for (ri i(1);i<=(1<<n-x);i+=2) {
            if (num[i*len]+1!=num[i*len+1]) {
                if (tot==4) return;
                ch[p(tot)]=i;ch[p(tot)]=i+1;
            }
        }
        if (!tot) return;
        for (ri i(1);i<=tot;p(i)) {
            for (ri j(i+1);j<=tot;p(j)) {
                // if ((i+j==3||i+j==7)&&tot==4) continue;
                Swap(ch[i],ch[j],x);
                dfs(x+1,cnt+1);
                Swap(ch[i],ch[j],x);//记得回溯
            }
        }
    }
    inline int main() {
        // freopen("1.in","r",stdin);
        n=read();
        p[1]=1;
        for (ri i(2);i<=12;p(i)) p[i]=p[i-1]*i;
        for (ri i(1);i<=(1<<n);p(i)) num[i]=read();
        dfs(0,0);
        printf("%d\n",ans);
        return 0;
    }
}
int main() {return nanfeng::main();}
```
目前是洛谷最优解，而且这么写码量也很小。

---

## 作者：three_D (赞：0)

刚看见题面有点蒙感觉除了暴搜什么都不会做。

没想到正解是搜索...

只要有一种操作不同就算不同方案，而对于一个方案，其内部顺序对结果无影响，所以求出一种后其全排列均合法，ans+=A（tot,tot）;

因为有上面这个性质所以从1搜到n，表示第i种操作的进行。

暴搜：暴力枚举端点进行交换。注意for循环中i+=长度,而不是i+=1,因为前提是先划分在选着换，不读题会很惨。T30

剪枝：一个特点：对于每种操作找出非连续序列个数如果大于2一定不合法，等于0就直接搜而不能再去换，因为这样会使顺序混乱一定不合法。

解释+具体操作：在搜第i种操作时假设小区间长度是y那么划分成Y/2个区间，每个里有两个小区间，查看它们是否是连续序列。因为下一次小区间长度就是y*2,所以

这次操作后不会有机会对其内部更改。以后就不会合法，这也是为什么非连续等于0后不能换的原因，因为换了内部一定不再合法。

count==0,直接搜下一种，==1看是否交换后合法，是搜下，否return，==2有四种情况其中1，3和2，4判断条件同而23，14不同。

tot记录使用的操作种类数。

 

骚操作：枚举换区间改成线段树。

---


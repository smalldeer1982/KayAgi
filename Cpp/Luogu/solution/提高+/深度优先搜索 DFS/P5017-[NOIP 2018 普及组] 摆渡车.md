# [NOIP 2018 普及组] 摆渡车

## 题目背景

NOIP2018 普及组 T3

## 题目描述

有 $n$ 名同学要乘坐摆渡车从人大附中前往人民大学，第 $i$ 位同学在第 $t_i$ 分钟去 等车。只有一辆摆渡车在工作，但摆渡车容量可以视为无限大。摆渡车从人大附中出发、 把车上的同学送到人民大学、再回到人大附中（去接其他同学），这样往返一趟总共花费 $m$ 分钟（同学上下车时间忽略不计）。摆渡车要将所有同学都送到人民大学。  

凯凯很好奇，如果他能任意安排摆渡车出发的时间，那么这些同学的等车时间之和最小为多少呢？    

注意：摆渡车回到人大附中后可以即刻出发。

## 说明/提示

**样例 1 说明**    

同学 $1$ 和同学 $4$ 在第 $3$ 分钟开始等车，等待 $0$ 分钟，在第 $3$ 分钟乘坐摆渡车出发。摆渡车在第 $4$ 分钟回到人大附中。   
同学 $2$ 和同学 $3$ 在第 $4$ 分钟开始等车，等待 $0$ 分钟，在第 $4$ 分钟乘坐摆渡车 出发。摆渡车在第 $5$ 分钟回到人大附中。   
同学 $5$ 在第 $5$ 分钟开始等车，等待 $0$ 分钟，在第 $5$ 分钟乘坐摆渡车出发。自此 所有同学都被送到人民大学。总等待时间为 $0$。

**样例 2 说明**  

同学 $3$ 在第 $1$ 分钟开始等车，等待 $0$ 分钟，在第 $1$ 分钟乘坐摆渡车出发。摆渡 车在第 $6$ 分钟回到人大附中。   
同学 $4$ 和同学 $5$ 在第 $5$ 分钟开始等车，等待 $1$ 分钟，在第 $6$ 分钟乘坐摆渡车 出发。摆渡车在第 $11$ 分钟回到人大附中。   
同学 $1$ 在第 $11$ 分钟开始等车，等待 $2$ 分钟；同学 $2$ 在第 $13$ 分钟开始等车， 等待 $0$ 分钟。他/她们在第 $13$ 分钟乘坐摆渡车出发。自此所有同学都被送到人民大学。 总等待时间为 $4$。  
可以证明，没有总等待时间小于 $4$ 的方案。 

**数据规模与约定**

对于 $10\%$ 的数据，$n ≤ 10$，$m = 1$，$0 ≤ t_i ≤ 100$。   
对于 $30\%$ 的数据，$n ≤ 20$，$m ≤ 2$，$0 ≤ t_i ≤ 100$。  
对于 $50\%$ 的数据，$n ≤ 500$，$m ≤ 100$，$0 ≤ t_i ≤ 10^4$。  
另有 $20\%$ 的数据，$n ≤ 500$，$m ≤ 10$，$0 ≤ t_i ≤ 4 \times  10^6$。  
对于 $100\%$ 的数据，$n ≤ 500$，$m ≤ 100$，$0 ≤ t_i ≤ 4 \times 10^6$。

## 样例 #1

### 输入

```
5 1 
3 4 4 3 5 ```

### 输出

```
0```

## 样例 #2

### 输入

```
5 5 
11 13 1 5 5 ```

### 输出

```
4```

# 题解

## 作者：Sooke (赞：1378)

### 前言

听说今年普及组难度堪比提高 $Day\ 1$，作为一名~~半退役~~提高选手，心血来潮，特地来接受这道经典好题的洗礼。

---

### 正文

这是一道题意简明的题，论解法却无比多样。我个人喜欢先把题意抽象化。

我们不妨认为时间是一条**数轴**，每名同学按照到达时刻分别对应数轴上**可能重合的点**。安排车辆的工作，等同于将数轴分成若干个**左开右闭**段，每段的长度 $\geqslant m$。原本的等车时间之和，自然就转换成所有点到各自**所属段右边界**的**距离之和**。

如果您无法理解复杂的文字描述，试图结合下面的这幅图思考：

![](https://i.loli.net/2018/11/13/5bead5ac2c9c8.png)

这不就有个鲜明的线性 $dp$ 模型了吗？设 $f_i$ 表示对数轴上 $(-\infty,\ i]$ 分段，且最后一段的右边界是 $i$，位于 $(-\infty,\ i]$ 内的点到各自所属段右边界的距离之和最小值。转移式：

$$f_i = \min_{j \leqslant i-m}\{ f_j+ \sum_{j < t_k \leqslant i} i-t_k \}$$

设最后一段对应 $(j,\ i]$，既然它的长度 $\geqslant m$，则有 $j \leqslant i - m$。我们知道 $j < t_k \leqslant i$，意味着第 $k$ 个点在这段中，它到右端的距离 $= i - t_k$，因而产生这么多的贡献。累加贡献，与 $j$ 以前的最优答案 $f_j$，即可推出转移式。

另外，特判 $(-\infty,\ i]$ 单独作为一段的**边界情况**，即 $f_i = \sum\limits_{t_k \leqslant i}i - t_k$。

然而我们对 $\sum\limits_{j < t_k \leqslant i} i-t_k$ 束手无策，如何快速求出呢？这时**前缀和**有了重大用途。拆，拆，拆！

$$\sum_{j < t_k \leqslant i} i-t_k = (\sum_{j < t_k \leqslant i}i)-(\sum_{j < t_k \leqslant i}t_k)=(cnt_i - cnt_j) \times i - (sum_i - sum_j)$$

其中，$cnt_i$ 表示 $(-\infty,\ i]$ 中点的个数，$sum_i$ 表示 $(-\infty,\ i]$ 中点的位置之和。顺便改写下刚才的转移式：

$$f_i = \min_{j \leqslant i-m}\{ f_j +  (cnt_i - cnt_j) \times i - (sum_i - sum_j)\}$$

这里令 $t = \max\limits_{1\leqslant i \leqslant n}\{t_i\}$，最终答案只需在 $i \geqslant t$ 找最小的 $f_i$ 即可。实际上，$[t,\ t + m)$ 包含了所有可能的答案。

至此，我们有了 $50$ 分的优秀做法，时间复杂度为 $O(t^2)$。代码如下：

```cpp
#include <cstdio>
#include <algorithm>

const int maxT = 4000105;

int n, m, t, ti, ans = 1e9, cnt[maxT], sum[maxT], f[maxT];

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &ti); t = std::max(t, ti);
        cnt[ti]++; sum[ti] += ti;
    }
    for (int i = 1; i < t + m; i++) { cnt[i] += cnt[i - 1]; sum[i] += sum[i - 1]; } // 前缀和.
    for (int i = 0; i < t + m; i++) {
        f[i] = cnt[i] * i - sum[i]; // 特判边界情况.
        for (int j = 0; j <= i - m; j++) { f[i] = std::min(f[i], f[j] + (cnt[i] - cnt[j]) * i - (sum[i] - sum[j])); }
    }
    for (int i = t; i < t + m; i++) { ans = std::min(ans, f[i]); }
    printf("%d\n", ans);
    return 0;
}
```

时间复杂度爆炸，怎么办？使用 $dp$ **优化法宝一：剪去无用转移**！

这是原来的转移式：

$$f_i = \min_{j \leqslant i-m}\{ f_j +  (cnt_i - cnt_j) \times i - (sum_i - sum_j)\}$$

实际上只需要：

$$f_i = \min_{i - 2m < j \leqslant i-m}\{ f_j +  (cnt_i - cnt_j) \times i - (sum_i - sum_j)\}$$

不知你是否看到了区别？仍然考虑 $(j,\ i]$ 段的长度，由于分的段数不会增大答案，当它的长度 $\geqslant 2m$ 时，我们完全可以再给它切一刀，得到**不劣**的答案。通过此性质，可剪去大量无用转移。

时间复杂度降至 $O(tm)$，按照写法常数可获得 $70$ ~ $100$ 不等的成绩，并不排除在 $CCF$ 少爷机上超时的可能。

```cpp
#include <cstdio>
#include <algorithm>

const int maxT = 4000105;

int n, m, t, ti, ans = 1e9, cnt[maxT], sum[maxT], f[maxT];

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &ti); t = std::max(t, ti);
        cnt[ti]++; sum[ti] += ti;
    }
    for (int i = 1; i < t + m; i++) { cnt[i] += cnt[i - 1]; sum[i] += sum[i - 1]; } // 前缀和.
    for (int i = 1; i < t + m; i++) {
        f[i] = cnt[i] * i - sum[i]; // 特判边界情况.
        for (int j = std::max(i - m - m + 1, 0)/*剪去无用转移*/; j <= i - m; j++) { f[i] = std::min(f[i], f[j] + (cnt[i] - cnt[j]) * i - (sum[i] - sum[j])); }
    }
    for (int i = t; i < t + m; i++) { ans = std::min(ans, f[i]); }
    printf("%d\n", ans);
    return 0;
}
```

不稳，很虚，怎么办？使用 $dp$ **优化法宝二：剪去无用状态**！

举个例子，假设正在求 $f_i$，但在 $(i-m,\ i]$ 中没有任何点，这个 $f_i$ 相对来说就是 **“无用”** 的。原因是若最后一段长度恰好 $= m$，这里面又没有任何点，不分割也罢。长度 $>m$ 时，完全可以把这一段的右边界往左“拖”，产生**不劣**的答案。

然而直接扔掉这个状态，会与上一个优化缩小转移范围起冲突，故**无用**的位置令 $f_i = f_{i-m}$，防止漏解。

可以证明**“有用”**的位置 $\leqslant nm$ 个，故时间复杂度再次优化成 $O(nm^2 + t)$。期望得分 $100$ 分。代码：

```cpp
#include <cstdio>
#include <algorithm>

const int maxT = 4000105;

int n, m, t, ti, ans = 1e9, cnt[maxT], sum[maxT], f[maxT];

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &ti); t = std::max(t, ti);
        cnt[ti]++; sum[ti] += ti;
    }
    for (int i = 1; i < t + m; i++) { cnt[i] += cnt[i - 1]; sum[i] += sum[i - 1]; } // 前缀和.
    for (int i = 0; i < t + m; i++) {
        if (i >= m && cnt[i - m] == cnt[i]) { f[i] = f[i - m]; continue; } // 剪去无用状态.
        f[i] = cnt[i] * i - sum[i]; // 特判边界情况.
        for (int j = std::max(i - m - m + 1, 0)/*剪去无用转移*/; j <= i - m; j++) { f[i] = std::min(f[i], f[j] + (cnt[i] - cnt[j]) * i - (sum[i] - sum[j])); }
    }
    for (int i = t; i < t + m; i++) { ans = std::min(ans, f[i]); }
    printf("%d\n", ans);
    return 0;
}
```

这样写毫无逼格，怎么办？使用 $dp$ **优化法宝三：利用单调性质**！

移除前两个优化，转变画风，$j$ 是 $i$ 的决策点，满足：

$$f_i = f_j +  (cnt_i - cnt_j) \times i - (sum_i - sum_j)$$

还是拆，拆，拆！

$$f_i = f_j +  cnt_i \times i - cnt_j \times i - sum_i + sum_j$$

把只跟 $j$ 有关的项移到左边，跟 $i,\ j$ 有关的乘积放在中间，只跟 $i$ 有关的项移到最右边：

$$\underline{f_j + sum_j}_{\ y} = \underline{i_{_{}}}_{\ k} \times \underline{cnt_j}_{\ x} + \underline{(f_i - cnt_i \times i + sum_i)}_{\ b}$$

这不是**斜率优化**裸题吗！斜率 $i$ 单调上升，维护下凸壳。对于 $i$ 把 $i - m$ 推入队列，即可保证决策点 $j \leqslant i - m$。

每个状态点最多进出队列一次，时间复杂度 $O(t)$，仍能拿到 $100$ 分。

```cpp
#include <cstdio>
#include <algorithm>

const int maxT = 4000105;

int n, m, t, ti, ans = 1e9, l = 1, r, cnt[maxT], sum[maxT], q[maxT], f[maxT];

inline double getSlope(int u, int v) { return (double) (f[v] + sum[v] - f[u] - sum[u]) / (cnt[u] == cnt[v] ? 1e-9 : cnt[v] - cnt[u]); }

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &ti); t = std::max(t, ti);
        cnt[ti]++; sum[ti] += ti;
    }
    for (int i = 1; i < t + m; i++) { cnt[i] += cnt[i - 1]; sum[i] += sum[i - 1]; } // 前缀和.
    for (int i = 0; i < t + m; i++) {
        if (i - m >= 0) {
        	while (l < r && getSlope(q[r - 1], q[r]) >= getSlope(q[r], i - m)) { r--; }
        	q[++r] = i - m; // 把可能成为最优解的推入队列. 
        }
    	while (l < r && getSlope(q[l], q[l + 1]) <= i) { l++; } // 把不可能成为最优解的弹出队列. 
        f[i] = cnt[i] * i - sum[i]; // 特判边界情况.
        if (l <= r) { f[i] = std::min(f[i], f[q[l]] + (cnt[i] - cnt[q[l]]) * i - (sum[i] - sum[q[l]])); } // 斜率优化转移. 
    }
    for (int i = t; i < t + m; i++) { ans = std::min(ans, f[i]); }
    printf("%d\n", ans);
    return 0;
}
```

教练加强了这题，$t \leqslant 10^9$，复杂度依赖 $t$ 的做法都挂了，怎么办？

掌握前两个优化的核心思想后，不难发现**最优情况**下，每个点到所属段右边界的距离 $< 2m$。令 $g_{i,\ j}$ 表示对 $t_{1..n}$ **排序**后（$0 \leqslant j < 2m$），第 $i$ 个点距离所属段右边界 $j$ 个单位时，第 $1..i$ 个点距离之和的最小值。

理论上，想要得到 $g_{i,\ j}$，我们需要枚举 $k,\ l$，用 $g_{k,\ l}$ 转移。可有趣的是，当前的第 $i$ 个点，要么和第 $i - 1$ 个点在**同一段内**，要么抛弃第 $i - 1$ 个点，**新开了一段**，而自己是里面的第一个。

总而言之，只要枚举一个 $k$，用 $g_{i-1,\ k}$ 转移得到 $g_{i,\ j}$，两者没有区别的。

在同一段内的情况很简单，不用枚举 $k$ 就可以直接转移：

$$g_{i,\ j} = g_{i - 1,\ t_i + j - t_{i-1}} + j$$

新开一段的情况，同样要保证段长 $\geqslant m$：

$$g_{i,\ j} = \min\limits_{t_{i-1} + k + m \leqslant t_i + j} \{ g_{i - 1,\ k} \} + j $$

易知，随着 $j$ 的增大，能够转移的 $k$ 的上限也不断增大，故使用**前缀最小值**维护可以转移的 $g_{i-1,\ k}$。

时间复杂度为 $O(n\ \log\ n + nm)$，即 $O(nm)$，目前看应该是最快的 $dp$ 做法了。注意边界细节，$AC$ 代码如下：

```cpp
#include <cstdio>
#include <algorithm>

const int maxN = 505, maxM = 205;

int n, m, mm, ans = 1e9, t[maxN], g[maxN][maxM];

int main() {
    scanf("%d%d", &n, &m); mm = m + m;
    for (int i = 1; i <= n; i++) { scanf("%d", &t[i]); }
    std::sort(t + 1, t + n + 1); // 排序. 
    for (int i = 1; i <= n; i++) {
    	g[i][0] = 1e9; // 先特判 j = 0 的情况. 
    	for (int j = 0; j <= std::min(t[i] - t[i - 1] - m, m - 1); j++) { g[i][0] = std::min(g[i][0], g[i - 1][j]); }
    	for (int j = 1; j < mm; j++) { g[i][j] = std::min(g[i][j - 1], t[i] + j - t[i - 1] - m >= 0 && t[i] + j - t[i - 1] - m < mm ? g[i - 1][t[i] + j - t[i - 1] - m] : (int) 1e9); } // 前缀最大值维护新开一段的情况. 
    	for (int j = 0; j < mm; j++) { g[i][j] = std::min(g[i][j], t[i] + j - t[i - 1] < mm ? g[i - 1][t[i] + j - t[i - 1]] : (int) 1e9) + j; } // 分在同一段内的情况, 加上 j 的贡献. 
    }
    for (int i = 0; i < m; i++) { ans = std::min(ans, g[n][i]); }
    printf("%d\n", ans);
    return 0;
}
```

听同学说，他有一个 $O(n)$ 的做法，怎么办？

很抱歉，作者菜得可怜，把 $dp$ 用到极致也只有 $O(nm)$，但**不清楚**贪心或乱搞是否能在 $O(n)$ 内解决本题。

---

### 尾注

或许您发现了，我给出的代码都特别短。是的，这道题考验的就是 $dp$ 的灵活运用，合理剪枝优化，利用好其性质，甚至能够用更加优美的做法暴踩标算。至于代码，只有会敲和懒得敲。

---

## 作者：info___tion (赞：137)

## updated on 2019.10.25：

1. 以前的程序真的丑……现在已经把码风改良了；

2. 去掉了之前那些完全是行为艺术的~~屑~~优化。

   ~~向那些被我的naive讲解和丑陋程序劝退的盆友们诚恳地道个歉（雾~~

   （因为笔者是$2020$届中考生，所以这应该是最后一次大改了，以后就不会有时间了……）

------

建议大家在博客里食用：[传送门](https://www.cnblogs.com/info---tion/p/11277515.html)

------

~~要是PJ组再考这么难的DP，我就当官把CCF取缔了~~

------

开个玩笑。

### 此题正解：$\mathrm{DP}$+各种剪枝 or 优化

------

## 一、引理

- 对于每个乘客，能搭载ta的车的发车时间**只有$m$种情况**；
- 设这个乘客开始等候的时间是$t_i$，则对应的$m$种情况是$[t_i,t_i+m)$。

### 证明

1. 如果存在一种情况，其发车时间是$\geqslant t_i+m$的，则由题意可知，发车时间可以提早若干轮**（也就是减去若干个$m$）**到达$[t_i,t_i+m)$这个区间，**这样做不会影响发车时间$\geqslant t_i+m$的那趟车**。
2. 如果$<m$的话，那这个乘客根本就坐不上这趟车，所以不需要考虑。

------

## 二、基本思想

- 首先，题目给定我们的这$n$个人开始等候的时间是乱的，所以我们要先**按照开始等车的时间把这$n$个人排个序**，然后再**离散化（具体来说就是将等待时间相同的若干个人“合并”成一个人）**。

  在结构体中，用`pos`表示**这一堆人的等待时间**，`num`表示**这一堆人的人数。**（具体过程看代码）

- 设$f(i,j)$表示用摆渡车已经载了前$i$个人，且搭载了第$i$个人**（不一定只搭载第$i$个人）**的那趟摆渡车的发车时间是（$t_i+j$）的最小等候时间和。（$t_i$的意义与题意相同）

- **这里要注意：$t_i+j$除了要满足$j<m$（对应上面的引理），同时还要满足$j<t_{i+1}-t_i$（即$t_i+j<t_{i+1}$）**

  - 因为如果$j\geqslant t_{i+1}$，那这趟车就可以把第$i+1$个人也搭上了，**显然违反了$\mathrm{DP}$状态的定义**。

    （在代码中，我们用一个名为`border(i)`的`#define`表示了这两个限制）

- 对于每个$f(i,j)$，枚举上一趟摆渡车的出发时间。

> 等等！数据范围写着：

> $$1 \leqslant t_i \leqslant 4\times10^6 $$

> 你跟我说枚举时间？你这最起码都$O(nt_i) \sim \mathrm{T}(2\times10^9)$ 的时间复杂度了，怎么$\mathrm{AC}$？

别着急啊，我还没说完呢。

- 其实引理已经告诉我们，我们**不需要把整个$t_i$枚举完**。

  由引理可得，对于前$i-1$个乘客，每个乘客能搭载的摆渡车的发车时间只有$m$种情况，所以我们只需要枚举这$(i-1)\times m$种情况即可。其他情况都是废的，不需要去考虑。

    这样做的枚举量为$O(nm) \sim \mathrm{T}(5 \times 10^4)$，相比之前直接枚举$t_i$的时间复杂度$\mathrm{T}(4 \times 10^6)$来讲，已经小很多了。

- 接着，假设前一趟摆渡车已经载了前$k$个人，那么我们要做的就只有两件事：

  1. 再枚举一个$l$，得到$f(k,l)$的最小值。
  2. 计算出第$k+1$个人到第$i$个人等候**当前这趟摆渡车**的等候时间和。

### 敲重点！敲重点！敲重点！



- 这里，$l$的取值范围有**三个条件：**

  - 前两个条件和前面的`border()`一样，不再赘述。

  - 第三个条件是$l\leqslant (t_i+j)-m-t_k$（即$t_k+l\leqslant (t_i+j)-m$）

    - 原因很简单，如果$t_k+l> (t_i+j)-m$,那么两趟车之间相隔的时间肯定就$<m$，显然不合题意。

      （所以这里还要再定义一个`border2(i)=min( border(i),第三个条件 )`）

- 在状态转移方程中的体现就是：

  $$f(i,j)=\min\limits_{0 \leqslant k < i,l\leqslant \mathrm{border2(k)}} \{f(k,l)+col(k+1,i,t_i+j)\}$$

    这当中，$col(k+1,i,t_i+j)$表示**第$k+1$个乘客到第$i$个乘客**等候**发车时间为$t_i+j$的那趟摆渡车**的时间和，直接用一个`for`循环累计即可。

  （当然，当$k=0$时，$f(k,l)$恒为零，表示这趟车直接把前$i$个人全部载完，这时等式右侧就直接等于$col(1,i,t_i+j)$）

- 算一下上面这个状态转移方程的时间复杂度：

  1. 首先，$i$和$j$必须枚举，所以是$O(nm)$的。
  2. 其次，$k$和$l$也是要枚举的，所以又是一个$O(nm)$。
  3. 最后，每次枚举$i,j,k,l$，都要计算一次$col$函数，而这个$col$函数的时间复杂度是$O(n)$的。

  综上所述，这个状态转移方程的时间复杂度为$O(nm\times nm\times n)=O(n^3m^2)$。

  这时间复杂度……也太~~可观~~了吧

  **所以我们需要优化！优化！优化！**

------

## 三、程序实现 or 剪枝

- 我们来关注一下这个式子：
$$col(k+1,i,t_i+j)$$
  对于每个$i,j$，当$k$每增加$1$时，$col$的值就只会减掉$(t_i+j-t_k)\times num_k$（$num_k$就是上文中提到的，结构体中**第$k$堆人的人数**）。

  所以我们可以在枚举每个$i$和$j$时，就把$col(1,i,t_i+j)$算出来（用一个变量$val$存起来）

  然后，$k$从$1$开始枚举，每当$k$在循环一开始等于某个值$x$时，$val$就减去$(t_i+j-t_x)\times num_x$。

  状态转移方程就变为：
  
  $$f(i,j)=\min\limits_{0 \leqslant k < i,l \leqslant \mathrm{border2(k)}} \{f(k,l)+val\}$$

  这样一抽出来，时间复杂度就变成了$O(nm(n+nm))=O(n^2m+n^2m^2)$		
  只保留最高次项后，时间复杂度就降为了$O(n^2m^2)$！**这就是$60$分的做法！**

------

- 其实大家有没有想过，**枚举$l$**这个操作显得有些多余，可不可以省去呢？（毕竟只是求一个最小值而已，我**求完一次就把这个最小值存起来**不就行了吗？）

  **没错，上面的想法是正确的！**

- 我们开多一个数组$\mathrm{Min}(i,j)= \min\limits_{j\leqslant \mathrm{border}(i)} \{f(i,j)\}$

   则之前的状态转移方程可以简化为：

   $f(i,j)=\min\limits_{0 \leqslant k < i} \{\mathrm{Min}(k,\mathrm{border2}(k))+val\}$

   **$\mathrm{Min}$可以在求每个$f(k,l)$的时候顺带维护。**

   因为这里只枚举了$i,j,k$，所以$\mathrm{DP}$的时间复杂度是$O(n^2m)$！！！

## 这个时间复杂度可以通过本题！！！

------

## 四、考场代码

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

const int maxn=502,maxm=102;
const int INF=0x7fffffff;

#define border2(x) min( border(x),lpos-Mem[x].pos )	//第三个条件是用小于等于号连接的，所以不用-1
#define border(x) min( m-1,Mem[x+1].pos-Mem[x].pos-1 )	//因为两个条件都是用小于号连接的，所以在循环中要-1

int f[maxn][maxm];
int Min[maxn][maxm];

int a[maxn];

struct Node{int pos,num;}Mem[maxn];int sz;

int col(int l,int r,int pos)
{
    int res=0;
    for(int i=l;i<=r;i++) res+=(pos-Mem[i].pos)*Mem[i].num;

    return res;
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);

    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    sort(a+1,a+n+1);

	a[0]=-1;

    for(int i=1;i<=n;i++)
    {
        if( a[i]!=a[i-1] ) Mem[++sz].pos=a[i];
        Mem[sz].num++;
    }

    Mem[sz+1]=(Node){INF,0};
    n=sz;

    for(int i=1;i<=n;i++) for(int j=0;j<=m;j++) f[i][j]=Min[i][j]=INF;

    for(int i=1;i<=n;i++)
        for(int j=0;j<=border(i);j++)
        {
            int pos=Mem[i].pos+j,lpos=pos-m;

            int val=col(1,i,pos);
            f[i][j]=val;

            for(int k=1; k<i and Mem[k].pos<=lpos ;k++)
            {
                val-=(pos-Mem[k].pos)*Mem[k].num;
                f[i][j]=min( f[i][j],Min[k][border2(k)]+val );
            }
            
            Min[i][j]=f[i][j];
            if( j>0 ) Min[i][j]=min( Min[i][j],Min[i][j-1] );
        }

    printf("%d",Min[n][m-1]);return 0;
}
```

------

又是一年过去了，这里就祝大家$\mathrm{CSP\ 2019\ J/S}$认证rp++！

（话说，老子打完这次也要隐退了呢。。。

---

## 作者：_ztyqwq (赞：129)

# 考场上，解出这道题目，靠的就是**“无知者无畏”**的精神。

主要是因为前两题很简单，本以为今年PJ也和往常一样难度，T3简单爆搜，T4~~稍微~~难一点。看到T3不可能爆搜，就往**简单**DP想。没想到这么难。。。硬着头皮想出来了。

闲话少说，开始讲述思路（思考过程）。

下面两个地名。。。~~（CCF打广告？！）~~直接用 A地 和 B地 代替了。

首先，看完题目意思，就想到了算法——**DP**。~~别问我怎么想到的，学OI的人，这个题目是DP都看不出来吗~~

然后，咱们直奔100%的数据~~（这么有自信？！）~~。发现 $ n $ 和 $ m $ 都很小，但是 $ t_i $ 很大，如果DP复杂度中出现了 $ t_i $，那么基本只能是线性的了~~（CCF老年姬）~~。但是有位机房巨佬写了一个 $ O(tm) $ 的，听说最近CCF评测速度有所增加，说不定能过。

反正 $ n,m $ 那么小，明摆着就是让你用的。

那么如何定义状态呢？

首先，排序是必然的。

接着，最容易想到的，最简单的状态定义：

**用 $ f[i] $ 表示前 $ i $ 个人都已经到达B地（上车也可以算到达，毕竟不用等了），所需要的最少总等候时间**。

状态怎么转移？这个题我们选择**刷表**（因为填表太麻烦了，不如直接思考我这个状态到哪里去）

**枚举 $ k $，$ f[k] = f[i] + $ 第 $ (i+1) $个学生到第 $ k $ 个学生的总等车时间。**

**这个总等车时间就是 $ \sum\limits_{x=i+1}^k{ (T-t[x]) } $。$ T $ 是车重新到达A地的时间。**怎么计算呢？

有没有人想当然地把 $ T $ 直接看做 $ t[k] $？

看似是对的，但实际上，第 $ i $ 个学生到达时，车有可能还没有到达A地！但是这样的话怎么做呢？

~~我们的信奥教练LJ：~~“DP不会的东西就加一维”

我们可以把上一次车到达的时间记录下来，放到DP状态的一维里去。这样状态定义就变成了：

**用 $ f[i][j] $ 表示前 $ i $ 个人在 $ j $ 时刻都已经到达B地（同上），所需要的最少总等候时间。**

此时 $ j $ 就是前 $ i $ 个人最后全部接走时车到达的时间。

重新观察状态转移方程，其中 $ max( j + m, t[k]) $ 就是 $ T $。看似好像没有什么问题了。

但是这样一来，$ j $ 又是 $ t_i $ 这个级别的了，承受不起，怎么办呢？

注意到此时，$ j \geqslant t[i] + m $ 的情况都是无意义的，因为如果 $ j \geqslant t[i] + m $，则说明第 $ i $ 个人等了 $ \geqslant m $ 分钟。但是即使车在 $ t[i] - 1 $ 时刻开走，他也只会等上 $ m - 1 $ 分钟啊！（注意，此时我们讨论的是**车一到就把第 $ i $ 个人接走**的情况，不考虑第 $ i + 1 $ 个人以及之后的人，如有不解见状态定义）

所以~~离散化~~状态定义变成了：

**用 $ f[i][j] $ 表示在第 $ i $ 个人等了刚好 $ j $ 分钟的时刻，前 $ i $ 个人已经到达B地（同上），所需要的最少总等候时间。**

重新审视空间复杂度，没有什么问题了。

此时前 $ i $ 个人最后全部接走时车到达的时间就是 $ t[i] + j $。

所以我们可以算出状态转移方程中应该添加的那一维（$ f[k] \rightarrow f[k][?] $ 中的 $ ? $），也就是第 $ k $ 个人的等待时间是：

$ max( t[i] + j + m - t[k], 0 ) = tmp $（下文因为这个量多次出现，所以简化为 $ tmp $）

$ t[i] + j + m $ 就是车到的时间。减去 $ t[k] $ 就是等候的时间。~~这个应该很好理解吧~~

现在 $ T $ 珂以~~不用思考就~~得出：$ T = $ 第 $ k $ 个人等候的时间 $ + t[k] = tmp + t[k] $（当然可以进一步简化~~，但是格式一致，而且少打几个字符~~）

所以现在状态转移方程长这样：

**$ f[k][tmp] = f[i][j] + $ 第 $ (i+1) $个学生到第 $ k $ 个学生的总等车时间。**

**总等车时间 $ = \sum\limits_{x=i+1}^k{ (T-t[x]) } $。$ T = tmp + t[k] $。**

（为什么 $ f[k][0 $ 到 $ tmp-1] $ 不考虑？因为它们不可能达到，为 $ inf $；为什么 $ f[k][tmp+1 $ 到 $ m-1] $ 不考虑？因为它们反正不是最优的，不考虑也没事）

**$ f[k][tmp] = f[i][j] + \sum\limits_{x=i+1}^k{ (tmp+t[k]-t[x]) } $**

计算一下时间复杂度（最差）：遍历状态 $ O(nm) $，枚举转移 $ O(n) $，转移过程。。。怎么还要 $ O(n) $？！$ O(n^3m) $ 不是炸了吗qwq

仔细观察那个 $ \sum $，发现 $ (tmp + t[k]) $ 是定值，所以提出来：

**$ f[k][tmp] = f[i][j] + (tmp + t[k]) \times (k - i) - \sum\limits_{x=i+1}^k{t[x]} $**

然后那个 $ \sum $ 珂以**前缀和**优化！

**$ f[k][tmp] = f[i][j] + (tmp + t[k]) \times (k - i) - (t[k] - t[i]) $**

至此，转移复杂度 $ O(1) $。

所以代码就可以写出来啦~

注意：我写的代码里，枚举的 $ k $ 不是转移方程中的 $ k $，转移方程中的 $ k $ 在我的代码中是 $ i + k $（具体看了代码就明白了）。边界情况我直接把 $ t[0] $ 设做了 $ -inf $（假设有第0个人，上车时间是 $ -inf $，从0开始做，就可以不用更新 $ f[i][0] $ 了）。

当然还有更快的做法（比如 $ O(nm) $），但是考场上能想出~~如此优秀的~~做法就已经不错啦qwq~

**UPDATE 11.21：**

 - 听说有教练把 $ O(t_i) $ 的范围改成了 $ \leqslant 10^9 $，这似乎更加支持与坚定了我的idea~

 - 事实上，如果 $ f[i][j] == inf $，则说明要么第 $ i $ 个人不可能只等 $ j $ 分钟，要么第 $ i $ 个人等待 $ j $ 分钟的情况不可能成为最优解的一部分，故可以不转移。所以……复杂度是 $ O(nm) $ （遍历所有状态）$ \times O( $ 平均每个状态转移复杂度 $ ) $（为 $ O(0) $ 或 $ O(n) $）。所以总复杂度是 $ O(nmk) $。$ k $ 为**玄学**常数。$ 0 \leqslant k \leqslant n $。

 - 实测：$ k \approx log(m) $，也就是说实际复杂度在 $ O(nmlogm) $ 左右qwq

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t[501],s[501],f[501][101];
const int inf=2139062143;
inline int read()
{
	int neg=1,x=0;
	char c;
	while((c=getchar())<'0'||c>'9')
		if(c=='-')
			neg=-1;
	x=c-'0';
	while((c=getchar())>='0'&&c<='9')
		x=x*10+(c-'0');
	return x*neg;
}
int main()
{
	int n=read(),m=read();
	for(int i=1;i<=n;i++)
		t[i]=read();
	sort(t+1,t+n+1);
	for(int i=1;i<=n;i++)
		s[i]=s[i-1]+t[i];
	memset(f,0x7f,sizeof(f));
	t[0]=-inf;
	f[0][0]=0;
	for(int i=0;i<=n;i++)
	{
		int MAX=min(m-1,t[i+1]-t[i]);
		for(int j=0;j<=MAX;j++)
			if(f[i][j]!=inf)
				for(int k=1;i+k<=n;k++)
				{
					int tmp=max(t[i]+j+m-t[i+k],0);
					f[i+k][tmp]=min(f[i+k][tmp],f[i][j]+(tmp+t[i+k])*k-(s[i+k]-s[i]));
				}
	}
	int ans=inf;
	for(int i=0;i<m;i++)
		ans=min(ans,f[n][i]);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：zhoutb2333 (赞：46)

有个自认为比较好想的方法：

我们如果在时间 $T_1,T_2,T_3 ,\dots ,T_k$ 发车（ $T_i \ge T_{i-1}+m$ ），那么总代价就是 $\sum \limits _{i=1}^{k} \sum \limits _{T_{i-1} < t_j \le T_i} (T_i - t_j)= \left( \sum \limits _{i=1}^{k} (s[T_i]-s[T_{i-1}]) \times T_i \right) - \sum \limits _{i=1}^{n}t_i$ ，其中 $s[i]$ 表示前 $i$ 分钟来到站台的总人数。

发现后面那个 $\sum \limits _{i=1}^{n}t_i$ 是固定的，于是我们可以设计dp求出前面的和式的最小值。

令 $f[i]$ 表示固定在时刻 $i$ 发一次车，前 $i$ 分钟的最小代价。那么有 $f[i]=\min \{ f[k]+(s[i]-s[k]) \times i\},k \le i-m \ \text{or} \ k=0$ 。然后就可以斜率优化转移了。最后减去 $\sum \limits _{i=1}^{n} t_i$ 即可。复杂度 $O(\max \{ t_i \})$ 。

``` cpp
#include<bits/stdc++.h>
#define maxn 510
#define maxt 5000010
#define ll long long
using namespace std;

int a[maxn],s[maxt],q[maxt],n,m,mx=0;
ll f[maxt],sum=0,ans=1LL<<60;
int main(){
	ios::sync_with_stdio(0); 
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i],s[++a[i]]++,mx=max(mx,a[i]),sum+=a[i];
	int l=1,r=1;
	for(int i=1;i<=mx+m;i++){
		s[i]+=s[i-1];
		if(i>m){
			int tmp=i-m;
			while(l<r&&(f[tmp]-f[q[r]])*(s[q[r]]-s[q[r-1]])<=(f[q[r]]-f[q[r-1]])*(s[tmp]-s[q[r]]))
				r--;
			q[++r]=tmp;
		}
		while(l<r&&f[q[l]]-i*s[q[l]]>=f[q[l+1]]-i*s[q[l+1]])
			l++;
		f[i]=f[q[l]]+i*(s[i]-s[q[l]]);
		if(i>=mx)
			ans=min(ans,f[i]);
	}
	cout<<ans-sum<<endl;
	return 0;
}
```

---

## 作者：zhouzihan_2004 (赞：24)

本来只是想水50，结果改着改着就发现好像能过（汗、

思路：DP~~（废话）~~

记T[i]为时间i时等车的人数（可能为0）

首先，我们考虑，假如在时间Tim的时候发一班车会影响多少人：

1. 之前等待的人没有了
2. 下一班车至少在时间Tim+m发，所以在时间Tim~时间Tim+m-1的人都一定会受影响

记Peo[Tim]为在时间Tim发车时的影响人数，tmp[Tim]为在时间Tim发车时的影响人数的等待时间，那么，记f[Tim][i]为时间Tim时有i个人等车的最小等待时间，则它的最小值为在时间Tim时发车和不发车的最小值。

如果Tim>maxT,直接发车就好了，f[Tim][i]=0；否则

- 如果发车了，那么等待时间加上在时间Tim时发车的影响人数的等待时间，i变为在时间Tim发车时的影响人数，下一班车至少在时间Tim+m,即值为f[Tim+m][Peo[Tim]]+tmp[Tim]；
- 如果没发车，那么等待时间加上当前人数以及时间Tim的人数，等待人数加上当前人数，即值为f[Tim+1][i+T[tim]]+i+T[tim]。

故f[Tim][i]=min(f[Tim+m][Peo[Tim]]+tmp[Tim]，f[Tim+1][i+T[tim]]+i+T[tim])，这就是50分的想法，复杂度O(n\*maxT<=5000000)

接下来想优化

我的优化主要针对maxT

大概就是这样的：

如果两个有人坐车时间Tim1,Tim2(Tim1<Tim2)之间没有任何人坐车，并且Tim2-Tim1>2\*m时，这两个人肯定不会互相影响，而且也不会影响其他人，那么把Tim2及Tim2以后往前移，直到Tim2-Tim1==2\*m时也没有影响。

此时maxT变为n\*2\*m<=100000

总复杂度O(n\*maxT<=50000000)，在加上2秒的时限，卡一卡常数就过了
程序仅供参考（烂的不行的记搜）：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m,a[1001],b[1001],T[1000001],f[100001][501],Peo[4000001],tmp[1000001];
void Get()
{
	for(int i=1;i<=m-1;i++)
    {
      	Peo[0]+=T[i];
      	tmp[0]+=T[i]*(m-i);
    }
	for(int Tim=1;Tim<=a[n];Tim++)
	{
		Peo[Tim]=Peo[Tim-1];
		tmp[Tim]=tmp[Tim-1];
		Peo[Tim]-=T[Tim];
		tmp[Tim]-=T[Tim]*(m-1);
		Peo[Tim]+=T[Tim+m-1];
		tmp[Tim]+=Peo[Tim];
	}
    return ;
}
int DFS(int Tim,int P)
{
	if(Tim>a[n]) return 0;
	if(f[Tim][P]<0x3f3f3f3f) return f[Tim][P];
    return f[Tim][P]=min(DFS(Tim+1,P+T[Tim])+P+T[Tim],DFS(Tim+m,Peo[Tim])+tmp[Tim]);
}
int main()
{
    memset(f,0x3f3f3f3f,sizeof(f));
	scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
      scanf("%d",&a[i]);
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++) 
    {
        b[i]=b[i-1];
        if(a[i]-a[i-1]>m*2) b[i]+=a[i]-a[i-1]-m*2;
    }
    for(int i=1;i<=n;i++)
    {
        a[i]-=b[i];
        T[a[i]]++;
    }
    Get();
    printf("%d",DFS(1,0));
    return 0;
}
```

---

## 作者：w4p3r (赞：20)

## 一、前言
还好今年考试的时候花了一个小时把这道题改对了，不然今年普及和提高都凉了,qwq
## 二、思路
- 我就以自己考试的时候的思路为例吧,这道题看出是一道动态规划题应该是不难的，看出要先排序也应该是不难的，因为人们到的时间从小到大的话更利于我们计算，所以先对**所有人到的时间从小到大排序一遍**  

### (1)30分

- 动态转移方程嘛，我开始想的是，假设f[i][j]表示**第i个人所在的公交车第j分钟出发使前i个人的等待时间的最小值**，然后应该不难推出一个动态转移方程,**设maxt为最后一个人（排序之后的）到的时间,t[i]为第i个人到的时间（排序之后的）,则**：    

- **对于i>1:f[i][j]=min(f[k][l]+cost(k+1,i,j)){1<i<=n,t[i]<=j<=maxt+m,0<=k<i,t[k]<=l<=j-m}**                                 

 **否则:f[i][j]=j-t[i]**

- 其中cost(k+1,i,j)为**第k+1-第i个人坐同一辆车且坐的车为在j时刻出发的代价**  **,即为sum(j-t[x])(k+1<=x<=i)**                                        

- 代码（如果不理解为什么j要<=maxt+m的话我等会儿会讲的）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#include<vector>
#include<stack>
#include<map>
#include<deque>
#define inf 0x7ffffff/2
#define eps 1e-6
#define N 110
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
inline ll read()
{
	char ch=getchar();
	ll s=0,w=1;
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
int n,m;
int f[N][N],t[N],maxt;
int ans=inf;
inline int cost(int l,int r,int x)//计算cost 
{
	int sum=0;
	for(register int i=l;i<=r;i++)sum+=(x-t[i]);
	return sum;
}
int main()
{
	n=read(),m=read();
	for(register int i=1;i<=n;i++)t[i]=read();
	//输入
	sort(t+1,t+n+1);//对每个人到达的时间从小到大排序
	maxt=t[n];//最后一个人到达的时间
    for(register int i=t[1];i<=maxt+m;i++)f[1][i]=i-t[1];
	for(register int i=2;i<=n;i++)//dp
	{
		for(register int j=t[i];j<=maxt+m;j++)
        //这里是maxt+t,不是maxt,很重要
		{
			f[i][j]=inf;//初始化
			for(register int k=0;k<i;k++)
			{
				for(register int l=t[k];l<=j-m;l++)
				{
					f[i][j]=min(f[i][j],f[k][l]+cost(k+1,i,j));
                    //动态转移方程
				}
			}
		}
	}
	for(register int i=maxt;i<=maxt+m;i++)ans=min(ans,f[n][i]);
    //统计答案
	printf("%d\n",ans);//输出
	return 0;
}


```
### (2)50分
- 后来经我仔细思考~~（瞎捉摸）~~,其实我们这样DP是很多余的，我们这样的DP其实相当于是**枚举了每次公交车所接程的人的区间，相当于是按每趟公交车DP的**，但是这道题我们并不关心**每辆公交车运了哪些人，或者是公交车运行了几次**，所以我们应该**以每个人为中心去思考DP**。
- 后来我居然想到了，**对于每个人来说，他要么坐上一个人乘坐的公交车，要么坐一辆新的公交车**
- 那么假设f[i][j]表达的含义30分的相同，一个新的动态转移方程也很好推出来了  
**对于i>1:f[i][j]=min(f[i-1][j],f[i-1][k])-t[i]+j(2<=i<=n,t[i]<=j<=maxt+m,t[i-1]<=k<=j-m)**         
**否则:f[i][j]=i-t[i]**
- 代码:                                                             

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#include<vector>
#include<bitset>
#include<set>
#include<map>
#define inf 0x7fffffff/2
#define eps 1e-6
#define N 510
#define M 10010
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
inline ll read()
{
	char ch=getchar();
	ll s=0,w=1;
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
int f[N][M];
int n,m;
int t[N];
int maxt;
int main()
{
	n=read(),m=read();
	for(register int i=1;i<=n;i++)t[i]=read();
	sort(t+1,t+n+1);
	memset(f,127,sizeof(f));//这里就要给f统一设上最大值了，避免没有循环到的值影响结果
	maxt=t[n];
	for(register int i=t[1];i<=maxt+m;i++)f[1][i]=i-t[1];
	for(register int i=2;i<=n;i++)
	{
		for(register int j=t[i];j<=maxt+m;j++)f[i][j]=min(f[i][j],f[i-1][j]+j-t[i]);//与上一个坐同一辆车
		for(register int j=t[i];j<=maxt+m;j++)
		{
			for(register int k=t[i-1];k<=j-m;k++)
			{
				f[i][j]=min(f[i][j],f[i-1][k]+j-t[i]);//新坐一辆车
			}
		}
	}
	int ans=inf;
	for(register int j=n;j<=maxt+m;j++)ans=min(ans,f[n][j]);
	printf("%d\n",ans);
	return 0;
}


```
(最后实测只有40分，应该加点小优化就50了)

### (3)100分
- 为什么拿不到满分呢，我们发现，**maxt的范围实在是太大了，有足足4000000,而此时我们注意到，n和m的却只有500和100，与4000000的差距太大了**，我们想到，如果两个人的时间相差得太远了，远得司机师傅早早送完了前面的所有人，却喝了几壶茶才等到了下一个人,**那我们其实可以让后面的人早点到**，~~（免得司机拿工资不干事）~~
- 那这个太远了是多少呢，**答案是2m,不是m**(这是一个纠结了我1个小时的问题)
- 为什么呢，我们假设在m-1的时刻有inf个人坐车，m的时刻有一个人坐车，这时候的最优解当然是让m-1个人先坐车走，**这样的话，在m时刻的人在2*m-1时刻才能做到车，如果有一个人在第3*m时刻坐车，将他的时间改为2m的话就会影响结果**   
(上方j的上届为maxt+m而不是maxt也是这个道理)                             
所以大概思路就出来了，再加一些小优化（将第一个人的时间改成0，使用滚动数组，用一个minn数组维护新坐公交车的情况），这道题就过了
- 代码:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#include<vector>
#include<bitset>
#include<set>
#include<map>
#define inf 0x7fffffff/2
#define eps 1e-6
#define N 510
#define M 110
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
inline ll read()
{
	char ch=getchar();
	ll s=0,w=1;
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
int f[2][N*M*10];
int n,m;
int t[N],minn[N*M*10];
int maxt,subt/*要减去的值*/;
int flag;
int main()
{
	n=read(),m=read();
	for(register int i=1;i<=n;i++)t[i]=read();
	sort(t+1,t+n+1);
	subt=t[1];
	for(register int i=1;i<=n;i++){t[i]-=subt;if(t[i]-t[i-1]>2*m){subt+=(t[i]-t[i-1]-2*m);t[i]=t[i-1]+2*m;}}
	maxt=t[n];
	memset(minn,127,sizeof(minn));
	for(register int i=0;i<=maxt+m;i++)f[0][i]=i,minn[i]=0;//t[1]=0
	for(register int i=2;i<=n;i++)
	{
		for(register int j=0;j<=maxt+m;j++)f[1][j]=inf;
		for(register int j=t[i];j<=maxt+m;j++)
		{
			f[1][j]=min(f[1][j],f[0][j]+j-t[i]);//和上一个人坐同一辆车
		}
		for(register int j=max(t[i],m);j<=maxt+m;j++)
		{
			f[1][j]=min(f[1][j],minn[j-m]+j-t[i]);//新坐一辆车
		}
		for(register int j=0;j<=maxt+m;j++)f[0][j]=f[1][j];//滚动数组
		for(register int j=0;j<=maxt+m;j++){if(!j)minn[j]=f[0][j];else minn[j]=min(minn[j-1],f[0][j]);}
	}
	int ans=inf;
	for(register int j=0;j<=maxt+m;j++)ans=min(ans,f[0][j]);
	printf("%d\n",ans);
	return 0;
}


```
嗯，然后这道题就可以满分了，如果你看了这篇题解有什么问题或不解可以问我~~（前提是这篇题解过了）~~



---

## 作者：__Watcher (赞：11)

### 前言（吐槽）
本蒟蒻今年正是广东的 pj 组选手（逃）

这道题花了我大约两个小时的时间，导致我第四题时间不够，思路错了，只拿了44分，都怪这第三题。

## 正文

### 心路历程

我是一个图论模板题打的超好的蒟蒻，因此拿到这题第一反应就是：

```cpp
SPFA!
```
于是我就动手开打那种标准的 SPFA ，用队列做，类似广搜。经过调试，错了，还不知道为什么（现在觉得这种思路很傻）。

我心灰意冷，决定用类似的，深搜。

爆搜肯定超时，于是基本思路就确定下来了：
```cpp
记忆化搜索！
```
### 思路讲解

1、首先车肯定要等到某个人来再出发是吧，于是可以先枚举第一次的出发时间。

2、一辆车到达的时候，或许有些人已经在等了，所以车一到就马上出发未尝不可能是一种最优解。

3、既然要等，那就要等到人再走，等几个人都有可能。要是发车时无人上车，那么发车时间就可以提前到上一个人上车的时间，只有更好没有更坏。

### 具体实现

记忆化的实现：开 $f$ 数组，$f_i$ 表示车在第 i 分钟可以出发，此时已经积累的最少的等车时间。

dfs的实现：两个参数 $t$ 和 $k$ ，$t$ 表示上次在第 $t$ 分钟发车， $k$ 表示上次已经接走了 $k$ 个人。

下面上代码（考场源代码）：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>//不敢用万能头文件
using namespace std;
long long n,m,a[505],f[4000105],t,k,maxn,minn=1e9;
//4000405：最大的有可能搜索到的时间
void dfs(int t,int k){
	if(k==n){//全部人都送完了
		if(f[t]<minn) minn=f[t];
		return ;
	}
	long long s=0,bian;
	for(int i=k+1;i<=n;i++){
		if(a[i]<=t+m){
			s+=t+m-a[i];
			if(s>=minn)return;
			bian=i;
		}
		else break;
	}//s:到达后马上出发会让已经到的人等多久
	if(t+m-a[n]>=0){//回来的时候全部人都在等了
		if(minn>f[t]+s) minn=f[t]+s;
		return;
	}
	if(f[t]+s<f[t+m]&&t+m-a[k+1]>=0){//马上出发
		f[t+m]=f[t]+s;
		dfs(t+m,bian);
	}
	s=0;
	for(int i=k+1;i<=n;i++){
		s+=(i-k-1)*(a[i]-a[i-1]);
		if(s>=minn)return;
		if(f[t]+s<f[a[i]]&&t+m<=a[i]&&a[i]!=a[i+1]){
        //接完第i个人后再出发
        //a[i]!=a[i+1]剪枝：两个人一起到就两个人一起送
			f[a[i]]=f[t]+s;//更新
			dfs(a[i],i);//递归
		}
	}
}
int main(){
	freopen("bus.in","r",stdin);
	freopen("bus.out","w",stdout);//看你还抄不抄代码
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1);//排序
	for(int i=1;i<=4000105;i++){
		f[i]=1e9;//初始化为很大的数
	}
	long long p=0;
	for(int i=1;i<=n;i++){
		p+=(i-1)*(a[i]-a[i-1]);
		f[a[i]]=p;
		if(a[i]!=a[i+1])dfs(a[i],i);//枚举出发时间
	}
	cout<<minn;
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```

### 总结

这篇题解并没有用到 dp 等高深算法，用的只是记忆化搜索。

虽然最慢的点用了将近 1s ，但这对于新手来说确实福音。因为其实掌握好基础算法，提高+的题也是可以解决的。

重要的是综合运用能力。比如说这题，你未必能想到这种方法。广东只有个位数的 pj 组选手 AC 了此题，而大概只有我一个人是这么做的。因此把握好基础是最重要的。

---

## 作者：_louhc (赞：10)

[博客食用更佳QAQ](https://www.cnblogs.com/louhancheng/p/10023188.html)  
我用的方法。。。比较。。。~~别致~~。。。主要是由于看不懂@Sooke 大佬的代码    
看这道题的时候，我（相信大家也是这样）最先想到的是贪心，但是从数据范围可以看出，如果是贪心题，数据范围不会那么小（相信NOIP不会和Luogu月赛一样，2018 11月月赛 搞个几百大小数据骗我们用DP，结果是贪心）。有些人会想(including me)，是不是在有人到达时才能发车呢？？？没想清楚就下手的话，就会浪费好多时间。仔细想想，很容易发现不一定要有人到达时发车，比如有时候，bus一回来，有个人等了2分钟，后面那个人还有INF(hh) min 才会来，如果有人到达时才能发车，那么bus将在INF min后才等到一个人，原来等了2分钟的那个人与司机等得花都谢了，所以这时候肯定是一回来就发车，虽然没有人刚好到达。

当然，我们先排序。（DP，从排序做起）。

我们用f[i]表示i min 时发一辆车，ps[i]表示1 ~ i 的人数，ts[i]表示1 ~ i 所有人开始等的时间之和。
设上一次发车是jmin时，那么j min及以前的人都已经滚粗了，我们要求j + 1 ~ i所有人等待时间之和。
等待时间之和为Σ(i - t[k]) 可以简化为 i * 人数 - Σ(t[k])， 人数、Σ(t[k])可以用前缀和来维护（即前面提到的ps、ts数组）。
然后就可以得到转移方程——

```cpp
( 0 <= i < m ) f[i] = ps[i] * i - ts[i]
( i > m ) f[i] = min{ f[j] + ( ps[i] - ps[j] ) * i - ( ts[i] - ts[j] ) }( 0 <= j <= i - m )
```

蓝鹅，这样的复杂度达到了O(MAXT ^ 2)!!!这是远远不行的。所以我们要进行优化~

### 优化I

> 对于两个人a、b( ta < tb,b = a + 1) 如果 tb - ta >= 2 * m 可以从中间断开
>
> 如果用work( l, r )表示对l、r区间范围内进行一次DP  work( ls, ta ), ls = tb;

很容易解释，因为如果两个人之间时间间隔不小于2m的话，他们是完全可以分两趟车走的。因为a最迟走的时间为ta + m - 1，车回来的时间为ta + 2m - 1,如果tb >= ta + 2m - 1，刚好可以直接粗发QAQ。(或者理解为b可以作为起点)

### 优化II

> i - 2* m + 1 <= j <= i - m

不难理解，每两趟车之间间隔不会超过或等于2m（否则中间为什么不再来一趟呢？？？）

实际上，这已经满足题目的时间复杂度要求，但是还有一个~~乱搞~~优化。(在考场上想到的)

### 优化III

> if ps[i] == ps[i - 1] 
>
> ​	j = i - m

解释这个优化要从贪心的角度考虑。

回到原来那个问题:是不是在有人到达时才能发车呢？？？

前面已经解释了答案是否定的。这从一个侧面告诉我们，如果不是在有人到达时才发车，肯定是由于车来不及回来。

所以，在最优方案中，那趟车一定会在刚好回来时发车。也就是说，i min时车刚好回来，上一次发车是在 i - m min时。

~~真是玄之又玄。~~

最终的程序不是在考场中写的，因为考场中 优化I 采用了路径压缩的方法，但是出现一些问题，被卡掉20分。

算法的复杂度也是在O(nm)级别，但常数要比Sooke大佬的代码大一些。

然后上代码！（虽然不是最好的解，但87ms也凑合吧。）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 505
#define MAXM 205

int n, m, mm, ans;
int t[MAXN], ps[MAXM * MAXN], ts[MAXM * MAXN];
int f[MAXM * MAXN];

void work( int l, int r ){
	memset( ps, 0, sizeof ps ), memset( ts, 0, sizeof ts ), memset( f, 0, sizeof f );
	for ( int i = l + 1; i <= r; ++i ){
		t[i] -= t[l]; ps[t[i]]++; ts[t[i]] += t[i];
	}
	t[l] = 0; ps[0]++;
	for ( int i = 1; i < t[r] + m; ++i ) ps[i] += ps[i - 1], ts[i] += ts[i - 1];
	for ( int i = 1; i < t[r] + m; ++i ){
		if ( i < m ){ f[i] = ps[i] * i - ts[i]; continue; }
		if ( ps[i] == ps[i - 1] ){ f[i] = f[i - m] + ( ps[i] - ps[i - m] ) * i - ( ts[i] - ts[i - m] ); continue; }
		f[i] = INT_MAX;
		for ( int j = max( 0, i - mm + 1 ); j <= i - m; ++j ) f[i] = min( f[i], f[j] + ( ps[i] - ps[j] ) * i - ( ts[i] - ts[j] ) );
	}
	int cur(INT_MAX);
	for ( int i = t[r]; i < t[r] + m; ++i ) cur = min( cur, f[i] );
	ans += cur;	
}

int main(){
	scanf( "%d%d", &n, &m ); mm = m << 1;
	for ( int i = 1; i <= n; ++i ) scanf( "%d", &t[i] );
	sort( t + 1, t + n + 1 );
	int ls(1);
	for ( int i = 1; i < n; ++i )
		if ( t[i + 1] - t[i] >= mm ) work( ls, i ), ls = i + 1;
	work( ls, n );
	printf( "%d\n", ans );
	return 0;
}
```

---

## 作者：exprosic (赞：9)

发一个 $O(n^2)$ 的解法吧。代码就不贴了。

首先证明一个性质：在将 $t_{1\dots n}$ 排序后，最优发车时刻一定形如
$$t_{i_0}<t_{i_0}+m<t_{i_0}+2m<\dots<t_{i_1}< t_{i_1}+m< t_{i_1}+2m< \dots\;(1\le i_0 < i_1 <\dots <i_k \le n)$$
也就是说，一定只能在
1. 某人到达时发车
2. 或者在相邻两次【某人到达时发车】之间，以 $m$ 的频率发车

对答案长度做归纳：
- 第一个发车时刻一定是在某人到达时。否则：
 - 如果发车前无人到达，则不必发车
 - 如果发车前有人到达，则一定可以提前到上一个人到达时发车，此时之前的人等待时间减少，之后的等待时间和发车安排不受影响
- 假设前 $n$ 个发车时刻都满足以上规律。考虑第 $n+1$ 次发车：
 - 如果发车时刻有人到达，则显然满足
 - 如果发车时刻无人到达，则离第 $n$ 次发车间隔必然为 $m$，否则若超过 $m$，就一定可以提前一分钟发车，此时之前的人等待时间不增，之后的等待时间和发车安排不受影响

证毕。这样问题就变成：选取一些同学的到达时刻 $1 \le i_1 < i_2 < \dots < i_k \le n$ 来发车，然后在时间段 $[i_j, i_{j+1}]$ 内的发车时刻为 $t_j+km,\;k=0,1,\dots, \left \lfloor{\frac{t_{j+1}-t_j}{m}}\right \rfloor-1$（注意最后需要$-1$，否则 $t_{j+1}$ 离上一次发车间隔会小于 $m$），在这样的发车规则下，等待时间之和最少是多少。

首先用 $O(n\log(n))$ 的时间排序，再用 $O(n^2)$ 的时间预处理出：任意一对同学之间，在以上发车方式之下，这对同学之间的同学的等待时间之和。然后就是简单的DP了。阶段数 $O(n)$，转移数 $O(n)$，转移代价 $O(1)$.

为了避免处理繁琐的边界情况，可以增加两位同学，等待时间分别为 $t_1-2m$ 和 $t_n+2m$，显然他们不影响答案，因而一定可以存在于最优解中。

总复杂度为 $O(n^2)$.

---

## 作者：djww (赞：8)

     
【前言】
  
   这题我在复赛考场上花了很久的时间……
 
   但是渣渣并没有出来

   我参考别的大佬发的解析，整理了一份分段得分的题解

【10分】
	    
   这个段应该最好理解了
   
   相当于摆渡车每个时间段都载走当前的学生
   
  因为下一个时间段和摆渡时间是一样的
  
   每次输出0，没有人在等

【30分暴搜】

  传说不是说会了暴搜普及问题就不大了吗
  我们~~正式~~开始分析这个问题
  
  首先，问题每次出现分歧的时候是在
  
 “等这波人”
  和
 “不等这波人”
       
  那暴搜的目的就是通过这个部分来进行枚举每一种可能
        
   **第一点，首先时间要排序，这样才可能判断等人**
        
  这一点应该不难想到，或者说是必须想到
        
   **第二点，每层在枚举什么**
        
   无非就是枚举人数或是时间但因为在这个问题中，这两个因素对问题都会产生影响
   
  所以每层两个都带
        
 **第三点，回溯的条件**
        
离开的人达到了总人数
        
**第四点，在哪里产生分歧，即暴搜起到作用**
        
可以看出，唯一产生分歧的，就是要不要等这个人
        
所以，我们每层时间都在枚举在这个时间点等下一波人和直接走的时间，那个更小
        
 **第五点，一些细节**
        
  1.小于等于当前时间点的人都要上车，进行计算
  
2.计算时间
 
 3.当前时间没人就跳到下一个有人的时间点
        
        
        
        
```cpp
#include <cstdio>
#include <algorithm>
#include <iostream>
using namespace std;
int n,m,t[510];
int dfs(int i,int st)//i代表第i个人，st代表当前时间 
{
    if(i==n+1)return 0;//所有人都上车了 
    if(st<t[i])return dfs(i,t[i]);//如果现在的时间没有人，就到下一个人的到达时间 
    int sum=0,j=i;
    while(j<=n&&t[j]<=st)//开车之前的人都上车 
        sum+=t[j++];
    int best=st*(j-i)-sum+dfs(j,st+m);//计算等待时间 
    for(;j<=n;j++)
    {
        sum+=t[j];
        best=min(t[j]*(j-i+1)-sum+dfs(j+1,t[j]+m),best);
        //如果不开车，等待第j个人的话时间会不会更优 
    }
    return best;
} 
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>t[i];
    sort(t+1,t+n+1);//显然从小到大按照时间排序更好算 
    printf("%d\n",dfs(1,0));
    return 0;
}
```
【30分DP】

我们再从DP的方式来分析这个问题

因为每一次的变量在于**人数和当前时间**（也就关系到上车）

我们设dp[i][j]表示第i个人在第j分钟上车时总等待时间的最小值

我们每次分析的目的是要不要上车，其实也就**关系到之前的人**

也就是判断在i之前的人如果和i一起上j时间的车会不会更优

那么dp[i][j]就是用1到i-1来推导

**dp[i][j]=min(dp[k][l]+time(k+1,i,j))**

{1<i<=n,t[i]<=j<=maxt+m,0<=k<i,t[k]<=l<=j-m}

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define inf 0x7ffffff/2
#define eps 1e-6
#define N 110
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int n,m;
int dp[N][N],t[N],maxt;
int ans=inf;
inline int cost(int l,int r,int x)//计算cost 
{
    int sum=0;
    for(register int i=l;i<=r;i++)sum+=(x-t[i]);
    return sum;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(register int i=1;i<=n;i++)scanf("%d",&t[i]);
    //输入
    sort(t+1,t+n+1);//对每个人到达的时间从小到大排序
    maxt=t[n];//最后一个人到达的时间
    for(register int i=t[1];i<=maxt+m;i++)dp[1][i]=i-t[1];
    for(register int i=2;i<=n;i++)//dp
    {
        for(register int j=t[i];j<=maxt+m;j++)
        //这里是maxt+t,不是maxt,很重要
        {
            dp[i][j]=inf;//初始化
            for(register int k=0;k<i;k++)
            {
                for(register int l=t[k];l<=j-m;l++)
                {
                    dp[i][j]=min(dp[i][j],dp[k][l]+cost(k+1,i,j));
                    //动态转移方程
                }
            }
        }
    }
    for(register int i=maxt;i<=maxt+m;i++)ans=min(ans,dp[n][i]);
    //统计答案
    printf("%d\n",ans);//输出
    return 0;
}
```


【50分DP进阶】

想要优化一种代码，我们就从代码优化前的思路入手

因为我们每次的dp，都是关注于这辆车上载了多少人和走了几次来影响递推和答案，但车上载多少人和答案有大关系吗

没有

所以我们从每个人入手，转移dp过程的中心

每个人要关注的是我要上上一个人做的车呢，还是坐下一班车呢

**dp[i][j]=min(dp[i-1][j],dp[i-1][k])-t[i]+j**

(2<=i<=n,t[i]<=j<=maxt+m,t[i-1]<=k<=j-m)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define inf 0x7fffffff/2
#define eps 1e-6
#define N 510
#define M 10010
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
inline ll read()
{
    char ch=getchar();
    ll s=0,w=1;
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
    return s*w;
}
int f[N][M];
int n,m;
int t[N];
int maxt;
int main()
{
    n=read(),m=read();
    for(register int i=1;i<=n;i++)t[i]=read();
    sort(t+1,t+n+1);
    memset(f,127,sizeof(f));//这里就要给f统一设上最大值了，避免没有循环到的值影响结果
    maxt=t[n];
    for(register int i=t[1];i<=maxt+m;i++)f[1][i]=i-t[1];
    for(register int i=2;i<=n;i++)
    {
        for(register int j=t[i];j<=maxt+m;j++)f[i][j]=min(f[i][j],f[i-1][j]+j-t[i]);//与上一个坐同一辆车
        for(register int j=t[i];j<=maxt+m;j++)
        {
            for(register int k=t[i-1];k<=j-m;k++)
            {
                f[i][j]=min(f[i][j],f[i-1][k]+j-t[i]);//新坐一辆车
            }
        }
    }
    int ans=inf;
    for(register int j=n;j<=maxt+m;j++)ans=min(ans,f[n][j]);
    printf("%d\n",ans);
    return 0;
}
```


【100分DP】

继续优化上一次的思想

上一次思想缺点在哪里呢，观察循环我们可以看到，maxt特么太大了，和n，m差了很多

比方说，上一波人明明已经送完了，但司机师傅每个点都要来帮你算一次，尽管事实上下一波人还要再等几个小时甚至大半天才来，是不是很耗费时间？

**我们可以让下一波人“早点”来**

具体早来的时间，为2m-1

>我们假设在m-1的时刻有inf个人坐车，m的时刻有一个人坐车，这时候的最优解当然是让m-1个人先坐车走，这样的话，在m时刻的人在2m-1时刻才能做到车，如果有一个人在第3m时刻坐车，将他的时间改为2m的话就会影响结果

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define inf 0x7fffffff/2
#define eps 1e-6
#define N 510
#define M 110
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int f[2][N*M*10];
int n,m;
int t[N],minn[N*M*10];
int maxt,subt/*要减去的值*/;
int flag;
int main()
{
    scanf("%d%d",&n,&m);
    for(register int i=1;i<=n;i++)scanf("%d%d",&t[i]);
    sort(t+1,t+n+1);
    subt=t[1];
    for(register int i=1;i<=n;i++){t[i]-=subt;if(t[i]-t[i-1]>2*m){subt+=(t[i]-t[i-1]-2*m);t[i]=t[i-1]+2*m;}}
    maxt=t[n];
    memset(minn,127,sizeof(minn));
    for(register int i=0;i<=maxt+m;i++)f[0][i]=i,minn[i]=0;//t[1]=0
    for(register int i=2;i<=n;i++)
    {
        for(register int j=0;j<=maxt+m;j++)f[1][j]=inf;
        for(register int j=t[i];j<=maxt+m;j++)
        {
            f[1][j]=min(f[1][j],f[0][j]+j-t[i]);//和上一个人坐同一辆车
        }
        for(register int j=max(t[i],m);j<=maxt+m;j++)
        {
            f[1][j]=min(f[1][j],minn[j-m]+j-t[i]);//新坐一辆车
        }
        for(register int j=0;j<=maxt+m;j++)f[0][j]=f[1][j];//滚动数组
        for(register int j=0;j<=maxt+m;j++){if(!j)minn[j]=f[0][j];else minn[j]=min(minn[j-1],f[0][j]);}
    }
    int ans=inf;
    for(register int j=0;j<=maxt+m;j++)ans=min(ans,f[0][j]);
    printf("%d\n",ans);
    return 0;
}
```

【100分记忆化搜索】

这个记忆化搜索其实就只有记忆化搜索的一个优化，别的思想完全和30分的没有变（想不到吧）

我们记mem[i][t]为第i个人t时的最优值，每次记忆就可以了

```cpp

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <cctype>

using namespace std;

int read()
{
    int x=0,f=1;char ch=getchar();
    while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
    while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
    return x*f;
}

int n,m,t[505],mem[505][505];

//因为0<=st-t[i]<=m，因此可以记忆化，把这个作为状态的第二维 

int solve(int i,int st)//记忆化搜索。i：第i个人，st：开始时间st 
{
    if (i==n+1)//所有人都上车了 
        return 0;
    if (st<t[i])//如果现在的时间没有人，就到下一个人的到达时间 
        return solve(i,t[i]);
    if (mem[i][st-t[i]])//记忆化 
        return mem[i][st-t[i]];
    int sum=0,j=i;
    //车等人 
    while (j<=n && t[j]<=st)
        sum+=t[j++];
    int best=st*(j-i)-sum+solve(j,st+m); 
    //人等车
    for (;j<=n;j++)
    {
        sum+=t[j];
        best=min(t[j]*(j-i+1)-sum+solve(j+1,t[j]+m),best);
    }
    return mem[i][st-t[i]]=best;
}

int main()
{
    //memset(mem,-1,sizeof(mem));
    n=read(),m=read();
    for (int i=1;i<=n;i++)
        t[i]=read();
    sort(t+1,t+n+1);//显然从小到大按照时间排序更好算 
    cout << solve(1,0) << endl;
    return 0;
}
```

---

## 作者：Plozia (赞：7)

宣传博客->[link](https://blog.csdn.net/BWzhuzehao/article/details/108141420)

update 2021/1/19：

1. 原题解部分 Markdown 和 Latex 炸了，现在已经修复。
2. 对题解当中一些表述不明的句子做了进一步的阐述。
3. 更换了码风。

---

首先，看到这道题在普及组 T3 的位置，我们知道只能是 搜索/图论/DP 三者之一。

再结合数据范围我们就可以 ~~根据个人经验~~ 分析出这道题是 DP 题。

但或许是我太弱了，没有想出 DP 怎么写，最后用了记忆化搜索。

在写记忆化搜索时，我的方法是： **先写爆搜，通过小样例之后再加记忆化。**

对于本题而言，我最开始想到的是从第 $n$ 个人倒回去处理，设他在第 $x$ 分钟离开（ $t_i \leq x$），进行搜索。 $dfs(k,g)$ 表示第 $k$ 个人在时间点 $g$ 之后离开，枚举第 $k-1$ 离开时间点后判断上一个人是否会与这个人同车。

但是这样显然时间复杂度与 $O(nt)$ 有关，妥妥的 TLE。

到这里，我们会发现有两条路：往 $O(nm)$ 走或者往 $O(t)$ 走。

接下来，我分析了题目，发现 **每一个人至多等待 $2 \times m$ 分钟** ，因为对于第 $i$ 个人，如果 $x-t_i > 2m$ ，表明此时他在的时候车子已经开过一遍了，而他却还是呆在原地，显然不是最优的选择。

所以，我们没有必要去枚举 $x$ ，只需要枚举一个数 $k$ （ $0 \leq k \leq 2m$ ，即为等车时间），则第 $i$ 个人发车时间为 $t_i+k$ 。这样就避免了因为 $t$ 的范围而引起的超时，方向为 $O(nm)$。

那么接下来如何判断第 $i-1$ 个人与第 $i$ 个人是否同车呢？

同样，我们枚举 $k'$ ，表示第 $i-1$ 个人的等车时间。

- 如果 $t_{i-1}+k'=t_i+k$ ，表明此时两个人发车时间相同，那么一起走。
- 如果 $t_{i-1}+k'+m \leq t_i+k$ ，表明此时第 $i-1$ 个人坐车到达，车子回到人大附中之后第 $i$ 个人还没有发车，那么第 $i-1$ 个人直接发车离开。
- 如果 $t_{i-1}+k'+m > t_i+k$ ，表明第 $i-1$ 个人发车走后第 $i$ 个人还要再等，但是这种情况按照上面所述显然不优：
	+ 如果第 $i-1$ 个人走了之后第 $i$ 个人都还没有到，那么我们完全不需要去理第 $i$ 个人，那么直接发车走人，而且此时肯定是越早走越好，那么我们在枚举 $k'$ 的时候已经解决了。
	+ 否则，说明第 $i-1$ 个人跟第 $i$ 个人在一起等车，但是第 $i-1$ 个人走了第 $i$ 个人还呆在那里，之前已经解释过肯定不是最优解，那么也不需要去管。

分析完毕，此时 $dfs(k,g)$ 表示第 $k$ 个人在 **第 $t_k+g$ 的时间发车（而不是第 $g$ 时间点发车）** 时的最小值。函数中，我们枚举 $i$ （$0 \leq i < 2m$），进行上述判断，如果满足任意条件，更新答案。

更新答案时，我的方式是函数中令 $sum= INF$ ，满足任一条件时， $sum \gets min(sum,dfs(k-1,i)+g)$（ $dfs(k-1,i)+g$ 表示第 $k-1$ 个人在 $t_{k-1}+g$ 时发车时等待时间最小值，加上第 $k$ 个人等待时间 $g$ ），最后返回 $sum$ 即可。

不要忘记对 $t$ 排序！

暴力代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 500 + 10;
int n, m, t[MAXN], f[MAXN][MAXN], ans;//f[i][j] 表示第 i 个人在等了 j 时间后发车的最优解

int read()
{
	int sum = 0, fh = 1; char ch = getchar();
	while (ch < '0' || ch > '9') {if (ch == '-') fh = -1; ch = getchar();}
	while (ch >= '0' && ch <= '9') {sum = (sum << 3) + (sum << 1) + (ch ^ 48); ch = getchar();}
	return sum * fh;
}
int Min(int a, int b) {return (a < b) ? a : b;}

int dfs(int k, int g)
{
	if (k == 1) return g;
	int ans = 0x7f7f7f7f;
	for (int i = 0; i < (m << 1); ++i)
	{
		if (t[k - 1] + i == t[k] + g) ans = Min(ans, dfs(k - 1, i) + g);
		if (t[k - 1] + i + m <= t[k] + g) ans = Min(ans, dfs(k - 1, i) + g);
	}
	return ans;
}//暴力dfs

int main()
{
	n = read(), m = read(), ans = 0x7f7f7f7f;
	for (int i = 1; i <= n; ++i) t[i] = read();
	sort(t + 1, t + n + 1); memset(f, -1, sizeof(f));
	for (int i = 0; i< (m << 1); ++i) ans = Min(ans, dfs(n, i));
	printf("%d\n", ans); return 0;
}
```

接下来加记忆化。其实在写记忆化搜索的时候，我个人认为加记忆化是最简单的， **只要爆搜写好并且写对，加记忆化易如反掌。哪里有 return ，哪里加记忆化** 。最后代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 500 + 10;
int n, m, t[MAXN], f[MAXN][MAXN], ans;//f[i][j] 表示第 i 个人在等了 j 时间后发车的最优解，初始化为 -1。

int read()
{
	int sum = 0, fh = 1; char ch = getchar();
	while (ch < '0' || ch > '9') {if (ch == '-') fh = -1; ch = getchar();}
	while (ch >= '0' && ch <= '9') {sum = (sum << 3) + (sum << 1) + (ch ^ 48); ch = getchar();}
	return sum * fh;
}
int Min(int a, int b) {return (a < b) ? a : b;}

int dfs(int k, int g)
{
	if (f[k][g] != -1) return f[k][g];
	if (k == 1) return f[k][g] = g;
	int ans = 0x7f7f7f7f;
	for (int i = 0; i < (m << 1); ++i)
	{
		if (t[k - 1] + i == t[k] + g) ans = Min(ans, dfs(k - 1, i) + g);
		if (t[k - 1] + i + m <= t[k] + g) ans = Min(ans, dfs(k - 1, i) + g);
	}
	return f[k][g] = ans;
}

int main()
{
	n = read(), m = read(), ans = 0x7f7f7f7f;
	for (int i = 1; i <= n; ++i) t[i] = read();
	sort(t + 1, t + n + 1); memset(f, -1, sizeof(f));
	for (int i = 0; i< (m << 1); ++i) ans = Min(ans, dfs(n, i));
	printf("%d\n", ans); return 0;
}
```

最后的总结：其实对于普及的 DP ，如果没有好思路时，可以尝试写记忆化搜索，或许就能解出 DP 题而成功的获得高分。

---

## 作者：redegg (赞：7)

这题没有想象得那么难。

首先一看这题就知道，需要离散化，$dp$转移一定是限定了范围的，比如转移只用从前$m$个转移而没必要从第一个开始转移。

我们先写转移方程吧，$dp[i]$表示在$i$这个时间点发车的最小等待时间。

我们首先假设$sum[i]-sum[j]$表示从$j$时刻发车后，到$i$时刻这段时间来乘车的同学的等待时间。（前缀和思想）

那么我们可以这样转移:$dp[i]=dp[j]+sum[i]-sum[j]$,而且前提是$i-m \ge j$（保证我发车时车回来了）。

而且有个贪心的想法在这里，我们上一次发车时间是限定在了一个长度为$m$的时间段的！

我们假设$k$是上一次发车后车返回这里的时间点，那么$j=k-m$，如果$k \le i-m$会怎么样？我可以在$k$时刻发一趟车啊，并且这趟车一定会在$i$时刻前赶回来的！在$k$时刻发车一定比等到$i$时刻发车更优秀！

所以$k$一定是$i-m \lt k \le i$的。那么$j$也一定是$i-2m \lt j\le i-m$的。

但是这样计算，最大的复杂度也达到了$4\times 10^8$，那么怎么优化呢？很容易发现，两点间距离一旦大于$2m$了，两点间的发车时间完全不受对方影响！我们可以吧这个大于$2m$的距离缩小为$2m$，不会影响答案！这一步就是很关键的离散化操作。

好了，复杂度优化到了$10^7$，但是上文提到的$sum[i]-sum[j]$怎么求呢？

很简单，我们需要两个数组$t$、$sum$，$t[i]$表示“从0秒开始到第$i$秒乘客一共等待的时间”，$sum[i]$表示“从0秒开始到现在一共有多少位同学到了车站。”

那么$j-->i$的总等待时间是：$t[i]-t[j]-sum[j]\times (i-j)$

自己思考一下看看对不对。

总的代码在下面：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m;

long long t[100005];
long long sum[100005];
long long dp[100005];

int cut;
int a[505];
int maxn=0;

int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1; i<=n; i++)
    {
        scanf("%d",&a[i]);
        a[i]+=m;
    }
    sort(a+1,a+1+n);
    for(int i=0; i<n; i++)
    {
        int lins=0;
        if(a[i+1]-a[i]>2*m)
            lins=a[i+1]-a[i]-2*m;
        a[i]-=cut;
        cut+=lins;
        maxn=max(maxn,a[i]);
    }
    a[n]-=cut;
    maxn=max(maxn,a[n]);

    for(int i=1; i<=n; i++)
        sum[a[i]]++;

    for(int i=1; i<=maxn+m; i++)
    {
        sum[i]=sum[i-1]+sum[i];
        t[i]=t[i-1]+sum[i-1];
    }

    memset(dp,0x3f,sizeof(dp));

    for(int i=0; i<m; i++)
        dp[i]=t[i];

    for(int i=m; i<=maxn+m; i++)
    {
        for(int j=i-m+1; j<=i; j++)
        {
            int last=j-m;
            if(last>=0)
                dp[i]=min(dp[last]+t[i]-t[last]-sum[last]*(i-last),dp[i]);
        }
    }

    long long ans=1e18;

    for(int i=maxn; i<=maxn+m; i++)
        ans=min(ans,dp[i]);
    printf("%lld\n",ans);

    return 0;
}

```

---

## 作者：Wai_t_ing (赞：6)

这是一道比较难想优化的DP，去年考炸了，今年就不想再碰这道题，今天比较闲，又重新做了一遍

一年之后重新做这一道题，发现还是有点套路的

可以用$f[j]$表示最后一次到j的浪费的时间，那么我们可以枚举所有上一次的时间，计算上一次到这一次所浪费的时间。

设上一次时间为$i$,这一次是$j$，那么

$$f[j]=min(f[j],f[i]+\sum_{t[k]<=j}j-t[k] )$$

$$\text{拆开这个柿子}$$

$$\sum{j-t[k]}=cnt[j]*i-sum[j]$$

这一部分用前缀和优化过去就行了，能得$50pts$

接下来，可以发现这里有处理重复状态，比如当$i=k,j=k-m$的时候，这个状态，已经有过一次，那么就没有必要在$i=k+m,j=k-m$的时候再重复计算一遍了，所以我们只需要枚举到$i-m$就够了，能得$70pts$

接下来再考虑一段，如果没有任何人存在，那么完全是没有必要更新的，直接取之前的状态就好了

综上可得$100pts$

```cpp

#include<bits/stdc++.h>
using namespace std;
int n,m,mt,t;
int f[4000005],ans[4000005];
int cnt[4000005],sum[4000005]; 
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i){
		scanf("%d",&t);
		++cnt[t];
		sum[t]+=t;
		mt=max(mt,t);
	}
	for(int i=1;i<mt+m;++i)cnt[i]+=cnt[i-1],sum[i]+=sum[i-1];//前缀和优化
	for(int i=1;i<mt+m;++i){
		if(i>=m&&cnt[i]==cnt[i-m]){f[i]=f[i-m];continue;}//中间没有人直接跳过
		f[i]=cnt[i]*i-sum[i];//边界情况先处理
		for(int j=max(i-2*m+1,0);j<=i-m;++j)
		 f[i]=min(f[i],f[j]+(cnt[i]-cnt[j])*i-(sum[i]-sum[j]));//上面的式子推得
	}
	int ans=1e9;
    for(int i=mt;i<mt+m;++i)ans=min(ans,f[i]);//统计答案
	cout<<ans<<endl;  
}

---

## 作者：CrazyDance (赞：4)

## [~~传送门~~](https://www.luogu.org/problem/P5017)

### 其实，这是一种比较容易推的方法。

仔细观察一下这道题，它的 $n$ 和 $m$ 都很小，明摆着就是让你用的嘛。先对 $a_i$ 进行排序，然后我们就设一个很神奇的状态，$f_{i,j}$ 表示第 $i$ 个人，等待时间为 $j$ 且前 $i$ 个人已到达的时间最小和，~~转移显然（咳咳）~~。

然后我们分两种情况讨论：

1. $a_{i+1}\leq a_{i}+j$。则下一个人明显可以和当前这个人坐同一辆车走，转移方程为：

$$ f_{i+1,a_i+j-a_{i+1}}= \min(f_{i+1,a_i+j-a_{i+1}},f_{i,j}+a_{i}+j-a_{i+1}) $$

2. $a_{i+1}>a_{i}+j$（情况一的反例）。我们就枚举下一台车的时间与下一个人到来时间的差，我们有 $k$：

$$ k = \max(0,a_i+j+m-a_{i+1}) \to (2m+1) $$

转移为：

$$ f_{i+1,k} = \min(f_{i+1,k},f_{i,j}+k) $$

$f$ 数组初值为无限大，但 $\forall\ f_{1,i} = i$。

接下来就是上代码啦（码风~~很好看~~，这个方法的理论极限复杂度是很慢的 $O(nm^2)$，但是实际上会快很多）

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 5010
#define inf 0x7f7f7f
using namespace std;
int a[N],f[N][N*2/5],n,m,s=inf;
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++) scanf("%d",&a[i]);
	memset(f,inf,sizeof(f));
	for (int i=0;i<=n;i++) f[1][i]=i;
	sort(a+1,a+n+1);
	for (int i=1;i<=n;i++) for (int j=0;j<=2*m;j++)
	{
		if (a[i+1]<=a[i]+j) f[i+1][a[i]+j-a[i+1]]=min(f[i+1][a[i]+j-a[i+1]],f[i][j]+a[i]+j-a[i+1]);
		else for (int k=max(0,a[i]+j+m-a[i+1]);k<=2*m+1;k++) f[i+1][k]=min(f[i+1][k],f[i][j]+k);
	}
	for (int i=0;i<=m;i++) s=min(s,f[n][i]);
	printf("%d",s);
	return 0;
}
```

---

## 作者：caidzh (赞：3)

看了一圈都没有用数据结构维护$dp$的

可能是我太菜了想不出单调性优化的做法吧

我们用思维难度低的数据结构来制裁思维难度大的单调性做法，虽然跑的慢了点，但是已经可以过了，下面的讲解中均不会出现边界条件，边界的设置因码而异

### $10$分做法

输出$0$就行辣！

### $30$分做法 $O(n^2t^2)dp$

排序是必要的，首先从小到大$sort$一遍

考虑用$dp[i]$来表示前$i$个人全部送走时的最小花费

然后开始列转移方程

$$dp[i]=min(dp[j]+cost(i,j))$$

你会发现你列不出转移方程了，那个$cost$无法使用$i,j$表示（仔细想想会发现这无法表示在转移时车是什么时候回来接人的，去年我就陷入了这样的漏洞，然后$15$分滚粗）

于是我们尝试加一维状态：用$dp[i][j]$表示前$i$个人全部送走，并且车是在$j$分钟时开走的，接下来状态转移就非常显然了

$$dp[i][j]=min(dp[k][l]+cost(i,j,k,l))$$

设第$i$个人到达的时间为$t[i]$那么$cost(i,j,k,l)$就等于

$$cost[i,j,k,l]=\sum_{a=k+1}^it[i]+j-t[a]$$

其中必须保证$t[k]+l+m\le t[i]+j$

其实做到这里会有点感觉，那个$\sum$是可以用前缀和优化的

设$sum[i]$表示$\sum_{a=1}^it[i]$，然后前面$cost$的计算可以化为

$$cost[i,j,k,l]=(i-k)*(t[i]+j)-(sum[i]-sum[k])$$

可以发现这样做时间和空间在大的数据下都是不优的

做完这些就可以得到$30$分的好成绩

### $50$分做法 $O(n^2m^2)dp$

其实做到这里已经非常显然了，一辆车最多在一个人到达后几分钟开走呢？实际上这个时间不会超过$2m-1$，因为可以发现如果一辆车在一个人走之前$1$分钟开走，那么如果它回来后$m$分钟都不开走，那么答案肯定不会最优（都有可以运走一批人的时间为什么不运走呢？）

所以把状态改了$dp[i][j]$表示把前$i$个人都送走，且车是在$t[i]+j$时间送走人的最小花费，然后状态转移方程改改就能$50$分了，代码如下：

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#define INF 2147483647
#define LLINF 9223372036854775807
#define LL long long
#define xyx AKIOI
#define Dilute AKIOI
#define Chtholly_Tree AKIOI
#define time_interspace AKIOI
using namespace std;
int inline read(){
    int num=0,neg=1;char c=getchar();
    while(!isdigit(c)){if(c=='-')neg=-1;c=getchar();}
    while(isdigit(c)){num=(num<<3)+(num<<1)+c-'0';c=getchar();}
    return num*neg;
}
int n,m,t[510],dp[510][210],sum[510],ans=INF/3;
//表示第i个人来之后j分钟摆渡车开走时的最小花费 
int main()
{
	cin>>n>>m;for(int i=1;i<=n;i++)t[i]=read();sort(t+1,t+n+1);
	for(int i=1;i<=n;i++)sum[i]=sum[i-1]+t[i];
	memset(dp,127/3,sizeof(dp));for(int i=0;i<=2*m;i++)dp[0][i]=0;t[0]=-INF;
	for(int i=1;i<=n;i++)
		for(int j=0;j<=2*m;j++)
			for(int k=0;k<i;k++)
			    for(int l=0;l<=2*m;l++)
			        if(t[k]+l+m<=t[i]+j)
			        	dp[i][j]=min(dp[i][j],dp[k][l]+(i-k)*(t[i]+j)-(sum[i]-sum[k]));
	for(int i=0;i<=2*m;i++)ans=min(ans,dp[n][i]);cout<<ans;
	return 0;
}
```

### $100$分做法 $O(n^2mlogm)$

注意到上面的状态转移方程中，当$k$不变时只有$dp[k][l]$一直在变，后面的$cost$是个常数，这启示我们可以动态地维护$dp[k][0->l]$的最小值

线段树？太麻烦辣！

可以发现对于$l$的限制是非常有趣的，$l$一定大于$0$，必须小于等于$t[i]+j-t[k]-m$，所以可以发现这个最小值是个前缀，前缀最小值？单点修改？这不就是树状数组嘛！

所以这个树状数组该开多大呢？是$2m$吗？的确是的！但是并没有这么简单，因为$t[i]+j-t[k]-m$可以很大

这里有个小$trick$，观察上面的代码，实际上我们并没有考虑这种第二维很大的状态，但为什么上面的代码对呢？因为它并没有忽视这样的转移，这就启示我们可以将$t[i]+j-t[k]-m>2m$的情况直接视作$2m$

于是开$n$个树状数组，注意将第二维为$i$的情况提到$i+1$，因为树状数组的下标不能为$0$，代码如下：
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#define INF 2147483647
#define LLINF 9223372036854775807
#define LL long long
#define xyx AKIOI
#define Dilute AKIOI
#define Chtholly_Tree AKIOI
#define time_interspace AKIOI
using namespace std;
int inline read(){
    int num=0,neg=1;char c=getchar();
    while(!isdigit(c)){if(c=='-')neg=-1;c=getchar();}
    while(isdigit(c)){num=(num<<3)+(num<<1)+c-'0';c=getchar();}
    return num*neg;
}
int n,m,t[510],dp[510][210],sum[510],ans=INF/3;
int Min[510][210];
void update(int p,int x,int val){x++;for(int i=x;i<=2*m;i+=i&(-i))Min[p][i]=min(Min[p][i],val);} 
int Query(int p,int x){int ans=INF;x++;for(int i=x;i>0;i-=i&(-i))ans=min(ans,Min[p][i]);return ans;}
//表示第i个人来之后j分钟摆渡车开走时的最小花费 
int main()
{
	cin>>n>>m;for(int i=1;i<=n;i++)t[i]=read();sort(t+1,t+n+1);
	for(int i=1;i<=n;i++)sum[i]=sum[i-1]+t[i];
	memset(dp,127/3,sizeof(dp));memset(Min,127/3,sizeof(Min));
	for(int i=0;i<=2*m;i++)dp[0][i]=0,update(0,i,0);t[0]=t[1]-m;
	for(int i=1;i<=n;i++)
		for(int j=0;j<=2*m;j++){
		    for(int k=0;k<i;k++){
		    	int l=t[i]+j-t[k]-m;if(l<0)continue;if(l>2*m)l=2*m;
		    	dp[i][j]=min(dp[i][j],Query(k,l)+(i-k)*(t[i]+j)-(sum[i]-sum[k]));
			}
			update(i,j,dp[i][j]);
		}
	for(int i=0;i<=2*m;i++)ans=min(ans,dp[n][i]);cout<<ans;
	return 0;
}
```
结果就发现$CCF$放这种不要啥思维的方法过了

---

## 作者：hnczy (赞：1)

这里写一个斜率优化 dp 的解法。

我们可以用 $T$ 来作为状态，进行转移。

令 $c_i$ 是第 $i$ 时的人数。
比较容易写出状态转移方程：$dp_i=dp_j+\sum_{k=j+1}^{i}(i-k)\times c_i$。

可以用一个前缀和优化，写成 $dp_i=dp_j+(p_i-p_j)\times i-(p2_i-p2_j)$，$p$ 表示人数的前缀，$p2$ 表示人数乘下标的前缀。

进行移项得：$dp_j+p2_j=dp_i+p2_i-p_i\times i+p_j\times i$。

令 $x=p_i,y=dp_i-p2_i,k=i$。

注意到，$x$，$k$ 都是单调的，直接用一个单调队列维护下凸包即可。

注意 $dp_{T\max}$ 不一定是答案，所以枚举要到 $dp_{T\max+m}$。

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5E6+5;
int n,m,p[N],p2[N],t[N],mx,q[N],dp[N],x[N],y[N],ans=1e9;
inline int calc(int i,int j){
	return dp[j]+i*(p[i]-p[j])-(p2[i]-p2[j]);
}
bool check(int i, int j, int k) {
	return (y[i] -y[j]) * (x[j] - x[k] ) <= (y[j]- y[k]) * (x[i] - x[j] );
}
signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1,x;i<=n;i++){
		scanf("%lld",&x);
		mx=max(mx,x);
		t[x]++;
	}
	p[0]=t[0];
	for(int i=1;i<=mx+m;i++){
		p[i]=p[i-1]+t[i];
		p2[i]=p2[i-1]+t[i]*i; 
	}
	int head=0,tail=-1;
	for(int i=0;i<m;i++){
		dp[i]=i*p[i]-p2[i];
		x[i]=p[i],y[i]=dp[i]-p2[i];
	}
	for(int i=m;i<=mx+m;i++){
		while(head<tail && check(q[tail],q[tail-1],i-m))
			tail--;
		q[++tail]=i-m;
		while(head<tail && calc(i,q[head]) >= calc(i,q[head+1]))head++;
		dp[i]=calc(i,q[head]);
		x[i]=p[i],y[i]=dp[i]-p2[i];
		if(i>=mx)ans=min(ans,dp[i]);
	}
	cout<<ans<<endl;
	return 0;
}

---

## 作者：xmy201315 (赞：0)

这道题乍一看，很多人（包括我）就会想到贪心。

但是我们仔细想一下，正着贪心（也就是摆渡车能开就开）这个是不行的。那倒着贪心呢（也就是让最后一个人不等待，然后一直往前推 $m$ 时刻）？也不行，这里有一个反例。

```cpp
4 5
1 1 1 5
```
正确输出
```cpp
1
```
第二种贪心方式的输出
```cpp
12
```
所以我们用到了 DP，状态设计起来还是比较简单的。

我们令 $t$ 为上一次摆渡车开走的时间，摆渡车没有开走过 $t$ 就等于 $1$。再令 $f_i$ 表示在 $i$ 时刻摆渡车开走了，$t \sim i$ 时刻的同学的等待时间。

那么转移为 $$f_i \gets min_{t\le i-m}(f_i,f_t+[t+1]\sim i)$$。

**AC code**:
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 201000;
int n, m, t[N], dp[N], s1[N], s2[N], cnt[N];
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &t[i]);
		t[i] += 1;
	}
	sort(t + 1, t + n + 1);
	for (int i = 1; i <= n; i++)if (t[i] - t[i - 1] >= 2 * m) {
			int c = t[i] - t[i - 1] - 2 * m;
			for (int j = i; j <= n; j++)
				t[j] -= c;
		}
	int T = t[n] + m;
	for (int i = 1; i <= n; i++)cnt[t[i]]++;
	for (int i = 1; i <= T; i++) {
		s1[i] = s1[i - 1] + cnt[i];
		s2[i] = s2[i - 1] + i * cnt[i];
	}
	int ans = 1 << 30;
	for (int i = 1; i <= T; i++) {
		dp[i] = i * s1[i] - s2[i];
		for (int j = i - m; j >= 1 && j >= i - 2 * m + 1; j--)
			dp[i] = min(dp[i], dp[j] + i * (s1[i] - s1[j]) - (s2[i] - s2[j]));
		if (i >= t[n])ans = min(ans, dp[i]);
	}
	printf("%d", ans);
}
```

---


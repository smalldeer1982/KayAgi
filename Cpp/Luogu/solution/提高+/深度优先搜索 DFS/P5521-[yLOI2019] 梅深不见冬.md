# [yLOI2019] 梅深不见冬

## 题目背景

> 风，吹起梅岭的深冬；霜，如惊涛一样汹涌；  
> 雪，飘落后把所有烧成空，像这场，捕捉不到的梦。   
> 醒来时已是多年之久，宫门铜环才长了铁锈，也开始生出离愁。

——银临《梅深不见冬》

## 题目描述

扶苏从深冬的梅岭走出，来到了一棵有 $n$ 个节点的有根树上。

如果你不知道什么是树，可以认为树是一个边数恰好比节点个数少一的简单无向连通图。

如果我们规定 $x$ 是树 $T$ 的根，那么定义任意一个节点 $y$ 到根的路径就是从 $y$ 出发不重复经过节点到达 $x$ 所经过的所经过的点构成的点集。可以证明这样的点集有且仅有一个。

定义一个节点 $u$ 是节点 $v$ 的孩子，当且仅当 $u$ 与 $v$ 相连且 $u$ 不在 $v$ 到根的路径中。如果 $u$ 是 $v$ 的孩子，那么定义 $v$ 是 $u$ 的家长节点。

如果我是 @[\_rqy](https://www.luogu.org/space/show?uid=7868) 那种~~毒瘤~~神仙的话，可能会问你每个节点的孩子数不超过 $k$ 的 $n$ 个节点的带标号无根树一共有多少个，可惜这个问题我也不会，所以我不会问你这么毒瘤的问题。

扶苏从这棵 $n$ 个节点的树的 $1$ 号节点出发，沿着树上的边行走。当然我们规定 $1$ 号节点是这棵树的根。他所行走的规定是：当扶苏在节点 $u$ 时，扶苏要么在 $u$ 的孩子中选择一个**没有到达过**的节点 $v$ 并行走到 $v$，要么选择回到 $u$ 的家长节点。

现在给每个节点一个权值 $w$，其中 $i$ 号节点的权值为 $w_i$。他想给这棵树的某个节点放上从梅岭带出的梅花。我们规定扶苏能在节点 $u$ 放上梅花当且仅当满足如下条件：

> 扶苏当前在节点 $u$。
>
> 对于 $u$ 的所有孩子 $v$，节点 $v$ 被放上了 $w_v$ 朵梅花。

同时，扶苏可以在**任意时刻**收回**任意节点**上的梅花，在收回梅花时不需要走到对应节点。

现在扶苏想问问你，对于每个节点，如果他想在 $i$ 号节点上放 $w_i$ 朵梅花，那么他最少要从梅岭带出多少朵梅花。

## 说明/提示

#### 输入输出样例 1 解释

![qwq](https://cdn.luogu.com.cn/upload/pic/72286.png)

样例 1 的输入如上图，每个节点都需要放 $1$ 一朵梅花。

如果在 1 号节点放梅花，则从一号点运动到 2 号点，然后运动到 3 号点，在 3 号点上放一朵梅花，返回 2 号点，在 2 号点上放一朵梅花，同时收回三号点的梅花，然后返回 1 号点，将从 3 号点收回的梅花放到 1 号点即可。一共需要两朵梅花。

在 2、3 号节点放梅花的方案类似。

#### 输入输出样例 3 解释

![qwq](https://cdn.luogu.com.cn/upload/pic/72287.png)

样例 3 的输入如左图。

先从 1 号节点运动至 3 号节点，再运动至 5 号节点，在 5 号节点上放置 $12$ 朵梅花，然后返回 3 号节点，在 3 号节点上放置 $1$ 朵梅花，收回五号节点的 $12$ 朵梅花，返回 1 号节点。

然后运动到 2 号节点，通过 4 号节点运动到 6 号节点，放下 $15$ 朵梅花，返回 4 号节点放下 $5$ 朵梅花，此时树上有的梅花数为 $5 + 15 + 1 = 21$，分别在 4 号、6 号和 3 号节点上。然后收回 6 号节点的梅花，返回 2 号节点，放下 $14$ 朵梅花，收回 4 号节点的，返回 1 号节点，在 1 号节点上放置 $3$ 朵梅花，即可达到在 1 号节点上放梅花的目的。

可以验证最大花费为 $21$。其他节点的答案同理。

请注意，其他节点的答案不一定是按照该节点的运动路径行走得到的。

---

#### 数据规模与约定

| 测试点编号 |  $n = $  | 测试点编号 |  $n = $  |
| :--------: | :------: | :--------: | :------: |
|     1      |   $1$    |     11     | $100003$ |
|     2      |   $8$    |     12     | $100003$ |
|     3      |   $8$    |     13     | $100003$ |
|     4      |   $8$    |     14     | $100003$ |
|     5      |   $8$    |     15     | $100004$ |
|     6      | $100000$ |     16     | $100004$ |
|     7      | $100000$ |     17     | $100004$ |
|     8      | $100002$ |     18     | $100004$ |
|     9      | $100002$ |     19     | $100004$ |
|     10     | $100002$ |     20     | $100004$ |

- 对于测试点 5、6，满足特殊性质：每个节点的孩子结点个数不超过 $2$。
- 对于测试点 8 到测试点 10，满足特殊性质：每个节点的孩子节点个数不超过 $5$。
- 对于测试点 11 到测试点 14，满足特殊性质：任意一个节点到根的路径上的点数不超过 $3$，也即树高不超过 $3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^5 + 4,~1 \leq p_i \leq i,~1 \leq w_i \leq 1000$。

---

#### 提示

- $n$ 的末位数字可以帮助你快速的判断测试点所具有的的特殊性质。

## 样例 #1

### 输入

```
3 
1 2 
1 1 1```

### 输出

```
2 2 1```

## 样例 #2

### 输入

```
3
1 1
1 1 1```

### 输出

```
3 1 1```

## 样例 #3

### 输入

```
6
1 1 2 3 4
3 14 1 5 12 15```

### 输出

```
21 20 13 20 12 15```

# 题解

## 作者：一扶苏一 (赞：38)

# B [yLOI2019] 梅深不见冬

## Background

风，吹起梅岭的深冬；霜，如惊涛一样汹涌；雪，飘落后把所有烧成空，

像这场，捕捉不到的梦。

醒来时已是多年之久，宫门铜环才长了铁锈，

也开始生出离愁。

——银临《梅深不见冬》

## Description

给定一棵 $n$ 个节点的树，在树上行走，每次要么选择一个没有到达过的子节点，要么返回父节点。想要在一个节点 $u$ 放上梅花当且仅当 $u$ 的任意子节点 $v$ 都被放上了 $w_v$ 朵梅花。在任意时刻可以收回任意节点的梅花。对于每个节点，求如果想在这个节点放梅花，则至少需要准备多少梅花。

## Limitations

![qwq](https://cdn.luogu.com.cn/upload/pic/72292.png)

特殊性质1：每个节点的孩子结点个数不超过 $2$

特殊性质2：每个节点的孩子节点个数不超过 $5$

特殊性质3：任意一个节点到根的路径上的点数不超过 $3$，也即树高不超过 $3$

对于 $100\%$ 的数据，保证 $1 \leq w_i \leq 1000$

## Solution

测试点 $1$：

只有一个节点，输出 $w_1$ 即可。期望得分 $5~pts$

测试点 $2~\sim 5$：

爆搜一个行走的顺序，然后可以 $O(n)$ 判断是否合法。时间复杂度 $O(n!\times n)$，期望得分 $20~pts$

测试点 $6~\sim~7$：

注意到题目所规定的走法相当于按照树的某个dfs序走，即离开某个节点时必须遍历完它的子树，否则子树中一旦有一个节点没有被遍历到，则永远无法返回这个节点。

如果设在点 $u$ 上放上 $w_u$ 朵梅花最少需要 $ans_u$ 朵梅花的话，考虑对于 $u$ 的两个孩子 $x,~y$，如果先走 $x$，那么首先需要准备 $ans_x$ 朵梅花，放上了 $w_x$ 朵梅花，剩余了 $ans_x - w_x$  朵花，再走 $y$，需要准备 $ans_y$ 朵花，当前有 $ans_x - w_x$，则需要额外准备 $\max(ans_y - ans_x + w_x, 0)$ 朵花。先走 $y$ 的情况类似，比较一下哪种情况更优即可。

时间复杂度 $O(n)$，期望得分 $10~pts$

测试点 $8~\sim 10$：

孩子节点个数不超过 $5$，于是爆搜一下走哪个孩子的顺序，用类似子任务 $3$ 的方法统计，然后取最优的即可。

时间复杂度 $O(n \times x!)$，其中 $x$ 为最大的节点孩子个数。期望得分 $15~pts$

测试点 $11~\sim 14$：

树高不超过 $3$，考虑第 $3$ 层的节点，答案显然是他们自身的权值，第二层的节点，答案是第三层的权值和。

对于第一层的根节点 $u$，考虑放满他的孩子的花费和在这个节点上放梅花的花费的关系：

如果放满它的孩子花费为 $c$，它的孩子的权值和为 $W$，则会剩余 $rest = c - W$ 朵梅花，由于 $W$ 是个常量，$rest$ 与 $c$ 正相关。考虑当 $w_u > rest$  时，需要额外花费 $w_u - rest$ 元，花费为 $w_u - rest + rest = w_u$ 元，当 $w_u \leq rest$ 时，花费 $rest$ 元。由此可以发现，当 $rest$ 减小时，所需要的花费不会增大。又因为 $rest$ 与 $c$ 正相关，因此放满它的孩子的花费变低，在这个节点上放梅花的花费不会增加。因此最小化放满它孩子的花费即可得到答案。

对于一个节点 $x$，设往这个节点上放上梅花至少需要准备 $ans_x$ 朵梅花，而 $x$ 的权值为 $w_x$，我们的问题是选择一个最优的放梅花的序列，使得最终需要准备的梅花最小。这个问题的答案是按照 $ans_x - w_x$ 的不升序排序即可。

考虑证明这个结论：

设有两个节点 $i,~j$，设 $a_i = ans_i - w_i,~a_j = ans_j - w_j$ 且 $a_i > a_j$。

考虑先放 $i$ 再放 $j$ 需要准备的梅花朵数是 $\max(ans_i, ans_j + w_i)$（一式），同理先放 $j$ 所需要准备的梅花朵数是 $\max(ans_j, ans_i + w_j)$（二式）。

由于 $a_i = ans_i - w_i$，得 $ans_i = a_i + w_i$。$ans_j$ 同理。对一式二式分别提出 $w$。

则 

$$\text{一式} = \max(ans_i, ans_j + w_i) = \max(a_i + w_i, ans_j + w_i) = w_i + \max(a_i, ans_j)$$

$$\text{二式} = \max(ans_j,ans_i + w_j) = w_j + \max(a_j, ans_i) = w_j + \max(a_j, a_i + w_i) = w_j + a_i + w_i$$

考虑一式的 $\max$ 如果取 $a_i$，那么 $\text{一式} = w_i + a_i < w_i + a_i + w_j = \text{二式}$

如果取 $ans_j$，那么 $\text{一式} = w_i + w_j + a_j < w_i + w_j + a_i = \text{二式}$

因此，一式恒小于二式，先放 $i$ 更优。

据此做数学归纳可得，按照 $ans - w$ 的不升序排序后的序列是最优的。

于是即可排序以后用上面的方式统计答案，时间复杂度 $O(n \log n)$，期望得分 $20~pts$

测试点 $15~\sim 20$：

发现上面的结论可以应用于这棵树上的任何一个节点，于是每个节点都按照这样的方法排序即可。时间复杂度 $O(n \log n)$，期望得分 $30 pts$。

## Code

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>

const int maxn = 100010;

int n;
int MU[maxn], ans[maxn];
std::vector<int>son[maxn];

void dfs(const int u);
bool cmp(const int &_a, const int &_b);

int main() {
  scanf("%d", &n);
  for (int i = 2, x; i <= n; ++i) {
    scanf("%d", &x);
    son[x].push_back(i);
  }
  for (int i = 1; i <= n; ++i) {
    scanf("%d", MU + i);
  }
  dfs(1);
  for (int i = 1; i < n; ++i) {
    printf("%d ", ans[i]);
  }
  printf("%d\n", ans[n]);
  return 0;
}

void dfs(const int u) {
  for (auto v : son[u]) {
    dfs(v);
  }
  std::sort(son[u].begin(), son[u].end(), cmp);
  int _ret = 0;
  for (auto v : son[u]) {
    if (_ret >= ans[v]) {
      _ret -= MU[v];
    } else {
      ans[u] += ans[v] - _ret;
      _ret = ans[v] - MU[v];
    }
  }
  ans[u] += std::max(0, MU[u] - _ret);
}

inline bool cmp(const int &_a, const int &_b) {
  return (ans[_a] - MU[_a]) > (ans[_b] - MU[_b]);
}
```

---

## 作者：赵旭芃 (赞：31)

## 这个题出的还是很好的
就不说暴力了，直接上正解吧
这个题n是1e5 , 所以复杂度肯定是nlogn或者o(n), 但是仔细想想发现o（n）好像做不了这个题(也可能是我太菜了)， 那么我们考nlogn做法

用手模一模样例我们可以发现，树上的叶子节点的答案就是它自己的权值，而对于树上非叶子节点，他的答案可以由它儿子的答案推出来， 也就是说要想知道一个点的答案 ，那么我们事先必须要知道这个点所有儿子的答案 ， 这种处理问题顺序不是很像dfs吗？ 所以大体思路上我们用dfs解决

现在我们需要考虑的是由一个点的儿子的答案怎么推出它自己的答案 ，我们定义一个结构体，a[i].ans表示这个点的答案，a[i].w表示题目中输入的这个点的权值，因为我们走到一个点时，在我们把这个点所需要的梅花放完后，我们可以立刻把这个点的所有孙子（如果有的话）的梅花都收回来，所以假如这个点的子树是一条链的话，那么答案就是其下面（包括自身）连续两个点权值和的最大值，这是简单情形。

而假如这个点的子树非常庞大，那么我们考虑，如果假设我们放完了前i个儿子，得到了当前最优值为sum，那么我们分析接下来放哪一个儿子可以使答案还保持放完前i+1个儿子的最优，所以我们需要对放的顺序进行更改，也就是说，我们需要对儿子数组进行排序。

**sum+a[i].w+a[i+1].ans<sum+a[i+1].w+a[i].ans**

**整理得：**

**a[i].w-a[i].ans<a[i+1].w-a[i+1].ans**

也就是说只要满足按x.w-x.ans从小到大排序，这样顺着取答案一定是最优的，那么我们预处理每个点的儿子个数，dfs到每个点开一个同样大小的数组，然后如此排序，接下来算答案就好了


这样就愉快的AC了

最后附上热腾腾的代码

```c
#include<bits/stdc++.h>
using namespace std;
struct re
{
    int nxt,to;
}edge[200010];
struct st
{
    int w,ans;
}a[100020];
int n,m,x,num,head[100010],tot[100010];
void add(int from,int to)
{
    edge[++num].to=to;
    edge[num].nxt=head[from];
    head[from]=num; 
}
bool cmp(st a,st b)
{
     return a.w-a.ans<b.w-b.ans;    
}
void dfs(int u,int father)
{
    int len=0,bj=0;
    int sum=0;
    st b[tot[u]+10];//数组多开大一些 
    memset(b,0,sizeof(b));
    for(int i=head[u];i;i=edge[i].nxt)
    {
      int v=edge[i].to;
      if(v==father)continue;
      dfs(v,u); 
      bj=1; 
      b[++len].w=a[v].w;
      b[len].ans=a[v].ans;
      sum+=a[v].w;
    }
    if(!bj)//叶子节点答案直接赋成它本身就好了 
    a[u].ans=a[u].w; 

    else 
    {
     sum+=a[u].w;//这个这个点答案的最小值 
     sort(b+1,b+1+len,cmp);
     int now=0;
     for(int i=1;i<=len;i++)
     {
     a[u].ans=max(a[u].ans,now+b[i].ans);
     now+=b[i].w;
     a[u].ans=max(a[u].ans,sum);    
     }          
    }  
}
int main()
{   
     scanf("%d",&n);    
     for(int i=1;i<n;i++)
     {
     scanf("%d",&x);
     add(x,i+1);
     add(i+1,x);
     }  
     for(int i=1;i<=n;i++)
     scanf("%d",&a[i].w);

     for(int i=1;i<=n;i++)//儿子个数 
     {
      for(int j=head[i];j;j=edge[j].nxt)  
      {
        int v=edge[j].to;
        tot[i]++;   
      } 
      tot[i]--;     
     }

     dfs(1,0);
     for(int i=1;i<=n;i++)
     printf("%d ",a[i].ans);    

     return 0;
} 
```


---

## 作者：ep938936 (赞：16)

这道题很容易可以看出是一个dfs解决的,所以我们只需考虑对于某个结点,如何在已知所有子节点的答案的前提下求出当前点的答案

我们用$w_i$表示节点i要放置的花数,$ans_i$表示节点i的答案

因为要在某个点放花需要将它的子节点全部放满,所以需要的花数至少是当前点的W+所有子节点的W

但是,我们考虑在所有子节点放花的过程,这有一个顺序,当要在一个子节点i放花的时候,我们手上需要有至少$ans_i$朵花,而且,在这个子节点之前的其他子节点上也要有花

所以,假设当前节点有n个子节点,那么,放置第k个子节点时的总花数为
$\sum\limits_{i=1}^{k-1}w_i+ans_k$
由于所有子节点都要放花,所以放完所有子节点需要的花数就是放置每个结点的最大值,即$\max\limits_{k=1\to n}(\sum\limits_{i=1}^{k-1}w_i+ans_k)$,再加上当前节点的w值就是当前节点的答案了

我们现在的任务就是,求出一种子节点的访问顺序,使得上面的这个最大值最小

事实上,这个顺序就是对每个子节点按照$ans-w$从大到小的顺序排序,得到的顺序就是访问顺序

这个贪心的结论可以类比noip2012的"国王游戏"这道题

证明方法见下图

![](https://cdn.luogu.com.cn/upload/pic/75993.png)
![](https://cdn.luogu.com.cn/upload/pic/75995.png)

有了这个关键的贪心结论之后,我们就可以解题了:求出所有子节点的答案后,将子节点按照$ans-w$的顺序排序,然后求出放置所有子节点的值,加上当前节点的w即求出当前节点的答案

代码如下:(这里使用了vector来储存边,方便排序,如果不希望使用STL可以用前向星)
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
int n,w[100005],ans[100005];
struct edge{
	int to;
	int cp;//ansi-wi
	bool operator>(edge v){
		return cp>v.cp;
	}
};
bool cmp(edge &a,edge &b){
	return a>b;
}
vector<edge> po[100005];
inline int max(int a,int b){
	return a>b?a:b;
}
void dfs(int v){
	int i,j,res=0,sw=w[v];
	for(i=0;i<po[v].size();i++){
		dfs(po[v][i].to);
		po[v][i].cp=ans[po[v][i].to]-w[po[v][i].to];
		sw+=w[po[v][i].to];
	}
	if(po[v].size()>0) sort(po[v].begin(),po[v].end(),cmp);
	res=sw;
	sw=0; 
	for(i=0;i<po[v].size();i++){
		res=max(res,sw+ans[po[v][i].to]);
		sw+=w[po[v][i].to];
	}
	ans[v]=res;
}

int main(){
	register int i,a;
	scanf("%d",&n);
	for(i=1;i<=n;i++) po[i].clear();
	for(i=2;i<=n;i++){
		scanf("%d",&a);
		edge p;
		p.to=i;p.cp=0;
		po[a].push_back(p);
	}
	for(i=1;i<=n;i++) scanf("%d",w+i);
	dfs(1);
	for(i=1;i<=n;i++) printf("%d ",ans[i]);
}
```


---

## 作者：Ofnoname (赞：13)

做自闭了。

因为需要将子节点放完后才能放自己，所以放置应该自顶向上，在自己被放置后，就可以将所有儿子拆除了。

对于叶节点，答案显然是自己的`w`值，记答案为`ans`。

如果不是叶节点，答案需要由多个儿子的节点合并而来。设`x`是当前节点，`y`是子节点。`1...m`是子树的遍历顺序。

一种答案是，所有子节点都无法剩下一颗多的石子，那么答案是$w[x] + \sum{w[y]}$。

或者由其中一颗子树剩下的石子（即`ans[i]-w[i]`，需要的石子数减去实际用掉的就是可以回收的）分给之后要遍历的子树，那么这个时候的答案，就是 $\sum_{k=1}^{i-1} w[k] + ans[i]$，意思就是前$[1,\ i)$的子树不变，但是$[i,\ m]$的子树和`x`点全部用$w[k]$省下的石子支付。这个`i`可以任意取，其中最大值就是答案。

现在，我们还应调整`1..m`的遍历顺序，使这个值最大，我们把子树按`ans[i] - w[i]`从大到小排就可以了。口胡证明：若之前已经选择`sum`，现在要在`i`和`i+1`之间做出选择，答案分别为`sum + ans[i+1] + w[i]`和`sum + ans[i] + w[i+1]`，那么两边移项就是`ans[i+1] - w[i+1]`和`ans[i] - w[i]`，也就是说要选`ans[] - w[]`较大的，那么按照`ans[] - w[]`从大到小排序，并用`sum`维护一下`w[]`的前缀和就可以快速解决。

```cpp
#include <bits/stdc++.h>
#define MAX (100000 + 7)
using namespace std;

int N, w[MAX], ans[MAX];
vector <int> son[MAX];

int cmp(int a, int b) {return ans[a] - w[a] > ans[b] - w[b];}
//按照ans[] - w[]排序 

#define y son[x][p]
void DFS(int x)
{
	ans[x] = w[x];
	for (int p = 0; p < son[x].size(); p++)
		DFS(y), ans[x] += w[y];//求出第一种答案（所有w相加） 
	sort(son[x].begin(), son[x].end(), cmp);//排序出儿子节点遍历顺序 
	for (int p = 0, sum = 0; p < son[x].size(); p++)
		ans[x] = max(ans[x], ans[y] + sum), sum += w[y];//求出第二种答案 
}
#undef y

int main()
{
	scanf("%d", &N);
	for (int i = 2, x; i <= N; i++)
		scanf("%d", &x), son[x].push_back(i);
	for (int i = 1; i <= N; i++)
		scanf("%d", &w[i]);
	DFS(1);
	for (int i = 1; i <= N; i++)
		printf("%d ", ans[i]);
}
```

---

## 作者：lyx1311 (赞：9)

## P5521 [yLOI2019] 梅深不见冬
记在 $i$ 节点放置雪花的最小花费为 $f_i$ ，$i$ 节点的权值为 $w_i$ 。因为 $f_u=\max\{\max\limits_{v\in\text{son}(u)}\{f_v+\sum\limits_{k\in\text{son}(u)~\land~k\text{ before }v}w_k\},w_u+\sum\limits_{v\in\text{son}(u)}w_v\}$ ，我们要求出最优的一种排列使得该式的值最小。

考虑对子节点如何贪心排序。$u$ 如果仅有两个子节点 $x,y$（微扰法证明贪心）：不交换时（即 $x\rightarrow y$ ），$f_u=\max\{f_x,f_y+w_x\}$ ；交换后（即 $y\rightarrow x$ ），$f_u=\max\{f_y,f_x+w_y\}$ 。前者更优则有 $\max\{f_x,f_y+w_x\}\le\max\{f_y,f_x+w_y\}$ 。讨论：

1. 假设左侧取 $f_y+w_x$ ，因为 $f_y+w_x>f_y$ ，所以右侧取 $f_x+w_y$ 才可能使式子成立。$f_y+w_x\le f_x+w_y$ ，可推出 $f_x-w_x\ge f_y-w_y$ 。

2. 假设左侧取 $f_x$ ，因为 $f_x+w_y>f_x$ ，所以无论右侧如何取值该式均成立。

综上，贪心排序的策略为：将 $f_x-w_x$ 大者放前面。时间复杂度 $O(n\log n)$ 。



---

## 作者：Code_星云 (赞：5)

对于某个节点，很明显，要使答案最优的话，当要往父节点走时，一定会把子节点的花收集起来。然后我们考虑遍历顺序。由于上面这个结论，我们思考能不能先遍历子节点贡献值（即收集的花）最大的子节点呢？又由于该点必须保留，所以我们按照 $ans_u - p_u$ 从大到小排序。（其中 $ans_u$ 表示该节点的答案，$p_u$ 表示权值）然后再按照顺序依次遍历，统计答案即可。

证明：

先假设一个节点 $u$ 只有两棵子树 $v1, v2$。如果先走 $v1$，那么答案为 $\max(ans_1, ans_2 +w_1)$；否则答案为 $\max(ans_2, ans_1 + w_2)$。

假设 $\max(ans_1, ans_2 +w_1) < \max(ans_2, ans_1 + w_2)$。

那么有 $ans_2 + w_1 < \max(ans_2, ans_1 + w_2)$。因为 $w_1 > 0$，所以 $ans_2 + w_1 > ans_2$，所以必有 $ans_1 + w_2 = \max(ans_2, ans_1 + w_2)$，因此 $ans_2 + w_1 < ans_1 + w_2$，即 $ans_1 - w_1 > ans_2 - w_2$。

然后可以用数学归纳法推广到多颗子树。证毕。


对于这种树上贪心，几乎都是找最优子树遍历顺序，比较套路。
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<vector>
using namespace std;
#define pb push_back

const int N = 100100;
int n;
vector<int> g[N];
int p[N], ans[N];

bool cmp(int x, int y){
	return ans[x] - p[x] > ans[y] - p[y];
}
void dfs2(int u){
	if(! g[u].size()){
		ans[u] = p[u];
		return;
	}
	int res = 0;
	for(int i = 0; i < g[u].size(); i ++){
		int v = g[u][i]; dfs2(v);
	}
	sort(g[u].begin(), g[u].end(), cmp);
	for(int i = 0; i < g[u].size(); i ++){
		int v = g[u][i];
		if(res >= ans[v]){
			res -= ans[v];
			res += ans[v] - p[v];
		}else{
			ans[u] += ans[v] - res;
			res = ans[v] - p[v];
		}
	}
	if(res < p[u]) ans[u] += p[u] - res;
}
int main(){
	scanf("%d", &n);
	for(int i = 2; i <= n; i ++){
		int fa; scanf("%d", &fa);
		g[fa].pb(i);
	}
	for(int i = 1; i <= n; i ++) scanf("%d", &p[i]);
	dfs2(1);
	for(int i = 1; i <= n; i ++) printf("%d ", ans[i]);
	puts("");
	return 0;
}
```


---

## 作者：Jsxts_ (赞：4)

邻项交换练习题。

考虑一个点只有两个儿子，如何安排顺序使得答案最优。

设两个儿子分别为 $x,y$，$f_i$ 为 $i$ 的答案。

那么如果 $x$ 在前， $y$ 在后，则在遍历 $y$ 的子树时，之前必须花费 $w_x$ 的花去覆盖 $x$，贡献为 $w_x+f_y$，同理 $y$ 在前、$x$ 在后贡献为 $w_y+f_x$，我们要使答案最小，那么就是让贡献尽量小，则排序函数为 $w_x+f_y<w_y+f_x$。这个函数满足传递性与不可比性的传递性（具体怎么证我也不会，这里有一篇写得不错的文章 [浅谈邻项交换排序的应用以及需要注意的问题](https://ouuan.github.io/%E6%B5%85%E8%B0%88%E9%82%BB%E9%A1%B9%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/)），可以直接用。

考虑把 $x$ 的子树排好序后，如何计算 $x$ 的答案。

首先，答案至少为 $w_x+\sum_{v\in son(x)}w_v$，之后依次遍历每个儿子，这个儿子的贡献为之前儿子的 $w$ 之和加上这个子树内 $f$ 的最大值（画图理解），维护一个 $g_x$ 表示 $x$ 子树内 $f$ 的最大值即可。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int inf = 2e9;
int read() {
	int s = 0,f = 1;char ch = getchar();
	while (!isdigit(ch)) f = ch == '-' ? -1 : 1, ch = getchar();
	while (isdigit(ch)) s = s * 10 + ch - '0', ch = getchar();
	return s*f;
}
void write(int x) {
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) write(x / 10);
	putchar(x % 10 + 48);
}
vector<int> vc[100010];
void add(int u,int v) {
	vc[u].push_back(v);
}
int w[100010],f[100010],g[100010];
int cmp(int x,int y) {
	return w[x] + f[y] < w[y] + f[x];
}
void dfs(int x) {
	for (int i = 0;i < vc[x].size();i ++ ) {
		int v = vc[x][i];
		dfs(v);
		g[x] = max(g[x],g[v]);
	}
	sort(vc[x].begin(),vc[x].end(),cmp);
	int s = 0;
	for (int i = 0;i < vc[x].size();i ++ )
		f[x] = max(f[x],s + g[vc[x][i]]), s += w[vc[x][i]];
	f[x] = max(f[x],s + w[x]);
	g[x] = max(g[x],f[x]);
}
int main() {
	int n = read();
	for (int i = 2;i <= n;i ++ ) {
		int x = read(); add(x,i);
	}
	for (int i = 1;i <= n;i ++ ) w[i] = read();
	dfs(1);
	for (int i = 1;i <= n;i ++ ) printf("%d ",f[i]);
	return 0;
}
```


---

## 作者：PanH (赞：2)

挺有意思的一道题。

感觉做法是 **DP+贪心**

~~题目读了好久~~

## 做法

记一个数组 $f[i]$ 表示在 $i$ 点放上梅花时需要的梅花数。

于是可以考虑转移。

为了在 $i$ 放梅花，考虑每一种可能出现的放梅花的情况。

**如果已经在点 $j$ 放了梅花，显然都把其子孙节点的梅花收走。**

~~接下来不知道说什么了。~~

然后有一个 DP 柿子：

$son_{i,j}$ 表示 $i$ 的第 $j$ 个儿子。

$$f[i]=\max(w[i]+\sum{w[son_{i}]},\max\{f[son_{i,j}]+\sum_{k=1}^{k<j} w[son_{i,k}]\})$$

发现有个问题，$i$ 的儿子的排列顺序是不固定的。

问题转化为：

对序列重新确定顺序，使得 $\max \{f[i]+\sum_{j=1}^{j<i}w[j]\}$ 最小。

~~看上去像二分~~

可以考虑贪心，对于一个 $i$ 与一个与之相邻的 $j$ ，如果 $i$ 在前更优，则应有：（$sum$ 是 $i,j$ 之前的 $w[i]$ 的和）

$$\max(sum+f[i],sum+w[i]+f[j])\le \max(sum+f[j],sum+w[j]+f[i])$$

发现 $sum$ 和最终的相对大小无关，去掉。

$$\max(f[i],w[i]+f[j])\le \max(f[j],w[j]+f[i])$$

因为

$$f[i]\le f[i]+w[j]$$
$$f[j]\le f[j]+w[i]$$

所以 ~~yy 一下~~ 可以知道最终的大小只和 $f[j]+w[i]$ 与 $f[i]+w[j]$ 有关。
最后的柿子可以化为：

$$f[j]-w[j]\le f[i]-w[i]$$

按照这个写一个 cmp 函数即可。

**实现的时候由于 $1≤p_i≤i$ 可以不用 dfs，从后往前做即可。**

code:
```
#include<bits/stdc++.h>
using namespace std;
template<class T>inline void read(T &x)
{
	x=0;int f=0;char ch=getchar();
	while(!isdigit(ch))	f=ch=='-',ch=getchar();
	while(isdigit(ch))	x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	x=f?-x:x;
}
const int N=1e5+5;
vector<int> son[N];
int n,m,w[N],f[N];
bool cmp(int x,int y) {return f[y]-w[y]<f[x]-w[x];}
int main()
{
	read(n);
	for(int i=2,fa;i<=n;i++) read(fa),son[fa].push_back(i);
	for(int i=1;i<=n;i++) read(w[i]);
	for(int i=n;i;i--)
	{
		sort(son[i].begin(),son[i].end(),cmp);
		int sum=0;
		for(auto x:son[i]) f[i]=max(f[i],f[x]+sum),sum+=w[x];
		f[i]=max(sum+w[i],f[i]);
	}
	for(int i=1;i<=n;i++) printf("%d ",f[i]);
	return 0;
}
```


---

## 作者：tsqtsqtsq0309 (赞：1)

[更好的阅读体验](https://www.cnblogs.com/tsqtsqtsq/p/17822232.html)

一道比较不错的思维题。

对于树上的每一个节点，我们考虑设节点 $i$ 要放 $w_i$ 朵梅花，如果从梅岭带出 $ans_i$ 朵梅花，就在节点 $i$ 上放 $w_i$ 朵梅花。

具体地，有以下两种情况：

第一种情况，梅花直接放所有子节点再放父节点。则易知 $w_i+\sum w_j$。

第二种情况，如果已经在节点 $j$ 放了梅花，显然都会将其子节点的梅花收走。那么放一个子节点的花费为： 
$$
\displaystyle\sum_{j=1}^{k-1}w_i+ans_k
$$
因为要放所有子节点，所以取其最大值。则有：
$$
ans_i=\max\left\{w_i+\sum w_j,\max_{k=1\rightarrow n}\left\{\sum_{j=1}^{k-1}w_j+ans_k\right\}\right\}
$$
注意到 $ans_i$ 与子节点顺序有联系，那么就需要排序。

这里给出结论：直接按 $ans_i-w_i$ 从大到小排序。

证明：

设两个节点 $i$，$j$ 相邻，且交换前的值是 $\max\left\{ans_j+w_i,ans_i\right\}$，交换后的值是 $\max\left\{ans_i+w_j,ans_j\right\}$。

若满足条件 $ans_i-w_i>ans_j-w_j$，则有 $ans_j+w_i<ans_i+w_j$。

因为 $w\in\N^+$，所以有：
$$
\begin{cases}
ans_j+w_i>ans_j \\
ans_i+w_j>ans_i \\
ans_j+w_i>ans_i \\
\end{cases}
$$
显然原顺序优于交换顺序。

证毕。

至于时间复杂度的话，设树上每一个节点与 $m$ 个节点相邻，则总的时间复杂度为 $O(nm\log n)$，可以通过本题（或许可以钦定为 $O(n)$？）。

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#define MAXN 100005
using namespace std;
int n, p;
struct edge{int w, to, nxt;}e[MAXN << 1];
int head[MAXN], cnt = 1;
struct node{
	int ans, w;
	bool friend operator<(node a, node b){
		return a.ans - a.w > b.ans - b.w;
	};
}a[MAXN];
int read(){
	int t = 1, x = 0;char ch = getchar();
	while(!isdigit(ch)){if(ch == '-')t = -1;ch = getchar();}
	while(isdigit(ch)){x = (x << 1) + (x << 3) + (ch ^ 48);ch = getchar();}
	return x * t;
}
void write(int x){
	if(x < 0){putchar('-');x = -x;}
	if(x >= 10)write(x / 10);
	putchar(x % 10 ^ 48);
}
void add(int u, int v, int w){
	cnt++;e[cnt].to = v;e[cnt].nxt = head[u];head[u] = cnt;
}
void dfs(int now){
	vector <node> tmp;tmp.clear();a[now].ans = a[now].w;
	for(int i = head[now] ; i != 0 ; i = e[i].nxt){
		int v = e[i].to;dfs(v);
		tmp.push_back(a[v]);
		a[now].ans += a[v].w;
	}
	sort(tmp.begin(), tmp.end());int tot = 0;
	for(int i = 0 ; i < tmp.size() ; i ++){
		a[now].ans = max(a[now].ans, tmp[i].ans + tot);
		tot += tmp[i].w;
	}
}
int main(){
	n = read();
	for(int i = 2 ; i <= n ; i ++)p = read(),add(p, i, 0);
	for(int i = 1 ; i <= n ; i ++)a[i].w = read();
	dfs(1);
	for(int i = 1 ; i <= n ; i ++){
		if(i != 1)putchar(' ');
		write(a[i].ans);
	}
 	putchar('\n');return 0;
}
```

---

## 作者：cosf (赞：1)

## [P5521](https://www.luogu.com.cn/problem/P5521) 梅深不见冬

## 思路

看到树，看到每个孩子只能走一遍，看到每个节点只与它的字节点有关，容易想到用树形 DP。

具体地，对于任意一个节点 $p$，我们需要先给它的所有字节点放上对应的 $w$ 朵梅花，然后给 $p$ 放上 $w_p$ 朵，然后把子节点上的梅花全部回收。这里令 $r_p$ 表示最后的答案。

此时的难点就在于如何确定子节点的访问顺序。

我们假设存在访问顺序相邻的两个子节点 $i, j$，若 $i$ 在 $j$ 前，那么 $i$ 对 $r_p$ 的贡献是 $W + r_i$，$j$ 对 $r_p$ 的贡献是 $W+ w_i + r_j$，这里的 $W$ 是它们之前的子节点的 $w$ 和。相反，$i$ 在 $j$ 后的话两个贡献分别是 $W + w_j + r_i$ 和 $W + r_j$。注意到 $W + w_i + r_j \gt W + r_j, W + w_j + r_i \gt W + r_i$，所以我们需要比较的就是 $W + w_i + r_j$ 和 $W + w_j + r_i$。稍微化简一下就是：如果 $i$ 在前更优的话，必须满足 $r_i - w_i \ge r_j - w_j$。按照这个条件排序一下就是最终的子节点访问顺序了。

那么整体的做法就出来了。总复杂度为 $O(n\log n)$。

## 代码

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

#define MAXN 100010

using ll = long long;

vector<int> s[MAXN];

ll w[MAXN];
ll r[MAXN];

void dfs(int p)
{
    if (!s[p].size())
    {
        r[p] = w[p];
        return;
    }
    for (int c : s[p])
    {
        dfs(c);
    }
    sort(s[p].begin(), s[p].end(), [](int a, int b)
         { return r[a] - w[a] > r[b] - w[b]; });
    ll m = 0;
    for (int c : s[p])
    {
        m += r[c];
        r[p] = max(r[p], m);
        m -= r[c];
        m += w[c];
    }
    r[p] = max(r[p], m + w[p]);
}

int main()
{
    int n;
    cin >> n;
    for (int i = 2; i <= n; i++)
    {
        int f;
        cin >> f;
        s[f].push_back(i);
    }
    for (int i = 1; i <= n; i++)
    {
        cin >> w[i];
    }
    dfs(1);
    for (int i = 1; i <= n; i++)
    {
        cout << r[i] << ' ';
    }
    cout << endl;
}

```


---

## 作者：strange757 (赞：1)

这确实是一道很好的思维题，在仔细研究了一下之后，想从与其他题解不同的角度对这道题进行分析。


------------
相信大家都已经知道本题应该按 $ ans_i - w_i $  升序排序了，证明过程其他题解也已经写的很详细了，这里我感性的帮助大家理解一下。

首先按照 $ ans_i - w_i $ 排序可以理解为浪费梅花数量由多到少的路径排序。
![](https://cdn.luogu.com.cn/upload/image_hosting/k2ns11h6.png)


如图所示，假设从 1 号节点排完序的路径是按照蓝色，绿色，红色顺序走的。可以发现每条路都走了上一条路中根节点的子节点，而答案只需要找到其中最大的一条路就可以。那么越早走的路径，它的所包含的子节点就越少，那么让浪费大的路径先走，就可以保证浪费大的路径权值尽可能的小。

所以排完序之后的顺序就是走的路径顺序，浪费大的先走，浪费小的后走，最后统计所有路径中的最大值即为答案。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 1e5 + 5;
int n, f[N], fa, w[N];
int head[N], tot;
struct node{
    int next, to;
}edge[N<<1];
void add(int u, int v){
    tot++;
    edge[tot].next = head[u];
    edge[tot].to = v;
    head[u] = tot;
}
bool cmp(int a, int b){
    return f[a] - w[a] > f[b] - w[b];
}
void dfs(int u){
    f[u] += w[u];
    int sum = 0, num = 0, s[N];
    for(int i = head[u]; i; i = edge[i].next){
        int v = edge[i].to;
        dfs(v);
        f[u] += w[v];
        s[++num] = v;
    }
    sort(s + 1, s + 1 + num, cmp);
    for(int i = 1; i <= num; i++){
        f[u] = max(f[u], f[s[i]] + sum);
        sum += w[s[i]];
    }
}
int main(){
    scanf("%d", &n);
    for(int i = 2; i <= n; i++){
        scanf("%d", &fa);
        add(fa, i);
    }
    for(int i = 1; i <= n; i++) scanf("%d", &w[i]);
    dfs(1);
    for(int i = 1; i <= n; i++) printf("%d ", f[i]);
    return 0;
}
```

---

## 作者：_l_l_ (赞：1)

[题目](https://www.luogu.com.cn/problem/P5521)

这道题使用 dp 和贪心。

以下内容的 $v$ 皆为 $u$ 的儿子之一，如果有下标则是为了区分不同的儿子。

首先考虑一下怎样放置梅花，由于题面说过进入儿子节点需要保证该儿子节点没有遍历过，即儿子节点一旦返回了父亲节点，则无法再回来。

所以假设当前节点为 $u$，则先遍历其儿子节点，使得所有的儿子节点都已经放了 $w_{v}$ 朵梅花，最后在 $u$ 放置 $w_u$ 朵梅花，并将儿子节点的梅花全部回收。

则我们可以定义 $dp_u$ 为**只考虑 $u$ 子树的范围内**，使用梅花的**峰值**。

容易写出转移方程：

$$dp_u=\max_{i=1}^{|v|}(\sum_{j=1}^{i-1}(w_{v_j})+dp_{v_i})$$

问题在于设定遍历儿子节点的顺序。

考虑贪心：

假设我们现在只有两个儿子 $v_1,v_2$，考虑两种排列方案：

1. $\max(dp_{v_1},w_{v_1}+dp_{v_2})$
2. $\max(dp_{v_2},w_{v_2}+dp_{v_1})$

假设第一种更优，即：

$$\max(dp_{v_1},w_{v_1}+dp_{v_2}) < \max(dp_{v_2},w_{v_2}+dp_{v_1})$$

那么

$$dp_{v_1} < \max(dp_{v_2},w_{v_2}+dp_{v_1})\text{ 且 }w_{v_1}+dp_{v_2}<\max(dp_{v_2},w_{v_2}+dp_{v_1})$$

由于 $w,dp$ 都为正整数，所以

$$dp_{v_1} < w_{v_2} + dp_{v_1}$$

所以

$$dp_{v_1}<\max(dp_{v_2},w_{v_2}+dp_{v_1})$$

考虑

$$w_{v_1}+dp_{v_2}<\max(dp_{v_2},w_{v_2}+dp_{v_1})$$

又因为

$$w_{v_1}+dp_{v_2}>dp_{v2}$$

所以

$$w_{v_1}+dp_{v_2}<w_{v_2}+dp_{v_1}$$

整理一下

$$w_{v_1}-dp_{v_1}<w_{v_2}-dp_{v_2}$$

因此当上式成立时，第一种方案更优。

归纳一下，当 $\forall1\le i\le|v|-1,w_{v_i}-dp_{v_i}<w_{v_{i+1}}-dp_{v_{i+1}}$ 时最优。

由于每一个节点只可能作为至多一个节点的儿子，所以可以直接排序，时间复杂度 $O(n\log_2n)$

代码：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int MAXN = 100050;
struct edge {
	int to, nxt;
} edges[MAXN];
int head[MAXN], w[MAXN], tot;
void add(int u, int v) {
	edges[++tot].to = v; edges[tot].nxt = head[u]; head[u] = tot;
}
int dp[MAXN];
void dfs(int u, int f) {
	int cnum = 0;
	static int sorttmp[MAXN];
	for (int i = head[u]; i; i = edges[i].nxt) {
		if (edges[i].to == f) continue;
		dfs(edges[i].to, u);
	}
	for (int i = head[u]; i; i = edges[i].nxt) {
		if (edges[i].to == f) continue;
		cnum++;
		sorttmp[cnum] = edges[i].to;
	}
	sort(sorttmp + 1, sorttmp + 1 + cnum, [](int x, int y) {
		return w[x] - dp[x] < w[y] - dp[y];
	});
	int sum = 0;
	for (int i = 1; i <= cnum; i++) {
		dp[u] = max(dp[u], sum + dp[sorttmp[i]]);
		sum += w[sorttmp[i]];
	}
	dp[u] = max(dp[u], sum + w[u]);
}
int main() {
	int n;
	scanf("%d", &n);
	for (int i = 2; i <= n; i++) {
		int f;
		scanf("%d", &f);
		add(f, i);
	}
	for (int i = 1; i <= n; i++) {
		scanf("%d", &w[i]);
	}
	dfs(1, 1);
	for (int i = 1; i <= n; i++) {
		printf("%d%c", dp[i], " \n"[i == n]);
	}
	return 0;
}
```

---

## 作者：7KByte (赞：1)

思维好题。

读完题面，大概明白操作过程。要放点$X$，就必须先把$X$的子节点放满。所以我们先搞定子节点，然后放节点$X$,再把子节点的花回收。这样花可以重复利用，答案会更优。

显然，解决$X$和单独解决$X$的一个子节点是相同的问题，我们递归解决。

但很快我们发现答案只是相对较优，不是最优。问题出在按照怎样的顺序搞定$X$的子节点。

如果我们要搞定一个节点，总共需要$Sum$朵花，能够回收$Res$朵花。显然我们先处理$Res$大的节点。因为该节点一定要$W_i$朵花，总共至少花$\sum W$花不变。但是$Res$大的节点回收的花多，这一部分可以重复利用，答案只会更优。所以我们按$Res$排序，按排序后的顺序进行处理。

知道了处理顺序，我们只用再按照顺序模拟一下即可得出需要多少朵花。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define N 100010
using namespace std;
vector<int>a[N];
int n,c[N];
int f[N];
bool cmp(int x,int y){
	return c[x]<c[y];
}
typedef pair<int,int> P;
int dfs(int x){
	if(!a[x].size()){f[x]=c[x];return 0;}
	int s=a[x].size();
	vector<P>v;
	for(int i=0;i<s;i++){
		int y=a[x][i];
		int now = dfs(y);
		v.push_back(make_pair(now,c[y]));
	}
	sort(v.begin(),v.end());
	int tot=0,res=0;
	for(int i=s-1;i>=0;i--){
		int x=v[i].first,y=v[i].second;
		if(res<x+y){
			tot+=x+y-res;
			res=x;
		}
		else res-=y;
	}
	if(res<c[x])tot+=c[x]-res;
	f[x]=tot;
	return tot-c[x];
}
int main(){
	scanf("%d",&n);
	rep(i,2,n){
		int x;scanf("%d",&x);
		a[x].push_back(i);
	}
	rep(i,1,n)scanf("%d",&c[i]);
	dfs(1);
	rep(i,1,n)printf("%d ",f[i]);
	return 0;
}
```

---

## 作者：_ZSR_ (赞：0)

### [P5521 [yLOI2019] 梅深不见冬](https://www.luogu.com.cn/problem/P5521)

显然，对于每一个叶节点，答案就是 $w_i$。接下来考虑叶节点以上的节点。对于一个节点，如果已经在它上面放了花，那么就可以拿走所有放在它的子节点上的花。大概推测一下，答案就是在不断地放花和收花的过程中，某一时刻放在节点上的花的数量的最大值。

那么这个最大值怎么求呢？我们发现，对于一个节点，如果放在它的子节点上的花的数量很多，那么收回来也很多，也就可以去放在更多其他的节点上。这样的话，我们就需要一个放花的顺序。

我们记 $ans_i$ 为要在一个节点上放 $w_i$ 枝花所需要的总花数，假设当前枚举到节点 $u$，$x,y$ 为 $u$ 的两个子节点。如果先选择放好 $x$，那么贡献为 $w_x+ans_y$，如果先选择放好 $y$，那么贡献为 $w_y+ans_x$。当 $w_x+ans_y < w_y+ans_x$ 时，我们先选择放好 $x$，反之先选择放好 $y$。

也就是说，我们将当前需要计算的节点的子节点按照 $w_i+ans_i$ 排序，依次放好花并统计答案就可以了。

code
```
#include <bits/stdc++.h>
using namespace std;
const int N=100010;
int n;
int h[N],to[N<<1],nxt[N<<1],idx;
struct Node{
    int w,ans;
    bool operator< (const Node &t) const
    {
        return w-ans<t.w-t.ans;
    }
}a[N];
int tot[N];
inline void add(int a,int b)
{
    to[++idx]=b;
    nxt[idx]=h[a];
    h[a]=idx;
}
void dfs(int u,int fa)
{
    int sum=0,cnt=0;
    Node b[tot[u]+10];
    for (int i=h[u];i;i=nxt[i])
    {
        int j=to[i];
        if (j==fa) continue;
        dfs(j,u);
        sum+=a[j].w;
        b[++cnt]={a[j].w,a[j].ans};
    }
    if (!tot[u]) a[u].ans=a[u].w;
    else
    {
        sum+=a[u].w;
        sort(b+1,b+cnt+1);
        a[u].ans=max(a[u].ans,sum);
        int tmp=0;
        for (int i=1;i<=cnt;++i)
        {
            a[u].ans=max(a[u].ans,tmp+b[i].ans);
            tmp+=b[i].w;
        }
    }
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen("zsr.in","r",stdin);
    freopen("zsr.out","w",stdout);
#endif
    scanf("%d",&n);
    for (int i=2;i<=n;++i)
    {
        int x;
        scanf("%d",&x);
        add(i,x),add(x,i);
    }
    for (int i=1;i<=n;++i) scanf("%d",&a[i].w);
    for (int i=1;i<=n;++i)
    {
        vector<int> son;
        for (int j=h[i];j;j=nxt[j])
        {
            int y=to[j];
            son.push_back(y);
        }
        tot[i]=son.size();
    }
    dfs(1,0);
    for (int i=1;i<=n;++i) printf("%d ",a[i].ans);
    return 0;
}
```


---

## 作者：Refined_heart (赞：0)

[[yLOI2019] 梅深不见冬](https://www.luogu.com.cn/problem/P5521)

$\text{Solution:}$

题意比较清晰就不赘述了。

先从一个 naive 的想法开始：如果要满足题目所说条件，那么一定就是其所有孩子都要先被占满梅花，再占自己。

那么一个 dfs 的轮廓就有了。这题一定是一个自底向上更新的解决流程。

那么我们试着给出一个解决方案：设 $ans[x]$ 表示在 $x$ 点符合要求所需要的最小梅花数量。怎么更新？

我们发现，题目说可以随时回收梅花，也就意味着对应地，把一个点填满后，必然会回收一些梅花。我们记 $rest[x]$ 表示填好这个点所回收掉的梅花数。

那么，考虑一个个儿子依次更新：第一个儿子回收上来的点只能作用于后面到达的儿子上。所以我们需要 确定某个顺序 来使得 $rest[]$ 数组的利用率最大。

考虑按照 $rest[x]$ 从大到小排序。这样，每次放完一个孩子后用之前的 $rest$ 更新，就是最优的情况。

$Proof:$

首先如果一个点的 $ans[x]>ans[x']$ 并且 $rest[x]<rest[x']$ 显然不优。

那么，假定存在 $x,x'$ 满足 $ans[x]<ans[x'],rest[x]<rest[x']$

选择前者的答案会是 $ans[now]+ans[x],rest[now]+rest[x]$

选择后者的答案会是 $ans[now]+ans[x'],rest[now]+rest[x']$

暂且假定两者会被放到第一个位置，后面的情况一致。这种情况下：

若后面的所有消耗不超过 $rest[x],$ 那么两者在此时一致。

若后面的所有消耗超过了 $rest[x],$ 那么后者更优。

那么当两者不位于序列第一位时，设当前 $rest[now]=r.$

那么，如果 $r\leq ans[x]$ 就和上述情况无异了。

当 $r\ge ans[x']$ 显然是后者更优。

当 $r$ 居于两者之间的时候，为了选择后者需要花费 $cost=ans[x']-r$ 的代价。

那么此时考虑后面的情况，我们来考虑 $rest$ 的**使用率**。

这是因为：

所有的 $ans[v][v\in son[now]]$ 都会被累加上去，唯一可以使得代价变小的就是 $rest$ 的利用率。

观察到，后者所面对的情况的 $cost'$ 应当小于等于前者所面对的 $cost'.$ 

而由此，后者在前面利用率比前者只高不低的情况下更容易将后面的所有值覆盖，也就是其利用率必然比前者高。

综上可以得出结论，按照 $rest[x]$ 排序即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10;
int n,m;
int w[N];
int pa[N],ans[N];
int rest[N];
vector<int>G[N];
inline void link(int x,int y){
	G[x].push_back(y);
}
inline bool cmp(int x,int y){
	return rest[x]>rest[y];
}
void dfs(int x){
	for(auto v:G[x])dfs(v);
	sort(G[x].begin(),G[x].end(),cmp);
	ans[x]=0,rest[x]=0;
	if(G[x].empty()){
		ans[x]=w[x];
		rest[x]=0;
		return;
	}
	ans[x]+=ans[G[x][0]];
	rest[x]+=rest[G[x][0]];
	for(int i=1;i<(int)G[x].size();++i){
		if(rest[x]>=ans[G[x][i]]){
			rest[x]-=ans[G[x][i]];
			rest[x]+=rest[G[x][i]];
		}
		else{
			ans[x]+=ans[G[x][i]];
			ans[x]-=rest[x];
			rest[x]=rest[G[x][i]];
		}
	}
	if(rest[x]>=w[x])rest[x]-=w[x];
	else {
		ans[x]+=w[x]-rest[x];
		rest[x]=0;
	}
	for(auto v:G[x])rest[x]+=w[v];
}
int main(){
	freopen("in.txt","r",stdin);
	scanf("%d",&n);
	for(int i=1;i<n;++i)scanf("%d",&pa[i]),link(pa[i],i+1);
	for(int i=1;i<=n;++i)scanf("%d",&w[i]);
	dfs(1);
	for(int i=1;i<=n;++i)printf("%d ",ans[i]);
	return 0;
}
```

---

## 作者：JRzyh (赞：0)

>风，吹起梅岭的深冬；霜，如惊涛一样汹涌；   
雪，飘落后把所有烧成空，像这场，捕捉不到的梦。    
醒来时已是多年之久，宫门铜环才长了铁锈，也开始生出离愁。   

——银临《梅深不见冬》


设节点 $i$ 要放 $w_i$ 朵花，那么如果他从梅岭带出 $ans_i$ 朵梅花，就能在 $i$ 号节点上放 $w_i$ 
朵梅花。


一种情况是直接放所有子节点再放父节点。

$w_i+\sum w_j$

第二种如果已经在点 $j$ 放了梅花，显然都把其子孙节点的梅花收走。

那放一个子节点的花费是 $\sum\limits^{k-1}_{j=1}w_j+ans_k$ 因为要放说有子节点，所以要取 $\max$。

所以答案为 $ans_i=\max\{w_i+\sum w_j,\max\limits_{k=1\to n}\{\sum\limits^{k-1}_{j=1}w_j+ans_k\}\}$


但是发现 $ans_i$ 和子节点顺序有关系。那么就需要进行排序。

先放个结论：按 $ans-w$ 从大到小的顺序排序。

证明：

这种东西一般是先证明两个结点间的情况，一旦证出来就可以推到 $n$ 个节点。

推两个节点时一般是按原顺序算一遍，再交换后算一遍，证明原顺序优于交换顺序。

有两个相邻节点 $i,j$，交换前的值是 $\max\{ans_j+w_i,ans_i\}$，交换后的值是$\max\{ans_i+w_j,ans_j\}$。

且满足 $ans_i-w_i>ans_j-w_j$。


移项得 $ans_j+w_i>ans_i+w_j$。

因为 $w$ 为正，所以 $ans_j+w_i>ans_j$，$ans_i+w_j>ans_i$，$ans_j+w_i>ans_i$。

显然得证。

code:

```cpp
////////////////////////
///////////////////////
//////////////////////
/////////////////////
/////Author/////////
//////zyh//////////
//////////////////
/////////////////
////////////////
///////////////
//////////////
/////////////
////////////
#include<bits/stdc++.h>
#define EL putchar('\n')
#define SP putchar(' ')
using namespace std;
int read(){int x;scanf("%d",&x);return x;}
long long readll(){long long x;scanf("%lld",&x);return x;}
void print(int x){printf("%d",x);}
void print(long long x){printf("%lld",x);}
int n;
struct edge
{
	int to,nxt,val;
}e[100008];
int hd[100008],ecnt;
struct node
{
	int ans,w;
}a[100008];
bool cmp(node a,node b)
{
	return a.ans-a.w>b.ans-b.w;
}
void add(int u,int v,int val)
{
	e[++ecnt].to=v;
	e[ecnt].val=val;
	e[ecnt].nxt=hd[u];
	hd[u]=ecnt;
}
void dfs(int now)
{
	vector<node>tmp;
	tmp.clear();
	a[now].ans=a[now].w;
	for(int i=hd[now];i;i=e[i].nxt)
	{
		dfs(e[i].to);
		tmp.push_back(a[e[i].to]);
		a[now].ans+=a[e[i].to].w;
	}
	sort(tmp.begin(),tmp.end(),cmp);
	int sum=0;
	for(int i=0;i<tmp.size();i++)
	{
		a[now].ans=max(a[now].ans,tmp[i].ans+sum);
		sum+=tmp[i].w; 
	}
	return;
}
int main()
{
	n=read();
	for(int i=2;i<=n;i++)
	{
		int p=read();
		add(p,i,0);
	}
	for(int i=1;i<=n;i++)
	{
		a[i].w=read();
	}
	dfs(1);
	for(int i=1;i<=n;i++)cout<<a[i].ans<<" ";
 	return 0;
}

```

 



---

## 作者：BelowHorizon (赞：0)

设 $f_i$ 表示当前节点答案的最小值，$res_i=f_i-w_i$ 。

考虑对当前某个点，有两个子节点 $i$，$j$ 。

那么先选择 $i$ 再选择$j$的花费是 $f_1+f_2-res_1$ ，反之花费是 $f_1+f_2-res_2$ 。

所以肯定要先选 $res$ 大的。

这个地方其实不够准确，需要考虑 $f_2-(f_1-w_1)<0$ 的情况，这时前者的花费变成了 $f_1$ ，此时后者的花费仍然是 $f_1+f_2-res_1$ 。前者仍然小于后者。还需要考虑 $f_1-(f_2-w_2)<0$ 的情况，这种情况不会成立因为还需要满足 $f_1-f_2>w_1-w_2$ ，这个不等式是不成立的。

对于对于每一个结点，将子节点按照 $f_i-w_i$ 的顺序排序之后再按照题意模拟即可。



---

## 作者：Leap_Frog (赞：0)

### P.S.
质量挺高的，代码不长还有思维。  
[前置（？）——zcy](https://www.luogu.com.cn/problem/P4823)  

### Description.
给定一颗以 $1$ 为根的子树，每个结点有一个权值 $w_i$。

行走规则：
- 每次可以会到当前结点的父亲。
- 也可以去当前结点的一个**没有到过**的孩子。

插花规则：
- 如果当前到达结点的所有孩子的花数 $\ge w_i$，可以在当前结点插上任意花。  
- 你可以在**任意时刻**回收**任意结点**的**任意朵花**。  

现在问让第 $i(1\le i\le n)$ 个结点满足限制，初始需要带多少花。  

### Solution.
笔者刚开始的想法显然是 **Too Young**。![](https://xn--9zr.tk/no)  
设 $g_i=w_i+\sum_{j\in \text{son}_i}w_j$，然后答案就是一颗子树的 $g$ 最大值。  
不妨想想为什么这个方法会假，原因显然。![](https://xn--9zr.tk/kk)  
假设访问 $x$ 儿子的顺序为 $v_1,v_2...$，那么我们走完 $v_1$ 后，$v_1$ 处的花我们不能收回。![](https://xn--9zr.tk/jy)  
~~不能收回怎么办呢？直接加上就好了啊~~![](https://xn--9zr.tk/cy)  
$$\therefore dp_u=\max\{g_u,dp_{v_1},dp_{v_2}+w_{v_1},dp_{v_3}+w_{v_2}+w_{v_1},...\}$$
我们惊奇地发现，我们的转移和访问儿子的顺序有关。  
那转移时，可能就需要数据结构/贪心等~~奇怪~~技巧来计算。![](https://xn--9zr.tk/dk)  

$$\text{设}\max\{dp_{v_1},dp_{v_2}+w_{v_1}\}<\max\{dp_{v_2},dp_{v_1}+w_{v_2}\}$$
$$\because dp_{v_2}<dp_{v_2}+w_{v_1}$$
$$\therefore dp_{v_1}-w_{v_1}>dp_{v_2}-w_{v_2}$$
所以我们发现转移时直接按照 $dp_v-w_v$ 的大小排序。  
然后就能找到最优的 $\{v_i\}$ 了。![](https://xn--9zr.tk/se)  

### Coding.
```
//愿你和你重要的人能够重逢！
#include<bits/stdc++.h>
using namespace std;typedef long long ll;
template<typename T>inline void read(T &x)
{
	x=0;char c=getchar(),f=0;
	for(;c<'0'||c>'9';c=getchar()) if(c=='-') f=1;
	for(;c>='0'&&c<='9';c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	if(f) x=-x;
}
struct edge{int to,nxt;}e[100005];int n,et,head[100005],w[100005],dp[100005],cn;
struct node{int dp,w;bool operator<(node b) const {return dp-w>b.dp-b.w;}}a[100005];
inline void adde(int x,int y) {e[++et]=(edge){y,head[x]},head[x]=et;}
inline void dfs(int x)
{
	int sm=0,S=0;for(int i=head[x];i;i=e[i].nxt) dfs(e[i].to),S+=w[e[i].to];
	cn=0;for(int i=head[x];i;i=e[i].nxt) a[++cn]=(node){dp[e[i].to],w[e[i].to]};
	//for(int i=1;i<=cn;i++) printf("<%d,%d>%c",a[i].dp,a[i].w,i==cn?'\n':' ');
	sort(a+1,a+cn+1);for(int i=1;i<=cn;i++) dp[x]=max(dp[x],sm+a[i].dp),sm+=a[i].w;
	dp[x]=max(dp[x],S+w[x]);
}
int main()
{
	read(n);for(int i=2,x;i<=n;i++) read(x),adde(x,i);
	for(int i=1;i<=n;i++) read(w[i]);
	dfs(1);for(int i=1;i<=n;i++) printf("%d%c",dp[i],i==n?'\n':' ');
	return 0;
}
```

---

## 作者：李34 (赞：0)

[链接](https://www.luogu.com.cn/problem/P5521)

题意较清楚，不再赘述。

讲一个比较新奇的做法，不知道对不对，欢迎指正。



------------


拿到题目我猜测父节点和子节点满足某些递推的关系

我们发现完成某一个节点的时候，此时存在权值的节点只有**这个节点**和**它的所有子节点**。

然而这**不一定**是最大值，因为在**满足它的子节点的时候，有可能会有超出最终需要值的情况**。

但是我们的子节点是**逐个满足**的，所以每次存在这种**超出可能**的**只有一个子节点**。

所以**所有可能爆出的情况**是：

> **当前已经满足好的子节点的权值和正在满足的这个子节点满足过程中出现的最大权值和。**

不妨用 $ Max[i] $ 来表示**满足 $ i $ 节点过程中出现的最大权值和**。 $ W[i] $ 表示 $ i $ 的权值。

所以满足子节点的**顺序**应该是：

> 按 $ Max[i] - W[i] $ 递减。

$ Code : $

```cpp
#include<cstdio>//
#include<vector>
#include<algorithm>
#define pb push_back
#define max(x,y) (x>y?x:y)
#define min(x,y) (x<y?x:y)
using namespace std;
const int N=100005,inf=2e9;
int n,W[N],Ans[N],Max[N];//W[i]权值 Ans[i]答案 Max[i]满足该节点最大权值和（见上文） 
vector<int> Son[N];//Son[i] i的儿子们 
struct node{ int p,tag; };
bool operator < (node a,node b){ return a.p>b.p; }
inline node mp(int x,int y){ node t;t.p=x,t.tag=y;return t; }//结构体：用于排序 
inline int read()//快读 
{
	int num=0;char ch=getchar();
	while (ch>'9'||ch<'0') ch=getchar();
	while (ch<='9'&&ch>='0') num=(num<<1)+(num<<3)+(ch^48),ch=getchar();
	return num;
}
inline void put(int x){ if (x) put(x/10),putchar(x%10+'0'); }//快输（不会有负数和0） 
int main()
{
	n=read();
	for (int i=2;i<=n;++i) Son[read()].pb(i);
	for (int i=1;i<=n;++i) W[i]=read();//输入 
	for (int i=n;i>=1;--i)
	{
		int sum=0,maxn=0,ansmax=0;
		vector<node> v;//sum子节点权值和  maxn子节点中最大的Max  ansmax子节点中最大的Ans 
		for (int j=0;j<Son[i].size();++j)
		{
			int to=Son[i][j];
			v.pb(mp(Max[to]-W[to],to)),maxn=max(maxn,Max[to]),ansmax=max(ansmax,Ans[to]);
		}//v来存储Max-W并记录属于谁 
		sort(v.begin(),v.end());//排序 
		for (int j=0;j<v.size();++j)
		{
			sum+=W[v[j].tag];//加和
			Ans[i]=max(Ans[i],sum+v[j].p);//sum+v[j].p是因为v[j].p在排序前减掉了W[] 
		}
		Max[i]=max(max(Ans[i],sum+W[i]),maxn);//更新Max 
		Ans[i]=max(Ans[i],max(sum+W[i],ansmax));//更新答案 
	}
	for (int i=1;i<=n;++i) put(Ans[i]),putchar(' ');//输出 
	return 0;
}

```




---


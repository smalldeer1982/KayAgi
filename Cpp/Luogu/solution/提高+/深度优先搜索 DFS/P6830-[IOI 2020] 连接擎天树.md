# [IOI 2020] 连接擎天树

## 题目背景

**这是一道交互题。**

本题仅支持 C++ 系列语言，提交时**不需要**包含 `supertrees.h` 头文件，但**需要**在程序开头包含 `vector` 头文件以及声明函数 `void build(std::vector<std::vector<int> > b);`

## 题目描述

滨海湾花园是新加坡的一个大型自然公园。公园内有 $n$ 个塔，称之为“擎天树”。这些塔的编号为 $0$ 到 $n-1$。我们希望建立一个桥的集合（桥的数目大于等于 $0$）。每⼀座桥连接两个不同的塔，而且可以双向通行。没有两座桥连接相同的一对塔。

一条从塔 $x$ 到塔 $y$ 的路径是一个满足以下条件的塔序列（塔的数目大于等于 $1$）：

- 序列的第一个元素是 $x$，
- 序列的最后一个元素是 $y$，
- 序列中所有元素互不相同，

序列中每两个相邻元素（塔）都是被某一座桥连接起来的。

注意根据定义，一个塔到它自己有且仅有一条路径，并且从塔 $i$ 到塔 $j$ 的不同路径的数目和从塔 $j$ 到塔 $i$ 的不同路径的数目是一样的。

负责该项设计的首席设计师希望待建造的桥梁要符合：任意给定 $0 \le i,j \le n-1$，恰好有 $p[i][j]$ 条从塔 $i$ 到塔 $j$ 的不同路径，其中 $0 \le p[i][j] \le 3$。

请构造一个桥的集合来满足设计师的要求，或判定这样的桥梁集合不可能存在。

#### 实现细节

你需要实现下面的这个函数：

```cpp
int construct(std::vector<std::vector<int> > p)
```

- $p$：⼀个表示设计师要求的 $n \times n$ 数组。
- 如果这个建设方案是存在的，该函数应该恰好调用一次 `build`（见下文）来给出建设方案，然后应返回 $1$。
- 否则，该函数应该返回 $0$，并且不要调用 `build`。
- 该函数将被调用恰好一次。

函数 `build` 定义如下：

```cpp
void build(std::vector<std::vector<int> > b)
```
  
- $b$：一个 $n \times n$ 的数组，$b[i][j]=1$ 表示有一座桥连接塔 $i$ 和塔 $j$，否则 $b[i][j]=0$。
- 注意该数组必须满足：对所有 $0 \le i,j \le n-1$，$b[i][j]=b[j][i]$；并且对所有 $0 \le i \le n-1$，$b[i][i]=0$。

## 说明/提示

#### 样例说明

#### 例 1

考虑以下调用：

```cpp
construct([[1, 1, 2, 2], [1, 1, 2, 2], [2, 2, 1, 2], [2, 2, 2, 1]])
```
  
这表明从塔 $0$ 到塔 $1$ 恰好有一条路径。对于所有其他的塔对 $(x,y)(0 \le x<y \le 3)$, 恰好有两条不同的路径连接塔 $x$ 和塔 $y$。这可以通过建设 $4$ 座桥来实现：连接塔对 $(0, 1), (1, 2), (1, 3)$ 和 $(2,3)$。

为了给出这个解决方案，函数 `construct` 应该做以下调用：

```cpp
build([[0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0]])
  ```

![](https://cdn.luogu.com.cn/upload/image_hosting/lf8q5wrk.png)

函数应该返回 $1$。

对于这个例子，存在多种不同的建设方案来满足要求，所有这些方案都被认为是正确的。

#### 例 2

考虑以下调用：

```cpp
construct([[1, 0], [0, 1]])
```
  
  这表明无法在两个塔之间进行旅行。这只能通过不建设桥梁来满足。

因此，函数 `construct` 应该做以下调用：
```cpp
build([[0, 0], [0, 0]])
```
  然后，函数 `construct` 应该返回 $1$。
  
  #### 例 3
  
考虑以下调用：

```cpp
construct([[1, 3], [3, 1]])
```

这表明从塔 $0$ 到塔 $1$ 恰好有 $3$ 条路径。这些要求无法满足。因此，函数 `construct` 应该返回 $0$ 并且不要调用 `build`。

#### 约束条件

- $1\le n\le 1000$
- $p[i][i]=1$（对所有 $0 \le i \le n-1$）
- $p[i][j]=p[j][i]$（对所有 $0 \le i,j \le n-1$）
- $0 \le p[i][j] \le 3$（对所有 $0 \le i,j \le n-1$）

#### 子任务

1. （11 分）$p[i][j]=1$（对所有 $0 \le i,j \le n-1$）
2. （10 分）$p[i][j] \in \{0,1\}$（对所有 $0 \le i,j \le n-1$）
1. （19 分）$p[i][j] \in \{0,2\}$（对所有 $i \ne j,0 \le i,j \le n-1$）
1. （35 分）$0 \le p[i][j]\le 2$（对所有 $0 \le i,j \le n-1$）并且至少有一种建设方案满足要求
1. （21 分）$0 \le p[i][j] \le 2$（对所有 $0 \le i,j \le n-1$）
1. （4 分）没有额外约束条件

#### 评测程序示例

评测程序示例以如下格式读取输入数据：

第 $1$ 行：$n$       
第 $2+i$ 行（$0 \le i \le n+1$）：$p[i][0]\ p[i][1]\ \ldots\ p[i][n]$

评测程序示例的输出格式如下：

第 $1$ 行: `construct` 的返回值。

如果 `construct` 的返回值为 $1$，评测程序示例会额外打印：

第 $2+i$ 行（$0 \le i \le n+1$）：$b[i][0]\ b[i][1]\ \ldots\ b[i][n]$

# 题解

## 作者：rui_er (赞：31)

破事水：IOI2020 结束后就想要写这题，但是 spj 当时是锅的，修好后我就~~秉承鸽子的良好品德~~一直咕到了现在。

因为 CSP2020 考的有点自闭，所以来做一道 IOI 真题放松一下。

---

题意简述：构造一个无向图，使得任意两个点之间路径个数与题目给出的相同。

---

思路：

**注：因为洛谷与其他 oj（包括 IOI 官方）的评测方式不同，本题解代码以洛谷为准，在其他 oj 可能无法直接取的 AC，请额外注意。**

首先，如果一个图中的一个连通块，拥有**多于**一个环，那么这种情况肯定不符合题意。为啥呢？画个图理解一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/ce80n3m9.png)

以这张图上 $4\rightarrow 6$ 的路径为例，共有如下情况：

1. $4\rightarrow 0\rightarrow 1\rightarrow 6$
1. $4\rightarrow 0\rightarrow 1\rightarrow 5\rightarrow 6$
1. $4\rightarrow 3\rightarrow 2\rightarrow 1\rightarrow 6$
1. $4\rightarrow 3\rightarrow 2\rightarrow 1\rightarrow 5\rightarrow 6$

因为跨过了两个环，路径条数显然多于三个。

我们得到了构造的初步方向：**原图必须是一个由树或基环树组成的森林**。

接着找规律：

![](https://cdn.luogu.com.cn/upload/image_hosting/tjnvm6dg.png)

对于这棵基环树，通过手推，发现：

1. 对于任意两个点（比如 $2,4$），它们之间的路径如果全在环外，那么它们之间**有且仅有一条路径**。
1. 对于任意两个点（比如 $6,3$），它们之间的路径如果至少有一条边一定在环上，那么它们之间**有两条路径**。

换句话说，就是把所有环上的边先删掉，如果还在连通块内，就只有一条边。

可以看到，**如果题目中要求 $u,v$ 之间有三条路径，此时无解**。

我们先 dfs 一遍**求出连通块**，如果连通块内存在要求有三条路径的边，就直接判掉。如果有两个点之间路径要求为零，也可以判掉。剩下的情况就分为两种：树和基环树。

对于连通块内只要求两两之间有一条路径，将其中一个点和连通块内其他所有点相连即可。对于基环树，我们先不考虑路径数为二的边，在剩下的路径数为一的边里面再次 dfs 求出环外的连通块，按照相同方式连接后，每个环外连通块取一个点，将这些点依次连城环即可。

至此我们便得到了正解。

---

代码：

```cpp
//By: Luogu@rui_er(122461)
#include <bits/stdc++.h>
using namespace std;
const int N = 1005;

void build(vector<vector<int> > b);

int n, ma, vis[N];
vector<int> block, edge, circle; // 分别为连通块、基环树上的树边和基环树上的环 
vector<vector<int> > graph, res;
void add(int u, int v) {res[u][v] = res[v][u] = 1;}
void dfs(int u) {
//	printf("DFS %d\n", u);
	vis[u] = 1;
	block.push_back(u);
	for(int v=0;v<n;v++) {
		ma = max(ma, graph[u][v]);
		if(!vis[v] && graph[u][v]) dfs(v);
	}
}
void dfsCircle(int u) {
	vis[u] = 2;
	edge.push_back(u);
	for(int v=0;v<n;v++) if(vis[v] == 1 && graph[u][v] == 1) dfsCircle(v);
}
int construct(vector<vector<int> > p) {
//	puts("CONSTRUCT");
	graph = p; n = p.size(); res.resize(n);
	for(int i=0;i<n;i++) res[i].resize(n);
	for(int i=0;i<n;i++) {
		if(vis[i]) continue;
		ma = 1; block.clear(); dfs(i);
//		printf("ROUND %d DFS ENDED WITH MAX=%d\n", i, ma);
		if(ma == 3) return 0;
		int sz = block.size();
		for(int j=1;j<sz;j++) {
			for(int k=0;k<j;k++) {
				if(!graph[block[j]][block[k]]) return 0;
			}
		}
		if(ma == 1) for(int j=1;j<sz;j++) add(block[0], block[j]);
		else {
			circle.clear();
			for(int _=0,j=block[_];_<sz;_++,j=block[_]) {
				if(vis[j] != 1) continue;
				edge.clear();
				dfsCircle(j);
//				puts("DFSCIRCLE ENDED");
				int sz2 = edge.size();
				for(int k=1;k<sz2;k++) {
					for(int l=0;l<k;l++) {
						if(graph[edge[k]][edge[l]] != 1) return 0;
					}
					add(edge[0], edge[k]);
				}
				circle.push_back(edge[0]);
//				printf("CIRCLE ADDED %d\n", edge[0]);
			}
			if(circle.size() <= 2) return 0;
			int sz3 = circle.size();
			for(int j=0;j<sz3;j++) add(circle[j], circle[(j+1)%sz3]);
		}
	}
	build(res);
	return 1;
}/*

void build(vector<vector<int> > b) {
	puts("BUILD");
	for(int i=0;i<b.size();i++) {
		for(int j=0;j<b[i].size();j++) printf("%d ", b[i][j]);
		puts("");
	}
}
int main() {
	vector<vector<int> > a = vector<vector<int> >
							({vector<int>({1, 1, 2, 2}), vector<int>({1, 1, 2, 2})
							, vector<int>({2, 2, 1, 2}), vector<int>({2, 2, 2, 1})});
	build(a);
	printf("CONSTRUCT ENDED WITH RETURN VALUE %d\n", construct(a));
	return 0;
}*/
```

---

## 作者：鏡音リン (赞：14)

题意：一个 $n$ 个点的图，给定了任意两点之间的不同简单路数量 $a_{ij}$，简单路定义为不经过重复点的路径，保证$0\le a_{ij}\le 3$。求构造满足要求的图或判断无解。

画几张图观察一下简单路的性质，发现合法的图一定满足**任意一个连通块中最多只有一个环**。如果一个连通块有不止一个环，一定可以找到一对点存在至少四条不同简单路，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/4uoyc4ux.png)

那么一个连通块一定是树或者基环树。dfs 出每个连通块，先判断一下如果连通块里出现了路径数为 $0$  的点对就是无解。然后树非常好处理，如果连通块内路径数全是 $1$ 那就是树，随便构造一个就行。基环树复杂一些，我们画张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/csdhwq0n.png)

观察发现，如果两个点在同一个红圈里，那它们只间有 $1$ 条简单路，否则有 $2$ 条。$3$ 是绝对不会出现的，出现了直接无解。然后 dfs 出每个连通块里，由 $a_{ij}=1$ 相连的子连通块，它们应该在一个红圈里。如果一个红圈里混进了路径数为 $2$ 的点对那无解，否则把它们连成一棵树。最后在每个红圈里找一个代表点，把这些代表点串起来成为一个环即可。如果代表点不足三个就没法串成环，还是无解。

```cpp
#include "supertrees.h"
#define N 1000
std::vector<std::vector<int>> *G, ret;
void addedge(int x, int y) {
	ret[x][y] = ret[y][x] = 1;
}
int n, mx; char vis[N];
std::vector<int> cnt, all, sm;
void dfs(int x) {
	vis[x] = 1;
	cnt.push_back(x);
	for (int i = 0; i < n; i++) {
		int d = (*G)[x][i];
		mx = std::max(d, mx);
		if (!vis[i] && d) dfs(i);
	}
}
void dfsS(int x) {
	vis[x] = 2;
	sm.push_back(x);
	for (int i = 0; i < n; i++) {
		if (vis[i] == 1 && (*G)[x][i] == 1) dfsS(i);
	}
}
int construct(std::vector<std::vector<int>> p) {
	G = &p; n = p.size();
	ret.resize(n);
	for (int i = 0; i < n; i++)
		ret[i].resize(n);
	for (int i = 0; i < n; i++) if (!vis[i]) {
		mx = 1;
		cnt.clear();
		dfs(i);
		if (mx == 3) return 0;
		for (int i = 1; i < cnt.size(); i++)
			for (int j = 0; j < i; j++)
				if (p[cnt[i]][cnt[j]] == 0)
					return 0;
		if (mx == 1) {
			for (int i = 1; i < cnt.size(); i++)
				addedge(cnt[0], cnt[i]);
			continue;
		}
		all.clear();
		for (int j : cnt) if (vis[j] == 1) {
			sm.clear();
			dfsS(j);
			for (int i = 1; i < sm.size(); i++) {
				for (int j = 0; j < i; j++)
					if (p[sm[i]][sm[j]] != 1)
						return 0;
				addedge(sm[0], sm[i]);
			}
			all.push_back(sm[0]);
		}
		if (all.size() <= 2) return 0;
		for (int j = 1; j < all.size(); j++)
			addedge(all[j-1], all[j]);
		addedge(all[0], all.back());
	}
	build(ret);
	return 1;
}
```

---

## 作者：s_r_f (赞：13)

安利：[IOI2020题解-洛谷博客](https://www.luogu.com.cn/blog/s-r-f/ioi2020-ti-xie) [IOI2020题解-cnblogs](https://www.cnblogs.com/s-r-f/p/13697373.html)

---

[题目链接-LOJ](https://loj.ac/problem/3365) [题目链接-洛谷](https://www.luogu.com.cn/problem/P6830)

首先，如果存在 $p_{i,j}=0$ ,那么就分成了多个联通块，这些联通块分开做即可。

由于 $p_{i,j} \leq 3 $ 所以一个联通块当中不能出现多于一个环，否则必然会有两个点之间有 $4$ 条路径。

没有环的情况(联通块内 $p_{i,j}$ 均为 $1$ )先判掉，那么这个联通块正好有一个环。

不难发现，如果两个点 $x$ 和 $y$ 之间的路径需要经过多于一个环上的节点，那么 $p_{x,y}$ 就等于 $2$ ,否则 $p_{x,y}$ 为 $1$ , 因此如果存在 $p_{x,y} = 3$ 那么也无解。

把所有的 $p_{x,y} = 1$ 的 $x$ 和 $y$ 合并到一个联通块中，把这些块之间连成一个环， $check$ 是否合法即可。

$\Theta (n^2)$

code(LOJ上通过):

```cpp
#include <bits/stdc++.h>
#include "supertrees.h"
using namespace std;
const int N = 1001;
int n,cur[N],cntc,G[N][N],ans[N][N];
int p[N],l,fa[N];
inline int Find(int x){ return x == fa[x] ? x : (fa[x] = Find(fa[x])); }
inline void Merge(int x,int y){ fa[Find(x)] = Find(y); }
inline void add_edge(int x,int y){ ans[x][y] = ans[y][x] = 1; }
inline bool solve(int c){
	int i,j; bool is = 0;
	for (l = 0,i = 1; i <= n; ++i) if (cur[i] == c) p[++l] = i;
	for (i = 1; i <= l; ++i) for (j = 1; j <= l; ++j) if (G[p[i]][p[j]] != 1) is = 1;
	if (l == 1) return 1;
	if (l == 2){ if (G[p[1]][p[2]] > 1) return 0; add_edge(p[1],p[2]); return 1; }
	if (!is){ for (i = 1; i < l; ++i) add_edge(p[i],p[i+1]); return 1; }
	for (i = 1; i <= l; ++i) fa[i] = i;
	for (i = 1; i <= l; ++i) for (j = 1; j <= l; ++j) if (G[p[i]][p[j]] == 1) Merge(i,j);
	for (i = 1; i <= l; ++i) fa[i] = Find(i);
	for (i = 1; i <= l; ++i) for (j = 1; j <= l; ++j)
		if (fa[i] == fa[j] && G[p[i]][p[j]] == 2) return 0;
	for (i = 1; i <= l; ++i) for (j = 1; j <= l; ++j)
		if (fa[i] != fa[j] && G[p[i]][p[j]] == 1) return 0;
	int x = 0,lst = 0,fir,cnt = 0;
	for (i = 1; i <= l; ++i){
		x = is = 0;
		for (j = 1; j <= l; ++j) if (fa[j] == i) is = 1;
		if (!is) continue;
		++cnt;
		for (j = 1; j <= l; ++j) if (j != i && fa[j] == i){
			if (x) add_edge(p[x],p[j]); x = j;
		}
		if (x) add_edge(p[x],p[i]);
		if (lst) add_edge(p[lst],p[i]); else fir = i; lst = i;
	}
	if (cnt < 3) return 0;
	add_edge(p[lst],p[fir]);
	return 1;
}
inline void getcur(int x,int c){
	cur[x] = c;
	for (int i = 1; i <= n; ++i) if (x != i && G[x][i] && !cur[i]) getcur(i,c);
}
inline int MAIN(){
	int i,j;
	for (i = 1; i <= n; ++i) if (!cur[i]) getcur(i,++cntc);
	for (i = 1; i <= n; ++i) for (j = 1; j <= n; ++j) if (cur[i] != cur[j] && G[i][j]) return 0;
	for (i = 1; i <= n; ++i) for (j = 1; j <= n; ++j) if (cur[i] == cur[j] && !G[i][j]) return 0;
	for (i = 1; i <= cntc; ++i) if (!solve(i)) return 0;
	vector<vector<int> >Ans; vector<int>ret; Ans.clear();
	for (i = 1; i <= n; ++i){
		ret.resize(n);
		for (j = 0; j < n; ++j) ret[j] = ans[i][j+1],cerr << ans[i][j+1] << ' '; cerr<<'\n';
		Ans.push_back(ret);
	}
	build(Ans);
	return 1;
}
int construct(vector<vector<int> > p){
	int i,j; n = p[0].size();
	for (i = 0; i < n; ++i) for (j = 0; j < n; ++j) if (p[i][j] == 3) return 0;
	for (i = 1; i <= n; ++i) for (j = 1; j <= n; ++j) G[i][j] = p[i-1][j-1];
	return MAIN();
}
/*
int main(){
	int n,i,j;
	cin >> n;
	vector<vector<int> >p; vector<int>q; p.clear(),q.resize(n);
	for (i = 1; i <= n; ++i){
		for (j = 0; j < n; ++j) cin >> q[j];
		p.push_back(q);
		
	}
	cout << construct(p) << '\n';
}
*/
```

---

## 作者：gyh20 (赞：5)

发现我居然会 IOI 的题？

先口胡一下，可能代码细节多？不是很想写，但应该是对的。

首先看到两两之间的路径条数不超过 $3$，想到分类讨论。

再思考另外一个问题：如何在不重边的情况下使得两个点之间有多条路径？

方法：在中间加入环。

如果加入一个环就有两条路径，但有两个环无论怎样都有四条，永远都不可能只有三条。

也就是说，如果存在三条就一定无解！（怪不得只有 $4$ 分）

考虑两条，也就是说构造的图一定是一个基环树森林，对于每一个连通块考虑，将这个环提到最上面（感性理解），然后假如删掉环得到的树叫做子树，那么每一个子树内点对路径条数都是 $1$，不在同一子树且连通的点对之间有两条路径。

具体实现（口胡）：先把路径条数为 $1$ 的连成森林，然后再把需要连 $2$ 的连成一个环，最后判一下合不合法。

---

## 作者：namelessgugugu (赞：4)

#### 题意

给定一个 $n*n$ 的数组$p$（$p_{ij}$ <= 3），构造一个 $n$ 个点的无向简单图使得从 $i$ 到 $j$ 的简单路径恰好有 $p_{ij}$ 条。

#### 题解

观察发现 $p$ 的范围非常小，我们就从这里入手

先考虑 $p_{ij}$ 为 $3$ 的情况，发现想要满足条件，$i,j$ 所处的连通块至少有两个环，至少一个点对之间的路径有四条或以上，肯定无解，所以我们先特判一下 $p$ 数组是否有 $3$。

现在我们还得出一个结论，一个连通块内，至多有一个环，也就是每个连通块都是**树**或**基环树**。

如果一个连通块是树，显然任意两点之间的路径只有一条。

如果是基环树，我们先把环取出来，每个环上的节点对应一棵树。观察发现任意两个属于不同的树的节点之间有两条路径，属于同一棵树的节点只有一条路径。

既然树里面的节点无论是否在基环树上，两两之间都只有一条路径，我们可以先把树找到，将满足 $p_{ij}$ 为 $1$ 的节点 $i,j$ 放在一棵树上，否则就不放。如果两个节点必须同时在一颗树上又必须不在一棵树上，可以直接判断无解。

然后考虑把树连成基环树。如果 $p_{ij}$ 为 $2$，则它们所属的树在一个环上，为 $0$ 则不在一个环上。同理，出现矛盾时可以判断无解。

最后我们特判一下有没有基环树仅有两个树，如果有的话就无解，因为两棵树连不成基环树。

总结一下大体思路，就是先特判 $3$ ,然后把点连成树，把树连成环，特判一下最后建图。

#### 代码

把点连成树，把树连成环的操作用并查集就可以实现，还可以判断是否矛盾。要记得储存每棵树的节点和每个环包含的树，最后建边要用到。

AC代码：
```cpp
#include <cstdio>
#include <cstring>
#include <vector>
void build(std::vector<std::vector<int> > b);
const int N = 2005;

int fa[N];
inline void init(int x)
{
	for(int i = 0;i < x;++i)
		fa[i] = i;
	return;
}
int find(int x)
{
	return fa[x] == x?x:fa[x] = find(fa[x]);
}
inline void merge(int x, int y)
{
	fa[find(x)] = find(y);
	return;
}
inline bool same(int x, int y)
{
	return find(x) == find(y);
}

int col[N];
std::vector<int> tree[N];
int vis[N];
int cnt;
std::vector<int> ro[N];
int construct(std::vector<std::vector<int> > p)
{
	int n = p[0].size();
	for(int i = 0;i < n;++i)
		for(int j = i+1;j < n;++j)
			if(p[i][j] == 3) //如果有3直接return 
				return 0;
	init(n);
	for(int i = 0;i < n;++i)
		for(int j = i+1;j < n;++j)
			if(p[i][j] == 1)
				merge(i, j); // 把点连成树 
	for(int i = 0;i < n;++i)
		for(int j = i+1;j < n;++j)
			if(p[i][j] != 1 && same(i, j)) //判断是否有矛盾 
				return 0;
	memset(vis, -1, sizeof(vis));
	for(int i = 0;i < n;++i)//把树的信息储存起来 
	{
		int f = find(i);
		if(vis[f] == -1)
			vis[f] = cnt++;
		col[i] = vis[f]; //col是节点i所属的树的编号 
		tree[vis[f]].push_back(i); //tree[i]储存树i包含的节点 
	}
	init(cnt);//记得初始化 
	for(int i = 0;i < n;++i)
		for(int j = i+1;j < n;++j)
			if(p[i][j] == 2)
				merge(col[i], col[j]); //把树连成环 
	for(int i = 0;i < n;++i)
		for(int j = i+1;j < n;++j)
			if(p[i][j] == 0 && same(col[i], col[j])) //判断是否矛盾 
				return 0;
	for(int i = 0;i < cnt;++i) //储存环的信息 
			ro[find(i)].push_back(tree[i][0]); //ro[i]储存环i包含的节点 
	for(int i = 0;i < cnt;++i) //如果有仅有两颗树的环，无解 
		if(ro[i].size() == 2)
			return 0;
	//接下来是建图 
	std::vector<std::vector<int> > ans;
	ans.resize(n);
	for(int i = 0;i < n;++i)
		ans[i].resize(n, 0);
	for(int i = 0;i < cnt;++i)
	{
		for(int j = 0;j < (signed)tree[i].size()-1;++j)
		{
			int x = tree[i][j], y = tree[i][j+1];
			ans[x][y] = ans[y][x] = 1;
		}
	}
	for(int i = 0;i < cnt;++i)
	{
		for(int j = 0;j < (signed)ro[i].size()-1;++j)
		{
			int x = ro[i][j], y = ro[i][j+1];
			ans[x][y] = ans[y][x] = 1;
		}
		if(ro[i].size() > 1)
		{
			int x = ro[i][0], y = ro[i][ro[i].size()-1];
			ans[x][y] = ans[y][x] = 1;
		}
	}
	build(ans);
	return 1;
}
```

---

## 作者：zzw4257 (赞：4)

>给定矩阵$g$,构造一个$n$点的无向图，使得$i,j$之间的简单路径有且仅有$g_{i,j}$条，其中$0\leqslant g_{i,j}\leqslant 3$

#### $\mathrm{Subtask1}:0\leqslant g_{i,j}\leqslant 1$

用$1$联通的关系求完联通块，出环判掉然后就有一个森林

#### $\mathrm{Subtask2}:0\leqslant g_{i,j}\leqslant 2$

容易想到$2$关系是用环去构造的

一些不可能出现的情况

环交环，两个环

发现这些情况总结出来就是

按照$2$关系找联通块如果
- 内部有$0/1$连边
- 不是森林中的树上**路径**
- 联通块有多个

都是不合法的

否则把$2$的联通块(一条路径)首尾连成环即可

#### $\mathrm{Subtask3}:0\leqslant g_{i,j}\leqslant 3$

容易发现有$3$关系必有$\geqslant 4$关系出现

所以无解

---

## 作者：Karry5307 (赞：1)

### 题意

好复杂，我就不写了。

### 题解

[不一定更好的阅读体验](https://www.cnblogs.com/Karry5307/p/13708429.html)

口胡了一下，发现我居然会 IOI 的题？

首先发现有 $3$ 一定不合法，因为连通块里面有一个环的话 $p_{i,j}$ 最多为 $2$，有两个环的话就存在一个 $p_{i,j}$ 为 $4$ 了。

所以每一个连通块之内要么是树要么是基环树。

考虑某个连通块。将这个连通块划分成若干子树，有一个环每个子树的根节点连接起来，比如说下面的图就将它划分为 $\{1,2,3\},\{4,5,6\},\{7,8,9\}$ 三棵子树。

![wqPN5T.png](https://s1.ax1x.com/2020/09/21/wqPN5T.png)

对于在同一个连通块里面的点 $i,j$ 来说，如果两个点在一个子树中那么 $p_{i,j}$ 显然为 $1$，否则 $p_{i,j}=2$。

所以我们可以先将 $p_{i,j}=1$ 的那些点合并成子树，再随意指定一个根将所有 $p_{i,j}=2$ 的点连成一个环就做完了，这个可以用两个并查集来维护。

这题无解有点难判。

### 代码

```cpp
#include<bits/stdc++.h>
#include "supertrees.h"
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=2e3+51;
vector<vector<ll>>res,g,p;
ll n;
ll ffa[MAXN],ffa2[MAXN];
inline ll find(ll x)
{
	return x==ffa[x]?x:ffa[x]=find(ffa[x]);
}
inline ll find2(ll x)
{
	return x==ffa2[x]?x:ffa2[x]=find(ffa2[x]);
}
inline void connect(ll x,ll y)
{
	return (void)(res[x][y]=res[y][x]=1);
}
inline ll merge(ll x,ll y)
{
	ll fx=find(x),fy=find(y);
	if(fx==fy)
	{
		return 1;
	}
	for(register int i=0;i<n;i++)
	{
		if(p[x][i]!=p[y][i])
		{
			return 0;
		}
	}
	return connect(fx,fy),ffa[fy]=fx,1;
}
inline void merge2(ll x,ll y)
{
	ll fx=find2(x),fy=find2(y);
	if(fx!=fy)
	{
		ffa2[fy]=fx;
	}
}
ll construct(vector<vector<ll>>x)
{
	p=x,n=p.size(),res.resize(n),g.resize(n);
	for(register int i=0;i<n;i++)
	{
		ffa[i]=ffa2[i]=i,res[i].resize(n);
	}
	for(register int i=0;i<n;i++)
	{
		for(register int j=0;j<n;j++)
		{
			if(p[i][j]>2)
			{
				return 0;
			}
			if(i!=j&&p[i][j]==1&&!merge(i,j))
			{
				return 0;
			}
		}
	}
	for(register int i=0;i<n;i++)
	{
		for(register int j=0;j<n;j++)
		{
			find(i)==i&&find(j)==j&&p[i][j]==2?merge2(i,j):(void)1;
		}
	}
	for(register int i=0;i<n;i++)
	{
		for(register int j=0;j<n;j++)
		{
			if(i!=j&&find(i)==i&&find(j)==j&&find2(i)==find2(j)&&!p[i][j])
			{
				return 0;
			}
		}
	}
	for(register int i=0;i<n;i++)
	{
		find(i)!=i?connect(i,ffa[i]):g[find2(i)].emplace_back(i);
	}
	for(register int i=0;i<n;i++)
	{
		if(find2(i)==i&&g[i].size()==2)
		{
			return 0;
		}
		if(find2(i)==i&&g[i].size()>1)
		{
			for(register int j=0;j<g[i].size();j++)
			{
				connect(g[i][j],g[i][(j+1)%g[i].size()]);
			}
		}
	}
	return build(res),1;
}
```

---

## 作者：Graphcity (赞：0)

一道巧妙的构造题。

首先注意到如果有 $p_{i,j}=3$ 则无解。原因很简单，我们构造出 $p_{i,j}=3$ 时的最简化情况：（图中 $i=1,j=2$）

![](https://cdn.luogu.com.cn/upload/image_hosting/6lsrv5b4.png)

可以发现即便如此也有 $p_{3,4}=4$。

所以接下来仅讨论 $p_{i,j}\le 2$ 的情况。所有 $p_{i,j}> 0$ 的 $i,j$ 一定连通，可以将原图划分为多个不相关的连通块解决问题。

如果一个连通块内 $p_{i,j}$ 均等于一那么就是一棵树，随便构造一棵树即可。如果存在 $p_{i,j}=2$，那么至少存在一个环。

但是一个连通块中的环不超过一个，因为存在两个环也就势必存在两个点有四条不同的路径。所以这是棵基环树。

基环树中，将环边删掉之后，同一连通块的点对均只有一条路径，而不同连通块的点对均有两条路径。可以用并查集来判断两个点是否在同一连通块。最后再从每个连通块中找一个代表点成环即可。

注意特判环中只有两个点的情况，此时不合法。时间复杂度 $O(n^2)$。

```cpp
#include<bits/stdc++.h>
#include "supertrees.h"
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int Maxn=1e3;

int construct(vector<vector<int>> p);
void build(vector<vector<int>> b);

int n,g[Maxn+5][Maxn+5],fa[Maxn+5];
int vis[Maxn+5],ans[Maxn+5][Maxn+5];
vector<int> v;

int Find(int x) {return fa[x]==x?x:fa[x]=Find(fa[x]);}
void dfs(int x)
{
    vis[x]=1,v.push_back(x);
    For(i,1,n) if(!vis[i] && g[x][i]) dfs(i);
}
int Solve(int id)
{
    v.clear(),dfs(id);
    for(auto i:v) for(auto j:v) if(!g[i][j]) return 0;
    For(i,1,n) fa[i]=i;
    for(auto i:v) for(auto j:v)
        if(g[i][j]==1 && Find(i)!=Find(j))
            fa[Find(i)]=Find(j);
    for(auto i:v) for(auto j:v)
    {
        if(Find(i)==Find(j) && g[i][j]!=1) return 0;
        if(Find(i)!=Find(j) && g[i][j]==1) return 0;
    }
    for(auto i:v) if(Find(i)!=i)
        ans[Find(i)][i]=ans[i][Find(i)]=1;
    int st=0,ed=0,cnt=0;
    for(auto i:v) if(Find(i)==i)
    {
        if(!st) st=i;
        if(ed) ans[ed][i]=ans[i][ed]=1;
        ed=i,cnt++;
    }
    if(cnt==2) return 0;
    if(st!=ed) ans[st][ed]=ans[ed][st]=1;
    return 1;
}
int Solve()
{
    For(i,1,n) For(j,1,n) if(g[i][j]==3) return 0;
    For(i,1,n) if(!vis[i] && !Solve(i)) return 0;
    return 1;
}
int construct(vector<vector<int>> p)
{
    n=p.size();
    For(i,0,n-1) For(j,0,n-1) g[i+1][j+1]=p[i][j];
    if(!Solve()) return 0;
    else
    {
        vector<vector<int>> b; b.resize(n);
        For(i,0,n-1) b[i].resize(n);
        For(i,0,n-1) For(j,0,n-1) b[i][j]=ans[i+1][j+1];
        build(b); return 1;
    }
}
```

---

## 作者：Conless (赞：0)

这题主要的难点是交互题的形式……调试了快一年

首先我们注意到一个~~奇怪~~的数据限制：$p[i][j]\in [0,3]$，这样的话，我们可以证明：对于两个有路径的节点，他们一定位于一棵树或一棵基环树上

一个联通的无向图可以看作在一棵树的基础上加 $k$ 条边

当 $k=1$ 时，是一棵基环树

![](https://cdn.luogu.com.cn/upload/image_hosting/t0lx9m7f.png)

此时，我们可以发现，环上各点相互之间都有 $2$ 条互通路径，而环上连接的树内两两只有 $1$ 条路径

如果我们再加入另一条边 $4-7$：
![](https://cdn.luogu.com.cn/upload/image_hosting/bj92zw4k.png)

则一定会形成两个新的环($1-2-3-7-3$ 与 $2-4-7-3-6-5$)

此时，除了对于原环上的一点（除了 $2,3$ 两个和 $4,7$ 原来有且只有一条路径的），我们能找到至少 $4$ 条到 $4$ 或 $7$ 的路径（即：原先通往 $2$ 与 $3$ 的四条路径，再在 $2$ $3$ 的子树上走到对应的另一棵子树上的 $7$ $4$）

所以可以保证每一个连通块都是树或基环树，且最大的路径树应为 $2$，所以出现 $3$ 的情况可以直接排除

对于一个最大路径数为 $1$ 的连通块，直接建树即可

对于一个最大路径数为 $2$ 的连通块，根据上面对于基环树的分析，我们对每个以环上一点为根的子树（$2-4$ 与 $3-7$）单独建树，再在每棵树上各取一点连成环即可

顺便贴一下测试数据与 $check$ 程序领取[地址](https://cdn.ioi2020.sg/day1/supertrees.zip)

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <vector>

using namespace std;

const int MAXN = 1005;

void build(vector<vector<int> > b);

int n, cnt;
int fa[MAXN], belong[MAXN], vis[MAXN];
vector<int> cir, edg;
vector<vector<int> > gr, tr, ans;

int find(int x) { return fa[x] == x ? fa[x] : fa[x] = find(fa[x]); }

void dfs(int u)
{
    vis[u] = 1;
    edg.push_back(u);
    for (int v = 0; v < n; v++)
        if (!vis[v] && gr[u][v] == 1)
            dfs(v);
}

int construct(vector<vector<int> > p)
{
    gr = p;
    n = p[0].size();
    tr.clear();
    ans.clear();
    tr.resize(n + 1);
    ans.resize(n);
    for (int i = 0; i < n; i++)
    {
        fa[i] = i;
        ans[i].resize(n);
    }
    for (int i = 0; i < n; i++)
        for (int j = i + 1; j < n; j++)
            if (p[i][j] != 0)
            {
                int fx = find(i), fy = find(j);
                if (fx != fy)
                    fa[fx] = fy;
            }
    for (int i = 0; i < n; i++)
    {
        find(i);
        if (belong[fa[i]])
            belong[i] = belong[fa[i]];
        else {
            belong[i] = ++cnt;
            tr[belong[i]].clear();
            belong[fa[i]] = cnt;
        }
        tr[belong[i]].push_back(i);
    }
    for (int i = 1; i <= cnt; i++)
    {
        int siz = tr[i].size();
        bool flag = 0;
        for (int j = 0; j < siz - 1; j++)
            for (int k = j + 1; k < siz; k++)
            {
                int u = tr[i][j], v = tr[i][k];
                if (p[u][v] == 3 || p[u][v] == 0)
                    return 0;
                if (p[u][v] == 2)
                    flag = 1;
            }
        if (!flag)
        {
            for (int j = 0; j < siz - 1; j++)
                ans[tr[i][j]][tr[i][j + 1]] = ans[tr[i][j + 1]][tr[i][j]] = 1;
        }
        else {
            cir.clear();
            for (int j = 0; j < siz; j++)
            {
                int u = tr[i][j];
                if (vis[u])
                    continue;
                edg.clear();
                dfs(u);
                int esiz = edg.size();
                for (int k = 1; k < esiz; k++)
                {
                    for (int l = 0; l < k; l++)
                        if (p[edg[k]][edg[l]] != 1)
                            return 0;
                    ans[edg[0]][edg[k]] = ans[edg[k]][edg[0]] = 1;
                    // printf("%d %d\n", edg[0], edg[k]);
                }
                // printf("%d\n", edg[0]);
                cir.push_back(edg[0]);
            }
            if (cir.size() <= 2)
                return 0;
            int csiz = cir.size();
            for (int j = 0; j < csiz - 1; j++)
                ans[cir[j]][cir[j + 1]] = ans[cir[j + 1]][cir[j]] = 1;
            ans[cir[0]][cir[csiz - 1]] = ans[cir[csiz - 1]][cir[0]] = 1;
        }
    }
    build(ans);
    return 1;
}
```


---


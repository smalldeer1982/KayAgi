# 【模板】点分治 1

## 题目背景

感谢 hzwer 的点分治互测。




## 题目描述

给定一棵有 $n$ 个点的树，询问树上距离为 $k$ 的点对是否存在。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n\leq 100$。
- 对于 $60\%$ 的数据，保证 $n\leq 1000$，$m\leq 50$ 。
- 对于 $100\%$ 的数据，保证 $1 \leq n\leq 10^4$，$1 \leq m\leq 100$，$1 \leq k \leq 10^7$，$1 \leq u, v \leq n$，$1 \leq w \leq 10^4$。

#### 提示

- **本题不卡常**。
- 如果您 #7 一直 RE/TLE，不妨看看 [这个帖子](https://www.luogu.com.cn/discuss/show/188596)。

## 样例 #1

### 输入

```
2 1
1 2 2
2```

### 输出

```
AYE```

# 题解

## 作者：Froggy (赞：319)

## 给一种~~另类~~的点分治!(非常好理解)

是一种不用桶的做法,数据范围珂以达到 $0\leq c,K \leq 10^9$ (或者更大)

---

### update 2020.2.8 修改了一些小错误

并update:代码在bzoj1316因为没有特判询问0导致WA掉的锅.(感谢 @jiaangk 指出)

### update 2021.3.3 修改了复杂度的错误

---

我看大部分题解的calc函数里都是:

```cpp
void calc(int u){
	...
	//注:tot为d数组长度
	for(int i=1;i<=tot;i++){
		for(int j=1;j<=tot;j++){
			...
		}
	}
	...
}
```
问一句: 
#### 你们不怕T么?
~~我相信回答一定是:你谷数据太菜~~ (update: 2020.2.2 管理员数据加强后确实会T)

### 双层循环?构造一个菊花图一定T!

所以,我这里给出一个复杂度是 $\mathcal{O}(n \log^{2}n+nm\log n)$ 的做法。

`calc` 函数和 `get_dis` 函数不一样，其他都差不多。

------------

记当前分治的根为 $root$。

- $a$ 数组记录从 $root$ 能到的点;

- $d$ 数组记录 $a_{i}$ 到 $root$ 的距离;

- $b$ 数组记录 $a_{i}$ 属于 $root$ 的哪一棵子树(即当 $b_{a_i}=b_{a_j}$ 时,说明 $a_{i}$ 与 $a_{j}$ 属于 $root$ 的同一棵子树)

### 注意：将 $a$ 数组排序时应按照 $d$ 值的从小到大:

cmp函数:


```cpp
bool cmp(int x,int y){
	return d[x]<d[y];
}
```

`get_dis` 函数借鉴了P4178的思想(即用两个指针 $l,r$ 遍历数组)

现在,请看 `get_dis` 与 `calc`

```cpp
void get_dis(int u,int fa,int dis,int from){
	a[++tot]=u;//加入一个新结点
	d[u]=dis;
	b[u]=from;
	for(int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(v==fa||vis[v])continue;
		get_dis(v,u,dis+edge[i].val,from);
	}
}
void calc(int u){
	tot=0;
	a[++tot]=u;
	d[u]=0;
	b[u]=u;//别忘了加上root自己
	for(int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(vis[v])continue;
		get_dis(v,u,edge[i].val,v);
	}
	sort(a+1,a+tot+1,cmp);
	for(int i=1;i<=m;i++){
		int l=1,r=tot;
		if(ok[i])continue;
		while(l<r){
			if(d[a[l]]+d[a[r]]>query[i]){//当和比询问的长度大时,右指针左移
				r--;
			}
			else if(d[a[l]]+d[a[r]]<query[i]){//类似上边
				l++;
			}
			else if(b[a[l]]==b[a[r]]){//和为询问的长度,但同属一棵子树,继续下一种情况
				if(d[a[r]]==d[a[r-1]])r--;
				else l++;
			}
			else{
				ok[i]=true;
				break;
			}
		}
	}
}
```
***talk is cheap,show me your code!***

## 全部代码:

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define N 10001
#define re register 
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<3)+(x<<1)+c-'0';
        c=getchar();
    }
    return x*f;
}
int n,m,query[101];
int e_cnt=0,head[N],maxp[N],siz[N],root,tot=0,d[N],b[N],a[N];
bool vis[N],ok[101];
struct Edge{
	int to,nxt,val;
}edge[N<<1];
void add(int a,int b,int c){
	e_cnt++;
	edge[e_cnt].nxt=head[a];
	edge[e_cnt].to=b;
	edge[e_cnt].val=c;
	head[a]=e_cnt;
}
void get_root(int u,int fa,int total){
	siz[u]=1;
	maxp[u]=0;
	for(re int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(v==fa||vis[v])continue;
		get_root(v,u,total);
		siz[u]+=siz[v];
		maxp[u]=max(siz[v],maxp[u]);
	}
	maxp[u]=max(maxp[u],total-siz[u]);
	if(!root||maxp[u]<maxp[root]){
		root=u;
	}
}
bool cmp(int x,int y){
	return d[x]<d[y];
}
void get_dis(int u,int fa,int dis,int from){
	a[++tot]=u;
	d[u]=dis;
	b[u]=from;
	for(re int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(v==fa||vis[v])continue;
		get_dis(v,u,dis+edge[i].val,from);
	}
}
void calc(int u){
	tot=0;
	a[++tot]=u;
	d[u]=0;
	b[u]=u;
	for(int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(vis[v])continue;
		get_dis(v,u,edge[i].val,v);
	}
	sort(a+1,a+tot+1,cmp);
	for(int i=1;i<=m;i++){
		int l=1,r=tot;
		if(ok[i])continue;
		while(l<r){
			if(d[a[l]]+d[a[r]]>query[i]){
				r--;
			}
			else if(d[a[l]]+d[a[r]]<query[i]){
				l++;
			}
			else if(b[a[l]]==b[a[r]]){
				if(d[a[r]]==d[a[r-1]])r--;
				else l++;
			}
			else{
				ok[i]=true;
				break;
			}
		}
	}
}
void solve(int u){
	vis[u]=true;
	calc(u);
	for(re int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(vis[v])continue;
		root=0;
		get_root(v,0,siz[v]);
		solve(root);
	}
}
int main(){
	n=read(),m=read();
	for(re int i=1;i<=n-1;i++){
		int u,v,w;
		u=read(),v=read(),w=read();
		add(u,v,w);
		add(v,u,w);
	}
	for(re int i=1;i<=m;i++){
		query[i]=read();
		if(!query[i])ok[i]=1;//这里,加个特判
	}
	maxp[0]=n;
	get_root(1,0,n);
	solve(root);
	for(re int i=1;i<=m;i++){
		if(ok[i]){
			cout<<"AYE"<<endl;
		}
		else{
			cout<<"NAY"<<endl;
		}
	}
	return 0;
}

```

[*Froggy's blog*](https://www.luogu.org/blog/froggy/)

#### 呱!!

---

## 作者：niiick (赞：211)

先贴一篇dalao的证明[一种基于错误的寻找重心方法的点分治的复杂度分析](http://liu-cheng-ao.blog.uoj.ac/blog/2969)%%%%%

针对本蒟蒻之前题解的一些错误以做出了修改，并且实测#7无RE/TLE，如果还有不到之处欢迎dalao指出
********************
我们先随意指定一个根rt，将这棵树转化成有根树

不难发现树上的路径分为两类，
**经过根节点rt的路径**和**包含于rt的某棵子树里(不经过rt)的路径**

对于前者，
我们用$dis[u]$表示结点$u$到根节点$rt$的路径长度，
则u到v的路径长即为$dis[u]+dis[v]$

对于后者，
既然$u$到$v$的路径包含在$rt$的某个子树内，
那么我们就**找到这棵子树的根，再对他求一次第一类路径**

这样分治的思想就很明显了

**就是把原来的树分成很多小的子树，并对每个子树分别求解第一类路径**

点分治过程中，每一层的所有递归过程合计对每个点处理一次
假设共递归T层，则总时间复杂度为$O(T*N)$

然而，**如果树退化成一条链**
那么递归层数就是$T=n$，总时间复杂度为$O(N^2)$

这样显然不能承受，所以我们要让树的层数经量少
这里就要找**树的重心**

maxp[u] (max part)表示**删除结点u后产生的子树中，最大的那棵的大小**

则树的重心就是**maxp[]值最小的那个节点**


```cpp
//sum是当前子树的总结点数，size[u]是以u为根的子树大小
void getrt(int u,int fa)
{
    size[u]=1; maxp[u]=0;
    for(int i=head[u];i;i=E[i].nxt)
    {
        int v=E[i].v;
        if(v==fa||vis[v])continue;
        getrt(v,u);//先递归得到子树大小
        size[u]+=size[v];
        maxp[u]=max(maxp[u],size[v]);//更新u结点的maxp
    }
    maxp[u]=max(maxp[u],sum-size[u]);//考虑删除u后，父节点一侧的子树大小
    if(maxp[u]<maxp[rt]) rt=u;//更新当前子树的重心
}
```

我们在点分治过程中**每次选取子树的重心为子树的树根进行处理**，
这样**总的递归深度不会超过**$logN$**层**，
整个点分治的时间复杂度也就保证了$O(NlogN)$

点分治题的思想大都如上，
对于不同的题要设计不同的calc函数

********************************


回到本题，询问可以离线记录并直接在分治过程中处理

设当前根为$rt$，他的子树为$v_1,v_2……v_t$，
假设当前处理的子树为$v_i$，求出$v_i$中每个结点到$rt$的距离$dis$并保存于$rem$数组
并令$judge[dis]$表示在子树$v_1$~$v_{i-1}$中是否存在某个节点到$rt$距离为$dis$

遍历每个离线记录的询问，对每个询问遍历一次当前子树的$rem$
若当前询问距离为$query[k]$，遍历到的子树$v_i$中某个结点到$rt$距离为$rem[j]$
如果$judge[query[k]-rem[j]]==1$，则代表此询问的路径存在

再具体点解释这段话操作的含义
就是用子树$v_i$中某个结点与子树$v_1$~$v_{i-1}$中某个节点两两配对，检查是否存在长度为$query[k]$的路径

像这样配对完后将这棵子树的$rem$(即子树$v_i$中每个节点到$rt$的$dis$)一起保存进$judge$数组，继续下一个子树$v_{i+1}$的处理

当以rt为根的树查询完后清空judge数组
然后对其他子树进行分治
*********************

```cpp
//niiick
#include<iostream>
#include<vector>
#include<algorithm>
#include<queue>
#include<cstring>
#include<cstdio>
using namespace std;

int read()
{
    int f=1,x=0;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return f*x;
}

const int inf=10000000;
const int maxn=100010;
int n,m;
struct node{int v,dis,nxt;}E[maxn<<1];
int tot,head[maxn];
int maxp[maxn],size[maxn],dis[maxn],rem[maxn];
int vis[maxn],test[inf],judge[inf],q[maxn];
int query[1010];
int sum,rt;
int ans;

void add(int u,int v,int dis)
{
    E[++tot].nxt=head[u];
    E[tot].v=v;
    E[tot].dis=dis;
    head[u]=tot;
}

void getrt(int u,int pa)
{
    size[u]=1; maxp[u]=0;
    for(int i=head[u];i;i=E[i].nxt) 
    {
        int v=E[i].v;
        if(v==pa||vis[v]) continue;
        getrt(v,u);
        size[u]+=size[v];
        maxp[u]=max(maxp[u],size[v]);
    }
    maxp[u]=max(maxp[u],sum-size[u]);
    if(maxp[u]<maxp[rt]) rt=u;
}

void getdis(int u,int fa)
{
    rem[++rem[0]]=dis[u];
    for(int i=head[u];i;i=E[i].nxt)
    {
        int v=E[i].v;
        if(v==fa||vis[v])continue;
        dis[v]=dis[u]+E[i].dis;
        getdis(v,u);
    }
}

void calc(int u)
{
    int p=0;
    for(int i=head[u];i;i=E[i].nxt)
    {
        int v=E[i].v;
        if(vis[v])continue;
        rem[0]=0; dis[v]=E[i].dis;
        getdis(v,u);//处理u的每个子树的dis

        for(int j=rem[0];j;--j)//遍历当前子树的dis
        for(int k=1;k<=m;++k)//遍历每个询问
        if(query[k]>=rem[j])
        test[k]|=judge[query[k]-rem[j]];
        //如果query[k]-rem[j]d的路径存在就标记第k个询问

        for(int j=rem[0];j;--j)//保存出现过的dis于judge
        q[++p]=rem[j],judge[rem[j]]=1;
    }
    for(int i=1;i<=p;++i)//处理完这个子树就清空judge
    judge[q[i]]=0;//特别注意一定不要用memeset，会T

}

void solve(int u)
{   
    //judge[i]表示到根距离为i的路径是否存在
    vis[u]=judge[0]=1; calc(u);//处理以u为根的子树
    for(int i=head[u];i;i=E[i].nxt)//对每个子树进行分治
    {
        int v=E[i].v;
        if(vis[v])continue;
        sum=size[v]; maxp[rt=0]=inf;//注意sum是以v为根的子树大小
        getrt(v,0); solve(rt);//在子树中找重心并递归处理
    }
}

int main()
{
    n=read();m=read();
    for(int i=1;i<n;++i)
    {
        int u=read(),v=read(),dis=read();
        add(u,v,dis);add(v,u,dis);
    }
    for(int i=1;i<=m;++i)
    query[i]=read();//先记录每个询问以离线处理

    maxp[rt]=sum=n;//第一次先找整棵树的重心
    getrt(1,0); 
    solve(rt);//对树进行点分治

    for(int i=1;i<=m;++i)
    {
        if(test[i]) printf("AYE\n");
        else printf("NAY\n");
    }
    return 0;
}
```

---

## 作者：寒冰大大 (赞：129)



[可能会更好的阅读体验](https://zsx6.com/2020/01/13/%E7%82%B9%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E8%AE%B0/)

## 放在开头的话

1.本人1月13日才刚刚接触了淀粉汁，所以可能很多东西没有理解完全甚至出错，如果您有什么疑问的话，请发在下面的评论区。

2.淀粉汁是跟着一篇题解学的，因此可以有些代码很像，但是原来题解的部分没讲到的地方我可能会提出来

3.这东西目前可能会更的很慢

## 初级

什么是点分治？

点分治是处理树上问题的一种高效的办法，时间复杂度很优秀，而且思想比较巧妙。

怎么来做呢？

首先我们引入树的重心

### 树的重心

> 树的重心也叫树的质心。找到一个点,其所有的子树中最大的子树节点数最少,那么这个点就是这棵树的重心,删去重心后，生成的多棵树尽可能平衡。

什么意思呢?

我们可以从这里推得以树的重心为根的任意一颗子树大小不超过$n/2$

> 证明就不用了吧

于是我们求$log_2N$次重心，那么每个点就能被确定了。

于是时间复杂度就变成了$O(N log N)$



怎么求呢？

根据它的定义，树的重心一定是最大子树最小的点。

~~感性理解即可~~

于是照着求就可以了啊。

但是我们要多次求，因此我们得加一个条件，判断是否可以访问

`vis[]`或者`fw[]`就可以了



于是整个代码如下

```cpp
inline void getzx(int t,int fat)
{
	int i,j;
	sz[t]=1;
	maxp[t]=0;
	for(i=head[t];i;i=e[i].next)
	{
		j=e[i].to;
		if(j==fat||vis[j]) continue;
		getzx(j,t);
		sz[t]+=sz[j];
		maxp[t]=max(sz[j],maxp[t]);
	}
	maxp[t]=max(maxp[t],tot-sz[t]);
	if(maxp[t]<maxp[rt]) rt=t;
}
```

### 点分治怎么做

我们只需要不断寻找重心，用这些重心来计算我们要的答案

我们举个例子：

现在这里有一棵树

(假定蓝色是未被处理的点，红色是当前子树的重心，绿色是处理完的点)

![](https://cdn.luogu.com.cn/upload/image_hosting/mf557a06.png)

先找到全局重心

![](https://cdn.luogu.com.cn/upload/image_hosting/ewoqneh1.png)

然后对他的子树，也这样找

![](https://cdn.luogu.com.cn/upload/image_hosting/mkr8k3al.png)

一直接下去![](https://cdn.luogu.com.cn/upload/image_hosting/jgxw6a0z.png) 

![](https://cdn.luogu.com.cn/upload/image_hosting/t1ajduki.png)

然后做完了。

等一下，这不是大部分点都被扫过了吗，时间复杂度怎么还会是$O (NlogN)$?

的确，这张图中大部分店都被扫到了，而且都求了重心，但是如果每条边中间连接1000个点，只有m,i,h三条边被处理的重心增多了。

增多了多少呢？

每条边在10左右。

~~现在你感性理解到了复杂度了吧~~

由于之前有一个推论

>我们可以从这里推得以树的重心为根的任意一颗子树大小不超过$n/2$

每次树的大小会变得不超过原来的一般，$log_2N$次后树的大小就会变成1,每一次最多遍历整棵树$O(N)$,复杂度就得到$O (NlogN)$?了

~~不信？我们用随机几十组数据看看~~

![](https://cdn.luogu.com.cn/upload/image_hosting/rzrxvvs2.png)

数据生成器放在[这里](https://www.luogu.com.cn/paste/s4faznxw)

测试用的代码放在[这里](https://www.luogu.com.cn/paste/gz2rcwai) 改自[P2634 [国家集训队]聪聪可可](https://www.luogu.com.cn/problem/P2634)



下面是一个模板代码

```cpp
inline void solve(int t)
{
	int i,j;
	vis[t]=judge[0]=1; calc(t);  //进行计算，有时候要用到容斥原理。
	for(i=head[t];i;i=e[i].next)
	{
		j=e[i].to;
		if(vis[j]) continue;
		tot=sz[j];
		maxp[rt=0]=bign;
		getzx(j,0);  //继续寻找重心
		solve(rt);
	}
}
```



### 例题

#### P3806 【模板】点分治1

大意

>给定一棵有n个点的树
>
>询问树上距离为k的点对是否存在。

其实是很无脑的两个桶，一个`judge[]`和一个`tmp[]`，`judge`存非本路径上长度能达到的数字，`tmp[]`存本路径上能达到的数字，把此时重心看做LCA，于是若tmp[]中一个数+judge[]一个数=k,就说明路径存在。

接着，这条路径遍历完后，把tmp的数字转移到judge里面

这个地方我们找完了，只需要把judge里面的数字清空即可。

于是我们就有代码了

```cpp
#include<touwenjian.h> 

using namespace std;

const int maxn=10010,bign=10001000;

int n,m,tmp[bign],judge[bign];
int sz[maxn],vis[maxn];
int head[maxn],que[maxn];
int size,maxp[maxn];
int tot,rt,dis[maxn];
int q[bign],ynn[maxn];

struct edge{
	int next,to,dis;
}e[maxn*2];

inline void addedge(int next,int to,int dis)
{
	e[++size].to=to;
	e[size].dis=dis;
	e[size].next=head[next];
	head[next]=size;
}

inline void getzx(int t,int fat)
{
	int i,j;
	sz[t]=1;
	maxp[t]=0;
	for(i=head[t];i;i=e[i].next)
	{
		j=e[i].to;
		if(j==fat||vis[j]) continue;
		getzx(j,t);
		sz[t]+=sz[j];
		maxp[t]=max(sz[j],maxp[t]);
	}
	maxp[t]=max(maxp[t],tot-sz[t]);
	if(maxp[t]<maxp[rt]) rt=t;
}

inline void getdis(int t,int fat)
{
	tmp[++tmp[0]]=dis[t];
	int i,j,k;
	for(i=head[t];i;i=e[i].next)
	{
		j=e[i].to;
		k=e[i].dis;
		if(vis[j]||j==fat) continue;  //vis和fat限制了这个子树只能向下遍历。
		dis[j]=dis[t]+k;
		getdis(j,t);
	}
}

inline void calc(int t)
{
	int p=0,i,j,k,l;
	for(i=head[t];i;i=e[i].next)
	{
		j=e[i].to;
		k=e[i].dis;
		if(vis[j]) continue;
		tmp[0]=0;
		dis[j]=k;
		getdis(j,t);
		for(k=tmp[0];k;k--)
		for(l=1;l<=m;l++) if(que[l]>=tmp[k]) ynn[l]|=judge[que[l]-tmp[k]];  
		for(k=tmp[0];k;k--) q[++p]=tmp[k],judge[tmp[k]]=1;  
	}
	for(i=p;i;i--) judge[q[i]]=0; 
}

inline void solve(int t)
{
	int i,j;
	vis[t]=judge[0]=1; calc(t);
	for(i=head[t];i;i=e[i].next)
	{
		j=e[i].to;
		if(vis[j]) continue;
		tot=sz[j];
		maxp[rt=0]=bign;
		getzx(j,0);
		solve(rt);
	}
}

int main()
{
	ios::sync_with_stdio(false);
	register int i,h;
	int t1,t2,t3;
	cin>>n>>m;
	for(i=1;i<n;i++)
	{
		cin>>t1>>t2>>t3;
		addedge(t1,t2,t3);
		addedge(t2,t1,t3);
	}
	for(i=1;i<=m;i++) cin>>que[i];
	maxp[rt=0]=n;
	tot=n;
	getzx(1,0);
	solve(rt);// 每次solve从重心开始
	for(i=1;i<=m;i++) 
	{
		if(ynn[i]) cout<<"AYE"<<endl;
		else cout<<"NAY"<<endl;
	}
	return 0;
}

```



---

## 作者：Nemlit (赞：77)

## [原文地址](https://www.cnblogs.com/bcoier/p/10485482.html)

题意：给定一棵带权无根树，问是否有点对的距离为k

暴力的做法可以枚举所有点对，树上差分即可，复杂度为$O(n^2logn)$，显然还需要优化

有一个~~显然~~的性质，对于任意两个点所夹成的路径，有两种情况：

$1.$经过根节点的路径

$2.$不经过根节点的路径

对与第一类路径，$dis[u->v] = dis[u->rt] + dis[v ->rt]$

对于第二类路径，~~我们可以求出LCA在进行讨论~~，但是我们可以继续递归下去，找到另一个rt，把他转化成第一类路径来讨论

不难发现，这样递归下去的复杂度是和深度有关的，所以我们要尽量的减小深度来优化复杂度，那么我们怎么办呢？

对于每一棵树，我们都有一个**重心**（删掉重心后剩下的子树尽可能地平衡（分出来的最大子树的$size$尽可能地小））

举个例子，对于这张图，深度达到了6，显然不够优秀
![](https://cdn.luogu.com.cn/upload/pic/53294.png)

但是如果我们以5为根，树就会变成这样，深度变为了4：

![](https://cdn.luogu.com.cn/upload/pic/53298.png)

可见根的选择是对复杂度有影响的，如果数据足够大，~~出题人足够毒瘤~~，那么影响显然还会更大

那重心要怎么着呢？我们可以利用树（mo）形（ni）DP的思想来做，即找到该节点所有的子树，找到最大的哪一棵即可，代码如下：
```
il void getroot(int u, int fr)
{
	dp[u] = 0, size[u] = 1;
	Next(i, u)//找到所有与u相连的边
	{
		int v = e[i].v;
		if(v == fr || vis[v]) continue;
		getroot(v, u);
		size[u] += size[v];
		dp[u] = max(dp[u], size[v]);
	}
	dp[u] = max(dp[u], sum - size[u]);//还有一棵以其父亲节点为根的子树
	if(dp[u] < dp[root]) root = u;//找到最优的根
}
```

找到**重心**后，我们不断的递归，在递归过程中也要不断寻找重心来优化复杂度。

代码如下：
```
il void solve(int u)
{
	vis[u] = pd[0] = 1, doit(u);//doit表示做一些
	Next(i, u)
	{
		int v = e[i].v;
		if(vis[v]) continue;
		dp[0] = n, sum = size[v], root = 0;
		getroot(v, u), solve(root);
	}
}
```

那么doit要怎么写呢？

由于我们保证了所有的树都是第一种树（经过根节点的路径），所以我们对于每一个根，可以先预处理出每一个子节点到根的距离，这样我们就可以得到对于每一个点可能出现的距离

代码如下：
```
il void getdis(int u, int fr)
{
	rev[++ tot] = dis[u];
	Next(i, u)
	{
		int v = e[i].v;
		if(v == fr || vis[v]) continue;
		dis[v] = dis[u] + e[i].w;
		getdis(v, u);
	}
}
```
求出了所有距离以后，我们就可以合并答案了，把任意两个出现的距离凑在一起，并判断可否凑出我们需要的k即可（注意复原的时候不要用memset，不然复杂度就是$O(n^2)$了）
```
il void doit(int u)
{
	int c = 0;
	Next(i, u)
	{
		int v = e[i].v;
		if(vis[v]) continue;
		tot = 0, dis[v] = e[i].w, getdis(v, u);
		rep(j, 1, tot) rep(k, 1, m) if(query[k] >= rev[j]) pax[k] |= pd[query[k] - rev[j]];
		rep(j, 1, tot) q[++ c] = rev[j], pd[rev[j]] = 1;
	}
	rep(i, 1, c) pd[q[i]] = 0;
}
```
所有代码如下：
```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define debug printf("Now is Line : %d\n",__LINE__)
#define file(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
//#define int long long
#define inf 123456789
#define mod 1000000007
il int read()
{
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define drep(i, s, t) for(re int i = t; i >= s; -- i)
#define Next(i, u) for(re int i = head[u]; i; i = e[i].next)
#define lb(x) (x)&(-(x))
#define ls k * 2
#define rs k * 2 + 1
#define _ 10005
#define ___ 10000005
#define __ 105
struct edge{int v, next, w;}e[_ << 1];
int n, m, head[_], cnt, dp[_], tot, size[_], sum, root;
int dis[_], vis[_], pd[___], rev[_], pax[__], q[_], query[__];
il void add(int u, int v, int w){e[++ cnt] = (edge){v, head[u], w}, head[u] = cnt;}
il void getroot(int u, int fr)
{
	dp[u] = 0, size[u] = 1;
	Next(i, u)
	{
		int v = e[i].v;
		if(v == fr || vis[v]) continue;
		getroot(v, u);
		size[u] += size[v];
		dp[u] = max(dp[u], size[v]);
	}
	dp[u] = max(dp[u], sum - size[u]);
	if(dp[u] < dp[root]) root = u;
}
il void getdis(int u, int fr)
{
	rev[++ tot] = dis[u];
	Next(i, u)
	{
		int v = e[i].v;
		if(v == fr || vis[v]) continue;
		dis[v] = dis[u] + e[i].w;
		getdis(v, u);
	}
}
il void doit(int u)
{
	int c = 0;
	Next(i, u)
	{
		int v = e[i].v;
		if(vis[v]) continue;
		tot = 0, dis[v] = e[i].w, getdis(v, u);
		rep(j, 1, tot) rep(k, 1, m) if(query[k] >= rev[j]) pax[k] |= pd[query[k] - rev[j]];
		rep(j, 1, tot) q[++ c] = rev[j], pd[rev[j]] = 1;
	}
	rep(i, 1, c) pd[q[i]] = 0;
}
il void solve(int u)
{
	vis[u] = pd[0] = 1, doit(u);
	Next(i, u)
	{
		int v = e[i].v;
		if(vis[v]) continue;
		dp[0] = n, sum = size[v], root = 0;
		getroot(v, u), solve(root);
	}
}
int main()
{
	file(a);
	dp[0] = sum = n = read(), m = read();
	rep(i, 1, n - 1) {int u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w);}
	rep(i, 1, m) query[i] = read();
	getroot(1, 0), solve(root);
	rep(i, 1, m) puts(pax[i] ? "AYE" : "NAY");
	return 0;
}
```

---

## 作者：用户已注销 (赞：29)

点分治？没听说过，还是写一发**DSU On Tree（树上启发式合并）**好了~

个人拙见，**DSU On Tree**主要是解决一些**静态**的**子树信息查询**的问题，当然通过一些骚操作可以拓展。拓展到路径最常见的套路就是**强制该路径经过当前子树根节点**，然后DFS枚举每个点作为根节点。

点分治的思想主要是寻找重心作为根节点以优化复杂度，启发式的思想则类似树链剖分，每次计算贡献时先枚举轻儿子，计算后**清除贡献**，最后枚举重儿子，计算后**保留重儿子的信息**，最后依次枚举轻儿子，暴力将答案计入贡献。这样的复杂度是$O(N\log N)$的。

~~然而只写这么多过不了审核，所以~~接下来仔细解释一下算法的原理！因为网上其他的教程都太简短了！所以我才学了一整天！

首先到底为什么要清空轻儿子的贡献：比如本模板题中，我们找的是**强制经过当前根节点的路径**，所以我们要避免同一个子树内的节点互相乱访问，才要清空轻儿子的贡献。

然后就是这种做法的复杂度为什么能保证？因为对于每个轻儿子我都要使用一次暴力，所以每个点被暴力的次数是它头顶上轻儿子的个数。根据树链剖分的基本常识，每个点到根节点的轻点个数是$\log$级别的，所以所有点被访问的总次数是$O(N\log N)$，算法的复杂度是$O(MN\log N)$。

然后这个算法比点分治好的地方在于：编码特别简单，调试特别简单，而且普通数据下的复杂度一定比点分治要好（因为每个点头顶的轻儿子个数远少于$\log N$），尤其是链的情况下，DSU On Tree更是只要线性复杂度。

放一下代码（**不开O2**，57ms）：

```
#include <bits/stdc++.h>
#define lld I64d
using namespace std ;
inline long long Readin() {
    long long K = 0 , F = 1 ; char C = ' ' ;
    while( C < '0' or C > '9' ) F = C == '-' ? -1 : 1 , C = getchar() ;
    while( C <= '9' and C >= '0' ) K = ( K << 1 ) + ( K << 3 ) + C - '0' , C = getchar() ;
    return F * K ;
}
const int MaxQ = 100 + 10 ;
const int MaxN = 10000 + 10 ;
const int MaxM = 20000 + 10 ;
const int MaxK = 10000000 + 10 ;
int N , Q , Asks[MaxQ] ;
bool Anss[MaxQ] ;
int Cnt , Head[MaxN] , To[MaxM] , Next[MaxM] , Val[MaxM] ;
inline void Add( int U , int V , int W ) {
    Next[++Cnt] = Head[U] ;
    Head[U] = Cnt ;
    To[Cnt] = V ;
    Val[Cnt] = W ;
}
int Fa[MaxN] , Size[MaxN] , D[MaxN] , Hson[MaxN] ;
bool Apr[MaxK] ;
int Depp ;
void Dfs( int Nod ) {
    Size[Nod] = 1 ;
    for(register int i = Head[Nod] ; i ; i = Next[i] ) 
        if( To[i] ^ Fa[Nod] ) {
            Fa[To[i]] = Nod ;
            D[To[i]] = D[Nod] + Val[i] ;
            Dfs( To[i] ) ;
            if( Size[To[i]] > Size[Hson[Nod]] ) Hson[Nod] = To[i] ;
            Size[Nod] += Size[To[i]] ;
        }
}
inline void C( int Nod ) {
    for(register int i = 0 ; ++i <= Q ; )
        if( Asks[i] - D[Nod] + Depp >= 0 )
            Anss[i] |= Apr[Asks[i]-D[Nod]+Depp] ;
}
void Calc( int Nod ) {
    C( Nod ) ;
    for(register int i = Head[Nod] ; i ; i = Next[i] )
        if( To[i] ^ Fa[Nod] ) Calc( To[i] ) ;
}
void Upd( int Nod ) {
    Apr[D[Nod]] = true ;
    for(register int i = Head[Nod] ; i ; i = Next[i] )
        if( To[i] ^ Fa[Nod] ) Upd( To[i] ) ;
}
void Clear( int Nod ) {
    Apr[D[Nod]] = false ;
    for(register int i = Head[Nod] ; i ; i = Next[i] )
        if( To[i] ^ Fa[Nod] ) Clear( To[i] ) ;
}
void Dfs( int Nod , bool Tag ) {
    for(register int i = Head[Nod] ; i ; i = Next[i] )
        if( To[i] ^ Fa[Nod] and To[i] ^ Hson[Nod] ) Dfs( To[i] , true ) ;
    if( Hson[Nod] ) Dfs( Hson[Nod] , false ) ;
    Depp = D[Nod] << 1 ;
    Apr[D[Nod]] = true ;
    C( Nod ) ;
    for(register int i = Head[Nod] ; i ; i = Next[i] )
        if( To[i] ^ Fa[Nod] and To[i] ^ Hson[Nod] ) Calc( To[i] ) , Upd( To[i] ) ;
    if( Tag ) Clear( Nod ) ;
}
int main() {
    N = Readin() ;
    Q = Readin() ;
    for(register int i = 0 , U , V , W ; ++i < N ; ) {
        U = Readin() ;
        V = Readin() ;
        W = Readin() ;
        Add( U , V , W ) ;
        Add( V , U , W ) ;
    }
    for(register int i = 0 ; ++i <= Q ; Asks[i] = Readin() ) ;
    Dfs( 1 ) ;
    Dfs( 1 , false ) ;
    for(register int i = 0 ; ++i <= Q ; puts( Anss[i] ? "AYE" : "NAY" ) ) ;
    return 0 ;
}
/*
5 3
1 2 1
1 3 1
2 4 2
2 5 2
1 2 3
*/
```

---

## 作者：Hootime (赞：7)

> 当你不知道怎么解决一道题的时候，给它凭空加一些限制条件，可能就出来了。
>
> ——不知道从哪里听来的一句话

这是点分治的一道模板题。

## 点分治
[OI wiki](https://oi-wiki.org/graph/tree-divide/) 曾说过：_点分治适合处理大规模的树上路径信息问题_。这道题目就是一个树上路径信息问题。

点分治的基本思路是：定一个根，把路径分为三类。
- 以根节点为其中一个端点的；
- 只是经过根节点的；
- 不经过根节点的。

首先弄一棵树出来，定根为 $1$。（这图真大）

![](https://cdn.luogu.com.cn/upload/image_hosting/rghuqv09.png)

容易看出第一类和第二类都与根节点相关，于是我们先处理它们。处理方式因题而异，下面会解释，但是通常我们会把第二类路径拆成两个第一类。

假设我们已经处理完了这些路径，现在还剩第三类路径。这时，根节点已经没有存在的意义了。于是我们把它删了。图变成了这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/gea0e694.png)

这时我们发现图变成了三颗不连通的树。然后，我们就可以贯彻分治思想，递归地处理这三棵树。于是，所有的第三类路径就都被转化成了第一类或者第二类路径。

这就是点分治的思想。

## 题解
以下是这道题目的题解。样例太水，给一组样例：

```
6 5
1 2 2
1 3 4
2 5 3
2 4 7
1 6 8
5
6
9
10
14
```
```
AYE
AYE
AYE
AYE
NAY
```

图例：（就是刚刚的图）  
![](https://cdn.luogu.com.cn/upload/image_hosting/rghuqv09.png)

本题多测，然而给每一个询问跑一遍点分治太麻烦而且可能会被这题的神奇时限卡掉，于是离线掉询问一起处理。

于是我们给路径分类，探讨第一类和第二类路径的处理方法。

- 对于一个第一类路径（一个端点是根的路径）：  
  我们直接对于每一个询问判断是否符合条件。在实现中为了减少码量，我们通常把它与一个根到根的长度为 $0$ 的路径拼成一个第二类路径处理。
- 对于一个第二类路径（一个经过根的路径）：  
  我们把它分成两个第一类路径。然后 DFS 出第一类路径，建立一个 bool 数组（或者 bitset，但是笔者不会用）存储一个距离对应的路径是否存在。然后，遍历询问，对于路径判断**不在该子树内的路径中**有没有长度符合（即为询问要求的长度减去当前路径的长度）的路径。若有，记录答案。

由于此后第一类路径被转化为了第二类路径，下面统称“路径”。

举个例子：

在处理以 $1$ 为根，点集为 $\{1, 2, 3, 4, 5, 6\}$ 的子树时，我们有路径 $1 \to 5$ 满足询问 1 的需求，有路径 $3 \to 2$ 满足询问 2 的需求，有路径 $3 \to 5$ 满足询问 3 的需求，有路径 $6 \to 2$ 满足询问 4 的需求。它们都经过了当前根 $1$。

对于这个过程，实现中直接对**每个子树**跑一遍 DFS 就行了。注意这是一个递归过程，不要跑到已经处理过的点就行了。这里**切记不能偷懒对整体 DFS**，否则你的算法会认为存在 $4 \to 2 \to 1 \to 2 \to 5$ 的路径使得长度为 $14$，满足询问 4。然而，这并不是一个路径。

然后，给当前根节点打一个标记表示已经处理，然后递归处理子树就行了。每次处理的复杂度是 $\mathcal{O}(n)$，期望树高有 $\mathcal{O}(\log n)$，期望复杂度 $\mathcal{O}(n \log n)$。

但是这就完了吗？出题人给你一个链就能把你的算法卡成 $\mathcal{O}(n^2)$。那怎么办？

树上有个东西叫重心，其定义为：_如果在树中选择某个节点并删除，这棵树将分为若干棵子树，统计子树节点数并记录最大值。取遍树上所有节点，使此最大值取到最小的节点被称为整个树的重心。_ 

显然就有性质：_以树的重心为根时，所有子树的大小都不超过整棵树大小的一半。_

于是我们每次定根的时候用 $\mathcal{O}(n)$ 的时间求出重心，以重心为根就可以了。易证树高不大于 $\log n$。于是复杂度就稳在了 $\mathcal{O}(n \log n)$。

就没了。

## 实现
```cpp
#include <bits/stdc++.h>
#define N 100005
#define VAL 10000007
using namespace std;

int to[N<<1], val[N<<1], nxt[N<<1], head[N], gsiz;            // 邻接表 
#define addedge(u,v,w) (++gsiz, to[gsiz]=v, val[gsiz]=w, nxt[gsiz]=head[u], head[u]=gsiz)
int vis[N], siz[N];
int exist[VAL], dis[N], cnt, tmp[N], cntt;                    // exist：存在性；dis, cnt：非当前子树的路径长度；tmp, cntt：当前子树的路径长度 
int query[105], ans[105];                                     // 离线 
int n, m;

inline void dfs1(int u, int fa){                              // 计算子树大小，相信大家都看得懂 
	siz[u] = 1;
	for(int i = head[u]; i; i = nxt[i]){
		int v = to[i];
		if(vis[v] || v == fa) continue;                       // 不能跑到父亲或者已经处理的节点去 
		dfs1(v, u);
		siz[u] += siz[v];
	}
	return;
}

inline void dfs2(int u, int fa, int root, int& minn, int& g){ // 计算重心，想偷懒就直接用引用了 
	int mink = siz[root]-siz[u];                              // 处理父节点方向 
	for(int i = head[u]; i; i = nxt[i]){                      // 处理子节点方向 
		int v = to[i];
		if(vis[v] || v == fa) continue;                       // 不能跑到父亲或者已经处理的节点去 
		mink = max(mink, siz[v]);
		dfs2(v, u, root, minn, g);                            // 顺便就递归了 
	}
	if(mink < minn) minn = mink, g = u;                       // 如果是可能的重心 
	return;
}

inline void dfs3(int u, int fa, int dep){
	if(dep <= 1e7) tmp[++cntt] = dep;                         // 范围中询问小于 1e7，防止 RE 
	for(int i = head[u]; i; i = nxt[i]){
		int v = to[i];
		if(vis[v] || v == fa) continue;                       // 不能跑到父亲或者已经处理的节点去 
		dfs3(v, u, dep+val[i]);
	}
	return;
}

inline void solve(int u){
	cnt = 0, cntt = 0;                                        // 多测不清空，__________ 
	dfs1(u, 0);   
	int minn = 1e9+7, g;                                      // 求重心 
	dfs2(u, 0, u, minn, g);
	vis[g] = true;                                            // 标记一下 
	exist[0] = true, dis[++cnt] = 0;                          // 把自环加进去 
	for(int e = head[g]; e; e = nxt[e]){
		int v = to[e];                                        // 对于每个子树 
		if(vis[v]) continue;                                  // 已经处理的节点去 
		cntt = 0;
		dfs3(v, g, val[e]);                                   // 处理这颗子树的路径 
		for(int i = 1; i <= cntt; ++i)
			for(int j = 1; j <= m; ++j)
				if(query[j]-tmp[i] >= 0)                      // 差小于 0 时强行访问会 RE 
					ans[j] |= exist[query[j]-tmp[i]];         // 统计答案 
		for(int i = 1; i <= cntt; ++i){
			dis[++cnt] = tmp[i];
			if(tmp[i] <= 1e7) exist[tmp[i]] = true;           // ……然后，它们就不是当前子树的路径了。 
		}
	}
	for(int i = 1; i <= cnt; ++i)
		if(dis[i] <= 1e7) exist[dis[i]] = false;              // 这里不能用 memset，不然复杂度就假了 
	for(int i = head[g]; i; i = nxt[i])
	    if(!vis[to[i]]) solve(to[i]);                         // 递归处理 
	return;
}

int main(){
	scanf("%d %d", &n, &m);
	for(int i = 1; i < n; ++i){                               // 输入 
		int u, v, w;
		scanf("%d %d %d", &u, &v, &w);   
		addedge(u, v, w), addedge(v, u, w);
	}
	for(int i = 1; i <= m; ++i)
		scanf("%d", &query[i]);
	solve(1);                                                 // 处理 
    for(int i = 1; i <= m; ++i)                               // 输出 
    	puts(ans[i] ? "AYE" : "NAY");
    return 0;                                                 // CCF NOI 要求 
}

```

### 实现的一些坑
- 如代码 37 行所示，需要特判路径过长的情况；
- 如代码 60 行所示，需要特判负数。

## 致谢
本题解参考了以下文献：
- [OI Wiki - 树分治](https://oi-wiki.org/graph/tree-divide/)
- [OI Wiki - 树的重心](https://oi-wiki.org/graph/tree-centroid/)
- 以及诸多题解、教程与警示后人帖子，在此一并致谢。

若题解有疏漏之处，还请在评论区指出，以便拾遗补缺。另外，[欢迎看一下我的 Blog](https://www.cnblogs.com/hootime/p/18878950)，谢谢。

---

## 作者：lam_dyr (赞：5)

众所周知，点分治是用来解决树上路径问题的一种方法。例如在带权树上询问距离为 $k$ 的点对（本题）或统计距离 $\le k$ 的点对数（P4178）。
### Pre-knowledge——树的重心
- 定义：一棵树的重心是以该点为根时最大子树最小的点。
- 性质
  
  1. 以树的重心为根时，所有子树的大小都不超过整棵树大小的一半。
  2. 树至多有两个重心。如果树有两个重心，那么它们相邻。此时树一定有偶数个节点，且可以被划分为两个大小相等的分支，每个分支各自包含一个重心。
  3. 树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。反过来，距离和最小的点一定是重心。
- 求法：在 dfs 中计算每个子树的大小，记录“向下”的子树的最大大小，利用总点数 - 当前子树（这里的子树指有根树的子树）的大小得到“向上”的子树的大小，最大值的点即为数的重心。
- 代码

```cpp
void dfs(int u,int fa){
	sz[u]=1;
	mx[u]=0;
	for(auto i : g[u]){
		int v=i.fi;
		int w=i.se;
		if(v==fa || vis[v]) continue;
		dfs(v,u);
		sz[u]+=sz[v];
		mx[u]=max(mx[u],sz[v]);
	}
	mx[u]=max(mx[u],tot-sz[u]);
	if(mx[u]<mx[rt]) rt=u;
}
```
## 点分治
本题的暴力求解很简单，只要以每一个点为起始点求得与其他点的距离即可。但这样的时间复杂度显然 $n^2$，考虑优化。

我们先选择一个节点 $p$ 作为跟，则树上两点 $u,v$ 的路径可以分为两类：

1. 经过根节点 $p$
2. 包含于 $p$ 的某一棵子树中

对于第 $1$ 类路径，我们只需要从这个根节点遍历整棵树，求出每个点到根节点的距离，找到满足 $dis_1+dis_2=k$ 的情况即可。

第 $2$ 类路径是点分治的核心。既然 $u\to v$ 的路径不过根节点，我们就不能直接用 $dis_1+dis_2=k$ 的情况来处理，那我们直接换一个根节点，继续找以这个新的根节点为起始的 $1$ 类路径不就行了吗？

现在我们要考虑怎样才能使换根操作最少。首先我们要以每一个点都为根节点遍历一遍，每次遍历我们都需要走满以当前这个点为根节点的这个子树，因此根的选择与子树大小有关。

这个时候就用到我们刚才了解的树的重心的性质 $1$ 了。我们每次选择当前树的重心当作根节点，这样就能保证最多递归 $\log n$ 次，不会被一条链的情况卡掉。

总结一下，点分治的过程就是

1. 求出重心。
2. 以重心为根统计两种路径的贡献。
3. 删除该点并递归子树。

## Code

```cpp
//P3806 【模板】点分治 1
#include <bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define se second
using namespace std;
const int N=1e4+10;
int n,m,rt,cnt,tot;
vector<pii> g[N];
int sz[N],q[N],mx[N];
int vis[N],ins[N],ans[N];
int dis[N],num[N],tmp[N];
void dfs(int u,int fa){
	sz[u]=1;
	mx[u]=0;
	for(auto i : g[u]){
		int v=i.fi;
		int w=i.se;
		if(v==fa || vis[v]) continue;
		dfs(v,u);
		sz[u]+=sz[v];
		mx[u]=max(mx[u],sz[v]);
	}
	mx[u]=max(mx[u],tot-sz[u]);
	if(mx[u]<mx[rt]) rt=u;
}
void find(int u,int fa){
	num[++cnt]=dis[u];
	for(auto i : g[u]){
		int v=i.fi;
		int w=i.se;
		if(v==fa || vis[v]) continue;
		dis[v]=dis[u]+w;
		find(v,u);
	}
}
void calc(int u){
	int t=0;
	for(auto i : g[u]){
		int v=i.fi;
		int w=i.se;
		if(vis[v]) continue;
		cnt=0;
		dis[v]=w;
		find(v,u);
		for(int j=1;j<=cnt;++j){
			for(int k=1;k<=m;++k){
				if(q[k]>=num[j])
					ans[k]|=ins[q[k]-num[j]];
			}
		}
		for(int j=1;j<=cnt;++j){
			ins[num[j]]=1;
			tmp[++t]=num[j];
		}
	}
	for(int i=1;i<=t;++i) ins[tmp[i]]=0;
}
void dfz(int u){
	vis[u]=1;
	ins[0]=1;
	calc(u);
	for(auto i : g[u]){
		int v=i.fi;
		int w=i.se;
		if(vis[v]) continue;
		tot=sz[v];
		mx[rt=0]=1e9;
		dfs(v,u);
		dfz(rt);
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<n;++i){
		int u,v,w;
		cin>>u>>v>>w;
		g[u].push_back({v,w});
		g[v].push_back({u,w});
	}
	for(int i=1;i<=m;++i)
		cin>>q[i];
	tot=n;
	mx[rt]=1e9;
	dfs(1,0);
	dfz(rt);
	for(int i=1;i<=m;++i)
		cout<<(ans[i]?"AYE":"NAY")<<"\n";
	return 0;
}

```

---

## 作者：xuyunao (赞：2)

## P3806 【模板】点分治 1 题解

### 什么是点分治

当一道树上题目可以**离线**，想要求得**子树内**或**路径上**的某些信息时，就可以使用点分治。

来看这道题目。

#### 题目描述

给定一棵有 $n$ 个点的树，询问树上距离为 $k$ 的点对是否存在。

- 对于 $100\%$ 的数据，保证 $1 \leq n\leq 10^4$，$1 \leq m\leq 100$，$1 \leq k \leq 10^7$，$1 \leq u, v \leq n$，$1 \leq w \leq 10^4$。

### 做法

暴力做法非常简单，我们先把询问离线下来，然后用 $O(n^2)$ 去枚举两个点 $u,v$，利用**树上差分**求解，总时间复杂度 $O(n^2\log n)$。

我们考虑以 $u$ 为根的子树内路径都有哪些情况，发现只有两类：

- 经过树的根 $u$，
- 不经过树根，在某棵子树内

不难发现，对于第二种情况，我们可以在**子树内**某个点为树根时统计到它的贡献，因此我们只需要考虑如何计算第一种情况。

首先我们需要求出**子树内每个点到根的距离**，在这里使用 $d$ 数组表示，这样我们就可以使用两条路径拼成一条长的路径。

```cpp
//统计出每个点路径长度
int cnt;
int dis[maxn],d[maxn];
void getdep(int u,int fa)
{
	dis[++cnt] = d[u];
	for(auto nxt : G[u])
	{
		int v = nxt.v;
		int w = nxt.w;
		if(v == fa || vis[v]) continue;
		d[v] = d[u] + w;
		getdep(v,u);
	}
}
```

但是如果两个点 $u,v$ 在树根的同一棵子树内，那么就会产生前面的第二种情况，也就是与自己子树内的点计算贡献。因此我们考虑在计算完当前点与之前点的贡献后，再统一把这棵子树的距离值加进去。

我们使用一个 $dis$ 数组来记录当前树上已经遍历过的路径长度，那么我们每次计算完路径长度，就可以统计答案。

具体的，外层循环枚举路径长度，内层枚举每个询问。  
我们令 $dis[i]$ 表示当前枚举的路径长度，$k$ 表示当前询问的长度，那么我们需要查询长度为 $k - dis[i]$ 的路径是否存在，使用一个桶记录一下就好。

```cpp
int q[maxn];//队列 存储当前子树内产生贡献的点 
bool judge[10000010];//判断一个数是否存在 

void getans(int u)
{
	judge[0] = 1;//长度为0的路径存在，目的是统计长度为k的路径
	int p = 0;//队列长度
	for(auto nxt : G[u])
	{
		int v = nxt.v;
		int w = nxt.w;
		if(vis[v]) continue;
		cnt = 0;//记录路径数量
		d[v] = w;
		getdep(v,u);
		for(int i = 1;i <= cnt;i++)
			for(int j = 1;j <= m;j++)
				if(que[j] >= dis[i]) ans[j] |= judge[que[j] - dis[i]];//统计答案
				
		for(int i = 1;i <= cnt;i++)
		{
			if(dis[i] <= 1e7)
			{
				judge[dis[i]] = 1;
				q[++p] = dis[i];//加入队列
			}
		}
	}
	for(int i = 1;i <= p;i++) judge[q[i]] = 0;//全部处理完后要清空
}
```

要注意，当我们处理完所有子树后，对根的分治就完成了，此时为了避免当前子树内的路径对其它子树产生贡献，我们需要清空它的贡献。注意不要使用 memset，否则时间复杂度就假了。

由于我们需要递归的去做，所以复杂度是和**树的深度与子树大小**密切相关的，因此我们需要找出一种最优的方案，来减少递归。

在树型结构中，**重心**具有很多优秀的性质，删掉重心后，其他的子树都尽可能地保持平衡，最大子树大小最小。

因此我们对一棵子树，选择重心进行点分治，这样对于整棵树，只需要进行 $O(\log n)$ 次。

```cpp
int siz[maxn],f[maxn];//siz子树大小，f最大子树 
int vis[maxn];//表示每个点是否已经被分治过 

//求重心 
void getroot(int u,int fa)
{
	siz[u] = 1;
	f[u] = 0;
	for(auto nxt : G[u])
	{
		int v = nxt.v;
		int w = nxt.w;
		if(vis[v] || v == fa) continue;
		getroot(v,u);
		siz[u] += siz[v];
		f[u] = max(f[u],siz[v]);
	}
	f[u] = max(f[u],s - siz[u]);
	if(f[u] < f[rt]) rt = u;
}
```

到这里基本已经完成了，接下来只需要完善一下分治以及主函数即可。

我们发现点分治大致有四个步骤：  
- 求出当前子树重心
- 求出子树内点到重心的距离
- 统计答案、清空
- 向下分治

到这里，我们已经做完了这道点分治模板题。

**AC Code**

```cpp
#include<bits/stdc++.h>

using namespace std;

const int inf = 0x3f3f3f3f;
const int maxn = 1e4 + 10;

struct note{
	int v,w;
};
vector<note> G[maxn];

int n,m;
int que[maxn];//question 
int s,rt;//存储当前子树大小及重心 
bool ans[maxn];//存储问题答案 

int siz[maxn],f[maxn];//siz子树大小，f最大子树 
int vis[maxn];//表示每个点是否已经被分治过 

//求重心 
void getroot(int u,int fa)
{
	siz[u] = 1;
	f[u] = 0;
	for(auto nxt : G[u])
	{
		int v = nxt.v;
		int w = nxt.w;
		if(vis[v] || v == fa) continue;
		getroot(v,u);
		siz[u] += siz[v];
		f[u] = max(f[u],siz[v]);
	}
	f[u] = max(f[u],s - siz[u]);
	if(f[u] < f[rt]) rt = u;
}

int cnt;
int dis[maxn],d[maxn];

//统计出每个点路径长度 
void getdep(int u,int fa)
{
	dis[++cnt] = d[u];
	for(auto nxt : G[u])
	{
		int v = nxt.v;
		int w = nxt.w;
		if(v == fa || vis[v]) continue;
		d[v] = d[u] + w;
		getdep(v,u);
	}
}

int q[maxn];//队列 存储当前子树内产生贡献的点 
bool judge[10000010];//判断一个数是否存在 

void getans(int u)
{
	judge[0] = 1;
	int p = 0;
	for(auto nxt : G[u])
	{
		int v = nxt.v;
		int w = nxt.w;
		if(vis[v]) continue;
		cnt = 0;
		d[v] = w;
		getdep(v,u);
		for(int i = 1;i <= cnt;i++)
			for(int j = 1;j <= m;j++)
				if(que[j] >= dis[i]) ans[j] |= judge[que[j] - dis[i]];
				
		for(int i = 1;i <= cnt;i++)
		{
			if(dis[i] <= 1e7)
			{
				judge[dis[i]] = 1;
				q[++p] = dis[i];
			}
		}
	}
	for(int i = 1;i <= p;i++) judge[q[i]] = 0;
}

//递归分治
void divide(int u)
{
	vis[u] = 1;//标记当前点 
	getans(u);//统计当前点的答案 
	for(auto nxt : G[u])
	{
		int v = nxt.v;
		int w = nxt.w;
		if(vis[v]) continue;
		s = siz[v];
		f[rt = 0] = inf;
		getroot(v,0);
		divide(rt);
	}
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	for(int i = 1;i < n;i++)
	{
		int u,v,w;
		cin >> u >> v >> w;
		G[u].push_back({v,w});
		G[v].push_back({u,w});
	}
	for(int i = 1;i <= m;i++) cin >> que[i];
	f[rt = 0] = inf; //初始化 
	s = n; //当前子树点的数量 
	getroot(1,0);//找到重心 
	getroot(rt,0);//从重心进行一遍dfs，求出每个点子树大小等信息 
	divide(rt);//分治 
	for(int i = 1;i <= m;i++) //输出答案 
		cout << (ans[i] ? "AYE" : "NAY") << '\n';
	return 0;
}
```
**需要注意的细节：**   

函数调用不要调用错误。  
记得及时清空变量及数组，函数运行前初始化信息。

希望对你有所帮助。

---

## 作者：Zjh6666 (赞：1)

# 边分治
## 算法介绍
**边分治**与点分治类似，都是一种树上分治算法。  
点分治是通过每次寻找树的重心，将一个树分为多个部分，并继续分治下去。边分治则是通过每次寻找**中心边**，将一个树分为两个部分，在对两个部分分别进行分治。
## 正确性证明
### 前置
可以证明：在节点度数均不超过 $$a$$ 时，存在一条中心边，将树分为两个不超过 $$\frac{a-1}{a}n$$ 的子树，利用这一点可以进行边分治。  
**证明**：如图，随意选取一条边 $$(u,v)$$。假设 $$u$$ 一侧的子树大小 $$\ge\frac{a-1}{a}n$$，则 $$v$$ 一侧的子树大小 $$\le\frac{a}{n}$$。由于 $$u$$ 的子树的大小之和 $$\ge\frac{a-1}{a}n$$，且至多有 $$a-1$$ 个子树，假设最大的那一颗子树的根为 $$x$$，那么它的大小 $$\ge\frac{n}{d}$$，选取边 $$(u,x)$$，则分成的两颗子树大小之差是单调下降的。反复这个过程就能找到中心边。  
![](https://cdn.luogu.com.cn/upload/image_hosting/5dze7tvi.png)
### 做法
但是当度数的上限很大时（如菊花图），可以通过添加虚点虚边，将原树改造为一颗度数 $$\le3$$ 树，而且满足对于原树中的路径 $$(x,y)$$ ，改造后的树上的路径 $$(x_1,y_1)$$所包含的边就是原树上路径 $$(x,y)$$ 所包含的边加上若干条虚边。因此，可以进行边分治。
#### 虚边建法：
对每个儿子建一个虚点，这些虚点之间相互连边，第一个虚点与父亲连边。   
![](https://cdn.luogu.com.cn/upload/image_hosting/dc9rmqlk.png)   
变成  
![](https://cdn.luogu.com.cn/upload/image_hosting/efwemygm.png)
## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
struct eg{
	int t,v,id;
};
struct e{
	int xx,yy,v;
}d[40005];
vector<int>vv;
int n,m,x,y,z,sz[40005],tt,pv[40005],s1,s2;
int b[105],t[10000005],as[105],p[40005];
vector<eg>v[40005],vp[10005];
void f1(int x,int fa){
    sz[x]=1;
    for(int i=0;i<v[x].size();i++){
        if(v[x][i].t==fa||p[v[x][i].id]) continue;
        f1(v[x][i].t,x),sz[x]+=sz[v[x][i].t];
    }
    return;
}
int f2(int x,int fa,int nm){
    for(int i=0,pp;i<v[x].size();i++){
        if(v[x][i].t==fa||p[v[x][i].id]) continue;
        pp=f2(v[x][i].t,x,nm);
        if(sz[v[x][i].t]<2*(nm+1)/3&&nm-sz[v[x][i].t]<=2*(nm+1)/3) return v[x][i].id;
        if(pp) return pp;
    }
    return 0;
}
void f(int x,int fa,int ds){
	for(int i=1;i<=m;i++) if(ds<=b[i]&&b[i]-ds<=1e7&&t[b[i]-ds]) as[i]=1;
	for(int i=0;i<v[x].size();i++){
		if(v[x][i].t==fa||p[v[x][i].id]) continue;
		f(v[x][i].t,x,ds+v[x][i].v);
	}
	return;
}
void ff(int x,int fa,int ds){
	if(ds<=1e7) t[ds]=1,vv.push_back(ds);
	for(int i=0;i<v[x].size();i++){
		if(v[x][i].t==fa||p[v[x][i].id]) continue;
		ff(v[x][i].t,x,ds+v[x][i].v);
	}
	return;
}
void bfz(int x){
	if(!x) return;
	p[x]=p[x&1]=1;
	ff(d[x].yy,d[x].xx,0);
	t[0]=t[d[x].v]=1;
	f(d[x].xx,d[x].yy,d[x].v),t[d[x].v]=0;
	for(int i=0;i<vv.size();i++) t[vv[i]]=0;
	vv.clear(); 
	f1(d[x].xx,d[x].yy),bfz(f2(d[x].xx,d[x].yy,sz[d[x].xx]));
	f1(d[x].yy,d[x].xx),bfz(f2(d[x].yy,d[x].xx,sz[d[x].yy]));
	return;
}
void dfs(int x,int fa){
	if(vp[x].size()==1&&fa) return;
	pv[x]=x;
	for(int i=0;i<vp[x].size();i++){
		if(vp[x][i].t==fa) continue;
		v[pv[x]].push_back({++n,0,++tt}),v[n].push_back({pv[x],0,++tt}),pv[x]=n;
		v[n].push_back({vp[x][i].t,vp[x][i].v,++tt}),v[vp[x][i].t].push_back({n,vp[x][i].v,++tt});
		dfs(vp[x][i].t,x);
	}
	return;
}
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<n;i++){
    	cin>>x>>y>>z;
		vp[x].push_back({y,z}),vp[y].push_back({x,z});	
	}
	dfs(1,0);
	for(int i=1;i<=n;i++) for(int j=0;j<v[i].size();j++) d[v[i][j].id]={i,v[i][j].t,v[i][j].v};
    for(int i=1;i<=m;i++) cin>>b[i];
	f1(1,0),t[0]=1;
	bfz(f2(1,0,n));
	for(int i=1;i<=m;i++){
		if(as[i]) cout<<"AYE\n";
		else cout<<"NAY\n";
	}
    return 0;
}
```
跑得挺快的，最慢的点不到 $$60ms$$ 。

---

## 作者：yanmingqian (赞：0)

# 算法介绍

通常用于处理在**无根树**上对路径静态统计的题目。

对于一颗树上的路径，设根节点为 $root$，则路径可以分为两类：经过根节点的和不经过根节点的。经过根节点的可以从根节点断开变成两条链，不经过的显然一定在某棵子树中，可以递归求解。

考虑怎么递归。如果你直接往下走复杂度会被卡到 $O(n^2)$。因此我们考虑重心。如果一棵树中将一个点删除后，分开的各个子树中最大的最小，则该点为重心。根据重心的性质，重心分成的各个子树的大小不超过原树大小的一半，因此这样可以做到 $O(n \log n)$。

求重心：

```cpp
int root,siz[N],maxp[N],sum;  //当前根，子树大小，删除当前节点后最大子树大小，当前子树总节点数
void get_root(int u,int fa){  //求根，也就是求重心
    siz[u]=1;maxp[u]=0;
    for(int i=head[u];i;i=nxt[i]){
        int vv=v[i];
        if(vv==fa||vis[vv]) continue;
        get_root(vv,u);
        siz[u]+=siz[vv];
        maxp[u]=max(maxp[u],siz[vv]);
    }
    maxp[u]=max(maxp[u],sum-siz[u]);  //考虑删除u后父亲节点一侧子树的大小
    root=(maxp[root]<maxp[u]?root:u);  //更新重心
}
```

递归各个子树：

```cpp
void work(int u){
    vis[u]=1;
    calc(u);  //计算
    for(int i=head[u];i;i=nxt[i]){  //对每棵子树递归求解
        int vv=v[i];
        if(vis[vv]) continue;
        maxp[root=0]=sum=siz[vv];get_root(vv,0);  //求子树的重心
        work(root);
    }
}
```

`calc()` 函数需要根据题目需要修改。以本题为例：

我们可以通过简单的 dfs 求可能的距离。将它们记录到桶中，假设我们已经知道了长度为 $d_i$ 的路径存在，现在要确定长度为 $k$ 的路径是否存在，显然存在一条长度为 $k-d_i$ 的路径，且这两条路径在同一子树中且可以通过子树的根相连接，长度为 $k$ 的路径就存在。因此在 `calc()` 函数中，我们可以先求出当前子树中各个点到达当前根节点的长度，然后按上面说的判断记录即可。

# 正确性证明

比较显然。时间复杂度前面提了，根据重心的性质，重心分成的各个子树的大小不超过原树大小的一半，是 $O(n \log n)$ 的。

当然，为了保证时间复杂度正确，进行桶的清空时需要额外开一个数组记录桶里面哪些地方需要清空。如果直接 `memset` 的话时间复杂度是假的。以及桶只开到 $10^7$（因为题目中查询的数最大不超过 $10^7$），所以如果当前查询的长度超过了这个值，直接跳过即可。

# 代码实现

放一下完整代码。

```cpp
#include<iostream>
#include<vector>
using namespace std;
const int N=1e4+10;
int head[N],v[N<<1],w[N<<1],nxt[N<<1],idx;
void add(int x,int y,int z){
    v[++idx]=y;
    w[idx]=z;
    nxt[idx]=head[x];
    head[x]=idx;
}
int n,q;
int ask[110];  //询问的数
int root,siz[N],maxp[N],sum;  //当前根，子树大小，删除当前节点后最大子树大小，当前子树总节点数
bool vis[N];
bool ans[N];
void get_root(int u,int fa){  //求根，也就是求重心
    siz[u]=1;maxp[u]=0;
    for(int i=head[u];i;i=nxt[i]){
        int vv=v[i];
        if(vv==fa||vis[vv]) continue;
        get_root(vv,u);
        siz[u]+=siz[vv];
        maxp[u]=max(maxp[u],siz[vv]);
    }
    maxp[u]=max(maxp[u],sum-siz[u]);  //考虑删除u后父亲节点一侧子树的大小
    root=([root]<maxp[u]?root:u);  //更新重心
}
int d[N],dis[N],cnt;
void get_dis(int u,int fa){
    d[++cnt]=dis[u];
    for(int i=head[u];i;i=nxt[i]){
        int vv=v[i];
        if(vv==fa||vis[vv]) continue;
        dis[vv]=dis[u]+w[i];
        get_dis(vv,u);
    }
}
vector<int> vec;  //记录桶中记录的下标，方便后续清空桶
bool t[10000010];  //桶，是否存在该长度的路径
void calc(int u){
    vec.clear();
    t[0]=1;
    for(int i=head[u];i;i=nxt[i]){
        int vv=v[i];
        if(vis[vv]) continue;
        dis[vv]=w[i];
        cnt=0;
        get_dis(vv,0);  //统计以v为根的子树中各个点到达u的路径条数(cnt)和长度(dis[])
        for(int j=1;j<=cnt;j++){
            for(int k=1;k<=q;k++){
                if(ask[k]<d[j]) continue;
                ans[k]|=t[ask[k]-d[j]];  //d[j]存在，若桶中(ask[k]-d[j])也存在，则长度为ask[k]的存在
            }
        }
        for(int j=1;j<=cnt;j++){
            if(d[j]>1e7) continue;
            if(!t[d[j]]){
                t[d[j]]=1;
                vec.push_back(d[j]);  //记录有哪些下标需要清空
            }
        }
    }
    for(int i=0;i<vec.size();i++) t[vec[i]]=0;  //清空桶
}
void work(int u){
    vis[u]=1;
    calc(u);  //计算经过根的路径
    for(int i=head[u];i;i=nxt[i]){  //对每棵子树递归求解
        int vv=v[i];
        if(vis[vv]) continue;
        maxp[root=0]=sum=siz[vv];get_root(vv,0);  //求子树的重心
        work(root);
    }
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>q;
    for(int i=1;i<n;i++){
        int x,y,z;
        cin>>x>>y>>z;
        add(x,y,z);add(y,x,z);
    }
    for(int i=1;i<=q;i++){
        cin>>ask[i];
    }
    maxp[root]=sum=n;get_root(1,0);  //第一次找整树重心
    work(root);
    for(int i=1;i<=q;i++){
        cout<<(ans[i]?"AYE\n":"NAY\n");
    }
    return 0;
}
```

---


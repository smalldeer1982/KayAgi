# 花园

## 题目描述

小 L 有一座环形花园，沿花园的顺时针方向，他把各个花圃编号为 $1 \sim n$。花园 $1$ 和 $n$ 是相邻的。

他的环形花园每天都会换一个新花样，但他的花园都不外乎一个规则：任意相邻 $m$ 个花圃中都只有不超过 $k$ 个 C 形的花圃，其余花圃均为 P 形的花圃。

例如，若 $n=10$ , $m=5$ , $k=3$ ，则

- `CCPCPPPPCC` 是一种不符合规则的花圃。
- `CCPPPPCPCP` 是一种符合规则的花圃。

请帮小 L 求出符合规则的花园种数对 $10^9+7$ 取模的结果。

## 说明/提示

#### 数据规模与约定

- 对于 $40\%$ 的数据，保证 $n \le 20$。
- 对于 $60\%$ 的数据，保证 $m=2$。
- 对于 $80\%$ 的数据，保证 $n \le 10^5$；
- 对于 $100\%$ 的数据，保证 $2 \leq n \le 10^{15}$，$2 \leq m \leq \min(n, 5)$，$1 \leq k \lt m$。

## 样例 #1

### 输入

```
10 5 3
```

### 输出

```
458```

## 样例 #2

### 输入

```
6 2 1
```

### 输出

```
18```

# 题解

## 作者：五更琉璃 (赞：51)

先考虑普通的DP，因为 $m \leq 5$，可以状压。

从第二个样例来看，$m=2,k=1$，有状态 

$$00  \rightarrow \begin{cases} \_00 \\ \_01 \end{cases}$$

$$01 \rightarrow \begin{cases} \_10 \end{cases}$$

$$10 \rightarrow \begin{cases} \_00 \\ \_01\end{cases}$$

可以知道前状态的最右几位要和后状态相同，不过最前面的一位被挤出去了，有没有摆C花没有关系， $01$ 皆可，因此设前状态为 $i$，后状态为 $j$，可以得到 $i,j$ 关系：

$$i = \begin{cases} j >> 1 \\ (j >>1) \ | \ (1 << (m - 1))  \end{cases}$$

另设 $f[i][j]$ 为到第 $i$ 盆花，前面 $m$ 盆的状态为 $j$，可以由上面的关系得到DP方程：

$$f[i][j]  =f[i][j] + \begin{cases} f[i - 1][j>>1] \\ f[i - 1][(j >> 1) \ | \  (1 << ( m - 1) ) \end{cases}$$

需要判一下第二个转移的前状态是否合法。

然后要处理环形的问题，可以简单的短环成链，然后对于给定初状态 $f[0][s]$ ，统计DP后的 $f[n][s]$ 计入答案。这是因为这样对于一个长度为 $n$ 的环， $i=0$ 和 $i=n$ 是等价的，所以 $j_0,j_n$ 相同的时候就是一个合法的环。

依照这个思路写出40分代码:

```cpp

#include <bits/stdc++.h>

int f[100000][1 << 5];
int n, m, K;
int t, ans;
int main() {
    n = read(); m = read(); K = read();
    t = (1 << m) - 1;
    for (int statu = 0; statu <= t; ++statu) {
        if (__builtin_popcount(statu) > K) continue;
        memset(f, 0, sizeof(f));
        f[0][statu] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j <= t; ++j) {
                f[i][j] += f[i - 1][j >> 1];
                if (__builtin_popcount((j >> 1) | (1 << (m - 1))) <= K)
                    f[i][j] += f[i - 1][(j >> 1) | (1 << (m - 1))];
            }
        }
        ans += f[n][statu];
    }

    printf("%d\n", ans);
    return 0;
}
\\ 不知道__builtin_popcount() 的可以自行百度，这是好东西
```

然后想着 $f[i][j]$ 只和 $f[i - 1][k]$ 有关，所以第一维 $[i]$ 可以滚动优化掉，然后按照这个 $n$ 的范围肯定是得上矩阵乘法的，试着构造转移矩阵。还是以上面的 $m=2,k=1$ 为例，状态转移还是一样的，设 $f[i]$ 为状态为 $i$ 时的方案数， 由 $f[i]$ 推出 $f'[i]$ ，就是下一轮的 $f[i]$；得到方程：

$$\begin{cases} f'[00] = f[00] + f[10] \\ f'[01] = f[00] + f[10] \\ f'[10] = f[01] \\ f'[11] = 0 \end{cases}$$

构造出转移矩阵： 

$$\begin{bmatrix} 1 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 1 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix}$$

对于任意的 $m,k$，也可以通过前后 $i,j$ 两个状态的关系，令转移矩阵中的 $mat[i][j] = 1$，构造出转移矩阵。

另外还有一点，对于之前每一个状态做一遍DP，现在我们有了矩阵，就没有必要对于 $f[0][0] = 1, f[0][1] = 1, \ldots ,f[0][(1 << m) - 1]$ 各做一次的必要了，可以把初始矩阵的第一维利用起来，即令 $f[0][0] = 1,f[1][1]=1, \ldots ,f[i][i] = 1$ 可以让每一种初状态并行处理，每一行中就是我们要的初状态只有一种的一轮DP。然而根据矩阵乘法的性质，这个矩阵乘上任意矩阵都等于所乘的矩阵，也就是说是一个单位矩阵，所以乘不乘没差，那么我们所求的答案就是转移矩阵自乘之后 $\sum_{i=0}^{2^m - 1} mat[i][i]$。

AC代码：

```cpp
#include <bits/stdc++.h>
typedef long long lint;

inline lint read() {
	lint x = 0, f = 0; char c = getchar();
	for (; c < '0' || c > '9'; c = getchar()) if (c == '-') f = 1;
	for (; c >= '0' && c <= '9'; c = getchar()) x = (x << 3) + (x << 1) + (c ^ 48);
	return f ? -x : x;
}

const int p = 1e9 + 7;
lint n;
int m, K;
int t, ans;

struct mat {
	int row, col;
	int a[32][32];
	mat() {
		memset(a, 0, sizeof(a));
	}
	void init() {
		*this = mat();
		row = col = t;
		for (int i = 0; i < t; ++i)
			a[i][i] = 1;
	}
	mat operator * (const mat &x) const {
		mat ans = mat(); ans.row = row; ans.col = col;
		for (int i = 0; i < row; ++i) 
			for (int j = 0; j < col; ++j)
				for (int k = 0; k < col; ++k)
					(ans.a[i][j] += (1ll * a[i][k] * x.a[k][j]) % p) %= p;
		return ans;
	}
	mat operator ^ (lint n) {
		mat ans = mat(); 
		ans.init();
		mat base = *this;
		for (; n; n >>= 1, base = base * base)
			if (n & 1) ans = ans * base;
		return ans;
	}
} ;

int main() {
	n = read(); m = read(); K = read();
	t = 1 << m;
	mat b = mat(); b.row = b.col = t;
	for (int i = 0, j; i < t; ++i) {
		if (__builtin_popcount(i) > K) continue;
		j = i >> 1;
		// j -> i
		b.a[j][i] = 1;
		j = (i >> 1) | (1 << (m - 1));
		if (__builtin_popcount(j) <= K)
			b.a[j][i] = 1;
	}

	mat c = (b ^ n);
	for (int i = 0; i < t; ++i) {
		ans = (ans + c.a[i][i]) % p;
	}
	printf("%d\n", ans);
	return 0;
}
```
$p.s.$ 前文 $f,i,j$ 重复使用的太多了，不要把意义混起来了。另代码中的 $i,j$ 和前面推矩阵时的 $i,j$ 时相反的。

---

## 作者：litble (赞：40)

我们用一个m位二进制数表示后m个花圃的状态，1表示为M.

那么令t(i,j)表示由状态i转移到状态j的方案数（i和j都合法，即1的个数不超过k）。所谓转移，是指如果i表示第1～第m个花圃的状态，那么j代表第2～第m+1个花圃的状态。

一开始两个合法转移状态之间t(i,j)=1,合法转移状态为j右移一位，在左边添加一个1（或不添加）为i，这个可以dfs搞出来。

然后我们会发现i转移到j，可以看作i先转移到一个状态k，再由k转移到j，这是一个满足结合律的floyed类型的式子，可以用矩阵快速幂来搞。

由于所有的花圃是一个环，所以第1～m个花圃就是第n+1~n+m个花圃，所以我们求的答案就是一个合法状态转移n次，转移回原状态的方案数之和。

有点玄学.....不知道我讲明白没.....

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define LL long long
LL n,m,k,lim,mod=1000000007,ans;
struct node{LL t[64][64];}re,x;
int ok[64],bin[6];//ok：是否是合法状态
void work(int zt,int num) {//计算初始合法转移
    ok[zt]=1;int kl=zt>>1;
    x.t[kl][zt]=1;
    if(num==k&&!(zt&1)) return;
    x.t[kl+bin[m]][zt]=1;
}
void dfs(int x,int num,int zt) {
    if(x==m+1) {work(zt,num);return;}
    dfs(x+1,num,zt);
    if(num<k) dfs(x+1,num+1,zt|bin[x]);
}
node operator * (node a,node b) {
    int i,j,k;node c;
    for(i=0;i<=lim;++i)
        for(j=0;j<=lim;++j) {
        c.t[i][j]=0;
        for(k=0;k<=lim;++k)
            c.t[i][j]+=a.t[i][k]*b.t[k][j]%mod,c.t[i][j]%=mod;
    }
    return c;
}
void ksm() {//快速幂
    int bj=0;
    while(n) {
        if(n&1) {
            if(!bj) re=x,bj=1;
            else re=re*x;
        }
        x=x*x;n>>=1;
    }
}
int main()
{
    bin[1]=1;for(int i=2;i<=5;++i) bin[i]=bin[i-1]<<1;
    scanf("%lld%lld%lld",&n,&m,&k);
    lim=(1<<m)-1;dfs(1,0,0);ksm();
    for(int i=0;i<=lim;++i) if(ok[i]) ans+=re.t[i][i],ans%=mod;//答案统计
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：vectorwyx (赞：17)

蒟蒻第一次独立做出紫题也是第一次写紫题的题解呢/kk，还请多多包涵qwq


------------
> 还是那句话：dp考虑三件事：状态、转移、初始化

## 一.状态
蒟蒻一开始看这道题的时候，第一反应是令 $dp_{i,j,0/1}$ 表示考虑到第 $i$ 个花圃，$[i-m+1,i]$ 这段区间有 $j$ 个 C 形花圃，且第 $i-m+1$ 个花圃是 P 还是 C 的方案数（0代表 P，1代表 C）。

然而，显然我们在转移时会用到第 $i-m+2$ 个花圃的状态，然后又会用到第 $i-m+3$ 个花圃的状态………这些我们都是无法得知的，因此无法进行转移，这个定义是错误的╮(╯▽╰)╭。

不过，想到了这一步，那么真正的状态定义也就呼之欲出了：既然我们需要用到 $[i-m+1,i]$ 这段区间中所有花圃的状态，那我们直接把它放在 $dp$ 中来转移不就行了！记录状态……不就是状压吗！因此，这道题正确的状态定义是令 $dp_{i,j}$ 表示考虑到第 $i$ 个花圃，区间 $[i-m+1,i]$ 中花圃的状态是 $j$，其中 $j$ 是一个二进制数。

## 二.转移
考虑最暴力的转移，我们需要枚举一下前一个位置的所有可能情况，转移方程为$dp_{i,j}=\sum_{k=0}^{2^{m}-1} dp_{i-1,k}\times Z_{k,j}$，其中 $Z_{k,j}$ 表示状态 $j$ 能否合法地“接到”状态 $k$ 的后面。这个可能有点难理解，我们来举个例子（图有点丑，凑活着看吧QAQ）：

![](https://cdn.luogu.com.cn/upload/image_hosting/cp0apy32.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

在这个例子中，我们需要从 $i-1$ 转移到 $i$，那么，如果 $i$ 的状态 $j$ 是`00100`，显然 $i-1$ 的状态 $w$ 只能是`00010`或`10010`。换句话说，$dp_{i-1,w}$ 能转移到 $dp_{i,j}$当且仅当 $j$ 的前 $m-1$ 位和 $w$ 的后 $m-1$ 位相同，且 $j$ 和 $k$ 中1的数量都小于等于 $k$。

不过，这样的转移是 $O(n\times2^{2m})$ 的，当 $n\le 1e15$ 时肯定会爆，因此需要加点优化。

我们再观察一下转移方程： $dp_{i,j}=\sum_{k=0}^{2^{m}-1} dp_{i-1,k}\times Z_{k,j}$。

令$p=2^{m}-1$，这其实就等价于 $dp_{i}=dp_{i-1}\times Z$，其中 $dp_{i},dp_{i-1}$ 是 $1\times p$ 的矩阵，$Z$ 是 $p \times p$ 的矩阵。再进一步，$dp_{n}=dp_{1}\times Z^{n-1}$，套一个矩阵快速幂就能用 $O(p^3\times \log{n})$ 的复杂度求解。

但是还有一个问题我们没有处理，那就是环。我们可以把后$m-1$ 个位置复制一份插入到第一个位置的前面，然后枚举一下新形成的前 $m$ 个位置的状态 $i$，每次枚举对于总方案数的贡献就是$dp_{n+1,i}$。

## 三.初始化
对于当前枚举的状态 $i$，令 $dp_{1,i}$ 为1，其余为0，然后直接乘上 $Z^{n}$。

-----
总时间复杂度为$O(p^{4} + p^{3}\log{n})$，稳过。

代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
#define fo(i,x,y) for(register int i=x;i<=y;++i)
#define go(i,x,y) for(register int i=x;i>=y;--i)
using namespace std;

const int maxn=32,yrz=1e9+7;
//要注意一点：我们这里的矩阵的下标是从0开始存储的，因此在重载矩乘运算符和清零矩阵时要格外小心 
struct Mat{
	int n,m;
	int a[maxn][maxn];
	Mat(){n=m=-1,memset(a,0,sizeof a);} 
	void zero(){
		fo(i,0,n)fo(j,0,m) a[i][j]=0;
		n=m=-1;
	}
}I,A,B,C,F,Z,ret;

Mat operator*(const Mat &x,const Mat &y){
	ret.zero();
	ret.n=x.n,ret.m=y.m;
	fo(i,0,ret.n)
		fo(j,0,ret.m)
			fo(k,0,x.m) ret.a[i][j]=(ret.a[i][j]+1ll*x.a[i][k]*y.a[k][j]%yrz)%yrz;
	return ret;
}

Mat ksm(const Mat &x,ll y){//矩阵快速幂 
	if(y==0) return I;
	A=ksm(x,y/2);
	A=A*A;
	if(y&1) A=A*x;
	return A;
}

ll n;
int m,k,p,ans,count[32];

int main(){
	cin>>n>>m>>k;
	p=(1<<m)-1;
	fo(i,0,p)
		fo(j,0,m-1) if(i&(1<<j)) count[i]++;//count[i]表示i这个二进制数中有多少个1 
	I.n=I.m=p;//单位矩阵 
	fo(i,0,p) I.a[i][i]=1;
	Z.n=Z.m=p;//预处理出Z数组 
	fo(i,0,p){
		if(count[i]>k) continue;
		fo(j,0,p){
			if(count[j]>k) continue;
			Z.a[i][j]=((i&((1<<(m-1))-1))==(j>>1));//取i的后i位与j的前i位相比较 
		}
	}
	F.n=0,F.m=p;
	B=ksm(Z,n);//Z不变，因此Z的n次方也不变 
	fo(i,0,p){//枚举最前面的m位的所有可能状态 
		if(count[i]>k) continue;
		F.a[0][i]=1;
		C=F*B;
		ans=(ans+C.a[0][i])%yrz;//计算贡献 
		F.a[0][i]=0;
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：TsReaper (赞：12)

据说是NOIP福建省夏令营的题目，这也太狠了...

一道递推的题目，记f(i,s)为当前考虑到第i个花圃，（包括第i个花圃）前m个花圃状态为s的方案数（s是用一个二进制数表示状态，0为P形花圃，1为C形花圃）。状态间的转移还是比较明显的，就是去掉最后一个花圃，再在最开头加上一个花圃，而加上的花圃可能是0也可能是1，举几个例子。

f(i,1011) = f(i-1,0110) + f(i-1,0111)

f(i,0011) = f(i-1,0110) + f(i-1,0111)

关于初值，由于花园是环形的，所以1~m号花圃会对n-m+2~n号花圃产生影响。为了确定产生的到底是什么样的影响，我们就需要枚举1~m号花圃的状态，对每种状态进行一次递推。设1~m号花圃的状态为s，则最终答案就是f(n+m,s).

但是n ≤ 10^15有点太大了，就需要用矩阵快速幂加速递推。


---

## 作者：天泽龟 (赞：9)

好像没有从$m<=2$角度出发的题解，我来补充一篇。

一开始想搞这个部分分的原因是很像组合数学啥的想去练练，结果跑到群里一问被`@CYJian`直接钦点出正解了，ORZ。

---

### 对于$m\leq 2$：

题意转换为： 给定大小为$n$的环形花圃，种满$C$和$P$且满足不存在有相邻$C$，问满足条件的方案数。

由于$N$很大，组合数学的话还是吃不消的（不知道$n\leq 10^5$会不会有新的解法）。考虑找个递推式，然后用矩阵加速搞。

由于环形很讨厌，所以我们先考虑链的情况。**我们设$f0[i][0/1]$为首项是$P$，已经确定至第$i$个元素且最后一个是$P/C$时，满足条件方案数** ，再设$f1[i][0/1]$为首项是$C$，其他同上的方案数。
那么初始情况显然：
$$f1[1][1]=1,f1[1][0]=0,f0[1][1]=0,f0[1][0]=1$$

然后递推式易得：
$$f0[i][0]=f0[i-1][1]+f0[i-1][0]$$
$$f0[i][1]=f0[i-1][0]$$

你可以理解为若上一个不是$C$的话这次选啥都行，上一个是$C$就只能是$P$了。不给$f1$的递推式了，如出一辙，只是因为他俩初始情况不同所以进行了区分。

然后发现答案$f1[n][1]$首尾$C$相连，是非法的，把这个答案去掉，这样就有$50$分了。

再想想，发现递推式只和上一项有关，滚掉后可以搞矩阵加速了，构造矩阵为：
$$\begin{bmatrix}1&1\\0&1\end{bmatrix}*\begin{bmatrix}f_{0}\\f_{1}\end{bmatrix}=\begin{bmatrix}f_{0}+f_1\\f_0\end{bmatrix}$$

~~很像斐波拉契的构造矩阵对吧。~~ 然后就没了，上我丑陋的代码，期望$60$：
```cpp
#include <iostream>
#include <cstring>
#define inf 2147483647
#define ll long long
using namespace std;

const ll mo=1e9+7;
ll n,m,k,f0[3][3],f1[3][3]; 
ll ans[5][5],w[5][5];
//f0[i][j]：首项是0，到了第i项时当前为j的方案数。 

void mi()
{
	ll kp[5][5]={0};
	for (int i=1;i<=2;i++)	for (int j=1;j<=2;j++) {
		kp[i][j]=0;
		for (int k=1;k<=2;k++) kp[i][j]=(kp[i][j]%mo+ans[i][k]%mo*w[k][j]%mo)%mo;
	}
	
	
	for (int i=1;i<=2;i++)
	for (int j=1;j<=2;j++) ans[i][j]=kp[i][j];
}

void zc()
{
	ll kp[5][5]={0};
	for (int i=1;i<=2;i++) for (int j=1;j<=2;j++)
	{	kp[i][j]=0;
		for (int k=1;k<=2;k++) kp[i][j]=(kp[i][j]%mo+w[i][k]*w[k][j]%mo)%mo;
	}
	for (int i=1;i<=2;i++)
	for (int j=1;j<=2;j++) w[i][j]=kp[i][j];
}

void ksm(ll k)
{
	ans[1][1]=ans[2][2]=1;  w[1][1]=w[1][2]=w[2][1]=1; 
	while (k){ if (k&1) mi(); k/=2; zc(); }
}

ll print()
{
	ll kp[5][5]={0},kP[5][5]={0};
	for (int i=1;i<=2;i++) for (int j=1;j<=2;j++)
	{
		for (int k=1;k<=2;k++) 
			kp[i][j]=(kp[i][j]%mo+(ans[i][k]%mo*f0[k][j])%mo)%mo,
			kP[i][j]=(kP[i][j]%mo+(ans[i][k]%mo*f1[k][j])%mo)%mo;
	}
	ll ans=(kp[1][1]%mo+kp[2][1]%mo+kP[1][1]%mo)%mo; return ans;
}

int main()
{
	cin>>n>>m>>k; 
	f0[1][1]=1; f0[2][1]=0; f1[1][1]=0; f1[2][1]=1;
	ksm(n-1);
	cout<<print()<<endl;
}
```
我知道我代码丑，没学过封装，打扰了。

### 对于全部数据：

这个别的题解说的很详细了，我简单提一嘴。

我们设$f[i][S]$为到了第i项，且最后$M$个状态为$S$的方案数，类比上式也可以搞出来递推式：

$$f[i][S]=f[i-1][S>>1]+f[i-1][S>>1~|~( 1<<(m-1) )]$$

有点长但不难理解，就是把第$i$项状态右移，再用`0/1`代替最前面新增的一项，这样就是$i-1$时的可能转移来的状态了（第二项可能非法）。

老样子，第一维滚掉，对于第二维套矩阵加速。我们知道这个构造矩阵的第$(i,j)$项其实就代表了 **$ans[i]$递推累加时是否包含了$a[j]$** ，而对于这题，当且仅当两个状态合法且满足递推式时可以被转移。所以只需要预处理判断$S$和$S>>1$，$S>>1~|~( 1<<(m-1) )$的合法性，然后在构造矩阵上标记即可。

在最后，我们只需乘上初始矩阵就完成了。这里有个小技巧（或者说正解），我们考虑初始矩阵$f[M][S]$长啥样，发现仅当$S$合法时候值才为1，否则是0，那我们大可不需要再搞个`print`函数，直接判断初始$S$是否合法，答案就是：
$$\sum_{0\leq S\leq 2^m-1} ^{\text{合法S}}ans[S][S]$$ 

详情见我丑陋的代码：
```cpp
#include <iostream>
#include <cstring>
#define inf 2147483647
#define ll long long
using namespace std;

const ll mo=1e9+7;
ll n,m,k,N; 
ll ans[33][33],w[33][33],a[33][33];
//f0[i][j]：首项是0，到了第i项时为j的条件方案数。 


void mi()
{
	ll kp[33][33]={0};
	for (int i=0;i<N;i++)	for (int j=0;j<N;j++) {
		kp[i][j]=0;
		for (int k=0;k<N;k++) kp[i][j]=(kp[i][j]%mo+ans[i][k]*w[k][j]%mo)%mo;
	}
	for (int i=0;i<N;i++)
	for (int j=0;j<N;j++) ans[i][j]=kp[i][j];
}

void zc()
{
	ll kp[33][33]={0};
	for (int i=0;i<N;i++) for (int j=0;j<N;j++)
	{	kp[i][j]=0;
		for (int k=0;k<N;k++) kp[i][j]=(kp[i][j]%mo+w[i][k]*w[k][j]%mo)%mo;
	}
	for (int i=0;i<N;i++)
	for (int j=0;j<N;j++) w[i][j]=kp[i][j];
}

void ksm(ll k)
{
	for (int i=0;i<N;i++) ans[i][i]=1; 
	while (k){ if (k&1) mi(); k/=2; zc(); }
}

int check(int x)  //初赛学到的可快速算二进制中1的函数. 
{	int sm=0;
	while (x){ x= x&(x-1); sm++; }
	return sm;
}

int main()
{
	cin>>n>>m>>k; N=(1<<m);
	for (int i=0;i<N;i++) if (check(i)<=k)  //预处理构造矩阵 
	{
		int j=i>>1; w[j][i]=1; 
		j|=(1<<(m-1)); if (check(j)<=k) w[j][i]=1;
	}
	ksm(n); ll sm=0;
	for (int i=0;i<N;i++) 
		if (check(i)<=k) sm=(sm+ans[i][i])%mo;
	cout<<sm<<endl;
}

```

---

## 作者：巨型方块 (赞：9)

http://blog.csdn.net/largecub233/article/details/73457992

博客^\_^


简单来说，这一题就是一个状压dp用矩阵优化；

但是这个矩阵也是最最最基础的矩阵了（floyd矩阵）；

dp的话，和第一个题解hi一样的；

f[i][s]表示第i位时的方案，s为i~i-m+1的状态

然后转移的时候我们枚举i枚举2个s


```cpp
if(v[j][k])f[i][j]=(f[i][j]+f[i-1][k])%mo;
```

这里的v[j][k]表示状态j是否可以转移到状态k；

这个数组是一开始直接暴力预处理的；

那么我的70分的代码（无滚存）


```cpp
#include<bits/stdc++.h>
#define Ll long long
using namespace std;
bool v[64][64],ok[64];
int bb[10],b[10];
Ll f[100010][64];
Ll n,m,k,w,ans,mo=1e9+7;
void check(){
    int x=0,y=0;
    for(int i=1;i<=m;i++)x=x*2+b[i];
    for(int i=2;i<=m+1;i++)y=y*2+b[i];
    for(int i=1;i<=m+1;i++)bb[i]=bb[i-1]+b[i];
    for(int i=m;i<=m+1;i++)
        if(bb[i]-bb[i-m]>k)return;
    v[x][y]=1; ok[x]=ok[y]=1;
}
void dfs(int x){
    if(x>m+1){check();return;}
    b[x]=1;dfs(x+1);
    b[x]=0;dfs(x+1);
}
void work(int x){
    memset(f,0,sizeof f);
    f[m][x]=1;
    for(int i=m+1;i<=n+m;i++)
        for(int j=0;j<=w;j++)
            for(int k=0;k<=w;k++)
                if(v[j][k])f[i][j]=(f[i][j]+f[i-1][k])%mo;
    ans=(ans+f[n+m][x])%mo;
}
int main()
{
    scanf("%lld%lld%lld",&n,&m,&k);
    w=(1<<m)-1;
    dfs(1);
    for(int i=0;i<=w;i++)if(ok[i])work(i);
    printf("%lld",ans);
}
```
然后矩阵快速幂直接套上去就好了；

就是把那个v[][]直接自乘n次，然后算答案；

代码就不发了吧




---

## 作者：Light_snow (赞：5)

# 算法
[更好的阅读体验](https://www.cnblogs.com/dixiao/p/13849461.html)

我们发现题目中$m < 5$很小。

所以我们可以使用二进制压缩。

我们用$1$来表示$C$ 用$0$表示$P$,我们压缩的是当前这个状态的最后$m$位的状态 比如后$m$位是$CCPP$则压缩为$(1100)_2$这个数。

接下来我们讨论一下状态如何转移：


首先好像我对于一个状态的转移和其他题解的方法不大相同。
我对于一个状态向其他状态的转移是这样的：
```
now_0 = (now << 1) & ((1 << m) - 1);
now_1 = (now << 1) & ((1 << m) - 1) + 1;

```
这个转移可能是更加符合题目的意思吧。
举个栗子：

就如题目中所给的例子 $m = 2\  k = 1$

我们就有如下的转移：


$00\ -> 01$

$00\ -> 00$

$10\ -> 01$

$10\ -> 00$

$01\ -> 10$

我们可以发现从现在这个状态$[i ,i + m]$到$[i + 1,i + m + 1]$的状态转移相当把$[i,i + m]$ 这个状态的第一个数字挤出去，再在最后一位填上新的数字，我们设$f[i][j]$为第$i$位向后$m$位状态为$j$的方案数。

那么我们就知道如果我们枚举$[0,m]$的状态 则我们的答案是$f[n + 1][j] \ j$在$2$进制下$1$的个数小于$k$。我们还发现每个$f[i][j]$都从$f[i - 1][j]$达到，所以我们可以用上滚动数组 这样能够做到$70pts$。

~~但我们可是冲着$100pts$去的啊 区区$70pts$~~。

我们可以预处理出这个一个矩阵，类似于邻接矩阵，将$i ->j$这个一个关系，当成一条边存入，这个过程可以使用$dfs$。然后我们要做的是转移，就转换成了经典的图上求到达每个点的方案数了，类似于[P2886 [USACO07NOV]Cow Relays G](https://www.luogu.com.cn/problem/P2886)这个用矩阵快速幂的题目（建议先做这个题），我们本题也可以使用矩阵快速幂来进行加速。

最后上代码啦
```
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
#define MOD 1000000007 

using namespace std;

ll n,m,k,fin = 0;

bool vis[(1 << 6) + 1][(1 << 6) + 1];

struct map{
	ll f[(1 << 6) + 1][(1 << 6) + 1]; 
	map(){
		memset(f,0,sizeof(f));
	}
}a,ans;

void dfs(ll now,ll last){
	if(vis[last][now])
	return;
	if(now >= (1 << m))
	return;
	vis[last][now] = 1;
	a.f[last][now] = 1;
	ll z = now;
	now = (now << 1) & ((1 << m) - 1);
	if(__builtin_popcount(now) >= k)
	dfs(now,z);
	else{
		dfs(now + 1,z);
		dfs(now,z);
	}
}

map operator * (const map &x,const map &y){
	map z;
	for(ll i = 0;i <= (1 << m) - 1;i ++)
	for(ll j = 0;j <= (1 << m) - 1;j ++)
	for(ll k = 0;k <= (1 << m) - 1;k ++)	
	z.f[i][j] = (z.f[i][j] + (1ll * x.f[i][k] * y.f[k][j]) % MOD) % MOD;
	return z;
} 
void quick(ll k){
	ans = a;
	k -= 1;
	while(k){
		if(k & 1) ans = ans * a;
		a = a * a;
		k >>= 1;
	}
}
int main(){
	scanf("%lld%lld%lld",&n,&m,&k);
    dfs(0,0);
    quick(n);
	for (int i = 0; i < (1 << m) - 1; ++i) {
		fin = (fin + ans.f[i][i]) % MOD;
	}
    cout<<fin;
} 

```

---

## 作者：旋转卡壳 (赞：3)

目测可得要用**dp**

因为M很小 所以我们考虑****状态压缩****

因为N很大 所以我们考虑**矩阵快速幂优化**

首先我们定义 **f(i,x)** 为前i个花圃中 最后M个花圃的状态是x的方案数

那么我们的dp起点一定是所有合法的x的f(M,x) 

考虑对于一个合法状态x的dp终点 想一想会发现不是f(N,x)而是 **f(N+M,x)** 因为花圃是呈环形结构的 要想在dp中体现出来 其实就是前面M个花圃和后面M个花圃的x是一样的(在物理上它们是同一个花圃)

那么回过头来考虑矩阵快速幂

矩阵的二维数组 **x[i][j]就代表状态i能否转移到状态j** 这样子就直接把一开始所有的状态都算入了 相当于所有的f(M,x) 因为M/K不是固定的 所以 **转移矩阵要通过dfs判断得出** ~~(打表也行)~~

然后快速幂N次(为什么不是N-M理由在上)

最后统计 **对角线** 的答案就行了(为什么是对角线理由在上)

具体细节看代码 借鉴了很多人 感觉能看= =

```cpp
#include <cstdio>
#include <cstring>

using namespace std;

typedef long long ll;

const int p=1e9+7;

ll n,m,k,S,ans,e[10],vis[70];
//S最大的可能状态 e[i]指2^i vis[i]指状态i是否合法

struct M {
	ll x[70][70];
	M operator * (const M &s) const {
		M t; memset(t.x,0,sizeof t.x);
		for(register int i=0;i<=S;++i)
		for(register int j=0;j<=S;++j)
		for(register int k=0;k<=S;++k)
			t.x[i][j]=(t.x[i][j]+x[i][k]*s.x[k][j]%p)%p;
		return t;
	}
}A,B;

inline void cul(int sta,int num) { //计算初始转移 对于合法状态sta 算出能转移到它的合法状态last
	vis[sta]=1; int last=sta>>1; B.x[last][sta]=1; //左边加0
	if(num!=k||(sta&1)) B.x[last+e[m-1]][sta]=1;
	//左边加1 条件为1数量少于k或原本最后一位为1 右移后没了 
}

void dfs(int x,int num,int sta) { //枚举合法状态 
	if(x==m+1) {cul(sta,num);return ;}
	dfs(x+1,num,sta);
	if(num<k) dfs(x+1,num+1,sta|e[x-1]);
}

int main() {
	for(register int i=e[0]=1;i<=6;++i) e[i]=e[i-1]<<1; 
	scanf("%lld %lld %lld",&n,&m,&k); S=(1<<m)-1;
	for(register int i=0;i<=S;++i) A.x[i][i]=1; dfs(1,0,0); //单位矩阵 快速幂用
	while(n) {if(n&1)A=A*B;B=B*B;n>>=1;}
	for(register int i=0;i<=S;++i) if(vis[i]) ans=(ans+A.x[i][i])%p; //统计状态合法的对角线
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：yzhang (赞：2)

### [原题传送门](https://www.luogu.org/problemnew/show/P1357)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/10915018.html)

我们先将花圃断环为链，并将$[1,m]$复制一份到$[n+1,n+m]$，最后要求$[1,n+m]$是合法序列且$[1,m]$与$[n+1,n+m]$相等的序列的数量即可

$m$很小，珂以考虑状压，$C$是$0$，$P$是$1$，可以将长$m$的花圃压缩成一个数

我们先考虑$[1,m]$的可行方法，直接暴力预处理

如何从$[1,m]$转移到$[2,m+1]$：设$[1,m]$的状态为$a$，我们珂以将第一个数字删掉再在最后加一个$0/1$得到一个新状态$b/c$，连一条$a->b/c$的边（$c$要判断一下$1$的数量）

之后亦是如此。这样我们将问题转化为求一个有向图中长度为$n$的环的数量

这就珂以用矩阵快速幂优化了qwqwq

```cpp
#include <bits/stdc++.h>
#define ll long long
#define mod 1000000007
#define N 32
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline ll read()
{
    register ll x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
struct mat{
    int a[N][N];
    inline mat()
    {
        memset(a,0,sizeof(a));
    }
    inline mat operator*(const mat&b)const{
        mat c;
        for(register int i=0;i<N;++i)
            for(register int j=0;j<N;++j)
                for(register int k=0;k<N;++k)
                    c.a[i][j]=(c.a[i][j]+1ll*a[i][k]*b.a[k][j])%mod;
        return c;
    }
}s; 
inline mat fastpow(register mat a,register ll b)
{
    mat res;
    for(register int i=0;i<N;++i)
    	res.a[i][i]=1;
    while(b)
    {
        if(b&1)
            res=res*a;
        a=a*a;
        b>>=1;
    }
    return res;
}
ll n,ans;
int m,k,lim,ok[N];
inline void work(register int zt,register int num)
{
    ok[zt]=1;
    int kl=zt>>1;
    s.a[zt][kl]=1;
    if(num==k&&!(zt&1))
        return;
    s.a[zt][kl+(1<<(m-1))]=1;
}
inline void dfs(register int x,register int num,register int zt)
{
    if(x==m+1)
    {
        work(zt,num);
        return;
    }
    dfs(x+1,num,zt);
    if(num<k)
        dfs(x+1,num+1,zt|(1<<(x-1)));
}
int main()
{
    n=read(),m=read(),k=read();
    dfs(1,0,0);
    s=fastpow(s,n);
    for(register int i=0;i<(1<<m);++i)
        if(ok[i])
            ans=(ans+s.a[i][i])%mod;
    write(ans);
    return 0;
}
```

---

## 作者：zach0914 (赞：1)

# [花园](https://www.luogu.com.cn/problem/P1357)

---

也是一道不错的状压练习题，梳理一遍**思路**。

---

首先，很明显，我们并不能够用一个简洁组合式子表示原问题答案。我们想到了递推计数。

不难想到，由于这个是一个环，我们**拆环**，将其转化成序列上的问题。同时，我们枚举该序列上最后$m$个数，分别对枚举的这些情况一一统计答案。

具体来讲，我们可以令$dp(i,S)$为前$i$个数后$m$位状态为$S$的方案个数：
$$
dp(i,S)=dp(i-1,S>>1)+dp(i-1,(S>>1)|(1<<m-1))
$$
这里，我们只考虑$S$合法的情况。

注意到该方程前一维仅涉及两个位置的状态值，因此**滚动数组**优化空间：

```c++
const int S = 1 << 6, mod = 1000000000 + 7;
int dp[2][S], ans = 0;

for(int S0 = 0; S0 < 1 << m; ++ S0)
{
    if(!valid[S0]) continue;//预处理状态
    memset(dp, 0, sizeof dp);
    dp[0][S0] = 1;
    for(int i = 1; i <= n; ++ i)
    {
        for(int s = 0; s < 1 << m; ++ s)
        {
            if(!valid[s]) continue;
            bool op = i & 1;
            dp[op][s] = (dp[1 - op][s >> 1] + dp[i - op][(s >> 1) | (1 << m - 1)]) % mod;  
        }
    }
    ans = (ans + dp[n][S0]) % mod;
}
printf("%d\n", ans);
```

---

接着发现$n$太大了，需要矩阵加速递推。

我们可以考虑，对于一个状态矩阵：

$\begin{bmatrix} dp(0) & dp(1) & … & dp(2^{m-1}-2) & dp(2^{m-1}-1)\end{bmatrix}$

可以构造一个转移矩阵使其能够递推。

考虑到：对于转移矩阵而言，新的状态值仅依赖于不超过两个状态，因此我们可以对于每一个状态计算出来。

最后发现，我们由于枚举些许状态**拆环**，我们可以直接将初始的矩阵构造成这个样子，答案为每个合法状态$mat(k,k)$。

$\begin{bmatrix} dp(0) & … & … \\… & dp(1) & … &\\…\\…& …\end{bmatrix}$

```c++
…
typedef long long LL;

const int N = 1e5 + 5, S = 40, mod = 1e9 + 7;

bool valid[S] = {};
LL n;
int m, k, ans = 0, dp[2][S], mat[S][S] = {};
int calc(int x)
{
	int res = 0;
	while(x)
	{
		++ res;
		x -= lowbit(x);
	}
	return res;
}

void mul(int (*c)[S], int (*a)[S], int (*b)[S])
{
	static int res[S][S];
	CLR(res, 0);
	for(int i = 0; i < 1 << m; ++ i)
		for(int j = 0; j < 1 << m; ++ j)
			for(int p = 0; p < 1 << m; ++ p)
				res[i][j] = (res[i][j] + 1ll * a[i][p] * b[p][j] % mod) % mod;
			
	memcpy(c, res, sizeof res);
}

void power(int (*c)[S], int (*a)[S], LL b)
{
	static int res[S][S];
	CLR(res, 0);
	for(int i = 0; i < 1 << m; ++ i) res[i][i] = 1;
	while(b)
	{
		if(b & 1) mul(res, res, a);	
		b >>= 1;
		mul(a, a, a);
	}
	memcpy(c, res, sizeof res);
	return;
}

int main()
{
	scanf("%lld %d %d", &n, &m, &k);
	for(int s = 0; s < 1 << m; ++ s) valid[s] = calc(s) <= k;
	
	for(int i = 0; i < 1 << m; ++ i)
	{
		int state = (i >> 1) | (1 << m - 1);
		mat[i >> 1][i] = 1, mat[state][i] = valid[state];
	}
	power(mat, mat, n);
	for(int i = 0; i < 1 << m; ++ i) if(valid[i]) ans = (ans + mat[i][i]) % mod;
	printf("%d\n", ans);
	return 0;
} 
```

---

总结：

1. 对付环状问题的技巧一般有两个：分类讨论和拆环；
2. 如果递推的时候发现迭代过多，应当考虑**矩阵加速**处理该问题。

---

## 作者：slothfulxtx (赞：1)

楼上说的很好了，我在这里只说几点

1.注意不要越界

2.事实上连续m个的区域，状态长度为m-1就好了

3.i->j与j->i情况一定要想清

4.快速幂指数是几一定要注意

5.注意矩阵乘法的定义，递推矩阵要先搞对

6.还有一种更快的方法，就是状态长度变为m/2，但这样不是特别好写，神犇可以试试

```delphi

program p1357;
const mod1=1000000007;
type
  arr=array[0..15,0..15]of int64;
var
  m,k,t,i,j,l,kk:longint;
  p,ans,n:int64;
  two:array[0..4]of integer=(1,2,4,8,16);
  map,s:arr;
  q:array[1..55]of integer;
function check(p:int64):boolean;
var
  sum:array[-16..16]of longint;
  y,i:longint;flag:boolean;
begin
  fillchar(sum,sizeof(sum),0);
  y:=0;
  while p<>0 do begin
    inc(y);
    if p and 1=1 then sum[y]:=1;
    p:=p shr 1;
  end;
  for i:=1 to 2*l do sum[i]:=sum[i]+sum[i-1];
  flag:=true;
  for i:=k to 2*l do
  if sum[i]-sum[i-m]>k then flag:=false;
  check:=flag;
end;
function cheng(a1,a2:arr):arr;
var i,j,k:longint;
begin
  fillchar(cheng,sizeof(cheng),0);
  for i:=0 to t do
    for j:=0 to t do
      for k:=0 to t do
        cheng[i,j]:=(cheng[i,j]+a1[i,k]*a2[k,j])mod mod1;
end;
begin

    readln(n,m,k);
  l:=m-1;
    t:=two[l]-1;
    fillchar(map,sizeof(map),0);
  for i:=0 to t do
      for j:=0 to 1 do begin
          p:=i*2+j;      //i<--j
      if check(p) then map[i,i mod two[l-1]*2+j]:=1;
        end;
    kk:=0;
    while n<>0 do begin
      inc(kk);
        q[kk]:=n and 1;
        n:=n shr 1;
    end;
    fillchar(s,sizeof(s),0);
    for i:=0 to t do s[i,i]:=1;
  for i:=1 to kk do begin
      if q[i]=1 then s:=cheng(s,map);
        map:=cheng(map,map);
    end;
    ans:=0;
  for i:=0 to t do begin
      fillchar(map,sizeof(map),0);
        map[0,i]:=1;
        map:=cheng(map,s);
    ans:=(ans+map[0,i])mod mod1;
    end;
    writeln(ans);
end.
```

---

## 作者：cold_cold (赞：0)

 [安利一波博客](https://www.cnblogs.com/cold-cold/p/10134857.html)

【数据规模】

40%的数据中，N<=20；

60%的数据中，M=2；

80%的数据中，N<=10^5。

100%的数据中，N<=10^15。

 

看到这个数据范围，我首先想到的是80分的写法

80分的写法可以使用状压DP

f[i][j]表示第i位，前m个二进制状态为j有多少种方式

```cpp
t1=(j>>1)|(1<<(m-1));
t2=j>>1;
```

转移到下一位有两种选择

t1为选C花圃，t2为选P花圃

当然如果选t1则超过k个C花圃，则不可转移
```cpp
if(ji[t1]<=k) f[i+1][t1]=(f[i+1][t1]+f[i][j])%mo;
f[i+1][t2]=(f[i+1][t2]+f[i][j])%mo;
```
另外要注意的是原花圃是一个环

所以我们枚举起始状态，转移n+m次，取f[n+m]中状态与起始相同加入总和

80分的状压DP具体实现如下：
```cpp
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstring>
#include <map>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
using namespace std;
typedef long long ll;
inline ll read()
{
    register ll p(1),a(0);register char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if(ch=='-') p=-1,ch=getchar();
    while(ch>='0'&&ch<='9') a=a*10+ch-48,ch=getchar();
    return a*p;
}
const ll N=100100,M=(1<<5),mo=1000000007;
ll f[N][M],n;
int ans=0,ji[M],t1,t2,m,k;
inline int suan(int xx)
{
    register int num=0;
    while(xx)
    {
        if(xx&1) num++;
        xx>>=1;
    }
    return num;
}
int main()
{
    // freopen("input","r",stdin);
    // freopen("output","w",stdout);
    n=read(),m=read(),k=read();
    for(register int i=(1<<m)-1;i>=0;i--)
        ji[i]=suan(i);
    for(register int kk=(1<<m)-1;kk>=0;kk--) if(ji[kk]<=k)
    {
        memset(f,0,sizeof(f));
        f[m][kk]=1;
        for(register int i=m;i<  n+m;i++)
            for(register int j=(1<<m)-1;j>=0;j--)
            {
                t1=(j>>1)|(1<<(m-1));
                t2=j>>1;
                // prllf("%d %d\n",t1,t2);
                if(ji[t1]<=k) f[i+1][t1]=(f[i+1][t1]+f[i][j])%mo;
                f[i+1][t2]=(f[i+1][t2]+f[i][j])%mo;
            }
        ans=(ans+f[n+m][kk])%mo;
    }
    printf("%d",ans);
    return 0;
}
 
```


然后我们再来考虑100分的做法

范围开到了1e15我们显然只能使用logn的算法

很容易想到矩阵快速幂的套路

使用状压DP的2^m种状态作为点

于是可以使用原来的思路建出一步可达矩阵图

快速幂n次方即可

100分矩阵快速幂实现如下：
```cpp
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstring>
#include <map>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
using namespace std;
typedef long long ll;
inline ll read()
{
    register ll p(1),a(0);register char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if(ch=='-') p=-1,ch=getchar();
    while(ch>='0'&&ch<='9') a=a*10+ch-48,ch=getchar();
    return a*p;
}
const ll N=100100,M=(1<<5),mo=1000000007;
struct matrix
{
    ll data[M][M];
    matrix(){memset(data,0,sizeof(data));}
};
ll f[N][M],n,ans=0,ji[M],t1,t2,m,k,big;
inline int suan(int xx)
{
    register int num=0;
    while(xx)
    {
        if(xx&1) num++;
        xx>>=1;
    }
    return num;
}
matrix chen(matrix a,matrix b)
{
    matrix c;
    for(register int i=0;i<big;i++)
        for(register int j=0;j<big;j++) if(a.data[i][j])
            for(register int k=0;k<big;k++)
                c.data[i][k]=(c.data[i][k]+a.data[i][j]*b.data[j][k])%mo;
    return c;
}
matrix qs(matrix a,ll b)
{
    matrix ans;
    for(register int i=0;i<big;i++) ans.data[i][i]=1;
    while(b)
    {
        if(b&1) ans=chen(ans,a); 
        a=chen(a,a);
        b>>=1;
    }
    return ans;
}
int main()
{
    // freopen("input","r",stdin);
    // freopen("output","w",stdout);
    n=read(),m=read(),k=read();
    matrix temp,now;
    big=1<<m;
    for(register int i=(1<<m)-1;i>=0;i--)
        ji[i]=suan(i);
    for(register int i=(1<<m)-1;i>=0;i--) if(ji[i]<=k)
    {
        t1=(i>>1)|(1<<(m-1));
        t2=i>>1;
        if(ji[t1]<=k) temp.data[i][t1]=1;
        temp.data[i][t2]=1;
    }
    temp=qs(temp,n);
    for(register int i=(1<<m)-1;i>=0;i--) if(ji[i]<=k)
        ans=(ans+temp.data[i][i])%mo;
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：wzf2000 (赞：0)

（方法跟下方两位神犇的不同）根据数据规模的套路，显然要矩阵加速快速幂

题目：01串相邻m个01中1个数小于k（环特判）

考虑两个m位01串怎么样加在一起符合条件：显然2m位中任意一个m位均要满足。

考虑m位的转移。那转移矩阵就是2^m\*2^m的，然后对于两个满足上述条件的01串01矩阵中赋值为1。

枚举开始（1-m）的m位，然后矩阵快速幂转移（n/m-1）次，然后还剩下n%m位，穷举这些位置，暴力判断与最后m位及开头5位是否符合条件即可。

暴力判断是否符合题意（x、y为两个01串）：

```cpp
ll pd(ll x,ll y)
{
    memset(bit,0,sizeof(bit));
    for (ll i=m-1;i>=0;i--)
        if ((x>>i)&1) bit[m-i]=1;
    for (ll i=m-1;i>=0;i--)
        if ((y>>i)&1) bit[(m<<1)-i]=1;
    for (ll i=1;i<=(m<<1);i++) bit[i]+=bit[i-1];
    for (ll i=0;i<=m;i++)
        if (bit[i+m]-bit[i]>k) return 0;
    return 1;
}
```
判断开头部分：

```cpp
rest=n%m;
for (ll l=0;l<(1<<m);l++)
    for (ll r=0;r<(1<<rest);r++)
        if (pd(((l<<rest)|r)&((1<<m)-1),i)&&pd(l,(r<<(m-rest))|(i>>rest)))
            Ans=(Ans+ans.a[0][l])%mod;
```

---


# [TJOI2011] 01矩阵

## 题目描述

$n\times m$ 的 $01$ 矩阵，其中某些位置已经确定，为 '.' 的位置可以填 $0$ 或 $1$，求相邻两个位置不同为 $1$ 的矩阵方案数，答案模 $10007$。

## 说明/提示

### 数据范围及约定

对于 $100\%$ 的数据，$n\times m \le 225$。

## 样例 #1

### 输入

```
2 3
10.
...
```

### 输出

```
5
```

# 题解

## 作者：real60t (赞：9)

## P1539题解
### 1.分析
数据范围: $n\times m\le225$。

则 $\min(m,n)\le15$。我们可以将较小值作为的列数，再对每一行进行状压，用 $c$ 数组储存每行方案，dp 求解。  

我们算一下时间复杂度，由于相邻不能同时为 1，所以很多情况都被舍掉，所以当 $m=15$ 时，每一行只有 1597 种情况，不会超时。

但题目给出的矩阵有些数已经填好，无法改变，这怎么处理呢？

设 $s_i$ 为第 $i$ 行已填数字 1 的分布情况，$t_i$ 为第 $i$ 行已填数字 0 的分布情况。如果第 $i$ 行中方案 $c_k$ 满足 $(t_i\;and\;c_k)=t_i$ 且 $s_i\;and\;(not\;c_k)=s_i$，则方案 $k$ 不与已填数字冲突。

最后的 dp 就比较简单了，设 $f[i][j]$ 为第 $i$ 行使用第 $j$ 种方案的方法数，$d$ 每行合法方案种数。

状态转移方程：$f[i][j]=\sum\limits_{k=1}^df[i-1][k](c[j]\;and\;c[k]=0)$。

最终答案：$ans=\sum\limits_{i=1}^df[n][i]$。

初始化：$f[0][1]=0$。

时间复杂度：$\mathcal O(nd^2)$。
### 2.Code
```
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
const int mod=10007;
int n,m=15,ans,t[230],s[230],c[1600],f[230][1600];
char a[230][230],b[230][230];
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%s",a[i]+1);
	//如果n<m,将矩阵顺时针旋转90度,以保证列数m<=15 
	if(n<m) {
		swap(n,m);
		memcpy(b,a,sizeof(b));
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)a[i][j]=b[m-j+1][i];		
	}
	//预处理s,t数组 
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			if(a[i][j]=='1')s[i]+=1<<m-j;
			if(a[i][j]=='0')t[i]+=1<<m-j;
		}
	}	
	//预处理每行方案,存入数组c 
	for(int i=0;i<1<<m;i++) 
		if(!(i>>1&i))c[++c[0]]=i;
	f[0][1]=1;
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=c[0];j++) {
			//判断方案是否合法 
			if((s[i]&c[j])!=s[i])continue;
			if((t[i]&(~c[j]))!=t[i])continue;
			for(int k=1;k<=c[0];k++) 
				if(!(c[j]&c[k]))f[i][j]=(f[i][j]+f[i-1][k])%mod;
		}
	}
	for(int i=1;i<=c[0];i++)ans=(ans+f[n][i])%mod;
	printf("%d",ans);
	return 0;
}
```

---

## 作者：yyxmy (赞：6)

$wtcl$, 不知道啥是轮廓线$dp$,　写了一发$FWT$;  
易得，$min(n,m) \leq 15$ ，可以设$dp[i][s]$为第$i$行，填的状态为$S$的
方案数，　枚举上一行的状态可以暴力转移，　复杂度是$nm(2^m)^2$的，　但是限制比较多，说不定能卡过。　观察什么样的的状态可以转移到$S$, 可以发现，如果某一位填１，上一行的这一位填必须填０，而如果这一位填$0$，上一行可以填１也可以填０，那么我们可以发现，　转移过来的状态是$S$取反后的子集，　那么可以做一个子集和达到优化的目的，　用$FWT$ 或　$FMT$就可以实现了。
```cpp
#include<bits/stdc++.h>
#define mod 10007
#define int long long
int n, m, A[21][1000001], ans, d[111111]; 
char p[1111][1111], s[1111][1111];

using namespace std;
void FMT(int *f){
    for(int i = 0; i <= m; i++)
        for(int j = 0; j < (1 << m); j++)
            if(j & (1 << i)) (f[j] += f[j ^ (1 << i)]) %= mod;
}
bool check(int x, int y){
    for(int i = 0; i <= m; i++){
        int w = y & (1 << i); if(w) w = 1;
        if(p[x][i + 1] == '0' && w == 1) return false;
        if(p[x][i + 1] == '1' && w == 0) return false; 
    }
    return true;
}
bool find(int x){
    for(int j = 1; j < m; j++){
        int p = x & (1 << j - 1);
        int q = x & (1 << j);
        if(p && q) return true; 
    }
    return false;
}
signed main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
    scanf("%s", s[i] + 1);
    if(n >= m){
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= m; j++) 
                p[i][j] = s[i][j];
    }
    if(n < m){
        swap(n, m);
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= m; j++)
            p[i][j] = s[j][i];
    }
    for(int i = 1; i < (1 << m); i++) d[i] = find(i);
    A[0][0] = 1;
    for(int i = 1; i <= n; i++){
        FMT(A[i - 1]);
        for(int j = 0; j < (1 << m); j++){
            if(!check(i, j) || d[j]) continue;
            A[i][j] = A[i - 1][j ^ ((1 << m) - 1)];
        }
    }
    for(int j = 0; j < (1 << m); j++) (ans += A[n][j]) %= mod;
    cout << ans << endl; return 0;
}
```


---

## 作者：吾乃会虎 (赞：5)

~~原本以为这道题很难的，没想到这么水~~

由于矩阵转置不影响答案，因此不妨假设$n>m$

首先看数据范围$nm\le 225$，换句话说，$m\le 15$，因此我们很可能需要一个$O(2^m n m)$的算法

~~“看数据范围知时间复杂度”技能 get√~~

然后想复杂度的每一项代表什么，思考再三，发现$nm$是矩阵大小，$2^m$是每一行的可能方案数

也就是说，我们要枚举矩阵的每一个格子，以及每个格子填完后最后一行的样子

为什么是最后一行呢？因为隔了一行，两个格子就不影响了啊

~~看上去好像[插头DP](luogu.com.cn/blog/interestingLSY/cha-tou-dp-zong-jie)啊~~

综合一下，我们定义这样一个DP状态：$f_{p,S}$（其中$p=(i-1)m+j$）代表考虑到格子$(i,j)$时，每一列最后一个位置的状态，仔细思考，它的转移状态应该是这样的：

- $S_j=0$，说明$(i,j)$上面填的是$0$，那么$(i-1,j)$填什么都可以，即$f_{p,S}=f_{p-1,S}+f_{p-1,S+\{j\}}$
- $S_j=1$，说明$(i,j)$上面填的是$1$，那么要求$(i-1,j),(i,j-1)$填的都是$0$，即$f_{p,S}=[S_{j-1}=0]f_{p-1,S-\{j\}}$（这里认为$S_0\equiv 0$，这样就不用特判$j=1$了）

最后$ans=\sum_{S}f_{nm,S}$

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mods = 10007;
int col[250][250];
int las[1 << 15], nxt[1 << 15];
signed main() {
	ios::sync_with_stdio(false);
	int n = 0, m = 0; cin >> n >> m;
	for(int i = 1; i <= n; i++) {
		char str[250]; cin >> (str + 1);
		for(int j = 1; j <= m; j++) {
			col[i][j] = (str[j] == '.'? 3: str[j] - '0' + 1);
		} //有位1：可以填0；有位2：可以填1
	} 
	if(n < m) {
		for(int i = 1; i <= n; i++) {
			for(int j = i + 1; j <= m; j++) {
				swap(col[i][j], col[j][i]);
			}
		}
		swap(n, m);
	} //调整矩阵，使得n >= m
	las[0] = 1;
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			for(int k = 0; k < (1 << m); k++) {
				if((col[i][j] & 1) and !(k & (1 << (j - 1)))) {
					nxt[k] = (nxt[k] + las[k]) % mods;
					nxt[k] = (nxt[k] + las[k ^ (1 << (j - 1))]) % mods;
				} // 填0
				if((col[i][j] & 2) and (k & (1 << (j - 1)))) {
					if(!(k & (1 << (j - 2)))) {
						nxt[k] = (nxt[k] + las[k ^ (1 << (j - 1))]) % mods;
					}
				} //填1
			}
			for(int k = 0; k < (1 << m); k++) {
				las[k] = nxt[k], nxt[k] = 0;
			}
		}
	}
	int ans = 0;
	for(int k = 0; k < (1 << m); k++) {
		ans = (ans + las[k]) % mods;
	}
	cout << ans << endl;
	return 0;
}
```
~~我好菜啊~~

![](https://i.loli.net/2020/03/25/fUcRYXCEhilVBgb.jpg)

---

## 作者：囧仙 (赞：4)

这是目前为止 $(\verb!2021.4.1!)$ 的[最优解](https://www.luogu.com.cn/record/48812915)。尽管这里有一堆有些难写的优化，但我希望这篇文章能对你有所帮助。

## 题解

观察到 $n\cdot m\le 225$ ，可得 $\min(n,m)\le 15$ （否则，两者的乘积必定大于 $225$ ）。于是考虑使用状压 $dp$ 。

我们先使 $n\ge m$ 。也就是说，当 $n<m$ 时，我们按照斜线方向翻折这个矩形，然后交换 $n,m$ 。很显然，这样并不会对答案造成任何影响。

最朴素的状压 $dp$ 是，从上到下枚举每一行的状态。转移时，枚举上一行的状态。这么做的时间复杂度是 $\mathcal O(n\times 2^m\times 2^m)$ ，显然是会超时的。当然，由于每一层的合法状态数量很少，于是我们只需要枚举合法状态就行了。这样的时间复杂度是 $\mathcal O(n\times k^2)$ ，其中 $k$ 是每一行合法状态数。尽管你可以通过这种方式卡过去，但是我们希望获得一个更好的做法。

考虑使用类似轮廓线一样的 $dp$ 。具体而言，我们只需要维护以下内容：

$$\def{\arraystretch}{1.5}\begin{array}{|c|c|c|c|c|}\hline
& & & & \cr\hline
& & 2 & 3 & 4 \cr\hline
0 & 1 \cr\hline
& & & & \cr\hline
\end{array}$$

里面的数字表示它在对应的二进制状态 $s$ 的第几位， $dp_s$ 存储轮廓线为这种状态时，一共有多少种方案。其中 $1$ 是我们当前位置 $(i,j)$ 。 $1$ 右边的格子 $(i,j+1)$ 是我们下一个要更新的地方。我们更新时，相当于将这个轮廓线在 $(i,j+1)$ 处向下推一格：

$$\def{\arraystretch}{1.5}\begin{array}{|c|c|c|c|c|}\hline
& & & & \cr\hline
& & & 3 & 4 \cr\hline
0 & 1 & 2 \cr\hline
& & & & \cr\hline
\end{array}$$

我们枚举所有 $(i,j)$ 处合法的 $s$ ，再讨论 $(i,j+1)$ 处放置什么东西（ $0$ 或者 $1$ ），就可以用 $(i,j)$ 处的 $dp$ 值推向 $(i,j+1)$ 。特别地， 在 $(i,1)$ 处放置数字 $1$ 不需要考虑它左侧格子是否是 $1$ ，可以参考下文的代码。

这种做法的时间复杂度是 $\mathcal O(\min(n,m)\times k)$ ，其中 $k$ 表示每行合法状态数的个数。因为常数比较小，所以跑起来挺快的。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define debug(x) (printf("The value of [%s] in fuction[%s] is %d.\n",#x,__FUNCTION__,x))
#define up(l,r,i) for(register int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(register int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long LL;
const int INF =2147483647;
int qread(){
	int w=1,c,r=0;
	while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); r=c-'0';
	while((c=getchar())>='0'&&c<='9') r=r*10+c-'0';
	return r*w;
}
const int MAXN =225+3,MOD=1e4+7,MAXM=(1<<15)+3;
int n,m,t,x,y,F[MAXM],G[MAXM],B1[MAXM],B2[MAXM],c1,c2,ans;
char S[MAXN][MAXN]; bool A[MAXM];
void add(int &a,int b){a+=b; if(a>=MOD) a-=MOD;}
int main(){
	n=qread(),m=qread(); up(0,n-1,i) scanf("%s",S[i]);
	if(n<m){
		up(0,n-1,i) up(i,m-1,j) swap(S[i][j],S[j][i]); swap(n,m);
	}
	F[0]=1,c1=1,B1[1]=0; up(0,n-1,i){
		up(0,m-1,j){
			if(S[i][j]=='.'||S[i][j]=='1') up(1,c1,k){
				x=B1[k],y=x| (1<<j); if((!j||!(x&(1<<j-1)))&&!(x&(1<<j))){
					if(!A[y]) A[y]=true,B2[++c2]=y; add(G[y],F[x]);
				}
			} 
			if(S[i][j]=='.'||S[i][j]=='0') up(1,c1,k){
				x=B1[k],y=x&~(1<<j);
				if(!A[y]) A[y]=true,B2[++c2]=y; add(G[y],F[x]);
			} 
			up(1,c1,j) F[B1[j]]=0; c1=c2;
			up(1,c2,j) F[B2[j]]=G[B2[j]],B1[j]=B2[j],B2[j]=G[B2[j]]=A[B2[j]]=0; c2=0;
		}
	}
	up(1,c1,i) add(ans,F[B1[i]]); printf("%d\n",ans);
	return 0;
}
```

---

## 作者：UltiMadow (赞：3)

首先，此题暴力状压可过

为啥捏，我们可以枚举每行所有的合法状态，也就是没有连续的两个 1 的状态数，记为 $k$，那么时间复杂度即为 $\Theta(nk^2)$

发现 $m=15$ 时这个 $k$ 不会很多

为啥，我们写一个爆搜：
```cpp
#include<bits/stdc++.h>
using namespace std;
int cnt;
void dfs(int n,int s)
{
	if(n>15){cnt++;return;}
	if(s&1)dfs(n+1,s<<1);//填0
	else dfs(n+1,s<<1),dfs(n+1,s<<1|1);//填1或填0
}
int main()
{
	dfs(1,0);
	printf("%d",cnt);
	return 0;
}
```
搜出来 $k=1597$

不算很大，如果你常数很小的话是可以通过这个题的

但是窝看过这么写的代码，码量奇大无比（甚至比窝的轮廓线dp还长

当然啦，我们这道题如果 $n\cdot m\le 400$，也就是 $m\le 20$ 就可以卡掉暴力啦（当然这也把普通的轮廓线dp卡掉了

接下来，我们进入正题

这题我们采用另一种姿势的轮廓线dp

我们设 $f_{i,j,k}$ 表示当前枚举到 $(i,j)$ 这个格子，轮廓线上的01状态为 $k$ 的情况有多少种放置方法

这里呢，我自己在做这个题的时候借助了一点插头dp的思想，但是整体不算是一个插头dp

首先，我们可以通过位运算提取出右边的格子和上面格子填的是0还是1

~~按照剧情~~，接下来就是大力分类讨论时间啦

1、当前格子必须填 0，直接转移即可  
2、当前格子必须填 1，则在右、上格子填的都是0才可转移  
3、当前格子 0,1 都可以填，且右、上格子填的都是0，则当前格子可以填0或者1  
4、当前格子 0,1 都可以填，且右、上格子填的数中有**至少一个** 1，则当前格子必须填 0

很好理解吧（

接下来，我写的代码中有几个细节，在代码中讲吧qwq
```cpp
#include<bits/stdc++.h>
#define MAXN 240
#define p 10007
using namespace std;
int n,m;
char c[MAXN],ma[MAXN][MAXN];
int f[2][1<<17],now,pre;//滚动数组
void modify(int& x,int y){x+=y;if(x>p)x-=p;}//卡常，也可以直接用膜运算替代
int main()
{
	scanf("%d%d",&n,&m);
	if(n>=m)
		for(int i=1;i<=n;i++)
		{
			scanf("%s",c+1);
			for(int j=1;j<=m;j++)
				ma[i][j]=c[j];
		}
	else
	{
		swap(n,m);
		for(int j=m;j>=1;j--)
		{
			scanf("%s",c+1);
			for(int i=1;i<=n;i++)
				ma[i][j]=c[i];
		}
	}//细节1，使m<=n
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			if(ma[i][j]=='1')ma[i][j]='0';
			else if(ma[i][j]=='0')ma[i][j]='1';
		}//细节2,01互换，可以方便位运算
	int max_state=(1<<m);
	f[0][max_state-1]=1;//细节3，读者自行思考初始状态为何为全1
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			pre=now;now^=1;
			memset(f[now],0,sizeof(f[now]));
			for(int k=0;k<max_state;k++)
			{
				int val=f[pre][k];
				if(!val)continue;
				int pl1;//right
				if(j>1)pl1=(k>>j-2)&1;
				else pl1=1;
				int pl2=(k>>j-1)&1;//up
				if(ma[i][j]=='1')modify(f[now][k|(1<<j-1)],val);
				else if(ma[i][j]=='0'){if(pl1&&pl2)modify(f[now][k^(1<<j-1)],val);}
				else if(pl1&&pl2)
				{
					modify(f[now][k],val);
					modify(f[now][k^(1<<j-1)],val);
				}
				else modify(f[now][k|(1<<j-1)],val);
			}
		}
	}
	int ans=0;
	for(int i=0;i<max_state;i++)modify(ans,f[now][i]);//统计答案
	printf("%d",ans%p);
	return 0;
}
```
接下来，我们还可以继续优化这个代码

我们发现这个代码有很多的冗余状态

于是，我们可以用哈希表来存储，节省时间&空间

~~（由于um太懒了所以不想写了）~~

至此，我们就把这个问题在大约 $\Theta(nmk)$ 的时间内做完啦

这里，$k\approx 3025$，至于为啥，~~留作习题自己思考吧~~

---

## 作者：Seauy (赞：2)

这里给出一个状压的准确复杂度分析

设 $k$ 为 $m$ 个 01格子 排成一排没有两个 1 相邻的方案数

UM 用爆搜证明了当 $m=15$ 时 $k=1597$

~~但是你这个不严谨啊~~ 我们需要阐明 $k$ 与 $m$ 的关系

设 $f_{i,j}$ 为从左往右摆了 j 个格子，最后一个摆了 i 的方案数

得递推式

$$ f_{0,i}=f_{0,i-1}+f_{1,i-1} $$

$$ f_{1,i}=f_{0,i-1} $$

边界值

$$ f_{0,1}=f_{1,1}=f_{1,2}=1 $$

$$ f_{0,2}=2 $$

则 $ k=f_{0,m}+f_{1,m} $

把 $ f_{1,i}=f_{0,i-1} $ 代入 $ f_{0,i}=f_{0,i-1}+f_{1,i-1} $ 得

$$ f_{0,i}=f_{0,i-1}+f_{0,i-2} $$

易得

$$ f_{0,i}=F_{i+1} $$

$$ f_{1,i}=F_{i} $$

其中 $F$ 为斐波那契数列

得出

$$ k=F_{m+2} $$

那么状压的复杂度就为

$$ O(nF_{m+2}^2) $$

可以看到，$ 1597=F_{15+2} $

---

## 作者：Awdrgysxc (赞：2)

### 【Analysis】
基础轮廓线dp，因为用普通状压可能过不去，用轮廓线的复杂度是可能过的。

普通状压预先处理一下每行的可行状态，可能也是可以过的。

不会轮廓线的可以看看[P3272 [SCOI2011]地板](https://www.luogu.com.cn/problem/P3272)或[P2595 [ZJOI2009]多米诺骨牌](https://www.luogu.com.cn/problem/P2595)。

考虑逐格转移，上面或右边只要有一个格子是$1$，那么这个格子只能放$0$,或是已经填好了。
对于$n<m$的时候可以把矩阵翻转过来。

转移方程：

$$1.dp_{t,s}=dp_{t,s}+dp_{t-1,(s>>1)}$$
$$2.dp_{t,s}=dp_{t,s}+dp_{t-1,(s>>1)|(1<<m-1)}$$

1. 当前可以放$0$。

2. 当前可以放$1$。

时间复杂度$O(n\times m \times 2^{min(n,m)})$。

### 【Code】（懒得滚动数组了）
```cpp
#include <iostream>
#include <functional>
#include <algorithm>
#include <cstring>
#include <vector>
using namespace std;

typedef long long int64;
const int P = 1e4 + 7;
const int MAXS = 1 << 15 | 1;
const int MAXN = 230;
int dp[MAXN][MAXS];
int g[MAXN][MAXN];
int tmp[MAXN][MAXN];
int n, m;

inline void incr(int& x, int y) { x += y; x -= x >= P ? P : 0; }

void OUT()
{
	for (int i = 1;i <= n; ++i)
		for (int j = 1;j <= m; ++j)
			cerr << g[i][j] << " \n"[j==m];
}

int main(void)
{
	cin >> n >> m;
	string cc;
	for (int i = 1; i <= n; ++i)
	{
		cin >> cc;
		for (int j = 1; j <= m; ++j)
		{
			if (cc[j-1] == '.')
				g[i][j] = -1;
			else
				g[i][j] = cc[j-1] - '0';
		}
	}

	function <bool(int, int, int)> check = [&](int x, int y, int s)
	{
		int k = m - y + 1;
		for (int i = 2; i < y; ++i)
			if (((s >> i + k) & 1) == ((s >> i - 1 + k) & 1) && (((s>>i+k) & 1)))
				return false;
		for (int i = 1; i < k; ++i)
			if (((s >> i) & 1) == ((s >> i - 1) & 1) && ((s>>i) & 1))
				return false;
		for (int i = 1; i < y; ++i)
			if (g[x][i] != -1 && ((s >> i + k - 1) & 1) != g[x][i])
				return false;
		for (int i = 0; i < k; ++i)
			if ((g[x - 1][y + i] != -1) && (((s >> i) & 1) != g[x - 1][y + i]))
				return false;
		return true;
	};

	if (n < m)
	{
		for (int i = 1; i <= n; ++i)
			for (int j = 1; j <= m; ++j)
				tmp[j][i] = g[i][j];
		swap(n, m);
		for (int i = 1; i <= n; ++i)
			for (int j = 1; j <= m; ++j)
				g[i][j] = tmp[i][j];
	}
	
	//OUT();
	for (int i = 1;i <= m; ++i)
		g[0][i] = 0;

	int all = 1 << m;
	int now = 0, pre = 1;
	int tot = 0;
	
	dp[0][0] = 1;
	for (int i = 1; i <= n; ++i)
	{
		for (int j = 1; j <= m; ++j)
		{
			++tot;
			for (int s = 0; s < all; ++s)
			{
				if (!check(i, j, s))
					continue;
				if (j == 1)
				{
					bool two = (s & 1) ^ 1;
					
					if (g[i][j] == -1)
					{
						incr(dp[tot][(s>>1)], dp[tot - 1][s]);
						if (two)
							incr(dp[tot][(s>>1)|(1<<m-1)], dp[tot - 1][s]);
					}
					else
					{
						if (g[i][j] == 0)
							incr(dp[tot][(s>>1)], dp[tot-1][s]);
						else
							if (two)
								incr(dp[tot][(s>>1) | (1<<m-1)], dp[tot - 1][s]);
					}
					
//					cerr << "dp : " << i << " " << j << " " << dp[tot][(s>>1)|(1<<m-1)] << '\n';
					continue;
				}
				bool up = s & 1, left = (s >> m - 1) & 1;
				bool two = (up ^ 1) & (left ^ 1);
					
				if (g[i][j] == -1)
				{
					incr(dp[tot][(s>>1)], dp[tot - 1][s]);
					if (two)
						incr(dp[tot][(s>>1) | (1<<m-1)], dp[tot - 1][s]);
				}
				else
				{
					if (g[i][j] == 0)
						incr(dp[tot][(s>>1)], dp[tot - 1][s]);
					else
						if (two)
							incr(dp[tot][(s>>1) | (1<<m-1)], dp[tot - 1][s]);
				}
				
//				cerr << "dp : " << i << " " << j << " " << dp[tot][s>>1 | (1<<m-1)] << '\n';
			}
		}
	}
	int ans = 0;
	for (int s = 0; s < all; ++s)
		incr(ans, dp[tot][s]);
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：gcwixsxr (赞：1)

### 题意

给定一个矩阵，中间的方格有若干已经填好的数字，要求在未填的格子中填入数字，询问有多少个方案使得相邻的格子不都为 $1$。

### 思路

首先观察数据范围，$n\times m \leq 225$，可以证明，$n$ 和 $m$ 中至少有一个数不大于 $15$ ，可以反证，如果都大于 $15$，那么乘积必定大于 $225$。

假设$n\geq m$（如果$n< m$ ，则将矩阵沿 $45^\circ$ 角翻转，保证 $n\geq m$）也就是 $m\leq 15$ ，对于这类很小的数据，可以考虑搜索或者状压$\texttt{dp}$。

那么这篇题解采用状压$\texttt{dp}$。

 - 怎样状压：对每一行的状态进行压缩，如果哪一位是 $1$ ，则二进制表示的这一位就为 $1$，例如第 $1,3$ 位为 $1$ ，而其他位为 $0$ ，就表示为 $000101$，十进制表示就是 $5$。
 - 用$f_{i,S}$表示第$i$行状态为 $S$ 时的方案数。那么有状态转移方程（其中 $K$ 表示上一行能够转移的状态，满足$S\ \&K=0$以及 $S$ 和 $K$ 中都不存在相邻的 $1$）：
 
 $$ f_{i,S}=f_{i,S}+f_{i-1,K}$$

### 代码

几个变量：

$ch$:输入的字符。

$n,m$:矩阵的长和宽。

$a_{i,j}$:矩阵第 $i$ 行第 $j$ 列是否有固定的值（有则为该值，没有则为 $-1$）。

$numone_i,numzero_i$:预处理数组，表示第 $i$ 行哪些位有固定值（ $0$ 或 $1$ ）。

$cando_i$:预处理数组，表示第 $i$ 个满足要求的状态（不存在相邻的 $1$）。

$cnt$:表示 $cando$ 数组的个数。

$f_{i,S}$:表示第$i$行状态为 $S$ 时的方案数。

```cpp
char ch;
int n,m;
int a[N][N];
int numone[N],numzero[N],cando[1<<15],cnt;
int f[N][1<<15];
```



如果$n< m$ ，则将矩阵沿 $45^\circ$ 角翻转（压行的写法）：

```cpp
cin>>n>>m;
for(int i=1;i<=n;i++){
	for(int j=1;j<=m;j++){
		cin>>ch;
		a[i*(n>=m)+j*(n<m)][j*(n>=m)+i*(n<m)]=
		   (ch=='1'||ch=='0')?ch-'0':-1;
	}
}
if(n<m)swap(n,m);
```

预处理每一行哪些位的值已被固定（当后面枚举第i行的状态 $S$ 时，必须满足 $S\ \&\ numone_i=numone_i$及$S\ \&\ numzero_i=0$）：

```cpp
for(int i=1;i<=n;i++){
	for(int j=1;j<=m;j++){
		if(a[i][j]==1)numone[i]+=1<<(m-j);
		if(a[i][j]==0)numzero[i]+=1<<(m-j);
	}
}
```
简单预处理一下哪些状态符合要求（不存在相邻的 $1$ ）：

```cpp
for(int i=0;i<(1<<m);i++){
	if((i&(i<<1))||(i&(i>>1)))continue;
	cando[++cnt]=i;
}
```
状压$\texttt{dp}$主要代码：

 - 初始化：
 
 ```cpp
f[0][0]=1;
```
 - 状态转移：
 ```cpp
for(int i=1;i<=n;i++){
	for(int j=1;j<=cnt;j++){
		if((cando[j]&(numone[i]))!=numone[i])continue;
		if(((cando[j])&(numzero[i])))continue;
		for(int k=1;k<=cnt;k++){
			if(cando[k]&cando[j])continue;
			f[i][cando[j]]=(f[i][cando[j]]+f[i-1][cando[k]])%mod;
		}
	}
}
```
统计答案：

```cpp
int ans=0;
for(int j=1;j<=cnt;j++){
	ans=(ans+f[n][cando[j]])%mod;
}
cout<<(ans%mod+mod)%mod<<endl;
```
结束：
```cpp
return 0;
```
连起来就是完整的代码啦！
 



---

## 作者：七色丶人偶使 (赞：0)

## 题目大意

给定一个矩阵，其中部分位置已经被填上 $0$ 或 $1$，求使 $1$ 互不相邻的用 $0$ 或者$1$ 填满整个矩阵的填法。

## 思路及做法

首先看数据范围 $n \ast m \le 225$。

我们可以想到这个矩阵在不同情况下最短边的最大值是 $15$，而这正好可以状压dp。

(下文约定 $n \le m$，如果出现 $n \gt m$ 那么我们可以交换它们并转置矩阵)

但是枚举 $2^{n}$ 是不现实的，这会导致你的复杂度变为 $O(n \cdot 2^{2n})$ （当 $n=15$ 的时候就直接复杂度爆炸）

因为题目的一些限制，我们可以想到并不是每个状态都能用上，也就是状压后两个1相邻的情况，那么我们可以记录每个可用状态。最后发现可用状态数（记为 $cnt$）$cnt \le 1600$。

那么我们就可以进行状压dp，复杂度 $O(n \cdot cnt^2)$。

以上就是这个题的思路，剩下就是实现的问题了。

注意一点，转移的时候当且仅当你当前的状态能和当前行已有的状态匹配到的时候（$0$ 的地方同为 $0$，$1$ 的地方同为 $1$， 剩余地方随意）才能利用这个状态转移。所以需要一点处理。

代码如下：
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>

using namespace std;

typedef int ll;
const ll MAXN = 1e6+10, MOD = 10007;

ll N, M, zt[MAXN], cnt, num[230], f[2][2000], num2[230]; // zt[]：记录有用状态
char g[230][230], g2[230][230]; // g2[][]：最终使用的矩阵

bool check(ll);

int main() {
    ios::sync_with_stdio(false);
    cin >> N >> M;
    for (ll i = 1; i <= N; i++)
        for (ll j = 1; j <= M; j++)
            cin >> g[i][j];
    if (N < M) {
        for (ll i = 1; i <= N; i++)
            for (ll j = 1; j <= M; j++)
                g2[j][i] = g[i][j];
        swap(N, M);
    } else {
    	for (ll i = 1; i <= N; i++) 
			for (ll j = 1; j <= M; j++)
				g2[i][j] = g[i][j];	
    }
    for (ll i = 0; i < (1LL << M); i++)
        if (check(i)) zt[++cnt] = i;
    for (ll i = 1; i <= N; i++)
    	for (ll j = 1; j <= M; j++) {
			if (g2[i][j] == '1') num[i] += (1LL << (j - 1));
			if (g2[i][j] == '0') num2[i] += (1LL << (j - 1)); // 考虑这两个处理以及在下面的使用，是保证正确性的关键。
		}
	for (ll i = 1; i <= cnt; i++)
		if (((num[1] & zt[i]) == num[1]) && ((num2[1] & (~zt[i])) == num2[1])) f[1][i] = 1;
	for (ll i = 2; i <= N; i++) {
		for (ll j = 1; j <= cnt; j++) {
			f[i&1][j] = 0;
			for (ll k = 1; k <= cnt; k++) {
				if (!(zt[j] & zt[k]) && ((num[i] & zt[j]) == num[i]) && ((num2[i] & (~zt[j])) == num2[i])) {
					f[i&1][j] = (f[i&1][j] + f[(i-1)&1][k]) > MOD ? (f[i&1][j] + f[(i-1)&1][k] - MOD) : (f[i&1][j] + f[(i-1)&1][k]);
				}
			}
		}
	}
	ll ans = 0;
	for (ll i = 1; i <= cnt; i++) 
		ans = (ans + f[N&1][i] > MOD) ? (ans + f[N&1][i] - MOD) : (ans + f[N&1][i]);
	cout << ((ans > MOD) ? ans - MOD : ans);
    return 0;
}

bool check(ll a) {
    if (a & (a << 1)) return false;
    if (a & (a >> 1)) return false;
    return true;
}
```

---


# 看守

## 题目描述

给出 $d$ 维空间的 $n$ 个点，求曼哈顿距离最大的两个点的曼哈顿距离。

两个 $d$ 维的点 $(x_1,x_2,\ldots,x_d)$，$(y_1,y_2,\ldots,y_d)$ 的曼哈顿距离定义为 $|x_1-y_1|+|x_2-y_2|+\ldots+|x_d-y_d|$。


## 说明/提示

#### 数据规模与约定

- 对于 $60\%$ 的数据，保证 $d\le2$。
- 对于 $100\%$ 的数据，保证 $2\le n\le10^6$，$d\le4$，且坐标每一维保证 $1\le x_i\le 10^5$。

## 样例 #1

### 输入

```
4 2
2 1
1 4
4 5
5 3```

### 输出

```
6```

# 题解

## 作者：隐心 (赞：36)

这道题要求求的是曼哈顿距离，什么是曼哈顿距离呢？题目里已经解释了，几个点之间的横纵坐标的差的绝对值，所以这里我们以二维的图为例子。

~~您好，您的灵魂画手已上线~~

就二维的图来说，存在两种情况

~~不会上传本地的画图那就用表格代替了，假装这是一个平面直角坐标器~~

![](https://s1.ax1x.com/2018/09/21/in1h2q.png)

~~怎么调表格都不对仗工整那就这样吧~~

我这里举出了二维中的所有情况，x与y这种的左边的在下面，和x与z这种的左边的在上面。

对于x与y之间的曼哈顿距离，是不是等于y到起点1的曼哈顿距离减去x到起点1的曼哈顿距离？

对于x与z之间的曼哈顿距离，是不是等于z到起点2的曼哈顿距离减去x到起点2的曼哈顿距离？

所以我们就可以算出来距离起点1最小的曼哈顿距离和距离起点1最大的曼哈顿距离之间的差，然后将这个同距离起点2最小的曼哈顿距离和距离起点2最大的曼哈顿距离之间的差相比较，取最大值。

这样即为二维的解。所以以此类推，在三维状态下，有四种情况，在四维状态下，~~作为一个三维生物，我是真的想象不出来有几种~~，我姑且猜想有八种情况~~（虽然我只考虑四种情况也过了，可能是数据正好吧）~~，但是严谨一点来说，枚举所以第四维的情况的话是有八种的。这点欢迎大佬留言讨论一下。

所以代码如下

```cpp
#include<bits/stdc++.h>
#define ll long long
ll start=0x7fffffff;
using namespace std;
ll read(){
	ll x=0,f=1; char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1; c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0'; c=getchar();}
	return x*f;
}
ll x[]={-start,-start,-start,-start,-start,-start,-start,-start};
ll y[]={-start,start,start,-start,-start,start,start,-start};
ll z[]={-start,-start,start,start,-start,-start,start,start};
ll ls[]={-start,-start,-start,-start,start,start,start,start};
ll a[10];
ll sum[10];
ll maxx[10];
ll minn[10];
ll ans;
ll n,d;
int main()
{
	cin>>n>>d;
/*	if(d==4)
	{
		//cout<<"我想象不出四维";
		return 0;
	}*/
	for(ll i=1;i<=n;i++)
	{
		for(ll j=1;j<=d;j++)
		{
			a[j]=read();//用cin直接超时，不要问我怎么知道的
		}
		for(ll j=0;j<8;j++)
		{
			sum[j]=0;
		}
		for(ll j=0;j<8;j++)
		{
			sum[j]=sum[j]+abs(a[1]-x[j])+abs(a[2]-y[j])+abs(a[3]-z[j])+abs(a[4]-ls[j]);
		}
		for(ll j=0;j<8;j++)
		{
			if(sum[j]>maxx[j])
			{
				maxx[j]=sum[j];
			}
			if(sum[j]<minn[j]||minn[j]==0)
			{
				minn[j]=sum[j];
			}
			if(ans<maxx[j]-minn[j])
			{
				ans=maxx[j]-minn[j];
			}
		}
	}
	cout<<ans;
	return 0;
}

```

以及在线求大佬给估一下时间复杂度

---

## 作者：514InParadox (赞：33)

# P1648 看守

### 题意

求点集中两点间曼哈顿距离的最大值

### 思路

暴力枚举为 $O(n^2)$ ，需要优化，发现曼哈顿距离有一些很好的性质，所以我们考虑从距离公式入手。

我们设两个点

$\qquad \qquad A(\,a_1,a_2,...,a_d\,)\ ,\  B(\,b_1,b_2,...,b_n) $

则这两个点的曼哈顿距离为

$\qquad \qquad dist_{A,B}=\sum\limits_{i=1}^d \mid a_i-b_i \mid$

容易发现绝对值不好参与运算，但是我们考虑绝对值性质可以将其化为取最大值:

$\qquad \qquad \mid a_i-b_i \mid \ = \max\{\ a_i-b_i \,,\, b_i-a_i\ \}$

而$max$运算相比绝对值有一些很好的性质，比如说它满足分配律：

$\qquad \qquad \max\{a,b\}+\max\{c,d\}=\max\{\,a+c,a+d,b+c,b+d\}$

所以我们可以将原式化简:

$\qquad \qquad dist_{A,B}=\max\limits_{q_i\in\{-1,1\}}\{\sum\limits_{i=1}^dq_i*a_i\,+\,\sum\limits_{i=1}^{d}-q_i*b_i\}$

其中 $q_i$ 即为枚举的 $a_i$ 与 $b_i$ 的符号。

这个式子或许增加了运算复杂度。但我们再引入$C$点后求最大距离：

$\qquad \qquad dist_{max}=\max\{dist_{A,B}\,,\,dist_{B,C}\,,\,dist_{A,C}\}$

$\qquad \qquad =\max\limits_{qi\in\{-1,1\}}\left\{\ \sum\limits_{i=1}^dq_i*a_i\,-\,\sum\limits_{i=1}^{d}q_i*b_i\ ,\ \sum\limits_{i=1}^dq_i*b_i\,-\,\sum\limits_{i=1}^{d}q_i*c_i\ ,\ \sum\limits_{i=1}^dq_i*a_i\,-\,\sum\limits_{i=1}^{d}q_i*c_i\ \right\}$

再加上 $dist_{B,A}$ 作最后补完处理，我们就能得出大括号中的值即$\sum\limits_{i=1}^dq_i*dot_i$中的最大值减去最小值。

实际枚举 $q_i$ 的时候，我们可以发现 $q_i$ 与 $-q_i$ 的情况等价，所以可以做一个只枚举一半的优化。

```
#include<bits/stdc++.h>
#define INF 1000000007
#define MAXN 1000005
#define MAXD 5
using namespace std;

template<typename T>
inline void read( T& r )
{
	r=0;
	bool w=true;
	char ch=getchar();
	while( ch<'0' || ch>'9' ) w=(!(ch^45))?false:w,ch=getchar();
	while( ch>='0' && ch<='9' ) r=(r<<1)+(r<<3)+(ch^48),ch=getchar();
	r=w?r:-r;
}
//================================
int n,d,a[MAXN][MAXD],ans;
bool m[5];
int main()
{
	read(n),read(d);
	for(register int i=1;i<=n;i++)
	{
		for(register int j=1;j<=d;j++)
		{
			read(a[i][j]);
		}
	}
	
	for(register int k=0;k<(1<<(d-1));k++)
	{
		int maxa=-INF,minb=INF;
		for(register int i=1;i<=d;i++)
		{
			m[i]=(k&(1<<(i-1)))?1:0;
		}
		for(register int i=1;i<=n;i++)
		{
			int suma=0;
			for(register int j=1;j<=d;j++)
			{
				suma+=a[i][j]*(1-m[j]*2);
			}
			maxa=max(maxa,suma),minb=min(minb,suma);
		}
		ans=max(ans,maxa-minb);
	}
	printf("%d",ans);
	return 0;
}

```

---

## 作者：Kelin (赞：22)

题意:给你n个点,求max{|x1-x1|+|x2-x2|+...+|xd-xd|}
D=1:|x1-y1|=max{x1-y1,y1-x1}
D=2:|x1-y1|+|x2-y2|=max{x1-x2+y1-y2,x1-x2+y2-y1,x2-x1+y1-y2,x2-x1+y2-y1}
D=3:.....

可以发现对于D维时的两个点(x1,x2,..,xd),(y1,y2,..,yd)将他们的绝对值去掉

就要分xi-yi,yi-xi进行讨论,如果xi符号为+,yi符号就为-,反正亦然

所以可以枚举每一维度xi的符号,那么对应yi的符号也可确定

就是求每个维度在某个符号状态下的最大值

我们可以2^D\*n\*D枚举出这些状态的最大值

然后Ans=max{ans[状态i]+ans[状态i的补集]}

虽然有些状态明显不存在(如max{xi}的符号是-号),但是这样显然不会记录到最大值里


---

## 作者：xwh_Marvelous (赞：16)

**说句题外话**，大佬的题解都看不懂。搞懂这题的我决定写个亲民的题解出来。

## 正文部分
曼哈顿距离怎么求，题目说的清清楚楚，但枚举每个直接 $O(n^2)$，时间复杂度爆炸，但里面有个绝对值，怎么办？

回忆一下，初中时遇到绝对值会怎么做？**分类讨论。**

所以，我们可以将所有符号组合枚举出来。由于 $d\le4$，所以，枚举所有符号组合只有最多 $2^d$ 即 $16$ 种可能。在枚举最大最小值，它两之差即为这个符号组合的最大值，复杂度 $O(n)$。总的复杂度 $O(2^dn)$，可以过。

有细心的 OIer 会问了，如果这样导致某一维度是负数怎么办？实际上，如果是负数，那么肯定有更优的符号组合使得某一维相减不是负数，从而让答案更大。这样，某维相减为负的答案肯定不会计入最终答案。

### AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,d,ans;
struct point {
	int d[6];
} a[1000005];
int main() {
	scanf("%d%d",&n,&d);
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=d; j++) {
			scanf("%d",&a[i].d[j]);
		}
	}
	for(int k=0; k<(1<<d); k++) {
		int minn=INT_MAX,maxx=INT_MIN;
		for(int i=1; i<=n; i++) {
			int sum=0;
			for(int j=1; j<=d; j++) {
				if((k>>j-1)&1)sum+=a[i].d[j];
				else sum-=a[i].d[j];
			}
			minn=min(minn,sum);
			maxx=max(maxx,sum);
		}
		ans=max(ans,maxx-minn);
	}
	cout<<ans;
	return 0;
}
```

Update: 本是过审题解，修改了一处公式错误，特此说明。

---

## 作者：yellow (赞：11)

曼哈顿距离定义为|X1-Y1|+|X2-Y2|+…+|Xn-Yn|

如果是一维的数据，就是最大的x-最小的x，

但是二维不可以（有负数），可能是-(x1-X1)+(x2-X2);所以我们尝试用绝对值去写

|xi-yi|+|xj-yj|可以转化为

xi-yi+xj-yj

xi-yi+yj-xj

yi-xi+xj-yj

yi-xi+yj-xj

所以当我们除去每一个数的绝对值，每一个点会得到2^k个一维坐标，距离最大是不会变的，贴一下核心的代码：

```cpp
for (int k=0;k<(1<<m);k++)
	{
		maxx=-INF,minn=INF;
		for (int i=1;i<=n;i++)
		{
			int sum=0;
			for (int j=1;j<=m;j++)
			{
				if (k&(1<<(j-1))) sum+=a[i][j];
				else sum-=a[i][j];
			}
			maxx=max(maxx,sum);
			minn=min(minn,sum);
		}
		ans=max(ans,maxx-minn);
	}
```

---

## 作者：zxtikes (赞：6)

### 题面描述

给出 $d$ 维空间的 $n$ 个点求曼哈顿距离最大的两个点的曼哈顿距离。

对于任意两点 $a$ , $b$ ,曼哈顿距离 $dis$ 定义为如下：

$$
\text{dis}_{a,b}=\sum_{i = 1}^{d}{|a_i-b_i|}
$$


------------
### 解题思路

首先如果考虑暴力的做法，依次枚举每两个点，求出两点的距离，得到最大值，时间复杂度 $O(n^2)$ , 复杂度明显超出题目范围，所以接下来考虑优化的做法。

观察题目，我们唯一可以下手的地方就是绝对值，接下来思考绝对值的性质：

$$
|a - b| =
\begin{cases}
a-b,a>b\\
b-a,a<=b
\end{cases}
=a\times  k-b\times  k
$$
其中 $k\in\{1,-1\}$ , $(a\times  k-b\times  k)>=0$

各位可能认为以上分析都是废话，~~实则确实如此~~，但我们可以发现，两个数之间相减的绝对值只会有这个相减的值本身和这个值的相反数，两种情况而已。

我们可以观察到 $d<=4$ 。数据很小。很明显，状态压缩能够表达。

所以到了这里，就可以和我们学的状态压缩相关联了，接下来我们思考如何讲题目问题转化为状态压缩问题。

我们再次回到曼哈顿距离的这个概念，可以得到：

$$
\text{dis}_{a,b}=\sum_{i=1}^{d}{|a_i-b_i|} =
\sum_{i=1}^{d}
\begin{cases}
a_i-b_i,a_i>b_i\\
b_i-a_i,a_i<=b_i
\end{cases}
=
\sum_{i=1}^{d}a_i\times  k-b_i\times  k
$$

其中 $k\in\{1,-1\}$ , 对于 $\forall i\in[1,d]$ ,都满足 $(a_i\times  k-b_i\times  k)>=0$

通过最后一个式子我们可以发现，每两点的曼哈顿距离 $\text{dis}_{a,b}$ ,可以通过 $a,b$ 两点的状态（接下来会说明这个状态如何表达），来得出这个 $\text{dis}_{a,b}$ 。

我们用二进制表达一个点的状态，一共 $d$ 个维度，所以我们用 $d$ 位二进制表达，其中 $1$ 表示这个维度的数为正，$0$ 表示这个维度的值为负，即  $1,0$ 表示 $k$ 的取值情况

定义一个点的权值 $\text{val}_x$:
$$
\text{val}_x=\sum_{i=1}^{d}{x_i\times  k}
$$
其中 $k\in\{1,-1\}$

所以 $\text{dis}_{a,b}=\text{val}_a-\text{val}_b$

其中对于 $\forall i\in[1,d]$ ,都满足 $(a_i\times  k-b_i\times  k)>=0$ 

------------
### 结论
最后我们显然能知道，要使 $\text{dis}_{a,b}$ 最大，就要使 $\text{val}_a-\text{val}_b$ 最大，所以我们依次状态压缩，找到在同一状态下，点的权值最大值和最小值，最后所有的状态下最大值和最小值的差值就是我们需要的最大曼哈顿距离。

其中由于可能会出现 $(a_i\times  k-b_i\times  k)<0$ 的情况，这种情况明显不满足我们上述曼哈顿距离或绝对值的定义。

但我们思考后，很简单的能得到，在我们状态定义中出现这种情况，那么这种情况一定不会作为我们的最后答案。因为这种情况会对答案做出负贡献，而我们每一个维度做出的贡献一定是正的，所以这种情况一定不会是最大值，会在我们的计算过程中被直接的掩盖，不会作为最后答案，所以也不会影响我们最后的答案。

时间复杂度 $O(2^d\times n\times d)$ ,可以通过。

------------
### 代码展示
虽然个人感觉讲的很清楚了，但还是贴一下代码给大家理解理解吧

```cpp
#include<bits/stdc++.h>
#define ll long long
#define inf 1e9
#define rep(i,l,r) for(register int i=l;i<=r;i++)
#define per(i,r,l) for(register int i=r;i>=l;i--)
using namespace std;
const int N=1e6+10,D=5;

int n,d;
int a[N][D];
int ans;
inline int read(){
	int s=0,w=1;
	char ch=getchar();
	while (ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
int main(){
	n=read(),d=read();
	rep(i,1,n)
	    rep(j,1,d)
	        a[i][j]=read();
	rep(i,0,(1<<d)-1){
		int maxn=-inf,minn=inf;
		rep(j,1,n){
			int ret=0;
			rep(k,1,d){
				if(i&(1<<k-1))ret+=a[j][k];
				else ret-=a[j][k];
			}
			maxn=max(maxn,ret);
			minn=min(minn,ret);
		}
		ans=max(ans,maxn-minn);
	}
	printf("%d\n",ans);
	return 0;
} 
```



---

## 作者：珈乐唯毒 (赞：5)

#  来一波玄学做法
以二维为例，将任意一个点作为原点构造平面直角坐标系，那么在第一象限与第三象限，第二象限与第四象限的点的曼哈顿距离就等于这两个点到原点的曼哈短距离的和。

三维、四维在相对象限两个点同理。

那么我们只要找出一个点使得曼哈顿距离最大的两个点在它的相对象限即可。

可是只找一个点可能无法确定，因此可以使用随机函数找十个点，这样通过的概率就会很高~~除非你是个非酋~~

上代码
```
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
int n,k;
int x[N][5],ma[20],ans;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int main(){
//	freopen("jail.in","r",stdin);
//	freopen("jail.out","w",stdout);
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=k;j++)
			x[i][j]=read();
	int t=1;
	while(t--){
		memset(ma,0,sizeof(ma));
		int u=rand()%n+1;
		for(int j=1;j<=n;j++){
			int ty=0,temp=0;
			for(int i=1;i<=k;i++){
				temp+=abs(x[u][i]-x[j][i]);
				if(x[u][i]>=x[j][i])
					ty+=(1<<(i-1));
			}
			ma[ty]=max(temp,ma[ty]);
		}
		for(int j=0;j<(1<<k);j++)
			ans=max(ans,ma[j]+ma[(1<<k)-1-j]);
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：MD_17L (赞：5)

 1. 题意：有N个点,每个点给D个坐标,求两个点之间的最小距离,距离为|x1-X1|+|x2-X2|+...+|xd-XD|
 
2. 公式推导：
- |x1-X1|=max{x1-X1,-x1+X1}
- |x1-X1|+|x2-X2|=max{x1-X1+x2-X2,x1-X1-x2+X2,-x1+X1+x2-X2,-x1+X1-x2+X2}
- find:每一个x如果考虑正负号,D=2时有4种表达式,所以有2^D个表达式.观察max中的元素,每个式子中的xi和Xi的符号相反。

3. 思路：so将正号看作1,负号看作0,就能用位数为D的二进制数表示状态
 
 - 代码

    ```cpp
    #include <iostream>
    #include <cstdio>
    #include <cstdlib>
    #include <cstring>
    #include <cmath>
    #include <algorithm>
    using namespace std;
    long long INF=100000007;
    int a[1000005][6],n,d,ans;

     int main()
    {
        scanf("%d%d",&n,&d);
        for (int i=1; i<=n; i++)
            for (int j=1; j<=d; j++) scanf("%d",&a[i][j]);
        int sum,Max,Min;
        for (int k=0; k<(1<<d); k++)//枚举2^D种状态
        {
            Max=-INF; Min=INF;//计算每种状态下的最大值和最小值
            for (int i=1; i<=n; i++)
            {
                sum=0;
                for (int j=1; j<=d; j++) 
                    if (k&(1<<(j-1))) sum+=a[i][j];//符号为正,sum加上当前值
                    else sum-=a[i][j];//符号为负
                Max=max(Max,sum);
                Min=min(Min,sum);
            }
            ans=max(ans,Max-Min);
        }
        printf("%d\n",ans);
        return 0;
    }
    ```



---

## 作者：inexistent (赞：5)

官方题解说的不是很清楚

n非常大，n^2过不了。但是d非常小。题目是让我们求|X1-Y1|+|X2-Y2|+…+|Xd-Yd|。带有绝对值，不能整体算。所以我们可以分类讨论，而对于|a-b|只有两种可能：a-b或b-a。对于各个维度上的值，都可以有正负两种取法。而确定了x的符号，y就必须与x异号。所以我们可以dfs枚举各个维度上是取正的还是负的。

由于绝对值已经拆掉了，所以利用加法交换律，根据枚举的符号，先求出每一个点各个维度的的总和X[i]，再求出每个点取相反符号的总和Y[j]。答案一定是X[i] + Y[j]。（也就是让这两点匹配）而要让X[i]+Y[j]尽量大，也就是让X[i]尽量大，Y[j]尽量大。因此，打擂求最大值。

```cpp
/*this code is written by -=Qxz=- */
#include <cstdio>
#include <cctype>
#include <cstring>
#define  INF  (0x3f3f3f3f)
#define  Max(a,b)  ((a) > (b) ? (a) : (b))
#define  Min(a,b)  ((a) < (b) ? (a) : (b))
#define  N  (1000010)
typedef long long ll;
using namespace std;
template <class T>
inline void read(T &x){
    int f = 0, ch = 0; x = 0;
    for(; !isdigit(ch); ch = getchar()) if(ch == '-') f = 1;
    for(; isdigit(ch); ch = getchar()) x = (x<<3) + (x<<1) + ch - '0';
    if(f) x = -x;
}
int n,d,max_x,max_y,tmp,ans;
int a[N][5],x[N][5],y[N][5];
bool zf[10];
void Get_Max(int p){
	if(p > d){
		max_x = -INF,max_y = -INF;
		for(int i = 1; i <= n; ++i){
			tmp = 0;
			for(int j = 1; j <= d; ++j) tmp += a[i][j] * (zf[j]?1:-1);
			max_x = Max(max_x, tmp);
			tmp = 0;
			for(int j = 1; j <= d; ++j) tmp += a[i][j] * (zf[j]?-1:1);
			max_y = Max(max_y, tmp);
		}
		ans = Max(ans, max_x + max_y);
		return;
	}
	zf[p] = 0, Get_Max(p+1);
	zf[p] = 1, Get_Max(p+1);
}
int main(){
	read(n),read(d);
	for(int i = 1; i <= n; ++i)
		for(int j = 1; j <= d; ++j)
			read(a[i][j]);
	memset(zf,0,sizeof(zf));
	Get_Max(1);
	printf("%d",ans);
	return 0;
}

```

---

## 作者：int08 (赞：4)

## 前言
最屎山的一集，但是也是代码最好理解的一集！
# Solution

发现 $d≤4$，自然想到分维度讨论（事实上最后的解法并不需要，但是我还是这么做了）

首先 $d=1$ 比较平凡，都在数轴上，最大减去最小即可。

其他的怎么办呢？先从 $d=2$ 入手。
### 1.$d=2$

我们先尝试直接去掉曼哈顿距离的绝对值：

$d_{x,y}=(x_1-y_1)+(x_2-y_2)=(x_1+x_2)-(y_1+y_2)$

经过我们一手重组，计算答案的信息变成了独立与两个点相关的。

**所以我们只需要知道每个点横纵坐标之和，取最大最小相减即可。**

但是这样并不能总是得出正确的结果，请思考为什么？

~~因为我把绝对值去了。~~ 

由初中数学得 $d_{x,y}=|x_1-y_1|+|x_2-y_2|=|(x_1-y_1)±(x_2-y_2)|$ 中的一个。

去掉绝对值这一步的影响是**略去了 $(x_1-y_1)-(x_2-y_2)=(x_1-x_2)-(y_1-y_2)$ 很大的情况。**

那我们两种情况都考虑，并取出两者中答案较大的一个，必然会覆盖最后的正确答案。

具体来说：考虑第二种的方法是：算出每个点横纵坐标之差，取最大最小相减。

现在拓展到高维吧！
### 2.$d>2$

三维为例。

发现和二维没有本质区别，只是需要考虑的情况变多了：

$d_{x,y}=|x_1-y_1|+|x_2-y_2|+|x_3-y_3|=|(x_1-y_1)±(x_2-y_2)±(x_3-y_3)|$

这次我们有 $4$ 种需要分别计算的情况，如果仍以去掉绝对值的情况为例：

我们需要知道每个点三维坐标之和，取最大最小相减。

另外三种有部分取差，不再赘述。

四维也差不多，有 $8$ 种情况。

### 3.代码咋办？

发现事实上不同维度的解法以及分讨情况高度相似，可以用一些类似状压手段合成，不用分讨。

但是，想到那一堆循环，变量以混乱的形式组合起来，我就不想写。

但是 $d≤4$ 极小无比，直接硬分讨就完了！

~~其实不是因为我懒，而是我最先就是这么想到的，这样也是思维含量最低的写法。~~

看似代码长，但是都是复制粘贴出来的，实际上只写了十来分钟还没调，是很快的。

缺点是不能拓展到 $d$ 较大情况。

## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,d,i,j,a[1234567][6],ma[10],mi[10];
int main()
{
	cin>>n>>d;
	for(i=1;i<=n;i++)
		for(j=1;j<=d;j++) scanf("%d",&a[i][j]);
		for(i=1;i<=9;i++) ma[i]=-1000000000,mi[i]=1000000000;
	if(d==1)
	{
		for(i=1;i<=n;i++)
		{
			ma[1]=max(ma[1],a[i][1]);
			mi[1]=min(mi[1],a[i][1]);
		}
		cout<<ma[1]-mi[1];
		return 0;
	}
	if(d==2)
	{
		for(i=1;i<=n;i++)
		{
			ma[1]=max(ma[1],a[i][1]+a[i][2]);
			mi[1]=min(mi[1],a[i][1]+a[i][2]);
			ma[2]=max(ma[2],a[i][1]-a[i][2]);
			mi[2]=min(mi[2],a[i][1]-a[i][2]);
		}
		cout<<max(ma[1]-mi[1],ma[2]-mi[2]);
		return 0;
	}
	if(d==3)
	{
		for(i=1;i<=n;i++)
		{
			ma[1]=max(ma[1],a[i][1]+a[i][2]+a[i][3]);
			mi[1]=min(mi[1],a[i][1]+a[i][2]+a[i][3]);
			ma[2]=max(ma[2],a[i][1]-a[i][2]+a[i][3]);
			mi[2]=min(mi[2],a[i][1]-a[i][2]+a[i][3]);
			ma[3]=max(ma[3],a[i][1]+a[i][2]-a[i][3]);
			mi[3]=min(mi[3],a[i][1]+a[i][2]-a[i][3]);
			ma[4]=max(ma[4],a[i][1]-a[i][2]-a[i][3]);
			mi[4]=min(mi[4],a[i][1]-a[i][2]-a[i][3]);
		}
		cout<<max(max(ma[3]-mi[3],ma[4]-mi[4]),max(ma[1]-mi[1],ma[2]-mi[2]));
		return 0;
	}
	if(d==4)
	{
		for(i=1;i<=n;i++)
		{
			ma[1]=max(ma[1],a[i][1]+a[i][2]+a[i][3]+a[i][4]);
			mi[1]=min(mi[1],a[i][1]+a[i][2]+a[i][3]+a[i][4]);
			ma[2]=max(ma[2],a[i][1]-a[i][2]+a[i][3]+a[i][4]);
			mi[2]=min(mi[2],a[i][1]-a[i][2]+a[i][3]+a[i][4]);
			ma[3]=max(ma[3],a[i][1]+a[i][2]-a[i][3]+a[i][4]);
			mi[3]=min(mi[3],a[i][1]+a[i][2]-a[i][3]+a[i][4]);
			ma[4]=max(ma[4],a[i][1]-a[i][2]-a[i][3]+a[i][4]);
			mi[4]=min(mi[4],a[i][1]-a[i][2]-a[i][3]+a[i][4]);
			ma[5]=max(ma[5],a[i][1]+a[i][2]+a[i][3]-a[i][4]);
			mi[5]=min(mi[5],a[i][1]+a[i][2]+a[i][3]-a[i][4]);
			ma[6]=max(ma[6],a[i][1]-a[i][2]+a[i][3]-a[i][4]);
			mi[6]=min(mi[6],a[i][1]-a[i][2]+a[i][3]-a[i][4]);
			ma[7]=max(ma[7],a[i][1]+a[i][2]-a[i][3]-a[i][4]);
			mi[7]=min(mi[7],a[i][1]+a[i][2]-a[i][3]-a[i][4]);
			ma[8]=max(ma[8],a[i][1]-a[i][2]-a[i][3]-a[i][4]);
			mi[8]=min(mi[8],a[i][1]-a[i][2]-a[i][3]-a[i][4]);
		}
		cout<<max(max(max(ma[3]-mi[3],ma[4]-mi[4]),max(ma[1]-mi[1],ma[2]-mi[2])),max(max(ma[5]-mi[5],ma[6]-mi[6]),max(ma[7]-mi[7],ma[8]-mi[8])));
		return 0;
	}
 } 
```


---

## 作者：zhengrunzhe (赞：4)

#### 信仰K-D Tree

**时间复杂度** $O(n^{\frac{2k-1}{k}})$

~~这玩意居然过了百万，最慢点不超过半秒~~

实际上kdtree做近邻/远离问题的时候就是个优化的暴力，查询就像在kd树上A*，设置估价函数，暴力搜树
```cpp
#include<cstdio>
#include<algorithm>
using std::nth_element;
template<class type>inline const void read(type &in)
{
	in=0;char ch=getchar();bool f=0;
	while (ch<48||ch>57){if (ch=='-')f=1;ch=getchar();}
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
	if (f)in=-in;
}
template<class type>inline const type max(const type &a,const type &b)
{
	return a>b?a:b;
}
template<class type>inline const type min(const type &a,const type &b)
{
	return a<b?a:b;
}
template<class type>inline const type abs(const type &x)
{
	return x<0?-x:x;
}
const int K=4,N=1e6+10,inf=2147483647;
int n,k,mx;
int f;
struct point
{
	int d[K];
	inline const bool operator<(const point &p)const
	{
		return d[f]<p.d[f];
	}
	inline const friend int manhattan(const point &a,const point &b)
	{
		int dis=0;
		for (int i=0;i<K;i++)dis+=abs(a.d[i]-b.d[i]);
		return dis;
	}
}a[N];
class KD_Tree
{
	private:
		struct tree
		{
			tree *son[2];
			point range,mn,mx;
			inline const void pushup()
			{
				for (int i=0;i<k;i++)
					mx.d[i]=max(range.d[i],max(son[0]->mx.d[i],son[1]->mx.d[i])),
					mn.d[i]=min(range.d[i],min(son[0]->mn.d[i],son[1]->mn.d[i]));
			}
			inline const int evalue(const point &p)
			{
				int f=0;
				for (int i=0;i<k;i++)f+=max(abs(p.d[i]-mn.d[i]),abs(p.d[i]-mx.d[i]));
				return f;
			}
		}*root,memory_pool[N],*tail,*null;
		inline const void init()
		{
			tail=memory_pool;
			null=tail++;
			root=null->son[0]=null->son[1]=null;
			for (int i=0;i<k;i++)null->mn.d[i]=inf,null->mx.d[i]=-inf;
		}
		inline tree *spawn(const point &x)
		{
			tree *p=tail++;
			p->range=p->mn=p->mx=x;
			p->son[0]=p->son[1]=null;
			return p;
		}
		inline tree *build(int l,int r,int d)
		{
			if (l>r)return null;
			int mid=l+r>>1;f=d;
			nth_element(a+l,a+mid,a+r+1);
			tree *p=spawn(a[mid]);
			if (l==r)return p;
			p->son[0]=build(l,mid-1,(d+1)%k);
			p->son[1]=build(mid+1,r,(d+1)%k);
			p->pushup();
			return p;
		}
		inline const void query(tree *p,const point &x)
		{
			if (p==null)return;
			mx=max(mx,manhattan(p->range,x));
			int f[2]={-inf,-inf};
			if (p->son[0]!=null)f[0]=p->son[0]->evalue(x);
			if (p->son[1]!=null)f[1]=p->son[1]->evalue(x);
			bool t=f[0]<=f[1];
			if (f[t]>mx)query(p->son[t],x);t^=1;
			if (f[t]>mx)query(p->son[t],x);
		}
	public:
		inline const void build()
		{
			init();root=build(1,n,0);
		}
		inline const void query(const point &x)
		{
			query(root,x);
		}
}kdt;
int main()
{
	read(n);read(k);
	for (int i=1;i<=n;i++)
		for (int j=0;j<k;j++)
			read(a[i].d[j]);
	kdt.build();
	for (int i=1;i<=n;i++)kdt.query(a[i]);
	printf("%d\n",mx);
	return 0;
}
```

---

## 作者：Link_Cut_Y (赞：1)

不大一样的做法。

先从二维情况入手，我们发现如果直接求的话需要 $O(n ^ 2)$ 的复杂度。但是如果我们将它转化为切比雪夫距离，即将每个点的坐标变为 $\mathrm{(x + y, x - y)}$，答案就变成了 $\max \{ |x_i - x_j|, |y_i - y_j|\}, i, j \in [1, n]$，遍历 $1 \sim n$ 并得到横纵坐标的最大、最小值。答案即为横（纵）坐标最大值最小值得差。复杂度 $O(n)$。

同样的，对于高于二维的曼哈顿距离，同样可以将其转化为切比雪夫距离。尽管高于二维的曼哈顿距离和切比雪夫距离不能同维转化，但是可以做到升维转化，具体证明可以看这里：[曼哈顿空间转切比雪夫空间能否推广至更高维？](https://www.zhihu.com/question/396319776)

这样 $d$ 维曼哈顿距离就可以被转化称为 $2 ^ {d - 1}$ 维切比雪夫距离，按照二维同样的做法，可以在 $O(2 ^ {d - 1} n)$ 复杂度内求得答案。$d \leq 4$，显然可过。

当然这样的转化方法也可以使用状压来完成，两种解法本质上相同。

Update：加入代码示例。

```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <vector>

using namespace std;

const int N = 1000010;
int n, d, ans, p[N][4], q[1 << 3][N];
vector<int> Max(1 << 3, -2e9), Min(1 << 3, 2e9);

void get(int x) { // 转为切比雪夫距离
	for (int i = 0; i < 1 << d - 1; i ++ ) {
		for (int j = 0; j < d; j ++ )
			q[i][x] += ((1 << j) & i ? p[x][j] : - p[x][j]);
		Max[i] = max(Max[i], q[i][x]), Min[i] = min(Min[i], q[i][x]);
	}
}
int main() {
	scanf("%d%d", &n, &d);
	for (int i = 0; i < n; i ++ )
		for (int j = 0; j < d; j ++ )
			scanf("%d", &p[i][j]);
	for (int i = 0; i < n; i ++ ) get(i);
	for (int i = 0; i < 1 << d - 1; i ++ )
		ans = max(ans, Max[i] - Min[i]);
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：Arghariza (赞：1)

考虑两个点的曼哈顿距离 $dis(x,y)=\sum\limits_{i=1}^{k}|x_i-y_i|$，显然可以求出某个 $a$ 序列，将其表示成 $\sum\limits_{i=1}^{k}(-1)^{a_i}(x_i-y_i)$ 的形式，其中 $a_i\in \{0,1\}$。

我们发现有个性质，即曼哈顿距离一定是 $a$ 序列 $2^k$ 种方案中最大的，因为是绝对值相加。

所以 $\sum\limits_{i=1}^{k}|x_i-y_i|=\max\limits_{\forall i,a_i\in \{0,1\}}\{\sum\limits_{i=1}^{k}(-1)^{a_i}(x_i-y_i)\}$。

我们发现 $2^k$ 只有 $16$，可以对于每一个 $a$，对每个点计算出 $f(a,x)=\sum\limits_{i=1}^{k}(-1)^{a_i}x_i$，然后两个点的曼哈顿距离就是 $\max\limits_{\forall i,a_i\in \{0,1\}}\{f(a,x)-f(a,y)\}$。

记 $a$ 的补集（每位取反）为 $\overline a$，则 $dis(x,y)=\max\limits_{\forall i,a_i\in \{0,1\}}\{f(a,x)+f(\overline a,y)\}$。

于是我们算出 $f(a,x)$ 后，对每个 $x$ 都取其最大值 $g(a)=\max\limits_{i=1}^{n}\{f(a,i)\}$，然后答案即为 $\max\limits_{\forall i,a_i\in \{0,1\}}\{g(a)+g(\overline a)\}$。

复杂度 $O(2^k n)$。

```cpp
#include <bits/stdc++.h>
namespace mystd {
	inline int read() {
	    char c = getchar();
	    int x = 0, f = 1;
	    while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();
	    while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + c - '0', c = getchar();
	    return x * f;
	}
	inline void write(int x) {
	    if (x < 0) x = ~(x - 1), putchar('-');
	    if (x > 9) write(x / 10);
	    putchar(x % 10 + '0');
	}
}
using namespace std;
using namespace mystd;

const int maxn = 1e6 + 100;
int n, k, a[10], t[20];

int main() {
	n = read(), k = read();
	memset(t, -0x3f, sizeof(t));
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= k; j++) a[j] = read();
		for (int s = 0; s <= (1 << k) - 1; s++) {
			int tp = 0;
			for (int l = 1; l <= k; l++) {
				if ((s >> (l - 1)) & 1) tp += a[l];
				else tp -= a[l];
			}
			t[s] = max(t[s], tp);
		}
	}
	int res = 0;
	for (int s = 0; s <= (1 << k) - 1; s++) {
		res = max(res, t[s] + t[((1 << k) - 1) ^ s]);
	}
	write(res);
	return 0;
}

```

还有个[双倍经验](https://www.luogu.com.cn/problem/CF1093G)，加一棵线段树即可。

---

## 作者：一串数字 (赞：1)

### 状压是什么？这不是个几何题吗？

先看看二维的情况。

首先，对于一个给定的点，它的`曼哈顿距离等值线`长这样：

![等值线](https://cdn.luogu.com.cn/upload/image_hosting/398gqavy.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

~~（所以说要学好初中地理~~ 黑色部分到给定点的`曼哈顿距离`都相等。

显然，白色部分任意一点到中心的曼哈顿距离小于黑色部分；灰色部分任意一点到中心的曼哈顿距离大于黑色部分。

那么这道题就转化成了，求出最大的一个`正方形`，满足以下条件：
- 以一个给定点为中心
- 存在另一个给定点在其中一条边上
- 四条边的斜率都是 $\pm 1$

对于每个点，我们计算出**过该点**且斜率为$\pm 1$的两条直线

![2](https://cdn.luogu.com.cn/upload/image_hosting/bmje405n.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

保存维护 $n$ 个点中上述直线`截距`的**最大最小值**（共4个，分别是：斜率 $+1$ 最大值，斜率 $-1$ 最大值，斜率 $+1$ 最小值，斜率 $-1$ 最小值）


我们将上述四个值记作 $posiMax,negaMax,posiMin,negaMin$，其代表的四条直线围成一个矩形。我们称该矩形为“边界”。

![3](https://cdn.luogu.com.cn/upload/image_hosting/xnjb8fvv.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

显然所有点都在“边界”内部。以任意一个点为中心（下图中的蓝色点）所能画出的**可能**符合条件的最大正方形（蓝色）一定不会越过最远的那一条直线。

![4](https://cdn.luogu.com.cn/upload/image_hosting/gg59h0gi.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

而上述正方形什么时候`不符合条件`呢？有可能图中绿线和蓝线重合的区域内**没有任何一个给定点**。幸运的是，这种情况并不存在，看图：

![5](https://cdn.luogu.com.cn/upload/image_hosting/bka4bkp9.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

绿线是我们找到的最远直线。假设 $B$ 点在蓝绿相交的部分外，则一定存在一条红线，使蓝色矩形拓展更远，即绿线一定不是距离 $A$ 点最远的那一条，假设不成立。

显然最大正方形应该以“边界”上的点为中心，这样才能扩得更大。这道题进一步转化为求上述直线中距离最远的一对。~~（读者自证不难~~

直接输出 $max(posiMax-posiMin, negaMax-negaMin)$ 预计得分 $60Pts$ 实际得分 $72Pts$。贴出代码：

```cpp
#include<iostream>
#include<cassert>

using namespace std;

const int MAXN = 1e6+9;

long long x[MAXN],y[MAXN];
int d,n;
long long posiMax = -1e14,posiMin = 1e14;
long long negaMax = -1e14,negaMin = 1e14;

int main(){
	ios::sync_with_stdio(false);cin.tie(0);
	cin>>n>>d;assert(d==2);
	for(int i=1; i<=n; i++)cin>>x[i]>>y[i];
	for(int i=1; i<=n; i++){
		negaMax = max(negaMax,x[i]+y[i]); //过(x,y)且斜率-1的直线截距显然为x+y
		negaMin = min(negaMin,x[i]+y[i]);
		
		posiMax = max(posiMax,y[i]-x[i]); //过(x,y)且斜率1的直线截距显然为y-x
		posiMin = min(posiMin,y[i]-x[i]);
	}
	
	cout<<max(posiMax - posiMin, negaMax - negaMin)<<endl;
	
	return 0;
}
```

扩展到三维，三维空间中曼哈顿距离的等值面为正八面体。所以只需要计算过每个点**四个方向**的平面，初始化出“边界”的八个平面，求距离最远的一对平面。维护平面，我们同样只需要记录其与y轴交点（因为平面的方向已知）。方便起见，我们将这八个平面从正面开始按顺时针编号 $1-4$ ，将与y轴交点记作 $upper$ $1-4$ 与 $lower$ $1-4$。

![图源wl](https://cdn.luogu.com.cn/upload/image_hosting/k3gqjwzb.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

四维空间不太好想，不过可以类比，初始化“边界”的十六个胞，求距离最远的一对。

至此，无任何表达式推导，这题就做完了，相信你可以自己写出完整代码。

---

## 作者：STrAduts (赞：1)

由题可知：${\rm dist}(x, y) = |x_1 - y_1| + |x_2 - y_2| + \dots + |x_d - y_d|$。

且该式可化为：${\rm dist}(x, y) = \sum_{i = 1}^{d} \max(x_i - y_i, y_i - x_i)$。

对于任意 $i \in [1, d]$ ，记 $q_i = x_i - y_i$。

则 ${\rm dist}(x, y) = \max(\sum_{i = 1} ^ {d} q_i \times (-1) ^ {k_i}), k_i \in [0, 1]$。

即 ${\rm dist}(x, y) = \max(\sum_{i = 1} ^ {d} x_i \times (-1) ^ {k_i} - y_i \times (-1) ^ {k_i}), k_i \in [0, 1]$。

于是我们可以考虑枚举所有的 $k$ 序列的样子，并求出这 $n$ 个点的坐标在 $k$ 序列下坐标权值的最大值与最小值。

最大值与最小值的差即为该 $k$ 序列能提供的最大权值，整体再取一个最大值就是最终答案。

因为 $|k| = d$，且 $d \leq 6$，故直接状压保存 $k$ 序列即可，时间复杂度 $O(2^d nd)$。

```cpp
#include <cstdio>

int Abs(int x) { return x < 0 ? -x : x; }
int Max(int x, int y) { return x > y ? x : y; }
int Min(int x, int y) { return x < y ? x : y; }

int read() {
    int x = 0, k = 1;
    char s = getchar();
    while (s < '0' || s > '9') {
        if (s == '-')
            k = -1;
        s = getchar();
    }
    while ('0' <= s && s <= '9') {
        x = (x << 3) + (x << 1) + (s ^ 48);
        s = getchar();
    }
    return x * k;
}

void write(int x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}

void print(int x, char c) {
    write(x);
    putchar(c);
}

const int MAXM = 32;
const int MAXN = 1e6 + 5;
const int INF = 2147483647;

int q[MAXN][6], t[MAXM];

int main() {
    int n = read(), d = read();
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= d; j++) q[i][j] = read();
    if (n == 1) {
        print(0, '\n');
        return 0;
    }
    int ans = -INF;
    for (int i = 0; i < (1 << d); i++) {
        int ma = -INF, mi = INF;
        for (int j = 1; j <= n; j++) {
            int tot = 0;
            for (int k = 0; k < d; k++)
                if (i & (1 << k))
                    tot += q[j][k + 1];
                else
                    tot -= q[j][k + 1];
            ma = Max(ma, tot);
            mi = Min(mi, tot);
        }
        ans = Max(ans, ma - mi);
    }
    print(ans, '\n');
    return 0;
}
```

---

## 作者：hytree (赞：1)

由于曼哈顿距离实则是{A}-{B},{A}与{B}均表示点,\
则为{Ax1,Ax2,Ax3,Ax4}-{Bx1,Bx2,Bx3,Bx4},由于绝对值的关系,所以每个x1,x2,x3,x4符号都 **_对应相同_ .**;   

我们分开来看就是{Ax1},与{Bx1}对应,在绝对值中同正同负.由于d<=4,所以关于x1,x2,x3,x4的符号排列全部可能有**2^D**种;

各位可能还会好奇|Ax1-Bx1|的符号问题,但我们不需要管.枚举这些符号即可.  

所以我们用一个二进制数k来枚举|Ax1-Bx1|,|Ax2-Bx2|,|Ax3-Bx3|,|Ax4-Bx4|的符号排列,当**k&(1<<(j-1))** 不为0时,则表示|Axj-Bxj|为正数,如k=1时则为 Ax1-Bx1,此时对于A与B而言,他们的x1均为正的.\

我们用一个**suma** 来存A此状态下的贡献,**sumb** 存b此状态下的贡献,**当 suma最大,sumb,最小时曼哈顿距离最大** 对于suma与sumb的取法,我们只用开个**sum在此状态k下** 求每个点的各维x1,x2,x3,x4的贡献然后,**suma取最大sum,sumb取最小sum即可**\

我们即可枚举状态去取每个k下 suma-sumb的最大值即可.
```
#include<bits/stdc++.h>
using namespace std;
int a[1000010][5],n,d,ans,sum,suma,sumb;
int main()
{
    scanf("%d%d",&n,&d);
    for(int i=1;i<=n;i++)
    for(int j=1;j<=d;j++)
	scanf("%d",&a[i][j]);
    for(int k=0;k<(1<<d);k++)
    {
        suma=-INT_MAX;sumb=INT_MAX;
        for(int i=1;i<=n;i++)
        {
            sum=0;
            for(int j=1;j<=d;j++)
            if(k&(1<<(j-1))) sum+=a[i][j];
            else sum-=a[i][j];
            suma=max(suma,sum);
            sumb=min(sumb,sum);
        }
        ans=max(ans,suma-sumb);
    }
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：BobPiggy (赞：0)

首先来看看曼哈顿距离公式。



两个 $d$ 维的点 $(x_1,x_2,\ldots,x_d)$，$(y_1,y_2,\ldots,y_d)$ 的曼哈顿距离定义为 $|x_1-y_1|+|x_2-y_2|+\ldots+|x_d-y_d|$。

暴力法就是枚举任意两点求曼哈顿距离，会超时。

然后考虑从公式入手：**拆绝对值！！！**

首先把绝对值全部换成括号，那么距离就变成了：
$(x_1-y_1)+(x_2-y_2)+\ldots+(x_d-y_d)$

这会导致什么问题呢？

会发现有些括号项会被减成负数！所以直接拆括号所得答案一定是小于等于正确答案的！

这里注意到维度 $d$ 范围很小，所以可以考虑枚举每个绝对值拆下来后是正还是负，这里使用二进制状态压缩，当前位为1表示正，为0表示负。

然后根据状态改变原来点坐标的正负，用最大坐标和减去最小坐标和得出当前状态下的最优答案，取最大值就可得到最终答案。


为什么是正确的呢？因为如果有的项正负反了，结果一定是小于正确答案。题目要求取最大值，所以不会有影响。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int N = 1e6 + 10;
const ll INF = 0x7f7f7f7f7f7f7f7f;

int t;

int n, m;

ll a[N][6];

int main()
{
   cin >> n >> m;

   for(int i = 1; i <= n; i++)
      for(int j = 1; j <= m; j++)
      {
         cin >> a[i][j];
      }

   ll ans = 0;
   for(int i = 0; i < (1 << m); i++){
      ll maxn = -INF, minn = INF;

      for(int j = 1; j <= n; j++){
         ll sum = 0;

         for(int k = 1; k <= m; k++){
            if(i & (1 << (k - 1))) sum += a[j][k];
            else sum -= a[j][k];
         }

         maxn = max(sum, maxn);
         minn = min(sum, minn);
      }

      ans = max(ans, maxn - minn);
   }

   cout << ans;
   return 0;
}

```




---


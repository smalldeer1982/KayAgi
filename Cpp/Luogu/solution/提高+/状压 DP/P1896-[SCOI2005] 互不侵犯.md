# [SCOI2005] 互不侵犯

## 题目描述

在 $N \times N$ 的棋盘里面放 $K$ 个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共 $8$ 个格子。

## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le N \le 9$，$0 \le K \le N\times N$。

---

$\text{upd 2018.4.25}$：数据有加强。

## 样例 #1

### 输入

```
3 2
```

### 输出

```
16
```

# 题解

## 作者：KesdiaelKen (赞：777)

####先声明一下，我这一篇题解是写给初学状压DP的同学看的，如果已有基础请看其他dalao的题解。所以就不要嫌我啰嗦啦(^\_^)

首先，看到这一题，就知道如果不是搜索，就是DP。当然搜索是过不了的，所以就应该尝试想出一个DP的解法。

DP的前提之一当然是要找出一个可以互相递推的状态。显然，目前已使用的国王个数当然必须是状态中的一个部分，因为这是一个限制条件。那么除此之外另外的部分是什么呢？

我们考虑到每行每列之间都有互相的约束关系。因此，我们可以用行和列作为另一个状态的部分（矩阵状压DP常用行作为状态，一下的论述中也用行作为状态）。

又看到数据范围： 1 <=N <=9。这里我们就可以用一个新的方法表示行和列的状态：数字。考虑任何一个十进制数都可以转化成一个二进制数，而一行的状态就可以表示成这样——例如：

$1010$(2)

就表示：这一行的第一个格子没有国王，第二个格子放了国王，第三个格子没有放国王，第四个格子放了国王（注意，格子从左到右的顺序是与二进制从左到右的顺序相反的，因为真正在程序进行处理的时候就像是这样的）。而这个二进制下的数就可以转化成十进制：

$10$(10)

于是，我们的三个状态就有了：第几行（用i表示）、此行放什么状态（用j表示）、包括这一行已经使用了的国王数（用s表示）。

考虑状态转移方程。我们预先处理出每一个状态（sit[x]）其中包含二进制下1的个数，及此状态下这一行放的国王个数（gs[x]），于是就有：

$f[i][j][s]=sum(f[i-1][k][s-gs[j]])$，$f[i][j][s]$**就表示在只考虑前i行时，在前i行（包括第i行）有且仅有s个国王，且第i行国王的情况是编号为j的状态时情况的总数。而k就代表第i-1行的国王情况的状态编号**

其中k在1到n之间，j与k都表示状态的编号，且k与j必须满足两行之间国王要满足的关系。（对于这一点的处理我们待会儿再说）

这个状态转移方程也十分好理解。其实就是上一行所有能够与这一行要使用的状态切合的状态都计入状态统计的加和当中。其中i、j、s、k都要枚举。

再考虑国王之间的关系该如何处理呢？在同一行国王之间的关系我们可以直接在预处理状态时舍去那些不符合题意的状态，而相邻行之间的关系我们就可以用到一个高端的东西：位运算。由于状态已经用数字表示了，因此我们可以用与（∧）运算来判断两个状态在同一个或者相邻位置是否都有国王——如果：

$sit[j]$&$sit[k]$**(及上下有重复的king)**

$(sit[j]<<1)$&$sit[k]$**(及左上右下有重复king)**

$sit[j]$&$(sit[k]<<1)$**(及右上左下有重复king)**

这样就可以处理掉那些不符合题意的状态了。

总结一下。其实状压DP不过就是将一个状态转化成一个数，然后用位运算进行状态的处理。理解了这一点，其实就跟普通的DP没有什么两样了。

最后上代码（注意其中的一些细节处理）：



```cpp
    #include<cstdio>
    #include<iostream>
    #include<cstring>
    #include<cmath>
    #include<string>
    #include<algorithm>
    using namespace std;
    int sit[2000],gs[2000];
    int cnt=0;
    int n,yong;
    long long f[10][2000][100]={0};
    void dfs(int he,int sum,int node)//预处理出每一个状态
    {
        if(node>=n)//如果已经处理完毕（注意是大于等于）
        {
            sit[++cnt]=he;
            gs[cnt]=sum;
            return;//新建一个状态
        }
        dfs(he,sum,node+1);//不用第node个
        dfs(he+(1<<node),sum+1,node+2);//用第node个，此时node要加2，及跳过下一个格子
    }
    int main()
    {
        scanf("%d%d",&n,&yong);
        dfs(0,0,0);
        for(int i=1;i<=cnt;i++)f[1][i][gs[i]]=1;//第一层的所有状态均是有1种情况的
        for(int i=2;i<=n;i++)
            for(int j=1;j<=cnt;j++)
                for(int k=1;k<=cnt;k++)//枚举i、j、k
                {
                    if(sit[j]&sit[k])continue;
                    if((sit[j]<<1)&sit[k])continue;
                    if(sit[j]&(sit[k]<<1))continue;//排除不合法国王情况
                    for(int s=yong;s>=gs[j];s--)f[i][j][s]+=f[i-1][k][s-gs[j]];//枚举s，计算f[i][j][s]
                }
        long long ans=0;
        for(int i=1;i<=cnt;i++)ans+=f[n][i][yong];//统计最终答案，记得用long long
        printf("%lld",ans);
        return 0;
}
```

---

## 作者：暗ざ之殇 (赞：725)

# 做完后的一点体会，希望能帮助和我一样不熟练状压 dp 的萌新
## 写得挺详细的，对萌新极为友好

![](https://img2018.cnblogs.com/i-beta/1617486/201911/1617486-20191105111256766-2039103522.png)

## 闲话时刻：

日常打开洛谷，看了一眼智能推荐题目：

![](https://cdn.luogu.com.cn/upload/image_hosting/civ6frl1.png)

$1896 [SCOI2005]$互不侵犯？


~~水题啊！~~ 嗯，一道状压 $dp$ 好题，之前老早就想做了，正好练练状压 $dp$，于是就开始做了起来；

## 题目大意：
~~一般来说题目越短越难。~~

在一个 $ n * n$ 的图中选 $k$ 个点，使得以每个点为中心的九宫格内有且只有它一个点，问方案数；

## 题解：
一道很好的状压 $dp$ 练手题；

状压状压，就是把一种状态压缩成一个数，达到节省空间的目的；

举个栗子：

假设我们有一行是这样放的国王（红色位置表示放国王）：

![](https://cdn.luogu.com.cn/upload/image_hosting/thweit3z.png)

正常操作：我们可以开一个一维数组 $f [ i ]$ 表示第 $i$ 个位置有没有放上国王；

状压操作：

上面的渣渣真是费空间，看我的！ 

由于每个格子只有两种状态：放国王 和 不放国王 ，所以我们可以用 $1$ 表示放国王，$0$ 表示不放国王；

那么把每个格子的数连起来就是：

![](https://cdn.luogu.com.cn/upload/image_hosting/1i6pegxc.png)


这是什么？如果我们将这个$01$串看成是一个二进制数的话，那么这种状态就被我们完美的表示成了一个数，这个数在十进制下是：$(101001)_2$ $=$ $( 41)_{10}$

所以状压 $dp$ 的套路就是不断的去枚举表示状态的数，去转移即可。

### 状态设置：
按照状压 $dp$ 的套路，我们设状态：$dp [ i ][ j ][ S ]$ 表示我们已经选到了第 $i$ 行，第 $i$ 行的状态为 $S$，用了 $j$ 个国王的方案数；

### 转移方程：
首先看一下国王的攻击范围（以其为中心的九宫格）：

红色代表国王位置，蓝色代表它的攻击范围： 

![](https://cdn.luogu.com.cn/upload/image_hosting/n6pfwo99.png)


思考：如果我们第 $i-1$ 行的第 $j$ 列放好国王之后，那么对第 $i$ 行的影响是什么呢？

也就是国王在第 $i$ 行上的攻击范围内的格子不能再放国王了：

![](https://cdn.luogu.com.cn/upload/image_hosting/0mg64zxm.png)


也就是说，如果第 $i-1$ 行的状态 $S_1$（表示状态的二进制数）的第 $j$ 位是 $1$（放国王）的话，第 $i$ 行的状态 $S_2$ 的第 $j-1$，$j$，$j+1$ 位一定为 $0$（不能再放国王了），否则就是不合法的状态；

那怎么表示这一条件呢？回归到二进制上来看： 

假如我们现在正在决定第 $i$ 行的状态：

![](https://cdn.luogu.com.cn/upload/image_hosting/pndgxpp2.png)


显然这个红色的 $1$ 是不合法的，但是怎么知道它是不合法的呢？

这里就要运用巧妙的位运算了： 

此时 **$S_1$ & $S_2 ≠ 0 $**；

那如果是右下方有一个国王呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/uw6qlieg.png)


我们可以按照刚刚那样的方法用位运算：

$1.$ 先将 $S_2$ 向左移一位：


![](https://cdn.luogu.com.cn/upload/image_hosting/va8i5lhw.png)


$2.$ 然后这样两个 $1$ 就冲齐了，此时两种状态的 & 运算是不为 $0$ 的；

$(S_2<<1)$ & $S_1 ≠ 0$；

在左下方的情况同理：


![](https://cdn.luogu.com.cn/upload/image_hosting/mnfqarbg.png)


$1.$ 我们先将 $S_2$ 向右移一位：


![](https://cdn.luogu.com.cn/upload/image_hosting/20jxduto.png)

 
 $2.$ 然后发现此时两状态的 & 运算不为 $0$；

$(S_2>>1)$ & $S_1 ≠ 0$； 


所以我们就得出了表示这三个位置的方法，那么 $S_2$ 必须满足什么条件才可能由 $S_1$ 转移过去呢？

条件：$( S_2 $ & $S_1$ $== 0 )$ && $(  ( S_2<<1 )$ & $ S_1 ) == 0 )$ && $( ( S_2>>1 )$ & $S_1 == 0 )$

我们发现这样写有点长，还可以这样写哦：

$( S_2 | ( S_2>>1 ) | ( S_2<<1 ) )$ & $S_1 ==0$ 

当然，我们处理完行间的限制后，接下来就要处理行内的限制了；

一个国王的左右格子内不能再放国王了，这就是行内的限制！

运用上面的第二，三种情况的做法，问题就迎刃而解了：

$1.$ 判断左边有没有国王：

我们将 $S_2$ 向右移一位，再与原来的 $S_2$ 做 & 运算：

![](https://cdn.luogu.com.cn/upload/image_hosting/6vrj3m2w.png)


观察到 $1$ 左边的数右移后跑到了 $1$ 的位置上，所以我们再做一次 & 运算即可：

若结果为 $0$ ，说明那一位是 $0$（合法）；否则为 $1$（不合法）； 

$2.$ 判断右边有没有国王：

同理，将 $S_2$ 左移一位再做 & 运算：

![](https://cdn.luogu.com.cn/upload/image_hosting/jmktydl8.png)


把上述过程转化成代码：

$( ( S_2<<1 )$ & $S_2 ==0 )$ && $( ( S_2>>1 )$ & $S_2 ==0 )$

更短的写法：

$( ( S_2<<1 ) | ( S_2>>1 ) )$ & $S_2 ==0$

所以我们下一步的状态 $S_2$ 要同时满足这两个条件才可以哦~

因为第二个条件只与状态的情况有关，所以我们可以预处理这个东西，$dp$ 的时候将所有满足第二条性质的状态拿出来看看是否再满足第一条性质就好了；

考虑第二维怎么转移的：

显然对于第 $i-1$ 行来说，第 $i$ 行多放的国王数就是第 $i$ 行的状态上 $1$ 的个数（在二进制下）；

综上，则有 $dp [ i ][ j ][ S_2 ] += dp [ i-1 ][ j-cnt [ S_2 ] ][ S_1 ]$ ，（其中 $S_2$ 要满足上述两个条件，$cnt [ S_2 ]$ 表示 $S_2$ 在二进制下有几个 $1$）

~~发现转移方程类似于背包 $dp$ 时的方程~~

### 边界设置
刚开始一个偌大的棋盘，我们啥也不知道，只知道它的第 $0$ 行不能放旗子（先说有第 $0$ 行嘛$qwq$）；

即 $dp [ 0 ][ 0 ][ 0 ] = 1$；

### 答案输出
最后的情况，肯定是我们已经考虑完 $n$ 行的排放情况，并且在其中一定是只放了 $k$ 个国王了，但对于第 $n$ 行具体摆成什么稀奇古怪的亚子，我们也不知道，所以我们去枚举第 $n$ 行所有可能的情况，统计答案就好了；

## 细节提示
最后注意开 $long long$ 哦~，不然随时见到你的祖宗

 

完整代码（详细注释版）：
```
#include<iostream>
#include<cstdio>
using namespace std;
int n,k,num;
long long cnt[2000],ok[2000];   
//cnt[i]:第i种状态的二进制中有几个1
//ok[i]:第i个行内不相矛盾(满足条件2:左右国王不相邻)的状态是多少 
long long dp[10][100][2000];
//dp[i][j][s]:我们已经放了i行,用了j个国王,第i行的状态为s的方案数
int main() 
{
    cin>>n>>k;                    //n*n的棋盘上放k个国王 
    for(int s=0;s<(1<<n);s++)     //枚举所有可能状态 
    {
        int tot=0,s1=s;           //tot:二进制下有多少个1; 
        while(s1)                 //一位一位枚举,直至为0(做法类似于快速幂那样) 
        {
            if(s1&1) tot++;       //如果最后一位是1,tot++ 
            s1>>=1;               //右移看下一位 
        }
        cnt[s]=tot;               //预处理这个二进制数有多少个1
        if((((s<<1)|(s>>1))&s)==0) ok[++num]=s; //如果这一状态向左向右都没有重复的话,说明左右不相邻,合法 
    }
    dp[0][0][0]=1;                //第0行一个也不放的方案数
    for(int i=1;i<=n;i++)         //枚举我们已经放到了第几行 
    {
        for(int l=1;l<=num;l++)   //枚举第i行的状态,这里我们直接枚举所有满足条件2的状态,算是个优化吧 
        {
            int s1=ok[l];             
            for(int r=1;r<=num;r++) //枚举上一行的状态 
            {
                int s2=ok[r];
                if(((s2|(s2<<1)|(s2>>1))&s1)==0)  //如果上下,左下右上,左上右下方向都不相邻,合法 
                {    
                       for(int j=0;j<=k;j++) //枚举国王个数 
                        if(j-cnt[s1]>=0)  
                            dp[i][j][s1]+=dp[i-1][j-cnt[s1]][s2];  //状态转移方程       
                }
            }
        }
    }
    long long ans=0;
    for(int i=1;i<=num;i++) ans+=dp[n][k][ok[i]];  //枚举第n行所有可能的情况,统计答案 
    printf("%lld\n",ans);    //输出 
    return 0;
}
```

做题的道路并不是一帆风顺的，博主在做题的时候对 $dp$ 的枚举顺序一直不是很明白，听了 [$qyf$ 神仙](https://www.luogu.org/user/45543)的讲解后才豁然开朗，在此感谢一下 $qyf$ 神仙；

在此我再将 $qyf$ 神仙的解释以我的理解说一下吧，帮助一下有同样困惑的 $Oier$：

一开始我的顺序是这样的：
```
for(int l=1;l<=num;l++)   //第i行的状态 
{
    int s1=ok[l]; 
    for(int r=1;r<=num;r++) //第i-1行的状态 
    {
        int s2=ok[r]; 
        if(((s2|(s2<<1)|(s2>>1))&s1)==0) 
        {    
            for(int i=1;i<=n;i++)  //枚举选到了哪一行 
                for(int j=0;j<=k;j++)  //枚举国王个数 
                    if(j-cnt[s1]>=0)  
                        dp[i][j][s1]+=dp[i-1][j-cnt[s1]][s2];    
        }
    }
}
```
错误的原因：

我们注意到在 $dp$ 过程中我们是按照状态从小到大去枚举的，所以 $dp$ 数组的赋值顺序是按照 $S_1$ 和 $S_2$ 从小到大来依次赋值的，换句话说，哪一个状态转化成十进制的数越小，它所对应的 $dp$ 值越先被赋值；**但是在 $dp$ 过程中， 上一行的状态 $S_2$ 是有可能比当前行状态 $S_1$ 要大的，但是因为我们现在正在给 $S_1$ 所对应的状态赋值，所以比 $S_1$ 还大的 $S_2$ 固然还没有被赋值，所以这就漏掉了好多情况，导致答案偏小；**

**正确写法：**

**我们先枚举 $i$，再枚举状态 。这样的话就是按照所选的行来转移，即使 $S_2$ 再比 $S_1$ 大，但 $S_2$ 终究是上一行的状态** ，**是一定已经被算过的了，这就保证了不重不漏!** 

---

## 作者：da32s1da (赞：461)

打表是一种优良的传统，比如**[P4484 [BJWC2018]最长上升子序列](https://www.luogu.org/problemnew/show/P4484)**。

打表可以让本要**TLE**的代码**0ms**通过~~(前提是正确的)~~。对于这道题，我们发现是个状压DP，而题目要求的范围比较小，故……
```
#include<cstdio>
#include<iostream>
long long a[300]={
1,
4,0,0,0,
9,16,8,1,0,0,0,0,0,
16,78,140,79,0,0,0,0,0,0,0,0,0,0,0,0,
25,228,964,1987,1974,978,242,27,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
36,520,3920,16834,42368,62266,51504,21792,3600,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
49,1020,11860,85275,397014,1220298,2484382,3324193,2882737,1601292,569818,129657,18389,1520,64,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
64,1806,29708,317471,2326320,12033330,44601420,119138166,229095676,314949564,305560392,204883338,91802548,25952226,4142000,281571,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
81,2968,65240,962089,10087628,77784658,450193818,1979541332,6655170642,17143061738,33787564116,50734210126,57647295377,49138545860,31122500764,14518795348,4959383037,1237072414,224463798,29275410,2673322,163088,6150,125,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
},b,c;
int main(){
    scanf("%d%d",&b,&c);
    std::cout<<a[(b-1)*b*(2*b-1)/6+c-1];
}
```
另外最后输出时，由于我这是一维数组，输出答案时还要用到这个公式。
$$\sum_{i=1}^n{i^2}=\frac{n*(n+1)*(2*n+1)}{6}$$

PS:于2018.4.23修改

---

## 作者：冰冻赤道 (赞：215)

本蒟蒻发现dalao们的代码不怎么好懂，还要现找上方的解释，所以手打了一份代码上自带解释的，适合新手理解，不要嫌我啰嗦；

本题呢，不算难，很明显的状压，只是加上需要考虑国王的数量。

这里附带一点网上感觉很棒的总结；

![大佬总结状压位运算的基本操作](https://images2018.cnblogs.com/blog/1220103/201802/1220103-20180221173155785-1390737716.png)

规则显而易见，代码上都有我的解释，适合同类蒟蒻；

**有心提醒一句**

**本题解中大量的位运算，涉及符号的先后顺序，务必要注意括号的位置！！**

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,k;
long long dp[10][15000][80]; //dp[i][j][k]表示第i行，状态为j，前面摆了k个国王时，方案数； 
long long state[777777] , king[77777] ;//state[]是当前状态，king[]是当前行的国王数；
long long ans , sum;//ans是用来记录状态总数的，sum是用来计算一共有多少种方案的；

inline void inte()
{
	int tot = (1<<n) - 1;//最多到这个时候，就是二进制下，每一位上都放上国王，当然有不行的，为了方便下文排除； 
	for(int i = 0 ; i <= tot ; i++)
		if(!((i<<1)&i))			//因为要互不侵犯，所以，两个国王之间必须隔一个，这是判断是否满足题意国王之间不相互攻击； 
		{
			state[++ans] = i;	//找到了满足的，记录这个状态； 
			int t = i;
			while(t)				//判断这个状态有多少个国王，也就是t在二进制下有多少个1； 
			{
				king[ans] += t%2;
				t>>=1;				//记住，是右移一位，和  t/=2 一样，就是稍微快一点； 
			}
		}
 } 

int main()
{
	cin>>n>>k;							//数据； 
	inte();								//初始化； 
	for(int i = 1; i <= ans ; i++)		//先处理第一行； 
		if(king[i] <= k)						//一行的国王数一定不能超过总数； 
			dp[1][i][king[i]] = 1;
	
	for(int i = 2 ; i <= n ; i++)							//处理剩下的，所以从 2 开始枚举； 
		for(int j = 1; j <= ans ; j++)						//枚举状态； 
			for(int p = 1; p <= ans ; p++)					//再一遍状态，用来当作上一行的状态，因为 我们由上向下递推，能迎上本行的，只有上一行； 
			{												//这里就不在赘述了，和处理第一行同理，但是不同的是这里处理相邻的行，
				if(state[j] & state[p])	continue;				 //所以，上下相邻不行
				if(state[j] & (state[p]<<1))	continue;		 //本行的右上角不能有国王； 
				if((state[j]<<1) & state[p])	continue;		//左上角也不行； 
				for(int s = 1 ; s <= k ; s++)
				{												//s表示本行以上用了多少国王； //满足条件后，还要记得国王数量是有限的！！
					if(king[j] + s > k)	continue;				 //我们是递推，所以本行以上一定处理完了，所以，本行加以前用过的国王，总数不能超过限定；
					dp[i][j][king[j]+s] += dp[i-1][p][s];	 	//还记得dp[i][j][k]中的k表示已经用过的国王数，而king[]是本行的，s是本行以前的； 
				}
			}
	
	for(int i = 1; i <= n ; i++)						//因为不确定在哪一行用光国王，所以都枚举一遍； 
		for(int j = 1 ; j <= ans ; j++)					
			sum += dp[i][j][k];							//本行及以前用光了国王，那么方案数加在总数中； 
	
	cout<<sum;
	return 0;	
	
}
```



---

## 作者：p_b_p_b (赞：76)

我也是无聊到一种境界了，竟然来发题解。

言归正传。这题一看n<=9，二话不说就上状压DP。

dp[i][j][k]表示第i行，状态为j，共k个国王时的方案数。

为了减小常数，我们可以先预处理出所有满足要求的状态，存在can数组里，再用num数组存储当前状态有几个国王。

判断上下是否符合要求也十分简单，乱&一下就可以了。

在我的代码中，dp[i][j][k]中的j表示第j个状态。

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cnt,MAX;
long long dp[20][1000][400];
int can[1000],num[2000];
int getsum(int x)
{
	int ret=0;
	while (x) ret+=(x&1),x>>=1;
	return num[cnt]=ret;
}
int main()
{
	register int i,j,k,l,x,y;
	long long ans=0;//记得long long 
	scanf("%d %d",&n,&m);
	MAX=(1<<n)-1;
	for (i=0;i<=MAX;i++) if (!(i&(i<<1))) can[++cnt]=i,dp[1][cnt][getsum(i)]=1;//预处理大法好 
	for (i=2;i<=n;i++)
	{
		for (j=1;j<=cnt;j++)
		{
			x=can[j];
			for (k=1;k<=cnt;k++)
			{
				y=can[k];
				if ((x&y)||(x&(y<<1))||(x&(y>>1))) continue;//乱& 
				for (l=0;l<=m;l++) dp[i][j][num[j]+l]+=dp[i-1][k][l];//转移 
			}
		}
	}
	for (i=1;i<=cnt;i++) ans+=dp[n][i][m];//都加起来 
	printf("%lld",ans);
}
```

---

## 作者：YZhe (赞：45)

## 状压DP的入门好题
**backgrand**:今天，蒟蒻Tryer在机房的DP专场考试中，抱着~~爆零~~坚定的决心，在考场上悟出了状压DP的精髓，并且没有爆零！！！


### 先安利一波常用的位运算技巧：
1.取出x的第i位:
```cpp
int main()
{
    y = (x>>(i-1))&1;
    return 0;
}
```
2.将x第i位取反:
```cpp
int main()
{
    x ^= (1<<(i-1));
    return 0;
}
```
3.将x第i位变为1：
```cpp
int main()
{
    x |= (1<<(i-1));
    return 0;
}
```
4.将x第i位变为0：
```cpp
int main()
{
    x &= (~(1<<(i-1)));
    return 0;
}
```
5.将x最靠右的1去掉：
```cpp
int main()
{
    x = x&(x-1);
    return 0;
}
```
6.取出x最靠右的1:
```cpp
int main()
{
    y = x&(-x);
    return 0;
}
```
7.判断是否有两个连续的一：
```cpp
int main()
{
    if(x&(x<<1)) cout<<"YES";
    return 0;
}
```
8.枚举子集：
```cpp
int main()
{
    for( int x = sta ; x ;  x = ( ( x - 1 )&sta) )
      cout<<x;
    return 0;
}
```
这些操作真的很常用，很好用，一定要在理解的基础上记忆，可以试着手动推导一下。


------------
### 下面进入正题

这道题很简单，想了一会一遍就过了。

#### Beginning

我们还是需要定义一个dp数组

```cpp
long long dp[11][1<<9][166];
//在第i层，状态为j时，放k个的方案数
``` 
值得一提的是，每一行的每个状态都有不同的方案数，且**与同一行的其他状态无关**

#### Next

因为第一行的比较特殊，所以我个人习惯将第一行单独提出来处理一下。

算法是，每枚举每个状态，然后判断这个状态是否满足题目条件，不符合就continue,然后我们统计这个状态存在的棋子数cnt,自然而然的，dp[1][sta][cnt] = 1;

代码如下
```cpp
for( ri sta = 0 ; sta <= ( 1<<n ) - 1 ; sta++ ){
    	bool b = false;
    	int cnt = 0;
    	//判断该状态是否合法,并统计已经放的棋子数 
    	for( ri j = 1 ; j <= n ; j++ ){
    		if( sta>>( j - 1 )&1 ) cnt++;
    		if( ( sta>>j&1 ) && ( sta>>( j - 1 )&1 ) ){
			    b = true;
				break;
			}
    	}
	    if( b ) continue;
    	dp[ 1 ][ sta ][ cnt ] = 1;
    }
```
由于我们需要判断是否有连续的棋子，所以我们可以用到上面提到的操作7,但是我们又需要统计这个状态存在的棋子数cnt,所以干脆直接一位一位地拆。

如果各位dalao有其他更好的方法，欢迎提出。

#### Next

下面会用到很多技巧

我们自然地会想到枚举每一行的每个状态，然后判断这个状态是否合法，但是最关键的状态转移又该如何进行呢？？？

我们考虑先定义一个状态fsta = (1<<n)-1;

它代表上面的每个地方都放了棋子，然后我们利用当前状态，来修改fsat，得到一个可行方案的**最大集合**，然后枚举它的**每个子集**，这样状态转移就变得异常简单了。

代码实现：
```cpp
          int fsta = ( 1<<n ) - 1;
	      if( sta&1 ){
	          fsta &= ( ~1 );
	          fsta &= ( ~2 );
	      }//特殊处理第一格 
		  for( ri j = 2 ; j <= n ; j++ )
		  	if( sta>>( j - 1 )&1 ){
		  		fsta &= ( ~( 1<<( j - 2 ) ) );
		  		fsta &= ( ~( 1<<( j - 1 ) ) );
		  		fsta &= ( ~( 1<<j ) );
		  	} 
		  //这一格如果有棋子，其上一排的正上方，左上方，右上方都要取0
	      //枚举所有子集，包括0
		  for( ri x = fsta ; 1 ; x = ( ( x - 1 ) & fsta ) ){
		  	  for( ri k = 0 ; k <= n * n ; k++ )
		  	  	dp[ i ][ sta ][ cnt + k ] += dp[ i - 1 ][ x ][ k ];
		  	  if( x == 0 ) break;
		  }//注意，因为我们需要0作为一个子集，所以与上面提到的操作8略有不同
```

#### End

**谢谢你看完蒟蒻我写的题解，虽然解法不一定很优，但是应该比较好理解吧.qwq**

---

## 作者：bingliang (赞：25)

考前发一波题解或许会使rp++

离退役只有50个小时了吗？

实际状压dp顾名思义，就是采用位运算，来记录更多的必须记录的状态。来做dp

实际有了比较深的dp功底后只要对位运算有了解就可以解决问题。。。。

1对于dp 做题  50道以上吧

2.着重讲位运算

1. &  x&y  |  x|y    ^ x^y  都是基本的运算符 这些都可以百度到的  按顺序 说就是  与 或 异或  都是把左右两个10进制数转换为2进制之后在进行操作的
2.  >>   <<    分别为 右移 和 左移   在非竞赛中对其还有更详细的区分    x>>1  相当于/2

3.一些基本的操作

1.得到n位全为1的数    (1<<n)-1

2.将第i位改成1  x=x|（1<<(i-1)）

3.将2进制下最右边的一个1去掉  x=x&（x-1）       或  x-=（x&（-x））

就是这样了拥有了这些位运算知识我们就可以解决问题啦！


那就回到这道题   记得原来有道一样的题 叫m国王


这个题  我们就先处理出每行有多少种国王不相邻的情况 （有同学要问了这样答案也不满足题中的条件啊），没事这个我们可以在枚举i中解决

就是说同时枚举第i行的时候和i-1行   看看是否成立。    于是就用正常的dp思路想就好了


---

## 作者：MyukiyoMekya (赞：18)

我第一眼看到这道题就觉得是轮廓线dp（或者叫插头dp），结果AC后发现洛谷52篇题解没有一篇是轮廓线dp。。。

~~像这种往一个大方框里面填奇奇怪怪的形状，然后这个大方框有一边特别窄的难道不就是轮廓线dp么~~

首先，我们转换一下问题

```
1 X X X
2 X K O
3 O O O
```

对于 K 即国王的位置，我们明显不需要 `O` 的部分，我们只需要关心 `X` 的部分会不会碰到其他的 `K`

当然，这是按照从左往右从上往下的顺序枚举填充。

那么显然我们要保存并枚举 1 2 两行的状态，

$f_{i,j,mask1,mask2,k}$ 表示 $(i,j)$ 位置当前行的状态是 $mask1$ ，上一行状态 $mask2$，放置 $k$ 个国王的方案数

但是这有点逊

![](https://cdn.luogu.com.cn/upload/image_hosting/6s86mu2k.png)

假设我们现在枚举到绿色方格的位置，那么我们现在枚举的 2 行状态中，其实棕色部分是没有用的

所以我们可以把红色部分看成 1 行，然后多带了 1 个粉色位置的状态，这样就把 2 行 状态压成了 “1行”

怎么压呢？正常轮廓线dp都是把红色部分压成一行，那么我们只要多开一维或者把粉色状态放在红色的后面就行

我们称这条紫色线为轮廓线，

上面的红色方格（当然这题里面还要包括粉色）就是我们要枚举有没有放过国王的状态

然后就是枚举绿色部分放不放国王，进行转移

当然如果放了会和轮廓线状态内国王产生冲突就只能不放，不放也是要转移的


转移完绿色方格后的新状态（即轮廓线）需要调整，具体可以看代码。

这是上面那张图的绿色方格转移完后轮廓线的调整

![](https://cdn.luogu.com.cn/upload/image_hosting/qmaoi7sn.png)

那么 $f_{i,j,mask}$ 的前两位可以滚存掉

时间复杂度 $O(n^2\times 2^{n+1})$

当然，我们也可以预处理出每个 $j$ 对应的所有合法的轮廓线状态，这样可以更快

```cpp
// This code wrote by chtholly_micromaker(MicroMaker)
#include <bits/stdc++.h>
#define reg register
using namespace std;
template <class t> inline void read(t &s)
{
	s=0;
	reg int f=1;
	reg char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(isdigit(c))
		s=(s<<3)+(s<<1)+(c^48),c=getchar();
	s*=f;
	return;
}
long long f[2][(1<<10)+5][82];
bool vis[2][10];
vector<int> Masks[10];
int n,K;
inline bool check(int mask,int pos)
{
	memset(vis,false,sizeof vis);
	if(pos>0&&mask&(1<<n))
		vis[0][pos-1]=true;
	for(int i=pos;i<n;++i)
		if(mask&(1<<i))
			vis[0][i]=true;
	for(int i=0;i<pos;++i)
		if(mask&(1<<i))
			vis[1][i]=true;
	for(int i=0;i<n-1;++i)
		if((vis[0][i]&&vis[0][i+1])||(vis[1][i]&&vis[1][i+1]))
			return false;
	for(int i=0;i<n;++i)
		if(vis[1][i])
		{
			if(vis[0][i])
				return false;
			if(i>0&&vis[0][i-1])
				return false;
			if(i<n-1&&vis[0][i+1])
				return false;
		}
	return true;
}
signed main(void)
{
	cin>>n>>K;
	reg int full=(1<<(n+1))-1;
	reg int fpos=0;
	f[fpos][0][0]=1;
	for(int j=0;j<n;++j)
		for(int mask=0;mask<=full;++mask)
			if(check(mask,j))
				Masks[j].push_back(mask);
	for(int i=0;i<n;++i)
		for(int j=0;j<n;++j)
		{
			for(int maskid=0;maskid<(int)Masks[j].size();++maskid)
			{
				reg int mask=Masks[j][maskid];
				for(int k=0;k<=K;++k)
				{
					reg int nmask=(mask&(~(1<<j)))&(~(1<<n));
					if(mask&(1<<j))
						nmask|=(1<<n);
					f[fpos^1][nmask][k]+=f[fpos][mask][k];
				}
				if(mask&(1<<j))
					continue;
				if(j>0&&(mask&(1<<(j-1))))
					continue;
				if(j<n-1&&(mask&(1<<(j+1))))
					continue;
				if(j>0&&mask&(1<<n))
					continue;
				for(int k=0;k<K;++k)
					f[fpos^1][(mask|(1<<j))&(~(1<<n))][k+1]+=f[fpos][mask][k];
			}
			for(int mask=0;mask<=full;++mask)
				for(int k=0;k<=K;++k)
					f[fpos][mask][k]=0;
			fpos^=1;
		}
	reg long long ans=0;
	for(int i=0;i<=full;++i)
		ans+=f[fpos][i][K];
	cout<<ans<<endl;
	return 0;
}
```



---

## 作者：loving丶Drug (赞：15)

## 法一(借鉴了一下别人的题解@KesdiaelKen): 

定义$f[i][j][s]$为前几行(i)有且仅有(s)个国王,且第i行国王的情况是编号为(j)的状态是情况的总数


先将状态 **** $(sit[ ])$ ****和此状态下这一行放的国王数量全部预处理出来全部预处理出来
```cpp
inline void solve (int status, int sum, int node)//当前此行的状态,现在此行一共选了多少个国王,当前选到了第几个格子
{
    if (node >= n)
    {
        sit[++cnt] = status;
        king[cnt] = sum;
        return;//新建一个状态
    }
    solve (status, sum, node + 1);//不用第node个格子
    solve (status + (1 << node), sum + 1, node + 2);//用第node个格子,此时node要+２,即跳过下一个格子
}
```

接下来考虑题目的条件:

1. 在同一行国王之间的关系我们可以直接在预处理状态时舍去那些不符合题意的状态

2. 国王不能上下相互重复
```cpp
if(sit[j] & sit[k]) continue
```
3. 国王不能左上右下相互重复
```cpp
if((sit[j]<< 1) & sit[k]) continue
```
4. 国王不能左下右上相互重复
```cpp
if(sit[j] & (sit[k] << 1)) continue
```

最后状态转移方程将每一行的情况处理出即可

```cpp
for (register int o = K; o >= king[j]; --o)
     f[i][j][o] += f[i - 1][k][o - king[j]];
```

记得最后要统计****方案数****

贴代码

~~码风hin丑，轻喷~~
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define LL long long

template <typename T> inline bool chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}
template <typename T> inline bool chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}

using namespace std;

const int maxn = 2010;
int n, K, cnt = 0;
int sit[maxn], king[maxn];
LL f[10][maxn][110];//前几行(i)有且仅有(s)个国王,且第i行国王的情况是编号为(j)的状态是情况的总数

inline void File ()
{
    freopen ("qinfan.in", "r", stdin);
    freopen ("qinfan.out", "w", stdout);
}

template <typename T> inline T read ()
{
    T ret = 0;
    char ch = getchar();
    while (!isdigit (ch))
        ch = getchar ();
    while (isdigit (ch))
    {
        ret = (ret << 3) + (ret << 1) + (ch & 15);
        ch = getchar ();
    }
    return ret;
}

inline void write (int x)
{
    if (x / 10) write (x / 10);
    putchar (x % 10 + '0');
}

inline void solve (int status, int sum, int node)//当前此行的状态,现在此行一共选了多少个国王,当前选到了第几个格子
{
    if (node >= n)
    {
        sit[++cnt] = status;
        king[cnt] = sum;
        return;//新建一个状态
    }
    solve (status, sum, node + 1);//不用第node个格子
    solve (status + (1 << node), sum + 1, node + 2);//用第node个格子,此时node要+２,即跳过下一个格子
}

int main ()
{
    File ();

    n = read<int>();
    K = read<int>();
    solve (0, 0, 0);
    for (register int i = 1; i <= cnt; ++i)
        f[1][i][king[i]] = 1;//第一层的所有状态均是有1种情况的
    for (register int i = 2; i <= n; ++i)
    {
        for (register int j = 1; j <= cnt; ++j)
        {
            for (register int k = 1; k <= cnt; ++k)
            {
                if(sit[j] & sit[k]) continue;
                if((sit[j]<<1) & sit[k]) continue;
                if(sit[j] & (sit[k] << 1)) continue;
                for (register int o = K; o >= king[j]; --o)
                        f[i][j][o] += f[i - 1][k][o - king[j]];
            }
        }
    }
    LL ans = 0;
    for (register int i = 1; i <= cnt; ++i)
        ans += f[n][i][K];
    write (ans);
    return 0;
}

```



------------





## 法二: 

~~这个方法比较粗暴也比较简洁~~

我觉得总体思想也差不多~~吧~~

首先我们用$popcount[ ]$预处理出没一个数在二进制下有多少个1** (写状压题基本通用) **

就像这样:
```cpp
for (register int i = 0; i < 1 << 9; ++i)
    for (register int j = 0; j < 9; ++j)
        if (i >> j&1)
           ++popcount[i];
```

现在开始dp

这一次我没有像上面那样把左右不能互相重复的情况在与处理中直接搞完了，而是直接简单粗暴的每一行扫过去然后在加上判断

~~说白了就是不带一点脑子直接暴力~~

```cpp
for (register int i = 0; i < n; ++i)
    for (register int j = 0; j <= k; ++j)
        for (register int x = 0; x < 1 << n; ++x)
            for (register int y = 0; y < 1 << n; ++y)
                if (!(y & y << 1) && !(x & y) && !(x << 1 & y) && !(x >> 1& y))
                   if (j + popcount[y] <= k)
                       f[i + 1][j + popcount[y]][y] += f[i][j][x];
```

**注意一下f数组我换了一下,第一篇题解解释过了,这个应该也差不多,看看代码就懂了**

贴上代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define LL long long

template <typename T> inline bool chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}
template <typename T> inline bool chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}

using namespace std;

const int maxn = 9;
int n, k;
LL f[maxn + 1][maxn * maxn + 1][1 << maxn], ans;
int popcount[1 << maxn];

inline void File ()
{
    freopen ("qinfan.in", "r", stdin);
    freopen ("qinfan.out", "w", stdout);
}

template <typename T> inline T read ()
{
    T ret = 0;
    char ch = getchar ();
    while (!isdigit (ch))
        ch = getchar ();
    while (isdigit (ch))
    {
        ret = (ret << 3) + (ret << 1) + (ch & 15);
        ch = getchar ();
    }
    return ret;
}

inline void write (int x)
{
    if (x < 9) write (x / 10);
    putchar (x % 10 + '0');
}

int main ()
{
    File ();

    n = read<int>();
    k = read<int>();
    for (register int i = 0; i < 1 << 9; ++i)
        for (register int j = 0; j < 9; ++j)
            if (i >> j&1)
                ++popcount[i];
    f[0][0][0] = 1;
    for (register int i = 0; i < n; ++i)
        for (register int j = 0; j <= k; ++j)
            for (register int x = 0; x < 1 << n; ++x)
                for (register int y = 0; y < 1 << n; ++y)
                    if (!(y & y << 1) && !(x & y) && !(x << 1 & y) && !(x >> 1& y))
                        if (j + popcount[y] <= k)
                            f[i + 1][j + popcount[y]][y] += f[i][j][x];
    for (register int i = 0; i < 1 << n; ++i)
        ans += f[n][k][i];
    write (ans);
    return 0;
}

```

向大家推荐两篇博客,我觉得写的非常非常好的,是我这种蒟蒻只能仰视的~~他们绝对跟我没有半点关系~~

# [扩欧解不定方程](https://www.luogu.org/blog/Tea/kuo-ou-xie-fou-ding-fang-cheng)

# [八数码](https://endsah.blog.luogu.org/solution-p1379)


最后祝愿大家(还有我自己)

# $NOIP2018  RP++$


---

## 作者：Phoenix030821 (赞：13)

## 一道较适合状压DP初学者（比如我）的练习题

我们可以看一看这道题的数据范围，1 <=N <=9。**看似很小，实则不然。**每一行的摆法就会有2^N种。但是如果把每一种摆法每一个格子的状态都表示出来，那时间空间都会太大了。

我们用1来表示这个格子里放了国王，而0表示未放。 如：
- ### 00101
- ### 10100

这样我们便可以发现，每一种摆法都可以表示为一个二进制数，而且不同的摆法二进制数不相同。
如00101便是十进制数5，10100为十进制数20

这样一行的状态便可以用一个数x表示。

### 国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子。
所以首先需要确定每一行的状态基本合法（即每一个国王左右无其他国王），这只需要将表示这一行状态的数x&(x<<1)==0&&x&(x>>1)==0，例：
### 0100110
左移后为
### 1001100
&，得
### 0000100
不为0，便说明此数符合状态（相信有一定位运算基础的人很简单便可理解）

还要用一个数组储存每一种状态需要的国王数，即%2得1便多一种，再/2。以下为处理初值的程序段：

```cpp
for(int x=0;x<(1<<n);x++){
    if(!(x&(x>>1))&&!(x&(x<<1)))g[x]=1;
    int w=x;
    while(w){
        if(w%2)h[x]++;
        w/=2;
    }//g[x]表示是否基本符合状态，h[x]表示此状态所需的国王数
    if(g[x])f[1][x][h[x]]=1;
}
```

我用f[n][x][i]表示第n行，此行状态为x时，用了i个国王的方法数，所以自然f[1][x][h[x]]=1。

之后是枚举行，上一行的状态y和这一行的状态z。只要这两行都基本符合状态且：
### !(y&z)&&!(y&(z>>1))&&!(y&(z<<1))
便可确定这两种可以作为上下行（原理同上面判断g[x]的方法）
此时便可用:
### f[n][z][w+h[z]]+=f[n-1][y][w];

c++代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=1<<9; 
long long g[M],h[M],f[10][M][82],n,k,tot=0;
int main(){
    cin>>n>>k;
    memset(f,0,sizeof(f));
    for(int x=0;x<(1<<n);x++){
        if(!(x&(x>>1))&&!(x&(x<<1)))g[x]=1;
        int w=x;
        while(w){
            if(w%2)h[x]++;
            w/=2;
        }
        if(g[x])f[1][x][h[x]]=1;
    }
    for(int x=2;x<=n;x++){
        for(int y=0;y<(1<<n);y++){
            if(g[y]){
                for(int z=0;z<(1<<n);z++){
                    if(g[z]&&!(y&z)&&!(y&(z>>1))&&!(y&(z<<1))){
                        for(int w=0;w+h[z]<=k;w++)f[x][z][w+h[z]]+=f[x-1][y][w];//w枚举总共放的国王的个数
                    }
                }
            }
        }
    }
    for(int y=0;y<(1<<n);y++)tot+=f[n][y][k];
    cout<<tot;
    return 0;
}
```


---

## 作者：The_Star (赞：12)

## 不会状压DP的来康康ヾ(๑╹◡╹)ﾉ"

DP大家都懂，那么什么是状压呢？


 - $\color{red}\text{ 所谓状压，就是将状态压缩成一个数字，以此数字的二进制（01串）表示此状态
}$

- 我们把以1来表示有国王或可被国王攻击的位置，以0来表示没有国王的位置

例如

|  i=1|00001  | 最右边有一个国王|
| -----------: | -----------: | -----------: |
| i=2 | 00010 |右二有一个国王|
| i=3 |00011  |右一右二有国王
|i=4  |00100  |中间有国王
| i=5 |00101  |中间右一有国王

↑这就是n=5时i的代表含义


![](https://cdn.luogu.com.cn/upload/image_hosting/pf6rht8q.png)
#### ————摘自OI Wiki

看不懂很正常 ~~因为我也看不懂~~

那么咱们以实际代码为例，实际说一下

----
```
//定义数组
int g[(1 << 10) + 100];//在i的状态下状态是否合法0代表不合法，1代表合法
int h[(1 << 10) + 100];//将i的状态下所有国王可攻击范围 
int cnt[(1 << 10) + 100];//cnt是某状态的1的个数（即国王的数量）
//主程序下的初始化
cin>>n>>k;
	int tt=1<<n;//在列数为n时的状态总数
	for(int i=0;i<tt;i++)
	{
		g[i]=((i&(i<<1))==0) && ((i&(i>>1))==0);
		h[i]=i|(i<<1)|(i>>1);
		cnt[i]=cnt[i>>1]+(i&1);
	}
```
 ## g[i]判断合法的解释：
- ###  (i&(i<<1))==0时

![](https://cdn.luogu.com.cn/upload/image_hosting/ixtl9s6b.png)
- ### (i&(i<<1))!=0时

![](https://cdn.luogu.com.cn/upload/image_hosting/p97u37gm.png)

(i&(i>>1))也是一样的道理

- ## 所以将向右攻击（右移）逻辑与上向左攻击（左移）为0时，i合法

### h[i]也是一样的道理
![](https://cdn.luogu.com.cn/upload/image_hosting/g84lwtai.png)

### cnt[i]=cnt[i>>1]+(i&1);
↑这个是我们常见的判断i的二进制位下1的个数↑

上面的内容相信大家都懂了（什么？不懂？自己看着图或者自己出一个状态玩一玩就好理解了  ~~或者和别人玩几局国际象棋？~~）

-----
————————————下面是主要程序————————————

```c
f[0][0][0]=1;//初始值千万不能忘 
	for(int i=0;i<n;i++)//枚举列数 
		for(int j=0;j<tt;j++)//枚举所有状态 
			for(int l=0;l<=k;l++)// 枚举每一个国王 
				if(f[i][j][l])
					for(int p=0;p<tt;p++)//枚举他下一行的所有状态 
						if(g[p]&&((h[p]&j)==0))//如果下一行的状态是可行的并且攻击范围与当前这种状态不相交
							f[i+1][p][l+cnt[p]]+=f[i][j][l];
                            				//优美的代码
```

这里我想着重解释一下最后一层for和if

- ###  为什么我们在讨论这一行时还要用for看下一行的状态？

我们还是用举个栗子来说明

这一行→01010

下一行→01101

虽然这两行都是合法的，但是在左二列上两个国王可以互相攻击（上下攻击）

- 所以要用（h[p]&j）来判断是否可行


——————————AC代码时间——————————
```c
#include<bits/stdc++.h> 
using namespace std;
long long ans,n,k; 
int g[(1 << 10) + 100];//在i的状态下状态是否合法 
int h[(1 << 10) + 100];//将i的状态下所有国王可攻击范围 
int cnt[(1 << 10) + 100];//cnt是某状态的1的个数（即国王的数量）
long long f[121][(1 << 10) + 100][121];
int main()
{
	cin>>n>>k;
	int tt=1<<n;
	for(int i=0;i<tt;i++)//i的二进制位表示一列上的国王摆放状态 
	{
		g[i]=((i&(i<<1))==0) && ((i&(i>>1))==0);
		h[i]=i|(i<<1)|(i>>1);
		cnt[i]=cnt[i>>1]+(i&1);
	}
	f[0][0][0]=1;//初始值千万不能忘 
	for(int i=0;i<n;i++)//枚举列数 
		for(int j=0;j<tt;j++)//枚举所有状态 
			for(int l=0;l<=k;l++)// 每一个国王 
				if(f[i][j][l])
					for(int p=0;p<tt;p++)//枚举他下一行的所有状态 
						if(g[p]&&((h[p]&j)==0))//如果下一行的状态是可行的并且攻击范围与当前这种状态不相交
							f[i+1][p][l+cnt[p]]+=f[i][j][l];
	for(int i=0;i<tt;i++)
		ans+=f[n][i][k];
	cout<<ans<<endl;
}
```




------------
## 发个题解不容易，各位留个赞再走吧٩(๑>◡<๑)۶ 



---

## 作者：jins3599 (赞：6)

做的第一道状压$dp$

基本上是跟着第一篇题解写的，记个笔记加深一下理解。

我们首先要设计状态，考虑到每行国王的摆放方式可以用一个二进制数唯一表示，我们不妨这样设计方程：

`f[i][j][k]`选择前$i$行，状态为$j$，共选择$k$个国王的方案总数。

显然，对于不相冲突的两个状态$h,g$，我们可以这样转移：

`f[i][h][k] += {f[i - 1][g][k - num[h]]}.`

其中`num[h]`对应的是状态$h$下放了多少国王，这个是可以预处理的。

枚举状态是比较简单的，`for(int i = 0 ; i <= (1 << n) ; ++ i)`即可。

$num[i]$如何处理呢？暴力枚举即可。

其实我们有更优化的预处理方式，写一个$O(2^n)$的搜索即可。

即`dfs(int now , int tot ,int sum)`代表上个状态$now$，当前在哪个点，当前共选了多少国王。

为什么要把上一个状态加进来？因为我们能否选择这意味取决于上一个状态的国王放置位置。

也就是说，我们如果当前这一位放国王的话，下一位国王只能考虑到当前位置的下下位，如果这一位不放国王，我们下一次依旧可以选择这个点。

所以说递归的顺序就明白了：
```
dfs(now , tot + 1, sum);//这一位不选
dfs(now | (1 << tot) , tot + 2 , sum + 1);这一位选
```

现在我们还遗留的最后一个问题，如何判断相邻两行的国王是否冲突？

我们考虑两行不冲突的国王：
```
101011
010000
```

显然，每一对对应的位置只能是`01\00\01`的情况。

这三种情况进行位运算结果相同的是哪种位运算？显然是$\&$

也就是说，如果两行国王不冲突，他们的按位与的值位$0.$

同理，左和右也是如此，把上一行的左移和下一行的左移进行判断即可。

注意，千万不能右移，因为你会把最右的那个国王移掉，会导致答案的错误。

综上，我们的代码大体内容如下:

- 预处理每个状态$i$和对应的`num[i]`

- 初始化第一行的`f[1][i][num[i]] = 1`

- 进行状压dp转移

- 输出最后一行所有状态答案的和

- 记得开`long long`

$Code:$

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int N = 2000;
int n , k;
ll num[N] , king[N] , cnt;
// num[] 当前状态的国王个数
// king[] 状态对应的十进制数 
ll f[10][N][100];
// f[i][j][k] 代表: 选完了前i行,状态为j,选了k个国王的方案总数 

void dfs(int sum , ll now , int tot) {// 共选了多少国王，上一个状态，当前在选哪一个位置 
	if(tot >= n) {
		king[++ cnt] = now;
		num[cnt] = sum; return;
	}
	dfs(sum , now , tot + 1);
	dfs(sum + 1 , now | (1 << tot) , tot + 2);
}

int main () {
	ios :: sync_with_stdio(0);
	cin >> n >> k;
	dfs(0 , 0 ,0);
	for(int i = 1 ; i <= cnt; ++ i) f[1][i][num[i]] = 1; 
	for(int i = 2 ; i <= n ; ++ i) {
		for(int j = 1 ; j <= cnt ; ++ j) {
			for(int p = 1 ; p <= cnt ; ++ p) {
				if(king[j] & king[p]) continue;
				if(king[j] & (king[p] << 1)) continue;
				if((king[j] << 1) & (king[p])) continue;
				for(int q = num[j] ; q <= k ; q ++)
					f[i][j][q] += f[i - 1][p][q - num[j]];
			}
		}
	}
	ll ans = 0;
	for(int i = 1 ; i <= cnt ; ++ i) ans += f[n][i][k];
	cout << ans;
	return 0;
}
```

---

## 作者：Ykimna (赞：6)


### 需要强调一点：状压dp也是 **dp**,需要普通动态规划基础，如没有普通动态规划基础还是先去巩固基础更为重要。

我也不知道我是否能讲清楚，如果哪里有疑问可以评论，或私信我（我在退役之前都能回答你）


------------

### 前置知识：普通动态规划，位运算。

这道题题意非常简单就不再赘述，直接来讲讲数据处理方法。
如果一般的动态规划去想这道题，你会发现它的状态很难去表示和转移（ ~~当然你也可以去开个10维数组~~ ），这就需要引入一种方法去表示它的状态，我们可以用一个数来表示它的状态，这个数每位只有两个数0或1，对于这道题来说1为国王，0为空格。

比如：10101 表示的就是：

![1](https://cdn.luogu.com.cn/upload/image_hosting/oudn4u12.png) 

很显然如果棋盘有9格那么这个数会到1e8数组会炸，所以我们就需要用个方法来减维，那就是 **状压** 。因为这个数每位只0或1，那么很显然我们可以用二进制来表达这个状态，再把这个二进制转化为十进制来存储，1e8就就会退化为 $\log_21e8$ 最大也就为 $2^9-1(511)$ 。这样就可以用数组存下了。  

接下来就来讲一下思路：我们先来处理每一行棋盘的所有合法状态。根据题意每个国王的左右不能有国王也就是只能插空站，在判断国王是否相邻（状态是否合法）有一种简单的方法 **&** 运算。这里举两个例子。  

1. 10101

我先把这个数左移一位再与这个数进行 **&** 运算

![2](https://cdn.luogu.com.cn/upload/image_hosting/fo964c1m.png)

2. 11010

![3](https://cdn.luogu.com.cn/upload/image_hosting/fifzt8bs.png)

我们发现合法序列的在计算后的值为 $0$ ，而不合法的序列计算后的值不为 $0$ 。因此我们就可一从0枚举到 $2^n-1$ 把所有的合法序列存在 $sta[N]$ 数组里面。同时我们可以用 $king[N]$ 数组把每一个合法状态有多少个国王存下来。

代码如下：

```cpp
int cnt=0;
for(int i=0;i<=(1<<n)-1;i++)
{
	if(i&(i<<1)) continue;
	sta[++cnt]=i;int gw=i; //存合法状态
	while(gw>0)//计算国王数量
	{
		if(gw%2==1) king[cnt]++;
		gw>>=1;
	}
}
```

之后的大致思路就是比较所有 $X$ 行和 $Y$ 行，其中 $X$ 为 $Y$ 的上一行，也就是说 $X=Y-1$ ，枚举所有 $X$ 行和 $Y$ 行的所有合法状态再计算出这 **两排** 的合法状态，因为想要整个棋盘合法，就要每一行棋盘都要与其上下两行棋盘合法
也就是国王的上方，左上，右上和下方，左下，右下都不能为国王。比较方法如下：

```cpp
	if(sta[j]&sta[k]) continue;//j枚举的是Y行的合法状态，k为X行的合法状态
	if((sta[j]<<1)&sta[k]) continue;
	if(sta[j]&(sta[k]<<1)) continue;
```

判断合法的状态都讲了，就可开始$dp$了，我们定义一个$dp[i][j][k]$数组，前i行，状态为j，使用了k个国王时的总方案数。再前文枚举$X$和$Y$合法后，我们就再枚举国王数就可以了。代码如下

```cpp
for(int c=0;c<=ki;c++)
{
	if(king[j]+c>ki) break;
	dp[i][j][king[j]+c]+=dp[i-1][k][c];
}
```

### 细节：处理好位运算的优先级，还有就是 ~~十年OI一场空，不开long long见祖宗~~

下面贴完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=(1<<10)+20;
const int M=17;
int n,ki,cnt,king[N];
long long ans,sta[N],dp[M][N][M*M];
int main()
{
    cin>>n>>ki;
    for(int i=0;i<=(1<<n)-1;i++)
    {
       if(i&(i<<1)) continue;
       sta[++cnt]=i;int gw=i; //存合法状态
       while(gw>0)//计算国王数量
       {
          if(gw%2==1) king[cnt]++;
          gw>>=1;
       }
    }
    for(int i=1;i<=cnt;i++)//初始化第一排，因为我们枚举的是X与X-1行
        if(king[i]<=ki) //一行的国王数不可能超过国王的总数量
            dp[1][i][king[i]]=1;
    for(int i=2;i<=n;i++)//枚举每行
    {
        for(int j=1;j<=cnt;j++)//X行的合法状态
        {
            for(int k=1;k<=cnt;k++)//X-1（Y）行的合法状态
            {
                if(sta[j]&sta[k]) continue;
                if((sta[j]<<1)&sta[k]) continue;
                if(sta[j]&(sta[k]<<1)) continue;
                for(int c=0;c<=ki;c++)//国王数
                {
                    if(king[j]+c>ki) break;
                    dp[i][j][king[j]+c]+=dp[i-1][k][c];
                }
            }
        }
    }
    for(int i=1;i<=cnt;i++)//因为记录的是前i行,所以加上在前n行的所有合法状态
        ans+=dp[n][i][ki];
    cout<<ans<<endl;
    return 0;
}

```

~~码字不易，反正不要钱多少赞一个~~ 

---

## 作者：Notshgiook (赞：6)

# About P1896【[SCOI2005]互不侵犯】
这题真好啊！互相尊重主权和领土完整，互不侵犯，互不干涉内政，平等互利，和平共处——和平共处五项原则！！！


这题是状态压缩动态规划吧！！！

据(bol)传言，数据不过18，不是暴搜就是状压！！

------------
### 为什么暴搜不行呢？？？
首先看上去时间复杂度很玄学，很看脸，如果碰上 **某些大常数** 算法，极易死亡！！

再从空间复杂度上来看，每个点的情况有两种，如果我们记录每个点的状态，空间复杂度是大概2^n，很容易 ~~死亡~~ ！

------------
### 关于这个题的状态压缩！！
假设n=3

我们先模拟一下当前的棋盘的第一行

一开始是没有任何棋子： 000 ；

那么我们用1来表示这个位置有国王

我们先不考虑国王之间会不会互相侵犯，那么把格子放国王都有那些情况呢？

①000 、②001、 ③010、 ④011、 ⑤100、 ⑥101、 ⑦110、 ⑧111

#### 那么我们光看这一行的话，有那些情况会符合呢？

emm，如果单看这一行的话那么对于每个1来说，ta的左边和右边的都必须是0；

那么满足情况的有:

①000，②001，③010，⑤100，⑥101 这些情况

看n仅仅是3，每行可能满足就有5种了（通过打表大法n=9，每行可能的情况有89种（可能会错））那么暴力乱搞貌似………………

所以不如换个状压的想法！！

你看着着000,001,010的，他怎么这么像二进制呢！！！

对啊，二进制好啊！！！

对于每种发棋子的情况比如 010 就可以变成一个十进制数字2来储存这个状态！！

#### 这样不就极大的节省空间吗？？

#### 那么我们怎么去找符合的情况呢？

众所周知，有一种二进制运算叫做 “（&）与” 运算，即1&1=1, 0&1=0, 0&0=1

同时呢“000”&“101”=“000”， “101”&“001”=“001”（即按位与（&））

在仅看每一行种，如果这个情况n合法那么一定存在 （n&（n<<1）==0）&&n&（n&（n>>1）==0）存在，那么判断一下就可以找出每一行的所有可能情况！

#### 同时我们可以记录一下每种情况用多少国王

即每种情况对应下的二进制代码有多少位是1！

有两种方法：

第一种：暴力10进制转换二进制，除2取余法！
```cpp
	int p=0; 
   	while(w)
	{
    		if(w%2) p++;
        	w/=2;
         }
```

第二种：用bitset库的函数做


------------

**简单介绍一下bitset；**

bitset存储二进制数位。

bitset就像一个bool类型的数组一样，但是有空间优化。

bitset中的每个元素都能单独被访问，例如对于一个叫做a的bitset，表达式a[3]访问了它的第4个元素，就像数组一样。

(但是输出单独访问结果不能用printf，和bitset有关的输出都用cout)

另外bitset的大小在编译时就需要确定，也就是说bitset<>的尖括号中写的是大小。

比如 bitset <10> a(5)  ==> 输出a得 101

bitset的运算就像一个普通的整数一样，可以进行与(&)、或(|)、异或(^)、左移(<<)、右移(>>)操作。

bitset有一些函数比如：

![](https://cdn.luogu.com.cn/upload/pic/61910.png)

那么我们就可以用a.count()算出一的个数！


------------
### 那么把所有东西都预处理完了就准备dp吧！！
我们用dp[i][j][k]表示第i行，状态为j，已用国王数为k的方案数！！

乍看一眼，好像并不能怎么状态转移

那我们可以考虑一下dp[i][j][k]可以转移到哪？

我们假设状态是从第一行向下转移，那么第i+1行的状态只会影响下一行的状态（因为第i行是从i-1行转移过来的，那么在假设情况下，i不会影响i-1行）；

我们设i行的情况为j,用了k个国王，i+1行的情况为 p，这种情况要用国王w个；

在i行为j的情况下p是否合法，只取决与 对于每一个国王位置（i+1，pos）而言，（i，pos-1），（i，pos），（i，pos+1）均不能有国王；

那么可以用之前那个左右移的方法去判断p情况是否合法

即 j&p=0，j&（p<<1）=0,j&(p>>1)=0;

这样看来 dp[i+1][p][w+k]+=dp[i][j][k]

那么我们把i+1换一下：就可以得到

dp[i][p][w+k]+=dp[i][j][k]

#### 在我们预处理每行可能的情况时，把dp[1][n][k]更新为1
n为该种状态，k为所用国王！

## **于是这个题就顺利的结束了！！**
cpp代码如下：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <bitset>
using namespace std;
int n,m,ans,tot=0;
bool vis[1<<9];
int g[1<<9],dp[10][1<<9][82];
int main()
{
	scanf("%d%d",&n,&m);
	for(register int x=0;x<(1<<n);x++)
	{
		if(!(x&(x<<1))&&!(x&(x>>1))) vis[x]=true;
		bitset <9> a(x);
		g[x]=a.count();
		if(vis[x]) dp[1][x][g[x]]=1;
	}
	for(register int i=2;i<=n;i++)
	{
		for(int j=0;j<(1<<n);j++)
		{
			if(vis[j])
			{
				for(register int k=0;k<(1<<9);k++)
				{
					if(vis[k] && !(j&(k<<1)) && !(j&(k>>1)) && !(j&k))
					{
						for(register int w=0;w+g[k]<=m;w++) dp[i][k][w+g[k]]+=dp[i-1][j][w];
					}
				}
			}
		}
	}
	for(register int i=0;i<(1<<n);i++) ans+=dp[n][i][m];
	printf("%d",ans);
	return 0;
}
```


---

## 作者：SuperJvRuo (赞：6)

这道题的状压思路，dalao们已经讲得非常清楚了

蒟蒻来补充一种优雅的操作：
统计32位无符号整数中1的数目
```
inline int popcount(unsigned int i)
{
    i=i-((i>>1)&0x55555555);
    i=(i&0x33333333)+((i>>2)&0x33333333);
    i=(i+(i>>4))&0x0f0f0f0f;
    i=i+(i>>8);
    i=i+(i>>16);
    return i&0x3f;
}
```
嗯看起来很神是吧

其实只是利用这样一个公式：
$$popcount(x)=x-\lfloor x/2\rfloor-\lfloor x/4\rfloor......\lfloor x/32 \rfloor$$
所以，我们可以这么搞：
```
#include<cstdio>

long long f[11][520][50],state[520],cnt,pop[520];
bool trans[520][520];

inline int popcount(unsigned int i)
{
	//用公式前两项并行计算每组宽度为2的位段中值为1的位元个数
	i = i - ((i >> 1) & 0x55555555);
	//现在，32位二进制每2个相邻位位组保存着这2位中值为1的位元数

	i = (i & 0x33333333) + ((i >> 2) & 0x33333333);

	//并项，8位二进制最多只有8个1，4位二进制可以表示
	//在这次每组高4位和低4位的相加中，不会向高4位进位
	i = (i + (i >> 4)) & 0x0f0f0f0f;
	//这时32位二进制每8位位组的低4位保存着这8位中值为1的位元数

	//为什么并项后的&运算也省略了？
	//这是因为每组的高8位是什么，即这32位二进制的32~24位/16~8位是什么，已经不重要了
	//后续都不会用到它的结果
	i = i + (i >> 8);
	i = i + (i >> 16);

	//最后结果小于32，肯定在低6位上
	//其余的26位里面的值是无意义的
	return i & 0x3f;
}

int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	int lim=(1<<n);
	for(int i=0;i<lim;++i)
	{
		
		if(((i<<1)&i)==0)
		{
			state[++cnt]=i;
			f[1][cnt][pop[cnt]=popcount(i)]=1;
		}
	}
	
	for(register int i=1;i<=cnt;++i)
	{
		for(register int j=i;j<=cnt;++j)
		{
			if ((!(state[i]&state[j]))&&(!(state[i]&(state[j]<<1)))
				&&(!(state[i]&(state[j]>>1))))
			{
				trans[i][j]=trans[j][i]=1;
			}
		}
	}
	
	for (register int i=2;i<=n;++i)
	{
		for (register int j=1;j<=cnt;++j)
		{
			for (register int m=1;m<=cnt;++m)
			{
				if (trans[m][j])
				{
					for (register int l=0;l<=k;++l)
					{
						f[i][j][l+pop[j]]+=f[i-1][m][l];
					}
				}
			}
		}
	}
	
	long long ans=0;
	for(int i=1;i<=cnt;++i)
	{
		ans+=f[n][i][k];
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：xiejinhao (赞：4)

# P1896 [$SCOI \ 2005$]互不侵犯 

**原题链接**：[P1896 [SCOI2005]互不侵犯](https://www.luogu.org/problem/P1896)

这一题我们看一眼数据范围，$N≤9$，那么我们想到的算法最基础的就两种：

1. **搜索|记忆化搜索**

1. **$DP$|状压$DP$**

对于搜索，如果我们不记忆化，那么一般情况下肯定是会$TLE$的（除非你的剪枝足够优秀），说是记忆化搜索，其实也就很像树形$DP$了。

像这一类题我们可以考虑状压$DP$，因为其实现简单，~~方程暴力~~。



------------


- ### **什么是状态压缩？**

状态压缩就是把我们原来复杂的状态转换为一个简单的量（反正我是这么理解的……）。

对于状态压缩，比如这一题，我们用$1$表示一行中由国王的位置，$0$表示没有国王的位置。这样的思想在搜索的时候大家应该都会了。基于这样的思想，我们考虑把一行的$0,1$串压缩成我们熟悉的量。这让我们想到了**进制**。

**因此我们可以用一个数字来表示一行的状态**。比如$1010$可以表示：第$1,3$位有国外，$2,4$位没有国王（从左向右数），当然你反过来数也可以。

然后我们只要确定表示当前行状态的数字是否合法即可，其转移时需要考虑上一行的状态，再确定当前状态与上一行状态放在一起是否合法。

- ### **状压$DP$怎么实现？**

我们已经了解了状压的思想，现在只需要一个转移方程。

我们现在来解决一个更简单的问题：

- 有一块$N*M(1≤N,M≤8)$的方格型土地，我们要在这块地上种玉米，但是我们种玉米的要求是一颗玉米上下左右都不能有其他玉米，求方案数。

乍一看，这时这一题的简化版。我们可以定义一个数$X$表示当前状态，我们用$1$表示这一行的某个位置有了玉米，那么$X$在二进制表示下不能有相邻的两个$1$。这个应该很好理解吧。

那么我们怎么进行这样的处理？

**我们只需要位运算！**

对于一个$X$合法，当且仅当：$X \ and \ (X<<1)=0$

这个东西是我们可以预处理出来的。当然$X \ and \ (X >> 1) = 0$会更好，因为其更不容易爆成负数。

那么我们就可以开始解决两行间的关系：

设上一行为$S$，这一行为$X$，且$S,X$都合法，那么我们只需保证$S \ and \ X=0$即可，即保证$S,X$在同一列上只有一个位置有玉米，暴力枚举$j,k∈[0,2^n-1]$就行了。

定义状态$f[i][j]$表示第$i$行状态为$j$时的方案数，$k$为上一行的状态那么转移方程就是$f[i][j] += f[i-1][k],(j \ and \ j >>1=0,\ k \ and \ k >> 1 = 0, \ j \ and \ k = 0)$

我们枚举$k$即可，特别的$f[0][0]=1$，最终答案为$ans=\sum _{j}^{j \ and \ j >> 1 = 0}f[n][j]$。

这个应该可以理解吧。



------------

**本题思路**
------------
类似于上面那题，这一题我们也可以进行预处理，但如果像上面从$0 \ \ \ -\ \ \ 2^n-1$枚举$j,k$，可能$TLE(2^{(n+1)}*n^3)$.但是由于我们进行了预处理，枚举合法的方案即可。

本题我们要保证：

1. 对于一个合法状态：$X \ and \ (X>>1) = 0$

1. 对于两行之间：$X \ and \ S = 0, X \ and \ (S<<1)=0, X \ and \ (S>>1)=0$

至于为什么对于两行之间：$X \ and \ S = 0, X \ and \ (S<<1)=0, X \ and \ (S>>1)=0$，因为我们对于这一行每一个$1$，其上、左上、右上都没有$1$（左右的情况处理过了）。

但是我们还漏了一点：我们用$a$表示$X$状态下$1$的个数，$b$表示$S$的，那么$0≤a,b≤k$且$0≤a+b≤k$。

对于每一个状态$1$的个数，在预处理时处理好即可。

但是我们注意到，这一次还要记录放$k$个国王，所以状态又多了一维。

定义状态：$f[i][j][k]$表示第$i$行，状态为$j$，放了$k$个国王时的方案数。

转移方程：$f[i][j][k]+=f[i-1][s][k-j.num]$

最后答案为$\sum_jf[n][j][k]$。

**我们发现，最终我们取到所有合法的$f[n][j][k]$，那么对于上面的$a+b≤k$是不必要的了。**

**记得开$long \ long$**(~~没让你写高精不错了)~~

$Code:$

```cpp
    #include<bits/stdc++.h>
    using namespace std;

    const int N = 1 << 9;

    struct rec {
        long long val;
        int num;
    }a[N + 1];

    int check(long long x, int k) {
        if((x & (x << 1) )!= 0) return 0;
        int cnt = 0;
        #define lowbit(x) (x&-x)
        for(; x; x -= lowbit(x), cnt++);
        return cnt <= k ? cnt : 0;
    }

    long long f[10][N][9 * 9 + 1];

    int main() {
        int n, k;
        scanf("%d %d", &n, &k);
        int cnt = 1;
        //a[1].num = 0, a[1].val = 0;
        for(int i = 1; i < (1 << n); i++) {
            int p = check(i, k);
            if(p) {
                a[++cnt].val = (long long) i;
                a[cnt].num = p;
            }	
        }

        for(int i = 1; i <= cnt; i++) 
            f[1][a[i].val][a[i].num] = 1;

        for(int i = 2; i <= n; i++) 
            for(int j = 1; j <= cnt; j++) 
                for(int s = 1; s <= cnt; s++) 
                    if((a[j].val & a[s].val) == 0 && (a[j].val & (a[s].val << 1)) == 0 && (a[j].val & (a[s].val >> 1)) == 0) 
                        for(int p = a[j].num; p <= k; p++) 
                            f[i][a[j].val][p] += f[i - 1][a[s].val][p - a[j].num];

        long long ans = 0;
        for(int i = 1; i <= cnt; i++)
            ans += f[n][a[i].val][k];
        printf("%lld", ans);
        return 0;
    }
```
**其实我们发现还可以优化，因为出现的方案不多，我们在第二维放上方案的编号即可，可以省很多空间。**

$Code:$

```cpp
    #include<bits/stdc++.h>
    using namespace std;

    const int N = 1 << 9;

    struct rec {
        long long val;
        int num;
    }a[N + 1];

    int check(long long x, int k) {
        if((x & (x << 1) )!= 0) return 0;
        int cnt = 0;
        #define lowbit(x) (x&-x)
        for(; x; x -= lowbit(x), cnt++);
        return cnt <= k ? cnt : 0;
    }

    long long f[10][200][9 * 9 + 1];

    int main() {
        int n, k;
        scanf("%d %d", &n, &k);
        int cnt = 1;
        //a[1].num = 0, a[1].val = 0;
        for(int i = 1; i < (1 << n); i++) {
            int p = check(i, k);
            if(p) {
                a[++cnt].val = (long long) i;
                a[cnt].num = p;
            }	
        }

        for(int i = 1; i <= cnt; i++) 
            f[1][i][a[i].num] = 1;

        for(int i = 2; i <= n; i++) 
            for(int j = 1; j <= cnt; j++) 
                for(int s = 1; s <= cnt; s++) 
                    if((a[j].val & a[s].val) == 0 && (a[j].val & (a[s].val << 1)) == 0 && (a[j].val & (a[s].val >> 1)) == 0) 
                        for(int p = a[j].num; p <= k; p++) 
                            f[i][j][p] += f[i - 1][s][p - a[j].num];

        long long ans = 0;
        for(int i = 1; i <= cnt; i++)
            ans += f[n][i][k];
        printf("%lld", ans);
        return 0;
    }
```
预处理用位运算即可，没有必要像某一篇题解那样$DFS$枚举。（虽然复杂度是一样的）



$End$
------------


---

## 作者：CloudStroll (赞：4)

对状压学习的入门题。

定义状态$dp[line][i][k]$表示第line行，第i个状态，一共放了K个棋子的总方案数。

当有状态$dp[line-1][j][k-\_\_builtin\_popcount(i)]$符合转移规则时。显然有

$$dp[line][i][k]=\sum\limits^{(1<<N)}_{j=0}dp[line-1][j][k\_\_builtin\_popcount(i)]$$

因为后面每一行的转移，事实上是被前面的限制住了，所以不会对前面已经做好的状态产生贡献。

规则是什么？

* **（1）** 是当前一行不能有国王**相邻**。

* **（2）** 当前一行的国王不能在**上一行**的**左下，右下，正下方**。

对于状态$i$,当把所有国王左移或右移没有国王重叠，那么就满足了规则1。

代码操作

``` cpp

if((((i<<1)&i)!=0)||(((i>>1)&i)!=0))
{
	continue;
}

```

对于状态$i,j$，$i$是$j$前一行。当$i$与$j$没有国王重叠，$i$左移或右移后没有国王和$j$重叠，便满足了规则2。


然后按照状态枚举DP即可。

再讲一下   **__builtin_popcount()**   .

一个整形参。

返回值也为整形。

返回的内容是参数转换为二进制下1的个数。就可以用来表示当前状态有多少个国王。

代码操作

``` cpp

int Work(int x)
{
	return __builtin_popcount(x);
}

```

方便解题。

AC代码

``` cpp

#include <bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=12;
int dp[MAXN][1<<MAXN][MAXN*MAXN];
int Work(int x)
{
	return __builtin_popcount(x);
}

signed main()
{
	int N,K;
	scanf("%lld%lld",&N,&K);
	for(int i=0;i<(1<<N);i++)
	{
		if((((i<<1)&i)!=0)||(((i>>1)&i)!=0))
		{
			continue;
		}
		int now=Work(i);
		dp[1][i][now]=1;
	}
	for(int line=2;line<=N;line++)
	{
		for(int i=0;i<(1<<N);i++)
		{
			if((((i<<1)&i)!=0)||(((i>>1)&i)!=0))
			{
				continue;
			}
			for(int k=0;k<=K;k++)
			{
				if(k<Work(i))
				{
					continue;
				}
				for(int j=0;j<(1<<N);j++)
				{
					if((((j<<1)&j)!=0)||(((j>>1)&j)!=0))
					{
						continue;
					}
					if(((i&j)!=0)||(((j<<1)&i)!=0)||(((j>>1)&i)!=0))
					{
						continue;
					}
					int now=Work(i);
					dp[line][i][k]+=dp[line-1][j][k-now];
				}
			}
		}
	}
	int ans=0;
	for(int i=0;i<(1<<N);i++)
	{
		if((((i<<1)&i)!=0)||(((i>>1)&i)!=0))
		{
			continue;
		}
		ans+=dp[N][i][K];
	}
	printf("%lld",ans);
}

```

记得开longlong。

---

## 作者：CreeperLordVader (赞：4)

## 前方大量位运算警告！！！

### 对于本题而言，我为了加快代码速度，加入了一定量的剪枝，并且使用了一些函数来使得代码简洁清晰，总体来说应该更好懂

### 首先不难得到状态转移方程如下

# d[i][s][p]+=d[i-1][possible][j-p];

i是当前行数，s是当前行的集合，p是该集合的国王数目

#### 问题就在于
#### 1.possible怎么求
#### 2.怎么判断合法状态

1.LAST函数求出了对于当前集合，上一行的禁区VIS变量（也就是说，如果当前行状态合法，上一行不能放置国王的区域的集合），这可以用位运算解决

DFS函数在禁区以外枚举可能的子集，为了防止大量使用TEST函数，我用了一个预处理，如果当前枚举的集合不合法（见2），直接返回，如果合法，把当前集合推进向量V中

2.TEST函数检验当前行的状态在不考虑前后的前提下是否合法，也就是说两个国王不能挨在一起，该函数统计集合中国王的数目，如果不合法返回-1，合法则返回国王数量

见代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,vis;
long long ans;
bool jud[(1<<9)+1];
long long d[10][(1<<9)+1][82];
bool b[(1<<9)+1];
vector<int>v;//上一行的集合
void read(int& x)
{
    char c=getchar();
    x=0;
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9')
    {
        x=x*10+c-'0';
        c=getchar();
    }
}
int test(int s)
{
    int tot=0,op=0;
    while(s)
    {
        if((s&1))
        {
            tot++;
            if(!op)op=1;
            else return -1;
        }
        else op=0;
        s>>=1;
    }
    return tot;
}
void last(int s)//求出禁区集合
{
    for(int i=0;i<n;i++)
    {
        if((s&(1<<i)))
        {
            vis|=(1<<i);//如果该格有国王，那么上一行的前中后都不能有国王
            if(i)vis|=(1<<(i-1));
            if(i<n-1)vis|=(1<<(i+1));
        }
    }
}
void dfs(int t,int now)
{
    if(!b[now])
    {
        if(jud[now])
		{
			v.push_back(now);
			b[now]=1;
		}
        else return ;//不合法直接返回
    }
	if(t==n)return ;
    if(!(vis&(1<<t)))
    {
        if(jud[now^(1<<t)])dfs(t+1,now^(1<<t));
    }
    dfs(t+1,now);
}
int main()
{
    read(n);
    read(k);
    d[0][0][0]=1;
    for(int s=0;s<=(1<<n)-1;s++)
    {
    	int p=test(s);
        if(p<0)continue;
        d[1][s][p]=1;
    }
    for(int s=0;s<=(1<<n)-1;s++)
    {
    	if(test(s)>=0)jud[s]=1;
	}
    for(int i=2;i<=n;i++)
    {
        for(int j=0;j<=k;j++)
        {
            for(int s=0;s<=(1<<n)-1;s++)
            {
                int p=test(s);
                if(p<0||p>j)continue;
                vis=0;last(s);v.clear();
                memset(b,0,sizeof(b));//DFS之前的初始化
                dfs(0,0);
                for(int l=0;l<v.size();l++)
                {
                	if(jud[s])d[i][s][j]+=d[i-1][v[l]][j-p];
				}
            }
        }   
    }
    for(int s=0;s<=(1<<n)-1;s++)
    {
    	ans+=d[n][s][k];
    }
    printf("%lld\n",ans);
}
```

---

## 作者：「QQ红包」 (赞：4)


//缩进被吞>>

题解：by redbag


DP 思路和plazum的一样，这里就不再发了，况且我描述得没那么清楚。


1代表有国王，0代表没国王


```cpp
- #include<set>
- #include<map>
- #include<list>
- #include<queue>
- #include<stack>
- #include<string>
- #include<math.h>
- #include<time.h>
- #include<vector>
- #include<bitset>
- #include<memory>
- #include<utility>
- #include<stdio.h>
- #include<sstream>
- #include<iostream>
- #include<stdlib.h>
- #include<string.h>
- #include<algorithm>
- #define LL unsigned long long
- using namespace std;
- int n,k,i,j,w,m;//n*n的棋盘k个国王
- int t[1010];
- int f[20][522][110];//f[i][j][k]表示i行j状态放置k个国王的方案数
- int check(int x,int y)//x在上，y在下 ,1为满足条件，0为不满足条件
- {
- if ((x&y)!=0) return 0;//如果x和y中有上下都是1情况，返回0；
- if ((x&(x<<1))>0) return 0;//如果x转成二进制后有相邻的1返回0；
- if ((y&(y<<1))>0) return 0; //如果y转成二进制后有相邻的1返回0；
- if ((y&(x<<1))>0) return 0;//如果x与y的左下方有冲突，返回0；
- if ((x&(y<<1))>0) return 0;//如果x与y的右下方有冲突，返回0；
- return 1;//否则就返回1
- }
- int main()
- {
- cin>>n>>k;
- m=(1<<n)-1;//2^k-1
- for (i=1;i<=m;i++)//求t数组
- {
- t[i]=t[i>>1]+(i&1);//将i转成2进制后1的个数，为何要用位运算：省时间！
- }
- f[0][0][0]=1;//初始值
- for (i=1;i<=n;i++)//枚举行
- for (j=0;j<=m;j++)//枚举本行状态
- for (w=0;w<=m;w++)//枚举上一行状态
- if (check(w,j)==1)//如果这种放置方法合法
- {
- for (int kkk=t[j]+t[w];kkk<=k;kkk++)//t[j]+t[w]为这两行的国王数，k为一共放置的国王数
- f[i][j][kkk]=f[i][j][kkk]+f[i-1][w][kkk-t[j]/*减去本行国王数之后剩下的*/];//加进去
- }
- int sum=0;
- for (i=0;i<=m;i++)
- sum+=f[n][i][k];//统计
- cout<<sum;//输出
- return 0;
- }
防止复制代码/huaix
```

---

## 作者：TheOldDriver (赞：3)

 # 本题解提供更加简明的实现代码，思路是基本的状压DP

我翻了翻题解，感觉大家都写的太麻烦了，还要开一些奇怪的数组

所以我发一篇更加简单明了的状压，思路见代码

ps：本代码大量使用位运算，学好位运算获得更好代码体验
```
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
long long ans,n,m,k,f[10][100][1<<9+5];
int lowbit(int x){
	int tmp=0;
	while(x) tmp++,x-=x&(-x);
	return tmp;
}
int main(){
	scanf("%lld%lld",&n,&k);
	m=(1<<n)-1;
	for(int i=0;i<=m;++i){
		if(!(i&(i<<1))&&lowbit(i)<=k) 
		f[1][lowbit(i)][i]=1;
	} 
	//处理出第一行的所有情况 
	for(int i=2;i<=n;++i)//枚举行 
	for(int j=0;j<=k;++j)//枚举上个阶段放了的国王数 
	for(int x=0;x<=m;++x){//枚举本阶段的状态 
		if(x&(x<<1)) continue;//本阶段不能互相伤害 
		for(int y=0;y<=m;++y){//枚举上一个阶段的状态 
			if(x&y||x&(y<<1)||x&(y>>1)) continue;//本状态和上一个状态不能冲突
			if(j+lowbit(x)>k) continue;//本状态新放的国王数目+上个阶段国王数小于k 
			f[i][j+lowbit(x)][x]+=f[i-1][j][y];  //本状态加上一状态数 
		}
	}
	for(int j=0;j<=m;++j) ans+=f[n][k][j];
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：四糸乃 (赞：3)

# 终于看明白状压啦！


题目描述

在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。

注：数据有加强（2018/4/25）
输入输出格式
输入格式：

只有一行，包含两个数N，K （ 1 <=N <=9, 0 <= K <= N * N）

输出格式：

所得的方案数

输入输出样例
输入样例#1： 

3 2

输出样例#1： 

16

可以搜索，没试过能骗多少分（怕打挂Orz）

求方案数的话，想dp。一维表示当前在第i行，一维表示已经用了j个国王。这样显然是描述不了一个问题的，还得记录一下当前的局面。此时发现n很小，但是对于每个点是否有国王是没办法表示的。这个时候不如用一个n位的二进制字串来表示当前的状态：1表示有国王，2表示没放，将这个字串丢入dp中的状态，三维的话就可以描述局面了QAQ。

dp[i][j][k]表示第前i行，第i行状态为j，已经使用k个国王的方案总数。

考虑到j这一维暴力得枚举(2<<n)-1次，有点变态QAQ，所以可以预处理一下。同一行中相邻的不能放国王，可以去掉这些不合法的状态。（对于一些能明显看出状态不合法或者能预处理能搞掉大部分不合法状态的还是想着预处理吧QAQ）（实在没时间就打暴力吧QAQ）

然后中间方程转移的时候注意盘一下左上右下上下合不合法就行了QAQ。最后的方案数是累加的呢QAQ

先这样吧QAQ

Code：
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
long long size[20010],king[20010],n,num,dp[20][20010][110],cnt,ans; 
void init()
{
	long long tot=(1<<n)-1;
	for(long long i=0;i<=tot;i++)
	{
		if(!(i&(i<<1)))
		{
			cnt++;
			king[cnt]=i;
			long long tmp=i;
			while(tmp)
			{
				size[cnt]+=(tmp&1);
				tmp=(tmp>>1);
			}
		}
	}
}
int main()
{
	cin>>n>>num;
	init();
	for(long long i=1;i<=cnt;i++)
	{
		if(size[i]<=num)
		 dp[1][i][size[i]]=1;
	}
	for(long long i=2;i<=n;i++)
	 for(long long j=1;j<=cnt;j++)//当前行 
	  for(long long k=1;k<=cnt;k++)//上一行 
	  {
	  	if(king[j]&king[k]) continue;
	  	if(king[j]&(king[k]<<1)) continue;
	  	if((king[j]<<1)&king[k]) continue;
	  	for(long long o=1;o<=num;o++)
	  	 {
	  	 	if(o+size[j]>num) continue;
	  	 	 dp[i][j][size[j]+o]+=dp[i-1][k][o];
		 }
	  }
	for(long long i=1;i<=n;i++)
	 for(long long j=1;j<=cnt;j++)
	 {
	 	ans+=dp[i][j][num];
	 }
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：niiick (赞：3)

### **爆裂吧！！！五重循环！！！！**

$dp[i][j][l]$表示**前i行共放了**$l$**个king**,且**第**$i$**行状态为**$j$的方案数**

先把只考虑一行的合法方案枚举出来存入state[]数组，
同时预处理dp[1][][]的所有情况，对于$0<= x <= (1<< n)-1$都要调用

```
void check(lt x)
{
    //将状态x分别左/右移判断是否有相邻的king
    if( !(x & (x<<1) ) && !(x & (x>>1) ) )
    {    
        lt num=get(x);//计算该状态有多少个king
        if(num>k) return;//若num>k，则不合法
        else state[++cnt]=x,sum[cnt]=num,dp[1][x][num]=1;
	    //储存该状态，并更新dp数组
    }
}
```


接下来状态转移方程$dp[i][j][l]+=dp[i-1][t][p]$
```
for(int i=2;i<=n;i++)//第1行已预处理，所以从第二行开始递推
for(int j=1;j<=cnt;j++)//枚举第2行状态
for(int l=0;l<=k;l++)//枚举前i行所放king数量
for(int t=1;t<=cnt;t++)//枚举i-1行状态
for(int p=0;p<=l;p++)//枚举前i-1行所放king数量
if( test(state[j],state[t]) && p+sum[j]==l )//判断是否合法
dp[i][j][l]+=dp[i-1][t][p];//更新
```

最后$ans=\sum_{j=1}^{cnt}dp[n][j][k]$

**************************************

```
//niiick
#include<iostream>
#include<vector>
#include<algorithm>
#include<queue>
#include<cstring>
#include<cstdio>
using namespace std;
typedef long long lt;

lt read()
{
    lt f=1,x=0;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return f*x;
}

const int maxn=1010;
lt n,k;
lt state[maxn],sum[maxn];
lt dp[10][100][100];
lt cnt,ans;

lt get(lt x)
{
    lt num=0;
    while(x>0){
        if(x&1) num++;
        x=x>>1;
    }
    return num;
}

void check(lt x)
{
    if( !(x & (x<<1) ) && !(x & (x>>1) ) )
    {
        lt num=get(x);
        if(num>k) return;
        else state[++cnt]=x,sum[cnt]=num,dp[1][cnt][num]=1;
    }
}

int test(lt x,lt y)
{
    if(x&y) return 0;
    if((x<<1)&y) return 0;
    if((x>>1)&y) return 0;
    return 1;
}

int main()
{
    n=read();k=read();
    for(int i=0;i<=(1<<n)-1;i++)
    check(i);
    
    for(int i=2;i<=n;i++)
    for(int j=1;j<=cnt;j++)
    for(int l=0;l<=k;l++)
    for(int t=1;t<=cnt;t++)
    for(int p=0;p<=l;p++)
    if( test(state[j],state[t]) && p+sum[j]==l )
    dp[i][j][l]+=dp[i-1][t][p];
    
    for(int i=1;i<=cnt;i++)
    ans+=dp[n][i][k];
    
    printf("%lld",ans);
    return 0;
}

```

---

## 作者：违规用户名U56916 (赞：3)

这是一道状压DP题。那么怎么判断一道题是不是状压呢？

我们老师说如果一道题他的数据很小，特别小，不要高兴，你会发现这道题一般算法解决不了，那么恭喜这90%是状压DP


------------


# 言归正传

状压的精髓就是把状态用数字表示出来，这个十进制数转化的二进制数就是这个状态

**所以这需要一定位运算基础**

~~像我这种蒟蒻还需要边码程序边看位运算是啥~~

我们用1来表示这个位置放了个国王，0表示不放

像这样

**10101001**

**00101010**

在n<=9范围内，不考虑题干，最大的情况是

(111111111)2=2^9-1;

这也就是为什么状压题数据都很小。

现在我们来看题目要求

国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。

这个国王能攻击他周围一圈人，就是要满足

**000**

**010**

**000**

我们要先考虑本行的状态要成立

成立的条件就是(i>>1)&i==0（确定左边一个不是国王）&&(i<<1)&i==0（确定右边一个不是国王）

然后注意这道题只需要放k个国王，不能多不能少，所以我们在判断的同时要看看这种状态有几个1即几个国王，大于k的删掉，小于k存储有几个

```cpp
for(int i=0;i<MAXN;i++){//MAXN为最大值
        if((!((i<<1)&i))&&(!((i>>1)&i))){
            int j=i,tl=0,pd=0;
            while(j>0){
                if(j&1) tl++;
                if(tl>k){
                    pd=1;
                    break;
                }
                j=j>>1;
            }
            if(!pd) b[i]=tl;
            else b[i]=-1;
        }
        else b[i]=-1;
    }
```

注意不成立一定不要赋值成0，这样没有办法区分是有0个（**000000000**）还是不成立

然后还要满足和上一行不冲突

上一行的状态我们认为是j

那么要满足j&i==0(他的上一个不是国王)&&(j>>1)&i==0(左上不是)&&(j<<1)&i==0(右上不是）

状态我们可以表示了现在就想转移方程

其实转移方程还是很好写的

f[i][j][k]存储前i行一共有j个国王第i行状态为k的方案数

那么f[i][j][k]+=f[i-1][j-m][l]

其中m为现在第i行状态一共有多少个国王，l为i-1行的状态

C++AC代码如下

```
#include<bits/stdc++.h>
using namespace std;
long long f[10][82][1025],ans;
int b[1025];
int main(){
    int n,k;
    cin>>n>>k;
    int MAXN=1<<n;//最大的情况是这个值-1
    for(int i=0;i<MAXN;i++){//判断程序在刚才已经出现了
        if((!((i<<1)&i))&&(!((i>>1)&i))){
            int j=i,tl=0,pd=0;
            while(j>0){
                if(j&1) tl++;
                if(tl>k){
                    pd=1;
                    break;
                }
                j=j>>1;
            }
            if(!pd) b[i]=tl;
            else b[i]=-1;
        }
        else b[i]=-1;
    }
    f[0][0][0]=1;//初值
    for(int i=1;i<=n;i++){//DP
        for(int j=0;j<=k;j++){
        for(int h=0;h<MAXN;h++){
            if((b[h]<=j)&&(b[h]!=-1)){
                for(int l=0;l<MAXN;l++){
                    if((!(h&l))&&(!(h&(l<<1)))&&(!(h&(l>>1)))&&(b[l]!=-1)){
                        f[i][j][h]+=f[i-1][j-b[h]][l];
                    }
                }
            }
        }   
        }
    }
    for(int i=0;i<MAXN;i++){
     ans+=f[n][k][i];//每种情况都要加一遍
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：封癫 (赞：3)

[博客链接](http://www.cnblogs.com/cellular-automaton/p/7599864.html)

真是可恶，被数据范围坑了一把。想要一遍AC的希望破灭了……

以后大家在做状压DP的时候一定要开long long……

设f[i][j][k]表示考虑前i行，总共放了j个King，第i行状态为k时的方案数。

先统计出k的二进制位有多少1，记为len，然后枚举o（1~(1<<n)-1），则状态转移方程有：

　　f[i][j][l]+=f[i-1][j-len][o];

注意判断两个状态是否合法。

j&(j>>1)不行，o&j不行，(o>>1)&j不行，(o<<1)&j也不行。当然o&(o>>1)更不行。

最后累计答案。

```cpp
#include<cstdio>
#include<cctype>
inline long long read(){
    long long num=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')    f=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        num=num\*10+ch-'0';
        ch=getchar();
    }
    return num\*f;
}

long long f[10][101][600];
inline int getlen(long long x){
    int ans=0;
    bool s;
    while(x){
        if(x&1)    ans++;
        x>>=1;
    }
    return ans;
}

long long Max;
long long ans;

inline bool check(long long x,long long y){
    if(x&y)    return 1;
    if((x>>1)&y)    return 1;
    if((x<<1)&y)    return 1;
    
    return 0;
}

int main(){
    f[0][0][0]=1;
    int n=read(),k=read();
    Max=(1<<n)-1;
    for(int i=1;i<=n;++i)
        for(int j=0;j<=k;++j)
            for(int l=0;l<=Max;++l){
                int len=getlen(l);
                if(len>j)        continue;
                if(l&(l>>1))    continue;
                for(int o=0;o<=Max;++o){
                    if(check(o,l))    continue;
                    if(o&(o>>1))    continue;
                    f[i][j][l]+=f[i-1][j-len][o];
                }
            }
    for(int i=0;i<=Max;++i)
        ans+=f[n][k][i];
    printf("%lld",ans);
    return 0;
}

---

## 作者：何卓然 (赞：3)

状态压缩好题！


首先关注数据范围， n 和 m 都很小，考察一个国王的攻击范围，只有当前行的一个格子，上一行的三个格子和下一行的三个格子。


考虑暴力做法，我们可以显而易见的发现，在每一行中，也有很多国王互相冲突的情况，而对于整个矩阵，每一行的情况都是类似的，我们可以首先预处理出所有的 “在某一行内国王不冲突的所有情况" 将这个状态用一个二进制数表示。对于的本题情况，个人估算下来合法状态大概在一百种左右，即使使用 DFS 枚举每一行再判断，也可以通过 n = 7 （个人估计有可能过 n = 8） 的点。


说到这里其实已经和正解非常接近了，由于我们最开始提到的国王攻击的范围，可以发现，对于一个合法的棋盘，它的前任意行也都是合法的，我们考虑动态规划，用


f[i][j][k] 表示 前 i 行，放好了 j 个国王，**第** i 行的放置状态为 k，


我们得到了状态转移方程


f[i + 1][j + b[l]][a[l]] += f[i][j][a[k]] (a[l] 状态 和 a[k] 状态不冲突)


完美解决了这个问题。


---

## 作者：Blizzard (赞：3)

对于这道经典的状压DP题，这里给出一份思路比较清晰的代码。

我们可以dfs构造出每一行的国王摆放可能种类，之后记录一下状态以及国王数量

之后考虑DP，第一行显然可以预处理出来，之后对于每一行都可以和上一行进行比较

如果上一行的状态有冲突，则非法；如果上一行左移有冲突，则非法；右移同理；

根据这个我们可以得出每一行每个状态的合法方案摆放总数，那么状态转移便是很显然的了

1A代码：


```cpp
#include<stdio.h>
using namespace std;
typedef long long ll;
int n,k,top=0;
int c[1<<10],s[1<<10];
void dfs(int cond,int sum,int pos){
    if(pos>n){
        c[++top]=cond;
        s[top]=sum;
        return;
    }
    dfs(cond+(1<<pos-1),sum+1,pos+2);
    dfs(cond,sum,pos+1);
}
ll f[11][1<<10][31];
int main(){
    scanf("%d%d",&n,&k);
    dfs(0,0,1);
    for(int i=1;i<=top;++i) f[1][c[i]][s[i]]=1ll;
    for(int i=2;i<=n;++i)
      for(int j=1;j<=top;++j)
        for(int h=1;h<=top;++h){
            if(c[j]&c[h]) continue;
            if((c[j]<<1)&c[h]) continue;
            if((c[j]>>1)&c[h]) continue;
            for(int sum=k;sum>=s[j];--sum)
            f[i][c[j]][sum]+=f[i-1][c[h]][sum-s[j]];
        }        
    ll ans=0ll;
    for(int i=1;i<=top;++i) ans+=f[n][c[i]][k];
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Feliks (赞：2)

# 状态压缩
```
for(int i=0;i<ts;i++){
		g[i]=((i&(i<<1))==0)&&((i&(i>>1))==0);
		h[i]=i|(i>>1)|(i<<1);
		cnt[i]=cnt[i>>1]+(i&1);	
	}
```
```
上面可以解释成
例如：g的状态i 0 1 0 0
		  i>>1 0 0 1 0
          i<<1 1 0 0 0
          三者且运算得零，所以i合法
      h的状态i 0 0 1 0
          i>>1 0 0 0 1
          i<<1 0 1 0 0
          三者或运算得出
               0 1 1 1
      cnt的状态i中1的个数
	  就等于i>>1的1的个数
	  加上i末位的1的个数
```


```
#include<bits/stdc++.h>
using namespace std;
int n,k;
long long ans;
const int S=(1<<10)+5;
int cnt[S],g[S],h[S];//cnt是某状态的1的个数（即国王的数量），g是这个状态是否合法（左右均无国王） ，h是某个状态的国王攻击范围 
long long f[10][S][100];
int main(){
	scanf("%d%d",&n,&k);
	int ts=1<<n;
	f[0][0][0]=1;
	for(int i=0;i<ts;i++){
		g[i]=((i&(i<<1))==0)&&((i&(i>>1))==0);
		h[i]=i|(i>>1)|(i<<1);
		cnt[i]=cnt[i>>1]+(i&1);	
	}
	for(int i=0;i<n;i++){//枚举每行 
		for(int j=0;j<ts;j++){//枚举i行的状态 
			for(int l=0;l<=k;l++){//枚举国王的个数 
				if(f[i][j][l]){//这个若去掉会慢，加上是因为如果f[i][j][l]是零，下边就没有加的必要（小优化） 
					for(int p=0;p<ts;p++){//枚举下一行的状态 
						if(g[p]&&((h[p]&j)==0)){//如果下一行的状态合法且下一行的国王攻击不到i行的国王 
							f[i+1][p][l+cnt[p]]+=f[i][j][l];//这里最终将方案数的和传递到末行
						}
					}
				}
			}
		}
	}
	for(int i=0;i<ts;i++){
		ans+=f[n][i][k];//末行所有状态的方案数的和即为所求
	}
	printf("%lld\n",ans);
}
```


---

## 作者：地表最强男人 (赞：2)

### 这一题是刚学状压的时候写的，借鉴了第一篇题解的处理方式。
- 写过一些题目，还是对状压有些理解，因为这一题n的值特别小，计算了一下$2^9$，发现不超过2000，而且如果用$dfs$好像也不怎么好，所以试着写了一下状压。这种压缩的方法十分明显，枚举每一行的状态，用二进制表示，如果该位有0（最低位为1），那么这一行的这一列上就有放国王，如果是0就没有放。考虑到怎么从上一行转移过来，设$f[i][j][k]$为第i行为止，第j种情况，目前为止一共使用了k个国王的方案数（注意：这里的j并不是二进制的状态，而是第j种我们求出的状态！！！我是将状态存储在$zt[\ ]$数组中的！！请认真看代码）。因为我们如果需要做这一行，只和上一行有关（有点像八皇后呢）。如果上一行的状态为第l种，且这两种状态是可以相容的，那$f[i][j][k]+=f[i-1][l][k-use[j]]$。注明一下：$use[i]$存储的是第i种情况需要消耗的国王数量，我们目前消耗的国王减去这一行消耗的国王数量就是上一行为止国王的总数。
- 还有一点，就是怎么判断两种状态相容，我们设两种状态为$zt[i]$和$zt[j]$，如果我们上下两行同个位置中没有国王，而且相邻位置也不能有两个国王，这样的状态才是相容的，所以处理相邻的办法就是判断($zt[j]<<1$)&$zt[k]==0$还有($zt[j]>>1$)&$zt[k]==0$和$zt[j]$&$zt[k]==0$这样就判断了上面的三种情况。
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,use[200010],zt[200010],tot;
long long f[11][2048][100],ans=0;
void dfs(int x,int y,int num)//预处理每一行可行的情况
{
        if(num==n)
        {
            use[++tot]=y;
            zt[tot]=x;
            return ;
        }
        if((x&1)==0)
            dfs((x<<1)+1,y+1,num+1);
        dfs((x<<1),y,num+1);
}
int main()
{
        cin>>n>>m;
        dfs(0,0,0);
        f[0][0][0]=1;
        for(int i=1;i<=n;i++)
            for(int j=0;j<tot;j++)
                for(int k=0;k<tot;k++)//注意，一定不能取tot，最后一种情况是0，已经和第0种重复了!!!
                    if((zt[j]&zt[k])==0&&(zt[j]&(zt[k]<<1))==0&&(zt[j]&(zt[k]>>1))==0)
                        for(int l=use[j];l<=m;l++)
                            f[i][j][l]+=f[i-1][k][l-use[j]];//转移
        for(int i=0;i<tot;i++)
            ans+=f[n][i][m];//最后一行可以是任意的情况
        cout<<ans;
        return 0;
}
```


---

## 作者：HYR2018 (赞：2)

借鉴了其他大佬的题解，按自己的理解重新解释一下代码

先是怎么处理图的问题：

这里国王的放置方法就两种情况，放和不放

那么我们就把放国王看成1，不放国王看成0

而这里就需要预处理，就是将放与不放的图转换成二进制来表示

我们需要将每种可能的情况给枚举出来：

0 0 0

0 0 1

1 0 0

1 0 1

0 1 1

样例一共有五种情况的预处理（我没按顺序来枚举）

而其中还有一个不太容易想的地方就是判断上下，左上右下，左上右下的情况

这里我们用按位与来判断

（“&”按位与运算：两个对应的二进制均为1时结果为1，否则为0）

那么判断上下的情况就是第j种状态与第k种状态按位与一下

举个例子：

j 0 1 1

k 1 0 1

& 0 0 1

这样的情况就是最后一列的两个国王要互相攻击，所以我们需要continue掉

左上右下，左下右上的情况就是需要错一下位来判断

大概解释就是这样了，代码中也有比较详细的解释，我直接上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long dp[10][1024][100];
//第几行,此行放什么状态,到这一行已经使用了的国王数

int N,K;
int cnt;
int gs[100];
long long situated[1024];
long long ans;

void dfs(int sum,int num,int x)//预处理//枚举国王的摆放状态 
//sum为用二进制的0和1来存摆放国王的状态 
//num为当前状态使用的国王数 
//x为本行第x格的状态
{
	if(x>=N)
	{
		++cnt; 
		situated[cnt]=sum;//cnt个的最终的状态则为sum（二进制表示）
		gs[cnt]=num;//cnt个所用的国王数 
		return;
	}
	dfs(sum,num,x+1);//不用第x个格子//则下一个格子可以用 
//则目前的格子所表示的数为sum（二进制表示）//国王已经用了num个 
	dfs(sum+(1<<x),num+1,x+2);//用第x个格子//则下一个格子不能用需要跳一格 
//则目前格子所表示的sum为二进制中1左移了x位//用了的国王数要+1 
}

int main()
{
	cin>>N>>K;
	dfs(0,0,0); 
	for(int i=1;i<=cnt;i++) dp[1][i][gs[i]]=1;//第一层是枚举的所有情况都可能有
	for(int i=2;i<=N;i++)
	{
		for(int j=1;j<=cnt;j++)
		{
			for(int k=1;k<=cnt;k++)
			{
				if(situated[j]&situated[k]) continue;//上下有重复的
				if((situated[j]<<1)&situated[k]) continue;//左上右下有重复的
				if((situated[j]>>1)&situated[k]) continue;//左下右上有重复的
				for(int l=K;l>=gs[j];l--) dp[i][j][l]+=dp[i-1][k][l-gs[j]];
				//要加上上一层k种状态下用了剩余国王数的情况 
			}
		}
	} 
	for(int i=1;i<=cnt;i++)ans+=dp[N][i][K];
	cout<<ans;
	return 0;
} 
```
本蒟蒻只能通过看其他dalao的题解，再根据自己的理解解释一下思路与代码，将其中的较难的地方强行解释一通（还望管理员通过）

---

## 作者：zhaoyifan (赞：2)

先思考怎么表示状态，用f[i][j]表示第i行放j个显然不行，那么需要一个可以表示出状态的变量，由于m很小，可以用二进制表示每个位置是否放置，因此f[i][j][z]表示第i行放置状态j时共放置z个国王的方案数，本行只收上一行的状态。

我用的是状压dfs，和状压dp想法一样，而且比较好实现，另外复杂度相同。

状压dfs（((2^n)^2)\*k\*n）最坏情况1e9，可以ac。

x表示行，y是列（从0），zhuang是你所求的上一行的状态，net是本行的状态（即本行的zhuang），now表示现有的国王总数，start存初值，l保证国王不相邻（其实可以直接跳两步，就不需要l了）

ps：int要改为长整形

```cpp
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,k,cnt,f[11][1125][101];
int dfs(int x,int y,int zhuang,int net,int now,int start,int l)
{
    if(y==n)
    {
        f[x+1][net][now]+=start;
        return 0;
    }
    dfs(x,y+1,zhuang,net,now,start,l);
    if(now<k&&(((1<<y)&zhuang)==0)&&y-l>1)
    {
        net=net|(1<<y);
        if(y>0)
        net=net|(1<<y-1);
        if(y<n-1)
        net=net|(1<<y+1);
        dfs(x,y+1,zhuang,net,now+1,start,y);
    }
}
int main()
{
    cin>>n>>k;
    memset(f,0,sizeof(f));
    f[1][0][0]=1;
    for(int i=1;i<=n;++i)
     for(int j=0;j<(1<<n);++j)
      for(int z=0;z<=k;++z)
       if(f[i][j][z])
       dfs(i,0,j,0,z,f[i][j][z],-2);
    int ans=0;
    for(int i=0;i<(1<<n);++i)
    ans+=f[n+1][i][k];
    cout<<ans;
    return 0;   
}
```

---

## 作者：7KByte (赞：2)

- ## 0x00 前言
状压dp——状态压缩动态规划  
这里主要讲一下位运算和判定条件

-------
- ## 0x10 位运算基础
我们日常生活中看到的数都是10进制数，但在计算机里是以二进制的方式进行运算和储存的，而直接对这些二进制数进行操作就是位运算
 - 1.按位与 , and , '&'  
 双目运算符，指在二进制下，两数第i位都为1，则结果的该位为1，否则为0
 - 2.按位或 , or , '|'
 双目运算符，指在二进制下，两数第i位只要有一个为1，则结果的该位为1，否则为0    
 位运算还有很多，篇幅受限只介绍与本题有关的


------------
- ## 0x11 位运算进阶&状态压缩前置技能
   - 取出x在二进制下的最后一位：(x&1)
   - 删除最后一位(右移)：(x>>1)
   - 计算一个数有多少位1（代码）
   ```
   int count(int x){
    int sum=0;
    while(x){
        sum+=x&1;
        x=x>>1;
    }
    return sum;
   }
   ```
   - 在本题中不能有两个国王放在一起，即在状态压缩（可先看0x20）后状态x二进制下任意两个1不相邻，我们只用不断取出当前最低位和上一位直接判断即可，具体细节见代码
   ```
   bool judge(int x){
    int last=x&1;x=x>>1;
    while(x){
        int flag=x&1;
        //cout<<flag<<" "<<last<<endl;
        if(last==flag&&last)return false;
        last=flag;
        x=x>>1;
    }
    return true;
}
```
----------
- ##  0x20 状态压缩
我们对每行国王的状态进行状态压缩，记录一个变量x，在二进制表示下x的第i位为一表示在第i列的位置摆放了一个国王。  
所以一行合法的状态（见0x11）:  
judge(x)==true  
相邻两行合法的状态:  
(x&y)==0    //不能上下相邻   
judge(x|y)==true  //左右不能相邻  
相邻两行合法的状态包括了一行的状态，所以我们只用判两行合法的状态


-------------
- ## 0x30 动态规划
f[i][j][k]表示前i行，最后一行状态为j，共放了k个国王的方案数  
我们枚举i行数，j上一行的状态，k当前行的状态，f前i-1行放了国王的总数，那么转移方程为  
**f[i][k][count(k)+f]+=f[i-1][j][f]**  
最终的答案是f[n][i][k]的总和（n行数,k国王数，i为枚举的最后一行的状态）
状态的范围:**0 to (i<<n)-1**  

-----------
- ## 0x40 代码
```
#include<bits/stdc++.h>
#define N (9+1)
using namespace std;
typedef long long ll;
bool tk[1<<N];
ll dp[N][1<<N][N*N];
int v,n;
bool judge(int x){
    int last=x&1;x=x>>1;
    while(x){
        int flag=x&1;
        if(last==flag&&last)return false;
        last=flag;
        x=x>>1;
    }
    return true;
}
int count(int x){
    int sum=0;
    while(x){
        sum+=x&1;
        x=x>>1;
    }
    return sum;
}
int main()
{
    cin>>n>>v;
    memset(dp,0,sizeof(dp));
    memset(tk,0,sizeof(tk));
    for(int i=0;i<=1<<N;i++)
      tk[i]=judge(i);
    dp[0][0][0]=1;
    for(int i=1;i<=n;i++)
      for(int j=0;j<=(1<<n)-1;j++)
        for(int k=0;k<=(1<<n)-1;k++)
          for(int f=count(j);f<=v;f++)
            if((j&k)==0&&tk[j|k])
              dp[i][k][count(k)+f]+=dp[i-1][j][f];
    ll ans=0;
    for(int i=0;i<=(1<<n)-1;i++)
      ans+=dp[n][i][v];
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：就皮这一下 (赞：1)

各位大佬代码很详细，但是我觉得不乏“造轮子”甚至越界的问题出现，这里给大家介绍一组神奇的函数：__builtin

### __bulitin家族没有孬种！

__builtin是一类神奇的函数，在处理2进制的时候有神奇的作用

```cpp
inline int num (int x) {
	return __builtin_popcount(x);
}
```

这__builtin_popcount是什么？

[这里有个神犇的详解](https://blog.csdn.net/jasonchen_gbd/article/details/44948523)，讲的很多，但Oi中只有几个有用
。这里，让我们看看：

>__builtin_popcount(x) 返回x中1的个数

这个就是我们的“金刚钻”，**用它去求这个状态有多少个国王**，接下来就是规划一下“瓷器活”怎么做了。

考虑状态定义：**这一行只受上一行影响**，“行”是一个 _天然的阶段划分_ 。状态定义：
>dp[i][j][k] : 第i行状态为j，且**以j的状态**放上后有k个国王

存的（~~好像是叫什么指标函数~~）显然就是方案了

状态j怎么表示？开一个dp[10][2][2][2][2][2][2]……？（第1,2,3……行放/不放）？？理论上可行，但实践上，，，你需要：
>_**27个特判**_ 

>**_不用传址：打一个10维数组_**

##### 相信大家都知道集合表示的整数法。
{1,4,6,7} -> 011010010

那么这个状态可以这么表示吗？

### 显然可以。

具体怎么做，大家都有数了，还不明白，前人之述备矣。

## 这里分析一下时间复杂度
#### 最高（粗略估计）
状态$2^n$，每次转移$2^n*2^n$,转移n次，枚举k个国王，$O(2^{n^2}+n^3) = O($……

#### 实际上：
即使$n=9$

状态也只有89种合法的

$89*89*9*81 = 5774409$

接下来就没有了喵？

```cpp
#include <bits/stdc++.h>
using namespace std; 

int state[90];
int m = 0;
//   row states
long long dp[10][90][90];//counts

inline int num (int x) {
	return __builtin_popcount(x);
}
inline bool invalid (int a,int b) {
	return (a&b) || (a&(b<<1)) || (a&(b>>1))
}
int main () {
	int n,tot;
	cin >> n >> tot;
	for (int i = 0; i < (1<<n); ++i) {
		if (i & (i << 1)) continue;
		state[++m] = i;
	}
	for (int i = 1; i<=m; ++i)
		dp[1][i][num(state[i])] = 1;
	
	for (int i = 2; i<=n; ++i)
		for (int k = 1; k<=m; ++k) {
			int pst = state[k];
			for (int j = 1; j<=m; ++j) {
				int cst = state[j];
				if (invalid(cst,pst)) continue;
				for (int popcount = num(pst); popcount+num(cst) <= tot; ++popcount)
					dp[i][j][popcount+num(cst)] += dp[i-1][k][popcount];
			}
		}
	long long ans = 0;
	for (int j = 1; j<=m; ++j)
		ans += dp[n][j][tot];
	cout << ans << endl;
	return 0;
}

```


---

## 作者：一个昵称 (赞：1)

# 一个状压DP

首先 先解释一下状压是什么吧 对于这种类型的题 每个点 都只存在两种情况 即为放了东西 没放东西 （这里先解释一下为什么不可以把状态设为每一个点 因为 如果设为每一个点的话 状态很不好转移 下一个点的位置无法确定）那么 我们就可以把放了东西定为1 没放东西定为0 于是 我们便可以得到类似“0 1 0 1”这样的一个状态（这里我们只模拟了一行的状态） 而这样的一个状态“0 1 0 1” 可以把他看作一个二进制数 我们也就可以很轻松的把他转换为一个10进制数 即5 那么 这个十进制数5 就可以表示这样的一个“0 1 0 1”的状态 也就是说 我们把这样的一个状态压缩到了一个十进制数里面 也就是状态压缩了

而我们的DP 就是通过状态的转移来进行计算 那么我们这个时候 所需要存储的状态 就会变成一个数 避免了原先一整行的摆放情况难以存储的问题

于是我们看回这道题 首先 它就是刚刚讲过的 是一个判断摆放情况的题 而且 他的数据范围很小（数据范围大了 状压就不一定能做了 因为它有一个进制的转换） 所以 可以判断出来 这是一道状压DP

那么 我们就可以设状态为每一行的摆放情况 f(i,j,k) 用来表示 第i行 摆放情况为j 截止当前行 使当前状态下一共摆放的个数为k的情况总数

那么 他的状态怎么转移呢 因为它本质上是一个放或不放的题 所以他的动态转移方程类似于01背包 

即 f[i][j][k]=f[i][j][k]+f[i-1][t][k-第i行放了的个数] 其中 t为第i-1行的状态

那么我们只需要枚举行 枚举该行状态 枚举上一行状态 再判断一下两状态是否冲突 然后再统计答案就好啦

先放上代码 看不懂的话后面有解释的（~~但我jio得我已经讲清楚了~~）

```cpp
#include<iostream>
#include<cmath>
#include<cstring>
using namespace std;
int n,k;
long long f[10][2000][100];
int a[2000];
int b[2000];

int sum1(int x){
	int ans=0;
	while(x){
		ans++;
		x-=x&-x;
	}
	return ans;
}

int checkh(int x){
	int t=x&1;
	while(x){
		
		x=x/2;
		
		if(x&1==t && t==1){
			return 0;
		}
		t=x&1;
	}
	return 1;
}

int main(){
	cin>>n>>k;
	for(int x=0;x <= (1<<n)-1;x++){	
		int bol=checkh(x);
		if(bol){
			int yi=sum1(x);	
			a[x]=yi;
			f[1][x][a[x]]=1;
		}
		else{
			b[x]=1;
		}
	}
	for(int i=2;i<=n;i++){
		for(int x=0;x <= (1<<n)-1;x++){
			if(!b[x]){
				int gs1=a[x];
				for(int y=0;y<=(1<<n)-1;y++){
					if(!b[y]){
						if((x&y)==0&&(x&(y<<1))==0&&(x&(y>>1))==0){
							for(int s=k;s>=gs1;s--){
								f[i][x][s]+=f[i-1][y][s-gs1];									
							}
						}				
					}
				}				
			} 
		}
	}
	long long cut=0;
	for(int x=0;x<=(1<<n)-1;x++){
		if(!b[x]){
			cut+=f[n][x][k];
		}		
	}
	cout<<cut;
	return 0;
} 
```


DP部分较为简单 我就再啰嗦一下预处理把 

首先 如何枚举状态 比如一个3 * 3的棋盘 那么某一行的状态中 值最大的状态为“1 1 1” 这个状态怎么来的呢 它可以是由“1 0 0 0 ”-1得到 那么 我们只需要根据棋盘的规模n 推出形如“1 0 0 0 ”这样的数 然后再-1 就可以得到状态的最大值啦 这里我们就需要用到位运算 左移<< 比如当n=3 时 “1 0 0 0”就可以由1向左移动3位得到 所以就有了(1<<n)-1这个式子去求状态的最大值 然后再枚举就好啦 
```cpp
for(int x=0;x <= (1<<n)-1;x++)
```

然后 枚举完状态 我们需要判断一下状态的合理性 因为这里我们只考虑一行 所以 只需要不存在两个连续的“1”即为合理 那么我们就可以进行逐位比较 我们每一次可以用“x&1”取出x的最后一位 然后再将x右移 取其当前末尾值 然后比较就OK啦 代码如下

```cpp
int checkh(int x){
	int t=x&1;
	while(x){
		
		x=x/2;//右移和÷基本是等效的
		
		if(x&1==t && t==1){
			return 0;
		}
		t=x&1;
	}
	return 1;
}
```
还有就是如何得到状态中有几个“1”
这里我们用到了一个树状数组中必用的东西 lowbit 即为x&-x
 这个东西有什么用呢 就是取出x的最后一个1所在位置 具体的证明啊什么的我写不动了 可以自己再去看看树状数组 [树状数组模板题](https://www.luogu.org/problem/P3374)
 下面是代码
 ```cpp
int sum1(int x){
	int ans=0;
	while(x){
		ans++;
		x-=x&-x;
	}
	return ans;
}
```
然后 这里我用了两个数组a和b 分别用来存这个状态里的“1”的个数和其合理性 就不用每次调用函数啦

**最后 给大家提个醒 数组一定要开够 以及 十年OI一场空 不开longlong见祖宗**

---

## 作者：Minakami_Yuki (赞：1)

状压DP入门题~~但是我早都入门了为啥还要写这个~~

# 题目链接

[P1896 [SCOI2005]互不侵犯](https://www.luogu.org/problem/P1896)

# 题意简述

在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。

# 解题思想

考虑状压每一行，然后以行为阶段DP。

预处理出每一个状态所需的国王数，然后转移的时候枚举两行的状态判一下就行了。

这里给出一个调试状压DP很好用的函数：

```cpp
void print(ll x, ll base, ll len, char const *s = NULL) {
    int tmp[100] = {0}, tot = 0;
    while(x) {
        tmp[++tot] = x % base;
        x /= base;
    }
    for(register int i = len; i >= 1; i--) printf("%d", tmp[i]);
    if(s) printf("%s", s);
}
```

将一个数转为 `base` 进制然后输出，空位输出 $0$

便于打印状态。

当然，如果是二进制状压则有一个好写的多的函数：

```cpp
void print_bin(int x, int len) {
    if(len) {
        print_bin(x >> 1, len - 1);
     	putchar('0' + x & 1);
    }
}
```



# 参考代码

```cpp
#include <cstdio>
#include <cctype>

#define ll long long

namespace FastIO {
    inline ll read() {
        char ch = getchar(); ll r = 0, w = 1;
        while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();}
        while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();}
        return r * w;
    }
    void _write(ll x) {
        if(x < 0) putchar('-'), x = -x;
        if(x > 9) _write(x / 10);
        putchar(x % 10 + '0');
    }
    inline void write(ll x, char const *s = "\n") {
        _write(x);
        printf("%s", s);
    }
}

using namespace FastIO;

const int N = 10;

ll ans = 0;
ll n, m, cnt;
ll dp[N][1 << N][N * N];
ll sta[1 << N], num[1 << N];

void print(ll x, ll base, ll len, char const *s = NULL) {
    int tmp[100] = {0}, tot = 0;
    while(x) {
        tmp[++tot] = x % base;
        x /= base;
    }
    for(register int i = len; i >= 1; i--) printf("%d", tmp[i]);
    if(s) printf("%s", s);
}

void dfs(int sit, int sum, int now) {
    if(now >= n) {sta[++cnt] = sit, num[cnt] = sum; return;}
    dfs(sit, sum, now + 1);
    dfs(sit + (1 << now), sum + 1, now + 2);
}

int main() {
    n = read(), m = read();
    dfs(0, 0, 0);
    for(register int i = 1; i <= cnt; i++) {
        dp[1][sta[i]][num[i]] = 1;
    }
    #ifdef DEBUG
    for(register int i = 1; i <= cnt; i++) {
        printf("num[");
        print(sta[i], 2, n);
        printf("] = %d\n", num[i]);
    }
    #endif
    for(register int i = 2; i <= n; i++) {
        for(register int j = 1; j <= cnt; j++) {
            for(register int k = 1; k <= cnt; k++) {
                //print(sta[j], 2, n, "\n");
                //print(sta[k], 2, n, "\n");
                if((sta[j] & sta[k]) || ((sta[j] << 1) & sta[k]) || ((sta[k] << 1) & sta[j])) {
                    continue;
                }
                for(register int s = m; s >= num[j]; s--) {
                    dp[i][sta[j]][s] += dp[i - 1][sta[k]][s - num[j]];
                }
            }
        }
    }
    for(register int i = 1; i <= cnt; i++) ans += dp[n][sta[i]][m];
    write(ans);
    return 0;
}
```

---

## 作者：凉如水 (赞：1)

第二次做这道题，感觉思路清晰了很多~

# 题目描述

# 在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。

# 输入格式：

# 只有一行，包含两个数N，K （ 1 <=N <=9, 0 <= K <= N * N）

# 输出格式：

# 所得的方案数

# 样例

# 输入 3 2

# 输出 16

附上蒟蒻的代码
```cpp
#include<bits/stdc++.h>
#define re return
#define st static
#define mem(A,B) memset((A),(B),sizeof(A))
#define Min(A,B) (A)<(B)?(A):(B)
#define Max(A,B) (A)<(B)?(A):(B)
#define inc(i,l,r) for(int i=l;i<=r;++i)
#define dec(i,l,r) for(int i=l;i>=r;--i)
 
using namespace std;
template<typename T>inline void read(T&x)
{
	char c;bool f=0;
	while((c=getchar())<'0'||c>'9')if(c=='-')f=1;
	x=c^48;
	while((c=getchar())>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48);
	if(f) x=-x;
}
 
template<typename T>void put(T x)
{
	if(x>9)put(x/10);
	putchar(x%10+48);
}
 
template<typename T>inline void write(const T x)
{
	if(x<0)putchar('-'),put(-x);
	else put(x);
} 
 
long long  king,ans=0,n,size,si[520],gs[520],f[10][520][30];
//long long 是个好东西，为此交了9次的我~~~
 
void js(int x)
{
	si[++size]=x;
	while(x)
	{
		if(x&1)gs[size]++;
		x>>=1;//注意！！！x>>1无效
	}
}
 
int main()
{
	read(n),read(king);
	if(king<=25)//9*9的棋盘上最多有25个国王
	{
		inc(i,0,(1<<n)-1)//这里可以进一步优化，但有一种懒叫做懒得不想呼吸
		if(!(i&(i<<1)))js(i);//判断是否有相邻的king存在，并塞选出每一行的可能方案
 
		inc(i,1,size)
		f[1][si[i]][gs[i]]=1;//可以选在f[0][1][0]=1,将i=1扔在下面
	
		inc(i,2,n)
		inc(j,1,size)
		inc(k,1,size)
		{
	 	 	if((si[j]&si[k])||(si[j]&(si[k]<<1))||(si[j]&(si[k]>>1)))continue;
		  	dec(ss,king,gs[j])
			   f[i][si[j]][ss]+=f[i-1][si[k]][ss-gs[j]];
		}
	    /*常规方案统计一波*/
 
		inc(i,1,size)
		ans+=f[n][si[i]][king];
	}
	printf("%lld",ans);
	re 0;
}

```
听隔壁大佬说ta要开二维做这道题，在下先溜了

---

## 作者：Baihua (赞：1)

## P1896 [SCOI2005]互不侵犯

在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。

##### 看到Ｎ比较小 ， 应该能想到搜索或者状态压缩 　；

### Stp.1 状态设计

利用

```
F[I][J][K]
```

Ｊ的二进制形式下  ， Ｊ［Ｉ］ = １表示第Ｉ位有国王 ， 否则没有 　；

表示在第Ｉ行放置状态形如Ｊ的国王 ， 并且已经放置了Ｋ个国王的状态　；

### Stp.2 无用状态的判定

考虑

```
Ｊ０＝１００１１００
```

它右移一位就变成了

```
Ｊ１＝０１００１１０
```

同时

```
Ｊ０＆Ｊ１　＝＝００００１００　！＝　１
```

斜上，斜下和这个原理差不多

### Stp.3 小的技巧

* 统计状态里的国王个数

  ```
  #define Lowbit(X) (X&(-X))
  int BC(int X) {
      int Cnt = 0 ;
      while (X) {
          ++Cnt ;
          X -= Lowbit(X) ;
      }
      return Cnt ;
  }
  ```

* 直观显示状态（调试用）

  ```
  string Bin(int X) {
  	string Ans = "" ;
  	int Cnt = 0 ;
  	while (X) {
  		Ans = (char)((X&1)+'0') + Ans ;
  		X >>=1 ;
  		++Cnt ;
  	}
  	while (++Cnt <= N)Ans = '0' + Ans ;
  	return Ans ;
  }
  ```

* 最重要的

  ```
  #define int long long
  ……
  ……
  ……
  signed main(){
  ……
  ……
  ……
  ```

### Stp.4 Code

```
#include <iostream>
#include <fstream>
#include <stdio.h>
#include <math.h>
#include <algorithm>
#include <string.h>
#define re register
#define gc getchar()
#define Lowbit(X) (X&(-X))
#define int long long
using namespace std ;
int Qread () {
	int X = 0;
	char  ch = gc ;
	while (ch > '9' || ch < '0') ch = gc ;
	while (ch >='0' && ch <='9') {
		X = X * 10 + ch - '0' ;
		ch = gc ;
	}
	return X ;
}
int N ;
const int Maxn = 9 , MaxPw = 512 , Maxk = 81;
int K ,F[Maxn+2][MaxPw+2][Maxk + 2] , Num[MaxPw + 2];
unsigned int Pw;
int BC(int X) {
	int Cnt = 0 ;
	while (X) {
		++Cnt ;
		X -= Lowbit(X) ;
	}
	return Cnt ;
}
signed main () {
	//freopen ("P1896.txt" , "r" , stdin) ;
	N = Qread () , K =  Qread () ;
	Pw = ( 1 << N )- 1 ;
	memset (F , 0 , sizeof (F)) ;
	for (re int i = 0 ; i <= Pw ; ++ i) Num[i] = BC(i) ;

	for (re int i = 0 ; i<=Pw ; ++ i) {
		if (Num[i] <= K) {
			F[0][i][Num[i]] = 1 ;
		}
	}
	for (re int i = 0 ; i < N -1; ++ i) {
		for (re int j = 0 ; j <= Pw ; ++ j) {
			if(Num[j] > K) continue ;
			if (j&(j>>1)) continue ;
			for (re int k = 0 ; k <= K ; ++ k ) {
				if (!F[i][j][k]) continue ;

				for (re int jj = 0 ; jj <= Pw ; ++ jj) {
					if (Num[jj] + k > K) continue ;
					if ((jj&(j>>1))||(jj&(j))||(jj&(j<<1)))continue ;
					F[i+1][jj][Num[jj] + k] += F[i][j][k] ;
				}
			}
		}
	}
	int Ans =  0 ;
	for (re int i = 0 ; i <= Pw ; ++ i) {
		if (i&(i<<1)) continue ;
		Ans += F[N-1][i][K] ;
	}
	cout <<Ans<<endl;
	fclose (stdin) ;
	fclose (stdout);
	return 0;
}
```



---

## 作者：love_for_ever (赞：1)

# 这是状态压缩的DP


>首先，因为是状压DP,方程的某一维一定是一个状态。n<=9，我们可以用01串表示某一行放置的情况。2^0~2^8，那么总共状态就是2^9-1。空间还是承受的起。当然还要枚举一下当前做到第几行，以及当前一共放了几颗棋子。很快，有关f的表示就出来了：用f[i][j][now]表示到第i行，一共放j个棋子（包括这之前的），且第i行的状态是k的方案数。再考虑转移。这一行肯定是由上一行的状态转移过来的，那么我们可以再枚举上一行的状态。

#### 很自然的，发现这会超时。每次枚举一种状态就需要2^9，两重循环已经快爆掉了！我们可以发现一件事情。比如n=5,我们每次枚举到的11111,11011,10111,01011这些状态都是无效的！那么我们可以先预处理一下对于每一行的所有可行的状态（就是不能有连续的1）。这样的效率仍然不高——我们还可以对于每种可行的状态i,j，预处理i和j是否能够相邻，这样我们在DP的时候，就可以O(1)来转移了！

**代码如下：**
```cpp
#include<cstdio>
const int STEP=512;
using namespace std;
long long f[10][101][STEP],ans;
int m,n,num,i,j,now,k,stay[101],cnt[101]; //stay记录每种状态压缩后的值，cnt记录对应的状态中1的个数。
bool map[101][101];
void dfs(int k,int put,int now) 
{ //预处理，k是放了几颗，put是当前放的位置，now是当前状态压缩后的值。
    stay[++m]=now;
    cnt[m]=k;
    if(k>=(n+1)/2||k>=num) return;
    for(int i=put+2;i<=n;i++)dfs(k+1,i,now+(1<<(i-1)));
}
void init() 
{
    dfs(0,-1,0);                 //预处理出每种状态，共有m种。
    for(int i=1;i<=m;i++)
        for(int j=1;j<=m;j++) //枚举某两种状态是否能相邻。一共有三种不能的情况：上下都是1，左上、右下是1，左下、右上是1。
            map[i][j]=map[j][i]=((stay[i]&stay[j])||((stay[i]>>1)&stay[j])||((stay[i]<<1)&stay[j]))?0:1;
    for(int i=1;i<=m;i++)f[1][cnt[i]][i]=1ll;  //边界
}
int main() 
{
    scanf("%d%d",&n,&num);
    init();
    for(i=2;i<=n;i++)
    {
        for(j=0;j<=num;j++) 
        {
            for(now=1;now<=m;now++) 
            {
                if(cnt[now]>j)continue;
                for(k=1;k<=m;k++)
                    if(map[k][now]&&cnt[k]+cnt[now]<=j)f[i][j][now]+=f[i-1][j-cnt[now]][k]; //转移
            }
        }
    }
    for(i=1;i<=m;i++)ans+=f[n][num][i];
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Tanktt (赞：1)

其实这道题如果把数据缩小一点是可以用搜索的，但是既然这数据显然过不了，那就需要一些不一样的东西——状压动归。。

状压的核心就是把一行、一列数用二进制数来表示。那么对于这道题，每一行的状态（即1为放0为不放）由上一行和自身是否符合条件决定。那么状态是可以先预处理出来的。

另外在预处理还有一个小技巧，就是判断国王是否相邻，即i&(i<<1)，为0就是合法的，这在状态转移时判断上下两行的放置是否合法也是能用的。

预处理后，就是状态转移了，设f[i,j,k]表示第i行时状态为j且前i行已放了k个king，那么f[i,j,k]=Σf[i-1,p,k-sum[j]]，其中sum[j]表示状态为j时这一行的国王数。

那么时间复杂度是O(N*M*num^2),其中num是每一行合法的状态数。其实我们输出一下可以知道num=89，时间是可以接受的。


[DONE]

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,s[112],sum[112],num;
long long f[12][112][92],ans;
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=0; i<(1<<n); i++)
    {
    	if (i&(i<<1)) continue;//不合法
        int ss=0;//国王个数
        for (int w=0; w<n; w++)
        if (i&(1<<w)) ss++;
        if (ss>m) continue;//个数超过范围
        s[++num]=i;
        sum[num]=ss;
    }
    f[0][1][0]=1;
    for (int i=1; i<=n; i++)
        for (int j=1; j<=num; j++)//第i行的状态
        {
            for (int p=0; p<=m; p++)//前i行国王数
            if (p>=sum[j])
            {
                for (int k=1; k<=num; k++)//第i-1行的状态
                if ((sum[k]<=p)&&!(s[k]&(s[j]<<1))&&!(s[k]&s[j])&&!(s[k]&(s[j]>>1)))//是否合法
                f[i][j][p]+=f[i-1][k][p-sum[j]];
            }
        }
    for (int i=1; i<=num; i++)
    ans+=f[n][i][m];
    return printf("%lld\n",ans),0;
}
```

---

## 作者：jklover (赞：1)

 _ 前言_  
 
 _ 这道题是一道状压dp的练习好题~~本来想用dfs打表水过去的~~ _
 
 

------------
### 具体思路/做法

稍加观察,发现我们放置第i行时某个方案是否合法,仅取决于其自身一行是否不存在冲突,及与上一行是否不存在冲突.

n较小,考虑用状态压缩记录每行放置国王的情况.(某位上为0代表不放,1代表放)

则可以用$f[s][r][t]$表示第r行放置的集合为s,前r行一共已经放置了t个国王的方案数.

每行中判断自身一行是否存在冲突与行数无关,可以预处理出所有单行的合法状态,记为S,当$n<=9$时,可发现$|S|<=89$.

接下来,对于状态 $st\in S$,我们就可以将它们分别填入第一行,处理出第一行的$f$值.再依次枚举每一行,枚举该行填入的状态,上一行的状态,从第一行到上一行一共用了多少国王,即可完成转移.

#### 时间复杂度
预处理$O(2^n)$,转移时,枚举行数为$O(n)$,枚举两个状态为$O(|S|^2)$,枚举国王数目最坏为$O(k)$,即$O(n^2)$,总时间复杂度为$O(2^n+89*89*n^2)$.



------------

#### code

```cpp
#include<bits/stdc++.h>
#define rg register
#define ll long long
using namespace std;
inline int read()
{
	int out=0,fh=1;
	char jp=getchar();
	while ((jp>'9'||jp<'0')&&jp!='-')
		jp=getchar();
	if (jp=='-')
		{
			fh=-1;
			jp=getchar();
		}
	while (jp>='0'&&jp<='9')
		{
			out=out*10+jp-'0';
			jp=getchar();
		}
	return out*fh;
}
const int MAXN=20;
int times[1<<10];
ll f[1<<10][10][100];//方案数 
int n,k;
inline int judge(int st)
{
	int ls=0;
	for(rg int i=0;i<n;++i)
		{
			int f=st&1;
			st>>=1;
			if(f && ls)
				return 0;
			ls=f;
		}
	return 1;
}
inline int totused(int st)
{
	if(times[st]!=-1)
		return times[st];
	int& res=times[st];
	res=0;
	while(st)
		res+=st&1,st>>=1;
	return res;
}
inline int check(int st,int lst)
{
	if(st & lst)
		return 0;
	if(st & (lst<<1))
		return 0;
	if((st<<1) & lst)
		return 0;
	return 1;
}
vector<int> S;
int main()
{
  	//freopen(".in","r",stdin);
  	//freopen(".out","w",stdout);
  	n=read(),k=read();
  	memset(times,-1,sizeof(times));
  	for(rg int st=0;st<(1<<n);++st)
  		{
  			if(judge(st) && totused(st)<=k)
  				S.push_back(st);
		}
	int tot=S.size();
	if(n==1)
		{
			cout<<(k>=2?0:1);
			return 0;
		}
	for(int i=0;i<tot;++i)
		{
			int t=totused(S[i]);
			f[S[i]][1][t]++;
		}
	ll ans=0;
	for(int r=2;r<=n;++r)
		{
			for(int i=0;i<tot;++i)
				{
					int t=totused(S[i]);
					for(int j=0;j<tot;++j)
						{
							int st=S[i];
							int lst=S[j];
							if(!check(st,lst))
								continue;
							for(int orgt=0;orgt+t<=k;++orgt)
								{
									f[st][r][t+orgt]+=f[lst][r-1][orgt];
									if(r==n && t+orgt==k)
										ans+=f[lst][r-1][orgt];
								}
						}
				}
		}
	cout<<ans;
	return 0;
}

```

---

## 作者：Tgotp (赞：1)

九宫格的话，只要跟上一行对比就好了，用了滚动数组优化，状压dp显而易见，具体看代码注释咯。



```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
using namespace std;
const int N = 10;
int n,m,e,now,t[1<<N][2];
long long num,dp[1<<9][2][N*N/2];
inline bool check(int z) //寻找数组
{
    if(z & (z<<1))return false;
    else return true;
}
inline bool CHECK(int x,int y) //判断是否能行
{
    if((t[x][0] & t[y][0]) || (t[x][0] & (t[y][0]<<1)) || ((t[x][0]<<1) & t[y][0])) return false;
    else return true;
}
inline int found(int z) //寻找此行放置的数量
{
    int ans=0;
    while(z)
    {
        if(z & 1)ans++;
        z=z>>1;
    }
    return ans;
}
int main()
{
    cin>>n>>m;
    for(int i=0;i<(1<<n);i++)
        if(check(i))t[e][0]=i,t[e++][1]=found(i);   
    for(int i=0;i<e;i++)
        if(t[i][1]<=m) dp[i][1][t[i][1]]=1;           //预处理
    for(int i=2;i<=n;i++)
    {
        for(int j=0;j<e;j++)
        {
            memset(dp[j][now],0,sizeof(dp[j][now]));
            for(int x=0;x<=m;x++)
                for(int k=0;k<e;k++) if(CHECK(j,k) && dp[k][now^1][x])              //dp过程。
                    dp[j][now][x+t[j][1]]+=dp[k][now^1][x];
        } 
        now=now^1; 
    }
    for(int i=0;i<e;i++) num+=dp[i][now^1][m];
    cout<<num;
    return 0;
}
```

---

## 作者：magolor (赞：1)

状态压缩DP，直接暴力TLE，加一个剪枝优化：

如果k > ((N>>1)+(N%2))\*(((N-p+1)>>1)+((N-p+1)%2))

（即从矩形左上角开始紧挨着塞满都塞不下，就返回就好）

这样一个剪枝非常强劲，直接从TLE到32Ms。


(当然，数据范围小，也可以打表)





```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 4096
#define ll long long 
#define gc() getchar()
inline int read(int ans = 0, int sgn = ' ', int ch = gc())
{
    for(;ch < '0' || ch > '9'; sgn=ch,ch=gc());
    for(;ch >='0' && ch <='9'; (ans*=10)+=ch-'0',ch=gc());
    return sgn-'-' ? ans : -ans;
}
ll f[15][105][MAXN+5];
int N, K, End_Situation;
inline int Count(int S, int ans = 0)
{
    for(register int i = 0; i < N; i++)
        ans += ((S>>i)&1);
    return ans;
}
inline ll Robot(int p, int k, int S_dash, ll ans = 0)
{
    if(k > ((N>>1)+(N%2))*(((N-p+1)>>1)+((N-p+1)%2)) || k < 0)
        return 0;
    if(p > N)
        return !k;
    if(f[p][k][S_dash])
        return f[p][k][S_dash];
    for(register int S = 0; S <= End_Situation; S++)
    {
        if((S&(S<<1)) || (S&S_dash) || (S&(S_dash<<1)) || (S&(S_dash>>1)))
            continue;
        ans += Robot(p+1,k-Count(S),S);
    }
    return f[p][k][S_dash] = ans;
}
int main()
{
    N = read(), K = read(), End_Situation = ~-(1<<N), printf("%lld\n",Robot(1,K,0));
    return 0;
}
```

---

## 作者：fl_334 (赞：1)

hhhh，what a good big 状态亚瑟题


```cpp
#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#define ll long long
using namespace std;
const int MAXN = 2000;
const int MAXK = 1100;
ll f[2][MAXN][MAXK],Ans;
int N,K;
int s[MAXN],num[MAXN];
int Next[MAXN*10],h[MAXN*10],st[MAXN],flag;
inline int getNum(int x){
    int t = 0;
    while (x>0){
        x = x&(x-1);//每执行一次将最右边的1置为0
        t++;
    }
    return t;
}
void DFS(int len,int now){
    if (len == N){
        ++s[0];
        s[s[0]] = now;
        num[s[0]] = getNum(now);
        return;
    }
    DFS(len+1,now << 1);//不放猛兽,最右位放置0
    if((now & 1) != 1){//当前最右为为0时可放置猛兽
        DFS(len+1,(now << 1)|1);//右移一位并把最后一位变成1
    }
}
void add(int one,int two){
    Next[++flag] = st[one];
    h[flag] = two;
    st[one] = flag;
}
vector < vector <int> > G;
void init(){
    cin >> N >> K;
    s[0] = 0;
    //枚举出总状态数
    for (int i = 0; i < (1 << N); ++i) {
        if(i & (i << 1))
            continue;
        s[0]++;
        int t = i;
        num[s[0]] = 0;
        while (t){
            num[s[0]] += (t&1);
            t = t >> 1;
        }
        s[s[0]] = i;
    }
    int s1,s2;
    G.clear();
    G.resize(MAXN*10);
    for (int j = 1; j <= s[0]; ++j) {
        for (int i = j+1; i <= s[0]; ++i) {//为什么不从j开始循环,因为0到0时会push两次1-1,会造成错误哒
            s1 = s[j],s2 = s[i];
            if( ((s2 << 1) & s1) || ((s2 >> 1) & s1) || (s1 & s2) )//判断s1状态与s2状态是否冲突
                continue;
            G[i].push_back(j);//状态号
            G[j].push_back(i);
        }
    }
    G[1].push_back(1);//0到0,也就是说可以连续出现两次第一个状态,也就是两行都不放
}
void DP(){
    f[0][1][0] = 1;//f(i,j,k) 考虑前i行,是第k个状态时,共放了j只猛兽//第一个状态就是0000
    int m = 0,s1;
    for (int i = 1; i <= N; ++i) {
        m ^= 1;
        //初始化数组
        for (int j = 1; j <= s[0]; ++j) {
            for (int k = 0; k <= K; ++k) {
                f[m][j][k] = 0;
            }
        }
        for (int j = 1; j <= s[0]; ++j) {
            for (int k = 0; k <= K; ++k) {
                for (int l = 0; l < G[j].size(); ++l) {
                    s1 = G[j][l];
                    if(k - num[j] >= 0){
                        f[m][j][k] += f[m^1][s1][k-num[j]];
                    }                //冻柜sa
                }
            }
        }
    }
    Ans = 0;
    for (int n = 1; n <= s[0]; ++n) {
        Ans += f[m][n][K];
    }
    cout << Ans << endl;
}
int main() {
    init();
    DP();
    return 0;
}
```

---

## 作者：plazum (赞：1)

（这里相当于给黄学长的这篇题解写个解释……）

[url]http://hzwer.com/1461.html[/url]

状态压缩动规，用一个整型的二进制表示来表示棋盘上一行的情况，放了棋子为1，没放为0；可以先预处理出所有可能的状态；用位运算来判断两种状态能否共存于相邻两行。

另：对于大于(ceil(n/2))^2的K可以直接输出方案数0……

```cpp

#include<iostream>
using namespace std;
int n,K,i,j,k,all,f[9][26][512],cnt[512],p;
bool f1[512],f2[512][512];
long long ans;
void pre()
{
    int t,x;
    for(;i<all;i++)
        if((i&(i>>1))==0){
            for(t=0,x=i;x;x/=2)t+=x&1;
            cnt[i]=t;
            f1[i]=true;
        }
    for(i=0;i<all;i++)if(f1[i])
        for(j=0;j<all;j++)if(f1[j])
            if((i&j)==0&&(i&(j>>1))==0&&(j&(i>>1))==0)
                f2[i][j]=true;
}
int main()
{
    cin>>n>>K;
    if(K>(n+1)/2*(n+1)/2){putchar('0');return 0;}
    all=1<<n;
    pre();
    for(i=0;i<all;i++)f[0][cnt[i]][i]=1;
    for(i=1;i<n;i++)
        for(j=0;j<all;j++)if(f1[j])
            for(k=0;k<all;k++)
                if(f2[j][k])
                    for(p=cnt[j];p+cnt[k]<=K;p++)
                        f[i][p+cnt[k]][k]+=f[i-1][p][j];
    for(i=0,n--;i<all;i++)ans+=f[n][K][i];
    cout<<ans;
    
    return 0;
}

```

---

## 作者：Skywalker_David (赞：1)

先DFS求出第一行可能的排列、 作为边界、

用位运算2^n-1表示在这个位置上是否有国王、

F[I,J,K] I表示行、 J表示当前行的状态、 K表示到这行 这行按J排列 总共有K个国王的可能数、方程就很简单了

```delphi

var n,k,i,j,w,l,temp,t:longint;
    ans:qword;
    d:boolean;
    f:array[0..10,0..512,0..81] of qword;
function min(a,b:longint):longint;
begin   if a<b then exit(a) else exit(b); end;
function hx(k:longint):longint;
begin   exit(1 shl (k-1)) end;
procedure ty(k,y,g:longint);
var i:longint;
begin
        if k<>-1 then f[1,y,g]:=1;
        for i:=k+2 to n do ty(i,y+hx(i),g+1);
end;
function check(x,y:longint):boolean;
var i:longint;
    a,b:array[0..10] of boolean;
begin
        check:=true;
        a[0]:=false; b[0]:=false;
        for i:=1 to n do
        begin
                if (x and 1=1) and (y and 1=1) then exit(false);
                if x and 1=1 then
                begin
                        inc(t);
                        a[i]:=true;
                end else a[i]:=false;
                if y and 1=1 then
                begin
                        inc(temp);
                        b[i]:=true;
                end else b[i]:=false;
                if (a[i] and b[i-1]) or (b[i] and a[i-1]) then exit(false);
                if (a[i] and a[i-1]) or (b[i] and b[i-1]) then exit(false);
                x:=x shr 1; y:=y shr 1;
        end;
end;
begin
        readln(n,k);
        ty(-1,0,0);
        for i:=2 to n do
        for j:=0 to hx(n+1)-1 do
        for w:=0 to hx(n+1)-1 do
        begin
                t:=0;
                temp:=0;
                d:=check(j,w);
                if d then
                      for l:=temp to min((i-1)*n-t,k-t) do
                      f[i,j,l+t]:=f[i,j,l+t]+f[i-1,w,l];
        end;
        for i:=1 to n do
        for j:=0 to hx(n+1)-1 do
                inc(ans,f[i,j,k]);
        writeln(ans);
end.

```

---

## 作者：littleseven (赞：1)


## 题解：

**状压DP**

首先解释为什么是状压DP：

- 根据题意我们能够得出是通过DP解决
- 根据题中数据范围$1 \le N \le 9$

其次，我们要考虑DP的几个属性：

- 状态：

  1. 我们定义$f[i][j][s]$为当前考虑前$i$行，第$i$行的国王的情况是编号为$j$的状态（压缩），在这$i$行共有$s$个国王的情况的总数。
  2. $sit[]$和$gs[]$分别表示某一点的状态和此状态下这一行放的国王数量。这里需要有dfs预处理。

  ```cpp
  void dfs(int sum, int tot, int now)
  {
  	if (now >= n)
  	{
  		sit[ ++ cnt] = sum;
  		gs[cnt] = tot;
  		return ;
  	}
  	dfs(sum, tot, now + 1);
  	dfs(sum + (1 << now), tot + 1, now + 2);
  }
  ```

- 转移：

  1. 同一行国王的冲突：我们可以直接在预处理时候解决。
  2. 上下国王的冲突：`if (sit[j] & sit[k]) continue ;​`
  3. 左上方和右下方国王的冲突：`if((sit[j] << 1) & sit[k]) continue ;`
  4. 左下方和右上方国王的冲突：`if (sit[j] & (sit[k] << 1)) continue ;`
  5. 最终的转移过程按照直接处理每一行即可。

  ```cpp
  for (int i = 2; i <= n; i ++ )
  {
  	for (int j = 1; j <= cnt; j ++ )
  	{
  		for (int k = 1; k <= cnt; k ++ )
  		{
  			if (sit[j] & sit[k])
  				continue ;
  			if ((sit[j] << 1) & sit[k])
  				continue ;
  			if (sit[j] & (sit[k] << 1))
  				continue ;
  			for (int l = gs[j]; l <= m; l ++ )
  				f[i][j][l] += f[i - 1][k][l - gs[j]];
  		}
  	}
  }
  ```

## AC代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 10;

const int M = 110;

const int NM = 2020;

int n, m, sit[NM], gs[NM], cnt;
long long f[N][NM][M];
void dfs(int sum, int tot, int now)
{
	if (now >= n)
	{
		sit[ ++ cnt] = sum;
		gs[cnt] = tot;
		return ;
	}
	dfs(sum, tot, now + 1);
	dfs(sum + (1 << now), tot + 1, now + 2);
}
int main()
{
	scanf("%d%d", &n, &m);
	dfs(0, 0, 0);
	for (int i = 1; i <= cnt; i ++ )
	{
		f[1][i][gs[i]] = 1;
	}
	for (int i = 2; i <= n; i ++ )
	{
		for (int j = 1; j <= cnt; j ++ )
		{
			for (int k = 1; k <= cnt; k ++ )
			{
				if (sit[j] & sit[k])
					continue ;
				if ((sit[j] << 1) & sit[k])
					continue ;
				if (sit[j] & (sit[k] << 1))
					continue ;
				for (int l = gs[j]; l <= m; l ++ )
					f[i][j][l] += f[i - 1][k][l - gs[j]];
			}
		}
	}
	long long ans = 0;
	//printf("%d\n", cnt);
	for (int i = 1; i <= cnt; i ++ )
		ans += f[n][i][m];
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：jackyzhu (赞：1)

处理框架跟1897玉米地一模一样，状压dp

定义f[i][j][k]表示前i行放j个国王，并且第i行的状态为k的放法数

第一行预处理一下：

```cpp
for(int j=0;j<=k;j++)
        for(int r=0;r<mm;r++)
            if(g[r]&&cal(r)==j)
                f[1][j][r]=1;
```
这里cal(r)用于计算r的二进制表示有多少个1
第i行可以放状态j用g[i]来判断：（左边右边没有国王）

g[i]=(!(i<<1 & i) && !(i>>1 & i) );

第i行（状态为k）与第i-1行(状态为s)不冲突判断为：


!(s&r)&&!((s<<1)&r)&&!((s>>1)&r)

dp公式：(前i行放j个，第i行放了cal(r)个,因此前i-1行放j-cal(r)个)

0<=s<(1<<n)

f[i][j][r]+=f[i-1][j-cal(r)][s];

最后注意一点：

f[i][j][k]用long，用int只能70分

AC代码：

    

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
long f[10][82][1<<9];
//int h[10][1<<9];//个数
int g[1<<9];
long ans;
int cal(int i)
{
    int num=0;
    while(i)
    {
        num++;
        i=i&(i-1);
    }
    return num;
}
int main()
{
    scanf("%d%d",&n,&k);
    int mm=1<<n;
    for(int i=0;i<mm;i++)
    {
        g[i]=(!(i<<1 & i) && !(i>>1 & i) );
        //f[0][0][i]=1;
    }
    //f[0][0]=1;
    for(int j=0;j<=k;j++)
        for(int r=0;r<mm;r++)
            if(g[r]&&cal(r)==j)
                f[1][j][r]=1;    
    int t;
    for(int i=2;i<=n;i++)
        for(int j=0;j<=k;j++)
            for(int r=0;r<mm;r++)
            {
                if(g[r])
                {
                    t=cal(r);
                    for(int s=0;s<mm;s++)
                        {
                            if(!(s&r)&&!((s<<1)&r)&&!((s>>1)&r)&&j>=t)
                                f[i][j][r]+=f[i-1][j-t][s];
                        }
                }
            }
    for(int i=0;i<mm;i++)
        ans+=f[n][k][i];
    printf("%ld",ans);
}

```

---

## 作者：梅川丘库 (赞：1)

最近在狂刷状压！！

此题1A过，感觉很棒！！

这题以前模拟考过，当时觉得挺难的，现在一看就容易多了....

有个省时间的东西叫预处理！！

因为每次都去枚举状态,,,虽然不多...但是当不能被状压的那一维较大时，时间就有差异了,,,,不要小瞧这点时间,再说写个预处理和按照状态来枚举代码量差不多呢

这是洒家的代码，各位看官多多指点

```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;
bool judge(int x)
{
    return ((x & (x<<1)) || (x & (x>>1)));
}
long long dp[10][85][101];
//表示前i行总共放了j个国王，且当前行的状态为k 
int can[101];
int many[101];
int main()
{
    int full;
    int n,K; 
    scanf("%d%d",&n,&K);
    full=(1<<n)-1;
    int cnt=0;
    for(int i=0;i<=full;i++)
    {
        if(judge(i)) continue;
        can[++cnt]=i;
    }
    int x;
    int sum=0;
    for(int i=1;i<=cnt;i++)
    {
        x=can[i];
        while(x>0)
        {
            sum++;
            x=x-(x & (-x));
        }
        many[i]=sum;
        sum=0;
```
}//记录每种状态的国王个数
```cpp
    int last,lastmany;
    int now,nowmany;
    for(int i=1;i<=cnt;i++) dp[1][many[i]][i]=1;
    for(int i=2;i<=n;i++)
    {
        for(int j=1;j<=cnt;j++)
        {
            last=can[j];
            for(int k=1;k<=cnt;k++)
            {
                now=can[k];
                if((now & last) || ((now>>1) & last) || ((now<<1) & last))  continue;
                nowmany=many[k];
                for(int l=nowmany;l<=K;l++)
                {
                    dp[i][l][k]+=dp[i-1][l-nowmany][j];
                }
            }
        }
    }
    long long maxn=0ll;
    for(int i=1;i<=cnt;i++) maxn+=dp[n][K][i];
    printf("%lld",maxn);    
    return 0;
}
```

---

## 作者：ylsoi (赞：1)

一道入门的状态压缩DP，难在如何确定放满k个国王，我们可以给DP再添加一个维度，即为当前状态下总共放置的国王数目，最后统计每个状态下国王放置数目为k个的就可以了

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
const int maxn=15;
int n,k,f[400],sum[400],dp[maxn][400][100],cnt,ans;
bool check(int i)
{
    if(i & (i << 1))return false;
    return true;
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=0;i<(1<<n);i++)
    if(check(i))
    {
        cnt++;
        f[cnt]=i;
        int t=i;
        while(t)
        {
            sum[cnt]+=t%2;
            t/=2;
        }
    }
    for(int i=1;i<=cnt;i++)
    {
        if(sum[i]>k)continue;
        dp[1][i][sum[i]]=1;
    }
    for(int i=2;i<=n;i++)
    {
        for(int j=1;j<=cnt;j++)
        {
            for(int l=1;l<=cnt;l++)
            {
                if(f[l] & f[j])continue;
                if(f[l] & (f[j]<<1))continue;
                if((f[l]<<1) & f[j])continue;
                for(int t=1;t<=k;t++)
                {
                    if(sum[j]+t>k)continue;
                    dp[i][j][sum[j]+t]+=dp[i-1][l][t];
                }
            }
        }
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=cnt;j++)
            ans+=dp[i][j][k];
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：MSM2004 (赞：0)

看到这道题的第一眼，我就想到了著名的八皇后问题，当时是用搜索做的。但是
********************but********************
八皇后只有八个位置可以用来放置，本问题却最多达9*9，所以用搜索复杂度可能高了些。
于是我们想到了状压动归。
    因为每行可以放置多个国王，我们用状压的思想，把每行的状态压缩成一个数来表示，这是很多与棋盘有关题目的处理方法，二进制1表示放置了一个国王，二进制0表示空位。先不考虑上下行的攻击情况，对于每一行来说，我们可以预处理出所有可行的状态记录所有的可行状态。
```
void yu()//预处理
{
	int all=(1<<m)-1;//一行中所有可能的情况
	for(int i=0;i<=all;i++)
	{
		if(!(i&(i<<1)))//如果不和左右冲突
		{
			s[++cnt]=i;//记录状态
			int x=i;
			while(x) x-=lowbit(x),sum[cnt]++;//记录每种情况所需国王数
		}
	}
}//lowbit(x)是x的二进制表达式中最低位的1所对应的值
```
动态规划解题：
    按行划分阶段；
    建立状态dp[i][j][k],表示的意义是前i行中，第i行状态为s[j]（j属于[1,cnt]时，前i行一共放置了k个国王的方案数，状态转移方程为：
    dp[i][j][k]=sigma(d[i-1][p][k-sum[j]]）
枚举第i-1行的可行状态s[p],当s[p]与s[j]不互相攻击时，满足上面的状态转移方程，很显然要求k>=sum[j]。
     最后的所求为sigma(dp[m][i][k]),i属于[1,cnt],dp[0][1][0]初始化为1。
```
bool Is_safe(int shang,int xia) 
{
	if( (shang&xia) || ((shang>>1)&xia) || ((shang<<1)&xia) ) return false;
	//  相邻的上方       相邻的左上方        相邻的右上方 
	return true;
}
 
void DP()
{
	dp[0][1][0]=1;//初始化 
	for(int i=1; i<=N; i++)//枚举行，按行划分阶段 
		for(int j=1; j<=cnt; j++)//枚举可行的行状态 
			for(int k=0; k<=K; k++)//枚举国王
			{
				if(sum[j]>k) continue;//前面的i-1行无国王可放 
				for(int p=1; p<=cnt; p++)
					if(Is_safe(s[p],s[j]))
						dp[i][j][k]+=dp[i-1][p][k-sum[j]];
			}
	return;
}
 
```


---


# 邦邦的大合唱站队

## 题目背景

BanG Dream!里的所有偶像乐队要一起大合唱，不过在排队上出了一些问题。


## 题目描述

N个偶像排成一列，他们来自M个不同的乐队。每个团队至少有一个偶像。

现在要求重新安排队列，使来自同一乐队的偶像连续的站在一起。重新安排的办法是，让若干偶像出列（剩下的偶像不动），然后让出列的偶像一个个归队到原来的空位，归队的位置任意。

请问最少让多少偶像出列？


## 说明/提示

【样例解释】

```cpp
1  3   √
3  3
2  3   √
4  4
2  4   √
1  2   √
2  2
3  2   √
1  1
1  1
3  1   √
4  1   √
```
【数据规模】

对于20%的数据，$N\le 20, M=2$

对于40%的数据，$N\le 100, M\le 4$

对于70%的数据，$N\le 2000, M\le 10$

对于全部数据，$1\le N\le 10^5, M\le 20$


## 样例 #1

### 输入

```
12 4
1
3
2
4
2
1
2
3
1
1
3
4```

### 输出

```
7```

# 题解

## 作者：kkksc03 (赞：192)

70分做法：枚举每个学校顺序，暴力。

100分：状压dp。从队列头到尾DP，

状态：f[i]表示i状态下最小的出列（不一致）的个数。

比如f[1101]表示从头到位为1/3/4乐队的偶像的最小出列个数。

$ f[i]=min(f[i\ xor\ 2^j]+num[j]-(sum[length][j]-sum[length-num[j]][j]));$

j表示团队编号，sum表示某种团队的前缀和，length表示到此已经排到的长度。


---

## 作者：天泽龟 (赞：109)

### ~~题解开始前请允许我高呼一声：BangDream天下第一！~~

BangDream国服开始公测啦，有没有小伙伴一起来玩啊OwO~

---

回归正题。

首先注意到这是一道偶像多达五个数量级的~~LIVE~~题目，要么贪心要么DP，又注意到虽然N很大，但总乐队数仅有20，可考虑对其状压。
 
我们可以设状态S为当前已经排列好的乐队编号集合，那么先不管这几个乐队怎么排列，她们的人数总和是一定的（不妨设其为$l[S]$），那她们从第一个位子站起，所占有的区间一定是$[~1~,~l[S]~]$。
 
那我们枚举站在最后一个位置的乐队（不妨设人数为$num[i]$），就同样可以确定它所对应的区间是$[~l[S]-num[i]+1~,~l[S]~]$，那么原先在这个范围内的，该乐队的偶像不用出列，其他人全部出列就可以了。
 
其中，$num[i],l[S]$，还有$s[i][j]$表示初始状态下前i个位子中编号为j的乐队的人数，这三个信息都可以由初始化得到。

于是便得到了最终的转移方程，设$f[S]$ 为状态S时所出列的最小人数，那么对于$\forall j\in S$，满足
$$f[S]=min(f[~S~xor~(1<<j)~]+num[j]-s[r][j]+s[l][j]$$

其中$l,r$表示上文提到的最后一个乐队所对应的区间。

然后就可以愉快的AC辣，上丑陋的代码：
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int n,m,x,f[2000000];
//首先枚举人肯定傻逼TLE，数据范围只能用状压
//设f[i]--> 状态I表示从左往右被标记的乐队已排好；
//f[i]表示状压为I时所出列最少人数。 
int s[100010][30],num[30],sm[2000000]; 

bool d(int s,int x){
	return (s&(1<<(x-1)));
}

void dfs(int x,int s,bool b)
{
	if (x==m) return;
	if (b) sm[s|(1<<x)]=sm[s]+num[x+1],dfs(x+1,s|(1<<x),1),dfs(x+1,s|(1<<x),0);
	else dfs(x+1,s,1),dfs(x+1,s,0);	
}

int main()
{
	cin>>n>>m;
	for (int i=1;i<=n;i++) {
		cin>>x; 
		for (int j=1;j<=m;j++) s[i][j]=s[i-1][j];
		s[i][x]++; num[x]++;
	}
	dfs(0,0,0); dfs(0,0,1);
	memset(f,0x3f,sizeof(f)); f[0]=0;
	for (int i=1;i<(1<<m);i++)
	{
		for (int j=1;j<=m;j++) if (d(i,j)) {
			int l=sm[i^(1<<j-1)],r=sm[i];
			f[i]=min(f[i],f[i^(1<<(j-1))]+(r-l)-(s[r][j]-s[l][j]));
		}	
	}
	cout<<f[(1<<m)-1]<<endl;
	return 0;
}
```

---

## 作者：hzoi_liuchang (赞：47)

## 分析
首先要注意合唱队排好队之后不一定是按$1.2.3......m$的顺序的

$N$的范围很大，但$m$的数据比较小，所以我们考虑状压DP

我们设$f[i]$为状态为$i$的合唱队已经安排好位置的最小花费

接下来就是状态转移方程的问题
``` cpp
for(int i=1;i<(1<<m);i++){
        int len=0;
        for(int j=1;j<=m;j++){
            if(i&(1<<(j-1))) len+=num[j];
        }
        for(int j=1;j<=m;j++){
            if(i&(1<<(j-1))) f[i]=min(f[i],f[i^(1<<(j-1))]+num[j]-sum[len][j]+sum[len-num[j]][j]);
        }
    }
```
第一维枚举的是状态，在枚举状态之后，我们还要统计当前状态下哪些合唱队已经排好了位置

我们用一个变量$len$记录排好队的总人数，如果当前合唱队已经排好了队，那么我们把总人数加上当前合唱队的人数

其中，编号为$j$的合唱队的总人数$num[j]$可以预处理

为什么这样做呢？

因为我们无论让偶像们怎么出队，他们最终的状态是确定的，肯定是一个合唱队的偶像站到一起，因此我们就可以统计排好队后当前区间的总长度

接下来就是状态转移

如果编号为$j$的合唱队在我们决策的范围之内，那我们就需要尝试将编号为$j$的合唱队的全体成员都放在队伍最后

那么此时我们就需要将编号为$j$的合唱队中不在区间$[len-num[j]+1,num[j]]$的偶像移到该区间

此时的花费为$num[j]-sum[len][j]+sum[len-num[j]][j]$

其中$sum[i][j]$表示开始时前$i$个位置中编号为$j$的合唱队员的个数

问题就可以解决了
## 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=22,maxm=1e5+5;
int f[1<<maxn];
int num[maxn],sum[maxm][maxn];
int main(){
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        int aa;
        scanf("%d",&aa);
        num[aa]++;
        for(int j=1;j<=m;j++) sum[i][j]=sum[i-1][j];
        sum[i][aa]++;
    }
    memset(f,0x3f,sizeof(f));
    f[0]=0;
    for(int i=1;i<(1<<m);i++){
        int len=0;
        for(int j=1;j<=m;j++){
            if(i&(1<<(j-1))) len+=num[j];
        }
        for(int j=1;j<=m;j++){
            if(i&(1<<(j-1))) f[i]=min(f[i],f[i^(1<<(j-1))]+num[j]-sum[len][j]+sum[len-num[j]][j]);
        }
    }
    printf("%d\n",f[(1<< m)-1]);
    return 0;
}
```

---

## 作者：Atream (赞：41)

这道题刚开始看的时候找不到下手去做的地方

其实这种最优方案的问题无非就是三种做法

要么暴力dfs
要么找性质贪心
要么就是dp

dfs暴力肯定不行，贪心可以吗？在找了很久性质后我没有发现什么有用的性质

那就只能dp了，考虑如何去表示一个状态使得这个状态下的答案之和这个状态有关，这实际上是大部分动态规划算法最基本也是最核心的部分

很容易就会想到一个状态，记录下每个位置的人有没有出去

很遗憾这样去做的话不同的状态有2^n，是我们不能承受的，那有没有什么办法可以压缩这个状态呢？观察到每个人是否出队是和他所在的队伍最终被我们摆放的位置有关，然后我们就很轻松的把每个人的状态压缩到了每个队伍最终的位置上

继续观察，对于最终两个相邻的队伍来说，那么他们的相对位置关系谁在前谁在后对之后的状态都是没有影响的，毕竟之后的队伍只能接在他们后面或者前面，这样就把两个相邻的队伍对之后状态的影响压缩到了一个队伍中

那能不能把所有已经拍好的队伍压缩到一起呢？答案是可以的，只要让他们都相邻就可以了，怎么让他们都相邻呢？把他们全部放到最前面就行了，这样一来一个状态对之后状态的影响就只有和哪些队伍已经排好了有关

记录二进制状态f【i】，i从后向前数第j位的01字符表示第j个队伍有没有排号（这里的排号指的是这个队伍所有人都在一起且所有排号的队伍都在最前面）状态下最少的出队人数

我们就可以很轻松的从一个状态的答案推出最其他状态的答案，从而推出把所有队伍的人都整合在一起并放到前n个位置的最少出对人数

对于一个状态i，枚举没有拍好的队伍j，将j接在所有排号的队伍后面，设为位置l-r，需要出队的就是所有在原序列中不在这个区间且属于j队伍的人

维护前缀和统计一下就好

```
//代码借鉴了其他题解
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
int f[(1<<20)+100],n,m,sum[100100][25];
int main()
{
	std::ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{	int x;
		cin>>x;
		for(int j=1;j<=m;j++)
			sum[i][j]=sum[i-1][j];
		sum[i][x]++;
	}
	int end=(1<<m)-1;
	f[0]=0;
	for(int i=1;i<=end;i++)
		f[i]=1000000000;
	for(int i=0;i<=end;i++)
	{	int finish=0;
		for(int j=0;j<m;j++)
			if((i>>j)&1)
				finish+=sum[n][j+1];
		for(int j=0;j<m;j++)
		{	if((i>>j)&1)
				continue;
			int l=finish,r=l+sum[n][j+1];
			f[i|(1<<j)]=min(f[i|(1<<j)],f[i]+r-l-(sum[r][j+1]-sum[l][j+1]));
		}
	}
	cout<<f[end]<<endl;
	return 0;
}
```


---

## 作者：jins3599 (赞：26)

设计状态$f_i$代表，状态为$i$的已完成队列，需要出队的最少人数。

举个例子，若$f_i=011$，代表团队一和二站满了前排。

然后我们枚举每一个情况$i$，对应的枚举所有的在$i$中的$j$（上面例子的话，$j=1,2$）：

$$f[i]=min\{f[i\ xor \ 2^j]+num[j] -lenth[x,y][j]\}$$

$num[j]$代表团队$j$的总人数，$lenth[x,y]$代表在区间$[x,y]$中团队$j$的总人数。

显然$[x,y]$应该是接在状态$i\ xor\ 2^j$后$num[j]$的那一段区间。

转移一下就好了，复杂度$O(m2^m)$。

$Code:$

```cpp
#include <bits/stdc++.h>

const int M = 21;
const int N = 1e5 + 10;

int n , m;
int a[N];
int num[M];
int sum[N][M];
int f[(1 << M)];

int main () {
//	freopen("data.txt" , "r" , stdin);
//	freopen("ans2.out" , "w" , stdout);
	scanf("%d %d" , &n , &m);
	for(int i = 1 ;i <= n ; ++ i) scanf("%d" , a + i);
	for(int i = 1 ; i <= n; ++ i) {
		num[a[i]] ++;
		for(int j = 1 ; j <= m ; ++ j) sum[i][j] = sum[i - 1][j];
		sum[i][a[i]] ++;
	}
	memset(f , 0x3f , sizeof(f)); f[0] = 0;
	for(int i = 1 ; i < (1 << m) ; i ++) {
		int lenth = 0;
		for(int j = 1 ; j <= m ; ++ j) if(i & (1 << (j - 1))) lenth += num[j];
		for(int j = 1 ; j <= m ; ++ j) {
			if(i & (1 << (j - 1))) {
				f[i] = std::min(f[i] , 
				f[i ^ (1 << (j - 1))] + num[j] - sum[lenth][j] + sum[lenth - num[j]][j]);
			}
		}		
	}
	printf("%d\n" , f[(1 << m) - 1]);
	return 0;
}

```

---

## 作者：Clouder (赞：18)

本文亦发表于[笔者博客](https://www.codein.icu/lp3694/)。

## 题意

[题目传送门](https://www.luogu.com.cn/problem/P3694)

$N$ 个人，分别属于 $M$ 个组，要求同组的人站在一起。    
每个人可以出队，出队后留出空位，出队后的人可以在任意空位归队。  
求最少出队人数。  

## 解法

看到 $M$ 的数据范围极小，猜测可能是状压DP。  
但没有想出来到底是如何状压，于是重新思考。   

### 全排列

可以发现，最后同组的人站在一起，一定会形成组的顺序，例如：  

>111111,222222,333333  
>222222,111111,333333  
>333333,111111,222222  
>....

类似如此，那么可以全排列枚举组的顺序。  
而确定组的顺序后，每个组的范围就确定下来了。    
而对于每个人，如果他的位置恰好属于他组的范围，他便不用出队，否则他一定要出队。    
依次检验，取最小值，即可得到答案。   
复杂度为 $O(NM!)$，只能通过四个点。  

考虑进行优化，可以发现这个 $O(N)$ 能够用预处理前缀和的方式去掉。    
维护 $s_{i,j}$ 代表前 $i$ 人中属于 $j$ 组的人数，即可用 $O(1)$ 的时间计算出一组的范围内应有多少人出队。  
复杂度降低到 $O(M!)$，可以通过七个点。  

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
template<typename T>void read(T &r){static char c;r=0;for(c=getchar();c>'9'||c<'0';c=getchar());for(;c>='0'&&c<='9';r=(r<<1)+(r<<3)+(c^48),c=getchar());}
const int maxn = 1e5 + 10;
const int maxm = 21;
int n,m;
int a[maxn];
int num[maxm];
int order[maxm];
int s[maxn][maxm];
int main()
{
    read(n);
    read(m);
    for(int i = 1;i<=n;++i)
        read(a[i]),num[a[i]]++,s[i][a[i]]++;
    for(int i = 1;i<=n;++i)
        for(int j = 1;j<=m;++j)
            s[i][j] += s[i-1][j];
    for(int i = 1;i<=m;++i)
        order[i] = i;
    int ans = 1 << 30;
    do
    {
        int res = 0;
        int l = 0,r = 0;
        for(int i = 1;i<=m;++i)
        {
            l = r + 1;
            r = l + num[order[i]] - 1;
            res += num[i] - (s[r][order[i]] - s[l-1][order[i]]);
        }
        ans = min(ans,res);
    } while (next_permutation(order + 1, order + 1 + m));
    printf("%d",ans);
    return 0;
}
```

### 状压DP

想要将 $O(M!)$ 的复杂度降低到 $O(2^M)$，使用状压DP的方法。  
有数据范围的提示，很容易定义出状态：  
状态 $S$ 每位代表该组是否已处理完成。  
如何转移呢？可以枚举排在最后的组。    
计算出当前队列的长度，枚举排在最后的组，已知排在最后组的长度，即可确定排在最后组的范围。    
确定组范围后，即可计算出该范围内应有多少人出队。  
枚举当前状态每个可能的最后组，取最小值进行转移。  

```cpp
dp[status] = min(dp[status],dp[status ^ (1<<(i-1))] + num[i] - (s[r][i] - s[l-1][i]));
```

实质上，这个状压DP也是在枚举顺序。  
不同于全排列，状压转移时并不知道子状态中的顺序，只知道子状态已完成的组，而将当前组加在子状态队列最后。  
或许借此剪去了部分无用的枚举。  

笔者使用了记忆化搜索的写法，预处理了每个状态的队列长度。  

```cpp
#include <cstdio>
#include <cstring>
using namespace std;
template<typename T>
inline T min(const T &a,const T &b){return a<b?a:b;}
template<typename T>
void read(T &r){static char c;r=0;for(c=getchar();c>'9'||c<'0';c=getchar());for(;c>='0'&&c<='9';r=(r<<1)+(r<<3)+(c^48),c=getchar());}
const int maxn = 1e5 + 10;
const int maxm = 21;
int n,m;
int a[maxn];
int num[maxm];
int s[maxn][maxm];
int len[1<<maxm];
int dp[1<<maxm];
int dfs(int status)
{
    if(dp[status] != 1<<30)
        return dp[status];
    for (int i = 1; i <= m; ++i)
        if(status & (1<<(i-1)))
        {
            int l = len[status] - num[i] + 1,r = len[status];
            dp[status] = min(dp[status],dfs(status ^ (1<<(i-1))) + num[i] - (s[r][i] - s[l-1][i]));
        }
    return dp[status];
}
int main()
{
    read(n);
    read(m);
    for(int i = 1;i<=n;++i)
        read(a[i]),num[a[i]]++,s[i][a[i]]++;
    for(int i = 1;i<=n;++i)
        for(int j = 1;j<=m;++j)
            s[i][j] += s[i-1][j];
    int maxs = (1<<m) - 1;
    for(int i = 1;i<=maxs;++i)
        dp[i] = 1<<30;
    for(int i = 1;i<=maxs;++i)
        for(int j = 1;j<=m;++j)
            if(i & (1<<(j-1)))
                len[i] += num[j];
    printf("%d",dfs((1<<m)-1));
    return 0;
}
```

---

## 作者：Seg_Tree (赞：12)

~~这个番好像很好看回头我补一补~~

------------

看到数据范围容易想到是状压dp,也容易想到用dp[i],用i的二进制表示各队伍是否排好,该情况的最小所需出列人数~~然后就不会了~~.

但在这里我们需要明确一下,我们的dp[i]在这题中表示的并不是仅仅把i状态下的队伍排到一块所需的最小出队人数,而是**i状态中要求完成的队伍按一定顺序,自队列最左端到右依次排好所需的最小出队人数.**

如何理解这一点呢?让我们假设一组数据:

2 1 2 2 1 2 1 1

对于这组数据,我们的肉眼当然能轻易地看出只要让第二位和第六位出列,让他们互换位置即可.

但对于我们的程序而言,这里的dp[1]的值应该为3

~~虽然到这儿大部分同学应该没看懂,但只要知道我们的dp[i]不是仅仅把i状态下的队伍排到一块所需的最小人数就行了.~~

接下来我们来看一看这道题所需的变量:

```cpp
int dp[1<<20];
//dp[i]表示i状态下最少所需出队人数
//此处之i状态指i的二进制下为1的队伍以从左到右的一定顺序排的状态
//例如dp[1]指将第一队所有成员排在整个队伍最左端所需最小出队人数 
int sum[21][N];
//sum[j][k]表示第j队于初始队列前k个人中有多少人
int num[21];
//num[j]表示第j队总共有多少人
//以上变量都可通过初始化得到
```
```cpp
int i,j,n,m,in,l,r,SUM;
//l,r表示要把当前新加入队伍排列在l,r区间内
//SUM表示当前已排好队伍总共有多少人 
```
随后我们就可以得出本题的状态转移方程：

$$dp_i=max(dp_{i\;xor(1<<j)}+(r-l)-(sum_{j,r}-sum_{j,l})$$

意思是,我们必须要让这时候我们分配给j队的位置中不是j队的人出列

再拿之前的数据举例子:

2 1 2 2 1 2 1 1

当i=1,我们现在要让1队的人都排到最前面,但此时我们发现前4个位置中有3个人不是1队的,而dp[0]=0,故dp[1]=3.

然而我们发现,此时我们只是把前4个位置空给1队了,1队的人并没有出来,这可怎么办呢?

这并没有什么关系,因为我们发现,此后如果我们以dp[1]为基点继续dp,那些流落在外的1队队员自然也会出列,故没有问题.

那么这样每次都要求这些队伍都排在最左端,会不会漏答案呢?

并不会,因为我们最终的答案也可以看作是所有的队伍都自左边开始排列所需最小出队人数,而它一定也是可以根据上一个i状态下自左边开始排列所需最小出队人数得出的.

附完整代码以及一些注释以及一些需要注意的小点
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 100005
using namespace std;
//我也是看题解的,不过感到许多题解的一些内容不大清晰故来补一片
//所以变量雷同,纯属抄袭。

int read(){
	int in=0;char c=getchar();
	while(c<48 || c>57)c=getchar();
	while(c>47 && c<58)in=in*10+c-48,c=getchar();
	return in;
}
 
int dp[1<<20];
//dp[i]表示i状态下最少所需出队人数
//此处之i状态指i的二进制下为1的队伍以从左到右的一定顺序排的状态
//例如dp[1]指将第一队所有成员排在整个队伍最左端所需最小出队人数 
int sum[21][N];
//sum[j][k]表示第j队于初始队列前k个人中有多少人
int num[21];
//num[j]表示第j队总共有多少人
 
int main(){
	memset(dp,63,sizeof(dp));
	dp[0]=0;
	int i,j,n,m,in,l,r,SUM;
	//l,r表示要把当前新加入队伍排列在l,r区间内
	//SUM表示当前已拍好队伍总共有多少人 
	n=read();
	m=read();
	for(i=1; i<=n; i++){
		in=read()-1;
		//由于需要装压,故我们的队伍序号从0开始 
		num[in]++;
		for(j=0; j<m; j++)
			sum[j][i]=sum[j][i-1];
		sum[in][i]++;
	}
	for(i=1; i<(1<<m); i++){
		SUM=0;
		for(j=0; j<m; j++)
			if(i&(1<<j))
				SUM+=num[j];
		for(j=0; j<m; j++){
			if(i&(1<<j)){
				l=SUM-num[j];
				r=SUM;
				dp[i]=min(dp[i],dp[i^(1<<j)]+(r-l)-(sum[j][r]-sum[j][l]));
			}
		}
	}
	cout<<dp[(1<<m)-1];
	return 0;
}
```



---

## 作者：yu__xuan (赞：9)

### 题目

[P3694 邦邦的大合唱站队](https://www.luogu.com.cn/problem/P3694)

### 思路

状压 $dp$。因为乐队数 $m \leq 20$，考虑将现在排好了哪些乐队压为二进制。

如共 $8$ 支乐队已经排好了$1,3$ 和 $4$ 号乐队那么对应的二进制数为 $00001101$。

$s[i]$ 表示已经排好了 $i$ 这些乐队需要多长的位置。

$sum[i][j]$ 表示原来的顺序中前 $i$ 个人中有几个是 $j$ 号乐队的。

$f[i]$ 表示排好了 $i$ 这些乐队最少需要多少人出队。

动态转移方程如下：
```cpp
if (i & (1 << (j - 1))) {
	int l = s[i ^ (1 << j - 1)], r = s[i];
	f[i] = min(f[i], f[i ^ (1 << (j - 1))] + sum[n][j] - sum[r][j] + sum[l][j]);
}
```
含义为，已经排好了 $i$ 这些乐队，$j$ 是其中的一支考虑将 $j$ 放到已经排好的这些乐队的最后那么就可以用排好了 $i \oplus j$ 这些乐队的最优情况 $f[i \oplus (1 << (j - 1))]$ 以及不在 $[s[i \oplus (1 << (j - 1))] + 1, s[i]]$ 这个区间中的 $j$ 号乐队的人数 $sum[n][j] - sum[s[i]][j] + sum[s[i \oplus (1 << j - 1)]][j]$ 来更新 $f[i]$。

### Code
```cpp
#include <cstdio>
#include <cstring>
#include <string>
#include <iostream>
#include <algorithm>
#define inf 2147483647
#define MAXN (1 << 20) + 1

int n, m, sum[100001][21];
int s[MAXN], f[MAXN];

int min(int a, int b) { return a < b ? a : b; }

int main() {
	scanf("%d %d", &n, &m);
	for (int i = 1, x; i <= n; ++i) {
		scanf("%d", &x);
		for (int j = 1; j <= m; ++j) {
			sum[i][j] = sum[i - 1][j];
		}
		++sum[i][x];
	}
	for (int i = 0; i < (1 << m); ++i) {
		int d = i, cnt = 0;
		while(d) {
			++cnt;
			if(d & 1) s[i] += sum[n][cnt];
			d >>= 1;
		}
		f[i] = inf;
	}
	f[0] = 0;
	for (int i = 0; i < (1 << m); ++i) {
		for (int j = 1; j <= m; ++j) {
			if (i & (1 << (j - 1))) {
				int l = s[i ^ (1 << j - 1)], r = s[i];
				f[i] = min(f[i], f[i ^ (1 << (j - 1))] + sum[n][j] - sum[r][j] + sum[l][j]);
			}
		}
	}
	printf("%d\n", f[(1 << m) - 1]);
	return 0;
}
```

---

## 作者：god8888 (赞：9)

### 这是本蒟蒻的第4篇题解
本题思路：

这是一道一眼dp题。

原本以为是背包，看了下数据范围，m<=20，明显状压范围鸭？

然后就可以状压了。

根据m定义f[i]表示状态为i时所需要出列的最小人数。

预处理出每个状态的长度，以及每个团队在不同位置需要出列的人数的前缀和。

然后枚举当前位置的团队的编号进行转移即可。

下面就是各位大佬们最喜欢的代码啦~~~

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
using namespace std;
#define mx (int) 1e5+1
#define mn (int) 21
#define inf 0x3f3f3f
int n,m;
int a[mx],f[1<<mn],len[1<<mn],cnt[mn];
int sum[mx][mn];
int main(){
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++) sum[i][j]=sum[i-1][j];
        scanf("%d",&a[i]);
        sum[i][a[i]]++;
		cnt[a[i]]++;
    }
    int pi=1<<m;
    for(int i=1;i<pi;i++) {
        for(int j=1;j<=m;j++) {
            if(!(i&(1<<j-1))) continue;
            len[i]+=cnt[j];
        }
    }
    for(int i=1;i<pi;i++) {f[i]=inf;}
    for(int i=1;i<pi;i++) {
        for(int j=1;j<=m;j++) {
            if(!(i&(1<<j-1))) continue;
            int k=i^(1<<j-1);
            f[i]=min(f[i],f[k]+cnt[j]-sum[len[i]][j]+sum[len[k]][j]);	
        }
    }
    printf("%d",f[pi-1]);
    return 0;
}
```


有大佬可能会懵逼于“1<<m”，此处发行一道[链接](https://wenda.so.com/q/1374248547065499)......

NICEEEE 第四道题解新鲜出炉。

---

## 作者：Vocanda (赞：6)


## 分析
看到这友好的乐队数范围，很容易就想到了状压dp，但是状态到底找哪个，记录答案的$f$数组开几维都是问题，我们来分析一下:

题目中给出的乐队$M$的范围是$20$，而状态压缩就是从小的范围入手的，所以$f$数组的状态那一维肯定是关于乐队的，再看题目中问的，询问的是要最少拿出来多少人，那么这个状态肯定就是第几个乐队入队的状态，记录的是当前状态下出队人数的最小，那么需不需要第二维呢？

看起来是不需要的，因为我们每次转移都是从上一次当前乐队的人未放入到放入，然后加上当前乐队人数，减去之前的队伍中当前乐队的人数（这个人数用$sum$数组记录前缀和来实现），就是这一次需要拿出来的人数，然后每次转移都取一次$min$，最终状态全为$1$的时候的$f$数组就是答案。状态转移方程如下：
$$ f[i] = min(f[i ^ (1<<(j-1) ] + num[j] - (sum[len][j]-sum[len-num[j]][j]),f[i])$$
其中$num$是第$j$个乐队的人数，$len$是到现在状态的队伍长度，预处理一下就可以。$sum$就是当前乐队在这一段中的人数。
如果一共有$M$个乐队，最终答案就是$f[(1<<M)-1]$
总结一下数组代表的东西：

$f[i]$代表状态为$i$时出队的最小人数,$sum[i][j]$表示前$i$长度里，$j$乐队的人数，$num[j]$代表的就是$j$乐队的总人数。

## 代码
```CPP
#include<bits/stdc++.h>
using namespace std;
const int maxn = 21;
int f[1<<maxn];
int num[maxn];
int a[100005];
int sum[100005][maxn];
int n,m;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;++i){
        cin>>a[i];
    }
    for(int i=1;i<=n;++i){
        num[a[i]]++;//记录每个乐队的总人数
        for(int j=1;j<=m;++j)sum[i][j] = sum[i-1][j];//初始化sum数组
        sum[i][a[i]]++;//求每个乐队人数的前缀和
    }
    memset(f,0x3f,sizeof(f));//初始化最大值
    f[0] = 0;//一个乐队都没有的时候取0人
    for(int i=1;i<(1<<m);++i){
        int len = 0;
        for(int j=1;j<=m;++j)if(i & (1<<(j-1)))len += num[j];//如果当前状态下取了j乐队的人，总人数就加上j乐队的人数
        for(int j=1;j<=m;++j){
            if(i & (1<<(j-1)))//效率优化，当前状态取了他再进行取min，不然取min没有意义
                  f[i] = min(f[i],f[i ^ (1<<(j-1))] + num[j] - sum[len][j]+sum[len - num[j]][j]);//状态转移，取第j个乐队要加上该乐队人数，减去这一段中本来就有的该乐队人数
        }
    }
    int ans = f[(1<<m)-1];
    cout<<ans;
}
```

---

## 作者：GsjzTle (赞：4)

## 题目链接

[点我跳转](https://www.luogu.com.cn/problem/P3694) 

## 题目大意

>$N$ 个人排成一列，每个人都有自己所属的乐队，其中第 $i$ 个人一开始所在的位置为 $i$
>
>你可以从队列中抽出任意数量的人，抽出后他们所在的位置将为空，之后你可以再把他们放进任意空位置
>
>现要求同一个乐队的人必须站在一起，问最少要抽出多少人

## 解题思路

>定义 $cnt[i]$ 表示乐队 $i$ 的总人数 
>
>定义 $dp[i]$ 表示{已处理好该状态所对应的所有乐队}的最少出列个数
>
>对于状态 $110$ (二进制)
>$dp[110]$ 可以由 $dp[100]$ 和 $dp[010]$ 转移得到
>
>而 $dp[100]$ 率先处理好的乐队是 $3$ 
>
>可以认为率先处理好乐队 $3$ 就是把该乐队成员放在 $1$ ~ $cnt[3]$ 的位置上
>
>$dp[010]$ 率先处理好的乐队是 $2$ 
>
>可以认为率先处理好乐队 $2$ 就是把该乐队成员放在 $1$ ~ $cnt[2]$ 的位置上  
>
>那么 $dp[110]$ 就可以由{先处理 $3$ 再处理 $2$} 和 {先处理 $2$ 再处理 $3$} 两种情况取最优得到 
>
>同理 $dp[111]$ 是由乐队 $1$、乐队 $2$、乐队 $3$ 从第一个位置开始任意摆放所得到的最优解 
>
>所以我们无需再考虑摆放顺序 
>
>而将第 $i$ 个乐队成员摆放在 $[L , R]$ 的代价 $=$ 该区间长度 $-$ 该区间第 $i$ 个乐队的人的个数
>
>这步我们可以用前缀和维护  

## AC_Code

```cpp
#include<bits/stdc++.h>

using namespace std;
 
const int N = 1e5 + 10;

int dp[1 << 20];

int cnt[N] , sum[N][21];

int a[N];

int get(int l , int r , int x){
	return (r - l + 1) - (sum[r][x] - sum[l - 1][x]);
}

signed main()
{
	memset(dp , 0x3f3f , sizeof(dp)) , dp[0] = 0;
	
	int n , m;
	
	cin >> n >> m;
	
	for(int i = 1 ; i <= n ; i ++)
	{
		cin >> a[i];
		
		for(int j = 1 ; j <= m ; j ++) sum[i][j] = sum[i - 1][j];
		
		sum[i][a[i]] ++ ;
		
		cnt[a[i]] ++ ;
	}
	
	int up = (1 << m) - 1;
	
	for(int i = 1 ; i <= up ; i ++)
	{
		int R = 0;
		
		for(int j = 0 ; j <= m - 1 ; j ++) if(i >> j & 1) R += cnt[j + 1];
		
		for(int j = 0 ; j <= m - 1 ; j ++) if(i >> j & 1)
		{
			int k = i - (1 << j);
		
			int L = R - cnt[j + 1] + 1;
		
			dp[i] = min(dp[i] , dp[k] + get(L , R , j + 1));
		}
	}
	
	cout << dp[up] << '\n';
	
	return 0;
}
```

---

## 作者：pantw (赞：4)

思路是状压DP。


转移方程：`f[i]=min(f[i],f[i^(1<<j)]+cnt[j]-pre[j][len[i]]+pre[j][len[i]-cnt[j]])`


其中，`f[i]`是状态i的DP值，`cnt[j]`是j乐队的人数，`pre[j][i]`是前i个人中来自j乐队的人数。


然后只需要以下几点，总时间就能卡进500ms了。

1. 如果有宏定义实现的min，改成inline函数。

2. 如果用scanf/cin，改成读优。

3. DP数组开正好`1<<20`。

4. 如果用memset，去掉它并改成写在循环里。

5. 处理当前状态的队列长度的时候，不要for一遍累加，而是直接从之前的状态转移。

6. 使用`// luogu-judger-enable-o2`。


```cpp
#include<cstdio>
#define maxn 100010
#define maxm 20
inline int min(int a, int b) {
    return a < b ? a : b;
}
inline int lowbit(int x) {
    return x & -x;
}
inline int r() {
    char ch = getchar(); int x = 0;
    while(ch < '0' || ch > '9') ch = getchar();
    while(ch >= '0' && ch <= '9') x = 10 * x + ch - '0', ch = getchar();
    return x;
}
int pre[maxm][maxn];
int cnt[maxm];
int f[1048576];
int len[1048576];
//define pre[i][j] as the number of occurences of i in the 0 to j sequence.
//we make sure that n starts from 1, and m starts from 0
int main(){
    int n, m, t;
    n=r(); m=r();
    for(int i=1;i<=n;++i){
        t=r()-1;
        for(int j=0;j<m;++j){
            pre[j][i]=pre[j][i-1];
        }
        ++pre[t][i];
        ++cnt[t];
    }
    for(int j=0;j<m;++j) len[1<<j] = cnt[j];
    int ml=(1<<m);
    f[0]=0;
    for(int i=1;i<ml;++i){
        f[i] = 0x3f3f3f3f;
        len[i] = len[i ^ lowbit(i)] + len[lowbit(i)];
        for(int j=0;j<m;++j){
            if(i&(1<<j)){
                f[i]=min(f[i],f[i^(1<<j)]+cnt[j]-pre[j][len[i]]+pre[j][len[i]-cnt[j]]);
            }
        }
    }
    printf("%d",f[ml-1]);
    return 0;
}
```

---

## 作者：zzozz (赞：3)

状态压缩，dp【i】表示达到i状态出队的最小人数，sum【i】【j】表示前i个人有几个属于j乐队那么枚举一个l，r则有dp[i|(1<<j)]=min(dp[i|(1<<j)],dp[i]+(r-l-(sum[r][j]-sum[l][j])));
代码：





```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
const int oo=1e9;
const int maxn=1e5+5;
const int maxm=21;
using namespace std;
int n,m;
int a[maxn],dp[(1<<maxm)+1],sum[maxn][maxm];
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]); a[i]--;
        for(int j=0;j<m;j++){
            sum[i][j]=sum[i-1][j];
            if(j==a[i]) sum[i][j]++;
        }
    }
    for(int i=0;i<(1<<m);i++) dp[i]=oo; dp[0]=0;
    for(int i=0;i<(1<<m);i++){
        int Sum=0;
        for(int j=0;j<m;j++)
            if((1<<j)&i) Sum+=sum[n][j];
        for(int j=0;j<m;j++){
            if((1<<j)&i) continue;
            int num=sum[n][j];
            int r=Sum+num;
            int l=Sum;
            dp[i|(1<<j)]=min(dp[i|(1<<j)],dp[i]+(r-l-(sum[r][j]-sum[l][j])));
        }
    }
    printf("%d\n",dp[(1<<m)-1]);
    return 0;
}
```

---


# 外太空旅行

## 题目描述

在人类的触角伸向银河系的边缘之际，普通人上太空旅行已经变得稀松平常了。某理科试验班有 $n$ 个人，现在班主任要从中选出尽量多的人去参加一次太空旅行活动。
可是 $n$ 名同学并不是和平相处的。有的人，比如小 A 和小 B 整天狼狈为奸，是好朋友；但还有的人，比如（政治敏感）和（政治敏感）就水火不相容。这 $n$ 名同学，由于是理科生，都非常的理性，所以“朋友的朋友就是朋友”和“敌人的朋友就是敌人”这两句话对这些同学无效。换句话说，有可能小 A 和小 B 是朋友，小 B 和小 C 是朋友，但是小 A 和小 C 两人势如水火。  
任意两个人之间要不就是敌人，要不就是朋友。  
因为在太空船上发生人员斗殴事件是很恶劣也很危险的，因此选出来参加旅行活动的同学必须互相之间都是朋友。你的任务就是确定最多可以选多少人参加旅行。

## 样例 #1

### 输入

```
4
1 2
2 3
3 1
1 4```

### 输出

```
3```

# 题解

## 作者：interestingLSY (赞：12)

这题出的，emmmmmmmmmmm..............

首先介绍一类问题：**最大团问题**

“团”就是指从一个图中选出来一堆点，每对点间都**直接**有边相连。“最大团”就是指包含的点最多的那个团。这题就是个“最大团问题”

但不幸的是，最大团问题是**NPC**的。

目前最快的**正确解法**是状压dp......复杂度为$O(n^22^n)$,这题中 $n=50$ 显然会凉凉

怎么办。。。我们先暴搜一波......

```cpp
int n;
bool gay[MAXN][MAXN];
int gaycnt[MAXN];

bool sel[MAXN];
il bool Cansel( int pos , int upp , int selcnt ){
	if( gaycnt[pos] < selcnt ) return 0;
	For(i,upp)
		if(sel[i]&&!gay[i][pos])
			return 0;
	return 1;
}
int ans = 0;
void Dfs( int pos , int tans , int cnt ){
	if( pos == n+1 ){
		Mymax(ans,tans);
		return;
	}
	if( tans + n-pos+1 <= ans ) return;
	int pmax = tans;
	Forx(i,pos,n)
		pmax += (int)Cansel(i,pos-1,cnt);
	if( pmax <= ans ) return;
	sel[pos] = 0;
	Dfs(pos+1,tans,cnt);
	if( Cansel(pos,pos-1,cnt) ){
		sel[pos] = 1;
		Dfs(pos+1,tans+1,cnt+1);
		sel[pos] = 0;
	}
}
```

好。70分。(楼下dalao各种剪枝90分%%%%%%)

然后。。点开分类标签，"乱搞"?emmmmmmmmm........

打不了表，考虑随机。

随机生成一个数列，并从前往后选。

WTF？AC了！

```cpp
#define MAXN 60

int n;
bool gay[MAXN][MAXN];
int gaycnt[MAXN];
int u[MAXN];
int s[MAXN], top;

int ans = 0;
bool Check( int pos ){
	int v = ::u[pos];
	if( gaycnt[v] < top ) return 0;
	For(i,top){
		if(!gay[s[i]][v])
			return 0;
	}
	return 1;
}

int main(){
	Ms(gay);
	
	scanf("%d",&n);
	int a,b;
	while( scanf("%d%d",&a,&b) != EOF ){
		gay[a][b] = gay[b][a] = 1;
		gaycnt[a]++;
		gaycnt[b]++;
	}
	For(i,n)
		u[i] = i;
	
	srand((ull)new char);
	For(i,100000){
		top = 0;
		random_shuffle(u+1,u+1+n);
		int tans = 0;
		For(i,n){
			if(Check(i)){
				s[++top] = u[i];
				tans++;
			}
		}
		Mymax(ans,tans);
		if( ans == n ) break;
	}
	printf("%d\n",ans);
	
	return 0;
}
```

---

## 作者：⚡LZSY01_XZY⚡ (赞：8)

这道题题解中有一位$dalao$说用`bitset`，但没给代码，我就填个坑。

先谈一谈$bitset$，在本人的$code$中，用到了`set`、`reset`、`count`函数，这些函数都是内置的，可以直接使用，使用方式为：  

	变量名.set();变量名.reset();变量名.count();

和结构体调用函数相似。  

$set()$是将所有元素都置为$1$，时间复杂度$O(n)$  
$reset()$是将所有元素都置为$0$，时间复杂度$O(n)$  
$count()$返回元素为$1$的数量，时间复杂度$O(n)$

另外，$bitset$变量整个可以当做一个$int$类型变量使用，也就是说，支持位运算，返回值为一个$int$类型变量

## $code:$
```cpp
#include <cstdio>
#include <bitset>
#include <ctime>
#include <stack>
#include <algorithm>
#define max(a,b) ((a)>(b)?(a):(b))
using namespace std;

int read()
{
	int x=0,f=1;char c=getchar();
	while (c<'0' || c>'9'){if (c=='-')f=-1;c=getchar();}
	while (c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-48;c=getchar();}
	return x*f;
}

const int MAXN=55;
int n,res;
stack<int> s;
bitset<MAXN> ans,vis[MAXN],is;

int main()
{
	int u,v;
	n=read();
	srand((unsigned)time(NULL));srand(rand());srand(rand());
	for (int i=1;i<=n;i++) vis[i].set();
	while (~scanf("%d%d",&u,&v))
	{
		vis[u].reset(v);
		vis[v].reset(u);
	}
	for (int i=1;i<=2*n;i++)
	{
		is.reset();ans.reset();
		for (int j=1;j<=n;j++)
		{
			u=(rand()%n)+1;
			while (is[u]) u=(rand()%n)+1;
			is.set(u);s.push(u);
		}
		while (!s.empty())
		{
			if ((vis[s.top()]&ans)==0) ans.set(s.top());
			s.pop();
		}
		res=max(res,ans.count());
	}
	printf("%d\n",res);
	return 0;
}
```

---

## 作者：Peter_Z (赞：7)

题外话：

剪了好久的枝终于搜索卡过……

貌似这是第一个用dfs AC的题解？

qwqwq我太蒻了

### 那么进入正题：

首先这道题显然是一个最大团问题（最大团问题的定义见[这个大佬的题解](https://interestinglsy.blog.luogu.org/solution-p4212)），也就是说正解是搜索+剪枝。

~~随机化？我太蒻了不会qwq~~

## Part 1 爆搜（70/100）

这道题还是很良心的，爆搜给了70分。

暴力还是很容易写的，把所有可能的情况在$O(2^n)$内枚举出来，然后$O(n^2)$判定是否可行，与答案比较一下应该就有70分。

这里代码就不给出了（[大佬的题解里面有](https://interestinglsy.blog.luogu.org/solution-p4212)）。

## Part 2 剪枝（80/100）

在爆搜的基础上，可以加这几个剪枝：

1.记录下每个点连接的边数（即出度+入度，代码中的degree数组），搜索时将degree值与ans比较。

若即将要加入的点的degree值<=ans，说明包含这个点的最大团点数一定不比当前ans大（因为最大团是完全子图）。

这时可以直接跳过。

2.搜索到一个新的点时，判断它与之前加入的点之间有没有连边，如果它与集合中任意一个点没有连边，那么说明已经不成立了，跳过。

3.若把剩下的所有点加入当前的集合中，集合的大小仍<=ans，也可以返回。

4.与3类似，用一个tmp变量保存当前集合大小的最大值，循环枚举当前点到n，若i点与当前集合所有点都连了边，则tmp++。

若最后tmp仍<=ans，则说明无论怎么加点，集合的大小都不会>ans了，返回。

这里的具体实现不太好描述，给出部分代码：

```cpp
bool check(int x,int deep) {
	//返回当前深度时，x点是否与集合中的点都连了边
    for(re i=1; i<=deep; i++) {
        if(!to[x][stk[i]]) {
            return false;
        }
    }
    return true;
}
//stk：保存当前的点集
void dfs(int deep,int x) {
    stk[deep]=x;
    //deep表示当前集合大小，x表示当前搜到的点
    if(deep>ans) {
    	//若当前集合大小超过了ans，则更新答案
        ans=deep;
    }
    if(x==n+1)	return;
    //剪枝3
    if(n+1-x+deep<=ans)	return;
    int tmp=deep;
    //剪枝4
    for(re i=x+1; i<=n; i++) {
        if(check(i,deep)) {
            tmp++;
        }
    }
    if(tmp<=ans)	return;
    for(int i=x+1; i<=n; i++) {
    	//剪枝1&剪枝2
        if(degree[i]>=ans && check(i,deep)) {
            dfs(deep+1,i);
        }
    }
}
```

Ps.~~其实这些地方看不懂也没关系，因为正解貌似用不到这些~~

## Part 3  ~~无耻的~~剪枝（90/100）

~~Part2 的代码开个O2就行了qwq~~

## Part 4 记忆化（90/100）

枚举第一个加入的点时，从后往前枚举。

令dp[x]表示当集合中最小的点为x时，ans的最大值。

那么每次当dp[x]+deep<=ans时，就可以返回。

这里原因比较不好描述，也比较显然，yy一下就好qwq。

实验表明，记忆化可以大幅提高程序的速度（然而该TLE的还是T了……）

代码改动不大，这里也就不给出了。

# Part 5 正解（100/100）

~~真正的毒瘤来了qwq~~

观察每多一个点加入集合时，可加入集合的点的数量是不会增加的。

就用样例举个例子：

假设现在只有1这个点。1与2，3，4都连了边，即1与2，3，4都是朋友，故可以加入的点的集合为：{2,3,4}。

然后把2加进来，当前点集变成{1,2}。因为2与4没有连边，因此把4从可以加入的点的集合中去掉，变成{3}。

再把3加进来，这时4与2没有连边（实际上与3也没连），因此4仍不能加入。

于是，考虑维护一个集合S：

让S[deep]表示deep深度时的可以加入的集合，那么每次搜索时处理一下下一层的S，即S[deep+1]。

然后，每次从这个S集中搜索就可以了。

显然，这个剪枝很强力，且包含了Part2中的很多剪枝。

## 代码

```cpp
// luogu-judger-enable-o2
#include<stdio.h>
#include<algorithm>
using namespace std;
#define re register int
int read() {
    re x=0,f=1;
    char ch=getchar();
    while(ch<'0' || ch>'9') {
        if(ch=='-')	f=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9') {
        x=10*x+ch-'0';
        ch=getchar();
    }
    return x*f;
}
const int Size=51;
int n,cnt,ans=1,head[Size];
bool to[Size][Size];
int stk[Size],dp[Size],S[Size][Size];
void dfs(int deep,int num,int x) {
    stk[deep]=x;
    if(!num) {
    	if(deep>ans)	ans=deep;
    	return;
    }
    if(dp[x] && dp[x]+deep<=ans)	return;
    if(deep+num<=ans)	return;
    for(int i=1; i<=num; i++) {
        int now=S[deep][i];
        int pos=0;
        for(re j=i+1; j<=num; j++) {
            if(to[now][S[deep][j]]) {
                S[deep+1][++pos]=S[deep][j];
            }
        }
        dfs(deep+1,pos,now);
    }
}
int main() {
//	freopen("data.in","r",stdin);
//	freopen("WA.txt","w",stdout);
    n=read();
    int a,b;
    while(scanf("%d%d",&a,&b)==2) {
    	to[a][b]=to[b][a]=1;
    }
    for(re i=n; i; i--) {
    	int pos=0;
    	for(re j=i+1; j<=n; j++) {
    		if(to[i][j]) {
    			S[1][++pos]=j;
            }
        }
    	dfs(1,pos,i);
    	dp[i]=ans;
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Dog_Two (赞：6)

## 前置知识和要求
①了解模拟退火

~~②优秀的洗面奶~~

## 思路
- 首先洗脸
- 维护一个能导致当前最优解的n的全排列，我们可以将其初始化为1...n的顺序序列
- 在每一轮降温中，随机交换序列中的两项，O(n^2)地check这个序列
- 对于1...n中的每一项i，如果节点i与1~j（j是已经加入候选答案的点）都有边相连，那么加入节点i必然是合法的，在团中加入节点i
- 如果这个序列导致的答案更优，那么接受答案，否则以某一个概率将当前序列接受作候选
时间复杂度O(T*n^2)。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=50+10;
int n;
bool fri[maxn][maxn];

int ans=INT_MAX-1,line[maxn];

void read(){
    cin>>n;
    int a,b;
    while(~scanf("%d%d",&a,&b)) fri[a][b]=fri[b][a]=true;
    for(int i=1;i<=n;++i) line[i]=i;
}

void pre_rand(){srand(time(NULL));}

inline int check(int *now){
    int cnt=0,res[maxn];
    for(int i=1;i<=n;++i){
        res[++cnt]=now[i];
        for(int j=1;j<i;++j) if(!fri[res[j]][now[i]]){--cnt;break;}
    }
    return n-cnt;
}

void solve(){
    int l[maxn]; memcpy(l,line,sizeof(line));
    double t=2048.0;
    while(t>1e-18){
        int now[maxn]; memcpy(now,l,sizeof(l));
        int a,b;
        do{
            a=rand()%n+1,b=rand()%n+1;
        }while(a==b);
        swap(now[a],now[b]);
        int _ans=check(now);
        int del=_ans-ans;
        if(del<0) ans=_ans,memcpy(l,now,sizeof(now)),memcpy(line,l,sizeof(l));
        else if(exp(-del/t)*RAND_MAX>rand()) memcpy(l,now,sizeof(now));
        t*=0.998;
    }
}

void print(){
    cout<<n-ans;
}

bool cheat(){if(n==1){cout<<1;return true;}return false;}

int main(){
    read();
    if(cheat()) return 0;
    pre_rand();
    for(int i=1;i<=24;++i) solve();
    print();
    return 0;
}

```

---

## 作者：引领天下 (赞：6)

这题目其实是bitset的一个很好的应用，再结合一下楼下的随机数算法即可AC。

注意一下，**由于两个人之间要么是朋友要么是敌人**，那么我们可以考虑将两个人之间的关系改为**2进制**。这就是bitset的原理。

bitset很强大，可以对很多数据类型进行转换，重点是：**支持运算操作！**

那么这题的做法就很显然了：直接用一个bitset `now` 来维护当前顺序可以入选的名单（用 `&` 运算可以模拟水火不容 or 基♂情满满）

剩下来的就是用随机生成顺序来取最大值了，最后存答案的bitset `ans` 的数量（ $ ans.count() $ 就是答案）。（ans中1的个数即表示有多少人能和睦相处）

代码就不贴了，只有18行，相信大家都能打出来。

---

## 作者：JoseTony (赞：5)

# 思路
这道题的正解应该是动态规划，然而我还没有学到那里怎么办？这里介绍一种随机算法，可以称之为随机贪心。虽然有投机取巧的嫌疑，但还是能通过此题并在比赛中拿到一定的分数。这里面用到的随机方法主要是 ```random_shuffle``` 内置模版。写法和排序还是有异曲同工之妙。具体的用法可参考下列代码。
```cpp
#include<bits/stdc++.h>
int a[100001];
int main(){
	int n;
  	cin >> n;
  	for(int i=0;i<n;i++){
  		cin >> a[i];
  	}
  	random_shuffle(a,a+n);
  	for(int i=0;i<n;i++){
  		cout << a[i];
  	}
    return 0;
}
```
这样我们就可以看出这个内置模版的作用了，也就是对于一个数组进行打乱排序，纯随机操作。那么在这道题中，依据题意，我们可以开始对于输入的数据进行模拟。如果两个人是朋友的话，我们就把它们储存在一个二维数组里，令它们等于一。然后把数组打乱，随机模拟到一个，如果两个人不是敌人，则我们把它们的标签设置为一。然后只要统计标签数组中一的个数就可以了。最后还要每次都在循环里求出最大值。注意标签数组在循环开始时要用 ```memset``` 函数进行归零操作。但是有一些同学的输入格式不对，注意输入不一定有 $n$ 行。代码如下。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int n;
int a[10001],tag[10001],ans,cnt,fr[100][100];
int minn;
int main(){
    cin >> n ;
    for(int i=1;i<=n;i++){
        a[i]=i;
    }
    int x,y;
    while(cin >> x >> y){
        fr[x][y]=1;
        fr[y][x]=1;//记录为1
    }
    for(int k=1;k<=1000;k++){
        cnt=0;
        memset(tag,0,sizeof(tag));//注意标签数组要归0
        random_shuffle(a,a+n);//打乱操作
        for(int i=1;i<=n;i++){
            if(tag[a[i]]==0){
                
                cnt++;//如果两个人不是敌人，计数器加一
                for(int j=1;j<=n;j++){
                    if(fr[a[i]][a[j]] == 0){
                    
                        tag[a[j]] = 1;//标签设为1
                        
                    }
            }
            
        }
    }
        minn=max(minn,cnt);//比较大小
}
    cout << minn << "\n";
    return 0;
}
```


---

## 作者：破忆 (赞：3)

## 【题意】
给出若干对朋友关系，选出最多的人，要求这些人互为朋友

## 【分析】
简单贪心一波

对于当前待选的人，只要此人与已选的人都互为朋友，就选择

显然这个贪心有很大的问题

然而n只有50，可以重复操作很多次

再一想，选人的顺序决定能否蒙到正确答案

随机排序即可

## 【解法】
随机化贪心

## 【代码】
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=55;
int n,x,y,a[maxn],ans;
bool vis[maxn];
bool f[maxn][maxn];
int main(){
 	freopen("P4212.in","r",stdin);
 	freopen("P4212.out","w",stdout);
	srand(time(NULL));
	scanf("%d",&n);
	while(scanf("%d%d",&x,&y)==2) f[x][y]=f[y][x]=1;
	for(int i=1;i<=n;i++) a[i]=i;
	while((double)clock()/CLOCKS_PER_SEC<0.95){
		random_shuffle(a+1,a+1+n);
		int now=0;
        	memset(vis,0,sizeof vis);
		for(int i=1;i<=n;i++){
			bool flg=0;
			for(int j=1;j<i;j++) if(vis[a[j]]&&!f[a[i]][a[j]]){ flg=1;break;}
			if(!flg) vis[a[i]]=1,now++;
		}
		ans=max(ans,now);
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：iorit (赞：3)

[原题](https://www.luogu.com.cn/problem/P4212)

**_前置芝士：模拟退火_**

题意：给你一个无向图，求出这个图的最大完全子图的大小。（即最大团问题）

众所周知，最大团问题是 $\texttt{NPC}$ 问题。观察数据范围 $1 \le n \le 50$，我们可以用模拟退火完成此题。

一般的模拟退火题都是维护一个序列，每次随机交换其中两个检验最优方案的方法来实现。

这题也可以采用类似的方法：我们把 $n$ 个点放到一个序列中，每次随机交换两个点，$\mathcal O(n^2)$ 枚举 $k$，直到前 $k$ 个点不组成一个团，$k - 1$ 即为当前答案。

大概长这个样：

```cpp
int query()
{
	for(int i = 1;i <= n;i++)
		for(int j = i - 1;j >= 1;j--)
			if( !edge[ a[i] ][ a[j] ] )
				return i - 1;
	return n;
}
```

其中 `a[i]` 表示序列的第 $i$ 个点。

当然由于这题正解不是退火，所以参数比较难调，卡时也要比较极限。我的参数仅供参考。

### 代码
```cpp
const double eps = 1e-8;
const double delta = 0.999;
int ans = -inf;
int n;
bool edge[N][N]; // 邻接矩阵存图，方便判断两点连通 
int a[N],ansa[N]; // 当前序列，最优序列 
int query()
{
	for(int i = 1;i <= n;i++)
		for(int j = i - 1;j >= 1;j--)
			if( !edge[ a[i] ][ a[j] ] )
				return i - 1;
	return n;
}
void SA()
{
	double T = 5000; // 初温调高一点 
	for(int i = 1;i <= n;i++)
		a[i] = ansa[i];
	while(T > eps)
	{
     	int x = rand() % n + 1;
     	int y = rand() % n + 1;
     	swap( a[x] , a[y] ); // 随机交换序列的两个数 
		int cur = query(); 
		if(cur > ans)
		{
			ans = cur;
			for(int i = 1;i <= n;i++)
				ansa[i] = a[i];
		}
		else if( exp( (cur - ans) / T ) * RAND_MAX < rand() )
			swap( a[x] , a[y] );
		T *= delta;
	}
}
int main()
{
	srand( time(NULL) );
	cin >> n;
	int u,v;
	while(cin >> u >> v)
		edge[u][v] = edge[v][u] = true;
	for(int i = 1;i <= n;i++)
		ansa[i] = i;
	while(clock() < CLOCKS_PER_SEC * 0.99) // 卡时 
		SA();
	cout << ans << endl;
    return 0;
}
```
不保证一直 AC 。

---

## 作者：lahlah (赞：3)

题解为什么都是随机化或bitset的呀

这题明明就是最大团板子题啊

~~是不是对最大团问题有什么误解~~

搜索加3个剪枝没有压力跑过去了呀

没开O2 : https://www.luogu.org/record/24996441

开O2 ： https://www.luogu.org/record/24995977

首先讲讲怎么搜索吧


我们可以考虑设立 F(i)，表示只考虑标号 ≥ i 的点所能构成的最大团的点数

那么我们就可以从 n 到 1 依次枚举，假设枚举到 i 号点，我们可以~~钦定~~**强制选择** i 号点作为团中的点，然后从小到大依次枚举 i 号点所连向的编号大于 i 的点，选为团中的点，然后不断进行这样的操作，注意要保证当前选的点要和之前选的点都有连边才合法。

注意 F(i) ≤ F(i+1) + 1，因为我每次只添加一个点，不可能把最大团的点数加2。所以如果把 F(i) 更新为了 F(i+1) + 1，那么就可以直接退出。（最优性剪枝 1）

如果当前深度是 depth，最后一个枚举的点是 u，设 D(u) 为编号大于 u 的且与u 有连边的点的个数，那么如果 depth + D(u) ≤ F(i)，那么这之后也肯定不可能会有更优的解，直接退出。（最优性剪枝 2）

假设当前深度是 depth，最后一个枚举的点是 u，如果 depth + F(u+1) ≤ F(i)，那么这之后肯定不可能会有更优的解，直接退出。（最优性剪枝 3）

code:
```cpp
#include<bits/stdc++.h>
#define N 55
using namespace std;
int n, ans, g[N][N], S[N][N], f[N];
void dfs(int m, int dep) {
	if(dep > ans) {//最优性剪枝 1
		ans = dep;
		return;	
	}
	for(int i = 1; i <= m; i ++) {
		if(dep + m - i + 1 <= ans) continue;//最优性剪枝 2
		if(dep + f[S[dep][i]] <= ans) continue;//最优性剪枝 3
		int sz = 0;
		for(int j = i + 1; j <= m; j ++)
			if(g[S[dep][i]][S[dep][j]]) S[dep + 1][++ sz] = S[dep][j];
		dfs(sz, dep + 1);
	}
}
int main() {
	scanf("%d", &n);
	int u, v;
	while(~scanf("%d%d", &u, &v)) g[u][v] = g[v][u] = 1;//这里题面就不能强调一下吗? 
	
	for(int i = n; i >= 1; i --) {
		int m = 0;
		for(int j = i + 1; j <= n; j ++) 	
			if(g[i][j]) S[1][++ m] = j;
		dfs(m, 1);
		f[i] = ans;
	}
	printf("%d", ans);
	return 0;
}

```

---

## 作者：试试事实上吗 (赞：2)

## 模拟退火

退火大法吼啊！

首先不知道模拟退火的请左转[这个题](https://www.luogu.com.cn/problem/P1337)

然后回到我们的这个问题，实际上我们的这个题是图论中的一类经典问题——[最大团问题]([https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E5%9B%A2%E9%97%AE%E9%A2%98/7648036?fr=aladdin](https://baike.baidu.com/item/最大团问题/7648036?fr=aladdin))，这个问题是指在一个图中找一个子图是完全图，使这个子图的点数最多。这是一个NP完全问题~~别说你不知道啥是NP完全~~，一般情况下解决NP完全问题，模拟退火都有较好的表现。

正片开始：

我们先产生一个排列，然后从前往后的枚举点，考虑这个点是否能加入，能就加入，不能就返回答案，这样我们就得到了一个解，然而它不一定使最优解，这个计算函数长这样：

```cpp
inline int calc(int *a)
{
    for(int i=1;i<=n;++i)
        for(int j=1;j<i;++j)
            if(!e[a[i]][a[j]]) return n-i+1;
    return 0;
}

```

我们可以每次尝试交换排列中的两个数来退火，就像这样：

```cpp
void SA()
{
    memcpy(a,b,sizeof(b));
    for(double t=2048;t>1e-18;t*=delta)
    {
        int x=rand()%n+1,y=rand()%n+1;
        if(x==y) continue;
        swap(a[x],a[y]);
        int now=calc(a),D=now-ans;
        if(D<0) ans=now,memcpy(b,a,sizeof(a));
        else if(exp(-D/t)*RAND_MAX<=rand()) swap(a[x],a[y]);
    }
}
```

多次退火到时间上限：

```cpp
double pre=clock();
while(clock()-pre<0.95*CLOCKS_PER_SEC) SA();
```

注意记录一下最优解的排列，每次从那里开始。

然后就没有了。

剩下的就只有~~最有意思的~~调参了。

代码，在$O2$的加持一般有九十分，~~洗一下脸说不定就A了~~

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <ctime>
using namespace std;
const int maxn=55;
const double delta=0.997;

int a[maxn],e[maxn][maxn],n,ans,b[maxn];

inline int calc(int *a)
{
    for(int i=1;i<=n;++i)
        for(int j=1;j<i;++j)
            if(!e[a[i]][a[j]]) return n-i+1;
    return 0;
}

void SA()
{
    memcpy(a,b,sizeof(b));
    for(double t=2048;t>1e-18;t*=delta)
    {
        int x=rand()%n+1,y=rand()%n+1;
        if(x==y) continue;
        swap(a[x],a[y]);
        int now=calc(a),D=now-ans;
        if(D<0) ans=now,memcpy(b,a,sizeof(a));
        else if(exp(-D/t)*RAND_MAX<=rand()) swap(a[x],a[y]);
    }
}

int main()
{
    srand(time(0));
    int u,v;
    scanf("%d",&n);
    if(n==1) {puts("1");return 0;}
    while(scanf("%d%d",&u,&v)!=EOF)
        e[u][v]=e[v][u]=1;
    for(int i=1;i<=n;++i) b[i]=i;
    ans=calc(b);
    double pre=clock();
    while(clock()-pre<0.95*CLOCKS_PER_SEC) SA();
    printf("%d\n",n-ans);
    return 0,QAQ;
}
```



---

## 作者：az__eg (赞：1)

首先看题。    
题意:**给定一个无向图，求最大可能有几个点使每个点之间都有边相连。**  

即**最大团问题。**  

很不幸的是，这个问题无法在多项式时间内解决，正解 dfs 的时间复杂度为 $O(n^{2}{2}^n)$，然而在本题中 $n = 50$，显然会 TLE。当然不乏有神犇通过强有力的剪枝AC的。本篇题提供一种另外的思路。

我们可以考虑能否有其他不一定准确得出答案但正确率极高的方法，即考虑对序列进行随机排序，按照顺序入队，由于如果使用贪心本身就很可能的到近似解，如果随机尝试的次数够多，例如 $10^5$ 次，则有很大概率得到正确答案。

我们可以每次随机一个序列 $a_i$，表示第 $i$ 个考虑的点为 $a_i$，并且从 $1$ 到 $n$ 遍历随机序列 $a$，如果 $a_i$ 与 $a_1$ 到 $a_{i-1}$ 不冲突便选中。

每一次检查的时间复杂度为 $O(n^2)$，共执行 $10^5$ 次，即可极大概率得到正确解。

代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<ctime>
#include<cstring>
#define ts printf("PASS\n")
using namespace std;
int n;
int myrand[51];//随机遍历序列
bool G[51][51];
bool visited[51];//标记是否被选中
int main()
{
	int i,j,k;
	scanf("%d",&n);
	int a,b;
	while(scanf("%d%d",&a,&b)==2)
	{
		G[a][b] = true;
		G[b][a] = true;//建边
	}
	int ans = 0;
	for(i=1;i<=n;i++)
	{
		zc[i] = i;//初始化选的序列
	}
	for(i=1;i<=100000;i++)
	{
		memset(visited,0,sizeof(visited));//清空标记
		int cnt = 0;
		random_shuffle(myrand+1,myrand+1+n);//随机排列序列
		for(j=1;j<=50;j++)
		{
			bool flag = true;
			for(k=j-1;k>=1;k--)
			{
				if(sq[k])
					if(!G[zc[j]][zc[k]])
					{
						flag = false;
						break;
					}
						
			}
			cnt += flag?1:0;
			sq[j] = flag;
		}
		ans = max(ans,cnt);
	}
	printf("%d",ans);
}
```




---

## 作者：Remake_ (赞：0)

这题绝对是水紫。

贪心大家都很会，但是贪心它正确性很差qwq。

那怎么办，每次```random_shuffle```贪心顺序啊，这样贪心个80000次，跑的很稳。

我的贪心思路，与前面要去旅行的人比一下，如果都是朋友，就直接安排他去旅行，同时建一个vector储存当前所有要去旅行的人，这样每来一个新的人，就直接与vector里的所有人判断一下就行了。

最后贪心的答案是```
v.size()```，同时用一个变量记录贪心这么多次的最大值，最后直接将这个最大值视作答案即可，正确性是显然的。

code:

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a, b, times = 80000, order[60], maxx;
bool pd[60][60];
vector<long long> v;
void tx()
{
    v.clear();
    v.push_back(order[1]);
    for (int i = 2; i <= n; i++)
    {
        int cnt = 0;
        for (int j = 0; j < v.size(); j++)
        {
            if (!pd[v[j]][order[i]])
                break;
            ++cnt;
        }
        if (cnt == v.size())
            v.push_back(order[i]);
    }
    maxx = max(maxx, int(v.size()));
}
int main()
{
    cin >> n;
    while (scanf("%d%d", &a, &b) != EOF)
        pd[a][b] = pd[b][a] = 1;
    for (int i = 1; i <= n; i++)
        order[i] = i;
    while (--times)
    {
        random_shuffle(order + 1, order + n + 1);
        tx();
    }
    cout << maxx;
    system("pause");
}
```


---

## 作者：Submerge (赞：0)

 这道题可以用模拟退火来乱搞（或者随机化+dfs）。

大体就是搞一个序列，定义其价值为从左往右、见到合法点立刻选所能选出的点数。
 
然后模拟退火，求出最大价值即为答案。  
一个很简单的转化就是把最大团变成补图的最大独立集(就是把不能共存看成边的话，选出的一定得是独立集)、
然后这也不是二分图啊,好像是个NP问题。
但是记得啥时候听说过怼np问题可以用随机化来着。

上代码
```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 50
#define swap(x,y) (x^=y^=x^=y)
#define Gmax(x,y) (x<(y)&&(x=(y)))
using namespace std;
int n,f[N+5][N+5];
class SimulatedAnnealing
{
	private:
		#define SA_TIME 100
		int ans,s[N+5],vis[N+5];
		I int Calc()
		{
			RI i,j,res=0;for(i=1;i<=n;++i)
			{
				for(j=1;j^i;++j) if(vis[j]&&!f[s[i]][s[j]]) break;
				i^j?vis[i]=0:(++res,vis[i]=1);
			}return res;
		}
		I void Work()
		{
			RI i,x,y,res,nres;for(i=1;i<=n;++i) s[i]=i;random_shuffle(s+1,s+n+1),res=Calc(),Gmax(ans,res);
			for(double tt=1e7;tt>1e-3;tt*=0.995)
			{
				W((x=rand()%n+1)==(y=rand()%n+1));swap(s[x],s[y]),nres=Calc(),Gmax(ans,nres);
				(nres>res||exp((res-nres)/tt)>1.0*rand()/RAND_MAX)?res=nres:swap(s[x],s[y]);
			}
		}
	public:
		I void Solve() {srand(20030909);for(RI i=1;i<=SA_TIME;++i) Work();printf("%d",ans);}
}S;
int main()
{
	cin:tie(0);
        cout:tie(o);
	RI i,x,y;scanf("%d",&n);W(~scanf("%d%d",&x,&y)) f[x][y]=f[y][x]=1;
	return S.Solve(),0;
}
```

---


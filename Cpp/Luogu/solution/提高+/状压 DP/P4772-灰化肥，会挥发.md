# 灰化肥，会挥发

## 题目背景

Farmer Justin 有一大堆会发黑和挥发的灰化肥呢！！！

## 题目描述

在 Farmer Justin 的农场中有许多灰化肥，它们都堆积在A仓库里。为了方便施肥，Farmer Justin 需要修一些公路使得他能用拖拉机把这些灰化肥拉到其他仓库里。由于 Farmer Justin 及其懒惰，所以他只想一次拉完所有的灰化肥送到其他仓库里。但是灰化肥见光易挥发，所以 Farmer Justin 需要尽快把这些灰化肥拉完。现在告诉你Farmer Justin农场的构成地图，请你帮帮他计划一条**从 A 仓库出发**走完所有仓库的方案吧！由于Farmer Justin 非常的讨厌浪费时间，所以你只需要告诉他最短的距离和走过所有农场的顺序。（注意：拖拉机走的时候是四联通的。）

## 说明/提示

对于全部数据，$ 1 \leqslant R,C \leqslant 500 $，$ 1 \leqslant N \leqslant 16 $。

## 样例 #1

### 输入

```
5 5 3
A.**C
*....
B*...
.**..
.....```

### 输出

```
16
ACB```

# 题解

## 作者：CYJian (赞：18)

首先发现这道题的仓库数量偏小，考虑状压。

定义状态$f[i][j]$表示已经走过的仓库集合为$i$且最后一次到的仓库为$j$时走过的最小距离。

这个转移的话只需要在枚举下一个到达的仓库$k$就可以很方便的转移了。如下:

$ f[i|(1<<k)][k] =min(f[i|(1<<k)][k], f[i][j] + dis[j][k])$

这里的$dis[j][k]$就表示从$j$到$k$的最短路，这个只需要在原图中以每一个仓库为起点跑几遍$BFS$就可以了。

但是我们还需要考虑输出字典序最小的方案。

这个其实并不难，只需要类比地再记录一个状态$g[i][j]$表示最小距离情况下的最小字典序的方案即可。

有很多人WA就是只考虑在转移$f$的时候顺便更新一下$g$，殊不知需要在$f$相等的时候再判断一下更新$g$看看会不会有更小的字典序产生。

具体细节请看~~丑陋的代码~~

```cpp
#include <bits/stdc++.h>

using namespace std;

struct Node {
    int x;
    int y;
};

const int N = 16;
const int fx[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};//四个方向

int n;
int m;
int s;
int jsq;
int f[1 << N][N];    //最小的距离 
string g[1 << N][N]; //走的方案
int To[N][N];        //最短路
int Arrive[501][501];//记录以某一个点开始到所有点的最短路
char S[501][501];    //存地图

Node F[N];

void BFS(Node F) {  //求从F仓库开始到其他仓库的最短路是多少
	memset(Arrive, 0, sizeof(Arrive));
	queue<Node>q;
	q.push(F);
	Arrive[F.x][F.y] = 1;
	while(!q.empty()) {
		Node f = q.front(); q.pop();
		for(int i = 0; i < 4; i++) {
			int x = f.x + fx[i][0];
			int y = f.y + fx[i][1];
			if(x < 1 || y < 1 || x > n || y > m || S[x][y] == '*' || Arrive[x][y]) continue;  //不可以走到就跳过
			Arrive[x][y] = Arrive[f.x][f.y] + 1; //更新最短路
			q.push((Node){x, y});  //加入队列
		}
	}
}

int main() {
    scanf("%d%d%d", &n, &m, &s);
    for(int i = 1; i <= n; i++)
        scanf("%s", S[i] + 1); //读入地图
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++) //找到仓库点
            if(S[i][j] >= 'A' && S[i][j] <= 'Z')
                F[S[i][j] - 'A' + 1] = (Node){i, j};
    for(int i = 1; i <= s; i++) { //求出最短路
		BFS(F[i]);
		for(int j = 1; j <= s; j++) To[i][j] = Arrive[F[j].x][F[j].y] - 1;
	}
	memset(f, 63, sizeof(f));  //初始化
	f[1][1] = 0;
	g[1][1] = "A";  //只能从A号仓库开始
	for(int i = 2; i < (1 << s); i++) {
		if(!(i & 1)) continue;
		for(int j = 1; j <= s; j++) {
			if(i & (1 << (j - 1)) == 0) continue;
			for(int k = 2; k <= s; k++) {
				if(i & (1 << (k - 1)) == 0 || j == k) continue;
				if(f[i][k] > f[i ^ (1 << (k - 1))][j] + To[j][k]) {
					f[i][k] = f[i ^ (1 << (k - 1))][j] + To[j][k];
					g[i][k] = g[i ^ (1 << (k - 1))][j] + (char)(k + 'A' - 1);
				} //如果可以有更小的f更新就直接更新
				else if(f[i][k] == f[i ^ (1 << (k - 1))][j] + To[j][k] && g[i][k] > (g[i ^ (1 << (k - 1))][j] + (char)(k + 'A' - 1)))
					g[i][k] = (g[i ^ (1 << (k - 1))][j] + (char)(k + 'A' - 1));   
                    //如果f相等就考虑字典序会不会更新之后更小
			}
		}
	}
	int T = (1 << s) - 1;
	int Min = f[T][2];
	string res = g[T][2];  //不可能最后一个点到A仓库，所有从第二个仓库开始
	for(int i = 3; i <= s; i++) {
		if(Min > f[T][i]) {
			Min = f[T][i];
			res = g[T][i];
		}
		else if(Min == f[T][i] && res > g[T][i])
			res = g[T][i];
	}//寻找最优解
	printf("%d\n", Min);
	cout << res << endl;
    return 0;
}
```

---

## 作者：loi_hjh (赞：12)

~~今天队内互（胡）测（策）题T2，没想到花了2小时居然码了出来~~

最开始试图搜索骗分，然后"良心"的出题人$l$*$p$将测试点开成了子任务$...$然后开$10$个子任务$100$个测试点捆绑测试

于是$n$=$16$考虑状压，设状态$dp[i][j]$表示$i$状态最后一个位置为$j$时的最短距离，因此考虑当$i$状态中包括$j$并且没有包括$k$时转移$dp[i|(1<<k-1)][k]$=$min(dp[i|(1<<k-1)][k],dp[i][j]+dis[j][k])$

$dis[j][k]$表示$j$到$k$的最短路,可以通过$bfs$实现，考场的时限为$1s$，于是我对着每个仓库暴力跑了一遍$dijkstra$求最短路$...$

对着每个不是障碍的位置暴力建边

```cpp
for(ri i=1;i<=n;i++)
	for(ri j=1;j<=m;j++){
		if(a[i][j]=='*') continue;//如果不是障碍就向四周建边
		if((a[i][j]>='A')&&(a[i][j]<='A'+p-1)) posx[a[i][j]-'@']=i,posy[a[i][j]-'@']=j;
		for(ri k=0;k<=3;k++){	
			ri x=i+dx[k],y=j+dy[k];
			if((x>=1)&&(y>=1)&&(x<=n)&&(y<=m)&&(a[x][y]!='*')) add((i-1)*m+j,(x-1)*m+y);
		}
	}
    
for(ri i=1;i<=p;i++)
	dijkstra(i);//dis[i][j]//表示从第i个字母出发到各点的最短路
```

```cpp
void dijkstra(ri s){
	for(ri i=1;i<=n*m;i++)
		vis[i]=0,dis[s][i]=1e9+7;
	dis[s][calc(s)]=0;
	q.push(make_pair(0,calc(s)));
	while(!q.empty()){
		ri u=q.top().second;
		q.pop();
		if(!vis[u]){
			vis[u]=1;
			for(ri i=head[u];i;i=e[i].nxt){
				ri v=e[i].v;
				if(dis[s][v]>dis[s][u]+1){
					dis[s][v]=dis[s][u]+1;
					q.push(make_pair(dis[s][v],v));
				}
			}
		}
	}
}
```



```cpp
for(ri i=1;i<(1<<p);i++)//p表示仓库的数量
	for(ri j=1;j<=p;j++)
		if((i&(1<<j-1))==(1<<j-1))
			for(ri k=2;k<=p;k++)
				if((i&(1<<k-1))!=(1<<k-1)) dp[i|(1<<k-1)][k]=min(dp[i|(1<<k-1)][k],dp[i][j]+dis[j][calc(k)]);
```

然后再考虑怎样记录每种状态经过的仓库，首先第一个仓库必然为$A$，不必记录，然后剩余的仓库数量为$15$，可以将状态视作为一个$16$进制数，将$B$视为$1$，$P$视为$15$，将经过的仓库状态使用$unsigned$ $long$ $long$存储，~~其实貌似$long$ $long$也能行~~

于是状态转移就变成了这样

```cpp
memset(dp,0x3f,sizeof(dp));
for(ri i=1;i<(1<<p);i++)
	for(ri j=1;j<=p;j++)	
		state[i][j]=9223372036854775807;
final=9223372036854775807;
state[1][1]=0=dp[1][1]=0;
for(ri i=1;i<(1<<p);i++)
	for(ri j=1;j<=p;j++)
		if((i&(1<<j-1))==(1<<j-1))
			for(ri k=2;k<=p;k++)
				if((i&(1<<k-1))!=(1<<k-1)){
					if(dp[i|(1<<k-1)][k]==dp[i][j]+dis[j][calc(k)]) state[i|(1<<k-1)][k]=min(state[i|(1<<k-1)][k],state[i][j]*16+(k-1));//当最新状态的原最短距离与该转移方式相同时，更新最新状态的转移方式
					if(dp[i|(1<<k-1)][k]>dp[i][j]+dis[j][calc(k)]) dp[i|(1<<k-1)][k]=dp[i][j]+dis[j][calc(k)],state[i|(1<<k-1)][k]=state[i][j]*16+(k-1);//如果可以更新最新状态的最短距离时，就直接转移
				}
		
```

放上考场代码（洛谷$dijkstra$需要开氧，因为洛谷时限$400ms$，需要将$dijkstra$改为$bfs$）

```cpp
#include<map>
#include<list>
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define N 250010
#define in inline
#define ll long long
#define INF 2147483647
#define ri register int
#define P pair<int,int>
using namespace std;
in int read(){
	int v=0;char c=' ';
	while((c<'0')||(c>'9')) c=getchar();
	while((c>='0')&&(c<='9')){v=(v<<1)+(v<<3)+(c^48);c=getchar();}
	return v;
}
struct Edge{
	int u,v,nxt;
}e[N<<3];
unsigned ll state[1<<17][20],final;
int n,m,p,cnt,posx[20],posy[20],dx[]={0,0,1,-1},dy[]={1,-1,0,0},head[N],dis[20][N],dp[1<<17][20],ans=INF,tot,let[20];
bool vis[N];
char a[510][510];
priority_queue<P,vector<P>,greater<P> > q;
void add(ri u,ri v){
	e[++cnt]=(Edge){u,v,head[u]};
	head[u]=cnt;
}
int calc(ri x){
	return (posx[x]-1)*m+posy[x];
}
void dijkstra(ri s){
	for(ri i=1;i<=n*m;i++)
		vis[i]=0,dis[s][i]=1e9+7;
	dis[s][calc(s)]=0;
	q.push(make_pair(0,calc(s)));
	while(!q.empty()){
		ri u=q.top().second;
		q.pop();
		if(!vis[u]){
			vis[u]=1;
			for(ri i=head[u];i;i=e[i].nxt){
				ri v=e[i].v;
				if(dis[s][v]>dis[s][u]+1){
					dis[s][v]=dis[s][u]+1;
					q.push(make_pair(dis[s][v],v));
				}
			}
		}
	}
}
int main(){
	n=read(),m=read(),p=read();
	for(ri i=1;i<=n;i++)
		for(ri j=1;j<=m;j++)
			cin>>a[i][j];
	for(ri i=1;i<=n;i++)
		for(ri j=1;j<=m;j++){
			if(a[i][j]=='*') continue;
			if((a[i][j]>='A')&&(a[i][j]<='A'+p-1)) posx[a[i][j]-'@']=i,posy[a[i][j]-'@']=j;
			for(ri k=0;k<=3;k++){	
				ri x=i+dx[k],y=j+dy[k];
				if((x>=1)&&(y>=1)&&(x<=n)&&(y<=m)&&(a[x][y]!='*')) add((i-1)*m+j,(x-1)*m+y);
			}
		}
	for(ri i=1;i<=p;i++)
		dijkstra(i);
	memset(dp,0x3f,sizeof(dp));
	for(ri i=1;i<(1<<p);i++)
		for(ri j=1;j<=p;j++)	
			state[i][j]=9223372036854775807;
	final=9223372036854775807;
	state[1][1]=0;
	dp[1][1]=0;
	for(ri i=1;i<(1<<p);i++)
		for(ri j=1;j<=p;j++){
			if((i&(1<<j-1))==(1<<j-1)){
				for(ri k=2;k<=p;k++)
					if((i&(1<<k-1))!=(1<<k-1)){
						if(dp[i|(1<<k-1)][k]==dp[i][j]+dis[j][calc(k)]) state[i|(1<<k-1)][k]=min(state[i|(1<<k-1)][k],state[i][j]*16+(k-1));
						if(dp[i|(1<<k-1)][k]>dp[i][j]+dis[j][calc(k)]) dp[i|(1<<k-1)][k]=dp[i][j]+dis[j][calc(k)],state[i|(1<<k-1)][k]=state[i][j]*16+(k-1);
					}
			}
		}
	for(ri i=1;i<=n;i++){
		if(ans==dp[(1<<p)-1][i]) final=min(final,state[(1<<p)-1][i]);
		if(ans>dp[(1<<p)-1][i]) ans=dp[(1<<p)-1][i],final=state[(1<<p)-1][i];
	}
	printf("%d\nA",ans);
	while(final) let[++tot]=final%16,final/=16;
	for(ri i=tot;i;i--)
		printf("%c",let[i]+'A');//将从B向后经过的仓库输出
	return ~~(0-0);
}

```

 _~~最后这场考试窝好像$AK$了~~_ 

---

## 作者：S_S_H (赞：4)

### 说实话这个题思路不难，但卡时间空间极其毒瘤！！！
做这个题之前推荐大家先做一下洛谷的   

[P4802 [CCO 2015]路短最](https://www.luogu.org/problem/P4802)

是这个题的简化版（推荐食用我的题解QWQ）

分析一下，N<=16考虑状压，但是肯定不能在图上状压吧。。。

求最短路，那么先每个点BFS一遍求最短路那么就可以脱离原图了（基本操作）

剩下的第一问和P4802一样DP一下就可以了

但是不一样的是本题只能从A点出发！！！（我因为这个WA了20分）

第二问才是这个题恶心的地方（思路借鉴 Cesare大佬）

本来维护一个string[1<<17][17]不会被卡，但是出题人故意卡自己31.25MB

只能考虑从答案反向DFS更新，正常570+ms没问题，但是本题400ms开O2勉强过

代码部分：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring
typedef long long ll;
using namespace std;
ll dp[1<<17][20],n,m,num,dis[50][50],ans=0x7f7f7f7f7f7f7f;
ll tx[5]={0,0,1,-1};
ll ty[5]={1,-1,0,0};
ll head[1<<17][20];
char s[510][510];
bool book[510][510];
string sans;
void bfs(ll stx,ll sty){
	memset(book,0,sizeof(book));
	queue<ll>x;
	queue<ll>y;
	queue<ll>val;
	x.push(stx);
	y.push(sty);
	val.push(0);
	book[stx][sty]=1;
	while(x.size()){
		ll ax=x.front();
		ll ay=y.front();
		ll av=val.front();
		for(ll i=0;i<4;i++){
			ll kx=ax+tx[i];
			ll ky=ay+ty[i];
			ll kv=av+1;
			if(kx>=0&&kx<n&&ky>=0&&ky<m){
				if(s[kx][ky]=='.'&&book[kx][ky]==0){
					book[kx][ky]=1;	
					x.push(kx);
					y.push(ky);
					val.push(kv);
				}
				if(s[kx][ky]>='A'&&s[kx][ky]<='Z'&&book[kx][ky]==0){
					book[kx][ky]=1;
					dis[s[stx][sty]-'A'][s[kx][ky]-'A']=kv;
					x.push(kx);
					y.push(ky);
					val.push(kv);
				}
			}
		}
		x.pop();
		y.pop();
		val.pop();
	}
}//常规BFS
void dfs(ll i,ll S,string k){
	k.insert(0,1,(char)(i+'A'));//意思是在k[0]处插入1个char类型的字符
	if(S==1){
		if(sans=="") sans=k;
		else if(k<sans) sans=k;//string可以直接比较字典序
		return;
	}
	ll now=S^(1<<i);
	for(ll j=0;j<num;j++) 
		if((now&(1<<j))&&dp[S][i]==dp[now][j]+dis[j][i])
			dfs(j,now,k);
}
int main(){
	scanf("%lld%lld%lld",&n,&m,&num);
	for(ll i=0;i<n;i++)
		scanf("%s",s[i]);
	for(ll i=0;i<n;i++)
		for(ll j=0;j<n;j++)
			if(s[i][j]>='A'&&s[i][j]<='Z')
				bfs(i,j);
	for(ll i=0;i<=(1<<num)-1;i++)
		for(ll j=0;j<num;j++)
			dp[i][j]=0x7f7f7f7f7f7f7f;
	for(ll j=0;j<num;j++)
		dp[(1<<j)^1][j]=dis[0][j];
	dp[1][0]=0;//初始化，以自己为起点终点为0，DFS会用到，不懂的话删去模拟一下DFS样例吧
	for(ll i=0;i<=(1<<num)-1;i++)
		for(ll j=0;j<num;j++)
			if(i&(1<<j))
				for(ll k=0;k<num;k++)
					if(i&(1<<k)&&k!=j)
						if(dp[i^(1<<j)][k]+dis[k][j]<dp[i][j])
							dp[i][j]=dp[i^(1<<j)][k]+dis[k][j];
   //和P4802方程一样
	for(ll i=0;i<num;i++)
		ans=min(ans,dp[(1<<num)-1][i]);
	printf("%lld\n",ans);
	for(ll i=0;i<num;i++)
		if(dp[(1<<num)-1][i]==ans)
			dfs(i,((1<<num)-1),"");//DFS搜
	cout<<sans;
	return 0;
}
```

## 祝大家2019CSP,NOI,XXXOI RP++!!!

---

## 作者：喵仔牛奶 (赞：3)

直接 $O(2^{rc})$ 暴力搜索肯定会 TLE。实则可以简化，写一个 BFS 跑出各个点的最短路，然后暴力 $O(n!)$ 搜索。

BFS 代码：

```cpp
const int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};
struct node {
	int x, y, s;
	node(int _, int __, int _s) :
		x(_), y(__), s(_s) {}
};
void bfs(char k) {
	queue<node> q;
	q.push(node(x[k], y[k], 0)), memset(vis, 0, sizeof vis);
	vis[x[k]][y[k]] = true, dis[k][k] = 0;
	while (!q.empty()) {
		node u = q.front(); q.pop();
		if (isupper(s[u.x][u.y])) dis[k][s[u.x][u.y]] = u.s;
		for (int i = 0; i < 4; i ++) {
			node v(u.x + dx[i], u.y + dy[i], u.s + 1);
			if (v.x >= 1 && v.x <= r && v.y >= 1 && v.y <= c && s[v.x][v.y] != '*' && !vis[v.x][v.y])
				vis[v.x][v.y] = true, q.push(v);
		}
	}
}
for (int i = 1; i <= n; i ++)
	bfs(i + 'A' - 1);
    
// x['A'], y['A']分别是农场A的x与y坐标。
// dis['A']['B']是农场A到B的最短路
```

然鹅又是 TLE ……

一般 $O(n!)$ 搜索的都可以简化成 $O(n2^n)$ 或 $O(n^22^n)$ 的状压 dp，参考[P1171 售货员的难题](https://www.luogu.com.cn/problem/P1171)。

所以可以写出一个状压 dp：

$f_{i,j}$ 为遍历过的农场的集合为 $i$，目前在农场 $j$ 的最短路。

那么有:

$$f_{i,j}=\min_{k\in i}\{f_{i\text{ xor }2^j,k}+dis_{k,j}\}$$

$i\text{ xor }2^j$ 相当于从集合 $i$ 中删去 $j$。

dp 代码：

```cpp
for (int i = 0; i < 1 << c; i ++)
		for (int j = 0; j < c; j ++)
			if (i & 1 << j)
				for (int k = 0; k < c; k ++)
					if (j != k && (i & 1 << k))
						if (f[i][j] > f[i ^ 1 << j][k] + dis[k + 'A'][j + 'A'])
							f[i][j] = f[i ^ 1 << j][k] + dis[k + 'A'][j + 'A'];
```

然鹅，你发现要求路径……那么可以建一个字符串数组统计。


当 $f_{i,j}$ 有更优时，要更新路径；当它们相等且新的路径字典序更小时，也要更新。

~~感觉像写大模拟qwq~~

Code:

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 17, M = 505, dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};
struct node {
	int x, y, s;
	node(int _, int __, int _s) :
		x(_), y(__), s(_s) {}
};
int f[1 << N][N], dis[M][M], x[M], y[M], n, m, c, ans = 114514;
char s[M][M];
bool vis[M][M];
string str, path[1 << N][N];
void bfs(char k) {
	queue<node> q;
	q.push(node(x[k], y[k], 0)), memset(vis, 0, sizeof vis);
	vis[x[k]][y[k]] = true, dis[k][k] = 0;
	while (!q.empty()) {
		node u = q.front(); q.pop();
		if (isupper(s[u.x][u.y])) dis[k][s[u.x][u.y]] = u.s;
		for (int i = 0; i < 4; i ++) {
			node v(u.x + dx[i], u.y + dy[i], u.s + 1);
			if (v.x >= 1 && v.x <= n && v.y >= 1 && v.y <= m && s[v.x][v.y] != '*' && !vis[v.x][v.y])
				vis[v.x][v.y] = true, q.push(v);
		}
	}
}
int main() {
	cin >> n >> m >> c;
	memset(f, 0x3f, sizeof f);
	for (int i = 1; i <= n; i ++)
		for (int j = 1; j <= m; j ++) {
			cin >> s[i][j];
			if (isupper(s[i][j]))
			 	x[s[i][j]] = i, y[s[i][j]] = j;
		}
	for (int i = 1; i <= c; i ++)
		bfs(i + 'A' - 1);
	f[1][0] = 0, path[1][0] = "A";
	for (int i = 0; i < 1 << c; i ++)
		for (int j = 0; j < c; j ++)
			if (i & 1 << j)
				for (int k = 0; k < c; k ++)
					if (j != k && (i & 1 << k))
						if (f[i][j] > f[i ^ 1 << j][k] + dis[k + 'A'][j + 'A']) {
							f[i][j] = f[i ^ 1 << j][k] + dis[k + 'A'][j + 'A'];
							path[i][j] = path[i ^ 1 << j][k] + char('A' + j);
						} else if (path[i][j] > (path[i ^ 1 << j][k] + char('A' + j)) && f[i][j] == f[i ^ 1 << j][k] + dis[k + 'A'][j + 'A'])
							path[i][j] = path[i ^ 1 << j][k] + char('A' + j);
	for (int i = 1; i < c; i ++)
		if (ans > f[(1 << c) - 1][i]) {
			ans = f[(1 << c) - 1][i];
			str = path[(1 << c) - 1][i];
		} else if (str > path[(1 << c) - 1][i] && ans == f[(1 << c) - 1][i])
			str = path[(1 << c) - 1][i];
	cout << ans << '\n' << str << '\n';
	return 0;
}
```


---

## 作者：Cesare (赞：2)

$update:$ 修改部分措辞与排版。

再 $update:$ 删除了某些对出题人不敬的用语，增加了小标题。~~大爷我错了，让我过吧~~

## $Solution$

状压 $dp$ + 最短路。

### 状压 $dp$ 部分

设 $f_{i, S}$ 表示当前在 $i$ ，走过仓库的状态为 $S$ 走的最短距离。 

有转移

$$f_{j, S | (1 << j - 1)} = min (f_{j, S | (1 << j - 1))}, f_{i, S} + dis_{i, j})$$

## 最短路部分

我们发现只需要对于 $k$ 个点求到其他点的最短路就可以了，存下来之后直接 $dp$ 。 

但还有一个问题，本题要求输出走的方案，还要求字典序最小。

对于这个问题，用一个 $string$ 存一下中间每一步转移方案的最小字典序，转移的时候顺便比一下就是了。

但是出题人卡了空间，导致了这种做法 $MLE$ 。

~~我也不知道是不是我不太会卡空间才没卡过去。~~

所以考虑另一种做法：先 $dp$ 一遍， $dp$ 完之后把所有最优的答案都 $dfs$ 他能从哪里转移到，然后存下这个答案。

如此，开 $O2$ 勉强 * 过。

## $Code:$

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include <bits/stdc++.h>
//#include <tr1/unordered_map>
//#include"Bignum/bignum.h"
//#define lll bignum
#define lowbit(x) (x & -x)
#define debug(x) (cout << "#x = " << (x) << endl)
#define Set(x, i) memset (x, i, sizeof(x))
#define R register
#define For(i, j, k) for(R int i = (j), ED = (k); i <= ED; ++i)
#define Rep(i, j, k) for(R int i = (j), ED = (k); i >= ED; --i)
#define Cross(i, j, k) for(R int i = (j); i; i = (k))
using namespace std;
typedef long long ll;
const ll N = 511;
const ll INF = 5e16;

namespace IO {

    inline char gc() {
        static char buf[100000], *p1 = buf, *p2 = buf;
        return (p1 == p2) && (p2 = (p1 = buf) +
            fread (buf, 1, 100000, stdin), p1 == p2)? EOF: *p1++;
    }

    #define dd ch = getchar()
    inline ll read() {
        R ll x = 0; R int f = 0; R char dd;
        for (; !isdigit (ch); dd) f ^= (ch == '-');
        for (; isdigit (ch); dd)  x = x * 10 + (ch ^ 48);
        return f? -x: x;
    }
    #undef dd

    inline void write( ll x ) {
        if (x < 0) putchar ('-'), x = -x;
        if (x > 9) write (x / 10); putchar (x % 10 | 48);
    }

    inline void wrn ( ll x ) { write (x); putchar (' '); }

    inline void wln ( ll x ) { write (x); putchar ('\n'); }

    inline void wlnn ( ll x, ll y ) { wrn (x), wln (y); }

}

using IO::wln;
using IO::read;

namespace Cesare {
    
    const ll M = 31;
    
	char mp[N][N];
    string S = "";
    ll n, m, k, CC, pos, Ans = INF;
    ll Dis[N][N], f[M][(1 << 16) + 2];
    
    
    struct Node {
        ll x, y;
    } Way[N];
    
    struct Alb {
        ll x, y;
    };
    
    /*
        设 f[i][S] 表示当前在 i ， 
        走过仓库的状态为 S 走的最短距离。 
        if (!(S & (1 << j - 1))) 
            f[j][S | (1 << j - 1)] = 
                min (f[j][S | (1 << j - 1))], f[i][S] + Dis[i][j])
        预处理 i -> j 的最短路即可。 
    */
    
    const ll dx[] = { 1, 0, -1, 0 };
    const ll dy[] = { 0, 1, 0, -1 };
    
    ll D[N][N], Vis[N][N];
    
    inline ll bfs ( ll sx, ll sy ) {
        Set (Vis, 0);
        Set (D, 0x3f);
        queue <Alb> Q;
        Q.push((Alb) { sx, sy });
        D[sx][sy] = 0; Vis[sx][sy] = 1;
        while (!Q.empty()) {
            Alb T = Q.front(); 
            Q.pop(); 
            for (R int i = 0; i < 4; ++i) {
                ll nx = T.x + dx[i], ny = T.y + dy[i];
                if (nx <= 0 || nx > n || ny <= 0 || ny > m) continue;
                if (Vis[nx][ny] || mp[nx][ny] == '*') continue;
                Vis[nx][ny] = 1; Q.push((Alb) { nx, ny });
                D[nx][ny] = D[T.x][T.y] + 1;
            }
        } return INF;
    }
    
    inline void dfs ( ll i, ll St, string K ) {
    	K.insert(0, 1, (char) (i + 'A' - 1));
    	if (St == 1) {
    		if (S == "") S = K;
    		else if (S > K) S = K;
			return ;
		}
    	ll NS = St - (1 << i - 1);
    	For ( j, 1, CC ) 
            if ((NS & (1 << j - 1)) && 
                f[i][St] == f[j][NS] + Dis[j][i]) dfs (j, NS, K);
    }
    
//    inline void Print ( ll i, ll S ) {
//        A[++K] = i;
//        if (i == 1ll) return ;
//        Print (xzy[i][S], S ^ (1ll << i - 1ll)); 
//    }
    
    void main() {
        Set (f, 0x3f); 
        n = read(), m = read(), k = CC = read();
        For ( i, 1, n ) For ( j, 1, m ) cin >> mp[i][j];
        For ( i, 1, n ) For ( j, 1, m ) 
            if (mp[i][j] >= 'A' && mp[i][j] <= 'Z') 
                Way[mp[i][j] - 'A' + 1] = (Node) { i, j };
        For ( i, 1, CC ) {
            bfs (Way[i].x, Way[i].y);
            For ( j, 1, CC ) Dis[i][j] = D[Way[j].x][Way[j].y];
        }
        f[1][1] = 0;
        ll Max = (1 << CC) - 1;
        For ( St, 1, Max ) For ( i, 1, CC ) For ( j, 1, CC ) {
            ll I = 1 << i - 1, J = 1 << j - 1;
            if ((St & I) && (!(St & J))) 
                f[j][St | J] = min (f[j][St | J], f[i][St] + Dis[i][j]);
        }
        For ( i, 1, CC ) Ans = min (Ans, f[i][Max]);
        wln (Ans);
        For ( i, 1, CC ) if (Ans == f[i][Max]) dfs (i, Max, "");
        cout << S << endl, exit (0);
    }
    
}

int main()
{
    return Cesare::main(), 0;
}

/*

*/

```

---

## 作者：Mr_think (赞：1)

## [P4772 灰化肥，会挥发](https://www.luogu.com.cn/problem/P4772)

## 题目大意：
给出一矩阵，求经过所有仓库的最短路。

## solution:

看到很小的 $n$ 的范围，我们考虑状压。跟 [P4802 [CCO 2015]路短最](https://www.luogu.com.cn/problem/P4802) 不同的是，本题给出了矩阵，所以我们考虑如何建图:
	
我们从每个点出发，进行 $\text{BFS}$ ，这样就可以愉快的状压了。

设**状态** $f[\,i\,][\,j\,]$ 为当前状态为 $\,i\,$ 走到了 $\,j\,$ 点的最短路径长，$g[\,i\,][\,j\,]$ 为当前状态为 $\,i\,$ 走到了 $\,j\,$ 点的最小字典序路径。

至于路径长，~~易得~~状态转移方程为：
   $$f[\,i\,][\,j\,]= \text{max}(f[\,i\,][\,j\,],f[\,i\, \bigoplus\,(1\ll j)][\,k\,]+dis[\,k\,][\,j\,]) $$
   
思考一下最小字典序路径，这里 $g[\,i\,][\,j\,]$ 我用的是 $\text{string}$ 类型，方便字符串的拼接与比较。转移我们考虑两种情况：

1. 当前最短路更新了，相应的路径也要更新。
2. 当前最短路无法更新，但与原状态相等，并且当前的路径字典序较小，可更新。

## 细节处理：
- 只能从 $\text{A}$ 点出发。
- 最后统计答案要赋个极大值。

看到这的同学，可以自己去写代码了(~~tf口吻~~)

[code](https://www.luogu.com.cn/paste/jk067sgm)

### End

---

## 作者：Exber (赞：1)

## 做法
状压 DP+BFS。

首先由于各个仓库之间的距离是不会改变的，所以需要先用 BFS 初始化一下各个仓库之间的距离。

因为 $n\le16$，所以考虑状压。

可以用一个二进制数来表示各个仓库有没有去过，例如 `1010001` 就表示第 `1`、`3` 和 `7` 号仓库去过。

因为就算状态一样，最终停留的仓库不同所需要走的距离也不同，所以用 $dp_i$ 表示状态为 $i$ 所需要走的最短距离显然是不行的。那么就需要增加一维，用 $dp_{i,j}$ 来表示状态为 $i$，现在位于 $j$ 号仓库所需要走的最短距离。那么很显然可以借鉴一下 `Floyd` 算法的思路来更新 `dp` 数组：枚举一个中间点 $k$来更新 $dp_{i,j}$。

最后就剩下输出字典序最小的路径这个棘手的任务了。可以用一个 `string` 类型的数组 `path` 来存路径。$path_{i,j}$ 表示状态为 $i$，现在位于 $j$ 号仓库的字典序最小的最短路径。那么在对 `dp` 数组进行更新的时候顺便更新一下 `path` 数组就行了。需要注意的是，当最短路径长度相同时，需要取字典序最小的路径。

## AC 代码
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <cstring>

using namespace std;

struct node
{
	int x,y,step;
};

int r,c,n,dis[20][20],xs[20],ys[20],dx[4]={0,0,1,-1},dy[4]={1,-1,0,0},dp[1<<16][20];
bool mp[505][505],vis[505][505];
string path[1<<16][20];

void bfs(int s) // bfs 初始化 s 号仓库到其它仓库的最短距离 
{
	int sx=xs[s],sy=ys[s];
	memset(vis,0,sizeof(vis));
	queue<node> q;
	q.push((node){
		sx,sy,0
	});
	vis[sx][sy]=true;
	while(!q.empty())
	{
		node now=q.front();
		q.pop();
		for(int i=1;i<=n;i++)
		{
			if(now.x==xs[i]&&now.y==ys[i])
			{
				dis[s][i]=now.step;
				dis[i][s]=now.step;
				break;
			}
		}
		for(int i=0;i<4;i++)
		{
			int nx=now.x+dx[i],ny=now.y+dy[i];
			if(nx<1||nx>r||ny<1||ny>c||mp[nx][ny]||vis[nx][ny])
			{
				continue;
			}
			vis[nx][ny]=true;
			q.push((node){
				nx,ny,now.step+1
			});
		}
	}
}

int main()
{
	scanf("%d%d%d",&r,&c,&n);
	for(int i=1;i<=r;i++)
	{
		for(int j=1;j<=c;j++)
		{
			char ch;
			scanf(" %c",&ch);
			if(ch=='*')
			{
				mp[i][j]=true;
			}
			if(ch>='A'&&ch<='Z')
			{
				int num=ch-'A'+1; 
				xs[num]=i;
				ys[num]=j;
			}
		}
	}
	memset(dis,-1,sizeof(dis));
	for(int i=1;i<=n;i++)
	{
		bfs(i);
	}
	memset(dp,127,sizeof(dp));
	dp[1][1]=0;
	path[1][1]="A"; // 刚开始只有 A 在路径里 
	for(int i=2;i<=(1<<n)-1;i++)
	{
		if(!(i&1))
		{
			continue;
		}
		for(int j=1;j<=n;j++)
		{
			if(!(i&(1<<j-1)))
			{
				continue;
			}
			for(int k=1;k<=n;k++)
			{
				if(k==j||dis[k][j]==-1||!(i&(1<<k-1)))
				{
					continue;
				}
				int cost=dp[i-(1<<j-1)][k]+dis[k][j];
				string npath=path[i-(1<<j-1)][k]+(char)(j+'A'-1);
				if(
				cost<dp[i][j] // 如果路径更短 
				||(cost==dp[i][j]&&path[i][j]>npath) // 如果路径一样长并且字典序更小 
				)
				{
					dp[i][j]=cost;
					path[i][j]=npath;
				}
			}
		}
	}
	int minn=0,last=(1<<n)-1;
	for(int i=1;i<=n;i++)
	{
		if(
		dp[last][i]<dp[last][minn]
		||(dp[last][i]==dp[last][minn]&&path[last][i]<path[last][minn])
		)
		{
			minn=i; // 找一条最短且字典序最小的路径 
		}
	}
	printf("%d\n%s\n",dp[last][minn],path[last][minn].c_str());
	return 0;
}
```


---

## 作者：Suffix_Sum (赞：0)

不太难的蓝题，整体来说比较好想。

看到 $1 \leq N \leq 16$，就很容易想到状态压缩。

首先预处理出每个点到每个点的距离，然后状压，$f[i][j]$ 代表上一个的点是 $\texttt{A}+i-1$，现在到了 $j$ 个点，找当前的最小距离，每次转移用之前预处理的距离，我这里用的是我为人人，然后输出怎么走，这里如果转移过去值的要小于当前值，那么把另一个数组 $last[x][y]$ 换成 $last[i][j]$ 插入 $\texttt{A}+x-1$，然后结尾直接输出就行了，时间复杂度 $O(N2^N)$，空间复杂度同样 $O(N2^N)$。

```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstring>
#include<queue>
#include<stack>
#include<iomanip>
#define int long long
using namespace std;
int n,m,t;
vector<pair<int,pair<int,int> > >v;
char mp[505][505];
int f[30][100001];
string last[30][100001];
int dis[30][30],vis[505][505];
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
int cnt=0;
void bfs(int p)//预处理距离
{
	memset(vis,-1,sizeof(vis));
	queue<pair<int,int> >q;
	vis[v[p].second.first][v[p].second.second]=0;
	q.push(make_pair(v[p].second.first,v[p].second.second));
	while(!q.empty())
	{
		int x=q.front().first,y=q.front().second;
		if(mp[x][y]>='A'&&mp[x][y]<='Z')
		{
			dis[v[p].first][mp[x][y]-'A'+1]=vis[x][y];
		}
		for(int i=0;i<4;i++)
		{
			int xx=x+dx[i],xy=y+dy[i];
			if(vis[xx][xy]!=-1||xx<1||xx>n||xy<1||xy>m||mp[xx][xy]=='*')
			{
				continue;
			}
			vis[xx][xy]=vis[x][y]+1;
			q.push(make_pair(xx,xy));
		}
		q.pop();
	}
}
signed main()
{
	memset(dis,0x3f3f3f3f,sizeof(dis));
	cin>>n>>m>>t;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>mp[i][j];
			if(mp[i][j]>='A'&&mp[i][j]<'Z')
			{
				cnt+=(1<<(mp[i][j]-'A'));
				v.push_back(make_pair(mp[i][j]-'A'+1,make_pair(i,j)));//每一个字符都放进桶里
			}
		}
	}
	for(int i=0;i<t;i++)//枚举每一个起点
	{
		bfs(i);
	}
	memset(f,0x3f,sizeof(f));//把f初始化
	f[1][1]=0;//起始点是'A'
	last[1][1]+='A';
	for(int j=1;j<cnt;j++)
	{
		for(int it=0;it<v.size();it++)
		{
			int i=v[it].first;
			if((j&(1<<(i-1)))==0)
			{
				continue;
			}
			for(int kt=0;kt<v.size();kt++)
			{
				int k=v[kt].first;
				if((j&(1<<(k-1)))!=0)//没有
				{
					continue;
				}
				if(f[k][j+(1<<(k-1))]>f[i][j]+dis[i][k])
				{
					f[k][j+(1<<(k-1))]=f[i][j]+dis[i][k];
					last[k][j+(1<<(k-1))]=last[i][j]+char(k+'A'-1);
				}
				if(f[k][j+(1<<(k-1))]==f[i][j]+dis[i][k]&&last[k][j+(1<<(k-1))]>last[i][j]+char(k+'A'-1))
				{
					last[k][j+(1<<(k-1))]=last[i][j]+char(k+'A'-1);
				}
				if(f[k][j+(1<<(k-1))]==f[i][j]+dis[i][k]&&last[k][j+(1<<(k-1))].size()==0)
				{
					f[k][j+(1<<(k-1))]=f[i][j]+dis[i][k];
					last[k][j+(1<<(k-1))]=last[i][j]+char(k+'A'-1);
				}
			}
		}
	}
	f[0][cnt]=0x3f3f3f3f3f;
	int minnid=0;
	for(int i=1;i<=t;i++)
	{
		if(f[i][cnt]<f[minnid][cnt])
		{
			minnid=i;
		}
	}
	cout<<f[minnid][cnt]<<endl;
	string ans=last[minnid][cnt];
	for(int i=1;i<=t;i++)
	{
		if(last[i][cnt]<ans&&f[i][cnt]==f[minnid][cnt]&&last[i][cnt].size()!=0)
		{
			ans=last[i][cnt];
		}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Exschawasion (赞：0)

简明题意如下：

- 给定一个 $R \times C$ 的字符矩阵作为地图。包含 $N$ 个字母作为节点；
- 求一条从 $\text{A}$ 节点开始走过所有节点的道路，使得**路径最短**，在此前提下使得经过的节点编号序列的**字典序**最小。

***

求解此题需要先了解[**哈密顿路径**](https://oi-wiki.org/graph/hamilton/)（$\texttt{Hamilton Path}$，也称哈密顿通路）。指一条简单路径**不重复**地经过**所有节点**仅一次。包含哈密顿路径的图称作**哈密顿图**。数据保证有解，因此这张地图必然是一张哈密顿图。

求最短路径的问题便是**最短哈密顿路径问题**。最短哈密顿路径就是所有哈密顿路径中最短的一条。为了方便求解，假设已经知道每个节点到其他所有节点的边的长度，可以将这个地图建成一张图。

求解最短哈密顿路径问题通常使用状态压缩 $\texttt{dp}$。具体这里不做过多的讲解，只作简单介绍，若需要模板练习可以尝试 [P4802 短路最](https://www.luogu.org/problem/P4802)。

因为 $N \leq 16$，且需要随时记录每一个点是否有到达过，考虑状压。用一个整数 $S$ 来记录，设二进制表示下第 $k$ 位为 $S_k$，表示节点 $k$ 是否到达过。则状态可以用一个二元组 $(S, \text{pos})$ 表示，$\text{pos}$ 表示当前处于哪个点。需要注意，这里的 $\text{pos}$ 一维不可少。

用 $S^{\prime}_i$ 表示将 $S$ 二进制表示下的第 $i$ 位设为 $1$ 后的值，设集合 $U_v$ 表示所有从节点 $v$ 出发能到达的未访问过节点的集合，那么状态转移如下：

$$
\forall i \in U_k~~~~
(S, k)
\rightarrow
(S^{\prime}_i, i)+E_{k,i}
$$

其中，$E_{k,i}$ 表示连接节点 $k$ 和节点 $i$ 的边的长度。

题目还要求输出字典序最小的路径。如果使用**记忆化搜索**来计算上面的状态转移的话，就可以相对容易的解决。办法是记录**当前状态的最优后继状态**，由于初始状态和终止状态都是确定的，就可以通过递推来计算出路径。

具体可以结合代码实现来更好地理解。

最后还有一个问题：如何把字符矩阵建成一张图。这个问题不难解决：对于每个节点，使用 $\texttt{BFS}$ 来得到该节点到其它节点的最短路径长度即可。总共需要进行 $N$ 次 $\texttt{BFS}$，时间复杂度为 $O(NRC)$，可以承受。

代码实现：

```
#include <bits/stdc++.h>

using namespace std;

const int maxn = 16 + 1;

int r, c, n;
char org[500 + 5][500 + 5];
int stp[500 + 5][500 + 5];
bool vis[500 + 5][500 + 5];

int posx[maxn], posy[maxn];

int tot = 0;
int head[550], nxt[550], ver[550], w[550];
void add(int x, int y, int v) {
	tot++, ver[tot] = y, w[tot] = v, nxt[tot] = head[x], head[x] = tot;
}

struct Rec {
	int x, y, step;
};

int dx[4] = { -1, 1, 0, 0 };
int dy[4] = { 0, 0, 1, -1 };

inline bool valid(int x, int y) { // 判断 (x,y) 是否越界或不能行走
	return org[x][y] != '*' && x > 0 && y > 0 && x <= r && y <= c;
}

void bfs(int sx, int sy) { // BFS 找最短路
	Rec rec;
	rec.x = sx, rec.y = sy, rec.step = 0;
	vis[sx][sy] = true;
	queue<Rec> q;
	q.push(rec);
	while(!q.empty()) {
		rec = q.front(); q.pop();
		stp[rec.x][rec.y] = rec.step;
		for(int i = 0; i < 4; i++) {
			int nx = rec.x + dx[i], ny = rec.y + dy[i];
			if(valid(nx, ny) && !vis[nx][ny]) vis[nx][ny] = true, q.push((Rec){nx, ny, rec.step + 1});
		}
	}
}

void read_map() {
	char x;
	cin >> r >> c >> n;
	for(int i = 1; i <= r; i++) {
		for(int j = 1; j <= c; j++) {
			cin >> x;
			if(isalpha(x)) { // 是字母
				posx[x - 'A' + 1] = i;
				posy[x - 'A' + 1] = j;
				org[i][j] = '.';
			}
			else {
				org[i][j] = x;
			}
		}
	}
}
int S;

int f[1 << 16][maxn];
int fbest[1 << 16][maxn];
int pos;
int dp() {
	if(S == (1 << n) - 1) { // 终止状态
		return 0;
	}
	else {
		int ret = 0x3f3f3f3f;
		if(f[S][pos] != -1) return f[S][pos];
		
		int bk = pos;
		int best_step = 0xff; // 最佳后继决策
		
		for(int i = head[pos]; i; i = nxt[i]) {
			int to = ver[i], len = w[i];
			if(!(S & (1 << (to - 1)))) {
				S |= (1 << (to - 1));
				pos = to;
				int aft = dp() + len; // 计算下一阶段
				if(aft <= ret && best_step >= to) {
					// 更优的解法：先判断路径是否更短，如果是判断字典序是否更小
					// 注意这里的 <= 号不能写成 <
					ret = aft;
					best_step = to;
				}
				S &= ~(1 << (to - 1));
			}
		}
		pos = bk;
		fbest[S][pos] = best_step; // 保存当前状态的最佳后继决策
		return f[S][pos] = ret;
	}
}

// 写成一个 get 函数更方便调用
int get(int x) {
	S = 1 << (x - 1);
	pos = x;
	return dp();
}

void weedy(int x) {
	S |= 1 << (x - 1);
	pos = x; // 初始状态
	cout << (char)(x + 'A' - 1);
	for(int i = 1; i < n; i++) { // 找 n 个点需要循环 n-1 次
		int nxtpt = fbest[S][pos]; // 找到当前状态的最佳后继选择
		pos = nxtpt; // 更新状态
		S |= 1 << (pos - 1);
		cout << (char)(nxtpt + 'A' - 1);
	}
}

int main() {
	read_map();
	
	for(int node = 1; node <= n; node++) {
		memset(vis, false, sizeof(vis));
		memset(stp, 0, sizeof(stp));
		bfs(posx[node], posy[node]);
		for(int i = node + 1; i <= n; i++) { // 注意添加双向边
			if(i != node) {
				add(i, node, stp[posx[i]][posy[i]]);
				add(node, i, stp[posx[i]][posy[i]]);
			}
		}
	}
	
	memset(f, -1, sizeof(f));
	cout << get(1) << endl;
	weedy(1);
	return 0;
}
```

经过一定的优化，目前这份代码已经能够比较快地通过本题了。具体可见[评测记录](https://www.luogu.com.cn/record/69312138)。

---

## 作者：Fan_Tuan (赞：0)

### 题意：
给定一个 $r \times c$ 的矩阵，求从 $A$ 仓库出发经过所有仓库的最短路径长度，和字典序最小的一个方案路径。

### 思路：
发现 $n$ 很小，考虑状压。

设 $f[S][i]$ 表示在 $S$ 这个状态最后到达 $i$ 点的最短路径长度。

得到转移 $f[S|(1<<j-1)][j] = \min(f[S][i]+Dis[i][j])$。

其中 $j$ 表示到达 $S|(1<<j-1)$ 这个状态的最后一个点，$i$ 表示转移到这个状态的上一个点，$Dis[i][j]$ 表示 $i$ 到 $j$ 的最短路径长度，可以用 BFS 暴力求出来。

考虑用一个结构体记录路径，$g[S][i].prei$，$g[S][i].pres$ 表示的是以 $i$ 结尾的状态 $S$ 时由以 $prei$ 结尾的状态 $pres$ 转移而来的，那么我们就可以用递归将整条路径输出出来。

还要保证字典序最小，在转移 $f$ 的时候，如果 $f[S|(1<<j-1)][j] > f[S][i] + Dis[i][j]$，那么我们直接把 $g$ 更新掉，如果 $f[S|(1<<j-1)][j] = f[S][i] + Dis[i][j]$，直接暴力把两条路径求出来比较大小，如果新路径字典序更小就更新 $g$，否则不更新。可以用递归实现。

### 主要代码：
```cpp

int n, r, c, a[510][510], f[(1 << 16)][17], tot, vis[510][510]; 

struct kk {
    int pres, prei;
}g[(1 << 16)][17];

struct node {
    char c;
    int x, y;
}u, t, C[17];

int dis[510][510], Dis[17][17];
int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};

void bfs(int s) {
    memset(dis, 0x3f, sizeof dis);
    queue<node> q;
    dis[C[s].x][C[s].y] = 0;
    q.push(C[s]);
    while (!q.empty()) {
        u = q.front();
        q.pop();
        for (int i = 0; i <= 3; i++) {
            t.x = u.x + dx[i], t.y = u.y + dy[i];
            if (t.x >= 1 && t.x <= r && t.y >= 1 && t.y <= c && dis[t.x][t.y] == 0x3f3f3f3f && vis[t.x][t.y]) {
                dis[t.x][t.y] = dis[u.x][u.y] + 1;
                q.push(t);
            }
        }
    }
}

void dfs(int S, int i, string &res) {
    if (!S) return ;
    dfs(g[S][i].pres, g[S][i].prei, res);
    res += char('A' + i - 1);
}

signed main() {
    r = read(), c = read(), n = read();
    for (int i = 1; i <= r; i++)
        for (int j = 1; j <= c; j++) {
            char c;
            cin >> c;
            if (c == '.') vis[i][j] = 1;
            else if (c != '*') C[c - 'A' + 1] = node{c, i, j}, vis[i][j] = 1; 
        }
    for (int i = 1; i <= n; i++) {
        bfs(i);
        for (int j = 1; j <= n; j++) 
            Dis[i][j] = dis[C[j].x][C[j].y];
    }
    memset(f, 0x3f, sizeof f);
    f[1][1] = 0;
    for (int S = 0; S < (1 << n); S++) {
        for (int i = 1; i <= n; i++) {
            if (!(S & (1 << i - 1))) continue;
            for (int j = 1; j <= n; j++) {
                if (S & (1 << j - 1)) continue;
                int T = (S | (1 << j - 1));
                if (f[T][j] > f[S][i] + Dis[i][j]) {
                    f[T][j] = f[S][i] + Dis[i][j];
                    g[T][j].prei = i, g[T][j].pres = S;
                }
                else if (f[T][j] == f[S][i] + Dis[i][j]) {
                    string res1, res2;
                    dfs(T, j, res1);
                    int x = g[T][j].prei, y = g[T][j].pres;
                    g[T][j].prei = i, g[T][j].pres = S;
                    dfs(T, j, res2);
                    if (res1 < res2) g[T][j].prei = x, g[T][j].pres = y;
                }
            }
        }
    }
    int Ans1 = 1000000000, Ans2;
    string Anss;
    for (int i = 1; i <= n; i++) 
        if (f[(1 << n) - 1][i] < Ans1) Ans1 = f[(1 << n) - 1][i], Ans2 = i;
        else if (f[(1 << n) - 1][i] == Ans1) {
            string res1, res2;
            dfs((1 << n) - 1, Ans2, res1);
            dfs((1 << n) - 1, i, res2);
            if (res2 < res1) Ans2 = i;
        }
    print(Ans1), putchar('\n');
    dfs((1 << n) - 1, Ans2, Anss);
    cout << Anss;
    return 0;
}
```

---

## 作者：loverintime (赞：0)

这道题 $N$ 的范围比较小， 容易想到状压。 状态定义如下：

$f(S,i)$ 表示走过 $S$ 集合中的仓库， 现在正在 $i$ 仓库的最短距离

设 $i,j$ 仓库的距离为 $dis_{i,j}$, 这个可以通过 $bfs$ 在 $\Theta(NRC)$ 的时间内求出来。

容易得到转移方程：

$\large f(S,i)=\min_{j\in S\wedge j\neq i}\{f(S-\{i\},j)+dis_{j,i}\}$

由于本题要输出字典序最小的方案， 我们令 $g(S,i)$ 表示 $f(S,i)$ 这个状态时的最小字典序方案， 转移顺便更新即可。

边界是 $f(\{1\},0)=0, g({1},0)=A$

## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=505;
struct point{
	int x,y,step;
	point(int _=0,int __=0,int ___=0){
		x=_,y=__,step=___;
	}
};
int dis[19][19];
queue <point> q;
int n,m,r,vis[N][N];
char s[N][N];
int px[5]={1,-1,0,0},py[5]={0,0,1,-1};
bool isab(char s){
	return 'A'<=s&&s<='Z';
}
void bfs(int x,int y,int a){
	queue <point> k;swap(k,q);memset(vis,0,sizeof vis);
	q.push(point(x,y,0));
	while(!q.empty()){
		point c=q.front();q.pop();
		int nx=c.x,ny=c.y;
		if(vis[nx][ny]) continue;
		vis[nx][ny]=1;
		if(isab(s[nx][ny])){
			dis[a][s[nx][ny]-'A']=c.step;
		}
		for(int i=0; i<4; i++){
			int ux=nx+px[i],uy=ny+py[i];
			if(ux<0||uy<0||ux>=n||uy>=m||s[nx][ny]=='*') continue;
			q.push(point(ux,uy,c.step+1));
		}
	}
}
int f[(1<<16)+1][17];
string ans[(1<<16)+1][17];
int main()
{
	scanf("%d%d%d",&n,&m,&r);
	for(int i=0; i<n; i++) scanf("%s",s[i]);
	for(int i=0; i<n; i++){
		for(int j=0; j<m; j++){
			if(isab(s[i][j])){
				bfs(i,j,s[i][j]-'A');
			}
		}
	}
	memset(f,0x3f,sizeof f);
	f[1][0]=0;ans[1][0]+='A';
	for(int s=1; s<(1<<r); s++){
		for(int i=0; i<r; i++){
			if((1<<i)&s){
				for(int j=0; j<r; j++){
					if(j!=i&&((1<<j)&s)){
						if(f[s][i]>f[s&(~(1<<i))][j]+dis[j][i]){
							f[s][i]=f[s&(~(1<<i))][j]+dis[j][i];
							ans[s][i]=ans[s&(~(1<<i))][j]+(char)(i+'A');
						}
						else if(f[s][i]==f[s&(~(1<<i))][j]+dis[j][i]&&ans[s][i]>(ans[s&(~(1<<i))][j]+(char)(i+'A'))){
							ans[s][i]=ans[s&(~(1<<i))][j]+(char)(i+'A');
						}
					}
				}
			}
		}
	}
	int minnum=0,min=0x3f3f3f3f;
	for(int i=0; i<r; i++){
		if(f[(1<<r)-1][i]<min){
			min=f[(1<<r)-1][i],minnum=i;
		}
	}
	printf("%d\n",min);
	cout<<ans[(1<<r)-1][minnum];
	
	return 0;
}


---


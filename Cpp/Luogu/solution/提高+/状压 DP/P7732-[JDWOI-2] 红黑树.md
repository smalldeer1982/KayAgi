# [JDWOI-2] 红黑树

## 题目背景

小 M 迷上了画画，所以她用红色和黑色的画笔画出了一棵红黑树。

## 题目描述

这棵树有 $n$ 个点，从 $1$ 开始标号，其中 $1$ 号点为树根。一开始，小 M 给这 $n$ 个点分别涂上了红色或黑色，第 $i$ 号点的颜色是 $a_i$（'R' 代表红色，'B' 代表黑色）。

但可惜的是，小 M 对这棵树并不是非常满意，她希望第 $i$ 号点的颜色为 $b_i$。

好在她的好朋友小 K 懂得一点点膜法。小 K 可以先选定一个点，然后把这个点的颜色反转（红变黑，黑变红）。但这个膜法太强大了，所以会把膜法传递下去，即在反转的一秒之后使当前点的父节点颜色也进行反转，如此传递，直到根节点为止。特殊的，如果在同一时刻有多个膜法作用在同一个点上，这些膜法会两两抵消，如果恰好抵消完了（即膜法的个数为偶数），则当前点不会变色，并且不会有膜法继续传递下去。注意此处抵消膜法不需要耗时间。

但毕竟小 K 还是个新手，所以他在一秒之内只能最多对一个节点施展上述膜法。

为了尽快让小 M 开心，小 K 想知道，至少经过多少秒才能让这棵红黑树初次出现小 M 的理想颜色状态？可以证明，总可以按题目要求变成理想颜色状态。

## 说明/提示

**【样例解释】**

第一组数据中，小 K 可以在第 $1$ 秒给 $4$ 号点膜法，整个树变为 RRBRR，在第 $2$ 秒给 $5$ 号点膜法，整个树变成 RBBRB，在第 $3$ 秒给 $1$ 号点膜法，整个树变成 BRBRB。

第二组数据中，小 K 可以在第 $1$ 秒给 $5$ 号点膜法，在第二秒给 $2$ 号点膜法；或者在第 $1$ 秒给 $3$ 号点膜法，在第 $2$ 秒给 $5$ 号点膜法。

**【数据范围】**

对于 $10\%$ 的数据，$1\leq n\leq 5$；

对于 $30\%$ 的数据，$1\leq n\leq 10$；

对于另外 $20\%$ 的数据，$\forall a_i\neq b_i$；

对于 $100\%$ 的数据，$1\leq n\leq 20$，$1\leq Q\leq 20$，树随机生成。

## 样例 #1

### 输入

```
2
5
RRBBR
1 2
1 3
2 4
2 5
BRBRB
5
RRRRR
1 2
2 3
3 4
4 5
BBBBB```

### 输出

```
3
3```

# 题解

## 作者：Nights_watcher (赞：3)

一眼看到 $n\le20$，便可以想到状压 DP。

很显然，$dp_{i,j}$ 表示第 $i$ 秒，状态是否可以为 $j$。但是如果按照常规方法转移，时间复杂度为 $O(Qn^32^n)$，直接爆炸。

于是我们想一下优化。我们可以将现有的所有操作都延迟一秒去做，这样它们影响的总时间不变，这时再在第一秒插入一个新的操作，这样影响的时间就为现在枚举到的时间。

我们可以预处理出一个数组表示在每个点使用魔法后每秒影响到的状态。转移时异或即可。

代码如下
```cpp
#include <bits/stdc++.h>
using namespace std;
int q , n , fa[21] , s[21][21];
bool dp[21][1 << 20];
string S;
vector <int> ve[21];
void dfs (int u , int f)
{
	fa[u] = f;
	for (int v : ve[u])
		if (v != f) dfs (v , u);
}
int main ()
{
	ios :: sync_with_stdio (false);
	cin.tie (0);
	cout.tie (0);
	cin >> q;
	while (q --)
	{
		cin >> n >> S;
		for (int i = 1;i <= n;i ++) ve[i].clear ();
		for (int i = 1;i < n;i ++)
		{
			int u , v;
			cin >> u >> v;
			ve[u].push_back (v);
			ve[v].push_back (u);
		}
		dfs (1 , 0);
		for (int i = 1;i <= n;i ++)
			for (int j = 1 , k = i;j <= n;j ++ , k = fa[k])
				if (k) s[i][j] = s[i][j - 1] ^ (1 << k - 1);
				else s[i][j] = s[i][j - 1];
		int ed = 0;
		for (int i = 1;i <= n;i ++)
		{
			char c;
			cin >> c;
			if (c != S[i - 1]) ed ^= (1 << (i - 1));
		}
		dp[0][0] = 1;
		for (int i = 0;i <= n;i ++)
		{
			if (dp[i][ed])
			{
				cout << i << "\n";
				memset (dp[i] , 0 , sizeof (dp[i]));
				break;
			}
			for (int j = 0;j < (1 << n);j ++)
				if (dp[i][j])
				{
					dp[i][j] = 0;
					dp[i + 1][j] = 1;
					for (int k = 1;k <= n;k ++) dp[i + 1][j ^ s[k][i + 1]] = 1;
				}
		}
	}
	return 0;
}
```

---

## 作者：_Cheems (赞：2)

### 题意
给定一棵树，每个点有 $0/1$ 两状态。每个时刻可以选择一点翻转颜色，并在下个时刻把“翻转”传递到父亲，两个“翻转”同时在一起会抵消。

给定初始状态，求最少第几时刻可以抵达目标状态？
### 思路
写的比较详细，希望能讲明白。

看到数据范围，优先考虑状压 $\rm dp$。但是朴素写法需记录 每个点的颜色 和 还在传递的点，显然不对。

先把初始状态和目标状态异或一下得到操作序列 $C$，那么题意可以转化为 初始全为 $0$ 需抵达 $C$ 状态。这是为了方便下文讨论。

直观地想，答案应该不会太大。事实正是如此：考虑把 $C$ 放在树上，那么一定可以将其划分为 $\le \frac n2$ 个连续全 $1$ 链，并且互不相交。对于每一段，只需在起点和终点的父亲上操作即可。所以答案必定 $\le n$。

然后考虑加上 时间 这一维。发现固定结束时间后便容易得到：每个点在某个时刻进行操作，最终所改变颜色的点集。

换句话说，可以考虑将每个点被操作后的影响直接加入状态中。

于是定义 $f_{i,S}$ 表示到第 $i$ 秒，点的颜色状压为 $S$，是否可行？

于是成功省掉了 还在传递的点 这一维。可是又发现，直接枚举被操作的点、操作的时间，还是会超时，不太可做的亚子。

然鹅有个神仙想法：转移时，直接让 $1$ 到 $i$ 的所有操作延迟一秒进行，不难发现对 $S$ 没有影响。然后枚举点，并使其在 $1$ 时刻进行操作。可以发现这样恰好能遍历完所有的可能情况。

然后需要开一个辅助数组 $s_{i,j}$ 表示第 $i$ 点在 $1$ 时刻操作、结束时间为 $j$ 时，被改变颜色的点集，可以预处理出来。

转移方程为：

1. 啥也不干：$f_{i,S}\to f_{i+1,S}$
2. 进行操作：$f_{i,S}\to f_{i+1,S\bigoplus s_{j,i+1}}$

复杂度 $O(qn^2 2^n)$，实际上跑不满，可以通过此题。我的辣鸡程序跑的最慢的点约为 $1.5s$。
### 代码
~~好像没啥好说的。~~

```cpp
#include<bits/stdc++.h>
using namespace std; 

int q, n, u, v, fa[22], s[22][22], beg, lst;
char c[22];
bool f[22][1 << 20];

int main(){
	
	cin >> q;
	while(q--){
		scanf("%d %s", &n, c + 1);
		
		beg = lst = 0;
		for(int i = 0; i <= n;++i){ //最好别用memset 
			fa[i] = 0;
			for(int S = 0; S < 1 << n;++S) f[i][S] = false;
		}
		
		for(int i = 1; i <= n;++i) beg |= (c[i] == 'R') * (1 << i - 1);
		for(int i = 1; i < n;++i) scanf("%d %d", &u, &v), fa[v] = u;
		scanf("%s", c + 1);
		for(int i = 1; i <= n;++i) lst |= (c[i] == 'R') * (1 << i - 1);
		
		for(int i = 1; i <= n;++i)
			for(int j = 1, u = i; j <= n;++j, u = fa[u]) 
				if(u) s[i][j] = s[i][j - 1] | (1 << u - 1);
				else s[i][j] = s[i][j - 1];  
				
		f[0][beg] = true;
		for(int i = 0; i <= n;++i)
			if(f[i][lst]) {printf("%d\n", i); break;}
			else{
				for(int S = 0; S < 1 << n;++S)
					if(f[i][S]){
						f[i + 1][S] = true;
						for(int j = 1; j <= n;++j)
							f[i + 1][S ^ s[j][i + 1]] = true;
					}
			}
	} 
	return 0;
}
```


---

## 作者：myzzym (赞：0)

[原（~~题~~）](https://www.luogu.com.cn/problem/P7732)

# 题意
给定一颗以 $1$ 号点为根的树，每个点有 `R` 和 `B` 两种状态，每秒可以选择一个点翻转颜色（`R` 变 `B`，`B` 变 `R`），并在下一秒让他的父节点也翻转，以此类推，一个点同时翻转两次可以抵消掉。

给定初始状态，求最少第几秒可以抵达目标状态。
# 思路
看到 $n$ 这么小首先想到状压。

设 $f_{i,j}$ 为在第 $i$ 秒时每个节点的颜色，发现很难转移，我们可以认为每种状态就是在第 $x(x\le \text{当前状态的时间})$ 秒翻转哪个颜色（或者不翻转）的操作，怎么转移到下一秒呢？

可以发现，无论在哪个时间翻转一个点，它影响的点一定是取决于它持续的时间，所以我们转移到下一秒可以当成把所有操作推迟一秒，然后在一开始再插入一个操作，只要弄个数组记录翻转第 $i$ 个点后 $j$ 秒影响的点就可以了。

例如：当前在第三秒，每秒的操作为：

| 第一秒 | 第二秒 | 第三秒 |
| -----------: | -----------: | -----------: |
| 翻转 $3$ 节点 | 翻转 $2$ 节点 | 翻转 $5$ 节点 |

转移到第四秒，每秒的操作为：

| 第一秒 | 第二秒 | 第三秒 | 第四秒 |
| -----------: | -----------: | -----------: | -----------: |
| 翻转 $114$ 号节点 | 翻转 $3$ 节点 | 翻转 $2$ 节点 | 翻转 $5$ 节点 |

（第三秒时的每个操作都推迟了一秒）

这样子就能覆盖所有的情况。

剩下的没什么难度，不说了（就难在转移）。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,fa[21],s[21][21],ed,st;
bool f[21][1<<20];
vector<int>G[21];
void dfs(int u,int father){
	fa[u]=father;
	for(int i=0;i<G[u].size();i++){
		int v=G[u][i];
		if(v!=father)
			dfs(v,u);
	}
}
signed main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		st=0,ed=0;
		for(int i=1;i<=n;i++){
			char x;
			cin>>x;
			if(x=='R')
				st=st|(1<<i-1);
			G[i].clear();
		}
		for(int i=1;i<n;i++){
			int u,v;
			scanf("%d%d",&u,&v);
			G[u].push_back(v);
			G[v].push_back(u);
		}
		dfs(1,0);
		for(int i=1;i<=n;i++)
			for(int j=1,k=i;j<=n;j++,k=fa[k])
				if(k)
					s[i][j]=s[i][j-1]^(1<<k-1);
				else
					s[i][j]=s[i][j-1];
		for(int i=1;i<=n;i++){
			char x;
			cin>>x;
			if(x=='R')
				ed=ed|(1<<i-1);
		}
		f[0][st]=1;
		int i;
		for(i=0;i<=n;i++){
			if(f[i][ed]){
				printf("%d\n",i); 
				break;
			}
			for(int j=0;j<(1<<20);j++){
				if(!f[i][j])continue;
				f[i][j]=0,f[i+1][j]=1;
				for(int k=1;k<=n;k++)
					f[i+1][j^s[k][i+1]]=1;
			}
		}
		memset(f[i],0,sizeof(f[i]));
	}
	return 0;
}
```

---

## 作者：HPXXZYY (赞：0)

$\color{blue}{\texttt{[Analysis]}}$

**本题解并不提供正确的思路，但是会分析这道题中大家容易出错的地方。**

看到数据范围中的 $1 \leq n \leq 20$，就想到这道题应该用状压 dp。

先约定，当前所有节点的颜色状态用一个整数 $S$ 表示。如果 $S$ 二进制的第 $i$ 位是 $0$，则该节点当前颜色为 `R`，否则为 `B`。

很容易想到的这样一个思路：用 $f_{s}$ 表示从起始状态变化为当前状态最少需要多长时间。状态转移不算特别复杂，但是时间复杂度有问题。

第一，你不能用普通的 dp，因为状态之间不保证谁先出现，谁后出现，所以你只能用记忆化。

但是如果你用记忆化的话，如果只有 $s$ 这一个状态，你很有可能会在同一个节点反复操作导致死循环。

如果你不想死循环，就必须要多加一个状态 $C$，表示是否在第 $i$ 个节点上进行过操作。我们知道，不同的 $C$ 下，$f_{s}$ 的值不同，你就必须把 $f_{s}$ 变成 $f_{s,C}$。于是，MLE 了。

所以这样简单粗暴的方式是有问题的。

正解很巧妙，大家可以看这篇[题解](https://www.luogu.com.cn/blog/ducati/solution-p7732)。

但是，如果你就这么兴冲冲地开始写代码，你可以会 TLE。

大家看题解中的这一段代码：

```cpp
for (int k=0;k<=n;++k){
	for (rg int s=0;s<(1<<n);++s){
		if (f[k][s]){
			f[k+1][s]=1;
			for (int i=1;i<=n;++i)  f[k+1][s^fuck[k][i]]=1;
		}
	}
	if (f[k+1][best_msk]) {printf("%d\n",k);lastans=k+1;break;}
}//Copy from ducati
```

`ducati` 把 $k$ 这一维放在了前面。但是很多同学（包括笔者）喜欢把大的一维（即 $\text{best\_msk}$ 的那一维）放在前面，并且获得了 TLE $45$ 分的好成绩。为什么？

因为这题卡常数。

大概的原因是因为电脑在找数据的时候是一个一个地址线性搜索的，如果把 $\text{besk\_msk}$ 那一维放在前面的话，会导致指针左右大幅度地跳来跳去，于是就 TLE 了。

---


# [ROIR 2024] 表格游戏 (Day 1)

## 题目背景

翻译自 [ROIR 2024 D1T3](https://neerc.ifmo.ru/school/archive/2023-2024/ru-olymp-regional-2024-day1.pdf)。

给定一个有 $h$ 行和 $w$ 列的表格 $A$，每个单元格内含有一个整数。行从上到下编号为 $1$ 到 $h$，列从左到右编号为 $1$ 到 $w$。允许对这个表格进行以下操作：

- 选择一列并删除它（删除的列左边和右边的列变为相邻的列）；
- 选择一行并删除它（删除的行上边和下边的行变为相邻的行）。

这些操作可以按任意顺序执行任意多次。

## 题目描述

你需要确定是否可以通过这些操作将表格变为一个数字之和为 $s$ 的表格。如果可以，请给出具体的操作。

## 说明/提示

在样例 $1$ 中，最初给定的表格是：

$$
\begin{matrix}
1 & 2 & 3 \\
2 & 3 & 1 \\
3 & 1 & 2 \\
\end{matrix}
$$

删除第三行和第三列后，我们得到以下表格，其元素总和为 $8$：

$$
\begin{matrix}
1 & 2 & 3 \\
2 & 3 & 1 \\
3 & 1 & 2 \\
\end{matrix}
\rightarrow
\begin{matrix}
1 & 2 & 3 \\
2 & 3 & 1 \\
\end{matrix}
\rightarrow
\begin{matrix}
1 & 2 \\
2 & 3 \\
\end{matrix}
$$

在样例 $2$ 中，显然无法通过操作从初始表格中得到元素总和为 $5$ 的表格，因为初始表格全部都是 $2$，而 $5$ 是一个奇数。

在样例 $3$ 中，最初给定的表格是：

$$
\begin{matrix}
1 & 2 & 1 & 4 & 5 \\
2 & 5 & 4 & 1 & 2 \\
4 & 2 & 4 & 3 & 1 \\
5 & 5 & 3 & 2 & 4 \\
1 & 2 & 4 & 5 & 2 \\
\end{matrix}
$$

删除最后两行和第一列后，我们得到以下表格，其元素总和为 $34$：

$$
\begin{matrix}
1 & 2 & 1 & 4 & 5 \\
2 & 5 & 4 & 1 & 2 \\
4 & 2 & 4 & 3 & 1 \\
5 & 5 & 3 & 2 & 4 \\
1 & 2 & 4 & 5 & 2 \\
\end{matrix}
\rightarrow
\begin{matrix}
1 & 2 & 1 & 4 & 5 \\
2 & 5 & 4 & 1 & 2 \\
4 & 2 & 4 & 3 & 1 \\
1 & 2 & 4 & 5 & 2 \\
\end{matrix}
\rightarrow
\begin{matrix}
1 & 2 & 1 & 4 & 5 \\
2 & 5 & 4 & 1 & 2 \\
4 & 2 & 4 & 3 & 1 \\
\end{matrix}
\rightarrow
\begin{matrix}
2 & 1 & 4 & 5 \\
5 & 4 & 1 & 2 \\
2 & 4 & 3 & 1 \\
\end{matrix}
$$

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $0$ | $0$ | 同样例 |
| $1$ | $17$ | $h=1$ |
| $2$ | $6$ | 第 $i$ 行中的数字和不超过 $i$ |
| $3$ | $10$ | $h\le3$ |
| $4$ | $13$ | $h,w\le10$ |
| $5$ | $13$ | $h,w\le12$ |
| $6$ | $12$ | $A_{i,j}\le6$ |
| $7$ | $29$ | 无 |

对于 $100\%$ 的数据，$1 \leq h, w \leq 15$，$0 \leq A_{i,j} \leq 10^9$，$1 \leq s \leq 10^{18}$。

## 样例 #1

### 输入

```
3 3
1 2 3
2 3 1
3 1 2
8```

### 输出

```
YES
2
1 3
2 3```

## 样例 #2

### 输入

```
2 3
2 2 2
2 2 2
5```

### 输出

```
NO```

## 样例 #3

### 输入

```
5 5
1 2 1 4 5
2 5 4 1 2
4 2 4 3 1
5 5 3 2 4
1 2 4 5 2
34```

### 输出

```
YES
3
1 4
1 5
2 1```

# 题解

## 作者：DHT666 (赞：2)

是没有递归的题解诶！！！

## 题意
给定 $n$ 行 $m$ 列的矩阵，若干次操作：删一整行或整列，问能否使矩阵的和为 $s$，要输出方案。

## 思路
数据范围是 $1\le n,m\le 15$，考虑搜索，时间复杂度是 $O(2^{n^2})$，于是可以用 meet in the middle，折半搜索，优化为 $O(2^{\frac{3}{2}n}n)$。具体实现是先枚举行的删除情况，然后枚举一半的列的删除情况，再枚举另一半列的删除情况，用 map 来找匹配的一半即可。

Talk is cheap, show me the code.

代码有点丑，但还是比较清晰。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <unordered_map>
using namespace std;

typedef long long LL;

const int N = 20;

int n, m;
LL s;
int a[N][N];
LL l[N];

unordered_map<LL, int> Map;

int main() {
	scanf("%d%d", &n, &m);

	LL sum = 0;
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			scanf("%d", &a[i][j]);
			sum += a[i][j];
		}
	}
	scanf("%lld", &s);

	if(sum == s) {
		puts("YES");
		printf("0");
		return 0;
	}
	
	int t1 = 0, t2 = 0, t3 = 0, res = 0;
	for(int i = 0; i < (1 << n); i++) { // 行的删除情况
		int re = n;
		for(int j = 1; j <= n; j++) {
			if((i >> j - 1) & 1) {
				re--;
			}
		}
		for(int j = 1; j <= m; j++) {
			l[j] = 0;
			for(int k = 1; k <= n; k++) {
				if((i >> k - 1) & 1) {
					l[j] += a[k][j];
				}
			}
		}
		Map.clear();
		for(int j = 0; j < (1 << (m >> 1)); j++) { // 前一半列的删除情况
			LL t = 0;
			for(register int k = 1; k <= (m >> 1); k++) {
				if((j >> k - 1) & 1) {
					t += l[k];
				}
			}
			Map[t] = j;
		}
		for(int j = 0; j < (1 << m - (m >> 1)); j++) { // 后一半列的删除情况
			LL t = 0;
			for(int k = 1; k <= m - (m >> 1); k++) {
				if((j >> k - 1) & 1) {
					t += l[m / 2 + k];
				}
			}
			if(Map.count(s - t)) {
				t1 = Map[s - t];
				t2 = j;
				t3 = i;
				goto end; // 不用找最优解啦，随便一个就可以
			}
		}
	}

	puts("NO");
	return 0;
	
	end:;
	puts("YES");
	int cnt = 0; // 删除的数量
	for(int i = 1; i <= n; i++) {
		if(!((t3 >> i - 1) & 1)) {
			cnt++;
		}
	}
	for(int i = 1; i <= (m >> 1); i++) {
		if(!((t1 >> i - 1) & 1)) {
			cnt++;
		}
	}
	for(int i = 1; i <= m - (m >> 1); i++) {
		if(!((t2 >> i - 1) & 1)) {
			cnt++;
		}
	}
	printf("%d\n", cnt);
	for(int i = 1; i <= n; i++) {
		if(!((t3 >> i - 1) & 1)) {
			printf("1 %d\n", i);
		}
	}
	for(int i = 1; i <= (m >> 1); i++) {
		if(!((t1 >> i - 1) & 1)) {
			printf("2 %d\n", i);
		}
	}
	for(int i = 1; i <= m - (m >> 1); i++) {
		if(!((t2 >> i - 1) & 1)) {
			printf("2 %d\n", m / 2 + i);
		}
	}
	
	return 0;
}
```

---

## 作者：Kketchup (赞：2)

### [[ROIR 2024 Day 1] 表格游戏](https://www.luogu.com.cn/problem/P11122)

- Meet in the middle

**Sol:** 首先能发现操作顺序不影响答案，看到数据范围这么小，可能是状压或者暴搜。朴素做法直接枚举行和列的删除情况并判断，复杂度 $O(2^{hw}poly(h))$，无法通过本题。

这时候就要介绍一种优化搜索的技巧了——$\text{Meet-in-the-middle}$。这个做法本质是把搜索过程分成两半再合并起来，从而将指数复杂度直接减半，板子题是[这个](https://www.luogu.com.cn/problem/P4799)。回到本题，我们先枚举行的删除情况，然后对列的删除进行折半，即先枚举一半，并把对应的答案用 map 存下来，再枚举另一半，看看两边合起来是不是正好和为 $s$，是则输出答案。具体细节见代码，我的实现时间复杂度 $O(2^{\frac{3}{2}h}h)$。

**Trick:** 使用 $\text{Meet-in-the-middle}$ 把暴力搜索指数减半。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define endl '\n'
const int N=30;
#define fin(a) freopen(#a".in","r",stdin)
#define fout(a) freopen(#a".out","w",stdout)
namespace IO{
	char buf[1<<20],*p1,*p2;
	#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?0:*p1++)
	template<typename T> inline static void read(T &x){x=0;int f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=(x*10)+(ch^48);ch=getchar();}if(f==-1) x=-x;}
	template<typename T,typename ...Args> inline static void read(T& x,Args& ...args){read(x);read(args...);}
	template<typename T> inline static void write(char c,T x){T p=x;if(!p) putchar('0');if(p<0){putchar('-');p=-p;}int cnt[105],tot=0;while(p){cnt[++tot]=p%10;p/=10;}for(int i=tot;i>=1;i--){putchar(cnt[i]+'0');}putchar(c);}
	template<typename T,typename ...Args> inline static void write(const char c,T x,Args ...args){write(c,x);write(c,args...);}
}using namespace IO;
int n,m;
ll a[N][N];
ll S,h[N];
vector<pair<int,int> >ans;
unordered_map<ll,int> ma;
int tmp,mid;
void dfs1(int x,int s,ll sum){
	if(x==mid+1){
		ma[sum]=s;
		return ;
	}
	dfs1(x+1,s,sum);
	dfs1(x+1,s|(1<<(x-1)),sum+h[x]);
}
void dfs2(int x,int s,ll sum){
	if(x==mid){
		if(ma.count(S-sum)){
			puts("YES");
			for(int i=1;i<=n;++i){
				if(tmp&(1<<(i-1))) ans.emplace_back(make_pair(1,i));
			}
			for(int i=1;i<=m;++i){
				if(!(s&(1<<(i-1)))&&!(ma[S-sum]&(1<<(i-1)))) ans.emplace_back(make_pair(2,i));
			}
			write('\n',ans.size());
			for(auto i:ans){
				write(' ',i.first);
				write('\n',i.second);
			}
			exit(0);
		}
		return ;
	}
	dfs2(x-1,s,sum);
	dfs2(x-1,s|(1<<(x-1)),sum+h[x]);
}
signed main(){
	read(n,m);
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			read(a[i][j]);
		}
	}
	read(S);
	for(int i=0;i<(1<<n);++i){
		for(int j=1;j<=m;++j){
			h[j]=0;
			for(int k=1;k<=n;++k){
				if(!(i&(1<<(k-1)))){
					h[j]+=a[k][j];
				}
			}
		}
		tmp=i;
		mid=m/2;
		ma.clear();
		dfs1(1,0,0);
		dfs2(m,0,0);
	}
	puts("NO");
	return 0;
}
```

---

## 作者：ny_jerry2 (赞：1)

update：发现写的有点简单，就多加了一点文字的描述。

### 思路
折半搜索模版题（之前确实没接触过）。  
简单来说，就是分两段来搜索（当然有的时候并不是非要等分，一般两边均值是最佳的），然后**用排序加二分或双指针来处理**。
这道题大致思路是这样的：

- 先去搜一下行的被选的状态，中途用一个数组来记录一下哪些行是被选了的。
- 然后记录一下列还剩多少价值（因为行列相交嘛）。
- 对于列就可以用折半搜索，这里取整个序列的中点为 $\lfloor{\frac{n}{2}}\rfloor$，然后分别进行搜索。
- 之后判断列有没有使用过可以状态压缩（搜索时就可以将列的被选的状态压缩成二进制）。
- 然后排序，排完序后发现两个序列都有单调性，就可以双指针或者二分了。
#### 具体过程
- 折半搜索部分前， _先把每一列剩余的价值计算出来_ 。
- 然后分两次搜索，搜索时**要记录剩下没选的行的总价值以及二进制状态**。每一次结束递归前**可以用 vector 来记录下当前的价值与状态**，要分别用两个 vector 来记录，可以在搜索中多传一个参数。
- 然后排序。
- 排完序后。就可以双指针或者二分了（这里采用双指针）。
- 遍历第一个 vector，第二个用双指针来处理。具体就是在判断价值的和是否相等之前用双指针排除绝对不可能的数值。如果当前的指针对应的值与当前循环遍历到的值之和大于了要求的和，就向左移动指针。因为已经排序，所以有单调性，因此正确性可以保证。
- 判断和是否相等。相等的话就输出并结束程序。

输出稍加处理即可,其实就是先计算一下操作了多少次，然后看行列的删除情况。  
行很简单，就是看有没有被标记为 $1$。列也不复杂，可以根据状态压缩的情况来判断有没有删掉（两次搜索的状态都要去判断）。

### 正解
搜索题还挺练习代码力的。
```cpp
#include<iostream>
#include<vector>
#include<algorithm>
int n,m;
long long c;
using namespace std;
const int N=30;
long long col[N][N],p[N];
bool vis[N],ch=1;
struct node{
	long long val,S;
	bool operator<(const node &t){
		return val<t.val;
	}
};
vector<node> s[2];
void dfs(int u);
void work();
void dfs2(int u,int ed,long long val,long long S,int type);
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%lld",&col[i][j]);
		}
	}
	cin>>c;
	dfs(1);
	if(ch){
		cout<<"NO";
	}
	return 0;
}
void dfs(int u){
	if(!ch){
		return;
	}
	if(u>n){
		work();
		return;
	}
	dfs(u+1);
	vis[u]=1;
	dfs(u+1);
	vis[u]=0;
}
void work(){
	for(int i=1;i<=m;i++){
		p[i]=0;
	}
	for(int i=1;i<=n;i++){
		if(vis[i]){
			continue;
		}
		for(int j=1;j<=m;j++){
			p[j]+=col[i][j];
		}
	}
	s[0].clear(),s[1].clear();
	int mid=(m>>1)+1;
	dfs2(1,mid,0,0,0);
	dfs2(mid+1,m,0,0,1);
	sort(s[0].begin(),s[0].end());
	sort(s[1].begin(),s[1].end());
	int x=s[0].size(),y=s[1].size();
	int j=y-1;
	for(int i=0;i<x;i++){
		while(j&&s[0][i].val+s[1][j].val>c){
			j--;
		}
		if(s[0][i].val+s[1][j].val!=c){
			continue;
		}
		int cnt=0;
		for(int k=1;k<=n;k++){
			if(vis[k]){
				cnt++;
			}
		}
		for(int k=1;k<=m;k++){
			if(!(s[0][i].S>>k&1)&&!(s[1][j].S>>k&1)){
				cnt++;
			}
		}
		printf("YES\n%d\n",cnt);
		for(int k=1;k<=n;k++){
			if(vis[k]){
				printf("1 %d\n",k);
			}
		}
		for(int k=1;k<=m;k++){
			if(!(s[0][i].S>>k&1)&&!(s[1][j].S>>k&1)){
				printf("2 %d\n",k);
			}
		}
		ch=0;
		return;
	}
}
void dfs2(int u,int ed,long long val,long long S,int type){
	if(u>ed){
		s[type].push_back({val,S});
		return;
	}
	dfs2(u+1,ed,val,S,type);
	dfs2(u+1,ed,val+p[u],S|(1<<u),type);
}
```
折半搜索是一个搜索的小优化，一般用于数据小但还没小到暴力做的程度，还是有套路。只不过考验代码力。感觉搜索都挺考代码力，练习多了还能提升 Debug 能力。

---

## 作者：__string__ (赞：1)

## 题目分析
首先拿到这道题，由于 $h, w\le 15$，都很小，不难想到可以暴力去枚举删哪些行、那些列，这样的时间复杂度就是 $O(2^{h+w})$，就会 TLE。

接下来就来想怎么优化，我们发现：删一行的数，会影响到每一列对行的贡献。所以，当我们确定要删哪些行之后，每一列对答案的贡献自然也就知道了，这时问题就转化成了能否从这些列的贡献中选出一些值，使它们的和为 $s$，这样就可以用到折半搜索了。

## 折半搜索
关于折半搜索的基本介绍，可以查看 [OI Wiki](http://oi-wiki.com/search/bidirectional/#meet-in-the-middle)。

### 做法分析

对于折半搜索的题目，一般都有两个特点：

1. 题目中的数据范围较小，但没有小到可以直接暴搜的程度。
2. 题目中的序列是无序的。

对于这道题目：

先花 $O(2^{h})$ 的复杂度枚举要删哪些行，用一个二进制数 $state$，第 $i$ 位为 $1$，就代表删第 $i$ 行，为 $0$ 就代表不删第 $i$ 行，根据这个就可以求出每一列的贡献。

设每一列的贡献分别为 $column_{1},column_{2},...column_{w}$。
1. $w,h\le15$，符合第一个特点。
2. 对于 $column$ 序列，每次选值的顺序不会对结果产生影响，符合第二个特点。
3. 如果暴搜的话，对于每个 $state$，都要花 $O(2^{w})$ 的复杂度去 check，总复杂度仍为 $O(2^{h+w})$，没有起到优化的效果，但如果采用折半搜索的话，check 的复杂度为 $O(2^{\frac{w}{2}})$，总复杂度就为 $O(2^{h}\times 2^{\frac{w}{2}})$，就可以通过此题。

### 具体 check 流程

1. 把 $column$ 序列分成两半，设长度分别为 $len1,len2$。
2. 对于每一半，都可以求出来由这一半的数可以组合出来的所有值，将它们分别存在两个数组中。
3. 检查是否能在第一个数组中找一个值，再在第二个数组中找一个值，使这两个值的和为 $s$，可以将两个数组分别排序后使用双指针实现。
4. 如果 check 成功，就可以根据当前记录删除行的二进制数 $state$ 和记录删除列的二进制数输出删除方案。

## 代码实现

```cpp
#include <algorithm>
#include <iostream>

using namespace std;

#define int long long
#define N 25
#define M 1000010

struct Node {
  int val;  // 答案
  int state;  // 删除的列 (二进制数)
  bool operator<(const Node &node) const { return val < node.val; }
};

int h, w;
int g[N][N];
int column[N];
int sum;
pair<int, int> ans[N << 1];
// 这两个 Node 数组就是记录流程 2 中组合出来的值的数组
Node ans1[M];
Node ans2[M];

signed main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);
  cin >> h >> w;
  for (int i = 1; i <= h; i++) {
    for (int j = 1; j <= w; j++) {
      cin >> g[i][j];
    }
  }
  cin >> sum;
  for (int s = 0; s < (1 << h); s++) {  // s 就是枚举的删除的行 (state)
    for (int i = 1; i <= w; i++) {
      column[i] = 0;
    }
    for (int i = 1; i <= h; i++) {
      if (!(s & (1 << (i - 1)))) {
        for (int j = 1; j <= w; j++) {
          column[j] += g[i][j];
        }
      }
    }
    // 目标: 从 column 中找一些数和为 sum
    int len1 = w / 2;
    int len2 = w - len1;
    int n = 0;
    int m = 0;
    for (int s = 0; s < (1 << len1); s++) {
      int res = 0;
      for (int i = 1; i <= len1; i++) {
        if (s & (1 << (i - 1))) {
          res += column[i];
        }
      }
      ans1[n].state = s;
      ans1[n++].val = res;
    }
    for (int s = 0; s < (1 << len2); s++) {
      int res = 0;
      for (int i = 1; i <= len2; i++) {
        if (s & (1 << (i - 1))) {
          res += column[i + len1];
        }
      }
      ans2[m].state = s;
      ans2[m++].val = res;
    }
    sort(ans1, ans1 + n);
    sort(ans2, ans2 + m);
    int j = m - 1;
    for (int i = 0; i < n; i++) {
      while (j > 0 && ans1[i].val + ans2[j].val > sum) {
        j--;
      }
      if (ans1[i].val + ans2[j].val == sum) {
        int cnt = 0;
        for (int k = 1; k <= h; k++) {
          if (s & (1 << (k - 1))) {
            ans[++cnt] = make_pair(1, k);
          }
        }
        for (int k = 1; k <= len1; k++) {
          if (!(ans1[i].state & (1 << (k - 1)))) {
            ans[++cnt] = make_pair(2, k);
          }
        }
        for (int k = 1; k <= len2; k++) {
          if (!(ans2[j].state & (1 << (k - 1)))) {
            ans[++cnt] = make_pair(2, k + len1);
          }
        }
        cout << "YES\n";
        cout << cnt << '\n';
        for (int i = 1; i <= cnt; i++) {
          cout << ans[i].first << ' ' << ans[i].second << '\n';
        }
        return 0;
      }
    }
  }
  cout << "NO\n";
  return 0;
}
```

---

## 作者：songzhixin (赞：1)

### 题意

可以删去若干行和若干列，问是否存在方案，使得剩下矩阵的和为 $s$。

### 思路

本题如果暴力直接枚举，时间复杂度约为 $O(2^{n+m})$，无法通过。

考虑优化，可以通过 IDDFS 进行限制，但是对于无解的情况，时间复杂度依然过高。

本题可以使用折半查找进行优化。可以先枚举行的情况，通过二进制枚举每一行选或者不选，时间复杂度 $O(2^n)$。

对于行的每一种情况，可以先枚举前 $\lfloor \frac{m}{2} \rfloor$ 列的所有情况，会得到 $2^{\lfloor \frac{m}{2} \rfloor}$ 种情况，把这些情况记录下来，然后按照这种情况得到的和从小到大排序，后面需要用。

对于后 $\lceil \frac{m}{2} \rceil$ 行，同样是和前面一样枚举出所有情况，但是这里枚举完得到和后，就可以直接从前面我们已经排好序的数组中进行查找，用二分找出是否存在可以与这个和配对的数，使得这两个数之和为 $s$。

至于输出，可以通过状态压缩记录一下方案，最后破译了输出即可。

这样子做，时间复杂度为 $O(2^n \times 2^{\lceil \frac{m}{2} \rceil} \times \log(2^{\lceil \frac{m}{2} \rceil}))$，大约为 $6 \times 10^8$，因为洛谷拥有强大的评测机，且时限调大了，所以可以通过。

我起先没有用递归，结果神秘的又超时又答案错误，将第二步改为 DFS 就通过了。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long N=20;
const long long M=130;
long long a[N][N];
struct node {
	long long b,s;
};
long long q[N];
node w[M];
bool v[N];
bool d[N];
long long n,m;
long long res;
bool cmp(node fx,node fy) {
	return fx.s<fy.s;
}
long long cnt=0;
void dfs(int x,int y,int z,int sum) {
	if(x==y+1) {
		w[++cnt].b=z;
		w[cnt].s=sum;
		return;
	}
	int tt=0;
	for(int i=1; i<=n; i++) {
		if(v[i]==true) {
			tt+=a[i][x];
		}
	}
	dfs(x+1,y,z+q[x-1],sum+tt);
	dfs(x+1,y,z,sum);
	return;
}
void dfs2(int x,int y,int z,int sum,int u) {
	if(x==y+1) {
		long long l=1,r=cnt;
		while(l<=r) {//二分进行配对
			long long mid=(l+r)>>1;
			if(w[mid].s+sum==res) {
				printf("YES\n");//破译之后输出
				long long y=0;
				x=u;
				while(x) {
					if(x&1) {
						y++;
					}
					x>>=1;
				}
				x=w[mid].b;
				while(x) {
					if(x&1) {
						y++;
					}
					x>>=1;
				}
				x=z;
				while(x) {
					if(x&1) {
						y++;
					}
					x>>=1;
				}
				printf("%lld\n",n+m-y);
				int tot=0;
				x=u;
				for(long long p=1; p<=16; p++) {
					v[p]=false;
				}
				while(x) {
					++tot;
					if(x&1) {
						v[tot]=true;
					}
					x>>=1;
				}
				for(long long p=1; p<=n; p++) {
					if(v[p]==false) {
						printf("1 %lld\n",p);
					}
				}
				for(long long p=1; p<=16; p++) {
					v[p]=false;
				}
				tot=0;
				x=w[mid].b;
				while(x) {
					++tot;
					if(x&1) {
						v[tot]=true;
					}
					x>>=1;
				}
				x=z;
				tot=m/2;
				while(x) {
					++tot;
					if(x&1) {
						v[tot]=true;
					}
					x>>=1;
				}
				for(long long p=1; p<=m; p++) {
					if(v[p]==false) {
						printf("2 %lld\n",p);
					}
				}
				exit(0);
			}
			if(w[mid].s+sum<res) {
				l=mid+1;
			}
			if(w[mid].s+sum>res) {
				r=mid-1;
			}
		}
		return;
	}
	int tt=0;
	for(int i=1; i<=n; i++) {
		if(v[i]==true) {
			tt+=a[i][x];
		}
	}
	dfs2(x+1,y,z+q[x-1-m/2],sum+tt,u);
	dfs2(x+1,y,z,sum,u);
	return;
}
int main() {
	scanf("%lld%lld",&n,&m);
	for(long long i=1; i<=n; i++) {
		for(long long j=1; j<=m; j++) {
			scanf("%lld",&a[i][j]);
		}
	}
	scanf("%lld",&res);
	q[0]=1;
	for(long long i=1; i<=19; i++) {
		q[i]=q[i-1]*2;
	}
	for(long long i=0; i<=q[n]-1; i++) {//枚举行
		long long x=i;
		for(long long j=1; j<=n; j++) {
			v[j]=false;
		}
		long long tot=0;
		while(x) {
			tot++;
			if(x&1) {
				v[tot]=true;
			} else {
				v[tot]=false;
			}
			x>>=1;
		}
		cnt=0;
		dfs(1,m/2,0,0);//枚举前m/2行
		sort(w+1,w+1+cnt,cmp);
		dfs2(m/2+1,m,0,0,i);//枚举后m-m/2行
	}
	printf("NO\n");
	return 0;
}
```

---

## 作者：rainbow_cat (赞：1)

删除的顺序和答案是无关的，$h,w \le 15$ 我们优先考虑搜索，显然 $O(2^{h+w})$ 的复杂度是无法接受的，使用折半搜索优化。    

这里折半行，所以需要枚举列的选择状态，即枚举 $0$ 至 $2^m-1$，若二进制下某一位是 $0$ 则该列不选，否则选。记录 $mp_i$ 表示和为 $i$ 时行的选择方法，这里同样状压处理。    

最后合并的时候只需要查询 $mp$ 即可，需要注意的是，特判只选择后一半的情况，复杂度 $O(2^{\frac{n}{2}+m+1})$。

```cpp
#include<bits/extc++.h>
using namespace std;
using namespace __gnu_cxx;
using namespace __gnu_pbds;
#ifdef ONLINE_JUDGE
char buf[1 << 23] , * p1 = buf , * p2 = buf , obuf[1 << 23] , * O = obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
inline int read() {
	int x = 0 , f = 1;char ch = getchar();
	while (!isdigit(ch)) { if (ch == '-') f = -1;ch = getchar(); }
	while (isdigit(ch)) x = (x<<3)+(x<<1)+ (ch ^ 48) , ch = getchar();
	return x * f;
}
#define endl '\n'
int n,m,pop[1<<15],a[20][20];
double st;
long long sumv[20],tsum[20];
long long v;
__gnu_pbds::gp_hash_table<long long,int>mp;
void dfs(int step,int &sta,long long sum,int hsta)
{
	if(step==(n>>1)+1)
	{
		if(sum+sumv[n]-sumv[n>>1]>=v)mp[sum]=hsta;
		return;
	}
	long long tmp=tsum[step];
	if(sum+tmp<=v)dfs(step+1,sta,sum+tmp,hsta|(1<<(step-1)));
	dfs(step+1,sta,sum,hsta);
}
void dfs1(int step,int &sta,long long sum,int hsta)
{
//	if((1.0*clock()-st)/CLOCKS_PER_SEC>0.55)
//	{
//		cout<<"NO";
//		exit(0);
//	}
	if(step==n+1)
	{
		if(mp[v-sum]||sum==v)
		{
			printf("YES\n%d\n",n+m-pop[sta]-pop[hsta+mp[v-sum]]);
			hsta+=mp[v-sum];
			for(int i=1;i<=m;i=-~i)
			{
				if((sta&1)==0)printf("2 %d\n",i);
				sta>>=1;
			}
			for(int i=1;i<=n;i=-~i)
			{
				if((hsta&1)==0)printf("1 %d\n",i);
				hsta>>=1;
			}
			exit(0);
		}
		return;
	}
	long long tmp=tsum[step];
	if(sum+tmp<=v)dfs1(step+1,sta,sum+tmp,hsta|(1<<(step-1)));
	dfs1(step+1,sta,sum,hsta);
}
int popcount(int x)
{
	int res=0;
	while(x)res+=x&1,x>>=1;
	return res;
}
signed main()
{
	n=read(),m=read();
	for(int i=0;i<(1<<15);i=-~i)pop[i]=popcount(i);
	for(int i=1;i<=n;i=-~i)
	{
		sumv[i]=sumv[i-1];
		for(int j=1;j<=m;j=-~j)a[i][j]=read(),sumv[i]+=(long long)a[i][j];
	}
	v=read();
	if(sumv[n]<v)
	{
		printf("NO");
		return 0;
	}
	for(int i=0;i<(1<<m);i=-~i)
	{
		for(int j=1;j<=n;j=-~j)
		{
			tsum[j]=0;
			int tmp=i,cnt=0;
			while(tmp)
			{
				cnt++;
				if(tmp&1)tsum[j]+=(long long)a[j][cnt];
				tmp>>=1;
			}
		}
		dfs(1,i,0,0),dfs1((n>>1)+1,i,0,0),mp.clear();
	}
	printf("NO");
	return 0;
}
```

---

## 作者：ny_Dacong (赞：0)

发现删除顺序与最终答案无关。

考虑暴力。用**状压表示删除情况**。枚举删哪几行，然后枚举删哪几列。最坏情况两者各有 $2^{15}$ 种情况，总复杂度为 $O(2^{h+w})$。

考虑折半搜索。这个算法的思想为把搜索区间分成两半，每一半单独搜索，然后用高效的方法合并结果。

对于这道题，我们可以先枚举删哪几行，然后先枚举只删 $1 \sim \lfloor \frac{w}{2} \rfloor$ 列的情况，再枚举只删 $\lceil \frac{w}{2} \rceil \sim w$ 列的情况。最后合并二者的结果，判断是否有解。

这个方法优化了时间复杂度，从 $O(2^{h+w})$ 优化到了 $O(2^{h+ \frac{w}{2}})$。可过。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,q;
long long num[20][20],sum[20];
long long state1;
unordered_map<long long,long long> state2;
vector<pair<long long,long long>> ans;
void dfs1(long long now,long long state,long long add){
	if(now == (m>>1)+1){
		state2[add] = state;
		return;
	}
	dfs1(now+1,state,add);
	dfs1(now+1,state|(1<<(now-1)),add+sum[now]);
	return;
}
void dfs2(long long now,long long state,long long add){
	if(now == m>>1){
		if(state2.count(q-add)){
			puts("YES");
			for(long long i = 0; i < n; i++){
				if(state1&(1<<i)){
					ans.push_back({1,i+1});
				}
			}
			for(long long i = 0; i < m; i++){
				if(!(state2[q-add]&(1<<i)) && !(state&(1<<i))){
					ans.push_back({2,i+1});
				}
			}
			printf("%lld\n",(long long)ans.size());
			for(auto i:ans){
				printf("%lld %lld\n",i.first,i.second);
			}
			exit(0);
		}
		return;
	}
	dfs2(now-1,state,add);
	dfs2(now-1,state|(1<<(now-1)),add+sum[now]);
}
int main(){
	scanf("%lld%lld",&n,&m);
	for(long long i = 1; i <= n; i++){
		for(long long j = 1; j <= m; j++){
			scanf("%lld",&num[i][j]);
		}
	}
	scanf("%lld",&q);
	for(long long i = 0; i < (1<<n); i++){
		for(long long j = 1; j <= m; j++){
			sum[j] = 0;
			for(long long k = 1; k <= n; k++){
				if(!(i&(1<<(k-1)))){
					sum[j] += num[k][j];
				}
			}
		}
		state1 = i;
		state2.clear();
		dfs1(1,0,0);
		dfs2(m,0,0);
	}
	puts("NO");
	return 0;
}
```

---

## 作者：xuyifei0302 (赞：0)

读完题，我们可以发现我们先删去行和先删去列是一样的，并且有 $h \le 15$ 和 $w \le 15$，某教练说过：“这种数据范围，都把状态压缩写脸上了。”，所以我们考虑状态压缩，用二进制集合的方式来判断每一行和每一列选还是不选，若二进制位上是 $1$ 就选，否则就不选。

我们会发现这里的枚举量是 $2 ^ {15} \times 2 ^ {15} = 2 ^ {30} = 1073741824$ 显然是过不去的，但是我们可以想到有一种黑科技叫折半搜索，故名思意，我们先搜索一半，再搜索一半，这样的枚举量就变为 $2 ^ {15} \times \left ( 2 ^ {8} + 2 ^ {7}\right ) = 12582912$ 发现这个枚举量就变得可以接受，于是就可以快乐搜索了。

每次枚举行的集合，然后对于列的集合进行折半搜索，一旦出现和为 $s$ 的情况，就证明可以，然后输出当前的选择状态即可。相反，若没有，即为不行。但是，在搜索的过程中要统计除去行之后每一列的总和，如果不预处理的话，它最坏会访问 $2 ^ 8$，所以要在搜索前预处理一下。

估计大家的折半搜索写出来大差不差。

---


# 平板涂色

## 题目描述

CE 数码公司开发了一种名为自动涂色机（APM）的产品。它能用预定的颜色给一块由不同尺寸且互不覆盖的矩形构成的平板涂色。

为了涂色，APM 需要使用一组刷子。每个刷子涂一种不同的颜色 $C_i$ 。APM 拿起一把有颜色 $C_i$ 的刷子，并给所有颜色为 $C_i$ 且符合下面限制的矩形涂色：

![](https://cdn.luogu.com.cn/upload/pic/90.png) 

为了避免颜料渗漏使颜色混合，一个矩形只能在所有紧靠它上方的矩形涂色后，才能涂色。例如图中矩形 $F$ 必须在 $C$ 和 $D$ 涂色后才能涂色。注意，每一个矩形必须立刻涂满，不能只涂一部分。

写一个程序求一个使 APM 拿起刷子次数最少的涂色方案。注意，如果一把刷子被拿起超过一次，则每一次都必须记入总数中。

## 说明/提示

$1\le C_i \le 20$，$0 \le x_i,y_i \le 99$，$1\le N \le 16$。

## 样例 #1

### 输入

```
7
0 0 2 2 1
0 2 1 6 2
2 0 4 2 1
1 2 4 4 2
1 4 3 6 1
4 0 6 4 1
3 4 6 6 2
```

### 输出

```
3
```

# 题解

## 作者：I_AM_HelloWord (赞：41)

一看到n<=16,颜色<=20，马上就要想到裸的状压dp，

设dp[S][i]表示在集合S(已经涂的矩形的集合)中，最后涂色的颜色是i，所需的最少拿刷子的次数。至于集合，就是用二进制表示。

先预处理出每个矩形上面有哪些矩形，这个由于数据范围比较小，都不用离散化，直接开个二维数组弄个矩形覆盖就行了。

至于具体的Dp，应该还算是比较好写的。

枚举一下最后一次涂的是第j个矩形，而第j个矩形的颜色是col[j]，当然，这个第j个矩形必须满足两个限制：

1.j属于S

2.j上面的矩形都属于S

那么Dp(S,col[j])=min(Dp(S-(1<<(j-1)),k)+1){枚举另一个颜色k，并且k!=col[j]}

Dp(S,col[j])=min(Dp(S-(1<<(j-1)),col[j]))

这个还是很好理解的。

参考代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
template<class T>void ChkMin(T &a,T b){if (a>b)a=b;}
const int INF=0x3f3f3f3f;
const int N=101;
const int M=21;
int lx[M],size[M],ly[M],col[M],rx[M],ry[M];
int n,a[N][N],dp[1<<16+1][M],up[M][M];
inline bool in(int i,int S){
    return (S>>(i-1))&1;
}
inline bool ok(int i,int S){
    bool flag=true;
    for (int j=1;j<=size[i] && flag;j++)flag&=in(up[i][j],S);
    return flag;
}
int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;i++){
        scanf("%d%d%d%d%d",&lx[i],&ly[i],&rx[i],&ry[i],&col[i]);
        for (int x=lx[i];x<rx[i];x++)
            for (int y=ly[i];y<ry[i];y++)
                a[x][y]=i;
    }
    for (int i=1;i<=n;i++){
        if (!lx[i])continue;
        lx[i]--;
        for (int j=ly[i]+1;j<=ry[i];j++)
            if (a[lx[i]][j]!=a[lx[i]][j-1])up[i][++size[i]]=a[lx[i]][j-1];
        if (a[lx[i]][ry[i]]==a[lx[i]][ry[i]-1])up[i][++size[i]]=a[lx[i]][ry[i]-1];
    }
    memset(dp,0x3f,sizeof(dp));
    for (int i=1;i<=20;i++)
        dp[0][i]=1;
    for (int i=1;i<(1<<n);i++){
        for (int j=1;j<=n;j++)
            if (in(j,i) && ok(j,i)){
                for (int k=1;k<=20;k++)
                    if (k!=col[j])ChkMin(dp[i][col[j]],dp[i-(1<<(j-1))][k]+1);
                ChkMin(dp[i][col[j]],dp[i-(1<<(j-1))][col[j]]);
            }
    }
    int ans=INF;
    for (int i=1;i<=20;i++)
        ChkMin(ans,dp[(1<<n)-1][i]);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：star_magic_young (赞：27)

~~先%下面DP的dalao们~~


蒟蒻不会DP，只能搜索（+剪枝）~~数据小过了~~


看到数据范围： n < 16 ？直接搜索，但是应该要剪枝


#搜索思路


读入数据，统计颜色，然后每个颜色都试一遍，即把该颜色的且能涂的砖涂上。

下一次涂色不能涂上次涂过的色。涂完了记录结果


为了不超时，加了两个剪枝


- 最优化剪枝：**当前涂色次数大于等于当前答案，直接退出**（这个好理解吧）


- 可行性剪枝：**如果当前没有涂到一个砖，直接退出**（如果接着搜，会多一个次数，可能还会死循环，，，）


至于判断该砖是否能涂，先预处理，**把紧邻该砖上方的砖用数组记录下来**，再判断那些砖是否被涂


代码如下（格式丑勿喷）


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
using namespace std;
struct lbq  //结构体 a1b1 该砖左上角坐标 a2b2 右下角坐标 x 颜色
{
    int a1,b1,a2,b2,x;
}a[20];
int ccmp(lbq a,lbq b)
{
    if(a.a1!=b.a1) return a.a1<b.a1;
    return a.b1<b.b1;
}
bool d=false;
int de[20]={0};//de数组表示是否有该颜色
int n,m,ans=999,b[20],fk[20][20]; //b数组代表该砖是否被涂 fk[i][j]表示第i个砖是否紧邻上方第j个砖 m 最大颜色编号
bool OK(int o)
{
    for(int i=1;i<=n;i++)
        if(fk[o][i]&&!b[i]) return false; //如果i砖下面紧邻o，但i没涂过，返回false
    return true;
}
void dfs(int o,int pq,int xx) //o 涂色次数 pq 涂过颜色的砖 xx 上次涂的颜色
{
    if(o>=ans) return; //当前涂色次数大于等于当前答案，直接退出
    if(pq==n) //涂完了，记录答案
       {
        ans=o;
        return;
    }
    for(int i=1;i<=m;i++) //枚举颜色
       {
        int qq=0; //代表现在用这个颜色涂的砖数
        if(i!=xx&&de[i])//如果有这个颜色，并且这种颜色上次没用过
        {
            for(int j=1;j<=n;j++) //涂色
            {
                if(!b[j]&&a[j].x==i&&OK(j)) //如果没涂过该砖，并且能涂
                   {
                    b[j]=1;
                    qq++;
                }
                else if(b[j]&&a[j].x==i) b[j]++;
            }
            if(qq>0) dfs(o+1,pq+qq,i); 如果涂了砖，进行下一步
            for(int j=n;j>=1;j--) //回溯一步
            {
                if(b[j]==1&&a[j].x==i&&OK(j))
                   {
                    b[j]=0;
                    qq--;
                }
                else if(b[j]>1&&a[j].x==i) b[j]--; 
            }
        }
    }
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d%d%d%d",&a[i].a1,&a[i].b1,&a[i].a2,&a[i].b2,&a[i].x);
        a[i].a1++;  //个人习惯把左上角坐标+1，就可以看成它左上角所占的方格
        a[i].b1++;  // 例如 0 0 2 2 +1后为 1 1 2 2 ，表示该砖左上角，右下角所占的方格
        de[a[i].x]++; //记录颜色
    }
    for(int i=1;i<=20;i++) if(de[i]) m=i; //求最大颜色编号
    sort(a+1,a+n+1,ccmp);  //按左上角坐标大小从小到大排序（先考虑纵，再考虑横）
    for(int i=2;i<=n;i++)
        for(int j=i-1;j>=1;j--) 
            if(a[i].a1==a[j].a2+1&& ( (a[i].b1>=a[j].b1&&a[i].b1<=a[j].b2) || (a[i].b2>=a[j].b1&&a[i].b2<=a[j].b2) ) )
                fk[i][j]=1; //如果i砖的最上面紧邻j砖最下面，且两砖横坐标有重叠部分，即j砖为i砖紧邻上面的砖
    dfs(0,0,0);
    cout<<ans;//结果
    return 0;
}
```

---

## 作者：_J_C_ (赞：14)

emm，本蒟蒻dp没学好，碰到dp难题只会暴力搜索。
不过暴力还是挺快的，0msAC了。

看到题目的时候，第一个感觉就是：如果我要涂这个矩形，它上面的矩形都要涂掉……怎么听上去有后效性……

转念一想：要涂一个矩形，它上面的矩形都要涂掉……拓扑排序啊！←←

拓扑排序让我想了想怎么把一坨坨的矩形转化为优雅的图


举个例子，对于样例：
 ![](https://cdn.luogu.com.cn/upload/pic/19325.png)
我们把它建个图：
 ![](https://cdn.luogu.com.cn/upload/pic/19326.png)

至于如何建图嘛，本蒟蒻太懒，开了个100 \* 100的数组，直接O(100 \* 100)枚举每一个点，判断其上下关系。~~不过没关系，O(10000)就是O(1)~~

然后在图上dfs，dfs先枚举颜色，然后枚举所有这个颜色的节点，用类似拓扑排序的方法尽可能的多去掉所有这个颜色的、入度能变为0的点。(贪心)

记录一个remain_color，为未涂完的颜色。当所有颜色的所有矩形都被涂掉后，dfs结束。
同时，如果 当前步数 + remain_color >= 已有答案，直接退出就好了，因为每一个颜色至少会导致举刷子一次。(剪枝)

记录一个bRemoved，表示这个点已经被删除了。

顺便说一下，由于是不带状态描述的dfs，记得恢复状态。要恢复的状态有：是否删除，remain_color，入度，这种颜色还剩余多少个点没涂（详见下面代码）

嗯，接下来就是我丑陋的代码了。（还是别看了T.T思路重要，代码太丑）

```cpp
#include <cstdio>
#include <cstdlib>

#include <queue>

#define COLOR 30

#define CNTRC 20

#define FOR_EDGE(i, pt) for (int i(iHead[pt]); i; i = all[i].next)

class edge
{
public:
    int to, next;
}all[112345];
int iHead[CNTRC];//邻接表存图
int iEnd(1);

void add(int fr, int to)
{
    all[iEnd].to = to;
    all[iEnd].next = iHead[fr];
    iHead[fr] = iEnd++;
}

int remain_color;//剩下几种颜色没涂
int rect[COLOR][CNTRC];//将所有矩形标号后按颜色分类
int EndRect[COLOR];//这个颜色的矩形有多少个
int map[112][112];//100\*100的暴力建图
int index[CNTRC];//每个点的入度
bool bRemoved[CNTRC];//这个点是否已经被删除了
int color[CNTRC];//这个点的颜色是什么
int remain[COLOR];//这种颜色还剩下几个点没有涂
int n, ans(212345678);

void dfs(int res)
{
    if (res + remain_color >= ans) return;//剪枝
    if (remain_color == 0)//全部涂完了，结束
    {
        ans = res;//如果res大于ans，已经被上面一个if过滤~~查水表~~了
        return;
    }
    int cnt(0);
    for (int i(1); i != COLOR && cnt != remain_color; ++i)
    {
        if (EndRect[i] == 0 || remain[i] == 0) continue;//如果这个颜色的矩形是不存在的，或是已经涂完了，就继续枚举
        std::queue<int> que, remove, subindex;//第一个是删除点的队列，第二个是删除掉的点的队列，第三个是更改过入度的点的队列。第一个是拓扑排序用的，后面两个是恢复状态用的。
        bool find(false);
        for (int j(0); j != EndRect[i]; ++j)
        {
            if (!bRemoved[rect[i][j]] && index[rect[i][j]] == 0)
            {
                find = true;
                que.push(rect[i][j]);
            }
        }
        if (find) ++cnt;
        else continue;//如果这种颜色无法去除任何一个点，继续枚举
        while (!que.empty())//拓扑删除点
        {
            int now(que.front());
            que.pop();
            bRemoved[now] = true;
            remove.push(now);
            --remain[i];
            FOR_EDGE(j, now)
            {
                --index[all[j].to];
                subindex.push(all[j].to);
                if (index[all[j].to] == 0 && color[all[j].to] == i)
                {
                    que.push(all[j].to);
                }
            }
        }
        if (remain[i] == 0) --remain_color;//当前颜色的点全部被涂完了
        dfs(res + 1);//搜索，记得步数加一
        if (remain[i] == 0) ++remain_color;
        while (!remove.empty())//恢复拓扑前的状态
        {
            bRemoved[remove.front()] = false;
            ++remain[i];
            remove.pop();
        }
        while (!subindex.empty())
        {
            ++index[subindex.front()];
            subindex.pop();
        }
    }
}

int main()
{
    scanf("%d", &n);
    for (int i(1); i <= n; ++i)//读入并将矩形分类
    {
        int l, t, r, b, c;
        scanf("%d%d%d%d%d", &t, &l, &b, &r, &c);
        ++remain[c];
        color[i] = c;
        if (EndRect[c] == 0) ++remain_color;
        rect[c][EndRect[c]++] = i;
        for (int x(t); x <= b; ++x) for (int y(l); y <= r; ++y) map[x][y] = i;
    }
    for (int x(1); x != 100; ++x)//暴力建图……
    {
        for (int y(0); y != 100; ++y)
        {
            int fr(0), to(0);//这两个是防止重复建边用的；如果难以理解，不妨模拟一下过程~~只可意会不可言传之蠢~~
            if (map[x][y] == map[x - 1][y]) continue;
            if (map[x][y] && map[x - 1][y] && map[x][y] != to && map[x - 1][y] != fr)
            {
                fr = map[x - 1][y];
                to = map[x][y];
                add(fr, to);
                ++index[to];
            }
        }
    }
    dfs(0);
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：洛桃 (赞：11)

#### 闲话
第一道完全靠自己想出的蓝题，怎么说也要写篇题解纪念一下
## 思路
看完题面，使用DFS应该是很显然了

但是不同于普通深搜的枚举，这道题有一个限制条件

那就是**一个矩形只能在所有紧靠它上方的矩形涂色后，才能涂色**

所以我在开始搜索前做了预处理，处理出了每个矩形在涂色前有哪些矩形需要先涂好，搜索时再去判断

每个需要预涂的矩形是否已先涂好

另外，由于搜索时我是一次性将所有可以涂色的涂完，所以需要先对所有矩形按照**从上到下**的顺序进行排序，这样就可以保证在**一次性**的涂色中，当我要涂下方的矩形时，上方的同颜色矩形已经涂完了

之后的事情就非常简单，只要照着DFS的模板打就行了

没有剪枝~~好像由于数据范围过小水过了~~

AC代码如下（带很详细的注释）
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
int n,minn=1e9,tot,sum[17],ss[17][17],ans[1000],v;sum[i]代表第i个矩形上方紧靠着的矩形数
struct node{              //ss[i][j]代表第i个矩形的第j个紧靠着的矩形是哪一个 
	int x1,y1,x2,y2;
	int d;
}s[17];//s[i].x1和y1代表第i个矩形左上方点的坐标,s[i].x2和y2代表右下方点的坐标,s[i].d代表要涂的颜色 
bool ex[17];
void dfs(int k,int su)//k为拿起刷子的次数,su为已经涂色的矩形数目 
{
	if(su==n)
	{
		minn=min(minn,k);
		return;
	}
	for(int g=1;g<=tot;g++)//tot为颜色总数
	{
		int f=su,lin[17],ff=0;//lin[i]为临时数组,用来记录新涂了哪些矩形,方便之后回溯 
		for(int i=1;i<=16;i++)lin[i]=0; 
		for(int i=1;i<=n;i++)
		{
			if(s[i].d==g&&ex[i]==0)
			{
				int si=0;
				for(int j=1;j<=sum[i];j++)//判断需要的矩形有几个已经预先涂好 
				if(ex[ss[i][j]])si++;
				if(si==sum[i])//如果都涂好了就说明可以涂这个矩形了 
				{
					ex[i]=1;lin[++ff]=i;//标记为已涂过 
					su++;
				}
			}
		}
		if(f==su)continue;//如果用这个颜色不能涂更多矩形,就换一个颜色 
		ans[++v]=g;//记录每一次使用的颜色 
		if(ans[v-1]!=ans[v]&&v!=1)//如果与上一次使用的颜色不同,就将次数加1 
		dfs(k+1,su);
		if(ans[v-1]==ans[v]||v==1)//如果与上一次使用的颜色相同或者是第一次使用,就不加次数 
		dfs(k,su);
		ans[v]=0;--v;//回溯 
		for(int i=1;i<=ff;i++)
		ex[lin[i]]=0,su--;
	}
}
bool cmp(node a,node b)
{
	if(a.x1==b.x1)return a.y1<b.y1;
	return a.x1<b.x1;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>s[i].x1>>s[i].y1>>s[i].x2>>s[i].y2>>s[i].d;
		tot=max(tot,s[i].d);//更新tot 
	}
	sort(s+1,s+n+1,cmp);//从上到下排序 
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	{
		if(i!=j)
		{    //如果其他矩形的y1与y2有一个在此矩形的y1与y2之间,并且是紧靠着的,就是合法的 
			if(((s[j].y1>=s[i].y1&&s[j].y1<s[i].y2)||(s[j].y2>s[i].y1&&s[j].y2<=s[i].y2))&&s[j].x1<s[i].x1&&s[i].x1==s[j].x2)
			{
				sum[i]++;//个数加1 
				ss[i][sum[i]]=j;//记录是哪个矩形 
			}
		}
	}
	dfs(1,0);
	printf("%d",minn);
	return 0;
}
```


------------
### 第一次写题解，如有不妥之处还请海涵

---

## 作者：lovely_aris (赞：9)

状压 DP，思路：

不知道怎么直接预处理各种各样的条件，只能一点一点在循环里写了。
这些可能对找 bug 和没考虑到的情况有用。

给出几个区块，我们在涂色时需要把与它本身上方有重叠的区块涂色，首行没有前置区块，我们要求最少换笔数，**注意不是落笔数，只要是相同颜色的画笔，可以在任意符合规则的位置，即无需区块相邻，都可以用一笔完成**。

题目要求需要前置区块完成才可进行这一块，~~所以想到拓扑~~，我们用链式前向星来存前置区块。同时我用结构体来存区块。

再看颜色要求 $c\leq20,n\leq16$ 应数据范围，我们可以用状态压缩来记录已经画了哪几个区块。

对于 dp 我们记 $f_{i,j}$ 当区块状态为 $i$ 时最后一笔的颜色为 $j$。

状态转移：我们找一个存在于状态 $i$ 中的点为 $j$，且颜色为 $col$，前一个状态的落笔颜色为 $k$ 如果 $j$ 的颜色与 $k$ 相等，则 $f_{i,col}=\min(f_{i-2^{j-1},k})$，否则就将换笔数加 $1$。


这就是整体思路。接下来还有我自己的一些判断条件，我会在代码里用注释体现。


~~这些花了一个下午~~。

接下来是代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int in(){
	int ans=0,f=1;
	char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) ans=ans*10+c-'0';
	return ans*f;
}//快读 
struct F{
	int xl,xr,yu,yd,col;
}sq[50];//区块 
int n,m;
int fir[1010],ne[1010],en[1010],cnt;//链式前向星 
void add(int u,int v){
	cnt++;
	ne[cnt]=fir[u];
	en[cnt]=v;
	fir[u]=cnt;
}
int f[100010][50],d[1010];
bool check(int s,int p){//判断当状态s时，区块p是否可以画 
	for(int i=fir[p];i;i=ne[i]){
		int u=en[i];
		if(((1<<(u-1))&s)==0) return 0;
	}
	return 1;
} 
bool cd(int i,int j){//判断区块i，j是否有重叠 
	int xl1=sq[i].xl,xr1=sq[i].xr;
	int xl2=sq[j].xl,xr2=sq[j].xr;
	if(xr1<=xl2) return 0;
	if(xr2<=xl1) return 0;
	return 1;
}
bool ch_col(int s,int p,int col){
	//判断当状态s时  当前区块为p  s的上一个状态（去除p）的落笔颜色中是否包含col
        //如果没有就不能遍历 
	if(d[p]==0&&s==(1<<(p-1))) return 1;//如果是无前置区块，则可以直接落笔 
	s-=(1<<(p-1));
	for(int i=1;i<=n;i++){
		if(s&(1<<(i-1))){
			if(col==sq[i].col) return 1;
		}
	}
	return 0;
}
int main(){
//	freopen("data.in","r",stdin);
	n=in();
	for(int i=1;i<=n;i++){
		sq[i].yu=in();
		sq[i].xl=in();
		sq[i].yd=in();
		sq[i].xr=in();
		sq[i].col=in();
		m=max(m,sq[i].col);//最大颜色 
	}
	//找自己的前置区块 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(sq[i].yd==sq[j].yu && i!=j){
				if(cd(i,j)){//i是j的前置区块
					add(j,i);
					d[j]++;//记录有多少个前置区块
				}
			}
		}
	}
	//状压dp 
	memset(f,0x3f,sizeof(f));
	for(int i=1;i<=m;i++) f[0][i]=1;
	for(int i=1;i<(1<<n);i++){
		for(int j=1;j<=n;j++){
			int to=i-(1<<(j-1));//前一个状态to 
			if(check(to,j) && ((i&(1<<(j-1)))!=0)){//j在i状态中且j的前置区块完成 
				for(int k=1;k<=m;k++){
					if(sq[j].col==k && (ch_col(i,j,k))){//颜色相同 且颜色存在于状态i中 
						f[i][sq[j].col]=min(f[i][sq[j].col],f[to][k]);
					}
					else f[i][sq[j].col]=min(f[i][sq[j].col],f[to][k]+1);
				}
			}
		}
	}
	int ans=0x7fffffff;
	for(int i=1;i<=m;i++){
		ans=min(ans,f[(1<<n)-1][i]);
	}//将所有可能落笔颜色遍历 
	cout<<ans;
	return 0;
}
```

---

## 作者：Salamander (赞：9)

用二进制压缩状态，一个n位二进制数的第i位为0或1表示第i块板是否图上了色。

f[A][i]表示达到A状态，最后一次涂色的颜色是i的最少换颜色次数。

位运算不懂的自己百度。

检查二进制数A第i位是否为0: A&(1<<(i-1))==(1<<(i-1))

二进制数A的第i位上的1变为0后的数: A-(1<<(i-1))


详见代码：






    
    
```cpp
#include<bits/stdc++.h>
using namespace std;
#define file(x) freopen(#x".in","r",stdin),freopen(#x".out","w",stdout)
int f[(1<<16)+1][21],n,color[20],b[100][100],maxcolor=0;
int num[20],temp[20][20],xx[20],xy[20],yx[20],yy[20],ans=INT_MAX;
bool check(int A,int x)//检查A状态下第x个矩形上方的所有矩形是否已经涂完色
{
    bool flag=true;
    for(int i=1;i<=num[x]&&flag;i++)//num[x]是第x个矩形上方相邻的矩形个数，temp[x][i]是这些矩形的编号
        if(((1<<(temp[x][i]-1))&A)!=(1<<(temp[x][i]-1)))flag=false;//如果上方某个矩形还未被涂色，则第x个矩形就不能涂色，就标记flag为false
    return flag;//如果上方没有矩形则num[x]==0，就不会进行循环，直接return ture
}
int main()
{
    //file(paint);
    memset(f,32,sizeof f);//初始化
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d%d%d%d",&xx[i],&yx[i],&xy[i],&yy[i],&color[i]);
        if(color[i]>maxcolor)maxcolor=color[i];//记录颜色的个数，即最大颜色编号
        for(int j=xx[i];j<xy[i];j++)
            for(int k=yx[i];k<yy[i];k++)
                b[j][k]=i;//b[i][j]表示第i行j列所在的矩形编号
    }
    for(int i=1;i<=n;i++)
    {
        int k=xx[i]-1;//扫一遍矩形上面一行，num[i]表示矩形i上方的不同矩形个数，temp[i][j]表示第i个矩形上方第j个矩形的编号。
        if(k<0)continue;
        for(int j=yx[i];j<yy[i];)//从左往右扫上方的矩形
            if(b[k][j])//如果有矩形
            {
                int l=j;
                while(b[k][l]==b[k][j]&&l<yy[i])l++;//跳过编号相同的矩形
                temp[i][++num[i]]=b[k][j];//记录上方的矩形编号
                j=l;//继续扫
            }
    }
    for(int i=1;i<=maxcolor;i++)
        f[0][i]=1;//初始化，所有平板未涂色时需要拿一次刷子。
    for(int A=1;A<=((1<<n)-1);A++)//枚举每个着色状态，n块平板的状态用二进制表示就是0到(2^n-1),位运算优化
        for(int i=1;i<=n;i++)//枚举放第i块平板
            if(((1<<(i-1))&A)==(1<<(i-1))&&check(A,i))//检查该状态中是否已经涂上了第i个矩形，还有该状态下第i个矩形的上方矩形是否都已涂完
```
{//状态转移:
for(int j=1;j<=maxcolor;j++)//枚举每种颜色

if(j!=color[i])f[A][color[i]]=min(f[A][color[i]],f[A-(1<<(i-1))][j]+1);//如果前驱状态的颜色不同就要换刷子

f[A][color[i]]=min(f[A][color[i]],f[A-(1<<(i-1))][color[i]]);//颜色相同就不换刷子

    
    
```cpp
            }
    for(int i=1;i<=maxcolor;i++)
        ans=min(ans,f[(1<<n)-1][i]);//枚举最后颜色不同的最终状态，取最小值为结果
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Nanchtiy (赞：7)

更好的阅读体验：
[Broken_String's blog](http://www.cnblogs.com/BrokenString/)

### 思路

看到n<16 整个坐标<100 肯定想到~~暴力~~啊

蒟蒻来一发**最简单易懂**的题解~~（因为不会DP哈~~

首先我们用map数组来存坐标图 **注意前面的坐标需要加1 **

因为输入的是坐标 而我们需要的是格子（后面同理)

随后一个结构体存下坐标和颜色 还有判断是否涂过

开始搜索时只要从**最顶上的几个**开始搜索

搜索时有两种情况

- 当颜色一样时 就不用多算拿笔数
- 当颜色不一样时 就要算拿笔数

加上个**最优性剪枝**可以跑得飞快 33ms

~~吐槽：这数据也太水了 本蒟蒻一开始判断写反了还有75分的说~~

### 代码

```cpp
#include<iostream>
using namespace std;
#define maxn 110
int n,num,ans=1e9+7;
int map[maxn][maxn];//存图 
struct sq
{
	int x1;
	int x2;
	int y1;
	int y2;
	int col; 
	bool vis;//判断是否涂色 
}a[21];
void cinn()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].x1>>a[i].y1>>a[i].x2>>a[i].y2>>a[i].col;
		a[i].vis=0;
		for(int j=a[i].x1+1;j<=a[i].x2;j++)
		    for(int k=a[i].y1+1;k<=a[i].y2;k++)
		    map[j][k]=a[i].col;//保存颜色 
	}
}
void add(int x)//涂色后为0 
{
	for(int j=a[x].x1+1;j<=a[x].x2;j++)
		    for(int k=a[x].y1+1;k<=a[x].y2;k++)
		    map[j][k]=0;
}
void del(int x)//清除涂色 
{
	for(int j=a[x].x1+1;j<=a[x].x2;j++)
		    for(int k=a[x].y1+1;k<=a[x].y2;k++)
		    map[j][k]=a[x].col;
}
int pd(int x)//判断上面是否涂色 
{
	for(int i=a[x].y1+1;i<=a[x].y2;i++)
	if(map[a[x].x1][i]!=0) return 0;//如果上面有一格没涂就不能涂这格 
	return 1; 
}
void dfs(int now,int sum,int cnt)
{
	if(sum>ans) return;//最优性剪枝 
	if(cnt==n)//当所有矩形都涂色完成 
	{
		ans=sum; //不用取最小值 因为前面的剪枝已经把大于最优解剪掉了 
		return;
    }
    for(int i=1;i<=n;i++)//枚举矩形 
    {
		if(!a[i].vis&&pd(i))//如果这个矩形没有被涂色 且可以涂 
		{
			if(a[i].col==a[now].col&&pd(i))//当颜色一样时 
			{
				a[i].vis=1;
				add(i);
				dfs(i,sum,cnt+1);//拿笔数不用加1 而已涂矩形要加1 
				a[i].vis=0;
				del(i);
			}
			if(a[i].col!=a[now].col&&pd(i))//当颜色不一样时 
			{
				a[i].vis=1;
				add(i);
				dfs(i,sum+1,cnt+1);//都要加1 
				a[i].vis=0;
				del(i);
			}
			
		}
    }
}
int main()
{
	cinn();
	for(int i=1;i<=n;i++)
	{
		if(!a[i].x1&&!a[i].vis)//只要从最上面开始搜索 
		{
			a[i].vis=1;
			add(i); 
			dfs(i,1,1);//先取第一个 
			a[i].vis=0;
			del(i);
		}
	}
	cout<<ans;
} 
```

---

## 作者：kokodayou (赞：6)

看了一下讨论里的HACK数据，好像确实干掉了不少题解，惊奇的发现我居然过了，完善一下其他搜索题解吧……

## 主要思路：
### 暴力DFS。。
**剪枝必不可少**

1. 当确定好一个矩形区域时，再次寻找只照和他颜色相同的矩形
1. 用vis判断一个矩形是否被涂过色，涂过则直接返回
1. 当前更换刷子次数已经大于最小值时，不论后面策略多优都没有用了，

 _人称：最优性剪枝_ 

最后不要忘记回溯操作噢。

------------

# CODE：          注释貌似还算详细

```cpp
#include<bits/stdc++.h>   //written by    kokodayou
#define ll long long
#define R register int
#define IL inline void
#define AC return 0      //deaine大法好 
using namespace std;
struct dot{
    ll x1,x2,y1,y2,color;
}a[17];
bool vis[20];
ll n,Min;
bool pd(ll k){
    for(R i=1;i<=n;i++)
    	if(!vis[i]&&a[i].y2==a[k].y1&&((a[k].x1>=a[i].x1&&a[k].x1<a[i].x2)||(a[k].x2>a[i].x1&&a[k].x2<=a[i].x2)||(a[k].x1<=a[i].x1&&a[k].x2>=a[i].x2)))
			return 0;      //如果在它上面和他紧挨着的一个矩形还没有被涂色，那么他必不行 
    return 1;
}
IL dfs(ll cnt,ll temp,ll c){
    if(cnt>=Min)return;            //最优性剪枝 
    if(temp==n)Min=cnt;            //更新答案 
    for(R i=1;i<=n;i++)
    	if(!vis[i]&&pd(i)){
        	if(a[i].color==c){
            	vis[i]=1;       //标记为已遍历过 
            	dfs(cnt,temp+1,c);          //颜色不变，还用老刷子 
            	vis[i]=0;         //回溯 
        	}
			else{
            	vis[i]=1;
            	dfs(cnt+1,temp+1,a[i].color);   //更改搜索的颜色，换一次刷子 
            	vis[i]=0;        //回溯 
        	}
    	}
}
int main(){
    cin>>n;
    Min=n;        //n次换刷子一定可以涂完 
    for(R i=1;i<=n;i++)
    	cin>>a[i].y1>>a[i].x1>>a[i].y2>>a[i].x2>>a[i].color;
    dfs(0,0,-1);
    cout<<Min;
    AC;        //完美AC 
}
```

题解虽好，抄袭不得。如有抄袭，奈何不得……

最后，祝大家CSPrp++！

---

## 作者：Xssion37_XY (赞：4)

### 前情提要

本人自认为码风~~比较~~良好，请安心食用。

~~本题解因放错了链接而重新交了一次，麻烦管理员了。~~

[题目链接](https://www.luogu.com.cn/problem/P1283)

[更好的阅读体验](https://www.luogu.com.cn/article/trte6fd5)

### 实际分析

不会状压 DP，写一发搜索吧。

我首先说明一下大概思路。

1. 使用结构体存储矩形的左上角和右下角的坐标以及颜色。

2. 排序,确定涂的顺序，如果两块砖不在一个水平面，将 $x$ 小的排在上面，否则就将 $y$ 小的排在上面，保证砖块从左上到右下排列。

3. 深搜，枚举颜色、记录数量、递推、回溯就可以了。

4. 剪枝，如果当前涂色次数大于等于记录的次数，直接退出就行了。

大概就是这样，详细解释请看代码。

### 代码部分

```
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXX = 20;
const int MAXX_normal = 21;
struct node {
	int Lx, Ly, Rx, Ry, c;
} a[MAXX];
int vis[MAXX_normal]; // 访问数组
bool b[MAXX_normal][MAXX_normal]; // b[i][j] 第 i 块砖是否在第 j 块砖的上方，0 表示不在，1 表示在
int color[MAXX]; // 颜色数量数组
int n, m = 20, ans = 16; // 16 个格子，就算每个格子拿一次，最多 16 次
bool cmp(node a, node b) {
	if (a.Rx != b.Rx) {
		return a.Rx < b.Rx;
	}
	return a.Ry < b.Ry;
}
bool check(int x) { // 判断这块砖是否涂过颜色
	for (int i = 0; i < n; i ++) {
		if (b[x][i] == 1 and vis[i] == 0) {
			return 0;
		}
	}
	return 1;
}
// x 是次数，col 是当前涂的砖的颜色，sum 是当前涂过的砖的总数
void dfs(int x, int col, int sum) {
//	cout << 1;
	if (x >= ans) {
		return ;
	}
//	cout << 2;
	if (sum == n) {
		ans = x;
		return;
	}
//	cout << 3;
	for (int i = 0; i < m; i ++) { // 枚举颜色
		int tmp = 0; // 记录本次涂砖的数量
//		cout << 4;
		if (color[i] and i != col) { // 判断是否可以涂
			for (int j = 0; j < n; j ++) {
				// 递推
				if (!vis[j] and check(j) and a[j].c == i) { // 没有被涂过、可以涂且是我们想要的
					vis[j] = 1;
					tmp ++;
				} else if (vis[j] > 0 and a[j].c == i) {
					vis[j] ++;
				}
			}
//			cout << 5;
			if (tmp > 0) {
				dfs (x + 1, i, sum + tmp); // 如果已经涂了，搜索下一块砖
			}
//			cout << 6;
			// 回溯
			for (int j = n - 1; j >= 0; j --) {
				if (vis[j] == 1 and check(j) and a[j].c == i) {
					vis[j] = 0;
					tmp --;
				} else if (vis[j] > 0 and a[j].c == i) {
					vis[j] --;
				}
			}
		}
	}

}
int main() {
	cin >> n;
	for (int i = 0; i < n; i ++) {
		cin >> a[i].Lx >> a[i].Ly >> a[i].Rx >> a[i].Ry >> a[i].c;
		a[i].Lx ++;
		a[i].Ly ++;
		color[a[i].c] ++; // 统计颜色数量
	}
	sort (a, a + n, cmp);
	for (int i = 1; i < n; i ++) {
		for (int j = i - 1; j >= 0; j --) {
			if (a[i].Lx == a[j].Rx + 1 and ((a[i].Ly >= a[j].Ly and a[i].Ly <= a[j].Ry) or (a[i].Ry >= a[j].Ly and a[i].Ry <= a[j].Ry))) {
				b[i][j] = 1;
			}
		}
	}
	dfs(0, 0, 0);
	cout << ans;
	return 0;
}
```

完结撒花！

---

## 作者：Alemirai (赞：4)

# [题目传送门](https://www.luogu.com.cn/problem/P1283)

# 暴力

对于最大只有16个矩形，~~不同于下面dalao的dp做法~~，本蒟蒻第一反应就是暴力做法。

------------
# 思路
![](https://cdn.luogu.com.cn/upload/pic/90.png)

对于样例中的情况，它的方式是

![](https://cdn.luogu.com.cn/upload/image_hosting/y6apopb5.png)

由于必须要等上方都刷完才能开始刷，因此我们可以定义一个 c 数组（颜色数组），代表某一格是某种颜色。

即
![](https://cdn.luogu.com.cn/upload/image_hosting/26rtndah.png)

当填完 B 块时，将 B 块部分填为 0 。

![](https://cdn.luogu.com.cn/upload/image_hosting/izrtmx5d.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

当某一块的左上角到右上角的上面一行全是 0 时，就可以填这一块。

例如，当填完 D 块时。

![](https://cdn.luogu.com.cn/upload/image_hosting/dkoojve0.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

此时是不能填 F 块的，因为 F 块上方一排有不是 0 的数，当填完 C 块时才能填 F 。

当整个颜色数组都为 0 时，深搜停止（注意剪枝）。

以上就是本体基本思路，废话不多说，直接上代码（虽然我知道看别人暴力代码很烦） ~~~~。


------------

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
int n;
int a[20][6];      //输入数组
bool isp=true,isp1=false;   //isp判断某矩形是否能刷,isp1判断是否刷完
int ans=0;                   //最小值
int c[100][100];   //颜色数组
int maxx=-1,maxy=-1;      //右下角横纵坐标
void f(int sum,int color)   //sum：已拿起刷子次数，color：上一次刷子颜色
{
	isp1=false;
	if(sum>ans&&ans!=0)     //剪枝：即遇到更大的值直接return
	{
		return;
	}
	for(int i=0;i<maxy;i++)    //18-28行判断是否刷完
	{
		for(int j=0;j<maxx;j++)
		{
			if(c[i][j]!=0)
			{
				isp1=true;
				break;
			}
		}
	}
	if(!isp1)           //如果刷完,将sum附给ans
	{
		ans=sum;
		return;
	}
	for(int i=0;i<n;i++)   //开始循环
	{
		isp=true;
		if(a[i][0]>0&&a[i][5]==0)   //若此矩形没刷且此矩形左上角不在第一行（若左上角在第一行无需判断,直接可以刷）
		{
			for(int x=a[i][1];x<a[i][3];x++)
			{
				if(c[a[i][0]-1][x]!=0)    //若从左上角到左下角的上方有没被刷的
				{
					isp=false;         //则此矩形不能被刷
				}
			}
		}
		if(a[i][5]==0&&isp)     //若此矩形没被刷过且可以被刷
		{
			for(int y=a[i][0];y<a[i][2];y++)
			{
				for(int x=a[i][1];x<a[i][3];x++)
				{
					c[y][x]=0;       //将被刷区域颜色设为0
				}
			}
			a[i][5]=1;    //状态调成已被刷
			if(a[i][4]==color)
			{
				f(sum,a[i][4]);     //若此次颜色和上次一样，则sum不变
			}
			else
			{
				f(sum+1,a[i][4]);
			}
			for(int y=a[i][0];y<a[i][2];y++)    //65-72行回溯
			{
				for(int x=a[i][1];x<a[i][3];x++)
				{
					c[y][x]=a[i][4];
				}
			}
			a[i][5]=0;
		}
	}
}
int main()
{
	cin>>n;
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<5;j++)
		{
			cin>>a[i][j];
			if(j==2&&a[i][j]>maxy)        //判断拼成的一个大矩形的右下角横纵坐标
			{
				maxy=a[i][j];
			}
			if(j==3&&a[i][j]>maxx)
			{
				maxx=a[i][j];
			}
		}
		a[i][5]=0;                     //a[i][5]判断此矩形是否已刷
		for(int y=a[i][0];y<a[i][2];y++)
		{
			for(int x=a[i][1];x<a[i][3];x++)
			{
				c[y][x]=a[i][4];       //进行颜色数组填充
			}
		}
	}
	f(0,-1);     //调用函数
	cout<<ans;   //AC
}
```

---

## 作者：little_prince (赞：3)

## 细节决定成败。

[P1283 平板涂色](https://www.luogu.com.cn/problem/P1283)

这道题其实完全没有什么思维难度，但是我因为不注意实现代码的细节，加上自己码力不强，没有多训练，以至于一道很简单的搜索题调了一天多。

n <= 16,所以指数级别的暴搜都绰绰有余。想的话就是暴搜啊，每次能涂就涂了去，那么在涂的时候就提前预处理一下那些可以接着涂，一路涂下去就OK了。

思路简单，但**抽象**。每一处地方都想好怎么写了吗？没有。边敲边想的结果是耗时多，错误多，最后还是看了题解。下面来详细对这道题进行分析：

细节1。

我们真的就在搜索的时候搜到一块可以涂，顺着这一块的下面一直涂下去？打标记涂过了还好说，最大的问题是——**怎么回溯呢？难道再开一个数组记录回溯上去，清空这次的影响？** 仔细想想就会发现，这样做非常麻烦，完全不知道怎么写，就算写了出了错也完全不好调试。

所以，不如我们先按坐标给所有方块排一个扫描的顺序，使得我们在扫描的时候
### 可以不重不漏地搜索到当前能涂的方块（能够保证顺序，即保证了能涂的方块都被涂）。

可不可以做到？如果当时我在这里仔细一想，自然就很容易想到，把扫描的顺序换成**一排一排的扫，每一排从左往右**，这样就解决了扫描的问题。

当然，预处理出f[i][j]表示第i个方块对第j个方块有影响，紧邻j的上面，如果不先涂i（即f[i][j] = 1 但!pd[i]） ，就不能涂j。

细节2。

回溯。数据范围这样小，并且怎么涂的都想好了，难道我们就不能开一个数组st把你涂的方块存起来，然后回溯的时候再清空影响？不这么做，再从当前方块往下清空，麻烦难写，我也很难调试。


………………

所以这道题考的是代码能力，考我**究竟会不会合理地安排代码作用**，其实DFS剪枝根本没什么，加一个最优化剪枝，当前涂的次数超过答案就回溯，这道题就能过了。

综上所述，代码实现的细节决定成败。希望这道题能给自己点警醒，也要多多锻炼代码实现能力！

附上代码：

```
#include<bits/stdc++.h>
using namespace std;
struct node{
	int xa,ya,xb,yb,color;
}s[27];
int n,f[27][27],c[27],pd[27],ans = 0x3f3f3f3f;
bool ok(int i,int j){
	if(s[i].xb != s[j].xa) return false;
	if(s[j].ya <= s[i].ya && s[j].yb <= s[i].ya) return false;
	if(s[j].ya >= s[i].yb && s[j].yb >= s[i].ya) return false;
	return true;
}
bool cmp(const node &a,const node &b){
	if(a.xa == b.xa) return a.ya < b.ya;//想清楚怎么排，最后扫的顺序是一行行横着的！
	return a.xa < b.xa;
}
bool check(int j){
	for(int i = 1;i <= n; i++)
	{
		if(f[i][j] && !pd[i]) return false;
	}
	return true;
}
void dfs(int t,int countt,int lc){
	if(t >= ans) return;
	if(countt == n){
		ans = min(ans,t);
		//for(int i = 1;i <= n; i++)
		//printf("pd[%d] = %d\n",i,pd[i]);
		return;
	}
	for(int u = 1;u <= 20; u++)
	{
		if(!c[u] || lc == u) continue;
		int num = 0;
		int st[27];memset(st,0,sizeof(st));
		for(int i = 1;i <= n; i++)
		{
			if(!pd[i] && s[i].color == u && (s[i].xa == 0 || check(i)) ){
				pd[i] = 1;
				num++;
				st[++st[0]] = i;
			}
		}

		/*for(int i = 1;i <= st[0]; i++)
		printf("st[%d] = %d\n",i,st[i]);
		cout<<"and num = "<<num<<endl;*/

		if(num > 0) dfs(t+1,countt + num,u);
		
		
		for(int i = 1;i <= st[0]; i++)	
		{
			pd[st[i]] = 0;num--;
		}
		/*cout<<"check_t = "<<t<<"  countt = "<<countt<<endl;
		cout<<"num = "<<num<<endl;
		for(int k = 1;k <= n; k++)
		printf("pd[%d] = %d\n",k,pd[k]);*/
	}
}

void tiaoshi(){
	for(int i = 1;i <= n; i++)
	printf("s[%d] : xa=%d,ya=%d,xb=%d,yb=%d\n",i,s[i].xa,s[i].ya,s[i].xb,s[i].yb);
	for(int i = 1;i <= n; i++)
	for(int j = 1;j <= n; j++)
	printf("f[%d][%d] = %d\n",i,j,f[i][j]);
}
int main(){
	scanf("%d",&n);
	for(int i = 1;i <= n; i++)
	{
		scanf("%d%d%d%d%d",&s[i].xa,&s[i].ya,&s[i].xb,&s[i].yb,&s[i].color);
		c[s[i].color]++;
	}
	sort(s+1,s+n+1,cmp);//排序是细节！
	for(int i = 1;i <= n; i++)
	for(int j = 1;j <= n; j++)
	{
		if(i == j) continue;
		if(ok(i,j)) //这里非常细节！
		f[i][j] = true;
	}
	//tiaoshi();
	dfs(0,0,0);
	cerr<<"ans = ";
	cout<<ans<<endl;
	return 0;
}

```


 _努力的日子没有一天是轻松地过去的。_ 

---

## 作者：HeinzGuderian (赞：3)


[题目传送门](https://www.luogu.org/problem/P1283),

首先，这个题是先输入纵坐标再输入横坐标

这个题的样例就卡了我老半天(主要因为我们主教练从网上找的蹩脚的翻译问最少要用几支笔刷)，直到我回过头来看模拟赛的原题才明白

好，那么我们来看样例，大概是这样子的：![样例图](https://cdn.luogu.com.cn/upload/image_hosting/mgzfeg3q.png).

我们不妨把一个区域看成一个整体，然后用一个visit数组记录该区域是否被访问

注释大都写在代码里了，只有一个地方需要解释



判断位置关系是这个题最重点的部分

对于一个区域m，如果它上面的矩形中有任意一个未被上色，那么它就不能被上色，返回不行就可以了。

我们不知道哪个区域在它的上面且和它直接接触，所以我们枚举每一个区域i

那么怎么判断矩形在它上方呢？只要判断横纵坐标就可以了。如果区域i在m的上方且与它直接接触，那么i的右下纵坐标b2[i]一定和m的左上纵坐标b1[m]相等，这时再进行进一步判断，不外乎3种情况1.左相交 2.右相交 3.i包含m（m包含i可以用相交判断）
![情况1](https://cdn.luogu.com.cn/upload/image_hosting/tevxy68q.png)
![情况2](https://cdn.luogu.com.cn/upload/image_hosting/s571r8bg.png)
![情况3](https://cdn.luogu.com.cn/upload/image_hosting/3axpkii8.png)

可以结合着图片自己理解。

奉上判断位置的代码

```cpp

inline bool judge(int k)
{
	for(R i=1;i<=n;i++)
	{
		if(!vis[i]&&b2[i]==b1[k])
			if((a1[k]>=a1[i]&&a1[k]<a2[i])||(a2[k]>a1[i]&&a2[k]<=a2[i])||(a1[k]<=a1[i]&&a2[k]>=a2[i]))//对应上面的3种情况
				return true;
	}
	return true;
}
```


[奆佬的文章](https://www.luogu.org/blog/kokodayou/solution-p1283)


----------


# My CODE
```cpp
#include<bits/stdc++.h>
#define ll long long
#define R register int
#define N 100001
#define loli return 0; 
using namespace std;
bool vis[N];
int n,minn,m;
int a1[N],a2[N],b1[N],b2[N],c[N];
inline bool judge(int k)
{
	for(R i=1;i<=n;i++)
	{
		if(!vis[i]&&b2[i]==b1[k])
			if((a1[k]>=a1[i]&&a1[k]<a2[i])||(a2[k]>a1[i]&&a2[k]<=a2[i])||(a1[k]<=a1[i]&&a2[k]>=a2[i]))
				return false;
	}
	return true;
}
inline int read()//读入优化，数据多的时候很有用，但是注意千万不要写炸了，不然你会T到怀疑人生
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
inline void dfs(int num,int tot,int color)//大法师好！！
//num代表画笔的数目，从0开始，tot代表一共走过了多少个区域，颜色代表当前所在区域的颜色
{
	if(num>=minn)return;//可行性剪枝，如果当前画笔数已经比最小值大，那么也就没有必要比下去了，直接返回
	if(tot==n)minn=num;//如果已经走遍了所有画板上的区域(一共有n个)那么就更新一次minn值
	for(R i=1;i<=n;i++)
	{
		if(!vis[i]&&judge(i)==true)
		{
			if(c[i]==color)//这个时候分为两种情况，如果有一个同该区域相连的区域颜色相同
			{
				vis[i]=1;//把该区域标记为访问过
				dfs(num,tot+1,color);//不换画笔，访问区域+1，区域颜色不变
				vis[i]=0;//回溯
			}
			else
			{
				vis[i]=1;
				dfs(num+1,tot+1,c[i]);//换画笔，访问区域+1，区域颜色改变为访问区域的颜色
				vis[i]=0;
			}
		}
	} 
}
int main()
{
	n=read();
	minn=n;//最差情况为n
	for(R i=1;i<=n;i++)
	{
		b1[i]=read(),a1[i]=read(),b2[i]=read(),a2[i]=read(),c[i]=read();
	}
	dfs(0,0,-1);//深搜，color标记为-1，表示还没有开始搜索
	printf("%d\n",minn);
	loli;//主教练优化
}
```
### 最后祝大家CSP2019RP++。
Update：2019-11-07 放大了图片。

蒟蒻第一次认真写题解，求管理员大大通过QwQ

---

## 作者：wsm52 (赞：2)

# 前言
这是一道蓝题？本蒟蒻不会状压 DP，况且数据也小，所以可以搜索。
# 思路
我们先要对每个矩形进行排序，将左上角纵坐标小的排在前面。然后记录位于各个矩形上方的矩形，然后进行搜索（结合代码理解，注意：矩形编号为排过序之后的编号，并非输入时的编号）。
# AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum=20;//因为矩形数量最多不超过16，所以sum不需要开太大 
struct nb{
	int lx,ly,rx,ry,c;
}a[20];
bool vis[20];
vector<int> con[20];
bool cmp(nb x,nb y){
	if(x.lx==y.lx) return x.ly<y.ly;//如果左上角x坐标相同，则左上角y坐标小的排在前面（可以不加） 
	return x.lx<y.lx;//左上角x坐标小的排在前 
}
bool check(int x){
	for(auto i:con[x]) if(!vis[i]) return false;
	return true;
}
void dfs(int x,int color,int num){//还剩多少个矩形、当前刷子颜色、拿起刷子次数 
	if(!x){
		sum=min(sum,num);
		return;
	}
	if(num>=sum) return;//小小剪枝 
	for(int i=1;i<=n;i++){
		if(vis[i]||!check(i)) continue;//当前的矩形已被涂色 或者 位于此矩形上方的矩形还未涂色 
		vis[i]=true;
		if(color==a[i].c) dfs(x-1,color,num);//当前刷子的颜色和矩形颜色相同，则继续使用当前刷子的颜色 
		else dfs(x-1,a[i].c,num+1);//反之则改变当前刷子的颜色，拿起刷子次数增加 
		vis[i]=false;
	}
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d%d%d%d%d",&a[i].lx,&a[i].ly,&a[i].rx,&a[i].ry,&a[i].c);
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)//查找位于第i个矩形上方的矩形 
		for(int j=i-1;j>0;j--)//由于已经排过序，因此从i~n的矩形没必要比较 
			if(a[j].rx<=a[i].lx&&((a[j].ly>=a[i].ly&&a[j].ly<a[i].ry)||(a[j].ry>a[i].ly&&a[j].ry<=a[i].ry)))
				//如果第j个矩形右下角x坐标比第i个矩形左上角的x坐标小
				//且第j个矩形左上角的y坐标位于 [第i个矩形左上角的y坐标,第i个矩形右下角的y坐标) 范围内
				//或者第j个矩形右下角的y坐标位于 (第i个矩形左上角的y坐标,第i个矩形右下角的y坐标] 范围内 
				con[i].push_back(j);//记录矩形编号 
	dfs(n,0,0); 
	printf("%d\n",sum); 
	return 0;
}
```
# 结尾
这道题难度并不高，主要考察代码能力还有搜索能力，独立思考一下就能做出来了。

---

## 作者：Lysea (赞：1)

## 一维状压 DP 做法

看到题解区要么用深搜，要么用二维 DP，于是来分享一下本题一维 DP 怎么做。

设 $dp_i$ 表示所有矩形的状态用二进制表示为 $i$ 时拿起刷子的最少次数。

如果 DP 只有一维，那么转移就会相对困难一些，最直接的想法枚举每一个颜色哪些位置是能够涂的（根据贪心不难想到，位置数量越多越好），然后用现在的状态去更新未来的状态。

然而问题又出现了，如果一个矩阵的上方还有一个相同颜色的矩阵，且上方的矩阵在本轮中可以被涂，假设下方的矩阵在上方的矩阵更新后也可以被涂，那么实际上我们是更新不到下方的矩阵的。

为了解决这个问题，我们观察到 $x$，$y$ 数据范围皆在 $100$ 以内，所以可以用一种很暴力的方法：每轮进行 $100$ 次更新，这样就可以保证所有能够被涂的矩阵都不会漏掉。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 20
#define M 25
#define INF 1e18
using namespace std;
struct node{
	int x,y,xx,yy,col;
}e[N];
int n,m,dp[1<<N],ned[M][M],c[M][M],qwq;
bool vis[N];
signed main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>e[i].y>>e[i].x>>e[i].yy>>e[i].xx>>e[i].col;
		c[e[i].col][++c[e[i].col][0]]=i;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(i!=j&&e[j].yy==e[i].y&&e[j].xx>e[i].x&&e[j].x<e[i].xx){
				ned[i][++ned[i][0]]=j;
			}
		}
	}
	for(int i=0;i<(1<<n);i++) dp[i]=INF;
	dp[0]=0;
	for(int i=0;i<(1<<n);i++){
		for(int j=1,tot;j<=20;j++){
			qwq=0,tot=100;
			for(int i=1;i<=n;i++) vis[i]=false;
			for(;tot--;)
			for(int k=1;k<=c[j][0];k++){
				int y=c[j][k],fl=1;
				for(int q=1;q<=ned[y][0];q++){
					if((1ll<<(ned[y][q]-1))&i||vis[ned[y][q]]) continue;
					fl=0;break;
				}
				if(fl) vis[y]=true;
			}
			for(int i=1;i<=n;i++){
				if(vis[i]) qwq+=(1ll<<(i-1));
			}
			dp[i|qwq]=min(dp[i|qwq],dp[i]+1);
		}
	}
	cout<<dp[(1<<n)-1];
	return 0;
}
```


---

## 作者：哈撒各一 (赞：1)

对于这道题的极小数据范围(c<=20,xy<100,n<=16),我们理所因当的想到搜索

 那么我们的暴力搜索思路就是:枚举每一个颜色,如果满足题目要求就涂上
 
 但是对于这道题的复杂度,我们不剪枝是一定过不了的
 
 所以我们考虑剪枝:
####  1.优化搜索顺序:
 	因为我们的每个矩形能不能涂是由他的上面紧靠的矩形决定的,那么我们可
 	按照左上的y和右下的y为关键字排序,我们就可以尽快的求出一个ans,配合
 	接下来的最优性剪枝可以达到更好的效果
####  2.排除等效冗余:
 	没想到;
####  3.可行性剪枝:
 	我们对于每一次涂矩形之前,检查一下他的上方紧靠的矩形是否被涂色,如果
 	没有,直接回溯
####  4.最优性剪枝:
 	如果当前求到的一个局部解大于我们已经求到的全局解,直接回溯
 ```
#include<bits/stdc++.h>
using namespace std;
#define N 110
struct Rec{
	int lx,ly,rx,ry,color;
	#define lx(x) rec[x].lx
	#define rx(x) rec[x].rx
	#define ly(x) rec[x].ly
	#define ry(x) rec[x].ry
	#define color(x) rec[x].color
	bool operator <(Rec A)const {
		if(A.ly!=ly)return ly<A.ly;
		return ry<A.ry;
	}
}rec[N];
int n,ans=INT_MAX,co_time[N],maxn;
int isnear[N][N],used[N];
inline bool can_draw(int x){//剪枝3 
	for(int i=1;i<=n;++i){
		if(isnear[x][i]&&!used[i])return 0;
	}
	return 1;
}
void dfs(int cnt,int alr,int las){
	if(cnt>=ans)return;//剪枝4 
	if(alr==n){
		ans=cnt;
		return;
	}
	for(int i=1;i<=maxn;++i){
		int sum=0;
		if(i!=las&&co_time[i]){
			for(int j=1;j<=n;++j){
				if(!used[j]&&color(j)==i&&can_draw(j)){
					used[j]=1;
					sum++;
				}
				else if(used[j]&&color(j)==i)used[j]++;
			}
			if(sum>0)dfs(cnt+1,alr+sum,i);
			for(int j=n;j>=1;--j){
				if(used[j]==1&&color(j)==i&&candraw(j)){
					used[j]=0;
					sum--;
				}
				else if(used[j]>1&&color(j)==i)used[j]--;
			}
		}
	}
}
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;++i){
		scanf("%d%d%d%d%d",&ly(i),&lx(i),&ry(i),&rx(i),&color(i));
		ly(i)++;lx(i)++;
		co_time[color(i)]++;
	}
	for(int i=1;i<=20;++i)if(co_time[i])maxn=i;
	sort(rec+1,rec+n+1);//剪枝1 
	for(int i=2;i<=n;++i){
		for(int j=i-1;j>=1;--j){
			if(ly(i)==ry(j)+1&&((lx(i)>=lx(j)&&lx(i)<=rx(j))||(rx(i)>=lx(j)&&rx(i)<=rx(j)))){
				isnear[i][j]=1;
			}
		}
	}
	dfs(0,0,0);
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：NULL0x7f (赞：1)

**本蒻看到那么多大佬用状压DP，深有感触**

**决定用广搜优化一下~~(逃)~~**

------------
首先来看一下DP的做法，发现状态好像~~很难~~设计

但是看一看数据范围，只有16个矩形，又因为每个矩形只有涂和不涂两种状态，用0/1分别表示这两种状态，于是我们就可以用n个有序的0/1来表示整个的状态了，也就是二进制数。

#### 进一步说，也就是一个状态只要用一个整数来表示。

但是，还要记一下最后一次拿起刷子的颜色。

**那么这样状态的设计就很~~显而易见~~了，设f[s][c]表示当前的状态用s表示，最后拿起刷子的颜色为c。**

**转移也比较容易，用转出式(方便广搜优化)，枚举在当前状态s下能涂的块j**
```cpp
f[j][color[j]]=max{f[s][c]+(color[j]!=c)};
```

###  接下来是广搜优化（手动划重点）

观察发现，如果第一维状态用枚举，会有许多状态是不合法的，浪费了一些时间，当然对于本题是不会炸的，但是本蒟蒻深得某骗分大佬胡** 真传，决定优化一下。

既然会有冗余，我们就用合法情况的状态来转移，首先起始状态肯定是合法的，一个状态转移出的状态也一定是合法的，而且可以证明这些就是所有合法的情况。所以用广搜搜出转移出的所有状态，其他具体细节看代码吧~~，手累~~。

代码比较压行~~（还挺丑）~~，勿喷
```cpp
#define main mian //防作弊
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
const int N=17;
int x0[N],y0[N],x1[N],y1[N];
	//矩形左上角坐标(x0,y0)，右上角坐标(x1,y1)
int n,pre[N],color[N],f[1<<N][21],ans=30;
	//n为矩形个数，color[i]为第i个矩形的颜色。
	//pre[i]是一个二进制数，表示要放第i个矩形至少要的矩形组成的状态，
	//比如第i个矩形上方的矩形分别是第3，4个矩形，pre[i]=1100=12。
	//ans是最终的答案。
bool txt[1<<N][21];
	//txt[s][c]=true表示f[s][c]这个状态在队列中，false反之，就是用来判重的。
struct zt {int x,c;};
	//表示队列中的一个状态，记录f数组的两维是什么就行了。
queue < zt > Q;
	//用来实现广搜的队列，存状态。
int main() {
    scanf("%d",&n);
    for(int i=1;i<=n;++i)	scanf("%d%d%d%d%d",&x0[i],&y0[i],&x1[i],&y1[i],&color[i]);
    //预处理第i个矩形上方的矩形组成的状态。
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
            if(i!=j&&x0[i]==x1[j]&&y0[i]<y1[j]&&y1[i]>y0[j])
            //如果下方重合并且水平方向相交就是的。
                pre[i] |= 1<<(j-1);
            	//1<<j表示二进制中第j+1位是1，其它位是0
    memset(f,0x7f,sizeof f);//极大求最小
    for(int i=1;i<=n;++i)
        if(pre[i]==0) {
            zt t=(zt){1<<(i-1),color[i]};
            f[t.x][t.c]=txt[t.x][t.c]=1;
            Q.push(t);
        }//如果没有前置要求，直接涂，赋初值并放入队列。
    while(!Q.empty()) {
        zt t=Q.front();Q.pop();
        for(int i=1;i<=n;++i)
            if((t.x&(1<<(i-1)))==0&&(t.x&pre[i])==pre[i]) {
          	//如果没放过并且能放
                zt tt={t.x|(1<<(i-1)),color[i]};
                f[tt.x][tt.c]=min(f[tt.x][tt.c],f[t.x][t.c]+(t.c!=tt.c));
                //转移
                if(!txt[tt.x][tt.c])	Q.push(tt),txt[tt.x][tt.c]=true;
            }
    }//广搜模板
    for(int i=1;i<=20;++i)	ans=min(ans,f[(1<<n)-1][i]);
    printf("%d\n",ans);return 0;//代码什么的都去死吧
}
```
实测好像比没用广搜快一点~~（20ms）~~
# 蒟蒻第一篇题解，写得不好请见谅
# よろしくお願いします

---

## 作者：ast123 (赞：0)

可以发现 $n$ 很小，可以考虑状压 DP。定义 $dp[i][j]$ 为状态为 $i$，最后一个板子的编号为 $j$ 的情况最少要刷多少次。

+ 初始化：对于每一个最初可以刷的板子（即没有板子在它上方） $i$，将 $dp[2^{i-1}][i]$ 置为1，其他初始化为正无穷。
+ 转移：考虑从已知的 $dp[i][j]$ 转移到 $dp[i + 2^{k-1}][k]$。为了保证第 $k$ 块板子可以加入，可以枚举每一块板子，若板子 $l$ 在板子 $k$ 上方且与板子 $k$ 紧贴，也就是说 $xd[l] = xu[k]$ 且 $\min(yl[l], yl[k]) < \min(yr[l], yr[k])$，注意第二个式子不能取等，因为取等意味着只有顶点相邻，会被 Hack 掉。
+ 答案即是 $\sum_{i=1}^{n} dp[2^k-1][i]$。

注：对于 $i$ 满足 $1 \leq i \leq n $，$(xu[i],yl[i])$ 表示第 $i$ 块板子左上角的坐标，$(xd[i],yr[i])$ 表示第 $i$ 块板子右下角的坐标。

[代码](https://www.luogu.com.cn/paste/hsibol8u)

---

## 作者：Nuyoah_awa (赞：0)

### 题目大意

很多格子，染成不同颜色，每次拿起刷子可以刷多个格子然后放下。

### 题目分析

一看数据范围 $C \le 20,n \le 16$，要么是爆搜，要么是状压 DP，这道题好像两种都能过，在这里只讲状压。

状态肯定一维表示哪些格子已经刷过了，由于我们可能接着上一步，不放下刷子就接着刷，所以可以再开一维表示当前刷子的颜色。

于是就跟一般的状压一样了，枚举子状态 $t$。

$$f_{s,i} = \min\limits_{col = 1} ^{col\le 20}\{f_{t, k} + 1\}$$

特别的，特判一下颜色一样的情况，没有贡献直接转移。

这道题在选一个格子的时候还要判断这个格子“上面”的格子是否被选，由于 $n$ 很小，暴力枚举即可。

时间复杂度是 $\mathcal O(2 ^ n \times n ^2)$。

### code
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#define int long long

using namespace std;

const int N = 18, M = 25, INF = 2e18;
int n, ans = INF, f[1 << N][M];
struct node{
    int x1, x2, y1, y2, c;
}p[N];
vector <int> e[N];

bool check(int x, int y)
{
    for(int i = 0;i < e[x].size();i++)
        if(!(y & (1 << (e[x][i] - 1))))
            return false;
    return true;
}

signed main()
{
    scanf("%lld", &n);
    for(int i = 1;i <= n;i++)
        scanf("%lld %lld %lld %lld %lld", &p[i].x1, &p[i].y1, &p[i].x2, &p[i].y2, &p[i].c);
    for(int i = 1;i <= n;i++)
        for(int j = 1;j <= n;j++)
            if(i != j && p[j].x2 == p[i].x1 && p[j].y2 > p[i].y1 && p[j].y1 < p[i].y2)
                e[i].push_back(j);
    for(int i = 0;i <= (1 << n);i++)
        for(int j = 0;j <= 20;j++)   f[i][j] = INF;
    for(int i = 1;i <= 20;i++)   f[0][i] = 1;
    for(int i = 1;i < (1 << n);i++)
    {
        for(int j = 1;j <= n;j++)
        {
            if(!(i & (1 << (j - 1))) || !check(j, i))   continue;
            for(int k = 1;k <= 20;k++)
                if(p[j].c != k)
                    f[i][p[j].c] = min(f[i][p[j].c], f[i-(1 << (j-1))][k] + 1);
            f[i][p[j].c] = min(f[i][p[j].c], f[i-(1 << (j-1))][p[j].c]);
        }
    }
    for(int i = 1;i <= 20;i++)
        ans = min(ans, f[(1 << n)-1][i]);
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：_JF_ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1283)

数据范围很小，直接考虑状压或者暴搜，这里考虑状压。

那就需要考虑我们选了一个集合 $S$，很自然能够想到把每个矩形是/否涂过色标记为 $0/1$，从而衍生为一个集合。

转移的话也很简单，在枚举所有集合 $i$ 的时候，直接枚举可以使用的颜色，大力模拟出来使用了当前画笔后的集合情况为 $s$，方程就是：

$$dp_s=\min(dp_s,dp_i+1)$$

思路看起来很清晰，但是实际操作起来难度比较大，写到吐。

开始的时候应该先排序，按照左上角的横坐标来排，这样才能保证在从上往下覆盖的时候不会漏掉矩形。

在判断矩形的时候，考虑直接用一个数组标记矩形靠上的那条长上的所有点的覆盖情况，注意，当前矩形靠上的长和另一个矩形靠下的长在同一直线，但是交集为 $1$ 的时候，题目不认为这属于“覆盖”的范畴，那么这个点就不能被标记了。

当然你也不能用一个二维数组去搞，因为很多点都是重合的，这样会漏掉信息。

同时可以发现，按照我们这样的设法，这题的状态数其实不会很多，跑起来飞快。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =100;
int dp[(1<<16)+20],vis2[N],p[N],c[N],vis[N],vis1[N],cnt,n;
struct node{
	int l1,r1,l2,r2;
}a[N];
bool cmp(node a,node b){
	return a.l1<b.l1;
}
void col(int x){
	for(int i=0;i<n;i++)
		if(x>>i&1==1)	vis1[i]=true;
}
bool check(int i){
	for(int j=0;j<n;j++){
		if(i==j||(a[i].l1!=a[j].l2)||vis1[j]==false)	continue;
		if(a[i].r1<a[j].r2&&a[j].r1<=a[i].r1)	for(int k=a[i].r1;k<=a[j].r2;k++)	vis2[k]=1;
		if(a[i].r2>a[j].r1&&a[j].r2>=a[i].r2)	for(int k=a[j].r1;k<=a[i].r2;k++)	vis2[k]=1;
	}
	for(int k=a[i].r1;k<=a[i].r2;k++)	if(vis2[k]==0)	return false;
	return true;
}
void Add(int now,int x){
	int lst=now;
	for(int i=0;i<n;i++){
		if(c[i]!=x||(lst>>i&1==1))	continue;
		bool f=true;
		memset(vis2,0,sizeof(vis2));
		if(a[i].l1!=0)	f=check(i);
		if(f==true)	vis1[i]=true,now|=(1<<i);	
	}
	dp[now]=min(dp[now],dp[lst]+1);	
}
int main()
{
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>a[i].l1>>a[i].r1>>a[i].l2>>a[i].r2>>c[i];
		if(vis[c[i]]==false)	p[cnt++]=c[i],vis[c[i]]=true;
	}
	sort(a,a+n,cmp);
	memset(dp,0x3f,sizeof(dp));
	dp[0]=0;
	for(int i=0;i<(1<<n);i++){
		if(dp[i]==1061109567)	continue;
		for(int j=0;j<cnt;j++)
			memset(vis1,0,sizeof(vis1)),col(i),Add(i,p[j]);
	} 
	cout<<dp[(1<<n)-1]<<endl;
	return 0;
}

```


---

## 作者：Akaina (赞：0)

### 平板涂色

**深搜+剪枝**

这道题最多只能刷16次，感觉不需要迭代加深

最优性剪枝：1.当前涂色次数>ans，就返回

可行性剪枝：2.在搜索前需要先按照y坐标为第一关键字，x坐标为第二关键字从小到大进行排序

这道题用一个二维的f数组，第一维是i，第二维是j，来表示j是否是紧靠i上方的矩形，若f的值为1，则为是，f的值为0，则为否。我将点的坐标直接转化为单位小正方形的坐标进行处理。

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;
int n;
int f[20][20],ans=0;//f[i][j]表示第i个矩形上方是否是第j个矩形
struct node{
    int x1,y1,x2,y2,col;
}a[25];
bool cmp(node x,node y)
{
    if(x.y2!=y.y2)return x.y2<y.y2;
    return x.x1<y.x1;
}
int had(int lx1,int rx1,int y1,int lx2,int rx2,int y2)
{
    if(y1==y2+1)
    {
        if(min(rx1,rx2)>=max(lx1,lx2))return 1;
    }
    return 0;
}
int vis[50];
int check(int x)
{
    for(int i=1;i<x;i++)
    {
        if(f[x][i]==1)
        {
           if(vis[i]==1)continue;
           return 0;
        }
    }
    return 1;
}
void dfs(int dr,int last,int nowco,int cnt)
{
    if(dr>=ans)return ;
    if(cnt==n)
    {
        ans=min(ans,dr);
        return ;
    }
    for(int i=1;i<=n;i++)
    {
        if(vis[i])continue;
        if(check(i)==1)
        {
            if(a[i].col==nowco)
            {
                vis[i]=1;
                dfs(dr,i,a[i].col,cnt+1);
                vis[i]=0;
            }
            else
            {
                vis[i]=1;
                dfs(dr+1,i,a[i].col,cnt+1);
                vis[i]=0;
            }
        }
    }
}
int main()
{
    scanf("%d",&n);ans=1e9;
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d%d%d%d",&a[i].y1,&a[i].x1,&a[i].y2,&a[i].x2,&a[i].col);
        a[i].x1++;a[i].y1++;
    }
    sort(a+1,a+n+1,cmp);
    for(int i=2;i<=n;i++)
    for(int j=1;j<i;j++)
    {
        if(had(a[i].x1,a[i].x2,a[i].y1,a[j].x1,a[j].x2,a[j].y2)==1)f[i][j]=1;
    }
    dfs(0,0,0,0);
    printf("%d",ans);
    return 0;
}
```







---

## 作者：Randolph、 (赞：0)

## [P1283 平板涂色](https://www.luogu.org/problem/P1283)

数据范围也太小了qwq。。适合本萌新暴搜

**小小的剪枝：**

1.用pre预处理出每块矩形上方的矩形，pre[i][0]记录数目（如果数据范围再开大一点，直接1~n枚举判断可能超时qwq）

2.每次对于可以涂的矩形，颜色相同的直接标记涂上，不同的dfs（而不用全都dfs）

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int n,ans;
int x[17],y[17],xx[17],yy[17],c[17],pre[17][17];
bool vis[17];
inline bool chk(int i) {//检查上方的矩形是否都涂过
	for (int j=1; j<=pre[i][0]; j++)
		if (!vis[pre[i][j]])
			return false;
	return true;
}
inline void dfs(int step,int num,int co) {//step拿起刷子的最少次数，num涂过的矩形数，co当前颜色
	if (step>=ans) return;
	for (int i=1; i<=n; i++)//每次把能涂的尽量涂好
		if (!vis[i] && chk(i) && c[i]==co)
			vis[i]=1,++num;
	if (num==n) {
		if (ans>step) ans=step;
		return;
	}
	for (register int i=1; i<=n; i++)//寻找颜色不同但可以涂的继续dfs
		if (!vis[i] && chk(i)) dfs(step+1,num,c[i]);
}
int main() {
	scanf("%d",&n),ans=n;
	for (int i=1; i<=n; i++)
    		scanf("%d%d%d%d%d",&y[i],&x[i],&yy[i],&xx[i],&c[i]);
	for (int i=1; i<=n; i++)
		for (int j=1; j<=n; j++)
			if (i^j && yy[i]==y[j])//如果两块矩形不是同一个，且上下贴合
				if (x[i]<=x[j] && xx[i]>=xx[j]) {
					pre[j][pre[j][0]=1]=i;
					break;//如果上矩形覆盖了下矩形的整条边
				} else if ((x[i]<=xx[j] && x[i]>=x[j]) || (xx[i]<=xx[j] && xx[i]>=x[j]))//如果覆盖了一部分
					pre[j][++pre[j][0]]=i;

	for (register int a=1; a<=n a++)
		if (!pre[a][0]) memset(vis,0,sizeof vis),vis[a]=1,dfs(1,1,c[a]);//每次寻找可以涂的开始dfs
	printf("%d",ans);
}
```


---

## 作者：zhangjianweivv (赞：0)

我看好像这道题都是用搜索做的呢、、好吧我也是用深搜做的。

---
这道题是调了挺久的吧，大概有一个多小时左右。其实作为一道搜索题，它还不是很难的。但是如果是作为一道DP题、、唉，我是绝对做不出来的了（虽然DP肯定比搜索要快很多，但是我菜啊，尤其是DP，我最差的就是DP了、、）

其实思路很简单的。我们用一个s数组按颜色记录每一个方阵。然后用不同的颜色去搜索。dfs里面传三个参数，k表示当前涂了几个方阵（当k=n+1时退出循环），ys表示上一个涂的是什么颜色，ss表示涂到当前这个方阵用了几步。

具体的还是在代码看吧，我也不想讲了（因为懒）
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
struct node
{
	int stx,sty,edx,edy,c;
}a[24];int n,s[30][24],ans,ts,sum;
/*s[i][j]表示第i种颜色的第j个是哪个方阵，ts表示一共有多少种颜色*/
bool bk[110][110],v[30][24];
const int inf=2147483647;
inline void turn(node kk)
{
	for(int i=kk.stx;i<=kk.edx;i++)
		for(int j=kk.sty;j<=kk.edy;j++)bk[i][j]=false;//把kk这个方阵设为没涂过
}
inline bool pd(node no)
{
	for(int i=no.sty;i<=no.edy;i++)
		if(!bk[no.stx][i])return false;
    /*判断是否可以涂（顶头的方阵是否被涂过或是顶头没有方阵*/
	return true;
}
inline void change(node no,bool k)
{
	for(int i=no.sty;i<=no.edy;i++)bk[no.edx][i]=k;
    /*由于方阵之间是没有重合的，所以no下面与no紧贴的方阵要判断是否可以涂色只需要找no的最后一行有没有涂过颜色就可以了。根据这个思路，我们只需要把no的最后一行改成涂过颜色的就可以了*/
}
inline int min(int x,int y){return x<y?x:y;}
inline int max(int x,int y){return x>y?x:y;}
void dfs(int k,int ys,int ss)
{
	if(ss>ans)return;/*剪枝，如果当前步数已经多过当前找到的最优答案了，就没有找下去的必要了*/
	if(k==n+1)ans=min(ans,ss);
	else
	{
		for(int i=1;i<=s[ys][0];i++)
        /*先找同种颜色的涂，用的步数就可以尽量的少（贪心的思想）*/
			if(!v[ys][i]&&pd(a[s[ys][i]]))
			{
				v[ys][i]=true;
				change(a[s[ys][i]],true);
				dfs(k+1,ys,ss);
				change(a[s[ys][i]],false);
				v[ys][i]=false;
			}
		for(int i=1;i<=ts;i++)
		{
			if(ss>=ans)break;/*如果ss本身已经≥ans了、、那也剪枝*/
			if(i!=ys)/*注意，ys已经在上面搜过了，i是退而求其次的，所以没必要再搜一次ys了*/
				for(int j=1;j<=s[i][0];j++)
					if(!v[i][j]&&pd(a[s[i][j]]))
					{
						v[i][j]=true;
						change(a[s[i][j]],true);
						dfs(k+1,i,ss+1);
						change(a[s[i][j]],false);
						v[i][j]=false;
					}
		}
	}
}
int main()
{
	scanf("%d",&n);ts=0;int mx=inf;
	memset(bk,true,sizeof(bk));
	memset(v,false,sizeof(v));
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d%d%d",&a[i].stx,&a[i].sty,&a[i].edx,&a[i].edy,&a[i].c);
		s[a[i].c][++s[a[i].c][0]]=i;a[i].stx++;a[i].sty++;a[i].edx++;a[i].edy++;/*避免出现0的尴尬（因为0时，stx-1会变成负数，这就会越界了）*/
		turn(a[i]);ts=max(ts,a[i].c);mx=min(mx,a[i].stx);
	}
	for(int i=1;i<=100;i++)bk[mx][i]=true;
	sum=inf;
	for(int i=1;i<=ts;i++)
		for(int j=1;j<=s[i][0];j++)
			if(a[s[i][j]].stx==mx)ans=inf,dfs(1,i,1),sum=min(sum,ans);
	printf("%d\n",sum);
	return 0;
}
```
好了就这么多了、、

---


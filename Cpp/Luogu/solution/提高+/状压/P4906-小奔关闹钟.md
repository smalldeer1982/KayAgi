# 小奔关闹钟

## 题目背景

由于今天是星期一，闹钟准时响了，由于小奔太困了，所以他想关停闹钟。


## 题目描述

可是，他的闹钟电路太复杂了，有很多个开关，每个开关都连着其他开关，其他开关又连着更多的开关，当且仅当所有开关都关闭时，闹钟才会停止响铃，（初始时默认每个开关都开着的），她该如何是好呢？


请你帮小奔求出最少开关次数，如果无论如何都不能关闭闹钟，请输出‘Change an alarm clock，please!’

## 说明/提示

样例1说明：


先关闭5，直接关联会关闭1。1间接关闭2、3、4，但会重新打开5。


此时共关闭开关一次，已关闭1，2，3，4


再打开2，直接关联会打开1和3。1间接关闭2、3、5，重新打开4。3间接关闭1、4。


此时共关闭开关2次，已关闭1，2，3，4，5，彻底关闭闹钟。

## 样例 #1

### 输入

```
5
4 2 3 4 5
2 1 3
2 1 4
2 1 5
1 1```

### 输出

```
2```

# 题解

## 作者：lilns (赞：14)

很激动。我的第一篇题解，主要是因为感觉做出来个黑题难以想象。毕竟菜鸡如我，最多也就做个蓝题。
~~（当然这个题有点水，要不我也做不出来）~~
好了话不多说我们看一下这个很有 __ ****水**** __ 准的题。

####  首先看一下题目


------------
由于今天是星期一，闹钟准时响了，由于小奔太困了，所以她想关停闹钟。  

嗯。。。。。。。。   
这个孩子不大行，我们把它稍微改一下；  

~~由于今天是星期一，闹钟没有响，由于小奔太爱学习了，所以她想开启闹钟~~。  

####  这样就题目就清楚多了吧；

可是，他的闹钟电路太复杂了，有很多个开关，每个开关都连着其他开关，其他开关又连着更多的开关，当且仅当所有开关都打开时，闹钟才会开始响铃，（初始时默认每个开关都关的），她该如何是好呢//这里改一下，初始时所有都开变为都关，感觉更好理解。

**当打开第i个开关时，只有直接关联，间接关联以及第i个开关才会起作用。**这句话的意思是我们要和他在两层关系以内的点都会因为这个点打开而打开，2层以后就不需要了，这是解题和这题可做的原因。

请你帮小奔求出最少开关次数，如果无论如何都不能开启闹钟，请输出‘Change an alarm clock，please!’

我们先导入一组小样例
```
3
2 2 3
1 3
1 1
```
我们看一下每一次只打开一个的情况
1. 当只打开1的时候，2,3会因此而打开 1{2，3}，然后因为2打开的有3，因为开关摁两下相当于没摁。所以3关闭，最后只有{1，2}。
1. 当只打开2的时候，3回打开 2，{3}，然后因为3打开的有1 , 2{ 3 { 1 } },此时所有开关都打开，方案可行，ans=1。
1. 当只有3打开的时候，1会因此打开 3{1}，因为1而打开的有2,3 此时情况为 ~~3~~{ 1 { 2 } }，不可行。

从上面看来，最优解ans=1，也就是只打开2的时候。


我们回过头来再看一下数据范围，n<=20.........
忍住，忍住不要想状压dp。哼，不让我想状压dp，我想状压总行了吧，反正没dp。
当然不状压也行，但感觉麻烦点，可能要开多个数组。

说了这么多，其实这个题用搜索做就好啦，深搜，广搜都可以，等下下会有代码。

### 介绍一下我方法。
首先存的时候用矩阵存就好啦，（n<=20真的是可以为所欲为）
然后预处理一个res数组，表示在打开一个点后所带来的两层之内的影响。
在通过搜索处理出答案。

这是res数组处理方法，res[i]的值在亦或^时可以对答案直接产生贡献。解释一下亦或^的原因
（来自弱鸡的问候:状压应该懂得吧，二进制上01代表选或不选，因为前面提到同一个开关摁两次想当于不摁，我们因此有了x=（x+1）%2,这相当于亦或^);

当搜索到now>n 而且sum=0的时候，尝试更新答案并返回。//深搜
当搜索到w==sum的时候，此时输出答案，此时一定是最优解//广搜

**最后提个坑** 在表示和i直连的开关中可能会有i，所以我么需要特判。
```cpp
	for(int i=1;i<=n;i++)
	{
		res[i]^=(1<<i);
		for(int j=1;j<=n;j++)
		{
			if(a[i][j]&&i!=j)
			{
				res[i]^=(1<<j);
				for(int k=1;k<=n;k++)
				{
					if(a[j][k]&&j!=k)	res[i]^=(1<<k);
					
				}
			}
		}
	}
```


------------
### 深搜代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
int f[8000000],a[25][25],res[25],n,m,sum,ans=-1,an;
void dfs(int now,int sum,int cnt)
{
	if(now>n)
	{
		if(sum==0)
		{
			if(ans==-1||ans>cnt)
			{
				ans=cnt;
			}
		}
		return ;
	}
	dfs(now+1,sum,cnt);
	sum^=res[now];
	dfs(now+1,sum,cnt+1);
	sum^=res[now];
} 
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&m);
		for(int j=1;j<=m;j++)
		{
			int x;
			scanf("%d",&x);
			a[i][x]=1;
		}
	}
	for(int i=1;i<=n;i++)
	{
		res[i]^=(1<<i);
		for(int j=1;j<=n;j++)
		{
			if(a[i][j]&&i!=j)
			{
				res[i]^=(1<<j);
				for(int k=1;k<=n;k++)
				{
					if(a[j][k]&&j!=k)	res[i]^=(1<<k);
					
				}
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		sum+=(1<<i);
	}
	dfs(1,sum,0);
	if(ans==-1) printf("Change an alarm clock，please!");
	else printf("%d \n",ans);
	for(int i=1;i<=n;i++)
	{
		printf("%d ",res[i]);
	}
	printf("\n%d",sum);
	return 0;
}
```


------------
###  广搜代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<queue>
using namespace std;
const int N=20010;
int sum,vis[N],n,m,a[N][N],res[N],ans=-1;
struct node{
    int x,d;
};
queue<node>q; 
int read()
{
	int ans=0;char ch;bool c=false;
	while((ch=getchar())<'0'||ch>'9') if(ch=='-') c=true;ans=ch-48;
	while((ch=getchar())>='0'&&ch<='9') ans=(ans<<3)+(ans<<1)+ch-48;
	return c==true?-ans:ans;
}

void bfs()
{
    q.push(node{0,0}); vis[0]=1;
    while(!q.empty())
    {
    	node x=q.front();q.pop();
        int w=x.x,d=x.d;vis[w]=0; 
        for(int i=1;i<=n;i++)
        {
        	int r=w^res[i];
            if(r==sum) 
            {
				printf("%d",d+1);
				exit(0);
            }
            if(!vis[r])
            {
                q.push((node){r,d+1});
                vis[r]=1;
            }
        }
    }
}
int main()
{	
    n=read();
    for(int i=1;i<=n;i++)
    {
    	m=read();
        for(int o=1;o<=m;o++) a[i][read()]=1; 
    }
    sum=pow(2,n)-1;
	
	for(int i=1;i<=n;i++) 
	{
	    int w=sum^1<<(i-1);
	    for(int j=1;j<=n;j++)
	    if(a[i][j]&&i!=j)
	    {
	        w^=1<<(j-1);
	        for(int k=1;k<=n;k++)
	        if(a[j][k]&&j!=k) w^=1<<(k-1); 
	    }
		res[i]=sum^w; 
	}
    bfs();
    printf("%d",ans);
    return 0;
}

```
。。。。
真·完结散花。希望各位大佬支持一下，初次写题解，还请见谅，不会可以直接call我。

---

## 作者：SammyChu (赞：9)

注意到好像还没有人写状压$dp$的题解，那么我就来发一波状压$dp$的题解。

但是，在开始讲述之前，我需要先吐槽本题的数据。

1. 一个开关的直接关联开关可以是自己
	
    然而题目中并没有说明需要忽略这样的数据

1. 一个开关的直接关联开关有重
	
    然而题目中并没有说明需要去重
    
1. 一个开关的直接关联开关可以大于开关总数$n$或者是$0$
	
    于是我的状压$dp$疯狂$RE$


综上，这道题的数据的确出的不尽人意。但是，我们也要理解出题人。数据这个东西是否有锅其实和做法是有很大关系的。以前我就尝试过出一道题目，最后就是因为数据不得不放弃了。

~~只是数据有锅却以为是自己代码写挂了就比较……嗯~~

## 现在进入正题。

状压$dp$，即把$dp$的状态进行压缩后转移的$dp$技巧。

之前好像看到讨论里有人说本题$dp$有后效性？我个人认为是没有的。但是空口无凭，所以我就来谈一谈这个问题。

我们使用一个二进制数来表示一个开关的开关状态：从最低位到最高位分别表示一个开关的状态。其中$0$表示开关打开，$1$表示开关关闭。那么，当一个开关的改变对状态造成影响后，我们就可以使用位运算**异或**来表示这种变化，从而实现转移。

在证明这个$dp$的状态设计没有后效性之前，我们先来看一看关于异或的一些性质。

- 异或运算满足交换律，即 $a$ $xor$ $b$ $=$ $b$ $xor$ $a$

- $a$ $xor$ $b$ $xor$ $b$ $=$ $a$

有了这两条性质就可以了。

首先，对于任意一个开关，当它的状态发生变化后，其对整体状态的变化过程一定可以利用题目中已知的信息表示成一个二进制数。换句话说，是一个**不受当前整体开关状态影响**的固定值。那么，由第二条性质可得，如果某一个开关被拨动两次，结果就会导致整个状态并没有发生任何改变。

于是，我们得到：**任何一个开关要么变动一次，要么不动**。

其次，对于任何两个会变动的开关$i$、$j$，无论我们先拨动$i$或者先拨动$j$，由于异或运算满足交换律，所以对整体结果的改变是一样的。

于是，我们又得到，**开关拨动的先后顺序并不影响结果**。

也就是说，这个问题现在已经有点类似于一个$01$背包了。每个开关要么动一次，要么不动，并且顺序任意。

扯了这么多，相信各位也已经明白这个$dp$是没有后效性的。因此，它可以作为我们解决本题的一个方法之一。

现在开始说具体的$dp$过程。

$state[i]$：表示当按下开关$i$时与其直接关联的开关的集合 **（不包括$i$）**

$change[i]$：表示当按下开关$i$后它对整个开关状态的影响 **（包括$i$）**（就是上文提到的“不受当前整体开关状态影响的固定值”）。假设原来的整体开关状态是$x$（是一个二进制数），按下开关$i$后，整体开关状态变为$x$ $xor$ $change[i]$。

$f[i][j]$：表示考虑到第$i$个开关，使得当前整体开关状态为$j$的最小按开关次数。若不可能达到则设为$INF$。转移方程：

$f[i][j]$ $=$ $Min$ $(f[i-1][j_0]+1$ $,$ $f[i-1][j])$

其中$j_0$ $xor$ $change[i]$ $=$ $j$

也就是说，讨论当前按不按第$i$个开关，可以从两个不同的状态转移过来，用于更新答案即可。至于$j_0$的取值，由刚才的等式就可以解出来。我们让等式两边同时异或上$change[i]$，再结合之前提到的第二条性质，就可以得到：

$j_0$ $=$ $j_0$ $xor$ $change[i]$ $xor$ $change[i]$ $=$ $j$ $xor$ $change[i]$

于是状态转移方程变为：

$f[i][j]$ $=$ $Min$ $(f[i-1][j$ $xor$ $change[i]]+1$ $,$ $f[i-1][j])$

然后我们枚举每一个开关（$20$），再枚举每一种状态（$2^{20}$），发现时间复杂度大约在$2e8$左右，结合本题的$5s$时限，是可以通过的。但是空间复杂度和时间复杂度同级，这是我们无法承受的。注意到$f[i][j]$只会由$f[i-1][j $ $or$ $j_0]$转移过来，所以使用滚动数组优化空间。至此，本题得到了状压$dp$的完美解法。

当然，关于出锅数据，当然可以用二维的数组避免掉。不过由于我是先写$dp$然后~~通过讨论区~~发现数据有问题后在原来的代码上直接改动的，就用的排序去重。这个怎么实现都可以啦。

以下是~~我历经千辛万苦写出来的~~$AC$代码。

```cpp
#include<cstdio>
#include<iostream> 
#include<cstring>
//用到了memset 
#include<algorithm>
//用到了sort和unique 
using namespace std;
//写读入优化是一个比较…嗯…的习惯 
inline void read(int &x) 
{
	int w=x=0;
	char ch=getchar();
	while(ch<'0'||'9'<ch)
		ch=='-'?w=1,ch=getchar():ch=getchar();
	while('0'<=ch&&ch<='9')
		x=(x<<3)+(x<<1)+(ch^'0'),ch=getchar();
	x=w?-x:x; 
}
const int Maxn=1<<20,N=25,INF=0x3f3f3f3f;
//定义INF最好习惯性地用这个，不会越界 
int n,m,t,Max,cnt[N],child[N][N];
//n，m如题所述；t是临时变量；Max是总状态的最大可能（1<<n）
//cnt是每个开关 合法 直接关联开关的个数，child是编号 
int tot,tmp[N],f[5][Maxn];
//tot和tmp是用于排序去重的， f数组是dp数组 
int state[N],change[N];
//如前文所述 
int main()
{
	read(n),Max=1<<n;//设定Max 
	for(int i=1;i<=n;++i)
	{
		read(m),tot=0;//tot一定要赋初值为0 
		for(int j=1;j<=m;++j)
		{
			read(t);
			if(t>0&&t<=n&&t!=i)//说起来都是泪 
				tmp[++tot]=t;
		}
		sort(tmp+1,tmp+tot+1),cnt[i]=unique(tmp+1,tmp+tot+1)-tmp-1;
		//先sort再unique去重并把去重后的数目存到cnt[i]里
		//当然这里可以用二维数组简化 
		for(int j=1;j<=cnt[i];++j)	
			child[i][j]=tmp[j],state[i]^=1<<(tmp[j]-1);
		//存入child并且更新state 
	}
	for(int i=1;i<=n;++i)
	{
		change[i]=state[i]^(1<<(i-1));
		//由于state是没有存自己的，所以要先把自己存进去 
		for(int j=1;j<=cnt[i];++j)
			change[i]^=state[child[i][j]];//更新change[i] 
		//由于state[i]已经记录了所有的child的状态变化
		//因此不需要把它们自己的改变存到change[i]里
		//这也就是为什么不能把自己的变化存到state里 
	}
	memset(f,0x3f,sizeof f),f[0][0]=0;
	//初始化dp数组，其中初始状态f[0][0]为0 
	for(int i=1;i<=n;++i)
	{
		int now=i&1;//x&1=x%2，这是用于压维优化空间的 
		for(int j=0;j<Max;++j)//遍历所有可能的状态 
			f[now][j]=min(f[now^1][j],f[now^1][j^change[i]]+1); 
		//状态转移 ： now就是i，now^1就是i-1 
	}
	//注意末状态是Max-1 
	if(f[n&1][Max-1]==INF)//无法关闭闹钟（自闭） 
		printf("Change an alarm clock，please!");
	else//输出答案 
		printf("%d",f[n&1][Max-1]);
	return 0;
} 
```

测试用时$174ms$，慢于广搜做法。

---

## 作者：Kaizyn (赞：8)

不服,为什么 bfs ???

显然一个开关摁两次等价于没摁

所以每个开关的状态要么没摁,要么摁了

所以 bfs 不是会产生无用功吗?其实无用功部分被vis数组判重判掉了...

~~不妨用0,1表示,就可以二进制枚举了!~~

我写的还是搜索,每个开关有两种状态,要么摁,要么不摁

一个开关摁奇数次的效果是一样的

摁偶数次的效果也是一样的

所以也可以用0,1表示

~~所以你们可以状态压缩,但是我懒~~

有这么个性质:

0 ^ 1 = 1, 1 ^ 1 = 0

0 ^ 0 = 0, 1 ^ 0 = 1

所以我们可以用异或(也可以加起来再对二取模)

---

最后有一个坑

导致我,~~相信也是其他很多人~~只得了三十分的原因

在代码注释的①②处

一定要特判一下

可能是毒瘤数据的锅,给出的第i个开关直接控制的灯泡里包含了灯牌i(本身)

---
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int Maxn = 25;

int n, ans = -1;
int a[Maxn][Maxn], b[Maxn][Maxn];
int now[Maxn];

// cur表示当前是第几个开关,cnt表示之前摁了几个开关
void solve(int cur, int cnt)
{
    if(cur > n)
    {
    	// 最后全关的状态等价于每个开关都摁过了
        int flag = 1;
        for(int i = 1; i <= n; ++i)
            if(now[i] == 0) flag = 0;
        if(flag)
        {
            if(ans == -1 || cnt < ans)
                ans = cnt;
        }
        return;
    }
    // 不摁
    solve(cur+1, cnt);
    // 摁
    for(int i = 1; i <= n; ++i)
        now[i] ^= b[cur][i];
    solve(cur+1, cnt+1);
    // 回溯
    for(int i = 1; i <= n; ++i)
        now[i] ^= b[cur][i];
}

int main()
{
    scanf("%d", &n);
    for(int i = 1, m, x; i <= n; ++i)
    {
        scanf("%d", &m);
        for(int j = 1; j <= m; ++j)
        {
            scanf("%d", &x);
            a[i][x] = 1;
        }
    }
    // 预处理第i个开关的效果
    for(int i = 1; i <= n; ++i)
    {
    	// 自身摁一下
        b[i][i] ^= 1;
        for(int j = 1; j <= n; ++j)
		{
            if(a[i][j] && i != j) // ①
			{
            	// 直接的
				b[i][j] ^= 1;
                // 间接的
                for(int k = 1; k <= n; ++k)
                    if(a[j][k] && k != j) // ②
						b[i][k] ^= 1;
			}
		}
    }
	// 搜索
    solve(1, 0);
    if(ans == -1) puts("Change an alarm clock，please!");
    else printf("%d\n", ans);
    return 0;
}
```
---

总的来说这是一道十分有**水**准的黑题

成就感++

---

## 作者：JustinRochester (赞：4)

[题目](https://www.luogu.org/problemnew/show/P4906)

哇，题目不难，数据恶心

前向星的同学们(包括本蒟蒻)，小心了......

---

**【分析】**

这题其实个人感觉没有黑题的难度，但是数据着实有点恶心

首先，这边三个点一定要注意：

1. 有可能出现某个开关没有任何直接关联开关(如题目所示)

2. 有可能出现某个开关的直接关联开关是它本身

3. 有可能出现某个开关的直接关联开关中有重复

这边先说第一点，我们只要读入 $M$ 后直接不读即可

第二点，题解区的其他大犇都说这个情况不可能，特判掉即可，本蒟蒻不明所以，反正这边也强调一下，直接判掉吧

那第三点，个人觉得可能算是卡前向星存边的选手吧，第 $3$ 个点应该就是有出现重复，比如
```
3 2 3 3
```
之类的

你问我为什么知道？因为本蒟蒻被这个点卡了两三遍，改了以后一下就过了......

---

本蒟蒻这边讲一下个人的实现方法

因为看题解区的众位大犇的实现方法都有点慢，本蒟蒻就试着推荐一下自己的打法

先放一下[结果](https://www.luogu.org/record/show?rid=12950464)，貌似是目前第三......

首先，这题的 $N \leq 20$ ，肯定可以状态压缩的

因为每个开关都是初始为开的状态，而且状态是且仅是开或者关

那么我们这么考虑，对于一个按钮 $i$ ，我们假设它按了以后对所有开关的影响是 $Eff_i$，影响的意思是对所有开关状态的改变(具体怎么算我们看后文)

若按 $i$ 对 $j$ 产生影响，则对应的，$Eff_i$ 的第 $j$ 位为 $1$ ，否则为 $0$ 。

那么，我们考虑一个这样的事实：

每一次按按钮，都是独立的一次修改，即每次按开关都是异或起来。

那就是说，如果一个按钮，按了两次，相当于原本的状态异或了两次，就等于没按。

按三次，就相当于按两次的基础上再按一次，也就是按一次。

以此类推，实际上，我们只要考虑每个按钮是按或者不按即可

那么，我们是不是又可以考虑把按的按钮的状态给压缩？

考虑枚举状态 $S$ 表示按按钮的状态集合

那么，有影响的状态就是 $\forall i \in S,Eff_i$ 的异或和

由于所有开关一开始都是开着的状态，我们只要判定该异或和是否为全集 $U$ 即可判定该状态是否能关掉所有开关

记得答案保存最小值

---

那么，现在我们的问题变成了如何计算 $Eff_i$ ，首先，我们可以将读入存在 $To_i$ 里面，也就是直接关联开关也记为一个集合

这样做有一个好处，即重复读入(第3点)是不会出问题的，而且能直接删除关联自己的这种情况，实现方法如下：

```cpp
inline int getit(){
    register int S=0,M=read();
    while(M--) S|=1<<read()-1;
    return S;
}
```
对于该开关的直接关联开关记为集合 $S$ ,那么，每次读入都是对集合里面不重复地加元素变成 $S\bigcup read()$

```cpp
f(i,0,N-1) To[i]=getit()&(~(1<<i));
```
而主函数里面，直接读入与之关联的所有开关，~$(1<<i)$ 是指 $i$ 的补集。因为我们的读入不需要与自己直接关联的，即$To_i=getit() \bigcap C_U^i$

而计算 $Eff_i$ 只需要手打的枚举三层即可

那其他细节就看本蒟蒻的代码吧

---

那本蒟蒻就放  ~~我码风极丑的代码~~  吧

```cpp
#include<cstdio>
using namespace std;
#define f(a,b,c) for(register int a=b,A=c;a<=A;a++)
#define g(a,b,c) for(register int a=b,A=c;a>=A;a--)
#define Max(a,b) ((a>b)?a:b)
#define Min(a,b) ((a<b)?a:b)
#define File(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout)
typedef long long int ll;
typedef unsigned long long int ull;
inline ll read(){
    register ll ans=0;register char c=getchar();register bool neg=0;
    while((c<'0')|(c>'9')) neg^=!(c^'-'),c=getchar();
    while((c>='0')&(c<='9'))ans=(ans<<3)+(ans<<1)+(c^48),c=getchar();
    return neg?-ans:ans;
}//条件反射的后果
int N,To[30]={0},Eff[30]={0},Ans=0x7f7f7f7f;
inline int getit(){
    register int S=0,M=read();
    while(M--) S|=1<<read()-1;
    return S;
}
inline int Sum(int p){
    register int S=1<<p;
    f(i,0,N-1) if( (To[p]>>i)&1 ){
        S^=(1<<i);
        f(j,0,N-1) if( (To[i]>>j)&1 ) S^=(1<<j);
    }
    return S;
}
int main(){
    N=read();
    f(i,0,N-1) To[i]=getit()&(~(1<<i));
    f(i,0,N-1) Eff[i]=Sum(i);
    f(i,1,(1<<N)-1){
        register int Cnt=0,S=0;
        f(j,0,N-1) if((i>>j)&1) S^=Eff[j],Cnt++;
        if(S+1>>N) Ans=Min(Ans,Cnt);
        //全集 U ,全部是 1 ,如果 +1 就是 10000...
    }
    if(Ans!=0x7f7f7f7f) printf("%d",Ans);
    else puts("Change an alarm clock，please!");
    return 0;
}
```

最后安利一下 [本蒟蒻的博客](https://www.luogu.org/blog/JustinRochester/#)

---

## 作者：喵仔牛奶 (赞：3)

由于开关最多传递两层，可以把每个开关按了最后的结果状压存起来，然后跑一遍 BFS 即可。

如果当前状态为 $S$，开关的状态（改变的是1，否则是0）是 $S^{\prime}$，那么按下后新的状态就是 $S\operatorname{xor}S^{\prime}$。

存开关状态的时候也是异或，因为按两次相当于没有按。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 22;
int a[N][N], f[N], dis[1 << N], n, m, x;
bool vis[1 << N];
queue<int> q;
int main() {
	freopen("clock.in", "r", stdin);
	freopen("clock.out", "w", stdout); 
	memset(dis, 0x3f, sizeof dis);
	cin >> n;
	for (int i = 1; i <= n; i ++) {
		cin >> m;
		for (int j = 1; j <= m; j ++)
			cin >> x, a[i][x] = true;
	}
	for (int i = 1; i <= n; i ++) {
		f[i] ^= 1 << (i - 1);
		for (int j = 1; j <= n; j ++)
			if (a[i][j] && i != j) {
				f[i] ^= 1 << (j - 1);
				for (int k = 1; k <= n; k ++)
					if (a[j][k] && k != j)
						f[i] ^= 1 << (k - 1);
			}
	} // 存结果
	q.push((1 << n) - 1), vis[(1 << n) - 1] = true, dis[(1 << n) - 1] = 0;
	while (!q.empty()) {
		int u = q.front(); q.pop();
		for (int i = 1; i <= n; i ++) {
			int v = u ^ f[i];
			if (!vis[v]) vis[v] = true, dis[v] = dis[u] + 1, q.push(v);
		}
	}
	if (dis[0] == 0x3f3f3f3f) puts("WTF?"); // 貌似没有无解的数据？
	else cout << dis[0] << '\n';
	return 0;
}
```


---

## 作者：CYJian (赞：2)

这道题。。真的不是黑题好么。。

首先一个开关只有开和关两种状态，所以可以二进制压位+异或操作。

然后每一个开关影响的开关可以$O(N^3)$暴力预处理出来。这个也可以处理成异或一个数的形式。

然后由于异或操作的性质，两次异或同一个值等于没有操作，所以只需要枚举每一个操作用或不用就好了。

下面有请$dfs$版本的代码：

```
#include <bits/stdc++.h>

using namespace std;

#define reg register
#define ge getchar()
#define cin Cin //魔改cin
#define MAXN 20

struct IO {
    friend IO operator >> (reg IO a, reg int&x) {
        reg char ch; x = 0;
        while(!isdigit(ch = ge)) ;
        while(isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = ge;
        return a;
    }
}Cin; // 魔改快读

void dfs(reg int, reg int, reg int);

int n;
int res = -1;
bitset<MAXN>a[MAXN];
int e[MAXN];

int main() {
    reg int m, i, j, k;
    cin >> n;
    for(i = 0; i < n; i++) {
        cin >> m;
        for(j = 0; j < m; j++) {
            cin >> k;
            a[i][k - 1] = 1; // 存下边，但是从0开始标号方便位运算
        }
    }
    for(i = 0; i < n; i++) {
        for(j = 0; j < n; j++)
            if(a[i][j] && i != j) { //如果自己连向自己则可以忽略
                e[i] ^= 1 << j; // 直接开关
                for(k = 0; k < n; k++)
                    if(a[j][k] && j != k) // 同理
                        e[i] ^= 1 << k;  // 间接开关
            }
        e[i] ^= 1 << i; // 自己改变了一次状态
    }
    dfs(0, (1 << n) - 1, 0);
    if(res < 0) puts("Change an alarm clock，please!");
    else cout << res << endl;
    return 0;
}
// x表示枚举到哪一个开关了，S表示当前开关的状态，ans表示当前动了多少个开关
void dfs(reg int x, reg int S, reg int ans) {
    if(res > 0 && ans >= res) return ; // 当前答案不够优秀就舍去
    if(!S) { res = ans; return ; } // 开关全都关了
    if(x == n) return ; // 开关枚举完了
    dfs(x + 1, S, ans); // 不用这个开关
    dfs(x + 1, S ^ e[x], ans + 1); // 用这个开关
}
```

---

## 作者：ADivT (赞：2)

这真是一道有**水**平的黑题啊。。 

一看题，我们可以发现$ 0<=n<=20.$好开心啊，这个数据不就是一个$ DFS$ 标准范围吗，先对开关情况 $n^3$ 暴力枚举存在二进制数位中，然 后$ DFS $枚举选与不选，有一个很坑的地方在于自己可以与自己连开 关，此时等于没连，由此，再加上一个小小的剪枝，可以写出$ AC$ 代 码：
```cpp
#include <bits/stdc++.h>

#define rep(i,o,p) for(register int i=o;i<p;++i)

using namespace std;

int n,m,ans=-1,x;
bool a[21][21];
int f[21];

void dfs(int number,int check,int tot) {
	if(ans>0&&tot>=ans) return ;
	if(!check) {
		ans=tot;
		return ;
	}
	if(number==n) return ;
	dfs(number+1,check,tot);
	dfs(number+1,check^f[number],tot+1);
}
int main() {
	scanf("%d",&n);
	rep(i,0,n) {
		scanf("%d",&m);
		rep(j,0,m) {
			scanf("%d",&x);
			a[i][x-1]=1;
		}
	}
	rep(i,0,n) {
		f[i]^=1<<i;
		rep(j,0,n)
		if(a[i][j]&&i!=j) {
			f[i]^=1<<j;
			rep(k,0,n)		if(a[j][k]&&j!=k)		f[i]^=1<<k;
		}
	}
	dfs(0,(1<<n)-1,0);
	if(ans<0)printf("Change an alarm clock，please!");
	else printf("%d\n",ans);
	return 0;
}
```
完结撒花

---

## 作者：违规用户名cVn1I&r! (赞：2)

-- P4906 【小奔关闹钟】--
题目背景

由于今天是星期一，闹钟准时响了，由于小奔太困了，所以她想关停闹钟。

题目描述

可是，他的闹钟电路太复杂了，有很多个开关，每个开关都连着其他开关，其他开关又连着更多的开关，当且仅当所有开关都关闭时，闹钟才会停止响铃，（初始时默认每个开关都开着的），她该如何是好呢？

请你帮小奔求出最少开关次数，如果无论如何都不能关闭闹钟，请输出‘Change an alarm clock，please!

输入输出格式

输入格式：

共有N+1行

第一行一个数N（1≤N≤20），表示有N个开关，从第2行起的第i行表示第i个闹钟开关。

以后N行，每行第一个数为M（0≤M≤N-1），表示第i个闹钟开关的直接关联开关个数。（由直接关联开关所关联的直接关联开关，自然就是第i个闹钟间接关联开关啦，当打开第i个开关时，只有直接关联，间接关联以及第i个开关才会起作用。），之后M个数，表示第i个闹钟直接关联开关的标号。（如果M为0则表示没有任何关联）

输出格式：

一个数ans，表示最少按开关次数，如果无法关闭，输出‘Change an alarm clock，please!’

--------分割线---------------------------------------

状压广搜

看n<=20,显然可以把每个开关的状态用2进制表示

如15(n=5,01111)表示1开 2,3,4,5关

0表示全部开,2^n-1表示所有都关

把每一个开关的作用效果用2进制表示出来,之后我们直接异或这个2进制数即可代表按这个开关.
----

用一个vis数组表示这个状态是否在队列中,如果不在就入队,直到二进制结果得到结果或队列空.
~~似乎没有无解情况......~~

代码(有小坑):
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,a[201][201],vis[9999999],ans,b[201],l;
int dfs(int p){
    int w=l^1<<(p-1); 
    for(int i=1;i<=n;i++)
    {
    	if(a[p][i]&&i!=p)
    	{
    		w^=1<<(i-1);
    		for(int j=1;j<=n;j++)
    		if(a[i][j]&&i!=j)w^=1<<(j-1);
    	}
    }//只搜两层,把搜到的开关取反
    return w;
}
struct node
{
    int x,step;
};//广搜结构体,x为状态,step为步数
queue<node>q;
int main(){
    cin>>m;
    for(int i=1;i<=n;i++){
        cin>>m;
        for(int j=1,x;j<=m;j++)
        {
            cin>>x;a[i][x]=1;
        }
    }
    l=pow(2,n)-1;
    for(int i=1;i<=n;i++)
    {
    	b[i]=l^dfs(i);//第i个开关的效果
    //	cout<<b[i]<<" ";
    }
    q.push((node){0,0});vis[0]=1;//把初始状态入队
    while(q.size())
    {
        node oo=q.front();q.pop();
        int u=oo.x,v=oo.step;vis[u]=0;
        for(int i=1;i<=n;i++)
        {
            int r=u^b[i];if(r==l)return printf("%d",v+1)&0;
            if(!vis[r])q.push((node){r,v+1}),vis[r]=1;
            //取队首拓展,如果能全关直接退出,否则把当前状态入队
        }
    }
   cout<<"Change an alarm clock，please!";
   //原题的逗号是中文标点....
    return 0;
}
```
跑的飞快,只用了25ms.....(~~为什么要开5s~~)

---

## 作者：I_will_AKIOI (赞：1)

简单的状态压缩题。

根据题意，关掉一个开关后，一个开关的直接关联和间接关联开关都会改变状态。看到 $n\le20$，很容易想到状压。在二进制下第 $i$ 位为 $1$，说明开关是开着的，反之就是关着的。所以我们可以定义一个数组 $f$，用于求解关掉第 $i$ 个开关后，开关的变化情况。输入数据时可以使用邻接表，然后使用双重循环遍历，遇到第 $i$ 个开关就把第 $i$ 位取反。

然后就是求最短路了，答案就是 $2^n-1$ 和 $0$ 之间的距离。如果你直接暴力建边然后跑迪杰斯特拉，很明显会 TLE。接着发现所有边的边权都是 $1$，所以直接跑一遍 BFS 就行了。

注意要判重边和自环，这两种情况不需要放进邻接表内。

```cpp
#include<bits/stdc++.h>
#define N 20
using namespace std;
struct Data{int x,s;}w;
int n,f[N];
bool a[N][N],vis[1<<N];
vector<int>v[N];
queue<Data>q;
int BFS()//求最短路
{
  w=Data{(1<<n)-1,0};
  q.push(w);
  while(!q.empty())
  {
    w=q.front();
    if(w.x==0) return w.s;
    for(int i=0;i<n;i++)
    {
      int x=w.x^f[i];
      if(vis[x]) continue;
      vis[x]=1;
      q.push(Data{x,w.s+1});
    }
    q.pop();
  }
  return -1;
}
int main()
{
  ios::sync_with_stdio(0);
  cin>>n;
  for(int i=0;i<n;i++) a[i][i]=1;
  for(int i=0;i<n;i++)
  {
    int m,x;
    cin>>m;
    for(int j=0;j<m;j++)
    {
      cin>>x;
      x--;
      if(a[i][x]==0) a[i][x]=1,v[i].push_back(x);
      //判重边和自环，没有才能加进去
    }
  }
  for(int i=0;i<n;i++)
  {
    f[i]=(1<<i);
    for(auto x:v[i])//直接关联开关
    {
      f[i]^=(1<<x);
      for(auto y:v[x]) f[i]^=(1<<y);//间接关联开关
    }
  }
  int res=BFS();
  if(res==-1) cout<<"Change an alarm clock,please!";
  else cout<<res;
  return 0;
}
```

---

## 作者：CYZZ (赞：1)

# [小奔关闹钟](https://www.luogu.com.cn/problem/P4906)
本题解会给出状压 DP 和 dfs 的两种方法。
# 题意简明
有 $n$ 个开关，它们一开始都开着，你想把这 $n$ 个开关都关掉。这些开关的关系构成一个无向图，按下 $u$ 开关就会使 $u$ 和所有与它有连边的开关 $v$ 改变，而 $v$ 又会使除 $u$ 外所有和 $v$ 有连边的开关改变（这种连锁反应只会发生一次）。求关掉所有开关的最小操作数。
# 思路分析
## 状态压缩
状态压缩是一种利用**二进制**的优化方法。假设你有 $n$ 个数，每个数只能使用一次。则最简单的方法就是开一个 bool 类型的数组，记录每个数有没有被使用过。但是一个数组很难被方便的利用，怎么把它压缩成一个数呢？我们发现 bool 数组和一个二进制数的每一位都只能是 $0$ 或 $1$。所以我们可以把 bool 数组的每一位看成二进制数每一位，那么 $vis[i]=1$ 就可以变成 $sum \operatorname{or} 2^{i-1}$ 了。注意此时的 $n$ 不能很大（最好是 $15$ 附近），不然二进制数会爆数据范围。
```cpp
int sum,x;
for(int i=1;i<=n;i++)
{
	scanf("%d",&x);
	sum|=1<<(x-1);//最简单的状压代码
}
```
## 状压 DP
由于本题中开关的特殊性质，所以我们把按位或操作改为按位异或。我们需要先预处理出按下每个开关分别会对状态产生什么影响。
### 预处理
设 $g_i$ 表示与 $i$ 有直接关系的开关集合，这个很容易在输入时预处理出。

设 $f_i$ 表示按下 $i$ 最终会对状态产生什么影响（不是 DP 数组），易知 $f_i$ 由 $g_i$ 和与 $i$ 有直接关系的 $g_j(j \in g_i)$ 得出。
$$f_i=2^{i-1} \oplus g_i  \oplus \sum g_j$$
### 状态转移
设 $dp_{i,j}$ 为当前选到第 $i$ 个开关，当前状态（状态压缩值）为 $j$ 时的最小操作次数。那么状态转移方程就十分明显了，一个开关只能是按或不按，所以方程是：
$$dp_{i,j}=\min(dp_{i-1,j},dp_{i-1,j \oplus f_i}+1)(i \in [1,n],j \in [0,2^n-1])$$

最终的答案为 $dp_{n,2^n-1}$，也就是全部开关都按奇数次。
### 细节处理
- 初始值 $dp_{0,0}=0$，其余为 $\infty$。
- 本题在输入的时候会有些奇妙的数据，比如自己连自己或者 $i\notin[1,n]$。所以要特判！
# 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,g[25],f[25],dp[25][1<<21];
int main()
{
	scanf("%d",&n);
	memset(dp,0x3f,sizeof dp);
	dp[0][0]=0;
	for(int i=1;i<=n;i++)
	{
		int m,x;
		scanf("%d",&m);
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&x);
			if(x!=i&&x<=n&&x>0)//奇怪的数据可能会导致RE 
				g[i]|=1<<(x-1);
		}
	}
	for(int i=1;i<=n;i++)
	{
		f[i]=(1<<i-1)^g[i];
		int tmp=g[i];
		for(int j=1;j<=n;j++)
		{
			if(tmp&1)
				f[i]^=g[j];//处理f数组 
			tmp>>=1;
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<(1<<n);j++)
		{
			dp[i][j]=min(dp[i-1][j],dp[i-1][j^f[i]]+1);//状压DP 
		}
	}
	if(dp[n][(1<<n)-1]==0x3f3f3f3f)
		puts("Change an alarm clock,please!");
	else
		printf("%d",dp[n][(1<<n)-1]);
	return 0;
}
```

时间复杂度 $O(n2^n)$，轻松过掉！但是你以为这就完了吗？
## 暴力搜索
如果你是一个跟我一样菜的蒟蒻，不会状压。前面说了一个开关只能按或不按，正符合 dfs 的要求，状态可以当做参数传下去。于是，一个又节省脑细胞又节省空间还跑得比状压 DP 快的暴力 dfs 横空出世！！！
```cpp
void dfs(int dep,int now,int sum)
{
	if(now>=ans)
		return ;
	if(dep>n)
	{
		if(sum==((1<<n)-1))
			ans=now;
		return ;
	}
	dfs(dep+1,now,sum);
	dfs(dep+1,now+1,sum^f[dep]);
}
```
时间复杂度 $O(2^n)$，比状压 DP 不知道快多少。
![](https://cdn.luogu.com.cn/upload/image_hosting/22kpufcd.png)
制作不易，希望本篇题解可以帮到大家！

---

## 作者：lx_zjk (赞：1)

这道题 我用了一种错误的写法竟然有50pts

先上代码吧 
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

inline ll read () {
    ll f = 1, x = 0;char ch;
    do {ch = getchar();if (ch == '-')f = -1;} while (ch > '9' || ch < '0');
    do {x = x * 10 + ch - '0';ch = getchar();} while (ch >= '0' && ch <= '9');
    return f * x;
}

const int MAX_N = 50 + 5;

const int MAX_S = (1 << 22) + 5;

int n, a[MAX_N][MAX_N], col[MAX_N], f[MAX_S];

int main (){
	n = read();
	for (int i = 0; i < n; i ++ ) {
	    a[i][n + 1] = read();
		for (int j = 0; j < a[i][n + 1]; j ++ ) {
			a[i][j] = read();
			a[i][j] -= 1;
			if (a[i][j] == i || a[i][j] + 1 > n || a[i][j] < 0) continue; 
			col[i] = col[i] | (1 << a[i][j]);
		}
//		col[i] |= (1 << i);
	}
	for (int i = 0; i  < (1 << n); i ++ ) 
		f[i] = 1e9;
	f[0] = 0;
	for (int s = 0; s < (1 << n); s ++ ) {
		for (int i = 0; i < n; i ++ ) {
			int tmp = s;
			tmp ^= col[i];
			tmp ^= (1 << i);
			for (int j = 0; j < a[i][n + 1]; j ++ ) {
				tmp ^= col[a[i][j]];
			}
			f[tmp] = min(f[s] + 1, f[tmp]);
		}
	}
	if (f[(1 << n) - 1] >= 1e9) puts("Change an alarm clock，please!");
	else cout << f[(1 << n) - 1] << endl;
	return 0;
}
```

我写了一个状态压缩动态规划 但是这个为什么会错呢

myt大佬给我了讲解 首先这个是正序的枚举状态 但是当前的$f[s]$可能会被后面的所更新 所以是有后效性的~~(不知道是不是的)~~

然后就写起了dfs + 状态压缩

这题并不需要写什么迭代加深或者$IDA*$算法

所以还是比较简单的

首先每个开关之多开一次 这应该是毋庸置疑的 如果不懂可以思考一下

然后$dfs(stage, k, cnt)$ $stage$表示当前开关使用情况 1表示用过
0表示没用过

之后的东西也就比较简单了

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int INF = 2139062143;

inline ll read() {
    ll f = 1, x = 0;char ch;
    do {ch = getchar();if (ch == '-')f = -1;} while (ch > '9' || ch < '0');
    do {x = x * 10 + ch - '0';ch = getchar();} while (ch >= '0' && ch <= '9');
    return f * x;
}

const int MAX_N = 20 + 5;

int n, ans, a[MAX_N][MAX_N], col[MAX_N], w[MAX_N];

inline void init() {
	for (int i = 0; i < n; i ++ ) {
		w[i] |= (1 << i);
		w[i] ^= col[i];
		for (int j = 0; j < n; j ++ ) {
			if (col[i] & (1 << j)) {
				w[i] ^= col[j];
			}
		}
		w[i] &= (1 << n) - 1;
	}
}

inline void dfs(int stage, int k, int cnt) {
	if (stage == (1 << n) - 1) {
		ans = min(ans, cnt);
		return;
	}
	if (k >= n) return;
	dfs(stage ^ w[k], k + 1, cnt + 1);
	dfs(stage, k + 1, cnt);
}

int main() {
	n = read();
	for (int i = 0; i < n; i ++ ) {
	    a[i][n + 1] = read();
		for (int j = 0; j < a[i][n + 1]; j ++ ) {
			a[i][j] = read();
			a[i][j] -= 1;
			if (a[i][j] == i || a[i][j] + 1 > n || a[i][j] < 0) continue; 
			col[i] = col[i] | (1 << a[i][j]);
		}
	}
	init();
	ans = INF;
	dfs(0, 0, 0);//表示现在状态是0,到了第0个点,用了多少步 
	if (ans == INF) puts("Change an alarm clock，please!");
	else cout << ans << endl;
	return 0;
}


```

---

## 作者：Leap_Frog (赞：1)

[$\color{black}\texttt{题目传送门}$](https://www.luogu.org/problemnew/show/P4906)

### PS
这道题是我A的第三道真·黑题，心情十分激动，于是发一篇题解~~管理大大求过~~

### 题意分析
1. 目标：关闭所有的电灯
2. 特殊：关了一个点灯之后，会影响其他电灯的开闭，其他点灯的开闭又继续影响
3. 限制：上面的影响只会持续2轮，~~不要问我为什么，我是从样例中看出来的QwQ~~

### 代码分析
由于题意分析中的第三条，我们可以考虑初始化更改一个点灯的状态后会产生的影响。  
复杂度是$\texttt{O(n}^\texttt{3}\texttt{)}$，对于$\texttt{1<n<20}$的数据一定能过。  
然后就可以暴力$\texttt{dfs}$来求答案了。  
当然，如果两次或多次关同一盏灯，那么开关的效果会被抵消，所以对于每一个点，只有动与不动两种情况。  
所以$\texttt{dfs}$的复杂度是$\texttt{O(2}^\texttt{n}\texttt{)}$，能过。  

### 代码实现
由于$\texttt{n<=20}$，$\texttt{2}^\texttt{20}=1048576$，在$\texttt{int}$的数据范围内，所以我们可以考虑状压。  
由于开灯与关灯具有如下性质：$\texttt{0+0=0,1+1=0,0+1=1,1+0=0}$，所以我们可以把它当成异或操作。

### 上代码
代码里有解释
```cpp
#include<bits/stdc++.h>
#define ya(x) (1<<(x))			//状压函数，把一个集合压成一个数字
#define go(x,y) ((x)!=(y)&&a[(x)][(y)])		//判断函数：这里有一个坑点，就是一盏灯自己会指向自己，要加一个特判
using namespace std;
const int N=25,INF=1000000007;
int n,m,ans,cha[N];
char a[N][N];
inline int dfs(int x,int s)
{
	if(x==n+1) {if(s==0) return 0;return INF;}		//递归的边界
	return min(dfs(x+1,s),dfs(x+1,s^cha[x])+1);		//枚举这一盏灯动不动
}
inline void init()		//读入函数，没什么好解释的把
{
	scanf("%d",&n);
	memset(a,0,sizeof(a));
	for(int i=1,t,x;i<=n;i++)
		for(scanf("%d",&t);t--;)
			scanf("%d",&x),a[i][x]=1;
}
inline void ready()		//前面说的预处理部分
{
	memset(cha,0,sizeof(cha));	//cha代表change，表示动一下这个开关，会产生的影响的状态（已压缩
	for(int i=1;i<=n;i++)
	{
		cha[i]^=ya(i-1);	//它本身状态改变
		for(int j=1;j<=n;j++)	//持续的第一轮
			if(go(i,j))
			{
				cha[i]^=ya(j-1);
				for(int k=1;k<=n;k++) if(go(j,k)) cha[i]^=ya(k-1);	//它持续的第二轮
			}
	}
	ans=dfs(1,ya(n)-1);		//找到答案
}
int main()
{
	return init(),ready(),ans<=INF?printf("%d\n",ans):puts("Change an alarm clock，please!"),0;		//一行的主程序完美地结束
}
```

---

## 作者：破忆 (赞：1)

### 题意
给定一些闹钟，可以直接关闭或打开其它闹钟，这些闹钟也存在传递性， 可以间接打开或关闭其它闹钟，每次可以改变一个闹钟的状态，问最少几步可以让全部打开的闹钟全部关闭


------------
### 分析
题目已经确定每个闹钟只会直接或间接影响其它闹钟

n^3枚举过去即可获得所有闹钟之间的关系

对于一个闹钟而言，要么不按，要么按一次

显然多按几次没有任何意义

那么枚举每个闹钟的状态即可

### 解法
其实很多题目的复杂度、算法和数据结构都可以根据数据范围猜个大概

举几个例子
>n<=10 O(n^n) 暴搜,模拟...

>n<=20 O(2^n) 压位DP...

>n<=50 O(n^4) DP...

>n<=200 O(n^3) DP...

>n<=1000 O(n^2) DP...

>n<=100000 O(nlogn） 贪心/二分/线段树...

>n<=1000000 O(n) DP/单调序列/单调栈...

>n<2^63 O(logn) 数论...

言归正传，这题n<=20

数据小的可怜，直接上暴搜吧

只有2种状态，可以压位，那就压位搜索

一个闹钟让其它闹钟关闭/打开，就是对范围内的闹钟取反，用异或即可

具体上代码


------------
### 代码
```cpp
#include<bits/stdc++.h>
#define IN inline
#define RE register
using namespace std;
const int maxn=22,INF=1<<30;
int n,a[maxn],b[maxn],ans=INF;//b数组存贮能直接影响的，a数组存贮直接影响与间接影响
IN int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
IN void DFS(int x,int s,int now){//x表示当前枚举的闹钟，s表示状态，now是步数
//	printf("%d\n",s);
	if(now>ans) return;//超出当前答案跳过
	if(!s){//全部关闭更新答案
		if(now<ans) ans=now;
		return;
	}
	if(x==n) return;
	DFS(x+1,s,now);//不按
	DFS(x+1,s^a[x],now+1);//按
}
int main(){
// 	freopen("P4906.in","r",stdin);
// 	freopen("P4906.out","w",stdout);
	n=read();
	for(RE int i=0;i<n;i++){//为了方便，读入时就从0到n-1
		int k=read();
		for(RE int j=1;j<=k;j++) b[i]|=1<<read()-1;
	}
	for(RE int i=0;i<n;i++){//枚举当i被按下
		a[i]^=(1<<i);//i自己能改变
		for(RE int j=0;j<n;j++){
			if((b[i]&(1<<j))&&i!=j){
				a[i]^=(1<<j);//i直接影响的闹钟会改变
				for(RE int k=0;k<n;k++){
					if((b[j]&(1<<k))&&j!=k)
					a[i]^=(1<<k);//i间接影响，j直接影响的闹钟也会改变
				}
			}
		}
	}
	DFS(0,(1<<n)-1,0);//初始时所有闹钟都打开
	if(ans==INF) printf("Change an alarm clock，please!\n");//无解
	else printf("%d\n",ans);
	return 0;
}
```


---

## 作者：FBW2010 (赞：0)

[传送门](https://www.luogu.com.cn/problem/P4906)

# 题意

有 $n$ 个开关，最初它们都是开着的。你可以选择将一个开关的状态取反，那**这个开关直接连着**的开关也会取反，而**第二次取反的开关直接连接**的开关又会取反。求让所有开关关闭的**最少**操作数。

# 思路

看到 $n$ 的范围只有 $20$，不妨直接**搜索**。由于一个开关操作两次是没有意义的，于是可以枚举每个开关是否操作，再判断最后开关是否全部关闭，取最小值即可。

我们可以将问题抽象成**图论**。用 $f_i$ 表示第 $i$ 个点的状态，那么每次操作就相当于从第 $i$ 个点开始遍历，深度为 $2$，然后把所有遍历过的点的 $f$ 都取反。这样复杂度为 $O(2^nn^2)$，可以通过此题。

**注意**：这题数据十分毒瘤，要忽略掉所有重边和自环。我们可以用 $vis$ 数组记录，将一个点走到自己或同一个点的情况去掉。~~本蒟蒻就这么 Wa 了一发~~。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=25;
int n,cnt,sum,ans=1e9,h[N],f[N];
struct node{
	int next,to;
}a[N*N];
void add(int x,int y){
	a[++cnt].next=h[x];
	a[cnt].to=y;
	h[x]=cnt;
}
void DFS(int x,int d){
	int vis[21]={};
	f[x]^=1;
	if(f[x])sum++;
	else sum--;
	vis[x]=1;
	if(d>=2)return;
	for(int i=h[x];i;i=a[i].next){
		if(!vis[a[i].to]){
			DFS(a[i].to,d+1);
			vis[a[i].to]=1;
		}
	}
}
void DFS2(int x,int s){
	if(sum==n||x>n){
		if(sum==n)ans=min(ans,s);
		return;
	}
	DFS(x,0);
	DFS2(x+1,s+1);
	DFS(x,0);
	DFS2(x+1,s);
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		int t;
		scanf("%d",&t);
		while(t--){
			int x;
			scanf("%d",&x);
			add(i,x);
		}
	}
	DFS2(1,0);
	if(ans==1e9)printf("Change an alarm clock，please!");
	else printf("%d",ans);
	return 0;
}
```

---

## 作者：Kirito1 (赞：0)

# 蒟蒻第三篇题解（求过）
#### 这道题不得不吐槽
#### 毒瘤题意+毒瘤数据=毒瘤~~水~~题
### 言归正传
## 题意
1.有n个开关

2.第i个开关有mi个关联开关

若i转化（开关 vt.）则与i关联的开关也会转化（开关 vt.）

且，与i关联的开关  的  关联开关  也变化

3.开关开始都是开的

4.求最少几步可以全关掉

## 分析
#### firstly
#### 看一眼数据 n<=20
#### draw a conclusion:状压dp
#### 我们用0表示开，1表示关
#### 用二进制表示i的关联开关和它自己以及关联开关的关联开关（即 点它时的作用效果）
#### for example 
#### 拿样例的开关2举例 它连接1和3 ，本身是2
#### so 表示为0 0 1 0 1
#### 我们用state[]存储
#### 再用exstate[]存储 state[] ^ 关联开关的state[]以及自己
#### 举个栗子
|开关  |关联开关|
| -----------: | -----------: |
|1  | 2—3|
|2  | 1 |
|3  | 2 |
#### state[1]=110   state[2]=001   state[3]=010
#### exstate[1]=100 exstate[2]=101 state[3]=111
#### 应该没算错...
## 变量意义
```cpp
int state[25],exstate[25]//已解释
bool son[25][25]//由于毒瘤数据开的，暂时略
int f[5][1<<20+1]//f[i][j] i表示状态
//这里采用滚动数组 ∵f[i][j]只与f[i][j-1]有关

```
## 上~~大妈~~代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int state[25];
int exstate[25];
bool son[25][25];
int f[5][1<<20]; 
int main(){
	cin>>n;
	int MAX=1<<n;
	// 最大状态 当n=5时MAX=（1 0 0 0 0 0）减一后（0 1 1 1 1 1）就是目标状态 
	for(int i=1;i<=n;i++){
		int m;cin>>m;
		for(int j=1;j<=m;j++){
			int s;cin>>s;
			if(s>0&&s!=i&&s<=n&&son[i][s]==0){//毒瘤数据居然有s=i和s重的时候 
	//开一个son数组表示s是否已经出现过 
				son[i][s]=1;
				state[i]^=(1<<(s-1));				
	//把二进制第s位改为1	
			}
		}
	}
	for(int i=1;i<=n;i++){	
	exstate[i]=state[i]^(1<<(i-1));//把自己也放进来 
		for(int j=1;j<=n;j++){
			if(i==j)continue;
			if(son[i][j])
			exstate[i]^=state[j];
			//把关联开关的关联开关也放进来
			// 注意，不能把exstate都换成 state 自己想？
			//其实也可以队列或数组存一哈关联开关
			//如果关联开关中有k且关联开关的关联开关也有k，则该为0
			//对于开关k 关联开关与关联开关的关联开关中k出现了偶数次则为0,else为1
			//^很好的 solve it； 
		}
	}
	memset(f,0x3f,sizeof f);f[0][0]=0;
	for(int i=1;i<=n;i++){
		int x=i&1;//当前状态，x^1为上一个 
		for(int j=0;j<MAX;j++){
			f[x][j]=min(f[x^1][j],f[x^1][j^exstate[i]]+1);
		}
	}
	if(f[n&1][MAX-1]==0x3f){//达不到目标状态 
		cout<<"Change an alarm clock，please!"<<endl;
	}else{
		cout<<f[n&1][MAX-1]<<endl;
	}
} 
```


---


# 咕咕咕

## 题目描述

小 F 是一个能鸽善鹉的同学，他经常把事情拖到最后一天才去做，导致他的某些日子总是非常匆忙。

比如，时间回溯到了 2018 年 11 月 3 日。小 F 望着自己的任务清单：

1. 看 iG 夺冠；
2. 补月赛题的锅。

小 F 虽然经常咕咕咕，但他完成任务也是很厉害的，他一次性可以完成剩余任务的任一**非空子集**。比如，他现在可以选择以下几种中的一种：

1. 看 iG 夺冠；
2. 补月赛题的锅；
3. 一边看 iG 夺冠的直播，一边补锅。

当然，比赛实在是太精彩了，所以小 F 就去看比赛了。

不过，当金雨从天而降、IG 举起奖杯之时，小 F 突然心生愧疚——锅还没补呢！于是，小 F 的内心产生了一点歉意。

这时小 F 注意到，自己总是在某些情况下会产生歉意。每当他要检查自己的任务表来决定下一项任务的时候，如果当前他干了某些事情，但是没干另一些事情，那么他就会产生一定量的歉意——比如，无论他今天看没看比赛，只要没有补完月赛的锅，他都会在选择任务的时候产生 $1$ 点歉意。小 F 完成所有任务后，他这一天的歉意值等于他每次选择任务时的歉意之和。

过高的歉意值让小 F 感到不安。现在，小 F 告诉你他还有 $n$ 项任务，并告诉你在 $m$ 种情况中的一种 $\mathrm{state}_i$ 的情况下，小 F 会产生 $a_i$ 点歉意。请你帮忙计算一下，小 F 在那一天所有可能的完成所有任务方式的歉意值之和是多少。

由于答案可能很大，你只需要输出答案对 $998244353$ 取模即可。

## 说明/提示

#### 样例 1 解释：

$0-1$ 串中第一个数字表示小 F 看没看比赛，第二个数字表示小 F 补没补锅。

我们用 $\varnothing$ 表示小 F 什么都没干，$A$ 表示小 F 看了比赛，$B$ 表示小 F 补了锅，那么所有会产生愧疚的方式如下：

$\varnothing: 1$  
$\{A\}:1$

那么所有可能的选择如下：

$\varnothing\rightarrow\{A\}\rightarrow\{A,B\}:2$  
$\varnothing\rightarrow\{B\}\rightarrow\{A,B\}:1$  
$\varnothing\rightarrow\{A,B\}:1$

所以答案是 $2 + 1 + 1 = 4$。

#### 数据范围

保证出现的 $\mathrm{state}_i$ 互不相同。

对于所有数据，有 $1 \leq n \leq 20$, $1 \leq m \leq \min(2 ^ n, 10 ^ 5), 1 \leq a_i \leq 10 ^ 5$。

| Case | $n$ |
| :------:|:------: |
|1|$1$|
|2|$2$|
|3|$3$|
|4|$10$|
|5|$12$|
|6|$14$|
|7|$16$|
|8|$18$|
|9|$19$|
|10|$20$|


## 样例 #1

### 输入

```
2 2
00 1
10 1```

### 输出

```
4```

## 样例 #2

### 输入

```
3 4
000 16
001 9
110 4
111 1```

### 输出

```
260```

# 题解

## 作者：假装思考 (赞：61)

显然，由于题目是求所有方案下羞愧值的和，所以对于每个状态，我们只要计算这些状态总共会出现多少次，再将出现次数乘上相应的权值就行了。

对于计算每个状态的出现次数，我们可以将它们看做中间状态，计算从全0变为它们的方案以及从它们到全1的方案，根据乘法原理相乘，就可以得到每个方案的出现次数。

显然具有相同1/0个数的状态，出现次数一样，因为0/1的位置是不重要的，重要的是数量，所以我们只要计算填i个1有多少种方案(1<=i<=n)。

设Opt[i]为填i个1的方案数，我们考虑最后一次一次性填了j个，选这j个有C(i,j)种选法，再乘上之前的。

于是有

![Luogu](https://cdn.luogu.com.cn/upload/pic/41939.png)

预处理递推一下，最后记录答案时对于每个状态给答案加上Opt[0个数]×Opt[1个数]×A

记得取模。。。比赛二十分钟打完标算算组合数没取模。。。60wawa。。。

~~话说数据能再大点~~


```
#include<bits/stdc++.h>
#define Mod 998244353
#define LL long long
using namespace std;
LL Opt[21],C[21][21],Ans;
int n,m;
void Init(){
    C[0][0]=1;
    for(int i=1;i<=20;++i)
        C[i][0]=1;
    for(int i=1;i<=20;++i)
        for(int j=1;j<=20;++j)
            C[i][j]=(C[i-1][j]+C[i-1][j-1])%Mod;
    Opt[0]=1;
    for(int i=1;i<=20;++i)
        for(int j=1;j<=i;++j)
            Opt[i]=(Opt[i]+Opt[i-j]*C[i][j])%Mod;
}
void Doit(){
    char c;
    int Flag;
    LL Count,A;
    scanf("%d%d",&n,&m);
    while(m--){
        Count=0;
        Flag=0;
        while(Flag<n){
            while((c=getchar())<'0'||c>'1');
            if(c=='1')
                ++Count;
            ++Flag;
        }
        scanf("%lld",&A);
        Ans=(Ans+A*Opt[Count]%Mod*Opt[n-Count]%Mod)%Mod;
    }
    printf("%lld\n",Ans);
}
int main(){
    Init();
    Doit();
    return 0;
}
```

---

## 作者：Gentle空King (赞：8)

月赛的时候，想到了组合，然后进一步想到递推，然后因为来晚了就十五分钟就没打了......

题目的本质便是要看有歉意值的状态出现了多少次，用草稿纸推一下发现暴搜可能不太现实，那就是组合递推啦。

那么我们来考虑由全是0的状态到一个中间状态再到全是1的状态有多少种。

设$cnt[i]$表示由i个0变为有i个1的方法数,易知$cnt[0]=cnt[1]=1$;

比如将00变为11，那么有两种情况：

1.先变出一个1，此时就是$C(2,1)$(组合数,二选一），再由分步乘法原理，剩下1个0变为1，就是再乘上一个$cnt[1]$；

2.一次性变为11，就是$C(2,2)$咯，再乘一个$cnt[0]$；

所以$cnt[2]=C(2,1)*cnt[1]+C(2,2)*cnt[0]=3$.

那么对于由i个0变为有i个1的方法数:

1.挑一个变成1，C(i,1),再乘上由i-1个0变为1的方法数，即C(i,1)*cnt[i-1];

2.挑两个，C(i,2),然后分步原理，C(i,2)*cnt[i-2];

......

于是$cnt[i]=\sum_{j=1}^i{C(i,j)*cnt[i-j]}$;

那么考虑一下一个有i个1的状态会出现多少次，用一个分布乘法原理，
先由n个0变为i个1，再由i个1变为n个1，其实就是先把那i个0变为1，再把剩下n-i个0变为1，那么就是$cnt[i]*cnt[n-i]$，最后再往sum上面加一个$a*cnt[i]*cnt[n-i]$(a为歉意值）,于是递推和计算的工作就大功告成了。

顺便说一句，记得一步一mod，我就是因为没mod好交了四次80哦。

上p党代码

```pascal
const mo=998244353;
var
c:array[0..22,0..22] of int64;//组合数
cnt:array[0..22] of int64;    //方法数
n,m,i,j:longint;         
sum,a,k:int64;                //答案，歉意值，1的个数
ch:char;
begin
readln(n,m);
c[1,0]:=1;c[1,1]:=1;cnt[1]:=1;cnt[0]:=1;
for i:=2 to n do
     c[i,0]:=1;
for i:=2 to n do
     for j:=1 to i do
     begin
         c[i,j]:=(c[i-1,j-1] mod mo+c[i-1,j] mod mo) mod mo;  //杨辉三角递推组合数
         cnt[i]:=(cnt[i]+c[i,j]*cnt[i-j] mod mo) mod mo; //上文所说递推公式
     end;

for i:=1 to m do
 begin
     a:=0;
     for j:=1 to n do
     begin
         read(ch);
         if ch='1' then inc(k);  //字符处理，记录1的个数
     end;
     readln(a);                  //歉意值
     sum:=(sum + (cnt[k]*(cnt[n-k] * a mod mo) mod mo)) mod mo; //一步一mod！！！
 end;
writeln(sum mod mo);
end.
```
最后祝各位大佬noip2018 rp++（蒟蒻即将退赛搞数学啦）

---

## 作者：BinDir0 (赞：7)

这道题对于我一个pj的蒟蒻很不友好QAQ

自己推了一个奇怪的东西把这道题打出来

首先先是一个类似打表的东西，用一个数组gu[x]来存储从做了k件事到k+x件事有多少种情况

不难得知，若总共有n件事待做，现在输入的字符串中有l个‘1’（做l件事），这种情况出现时会增加a的羞愧度，

## 则总羞愧度sum+=gu[l]×gu[n-l]×a

别忘了分开乘（否则会爆long long）

下面是代码啦qwq


```cpp
#include<bits/stdc++.h>
#define N 998244353
using namespace std;
int zh[20][20]={1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,3,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,6,4,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,10,10,5,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,15,20,15,6,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,21,35,35,21,7,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,28,56,70,56,28,8,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,36,84,126,126,84,36,9,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,10,45,120,210,252,210,120,45,10,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,55,165,330,462,462,330,165,55,11,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,12,66,220,495,792,924,792,495,220,66,12,1,-1,-1,-1,-1,-1,-1,-1,-1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1,-1,-1,-1,-1,-1,-1,-1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1,-1,-1,-1,-1,-1,-1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1,-1,-1,-1,-1,-1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1,-1,-1,-1,-1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1,-1,-1,-1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1,-1,-1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1,-1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1};
long long gu[21],t,n,m,sum,a,x,y,v;//三年OI一场空，不开long long见祖宗QAQ 
string w;
int main()
{
	while(1);//防作弊
    第三方的设计开发黑色的礼服//防作弊+1
    gu[0]=gu[1]=1;
    for(int nn=2;nn<=20;nn++)
    {
        for(int i=1;i<nn;i++)
    	{
        	gu[nn]+=zh[nn-1][i-1]%N*gu[nn-i];
        	gu[nn]%=N;
    	}
    	gu[nn]++;
    }
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        t=0;
        cin>>w>>a;
        for(int j=0;j<w.size();j++)
        {
            if(w[j]=='1')
            t++;
        }
        v=gu[t]*a;
        v%=N;
        v*=gu[n-t];
        v%=N;
        sum+=v;
        sum%=N;
    }
    cout<<sum%N;

    
    
    return 0;
}

```

---

## 作者：redegg (赞：4)

$70$分状压记忆化$dfs$。

$100$分组合数学求方案。

（~~其实我觉得记忆化$dfs$不应该过那么多~~）

其实我是不会算枚举子集的复杂度的，当时我觉得我的复杂度很优啊（奶）。

然后考下来$70$分一脸懵逼，这蓝色的$TLE$扎心啊！！！

氧气也救不了我的“很优秀的”代码。

那么先说一下记忆化搜索吧。

首先，搜索，（或者是拓扑排序，也可能是$DP$？），可以状压一下状态，然后枚举现在这个状态的子集，可以求到从子集到自己这个状态的方案数，最后乘上自己的权值就好了，看起来是个套着$dfs$的$dp$（或是拓排）。

由于记忆化，可以确定每个状态只做一次，于是复杂度是O($2^n$)？

哎，你们还是`too young`，得出来的复杂度都`too simple , sometimes naive`。（大雾）

$dfs$复杂度$O(nm)$的，那么这个枚举的复杂度是什么呢？$O(3^n)$，GG。

贴下70代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m;

long long mod=998244353;
long long v[1048600];
long long dp[1048600];
long long dis[1048600];
bool ok=1;

long long dfs(int x)
{
    if(x==0)return v[x];
    if(dp[x]!=-1)return dp[x];
    dp[x]=0;
    for(int i=x&(x-1);i!=0;i=x&(i-1))
    {
        dp[x]=(dp[x]+dfs(i))%mod;
        dis[x]=(dis[x]+dis[i])%mod;
    }
    dp[x]=(dp[x]+dfs(0))%mod;
    dis[x]=(dis[x]+dis[0])%mod;
    dp[x]=(dp[x]+(dis[x]*v[x])%mod)%mod;
    return dp[x];
}

int main()
{
    scanf("%d%d",&n,&m);
    memset(dp,-1,sizeof(dp));
    dis[0]=1;
    for(int i=1;i<=m;i++)
    {
        char c[22];
        scanf("%s",c+1);
        int a=0;
        for(int j=1;j<=n;j++)
        {
            if(c[j]=='1')
            {
                a+=(1<<(j-1));
            }
        }
        scanf("%lld",&v[a]);
    }
    dfs((1<<n)-1);
    printf("%lld\n",dp[(1<<n)-1]%mod);
    return 0;
}
```

既然做到每个状态只做一次都要TLE，~~一定是毒瘤......~~

综上，我们需要把状态数压缩，或者巧妙地统一处理。

是的，在比赛的时候就在思考，是否可以直接求出每个状态的方案数呢？

~~太懒太笨太弱，于是放弃思考划水去了~~

~~抄袭~~借鉴了其他题解，这里我们可以分步做，第一步，从我的子集到我，第二步，从我到目标串。

那么我们还可以再统一处理一下，当几个串里面的1的数量一样的时候，从全0到他们的方案数是相等的（~~显而易见~~）。

那么对于一个子串，他的$1$的数量是$n$的话，他从一个$1$的数量为$m$的子集转移过来的方案数是$C_n^m$，可以这样理解，从他的$n$个$1$中选$m$个$1$出来，这$m$个$1$是他已经完成的，剩下的$1$都是他现在直接一次性完成的。

那么方案转移就是$dp[i] = dp[j] \times c_i^j$

最后答案直接用$dp[$自己的$1$的个数$]$乘上自己的权值，然后加到答案里即可。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

int mod=998244353;

int n,m;

char in[24];

long long c[25][25];
long long v[25];

long long ans;

int main()
{
    scanf("%d%d",&n,&m);
    v[0]=1;
    v[1]=1;
    c[1][1]=1;
    c[1][0]=1;
    for(int i=2;i<=n;i++)
    {
        c[i][0]=c[i-1][0]%mod;
        for(int j=1;j<=i;j++)
        {
            c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
            v[i]=(v[i]+(v[i-j]*c[i][j])%mod)%mod;
        }
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%s",in+1);
        int a=0;
        long long b;
        for(int i=1;i<=n;i++)
            if(in[i]=='1')
                a++;
        scanf("%lld",&b);
        ans=(ans+(v[a]*((b*v[n-a])%mod))%mod)%mod;
    }
    printf("%lld\n",ans%mod);
    return 0;
}
```

---

## 作者：exi3t (赞：3)

本题是个好题,偏数论;
我下面把各个分段的做法写下来;

<1>状压搜索,没什么可讲的,只能拿30分;

<2>加法原理(递推):

		定义cnt[i]为从0到达状态i(二进制状压)的方案数;
    	sum[i]为从0到达状态i的权值和(包括i的);
    	很容易得到递推关系式;
        cnt[i]=Σ(j)cnt[j];
        sum[i]=Σ(j)sum[j]+cnt[i]×w[i];
        其中j是i的真子集;
        那么答案便是sum[(1<<n)-1];
        据说这种算法的时间复杂度是3ⁿ(然而我证明不了);
        在这里交代一下子集的求法:
        loop(j=(i-1)&i;;j=(j-1)&i);
        这样可以求出所有本题意义上子集;
        总之,这种算法能得70分;
<3.1>乘法原理(打表):

        考虑乘法原理,从0到i状态有x种方案,
        而从i到(1<<n)-1有y种方案;
    	那么经过i的方案共有x×y种;
        那么i状态对答案的贡献也就是方案数×权值;   
        那么方案数如何求得?
        在<2>定义了cnt[],这相当于刚才讲的x,
        那么y是什么呢?
        考虑将i状态取反(1变0,0变1),
        那么y也就是从0((1<<n)-1取反得到)到取反后的i的方案数;
        那么状态i的方案数便是cnt[i]×cnt[取反(i)];
        这样做仍然要花3ⁿ时间复杂度来枚举,并不能得到更高的分数,
        但是可以打表,
    	实际上,1的个数相同的状态,它们的cnt[]是相同的;
        所以可以提前计算出1的个数为(1到20)的方案数;
        在新程序中给数组赋值;
        在线处理直接求各状态的贡献之和 即得到答案.
        这样可以AC了;
<3.2>乘法原理(正解):
		
        <3.1>中提到,1的个数相同的状态,它们的cnt[]是相同的;
        所以重新定义cnt[x]为从0到 1的个数为x的状态 的方案数;
        那么cnt[]满足递推关系式:
        cnt[i]=Σ(j)(c(i,j)×cnt[j]); 其中,j从0到i-1;
        这样时间复杂度只有n²;
最后注意取模的写法.

各代码如下:


------------
<2>
```cpp
#include<iostream>
#include<cstdio>
#define ll long long
#define inf 0x7f7f7f7f
#define loop(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
const int p=998244353;
ll cnt[1<<20],sum[1<<20],n,m,w[1<<20];
//cnt[i]指到达状态i的方案数;
//sum[i]只到达状态i的权值和(包括i的);
int trans(string);
int main()
{
//	freopen("in.txt","r",stdin);
    cin>>n>>m; string  state; int x;
    loop(i,1,m){
        cin>>state>>x;
        x%=p;
        w[trans(state)]=x;
    }
    cnt[0]=1; sum[0]=w[0];
    loop(i,1,(1<<n)-1){ //可以保证,子集的状态一定已经求得;
        int j=i;//i的一个子集;
        while(true){
            cnt[i]+=cnt[j];
            cnt[i]%=p;
            sum[i]+=sum[j];
            sum[i]%=p;
            if(!j) break;
            j=(j-1)&i;
        }
        sum[i]+=cnt[i]*w[i];
        sum[i]%=p;
    }
    cout<<sum[(1<<n)-1]<<endl;
    return 0;
}
int trans(string s)
{
    int pow=1,ret=0;
    for(int i=s.size();i>=1;i--){
        if(s[i-1]=='1')	ret+=pow;
        pow*=2;
    }
    return ret;
}
```

<3.1>
打表程序:
```cpp
#include<iostream>
#include<cstdio>
#define ll long long
#define inf 0x7f7f7f7f
#define loop(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
const int p=998244353;
ll cnt[1<<20],n;
//cnt[i]指到达状态i的方案数;
int main()
{
//	freopen("in.txt","r",stdin);
	n=20;
	cnt[0]=1;
    loop(i,1,(1<<n)-1){ //可以保证,子集的状态一定已经求得;
        int j=i;//i的一个子集;
        while(true){
            cnt[i]+=cnt[j];
            cnt[i]%=p;
            if(!j) break;
            j=(j-1)&i;
        }
    }
    int s=0;
	loop(i,0,n){
		if(i) s=s|(1<<(i-1));
		printf("cnt[%d]=%lld;\n",i,cnt[s]);
		//这里打印的cnt[]下标为状态中1的个数;
	}
    return 0;
}
```
        
评测程序:
```cpp
#include<iostream>
#include<cstdio>
#define ll long long
#define inf 0x7f7f7f7f
#define loop(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
const int p=998244353;
ll cnt[20+1],n,m,ans;
//int trans(string);
int bit(string);
void mk_cnt();
int main()
{
    mk_cnt();
    cin>>n>>m; string  state; int x,t; ll tmp;
    loop(i,1,m){
        cin>>state>>x;
        x%=p;
        t=bit(state);
        tmp=1;
        tmp*=cnt[t];
        tmp%=p;
        tmp*=cnt[n-t];
        tmp%=p;
        tmp*=x;
        tmp%=p;
        (ans+=tmp)%=p;
    }
    cout<<ans<<endl;
    return 0;
}
void mk_cnt()
{
    cnt[0]=1;
    cnt[1]=1;
    cnt[2]=3;
    cnt[3]=13;
    cnt[4]=75;
    cnt[5]=541;
    cnt[6]=4683;
    cnt[7]=47293;
    cnt[8]=545835;
    cnt[9]=7087261;
    cnt[10]=102247563;
    cnt[11]=624388220;
    cnt[12]=140725711;
    cnt[13]=783574350;
    cnt[14]=58167463;
    cnt[15]=197672989;
    cnt[16]=507523296;
    cnt[17]=622140839;
    cnt[18]=604776563;
    cnt[19]=768918857;
    cnt[20]=809378366;
}
int bit(string s)
{
    int s1ze=s.size(),ret=0;
    loop(i,1,s1ze) if(s[i-1]=='1') ret++;
    return ret;
}
```
<3.2>
```cpp
#include<iostream>
#include<cstdio>
#define ll long long
#define inf 0x7f7f7f7f
#define loop(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
const int p=998244353;
const int N=20;
ll cnt[N+1],c[N+1][N+1],ans;
//cnt[x]指从0个1 到 x个1 的方案数;
int n,m;
int bit(string);
int main()
{
    c[0][0]=1;
    cin>>n;
    loop(i,1,n) loop(j,0,i){
        if(!j){
            c[i][j]=1;
            continue;
        }
        c[i][j]=c[i-1][j-1]+c[i-1][j];
        c[i][j]%=p;
    }
    cnt[0]=1;
    loop(i,1,n) loop(j,0,i-1){
        (cnt[i]+=(c[i][j]*cnt[j]))%=p;
    }
    cin>>m; string s; int x; ll w,t;
    loop(i,1,m){
        cin>>s>>w;
        x=bit(s);
        t=1;
        (t*=cnt[x])%=p;
        (t*=cnt[n-x])%=p;
        (t*=w)%=p;
        (ans+=t)%=p;
    }
    cout<<ans<<endl;
    return 0;
}
int bit(string s)
{
    int s1ze=s.size(),ret=0;
    loop(i,1,s1ze) if(s[i-1]=='1') ret++;
    return ret;
}
```
需要注意的是,后三个程序中的取模都写得很繁琐,

但是这样写能够保证万无一失;        

---

## 作者：ccviolett (赞：2)

模数打错了所以 WA 了一次。

很简单的一个数学问题，因为每个串直接不影响（没有说一定要先转移到哪个再转移到哪个），所以我们可以直接考虑每一个串对最后答案的贡献。

我们首先有一个全部为 0 的状态，如果需要转移到某个状态，其实就是将其中对应的 0 转换为 1，最后我们需要转换为全部为 1 的状态，就是将剩余的 0 转为 1.

因为哪个 0 先转，哪个 0 后转都无所谓，所以我们可以将问题转换为：先将 x 个 0 改为 1，然后将 n-x 个 0 改为 1，一共有多少种方案。

比如说：

000 -> 110 -> 111

我们就是要先改 2 个 0 为 1，然后改 1 个 0 为 1.

那问题就变成了求转换若干个 0 为 1 的方案数——DP 转移找规律即可。

$$ f[0] = 1, f[i] = 1 + \sum_{j = 1}^{i - 1} c[i][j] * f[j]$$

最后答案就是所有串贡献累加起来。

$$ ans = \sum_{i = 1}^{m} f[x] * f[n - x] * a[i]$$

x 为某一个状态中 1 的数量。


代码：
```c++
#include <bits/stdc++.h>

using namespace std;
#define rep(i, a, b) for (int i = a; i <= b; i++)

const int N = 20;
const int MOD = 998244353;

int c[N + 1][N + 1];
int f[N + 1];
char s[N + 1];
int x;

void init();

int main() {
    //freopen("4996.in", "r", stdin);
    //freopen("4996.out", "w", stdout);
    ios::sync_with_stdio(false);
    init();
    int n, m;
    cin >> n >> m;
    int ans = 0;
    rep(i, 1, m) {
        cin >> (s + 1) >> x;
        int have = 0;
        rep(j, 1, n) have += s[j] == '1';
        int way = (1LL * f[have] * f[n - have]) % MOD;
        int tAns = (1LL * way * x) % MOD;
        (ans += 1LL * tAns) %= MOD;
    }
    cout << ans << endl;
    return 0;
}

void init() {
    rep(i, 0, N) {
        c[i][0] = 1;
        rep(j, 1, i) c[i][j] = (1LL * c[i - 1][j - 1] + c[i - 1][j]) % MOD;
    }
    rep(i, 0, N) {
        f[i] = 1;
        rep(j, 1, i - 1) (f[i] += (1LL * c[i][j] * f[j]) % MOD) %= MOD;
    }
}
```

---

## 作者：philosopherchang (赞：2)

看了[超神火星人](https://www.luogu.org/space/show?uid=24518)（%下dalao）的题解，才发现自己组合数原来一直没有初始化,还没取模。。。（来自一名T2傻到打dfs，T了9个点的蒟蒻）

觉得火星人讲的有点绕嘴，我再来解释一下.

```cpp
lalala[i]=(lalala[i]+(lalala[i-j]*c[i][j])%mod)%mod;//其实我觉得核心代码就这一句
```

c[i][j]就是表示组合数，lalala[i]表示有i个1的方案数，假如说目前一共填了j
个数(1)，那么选这j个数一共有c[i][j]种选法，但我们填j个数时，i个数可能并没有被填完，所以我们要再乘上lalala[i-j]，再加上之前计算过得lalala[i]，递推一遍，就是最后的方案数。

然后对于每个状态，我们计算完这些状态总共会出现多少次，再将出现次数乘上相应的歉意值就行了。

以上全是个人感觉，有错误请提出————来自蒟蒻的请求。

然后就是温馨提醒，这题除了c[i][j]以外都要开long long,不开long long 30分，而且这题非常卡取模，如果只对乘完以后的ans取模,可得50分,如果再对lalala[i]取模，可得80分,如果对ans一边乘lalala[i]一边取模,就能AC了。

最后放上代码（蒟蒻丑陋的代码）：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long c[22][22];//不long long也行
long long mod=998244353;
long long lalala[22],ans;
long long n,m,w,cnt;
int main()
{
	cin>>n>>m;
	c[0][0]=1;
	for(int i=1;i<=20;i++)
	c[i][0]=1;
	for(int i=1;i<=20;i++)
	{
		for(int j=1;j<=i;j++)
		{
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;//不模也没事，爆不了。
		}
	}
	lalala[0]=1;
	for(int i=1;i<=20;i++)
	{
		for(int j=1;j<=i;j++)
		{
			lalala[i]=(lalala[i]+(lalala[i-j]*c[i][j])%mod)%mod;
		}
	}
	for(int i=1;i<=m;i++)
	{
		cnt=0;
		int wa;
		for(int j=1;j<=n;j++)
		{
			scanf("%1d",&wa);
			if(wa==1)
			cnt++;
		}
		cin>>w;
		ans=(ans+(w*lalala[cnt]%mod*lalala[n-cnt]%mod))%mod;//模模模，一定要模。
	}
	cout<<ans;
	return 0;
}
```

文章最后，感谢火星人，再%一下CZ，祝我NOIP RP++。

---

## 作者：asuldb (赞：2)

上午好傻啊，写了一个暴力的$3^n$枚举子集拿到了$70$就快乐走人了

之后就滚粗了

这道题还是不难的

首先就是$O(3^n)$的枚举子集，我们设$dp[S]$表示从起点$0$到$S$状态的所有愧疚值之和是多少

显然所有能转移到$S$的状态必定是其子集，于是则有

$$dp[S]=\sum_{t\in S}dp[t]+f[t]*num[t]$$

$f[t]$表示从$t$状态做一个决定产生的愧疚值，$num[t]$表示从$0$到$t$的方案数

$num[S]$可以一起转移

$$num[S]=\sum_{t\in S}num[t]$$

之后就有了一份$70$分的代码了

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define LL long long
#define re register
#define maxn 1048578
const int mod=998244353;
inline int read()
{
	char c=getchar();
	int x=0;
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<3)+(x<<1)+c-48,c=getchar();
	return x;
}
LL dp[maxn];
int N,n,m;
LL f[maxn],num[maxn];
char S[21];
int main()
{
	n=read(),m=read();
	N=(1<<n)-1;
	int val;
	for(re int i=1;i<=m;i++)
	{
		scanf("%s%d",S,&val);
		int now=0;
		for(re int j=0;j<n;j++)
			if(S[j]=='1') now|=(1<<j);
		f[now]+=val;
	}
	num[0]=1;
	for(re int i=1;i<=N;i++)
	{
		for(re int t=i;t;t=(t-1)&i)
			dp[i]=(dp[i]+f[i^t]*num[i^t]%mod+dp[i^t])%mod,num[i]=(num[i]+num[i^t])%mod;
	}
	std::cout<<(dp[N]+num[N]*f[N]%mod)%mod;
	return 0;
}
```


$O(3^n)$自然过不了$20$的数据的，这个时候思考一下这个$dp$的本质是什么

根据上面那个递推的方程，我们发现每个$f[t]$在答案中出现的次数是$num[t]*num[∁_{U}t]$

因为对于$t$的每一个补集我们都是会枚举到$t$，每次枚举到$t$那么$f[t]$就会出现$num[t]$次，而这些$t$的补集自然会往后传递，传递次数是$num[∁_{U}t]$次，所以一共会出现$num[t]*num[∁_{U}t]$次

好像这个往后传递的次数有些难以理解，其实可以反着考虑成从全集$U$到$S$的方案数，那自然是$num[∁_{U}t]$次

但是发现现在的时间复杂度还是$O(3^n)$，因为$num$并不好求

但是显然如果两个状态$1$的个数相等，那么$num$肯定也相等

那么我们设$g[i]$表示当$S$中有$i$个$1$的时候的$num$的值为多少

我们再来考虑一下上面那个关于$num$的递推式的本质，那个不就是枚举子集吗，对于$1$的个数相同的子集我们完全可以放到一起算啊，而一个有$i$个元素的集合，元素个数为$j$的子集自然有$\binom{i}{j}$个

所以就有

$$g[i]=\sum_{j=0}^{i-1}\binom{i}{j}*g[j]$$

所以现在就非常好做了

代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define LL long long
#define re register
#define lowbit(x) ((x)&(-x))
#define maxn 1048578
const int mod=998244353;
LL f[maxn],dp[maxn];
LL c[21][21],g[21];
int n,m,N;
char S[21];
inline int cnt(int x)
{
	int t=0;
	while(x) t++,x-=lowbit(x);
	return t;
}
int main()
{
	scanf("%d%d",&n,&m);
	N=(1<<n)-1;
	int val;
	for(re int i=1;i<=m;i++)
	{
		scanf("%s%d",S,&val);
		int now=0;
		for(re int j=0;j<n;j++)
			if(S[j]=='1') now|=(1<<j);
		f[now]+=val;
	}
	c[0][0]=1;
	for(re int i=1;i<=n;i++) c[i][0]=c[i][i]=1;
	for(re int i=2;i<=n;i++)
		for(re int j=1;j<i;j++)
			c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;
	g[0]=1;
	for(re int i=1;i<=n;i++)
		for(re int j=0;j<i;j++)
			g[i]=(g[i]+g[j]*c[i][j]%mod)%mod;
	LL ans=0;
	for(re int i=0;i<=N;i++) 
		ans=(ans+f[i]*g[cnt(i)]%mod*g[n-cnt(i)]%mod)%mod;
	std::cout<<ans;
	return 0;
}
```

---

## 作者：hongzy (赞：1)

发一个拿第二类斯特林数做的题解...

首先转换问题，答案转换为$\sum_{i=1}^m a_itot_i$，其中$tot_i$表示经过状态$i$的方案数。利用乘法原理，$tot_i$等于$0$到状态$i$的方案数乘以状态$i$到$(1<<n)-1$的方案数。

考虑求从$0$开始每次加一个数，到一个状态$x$的方案数$total(x)$，求完以后答案就是$\sum_{i=1}^m a_itotal(x)total(((1<<n)-1)\;xor\;x)$了

关于求$total(x)$，这里提供一种思想暴力的方法：假设$x$二进制有$c$个1，$i=1\to c$枚举加几次到$x$，然后求出$c$个不同的$1$放到$i$个不同集合里的方案数，直接第二类斯特林数乘以集合个数的阶乘，因为第二类斯特林数$S(n,m)$是求$n$个带标号小球放进$m$个相同盒子的方案数的

做法比较复杂，可能常数较大

```cpp
#include <stdio.h>

const int N = 32;
const int MOD = 998244353;

void upd(int & x, const int & y) {
	(x += y) >= MOD ? x -= MOD : 0;
}

int n, m, S[N][N], fac[N];
//fac[n] : n! 
//S[n][m] : 把1~n分进m个相同盒子的方案数 (第二类斯特林数) 

void Stirling() { //预处理第二类斯特林数和阶乘 
	for(int i = fac[0] = 1; i < N; i ++) 
		fac[i] = fac[i - 1] * 1ll * i % MOD;
	int n = N - 1, m = N - 1;
	for(int i = 1; i <= n; i ++)
		S[i][0] = 0, S[i][i] = 1;
	for(int i = 2; i <= n; i ++)
		for(int j = 1; j <= m; j ++)
			S[i][j] = ((j * 1ll * S[i - 1][j] % MOD) + S[i - 1][j - 1]) % MOD;
}

int total(int x) { //合成x的方案数
	int c = __builtin_popcount(x); //二进制中1的个数 
	if(!c) return 1;
	int ans = 0;
	for(int i = 1; i <= c; i ++)
		upd(ans, S[c][i] * 1ll * fac[i] % MOD);
	return ans;
}

int main() {
	Stirling(); 
	scanf("%d%d", &n, &m);
	static char state[N];
	int t = (1 << n) - 1, ans = 0;
	for(int i = 0; i < m; i ++) {
		int s = 0, a;
		scanf("%s %d", state, &a);
		for(int j = n - 1; ~ j; j --) //字符串转数字 
			s <<= 1, s |= state[j] ^ 48;
		int pre = total(s), next = total(t ^ s);
		upd(ans, pre * 1ll * next % MOD * a % MOD);
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：qwerta (赞：1)

**题意**

首先给定$m$个长为$n$的串，和踩中每个需付的代价。

定义每次操作从$\underbrace{000....00}_{n}$开始，每步可以任选至少一个$0$变成$1$，当所有串变成$\underbrace{111....11}_{n}$时，操作结束。

在操作过程中，如果在某时刻序列和之前给定的序列相同，那么要付给定序列的代价。

问在这数不清的不同操作都做完之后（两次操作相同当且仅当变换过程**完全**相同），一共要付的代价，对$998244353$取模。


~~哇这个题真实的难读懂啊qwq~~

**以下分析**

先来考虑对于一个给定串$s$，有多少个操作（设为$ans$）会撞上它。

可以注意到，**答案跟数字的位置无关**，所以我们可以先把串抽象出来，数出有$c$个$1$，$(n-c)$个$0$。

那么这$c$个$1$，可能是由$c-1$个$1$的串转移而来，可能是$c-2,c-3......0$个$1$的串转移而来。

### dp!

设$f[i]$为转移成$i$个$1$的方案数。

转移方程：$f[i]=\sum_{j=0}^{j-1}(f[j]*C_{i}^{j})$。

其中$C_i^j$是因为有$C_i^j$种方式从$j$个$1$转移成$i$个$1$。（在$i$个里面钦定$j$个为原有的$1$的方案数为$C_i^j$）

那么从$000.....0$转移到$s$的方案数就为$f[c]$。

而从$s$转移到$111.....1$的方案数可以倒着思考：从$111.....1$转移到$s$，有$(n-c)$个$1$变成了$0$对叭。

所以可以直接操起求过的$f$数组，从$s$转移到全$1$串的方案数就为$f[n-c]$。

然后用乘法原理乘起来，就得到了会经过串$s$的操作数，再乘上串$s$的单次代价就是这个串造成的总代价了。

最后把$m$个串的代价加起来就是答案。

```
/*
	qwerta 
	P4996 咕咕咕 Accepted 
	100
	代码 C++，0.6KB
	比赛 【LGR-055】洛谷11月月赛
	提交时间 2018-11-04 11:58:31//下考前几十秒发现自己忘开long long，太真实了qwq
	耗时/内存 108ms, 804KB
*/
#include<iostream>
#include<cstdio>
using namespace std;
#define LL long long//一年OI一场空，不开long long见祖宗
const int mod=998244353;
LL f[23];
char s[23];
LL je(int x)//返回x!（因为20!没爆long long就直接乱搞了
{
    LL ans=1;
    while(x)
    {
        ans*=x;
        x--;
    }
    return ans;
}
LL C(int q,int w)//返回C(q,w)
{
    return je(q)/je(w)/je(q-w);
}
int main()
{
    ios::sync_with_stdio(false);
    int n,m;
    cin>>n>>m;
    f[0]=1;//初始化
    //先把f预处理出来
    for(int i=1;i<=n;++i)
    {
        for(int j=0;j<i;++j)
        {
            f[i]+=C(i,j)*f[j]%mod;
            f[i]%=mod;
        }
    }
    LL ans=0;
    for(int i=1;i<=m;++i)
    {
        cin>>s;
        int c=0;//c为s中1的个数
        for(int j=0;j<n;++j)
        c+=s[j]-'0';
        int v;//这个串的单次代价
        cin>>v;
        ans+=(LL)f[c]*f[n-c]%mod*v%mod;
        ans%=mod;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：qmq菜死了 (赞：0)

这道题的意思是求出所有可能完成任务的顺序获得羞愧值的总和，当完成任务的情况跟输入情况的某一情况相同时，就会获得相应的羞愧值。对于每个状态只要我们求助它一共的出现次数，再乘上他的羞愧值就可以得到最后的答案，根据乘法原理相乘就可以得到每种状态的出现次数。（这道题也可以用状压来做，对于每一件事，要么做了要么还没做，所以可以用二进制的 0 和 1 来表示）

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=22,MOD=998244353;//偷懒，定义一个模数
long long n,m,a[N][N],f[N],ans=0;//情况可能很多要开 long long
//a[i][j] 表示前 i 个中有 j 个 1 的情况，f[i]表示有 i 个 1 的方案数
int main()
{
	for(int i=1;i<=20;i++)
	{
		a[i][1]=i;
		a[i][i]=1;
		a[i][0]=1;
	}// n 最大为 20，先预处理出所有情况
	for(int i=3;i<=20;i++)
	{
		for(int j=2;j<i;j++)
		{
			a[i][j]=(a[i-1][j]+a[i-1][j-1])%MOD;//乘法原理相乘得出 a[i][j]
		}
	}
	f[0]=1;//初始化
	for(int i=1;i<=20;i++)
	{
		for(int j=1;j<=i;j++)
		{
			f[i]=(f[i]+(f[i-j]*a[i][j])%MOD)%MOD;//同上
		}
	}
	cin>>n>>m;//读入
	for(int i=1;i<=m;i++)
	{
		int c=0,z;
		char x;
		for(int j=1;j<=n;j++)
		{
			while((scanf("%c",&x))==1&&(x<'0'||x>'9'));//边读入边处理
			if(x=='1')
			{
				c++;//求出 1 的个数
			}
		}
		cin>>z;
		ans=(ans+((f[c]*z%MOD)*f[n-c]%MOD))%MOD;//出现次数乘上获得的权值
	}
	cout<<ans;//输出最后答案
	return 0;
}
```


---


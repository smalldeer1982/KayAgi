# [COCI 2016/2017 #1] Vještica

## 题目描述

Matej 面临着一个难题。在此之前，我们必须熟悉一种称作前缀树（`trie`）的数据结构。前缀树以前缀的方式，储存单词：

- 前缀树的每一条边都用英文字母表中的字母表示。
- 前缀树的根节点表示空前缀。
- 前缀树的每个其他节点都表示一个非空前缀。依次连接根节点至该节点路径上所标有的字母，即可得到该前缀。
- 不存在从一个节点出发的、标有相同字母的两条边。

例如，这棵前缀树储存了 `A,to,tea,ted,ten,i,in,inn`：

![](https://cdn.luogu.com.cn/upload/image_hosting/etllxob4.png)

现在，Matej 获得了 $n$ 个单词，并可以将其中的一些单词重组。例如 `abc` 可以重组为 `acb,bac,bca,cab,cba`。请你计算，将一些单词重组后，储存这些单词的前缀树节点数的最小值。

## 说明/提示

#### 样例 3 解释

所有单词均可以重组为 `aabb`。显然，前缀树最少的节点数应为 $5$（包含了表示空前缀的根节点）。

------------

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n\le 16$。

所有单词的长度和不超过 $10^6$，且只包含小写字母。

------------

#### 说明

**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #1](https://hsin.hr/coci/archive/2016_2017/contest1_tasks.pdf) _T6 Vještica_**。

## 样例 #1

### 输入

```
3
a
ab
abc ```

### 输出

```
4 ```

## 样例 #2

### 输入

```
3
a
ab
c ```

### 输出

```
4 ```

## 样例 #3

### 输入

```
4
baab
abab
aabb
bbaa ```

### 输出

```
5 ```

# 题解

## 作者：JK_LOVER (赞：15)

## 题意
给你 $n$ 个字符串，插入字典树中，要求如何重构串，使字典树节点最小。[$QAQ$](https://www.luogu.com.cn/blog/xzc/solution-p6289)
## 分析
$n\le 16$ 可以考虑状压 $dp$ 。考虑如何计算字典树的节点数。如果是两个串，那么 $Size = len_{s_1}+len_{s_2}-pre_{1,2}$ 。 $pre_{i,j}$ 表示 $s_1,s_2$ 的前缀长度。那么将这个拓展到多个字符串。令 $dp[s]$ 表示，已经插入集合为 $s$ 时最小节点数。
$$
dp[s] = dp[s-S] +dp[S] -pre_{i..j}  \ (i,j\in s)
$$
那么这道题就做完了，要记住最后还要加上空节点 $1$ 个。

- 为什么不用 $dp[s] = dp[s-i]+len_{s_i}-pre_{i..j} $ 这种转移方程。我考虑的是，这样转移是没有考虑到所以状态的，如果各位有想法欢迎私聊。

时间复杂度为 $O(3^n + n\times 2^n)$ 。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+10;
char ch[N];
int pre[N][30],sum[20][30],n,f[N];
int main(){
	cin >> n;
	memset(f,0x3f,sizeof(f));memset(pre,0x3f,sizeof(pre));
	for(int i = 1;i <= n;i++){
		cin >> ch+1;
		for(int j = strlen(ch+1);j;j--) sum[i][ch[j]-'a'+ 1]++;
		sum[i][0] = strlen(ch+1);
		f[1<<i-1] = sum[i][0];
	}
	for(int s = 1;s < (1<<n);s++){
		for(int i = 1;i <= n;i++){
			if((s>>i-1)&1){
				for(int j = 1;j <= 26;j++) pre[s][j] = min(pre[s][j],sum[i][j]); 
			}
		}
		pre[s][0] = 0;
		for(int i = 1;i <= 26;i++) pre[s][0] += pre[s][i];
		for(int S = s&(s-1);S;S = (S-1)&s) {
			f[s] = min(f[s],f[S]+f[S^s]-pre[s][0]);
		}
	}
	cout << f[(1<<n)-1]+1 << endl;
}
```


---

## 作者：Dantal10n (赞：5)

[P6289 [COCI2016-2017#1] Vještica](https://www.luogu.com.cn/problem/P6289)

> 本来这个题也只是一般妙，但是做完看了题解区觉得大家注意力都太高了，我完全没法一步想到，于是来点一步步想的。

题意给你 $n$ 个小写字母构成的字符串 $s_i$，求将每个重新排列后，建 Trie 树的最少节点数。$n\le16, \sum|s_i|\le10^6$。

首先每个串只有每种字母的出现次数是有用的，计数一下。

然后会不了一点！想暴力。

一棵 Trie 树能怎么暴力，大概只能**从左往右**或者**从上往下**；**从左往右**就是枚举排列再整，$O(n!)$ 底色的没啥前途。手玩几下也能感觉到前缀这东西很难拆成相邻两对的关系处理，前后关系还是很大的。

于是我们考虑**从上往下**爆搜，也就考虑 Trie 的基本结构：每次往下走一个或分叉多个字母，直到最后叶子，每条从根到叶子的链就代表一个字符串。再换种理解：**我们抛弃常见的挨个插入字符串的理解，而是将“一捆”字符串不断根据下一个字符是否相同拆成小捆，直到叶子**。

然后是我觉得很天才的一步（也可能挺平凡）：**把拆分反向转成合并**。

考虑两个字符串 $s,T$ 建 Trie 的节点数：$|s|+|t|-|\text{LCP}(s,t)|+1$。 

然后，我们考虑两棵分别由字符串集合 $S,T$ 构成的 Trie $U,V$，合并之后的 Trie 的节点数是多少？

仔细考虑，不难发现是 $|U|+|V|-|\text{LCP}\left\{U\cup V\right\}|-1$。原因：考虑合并前缀的相同部分。

后面确实是状压 DP 板子了，预处理 $cs_S$ 表示字符串集合 $S$ 的最大可能 $\text{LCP}$ 长度，具体等于每个串内每个字符个数的最小值，可以 $O(|\Sigma|\cdot 2^n)$ 计算；设计 $f_S$ 表示字符串集合 $S$ 构成的 Trie 的节点数，转移 $O(3^n)$ 枚举子集。

代码实现中的空根节点数的处理与上面讲解有略微不同，但不难理解。

```cpp
#include<bits/stdc++.h>
#define rep(i,n) for(int i=0;i<((int)(n));i++)
#define N 16
#define C 26
#define t(x) (1ll<<(x))
#define S (1<<N)
#define int long long
#define INF 1145141145141919810ll
using namespace std;
int n,ss,cnt[N][C],c[S][C],cs[S],f[S];string str;
map<int,int>lg2;
signed main(){
	cin.tie(0)->sync_with_stdio(0);
	rep(i,N)lg2[t(i)]=i;
	cin>>n,ss=(1<<n);
	rep(i,n){
		int x;
		cin>>str,x=str.size();
		rep(j,x)
			++cnt[i][str[j]-'a'];
	}
	rep(i,C)c[0][i]=INF;
	rep(s,ss)if(s){
		int x=s&-s;x=__builtin_popcount(x-1); 
		rep(i,C)
			cs[s]+=(c[s][i]=min(c[s-t(x)][i],cnt[x][i]));
	}
	rep(s,ss)if(__builtin_popcount(s)>1){
		f[s]=INF;
		for(int t=s;t;t=(t-1)&s)if(t<s)
			f[s]=min(f[s],f[t]+f[s-t]-cs[s]);
	}else if(__builtin_popcount(s)==1)f[s]=cs[s];
	cout<<f[ss-1]+1<<'\n';
	return 0;
}
```

---

## 作者：ModestCoder_ (赞：5)

这题可以想出很多性质

$n<=16$暗示的非常明显，我后来才意识到是状压

对于一堆字符串，显然，我们可以先把它们共有的部分弄掉，剩下的不存在共有的部分

我可以状压$dp_i$表示状态$i$的答案

枚举$i$的子集$j$，表示先把$j$和$i-j$内部先算好答案

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201025180608920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01vZGVzdENvZGVyXw==,size_16,color_FFFFFF,t_70#pic_center)

所以两部分的答案加起来的时候总共共有的部分重复算了一遍

要减掉

令$sum=总共的共有部分$

$dp_i=min(dp_j+dp_{i-j}-sum)$

Code：

```cpp
#pragma GCC optmize("-Ofast")
#include <bits/stdc++.h>
#define maxn 1000010
using namespace std;
int a[20][30], n, dp[maxn], power[25];
char s[maxn];

int calc(int sta){
	int sum = 0;
	for (int i = 1; i <= 26; ++i){
		int x = 1e9;
		for (int j = 1; j <= n; ++j)
			if (power[j - 1] & sta) x = min(x, a[j][i]);
		sum += x;
	}
	return sum;
}

int main(){
	freopen("vjestica.in", "r", stdin);
	freopen("vjestica.out", "w", stdout);
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i){
		scanf("%s", s + 1);
		for (int j = 1; j <= strlen(s + 1); ++j) ++a[i][s[j] - 96];
	}
	power[0] = 1;
	for (int i = 1; i <= n; ++i) power[i] = power[i - 1] << 1;
	for (int i = 1; i < power[n]; ++i){
		if (i - (i & -i) == 0){
			dp[i] = calc(i);
			continue;
		}
		int sum = calc(i);
		dp[i] = 1e9;
		for (int j = (i - 1) & i; j; j = (j - 1) & i)
			dp[i] = min(dp[i], dp[j] + dp[i ^ j] - sum);
	}
	printf("%d\n", dp[power[n] - 1] + 1);
	return 0;
}
```


---

## 作者：mygr (赞：3)

[Link](https://www.luogu.com.cn/problem/P6289)

感觉好多题解都说得不是很全面啊，根本没法理解这道题的算法流程，我来写一篇(自认为)比较详细的题解吧。

我们首先考虑只有两个字符串的情况，此时我们发现将两个字符串都拥有的部分放在 trie 树的最上方，使其重合，一定是最优的，而至于剩下的部分则随意安排，无论怎么放都不会使答案变得更优或更劣。

可一旦有三个及以上个字符串时，答案统计就会变得特别麻烦，例如这样一组数据：

    3
    ea
    ebc
    eab

此时我们会先合并第一，二个字符串，但当我们尝试着在这棵形成的 trie 树上继续合并第三个字符串时，问题来了：我究竟是该向着 $a$ 这条边走还是 $b$ 这条边走？

我们从上帝视角上来看似乎很显然，但是在实际运行中却很难求出最优方案，因为我们在走完相同的部分后并不能知道接下来需要移动至哪里，而且更别说这次操作还有可能对接下来的插入产生影响了。

既然我们无法判断，那干脆就忽略掉它吧。

我们这么考虑，既然相同的部分我们很好统计，那我们干脆只统计相同的部分。

我们发现虽然插入可能会导致其他字符串无法插入，但是只要我们找到一个合适的顺序去合并，那一定能产生一个点数最小的方案。

具体说，我们之前之所以无法使插入第三个字符串时最优是因为第二个字符串早于它插入，导致的结果就是有一个 $e$ 边被占用，导致第三个字符串无法与之结合，那倘若我先插入第三个字符串呢？我们发现此时得出答案的就是最小答案。

有因为数据范围很小，而且每个字符串只会被合并一次，所以我们可以采用状压动规的方式解决。

设 $f_S$ 表示已经合并了 $S$ 这个集合的所有字符串，此时总共用了的最小结点数，于是我们就能得到状态转移方程

$$f_S=\min_{S' \subseteq S}f_{S'}+f_{\complement_{S}S'}+same_S$$

其中 $same_S$ 表示集合 $S$ 中所有字符串都共有的字符的个数(即 trie 树上方共同节点的个数)

然后就可以枚举求解了

至于为什么这样计数一定最优，因为对于每一种状态而言，我们其实就相当于是枚举了它的每一种组合方式，求出来的结果由于取最小值的缘故则一定是使得这种状态出现的最小代价。

那为什么一定会取这个状态的 $same$ 呢？由于我们之前的论断，当两个字符串抑或是 trie 树有相同的部分时，将他们结合一定是最优的(相同部分结合既不影响后续操作又会使答案变小，何乐而不为呢？)

最后需要注意的一点是，如果我们直接枚举每个小于状态的数来找子集的话会超时，所以需要换一种枚举子集的方法，具体看代码，若是实在不理解的话可以自行百度搜索。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Max=20,nmax=1<<16;
int num[20][30],len[Max];
int dp[nmax];
int n,m;
void read(int rank)
{
	char c=getchar();
	while(c<'a' or 'z'<c)
		c=getchar();
	while('a'<=c and c<='z')
	{
		num[rank][c-'a'+1]++;
		len[rank]++;
		c=getchar();
	}
}
int power[Max];
int same(int now)
{
	int ans=0,Min=0;
	for(int i=1;i<=26;i++)
	{
		Min=0x7fffffff;
		for(int j=1;j<=n;j++)
		{
			if(now&power[j])
				Min=min(Min,num[j][i]);
		}
		if(Min!=0x7fffffff)
			ans+=Min;
	}
	return ans;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		read(i);
	power[1]=1;
	for(int i=2;i<=Max;i++)
		power[i]=power[i-1]<<1;
	m=power[n+1]-1;
	for(int i=0;i<=m;i++)
		dp[i]=0x7fffffff;
	for(int i=1;i<=n;i++)
		dp[power[i]]=len[i];
	for(int i=1;i<=m;i++)
	{
		int s=same(i);
		for(int j=(i-1)&i;j;j=(j-1)&i)
		{
			dp[i]=min(dp[i],dp[j]+dp[i^j]-s);
		}
	}
	printf("%d",dp[m]+1);
}
```


---

## 作者：Walrus (赞：2)

晚测场切了，感觉思维没有这么高。

## Solution

LCS 好像是最长公共前缀？

先对于 $n=2$，考虑一个贪心，即将两个字符串内部排序，答案就是这两个字符串的 $size$ 和减去它们的 LCS。

考虑状压，设 $f_S$ 表示选了字符串的集合为 $S$ 这个树的节点个数最小值，思考怎么转移。

对于一个集合 $S$，一个直接的想法是直接枚举这个 $S$ 的子集与其补集来转移，然后贡献减去其 LCS。

同时思考上述性质是否可以推广到一个集合，假设我已经知道一堆字符串的 LCS，那我是否可以将这两个集合合并作为转移，那么有

$$f_S=\min\limits_{\forall S'\subseteq S,T\cup S'=S}f_{S'}+f_T-LCS(S',T)$$

这其实是对的，根据 trie 的性质，这个转移其实是模拟了 trie 的建树过程，优先走公共路径最终树的大小一定是最小的。

考虑怎么求 $LCS(S',T)$，考虑预处理出每一个字符串中的每一个字符出现次数，枚举每个集合，求出所有的 LCS，这个复杂度是 $O(N\times 2^N)$ 的。

最后复杂度是 $O(N\times 2^N+3^N)$。

```cpp
#include <bits/stdc++.h>
#define FASTIO ios::sync_with_stdio(0), cin.tie(nullptr), cout.tie(nullptr)
#define rep(i, j, k) for (int i = j; i <= k; ++i)
#define pre(i, j, k) for (int i = j; i >= k; --i)
#define PII pair<int, int>
#define fi first
#define se second
#define pb push_back
#define lb lower_bound
#define ub upper_bound
//#define int long long
#define inf 0x3fffffff
//#define getchar getchar_unlocked
//#define putchar putchar_unlocked

using LL = long long;
using i64 = __int128;
using namespace std;


const int N = 17;
const int M = 26;
const int mod = 1e9 + 7;

#define cmax(a, b) (a = a > b ? a : b)
#define cmin(a, b) (a = a < b ? a : b)
#define cadd(a, b) (a = (a + b) % mod)
#define cdel(a, b) (a = ((a - b) % mod + mod) % mod)

int n, f[1 << N], b[N][M], sum[1 << N], bj[1 << N][M], ret;
string s[N];

signed main() {
	FASTIO;
	memset(f, 0x3f, sizeof f), memset(bj, 0x3f, sizeof bj);
	cin >> n;
	rep(i, 1, n) {
		cin >> s[i]; f[1 << i - 1] = s[i].size();
		for(auto ch : s[i]) b[i][ch - 'a']++;
	}
	
	rep(S, 1, (1 << n) - 1) {
		rep(j, 1, n) {
			if(S >> (j - 1) & 1) {
				rep(k, 0, 25) cmin(bj[S][k], b[j][k]);
			}
		}
	}
	
	rep(S, 1, (1 << n) - 1) {
		rep(i, 0, 25) {
			sum[S] += bj[S][i];
		}
	}

	rep(S1, 1, (1 << n) - 1) {
		for(int S2 = S1 - 1 & S1; S2; S2 = S2 - 1 & S1) {
			cmin(f[S1], f[S2] + f[S1 ^ S2] - sum[S1]);
		}
	}	

	cout << f[(1 << n) - 1] + 1;

	return 0;
}
```

---

## 作者：ethan0328 (赞：2)

## 题意

给 $n$ 个字符串，插入字典树中，可以把字符重组，使字典树节点数最小，求最小节点数。

## 思路

[状压 DP ](https://oi-wiki.org/dp/state/)模板题。

令 $f_{i}$ 表示在 $i$ 状态下，字典树最小节点数。$i$ 的二进制的第 $j$ 位若为 $1$，则第 $j$ 个字符串在字典树中。第 $j$ 位若为 $0$，则第 $j$ 个字符串不在字典树中。

对于 $f_{i}$，枚举一个状态 $j$ 是 $i$ 的子集，则 $f_{i}=\min(f_{j}+f_{i \oplus j}-same,f_{i})$，其中 $same$ 为所有在字典树内的字符串重复的部分。

最后的答案要加 $1$，因为要算上根节点。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=20,N2=(1<<16)+10;
int n,cnt[N][30],same[N2][30],f[N2];
int main()
{
	string s;
	cin>>n;
	for(int i=1;i<(1<<n);i++)
	{
		f[i]=2e9;
		for(int j=1;j<=26;j++)
		{
			same[i][j]=2e9;
		}
	}
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		for(int j=0;j<s.length();j++)
		{
			cnt[i][s[j]-'a'+1]++;
		}
		f[1<<(i-1)]=s.length();
	}
	for(int i=1;i<(1<<n);i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(i&(1<<j-1))
			{
				for(int k=1;k<=26;k++)
				{
					same[i][k]=min(same[i][k],cnt[j][k]);
				}
			}
		}
		same[i][0]=0;
		for(int j=1;j<=26;j++)
		{
			same[i][0]+=same[i][j];
		}
		for(int j=i&(i-1);j;j=i&(j-1))
		{
			f[i]=min(f[i],f[j]+f[i^j]-same[i][0]);
		}
	}
	cout<<f[(1<<n)-1]+1;
}
```


---

## 作者：happybob (赞：1)

考虑字典树的节点数是什么。将所有字符串按照 LCP 划分等价类，点数为 $\sum \left| s_i \right| - \sum \limits_{i} len_i \times (c_i-1)$。$len_i$ 为第 $i$ 个等价类的 LCP 长度，$c_i$ 表示第 $i$ 个等价类包含字符串数量。

状压 DP，记 $f_S$ 表示对于集合 $S$ 来说，删去能存在的最长 LCP 后，即对于每种字符，删去 $S$ 内每个字符串中这个字符出现次数的 $\min$ 之和后，能得到的最大贡献是多少。同时记录 $g_S$ 表示集合 $S$ 的能存在的最长 LCP 是多少。对于 $f$ 来说，转移直接枚举子集就好。对于 $g$ 来说，预处理每个字符串中每种字符的出现次数就可以直接计算。

总复杂度 $O(3^n+n2^n\left| \Sigma \right| + \sum \limits \left| S_i \right|)$。

代码：


```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <string>
#include <vector>
#include <numeric>
#include <queue>
using namespace std;

const int N = 16;

int f[1 << N];
int n, sum;
string s[N + 1];
int c[1 << N], cnt[N + 1][26], c2[26];

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> s[i];
		sum += s[i].size();
		for (int j = 0; j < s[i].size(); j++) cnt[i][s[i][j] - 'a']++;
	}
	for (int i = 0; i < (1 << n); i++)
	{
		for (int j = 0; j < 26; j++) c2[j] = (int)1e9;
		for (int j = 0; j < 26; j++)
		{
			for (int x = 1; x <= n; x++)
			{
				if ((i >> (x - 1)) & 1)
				{
					c2[j] = min(c2[j], cnt[x][j]);
				}
			}
		}
		for (int j = 0; j < 26; j++)
		{
			if (c2[j] != (int)1e9) c[i] += c2[j];
		}
		for (int S = i; S; S = (S - 1) & i)
		{
			int cs = popcount((unsigned int)S), cs2 = popcount((unsigned int)(i ^ S));
			if (S == i) continue;
			f[i] = max(f[i], f[S] + f[i ^ S] + (c[S] - c[i]) * (cs - 1) + (c[i ^ S] - c[i]) * (cs2 - 1));
		}
	}
	cout << (sum - f[(1 << n) - 1] - c[(1 << n) - 1] * (n - 1) + 1) << "\n";
	return 0;
}
```

---

## 作者：UperFicial (赞：1)

[传送门](https://www.luogu.com.cn/problem/P6289)。

同步发表于我的 [$\text{cnblog}$](https://www.cnblogs.com/UperFicial/p/16043592.html)。

### $\texttt{Description}$

给定 $n$ 个字符串，你可以将任意个字符串重组，使得存储这些单词的 $\text{Trie}$ 数的节点数尽量小。
$1\le n\le 16$。

### $\texttt{Solution}$

第一眼发现 $n\le 16$，可以考虑状压 $\texttt{DP}$。

我们设 $f[s]$ 表示插入完集合 $s$ 中的所有字符串的最小节点数。

那么显然答案是 $f[S]$，$S$ 表示所有字符串的集合。

考虑转移。

先解决一种简单的情况，假设说只有两个字符串 $A,B$，那么将它们插入到 $\text{Trie}$ 树上后所需的节点数为 $len_A+len_B-\text{same}(A,B)$，$\text{same}(A,B)$ 指 $A$ 和 $B$ 可能的最长公共前缀。

这种简单的情况是可以推广到 $n$ 个字符串的。

对于 $f[s]$，我们考虑枚举 $s$ 的子集 $s'$，那么 $s\operatorname{xor} s'$ 是 $s$ 的另一个子集 $s''$。

我们直接对于 $s'$ 和 $s''$ 看做两个字符串，长度分别为 $f[s']$ 和 $f[s'']$，所以就可以归结为两个字符串的情况。

于是得到了最终的状态转移方程：$f[s]=\min_{s'\in s}\{f[s']+f[s\operatorname{xor} s']-\operatorname{same}(s)\}$。

考虑函数 $\operatorname{same}$ 如何求。

我们贪心的想，对于一个字符 $c$，我们考虑集合中所有字符串中 $c$ 的数量，找到最小的那一个，记为 $x$，是不是说明公共的长度又能减少 $x$，因为所有的字符串都有这 $x$ 个字符 $c$。我们对于每一个字符都求一遍相应的 $x$，求和，便是 $\operatorname{same}(s)$ 的值。

细节留给读者自行处理。

贴一下代码：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int MAXN(18);
const int MAXM(1e6+10);
const int INF(1e9+10);
int n;
char s[MAXN][MAXM]; 
int fac[MAXN],len[MAXN];
inline int lowbit(int x){return x&(-x);}
inline int Min(int x,int y){return x<y?x:y;}
int pos[MAXN];
int dp[1<<MAXN];
int mp[MAXN][27];
int main()
{
	scanf("%d",&n);
	for(register int i=1;i<=n;i++) scanf("%s",s[i]+1);
	fac[0]=1;
	for(register int i=1;i<=n;i++) fac[i]=fac[i-1]<<1;
	for(register int i=1;i<=n;i++)
	{
		len[i]=strlen(s[i]+1);
		for(register int j=1;j<=len[i];j++)
		{
			int c=s[i][j]-'a'+1;
			mp[i][c]++;
		}
	}
	for(register int i=1;i<fac[n];i++)
	{
		if(i==lowbit(i))//单独选了一个
		{
			for(register int j=1;j<=n;j++)
				if(i&fac[j-1])
				{
					dp[i]=len[j];
					break;
				}
			continue;
		}
		int sum=0,tot=0,minlen=INF;
		for(register int j=1;j<=n;j++)
			if(i&fac[j-1]) pos[++tot]=j,minlen=Min(minlen,len[j]);
			//找出i中有哪些字符串，将编号记录到pos中 
		for(register int c=1;c<=26;c++)//枚举每一个c，找相应的x 
		{
			int minn=INF;
			for(register int j=1;j<=tot;j++) minn=Min(minn,mp[pos[j]][c]);
			sum+=minn;//求 same 的值 
		}
		dp[i]=INF;
		for(register int j=(i-1)&i;j;j=(j-1)&i)//枚举i的子集 
			dp[i]=Min(dp[i],dp[j]+dp[i^j]-sum);
	}
	printf("%d\n",dp[fac[n]-1]+1);
	return 0;
}
```
$$\texttt{The End.by UF}$$

---

## 作者：MCAdam (赞：0)

[P6289 [COCI2016-2017#1] Vještica](https://www.luogu.com.cn/problem/P6286)

首先很容易想到，两个字符串，把它们扔到$Trie$中，最小的节点数就是：两个字符串的长度之和$-$相同的字母数。

所以我们先对每一个字符串，统计它每一个单词出现了多少次。

看到$n$辣么小，考虑状压。

设$f[i]$表示选了状态为$i$的字符串集合的最少节点数。那么转移就是$f[i]=\min\{f[p]+f[i\,xor\,p]-len\}$。$p$是$i$的子集，$len$是状态$i$中字符串的字母相同数量。

计算$len$的话，就枚举$i$中的字符串，然后把每个字母的数量取个最小值，再加起来。

现在还有一个问题，怎么枚举$i$的子集呢？如果直接一个个枚举再判断会超时。

```cpp
for(register int j=(i-1)&i;j>0;j=(j-1)&i)
```
因为对于任意一个数$j$，让$j$&上$i$肯定是$i$的子集，$(i-1)$&$i$就是除$i$以外最大的子集；然后到次大的。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <cstring>
#include <string>
using namespace std;
const int N=20,INF=1e9+10;
string s[N];
int all[30],cnt[N][30],f[66600];
int main()
{
	int n;
	scanf("%d",&n);
	for(register int i=0;i<n;i++)
	{
		cin>>s[i];
		for(register int j=0;j<s[i].length();j++)
			cnt[i][s[i][j]-'a']++;//统计每个字符串的单词 
	}
	memset(f,0x3f,sizeof(f));	
	for(register int i=0;i<(1<<n);i++)
	{
		int ans=0,stp=0;
		for(register int j=0;j<26;j++)
			all[j]=INF;
		for(register int j=0;j<n;j++)
		{
			if((i&(1<<j))==0) continue;
			for(register int k=0;k<26;k++)
				all[k]=min(all[k],cnt[j][k]);//统计字母的重复数 
			stp++;
		}
		for(register int j=0;j<26;j++)
			if(all[j]!=INF) ans+=all[j];//加起来 
		if(stp==1){ f[i]=ans; continue; }
		for(register int j=(i-1)&i;j>0;j=(j-1)&i)//枚举子集 
			if(j>1&&j<i) f[i]=min(f[i],f[j]+f[i^j]-ans);//转移 
	}
	printf("%d\n",f[(1<<n)-1]+1);
	return 0;
}
```

---


# [YsOI2020] 义已失吾亦死

## 题目背景

> 义已失吾亦死！亦久亦旧罢以龄。

本题添加了 HACK 数据。并且愿意接受更多的 HACK 数据。

## 题目描述

Ysuperman 的幼儿园不仅注重文化课、竞赛课的教学，还教授大家德智体美全面发展。这一天是周末，德智体美全面发展的 Ysuperman 爬上了 Y 山。

Ysuperman 爬山并不走行车的大路，而是走旁边的泥土山路。走了很远，他猛然发现回头的路已变得模糊，挡在他面前的是巨大的石壁。他震惊地发现，石壁上竟然写有上个世纪的文字！“义已失吾亦死”他看着这些文字，仿佛有一种特殊的魅力。

回到幼儿园，兴奋的 Ysuperman 立即创造了其他的句子，但他却发现这些句子大部分都失去了魅力。经过两年半的钻研，TA 终于发现，“义已失吾亦死”，对应的其实是 $114514$ 这串数字！研究方向变得更加明确，他决定研究把一个句子映射到一个数字里，一个有魅力的数字满足如下条件：

- 十进制，是自然数；

- 数位(digit)仅仅包含 $1,4,5$ 三种数字；

- 在模一个给定常数 $p$ 意义下为 $0$。

现在 Ysuperman 已经有了很多的数字 $1,4,5$，分别有 $a_1,a_4,a_5$ 个。

Ysuperman 希望组成一个长度为 $n$ 的有魅力的数字，使得它尽可能大。

Ysuperman 知道，如果 TA 还是学生，一定能凭借这次发现入围羟基计划。为了 TA 儿时的梦想，你能帮帮他吗？

## 说明/提示

### 样例说明

#### 样例说明 $1$：

第一组可以组成 $1,4,5$，最大的是 $5$。

第二组可以组成 $145,155,415,455,515,545$，最大的是 $545$。

第三组只能组成 $114514$。

-----
### 数据范围

为了致敬 NOI，出题人特地准备了良心的部分分表格。

| 测试点编号 | $n$ | $a_1,a_4,a_5$ | $p$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $=1$ | $=0$ | $=1$ |
| $2$ | $=2$ | $\le 1$ | $\le 10$ |
| $3$ | $=3$ | $\le 3$ | $\le 10$ |
| $4$ | $=15$ | $\le 15$ | $\le 10$ |
| $5$ | $\le 20$ | $\le 20$ | $\le 20$ |
| $6$ | $\le 30$ | $\le 30$ | $\le 30$ |
| $7$ | $\le 35$ | $\le 35$ | $\le 35$ |
| $8$ | $\le 233$ | $\le 233$ | $\le 2$ |
| $9$ | $\le 233$ | $\le 233$ | $\le 2$ |
| $10$ | $\le 50$ | $\le 50$ | $\le 64$ |
| $11$ | $\le 55$ | $\le 55$ | $\le 64$ |
| $12$ | $\le 60$ | $\le 60$ | $\le 64$ |
| $13$ | $\le 65$ | $\le 65$ | $\le 64$ |
| $14$ | $\le 70$ | $\le 70$ | $\le 64$ |
| $15$ | $\le 75$ | $\le 75$ | $\le 64$ |
| $16$ | $\le 80$ | $\le 80$ | $\le 64$ |
| $17$ | $\le 233$ | 性质一 | $\le 64$ |
| $18$ | $\le 233$ | 性质一 | $\le 64$ |
| $19$ | $\le 233$ | 性质二 | $\le 64$ |
| $20$ | $\le 233$ | 性质二 | $\le 64$ |
| $21$ | $\le 233$ | $\le 233$ | $\le 64$ |
| $22$ | $\le 233$ | $\le 233$ | $\le 64$ |
| $23$ | $\le 233$ | $\le 233$ | $\le 64$ |
| $24$ | $\le 233$ | $\le 233$ | $\le 64$ |
| $25$ | $\le 233$ | $\le 233$ | $\le 64$ |

性质一：$a_1+a_4+a_5=n$。

性质二：$a_1=a_4=a_5=n$。

对于 $100\%$ 的数据，满足  

$0 \le a_1,a_4,a_5 \le 233$。  
$1\le n \le 233$。   
$1 \le p \le64$。  
$0 \le T\le 5$。

-----

### 提示

如果你不知道自然数是什么意思，Ysuperman 提供了一个链接：[link](https://zh.wikipedia.org/zh-hans/%E8%87%AA%E7%84%B6%E6%95%B0)。

如果你不知道取模是什么意思，Ysuperman 提供了另一个链接：[link](https://zh.wikipedia.org/zh-hans/%E6%A8%A1%E9%99%A4)。

## 样例 #1

### 输入

```
5
1 1
1 1 1
3 5
1 1 2
6 62
3 2 1
23 13
10 10 10
233 10
233 233 233
```

### 输出

```
5
545
114514
55555555554444444441111
-1
```

## 样例 #2

### 输入

```
5
100 64
33 33 34
114 63
33 33 50
115 62
111 11 1
192 60
8 1 7
233 64
100 100 33
```

### 输出

```
5555555555555555555555555555555555444444444444444444444444444441111111111111111111111111111111414144
555555555555555555555555555555555555555555555555444444444444444444444444444444441111411111111111111111111111111111
5444444444111111111114111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111114
-1
55555555555555555555555555555555544444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444411111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111414144
```

# 题解

## 作者：Imakf (赞：12)

~~似乎被一些不太正常的做法艹了，所以赛后加了组 HACK 数据~~

先讲不正经的部分分。

### $\rm{testdata}\ 1(4pts)$ $a_i=0$

答案全为 `-1`。

### $\rm{testdata}\ 8\sim9(8pts)$ $p=2$

因为 $p=2$，所以只能把 $4$ 放最后，前面直接贪心。

### $\rm{testdata}\ 17\sim18(8pts)$ $\sum a_i=n$

然而出题人并不会这一档。

### $\rm{testdata}\ 19\sim20(8pts)$ $a_i=n$

发现非常容易搜出结果，直接爆搜。

----

### 算法一：

从高位到低位贪心搜索。

期望得分：$32$。

实际得分：？？（取决于出题人心情）

### 算法二：

容易发现上述搜索算法在无解时一定会 TLE。

于是限制每一组数据只能跑 200ms，超过则判 `-1`。

期望得分：$44$。

实际得分：？？（取决于出题人心情）

------

### 算法三：

容易发现，这是一道 dp 题。

下面介绍一种错误的状态设计：

设 $dp_{b_1,b_4,b_5,l,q}$ 表示考虑了由高到低 $l$ 位，剩余 $b_1,b_4,b_5$ 个 $a_1,a_4,a_5$，当前模意义下为 $q$ 的最大答案（一个高精度数）。

经过状态简化可以变为 $dp_{b_1,b_4,b_5}$，含义不变。

这么设计状态为什么错误？

因为前面尽可能大，后面不一定能有解。

就算从低位到高位考虑也是不对的，因为后面尽可能大前面不一定大。

期望得分：？？（取决于出题人心情）

实际得分：N/A（出题人是懒狗，没写）。

### 算法四：

把原本的最优化 dp 转变为可行性 dp。

设 $dp_{b_1,b_4,b_5,l,q}$ 是否存在一个数，使得考虑了**由低到高** $l$ 位，剩余 $b_1,b_4,b_5$ 个 $a_1,a_4,a_5$，当前模意义下为 $q$。

容易发现这样 dp 求解，过程是 $O(n^4p)$。

考虑如何获得答案，固定 $l=n,q=0$，枚举 $b_1,b_4,b_5$，贪心选取 $5,4,1$，获得答案。

计算答案是 $O(n^3p)$。

总复杂度 $O(Tn^4p)$

根据实现优劣可以拿到不同的分数。

期望得分：$20\sim 28$。

实际得分：N/A（出题人是懒狗，没写）。

### 算法五：

简化 $dp$ 状态。

将状态仅仅保留为 $dp_{b_1,b_4,b_5,q}$。

因为你可以通过 $b_1,b_4,b_5$ 直接求得当前位数 $l$。

总复杂度 $O(Tn^3p)$。

期望得分：$56$。

### 算法六：

继续简化 $dp$ 状态。

发现 $p$ 很小，可以直接使用 `unsigned long long` 进行压位。

总复杂度 $O(Tn^3)$。

期望得分：$100$。

以下为 std。

**然而 std 的 dp 状态是 $l,b_1,b_4$**。 *然而 std 的 dp 状态是 $l,b_1,b_4$*。 **然而 std 的 dp 状态是 $l,b_1,b_4$**

重要的事情说三遍。

最后求答案时可以进行剪枝，跑得飞快。 std 未剪枝。

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>

using namespace std;
#define ULL unsigned long long
#define MX (234 + 1)
#define pow10 IEE

int n ,p;
int a1 ,a4 ,a5 ,pow10[MX];
ULL dp[MX][MX][MX];
ULL LOOP(ULL x ,int bit){ // 循环左移
	bit = (bit % p + p) % p; 
	return (x << bit) | (x >> (p - bit));
}

struct BIGINT{
	char k[MX];
	int len;
	BIGINT(){memset(k ,0 ,sizeof k); len = 0;}
	void push_back(char c){k[len++] = c;} 
	bool operator <(const BIGINT &B)const{
		if(len != B.len) return len < B.len;
		for(int i = 0 ; i < len ; ++i){
			if(k[i] != B.k[i]) return k[i] < B.k[i];
		}return false;
	}
	void output(){puts(k);}
}Ans ,tmp;

void solve(){
	memset(dp ,0 ,sizeof dp); 
	Ans = BIGINT(); 
	cin >> n >> p >> a1 >> a4 >> a5;
	pow10[0] = 1;
	for(int i = 1 ; i <= n ; ++i){
		pow10[i] = pow10[i - 1] * 10 % p;
	}
	dp[0][0][0] = 1;
	for(int i = 0 ; i < n ; ++i){
		for(int j = 0 ; j <= min(i ,a1) ; ++j){
			for(int s = 0 ; s <= a4 && s + j <= i ; ++s){
				int k = i - j - s; if(k > a5) continue;
				dp[i + 1][j + 1][s] |= LOOP(dp[i][j][s] ,pow10[i] * 1 % p);
				dp[i + 1][j][s + 1] |= LOOP(dp[i][j][s] ,pow10[i] * 4 % p);
				dp[i + 1][j][s] |= LOOP(dp[i][j][s] ,pow10[i] * 5 % p);
			}
		}
	}
	for(int j = 0 ; j <= a1 ; ++j){
		for(int s = 0 ; s <= a4 ; ++s){
			int A5 = n - j - s ,A1 = j ,A4 = s;
			if(A5 < 0 || A5 > a5 || (dp[n][j][s] & 1) == 0 ) continue;
			ULL st = 1;
			tmp = BIGINT();
			for(int t = n ; t ; --t){
				// priority: 5 > 4 > 1
				if(A5 && (LOOP(st ,-pow10[t - 1] * 5) & dp[t - 1][A1][A4])){
					tmp.push_back('5');
					st = LOOP(st ,-pow10[t - 1] * 5) & dp[t - 1][A1][A4] ,--A5;
				}else if(A4 && (LOOP(st ,-pow10[t - 1] * 4) & dp[t - 1][A1][A4 - 1])){
					tmp.push_back('4');
					st = LOOP(st ,-pow10[t - 1] * 4) & dp[t - 1][A1][--A4];
				}else{
					tmp.push_back('1');
					st = LOOP(st ,-pow10[t - 1] * 1) & dp[t - 1][--A1][A4];
				}
			}
			if(Ans < tmp) Ans = tmp;
		}
	}
	if(Ans.len == 0) puts("-1");
	else Ans.output();
}

int main(){
	int T; cin >> T;
	while(T--) solve();
	return 0;
}

```

---

## 作者：lmAKf (赞：12)

大家好，这里是乱搞草过去的玩家。

首先显然有一个 $\mathcal O(n^3p)$ 的 dp 做法，然后感觉挺不能过的。

然后假如您不知道把某个维度压到一个 bitset 的话我们考虑一下 brute

显然如果有解的话将 dp 换成记搜**应该**会一下子就把答案跑出来。

这里的复杂度应该是会和 $p$ 相关而不是 $n$ 了，挺直观的，但是复杂度咋也说不清，无解就会跑满。

于是我们的问题只有：

1. 特判无解。
2. 把空间压下来。

压空间的话把三个维度哈希一下就可以了，你可以挑选你喜欢的模数。

特判无解的话我们用这份哈希+记搜的代码跑一下，然后打个表，发现在 $n$ 取 $1\sim 233$ 时，$10|p$ 或 $p=25$ 或 $p=26$ 时总是无解的。

所以我们将这三类模数判掉。

然后赛后出题人加了一些模数不是上述情况但是无解的情况，这样只需要在搜索时限制一下遍历上界即可，大概取 $1.5\cdot 10^6$ 即可啦。

然后出题人又说他非常毒瘤，准备对着模数卡，于是我改了一个随机模数的版本。

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )
#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )
#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )
#define re register
#define LL long long
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int N = 233 + 5 ; 
const int M = 6e5 + 5 ; 
const int K = 70 ; 
bool F[M][K] ;  
int idcnt, P ;
LL Hash( LL x, LL y, LL z ) {
	return ( x * 19491001ll % P + y * 20131223ll % P + z * 19260817ll % P ) % P ;
}
int n, p, a1, a2, a5, flag, vis[N] ; 
void dfs( int A1, int A2, int A3, int v ) {
	int x = A1 + A2 + A3 ; ++ idcnt ; 
	if( flag || A1 > a1 || A2 > a2 || A3 > a5 ) return ; 
	LL u = Hash(A1, A2, A3) ; 
	if( F[u][v] ) return ; 
	F[u][v] = 1 ; 
	if( idcnt > 1500000 ) return ;  
	if( x == n ) {
		if( v == 0 ) {
			rep( i, 1, n ) printf("%d", vis[i] ) ; 
			flag = 1, puts("") ; 
			return ; 
		}
		return ; 
	} 
	vis[x + 1] = 5 ; 
	dfs( A1, A2, A3 + 1, ( v * 10 + 5 ) % p ) ;
	if( flag ) return ; 
	vis[x + 1] = 4, 
	dfs( A1, A2 + 1, A3, ( v * 10 + 4 ) % p ) ;
	if( flag ) return ; 
	vis[x + 1] = 1,
	dfs( A1 + 1, A2, A3, ( v * 10 + 1 ) % p ) ; 
	if( flag ) return ; 
}
int tp[100] = { 499439, 499459, 499481, 499483, 499493, 499507, 499519, 499523, 499549, 499559, 
				499571, 499591, 499601, 499607, 499621, 499633, 499637, 499649, 499661, 499663, 
				499669, 499673, 499679, 499687, 499691, 499693, 499711, 499717, 499729, 499739, 
				499747, 499781, 499787, 499801, 499819, 499853, 499879, 499883, 499897, 499903 } ;
signed main()
{
	srand(time(NULL)) ;
	int T = gi() ;
	int tx = rand() % 40 ;
	P = tp[tx] ; 
	while( T-- ) {
		idcnt = 0 ;  
		n = gi(), p = gi(), flag = 0 ; 
		a1 = gi(), a2 = gi(), a5 = gi() ; 
		if( a1 + a2 + a5 < n ) puts("-1") ; 
		else if( ( p % 10 == 0 ) || ( p == 26 ) || ( p == 25 ) ) puts("-1") ; 
		else {
			dfs( 0, 0, 0, 0 ) ; 
			if( !flag ) puts("-1") ; 
		}
		memset( F, 0, sizeof(F) ) ;
	}
	return 0 ;
}
```

---

## 作者：zzqDeco (赞：7)

终于打完了这个毒瘤题（卡掉乱搞，我求你了）

首先考虑一个简单的 dp ，也就是说 $f[i][j][k][g]$ 表示分别选择 $i,j,k$ 个 $1,4,5$ 得到余数 $g$ 的最大答案

显然这个是一个空间很大的算法，有点难受，于是便可以考虑一下一个常见的操作：我们先考虑是否可行然后再反向查找最大答案（实际上感觉类似于找最短路的实际路径）

考虑到这里我们就可以发现出题人的用心良苦，$64$ 显然是为了方便状压吗，我们直接用一个 `unsigned long long` 来解决这个问题

最后提醒两个技巧卡常：

1. 找答案的时候剪枝
2. $n^2$ 预处理所有取模可以快 $1s$（别问我为啥知道）

下面就是代码

```cpp
void init()
{
  cout<<"wdnmd"<<endl;
  inv[1]=1%p;
  for(int i=2;i<=234;i++) inv[i]=inv[i-1]*10%p;//,printf("%d\n",inv[i]);
  for(int i=0;i<=63;i++)
  {
    for(int j=1;j<=234;j++)
    {
      g[i][j][1]=res<<((i+1*inv[j])%p);
      g[i][j][2]=res<<((i+4*inv[j])%p);
      g[i][j][3]=res<<((i+5*inv[j])%p);
      h[i][j][1]=((i-(1*inv[j]%p)+p)%p);
      h[i][j][2]=((i-(4*inv[j]%p)+p)%p);
      h[i][j][3]=((i-(5*inv[j]%p)+p)%p);
    }
  }
  cout<<"wdnmd"<<endl;
}

int redo(int len,int i,int j,int v)
{
  bool qwq=0;
  while(len!=0)
  {
    ++cnt;
    if(i+j<len&&(f[len-1][i][j]&(res<<h[v][len][3])))
    {
      ans[cnt]=5;
      v=h[v][len][3];
      len--;
    }
    else if(j&&(f[len-1][i][j-1]&(res<<h[v][len][2])))
    {
      ans[cnt]=4;
      v=h[v][len][2];
      len--;
      j--;
    }
    else if(i&&(f[len-1][i-1][j]&(res<<h[v][len][1])))
    {
      ans[cnt]=1;
      v=h[v][len][1];
      len--;
      i--;
    }
    if(ans[cnt]<nowans[cnt]&&!qwq) return 0;
    if(ans[cnt]>nowans[cnt]) qwq=1;
  }
  return 1;
}

int main()
{
  int t=redi();
  while(t--)
  {
    memset(f,0,sizeof(f));
    memset(nowans,0,sizeof(nowans));
    n=redi();
    p=redi();
    cout<<"wdnmb"<<endl;
    init();
    A=redi();
    B=redi();
    C=redi();
    f[0][0][0]=1;
    for(int l=0;l<=n-1;l++)
      for(int i=min(l,A);i>=0;i--)
        for(int j=max(0,l-C-i);i+j<=l&&j<=B;j++)
          for(int k=0;k<p;k++)
            if(f[l][i][j]&(res<<k))
            {
              f[l+1][i+1][j]|=g[k][l+1][1];
              f[l+1][i][j+1]|=g[k][l+1][2];
              f[l+1][i][j]|=g[k][l+1][3];
            }
    bool flag=1;
    for(int i=min(n,A);i>=0;i--)
      for(int j=max(0,n-C-i);i+j<=n&&j<=B;j++)
        if(f[n][i][j]&1)
        {
          cnt=0;
          if(redo(n,i,j,0)) for(int i=1;i<=n;i++) nowans[i]=ans[i];
          flag=0;
        }
    if(flag) printf("-1");
    else for(int i=1;i<=n;i++) printf("%d",nowans[i]);
    printf("\n");
  }
}
```



---

## 作者：一架飞机 (赞：2)

因为要求最大值，又没办法贪心，所以选择 dp。因为1、4、5的个数是独立的而且都有后效性，所以 dp 的前3维分别表示现在已经用的1、4、5的个数 i、j、k。因为要模 p 等于0，所以第4维 t 表示模 p 等于 t。然后 dp 就诞生了：$dp[i][j][k]$ 表示用了 i 个1、j 个4、k 个5时组成的数模 p 是否可以等于 t。（我们先考虑能否有这个数，后面再说。空间和时间复杂度不对，后面也会优化）然后转移就诞生了:考虑最后一个放的是1，则可以得到：`dp[i][j][k][t]|=dp[i-1][j][k][(t-1+p)%p]`。4、5同理。

如何找到最大值呢？这里就要用到**路径回溯**。如果不会可以先看 [P1759](https://www.luogu.com.cn/problem/P1759)。其实就是 dp 求完后倒回去看每一步可以选哪个，然后选最优的。这里的最大相当于字典序最大，直接用贪心。

如何优化呢？因为 $p\leq 64$，所以想到了状压 dp。然后就需要把下面这个用 $O(1)$ 次位运算完成：
```cpp
for(int t=0;t<p;t++)dp[i][j][k][t]|=dp[i-1][j][k][(t-1+p)%p];
```
可以发现 `t1=(t-1+p)%p` 就是向左移一位，空出来的用超出的补上，就相当于 `(x<<k)|(x>>(p-1))`。(x 是这个数，t 是每一位)

综上，这是一道有点麻烦的状压 dp 加路径回溯。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int M=240,P=70;
ull dp[M][M][M];int poww[M],ans[M],p;
ull rev(ull x,int k){return (x<<k)|(x>>(p-k));}
bool dig(ull x,int k){return (x>>k)&1;}
int main(){
 //	freopen("my.txt","w",stdout);
	int T;scanf("%d",&T);
	int n,a1,a4,a5;
	while(T--){
	    memset(dp,0,sizeof(dp));memset(ans,0,sizeof(ans));dp[0][0][0]=1;
		scanf("%d%d%d%d%d",&n,&p,&a1,&a4,&a5);
		poww[0]=1;for(int i=1;i<=n;i++)poww[i]=poww[i-1]*10%p;
		if(a1+a4+a5<n){puts("-1");continue;}
		for(int i=0;i<=a1;i++){
			for(int j=0;j<=a4&&i+j<=n;j++){
				for(int k=0;k<=a5&&i+j+k<=n;k++){
					int t=poww[i+j+k-1];//cout<<t<<":\n"<<rev(dp[i][j][k],t)<<endl;
					if(i)dp[i][j][k]|=rev(dp[i-1][j][k],t);
					if(j)dp[i][j][k]|=rev(dp[i][j-1][k],t*4%p);
					if(k)dp[i][j][k]|=rev(dp[i][j][k-1],t*5%p);
//					for(int o=0;o<=p;o++)if(dig(dp[i][j][k],o))cout<<i<<' '<<j<<' '<<k<<' '<<o<<endl;
				}
			}
		}
		int flag=0;
		for(int kk=a5;kk>=0;kk--){
			for(int jj=a4;jj>=0;jj--){
				int i=n-jj-kk;
				if(i>=0&&(dp[i][jj][kk]&1ull)){
					int res=0,j=jj,k=kk;//cout<<i<<' '<<j<<' '<<k<<endl;
					for(int o=n-1;o>=0;o--){//cout<<i<<' '<<j<<' '<<k<<' '<<res<<endl;
						int t=poww[o],tmp;
						if(k&&dig(dp[i][j][k-1],(res-t*5%p+p)%p))tmp=5,res=(res-t*5%p+p)%p,k--;
						else if(j&&dig(dp[i][j-1][k],(res-t*4%p+p)%p))tmp=4,res=(res-t*4%p+p)%p,j--;
						else tmp=1,res=(res-t%p+p)%p,i--;
						if(flag){
							if(tmp>ans[o])flag=0;
							else if(tmp<ans[o])break;
						}
						if(!flag)ans[o]=tmp;
					}
					flag=1;
				}
			}
		}
		if(!flag)puts("-1");
		else{for(int i=n-1;i>=0;i--)printf("%d",ans[i]);puts("");}
	}
	return 0;
}

```



---


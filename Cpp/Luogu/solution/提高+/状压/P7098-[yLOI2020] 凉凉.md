# [yLOI2020] 凉凉

## 题目背景

> 凉凉三生三世恍然如梦，须臾的年风干泪痕。  
> 若是回忆不能再相认，就让情分落九尘。  
> 凉凉十里何时还会春盛，又见树下一盏风存。  
> 落花有意流水无情，别让恩怨爱恨凉透那花的纯，吾生愿牵尘。 

——张碧晨&杨宗纬《凉凉》

## 题目描述

这是 yLOI 系列竞赛中第一道以歌曲命名但歌手不是银临的题目。这道题目的歌曲和问题没什么关系，只是我们的主人公叫凉凉，于是扶苏为他选择了这首歌。

凉凉在和「七瑾在成都喝着凉茶看 jk 边咕咕边嘎嘎边哔哔边在瓦片上吭吭哧哧切企鹅」群的部分群友在青岛面基结束后，和扶苏一起乘坐地铁被七瑾送到了青岛北站。在乘坐地铁的途中，他们经过了「做物理站（错埠岭站）」，做完了高考物理的凉凉给一点都不想做物理的扶苏提了一个物理问题，扶苏不会做，所以凉凉决定考你一道经济学问题。

青岛共有 $n$ 条地铁线路和 $m$ 个地铁站点。每条线路的地铁都在地下以某一固定的深度运行，而如果某深度为 $i$ 的地铁经过了地铁站 $j$，那么地铁站 $j$ 就要在深度为 $i$ 的地方挖一个站台作为上下客口，开挖该上下客口的花费为 $a_{i,j}$。我们忽略建设上下客口通向地面的通道的费用，而只考虑在该深度建上下客口的花费。显而易见，对于线路 $u$ 和线路 $v$，如果他们都经过了同一个地铁站，那么他们线路不能处在同一深度，否则两线地铁将会相撞。而如果 $u$ 和 $v$ 不存在任何一个相同的经过站点，那么这两条线既可以处在同一高度，也可以不处在同一高度。

在这个问题中，你可以认为任何两个地铁不会在除了站点以外的行驶途中相遇，也即你无需考虑两个地铁因为行驶线路交叉而在两站点之间相遇的情况。

将站点从 $1$ 至 $m$ 编号，线路从 $1$ 至 $n$ 编号，现在给定你 $n$ 条线路的经过站点列表和在每个站点的每个深度的建站花费，请你求出让所有的地铁正常运行的最小建站花费总和。

## 说明/提示

### 样例 1 解释

$1$ 号线和 $2$ 号线都经过了站点 $1$，因此他们不能处于同一深度。   
令 $1$ 号线在深度 $2$ 运行，$2$ 号线在深度 $1$ 运行，则需要修建站点 $1$ 的深度 $1$ 、 $2$ 的上下客口（花费为 $4+4=8$），站点 $2$ 的深度为 $2$ 的上下客口（花费为 $1$），站点 $3$ 的深度为 $1$ 的上下客口（花费为 $1$），总花费为 $10$。可以证明，这是最优的方案。

### 数据规模与约定

本题共 $20$ 个测试点，每个测试点 $5$ 分。

- 对于 $5\%$ 的数据，保证 $n=1$。
- 对于 $35\%$ 的数据，保证 $n,m \le 6$。
- 对于 $70\%$ 的数据，保证 $n \le 10$。
- 对于 $100\%$ 的数据，保证 $1 \le n \le 14$，$1 \le m \le 10^5$，$1 \le a_{i,j} \le 10^9$，$1 \le c,u \le m$。

### 提示

本题共有两个附加样例文件，见附加文件中的 cold.zip。

(本来有个更大的样例，但是因为附件不让传这么大的，就被删掉了)


## 样例 #1

### 输入

```
2 3
4 1 1
4 1 5
2 1 2
2 1 3```

### 输出

```
10```

# 题解

## 作者：Durancer (赞：12)

### 前言

预处理巨多的状压好题

### 思路

~~我不会爆搜啊，太麻烦了~~。

直接将 $\text{DP}$ 怎么做。

首先需要很多的预处理：

1、处理在每一个深度 $j$ 建立某一个铁路线 $i$ 花费的价格 $\text{cost}_{i,j}$。

2、处理出铁路线 $i$ 和铁路线 $j$ 能否在同一个深度建立线路 $vis_{i,j}$。

3、处理出在深度为 $i$ 的时候，在这一层深度修建的铁路线的状态为 $S$ 价钱 $g_{i,S}$。

~~处理完这些就可以进行非常短的 $\text{DP}$ 过程了。~~

限制我们计算价钱的量为深度 $\text{dep}$ ，以及状态 $S$, 那么就考虑设置两维 $\text{DP}$。

设置 $f_{i,S}$ 已经弄完了前 $i$ 深度的铁路线，现在建立完的铁路线编号的状态为 $S$ 的最短价格。

既然我们预处理完了，那么很显然的状态转移就是：

$$f_{i,S}=\min_{s\in S} \{ f_{i-1,S\oplus s}+g_{i,s}\}$$

我们可以用枚举子集的方法避免暴力枚举状态判断。

奇怪的复杂度大约为 ：$O(n^2+2^{14}n^2+2^{14}+2^{14}n)$。(枚举子集的时间复杂度不会算/kk)

可以非常完美的通过此题。

### 代码实现

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<vector>
#include<algorithm>
#include<map>
using namespace std;
const int N=15;
const int M=1e5+9;
const int K=(1<<15);
const long long int INF=1e18+9;//要开大一点/cg 
int dep[N][M];//深度为 i 的地铁经过了地铁站 j ，的花费
int cnt[N];//表示第 i 条地铁经过的站点个数 
int sub[N][M];//第 i 条地铁经过的站点编号。
int n,m;
long long int f[N][K];//明显跟深度有关，所以就设前i深度，修建的铁路线状态为j的最小花费
long long int g[N][K];//在深度为i时，该层修建状态为j的花费 
long long int cost[N][N];//第i条铁路在深度为j修建时的花费 
bool vis[N][N];//询问第i条铁路和第j条铁路能否修建在一个道路上 
int stk[N],top;
int read()
{
	int f=1,x=0;
	char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=(x<<1)+(x<<3)+(s^'0');s=getchar();}
	return f*x;
} 
void Prepare()
{
	for(int i=1;i<=n;i++)
		sort(sub[i]+1,sub[i]+1+cnt[i]);//排序，便于查找 
	for(int i=1;i<=n;i++)
	{
		for(int j=i+1;j<=n;j++)
		{
			vis[i][j]=vis[j][i]=true;
			int x=1,y=1;//一种省时间的方法，序号排好之后，我们可以不断比较编号大小，慢慢递增寻找相同点
			while(x<=cnt[i] and y<=cnt[j])
			{
				if(sub[i][x]==sub[j][y])
				{
					vis[i][j]=vis[j][i]=false;	
					break;//不能在同一条线路上 
				}	
				if(sub[i][x]<sub[j][y]) x++;
				else if(sub[i][x]>sub[j][y]) y++;
			}
		}
	}
	for(int s=1;s<(1<<n);s++)//枚举所有状态 
	{
		top=0;
		for(int i=1;i<=n;i++)
			if(s&(1<<(i-1)))//有戏
			{
				stk[++top]=i;
				for(int j=1;j<top;j++)
					if(!vis[i][stk[j]])//看来没戏了/kk
					{
						for(int k=1;k<=n;k++)//把所有都变为极大值
							g[k][s]=INF;
					}
				if(f[1][s]==INF)//没救了，赋为极大值
					break;
				for(int j=1;j<=n;j++)
					g[j][s]+=cost[i][j];
				//深度为j时修建状态为s的铁路，加上第i条铁路在j深度修建时的总价钱。 
			}
	}
	for(int s=1;s<(1<<n);s++)
		f[1][s]=g[1][s];//初始化第一行 
	return;
}
int main()
{
	n=read();
	m=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++) 
			dep[i][j]=read();
	for(int i=1;i<=n;i++)
	{
		cnt[i]=read();//输入个数
		for(int j=1;j<=cnt[i];j++)
			sub[i][j]=read();
		for(int j=1;j<=n;j++)
			for(int k=1;k<=cnt[i];k++)
				cost[i][j]+=dep[j][sub[i][k]];
	}
	Prepare();
	for(int i=2;i<=n;i++)
	{
		for(int S=0;S<(1<<n);S++)
		{
			f[i][S]=f[i-1][S];//初始化,加入这个不选 
			for(int s=S;s;s=(s-1)&S)
				f[i][S]=min(f[i][S],f[i-1][S^s]+g[i][s]);
		}	
	} 
	cout<<f[n][(1<<n)-1]<<endl;
	return 0;
}
```


---

## 作者：一扶苏一 (赞：9)

### E

#### Algorithm 1

考虑枚举所有的情况，即每条线路经过哪一层，每条线路都有 $n$ 种可能，爆搜即可，时间复杂度 $O(n^n)$。这里省略了与 $m$ 有关的项。期望得分 $35$ 分。

#### Algorithm 2

注意到数据范围明示状压 dp。考虑设计状态：$f_{i, S}$ 表示考虑了放在深度为前 $i$ 层的地铁，已经考虑了集合 $S$ 中的所有路线的最小花费，转移显然：

$$f_{i, S} = \min_{s \subseteq S} f_{i - 1, s} + val(i, S - s)$$

其中 $s$ 是 $S$ 的子集，$val(S - s)$ 表示 $s$ 在 $S$ 中的补集中的元素都放到第 $i$ 层时的花费。$val$ 是可以预处理的。具体可以参考 std~~和将来会有的民间题解~~。

暴力枚举 $s$ 并判断 $s$ 是不是 $S$ 的子集来转移，共有 $O(n 2^n)$ 个状态，单次转移复杂度 $O(2^n)$，总复杂度 $O(n 4^n + m)$，期望得分 $70$ 分。

#### Algorithm 3

考虑优化算法二中的子集枚举方式。按照如下方式枚举子集显然可以精确枚举 $S$ 的每个子集而不会无用枚举：

```cpp
for (int s = S; s; s = (s - 1) & S) 
```

这样转移的复杂度就变成了 $O(2^k)$，其中 $k$ 表示 $S$ 二进制为 $1$ 的位数。考虑这样的时间复杂度为 $O(m + n \times \sum\limits_{k = 0}^n C_{n}^k \times 2^k)$。其中 $C_{n}^k$ 表示二进制共有 $k$ 位为 $1$ 的数的个数。根据二项式定理，$\sum\limits_{k = 0}^n C_{n}^k \times 2^k = \sum\limits_{k = 0}^n C_{n}^k \times 2^k \times 1^{n - k} = (2 + 1)^n = 3^n$，因此总复杂度为 $O(m + n \times 3^n)$。期望得分 $100$ 分。

值得注意的是，为了对标「NOIp2017 宝藏」的真实情况，本题没有加捆绑测试，也没有对着爆搜加剪枝卡（事实上数据量这么小根本就没法卡）。因此爆搜加剪枝可能可以获得比较可观的分数。

```cpp
#include <cctype>
#include <cstdio>
#include <algorithm>

typedef long long int ll;

const int maxn = 15;
const int maxm = 100005;
const int maxt = 1 << maxn;
const ll INF = 1000000000000000000ll;

template <typename T>
inline void qr(T &x) {
  char ch = getchar();
  while (!isdigit(ch)) ch = getchar();
  while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
}

int n, m, upc;
int a[maxn][maxm], b[maxn][maxm], tmp[maxn];
ll fee[maxn][maxn], g[maxn][maxt], f[maxn][maxt];
bool ac[maxn][maxn];

int main() {
  qr(n); qr(m);
  upc = 1 << n;
  for (int i = 0; i < n; ++i) {
    for (int j = 1; j <= m; ++j) {
      qr(a[i][j]);
    }
  }
  for (int i = 0; i < n; ++i) {
    qr(b[i][0]);
    for (int j = 1; j <= b[i][0]; ++j) {
      qr(b[i][j]);
    }
    std::sort(b[i] + 1, b[i] + 1 + b[i][0]);
    for (int j = 0; j < n; ++j) {
      for (int k = 1; k <= b[i][0]; ++k) {
        fee[i][j] += a[j][b[i][k]];
   //     printf("Aa%d %d %d %d %d %d\n", i, j, k, b[i][k], a[j][b[i][k]], fee[i][j]);
      }
  //    printf("ovO%d %d %d\n", i, j, fee[i][j]);
    }
  }
  
  for (int i = 0; i < n; ++i) {
    for (int j = i + 1; j < n; ++j) {
      ac[i][j] = ac[j][i] = true;
      int u = 1, v = 1;
      while ((u <= b[i][0]) && (v <= b[j][0])) {
        if (b[i][u] == b[j][v]) {
          ac[j][i] = ac[i][j] = false; break;
        }
        if (b[i][u] < b[j][v]) ++u;
        else ++v;
      }
    }
  }
  for (int s = 1; s < upc; ++s) {
    int cnt = 0;
    for (int i = 0; i < n; ++i) if (s & (1 << i)) {
      tmp[++cnt] = i;
      for (int j = 1; j < cnt; ++j) if (ac[tmp[j]][i] == false) {
        for (int k = 0; k < n; ++k) {
          g[k][s] = INF;
        }
        break;
      }
      if (g[0][s] == INF) break;
      for (int k = 0; k < n; ++k) {
        g[k][s] += fee[i][k];
      }
    }
  }
  for (int s = 1; s < upc; ++s) {
    f[0][s] = g[0][s];
  }
  for (int i = 1; i < n; ++i) {
    for (int s = 0; s < upc; ++s) {
      f[i][s] = f[i - 1][s];
      for (int t = s; t; t = (t - 1) & s) {
        f[i][s] = std::min(f[i][s], f[i - 1][s ^ t] + g[i][t]);
      }
     // printf("%d %d %lld\n", i, s, f[i][s]);
    }
  }
  printf("%lld\n", f[n - 1][upc - 1]);
}
```



---

## 作者：AuCloud (赞：3)

~~比完赛好几天了居然没人发题解~~

## 心路历程

首先考虑贪心，~~直觉+生活经验~~告诉我们越浅的越便宜，但是仔细看了一下题目，并没有说明；

于是问了出题人……

![](https://cdn.luogu.com.cn/upload/image_hosting/tlpptymy.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/8r97f1ih.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/e953yzts.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/uf4cf1l7.png)

好吧fAKe了……

于是再看一眼数据范围：n<=14

这不是赤裸裸的状压吗（

先看看部分分：

5分人口普查：只有一列车，枚举所在层数取min即可

35分无脑分：$O(N^N)$爆搜即可拿下$N<=6$的35pts

显然如果在爆搜过程中枚举经过的站点的话会T飞（大概

所以考虑预处理一个val数组,$val[i][j]$表示$j$车在$i$层的花费，一边读入一边处理就行

剩下的70分和100分其实**看起来**差别不太大，感觉都是状压一类

--------

5分的部分分只是用来验证我们读题是否正确的，对于解题没什么帮助（

考虑将35分的val数组推广，让第二维j表示的不仅仅是某个车而是某个状态

稍微想一下，貌似可行：

从$0$至$(1<<n)-1$枚举j，判断状态是否合法，若合法则$O(logN)$枚举j状态下哪些车被选中并加和；不合法则置为$inf$。

至于判断是否合法，在输入时将所有经过的车站压入bitset里，判断时把所有车拿出来$N^2$挨个取或，如果不为零则说明有重叠部分，不合法。

设$f[i][st]$表示前i层安放$st$状态的车辆的最小花费，再结合刚刚的val数组，转移方程就很容易列出来：

$ f[i][st] = min{f[i-1][k] + val[i][st-k]},(st | k = st) $

其中，$st|k=st$表示k状态是st状态的子集

## code#1

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
bitset<100001>y[20];
int z[20][20];
int f[20][1<<20];
int val[20][1<<20];
int W[20][100001];
bool pd(int st)//判断状态st是否合法
{
	int now = 1;
	int qwq[20];
	int tot = 0;
	while(st)
	{
		if(st & 1)
		{
			qwq[++tot] = now;//有当前的状态，记录
		}
		st >>= 1;
		now++;
	}
	for(int i = 1; i <= tot; i++)
	{
		for(int j = 1; j < i; j++)
		{
			bitset<100001> ls;
			ls = y[qwq[i]] & y[qwq[j]];
			if(ls.count()) return 1;//不合法
		}
	}
	return 0;
}
signed main()
{
	// freopen("cold.in", "r", stdin);
	memset(f, 0x3f, sizeof(f));
	int n, m;
	cin >> n >> m;
	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= m; j++)
		{
			cin >> W[i][j];
		}
	}
	for(int i = 1; i <= n; i++)
	{
		int x;
		cin >> x;
		for(int j = 1; j <= x; j++)
		{
			int qwq;
			cin >> qwq;
			y[i][qwq] = 1;
			for(int k = 1; k <= n; k++)
			{
				z[i][k] += W[k][qwq];
			}
		}
	}
	for(int i = 1; i <= n; i++)
	{
		for(int st = 0; st <= (1 << n) - 1; st++)
		{
			if(pd(st)) val[i][st] = 0x3fffffffffffffff;
			else
			{
				int qwq = st;
				int now = 1;
				while(qwq)
				{
					if(qwq & 1) val[i][st] += z[now][i];
					qwq >>= 1;
					now++;
				}
			}
		}
	}
	f[0][0] = 0;
	for(int i = 1; i <= n; i++)
	{
		for(int j = 0; j <= (1 << n) - 1; j++)
		{
			for(int s = 0; s <= (1 << n) - 1; s++)
			{
				if((j | s) != j) continue;
				f[i][j] = min(f[i][j], f[i - 1][s] + val[i][j - s]);
			}
		}
	}
	cout << f[n][(1 << n) - 1] << endl;
}
```
提交上去发现拿到了70分的好成绩，剩下的T了

然后发现我们在枚举j的子集转移时，是直接暴力$2^N$枚举，导致多枚举了很多没有用的状态

于是要考虑某些~~奇技淫巧~~更优秀的枚举方法：

```cpp
for(int s = j; s; s = j & (s - 1))
```

这样可以保证每个s都是j的子集并且不会多枚举其他的东西

于是优化掉了一个$2^N$，~~好耶~~

但是注意到一个问题：这个方法无法枚举到0，需要特判一下，否则无法更新答案

剩下的就是优化优化读入什么的就过了（

~~因为太懒就直接sync_with_stdio(false)了，结果成功跑到最优解倒数第一~~

## code#2

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
bitset<100001>y[20];
int z[20][20];
int f[20][1<<20];
int val[20][1<<20];
int W[20][100001];
bool pd(int st)
{
	int now = 1;
	int qwq[20];
	int tot = 0;
	while(st)
	{
		if(st & 1)
		{
			qwq[++tot] = now;
		}
		st >>= 1;
		now++;
	}
	for(int i = 1; i <= tot; i++)
	{
		for(int j = 1; j < i; j++)
		{
			bitset<100001> ls;
			ls = y[qwq[i]] & y[qwq[j]];
			if(ls.count()) return 1;
		}
	}
	return 0;
}
signed main()
{
	ios::sync_with_stdio(false);
	memset(f, 0x3f, sizeof(f));
	int n, m;
	cin >> n >> m;
	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= m; j++)
		{
			cin >> W[i][j];
		}
	}
	for(int i = 1; i <= n; i++)
	{
		int x;
		cin >> x;
		for(int j = 1; j <= x; j++)
		{
			int qwq;
			cin >> qwq;
			y[i][qwq] = 1;
			for(int k = 1; k <= n; k++)
			{
				z[i][k] += W[k][qwq];
			}
		}
	}
	for(int i = 1; i <= n; i++)
	{
		for(int st = 0; st <= (1 << n) - 1; st++)
		{
			if(pd(st)) val[i][st] = 0x3fffffffffffffff;
			else
			{
				int qwq = st;
				int now = 1;
				while(qwq)
				{
					if(qwq & 1) val[i][st] += z[now][i];
					qwq >>= 1;
					now++;
				}
			}
		}
	}
	f[0][0] = 0;
	for(int i = 1; i <= n; i++)
	{
		for(int j = 0; j <= (1 << n) - 1; j++)
		{
			for(int s = j; s; s = j & (s - 1))
			{
				f[i][j] = min(f[i][j], f[i - 1][s] + val[i][j - s]);
			}
			int s = 0;
			f[i][j] = min(f[i][j], f[i - 1][s] + val[i][j - s]);
		}
	}
	cout << f[n][(1 << n) - 1] << endl;
	return 0;
}

```

---

## 作者：Kisaragi_Nanami (赞：2)

**update**

修复了部分笔误。


------------


提供一种相对好写且常数较小的实现方式。

本题和 [NOIP2017 宝藏](https://www.luogu.com.cn/problem/P3959) 很像，但宝藏是求一棵生成树，而本题题面中「深度」与「高度」混用且没有具体描述，让笔者误认为求的就是生成树，WA 了将近一页。

回到题目本身，从整体上看，我们要将 $n$ 条线路划分进 $n$ 个深度集合，使得代价最小，限制是存在部分线路不能被划分到同一深度集合，**允许空集**。

$n \le 14$，考虑状压 $n$。

设 $U$ 为全集，$f(i,S)$ 为考虑深度为 $[1,i] \cap \mathbb{Z}$ 的深度集合，划分完集合 $S$ 内的线路的最小代价，$ok(S)$ 表示 $S$ 能否被划分到同一集合，有

$$
f(i,S) = \min_{S_0 \subseteq U - S \text{ and } ok(S_0) }\Big\{ f(i-1,S-S_0) + d(i,S_0) \Big\}
$$


关键是如何处理 $d(i,S)$ 与 $ok(S)$。

对于每个深度集合 $i$，暴力处理 $|S|=1$ 的情况，复杂度 $O(n^2m)$，可以接受。对于更大的 $S$，使用 $\operatorname{lowbit}$ 运算递推即可，这部分是 $O(n2^n)$。

对于 $ok(S)$，可以考虑这样一个事实：线路 $j$ 包含站点 $x$，那么就可以以此判掉所有含有 $x$ 的线路，进而能在 $O(n^2m)$  的时间里处理二元关系 $valid(i,j)$ 表示 $i$ 与 $j$ 能否被划分到同一深度集合中。

当 $|S|=1$ 时，$ok(S)=1$。对于更大的 $S$，对 $\operatorname{lowbit}(S)$ 对应的点判断其他点是否合法，利用 $valid$ 即可。这部分是 $O(n2^n)$，枚举其他点的过程也使用 $\operatorname{lowbit}$ 运算，可以带上一个 $\frac{1}{2}$ 的常数。

上述过程也可以进行合并，从而降低一点点常数。

具体细节见代码。

```cpp
// Problem: P7098 [yLOI2020] 凉凉
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P7098
// Author: KisaragiQwQ
// Date: 2023-06-19 08:47:18
// Memory Limit: 256 MB
// Time Limit: 1000 ms
// 
// Let's Daze
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
	int a=0, f=1; char c=getchar();
	while(!isdigit(c)) {
		if(c=='-') f=-1;
		c=getchar();
	}
	while(isdigit(c)) a=a*10+c-'0', c=getchar();
	return a*f;
}
const int N=20, M=1e5+5;
int n, m, U, a[N][M], d[N][1<<14], lg[1<<14];
bool valid[N][N], o[N][M], ok[1<<14];
int f[N][1<<14];
int lowbit(int x) { return x&-x; }
int dfs(int x,int S) {
	if(f[x][S]) return f[x][S];
	int& res=f[x][S];
	res=1e15;
	if(S==U) return res=0;
	if(x==n) return 1e15;
	int T=U^S;
	res=min(res,dfs(x+1,S));
    // 允许空集
	for(int S0=T;S0;S0=(S0-1)&T) if(ok[S0]) {
		res=min(res,d[x+1][S0]+dfs(x+1,S|S0));
	}
	return res;
}
signed main() {
	n=read(), m=read();
	U=(1<<n)-1;
	rep(i,1,n) rep(j,1,m) a[i][j]=read();
	rep(i,0,n-1) {
		int c=read();
		while(c--) {
			int x=read();
			o[i][x]=1;
			rep(j,1,n) {
				d[j][1<<i]+=a[j][x];
				if(i!=j-1&&o[j-1][x]) valid[i][j-1]=valid[j-1][i]=1;
			}
		}
		ok[1<<i]=1;
		lg[1<<i]=i;
	}
	ok[0]=1;
	for(int S=1;S<=U;++S) {
		int i=lg[lowbit(S)], can=1;
		if(!ok[S^lowbit(S)]) { ok[S]=0; continue; }
		for(int S0=S^lowbit(S);S0;S0-=lowbit(S0)) {
			int j=lg[lowbit(S0)];
			if(valid[i][j]) { can=0; break; }
		}
		if(can) ok[S]=1; else ok[S]=0;
	}
	for(int S=1;S<=U;++S) rep(i,1,n) {
		d[i][S]=d[i][S^lowbit(S)]+d[i][lowbit(S)];
	}
	printf("%lld\n",dfs(0,0));
    // 第一层也可以是多条线路，不要和宝藏搞混了
	return 0;
}
```



---

## 作者：MeowScore (赞：2)

看一下数据范围就可以考虑状压了。一道好题，不算很难，耐心推一推还是好做的。（最终的 dp 转移就十几行，但是预处理巨多无比！）

这个 $n$ 很小，考虑状压，即考虑一个状态集合内部的所有线路都运行的最小代价。但是这样还是不好转移，因为线路深度也是很重要的一个因素，我们把这一要素也设到状态中：$f_{S,j}$ 表示集合 $S$ 内的所有线路在深度不超过 $j$ 的情况下运行的最小花费。转移很自然（枚举一个子集，使这个子集中的线路在更浅的地方运行，补集在当前深度运行）：

$$
f_{S,j}=\min_{s\subseteq S,can_{\complement_Ss}}(f_{s,j-1}+v_{\complement_Ss,j})
$$

最终答案为 $f_{2^n-1,n}$。

定义 $v_{S,j}$ 指集合 $S$ 中所有线路都在深度 $j$ 运行的花费。$can_{S}$ 记录集合 $S$ 中的所有线路能否在同一深度运行。这两个东西可以预处理。

考虑 $v$ 的计算。由于每条线路途径的点数可以很多，我们枚举所有集合，然后枚举集合中的每条线路，再枚举每条线路经过的点是不现实的。我们考虑再预处理一个 $cost_{i,j}$，表示线路 $i$ 在深度 $j$ 运行的花费，这个十分容易。同时 $v$ 的计算中省掉了枚举途径点的过程，这样就很高效了。计算 $cost$ 是 $O(n^2m)$ 的，计算 $v$ 是 $O(2^n n^2)$ 的。

再考虑 $can$ 的预处理。给我们若干线路，判断有/无交，并不好直接做。但是我们发现：这些线路两两无交，等价于放在一起无交。对于一个集合，两两枚举其包含的线路，查看是否有交即可，都无交则无交。那么怎么判断两个线路是否有交？预处理 $valid_{i,j}$ 表示 $i$ 和 $j$ 线路可以在同一深度运行，这个借助桶可以在 $O(n^2m)$ 的时间中计算出来。然后 $can$ 就可以 $2^nn^2$ 求出了。

唔，好麻烦的预处理到此就结束了！

还有就是 $f$ 要初始化为 $\inf$。$f_{0,i}$ 要初始为 $0$。

就这样了，放个代码吧 qwq。

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=15,M=100010;
int a[N][M];//a[i][j]:深度为i经过j站点的费用 
int cost[N][N];//cost[i][j]:第i条线路在深度j运行的费用
int f[1<<N][N];//f[i][j]:状态为i的线路在小于等于j的深度运行的费用
int n,m;
bool valid[N][N];//valid[i][j]:i和j线路能否在同一深度运行
bool can[1<<N];//can[i]:状态为i的线路能否在同一深度运行 
int p[N][M],sz[N];
bool bin[M];
int stk[N],top;
int v[1<<N][N];//v[i][j]:状态为i的线路在深度j运行的费用 
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	for(int i=1;i<=n;i++){
		cin>>sz[i];
		for(int j=1;j<=sz[i];j++)
			cin>>p[i][j];
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=sz[i];j++)
			bin[p[i][j]]=1;
		for(int j=i+1;j<=n;j++){
			valid[i][j]=valid[j][i]=1;
			for(int k=1;k<=sz[j];k++){
				if(bin[p[j][k]]){
					valid[i][j]=valid[j][i]=0;
					break;
				}
			}
		}
		for(int j=1;j<=sz[i];j++)
			bin[p[i][j]]=0;
	}
	for(int i=0;i<(1<<n);i++){
		can[i]=1;
		top=0;
		for(int j=0;j<n;j++){
			if((i>>j)&1){
				top++;
				stk[top]=j+1;
			}
		}
		for(int j=1;j<=top;j++){
			if(!can[i])
				break;
			for(int k=j+1;k<=top;k++){
				if(!can[i])
					break;
				if(!valid[stk[j]][stk[k]])
					can[i]=0;
			}
		}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			for(int k=1;k<=sz[i];k++)
				cost[i][j]+=a[j][p[i][k]];
	for(int i=1;i<(1<<n);i++)
		for(int j=1;j<=n;j++)
			for(int k=0;k<n;k++)
				if((i>>k)&1)
					v[i][j]+=cost[k+1][j];
	memset(f,0x3f,sizeof(f));
	for(int i=0;i<=n;i++)
		f[0][i]=0;
	for(int S=1;S<(1<<n);S++){
		for(int j=1;j<=n;j++){
			for(int s=S;;s=((s-1)&S)){//枚举子集，状压题常规技巧 
				int x=S^s;
				if(!can[x]){
					if(!s)
						break;
					continue;
				}
				f[S][j]=min(f[S][j],f[s][j-1]+v[x][j]);
				if(!s)
					break;
			}
		}
	}
	cout<<f[(1<<n)-1][n];
	return 0;
}
```

---

## 作者：破忆 (赞：2)

[P7098 [yLOI2020] 凉凉](https://www.luogu.com.cn/problem/P7098)

考前复习状压DP。

## 【题意】

地下有 $n$ 层，需要建设 $n$ 条线路，一条线路只能在一个深度，每条线路会经过若干站点，共有 $m$ 个站点，在第 $i$ 层经过站点 $j$ 需要代价 $a_{i,j}$， 经过同一个站点的两条线路不能在同一层，求最小代价。

## 【分析】

注意到 $n \leqslant 14$，考虑状压DP。

### 设计状态

定义 $f_{i,S}$ 表示前 $i$ 层，已建设的线路状态为 $S$ 的最小代价。

### 考虑转移

转移就是 $f_{i,S}=\min(f_{i-1,S-T}+V_T),T \subseteq S$。

$T$ 是在第 $i$ 层建的线路集合，$V_T$ 即相应的代价。

复杂度 $O(n\cdot3^n)$。

### 计算 $V_S$

首先要知道 $S$ 这个状态在同一层是否合法。

如果合法，对于每一层，对需要的站点的代价求和即可。

复杂度 $O( 2^n\cdot n^2)$。

### 判断 $S$ 的合法性

$S$ 合法，即 $S$ 中的任意两条线路都不冲突。

枚举两条线路，再枚举站点，逐一判断（这里似乎可以用bitset优化常数）。

复杂度 $O(n^2\cdot m)$。

再枚举 $S$，枚举 $S$ 中的两条线路。
复杂度 $O(2^n\cdot n^2)$。

------------

每一部分的复杂度都是合理的。

根据以上思路即可通过此题。

## 【解法】

状压DP

## 【代码】

```cpp
#include<bits/stdc++.h>
using namespace std;
char gc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
#define getchar gc
int read(){
    int ret=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
    while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
    return ret*f;
}
#define LL long long
const int maxn=16,maxm=1e5+5,maxs=(1<<14)+5;
const LL INF=1ll<<62;
int n,m;
LL a[maxn][maxm],v[maxs],c[maxn][maxn],f[maxn][maxs];
bool p[maxn][maxm],pe[maxn][maxn],vis[maxs];
int s[maxs];
int cnt(int S){
	int ret=0;
	while(S) S-=S&-S,ret++;
	return ret; 
}
bool check(int i,int j){
	for(int k=1;k<=m;k++) if(p[i][k]&p[j][k]) return 0;
	return 1;
}
int main(){
	#ifndef ONLINE_JUDGE
	freopen("P7098.in","r",stdin);
	freopen("P7098.out","w",stdout);
	#endif
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++) a[i][j]=read();
	for(int i=0;i<n;i++){
		int z=read();
		while(z--){
			int x=read();
			for(int j=1;j<=n;j++) c[j][i]+=a[j][x];
			p[i][x]=1;
		}
		vis[1<<i]=1;
	}
	for(int i=0;i<n;i++)
	for(int j=i+1;j<n;j++) pe[i][j]=check(i,j);
	for(int S=3,eS=1<<n;S<eS;S++) if(!vis[S]){
		vis[S]=1;
		for(int j=0;j<n&&vis[S];j++) if((S>>j)&1)
		for(int k=j+1;k<n&&vis[S];k++) if((S>>k)&1) vis[S]&=pe[j][k]; 
	}
	for(int S=1,eS=1<<n;S<eS;S++) f[0][S]=INF;
	for(int i=1;i<=n;i++){
		for(int S=1,eS=1<<n;S<eS;S++) if(vis[S]){
			v[S]=0;
			for(int j=0;j<n;j++) if((S>>j)&1) v[S]+=c[i][j];
		}
		for(int S=0,eS=1<<n;S<eS;S++){
			f[i][S]=f[i-1][S];
			for(int T=S;T;T=S&(T-1)) if(vis[T]) f[i][S]=min(f[i][S],f[i-1][S^T]+v[T]);
		}
	}
	printf("%lld\n",f[n][(1<<n)-1]);
	return 0;
}
```


---

## 作者：Conless (赞：2)

终于写完今年 yLOI 了 qwq

~~银临女神支持我写题~~

这题看到数据范围 $n\le 14$ 明示状压，但是状压状态却相对难分析一点，因为在思考爆搜策略时，我们会发现，不仅仅需要关心某一条线路或者某一个深度是否被选择，同样也要关心哪条线路选择了哪个深度，以便于不同线路之间**合并**的进行。

然而，我们不妨考虑对阻碍状压的因素：合并，进行预处理，将全部可以合并的线路（即放在同一层不会发生冲突）提前合并，那么就变成了两个分别处理的基础状压 $dp$ 问题了。

合并的思路：

令 $d_{i,set}$ 表示 $set$ 集合内的所有列车放在第 $i$ 层所需的费用，容易得到状压策略：

若新加入的列车 $j$ 与原集合 $set$ 不冲突，即可进行状态转移：

 $d_{i,set\bigcup\{j\}}=min\{d_{i,set\bigcup\{j\}},d_{i,set}+sum_{j,i}\}$
 
状压 $dp$ 的思路：

令 $f_{i,set}$ 表示 $set$ 集合内所有列车放在前 $i$ 层所需的费用，那么我们就可以直接枚举子集来做了：

对于第$i$层每个可选的列车集合 $j$，枚举它的子集 $k$，令 $l=\complement_jk$，则可以进行状态转移：

$f_{i,j} = min\{f_{i,j}, f_{i-1,l} + d[i][k]\}$

最后$ans=f_{i,U}$

当然，由于状压 $dp$ 中 $4^n$ 的复杂度仍然无法接受，所以还要用个枚举子集的 trick

```cpp
for (int k = j; k; k = j & (k - 1))
```

这样时间复杂度就会降为 $n \times \Sigma_{i=0}^{n} C_n^i\times 2^i\times 1^{n-i}=n\times 3^n$ 了

完整代码：

（记得开long long）

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

typedef long long ll;

const int MAXN = 16;
const int MAXS = 1 << 16;
const int MAXM = 1e5 + 5;

int n, m;
int siz[MAXN];
bitset<MAXM> sta[MAXN];
int price[MAXN][MAXM], data[MAXN][MAXM];

// sum[i][j] refer to the price of constructing all the stations for train j at the height i
int sum[MAXN][MAXN];
// d[i][j] refer to the price of constructing all the stations for trains in set(j) at the height i
int d[MAXN][MAXS];
// f[i][j] refer to the price of constructing all the stations for trains in set(j) beyond or at height i
int f[MAXN][MAXS];

signed main()
{
    memset(d, 0x3f, sizeof(d));
    memset(f, 0x3f, sizeof(f));
    scanf("%lld%lld", &n, &m);
    for (int i = 1; i <= n; i++)
    {
        d[i][0] = 0;
        for (int j = 1; j <= m; j++)
            scanf("%lld", &price[i][j]);
    }
    for (int i = 0; i < n; i++)
    {
        scanf("%lld", &siz[i]);
        for (int j = 1; j <= siz[i]; j++)
        {
            scanf("%lld", &data[i][j]);
            sta[i].set(data[i][j]);
        }
        for (int j = 1; j <= n; j++)
        {
            for (int k = 1; k <= siz[i]; k++)
                sum[j][i] += price[j][data[i][k]];
        }
    }
    int maxt = 1 << n;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 0; j < maxt; j++)
        {
            if (d[i][j] > 1e15)
                continue;
            bitset<MAXM> now;
            now.reset();
            for (int k = 0; k < n; k++)
                if ((j >> k) & 1)
                    now |= sta[k];
            for (int k = 0; k < n; k++)
            {
                if (!((j >> k) & 1) && !(now & sta[k]).count())
                {
                    int nex = j | (1 << k);
                    d[i][nex] = min(d[i][nex], d[i][j] + sum[i][k]);
                }
            }
        }
    }
    f[0][0] = 0;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 0; j < maxt; j++)
        {
            f[i][j] = f[i - 1][j];
            for (int k = j; k; k = j & (k - 1))
            {
                int res = j ^ k;
                f[i][j] = min(f[i][j], f[i - 1][res] + d[i][k]);
            }
        }
    }
    printf("%lld", f[n][maxt - 1]);
    return 0;
}
```

---

## 作者：ABookCD (赞：1)

#### P7098 [yLOI2020] 凉凉 题解

提供一种相对比较暴力的思路直接的解法。

最终的结果一定形如将线路分成若干组，每一组占据一层的情况。

我们可以先预处理出每一组 $s$ 能否使用同一层 $ava_{s}$ 和占用第 $i$ 层的费用 $cost_{s,i}$。

我们用一个 std::bitset 记录没一个地铁经过的站点，每次枚举集合 $s$，将 bitset 合并，判断有无交集，若无，那么可以使用同一层，在枚举每一层将每一辆车的贡献加起来。

在预处理这两个数组之前，我们还需要与处理一下每一个地铁 $i$ 在第 $j$ 层设置站台的花费和。

以上过程时间复杂度 $O(2^n n+2^n\frac{m}{w})$。

然后我们就可以开始 DP，令 $dp[i][s]$ 表示已经选的集合为 $s$，已经枚举了前 $i$ 层的最小答案，对于每一层，我们枚举子集暴力转移即可。

总时间复杂度：$O(3^n n+2^n\frac{m}{w})$。

显然不是最好的做法，不过能过。



---


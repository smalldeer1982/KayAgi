# [COCI 2020/2021 #3] Selotejp

## 题目背景

在 Mirko 看来，没有比找到一卷新的胶带纸要更令人快乐，而今天他格外开心，因为他找到 Slavko 的基督日历。

## 题目描述

基督日历可以被一个 $n$ 行 $m$ 列的表格所表示。每个方格包含一个小窗口，而每个小窗口后有一块巧克力。Slavko 已经打开了部分窗口，而其他的处于关闭状态。

Mirko 打算用他的胶带纸去把所有的窗口粘贴，使它们处于关闭状态。胶带纸长度无限大，并且宽度与一个窗口吻合。Mirko 可以撕下一部分胶带纸来将 **一横排或一纵列连续的窗口** 合上，使其关闭。他不想放太多胶带纸，因为他仍旧想做 Slavko 的朋友。

他想知道将**所有**窗口都关闭所需的**最少**胶带纸的数量。

## 说明/提示

**【样例解释 #1】**

一种符合题意的方案：分别在第一列整列、第三列整列和第二行第二列处使用胶带纸。

**【数据范围】**

| Subtask | 分值 | 数据范围及约定 |
| :----------: | :----------: | :----------: |
| $1$ | $35$ | 每个窗口与至多两个已关闭的窗口相邻 |
| $2$ | $35$ | $1 \le n \le 10$ |
| $3$ | $40$ | 无 |

对于 $100\%$ 的数据，$1 \le n \le 1000$，$1 \le m \le 10$。

**【说明】**

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2020-2021](https://hsin.hr/coci/) [CONTEST #3](https://hsin.hr/coci/contest3_tasks.pdf)  _T4 Selotejp_。**

## 样例 #1

### 输入

```
2 3
#.#
###```

### 输出

```
3```

## 样例 #2

### 输入

```
4 3
.#.
###
.##
.#.```

### 输出

```
3```

## 样例 #3

### 输入

```
4 4
####
#.#.
#.##
####```

### 输出

```
5```

# 题解

## 作者：Figo17 (赞：4)

# P7171 题解

2021.10.29 修改了一些语言表述问题。

## 题意：

有 $n\times m$ 个格子，一些是"#"，一些是"."，每次可以将连续个"#"涂色，不可重复涂色，求最少涂抹次数。

## 分析：

一道经典的 dp 问题，考虑普通状压转移过于复杂，还会超时，所以使用[轮廓线 dp](http://oi-wiki.com/dp/plug/)。

我们设 $dp_{i,j,k}$ 为在扫描前 i 行第 j 个元素时，前 m 个数的二进制状态（0 为横着涂，1 为竖着涂，不可涂色部分默认为 0）为 k 时的答案贡献。

（此时二进制状态从低位到高位应分别对应前 m 的数、前 m-1 的数等等，以此类推）

（对于“前 i 的数”的顺序的定义，可以理解为矩阵一般的搜索顺序）

## 解决：

确定状态后，我们考虑该如何转移。

对于当前所找的元素，如果为"#"，则 $dp_{i,j+1,k>>1}$（即下个元素横着涂）可由 $dp_{i,j,k}$（若未超界且当前元素为横）或 $dp_{i,j,k}+1$（若未超界且当前元素为竖）转移过去；

以此类推，$dp_{i,j+1,(k>>1)+(1<<m-1)}$（即下个元素竖着涂）也可以这样转移。

如果当前元素为"."，则直接转移贡献即可。

（可能有点难读懂，那就展现读者强大的阅读能力吧！）

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[1005][15][2050];
int n,m,M;
char c[1005][15];
int ans;
int maxn=1000000007;
int main()
{
	cin>>n>>m;M=1<<m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>c[i][j];
	
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			for(int k=0;k<M;k++)
				dp[i][j][k]=maxn;
	
	if(c[1][1]=='#') dp[1][1][0]=dp[1][1][1<<m-1]=1;
	else dp[1][1][0]=0;
	
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			for(int k=0;k<M;k++)
			{
				if(dp[i][j][k]>=maxn) continue;
				int nj=j%m+1,ni=i;
				if(j==m) ni=i+1;
				if(c[ni][nj]=='#')
				{
					if(nj>1&&!(k&1<<m-1)&&c[i][j]=='#') dp[ni][nj][k>>1]=min(dp[ni][nj][k>>1],dp[i][j][k]);
					else dp[ni][nj][k>>1]=min(dp[ni][nj][k>>1],dp[i][j][k]+1);
					if(ni>1&&(k&1)&&c[ni-1][nj]=='#') dp[ni][nj][(k>>1)+(1<<m-1)]=min(dp[ni][nj][(k>>1)+(1<<m-1)],dp[i][j][k]);
					else dp[ni][nj][(k>>1)+(1<<m-1)]=min(dp[ni][nj][(k>>1)+(1<<m-1)],dp[i][j][k]+1);
				}
				else dp[ni][nj][k>>1]=min(dp[ni][nj][k>>1],dp[i][j][k]);
			}
	
	ans=maxn;
	for(int i=0;i<M;i++)
		ans=min(ans,dp[n][m][i]);

	cout<<ans;
	return 0;
}
```

朴素~~~~奇丑~~~~的代码。

## 谢谢观看！！

---

## 作者：_zexal_ (赞：4)

看到 $m\leq8$，又注意到只和左右，上下有关，考虑轮廓线 dp 解决本题，建议评紫，如果没做过这种题的话，建议先解决这道[例题](https://www.luogu.com.cn/problem/UVA11270)。

我们不妨定义 $f_{i,j,S}$ 表示在第 $i$ 行，第 $j$ 列的点，他的轮廓线状态为 $S$，$S$ 的第 $i$ 位是 $1$ 则表示他从竖着涂。形象的讲，就是一个类似这样的图。![](https://s1.ax1x.com/2023/07/14/pC43GQI.png)

状态定义了，我们接下来考虑如何转移的顺序，无非只有两种，横着涂和竖着涂两种走法。不过，我们还需要钦定一个顺序，也就是，我们如何确定一个横竖涂从哪里发起呢？这里我使用从最上方和最左边记录。

#### 解决
考虑如何转移，我们枚举 $S_1$ 表示轮廓线的状态，如果 $S_1$ 的第 $j$ 位为 $1$,则说明 $f_{i-1,j,S_1}$ 可以转移到当前状态，否则，说明上面没有发起竖涂，此时，我们可以选择从左边转移，从我们的 $f_{i,j-1,S1}$ 转移，或者在这个位置另起新的一次竖涂法。

#### Code
稍微压了一下维。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define F(i,a,b) for(int i=a;i<b;i++)
const int inf = INT_MAX;
vector<int> dp(1 << 12, inf), f(1 << 12);
int n, m, ans = INT_MAX;
char a[1 << 12][15];
signed main() {
    cin >> n >> m;
    F(i, 0, n) F(j, 0, m) cin >> a[i][j];
    dp[0] = 0;
    F(i, 0, n) {
        F(j, 0, m) {
            F(k, 0, (1 << m)) {
                if (k & (1 << j)) { //当前位要从上面转移
                    if (a[i][j] == '.') { //不能涂
                        f[k] = inf;
                    } else {
                        f[k] = min(dp[k], dp[k ^ (1 << j)] + 1); //上一位集成，或者上位没涂，自己发起涂
                    }
                } else {
                    f[k] = min(dp[k], dp[k ^ (1 << j)]); //从左边转移，或则上一位涂下来

                    if (a[i][j] == '#' && (j == 0 || (k & (1 << (j - 1))) || a[i][j - 1] == '.'))
                        f[k]++;//如果是有障碍或 这是开头，必须有自己发起，或左边是上涂，左边是点
                }

            }
            dp = f;
        }
    }
    F(i, 0, (1 << m)) ans = min(ans, dp[i]);
    cout << ans;
    return 0;
}
```


---

## 作者：cff_0102 (赞：3)

注意一个题意理解上的问题：每一个窗口只能被一个胶带纸贴着，比如下面这份输入数据：

```text
5 5
.#.#.
#####
.#.#.
#####
.#.#.
```

Mirko 显然可以用四个胶带全部贴上，但是因为他只能“将一横排或一纵列连续的窗口合上”，而被贴过的窗口已经是合上的，所以在贴新胶带的时候变成不连续的了，因此应该输出 $8$ 而不是 $4$。

用记忆化搜索做的轮廓线 dp，设 $dp_{i,j,S}$ 为考虑到第 $i$ 行第 $j$ 列，前面的 $m$ 个空是否选择竖着涂的状态是 $S$，剩下最少需要几个胶带。具体的思路已经在注释里了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,M;
int b[1005][15];
int dp[1005][15][2000];
int nxti(int i,int j){
	if(j<m)return i;
	return i+1;
}
int nxtj(int i,int j){
	if(j<m)return j+1;
	return 1;
}
int lsti(int i,int j){
	if(j>1)return i;
	return i-1;
}
int lstj(int i,int j){
	if(j>1)return j-1;
	return m;
}
int dfs(int i,int j,int S){//考虑到第 i 行第 j 列，前面的 m 个空竖着涂的状态是 S，剩下最少要几个胶带
	S&=M;
	if(i>n)return 0;
	if(dp[i][j][S]!=-1)return dp[i][j][S];
	int ans=114514;
	int ni=nxti(i,j),nj=nxtj(i,j);
	int li=lsti(i,j),lj=lstj(i,j);
	if(!b[i][j])return dp[i][j][S]=dfs(ni,nj,S<<1);
	//先看能不能竖着涂 
	//如果上面有竖着涂的，可以选择继续竖着涂
	if(S&(1<<(m-1)))ans=min(ans,dfs(ni,nj,(S<<1)|1));
	//如果上面没有竖着涂的，可以自己开始竖着涂
	else ans=min(ans,1+dfs(ni,nj,(S<<1)|1));
	//再看能不能横着涂，要看前一个有没有选择横着涂 
	if(i!=li)ans=min(ans,1+dfs(ni,nj,S<<1));//如果是一行开头左边啥都没有只能新开一个横着涂
	else if(b[li][lj]&&(S&1)==0)ans=min(ans,dfs(ni,nj,S<<1));//前一个需要涂但没有竖着涂，那就是横着的了
	else ans=min(ans,1+dfs(ni,nj,S<<1));//不能接到左边，只能自己开始横着涂 
	return dp[i][j][S]=ans; 
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>n>>m;
	M=(1<<m)-1;
	for(int i=0;i<=n;i++){
		for(int j=0;j<(1<<m);j++){
			for(int k=0;k<=m;k++)dp[i][k][j]=-1;
		}
	}
	for(int i=1;i<=n;i++){
		string s;cin>>s;
		for(int j=0;j<m;j++){
			if(s[j]=='#'){
				b[i][j+1]=1;
			}
		}
	}
	cout<<dfs(1,1,0);
	return 0;
}
```

---

## 作者：_Cheems (赞：2)

闲话：为啥题解区清一色的轮廓线 dp？感觉怪怪的捏。

注意题意：一个格子必须**恰被覆盖一次**。

直接记 $f_{i,S}$ 表示考虑前 $i$ 行，其中第 $i$ 行中 $S$ 位置集合上有列方向的贴纸。

转移分三步走，一是继承上一行的贴纸，也就是超集取 $\min$，子集卷积（俗称 sos dp）即可。然后是在本行新增一些列贴纸，枚举下一个新增位置即可。最后是本行使用行贴纸贴上空位，即连续段个数。

$O(nm2^m)$。
#### 代码
把字符翻转了看的舒服点。
```cpp
#include<bits/stdc++.h>
using namespace std;

#define MIN(a, b) a = min(a, b)
const int M = 1e3 + 5, N = 15;
int n, m, f[1 << N], g[1 << N], h[1 << N], sit[M], val[M][1 << N], inf;
char c[N];

signed main(){
	scanf("%d%d", &n, &m);
	for(int i = 0; i < n; ++i){
		scanf("%s", c);
		for(int j = 0; j < m; ++j) c[j] = (c[j] == '#' ? '.' : '#');
		for(int j = 0; j < m; ++j) if(c[j] == '#') sit[i] += (1 << j);
		for(int S = 0; S < 1 << m; ++S)
			for(int j = 0; j < m; ++j)
				if((c[j] == '.' && (!((S >> j) & 1))) && (j == 0 || (c[j - 1] == '#' || ((S >> (j - 1)) & 1)))) ++val[i][S];
	}
	memset(f, 0x3f, sizeof f), inf = f[0];
	f[0] = 0;
	for(int i = 0; i < n; ++i){
		for(int S = 0; S < 1 << m; ++S) g[((1 << m) - 1) ^ S] = f[S];
		memset(f, 0x3f, sizeof f);
		for(int i = 0; i < m; ++i)
			for(int S = 0; S < 1 << m; ++S)
				if((S >> i) & 1) MIN(g[S], g[S ^ (1 << i)]);
		for(int S = 0; S < 1 << m; ++S)
			f[S] = g[((1 << m) - 1) ^ S];
		for(int S = 0; S < 1 << m; ++S)
			for(int j = 0; j < m; ++j)
				if(!((S >> j) & 1))
					MIN(f[S | (1 << j)], f[S] + 1);
		for(int S = 0; S < 1 << m; ++S)
			if(!(S & sit[i])) f[S] += val[i][S];
			else f[S] = inf;
	}
	int ans = inf;
	for(int S = 0; S < 1 << m; ++S) MIN(ans, f[S]);
	cout << ans; 
	return 0;
}
```

---

## 作者：zhangxy__hp (赞：2)

注：题解中 $\operatorname{lsh}$，$\operatorname{rsh}$，$\operatorname{or}$ 分别表示按位左移、按位右移、按位或，即 c++ 语言中的 `<<`，`>>`，`|`。

我也是打上轮廓线 DP 了。

设 $f_{x,y,S}$ 表示当前在 $(x,y)$ 格子，前 $m$ 个格子的状态为 $S$ 时的最小花费。

这里的状态是指，这一格竖着覆盖为 $1$，横着覆盖或本来就不用覆盖为 $0$。

这里的前 $m$ 个格子如下图所示，假设 $m=4$，当前在 $(2,2)$，方格内的数表示在 $S$ 中从低到高的下标（从 $0$ 开始）：

![](https://cdn.luogu.com.cn/upload/image_hosting/4nmsdxhb.png)

它就是一个逐行遍历矩阵的顺序，注意是包括 $(x,y)$ 这一格的。

为什么要这样记录呢，因为存在竖着覆盖，如刚才的例子，$(2,2)$ 的下一个为 $(2,3)$，它的上面是 $(1,3)$，刚好被记录了状态。

于是转移其实不难想：

- 下一位 $(nx,ny)$ 为 `#`
  - 横着覆盖，判断左边有没有点，且这个点是不是横着覆盖的，即 $f_{nx,ny,S\operatorname{rsh}1}$ 从 $f_{x,y,S}$ 或 $f_{x,y,S}+1$ 转移。
  - 竖着覆盖，判断上面的点是不是竖着覆盖的，即 $f_{nx,ny,(S\operatorname{rsh}1)\operatorname{or}(1\operatorname{lsh}(m-1))}$ 从 $f_{x,y,S}$ 或 $f_{x,y,S}+1$ 转移。
- 下一位为 `.`，直接让 $f_{nx,ny,S\operatorname{rsh}1}$ 从 $f_{x,y,S}$ 转移。

复杂度 $O(nm2^m)$。
```cpp
#include<bits/stdc++.h>
#define ll long long
#define il inline
#define read(x){\
	char ch;\
	int fu=1;\
	while(!isdigit(ch=getchar()))\
		fu-=(ch=='-')<<1;\
	x=ch&15;\
	while(isdigit(ch=getchar()))\
		x=(x<<1)+(x<<3)+(ch&15);\
	x*=fu;\
}

using namespace std;
namespace asbt{
namespace cplx{bool begin;}
const int maxn=(1<<10)+5;
const int inf=0x3f3f3f3f;
int n,m,f[maxn][15][maxn];
char s[maxn][15];
il void upd(int &x,int y){
	x=min(x,y);
}
namespace cplx{
	bool end;
	il double usdmem(){return (&begin-&end)/1048576.0;}
}
int main(){
	read(n)read(m);
	for(int i=1;i<=n;i++){
		scanf(" %s",s[i]+1);
	}
	memset(f,0x3f,sizeof f);
	if(s[1][1]=='#'){
		f[1][1][0]=f[1][1][1<<(m-1)]=1;
	}
	else{
		f[1][1][0]=0;
	}
	for(int x=1;x<=n;x++){
		for(int y=1;y<=m;y++){
			for(int S=0,nx,ny;S<1<<m;S++){
				if(f[x][y][S]>=inf){
					continue;
				}
				nx=x+y/m;
				ny=y%m+1;
				if(s[nx][ny]=='#'){
					if(ny>1&&(S>>(m-1)&1)==0&&s[x][y]=='#'){
						upd(f[nx][ny][S>>1],f[x][y][S]);
					}
					else{
						upd(f[nx][ny][S>>1],f[x][y][S]+1);
					}
					if(nx>1&&(S&1)){
						upd(f[nx][ny][S>>1|1<<(m-1)],f[x][y][S]);
					}
					else{
						upd(f[nx][ny][S>>1|1<<(m-1)],f[x][y][S]+1);
					}
				}
				else{
					upd(f[nx][ny][S>>1],f[x][y][S]);
				}
			}
		}
	}
	int ans=inf;
	for(int S=0;S<1<<m;S++){
		ans=min(ans,f[n][m][S]);
	}
	printf("%d",ans);
	return 0;
}
}
int main(){return asbt::main();}
```

---

## 作者：CommonDigger (赞：2)

我的代码和讲解可能比其他题解更清晰。

### 题目意思
用胶带填上矩阵中的 `#`，不考虑胶带长度，不重复，不覆盖到其他格子。

### 方法
题目中有一个值得注意的数据范围：矩阵的宽 $m\leqslant10$。这意味着可以逐行枚举状态，即状压 DP。又因为计算每个点的时候需要考虑到它周围（上、左相邻）格子，所以考虑轮廓线 DP。

设 `dp[pos][x]`，表示计算到 $pos$ 位置，轮廓状态为 $x$ 的方案数。二进制下，每一位上 $0$ 表示当前格子留空或放横向胶带；$1$ 表示当前格子放竖向胶带。

这里规定轮廓从左至右第 $j(1\leqslant j\leqslant m)$ 位正对应其二进制下第 $j$ 位。那么它左边一位就是二进制第 $j-1$ 位 $(j>1)$。注意，当我们计算第 $j$ 位时，这个位置的状态是尚不知道的，此时二进制第 $j$ 位表示的是它上面的那个点。

分类讨论：

当前格子是**关闭**的窗口：不可贴胶带，则将轮廓二进制这一位修改为 $0$ 表示留空，直接复制之前的结果。

当前格子是**打开**的窗口：  
1. 考虑放竖向胶带：如果其上面窗口打开且放的也是竖向胶带，可以直接延长过来，不用多的胶带；如果不是，则新启用一个竖向胶带（数量 $+1$）。将轮廓这一位修改为 $1$，尝试更新新状态的 `dp` 值。
2. 考虑放横向胶带：如果其左边窗口打开且放的也是横向胶带，可以直接延长过来；如果不是，则新启用一个横向胶带。将轮廓这一位修改为 $0$，尝试更新新状态的 `dp` 值。

### 细节
1. 开始计算前，将前一位的方案数设为正无穷，状态 $0$ 的方案数设为 $0$。意思是只能留空，不用胶带。
2. 由于一行中每一列的 `dp` 值由其前一位的 `dp` 值推导，每行第一列由其上一行最后一列推导，所以使用滚动数组，方便访问上个格子。记得及时 `memset`。

### 代码
```cpp
/*
Luogu P7171 Selotejp
https://www.luogu.com.cn/problem/P7171
*/
#include "iostream"
#include "cstring"
using namespace std;
int n, m, temp, x_;
bool a[1005][11];
int f[2][1024];
char c;
bool check(int x, int j){ // 求 x 二进制第 j 位的值
    return x & (1<<(j-1));
}
int erase(int x, int j){ // 将 x 二进制下第 j 位修改为 0
    int t = 1<<(j-1);
    if(x & t) return x^t;
    else return x;
}
int main(){
    cin >> n >> m;
    temp=(1<<m);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin >> c;
            if(c=='#') a[i][j]=1; // bool数组，1 表示是打开的窗口
        }
    }
    // 0 横向胶带；1 竖向胶带
    memset(f[1], 0x3f, sizeof(f[1]));
    f[1][0]=0;
    int q=1; // 滚动的下标
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            q ^= 1;
            memset(f[q], 0x3f, sizeof(f[q]));
            for(int x=0;x<temp;x++){ // 枚举上一个轮廓位置状态
                if(!a[i][j]){ // 若这一位是关闭窗口
                    x_= erase(x, j);
                    f[q][x_] = min(f[q][x_], f[q^1][x]);
                    continue;
                }
                /* 考虑竖向放置：*/
                if(!check(x, j)){ // 上面横放、无
                    x_=x|(1<<(j-1)); // 将这一位状态修改为 1
                    f[q][x_]=min(f[q][x_], f[q^1][x]+1); // 新建竖向
                }else{ // 上面竖放
                    if(i && a[i-1][j]) // 上面打开
                        f[q][x]=min(f[q][x], f[q^1][x]); // 继承竖向
                }
                /* 考虑横向放置*/
                if(j>1 && !check(x, j-1) && a[i][j-1]){ // 左边横放
                    x_ = erase(x, j); // 将这一位状态修改为 0
                    f[q][x_]=min(f[q][x_], f[q^1][x]); // 继承横放
                }else{
                    x_ = erase(x, j); // 新建横向
                    f[q][x_]=min(f[q][x_], f[q^1][x]+1);
                }
            }
        }
    }
    // 最后，每个状态统计最优解
    int ans=2147483647;
    for(int i=0;i<temp;i++){
        ans=min(ans, f[q][i]);
    }
    cout << ans;
}
```

---

## 作者：ClearluvXL (赞：2)

# Selotejp
## 思路
### 一种没有过的考场思路
我觉得还是很有启发的，毕竟能在考场上想到很不容易，最终只有一个点被卡，可能是因为每一个窗户都被打开了导致我们每一行都会跑满 $2^{10}$。

依旧是状压，只不过我们看到 $m\leq 10$，直接联想到枚举每一行的状态。

我们先存储下来每一行窗户的开关状态，开着是 $0$，关了是 $1$，记作 $a$ 数组。

然后我们预处理出每一行的的开着的窗户的覆盖情况，$1$ 表示这个窗户被横着的绷带覆盖，$0$ 表示被竖着的绷带覆盖，开着的窗户必须为 $0$。

然后我们枚举出上一行的状态，令这一行覆盖状态为 $now$,上一行覆盖状态为 $lst$。

转移如下：我们令 $cnt$ 为当前这一行为新加的绷带数量。
* 先考虑预处理出 $cnt$ 数组。
* 首先就是本行的连续 $1$ 的段数，加上上一行对应列是横着的，但这一行对应列是竖着的列数。

那么普通的转移就是：$f_{i,now}=\min(f_{i,now},f_{i-1,lst}+cnt_{now,lst})$。

但是我们要考虑这些情况：
* 因为我们默认开着的窗户是竖着的，所以说，当我们这列是竖着的，上一行这一列也是竖着的，但是上一行那一列其实是开着的窗户，我们就少算了这一列新加的绷带，我们就需要加上。
* 还有就是，这一行这一列是开着的窗户，但是上一行为横着的绷带，因为我们默认开着的窗户是竖着的，我们就会加上这些列竖着的新的绷带，实际上我们是不需要的，要减去这些多的。
```c++
#include<bits/stdc++.h>
#define endl '\n'

using namespace std;

const int N=2010;
const int INF=0x3f3f3f3f;

typedef long long ll;
typedef pair<int,int> pii;

int n,m; 
int a[N];//第i位是1表示第i位需要被填。 

//num用来表示，一行以及上一行的状态来确定这行需要新加的绷带数量。 
int num[N][N];

int qf[N]；//在只有m位的状态下每个状态取反后的状态
int one[N];//对应状态里1的个数

void prework(){
	for(int now=0;now<(1<<m);now++){
		for(int lst=0;lst<(1<<m);lst++){
			int cnt=0;
			for(int k=0;k<m;k++){
				if((now>>k)&1) {
					if(k==0||!((now>>(k-1))&1)) cnt++; 
				}
				else if((lst>>k)&1) cnt++;
			}
			num[now][lst]=cnt;
		}
	}
	
	for(int now=0;now<(1<<m);now++){
		int st=0,cnt=0;
		for(int k=0;k<m;k++){
			if((now>>k)&1){
				cnt++;
				continue;
			} 
			st|=(1<<k);
		} 
		qf[now]=st;
		one[now]=cnt;
	}	
}//end

vector<int> yp[N];
int f[N][N];

//状压 
int main(){
//	freopen("selotejp.in","r",stdin);
//	freopen("selotejp.out","w",stdout);
	
	ios::sync_with_stdio(0);
	
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		int st=0;
		for(int j=0;j<m;j++) {
			char x; cin>>x;
			if(x=='.') st|=(1<<j);
		}
		a[i]=st;
	}
	
	prework();
	
	for(int i=1;i<=n;i++){
		for(int st=0;st<1<<m;st++){
			if(st&(a[i])) continue;
			yp[i].push_back(st);
		}
	} 
	
	memset(f,INF,sizeof f);
	
	yp[0].push_back((1<<m)-1);
	f[0][(1<<m)-1]=0;
	
	for(int i=1;i<=n;i++){
		for(int now:yp[i]){
			for(int lst:yp[i-1]){
				f[i][now]=min(f[i][now],f[i-1][lst]+num[now][lst]+
					one[(qf[now]^a[i])&a[i-1]]-one[qf[now]&(a[i])&lst]);
			}
		}
	}
	
	int ans=1e9;
	
	for(int now:yp[n]){
		ans=min(ans,f[n][now]);
	}
	
	cout<<ans<<endl;
	
	return 0;
}//end 
```
### 正解思路
在考场时想过此类 DP，但是因为不会转移导致暴毙。了解到这类 DP 叫做轮廓线 DP。

记当前点的状态位前 $m$ 位的状态，如果溢出就往上面一行补。具体看图。

![](https://cdn.luogu.com.cn/upload/image_hosting/jsjjsf18.png)

那么我们向 $(i,j+1)$ 转移时，需要看 $(i,j)$ 和 $(i-1,j+1)$ 的状态，而这样就可以刚好枚举到。
* $(i,j+1)$ 是横，如果 $(i,j)$ 也是横，可以跟着 $(i,j)$，否则 $+1$。
* $(i,j+1)$ 是竖，如果 $(i-1,j+1)$ 也是竖，可以跟着 $(i-1,j+1)$，否则 $+1$。

**注意开着的窗户此时默认是横着绷带的情况，记得辨别**。

**这份代码中我们将 $1$ 看作是竖着涂，$0$ 看作是横着**。

**代码中状态的最高位为当前位置的绷带覆盖状态，与上述状态相反**。

因为这份代码是看的题解区大佬的思路打的，所以状态的设计和转移也是跟着他们的。

```c++
#include<bits/stdc++.h>
#define endl '\n' 
using namespace std;

const int N=1010;
const int INF=0x3f3f3f3f;

int f[N][15][1050];
int n,m;
char c[N][15];

int main(){
	freopen("selotejp.in","r",stdin);
	freopen("selotejp.out","w",stdout);
	
	ios::sync_with_stdio(0);
	
	cin>>n>>m;
	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++) cin>>c[i][j];
	}
	
	memset(f,INF,sizeof f);
		
	if(c[1][1]=='#') f[1][1][0]=f[1][1][1<<m-1]=1;
	else f[1][1][0]=0;
	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			for(int k=0;k<1<<m;k++){
				if(f[i][j][k]>=INF) continue;
				int nj=j%m+1,ni=i;//下一位 
				if(j==m) ni=i+1;//如果是最后一位就换行 
				if(c[ni][nj]=='#'){
					if(nj>1&&!(k&1<<m-1)&&c[i][j]=='#')//可以连着左边横着的横着 
						f[ni][nj][k>>1]=min(f[ni][nj][k>>1],f[i][j][k]);
					else //新开一个横着的 
						f[ni][nj][k>>1]=min(f[ni][nj][k>>1],f[i][j][k]+1);
					
					if(ni>1&&(k&1)&&c[ni-1][nj]=='#') //可以连着上边竖着 
						f[ni][nj][(k>>1)+(1<<m-1)]=min(f[ni][nj][(k>>1)+(1<<m-1)],f[i][j][k]);
					else //新开一个竖着的 
						f[ni][nj][(k>>1)+(1<<m-1)]=min(f[ni][nj][(k>>1)+(1<<m-1)],f[i][j][k]+1);
				}
				//默认开着的窗户只能横着 
				else f[ni][nj][k>>1]=min(f[ni][nj][k>>1],f[i][j][k]);
			}
		}
			
	}
		

	int ans=1e9;	
	
	for(int i=0;i<1<<m;i++) ans=min(ans,f[n][m][i]);

	cout<<ans<<endl;
	
	return 0;
}//end
```

---

## 作者：mskqwq (赞：1)

一种不需要轮廓线 dp 的简单方法。

设 $f_{i,s}$ 表示考虑到了第 $i$ 行，$s$ 中的位置为向下的胶带，剩下的位置为横向的胶带。那么转移就形如 $f_{i,s}\gets f_{i-1,t}+|s|-|s\cap t|+g_{s-s\cap t}$，其中 $g_s$ 表示 $s$ 在二进制下的连续的 $1$ 的个数，容易预处理。

直接转移是 $O(n4^m)$ ，考虑优化。我们发现我们只在意 $s$ 和 $t$ 的交集部分，于是我们对 $f_{i-1}$ 做一遍高维后缀 $\min$，然后在转移时 $t$ 就只需枚举 $s$ 的子集了，复杂度变为 $O(n3^m)$。

但是这样做会不会导致错误的转移呢？假如我们用一个 $f_{i-1,t\cup\{x\}}$ 去转移，但是常数项还是 $|s|-|s\cap t|+g_{s-s\cap t}$。如果 $x\notin s$ 的话，$|s|-|s\cap t|$ 不变，不会出问题。如果 $x\in s$ 的话，$|s|-|s\cap t|$ 的值会比正确的值多 $1$，$g_{s-s\cap t}$ 的值至多比正确的值少 $1$，也不会产生错误的转移。


```cpp
int n,m,f[2][1<<10],g[1<<10],ans=mod;char s[15];
void ck(int &x,int y){(x>y)&&(x=y);}
void misaka(){
    n=read(),m=read();
    memset(f,0x3f,sizeof(f));
    f[0][0]=0;
    rep(i,0,(1<<m)-1){
        if(~i&1) g[i]=g[i>>1];
        else g[i]=g[i>>1]+(~i>>1&1);
    }
    rep(i,1,n){
        scanf("%s",s);
        int p=i&1,q=p^1,S=0;
        rep(j,0,(1<<m)-1) f[p][j]=mod;
        rep(j,0,m-1) S|=(s[j]=='#')<<j;
        rep(j,0,m-1)rep(k,0,(1<<m)-1)
            if(~k>>j&1) ck(f[q][k],f[q][k|(1<<j)]);
        for(int t=S;;t=(t-1)&S){
            for(int h=t;;h=(h-1)&t){
                ck(f[p][t],f[q][h]+pc(t^h)+g[S^t]);
                if(!h) break;
            }
            if(!t) break;
        }
    }
    rep(i,0,(1<<m)-1) ck(ans,f[n&1][i]);
    printf("%d",ans);
}
```

---

## 作者：Claire0918 (赞：0)

我们注意到 $n \leq 1000, m \leq 10$ 极有特点，考虑大致 $\mathcal{O}(n2^m)$ 复杂度。

考虑 DP。行和列的状态都需要刻画，同时考虑到上文提及的复杂度，设 $f_{i, s}$ 为前 $i$ 行，第 $i$ 行每一个格子是否贴了向下胶带的状态为 $s$ 时的最小答案。有显然的初始化 $f_{0, 0} = 0$。

考量第 $i$ 行，如果第 $j$ 格是关闭的，那么显然其不能贴胶带，更不能贴向下的胶带，从而我们要求 $j \notin s$。这部分检查是单次 $\mathcal{O}(m)$ 的，对整体复杂度贡献 $\mathcal{O}(nm2^m)$。

在 $s$ 满足这一点之后，我们枚举第 $i - 1$ 行的状态 $t$。直接枚举将会使整体复杂度达到 $\mathcal{O}(4^m)$，不能通过。我们注意到 $t$ 能在第 $i$ 行保留的贡献是 $t \cap s$，剩余的都不在第 $i$ 行需要。我们可以把 $t$ 的贡献挂在 $t' = t \cap s$ 上，对 $f_{i, s}$ 求超集和转移。

具体地，我们记 $f'_{i, s}$ 表示 $f_{i, s}$ 的状态意义超集和，即 $f'_{i, s} = \min_{t \supseteq s} f_{i, s}$。我们可以枚举 $t' \subseteq s$，设第 $i$ 行除了在 $s$ 中的点外还有需要通过横着贴胶带来处理 $k$ 次，那么就有转移
$$
f_{i, s} = \min_{t' \subseteq s} f'_{i, t'} + |s \setminus t| + k
$$
转移完 $f_{i, s}$ 后枚举子集来处理 $f'_{i, s}$ 即可。枚举子集使用恰当的实现可以做到对于一个 $i$ 复杂度 $\mathcal{O}(3^m)$，对整体复杂度贡献 $\mathcal{O}(n3^m)$。

整体时间复杂度 $\mathcal{O}(nm2^m + n3^m)$，可以通过。

Code：
```cpp
#include<bits/stdc++.h>
#define mem(a, v) memset(a, v, sizeof(a))

using namespace std;

const int maxn = 1000 + 10, maxm = 10;

int n, m;
char a[maxn][maxm];
int f[maxn][1 << maxm];

int main(){
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; i++){
        scanf("%s", a[i] + 1);
    }
    mem(f, 0x3f);
    f[0][0] = 0;
    for (int i = 1; i <= n; i++){
        for (int sta = 0; sta < 1 << m; sta++){
            bool fl = true;
            for (int j = 1; j <= m; j++){
                fl &= !(a[i][j] == '.' && (sta >> j - 1 & 1));
            }
            if (fl){
                int cnt = 0;
                for (int j = 1; j <= m; j++){
                    if (a[i][j] == '#' && !(sta >> j - 1 & 1) && (j == 1 || a[i][j - 1] != '#' || (sta >> j - 2 & 1))){
                        cnt++;
                    }
                }
                for (int t = sta;; t = t - 1 & sta){
                    f[i][sta] = min(f[i][sta], f[i - 1][t] + __builtin_popcount(sta ^ t) + cnt);
                    if (!t){
                        break;
                    }
                }
            }
            for (int t = sta;; t = t - 1 & sta){
                f[i][t] = min(f[i][t], f[i][sta]);
                if (!t){
                    break;
                }
            }
        }
    }
    printf("%d", f[n][0]);

return 0;
}
```

---

## 作者：rainygame (赞：0)

拜谢可爱的 @[Yao_yx](https://www.luogu.com.cn/user/1041298) 场切本题。她给出了不用轮廓线 DP 的做法。

先给出我场上一个暴力 DP 的做法：设 $f_{i,S}$ 表示现在到第 $i$ 行，且竖着的胶带的集合为 $S$。转移有：

$$
\begin{aligned}
f_{i,S}=v(S)+\min\limits_{T} f_{i-1,T}+\operatorname{popc}(S)-\operatorname{popc}(S\wedge T)
\end{aligned}
$$

其中 $v(S)$ 表示竖着的集合为 $S$ 时第 $i$ 行需要的胶带个数，$\wedge$ 为按位与。意思就是本来需要在这一行新建 $\operatorname{popc}(S)$ 个竖着的胶带，但是因为有 $\operatorname{popc}(S\wedge T)$ 个在前一行已经新建了，所以要减去。

这样需要枚举 $S$ 和 $T$，时间复杂度为 $O(n4^m)$。

对于一个 $S$ 来说，$v(S)$ 和 $\operatorname{popc}(S)$ 都是固定的，考虑求出 $\min\limits_{T} f_{i-1,T}-\operatorname{popc}(S\wedge T)$。这个 $S\wedge T$ 不太好处理，那么就枚举它。在枚举了 $S\wedge T$ 之后，找到 $S\wedge T$ 的一个超集 $T$ 使得 $f_{i-1,T}$ 最小，超集最小值可以用 SOSDP 求出。需要枚举 $S$ 和它的子集 $S\wedge T$。总时间复杂度为 $O(n3^m)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 1005
#define MAXM 1<<10

int n, m, ans(USHRT_MAX); int f[MAXM], g[MAXM]; int s[MAXN];

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);

    cin >> n >> m; for (int i(1); i<=n; ++i) for (int j(1); j<=m; ++j){char c; cin >> c; s[i] |= (c=='#')<<(j-1);}
    memset(g, 0x3f, sizeof(g)); g[0] = 0;
    for (int i(1); i<=n; ++i){
        memset(f, 0x3f, sizeof(f)); for (int j(0); j<m; ++j) for (int i(0); i<(1<<m); ++i) if (!(i>>j&1)) g[i] = min(g[i], g[i^1<<j]);
        for (int j(s[i]); ; j=(j-1)&s[i]){
            for (int k(j); ; k=(k-1)&j){f[j] = min(f[j], g[k]-__builtin_popcount(k)); if (!k) break;}
            f[j] += __builtin_popcount(j);
            for (int k(0), ls(0); k<=m; ++k) if ((j>>k&1) || !(s[i]>>k&1)) f[j] += ls, ls = 0; else ls = 1; if (!j) break;
        }
        memcpy(g, f, sizeof(f));
    }
    for (int i(0); i<(1<<m); ++i) ans = min(ans, f[i]); cout << ans;

    return 0;
}
```

---


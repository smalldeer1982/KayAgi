# [TOIP2024] 栖息地分配

## 题目描述

有 $n$ 只猫活动于某个地区，每只猫各有其栖息地，编号为 $1$ 到 $n$。栖息地之间有 $m$ 条道路连接，道路总数不超过 $2n-4$。第 $i$ 条道路连接第 $a_i$ 个栖息地和第 $b_i$ 个栖息地，猫可以沿着这些道路在栖息地之间**双向**移动，且不会有两条不同的道路连接着同一对栖息地。有 $3$ 个动物保护团体要接管此地区，请你协助将这 $n$ 个栖息地分配给这 $3$ 个团体，满足以下要求：

- 每个栖息地仅由 $1$ 个团体管理，且每个团体需要管理至少 $1$ 个栖息地。每个团体所属的栖息地之间不一定要连通。
- 为了方便管理，每个团体会移除由该团体负责的栖息地之间的道路。换句话说，若有一条道路连接的两个栖息地被分配到同一个团体，该道路会被移除。
- 这些道路移除后，剩余的道路不可以形成「环」，以免猫可能会绕着环奔跑，让工作人员难以捕捉。也就是说，不可以存在一个两两相异的栖息地序列 $v_1,v_2,\ldots, v_k$，满足 $k \ge 3$，且对于所有 $1\le i < k$，栖息地 $v_i$ 和栖息地 $v_{i+1}$ 都有一条未被移除的道路连接、同时 $v_k$ 和 $v_1$ 也有一条未被移除的道路连接。

举例，有 $5$ 个栖息地，道路连接如下图所示

![](https://cdn.luogu.com.cn/upload/image_hosting/b0pxmz4d.png)

我们可以将第 $3$, $4$, $5$ 个栖息地分配给第 $1$ 个团体，第 $1$ 个栖息地分配给第 $2$ 个团体，第 $2$ 个栖息地分配给第 $3$ 个团体。 移除掉道路后，如下图所示

![](https://cdn.luogu.com.cn/upload/image_hosting/pxugxjfr.png)

剩余道路不存在环，所以这是一种满足目标的分配方式。

请输出这 $3$ 个团体应该分别管理哪些栖息地，若有多种分配方式满足条件，输出任意一种。

## 说明/提示

### 测试数据限制
* $1 \le t \le 3\times 10^5$。
* $3 \le n \le 3\times 10^5$。
* $0 \le m \le 2n - 4$。
* $1 \le a_i, b_i \le n$，$a_i \neq b_i$。
* 所有测试数据中，$n$ 的总和不超过 $3\times 10^5$。

### 评分说明

本题共有四组子任务，条件限制如下所示。
每一组可有一或多组测试数据，该组所有测试数据皆需答对才会获得该组分数。

|  子任务  |  分数  | 额外输入限制 |
| :------: | :----: | ------------ |
| 1 | $3$ | 输入满足 $m = n - 1$，且所有的栖息地连通。 |
| 2 | $23$ | 输入保证存在两个以上的栖息地互相无法抵达。 |
| 3 | $28$ | 输入满足所有测试数据中，$n$ 的总和不超过 $500$。 |
| 4 | $46$ | 无额外限制。 |

## 样例 #1

### 输入

```
1
5 6
1 2
2 3
3 4
4 5
5 3
4 2```

### 输出

```
3 3 4 5
1 1
1 2```

## 样例 #2

### 输入

```
2
5 4
1 2
1 3
3 4
3 5
5 4
1 2
2 3
1 3
4 5```

### 输出

```
2 1 2
1 3
2 4 5
3 1 2 3
1 4
1 5```

# 题解

## 作者：水星湖 (赞：3)

必然有解。

当图中有 $\ge 2$ 个连通块时，将较小的连通块内所有点放在第一类，剩下大的连通块大小必然 $\ge 2$，任取一个点作为第二类，剩下的作为第三类，显然合法。

否则，当图中仅有一个连通块时，由于 $m\le 2n-4$，则求生成树的过程中至多有 $n-3$ 条返祖边，每一条返祖边用并查集合并端点，最后必然剩下 $\ge 3$ 个未合并的集合（$n$ 个点至多合并 $n-3$ 次），直接输出就好了。

```cpp
#include <bits/stdc++.h>
using namespace std;

namespace z {

#define int long long
const int N = 5e5 + 5;
int fa[N], flag[N], vis[N];
vector<int> p[N];
int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
void merge(int x, int y) { x = find(x), y = find(y); if(x != y) fa[x] = y; }
void init(int n) { for(int i = 1; i <= n; i++) fa[i] = i, flag[i] = 0, vis[i] = 0, p[i].clear(); }
void dfs(int u, int fa) {
    vis[u] = 1;
    for(auto v : p[u]) {
        if(v == fa) continue;
        if(vis[v]) merge(v, u);
        else dfs(v, u);
    }
}
void solve() {
    int n, m; cin >> n >> m;
    init(n);
    for(int i = 1; i <= m; i++) {
        int u, v; cin >> u >> v;
        p[u].push_back(v);
        p[v].push_back(u);
    }
    dfs(1, 0);
    for(int i = 2; i <= n; i++) if(!vis[i]) {
        vector<int> a1, a2;
        for(int j = 1; j <= n; j++) {
            if(vis[j]) a1.push_back(j);
            else a2.push_back(j);
        }
        if(a1.size() == 1) {
            cout << 1 << " " << a1[0] << '\n';
            cout << 1 << " " << a2[0] << '\n';
            cout << a2.size() - 1 << " ";
            for(auto j : a2) if(j != a2[0]) cout << j << ' ';
            cout << '\n';
        } else if(a2.size() == 1) {
            cout << 1 << " " << a1[0] << '\n';
            cout << 1 << " " << a2[0] << '\n';
            cout << a1.size() - 1 << " ";
            for(auto j : a1) if(j != a1[0]) cout << j << ' ';
        } else {
            cout << a1.size() << " ";
            for(auto j : a1) cout << j << ' ';
            cout << '\n';
            cout << 1 << " " << a2[0] << '\n';
            cout << a2.size() - 1 << " ";
            for(auto j : a2) if(j != a2[0]) cout << j << ' ';
        }
        return;
    }
    vector<int> ans;
    for(int i = 1; i <= n; i++) 
        if(find(i) == i) ans.push_back(i);
    vector<int> a[3];
    for(int i = 0; i <= 2; i++)
        for(int j = 1; j <= n; j++)
            if(find(j) == ans[i])
                a[i].push_back(j), flag[j] = 1;
    for(int i = 1; i <= n; i++) 
        if(!flag[i]) a[0].push_back(i);
    for(int i = 0; i <= 2; i++) {
        cout << a[i].size() << ' ';
        for(auto j : a[i]) cout << j << ' ';
        cout << '\n';
    }
}
void main() {

    ios::sync_with_stdio(false);
    cin.tie(nullptr);cout.tie(nullptr);
    int T; cin >> T;
    while(T--) solve();

}

#undef int

}


int main()
{
    z::main();
    return 0;
}
```

---

## 作者：_sin_ (赞：0)

提供一个神秘做法。

先考虑求最小生成树的步骤，如果这条边连接两个不同的连通块，两端颜色可以不同；如果这条边连接在同一个连通块内，两端颜色必须相同。这可以用两个并查集维护。

这个做法看上去很对，但是交上去会 Wa 几个点。我们充分发扬人类智慧，将一条边 $(x,y)$ 当 $x>y$ 时候交换 $x,y$。最后以 $x$ 为第一关键字，$y$ 为第二关键字从小到大排序。将所有的边这样处理后再进行上述操作即可通过本题。

代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}
    while('0'<=ch&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return f*x;
}

const int N = 1e6+5;
int T,n,m,col[N],cnt=0,st;vector<int>ans[5];
struct EDGE{int x,y;}edges[N];
struct UnionSet{
    int fa[N],n;
    void init(int _n){n=_n;for(int i=1;i<=n;i++)fa[i]=i;}
    int find(int x){return fa[x]=(fa[x]==x?x:find(fa[x]));}
    void merge(int x,int y){fa[find(x)]=find(y);}
}s1,s2;

bool cmp(EDGE a,EDGE b){return a.x==b.x?a.y<b.y:a.x<b.x;}

void solve(){n=read(),m=read();s1.init(n),s2.init(n);for(int i=1;i<=m;i++){
        edges[i].x=read(),edges[i].y=read();if(edges[i].x>edges[i].y)swap(edges[i].x,edges[i].y);
    }sort(edges+1,edges+1+m,cmp);for(int i=1;i<=m;i++)
    if(s1.find(edges[i].x)!=s1.find(edges[i].y))s1.merge(edges[i].x,edges[i].y);
    else s2.merge(edges[i].x,edges[i].y);for(int i=1;i<=n;i++)s2.fa[i]=s2.find(i),col[i]=-1;
    ans[0].clear(),ans[1].clear(),ans[2].clear();for(int i=1;i<=n;i++){
        if(col[s2.fa[i]]==-1)col[s2.fa[i]]=(cnt++)%3;ans[col[s2.fa[i]]].emplace_back(i);
    }for(int id=0;id<3;id++){printf("%ld ",ans[id].size());for(int x:ans[id])printf("%d ",x);puts("");}
}

int main(){
    T=read();while(T--)solve();
    return 0;
}
```

---

## 作者：AmaoFox (赞：0)

upd：修正了一个 typo。增加了证明。

看到其它题解认为本题很好玩，于是过来做了一下。注意：本题解可能比较邪道，欢迎 hack。

我们注意到 $m\le2n-4$，图中的边数并不多。所以，根据考场上的不会正解就随机化的思路，我们开始写随机化算法。

具体地说，我们每次随机挑选两个点，将它们分别分给一个团队，剩下的全部分给第三个团队，那么最终的结果是保留的边会变成这两个点相邻边的并集，其它的边全部没有了。

我们知道，一个点的所有相邻边构成一个菊花，而一朵菊花肯定是不会有环的。但是两朵菊花什么时候没有环呢？

在草稿纸上画一下，如果两朵菊花的根$^1$被连在一条边上，它们又刚好没有公共叶子，那么它们是不会构成环的。最终会长成一条边的两个端点各伸出去一些单独的边。否则，两个根除了直接相连，还有经过叶子的路径，就一定会构成环。

如果两朵菊花的根并不相连，那么它们可以有零或一个公共叶子，这样也显然是不会构成环的，因为两个根中间根本就没有路径，或者只有一条。而有两个公共叶子的时候，两个根中间就会有两条经过不同叶子的路径：这又是一个环了。

证明这样总是有解的：首先我们不妨假设无解。也就是说，对于任意两个节点，他们要么在一条边上并且有至少一个公共的第三点与他们相邻，要么不在一条边上并且有至少两个公共的第三点与他们相邻。

我们对一个点进行考虑，如果它的度数小于 $2$ 那么没有考虑的必要了。  
假设它的度数为 $x$。则对于不与它相连的 $(n-x-1)$ 个点，它们都有两条边指出来指向相同的两个点，且这两个点和原来的 $x$ 相连。如果指向不同的两个点显然是浪费边了。所以现在这里最少也有 $(2+2(n-x-1))$ 条边。  
而对于与它相连的 $x$ 个点，它们都有另外的一条边指出来指向相同的一个点，同样，指向不同的点也是浪费边了。所以现在这里也最少有 $(x+(x-1))$ 条边。

于是你惊喜的发现你现在已经用掉 $(2n-1)$ 条边了，而你刚刚考虑了一个点而已。这显然是不符合题意的。

于是，在 $(2n-4)$ 条边的限制下总有两个点可以有解。带着这个结论，我们开始愉快地写代码了。

``` cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int N = 300005;

vector<int> g[N];

void solve() {
  int n, m;
  cin >> n >> m;
  for(int i = 1; i <= n; i++) {
    g[i].clear();
  }
  for(int i = 1; i <= m; i++) {
    int u, v;
    cin >> u >> v;
    g[u].push_back(v);
    g[v].push_back(u);
  }
  while(1) {
    int x = rand() % n + 1, y = rand() % n + 1;
    if(x == y) {
      continue;
    }
    set<int> st;
    for(int i : g[x]) {
      st.insert(i);
    }
    for(int i : g[y]) {
      st.insert(i);
    }
    if(st.size() == g[x].size() + g[y].size()) { // 没有公共叶子
      cout << "1 " << x << "\n1 " << y << '\n' << n - 2;
      for(int i = 1; i <= n; i++) {
        if(i != x && i != y) {
          cout << ' ' << i;
        }
      }
      cout << '\n';
      return;
    } else if(st.size() == g[x].size() + g[y].size() - 1) { // 有一个公共叶子
      bool ok = 1;
      for(int i : g[x]) {
        if(i == y) {
          ok = 0;
          break;
        }
      }
      if(ok) { // x 和 y 不相连
        cout << "1 " << x << "\n1 " << y << '\n' << n - 2;
        for(int i = 1; i <= n; i++) {
          if(i != x && i != y) {
            cout << ' ' << i;
          }
        }
        cout << '\n';
        return;
      }
    }
  }
}

signed main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  int t;
  cin >> t;
  while(t--) {
    solve();
  }
  return 0;
}
```

可以看到最慢的点跑了四百多毫秒，还是在可以接受范围之内的。很搞笑的一点是，如果暴力枚举 $x$ 和 $y$ 而不是随机化，虽然子任务 $2$ 严重超时，但是其它子任务反而勉强还是过了。

注 $1$：这里的菊花的根指中间有边连向剩下其它节点的节点。而叶子指剩下其它节点。

---

## 作者：SamHH0912 (赞：0)

题目传送门：[link](https://www.luogu.com.cn/problem/P11829)

调了一下午+一晚上的题过了，来写篇题解。

> **注：题解中展示的做法仅为笔者的初步思路调整后的，实际上存在更简单的做法。这个做法就是将 $nct=1$ 时的做法推广至所有情况。可以证明其正确性。**
>
> **建议读者使用这种更加简单的做法通过本题，而非使用本题解中展示的整体做法。**

---

## 题目简述

有一个 $n$ 点 $m$ 边**无向图**，现在要将图中的**每个节点**都染上**三种颜色**（$1,2,3$）中的**其中一种**，要求**每种颜色都要被至少一个点染上**。染完色后，断开所有**同色节点**间的连边，得到一张新图。要求新图中**无环**，请构造一组方案，或报告无解。

多测。**保证无重边、无自环。**

数据规模：$3\le n,\sum n\le 3\times 10^5$，$\color{red}0\le m\le 2n-4$。

## 第一步

看到“新图中无环”的操作，容易想到将每个**边双连通分量**中的所有点染成同一种颜色，这样就可以**断开所有边双中的边**，达到这个目的了。

接下来，让我们开始分类讨论。**下文中，记 $nct$ 为原图中边双的个数。**

## 特判：$m=0$

图中没有连边，但题目要求**每种颜色都要用上**，所以**将 $1,2$ 号节点分别染上颜色 $1$ 和颜色 $2$**，其余 $(n-2)$ 个节点全部染颜色 $3$ 即可。

## $nct\ge 3$

边双缩点完毕后，得到的图**一定是森林**（易证）。

森林中的边即使留着，在断边后形成的新图中也**不会产生**新的环。所以我们无需在意森林中的边连接的两端点的颜色。

所以，我们只需分别用颜色 $1$ 和颜色 $2$ **各染一个边双**，然后再用颜色 $3$ 染**剩余的点**，就能满足题目的要求了。

## $nct=2$

先将这两个边双**分别染上**颜色 $1$ 和颜色 $2$。

显然，我们可以**任意取**一个**大小 $\gt 1$ 的边双**，**随便**将这个边双中的**其中一个点**染成颜色 $3$ 就满足题目要求了。（染成颜色 $3$ 的那个点在新图中所在的连通块是以其为花心的**菊花图**）

**Tips：在使用多层循环和 if/else 语句嵌套且无括号时，时刻注意 if 与 else 的对应关系（必要的括号不要省！！！）。**

## $nct=1$

最难的一部分。笔者假了好几次，最后终于想出来了正解。**（实际上这里的解法经过微调可以通过全体数据，请读者自行实现）**

### 方法

在图上进行**深度优先搜索（DFS）**，同时维护一个**并查集**。

在搜索时，如果搜到当前点引出了一条**指向已经搜过的点**的边，则将这条边连接的两个点所在的并查集**合并**。

最后，取**一个并查集中连通块**染上颜色 $1$，再取**另一个并查集中连通块**染上颜色 $2$，**剩下所有连通块**染上颜色 $3$。

同时，有结论：**在题目的条件下，一定有解。**

下面给出存在解及正确性证明。

---

### 引理 1：对于所有从当前节点连向搜过的点的边，若构建搜索树，则该边一定为树外返祖边。

证明：为方便，设当前节点为 $now$，先前节点为 $pre$。

若非返祖边，则这条边一定横跨了两个不交的子树。

由于 $dfn_{pre}\lt dfn_{now}$，则**根据 DFS 的搜索原理**，$now$ **一定**会被 $pre$ 或 $pre$ 在搜索树上的后代**第一次搜到**，故在搜索树上 $now$ **是** $pre$ 的 **后代**。

这与假设矛盾，故原命题成立，是为引理 $1$。

---

### 引理 1.5：所有返祖边连接的两点在树上不是直接相连（树上距离 $\ge 2$）。

证明：若是直接相连，则 $now$ 和 $pre$ 之间有**至少两条**边，这与题干中 **【原图中无重边】** 的条件矛盾，故原命题成立，是为引理 $1.5$。

---

### 引理 2：最终的并查集数 $\ge 3$（定理：题目条件下保证有解）

证明：反证，假设最终的并查集数 $\le 2$。

**根据引理 $1.5$**，有一个小的结论：**根及其儿子没有返祖边。** 这说明根和其儿子一定是各自所在并查集中**深度最小**的点。

首先，如果根节点的儿子数 $\gt 1$，则**根据引理 $1.5$**，根和它的所有儿子**都**是在各自所在并查集中**深度最小的点**，故**最少有 $3$ 个并查集**，与假设矛盾。

再看根节点只有一个儿子的情况（不能没有儿子，因为 $n\ge 3$）。  
根据根节点儿子数 $\gt 1$ 的部分得到的推论，这两个连通块中**深度最小的点**分别是**根及其儿子**，其他每个节点都有**至少一条**返祖边。  
**根据引理 $1.5$**，为使总边数最小，从除了上述两个节点之外的所有节点连一条指向自己**二级祖先**的边。  
这种情况下，返祖边条数为 $(n-2)$，加上原来的 $(n-1)$ 条树边，**总边数为 $(2n-3)$**。但是题目限制 $\color{red}m\le 2n-4\lt 2n-3$，所以此情况下，只有两个并查集的情况**不存在**。

综上，最终得到的并查集数 $\ge 3$。换言之，**一定有解**。是为引理 $2$。

---

### 染色结果正确性证明

首先，考虑非树边。由于并查集的维护，所有非树边**都因为节点同色被断掉**，所以最终图中**不存在**非树边。

然后，我们发现，剩下的边**即使全部保留，也只能得到一棵树**（**无环**，是为**原图的 DFS 生成树**）。所以最终留下的边**无论如何都不会成环**。

---

根据**有解性证明**和上面的**结果正确性证明**，我们成功地**证明了染色方法的正确性**，因此可以放心大胆地写了。

## 输出

除了对于 $m=0$ 的特判部分，其余部分均需**处理出输出序列**。由于笔者不想写 `vector`等 `STL`，所以 Ta 使用了**链表**来输出。

即，从后往前扫整个颜色序列，维护每种颜色**扫到过**的**最靠前**的位置，并对于每个位置，计算**下一个**与该位置**同色**的位置。输出时，对于每一条链，**从链头跳到链尾**即可。

（为什么从后往前扫呢？因为笔者怕 SPJ 判不了倒序（雾）

## 时间复杂度

每一小的部分（求边双、DFS、统计各颜色点数，求输出序列、输出、$1$ 和 $2$ 和 $m=0$ 的特判等）的时间复杂度不是 $\mathcal{O}(n)$ 就是 $\mathcal{O}(m)$，常数小一点包能过的！

## 代码

**Tips：仅供参考，请勿抄袭！**


```cpp
#include <bits/stdc++.h>
using namespace std;
#define LL long long

#define N 300007
int cnt,head[N];//链式前向星
struct qwq{int v,nxt;}edge[N<<2];//(2n-4)*2<=4n
inline void AddE(int u,int v){
	edge[++cnt]={v,head[u]};
	head[u]=cnt;
}
inline void init(int n){//图的初始化
	cnt=0;
	for(int i=1;i<=n;i++) head[i]=0;
}
#define REPG(x) for(int i=head[x];i;i=edge[i].nxt)
//同点连出的边

int ctr,low[N],dfn[N],stk[N],t,nct,num[N],sz[N];
//已经过点数，最早栈中节点，DFS序，手写栈，栈顶，当前边双个数，所属边双编号，边双大小

inline void Tarjan(int u,int fa){//参考P8436（不过不用判重边）
	low[u]=dfn[u]=++ctr;
	stk[++t]=u;
	REPG(u){
		int v=edge[i].v;
		if(v==fa) continue;
		if(!dfn[v]) Tarjan(v,u),low[u]=min(low[u],low[v]);
		else low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u]){
		nct++;sz[nct]=0;
		while(int v=stk[t--]){
			num[v]=nct;sz[nct]++;
			if(v==u) break;
		}
	}
}

bool vis[N];

int ans[N],c[3],lst[3],nxt[N];

int f[N],colu[N];

inline int getfa(int x){//并查集找祖先
	if(f[x]==x) return f[x];
	return f[x]=getfa(f[x]);
}
inline void merge(int x,int y){//合并连通块
	f[getfa(f[x])]=getfa(f[y]);
}

inline void dfs1(int u,int fa){//第一次：维护并查集
	vis[u]=1;
	REPG(u){
		int v=edge[i].v;
		if(vis[v]){
			if(v!=fa) merge(u,v);//不是父亲，就是返祖边
		}
		else dfs1(v,u);//是新节点
	}
}

inline void dfs2(int u){//第二次：染色
	vis[u]=1;
	if(colu[f[u]]<0){//第一次搜到这个集，需要定颜色
		if(!c[0]) colu[f[u]]=1,c[0]++;
		else if(!c[1]) colu[f[u]]=2,c[1]++;
		else colu[f[u]]=3,c[2]++;
	}else c[colu[f[u]]-1]++;//颜色已定
	ans[u]=colu[f[u]];//染到点上
	REPG(u){
		int v=edge[i].v;
		if(!vis[v]) dfs2(v);
	}
}

inline void solve(){
	int n,m;
	cin>>n>>m;
	if(!m){//m=0的特判
		cout<<1<<' '<<1<<'\n';
		cout<<1<<' '<<2<<'\n';
		cout<<n-2<<' ';for(int i=3;i<=n;i++) cout<<i<<' ';
		cout<<'\n';return;
	}
	for(int i=1;i<=m;i++){//输入边
		int a,b;
		cin>>a>>b;
		AddE(a,b),AddE(b,a);//无向图
	}
	
	for(int i=1;i<=n;i++) if(!dfn[i]) Tarjan(i,i);//边双
	if(nct<3){
		if(nct==1){//nct=1
			for(int i=1;i<=n;i++) f[i]=i,colu[i]=-1,vis[i]=0;//并查集/块颜色/DFS标记
			dfs1(1,0);//维护并查集
			for(int i=1;i<=n;i++) f[i]=getfa(f[i]),vis[i]=0;//DFS标记归位，并查集最后修改
			memset(c,0,sizeof c);//颜色点数
			dfs2(1);//计算答案
			goto Out;//跳至输出
		}else{//nct=2
			int u;
			if(sz[1]>1) {for(u=1;u<=n;u++) if(num[u]==1) break;}//如果能从1号边双中取（注意括号）
			else for(u=1;u<=n;u++) if(num[u]==2) break;//只能从2号边双中取
			memset(lst,0,sizeof lst);//最前颜色位
			for(int i=n;i;i--){
				ans[i]=(i==u?3:num[i]);//换色节点特判
				nxt[i]=lst[ans[i]-1],lst[ans[i]-1]=i;//仍然是链表
			}
			if(num[u]==1) sz[1]--; else sz[2]--;//更新染色节点数
			cout<<sz[1]<<' '; for(int j=lst[0];j;j=nxt[j]) cout<<j<<' ';//输出大小后开始跳链
			cout<<'\n';//颜色 1
			cout<<sz[2]<<' '; for(int j=lst[1];j;j=nxt[j]) cout<<j<<' ';//跳颜色 2 的链
			cout<<'\n';//颜色 2
			cout<<1<<' '<<u<<'\n';//颜色 3
		}
		goto end;//跳至初始化
	}
	
	memset(c,0,sizeof c);
	for(int i=1;i<=n;i++) ans[i]=min(num[i],3),c[ans[i]-1]++;//边双分配颜色，并染色
	
	Out://输出
	memset(lst,0,sizeof lst);//清空最新位置数组
	for(int i=n;i;i--){//倒序扫描
		int col=ans[i]-1;//-1是因为c数组和lst数组长度都只有3（下标0到2）
		nxt[i]=lst[col],lst[col]=i;//计算当前节点指向的节点，并更新同色最新节点
	}
	for(int i=0;i<3;i++){//对于每种颜色
		cout<<c[i]<<' ';//输出大小
		for(int j=lst[i];j;j=nxt[j]) cout<<j<<' ';//跳链
		cout<<'\n';//换行
	}
	
	end://初始化
	init(n);//图初始化
	ctr=t=0;//Tarjan变量初始化
	for(int i=1;i<=n;i++) dfn[i]=nxt[i]=0;//Tarjan & 链表初始化
	nct=0;//边双数归零
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	
	int t;
	cin>>t;
	while(t--) solve();
	
	return 0;
}
```

## 尾声

这篇题解到这里就结束了。若有不妥之处，还请批评指正。**再次建议大家尝试用 $nct=1$ 时的做法通过整道题目，而非本题解中使用的整体做法。**

感谢您的阅读！

---


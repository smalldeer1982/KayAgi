# 闪耀之塔

## 题目描述

闪耀之塔是一棵节点结点从 $1\sim 2^n -1$ 编号，以 $1$ 为根，共有 $n$ 层的满二叉树。

非叶子节点节点 $i$ 的左右儿子的编号分别为 $i\times2$ 和 $i \times 2 +1$。

多萝茜需要给这颗树上所有节点附上一个权值。

每个节点的权值取值范围为 $[1,2^n-1]$，且要保证互不相同。

定义 $S(u)$ 为 $u$ 节点的所有儿子的集合，$val_u$ 表示节点 $u$ 的权值。

每个节点有一个能量值 $f(u)$，其可表示为：

$$f(u)= val_u + \sum_{v\in S(u) }f(v) $$

她想知道在保证 $ \sum_{i = 1}^{2^n-1} f(i)$ 取得最大值时，对于编号为 $p$ 的节点其 $f(p)$ 的最大值是多少。
询问的答案需要对 $10^9+7$ 取模。

## 说明/提示

**【数据范围】**

对于所有测试数据，保证：

- $1 \leq k\leq n \leq 10^{12}$；
- $1 \leq q\leq 1000$；
- $1 \leq k\leq 10^4$。

| 测试点 | $n\leq$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $2$ | 无 |
| $2$ | $10$ | 无 |
| $3\sim5$ | $5000$ | 无 |
| $6$ | $10^5$ | 无 |
| $7$ | $10^8$ | A |
| $8 \sim 10$ | $10^{12}$ | 无 |

特殊性质 A：保证任意一组的询问都有 $k = 1$。


## 样例 #1

### 输入

```
2 1
2
11```

### 输出

```
3```

## 样例 #2

### 输入

```
10 3
4
1001
8
10110110
3
111```

### 输出

```
84582
5362
163710```

# 题解

## 作者：wangyizhi (赞：3)

[**题目传送门**](https://www.luogu.com.cn/problem/P11410)

非常好的数学题。

提供一种稍微不同一点的做法。

## 题目分析

首先我们肯定要贪心地将每一层上最大的那几个放在这个子树内。

令 $x=2^k$，则这颗子树大概长这样：

```text
k  :        x-1
           /    \
          /      \
         /        \
k+1:   2x-2      2x-1
       /  \      /  \
k+2: 4x-1 4x-2  4x-3 4x-4
```

###### ~~蒟蒻不会画图，巨佬轻喷。~~

我们对含 $x$ 的项与常数项分开考虑。

对于含 $x$ 的项，**子树**第 $i$ 层（从 $0$ 开始记）的系数为 $4^i$。

用等比数列求和公式可以得出这一部分的答案为
$$$\sum_{i=0}^{n-k}4^ix=2^k\frac{4^{n-k}-1}{3}$$$

设**子树**的第 $i$ 层（从 $0$ 开始记）上**减去的数**的和为 $f_i$。则 $f_0=1$。

对于第 $i+1$ 层，就是把第 $i$ 层的乘以 $2$ 后加上每个右子树加的 $1$，因此 $f_{i+1}=2f_i+2^i$。

然后我们把它展开，可以得到：$f_{i+1}=2^{i-1}+2^{2i-1}$。

将它分成两块分别用等比数列求和再整理亿下，我们就得到了一个美丽的柿子：

$$$\sum_{0}^{n-k}f_{i}=\frac{(2^{n-k+1}+4)(2^{n-k+1}-1)}{6}$$$

因此答案就是 $2^k\frac{4^{n-k}-1}{3}-\frac{(2^{n-k+1}+4)(2^{n-k+1}-1)}{6}$。

做完了。

## AC Code

```cpp
#include<iostream>
using namespace std;
using ll=long long;
using ld=long double;
const ll mod=1e9+7;
ll qpow(ll a,ll b)
{
	if(b<0) return 0;
	if(!b) return 1;
	else if(b==1) return a%mod;
	ll res=qpow(a,b>>1);
	if(b&1) return res*res%mod*a%mod;
	else return res*res%mod;
}
inline ll sum(ll a,ll q,ll n)
{return 1ll*a*(qpow(q,n)-1+mod)%mod*qpow(q-1,mod-2)%mod;}
inline int inv(int x){return qpow(x,mod-2);}
signed main()
{
	char c;
	ll n,q;
	cin>>n>>q;
	while(q--)
	{
		ll k;
		cin>>k;
		for(int i=1;i<=k;i++) cin>>c;
		cout<<(sum(qpow(2,k),4,n-k+1)-(qpow(2,n-k+1)+4)%mod*(qpow(2,n-k+1)-1+mod)%mod*inv(6)%mod+mod)%mod<<"\n";
	}
	return 0;
}
```

#### 后记

对于常数项的柿子，其实你也可以手算几个小的然后 $OEIS$。

$f$ : [$A007582$](https://oeis.org/A076024)。

$f$ 的前缀和 : [$A076024$](https://oeis.org/A076024)。

---

## 作者：Sunrise_beforeglow (赞：2)

挺好的一道数学题。

首先我们来看这个柿子：

定义 $son_u$ 表示以节点 $u$ 为祖先的节点集合。 

$$\sum_{i=1}^{2^n-1}\sum_{j\in son_i}val_j$$

要使这个这个柿子最大，我们可以拆开它，定义 $dep_u$ 表示节点 $u$ 的深度。原柿为：

$$\sum_{i=1}^{2^n-1}val_i\cdot dep_i$$

于是，深度越大的点，权值越大。第 $i$ 层的点，取值范围既是 $[2^{i-1},2^i-1]$ 。

在第 $i$ 层取 $k$ 个点，权值既是：

$$\sum\limits_{x=2^i-k}^{2^i-1}x$$

用等差数列求和公式算一下，就是 $\dfrac{k(2^{i+1}-k-1)}{2}$。

于是，第 $k$ 层节点最大能量值 $f(k)$ 既为：

$$\sum_{i=k}^n\dfrac{2^{i-k}(2^{i+1}-2^{i-k}-1)}{2}$$

拆一下，就得到了：

$$\dfrac{\sum\limits_{i=k}^n(2^{2i-k+1}-2^{2i-2k}-2^{i-k})}{2}$$

那么这个柿子怎么解决呢？我们可以将它拆成三部分。

1. $\sum\limits_{i=k}^n2^{2i-k+1}$

可以转化为 $\dfrac{\sum\limits_{i=k}^n4^i}{2^{k-1}}$。

而 $\sum\limits_{i=k}^n4^i=\dfrac{4^{n+1}-4^k}{3}$。

光速幂预处理即可。

2. $\sum\limits_{i=k}^n2^{2i-2k}$

转化为 $\dfrac{\sum\limits_{i=k}^n4^i}{2^{2k}}$。

而 $\sum\limits_{i=k}^n4^i=\dfrac{4^{n+1}-4^k}{3}$。

光速幂预处理即可。

3. $\sum\limits_{i=k}^n2^{i-k}$

转化为 $\dfrac{\sum\limits_{i=k}^n2^i}{2^{k}}$。

而 $\sum\limits_{i=k}^n2^i=2^{n+1}-2^k$。

光速幂预处理即可。

最后的代码环节：


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int M=1e9+7;
const int len=1e6;
const int N=1e6+5;
int inv(int x)
{
    if(x==1)return 1;
    return (M-M/x)*inv(M%x)%M;
}
int b[N],g[N],B[N],G[N],n,q,k;
string p;
void init()
{
    b[0]=B[0]=g[0]=G[0]=1;
    for(int i=1;i<=len;i++)
    {
        b[i]=b[i-1]*2%M;
        B[i]=B[i-1]*4%M;
    }
    for(int i=1;i<=len;i++)
    {
        g[i]=g[i-1]*b[len]%M;
        G[i]=G[i-1]*B[len]%M;
    }
}
int query(int x)
{
    int q=x/len,r=x%len;
    return g[q]*b[r]%M;
}
int query_4(int x)
{
    int q=x/len,r=x%len;
    return G[q]*B[r]%M;
}
signed main()
{
    init();
    cin>>n>>q;
    while(q--)
    {
        cin>>k>>p;
        int sum1=(query_4(n+1)-query_4(k)+M)%M;
        sum1=sum1*inv(3)%M;
        sum1=sum1*inv(query(k-1))%M;
        int sum2=(query_4(n+1)-query_4(k)+M)%M;
        sum2=sum2*inv(3)%M;
        sum2=sum2*inv(query(2*k))%M;
        int sum3=(query(n+1)-query(k)+M)%M;
        sum3=sum3*inv(query(k))%M;
        int sum4=(sum1-sum2-sum3+M+M)%M;
        cout<<sum4*inv(2)%M<<endl;
    }
    return 0;
}
```
讲了这么多，点个赞再走吧。

---

## 作者：Acit (赞：2)

提供一种不用矩阵的解法。

## **思路**

不难发现题目中的 $f(u)$ 即为 $u$ 子树上所有点的权值和，于是我们可以得出对于一个深度为 $d$ 的节点，在结算 $f$ 总和时，其会被计算 $d$ 次。

题目要求 $\sum_{i=1}^{2^n-1} f(i)$ 最大，那么我们应当贪心地将较大的数填到深度较大的节点上，进一步思考可以发现第 $i$ 层所填的数的范围为 $[2^{i-1},2^i-1]$。

下面回归题目：字符串 $p$ 并不重要，因为我们要填充的是一颗根节点深度为 $k$ 的完全二叉子树，考虑对于第 $i$ 行 $ (k\le i \le n)$，我们要填充 $2^{i-k}$ 个数，那么这些数必然都在 $[2^i-2^{i-k},2^i-1]$ 之间，即第 $i$ 行的权值和为 $\Large\frac{({2^i-2^{i-k}+2^i-1})2^{i-k}}{2}$。

根据上面得出的结论，我们知道答案应为 $$\Large\sum_{i=k}^n\frac{({2^i-2^{i-k}+2^i-1})2^{i-k}}{2}$$。  

拆开，得到 $\Large\frac{\sum_{i=k}^{n}2^{2i-k+1}-2^{2i-2k}-2^{i-k}}{2}$。

分子上每一项都可以预处理，本文使用光速幂计算，时间复杂度 $O(\sqrt{n}+q)$。

## **Code**


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,q,k,ans;
const int N=2e6+10,MOD=1e9+7,LEN=2e6;
//LEN为块长，可根据n调整
int mi1[N],mi2[N],sum[N];
int summi1[N];
int summi2[N];
void pre(){
	mi1[0]=1;
	for(int i=1;i<=LEN;i++)mi1[i]=mi1[i-1]*2%MOD;
	mi2[0]=1;
	for(int i=1;i<=LEN;i++)mi2[i]=mi2[i-1]*mi1[LEN]%MOD;
}
int calc(int x){
	x%=(MOD-1);
	return mi1[x%(LEN)]*mi2[x/LEN]%MOD;
}
void pre2(){
	for(int i=1;i<=LEN/2;i++)summi1[i]=(summi1[i-1]+mi1[i<<1])%MOD;
	//2**2+2**4+2**6+...+2**LEN
	for(int i=1;i<=LEN;i++){
		summi2[i]=summi2[i-1]*mi1[LEN]%MOD+summi1[LEN/2];
	}
}
int calc2(int u){
	//1+2**2+2**4+2**6+..+2**u
	int x=u;
	int s=summi2[x/LEN];
	x%=LEN;
	(s+=summi1[x>>1]*(calc(u/LEN*LEN))%MOD)%=MOD;
	return (s+1)%MOD;
}
string s;
void work(){
	cin>>k>>s;
	ans=0;
	int he1=calc(n-k+1)-1;//分子第三项
	int he2=calc2(2*n-2*k);//分子第二项
	int he3=((calc2(2*n)-calc2(2*k-2))%MOD+MOD)%MOD;
	he3*=calc(MOD-k);
	he3%=MOD;//分子第一项
	int sum=((he3-he2-he1)%MOD+MOD)%MOD;
	sum=sum*calc(MOD-2)%MOD;
	cout<<sum<<endl;
}
signed main(){
	ios::sync_with_stdio(0);
	pre();
	pre2();
	cin>>n>>q;
	while(q--)work();
	return 0;
}
```

---

## 作者：szh_AK_all (赞：2)

这题比较好想。

首先明确如何让 $\sum f$ 最大。对于一个在第 $x$ 层的节点 $i$，容易发现其对总答案会产生 $val_i\times x$，这告诉我们，我们应该贪心的将大的值放在层数大的节点上，既第 $i$ 层的节点所放的权值为 $2^i-1\sim 2^{i-1}$，至于每层所放权值的顺序是随意的。

再考虑到每次询问，相当于是要考虑 $p$ 号节点的子树。对于每一层，由于其顺序是随意的，所以在贪心时，我们尽量让 $p$ 号节点的子树所包含的节点尽量放上大的权值，即对于第 $i$ 层，从 $2^i-1$ 这个值开始放，具体放到哪个数字则看其包含的节点数量。

朴素的做法是，枚举每一层，看其贪心的最大贡献是多少，然后发现对于每一层，它的式子是可以用等比数列优化的，于是这题便做出来了。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int mod = 1e9 + 7;

int qpow(int a, int b) {
	b %= (mod - 1);
	int ans = 1;
	while (b) {
		if (b % 2 == 1)
			ans = 1LL * ans * a % mod;
		b /= 2;
		a = 1LL * a * a % mod;
	}
	return ans;
}

int bi(int a1, int q, int n) {
	int ans = a1 * (1 - qpow(q, n)) % mod * qpow(1 - q, mod - 2);
	ans = (ans % mod + mod) % mod;
	return ans;
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	int n, q;
	cin >> n >> q;
	while (q--) {
		int k;
		cin >> k;
		for (int i = 1; i <= k; i++) {
			char c;
			cin >> c;
		}
		int ans = 0;
		int ceng = n - k, now = n;
		ans = bi(qpow(2, n - ceng + 2 * 1), 4, ceng) - bi(qpow(2, 1), 4, ceng) - bi(qpow(2, 0), 2, ceng);
		now -= ceng;
		ans += (qpow(2, now) - 1), ans %= mod;
		ans = (ans % mod + mod) % mod;
		cout << ans << "\n";
	}
}
```

---

## 作者：Amoribus (赞：1)

省流：**本题解是此题所有题解中复杂度最高，最无脑的做法。** 从算法角度上来说，你只要会一般的快速幂和逆元；从思维难度上说，此题解不需要过高的数学推导功底。建议降黄。

普及组题就要用普及组做法！

时间复杂度 $O(k\log n+q)$。

容易注意到深度相同的点答案相同。

设 $f_i$ 表示深度为 $i$ 时的答案。

则 $f_1$ 为整棵树的数字和。即 $\dfrac{(2^n-1)\times 2^n}{2}$。

考虑一个深度为 $i$ 节点的左子树和右子树总和的差 $T(i)$，应该是 $1^2+2^2+4^2+8^2+\cdots$ 的形式，即 $4^0+4^1+4^2+4^3+\cdots +4^{n-i}$ 的形式，用错位相减法可解。

直接递推即可，有 $f_i=\dfrac{f_{i-1}-(2^{i-1}-1)-T(i)}{2}+T(i)$，其中 $T(i)=\dfrac{4^{n-i+1}-1}{3}$。

---

## 作者：jojo222 (赞：1)

### 步骤 1：贪心
显然，节点 $u$ 对能量和的贡献是 $dep_u\times val_u$（$dep_u$ 指 $u$ 的深度），第 $i$ 层应该放 $2^{i-1}$ 至 $2^i-1$ 的权值。

要使点 $p$ 能量最大，$p$ 子树中每一个节点都要尽量大，第 $i$ 层应该放 $2^i-2^{i-k}$ 至 $2^i-1$ 的权值（一共 $2^{i-k}$ 个权值）。
### 步骤 2：公式推导
数学大佬们可以自行跳过。
$$\begin{aligned}\sum_{i=k}^{n}\sum_{j=2^{i}-2^{i-k}}^{2^{i}-1}j&=\sum_{i=k}^{n}\frac{\left(2^{i+1}-2^{i-k}-1\right)\cdot2^{i-k}}{2}\\&=\sum_{i=k}^{n}\frac{2^{2i-k+1}-2^{2\left(i-k\right)}-2^{i-k}}{2}\\&=\frac{1}{2}\sum_{i=k}^{n}\left(2^{2i-k+1}-4^{i-k}-2^{i-k}\right)\\&=\frac{1}{2}\sum_{i=0}^{n-k}\left(2^{2i+k+1}-4^{i}-2^{i}\right)\\&=\frac{1}{2}\left(\sum_{i=0}^{n-k}2^{2i+k+1}-\sum_{i=0}^{n-k}4^{i}-\sum_{i=0}^{n-k}2^{i}\right)\\&=\frac{1}{2}\left(\frac{\left(2^{k+1}-1\right)\left(4^{n-k+1}-1\right)}{3}-2^{n-k+1}+1\right)\\\end{aligned}$$
除法逆元求解即可。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M = 1e9 + 7;
int q, k;
int64_t n;
string s;
int qpow(int x, int64_t y)
{
	int mu = x, ans = 1;
	while(y)
	{
		if(y & 1) ans = 1ll * ans * mu % M;
		mu = 1ll * mu * mu % M, y >>= 1;
	}
	return ans;
}
int main()
{
	cin >> n >> q;
	while(q--)
	{
		cin >> k >> s;
		cout << 500000004ll * (333333336ll * (qpow(2, k + 1) - 1) % M * (qpow(4, n - k + 1) - 1) % M + M - qpow(2, n - k + 1) + 1) % M << endl;
	}
	return 0;
}
```

---

## 作者：suyi1111 (赞：1)

简单推式子题目。

首先，显然贪心，将每层最大的几个点放在点 $p$ 的子树中，显然我们只需要 $p$ 的层数即可。

注：以下 $k,n$ 的含义与题目相同。

显然将 $p$ 的子树与原树前 $n-k+1$ 层相减，可得同一层的差值相等，不同的层祖先的差值是儿子的二分之一。

同一层的差值相等显然，下证明祖先的差值是儿子的二分之一。

对于子树中的层 $i$，其最后一个数字假设为 $2^x-1$。则下一层的最后一个数字是 $2^{x+1}-1$。父亲相减得：$2^x-2^i$，儿子相减得：$2^{x+1}-2^{i+1}=2\times(2^x-2^i)$，再由同一层的差值相等，命题得证。

由于每一层的差值数量为前一层的两倍，因此每一层差值之和为一个以四为公比的等比数列。

我们只需要第一层的差值即可求出后面的差值，第一层的差值显然为 $2^k-1-1=2^k-2$，由等比数列求和公式与等差数列求和公式得答案为：$\frac{2^k\times(2^k-1)}2+\frac{(2^k-2)\times(1-4^{n-k+1})}{-3}$。

利用逆元即可得到最终公式：${2^k\times(2^k-1)}\times2^{MOD-2}+(2^k-2)\times(1-4^{n-k+1})\times(-3)^{MOD-2}$。

代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
#define mo 1000000007
using namespace std;
int n,q;
int qp(int x,int y,int z){
	if(y==0)return 1;
	if(y==1)return x%z;
	int l=qp(x,y>>1,z);
	if(y&1){
		return l*l%mo*x%mo;
	}else return l*l%mo;
}
main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>q;
	while(q--){
		int k;
		cin>>k;
		string s;
		cin>>s;
		cout<<(((qp(2,n-k+1,mo)-1)*(qp(2,n-k+1,mo))%mo*(qp(2,mo-2,mo))%mo+((qp(2,k,mo)-2)*(1-qp(4,n-k+1,mo))%mo*(qp(-3,mo-2,mo))%mo+mo)%mo)%mo+mo)%mo<<'\n';
	}
	return 0;
} 
```

---

## 作者：Genius_Star (赞：1)

简单计数题。

### 思路：

考虑什么样的方案数最优的？

容易发现，由于是满二叉树，所以对于第 $i$ 层的点的贡献系数是一样的，且深度越深，贡献系数越大；于是只需要满足第 $i$ 层的点的权值是 $[2^{i - 1}, 2^i)$ 即可。

于是可以得到答案的式子：

$$\begin{aligned} LHS &= \sum_{i = dep}^n Sum
(2^i - 2^{i - m}, 2^i - 1) \\ &= \frac{1}{2} \sum_{i = dep}^n (2^{i + 1} - 2^{i - m} - 1)2^{i - m}  \\ &= \frac{1}{2} \sum_{i = dep}^n (2^{2i + 1 - m} - 2^{2i - 2m}  - 2^{i - m}) \\ &= \frac{1}{2} \left( \frac{2 S^2(dep, n)}{2^m} - \frac{S^2(dep, n)}{2^{2m}} -\frac{S(dep, n)}{2^m}\right)\end{aligned}$$

这里：

$$S^2(l, r) = \sum_{i = l}^r 2^{2i} = S^2(r) - S^2(l -1)$$

$$S^2(n) = \sum_{i = 0}^n 4^i = \frac{4^{n + 1} - 1}{3}$$

$$S(l,r) = \sum_{i = l}^r 2^i = S(r) - S(l - 1)$$

$$S(n) = \sum_{i = 0}^n 2^i = 2^{n + 1} - 1$$

使用快速幂即可做到单次 $O(\log n)$。

### 完整代码：

```cpp
 #include<bits/stdc++.h>
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define popcnt(x) __builtin_popcount(x)
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 1e4 + 10, mod = 1e9 + 7;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
ll n, q, m, na, nb, ans, inv3, inv2 = (mod + 1) >> 1;
char s[N];
inline int qpow(int a, ll b){
	int ans = 1;
	while(b){
		if(b & 1)
		  ans = 1ll * ans * a % mod;
		a = 1ll * a * a % mod;
		b >>= 1;
	}
	return ans;
}
inline int S(ll n){
	return qpow(2, n + 1) - 1;
}
inline int S(ll l, ll r){
	return (S(r) - S(l - 1) + mod) % mod;
}
inline int SS(ll n){
	return 1ll * (qpow(4, n + 1) - 1) * inv3 % mod;
}
inline int SS(ll l, ll r){
	return (SS(r) - SS(l - 1) + mod) % mod;
}
bool End;
int main(){
	// freopen("hate.in", "r", stdin);
	// freopen("hate.out", "w", stdout);
	inv3 = qpow(3, mod - 2);
	n = read(), q = read();
	while(q--){
		ans = 0;
		m = read();
		scanf("%s", s + 1);
		int x = SS(m, n);
		ans = 2ll * x % mod * qpow(inv2, m) % mod;
		ans = (ans - 1ll * x * qpow(inv2, m << 1) % mod + mod) % mod;
		ans = (ans - 1ll * S(m, n) * qpow(inv2, m) % mod + mod) % mod;
		ans = 1ll * ans * inv2 % mod;
		write(ans);
		putchar('\n');
	}
	//cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：Yesod (赞：1)

这题首先考虑使 $ \sum_{i=1}^{2^n-1} f(i) $  最大，因为第 $ i $ 层节点 $ j $ 的贡献为 $ i \times val_j $ 所以可以贪心将大的数排在深度大的位置，也就是第 $ i $ 层任意放 $ [2^{i-1},2^i-1] $ 范围内的数。

其次考虑让 $ f(p) $ 最大，因为每层的数可以任意放，所以若第 $ i $ 层要放 $ j $ 个数那一定是放 $ [2^i-j,2^i-1] $ 这些数，可以列出一个 dp 式子，设 $ dp_i $ 为第 $ i $ 层放的数的总和，假如第 $ i $ 层放了 $ j $ 个数，第 $ i + 1 $ 层放的数为 $ 2 \times j $ 个数，发现第 $ i $ 层放的 $ j $ 个数为 $ [2^i-j,2^i-1] $ 这些数，而 $ i + 1 $ 层放的 $ 2 \times j $ 个数就为 $ [2^{i+1}-j \times 2,2^{i+1}-1] $ 发现转移式子为 $ dp_{i+1} = dp_{i} \times 4 + j $，$ j $ 为第 $ i $ 层放的数量。但这东西显然过不了，考虑优化，这个 dp 显然可以矩阵优化，于是最后的时间复杂度为 $ O(q\log^3n) $。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
long long n,q,k;
string w;
struct node{
	long long a[5][5];
}a,d;
long long ksm(long long i,long long j)
{
	long long ans=1;
	while(j)
	{
		if(j%2==1) ans=(ans*i)%mod;
		i=(i*i)%mod;
		j/=2;
	}
	return ans;
}
node cf(node i,node j)
{
	node z;
	for(int ii=1;ii<=3;++ii)
		for(int jj=1;jj<=3;++jj)
			z.a[ii][jj]=0;
	for(int ii=1;ii<=3;++ii)
		for(int jj=1;jj<=3;++jj)
			for(int zz=1;zz<=3;++zz)
				z.a[ii][jj]=(z.a[ii][jj]+i.a[ii][zz]*j.a[zz][jj])%mod;
	return z;
}
long long ksm1(long long j)
{
	while(j)
	{
		if(j%2==1) a=cf(a,d);
		j/=2;
		d=cf(d,d);
	}
	return a.a[1][1];
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<=q;++i)
	{
		cin>>k>>w;
		d.a[1][1]=1;
		d.a[1][2]=0;
		d.a[1][3]=0;
		d.a[2][1]=4;
		d.a[2][2]=4;
		d.a[2][3]=0;
		d.a[3][1]=1;
		d.a[3][2]=1;
		d.a[3][3]=2;
		a.a[1][1]=a.a[1][2]=(ksm(2,k)-1+mod)%mod;
		a.a[1][3]=1;
		for(int j=1;j<=3;++j)
			a.a[2][j]=a.a[3][j]=0;
		cout<<ksm1(n-k)<<'\n';
	}
	return 0; 
}

---

## 作者：ELECTRODE_kaf (赞：1)

- 深度越大的点在整棵树的总价值中被计算的次数越多，所以最佳的填数方案应该是在按照每个点的编号赋值的基础上。
- 同深的点被计算次数相同，所以可以任意交换一层上填的数。

根据题意，所求即为点 $p$ 的子树所填数的和。所以应该把每层中最大的数移到这个子树中。设点 $p$ 的深度为 $d$，答案即为：

$$\sum_{i=d}^n [\frac{(2^i-1)+(2^i-1-2^{i-d}+1)}{2}\cdot 2^{i-d}]$$

化简再分组，用等比数列求和公式可以化简为：

$$\frac{2^{2n-d+2}-2^d-2^{2n-2d+1}}{3}-2^{n-d}+\frac{2}{3}$$

预处理 $3$ 的逆元，套用快速幂即可通过。

```cpp
ll n,q;
const ll mod=1e9+7,inv3=333333336;

ll qp(ll x) {
	if(x==0) return 1;
	else if(x==1) return 2;
	else {
		ll tmp=qp(x/2);

		if(x%2) return tmp*tmp%mod*2%mod;
		else return tmp*tmp%mod;
	}
}

ll cal(string u) {
	ll d=u.size();
//	cout<<"d="<<d<<'\n';
//	pause;
	return ((inv3*(((qp(2*n-d+2)+mod-qp(d))%mod
		+mod-qp(2*n-2*d+1))%mod)%mod
		+mod-qp(n-d))%mod+inv3*2%mod)%mod;
}

int main() {
	sync_off;
	cin>>n>>q;

	count(q) {
		string in;
		cin>>in>>in;
		reverse(in.begin(),in.end());
		cout<<cal(in)<<'\n';
	}
}
```

预处理逆元用到的表生成代码：

```cpp
ll invx,invy;

void exgcd(ll a,ll b){
	if(b==0){
		invx=1;
		invy=0;
		return;
	}
	exgcd(b,a%b);
	ll x1=invy,y1=invx-a/b*invy;
	invx=x1;
	invy=y1;
}

ll calinv(ll a,ll p){
	exgcd(a,p);
	return (invx%p+p)%p;
}
```

---

## 作者：Siner7 (赞：1)

# P11410 闪耀之塔 题解
~~建议降绿，毕竟NOIP T2考场都没推出来，这题直接秒了。~~

~~咳咳咳。~~

# 思路

进入正题。

首先根据题面，我们不难得出，$f(u)$ 表示 $u$ 子树的权值和。那么对于 $\sum_{i=1}^{2^{n}-1}f(i)$，深度为 $dep$ 的节点，会被计算 $dep$ 次。

由此，我们贪心地想到，要使 $\sum_{i=1}^{2^{n}-1}f(i)$ 尽可能大，就应让越深的点的权值越大，即第 $i$ 层的权值应该为 $\left[2^{i-1},2^{i}-1 \right]$。同时，因为同一深度的点计算次数相同，所以**同一深度的点互相交换权值对于最大值没有影响**。


那么，对于 $f(u)$ 的最大值具体应该怎么求呢？

根据贪心，对于 $f(u)$ 有贡献的节点，即 $u$ 的子树，应填入尽量大的权值，即第 $i$ 层应填入的权值为，末项为 $2^{i}-1$，长度为 $2^{i-dep(u)+1}$，公差为 $1$ 的等差数列。

将求和式子展开，可以发现等比数列，只需使用快速幂优化，具体计算见代码。

时间复杂度 $\mathcal O(T \log n)$。

# CODE

```cpp
#include<bits/stdc++.h>
#define int long long//不开longlong两行泪
using namespace std;
const int mod=1e9+7;
int ksm(int a,int b){
    int ans=1;
    while(b){
        if(b&1) ans=ans*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return ans;
}
int n,q;
signed main(){
    cin>>n>>q;
    int ny=ksm(3,mod-2);//公比为4的等比数列需要除以3，计算其相应逆元
    while(q--){
        int k;
        string s;
        cin>>k>>s;
        cout<<((ksm(2,k)-1ll)%mod*(ksm(4,n-k+1)-1ll)%mod*ny%mod+mod-(ksm(2,n-k)-1)%mod+2*1ll*(ksm(4,n-k)-1ll)%mod*ny%mod)%mod<<endl;
        //ksm(2,k)-1为节点u的权值
    }
    return 0;//完结撒花！
}
```

---

## 作者：linjunye (赞：0)

不错的题，这里给一个矩阵优化 DP 的做法。

首先我们看每一个点的贡献，容易发现第一层的点贡献是 $1$，第二层是 $2$，依次类推。

所以，第一层放 $1$，第二层放 $2$ 和 $3$，第 $k$ 层放 $2^k$ 到 $2^{k+1}-1$ 的数最优。

然后关注我们的查询。

我们发现，这个点的深度就是 $k$（我们定义第一个点的深度为 $1$），所以答案和这个点是什么不重要，重要的是它的深度。

那么，我们相当于选择一个 $n-k+1$ 层的满二叉树进行放数。

设 $dp_i$ 表示选择一个 $n-i+1$ 层的满二叉树进行放数，不难得到递推式：$dp_i=2dp_{i-1}-\sum_{j=0}^{i-2}(2^j)^2+2^{n-i+1}+1=2dp_{i-1}-\sum_{j=0}^{i-2}2^{2j}+2^{n-i+1}+1$。

注意到 $\sum_{j=0}^{i-2}2^{2j}$ 也是可以递推的，预处理之后，你就拿到了 $60$ 分。

接下来怎么做？

我们现在不得不定义一些东西了。

我们记 $mm_i$ 表示 $2^{2i}$，递推式：$mm_i=4mm_{i-1}$

我们记 $sum_i$ 表示 $\sum_{j=0}^{i-2}2^{2j}$，递推式：$sum_i=sum_{i-1}+2^{2i-2}=sum_{i-1}+mm_{i-1}$。

我们记 $p_i$ 表示 $2^{n-(i+1)+1}=2^{n-i}$，递推式：$p_i=p_{i-1}\times inv_2$，其中 $inv_2$ 表示 $2$ 的逆元。

那么 $dp_i$ 可以表示成：$dp_i=2dp_{i-1}-sum_{i-1}+inv_{i-1}+1$。

上述的递推式可以放在一个矩阵中进行转移，转移式子为：

$$
\begin{bmatrix}dp_i\\sum_i\\p_i\\mm_i\\1\end{bmatrix}=\begin{bmatrix}2&-1&1&0&1\\0&1&0&1&0\\0&0&inv_2&0&0\\0&0&0&4&0\\0&0&0&0&1\end{bmatrix}\times\begin{bmatrix}dp_{i-1}\\sum_{i-1}\\p_{i-1}\\mm_{i-1}\\1\end{bmatrix}
$$

时间复杂度：$O(qV^3\log n)$，其中 $V$ 是矩阵大小，你可以认为 $V=5$。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int M=5;
const int mod=1e9+7;
struct matrix{
	int n,a[M][M];
	matrix(int _n){
		n=_n;
		memset(a,0,sizeof(a));
	}
	void print(){
		for(int i=0;i<n;i++,cout<<"\n")
			for(int j=0;j<n;j++)
				cout<<a[i][j]<<" ";
		cout<<"\n";
		return;
	}
	friend matrix operator * (matrix a,matrix b){
		int n=a.n;
		matrix c(n);
		for(int k=0;k<n;k++)
			for(int i=0;i<n;i++)
				for(int j=0;j<n;j++)
					c.a[i][j]=(c.a[i][j]+a.a[i][k]*b.a[k][j])%mod;
		return c;
	}
	friend matrix operator ^ (matrix a,int b){
		int n=a.n;
		matrix z(n);
		for(int i=0;i<n;i++)z.a[i][i]=1;
		while(b){
			if(b&1)z=z*a;
			a=a*a;
			b>>=1;
		}
		return z;
	}
};
int ksm(int a,int b){
    int z=1;
    while(b){
        if(b&1)z=z*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return z;
}
int inv(int x){
    return ksm(x,mod-2);
}
const int inv2=(mod+1)/2;
int n,k,q;
string s;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
    cin>>n>>q;
    matrix A(5),B(5),ans(5);
    B.a[0][0]=0;
    B.a[1][0]=0;
    B.a[2][0]=ksm(2,n);
    B.a[3][0]=1;
    B.a[4][0]=1;
    A.a[0][0]=2;A.a[0][1]=-1;A.a[0][2]=1;A.a[0][3]=0;A.a[0][4]=-1;
    A.a[1][0]=0;A.a[1][1]=1;A.a[1][2]=0;A.a[1][3]=1;A.a[1][4]=0;
    A.a[2][0]=0;A.a[2][1]=0;A.a[2][2]=inv2;A.a[2][3]=0;A.a[2][4]=0;
    A.a[3][0]=0;A.a[3][1]=0;A.a[3][2]=0;A.a[3][3]=4;A.a[3][4]=0;
    A.a[4][0]=0;A.a[4][1]=0;A.a[4][2]=0;A.a[4][3]=0;A.a[4][4]=1;
    while(q--){
        cin>>k;
        cin>>s;
        ans=A;
        ans=ans^(n-k+1);
        ans=ans*B;
        // ans.print();
        cout<<(ans.a[0][0]%mod+mod)%mod<<"\n";
    }
	return 0;
}
/*

*/
```

如果还有不理解的，可以看一下 $60$ 分暴力代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3000010;
const int mod=1e9+7;
const int INF=0x3f3f3f3f3f3f3f3f;
int n,q;
int dp[N];
int sum[N];
int ksm(int a,int b){
    int z=1;
    while(b){
        if(b&1)z=z*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return z;
}
int inv(int x){
    return ksm(x,mod-2);
}
int k;
string s;
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>q;
    for(int i=1;i<=n;i++){
        dp[i]=2*dp[i-1]-sum[i-1]+ksm(2,n-i+1)-1;
        dp[i]=(dp[i]%mod+mod)%mod;
        sum[i]=sum[i-1]+ksm(2,i-1)*ksm(2,i-1)%mod;
        sum[i]%=mod;
    }
    while(q--){
        cin>>k;
        cin>>s;
        cout<<dp[n-k+1]<<"\n";
    }
    return 0;
}
/*

*/
```

---

## 作者：yingxilin (赞：0)

# 题解：P11410 闪耀之塔

[题目入口](https://www.luogu.com.cn/problem/P11410)

我们要想讲讲前置知识——蒙哥马利快速幂模求逆元。

## 前置知识逆元

### 定义

何为逆元？逆元，又称数论倒数。若整数 $a , b$ 满足同余方程 $a \times b \equiv 1 \pmod n$，那么 $a , b$ 互为模 $n$ 意义下的逆元。

### 前置：快速幂

给你三个整数 $a , b , p$，求 $a^b \bmod p$。
如果直接算复杂度太高了，我们考虑优化。

我们知道 $a^b$ 有两种情况，一种是 $n$ 为偶数，一种是 $n$ 为奇数。

因为 $a^{m+n}=a^m \times a^n$，所以当 $n$ 为偶数 $a^n=a^{n/2} \times a^{n/2}$，而当 $n$ 为奇数时，则在此基础上再多乘上一个 $a$ 就可以了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a,b,p;
int qmi(int a,int b,int p){
	int x=1;
	while(b){
		if(b&1) x=x*a%p;
		a=a*a%p;
		b/=2;
	}
	return x;
}
signed main(){
	cin>>a>>b>>p;
	printf("%lld^%lld mod %lld=%lld\n",a,b,p,qmi(a,b,p));
	return 0;
}
```

### 前置：费马小定理

先来讲讲费马小定理。

费马小定理的原始状态：$a^p \equiv a \pmod p$，其中 $a , p$ 互质。

然后，原式 $\Rightarrow a^p - a \equiv 0 \pmod p \Rightarrow a \times (a^{p-1} - 1) \equiv 0 \pmod p \Rightarrow a^{p-1}-1 \equiv 0 \pmod p \Rightarrow a^{p-1} \equiv 1 \pmod p$。

这就是费马小定理的结论，求逆元时常用的。

### 蒙哥马利快速幂模

这个方法的的局限性很大，只有在 $p$ 是质数的情况下才可以使用。

设 $inv(a)$ 是 $a$ 的逆元。由定义得，$inv(a) \times a \equiv 1 \pmod p$。又有费马小定理 $a^{p-1} \equiv 1$，易得 $inv(a) \times a \equiv a^{p-1} \pmod p$。移项，得：$inv(a) \equiv a^{p-2}$。然后这就是蒙哥马利快速幂模算法的一个前提条件：$inv(a) \equiv a^{p-2} \pmod p$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,p;
int qmi(int a,int b,int p){
	int x=1;
	while(b){
		if(b&1) x=x*a%p;
		a=a*a%p;
		b>>=1;
	}
	return x;
}
int main(){
	cin>>a>>p;
	cout<<qmi(a,p-2,p)<<endl;
	return 0;
}
```

## 思路

回到本题，我们来讲讲思路。

首先可得两点性质。

- 深度越大的点贡献越多，所以可以先按照每个点的编号赋值。

- 又因为同深度的点贡献相同，所以同一层上的值可互换。

又因为题目里要求的是 $q$ 的子树值之和，所以要让其子树里的值尽可能在交换同层值时取得更大。

设层数为 $i$，结点 $q$ 的深度为 $d$。

枚举每一层，看其贪心的最大贡献，应填入尽量大的权值，即第 $i$ 层的权值应该为长度为 $2^{i-d+1}$，末项为 $2^{i}-1$，公差为 $1$ 的等差数列。

然后将其展开就会发现一个等比数列，最后得式子 $\frac{2^{2n-d+2}-2^d-2^{2n-2d+1}}{3}-2^{n-d}+\frac{2}{3}$ 由此解决此题。

## code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int qmi(int a,int b){
	int x=1;
	while(b){
		if(b&1) x=x*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return x;
}
int n,q,k;
string s;
signed main(){
//	freopen("yxl.in","r",stdin);
//	freopen("yxl.out","w",stdout);
    cin>>n>>q;
    int inv=qmi(3,mod-2);//计算3的逆元
    while(q--){
        cin>>k>>s;
        printf("%lld\n",((qmi(2,k)-1ll)%mod*(qmi(4,n-k+1)-1ll)%mod*inv%mod+mod-(qmi(2,n-k)-1)%mod+2*1ll*(qmi(4,n-k)-1ll)%mod*inv%mod)%mod);
    }
    return 0;
}
```

OK，完结撒花。

---


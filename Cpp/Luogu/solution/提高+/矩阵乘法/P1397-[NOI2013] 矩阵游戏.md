# [NOI2013] 矩阵游戏

## 题目描述

婷婷是个喜欢矩阵的小朋友，有一天她想用电脑生成一个巨大的 $n$ 行 $m$ 列的矩阵（你不用担心她如何存储）。她生成的这个矩阵满足一个神奇的性质：若用 $F[i,j]$ 来表示矩阵中第 $i$ 行第 $j$ 列的元素，则 $F[i,j]$ 满足下面的递推式:

$$\begin{aligned}
F[1, 1] &= 1 \\
F[i, j] &=a\times F[i, j-1]+b, &j\neq 1 \\
F[i, 1] &=c\times F[i-1, m]+d, &i\neq 1 \\
\end{aligned}$$

递推式中 $a,b,c,d$ 都是给定的常数。

现在婷婷想知道 $F[n,m]$ 的值是多少，请你帮助她。由于最终结果可能很大，你只需要输出 $F[n,m]$ 除以 $10^9+7$ 的余数。


## 说明/提示

【样例1说明】

样例中的矩阵为：

$$\begin{pmatrix}
 1 &  4 &  7 & 10 \\
26 & 29 & 32 & 35 \\
76 & 79 & 82 & 85 \\
\end{pmatrix}$$

### 数据范围

| 测试点编号 | 数据范围 |
| :-: | :-: |
| 1 | $1 \le n,m \le 10$；$1 \le a,b,c,d \le 1000$ |
| 2 | $1 \le n,m \le 100$；$1 \le a,b,c,d \le 1000$ |
| 3 | $1 \le n,m \le 10^3$；$1 \le a,b,c,d \le 10^9$ |
| 4 | $1 \le n,m \le 10^3$；$1 \le a,b,c,d \le 10^9$ |
| 5 | $1 \le n,m \le 10^9$；$1 \le a = c \le 10^9$；$1 \le b = d \le 10^9$ |
| 6 | $1 \le n,m \le 10^9$；$a = c = 1$；$1 \le b,d \le 10^9$ |
| 7 | $1 \le n,m,a,b,c,d \le 10^9$ |
| 8 | $1 \le n,m,a,b,c,d \le 10^9$ |
| 9 | $1 \le n,m,a,b,c,d \le 10^9$ |
| 10 | $1 \le n,m,a,b,c,d \le 10^9$ |
| 11 | $1 \le n,m \le 10^{1\,000}$；$a = c = 1$；$1 \le b,d \le 10^9$ |
| 12 | $1 \le n,m \le 10^{1\,000}$；$1 \le a = c \le 10^9$；$1 \le b = d \le 10^9$ |
| 13 | $1 \le n,m \le 10^{1\,000}$；$1 \le a,b,c,d \le 10^9$ |
| 14 | $1 \le n,m \le 10^{1\,000}$；$1 \le a,b,c,d \le 10^9$ |
| 15 | $1 \le n,m \le 10^{20\,000}$；$1 \le a,b,c,d \le 10^9$ |
| 16 | $1 \le n,m \le 10^{20\,000}$；$1 \le a,b,c,d \le 10^9$ |
| 17 | $1 \le n,m \le 10^{1\,000\,000}$；$a = c = 1$；$1 \le b,d \le 10^9$ |
| 18 | $1 \le n,m \le 10^{1\,000\,000}$；$1 \le a = c \le 10^9$；$1 \le b = d \le 10^9$ |
| 19 | $1 \le n,m \le 10^{1\,000\,000}$；$1 \le a,b,c,d \le 10^9$ |
| 20 | $1 \le n,m \le 10^{1\,000\,000}$；$1 \le a,b,c,d \le 10^9$ |

## 样例 #1

### 输入

```
3 4 1 3 2 6
```

### 输出

```
85
```

# 题解

## 作者：litble (赞：57)

来一发暴力题解吧。

首先看了这道题，感觉这种递推应该要用矩阵乘法。

初始矩阵，记做$A_3$

```cpp
1
1
```

然后对于每一行，有一个转移矩阵$A_1$

```cpp
a b
0 1
```

对于每一列，有一个转移矩阵$A_2$

```cpp
c d
0 1
```

那么转移到最后一行最后一列，就应该是$A_1^{m-1}(A_2A_1^{m-1})(A_2A_1^{m-1})...A_3$

也就是$A_1^{m-1}(A_2A_1^{m-1})^{n-1}A_3$

做到这里，我想，哇塞，这题不就是大水题了吗！可以使用十进制快速幂，这种方法就是若是求$x$的$y$次方，从低位到高位查看$y$十进制下的每一位，这一位为几，就让$ans$乘几个$x$，然后让$x=x^10$，不断这样操作即可。

然后我很高兴地写了十进制式的快速幂，忽然发现时限只有1s，又卡了一发常数，1752ms,AC。

A完后才发现这道题是数学题，我却把它写成了一个暴力题。

```cpp
#include<bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,no-stack-protector")
//卡常之去掉栈保护，优化效果非常明显
#define Res register
//卡常之register，优化效果不太明显
typedef long long LL;
const int mod=1000000007;
struct node{int n,m,t[3][3];}a1,a2;
int qm(int x) {return x>=mod?x-mod:x;}//卡常之加法取模操作，优化效果非常明显
int a,b,c,d,nl,ml;char n[1000005],m[1000005];
inline node operator * (const node &a,const node &b) {
	node c; c.n=a.n,c.m=b.m;
	c.t[1][1]=qm(1LL*a.t[1][1]*b.t[1][1]%mod+1LL*a.t[1][2]*b.t[2][1]%mod);
	c.t[1][2]=qm(1LL*a.t[1][1]*b.t[1][2]%mod+1LL*a.t[1][2]*b.t[2][2]%mod);
	c.t[2][1]=qm(1LL*a.t[2][1]*b.t[1][1]%mod+1LL*a.t[2][2]*b.t[2][1]%mod);
	c.t[2][2]=qm(1LL*a.t[2][1]*b.t[1][2]%mod+1LL*a.t[2][2]*b.t[2][2]%mod);
    //卡常之循环展开，优化效果非常明显
	return c;
}
inline node ksm(node x,char *y) {//十进制快速幂
	int ll=strlen(y+1);node re;
	re.t[1][1]=re.t[2][2]=1,re.t[1][2]=re.t[2][1]=0,re.n=re.m=2;
	for(Res int i=ll;i>=1;--i) {
		node tt=x;
		if(y[i]=='9') {tt=tt*tt,tt=tt*tt,tt=tt*tt,tt=tt*x,re=re*tt;}
		else if(y[i]=='8') {tt=tt*tt,tt=tt*tt,tt=tt*tt,re=re*tt;}
		else for(Res int j=1;j<=y[i]-'0';++j) re=re*x;
		node tmp=x; x=x*x,x=x*x,x=x*x,x=x*tmp,x=x*tmp;
	}
	return re;
}
int main()
{
	scanf("%s",n+1),scanf("%s",m+1),scanf("%d%d%d%d",&a,&b,&c,&d);
    nl=strlen(n+1),ml=strlen(m+1);
    for(Res int i=nl;i>=1;--i)//n,m分别减1
    	if(n[i]=='0') n[i]='9';
    	else {n[i]=n[i]-1;break;}
    for(Res int i=ml;i>=1;--i)
    	if(m[i]=='0') m[i]='9';
    	else {m[i]=m[i]-1;break;}
    a1.n=a1.m=a2.n=a2.m=2;//用上述公式进行计算
    a1.t[1][1]=a,a1.t[1][2]=b,a1.t[2][2]=1,a1=ksm(a1,m);
    a2.t[1][1]=c,a2.t[1][2]=d,a2.t[2][2]=1;
    a2=a2*a1;a2=a1*ksm(a2,n);
    printf("%d\n",qm(a2.t[1][1]+a2.t[1][2]));
    return 0;
}
```

---

## 作者：bulijoijiodibuliduo (赞：30)

这道题直接 $\operatorname{mod} \varphi(p)$ 的题解很多都是错的并且没有给出证明。

## 解题思路
首先这道题等价于求 $(A^{m-1}B)^{n-1}A^{m-1}$。

可以直接用高精度的矩阵快速幂，但是这里不讲。  

不难发现在计算过程中矩阵一定是 $\begin{bmatrix}a&b\\0&1\end{bmatrix}$ 的形式。  

所以现在问题转化为了计算型为 $A=\begin{bmatrix}a&b\\0&1\end{bmatrix}$ 的矩阵快速幂。  

### Part1
考虑将矩阵对角化，也就是找到一个矩阵 $P$ 满足 $PAP^{-1}=B$ 是一个对角矩阵，也就是说:
$$
B=
\begin{bmatrix}
  \lambda_1&0\\
  0&\lambda_2
\end{bmatrix}
$$

那么 $A^x=P^{-1}B^xP$。

证明：
$$
\begin{aligned}
  P^{-1}B^xP&=P^{-1}(PAP^{-1})^xP\\
  &=P^{-1}((PAP^{-1})(PAP^{-1})\dots(PAP^{-1}))P\\
  &=P^{-1}(PAP^{-1}PAP^{-1}\dots PAP^{-1})P\\
  &=P^{-1}(PA^xP^{-1})P\\
  &=P^{-1}PA^xP^{-1}P\\
  &=A^x
\end{aligned}
$$

接下来证明 $A^x=A^{x\operatorname{mod} \varphi(p)}\pmod{p}$。

只要证明 $B^x=B^{x\operatorname{mod} \varphi(p)}\pmod{p}$ 即可，显然：

$$
\begin{aligned}
  B^x&=
  \begin{bmatrix}
    \lambda_1&0\\
    0&\lambda_2
  \end{bmatrix}^x\\
  &=
  \begin{bmatrix}
    \lambda_1^x&0\\
    0&\lambda_2^x
  \end{bmatrix}\\
  &=
  \begin{bmatrix}
    \lambda_1^{x\operatorname{mod} \varphi(p)}&0\\
    0&\lambda_2^{x\operatorname{mod} \varphi(p)}
  \end{bmatrix}\\
  &=
  \begin{bmatrix}
    \lambda_1&0\\
    0&\lambda_2
  \end{bmatrix}^{x\operatorname{mod} \varphi(p)}
\end{aligned}
$$

### Part2
现在来考虑什么时候能找到这么一个 $P$，先进行化简：
$$
\begin{aligned}
  PAP^{-1}&=
  \begin{bmatrix}
    \lambda_1&0\\
    0&\lambda_2
  \end{bmatrix} \\
  PA&=
  \begin{bmatrix}
    \lambda_1&0\\
    0&\lambda_2
  \end{bmatrix}P \\
\end{aligned}
$$
设 $P=\begin{bmatrix}p_{1,1}&p_{1,2}\\p_{2,1}&p_{2,2}\end{bmatrix}$。  

那么可以将上面等式变形为：
$$
\begin{bmatrix}
  ap_{1,1}&bp_{1,1}+p_{1,2}\\
  ap_{2,1}&bp_{2,1}+p_{2,2}\\
\end{bmatrix}=
\begin{bmatrix}
  \lambda_1p_{1,1}&\lambda_1p_{1,2}\\
  \lambda_2p_{2,1}&\lambda_2p_{2,2}
\end{bmatrix}
$$

化简得：
$$
\begin{aligned}
  (a-1)p_{1,2}&=p_{1,1}b\\
  (a-1)p_{2,2}&=p_{2,1}b
\end{aligned}
$$
考虑 $a=1$ 的情况，由于 $b\neq 0$，所以 $p_{1,1}=p_{2,1}=0$。

而此时 $P$ 的行列式为 $0$，不存在 $P^{-1}$，因此不可以对角化。

因此当且仅当 $a\neq1$ 时可以对角化。

### Part3
当 $a=1$ 时，发现就是每次加 $b$，那么很显然 $A^x=A^{x\operatorname{mod}p}\pmod p$，然后分类讨论即可。

## 代码实现
```cpp
/*
* @Author: ftt2333
* @Email: ftt2333@126.com
* @LastEditTime: 2022-11-29 09:27:17
*/

#include <bits/stdc++.h>
using namespace std;
#define rep(i, a, b) for (auto i = (a); i <= (b); ++i)
#define per(i, a, b) for (auto i = (a); i >= (b); --i)
#define all(v) (v).begin(), (v).end()
#define szof(v) int((v).size())
using pii = pair<int, int>;
using ll = long long;

#define gc() getchar()
#define pc(c) putchar(c)
template <class T = int> T read() {
  T x = 0; char c = gc(); bool f = 0;
  for (; !isdigit(c); c = gc()) f = c == '-';
  for (; isdigit(c); c = gc()) x = x * 10 + c - 48;
  return f ? -x : x;
}
template <class T> void write(T x) {
  if (x >= 0) { if (x > 9) write(x / 10); pc(48 + x % 10); }
  else { pc('-'); if (x < -9) write(-(x / 10)); pc(48 - x % 10); }
}

const int N = 1e6 + 10, mod = 1e9 + 7;
struct mat {
  int a[2][2];
  mat() { memset(a, 0, sizeof(a)); }
};
mat operator*(const mat &a, const mat &b) {
  mat c;
  rep(i, 0, 1) rep(j, 0, 1) rep(k, 0, 1)
    (c.a[i][j] += 1ll * a.a[i][k] * b.a[k][j] % mod) %= mod;
  return c;
}
mat qpow(mat a, int b) {
  mat res;
  res.a[0][0] = 1, res.a[0][1] = 0;
  res.a[1][0] = 0, res.a[1][1] = 1;
  for (; b; b >>= 1, a = a * a)
    if (b & 1) res = res * a;
  return res;
}

char nstr[N], mstr[N];
int nlen, mlen, a, b, c, d, n, m;

int main() {
  scanf("%s%s", nstr + 1, mstr + 1);
  a = read(), b = read(), c = read(), d = read();
  int base0 = (a == 1 ? mod : mod - 1);
  nlen = strlen(nstr + 1), mlen = strlen(mstr + 1);
  rep(i, 1, mlen) {
    m = (10ll * m + mstr[i] - 48 + base0) % base0;
  }
  mat A, B;
  A.a[0][0] = a, A.a[0][1] = b;
  A.a[1][0] = 0, A.a[1][1] = 1;
  B.a[0][0] = c, B.a[0][1] = d;
  B.a[1][0] = 0, B.a[1][1] = 1;
  mat C;
  C.a[0][0] = 1, C.a[0][1] = 0;
  C.a[1][0] = 1, C.a[1][1] = 0;
  mat D = qpow(A, (m + base0 - 1) % base0) * B;
  int base1;
  if (D.a[0][0] == 1) base1 = mod;
  else base1 = mod - 1;
  rep(i, 1, nlen) {
    n = (10ll * n + nstr[i] - 48 + base1) % base1;
  }
  C = qpow(D, (n + base1 - 1) % base1) *
      qpow(A, (m + base0 - 1) % base0) * C;
  write(C.a[0][0]); pc(10);
}
```

## hack 数据
in:
```
1145141919810 1000000007 2 1 1 2
```
ans:
```
283823589
```

---

## 作者：waaadreamer (赞：23)

这道题可以使用数论解法。

显然，F(n,m)=a·F(n,m-1)+b=(a^(m-1))F(n,1)+b+ab+...+(a^(m-2))b=(a^(m-1))c·F(n-1,m)+(a^(m-1))d+b+ab+...+(a^(m-2))b

记p=b+ab+...+(a^(m-2))b, x=(a^(m-1))c, y=(a^(m-1))d+p, q=y+xy+...+(x^(n-2))y

那么F(n,m)=x·F(n-1,m)+y=(x^(n-1))F(1,m)+q=(x^(n-1))(a^(m-1)+p)+q

显然，p,q都可以使用等比数列求和公式计算（注意若公比为1，不能使用求和公式）

但是这里涉及到a^(m-1)和x^(n-1)的运算，若使用bigint暴力计算，肯定会超时。于是我们可以通过缩小n,m的值来计算。

设a^p=a^(p-x) (mod k)，k为质数且gcd(a,k)=1，则a^x=1(mod k)

由于有费马小定理a^(k-1)=1(mod k)，所以x=k-1.这样，就有a^p=a^(p mod (k-1)) (mod k)，因此我们可以把n,m缩小到1,000,000,007以内，这样就可以使用快速幂计算结果了。

但是在公比为1的时候是需要用项数\*首项来计算答案的，因此我们不光要储存n,m mod 1,000,000,006的值，同时也需要储存它们mod 1,000,000,007的值以防万一。

除法的部分使用乘法逆元就行，总复杂度O(n的位数+m的位数)，轻松AC。

附上C++代码：


```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
using namespace std;
typedef long long ll;
const int maxn = 1000005, mod = 1000000007;
inline int modpow(int a, int b, int m){
    int res = 1;
    for(; b; b >>= 1){
        if(b & 1) res = (ll)res * a % m;
        a = (ll)a * a % m;
    }
    return res;
}
int main(){
    int n = 0, n1 = 0, m = 0, m1 = 0, a, b, c, d;
    char str;
    while((str = getchar()) != ' '){
        n = (10LL * n + str - '0') % (mod - 1);
        n1 = (10LL * n1 + str - '0') % mod;
    }
    n = (n - 1 + mod - 1) % (mod - 1);
    n1 = (n1 - 1 + mod) % mod;
    while((str = getchar()) != ' '){
        m = (10LL * m + str - '0') % (mod - 1);
        m1 = (10LL * m1 + str - '0') % mod;
    }
    m = (m - 1 + mod - 1) % (mod - 1);
    m1 = (m1 - 1 + mod) % mod;
    scanf("%d%d%d%d", &a, &b, &c, &d);
    int am = modpow(a, m, mod), p, x = (ll)am * c % mod;
    if(a == 1) p = (ll)m1 * b % mod;
    else p = (ll)b * (am - 1 + mod) % mod * modpow(a - 1, mod - 2, mod) % mod;
    int xn = modpow(x, n, mod), y = ((ll)am * d + p) % mod, q;
    if(x == 1) q = (ll)n1 * y % mod;
    else q = (ll)y * (xn - 1 + mod) % mod * modpow(x - 1, mod - 2, mod) % mod;
    printf("%lld", ((ll)xn * (am + p) + q) % mod);
    return 0;
}
```

---

## 作者：日居月诸 (赞：14)

**upd 2020-12-04:感谢**@AnnihilatiοnLightd**的提醒，修正了一个错误**

~~为啥你谷不支持生成目录啊~~

[此处我的博客，体验更佳](https://blog.csdn.net/qq_41996523/article/details/110307469)

这题怎么这么多人用矩乘做啊。。。

所以我还是在下面附上这道题的“矩乘”费马小定理吧。（其实这个性质极其特殊）

## 题目链接

[P1397 矩阵游戏 - 洛谷](https://www.luogu.com.cn/problem/P1397)

## 题目大意

已知

$$F(1,1)=1;$$

$$F(i,j)=aF(i,j-1)+b(2\le j\le m)$$

$$F(i,1)=cF(i-1,m)+d(2\le i\le n)$$

求 $F(n,m)\bmod (10^9+7)$ 的值

-   $1\le n,m\le 10^{1\ 000\ 000};1\le a,b,c,d\le 10^9$

## 解题报告

### 问题分析

看到这题的时候，我就觉得这就是个高中数学数列题，结果它的确是。~~（尽管它非常毒瘤）~~

显然根据数学知识，先要分 $a$ 是否为1来考虑这个问题。这里我就推推 $a\ne 1$ 的情况。

思路是 $F(i,1)\to F(i,m)\to F(i+1,1)$

然后 $F(1,1)\to F(n,1)$

最后再 $F(n,1)\to F(n,m)$

**具体推导**如下

$$F(i,j)=aF(i,j-1)+b$$

特征方程为 $x=ax+b$ ，特征根为 $x=-\dfrac{b}{a-1}$

于是

$$F(i,j)+\dfrac{b}{a-1}=a[F(i,j-1)+\dfrac{b}{a-1}]$$

$$F(i,m)=a^{m-1}[F(i,1)+\dfrac{b}{a-1}]-\dfrac{b}{a-1}\cdots (\alpha)$$

故而

$$F(i,1)=cF(i-1,m)+d$$

$$=a^{m-1}c\cdot F(i-1,1)+\dfrac{a^{m-1}bc}{a-1}-\dfrac{bc}{a-1}+d$$

$$=A\cdot F(i-1,1)+B$$

其中 $A=a^{m-1}c\ne 1,B=\dfrac{a^{m-1}bc}{a-1}-\dfrac{bc}{a-1}+d$

再像一开始那样推就可以推得

$$F(n,1)=A^{n-1}[1+\dfrac{B}{A-1}]-\dfrac{B}{A-1}\cdots (\beta)$$

能够求得 $F(n,1)$

再把 $F(n,1)$ 代入 $(\alpha)$ 式中即可得 $F(n,m)$

另外由于 $n,m$ 巨大，要使用欧拉定理转化：

$$a^n\equiv a^{n \bmod (P-1)}\pmod P$$

---

告一段落。另外还有一种$a=1$的情况理应特殊考虑。~~（然而我脑残还考虑了c是不是1，分了四种情况）~~

### 代码实现

```cpp
//...
const ll P = 1e9 + 7;
const int MAXB = 1e6 + 5;
char n[MAXB], m[MAXB];
ll a, b, c, d;
ll calc(char a[], ll mod) {
	ll ans = 0; int len = strlen(a);
	for(int i = 0; i < len; i++) {//from hign to low
		ans = (ans * 10 + a[i] - '0') % mod;
	}
	return ans;
}
ll qpow(ll a, ll n) {
	ll ret = 1;
	for(; n; n >>= 1, (a *= a) %= P)
		if(n & 1) (ret *= a) %= P;
	return ret;
}
void solve1() {//a=c=1
	ll t1 = calc(n, P); ll t2 = calc(m, P);
	t1--; if(t1 < 0) t1 += P;
	t2--; if(t2 < 0) t2 += P;
	ll ans = (1 + (t2 * b % P + d) % P * t1 % P + t2 * b % P) % P;
	printf("%lld\n", ans);
}
ll calcFn1(ll A, ll B) {
	ll t3 = calc(n, P-1);
	t3--; if(t3 < 0) t3 += P-1;
	return ((qpow(A-1, P-2) * B + 1)% P * qpow(A, t3) % P + P - qpow(A-1, P-2) * B % P) % P;//F(n,1)
}
void solve2() {//a=1,c!=1
	ll t2 = calc(m, P);
	t2--; if(t2 < 0) t2 += P;
	ll A = c, B = (b * c % P * t2 % P + d) % P;
	ll tmp = calcFn1(A, B);//F(n,1)
	ll ans = (tmp + t2 * b % P) % P;
	printf("%lld\n", ans);
}
void solve3() {//a!=1, c=1
	ll t4 = calc(m, P-1); 
	t4--; if(t4 < 0) t4 += P-1;
	ll A = qpow(a, t4), B = ((A * b % P * qpow(a-1, P-2) % P + d) % P + P - qpow(a-1, P-2) * b % P) % P;
	ll tmp = calcFn1(A, B);
	ll ans = ((tmp + qpow(a-1, P-2) * b % P) * qpow(a, t4) % P + P - qpow(a-1, P-2) * b % P) % P;
	printf("%lld\n", ans);
}
void solve4() {//a!=1, c!=1
	ll t4 = calc(m, P-1);
	t4--; if(t4 < 0) t4 += P-1;
	ll A = qpow(a, t4) * c % P, B = ((A * b % P * qpow(a-1, P-2) % P + d) % P + P - b * c % P * qpow(a-1, P-2) % P) % P;
	ll tmp = calcFn1(A, B);
	ll ans = ((tmp + b * qpow(a-1, P-2) % P) % P * qpow(a, t4) % P + P - b * qpow(a-1, P-2) % P) % P;
	printf("%lld\n", ans);
}
int main() {
	scanf("%s%s", n, m);
	a = read(), b = read(), c = read(), d = read();
	if(a == 1 && c == 1) solve1();
	else if(a == 1 && c != 1) solve2();
	else if(a != 1 && c == 1) solve3();
	else solve4();
	return 0;
}
```

### 关于矩乘的“费马小定理”

这其实是这个题目的一个特殊性质。。。

当 $a\ne 1$ 时，有

$$\begin{pmatrix}a & b\\ 0 & 1\end{pmatrix}^{P-1}=\begin{pmatrix}a^{P-1} & (a^{P-2}+\cdots+a+1)b\\0 & 1\end{pmatrix}$$

由费马小定理

$$a^{P-1}\equiv 1\pmod P$$

$$(a^{P-2}+\cdots+a+1)\equiv\dfrac{1-a^{P-1}}{1-a}\equiv 0 \pmod P$$

所以 $\begin{pmatrix}a & b\\ 0 & 1\end{pmatrix}^{P-1}$ 在做 $\bmod P$ 运算时就相当于单位矩阵 $E_2$ ！

完结撒花

---

## 作者：Kelin (赞：12)

似乎洛谷的Markdown编辑不了数学公式(公式炸了好多次了)

所以这里推荐一下我的(blog)[http://blog.csdn.net/benoble\_/article/details/77488783]

这里吐槽一下楼下的代码,他是会被hack掉的

一组hack的数据

34578734657863487 38465873465876348 1 23734637 3892734 3849

467549493


---

## 作者：Karry5307 (赞：5)

### 题意

给一个 $n$ 行 $m$ 列的数表 $f$ 和四个常数 $a,b,c,d$，按照如下规则构造数表：

$$
f_{i,j}=\begin{cases}1&,i=1,j=1\\cf_{i-1,m}+d&,i>1,j=1\\af_{i,j-1}+b&,j>1\end{cases}
$$

求 $f_{n,m}$，答案对 $10^9+7$ 取模。

### 题解

矩阵快速幂+求逆或者推公式，先讲矩阵做法。

首先考虑一行的转移，很明显有

$$
\begin{pmatrix}f_{i,j}&1\end{pmatrix}=\begin{pmatrix}f_{i,j-1}&1\end{pmatrix}\begin{pmatrix}a&0\\b&1\end{pmatrix}
$$

对于一列来说，有

$$
\begin{pmatrix}f_{i,1}&1\end{pmatrix}=\begin{pmatrix}f_{i-1,m}&1\end{pmatrix}\begin{pmatrix}c&0\\d&1\end{pmatrix}
$$

设 $A=\begin{pmatrix}a&0\\b&1\end{pmatrix},B=\begin{pmatrix}c&0\\d&1\end{pmatrix}$，则

$$\begin{pmatrix}f_{i,1}&1\end{pmatrix}=\begin{pmatrix}f_{i-1,1}&1\end{pmatrix}A^{m-1}B$$

这就弄出了一列的真正转移了，于是有

$$\begin{pmatrix}f_{n,m}&1\end{pmatrix}=\begin{pmatrix}f_{i,1}&1\end{pmatrix}(A^{m-1}B)^{n-1}A^{m-1}$$

由于高精度减法退位可以被卡到 $O(\log n)$ 的，同时因为求逆矩阵以及矩阵乘法复杂度很低，所以可以将减法变成乘逆矩阵的形式，也即

$$\begin{pmatrix}f_{n,m}&1\end{pmatrix}=\begin{pmatrix}f_{i,1}&1\end{pmatrix}(A^{m}A^{-1}B)^{n}B^{-1}$$

对于矩阵 $\begin{pmatrix}a&0\\b&1\end{pmatrix}$ 来说，其逆矩阵为 $\begin{pmatrix}\frac{1}{a}&0\\-\frac{b}{a}&1\end{pmatrix}$，所以可以预处理出 $A^mA^{-1}B$ 然后矩阵快速幂。

注意到高精度整数除 $2$ 的复杂度是 $O(\log n)$ 的，整个快速幂过程是 $O(\log^2n)$ 的所以使用十进制快速幂，复杂度为 $O(\log n)$，总复杂度 $O(\log nm)$，较常规矩乘快。

接下来考虑通项公式，先考虑一行。

$$f_{i,j}=af_{i,j-1}+b$$

如果式子是 $f_{i,j}-x=a(f_{i,j-1}-x)$ 就很好做，所以有 $(-a+1)x=b$，即 $x=-\frac{b}{a-1}$，所以有

$$f_{i,j}+x=a\left(f_{i,j-1}+x\right)$$

也即 $f_{i,m}=a^{m-1}(f_{i,1}+x)-x$，所以 $f_{i+1,1}=c(a^{m-1}(f_{i,1}+x)-x)+d$，整理一下即 

$$f_{i+1,1}=a^{m-1}cf_{i,1}+a^{m-1}cx-cx+d$$

设 $A=a^{m-1}c,B=a^{m-1}cx-cx+d$，则 $f_{i,1}=Af_{i-1,1}+B$。

按照上面的方法有 $X=-\frac{B}{A-1}$，那么有

$$f_{i,1}+X=A(f_{i-1,1}+X)$$

所以 $f_{n,1}=A^{n-1}(f_{1,1}+X)-X$，所以

$$f_{n,m}=a^{m-1}(A^{n-1}(X+1)-X+x)-x$$

于是就没了。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=1e6+51,MOD=1e9+7;
struct Matrix{
	ll num[3][3];
	Matrix()
	{
		memset(num,0,sizeof(num));
	}
	inline ll* operator [](const ll &x)
	{
		return num[x];
	}
	inline const ll* operator [](const ll &x)const
	{
		return num[x];
	}
};
Matrix matx,maty,invl;
ll x;
char n[MAXN],m[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline ll qpow(ll base,ll exponent)
{
    ll res=1;
    while(exponent)
    {
        if(exponent&1)
        {
            res=(li)res*base%MOD;
        }
        base=(li)base*base%MOD,exponent>>=1;
    }
    return res;
}
inline Matrix operator *(Matrix x,Matrix y)
{
	Matrix res;
	for(register int i=1;i<=2;i++)
	{
		for(register int j=1;j<=2;j++)
		{
			for(register int k=1;k<=2;k++)
			{
				res[i][j]=(res[i][j]+(li)x[i][k]*y[k][j])%MOD;
			}
		}
	}
	return res;
}
inline Matrix qpow(Matrix base,ll len,char *exponent)
{
	Matrix res,pw[4];
	res[1][1]=res[2][2]=1;
	for(register int i=len;i;i--)
	{
		pw[0]=base,pw[1]=pw[0]*pw[0],pw[2]=pw[1]*pw[1],pw[3]=pw[2]*pw[2];
		for(register int j=4;j>=0;j--)
		{
			(exponent[i]-48)&(1<<j)?res=res*pw[j],1:1;
		}
		base=pw[3]*pw[1];
	}
	return res;
}
int main()
{
    scanf("%s%s",n+1,m+1),invl[1][1]=qpow(matx[1][1]=read(),MOD-2);
	matx[2][1]=read(),matx[2][2]=invl[2][2]=1;
	invl[2][1]=(MOD-(li)matx[2][1]*invl[1][1])%MOD;
	matx=qpow(matx,strlen(m+1),m),matx=matx*invl;
	maty[1][1]=read(),maty[2][1]=read(),maty[2][2]=1,matx=matx*maty;
	matx=qpow(matx,strlen(n+1),n),x=(matx[1][1]+matx[2][1])%MOD;
    printf("%d\n",(li)(x-maty[2][1]+MOD)%MOD*qpow(maty[1][1],MOD-2)%MOD);
}
```

---

## 作者：poorpool (赞：5)

这群人怎么都用的矩阵快速幂呀 QAQ，来讲个数学方法吧。

**前置技能：高中数学必修“数列”，扩展欧拉定理降幂。**

考虑从 $F_{i,1}$ 推到 $F_{i,m}$。考虑到有人没学过数列我还是推一下吧 qwq。

我们设 $F_{i,j} + k = a(F_{i,j-1}+k)$，易得到 $(a-1)k=b$。我们需要对 $a$ 分类讨论。

### 当 $a=1$ 时

将 $a$ 放到题目给的第二个式子，得到 $F_{i,j}=F_{i,1}+(j-1)b$。

再考虑 $F_{i+1, 1}$ 的转移。

$F_{i+1,1}=cF_{i,m}+d=c(F_{i,1}+(m-1)b)+d=cF_{i,1}+cb(m-1)+d$。

用同样的套路得到 $F_{n+1,1}$ 的式子。我们发现 $c$ 也是要分类讨论的。我们记 $D=cb(m-1)+d$。

$c=1$ 时，$F_{n+1,1}=F_{1,1}+nD$。

否则 $F_{n+1,1}=c^nF_{1,1}+D \cdot \dfrac{c^n-1}{c-1}$。

这样我们便可以轻松得到 $F_{n+1,1}$ 了。

#### 当 $a \neq 1$ 时

于是 $k=b/(a-1)$。同样地我们得出 $F_{i,j}=a^{j-1}F_{i,1}+(a^{j-1}-1) \dfrac{b}{a-1}$。

再考虑 $F_{i+1, 1}$ 的转移。

$F_{i+1,1}=cF_{i,m}+d=c(a^{m-1}F_{i,1}+(a^{m-1}-1) \dfrac{b}{a-1})+d$。

化简得到 $a^{m-1}cF_{i,1}+c(a^{m-1}-1) \dfrac{b}{a-1}+d$

记 $A=a^{m-1}c$，$B=c(a^{m-1}-1) \dfrac{b}{a-1}+d$，则 $F_{i+1,1}=AF_{i,1}+B$。

我们再讨论一下是否 $A=1$。不过，我们发现这里和上面的式子（$F_{i+1,1}=cF_{i,1}+D$）的形式是一样的（只有常数不同），那么我们不必重复讨论，只要将求解 $F_{n+1,1}$ 写成一个函数调用就可以了。这个函数的讨论就按照上面对 $c$ 的讨论做就行了。

-----

现在我们得到了 $F_{n+1,1}$ ，只需要按照题目中给的第三个式子逆推就行了。于是我们 AC 了这道题。

最后解释一下为什么要用扩展欧拉定理降幂。观察到 $n,m$ 太大了，肯定要取模。当 $n,m$ 作系数的时候是对 $10^9+7$ 取模的，但是我们发现 $n,m$ 还要作指数，作指数应当对 $\varphi(10^9+7)$ 取模。所以要用扩展欧拉定理降幂，因此我们要记录一下 $n,m$ 对于这两个不同的模数取模后的值。

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
typedef long long ll;
int a, b, c, d, nu, nv, mu, mv;
const int mod=1e9+7, phi=mod-1;
char ss[1000005];
void rn(int &x, int &y){
	scanf("%s", ss);
	int len=strlen(ss);
	for(int i=0; i<len; i++){
		x = ((ll)x * 10 % mod + ss[i] - '0') % mod;
		y = ((ll)y * 10 % phi + ss[i] - '0') % phi;
	}
}
int ksm(int a, int b){
	int re=1;
	while(b){
		if(b&1)	re = (ll)re * a % mod;
		a = (ll)a * a % mod;
		b >>= 1;
	}
	return re;
}
int qwq(int x, int y){
	int re;
	if(x==1)
		re = (1 + (ll)nu * y % mod) % mod;
	else{
		re = ksm(x, nv);
		re = (re + (ll)y*(ksm(x, nv)-1+mod)%mod*ksm(x-1, mod-2)%mod) % mod;
	}
	return re;
}
int main(){
	rn(nu, nv);
	rn(mu, mv);
	cin>>a>>b>>c>>d;
	int re;
	if(a==1){
		int D=(ll)c*b%mod*(mu-1+mod)%mod;
		D = (D + d) % mod;
		re = qwq(c, D);
	}
	else{
		int A=(ll)c*ksm(a, (mv-1+phi)%phi+phi)%mod;
		int B=((ll)c*b%mod*(ksm(a, (mv-1+phi)%phi+phi)-1+mod)%mod*ksm(a-1, mod-2)%mod+d)%mod;
		re = qwq(A, B);
	}
	re = (re - d + mod) % mod;
	re = (ll)re * ksm(c, mod-2) % mod;
	cout<<re<<endl;
	return 0;
}
```


---

## 作者：0xFF (赞：3)

#### 题目大意


------------
给定 $n,m,a,b,c,d$ 求出 $F[n][m]$ 在模 $1000000007$ 意义下的值

$\begin{array}{c}
F[1][1]=1 \\
F[i, j]=a \times F[i][j-1]+b(j \neq 1) \\
F[i, 1]=c \times F[i-1][m]+d(i \neq 1)
\end{array}$

#### 思路分析


------------

首先考虑 $F[n][m]$ 是如何通过 $F[1][1]$ 经过有限次变换得到的。

将把第二行递推式的变换记为变换 $1$,将第三行递推式的变换记为变换 $2$。

观察第二行的递推式，显然， $F[n][m]$ 可以由 $F[n][1]$ 通过 $m-1$ 次变换 $1$ 得到，同理，每一行的最后一个数都可以由这一行的第一个数通过 $m-1$ 次变换 $1$ 得到。

接下来考虑 $F[n][1]$ 与 $n-1$ 的数的联系，显然，只要找出了不同行之间的联系就可以找出整个矩阵不同元素之间的关系，进而就可以从 $F[1][1]$ 推出 $F[n][m]$ 的值。

显然，每一行的第一个数都可以由上一行的最后一个数经过一个变换 $2$ 得到。

形式化的表述如下：

设原始数组 $A$ 

$\begin{bmatrix}
 1\\1
\end{bmatrix}$

设转移数组 $1$ $A_1$ 

$\begin{bmatrix}
 a & 0\\
 b & 1
\end{bmatrix}$

设转移数组 $2$ $A_2$

$\begin{bmatrix}
 c & 0\\
 d & 1
\end{bmatrix}$
 
答案即为 $A \cdot (A_1^{m-1} \cdot A2)^{n-1} \cdot A1^{m-1}$
 
综上，我们就可以再规定的时间之内解决此题了！

[然而……](https://www.luogu.com.cn/record/77209134)

注意到后面的数据范围是 $10^{1000000}$，显然，就连 `__int128` 面对如此之大的数据也爆的毫无悬念。

由于高精度数的取模过于困难，我们可以考虑边读入边对数据取模。

由于 $n,m$ 皆为指数，根据费马小定理，可以考虑在读入时就对 $n,m$ 对 `mod-1` 取模，证明如下：

$$∵ a^{p-1} \equiv 1 (\bmod  \ p)$$

$$∴ a^n \equiv a^{n \mod p-1}(\bmod  \ p)$$

由此，我们就将所有的数都转化为了在我们操作范围之内的数。

[然而……](https://www.luogu.com.cn/record/77209429)

观察到测试点 $6$ 和测试点 $11$ 都满足 $a=c=1$ 这一特殊性质，此时的运算就不是矩阵运算而是一个值的运算，所以直接取模即可，无需模 `mod-1`。

#### 代码实现


------------
```cpp
char s1[N],s2[N];
struct Matrix{
	long long c[3][3];
}A1,A2,E1,E2,base;

Matrix operator * (const Matrix &x,const Matrix &y){
	Matrix a;
	for(int i=1;i<=2;i++){
		for(int j=1;j<=2;j++){
			a.c[i][j] = 0;
		}
	}
	for(int i=1;i<=2;i++){
		for(int j=1;j<=2;j++){
			for(int k=1;k<=2;k++){
				a.c[i][j] += x.c[i][k] * y.c[k][j] % mod;
				a.c[i][j] %= mod;
			}
		}
	}
	return a;
}
int n,m;
signed main(){
	freopen("P1397_3.in","r",stdin);
	scanf("%s",s1 + 1);
	scanf("%s",s2 + 1);
	int a = read() , b = read() , c = read() , d = read();
	int len1 = strlen(s1 + 1) , len2 = strlen(s2 + 1);
	for(int i=1;i<=len1;i++){
		if(a == 1) n = ((n<<3) + (n<<1) + s1[i] - '0') % mod;
		else n = ((n<<3) + (n<<1) + s1[i] - '0') % (mod - 1);
	}
	for(int i=1;i<=len2;i++){
		if(c == 1) m = ((m<<3) + (m<<1) + s2[i] - '0') % mod;
		else m = ((m<<3) + (m<<1) + s2[i] - '0') % (mod - 1);
	}
	for(int i=1;i<=2;i++){
		A1.c[i][i] = A2.c[i][i] = 1;
	}
	E1.c[1][1] = a , E1.c[2][1] = b , E1.c[2][2] = 1;
	E2.c[1][1] = c , E2.c[2][1] = d , E2.c[2][2] = 1;
	int tmp = m - 1;
	while(tmp > 0){
		if(tmp & 1) A1 = A1 * E1;
		E1 = E1 * E1;
		tmp >>= 1;
	}
	E2 = A1 * E2;
	tmp = n - 1;
	while(tmp > 0){
		if(tmp & 1) A2 = A2 * E2;
		E2 = E2 * E2;
		tmp >>= 1;
	}
	A1 = A2 * A1;
	cout<<(A1.c[1][1]+A1.c[2][1])%mod<<endl;
	return 0;
}
```


---

## 作者：_Anchor (赞：1)

[题意链接](https://www.luogu.com.cn/problem/P1397)

# 题意简述

给定一个二维的递推方程，已知第一项$(1,1)$求其第$(n,m)$项

# 分析

一道矩阵乘法基础题

一看到递推式还没有特殊条件就知道是矩阵快速幂

但是这个$n,m$的范围着实是不正常

所以考虑到要用个某某定理或者性质把$n,m$的范围缩小

这里就是费马小定理了

**容易**发现，这里的矩阵乘法是满足费马小定理的，但是当$a=1$的情况要特判，（至于为什么详见[这篇博客](https://blog.csdn.net/qq_41996523/article/details/110307469)或者[这篇博客](https://blog.csdn.net/benoble_/article/details/77488783)）

所以接下来我们可以开始构造状态矩阵

所以可以**把单独一行**的转移方程写出来:

$\left\{ \begin{matrix} a & 0\\ b & 1 \end{matrix} \right\}$

那么其实我们每一行转移过后就是行与行之间的转移，那么我们可以把这个转移方程也直接写出来：

$\left\{ \begin{matrix} c & 0\\ d & 1 \end{matrix} \right\}$

（其实一点变化都没有）

所以我们手摸一下，可以直接得出：

我们的初始状态的矩阵要乘上
$$
\left[
\begin{matrix}
a & 0\\
b & 1
\end{matrix}
\right]^{(m-1)*n}

*

\left[
\begin{matrix}
c & 0\\
d & 1
\end{matrix}
\right]^{(n-1)}
$$

最后答案就是初始矩阵的元素$f_{(1,1)}$

那么这道题就结束了

# 代码

代码附上

```cpp
#include<bits/stdc++.h>
using namespace std;
template <typename T>
inline void read(T &x){
	x=0;char ch=getchar();bool f=false;
	while(!isdigit(ch)){if(ch=='-'){f=true;}ch=getchar();}
	while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	x=f?-x:x;
	return ;
}
template <typename T>
inline void write(T x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10^48);
	return ;
}
#define ll long long
const ll MOD=1e9+7,N=1e6+5;
#define inc(a,b) (a+b>=MOD?a+b-MOD:a+b)
struct Matrix{
	ll a[3][3];
	Matrix(){memset(a,0,sizeof(a));}
	Matrix operator * (Matrix B){
		Matrix C;
		for(int i=1;i<3;i++){
			for(int j=1;j<3;j++){
				for(int k=1;k<3;k++){
					C.a[i][j]=inc(C.a[i][j],a[i][k]*B.a[k][j]%MOD);
				}
			}
		}
		return C;
	}
};
Matrix QuickPow(Matrix A,ll y){
	Matrix res;
	res.a[1][1]=res.a[2][2]=1;
	while(y){
		if(y&1) res=res*A;
		A=A*A;
		y>>=1;
	}
	return res;
}
Matrix ans,base,base1;
string nn,mm;
ll a,b,c,d,n,m;
int main(){
	cin>>nn>>mm>>a>>b>>c>>d;
	int len1,len2;
	len1=nn.size(),len2=mm.size(); 
	for(int i=0;i<len1;i++) n=(n*10+nn[i]-'0')%(a==1?MOD:MOD-1);
	for(int i=0;i<len2;i++) m=(m*10+mm[i]-'0')%(a==1?MOD:MOD-1);
	ans.a[1][1]=1,ans.a[1][2]=1;
	base.a[1][1]=a,base.a[2][1]=b,base.a[2][2]=1;
	base=QuickPow(base,m-1);
	base1.a[1][1]=c,base1.a[2][1]=d,base1.a[2][2]=1;
	base=base*base1;
	base=QuickPow(base,n-1);
	base1.a[1][1]=a,base1.a[2][1]=b,base1.a[2][2]=1;
	base1=QuickPow(base1,m-1);
	write((ans*(base*base1)).a[1][1]);
	return 0;
}

```

---

## 作者：SuBtitle (赞：0)

#### 题目链接

[P1397 矩阵游戏](https://www.luogu.com.cn/problem/P1397)

## 分析

- **首先考虑单独的一行**
  $$F[i][j]=a \times F[i][j-1]+b$$
  为了求出 $F[i][m]$，也就是数列的通项。我们设
  $$F[i][m]+x=a\times(F[i][m-1]+x)$$
  不难求出
  $$x=\frac{b}{a-1}$$
  继而根据等比数列的通项公式，得到
  $$F[i][m]+\frac{b}{a-1}=a^{m-1}\times(F[i][1]+\frac{b}{a-1})$$
  所以
  $$F[i][m]=a^{m-1}\times F[i][1]+\frac{a^{m-1}\times b-b}{a-1}$$

- **考虑 $F[n-1][m]$ 到 $F[n][m]$ 的转化**
  $$F[n][1]=c\times F[n-1][m]+d$$
  将其代入推出的第一个公式，得到
  $$F[n][m]=a^{m-1}\times(c\times F[n-1][m]+d)+\frac{a^{m-1}\times b-b}{a-1}$$
  稍微转化一下
  $$F[n][m]=a^{m-1}\times c\times F[n-1][m]+a^{m-1}\times d+\frac{a^{m-1}\times b-b}{a-1}$$
  惊喜地发现，只要
  $$\text{将 }a^{m-1}\times c\text{ 设为 }A\text{ ，将 }a^{m-1}\times d+\frac{a^{m-1}\times b-b}{a-1}\text{ 设为 }B$$
  原式就变成了
  $$F[n][m]=A\times F[n-1][m]+B$$
  得到了一个与一式一模一样的式子，也就是说
  $$F[n][m]=A^{n-1}\times F[1][m]+\frac{A^{n-1}\times B-B}{A-1}$$
- 于是乎，我们只需要通过一式求出 $F[1][m]$，再通过二式求出 $F[n][m]$，就结束了

## 代码实现与细节

- 因为形如 $\frac{a^{m-1}\times b-b}{a-1}$ 的式子，可能会出现增根，此时我们需要特判 $a$ 等于 $1$ 的情况，注意原式
$$a^{m-1}-1=(a-1)\times(a^{m-2}+a^{m-3}+...+a+1)$$
也就是说，当 $a$ 等于 $1$ 时， $\frac{a^{m-1}\times b-b}{a-1}$ 即为 $(m-1)\times b$
- 因为此题的数据大的离谱，常规的输入肯定不行，但又因为取模的条件，我们只需要使用快读，在读入的时候取模就行。
- 又因为涉及到乘方运算，在计算 $a^{m-1}$ 等时， $n$ 或 $m$ 不能直接对 $1000000007$ 取模，而要对 $1000000007$ 的 $\varphi$，也就是 $1000000006$ 取模（费马小定理）

## 具体代码

~~因为我太懒了，所以直接把所有 int 替换成了 long long~~

```c++
#include<iostream>
#include<cstdio>
using namespace std;

const long long M=1e9+7,phiM=M-1;
long long n,m,pn,pm,a,b,c,d,A,B,ans;

template<typename T>inline void re(T &x)       //一般快读
{
	T f=1;x=0;
	char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c))x=(1ll*x*10+(c^48))%M,c=getchar();
	x*=f;
}

template<typename T>inline void spre(T &x,T &y)    //针对n,m的快读
{
	T f=1;x=0,y=0;
	char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c))x=(1ll*x*10+(c^48))%M,y=(1ll*y*10+(c^48))%phiM,c=getchar();
	x*=f,y*=f;
}

long long mpow(long long x,long long y)     //快速幂
{
	long long ret=1;
	for(;y;y>>=1)
	{
		if(y&1) ret=ret*x%M;
		x=x*x%M;
	}
	return ret;
}

int main()
{
	spre(n,pn),spre(m,pm),re(a),re(b),re(c),re(d);
	long long tmp=mpow(a,pm-1),ni=mpow(a-1,M-2),a1;    //ni为a-1的逆元
	A=tmp*c%M;
	if(a==1) B=((m-1)*b%M+d)%M;                    //考虑a==1时的特殊情况
	else B=(tmp*(b*ni%M+d)%M-b*ni%M+M)%M;
	if(a==1) a1=((m-1)*b%M+1)%M;
	else a1=(tmp*(b*ni%M+1)%M-b*ni%M+M)%M;          //a1即F[1][m]
	long long ni2=mpow(A-1,M-2);
	if(A==1) ans=((n-1)*B%M+a1)%M;                        //A==1同样需要特判
	else ans=(mpow(A,pn-1)*(B*ni2%M+a1)%M-B*ni2%M+M)%M;
	printf("%lld",ans);
	return 0;
}
```





---

## 作者：Hide_In_The_Shadow (赞：0)

## P1397[NOI2013] 矩阵游戏

### 题目描述

若用 $F[i][j]$ 来表示矩阵中第 $i$ 行第 $j$ 列的元素，则 $F[i][j]$ 满足下面的递推式:

$$
F[1][1]=1
$$
$$
F[i,j]=a\times F[i][j-1]+b (j\neq 1)
$$
$$
F[i,1]=c\times F[i-1][m]+d (i\neq 1)
$$

递推式中 $a,b,c,d$ 都是给定的常数。

求 $F[n][m]$ 模 $1,000,000,007$ 的值。

乍一看数据范围有 $10^{1e6}$，很恐怖，那么说明要跳出一般的思维来解题，先做好心理准备。

然而刚开始，考虑照着样例递推。第一个递推式是本行内递推，举例计算之后，发现其行尾值其实有寄可循，不妨假设有 $m$ 列，行首值为 $x$，则行尾值 $=a^{m-1}\times x+\sum_{i=0}^{m-2}a^i\times b$。发现除了首项，其他项成等比数列，考虑运用高中数学知识简化，可得行尾值 $=a^{m-1}+\frac{a^{m-1}-1}{a-1}\times b$。由此行问题基本解决。

接下来考虑第二个递推式，很明显第二个递推式将上一行的尾值转移为此行的初值，由于行数过大，而且最终式子不好推导，于是考虑使用矩阵加速。由于行的表达式已经推导完成，于是结合第二个递推式推出矩阵 $\begin{bmatrix} a^{m-1}\times c & 0 \\ \frac{a^{m-1}-1}{a-1}\times b\times c+d & 1 \end{bmatrix}$。
其中取模意义下的除法用逆元解决。由于只会递推 $n-1$ 行，故只需得到矩阵的  $n-1$ 次幂，最后乘以行表达式推出 $F[n][m]$ 的答案。

但是考虑到 $n,m$ 极大时可能与 $a,b,c$ 等需要高次方的项不互质，考虑读入时对 $1e9+6(\phi(1e9+7))$ 取模，但 $a=1$ 和 $c=1$ （因为一定就互质了）的情况需要特判。

蒟蒻在代码实现时不懂初始化矩阵，故显码风丑陋，勿喷

下附代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#define ll long long
using namespace std;
const ll p=1000000007;
ll a,b,c,d,cnt,nn,mm,ny;
char n[1145141],m[1145141];
struct mmm{
	ll p[2][2];
};
mmm m1,m2,m3,m4,m5;//此处m1为初始矩阵，m2为行矩阵，m3为列初始矩阵，m4为列矩阵（快速幂之后的），m5为答案矩阵，此处其实可以缩减到2个矩阵，不过为了方便理解，拆成了5个矩阵
mmm operator *(mmm a,mmm b){
	mmm c;
	memset(c.p,0,sizeof(c.p));
	for(int i=0;i<=1;i++){
		for(int j=0;j<=1;j++){
			for(int k=0;k<=1;k++){
				c.p[i][j]=(c.p[i][j]+a.p[i][k]*b.p[k][j]%p)%p;
			}
		}
	}
	return c;
}
mmm ksmm(mmm x,ll y){
	mmm t;
	t.p[0][0]=1;
	t.p[1][1]=1;
	t.p[0][1]=0;
	t.p[1][0]=0;
	while(y){
		if(y&1)t=t*x;
		x=x*x;
		y>>=1;
	}
	return t;
}
ll work(char a[],ll mod){//用于处理n,m
	int len=strlen(a);
	ll ret=0;
	for(int i=0;i<len-1;i++){
		ret=(ret*10+a[i]-'0')%mod;
	}
	return ret;
}
ll ksm(ll x,ll y){
	ll t=1;
	while(y){
		if(y&1)t=t*x%p;
		x=x*x%p;
		y>>=1;
	}
	return t;
}
int main(){
	while(1){//读入n
		n[cnt]=getchar();
		if(n[cnt]<'0'||n[cnt]>'9'){
			cnt=0;
			break;
		}
		cnt++;
	}
	while(1){//读入m
		m[cnt]=getchar();
		if(m[cnt]<'0'||m[cnt]>'9'){
			cnt=0;
			break;
		}
		cnt++;
	}
	scanf("%lld %lld %lld %lld",&a,&b,&c,&d);
	if(c==1)nn=work(n,p);//特判c=1的情况
	else{
	    nn=work(n,p-1); 
	}
	if(a==1)mm=work(m,p);//特判a=1的情况
	else{
	    mm=work(m,p-1); 
	}
	m1.p[0][0]=1;
	m1.p[0][1]=1;
	if(mm>1){
    	if(a==1){
	    	m2.p[0][0]=1;
	    	m2.p[1][0]=(mm-1)*b%p;
	    	m2.p[1][1]=1;
	    	m3.p[0][0]=c;
	    	m3.p[1][0]=(m2.p[1][0]*c%p+d)%p;
		    m3.p[1][1]=1;
	    }
    	else{
	    	ny=ksm(a-1,p-2);
	    	m2.p[0][0]=ksm(a,mm-1);
	    	m2.p[1][0]=(m2.p[0][0]-1)*ny%p*b%p;
	    	m2.p[1][1]=1;
	    	m3.p[0][0]=m2.p[0][0]*c%p;
		    m3.p[1][0]=(m2.p[1][0]*c%p+d)%p;
	    	m3.p[1][1]=1;
    	}
    	if(nn>1){
			m4=ksmm(m3,nn-1);
			m5=m1*m4*m2;
			printf("%lld",m5.p[0][0]);
		}
		else{
			m5=m1*m2;
			printf("%lld",m5.p[0][0]);
		}
    }
	else{
		if(nn>1){
			m3.p[0][0]=c;
			m3.p[1][0]=d;
			m3.p[1][1]=1;
			m4=ksmm(m3,nn-1);
			m5=m1*m4;
			printf("%lld",m5.p[0][0]);
		}
		else{
			puts("1");//m和n都为1的时候答案就是初值1
		}
	}
	return 0;
}
```

---

## 作者：DiruiXiao (赞：0)

## [P1397 [NOI2013] 矩阵游戏](https://www.luogu.com.cn/problem/P1397)

**【题目简述】**

给定一个 $n$ 行 $m$ 列的矩阵，构造方式满足：
$$
F_{1,1} = 1
$$

$$
F_{i,j} = a\cdot F_{i,j-1}+b
$$

$$
F_{i,1}=c\cdot F_{i-1,m}+d
$$



题目给出了 $a$，$b$，$c$，$d$。求 $F_{n,m}$ 模上 $10^9+7$ 的值。

**【解题思路】**

**A. 数列求和法**

原题目要求求出 $F_{n,m}$ 的值，观察构造方程，发现有 $F_{i,j}=a\cdot F_{i,j-1}+b$。为了方便表达，我们将 $F_{i,j}$ 记作 $A_j$ 。

则有：

$$A_j=a\cdot A_{j-1}+b$$

设：

$$A_j+\alpha=a\cdot(A_{j-1}+K)$$

化简后：

$$A_j = a\cdot A_{j-1}+(a-1)\cdot K$$

对应系数后解出：

$$K = \frac{b}{a-1}$$

构造:
$$B_j = A_j+K$$

则有 $\{B_j\}$ 是以 $a$ 为公比，以 $F_{i,1}+K$ 为首项的等比数列。

则有:

$$B_j=\left(F_{i,1}+K\right)\cdot a^{j-1}$$

$$F_{i,j}=A_j=\left(F_{i,1}+K\right)\cdot a^{j-1}-K$$

$$F_{i,m}=A_m=\left(F_{i,1}+K\right)\cdot a^{m-1}-K$$

同理，将 $F_{i,1}$ 记作 $C_i$，可得：

$$C_i=c\cdot F_{i-1,m}+d$$

$$= c\cdot \left(\left(K+C_{i-1}\right)\cdot a^{m-1}-K\right)+d$$

$$C_i=-cK+ca^{m-1}K+ca^{m-1}C_{i-1}+d$$

$$C_i=cK(a^{m-1}-1)+d + ca^{m-1}C_{i-1}$$

$$C_i+L=ca^{m-1}(C_{i-1}+L)$$

解得：

$$L=\dfrac{cKa^{m-1}-ca^{m-1}+d}{ca^{m-1}-1}$$

令 $D_i=C_i+L$，则 $\{D_i\}$ 是以 $1+L$ 为首项，以 $ca^{m-1}$ 为公比的等比数列。

$$D_n=(1+L)\cdot c^{n-1}a^{(n-1)(m-1)}$$

所以：
$$C_n=(1+L)\cdot c^{n-1}a^{(n-1)(m-1)}-L$$

综上:

$$F_{n,m}=(C_n+K)a^{m-1}-K$$

$$=((1+L)\cdot c^{n-1}a^{(n-1)(m-1)}-L+K)a^{m-1}-K$$

同上构造可得：

但是 $m$，$n$ 都很大，考虑降次，又因为模数是质数，由欧拉定理可知 $a^{b}\equiv a^{b \ \bmod\ {\varphi(p)}}\pmod p$。这里 $\varphi(p)=p-1$。最后再取模意义下所有除法都要乘以逆元，再用快速幂求解。

但是注意特判：

再上文中当 $a$，$c$ 均为 $1$ 的时候公式无意义，需要特判。而对于读入，可以考虑一边读入，一边取模。

时间复杂度：$O(\log p)$ (因为 $n$，$m$ 均可控制在 $p-1$ 内)

**B. 矩阵加速递推法**

我选择的的做法……

构造初始矩阵：
$$
O=\begin{bmatrix}
1&1\\
\end{bmatrix}
$$
列转移：
$$
A=\begin{bmatrix}
a&0\\
b&1
\end{bmatrix}
$$
行转移：
$$
B=\begin{bmatrix}
c&0\\
d&1
\end{bmatrix}
$$
矩阵很好构造，问题在于计算，设答案矩阵为 $R$。

则有：

$$R = G\times \underbrace{A^{m-1}\times C\times...\times A^{m-1}\times C}_{\text{Repeat for } n \text{ times}} \times A^{m-1}=G\times (A^{m-1}\times C)^{n}\times A^{m-1}$$

**注意，矩阵乘法没有交换律，所以 $G\times A^{n(m-1)}\times C^{n}$ 是错误的, 并且要对 $a=1$ 的情况特判。**

关于为何该矩阵能够使用类似欧拉定理来降幂的证明已经有人给出了。

时间效率 $O(2^3\log p)$。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#define MAX_MATRIX_SIZE 5 // 矩阵的最大大小
#define MOD 1000000007
#define PHI_MOD 1000000006
using namespace std;
typedef long long ll;
ll a, b, c, d, n, m;

struct Matrix{
	ll a[MAX_MATRIX_SIZE][MAX_MATRIX_SIZE];
	Matrix() {memset(a,0,sizeof(a));}
};

inline Matrix mul(Matrix a, Matrix b) {
	Matrix ans;
	for (int i = 1; i <= 2; ++i) {
		for (int j = 1; j <= 2; ++j) {
			for (int k = 1; k <= 2; ++k) {
				ans.a[i][j] += a.a[i][k] * b.a[k][j]; // 矩阵乘法
				ans.a[i][j] %= MOD;
			}
		}
	}
	return ans;
}

inline void readBigInt(ll &ans1, ll &ans2) {
	ans1 = 0, ans2 = 0;
	char ch = getchar();
	while (!isdigit(ch)) ch = getchar();
	while (isdigit(ch)) {
		ans1 = (ans1 << 3) + (ans1 << 1) + (ch ^ 48); // 返回两种取模结果
		ans1 %= MOD;
		ans2 = (ans2 << 3) + (ans2 << 1) + (ch ^ 48);
		ans2 %= PHI_MOD;
		ch = getchar();
	}
}

Matrix A, B, ans; // 行转移、列转移和初始(答案)矩阵

inline Matrix quickPow(Matrix a, ll b) { // 快速幂
	Matrix ret; for (int i = 1; i <= 2; ++i) ret.a[i][i] = 1;
	while (b) {
		if (b & 1) ret = mul(ret, a);
		a = mul(a, a), b >>= 1;
	}
	return ret;
}

int main() {
	ll n1, n2, m1, m2; readBigInt(n1, n2), readBigInt(m1, m2);
	scanf("%lld %lld %lld %lld", &a, &b, &c, &d);
	a == 1 ? (n = n1, m = m1) : (n = n2, m = m2); // 特判
	ans.a[1][1] = ans.a[1][2] = 1; // 初始化答案矩阵
	A.a[1][1] = a, A.a[2][1] = b, A.a[2][2] = 1; // 初始化列转移矩阵
	A = quickPow(A, m - 1);
	B.a[1][1] = c, B.a[2][1] = d, B.a[2][2] = 1; // 初始化行转移矩阵
	A = mul(A, B);
	A = quickPow(A, n - 1);
	B.a[1][1] = a, B.a[2][1] = b, B.a[2][2] = 1; // 最后一行的列转移
	B = quickPow(B, m - 1);
	A = mul(A, B);
	ans = mul(ans, A);
	printf("%lld\n", ans.a[1][1]);
	return 0;
}
```



---


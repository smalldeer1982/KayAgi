# 刷题比赛

## 题目背景

nodgd 是一个喜欢写程序的同学，前不久洛谷 OJ 横空出世，nodgd 同学当然第一时间来到洛谷 OJ 刷题。   
于是发生了一系列有趣的事情，他就打算用这些事情来出题恶心大家……


## 题目描述

洛谷OJ当然算是好地方，nodgd 同学打算和朋友分享一下。于是他就拉上了他的朋友 Ciocio 和 Nicole 两位同学一起刷题。喜欢比赛的他们当然不放过这样一次刷题比赛的机会！

在第 $1$ 天 nodgd,Coicoi,Nicole 都只做了 $1$ 道题。

在第 $2$ 天 nodgd,Coicoi,Nicole 都只做了 $3$ 道题。

他们都有着严格的刷题规则，并且会在每一天都很遵守规则的刷一定量的题。

1、nodgd 同学第 $k+2$ 天刷题数量    
$$a_{k+2}=pa_{k+1}+qa_k+b_{k+1}+c_{k+1}+rk^2+tk+1$$

2、Ciocio 同学第 $k+2$ 天刷题数量      
$$b_{k+2}=ub_{k+1}+vb_k+a_{k+1}+c_{k+1}+w^k$$

3、Nicole 同学第 $k+2$ 天刷题数量    
$$c_{k+2} = xc_{k+1}+yc_k + a_{k+1} + b_{k+1} + z^k+k+2$$

（以上的字母 $p,q,r,t,u,v,w,x,y,z$ 都是给定的常数，并保证是正整数）

于是他们开始了长时间的刷题比赛！一共进行了 $n$ 天

但是时间是可贵的，nodgd 想快速知道第 $n$ 天每个人的刷题数量。  
不过 nodgd 同学还有大量的数学竞赛题、物理竞赛题、英语竞赛题、美术竞赛题、体育竞赛题…… 要做，就拜托你来帮他算算了。

由于结果很大，输出结果 $\bmod \space m$ 的值即可。


## 说明/提示

对于 $100\%$ 的数据，$4\le n \le 10^{16}$，$2\le m \le 10^{16}$，$1\le p,q,r,t,u,v,w,x,y,z \le 100$。

## 样例 #1

### 输入

```
4 10007
2 1 1 1
2 2 3
1 1 2```

### 输出

```
nodgd 74
Ciocio 80
Nicole 59```

# 题解

## 作者：SDqwq (赞：43)

[P1707 刷题比赛](https://www.luogu.com.cn/problem/P1707)

[更坏的阅读体验](https://www.luogu.com.cn/blog/Sham-Devour/solution-p1707)

[前置芝士：矩阵](https://oi-wiki.org/math/matrix/)

# $\texttt{Description}$

给定 $3$ 个序列 $a,b,c$：

$$
a_1=b_1=c_1=1
$$

$$
a_2=b_2=c_2=3
$$

计算方式：

$$
a_{k+2}=pa_{k+1}+qa_k+b_{k+1}+c_{k+1}+rk^2+tk+1
$$

$$
b_{k+2}=ub_{k+1}+vb_k+a_{k+1}+c_{k+1}+w^k
$$

$$
c_{k+2}=xc_{k+1}+yc_k+a_{k+1}+b_{k+1}+z^k+k+2
$$

其中 $p,q,r,t,u,v,w,x,y,z$ 都为给定常数。

求 $a_n,b_n,c_n$，答案对 $m$ 取模。

---

**数据范围：**

$4\le n\le10^{16}$

$2\le m\le10^{16}$

$1\le p,q,r,t,u,v,w,x,y,z\le100$

# $\texttt{Solution}$

~~因为暴力人人都会，所以直接上正解。~~

每次转移的项数都很少，而 $n$ 很大，所以自然而然地想到了矩阵加速。

不难想到 $1\times11$ 的状态矩阵初始应该长这样子：

$$
\begin{bmatrix}
a_{k+1}&b_{k+1}&c_{k+1}&a_k&b_k&c_k&k^2&k&1&w^k&z^k
\end{bmatrix}
$$

于是 $11\times11$ 的转移矩阵随便画一下就出来了：

$$
\begin{bmatrix}
p&1&1&1&0&0&0&0&0&0&0\\
1&u&1&0&1&0&0&0&0&0&0\\
1&1&x&0&0&1&0&0&0&0&0\\
q&0&0&0&0&0&0&0&0&0&0\\
0&v&0&0&0&0&0&0&0&0&0\\
0&0&y&0&0&0&0&0&0&0&0\\
r&0&0&0&0&0&1&0&0&0&0\\
t&0&1&0&0&0&2&1&0&0&0\\
1&0&2&0&0&0&1&1&1&0&0\\
0&1&0&0&0&0&0&0&0&w&0\\
0&0&1&0&0&0&0&0&0&0&z
\end{bmatrix}
$$

接下来矩阵快速幂即可。

---

注意因为模数太大，所以要用龟速乘。

---

时间复杂度：$\mathcal{O}(\log n\log m)$，有个 $11^3$ 的 ~~常数~~。

# $\texttt{Code}$

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>

using namespace std;

typedef long long ll;

ll m, p, q, r, t, u, v, w, x, y, z;

struct Matrix {
	int n, m;
	ll a[15][15];
	
	inline Matrix () {
		memset(a, 0, sizeof(a));
	}
} base, ans;

inline ll quickMul (ll a, ll b) {
	ll res = 0;
	a %= m;
	b %= m;
	while (b) {
		if (b & 1)
			res = (res + a) % m;
		b >>= 1;
		a = (a + a) % m;
	}
	return res;
}

inline Matrix operator * (Matrix a, Matrix b) {
	Matrix res;
	res.n = a.n;
	res.m = b.m;
	for (int i = 1; i <= a.n; i++)
		for (int j = 1; j <= b.m; j++)
			for (int k = 1; k <= a.m; k++)
				res.a[i][j] = (res.a[i][j] + quickMul(a.a[i][k], b.a[k][j])) % m;
	return res;
}

inline Matrix quickPow (Matrix a, ll k) {
	Matrix res;
	res.n = res.m = a.n;
	for (int i = 1; i <= a.n; i++)
		res.a[i][i] = 1;
	while (k) {
		if (k & 1)
			res = res * a;
		k >>= 1;
		a = a * a;
	}
	return res;
}

inline void init_base () {
	base.n = base.m = 11;
	base.a[1][2] = base.a[1][3] = base.a[1][4] = base.a[2][1] = base.a[2][3] = base.a[2][5] = base.a[3][1] = base.a[3][2] = base.a[3][6] = base.a[7][7] = base.a[8][3] = base.a[8][8] = base.a[9][1] = base.a[9][7] = base.a[9][8] = base.a[9][9] = base.a[10][2] = base.a[11][3] = 1;
	base.a[8][7] = base.a[9][3] = 2;
	base.a[1][1] = p;
	base.a[2][2] = u;
	base.a[3][3] = x;
	base.a[4][1] = q;
	base.a[5][2] = v;
	base.a[6][3] = y;
	base.a[7][1] = r;
	base.a[8][1] = t;
	base.a[10][10] = w;
	base.a[11][11] = z;
}

inline void init_ans () {
	ans.n = 1;
	ans.m = 11;
	ans.a[1][1] = ans.a[1][2] = ans.a[1][3] = 3;
	ans.a[1][4] = ans.a[1][5] = ans.a[1][6] = ans.a[1][7] = ans.a[1][8] = ans.a[1][9] = 1;
	ans.a[1][10] = w;
	ans.a[1][11] = z;
}

int main () {
	ll n;
	scanf("%lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld", &n, &m, &p, &q, &r, &t, &u, &v, &w, &x, &y, &z);
	if (n < 2) {
		puts("nodgd 1");
		puts("Ciocio 1");
		puts("Nicole 1");
		return 0;
	}
	init_base();
	init_ans();
	ans = ans * quickPow(base, n - 2);
	printf("nodgd %lld\nCiocio %lld\nNicole %lld", ans.a[1][1], ans.a[1][2], ans.a[1][3]);
	return 0;
}
```

---

## 作者：nodgd (赞：12)

题目已经说了是矩阵乘法，这里只须把怎么乘说一下就行了。

递推式子题目已经给出，都是二阶线性递推，我个人认为难点在于剩下的一堆指数项、平方项之类的。

由于矩阵乘法是用来搞线性递推的，所以我们需要把指数项、平方项之类的都化成线性递推。

对于一次项：(k+1) = k + 1;

对于平方项：(k+1)^2 = k^2 + 2\*k + 1;

对于指数项：w^(k+1) = w\*w^k;

所以我们需要同时维护a[k+1],a[k],b[k+1],b[k],c[k+1],c[k],w^k,z^k,k^2,k,1这11个项的递推。

只需要生成如下的矩阵，就可以开始递推了：

状态矩阵F[k]==

【 a[k] a[k+1] b[k] b[k+1] c[k]  c[k+1]  k^2    k    w^k   z^k    1 】

转移矩阵A==

【    0     q     0     0     0     0     0     0     0     0     0 】

【    1     p     0     1     0     1     0     0     0     0     0 】

【    0     0     0     u     0     0     0     0     0     0     0 】

【    0     1     1     v     0     1     0     0     0     0     0 】

【    0     0     0     0     0     x     0     0     0     0     0 】

【    0     1     0     1     1     y     0     0     0     0     0 】

【    0     r     0     0     0     0     1     0     0     0     0 】

【    0     t     0     0     0     1     2     1     0     0     0 】

【    0     0     0     1     0     0     0     0     w     0     0 】

【    0     0     0     0     0     1     0     0     0     z     0 】

【    0     1     0     0     0     2     1     1     0     0     1 】

然后由F[k]\*A==F[k+1]来快速幂。


另外一个方面，由于用来mod的K比较大，直接乘可能会超过64位长整型的数据范围，我们可以用加法代替乘法，也就是二分快速幂的代码把乘号改成加号。时间复杂度添上一个O(logK)。总的时间复杂度为O(11^3\*logN\*logK)，稳稳地AC。


附代码。（矩阵乘法我不喜欢写函数，写了若干个for循环。。。。）

```cpp

#include <cstdio> 
#include <cstdlib>
using namespace std;
unsigned long long N,K,a[13][13],c[13][13],t[13][13],f[13];
int m=11;
unsigned long long _mul(unsigned long long aa,unsigned long long bb)
{
    unsigned long long cc=0;
    if(aa==0||bb==0)return 0;
    while(bb>1)
    {
        if(bb%2==1)cc=(cc+aa)%K;
        aa=(aa+aa)%K;
        bb=bb/2;
    }
    bb=(aa+cc)%K;
    return bb;
}
void _Mqsm()
{
    int i,j,k;
    unsigned long long b;
    b=N-1;
    while(b>1)
    {
        if(b%2==1)
        {
            for(i=1;i<=m;i++)
                for(j=1;j<=m;j++)
                {
                    t[i][j]=0;
                    for(k=1;k<=m;k++)
                        t[i][j]=(t[i][j]+_mul(a[i][k],c[k][j]))%K;
                }
            for(i=1;i<=m;i++)
                for(j=1;j<=m;j++)
                    c[i][j]=t[i][j];
        }
        for(i=1;i<=m;i++)
            for(j=1;j<=m;j++)
            {
                t[i][j]=0;
                for(k=1;k<=m;k++)
                    t[i][j]=(t[i][j]+_mul(a[i][k],a[k][j]))%K;
            }
        for(i=1;i<=m;i++)
            for(j=1;j<=m;j++)
                a[i][j]=t[i][j];
        b=b/2;
    }
    for(i=1;i<=m;i++)
        for(j=1;j<=m;j++)
        {
            t[i][j]=0;
            for(k=1;k<=m;k++)
                t[i][j]=(t[i][j]+_mul(a[i][k],c[k][j]))%K;
        }
    for(i=1;i<=m;i++)
        for(j=1;j<=m;j++)
            a[i][j]=t[i][j];
    for(i=1;i<=1;i++)
        for(j=1;j<=m;j++)
        {
            t[i][j]=0;
            for(k=1;k<=m;k++)
                t[i][j]=(t[i][j]+_mul(f[k],a[k][j]))%K;
        }
    printf("nodgd %I64dn",t[1][1]);
    printf("Ciocio %I64dn",t[1][3]);
    printf("Nicole %I64dn",t[1][5]);
}
int main()
{
    int i,p,q,r,t,u,v,w,x,y,z;
    m=11;
    scanf("%I64d%I64d",&N,&K);
    scanf("%d%d%d%d",&p,&q,&r,&t);
    a[2][2]=p;a[1][2]=q;a[7][2]=r;a[8][2]=t;
    scanf("%d%d%d",&u,&v,&w);
    a[4][4]=u;a[3][4]=v;a[9][9]=w;
    scanf("%d%d%d",&x,&y,&z);
    a[6][6]=x;a[5][6]=y;a[10][10]=z;
    a[2][1]=a[2][4]=a[2][6]=1;
    a[4][2]=a[4][3]=a[4][6]=1;
    a[6][2]=a[6][4]=a[6][5]=1;
    a[7][7]=1;
    a[8][6]=a[8][8]=1;
    a[9][4]=1;
    a[10][6]=1;
    a[11][2]=a[11][7]=a[11][8]=a[11][11]=1;
    a[8][7]=a[11][6]=2;
    for(i=1;i<=m;i++)c[i][i]=1;
    f[1]=f[3]=f[5]=f[7]=f[8]=f[11]=1;
    f[2]=f[4]=f[6]=3;
    f[9]=w;f[10]=z;
    _Mqsm();
    return 0;
}


```

---

## 作者：qwaszx (赞：9)

这题怎么说呢

挺毒瘤的一个矩乘

特点在于不是齐次的qwq

我记得我第一次问我loser学长f[i]=f[i-1]+x*x怎么矩阵加速的时候学长说不能加速qwq

但事实上我们可以把x*x这样的东西变成递推

比如w^(k+1)=w*w^k

(k+1)^2=k^2+2k+1

如果你把这个与k有关的式子记为f[k]的话，它可以写成一个递推式

以f[k]=k*k为例

f[k+1]=f[k]+2*k+1

于是要再记g[k]=k

g[k+1]=g[k]+1

然后再记h[k]=1

这样所有项都化成了递推的形式

于是可以矩阵加速

具体如何加速楼下两个dalao说的很明白了

我只在代码里加一些细小的优化

具体见注释

```cpp
// luogu-judger-enable-o2
//其实O2没什么用...本来就是0ms，还没加inline register啥的
#include<cstdio>//少开库减少空间，我就是这么rk1的
const long long md=1LL<<60;//减少取模次数用的常量，大于md的时候取模，因为%比较慢
long long n,m;
int p,q,r,t,u,v,w,x,y,z,st[11]={3,1,3,1,3,1,0,0,1,1,1};;
struct hh{long long a[11][11];};
long long mul(long long kx,long long ky,long long m) {return (kx*ky-(long long)((long double)kx/m*ky)*m+m)%m;}//看了rk1的代码明白的 这**比慢速乘快多了 出题人给的正解是慢速乘 但为了保险数很大还是要用慢速乘
/*long long mul(long long a,long long b,long long m)//没用了的慢速乘qaq
{
    long long ans=0;
    while(b)
    {
        if(b&1)
        {
            ans=ans+a;
            if(ans>md)ans%=m;
        }
        a=a+a;
        if(a>md)a%=m;
        b>>=1;
    }
    return ans;
}*/
hh operator * (hh a,hh b)//矩阵乘法
{
    hh c={0};
    for(int i=0;i<11;i++)
        for(int k=0;k<11;k++)
            if(a.a[i][k])//注意，这里把k和j调换过来，防止稀疏矩阵造成的无用操作，因为如果a[i][k]为0的话j循环没有意义
                for(int j=0;j<11;j++)
                {
                    c.a[i][j]+=mul(a.a[i][k],b.a[k][j],m);
                    if(c.a[i][j]>md)c.a[i][j]%=m;
                }
    return c;
}
hh qpower(hh a,long long b,long long m)//普通快速幂
{
    hh ans={0};//主对角线(左上-右下)为1其它为0的矩阵是单位矩阵，一个矩阵乘单位矩阵后不发生变化
    for(int i=0;i<11;i++)ans.a[i][i]=1;
    while(b)
    {
        if(b&1)ans=ans*a;
        a=a*a;
        b>>=1;
    }
    return ans;
}
int main()
{
    scanf("%lld%lld%d%d%d%d%d%d%d%d%d%d",&n,&m,&p,&q,&r,&t,&u,&v,&w,&x,&y,&z);
    st[6]=w,st[7]=z;//st是递推中每一项f[1]的值
    hh f={p	,q	,1	,0	,1	,0	,0	,0	,r	,t  ,1
         ,1	,0	,0	,0	,0	,0	,0	,0	,0	,0  ,0
         ,1	,0	,u	,v	,1	,0	,1	,0	,0	,0  ,0
         ,0	,0	,1	,0	,0	,0	,0	,0	,0	,0  ,0
         ,1	,0	,1	,0	,x	,y	,0	,1	,0	,1  ,2
         ,0	,0	,0	,0	,1	,0	,0	,0	,0	,0  ,0
         ,0	,0	,0	,0	,0	,0	,w	,0	,0	,0  ,0
         ,0	,0	,0	,0	,0	,0	,0	,z	,0	,0  ,0
         ,0	,0	,0	,0	,0	,0	,0	,0	,1	,2  ,1
         ,0	,0	,0	,0	,0	,0	,0	,0	,0	,1  ,1
         ,0	,0	,0	,0	,0	,0	,0	,0	,0	,0  ,1};//构造转移矩阵
    f=qpower(f,n-2,m);
    long long a1=0,a2=0,a3=0;//把初值算上
    for(int i=0;i<11;i++)a1=(a1+mul(f.a[0][i],st[i],m))%m,a2=(a2+mul(f.a[2][i],st[i],m))%m,a3=(a3+mul(f.a[4][i],st[i],m))%m;
    printf("nodgd %lld\nCiocio %lld\nNicole %lld",a1,a2,a3);
}
```
主要就是告诉你怎么搞常系数线性非齐次递推关系，然后这东西不怎么好调，自己注意

转移矩阵的构造毫无难度

---

## 作者：Utilokasteinn (赞：7)

## [Link](https://www.luogu.com.cn/problem/P1707)

一眼可知可以 $\mathcal{O}(n)$ 递推，但由于 $n$ 很大，所以考虑优化。

学过矩阵快速幂都容易发现可以用矩阵快速幂进行优化。那就需要构造矩阵，使得可以从第 $k$ 天转移到第 $k+1$ 天。

可以发现只维护 $a_{k+1}$，$b_{k+1}$，$c_{k+1}$ 是不能推出 $a_{k+2}$，$b_{k+2}$，$c_{k+2}$ 的。经过观察，我们一共要维护以下 $11$ 个值：

$$\begin{bmatrix}
a_{k+1}\\
b_{k+1}\\
c_{k+1}\\
a_k\\
b_k\\
c_k\\
k^2\\
k\\
1\\
w^k\\
z^k\\
\end{bmatrix}$$

那么容易构造矩阵，使得从 $k+1$ 天转移到 $k+2$ 天，转移如下：

$$\begin{bmatrix}
p&1&1&q&0&0&r&t&1&0&0\\
1&u&1&0&v&0&0&0&0&1&0\\
1&1&x&0&0&y&0&1&2&0&1\\
1&0&0&0&0&0&0&0&0&0&0\\
0&1&0&0&0&0&0&0&0&0&0\\
0&0&1&0&0&0&0&0&0&0&0\\
0&0&0&0&0&0&1&2&1&0&0\\
0&0&0&0&0&0&0&1&1&0&0\\
0&0&0&0&0&0&0&0&1&0&0\\
0&0&0&0&0&0&0&0&0&w&0\\
0&0&0&0&0&0&0&0&0&0&z\\
\end{bmatrix}
\times
\begin{bmatrix}
a_{k+1}\\
b_{k+1}\\
c_{k+1}\\
a_k\\
b_k\\
c_k\\
k^2\\
k\\
1\\
w^k\\
z^k\\
\end{bmatrix}=
\begin{bmatrix}
a_{k+2}\\
b_{k+2}\\
c_{k+2}\\
a_{k+1}\\
b_{k+1}\\
c_{k+1}\\
(k+1)^2\\
k+1\\
1\\
w^{k+1}\\
z^{k+1}\\
\end{bmatrix}
$$

只要求出第一个矩阵的 $n-2$ 次方再乘上 $k=1$ 时的第二个矩阵，就可以得出答案。

注意数据，发现相乘时大概率会爆 ```long long```。但是初始是不会的，所以显然可以用龟速幂，时间复杂度 $O(11^3\log m\log A)$，$A$ 为求快速幂时的底数。

但由于现在 CSP 和 NOIP 等比赛可以用 ```__int128```，所以该题可以用```__int128``` 水过去了……

代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
__int128 n,mod,p,q,r,t,u,v,w,x,y,z;
struct matrix{
	__int128 a[15][15];
	matrix(){memset(a,0,sizeof(a));}
}res,base,num;
inline __int128 read()
{
    __int128 s=0;char c=getchar();
    for(;!isdigit(c);c=getchar());
    for(;isdigit(c);c=getchar())
        s=s*10+c-'0';
    return s;
}
void write(__int128 x)
{
    static char buf[50];
    static int len=-1;
    if(x<0)putchar('-'),x=-x;
    do buf[++len]=x%10,x/=10;while(x);
    while(len>=0)putchar(buf[len--]+'0');
    putchar('\n');
}
matrix operator * (const matrix &a,const matrix &b)
{
	matrix c;
	for(int i=1;i<=11;i++)
		for(int j=1;j<=11;j++)
			for(int k=1;k<=11;k++)
				c.a[i][j]=(c.a[i][j]+a.a[i][k]*b.a[k][j]%mod)%mod;
	return c;
}
inline void input()
{
	n=read(),mod=read();
	p=read(),q=read(),r=read(),t=read();
	u=read(),v=read(),w=read();
	x=read(),y=read(),z=read();
}
inline void init()
{
	for(int i=1;i<=11;i++)
		res.a[i][i]=1;
	base.a[1][1]=p,base.a[1][2]=base.a[1][3]=1,base.a[1][4]=q,base.a[1][7]=r,base.a[1][8]=t,base.a[1][9]=1;
	base.a[2][1]=1,base.a[2][2]=u,base.a[2][3]=1,base.a[2][5]=v,base.a[2][10]=1;
	base.a[3][1]=base.a[3][2]=1,base.a[3][3]=x,base.a[3][6]=y,base.a[3][8]=1,base.a[3][9]=2,base.a[3][11]=1;
	base.a[4][1]=1;
	base.a[5][2]=1;
	base.a[6][3]=1;
	base.a[7][7]=1,base.a[7][8]=2,base.a[7][9]=1;
	base.a[8][8]=base.a[8][9]=1;
	base.a[9][9]=1;
	base.a[10][10]=w;
	base.a[11][11]=z;
	num.a[1][1]=num.a[2][1]=num.a[3][1]=3;
	num.a[4][1]=num.a[5][1]=num.a[6][1]=num.a[7][1]=num.a[8][1]=num.a[9][1]=1;
	num.a[10][1]=w;
	num.a[11][1]=z;
}
void qpow(__int128 k)
{
	while(k)
	{
		if(k&1)res=res*base;
		k>>=1,base=base*base;
	}
	res=res*num;
}
void print()
{
	printf("nodgd ");
	write(res.a[1][1]);
	printf("Ciocio ");
	write(res.a[2][1]);
	printf("Nicole ");
	write(res.a[3][1]);
}
int main()
{
	input();
	init();
	qpow(n-2);
	print();
	return 0;
}
```

---

## 作者：灼眼的夏娜 (赞：3)

首先感谢**叶璃caco3**dalao为我指出错误，让我终于A了这恶心了我一晚上的题

显然，这是个矩乘，需要我们推元矩阵，我们要维护的信息如下：

$a_{k+2},a_{k+1},b_{k+2},b_{k+1},c_{k+2},c_{k+1},k^{2},k,w^{k},$
$z^{k},$常数，没错，总共11个！

那接下来就让我们开始推吧（如果你不造啥是矩阵乘法请自觉问度娘）

把刚刚的11个信息塞到一个矩阵里，就有

| $a_{k+2}$ |$a_{k+1}$  |$b_{k+2}$  |$b_{k+1}$  |$c_{k+2}$  |$c_{k+1}$  |$k^{2}$  |$k$  |$w^{k}$  |$z^{k}$  |$1$  |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
根据题意，让以上矩阵放在乘号右边，左边是元矩阵，这可以得到以下矩阵

【$p,1,1,0,1,0,0,0,0,0,0$】

【$q,0,0,0,0,0,0,0,0,0,0$】

【$1,0,u,1,1,0,0,0,0,0,0$】

【$0,0,v,0,0,0,0,0,0,0,0$】

【$1,0,1,0,x,1,0,0,0,0,0$】

【$0,0,0,0,y,0,0,0,0,0,0$】

【$r,0,0,0,0,0,1,0,0,0,0$】

【$t,0,0,0,1,0,2,1,0,0,0$】

【$0,0,1,0,0,0,0,0,w,0,0$】

【$0,0,0,0,1,0,0,0,0,z,0$】

【$1,0,0,0,2,0,1,1,0,0,1$】

~~是不是非常恶心~~

那接下来就是正常的矩阵快速幂了。

## **注意以下几点：**

①我调了一晚上的原因，$k$变$k+1$的时候没有乘那个1（555555），包括

平方项也是，一定要注意是$k+1$以及$k^{2}+2*k+1$

②矩阵又结合性但不具有交换性，如果你的矩阵一直乘错，试试把两个矩阵

的顺序交换一下（~~说不定就A了~~）

③注意这玩意非常大，需要龟速乘，不然ULL也可以

当然初始矩阵就是{$3,1,3,1,3,1,1,1,w,z,1$}啦

最后我们的答案就是$f$矩阵的1,3,5,项啦，到了愉快的代码时间

## code
```cpp
#include<bits/stdc++.h>
#define R register

using namespace std;
typedef long long LL;
LL n, k;
int p, q, r, t;
int u, v, w;
int x, y, z;
struct JU {
	LL v[12][12];
}f, base;

inline LL sxsy(LL a, LL b) {//龟速乘
	LL res = 0;
	for(; b ;b >>= 1, a = (a << 1) % k)
		if(b & 1)
			res = (res + a) % k;
	return res;
}

JU operator * (JU a, JU b) {重载*号
	JU c;
	memset(c.v, 0, sizeof(c.v));
	for(R int i = 1;i <= 11;++ i) {
		for(R int j = 1;j <= 11;++ j) {
			for(R int l = 1;l <= 11;++ l) {
				c.v[i][j] = (c.v[i][j] + sxsy(a.v[i][l], b.v[l][j])) % k;
			}
		}
	}
	return c;
}

inline JU qxsy(JU a, LL b) {矩阵快速幂
	JU res;
	memset(res.v, 0, sizeof(res.v));
	for(R int i = 1;i <= 11;++ i) res.v[i][i] = 1;
	for(; b ;b >>= 1, a = a * a)
		if(b & 1)
			res = res * a;
	return res;
}

int main() {
	scanf("%lld%lld",&n, &k);
	scanf("%d%d%d%d",&p, &q, &r, &t);
	scanf("%d%d%d",&u, &v, &w);
	scanf("%d%d%d",&x, &y, &z);
	
	f.v[1][1] = f.v[1][3] = f.v[1][5] = 3初始矩阵;
	f.v[1][2] = f.v[1][4] = f.v[1][6] = 1;
	f.v[1][7] = f.v[1][8] = f.v[1][11] = 1;
	f.v[1][9] = w, f.v[1][10] = z;
	//最恶心的元矩阵
	base.v[1][1] = p, base.v[1][2] = 1, base.v[1][3] = 1;
	base.v[1][5] = 1, base.v[2][1] = q, base.v[3][1] = 1;
	base.v[3][3] = u, base.v[3][4] = 1, base.v[3][5] = 1;
	base.v[4][3] = v, base.v[5][1] = 1, base.v[5][3] = 1;
	base.v[5][5] = x, base.v[5][6] = 1, base.v[6][5] = y;
	base.v[7][1] = r, base.v[7][7] = 1, base.v[8][1] = t;
	base.v[8][5] = 1, base.v[8][7] = 2, base.v[8][8] = 1;
	base.v[9][3] = 1, base.v[9][9] = w, base.v[10][5] = 1;
	base.v[10][10] = z, base.v[11][1] = 1, base.v[11][5] = 2;
	base.v[11][7] = base.v[11][8] = base.v[11][11] = 1;
	
	f = f * qxsy(base, n - 2);
	printf("nodgd %lld\n",f.v[1][1]);
	printf("Ciocio %lld\n",f.v[1][3]);
	printf("Nicole %lld\n",f.v[1][5]);
	return 0;
}
```
完结撒花

---

## 作者：Wuyanru (赞：2)

这是一道很好的矩阵快速幂练手题。

首先我们来看暴力破解，这种做法在最优情况下空间复杂度为 $ \Theta\left(1\right) $,时间复杂度会达到 $ \Theta\left(n\right) $,但是本题数据范围为 $ 1 \le n \le 10^{16} $,暴力显然是不行的。

所以，我们完全可以猜测时间复杂度为 $ \Theta\left(\log_2k\right) $,这种时间复杂度使用矩阵快速幂就完全可以做到。

首先，~~由于本人看题目中转移公式很不顺眼~~，所以我们可以将这三个公式变成下面这种样子：

$ a_{k+1}=pa_k+qa_{k-1}+b_k+c_k+r\left(k-1\right)^2+t\left(k-1\right)+1 $

$ b_{k+1}=ub_k+vb_{k-1}+a_k+c_k+w^{k-1} $

$ a_{k+1}=xc_k+yc_{k-1}+a_k+b_k+z^{k-1}+\left(k-1\right)+2 $

接下来，我们就可以构造矩阵了，让我们首先来确认需要进行维护的变量，首先 $ a_k $,$ a_{k-1} $,$ b_k $,$ b_{k-1} $,$ c_k $,$ c_{k-1} $ 这六个肯定是要一直保留的，其次，我们还需要 $ \left(k-1\right)^2 $,$ w^{k-1} $,$ z^{k-1} $ 这几个变量，同时，为了维护 $ \left(k-1\right)^2 $ 我们也需要维护 $ k-1 $ 和 $ 1 $。

所以，我们就可以构造出一个矩阵了：

$  \begin{vmatrix}
a_k  &b_k  &c_k  &a_{k-1}  &b_{k-1}  &c_{k-1}  &\left(k-1\right)^2  &\left(k-1\right)  &1  &w^{k-1}  &z^{k-1}
\end{vmatrix} $

接下来，我给出几个显而易见的转移公式：

$ k^2=\left(k-1\right)^2+2\times\left(k-1\right)+1 $

$ k=\left(k-1\right)+1 $

$ w^k=w^{k-1}\times w $

$ z^k=z^{k-1}\times z $

有了这几个公式与题目中所给的三个公式，我们就可以得出用于转移的这个矩阵了，它长这个样子：

$ \begin{vmatrix}
p  &1  &1  &1  &0  &0  &0  &0  &0  &0  &0 \\
1  &u  &1  &0  &1  &0  &0  &0  &0  &0  &0 \\
1  &1  &x  &0  &0  &1  &0  &0  &0  &0  &0 \\
q  &0  &0  &0  &0  &0  &0  &0  &0  &0  &0 \\
0  &v  &0  &0  &0  &0  &0  &0  &0  &0  &0 \\
0  &0  &y  &0  &0  &0  &0  &0  &0  &0  &0 \\
r  &0  &0  &0  &0  &0  &1  &0  &0  &0  &0 \\
t  &0  &1  &0  &0  &0  &2  &1  &0  &0  &0 \\
1  &0  &2  &0  &0  &0  &1  &1  &1  &0  &0 \\
0  &1  &0  &0  &0  &0  &0  &0  &0  &w  &0 \\
0  &0  &1  &0  &0  &0  &0  &0  &0  &0  &z
\end{vmatrix} $

于是，我们就把本题中最大的困难，构造矩阵解决了。

现在我们还有一个小问题，就是两个最大为 $ 10^{16} $ 的数怎么相乘，其实这一个问题我们可以使用龟速乘来解决。

从字面上理解，就是很慢的乘法，其实它也慢不到哪里去。龟速乘也就是利用了快速幂的思想，从而实现很大两数相乘取模的情况，详情大家可以看代码。

如果有不会矩阵快速幂的同学，可以查看[我的博客](https://www.luogu.com.cn/blog/wuyanru/guan-yu-ju-zhen)，这里有关于矩阵的代码，快速幂都是写好的。

AC 代码：

```
#include<cstring>
#include<cstdio>
using namespace std;
long long n,mm;
long long p,q,r,t;
long long u,v,w;
long long x,y,z;
long long cheng(long long a,long long b) {
	long long ans=0;
	while(b) {
		if(b&1) {
			ans=ans+a;
			ans%=mm;
		}
		a=a+a;
		a%=mm;
		b>>=1;
	}
	return ans;
}
struct mat {
	long long m,n;
	long long a[12][12];
	mat operator + (mat b) {
		mat ans;
		memset(ans.a,0,sizeof(ans.a));
		ans.m=m,ans.n=n;
		for(int i=1; i<=m; i++)
			for(int j=1; j<=n; j++)
				ans.a[i][j]=a[i][j]+b.a[i][j];
		return ans;
	}
	void operator += (mat b) {
		for(int i=1; i<=m; i++)
			for(int j=1; j<=n; j++)
				a[i][j]+=b.a[i][j];
	}
	mat operator - (mat b) {
		mat ans;
		memset(ans.a,0,sizeof(ans.a));
		ans.m=m,ans.n=n;
		for(int i=1; i<=m; i++)
			for(int j=1; j<=n; j++)
				ans.a[i][j]=a[i][j]-b.a[i][j];
		return ans;
	}
	void operator -= (mat b) {
		for(int i=1; i<=m; i++)
			for(int j=1; j<=n; j++)
				a[i][j]-=b.a[i][j];
	}
	mat operator * (mat b) {
		mat ans;
		memset(ans.a,0,sizeof(ans.a));
		ans.m=m;
		ans.n=b.n;
		for(int i=1; i<=m; i++)
			for(int j=1; j<=b.n; j++)
				for(int p=1; p<=n; p++) {
					ans.a[i][j]+=cheng(a[i][p],b.a[p][j]);
					ans.a[i][j]%=mm;
				}
		return ans;
	}
	void operator *= (mat b) {
		(*this)=(*this)*b;
	}
	mat operator ^ (long long t) {
		mat ans,num;
		ans.m=ans.n=m;
		num=(*this);
		memset(ans.a,0,sizeof(ans.a));
		for(int i=1; i<=m; i++)
			ans.a[i][i]=1;
		while(t) {
			if(t&1)
				ans=ans*num;
			num=num*num;
			t>>=1;
		}
		return ans;
	}
	void operator ^= (long long t) {
		(*this)=(*this)^t;
	}
	mat operator % (long long t) {
		mat ans;
		ans.m=m,ans.n=n;
		for(int i=1; i<=m; i++)
			for(int j=1; j<=n; j++)
				ans.a[i][j]=a[i][j]%t;
		return ans;
	}
	void operator = (mat b) {
		m=b.m,n=b.n;
		for(int i=1; i<=b.m; i++)
			for(int j=1; j<=b.n; j++)
				a[i][j]=b.a[i][j];
	}
	bool operator == (mat b) {
		if(m!=b.m||n!=b.n)
			return false;
		for(int i=1; i<=m; i++)
			for(int j=1; j<=n; j++)
				if(a[i][j]!=b.a[i][j])
					return false;
		return true;
	}
	void inn() {
		scanf("%lld",&n);
	}
	void inm() {
		scanf("%lld",&m);
	}
	void innn() {
		inm();
		n=m;
	}
	void inmn() {
		inm();
		inn();
	}
	void ina() {
		for(int i=1; i<=m; i++)
			for(int j=1; j<=n; j++)
				scanf("%lld",&a[i][j]);
	}
	void in() {
		inmn();
		ina();
	}
	void outm() {
		printf("%lld\n",m);
	}
	void outn() {
		printf("%lld\n",n);
	}
	void outmn() {
		printf("%lld %lld\n",m,n);
	}
	void outa() {
		for(int i=1; i<=m; i++) {
			for(int j=1; j<=n; j++)
				printf("%lld ",a[i][j]);
			printf("\n");
		}
	}
	void out() {
		outmn();
		outa();
	}
};
mat num,ans;
int main() {
	scanf("%lld%lld",&n,&mm);
	scanf("%lld%lld%lld%lld",&p,&q,&r,&t);
	scanf("%lld%lld%lld",&u,&v,&w);
	scanf("%lld%lld%lld",&x,&y,&z);
	memset(num.a,0,sizeof(num.a));
	memset(ans.a,0,sizeof(ans.a));
	ans.m=1,ans.n=11;
	ans.a[1][1]=ans.a[1][2]=ans.a[1][3]=3;
	ans.a[1][4]=ans.a[1][5]=ans.a[1][6]=1;
	ans.a[1][7]=ans.a[1][8]=ans.a[1][9]=1;
	ans.a[1][10]=w,ans.a[1][11]=z;
	num.m=num.n=11;
	num.a[1][1]=p,num.a[1][2]=num.a[1][3]=num.a[1][4]=1;
	num.a[2][2]=u,num.a[2][1]=num.a[2][3]=num.a[2][5]=1;
	num.a[3][3]=x,num.a[3][1]=num.a[3][2]=num.a[3][6]=1;
	num.a[4][1]=q,num.a[5][2]=v,num.a[6][3]=y;
	num.a[7][1]=r,num.a[7][7]=1;
	num.a[8][1]=t,num.a[8][3]=num.a[8][8]=1,num.a[8][7]=2;
	num.a[9][1]=num.a[9][7]=num.a[9][8]=num.a[9][9]=1,num.a[9][3]=2;
	num.a[10][10]=w,num.a[10][2]=1;
	num.a[11][11]=z,num.a[11][3]=1;
	num^=(n-2);
	ans=ans*num;
	printf("nodgd %lld\nCiocio %lld\nNicole %lld",ans.a[1][1],ans.a[1][2],ans.a[1][3]);
	return 0;
}
```
几个小细节：

1.  矩阵进行快速幂中指数为 $ k-2 $ 次，千万不要写错；

2.  矩阵记得初始化；

3.  本题中的变量尽量都使用 long long 类型；

4.  记得使用龟速乘，不要顺手打成快速幂的代码。

5.  记得取模，取的模要正确。

感谢观看！

---

## 作者：brealid (赞：2)

毕竟是道矩阵乘法，大家用的矩阵都各(非)不(常)相(恶)同(心)

这里提供一下我用的矩阵

![](http://47.104.147.153:818/storage/65/P1707-matrix.png)

表格链接 http://47.104.147.153:818/storage/65/P1707-matrix.html

不同之处在于，我转移用的都是 $k$, $k-1$。

然而其他写题解的人们用的是 $k+1$, $k$。

这就导致卡速米的幂数不同（我：$N-2$；其他人：$N-3$）

再来说一下本题

一般，矩阵乘法的题目都比较浅显，很容易看出来；而转移用的矩阵也比较好推理（如果你已经做过含 $z^k$ 或 $k^z$ 的题目，k是项的编号，z是常数）

然而，到了提高+层次（尤其本题还是 省选/NOI-）的时候，就要考虑题目的坑了

## 题目的坑

### 一个明显的坑

矩阵乘法的时候不能直接乘，要用特殊乘法：

1. 龟速乘
2. $long\ double$误差大乘（尤指本题，$K$非常大）
3. __int28联赛不能用乘

~~其实都很不靠谱~~

### 一个不太会跳进去的坑

~~然而我跳进去了~~

第2天不满足公式，所以转移完之后一定要再乘上 初始矩阵

$|\ 3\ |$  
$|\ 1\ |$  
$|\ 3\ |$  
$|\ 1\ |$  
$|\ 3\ |$  
$|\ 1\ |$  
$|\ 1\ |$  
$|\ 1\ |$  
$|\ 1\ |$  
$|\ \!w\ \!|$   
$|\ z\ |$  

### 一个容易进也容易出的坑

转移矩阵写错，较容易发现

然后应该没有什么坑了吧

## 喜闻乐见的 Code 时间
```
/*************************************
 * problem:      P1707 刷题比赛.
 * user ID:      63720.
 * user name:    Jomoo.
 * time:         2019-08-09.
 * language:     C++.
 * upload place: Luogu.
*************************************/ 

#include <bits/stdc++.h>
using namespace std;

template <typename Int>
inline Int read()       
{
    Int flag = 1;
    char c = getchar();
    while ((!isdigit(c)) && c != '-') c = getchar();
    if (c == '-') flag = -1, c = getchar();
    Int init = c & 15;
    while (isdigit(c = getchar())) init = (init << 3) + (init << 1) + (c & 15);
	return init * flag;
}

template <typename Int>
inline void write(Int x)
{
    if (x < 0) putchar('-'), x = ~x + 1;
    if (x > 9) write(x / 10);
    putchar((x % 10) | 48);
}  

template <typename Int>
inline void write(Int x, char nextch)
{
    write(x);
    putchar(nextch);
}

unsigned long long N, K;
unsigned long long p, q, r, t;
unsigned long long u, v, w;
unsigned long long x, y, z;

unsigned long long mul(unsigned long long x, unsigned long long y)
{
    unsigned long long res = 0;
    if (x < y) swap(x, y);
    if (!x || !y) return 0;
    while (y > 1) {
        if (y & 1) res = (x + res) % K;
        x = (x + x) % K;
        y >>= 1;
    }
    return (res + x) % K;
}

#define EMPTY_MATRIX 19260817
#define UNIT_MATRIX 114514
struct matrix {
    unsigned long long n, m;
    unsigned long long a[21][21];

    matrix(unsigned long long _n, unsigned long long _m, unsigned long long matrixType) : n(_n), m(_m)
    { 
        memset(a, 0, sizeof(a));
        if (matrixType == UNIT_MATRIX) for (unsigned long long i = 1; i <= _n; i++) a[i][i] = 1;
    }

    matrix operator * (const matrix &Timeser)
    {
        matrix res(n, Timeser.m, EMPTY_MATRIX);
        for (unsigned long long i = 1; i <= n; i++) {
            for (unsigned long long j = 1; j <= Timeser.m; j++) {
                for (unsigned long long k = 1; k <= m; k++) {
                    res.a[i][j] += mul(a[i][k], Timeser.a[k][j]) % K;
                    res.a[i][j] %= K;
                }
            }
        }
        return res;
    }
};

matrix fexp(matrix a, unsigned long long n)
{
    matrix res(a.n, a.m, UNIT_MATRIX);
    while (n) {
        if (n & 1) res = a * res;
        a = a * a;
        n >>= 1;
    }
    return res;
}

int main()
{
    N = read<unsigned long long>();
    K = read<unsigned long long>();
    // line 1
    p = read<unsigned long long>();
    q = read<unsigned long long>();
    r = read<unsigned long long>();
    t = read<unsigned long long>();
    // line 2
    u = read<unsigned long long>();
    v = read<unsigned long long>();
    w = read<unsigned long long>();
    // line 3
    x = read<unsigned long long>();
    y = read<unsigned long long>();
    z = read<unsigned long long>();
    // line 4
    matrix facer(11, 11, EMPTY_MATRIX), baser(11, 1, EMPTY_MATRIX), ans(11, 1, UNIT_MATRIX);
    // facer.n = 11;
    // facer.m = 11;
    facer.a[1][1] = p;
    facer.a[1][2] = 1;
    facer.a[1][3] = 1;
    facer.a[1][4] = q;
    facer.a[1][9] = r;
    facer.a[1][10] = t;
    facer.a[1][11] = 1;
    facer.a[2][1] = 1;
    facer.a[2][2] = u;
    facer.a[2][3] = 1;
    facer.a[2][5] = v;
    facer.a[2][7] = 1;
    facer.a[3][1] = 1;
    facer.a[3][2] = 1;
    facer.a[3][3] = x;
    facer.a[3][6] = y;
    facer.a[3][8] = 1;
    facer.a[3][10] = 1;
    facer.a[3][11] = 2;
    facer.a[4][1] = 1;
    facer.a[5][2] = 1;
    facer.a[6][3] = 1;
    facer.a[7][7] = w;
    facer.a[8][8] = z;
    facer.a[9][9] = 1;
    facer.a[9][10] = 2;
    facer.a[9][11] = 1;
    facer.a[10][10] = 1;
    facer.a[10][11] = 1;
    facer.a[11][11] = 1;
    // baser.n = 11;
    // baser.m = 1;
    baser.a[1][1] = 3;
    baser.a[2][1] = 3;
    baser.a[3][1] = 3;
    baser.a[4][1] = 1;
    baser.a[5][1] = 1;
    baser.a[6][1] = 1;
    baser.a[7][1] = w;
    baser.a[8][1] = z;
    baser.a[9][1] = 1;
    baser.a[10][1] = 1;
    baser.a[11][1] = 1;
    ans = fexp(facer, N - 2) * baser;
    printf("nodgd %llu\n", ans.a[1][1]);
    printf("Ciocio %llu\n", ans.a[2][1]);
    printf("Nicole %llu\n", ans.a[3][1]);
    return 0;
}
```

---

## 作者：Violet___Evergarden (赞：1)


矩阵乘法的恶心题。
# 配矩阵
可以配一个 $11$ 行 $11$ 列的矩阵，具体见下:

初始矩阵：
$$\begin{pmatrix} a_k & a_{k+1} & b_k & b_{k+1} &c_k & c_{k+1} & k^2 & k & z^k & w^k & 1 \end{pmatrix}\quad$$
那么系数矩阵怎么配呢？

前六个数的系数直接套公式。

根据以下几个公式可配出后面几个：
$$ (k+1)^2=k^2+2 \cdot k+1^2 $$


$$ z^{k+1} =z^k \cdot z$$

$$ w^{k+1}=w^k \cdot w$$

于是系数矩阵就出来啦！
$$\begin{pmatrix} 0 & q &0 & 0&0&0&0&0&0&0&0\\
1 &p& 0&1&0&1&0&0&0&0&0\\
0&0&0&v&0&0&0&0&0&0&0\\
0&1&1&u&0&1&0&0&0&0&0
\\
0&0&0&0&0&y&0&0&0&0&0\\
0&1&0&1&1&x&0&0&0&0&0
\\
0&r&0&0&0&0&1&0&0&0&0\\
0&t&0&0&0&1&2&0&0&0&0\\
0&0&0&0&0&1&0&0&z&0&0\\
0&0&0&1&0&0&0&0&0&w&0\\
0&1&0&0&0&2&1&1&0&0&1
\end{pmatrix}\quad$$


------------

# 龟速乘：
每个数都可以表示为一个或多个 $2^k$ 的和，于是：
$$ a \times b=a \times 2^{b_1} + a \times 2^{b_2} + \cdots(b_1 +b_2 +\cdots=b)$$

类似于快速幂。
这样算虽然会将乘法 $O(1)$ 的时间提升到 $O(\log(b))$，但这样可以在乘的过程中取模就不会爆数据类型了！
# AC CODE
懂了前面这些代码也就简单了！
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,q,p,r,t,u,v,w,x,y,z;
int a[12][12],b[12][12],c[12][12];
int ch(int a,int b)//龟速乘
{
    int ans=0;
    for(int i=1;i<=b;i<<=1)
    {
        if(b&i)
        {
            ans+=a;
            ans%=m;
        }
        a=a*2%m;
    }
    return ans;
}
void Mul(int a[12][12],int b[12][12])//矩阵乘法
{
    for(int i=1;i<=11;i++)
    {
        for(int j=1;j<=11;j++)
        {
            c[i][j]=0;
            for(int k=1;k<=11;k++)
            {
                c[i][j]+=ch(a[i][k],b[k][j])%m;
                c[i][j]%=m;
            }
        }
    }
}
signed main()
{
cin>>n>>m>>p>>q>>r>>t>>u>>v>>w>>x>>y>>z;
n--;
a[1][1]=1,a[1][2]=3,a[1][3]=1,a[1][4]=3,a[1][5]=1,a[1][6]=3,a[1][7]=1,a[1][8]=1,a[1][9]=z,a[1][10]=w,a[1][11]=1;
b[1][2]=q,b[6][4]=1,b[2][1]=1,b[2][2]=p,b[2][6]=1,b[3][4]=v,b[4][2]=1,b[4][3]=1,b[4][4]=u,b[5][6]=y,b[6][2]=1,b[6][5]=1,b[6][6]=x,b[7][2]=r,b[7][7]=1,b[8][2]=t,b[8][6]=1,b[8][7]=2,b[9][6]=1,b[10][4]=1,b[9][9]=z,b[10][10]=w,b[11][2]=1,b[11][6]=2,b[11][7]=1,b[11][8]=1,b[11][11]=1,b[2][4]=1,b[4][6]=1,b[8][8]=1;//初始化矩阵
for(int i=1;i<=n;i<<=1)//矩阵快速幂
{
    if(n&i)
    {
        Mul(a,b);
        for(int j=1;j<=11;j++)
        {
            for(int k=1;k<=11;k++)
            {
                a[j][k]=c[j][k];
            }
        }
    }
    Mul(b,b);
    for(int j=1;j<=11;j++)
    {
        for(int k=1;k<=11;k++)
        {
            b[j][k]=c[j][k];
        }
    }
}
cout<<"nodgd "<<a[1][1]<<"\n";
cout<<"Ciocio "<<a[1][3]<<"\n";
cout<<"Nicole "<<a[1][5]<<"\n";
return 0;
}
码字不易（特别是矩阵那一块）求过awa~

---

## 作者：Treaker (赞：1)

$$\color{cornflowerblue}{\mathcal{Treaker}}$$
## 矩阵乘法。。。
机房某个巨佬留的题，~~简直就是畜生-.-~~。

然后按照矩阵的套路手玩了一下矩阵，然后就A了

其实这道题挺简单的。。按照他给你的变量放入矩阵来构造就行了。

那么对于我们的递推有用的变量是什么呢？

显然从递推式可以看出是$~a[k+1],a[k],b[k+1],b[k],c[k+1],c[k],k^2,k,w^k,z^k,1~$。

中间的转移矩阵可以自己手玩一下。。

这里放出。

注：构造方法不唯一，仅供参考，我的矩阵是从右边向左边递推的。。。

| p | q | 1 | 0 | 1 | 0 | r | t | 0 | 0 | 1 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 0 | u | v | 1 | 0 | 0 | 0 | 1 | 0 | 0 |
| 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 0 | 1 | 0 | x | y | 0 | 1 | 0 | 1 | 2 |
| 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 1 | 2 | 0 | 0 | 1 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 1 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | w | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | z | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |

![](https://cdn.luogu.com.cn/upload/image_hosting/ur0ocnuo.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/e759mdgp.png)

### 矩阵乘法就是这么神奇


### 完整代码如下：
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#define ll long long
using namespace std;
const int N = 100005;
inline ll read()
{
	ll x = 0 , f = 1;	char ch = getchar();
	while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
ll n , mod , p , q , r , t , u , v , w , x , y , z;
struct martix
{
	ll f[12][12];
	martix() {memset(f,0,sizeof f);}
	void init() {for(int i = 1;i <= 11;i ++) f[i][i] = 1;}
}ans;
inline ll mul(ll a,ll b)
{
	ll res = 0;
	while(b)
	{
		if(b & 1) res = (res + a) % mod;
		a = (a + a) % mod;
		b >>= 1;
	}
	return res;
}
martix operator * (const martix & a,const martix & b)
{
	martix res;
	for(int k = 1;k <= 11;k ++) for(int i = 1;i <= 11;i ++) for(int j = 1;j <= 11;j ++) res.f[i][j] = (res.f[i][j] + mul(a.f[i][k],b.f[k][j])) % mod;
	return res;
}
inline martix ksm(ll b)
{
	martix res , a; res.init(); 
	a.f[1][1] = p; a.f[1][2] = q; a.f[1][3] = 1; a.f[1][5] = 1; a.f[1][7] = r; a.f[1][8] = t; a.f[1][11] = 1;
	a.f[2][1] = 1; a.f[3][1] = 1; a.f[3][3] = u; a.f[3][4] = v; a.f[3][5] = 1; a.f[3][9] = 1; a.f[4][3] = 1; 
	a.f[5][1] = 1; a.f[5][3] = 1; a.f[5][5] = x; a.f[5][6] = y; a.f[5][8] = 1; a.f[5][10] = 1; a.f[5][11] = 2; a.f[6][5] = 1;
	a.f[7][7] = 1; a.f[7][8] = 2; a.f[7][11] = 1; a.f[8][8] = 1; a.f[8][11] = 1; a.f[9][9] = w; a.f[10][10] = z; a.f[11][11] = 1;
	while(b)
	{
		if(b & 1) res = res * a;
		a = a * a;
		b >>= 1;
	}
	return res;
}
int main()
{
	n = read(); mod = read(); p = read(); q = read(); r = read(); t = read(); u = read(); v = read(); w = read(); x = read(); y = read(); z = read();
	ans.f[1][1] = ans.f[3][1] = ans.f[5][1] = 3; ans.f[2][1] = ans.f[4][1] = ans.f[6][1] = 1; ans.f[7][1] = ans.f[8][1] = 1; ans.f[9][1] = w; ans.f[10][1] = z; ans.f[11][1] = 1;
	ans = ksm(n-2) * ans;
	printf("nodgd %lld\nCiocio %lld\nNicole %lld\n",ans.f[1][1],ans.f[3][1],ans.f[5][1]);
	return 0;
}

```


---

## 作者：Leap_Frog (赞：1)

感觉有很多题解都是he来he去的诶（连矩阵前后的【】都不改

| | $a_{k+1}$| $b_{k+1}$| $c_{k+1}$| $a_k$| $b_k$| $c_k$| $k^2$| $w^k$| $z^k$| $k$| $1$| 
| ----:| ----:| ----:| ----:| ----:| ----:| ----:| ----:| ----:| ----:| ----:| ----:| ----:| 
| $a_{k+2}$| $p$| $1$| $1$| $q$| | | $r$| | | $t$| $1$| 
| $b_{k+2}$| $1$| $u$| $1$| | $v$| | | $1$| | | | 
| $c_{k+2}$| $1$| $1$| $x$| | | $y$| | | $1$| $1$| $2$| 
| $a_{k+1}$| $1$| | | | | | | | | | | 
| $b_{k+1}$| | $1$| | | | | | | | | | 
| $c_{k+1}$| | | $1$| | | | | | | | | 
| $(k+1)^2$| | | | | | | $1$| | | $2$| $1$| 
| $w^{k+1}$| | | | | | | | $w$| | | 
| $z^{k+1}$| | | | | | | | | $z$| | 
| $k+1$| | | | | | | | | | $1$| $1$| 
| $1$| | | | | | | | | | | $1$| 

啥都别说了，就这样矩阵转移。  
注意要用快速乘法

```cpp
//愿你有一天能和你重要的人重逢。
//大切な人といつかまた巡り会えますように
inline ll MT(ll x,ll y) {}//快速乘
struct mat
{
	ll a[15][15];
	inline void operator!() {memset(a,0,sizeof(a));}
	inline void operator~() {!*this;for(int i=1;i<=11;i++) a[i][i]=1;}
	inline mat operator*(mat b)
	{
		mat r;!r;
		for(int i=1;i<=11;i++) for(int k=1;k<=11;k++) for(int j=1;j<=11;j++) (r.a[i][j]+=MT(a[i][k],b.a[k][j]))%=P;
		return r;
	}
	inline mat operator^(ll q) {mat r,x=*this;~r;for(;q;q>>=1,x=x*x) if(q&1) r=r*x;return r;}
}mt;
int main()
{
	read(n),read(P),read(p),read(q),read(r),read(t),read(u),read(v),read(w),read(x),read(y),read(z);
	p%=P,q%=P,r%=P,t%=P,u%=P,v%=P,w%=P,x%=P,y%=P,z%=P;
	ll brush[15][15]={
		{p,1,1,q,0,0,r,0,0,t,1},
		{1,u,1,0,v,0,0,1,0,0,0},
		{1,1,x,0,0,y,0,0,1,1,2},
		{1,0,0,0,0,0,0,0,0,0,0},
		{0,1,0,0,0,0,0,0,0,0,0},
		{0,0,1,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,1,0,0,2,1},
		{0,0,0,0,0,0,0,w,0,0,0},
		{0,0,0,0,0,0,0,0,z,0,0},
		{0,0,0,0,0,0,0,0,0,1,1},
		{0,0,0,0,0,0,0,0,0,0,1}};
	ll yuan[15]={-1,3,3,3,1,1,1,1,w,z,1,1},nw[15];memset(nw,0,sizeof(nw));
	for(int i=1;i<=11;i++) for(int j=1;j<=11;j++) mt.a[i][j]=brush[i-1][j-1];
	mt=mt^(n-2);for(int i=1;i<=11;i++) for(int k=1;k<=11;k++) (nw[i]+=1ll*mt.a[i][k]*yuan[k]%P)%=P;
	return printf("nodgd %lld\nCiocio %lld\nNicole %lld\n",nw[1],nw[2],nw[3]),0;
}
```

---

## 作者：BzhH (赞：0)

一道显而易见的矩阵加速题，只需要将转移矩阵按照题目的要求构建出来就行了。

状态矩阵

$$\begin{vmatrix} a_{k+1}&b_{k+1}&c_{k+1}&a_k&b_k&c_k&k^2&k&w^k&z&k&1 
\end{vmatrix}$$

转移矩阵

$$\begin{vmatrix}p&1&1&1&0&0&0&0&0&0&0\\1&u&1&0&1&0&0&0&0&0&0\\1&1&x&0&0&1&0&0&0&0&0\\q&0&0&0&0&0&0&0&0&0&0\\0&v&0&0&0&0&0&0&0&0&0\\0&0&y&0&0&0&0&0&0&0&0\\r&0&0&0&0&0&1&0&0&0&0\\t&0&1&0&0&0&2&1&0&0&0\\0&1&0&0&0&0&0&0&w&0&0\\0&0&1&0&0&0&0&0&0&z&0\\1&0&2&0&0&0&1&1&0&0&1
\end{vmatrix}$$

然后直接套板子就可以了

代码
```
#include<iostream>
#include<cstdio>
#include<cstring>
#define lll __int128
using namespace std;
typedef long long ll;

ll n, m;
struct matrix 
{
    ll dt[12][12];
    matrix operator * (const matrix b) const
    {
        matrix c;
        memset(c.dt, 0, sizeof(c.dt));
        for (int i = 1; i <= 11; i++)
            for (int j = 1; j <= 11; j++)
                for (int k = 1; k <= 11; k++)
                    c.dt[i][j] = (c.dt[i][j] + (lll)dt[i][k] * b.dt[k][j]) % m;
        return c;
    }
} a, ito;

matrix qmi(matrix base, ll b)
{
    matrix res;
    memset(res.dt, 0, sizeof(res.dt));
    for (int i = 1; i <= 11; i++)
        res.dt[i][i] = 1;
    while (b)
    {
        if (b & 1)
            res = res * base;
        base = base * base;
        b >>= 1;
    }
    return res;
}

int main()
{
    scanf("%lld%lld", &n, &m);
    int p, q, r, t, u, v, w, x, y, z;
    scanf("%d%d%d%d%d%d%d%d%d%d", &p, &q, &r, &t, &u, &v, &w, &x, &y, &z);
    a.dt[1][1] = a.dt[1][2] = a.dt[1][3] = 3;
    a.dt[1][4] = a.dt[1][5] = a.dt[1][6] = a.dt[1][7] = a.dt[1][8] = 1;;
    a.dt[1][9] = w, a.dt[1][10] = z, a.dt[1][11] = 1;
    ito.dt[1][1] = p, ito.dt[1][2] = ito.dt[1][3] = ito.dt[1][4] = 1;
    ito.dt[2][1] = ito.dt[2][3] = ito.dt[2][5] = 1, ito.dt[2][2] = u;
    ito.dt[3][1] = ito.dt[3][2] = ito.dt[3][6] = 1, ito.dt[3][3] = x;
    ito.dt[4][1] = q, ito.dt[5][2] = v, ito.dt[6][3] = y;
    ito.dt[7][1] = r, ito.dt[7][7] = 1;
    ito.dt[8][1] = t, ito.dt[8][7] = 2, ito.dt[8][8] = ito.dt[8][3] = 1;
    ito.dt[9][2] = 1, ito.dt[9][9] = w;
    ito.dt[10][3] = 1, ito.dt[10][10] = z;
    ito.dt[11][1] = ito.dt[11][7] = ito.dt[11][8] = ito.dt[11][11] = 1, ito.dt[11][3] = 2;
    a = a * qmi(ito, n - 2);
    printf("nodgd %lld\nCiocio %lld\nNicole %lld", a.dt[1][1], a.dt[1][2], a.dt[1][3]);
    return 0;
}
```

---

## 作者：cirnovsky (赞：0)

## 题意简述

给你三个互相依赖的递推式，分别求值。

## 题解

裸的矩阵快速幂，我们把这几个东西放进矩阵：

$$
B=\begin{bmatrix}
a_{k}\\
a_{k+1}\\
b_{k}\\
b_{k+1}\\
c_{k}\\
c_{k+1}\\
k^{2}\\
k\\
w^{k}\\
2^{k}\\
1
\end{bmatrix}
$$

则初始矩阵为：

$$
S=\begin{bmatrix}
a_{1}\\
a_{2}\\
b_{1}\\
b_{2}\\
c_{1}\\
c_{2}\\
1^{2}\\
1\\
w^{1}\\
2^{1}\\
1
\end{bmatrix}
=\begin{bmatrix}
1\\
3\\
1\\
3\\
1\\
3\\
1\\
1\\
w\\
2\\
1
\end{bmatrix}
$$

转移矩阵为：

$$
A=\begin{bmatrix}
0&1&0&0&0&0&0&0&0&0&0\\
q&p&0&1&0&1&r&t&0&0&1\\
0&0&0&1&0&0&0&0&0&0&0\\
0&1&v&u&0&1&0&0&1&0&0\\
0&0&0&0&0&1&0&0&0&0&0\\
0&1&0&1&y&x&0&1&0&1&2\\
0&0&0&0&0&0&1&2&0&0&1\\
0&0&0&0&0&0&0&1&0&0&1\\
0&0&0&0&0&0&0&0&w&0&0\\
0&0&0&0&0&0&0&0&0&z&0\\
0&0&0&0&0&0&0&0&0&0&1
\end{bmatrix}
$$

则最终的答案矩阵为：

$$
T=A^{n-2}\times S
$$

答案的位置显然。

总的来说算是一道套路的矩阵加速题，可以给新手做一下。不过我草稿纸写z抄代码上去成了2也是nt行为。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

template < typename Type >
void read( Type& a )
{
	a = 0;
	char ch = getchar( );
	bool minus = 0;
	while( !isdigit( ch ) )
	{
		if( ch == '-' ) minus = 1;
		ch = getchar( );
	}
	while( isdigit( ch ) )
	{
		a = ( a << 3 ) + ( a << 1 ) + ( ch ^ '0' );
		ch = getchar( );
	}
	if( minus == 1 ) a = -a;
}

template < typename Type, typename... Args >
void read( Type& t, Args&... args )
{
	read(t), read(args...);
}

void write( __int128 x )
{
	if( x < 0 )	putchar( '-' ), x = -x;
	if( x > 9 )	write( x / 10 );
	putchar( x % 10 + '0' );
}

const __int128 Maxn = 11;
__int128 n, m, p, q, r, t, u, v, w, x, y, z;
struct Matrix
{
	__int128 mat[ Maxn ][ Maxn ];
	Matrix( __int128 x = 0 ) { memset ( mat, x, sizeof ( mat ) ); }

	Matrix operator * ( const Matrix& rhs ) const
	{
		Matrix ret;
		for( __int128 i = 0; i < Maxn; ++ i )
			for( __int128 j = 0; j < Maxn; ++ j )
				for( __int128 k = 0; k < Maxn; ++ k )
					ret.mat[ i ][ j ] = ( ret.mat[ i ][ j ] + 1ll * mat[ i ][ k ] * rhs.mat[ k ][ j ] ) % m;
		return ret;
	}
} unit, meta;

void Make_Unit( )
{
	for ( __int128 i = 0; i < Maxn; ++ i )
		unit.mat[ i ][ i ] = 1;
}

void Make_Meta( )
{
	__int128 cpy[ Maxn ][ Maxn ] = 
	{
		{ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
		{ q, p, 0, 1, 0, 1, r, t, 0, 0, 1 },
		{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
		{ 0, 1, v, u, 0, 1, 0, 0, 1, 0, 0 },
		{ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
		{ 0, 1, 0, 1, y, x, 0, 1, 0, 1, 2 },
		{ 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 1 },
		{ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1 },
		{ 0, 0, 0, 0, 0, 0, 0, 0, w, 0, 0 },
		{ 0, 0, 0, 0, 0, 0, 0, 0, 0, z, 0 },
		{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }
	};
	memcpy( meta.mat, cpy, sizeof( cpy ) );
}

signed main( )
{
	read( n, m, p, q, r, t, u, v, w, x, y, z );
	Make_Unit( ), Make_Meta( );

	__int128 tS[ Maxn ][ Maxn ] = 
	{
		{ 1 }, { 3 }, { 1 }, { 3 }, { 1 }, { 3 }, { 1 }, { 1 }, { w }, { z }, { 1 }
	};
	Matrix S;
	memcpy( S.mat, tS, sizeof( tS ) );

	__int128 k = n - 2;
	Matrix ret = unit, base = meta;
	for( ; k; k >>= 1, base = base * base )
		if( k & 1 )	ret = ret * base;
	ret = ret * S;
	printf( "nodgd " ), write( ret.mat[ 1 ][ 0 ] ), putchar( '\n' );
	printf( "Ciocio " ), write( ret.mat[ 3 ][ 0 ] ), putchar( '\n' );
	printf( "Nicole " ), write( ret.mat[ 5 ][ 0 ] ), putchar( '\n' );
	return 0;
}
```

---

## 作者：Jμdge (赞：0)

来一发各种骚但仍较为清晰的代码...

这道题反正就是构造矩阵嘛，然后就是一遍回忆构造矩阵的套路一遍 A 掉此题就好了

然后这道题用的表达式中变量是非常的多，所以大家构造出来的矩阵会有着一些差异...（比如有的人把 a[k] a[k+1] 放一起，有人把 a[k] b[k] c[k] 放一起）

所以抄题解就超级麻烦，像我这种矩阵构造到一半出锅了看题解的表示难受...

然后我用了题解里构造的矩阵，除此之外都是板子...（具体一点的解释就放代码里了）


```
//by Judge
#include<cmath>
#include<cstdio>
#include<iostream>
#define ld long double
#define ll long long
using namespace std;
const int M=1e5+7;
ll n,mod,p,q,r,t,u,v,w,x,y,z;
inline void ADD(ll& a,ll b){ //快速加，我不知道说些什么...
	a+=a+b>=mod?b-mod:b;
}
inline ll mul(ll a,ll b){ a%=mod,b%=mod; //这里是正宗快速乘（以后别打龟速乘啦！）
	return (ll)(a*b-(ll)(((ld)a*b+0.5)/mod)*mod)%mod;
}
struct Matrix{ ll a[13][13];  //这个板子还是不错的...
	ll* operator [](int pos){ return a[pos]; } //这里就是重载了'[]'这个符号，下面写起来就方便很多了（最主要是代码清晰了有木有）
	Matrix operator *(Matrix& b){ static Matrix c;
		for(int i=1;i<=11;++i)
			for(int j=1;j<=11;++j) c[i][j]=0;
		for(int i=1;i<=11;++i) for(int k=1;k<=11;++k)
			for(int j=1;j<=11;++j) ADD(c[i][j],mul(a[i][k],b[k][j]));
		return c;
	}
}A,f[65];
inline ll qpow(ll x,ll p){ ll s=1;
	for(;p;p>>=1,x=mul(x,x))
		if(p&1) s=mul(s,x); return s;
}
int main(){
	scanf("%lld%lld%lld%lld%lld%lld",&n,&mod,&p,&q,&r,&t);
	scanf("%lld%lld%lld%lld%lld%lld",&u,&v,&w,&x,&y,&z);
    /*   这里构造矩阵  */
	f[0][1][1]=p,f[0][2][1]=q,f[0][3][3]=u,f[0][4][3]=v,
	f[0][5][5]=x,f[0][6][5]=y,f[0][7][1]=r,f[0][8][1]=t,
	f[0][10][10]=w,f[0][11][11]=z,f[0][8][7]=2,f[0][9][5]=2;
	f[0][1][2]=f[0][1][3]=f[0][1][5]=f[0][3][1]=f[0][3][4]=1;
	f[0][3][5]=f[0][5][1]=f[0][5][3]=f[0][5][6]=f[0][7][7]=1;
	f[0][8][5]=f[0][8][8]=f[0][9][1]=f[0][9][7]=f[0][9][8]=1;
	f[0][9][9]=f[0][10][3]=f[0][11][5]=1,
	
    /*      这里初始化答案矩阵        */
	A[1][2]=A[1][4]=A[1][6]=A[1][7]=A[1][8]=A[1][9]=1,
	A[1][1]=A[1][3]=A[1][5]=3;
	A[1][10]=w,A[1][11]=z,--n;
	
    
    /*    然后是矩阵加速 + 查询？      */
	for(int i=1;n>>i;++i) f[i]=f[i-1]*f[i-1];
	for(int i=0;n>>i;++i) if(n>>i&1) A=A*f[i];
	
	printf("nodgd %lld\n",A[1][2]);
	printf("Ciocio %lld\n",A[1][4]);
	printf("Nicole %lld\n",A[1][6]);
	return 0;
}
```




---

## 作者：汪锦程 (赞：0)

和前面说的相似，1\*11的一个矩阵递推。

a(k) b(k) c(k) a(k+1) b(k+1) c(k+1) k k^2 w^k z^k 1

转移矩阵在下面.

或许代码看着舒服些吧。

```cpp
    #include<iostream>
    #include<cstdio>
    #include<cstring>
    using namespace std;
    typedef long long ll;
    ll n,MOD;
    ll mul(ll h,ll g){
        ll sum=0;
        while(g){
            if(g&1)
                sum=(sum+h)%MOD;
            g>>=1;
            h=(h+h)%MOD;
        }
        return sum;
    }
    struct mat{
        ll a[11][11];
        int l,c;
        mat operator*(const mat A)const{
            mat ret;
            ret.l=l,ret.c=A.c;
            memset(ret.a,0,sizeof(ret.a));
            for(int i=0;i<l;i++)
                for(int j=0;j<A.c;j++)
                    for(int k=0;k<c;k++)
                        ret.a[i][j]=(ret.a[i][j]+mul(a[i][k],A.a[k][j]))%MOD;
            return ret;
        }
    }ans,m;
    int p,q,r,t,u,v,w,x,y,z;
    int main(){
        scanf("%lld%lld",&n,&MOD);
        scanf("%d%d%d%d%d%d%d%d%d%d",&p,&q,&r,&t,&u,&v,&w,&x,&y,&z);
        ans.l=1,ans.c=11;
        ll a1[11]={1,1,1,3,3,3,1,1,w,z,1};
        for(int i=0;i<11;i++)
            ans.a[0][i]=a1[i];
        m.l=11,m.c=11;
        ll a2[11][11]={
        {0,0,0,q,0,0,0,0,0,0,0},
        {0,0,0,0,v,0,0,0,0,0,0},
        {0,0,0,0,0,y,0,0,0,0,0},
        {1,0,0,p,1,1,0,0,0,0,0},
        {0,1,0,1,u,1,0,0,0,0,0},
        {0,0,1,1,1,x,0,0,0,0,0},
        {0,0,0,t,0,1,1,2,0,0,0},
        {0,0,0,r,0,0,0,1,0,0,0},
        {0,0,0,0,1,0,0,0,w,0,0},
        {0,0,0,0,0,1,0,0,0,z,0},
        {0,0,0,1,0,2,1,1,0,0,1},
        };
        for(int i=0;i<11;i++)
            for(int j=0;j<11;j++)
                m.a[i][j]=a2[i][j];
        n-=2;
        while(n){
            if(n&1)
                ans=ans*m;
            n>>=1;
            m=m*m;
        }
        printf("nodgd %lld\nCiocio %lld\nNicole %lld\n",ans.a[0][3],ans.a[0][4],ans.a[0][5]);
        return 0;
    }

```

---


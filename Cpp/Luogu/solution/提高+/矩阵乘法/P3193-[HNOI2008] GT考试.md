# [HNOI2008] GT考试

## 题目描述

阿申准备报名参加 GT 考试，准考证号为 $N$ 位数$X_1,X_2…X_n\ (0\le X_i\le 9)$，他不希望准考证号上出现不吉利的数字。
他的不吉利数字$A_1,A_2,\cdots, A_m\ (0\le A_i\le 9)$ 有 $M$ 位，不出现是指 $X_1,X_2\cdots X_n$ 中没有一段恰好等于 $A_1,A_2,\cdots ,A_m$，$A_1$ 和 $X_1$ 可以为 $0$。

## 说明/提示

### 数据范围及约定

对于全部数据，$N\leq10^9$，$M\leq 20$，$K\leq10000$。

## 样例 #1

### 输入

```
4 3 100
111```

### 输出

```
81```

# 题解

## 作者：Edgration (赞：143)

题解有点长请耐心观看...
## 题意
求有多少个$n$位的数字串不包含$m$位的字符串
（范围 $n <= 1e9 $， $m <= 20$）
## 分析
网上的题解我都看不懂啊QAQ(太弱了)，那么我就写详细一点吧...
### 0x01 暴力
第一眼看到就是不会...
不会怎么办..先把暴力打了...
暴力枚举字符串，然后$Hash$比较
复杂度$O(10^n\cdot n)$，实测只能过$n<=7$的点
然后得到$10$分

![](https://ws2.sinaimg.cn/large/006tKfTcly1fqa913k95mj30no0gjgmr.jpg)

### 0x02 DP
妈妈我会$DP$ !
根据套路，因为$m$并不会很大，设$f[i][j]$表示长串匹配到第$i$位，短串最多可以匹配到第$j$位的方案数
![](https://ws4.sinaimg.cn/large/006tKfTcly1fqa7y12r2vj30ft079gm0.jpg)
那么为了让它不能找到完全的匹配，答案就是
$$\sum_{i=0}^{m-1}f[n][i]$$
那么怎么转移？
考虑对于已经匹配了的$f[i][j]$转移到$f[i + 1][k]$新加一个新的字符造成的影响。
![](https://ws2.sinaimg.cn/large/006tKfTcly1fqa82b67ssj30ev05wq3f.jpg)
由于这个$new$是可以随便填写的，对于短串的$j+1$，可能会有几种情况。
1. new和$t+1$匹配，转移到$f[i+1][j+1]$
2. 不匹配

![](https://ws4.sinaimg.cn/large/006tKfTcly1fqa873h653j30f7081wfj.jpg)

如图，这样可能会找到一个新的长度为$k$的前缀使得和当前枚举到的后缀匹配

![](https://ws2.sinaimg.cn/large/006tKfTcly1fqa89i1k3aj30fv08gjs9.jpg)

甚至$k=0$无法匹配

其实，这个东西和枚举的字母无关，考虑到最后的答案，在$DP$过程中只需要考虑长度对答案造成的影响。

对于这一点，我们就是要知道，对于一个匹配到长度为$j$的串，转移到$k$的串的方案，也就对于长度为$i$的串，加一个数子，能加入多少种数字，使得长度为$j$的匹配变成长度为$k$的匹配（如图）。

$DP$式就可以写出来啦
$$f[i][j]=\sum_{k=0}^{m-1} f[i-1][k]*g[k][j]$$

$DP$套$DP$？

其实没那么麻烦，对于第二个的方案数，因为我们知道短串，这个“$g[i][j]$”是固定的，就可以预处理出结果。

![](https://ws2.sinaimg.cn/large/006tKfTcly1fqa8lwb5xyj309307p74l.jpg)
为了计算长度为$j$的已经匹配好了的串可以用多少种数字变为$k$，枚举一个数字，看它在短串中最长可以匹配到最多多长的前缀。

妈妈我会$Kmp$！

然后为了保证是最长的而且前面的东西保留，暴力枚举的复杂度好像有点爆炸，这个时候一看不就是一个裸$Kmp$吗，对于新的数字，失去匹配就跳$next$。

![](https://ws2.sinaimg.cn/large/006tKfTcly1fqa8rri4eej309p09bdgp.jpg)

于是就得到了一个$O(n*m^2)$的优秀算法....
大概可以做$n<=250000$的数据，然后得到$40$分

![](https://ws2.sinaimg.cn/large/006tKfTcly1fqa91ilorsj30np0f6my9.jpg)

### 0x03 矩阵快速幂
然后看一看$DP$式
$$f[i][j]=\sum_{k=0}^{m-1} f[i-1][k]*g[k][j]$$
这不就是一个矩阵乘法的式子吗...
因为$g[i][j]$是固定的，于是把$f[i][j]$看成一个矩阵，对于矩阵$F[i]$它的第一层就是$f[i][j]$。
$$F[i]=F[i-1]*G$$
$G$是固定的，你又知道$F[0]$的第一行第一列是$1$，然后求一个$F[n]$就行了...
矩阵快速幂即可....

### 0x04 代码
暴力
```
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    char ch = getchar(); int u = 0, f = 1;
    while (!isdigit(ch)) { u = (u << 1) + (u << 3) + ch - 48; ch = getchar(); }
    while (isdigit(ch)) { u = (u << 1) + (u << 3) + ch - 48; ch = getchar(); }
    return u * f;
}
const int maxn = 1e5 + 10;
int n, m, k;
int ans = 0;
typedef unsigned long long ull;
ull ha_m; 
ull mod = 19260817;
ull base = 266;
ull ha[maxn], pw[maxn];
int s[maxn];
char md[maxn];
inline void build(){
    ha[0] = 0;
    for (int i = 1; i <= n; ++i)
        ha[i] = (ha[i - 1] * base + s[i]) % mod;
}
inline ull split(int l, int r){
    return ((ha[r] - (ha[l - 1] * pw[r - l + 1]) % mod) + mod) % mod;
}
inline void dfs(int x){
    if (x == n + 1){
        build();
        for (int i = 1; i + m - 1 <= n; ++i){
            if (split(i, i + m - 1) == ha_m) return; 
        }
        ans++; 
        return;
    }
    for (int i = 0; i <= 9; ++i){
        s[x] = i;
        dfs(x + 1);
    }
}
int main(){
//	freopen("data.txt", "r", stdin);
    n = read(), m = read(), k = read();
    if (n >= 10) return 0 * puts("NO");
    scanf("%s", md + 1);
    pw[1] = base;
    for (int i = 2; i <= n; ++i) pw[i] = (pw[i - 1] * base) % mod;
    for (int i = 1; i <= m; ++i) ha_m = (ha_m * base + (md[i] - '0')) % mod;
    dfs(1);
    printf("%d", ans % k);
    return 0;
}
```
40分DP
```
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    char ch = getchar(); int u = 0, f = 1;
    while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
    while (isdigit(ch)) { u = (u << 1) + (u << 3) + ch - 48; ch = getchar(); }
    return u * f;
}
const int maxn = 1e6+10;
int f[maxn][30], n, m, k;
int nxt[50], match[50][50];
char md[50];

inline void Inittt(){
    n = read(), m = read(), k = read();
    scanf("%s", md + 1);
}
inline void Kmp(){ 
    nxt[0] = -1;
    for (int i = 1; i <= m; ++i){
        int j = nxt[i - 1];
        while (j != -1 && md[j + 1] != md[i]) j = nxt[j];
        nxt[i] = j + 1;
    }
    nxt[0] = 0;
    for (int i = 0; i < m; ++i){
        for (int j = '0'; j <= '9'; ++j){
            int temp = i;
            while (md[temp + 1] != j && temp > 0) temp = nxt[temp];
            if (md[temp + 1] == j) temp++;
            if (temp < m) match[i][temp]++;
        }	
    }
}
int main(){
    Inittt();
    Kmp();
    f[0][0] = 1;
    for (int i = 1; i <= n; ++i)
        for (int j = 0; j < m; ++j)
            for (int p = 0; p < m; ++p)
                { (f[i][j] += f[i - 1][p] * match[p][j]) %= k; }
    int ans = 0;
    for (int i = 0; i < m; ++i) (ans += f[n][i]) %= k;
    printf("%d", ans);
    return 0;
}
```
100分代码（人傻大常数大
```
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    char ch = getchar(); int u = 0, f = 1;
    while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
    while (isdigit(ch)) { u = (u << 1) + (u << 3) + ch - 48; ch = getchar(); }
    return u * f;
}
const int maxn = 5050;
int f[maxn][30], n, m, k;
int nxt[maxn], match[maxn][50];
char md[maxn];
inline void Kmp(){ 
    nxt[0] = -1;
    for (int i = 1; i <= m; ++i){
        int j = nxt[i - 1];
        while (j != -1 && md[j + 1] != md[i]) j = nxt[j];
        nxt[i] = j + 1;
    }
    nxt[0] = 0;
    for (int i = 0; i < m; ++i){
        for (int j = '0'; j <= '9'; ++j){
            int temp = i;
            while (md[temp + 1] != j && temp > 0) temp = nxt[temp];
            if (md[temp + 1] == j) temp++;
            if (temp < m) match[i][temp]++;
        }	
    }
}
class MARTIX{
public:
    int mr[23][23];
    MARTIX(){ memset(mr, 0, sizeof(m)); }	
    void pr(){ for (int i = 0; i <= m; i++, cerr << endl) for (int j = 0; j <= m; ++j) cerr << mr[i][j] << " "; }
    MARTIX operator * (MARTIX B){
        MARTIX Rtn;
        memset(Rtn.mr, 0, sizeof(Rtn.mr));
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < m; ++j)
                for (int p = 0; p < m; ++p)
                    { (Rtn.mr[i][j] += mr[i][p] * B.mr[p][j]) %= k; }
        return Rtn;
    }
}F, G;

inline MARTIX ksm(MARTIX A, int pw){
    MARTIX Rtn;
    for (int i = 0; i <= m; ++i)
        Rtn.mr[i][i] = 1;
    for (; pw; pw >>= 1, A = A * A)
        if (pw & 1) Rtn = Rtn * A;
    return Rtn;
}
signed main(){
    
    n = read(), m = read(), k = read(); scanf("%s", md + 1);
    
    Kmp();

    F.mr[0][0] = 1;
    for (int i = 0; i <= m; ++i)
        for (int j = 0; j <= m; ++j)
            G.mr[i][j] = match[i][j];
    G = ksm(G, n); 
    F = F * G;
    int ans = 0;
    
    for (int i = 0; i < m; ++i) { (ans += F.mr[0][i]) %= k; }
    printf("%d", ans);
    return 0;
}
```


---

## 作者：Siyuan (赞：60)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io/articles/problem-HNOI-2008-GT-Exam/)

---

## Description

> 题目链接：[Luogu 3193](https://www.luogu.org/problemnew/show/P3193)

阿申准备报名参加 GT 考试，准考证号为 $n$ 位数 $X_1,X_2,\dots,X_n$，他不望准考证号上出现不吉利的数字。他的不吉利数学 $A_1,A_2,\dots,A_m$ 有 $m$ 位，不出现是指 $X_1,X_2,\dots,X_n$ 中没有恰好一段等于 $A_1,A_2,\dots,A_m$。注意 $A_1$ 和 $X_1$ 可以为 $0$。

数据范围：$1\le n\le 10^9$，$1\le m\le 20$，$1\le k\le 1000$，$0\le X_i,A_i\le 9$

------

## Solution

我们定义 $\text{DP}$ 状态 $f_{i,j}$ 表示考虑到第 $i$ 个数，匹配到了 $X$ 中的第 $j$ 个字符时的方案数。显然 $i,j$ 的范围是 $0\le i\le n$，$0\le j<m$。

转移方程为：
$$f_{i,j}=\sum_{k=0}^{9} f_{i-1,p}$$
其中的 $p$ 不一定是 $0$ 或者 $j-1$，因为加入字符 $k$ 后，有如下三种情况：

1. 匹配到了 $X$ 中的下一个字符。
2. 失配，无法匹配任何字符。
3. 重新匹配到了 $X$ 的一个前缀。

这个式子看似无法优化了，我们换一种方式写出转移方程：
$$f_{i,j}=\sum_{k=0}^{m-1} f_{i-1,k}\times g_{k,j}$$
其中的 $g_{k,j}$ 表示一个匹配了长度为 $k$ 长度的串，有多少种加数字的方法，使得匹配长度变成 $j$。

由于我们知道原串，那么 $g_{i,j}$ 是固定的，我们可以预处理出这个数组。我们可以使用 $\text{KMP}$ 算法，求出 $\text{next}$ 数组后，枚举匹配长度 $k$ 和字符 $ch$，暴力计算能匹配到多长的前缀。

这样一来，我们得到了一个 $O(nm^2)$ 的算法。

再次观察这个 $\text{DP}$ 式子，可以轻松发现这个式子和**矩阵乘法**的式子非常相似，那么我们用矩阵快速幂优化 $\text{DP}$ 转移即可，求出 $g$ 矩阵的 $n$ 次幂。

**时间复杂度**：$O(m^3\log n)$

------

## Code

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

const int N=21;
int n,m,mod,nxt[N];
char s[N];

void upd(int &x,int y) {
	(x+=y)>=mod&&(x-=mod);
}
struct Matrix {
	int n,A[N][N];
	Matrix(int _n=0) {n=_n,memset(A,0,sizeof(A));}
	void operator ~ () {
		for(int i=0;i<n;++i) A[i][i]=1;
	}
	Matrix operator * (const Matrix &b) const {
		Matrix ret(n);
		for(int i=0;i<n;++i) for(int j=0;j<n;++j) for(int k=0;k<n;++k) {
			upd(ret.A[i][k],1LL*A[i][j]*b.A[j][k]%mod);
		}
		return ret;
	}
	Matrix operator ^ (const long long &b) const {
		Matrix ret(n),x=*this; ~ret;
		for(long long p=b;p;p>>=1,x=x*x) if(p&1) ret=ret*x;
		return ret;
	}
};

Matrix kmp() {
	nxt[1]=0;
	for(int i=2,j=0;i<=m;++i) {
		while(j&&s[j+1]!=s[i]) j=nxt[j];
		if(s[j+1]==s[i]) ++j;
		nxt[i]=j;
	}
	Matrix a(m);
	for(int i=0;i<m;++i) {
		for(char ch='0';ch<='9';++ch) {
			int j=i;
			while(j&&s[j+1]!=ch) j=nxt[j];
			if(s[j+1]==ch) ++j;
			++a.A[i][j];
		}
	}
	return a;
}
int main() {
	scanf("%d%d%d%s",&n,&m,&mod,s+1);
	Matrix a=kmp();
	a=a^n;
	int ans=0;
	for(int i=0;i<m;++i) upd(ans,a.A[0][i]);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：HH_Halo (赞：22)

 _~~本萌新洛谷第一篇题解~~_ 
 
 看了很多题解，发现有很多细节直接忽略了，所以我将各位大佬的思路整合了以下
## 题外话
本来就是想好好想练一下$KMP$，根据你谷标签找到了这道题，看题面那么简短，以为并不是很难（虽然是紫的），结果做着做着就傻了
这题很综合，$DP$+矩阵快速幂+$KMP$，我原地螺旋升天sto orz
### 状态转移：
* 设$dp[i][j]$表示长度为$i$的字符串，最后$j$个可以匹配模式串前$j$位的情况数，答案就是$\sum_{i=0}^{m-1}dp[n][i]$
* However,理论是有了，如何实现？
* 关键在于对模式串的不同匹配情况，用一个$g[k][j]$对于一个匹配到长度为 $j$的串，转移到 $k$ 的串的方案
* 此时转移方程$dp[i][j] = \sum_{k=0}^{m-1}dp[i-1][k]*g[k][j]$，你看，你看，你仔细看，这个式子像什么？矩阵乘啊！（本蒟蒻永远推不出来系列）
* 因为我们最后只需要$n$这一行矩阵，所以我们把每一行$dp[i][j]$抽象成**只有一行**，**列数为**$m-1$的$F[i]$,最后就变成了$F[i] = F[i-1]*G$,推出$F[n] = F[0]*G^{n}$,这时候就可以跑矩阵快速幂了（这里很多题解一带而过，需要对矩阵乘法理解透彻）

~~等会儿，我不是来练$KMP$的吗？？？~~
## Code
```c++
#include<bits/stdc++.h>
#define N 25
using namespace std;
inline int read(){
	int x = 0,f =  1;
	char ch = getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
int n,m,mod,kmp[N];
char s[N];
struct xzy{//定义矩阵
	int a[N][N];
	xzy(){memset(a,0,sizeof(a));}
}G,F;
xzy operator *(xzy a,xzy b){//矩阵乘法
	xzy ans;
	for(int i = 0;i < m;i++){
		for(int j = 0;j < m;j++){
			for(int k = 0;k < m;k++){
				ans.a[i][j] = (ans.a[i][j]+a.a[i][k]*b.a[k][j]%mod)%mod;
			}
		}
	}
	return ans;
}
xzy quickpow(xzy g,int t){//矩阵快速幂
	xzy ans;
	for(int i = 0;i < m;i++)ans.a[i][i] = 1;
	while(t){
		if(t&1)ans = ans*g;
		g = g*g;
		t >>= 1;
	}
	return ans;
}
int main(){
	n=read();m=read();mod=read();
	scanf("%s",s+1);
	int j=0;
	for(int i=2;i<=m;++i) {//kmp求匹配情况
		while(j && s[j+1]!=s[i]) j=kmp[j];
		if(s[j+1]==s[i]) j++;
		kmp[i]=j;
	}
	
	for(int i=0;i<m;++i) {//算出所有未完全匹配的个数（这好像才是我的本意……）
		for(char ch='0';ch<='9';++ch) {//枚举所有位数
			int j=i;
			while(j && s[j+1]!=ch) j=kmp[j];//失配回跳
			if(s[j+1]==ch) j++;//该情况成立
			G.a[i][j]=(G.a[i][j]+1)%mod;//加上一种情况
		}
	}
	F.a[0][0]=1;//F是一行m列的
	G=quickpow(G,n);
	F=F*G;
	int ans=0;
	for(int i=0;i<m;++i) ans=(ans+F.a[0][i])%mod;
	printf("%d",ans);
	return 0;
}
```

---

## 作者：巨型方块 (赞：17)

一开始感觉这道题目很难啊什么的；

然后身边的同学们慢慢都ac了；

才发现这道题并不是怎么的难；

我们搞一个f[i][j]表示现在已经有i个数字了，而且最后j个数字是不幸数字的一部分；

注意对于同一个状态j要竟可能大；

比如
1212是不幸数字

那么551212是f[6][4];

这样的话我们可以发现f[0][0]=1;

ans=f[n][k] (k=0~m-1)

这样的话我们可以从f[0][0]地推；

每局这个状态最后放一个什么数字，然后kmp求j

a[j][k]表示j个不幸之后放k产生的新的j

```cpp
f[i+1][a[j][k]]=(f[i+1][a[j][k]]+f[i][j])%mo;
```

```cpp
#include<bits/stdc++.h>
#define Ll long long
using namespace std;
const int N=25,M=1e5+5;
int n,m,mo,ans;
char c[N];
int f[M][N],p[N],a[N][10];
void make(){
    p[0]=-1;
    int j=-1;
    for(int i=1;i<=m;p[i++]=++j)
        while(j!=-1&&c[i]!=c[j+1])j=p[j];
}
int find(int j,int k){
    while(j!=-1&&c[j+1]!=char(k+48))j=p[j];
    return j+1;
}
int main()
{
    scanf("%d%d%d",&n,&m,&mo);
    scanf("%s",c+1);
    make();
    for(int j=0;j<=m-1;j++)
        for(int i=0;i<=9;i++)a[j][i]=find(j,i);
    f[0][0]=1;
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            for(int k=0;k<=9;k++)
                f[i+1][a[j][k]]=(f[i+1][a[j][k]]+f[i][j])%mo;
    for(int i=0;i<m;i++)ans+=f[n][i];
    printf("%d",ans%mo);
}
```

然后用矩阵优化就好了；

完全的代码可以看我博客：

http://blog.csdn.net/largecub233/article/details/74327768


---

## 作者：hanmo0321 (赞：13)

# 洛谷P3193[HNOI2008]GT考试
传送门:[https://www.luogu.org/fe/problem/P3193](https://www.luogu.org/fe/problem/P3193)

先说一件大事:~~我背叛了P党~~我转c++啦!

思路:

看到这道题,首先想暴搜.暴搜的话枚举每一位,时间复杂度O(10^n),不炸飞才怪.

那么,暴搜慢在哪里?就是因为一个一个加.一坨一坨加不就快了吗?

如何一坨一坨加?考虑分类讨论,将当前的数串分为以下几种情况:

(1):该串后缀与不吉利串前缀最多能匹配0位

(2):该串后缀与不吉利串前缀最多能匹配1位

(3):该串后缀与不吉利串前缀最多能匹配2位

(4):该串后缀与不吉利串前缀最多能匹配3位

......

(m):该串后缀与不吉利串前缀最多能匹配m-1位

拿样例来说,就是:

(1):该串后缀与111前缀最多能匹配0位(X...XXX)

(2):该串后缀与111前缀最多能匹配1位(X...XX1)

(3):该串后缀与111前缀最多能匹配2位(X...X11)

三位是不可能的

想到状态:f[i][j]表示前i位,该串后缀与不吉利串前缀最多匹配j位的方案数

那么f[i][0]会加到哪里去?

一个匹配0位的串再加一位,有两种情况:

(1)加1 由XXX变成XX1,f[i+1][1]+=f[i][0]

(2)不加1 由XXX变成XXX,f[i+1][0]+=f[i][0]*9

按同样的方法,可以推出状态转移方程:

f[i+1][0]=f[i][0]*9+f[i][1]*9+f[i][2]*9

f[i+1][1]=f[i][0]

f[i+1][2]=f[i][1]

但这只是不吉利串为111时的状态转移方程,换一下又得重推o(TヘTo)

那怎么办?只能**让电脑来推状态转移方程**!

什么?还有这种操作?别急,且听我慢慢道来

设a[i][j]表示f[x][i]转移到f[x+1][j]有几种可能

想想,刚刚人工想状态转移方程是怎么搞的?

对呀!**枚举最后一步(位)**!

枚举最后一位(第x+1位)是什么

枚举完了以后再枚举k,k表示当前串的最后k位和不吉利串的前k位比较

枚举完k再写一个check函数,判断当前串的最后k位和不吉利串的前k位相不相等即可

好了!思路整理完了,就来看看CODE吧:
```cpp
//s为不吉利串
a[0][0]=9;a[0][1]=1;//初始化
for(int i=1;i<m;i++){
    for(int j=0;j<i;j++) tmp[j]=s[j];//有j位已经匹配好了
    for(int j=0;j<=9;j++){
        tmp[i]=j+48;//数字转字符
        int k;//注意要外面定义
        for(k=i+1;k>=1;k--)
            if(check(tmp+(i-k+1),s,k)) break;
        a[i][k]++;//找到最大的k后a[i][k]++
    }
}
```
还有check函数~~~
```cpp
bool check(char s1[],char s2[],int k){
    for(int i=0;i<k;i++) if(s1[i]!=s2[i]) return 0;
    return 1;
}

```
好啦!那还有一大难题:n最大是10^9......

怎么办呢?别怂!先把状态转移方程写出来:

f[i][j]=Σ(0<=k<m)f[i-1][k]*a[k][j]

等等,好像有点像......

再确认一下,上矩阵乘法的式子:

c[i][j]=Σ(0<=k<m)a[i][k]*b[k][j]

那上面一个式子不就是f[i-1]*a=f[i]嘛!

那么f[n]=f[0]*a^n

所以套用矩阵快速幂求出a^n,矩阵乘法求f[n],最后输出f[0~m-1]的和即可

(也可以输出a^n第0行的和)

上代码(心累啊):
```cpp
#include<bits/stdc++.h>
using namespace std;
struct matrix{
    int a[25][25],n,m;
}x;
int n,m,mod,ans,a[25][25];
char tmp[25],s[25];
bool check(char s1[],char s2[],int k){
    for(int i=0;i<k;i++) if(s1[i]!=s2[i]) return 0;
    return 1;
}
matrix mul(matrix a,matrix b){
    matrix c;
    c.n=a.n,c.m=b.m;
    for(int i=0;i<c.n;i++)
        for(int j=0;j<c.m;j++){
            c.a[i][j]=0;
            for(int k=0;k<a.m;k++) c.a[i][j]=(c.a[i][j]+a.a[i][k]*b.a[k][j]%mod)%mod;
        }
    return c;
}
matrix q_pow(matrix a,int b){
    matrix q;
    q.n=m,q.m=m; 
    for(int i=0;i<q.n;i++)
        for(int j=0;j<q.m;j++) q.a[i][j]=(i==j);
    while(b>0){
        if(b&1) q=mul(q,a);
        a=mul(a,a);
        b>>=1;
    }
    return q;
}
int main(){
    scanf("%d%d%d",&n,&m,&mod);
    scanf("%s",s);
    a[0][0]=9;a[0][1]=1;
    for(int i=1;i<m;i++){
        for(int j=0;j<i;j++) tmp[j]=s[j];
        for(int j=0;j<=9;j++){
            tmp[i]=j+48;
            int k;
            for(k=i+1;k>=1;k--)
                if(check(tmp+(i-k+1),s,k)) break;
            a[i][k]++;
        }
    }
    for(int i=0;i<m;i++)
        for(int j=0;j<m;j++) x.a[i][j]=a[i][j];
    x.n=x.m=m;
    x=q_pow(x,n);
    for(int i=0;i<m;i++) ans=(ans+x.a[0][i])%mod;
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：斯茂 (赞：12)

实话说这里的题解我一个都看不懂，我太弱了......

希望我的这一篇能够造福更多像我一样的新手。

先来说一下辅助数组G

G[i][j]表示A串的前i位，增加一个字符后的后缀能与A串的前j位匹配的方法数。

举个例子，若A = 129919

G[5][2]就是1，因为在12991后加上一个2的129912的后缀12于12991的前缀12，并且可以知道这是唯一一种方法。

G的生成......由于m只有20，所以直接暴力就行了，如果m是100可以用KMP算法。

d[i][j]表示长度为i位的串，末尾j位和A串的前j位匹配的方法数。

d[i][j] = d[i-1][0] 乘 G[0][j] + d[i-1][1] 乘 G[1][j] + ... + d[i-1][j] 乘 G[j][j]

下面是重点！！！！！

这里也是我看不懂其他题解的一点。

答案中写的是d[n][0]+d[n][1]+...+d[n][m-1]

但是要注意，最后m位不匹配不代表前面不匹配

似乎我们的G出现了一点问题

因为只要在某一位匹配到了m位，之后不论是怎么样的，这都是一个不吉利的串。

所以，令G[m][m] = 10（只有0-9十个字符）, 而其他的G[m][j] 都为0.

最后，此题的DP需要矩阵乘法。

由于我不喜欢数组零下标，我就把0->m改成了1->m+1。

其实这道题代码并不难写，难的地方是对题的理解。

代码细节请看我的代码。
```
#include <iostream>
#include <string>
using namespace std;
int n, m, K;
string x;
struct matrix
{
  int n, m;
  int s[22][22];
}p, q, r, null;
int d[22][22];
matrix matmul(matrix a, matrix b)
{
  int i, j, k;
  int n, m, p;
  matrix ans = null;
  n = ans.n = a.n;
  m = a.m;
  p = ans.m = b.m;
  for(i = 1; i <= n; i++)
    for(j = 1; j <= p; j++)
      for(k = 1; k <= m; k++)
        ans.s[i][j] = (ans.s[i][j] + a.s[i][k] * b.s[k][j]) % K;
  return ans;
}
int main()
{
    int i, j, k, t, ans = 0;
	cin >> n >> m >> K >> x;
    x = " " + x;
    for(i = 0; i < m/*注意！！！！！*/; i++)
      for(j = 0; j <= 9; j++)
        for(k = i + 1; k >= 0; k--)
          if(k == 0 || x.substr(i - k + 2, k - 1) + (char)(j + '0') == x.substr(1, k))
          {
            d[i][k]++;//d[i][j]是匹配i位加一个字符匹配j位的方法数 
            break;
		  }
	d[m][m] = 10;//已经到了m位就不能回去了 
    r.n = r.m = m + 1;
    for(i = 1; i <= m + 1; i++)
      r.s[i][i] = 1;
    p.n = p.m = m + 1;
    for(i = 1; i <= m + 1; i++)
      for(j = 1; j <= m + 1; j++)
        p.s[i][j] = d[j - 1][i - 1];//反过来 
    q.n = m + 1;
    q.m = 1;
    q.s[1][1] = 1;
    t = n;
    while(t)
    {
      if(t & 1) r = matmul(r, p);
      p = matmul(p, p);
      t /= 2;
	}
	q = matmul(r, q);
	for(i = 1; i <= m; i++)
	  ans = (ans + q.s[i][1]) % K;
	cout << ans << endl;
	return 0;
}
```
求过，谢谢！！！

---

## 作者：精神小火 (赞：12)

我的思路跟各位大佬有点不一样，我是先求出来**出现不吉利号码**有多少种情况，再用$10^n$减去他得出答案。

思路跟普通的做法差不多。把矩阵拓展一维，也就是$m+1$维。前$m$维是一模一样的，最后一维记录**已经出现过不吉利号码的数量**。

初始矩阵就是1,0,0,0... 转移矩阵的$(m+1,m+1)$位置是10。需要注意$m+1$列的前$m$位不一定是0。

以样例为例 转移矩阵
$$
 \left[
 \begin{matrix}
   9 &1 &0 &0\\ 
9&0& 1 &0 \\
9 &0 &0 &1 \\
0 &0& 0 &10 
  \end{matrix}
  \right] $$
初始矩阵
$$
 \left[
 \begin{matrix}

1 &0& 0 &0 
  \end{matrix}
  \right] $$
代码：  
``` cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
#define forg(i,x) for(int i=first[x];i;i=nxt[i])
#define forl(z,i,x) for(int i=z.first[x],y=z.to[i];i;i=z.nxt[i],y=z.to[i])
#define uu unsigned
#define fi first
#define se second
#define ran() ((unsigned)rand())
#define lam(z,k) [&](const z &a,const z &b){ return k; }
#define od(x) ((x)&1)
#define ev(x) (od(x)^1)

int n,m,mod;char dan[23];
int nxt[23];
struct mat{
	int a[23][23];
	int x,y;
	mat(){
		memset(a,0,sizeof(a));
	}
	mat(int xx,int yy){
		x=xx,y=yy;memset(a,0,sizeof(a));
	}
	inline void pr(){
		puts("******************");
		for(int i=0;i<=x;++i){
			for(int j=0;j<=y;++j)printf("%d ",a[i][j]);
			puts("");
		}
	}
};
mat hp,st,res,zy;
mat operator *(mat &a,mat &b){
	static mat hp;
	hp=mat(a.x,b.y);
	for(int k=0;k<=a.y;++k)for(int i=0;i<=hp.x;++i)for(int j=0;j<=hp.y;++j){
		(hp.a[i][j] += a.a[i][k]*b.a[k][j])%=mod;
	}
	return hp;
}
inline mat mpor(mat &be,mat &a,int p){
	hp=be;
	for(int i=p;i;i>>=1){
		if(i&1)hp=hp*a;
		a=a*a;
	}
	return hp;
}

inline mat giao(){
	// 10^n % mod
	mat a=mat(0,0),b=mat(0,0);
	a.a[0][0]=1%mod,b.a[0][0]=10%mod;
	return mpor(a,b,n);
}
inline int msub(int a,int b){
	return a>=b?a-b:a-b+mod;
}
int main(){
	scanf("%d%d%d%s",&n,&m,&mod,dan+1);
	nxt[0]=-1,nxt[1]=0;
	for(int i=2,j=0;i<=m;++i){
		while(~j&&dan[j+1]!=dan[i])j=nxt[j];
		nxt[i]=++j;
	}
	st=mat(0,m); st.a[0][0]=1;
	zy=mat(m,m);
	for(int i=0;i<m;++i)for(int j='0';j<='9';++j){
		int k=i;
		while(~k&&dan[k+1]!=j)k=nxt[k];
		++k;//普通的做法得写一句 if(k!=m)
		++zy.a[i][k];
	}
	zy.a[m][m]=10;

	res=mpor(st,zy,n);
	mat why=giao();//求10^n
	printf("%d\n",msub(why.a[0][0],res.a[0][m]));
	return 0;
}
```

---

## 作者：DavidJing (赞：8)

矩阵乘法加速动态规划

### step1

首先先阐述一个sb错误:我刚开始以为给的序列是无关答案的，后来发现其实是不行的，因为例如

n=4 m=3 数列为101和数列为111时是不一样的答案因为对于1111 1101其一个有重复一个无重复构成的答案不同~~应该只有我这种蒟蒻会这么想吧~~

**切入正题：**

在这里设$dp[i][j]$ 为文本串到i最多能匹配到模式串的j位上(文本串中i-j+1--i为与模式串1--j位相等)上的数总数

**再引入一个数组$g$,$g[i][j]$表示在模式串前缀为i后加一个数字使得后缀最多匹配前缀数量为j的方案数**

答案即为$\sum_{i=0}^{m-1}dp[n][i]$

可以得出状态转移方程$dp[i][j]=\sum_{k=0}^{m-1}{dp[i-1][k]+g[k][j]}$

什么意思呢?**其实就是在i位枚举0-9的可能，使i-1位上匹配的k个变为j个。**

然后本问题就可以在$O(n*m^2)$ 的时间内解决了

介绍一下$g$数组的求法，显然涉及到后缀前缀匹配，使用kmp即可。

```cpp
void kmp()
{
	p[1]=0;
	for(int i=2;i<=m;i++)
	{
		int j=p[i-1];
		while(s[j+1]!=s[i]&&j)j=p[j];
		if(s[j+1]==s[i])p[i]=j+1;
	}
	for(int i=0;i<=m-1;i++)//在i+1位上放j可以使得最多匹配个数
	for(int j='0';j<='9';j++)
	{
		int k=i;
		while(s[k+1]!=j&&k)k=p[k];
		if(s[k+1]==j)k++;
		g[i][k]++;
	}
}
```

### step2

显然上文的复杂度是不足以通过的。

此时观察状态转移方程$dp[i][j]=\sum_{k=0}^{m-1}{dp[i-1][k]+g[k][j]}$

是不是很像矩阵乘法?

我们可以建立两个矩阵$DP$矩阵和$G$ 矩阵

$$\begin{vmatrix}1\\0\\\cdots\\0\\\end{vmatrix}$$

$$\begin{vmatrix}g[0][0] &g[0][1] &\cdots &g[0][m-1] \\g[1][0] &\cdots & \cdots &g[1][m-1] \\ \cdots &\cdots &\cdots &\cdots \\g[m-1][0] &g[m-1][1] &\cdots & g[m-1][m-1]\\\end{vmatrix}$$
此时发现$DP$矩阵表示$i=0$时的情况即$dp[0][0]=1$其余为0

把$DP$矩阵与$G$矩阵的n次相乘即得出最终答案了

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,mo,tans;
char s[25];
int p[25],g[25][25];
void kmp()
{
	p[1]=0;
	for(int i=2;i<=m;i++)
	{
		int j=p[i-1];
		while(s[j+1]!=s[i]&&j)j=p[j];
		if(s[j+1]==s[i])p[i]=j+1;
	}
	for(int i=0;i<=m-1;i++)
	for(int j='0';j<='9';j++)
	{
		int k=i;
		while(s[k+1]!=j&&k)k=p[k];
		if(s[k+1]==j)k++;
		g[i][k]++;
	}
}
struct node{
	int p[25][25];
	node(){memset(p,0,sizeof(p));}
}ans,G,dp;
void tim(node &a,node b)
{
	node c;
	for(int k=0;k<=m-1;k++)
	for(int i=0;i<=m-1;i++)
	for(int j=0;j<=m-1;j++)
	c.p[i][j]=(c.p[i][j]+a.p[i][k]*b.p[k][j])%mo;
	a=c;
}
void pow(node &G)
{
	int t=n;for(int i=0;i<=m-1;i++)ans.p[i][i]=1;
	while(t!=1)
	{
		if(t%2)tim(ans,G);
		t/=2;tim(G,G);
	}
	tim(ans,G);
	G=ans;
}
int main()
{
	scanf("%d%d%d",&n,&m,&mo);
	cin>>s+1;kmp();dp.p[0][0]=1;
	for(int i=0;i<=m-1;i++)
	for(int j=0;j<=m-1;j++)
	G.p[i][j]=g[i][j];
	pow(G);tim(dp,G);
	for(int i=0;i<=m-1;i++)tans=(tans+dp.p[0][i])%mo;
	printf("%d",tans);
	return 0;
}
```



---

## 作者：Orion545 (赞：7)

# 广告

[蒟蒻のblog](http://www.cnblogs.com/dedicatus545/p/8902550.html)

# 思路

首先，如果$n$和$m$没有那么大的话，有一个非常显然的dp做法：

设$dp[i][j]$表示长度为i的字符串，最后j个可以匹配模板串前j位的情况数

那么显然，答案就是$\sum_{i=0}^{m-1}dp[n][i]$了

转移过程则需要用一个辅助数组：令$g[i][j]$表示模板串的前缀$i$可以转移到前缀$j$的方法数（注意它可能可以转移到很多个串）

辅助数组的生成可以用next数组来推（模板串太短，其实暴力也是可以的）

那么$dp[i+1][k]=dp[i][j]*g[j][k]\left(j=1...m\right)$

然后再看这题的数据范围：$n\leq 10^9$

Easy，加一个矩阵快速幂来解决上面的递推就行了

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
#define inf 1e9
using namespace std;
int MOD;
struct ma{//矩阵类
    int n,m,a[25][25];
    ma(){n=m=0;memset(a,0,sizeof(a));}
    void clear(){n=m=0;memset(a,0,sizeof(a));}
}A,B;
void mul(ma &a,ma b){//矩阵乘法
    ma re;int i,j,k;re.n=a.n;re.m=b.m;
    for(i=0;i<=re.n;i++){
        for(k=0;k<=a.m;k++){
            if(!a.a[i][k]) continue;
            for(j=0;j<=re.m;j++){
                re.a[i][j]=(re.a[i][j]+a.a[i][k]*b.a[k][j]%MOD)%MOD;
            }
        }
    }
    a=re;
}
int n,m,a[30],fail[30],f[30][10];char s[30];
void qpow(ma &x,ma &y,int t){//快速幂
    while(t){
        if(t&1) mul(x,y);
        mul(y,y);t>>=1;
    }
}
int main(){
    scanf("%d%d%d",&m,&n,&MOD);
    scanf("%s",s);int i,j,k;
    for(i=0;i<n;i++) a[i]=s[i]-'0';a[n]=inf;
    fail[0]=fail[1]=0;j=0;
    for(i=1;i<n;i++){//求出next数组
        while(j&&(a[i]!=a[j])) j=fail[j];
        j+=(a[i]==a[j]);fail[i+1]=j;
    }
    for(i=0;i<n;i++){//生成转移矩阵
        for(j=0;j<10;j++){
            k=i;while(k&&a[k]!=j) k=fail[k];
            k+=(a[k]==j);
            if(k<n) B.a[i][k]+=1;
        }
    }
    B.m=B.n=A.m=n-1;A.n=0;A.a[0][0]=1;
    qpow(A,B,m);
    int ans=0;
    for(i=0;i<n;i++) ans+=A.a[0][i],ans%=MOD;
    printf("%d",ans);
}
```

---

## 作者：muller (赞：4)

前置技能：

kmp 矩阵乘法

不会的可以去做模板题...qwq

这题好像没有什么部分分吧，题目里好像没有写

那我就讲讲标算吧

100 pts

首先普通的dp状态应该是f[i][j]到i为匹配j位

肯定tle

考虑到m比较小

我们可以建一个矩阵

于是我们就思考从匹配i位到j位的可能总数

这里我们可以用kmp，求一发nxt数组即可

剩余的我们建立一个初始矩阵，随便转移一下就可

注意矩阵中的A[len][len]为1

即表示只要匹配了便是满足条件

最后统计不是A[len][len]的和

放上我丑陋的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 25;
struct mat {
	int a[N][N];
} a, b;
int len, p, nxt[N];
mat operator *(mat a, mat b) {
	mat c;
	int i, j, k;
	for (i = 0; i <= len; ++i)
		for (j = 0; j <= len; ++j) c.a[i][j] = 0;
	for (i = 0; i <= len; ++i)
		for (j = 0; j <= len; ++j)
			for (k = 0; k <= len; ++k) c.a[i][j] = (c.a[i][j] + a.a[i][k] * b.a[k][j]) % p;
	return c;
}
mat pw(mat s, mat x, int y) {
	mat x1 = s, x2 = x;
	for (; y; y >>= 1, x2 = x2 * x2)
		if (y & 1) x1 = x1 * x2;
	return x1;
}
int main() {
	int i, j, x, n, res = 0;
	char s[N], c;
	scanf("%d%d%d", &n, &len, &p);
	scanf("%s", s + 1);
	for (i = 1, j = 0; i <= len; ++i) {
		while (j && s[i + 1] != s[j + 1]) j = nxt[j];
		if (s[i + 1] == s[j + 1]) ++j;
		nxt[i + 1] = j;
	}
	for (i = 0; i <= len; ++i)
		for (j = 0; j <= len; ++j) a.a[i][j] = b.a[i][j] = 0;
	b.a[0][1] = a.a[0][0] = 1; b.a[len][len] = 10; b.a[0][0] = 9;
	for (i = 1; i < len; ++i)
		for (c = '0'; c <= '9'; ++c) {
			x = i;
			while (x && s[x + 1] != c) x = nxt[x];
			if (s[x + 1] == c) ++b.a[i][x + 1];
			else ++b.a[i][0];
		}
	mat ans = pw(a, b, n);
	for (i = 0; i < len; ++i) res = (res + ans.a[0][i]) % p;
	printf("%d\n", res);
	return 0;
}

```

---

## 作者：Refun (赞：4)

好题。不看题解不会写题系列。 

~~虽然AC自动机的题解本来就没几篇我还一篇都没看懂~~


~~一开始口胡的写法是对的不过因为一个小瑕疵写挂了~~ 

建议先写过[文本生成器](http://www.cnblogs.com/refun/p/8706911.html)再来写这个题

不然这个题解可能看不懂

而且因为我比较菜不会的东西太多所以这个题解可能很长……

 
考虑暴力，我们会发现这个题和我做过的BZOJ1030好像几乎一模一样……

就连DP式子都一样

只不过N太大了没法转移是么……

贴一段文本生成器的AC代码。

```cpp
for (int i=1;i<=m;++i)
	for (int j=0;j<=sz;++j)
		for (int k=0;k<26;++k)
			if (!End[Son[j][k]])
				(f[i][Son[j][k]]+=f[i-1][j])%=MOD;
```
我们发现外层的m(也就是本题的N)循环的时候，里面两个循环每次进行的转移都是机械一样的。

都是根据父亲的状态来推儿子的状态。

这样的话，我们就可以用矩阵快速幂来优化了。


举个例子

4 3 100

111

这是样例。

我们将初始矩阵start定义为[1,0,0]，这对应的是文本生成器一题中的初始化f[0][0]=1; 

然后将x节点与x的所有儿子节点在转移矩阵a中a[x][son]+=1

这样在矩乘转移的时候我们就可以把父亲的状态推到儿子了 

最后答案即为start*a^n


因为很容易发现,start是f[0][]的所有状态

start*a是f[1][]的所有状态

那么start*a^n即为f[n][]的所有状态

将start*a^n矩阵里的所有数值加起来即为所求答案。

orz感觉自己已经是一条咸鱼了


对了送组数据: 

1000000000 19 9973

1010100110011000001 

5753

代码戳→[蒟蒻的博客](http://www.cnblogs.com/refun/p/8710926.html)

---

## 作者：_ctz (赞：2)

[$\tt\text{My blog}$](https://ctz45562.github.io/2019/03/27/%E6%B4%9B%E8%B0%B7-P3193-HNOI2008-GT%E8%80%83%E8%AF%95/)

[传送门](https://www.luogu.org/problemnew/show/P3193)

求方案数，显然这个题得动态规划。。。

设$f(i,j)$为母串长为$i$位，子串当前匹配到了第$j$位的方案数。考虑$f(i,j)$向$i+1$转移：

枚举$i+1$的数字，然后就会发现这玩意可以用$kmp$转移。预处理出$next$数组后，转移时和普通的$kmp$匹配一样跳$next$数组，直到匹配到最长前缀转移过去。

初值$f(0,0)=1$，答案$ans=\sum\limits_{i=0}^{i<m}f(n,i)$

伪代码：

```cpp
	f[0][0]=1;
	for(int i=0;i<n;++i)
		for(int j=0;j<m;++j)
			for(int k='0';k<='9';++k){//枚举下一位
				int l=j;
				while(l&&a[l+1]!=k)l=next[l];
				if(a[l+1]==k)++l;
                //和kmp一样以k为i+1位的数字匹配
				(f[i+1][l]+=f[i][j])%=mod;
			}
	int ans=0;
	for(int i=0;i<m;++i)
		(ans+=f[n][i])%=mod;

```

复杂度~~不会证~~，反正不低于$O(10nm)$。这个式子可以用矩阵快速幂优化。把$f(i-1,0$ ~ $m-1)$和$f(i,0$ ~ $m-1)$扔进去，枚举每一个$j$和第$i+1$位的数字，在矩阵上对应的位置$+1$。

显然$f(1,0)=9,f(1,1)=1$，然后直接矩乘就好了。

矩阵大小：$(2m)*(2m)$，复杂度$O(40^3\log n)$

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

using namespace std;

inline int read(){
    int x=0,y=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return y?-x:x;
}
template<typename T>
inline T read(){
    T x=0;
    int y=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return y?-x:x;
}
int n,m,mod;
int next[50];
char a[22];
struct Matrix{
    int a[50][50],l,c;
    Matrix operator * (const Matrix x){
        Matrix ans;
        ans.l=l,ans.c=x.c;
        for(register int k=0;k<c;++k)
            for(register int i=0;i<l;++i)
                for(register int j=0;j<x.c;++j)
                    (ans.a[i][j]+=a[i][k]*x.a[k][j])%=mod;
        return ans;
    }
    Matrix(){
        memset(a,0,sizeof a);
    }
}start,origin;
//start为初始矩阵，origin为转移矩阵
Matrix quickpow(Matrix x,int y){
    Matrix ans;
    ans.l=ans.c=x.l;
    for(register int i=0;i<ans.l;++i)
        ans.a[i][i]=1;
    while(y){
        if(y&1)ans=ans*x;
        x=x*x;
        y>>=1;
    }
    return ans;
}
void kmp(){
    int j=0;
    for(register int i=2;i<=m;++i){
        while(j&&a[j+1]!=a[i])j=next[j];
        if(a[j+1]==a[i])++j;
        next[i]=j;
    }
}
void build(){
    for(register int i=m,j=0;i<(m<<1);++i,++j)
        origin.a[i][j]=1;
    for(register int i=0;i<m;++i){
        for(register int j='0';j<='9';++j){
            int k=i;
            while(k&&a[k+1]!=j)k=next[k];
            if(a[k+1]==j)++k;
            if(k<m)++origin.a[i+m][k+m];
            //m=i、下一位为j时会对第k位产生影响
        }
    }
    origin.l=origin.c=m<<1;
    start.l=1,start.c=m<<1;
    start.a[0][0]=start.a[0][m+1]=1,start.a[0][m]=9;
}
int main(){
    n=read(),m=read(),mod=read();	
    scanf("%s",a+1);
    kmp();
    build();
    start=start*quickpow(origin,n);
    int ans=0;
    for(register int i=0;i<m;++i)
        (ans+=start.a[0][i])%=mod;
    printf("%d\n",ans);
}


```



---

## 作者：小塘空明 (赞：1)

首先n=1e9，m=20，基本可以确定这是一到矩阵乘法的题。

所以我们按照套路，考虑f[i][j]=f[i][k]*g[k][j](0<=k<m),f数组表示选了i个数，末尾字符串匹配字符串a前缀k位，g数组表示从匹配k位到匹配j位的方法种数。

答案就是f[n][k] （0<=k<m）

根据f数组的定义，我们很容易想到用kmp预处理出next数组。

考虑处理g数组，假设当前已经匹配了i位，我们枚举第i+1位选了哪个数字，处理出在选了这个数字的情况下能与前缀匹配几位。

注意f[i][i]初始时都为1。

然后加个矩阵优化就行了。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
#include<queue>
using namespace std;
typedef long long ll;
const ll N=25;
ll n,m,mod,ans,next[N],f[N][N],b[N][N];char s[N];
inline ll read(){
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}
inline void mul(ll a[25][25],ll b[25][25]){
	ll c[25][25];
	memset(c,0,sizeof(c));
	for(ll i=0;i<m;i++){
		for(ll j=0;j<m;j++){
			for(ll k=0;k<m;k++){
				c[i][j]=(c[i][j]+a[i][k]*b[k][j])%mod;
			}
		}
	}
	memcpy(a,c,sizeof(c));
}
int main(){
	n=read();m=read();mod=read();
	scanf("%s",s+1);
	next[1]=0;
	for(ll i=2,j=0;i<=m;i++){
		while(j&&s[j+1]!=s[i]) j=next[j];
		if(s[j+1]==s[i]) j++;
		next[i]=j; 
	}
	for(ll i=0;i<m;i++){
		for(ll j='0';j<='9';j++){
			ll p=i;
			while(p&&s[p+1]!=j) p=next[p];
			if(s[p+1]==j) p++;
			if(p!=m) b[i][p]=(b[i][p]+1)%mod;
		}
	}
	for(ll i=0;i<m;i++) f[i][i]=1;
	for(ll i=n;i;i>>=1,mul(b,b)){
		if(i&1) mul(f,b);
	}
	for(ll i=0;i<m;i++) ans=(ans+f[0][i])%mod;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：i207M (赞：1)

## 题目总结

求N位数（可以以0开头）中不包含数字串M的个数；

## 数据范围

$N≤10^9,M≤20,K≤1000$

## 解题思路

KMP+DP；

很容易发现此题可以用DP来写；

$f[i][j]$ 表示第i位数字，匹配长度为j的数量；

![](https://cdn.luogu.com.cn/upload/pic/20141.png)

但是N较大，考虑优化；

因为每次乘数相同，并且这个转移十分像矩阵，考虑矩阵快速幂；

初始矩阵为 $f[0][0]=0$；

乘矩阵G可通过KMP统计；对于每一位i，枚举下一位数字，通过KMP加速匹配，找到衔接这位数字后的匹配数，++；

由于初始矩阵很特殊，所以不用乘它，只需将快速幂后的G矩阵第0行加起来即可（自己手算规律）

## 易错误区

**一定不要写错KMP！！！**
```cpp
nxt[0] = -1;
    for (ri i = 1, j; i <= m; i++) {
        j = nxt[i - 1];
        while (j != -1 && s[j + 1] != s[i]) j = nxt[j];
        nxt[i] = j + 1;
    }
    nxt[0] = 0;
```

## 代码展示

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<list>
#include<queue>
#include<stack>
#include<bitset>
#include<deque>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define ri register int
#define il inline
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
#define mem0(x) memset((x),0,sizeof (x))
#define mem1(x) memset((x),0x3f,sizeof (x))
il char gc() {
    static const int BS = 1 << 22;
    static unsigned char buf[BS], *st, *ed;
    if (st == ed) ed = buf + fread(st = buf, 1, BS, stdin);
    return st == ed ? EOF : *st++;
}
#define gc getchar
template<class T>void in(T &x)
{
    x = 0; bool f = 0; char c = gc();
    while (c < '0' || c > '9') {if (c == '-') f = 1; c = gc();}
    while ('0' <= c && c <= '9') {x = (x << 3) + (x << 1) + (c ^ 48); c = gc();}
    if (f) x = -x;
}
#undef gc
void out(int x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) out(x / 10);
    putchar(x % 10 + '0');
}
#define N 25
#define M 1
int n, m, md;
char s[N];
int ls, nxt[N];
struct Mat {
    int p[N][N];
    Mat() {mem0(p);}
};
void mul(Mat &a, Mat &b) {
    Mat ret;
    for (ri i = 0; i < m; i++) {
        for (ri k = 0; k < m; k++) {
            if (!a.p[i][k]) continue;
            for (ri j = 0; j < m; j++) {
                (ret.p[i][j] += a.p[i][k] * b.p[k][j] % md) %= md;
            }
        }
    }
    a = ret;
}
void qpow(Mat &a, int p) {
    Mat ret = a; p--;
    for (; p; p >>= 1, mul(a, a)) if (p & 1) mul(ret, a);
    a = ret;
}
int ans;
Mat g;
signed main() {
    in(n), in(m), in(md);
    scanf("%s", s + 1);
    nxt[0] = -1;
    for (ri i = 1, j; i <= m; i++) {
        j = nxt[i - 1];
        while (j != -1 && s[j + 1] != s[i]) j = nxt[j];
        nxt[i] = j + 1;
    }
    nxt[0] = 0;
    for (ri i = 0, t; i < m; i++) {
        for (ri j = '0'; j <= '9'; j++) {
            t = i;
            while (t && s[t + 1] != j) t = nxt[t];
            if (s[t + 1] == j) t++;
            g.p[i][t]++;
        }
    }
    qpow(g, n);
    for (ri i = 0; i < m; i++) (ans += g.p[0][i]) %= md;
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：miaowey (赞：1)

令f[i][j]表示原串第i位匹配了不吉利数列(unlu[])第j位的方案数

则对于原串中每一个f[i][j]，用它更新所有后接0-9数字应该转移到的所有f[i+1][k]

后接数字要么等于unlu[j+1]，那么k为j+1

要么找到前面与其匹配的位置k


然后用kmp与矩阵快速幂优化即可


代码
'''












```cpp
//miaomiao 2017.2.12
#include<cstdio>
#include<cstring>
using namespace std;
#define Set(a, v) memset(a, v, sizeof(a))
#define For(i, a, b) for(int i = (a); i <= (int)(b); i++)
#define M (20+5)
int n, rm, P, unlu[M], f[M];
struct Matrix{
    int m[M][M];
    Matrix(int x=0){
        Set(m, 0); if(!x) return;
        For(i, 0, rm) m[i][i] = 1;
    }
    Matrix operator *(const Matrix &rhs)const{
        Matrix ret;
        For(k, 0, rm-1) For(i, 0, rm-1) if(m[i][k]) For(j, 0, rm-1)
            ret.m[i][j] = (ret.m[i][j]+m[i][k]*rhs.m[k][j]%P)%P;
        return ret;
    }
    Matrix operator ^(int num){
        Matrix ret(1), a = *this;
        while(num){
            if(num&1) ret = ret*a;
            a = a*a; num >>= 1;
        }
        return ret;
    }
}base;
int to[M][10];
inline void getfail(){
    For(i, 1, rm-1){
        int j = f[i];
        while(j && unlu[i+1]!=unlu[j+1]) j=f[j];
        f[i+1] = unlu[i+1]==unlu[j+1]? j+1: 0;
    }    
    For(i, 0, rm-1) For(j, 0, 9){
        to[i][j] = unlu[i+1]==j? i+1: to[f[i]][j];
        base.m[i][to[i][j]]++;
    }
}
int main(){
    scanf("%d%d%d", &n, &rm, &P);
    For(i, 1, rm) scanf("%1d", &unlu[i]);
    getfail();
    Matrix a; a.m[0][0] = 1;
    a = a*(base^n);
    int sum = 0;
    For(i, 0, rm-1) sum += a.m[0][i];
    printf("%d\n", sum%P);
    return 0;
}
'''
```

---


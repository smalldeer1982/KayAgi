# [HNOI2011] 数学作业

## 题目描述

小 C 数学成绩优异，于是老师给小 C 留了一道非常难的数学作业题：

给定正整数 $n,m$，要求计算 $\text{Concatenate}(n) \bmod \ m$  的值，其中 $\text{Concatenate}(n)$ 是将 $1 \sim n$ 所有正整数 顺序连接起来得到的数。

例如，$n = 13$，$\text{Concatenate}(n) = 12345678910111213$。小 C 想了大半天终于意识到这是一道不可能手算出来的题目，于是他只好向你求助，希望你能编写一个程序帮他解决这个问题。



## 说明/提示

【数据范围】

对于 $30\%$ 的数据，$1\le n \le 10^6$；  
对于 $100\%$ 的数据，$1\le n \le 10^{18}$，$1\le m \le 10^9$。

- 2023.4.20 添加一组 hack 数据。

## 样例 #1

### 输入

```
13 13```

### 输出

```
4```

# 题解

## 作者：Laoshan_PLUS (赞：28)

### 题意

令 $\operatorname{Concatenate}(n)$ 是将 $1\sim n$ 所有正整数顺序连接起来得到的数。给定 $n,m$，求 $\operatorname{Concatenate}(n)\bmod m$ 的值。

对于 $100\%$ 的数据，$1\le n\le10^{18}$，$1\le m\le10^9$。

### 解析

矩阵加速题。令 $\textit{dp}[i]=\operatorname{Concatenate}(i)$，则有：

$$
\textit{dp}[i]=\left[\left(\textit{dp}[i-1]\times10^{1+\lg i}\bmod m\right)+i\right]\bmod m
$$

构造出答案矩阵：

$$
\begin{bmatrix}
\textit{dp}[i] \\ i+1 \\ 1
\end{bmatrix}
$$

> 答案矩阵是如何构造的？
> 
> 答案矩阵一般情况下都是单列：
> 
> 1. 先把 $\textit{dp}[i]$ 写上，方便在最后直接输出：
> 
> $$
> \begin{bmatrix}\textit{dp}[i]\\ \\ \\\end{bmatrix}
> $$
> 
> 2. 观察转移方程，$\textit{dp}[i]$ 需要由 $\textit{dp}[i-1]$ 和 $i$ 推出，这两项都需要体现在矩阵里。为了转移下一位，矩阵中还需要有 $i+1$：
> 
> $$
> \begin{bmatrix}\textit{dp}[i]\\i+1\\ \\\end{bmatrix}
> $$
> 
> 3. 由 $i$ 是如何推得 $i+1$ 的呢？所以矩阵中还需要有一个常数项 $1$：
> 
> $$
> \begin{bmatrix}\textit{dp}[i]\\i+1\\1\end{bmatrix}
> $$

构造出转移矩阵：

$$
\begin{bmatrix}
10^k& 1 & 0 \\
0 & 1 & 1 \\
0 & 0 & 1
\end{bmatrix}
$$

$k$ 为这一步对应 $i$ 的数位数，即 $1+\lg i$。

> 转移矩阵是如何构造的？
> 
> **转移矩阵构造法：将单行的答案矩阵横倒过来看，再根据状态转移方程处理每行的加减情况。**
> 
> 1. $\textit{dp}[i]$ 是如何推得的？$\textit{dp}[i]=\textit{dp}[i-1]\times10^{1+\lg i}+i$（取模在运算时体现）。令 $k=1+\lg i$，所以转移矩阵第一行写上：
> 
> $$
> \begin{bmatrix}10^k&1&0\\&&\\&&\\\end{bmatrix}
> $$
> 
> 2. 同理，要推 $i+1$，就得在 $i$ 的位置和 $1$ 的位置点上 $1$：
> 
> $$
> \begin{bmatrix}10^k&1&0\\0&1&1\\\\\end{bmatrix}
> $$
> 
> 3. $1$ 转移过来还是 $1$，所以完成转移矩阵：
> 
> $$
> \begin{bmatrix}10^k&1&0\\0&1&1\\0&0&1\end{bmatrix}
> $$

我们发现 $k$ 会随着 $i$ 改变，这在矩阵快速幂中是不允许的，因此不能一次矩阵快速幂解决。我们需要根据每一次的 $i$ 构造转移矩阵，每次快速幂的幂次这一层转移的次数，即 $\min\hspace{-0.25em}\left(n-10^{k-1}+1,10^k-10^{k-1}\right)$。

细节……也就这么多，具体见代码。时间复杂度 $O(\lg n\times\log n)$ 左右。

### 实现

```cpp
#include <bits/stdc++.h>
#define int unsigned long long
using namespace std;

int n, p;
struct Matrix {
	int r, c, mx[4][4];
	Matrix() {
		memset(mx, 0, sizeof(mx));
	}
	friend Matrix operator * (Matrix a, Matrix b) {
		Matrix res;
		res.r = min(a.r, b.r), res.c = min(a.c, b.c);
		for (int i = 1; i <= a.r; i++)
			for (int j = 1; j <= b.c; j++)
				for (int k = 1; k <= a.c; k++)
					res.mx[i][j] = (res.mx[i][j] + a.mx[i][k] * b.mx[k][j] % p) % p;
		return res;
	}
} a, b;

Matrix power(Matrix a, Matrix b, int x) {
	while (x > 0) {
		if (x & 1) a = b * a;
		b = b * b;
		x >>= 1;
	}
	return a;
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(nullptr);
	cin >> n >> p;
	a.c = 1, a.r = b.r = b.c = 3;
	a.mx[2][1] = a.mx[3][1] = 1;
	b.mx[1][2] = b.mx[2][2] = b.mx[2][3] = b.mx[3][3] = 1;
	for (int k = 10;; k *= 10) {
		b.mx[1][1] = k % p;
		if (n < k) {
			a = power(a, b, n - k / 10 + 1);
			break;
		}
		a = power(a, b, k - k / 10);
	}
	cout << a.mx[1][1] << '\n';
	
	return 0;
}
```

---

## 作者：peterwuyihong (赞：19)

## 提供一个奇妙的构造矩阵方法
$ \begin{bmatrix} dp[i]  \\ i  \\i+1 \end{bmatrix} = \begin{bmatrix} dp[i-1]  \\ i-1  \\i \end{bmatrix} \begin{bmatrix} 10^k &0 &1 \\ 0&0&1  \\0&-1&2 \end{bmatrix}  $

你说作者一开始怎么没有想到卷一个$1$进来，真是笨死了
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,mod;
struct matrix{
	int s[3][3];
	matrix operator*(matrix a){
		matrix ans;
		memset(ans.s,0,sizeof ans.s);
		for(int i=0;i<3;i++)
		for(int j=0;j<3;j++)
		for(int k=0;k<3;k++)
		ans.s[i][j]=((ans.s[i][j]+a.s[i][k]*s[k][j])%mod+mod)%mod;
		return ans;
	}
}ans,base,k;
matrix one(){
	matrix a;
	memset(a.s,0,sizeof a.s);
	for(int i=0;i<3;i++)a.s[i][i]=1;
	return a;
}
matrix ksm(matrix a,int b){
	matrix ans=one();
	for(;b;b>>=1,a=a*a)
	if(b&1)ans=ans*a;
	return ans;
}
__int128 ten[22];
signed main(){
	cin>>n>>mod;
	n++;
	ten[0]=1;
	for(int i=1;i<=20;i++)ten[i]=ten[i-1]*10;
	memset(base.s,0,sizeof base.s);
	k.s[0][0]=0,k.s[1][0]=0,k.s[2][0]=1;
	base.s[0][2]=1,base.s[1][2]=1,base.s[2][1]=-1,base.s[2][2]=2;
	for(int i=1;i<=(int)ceil(1+log(n)/log(10.0));i++){
		base.s[0][0]=ten[i]%mod;
		if(n<ten[i]){
			k=k*ksm(base,n-ten[i-1]);
			cout<<k.s[0][0];
			return 0;
		}k=k*ksm(base,ten[i]-ten[i-1]);
	}
}
```


---

## 作者：qwaszx (赞：18)

蒟蒻看到这题题解瑟瑟发抖

拆开矩乘岂不是要烦死人

那我们来观察一下这个东西

如果我们有一个函数可以计算出来把$[l,r]$(l，r位数相同)串到一起的值，那答案就非常显然了

按照位数分段做，每一段的位数是容易求的，就用原来的答案乘上10的位数次方再加上$[l,r]$的答案

如果我们设这段区间内的位数都为$k$，那么这一段的值就是

$r+(r-1)*10+(r-2)*10^2+...+l*10^{r-l}$

这是个等差比数列，然而求和公式显然不能用因为$m$不一定是素数

那么我们就考虑按照分治法求和等比数列的办法来做

假设$S(l,r,n)=l+(l-1)r+(l-2)r^2+...(l-n)r^n$

显然$S(l,r,0)=l$

然后按照$n$的奇偶性分类

$n$是奇数:
$S(l,r,n)=[l+(l-1)r+...+(l-\frac{n-1}{2})r^{\frac{n-1}{2}}]+r^\frac{n+1}{2}[(l-\frac{n+1}{2})+...(l-n)^\frac{n-1}{2}]$

$=(1+r^\frac{n+1}{2})[l+(l-1)r+...+(l-\frac{n-1}{2})r^{\frac{n-1}{2}}]-\frac{n+1}{2}r^\frac{n+1}{2}(1+r+...r^\frac{n-1}{2})$

$=(1+r^\frac{n+1}{2})S(l,r,\frac{n-1}{2})-\frac{n+1}{2}r^\frac{n+1}{2}(1+r+...r^\frac{n-1}{2})$

后面的这一长串可以用类似的方法分治求解

$n$是偶数:$S(l,r,n)=S(l,r,n-1)+(l-n)r^n$

于是我们就得到了$O(log^3n)$的做法[递归$log$次，等比数列求和是$log^2$的(递归$log$次，快速幂是$log$的)]

细节:unsigned long long在处理减法的时候要极为小心，还有注意乘法取模的问题

```
#include<iostream> 
#include<cstdio>
#include<cstring>
#define ull unsigned long long
using namespace std;
ull n,m;
ull length(ull l,ull r,ull len){return (r-l+1)*len;}
ull qpower(ull a,ull b,ull m)
{
	ull ans=1%m;a%=m;
	while(b)
	{
		if(b&1)ans=ans*a%m;
		a=a*a%m;
		b>>=1;
	}
	return ans;
}
ull s(ull r,ull n)
{
	if(!n)return 1;
	if(n&1)return (1+qpower(r,(n+1)>>1,m))%m*s(r,n>>1)%m;
	return ((1+qpower(r,n>>1,m))%m*s(r,(n>>1)-1)%m+qpower(r,n,m))%m;
}
ull calc(ull l,ull r,ull n)
{
	if(!n)return l;
	if(n&1)return ((1+qpower(r,(n+1)>>1,m))*calc(l,r,n>>1)%m-qpower(r,(n+1)>>1,m)*(((n+1)>>1)%m)%m*s(r,n>>1)%m+m)%m;
	return ((1+qpower(r,n>>1,m))*calc(l,r,(n>>1)-1)%m+m-qpower(r,n>>1,m)*((n>>1)%m)%m*s(r,(n>>1)-1)%m+((l+m-n%m)%m)*qpower(r,n,m)%m+m)%m;
}
int main()
{
	scanf("%lld%lld",&n,&m);
	ull i,l,len;
	ull ans=0;
	for(i=1,l=1;i*10<=n;i*=10,l++)
	{
		len=length(i,i*10-1,l);
		ans=(ans*qpower(10,len,m)%m+calc((i*10-1)%m,i*10%m,i*9-1))%m;
	}
	len=length(i,n,l);
	ans=(ans*qpower(10,len,m)%m+calc(n%m,i*10%m,n-i))%m;
	cout<<ans<<endl;
}
```

---

## 作者：xyz32768 (赞：8)

考虑求$Concatenate(L...R)$的值，其中$[L,R]$之间的数都是$x$位数。

可以得到，$Concatenate(L...i)$可以用递推式表示。以下设$Concatenate(L...i)$为$f[i]$。

则有：

$f[L]=L$

$f[i]=f[i-1]*10^x+i$

建立一个$3*3$的转移矩阵$P$，第一行代表$f[i]$，第二行代表$i$，第三行代表$1$。则容易得出矩阵内容：

$$
\begin{bmatrix}

10^x & 1 & 1 \\

0 & 1 & 1 \\

0 & 0 & 1

\end{bmatrix}

$$
$3*1$的边界矩阵$F$：

$$
\begin{bmatrix}

L \\
L  \\
1
\end{bmatrix}

$$
此时可以得出，$f[R]=(P^{R-L}*F)[1][1]$。

用这样的方法，就可以求出$Concatenate(1...9)$，$Concatenate(10...99)$，$Concatenate(100...999)$，...，$Concatenate(10^k,N)$的值，然后乱搞即可。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
ll nn, E10[1005]; int CYX, Exp[1005], np[25];
struct cyx {
    int m, n, a[15][15];
    cyx() {}
    cyx(int _m, int _n) :
        m(_m), n(_n) {memset(a, 0, sizeof(a));}
    friend inline cyx operator * (cyx x, cyx y) {
        cyx z = cyx(x.m, y.n); int i, j, k;
        for (i = 1; i <= z.m; i++) for (j = 1; j <= z.n; j++)
        for (k = 1; k <= x.n; k++)
            (z.a[i][j] += 1ll * x.a[i][k] * y.a[k][j] % CYX)
                %= CYX;
        return z;
    }
    friend inline cyx operator ^ (cyx x, ll y) {
        cyx aa = x, z = cyx(x.m, x.n); int i;
        for (i = 1; i <= z.m; i++) z.a[i][i] = 1;
        while (y) {
            if (y & 1) z = z * aa;
            aa = aa * aa;
            y >>= 1;
        }
        return z;
    }
} F, P;
int qpow(int a, ll b) {
    int res = 1;
    while (b) {
        if (b & 1) res = 1ll * res * a % CYX;
        a = 1ll * a * a % CYX;
        b >>= 1;
    }
    return res;
}
int solve(int w, ll mx) {
    F.a[1][1] = F.a[2][1] = Exp[w - 1];
    F.a[3][1] = 1; P.a[1][1] = Exp[w];
    F = (P ^ mx - E10[w - 1]) * F;
    return F.a[1][1];
}
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
int main() {
    int i, cnt = 0, res = 0;
    cin >> nn; CYX = read(); Exp[0] = E10[0] = 1;
    for (i = 1; i <= 1000; i++)
        Exp[i] = 1ll * Exp[i - 1] * 10 % CYX;
    for (i = 1; i <= 18; i++) E10[i] = E10[i - 1] * 10;
    F = cyx(3, 1); P = cyx(3, 3);
    P.a[1][2] = P.a[1][3] = P.a[2][2]
    = P.a[2][3] = P.a[3][3] = 1; ll bb = nn;
    while (bb) cnt++, bb /= 10;
    for (i = 1; i <= cnt; i++) {
        ll mx = i == cnt ? nn : E10[i] - 1;
        res = 1ll * res *
            qpow(qpow(10, mx - E10[i - 1] + 1), i) % CYX;
        (res += solve(i, mx)) %= CYX;
    }
    printf("%d\n", res);
    return 0;
}
```

---

## 作者：pantw (赞：7)

$n<=10^{18}$的范围提醒我们，这题应该往倍增/快速幂等方向考虑。


由递推式：$f[i]*10^k+i+1=f[i+1]$，我们可以设计出以下转移矩阵：


$ com=\begin{bmatrix}

10^k & 0 & 0 \\\

1 & 1 & 0 \\\

1 & 1 & 1


  \end{bmatrix}$

设$ans=\begin{bmatrix}f[i]&i&1\end{bmatrix}$。

则：$ans \times com=\begin{bmatrix}f[i+1]&i+1&1\end{bmatrix}$

其中$k=\lfloor\log{i}\rfloor+1$。

由矩阵乘法的结合性，我们可以用快速幂加速这个过程。

因为k的取值只有不到20种，我们可以直接枚举处理。

实现细节详见代码。


```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#define lld "%lld"
#define Lovelive long long
Lovelive mod;

struct matrix{
    int n, m;
    Lovelive mat[10][10];

    matrix(int n = 0, int m = 0): n(n), m(m) {}

    void clear() {
        memset(mat, 0, sizeof mat);
    }

    void iden() {
        memset(mat, 0, sizeof mat);
        for(int i = 0; i < n; i++) mat[i][i] = 1; 
    }

    matrix operator * (const matrix& b) const {
        if(m != b.n) exit(2333);
        int p = b.m;
        matrix c(n, b.m);
        c.clear();
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < p; j++) {
                for(int k = 0; k < m; k++) {
                    c.mat[i][j] += mat[i][k] * b.mat[k][j];
                    c.mat[i][j] %= mod;
                }
            }
        }
        return c;
    }

    matrix operator ^ (Lovelive p) {
        matrix ret(n, n), tmp;
        ret.iden();
        for(tmp = *this; p; p>>=1, tmp = tmp * tmp) {
            if(p & 1) ret = ret * tmp;
        }
        return ret;
    }
};

char buf[2333];
int main() {
    Lovelive n, bit;
    scanf(lld lld, &n, &mod);

    sprintf(buf, lld, n);
    bit = strlen(buf);

    matrix ans(1, 3);
    ans.clear();
    ans.mat[0][2] = 1;

    for(int i = 1; i <= bit; i++) {
        Lovelive unit = pow(10, i - 1);

        matrix com(3, 3);
        com.clear();
        com.mat[0][0] = unit % mod * 10 % mod;
        com.mat[1][0] = com.mat[1][1] = com.mat[2][0] = com.mat[2][1] = com.mat[2][2] = 1;

        if(i != bit) ans = ans * (com ^ (unit * 9));
        else ans = ans * (com ^ (n - unit + 1));
    }

    printf(lld, ans.mat[0][0]);
}
```

---

## 作者：zzw4257 (赞：5)

### 题意
>求$1,2,3,\cdots,n$拼在一起$\pmod{m}$意义下的值

### Solution

首先把这个东西表示出来$f_i$表示$1,2,3,\cdots,i$拼起来的数,因为是拼起来那么就是$i$和$i-1$的转移

$f_i=10^{\lfloor\lg n\rfloor+1}f_{i-1}+i$

然后将其写成矩阵乘法形式,要带着$i$走

$\begin{bmatrix}f_n\\n\\1\end{bmatrix}=
\begin{bmatrix}10^{\lfloor\lg n\rfloor+1}&&1&&&1\\\\
0&&1&&&1\\\\0&&0&&&1\end{bmatrix}\begin{bmatrix}f_{n-1}\\n-1\\1\end{bmatrix}$即可

---

## 作者：阔睡王子 (赞：5)

### 简单的矩阵递推练手题
前言：听完了矩阵递推的网课后我打开了团队练习题单，发现自己并不会[矩阵游戏](https://www.luogu.com.cn/problem/P1397)中矩阵满足费马小定理的证明，于是只好来切这道题，但事实上，抛开细节对代码构筑能力的考验，这道题比矩阵游戏简单，甚至可以说在你明白这是道矩阵递推的题后，简直就是水题。\
一开始先不想矩阵递推，不难推出公式：
```
long long ans=0; 
for(long long i=1;i<=n;i++)
{
	//ws[i]是i的位数 
	ans=ans*ws[i]+i;//不模的简洁版 
	ans=(ans*ws[i]%mod+i)%mod;//取模的细节版 
}
 
```

明显会爆longlong， $n$ 可是小于等于 $10^{18}$ 的啊。\
思考矩阵递推，发现在矩阵里面搞位数这玩意儿实属不会，看看 $n$ 的范围，想到按位数来搞矩阵快速幂，总共做 $18$ 次，这样就不难处理位数了，而且代码跑的比香港记者还快。
然后想出矩阵如下（以下以位数为 $1$ 时为例子）：

$\begin{vmatrix}
10 & 1 & 0 \\
0 & 1 & 1 \\
0 & 0 & 1
\end{vmatrix}$
$\times$
$\begin{vmatrix}
sum[i-1] \\
i \\
1 
\end{vmatrix}$
$=$
$\begin{vmatrix}
sum[i]\times10+i \\
i+1 \\
1
\end{vmatrix}$
$=$
$\begin{vmatrix}
sum[i] \\
i+1 \\
1 
\end{vmatrix}$

又比如位数为3时：

$\begin{vmatrix} 
1000 & 1 & 0 \\
0 & 1 & 1 \\
0 & 0 & 1 
\end{vmatrix}$ 
$\times$
$\begin{vmatrix}
sum[i-1] \\
i \\
1 
\end{vmatrix}$
$=$
$\begin{vmatrix}sum[i]\times 1000+i \\
i+1 \\
1 
\end{vmatrix}$
$=$
$\begin{vmatrix}
sum[i] \\
i+1 \\
1 
\end{vmatrix}$

举了两个例子后思路就清晰了，我们可以先求1到10，再求10到100，然后是100到1000等等。

```
struct node
{
	int x,y;//行列数 
	int a[5][5];
	void empty()//清空哦 
	{
		x=y=0;
		for(int i=0;i<=4;i++)
		for(int j=0;j<=4;j++)
		{
			a[i][j]=0;
		}
	}
	void check()//验错用的
	{
		for(int i=1;i<=x;i++)
		{
			for(int j=1;j<=y;j++)
			printf("%lld ",a[i][j]);
			printf("\n");
		}
	}
}q[20],p,p2;//q表示对应位数下使用的3X1初始矩阵,p是用来维护递推关系的柿子，p是单位矩阵0. 
/*
	q[1]：
	0
	1
	1
	q[2]： 
	123456789
	10
	1 
*/ 
void pre()//初始化 
{
	int temp=1;
	for(int i=1;i<=18;i++)
	{
		q[i].x=3,q[i].y=1;
		q[i].a[2][1]=temp;
		temp=temp*10;
		q[i].a[3][1]=1;
	}
	p.x=p.y=p2.x=p2.y=3;
	p.a[1][1]=10;
	p.a[2][2]=p.a[1][2]=p.a[2][3]=p.a[3][3]=1;
	p2.a[1][1]=p2.a[2][2]=p2.a[3][3]=1;
}
void work(int now,int pre,int to)//现在的位数,上一次计算到的位置，这一次该计算到的位置 
{
	//q[now]是递推出来的3X1矩阵，p是左边用于递推的3X3矩阵 
	int temp=q[now-1].a[1][1];//继承 
	q[now].a[1][1]=temp;
	if(now==ws_ans)//如果当前位数和答案一致,可以合法的到达答案了 
	{
		node b=quickpow(p,n-pre);//矩阵快速幂 
		q[now]=b*q[now];//计算出最终的矩阵 
		printf("%lld",q[now].a[1][1]);
		return;
	}
	else q[now]=quickpow(p,to-pre)*q[now];//直接求解下一个位数的第一个矩阵 
	p.a[1][1]=p.a[1][1]*10%mod;//此处记得取模 
	work(now+1,to,(to+1)*10-1);//递归下一位数 
} 
```
然后还要注意取模的问题，不要爆longlong，基本上自己手测几个样例之后就能过了。\
送一组大样例，输入19191145141919 415411 ，输出246506。\
原代码如下：（有些变量名与上面不一样，注意区分）

```
#include<cstdio>
#define int unsigned long long
using namespace std;
int n,m,ws;
struct node
{
	int x,y; 
	int a[5][5];
	void empty()
	{
		x=y=0;
		for(int i=0;i<=4;i++)
		for(int j=0;j<=4;j++)
		{
			a[i][j]=0;
		}
	}
	void check()
	{
		for(int i=1;i<=x;i++)
		{
			for(int j=1;j<=y;j++)
			printf("%lld ",a[i][j]);
			printf("\n");
		}
	}
}q[20],p,p2;
void pre()
{
	int temp=1;
	for(int i=1;i<=18;i++)
	{
		q[i].x=3,q[i].y=1;
		q[i].a[2][1]=temp;
		temp=temp*10;
		q[i].a[3][1]=1;
	}
	p.x=p.y=p2.x=p2.y=3;
	p.a[1][1]=10;
	p.a[2][2]=p.a[1][2]=p.a[2][3]=p.a[3][3]=1;
	p2.a[1][1]=p2.a[2][2]=p2.a[3][3]=1;
}
node operator*(node a,node b)
{
	node o;
	o.empty();
	int x=a.x;
	int y=a.y;
	int z=b.y;
	for(int i=1;i<=x;i++)
	for(int j=1;j<=y;j++)
	for(int k=1;k<=z;k++)
		o.a[i][k]=(o.a[i][k]+(a.a[i][j]%m)*(b.a[j][k]%m))%m;
	o.x=x;
	o.y=z;
	return o;
}
node quickpow(node a,int b)
{
	node ans=p2,temp=a;
	while(b)
	{
		if(b&1)ans=ans*temp;
		temp=temp*temp;
		b/=2;
	}
	return ans;
}
void work(int now,int pre,int to)
{
	int vra=q[now-1].a[1][1];
	q[now].a[1][1]=vra;
	if(now==ws)
	{
		node b=quickpow(p,n-pre);
		q[now]=b*q[now];
		printf("%lld",q[now].a[1][1]);
		return;
	}
	else q[now]=quickpow(p,to-pre)*q[now];
	p.a[1][1]=p.a[1][1]*10%m;
	work(now+1,to,(to+1)*10-1);
} 
signed main()
{
	scanf("%lld%lld",&n,&m);
	pre();
	int temp=n;
	while(temp)
	{
		temp/=10;
		ws++;
	}
	work(1,0,9);
}
```

撰写不易，求通过。


---

## 作者：white_tiger_yyyy (赞：5)

感触很深，写篇题解。

轻而易举地发现 dp 式：

$$
dp_i=(dp_{i-1}\times 10^{1+\log_{10}i}\bmod p+i)\bmod p
$$

时间复杂度 $O(n)$，看来不行。

考虑矩阵快速幂优化。

有：

$$
\begin{bmatrix}dp_i\ i+1\ 1\end{bmatrix}=\begin{bmatrix}dp_{i-1}\ i\ 1\end{bmatrix}\begin{bmatrix}10^{t}\ 0\ 0\\1\ \ \ \ 1\ 0\\0\ \ \ \ 1\ 1\end{bmatrix}
$$

时间复杂度 $O(3^3\log_2n\log_{10}n)$。

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
using namespace std;
ull n,p;
struct mat{
    int x,y;
    ull z[4][4];
    mat(){
        for(int i=1;i<4;i++)
            for(int j=1;j<4;j++)
                z[i][j]=0;
    }
}a,b;
mat times(mat a,mat b){
    mat c;
    c.x=a.x;
    c.y=b.y;
    for(int i=1;i<=c.x;i++)
        for(int j=1;j<=c.y;j++)
            for(int k=1;k<=a.y;k++){
                c.z[i][j]+=a.z[i][k]*b.z[k][j]%p;
                c.z[i][j]%=p;
            }
    return c;
}mat qpow(mat a,mat b,ull x){
    while(x){
        if(x&1)
            a=times(a,b);
        b=times(b,b);
        x>>=1;
    }return a;
}int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>n>>p;
    a.x=1,a.y=b.x=b.y=3;
    a.z[1][2]=a.z[1][3]=1;
    b.z[2][1]=b.z[2][2]=1;
    b.z[3][2]=b.z[3][3]=1;
    for(ull i=1,j=1;;i++){
        j=b.z[1][1]=j*10;
        b.z[1][1]%=p;
        if(n<j){
            a=qpow(a,b,n-(j/10-1));
            break;
        }a=qpow(a,b,j-j/10);
    }cout<<a.z[1][1];
    return 0;
}
```

---

## 作者：robertuu (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P3216)

$n \leq 10^{18}$ 又是一个递推式，很容易想到矩乘加速递推。

构造出答案矩阵：

$$ \begin{bmatrix}
  ans_{i-1} \\
  i \\
  1 \\
\end{bmatrix} $$

构造出转移矩阵：

$$ \begin{bmatrix}
  10^x&1&0 \\
  0&1&1 \\
  0&0&1 \\
\end{bmatrix} $$

其中 $x$ 是这一步对应 $i$ 的数位数。

会发现 $x$ 会随着 $i$ 改变，因此不能一次快速幂解决，需要按数位进行分类，对于每一类单独构建转移矩阵，快速幂之后和之前的结果相乘，快速幂的幂次是 $\min(n-10^{x-1}+1,10^x-10^{x-1})$，也就是这一层进行转移的次数（需要注意，由于初始状态不需要进行转移，一位数的时候需要额外减 $1$）。

#### 注意！顺序很重要，需要先快速幂再去乘原来的答案！

代码：
```cpp
#include<iostream>
#include<cstring>
using namespace std;
unsigned long long n,m,p10[20];
struct matrix
{
    int a[105][105] = {};
    matrix() {memset(a,0,sizeof(a));}
    matrix operator * (const matrix b)
    {
        matrix c;
        for(int i = 1;i <= 3;i++)
        	for(int j = 1;j <= 3;j++)
        		for(int k = 1;k <= 3;k++)
        		{
        			c.a[i][j] += 1ll * a[i][k] * b.a[k][j] % m;
        			c.a[i][j] %= m;
        		}
        return c;
    }
    void output()
    {
        for(int i = 1;i <= 3;i++)
        {
        	for(int j = 1;j <= 3;j++)
        		printf("%lld ",a[i][j]);
        	printf("\n");
        }
    }
};
matrix pow(matrix x,long long b)
{
    matrix ans;
    for(int i = 1;i <= 3;i++) ans.a[i][i] = 1;
    while(b)
    {
    	if(b&1) ans = ans * x;
    	x = x * x;
    	b >>= 1;
    }
    return ans;
}
int digits(long long x)
{
	int cnt = 0;
	while(x)
	{
		cnt++;
		x /= 10;
	}
	return cnt;
}
int main()
{
	p10[0] = 1;
	for(int i = 1;i < 20;i++)
		p10[i] = p10[i-1] * 10ll;
	scanf("%lld%lld",&n,&m);
	matrix p,ans;
	for(int i = 1;i <= 3;i++) ans.a[i][i] = 1;
	for(int i = 1;i <= digits(n);i++)
	{
		p.a[1][2] = p.a[2][2] = p.a[2][3] = p.a[3][3] = 1;
		p.a[1][1] = p10[i] % m;
		if(i == 1) ans = ans * pow(p,min(n-p10[i-1],p10[i]-p10[i-1]-1));
		else ans = pow(p,min(n-p10[i-1]+1,p10[i]-p10[i-1])) * ans;
	}
	printf("%lld",(ans.a[1][1] + 2ll * ans.a[1][2] + ans.a[1][3]) % m);
	return 0;
}
```

---

## 作者：CWzwz (赞：3)

[P3216 数学作业](https://www.luogu.com.cn/problem/P3216) 题解

------------

分段计算，每一段内的数（十进制下）位数一样。

第 $k$ 段（从第 $0$ 段开始）是 $[10^k, 10^{k+1})$，本题数据范围下有 $17$ 段（$10^{18}$ 除外）。

第 $k$ 段的递推式：$\forall i \in [10^k,10^{k+1}),\ f_i = f_{i-1} \times10^{k} + i$。

枚举段数 $k$ 之后，$10^k$ 成为常量，考虑矩阵加速。

由于计算 $f_i$ 的式子中用到了 $f_{i-1}$ 和 $i$，而将 $i$ 变成 $i+1$ 又需要一个 $1$。

所以考虑全塞进矩阵：

$$
S = 
\begin{bmatrix}
f_i & i & 1
\end{bmatrix}
$$

设转移矩阵是

$$
T = 
\begin{bmatrix}
a & b & c\\
d & e & g\\
x & y & z
\end{bmatrix}
$$

则

$$
S \times T = 
\begin{bmatrix}
af_i+di+x & bf_i+ei+y & cf_i+gi+z
\end{bmatrix}
$$

而我们希望

$$
S\times T=
\begin{bmatrix}
10^kf_i+i+1 & i+1 & 1
\end{bmatrix}
$$

解得转移矩阵

$$
T=
\begin{bmatrix}
10^k & 0 & 0\ \\
1 & 1 & 0\ \\
1 & 1 & 1\ 
\end{bmatrix}
$$

特判 $n=10^{18}$ 的情况：先矩乘做到 $10^{18}-1$，然后递推一次即可。

我取模好像没取干净，所以开了 $\texttt{int128}$ 请见谅 qwq

$\texttt{lstans}$ 表示的是，上一段最后一个数是多少。

```cpp
// Problem: P3216
#include<iostream>
#include<stdio.h>
#include<string.h>
typedef __int128 ll;
#define typ ll

typ read(){typ x=0,f=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}return x*f;}
void print(typ x){if(x<0)putchar('-'),x=-x;if(x>9)print(x/10);putchar(x%10+48);}void print(typ x, char c){print(x);putchar(c);}

ll n, mod;

struct matrix {
    int n, m;
    ll mtx[4][4];
    matrix() {
        n = m = 0;
        memset(mtx, 0, sizeof mtx);
    }
};

matrix unt(int n) {
    matrix res;
    res.n = res.m = n;
    for(int i = 1; i <= n; i++) res.mtx[i][i] = 1;
    return res;
}
matrix operator * (matrix x, matrix y) {
    matrix res;
    assert(x.m == y.n);
    res.n = x.n, res.m = y.m;
    for(int i = 1; i <= res.n; i++) {
        for(int j = 1; j <= res.m; j++) {
            for(int k = 1; k <= x.m; k++) {
                res.mtx[i][j] += x.mtx[i][k] * y.mtx[k][j] % mod;
                res.mtx[i][j] %= mod;
            }
        }
    }
    return res;
}
matrix mtxpow(matrix bas, ll b) {
    matrix res = unt(bas.n);
    for(; b; b >>= 1, bas = bas * bas) if(b & 1) res = res * bas;
    return res;
}
ll qpow(ll a, ll b) {
    if(b == 0) return 1;
    ll res = 1;
    for(; b; b >>= 1, a = a * a) if(b & 1) res = res * a;
    return res;
}

int main() {
    n = read(), mod = read();
    ll lstans = 0;
    for(int k = 0; k <= 17; k++) {
        matrix s, t;
        s.n = 1, s.m = 3;
        s.mtx[1][1] = lstans % mod, s.mtx[1][2] = (qpow(10, k) - 1) % mod, s.mtx[1][3] = 1;
        t.n = t.m = 3;
        t.mtx[1][1] = qpow(10, k + 1), t.mtx[2][1] = t.mtx[2][2] = t.mtx[3][1] = t.mtx[3][2] = t.mtx[3][3] = 1;
        if(n >= qpow(10, k + 1)) {
            s = s * mtxpow(t, qpow(10, k) * 9ll);
            lstans = s.mtx[1][1];
        } else {
            print((s * mtxpow(t, n + 1 - qpow(10, k))).mtx[1][1], '\n');
            return 0;
        }
    }
    print(lstans * (((__int128)1e19) % mod) % mod, '\n'); // n = 1e18
    return 0;
}
```

---

## 作者：不存在之人 (赞：3)

## 思路：

### 其实很容易可以想到，当我们所要连接的数的位数不同的时候，我们需要把原来的数增大的倍数是不一样的。

### 所以我们需要分阶段来做矩乘。

**根据数的位数分为$1->9;10->99………10^k->10^(k+1)-1$就可以了。 **

**但是我们还需要注意一个问题，就是由于我们每个阶段快速幂的矩阵是不一样的，所以每个阶段做完以后我们都需要跟新答案，因为矩乘没有分配率！**

**这样以后我们就可以做了，矩阵是：**

![](https://img-blog.csdn.net/20150526072058040)
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long n,m,a[3][3],c[3][3],ans[3][3],aa[3],bb[3];
long long quickcheng(long long x,long long y)
{
    long long out=0;
    x=x%m;y=y%m;
    if(x>y) swap(x,y);
    while(y)
    {
        if(y&1) out=(out+x)%m;
        y>>=1;
        x=(x+x)%m;
    }
    return out;
}
void mul(long long x,long long z)
{
    long long y=z-x/10+1,i,j,k;
    bool f=true;
    if(x==10) y-=1;
    a[0][0]=x;
    a[0][1]=a[1][1]=a[1][2]=a[2][2]=1;
    a[0][2]=a[1][0]=a[2][0]=a[2][1]=0;
    while(y)
	{
        if(y&1)
		{
            if(f)
			{
                for(i=0;i<=2;++i)
                  	for(j=0;j<=2;++j)
                    	ans[i][j]=a[i][j];
                f=false;
            }
            else
			{
                for(i=0;i<=2;++i)
                  	for(j=0;j<=2;++j)
					{
                    	c[i][j]=0;
                    	for(k=0;k<=2;++k)
                      		c[i][j]=(c[i][j]+quickcheng(a[i][k],ans[k][j]))%m;
                  	}
                for(i=0;i<=2;++i)
                  	for(j=0;j<=2;++j)
                    	ans[i][j]=c[i][j];
            }
        }
        y>>=1;
        for(i=0;i<=2;++i)
          	for(j=0;j<=2;++j)
			{
            	c[i][j]=0;
            	for(k=0;k<=2;++k)
              		c[i][j]=(c[i][j]+quickcheng(a[i][k],a[k][j]))%m;
          	}
        for(i=0;i<=2;++i)
          	for(j=0;j<=2;++j)
            	a[i][j]=c[i][j];
    }
    for(i=0;i<=2;++i)
	{
        bb[i]=0;
        for(j=0;j<=2;++j)
		{
            bb[i]=(bb[i]+quickcheng(ans[i][j],aa[j]))%m;
        }
   	}
   	for(i=0;i<=2;++i)
     	aa[i]=bb[i];
}
int main()
{
    long long t=10;
    scanf("%d%d",&n,&m);
    aa[0]=1;aa[1]=2;aa[2]=1;
    while(n>=t)
	{
        mul(t,t-1);
        t*=10;
    }
    mul(t,n);
    printf("%d\n",aa[0]);
}
```
**PS：因为怕有人抄袭我做了一点点改动~QWQ~**

---

## 作者：Storm_Lightning (赞：1)

# P3216 [HNOI2011] 数学作业题解

## 思路

   读完题目，我们可以轻而易举的发现 $dp$ 式：$dp_i = ( dp_{i-1} \times 10^{1+\lfloor \log_{10}{i} \rfloor} \bmod p + 1) \bmod p$ 
   
   因为时间复杂度为 $O(n)$，所以裸的 dp 肯定不行！
   
   考虑矩阵快速幂优化！！！
   
   则会有：
    $\left[\begin{matrix}dp_i&i+1&1\end{matrix}\right]=\left[\begin{matrix}dp_{i-1}&i&1\end{matrix}\right] \times \left[\begin{matrix}10^t&0&0\\1&1&0\\0&1&1\end{matrix}\right]$
    
   注意：乘号为**矩阵快速幂**里的乘号！
    
   时间复杂度为：$ O(\log_{2}{n}) $。
   
   ```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,mod;
struct matrix
{
	int s[3][3];
	matrix operator*(matrix a)
	{
		matrix ans;
		memset(ans.s,0,sizeof ans.s);
		for(int i=0;i<3;i++)
		{
			for(int j=0;j<3;j++)
			{
				for(int k=0;k<3;k++)
				{
					ans.s[i][j]=((ans.s[i][j]+a.s[i][k]*s[k][j])%mod+mod)%mod;
				}
			}
		}
		return ans;
	}
}ans,base,k;
matrix one()
{
	matrix a;
	memset(a.s,0,sizeof a.s);
	for(int i=0;i<3;i++)a.s[i][i]=1;
	return a;
}
matrix ksm(matrix a,int b)
{
	matrix ans;
	memset(ans.s,0,sizeof ans.s);
	for(int i=0;i<3;i++)
	{
		ans.s[i][i]=1;
	}
	while(b)
	{
		if(b&1)ans=ans*a;
		a=a*a;
		b>>=1;
	}
	return ans;
}
__int128 cimi[22];
signed main()
{
	cin>>n>>mod;
	n++;
	cimi[0]=1;
	for(int i=1;i<=20;i++)
	{
		cimi[i]=cimi[i-1]*10;
	}
	memset(base.s,0,sizeof base.s);
	k.s[2][0]=1;   
	base.s[0][2]=1;
	base.s[1][2]=1;
	base.s[2][1]=-1;
	base.s[2][2]=2;
	int wzh=(int)ceil(1+log(n)/log(10.0));
	for(int i=1;i<=wzh;i++)
	{                     
		base.s[0][0]=cimi[i]%mod;
		if(n<cimi[i])
		{
			k=k*ksm(base,n-cimi[i-1]);
			cout<<k.s[0][0]<<endl;
			return 0;
		}
		k=k*ksm(base,cimi[i]-cimi[i-1]);
	}
	return 0;
}
```

---


# [SCOI2009] 迷路

## 题目背景

windy 在有向图中迷路了。

## 题目描述

该有向图有 $n$ 个节点，节点从 $1$ 至 $n$ 编号，windy 从节点 $1$ 出发，他必须恰好在 $t$ 时刻到达节点 $n$。

现在给出该有向图，你能告诉 windy 总共有多少种不同的路径吗？ 

答案对 $2009$ 取模。

注意：windy 不能在某个节点逗留，且通过某有向边的时间严格为给定的时间。




## 说明/提示

#### 样例输入输出 1 解释

路径为 $1 \to 1 \to 2$。

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 5$，$t \leq 30$。
- 对于 $100\%$ 的数据，保证 $2 \leq n \leq 10$，$1 \leq t \leq 10^9$。

## 样例 #1

### 输入

```
2 2
11
00```

### 输出

```
1

```

## 样例 #2

### 输入

```
5 30
12045
07105
47805
12024
12345
```

### 输出

```
852```

# 题解

## 作者：我好蒻呀 (赞：92)

- 首先考虑边权只有 $0,1$ 的情况。
- 令 $f_1=$给定矩阵
- 因为边权只有 $0,1$，所以我们可以将这个矩阵的意义转化成：$f_t[i][j]=k \Longleftrightarrow$ $i$到$j$的长度为$t$的路径条数为$k$。
- 显然对于 $f_1$ 这个意义成立。
- 这样问题就变得简单多了。
- 显然有 $f_t[i][j]=\sum\limits_{k=1}^nf_{t-1}[i][k]\times f_1[k][j]$。
- 即 $f_t=f_{t-1}\times f_1$。
- 矩阵乘法满足结合律，故 $f_t=f_1^t$。
- 于是这种情况下答案就是 $f_T[1][n]$。
- 再考虑边权 $w\in [0,9]\cap\mathbb Z$ 的情况。
- 因为边权可能大于1，所以给定矩阵不能直接转换成那种含义了。
- 但是我们发现 $n\le 10$。
- 这意味着我们可以~~乱搞~~将每个点都拆开，将这张图转化成边权只有 $0,1$ 的图，这样上面的意义就成立了。
- ~~经过思考，~~我们发现可以将每个点拆成 $9$ 个点，令有序数对 $(i,j)(i\in [1,n]\cap\mathbb Z,j\in [0,8]\cap\mathbb Z)$ 表示点 $i$ 拆成的第 $j$ 个点，其中第 $0$ 个点是“真”点，其余的是“假”点。
- 我们可以令 $(i,j)(j\in [1,8]\cap\mathbb Z)$ 表示到“真”点 $(i,0)$ 的距离为 $j$ 的“假”点，只要让 $(i,j)(j\in [1,8]\cap\mathbb Z)$ 向 $(i,j-1)$ 连一条边权为 $1$ 的边。
- 而对于原图中的一条 $u\to v$ 边权为 $w$ 的边，只要让 $(u,0)$ 向 $(v,w-1)$ 连一条边权为 $1$ 的边。
- 这样我们就还原了原图中的边，并且将边权都转化成了 $0,1$。
- 而每个 $(i,j)$ 又可以唯一对应一个编号 $i+j\times n$，因此原矩阵就变成了一个 $9n\times 9n$ 的矩阵 $f_1$。
- 根据前面的推理，同样 $f_t=f_1^t$。
- 答案就是 $f_T[1][n]$。
- 假设 $m=9n$，时间复杂度就是 $O(m^3\log T)$。

```cpp
#include <bits/stdc++.h>

const int MaxN = 100; 
const int mod = 2009; 

int n, m, T; 

struct mat
{
	int r, c; 
	int a[MaxN + 1][MaxN + 1]; 
	
	mat(){}
	mat(const int &_r, const int &_c):
		r(_r), c(_c) 
	{
		memset(a, 0, sizeof(a)); 
	}
	
	inline void clear()
	{
		memset(a, 0, sizeof(a)); 
		for (int i = 1; i <= r; ++i)
			a[i][i] = 1; 
	}
	
	inline mat operator * (const mat &rhs) const
	{
		mat res(r, rhs.c); 
		for (int i = 1; i <= r; ++i)
			for (int j = 1; j <= rhs.c; ++j)
			{
				for (int k = 1; k <= c; ++k)
					res.a[i][j] += a[i][k] * rhs.a[k][j]; 
				res.a[i][j] %= mod; 
			}
		return res; 
	}
	
	inline mat operator ^ (int p) const
	{
		mat res(r, c), x = *this; 
		res.clear(); 
		for (; p; p >>= 1, x = x * x)
			if (p & 1)
				res = res * x; 
		return res; 
	}
}f; 

inline int pos(const int &u, const int &i)
{
	return u + i * n; 
}

int main()
{
	scanf("%d%d", &n, &T); 
	m = n * 9; 
	
	f = mat(m, m); 
	
	int x; 
	for (int i = 1; i <= n; ++i)
	{
		for (int j = 1; j <= 8; ++j)
			f.a[pos(i, j)][pos(i, j - 1)] = 1; 
		for (int j = 1; j <= n; ++j)
		{
			scanf("%1d", &x); 
			if (x)
 				f.a[i][pos(j, x - 1)] = 1; 
		}
	}
	
	f = f ^ T; 
	printf("%d\n", f.a[1][n]); 
	
	return 0; 
}
```

---

## 作者：xiwang (赞：36)

要是所有边边权都是1那么就是求邻接矩阵的T次幂的大水题了，可惜这题不是

那么我们怎么表示这个图呢？

发现边权只有1~⑨，所以我们可以暴力把一个点拆成⑨个点并按顺序连上

然后一条边权为k的边就是从起点拆出的第k个点到终点拆出的第一个点连边

上面连的边边权全是1，于是就可以愉快地矩阵乘法水过去了

代码


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=128;
const int mo=2009;
int n,T;
struct mat{
	int a[N][N];
	void clr(){
		memset(a,0,sizeof(a));
	}
}a;
mat operator *(mat a,mat b){
	mat re;
	re.clr();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=1;k<=n;k++){
				re.a[i][j]=(re.a[i][j]+a.a[i][k]*b.a[k][j]%mo)%mo;
			}
		}
	}
	return re;
}
mat operator ^(mat a,int b){
	mat re;re.clr();
	for(int i=1;i<=n;i++)re.a[i][i]=1;
	while(b){
		if(b&1)re=re*a;
		a=a*a;
		b>>=1;
	}
	return re;
}
int main(){
	scanf("%d%d",&n,&T);
	int n1=n;
	n=n*9;
	for(int i=1;i<=n1;i++){
		for(int j=1;j<=8;j++){
			a.a[9*(i-1)+j][9*(i-1)+j+1]=1;
		}
	}
	char s[32];
	for(int i=1;i<=n1;i++){
		scanf("%s",s+1);
		for(int j=1;j<=n1;j++){
			if(s[j]>'0'){
				a.a[9*(i-1)+s[j]-'0'][9*(j-1)+1]=1;
			}
		}
	}
	a=a^T;
	printf("%d",a.a[1][n1*9-8]);
	return 0;
}
/*
5 30
12045
07105
47805
12024
12345
*/
```

---

## 作者：tommymio (赞：26)

矩阵乘法入门题。

先考虑假如边权只有 $0,1$ 的情况：

设 $f_t[i,j]$ 为从 $i$ 点到 $j$ 点，所花时间为 $t$ 的方案数。

就有 $f_t[i,j]=\sum\limits_{i=1}^n f_{t-1}[i,k]*f_1[k,j]$

仔细观察上述式子，发现这个式子还可以写成 $f_t=f_{t-1}*f_1$，故有式子 $f_t=f_1^t$。

由于所花时间为 $1$ 时，显然只能经过一条边，故 $f_1$ 的值应为初始给出的邻接矩阵。

但这道题边权为 $0-9$，我们无法直接用上述做法求解，考虑转化。

作一个类似分层图的东西，把每个点拆开，拆成 $9$ 个点，每个拆后的点用一个点对 $(i,j)$ 表示，表示点 $i$ 在第 $j$ 层。

那么我们需要重新建边：

- 若点 $x,y$ 之间存在一条边权为 $w$ 的边，那么在 $(x,0)$ 与 $(y,w-1)$ 间连一条边权为 $1$ 的边。
- 在 $(x,i)$ 与 $(x,i-1)$ 间连一条边。

为什么可以这样连呢？每个点 $x$ 只会从第 $0$ 层向外扩展，而第 $w-1$ 层的点 $y$，需要经过 $w-1$ 条边到达第 $0$ 层，并且在这个过程中它只能够从点 $y$ 的第 $m$ 层到达第 $m-1$ 层，直到到达第 $0$ 层才能够扩展向其他节点，因此答案的计数不会出现差错。

也就是说，这样做事实上是把点 $x,y$ 之间边权为 $w$ 的边拆成了 $1$ 条点 $x,y$ 边权为 $1$ 的边以及 $w-1$ 条 $y$ 节点向上一层次的边权为 $1$ 的边，正确性是可以确保的。

那么原图的邻接矩阵就被扩展成了一个 $9n*9n$ 的只有 $0,1$ 的邻接矩阵，于是直接矩阵快速幂即可。

**Show the Code** 

```cpp
#include<cstdio>
#define id(x,y) ((x-1)*9+(y))
const int mod=2009;
int n,t;
char s[105][105];
struct matrix {
	matrix operator=(matrix b) {
		for(register int i=0;i<9*n;++i) {
			for(register int j=0;j<9*n;++j) {
				this->a[i][j]=b.a[i][j];
			}
		}
		return *this;
	}
	void init() {for(register int i=0;i<9*n;++i) {for(register int j=0;j<9*n;++j) a[i][j]=0;a[i][i]=1;}}
	int a[105][105];
}pw;
matrix mul(matrix a,matrix b) {
	matrix c;
	for(register int i=0;i<9*n;++i) {
		for(register int j=0;j<9*n;++j) {
			c.a[i][j]=0;
			for(register int k=0;k<9*n;++k) {
				c.a[i][j]+=a.a[i][k]*b.a[k][j]%mod;
				c.a[i][j]%=mod;
			}
		}
	}
	return c;
}
matrix pow(matrix a,int k) {
	matrix res;
	res.init();
	for(;k;k>>=1) {
		if(k&1) res=mul(res,a);
		a=mul(a,a);
	}
	return res;
}
int main() {
	//(n-1)*9+8=9n-1; 0~9n-1;
	scanf("%d%d",&n,&t);
	//printf("%d %d\n",n,t);
	for(register int i=1;i<=n;++i) {
		scanf("%s",s[i]+1);
		for(register int j=1;j<=8;++j) pw.a[id(i,j)][id(i,j-1)]=1;
		for(register int j=1;j<=n;++j) {if(s[i][j]-'0') pw.a[id(i,0)][id(j,s[i][j]-'0'-1)]=1;}
	}
	matrix ans=pow(pw,t);
	printf("%d\n",ans.a[id(1,0)][id(n,0)]);
	return 0;
}
```

---

## 作者：杨铠远 (赞：24)

# 前两个大佬的 operator 看的我很迷   我来水一篇亲民题解
```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;
int mod=2009;
int n,t;
struct pp{
	int m[115][115];
}a;
int c;
inline pp mul(pp b,pp c)//矩阵快速幂板子 
{
	pp t;
	for(int i=1;i<=10*n;i++)
	for(int j=1;j<=10*n;j++){
		t.m[i][j]=0;
		for(int k=1;k<=10*n;k++){
			t.m[i][j]=(t.m[i][j]+(b.m[i][k]*c.m[k][j])%mod)%mod;// i行j列的值等于第一个矩阵的第一行*第二个矩阵的第j列  
		}//                                                         像向量那样乘  
	}
	return t;
}
inline int fast(int x)
{
	pp ans=a;
	pp base=a;
	while(x)
	{
		if(x&1)ans=mul(ans,base);
		base=mul(base,base);
		x=x>>1;
	}
	return ans.m[1][n];//返回1号点到n号点的方案数 
}
int main()
{
	cin>>n>>t;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=8;j++)
		a.m[i+j*n][i+(j-1)*n]=1;//建虚点 
		for(int j=1;j<=n;j++)
		{
			scanf("%1d",&c);
			a.m[i][j+n*(c-1)]=1;//连边 
			//a.m[j+n*(c-1)][i]=1;
		}
	}
	cout<<fast(t-1);//注意 要  -1  ！！！ t==1时相当于没动  
	return 0;
}
//  
```
紫题。。。慌（逃）

---

## 作者：小蒟蒻皮皮鱼 (赞：16)

## P4159 [SCOI2009] 迷路

这道题一个很奇怪的特点就是边权是以字符串的形式给的，也就是说两点之间的距离小于等于9。

不妨先考虑当路径长度都是1的情况，那么题目要求的其实就是走了$t$步到达$n$点的方案数

设$f[i][j][t]$表示从$i$到$j$恰好走了$t$步的方案数，则

$f[i][j][t] = \sum\limits_{k=1}^nf[i][k][t-1]*f[k][j][1]$

发现这不正好是矩阵乘法的公式吗。

设$t$时刻的矩阵为$f_t$，则$f_t=f_{t-1}*f_1$，也就是$f_t=f_1^t$，直接矩阵快速幂搞一下就好了，而$f_1$也就是题中所给的邻接矩阵。

回到原来的问题上，边权小于等于$9$怎么做？

有一个想法就是把一个点看成$9$个点，在这九个点之间连边。这样就把问题转化成了先前我们讨论的问题。那么接下来考虑的就是如何拆点。不妨先考虑简单的情况，两个点，边权最大为$2$。

有如下矩阵：
$$
\begin{Bmatrix}
	2&1\\
	2&0
\end{Bmatrix}
$$
画出图就是这样

![](https://cdn.luogu.com.cn/upload/image_hosting/tsas8v0k.png)

拆点后

![](https://cdn.luogu.com.cn/upload/image_hosting/x0n5rxu8.png)

这里每条边的边权都是1，其中点$1.1$和$2.1$表示实际的点，$1.2$和$2.2$表示拆出来的点。

以此类推到九个点也是一样的

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 105;
const int mod = 2009;
int n, t, sz;
struct martix
{
	int m[N][N];
}e, a;
martix cheng(martix x, martix y)
{
	martix c;
	for(int i = 1; i <= sz; i ++)
		for(int j = 1; j <= sz; j ++) c.m[i][j] = 0;
	for(int i = 1; i <= sz; i ++)
		for(int j = 1; j <= sz; j ++) 
			for(int k = 1; k <= sz; k ++)
				c.m[i][j] = (c.m[i][j] + x.m[i][k] * y.m[k][j] % mod) % mod;
	return c;
}
martix pow(martix x, int y)
{
	martix ans = e;
	while(y)
	{
		if(y & 1) ans = cheng(ans, x);
		x = cheng(x, x);
		y >>= 1;
	}
	return ans;
}
char s[N];
int main()
{
	scanf("%d%d", &n, &t);
	sz = n * 10;
	for(int i = 1; i <= sz; i ++)
		e.m[i][i] = 1;
	for(int i = 1; i <= n; i ++)
	{
		int now = (i - 1) * 10;
		for(int j = 2; j <= 9; j ++)
			a.m[j + now - 1][j + now] = 1;
	}
	for(int i = 1; i <= n; i ++)
	{
		scanf("%s", s + 1);
		int now = (i - 1) * 10;
		for(int j = 1; j <= n; j ++)
		{
			if(s[j] == '0') continue;
			int to = s[j] - '0';
			a.m[now + 9][j * 10 - to] = 1;
		}
	}
	e = pow(a, t);
	printf("%d\n", e.m[9][(n-1) * 10 + 9]);
}
```



---

## 作者：RedreamMer (赞：11)

[$\large{\texttt{P4159}}$](https://www.luogu.com.cn/problem/P4159)

题目和普通的 $01$ 路径矩阵加速有一点区别，做法很巧。

---

$\large{\texttt{Meaning}}$

给定一个邻接矩阵，即每个点之间的边权，若为 $0$ 则无边，因为是 $a*a$ 的矩阵，所以隐藏含义是每条边权 $1$~$9$ 。

---

$\large{\texttt{Solution}}$

因为边权不只是 $1$ 了，所以不能直接就将每个点连接边做矩乘，但是数据范围太大又不能不用矩乘。

注意到边权为 $1$~$9$ ，所以可以将每一个点拆成 $9$ 个点，若原先每个点为 $i$ ，则拆后的点为 $(i-1)*9+n~(1\le n\le9)$， $i$ 的主点为 $(i-1)*9+1$ ，并将点 $(i-1)*9+n$ 和 $(i-1)*9+n+1$ 连边长为 $1$ 。

然后连长度不为 $1$ 的边就很方便了，若连点 $u$ 和 $v$ 边权为 $k$ ，则连接 $(u-1)*9+k$ 和 $(v-1)*9+1$ ，这样，从 $u$ 的主点必须要走 $k-1$ 个单位，再走这条边才到的主点，且可以使用矩阵乘法+快速幂。

最后答案即为 $1$ 的主点到 $n$ 的主点的距离。

---

$\large{\texttt{Code}}$

```cpp
#include<bits/stdc++.h>
using namespace std;

// #define int long long
const int mod=2009;
const int N=10;

int a,b;
char ch;

struct node {
    int n,m,s[1010][1010];
    inline void Mem() {memset(s,0,sizeof(s));}
    inline void Re() {for(int i=1;i<=n;i++) s[i][i]=1;}
    inline void print() {for(int i=1;i<=n;i++) {for(int j=1;j<=m;j++) printf("%d ",s[i][j]); puts("");}}
    node operator*(const node b) {
        node sum;
        sum.Mem();
        sum.n=n;
        sum.m=b.m;
        for(int i=1;i<=n;i++) for(int j=1;j<=b.m;j++) {for(int k=1;k<=m;k++)  sum.s[i][j]=(sum.s[i][j]+s[i][k]*b.s[k][j]); sum.s[i][j]%=mod;}
        return sum;
    }
} S,A;

inline void Pow(int n) {//矩阵快速幂
    while(n) {
        if(n&1) S=S*A;
        A=A*A;
        n>>=1;
    }
}

signed main() {
    // freopen("in","r",stdin);
    scanf("%d%d",&a,&b);
    S.n=S.m=a*9;
    for(int i=1;i<=a;i++) for(int j=1;j<=8;j++) S.s[(i-1)*9+j][(i-1)*9+j+1]=1;
    for(int i=1;i<=a;i++) {
        getchar();//防止scanf读入偏差
        for(int j=1;j<=a;j++) {
            scanf("%c",&ch);
            if(ch!='0') S.s[(i-1)*9+ch-'0'][(j-1)*9+1]=1;
        }
    }
    A=S;
    Pow(b-1);
    //S.print();
    printf("%d",S.s[1][(a-1)*9+1]);
    return 0;
}
```

[$\blue{\large{\texttt{My Blog}}}$](https://www.luogu.com.cn/blog/184549/)

---

## 作者：eee_hoho (赞：8)

其实这道题我们可以不从拆点的角度考虑

根据题意，可以写出转移方程

$$f_{i,j}=\sum f_{r,j-w[r]}$$

$f_{i,j}$表示第$j$时刻在第$i$个点时的方案数，$r$为$i$的前驱，$w[r]$为距离

而$T\le 10^9$，所以肯定是不可行的，就要用到**矩阵加速**

如果对于上面那个转移方程是无法矩阵加速的

但是边权只有$1…9$，我们可以把$j$分开表示，也就是把所有距离的情况都表示出来

那么对于上面的那个转移方程就有两种转移形式

- 这个距离$j$不是真正的距离，那么$f_{r,j}$可以从$f_{r,j-1}$继承

- 这个$j$是真正的距离，那么$f_{r,j}$对$f_{i,j}$是有贡献的

这就是不拆点的思路了，虽然代码和拆点是一样的，但这个思路可能会~~更清晰点~~

**Code**
``` cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int n,t,d[500][500],s[500][500],b[500][500],p=2009;
char ch;
void jzc(int x[500][500],int y[500][500])
{
	for (int i=1;i<=n*9;i++)
		for (int j=1;j<=n*9;j++)
			for (int k=1;k<=n*9;k++)
				b[i][j]=(b[i][j]+x[i][k]*y[k][j]%p)%p;
	for (int i=1;i<=n*9;i++)
		for (int j=1;j<=n*9;j++)
			x[i][j]=b[i][j],b[i][j]=0;
}
int main()
{
	cin>>n>>t;
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=8;j++)     //第一个的继承关系
			d[i+j*n][i+(j-1)*n]=1;
		for (int j=1;j<=n;j++)
		{
			cin>>ch;
			d[i][j+n*((ch-'0')-1)]=1;   //真正的边
		}
	}
	for (int i=1;i<=n*9;i++)
		s[i][i]=1;
	while (t)
	{
		if (t&1)jzc(s,d);
		jzc(d,d);
		t>>=1;
	}
	cout<<s[1][n]<<endl;
	return 0;
}
```

---

## 作者：Schwarzkopf_Henkal (赞：6)

看一眼题，在某一时刻到达第n个点，一眼就是个DP题，定义状态$dp_{i,j}$是在第$j$时刻到达$i$点的方法数。

看一眼数据范围，$t\leq 10^9$，这样就是叉掉了几乎所有的DP做法。

但是额外地，我们发现n极小，并且路径长度也小的诡异。学过矩阵加速递推的大概现在已经起反应了，既然这样，影响下一个状态的就只剩下距今时间小于等于9的那部分了。也就是，如果我们确定要使用矩阵加速递推，那么剩下的就非常*显然*。

例如当n=3，路径最大长度是3的时候，定义$a_{i,j}$是经过$i$时间到达$j$的方法数（求求了，再大手就会打废掉的）：

$$\begin{bmatrix}1&2&3\\3&2&1\\1&3&1\end{bmatrix}$$
$$\Downarrow$$
$$\begin{bmatrix}0&0&0&1&0&0&0&0&0\\0&0&0&0&1&0&0&0&0\\0&0&0&0&0&1&0&0&0\\0&0&0&0&0&0&1&0&0\\0&0&0&0&0&0&0&1&0\\0&0&0&0&0&0&0&0&1\\0&1&0&0&0&0&1&0&1\\0&0&1&1&1&0&0&0&0\\1&0&0&0&0&1&0&0&1\\\end{bmatrix}\begin{bmatrix}a_{1,1}\\a_{1,2}\\a_{1,3}\\a_{2,1}\\a_{2,2}\\a_{2,3}\\a_{3,1}\\a_{3,2}\\a_{3,3}\\\end{bmatrix}=\begin{bmatrix}a_{2,1}\\a_{2,2}\\a_{2,3}\\a_{3,1}\\a_{3,2}\\a_{3,3}\\a_{4,1}\\a_{4,2}\\a_{4,3}\\\end{bmatrix}$$

很容易发现前几个都特别地有规律啊，毕竟只需要继承之前推出的结果就行了。只有最后三排，我们需要根据邻接矩阵来填上0或1。易于发现，扫描某一列，如果距离是三就在前面三个找出来，变成1。最后，利用矩阵快速幂，我们可以随随便便就发现答案。

注意，因为保存状态只能用一维的矩阵（貌似二维也是可以的，~~但是并不知道立方体乘法怎么做~~）所以必须把状态堆叠起来，这样打着有些别扭，但是莫得办法。在快速幂之后，就是乘上初始的状态矩阵，由于只有一个一，找一下输出就好了。参考代码qwq

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Mod=2009;
int t,n,a[15][15],mx;
struct node{
    int a[105][105];
    void clear(){
        memset(a,0,sizeof(a));
    }
    friend node operator*(node x,node y){
        node z;
        z.clear();
        for(int i=1;i<=10*n;i++)
            for(int j=1;j<=10*n;j++)
                for(int k=1;k<=10*n;k++)
                    z.a[i][j]=(z.a[i][j]+x.a[i][k]*y.a[k][j])%Mod;
        return z;
    }
}x,E;
int main(){
    x.clear();
    E.clear();
    cin>>n>>t;
    mx=n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            char inp;
            cin>>inp;
            a[i][j]=inp-'0';
        }
    for(int i=1;i<=9*n;i++)
        x.a[i][i+n]=1;
    for(int i=1;i<=10*n;i++)
        E.a[i][i]=1;
    for(int i=9*n+1;i<=10*n;i++){
        int p=i-9*n;
        for(int j=1;j<=n;j++)
            if(a[j][p])
                x.a[i][(10-a[j][p])*n+j]=1;
    }
    while(t){
        if(t%2)
            E=E*x;
        t/=2;
        x=x*x;
    }
    // for(int i=1;i<=10*mx;i++){
    //     for(int j=1;j<=10*mx;j++)
    //         cout<<E.a[i][j]<<" ";
    //     cout<<'\n';
    // }
    cout<<E.a[10*n][n*9+1];
}
```

---

## 作者：徐致远 (赞：3)

[蒟蒻我的Blog](https://www.chnxuzhiyuan.cn/2019/06/01/%E3%80%8CSCOI2009%E3%80%8D%E8%BF%B7%E8%B7%AF-Solution/)

### 题解

先来考虑如果边权全都为$1$怎么处理。

设$G[i][j][k]$表示从$i$走到$j$，步数恰好为$k$的方案数。

不难推出转移方程：
$$
G[i][j][k]=\sum_{t=1}^{n}G[i][t][k-1]*G[t][j][1]
$$
而这正是一个矩阵乘法的式子。

令转移矩阵为$F$，其中$F[i][j]$表示从$i$一步走到$j$的方案数。如果$i,j$之间有边则$F[i][j]=1$，否则$F[i][j]=0$。

所以有答案矩阵$G_T=F^T$，矩阵快速幂即可。

还有就是由于原题中边权不一定为$1$，但是小于等于$9$。

所以可以暴力拆点，把每个点拆成$9$个点，然后就可以把所有边的边权转化为$1$了。

时间复杂度$O((9n)^3\log T)$。

### 代码

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=100,TT=2009;
int n,T;
int GetC()
{
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	return ch-'0';
}
struct Matrix
{
	int n,m,a[maxn][maxn];
	Matrix(){n=m=0;memset(a,0,sizeof(a));}
	Matrix operator * (const Matrix& b)
	{
		Matrix c;
		c.n=n;c.m=b.m;
		for(int i=1;i<=c.n;i++)
			for(int j=1;j<=c.m;j++)
				for(int k=1;k<=m;k++)
					c.a[i][j]=(c.a[i][j]+a[i][k]*b.a[k][j])%TT;
		return c;
	}
}F,G;
Matrix QP(Matrix a,int b)
{
	Matrix ret=a,w=a;b--;
	while(b)
	{
		if(b&1) ret=ret*w;
		w=w*w;b>>=1;
	}
	return ret;
}
int main()
{
	scanf("%d%d",&n,&T);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			int C=GetC();
			if(C!=0) F.a[(i-1)*9+1][(j-1)*9+C]=1;
		}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<9;j++)
			F.a[(i-1)*9+j+1][(i-1)*9+j]=1;
	F.n=F.m=n*9;
	G=QP(F,T);
	printf("%d\n",G.a[1][(n-1)*9+1]);
	return 0;
}
```

---

## 作者：天命之路 (赞：2)

首先，遇到这种计数类的题目，考虑两个东西:**搜索或递推**

$1\le t\le10^9$,搜索不可能，考虑递推。

设$f_{i,j,k}$ 表示从点$i$ 经过$k$ 个单位的时间到达点$j$ 的方案数，则很容易的可以列出转移方程：
$$\large f_{i,j,k}=\sum\limits_{(v,j,w)\in \mathbf{E}}f_{i,v,k-w}$$

其中,$(v,j,w)$ 表示一条从$v$ 到$j$ ,权值为$w$ 的边，E 表示原图边集

如果$k$ 不大的话，你完全可以用记忆化搜索来转移，挺好的。

但是$k$ 很大。

我们先从弱化版的$w=1$ 的情况考虑，这时可以用矩阵快速幂求解，令邻接矩阵为$G$($G(i,j)=1$ 表示 $i,j$ 有边),则$F[k]=F[k-1]*G$(k的意义同上方转移方程)

但是边权是$w$,注意$w$ 在$1-9$ 之间，故可以考虑将其拆成$w$ 条权为$1$ 的边，中间用中转点。

但是点的规模为$n+9m\le910$，会超的。


考虑把拆边改为拆点，即将$(u,v,w)$ 看做“从$u$ 去到$v$ ，并在$v$停留了$w-1$ 个单位时间(路上要花费1个单位时间）”，这样，设$u_i$ 为在结点$u$停留$u$ 停留$i$ 天所对应的点，则$(u,v,w)$ 变为 $(u,v_{w-1},1)$



注意，$u_{i-1}$ 和 $u_i$ 之间也要连边。

矩阵快速幂不多讲.

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=101,mod=2009,Node=11;
struct matrix{
	int a[N][N],r,c;
	inline void init()
	{
		for(int i=1;i<=r;i++)
		for(int j=1;j<=c;j++)
		a[i][j]=(i==j);
	}
	matrix(){ memset(a,r=c=0,sizeof a);}
	matrix operator *(const matrix &rhs) 
	{
		matrix res;
		res.r=this->r;res.c=rhs.c;
		assert(c==rhs.r);  //检验矩阵乘法的合法性，错误时会弹出错误信息并终止程序
		for(int i=1;i<=r;i++)
		for(int k=1;k<=c;k++)
		for(int j=1;j<=rhs.c;j++)
		(res.a[i][j]+=this->a[i][k]*rhs.a[k][j])%=mod;
		return res;
	}
	matrix operator ^( int p)
	{
		matrix res,tmp=*this;
		res.r=res.c=this->r;
		res.init();
		while(p)
		{
			if(p&1) res=res*tmp;
			tmp=tmp*tmp;
			p>>=1;
		}
		return res;
	}
	int *operator [](const int p)  { return a[p];}
}A;
int n,t,id[Node][Node],cnt=0;
char s[Node][Node];
int main()
{
	scanf("%d%d",&n,&t);
	for(int i=1;i<=n;i++) cin>>(s[i]+1);

	for(int j=0;j<=9;j++) 
	for(int i=1;i<=n;i++)
	id[i][j]=++cnt;
		A.r=A.c=cnt;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	{
		int w=s[i][j]-'0';
		if(!w) continue;
	//	printf("%d,%d,%d\n",i,j,w);
		for(int k=1;k<w;k++) A[id[i][k-1]][id[i][k]]=1;   //u_i-1和u_i间的边
		A[id[i][w-1]][j]=1;    //(u,v_w-1,1)
	}
	cout<<(A^t)[1][n];
}

```

---

## 作者：cszhpdx (赞：1)

题目传送门 [P4159 \[SCOI2009\] 迷路](https://www.luogu.com.cn/problem/P4159)

1. 如果完全没有思路请移步至 [P2233 [HNOI2002]公交车路线](https://www.luogu.com.cn/problem/P2233)
2. 如果没学过矩阵乘法可以去

[P1939【模板】矩阵加速（数列）](https://www.luogu.com.cn/problem/P1939)

[P3390 【模板】矩阵快速幂](https://www.luogu.com.cn/problem/P3390)

看看这两题的题解

要是不会快速幂请去 [P1226 【模板】快速幂||取余运算](https://www.luogu.com.cn/problem/P1226)

3. 然后我们通过 P2233 知道了，对于一个邻接矩阵为 $G$ 的，边权只有 0 1 的图，从 $i$ 走到 $j$ 恰好走 $T$ 个单位的方案数是 $G^T_{ij}$，那么考虑把这道题转换成边权为 0 1 的形式

4. 通过深思熟虑，我们发现其实我们可以把每一条边拆开，比如把一个边权为 9 的边拆成 9 段，每一段边权都是 1 ，就转化成了边权只有 0 和 1 的图，然后我们惊喜的发现，边权最大也就是 9 ，所以每条边最多拆成 9 段，所以每个点最多拆成 9 个点，而且 $n \le 10$ ，所以拆完之后最多 90 个点，所以最后算法的复杂度就是 $O((9n)^3 \log_2T)$ 绝对能过

最后献上代码：
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int NR=15, XR=110, MOD=2009;
int n, t, tmp;
#define ps(x, y) ((x)+(y)*n)
//为每一个点编号，参见一楼题解
struct mat
{//矩阵乘法模板
	int n, m, a[XR][XR];
	mat(){n=m=0, memset(a, 0, sizeof(a));}
	mat operator*(const mat &b)const
	{
		mat c;
		if(m!=b.n)return c;
		c.n=n, c.m=b.m;
		for(int k=1;k<=m;k++)
			for(int i=1;i<=n;i++)
				for(int j=1;j<=b.m;j++)
					c.a[i][j]=(c.a[i][j]+a[i][k]*b.a[k][j])%MOD;
		return c;
	}
	mat operator*=(const mat &b)
	{
		return *this=*this*b;
	}
	void I()
	{
		if(n!=m)return;
		for(int i=1;i<=n;i++)
			a[i][i]=1;
	}
	mat operator^(int p)const
	{
		mat a=*this, res;
		res.n=a.n, res.m=a.m;
		res.I();
		while(p)
		{
			if(p&1)res*=a;
			a*=a, p>>=1;
		}
		return res;
	}
	mat operator^=(const int p)
	{
		return *this=*this^p;
	}
}a;
int main()
{
	scanf("%d%d", &n, &t);
	a.n=a.m=9*n;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=8;j++)
			a.a[ps(i, j)][ps(i, j-1)]=1;
		for(int j=1;j<=n;j++)
		{
			scanf("%1d", &tmp);
			if(tmp)a.a[i][ps(j, tmp-1)]=1;
		}
	}
	printf("%d", (a^t).a[1][n]);
	return 0;
}
```

---


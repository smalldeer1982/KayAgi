# 异位坍缩

## 题目背景

>自然的法则隐藏在黑暗之中。

月光之下，菲欧娜和一群与她有着同样信仰的信徒们聚集在一起，等待着他们所信仰的神明降临。

「神明大人，我们愿意永远追随您。」

## 题目描述

神明想要测试他的信徒们是否忠诚，他决定用运气来进行测试。

神明事先准备了 $n$ 个问题，每个问题都有两种选择：**「相对激进的」** 和 **「相对保守的」**。神明已经定好了自己的选择。

为了考验他的信徒们，神明会在所有可行的问题选择方式中**等概率选出一种**（可行的选择方式指选出**连续的** $k$ 个问题，满足 $l\leq k\leq r$，其中 $l,r$ 给定），然后信徒们会依次对这 $k$ 个问题中的每个问题回答「相对激进的」或「相对保守的」。神明会根据自己的选择以及某个信徒的回答来判定这名信徒是否忠诚。

神明的判定方式是这样的：

+ 这是第一个问题：无论回答如何，神明都愿意相信这名信徒是忠诚的。
+ 这不是第一个问题：如果这名信徒的上一个回答与神明的选择相同，那么神明会需要他去对更先进的选择进行探索，因此这名信徒在这个问题的回答**不能比神明的选择更保守**；否则，神明会要求这名信徒服从于自己，在这个问题的回答**不能比神明的选择更激进**。

如果这名信徒的回答满足上述要求，那么这名信徒就是忠诚的。

现在，神明想要知道，如果信徒对每个问题都会**等概率回答「相对激进的」或「相对保守的」**，那么一名信徒有多大的概率会是忠诚的。他通过菲欧娜向你提出了这个问题，并要求你将结果对 $998244353$ 取模。如果你无法及时回答出，那么你就会失去神明的信任。

------------

#### 简要题意：

给定一个长度为 $n$ 的 01 串 $a$ 以及 $l,r(l\leq r)$。

对于两个长度均为 $k$ 的 01 串 $p,q$，我们认为 $q$ 对于 $p$ 是「忠诚的」，当且仅当 $p$ 和 $q$ 满足如下要求：

+ 对于任意 $1<i\leq k$，如果 $q_{i-1}=p_{i-1}$，那么 $q_i\geq p_i$，否则 $q_i\leq p_i$。

你需要求出如果**先等概率随机选出一个长度 $k$ 满足 $l\leq k\leq r$ 的 $a$ 的子串**，然后**再等概率随机出一个长度为 $k$ 的 01 串 $b$**，有多大的概率使得 $b$ 对于这个子串是「忠诚的」，结果对 $998244353$ 取模。

## 说明/提示

#### 样例一解释：

我们用 $\left[l,r\right]$ 表示所选择的子串所在区间。

+ 选择 $\left[1,2\right]$，子串为 `01`，长度为 $2$，有 $3$ 个 01 串对这个子串是「忠诚的」，概率为 $\dfrac{3}{4}$。
+ 选择 $\left[1,3\right]$，子串为 `011`，长度为 $3$，有 $4$ 个 01 串对这个子串是「忠诚的」，概率为 $\dfrac{1}{2}$。
+ 选择 $\left[2,3\right]$，概率为 $\dfrac{3}{4}$。

+ 选择 $\left[2,4\right]$，概率为 $\dfrac{5}{8}$。
+ 选择 $\left[3,4\right]$，概率为 $\dfrac{3}{4}$。
+ 选择 $\left[3,5\right]$，概率为 $\dfrac{1}{2}$。
+ 选择 $\left[4,5\right]$，概率为 $\dfrac{3}{4}$。

结果为 $\dfrac{\dfrac{3}{4}+\dfrac{1}{2}+\dfrac{3}{4}+\dfrac{5}{8}+\dfrac{3}{4}+\dfrac{1}{2}+\dfrac{3}{4}}{7}=\dfrac{37}{56}$，取模意义下为 $338690049$。

------------

**本题采用捆绑测试**

+ Subtask 1 ( $1\%$ )：$n=1$。
+ Subtask 2 ( $13\%$ )：$n\leq100$。
+ Subtask 3 ( $3\%$ )：保证 $\forall1\leq i\leq n,a_i=0$。
+ Subtask 4 ( $3\%$ )：保证 $\forall1\leq i\leq n,a_i=1$。
+ Subtask 5 ( $20\%$ )：$n\leq10^3$。
+ Subtask 6 ( $15\%$ )：$l=r$。
+ Subtask 7 ( $20\%$ )：$n\leq 5\times 10^5$。
+ Subtask 8 ( $25\%$ )：无特殊限制。

对于所有数据，$1\leq n\leq5\times 10^6,1\leq l\leq r\leq n$。

## 样例 #1

### 输入

```
5 2 3
01101
```

### 输出

```
338690049```

## 样例 #2

### 输入

```
17 4 13
10101110100101101
```

### 输出

```
512357021```

# 题解

## 作者：littleKtian (赞：2)

样例解释已经很明显告诉你先计算所有选择子串方案的概率和再除掉方案数了。

先考虑去掉 $l$ 和 $r$ 的限制的情况下如何计算。

设 $f_{i,0/1}$ 表示**所有**以 $i$ 为结尾的子串，选择相应的 $b$，满足 $b$ 对于相应子串是「忠诚的」，且 $b$ 的**结尾**与相应子串**相同**/**不同**的**概率和**。

有递推式 $\begin{cases}f_{i,0}=\dfrac{1}{2}(f_{i-1,0}+f_{i-1,1}+1),f_{i,1}=\dfrac{1}{2}(f_{i-1,0}+1)&a_i=0\\f_{i,0}=\dfrac{1}{2}(f_{i-1,0}+f_{i-1,1}+1),f_{i,1}=\dfrac{1}{2}(f_{i-1,1}+1)&a_i=1\end{cases}$。

或者写成 $f_{i,0}=\dfrac{1}{2}(f_{i-1,0}+f_{i-1,1})+\dfrac{1}{2},f_{i,1}=\dfrac{1}{2}(f_{i-1,a_i})+\dfrac{1}{2}$。

特别的，$f_{0,0}=f_{0,1}=0$。

观察如何给这个式子加上 $l$ 和 $r$ 的限制。

注意到式子中的 $+\dfrac{1}{2}$ 其实就类似于 $l=1$ 时产生的限制，这提示我们可以在 dp 时保留保留式子其他部分，将 $+\dfrac{1}{2}$ 根据 $l$ 的限制进行更换，同时再根据 $r$ 的限制再在原式中减去一部分。

因此我们修改 $f$ 的定义。设 $f_{i,0/1}$ 表示**所有**以 $i$ 为结尾的**且长度在 $l$ 到 $r$ 之间的子串**，选择相应的 $b$，满足 $b$ 对于相应子串是「忠诚的」，且 $b$ 的**结尾**与相应子串**相同**/**不同**的**概率和**，另外设 $fl_{i,0/1},fr_{i,0/1}$ 分别表示**以 $i$ 为结尾的长度为 $l$ /为 $r+1$ 的子串**，有**多少个 01 串** $b$ 使得 $b$ **对其是「忠诚的」**，且$b$ 的**结尾**与其**相同**/**不同**（如果 $i< l$ / $i< r+1$，那么 $fl_{i,0}=fl_{i,1}=0$ / $fr_{i,0}=fr_{i,1}=0$）。

于是有 $f_{i,0}=\dfrac{1}{2}(f_{i-1,0}+f_{i-1,1})+\dfrac{fl_{i,0}}{2^l}-\dfrac{fr_{i,0}}{2^{r+1}},f_{i,1}=\dfrac{1}{2}(f_{i-1,a_i})+\dfrac{fl_{i,1}}{2^l}-\dfrac{fr_{i,1}}{2^{r+1}}$。

现在的问题是如何计算 $fl$ 和 $fr$。

（因为两者计算方法基本相同所以下面只讲一个）

假设我们现在要计算一个串有多少个串 $b$ 对其是「忠诚的」，设 $g_{i,0/1}$ 表示到第 $i$ 个位置为止有多少个串对其是「忠诚的」。

有递推式 $g_{i,0}=g_{i-1,0}+g_{i-1,1},g_{i,1}=g_{i-1,a_i}$。特别的，$g_{1,0}=g_{1,1}=1$。

把递推式写成矩阵的形式，有：

$\begin{cases}\begin{bmatrix}g_{i-1,0}&g_{i-1,1}\end{bmatrix}\begin{bmatrix}1&1\\1&0\end{bmatrix}=\begin{bmatrix}g_{i,0}&g_{i,1}\end{bmatrix}&a_i=0\\\begin{bmatrix}g_{i-1,0}&g_{i-1,1}\end{bmatrix}\begin{bmatrix}1&0\\1&1\end{bmatrix}=\begin{bmatrix}g_{i,0}&g_{i,1}\end{bmatrix}&a_i=1\end{cases}$

因为两种情况使用的矩阵不同，我们不能直接进行矩阵快速幂。但我们发现在计算时用的都是一连串的矩阵，，并且头部和尾部都往一个方向移动。所以我们可以在计算时直接在尾部乘上一个新的矩阵，并在头部乘上一个逆矩阵，这样每次只需要做两次矩阵乘法就能直接得到新的用于计算的矩阵。从而计算出 $fl$ 和 $fr$。

上面两个矩阵的逆矩阵分别为 $\begin{bmatrix}0&1\\1&-1\end{bmatrix}$ 和 $\begin{bmatrix}1&0\\-1&1\end{bmatrix}$。

时间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
#define p 998244353
using namespace std;
struct jx{
	int a[2][2];
};
jx operator *(const jx &x,const jx &y)
{
	jx z;
	z.a[0][0]=(1ll*x.a[0][0]*y.a[0][0]+1ll*x.a[0][1]*y.a[1][0])%p;
	z.a[1][0]=(1ll*x.a[1][0]*y.a[0][0]+1ll*x.a[1][1]*y.a[1][0])%p;
	z.a[0][1]=(1ll*x.a[0][0]*y.a[0][1]+1ll*x.a[0][1]*y.a[1][1])%p;
	z.a[1][1]=(1ll*x.a[1][0]*y.a[0][1]+1ll*x.a[1][1]*y.a[1][1])%p;
	return z;
}
jx A[2],B[2],aa;
int n,l,r,a[5000005],fl[2][5000005],fr[2][5000005],f[2][5000005],ans,cho,pl,pr,p2;
int P(int x,int y=p-2)
{
	int z=1;
	for(;y;x=1ll*x*x%p,y>>=1)if(y&1)z=1ll*z*x%p;
	return z;
}
int main()
{
	A[0].a[0][0]=A[0].a[0][1]=A[0].a[1][0]=1,B[0].a[0][1]=B[0].a[1][0]=1,B[0].a[1][1]=p-1;
	A[1].a[0][0]=A[1].a[1][0]=A[1].a[1][1]=1,B[1].a[0][0]=B[1].a[1][1]=1,B[1].a[1][0]=p-1;
	scanf("%d%d%d",&n,&l,&r);
	pl=P(P(2,l)),pr=P(P(2,r+1)),cho=P((1ll*(n*2-l-r+2)*(r-l+1)/2)%p),p2=P(2);
	for(int i=1;i<=n;i++)
	{
		char ch=getchar();
		while(ch!='0'&&ch!='1')ch=getchar();
		a[i]=ch-'0';
	}
	aa.a[0][0]=aa.a[1][1]=1,aa.a[0][1]=aa.a[1][0]=0;
	for(int i=1;i<l;i++)aa=aa*A[a[i]];
	for(int i=l;i<=n;i++)
	{
		aa=B[a[i-l+1]]*aa*A[a[i]];
		fl[0][i]=(aa.a[0][0]+aa.a[1][0])%p,fl[1][i]=(aa.a[0][1]+aa.a[1][1])%p;
	}
	aa.a[0][0]=aa.a[1][1]=1,aa.a[0][1]=aa.a[1][0]=0;
	for(int i=1;i<=r;i++)aa=aa*A[a[i]];
	for(int i=r+1;i<=n;i++)
	{
		aa=B[a[i-r]]*aa*A[a[i]];
		fr[0][i]=(aa.a[0][0]+aa.a[1][0])%p,fr[1][i]=(aa.a[0][1]+aa.a[1][1])%p;
	}
	for(int i=1;i<=n;i++)f[0][i]=((1ll*p2*(f[0][i-1]+f[1][i-1])+1ll*pl*fl[0][i]-1ll*pr*fr[0][i])%p+p)%p,f[1][i]=((1ll*p2*f[a[i]][i-1]+1ll*pl*fl[1][i]-1ll*pr*fr[1][i])%p+p)%p;
	for(int i=1;i<=n;i++)ans=(ans+(f[0][i]+f[1][i])%p)%p;
	printf("%lld",1ll*ans*cho%p);
}
```

---

## 作者：popossible (赞：1)

题意不再赘述，我们探究一下两个串 $a,b$ 在何时 $b$ 对 $a$ 是忠诚的。

考虑令 $A,B$ 表示 $a,b$ 的整数序列，即若 $a="00011110",A=\{ 0,0,0,1,1,1,1,0 \}$。考虑使 $C=A-B$，逐位相减，通过观察可以发现 $C$ 数列的性质，

+ $C$ 中的数一定是一段 $0$ 与一段 $-1,1,1,\dots$ 或 $1,1,1,\dots$ 交替出现，即有如下例子 $0,0,-1,1,1,1,0,0,0,0,-1,1,1$。
+ $1,1,1,\dots$ 出现当且仅当 $A$ 第一个数为 $1$ ，$B$ 第一个数为 $0$，且仅可能出现一次，即开头。 
+ $A$ 中 $0$ 的位置或者作为 $-1,1,1,\dots$ 的开头，或者作为 $0$ 出现。
+ $A$ 中 $1$ 的位置或者作为 $1,1,1,\dots$ 的开头，或者作为 $-1/1,1,1,\dots$ 开头之后的 $1$，或者作为 $0$ 出现。

于是将该问题转化为序列计数，具体地，设 $f_{i,0/1}$ 表示目前进行到第 $i$ 个数，是否开启一段 $-1/1,1,1,\dots$，$0$ 表示没有，$1$ 表示开启，于是列出以下转移，
$$
A[i]=0,
\begin{cases} 

f_{i,0}=f_{i-1,0}+f_{i-1,1} \\
f_{i,1}=f_{i-1,0}

\end{cases} \\
A[i]=1,
\begin{cases} 

f_{i,0}=f_{i-1,0}+f_{i-1,1} \\
f_{i,1}=f_{i-1,1}

\end{cases} \\
$$
边界值为 $f_{1,0}=f_{1,1}=1$，因为无论 $0$ 或是 $1$ 开头，均可开启一段 $0$ 或 一段 $-1/1,1,1,\dots$ 。

对于每个合法位置，$f_{i,0},f_{i,1}$ 均会被统计入答案。

考虑列出矩阵优化转移，即有，
$$
A[i]=0,
\begin{bmatrix} 
1,1 \\
1,0
\end{bmatrix} [f_{i-1,0},f_{i,1}]=[f_{i,0},f_{i,1}]
\\
A[i]=1,
\begin{bmatrix} 
1,1 \\
0,1
\end{bmatrix} [f_{i-1,0},f_{i,1}]=[f_{i,0},f_{i,1}]
$$
即可用扫描线，每次新拓展一个位置，并对一段矩阵乘当前位对应的转移矩阵，设单次矩阵乘的时间为 $t$，即可做到 $O(t\times n\log n)$，此题中 $t=8$。

由矩阵乘法对加法有分配律，我们可以对矩阵求前缀和，累乘转移矩阵，每次对于 $[L, R]$ 的一段矩阵，乘上转移矩阵，累加答案。

对于多乘了一些转移矩阵的问题，我们考虑引进它的逆矩阵，对于每个位置上的节点，我们记录一个 $inv$ 表示 $[1,i]$ 位置的按顺序的转移矩阵的逆矩阵，每次**右乘**下一个位置的转移矩阵的逆矩阵，$tag$ 表示 $[1,i]$ 位置的按顺序的转移矩阵，每次**左乘**下一个位置的转移矩阵。在处理前缀和时，先处理出 $inv$，对当前位置的初始矩阵**左乘** $inv$ 后，累加前缀和。处理新的答案时，对于差分出的 $f[L,R]$，**左乘** $tag$ 即可避免此问题。可以参照下图考虑，

![](https://cdn.luogu.com.cn/upload/image_hosting/jdc7wxus.png)

$s$ 表是转移矩阵，$s^{-1}$ 表示逆矩阵。

关于本题，要计算概率，可以发现，每拓展一个位置，总的 01 串数量乘 $2$，于是对于转移矩阵，数乘 $\frac{1}{2}$ 即可。时间复杂度为 $O(t\times n)$。

最后的转移矩阵与其逆矩阵以及初始矩阵请读者自行推导。

### code

```cpp
Matrix f[M],tag,inv,tmp;
signed main(){
	tag={1,0,0,1};
	inv={1,0,0,1};
	
	cin>>n>>l>>r;
	for(int i=1;i<=n;i++) {
		(tot+=min(i+r-1,n)-min(i+l-1,n+1)+1)%=mod; //统计有多少神可以选择的串 
		char x;cin>>x;
		int L=max(1ll,i-r+1),R=max(0ll,i-l+1); //获得在当前位置有贡献的串的区间 
		tag=(x=='0'?Zero:One)*tag; //左乘转移矩阵 
		inv=inv*(x=='0'?Zero_inv:One_inv); //右乘逆矩阵 
		f[i].num[0][0]=f[i].num[1][0]=inv_2; //初始矩阵
		f[i]=inv*f[i]; //左乘逆矩阵 
		f[i]=f[i]+f[i-1]; //前缀和 
		tmp=tag*(f[R]-f[L-1]); //左乘转移矩阵 
		(ans+=(tmp.num[0][0]+tmp.num[1][0]))%=mod; //统计答案 
	}
	cout<<ans*expow(tot,mod-2)%mod; 

	return 0;
}
```

---


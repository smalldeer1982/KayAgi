# [COCI 2009/2010 #6] GREMLINI

## 题目描述

有 $n$ 种小妖精，我们给这 $n$ 类小妖分别编号为 $1,\dots,n$。

$t$ 年前，一次事故造出了 $n$ 只小妖（视为刚出生的，而非成熟的），这些小妖的种类互不相同。

第 $i$ 种小妖出生后需要 $y_i$ 年成熟，成熟后会立即产下 $k_i$ 个蛋（小妖是无性繁殖的生物）然后死亡。将它的蛋编号为 $1.\dots,k$，其中，第 $j$ 个蛋需要 $h_{i,j}$ 年孵化，孵出的小妖的类型为 $g _ {i, j}$。

请问，现在和祖先关系最远的小妖到了多少代，不考虑暂未孵出的。假设祖先是 $1$ 代，其子辈为第 $2$ 代，孙辈为第 $3$ 代，以此类推。

## 说明/提示

**【样例 #2 解释】**

事故发生 $10$ 年后，最开始的那只小妖（$1$ 代）产下了一个蛋，然后死亡。事故发生 $15$ 年后，蛋孵化出了新的一只小妖（$2$ 代）。事故发生 $25$ 年后，$2$ 代小妖产下了一个蛋，然后死亡。事故发生 $30$ 年后，蛋孵化出了新的一只小妖（$3$ 代）。事故发生 $40$ 年后，$3$ 代小妖产下了一个蛋，然后死亡。事故发生 $42$ 年后，这个蛋仍未孵化，因此不计。

**【数据范围】**

$1 \le n \le 100,1 \le t \le 10^{15},1 \le k_i, y_i, h_{i,j} \le 1000,1 \le g_{i,j} \le n$。

本题分值按 COCI 原题设置，满分 $130$。

## 样例 #1

### 输入

```
1 42
1 10
1
5```

### 输出

```
2```

## 样例 #2

### 输入

```
2 42
1 10
1
5
1 5
1
5```

### 输出

```
3```

## 样例 #3

### 输入

```
3 8
4 5
1 2 3 2
1 2 1 3
1 1
3
1
2 1
1 2
2 1```

### 输出

```
4```

# 题解

## 作者：ybe2007 (赞：7)

其实本质上是一道 $\text{dp}$ 题。

首先有如下事实：对于同代的同种小妖，我们只需考虑最早出生的那只。

原因：每只小妖的所有属性，包括成长时间，孵化种类及时间都是一定的。而我们要求的是最远到达的代数，所以只需考虑最早出生的那只即可。~~感性理解一下。~~

因此考虑动态规划。观察到 $t$ 的范围较大，所以不妨使用倍增优化。那么状态该如何设计呢？首先应当存下每一种的最小孵化时间，因为 $n\leq 100$，所以不妨把这个单独作为一个数组存下来。那么此时根据倍增，以代数为阶段进行转移更新最小值，倍增的答案累加到 $ans$ 中。

所以现在的目标就是如何较快地更新出每一种的最小值，为此我们可以预处理，令 $d_{p,i,j}$ 表示经过 $2^p$ 代，从 $i$ 出生到 $j$ 出生所需的最小时间，那么同样以倍增的形式进行转移，然后用类似 $\texttt{Floyd}$ 的方式更新最短路。注意，因为这里的阶段是单独作为一维的，所以不用按照 $\texttt{Floyd}$ 的方式在最外层枚举中转点的做法亦是可行的。然后更新答案的倍增倒序枚举，能更新就更新，根据二进制的相关知识，这样可以保证最优性。

时间复杂度 $O(n^3\times \log t)$。

```cpp
#include<bits/stdc++.h>
#define N 105
using namespace std;
typedef long long ll;
int n,x[1005],y[1005];
ll T;
ll d[55][N][N];
ll now[N],mn[N];
int main()
{
	scanf("%d%lld",&n,&T);
	memset(d,0x3f,sizeof(d));
	for(int i=1;i<=n;i++)
	{
		int k,z;
		scanf("%d%d",&k,&z);
		for(int j=1;j<=k;j++) scanf("%d",&x[j]);
		for(int j=1;j<=k;j++) scanf("%d",&y[j]),d[0][i][x[j]]=min(d[0][i][x[j]],1ll*(z+y[j]));
	}
	for(int p=1;p<=50;p++)
		for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) for(int k=1;k<=n;k++) d[p][i][j]=min(d[p][i][j],d[p-1][i][k]+d[p-1][k][j]);
	//d[p][i][j]表示从 i 到 j，繁殖(1<<p)代所需的最小年数 
	//不严格矩阵乘法，本质是倍增优化dp 
	ll ans=0;
	for(int p=50;p>=0;p--)
	{ 
		for(int i=1;i<=n;i++) mn[i]=1e18;
		for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) mn[j]=min(mn[j],now[i]+d[p][i][j]);
		bool flag=0;
		for(int i=1;i<=n;i++) if(mn[i]<=T) flag=1;
		if(flag)
		{
			ans+=(1ll<<p);
			for(int i=1;i<=n;i++) now[i]=mn[i];
		}
	}
	printf("%lld\n",ans);
}
```

---

## 作者：_acat_ (赞：3)

~~来自 COCI 的官方题解。~~

## 思路

让 $x_{d[i]}$ 为到第一个有 $d$ 个祖先的 $i$ 型精灵诞生的年份。由于事故中每种类型的小精灵都有一个，我们可以为每个 $i$ 设置 $x_0[i] = 0$。

检查一种有 $d$ 祖先的 $i$ 型小精灵。一年后他产下一枚 $j$ 型卵，那需要 $z_{i,j}$ 年才能孵化。那个蛋有 $d+1$ 个祖先。所以我们现在知道 $x_{d+1}[j]$ 小于或等于 $x_{d[i]} + y_i + z$。显然，找到所有孵化 $j$ 型蛋的小精灵的最小值，我们得到 $x_{d+1}[j]$。我们可以用矩阵代数一次观察所有类型。

我们有:

$$a \otimes x_d = x_{d +1}$$

其中 $a$ 是一个矩形矩阵，第 $i$ 行第 $j$ 列等于 $y_j + z_j$，如果是 $j$ 型格莱姆林孵化出第 $i$ 型蛋，则为 $i$，如果不是 $\infty$。矩阵 $x_d$ 和 $x_{d+1}$ 是不需要加以说明的，$\otimes$ 表示最小加矩阵乘法。

用二进制求幂法可以快速地将矩阵 $a$ 提升到任意次幂。

将 $a^d \times x_0$，然后对 $x_d$ 进行最小加代数运算，扫描得到的 $x_d$ 矩阵。如果每个数字都大于 $t$，那么就没有 $d$ 祖先的小妖精。否则，至少有一个。对 $D$ 进行二分搜索，找到最大的可能 $d$。

---

## 作者：qwer6 (赞：0)

我们不妨直接建图，对于一个种类为 $i$ 的妖精，我们向 $g_{i,j}$ 连一条边权为 $y_i+h_{i,j}$ 的边，问题就转换为，求一个最大的 $k$，使得存在一条经过 $k$ 条边的路径，长度不超过 $t$，最后的答案就是 $k+1$。  
这很显然就是一个倍增 Floyd 求定长最短路了，或者说是一个广义的矩阵乘法，我们预处理经过 $2^i$ 条边可以得到的第 $i$ 个点和第 $j$ 个点的之间最短路，然后类似树上求 LCA 的流程求出最大的 $k$ 即可。  
```c++
/*by qwer6(省略缺省源和快读快写)*/
int n,t,ans,lg;
int y[105],k[105],h[105][105],g[105][105];
struct matrix{
	int dis[105][105];
	void clear(){
		memset(dis,0x3f,sizeof(dis));
	}
	matrix operator *(const matrix &T)const{
		matrix res;
		res.clear();
		for(int k=1;k<=n;k++)
			for(int i=1;i<=n;i++)
				for(int j=1;j<=n;j++)
					tomin(res.dis[i][j],dis[i][k]+T.dis[k][j]);
		return res;
	}
	bool check(){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++)if(dis[i][j]<=t)return true;
		}
		return false;
	}
}A,st[50];
signed main(){
	read(n),read(t);
	A.clear();
	st[0].clear();
	for(int i=1;i<=n;i++){
		A.dis[i][i]=0;
		read(k[i]),read(y[i]);
		for(int j=1;j<=k[i];j++)
			read(g[i][j]);
		//从 i 这个小妖出生到 j 这个小妖出生需要的时间 
		for(int j=1;j<=k[i];j++){
			read(h[i][j]);
			tomin(st[0].dis[i][g[i][j]],y[i]+h[i][j]);
		}
	}
	for(int i=1;;i++){
		st[i]=st[i-1]*st[i-1];
		if(!st[i].check()){
			lg=i;
			break;
		}
	}
	matrix tmp;
	for(int i=lg;i>=0;i--){
		tmp=A*st[i];
		if(!tmp.check())continue;
		A=tmp;
		ans+=1ll<<i;
	}
	write(ans);
}
```

---

## 作者：Carey_chen (赞：0)

这是一道 dp + 倍增题目。

可以把题目中的关系建为一张有向图，每个点代表一种妖精，边代表 “繁殖” 的关系，边权代表第 $i$ 种妖精从出生到繁殖出第 $j$ 种妖精所需要的最小时间。把这张图的邻接矩阵记为 $G$.

设 $dp_{k, i, j}$ 为第 $i$ 种妖精产生代数为 $k$ 的第 $j$ 种妖精所需要的最小时间。

那么有：

$$dp_{k, i, j} = \min _{1 \leq x \leq n}\left\{dp_{k-1, i, x} +G_{x, j}\right\}$$

定义一种新矩阵乘法，当 $A × B = C$ 时，$C_{i, j} = min\left\{A_{i, k} + B_{k, j}\right\}$

可以发现，在这种新定义的矩阵乘法中，$dp_{k} × G = dp_{k+1}$

题目要求 $t$ 年后和祖先关系最远的小妖的代数，也就相当于求一个最大的 $k$，使 $dp_{k}$ 中至少有一个值小于等于 $t$。

可以预处理出 $F_{x} = dp_{2^x}$，之后倍增即可。

### Code

```cpp
#include <bits/stdc++.h>
#define Base 45
#define int long long

using namespace std;

struct matrix
{
    int s;
    int arr[110][110];
    
    matrix(int num = 100)
    {
        s = num;
        
        memset(arr, 0x1f, sizeof(arr));
    }
    
    matrix operator * (const matrix &b) //新定义的矩阵乘法
    {
        matrix c(s);
        
        for(int i = 1; i <= s; i++)
        {
            for(int j = 1; j <= s; j++)
            {
                for(int k = 1; k <= s; k++)
                {
                    ​​c.arr[i][j] = std::min(c.arr[i][j], arr[i][k] + b.arr[k][j]);
                }
            }
        }
        
        return c;
    }
};

matrix G[Base + 5], now;

int n, t; 
bool check(matrix x)
{
    int cnt = 0;
    for(int i = 1; i <= x.s; i++)
    {
        for(int j = 1; j <= x.s; j++)
        {
            if(x.arr[i][i] > t)
            {
                cnt++;
            }
        }
    }
    
    return cnt != x.s * x.s;
}

int g[1010], h[1010];

signed main()
{
    scanf("%lld %lld", &n, &t);
    
    now.s = n;
    for(int i = 0; i <= Base; i++)
    {
        G[i].s = n;
    }
    
    for(int i = 1; i <= n; i++)
    {
        int k, y;
        scanf("%lld %lld", &k, &y);
        
        for(int j = 1; j <= k; j++)
        {
            scanf("%lld", &g[j]);
        }
        for(int j = 1; j <= k; j++)
        {
            scanf("%lld", &h[j]);
        }
        
        for(int j = 1; j <= k; j++)
        {
            G[1].arr[i][g[j]] = min(G[1].arr[i][g[j]], y + h[j]);
        }
    }
    
    for(int i = 2; i <= Base; i++) // 预处理
    {
        G[i] = G[i-1] * G[i-1];
    }
    
    memset(now.arr, 0, sizeof(now.arr));
    int ans = 0, OK = 0;
    for(int i = Base; i >= 1; i--) // 倍增
    {
        matrix _new(n);
        
        _new = now * G[i];
        
        if(check(_new) == true)
        {
            OK++;
            ans += (1ll << (i - 1)); // 必须用1ll，不然会爆 long long
            now = _new;
        }
    }
    printf("%lld\n", ans);
    
    return 0;
}
```

---

## 作者：鱼跃于渊 (赞：0)

## 做法：  
考虑 dp：设 $f_{i,j}$ 为 $i$ 种小妖从出生直到它产下的 $j$ 种小妖孵化的最小时间，转移很容易，枚举它的后代种类。  
考虑矩阵优化：显然上面的 dp 转移方式是 $(\min,+)$，有结合律，可以使用矩阵优化。  
考虑倍增：设 $A$ 为转移矩阵，则 $pw_i=A^i$，从大到小枚举，若乘上它后矩阵内最小值不大于 $t$，就乘上它。可以证明这样做具有最优性。  
## 代码：  
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=100,inf=1e18;
int n,t,ans,g[N*10];
struct matrix{
	int a[N][N];
	int *const operator [](const int i){
		return a[i];
	}
	void clear(){
		memset(a,0,sizeof(a));
	}
	void init(){
		for(int i=0;i<n;i++)
			for(int j=0;j<n;j++)
				a[i][j]=inf;
	}
	friend matrix operator *(matrix &x,matrix &y){
		matrix z;z.init();
		for(int i=0;i<n;i++)
			for(int k=0;k<n;k++)
				for(int j=0;j<n;j++)
					z[i][j]=min(z[i][j],x[i][k]+y[k][j]);
		return z;
	}
	friend matrix operator ^(matrix &a,int b){
		matrix res;res.init();
		while(b){
			if(b&1) res=res*a;
			a=a*a;b>>=1;
		}
		return res;
	}
}a,b,pw[N];
bool check(matrix x){
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			if(x[i][j]<=t) return 1;
	return 0;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin>>n>>t;
    a.init();b.clear();
    for(int i=0,k,y;i<n;i++){
    	cin>>k>>y;
    	for(int j=0;j<k;j++){
    		cin>>g[j];g[j]--;
		}
    	for(int j=0,h;j<k;j++){
    		cin>>h;
    		a[i][g[j]]=min(a[i][g[j]],y+h);
		}
	}
	pw[0]=a;
	for(int i=1;i<=50;i++)
		pw[i]=pw[i-1]*pw[i-1];
	for(int i=50;i>=0;i--){
		if(check(b*pw[i])){
			ans+=(1ll<<i);
			b=b*pw[i];
		}
	}
	cout<<ans<<'\n';
    return 0;
} 
```

---


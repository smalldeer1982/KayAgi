# 石头游戏

## 题目描述

石头游戏在一个 $n$ 行 $m$ 列的网格上进行，每个格子对应一种操作序列，操作序列至多有 $10$ 种，分别用 $0 \sim 9$ 这 $10$ 个数字指明。

操作序列是一个长度不超过 $6$ 且循环执行、每秒执行一个字符的字符串。

每秒钟，所有格子同时执行各自操作序列里的下一个字符。

序列中的每个字符是以下格式之一：

  1. 数字 $0 \sim 9$：表示拿 $0 \sim 9$ 个石头到该格子。
  2. `NWSE`：表示把这个格子内所有的石头推到相邻的格子，`N` 表示上方，`W` 表示左方，`S` 表示下方，`E` 表示右方。
  3. `D`：表示拿走这个格子的所有石头。

给定每种操作序列对应的字符串，以及网格中每个格子对应的操作序列，求石头游戏进行了 $t$ 秒之后，石头最多的格子里有多少个石头。

在游戏开始时，网格是空的。

## 说明/提示

对于所有的测试数据， 满足 $1 \le m,n \le 8$，$1 \le t \le 10^8$，$1 \le act \le 10$。

## 样例 #1

### 输入

```
1 6 10 3
011112
1E
E
0```

### 输出

```
3```

# 题解

## 作者：JHR100330 (赞：9)

## 题目大意

根据题目模拟操作，输出 $t$ 秒后石头最多的格子里有多少个石头。

## 分析

首先，$1 \le t \le 10^8$，暴力枚举必然超时，我们发现，操作序列的长度极短，仅有 $1$ 至 $6$，所以每 $60$ 秒为一个周期，所有操作序列均会回到第一个操作，然后循环，故考虑矩阵快速幂加速递推。

先要考虑如何构建矩阵。

### 一、考虑放置操作

我们先将其简化一下：只考虑网格是一维，且每个格子上的操作也只有一种的情况。

假设我们输入的数据为：

```
1 3 2 3
012
0
1
2
```

根据题目，我们可以知道，每秒钟我们在第一个格子上放 $0$ 个石头，在第二个格子上放 $1$ 个石头，在第二个格子上放 $2$ 个石头。

然后让我们思考一下如何创建状态矩阵，三个时刻每一格石头的个数即为 `0 0 0`，`0 1 2`，`0 2 4`。

我们发现每一秒某个格子上增加的石头数量都是一样的。

我们将这三个网格上的石头的数量设为 $a_1,a_2,a_3$，代表第 $0$ 秒时的状态（转移前的状态），$a_1',a_2',a_3'$ 表示第 $1$ 秒时的状态(转移后的状态)。

通过分析我们可以列出下列表达式：

$$
a_1' = 1 \times a_1 + 0 \\
a_2' = 1 \times a_2 + 1 \\
a_3' = 1 \times a_3 + 2
$$

变换一下：

$$
a_1' = 1 \times a_1 + 0 \times a_2 + 0 \times a_3 + 0 \\
a_2' = 0 \times a_1 + 1 \times a_2 + 0 \times a_3 + 1 \\
a_3' = 0 \times a_1 + 0 \times a_2 + 1 \times a_3 + 2
$$

但是还要解决一个问题，那就是结尾加上去的 $0,1,2$。

我们知道结尾加上的数是不会随着时间的变化而变化的，所以我们设 $a_0 = 1$，则：

$$
a_0 = a_0 \\
0 = 0 \times a_0 \\
1 = 1 \times a_0 \\
2 = 2 \times a_0
$$

将其与上面的式子结合我们就可以得到：

$$
a_0' = 1 \times a_1 + 0 \times a_1 + 0 \times a_2 + 0 \times a_3 \\
a_1' = 0 \times a_1 + 1 \times a_1 + 0 \times a_2 + 0 \times a_3 \\
a_2' = 1 \times a_1 + 0 \times a_1 + 1 \times a_2 + 0 \times a_3 \\
a_3' = 2 \times a_1 + 0 \times a_1 + 0 \times a_2 + 1 \times a_3
$$

（$a_0'$ 为 $a_0$ 转移后的值）

这样我们就得到了状态矩阵：

$$
\begin{bmatrix}
1 & 0 & 0 & 0 
\end{bmatrix}
$$

和转移矩阵：

$$
\begin{bmatrix}
1 & 0 & 1 & 2 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
$$

### 二、考虑移动操作

若当前状态矩阵为：

$$

\begin{bmatrix}
a_0 & a_1 & a_2 & a_3 
\end{bmatrix}
=
\begin{bmatrix}
1 & 2 & 3 & 4 
\end{bmatrix}
$$

变化一下：

$$
a_0' = 1 \times a_1 + 0 \times a_1 + 0 \times a_2 + 0 \times a_3 \\
a_1' = 0 \times a_1 + 0 \times a_1 + 0 \times a_2 + 0 \times a_3 \\
a_2' = 0 \times a_1 + 1 \times a_1 + 1 \times a_2 + 0 \times a_3 \\
a_3' = 0 \times a_1 + 0 \times a_1 + 0 \times a_2 + 1 \times a_3
$$

所以转移矩阵为：

$$
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
$$

矩阵的构建就实现完了。

### 三、考虑代码实现

设 $\forall i \in [1,n],j \in [1,m],num(i,j) = (i - 1) \times m + j$。

把网格看做 $n \times m$ 的一维向量，定义 $1$ 行 $n \times m + 1$ 列的状态矩阵 $F$，下标为 $0$ 至 $n \times m$，其中 $F_{num(i,j)}$ 记录格子 $(i,j)$ 中石头的个数。

特别地，令 $F_0$ 始终等于 $1$。

$F$ 会随着时间的增长而不断变化。设 $F_k$表示 $k$ 秒之后的状态矩阵。

在游戏开始时，根据题意和 $F$ 的定义，有：

$$
F_0
=
\begin{bmatrix}
1 & 0 & 0 & \cdots & 0 
\end{bmatrix}
$$

注意到操作序列的长度不超过 $6$，而 $1$ 至 $6$ 的最小公倍数是 $60$，所以每经过 $60$ 秒，所有操作序列都会重新处于最开始的字符处。我们可以统计出第 $k$ 秒（$1 \le k \le 60$）各个格子执行了什么字符，第 $k + 60$ 秒执行的字符与第 $k$ 秒一定是相同的。

对于 $1$ 至 $60$ 之间的每个 $k$，各个格子在第 $k$ 秒执行的操作字符可以构成一个转移矩阵 $A_k$，矩阵行、列下标都为 $0$ 至 $n \times m$。

构造方法如下：

1. 若网格 $(i,j)$ 第 $k$ 秒的操作字符为 `N`，且 $i > 1$，则令 $A_k[num(i,j),num(i - 1, j)] = 1$，表示将石头推至上方的格子。字符 `W`，`S` 与 `E` 类似。

1. 若网格 $(i,j)$ 第 $k$ 秒的操作字符为数字 $x$，则令 $A_k[0,num(i, j)] = x,A_k[num(i,j),num(i,j)] = 1$，表示该格中原有的石头不动，再拿 $x$ 块石头。

1. 令 $A_k[0,0] = 1$。

1. 令 $A_k$ 剩余部分均为 $0$。

上述构造实际上把状态矩阵的第 $0$ 列作为"石头来源"，$A_k[0,0] = 1$ 保证了 $F_0$ 始终为 $1$，$A_k[0,num(i, j)] = x$ 相当于从"石头来源"获取 $x$ 个石头，放到格子 $(i,j)$ 中。

使用矩阵乘法加速递推，遇到常数项时，经常需要在状态矩阵中添加一个额外的位置，始终存储常数 $1$，并乘上转移矩阵中适当的系数，累加到状态矩阵的其他位置。

### 四、考虑答案统计

设：

$$
A = \displaystyle \prod_{i = 1}^{60} A_i $$

$$
t = q \times 60 + r(0 \le r \lt 60)
$$

根据上面的讨论：

$$
F_t = F_0 \cdot A^q \cdot \displaystyle \prod_{i = 1}^r A_i
$$

使用矩阵乘法和快速幂计算该式，$F_t$ 第 $1$ 至 $n \times m$ 列中的最大值即为所求。

## AC Code


```cpp
#include <bits/stdc++.h>

using namespace std;

#define ll long long

const int N = 10, M = 65;

struct matrix{ // 矩阵 
	ll c[M][M];
	matrix(){memset(c, 0, sizeof c);} // 生成函数：初始值均为0 
};

int n, m, t, act, x, y;
ll mx;
int idx[N][N], now[N][N];
matrix cg[M], sum, ans;
char c, seq[N][N];

matrix operator*(matrix a, matrix b){ // 新定义矩阵乘 
	matrix u;
	for(int i = 0; i <= n * m; i ++)
		for(int j = 0; j <= n * m; j ++)
			for(int k = 0; k <= n * m; k ++)
				u.c[i][j] += a.c[i][k] * b.c[k][j];
	return u;
}

int gt(int a, int b){return (a - 1) * m + b;} // 将网格中的点降维 

matrix qpow(matrix a, int b){ // 矩阵快速幂 
	matrix u, x = a;
	for(int i = 0; i < M; i ++)
		u.c[i][i] = 1;
	for(; b; b >>= 1){
		if(b & 1) u = u * x;
		x = x * x;
	}
	return u;
}

int main() {
	scanf("%d %d %d %d\n", &n, &m, &t, &act);
	for(int i = 1; i <= n; i ++){
		for(int j = 1; j <= m; j ++){
			scanf("%c", &c);
			idx[i][j] = c - '0' + 1;
		}
		scanf("\n");
	}
	for(int i = 1; i <= act; i ++)
		scanf("%s", seq[i]);
	for(int tim = 1; tim <= 60; tim ++){ // 生成前60次转移矩阵 
		for(int i = 1; i <= n; i ++){
			for(int j = 1; j <= m; j ++){
				x = idx[i][j], y = now[i][j];
				if(isdigit(seq[x][y])){ // 操作字符为数字 
					cg[tim].c[0][gt(i, j)] = seq[x][y] - '0'; // 从“石头来源”取x个石头 
					cg[tim].c[gt(i, j)][gt(i, j)] = 1; // 原来的石头数不变 
				}
				// 操作字符为NWSE 
				if(seq[x][y] == 'N' && i > 1) cg[tim].c[gt(i, j)][gt(i - 1, j)] = 1;
				if(seq[x][y] == 'W' && j > 1) cg[tim].c[gt(i, j)][gt(i, j - 1)] = 1;
				if(seq[x][y] == 'S' && i < n) cg[tim].c[gt(i, j)][gt(i + 1, j)] = 1;
				if(seq[x][y] == 'E' && j < m) cg[tim].c[gt(i, j)][gt(i, j + 1)] = 1;
				// 该位操作位数+1 
				now[i][j] = (y + 1) % strlen(seq[x]);
			}
		}
		cg[tim].c[0][0] = 1;
	}
	// 统计前60次转移 
	sum = cg[1];
	for(int i = 2; i <= 60; i ++)
		sum = sum * cg[i];
	// 快速幂计算每60秒后的矩阵 
	ans.c[1][0] = 1;
	ans = ans * qpow(sum, t / 60);
	// 剩余的不到60次操作 
	for(int i = 1; i <= t % 60; i ++)
		ans = ans * cg[i];
	// 统计最大石头数 
	for(int i = 1; i <= n * m; i ++)
		mx = max(mx, ans.c[1][i]);
	printf("%lld\n", mx);
	return 0;
}
```

---

## 作者：_HCl_ (赞：4)

虽然比较难调试，但还是一道非常有趣的题。

# P10498 题解

**题意简述**

一个网格上，每一个格子对应一个操作序列。每一秒，所有格子根据其操作序列同时进行操作。操作有可能放若干个石子再格子上，或者将移动至相邻格子，或者取走上面的所有石子。

求出 $t$ 秒时，石子最多的格子上的石子数量。

**思路引导**

观察发现，除了 $t$ 较大以外，其余数据均比较小。因此考虑使用矩阵优化。

不同的格子，其操作序列长度不同。所以考虑将它们都统一成长度为 $60$ 的序列。这样在计算时会方便不少。

另外，我们需要将 $n\times m$ 的网格“拍扁”成一个一维的长度为 $nm$ 的行，这样才能使用矩阵乘法对状态进行转移。我们使用 $pos(i,j)$ 表示这样一个从网格到行的双射。

下面先考虑对于一秒内的操作，如何求出其转移矩阵。下述内容请结合矩阵乘法的定义进行思考。

- 取出石子

取出石子，即把这一个位置 $x=pos(i,j)$ 的数变为 $0$。根据矩阵乘法的定义，转移矩阵 $M$ 的 $M_{x,x}$ 需要为 $0$。

- 移动石子

以上移为例，移动石子即清空 $x=pos(i,j)$ 上的石子，$y=pos(i-1,j)$ 上的石子数量加上 $x$ 上原石子数量。

那么 $M_{x,x}=0$，$M_{x,y}=1$。

另外，注意判断移动到网格外时，就相当于取出操作。

- 放置石子

为了方便加上一个给定的数 $d$，我们在状态矩阵的右边多加一位 $1$。即规定状态矩阵 $S$ 的 $S_{1,nm+1}=1$。

这样在我们给 $x$ 位置放上 $d$ 个石子时，转移矩阵上表现为 $M_{nm+1,x}=1$。

然后我们将每 60 个转移矩阵整合成一个大的转移矩阵 $trans$，这里利用矩阵快速幂去优化。还有一些多余的操作就逐个去乘。（其实也可以前缀和弄起来的，但是不要紧）。

时间复杂度 $\mathcal{O}(n^3m^3\log t)$。

**代码**

代码量比较大，模块化写起来会比较舒服。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct Matrix{
	int n,m;
	int mat[66][66];
};
Matrix operator *(Matrix A,Matrix B){//矩阵乘法
	Matrix res;
	res.n=A.n,res.m=B.m;
	memset(res.mat,0,sizeof(res.mat));
	for(int i=1;i<=A.n;++i)
		for(int j=1;j<=B.m;++j)
			for(int k=1;k<=A.m;++k)
				res.mat[i][j]+=A.mat[i][k]*B.mat[k][j];
	return res;
}
Matrix I(int x){//生成单位矩阵
	Matrix res;
	res.n=res.m=x;
	memset(res.mat,0,sizeof(res.mat));
	for(int i=1;i<=x;++i)res.mat[i][i]=1;
	return res;
}
Matrix opt[61];
int n,m,T,act,op[11][11],siz;
string arr[11];
int pos(int i,int j){//网格到行的映射
	if(i<=0||i>n||j<=0||j>m)return -1;//超出边界标记为-1
	return m*(i-1)+j;
}
Matrix getmat(int x){//生成单步的转移矩阵
	Matrix res=I(siz);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j){
			char ch=arr[op[i][j]][x];
			if('0'<=ch&&ch<='9'){
				int num=ch-'0';
				res.mat[siz][pos(i,j)]=num;
			}else if(ch=='D')res.mat[pos(i,j)][pos(i,j)]=0;
			else{
				int x=pos(i,j),y;
				if(ch=='N')y=pos(i-1,j);
				else if(ch=='W')y=pos(i,j-1);
				else if(ch=='S')y=pos(i+1,j);
				else if(ch=='E')y=pos(i,j+1);
				res.mat[x][x]=0;
				if(y!=-1)res.mat[x][y]=1;
			}
		}
	return res;
}
Matrix gentrans(){//生成大的转移矩阵
	Matrix res=I(siz);
	for(int i=1;i<=60;++i){
		opt[i]=getmat(i);//顺带记录每一步的转移矩阵
		res=res*opt[i];
	}
	return res;
}
Matrix start(){//初始状态矩阵
	Matrix res;
	res.n=1,res.m=siz;
	memset(res.mat,0,sizeof(res.mat));
	res.mat[1][siz]=1;
	return res;
}
Matrix qpow(Matrix A,int y){//快速幂
	Matrix res=I(siz);
	for(;y;y>>=1,A=A*A)if(y&1)res=res*A;
	return res;
}
signed main(){
	cin>>n>>m>>T>>act;
	siz=n*m+1;//矩阵的大小
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j){
			char ch;cin>>ch;
			op[i][j]=ch-'0'+1;
		}
	for(int i=1;i<=act;++i){
		cin>>arr[i];
		string tmp=arr[i];
		while(tmp.length()<60)tmp+=arr[i];//循环扩充至60
		arr[i]=" "+tmp;
	}
	Matrix trans=gentrans();
	int x=T/60,y=T%60;
	Matrix ans=start()*qpow(trans,x);
	for(int i=1;i<=y;++i)ans=ans*opt[i];//计算最终状态
	int Ans=0;
	for(int i=1;i<siz;++i)Ans=max(Ans,ans.mat[1][i]);//计算答案
	cout<<Ans;
	return 0;
}
```

---

## 作者：cybermage_liu (赞：4)

# 思路
$t$ 的范围很大，直接暴力肯定会 TLE，但是操作序列是循环执行的，所以可以通过矩阵快速幂进行加速。

因为要对整个矩阵进行操作，所以我们可以对矩阵降维打击，使其变为一个长 $n \times m$ 的链，矩阵的 $(i,j)$ 表示为链上的 $(i-1) \times m+j$，再拓展一维用来矩阵加速。

题中有增加方格内石头数量的操作，所以再加一个下标为 $0$ 的地方表示数字 $1$ 方便操作。

考虑每一个操作的具体实现，假设当前方格为 $(i,j)$，转移矩阵为 $A$，当前矩阵为 $B$，$B$ 乘上 $A$ 就是操作后的矩阵。

首先将 $A$ 清空，将 $A_{0,0}$ 标记为 $1$。
### 数字 0~9
将此方格内石头数量加上新增数量。

也就是将 $A_{(i-1) \times m+j,(i-1) \times m+j}$ 标记为 $1$，$A_{0,(i-1) \times m+j}$ 标记为新增数量。
### NWSE
将一个临近方格内石头数量加上当前方格内石头数量，当前方格内石头数量清空。

需要特判在边界处推出去的情况。

$N$：将 $A_{(i-1) \times m+j,(i-2) \times m+j}$ 标记为 $1$。  
$S$：将 $A_{(i-1) \times m+j,i \times m+j}$ 标记为 $1$。  
$W$：将 $A_{(i-1) \times m+j,(i-1) \times m+j-1}$ 标记为 $1$。  
$E$：将 $A_{(i-1) \times m+j,(i-1) \times m+j+1}$ 标记为 $1$。  
### D
将当前方格清空。

不用操作。

### 矩阵快速幂

要将整个矩阵的操作序列作为一个整体进行操作，因为每个操作序列都是循环执行的，且长度不一定相等，所以要将每个操作序列循环至同一长度。

很明显这个长度（$len$）最小为操作序列长度的最小公倍数。操作序列长度不超过 $6$，那么最小公倍数不超过 $60$。

那么就可以愉快地矩阵快速幂了，最终矩阵（$T$）为 $B$ 的 $\lfloor t/len \rfloor$ 次方乘上操作执行到 $t \bmod len$ 时的矩阵（$C$），也就是 $T=B^{\lfloor t/len \rfloor} \times C$。

那么答案就是 $\max_{1 \le i \le n \times m}\{T_{0,i}\}$。
# AC code
```cpp
#include<bits/stdc++.h>
#define int long long//记得开 long long
#define nm (n*m) 
using namespace std;
const int N=66;
struct node{
	int a[N][N];
}A,B,C;
int n,m,d[10][10];
string ch,s[10];
node operator*(node X,node Y){//矩阵乘法
	node Z;memset(Z.a,0,sizeof(Z.a));
	for(int i=0;i<=nm;i++)
		for(int j=0;j<=nm;j++)
			for(int k=0;k<=nm;k++)
				Z.a[i][j]+=X.a[i][k]*Y.a[k][j];
	return Z;
}
node qpow(int b){//矩阵快速幂
	node res;memset(res.a,0,sizeof(res.a));
	for(int i=0;i<=nm;i++) res.a[i][i]=1;
	while(b){
		if(b&1) res=res*B;
		B=B*B,b>>=1;
	}
	return res;
}
signed main(){
	int t,act,ans=0,len=1;
	cin>>n>>m>>t>>act;
	memset(B.a,0,sizeof(B.a));
	for(int i=1;i<=n;i++){
		cin>>ch;
		for(int j=1;j<=m;j++) d[i][j]=ch[j-1]-48;
	}
	for(int i=0;i<act;i++){
		cin>>s[i];
		int x=s[i].length();
		len=len/__gcd(len,x)*x;//求最小公倍数
	}
	for(int i=0;i<act;i++)
		while(s[i].length()<len) s[i]+=s[i];//循环操作序列至最小公倍数
	for(int i=0;i<=nm;i++) B.a[i][i]=1;//初始化为单位矩阵
	for(int p=0;p<len;p++){
		memset(A.a,0,sizeof(A.a));
		A.a[0][0]=1;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				if(s[d[i][j]][p]>=48 && s[d[i][j]][p]<=57)
					A.a[0][(i-1)*m+j]=s[d[i][j]][p]-48,
					A.a[(i-1)*m+j][(i-1)*m+j]=1;
				else if(s[d[i][j]][p]=='N' && i!=1)//注意边界特判
					A.a[(i-1)*m+j][(i-2)*m+j]=1;
				else if(s[d[i][j]][p]=='S' && i!=n)
					A.a[(i-1)*m+j][i*m+j]=1;
				else if(s[d[i][j]][p]=='W' && j!=1)
					A.a[(i-1)*m+j][(i-1)*m+j-1]=1;
				else if(s[d[i][j]][p]=='E' && j!=m)
					A.a[(i-1)*m+j][(i-1)*m+j+1]=1;
			}
		}
		B=B*A;
		if(p+1==t%len) C=B;
	}
	node T=qpow(t/len);
	if(t%len) T=T*C;
	for(int i=1;i<=nm;i++) ans=max(ans,T.a[0][i]);
	cout<<ans;
	return 0;
}
```

---

## 作者：hjyowl (赞：4)

### 思路

首先，如果硬模拟，由于 $t \le 10^8$，会超时。

考虑到矩阵快速幂，由于操作长度小于等于 $6$，可以得到 $60$ 秒钟过后必有一个循环节。

有了这个性质过后，我们可以考虑把 $t$ 划分成 $t \div 60$ 下取整个完整的循环节和 $t \bmod 60$ 的余下的。

我们可以用一个 $n\times m$ 的向量，记能使 $i-1$ 秒转移到 $i$ 秒的 矩阵为 $a_i$，这里 $1\le i\le60$。

然后我们令 $A = \Pi_{i=1}^{60} a_i$，令 $t=60q+r$，且 $r \le 60$，那么我们答案为 $f_0 \times A^q \times \Pi_{i=1}^{r}a_i$。

这是基本大方向，但是具体细节在于如何求出变换矩阵 $a_i$。

每次乘的矩阵的边长为 $n\times m$，对于矩阵 $a_{time}$，这里是求法：

$a_{time,0,0}=1$。

对于任意 $(i,j)$，他在 $time$ 秒钟的操作符号记为 $op$，则：

若 $op$ 为数字，则 $a_{time,0,get(i,j)}=op$，$a_{time,get(i,j),get(i,j)}=1$，这里 $get$ 返回的是 $(i - 1) \times m + j$。

若 $op$ 为 ```N```，则当 $i > 1$ 成立时，$a_{time,get(i,j),get(i - 1,j)} = 1$。

若 $op$ 为 ```S```，则当 $i < n$ 成立时，$a_{time,get(i,j),get(i + 1,j)} = 1$。

若 $op$ 为 ```W```，则当 $j > 1$ 成立时，$a_{time,get(i,j),get(i,j - 1)} = 1$。

若 $op$ 为 ```E```，则当 $j < m$ 成立时，$a_{time,get(i,j),get(i,j + 1)} = 1$。

如果都没有被赋值的地方，为 $0$。

然后求出来过后按照上面的公式计算即可。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,m,t,k;
long long a[62][70][70];
long long tmp[70][70];
long long fc[70][70];
long long checker[70][70];
string op[70]; 
void mul_qmi(long long f[70],long long a[70][70]){
	long long c[70];
	memset(c,0,sizeof c);
	for (long long i = 0; i <= n * m; i ++ ){
		for (long long j = 0 ;j <= n * m; j ++ ){
			c[i] = (c[i] + (long long)f[j] * a[j][i]);
		}
	}
	memcpy(f,c,sizeof c);
}
void mul_qmi2(long long a[70][70]){
	long long c[70][70];
	memset(c,0,sizeof c);
	for (long long i = 0; i <= n * m; i ++ ){
		for (long long j = 0; j <= n * m; j ++ ){
			for (long long k = 0; k <=  n * m; k ++ ){
				c[i][j] = (c[i][j] + (long long)a[i][k] * a[k][j]);
			}
		}
	}
	memcpy(a,c,sizeof c);
}
void mul(long long a[70][70],long long b[70][70]){
	long long c[70][70];
	memset(c,0,sizeof c);
	for (long long i = 0; i <= n * m; i ++ ){
		for (long long j = 0; j <= n * m; j ++ ){
			for (long long k = 0; k <=  n * m; k ++ ){
				c[i][j] = (c[i][j] + (long long)a[i][k] * b[k][j]);
			}
		}
	}
	memcpy(a,c,sizeof c);
}
long long get(long long x,long long y){
	return (x - 1) * m + y;
}
void qmi(){
	long long f[70];
	memset(f,0,sizeof f);
	cin >> n >> m >> t >> k;
	for (long long i =1; i <= n; i ++ ){
		for(long long j =1; j <= m; j ++ ){
			char x;
			cin >> x;
			fc[i][j] = x - '0';
		}
	}
	for (long long i = 0; i < k; i ++ ){
		cin >> op[i];
	}
	for (long long T = 1; T <= 60; T ++ ){
		a[T][0][0] = 1;
		for (long long i = 1; i <= n; i ++ ){
			for (long long j = 1; j <= m; j ++ ){
				long long t = checker[i][j];
				if (op[fc[i][j]][t] >= '0' && op[fc[i][j]][t] <= '9'){
					a[T][0][get(i,j)] = op[fc[i][j]][t] - '0';
					a[T][get(i,j)][get(i,j)] = 1;
				}
				else if (op[fc[i][j]][t] == 'N' && i > 1){
					a[T][get(i,j)][get(i - 1,j)] = 1;
				}
				else if (op[fc[i][j]][t] == 'S' && i < n){
					a[T][get(i,j)][get(i + 1,j)] = 1;
				}
				else if (op[fc[i][j]][t] == 'W' && j > 1){
					a[T][get(i,j)][get(i,j - 1)] = 1;
				}
				else if (op[fc[i][j]][t] == 'E' && j < m){
					a[T][get(i,j)][get(i,j + 1)] = 1;
				}
				checker[i][j] = (t + 1) % (op[fc[i][j]].size()); 
			}
		}
	}
	for (long long i = 0; i <= n *m ; i ++ ){
		for (long long j = 0; j <= n * m; j ++ ){
			tmp[i][j] = a[1][i][j];
		}
	}
	for (long long i = 2;i <= 60; i ++ ){
		mul(tmp,a[i]);
	}
	f[0] = 1;
	long long check = t / 60;
	while (check){
		if (check & 1){
			mul_qmi(f,tmp);
		}
		mul_qmi2(tmp);
		check >>= 1;
	}
	for (long long i = 1; i <= t % 60; i ++ ){
		mul_qmi(f,a[i]);
	}
	long long res = 0;
	for (long long i = 1; i <= n * m; i ++ ){
		res = max(res,f[i]);
	}
	cout << res;
}
int main(){
	qmi();
	return 0;
}
```

---

## 作者：Chenyichen0420 (赞：2)

同[这题](https://www.acwing.com/problem/content/208/)。

矩阵乘法好题。很显然我们需要构造出这么一个转移矩阵。为了操作方便，我们需要将矩阵拍成一维的。用这份代码：`#define sw(i,j) ((i-1)*m+j)`。否则你做的就不是矩阵乘法，而是《立方体乘法》之类的东西（大雾）。

接下来分情况看：

1. 拿石子操作：`[0][sw(i, j)]` 赋值为石子数量，`[sw(i, j)][sw(i, j)]=1`。
2. `NESW` 操作：`[sw(i, j)][sw(移动终位置)]=1`。比如 `N` 为 `[sw(i, j)][sw(i - 1, j)]`。
3. `D` 操作：不管（如果你矩阵默认值为零）。

其余位置默认为 $0$ 就行。最后来矩阵乘法/矩阵快速幂就行。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define gc cin.get()
#define vc vector<int>
#define mat vector<vc>
#define sw(i,j) (i-1)*m+j
int n, m, t, act, c[12][12], x, y, ans, w;
char a[12][12], op[12][12];
mat anv, tiv[65], qpv;
inline void ul(mat& anv, const mat& tiv) {
	mat ans(anv.size(), vc(tiv[0].size()));
	for (int i = 0; i < anv.size(); ++i)
		for (int j = 0; j < tiv[0].size(); ++j)
			for (int k = 0; k < tiv.size(); ++k)
				ans[i][j] = ans[i][j] + anv[i][k] * tiv[k][j];
	anv = ans;
}
signed main() {
	ios::sync_with_stdio(0);
	cin >> n >> m >> t >> act; gc;
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= m; ++j)
			a[i][j] = gc ^ 48;
		gc;
	}
	for (int i = 0; i < act; ++i) cin >> op[i];
	for (int i = 1; i <= 60; ++i) tiv[i].resize(n * m + 1, vc(n * m + 1)), tiv[i][0][0] = 1;
	for (int k = 1; k <= 60; ++k)
		for (int i = 1; i <= n; ++i)
			for (int j = 1; j <= m; ++j) {
				x = a[i][j], y = c[i][j];
				if (isdigit(op[x][y])) tiv[k][0][sw(i, j)] = op[x][y] ^ 48, tiv[k][sw(i, j)][sw(i, j)] = 1;
				else if (op[x][y] == 'N' && i > 1) tiv[k][sw(i, j)][sw(i - 1, j)] = 1;
				else if (op[x][y] == 'S' && i < n) tiv[k][sw(i, j)][sw(i + 1, j)] = 1;
				else if (op[x][y] == 'W' && j > 1) tiv[k][sw(i, j)][sw(i, j - 1)] = 1;
				else if (op[x][y] == 'E' && j < m) tiv[k][sw(i, j)][sw(i, j + 1)] = 1;
				c[i][j] = (y + 1) % strlen(op[x]);
			}
	qpv = tiv[1]; w = t / 60;
	for (int i = 2; i <= 60; ++i)ul(qpv, tiv[i]);
	anv.resize(1, vc(n * m + 1)); anv[0][0] = 1;
	while (w) {
		if (w & 1)ul(anv, qpv);
		ul(qpv, qpv), w >>= 1;
	}
	for (int i = 1; i <= t % 60; ++i) ul(anv, tiv[i]);
	for (int i = 0; i <= n * m; ++i) ans = max(ans, anv[0][i]);
	cout << ans << endl;
	return 0;
}
```

---

## 作者：MoonCake2011 (赞：1)

首先，将那个网格搞成一个一维数组。

矩阵乘法，对于每个操作，可以设计相应格子里的矩阵。

最多 $60$ 个矩阵。

于是我们分为两个部分。

一个是 $t$ 可以被 $60$ 完整分割的部分。

一个是剩余的部分。

第一个直接矩阵快速幂，第二个暴力乘法计算。

状态矩阵 $c_{x,y}$ 表示将第 $y$ 个格子的石子个数赋值为第 $x$ 个格子的石子个数乘 $c_{x,y}$。

于是 `NWSE` 操作瞬间秒了（注意计算对应的位置）。

其实还有一个重要点，就是被推空的那个格子不赋值。

**注意边界问题**！

放石子的操作，可以将每时每刻的状态矩阵 $f_0$ 赋值为 $1$。

并且将每个 $c_{0,0}$ 赋值为 $1$。

这样这个操作就可以将 $c_{0,p}$ 赋值为那个数字（$p$ 为那个坐标对应的位置）。

`D` 相当于不赋值。

结束。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,t,act; 
int a[30][30];
string s[30];//字符串
int get(int x,int y){
	return (x-1)*m+y;
}
void mulself(int a[110][110],int b[110][110]){//矩阵乘矩阵
	int c[110][110]={{0}};
	for(int i=0;i<=n*m;i++)
		for(int j=0;j<=n*m;j++)
			for(int k=0;k<=n*m;k++)
				c[i][j]+=a[i][k]*b[k][j];
	memcpy(a,c,sizeof c); 
}
void mul(int f[110],int a[110][110]){
	int c[110]={0};
	for(int j=0;j<=n*m;j++)
		for(int k=0;k<=n*m;k++)
			c[j]+=f[k]*a[k][j];
	memcpy(f,c,sizeof c);
}
int mat[110][110][110],q[110][110];//60个状态矩阵与60个状态矩阵的乘积（打包计算的）
int f[110];//二维网格压缩的一维矩阵
signed main() {
	cin>>n>>m>>t>>act;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%1d",&a[i][j]),a[i][j]++;
	for(int i=1;i<=act;i++){//复制字符串到 60 个
		cin>>s[i];
		string t=s[i];
		while(s[i].size()!=60) s[i]+=t;
		s[i]=" "+s[i]; 
	}
	for(int k=1;k<=60;k++){//建立60个状态矩阵
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++){
				int x=a[i][j];
				if(isdigit(s[x][k])){
					mat[k][0][get(i,j)]=s[x][k]-'0';
					mat[k][get(i,j)][get(i,j)]=1;
				}
				else if(s[x][k]=='N' && i>1/*边界问题*/) mat[k][get(i,j)][get(i-1,j)]=1;
				else if(s[x][k]=='W' && j>1) mat[k][get(i,j)][get(i,j-1)]=1;
				else if(s[x][k]=='S' && i<n) mat[k][get(i,j)][get(i+1,j)]=1;
				else if(s[x][k]=='E' && j<m) mat[k][get(i,j)][get(i,j+1)]=1;
			}
		mat[k][0][0]=1; //赋值为 1 保证 f[0]=1
	}
	memcpy(q,mat[1],sizeof mat[1]);
	for(int k=2;k<=60;k++) mulself(q,mat[k]);//计算需要矩阵快速幂的矩阵
	f[0]=1;//压缩成一维数组，且 f[0]=1
	int u=t/60;
	while(u){//矩阵快速幂
		if(u & 1) mul(f,q);
		mulself(q,q);
		u>>=1;
	}
	u=t%60;
	for(int i=1;i<=u;i++) mul(f,mat[i]);//计算剩余部分
	int ans=0;
	for(int i=1;i<=n*m;i++) ans=max(ans,f[i]);//计算
	cout<<ans;
	return 0;
} 
```

---

## 作者：_Kenma_ (赞：1)

## 前言

蓝书题，很久以前口胡过。

然后写完才发现当时胡的有点假（？）

## 思路分析

看到 $t\le 10^8$，肯定是矩阵快速幂。

然后再观察每一时刻方格的石块的转移，不难发现周期长度至多为 $60$。

考虑一个经典 trick：对于每一次转移矩阵不同但是有一个较小的周期的情况，可以对整周期做矩阵快速幂，不满一个整周期的暴力乘。

现在问题在于如何构造转移矩阵 $b$。

因为 $n,m$ 都很小，考虑构造初始矩阵为：

$$\begin{bmatrix}
  a_{1,1}&  a_{1,2}&  a_{1,3}& \cdots & a_{n,m} &1
\end{bmatrix}$$

为了方便，以下把初始矩阵和转移矩阵最后一个位置的下标称为 $end$，其他位置用二元组 $(i,j)$ 表示 $i$ 行 $j$ 列。

对于任意一个 $a_{i,j} \to a_{x,y}$ 推石块的情况，我们将转移矩阵 $b_{(i,j),(x,y)} \to 1$，同时 $b_{(i,j),(i,j)}\to 0$。

类似地，对于 $a_{i,j}$ 获取石块 $x$ 块的情况，我们将转移矩阵 $b_{(end),(i,j)}\to x$，同时 $b_{(i,j),(i,j)}\to 1$。

丢失石块直接 $b_{(i,j),(i,j)}\to 0$ 就行。

不要忘记 $a_{end}=1$ 一直保持不变，所以我们需要 $b_{end,end}\to 1$。

不难感性理解，主要要分析清楚每一个时刻的石块来自于哪里。

然后会构造每个时刻的转移矩阵后，我们直接按上面的 trick 实现就行。

## 代码实现

写起来还是有一点麻烦的，需要考虑一些细节。

```cpp
#include<bits/stdc++.h>
#define id(i,j) (((i)-1)*m+(j))
#define int unsigned long long
using namespace std;
char ch;
int n,m,t,k,a[9][9],cnt[9][9],ans;
string s[11];
struct node{
	int h[66][66];
	node(){
		memset(h,0,sizeof(h));
	}
	node operator *(const node a)const{
		node ans;
		for(int k=1;k<=n*m+1;k++){
			for(int i=1;i<=n*m+1;i++){
				for(int j=1;j<=n*m+1;j++){
					ans.h[i][j]=(ans.h[i][j]+h[i][k]*a.h[k][j]);
				}
			}
		}
		return ans;
	}
}b[61],c,all,d;
node binpow(node a,int b){
	if(!b) return c;
	node res=binpow(a,b/2);
	if(b&1) return (res*res)*a;
	else return res*res; 
}
void solve(int l,int i,int j,char ch){
	if(ch>='0' && ch<='9'){
		b[l].h[n*m+1][id(i,j)]=ch-'0';
		b[l].h[id(i,j)][id(i,j)]=1;
	}else{
		if(ch=='N'){
			if(i-1) b[l].h[id(i,j)][id(i-1,j)]=1;
		}else if(ch=='W'){
			if(j-1) b[l].h[id(i,j)][id(i,j-1)]=1;
		}else if(ch=='S'){
			if(i+1<=n) b[l].h[id(i,j)][id(i+1,j)]=1;
		}else if(ch=='E'){
			if(j+1<=m) b[l].h[id(i,j)][id(i,j+1)]=1;
		}
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m>>t>>k;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>ch;
			a[i][j]=ch-'0'+1; 
		}
	}
	for(int i=1;i<=k;i++){
		cin>>s[i];
	}
	for(int l=1;l<=60;l++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				int id=a[i][j];
				solve(l,i,j,s[id][cnt[i][j]]);
				cnt[i][j]=(cnt[i][j]+1)%s[id].size();
			}
		}
	}
	for(int i=1;i<=60;i++){
		b[i].h[n*m+1][n*m+1]=1;
	}
	for(int i=1;i<=n*m+1;i++){
		c.h[i][i]=1;
	}
	d.h[1][n*m+1]=1;
	all=c;
	for(int i=1;i<=60;i++){
		all=all*b[i];
	}
	all=binpow(all,t/60);
	for(int i=1;i<=t%60;i++){
		all=all*b[i];
	}
	d=d*all;
	for(int i=1;i<=n*m;i++){
		ans=max(ans,d.h[1][i]);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：AZYDLL (赞：0)

# 思路

注意到所有的数据都是个位数，只有 $t \le 10^8$ 一骑绝尘。于是考虑使用矩阵快速幂加速递推。

本题需要进行二维的操作，即把石头推到上方格子或下方格子。但是矩阵快速幂只能处理一维的递推，即每次加上当前行的某些元素。因此我们要先把这个网格压成一维的。

具体而言，我们将 $n$ 行 $m$ 列的网格 $S$ 压成一个长度为 $n \times m+1$ 的数列 $A$，其中 $A_{(i-1) \times m+j}=S_{i,j}$，并令 $A_{n \times m+1}=1$。那么对于目标格 $A_q$，我们的操作转化为：

1. 拿 $k~(k \in [0,9])$ 个石头：将 $A_q$ 加上 $k \times A_{n \times m +1}$。

2. 左移：将 $A_{q-1}$ 加上 $A_{q}$，并将 $A_q$ 清空，右移同理。

3. 上移：将 $A_{q-m}$ 加上 $A_{q}$，并将 $A_q$ 清空，下移同理。

注意几个点：

1. 石头可以被推出网格外，相当于掉到虚空里面直接没掉。

2. 删除（移走）当前格子的石头后，当前格子可以同时接受其它格子推来的石头。

最后就是耳熟能详的套路了。由于 60 是 $1 \sim 6$ 的所有整数的公倍数，我们以 60 秒为一周期进行矩乘即可。对于不满 60 秒的部分单独暴力处理。

# 代码


```cpp
#include<bits/stdc++.h>
#define MAXN 75
#define int unsigned long long

using namespace std;
namespace FastIO
{
	inline string _rs()
	{
		string str="";
		int ch=getchar();
		while(ch==' ' || ch=='\n' || ch=='\r') ch=getchar();
		while(ch!=' ' && ch!='\n' && ch!='\r' && ch!=EOF){
			str.push_back(ch);
			ch=getchar();
		}
		return str;
	}
	inline void _ws(string a,char b)
	{
		int len=a.size();
		for(int i=0;i<len;i++) putchar(a[i]);
		putchar(b);
		return ;
	}
	inline int _r()
	{
		int flag=1,ans=0,ch=getchar();
		while((ch<'0' || ch>'9') && ch!=EOF){
			if(ch=='-') flag=-1;
			ch=getchar();
		}
		while(ch>='0' && ch<='9'){
			ans=(ans<<1)+(ans<<3)+(ch^48);
			ch=getchar();
		}
		return flag*ans;
	}
	inline void _w(int a,char b)
	{
		if(a<0) a=-a,putchar('-');
		int sta[22],top=0;
		do{
			sta[top++]=a%10;
			a/=10;
		}while(a);
		while(top) putchar(sta[--top]+48);
		putchar(b);
		return ;
	}
}
using namespace FastIO;

int n,m,n1,t,act,p[MAXN][MAXN],S1[MAXN],S[MAXN][MAXN][MAXN],A[MAXN][MAXN],B[MAXN][MAXN],ANS[MAXN][MAXN],ans;
string str,actS[MAXN];

void mul0(int pt)
{
	for(int i=1;i<=n1;i++){
		for(int j=1;j<=n1;j++){
			B[i][j]=0;
			for(int kk=1;kk<=n1;kk++) B[i][j]=(B[i][j]+A[i][kk]*S[pt][kk][j]);
		}
	}
	
	for(int i=1;i<=n1;i++) for(int j=1;j<=n1;j++) A[i][j]=B[i][j];
	return ;
}

void mul0_1(int pt)
{
	for(int i=1;i<=n1;i++){
		for(int j=1;j<=n1;j++){
			B[i][j]=0;
			for(int kk=1;kk<=n1;kk++) B[i][j]=(B[i][j]+ANS[i][kk]*S[pt][kk][j]);
		}
	}
	
	for(int i=1;i<=n1;i++) for(int j=1;j<=n1;j++) ANS[i][j]=B[i][j];
	return ;
}

void mul1()
{
	for(int i=1;i<=n1;i++){
		for(int j=1;j<=n1;j++){
			B[i][j]=0;
			for(int kk=1;kk<=n1;kk++) B[i][j]=(B[i][j]+A[i][kk]*A[kk][j]);
		}
	}
	
	for(int i=1;i<=n1;i++) for(int j=1;j<=n1;j++) A[i][j]=B[i][j];
	return ;
}

void mul2()
{
	for(int i=1;i<=n1;i++){
		for(int j=1;j<=n1;j++){
			B[i][j]=0;
			for(int kk=1;kk<=n1;kk++) B[i][j]=(B[i][j]+ANS[i][kk]*A[kk][j]);
		}
	}
	
	for(int i=1;i<=n1;i++) for(int j=1;j<=n1;j++) ANS[i][j]=B[i][j];
	return ;
}

void init()
{
	n1=n*m+1;
	for(int x=1;x<=n;x++){
		for(int y=1;y<=m;y++){
			int pt=(x-1)*m+y;
			int len=actS[p[x][y]].size()-1,tms=60/len;
			for(int i=1;i<=tms;i++){
				for(int j=1;j<=len;j++){
					int p1=(i-1)*len+j;
					if(actS[p[x][y]][j]>='0' && actS[p[x][y]][j]<='9') S[p1][n1][pt]=actS[p[x][y]][j]-'0',S[p1][pt][pt]=1;
					else if(actS[p[x][y]][j]=='N' && pt-m>0) S[p1][pt][pt-m]=1;
					else if(actS[p[x][y]][j]=='S' && pt+m<n1) S[p1][pt][pt+m]=1;
					else if(actS[p[x][y]][j]=='W' && pt-1>=(x-1)*m+1) S[p1][pt][pt-1]=1;
					else if(actS[p[x][y]][j]=='E' && pt+1<=(x-1)*m+m) S[p1][pt][pt+1]=1;
					else continue;
				}
			}
		}
	}
	
	for(int i=1;i<=60;i++) S[i][n1][n1]=1;
	for(int i=1;i<=n1;i++) A[i][i]=1,ANS[i][i]=1;
	for(int i=1;i<=60;i++) mul0(i);
	return ;
}

void Fpow()
{
	init();
	int pw=t/60,pw1=t%60;
	while(pw){
		if(pw&1) mul2();
		mul1();
		pw=pw>>1;
	}
	
	for(int i=1;i<=pw1;i++) mul0_1(i);
	return ;
}

signed main()
{
	n=_r(),m=_r(),t=_r(),act=_r();
	for(int i=1;i<=n;i++){
		str=" "+_rs();
		int len=str.size()-1;
		for(int j=1;j<=len;j++) p[i][j]=str[j]-'0';
	}
	for(int i=0;i<act;i++) actS[i]=" "+_rs();
	
	Fpow();
	ans=0;
	for(int i=1;i<n1;i++) ans=max(ans,ANS[n1][i]);
	_w(ans,'\n');
	
	return 0;
}
```

---


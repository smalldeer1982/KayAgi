# [蓝桥杯 2024 国 A] 重复的串

## 题目描述

给定一个仅含小写字母的字符串 $S$，问有多少个长度为 $n$ 的仅含小写字母的字符串中恰好出现了两次 $S$。答案对 $998\ 244\ 353$ 取模。

## 说明/提示

对于 $40\%$ 的评测用例，$n \le 20$，$|S| \le 6$；  
另有 $10\%$ 的评测用例，$n\le 500$，$|S| \le 2$；  
对于 $70\%$ 的评测用例，$n\le 10^5$；  
对于所有评测用例，$1\le n\le 10^9$，$1 \le |S| \le 30$。

## 样例 #1

### 输入

```
aba 6```

### 输出

```
53```

## 样例 #2

### 输入

```
aba 10```

### 输出

```
77907666```

# 题解

## 作者：_LRH_ (赞：39)

- ## 题意

  求出长度为n且恰好出现两次原串的字符串个数

- ## 思路

  我们可以定义状态 ${f_{l,e,i}}$ 表示当前字符串长度为 $l$ 匹配了 $e$ 次已经匹配到了第 $i$ 位的方案数

  匹配问题我们自然可以想到使用 KMP 来做这件事

  所以我们可以枚举当前填的字母并完成转移，如何转移这里读者可以思考一会

  我们可以很自然的发现 $f_{l,e,i}$ 只从长度为 $l-1$ 的状态转移而来，并且每次转移的方式都是一样的。所以我们考虑使用矩阵乘法优化这个转移

  我们可以枚举当前已经匹配到了第 $i$ 位，匹配了$e$ 次，下一个字母填什么，然后使用 kmp 得到它可以转移到的状态匹配到了第多少位，匹配了多少次。

  我们可以赋给每种这样的状态一个下标，如果 $j$ 可以转化到 $k$ 那么图大概长这样

  ![](https://cdn.luogu.com.cn/upload/image_hosting/t7gftkac.png)

  所以我们可以发现每一次转移都乘上了这个中间的矩阵,故我们可以使用矩阵快速幂解决这个问题

- ## 代码
  
```cpp

#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int N = 105, mod = 998244353;

int n, m, len, nxt[N];

string s;

struct S {
	ll a[N][N];
} dis, ans;

S operator * (const S &A, const S &B) {
	S C;
	for (ll i = 0; i <= m; i++) {
		for (ll j = 0; j <= m; j++) {
			ll s = 0;
			for (ll k = 0; k <= m; k++) {
				s = (A.a[i][k] * B.a[k][j] % mod + s) % mod;
			}
			C.a[i][j] = s;
		}
	}
	return C;
} //矩阵乘法 

int id(int x, int y) {
	return y * (len + 1) + x;
}  //赋予一个状态编号 

void D(int x) {
	ans.a[0][0] = 1; //初始只有转移到0匹配了0次才是1 
	for (; x; x /= 2, dis = dis * dis) {
		if (x & 1) {
			ans = ans * dis;
		}
	}
}

int main() {
	cin >> s >> n;
	len = s.size();
	s = " " + s + "*";
	
	for (int i = 2, j = 0; i <= len; i++) {
		for (; j && s[i] != s[j + 1]; j = nxt[j]) {
		}
		j = nxt[i] = j + (s[i] == s[j + 1]);
	}
	
	//kmp模板 
	
	m = 3 * (len + 1);
	
	//注意这里是len+1因为是从0到len的
	 
	for (int i = 0; i <= len; i++) {    //枚举匹配到的位置 
		for (int e = 0; e <= 2; e++) {  //枚举匹配的次数 
			for (char ch = 'a'; ch <= 'z'; ch++) { //枚举下一个字母 
			    int j = i;
				for (; j && ch != s[j + 1]; j = nxt[j]) {
				} 				
				j += (ch == s[j + 1]); // 算出下一个状态匹配到的位置 
				if (j == len) {
					if (e == 2) {
						continue;
					}                 //我们需要的是恰好两次故超过的不算 
					dis.a[id(i, e)][id(j, e + 1)]++;
				} else {
					dis.a[id(i, e)][id(j, e)]++;
				}
			}
		}
	}
	
	D(n);
	ll sum = 0; 
	for (int i = 0; i <= len; i++) {
		sum += ans.a[0][i + (2 * (len + 1))];  
		sum %= mod;
	} //统计答案 
	
	cout << sum % mod;
	return 0;
}

---

## 作者：Rindong (赞：7)

# 思路

看到字符串匹配，方案数关键字，自然想到 dp 与 kmp 算法的结合，看到 $n$ 的数量比较大，不用慌，先把朴素的方程想出来再优化。

一般地可以想到方程 $dp[i][j][k]$ 为字符串序列长度为 $i$ 并且当前匹配到模式串的长度为 $j$ ，总匹配次数恰好为 $k$ 次的方案数。转移的方式就是，我们枚举每个 $i, j, k$ 再枚举当前状态下填的字母，通过 kmp 进行匹配，计算出下一个可转移的状态。代码：

```cpp
dp[0][0][0] = 1;
for (int i = 0; i < n; i++)
	for (int k = 0; k <= 2; k++)
		for (int j = 0; j < m; j++) //枚举每个状态
			for (char ch = 'a'; ch <= 'z'; ch++) { //枚举当前状态填的字母
				int st = j;
        // nex 数组预处理过程省略
				while (st && str[st + 1] != ch) st = nex[st];
				if (str[st + 1] == ch) st++;
				if (st == m) { //如果完全匹配成功可转移到 k + 1
					dp[i + 1][nex[st]][k + 1] = (dp[i + 1][nex[st]][k + 1] + dp[i][j][k]) % MOD;
				}
				else dp[i + 1][st][k] = (dp[i + 1][st][k] + dp[i][j][k]) % MOD;
			}
ans = 所有j的dp[n][j][2]之和;
```

上面的方程可以通过一部分的数据，但我们可以做的更好。

通过观察发现，对于每个 $j$ 填的下一个字母，它可以转移的状态是固定的！比如样例中的 ```aba``` 在 $j = 0$ 的情况下，不管 $i, k$ 是多少，只要填字母 a 就最终总是会到达状态 $j = 1$；只要填字母 b 总是会到状态 $j = 0$。于是，我们就考虑使用矩阵加速递推，关于矩阵加速递推可以参考 [OI-WIKI](https://oi-wiki.org/math/linear-algebra/matrix/#%E7%9F%A9%E9%98%B5%E5%8A%A0%E9%80%9F%E9%80%92%E6%8E%A8)。

# 代码

```cpp
#include <iostream>
#include <string.h>
using namespace std;
#define MAX_N 105
#define ll long long
const ll MOD = 998244353LL;
char str[MAX_N];
int nex[MAX_N] = { 0 };
ll arr[MAX_N][MAX_N] = { 0 };
ll temp[MAX_N][MAX_N] = { 0 };
ll ret[MAX_N][MAX_N] = { 0 };
//矩阵乘法
void multi(ll a[MAX_N][MAX_N], ll b[MAX_N][MAX_N], int n, int m, int k) {
	memset(temp, 0, sizeof temp);
	for (int i = 0; i < n; i++)
		for (int c = 0; c < k; c++)
			for (int r = 0; r < m; r++)
				temp[i][c] = (temp[i][c] + a[i][r] * b[r][c] % MOD) % MOD;
	memcpy(a, temp, sizeof temp);
}
//矩阵快速幂
void quick_mi(ll b, int n) {
	while (b) {
		if (b % 2) multi(ret, arr, n, n, n);
		multi(arr, arr, n, n, n);
		b /= 2;
	}
}
int n, m;
void get_nex() {
	nex[0] = nex[1] = 0;
	for (int i = 2, j; i <= m; i++) {
		j = i - 1;
		while (j && str[nex[j] + 1] != str[i]) j = nex[j];
		if (j) nex[i] = nex[j] + 1;
		else nex[i] = 0;
	}
}
//给每个状态分配一个下标
int get_ind(int j, int k) {
	return j + k * (m + 1);
}
ll matrix[MAX_N][MAX_N] = { 0 };
int main() {
	scanf("%s", str + 1);
	scanf("%d", &n);
	m = strlen(str + 1);
	get_nex();
	//初始化单位矩阵
	for (int x = 0; x < (m + 1) * 3; x++)
		ret[x][x] = 1;
	for (int k = 0; k <= 2; k++)
		for (int j = 0; j < m; j++)
			for (char ch = 'a'; ch <= 'z'; ch++) {
				int st = j;
				while (st && str[st + 1] != ch) st = nex[st];
				if (str[st + 1] == ch) st++;
				if (st == m) {
					if (k != 2) arr[get_ind(j, k)][get_ind(nex[st], k + 1)]++;
				}
				else arr[get_ind(j, k)][get_ind(st, k)]++;
			}
	matrix[0][get_ind(0, 0)] = 1;
	quick_mi(n, (m + 1) * 3);
	multi(matrix, ret, 1, (m + 1) * 3, (m + 1) * 3);
	ll ans = 0;
	for (int j = 0; j <= m; j++)
		ans = (ans + matrix[0][get_ind(j, 2)]) % MOD;
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：ZHR100102 (赞：3)

一道 KMP + dp 的板子题。

# 暴力 dp

设计 $dp_{k,i,j}$ 表示主串匹配到第 $i$ 位，模式串有 $j$ 位已匹配完成，目前已完成 $k$ 次匹配的方案数。


不难写出暴力的填表法转移式子，发现是平方级别的转移，所以使用填表法不行，我们尝试刷表法。

$dp_{k,i,j}$ 要转移去的地方显然是第 $i+1$ 位，于是我们要观察 $j$ 里哪些是合法的，很容易就想到用 KMP 加速这个过程，因为 KMP 做的也是匹配到某一位后，求出下一位的最大匹配长度。

假设 $m$ 为模式串的长度。

对于 $dp_{k,i,j}$ 我们枚举第 $i+1$ 位的字符是什么，依次和当前需要匹配的字符进行比较，然后用 KMP 的 next 数组求出下一位的最大匹配长度 $l$：
- 当最大匹配长度为 $m$ 时，这时候 $k$ 就要 $+1$，所以 $dp_{k+1,i+1,next_l} \gets dp_{k+1,i+1,next_l}+dp_{k,i,j}$。
- 当最大匹配长度小于 $m$ 时，直接转移即可，$dp_{k,i+1,l} \gets dp_{k,i+1,l}+dp_{k,i,j}$。

时间复杂度是 $O(k|\sum|n)$ 的，显然不可过。

# 矩阵优化

发现当值域非常大的 $i$ 确定时，剩下两维的数量很小，只有 $90$ 个值左右，考虑矩阵优化 dp。

我们把 $i$ 这一位提取到前面来，作为快速幂的幂次即可。

构造矩阵有点难描述，看代码吧，大体就是做一遍上面的那个转移，注意细节问题就好了。

另外，当 $j=m$ 时，不能进行转移。

时间复杂度 $O((k|\sum|)^3 \log n)$。

# 代码

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define lc (p<<1)
#define rc ((p<<1)|1)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pi;
const ll mod=998244353;
int n,ne[35],m;
char c[35];
struct mat{
    ll a[105][105];
    mat(){memset(a,0,sizeof(a));}
    mat operator*(const mat &t)const{
        mat res;
        for(int i=0;i<=100;i++)
        {
            for(int k=0;k<=100;k++)
            {
                for(int j=0;j<=100;j++)
                {
                    res.a[i][j]=(res.a[i][j]+a[i][k]*t.a[k][j])%mod;
                }
            }
        }
        return res;
    }
};
void construct_dp(mat &dp)
{
    for(int lv=0;lv<=2;lv++)
    {
        int ns=1+lv*(m+1);
        for(int i=ns;i<ns+m;i++)
        {
            for(int j=0;j<26;j++)
            {
                char nc=('a'+j);
                int now=i-ns;
                while(now&&nc!=c[now+1])now=ne[now];
                if(nc==c[now+1])now++;
                if(now==m)
                {
                    if(lv==2)continue;
                    now=ne[now];
                    dp.a[i][ns+m+1+now]=(dp.a[i][ns+m+1+now]+1)%mod;
                }
                else dp.a[i][ns+now]=(dp.a[i][ns+now]+1)%mod;
            }
        }    
    }
}
void construct_init(mat &s){s.a[1][1]=1;}
mat qpow(mat a,ll b)
{
    mat res;
    for(int i=0;i<=100;i++)res.a[i][i]=1;
    while(b)
    {
        if(b&1)res=res*a;
        a=a*a;
        b>>=1;
    }
    return res;
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>c+1>>n;
    m=strlen(c+1);
    int now=0;
    for(int i=2;i<=m;i++)
    {
        while(now&&c[now+1]!=c[i])now=ne[now];
        if(c[now+1]==c[i])now++;
        ne[i]=now;
    }
    mat dp;
    construct_dp(dp);
    mat s;
    construct_init(s);
    dp=s*qpow(dp,n);
    ll ans=0;
    for(int i=1+2*(m+1);i<1+3*(m+1);i++)ans=(ans+dp.a[1][i])%mod;
    cout<<ans;
    return 0;
}
```

---

## 作者：MPLN (赞：0)

非常经典的 KMP+DP。

参考 KMP 的匹配，我们设 $f_{i,j,k}$ 表示考虑了最终字符串的前 $i$ 位，目前最长与模式串 $S$ 前缀相同的后缀长度为 $j$（与 KMP 相同），然后文本串已经出现了 $k$ 次 $S$，此时有多少种字符串。

转移到 $f_{i+1}$ 的时候只需要枚举下一位是什么字母即可，对 $j$ 这一维的转移直接结合原来的 $j$、当前字符 $c$ 和预处理好的 nxt 数组跑 KMP 的匹配部分。

为什么可以这么做？我们观察 KMP 的本质，求出最长匹配后缀之和原**来的匹配长度**与**当前字符**有关，这也是我们这样设计状态的原因。

记得特判匹配完了的情况，就是 $f_{i+1,nxt_{lenS},k+1}\gets f_{i,lenS-1,k}$，且当前字符也匹配。

接着容易发现 $i\le 10^9$，$j\le 30$，$k\le 2$。并且关键性质是满足 $dp_{i+1}$ 只从 $dp_{i}$ 转移，且与 $i$ 具体是多少没有关系。那么搞个矩阵存 $j,k$ 的转移矩阵，然后跑矩阵快速幂优化 DP 即可。

最终答案是 $\sum dp_{n,j,2}$。

时间复杂度 $O(V|S|+|S|^3 \operatorname{log} n)$，$V$ 为字符集大小。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int MOD=998244353;
void upd(int &x,int y){x=(x+y)%MOD;}
int gid(int x,int y){return x*3+y+1;}
int n,len,nxt[35];
char s[35];
struct matrix{
    int a[105][105],n,m;
    void init(int l){
        n=m=l;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(i==j) a[i][j]=1;
                else a[i][j]=0;
            }
        }
    }
    void genz(){
        n=m=3*len;
        for(int i=0;i<len;i++){
            for(int j=0;j<=2;j++){
                for(char c='a';c<='z';c++){
                    int tmp=i;
                    while(tmp&&c!=s[tmp+1]) tmp=nxt[tmp];
                    if(c==s[tmp+1]) tmp++;
                    if(tmp==len&&j<2) a[gid(i,j)][gid(nxt[len],j+1)]++;
                    else if(tmp<len) a[gid(i,j)][gid(tmp,j)]++;
                }
            }
        }
    }
    matrix operator*(const matrix &x)const{
        matrix res;
        res.n=n,res.m=x.m;
        for(int i=1;i<=res.n;i++){
            for(int j=1;j<=res.m;j++){
                res.a[i][j]=0;
                for(int k=1;k<=m;k++){
                    upd(res.a[i][j],a[i][k]*x.a[k][j]%MOD);
                }
            }
        }
        return res;
    }
};
matrix qpow(matrix a,int b){
    matrix res;
    res.init(a.n);
    while(b){
        if(b&1) res=res*a;
        a=a*a,b>>=1;
    }
    return res;
}
signed main(){
    cin>>(s+1)>>n;
    len=strlen(s+1);
    nxt[1]=0;
    for(int i=2,j=0;i<=len;i++){
        while(j&&s[i]!=s[j+1]) j=nxt[j];
        if(s[i]==s[j+1]) j++;
        nxt[i]=j;
    }
    matrix st;
    st.n=1,st.m=3*len,st.a[1][1]=1;
    matrix z; z.genz();
    st=st*qpow(z,n);
    int ans=0;
    for(int i=0;i<len;i++){
        upd(ans,st.a[1][gid(i,2)]);
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：_yang_yi_bo_ (赞：0)

感觉题解区讲得够详细了。

再补充一点小细节。

首先考虑 $n\le 10^5$ 的时候，暴力的写法。

我们定义 $dp_{i,j,k}$ 表示我们算了字符串的前 $i$ 位（注意是计算方案数的字符串，不是原字符串），匹配成功了输入的字符串 $j$ 次（包括之前的匹配成功）后又在末尾处匹配了前 $k$ 位（也就是说，输入的字符串的长度为 $k$ 的前缀是计算方案数的字符串的长度为 $k$ 的后缀）。

此时我们需要计算的是加入 $i$ 后的 $k$。

枚举 $i$ 加入的字符，我们需要找原字符串 $k-1$ 的长度的前缀的一个公共前后缀（可以为原串），使得加入的字符可以和第 $k$ 个字符匹配。

公共前后缀可以枚举去求，也可以使用 KMP 去求最长公共前后缀，一直枚举最长公共前后缀的最长公共前后缀即可。

注意当匹配完成了 $j$ 要加一，$k$ 为原字符串的最长公共前后缀（注意这个最长公共前后缀不包含原串）。

这里是暴力代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e5 + 5, mod = 998244353;
int n, len;
string s;
int dp[100005][5][35];
int nxt[35];
void getnxt(string s) {
  nxt[0] = -1;
  int i = 0, j = -1;
  while (i < s.size()) {
    if (j == -1 || s[i] == s[j]) {
      i++, j++, nxt[i] = j;
    } else {
      j = nxt[j];
    }
  }
}
signed main() {
  cin >> s >> n;
  dp[0][0][0] = 1;
  getnxt(s);
  len = s.size();
  // cout << nxt[1] << " ";
  s = " " + s;
  for (int i = 1; i <= n; i++) {
    for (int j = 'a'; j <= 'z'; j++) {
      for (int k = 0; k < len; k++) {
        for (int l = 0; l <= 2; l++) {
          int x = k;
          while (x >= 0 && j != s[x + 1]) {
            x = nxt[x];
          }
          if (x + 1 == len) {
            dp[i][l + 1][nxt[len]] += dp[i - 1][l][k];
            continue;
          }
          dp[i][l][x + 1] += dp[i - 1][l][k];
          dp[i][l][x + 1] %= mod;
        }
      }
    }
  }
  int ans = 0;
  for (int i = 0; i < len; i++) {
    // cout << dp[n][2][i] << " ";
    ans += dp[n][2][i];
    ans %= mod;
  }
  cout << ans;
  return 0;
}
/*
ababa

aba
*/
```

由于我们的转移只会从 $i-1$ 转移过来，考虑矩阵快速幂优化。

将二维的状态通过哈希的方式变成一位的状态方便矩阵快速幂。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e5 + 5, mod = 998244353;
int n, len;
string s;
int dp[100005][5][35];
int nxt[35];
void getnxt(string s) {
  nxt[0] = -1;
  int i = 0, j = -1;
  while (i < s.size()) {
    if (j == -1 || s[i] == s[j]) {
      i++, j++, nxt[i] = j;
    } else {
      j = nxt[j];
    }
  }
}
int getsum(int x, int y) {
  return x * (len + 1) + y;
}
struct kkk {
  int n, m;
  int a[105][105];
  kkk(int x, int y) : n(x), m(y) {
    memset(a, 0, sizeof(a));
  }
  kkk operator*(const kkk &b) const {
    kkk c(n, b.m);
    for (int i = 0; i <= n; i++) {
      for (int j = 0; j <= b.m; j++) {
        for (int k = 0; k <= m; k++) {
          c.a[i][j] = (c.a[i][j] + a[i][k] * b.a[k][j]) % mod;
        }
      }
    }
    return c;
  }
};
kkk qpow(kkk a, int b) {
  kkk ans(a.n, a.n);
  for (int i = 0; i <= a.n; i++) ans.a[i][i] = 1;
  // for (int i = 0; i <= a.n; i++) {
  //   for (int j = 0; j <= a.n; j++) {
  //     cout << a.a[i][j] << " ";
  //   }
  //   cout << "\n";
  // }
  while (b) {
    if (b & 1) ans = ans * a;
    a = a * a;
    b >>= 1;
  }
  // for (int i = 0; i <= ans.n; i++) {
  //   for (int j = 0; j <= ans.n; j++) {
  //     cout << ans.a[i][j] << " ";
  //   }
  //   cout << "\n";
  // }
  return ans;
}
signed main() {
  cin >> s >> n;
  dp[0][0][0] = 1;
  getnxt(s);
  len = s.size();
  // cout << nxt[1] << " ";
  s = " " + s;
  kkk a(getsum(2, len), getsum(2, len));
  for (int j = 'a'; j <= 'z'; j++) {
    for (int k = 0; k < len; k++) {
      for (int l = 0; l <= 2; l++) {
        int x = k;
        while (x >= 0 && j != s[x + 1]) {
          x = nxt[x];
        }
        if (x + 1 == len) {
          // cout << l << " " << k << " " << l + 1 << " " << nxt[len] << "\n";
          a.a[getsum(l, k)][getsum(l + 1, nxt[len])]++;
          continue;
        }
        a.a[getsum(l, k)][getsum(l, x + 1)]++;
      }
    }
  }
  kkk ans(0, getsum(2, len));
  ans.a[0][0] = 1;
  ans = ans * qpow(a, n);
  int sum = 0;
  for (int i = 0; i < len; i++) sum = (sum + ans.a[0][getsum(2, i)]) % mod;
  cout << sum;
  return 0;
}
/*
ababa

aba
*/
```

---


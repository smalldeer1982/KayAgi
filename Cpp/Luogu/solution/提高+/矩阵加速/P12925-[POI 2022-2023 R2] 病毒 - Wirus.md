# [POI 2022/2023 R2] 病毒 / Wirus

## 题目背景

翻译来自于 [LibreOJ](https://loj.ac/p/5020)。

## 题目描述

**题目译自 [XXX Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi30-2/dashboard/) [Wirus](https://szkopul.edu.pl/problemset/problem/c9kbLOJVLHiQDcmiNo8Pa4w6/statement/)**

Bajtosia 在 Bajtocja 最先进的生物实验室工作，她的团队研究一种新型病毒。该病毒的基因型仅由两种基因组成，记为 $0$ 和 $1$，总计 $n$ 个基因，可表示为序列 $(X_1, X_2, \ldots, X_n)$，其中每个 $X_i$ 为 $0$ 或 $1$。

不幸的是，这种病毒以独特但规律的方式变异。每天，左侧第一个基因 $X_1$ 脱离，变为 $X_1 \oplus X_2$（$\oplus$ 表示异或运算），然后附着到序列右侧。因此，基因型 $(X_1, X_2, \ldots, X_n)$ 变异后为 $(X_2, X_3, \ldots, X_n, X_1 \oplus X_2)$。

Bajtosia 需要预测病毒在 $d$ 天后的基因型。你能帮助她吗？

## 说明/提示

**样例 1 解释**

病毒基因型每日变化如下：

$$
01010 \to 10101 \to 01011 \to 10111 \to 01111
$$

**附加样例**

1. $n=10, d=30$，初始基因型 $1010000101$，答案为 $0110110110$。  
2. $n=100, d=2000000$，初始基因型 $000\ldots000$，答案为 $000\ldots000$。  
3. $n=700, d=10^{15}$，初始基因型 $111\ldots111$。

详细子任务附加限制及分值如下表所示。

| 子任务编号 | 附加限制 | 分值 |
| :---: | :--: | :---: |
| $1$    | $d \leq 100$             | $7$  |
| $2$    | $d \leq 2000000$         | $12$ |
| $3$    | $n \leq 100$             | $65$ |
| $4$    | 无附加限制               | $16$ |

## 样例 #1

### 输入

```
5 4
01010```

### 输出

```
01111```

# 题解

## 作者：liuchuliang666 (赞：0)

整个操作可以分为两步：

1. 将序列左移一次；
2. 异或。

而这两个操作都是类似线性递推的形式，我们考虑使用 $0/1$ 矩阵快速幂进行加速。

记向量 $\boldsymbol{p} = \begin{bmatrix}
    a_1 \\
    a_2 \\
    a_3 \\
    a_4 \\
    \vdots \\
    a_n
\end{bmatrix}$，容易得到交换矩阵 $\boldsymbol{M_1} = \begin{bmatrix}
    0 & 1 & 0 & 0 & \ldots & 0 \\
    0 & 0 & 1 & 0 & \ldots & 0 \\
    0 & 0 & 0 & 1 & \ldots & 0 \\
    0 & 0 & 0 & 0 & \ldots & 0 \\
    \vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\
    1 & 0 & 0 & 0 & \ldots & 0 \\
\end{bmatrix}$ 和异或矩阵 $\boldsymbol{M_2} = \begin{bmatrix}
    1 & 0 & 0 & 0 & \ldots & 0 \\
    0 & 1 & 0 & 0 & \ldots & 0 \\
    0 & 0 & 1 & 0 & \ldots & 0 \\
    0 & 0 & 0 & 1 & \ldots & 0 \\
    \vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\
    1 & 0 & 0 & 0 & \ldots & 1 \\
\end{bmatrix}$，那么 $\boldsymbol{q} = (\boldsymbol{M_2} \cdot \boldsymbol{M_1}) ^ d \cdot \boldsymbol{p}$ 就是答案向量，矩阵快速幂即可。

如果你使用常规的矩阵快速幂，那么复杂度是 $O(n ^ 3 \log d)$ 的，会 T。

我们发现 $0/1$ 矩阵乘法可以使用 `bitset` 优化，那么就是 $O\left(\frac{n ^ 3 \log d}{w}\right)$ 的，可以通过。

```cpp
#include <bits/stdc++.h>
using namespace std;
#ifdef ONLINE_JUDGE
#define debug(...)
#else
#define debug(...) fprintf(stderr, ##__VA_ARGS__)
#endif
#define endl '\n'
#define eb emplace_back
#define ep emplace
#define fi first
#define se second
#define rep(i, l, r, ...) for (int i = (l), i##e = (r), ##__VA_ARGS__; i <= i##e; ++i)
#define per(i, r, l, ...) for (int i = (r), i##e = (l), ##__VA_ARGS__; i >= i##e; --i)
#define mst(x, val, len) memset(x, val, sizeof((x)[0]) * (int(len) + 1))
#define mcp(from, to, len) memcpy(to, from, sizeof((to)[0]) * (int(len) + 1))
#define Mst(x, val) memset(x, val, sizeof(x))
#define Mcp(from, to) memcpy(to, from, sizeof(from))
#define mid (((l) + (r)) >> 1)
#define ls ((x) << 1)
#define rs ((x) << 1 | 1)
#define lson ls, l, mid
#define rson rs, mid + 1, r
#define pbds __gnu_pbds
#define int ll
typedef long long ll;
#define vi vector<int>
#define pii pair<int, int>
#define vpii vector<pii>
#define Add(a, b) ((a) = (((a) + (b)) % mod + mod) % mod)
#define Mul(a, b) ((a) = (((a) * (b)) % mod + mod) % mod)
#define add(a, b) (((a) += (b)) >= mod ? (a) -= mod : (a))
#define mul(a, b) (((a) *= (b)) %= mod)
constexpr int MAXN = 700 + 10, inf = 1e9, mod = 998244353, MAXV = MAXN << 2;
template <typename T> inline void chkmx(T &a, const T b) { a = a < b ? b : a; }
template <typename T> inline void chkmn(T &a, const T b) { a = a > b ? b : a; }
int lowbit(int x) { return x & (-x); }
int qpow(int a, int b)
{
    static int res;
    for (res = 1; b; b >>= 1, mul(a, a)) ((b & 1) && mul(res, a));
    return res;
}
int inv(int x) { return qpow(x, mod - 2); }
struct Mat
{
    int n, m;
    bitset<MAXN> val[MAXN];
    bitset<MAXN> &operator[](int x) { return val[x]; }
    Mat(int n = 0, int m = 0) : n(n), m(m), val{} {}
    void init() { rep(i, 1, min(n, m)) val[i][i] = 1; }
    friend Mat operator*(Mat a, Mat b)
    {
        Mat c{a.n, b.m};
        rep(i, 1, a.n) rep(k, 1, a.m) if (a[i][k]) c[i] ^= b[k];
        return c;
    }
};
Mat qpow(Mat a, int b)
{
    Mat res{a.n, a.m};
    for (res.init(); b; b >>= 1, a = a * a)
        if (b & 1) res = res * a;
    return res;
}
bool MST;
int n, d;
string s;
bool MED;
signed main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    debug("Memory Used: %.2lf Mib.\n", (&MST - &MED) / 1024. / 1024.);
    cin >> n >> d >> s;
    Mat tr{n, n}, rt{n, n}, p{n, 1}; // tr is used to swap, rt is used to xor
    rep(i, 1, n - 1) tr[i][i + 1] = 1;
    tr[n][1] = 1, rt.init(), rt[n][1] = 1;
    rep(i, 1, n) p[i][1] = s[i - 1] - '0';
    p = qpow(rt * tr, d) * p;
    rep(i, 1, n) cout << int(p[i][1]);
    return 0;
}
```

---

## 作者：IntoTheDusk (赞：0)

> 给定一个长度为 $n$ 的序列 $a_{1 \dots n}$，其中 $\forall 1 \le i \le n,a_i \le \{0,1\}$。现在进行 $d$ 次操作，每次操作将 $a$ 由 $[a_1,a_2,\dots,a_{n-1},a_n]$ 变为 $[a_2,a_3,\dots,a_n,a_1 \bigoplus a_2]$（其中 $\bigoplus$ 表示按位异或）。求 $d$ 次操作后的序列 $a$。
>
> $2 \le n \le 700,1 \le d \le 10^{15},3.0\rm{s},512\rm{MiB}$。

事实上，由于本题中的值域为 $[0,1]$，我们可以将异或视为对 $2$ 取模的加法。此时，我们不难注意到，本题的一次操作可以被视为一次线性变换。事实上，我们可以构造出一个 $n \times n$ 的矩阵 $M$ 来描述这一变换：

$$
M=
\begin{bmatrix}
0 & 1 & 0 & 0 & 0 & \ldots & 0 \\
0 & 0 & 1 & 0 & 0 & \ldots & 0 \\
0 & 0 & 0 & 1 & 0 & \ldots & 0 \\
0 & 0 & 0 & 0 & 1 & \ldots & 0 \\
\vdots & \vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\
0 & 0 & 0 & 0 & 0 & \ldots & 1 \\
1 & 1 & 0 & 0 & 0 & \ldots & 0 \\
\end{bmatrix}
$$

令向量 $\textbf{v}={\begin{bmatrix}a_1 & a_2 & \ldots & a_n\end{bmatrix}}^{T}$，则答案即为 $M^d\textbf{v}$。

我们可以直接采用矩阵快速幂算法，时间复杂度为 $O\left(n^3 \log k\right)$。然而，这一做法在 $n$ 为 $700$ 时难以通过，需要进一步优化。

事实上，对于 $01$ 矩阵乘法的问题，我们完全可以用 $\rm{bitset}$ 加速矩阵乘法。时间复杂度 $O\left(\frac{n^3 \log k}{\omega}\right)$。

[评测记录](https://www.luogu.com.cn/record/224634374)

---


# 帕秋莉的手环

## 题目背景

帕秋莉是蕾米莉亚很早结识的朋友，现在住在红魔馆地下的大图书馆里。不仅擅长许多魔法，还每天都会开发出新的魔法。只是身体比较弱，因为哮喘，会在咏唱符卡时遇到麻烦。

她所用的属性魔法，主要是生命和觉醒的“木”，变化和活动的“火”，基础和不动的“土”，果实和丰收的“金”，寂静和净化的“水”，机动和攻击的“日”，被动和防御的“月”七种属性

没有窗户的图书馆或许充满了灰尘，不过她认为在书旁边才是自己，所以她不能从书的旁边离开。这样已经一百年了。

## 题目描述

经过数年魔法的沉淀，帕秋莉将她那浩瀚无边的魔法的一部分浓缩到了一些特质的珠子中。

由于帕秋莉爱好和平，她只把象征生命和觉醒的木属性魔法和果实和丰收的金属性魔法放入了珠子中。

她认为光要这些珠子没有什么用处，于是她想将这些珠子串成魔法手环，这样就好看多了。于是，她拿出来用来串这些珠子的线 - 雾雨灵径。

她将这些珠子串到一起之后发现了一些性质：只要相邻珠子间的两个珠子中有一个是金属性的，那么它们之间的雾雨灵径的颜色就为金色。

帕秋莉想要一个全都是金色的手环，而且她还想知道一共有多少种方案。由于她还要研究新的魔法，她就把这件事交给了你。由于她的魔法浩瀚无边，她有无穷的珠子。

她并不想看着好几十位的数字，于是你需要对 $1000000007$ 进行取模。

## 说明/提示

这里给出 $n = 5$ 时，样例的解释：


使用 $1, 2, 3, 4, 5$ 来代表各个珠子。

可行的方案是（其中的数字代表染成金元素的珠子序号）：

$\{1, 3, 5\}, \{1, 2, 4\}, \{1, 3, 4\}, \{2, 3, 5\}, \{2, 4, 5\}$

$\{1, 2, 3, 4\}, \{1, 2, 3, 5\}, \{1, 2, 4, 5\}, \{1, 3, 4, 5\}, \{2, 3, 4, 5\}$

$\{1, 2, 3, 4, 5\}$



对于 $20\%$ 的数据，有 $1 \le n \le 10$ ；

对于 $40\%$ 的数据，有 $1 \le n \le 10^2$ ；

对于 $60\%$ 的数据，有 $1\le n \le 10^6$ ；

对于 $90\%$ 的数据，有 $1 \le n \le 10^9$ ；

对于全部的数据，有 $1\le T \le 10,  1\le n \le 10^{18}$。

## 样例 #1

### 输入

```
2
5
20```

### 输出

```
11
15127```

## 样例 #2

### 输入

```
3
9
99
999```

### 输出

```
76
281781445
445494875```

## 样例 #3

### 输入

```
5  
123
1234
12345
123456
1234567```

### 输出

```
528790589
200102666
537707871
262341000
534036342
```

# 题解

## 作者：liangbowen (赞：36)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P4910)

[更好的阅读体验？](https://www.cnblogs.com/liangbowen/p/16945276.html)

矩阵快速幂优化 DP 经典题。

前置知识：会做简单的 DP、矩阵加速。

## 题目简述

给定一个长度为 $n$ 的环，每个位置可以填 $1$ 或 $2$。相邻两个不能同时填 $1$。

求方案数。多测。

## 朴素 DP

### 思路

看到题目，很容易想到环形 DP。

设 $dp_{i, 0}$ 表示第 $i$ 位填 $1$ 的总方案数，$dp_{i, 1}$ 表示第 $i$ 位填 $2$ 的总方案数。

状态转移方程如下：

+ 第 $i$ 位填 $1$，则上一位只能填 $2$。所以 $dp_{i, 0} = dp_{i - 1, 1}$。
+ 第 $i$ 位填 $2$，则上一位可以填 $1$ 或 $2$。所以 $dp_{i, 1} = dp_{i - 1, 0} + dp_{i - 1, 1}$。

初始化要分类讨论一下：

+ 如果第 $1$ 位填 $1$，则第 $n$ 位只能填 $2$。所以答案算上 $dp_{n, 1}$。
+ 如果第 $1$ 位填 $2$，则第 $n$ 位可以填 $1$ 或 $2$。所以答案算上 $dp_{n, 0} + dp_{n, 1}$。

把公式抄上去即可。时间复杂度 $O(n)$。

### 代码

按照题目的应该是可以拿 $60$ 分的。但是只有 $48$ 分。

[提交记录](https://www.luogu.com.cn/record/95973366)。

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N = 1e6 + 5, mod = 1e9 + 7;
int n, dp[N][2]; //dp[i][0/1] : 第i位填A或B
void calc()
{
	for (int i = 2; i <= n; i++)
		dp[i][0] = dp[i - 1][1],                        //第i位填1，则上一位只能填2
		dp[i][1] = (dp[i - 1][0] + dp[i - 1][1]) % mod; //第i位填2，则上一位可以填1或2
}
void solve()
{
	long long ans = 0;
	scanf("%d", &n);

	dp[1][0] = 1, dp[1][1] = 0;           //第一位填1，
	calc(), ans = (ans + dp[n][1]) % mod; //则最后一位只能填2

	dp[1][0] = 0, dp[1][1] = 1;                      //第一位填2，
	calc(), ans = (ans + dp[n][0] + dp[n][1]) % mod; //则最后一位可以填1或2

	cout << ans << '\n';
}
int main()
{
	ios::sync_with_stdio(false);
	int T;
	scanf("%d", &T);
	while (T--) solve();
	return 0;
}
```

## 矩阵加速

### 思路

如果 $n$ 就 $10^6$，那顶多一道黄题。但是 $n$ 是 $10^{18}$，哭泣。

这里用一个很常见的 trick：**矩阵加速优化 DP**。

我们设一组矩阵 $\begin{pmatrix} dp_{i, 0} & dp_{i, 1} \end{pmatrix}$。

然后很容易根据状态转移方程列出关系式：

$$
\begin{pmatrix} dp_{i, 0} & dp_{i, 1} \end{pmatrix}

\times

\begin{pmatrix}
0 & 1 \\
1 & 1
\end{pmatrix}

=

\begin{pmatrix} dp_{i+1, 0} & dp_{i+1, 1} \end{pmatrix}
$$

再根据矩阵跑快速幂就秒掉了这题。

同上面的，仍然是要初始化两个（具体看代码）。

时间复杂度 $O(\log n \times t^3)$，$t = 2$（矩阵大小）。

你会发现这东西很小很小，所以随便过。

### 代码 

很轻松拿到 $100$ 分。跑得飞快，最慢的点 $4$ 毫秒。

代码轻度整活，但是应该可以看得懂。

[提交记录](https://www.luogu.com.cn/record/96308686)。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int N = 2, mod = 1e9 + 7;
namespace martix {
	void mul(int ANS[][N], int x[][N], int y[][N])
	{
		int ans[N][N] = {};
		for (int i = 0; i < N; i++)
			for (int j = 0; j < N; j++)
				for (int k = 0; k < N; k++)
					ans[i][j] = (ans[i][j] + 1ll * x[i][k] * y[k][j]) % mod;
		memcpy(ANS, ans, sizeof ans);
	}
	void ksm(int f[][N], int A[][N], long long y)
	{
		while (y)
		{
			if (y & 1) mul(f, f, A);
			mul(A, A, A);
			y >>= 1;
		}
	}
}; using namespace martix;

void solve()
{
	long long n, ans = 0;
	cin >> n;
	int zltAK[N][N] = {1, 0}; //第一位填1 的 初始矩阵
	int ioi[N][N] = {
		0, 1, 
		1, 1
	};
	ksm(zltAK, ioi, n - 1), ans = (ans + zltAK[0][1]) % mod; //则最后一位只能填2

	int hxyAK[N][N] = {0, 1}; //第一位填2 的 初始矩阵
	int csp[N][N] = {
		0, 1, 
		1, 1
	};
	ksm(hxyAK, csp, n - 1), ans = (ans + hxyAK[0][0] + hxyAK[0][1]) % mod; //则最后一位可以填1或2

	cout << ans << '\n';
}
int main()
{
	int T;
	scanf("%d", &T);
	while (T--) solve();
	return 0;
}
```

码字不易，希望能帮助到大家！

---

## 作者：lizh (赞：17)

# 矩阵快速幂典型题 #

不会矩阵快速幂转到这里[斐波那契数列](https://www.luogu.org/problemnew/show/P1962)

### 首先，我们可以先用dp的思想来解这道题；

我们先按照题意定义f[k][1]表示第k个数是放金属性的珠子的话到第k个一共有几种放法，f[k][0]表示第k个数是放木属性的珠子的话到第k个一共有几种放法。
#### 这也就可以推出下面这两个式子

## f[i][0]=f[i-1][1]

## f[i][1]=f[i-1][0]+f[i-1][1]

#### 第一个意思就是第i个放木属性的话，那么i-1个就必须是金属性，这样的话，到第i个放木属性的放法数量和第i-1个放金属性的放法数量就是一样的了，就可以这样来进行转移
#### 而第二个的意思是如果第i个放金属性，那前面那个放木属性还是金属性都没关系，所以这两种情况都有可能，所以要加起来

#### 而到第i个的总情况数就是 f[i][0]+f[i][1];


这个题目有一个区别于其他矩阵快速幂的题目的特点就是它的形状是环状的，这也就是说最后一个的情况受第一个影响，这就需要我们在最后一层的时候区分下，所以有四种情况
#### （1）、金……金
#### （2）、金……木
#### （3）、木……金
#### （4）、木……木（舍去）
因为这个形状是环形的，所以第（2）、（3）种情况最后得出的个数是一样的，我们只要算第一个是金属性的话，结果是什么就行，最后金属（2）*2+（1）就行

最后就是矩阵快速幂的部分，我们定义初始值f[2]={0,1}，表示第一个无法放木属性，只能放金属性，而后面f[0]表示上面递推式中的f[i][0]，f[1]表示上面递推式的f[i][1]；

我们就可以得出矩阵快速幂的递推式（自己演算下很快就出来了）

### a[2][2]={{0,1},{1,1}}

最后上代码（和斐波那契数列差不多）

```cpp
#include<iostream>
#include<cstring>
using namespace std;
const int Mod=1000000007;
void mulself(long long a[2][2])
{
    long long c[2][2];
    memset(c,0,sizeof(c));
    for(int i=0;i<2;i++)
    {
        for(int j=0;j<2;j++)
        {
            for(int k=0;k<2;k++)
            {
                c[i][j]=(c[i][j]+a[i][k]*a[k][j]%Mod)%Mod;
            }
        }
    }
    memcpy(a,c,sizeof(c));
}
void mul(long long f[2],long long a[2][2])
{
    long long c[2];
    memset(c,0,sizeof(c));
    for(int i=0;i<2;i++)
    {
        for(int j=0;j<2;j++)
        {
            c[i]=(c[i]+f[j]*a[j][i]%Mod)%Mod;
        }
    }
    memcpy(f,c,sizeof(c));
}
int main()
{
    
    int T;
    cin>>T;
    while(T--)
    {
        long long a[2][2]={{0,1},{1,1}},f[2]={0,1};
        long long n;
        cin>>n;
        n--;
        while(n)
        {
            if(n&1) mul(f,a);
            mulself(a);
            n>>=1;
        }
        cout<<(f[0]+f[1]+f[0])%Mod<<endl;
    }

    
    return 0;
}
```






---

## 作者：灯芯糕 (赞：16)

## 矩阵快速幂解法：

这是一个类似斐波那契数列的矩乘快速幂，所以推荐大家先做一下下列题目：（会了，~~差不多就是多倍经验题了~~）

注：如果你不会矩阵乘法，可以了解一下[P3390](https://www.luogu.org/problemnew/show/P3390)的题解

[P1939 【模板】矩阵加速（数列）](https://www.luogu.org/problemnew/show/P1939)

[P3390 【模板】矩阵快速幂](https://www.luogu.org/problemnew/show/P3390)

[P1306 斐波那契公约数](https://www.luogu.org/problemnew/show/P1306)

[P1962 斐波那契数列](https://www.luogu.org/problemnew/show/P1962)

[P4838 P哥破解密码](https://www.luogu.org/problemnew/show/P4838)

由题意可得：相邻两个珠子中必有金属性珠子。这其实就可以理解为不能有连续的两个木属性珠子。这样一看，此题就和[P4838 P哥破解密码](https://www.luogu.org/problemnew/show/P4838)差不多了。只不过这题是个2*2矩阵乘法

### 进入正文：

我们先一次将1~n中每一个珠子的情况枚举
```cpp

//                n=1 n=2 n=3 n=4 n=5 n=6 .......
//可放金属性珠子：  1   2   3   5   8   13 .......
//可放木属性珠子：  1   1   2   3   5   8  .......
```

不难发现这就是一个斐波那契数列的递推

### 但是：这是一个手环！
所以第一个珠子与最后一个手环是相连的，他们会互相影响！

不过他们只会影响对方而不会影响其他珠子，我们可以将第一颗珠子选金属性与木属性这两种情况分开：
```cpp
//第一颗珠子为金属性： 若 n=5 
//        1   2   3   4   n  .......
//金属性： 1   1   2   3   5  .......
//木属性： 0   1   1   2   3  .......

//第一颗珠子为木属性： n=5 
//        1   2   3   4   n  .......
//金属性： 0   1   1   2   3  .......
//木属性： 1   0   1   1   0  .......
                //最后一颗不能为木! 
//两种情况加起来就是样例1的解了 
```
所以此题就是求斐波那契数列**第n项** 加 **第n-1项的两倍**

然后就可矩阵快速幂了！递推矩阵如下
```cpp
//                     1 1
//                     0 1
```

## 不过我们当然不能止步于此：

因为还有一种更无脑有效的方法：

既然矩阵可以快速幂，那么说明每两个递推数（即答案）之间的递推矩阵是一样的！

所以我们可以先手算两组结果，然后直接推出递推矩阵：

```cpp

//  3 4  乘  递推矩阵  =  4 7

//  解上述方程得递推矩阵为： 
//             0  1
//  3 4  乘            =  4 7
//             1  1
```

## 下面上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define mod 1000000007//简化一下 
struct ju{
    long long a[2][2];//不用long long只有8分哦（亲测QAQ）  
    ju operator *(const ju &x){
    	ju res;//这里需要另外建个矩阵存答案 
        memset(res.a,0,sizeof(res.a));
        for(int i=0;i<2;i++)
          for(int j=0;j<2;j++)
            for(int k=0;k<2;k++)
              res.a[i][j]=(res.a[i][j]+a[i][k]%mod*(x.a[k][j])%mod)%mod;
        return res;
    }         //重载运算符，（可以写成函数） 
}base,ans;//两个基本矩阵 
int main(){
    long long n,t;
    scanf("%lld",&t);//只有t就不写快读了 
    while(t--){
    	scanf("%lld",&n);n--;//n要减一，不然会错 QAQ 
    	base.a[0][0]=0;base.a[0][1]=1;base.a[1][0]=1;base.a[1][1]=1;
    	ans.a[0][0]=2;ans.a[0][1]=1;ans.a[1][0]=0;ans.a[1][1]=0;//初始化 
        while(n){//快速幂，（也可以写成函数） 
            if(n%2==1) ans=ans*base;
            base=base*base;
            n/=2;
        }
    	printf("%lld\n",ans.a[0][1]%mod);
    }   //输出 
    return 0;
}
```
### 代码中ans的初始化已经是n=1时的答案了所以n要减一。
啊，写题解好累啊，是我太蒟了吗。。

---

## 作者：犇犇犇犇 (赞：14)

由题意，是一个组合问题。  
由于是环组合，首尾两个珠子是会互相影响的  
### 于是便可以想到一种三维方式

$dp[l][s][e]$：
长度为$l$，首珠属性为$s$，尾珠属性为$e$时的种数

![](https://i.loli.net/2019/08/21/FXAE7Zxo5ranjYJ.jpg)

dp到最后的结局一共只有**四种**

![](https://i.loli.net/2019/08/21/mAIBf4JzMClDpY2.jpg)

### 考虑一下这四种情况  
其实最后一种可以直接去掉  
首珠金，尾珠木和首珠金木，尾珠金的情况总数是**一样**的


### 所以我们实际上求的答案 为金金+2*金木

所以我们便可以**定下首珠**了，为金色。  
### 情况简化为二维dp

于是状态为是$dp[l][e]$  
表示长度为$l$，尾珠属性为$e$时的种数  

$dp[i][$金$]=dp[i-1][$金$]+dp[i-1][$木$]$  
因为如果当前放的是金，那么前面放木或者金都可以  
所以情况数要加起来

$dp[i][$木$]=dp[i-1][$金$]$  
前面一个必须放金，所以就是前面放金的情况。

初始化：  
$dp[1][$金$]=1$  
$dp[1][$木$]=0$

最后的答案即为 $ans=2*dp[n][$木$]+dp[n][$金$]$

看下数据范围$n\leq 10^{18}$ 要用矩阵快速幂

转换下递推公式

$dp[i][$木$]=0*dp[i-1][$木$]+1*dp[i-1][$金$]$  
$dp[i][$金$]=1*dp[i-1][$木$]+1*dp[i-1][$金$]$

为了表达方便，用$0$表示木，$1$表示金

由矩阵乘法性质得到  
$(dp[i][0]\texttt{ }\texttt{  }dp[i][1])=(dp[i-1][0]\texttt{ }\texttt{ }\texttt{ }dp[i-1][1])\left(\begin{matrix}0 & 1 \\1 & 1\end{matrix}\right)$

 $\texttt{ }(dp[n][0]\texttt{ }\texttt{ }\texttt{ }dp[n][1])$  
$=(dp[n-1][0]\texttt{ }\texttt{ }\texttt{ }dp[n-1][1]){\left(\begin{matrix}0 & 1 \\1 & 1 \end{matrix}\right)}^1$  
$=(dp[n-2][0]\texttt{ }\texttt{ }\texttt{ }dp[n-2][1]){\left(\begin{matrix}0 & 1 \\1 & 1 \end{matrix}\right)}^2$  
$= ......$  
$=(dp[1][0]\texttt{ }\texttt{ }\texttt{ }dp[1][1]){\left(\begin{matrix}0 & 1 \\1 & 1 \end{matrix}\right)}^{n-1}$  
$=(0\texttt{ }\texttt{ }\texttt{ }1){\left(\begin{matrix}0 & 1 \\1 & 1 \end{matrix}\right)}^{n-1}$  
  
所以可以求出答案  
 $\texttt{ }ans$  
$=2*dp[n][0]+dp[n][1]$  
$=\texttt{ }(dp[n][0]\texttt{ }\texttt{ }\texttt{ }dp[n][1])\left(\begin{matrix}2 \\1 \end{matrix}\right)$  
$=(0\texttt{ }\texttt{ }\texttt{ }1){\left(\begin{matrix}0 & 1 \\1 & 1 \end{matrix}\right)}^{n-1}\left(\begin{matrix}2 \\1 \end{matrix}\right)$  
$={\left(\begin{matrix}0 & 2 \\0 & 1 \end{matrix}\right)}{\left(\begin{matrix}0 & 1 \\1 & 1 \end{matrix}\right)}^{n-1}$
  
所以接下去就是基本的**矩阵快速幂**了

注意~~不开long long见祖宗~~

```
#include<bits/stdc++.h>
#define MOD 1000000007
#define ll long long
using namespace std;
void mul(ll a[2][2],ll b[2][2],ll c[2][2])
{
    int i,j,k;
	ll tmp[2][2]={0,0,0,0};
    for(i=0;i<=1;i++)
        for(j=0;j<=1;j++)
            for(k=0;k<=1;k++)
                tmp[i][j]=(tmp[i][j]+a[i][k]*b[k][j]%MOD)%MOD;
    memcpy(c,tmp,sizeof(ll)*4);
    return;
} //2*2矩阵乘 
int main()
{
    ll i,T,n;
    cin>>T;
    while(T--)
    {
		ll y[2][2]={0,1,1,1};
		ll x[2][2]={0,2,0,1}; //初始矩阵 
		cin>>n;
	    for(i=n-1;i>0;i>>=1)
	    {
	        if(i%2==1)
	            mul(x,y,x);
	        mul(y,y,y);
	    } //矩阵快速幂 
	    cout<<(x[1][1]+x[0][0])%MOD<<endl;
	}
    return 0;
}
```




---

## 作者：灵乌路空 (赞：6)

## 知识点: DP，矩阵加速

### [原题面](https://www.luogu.com.cn/problem/P4910)

### 题目要求:
>给定一个长度为 $n$ 的环，填入 金色或绿色。   
>不能有两个相邻的绿色。   
>多组数据, $T\le 10,  n\le 10^{18}$  

---

### 分析题意

矩阵加速模板。

设 $f_{i,0/1}$ 为当前填到第 $i$ 位，第一个位置为 金色/绿色 的合法方案数。  
分成第一个位置为 绿/金讨论：  
1. 第一个位置为绿色时，$f_{1,0} = 0,f_{1,1} = 1$。   
   由于不能有两个相邻的绿色，则结尾珠子必为金色。  
   其对答案的贡献为 $f_{n,0}$
2. 第一个位置为金色时，$f_{1,0} = 1, f_{1,1} = 0$。   
   此时结尾珠子颜色任意。  
   其对答案的贡献为 $f_{n,0} + f_{n,1}$

状态转移方程：  
$f_{i,0} = f_{i-1,0} + f_{i-1,1}$   
$f_{i,1} = f_{i-1,0}$  

复杂度 $O(Tn)$，期望得分 $\text{60pts}$。  

---


上式显然可矩阵加速，转移矩阵如下：  

$$\begin{bmatrix}f_{i-1,0}&f_{i-1,1}\end{bmatrix} \times \begin{bmatrix}1&1\\1&0\end{bmatrix} = \begin{bmatrix}f_{i,0}&f_{i,1}\end{bmatrix}$$

复杂度 $O(T\log n)$，期望得分 $\text{100pts}$。

---

### 代码实现

```cpp
//
/*
By:Luckyblock 
*/
#include <cstdio>
#include <ctype.h>
#include <cstring>
#include <algorithm>
#define ll long long
const ll kMod = 1e9 + 7;
//=============================================================
struct Matrix {
  ll a[2][2];
} shift, sum;
ll T, n, ans; //0金 1绿 
//=============================================================
inline ll read() {
  ll f = 1, w = 0; char ch = getchar();
  for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1;
  for (; isdigit(ch); ch = getchar()) w = (w << 3) + (w << 1) + (ch ^ '0');
  return f * w;
}
Matrix operator * (const Matrix &a, const Matrix &b) {
  Matrix c;
  memset(c.a, 0, sizeof(c));
  for (int k = 0; k <= 1; ++ k) {
    for (int i = 0; i <= 1; ++ i) {
      for (int j = 0; j <= 1; ++ j) {
        c.a[i][j] = (c.a[i][j] + a.a[i][k] * b.a[k][j] % kMod) % kMod;
      }
    }
  }
  return c;
}
void Build(Matrix &a) {
  memset(a.a, 0, sizeof(a.a));
  for (int i = 0; i <= 1; ++ i) a.a[i][i] = 1;
}
Matrix qpow(Matrix x, ll y) {
  Matrix ret;
  Build(ret);
  while (y) {
    if (y & 1) ret = ret * x;
    x = x * x; y >>= 1;
  }
  return ret;
}
//=============================================================
int main() {
  T = read();
  while (T --) {
    n = read(), ans = 0;
    memset(shift.a, 0, sizeof(shift.a));
    shift.a[0][0] = shift.a[0][1] = shift.a[1][0] = 1;
    shift = qpow(shift, n - 1);
    
    memset(sum.a, 0, sizeof(sum.a));
    sum.a[0][0] = 1, sum = sum * shift;
    ans = ((ans + sum.a[0][0]) % kMod + sum.a[0][1]) % kMod;
    
    memset(sum.a, 0, sizeof(sum.a));
    sum.a[0][1] = 1, sum = sum * shift;
    ans = (ans + sum.a[0][0]) % kMod;
    
    printf("%lld\n", ans);
  }
  return 0;
}
```

---

## 作者：pkh68 (赞：6)


给此题提供一个新颖的思路。

### 解析

直接考虑链即可，因为环可以通过强制首尾颜色变成链。

设$f(i,0/1)$表示前$i$个珠子，最后一个珠子为$0/1$的方案数。

那么有

$f(i,0) \rightarrow f(i+1,0/1)$

$f(i,1) \rightarrow f(i+1,0)$

但$O(n)$过不去，不妨考虑倍增，这里可以不用矩阵快速幂。

设$f(i,0/1,0/1)$表示长度为$2^i$的链，左端为$0/1$,右端为$0/1$的方案数。

那么有：

$f(i,0,0)=f(i-1,0,1) \times f(i-1,0,0)+f(i-1,1,0) \times f(i-1,1,0)+f(i-1,0,1) \times f(i-1,1,0)$

其他同理。

然后对于长度为$n$的链，用上述式子拼接即可。

### 代码如下

```cpp

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<map>
#define LL long long
#define re register
#define fuck mp[left][right][len]
using namespace std;
const int Mod=1000000007;
int T;
LL n,f[70][2][2],power[70];
map<LL,LL>mp[2][2];
LL check(LL len,int left,int right,int x){
    if(mp[left][right][len]) return mp[left][right][len];
    for(re int i=x;~i;--i){
        if(power[i]==len) return f[i][left][right];
        if(power[i]<len){
            LL ans0=check(len-power[i],0,right,i-1),ans1=check(len-power[i],1,right,i-1);
            fuck=(fuck+(f[i][left][0]*ans1)%Mod)%Mod;
            fuck=(fuck+(f[i][left][1]*ans0)%Mod)%Mod;
            fuck=(fuck+(f[i][left][1]*ans1)%Mod)%Mod;
            return fuck;
        }
    }
}
int main(){
    scanf("%d",&T);
    f[0][0][0]=f[0][1][1]=power[0]=1ll;
    for(re int i=1;i<=62;++i){
        power[i]=power[i-1]*2;
        for(re int j=0;j<=1;++j){
            for(re int k=0;k<=1;++k){
                f[i][j][k]=(f[i][j][k]+(f[i-1][j][0]*f[i-1][1][k])%Mod)%Mod;
                f[i][j][k]=(f[i][j][k]+(f[i-1][j][1]*f[i-1][0][k])%Mod)%Mod;
                f[i][j][k]=(f[i][j][k]+(f[i-1][j][1]*f[i-1][1][k])%Mod)%Mod;
            }
        }
    }
    for(re int i=1;i<=T;++i){
        scanf("%lld",&n);
        printf("%lld\n",(check(n+1,0,0,62)+check(n+1,1,1,62))%Mod);
    }
    return 0;
}
```

---

## 作者：囧仙 (赞：5)

经典的矩阵快速幂优化 dp，作为例题还是值得一做的

- **题意**

  对一个 $n$ 个点组成的的环，每个点染色黄或绿，要求没有连续的两个绿色点，求方案数，答案对 $10 ^ 9 + 7$ 取模
  
- **简单的dp**  
  
  环上计数一般都是枚举第一个点的情况，然后断开在序列上用 dp 计数
  
  首先肯定是设 $dp_i$ 表示前 $i$ 个点满足要求的方案数，而第 $i$ 个点能染什么颜色与 $i - 1$ 点有关，所以第 $i$ 个点的颜色也要加入状态
  
  所以，设 $dp_{i,0}$ 表示第 $i$ 个点染黄色，前面全部符合要求的方案数， $dp_{i,1}$ 表示第 $i$ 个点染绿色，前面全部符合要求的方案数
  
  $$dp_{i,0} = dp_{i - 1,0} + dp_{i - 1,1}$$
  
  $$dp_{i,1} = dp_{i - 1,0}$$
  
  然后要枚举第一个点的颜色，如果是黄色的话，那么 $dp_{1,0} = 1$，答案可以加上 $dp_{n,0} + dp_{n,1}$，如果是绿色，那么 $dp_{1,1} = 1$，答案可以加上 $dp_{n,0}$
  
  代码：
  
```cpp
#include <cstdio>
#define ll long long
#define mod 1000000007
int T,n;
ll f[1000005][2];//f[i][0]表示最后一个金色,前面全部满足的方案,f[i][1]表示最后一个绿色,前面全部满足的方案 
ll ans;

void work(){
	scanf("%d",&n);
	f[1][0] = 1;
	f[1][1] = 0;
	for(int i = 2;i <= n;i++){
		f[i][0] = (f[i - 1][1] + f[i - 1][0]) % mod;
		f[i][1] = f[i - 1][0];
	}
	ans = f[n][0] + f[n][1];
	f[1][0] = 0;
	f[1][1] = 1;
	for(int i = 2;i <= n;i++){
		f[i][0] = (f[i - 1][1] + f[i - 1][0]) % mod;
		f[i][1] = f[i - 1][0];
	}
	ans += f[n][0];
	printf("%lld\n",ans % mod);
}

int main(){
	scanf("%d",&T);
	while(T--) work();	
	return 0;
}
```

- **矩阵快速幂优化dp**

   可以发现，$dp_i$ 实际上只由 $dp_{i - 1}$ 得到
   
   所以说，我们可以把每次的转移写成一个乘上一个固定的矩阵
   
   构造初始矩阵：
   
   $$st = \begin{bmatrix}f_{i,0}&f_{i,1}\\0&0\end{bmatrix}$$
   
   根据 dp 的转移，每次的转移矩阵就是：
   
   $$nxt = \begin{bmatrix}1&1\\1&0\end{bmatrix}$$
   
   这样，答案矩阵就是 $st \times nxt ^ {n - 1}$
   
   这样做有一个好处，就是矩阵是满足结合律的，所以可以用快速幂的方式求出 $nxt ^ {n - 1}$
   
   这样，我们就在 $O(T\log n)$ 的时间复杂度内求出了答案
   
   代码：
   
```cpp
#include <cstdio>
#define ll long long
#define mod 1000000007 

struct M{
	ll a,b,c,d;
	/*
	[a,b]
	[c,d]
	*/
}st,nxt;

M operator * (M a,M b){
    M c;
    c.a = (a.a * b.a + a.b * b.c) % mod;
    c.b = (a.a * b.b + a.b * b.d) % mod;
    c.c = (a.c * b.a + a.d * b.c) % mod;
    c.d = (a.c * b.b + a.d * b.d) % mod;
    return c;
}

M power(M n,ll k){
	M ans = {1,0,0,1};
	while(k){
		if(k % 2 == 1){
			ans = n * ans;
		}
		n = n * n;
		k /= 2;
	}
	return ans;
}
int T;
ll n,ans;

void solve(){
	scanf("%lld",&n);
	st = {1,0,0,0};
	nxt = {1,1,1,0};
	M res = st * power(nxt,n - 1);
	ans = res.a + res.b;
	st = {0,1,0,0};
	nxt = {1,1,1,0};
	res = st * power(nxt,n - 1);
	ans += res.a;
	printf("%lld\n",ans % mod);
}

int main(){
	scanf("%d",&T);
	while(T--) solve();
	return 0;
}
```

---

## 作者：zzqDeco (赞：4)

我的做法和题解中考虑每一个点的转移不一样

我考虑的使用一种常见的方法来解决这个问题

由于合法的状态只在于两位，所以我们考虑把连续两个的状态压成一个数，这也就是我们熟悉的状压，这样的情况下转移矩阵就很好写了

最后处理环形的时候就可以考虑枚举开始的状态，当我们把环变成长度等于 $len+2$ 的链的时候，末尾的状态和开始的状态应该是相同

也就是说我们的答案就是转移矩阵做快速幂之后的对角线之和（对角线就是表示一个状态转移到它相同的状态）

虽然这个在这个题我们可以直接用一般的来解决，但是这种状态压缩处理环的方法还是相当有用的

下面就是代码

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>

using namespace std;

long long mod=1000000007;

int m,q;

long long t;

struct M
{
  long long s[50][50],r,c;
  void clear()
  {
    memset(s,0,sizeof(s));
  }
  void build(int n)
  {
    for(int i=0;i<n;i++) for(int j=0;j<n;j++) s[i][j]=0;
    for(int i=0;i<n;i++) s[i][i]=1;
  }
}b,Ye;

M operator * (const M &x,const M &y)
{
  M now;
  now.clear();
  now.r=x.r;
  now.c=y.c;
  for(int k=0;k<x.c;k++)
  {
    for(int i=0;i<x.r;i++)
    {
      for(int j=0;j<y.c;j++)
      {
        now.s[i][j]=(now.s[i][j]+x.s[i][k]*y.s[k][j]%mod)%mod;
      }
    }
  }
  return now;
}

M ksm(M a,long long k)
{
  M ans;
  ans.build((4));
  ans.r=(4);
  ans.c=(4);
  while(k)
  {
    if(k&1ll) ans=ans*a;
    a=a*a;
    k>>=1;
  }
  return ans;
}

int main()
{
  int T;
  scanf("%d",&T);
  while(T--)
  {
    scanf("%lld",&t);
    Ye.clear();
    Ye.r=4;
    Ye.c=4;
    for(int i=1;i<(1<<2);i++)
    {
      int now1=((i%(2))<<1)+1,now0=((i%(2))<<1)+0;
      if(now1) Ye.s[i][now1]=1;
      if(now0) Ye.s[i][now0]=1;
    }
    long long ans=0;
    M nowans=ksm(Ye,t);
    for(int i=1;i<(1<<2);i++) ans=(ans+nowans.s[i][i])%mod;
    printf("%lld\n",ans);
  }
}

```

---

## 作者：yfy2004 (赞：4)

看到没多少人发题解，那么本蒟蒻就来发一篇吧。~~这居然还是本蒟蒻的第一篇题解~~

~~话说这题难度被评为省选/NOI-真是令人智熄~~

## 简化题意

你有黑白两种珠子（~~什么时候变成黑白了~~）个INF颗，现在要将黑色与白色珠子共n颗串成一个环，使任意两个相邻的珠子中至少有一个黑色珠子，求满足条件的串法的方案数（有多组数据）。（震惊的是两种经过旋转后重合的方案视为不同的方案）

### 60分做法：

当我第一眼看到这题后，就感觉这题是道环形dp。设f[i][0]表示已经放完前i个珠子，且第i个珠子为黑色的方案数，设f[i][1]表示已经放完前i个珠子，且第i个珠子为白色的方案数，于是列出转移方程：

（1）第一个珠子为黑色，f[1][0]=1,f[1][1]=0;

（2）第一个珠子为白色，f[1][0]=0,f[1][1]=1;

f[i][0]=f[i-1][0]+f[i-1][1]；f[i][1]=f[i-1][0]（2<=i<=n）

最后答案为（1）中的f[n][0]+f[n][1]+（2）中的f[n][0]。

时间复杂度O(Tn)

当我看到数据范围“1<=n<=10^18”时，~~我和我的小伙伴们都惊呆了~~，于是就有了

### 100分做法：

经过认真的~~打表~~观察后，我发现转移方程其实可以合并：

由于f[i-1][1]=f[i-2][0]，第一条方程其实可以变为f[i][0]=f[i-1][0]+f[i-2][0]。发现了什么？斐波那契数列！

所以答案可以简化为（1）中的f[n][0]+f[n-1][0]（也就是f[n+1][0]）+（2）中的 f[n][0]。

设F[i]为斐波那契数列的第i项，则（1）中的结果为F[n+1]，而由于（2）中f[1][0]=0，即该斐波那契数列是由0开始的，所以（2）中的结果为F[n-1]。

#### 结论：

答案为F[n+1]+F[n-1]。

然而这样还并没有结束，我们应该如何求F[n+1]和F[n-1]呢？应该很容易想到用矩阵加速递推吧（也就是矩阵快速幂）。

还有一点，不要忘了特判n=1时的情况，~~不然你就会获得94分的好成绩~~

最后，~~也是最重要的~~，献上本蒟蒻的代码：

```
#include<bits/stdc++.h>
#define ll long long
#define md 1000000007
using namespace std;
int T;
ll n,m,ans;
void mul(ll f[3],ll a[3][3]){
    int j,k;
    ll c[3];
    memset(c,0,sizeof(c));
    for(j=1;j<=2;j++) for(k=1;k<=2;k++) c[j]=(c[j]+f[k]*a[k][j])%md;
    memcpy(f,c,sizeof(c));
}
void mulself(ll a[3][3]){
    int i,j,k;
    ll c[3][3];
    memset(c,0,sizeof(c));
    for(i=1;i<=2;i++) for(j=1;j<=2;j++) for(k=1;k<=2;k++) c[i][j]=(c[i][j]+a[i][k]*a[k][j])%md;
    memcpy(a,c,sizeof(c));
}
void jzksm(ll x){
    ll f[3]={0,1,1};
    ll a[3][3]={{0,0,0},{0,0,1},{0,1,1}};
    while(x>0){
        if(x%2==1) mul(f,a);
        mulself(a);
        x/=2;
    }
    ans=(ans+f[2])%md;
}//矩阵快速幂
int main(){
    scanf("%d",&T);
    while(T--){
        scanf("%lld",&n);
        if(n==1){
            printf("1\n");
            continue;
        }
        ans=0;
        jzksm(n-1);
        jzksm(n-3);//由于第一、二项已知，我们只需做n-1、n-3次变换
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：ZCETHAN (赞：2)

[传送门](https://www.luogu.com.cn/problem/P4910)
## 题目大意
给定一个长度 $n$，求有多少个长度为 $n$ 的 $01$ **环**，使得没有两个相邻的 $0$。

~~不得不说 Luogu 上的翻译是真的差劲。~~
## Solution
看完题面就知道是裸的 $dp$ 题，有点 $dp$ 基础的人很快就能写出 $dp$ 的转移式子。

设 $dp_{i,0/1}$ 表示第 $i$ 位填入 $0/1$ 的方案数是多少。则有：

如果当前这位是 $0$，则前一位必须是 $1$。即：
$$dp_{i,0}=dp_{i-1,1}$$
如果当前这位是 $1$，则前一位随便。即：
$$dp_{i,1}=dp_{i-1,0}+dp_{i-1,1}$$

非常简单。

但是，接下来考虑题目中的细节问题：

**first: 要求的是个环**

这个还是比较好办的，我的策略就是直接固定第一个是 $0$ 还是 $1$，然后对于 $0/1$ 分别跑一次 $dp$，最后对于每种情况处理一下答案的累加就可以了。

```cpp
//如果第一位是 0，则第二位只有当其是 1 的时候才有 1 种情况
dp[2][1]=1;dp[2][0]=0;
for(int i=3;i<=n;i++)
	dp[i][0]=dp[i-1][1],
	dp[i][1]=dp[i-1][0]+dp[i-1][1];
ans+=dp[n][1];//由于第一位是 0，所以最后只有当最后一位是 1 的时候是合法的
//同理处理第一位是 1 的情况
dp[2][1]=1,dp[2][0]=1;
for(int i=3;i<=n;i++)
	dp[i][0]=dp[i-1][1],
	dp[i][1]=dp[i-1][0]+dp[i-1][1];
ans+=dp[n][1]+dp[n][0];//此时两种都是合法的
```

**second: 数据太大了**

是的，如果你就写了个裸个 $dp$，那么自然是会喜提 $\mathsf{TLE}$ 一枚。
>$1 \leq n \le 10^{18}$

行吧，瞬间好像不可做了。

但是，看看这个 $dp$ 式子，发现非常简洁，几乎没有判断。这个时候，我们就想到一个加速的利器：**矩阵快速幂**。可以把 $dp$ 填入矩阵中：
$$\begin{bmatrix}dp_{i,1} \\dp_{i,0} \end{bmatrix}$$
此时定义操作矩阵：
$$\begin{bmatrix}
 1 &1 \\
 1 &0
\end{bmatrix}$$

就可以了。复杂度 $O(T \log n)$。
## Code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MOD=1e9+7;
const int MAXN=110;
const int siz=2;
struct Matrix{ll a[MAXN][MAXN];};
Matrix mul(Matrix m1,Matrix m2){
	Matrix ret;
	memset(ret.a,0,sizeof(ret.a));
	for(int i=0;i<siz;i++)
		for(int k=0;k<siz;k++){
			if(!m1.a[i][k]) continue;
			for(int j=0;j<siz;j++)
				ret.a[i][j]=(ret.a[i][j]+m1.a[i][k]*m2.a[k][j]%MOD)%MOD;
		}
	return ret;
}
Matrix qpow(Matrix m,ll p){
	Matrix ret;
	memset(ret.a,0,sizeof(ret.a));
	for(int i=0;i<siz;i++) ret.a[i][i]=1;
	while(p){
		if(p&1) ret=mul(ret,m);
		m=mul(m,m); p>>=1;
	}return ret;
}//矩阵快速幂
Matrix op,m;
void solve(){
	ll n;
	ll ans=0;
	scanf("%lld",&n);
	if(n==1){puts("1");return;}
	m.a[0][0]=1;m.a[1][0]=0;
	op.a[0][0]=1;op.a[0][1]=1;
	op.a[1][0]=1;op.a[1][1]=0;
	ans=(ans+mul(qpow(op,n-2),m).a[0][0])%MOD;
	m.a[0][0]=1;m.a[1][0]=1;
	op.a[0][0]=1;op.a[0][1]=1;
	op.a[1][0]=1;op.a[1][1]=0;
	ans=(ans+mul(qpow(op,n-2),m).a[0][0])%MOD;
	ans=(ans+mul(qpow(op,n-2),m).a[1][0])%MOD;
	printf("%lld\n",ans);
}
int main()
{
	int T;
	for(scanf("%d",&T);T--;)
		solve();
}
```

---

## 作者：EndSaH (赞：2)

首先预祝 $NOIP2018rp++$

# 1.题面分析

### 人话版:

给定一个含 $n$ 个点的环, 你可以选择一些点染色, 与被染色的点相连的边也会被染色.

求把所有边染色的方案数, 对 $10^9+7$取模.

# 2.思路
### 首先观察数据范围.

$n \le 10^{18}$, 再结合题意判断该题为**数学结论题**.

### 环的话不好处理, 首先断环成链考虑.

设 $f[i][0/1](i \in [1,n])$ 表示处理到第 $i$ 个点时该点**染/不染**的方案数.

这个类似于斐波那契的递推思路$(DP?)$很容易想:

#### 若该点不染色, 那么他的前一个点就必须染色, 即 
$$f[i][0]=f[i-1][1]$$

#### 若该点染色, 那么他的前一个点染不染色都无所谓, 即 
$$f[i][1]=f[i-1][0]+f[i-1][1]$$

(初始状态在讨论环时再说)

### 现在再考虑**环**的情况.

可以发现, 其实环与链的不同只有一个地方, 就是**第一个点**染不染色.

设 $ans_1$ 为第一个点染色时的总方案数, $ans_2$为第一个点不染色的总方案数, 最后总体的 $ans$ 就是 $ans_1$ 和 $ans_2$ 的和.

#### 当第一个点染色时, 最后一个点染不染色都无所谓, 所以 
$$ans_1=f[n][0]+f[n][1]$$

又因为这种状况下第一个点必须染色, 所以初始状态为:
$$f[1][0]=0,f[1][1]=1$$

#### 当第一个点不染色时, 最后一个点必须染色, 所以 
$$ans_2=f[n][1]$$

又因为这种状况下第一个点不染色, 所以初始状态为:
$$f[1][0]=1,f[1][1]=0$$

综上所述, 
$$ans=ans_1+ans_2=2f[n][1]+f[n][0]$$

为什么我把初始状态不同所推出的两个 $f[n][1]$ 合并在了一起?

简略讨论一下:

当 $n=1$ 时, 答案为 $1$;

(因为这时没有雾雨灵径, 让项链为金色必须让这一个珠子为金色)

(我试过, 若认为答案为 $2$ 会WA $3$ 个点)

~~易证得~~当 $n>1$ 时, 两种初始状态推出的 $f[i][1]$ 是相同的.

故合并 $f[i][1]$ 对答案不会产生影响.

## 3.代码实现

### 前置技能:矩阵快速幂, 不会的话左转 [P3390](https://www.luogu.org/problemnew/show/P3390)

代码实现很简单, 首先构造矩阵递推式:

$$\left[\begin{matrix}f[i-1][1] & f[i-1][0]\end{matrix}\right]×\left[\begin{matrix}1 & 1\\1&0\end{matrix}\right]=\left[\begin{matrix}f[i][1] & f[i][0]\end{matrix}\right]$$

最终结果:

$$\left[\begin{matrix}f[n][1] & f[n][0]\end{matrix}\right]={\left[\begin{matrix}1 & 1\\1&0\end{matrix}\right]}^{n-1}×\left[\begin{matrix}f[1][1] & f[1][0]\end{matrix}\right]$$

快速幂求解

$${\left[\begin{matrix}1 & 1\\1&0\end{matrix}\right]}^{n-1}$$

与初始状态相乘即可.

因为初始状态无所谓, 那么我假定它为 $\left[\begin{matrix}1&0\end{matrix}\right]$, 则与这个初始状态相乘的答案恰为那个快速幂出的最终系数矩阵中 $3$ 个非零数的和.

我的代码:
```cpp
#include <cstring>
#include <cstdio>
#include <cctype>
#include <stack>
#include <iostream>
#define file

typedef long long LL;

const int mod = 1e9 + 7;

int T, ans;
LL n;

struct Matrix
{
    int a[3][3], R, C;

    Matrix()
    {
        R = C = 2;
        memset(a, 0, sizeof a);
    }

    void init()
    {
        R = C = 2;
        a[1][2] = a[2][1] = 0;
        a[1][1] = a[2][2] = 1;
    }

    friend Matrix operator*(const Matrix& x, const Matrix& y)
    {
        Matrix temp;
        temp.R = x.R, temp.C = y.C;
        for(register int i = 1; i <= temp.R; ++i)
            for(register int j = 1; j <= temp.C; ++j)
                for(register int k = 1; k <= x.C; ++k)
                    temp.a[i][j] += (LL)x.a[i][k] * y.a[k][j] % mod,
                    temp.a[i][j] %= mod;
        return temp;
    }
}coe, goal;

template<typename _Tp>
_Tp QuickPower(_Tp a, LL k)
{
    _Tp ret;
    ret.init();
    while(k)
    {
        if(k & 1)
            ret = ret * a;
        a = a * a;
        k >>= 1;
    }
    return ret;
}

class Fast_IO
{
    static const int MAX = 1e7;

    char inbuf[MAX], outbuf[MAX];
    char *in, *inend, *out;
    std::stack<char> stk;

    char get_char()
    {
        return in == inend and (inend = (in = inbuf) + fread(inbuf, 1, MAX, stdin), in == inend) ? EOF : *in++;
    }

    void put_char(char c)
    {
        if(out - outbuf == MAX)
            fwrite(outbuf, 1, MAX, stdout), out = outbuf;
        *out ++= c;
    }

public :
    Fast_IO()
    {
        in = inend = inbuf;
        out = outbuf;
    }

    ~Fast_IO()
    {
        fwrite(outbuf, 1, out - outbuf, stdout);
    }

    template<typename _Tp>
    Fast_IO& operator>>(_Tp& num)
    {
        num = 0;
        register char c;
        register bool flag = false;
        while(!isdigit(c = get_char()))
            if(c == '-')
                flag = true;
        while(num = (num << 3) + (num << 1) + (c ^ 48), isdigit(c = get_char()));
        if(flag)
            num = -num;
        return *this;
    }

    Fast_IO& operator<<(int num)
    {
        if(num < 0)
            put_char('-'), num = -num;
        do
        {
            stk.push(num % 10 + 48);
            num /= 10;
        } while(num);
        while(!stk.empty())
            put_char(stk.top()), stk.pop();
        return *this;
    }

    Fast_IO& operator<<(char c)
    {
        put_char(c);
        return *this;
    }

    Fast_IO& operator<<(const std::string& str)
    {
        for(register std::string::size_type i = 0; i < str.size(); ++i)
            put_char(str[i]);
        return *this;
    }
} wib;

int main()
{
    wib >> T;
    while(T--)
    {
        coe.R = coe.C = 2;
        coe.a[1][1] = coe.a[1][2] = 1;
        coe.a[2][1] = 1;
        coe.a[2][2] = 0;
        wib >> n;
        goal = QuickPower(coe, n - 1);
        ans = ((LL)goal.a[1][1] + goal.a[2][1] + goal.a[1][2]) % mod;
        wib << ans << '\n';
    }
}
```
# 4.题外话

感谢 @HNYLMS_Tea 提供的思路.

因机子卡, 我的 $AC$ 代码没有交上去, 导致我的 $100$ 变成了 $8$....

(中间只差了 $19s$)

还有, 这题为什么评成了紫题... 这题难度最多蓝题, 不能再多了...

# $Thank$ $you$ $for$ $your$ $consideration!$

---

## 作者：chengni (赞：2)

找不到官方题解啊。我先水一篇。

先解释一下题目意思吧，反正最开始我是懵逼了的。

就是有 $n$ 个位置，每个位置可以是 $1$ 或者 $0$ ，要求相邻的两个位置必须有一个是 $1$，问有多少种方案数，且不考虑对称即每个位置不同

我们可以敲一个dp，$f[i][j]$ 表示放到第 $i$ 位且第 $i$ 位为 $j$ 的方案数

```cpp
	f[1][1]=f[1][0]=1;
	for(int i=2;i<=n;i++){
		f[i][1]=f[i-1][1]+f[i-1][0];
		f[i][0]=f[i-1][1];
	}
```

诶似乎大了那么一点？

~~哦原来是环啊~~

我们再记录一下起始位置是 $1$ 还是 $0$

```cpp
	for(int i=2;i<=n;i++){
        f[i][1][0]=f[i-1][0][0]+f[i-1][1][0];
        f[i][1][1]=f[i-1][0][1]+f[i-1][1][1];
        f[i][1][0]%=p;
        f[i][1][1]%=p;
        f[i][0][0]=f[i-1][1][0];
        f[i][0][1]=f[i-1][1][1];
    }
```
本来以为能有 $60$ 分吧，比赛结束了一看居然 $M$ 了，出题人居然卡空间！

好接下来我们说一下正解

稍微用 DP 打个表就可以找出来规律了，是一个类似斐波那契的数列 $f[i]=f[i-1]+f[i-2]$

我没推出来公式，只好递推。由于数据范围太大，我们需要用到矩阵快速幂。

大概下面这个样子(我矩阵快速幂板子丑勿喷)

```cpp
#include<bits/stdc++.h>

using namespace std;

const long long  M=1000000007;

long long a[4][4];
long long ans[4][4];
long long dx[4][4];


void as(int n){
    for(int i=1;i<=n;i++)
     for(int j=1;j<=n;j++)
      dx[i][j]=ans[i][j],ans[i][j]=0;

    for(int i=1;i<=n;i++)
     for(int j=1;j<=n;j++)
      for(int k=1;k<=n;k++)
       ans[i][j]=(ans[i][j]+(a[i][k]*dx[k][j])%M)%M;
}


void df(int n){
    for(int i=1;i<=n;i++)
     for(int j=1;j<=n;j++)
      dx[i][j]=a[i][j],a[i][j]=0;
      
    for(int i=1;i<=n;i++)
     for(int j=1;j<=n;j++)
      for(int k=1;k<=n;k++)
       a[i][j]=(a[i][j]+(dx[i][k]*dx[k][j])%M)%M;
}

void kla(long long q,long long w){
    while(w)
    {
        if(w%2==1) as(q);
        w/=2;
        df(q);
    }
}


int main(){
    long long n,m=2;
    int t;
    cin>>t;
    while(t--){
        memset(a,0,sizeof(a));
        memset(ans,0,sizeof(ans));
        memset(dx,0,sizeof(dx));
        scanf("%lld",&n);
        if(n==1) {
        	cout<<1<<endl;
        	continue;
        }
        a[2][1]=ans[2][1]=1;
        a[1][2]=ans[1][2]=1;
        a[2][2]=ans[2][2]=1;
        kla(m,n-2);      
        printf("%lld\n",(ans[1][1]+3*ans[2][1])%M);
    }
    return 0;
}


```

注意一下 $1$ 的情况。

至于为什么是这个公式我也不太清楚，等出了官方题解再说吧















---

## 作者：xcxc82 (赞：1)


## 思路貌似跟dalao们的有点不一样
先前排声明一下,蒟蒻刚学OI没多久,而且是自学的,所以思路可能比较~~sb+累赘~~

### 大致题意


------------
给一串珠子,每个珠子黑白两种颜色,而且两个珠子中一定要有一个白色的珠子,求方案总数






------------

## 思路

既然每种珠子都有两种颜色,我们先假定前一个珠子是黑色的,那么后一个珠子就**必须是白色**(两个珠子中一定要有一个白色珠子) 如果是白色的,那就可以**有黑，白两种选择**，画成图的话大概就是这个样子
![](https://cdn.luogu.com.cn/upload/image_hosting/yso2g7i3.png)
图中所示为n=5的时候的情况

很明显可以看出n=5的所有可能是从n=3和n=4过来的

可以得出递推式

 $a_{n} =a_{n-1}+a_{n-2}$ 
 
 当然这个递推式显然是不对的,应为题目中给出的是一个环,所以要**减去开头结尾均为黑色的所有可能**
 
 ![](https://cdn.luogu.com.cn/upload/image_hosting/oth02jwr.png)
 
 观察一下不难发现**开头结尾均为黑色的可能为n-2的所有结尾为黑色的可能**
 
 我们这里设$b_{n}$为记录每个数字结尾为黑色的个数
 
 
 根据之前的递推式
 
可以发现$b_{n} =b_{n-3}+b_{n-4}$ (左右二分)

当n=1和n=2时$b_{n}$均为0 可以直接去掉

既$b_{n} =b_{n-1}+b_{n-2}$ 

那么就可以得到最终的递推式了

$f_{n} =a_{n-1}-b_{n-1}+a_{n-2}-b_{n-2}=a_{n}-b_{n}=f_{n-1}+f_{n-2}$ 

$\begin{cases}1(n=1)\\3 (n=2)\\f_{n} =f_{n-1}+f_{n-2}(n>=3)\end{cases}$ 

然后再套矩阵快速幂的模板就可以了

贴上丑陋不堪的辣鸡代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int mo=1000000007;
long long n,t;
struct matrix{
	long long int a[5][5];
}ans,a;
matrix operator *(const matrix &x,const matrix &y){
	matrix z;
	for(int i=1;i<=2;i++){
		for(int j=1;j<=2;j++){
			z.a[i][j]=0;
		}
	}
	for(int k=1;k<=2;k++){
		for(int i=1;i<=2;i++){
			for(int j=1;j<=2;j++){
				z.a[i][j]=(z.a[i][j]+(x.a[i][k]*y.a[k][j])%mo)%mo;
			}
		}
	}
	return z;
}
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		if(n==1){
			cout<<1<<endl;
		}
		
	else if(n==2){
		cout<<3<<endl;
	}
	else{
		for(int i=1;i<=3;i++){
				for(int j=1;j<=3;j++){
					a.a[i][j]=0;
					if(i==j) ans.a[i][j]=1;
					else ans.a[i][j]=0;
				}
			}
		a.a[1][2]=a.a[2][2]=a.a[2][1]=1;
		a.a[1][1]=0;
		n-=1;
		while(n){
			if(n&1) ans=ans*a;
			n>>=1;
			a=a*a;
		}
		cout<<(1*ans.a[1][1]+3*ans.a[1][2])%mo<<endl;
	}
	
	}
	return 0;
}
```




 
 
 



---

## 作者：Acestar (赞：1)

~~本题描述较为复杂，这里简单描述一下。~~

>把一个长度为 $n$ 的环用金色和绿色染色，求出有多少种染色方法使得相邻两个点必有一个是金色。

### 矩阵快速幂优化dp

先考虑如何 $dp$，用 $dp_{i,0}$ 表示第 $i$ 个点为金色的方案数，$dp_{i,1}$ 表示第 $i$ 个点为绿色的方案数，那么

$
\begin{cases}
dp_{i,0}=dp_{i-1,0}+dp_{i-1,1}& \\
dp_{i,1}=dp_{i-1,1}& \\
\end{cases}
$

因为如果 $i$ 为金色，那么 $i-1$ 两种颜色都可以，如果 $i$ 为绿色，那么 $i-1$ 只能为金色。

注意：因为这是一个环，所以要分别讨论第1个是金色或绿色的情况。

- 如果是金色，那么 $dp_{i,0}=1$，第 $n$ 个点两种颜色都可以，所以答案是 $dp_{n,0}+dp_{n,1}$

- 如果是绿色，那么 $dp_{i,1}=1，$第 $n$ 个只能是金色，所以答案是 $dp_{n,0}$

最后加起来取模就可以了。


接下来考虑如何优化。

因为第 $i$ 个点的答案只取决余 $i-1$，所以可以用矩阵快速幂。

不难发现

$$
\begin{bmatrix} dp_{i-1,0} & dp_{i-1,1} \\ 0 & 0 \end{bmatrix}
\quad
×
\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}
\quad
=
\begin{bmatrix} dp_{i,0} & dp_{i,1} \\ 0 & 0 \end{bmatrix}
\quad
$$

那么这道题就做完了。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define int long long	//注意这里 

using namespace std;

const int modd=1e9+7;
struct matrix
{
	int num[3][3];
	matrix()
	{
		memset(num,0,sizeof(num));
	}
	matrix operator * (const matrix &that) const	//矩阵乘法 
	{
		matrix r;
		for(int i=1; i<=2; i++)
			for(int j=1; j<=2; j++)
				for(int k=1; k<=2; k++)
					r.num[i][j]=(r.num[i][j]+num[i][k]*that.num[k][j]%modd)%modd;
		return r;
	}
	matrix operator ^ (int p)	//矩阵快速幂 
	{
		matrix r,a;
		memcpy(a.num,num,sizeof(num));
		for(int i=1; i<=2; i++)
			r.num[i][i]=1;
		for(; p; p>>=1,a=a*a)
			if(p&1) r=r*a;
		return r;
	}
};

matrix base;	//转移矩阵 
signed main()
{
	base.num[1][1]=base.num[1][2]=base.num[2][1]=1;
	int T;
	scanf("%lld",&T);
	while(T--)
	{
		int n,ans;
		matrix A,B;
		scanf("%lld",&n);
		A.num[1][1]=1;	//第1个点是金色的初始矩阵 
		B.num[1][2]=1;	//第1个点是绿色 
		A=A*(base^(n-1));
		B=B*(base^(n-1));
		ans=(A.num[1][1]+A.num[1][2]+B.num[1][1])%modd;
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：机房冒火 (赞：1)

p党的福利来了

  这道题就是简单的
  
  {我是一个蒟蒻
    第一次发题解}
  
   ~~找规律~~
   
   （斐波那契）大家应该都知道
   
    
    
    其实我打了一个表
     如下
      1  1
      2  3
      3  4
      4  7
      5  11
      6  18
      7  29
      8  47
      9  76
     发现5 和 9 都满足条件（和样例一样）
    看了一下数据
     才知道 o（n）是不够的
   顺便学了一个 矩阵乘求斐波那契
   记住要开int64；
   [](https://www.cnblogs.com/huxianglin/p/5995649.html)
   ```pascal
program ju;
const p=1000000007;
 var i:longint;
     j,k,n,m:int64;
     d:array[1..2,1..2] of int64;
     ans:array[1..2,1..2] of int64;
     c,a,b:array[1..2,1..2]of int64;
procedure calc1;
 var i,j,k:longint;
begin
  a:=d;b:=d;
  fillchar(c,sizeof(c),0);
  for i:=1 to 2 do
   for j:=1 to 2 do
    for k:=1 to 2 do

       c[i,k]:=(c[i,k]+a[i,j]*b[j,k])mod p;
    d:=c;

end;
procedure calc2;
 var i,j,k:longint;
begin
  a:=d;b:=ans;
  fillchar(c,sizeof(c),0);
  for i:=1 to 2 do
   for j:=1 to 2 do
    for k:=1 to 2 do
       c[i,k]:=(c[i,k]+a[i,j]*b[j,k])mod p;
    ans:=c;
end;

procedure quick(n:int64);
begin

  while n>0 do
    begin
      if (n and 1)>0 then calc2;
      calc1;
      n:=n shr 1;
    end;

end;

begin
 read(n);
 for i:=1 to n do
  begin
   read(m);
   d[1,1]:=1;d[1,2]:=1;
   d[2,1]:=1;d[2,2]:=0;
   ans[1,1]:=3;ans[1,2]:=1;
   ans[2,1]:=1;ans[2,2]:=0;
   if m=1 then begin writeln(1);continue;end;
   if m=2 then begin writeln(3);continue;end;
   quick(m-2);
   writeln(ans[1,1]);

  end;
end.

```   
     
    

---

## 作者：yzhang (赞：1)

### [原题传送门](https://www.luogu.org/problemnew/show/P4910)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/10890998.html)

#### “连续的两个中至少有1个金的”珂以理解为“不能有两个木相连”

#### 我们考虑一个一个将元素加入手环

#### 设f$[i][0/1]$表示长度为$i$手环末尾有$0/1$个木的种类数

#### 仔细想想发现它实际就是一个斐波那契数列（$fib[1]=fib[2]=1$）

#### 因为首尾相接，所以开头要分类讨论

- ####  第一个是金：对答案的贡献为$fib[n]+fib[n-1]$

- ####  第一个是木：对答案的贡献为$fib[n-1]$

#### 矩阵快速幂即可

```cpp
#include <bits/stdc++.h>
#define ll long long
#define mod 1000000007
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline ll read()
{
    register ll x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
struct mat{
	int a[2][2];
	inline mat()
	{
		memset(a,0,sizeof(a));
	}
	inline mat operator*(const mat&b)const{
		mat c;
		for(register int i=0;i<2;++i)
			for(register int j=0;j<2;++j)
				for(register int k=0;k<2;++k)
					c.a[i][j]=(c.a[i][j]+1ll*a[i][k]*b.a[k][j])%mod;
		return c;
	}
}s,o,ans;
inline mat fastpow(register mat a,register ll b)
{
	mat res;
	res.a[0][0]=res.a[1][1]=1;
	while(b)
	{
		if(b&1)
			res=res*a;
		a=a*a;
		b>>=1;
	}
	return res;
}
int T;
ll n;
int main()
{
	T=read();
	s.a[0][0]=s.a[0][1]=s.a[1][0]=1;
	o.a[0][0]=1;
	while(T--)
	{
		n=read();
		ans=o*fastpow(s,n-1);
		write((1ll*ans.a[0][0]+ans.a[0][1]*2ll)%mod),puts("");
	}
	return 0;
}

```

---

## 作者：Suzt_ilymtics (赞：0)



[更好的阅读体验？](https://www.cnblogs.com/Silymtics/p/solution-P4910.html)

## Description

> 对一个长度为 $n$ 的环 $01$ 染色，要求相邻两个数之间必须有一个 $1$，求方案数。$T$ 组询问。

## Solution

设 $f_i$ 表示长度为 $i$ 的环的方案数。

你发现标签里有斐波那契，然后你准备猜一手结论。

用脚想一想就能得到 $f_1 = 1$（只有 $1$ 这一种方案），$f_2 = 3$ （有 $11,01,10$ 这三种方案）。然后你想到了斐波那契的递推公式：

$$f_i = f_{i - 1} + f_{i - 2}$$

你在打草纸上模拟出了 $f_5 = 11$。

并花了 $5min$ 用计算器验证了 $f_9 = 76,f_{20} = 15127$ 的结果。

然后你花 $10min$ 写了个矩阵快速幂，然后你把它切了。。。

考虑正确性：

考虑第 $i$ 个位置，如果上个金在 $i-2$ 的位置出现，你可以在这里放一个金，如果上个金在 $i-1$ 的位置出现，你也可以在这里放一个金。不难发现只有这两种转移是合法的，前 $i-1$ 长度的项链的所有合法方案**有且仅有**这两种情况，所以到当前位置的方案数就是前两个位置的方案数的和。

这个转移比较套路，矩阵快速幂加速转移即可，如果不懂可以来看一下我写的这篇博客[矩阵乘法](https://www.cnblogs.com/Silymtics/p/14408381.html)。

总复杂度为 $O(T \times 2^3 \log n)$。

## Code

```cpp
/*
Work by: Suzt_ilymics
Problem: 不知名屑题
Knowledge: 垃圾算法
Time: O(能过)
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#define int long long
#define orz cout<<"lkp AK IOI!"<<endl

using namespace std;
const int MAXN = 1e5+5;
const int INF = 1e9+7;
const int mod = 1e9+7;

struct Matrix {
    int a[2][2];
    Matrix () { memset(a, false, sizeof a); }
    Matrix operator * (Matrix b) {
        Matrix res;
        for(int i = 0; i < 2; ++i) 
            for(int j = 0; j < 2; ++j) 
                for(int k = 0; k < 2; ++k) 
                    res.a[i][j] = (res.a[i][j] + a[i][k] * b.a[k][j] % mod) % mod;
        return res;
    }
    Matrix operator ^ (int p) {
        Matrix res, x = *this;
        res.a[0][0] = res.a[1][1] = 1;
        while(p) {
            if(p & 1) res = res * x;
            x = x * x, p >>= 1;
        }
        return res;
    }
}ans, base;

int read(){
    int s = 0, f = 0;
    char ch = getchar();
    while(!isdigit(ch))  f |= (ch == '-'), ch = getchar();
    while(isdigit(ch)) s = (s << 1) + (s << 3) + ch - '0' , ch = getchar();
    return f ? -s : s;
}

void Init() {
    ans.a[0][0] = 3, ans.a[0][1] = 1;
    ans.a[1][0] = 0, ans.a[1][1] = 0;
    base.a[0][0] = 1, base.a[0][1] = 1;
    base.a[1][0] = 1, base.a[1][1] = 0;
}

signed main()
{
    int T = read();
    while(T--) {
        int n = read();
        if(n == 1) puts("1");
        else if(n == 2) puts("3");
        else {
            Init();
            base = base ^ (n - 2);
            ans = ans * base;
            printf("%lld\n", ans.a[0][0]);
        }
    }
    return 0;
}
```

---

## 作者：幻离ian (赞：0)


## 题意：

一串长为n的环状手环，相邻两个珠子至少有一个是金属性，求方案数。

打表得：


| n | 1 | 2 | 3 | 4 | 5 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| f | 1  |3  | 4  | 7 | 11 |



发现$f_{i}=f_{i-1}+f_{i-2}$，直接用斐波那契矩阵加速做。

### ~~Over~~

## **正解：** 

递推推一下。

假设$f_1$~$f_{i-1}$都已求得，则第$i$个珠子有两种可能：

1. **金** ，则剩下$i-1$个珠子怎么选都行，有$f_{i-1}$种可能。

1. **木** ，则剩下$i-1$个珠子与之相邻的一个珠子必须是金的，剩下$i-2$个珠子随便放，有$f_{i-2}$种可能。

综上，递推式$f_{i}=f_{i-1}+f_{i-2}$，和斐波那契数列一模一样，直接套矩阵加速板子即可。


$ { \left [ \begin{array}{cc} f_i\\ f_{i-1}  \end{array} \right ]}={ \left [ \begin{array}{cc}1 & 1 \\1& 0 \end{array} \right ]}\times{ \left [ \begin{array}{cc} f_{i-1}\\ f_{i-2}  \end{array} \right ]}$



$f_1=1$,$f_2=3$

最后记得n=1,2时加个特判。

---

## 作者：loceaner (赞：0)

## 题意

多组数据，给出一个环，要求不能有连续的$1$，求出满足条件的方案数

 $1\le T \le 10, 1\le n \le 10^{18}$

## 思路

### 20pts

暴力枚举~~（不会写~~

### 60pts

假设金珠子为$0$，木珠子为$1$，则不能有连续的木珠子

线性递推$DP$，设$f[i][0/1]$表示当前填到第$i$位，第$i$位为金珠子/木珠子的方案数，那么有：

$$f[i][0] = f[i - 1][0] + f[i - 1][1]$$

$$f[i][1] = f[i-1][0]$$

但是要分成两种情况讨论

- 第一个位置是$0$，则$f[1][0]=1,f[1][1]=0$，那么最后一个位置可以是$0$也可以是$1$

  所以此时对答案的贡献为$f[n][0]+f[n][1]$

- 第一个位置是$1$，则$f[1][1]=1,f[1][0]=0$，那么最后一个位置只能是$0$

  所以此时对答案的贡献为$f[n][0]$

时间复杂度$O(Tn)$，期望得分$60$分

~~不知道为什么，也许是我写假了，只有48分~~

### 100pts

考虑用矩阵优化，目前的状态为$[f_{i,0},f_{i,1}]$，目标状态为$[f_{i+1,0},f_{i+1，1}]$，比较容易推出转移矩阵为

$$[f_{i,0},f_{i,1}] * \left[ \begin{matrix}   1 & 1 \\   1 & 0 \end{matrix}  \right] = [f_{i+1,0},f_{i+1，1}]$$

按照$60$分做法写矩阵快速幂就好了

## 代码

### 60pts

```cpp
/*
Author:loceaner
假设不能有连续的1 
用f[i][0/1]表示选到了i处，第i处为白/黑的方案数
f[i][1] = f[i - 1][0]
f[i][0] = f[i - 1][1] + f[i - 1][0]
*/
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

const int A = 1e6 + 10000;
const int B = 1e6 + 11;
const int mod = 1000000007;
const int inf = 0x3f3f3f3f;

inline int read() {
	char c = getchar(); int x = 0, f = 1;
	for( ; !isdigit(c); c = getchar()) if(c == '-') f = -1;
	for( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
	return x * f;
}

int n, f[A][2];

int main() {
	int T = read();
	while(T--) {
		n = read();
		long long ans = 0;
		f[1][0] = 1, f[1][1] = 0;
		for (int i = 2; i <= n; i++) {
			f[i][1] = f[i - 1][0] % mod;
			f[i][0] = (f[i - 1][1] + f[i - 1][0]) % mod;
		} 
		ans = (f[n][0] + f[n][1]) % mod; 
		f[1][0] = 0, f[1][1] = 1;
		for (int i = 2; i <= n; i++) {
			f[i][1] = f[i - 1][0] % mod;
			f[i][0] = (f[i - 1][1] + f[i - 1][0]) % mod;
		} 
		(ans += f[n][0]) %= mod;
		cout << ans << '\n';
	}
	return 0;
}
```

### 100pts

```cpp
/*
Author:loceaner
*/
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define int long long
using namespace std;

const int A = 1e6 + 10000;
const int B = 1e6 + 11;
const int mod = 1000000007;
const int inf = 0x3f3f3f3f;

inline int read() {
	char c = getchar(); int x = 0, f = 1;
	for( ; !isdigit(c); c = getchar()) if(c == '-') f = -1;
	for( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
	return x * f;
}

int n;

struct mat { int a[2][2]; } a, b, c;

mat operator * (const mat &a, const mat &b) {
	mat c;
	memset(c.a, 0, sizeof(c.a));
	for (int k = 0; k <= 1; k++) 
		for (int i = 0; i <= 1; i++)
			for (int j = 0; j <= 1; j++)
				c.a[i][j] = (c.a[i][j] + a.a[i][k] % mod * b.a[k][j] % mod) % mod;
	return c;
}

mat ksm(mat a, int b) {
	mat ans;
	memset(ans.a, 0, sizeof(ans.a));
	for (int i = 0; i <= 1; i++) ans.a[i][i] = 1;
	while (b) {
		if (b & 1) ans = ans * a;
		a = a * a, b >>= 1;
	}
	return ans;
}

signed main() {
	int T = read();
	while(T--) {
		n = read();
		int ans = 0;
		memset(a.a, 0, sizeof(a.a));
		a.a[0][0] = a.a[0][1] = a.a[1][0] = 1;
		a = ksm(a, n - 1);
		memset(b.a, 0, sizeof(b.a));
		b.a[0][0] = 1, b = b * a;
		ans = (ans + b.a[0][0] % mod + b.a[0][1]) % mod;
		memset(c.a, 0, sizeof(c.a));
		c.a[0][1] = 1, c = c * a;
		ans = (ans + c.a[0][0]) % mod;
		cout << ans << '\n';
	}
}
```

---

## 作者：Azazеl (赞：0)

$\ \ \ \ $将近一个月没写题解了（惊恐）  


------------
#### 题意  
$\ \ \ \ $给出一个长度为 $n$ 的环，在环内每个点填上 $0/1$ （对应绿色和金色珠子） 使得任意两个相邻点中至少有一个 $1$（金色珠子）。  


------------

#### 题解

- Algorithm 1

$\ \ \ \ $我们可以很容易地想到破环为链进行区间DP，但显然 $n\le 10^{18}$ 的数据范围让你连 $\mathcal{O}(n)$ 都会 TLE，所以这种 $\mathcal{O(n^3)}$ 的方法肯定不行.   

$\ \ \ \ $期望得分: $40pts$

- Algorithm 2 

$\ \ \ \ $我们发现其实这个**环**它只会对第一个与最后一个位置之间的决定产生影响，因此我们直接先把它当成区间来做。  
$\ \ \ \ $设 $dp_{i,0},dp_{i,1}$表示 $i$ 位置放 $0$（绿色珠子） 和 $1$（金色珠子）各自的方案数，可以推得
$$\left\{\begin{array}{l}
dp_{i,0}=dp_{i-1,1}\\ 
dp_{i,1}=dp_{i-1,1}+dp_{i-1,0}
\end{array}\right.$$  
$\ \ \ \ $直接按照这个式子进行中间部分的 dp 即可，但我们还需要考虑环形的首尾的问题，我们可以以第一个位置上珠子的种类分类讨论:  
$\ \ \ \ $① 若第一颗珠子为金色，即 $1$，此时  $dp_{1,1}=1,dp_{1,0}=0$ ,答案为 $dp_{i,0}+dp_{i,1}$ 。  
$\ \ \ \ $② 若第一颗珠子为绿色，即 $0$，此时  $dp_{1,1}=1,dp_{1,0}=0$ ,答案为 $dp_{i,1}$。  
$\ \ \ \ $注意第二个式子的地方，在那里其实根本不应该在中间 dp 的时候转移出 $dp_{n,0}$ ，因为当两边都是绿色 ( $0$ ) 的时候那里也肯定不能放绿色，但由于之后不需要再利用 $dp_{n,0}$ ，所以我们仅仅在统计答案的时候忽略掉即可。  

$\ \ \ \ $至此为止，我们可以用 $\mathcal{O(T}n\mathcal{)}$ 的时间复杂度解决这个问题了，但它仍然不够优秀，因为 $n$ 还是很大。  

$\ \ \ \ $期望得分:$60pts$   

- Algorithm 3  
$\ \ \ \ $观察上面推出来的式子，发现对于两个式子它都是**递推**的形式，并且神似变形后的斐波那契数列，所以我们应该想到它可以进行矩阵加速。

$$\quad
\begin{bmatrix} dp_{i-1,0} \\dp_{i-1,1}\end{bmatrix} 

\rightarrow 

\begin{bmatrix} dp_{i,0} \\ dp_{i,1}\end{bmatrix}

=

\begin{bmatrix} 0\times dp_{i-1,0}+1\times dp_{i-1,1} \\ 1\times dp_{i-1,0}+1\times dp_{i-1,1}\end{bmatrix}

\quad$$  

$\ \ \ \ $由此可得  
$$\quad
\begin{bmatrix} dp_{i,0} \\ dp_{i,1}   
\end{bmatrix}=\begin{bmatrix}0,1\\ 1,1   
\end{bmatrix} \times \begin{bmatrix} dp_{i-1,0} \\ dp_{i-1,1}   
\end{bmatrix}
\quad$$  

$\ \ \ \ $显然左乘部分可以直接快速幂计算，所以现在我们已经算法优化到了 $\mathcal{O(T\ } \log n\mathcal{)}$，可以通过此题了。  

$\ \ \ \ $期望得分：$100pts$  



------------
#### 代码  
```cpp
#include <cstdio>
#include <cstring>
#define ll long long
using namespace std;
const ll WY=1000000007;//日常膜拜巨佬
struct matrix{
	ll a[8][8];
	matrix(){memset(a,0,sizeof(a));}//注意矩阵的初始化
}mat,f1,f2;
inline matrix mul(matrix a,matrix b)
{
	matrix c;
	for(ll i=1;i<=2;i++)
	{
		for(ll k=1;k<=2;k++)
		{
			for(ll j=1;j<=2;j++) c.a[i][j]=(c.a[i][j]+a.a[i][k]*b.a[k][j])%WY;
		}
	}
	return c;
}
inline matrix qpow(matrix a,ll b)
{
	matrix c;
	for(ll i=1;i<=2;i++) c.a[i][i]=1;
	while(b)
	{
		if(b&1) c=mul(a,c);
		b>>=1;
		a=mul(a,a);
	}
	return c;
}
int main() {
	//这里构造矩阵的时候笔者是先放的dp[i-1][1]
 	//因此与上面的题解有所不同
	mat.a[1][1]=1,mat.a[1][2]=1;
	mat.a[2][1]=1,mat.a[2][2]=0;
	
	f1.a[1][1]=1,f1.a[2][1]=0;
	f2.a[1][1]=0,f2.a[2][1]=1;
	ll T,n;
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%lld",&n);
		matrix s1=mul(qpow(mat,n-1),f1),s2=mul(qpow(mat,n-1),f2);
		printf("%lld\n",(s1.a[1][1]+s1.a[2][1]+s2.a[1][1])%WY);
	}
	return 0;
}
```  



------------
路漫漫其修远兮，吾将上下而求索

---

## 作者：Sakura_梦瑶 (赞：0)

这道题通过推算通项公式可以理性推算出和斐波那契数列有逻辑关系,但是用斐波那契思想写此题是要求log的,但是既然都是矩阵快速幂为何不尝试直接利用题目约束构造矩阵,写法也更佳,这题思想直接,直接构造一个起始点为n=2时候的答案矩阵,意义为以金或木开头结尾为金或木的方案数,但是仅仅是头尾不合法的要保留,因为它依旧有合法贡献.另一个约束矩阵2*2.表示各个情况下选金或木是否合法.然后就是暴力快速幂.
代码实现的时注意判断n=1.我这里是注意到了还判爆了.因为n先-=2,然后我直接判1,然后re。。。这种错误很尴尬但就是改不掉....
```cpp
#include<bits/stdc++.h>
#define mod 1000000007
#define fer(x,y,z) for(register short x=y;x<=z;x++)
using namespace std;
struct q{long long a[2][2];}A[70],B[70];long long n;
void mul(q a,q b,q &c){
	memset(c.a,0,sizeof c.a);
	fer(i,0,1)fer(k,0,1)fer(j,0,1)
	(c.a[i][k]+=(a.a[i][j]*b.a[j][k])%mod)%=mod;
}
int main(){
	B[1].a[0][1]=B[1].a[1][1]=B[1].a[1][0]=1;
	A[1].a[0][1]=A[1].a[1][0]=A[1].a[1][1]=1;
	fer(i,1,65)mul(B[i],B[i],B[i+1]);
	short t,now,cnt;cin>>t;while(t--){
		cin>>n,n-=2,now=1,cnt=1;
		if(n==-1){cout<<1<<'\n';continue;}
		else if(n==0){cout<<3<<'\n';continue;}
		while(n){if(n&1)mul(A[now],B[cnt],A[now+1]),now++;cnt++,n>>=1;}
		cout<<(A[now].a[0][1]+A[now].a[1][1]+A[now].a[1][0])%mod<<'\n';
	}
}
```

---


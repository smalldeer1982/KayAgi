# 专心OI - 跳房子

## 题目背景

Imakf 有一天参加了 PINO2017 PJ 组，他突然看见最后一道题：

![](https://cdn.luogu.com.cn/upload/pic/39659.png )

他十分蒟蒻，写不出来。

而如今他还是一个蒟蒻，他又看见一道题：

![](https://cdn.luogu.com.cn/upload/pic/39660.png)

他还是写不出来，于是便来请教您。

## 题目描述

您有 $N$ 个格子，排成一行，从左往右编号为 $1,2,\cdots,N$。您站在 $1$ 号格子的左边无限远，开始从左往右跳，跳到 $N$ 号格子右侧为止。由于您是一位成功的 OIer，您自然长得很胖，所以您的腿部力量也非常大！这使得您跳一次，当前格子到目标格子中间必须至少空出来 $M$ 格，但您可以跳无数格远！

您认为这么跳太没意思了，于是便想计算出有多少种方案可以跳完全程。由于方案可能过多，您会输出方案数量模 $(10^9+7)$ 的值

方案不同当且仅当经过的任一一个格子编号不同。

## 说明/提示

| 测试数据编号 | $N$ | $M$ |  
| :-----------: | :-----------: | :-----------: |
|$1,2$ | $\leq10$ | $=1$ |    
| $3,4$ | $\leq10^7$ | $=1$ |    
| $5,6$ | $\leq10^6$ | $=2$ |  
| $7,8$ | $\leq10^5$ | $=3$ |  
| $9,10$ | $\leq10^4$ | $=5$ |  
| $11,12$ | $\leq10^{12}$ | $=1$ |  
| $13,14$ | $\leq10^{18}$ |$=10$  |  
| $15\sim20$ | $\leq10^{18}$ |  $=15$|  

对于 $100\%$ 的数据，满足 $1 \le N \le 10^{18}$。

## 样例 #1

### 输入

```
5 1 
```

### 输出

```
13
```

## 样例 #2

### 输入

```
6 2 
```

### 输出

```
13
```

# 题解

## 作者：Imakf (赞：18)

PS:本题目题解涉及到的矩阵表示方法可能有点问题……凑和着看吧

本题受 [[SCOI2005]互不侵犯](https://www.luogu.org/problemnew/show/P1896)启发而出

题目简化一下……把$N$个无色格子排成一行，可以把某些格子染成黑色，但两个黑色格子之间必须至少有$M$个无色格子

题目没出$M=0$因为这样就成了快速幂了，但是……$STD$还是快速幂

## $10pts$ dfs爆搜

```cpp
#include<iostream>
#include<cstdio>
#define max(a,b) (a>b?a:b)
long long n,m;
#define mod (1000000007)
int cnt;
void dfs(int now){
    if(now>n){
        if(cnt==mod)	cnt=0;
        ++cnt;
        return;
    }
    if(now+m+1>n){
        if(cnt==mod)	cnt=0;
        ++cnt;
        return ;
    }
    for(register int i=max(1,now+1+m);i<=n+1;++i)
        dfs(i);
}

int main(){
    scanf("%lld%lld",&n,&m);
    dfs(-20);
    printf("%d",cnt);
    return 0;
}
```

顺带收获$TLE*8,MLE*10$

## 这是找规律好题鸭！

## $20pts$ 考虑$M=1,N<=10^7$

| $N$ | $ANS$ |
| -----------: | -----------: |
| $1$ | $2$ |
| $2$ | $3$ |
| $3$ | $5$ |
| $4$ | $8$ |
| $5$ | $13$ |

是否发现什么奥秘？

然而就是斐波那契数列……

```

    scanf("%lld%lld",&n,&m);
    long long a=2,b=3,c=0;
    for(register int i=1;i<n;++i){
    	c=a+b;
    	c%=mod;
    	a=b,b=c;
    }
    printf("%lld",a);

```

这20分爽吧

## $30pts $ 矩阵优化一波

这样应该可以过$M=1$的所有数据啦

不会矩阵乘法？洛谷有优质的[模板1](https://www.luogu.org/problemnew/show/P3390)，[模板2](https://www.luogu.org/problemnew/show/P1939)去看题解吧！

## $50pts$ 让我们继续找规律

再看看$M=2$

| $N$ | $ANS$ |
| -----------: | -----------: |
| $1$ | $2$ |
| $2$ | $3$ |
| $3$ | $4$ |
| $4$ | $6$ |
| $5$ | $9$ |

您可以发现前$3$项值都是$N+1$ 之后$ANS_i=ANS_{i-1}+ANS_{i-3}$

好玩吧？

您也可以自己寻找$M=3$ 的规律,不过我在这里给出结论

$\begin{cases} S_i=i+1,~~~~i\in[1,M+1] \\ S_i=S_{i-1}+S_{i-1-M},~~~~i\in[M+2,\infty]  \end{cases} $

不知道这些数学符号对不对呀…………我只是个初中生

（如果您是递归做的只有$45pts$,因为会$MLE$）

## $100pts$ 继续矩阵优化

矩阵的大小和数值随$M$变化

原矩阵为

$\begin{matrix} ANS_1~~~ANS_2~...~ANS_{M+1} \end{matrix}$

乘一遍矩阵应该变成

$\begin{matrix} ANS_2~~~ANS_3~...~ANS_{M+2} \end{matrix}$

下面讨论用来乘的矩阵

可以发现$M=1$时，矩阵应该为

$\begin{matrix} 0~~~~1\\1 ~~~~1 \end{matrix}$

$M=2$时，矩阵为

$\begin{matrix} 0~~~~0~~~~1\\1 ~~~~0~~~~0\\0~~~~1~~~~1 \end{matrix}$

$M=3$时，矩阵为

$\begin{matrix} 0~~~~0~~~~0~~~~1\\1 ~~~~0~~~~0~~~~0\\0~~~~1~~~~0~~~~0\\0~~~~0~~~~1~~~~1 \end{matrix}$

$M=4$时，矩阵为

$\begin{matrix} 0~~~~0~~~~0~~~~0~~~~1\\1 ~~~~0~~~~0~~~~0~~~~0\\0~~~~1~~~~0~~~~0~~~~0\\0~~~~0~~~~1~~~~0~~~~0\\0~~~~0~~~~0~~~~1~~~~1 \end{matrix}$

规律很明显了

![](https://cdn.luogu.com.cn/upload/pic/40622.png )

这个斜率为$-1$的长条上都是$1$，最后一列第一个和最后一个是$1$除此之外都是$0$,如此构造矩阵即可！

~~您也许可以写个dp，但是不知道多少分~~

然后搞矩阵快速幂即可

---

## 作者：NaCly_Fish (赞：13)

日常生成函数艹水题，~~平角裤，平角裤！~~（指我自己）

形式化题意：将 $n+m$ 拆分为若干个有序正整数，每部分至少为 $m+1$，求方案数。

显然答案的生成函数
$$F(x)=\sum_{k=0}^\infty\left( \frac{x^{m+1}}{1-x}\right)^k$$
$$F(x)=\left( 1-\frac{x^{m+1}}{1-x}\right)^{-1}$$
$$F(x)=\frac{1-x}{1-x-x^{m+1}}$$
不难得出递推式
$$a_n=a_{n-1}+a_{n-m-1}$$

对于 $n\le m$，$a_n=1$，答案显然为 $a_{n+m}$。  

此题中矩阵快速幂即可解决，时间复杂度 $\Theta(m^3\log n)$；  
用多项式取模 +FFT 可以优化到 $\Theta(m \log m \log n)$。

但是这个递推式非常特殊，很吸引人进一步探究（迫真）  
如果有更优的想法欢迎讨论。

---

## 作者：Adove (赞：6)

这道题的式子大约是这样的

$F[i]=\sum_{j=0}^{i-m-1}F[j]$

那么显然我们构造矩阵中要有前缀和，并且要保留m+1项

$B=\begin{bmatrix} Sum_{i-1} \\F_i \\ \vdots \\ F_{i-m} \end{bmatrix}$

令$A \times B=\begin{bmatrix} Sum_{i-1}+F_{i} \\F_i+F_{i-m} \\ \vdots \\ F_{i-m+1} \end{bmatrix}$

则有$A=\begin{bmatrix} 1 & 1 & 0 & \cdots & 0 \\ 0 & 1 &0 & \cdots & 1 \\ 0 & 1 & 0 & \cdots & 0 \\ \vdots & \ddots & \ddots & \ddots & \vdots \\ 0 & \cdots & \cdots & 1 & 0 \end{bmatrix}$

然后初始化跑矩阵快速幂就好啦

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int siz=25;
const int MOD=1e9+7;

long long n;
int m;
struct Matrix{
    int v[siz][siz];
    int x,y;
    
    void reset(){memset(v,0,sizeof(v));x=y=0;}
    void Mmul(Matrix a,Matrix b)
    {
        reset();
        x=a.x,y=b.y;
        int c=a.y;
        for(int i=1;i<=x;++i){
            for(int j=1;j<=y;++j){
                for(int k=1;k<=c;++k){
                    v[i][j]=(v[i][j]+(long long)a.v[i][k]*b.v[k][j])%MOD;
                }
            }
        }return;
    }
    
    Matrix Mpw(Matrix a,long long b)
    {
        Matrix x;x.reset();x.x=x.y=a.x;
        for(int i=1;i<=x.x;++i) x.v[i][i]=1;
        while(b){
            if(b&1) x.Mmul(x,a);
            b>>=1;a.Mmul(a,a);
        }return x;
    }
}A,B;

int main()
{
    scanf("%lld%d",&n,&m);
    if(n<=m){printf("%lld\n",n+1);return 0;}
    A.x=A.y=m+2;B.x=m+2;B.y=1;for(int i=2;i<=m+2;++i) B.v[i][1]=1;B.v[1][1]=m+1;
    A.v[1][1]=A.v[1][2]=1;
    A.v[2][2]=A.v[2][m+2]=1;
    for(int i=3;i<=m+2;++i) A.v[i][i-1]=1;
    A=A.Mpw(A,n-m);
    B.Mmul(A,B);
    printf("%d\n",B.v[1][1]);
    return 0;
}
```

---

## 作者：刘辰雨 (赞：4)

# P5004 专心OI - 跳房子 题解

### 题意：

对于一个数组 $a_1,a_2\dots a_{n-1},a_n$ ,  有 $a_{i}=\sum\limits_{k=1}^{n-m-1}{a_k} $ 。 $n$ 和 $m$ 由输入给出。

### 思路：

1. 考虑 $n \le 10^{18}$ ， 遍历 $1$ 到 $n-m-1$ 的时间复杂度接近 $\mathcal{O}(n)$ ,指定超时，考虑**前缀和优化**， 定义 $Pre_i=\sum\limits_{k=1}^{i}{a_i}$ 。

2. 前缀和优化后，整体时间复杂度 $\mathcal{O}(n)$ ，指定超时，于是可以明白，这是一道**矩阵加速**的好题。 Ps : 矩阵神罚/雾

3. 前缀和 & 矩阵乘法，于是考虑将 $a_i,a_{i-1},\dots a_{i-m},a_{i-m-1}$  作为整体递推，长度 $m+1$ 。构造出的 $(m+1)\times (m+1)$ 的 $Base$ 矩阵如下（以 $5\times 5$ 举例） :

$\begin{pmatrix}  
  1 & 1 & 0 & 0 & 0 \\  
  0 & 0 & 1 & 0 & 0 \\
  0 & 0 & 0 & 1 & 0 \\
  0 & 0 & 0 & 0 & 1 \\
  1 & 0 & 0 & 0 & 0
\end{pmatrix} $ 


各题解构造的矩阵的结构大同小异，因各人代码而异，**建议自己构造**。

### Code:

其余细节详见代码。

仅出示部分代码。


```cpp
struct Array
{
    long long F[20][20];
    void Print(void)
    {
        for(int i = 1 ; i<= M ; i++)
        {
            for(int j = 1 ; j<= M ; j++)
            {
                printf("%lld ",F[i][j]);
            }
            puts("");
        }
    }
};//定义矩阵结构体，较慢，不推荐。

Array operator * (Array A,Array B)
{
    Array R;
    memset(R.F,0,sizeof(R.F));
    for(int i = 1 ; i<= M ; i++)
    {
        for(int j = 1 ; j<= M ; j++)
        {
            for(int k = 1 ; k<= M ; k++)
            {
                R.F[i][j] += ((A.F[i][k]%MOD) * (B.F[k][j]%MOD) + MOD) % MOD;
                R.F[i][j] %= MOD;
            }
        }
    }
    return R;
}//重加载，效果等同函数，较慢，不推荐。

Array FastMix(Array A,long long p)
{
    Array Answer;
    memset(Answer.F,0,sizeof(Answer.F));
    for(int i = 1 ; i<= M ; i++)
        Answer.F[i][i] = 1;
    while(p)
    {
        if(p&1)
            Answer = Answer * A;
        A = A * A;
        p >>= 1;
    }
    return Answer;
}//矩阵快速幂，矩阵加速板子，重加载在这里显得很方便。

int main()
{
    scanf("%lld%lld",&N,&M);
    M++;
    Array A,G;
    memset(A.F,0,sizeof(A.F));
    memset(G.F,0,sizeof(G.F));
    for(int i = M ; i >= 1 ; i--)
    {
        A.F[1][i] = A.F[1][i+1] + 1;
    }
    if(N < M+1)
    {
        printf("2\n");
        return 0;
    }//特判，不判95分
    for(int i = 1 ; i < M ; i++)
    {
        G.F[i][i+1] = 1;
    }
    G.F[1][1] = G.F[M][1] = 1;

    A = A * FastMix(G,N-M+1);

    printf("%lld\n",A.F[1][1]%MOD );
```

### 写在最后：

此题较为简单，接近裸矩阵加速，**建议降蓝**。

---

## 作者：hovny (赞：3)

## [题面](https://www.luogu.org/problemnew/show/P5004)

把$N$个无色格子排成一行，选若干个格子染成黑色，要求每个黑色格子之间至少间隔$M$个格子，求方案数

## 思路：

### 矩阵加速

根据题面，这一题似乎可以用递推

设第$i$个格子的编号为$i$，有$i$个格子时的方案数为$f(i)$

显然，当 $i \le M+1$ 时，

可以所有格子**不染色**（方案数为$1$种，或者**最多**有**一个格子**染色（方案数为$i$种）

所以有$f(i)=i+1$

当$i>M+1$时，

对于第$i$个格子可以由第$i-1$个格子转移过来，

而第$i$个格子有两种情况

> 1、不染色，显然可以这种情况下方案数为$f(i-1)$
>
> 2、染色，可以看出第$[i-m,i-1]$个格子必定**不染色**，也就是没有贡献的，方案数为$f(i-m-1)$

但是！

$N \le 10^{18}$，$M \le 15$

可以使用**矩阵加速递推**

### 求解

我们要记录的是应该是$f(i) \to f(i+m)$一共$m+1$个元素，于是就用一个$(M+1)^2$的矩阵进行加速，配合快速幂求解

Code：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define Mod 1000000007
#define N 20
using namespace std;
int n;
ll b;
struct node{//矩阵放结构体里
	ll f[N][N];
}res,a;
node operator* (const node a,const node b)//重载*运算
{
	int i,j,k;
	node c;ll res;
	for(i=0;i<n;i++)
		for(j=0;j<n;j++)
		{
			res=0;
			for(k=0;k<n;k++)
				res=(res+a.f[i][k]*b.f[k][j])%Mod;
			c.f[i][j]=res;
		}
	return c;
}
void init(){//初始化
	int i;
	for(i=0;i<n;i++) res.f[0][i]=i+2;//矩阵下标从0开始，所以+2
	for(i=0;i<n-1;i++) a.f[i+1][i]=1;
	a.f[n-1][n-1]=a.f[0][n-1]=1;
}
void quickPow(ll b)
{
	while(b)
	{
		if(b&1) res=res*a;
		b>>=1;a=a*a;
	}
}
int main()
{
    scanf("%lld%d",&b,&n);--b,++n;//res初始为b=1的情况，所以实际的b要-1
    init();quickPow(b);//n++是方便计算间隔
    printf("%lld",res.f[0][0]);
    return 0;
}
```



---

## 作者：wangjinbo (赞：2)

这道题是一道找规律好题，不过作为一道紫题还是比较水的   
### 10分
爆搜
### 20分
一眼就可以看出这个式子：$f[i]=\sum_{j=1}^{n-m-1}{f[j]}$ 

直接写上就可以得20分了，时间复杂度$O(n^2)$

### 100分
看到输入只有两个数，我们就会自然而然的想到找规律。所以用刚才的20分程序打表：(纵坐标为 $n$,横坐标为$m$)

|  |1 |2 |3 |4 |5 |6 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|1 | 2 | 2 |2  | 2 | 2 | 2 |
|2 | 3 | 3 | 3 | 3 | 3 | 3 |
|3 | 5 | 4 | 4 | 4 | 4 | 4 |
|4 | 8 | 6 | 5 | 5 | 5 | 5 |
|5 | 13 | 9 | 7 | 6 | 6 | 6 |
|6 | 21 | 13 | 10 | 8 | 7 | 7 |

然后我们就会发现，当 $i$ $\le$ $m+1$ 时， $f[i]$ = $i+1$ , 否则$f[i]$ = $f[i-1] + f[i-m-1]$ 这个式子就是矩阵加速的模板了

说一下怎样构造这个矩阵的：

原矩阵：$\{f[i],f[i+1],…f[i+m]\}$

目标矩阵：$\{f[i+1],f[i+2],f[i+3],…f[i+m+1]=f[i]+f[i+m]\}$

可以看出目标矩阵就是原矩阵前移一个位置，最后一个位置的数为原矩阵第一个和最后一个的和，即$f[i+m+1]=f[i]+f[i+m],f[i]=f[i+1],f[i+1]=f[i+2],…f[i+m]=f[i+m+1]$
根据矩阵乘法，对应在矩阵中就是$mat[i+1][i]=1 , mat[1][m+1]=mat[m+1][m+1]=1$.

AC代码：
```
#include<bits/stdc++.h>
using namespace std;
struct Mat{
	long long mat[17][17];
};
Mat ans,base;
long long n,m;
const int mod=1e9+7;
Mat mul(Mat a,Mat b,int s)
{
	Mat res;
	for(int i=1;i<=s;i++)
	for(int j=1;j<=s;j++)
	res.mat[i][j]=0;
	for(int i=1;i<=s;i++)
	for(int j=1;j<=s;j++)
	for(int k=1;k<=s;k++)
	{
	    res.mat[i][j]+=a.mat[i][k]*b.mat[k][j];
	    res.mat[i][j]%=mod;
	}
	return res;
}
Mat qpow(Mat ans,Mat base,long long p)
{
	while(p)
	{
		if(p&1)ans=mul(ans,base,m+1);
		base=mul(base,base,m+1);
		p>>=1;
	}
	return ans;
}
int main()
{
	scanf("%lld %lld",&n,&m);
	if(n==1&&m==1){//注意特判不然会死循环
		printf("2");return 0;
	}
	for(int i=1;i<=m+1;i++)
	ans.mat[1][i]=i+1;
	for(int i=1;i<=m;i++)
	base.mat[i+1][i]=1;
	base.mat[1][m+1]=base.mat[m+1][m+1]=1;
	ans=qpow(ans,base,n-m-1);
	printf("%lld\n",ans.mat[1][m+1]);
	return 0;
}
```

---

## 作者：Deuteron (赞：1)

### 写在前面:这是本蒟蒻的第一篇题解，写的不好请谅解 QwQ

题目链接[->](https://www.luogu.com.cn/problem/P5004)

### 10 分做法：暴力搜索
时间复杂度：$O(TLE)$
### 30 分做法
我们设 $f_i$ 表示跳到 $i$ 点的方案数，易得转移方程为

$f_k=\sum_{i=0}^{k-m}a_i$

由此进行 dp，可得 30 分。注意最后要求的结果是 $\sum_{i=0}^{n} f_i$ 。

时间复杂度：$O(n^2)$

### 50 分做法

我们设 $s_k$ 表示 $\sum_{i=0}^{k}a_i$
 
则状态转移方程为

$f_k=s_{k-m}$

由 $s_i=s_{i-1}+f_i$ 可得 $s_i=s_{i-1}+s_{i-m-1}$

由此进行 dp，可得 50 分。只需求出 $s_n$ 即可。

时间复杂度：$O(n)$

### 100 分做法

使用矩阵优化 dp。

注意转移矩阵的大小是 $m+1$ 的。

转移矩阵：（不会打 Latex 就将就看看吧）

$
1 \space0\space 0 \cdots 0 \space 1
$

$
1 \space0\space 0 \cdots 0 \space 0
$

$
0 \space1\space 0 \cdots 0 \space 0
$

$
0 \space0\space 1 \cdots 0 \space 0
$

$\vdots$

$
0 \space0\space 0 \cdots 0 \space 1
$

贴一下代码：

```cpp
#include<iostream>
#include<cstring>
#define int long long
using namespace std;
const int siz=20;//m<=15
const int mod=1e9+7;
int n,m;
struct jz{
	long long x[siz][siz];
	void cl(){
		memset(x,0,sizeof(x));
	}
};
jz mult(jz a,jz b){
	jz c;
	c.cl();
	for(int i=1;i<=m;i++){
		for(int j=1;j<=m;j++){
			for(int k=1;k<=m;k++){
				c.x[i][j]+=a.x[i][k]*b.x[k][j];
				c.x[i][j]%=mod;
			}
		}
	}
	return c;
}
jz ksm(int k,jz j){
	if(k==1) return j;
	jz d=ksm(k/2,j);
	d=mult(d,d);
	if(k%2==1) d=mult(j,d);
	return d;
}
jz u;
signed main(){
	u.cl();
	cin>>n>>m;
	m++;
	u.x[1][1]=1;
	u.x[1][m]=1;
	for(int i=2;i<=m;i++){
		u.x[i][i-1]=1;
	}
	jz w=ksm(n+m-1,u);
	cout<<w.x[1][1]<<endl;
	return 0;
}

```



---

## 作者：Flandre_495 (赞：1)

乍一看题：数据结构优化DP。仔细一看：$n$好大啊~，$m$好小啊~

所以又是一道矩阵优化好题。

想不出矩阵怎么构造，不慌，咱们慢慢看。

一个正解总是从部分分入手。我也不讲特殊性质的部分分了，我就直接讲所有情况的暴力。

我就按每个位置填$1$或$0$来说了，你们肯定知道什么意思。

一个显然的DP方程：$f[i][j]$表示枚举到第$i$个位置，前面（包括$i$）**恰好**有连续$j$个零。（用**至少**有$j$个零当状态其实是一样的，你怎么理解就怎么转，反正我就用**恰好**讲了）。

考虑每一个位置放$0$还是$1$，如果当前位置放$1$，那$j$就是$0$；否则就是多加一个$0$，$f[i][j] = f[i-1][j-1]$；因为第一个位置就可以放$1$，所以我默认$0$的位置前面已经有$m$个$0$。放$1$时，它前面至少有$m$个零，所以$f[i][0]=\sum\limits_{j=m}^\infty f[i-1][j]$。

这个无限大呢，既然我们是考虑前面可能有多少个零，那么这个无限大最大是$n+m$，所以枚举到$maxn = n+m$即可。我只显示主函数：

```cpp
cin>>n>>m; maxn = n+m; f[0][m] = 1;  //默认为前面有m个零，一种情况。
for(int i=1;i<=n;i++) {
	for(int j=m;j<=maxn;j++) f[i][0] += f[i-1][j];
	for(int j=1;j<=maxn;j++) f[i][j] = f[i-1][j-1];
	cout<<endl;
}
for(int i=0;i<=maxn;i++) ans += f[n][i]; cout<<ans;
```

~~恭喜你获得了10分的好成绩！~~

数组明显开不下，滚掉第一维。可以开$f[2][N]$，也可以直接不要第一维，但转的时候要注意一些细节，前者太简单，后者多注意些细节，不要转移重复了，记得倒着枚举.

我把$f[N]$的写出来：
```cpp
cin>>n>>m; maxn = n+m; f[m] = 1;
for(int i=1;i<=n;i++) {
	int t = f[0]; f[0] = 0;
	for(int j=m;j<=maxn;j++) f[0] += f[j];
	for(int j=maxn;j>=2;j--) f[j] = f[j-1];
	f[1] = t;
}
for(int i=0;i<=maxn;i++) ans += f[i]; cout<<ans;
```
结果发现：肯定还是10分。。。

那么考虑这个$m$这么小有什么用：若某位置前面零的数量超过了$m$，这个位置肯定可以放$1$，所以我们只需关心前面大于等于$m$的情况数有多少，转移时，我们也只需让高于$m$的状态，全部挤在$f[m]$中。即：
$$\begin{cases}f[0] = f[m]\\f[i] = f[i-1] (0<i<m)\\f[m] = f[m-1] + f[m]\end{cases}$$

```cpp
cin>>n>>m; f[m] = 1;
for(int i=1;i<=n;i++) {
	int t = f[0]; f[0] = f[m];
	for(int j=m+1;j>=2;j--) f[j] = f[j-1];
	f[1] = t; (f[m] += f[m+1]) %= mp;
}
for(int i=0;i<=m;i++) (ans += f[i]) %= mp; cout<<ans;
```
即可得到50分的~~好成绩~~。

既然我们有了50分做法，那根据上面的大括号式子，很简单可以构造出转移矩阵，如果不会构造的话，建议去做一做板子。~~既然来写这题了，肯定会矩阵加速的了~~~

具体矩阵我不画了，~~太累（lan）~~。直接放AC代码了：

```cpp
#include<iostream>
#define ll long long
using namespace std;
const ll mp=1000000007;
ll n,m,res;
struct E{ ll f[16][16]; } chu,ans,aa;

E cheng(E a,E b) {
	E c = chu;
	for(ll i=0;i<=m;i++)
	for(ll j=0;j<=m;j++)
	for(ll k=0;k<=m;k++)
	(c.f[i][j] += (a.f[i][k] * b.f[k][j]) % mp) %= mp;
	return c;
}

int main() {
	cin>>n>>m;
	aa.f[0][m] = 1; aa.f[m][m] = 1;
	for(ll i=1;i<=m;i++) aa.f[i][i-1] = 1;
	ans.f[m][0] = 1;
	while(n) {
		if(n&1) ans = cheng(aa,ans);
		n >>= 1; aa = cheng(aa,aa);
	}
	for(ll i=0;i<=m;i++) (res += ans.f[i][0]) %= mp; cout<<res;
	return 0;
}
```
简短而易懂。算是本人写的比较认真的一篇题解了，~~还是太菜了~~。

---

## 作者：UperFicial (赞：1)

~~本题的找规律题解到此为止。~~

~~为防止新人受到误导，不再接受新的此类题解。~~

~~以前的保留不会删除，但请不要再提交。~~

---

[题目传送门](https://www.luogu.com.cn/problem/P5004)。

同步发表于我的 [$\text{cnblogs}$](https://www.cnblogs.com/UperFicial/p/16696073.html)。

矩阵加速模板题吧。给一个正经的不用找规律的做法。

考虑设 $F_n$ 表示前 $n$ 个格子的答案，$f_n$ 表示最后降落在 $n$ 的方案数，显然有 $F_n=F_{n-1}+f_n$，由于 $f_n$ 也是由一个 $f$ 的前缀和得来，所以得到 $F_{n}=F_{n-1}+F_{n-m-1}$。

这个长得就很矩阵加速了。观察数据范围发现 $m$ 很小，而这又是一个前缀和的形式，启示我们把 $\{F_n,F_{n-1},\cdots,F_{n-m}\}$ 都放入一个矩阵里进行转移。

考虑用原矩阵 $\begin{bmatrix}
 F_{n-1}\\
 F_{n-2}\\
 \cdots\\
 F_{n-m-1}
\end{bmatrix}$ 推出目标矩阵  $\begin{bmatrix}
 F_{n}\\
 F_{n-1}\\
 \cdots\\
 F_{n-m}
\end{bmatrix}$

对于 $i$ 满足 $n-m\le i\le n-1$，$F_i$ 都是原矩阵已知的元素，不用管它。

对于 $F_n$，把它直接替换成 $F_{n-1}+F_{n-m-1}$，这两项恰好也是我们原矩阵已知的元素。

下面构造转移矩阵。

第一行是特殊的，因为它的转移是对于 $F_n$ 的。我们将第一个设成 $1$，最后一个设成 $1$，其余设成 $0$，表示对应 $F_{n-1}$ 和 $F_{n-m-1}$。

然后剩下的那些行，只需要将 $F_i$ 对应的位置设成 $1$ 就可以，直接继承过来。

这样就得到了这样一个矩阵（这是当 $m=5$ 时矩阵的样子，来类比一下，应该很容易能看出来）：

$$\begin{bmatrix}
 1 & 0 & 0 & 0 & 0 & 1\\
 1 & 0 & 0 & 0 & 0 & 0\\
 0 & 1 & 0 & 0 & 0 & 0\\
 0 & 0 & 1 & 0 & 0 & 0\\
 0 & 0 & 0 & 1 & 0 & 0\\
 0 & 0 & 0 & 0 & 1 & 0
\end{bmatrix}$$

这样的话，可以构造一个 $\left(m+1\right)\times \left(m+1\right)$ 的转移矩阵然后快速幂即可。

矩阵乘法 $\Theta(m^3)$，快速幂 $\Theta(\log n)$，最终复杂度 $\Theta(m^3\log n)$。

代码：

```cpp
const int MOD(1e9+7);

inline int add(int x,int y){return x+y>=MOD?x+y-MOD:x+y;}
inline int mul(int x,int y){return 1ll*x*y%MOD;}

ll n;
int m;

struct Matrix
{
	int G[30][30];
	Matrix(){rep(i,1,m) rep(j,1,m) G[i][j]=0;return;}
	Matrix operator*(const Matrix&x)
	{
		Matrix res;
		rep(i,1,m) rep(j,1,m) rep(k,1,m) res.G[i][j]=add(res.G[i][j],mul(G[i][k],x.G[k][j]));
		return res;
	}
};

inline Matrix ksm(ll y)
{
	Matrix ans,x;
	rep(i,1,m) ans.G[i][i]=1;
	rep(i,2,m) x.G[i][i-1]=1;
	x.G[1][1]=1,x.G[1][m]=1;
	while(y)
	{
		if(y&1) ans=ans*x;
		x=x*x;
		y>>=1;
	}
	return ans;
}

int main()
{
	scanf("%lld%d",&n,&m);
	++m;
	Matrix now=ksm(n+m-1);
	printf("%d\n",now.G[1][1]);
	return 0;
}
```

---

## 作者：wisdom_grass (赞：0)

[传送门](https://www.luogu.com.cn/problem/P5004)
#### Solution:
考虑线性dp。$f[i]$表示前$i$个格子（仅限于跳到前$i$个格子）有多少种跳法。则$f[i] = f[1] + f[2] + ... + f[i - M - 1]$。（不会打xigema，凑合着看吧）

然而$N$很大，无法用$\operatorname{O}(N)$的时间来做。发现$M$很小，立刻想到矩阵乘法优化线性dp。

维护一个$M+1$行$1$列的矩阵$A$，$A_{11}=f[i],A_{21}=f[i-1],...A_{(M+1)1}=f[i-M]$。

初始矩阵为$M+1$行$1$列的矩阵$A$，为$f$数组的前$M+1$个数值。事实上$f$数组的前$M+1$个数值全部都是$1$。所以初始化的矩阵的元素都是$1$（即从最左边直接跳到该位置）。

如何转移下图的矩阵？注意到左右侧相同元素均可匹配，那么现在就求$f[i]$。
$f[i] = f[i-1]+f[i-M-1]$。由第一行的公式可知$f[i-1]$代表的就是$f[1]+f[2]+ ... +f[i-M-2]$。

答案：将最后的f数组的元素都加起来。因为现在在这些格子上都可以一步跳到无限大。

时间复杂度$\operatorname{O}(M^3logN)$。

![The Matrixes](https://cdn.luogu.com.cn/upload/image_hosting/auxbtf7s.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

#### Code:
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

typedef long long LL;
const int MAXM = 17 + 10;
const int SIZ = 17;
const LL MOD = 1000000007;
LL N, M;
struct Matrix {
	LL l[MAXM][MAXM];
	Matrix () {memset(l, 0, sizeof(l));}
	Matrix operator = (Matrix h) {
		for(int i = 1; i <= SIZ; i++)
			for(int j = 1; j <= SIZ; j++)
				l[i][j] = h.l[i][j] % MOD;
		return *this;
	}
	Matrix operator * (Matrix h) {
		Matrix c;
		for(int k = 1; k <= SIZ; k++)
			for(int i = 1; i <= SIZ; i++)
				for(int j = 1; j <= SIZ; j++)
					c.l[i][j] += (l[i][k] * h.l[k][j]) % MOD;
		return c;
	}
}T, bas, st;

void init() {
	bas.l[1][1] = bas.l[1][M + 1] = 1;
// bas为转移的矩阵，st为初始矩阵，T为单位矩阵。
	for(int i = 2; i <= M + 1; i++)
		bas.l[i][i - 1] = 1;
	for(int i = 1; i <= M + 1; i++)
		st.l[i][1] = 1;
	for(int i = 1; i <= M + 1; i++)
		T.l[i][i] = 1;
}
Matrix Qpow(Matrix a, LL b) { // 矩阵快速幂优化
	Matrix res = T;
	while(b > 0) {
		if(b & 1) res = res * a;
		a = a * a;
		b >>= 1;
	}
	return res;
}
void Wor() {
	Matrix h = Qpow(bas, N - M);
	st = h * st; // 注意矩阵乘法满足结合律但不满足交换律！st=st*h和st=h*st是不一样的！
	LL ans = 0;
	for(int i = 1; i <= SIZ; i++)
//		for(int j = 1; j <= SIZ; j++)
			ans = (ans + st.l[i][1]) % MOD;
	printf("%lld", ans);
}
int main() {
	#ifdef test
		freopen("test.txt", "r", stdin);
	#endif
	cin >> N >> M;
	init();
	Wor();
	return 0;
}
```

---

## 作者：LevenKoko (赞：0)

# [更好的阅读体验](https://www.cnblogs.com/zhenglw/p/10437703.html)

首先这是一道**计数类DP**，那我们得先推式子，~~经过瞎掰乱凑~~，认真分析，我们可以得到这样的方程

### F(N)=F(0)+F(1)+....+F(N-M-1)

### 所有F初值为1，F(1)=2

### ANS=F(N+M);

那显然我们有这样的代码：
```
 1 #include<iostream>
 2 #include<cstdio>
 3 #include<cstring>
 4 #include<algorithm>
 5 const int M=1e9+7;
 6 using namespace std;
 7 inline int read(){
 8     char chr=getchar();    int f=1,ans=0;
 9     while(!isdigit(chr)) {if(chr=='-') f=-1;chr=getchar();}
10     while(isdigit(chr))  {ans=(ans<<3)+(ans<<1);ans+=chr-'0';chr=getchar();}
11     return ans*f;
12 }
13 void write(int x){
14     if(x<0) putchar('-'),x=-x;
15     if(x>9) write(x/10);
16     putchar(x%10+'0');
17 }int n,m,f[10000005];
18 int main(){
19     n=read(),m=read();
20     f[0]=1;f[1]=2;
21     for(int i=1;i<=n+m;i++){
22         f[i]=1;
23         for(int j=0;j<=i-m-1;j++)
24             if(f[i]+f[j]>M) f[i]=f[i]+f[j]-M;
25             else f[i]=f[i]+f[j];//卡一波时间
26     }cout<<f[n+m];
27     return 0;
28 }
```
显然这是O（n^2）的算法，然而面对N=1e18，这个算法可以~~去见鬼了~~要一些优化，不过这样子由于语句都是加加减减比较简单，勉强可以过十万的数据，大概30分

### 考虑优化：

我们先看一下上面的式子，尝试对这个式子变形...好吧，其实就是迭代，然后用鸽笼原理一通乱搞：

### F(N)=F(N-1)+F(N-M-1)

### ANS=F(N)

好了我们把这个东西优化得到了O(N)的算法：

### 期望得分：50pts
```
 1 #include<iostream>
 2 #include<cstdio>
 3 #include<cstring>
 4 #include<algorithm>
 5 const int M=1e9+7;
 6 using namespace std;
 7 inline int read(){
 8     char chr=getchar();    int f=1,ans=0;
 9     while(!isdigit(chr)) {if(chr=='-') f=-1;chr=getchar();}
10     while(isdigit(chr))  {ans=(ans<<3)+(ans<<1);ans+=chr-'0';chr=getchar();}
11     return ans*f;
12 }
13 void write(int x){
14     if(x<0) putchar('-'),x=-x;
15     if(x>9) write(x/10);
16     putchar(x%10+'0');
17 }int n,m,f[10000005];
18 int main(){
19     n=read(),m=read();
20     f[0]=1;f[1]=2;
21     for(int i=2;i<=n;i++)
22         f[i]=(f[i-1]+f[max(i-m-1,0)])%M;
23     cout<<f[n];
24     return 0;
25 }
```                  
# 考虑继续优化

某个大佬说过1e18的数据考虑logn的算法，比如快速幂。

这既然是DP，那自然往矩阵乘法考虑。

　　**考虑构造矩阵**：m这么小，而且递推式中出现的常量只有m，显然矩阵的大小要往m*m考虑

　　m=1的时候斐波那契，显然不用我推了

　　看一下其他情况：

   ![](https://i.loli.net/2019/02/26/5c74f61d85371.png) 
　　![](https://i.loli.net/2019/02/26/5c74f61d7086e.png)              

 得到通式（写了的是1，其他是0）：

![](https://i.loli.net/2019/02/26/5c74f61d87150.png)

然后会矩阵加速的同学都知道该怎么做了吧...

 
```
 1 // luogu-judger-enable-o2
 2 #include<iostream>
 3 #include<cstdio>
 4 #include<cstring>
 5 #include<algorithm>
 6 #define int long long
 7 const int M=1e9+7;
 8 using namespace std;
 9 inline int read(){
10     char chr=getchar();    int f=1,ans=0;
11     while(!isdigit(chr)) {if(chr=='-') f=-1;chr=getchar();}
12     while(isdigit(chr))  {ans=(ans<<3)+(ans<<1);ans+=chr-'0';chr=getchar();}
13     return ans*f;
14 }
15 void write(int x){
16     if(x<0) putchar('-'),x=-x;
17     if(x>9) write(x/10);
18     putchar(x%10+'0');
19 }int n,m;
20 struct P{int a[20][20];P(){memset(a,0,sizeof(a));}}A,B;
21 P operator *(const P &x,const P &y){
22     P ans;
23     for(int i=0;i<m;i++)
24         for(int k=0;k<m;k++)
25             for(int j=0;j<m;j++)
26                 ans.a[i][j]=(ans.a[i][j]+x.a[i][k]*y.a[k][j])%M;
27     return ans;    
28 }
29 void KSM(int n){
30     while(n){
31         if(n&1) B=B*A;
32         n>>=1;A=A*A;
33     }
34 }
35 inline void init(){
36     n=read(),m=read();--n,++m;
37     A.a[m-1][m-1]=A.a[0][m-1]=1;
38     for(int i=0;i<m-1;i++)    A.a[i+1][i]=1;//初始矩阵 
39     for(int i=0;i<m;i++)B.a[0][i]=i+2;
40 }
41 signed main(){
42     init();KSM(n);
43     write(B.a[0][0]);
44     return 0;
45 }
```

---

## 作者：Equfix (赞：0)

~~这个题跟P3957完全不一样好吧！~~

## 算法一：DP(1)

用 $dp_{i}$ 表示跳到第 $i$ 格的方案数。则有转移：

$dp_{i}=1+\sum_{j<i-m}dp_{j}$

意为从开始直接跳到第 $i$ 格，或从前面的、满足条件的第 $j$ 格跳来。

目标:$\sum dp_i$

时间复杂度 $O\left(n^{2}m\right)$,TLE on #3。

## 算法二：DP(2)

考虑到 $dp_{i-1}=1+\sum_{j<i-m-1}dp_{j}$,可以对我们的转移进行优化：

$dp_{i}=dp_{i-1}+dp_{i-m-1}$

时间复杂度 $O\left(nm\right)$,TLE on #11。

## 正解：矩阵加速

考虑矩阵：

$\begin{bmatrix}
sum_i &dp_{i-m} &dp_{i-m+1} &\dots &dp_i
\end{bmatrix} \times A =\begin{bmatrix}
sum_{i+1} &dp_{i-m+1} &dp_{i-m+2} &\dots &dp_{i+1}
\end{bmatrix} $

则我们构造出矩阵 $A$ 即可。


------------

举例说明：

$m=4$ 时，$A$ 应长这样：

$\begin{bmatrix}
1&0&0&0&0&0 \\
1&0&0&0&0&1 \\
0&1&0&0&0&0 \\
0&0&1&0&0&0 \\
0&0&0&1&0&0 \\
0&0&0&0&1&1
\end{bmatrix} $


------------


$m=5$ 时，$A$ 应长这样：

$\begin{bmatrix}
1&0&0&0&0&0&0 \\
1&0&0&0&0&0&1 \\
0&1&0&0&0&0&0 \\
0&0&1&0&0&0&0 \\
0&0&0&1&0&0&0 \\
0&0&0&0&1&0&0 \\
0&0&0&0&0&1&1
\end{bmatrix} $

相必大家都会构造矩阵了吧！


------------

注意细节：

一、初始矩阵为 $\begin{bmatrix}
m+1 &1 &1 &\dots &1
\end{bmatrix}$。

二、需要特判 $n\le m$ 的情况。


------------

代码安排上：（213ms AC）

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
//typedef long long ll;
int read(){
	int n=0,s=1;
	char x;
	while((x=getchar())<'0'||x>'9')
		if(x=='-')
			s=-1;
	while(x>='0'&&x<='9'){
		n=(n<<1)+(n<<3)+(x^48);
		x=getchar();
	}
	return n*s;
}
void write(int n,char x=0){
	if(n<0)
		putchar('-'),n=-n;
	if(n>9)write(n/10);
	putchar('0'+n-n/10*10);
	if(x)putchar(x);
}
const int mod=1e9+7;
class mat{
	private:
		int n,m;
	
	public:
		int a[101][101];
		mat(int x,int y,bool flag=0){
			memset(a,0,sizeof(a));
			n=x;
			m=y;
			if(flag&&n==m)
				for(int i=1;i<=n;i++)
					a[i][i]=1;
		}
		mat operator+(mat &b){
			if(b.n==n&&b.m==m){
				mat ans(n,m);
				for(int i=1;i<=n;i++)
					for(int j=1;j<=n;j++)
						ans.a[i][j]=b.a[i][j]+a[i][j],ans.a[i][j]%=mod;
				return ans;
			}
		}
		mat operator*(mat &b){
			if(b.n==m){
				mat ans(n,b.m);
				for(int i=1;i<=n;i++)
					for(int j=1;j<=b.m;j++)
						for(int k=1;k<=m;k++)
							ans.a[i][j]+=((long long)a[i][k]*b.a[k][j])%mod,ans.a[i][j]%=mod;
				return ans;
			}
		}
		mat pw(long long t){
			if(n==m){
				mat re(n,n,1);
				if(t==0)
					return re;
				if(t%2)re=re*(*this);
				mat ans(n,n);
				ans=pw(t/2);
				re=re*ans*ans;
				return re;
			}
		}
		void display(){
			for(int i=1;i<=n;i++){
				for(int j=1;j<=m;j++)
					printf("%d ",a[i][j]);
				printf("\n");
			}
		}
};
signed main(){
	int n=read(),m=read();
	if(n<=m){
		printf("%lld",n+1);
		return 0;
	}
	mat A(1,m+2);
	A.a[1][1]=m+1;
	for(int i=2;i<=m+2;i++)
		A.a[1][i]=1;
	mat B(m+2,m+2);
	B.a[1][1]=B.a[2][1]=B.a[m+2][1]=1;
	B.a[3][2]=1;
	for(int i=3;i<m+2;i++)
		B.a[i+1][i]=1;
	B.a[2][m+2]=B.a[m+2][m+2]=1;
	B=B.pw(n-m-1);
	cout<<((A*B).a[1][1]+1)%mod;
	return 0;
}
```


---


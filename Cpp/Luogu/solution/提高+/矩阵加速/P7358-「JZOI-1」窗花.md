# 「JZOI-1」窗花

## 题目背景

小蔡和小僖在比赛剪窗花。

## 题目描述

小蔡和小僖的制作水平都很高，换句话讲，他们都能制作出好看度为 $1\dots n$ 的窗花，但是两个人的熟练度不一样，小蔡的熟练度可以用一个数组 $a_{1\dots n}$ 组成，换句话讲，他剪出一个好看度为 $k(1\le k\le n)$ 的窗花的概率为 $\frac{a_k}{\sum_{i=1}^na_i}$。同理，小僖的熟练度可以用数组 $b_{1\dots n}$ 组成，他剪出一个好看度为 $k(1\le k\le n)$ 的窗花的概率为 $\frac{b_k}{\sum_{i=1}^nb_i}$。

现在两个人正在比赛剪窗花，如果某个人剪出的窗花的好看度比另一个人的大，那么这个人取胜，如果比另一个人的小，那么这个人失败，如果一样，则为平局。

现在，小蔡用一个计数器记录他的情况，如果他赢了，那么计数器 $+1$，如果他输了，那么计数器 $-1$，如果平了，那么不加不减。但由于计数器不支持负数，所以如果结果 $\le0$ 那么会自动变成 $0$，如果计数器显示的数 $=m$，那么比赛结束。

作为新时代的大神，小蔡花了 $10^{-6}$ 秒就算出来了比赛结束所经过的期望局数，但他想让你帮忙检验一下……

## 说明/提示

对于 $ 30\% $ 的数据点，$ 1 \leq m \leq 100 $。

对于 $ 60\% $ 的数据点，$ 1 \leq m \leq 10^{6} $。

对于 $ 90\% $ 的数据点，$ 1 \leq m \leq 10^{18} $。

对于 $ 100\% $ 的数据点，$ 2 \leq n \leq 10^6 $，$ 1 \leq m \leq 10^{1000} $，$ 1 \leq a_i \leq 10^9 $。

## 样例 #1

### 输入

```
4 2
3 1 1 4 
3 5 2 1 ```

### 输出

```
570934265```

## 样例 #2

### 输入

```
3 1
1 1 1
1 1 1```

### 输出

```
3```

# 题解

## 作者：do_while_true (赞：5)

[$\text{获得另一种阅读体验}$](https://www.cnblogs.com/do-while-true/p/14405475.html)

设赢，平局，输的概率分别为 $P_1,P_2,P_3$。

设 $E(i)$ 为从计数器为 $i$ 开始走，走到 $m$ 的步数。根据定义有 $E(m)=0$。

据题意，得出

$$
E(i)=
\begin{cases}
P_1E(i+1)+P_2E(i)+P_3E(i-1)+1,(i\geq 1)
\\
P_1E(1)+(1-P_1)E(0)+1,(i==0)
\end{cases}
$$

设 $E(0)=x$

设 $E(i)=a_ix+b_i,(i>1)$

$$
\because E(0)=P_1E(1)+(1-P_1)E(0)+1
\\
\therefore E(1)=E(0)-\frac{1}{P_1}
\\
\therefore a_1=1,b_1=-\frac{1}{P_1}
$$

同理可得：

$$
a_i=\frac{1-P_2}{P_1}a_{i-1}-\frac{P_3}{P_1}a_{i-2},(i>1)
\\
b_i=\frac{1-P_2}{P_1}b_{i-1}-\frac{P_3}{P_1}b_{i-2}-\frac{1}{P_1},(i>1)
$$

推出 $a_m,b_m$ 后可得一个一元一次方程

$$
E(m)=a_m x+b_m=0
\\
E(0)=x=-\frac{b_m}{a_m}
$$

由定义可知 $E(0)$ 即为所求答案。

如何快速求得 $a_m,b_m$？可以矩阵快速幂。

这里就是朴素的矩阵快速幂了，这里给出我推得的初始矩阵和转移矩阵：

设 $t_1=\frac{1-P_2}{P_1}a_{i-1},t_2=-\frac{P_3}{P_1}b_{i-2},t_3=-\frac{1}{P_1}$

$a:$

$$
\\
\text{初始矩阵：}\begin{bmatrix}1&1\end{bmatrix}
\\
\text{转移矩阵：}\begin{bmatrix}0&t_1\\1&t_2\end{bmatrix}
$$

$b:$

$$
\\
\text{初始矩阵：}\begin{bmatrix}0&t_3&1\end{bmatrix}
\\
\text{转移矩阵：}
\begin{bmatrix}
0&t_2&0
\\
1&t_1&0
\\
0&t_3&1
\end{bmatrix}
$$
$m$ 可以高精除，模拟短除法得到 $m$ 的二进制，遍历一遍 $m$ 的二进制上各个位即可完成快速幂。

时间复杂度加上矩阵的常数为 $\mathcal{O}(\lg m\times\log_2 m+2^3\times\log_2 m+3^3\times\log_2 m)$，前面是求 $m$ 的二进制，后面两个分别为 $a,b$ 的矩阵快速幂求解。

即使本文略去简单的计算及推导，也难免会出现错误，欢迎指正。

$\mathcal{Code}$

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
namespace do_while_true {	
	#define ld double
	#define ll long long
	#define re register
	#define pb push_back
	#define fir first
	#define sec second
	#define pp std::pair
	#define mp std::make_pair
	const ll mod = 1000000007;
	template <typename T> inline T Max(T x, T y) { return x > y ? x : y; }
	template <typename T> inline T Min(T x, T y) { return x < y ? x : y; }
	template <typename T> inline T Abs(T x) { return x < 0 ? -x : x; }
	#define p mod 
	template <typename T> inline T Add(T x, T y) { return (x + y) % p; }
	template <typename T> inline T Mul(T x, T y) { return (x * y) % p; } 
	template <typename T> inline T Mod(T x) { return x % mod; }
	#undef p
	template <typename T>
	inline T& read(T& r) {
		r = 0; bool w = 0; char ch = getchar();
		while(ch < '0' || ch > '9') w = ch == '-' ? 1 : 0, ch = getchar();
		while(ch >= '0' && ch <= '9') r = r * 10 + (ch ^ 48), ch = getchar();
		return r = w ? -r : r;
	}
	template <typename T>
	inline T qpow(T x, T y) {
		re T sumq = 1; x %= mod;
		while(y) {
			if(y&1) sumq = sumq * x % mod;
			x = x * x % mod;
			y >>= 1;
		}
		return sumq;
	}
	template <typename T> inline T Inv(T x) { return qpow(x, mod-2); }
	char outch[110];
	int outct;
	template <typename T>
	inline void print(T x) {
		do {
			outch[++outct] = x % 10 + '0';
			x /= 10;
		} while(x);
		while(outct >= 1) putchar(outch[outct--]);
	}
}
using namespace do_while_true;

const int N = 1000100;
int n;
ll P1, P2, P3;
ll a[N], b[N], suma[N], sumb[N], isuma, isumb;
ll c[N], d[N];
char ch[N];
int _m[N], m[N], len, ct;

struct Matrix {
	int n, m;
	ll a[5][5];
	void mem() {
		n = m = 0;
		for(int i = 0; i <= 4; ++i)
			for(int j = 0; j <= 4; ++j)
				a[i][j] = 0;
	}
	Matrix operator * (const Matrix& y) {
		Matrix c; c.mem();
		c.n = n; c.m = y.m;
		for(int i = 1; i <= c.n; ++i)
			for(int j = 1; j <= c.m; ++j)
				for(int k = 1; k <= m; ++k)
					(c.a[i][j] += a[i][k] * y.a[k][j]) %= mod;
		return c;
	}
};

void solve() {
	scanf("%d %s", &n, ch+1); len = std::strlen(ch+1);
	for(int i = 1; i <= len; ++i) _m[i] = ch[len-i+1]-'0';
	while(len>=0 && ++ct) { 
		if(_m[1] & 1) m[ct] = 1;
		for(int i = len, x = 0; i >= 1; --i) _m[i] += x*10, x = _m[i]%2, _m[i] /= 2;
		while(_m[len] == 0 && len >= 0) --len;
	}
	for(int i = 1; i <= n; ++i) read(a[i]), suma[i] = Add(suma[i-1], a[i]);
	for(int i = 1; i <= n; ++i) read(b[i]), sumb[i] = Add(sumb[i-1], b[i]);
	isuma = qpow(suma[n], mod-2); isumb = qpow(sumb[n], mod-2);
	for(int i = 1; i <= n; ++i) {
		P1 = Add(P1, Mul(a[i] * isuma % mod, sumb[i-1] * isumb % mod));
		P2 = Add(P2, Mul(a[i] * isuma % mod, b[i] * isumb % mod));
		P3 = Add(P3, Mul(a[i] * isuma % mod, Mod(sumb[n] - sumb[i] + mod) * isumb % mod));
	}
	c[0] = 1; d[0] = 0; c[1] = 1; d[1] = Mod(-Inv(P1)+mod);
	ll t1 = Mod(1 - P2 + mod) * Inv(P1) % mod;
	ll t2 = Mod(-P3 + mod) * Inv(P1) % mod;
	ll t3 = d[1];
	Matrix basea, ansa, baseb, ansb;
	basea.mem(); ansa.mem(); baseb.mem(); ansb.mem();
	ansa.n = 1; ansa.m = 2;
	ansa.a[1][1] = 1; ansa.a[1][2] = 1;
	basea.n = 2; basea.m = 2;
	basea.a[1][1] = 0; basea.a[1][2] = t1;
	basea.a[2][1] = 1; basea.a[2][2] = t2;
	for(int i = 1; i <= ct; ++i, basea = basea * basea) if(m[i]) ansa = ansa * basea; 
	ansb.n = 1; ansb.m = 3;
	ansb.a[1][1] = 0; ansb.a[1][2] = t3; ansb.a[1][3] = 1;
	baseb.n = 3; baseb.m = 3;
	baseb.a[1][1] = 0; baseb.a[1][2] = t2; baseb.a[1][3] = 0;
	baseb.a[2][1] = 1; baseb.a[2][2] = t1; baseb.a[2][3] = 0;
	baseb.a[3][1] = 0; baseb.a[3][2] = t3; baseb.a[3][3] = 1;
	for(int i = 1; i <= ct; ++i, baseb = baseb * baseb) if(m[i]) ansb = ansb * baseb; 
	printf("%lld\n", Mod(-ansb.a[1][1]+mod) * Inv(ansa.a[1][1]) % mod);
}

signed main() {
	#ifndef ONLINE_JUDGE
	freopen("in.txt", "r", stdin);
	#endif
	int T = 1;
//	read(T);
	while(T--) solve();
	fclose(stdin);
	return 0;
}
```

---

## 作者：renshale (赞：2)

本题受GDKOI DAY2 T1启发，但是有所削弱（参见下面的练习）。本来当时考场上已经想出来思路，但是就差那最后一点点，后来发现自己的思路和树上高斯消元有些相似，执念比较深，就出了这样一个题。

首先可以预处理一下赢、输、平的概率，设为$ a,b,c $，时间复杂度$ O(n) $。

以下方法都视求逆元的$ O(log_2 \ p) $为**常数**。

对于30pts的数据点，dp模拟，或者高斯消元都能做吧，~~都是口胡~~。

对于60pts的数据点，有两种方法：

1.设$ f_i $为计数器从$ i $到$ i + 1 $的期望局数，则有$ f_i = a + b * (1 + f_{i - 1} + f_i) + c * (1 + f_i) $，化简得到$ f_i = \frac{b}{a} * f_{i - 1} + \frac{1}{a} $，$ ans = \Sigma_{i = 0}^{m - 1} f_i $，时间复杂度$ O(m) $。

2.设$ f_i $为计数器已经到$ i $，到达$ m $的期望局数，则有$ f_i = a * (1 + f_{i + 1}) + b * (1 + f_{i - 1}) + c * (1 + f_i) $，记$ f_i = A_i * f_{i - 1} + B_i $，则有$ f_i = a * (1 + {i + 1} * f_i + B_{i + 1})) + b * (1 + f_{i - 1}) + c * (1 + f_i) $，化简得到$ f_i = \frac{b}{1 - c - a * A_{i + 1}} * f_{i - 1} + \frac{a * B_{i + 1} + 1}{1 - c - a * A_{i + 1}} $，此时可以得到$ A_i = \frac{b}{1 - c - a * A_{i + 1}} $, $ B_i = \frac{a * B_{i + 1} + 1}{1 - c - a * A_{i + 1}} $, $ A_n = B_n = f_n = 0 $，通过观察发现，$ f_0 $以前的$ f $值与$ f_0 $相同，即$ f_0 $为不动点，从而得到$ A_0 * f_0 + B_0 = f_0 $，即有$ f_0 = \frac{-B_0}{A_0 - 1} $，时间复杂度$ O(m) $。这个方法与树上高斯消元有关，读者可以试着自行推导$ f_i = a * f_{i - 1} + b * f_{i + 1} + c * f_{2 * i} $的情况。其实本来是想加多一档部分分，推广一下这个东西的。

对于90pts的数据点，可以发现，60pts数据点的第一种方法的$ f $是一个一阶线性递推数列，手推一下通项公式即可，$ Ans = \Sigma_{i = 0}^{m - 1} (\frac{1}{a} + \frac{1}{b - a}) * (\frac{b}{a})^i - \frac{1}{b - a} = (\frac{1}{a} + \frac{1}{b - a}) * \frac{(\frac{b}{a})^m - 1}{\frac{b}{a} - 1} \ - \ m * \frac{1}{b - a}$，需要特殊考虑$ a = b $的情况，此时$ Ans = \Sigma_{i = 0}^{m - 1} (i + 1) * \frac{1}{a} = \frac{(m + 1) * m}{2 * a} $，时间复杂度$ O(log_2 \ m) $。

对于100pts的数据点，~~写高精度~~根据费马小定理，有$ a^{p-1} \equiv 1 \pmod{p} $，于是可以在读入的时候处理出$ m_1 = m \ \bmod \ (p - 1), m_2 = m \ \bmod \ p $，代入原公式即可，时间复杂度$ O(lg \ m) $，为读入速度。

当然，也可以写矩阵乘法（~~出题人在赛前貌似忘了这种做法，赛时才发现~~），毕竟是个齐次线性递推数列，但是常数会大一点。

其实还可以设置多组询问再加一个光速幂的（~~能卡矩阵？~~），不过出题人不想卡大家常数，就不弄啦！

样例解释比较难给（一直平，无穷级数），想从样例中看出思路的小伙伴，抱歉啦。

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <cstring>
#include <algorithm>
using namespace std;

#define Rs register
#define INF 0x7FFFFFFF
#define ll long long
#define ld long double

inline ll read()
{
	ll x = 0, f = 1;
	char c = getchar();
    while (c > '9' || c < '0') { if(c == '-') f = -1; c = getchar(); }
    while (c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }
    return x * f;
}

const int N = 1e6 + 10;
const ll Mod = 1e9 + 7;

inline ll qpow(ll x, ll y)
{
	ll res = 1;
	for (; y; y >>= 1)
	{
		if (y & 1)
			res = res * x % Mod;
		x = x * x % Mod;
	}
	return res;
}

ll n, m, invsa, invsb, A, B, C, ans;
ll a[N], b[N], suma[N], sumb[N], x[N], y[N], dp[N];

ll m1;

inline void read_m()
{
	char c = getchar();
    while (c > '9' || c < '0') 
		c = getchar(); 
    while (c >= '0' && c <= '9') 
	{ 
		m = (m * 10 % Mod + c - '0') % Mod; 
		m1 = (m1 * 10 % (Mod - 1) + c - '0') % (Mod - 1); 
		c = getchar(); 
	}
}

inline void Solve1()
{
	ll INVA = qpow(A, Mod - 2);
	dp[0] = INVA;
	for (int i = 1; i < m; i ++)
		dp[i] = (B * INVA % Mod * dp[i - 1] % Mod + INVA) % Mod;
	for (int i = 0; i < m; i ++)
		ans = (ans + dp[i]) % Mod;
}

inline void Solve2()
{
	x[m] = y[m] = 0;
	for (int i = m - 1; ~ i; i --)
	{
		ll INV = qpow((1 + (Mod - C) + (Mod - A * x[i + 1] % Mod)) % Mod, Mod - 2);
		x[i] = B * INV % Mod;
		y[i] = (A * y[i + 1] % Mod + 1) % Mod * INV % Mod;
	}
	ans = (Mod - y[0]) * qpow((x[0] - 1 + Mod) % Mod, Mod - 2) % Mod;
}

inline void Solve3()
{
	if (A != B)
	{
		ll INVA = qpow(A, Mod - 2);
		ll INVB_A = B * INVA % Mod;
		ll INV = qpow((B - A + Mod) % Mod, Mod - 2);
		ll S = (qpow(INVB_A, m1) - 1 + Mod) % Mod * qpow((INVB_A - 1 + Mod) % Mod, Mod - 2) % Mod;
		ans = ((INVA + INV) % Mod * S % Mod - INV * m % Mod + Mod) % Mod;
	}
	else
		ans = qpow(A, Mod - 2) * (m + 1) % Mod * m % Mod * qpow(2, Mod - 2) % Mod;
}

signed main()
{
	n = read(), read_m();
	for (int i = 1; i <= n; i ++)
	{
		a[i] = read();
		invsa = (invsa + a[i]) % Mod;
	}
	invsa = qpow(invsa, Mod - 2);
	for (int i = 1; i <= n; i ++)
	{
		a[i] = a[i] * invsa % Mod;
		suma[i] = (suma[i - 1] + a[i]) % Mod;
	}
	for (int i = 1; i <= n; i ++)
	{
		b[i] = read();
		invsb = (invsb + b[i]) % Mod;
	}
	invsb = qpow(invsb, Mod - 2);
	for (int i = 1; i <= n; i ++)
	{
		b[i] = b[i] * invsb % Mod;
		sumb[i] = (sumb[i - 1] + b[i]) % Mod;
	}
	for (int i = 1; i <= n; i ++)
	{
		A = (A + a[i] * sumb[i - 1] % Mod) % Mod;
		B = (B + b[i] * suma[i - 1] % Mod) % Mod;
		C = (C + a[i] * b[i] % Mod) % Mod;
	}
//	Solve1();
//	printf("%lld\n", ans);
//	Solve2();
//	printf("%lld\n", ans);
	Solve3();
	printf("%lld\n", ans);
	return 0;
}
```


---


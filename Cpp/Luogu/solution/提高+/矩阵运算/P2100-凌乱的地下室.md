# 凌乱的地下室

## 题目描述

小 Z 家的地下室里并排放 $n$ 个小方块（小 Z 是一位 MC 狂热爱好者，喜欢用小方块装饰他家的地下室），并且每个方块都不一样（小 Z 喜欢各不相同的东西），比如有草方块、大理石、黑曜石等。

小 Z 喜欢以一种特殊的顺序摆放这些小方块，比如：草方块、大理石、黑曜石。一天，小 D 帮助小 Z 整理地下室，可是智商捉急的小 D 将所有小方块搬出来后忘记了它们原来的具体位置。凭着模糊的印象，小 D 可能把原来放在第 $i$ 个位置上的小方块放到第 $i-1,i,i+1$ 个位置中的任意一个上（当然，第 $1$ 个不可能放到第 $0$ 个位置上，第 $n$ 个不可能放到第 $n+1$ 个位置上），比如（对应上面那个例子）：大理石、草方块、黑曜石。

小 Z 是一个心胸宽广的人，他希望计算一下小 D 一共会有几种可能的摆放结果，并不追究小 D 的责任（追究了只会更乱……）。由于他自己的智商也比较捉急，所以如果答案很大的话他只想看到最后的 $8$ 位（前导零就不要给他看了）。



---


求满足 $|p_i-i| \le 1$ 的 $1 \sim n$ 的排列 $\{p_n\}$ 的个数，答案对 $10^8$ 取模。

## 说明/提示

【样例解释 $1$】

接着题目中的例子，一共有 $3$ 种：（草方块，大理石，黑曜石）、（大理石，草方块，黑曜石）、（草方块，黑曜石，大理石）。


【数据规模】

对于 $30\%$ 的数据，$n \le 10^6$。

对于 $50\%$ 的数据，$n \le 10^{16}$。

对于 $100\%$ 的数据，$1 \le n \le 10^{1000}$。

## 样例 #1

### 输入

```
3```

### 输出

```
3```

## 样例 #2

### 输入

```
987```

### 输出

```
223731```

# 题解

## 作者：Archmushroom (赞：10)

## 题意

$n$ 个物体放进 $n$ 个格子。$i$ 号物体只能放在 $i - 1$ 号， $i$ 号或 $i + 1$ 号格，有多少种放法？

## 题目分析

老规矩 DP，$f_n$ 表示 $n$ 个物体放 $n$ 个格子的方案数。我们先看看 0 号物体放哪儿：
- 0 号物体放 0 号格：剩下 $n - 1$ 个物体放 $n - 1$ 个格子，方案数 $f_{n-1}$。
- 0 号物体放 1 号格：此时 1 号物体必须放 0 号格（否则 0 号格就没东西可放了）。剩下 $n - 2$ 个物体放 $n - 2$ 个格子，方案数 $f_{n-2}$。

综上转移函数是 $f_n = f_{n - 1} + f_{n - 2}$。没错，此题本质就是 Fibonacci，快速求 Fibonacci 数列第 n 项一般采用矩阵法：

$$\begin{bmatrix} f_{n+1} & f_n \\ f_n & f_{n-1} \end{bmatrix} = \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}^n$$

问题在于这里 $n \leq 10^{1000}$。对于如何处理这么大的整数，每篇题解都是八仙过海各显神通。不过本蒟蒻还是想到一种更简单易行的方法（明明很简单为什么大佬们都没写呢）。

## 核心内容

一句话概括：将快速幂从二进制扩展到十进制。原始的快速幂大家都理解了，在计算 $a^b$ 时：

- 如果 $b$ 的第零个二进制位为 $1$，则这一位对结果的贡献为 $a$;
- 如果 $b$ 的第一个二进制位为 $1$，则这一位对结果的贡献为 $a^2$;
- 如果 $b$ 的第二个二进制位为 $1$，则这一位对结果的贡献为 $a^4$;
- ......

那何不将其扩展到十进制的形式？

- 如果 $b$ 的个位为 $x$，则这一位对结果的贡献为 $a^x$;
- 如果 $b$ 的十位为 $x$，则这一位对结果的贡献为 $a^{10x}$;
- 如果 $b$ 的百位为 $x$，则这一位对结果的贡献为 $a^{100x}$;
- ......

这样做的好处是 $n$ 可以直接用字符串储存，而不需要使用高精度并将其转化为二进制了。

代码如下（只放核心的快速幂 $m^{pow}$ 部分，可以看到 $pow$ 是字符串而非整数）：
```
    matrix22 power(matrix22 m, std::string pow)
    {
        matrix22 result(1, 0, 0, 1);
        while(!pow.empty())
        {
            int pow_bit = pow.back() - '0';
            for(int i = 0; i < pow_bit; i++)
                result = result * m;
            m = m.pow10();
            pow.pop_back();
        }
        return result;
    }
```

---

## 作者：K2sen (赞：6)

### 题目分析
因为第 i 个方块只能放到第 $i-1, i, i+1$ 上。

在这里我们只考虑在 n 的基础上加上一个方块的情况。

因为第 n+1 个方块只能在 n 与 n+1 上，我们就分别考虑放到 n 上和 n + 1上的情况。

- 当我们将新加的方块放到 n+1 上时，对 $[1, n]$ 这个范围上没有影响，所以放到 n+1 上的时候的答案就是 n 的答案。

- 当我们将新加的方块放到 n 上时，考虑到每个方块只能放到 $i-1, i, i+1$ 个位子上。因此只可能是，第 n 个方块与第 n+1 个方块互换， 对 $[1,n-1]$ 范围内的答案没有影响，因此它的答案刚好是 n-1 的答案。

n+1 的答案就是上边两种情况的和了。

$$
f_i = 
\begin{cases}
1 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ,n = 1\\
2 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ,n = 2\\
f_{i-1}+f_{i-2} , \operatorname{otherwise}
\end{cases}
$$

因此转移矩阵还是和 fibonacci 的转移矩阵一样，初始矩阵就是左边那样。

$$
\begin{bmatrix}
2\\
3
\end{bmatrix}
.
\begin{bmatrix}
1&1\\
1&0
\end{bmatrix}
$$

### code
这个题还需要高精把 10 进制转化成 2 进制，但是高精板子太长了我就不在这里放了。

[高精板子](https://www.luogu.com.cn/paste/u5kqldz0)

```cpp
int cnt, er[10000010];
bignum a;

const int mod = 100000000;
struct node {
	long long a[3][3], r, c;
};

inline node mul(node x, node y) {
	node p;
	memset(&p, 0, sizeof p);
	for (int i = 1; i <= x.r; i++)
		for (int j = 1; j <= y.c; j++)
			for (int k = 1; k <= x.c; k++)
				p.a[i][j] = (p.a[i][j] + x.a[i][k] * y.a[k][j] % mod) % mod; 
	p.r = x.r, p.c = y.c;
	return p;
}

void q_pow() {
	node ans, p;
	memset(&p, 0, sizeof p);
	memset(&ans, 0, sizeof ans);
	ans.a[1][1] = 1, ans.a[1][2] = 0, ans.r = 1, ans.c = 2;
	p.a[1][1] = p.a[1][2] = p.a[2][1] = 1, p.a[2][2] = 0, p.r = p.c = 2;
	int i = 1;
	while (i <= cnt) {
		if (er[i] == 1) ans = mul(ans, p);
		p = mul(p, p);
		i++;
	}
	cout << ans.a[1][1];
}

signed main() {
	cin >> a;
	if (a <= 3) {
		if (a == 1) puts("1");
		else if (a == 2) puts("2");
		else if (a == 3) puts("3");
	} else {
		while (a != 0) {
			er[++cnt] = a % 2;
			a /= 2;
		}
		q_pow();
	}
	return 0;
}

```

---

## 作者：Viston (赞：5)

- 我Viston就算是死，死这里，从这儿跳下去，我也不可能写高精度。   

循环节最好用了....快读最好用了.....通项公式最好用了.......     

证明可以参照楼下那位P党大佬，我就讲讲用通项公式+循环节的做法吧....、   

通项公式：     

设 $n\in R$,则有：
$$F[2n] = F[n+1]^2-F[n-1]^2 = (2F[n-1]+F[n])F[n]$$

$$F[2n+1] = F[n+1]^2 + F[n]^2 $$     
于是我们就可以用这个公式+高精度取膜循环节（高精%低精可以直接在快读中进行）   

见代码
```
#include<bits/stdc++.h>
using namespace std;
map<long long ,long long>mmp;     //map优化递归求斐波拉契
long long a,b,c,d;
long long dfs(long long a){
	if(a==1) return 1;
	if(a==2) return 1;
	if(mmp[a]!=0) return mmp[a];
	else return 
		mmp[a]=a%2==0?(dfs(a/2)+2*dfs(a/2-1))*dfs(a/2)%100000000 :
		 (dfs(a/2)*dfs(a/2)+dfs(a/2+1)*dfs(a/2+1))%100000000;
}        //通项公式求斐波拉契
inline long long read(){
	long long X=0;char ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)) X=(X*10+ch-'0')%150000000,ch=getchar();
	return X;
}     //取摸150000000直接在快速读入中进行
int main(){
	a=read();
	cout<<dfs(a+1);
}          //主程序真短
```

---

## 作者：BFSBFSBFSBFS (赞：4)

~~(题目给了双倍时间空间..).~~.

题意.给出n个数.每个数的位置可能移动.但只可能移动到原位置+1或-1.求不同序列的总数..

可以看出.这是1个交换过程..且每个数最多只能被交换1次...(除非反复交换..)..

拿来P1962程序跑了跑样例..果然是的..

下面给出~~伪~~证明..
```
设f[i]为前i位可能组成不同序列的数量.
将f[i]拆分.
f[i,1]表示第i个数与第i-1个数交换后,有多少不同序列.
f[i,2]表示第i个数与第i-1个数不交换,有多少不同的序列..
显然有.f[i] = f[i,1]+f[i,2];
如果交换.第i-1个数不能再被其他的数交换..有f[i,1] = f[i-1,2];
没有交换.不产生影响.f[i,2] = f[i-1,1]+f[i-1,2];
接下来.
f[i,1] = f[i-1,2] = f[i-2,1]+f[i-2,2] = f[i-2];
f[i,2] = f[i-1,1]+f[i-1,2] = f[i-1];
f[i] = f[i,1]+f[i,2] = f[i-2]+f[i-1] = f[i-1]+f[i-2];
```
**所以这就是个Fibonacci...**.

若你过了P1962,或者会矩阵乘法.大概就能过了..

我的构造方法:
```
1 1   1 1 ^(n-1)
    *(   )       mot 100000000.
0 0   1 0
 a     b
ans = a[1,1].
```
题目说只给0.2s..~~(其实是0.4s.).~~.

于是跑到P4000补了补循环节求法..请至P4000题解查看....

~~(懒得写..).~~.

经过计算.本题可以转化成:

**先将n对150000000取模,用矩阵乘法求Fibonacci第n+1项对100000000取模..**.

丢代码..太乱的话建议去掉//并分开子程序..

~~其实建议不要看..~~.
```
program P2100;
 type
  ws=record
   fc:array[1..2,1..2] of int64; //矩阵.
   x,y:longint;
  end;
  wc=record                      //就是个字符换数字的东西..
   case integer of
    1:(c:char);
    2:(d:byte);
  end;
 var
  a,b,c,d:ws;
  cc:wc;
  mot,mots,p:int64;
 function hahainf(p:int64):int64;forward;
 function hahafff(x:int64):int64;forward;
 function hahaggb(P:int64):int64;forward;
 operator **(x,y:int64)z:int64;  //快速幂..
  begin
   z:=1;
   while y>0 do
    begin
     if y and 1=1 then z:=z*x mod mot;
     x:=x*x mod mot;
     y:=y>>1;
    end;
  end;
 operator *(x,y:ws)z:ws;         //矩乘.
  var
   i,j,k:longint;
  begin
   fillqword(z,sizeof(z)>>3,0);
   z.x:=x.x;
   z.y:=y.y;
   for i:=1 to x.x do
    for j:=1 to y.y do
     for k:=1 to x.y do
      z.fc[i,j]:=(z.fc[i,j]+x.fc[i,k]*y.fc[k,j]) mod mot;
  end;
 function hahagcd(x,y:int64):int64;   //求gcd..
  begin
   if x<y then exit(hahagcd(y,x));
   if y=0 then exit(x);
   exit(hahagcd(y,x mod y));
  end;
 function hahaha(p:int64):int64;         //用来求循环节.
  var
   i:longint;
   x,y:int64;
  procedure hahax(var p:int64;i:int64);  //请出门至P4000.
   begin
    y:=p div i;
    x:=hahaggb(i);
    while p mod i=0 do p:=p div i;
    x:=x*y div p;                           //g(i)*i^(m-1);
    hahaha:=hahaha div hahagcd(hahaha,x)*x; //求lcm...
   end;
  begin
   hahaha:=1;
   for i:=2 to trunc(sqrt(p)) do         //对膜值分解..
    if p mod i=0 then hahax(p,int64(i));
   if p>1 then hahax(p,p);
  end;
 function hahaggb(p:int64):int64;        //请出门至P4000.
  var
   ffiu:array[0..5] of longint=(0,1,3,8,6,20);
  begin
   if (p<=5) then exit(ffiu[p]);
   if 5**((p-1)>>1)=1 then exit(hahainf(p-1))      //欧拉准则.??
                      else exit(hahainf((p+1)<<1)); /x^((p-1)>>1) = 1.
   //writeln(5**((p-1)>>1)=1);
   //exit(hahainf((p+1)<<1));
  end;
 function hahainf(p:int64):int64;         //此处本应该求约数..
  begin                                    /由于1E+08 = 2^8*5^8;
   //if hahafff(f[i]+4)=3 then exit(f[i]); /也就没用了..
   //exit(5882353);
  end;
 function hahafff(x:int64):int64;         //矩阵快速幂..
  begin
   while x>0 do
    begin
     if x and 1=1 then a:=a*b;
     x:=x>>1;
     b:=b*b;
    end;
   hahafff:=a.fc[1,1];
  end;
 procedure haharere;        //初始化..
  begin
   fillchar(d,sizeof(d),0);
   d.x:=2;
   d.y:=2;
   b:=d;
   a:=d;
   b.fc[1,1]:=1;
   b.fc[1,2]:=1;
   b.fc[2,1]:=1;
   a.fc[1,1]:=1;
   a.fc[1,2]:=1;
   a.x:=1;
  end;
 begin
  mot:=100000000;
  //writeln(hahaha(mot));
  mots:=hahaha(mot);       //也可直接赋值为150000000..
  haharere;
  //readln(n);
  //writeln(hahafff(5));
  p:=0;
  while not eoln do
   begin
    read(cc.c);
    //writeln(cc.d);
    p:=(p*10+cc.d-48) mod mots;
   end;
  writeln(hahafff(p-1));   //由于前2项已经在矩阵里..只要乘上n-1项..
 end.
```
(ಡωಡ).


---

## 作者：lg1058428 (赞：2)

这题竟然还能写题解。
# 解题思路
先从递推的方向考虑。  
令 $dp_n$ 代表 $n$ 个方块的摆放方法数。
- 第 $n$ 个方块放在 $n$ 号位置上，此时剩下 $n-1$ 个位置，共有 $dp_{n-1}$ 中摆放方案。
- 第 $n$ 个方块放在 $n-1$ 号位置上，考虑第 $n-1$ 个方块的摆放位置。
  - 若摆在 $n-2$ 号位置上，则第 $n-2$ 个方块只能摆在 $n-3$ 号位置上，第 $n-3$ 个方块只能摆在 $n-4$ 号位置上，依次类推。$n$ 号位置上永远不可能摆放方块，此种方案不可行。
  - 若摆在 $n$ 号位置上，此时剩下 $n-2$ 个位置，共有 $dp_{n-2}$ 中摆放方案。
所以递推式为 $dp_n=dp_{n-1}+dp_{n-2}$。边界情况为 $dp_1=1$，$dp_2=2$。也就是斐波那契数列。使用 P4000 的方法，模数取 $10^8$，即可解决本题。
# AC 代码
```cpp
#include <bits/stdc++.h>
#define int long long
#define __lcm(a,b) __detail::__lcm((a), (b))
using namespace std;
string sn;
int n, mod;
int qpow(int x, int y) {
	int res = 1;
	while (y) {
		if (y & 1) res = res * x;
		x = x * x;
		y >>= 1;
	}
	return res;
}
int ppisano(int p) {
	if (p == 2) return 3;
	if (p == 3) return 8;
	if (p == 5) return 20;
	if (p % 5 == 1 || p % 5 == 4) return p - 1;
	return 2 * (p + 1);
}
int pkpisano(int p, int k) {
	return ppisano(p) * qpow(p, k - 1);
}
int xpisano(int x) {
	int res = 1;
	for (int i = 2; i <= x / i; i++) {
		if (x % i != 0) continue;
		int cnt = 0;
		while (x % i == 0) {
			cnt++;
			x /= i;
		}
		res = __lcm(res, pkpisano(i, cnt));
	}
	if (x != 1) res = __lcm(res, ppisano(x));
	return res;
}
pair<int, int> qfib(int n) {
	if (n == 0) return {0, 1};
	pair<int, int> pii = qfib(n / 2);
	int f1 = pii.first * (2 * pii.second % mod - pii.first) % mod;
	int f2 = (pii.first * pii.first % mod + pii.second % mod * pii.second % mod) % mod;
	if (n % 2 == 1) return {f2, (f1 + f2) % mod};
	else return {f1, f2};
}
signed main() {
	cin >> sn; mod = 1e8;
	int len = sn.size();
	sn = ' ' + sn;
	int p = xpisano(mod);
	for (int i = 1; i <= len; i++) n = (n * 10 + sn[i] - '0') % p;
	cout << (qfib(n).second + mod) % mod;
	return 0;
}
```

---

## 作者：Mortidesperatslav (赞：1)

~~MC 真的有大理石吗？~~

我们先讨论放法。记 $f_i$ 为 $i$ 个方块的放法数。

我们首先可以知道，第 $1$ 个格子只有 $1,2$ 两个方块可以放，第 $1$ 个方块只能放 $1,2$ 两个格子。

那么如果第 $1$ 个方块放了第 $1$ 格，第 $2$ 个方块就变成了剩下方块中的第 $1$ 个（它的左边已经被方块占用了），这种情况下有 $f_{i-1}$ 种放法。

否则因为第 $1$ 个格子只有 $1,2$ 两个方块可以放，所以第 $2$ 个方块放在第 $1$ 个格子。那么剩下 $f_{i-2}$ 个方块。

综上所述，有 $f_i=f_{i-1}+f_{i-2}$。

边界情况：

+ $f_1=1$。

+ $f_2=2$。

所以我们要求的就是斐波那契数列第 $n+1$ 项！

但是因为 $n \leq 10^{1000}$，时限还极小，朴素矩阵快速幂很可能卡不过去。

但是我们可以找循环节。找一篇 P4000 的题解都可以看到。但是其实我们也可以暴力枚举。计算得到 $150000000$。然后就是愉快的矩阵快速幂了。

取模不需要高精，快读边读边模即可。

代码就不加注释了，因为完全是套模板。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct juzhen{
	public:
		int a[2][2];
};
juzhen p;
juzhen juzhenchengfa(juzhen x,juzhen y){//It is zhouly
	juzhen res;
	memset(res.a,0,sizeof(res.a));
	for(register int i=0;i<2;i++)
		for(register int j=0;j<2;j++)
			for(register int k=0;k<2;k++)
				res.a[i][j]=(res.a[i][j]+(x.a[i][k]*y.a[k][j])%100000000)%100000000;
	return res;		
}
juzhen juzhenkuaisumi(juzhen x,int y){
	juzhen res;
	res.a[0][0]=-1;
	while(y>0){
		if(y&1){
			if(res.a[0][0]==-1)res=x;
			else res=juzhenchengfa(res,x);
		}
		x=juzhenchengfa(x,x);
		y>>=1;
	}
	return res;
}
inline long long read(){
	long long x=0;
	char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))x=(x*10+ch-'0')%150000000,ch=getchar();
	return x;
}
signed main(){
	p.a[0][0]=1,p.a[0][1]=1,p.a[1][0]=1,p.a[1][1]=0;
	int k=read();
	k++;
	if(k<=2){
		cout<<1;
		return 0;
	}
	juzhen q=juzhenkuaisumi(p,k-2);
	int ans=q.a[0][1]+q.a[0][0];
	cout<<ans%100000000; 
}
```

---

## 作者：CQ_Alice (赞：1)

题目大意：共 $n$ 个物品，第 $i$ 个物品可以放在 $i-1$，$i$，$i+1$ 的位置，不能放在 $0$ 和 $n + 1$ 的位置。

考虑动态规划 $f_{i,j=0/1/2}$ 表示前 $i$ 个物品都已经放好了，此时第 $i$ 个物品放在 $i-1(j=0)$，$i(j=1)$ 以及 $i+1(j=2)$。

那么转移还是比较好想。

若物品 $i$ 放在位置 $i-1$ 那么物品 $i-1$ 就一定需要放到 $i$ 的位置，否则 $i$ 后面的物品会不够放完 $i\sim n$ 这一段位置。

$f_{i,0}=f_{i-1,2}$

若物品 $i$ 放在位置 $i$ 那么物品 $i-1$ 即可以摆放到位置 $i-2$，也可以就摆放到位置 $i-1$，唯独不能摆放到位置 $i$，因为位置 $i$ 已经摆放了物品 $i$。 

$f_{i,1}=f_{i-1,0}+f_{i-1,1}$

若物品 $i$ 放在位置 $i+1$ 那么物品 $i-1$ 即可以摆放到位置 $i-2$，也可以就摆放到位置 $i-1$，唯独不能摆放到位置 $i$，因为物品 $i-1$ 一旦放在了位置 $i$，则位置 $1\sim i-1$ 就不够放完了。

$f_{i,2}=f_{i-1,0}+f_{i-1,1}$

那么答案就是 $f_{n,0}+f_{n,1}$，物品 $n$ 只能放在位置 $n-1$ 和 $n$。

初始化令 

$f_{0,1}=1$，
$f_{0,0}=f_{0,2}=0$

意义是构造一个物品 $0$，让他放在自己的位置，这样物品 $1$ 就不能放在位置 $0$ 了，符合题意。

直接递推是会超时的，考虑矩阵优化。

我们有这样两个矩阵。

$ A = \begin{bmatrix} f_{i-1,0} & f_{i-1,1} & f_{i-1,2} \end{bmatrix} $ 

$ B = \begin{bmatrix} f_{i,0} & f_{i,1} & f_{i,2} \end{bmatrix}$

根据上面的递推式子我们很容易得到一个系数矩阵为：

$$ stant = \begin{bmatrix} 0 & 1 & 1 \\ 0 & 1 & 1 \\ 1 & 0 & 0 \end{bmatrix} $$

这样我们可以通过 $A \times stant$ 得到 $B$，矩阵乘法实现转移。

$A \times stant=$

$$ A = \begin{bmatrix} 0 \times f_{i-1,0} + 0 \times f_{i-1,1} + 1 \times f_{i-1,2} \\ 1 \times f_{i-1,0} + 1 \times f_{i-1,1} + 0 \times f_{i-1,2} \\ 1 \times f_{i-1,0} + 1 \times f_{i-1,1} + 0 \times f_{i-1,2}\end{bmatrix}$$ 

注意这里的矩阵 $A$ 本应该是 $1 \times 3$，作者把他写成 $3 \times 1$ 是为了更好的观察。

所以最后我们会推出来一个矩阵 
$S = \begin{bmatrix} f_{n,0} & f_{n,1} & f_{n,2} \end{bmatrix}$。

此时 $S_{0,0}+S_{0,1}$ 就是答案，使用矩阵快速幂求即可。

想到这这道题产不多解决了三分之二了，接下来的问题在于给定的 $n$ 需要高精度来读入，若按照传统做法我们需要拆分二进制，这对于高精来说实在是不好处理，所以我们就按照十进制来做矩阵幂。

比如有个矩阵 $A$，现在你要求 $A^{152}$。这个时候 $152=2 \times 10^0+5 \times 10^1+1 \times 10^2$
    
于是就有 $A^{152}=A^{2 \times 10^0} \times A^{5 \times 10^1} \times A^{1 \times 10^2}$。

$A^{10^k}$ 进行十遍乘法就可以转移了，$(A^{10^{k - 1 }})^{10}  = A^{10^k}$

然后根据每一位的数字来决定这一位矩阵乘法系数，这一位有多少就乘多少。

```cpp
求矩阵a 的 b次方
b 是一个字符串类型存储的高精度

定义矩阵 c , d;
for(int i = b.length( ) - 1 ; i >= 0 ; i -- ){ // 从低位往高位枚举
	int k = b[i] - '0';// k 是这一位的数字
	while( k -- ) c *= a ;有多少次乘多少次
   d = a ; 
	int p = 9 ; 
	while( p -- ) { // 乘十次得到下一位对应的矩阵 a
		d *= a ;
	}
   a = d ;
}
return c ; 
```

！完结撒花！


---

## 作者：dreagonm (赞：1)

斐波那契数列的规律下面的julao都说的很明白了

下面说一种乱搞AC的方法

常数稍大，**不开O2** 200多ms~~吸氧181ms~~

首先考虑快速幂的过程
会发现只有按位的右移、查询有无为1的位、查询最低位二进制是否为1的操作，都是对二进制数直接操作，所以我们有了显然的想法，如何表示这么大的n呢？

当然是**bitset**(逃

所以用bitset表示一个二进制数，实测表示4000位可过

然后快速幂的问题解决了，下一步就是如何把一个高精度数转化为二进制数，这步需要用到大整数快速转换进制的科技，下面就讲一讲这种资本操作

---

具体过程很好描述，就是类比正常的取模转换进制的方法，对每位做除法，用上一位的除法余数乘以原来的进制数加上这一位的值和要转换的进制数相除替换这一位的值，迭代的做下去，对每一位都重复这个过程，记录每次的最终余数，最后逆序输出即可

**是不是看晕了？**
~~那看一眼代码吧~~

```cpp
int i,m=lennum,t,cnt=0;
while(m>=0){
	t=0;
    for(i=m;i>=0;i--){//lennum是最高位
		t=t*oldbase+num[i];
        num[i]=t/newbase;
        t=t%newbase;
	}
    for(i=lennum;i>=0&&(!num[i]);i--);
    result[cnt++]=t;
    m=i;
}
```
就没有了
剩下的就是矩阵快速幂求fib的板子

最后贴上代码
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <bitset>
#include <string>
#include <iostream>
#define int long long
using namespace std;
const int MOD = 100000000;
//int n;
bitset<4000> n;
string nx;
int num[2000000],numlen;
void basetrun(void){
	int cnt=0,m=numlen,t=0;
	while(m>=0){
		int t=0,i;
		for(i=m;i>=0;i--){
			t=t*10+num[i];
			num[i]=t/2;
			t=t%2;
		}
		n[cnt++]=t;
		for(i=numlen;i>=0&&(!num[i]);i--);
		m=i;
	}
}
void getnum(void){
	for(int i=nx.length()-1,j=0;i>=0;i--,j++){
		num[j]=nx[i]-'0';
	}
	numlen=nx.length()-1;
}
struct Matrix{
  static const int MAXN = 4;
  int alpha[MAXN][MAXN];
  int n,m;
  void init(void){
    for(int i=0;i<MAXN;i++)
      for(int j=0;j<MAXN;j++)
        alpha[i][j]=0;
    n=m=0;
  }
  void init_f2(void){
    n=2;m=2;
    alpha[1][1]=1;
    alpha[2][1]=1;
    alpha[1][2]=1;
    alpha[2][2]=0;
  }
  void init_f(void){
    n=1;m=2;
    alpha[1][1]=1;
    alpha[1][2]=1;
  }
  void init_pow(int x){
    for(int i=1;i<=x;i++)
      alpha[i][i]=1;
    m=n=x;
  }
  Matrix operator * (Matrix b){
    Matrix c;
    c.init();
    for(int i=1;i<=n;i++)
      for(int j=1;j<=b.m;j++)
        for(int k=1;k<=m;k++)
          c.alpha[i][j]=(c.alpha[i][j]%MOD+alpha[i][k]*b.alpha[k][j]%MOD)%MOD;
    c.n=n;
    c.m=b.m;
    return c;
  }
};
Matrix pow(Matrix a){
  Matrix ans;
  ans.init();
  ans.init_pow(a.n);
  while(n.any()){
    if(n[0])
      ans=ans*a;
    a=a*a;
    n>>=1;
  }
  return ans;
}
signed main(){
  cin>>nx;
  getnum();
  basetrun();
  Matrix f,f2,ans;
  f.init();
  f.init_f();
  f2.init();
  f2.init_f2();
  ans=pow(f2);
//  for(int i=1;i<=ans.n;i++){
//    for(int j=1;j<=ans.m;j++)
//      printf("%d ",ans.alpha[i][j]);
//    printf("\n");
//    }
  f=f*ans;
  printf("%lld",f.alpha[1][2]%MOD);
  return 0;
}


```

---

## 作者：fly_x (赞：0)

题目链接：[P2100 凌乱的地下室](https://www.luogu.com.cn/problem/P2100)。

~~题号这么靠前怎么没人写啊。~~

## 大意
你有 $n$ 个方块，第 $i$ 个方块可以放置在第 $i-1$，$i$ 或 $i+1$ 的位置上，问有多少种摆放方案。
## 解法
~~打表发现~~，是**斐波那契数列**。
### 本蒟蒻的做法
我们会发现，其实就是**交换相邻的两个数，求总方案数**。理由如下：

> 方块 $i$ 只能放置至相邻位置，记为方块 $i$ 放置到了方块 $j$ 的位置上，而一个位置上不能有两个块，所以方块 $j$ 需要移动到周边空位，此时方块 $i$ 原先的位置空出，也就实现了两个方块的交换。

那么对于第 $i$ 个数（$1 \le i \le n-1$）就有两种方案：

1. **不交换**：计算剩余的 $n-i$ 个数的交换方案；
2. 和第 $i+1$ 个数**交换**：计算剩余的 $n-i-1$ 个数的交换方案。

于是得出递推式：

$f_i = \begin{cases} 
1, &0\le i\le1\\
f_{i-1} + f_{i-2}, &i>1
\end{cases}$
## 实现
看一眼数据范围：$1 \le n \le 10^{1000}$，

而时限只有：200ms（~~其实 luogu 给了 400ms~~）。

$ O(n) $ 跑不过诶 QwQ。

但是我们可以使用**矩阵快速幂/扩域/通项公式**（但是真的有人会用公式写吗）（不会的去看 [P1902](https://www.luogu.com.cn/problem/P1902)）。

同时 $n$ 需要开高精。

或者不开高精？

模 $p$ 意义下的斐波那契数列是有**周期性**的，~~暴力枚举~~得知 $p$ 为 $10^8$ 时该周期为 $1.5 \times 10^8$（如何计算可以参考 [OI-wiki](https://oi-wiki.org/math/combinatorics/fibonacci/#%E6%A8%A1%E6%84%8F%E4%B9%89%E4%B8%8B%E5%91%A8%E6%9C%9F%E6%80%A7) 以及 [P4000](https://www.luogu.com.cn/problem/P4000)，~~我太弱了我不会 QwQ~~）。

## 代码
我使用了**矩阵快速幂**来写这道题。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int mod = 1e8;
const int p = 1.5*mod;
int n;
// 初始化
struct Matrix{
	int a[3][3];
	Matrix(){memset(a, 0, sizeof a);}
	Matrix operator* (const Matrix &b) const{
		Matrix res;
		for (int i = 1; i <= 2; ++i)
			for (int j = 1; j <= 2; ++j)
				for (int k = 1; k <= 2; ++k)
					res.a[i][j] = (res.a[i][j] + a[i][k] * b.a[k][j]) % mod;
		return res;
	}
} ans, base;
void init(){
	base.a[1][1] = base.a[1][2] = base.a[2][1] = 1;
	ans.a[1][1] = ans.a[1][2] = 1;
}
void qpow(int b){
	while (b){
		if (b & 1) ans = ans * base;
		base = base * base;
		b >>= 1;
	}
}
// 矩阵快速幂板子
void read(int &x){
	char ch = getchar(); x = 0;
	while (ch < '0' || ch > '9') ch = getchar();
	while (ch >= '0' && ch <= '9'){
		x = (x * 10 + ch - '0') % p;
		ch = getchar();
	}
}
// 边读边取模（这样就不用高精啦！）
signed main() {
	read(n);
	if (n <= 1){cout << 1; return 0;}
	init(); qpow(n-1);
	cout << ans.a[1][1] % mod;
	return 0;
}

```
## 最后
审核求过 QwQ。

不太会写表达式，文中若有错误请指正。

---


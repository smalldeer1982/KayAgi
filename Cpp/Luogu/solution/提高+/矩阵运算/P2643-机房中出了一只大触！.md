# 机房中出了一只大触！

## 题目背景

机房中出了一只大触Kurunie！作为一只大触，它当然喜欢刷题。然而NOIp复赛临近，大触要抽出更多的时间来刷OI题，所以它就把一些简单的题目丢给你啦。


## 题目描述

显然，任何题目对于K触来说都是水题，倒是K触怕你不会写，于是给了你最最简单的化学卷子。

原来K触正在准备化学方程式配平大赛，所以卷子全都是配平练习题。

K触给你举了个简单的例子，比如下列物质在氧气中燃烧的化学方程式，要求配平：

 ![](https://cdn.luogu.com.cn/upload/pic/1755.png) 

K触当然知道这是绿原酸(C16H18O9)（O和0要分清楚哦），它在氧气中燃烧的方程式是：

C16H18O9+O2=CO2+H2O

什么？你说配平？这种简单的事情当然就交给你啦。


## 说明/提示

保证输入字符串长度小于等于50，字符串只包含大小写英文字母、数字、小括号、加号、等号。

涉及到的物质均不包含带结晶水。

涉及到的元素最多只有两个字母。

小括号中不会嵌套小括号。

配平后每种物质系数、原字符串中的所有下标均在32位带符号整数范围内。


## 样例 #1

### 输入

```
C16H18O9+O2=CO2+H2O```

### 输出

```
C16H18O9+16O2=16CO2+9H2O```

## 样例 #2

### 输入

```
Cu(NO3)2+Fe=Fe(NO3)2+Cu```

### 输出

```
Cu(NO3)2+Fe=Fe(NO3)2+Cu```

# 题解

## 作者：虞皓翔 (赞：16)

这道题嘛，肯定不用从化学的角度思考（神马乱凑啊，奇偶分析啦，化合价分析啦等等都可能过不去）。

如果你看到一个不会配平的方程式，如果你不想思考，你的第一反应一定是：**待定系数法**。

“待定系数法”什么意思？就是把它们都设出来，再解方程，那么你一定会想到——高斯消元。

举个例子（样例）:

![图挂了](http://latex.codecogs.com/gif.latex?\mathrm{C\_{16}H\_{18}O\_9%20+%20O\_2%20\to%20CO\_2%20+%20H\_2O})

我们设一下系数：

![图又挂了](http://latex.codecogs.com/gif.latex?x\_1\mathrm{C\_{16}H\_{18}O\_9}%20+%20x\_2\mathrm{O\_2}%20=%20x\_3\mathrm{CO\_2}%20+%20x\_4\mathrm{H\_2O})

根据元素守恒，我们就得到了一个线性方程组：

![方程组挂了](http://latex.codecogs.com/gif.latex?\left\{\begin{matrix}16x\_1&&&=&x\_3\\18x\_1&&&=&&&2x\_4\\9x\_1&+&2x\_2&=&2x\_3&+&x\_4&\end{matrix}\right.)

显然，它有4个未知数，却只有3个方程，这是无法解的。

但你要发现，化学方程式的特点，如果去掉最大公因数为1和整数的条件，如果把每种物质的系数乘上（除以）同一个数后，它依旧是配平的，所以我们可以假设一个值为1，根据个人习惯，我假设$x_4=1$。

那么方程变成了：

![方程组又挂了](http://latex.codecogs.com/gif.latex?\left\{\begin{matrix}16x\_1&&&-&x\_3&=&0\\18x\_1&&&&&=&2\\9x\_1&+&2x\_2&-&2x\_3&=&1&\end{matrix}\right.)

解之，得![图怎么还在挂](http://latex.codecogs.com/gif.latex?\left\{\begin{matrix}x\_1&=&1/9\\x\_2&=&16/9\\x\_3&=&16/9\end{matrix}\right.)

因此，原来的方程式为![蛤](http://latex.codecogs.com/gif.latex?\mathrm{\frac19C\_{16}H\_{18}O\_9+\frac{16}9O\_2=\frac{16}9CO\_2+H\_2O})

我们只需要取分母的最小公倍数 $L$ (本例中为9)，就得到正确的方程式：

![不](http://latex.codecogs.com/gif.latex?\mathrm{C\_{16}H\_{18}O\_9+16O\_2=16CO\_2+9H\_2O})

所以，本题的基本思路就是一开始写一大堆字符串处理，然后开始高斯消元。

未知数的个数 $n$ 等于物质的种类数，方程的个数 $l$ 为元素的个数，数据一定会保证 $l \geq n - 1$ ，因为我们总是可以假设一个数为1。

如果 $l > n - 1$ ，如果我们加上绝对值优化的话，数据一定会保证最后 $l - (n - 1)$ 行为全0，所以只需处理前 $n-1$ 个数即可。

长(chou)的要死的代码：

(分数类和高斯消元)

```cpp
typedef long long ll;

struct frac{
    ll x, y;
    frac (ll x0 = 0, ll y0 = 1): x(x0), y(y0) {
        if(!y0) y0 = 1;
        Canonicity();
    }
    void Canonicity(){
        if(y < 0){
            x = -x;
            y = -y;
        }
        ll d = gcd(abs(x), y);
        x /= d;
        y /= d;
    }
    frac operator + (const frac &b) const {return frac(x * b.y + y * b.x, y * b.y);}
    frac operator - (const frac &b) const {return frac(x * b.y - y * b.x, y * b.y);}
    frac operator * (const frac &b) const {return frac(x * b.x, y * b.y);}
    frac operator / (const frac &b) const {return frac(x * b.y, y * b.x);}
    bool operator < (const frac &b) const {return x * b.y < y * b.x;}
    bool operator > (const frac &b) const {return b < *this;}
    bool operator == (const frac &b) const {return x * b.y == y * b.x;}
    bool operator != (const frac &b) const {return !(*this == b);}
    void print(){
        if(y == 1) printf("%lld", x);
        else printf("%lld/%lld", x, y);
    }
};

inline frac frabs(frac z){
    if(z.x < 0) z.x = -z.x;
    return z;
}

template <typename T>
struct LnEqn{
    int r, c;
    T **m, *b;
    LnEqn (){m = NULL; b = NULL;}
    void resize(int r0, int c0){
        r = r0; c = c0; m = new T *[r];
        for(int i = 0; i < r; i++){
            m[i] = new T[c];
            memset(m[i], 0, c * sizeof(T));
        }
        b = new T[r];
        memset(b, 0, r * sizeof(T));
    }
    ~LnEqn (){
        if(m != NULL){for(int i = 0; i < r; i++) delete [] (m[i]); delete [] (m);}
        if(b != NULL) delete [] (b);
    }
    bool solve(){
        int i, j, k, maxi;
        T coe;
        for(k = 0; k < c; k++){
            maxi = k;
            for(i = k + 1; i < r; i++)
                if(frabs(m[i][k]) > frabs(m[maxi][k]))
                    maxi = i;
            if(frabs(m[maxi][k]) == frac(0)) return false;
            if(maxi != k){
                swap(m[maxi], m[k]);
                swap(b[maxi], b[k]);
            }
            coe = m[k][k];
            for(j = 0; j < c; j++)
                m[k][j] = m[k][j] / coe;
            b[k] = b[k] / coe;
            for(i = 0; i < r; i++){
                if((i == k ? ++i : i) >= r) break;
                coe = m[i][k];
                for(j = 0; j < c; j++)
                    m[i][j] = m[i][j] - coe * m[k][j];
                b[i] = b[i] - coe * b[k];
            }
        }
        return true;
    }
};
```
(字符串处理)

```cpp
//nextint函数定义
int nextint(char *p, char **q){
    if(!isdigit(*p)){
        if(q != NULL) *q = p;
        return 1;
    }
    int b;
    for(b = *p - 48; isdigit(*++p); b = b * 10 + (*p - 48));
    if(q != NULL) *q = --p;
    return b;
}
//主字符串处理，适当的应用scanf技巧
for(n = 0; ; ++n){
        scanf("%[^ +=\n]", s[n]); // reading matter
        for(p = s[n]; *p; ++p){
            if(*p == '('){
                for(q = p; *q != ')'; ++q);
                Mul = nextint(++q, NULL);        
            }else if(*p == ')'){
                nextint(++p, &p);
                Mul = 1;
            }else if(*p >= 'A' && *p <= 'Z'){
                elem = *p - 65;
                if(p[1] >= 'a' && p[1] <= 'z'){
                    elem = elem * 26 + (p[1] - 65);
                    ++p;
                }
                mul = 1;
                if(isdigit(p[1]))
                    mul = nextint(++p, &p);
                eid = (~idx[elem] ? idx[elem] : idx[elem] = nid++);
                coe[eid][n] += Mul * mul;
                //printf("elem = %d, coe[%d][%d] = %d\n", elem, eid, n, coe[eid][n]);
            }
        }
        scanf("%[ +=\n]", s[N - 1]); // reading signs
        for(p = s[N - 1]; *p; ++p){
            if(*p == '=') eq = n + 1;
            if(*p <= '\n') break;
        }
        if(*p && *p <= '\n'){++n; break;}
    }
```

---

## 作者：HiJ1m (赞：7)

思路和楼下差不多 :  字符串处理+高斯消元

我感觉我的字符串处理写的更亲民一些 （楼下大佬代码我看不懂 =、=）

我的博客原文链接http://www.cnblogs.com/Elfish/p/7631603.html

完整代码

/\*
Chemical Equation Balancer

HiJ1m 2017.10.6

\*/
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int gcd(int x,int y){
    return x%y==0?y:gcd(y,x%y);
}
inline int lcm(int x,int y){
    return x*y/gcd(x,y);
}
struct frac{                            //分数类 
    int a,b;
    void reduce(){
        int x=gcd(a,b);
        a/=x,b/=x;
    };
    frac operator = (int x){
        a=x,b=1;
        return *this;
    };
    frac operator = (const frac x){
        a=x.a,b=x.b;
        reduce();
        return *this;
    };
    frac operator + (const frac x){
        return (frac){b*x.a+a*x.b,b*x.b};
    };
    frac operator - (const frac x){
        return (frac){a*x.b-b*x.a,b*x.b};
    };
    frac operator * (const frac x){
        return (frac){a*x.a,b*x.b};
    };
    frac operator / (const frac x){
        return (frac){a*x.b,b*x.a};
    };
    bool operator < (const frac x){
        return a*x.b<b*x.a;
    };
    bool operator == (const frac x){
        return a*x.b==b*x.a;
    };
    void print(){
        if(b==1)printf("%d\n",a);
        else printf("%d/%d\n",a,b);
    };
};        
inline frac Abs(frac x){
    int p=x.a>0?x.a:-x.a,q=x.b>0?x.b:-x.b;
    return (frac){p,q};
}                                            
char s[55];
int fun[55][55];
int Map[27][27];                        //手动MAP 
frac M[55][55];                            //求解矩阵
frac ans[55];                            //解 
int Ans[55];                            //整数解 
int cnt,c1,c2,flag=1,N,K;                //cnt数元素，c1数反应物，c2总数 （未知数的数量） 
char mat[55][55];                        //存储物质的名称 
void print(){
    printf("%d %d\n",N,K);
    for(int i=1;i<=K;i++){
        for(int j=1;j<=N+1;j++)
            printf("%d ",M[i][j].a);
        printf("\n");
    }
    printf("\n");
}
inline int getint(int pos){                //读数 
    pos++;
    if(s[pos]>='a'&&s[pos]<='z')pos++;
    if(s[pos]<'0'||s[pos]>'9')return 1;                                //没数就是1 
    else {
        int x=0;
        while(s[pos]>='0'&&s[pos]<='9')x=x*10+s[pos]-'0',pos++;        //读元素后面的数字 
        return x;
    }
}
inline void scan(int l,int r){             //处理物质    
    c2++;
    for(int i=0;i<=r-l;i++)mat[c2][i]=s[l+i];        //存下元素的名字
    if(flag==1)c1++;                                //统计一下反应物数量
    int tmp=1;                                        //tmp是小括号倍数 
    for(int i=l;i<=r;i++){
        if(s[i]==')')tmp=1;                                                        
        if(s[i]=='('){
            int j=i+1;while(s[j]!=')')j++;            //找这个括号的范围 
            tmp=getint(j);                            //读")"右边的数字 
        }
        if(s[i]>='A'&&s[i]<='Z'){                    //发现元素 
            int x=s[i]-'A'+1,y=0;
            if(s[i+1]>='a'&&s[i]<='z')                //看一眼是一个字母的还是两个的 
                y=s[i+1]-'a'+1;
            if(!Map[x][y])Map[x][y]=++cnt;            //判重
            fun[Map[x][y]][c2]+=flag*getint(i)*tmp;    //把这个物质里的这种元素数量放进矩阵里，坐标（map[x][y]，c2） 
        }
    } 
}
inline bool Solve(){                    //解方程  （矩阵 高cnt，宽c2+1,c2+1列常数全0） 
    ans[c2]=1;                                    //令最后一个解为1
    for(int i=1;i<=cnt;i++){
        for(int j=1;j<=c2;j++)
            M[i][j]=fun[i][j];
    }
    for(int i=1;i<=cnt;i++)
        M[i][c2].a=-M[i][c2].a;            //移到常数 
    //高斯消元过程 
    N=c2-1,K=cnt;
    for(int k=1;k<=N;k++){
        frac maxm=(frac){-1,1};int maxi;
        for(int i=k;i<=K;i++)
            if(maxm<Abs(M[i][k]))
                maxm=Abs(M[i][k]),maxi=i;
        if(maxm==(frac){0,1})
            return false;
        if(maxi!=k)
            for(int j=1;j<=N+1;j++){
                swap(M[k][j],M[maxi][j]);
            }
        frac tmp=M[k][k];
        for(int j=1;j<=N+1;j++)
            M[k][j]=M[k][j]/tmp;
        for(int i=k-1?1:2;i<=K;i++){
            if(i==k)continue;
            frac tmp=M[i][k];
            for(int j=1;j<=N+1;j++)
                M[i][j]=M[i][j]-tmp*M[k][j];
        }
    }
    return true;
}
int main()
{
//    printf("Chemical Equation Balancer\n");
//    printf("\nEnter the chemical equation:\n");
    scanf("%s",s);
    int lst=0;
    for(int i=1;i<strlen(s);i++){
        if(i==strlen(s)-1)scan(lst,i);                    
        if(s[i]=='+'||s[i]=='=')scan(lst,i-1),lst=i+1;     
        if(s[i]=='=')flag=-1;                            //等号后面的系数变负 
    }
    if(Solve())
        for(int i=1;i<=c2-1;i++)
            ans[i]=M[i][N+1];
    else printf("No Solution");
    int tmp=lcm(ans[1].b,ans[2].b);
    for(int i=3;i<=c2;i++)tmp=lcm(tmp,ans[i].b);
    for(int i=1;i<=c2;i++)Ans[i]=ans[i].a*tmp/ans[i].b;    //取分母Lcm，把分数变整数 
    for(int i=1;i<=c2;i++)
    {
        if(Ans[i]>1)printf("%d",Ans[i]);
        for(int j=0;j<strlen(mat[i]);j++)
            printf("%c",mat[i][j]);
        if(i==c2)return 0;
        else if(i==c1)printf("=");
        else printf("+");
    }
}
```

---

## 作者：Inlay1158 (赞：6)

这道题目是一道字符串处理和高斯消元的题目，并且这道题目主要难在字符串处理，处理出字符串以后高斯消元就不难了。

--------

对于大多数（不是所有）的化学方程式，都可以用待定系数法配平，而带有 $n$ 种物质的化学方程式，用待定系数法可以列出 $n-1$ 个本质不同的方程，貌似没有唯一解。但是，我们可以发现，这些方程的比例是固定的，那么我们不妨设这个化学方程式的最后一项为 $1$，然后解这个方程即可。拿样例一来说，要配平化学方程式为  
$$
\text{C}_{16}\text{H}_{18}\text{O}_{9}+\text{O}_{2}\longrightarrow\text{CO}_2+\text{H}_2\text{O}
$$


设一下系数，可得  
$$
a\text{C}_{16}\text{H}_{18}\text{O}_{9}+b\text{O}_{2}====c\text{CO}_2+d\text{H}_2\text{O}
$$


假设 $d=1$，那么可列出方程组：  
$$
\begin{cases}
16a-c & = 0 \\
18a & = 2 \\
9a+2b-2c & = 1
\end{cases}
$$
解方程，可得  
$$
\begin{cases}
a & = \dfrac{1}{9} \\
b & = \dfrac{16}{9} \\
c & = \dfrac{16}{9}
\end{cases}
$$
代回化学方程式中  
$$
\dfrac{1}{9}\text{C}_{16}\text{H}_{18}\text{O}_{9}+\dfrac{16}{9} \text{O}_{2}====\dfrac{16}{9}\text{CO}_2+\text{H}_2\text{O}
$$
将系数全部乘以九，即可得出正确的化学方程式  
$$
\text{C}_{16}\text{H}_{18}\text{O}_{9}+16\text{O}_{2}====16\text{CO}_2+9\text{H}_2\text{O}
$$
这就是处理高斯消元的过程，但是难点并不在这，而在字符串处理。  

--------

如何处理字符串呢？首先，我们要找到这个化学方程式有几种元素，这时候，先扫一遍有哪些元素。注意，有些元素有两个字母（一大一小），所以碰到大写字母的时候需要判断一下后一个是不是小写字母。找到这个元素后，就把它记录下来。

```cpp
void getele() {
	ll det = 0;
	while (det < len) {
		if (!isalpha(str[det])) {++det; continue;}
		if (det <= len - 2 && islower(str[det + 1])) {//判断这个元素是否有两个字母
			string s; s += str[det], s += str[det + 1], det += 2;
			if (!e[s]) ele[++eles] = s, e[s] = eles; continue;
		}
		string s; s += str[det], ++det;
		if (!e[s]) ele[++eles] = s, e[s] = eles;//e数组是map数组
	}
}
```

接着，处理一下出现了哪些分子，并找到分界线，由于不存在结晶水的点号，所以分隔两个分子的符号只有两个符号，一个是 `+`，另一个是 `=`，记录一下在这两个符号之前的字符串即可。

```cpp
void getmol() {
	ll det = 0; mols = 1;
	while (det < len) {
		if (str[det] == '+' || str[det] == '=') {
			if (str[det] == '=') part = mols + 1;
			++det, ++mols; continue;
		}
		mol[mols] += str[det], ++det;
	}
}
```

然后，处理出一个分子中各个元素的个数，遇到括号，用一个临时数组存一下括号内的各个元素的个数，由于不会内嵌括号，所以这样处理是对的，处理完括号内部以后，如果有系数，就将括号内的各个元素的个数都乘以系数。遇到元素，也如法炮制，这样，即可处理出分子里面各个元素的个数。

```cpp
void getnum(string s, ll k) {//k表示是数组中第一维下标
	ll len = s.length(), det = 0;
	while (det < len) {
		if (s[det] == '(') {
			memset(temp, 0, sizeof(temp)), ++det;
			while (s[det] != ')') {
				if (isalpha(s[det])) {
					string t; t += s[det];
					if (islower(s[det + 1])) ++det, t += s[det];
					++det; ll num = 0;
					while (isdigit(s[det])) num = num * 10 + s[det] - 48, ++det;
					if (!num) num = 1; temp[e[t]] += num;
				}
			}
			++det; ll num = 0;
			while (det < len && isdigit(s[det])) num = num * 10 + s[det] - 48, ++det;
			if (!num) num = 1;
			for (ll i = 1; i <= eles; ++i) cnt[k][i] += temp[i] * num;
		}
		string t; t += s[det];
		if (det <= len - 2 && islower(s[det + 1])) ++det, t += s[det];
		++det; ll num = 0;
		while (det < len && isdigit(s[det])) num = num * 10 + s[det] - 48, ++det;
		if (!num) num = 1; cnt[k][e[t]] += num;
	}
}
```

然后，就是处理高斯消元的部分了，方法在上面已经讲过了，我就不再赘述了，分数的运算应该也是会的。  

分数类结构体代码如下：

```cpp
struct frac {
	ll p, q;
	frac(ll p = 0, ll q = 1): p(p), q(q){
		ll t = __gcd(abs(p), q);
		this->p /= t, this->q /= t;
	}
	frac Abs() {//取绝对值，避免出问题
		return frac(abs(p), q);
	}
	friend bool operator <(frac a, frac b) {
		ll q = a.q * b.q / __gcd(a.q, b.q);
		a.p *= q / a.q, b.p *= q / b.q;
		return a.p < b.p;
	}
	friend frac operator +(frac a, frac b) {
		ll q = a.q * b.q / __gcd(a.q, b.q);
		a.p *= q / a.q, b.p *= q / b.q;
		return frac(a.p + b.p, q);
	}
	friend frac operator -(frac a, frac b) {
		ll q = a.q * b.q / __gcd(a.q, b.q);
		a.p *= q / a.q, b.p *= q / b.q;
		return frac(a.p - b.p, q);
	}
	friend frac operator *(frac a, frac b) {
		return frac(a.p * b.p, a.q * b.q);
	}
	friend frac operator /(frac a, frac b) {
		ll p = a.p * b.q, q = a.q * b.p;
		if (q < 0) q = -q, p = -p;//由于除法可能会出现分母为负数的情况，所以要特判一下
		return frac(p, q);
	}
};
```

最后，上高斯消元的代码：

```cpp
void gauss() {
	for (ll i = 1; i <= eles; ++i) {
		for (ll j = 1; j < part; ++j)//在分界线前系数为正，在分界线后系数为负
			a[i][j] = frac(cnt[j][i]);
		for (ll j = part; j < mols; ++j)
			a[i][j] = frac(-cnt[j][i]);
		a[i][mols] = frac(cnt[mols][i]);
	}
	for (ll i = 1; i < mols; ++i) {
		ll det = i;
		for (ll j = i + 1; j <= eles; ++j)
			if (a[det][i].Abs() < a[j][i].Abs())
				det = j;
		swap(a[i], a[det]);//数组也是可以直接swap了
		for (ll j = i + 1; j <= eles; ++j) {
			frac t = a[j][i] / a[i][i];
			for (ll k = i; k <= mols; ++k)
				a[j][k] = a[j][k] - t * a[i][k];
		}
	}
	ans[mols] = frac(1);
	for (ll i = mols - 1; i; --i) {
		ans[i] = a[i][mols] / a[i][i];
		for (ll j = i - 1; j; --j)
			a[j][mols] = a[j][mols] - ans[i] * a[j][i], a[j][i] = frac();
	}
	for (ll i = 1; i <= mols; ++i) lcm = lcm * ans[i].q / __gcd(lcm, ans[i].q);//处理分母的最小公倍数
	flcm = frac(lcm);
	for (ll i = 1; i <= mols; ++i) {
		ans[i] = ans[i] * flcm;
		sol[i] = ans[i].p;
	}
	gcd = sol[1];
	for (ll i = 2; i <= mols; ++i) gcd = __gcd(gcd, sol[i]);//最后还要除以最大公约数
	for (ll i = 1; i <= mols; ++i) sol[i] /= gcd;
}
```

主要代码都已经给出了，剩下的代码就自己实现了。

---

## 作者：jianhe (赞：4)

### 思路：
设每个化学式前的系数为 $a,b,\cdots$。

则对于 $aC_{16}H_{18}O_9+bO_2=cCO_2+dH_2O$，有
$$\left\{
\begin{aligned}
16a&=c&(C)\\
18a&=2d&(H)\\
9a+2b&=2c+d&(O)
\end{aligned}
\right.
$$
移项后得到
$$\left\{
\begin{aligned}
16a-c&=0&(C)\\
18a-2d&=0&(H)\\
9a+2b-2c-d&=0&(O)
\end{aligned}
\right.
$$
~~根据 [化学方程式配平](https://baike.baidu.com/item/%E5%8C%96%E5%AD%A6%E6%96%B9%E7%A8%8B%E5%BC%8F%E9%85%8D%E5%B9%B3/3013725#2-3) 的基本原则~~，我们可以设其中一个变量为 $1$，最后算出来为分数再进行通分。

比如设 $d\leftarrow1$，那么就得到了
$$\left\{
\begin{aligned}
16a-c&=0&(C)\\
18a&=2&(H)\\
9a+2b-2c&=1&(O)
\end{aligned}
\right.
$$
[高斯消元](https://www.luogu.com.cn/problem/P3389) 即可。
### 细节：
前面处理化学方程式的部分类似于 
[P2382 化学分子式](https://www.luogu.com.cn/problem/P2382)，高斯消元时由于过程要保留分数，所以要定义一个分数类来计算。同时在通分的时候记得先将 $d\leftarrow1$，再通分。
### 代码：
```cpp
/*
 * @Author: jianhe
 * @Date: 2025-06-27 10:40:23
 * @LastEditTime: 2025-06-27 16:06:53
 */
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=222;
ll ct,tot,now,n,m=1,op=1,ans[N];
// n 表示元素的个数，m 表示化学式的个数
string s,t;map<string,ll> p;vector<vector<ll> > ss;
// ss 是栈，存储当前括号里的元素
struct P{// 分数类
    ll fz,fm=1;
    void init(){ll g=__gcd(fz,fm);fz/=g,fm/=g;}
    P operator-(const P& B){return {fz*B.fm-fm*B.fz,fm*B.fm};}
    P operator*(const P& B){return {fz*B.fz,fm*B.fm};}
    P operator/(const P& B){return {fz*B.fm,fm*B.fz};}
    bool operator>(const P& B){return abs(fz)*abs(B.fm)>abs(B.fz)*abs(fm);}
}a[N][N];
ll lcm(ll a,ll b){ll g=__gcd(a,b);return a*b/g;}
void solve(){// 高斯消元
	for(int i=1;i<m;i++){
		ll r=i;
		for(int j=i+1;j<=n;j++) if(a[j][i]>a[r][i]) r=j;
		if(r!=i) swap(a[r],a[i]);
        P t=a[i][i];assert(a[i][i].fz);
		for(int j=1;j<=m;j++) a[i][j]=a[i][j]/t,a[i][j].init();
		for(int j=i-1?1:2;j<=n;j++){
			t=a[j][i];if(j==i) continue;
			for(int k=i;k<=m;k++) a[j][k]=a[j][k]-a[i][k]*t,a[j][k].init();
		}
	}
    ll g=a[1][m].fm;a[m][m]={1,1};
    for(int i=2;i<m;i++) a[i][m].init(),g=lcm(g,a[i][m].fm);
    for(int i=1;i<=m;i++) ans[i]=a[i][m].fz*g/a[i][m].fm;
}
void init(){
    for(int i=0,x;i<s.size();i++)
        if(s[i]=='+') m++;
        else if(s[i]=='=') op=-1,m++;// 系数变成负的
		else if(s[i]=='(') tot++;
		else if(s[i]==')'){// 处理 (AB...C)x
			for(x=0;i+1<s.size()&&'0'<=s[i+1]&&s[i+1]<='9';i++) x=x*10+s[i+1]-'0';
            for(auto y:ss[tot]) ss[tot-1].push_back(y),a[y][m].fz*=x;ss[tot--].clear();
		}else if('A'<=s[i]&&s[i]<='Z'){
			t+=s[i];
            if('a'>s[i+1]||s[i+1]>'z') ss[tot].push_back(now=(p[t]?p[t]:p[t]=++n)),a[now][m].fz=op,t="";
		}else if('a'<=s[i]&&s[i]<='z')
            t+=s[i],ss[tot].push_back(now=(p[t]?p[t]:p[t]=++n)),a[now][m].fz=op,t="";
            // 提取元素
		else{
			for(x=0;i<s.size()&&'0'<=s[i]&&s[i]<='9';i++) x=x*10+s[i]-'0';
			i--;a[now][m].fz*=x;
            // 处理 Ax
		}
    for(int i=1;i<=n;i++) a[i][m].fz=-a[i][m].fz;
}
int main(){
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    cin>>s;ss.resize(N);init();solve();
    for(int i=0,j=1;i<s.size();i++){
        if(!i||s[i-1]=='+'||s[i-1]=='='){
            if(abs(ans[j])!=1) cout<<abs(ans[j]);
            j++;
        }
        cout<<s[i];
    }
    return 0;
}
```

[AC link](https://www.luogu.com.cn/record/221548801)

---

## 作者：undirected_edge (赞：4)

题解的来历：本来想在做化学作业的时候偷懒的，后来真的发现了这道题……

这篇题解会详细一些。

前置知识：原子守恒（化学）、高斯消元

### 1. 为什么是高斯消元

首先本蒟蒻不会打表化合价……因为化合价的种类实在太多，使用化学常规的化合价配平会超级麻烦，这里就不多说了。

那怎么配平呢？**原子守恒**。

根据原子守恒，对于方程式中出现的每一种元素 $R$，都有：

等号左边 $R$ 原子的个数 $=$ 等号右边 $R$ 原子的个数。

如果在未配平的方程式中从左到右，单个第 $i$ 种分子中含有 $a_i$ 个 $R$ 原子，且第 $i$ 种分子在配平的方程式中系数为 $x_i$，那么上面那个式子就可以写成：

$$a_1x_1+a_2x_2+\dots+a_kx_k=a_{k+1}x_{k+1}+\dots+a_nx_n$$

这不就是一个 $n$ 元一次方程嘛。把等号右边的每一项（最后一项除外）移到左边就是：

$$a_1x_1+a_2x_2+\dots+a_kx_k-a_{k+1}x_{k+1}-\dots-a_{n-1}x_{n-1}=a_nx_n$$

设方程式中含 $m$ 种元素，那么同上写出 $m$ 个方程，构成一个方程组。

然后就可以快乐高斯消元，解出所有 $x$ 了。

注：在消元的时候把 $x_n$ 视为一个单位，解 $x_1,x_2 \dots ,x_{n-1}$。

### 2. 如何处理字符串

显然字符串只会由大小写字母、数字、加号、等号和圆括号组成。（没有结晶水所以就没有点咯）

此处，把一个分子中的每一个原子符号及其系数视为“一项”。即使有两个项的原子名称相同（如 `C2H5OH` 中有两项 `H`），也视为不同项，以便判断括号括住了哪些东西。

1. 对于正括号：记录它将从第几项开始括起。

2. 对于大写字母：如果是大写字母，说明出现新的一项。初始系数记得赋值为 $1$。

3. 对于小写字母：与大写字母一起视为一种原子。

4. 对于数字：以如下类似快读代码得到整个数字的值：

```cpp
x=0;
if('0'<=s[i]&&s[i]<='9'){
	while('0'<=s[i]&&s[i]<='9'){
		x=x*10+s[i]-'0';
		++i;
	}
}
```

然后将原子的系数数赋值为 `x`。

5. 对于反括号：先扫描反括号后面紧跟着的数字的大小（假设为 $p$），再从对应的正括号的位置开始，将每一项的原子个数乘以 $p$。

6. 对于加号、等号：对这个分子的扫描结束。如果是等号，那么接下来的原子个数乘上 $-1$（因为要移项）。

例如 `NaI(IO3)4` 在扫描之后会被记录为：

`{'N','a',1},{'I','',1},{'I','',4},{'O','',12}`

全部扫描完毕后再合并同类项。

例如 `NaI(IO3)4` 在合并同类项之后会被记录为：

`{'I','',5},{'N','a',1},{'O','',12}`（按字典序排序）

代码为：

```cpp
	len=strlen(s); 
	for(int i=0;i<len;){
		if(s[i]=='(') z[++tail]=t[n]+1,++i;//第一步
		x=s[i],++i;//第二步
		if(s[i]<='z'&&s[i]>='a') y=s[i],++i;
		else y='z'+1;//第三步
		m=0;
		if('0'<=s[i]&&s[i]<='9'){
			while('0'<=s[i]&&s[i]<='9'){
				m=m*10+s[i]-'0';
				++i;
			}
		}
		else m=1;//第四步
		a[n][++t[n]]={x,y,m};
		if(s[i]==')'){//第五步
			++i;
			m=0;
			if('0'<=s[i]&&s[i]<='9'){
				while('0'<=s[i]&&s[i]<='9'){
					m=m*10+s[i]-'0';
					++i;
				}
				if(m!=1){
					for(int j=z[tail];j<=t[n];++j) a[n][j].cnt*=m;
				}
			}
			z[tail--]=0;
		}
		if(s[i]=='+'||s[i]=='='){//第六步
			++n;
			if(s[i]=='=') anth=n;
			++i;
		}
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=t[i];++j){
			f[i][a[i][j].x-'A'+1][a[i][j].y-'a'+1]+=a[i][j].cnt;//合并
			dic[a[i][j].x-'A'+1][a[i][j].y-'a'+1]=true;//记录方程式中存在这个元素
		}
	}
	m=0;
    for(int i=1;i<=30;++i){//准备高斯消元的矩阵
		for(int j=0;j<=30;++j){
			if(dic[i][j]){
				++m;
				for(int k=1;k<=n;++k){
					if(k<anth||k==n) g[m][k]=f[k][i][j];
					else g[m][k]=-f[k][i][j];
				}
			}
		}
	}
```

### 3. 怎么消元

蒟蒻采用的是高斯-约旦消元法。

这里要进行一个小小的改动（注释在代码里）：

```cpp
	for(int k=1;k<n;++k){
		for(int i=k;i<=m;++i){
			if(g[i][k]){
				for(int j=k;j<=n;++j) swap(g[i][j],g[k][j]);
				break;
			}
		}
		if(!g[k][k]){
			return 0;
		}
		for(int i=1;i<=m;++i){
			if(i==k) continue;
			G=gcd(g[i][k],g[k][k]);
			for(int j=1;j<=n;++j) g[i][j]*=(g[k][k]/G);
			G=g[i][k]/g[k][k];//这里要通分g[i][k]和g[k][k]，让得出的结果仍然是整数
			for(int j=1;j<=n;++j) g[i][j]-=G*g[k][j];
		}
	}
```

### 4. 得出结果

消元之后，会得到一个斜对角矩阵。

以 `P+O2=P2O5` 为例：

消元完毕，会得到矩阵$\begin{bmatrix}
  1&0&2
\\0&2&5
\end{bmatrix}$。

这个矩阵会带给我们什么信息呢？`P` 和 `P2O5` 系数之比为 $2:1$，`O2` 和 `P2O5` 系数之比为 $5:2$。（如果不懂就多想想）

那么 `P2O5` 真正的最简系数就是 $1$ 和 $2$ 的最小公倍数，即 $2$。

将 `P` 和 `O2` 与 `P2O5` 系数之比代入，得到 `P` 系数为 $2\div1\times2=4$，`O2` 的系数为 $2\div2\times5=5$。

得到 `4P+5O2=2P2O5`。

一般地，假设最后消元得到的矩阵是 $\begin{bmatrix}
  a_{1,1}&0&\dots&0&a_{1,n}
\\0&a_{2,2}&\dots&0&a_{2,n}
\\\vdots&\vdots&\ddots&\vdots
\\0&0&\dots&a_{n-1,n-1}&a_{n-1,n}
\end{bmatrix}$，

则可以得到系数关系式：

$$\left\{\begin{array}{c}
  x_1:x_n=a_{1,1}:a_{1,n}
\\x_2:x_n=a_{2,2}:a_{2,n}
\\ \vdots
\\x_{n-1}:x_n=a_{n-1,n-1}:a_{n-1,n}
\end{array}\right.$$

为了将所有系数化成最简整数比，就令 $x_n=\text{lcm}(a_{1,n},a_{2,n},\dots,a_{n-1,n})$，那么第 $i$ $(1 \le i \le n-1)$ 个分子的系数为 $a_{n-1,n-1}\times \frac{x_n}{a_{n-1,n}}$。

这样就得到所有系数了。

然后，将读入的字符串输出，但是输出之前或扫描到加号或者等号的时候要输出系数，如果系数是 $1$ 就省略。

```cpp
	for(int i=1;i<n;++i) G=G/gcd(G,g[i][i])*g[i][i];
	for(int i=1;i<n;++i) ans[i]=g[i][n]*G/g[i][i];
	ans[n]=G,G=0;
	for(i=0;i<len;++i){
		if(ans[++G]>1) cout<<ans[G];
		while(s[i]!='+'&&s[i]!='='&&i<len){
			if(ans[G]) cout<<s[i];
			++i;
		}
		if(i<len&&ans[G]) cout<<s[i];
	}
```

这题就结束了。

### 5.注意

- 读入时要读入一整个字符串，最好别边 `getchar` 边处理。否则可能出现本地AC提交WA的玄学情况。

- 不开 `long long` 见祖宗。

---

## 作者：yuxuzhehuan (赞：2)

# [P2643](https://www.luogu.com.cn/problem/P2643)
## 题目描述
配平已给出的化学方程式。
## 分析
### Step1 思考
这题不太可能用化学方法去解决，那么我们就用最暴力的方法：**待定系数**。

也就是设第 $i$ 个物质前的系数为 $x_i$。

以 $\text{FeCl}_2$ 与 $\text{Cl}_2$ 反应生成 $\text{FeCl}_3$ 为例。
$$
x_1 \text{FeCl}_2+x_2 \text{Cl}_2= x_3 \text{FeCl}_3
$$
由于元素守恒，可以得出以下方程组。
$$
\begin{cases}
x_1=x_3\\
2 \times x_1+2\times x_2=3 \times x_3
\end{cases}
$$
然后发现方程组中无常数项，所以可同除以 $x_3$，令 $\frac{x_1}{x_3}=y_1,\frac{x_2}{x_3}=y_2$。
$$
\begin{cases}
y_1=1\\
2 \times y_1+2\times y_2=3
\end{cases}
$$
然后利用高斯消元求解方程组，最后 $y_i$ 都乘上分母的最小公倍数即可配平方程。
### Step2 实现
此处要使用分数结构和高斯消元，本蒟蒻采用的是高斯-约旦消元。
```cpp
#include<bits/stdc++.h>
using namespace std;
int sl,n,m,o,fl=1,x,mp[27][27],aa[55][55],t,ans[55];
char s[55],ma[55][55];
int gcd(int a,int b){	return b?(a?gcd(b%a,a):b):a;}
struct Q
{	int p,q;
	Q operator =(const Q o){	return p=o.p,q=o.q,x=gcd(p,q),p/=x,q/=x,*this;};
	Q operator +(const Q o){	return {p*o.q+q*o.p,q*o.q};};
	Q operator -(const Q o){	return {p*o.q-q*o.p,q*o.q};};
	Q operator *(const Q o){	return {p*o.p,q*o.q};};
	Q operator /(const Q o){	return {p*o.q,q*o.p};};
	bool operator >(const Q o){	return 1ll*p*o.q*o.q*q>1ll*q*o.p*o.q*q;};
	bool operator ==(const Q o){	return p*o.q==q*o.p;};
}	a[55][55],k,T,A;
inline Q abs(Q o){	return {abs(o.p),abs(o.q)};}
inline int get(int p)
{	p++;
	int x=0;
	if('a'<=s[p]&&s[p]<='z')	p++;
	if(s[p]<'0'||s[p]>'9')	return 1;
	while('0'<=s[p]&&s[p]<='9')	x=x*10+s[p]-'0',p++;
	return x;
}
inline void in(int L,int R)
{	n++,o+=fl;
	for(int i=L;i<=R;i++)	ma[n][i-L]=s[i];
	int t=1;
	for(int i=L,j,x,y;i<=R;i++)
	{	if(s[i]==')')	t=1;
		if(s[i]=='(')
		{	j=i+1;
			while(s[j]!=')')	j++;
			t=get(j);
		}
		if('A'<=s[i]&&s[i]<='Z')
		{	x=s[i]-'A'+1,y=0;
			if('a'<=s[i+1]&&s[i+1]<='z')	y=s[i+1]-'a'+1;
			if(!mp[x][y])	mp[x][y]=++m;
			aa[mp[x][y]][n]+=get(i)*t*(fl?1:-1);
		}
	}
}
signed main()
{	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>s,sl=strlen(s),s[sl]='+';
	for(int i=0,l=0;i<=sl;fl^=(s[i]=='='),i++)	if(s[i]=='+'||s[i]=='=')	in(l,i-1),l=i+1;
	if(m<n-1)	return cout<<"No Solution",0;
	for(int i=1;i<=m;i++)
	{	for(int j=1;j<=max(m,n);j++)	a[i][j].q=1;
		for(int j=1;j<=n;j++)	a[i][j].p=aa[i][j];
		a[i][n].p=-a[i][n].p;
	}
	for(int i=1,p;i<n;i++)
	{	p=0,A={-1,1};
		for(int j=i;j<=m;j++)	if(abs(a[j][i])>A)	A=abs(a[j][i]),p=j;
		if(A==(Q){0,1})	return cout<<"No Solution",0;
		if(p!=i)	for(int j=1;j<=n;j++)	swap(a[i][j],a[p][j]);
		k=a[i][i];
		for(int j=1;j<=n;j++)	a[i][j]=a[i][j]/k;
		for(int j=1;j<=m;j++)	if(i!=j)
		{	k=a[j][i];
			for(int l=1;l<=n;l++)	a[j][l]=a[j][l]-k*a[i][l];
		}
	}
	a[n][n]={1,1},t=a[1][n].q;
	for(int i=1;i<=n;i++)	t=t*a[i][n].q/gcd(t,a[i][n].q);
	for(int i=1;i<=n;i++)	ans[i]=t*a[i][n].p/a[i][n].q;
	for(int i=1;i<=n;i++)
	{	if(ans[i]!=1)	cout<<ans[i];
		cout<<ma[i];
		if(i==o)	cout<<'=';
		else if(i!=n)	cout<<'+';
	}
	return 0;
}
```
此处要注意到可能存在未知数数量大于方程数量的可能，例子为 $2\text{KMnO}_4+5\text{H}_2\text{O}_2+2 \text{H}_2\text{SO}_4=\text{K}_2 \text{SO}_4+\text{MnSO}_4+5\text{O}_2+2\text{H}_2\text{O}$。

---


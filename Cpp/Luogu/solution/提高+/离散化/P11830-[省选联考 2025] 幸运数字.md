# [省选联考 2025] 幸运数字

## 题目描述

小 X 有 $n$ 个正整数二元组 $(a_i, b_i) (1 \leq i \leq n)$。他将会维护初始为空的可重集 $S$，并对其进行 $n$ 轮操作。第 $i (1 \leq i \leq n)$ 轮操作中，他会在 $S$ 中加入 $a_i$ 个 $b_i$。

设 $m = \sum \limits_{i=1}^{n} a_i$，在所有操作结束后，小 X 会得到一个包含 $m$ 个正整数的可重集 $S$。最后他会计算 $S$ 的中位数，即 $S$ 中第 $\left\lfloor \frac{m+1}{2} \right\rfloor$ 小的数，作为他的幸运数字。

想知道小 X 幸运数字的小 Y 不知道这 $n$ 个二元组的具体数值是多少，但她得知了每个数的范围。具体地，对于每个 $1 \leq i \leq n$，小 Y 知道 $a_i \in [l_{i,1}, r_{i,1}]$ 且 $b_i \in [l_{i,2}, r_{i,2}]$。

小 Y 想知道在满足以上条件的情况下，有多少个数可能成为小 X 的幸运数字。

## 说明/提示

**【样例 1 解释】**

该组样例共有 $4$ 组测试数据。
- 对于第一组测试数据，若取 $(a_1, b_1) = (1, 1), (a_2, b_2) = (1, 2)$，则得到 $S = \{1, 2\}$，其中位数为 $1$；若取 $(a_1, b_1) = (2, 1), (a_2, b_2) = (1, 2)$，则得到 $S = \{1, 1, 2\}$，其中位数为 $1$。因此仅有 $1$ 为可能计算出的中位数，因此答案为 $1$。
- 对于第二组测试数据，若取 $(a_1, b_1) = (1, 1), (a_2, b_2) = (1, 2)$，则得到 $S = \{1, 2\}$，其中位数为 1；若取 $(a_1, b_1) = (1, 2), (a_2, b_2) = (1, 3)$，则得到 $S = \{2, 3\}$，其中位数为 $2$。可以证明不存在其他可能计算出的中位数，因此答案为 $2$。
- 对于第三组测试数据，可以证明有且仅有 $1, 2, 3, 4$ 为可能计算出的中位数，因此答案为 $4$。
- 对于第四组测试数据，可以证明有且仅有 $1, 2, 3$ 为可能计算出的中位数，因此答案为 $3$。

**【样例 2】**

见选手目录下的 lucky/lucky2.in 与 lucky/lucky2.ans。

该组样例共有 $60$ 组测试数据，所有数据均满足 $n = 4$。其中测试数据 $1 \sim 20$ 满足特殊性质 AB，测试数据 $21 \sim 40$ 满足特殊性质 A。

**【样例 3】**

见选手目录下的 lucky/lucky3.in 与 lucky/lucky3.ans。

该组样例共有 $4$ 组测试数据，所有数据均满足 $n = 2\,000$。其中测试数据 $1$ 满足特殊性质 AB，测试数据 $2$ 满足特殊性质 A，测试数据 $3$ 满足特殊性质 B。

**【样例 4】**

见选手目录下的 lucky/lucky4.in 与 lucky/lucky4.ans。

该组样例共有 $2$ 组测试数据，所有数据均满足 $n = 2 \times 10^5$。其中测试数据 $1$ 满足特殊性质 A，测试数据 $2$ 满足特殊性质 B。

**【子任务】**

设 $\sum n$ 为单个测试点内所有测试数据的 $n$ 的和。对于所有测试点，
- $1 \leq T \leq 400$，
- $1 \leq n \leq 2 \times 10^5$，$1 \leq \sum n \leq 6 \times 10^5$，
- $\forall 1 \leq i \leq n$，$1 \leq l_{i,1} \leq r_{i,1} \leq 10^9$，$1 \leq l_{i,2} \leq r_{i,2} \leq 10^9$。

::cute-table{tuack}

| 测试点编号 | $n \leq$ | $\sum n \leq$ | 特殊性质 A | 特殊性质 B |
|:------------:|:----------:|:--------------:|:------------:|:------------:|
| $1$  | $4$ | $400$ | 是 | 是 |
| $2$  |  ^  | ^ | ^ | 否 |
| $3$  | $2\,000$ | $10^4$ | ^ | 是 |
| $4$  | ^ | ^ | ^ | 否 |
| $5$  | ^ | ^ | 否 | 是 |
| $6$  | ^ | ^ | ^ | 否 |
| $7$  | $2 \times 10^5$ | $6 \times 10^5$ | 是 | 是 |
| $8$  | ^ | ^ | ^ | 否 |
| $9$  | ^ | ^ | 否 | 是 |
| $10$ | ^ | ^ | ^ | 否 |

- 特殊性质 A：$\forall 1 \leq i \leq n$，$r_{i,1}, r_{i,2} \leq n$。
- 特殊性质 B：$\forall 1 \leq i \leq n$，$l_{i,1} = r_{i,1}$。

## 样例 #1

### 输入

```
0 4
2
1 2 1 1
1 1 2 2
2
1 1 1 2
1 1 2 3
2
1 2 1 2
2 3 3 4
4
1 2 1 4
3 4 1 2
3 4 2 3
3 4 3 4```

### 输出

```
1
2
4
3```

# 题解

## 作者：ran_qwq (赞：52)

考场思路，大样例过了，不知道对不对。

考虑对于一个数 $x$，它能成为中位数需要满足什么条件。

首先肯定要有区间包含它，否则 $x$ 连出现一次都不可能。

然后设如果有 $a$ 个数 $<x$，$b$ 个数 $=x$，$c$ 个数 $>x$，那么必须满足以下两个不等式：

- $a+b\ge c$。如果 $a+b<c$，第 $\lfloor\dfrac{m+1}2\rfloor$ 个数 $>x$。
- $a<b+c$。如果 $a\ge b+c$，第 $\lfloor\dfrac{m+1}2\rfloor$ 个数 $<x$。

有一个贪心策略是如果 $l_{i,2}\le x\le r_{i,2}$，即可以放 $x$，就尽量放 $r_{i,1}$ 个 $x$。因为把非 $x$ 改成 $x$，$a$ 和 $c$ 减小而 $b$ 增大，显然 $x$ 成为中位数可能性变大。而且 $x$ 的个数越多，$a$ 和 $c$ 不变而 $b$ 越大，两个不等式中要求大的那部分，即包含 $b$ 的那部分变大，也是更优的。

现在问题变成 $a$ 和 $c$ 取多少。受到个数的限制，$a$ 和 $c$ 都有个最小值和最大值，$a$ 的取值范围为 $[l,r]$，$c$ 的取值范围为 $[L,R]$。

考虑固定 $a$，求 $c$ 的取值范围。第一个不等式化为 $c\le a+b$，第二个不等式化为 $c>a-b$。联立可得 $c\in[a-b+1,a+b]$。

现在不固定 $a$。$a=l$ 时，$c$ 最小为 $l-b+1$。$a=r$ 时，$c$ 最大为 $r+b$。所以 $c\in[l-b+1,r+b]$。

又因为 $c$ 的取值范围为 $[L,R]$，所以 $c\in[\max(l-b+1,L),\min(r+b,R)]$。

对于 $x$，求出 $b,l,r,L,R$ 之后，若 $c$ 的取值范围非空，即 $\max(l-b+1,L)\le\min(r+b,R)$，则 $x$ 可以作为中位数。$b,l,r,L,R$ 可以枚举每个区间，判断其与 $x$ 的关系来求。

到目前为止期望得分 $50$。

我们的瓶颈在于算出 $b,l,r,L,R$，考虑用差分前缀和优化这一过程。具体来讲，一个区间 $[l_{i,2},r_{i,2}]$，会对 $[l_{i,2},r_{i,2}]$ 的 $b$ 产生 $r_{i,1}$ 的贡献，对 $(r_{i,2},\infty)$ 的 $l$ 产生 $l_{i,1}$ 的贡献，对 $(r_{i,2},\infty)$ 的 $r$ 产生 $r_{i,1}$ 的贡献，对 $[1,l_{i,2})$ 的 $L$ 产生 $l_{i,1}$ 的贡献，对 $[1,l_{i,2})$ 的 $R$ 产生 $r_{i,1}$ 的贡献。而 $x$ 能否成为中位数只与 $b,l,r,L,R$ 有关，即如果没有跨过任何区间，不改变 $x$ 能否成为中位数。

所以我们可以对由区间左右端点划分而成的一段进行计算，用前缀和算出 $b,l,r,L,R$ 即可。

需要排序+离散化，时间复杂度 $O(n\log n)$。

可以通过民间数据的代码：

```cpp
int n,ln,cf,as,l1[N],r1[N],l2[N],r2[N],dc[N*2],f[N*2];
ll ca,cb,cc,cd,ce,a[N*2],b[N*2],c[N*2],d[N*2],e[N*2];
void QwQ() {
	n=rd();
	for(int i=1;i<=ln;i++) a[i]=b[i]=c[i]=d[i]=e[i]=f[i]=0;
	ln=ca=cb=cc=cd=ce=cf=as=0;
	for(int i=1;i<=n;i++)
		l1[i]=rd(),r1[i]=rd(),l2[i]=rd(),r2[i]=rd(),
		dc[++ln]=l2[i],dc[++ln]=r2[i]+1;
	sort(dc+1,dc+1+ln),ln=unique(dc+1,dc+1+ln)-dc-1;
	for(int i=1,x,y;i<=n;i++)
		x=lb(dc+1,dc+1+ln,l2[i])-dc,y=lb(dc+1,dc+1+ln,r2[i]+1)-dc,
		a[x]+=r1[i],a[y]-=r1[i],
		b[y]+=l1[i],c[y]+=r1[i],
		d[1]+=l1[i],d[x]-=l1[i],
		e[1]+=r1[i],e[x]-=r1[i],
		f[x]++,f[y]--;
	for(int i=1;i<ln;i++) {
		ca+=a[i],cb+=b[i],cc+=c[i],cd+=d[i],ce+=e[i],cf+=f[i];
		if(cf&&max(cb-ca+1,cd)<=min(cc+ca,ce)) as+=dc[i+1]-dc[i];
	}
	wr(as,"\n");
}
```

---

## 作者：CaiZi (赞：18)

签到题，但是这个蒟蒻签到签了快 $4$ 个小时。你猜为什么题解里面有一处注意，因为这个蒟蒻被这个地方硬控了 $3$ 小时，推翻了代码若干次。

首先考虑一个数 $w$ 可以成为中位数的条件，记 $<w$ 的数字个数为 $x$，$w$ 的个数为 $y$，$>w$ 的数字个数为 $z$。那么需要满足：
- 若 $x\ge z$，则 $x-z<y$。
- 若 $x<z$，则 $z-x\le y$。
- $y\ne0$。

这个的证明是容易的，你分类讨论一下手玩就好了。

然后考虑暴力。考虑枚举每一个可以作为中位数的数 $w$（**注意一定要 $\exists i,w\in[l_{i,2},r_{i,2}]$，否则答案会偏大**）。由上面的性质可以知道，如果 $w\in[l_{i,2},r_{i,2}]$，那么一定要令 $a_i=r_{i,1},b_i=w$，因为你让 $y$ 尽量大，在两种情况下都一定是更优的。否则，一定有 $r_{i,2}<w$ 或者 $l_{i,2}>w$，因此：
$$x\in[\sum_{r_{i,2}<w}l_{i,1},\sum_{r_{i,2}<w}r_{i,1}],y=\sum_{w\in[l_{i,2},r_{i,2}]}r_{i,1},z\in[\sum_{l_{i,2}>w}l_{i,1},\sum_{l_{i,2}>w}r_{i,1}]$$
分类讨论一下，如果 $x,z$ 能取同一个值 $w$ 肯定可以为中位数，否则尽量让 $x,z$ 接近，判断能否使 $w$ 为中位数。

枚举是 $O(V)$ 的，上述 check 是 $O(n)$ 的，考虑优化，这里貌似有很多方法，这里讲一个最简单的方法。

我们发现我们只关心某个数和你枚举的数的相对大小，同时你枚举数字时，如果 $\{i|w\in[l_{i,2},r_{i,2}]\}$ 相同，那么两个 $w$ 是完全一致的。因此考虑离散化，将所有的 $l_{i,2},r_{i,2}$ 丢进去排序。但是注意这里的离散化不太一样，因为离散化后，你的 $w$ 除了可以取这里面的某一个数，也有可能取这里面某两个相邻的数之间的数，某两个相邻的数之间的数只要有一个满足条件，其余就都可以满足条件，因此只需要保留任意一个即可。

此时时间复杂度就是 $O(n^2)$ 的了。接下来很简单，考虑预处理各种东西，使用前缀和 $O(1)$ 求出 $x,y,z$。

时间复杂度 $O(\sum n\log n)$。是正确的，但是本人代码常数实在太大，而且对于在做这题的人，这个过程应该是较为容易的，所以在此不放代码。

---

## 作者：篮网总冠军 (赞：18)

第一次参加省选。

作为一个 $1$ 年 C 初二的学生，我已经第三次场切蓝啦！连续 $3$ 次！

不吹了，我们讲题（只过了 T1）。

我们可以发现，这题满足一定单调性，手推即可。

什么叫**一定单调性**呢？

我们注意到，有的数可能出现在范围中，但是，**它不会被取到！**

也就是所有的 $l_{i,2} \sim r_{i,2}$ 中都不会出现！

排除掉就好了。

当你求出一个符合要求的区间后，你只需要对所有 $l_{i,2} , r_{i,2}$ 进行区间合并即可啊。

求出每个合并后的区间与求出区间的重叠部分，加上。

好，我们来讲怎么求区间。

首先，我们需要在 $1 \sim 10^9$ 中找到一个**最小的**符合当极限贪心时，比它小的数满足它可以成为中位数的条件。

接着，我们需要在 $1 \sim 10^9$ 中找到一个**最大的**符合当极限贪心时，比它大的数满足它可以成为中位数的条件。

具体代码见下。

然后，我们就可以求出像上面所述的区间了。

考场拿下民间数据的代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

struct node{
	long long l1,r1,l2,r2;
}a[200005];
int n;
bool cmp(node x,node y){
	if (x.l2==y.l2) return x.r2<y.r2;
	return x.l2<y.l2;
}
bool check(long long x){
	long long s1=0,s2=0;
	for(int i=1;i<=n;i++){
		if (a[i].l2>x) s2+=a[i].l1;
		else s1+=a[i].r1;
	}
	if ((s1+s2)%2==0) return s1>=s2;
	else return s1>=(s2+1);
}
bool check2(long long x){
	long long s1=0,s2=0;
	for(int i=1;i<=n;i++){
		if (a[i].r2<x) s1+=a[i].l1;
		else s2+=a[i].r1;
	}
	if ((s1+s2)%2==0) return s2>=s1+2;
	else return s2>=s1+1;
}
int main(){
	freopen("lucky.in","r",stdin);
	freopen("lucky.out","w",stdout);
	ios::sync_with_stdio(false);
	int c,t;
	cin>>c>>t;
	while(t--){
		cin>>n;
		long long maxk;
		for(int i=1;i<=n;i++){
			cin>>a[i].l1>>a[i].r1>>a[i].l2>>a[i].r2;
			maxk=max(a[i].r2,maxk);
		}
		long long l1=maxk,r1=0;
		while(l1>r1){
			long long mid=(l1+r1-1)/2;
			if (check(mid)) l1=mid;
			else r1=mid+1;
		}
		long long l2=0,r2=maxk;
		while(l2<r2){
			long long mid=(l2+r2+1)/2;
			if (check2(mid)) l2=mid;
			else r2=mid-1;
		}
		sort(a+1,a+1+n,cmp);
		long long s1=a[1].l2,s2=a[1].r2;
		long long ans=0;
		for(int i=2;i<=n;i++){
			if (a[i].l2<=s2) s2=max(s2,a[i].r2);
			else{
				if (s2>=l2&&s1<=l2) ans=ans+(l2-max(s1,l1)+1);
				else if (s2<=l2&&s2>=l1)ans=ans+(s2-max(s1,l1)+1);
				s1=a[i].l2,s2=a[i].r2;
			}
		}
		if (s2>=l2&&s1<=l2) ans=ans+(l2-max(s1,l1)+1);
		else if (s2<=l2&&s2>=l1)ans=ans+(s2-max(s1,l1)+1);
		cout<<ans<<endl;
	}	
	return 0;
}

---

## 作者：LinkCatTree (赞：12)

场切但是花了两个多小时……我是飞屋。

这题中性质 A 很重要，可以直接得出最终的做法。我们先考虑对于一个数 $x$，如何判断这个数是否能够成为“幸运数”，这是比较简单的：如果第 $i$ 个二元组能够取到 $x$，那么就尽量多取 $x$；否则我们记录比 $x$ 小（或比 $x$ 大）的数的个数的范围。

假设有 $[lc_0,lc_1]$ 个数一定比 $x$ 小，$[rc_0,rc_1]$ 个数一定比 $x$ 大，那么我们尽量从这两个范围中取出相近的数，这样显然更能够让 $x$ 成为幸运数。具体可见代码：

```cpp
bool check(int x) {
	// ...
	if(lc[1]>=rc[0]&&lc[0]<=rc[1]) return true;
	for(int i=0;i<2;i++)
		for(int j=0;j<2;j++) {
			ll middle=(lc[i]+xc+rc[j]+1)/2;
			if(lc[i]<middle&&lc[i]+xc>=middle) return true;
		}
	return false;
}
```

然后我们就可以得出性质 A 下的 $\mathcal{O}(n \times r)$ 的做法（枚举“幸运数”）。我们发现这是可以优化的，因为每个二元组在枚举中都是从 $>x$ 到 $=x$ 再到 $<x$ 的过程，我们可以记录什么时候枚举的 $x$ 进入 $[l_{i,2},r_{i,2}]$ 这一区间以及什么时候枚举的 $x$ 再离开 $[l_{i,2},r_{i,2}]$，这样均摊时间复杂度就可以 $\mathcal{O}(n+r)$ 完成。

这时候我们发现 $r$ 的范围过大就不行了，于是很自然地想到离散化，这样就做完了。

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int read() {
	int x=0,ch=getchar(),minus=0;
	for(;ch<'0'||ch>'9';ch=getchar()) minus|=(ch=='-');
	for(;ch>='0'&&ch<='9';ch=getchar()) x=x*10+(ch^48);
	return minus?-x:x;
}

const int N=2e5+5;
typedef long long ll;
int c,T,n,m,tp[N<<1];
vector<int> in[N<<1],out[N<<1];
ll lc[2],rc[2],xc;
struct Number {
	int l[2],r[2];
	Number()=default;
} a[N];

int main() {
	c=read(),T=read();
	while(T--) {
		n=read(),lc[0]=rc[0]=lc[1]=rc[1]=xc=m=0;
		for(int i=1;i<=n;i++) {
			a[i].l[1]=read(),a[i].r[1]=read();
			a[i].l[0]=read(),a[i].r[0]=read();
			tp[++m]=a[i].l[0],tp[++m]=a[i].r[0]+1; // 注意这里是 r+1 而非 r
			rc[0]+=a[i].l[1],rc[1]+=a[i].r[1];
		}
		sort(tp+1,tp+1+m),m=unique(tp+1,tp+1+m)-tp-1,tp[m+1]=tp[m]+1;
		for(int i=1;i<=m;i++) in[i].clear(),out[i].clear();
		for(int i=1;i<=n;i++) {
			a[i].l[0]=lower_bound(tp+1,tp+1+m,a[i].l[0])-tp;
			a[i].r[0]=lower_bound(tp+1,tp+1+m,a[i].r[0]+1)-tp;
			in[a[i].l[0]].push_back(i),out[a[i].r[0]].push_back(i); // 记录 x 进入区间与离开区间时的值
		}
		int ans=0;
		for(int i=1;i<=m;i++) {
			for(auto j:in[i]) rc[0]-=a[j].l[1],rc[1]-=a[j].r[1],xc+=a[j].r[1]; // x 进入区间，把它的贡献从 rc 中删掉
			for(auto j:out[i]) lc[0]+=a[j].l[1],lc[1]+=a[j].r[1],xc-=a[j].r[1]; // x 离开区间，把它的贡献加入 lc
			if(!xc) continue ;
			int add=0;
			if(lc[1]>=rc[0]&&lc[0]<=rc[1]) add=1;
			for(int i=0;i<2;i++)
				for(int j=0;j<2;j++) {
					ll middle=(lc[i]+xc+rc[j]+1)/2;
					if(lc[i]<middle&&lc[i]+xc>=middle) add=1;
				}
			ans+=add*(tp[i+1]-tp[i]);
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

最终时间复杂度为 $\mathcal{O}(qn \log_2 n)$。

---

## 作者：cosf (赞：12)

提供一个较为简便的做法。

我们先考虑判断一个数 $x$ 是否能成为中位数。

首先，如果某个 $b$ 能成为 $m$，那它必然选 $m$。否则我们可以根据它的大小将它分为小部分和大部分。具体的，我们令 $[l_s, r_s]$ 表示必然小于 $m$ 的数个数的范围，$c_m$ 表示 $x$ 的最大个数，$[l_u, r_u]$ 表示必然大于 $m$ 的数个数的范围。

令 $f(a, b, c)$ 表示，$a$ 个 $-1$、$b$ 个 $0$ 和 $c$ 个 $1$ 的中位数。则，如果 $c_m$ 非 $0$ 并且 $f(l_s, c_m, r_u) = 0$ 或 $f(r_s, c_m, l_u) = 0$ 或 $f(l_s, c_m, r_u) \not= f(r_s, c_m, l_u)$，则 $m$ 可以成为中位数。

前两者显然，对于最后一个，$f(l_s, c_m, r_u) = 1, f(r_s, c_m, l_u) = -1$，由于 $a$ 和 $c$ 可以取 $[l_s, r_s], [l_u, r_u]$ 中的任意整数，所以必然存在一个 $a, c$ 使得 $f(a, c_m, c) = 0$，于是 $m$ 可以成为中位数。

接下来就是从 $m$ 转移到 $m + 1$ 了。注意到，假设一个数的区间为 $[b_l, b_r]$，个数为 $[a_l, a_r]$，则它对 $l_s, r_s, c_m, l_u, r_u$ 的贡献只会在 $b_l$ 和 $b_{r} + 1$ 改变。具体的，初始时 $l_s = r_s = c_m = 0, l_u = \sum a_l, r_u = \sum a_r$，当 $m$ 变为 $b_l$ 时，让 $l_u \overset{-}{\gets} a_l, r_u \overset{-}{\gets} a_r, c_m \overset{+}{\gets} a_r$ 即可。$m$ 变为 $b_{r} + 1$ 同理。

于是可以发现只有在所有 $b_l$ 和 $b_{r} + 1$ 才有改变，离散化一下即可。

最后就是 $O(n\log n)$ 的，瓶颈在于离散化。代码也非常短。

```cpp
// 赛后重写
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

#define MAXN 200005

using ll = long long;

int n;

struct Rng
{
    ll l, r;
} a[MAXN], b[MAXN];

ll c[MAXN << 1];

vector<Rng> ad[MAXN << 1], de[MAXN << 1];

int cal(ll a, ll b, ll c)
{
    ll m = (a + b + c + 1) / 2;
    if (a >= m)
    {
        return -1;
    }
    if (a + b >= m)
    {
        return 0;
    }
    return 1;
}

bool calc(Rng l, ll m, Rng r)
{
    int s = cal(l.l, m, r.r), t = cal(l.r, m, r.l);
    return m && (s == 0 || t == 0 || s != t);
}

void solve()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i].l >> a[i].r >> b[i].l >> b[i].r;
        c[2 * i - 1] = b[i].l;
        c[2 * i] = b[i].r + 1;
    }
    sort(c + 1, c + 2 * n + 1);
    int idx = unique(c + 1, c + 2 * n + 1) - c - 1;
    Rng l{0, 0}, r{0, 0};
    ll m = 0;
    for (int i = 1; i <= n; i++)
    {
        b[i].l = lower_bound(c + 1, c + idx + 1, b[i].l) - c;
        b[i].r = lower_bound(c + 1, c + idx + 1, b[i].r + 1) - c;
        ad[b[i].l].push_back(a[i]);
        de[b[i].r].push_back(a[i]);
        r.l += a[i].l, r.r += a[i].r;
    }
    ll res = 0;
    for (int i = 1; i <= idx; i++)
    {
        for (auto [u, v] : ad[i])
        {
            m += v;
            r.l -= u, r.r -= v;
        }
        for (auto [u, v] : de[i])
        {
            m -= v;
            l.l += u, l.r += v;
        }
        if (calc(l, m, r))
        {
            res += c[i + 1] - c[i];
        }
        ad[i].clear();
        de[i].clear();
    }
    cout << res << endl;
}

int main()
{
    int t;
    cin >> t >> t;
    while (t--)
    {
        solve();
    }
    return 0;
}

```

---

## 作者：wangif424 (赞：10)

蒟蒻的最后一次省选了……

## 做法

看到中位数想到二分答案。

我们假设值域是连续的，那么能取到的中位数一定是一个连续的区间，我们可以二分这个区间。

而实际区间中间课能会有断开，不过这不影响我们去二分它。

具体的，我们做两次二分，分别二分左右端点：

- 对于左端点，我们二分最小的 $x$，使得小于等于 $x$ 的数中存在数字可以作为中位数。

- 对于右端点，我们二分最大的 $x$，使得大于等于 $x$ 的数中存在数字可以作为中位数。

考虑 `check`，我们记录大于等于小于 $x$ 的数都分别选多少个。如果能选到等于 $x$ 的，那么一定令其等于 $x$；否则，我们视情况选择最多或最少的数量。

现在我们得到了最大和最小的中位数都是多少，但中间有一些取不到的数字，不过这是好做的，简单的区间交并就可以解决。

## AC 代码

```cpp
#include <bits/stdc++.h>
#define R(x) x = read()
#define int long long
using namespace std;
char pbuf[1<<20], *pp=pbuf;
inline void push(const char &c){(pp-pbuf==1<<20)?fwrite(pbuf,1,1<<20,stdout),pp=pbuf,*pp++=c:*pp++=c;}
class io {public:~io() {fwrite(pbuf, 1, pp - pbuf, stdout);}} _;
inline void write(int x) {
	x<0&&(push('-'),x=-x);
	static int sta[60]={},top=0;
	do{sta[top++]=x%10,x/=10;}while(x);
	while(top)push(sta[--top]^'0');
}
#ifndef LOCAL
	char buf[1<<23],*p1=buf,*p2=buf;
	#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
inline int read() {
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){ch=='-'&&(f=-1);ch=getchar();}
    while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
    return x*f;
}
constexpr int N=2e5+100;
int c,T;
int n;
struct node{
	int la,ra,lb,rb;
}v[N];
bool checkr(int x){
	int ll,rl,nx,lg,rg;
	ll=rl=nx=lg=rg=0;
	for(int i=1;i<=n;i++){
		if(v[i].lb<=x&&x<=v[i].rb)nx+=v[i].ra;
		if(x<v[i].lb)lg+=v[i].la,rg+=v[i].ra;
		if(x>v[i].rb)ll+=v[i].la,rl+=v[i].ra;
	}
//	cerr << x << ':' << ll << ' ' << nx << ' ' << rg << '\n';
	return ll<(ll+nx+rg+1)/2;
}
bool checkl(int x){
	int ll,rl,nx,lg,rg;
	ll=rl=nx=lg=rg=0;
	for(int i=1;i<=n;i++){
		if(v[i].lb<=x&&x<=v[i].rb)nx+=v[i].ra;
		if(x<v[i].lb)lg+=v[i].la,rg+=v[i].ra;
		if(x>v[i].rb)ll+=v[i].la,rl+=v[i].ra;
	}
	return rl+nx>=(rl+nx+lg+1)/2;
}
set<pair<int,int> >s;
vector<pair<int,int> >vec;
signed main(){
	R(c);R(T);
	while(T--){
		R(n);
		for(int i=1;i<=n;i++){
			R(int la),R(ra),R(lb),R(rb);
			v[i]={la,ra,lb,rb};
		}
		int l,r;
		l=1,r=1e9;
		int ansr=1;
		while(l<=r){
			int mid=(l+r)>>1;
			if(checkr(mid))ansr=mid,l=mid+1;
			else r=mid-1;
		}
		l=1,r=1e9;
		int ansl=1e9;
		while(l<=r){
//			cerr << l << ' ' << r << '\n';
			int mid=(l+r)>>1;
			if(checkl(mid))ansl=mid,r=mid-1;
			else l=mid+1;
//			cerr << ansl << '\n';
		}
//		cerr << ':' << ansl << ' ' << ansr << ' ' << ansr-ansl+1 << '\n';
		s.clear();
		vec.clear();
		for(int i=1;i<=n;i++){
			int l=v[i].lb,r=v[i].rb;
			if((l<=ansl&&ansl<=r)||(l<=ansr&&ansr<=r)||(ansl<=l&&r<=ansr)||(l<=ansl&&r<=ansr)){
				vec.emplace_back(max(l,ansl),min(r,ansr));
			}
		}
		sort(vec.begin(),vec.end(),[](pair<int,int> i,pair<int,int> j){
			if(i.first!=j.first)return i.first<j.first;
			return i.second>j.second;
		});
		int ll=vec[0].first,rr=vec[0].second;
		for(int i=0;i<vec.size();i++){
			int l=vec[i].first,r=vec[i].second;
			if((l<=ll&&ll<=r)||(l<=rr&&rr<=r)||(l<=ll&&rr<=r)||(ll<=l&&r<=rr)){
				ll=min(ll,l);
				rr=max(rr,r);
			}else{
				s.emplace(ll,rr);
				ll=l,rr=r;
			}
		}
		s.emplace(ll,rr);
		int ans=0;
		for(auto i:s){
//			cerr << i.first << ' ' << i.second << '\n';
			ans+=(i.second-i.first+1);
		}
		write(ans);push('\n');
	}
    return 0;
}
```

---

## 作者：xxr___ (赞：10)

### 前言
签到签了两个小时。
### 思路
首先我们考虑枚举答案的做法，考虑如何判断一个数是否可以作为答案。
#### 分析一下：
- 首先我们令 $l_{i,1}$ 表示小于 $x$ 的数最少有多少个，用 $r_{i,1}$ 表示小于 $x$ 的数最多有多少个，注意，这里小于 $x$ 当且仅当存在 $j\in [1,n]$ 使得 $R_{j,2} < x$。
- 首先我们令 $l_{i,2}$ 表示大于 $x$ 的数最少有多少个，用 $r_{i,2}$ 表示大于 $x$ 的数最多有多少个，注意，这里小于 $x$ 当且仅当存在 $j\in [1,n]$ 使得 $L_{j,2} > x$。
- 令 $k$ 表示可以取到的 $x$ 的最多的数量，根据人类直觉，显然我们如果想让中位数为 $x$ 那么能取到 $x$ 的都取 $x$ 不劣。

那么知道了这些，如果 $k=0$ 那么肯定不合法，因为你都取不到 $x$。

如果 $l_{i,1},r_{i,1},l_{i,2},r_{i,2}$ 存在交集，那么说明什么？说明我们肯定可以取到一个 $K$ 满足大于 $x$ 与小于 $x$ 的数都等于 $K$。这样我们在中间插入一堆 $x$ 肯定 $x$ 就是中位数了。

否则我们把他们放到数轴上，肯定是两两互不相交的线段，我们假设 $l_{i,1}<l_{i,2}$ 此时 $r_{i,1}<r_{i,2}$ 这个时候我们取 $r_{i,1}$ 与 $l_{i,2}$ 分别作为大于 $x$ 与小于 $x$ 的数的个数，因为这样才能最有可能让 $x$ 成为中位数，我们特判一下看看中位数的位置能不能取到就可以了。

这样显然判断一次是 $O(n)$ 的，但是我们发现我们可以将原数组 $L_{i,2}$ 和 $R_{i,2}$ 排个序，这样我们的取值就是一段前缀或者后缀，就能二分在 $O(\log n)$ 的时间复杂度单次判断了。

这样做是 $O(\max R_{i,2}\log n)$ 的，能过特殊性质A。

然后我们发现有用的取值实际上只有 $L_{i,2},R_{i,2}$ 的，形象点就是假设一个数能被选，那么离散化后，这个点对应的两个离散化后的点中间的所有点都可以选，因为要么离散化后区间都能选，要么都不能选。所以我们可以特判离散化后每个点下一个点是否可以作为中位数，如果可以，那么这个点和下一个点中间的区间都能选，显然这样是 $O(n\log n)$ 的，可以通过。

注意，我们还要特判一下离散化后某个点的下一个位置是否存在于一个 $j\in [1,n]$ 满足 $L_{i,2}\leq x\leq R_{i,2}$，这个我们用差分维护就行。

### 通过民间数据的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define rep(i,l,r) for(int i=(l);i<=(r);++i)
#define pre(i,l,r) for(int i=(l);i>=(r);--i)
const int N=4e5+5;
int li[N],cnt=0,l[N/2],r[N/2],ll[N/2],rr[N/2],n,t,c;
struct node{
	int u,v,w;
}p[N/2],q[N/2];
int Ll[N/2],Rr[N/2],sum[N/2][3],su[N/2][3],cha[N];
bool operator<(const node&x,const node&y){
	return x.w<y.w;
}
bool cov(int x,int y,int X,int Y){
	if(x>X){
		swap(X,x);swap(y,Y);
	}
	if(X<=y) return 1;
	return 0;
}
bool check(int x){
	int pos=lower_bound(Rr+1,Rr+n+1,x)-Rr-1;
	int qos=upper_bound(Ll+1,Ll+n+1,x)-Ll-1;
	int ql=su[pos][0],qr=su[pos][1];
	int pl=sum[n][0]-sum[qos][0],pr=sum[n][1]-sum[qos][1];
	int k=sum[n][1]-pr-qr;
	if(!k) return 0;
	if(cov(ql,qr,pl,pr)) return 1;
	if(qr<pl){
		int mid=(qr+pl+k+1)/2;
		if(mid>qr&&mid<=qr+k) return 1;
	}
	if(pr<ql){
		int mid=(pr+ql+k+1)/2;
		if(mid>ql&&mid<=ql+k) return 1;
	}
	return 0;
}
void solve(){
	cin>>n;
    cnt=0;
	rep(i,1,n) cin>>l[i]>>r[i]>>ll[i]>>rr[i];
	rep(i,1,n) li[++cnt]=ll[i],li[++cnt]=rr[i];
	sort(li+1,li+cnt+1);
	cnt=unique(li+1,li+cnt+1)-li-1;
	rep(i,1,n) p[i]={l[i],r[i],ll[i]},q[i]={l[i],r[i],rr[i]};
	sort(p+1,p+n+1);sort(q+1,q+n+1);
	rep(i,1,n) Ll[i]=p[i].w,Rr[i]=q[i].w,sum[i][0]=p[i].u,sum[i][1]=p[i].v,su[i][0]=q[i].u,su[i][1]=q[i].v;
	rep(i,1,n) rep(j,0,1) sum[i][j]+=sum[i-1][j],su[i][j]+=su[i-1][j];
	rep(i,1,n){
		int L=lower_bound(li+1,li+cnt+1,ll[i])-li;
		int R=lower_bound(li+1,li+cnt+1,rr[i])-li;
		cha[L]++;cha[R]--;
	}
	rep(i,1,cnt) cha[i]=cha[i]+cha[i-1];
	int ans=0;
	rep(i,1,cnt){
		if(check(li[i])){
			++ans;
			if(i<cnt&&cha[i]&&check(li[i]+1)){
				ans+=li[i+1]-li[i]-1;
			}
		}
	}
	cout<<ans<<'\n';
}
int32_t main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	cin>>c>>t;
	while(t--){
		solve();
	}
	
	return 0;
}
//tomxi
```

---

## 作者：Redshift_Shine (赞：9)

## 前言

明天，就是终点了。

我的记忆将会被重置。

经过 4 个月“腐蚀”的我，还能拥有现在的实力吗？

又或者，我在已经在“那场挑战”中败下阵来，失去自身的灵魂，成为流水线上的一个零件？

## 题解

按照 NOIP T1 的经验教训，我们要在可行的前提下尽可能将解法想简单。

实际上，容易发现，为了让一个数 $x$ 有更大的概率成为中位数，我们需要干的事情是：

1. 让 $x$ 尽可能多。
2. 让小于 $x$ 的数和大于 $x$ 的数的**数量差**尽可能小。

而由于 $n$ 的值域（$2\times 10^5$）相对于 $x$ 的值域（$10^9$）很小，不难发现在很多个 $x$ 中，不同信息对于对应情况的贡献都是一样的。

那么可以离散化处理。

对于每个数 $x$，可以通过以下方式判断其是否可以成为中位数：

1. 令所有信息中值域区间包含 $x$ 的全部变成 $x$，数量取最大值。
2. 记录所有只能小于/大于 $x$ 的数的数量的最小值和最大值。
3. 进行分类讨论：
	1. 若 $x$ 的出现次数为 $0$，则 $x$ 无法成为最大值。
	2. 计算小于/大于 $x$ 的数的数量的最小差值 $t$。**此处的 $t$ 的计算方式是小于减去大于**。
	3. 若 $t=0$，则 $x$ 可以成为中位数。
	4. 若 $t<0$，且 $-t$ 小于 $x$ 的最大出现次数，则 $x$ 可以成为中位数。
	5. 若 $t>0$，且 $t$ **不大于** $x$ 的最大出现次数，则 $x$ 可以成为中位数。
	6. 否则，$x$ 不能成为中位数。

上述过程中用到的各个变量显然可以在将 $x$ 增大的过程中动态维护，所以，该解法的时间复杂度为 $O(n\log n)$。

**注意：下方代码在分类讨论第 $2$ 到 $5$ 步的处理略有不同**。

## 代码
```c++
// #define Redshift_Debug
#ifdef Redshift_Debug
#define debug(...) fprintf(stderr, __VA_ARGS__)
#include <chrono>
#else
#define debug(...)
#endif
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <utility>
#include <vector>
using namespace std;
const int N = 4e5 + 10;
int c;
int n, v[N], idx, res;
struct st
{
	int nm_l, nm_r, va_l, va_r;
};
st dtb[N];
using pii = pair<int, int>;
vector<pii> cid[N];
using ll = long long;
ll lft_l, lft_r, rgt_l, rgt_r, curv;
template <typename _Tp> inline void read(_Tp &x)
{
	static char ch;
	while (ch = getchar(), !isdigit(ch))
		;
	x = (ch ^ 48);
	while (ch = getchar(), isdigit(ch))
		x = (x << 3) + (x << 1) + (ch ^ 48);
}
template <typename _Tp, typename... _Args> inline void read(_Tp &x, _Args &...args)
{
	read(x);
	read(args...);
}
void init_global()
{
}
void init_local()
{
	res = 0;
	read(n);
	for (int i = 1; i <= idx; i++)
		cid[i].clear();
	idx = 0;
	for (int i = 1; i <= n; i++)
	{
		read(dtb[i].nm_l, dtb[i].nm_r, dtb[i].va_l, dtb[i].va_r);
		v[++idx] = dtb[i].va_l;
		v[++idx] = dtb[i].va_r + 1;
	}
}
bool check()
{
	if (!curv)
		return false;
	if (!(lft_r < rgt_l or rgt_r < lft_l))
		return true;
	if (lft_l + curv >= rgt_r and lft_l < ((lft_l + curv + rgt_r + 1) >> 1))
		return true;
	if (lft_r < curv + rgt_l and rgt_l <= lft_r + curv + rgt_l - ((lft_r + curv + rgt_l + 1) >> 1))
		return true;
	return false;
}
void run()
{
	lft_l = lft_r = rgt_l = rgt_r = curv = 0;
	sort(v + 1, v + idx + 1);
	idx = unique(v + 1, v + idx + 1) - v - 1;
	for (int i = 1; i <= n; i++)
	{
		dtb[i].va_l = lower_bound(v + 1, v + idx + 1, dtb[i].va_l) - v;
		dtb[i].va_r = lower_bound(v + 1, v + idx + 1, dtb[i].va_r + 1) - v;
		cid[dtb[i].va_l].emplace_back(1, i);
		cid[dtb[i].va_r].emplace_back(-1, i);
	}
	for (int i = 1; i <= n; i++)
	{
		rgt_l += dtb[i].nm_l, rgt_r += dtb[i].nm_r;
	}
	for (int i = 1; i <= idx; i++)
	{
		if (check())
			res += v[i] - v[i - 1];
		for (auto &j : cid[i])
		{
			if (~j.first)
			{
				rgt_l -= dtb[j.second].nm_l, rgt_r -= dtb[j.second].nm_r;
				curv += dtb[j.second].nm_r;
				continue;
			}
			curv -= dtb[j.second].nm_r;
			lft_l += dtb[j.second].nm_l, lft_r += dtb[j.second].nm_r;
		}
	}
	printf("%d\n", res);
}
int main()
{
#ifdef Redshift_Debug
	auto st = chrono::high_resolution_clock::now();
#endif
	int T = 1;
	read(c, T);
	init_global();
	while (T--)
	{
		init_local();
		run();
	}
#ifdef Redshift_Debug
	auto ed = chrono::high_resolution_clock::now();
	fprintf(stderr, "%.9lf\n", (ed - st).count() / 1e9);
#endif
}
```

---

## 作者：ykzzldz (赞：8)

若值域连续，容易发现，可能的答案为一段区间。对于值域不连续的情况，我们可以先求出可能答案的最小值和最大值，再与值域区间取并即可。

考虑二分区间的两个端点，这里以左端点为例。我们二分一个 $x$，考虑左端点能不能**小于等于** $x$。大家可以先阅读下面的代码，其中 $L$ 表示可以小于等于 $x$ 的数的数量的最大值，$R$ 表示必须大于 $x$ 的数的数量的最小值。

```cpp
int check1(int x){
    int L=0,R=0;
    for(int i=1;i<=n;i++){
        if(ll[i]>x)R+=l[i];
        else L+=r[i];
    }
    if(L>=R)return 1;
    return 0;
}
```

我们发现，若一个区间包含了 $x$ 或小于 $x$，对答案都是有利的，所以我们对这部分区间放置尽可能多的数，当一个区间的左端点都大于 $x$，此时对答案不利，我们尽可能放置少的数。最后，我们只要判断这两部分数谁更多即可，若可能小于等于 $x$ 的数的数量大于等于一定大于 $x$ 的数的数量，就说明存在小于等于 $x$ 的左端点。右端点是类似的，只需要把最后判断的大于等于改成大于即可（因为中位数在偶数个的时候是去中间前面的那个数）。

最后，我们只要判断备选区间中的哪些数可能被取到即可。这里是简单的，只需要将给出的区间按左端点排序，然后判断一下两个区间是否有交集即可。下面给出考场代码：


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+10;
int c,T,n,l[N],r[N],ll[N],rr[N];
int check1(int x){
    int L=0,R=0;
    for(int i=1;i<=n;i++){
        if(ll[i]>x)R+=l[i];
        else L+=r[i];
    }
    if(L>=R)return 1;
    return 0;
}
int check2(int x){
    int L=0,R=0;
    for(int i=1;i<=n;i++){
        if(rr[i]<x)L+=l[i];
        else R+=r[i];
    }
    if(R>L)return 1;
    return 0;
}
struct node{
    int l,r;
}a[N];
bool cmp(node a,node b){
    if(a.l==b.l)return a.r<b.r;
    return a.l<b.l;
}
signed main(){
    cin>>c>>T;
    while(T--){
        cin>>n;
        int L=1,R,mx=0,cnt=0;
        for(int i=1;i<=n;i++){
            scanf("%lld%lld%lld%lld",&l[i],&r[i],&ll[i],&rr[i]);
            mx=max(mx,rr[i]);
        }
        int ans1,ans2;
        R=mx;
        while(L<=R){
            int mid=L+R>>1;
            if(check1(mid)){
                ans1=mid;
                R=mid-1;
            }
            else L=mid+1;
        }
        L=1,R=mx;
        while(L<=R){
            int mid=L+R>>1;
            if(check2(mid)){
                ans2=mid;
                L=mid+1;
            }
            else R=mid-1;
        }
        for(int i=1;i<=n;i++){
            if(rr[i]<ans1||ll[i]>ans2)continue;
            ll[i]=max(ll[i],ans1);
            rr[i]=min(rr[i],ans2);
            a[++cnt]={ll[i],rr[i]};
        }
        sort(a+1,a+cnt+1,cmp);
        int ans=0,lst=0;
        for(int i=1;i<=cnt;i++){
            if(a[i].l>lst){
                lst=a[i].r;
                ans+=a[i].r-a[i].l+1;
            }
            else{
                if(a[i].r>lst){
                    ans+=a[i].r-lst;
                    lst=a[i].r;
                }
            }
        }
        cout<<ans<<'\n';
    }
    return 0;
}
```

---

## 作者：shinzanmono (赞：7)

先离散化，枚举中位数在哪个段。设这个段左边的个数为 $cntl$，右边的个数为 $cntr$，这个段的个数为 $cnt$，$[L_x,R_x]$ 表示这个 $x$ 这个变量的取值范围。

一个数为中位数的条件是：

$$
\left\{
\begin{aligned}
cntl&<\left\lfloor\dfrac{cnt+cntl+cntr+1}{2}\right\rfloor\\
cntl+cnt&\geq \left\lfloor\dfrac{cnt+cntl+cntr+1}{2}\right\rfloor
\end{aligned}
\right.
$$
而 $\left\lfloor\dfrac{x}{2}\right\rfloor=\dfrac{x-x\bmod 2}{2}$，设 $M=(cnt+cntl+cntr+1)\bmod 2$，移项并放缩可得：

$$
\left\{
\begin{aligned}
cnt&\geq cntl-cntr+M\\
cnt&\geq cntr-cntl+1-M
\end{aligned}
\right.
$$

其中 $cntl-cntr$ 的取值范围 $[L,R]$ 易求得。则分 $cnt$ 和 $cntl-cntr$ 的奇偶性讨论即可。

不算排序和离散化可以做到线性。常数有点大，要 $24$ 倍左右。
```cpp
#include<iostream>
#include<algorithm>
using ll=long long;
const int sz=2e5+10;
const ll inf=0x7fffffffffffffff;
int c[sz<<3],l[sz],r[sz],vl[sz],vr[sz];
std::basic_string<int>beg[sz<<3],end[sz<<3];
int main(){
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int t;
  std::cin>>t>>t;
  while(t--)[&]{
    int n,V=0;
    std::cin>>n;
    for(int i=1;i<=n;i++){
      std::cin>>l[i]>>r[i]>>vl[i]>>vr[i];
      c[++V]=vl[i]-1,c[++V]=vl[i],c[++V]=vl[i]+1;
      c[++V]=vr[i]-1,c[++V]=vr[i],c[++V]=vr[i]+1;
    }
    std::sort(c+1,c+V+1);
    V=std::unique(c+1,c+V+1)-c-1;
    for(int i=1;i<=V;i++)beg[i].clear(),end[i].clear();
    ll cntll=0,cntlr=0,cntl=0,cntr=0,cntrl=0,cntrr=0,ans=0;
    for(int i=1;i<=n;i++){
      vl[i]=std::lower_bound(c+1,c+V+1,vl[i])-c;
      vr[i]=std::lower_bound(c+1,c+V+1,vr[i])-c;
      beg[vl[i]]+=i,end[vr[i]+1]+=i,cntrl+=l[i],cntrr+=r[i];
    }
    for(int i=1;i<V;i++){
      for(int j:beg[i])cntrl-=l[j],cntrr-=r[j],cntl+=l[j],cntr+=r[j];
      for(int j:end[i])cntl-=l[j],cntr-=r[j],cntll+=l[j],cntlr+=r[j];
      if(cntr==0)continue;
      ll cnt[2]={-1,-1},L=cntll-cntrr,R=cntlr-cntrl;
      std::pair<ll,ll>b[2]={std::make_pair(-inf,-inf),std::make_pair(-inf,-inf)};
      cnt[cntr&1]=cntr;
      if(cntl!=cntr)cnt[cntr-1&1]=cntr-1;
      b[L&1].first=L,b[R&1].second=R;
      if(L!=R)b[L+1&1].first=L+1,b[R-1&1].second=R-1;
      [&]{
        for(int l:{0,1}){
          for(int r:{0,1}){
            if(cnt[l]==-1)continue;
            if(b[r].first==-inf)continue;
            int mod=l^r^1;
            if(1-mod-cnt[l]<=b[r].second&&cnt[l]-mod>=b[r].first)return ans+=c[i+1]-c[i],void();
          }
        }
      }();
    }
    std::cout<<ans<<"\n";
  }();
  return 0;
}
```

---

## 作者：Louis_lxy (赞：7)

简单题，随便做。纪念第一次场切省选题。

首先看 A 性质，很容易想到枚举中位数，设这个数为 $k$。然后很显然的可以贪心：如果能选择 $k$ 就选择 $k$，显然如果增加 $x$ 个 $k$，中位数最多右移 $x$ 个数。然后接下来的区间就一定全部在左边或者全部在右边，将所有数的值的区间以左端点为第一关键字，右端点为第二关键字排序，右边弄个后缀和维护数字数量的上下界就可以做了，左边可以再以右端点为第一关键字左端点为第二关键字再排一次，也可以直接上个树状数组。反正都是很好做的。

显然我们发现答案是连续的，简单来说若设比 $k$ 小的数的个数区间为 $[l_1, r_1]$，$k+1$ 的区间为 $[l_2,r_2]$，显然有 $l_2\ge l_1$、$r_2\ge r_1$，若 $k$ 合法且 $k+1$ 已经不合法了，那么 $k+2$ 的区间的最小值只会更大，而 $k+1$ 不合法一定是区间最小值过大，因此答案区间一定连续，然后我们发现左右的数量的区间只会在经过某个值域的端点时被改变。然后离散化一下，因为有些值不一定存在，所以再对答案区间对所有值域区间求一个交集，再对这些交集求个并集就是答案了。

---

## 作者：LastKismet (赞：6)

# 性质 A
我们从性质入手，看到这个对值域的范围限制，不难想到枚举中位数。

考虑贪心，不难发现中位数的数量越多越优，那么可能成为中位数的就全部令为中位数，并且数量拉到最大。

剩下的就是绝对小于中位数的和绝对大于中位数的，考虑分别获取其数量最小值与最大值，不难想到分别对所有最少数量和最大数量使用前缀和和后缀和，就可以 $O(1)$ 得到。

下面还是一个贪心，考虑两侧的数越接近，中位数越可能是我们选定的中间位置的数。所以我们只需要给两边的数量赋值最接近，然后判定即可。

# 正解
考虑对区间缩点，不难发现很多点本质上是一致的。具体地，我们发现 $l$ 和 $r+1$ 两种位置会发生变化，所以考虑对他们进行离散化，一个点代表了当前点到下一个点减一的区间。这个区间是本质相同的。

然后序列长度就是 $O(2n)$ 的。我们可以用性质 A 的方式解决，并且快速得到每个点代表的区间长度以更新答案。

# 复原代码
按考场思路复原，已通过洛谷数据。
```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef __int128 i128;
typedef double db;
typedef long double ld;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef pair<int,ll> pil;
typedef pair<ll,int> pli;
template <typename Type>
using vec=vector<Type>;
template <typename Type>
using grheap=priority_queue<Type>;
template <typename Type>
using lrheap=priority_queue<Type,vector<Type>,greater<Type> >;
#define fir first
#define sec second
#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front
#define chmax(a,b) a=max(a,b)
#define chmin(a,b) a=min(a,b)
#define rep(i,x,y) for(int i=(x);i<=(y);i++)
#define per(i,x,y) for(int i=(x);i>=(y);i--)
#define repl(i,x,y) for(int i=(x);i<(y);i++)
#define file(f) freopen(#f".in","r",stdin);freopen(#f".out","w",stdout);

const int inf=0x3f3f3f3f;
const ll INF=0x3f3f3f3f3f3f3f3f;
const int mod=1e9+7/*998244353*/;

const int N=2e5+5;

int n,cnt;
int l1[N],r1[N],l2[N],r2[N];
ll x[N<<1];
ll lpre[N<<1],rpre[N<<1],lsuf[N<<1],rsuf[N<<1];

void solve(){
	cin>>n;cnt=0;
	rep(i,1,n){
		cin>>l1[i]>>r1[i]>>l2[i]>>r2[i];
		x[++cnt]=l2[i],x[++cnt]=r2[i]+1;
	}
	sort(x+1,x+1+cnt);
	cnt=unique(x+1,x+1+cnt)-x-1;
	rep(i,0,cnt+1)lpre[i]=rpre[i]=lsuf[i]=rsuf[i]=0;
	rep(i,1,n){
		l2[i]=lower_bound(x+1,x+1+cnt,l2[i])-x;
		r2[i]=lower_bound(x+1,x+1+cnt,r2[i]+1)-x-1;
	}
	rep(i,1,n){
		lpre[r2[i]]+=l1[i];
		rpre[r2[i]]+=r1[i];
		lsuf[l2[i]]+=l1[i];
		rsuf[l2[i]]+=r1[i];
	}
	rep(i,1,cnt)lpre[i]+=lpre[i-1],rpre[i]+=rpre[i-1];
	per(i,cnt,1)lsuf[i]+=lsuf[i+1],rsuf[i]+=rsuf[i+1];
	ll ans=0;
	repl(i,1,cnt){
		ll num=rpre[cnt]-rpre[i-1]-rsuf[i+1];
		if(!num)continue;
		if(rpre[i-1]<lsuf[i+1]){if((rpre[i-1]+num+lsuf[i+1]+1>>1)>rpre[i-1]&&(rpre[i-1]+num+lsuf[i+1]+1>>1)<=rpre[i-1]+num)ans+=x[i+1]-x[i];}
		else if(lpre[i-1]>rsuf[i+1]){if((lpre[i-1]+num+rsuf[i+1]+1>>1)>lpre[i-1]&&(lpre[i-1]+num+rsuf[i+1]+1>>1)<=lpre[i-1]+num)ans+=x[i+1]-x[i];}
		else ans+=x[i+1]-x[i];
	}
	cout<<ans<<"\n";
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int c,t;
	cin>>c>>t;
	while(t--)solve();
	return 0;
}
```

---

## 作者：Locix_Elaina_Celome (赞：6)

~~在省选考场上遇到这种题不如玩 O 神，建议降黄。~~

首先考虑暴力。

我们枚举中位数 $mid$，于是问题就是判断这个中位数是否合法。

我们把所有数分为三类：$x < mid,x=mid ,x>mid$。

我们发现第二类数是越多越好，所以所有跨过 $mid$ 的区间一定是选择 $mid$ 不劣的且选满。设这样的数最多有 $p$ 个。

然后发现剩下的一定小于或大于 $mid$，得到两个数量的区间。只需要判断这两个区间是否能通过偏移 $p$ 位使得区间有交。因为左右两边数量相同了 $mid$ 就一定能作为中位数。

于是直接做是一个 $O(nV)$ 的复杂度。

考虑优化。我们发现如果两个数关于别的值域区间的相对位置是一样的，那么他们对答案的贡献也是一样的。换句话说，如果一段值域中不存在输入的值域端点，可以一起处理。

离散化一下即可做到 $O(n^2)$。

接着我们发现对三类区间的计数直接预处理一下就是个权值数组上的区间查询。静态的所以不需要线段树。于是就是 $O(1)$ 查询。

总体时间复杂度 $O(n\log n)$，瓶颈在离散化上。

---

## 作者：liuyuantao (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P11830)

赛时先做了**性质 B**,后面回来想到了正解。  
我们考虑计算出中位数的最大值和最小值，之后去掉其中的不可取位置得到答案。为什么可以这样做呢？  
显然如果有一个数是答案之一，那么它**一定属于某一区间**。不妨设此数为 $k$，可由 $b_p$ 取得，已得最大值 $mx$，最小值 $mi$，上一步我们已得 $j$ 是一个答案且 $k$ 是**最小的**满足 $k \ge j$ 且 $\exists i\in[1,n],k\in[l_{i,2},r_{i,2}]$ (即此时 $i=p$)。  
记答案为 $j$ 时 $b_p$ 位置是 $q$ 且 $S_{q+1}>S_q$，我们分类讨论:  
1. $q=\lfloor{\frac{m+1}{2}}\rfloor$。我们直接将 $b_p$ 调整为 $k$，所有 $a_i$ 不变。必有 $k$ 是中位数(否则必是超过了某数，与 $k$ 最小矛盾)。  
2. $q\ne\lfloor{\frac{m+1}{2}}\rfloor$。我们将 $b_p$ 调整为 $k$，接着将所有当前值不为 $k$ 但可以改为 $k$ 的 $b_i$ 调整为 $k$，显然大于 $k$ 的数数量单调不增，故中位数不超过 $k$。操作直到 $k$ 为中位数。若此操作结束后不成功，则逐渐增大所有 $b_i \ge k$ 的数的数量，显然一次最多让中位数向后一位，所以可以使 $k$ 为中位数。  
如果操作完毕后仍不成功，由第一步操作可知现有至少 $\lfloor{\frac{m+1}{2}}\rfloor$ 个数最大取值小于 $k$，增大它们的数量只会减小中位数，与最大可以取到 $mx$ 相矛盾，故一定能够取到 $k$。

接下来考虑求出最大(小)值。贪心地考虑，让所有 $b_i$ 最大显然不比其他方案劣。接着对 $b$ 数组排序，最小化较小的 $b_i$ 数量并最大化较大者，将它们求和记录，直到较小者数量和不小于较大者数量和，记录中位数，即为最大值。最小值可同理求出。  
去除不可取位置仅需记录不可取的区间删除其长度即可，由区间的连续性可知不可取区间 $[q_{i,1},q_{i,2}]\in[mi,mx]$。  
参考代码:  

```cpp
#include<bits/stdc++.h>

using namespace std;

#define LL long long

const int N=2e5+5;
LL c,cnt,ans,cnt1,cnt2,cnt3,cnt4,T,n,m,minm,maxm;
LL C[N][2];

struct xy{
    LL l1,l2,r1,r2;
}A[N];

struct yz{
    LL a,b,c;
}B[N];

bool cmp(xy x,xy y){
    return x.l2<y.l2;
}

bool cmp1(yz x,yz y){
    return x.a<y.a;
}

int main(){
    cin>>c>>T;
    while(T--){
        cin>>n;
        for(int i=1;i<=n;i++){
        cin>>A[i].l1>>A[i].r1>>A[i].l2>>A[i].r2;
        }
        cnt=ans=cnt1=cnt2=cnt3=0;
        sort(A+1,A+n+1,cmp);
        LL R=A[1].r2;
        for(int i=2;i<=n;i++){
            if(R<A[i].l2-1){
                C[++cnt3][0]=R+1;
                C[cnt3][1]=A[i].l2-1;
            }
            R=max(A[i].r2,R);
        }
        for(int i=1;i<=n;i++){
            B[i].a=A[i].l2;
            B[i].b=A[i].l1;
            B[i].c=A[i].r1;
            cnt1+=B[i].b;
            cnt2+=B[i].c;
        }
        sort(B+1,B+n+1,cmp1);
        cnt=0;
        for(int i=1;i<=n;i++){
            cnt+=B[i].c;
            cnt1-=B[i].b;
            if(cnt>=cnt1){
                minm=B[i].a;break;
            }
        }
        for(int i=1;i<=n;i++){
            B[i].a=A[i].r2;
            B[i].b=A[i].l1;
            B[i].c=A[i].r1;
        }
        sort(B+1,B+n+1,cmp1);
        cnt=0;
        for(int i=1;i<=n;i++){
            cnt+=B[i].b;
            cnt2-=B[i].c;
            if(cnt>=cnt2){
                maxm=B[i].a;
                break;
            }
        }
        cnt4=0;
        for(int i=1;i<=cnt3;++i){
            if(C[i][0]>=minm&&C[i][1]<=maxm){
                cnt4+=C[i][1]-C[i][0]+1;
            }
        }
        cout<<maxm-minm-cnt4+1<<endl;
    }
    return 0;
}
```
[AC 记录(民间数据)](https://www.luogu.com.cn/record/205365565)

---

## 作者：Laisira (赞：4)

额么么 t1 感觉没到蓝题的鸭子，但是我没能参加省选。

显然有且仅有一段区间任意一个存在的数可以作为答案。考虑二分这个边界值，对于 $x$ 显然右端点小于 $x$ 的一定放前面，包含 $x$ 的选 $x$ 显然不劣，这样会发现单调性，判断小于的和等于的有多少就行了。

---

## 作者：sjzsd147 (赞：2)

# 题意简述
有 $n$ 个二元组 $(a_i,b_i)$，每个二元组满足 $a_i\in[l_{i,1},r_{i,1}]$ 且 $b_i\in[l_{i,2},r_{i,2}]$。求存在多少数 $x$ 满足存在一种情况使得 $\sum_{b_i<x}a_i\le\frac{m}{2}$ 且 $\sum_{b_i\le x}a_i>\frac m2$。

# 解法分析
## 特殊性质A
不妨从小到大枚举每一个可能的值，对于每一个值 $x$，可以将所有的二元组分为三种，分别是:  
1. $r_{i,2}<x$
2. $l_{i,2}\le x\le r_{i,2}$
3. $l_{i,2}>x$

  一个显然的结论是，对于所有可以取到 $x$ 的 $b_i$，取 $x$ 一定不会更劣，而取不到的取值不会影响中位数本身，这样就已经解决了对于 $b_i$ 的取值的问题。
### 特殊性质C
先考虑将这三种的 $a_i$ 的和分别记为 $pre,now,aft$，可以将 $l_{i,2},r_{i,2}$ 以及对应的 $a_i$ 取出并分别排序，在枚举 $x$ 的同时统计这三个值。

那么此时，$x$ 满足题意的充要条件是：
$$pre<\frac{pre+now+aft}{2}$$
$$pre+now\ge\frac{pre+now+aft}{2}$$
$$now\ge 1$$

### 如果 $a_i$ 不确定呢？
同样的，我们将二元组分为三组，对于上面的条件，我们化简一下，可以转换为：
$$-now<aft-pre\le now$$
显然，对于 $now$ 只需要取对应最大值即可。

设 $pre_{min},pre_{max},aft_{min},aft_{max}$ 分别为 $pre,aft$ 可以取到的最小值和最大值。那么还有：
$$aft_{min}-pre_{max}\le aft-pre \le aft_{max}-pre_{min}$$
当这两个范围存在交集时 $x$ 满足条件。

## 更普遍的情况
容易注意到，对于区间 $[u,v]$，若不存在 $l_{i,2}\in (u,v],r_{i,2}\in[u,v)$，那么对于该区间内所有值的 $pre,now,aft$ 值均相同。

此时我们只需要将所有 $l_{i,2},r_{i,2}+1$ 排序，并枚举每一个区间 $[x_i,x_{i+1})$ 即可。此时的三个分组为：
1. $r_{i,2}<x_i$
2. $l_{i,2}\le x_i,r_{i,2}\ge x_i$
3. $l_{i,2}>x_i$

判断条件同上。

时间复杂度 $O(Tn\log n)$，可以通过本题。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

int c,T;
int n;
struct node{
	int l1,r1,l2,r2;
};
vector<node>p;
vector<int>num;

int subtaskB(){
	ll m=0;
	ll res=0;
	vector<pair<int,int>>pl;
	vector<pair<int,int>>pr;
	for(auto i:p){
		m+=i.l1;
		pl.push_back({i.l1,i.l2});
		pr.push_back({i.l1,i.r2});
	}
	auto cmp=[&](pair<int,int> x,pair<int,int> y){
		return x.second<y.second;
	};
	sort(pl.begin(),pl.end(),cmp);
	sort(pr.begin(),pr.end(),cmp);
	auto lt=pl.begin(),rt=pr.begin();
	ll tmp1=0,tmp=0;
	for(int i=0;i<num.size()-1;i++){
		while(rt!=pr.end()&&rt->second<num[i]){
			tmp1+=rt->first;
			tmp-=rt->first;
			rt++;
		}
		while(lt!=pl.end()&&lt->second<=num[i]){
			tmp+=lt->first;
			lt++;
		}
		if(tmp1<(m+1)/2&&tmp1+tmp>=(m+1)/2){
			res+=num[i+1]-num[i];
		}
	}
	// if(tmp1<(m+1)/2&&tmp1+tmp>=(m+1)/2){
	// 	res++;
	// }
	return res;
}

int solve(){
	ll res=0;
	ll premin=0,premax=0,nowmin=0,nowmax=0,aftmin=0,aftmax=0;
	vector<tuple<int,int,int>>left,right;	//pos, min, max
	for(auto i:p){
		left.push_back({i.l2,i.l1,i.r1});
		right.push_back({i.r2,i.l1,i.r1});
		aftmin+=i.l1;
		aftmax+=i.r1;
	}
	sort(left.begin(),left.end());
	sort(right.begin(),right.end());
	auto lt=left.begin(),rt=right.begin();
	for(int i=0;i<num.size()-1;i++){
		while(rt!=right.end()&&get<0>(*rt)<num[i]){
			premin+=get<1>(*rt);
			premax+=get<2>(*rt);
			nowmin-=get<1>(*rt);
			nowmax-=get<2>(*rt);
			rt++;
		}
		while(lt!=left.end()&&get<0>(*lt)<=num[i]){
			nowmin+=get<1>(*lt);
			nowmax+=get<2>(*lt);
			aftmin-=get<1>(*lt);
			aftmax-=get<2>(*lt);
			lt++;
		}
		if(premin-aftmax<nowmax&&premax-aftmin>=-nowmax&&nowmin){
			res+=num[i+1]-num[i];
		}
	}
	return res;
}

int main(){
	freopen("lucky.in","r",stdin);
	freopen("lucky.out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>c>>T;
	while(T--){
		cin>>n;
		p.resize(n);
		num.clear();
		for(auto &i:p){
			cin>>i.l1>>i.r1>>i.l2>>i.r2;
			num.push_back(i.l2);
			num.push_back(i.r2+1);
		}
		sort(num.begin(),num.end());
		num.erase(unique(num.begin(),num.end()),num.end());
		num.push_back(num.back()+1);
		// for(auto &i:p){
		// 	i.l2=lower_bound(num.begin(),num.end(),i.l2)-num.begin();
		// 	i.r2=lower_bound(num.begin(),num.end(),i.r2)-num.begin();
		// }
		if(c&1){
			cout<<subtaskB()<<"\n";
		}else{
			cout<<solve()<<"\n";
		}
	}
	return 0;
}
```

---

## 作者：ljx20130810 (赞：2)

考场上花了 $3$ 小时打的，快调似了

## Part 1: 40pts

首先有一个很显然的结论：如果要让中位数是 $k$，则最终 $k$ 的数量越多越好。

然后就有了一个思路，枚举所有的数**是否可能成为中位数**。

对于每个数 $k$，对于所有 $l_{i,2} \le k \le r_{i,2}$ 的二元组，加入**尽量多**的 $k$。记此时 $k$ 的个数为 $cnt_k$。剩下的要么一定比 $k$ 小，要么一定比 $k$ 大。

假设比 $k$ 小的数的个数在 $[p_1,p_2]$ 内，比 $k$ 大的数的个数在 $[q_1,q_2]$ 内，则为了让比 $k$ 小的数的个数与比 $k$ 大的数的个数的差的绝对值**尽量小**，

* 若 $p_2<q_1$，绝对差的最小值为 $q_1-p_2$，当 $q_1-p_2 \le cnt_k$ 时，$k$ 可能成为中位数。
* 若 $q_2<p_1$，绝对差的最小值为 $p_1-q_2$，当 $p_1-q_2 < cnt_k$ 时，$k$ 可能成为中位数。
* 否则，若 $cnt_k>0$，$k$ 一定可以成为中位数。（此时必有一种方案，使得比 $k$ 小的数与比 $k$ 大的数个数相等。）

注意第 $1$ 条与第 $2$ 条的区别：由于是从小到大的中位数，因此若 $\ge k$ 的数的个数和 $<k$ 的数的个数相等，中位数将会取到 $<k$ 的数中最大的一个，因此第 $2$ 条不能取等。

**记得开 $\texttt{long long}$**

时间复杂度 $O(n \times \max \limits _{r_{i,2}})$，预计得分 $40$。

## Part 2: 60pts

考虑优化每次判定的时间复杂度。注意到，由于一次操作不可能**既一定大于 $k$ 又一定小于 $k$**，因此可以使用单调性优化。

将所有二元组复制一份，第 $1$ 组按 $l_{i,2}$ 排序，第 $2$ 组按 $r_{i,2}$ 排序。这样就可以使用二分查找找到**一定大于 $k$ 或一定小于 $k$** 的二元组的**区间**，然后用前缀和查询区间和，即可在 $O(\log n)$ 的时间内计算出 $p_1,p_2,q_1,q_2$，然后使用总数减去一定大于或小于的个数即为 $cnt_k$。（注意 $cnt_k$ 仍然保持最大）

时间复杂度 $O(\log n \times \max \limits _{r_{i,2}})$，预计得分 $60$。

## Part 3: 100pts

~~其实你先做第 $3$ 步再做第 $2$ 步也能获得 $60pts$，但是因为第 $2$ 步更简单所以放在前面~~

判定的时间复杂度已经无法优化了，考虑优化 $\max \limits _{r_{i,2}}$。由于中位数只与大小关系有关，与具体数值无关，很容易想到使用离散化。

将 $l_{i,2}$ 和 $r_{i,2}$ 合并后一起离散化。**由于此时每两个数之间是隔着一个大区间的，合并成相邻两个正整数就会变为连续，因此每两个数字之间都要再插入一个元素代表相邻两个数字之间的区间。** 使用一个数组存储区间长度即可（单个值的长度为 $1$）。查询时，对于一个区间，若这个区间判定为可能成为中位数，则直接将答案增加这个区间的长度。

一共 $2n$ 个元素，每两个元素之间插入一个区间，因此总元素数量是 $O(4n)$ 的。总时间复杂度 $O(n \log n)$，预计得分 $100$ 分。建议使用快读优化。

（作者考场上最后一个大样例跑了 $0.89$ 秒，但是众所周知极限数据是它的 $1.5$ 倍，所以一定要卡过去 bushi）

代码等公示。

---

## 作者：2022dyx (赞：2)

很好的一道签到题，一眼看不太出贪心的思路，但从性质开始想就能比较自然地接近正解。

---

先看性质 B，保证 $l_i=r_i$ 也就意味着固定了总个数，这时问哪些数可以是中位数也就意味着问哪些数可以排到固定的位置。

我们一个一个数地看。对于数字 $x$，所有数的范围就被划成了三部分：完全小于 $x$，包含 $x$，和完全大于 $x$。不难发现要想让 $x$ 成为中位数，所有经过 $x$ 的范围都选 $x$ 一定是最优的，证明就是将选的其他的东西换成 $x$ 不会导致 $x$ 不再成为中位数。

然后其实性质 B 就做完了。因为完全小于 $x$ 和完全大于 $x$ 的两部分选什么与 $x$ 能否成为中位数完全无关，于是直接树状数组判一下就行。

---

再看性质 A。其实如果有比较敏锐的观察力就能发现这个性质和正解大概率只差一个离散化。但无论如何，我们还是先从简单的部分开始想。

与上一部分相比，少了个数固定这个很好的性质，但是 $\le n$ 的值域提醒我们可以直接枚举每个数并验证其能否成为中位数。

验证的过程中，经过 $x$ 的部分一定还是选 $x$ 并使个数最多，证明也是同理的。但是剩下的部分就没有那么显然了。我们设最终 $x$ 的个数为 $m$，小于 $x$ 的数的个数是 $l$，大于 $x$ 的数的个数是 $r$，来推一推式子看看。

先假设总数也就是 $l+m+r$ 是 $2$ 的倍数，那就有：

$$l < \frac{l+m+r}{2} \le l+m$$

也就是 $l < m+r$，$r \le l+m$。

把 $l$ 和 $r$ 放到一起，就有 $-m < r-l \le m$。

$l+m+r$ 不是 $2$ 的倍数也是同理的，只是变一变符号，有 $-m \le r-l < m$。

也就是说我们只要存在 $r-l$ 在这个区间里就行。所以可以求出 $r-l$ 的最大值和最小值，只要不位于区间的同侧就行。

那怎么求 $r-l$ 的最值呢？

我们可以把每个二元组能取的最大数量和最少数量挂到左右端点上，查询的时候直接树状数组上查询就能分别得知 $l$ 和 $r$ 的最大值和最小值。

---

根据上面的剧透，性质 A 和正解就只差一个离散化。我们直接对出现的区间左右端点离散化，没出现的部分一定是等同的，因此答案不同的数的个数只有 $O(n)$ 个。

离散化的时候有一个小技巧。为了避免端点和中间的特判，我们可以直接把所有右端点增加 $1$，容易发现此时区间内数字的答案一定与左端点相同。

总时间复杂度 $O(n \log n)$。

下面是赛时的代码：
```
#include <bits/stdc++.h>
#define int long long
#define file(x) freopen(#x ".in", "r", stdin); freopen(#x ".out", "w", stdout);
using namespace std;
constexpr int N = 4e5 + 5;
int id, t, n, val[N], sum, ans;
vector <int> v;
struct Tuple{ int l1, r1, l2, r2; } a[N];
struct TreeArray{
	int Tree[N];
	int lowbit(int x) { return x & (-x); }
	void modify(int x, int y) { for (int i = x; i <= v.size(); i += lowbit(i)) Tree[i] += y; }
	int query(int x) { int ret = 0; for (int i = x; i > 0; i -= lowbit(i)) ret += Tree[i]; return ret; }
	int query(int x, int y) { return query(y) - query(x - 1); }
}tree[4];
// 0:Lmin, 1:Lmax, 2:Rmin, 3:Rmax
int check(int x, int y, int z) {
	if ((x + y + z) % 2 == 0) {
		if (x - y <= -z) return -1;
		if (x - y > z) return 1;
		return 0;
	}
	if ((x + y + z) % 2 == 1) {
		if (x - y < -z) return -1;
		if (x - y >= z) return 1;
		return 0;
	}
}
signed main() {
	file(lucky)
	cin.tie(0) -> sync_with_stdio(false);
	cin >> id >> t;
	while(t--) {
		cin >> n;
		v.clear();
		sum = ans = 0;
		for (int i = 1; i <= n; ++i) {
			cin >> a[i].l1 >> a[i].r1 >> a[i].l2 >> a[i].r2;
			++a[i].r2, v.push_back(a[i].l2), v.push_back(a[i].r2);
		}
		sort(v.begin(), v.end()), v.erase(unique(v.begin(), v.end()), v.end());
		for (int i = 1; i < v.size(); ++i) val[i] = v[i] - v[i - 1];
		for (int i = 1; i <= n; ++i) {
			a[i].l2 = lower_bound(v.begin(), v.end(), a[i].l2) - v.begin() + 1;
			a[i].r2 = lower_bound(v.begin(), v.end(), a[i].r2) - v.begin() + 1;
			sum += a[i].r1;
			tree[0].modify(a[i].l2, a[i].l1), tree[1].modify(a[i].l2, a[i].r1);
			tree[2].modify(a[i].r2, a[i].l1), tree[3].modify(a[i].r2, a[i].r1);
		}
		for (int i = 1; i < v.size(); ++i) {
 			int lmin = tree[2].query(1, i), lmax = tree[3].query(1, i);
			int rmin = tree[0].query(i + 1, v.size()), rmax = tree[1].query(i + 1, v.size());
			int msum = sum - lmax - rmax;
			if (!msum) continue;
			int mxcheck = check(rmax, lmin, msum), mncheck = check(rmin, lmax, msum); 
			if (mxcheck == -1 && mncheck == -1) continue;
			if (mxcheck == 1 && mncheck == 1) continue;
			ans += val[i];
		}
		cout << ans << '\n';
		for (int i = 1; i <= n; ++i) {
			tree[0].modify(a[i].l2, -a[i].l1), tree[1].modify(a[i].l2, -a[i].r1);
			tree[2].modify(a[i].r2, -a[i].l1), tree[3].modify(a[i].r2, -a[i].r1);
		}
	}
}
```

---

## 作者：ganpig (赞：2)

我们设所有的 $l_{i,2}$ 和 $r_{i,2}+1$ 组成的集合为 $A$，容易发现：区间 $[A_i,A_{i+1})$ 里的数要么同时可能成为中位数要么同时不可能。证明：假如答案为区间中的一个数 $x$，首先把 $S$ 中处于这个区间的数都改为 $x$（根据 $A$ 的定义，这不会跨越任何端点，所以是可行的），这不会改变大小关系，因而中位数不变；接着把加入 $S$ 的所有这个数都改为区间中的另一个数 $y$，没有改变这些数与其他数的大小关系，于是中位数就变成 $y$ 了，原题得证。

所以我们只要考虑 $A$ 中 $O(n)$ 个数的可行性即可。设当前考虑的数为 $x$，维护一定小于 $x$ 的数 $lcnt$ 的个数范围（即 $[\sum_{r_{i,2}<x}l_{i,1},\sum_{r_{i,2}<x}r_{i,1}]$）、可以取 $x$ 的数 $mcnt$ 的个数范围（即 $[\sum_{l_{i,2}\le x \le r_{i,2}}l_{i,1},\sum_{l_{i,2}\le x \le r_{i,2}}r_{i,1}]$）、一定大于 $x$ 的数 $rcnt$ 的个数范围（即 $[\sum_{x<l_{i,2}}l_{i,1},\sum_{x<l_{i,2}}r_{i,1}]$）。

中位数为 $x$ 的条件是：$(lcnt < mcnt+rcnt) \land (lcnt+mcnt \ge rcnt)$，要存在满足这个条件的可能，只需 $(mcnt_{max} > 0) \land (lcnt_{min} < mcnt_{max} + rcnt_{max}) \land (lcnt_{max} + mcnt_{max} \ge rcnt_{min})$，满足这个式子就将这个区间的长度计入答案。

时间复杂度 $O(n \log n)$（排序）。

### $\text{Code}$

```cpp
#include <bits/stdc++.h>

int main() {
    freopen("lucky.in", "r", stdin);
    freopen("lucky.out", "w", stdout);

    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int C, T;
    std::cin >> C >> T;
    while (T--) {
        int n;
        std::cin >> n;
        std::vector<std::array<int, 4>> a(n);
        std::set<int> st;
        std::vector<std::array<int, 3>> L, R;
        long long lmi = 0, lma = 0, mmi = 0, mma = 0, rmi = 0, rma = 0;
        for (auto &[l1, r1, l2, r2] : a)
            std::cin >> l1 >> r1 >> l2 >> r2, rmi += l1, rma += r1,
                L.push_back({r2, l1, r1}), R.push_back({l2, l1, r1}),
                st.insert(l2), st.insert(r2 + 1);
        std::sort(L.begin(), L.end()), std::sort(R.begin(), R.end());

        auto lit = L.begin(), rit = R.begin();
        int ans = 0;
        for (auto it = st.begin(); std::next(it) != st.end(); it++) {
            for (; rit != R.end() && (*rit)[0] <= *it; rit++) {
                rmi -= (*rit)[1], mmi += (*rit)[1];
                rma -= (*rit)[2], mma += (*rit)[2];
            }
            for (; lit != L.end() && (*lit)[0] < *it; lit++) {
                lmi += (*lit)[1], mmi -= (*lit)[1];
                lma += (*lit)[2], mma -= (*lit)[2];
            }
            if (mma && lmi < mma + rma && lma + mma >= rmi)
                ans += *std::next(it) - *it;
        }
        std::cout << ans << '\n';
    }
}
```

PS：也许是 AFO 前的最后一篇题解了。洛谷，未来有缘再见。

---

## 作者：Eric998 (赞：1)

考场思路+代码。

我们考虑离散化后钦定 $i$ 为中位数，设 $i$ 有 $\beta$ 个，$<i$ 的有 $\alpha$ 个，$>i$ 的有 $\gamma$ 个。

注意到 $i$ 为中位数等价于以下条件：

- $\beta \neq 0$
- $\gamma-\alpha\in(-\beta,\beta]$。

我们研究每个可能对 $\beta$ 产生贡献，并可能对 $\alpha,\gamma$ 其中至少一个产生贡献的区间，设其的重数为  $x\in[L,R]$。观察到将其放到 $\alpha,\gamma$ 中的一边，只可以将 $\gamma-\alpha$ 的结果改变 $x$；但如果将其放到 $\beta$ 上，则 $\gamma-\alpha$ 的区间会扩展 $x$。这是一定比加在一边优的。

因此，我们维护 $\beta$ 的最大值与 $\beta$ 取最大时  $\alpha,\gamma$ 的取值范围。这一部分扫描过去用两个堆维护包含 $i$ 的和完全在 $i$ 右边的区间即可。

code:
```cpp
//AD ASTRA PER ASPERA
#include <bits/stdc++.h>
#include <bits/extc++.h>
using namespace std;
#define N 200005
#define int long long
int L[N], R[N], X[N], Y[N], n, m, T, ans, cur, lmx, lmn, rmx, rmn;
#define fi first
#define se second

//100pts please
//Why 1 second time
//I wish CCF's mother to live forever.
void solve() {
	cin >> n;
	vector<int> v;
	v.push_back(0);
	for (int i = 1; i <= n; i++)
		cin >> X[i] >> Y[i] >> L[i] >> R[i], v.push_back(L[i]), v.push_back(R[i] + 1);
	sort(v.begin(), v.end());
	int k = unique(v.begin(), v.end()) - v.begin();
	__gnu_pbds::priority_queue<pair<pair<int, int>, pair<int, int> >, greater<pair<pair<int, int>, pair<int, int> > >, __gnu_pbds::pairing_heap_tag>
	icl, rit;
	ans = cur = lmx = lmn = rmx = rmn = 0;
	for (int i = 1; i <= n; i++)
		rit.push({{L[i], R[i]}, {X[i], Y[i]}}), rmx += Y[i], rmn += X[i];
	for (int i = 1; i < k - 1; i++) {
		while (rit.size() && rit.top().fi.fi <= v[i]) {
			auto g = rit.top();
			rmx -= g.se.se, rmn -= g.se.fi, cur += g.se.se, rit.pop(), icl.push({{g.fi.se, g.fi.fi}, {g.se}});
		}
		while (icl.size() && icl.top().fi.fi < v[i]) {
			auto g = icl.top();
			lmx += g.se.se, lmn += g.se.fi, cur -= g.se.se, icl.pop();
		}
//        printf("[%lld,%lld) cur = %lld L[%lld,%lld], R[%lld,%lld]\n",v[i],v[i+1],cur,lmx,lmn,rmx,rmn);
		int dmx = rmx - lmn, dmn = rmn - lmx;
		if (dmx <= -cur || dmn > cur || !cur)
			continue;
		ans += v[i + 1] - v[i];
	}
	cout << ans << '\n';
}

signed main() {
	freopen("lucky.in", "r", stdin), freopen("lucky.out", "w", stdout);
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin >> T >> T;
	while (T--)
		solve();
}

//678534
//Day 1 150+pts /kel/kel/kel/kel/kel
``

---

## 作者：Hell0_W0rld (赞：1)

### 20 pts
暴力枚举，排序。

写完之后大约 8:44。
### 40 pts
每一个数出现次数是固定的，考虑离散化，对于两个数 $x,y$，如果 $\forall i\in [1,n]$ 都有 $x,y$ 均在或均不在 $[l_{i,2},r_{i,2}]$ 中，显然可以压缩为一段。

对于每个数 $t$，若 $t$ 可能成为答案，贪心思考则必有：若 $b_i$ 能选 $t$ 则必然选 $t$。

预处理中位数对应的序号，枚举一下看看前后个数是否能使其成为中位数即可。

写完之后大约 9:10。
### 60 pts
出现次数不固定了，但能选 $t$ 则必然选 $t$ 且次数最大化肯定是没问题的。

然后大力推式子：设一定小于 $t$ 的数对所有 $a_i$ 的和出现次数在 $[L_1,R_1]$ 范围内，大于的则在 $[L_2,R_2]$ 范围内。

考虑左端为 $x$ 次，$t$ 出现了 $y$ 次，右端出现了 $z$ 次，则：
$$\begin{cases}
x<\lfloor\frac{x+y+z+1}{2}\rfloor\\
x+y\geq \lfloor\frac{x+y+z+1}{2}\rfloor\\
y>0
\end{cases}$$
则有
$$\begin{cases}
x<y+z\\
x+y\geq z
\end{cases}\\
\therefore x-y<z\leq x+y\\
\therefore L_2\leq x+y,x-y<R_2\\
\therefore x\in[L_2-y,R_2+y-1]\\
\therefore [L_2-y,R_2+y-1]\cap[L_1,R_1]\neq \emptyset\land y\neq 0.$$

枚举一下每个区间段，算出来即可。

写完大约 9:50。
### 100 pts
考虑在 60 分做法的基础上动态维护 $L_1,R_1,L_2,R_2$ ，有 $y=\sum_{x=1}^n r_{1,x}-R_1-R_2$。

注意到 $L_1=\sum_{x=1}^n [r_{2,x}<t]l_{1,x}$，同理可得 $L_2,R_1,R_2$ 的表达式。

那我们可以用增量式的方法，预处理对于每一个 $t$，$L_1,L_2,R_1,R_2$ 的变化量再累加这个 $t$ 所代表的离散段即可。

写完大约 10:00。

---

## 作者：Crazyouth (赞：1)

## 分析

首先答案必定在所有 $[l_2,r_2]$ 的并之中。其次，我们如果想让 $k$ 成为中位数，我们就可以先让所有能小于等于 $k$ 的数都小于它并尽量地多取，不能小于等于的就少取；然后反过来让大于等于的都多取，不能的就少取，判断两次的 $k$ 是否位于中位的两边，如果是，那么总可以每次删除或增加一个数使得 $k$ 位于中位，成为中位数。我们注意到符合条件的 $k$ 必然是若干个连续段，所以可以在每一段值域上二分这个连续区间，设其为 $[l,r]$，那么我们先二分 $l$ 是啥，由于我们想让它尽量小，所以如果二分后无法找到 $l$，说明 $l$ 在整个区间左侧，所以就可以先二分 $r$ 了，再二分出 $l$。

---

## 作者：wmrqwq (赞：1)

# 题目链接

[P11830 [省选联考 2025] 幸运数字](https://www.luogu.com.cn/problem/P11830)

# 解题思路

## 40pts

考虑直接暴力 check 每个数字 $x$ 是否能被取到。

有以下贪心方式：

- 如果根本不可能取到至少一个数字 $x$，则 $x$ 不能被取到。

- 若对于一个可取数字区间有 $l2 \le x \le r2$，则必然取数字 $x$，取的数字数量为 $r1$。

- 否则，则有 $x < l2$ 或 $r2 < x$，此时我们容易求得 $[1,x-1]$ 的数字个数取值区间 $[s1,s2]$，$[x+1,10^9]$ 的数字个数取值区间 $[s3,s4]$。然后我们分讨以下情况：

  - $s1 \le s3 \le s2$ 或 $s3 \le s1 \le s4$，此时前后两区间长度可以相交，那么使得两区间长度一致那么数字 $x$ 就可以被取到，因此此情况 $x$ 可以被取到。
 
  - 否则，我们分讨以下两种情况。
 
    - 若 $s2 < s3$，那么此时前面取 $s2$ 个数字，后面取 $s3$ 个数字显然最优，算出此时中位数是否为 $x$ 即可。
    - 否则一定有 $s4 < s1$，那么此时前面取 $s1$ 个数字，后面取 $s4$ 个数字显然最优，算出此时中位数是否为 $x$ 即可。
      
那么这样 check 一次是 $O(n)$ 的。

考虑去暴力做特殊性质 A 的 $n$ 个数字，依次 check，可以获得 $40$ 分。

总时间复杂度 $O(n^2)$。

## 60pts

特殊性质 A 做法。

依然考虑上述 check 方式，你发现根据 $x$ 的递增性，每个数字区间 $[l2,r2]$ 只会给 $s1,s2,s3,s4$ 带来连续一段区间的贡献，那么直接差分后进行一次前缀和即可。

总时间复杂度 $O(n)$。

## 80pts

经过惊人的注意力（打表）可以发现，我们可以将 $l2,r2$ 离散化，此时就会有 $2n$ 个点，发现若一个点是合法的，则这个点往左有一段连续的区间也是合法的，此时直接二分即可，时间复杂度 $O(n^2 \log^2 n)$，可以获得 $80$ 分。

## 100pts

考虑优化 80pts 做法，那么你发现我们可以直接将原本需要暴力做的区间离散化，由于需要差分加减的点只有 $2n$ 个，那么直接离散化这些差分端点，二分即可查找到准确前缀和之后的值，那么一次 check 复杂度就被降到了 $O(\log n)$，总时间复杂度 $O(n \log^2 n)$，可以通过此题。

# 参考代码

等代码公示后放。

---

## 作者：Polarisx (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11830)。

似乎写复杂了一些。

## 思路

考虑判断一个数 $p$ 是否能成为中位数，对于 $r_{i,2}<p$ 的这些数，只能填在 $p$ 左边，$r_{i,2}>p$ 的数只能填在其右边，而 $l_{i,2}\le p\le r_{i,2}$ 这些数当然填 $p$ 最优，而且越多越好。

可以先求出 $r_{i,2}<p$ 可以填数个数的范围，即 $[\sum_{r_{i,2}<p}l_{i,1},\sum_{r_{i,2}<p}r_{i,1} ]$，不妨记为 $[L_1,R_1]$，同理可以求出 $r_{i,2}>p$ 可填数个数的范围，记为 $[L_2,R_2]$，最后求出 $l_{i,2}\le p\le r_{i,2}$，记其**最大**可填数个数为 $C$。

接下来问题转换成了现在有三个数 $a,c,b(a<c<b)$，其中 $a$ 个数的范围在 $[L_1,R_1]$，$b$ 个数的范围在 $[L_2,R_2]$，$c$ 个数为 $C$，判断 $c$ 是否可能成为中位数。

- 若 $c=0$，一定不可能。
- 若 $[L_1,R_1],[L_2,R_2]$ 有交，则取交集中的某一个数一定可以使得 $c$ 为中位数。
- 否则让在 $[L_1,R_1]$ 和 $[L_2,R_2]$ 区间中选的两个数尽量靠近，然后判断即可。

以上是 A 性质，正解就是将区间离散化，因为一个区间中数的贡献是一定的。


```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int Maxn=5e5+6;
int c,T;
int n;
int pos[Maxn],tot;
int yuan[Maxn];

ll su[Maxn],suf[Maxn],pre[Maxn],pr[Maxn];

struct node{
    int l1,r1,l2,r2;
}a[Maxn];

inline bool Getval(ll A,ll B,ll C){
    ll mid=(A+B+C+1)/2;
    if(mid>A and mid<=A+C) return 1;
    return 0;
}
inline bool check(ll l1,ll r1,ll l2,ll r2,ll C){
    if(!C) return 0;
    if(max(l1,l2)<=min(r1,r2)) return 1;
    return (Getval(l1,l2,C)|Getval(l1,r2,C)|Getval(r1,l2,C)|Getval(r1,r2,C));
}

int main(){
    scanf("%d%d",&c,&T);

    while(T--){
        scanf("%d",&n);
        tot=0; ll AC=0;
        for(int i=1;i<=n;i++){
            scanf("%d%d%d%d",&a[i].l1,&a[i].r1,&a[i].l2,&a[i].r2);
            pos[++tot]=a[i].l2,pos[++tot]=a[i].r2; AC+=a[i].r1;
        }
        sort(pos+1,pos+tot+1);
        tot=unique(pos+1,pos+tot+1)-pos-1;
        
        for(int i=1;i<=n;i++){
            int p1=lower_bound(pos+1,pos+tot+1,a[i].l2)-pos;
            int p2=lower_bound(pos+1,pos+tot+1,a[i].r2)-pos;
            yuan[p1]=a[i].l2,yuan[p2]=a[i].r2; a[i].l2=p1,a[i].r2=p2;
            pre[p2]+=a[i].l1,suf[p1]+=a[i].l1,su[p1]+=a[i].r1,pr[p2]+=a[i].r1; 
        }
        for(int i=1;i<=tot;i++) pre[i]+=pre[i-1],pr[i]+=pr[i-1];
        for(int i=tot;i;i--) suf[i]+=suf[i+1],su[i]+=su[i+1];
        ll ans=0;
        for(int i=1;i<tot;i++){
            int len=yuan[i+1]-yuan[i]-1;
            ll C=AC-su[i+1]-pr[i];
            if(check(pre[i],pr[i],suf[i+1],su[i+1],C)) ans+=len;
        }
        for(int i=1;i<=tot;i++){
            ll C=AC-pr[i-1]-su[i+1];
            if(check(pre[i-1],pr[i-1],suf[i+1],su[i+1],C)) ans++;
        }
        printf("%lld\n",ans);
        
        for(int i=1;i<=tot+5;i++) pre[i]=suf[i]=su[i]=yuan[i]=pr[i]=0;
    }

    return 0;
}

```

---

## 作者：xixisuper (赞：1)

# P11830 [省选联考 2025] 幸运数字 题解

夸一夸出题人的特殊性质，我 3min 会了 B 性质，5min 会了 A 性质，8min 会了正解。

## 思路

按照考场里的思路来说吧。

### 性质 B

你发现在这个集合中至多出现 $n$ 种不同的数，这启发你枚举中位数是哪一个，然后一个一个判断是否可行。

考虑如何判断，有一个很重要的性质：**如果想要令 $x$ 为最终的中位数，则让 $x$ 出现的次数最多一定不劣。**

证明上述性质是很容易的，显然如果 $x$ 已经是中位数，继续增加 $x$ 的个数答案不会改变；而如果 $x$ 不是中位数，则有可能通过增加 $x$ 的个数的方式使得中位数变成 $x$。

此时要想判断 $x$ 有没有可能成为中位数，只需要知道小于 $x$ 的数出现的次数范围以及大于 $x$ 的数出现的次数范围即可。假设小于 $x$ 的数出现的次数为 $[l,r]$ 次，大于 $x$ 的数出现的次数为 $[l',r']$ 次，则你可以分讨：

- 如果 $[l,r]$ 和 $[l',r']$ 有交，$x$ 显然可以成为中位数，只需要让小于的个数等于大于的个数即可。
- 如果 $[l,r]$ 和 $[l',r']$ 无交，则需要取相距最近的两个数作为小于的个数和大于的个数，然后判断中位数是否在中间为 $x$ 的那一部分即可。

于是你做完了性质 B，时间复杂度 $O(Tn\log n)$，瓶颈在于排序。

### 性质 A

因为限制了集合中出现的数不可能大于 $n$，所以你依旧可以枚举中位数是什么。

不过此时会有多个操作覆盖到我们枚举的中位数 $x$，怎么统计 $x$ 出现的次数呢？我们可以考虑把操作排序后丢进优先队列里去维护，边枚举中位数边更新这个优先队列即可。判断一个数是不是中位数的方式和性质 B 中完全一致。

于是你做完了性质 A，时间复杂度 $O(Tn\log n)$，瓶颈在于排序和优先队列。

### 正解

观察一下性质 A 我们能够发现，如果一段区间内所有的数都被同样的区间所覆盖，那么**这段区间内的所有数要么都可以成为中位数，要么都不可以成为中位数**。于是我们只需要把枚举中位数变成枚举有多少个不同的区间交即可，这一部分依然可以使用优先队列维护。

最后归到时间复杂度分析，由于总共只有 $n$ 个区间，所以区间交至多只有 $2n$ 个，于是时间复杂度为 $O(Tn\log n)$，瓶颈在于排序和优先队列。

## 代码

```cpp
#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>
#define ll long long
using namespace std;
const ll N=2e5+10;
struct node{
	ll numL,numR,cntL,cntR;
	friend bool operator >(const node &a,const node &b){
		return a.numR>b.numR;
	}
}pr[N];
inline bool cmp(node a,node b){
	if(a.numL==b.numL) return a.numR<b.numR;
	return a.numL<b.numL;
}
ll n;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0); 
	ll c,T;cin>>c>>T;
	while(T--){
		cin>>n;
		for(ll i=1;i<=n;i++) cin>>pr[i].cntL>>pr[i].cntR>>pr[i].numL>>pr[i].numR;
		sort(pr+1,pr+1+n,cmp);
		priority_queue<node,vector<node>,greater<node> > qu;
		ll premin=0,premax=0,sufmin=0,sufmax=0;
		ll nowcnt=0,top=1;
		for(ll i=1;i<=n;i++){
			sufmin+=pr[i].cntL;
			sufmax+=pr[i].cntR;
		}
		ll L,R,ans=0;
		while(top<=n||!qu.empty()){
			if(qu.empty()){
				L=pr[top].numL;
				sufmin-=pr[top].cntL;
				sufmax-=pr[top].cntR;
				nowcnt+=pr[top].cntR;
				qu.push(pr[top]);
				top++;
			}
			while(top<=n&&L==pr[top].numL){
				sufmin-=pr[top].cntL;
				sufmax-=pr[top].cntR;
				nowcnt+=pr[top].cntR;
				qu.push(pr[top]);
				top++;
			}
			R=(qu.top()).numR;
			if(top<=n) R=min(R,pr[top].numL-1);
			if(premax<sufmin||premin>sufmax){
				ll m;
				if(premax<sufmin){
					m=premax+sufmin+nowcnt;
					m=(m+1)>>1;
					if(m>=premax+1&&m<=premax+nowcnt) ans+=R-L+1;
				}
				else{
					m=premin+sufmax+nowcnt;
					m=(m+1)>>1;
					if(m>=premin+1&&m<=premin+nowcnt) ans+=R-L+1;
				}
			}
			else ans+=R-L+1;
			L=R+1;
			while(!qu.empty()&&(qu.top()).numR<L){
				premin+=(qu.top()).cntL;
				premax+=(qu.top()).cntR;
				nowcnt-=(qu.top()).cntR;
				qu.pop();
			}
		}
		cout<<ans<<"\n";
	}
	return 0;
} 
```

---

## 作者：happybob (赞：1)

考虑怎么判定 $x$ 是否可以成为中位数。

对于 $l_{i,2}\leq x\leq r_{i,2}$ 的 $i$，显然会取 $r_{i,1}$ 个 $x$，否则所有 $r_{i,2} < x$ 的 $i$ 都本质相同，$l_{i,2} > x$ 的 $i$ 也相同，于是可以得到两个区间分别表示 $<x$ 和 $>x$ 的数的个数在这个范围内，对这个东西解方程就能求出对应范围了。

值域很大，离散化后每段本质相同，双指针后判断即可。复杂度 $O(n \log n)$。

---

## 作者：modfish_ (赞：0)

## 思路
注意到特殊性质 A 给了我们一个提示：枚举可能成为中位数的答案。

不妨把所有 $l_{i,2},r_{i,2}+1$ 标在数轴上。容易发现，任意两个相邻点构成的**左闭右开区间**内的数，要么都可以成为中位数，要么不可以成为。只需要枚举每一段区间即可。

考虑假设当前枚举到的数为 $x$（因为一个区间的答案都一样，不妨用一个数表示）。一个显然的贪心策略是：对于所有 $i$ 满足 $x\in [l_{i,2},r_{i,2}]$，应当令 $b_i=x,a_i=r_{i,1}$，即选取尽可能多的 $x$。因为出现次数越多，成为中位数的机会越大。

不妨记 $m=\sum_{x\in [l_{i,2},r_{i,2}]}r_{i,1}$，表示可以选择的最多的 $x$。再记 $l_l=\sum_{r_{i,2}<x}l_{i,1},r_l=\sum_{r_{i,2}<x}r_{i,1}$，表示小于 $x$ 的**数的数量**的取值范围；再记 $l_r=\sum_{l_{i,2}>x}l_{i,1},r_r=\sum_{l_{i,2}>x}r_{i,1}$，表示大于 $x$ 的**数的数量**的取值范围。

考虑讨论何时区间合法。

- 显然 $m=0$ 时不合法。

- 若区间 $[l_l,r_l]$ 与 $[l_r,r_r]$ 有交，且 $m>0$，一定合法。此时可以令小于 $x$ 的数与大于 $x$ 的数数量相等，$x$ 一定可以是中位数。

- 否则，分两种情况
  - $r_l<l_r$，即小于 $x$ 的数无论如何都比大于 $x$ 的数少。显然可以贪心地让左右数的数量差最小，即取 $r_l$ 个比 $x$ 小的数，$l_r$ 个比 $x$ 大的数。那么应该有至少 $l_r-r_l$ 个 $x$ 才能保证 $x$ 是中位数。所以如果 $r_l+m\ge l_r$，区间合法，否则不合法。
  - $r_r<l_l$，即大于 $x$ 的数无论如何都比小于 $x$ 的数少。类似于上面的讨论，只不过因为中位数的定义，判定条件有些许变化：如果 $r_r+m\ge l_l+1$，区间合法，否则不合法。

于是直接在数轴上扫过去即可，$m,l_l,r_l,l_r,r_r$ 都很容易维护。时间复杂度 $O(n\log n)$。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int maxn = 2e5 + 5;

ll l1[maxn], r1[maxn], l2[maxn], r2[maxn];
pair<ll, int> vs[maxn << 1];
int tot = 0;

int main(){
    int c, T;
    scanf("%d %d", &c, &T);
    while(T --){
        int n;
        scanf("%d", &n);
        tot = 0;
        for(int i = 1; i <= n; i ++){
            scanf("%lld %lld %lld %lld", &l1[i], &r1[i], &l2[i], &r2[i]);
            vs[++ tot] = make_pair(l2[i], -i), vs[++ tot] = make_pair(r2[i] + 1, i);
        }
        sort(vs + 1, vs + tot + 1);
        ll lmin = 0, lmax = 0, rmin = 0, rmax = 0, mid = 0;
        for(int i = 1; i <= n; i ++) rmin += l1[i], rmax += r1[i];
        ll ans = 0, pre = 0;
        bool fl = false;
        for(int i = 1; i <= tot; i ++){
            if(fl) ans += vs[i].first - pre;
            if(vs[i].second < 0){
                int x = -vs[i].second;
                rmin -= l1[x], rmax -= r1[x];
                mid += r1[x];
            }else{
                int x = vs[i].second;
                lmin += l1[x], lmax += r1[x];
                mid -= r1[x];
            }
            while(i < tot && vs[i + 1].first == vs[i].first){
                i ++;
                if(vs[i].second < 0){
                    int x = -vs[i].second;
                    rmin -= l1[x], rmax -= r1[x];
                    mid += r1[x];
                }else{
                    int x = vs[i].second;
                    lmin += l1[x], lmax += r1[x];
                    mid -= r1[x];
                }
            }
            pre = vs[i].first;
            if(!mid) fl = false;
            else if(max(lmin, rmin) <= min(lmax, rmax)) fl = true;
            else if(lmax < rmin){
                if(lmax + mid >= rmin) fl = true;
                else fl = false;
            }else if(rmax < lmin){
                if(rmax + mid >= lmin + 1) fl = true;
                else fl = false;
            }
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```

---

## 作者：寄风 (赞：0)

就你考虑咋求中位数，考虑维护 $s1,s2,s3,s4,s$ 表示小于当前值的最小个数，最大个数，大于当前值的最小个数，最大个数，和可以取当前值的最大个数。

判断中位数的条件就是说首先你的 $s$ 要大于 $0$，然后去看 $s1-s4$ 和 $s2-s3$ 的正负，如果不一样则一定可以。然后分情况讨论，结果是 $\min(s4-s1-1,s3-s2-1,s2-s3,s1-s4) \leq s-1$ 时可以把这个数作为中位数。（注：若这个 $\min$ 式子中若 $s1-s4,s2-s3,s3-s2,s4-s1$ 有小于 $0$ 的，则这几项不参与 $\min$ 式的计算。

考虑到每一次从一个区间的端点到另一个区间的端点时，这五个东西的变化都是可以 $O(1)$ 求的，于是简单处理下就做完了。

时间复杂度 $O(n \log n)$，瓶颈在排序，将排序换成基数排序可实现线性。

这个东西应该是对的，我场上这么写过了所有样例，没拍出错。

等代码下发，HN 被加密了。

upd : 作者自己复现了一遍，通过了民间数据。

复现代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n , s1 , s2 , s3 , s4 , s , C , T;
const int N = 1e6 + 5;
vector<int>l[N] , r[N];
int la[N] , ra[N] , lb[N] , rb[N];
inline bool check(){
    if(!s) return 0;
    if((s1 - s4 < 0) ^ (s2 - s3 < 0)) return 1;
    int dw = LONG_LONG_MAX;
    if(s1 - s4 >= 0) dw = min(dw , s1 - s4);
    if(s2 - s3 >= 0) dw = min(dw , s2 - s3);
    if(s3 - s2 >= 0) dw = min(dw , s3 - s2 - 1);
    if(s4 - s1 >= 0) dw = min(dw , s4 - s1 - 1);
    // cerr<<"FK "<<dw<<'\n';
    return dw < s;
}
inline void solve(){
    for(int i = 0;i <= 2 * n;i++) l[i].clear() , r[i].clear();
    cin >> n;
    s1 = s2 = s3 = s4 = s = 0;
    int ss = 0;
    for(int i = 1;i <= n;i++){
        cin >> la[i] >> ra[i] >> lb[i] >> rb[i];
        ss += ra[i];
    }
    for(int i = 1;i <= n;i++){
        if(lb[i] > 0){
            s3 += la[i] , s4 += ra[i]; 
            continue;
        }
        if(rb[i] < 0){
            s1 += la[i] , s2 += ra[i]; 
            continue;
        }
        s += ra[i];
    }   
    vector<int>tp;
    tp.push_back(0);
    for(int i = 1;i <= n;i++) tp.push_back(lb[i]) , tp.push_back(rb[i]);
    sort(tp.begin() , tp.end());
    tp.erase(unique(tp.begin() , tp.end()) , tp.end());
    for(int i = 1;i <= n;i++){
        int ii;
        ii = lower_bound(tp.begin() , tp.end() , lb[i]) - tp.begin();
        l[ii].push_back(i);
        ii = lower_bound(tp.begin() , tp.end() , rb[i]) - tp.begin();
        r[ii].push_back(i);
    }
    for(auto v:l[0]) s3 -= la[v] , s4 -= ra[v];
    // cerr<<s1<<' '<<s2<<' '<<s3<<' '<<s4<<' '<<s<<'\n';
    int ans = 0;
    for(int i = 1;i < tp.size();i++){
        bool f = 0;
        if(check()){
            f = 1;
            // for(auto v:l[i]) s3 -= la[v] , s4 -= ra[v];
            for(auto v:r[i-1]) s1 += la[v] , s2 += ra[v];
            s = ss - s2 - s4;
            // cerr<<s1<<' '<<s2<<' '<<s3<<' '<<s4<<' '<<s<<'\n';
            if(check()) ans += tp[i] - tp[i - 1];
            else ans++;
        }
        for(auto v:l[i]) s3 -= la[v] , s4 -= ra[v];
        if(!f){
            for(auto v:r[i-1]) s1 += la[v] , s2 += ra[v];
        }
        s = ss - s2 - s4;
    }
    // cerr<<s1<<' '<<s2<<' '<<s3<<' '<<s4<<' '<<s<<'\n';
    // cerr<<check();
    if(check()) ans++;
    cout << ans << '\n';
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0) , cout.tie(0);
    cin >> C >> T;
    while(T--) solve();
    return 0;
}
```

---


# 无尽的生命

## 题目描述

逝者如斯夫，不舍昼夜！

叶良辰认为，他的寿命是无限长的，而且每天都会进步。

叶良辰的生命的第一天，他有 $1$ 点能力值。第二天，有 $2$ 点。第 $n$ 天，就有 $n$ 点。也就是 $S_i=i$。

但是调皮的小A使用时光机，告诉他第 $x$ 天和第 $y$ 天，就可以任意交换某两天的能力值。即 $S_x\leftrightarrow S_y$。

小A玩啊玩，终于玩腻了。

叶良辰：小A你给我等着，我有 $100$ 种办法让你生不如死。除非能在 $1$ 秒钟之内告知有多少对“异常对”。也就是说，最后的能力值序列，有多少对的两天 $x,y$，其中 $x<y$，但是能力值 $S_x>S_y$？

小A：我好怕怕啊。

于是找到了你。


## 说明/提示

样例说明

- 最开始是 $1,2,3,4,5,6\cdots$
- 然后是 $1,4,3,2,5,6\cdots$
- 然后是 $2,4,3,1,5,6\cdots$

符合的对是 $(1,4),(2,3),(2,4),(3,4)$。


- 对于 $30\%$  的数据，$x_i,y_i\le 2\times 10^3$；
- 对于 $70\%$  的数据，$x_i,y_i\le 10^5$；
- 对于 $100\%$ 的数据，$x_i.y_i\le 2^{31}-1$，$k\le 10^5$。

## 样例 #1

### 输入

```
2
4 2
1 4```

### 输出

```
4
```

# 题解

## 作者：IC_QQQ (赞：33)

### 求逆序对
但这肯定不是普通的求逆序对题目：数据范围太大了，会超时。

尽管数据范围很大，但是**k**不大，最多只牵涉到了**2k**个数。

我们举个例子：

![栗子](https://i.loli.net/2019/05/13/5cd8cf438322b46109.png)

需要交换的两组数是：1—6 , 4—9。

我们可以发现，数2、3可以看做一个**整体**，数7、8可以看做一个**整体**。

也就是说，一段**连续**的数，我们可以把它看做一个**整体**，记录下它的代表元**id**和权值**t**。

什么意思呢？我们来看处理之后应该是怎样的：

（1,1) ， (2,2) ， (4,1) ， (5,1) ， (6,1) ， (7,2) ， (9,1)

我们就把所有的连续区间记做了**二元组**。用这个区间最小的数作**代表元**，**权值**就是区间数的个数。

然后进行交换：

（6,1），（2,2），（9,1），（5,1），（1,1），（7,2），（4,1）

剩下的就是普通的求逆序对了。

别忘了离散化。

### 代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+5;
int n,st,tot;
struct aaa{
	int x,y;
}Q[N];//记录需要交换的数
int t[2*N],id[2*N];//t:权值。id:代表元
int s[2*N],row[22*N];
ll ans,c[2*N];

int query(int val){//离散化的查询
	return lower_bound(row+1,row+1+tot,val)-row;
}

void adds(int pos,ll w){//
	for(;pos<=tot;pos+=pos&-pos) c[pos]+=w;
	return;
}

ll asks(int pos){
	ll sum=0;
	for(;pos;pos-=pos&-pos) sum+=c[pos];
	return sum;
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&Q[i].x,&Q[i].y);
		s[i]=Q[i].x;s[i+n]=Q[i].y;
	}
	sort(s+1,s+1+2*n);
	st=unique(s+1,s+1+2*n)-(s+1);
	row[++tot]=s[1];t[tot]=1;
	for(int i=2;i<=st;i++){
		if(s[i]-s[i-1]>1){
			row[++tot]=s[i-1]+1;
			t[tot]=s[i]-s[i-1]-1;
		}
		row[++tot]=s[i];t[tot]=1;
	}
	for(int i=1;i<=tot;i++) id[i]=i;
	for(int i=1;i<=n;i++){
		int x=query(Q[i].x),y=query(Q[i].y);
		swap(t[x],t[y]);
		swap(id[x],id[y]);
	}
	for(int i=tot;i>=1;i--){
		ans+=asks(id[i]-1)*(ll)t[i];//注意，乘法 
		adds(id[i],(ll)t[i]);
	} 
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：ws_fqk (赞：19)

70分：

裸的逆序对，树状数组线段树归并排序均可过。

100分：

我们会发现，未被操作过的数不必一一统计，因为总有一个连续区间的数跟他具有相同的性质。

于是，我们先将被操作过的点存下来离散化，然后对这些点进行交换操作。

之后几乎就是普通的逆序对，树状数组存比I小的数的个数。分别计算hash后两个值之间一段产生的逆序对和端点产生的逆序对，加到答案中。

附代码：

```cpp

#include<iostream>
#include<algorithm>
#include<cstdlib>
#include<cstring>
#include<cstdio>
#include<cmath>
#define ll long long
using namespace std;
int hash[200005],b[200005],a[200005];
ll ans,tree[200005];
int n,m,cnt;
struct node {int x,y;} q[100005];
inline int read()
{
    int a=0,f=1; char c=getchar();
    while (c<'0'||c>'9') {if (c=='-') f=-1; c=getchar();}
    while (c>='0'&&c<='9') {a=a*10+c-'0'; c=getchar();}
    return a*f;
}
inline int find(int x)
{
    int l=1,r=m;
    while (l<=r)
    {
        int mid=(l+r)>>1;
        if (hash[mid]==x) return mid;
        else if (hash[mid]<x) l=mid+1; else r=mid-1;
    }
    return r;
}
inline int lowbit(int x)
{
    return x&(-x);
}
inline void add(int x,ll val)
{
    for (int i=x;i<=m;i+=lowbit(i)) tree[i]+=val;
}
inline ll query(int x)
{
    ll sum=0;
    for (int i=x;i;i-=lowbit(i)) sum+=tree[i];
    return sum;
}
int main()
{
    n=read();
    for (int i=1;i<=n;i++) a[++cnt]=q[i].x=read(),a[++cnt]=q[i].y=read();
    sort(a+1,a+cnt+1); 
    for (int i=1;i<=cnt;i++)
        if (a[i]!=a[i-1]) hash[++m]=a[i];
    for (int i=1;i<=m;i++) b[i]=i;
    for (int i=1;i<=n;i++)
    {
        int x=find(q[i].x),y=find(q[i].y);
        swap(b[x],b[y]);
    }
    add(b[m],1);
    for (int i=m-1;i;i--)
    {
        ll x=(ll)(hash[i+1]-hash[i]-1),p=query(i);
        ans=ans+(x*p);
        add(i,x);
        ans=ans+query(b[i]-1);
        add(b[i],1);
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：da32s1da (赞：8)

这个题用树状数组逆序对+离散化。下面先看看代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[200001],b[200001],d[200001],e,f[200001],g,hh,h[200001],m,x;
struct cc{   //离散化准备 
    long long p;
    long long q;
};
cc c[200001];
long long mmp(const cc & o, const cc & oo)  //排序 
{return o.p<oo.p;}
inline void rad(long long &noi)  //快读 
{
    bool mark=false;
    static char ch;
    while(ch=getchar(),ch<'0'||ch>'9') if(ch=='-') mark=true;
    noi=ch-'0';
    while(ch=getchar(),ch<='9'&&ch>='0') noi=(noi<<3)+(noi<<1)+ch-'0';
    if(mark) noi=-noi;
}
int main()
{
    rad(n);
    for(int i=1;i<=2*n;i++)
    rad(c[i].p),c[i].q=i,a[i]=i;    //离散化准备 
    sort(c+1,c+2*n+1,mmp);
    for(int i=1;i<=200000;i++) f[i]=1,b[i]=i;
    hh=c[1].p;
    for(int i=1;i<=2*n;i++)
    if(c[i].p!=hh)
    f[(++g)*2]=c[i].p-hh-1,hh=c[i].p;   //计算离散化后实际距离 
    g=0;
    for(int i=1;i<=2*n;i++)
    {
        if(c[i].p!=c[i-1].p)
        g++;d[c[i].q]=g;   //离散化 
    }
    //g是有几个不同数字 
    for(int i=1;i<=n;i++)
    swap(a[d[i*2-1]],a[d[i*2]]);    //交换离散化完后的值，*2之后解释 
    for(int i=1;i<=g;i++) b[i*2-1]=a[i]*2-1;      //将离散化后的数存下 
    for(int i=1;i<=2*g-1;i++)    //树状数组求逆序对 
    {
        e=0;m+=f[i];   //实际有多少个数字 
        for(int j=b[i]-1;j;j-=(j&(-j))) e+=h[j];
        for(int j=b[i];j<=g*2-1;j+=(j&(-j))) h[j]+=f[i];
        x+=f[i]*(m-e-f[i]);    //逆序对的实际对数是当前区间数字个数乘交换时经过几个数字 
    }
    printf("%lld\n",x);
    return 0;
}
```
\*2的原因？

将不同数字个数交叉在区间中


先来看这样一组数据

2 4 9 1 4

b[]=5 2 1 4 3

f[]=1 2 1 4 1

什么意思呢？

b[]表示离散化后的数组，注意区间也算

而f[]表示区间有几个数字，算答案的时候用

再来看这样

2 1 2 3 4

b[]=3 2 1 4 7 6 5

f[]=1 0 1 0 1 0 1

注意区间为0时，即使有逆序对，对答案也没有影响。


提醒：当企图打100分程序时，可以从70分的模板编几个大数据，过了基本就A了。


---

## 作者：ACAね (赞：5)

这题目比较坑爹。。。

第一眼看上去就是个裸的逆序对

然后打起来越看越不对。。。

然后L了半天才A.


[题目传送](https://www.luogu.org/problemnew/show/P2448)


思想:

先去重，然后离散化。然后倒序插入。但是在这里，离散化间消失的数字的答案还是要算，然后他们组成的新逆序对也要算进去。

先上代码

```cpp
    /*
        By Adscn~ 
    */
    #include<bits/stdc++.h>
    using namespace std;
    #define IL inline
    #define RG register
    #define gi getint()
    #define pi(k) putint(k)
    #define gc getchar()
    #define File(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)
    IL int getint()
    {
        RG int xi=0;
        RG char ch=gc;
        bool f=0;
        while(ch<'0'|ch>'9')ch=='-'?f=1:f,ch=gc;
        while(ch>='0'&ch<='9')xi=(xi<<1)+(xi<<3)+ch-48,ch=gc;
        return f?-xi:xi;
    }
    IL void putint(int k)
    {
        if(k<0)k=-k,putchar('-');
        if(k>10)putint(k/10);
        putchar(k%10+'0');
    }
    IL int max(RG int a,RG int b)
    {
        return a>b?a:b;
    }
    typedef long long ll;
    int cnt,cnt1;
    int c[200000+1];
    int now;
    void change(int,int);
    int lowbit(int);
    IL void push(RG int i)
    {
        change(now,i);
        now++;
    }
    IL void change(RG int i,RG int j)
    {
        for(; i <= cnt1; i+=lowbit(i))
            c[i] += j;
        return;
    }
    IL ll getsum(int i)
    {
        ll ans = 0;
        for(; i; i-=lowbit(i))
            ans += c[i];
        return ans;
    }
    IL int lowbit(RG int k)
    {
        return k&(-k);
    }//树状数组
    int a[200001];
    int x[200001],y[200001];
    int hash[200001],qc[200001];
    map<int,int> hash1;
    int main(void)
    {
        RG int n=gi,i;
        for(i=1; i<=n; i++)x[i]=qc[++cnt]=gi,y[i]=qc[++cnt]=gi;
        sort(qc+1,qc+cnt+1);//去重
        for(i=1; i<=cnt; i++)if(qc[i]!=qc[i-1])hash[++cnt1]=qc[i];//建立从离散化后的新数组到原数组的值的映射
        for(i=1;i<=cnt1;i++)hash1[hash[i]]=i;//建立相反映射
        for(i=1; i<=cnt1; i++)a[i]=i;
        for(i=1; i<=n; i++)swap(a[hash1[x[i]]],a[hash1[y[i]]]);//交换新数组的值
        change(a[cnt1],1);
        ll ans=0;
        for(i=cnt1-1; i; i--)
        {
            ll x=(ll)(hash[i+1]-hash[i]-1),p=getsum(i);//x是两个数之间没有被离散化的数的个数,p是前比它小的数的个数。
            ans+=x*p;//明显，每两个都是一对逆序对
            change(i,x);
            ans+=getsum(a[i]-1);//下面是对映射后的离散化数组进行的单独逆序对计算
            change(a[i],1);
        }
        printf("%lld",ans);
        return 0;
    }
```
解释一下几个问题:

Q1.为什么76行的x是hash[i+1]-hash[i]-1

A1.因为即使离散化了，但是两个数之中的数没有被交换，还是原来的那些数。举例：

比如
1 2 3 4 5 6 7 8

交换 4 7

交换 1 4

-> 7 2 3 1 5 6 4 8

但是之间还是5,6

Q2.为什么87行是change(i,x),而不是change(i,1)，也不是change(a[i],x)

A2.因为既然他们之间有x个数，树状数组求sum的时候必须要将其计算在内，所以把他们加在他们开始的数的编号i上,这样在计算某数前比他大的数的个数时，就可以一次性加上x个比他大的数。至于为什么不是change(a[i],1)，参见A1.

Q3.如何用树状数组求逆序对

A3.请阅读推荐博客[传送门](http://blog.csdn.net/SeasonJoe/article/details/50193789?fps=1&locationNum=15)


---

## 作者：kbzcz (赞：4)

~~csp初赛前三天还在刷水题~~

---
### 思路

显然，题目是要求求交换过后的数列的逆序对个数。

考虑朴素求逆序对，用的权值树状数组。但这题的数据范围是 $1\le x_i,y_i\le 2^{31}-1$，所以必须要离散化，但是离散化后就求不到那些**并没有被交换的数对答案的贡献**，所以我们考虑把被交换的数和没被交换的数分开计算。


------------

被操作过的数之间的逆序对个数显然离散化+树状数组就可以求了，所以这题的难点是求没被交换过的数和被交换过的数之间的逆序对个数。

![](https://cdn.luogu.com.cn/upload/image_hosting/wnyb9hb0.png)

假设一个数往前交换，红色圈是一个数的原来位置和所有交换完成后的位置。可以发现，因为中间的数并没有被交换过，所以不会产生逆序对，只有交换后的数会对中间**没被交换的每一个数**都产生一个逆序对，因为那个数的值比中间的都大，且在他们前面。    

往后交换同理。

综上，我们先把每个数离散化，并记录原来的位置和交换完后的位置。用树状数组求交换过的数的逆序对，再用一个循环求每个数到他原来位置之间没被交换的数的个数，并累加到答案中。

---

## 代码


```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=2e5+5;
struct node {
	int x,y;
}a[N];
int n;
LL ans;
int pos[N];
int c[N];
vector<int> ls;
int val(int x) {return lower_bound(ls.begin(),ls.end(),x)-ls.begin()+1;}
void lsnum() {
	sort(ls.begin(),ls.end());
	ls.erase(unique(ls.begin(),ls.end()),ls.end());
	for(int i=1;i<=n;i++) {
		a[i].x=val(a[i].x);
		a[i].y=val(a[i].y);
	}
}
int lowbit(int k){return k&-k;}
void add(int x,int k) {
	while(x<=2*n) {
		c[x]+=k;
		x+=lowbit(x);
	}
}
int query(int x) {
	int sum=0;
	while(x) {
		sum+=c[x];
		x-=lowbit(x);
	}
	return sum;
}
int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;i++) {
		scanf("%d%d",&a[i].x,&a[i].y);
		ls.push_back(a[i].x);
		ls.push_back(a[i].y);
	}
	lsnum();
	for(int i=0;i<ls.size();i++) pos[i+1]=ls[i];
	for(int i=1;i<=n;i++) swap(pos[a[i].x],pos[a[i].y]);
	for(int i=0;i<ls.size();i++) {
		int x=pos[i+1],y=ls[i];
		ans+=abs(y-x)-abs(val(x)-(i+1));//求没被交换的数的贡献
	}
	for(int i=ls.size();i>=1;i--) {
		ans+=query(val(pos[i])-1);
		add(val(pos[i]),1);
	}
	printf("%lld",ans);
	return 0;
}
```




---

## 作者：lwyz123 (赞：4)

#### ~~听说 csp之前发题解会++rp~~
### 对于这个玄学题 
在AC之前 我用了个错误的方法，忘记统计中间不变的数据

然后 就有 一个 不同于其他题解的做法

~~只是又臭又长罢了~~
set 来去重，维护单调上升的序列
map 来统计 改变前的 位置

然后我发现当 val！=1 时我逆序对求不对了

回头重新学了遍树状数组逆序对，把之前让我懵逼的做法给否了。。

重新根据原理想到了正确的做法

你可以正着，也可以到着；

然后你发现对于 val!=1 的单调上升序列

他们对答案的贡献是前面比他大的个数* val 
然后 

此题可做

下面代码未优化

如果想不懂前面的改变，可以看一下其他大佬代码


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <set>
#include <map> 
#define int long long 
using namespace std;
void r(int &x)
{
	char a;
	int f=1;
	while((a=getchar())<'0'||a>'9')if(a=='-')f=-1;
	x=a-48;
	while((a=getchar())>='0'&&a<='9')
	x=(x<<3)+(x<<1)+a-48;
	x=x*f;
}
set<int>st;
map<int,int>ma;
int x[405000],y[405000];
int n,cnt;
struct edge{
	int sum,id,val;
}e[405000];
bool cmp(edge x,edge y)
{
	return x.sum<y.sum;
}
int sum[405000];
int lowbit(int x){return x&(-x);}
int tot;
void modify(int x,int v)
{
	for(;x<=tot;x+=lowbit(x)) sum[x]+=v;
}
int query(int x)
{
	int ans=0;
	for(;x;x-=lowbit(x)) ans+=sum[x];
	return ans;
}
signed main()
{
	r(n);
	for(int i=1;i<=n;i++)
	{	
		r(x[i]),r(y[i]);
		st.insert(x[i]);
		st.insert(y[i]);
	}
	set<int>::iterator it;
	while(!st.empty())
	{		
		it=st.begin();
		ma[*it]=++cnt;
		e[cnt].id=cnt;
		e[cnt].sum=(*it);
		e[cnt].val=1;
		st.erase(it);
	}
	tot=cnt;
	for(int i=1;i<=cnt;i++)
	{
		if(e[i].sum-e[i-1].sum!=1)
		{
			e[++tot].sum=e[i-1].sum+1;
			e[tot].val=e[i].sum-e[i-1].sum-1;
		}
	}
	sort(e+1,e+tot+1,cmp);
	for(int i=1;i<=tot;i++) ma[e[i].sum]=i,e[i].id=i;
	for(int i=1;i<=n;i++)
	{	
		swap(e[ma[x[i]]].sum,e[ma[y[i]]].sum);
		swap(ma[x[i]],ma[y[i]]);
	}
	sort(e+1,e+tot+1,cmp);
	int ans=0;
	for(int i=tot;i>=1;i--)
	{			
		modify(e[i].id,e[i].val);
		ans+=(query(e[i].id)-e[i].val)*e[i].val;
	}
	cout<<ans<<"\n";
}



```


---

## 作者：叶枫 (赞：3)

## 写在前面

这一篇没有什么好东西，~~为什么没人写Hash~~

# $Idea$

因为本题求的是**逆序对**,重点是**离散化**，不是么？![ts.png](https://i.loli.net/2019/09/21/GZBd691o2I3CFwv.png)

于是可以用**Hash**来处理本题？

- 裸的树状数组和归并有$70\;pts$![裸的.png](https://i.loli.net/2019/09/29/DQV8ZUtFbfpgzOC.png)是吧

- 根据[这一篇题解](https://www.luogu.org/blog/IC-QQQ/solution-p2448)，我们可以得到一种好的做法

这里我采用**Hash**

可以看看记录

![jl.png](https://img.langlangago.xyz/2019/09/29/5d908ffd37d8a.png)

开$O2$的$74\;ms$![悠闲.gif](https://i.loli.net/2019/09/27/Qp2FNJftigzaGyB.gif)

# $Code$

```cpp
int Hash[maxn<<1],c[maxn<<1],l[maxn<<1];
int cnt,tot,n,m;
pair<int,int> p[maxn];
inline void add(int x,int v){
	for(int i=x;i<=m;i+=(-i)&i)
		c[i]+=v;
}
inline ll ask(int x){
	int ans=0;
	for(int i=x;i;i-=i&(-i))
		ans+=c[i];
	return ans;
}
signed main(){
	int k=read();
	for(int i=1;i<=k;i++){
		p[i].first=read(); p[i].second=read();
		Hash[++cnt]=p[i].first;
		Hash[++cnt]=p[i].second;//先都放入Hash数组里，之后排序去重
	}
	sort(Hash+1,Hash+cnt+1);
	m=unique(Hash+1,Hash+cnt+1)-Hash-1;
	for(int i=1;i<=m;i++) l[i]=i;//记录原始状态
    for(int i=1;i<=k;i++){
        int pos1=lower_bound(Hash+1,Hash+1+m,p[i].first)-Hash;
        int pos2=lower_bound(Hash+1,Hash+1+m,p[i].second)-Hash;
        swap(l[pos1],l[pos2]);//找到对应位置进行相应操作
    }
    ll ans=0;
    for(int i=m;i>=1;i--){
        ans+=ask(l[i]-1);//单点求逆序对
        add(l[i],1);//更新单点
        ll len=Hash[i]-Hash[i-1]-1;//求连续区间长度
        ans+=len*ask(i-1);//连续的不变区间，可以将它看作 i 这个数！
        if(i!=1) add(i-1,len);//最后一个不用更新了（也不能更新，会在更新中死循环，因为0的lowbit是0）
    }
    printf("%lld",ans);
	return 0;
}
```

$$
The \quad End
$$

$$
\text{愿意用一支黑色的铅笔,画一出沉默舞台剧-《不要说话》陈奕迅}
$$



---

## 作者：aiyougege (赞：3)

### Solution
忘了可以树状数组直接做了.所以写了很麻烦的线段树.
大概写一下怎么做, 因为细节比较多.

我们发现一次交换的实际上是交换了两个位置上的数.
我们可以将所有的位置分成三类:
1. 有的位置会被改变(交换), 也对答案有贡献;
2. 有的位置不会被改变, 也不会对答案有贡献;
3. 有的位置不会被改变, 但是对答案有贡献.


1. 第一类是所有的操作会交换的位置;
2. 第二类是被改变的第一个和最后一个位置往左和往右的数;
3. 第三类是不会被直接改变, 但是其左右都有被改变的数.

举个例子：交换2和5位置, 数列变成$1,5,3,4,2,6,7,\cdots$.
位置$2, 5$属于第一类, 位置$1,6,7,\cdots$属于第二类, 位置$3, 4$属于第三类(因为与5位置形成逆序对)

- 对于不会被改变也没有影响的数, 忽略存在就好了.
- 对于不会被改变但是有影响的位置, 这些位置的行为表现出来像是一个**整体**(会**同时对另一个位置产生或不产生逆序对**).
所以就把他们**捆**起来, 看成是一个**特殊的数字**就好了.

所以就将这些涉及到的位置离散化, 在离散化后按要求**交换这些位置上的数**形成一个数列,利用**树状数组/线段树**求逆序对即可.

至于怎么离散化, 看代码就好了
### Code
```c++
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 1e6;
struct Node {
    long long val;
    Node *ls, *rs;
    Node(int _v = 0, Node *_ls = nullptr, Node *_rs = nullptr) :
        val(_v), ls(_ls), rs(_rs) { }
    void pushup() {
        val = ls->val + rs->val;
    }
    void mod(int k) { val += k; }
};
class Tree { // 普通的单调修改区间查询线段树
    int n;
    Node* root;
 #define LS l, mid, node->ls
 #define RS mid + 1, r, node->rs
    void build(int l, int r, Node* node) {
        if (l == r) return;
        int mid = l + r >> 1;
        node->ls = new Node();
        node->rs = new Node();
        build(LS), build(RS);
    }
    void insert(int l, int r, Node* node, int p, int k) {
        if (l == r) return node->mod(k);
        int mid = l + r >> 1;
        if (p <= mid) insert(LS, p, k);
        if (p >  mid) insert(RS, p, k);
        node->val = node->ls->val + node->rs->val;
    }
    long long query(int l, int r, Node* node, int L, int R) {
        if (l >= L and r <= R) 
            return node->val;
        int mid = l + r >> 1;
        long long res = 0;
        if (L <= mid) res += query(LS, L, R);
        if (R >  mid) res += query(RS, L, R);
        return res;
    }
  public:
    Tree(int _n) : n(_n), root(new Node()) {}
    void build() {
        build(1, n, root);
    }
    long long query(int l, int r) {
        return query(1, n, root, l, r);
    }
    void insert(int p, int k) {
        insert(1, n, root, p, k);
    }
};
struct Operate {
    int l, r;
    Operate(int _ = 0, int __ = 0) :
        l(_), r(__) {}
}Opt[N];
struct Element {
    int v, siz; 
    Element(int _v = 0, int _s = 0) :
        v(_v), siz(_s) { }
    bool operator < (const Element& o) const {
        return v < o.v;
    }
}P[N];

int A[N], seq[N];

int main () {
    int n;
    scanf("%d", &n);
    int tot = 0;
    for (int i = 1, u, v, c; i <= n; i += 1) {
        scanf("%d%d", &u, &v);
        Opt[i] = Operate(u, v);
        A[++tot] = u, A[++tot] = v;
    }
    sort(A + 1, A + tot + 1);
    int cnt = unique(A + 1, A + tot + 1) - A - 1; // 被直接交换的位置, 也就是第一类
    int total = 0;
    for (int i = 1; i <= cnt; i += 1) {
        P[++total] = Element(A[i], 1); // 第一类
        if (A[i + 1] > A[i] + 1) // A[i] 和A[i+1]之间的是第三类
            P[++total] = Element(A[i] + 1, A[i + 1] - A[i] - 1);  // A[i+1]-A[i]-1是这一段的个数
    }
#define Find(x) lower_bound(P + 1, P + total + 1, Element(x, 0)) - P
    Tree* T = new Tree(total); // 建线段树
    T->build();
    for (int i = 1; i <= total; i += 1)
        seq[i] = i;
    for (int i = 1, u, v; i <= n; i += 1) {
        u = Find(Opt[i].l), v = Find(Opt[i].r); // 按要求交换
        swap(seq[u], seq[v]);
    }
    long long res = 0;
    for (int i = 1; i <= total; i += 1) {
        T->insert(seq[i], P[seq[i]].siz); 
        res += 1ll * P[seq[i]].siz * T->query(seq[i] + 1, total);
    }
    printf("%lld\n", res);
    return 0;
}
```

---

## 作者：__Star_Sky (赞：2)

双倍经验：CF540E

### 题意简述

给定一个数列 $1,2,3\dots n$ 和 $k$ 次操作，每次操作交换数列中下标为 $x$ 和 $y$ 的数。求最终数列中有多少个逆序对。其中 $n,x,y\le2^{31}-1,k\le10^5 $。

### 前置知识
树状数组，离散化

### Solution

显然可以用树状数组求逆序对。但是难点在于原数列中可能有很多元素没有被交换过，要考虑怎么计算它们的贡献。

注意到操作数 $k\le10^5$，因此最多只有 $2\times10^5$ 个数被交换了。这样，最多会产生 $2\times10^5-1$ 个区间，处于这些区间之间的数都没有被交换过。设区间 $[l,r]$ 中的所有元素都没有被交换过，显然这些数两两之间都不可能产生逆序对，因此考虑用任意一个 $x\in[l,r]$ 代替这些数，并将 $x$ 的权值设为 $r-l+1$ 。对于交换过的数，权值设为 $1$ 即可。这样一来，我们就得到了一个新的序列，这个序列仅有不超过 $4\times10^5-1$ 个数，离散化之后就可以使用权值树状数组来求逆序对了。注意对于每个 $x$ 统计贡献时要乘上 $x$ 的权值。

时间复杂度 $O(k \log{k})$。

### Code
```
#include<bits/stdc++.h>
#define int long long
#define lowbit(x) x&-x
#define INF 0x7fffffff
using namespace std;
const int N=1e6+10;
struct node{int x,y;}t[N];
int n;
int a[N],b[N],c[N];
void add(int x,int k) {while(x<=n) c[x]+=k,x+=lowbit(x);}
int get_sum(int x) {int res=0;while(x>=1) res+=c[x],x-=lowbit(x);return res;}
int s[N],siz[N];//siz[x]表示x的权值
signed main()
{
	int k;
	scanf("%lld",&k);
	for(int i=1;i<=k;i++) 
		scanf("%lld%lld",&t[i].x,&t[i].y),
		a[i*2-1]=t[i].x,a[i*2]=t[i].y;
	memcpy(b,a,sizeof(b));
	sort(b+1,b+2*k+1);
	n=unique(b+1,b+2*k+1)-b-1;
	for(int i=1;i<=n;i++) a[i*2-1]=b[i];
	n=n*2-1;
	for(int i=1;i<=n;i++) 
	{
		if(i&1) continue;
		if(a[i+1]==a[i-1]+1) a[i]=INF;
		else a[i]=a[i-1]+1,s[i]=a[i+1]-a[i-1]-1;
	}
	memcpy(b,a,sizeof(b));
	sort(a+1,a+n+1);
	int tmp=n;
	while(a[n]==INF) n--;
	for(int i=1;i<=tmp;i++)
	{
		if(b[i]==INF) continue;
		int idx=lower_bound(a+1,a+n+1,b[i])-a;
		siz[idx]=s[i];
	}
	for(int i=1;i<=n;i++) if(!siz[i]) siz[i]=1;
	memcpy(b,a,sizeof(b));
	for(int i=1;i<=k;i++)
	{
		int idx=lower_bound(b+1,b+n+1,t[i].x)-b;
		int idy=lower_bound(b+1,b+n+1,t[i].y)-b;
		swap(a[idx],a[idy]);
	}
	int ans=0;
	for(int i=n;i>=1;i--)
	{
		int idx=lower_bound(b+1,b+n+1,a[i])-b;
		ans+=siz[i]*get_sum(idx-1);
		add(idx,siz[i]);
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Adelaide_Black (赞：2)

### 题意简述

看到题目显而易见是求逆序对个数。

### 思路分析

看到数据范围 $x_i,y_i \le 2^{31}-1$，$k \le 10^5$。数据值域大但是个数少，且与数据之间的大小关系有关，因此考虑离散化。

#### 离散化简单介绍

离散化实际就是一种映射，当数据值域过大而个数有限时，可以尝试离散化。

具体过程以此题为例。假设给出这么一组数据：

```
2

123456789 123456

987654321 123456

```

首先将所有出现过的数收集起来，存进 $a$ 数组，并进行排序，然后再**去重**保存进 $pos$ 数组当中。

![](https://cdn.luogu.com.cn/upload/image_hosting/wykzmz13.png)

接下来就可以建立映射关系。**将数值大的数在 $num$ 数组中用数值小的数代替，但各个数之间的大小关系不变**，接下来交换操作先用二分答案在 $pos$ 数组中检索，然后通过映射在 $num$ 数组中进行交换。

![](https://cdn.luogu.com.cn/upload/image_hosting/ji9dhfzo.png)

最终被交换过的数之间的逆序对在 $num$ 数组中求即可。

#### 被交换的数与未被交换的数之间的逆序对

考虑每个被交换的数对答案的贡献。

设 $x<y$，当 $x$ 和 $y$ 交换后。

对于 $x$ 来说， $x \sim y$ 之间所有未被交换的数都比 $x$ 大，形成逆序对。

对于 $y$ 来说，$x \sim y$ 之间所有未被交换的数都比 $y$ 小，形成逆序对。

逆序对个数都为 $x \sim y$ 之间所有未被交换的数。

温馨提示：以下主要为代码实现讲解，本质思想同上。

对于交换过后的 $num$ 数组，$num_i$ 表示的是位置 $pos_i$ 上当前所在的数在 $num$ 数组中对应的数。记数 $x$ 为位置 $pos_i$  上当前所在的数。

$pos_{num_i}$ 表示数 $x$ 现在所在的位置。

$pos_i$ 表示数 $x$ 原来在的位置。

$\left\vert pos_i-pos_{num_i}-1\right\vert$ 表示两个位置间所有的数。

$\left\vert num_i-i-1\right\vert$ 表示两个位置间所有被交换过的数。

因此所有未被交换的数就是 $\left\vert pos_i-pos_{num_i}-1\right\vert - \left\vert num_i-i-1\right\vert$。

### code

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
struct A{
	int x,y;
}a[100005];
int k,pos[200005],num[200005],cnt,len;
int t[100005];
void add(int x){
	for(;x<=len;x+=(x&-x)) t[x]+=1;
}
long long sum(int x){
	long long ans=0;
	for(;x;x-=(x&-x)) ans+=t[x];
	return ans;
}
int find(int x){
	int l=1,r=len;
	while(l<r){
		int mid=(l+r)>>1;
		if(pos[mid]<x) l=mid+1;
		else if(pos[mid]>x) r=mid-1;
		else return mid;
	}
} 
int main(){
	scanf("%d",&k);
	for(int i=1;i<=k;i++){
		scanf("%d%d",&a[i].x,&a[i].y);
		num[++cnt]=a[i].x;
		num[++cnt]=a[i].y;
	}
	sort(num+1,num+cnt+1);
	for(int i=1;i<=cnt;i++){
		if(num[i]==num[i-1]) continue;
		pos[++len]=num[i];
	}
	for(int i=1;i<=len;i++) num[i]=i;
	for(int i=1;i<=k;i++){
		int pos1=find(a[i].x);
		int pos2=find(a[i].y);
		swap(num[pos1],num[pos2]);
	}
	long long ans=0;
	for(int i=len;i>=1;i--){
		add(num[i]);
		ans+=sum(num[i]-1);
		ans+=abs(pos[num[i]]-pos[i]-1)-abs(num[i]-i-1); 
	} 
	cout<<ans<<endl;
	return 0;
}
```





---

## 作者：zeromaker (赞：2)

题意就是给定若干次交换操作，求出交换之后序列的逆序对的个数，当然由于x和y很大的关系，这题是不能够直接统计逆序对的，我们需要先进行一次离散化，我们发现这样的一个序列：54123和序列：54111的逆序对数是一样多的，所以我们将每次交换的两个数记录下来，如果发现有一段数字没有被交换，那么就记录这段数字中最小的那个数字，再把长度记录下来，（如序列54123将被离散化为：（（5,1），（4,1），（1,3）），第一个数字表示离散化之后的数值，第二个数字表示该数值的长度。）最后使用树状数组（需要再次离散化）或者归并排序统计逆序对的时候，只要把求出来的某个数字产生的逆序对数乘以该数字的长度，累加就可以求出总的逆序对的个数了。

另附树状数组求逆序对的文章一份：http://blog.csdn.net/acdreamers/article/details/8520096

（注：再使用该大触博客中所写的离散化方法之前，还需要跑一遍上面的离散化方法，也就是树状数组要两次离散化=A=，当然也可能只是我自己想多了）

附上自己的代码一份

```cpp

#include<iostream>  
#include<stdio.h>  
#include<string.h>  
#include<string>  
#include<stdlib.h>  
#include<algorithm>  
#include<math.h>  
#include<map>  
#define int long long  
using namespace std;  
  
const int Maxn=500010;  
map <int,int>m;  
struct T  
{  
    int len;  
    int v;  
    int order;  
}a[Maxn];  
int cnt;  
long long c[Maxn];  
T aa[Maxn];  
long long sum[Maxn];  
long long n;  
  
int lowbit(int x)  
{  
    return x&(-x);  
}  
  
void update(int t,int value)  
{  
    int i;  
    for(i=t;i<=cnt;i+=lowbit(i))  
    {  
        c[i]+=value;  
    }  
}  
  
long long getsum(int x)  
{  
    int i;  
    long long temp=0;  
    for(i=x;i>=1;i-=lowbit(i))  
    {  
        temp+=c[i];  
    }  
    return temp;  
}  
  
bool cmp(T x,T y)  
{  
    return x.v<y.v;  
}  
  
main()  
{  
    int k;  
    scanf("%lld",&k);  
      for (int i=1;i<=k;i++)  
    {  
        int t1,t2;  
        scanf("%lld%lld",&t1,&t2);  
        int tt1=t2,tt2=t1;  
        if (m[t1]==0)  
            m[t1]=t1;  
        if (m[t2]==0)  
            m[t2]=t2;  
        int x1=m[tt1];  
        int x2=m[tt2];  
        m[t1]=x1;  
        m[t2]=x2;  
        n=max(n,(long long)t1);  
        n=max(n,(long long)t2);  
    }  
    map<int,int>::iterator it;  
    int last=-1;  
    for(it=m.begin();it!=m.end();++it)  
    {  
        if (last!=-1 && it->first!=last+1)  
        {  
            cnt++;  
            a[cnt].v=last+1;  
            a[cnt].len=it->first-last-1;  
            a[cnt].order=cnt;  
            last=it->first;  
        }  
        cnt++;  
        a[cnt].v=it->second;  
        a[cnt].len=1;  
        a[cnt].order=cnt;  
        last=it->first;  
    }  
    sort(a+1,a+cnt+1,cmp);  
    for(int i=1;i<=cnt;i++)   
    {  
        aa[a[i].order].v=i;  
        aa[a[i].order].len=a[i].len;  
    }  
    for (int i=1;i<=cnt;i++)  
    {  
        sum[i]=sum[i-1]+aa[i].len;  
    }  
    memset(c,0,sizeof(c));  
    long long ans=0;  
    for(int i=1;i<=cnt;i++)  
    {      
        update(aa[i].v,aa[i].len);  
        ans+=(sum[i]-getsum(aa[i].v))*a[i].len;  
    }  
    printf("%lld\n",ans);  
}  

```

---

## 作者：Invoker (赞：2)

很容易看出这是一道逆序对的题，然而数据范围并不允许直接树状数组或者归并排序。

于是我们想到离散化。

对于小于最小值或者大于最大值的，显然不会对逆序对产生什么影响。

对于中间的数，我们开一个数组进行离散化，然后用树状数组维护一下就可以了。

核心代码：

```cpp

T.modify(a[n],1);
for1(i,n-1,1)
{  
    LL len=num[i+1]-num[i];  
    ans+=((len-1)*T.query(i));  
    T.modify(i,len);
    ans+=T.query(a[i]-1); 
    T.modify(a[i],1);
}
```cpp

---

## 作者：qczrz6v4nhp6u (赞：1)

双倍经验：CF540E。

### Solution

注意到原序列中有很多形如 $u,u+1,\cdots,v$ 的段（即这些段没有被操作），而这些部分内部并不会产生逆序对，我们从这入手考虑。

设上述段对应的区间是 $[l,r]$，则一个容易注意到的性质是：如果存在 $p,q$ 满足 $l\le q\le r$ 且 $(p,q)$ 是逆序对，那么 $\forall l\le i\le r,(p,i)$ 是逆序对。

证明注意到 $p<l$ 且 $a_p>r$ 即可。对于 $(q,p)$ 是逆序对的情况也有类似的结论成立。

由以上的结论，$[l,r]$ 内的数在计算逆序对时并没有本质不同。我们可以把每段 $[l,r]$ 缩成任意一个 $[u,v]$ 内的数来计算逆序对，计算贡献时乘上 $(r-l+1)$ 即可。

缩完后的序列只有 $O(k)$ 个数，直接正常求逆序对即可。时间复杂度 $O(k\log k)$。

### Code

```cpp
#include<bits/stdc++.h>
#define Tp template<typename T>
#define Ts template<typename T,typename... _T>
using namespace std;
using ll=long long;
using ull=unsigned long long;
char buf[1<<20],*p1=buf,*p2=buf;
#define getchar() (p1==p2&&(p2=buf+fread(p1=buf,1,1<<20,stdin),p1==p2)?EOF:*p1++)
Tp inline void read(T& x){
    x=0;char c=getchar();bool f=0;
    for(;c<48||c>57;c=getchar())c=='-'&&(f=1);
    for(;c>47&&c<58;c=getchar())x=(x<<1)+(x<<3)+(c^48);
    f&&(x=-x);
}
Ts inline void read(T& x,_T&... y){read(x),read(y...);}
Tp inline void assign(T *a,int n,T b){while(n--)*a++=b;}
Tp inline void copy(T *a,T *b,int n){while(n--)*a++=*b++;}
Tp inline void ckmin(T &a,T b){b<a&&(a=b);}
Tp inline void ckmax(T &a,T b){a<b&&(a=b);}
const int N=1e5+5;
int n,a[N],b[N],va[N],vb[N],p[N<<1];
int num[N<<1],len;
int c[N<<2];
void add(int x,int k){
	x=(len<<1)-x;
	for(;x<(len<<1);x+=x&-x)
		c[x]+=k;
}
int ask(int x){
	x=(len<<1)-x;
	int res=0;
	for(;x;x-=x&-x)
		res+=c[x];
	return res;
}
int val(int x){return lower_bound(num+1,num+len+1,x)-num;}
int main(){
	read(n);
	for(int i=1;i<=n;i++){
		read(a[i],b[i]);
		num[++len]=a[i];
		num[++len]=b[i];
	}
	sort(num+1,num+len+1);
	len=unique(num+1,num+len+1)-num-1;
	for(int i=1;i<=n;i++){
		va[i]=val(a[i]);
		vb[i]=val(b[i]);
		p[va[i]]=(va[i]<<1)-1;
		p[vb[i]]=(vb[i]<<1)-1;
	}
	for(int i=1;i<=n;i++)
		swap(p[va[i]],p[vb[i]]);
	ll ans=0;
	for(int i=1;i<=len;i++){
		ans+=ask(p[i]);
		add(p[i],1);
		if(i<len){
			ans+=ask(i<<1)*(num[i+1]-num[i]-1ll);
			add(i<<1,num[i+1]-num[i]-1);
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：SegTre (赞：1)

前置知识：树状数组求逆序对。给定一个有 $n$ 个数的序列，怎么求逆序对？我们从后往前处理数组，假设当前的数大小为 $x$，之前处理的数有多少个小于 $x$ 的就新产生了多少个逆序对，因为这些数都满足下标大于当前数且数值小于当前数。所以我们开一个大小等于值域的树状数组，维护先前小于当前数的个数，然后累积答案即可。

# Solution
但是 $2^{31}$ 的值域，数组承受不起，于是考虑离散化。只计算题目中出现数字的逆序对是会出问题的，因为没有改变位置的数也可能对答案产生贡献。我们先对题目中出现过的数字进行排序，记为 $num_{i}$，显然 $i \leqslant 2k$，然后离散化 $num$ 数组记为 $d$ 数组。再按照题目交换 $d_{x_i}$ 和 $d_{y_i}$，如果不考虑没交换位置的数，答案显然是序列 $d$ 的逆序对数，接下来考虑没交换位置的数对答案产生的贡献。
![](https://cdn.luogu.com.cn/upload/image_hosting/005094wu.png)

这是交换后的数组。若 $num_{d_i}> num_i$，那么这两个数之间没有被交换的数个数为 $num_{d_i}-num_i-(d_i-i)$，这些数都比 $num_{d_i}$ 小，统计进答案；若 $num_{d_i}< num_i$ ,那么这两个数之间没有被交换过的数个数为 $num_{i}-num_{d_i}-(i-d_i)$，这些数都比 $num_{d_i}$ 大，统计进答案。

记得开长整型。

# Code
```cpp
#include<cstdio>
#include<cctype>
#include<algorithm>
#define int long long
using namespace std;
const int N=1e5+5;
inline int read() {
	int res,sign=1;char c;
	while(!isdigit(c=getchar())) if(c=='-') sign=-1;res=c^48;
	while(isdigit(c=getchar())) res=(res<<3)+(res<<1)+(c^48);
	return res*sign;
}
int tot,a[N],b[N],c[N],num[N<<1],d[N];
inline void swap(int &x,int &y) {
	int tmp=x;
	x=y,y=tmp;
}
int find(int x) {
	int l=1,r=tot,mid;
	while(l<=r) {
		mid=l+r>>1;
		if(num[mid]<x) l=mid+1;
		else r=mid-1;
	}
	return l;
}
int lowbit(int x) {return x&(-x);}
inline void add(int x) {
	while(x<=tot) {
		c[x]++;
		x+=lowbit(x);
	}
}
int sum(int x) {
	int res=0;
	while(x) {
		res+=c[x];
		x-=lowbit(x);
	}
	return res;
}
signed main() {
	int k=read();
	for(int i=1;i<=k;++i) {
		a[i]=read();
		b[i]=read();
		num[i]=a[i];
		num[k+i]=b[i];
	}
	sort(num+1,num+2*k+1);
	tot=unique(num+1,num+2*k+1)-num-1;
	for(int i=1;i<=tot;++i) d[i]=i;
	for(int i=1;i<=k;++i) swap(d[find(a[i])],d[find(b[i])]);
	int ans=0;
	for(int i=tot;i>=1;--i) {
		add(d[i]);
		ans+=sum(d[i]-1);
		if(d[i]>i) ans+=num[d[i]]-num[i]-(d[i]-i);
		if(d[i]<i) ans+=num[i]-num[d[i]]-(i-d[i]);
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：luckydrawbox (赞：1)

## 题意

一个很长的序列 $a_1,a_2,a_3,…,a_{2^{31}-1}$，值分别是 $1,2,3,…,2^{31}-1$。

进行 $k$ 个操作，每次有两个数 $x,y$，请交换 $a_x,a_y$，最后输出新序列的逆序对数。

## 分析

每次交换只会改变两个数的位置，交换的次数也比较少，于是我们可以根据 $x,y$ 把整个序列分成几段，每段内的数字都是连续的。

请看下面的例子：

```cpp
2
1 8
4 10
```

交换的点 $x,y$ 显然要单独一段，中间的数也要一段。

$1|2\ 3|4|5\ 6\ 7|8|9|10$

这样就知道怎么分了吧，所有作为左端点的数就是 $x,x+1,y,y+1$，将他们放进数组 $c$ 中进行排序并去重，确定每个区间的左端点，右端点就是下一个区间的左端点减 $1$。虽然这样看起来像是离散化，但其实并不是。交换时只要交换 $x,y$ 所在的段即可。

```cpp
for(int i=1;i<=n;i++){
	x[i]=read();y[i]=read();
	c[++m]=x[i];c[++m]=x[i]+1;
	c[++m]=y[i];c[++m]=y[i]+1;
}
sort(c+1,c+m+1);
int tot=unique(c+1,c+m+1)-c-1;
for(int i=1;i<tot;i++)
	a[i].l=c[i],a[i].r=c[i+1]-1;
for(int i=1;i<=n;i++){
	x[i]=lower_bound(c+1,c+tot+1,x[i])-c;
	y[i]=lower_bound(c+1,c+tot+1,y[i])-c;
	swap(a[x[i]],a[y[i]]);
}
```

接下来就是求逆序对了。

按照套路，倒序扫描。

然后我们需要实现：

- 求一段区间中少于某个数的数的个数——**区间查询**。

- 把一段连续的数出现的次数增加 $1$——**区间增加**。

这不就是**线段树**吗！

于是我们可以以权值为节点建一棵线段树。

然而叶子节点数多达 $2^{31}-1$，普通线段树是存不下的，所以我们用**动态开点**的线段树就可以了。

每次求答案记得要乘上区间的长度。

最后就是动态开点权值线段树板子了。

**友情提示**：要开 ``long long``，动态开点线段树空间要开大。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll read(){
	ll x=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void write(ll x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
const int N=1e5+10,M=3e6+10;
int n,m,c[N<<2],x[N],y[N],t=1,l,r;
ll ans;
struct qj{
	int l,r;
}a[N<<2];
struct Tree{
	int cl,cr;
	ll tag,sum;
}s[M];
void make(int p){
	if(s[p].cl)
		return;
	s[p].cl=++t;s[p].cr=++t;
}
void pushup(int p){
	s[p].sum=s[s[p].cl].sum+s[s[p].cr].sum;
}
void pushdown(int p,int l,int mid,int r){
	if(s[p].tag){
		s[s[p].cl].tag=s[s[p].cr].tag=s[p].tag;
		s[s[p].cl].sum+=s[p].tag*(mid-l+1);
		s[s[p].cr].sum+=s[p].tag*(r-mid);
		s[p].tag=0;
	}
}
void add(int p,int l1,int r1){
	if(l<=l1&&r1<=r){
		s[p].tag++;
		s[p].sum+=(r1-l1+1);
		return;
	}
	int mid=(l1+r1)>>1;
	make(p);
	pushdown(p,l1,mid,r1);
	if(l<=mid)
		add(s[p].cl,l1,mid);
	if(r>mid)
		add(s[p].cr,mid+1,r1);
	pushup(p);
}
ll ask(int p,int l1,int r1){
	if(l<=l1&&r1<=r)
		return s[p].sum;
	ll ans=0;
	int mid=(l1+r1)>>1;
	make(p);
	pushdown(p,l1,mid,r1);
	if(l<=mid)
		ans+=ask(s[p].cl,l1,mid);
	if(r>mid)
		ans+=ask(s[p].cr,mid+1,r1);
	return ans;
}
int main()
{
    n=read();
	for(int i=1;i<=n;i++){
		x[i]=read();y[i]=read();
		c[++m]=x[i];c[++m]=x[i]+1;
		c[++m]=y[i];c[++m]=y[i]+1;
	}
	sort(c+1,c+m+1);
	int tot=unique(c+1,c+m+1)-c-1;
	for(int i=1;i<tot;i++)
		a[i].l=c[i],a[i].r=c[i+1]-1;
	for(int i=1;i<=n;i++){
		x[i]=lower_bound(c+1,c+tot+1,x[i])-c;
		y[i]=lower_bound(c+1,c+tot+1,y[i])-c;
		swap(a[x[i]],a[y[i]]);
	}
	for(int i=tot-1;i;i--){
		l=1;r=a[i].l-1;
		if(l<=r)
			ans+=ask(1,1,c[tot])*(a[i].r-a[i].l+1);
		l=a[i].l,r=a[i].r;
		add(1,1,c[tot]);
	}
	write(ans);
	return 0;
}
```


---

## 作者：Rubyonly (赞：0)

首先 $70\%$ 的数据点直接个 $10^5$ 的序列直接操作，大于 $10^5$ 的数肯定不会贡献答案，因为比它大的值不会交换到前面，最后跑一遍树状数组求逆序对即可

对于 $x,y$ 很大的时候，容易发现最多会有 $10^5$ 个数会进行交换操作

剩下的是若干个类似于 $x,x+1,x+2...$ 的连续段，不妨把这些连续段缩成一个点，同时维护一个这个连续段内数的个数，跑一遍树状数组求逆序对，注意数组要开两倍

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>

#define rint register int 

using namespace std;

const int maxn = 2e5 + 50;

inline int read () {
	rint x = 0, w = 1;
	char ch = getchar ();
	for (; ch < '0' || ch > '9'; ch = getchar ()) if (ch == '-') w = -1;
	for (; ch >= '0' && ch <= '9'; ch = getchar ()) x = x * 10 + ch - '0';
	return x * w;
}

int k, n, len, a[maxn], b[maxn], cnt[maxn], pos[maxn], tree[maxn];
long long ans;

struct Node {
	int x, y;
} q[maxn];

inline void Insert (rint x, rint val) {
	for (; x; x -= x & -x) tree[x] += val;
}

inline int Query (rint x, int ans = 0) {
	for (; x <= maxn; x += x & -x) ans += tree[x];
	return ans;
}

int main () {
	k = read();
	for (rint i = 1; i <= k; i ++) 
		q[i].x = b[++ len] = read(), q[i].y = b[++ len] = read();
	b[++ len] = 1, b[++ len] = 2147483647;
	sort (b + 1, b + len + 1), len = unique (b + 1, b + len + 1) - b - 1;
	n = (len << 1) - 1;
	for (rint i = 1; i <= n; i ++) {
		a[i] = pos[i] = i;
		if (i & 1) cnt[i] = 1;
		else cnt[i] = b[(i >> 1) + 1] - b[i >> 1] - 1;
	}
	for (rint i = 1; i <= k; i ++) {
		q[i].x = lower_bound (b + 1, b + len + 1, q[i].x) - b;
		q[i].y = lower_bound (b + 1, b + len + 1, q[i].y) - b;
		q[i].x <<= 1, q[i].y <<= 1, q[i].x --, q[i].y --;
		swap (a[q[i].x], a[q[i].y]);
	}
	for (rint i = 1; i <= n; i ++) 
		ans += 1ll * Query (a[i]) * cnt[i], Insert (a[i], cnt[i]);
	printf ("%lld\n", ans);
	return 0;
}

```

---

## 作者：安好 (赞：0)

```
/*
序列分为移动的序列和未移动的序列两部分
询问离散化后 
对于移动的序列，抽出来树状数组统计逆序对
对于未移动的序列，想办法能直接统计答案
首先维护哪些数未被移动过，然后对于未被移动过的数求前缀和sum[i] 
这样就得到了1~i中未被移动过的数的个数，进而能O(1)得出每段区间未被移动的数的个数。
考虑一个移动了的元素，从i向前移动到了j，那么他对答案的贡献，就是sum[j,i]
因为向前移动后[j,i]这段区间所有数都比他小。
同理一个元素从i向后移动到了j，那么他对答案的贡献为sum[i,j]
所以未被移动的元素对答案的贡献和就是Σabs(sum[原来位置]-sum[移动后的位置]) 
*/
#include<bits/stdc++.h>

#define N 200007
#define ll long long

using namespace std;
int n,m,cnt,num;
ll ans;
ll pos[N],a[N],sum[N];
struct node{
	int L,R;
}ask[N];

struct BIT_{
	
	int n;ll a[N];
	
	static int lowbit(int x){
		
		return x & -x;
	}
	
	void clear(){
		
		for(int i=1;i<=n;i++) a[i]=0;
	}
	
	ll query(int pos){
		
		ll ans=0;
		for(int i=pos;i>0;i-=lowbit(i)) ans+=a[i];
		return ans;
	}
	
	void update(int pos,int val){
		
		for(int i=pos;i<=n;i+=lowbit(i)) a[i]+=val;
	}
}bit;

inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}

void discrete()
{
	for(int i=1;i<=n;i++)
	{
		ask[i].L=read();ask[i].R=read();
		a[i]=ask[i].L;a[i+n]=ask[i].R;
		pos[i]=i;pos[i+n]=i+n;
	}
	sort(a+1,a+n*2+1);
	num=unique(a+1,a+n*2+1)-a-1;
	for(int i=1;i<=num;i++) sum[i]=sum[i-1]+a[i]-a[i-1]-1;
	for(int i=1;i<=n;i++)
	{
		ask[i].L=lower_bound(a+1,a+num+1,ask[i].L)-a;
		ask[i].R=lower_bound(a+1,a+num+1,ask[i].R)-a;
		swap(pos[ask[i].L],pos[ask[i].R]);
	}
}

int main()
{
	n=read();discrete();
	bit.n=n<<1; bit.clear();
	for(int i=num;i>=1;i--)
	{
		ans+=bit.query(pos[i]);
		ans+=abs(sum[pos[i]]-sum[i]);
		bit.update(pos[i],1);
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：forever_nope (赞：0)

（~~双倍经验过来的，这边人比较多，感觉我讲的比较细，求通过 QwQ~~）

## 简要分析

求逆序对，但是元素很多（$\le 2^{31} - 1$，$2 \times 10^9$ 多一点），由于题目给出的 $k$ 却比较小，所以我们可以从 $k$ 入手：

显而易见，$2 \times 10^9$ 的元素中最多只会有 $2 \times 10^5$ 个被交换（不会重复交换一个元素），而剩下的大量数据如果都储存下来，是没有意义的。

我们可以将没有参与交换的元素中，连续的部分看成一个整体，这里就用到了离散化的思想，将这些元素合并以后，剩下的元素就可以 $O(n \log n)$ 求逆序对了。

## 逆序对

逆序对怎么求，这里我们可以用树状数组求。由于这个不是模板题，不再解释。（~~都是紫题了还要讲逆序对？~~）

但是在这道题中，一部分元素是包含多个元素的，怎么办？

这就可以用到权值逆序对：我们在查找的过程中，现在发现了一个现在数组中的一对逆序对 $S_i > S_j$（$i < j$），$S_i$ 包含 $t_i$ 个元素，$S_j$ 包含 $t_j$ 个元素。因为只有连续的区间才会被合并，所以 $S_i$ 包含的所有元素都大于 $S_j$ 中的任意元素。

因此，$S_i$ 和 $S_j$ 对答案的贡献为 $t_i \times t_j$。

## 细节和易错点

1. 数组别开的太小，会 RE 的，我开到了 $4 \times 10^5$。

2. $10^5$ 级别的数据，不开 `long long` 怎么行？

## 代码

（由于我大量使用了 STL，所以效率并不太高 ~~懒 呵呵~~）

```cpp
#include <bits/stdc++.h>

#define int long long

#define rr read()

using namespace std;

const int N = 4e5 + 10;

// 快读

inline int read()
{
    int num = 0, flag = 1;
    char ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        if (ch == '-')
            flag = -1;
    for (; isdigit(ch); ch = getchar())
        num = (num << 3) + (num << 1) + ch - '0';
    return num * flag;
}

// 存放元素

struct node
{
    int x, y;
    node()
    {
        x = y = 0;
    }
    node(int _x, int _y)
    {
        x = _x, y = _y;
    }
    bool operator<(const node &t) const
    {
        return x < t.x;
    }
};

vector<node> q;
vector<node> a;

set<node> uq;
set<node> ad;

unordered_map<int, int> to;

// 树状数组

int s[N];

inline int lobit(int x)
{
    return x & -x;
}

void upd(int x, int t)
{
    for (; x < N; x += lobit(x))
        s[x] += t;
}

int que(int x)
{
    int res = 0;
    for (; x; x -= lobit(x))
        res += s[x];
    return res;
}

signed main()
{
    int m = rr;
    for (int i = 0; i < m; ++i)
        q.push_back({rr, rr}), uq.emplace(q[i].x, 1), uq.emplace(q[i].y, 1);

    // 去重和合并

    set<node>::iterator _a = uq.begin(), _b(_a);
    for (++_b; _b != uq.end(); ++_a, ++_b)
        if (_a->x < _b->x - 1)
            ad.emplace(_b->x - 1, _b->x - _a->x - 1);
    uq.insert(ad.begin(), ad.end());

    int n = 0;
    for (node i : uq)
        to[i.x] = n++, a.push_back({n, i.y});

    // 进行交换操作

    for (int i = 0; i < m; ++i)
        swap(a[to[q[i].x]], a[to[q[i].y]]);

    // 求逆序对

    int ans = 0;
    for (int i = n - 1; i >= 0; --i)
    {
        ans += que(a[i].x - 1) * a[i].y;
        upd(a[i].x, a[i].y);
    }

    printf("%lld\n", ans);
    return 0;
}
```

---


# [FJWC2018] 全排列

## 题目描述

定义两个长为 $n$ 的排列 $A$ 与 $B$ 相似：若 $\forall i$，满足 $C(A, A_i) = C(B, B_i)$。其中 $C(P, x)$ 为满足 $P_j < x$ $(1 \leqslant j \leqslant n)$ 的 $j$ 的数目。

对于两个长为 $n$ 的排列 $P_1, P_2$，定义函数 $F(P_1, P_2)$ 等于满足 $P_1[l \ldots r]$ 相似于 $P_2[l \ldots r]$ $(1 \leqslant l \leqslant r \leqslant n)$ 并且 $P_1[l \ldots r]$ 包含不超过 $E$ 个逆序对的数对 $(l, r)$ 的数目。

现在请你求出：对 $P_1, P_2$ 分别取遍所有 $1 \sim n$ 的排列后所有 $F(P_1, P_2)$ 的和。

## 说明/提示

对于 $50\%$ 的数据，$T \leqslant 10^4, n \leqslant 10, E \leqslant 50$。

对于 $80\%$ 的数据，$T \leqslant 10^4, n \leqslant 50, E \leqslant 10^6$。

对于 $100\%$ 的数据，$T \leqslant 10^4, n \leqslant 500, E \leqslant 10^6$。

## 样例 #1

### 输入

```
4
2 2
2 1
2 0
1 1```

### 输出

```
10
10
9
1```

# 题解

## 作者：dtcxzyw (赞：9)

这是FJWC2018的模拟考题。

我当时细节没有调对，然后就愉快地从100变为0分。。。

以下为题解：

考虑两个相似序列的共性：

1. 它们在原序列的位置相同；
2. 它们“**离散化**”后的序列相同（$C(P,x)$实质上是离散化后的下标）。

因为序列离散化后是一个排列，易知一个长度为i的排列可由$C[n][i]*(n-i)!$个长度为n的排列的子串离散化得到。

(即选择了$i$个数固定在子串中，剩余$n-i$个数自由排列)

所以我们可以先预处理$cnt[i][j]$表示长度为$i$，逆序对数不超过$j$的排列数，统计答案时，枚举排列子串的长度i，答案为

$ans=\sum_{i=1}^n{cnt[i][m](n-i+1)(C[n][i]*(n-i)!)^2}$

接下来讲讲如何预处理$cnt[i][m]$:

首先，数据范围中给出的$m<=1e6$过大，因为一个长为$n$的排列最多产生$\frac{n(n-1)}{2}$对逆序对，$query$时限制一下就好。

考虑往一个长度为$i-1$的排列里插入i，我们很容易得到一个$O(n^4)$的dp，显然会TLE。

打表可发现$cnt$的求法和组合数类似(超出定义域时值为0)：

$cnt[i][j]=cnt[i][j-1]+cnt[i-1][j]-cnt[i-1][j-i]$

于是预处理复杂度降为$O(n^3)$

dp出长度为i，逆序对数为j的排列数后，做个前缀和就好了。

时间复杂度$O(n^3+Tn)$

以下是代码：

```cpp
#include <algorithm>
#include <cstdio>
#include <vector>
int read() {
    int res = 0, c;
    do
        c = getchar();
    while (c < '0' || c > '9');
    while ('0' <= c && c <= '9') {
        res = res * 10 + c - '0';
        c = getchar();
    }
    return res;
}
const int size = 505, mod = 1000000007;
int add(int a, int b) {
    a += b;
    return a < mod ? a : a - mod;
}
int sub(int a, int b) {
    a -= b;
    return a >= 0 ? a : a + mod;
}
std::vector<int> cnt[size];
int C[size][size], fac[size];
typedef long long Int64;
#define asInt64(x) static_cast<Int64>(x)
void pre(int n, int m) {
    fac[0] = 1;
    for (int i = 1; i <= n; ++i) fac[i] = asInt64(fac[i - 1]) * i % mod;
    C[0][0] = 1;
    for (int i = 1; i <= n; ++i) {
        C[i][0] = 1;
        for (int j = 1; j <= i; ++j)
            C[i][j] = add(C[i - 1][j - 1], C[i - 1][j]);
    }
    cnt[0].push_back(1);
    for (int i = 1; i <= n; ++i) {
        int lsiz = cnt[i - 1].size();
        int cur = std::min(m, i * (i - 1) / 2);
        cnt[i].resize(cur + 1);
        cnt[i][0] = 1;
        for (int j = 1; j <= cur; ++j) {
            cnt[i][j] = cnt[i][j - 1];
            if (j < lsiz) cnt[i][j] = add(cnt[i][j], cnt[i - 1][j]);
            int off = j - i;
            if (0 <= off && off < lsiz)
                cnt[i][j] = sub(cnt[i][j], cnt[i - 1][off]);
        }
    }
    for (int i = 1; i <= n; ++i) {
        int siz = cnt[i].size();
        for (int j = 1; j < siz; ++j)
            cnt[i][j] = add(cnt[i][j - 1], cnt[i][j]);
    }
}
int query(int n, int m) {
    int res = 0;
    for (int i = 1; i <= n; ++i) {
        Int64 val = asInt64(C[n][i]) * fac[n - i] % mod;
        int cur = cnt[i].size() - 1;
        res = (res + val * val % mod * cnt[i][std::min(cur, m)] % mod * (n - i + 1)) % mod;
    }
    return res;
}
struct Query {
    int n, m;
} Q[10005];
int main() {
    int t = read();
    int maxn = 0, maxm = 0;
    for (int i = 0; i < t; ++i) {
        Q[i].n = read();
        maxn = std::max(maxn, Q[i].n);
        Q[i].m = read();
        maxm = std::max(maxm, Q[i].m);
    }
    pre(maxn, maxm);
    for (int i = 0; i < t; ++i)
        printf("%d\n", query(Q[i].n, Q[i].m));
    return 0;
}

```


---

## 作者：小老虎3018 (赞：4)

[LUOGU4678](https://www.luogu.org/problemnew/show/P4678) [BZOJ5255](https://www.lydsy.com/JudgeOnline/problem.php?id=5255)

**题面**：求（任意两个长度为$N$的全排列的贡献）之和，而两个数列中位置相等的两段区间，且满足各区间内数字大小关系相等，逆序对个数不大于$E$的区间贡献为$1$。~~其实数学公式的描述可能比这个更好懂。~~

数字大小关系相等，即离散化后值相等，也可以看作给定填入该区间的数字后，只有唯一一种排列形式。而这个区间又是来自于一段$1 \sim n$各出现一次的序列。

可以将两个全序列看作某一个区间分别插入到两个不完整的序列后的产物，由排列组合的知识得：

$$ ans = \sum_{i=1}^{i \leq n} [ ( C_n^i A_{n-i}^{n-i} )^2 \times cnt_{i,k} C_{n-i+1}^{1} ] = \sum_{i=1}^{i \leq n} [ (\frac{n!}{i!} )^2cnt_{i,k} C_{n-i+1}^{1} ]$$

$A$是排列的意思，$A_{n-i}^{n-i}$即全排列方案数$(n-i)!$。所以前面的平方代表两个不一定相同的不完整序列方案数，而区间插入两个序列的位置是一样的，插空法组合数求解。

所以$cnt$代表的是什么东西？题面要求区间应该还满足逆序对个数小于$k$，因此区间的方案数并不是大小为$i$的全排列，而与长度和逆序对个数相关。

先设$pre_{i,k}$是区间长度为$i$，逆序对个数恰好为$k$的方案数，暴力打表如下：

$$ \begin{matrix} 1_{i=1,k=0}\\1_{i=2,k=0}&1\\1_{i=3,k=0}&2&2&1\\1_{i=4,k=0}&3&5&6&5&3&1\\1_{i=5,k=0}&4&9&15&20&22&20&15&9&4&1_{k=10} \end{matrix} $$

感觉在答案递增的时候，值有点像上面的答案+左边的答案？可是$20+3 \not= 22$啊？

没有靠谱的规律的时候就考虑动态规划。发现可以通过区间长度更小的方案数推区间长度更大的方案数，即将$n$这个数插入到$1\sim (n-1)$的全排列当中，新增的逆序对个数肯定是插入位置后面的数字个数。用数学公式表示：

$$ pre_{i,k} = \sum_{j=max(0,k-(i-1))}^{k} pre_{i-1,j} $$

前缀和优化，设$cnt_{i,k}$是区间长度为$i$，逆序对个数不大于$k$的方案数。转移如下：

$$ \sum_{j=0}^{k} pre_{i,j} = cnt_{i,k} = cnt_{i,k-1}+\begin{cases}  &cnt_{i-1,k}&(k-i+1 < 0)\\&cnt_{i-1,k}-cnt_{i-1,k-i}&(k-i+1 \geq 0)\end{cases}$$

这么区分是为了避免数组越界。这里有一道相关的题：[\[HAOI2009\]逆序对数列](https://www.luogu.org/problemnew/show/P2513)

**时间复杂度分析**：
我看到代码里最多只有两层循环，便认为是$O(n^2+nT)$的时间复杂度。其中预处理$cnt$和对各询问进行计算分别计算。

但是区间长度为$i$时，逆序对个数最多会有多少个呢？（自行计算，答案见其他题解，不会超过$n^2$）

**注意**：像$cnt_{i=2,k=1000}$这样的询问其实就等价于$cnt_{i=2,k=max(cnt_i)=1}$，不用完全的$n^2$处理。

因此正确时间复杂度是$O(n^3+nT)$，空间复杂度可以是预处理后的$(n^3)$。

Code:
```cpp
//A code file. By Tiger3018
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
#include<climits>
using namespace std;
typedef long long ll;
const ll p=1000000007;
int f[509][130009]={0},maxni[509],jie[509],inv[509];

void nixu(){
	int tm1=1,tm2=1;
	for(int i=1;i<=500;i=-(~i)){
		f[i][0]=1;maxni[i]=tm1;
		for(int j=1;j<tm1;j=-(~j)){
			f[i][j]=(ll)(f[i][j-1]+f[i-1][j]-((j-i>=0)?f[i-1][j-i]:0)+p)%p;
		}
		for(int j=0;j<tm2;j=-(~j))f[i][j+tm1]=f[i][tm1-1];
		tm1+=tm2;tm2++;//printf("%d %d\n",i,tm1);
//		fflush(stdout);
	}
}

int C(int n,int m){return 1ll*jie[m]*inv[m-n]%p*inv[n]%p;}

int main(){
#ifndef ONLINE_JUDGE
	freopen("perm.in","r",stdin);
	freopen("perm.out","w",stdout);
#endif
	int T,t1,t2,j1,j2,res;scanf("%d",&T);
	nixu();jie[0]=jie[1]=inv[0]=inv[1]=1;
	for(int i=2;i<=500;i=-(~i)){jie[i]=1ll*jie[i-1]*i%p;}
	for(int i=2;i<=500;i=-(~i)){inv[i]=1ll*inv[p%i]*(p-p/i)%p;}
	for(int i=2;i<=500;i=-(~i)){inv[i]=1ll*inv[i-1]*inv[i]%p;}
	while(T--){
		res=0;
		scanf("%d%d",&t1,&t2);
		for(int i=1;i<=t1;i=-(~i)){
			j1=1ll*jie[t1-i]*jie[t1-i]%p;
			j2=C(i,t1);j2=1ll*j2*j2%p*j1%p;
			res=(res+(1ll*f[i][min(t2,maxni[i])]*j2%p*(t1-i+1)%p)+p)%p;
		}
		printf("%d\n",res);
	}
	return 0;
}
```

**Addition：**也可以考虑离线操作优化空间复杂度？但这个时候的时间复杂度会不会变化？

如果没有前缀和优化，时间复杂度？

---

## 作者：_fairytale_ (赞：2)

注意到两个序列相似实际上就是它们离散化之后相同。

考虑枚举每一个相似的区间长度 $len$，设长度为 $n$，且逆序对数不超过 $E$ 的序列数是 $f[n]$，先不管这个如何求得，那么最终答案为：

$$
\sum_{len=1}^{n}(n-len+1)\times [{n\choose len}\times (n-len)!]^2\times f[len]
$$

解释一下，先枚举区间长度 $len$，长度为 $len$ 的区间在两个序列中的开头有 $(n-len+1)$ 种，对答案的贡献是 $(n-len+1)$，然后这个长度为 $len$ 的区间是由 $P_1$ 和 $P_2$ 的 $n$ 个数中任意选出 $len$ 个组成的，至于剩下的位置，可以让它们随意排列。因为 $P_1$ 和 $P_2$ 的这两个区间是相似的，所以它们离散化后相同，合法的排列顺序有 $f[len]$ 种，所以就是上面的式子。

显然 $f[len]$ 以外的部分是好求的。

现在思考 $f[len]$ 要怎么求。

注意到这个问题实际上就是[这道题](https://www.luogu.com.cn/problem/P2513)。

不妨钦定将排列中的 $len$ 个数从小到大加入，设 $f[i][j]$ 为加入前 $i$ 个数，逆序对数恰好为 $j$ 的方案数，此时第 $i+1$ 个数有 $i+1$ 个位置可以插入，可以为序列增加 $[0,i]$ 个逆序对，所以得到转移方程：

$$
f[i][j]=\sum_{k=0}^{i-1} f[i-1][j-k]
$$

注意到我们每次都是对 $f[i-1]$ 中的一段连续段求和，所以可以处理出 $pre[i-1][j]=\sum_{k=0}^{j}f[i-1][k]$，即 $f[i-1]$ 的前缀和来优化 DP，优化后的转移方程为：

$$
f[i][j]=pre[i-1][j]-pre[i-1][j-i+1]
$$

（这里没有处理下标越界，主要是看着舒服嘛）

这样时间复杂度就优化到了 $\mathcal O(nE)$，还是会 $T$，不过其实逆序对数最多是 $n^2$ 级别的，所以可以直接把 $E$ 跟 $\dfrac{n(n-1)}{2}$
取 $\min$，就可以把复杂度降到 $\mathcal O(n^3)$ 啦！

最终我们原来需要的 $f[len]$ 就是 $pre[len][E]$！

贴个代码：

```cpp
#include<bits/stdc++.h>
#define re register
#define ll long long
#define rep(x,a,b) for(re int (x)=(a);(x)<=(b);++(x))
using namespace std;
#define maxn 510
#define mod 1000000007
int T;
constexpr int K=500*(500-1)/2;
int n=500,e;
int f[maxn][K+10],pre[maxn][K+10];
int fac[maxn],invfac[maxn];
inline int qp(int x,int y){
	int res=1;
	while(y){
		if(y&1)res=1ll*res*x%mod;
		x=1ll*x*x%mod;
		y>>=1;
	}
	return res;
}
inline int inv(int x){
	return qp(x,mod-2);
}
inline int C(int x,int y){
	if(x<y||x<0||y<0)return 0;
	return 1ll*fac[x]*invfac[y]%mod*invfac[x-y]%mod;
}
inline int pf(int x){return 1ll*x*x%mod;}
ll ans;
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
    f[0][0]=1;
    rep(j,0,K)pre[0][j]=1;
	rep(i,1,n){
    	rep(j,0,K){
    		int tmp=(j-i+1-1<0?0:pre[i-1][j-i+1-1]);
			f[i][j]=((pre[i-1][j]-tmp)%mod+mod)%mod;
    		pre[i][j]=(pre[i][j-1]+f[i][j])%mod;
		}
	}
	fac[0]=1;
	rep(i,1,n)fac[i]=1ll*fac[i-1]*i%mod;
	rep(i,0,n)invfac[i]=inv(fac[i]);
	cin>>T;
	while(T--){
		cin>>n>>e;
		e=min(e,K);
		ll ans=0;
		rep(len,1,n){
			ans=(ans+1ll*(n-len+1)%mod*pf(1ll*C(n,len)*fac[n-len]%mod)%mod*pre[len][e]%mod)%mod;
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

---


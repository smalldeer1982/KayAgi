# 「EZEC-2」数轴

## 题目描述

小 X 画了一条数轴，他将进行 $n$ 次操作，每次操作他会先在数轴上的 $x_i$ 位置上增添 $a_i$ 个标记。

然后他需要选择二元组 $(l,r)$，满足 $l,r$ 为整数， $0\le l\le r \le m$，且在数轴上的区间 $[l,r]$ 上的标记的个数**小于等于** $k$。

对于每次操作，你需要求出满足条件的二元组 $(l,r)$ 中 $r-l$ 的最大值。



## 说明/提示

**【样例解释 #2】**

每次操作后选择的二元组分别是 $(0,15),(4,15),(4,15),(8,15),(9,15)$。

---
**【数据范围与约定】**

| 数据点编号 | $n=$ | $m=$ | $k=$ |
| :----------: | :----------: | :----------: | :----------: |
| $1,2$ | $100$ | $100$ | $3$ |
| $3,4$ | $100$ | $10^3$ | $3$ |
| $5,6$ | $100$ | $10^4$ | $3$ |
| $7,8$ | $500$ | $10^4$ | $3$ |
| $9,10$ | $10^3$ | $10^4$ | $3$ |
| $11,12$ | $10^4$ | $10^5$ | $3$ |
| $13\sim 16$ | $10^5$ | $10^6$ | $0$ |
| $17\sim 21$ | $10^5$ | $10^6$ | $3$ |
| $22,23$ | $10^5$ | $10^9$ | $100$ |
| $24,25$ | $10^6$ | $10^9$ | $100$ |

保证测试点 $13\sim 16$ 的 $x_i$ 为随机构造。

测试点 $24,25$ 的时间限制为 $3\text s$ ，其他测试点的时间限制均为 $2\text s$。

对于 $100\%$ 的数据，满足 $1\le n\le 10^6$，$0\le m\le 10^9$，$0\le x_i\le m$，$0\le k\le 100$，$1\le a_i\le 100$。

**注意：数轴上同一个位置上可能会多次增添标记。**

**已自动开启 $\text{O2}$ 优化，保证时空限制均为 $\text{std}$ 在开启 $\text{O2}$ 优化后的两倍以上。**

## 样例 #1

### 输入

```
5 4 0
2 1
3 1
0 1
1 1
4 1```

### 输出

```
1
1
0
0
-1```

## 样例 #2

### 输入

```
5 15 1
3 1
8 1
1 1
7 1
14 1```

### 输出

```
15
11
11
7
6
```

## 样例 #3

### 输入

```
10 100 10
94 3
22 10
9 4
37 1
21 10
92 5
50 9
68 8
44 4
78 9
```

### 输出

```
100
93
83
77
77
77
68
44
40
26
```

## 样例 #4

### 输入

```
10 100 3
95 1
13 1
52 1
74 1
40 1
54 1
71 1
68 1
51 3
12 2
```

### 输出

```
100
100
100
94
80
59
56
53
50
39
```

# 题解

## 作者：君のNOIP。 (赞：11)

先讲一下这题各种部分分的复杂度。

------------

花式暴力：

- 8分，$O(nm^3)$

- 16分，$O(nm^2)$

- 24分，$O(n^4)$

- 32分，$O(n^3)$

- 40分，$O(n^2logn)$

- 48分，$O(n^2)$

送分结束。

------------

认真骗分：

- 64分，在 $O(n^2)$ 做法上加个小优化。

- 84分，数据结构：$O(nklog^2 n)$ 或 $O(nk^2logn)$

------------

简单正解：

- 100分，$O(n(k+logn))$



------------

### 48分： $O(n^2)$ 的暴力。

很显然，最优解一定是某两个有标记的点（包括 $-1$ 和 $m+1$）之间的距离 $-1$ ，这两个点只需要满足他们之间（不包括这两个点）的标记数 $\le k$ 即可。

所以我们只需**枚举有标记的点**作为左端点和右端点即可。

按照这个思路，我们可以直接用 set 和 map ，~~但是我不太会用~~。

如果用数组存，只需先离线记录各个输入，然后开个结构体排个序再 map 瞎搞搞就好了。

每次操作的时候，枚举左端点，将右端点不断向右挪就好了。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, k;
int ans;
int num[10005], pos[10005], cnt;
struct node{
	int x, a;
} e[10005];
int x[10005], a[10005];
map<int,int>mp;

bool comp(node x,node y){
	return x.x < y.x;
}

int main(){
    cin>>n>>m>>k;
    for(int i = 1; i <= n; i++){
    	cin>>e[i].x>>e[i].a;
    	x[i] = e[i].x, a[i] = e[i].a;
	}
	e[n+1].x = -1;
	sort(e+1,e+2+n,comp);
	for(int i = 1; i <= n + 1; i++){
		if(e[i].x != pos[cnt]) pos[++cnt] = e[i].x;
		mp[e[i].x] = cnt;
	}
	pos[cnt+1] = m + 1;
	for(int i = 1; i <= n; i++){
		num[mp[x[i]]] += a[i];
		int t = 1, s = 0;
		ans = -1;
		for(int j = 1; j <= cnt; j++){
			s -= num[j];
			while(s + num[t+1] <= k && t < cnt) t++, s += num[t];
			ans = max(ans,pos[t+1] - pos[j] - 2);
		}
		cout<<ans<<endl;
	}
}
```


------------

### 64分： $O(n^2)$ 的暴力 + 优化。

- 保证测试点 $13\sim 16$ 的 $x_i$ 为随机构造。

很显然，每次操作的答案小于等于上次的答案。

其实在随机数据下，是会有很多相同的答案的。

因为随着操作的增多，答案区间也越来越小，需要更新答案的概率也就越低。

所以如果某次操作的答案与上次的相同，那么就不用再更新答案。

怎么判断某次的答案是不是与上次的相同呢？

我们每次操作后记录下当前答案区间的左右端点，很显然如果某次操作的 $x_i$ 不在上次的答案区间内，就不用更新答案。



Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAX_N 1000005
int n, m, k;
int ll, rr;
int ans;
int num[MAX_N], pos[MAX_N], cnt;
struct node{
	int x, a;
}e[MAX_N];
int x[MAX_N], a[MAX_N];
map<int,int>mp;

bool comp(node x,node y){
	return x.x < y.x;
}

int main(){
    cin>>n>>m>>k;
    for(int i = 1; i <= n; i++){
    	cin>>e[i].x>>e[i].a;
    	x[i] = e[i].x, a[i] = e[i].a;
	}
	e[n+1].x = -1;
	sort(e+1,e+2+n,comp);
	for(int i = 1;i <= n + 1; i++){
		if(e[i].x != pos[cnt]) pos[++cnt] = e[i].x;
		mp[e[i].x]= c nt;
	}
	pos[cnt+1] = m+1;
	rr = m;
	for(int i = 1; i <= n; i++){
		num[mp[x[i]]] += a[i];
		if(x[i] >= ll && x[i] <= rr){
			int t = 1, s = 0;
			ans = -1;
			for(int j = 1; j <= cnt; j++){
				s -= num[j];
				while(s + num[t+1] <= k && t < cnt) t++, s += num[t];
				if(pos[t+1] - pos[j] - 2 > ans) ans = pos[t+1] - pos[j] - 2, ll = pos[j] + 1, rr = pos[t+1] - 1;
			}
		}
		cout<<ans<<endl;
	}
}
```


------------

### 84分：数据结构。

- #### 方法一：万能的线段树 $O(nk^2logn)$

注意到 $m\le 10^6$ ，那么我们可以直接开线段树维护。

只需维护符合要求的最大区间，从左端点开始的最大区间，从右端点开始的最大区间。

考虑到 $k\le 3$ ，我们只需开二维，每个节点 $k^2$ 暴力更新。

由于是单点修改，不需要下传标记。

询问也很简单，直接输出节点 $1$ 的最大区间即可。

每次上传信息的时候，就维护下该区间内有 $j$ 个标记时的最大区间，从左端点开始的最大区间，从右端点开始的最大区间即可。

所以这个连懒惰标记都不用的线段树就很好打了。


Code：

------------
```cpp
#include<map>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
#define G() Cr=getchar()
#define sum(i,j) tr[i].sum[j]
#define lst(i,j) tr[i].lst[j]
#define rst(i,j) tr[i].rst[j]
int Xr;char Cr;
inline int rd(){
	Xr=0, G();
	while(Cr<'0' || Cr>'9') G();
	while(Cr>='0' && Cr<='9') Xr=(Xr<<3) + (Xr<<1) + (Cr & 15), G();
	return Xr;
}
#define MAX_N 1000005
int n, m, k;
int ans;
int num[MAX_N];
int pos, a;

struct Node {
	int sum[5], lst[5], rst[5];
} tr[MAX_N<<2];

void Push_up(int i,int l,int r) {
	int mid = l + r >> 1;
	for(int j = 0; j <= k; j++)
		sum(i,j) = max(sum(i<<1,j),sum(i<<1|1,j)),
		lst(i,j) = lst(i<<1,j),
		rst(i,j) = rst(i<<1|1,j);
	for(int j = 0; j <= k; j++)
		for(int p = 0; p <= j; p++) {
			if(rst(i<<1,p) && lst(i<<1|1,j-p))sum(i,j) = max(sum(i,j), rst(i<<1,p) + lst(i<<1|1,j-p));
			if(lst(i<<1,p) == mid-l+1 && lst(i<<1|1,j-p)) lst(i,j) = max(lst(i,j), lst(i<<1,p) + lst(i<<1|1,j-p));
			if(rst(i<<1|1,p) == r-mid && rst(i<<1,j-p)) rst(i,j) = max(rst(i,j), rst(i<<1|1,p) + rst(i<<1,j-p));
		}
}

void Build(int i,int l,int r) {
	if(l == r) {
		sum(i,0) = lst(i,0) = rst(i,0) = 1;
		return;
	}
	int mid = l + r >> 1;
	Build(i<<1,l,mid);
	Build(i<<1|1,mid+1,r);
	Push_up(i,l,r);
}

void Change(int i,int l,int r,int P) {
	if(l>=P && r<=P) {
		for(int j=0;j<=k;j++) sum(i,j) = lst(i,j) = rst(i,j) = 0;
		if(num[l] <= k) sum(i,num[l]) = lst(i,num[l]) = rst(i,num[l]) = 1;
		return;
	}
	int mid = l + r >> 1;
	if(mid >= P) Change(i<<1,l,mid,P);
	else Change(i<<1|1,mid+1,r,P);
	Push_up(i,l,r);
}

int main() {
    n=rd(), m=rd(), k=rd();
    Build(1,0,m);
    for(int i = 1;i <= n;i++) {
    	pos=rd(), a=rd();
    	num[pos] += a;
    	Change(1,0,m,pos);
    	ans = -1;
    	for(int j = 0;j <= k; j++) ans = max(ans,sum(1,j) - 1);
    	printf("%d\n",ans);
	}
}
```


------------

- #### 方法二：树状数组 + 二分 $O(nklog^2n)$ 

首先我们发现由于每次的答案小于等于上一次的答案，我们不能直接维护最大区间。

但如果**将询问倒序处理**呢？

我们发现答案变为大于等于上一次的答案。

这样问题就转化为每次删除若干标记。

这样还不够，我们发现每次如果更新答案，那么新的答案区间一定包含此处操作删除标记的那个点。

所以我们只需枚举最多 $k$ 个左端点，我们可以用树状数组维护在某个**最终有标记**的点的标记数前缀和，然后利用二分查找枚举左右端点即可。

Code：

------------
```cpp
#include<map>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
#define G() Cr=getchar()
int Xr;char Cr;
inline int rd(){
    Xr = 0, G();
    while(Cr < '0' || Cr > '9') G();
    while(Cr >= '0' && Cr <= '9')Xr = (Xr<<3) + (Xr<<1) + (Cr & 15), G();
    return Xr;
}
#define LL long long
#define MAX_N 1000005
int n, m, k;
int ans[MAX_N];
int num[MAX_N], pos[MAX_N], cnt;
int ma = -1, s, t;
int sum[MAX_N];
struct node{
	int x, a;
} e[MAX_N];
int x[MAX_N], a[MAX_N];
map<int,int>mp;

bool comp(node x,node y){
	return x.x < y.x;
}

void add(int p,int x){
	while(p <= cnt) sum[p] += x, p += p & -p;
}

int gsum(int p){
	int ss=0;
	while(p) ss += sum[p], p -= p & -p;
	return ss;
}

int find_l(int p){
	int ss = gsum(p);
	int l=1, r=p, sss=p;
	while(l <= r){
		int mid = (l + r)>>1;
		if(ss - gsum(mid) <= k) sss = mid, r = mid - 1;
		else l = mid + 1;
	}
	return sss;
}

int find_r_j(int p){
	int ss = gsum(p);
	int l = p + 1, r = cnt, sss = p + 1;
	while(l <= r){
		int mid = (l + r)>>1;
		if(ss < gsum(mid)) sss = mid, r = mid - 1;
		else l = mid + 1;
	}
	return sss;
}

int find_r_t(int p){
	int ss = gsum(p);
	int l = p, r = cnt, sss = p;
	while(l <= r){
		int mid = (l + r)>>1;
		if(gsum(mid) - ss <= k) sss = mid, l = mid + 1;
		else r = mid - 1;
	}
	return sss;
}

int main(){
    n = rd(), m = rd(), k = rd();
    for(int i = 1; i <= n; i++) {
    	e[i].x = rd(), e[i].a = rd();
    	x[i] = e[i].x, a[i] = e[i].a;
	}
	e[n+1].x = -1;
	sort(e+1,e+2+n,comp);
	for(int i = 1; i <= n + 1; i++) {
		if(e[i].x != pos[cnt]) pos[++cnt] = e[i].x;
		mp[e[i].x] = cnt;
	}
	pos[cnt+1] = m + 1;
	for(int i = 1; i <= n; i++) num[mp[x[i]]] += a[i], add(mp[x[i]],a[i]);
	for(int i = 1; i <= cnt; i++) {
		s -= num[i];
		while(s + num[t+1] <= k && t < cnt) t++, s += num[t];
		ma=max(ma,pos[t+1] - pos[i] - 2);
	}
	ans[n] = ma;
	for(int i = n; i >= 2; i--) {
		int p = mp[x[i]];
		add(p,-a[i]);
		int j = find_l(p), t;
		while(j < p){
			t = find_r_t(j);
			ma = max(ma,pos[t+1] - pos[j] - 2);
			j = find_r_j(j);
		}
		ans[i-1] = ma;
	}
	for(int i = 1; i <= n; i++) printf("%d\n",ans[i]);
}
```


------------

### 100分：$O(n(k+logn))$ 只需开几个数组直接维护即可 。

考虑反正每次也是最多枚举 $k$ 次左端点，我们可以定两个数组 $l_i,r_i$，表示第 $i$ 个最终有标记点的左边和右边的第一个有标记的点的下标。

初始化：
```cpp
l[i] = i - 1, r[i] = i + 1;
```


然后每次倒序操作时，若此点的标记减为 $0$， 更新 ：

```
if(!num[p]) r[l[p]] = r[p], l[r[p]] = l[p];
```

其中 $p$ 为此次操作删去标记的点。

然后查询也就只需每次移动到 $l_j,r_j$ 即可，很显然每次操作移动复杂度为 $O(k)$

Code:


------------
```cpp
#include<map>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
#define G() Cr=getchar()
int Xr;char Cr;
inline int rd(){
    Xr = 0, G();
    while(Cr < '0' || Cr > '9') G();
    while(Cr >= '0' && Cr <= '9') Xr = (Xr<<3) + (Xr<<1) + (Cr & 15), G();
    return Xr;
}
#define MAX_N 1000005
int n, m, k;
int ans[MAX_N];
int num[MAX_N], pos[MAX_N], cnt;
int l[MAX_N], r[MAX_N];
int ma = -1, s, t;
struct node{
	int x, a;
} e[MAX_N];
int x[MAX_N], a[MAX_N];
map<int,int>mp;

bool comp(node x,node y){
	return x.x < y.x;
}

int main(){
    n = rd(), m = rd(), k = rd();
    for(int i = 1; i <= n; i++) {
    	e[i].x = rd(), e[i].a = rd();
    	x[i] = e[i].x, a[i] = e[i].a;
	}
	e[n+1].x = -1;
	sort(e+1,e+2+n,comp);
	for(int i = 1; i <= n + 1; i++) {
		if(e[i].x != pos[cnt]) pos[++cnt] = e[i].x;
		mp[e[i].x] = cnt;
	}
	pos[cnt+1] = m + 1;
	for(int i = 1; i <= n; i++) num[mp[x[i]]] += a[i];
	for(int i = 1; i <= cnt; i++) {
		s -= num[i];
		while(s + num[t+1] <= k && t < cnt) t++, s += num[t];
		ma = max(ma, pos[t+1] - pos[i] - 2);
		l[i] = i - 1, r[i] = i + 1;
	}
	ans[n] = ma;
	for(int i = n; i >= 2; i--) {
		int p = mp[x[i]];
		num[p] -= a[i];
		if(!num[p]) r[l[p]] = r[p], l[r[p]] = l[p];
		t = p;
		int j = p;
		s = num[t];
		while(j > 1 && s <= k) j = l[j], s += num[j];
		for(j; j < p; j = r[j]) {
			s -= num[j];		
			while(s + num[r[t]] <= k && r[t] <= cnt) t = r[t], s += num[t];
			ma = max(ma, pos[r[t]] - pos[j] - 2);
		}
		ans[i-1] = ma;
	}
	for(int i = 1; i <= n; i++) printf("%d\n",ans[i]);
}
```


------------

总结：这是一道思维题，细节也不少，不过部分分非常足。

另：我是用 map 的，所以会比较慢， std 被吊打很正常/kk

---

## 作者：一扶苏一 (赞：9)

## 【two pointers】【P6602】 「EZEC-2」数轴

### Description

给定一个长度为 $m$ 的序列，有 $n$ 次操作，对序列单点加 $a$。每次操作后都要求出序列中最长的区间，满足区间和不大于 $k$。

$1 \leq n \leq 10^6$，$1 \leq m \leq 10^9$，$1 \leq k \leq 100$，$1 \leq a \leq 100$。

### Analysis

首先注意到答案区间一定是形如开区间 $(l, r)$ 的形式，其中 $l$ 要么是 $-1$，要么是被修改过的位置；$r$ 要么是 $m + 1$，要么是被修改过的位置。这是因为如果 $l$ 没有被修改的话，将 $l$ 减掉 $1$，区间和不变，区间变长，答案更优。$r$ 同理。我们把所有**目前**被修改过的位置和 $-1$ 以及 $m + 1$ 都称为关键点。

考虑对于关键点作为 $r$，都维护出其对应的 $l$ 最小的位置。当进行一次单调修改时，我们注意到因为关键点处的值至少是 $1$（除了 $-1$ 和 $m + 1$），所以被修改的位置至多会影响它后面 $k$ 个关键点的答案。由于 $k$ 很小，我们直接暴力修改这些位置对应的 $l$ 即可。注意到当 $r$ 增加时，$l$ 单调不降。所以可以 two pointers 扫一遍。修改一次的复杂度是 $O(k)$。

考虑维护答案，可以把所有关键点对应的区间长度都扔到 `std::set` 里，每次修改都修改 `std::set` 里的值。查询时查询最大值即可。时间复杂度 $O(nk \log n)$，可以获得 84 分的好成绩。

考虑优化。注意到之所以需要用 `std::set` 来维护答案，是因为随着操作进行，每个位置的答案都会不断减小，导致最大值减小。我们无法快速维护原来的最大值被减小以后新的最大值是多少。

但是如果最大值是不断增加的，我们只需要一次取 max 就可以 $O(1)$ 维护当前最大值了。因此我们考虑把操作都反过来，一开始就维护出序列的最终状态，然后把单点加变成单点减，随着操作进行不断地去掉关键点，这样对于每个关键点，其对应的区间长度都是随着操作进行单调不降的，因此最大值单调不降，我们就可以 $O(1)$ 去维护最大值而不需要 `std::set` 了。处理序列的最终状态的关键点对应的长度可以 two pointers 来求，删除关键点可以用链表来维护。这样时间复杂度为 $O(nk)$，可以通过本题。

### Code

写了个 $O(n^2)$ 的假代码水过了这个题，已经联系出题人加强数据，等我明天写一份真的代码再补吧。

upd：代码已添加。

```cpp
namespace Fusu {

const int maxn = 1000006;

int n, m, t, ma = -1;
int a[maxn], b[maxn], c[maxn], ans[maxn], w[maxn], lp[maxn], rp[maxn];

void Init();
void Solve();

void Main() {
  Init();
  Solve();
}

void Init() {
  qr(n); qr(m); qr(t);
  for (int i = 1; i <= n; ++i) {
    qr(a[i]); qr(b[i]);
    c[i] = a[i];
  }
  std::sort(c + 1, c + 1 + n);
  auto bg = c + 1, ed = std::unique(bg, c + 1 + n);
  *ed = m + 1;
  m = ed - bg + 1;
  w[m + 1] = 1;
  c[0] = -1;
  for (int i = 1; i <= n; ++i) {
    w[a[i] = std::lower_bound(bg, ed, a[i]) - c] += b[i];
  }
  for (int i = 0; i <= m; ++i) {
    lp[i] = i - 1;
    rp[i] = i + 1;
  }
  for (int l = 0, r = 1, sum = 0; r <= m; sum += w[r], r = rp[r]) {
    while (sum > t) sum -= w[l = rp[l]];
    ma = std::max(ma, c[r] - c[l]);
  }
}

void Solve() {
  for (int i = n; i; --i) {
    ans[i] = ma - 2;
    w[a[i]] -= b[i];
    int l = a[i] - 1, sum = 0;
    while (l && ((sum += w[l]) <= t)) l = lp[l];
    sum -= w[l];
    ma = std::max(ma, c[a[i]] - c[l]);
    sum += w[a[i]];
    for (int r = a[i] + 1; r <= m; sum += w[r], r = rp[r]) {
      while (sum > t) sum -= w[l = rp[l]];
      ma = std::max(ma, c[r] - c[l]);
      if (l > a[i]) break;
    }
    if (w[a[i]] == 0) {
      lp[a[i] + 1] = lp[a[i]];
      rp[a[i] - 1] = rp[a[i]];
    }
  }
  qwa(ans + 1, n, '\n', '\n');
}

} // namespace Fusu
```

---

## 作者：_CHO (赞：3)

## 时光倒流+暴力+尺取



------------


第一次看到这题，是在神子杏的课堂上

>  这就是一个裸的双指针，洛咕上多倍经验的题太多了。 ——神子杏

那好，我们就用双指针来考虑这道题。

首先可以发现

- 答案区间$ (l,r) $ 一定在某两个标记点之间，也就是说，$l-1 $ 应当是一个有标记点，$r+1$ 也应是一个有标记的点。

证明很显然，假如右端点的右侧没有标记，那么右端点一定可以继续向右延伸。左端点同理。

往数轴上增加标记不好做，考虑从数轴上拿走标记。我们可以预处理出所有标记点都在数轴上时的答案，也就是输出答案的最后一行。关于这一步，我们可以发现暴力枚举每一个可能的答案区间$(l,r)$的复杂度为$O(n^2)$，这显然是不能接受的。发现每当我们确定一个左端点l，则随着l的增大，r是单调不降的。基于这一性质，考虑用双指针扫一遍，$O(n)$美滋滋。

接下来考虑依次删去每一个标记，即将这一标记的权值设为$0$，同时统计对应的答案。统计答案的方法同上。但是我们会发现这样单次复杂度最坏是$O(n)$,不能接受。

还需要注意的是，题目中要求标记个数不大于k，发现k很小，考虑暴力做。可以发现

- 删除一个标记点时，至多只会影响这个点左侧k个和右侧k个点（想一想，为什么）。

所以我们只需要在每次删除时，以$O(k)$的复杂度用双指针来找这个标记点的左右能不能作为答案即可。

继续考虑优化。删除一个标记，我们不仅删除它的权值，而且删除这个标记的在数组存储中的下标，枚举端点的时候直接跳过它。没错，我们可以使用一个链表来维护每一个端点的前驱和后继。在删除标记时，只需修改其前驱后继的关系即可。

最后需要特判一种情况：删除上一个标记点时的答案区间为$(l0,r0)$，删除当前标记点的答案区间为$(l,r)$，两个区间不是包含关系。这时需要将当前的答案取两者中较大的即可。

则总复杂度为$O(nk)$


Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e+6+100;
const int inf = 0x7f7f7f7f;
struct Data{
	int x,a,tim;
};
int n,m,k;
Data opt[maxn];
int tim[maxn];
int ans[maxn];
int pre[maxn],suc[maxn];
inline int read(){
	int v=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-f; ch = getchar();}
	while(ch>='0'&&ch<='9'){v=(v<<3)+(v<<1)+ch-'0';ch=getchar();}
	return v*f;
}
inline bool cmp(Data x,Data y){
	return x.x<y.x;
}
int main(){
	n=read();m=read();k=read();
	for(register int i=1;i<=n;++i){
		opt[i].x=read();opt[i].a=read();opt[i].tim = i;
		ans[i] = -1;
	}
	opt[n+1]=Data{-1,inf,0};
	opt[n+2]=Data{m+1,inf,0};
	sort(opt+1,opt+n+3,cmp);
	for(register int i=1;i<=n+2;++i) tim[opt[i].tim] = i;
	for(register int l=1,r=1,cnt=0;r<=n+2;++r){
		cnt+=opt[r].a;
		while(cnt>k){
			cnt-=opt[l++].a;
			if(l>r) break;;
		}
		if(k==0) ans[n] = max(ans[n],opt[r].x-opt[r-1].x-2);
		else ans[n]=max(ans[n],opt[r+1].x-opt[l-1].x-2);
	}
	for(register int i=1;i<=n+2;++i){
		if(i!=1)pre[i] = i-1;
		suc[i] = i+1;
	}
	for(register int i=n-1;i>=1;--i){
		int t=tim[i+1];
		opt[t].a=0;
		pre[suc[t]] = pre[t];
		suc[pre[t]] = suc[t];
		int r=t,lim=t;
		for(int p=0;p<=k+10;++p){
			r=max(pre[r],2);
			lim=min(suc[lim],n+2);
		}
		for(register int l=r,cnt=0;r<=lim;r=suc[r]){
			cnt+=opt[r].a;
			while(cnt>k){
				cnt-=opt[l].a;
				l=suc[l];
			}
			if(k==0) ans[i] = max(ans[i],opt[r].x-opt[pre[r]].x-2);
			else ans[i] = max(ans[i],opt[suc[r]].x-opt[pre[l]].x-2);
		}
		ans[i]=max(ans[i+1],ans[i]);
	}
	for(register int i=1;i<=n;++i) printf("%d\n",ans[i]);
	return 0;
}
```

---


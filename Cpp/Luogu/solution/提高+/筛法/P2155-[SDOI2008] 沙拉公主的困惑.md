# [SDOI2008] 沙拉公主的困惑

## 题目描述

大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为 $1$ 到 $N$ 的阶乘，但是，政府只发行编号与 $M!$ 互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于数量可能非常大，你只需计算出答案对 $R$ 取模后的结果即可。 

## 说明/提示

对于 $100\% $ 的数据，$1\leq M\leq N\leq 10^7$，$1\leq T\leq 10^4$，$2\leq R\leq 10^9+10$ 且 $R$ 为质数。

## 样例 #1

### 输入

```
1 11
4 2```

### 输出

```
1
```

# 题解

## 作者：小粉兔 (赞：137)

本题在 [/discuss/show/338087](/discuss/show/338087) 加强数据前的题解有一些是错误的，具体原因下面会说明。

错误的题解存在的问题是，当 $n \ge R$ 时就直接输出 $0$，在原数据下是能 AC 的。

实际上并不是这样的，可以试试这个数据：

```plain
1 3
4 3
```

输出应该是 $2$。但是我见到的大部分题解输出都是 $0$。

为什么呢？

我们先看看这题的公式：$\displaystyle \mathrm{ans} = \frac{n!}{m!} \cdot \varphi(m!)$，其中 $\varphi(x)$ 代表 $x$ 的欧拉函数。

化简：

$$ \begin{aligned} \mathrm{ans} &= \frac{n!}{m!} \cdot \varphi(m!) \\ &= \frac{n!}{m!} \cdot m! \prod_{p \mid m!} \frac{p - 1}{p} \\ &= n! \cdot \frac{\displaystyle \prod_{p \in \mathbb{P} \mathbin{\&} p \le m} (p - 1)}{\displaystyle \prod_{p \in \mathbb{P} \mathbin{\&} p \le m} p} \end{aligned} $$

那么，我们只要处理 $\displaystyle \prod p$ 对 $R$ 的逆元吗？

错了，因为 $n!$ 中的因子 $R$ 还有可能和 $\displaystyle \prod p$ 中的 $R$ 消掉。

正解应该是对 $n \ge R$ 的 $n!$ 消去一个 $R$，对 $m \ge R$ 的 $\displaystyle \prod p$ 同时消去一个 $R$ 才对。

由于 $\displaystyle \prod p$ 中最多含有一个 $R$ 所以不需要多做消去。

代码：

```cpp
#include<cstdio>
#define F(i,a,b) for(int i=(a);i<=(b);++i)
#define F2(i,a,b) for(int i=(a);i<(b);++i)
int T,Mod,n,m;
int primes[664580], pnum=0;
bool isn_prime[10000001];
int pi[664580],inv[10000001];
int in[664580],fct[10000001];
int pos[10000001];
void init(){
	isn_prime[0]=isn_prime[1]=1;
	F(i,2,10000000){
		if(!isn_prime[i]) primes[++pnum]=i;
		for(int j=1;j<=pnum&&primes[j]*i<=10000000;++j){
			isn_prime[primes[j]*i]=1;
			if(i%primes[j]==0) break;
		}
	}
	inv[1]=1; for(int i=2;i<Mod&&i<=10000000;++i)
		inv[i]=1ll*(Mod-Mod/i)*inv[Mod%i]%Mod;
	pi[0]=1; F(i,1,pnum) pi[i]=1ll*pi[i-1]*(primes[i]-1)%Mod;
	in[0]=1; F(i,1,pnum) if(primes[i]!=Mod) in[i]=1ll*in[i-1]*inv[primes[i]%Mod]%Mod; else in[i]=in[i-1];
	fct[0]=1; F(i,1,10000000) if(i!=Mod) fct[i]=1ll*fct[i-1]*i%Mod; else fct[i]=fct[i-1];
	F(i,2,10000000) if(isn_prime[i]) pos[i]=pos[i-1]; else pos[i]=pos[i-1]+1; 
}
int main(){
	scanf("%d%d",&T,&Mod);
	init();
	while(T--){
		scanf("%d%d",&n,&m);
		if(n>=Mod&&m<Mod) puts("0");
		else printf("%d\n",1ll*fct[n]*pi[pos[m]]%Mod*in[pos[m]]%Mod);
	}
	return 0;
}
```

---

## 作者：Isprime (赞：28)

题意简述：给定 $N,M,R$，求 $[1,N!]$ 中与 $M!$ 互质的数的数量。

伟大的欧几里得已经告诉我们该怎么做了。

题目中限定了 $M \leq N$，那么显然 $M! | N!$. 

常识告诉我们，$gcd(a,b)=gcd(a+k\times b,b)$.然而常识很多时候是假的，所以我们考虑证明这个式子。

设 $s=gcd(a,b)$, 则存在 $x,y\in\mathbb{Z}$使得 $a=x\times s,b=y\times s,gcd(x,y)=1$，于是 $gcd(a+b\times k,b)=gcd(x\times s+y\times s\times k,y\times s)=gcd(s\times(x+y\times k),s\times y)=s\times gcd(x+y\times k,y)$.

设 $m|(x+y\times k)$ 且 $m|y$，所以 $m|(y\times k)$，所以 $m|x$.即 $m|x$ 且 $m|y$，又因为 $gcd(x,y)=1$，所以 $gcd(x+y\times k,y)=m=1$，所以 $gcd(a+b\times k,b)=s\times gcd(x+y\times k,y)=s=gcd(a,b)$.

这个式子能说明什么呢？我们令 $b=M!$,显然可以发现：对于 $\forall k\in [1,\frac{N!}{M!}],\forall x\in[1,M!]$ 有 $gcd(k*M!+x,M!)=gcd(x,M!)$.

也就是说，对于 $\forall k\in [1,\frac{N!}{M!}]$, $[(k-1)\times M!+1,k\times M!]$ 中与 $M!$ 互质的数是相等的。

得出这个结论之后就简单了。答案就是 $\frac{N!}{M!}\times \phi(M!)$.

$\phi(M!)$ 又是个不可做的东西。。。吗？

我们知道 $\phi(n)=n\times\Pi_{p|n}(1-\frac{1}{p})$, 设 $phifac_i=\phi(i!)$，我们分两种情况讨论。

$n$ 为素数时，$phifac_i=n\times(1-\frac{1}{n})\times(n-1)!\times\Pi_{p|n!\&p\neq n}(1-\frac{1}{p})=(n-1)\times (n-1)!\times\Pi_{p|(n-1)!}(1-\frac{1}{p})=(n-1)\times phifac_{n-1}$.

$n$ 为合数时，
$phifac_i=n\times(n-1)!\times\Pi_{p|n!}(1-\frac{1}{p})=n\times phifac_{n-1}$.

这样我们就得到了阶乘的欧拉函数的递推式。

预处理出阶乘和欧拉函数，对于每个询问计算 $M!$ 的逆元即可。

但是题目中没有规定 $R\leq N$ 所以有可能会出现 $R|N!$，预处理阶乘和欧拉函数的时候要记得特判如果 $R|i$ 那么要把 $i$ 中的 $R$ 因子全部除掉再计算。

最后特判一下，如果 $\lfloor \frac{N}{R}\rfloor>\lfloor\frac{M}{R}\rfloor$  （即 $N!$ 中 $R$ 因子更多）则答案为 $0$.

```cpp
#include <cstdio>
using namespace std;
inline int read() {
	int res=0,f=1; char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1; ch=getchar();}
	while(ch>='0'&&ch<='9') {res=res*10+ch-'0'; ch=getchar();}
	return res*f;
}
const int MAXN=10000005;
int T,r,n,m;
int ispr[MAXN];
int pri[MAXN];
int fct[MAXN];
int phi[MAXN];
inline void IsPrImE() {
	int cnt=0;
	ispr[0]=ispr[1]=1;
	for(register int i=2;i<MAXN;++i) {
		if(!ispr[i]) 
			pri[++cnt]=i;
		for(register int j=1;j<=cnt;++j) {
			if(1ll*i*pri[j]>=MAXN) break;
			ispr[i*pri[j]]=1;
			if(!i%pri[j]) break;
		}
	}
}
inline long long qpow(int x,int p) {
	long long res=1;
	while(p) {
		if(p&1) res=1ll*res*x%r;
		p>>=1; x=1ll*x*x%r;
	}
	return res;
}
signed main() {
	IsPrImE();
	T=read(); r=read();
	fct[0]=phi[0]=1;
	for(register int i=1;i<MAXN;++i) {
		int x=i,k=0;
		while(x%r==0) x/=r,++k;
		fct[i]=fct[i-1]*1ll*x%r;
		x=i-1+ispr[i],k=0;
		while(x%r==0) x/=r,++k;
		phi[i]=phi[i-1]*1ll*x%r;
	}
	while(T--) {
		n=read(); m=read();
		long long ans=1ll*fct[n]*phi[m]%r*qpow(fct[m],r-2)%r;
		if(n/r>m/r) ans=0;
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：言琢დ (赞：21)

## 题意简述

**本题多测。最高可达 1w 组测试数据。**

求 $1\sim N!$ 中与 $M!$ 互质的数的个数，对 $R$ 取模。

$N,M$ 在线性范围，$R$ 是一个可能很大的素数。

## $\rm Analysis$

#### 引理 $1$

考虑某一个数 $x$，与 $M!$ 互质，即

$$\gcd(x,M!)=1$$

即与每一个因子都互质，即

$$\gcd(x,1),\gcd(x,2),\cdots,\gcd(x,M)$$

均为 $1$。

那么某一个合数因子，必能表示成多个不大于 $M$ 的质数因子的积。

题意即转求

$$\gcd(x,p_1),\gcd(x,p_2),...,gcd(x,p_K)$$

均为 $1$。

其中 $p_{1\cdots K}$ 表示不大于 $M$ 的全体素数。

那么答案即为 $1\sim N!$ 中与 $\{p_K\}$ 互质的数的个数。

#### 引理 $2$

若存在两个数，$x\le y$，答案是要求 $1\cdots x$ 的贡献。

我们也可以通过计算 $1\cdots y$ 的贡献减去 $x+1\dots y$ 的贡献来得到 $1\cdots x$ 的贡献。

#### 最后一击

由引理 $1$ 可知答案是 $1\cdots N!$ 中与 $\{p_K\}$ 互质的数的个数。

由引理 $2$ 可将上面的问题转化为：

$$\begin{aligned}&\text{(1}\sim \text{N! 中与 N! 互质的个数)}\\-&\text{(1} \sim\text{N! 中与 (M+1)*(M+2)*..*(N-1)*N 互质的个数)}\end{aligned}$$

前者，$1\sim N!$ 中与 $N!$ 互质的个数，就是欧拉函数 $\varphi(N!)$。

$$\varphi(N!)=N!\times\dfrac{p_1-1}{p_1}\times\dfrac{p_2-1}{p_2}\times\cdots\times\dfrac{p_K-1}{p_K}$$

后者对答案的贡献是零。

因为若存在因子 $p_i\in(M\sim N)$，与 $N!$ 个数中某些数互质，那 $p_i$ 一定不与 $M!$ 互质。

故不存在贡献。

所以答案即为

$$N!\times\dfrac{(p_1-1)\times(p_2-1)\times\cdots\times(p_k-1)}{(p_1\times p_2\times\cdots\times p_k)}$$

#### Hack 数据原理

当 $R\le M\le N$ 时，$N!$ 中的 $R$ 与分母中的 $R$ 会约去，而直接求逆元会导致答案为 $0$。

考虑 $3$ 种情况：

- $R>N$: 正常该怎么做怎么做。

- $R\in[M,N]$：这时分子 $(N!)$ 中存在 $R$ 因子，分母 $(M!)$ 中不存在 $R$ 因子，答案恰好为 $0$。

- $R<M$：这时分子分母均含有 $R$，若 $\text{(分子\%R*分母逆元\%R)}$ 答案显示应是零，但实际不是零。

如下面这个例子：$\dfrac{2!}{2!}=1$，$\bmod~2$ 意义下正解应为 $1$。

但分子 $2!\bmod 2=0$，再乘上个逆元，不管逆元是多少，模 $2$ 它还是零。这就错了。

解决办法：特判 $R\le M$ 时，分子分母计算的时候都不乘上 $R$ 因子，等于是约分掉了。

```cpp
#include<cstdio>
#include<algorithm>
inline int in();
inline void wr(int);
const int N=(int)1e7+5,M=(int)3e6+5;
int p[M],fac[N],p1[M],p2[M];bool vis[N];
inline void prime();
inline int quick_mod(int,int,int);
int main(int argc,char**argv){
	prime();
	register int T=in(),R=in();
	fac[0]=1;
	for(register int i=1;i<N;++i)
		if(i!=R)fac[i]=fac[i-1]*1ll*i%R;
		else fac[i]=fac[i-1];
		/*特判：约分！*/
	p1[1]=(p[1]-1)%R;p2[1]=p[1];
	for(register int i=2;i<=p[0];++i)
		p1[i]=p1[i-1]*1ll*(p[i]-1)%R,p2[i]=p[i];
	/*p1[i]表示前i个素数-1相乘的结果*/
	for(register int i=1;i<=p[0];++i)
		if(p[i]!=R)p[i]=quick_mod(p[i],R-2,R);
	for(register int i=2;i<=p[0];++i)
		if(p[i]!=R)p[i]=p[i]*1ll*p[i-1]%R;
		else p[i]=p[i-1];
	while(T--){
		register int n=in(),m=in();
		if(m<R&&R<=n)
			{puts("0");continue;}
		register int id=std::upper_bound(p2+1,p2+1+p[0],m)-(p2+1);
		if(id<1)
			wr(fac[n]),putchar('\n');
		else
			wr(fac[n]*1ll*p1[id]%R*1ll*p[id]%R),putchar('\n');
	}
}
inline int quick_mod(int a,int b,int c){
	register int s=1;
	while(b){
		if(b&1)s=(s*1ll*a)%c;
		a=(a*1ll*a)%c;b>>=1;
	}
	return s;
}
inline void prime(){
	for(register int i=2;i<N;++i)
		if(!vis[i]){
			p[++p[0]]=i;
			if(i*1ll*i>=N)continue;
			for(register int j=i*i;j<N;j+=i)
				vis[j]=1;
		}
}
inline int in(){
	register char c=getchar();
	register int x=0,f=1;
	for(;c<'0'||c>'9';c=getchar())
		if(c=='-')f=-1;
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+(c&15);
	return x*f;
}
inline void wr(int x){
	if(x<0)putchar('-'),x=-x;
	if(x/10)wr(x/10);
	putchar(x%10+'0');
}
```


---

## 作者：yhgalaxy (赞：12)

题意是 $n!$ 以内与 $m!$ 互质的数的个数 $(n\geq m)$。

根据欧几里得算法 $\gcd(a,b)=\gcd(a+kb)$，那么如果 $y|x$，x以内与y互质的数的个数，就是 $\varphi(y)x/y$，此题 $n!$ 是 $m!$ 的倍数，所以答案为
$$\frac{n!\varphi(m)}{m!}=\frac{n!\prod_{i=1}^m(i-isprime(i))}{m!}$$
筛法求出n以内的素数，预处理阶乘和phi，每次询问直接回答。

但注意到题目并没有说明模数R的范围，所以1~n的数中有可能含有R的倍数，式子中有除法，询问时使用逆元可能会出问题。可以将数表示成 $a\times R^k$ 的形式，分别存储a和k，做乘法时a相乘k相加，做除法时a乘逆元k相减，判断一下k是否等于0，即可解决这一问题。
```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;

#define Rep(i,l,r) for (int i = (l); i <= (r); ++ i)
#define RepD(i,r,l) for (int i = (r); i >= (l); -- i)
#define RepG(i,x) for (int i = hd[x]; i; i = e[i].nxt)

typedef long long ll;

const int N = 10000005;

bool np[N];
int mod, n, m, fac[N], phi[N], fac0[N], phi0[N];

ll power (ll x, int n) {
	ll s = 1;
	while (n) {if (n&1) (s *= x) %= mod; (x *= x) %= mod, n >>= 1;}
	return s;
}

int main () {
	int T, lim = 1e7;
	scanf ("%d%d", &T, &mod);
	np[1] = 1;
	Rep(i,2,lim) if (!np[i])
		for (int j = 2*i; j <= lim; j += i) np[j] = 1;
	fac[0] = phi[0] = 1, fac0[0] = phi0[0] = 0;
	Rep(i,1,lim) {
		int x = i, k = 0;
		while (x%mod==0) x /= mod, ++ k;
		fac[i] = 1ll*fac[i-1]*x%mod, fac0[i] = fac0[i-1]+k;
		x = (np[i]? i: i-1), k = 0;
		while (x%mod==0) x /= mod, ++ k;
		phi[i] = 1ll*phi[i-1]*x%mod, phi0[i] = phi0[i-1]+k;
	}
	while (T --) {
		scanf ("%d%d", &n, &m);
		ll ans = 1ll*fac[n]*phi[m]%mod*power (fac[m], mod-2)%mod;
		if (fac0[n]+phi0[m]-fac0[m]) ans = 0;
		printf ("%lld\n", ans);
	}
	return 0;
}

```

---

## 作者：Prean (赞：11)

最优解来写题解啦（

# 题目大意：

多测：
$$ \sum_{i=1}^{n!}[\gcd(i,m!)=1] $$
根据 $ \rm gcd $ 的结论，我们可以得到答案其实是：
$$ \frac {n!} {m!} \times \varphi(m!) $$
恩，然后我们就可以直接做了

预处理 $ n! $ 及其逆元，以及 $ \varphi(n!) $。

那么怎么得到 $ \varphi(n!) $ 呢？考虑从 $ \varphi((n-1)!) $ 递推过来。

注意到 $ n! $ 有一个性质，就是其为所有不大于 $ n $ 的质数的倍数。也就是说 $ \varphi(n!) $ 可以写成：
$$ \prod_p^n \varphi(p^k) $$
其中所有的 $ k $ 一定都不小于 $ 1 $。
分类讨论一下：

1. 当 $ n $ 为质数时，$ \varphi(n!)=\varphi((n-1)!) \times (n-1) $
2. 当 $ n $ 不为质数时，$ \varphi(n!)=\varphi((n-1)!) \times n $

于是可以递推得到 $ \varphi(n!) $。

那么对于前面的那个分数，都知道当 $ n \geq mod $ 并且 $ m \geq mod $ 时是不能直接算的，因为 $ n! $ 中的 $ mod $ 和 $ m! $ 中的 $ mod $ 有可能会抵消掉。

于是在递推阶乘的时候可以特判一下，当 $ i=mod $ 时直接令 $ n!=(n-1)! $。

在计算的时候再判断一下 $ \lfloor \frac n {mod} \rfloor $ 是否等于 $ \lfloor \frac m {mod} \rfloor $ 就可以避免这个问题了。

复杂度为 $ O(n+T) $。

code:
```cpp
#include<cstdio>
typedef __uint128_t L;
typedef unsigned long long ull;
const int M=1e7+5;
int T,P,mx,top,n[10005],m[10005],pri[M],phi[M],fac[M],ifac[M];bool zhi[M];
struct FastMod{
    ull b,m;
    FastMod(ull b):b(b),m(ull((L(1)<<64)/b)){}
    friend inline ull operator%(const ull&a,const FastMod&mod){
        ull q=(L(mod.m)*a)>>64;
        ull r=a-q*mod.b;
        return r>=mod.b?r-mod.b:r;
    }
}mod(2);
signed main(){
	register int i,j,x;
	scanf("%d%d",&T,&P);phi[1]=fac[1]=ifac[1]=1;mod=FastMod(ull(P));
	for(i=1;i<=T;++i)scanf("%d%d",n+i,m+i),mx=n[i]>mx?n[i]:mx,mx=m[i]>mx?m[i]:mx;
	for(i=2;i<=mx;++i){
		if(!zhi[i])pri[++top]=i,phi[i]=1;
		for(j=1;j<=top&&(x=i*pri[j])<=M;++j){
			zhi[x]=true;if(!(i%pri[j]))break;
		}
		phi[i]=i-phi[i];
	}
	for(i=2;i<=mx;++i){
		if(i^P)fac[i]=1ull*fac[i-1]*i%mod,ifac[i]=1ull*(P-P/i)*ifac[P%i]%mod;
		else fac[i]=fac[i-1],ifac[i]=1;
	}
	for(i=2;i<=mx;++i)phi[i]=1ull*phi[i-1]*phi[i]%mod,ifac[i]=1ull*ifac[i-1]*ifac[i]%mod;
	for(i=1;i<=T;++i)printf("%d\n",n[i]-n[i]%P==m[i]-m[i]%P?1ull*fac[n[i]]*ifac[m[i]]%mod*phi[m[i]]%mod:0);
}
```

---


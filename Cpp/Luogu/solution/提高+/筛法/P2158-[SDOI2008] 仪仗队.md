# [SDOI2008] 仪仗队

## 题目描述

作为体育委员，C 君负责这次运动会仪仗队的训练。仪仗队是由学生组成的 $N \times N$ 的方阵，为了保证队伍在行进中整齐划一，C 君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐（如下图）。

![](https://cdn.luogu.com.cn/upload/pic/1149.png)

现在，C 君希望你告诉他队伍整齐时能看到的学生人数。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le N \le 40000$。

## 样例 #1

### 输入

```
4```

### 输出

```
9```

# 题解

## 作者：Nemlit (赞：229)

## [原文地址](https://i.cnblogs.com/EditPosts.aspx?postid=10293067)

发现这道题的题解大多都没有详细讲欧拉函数，所以本弱就来详细将讲欧拉函数

欧拉函数是小于$x$的整数中与$x$互质的数的个数，一般用$φ(x)$表示。特殊的，$φ(1)=1$。

如何计算出$1-n$欧拉函数呢？

~~我会GCD暴力枚举！~~

复杂度$O(n^2logn)$

~~我会递推~~

复杂度$O(n^2)$

递推式：

$φ(n)=n*∏(1-\frac{1}{pi})$（其中pi为n的所有质因数）

这个递推式的推到比较简单，因为$n$里面一定有$n*\frac{1}{pi}$个数是$pi$的倍数，所以我们就有$n*(1-\frac{1}{pi})$个数不是pi的个数

于是我们想知道$1-n$中有多少数不是所有$pi$倍数，我们自然可以想到乘法原理，就可以推出我们的递推式了。

其实我们也可以$O(1)$推出欧拉函数，即$φ(p)=p-1$,但是p要是质数，怎么证明呢？显然因为$p$是质数，所以他的质因数一定只有1和他本身，所以我们代入公式，即$φ(p)=p*(1-\frac{1}{p})=p*\frac{p-1}{p}=p-1$

我们有一个关于欧拉函数的性质，当$n>1$时，小于n的数中，与n互质的数的总和为：$\frac{φ(n)*n}{2}$。这个公式证明需要用到一个定理~~（其实是我太菜了不会证明）~~若$n$互质的数有一个是$m$，那么还存在另一个数$n-m$也与$n$互质。

所以与$n$互质的数的平均数是$\frac{n}{2}$，而个数又是$φ(n)$，可以得到这些数的和就是$\frac{φ(n)*n}{2}$。

其实根据上面那个定理，我们也可以得到另一个性质：当$n>2$时，$φ(n)$是偶数

那可不可以线性递推出$1-n$中所有的欧拉函数呢？

联想到我们是怎么筛出$1-n$中所有质数的呢？

### [不会的同学可以戳一戳](https://tbr-blog.blog.luogu.org/solution-p3912)

根据该链接的第一个算法，我们可以推出类比推出筛欧拉函数的方法

首先我们把所有的欧拉函数都设为它本身，然后再根据公式除以n所有的质因子（质因子可以靠筛法）

每当我们找到一个质数时，我们把它所有的倍数（即有质因子为该质数的数）乘以$(1-\frac{1}{pi})$即$(\frac{pi-1}{pi})$即可

以下算法复杂度为$O(nlogn)$
```cpp
il void work(int n) 
{ 
	for(re int i=1;i<=n;++i) 
    {
    	p[i]=i; 
    }
    for(re int i=2;i<=n;++i) 
    { 
    	if(p[i]==i)//如果i是质数
    	{ 
        	for(re int j=i;j<=n;j+=i) 
            { 
            	p[j]=p[j]/i*(i-1);//那么就把i的所有倍数筛出来 
            } 
        } 
    }
}
```

既然我们可以利用第一种筛法求出所有欧拉函数，那么我们可不可以根据欧拉筛推出所有的欧拉函数呢？显然是可以的。

我们需要计算的东西其实和上面的方法一样，下面给出代码。
```cpp
il void euler(int n) 
{
	p[1]=1;//1要特判 
    for(re int i=2;i<=n;++i) 
    { 
    	if(!b[i])//这代表i是质数 
        { 
        	prime[++num]=i; 
            p[i]=i-1; 
        } 
    	for(re int j=1;j<=num&&prime[j]*i<=n;++j)//经典的欧拉筛写法 
    	{ 
    		b[i*prime[j]]=1;//先把这个合数标记掉 
        	if (i%prime[j]==0) 
        	{ 
        		p[i*prime[j]]=p[i]*prime[j];//若prime[j]是i的质因子，则根据计算公式，i已经包括i*prime[j]的所有质因子 
           	 break;//经典欧拉筛的核心语句，这样能保证每个数只会被自己最小的因子筛掉一次 
        	} 
        	else 
        	{
        		p[i*prime[j]]=p[i]*p[prime[j]];//利用了欧拉函数是个积性函数的性质 
        	}
    	} 
    } 
}
```
## 例题：P2158 [SDOI2008]仪仗队 

通过观察发现，可以被看到的人必须满足$gcd(x,y)=1$，证明也很简单，如果$x,y$不互质的话，那么一定会有$(x/gcd(x,y),y/gcd(x,y))$把$(x,y)$挡住，换句话说，如果$gcd(x,y)$等于1，那么它一定可以把所有的$(kx,ky)$都挡住，所以我们只需要求出与$x,y$互质对的对数即可。

通过观察也可以发现，可以看到的人一定满足对称关系，所以我们只需要算出一个三角形（下面会提到）的对数在乘以$2+1$ ($2,2$也满足条件)

所以我们要算下图中为$1$的答案的对数即可
```
0000
0001
0011
0111
```
那我们怎么求呢？显然可以用欧拉函数来求出与每一个数互质的数的个数即可。

### 具体实现：

我们先算出$1~n$中所有的欧拉函数（$n$比较小，没必要用欧拉筛）,再把$1~n-1$所有的欧拉函数加起来就可以得到上图三角形内答案了。

为什么是$n-1$呢？我们不难发现，上图中小三角形只有$n-1$排，所以就是$n-1$啊

但这道题有一个坑点，如果$n==1$，那我们的答案应该是$0$而不是$1$，为什么呢？我们仔细回忆一下，我们为什么要$+1$呢？因为我们有一个$(2,2)$来特判（两个三角形的分界），如果$n==1$的话，显然就不需要$+1$了

时间复杂度：$O(n^2)->O(n)$

代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
#define re register
#define maxn 400005
int n,ans,p[maxn];
int main()
{
    cin>>n;
    for(re int i=1;i<=n;++i)
    {
        p[i]=i;
    }
    for(re int i=2;i<=n;++i)
    {
        if(p[i]==i)
        {
            for(re int j=i;j<=n;j+=i)
            {
                p[j]=p[j]*(i-1)/i;
            }
        }
    }
    for(re int i=1;i<n;++i)
    {
        ans+=p[i];
    }
    printf("%d\n",(n==1)?0:ans<<1|1);
    return 0;
}
```

后来学了莫比乌斯反演，发现这题还可以用莫比乌斯反演做。

题目所求即为：$\sum_{i=1}^{n-1}\sum_{j=1}^{n-1}[gcd(i,j)==1]$

按照莫比乌斯反演的套路，原式=$\sum_{i=1}^{n-1}\sum_{j=1}^{n-1}\sum_{g|gcd(i,j)}\mu(i)$

i,j同时除以g得：原式=$\sum_{g=1}^{n}\mu(i)\sum_{i=1}^{\frac{n-1}{g}}\sum_{j=1}^{\frac{n-1}{g}}=\sum_{g=1}^{n}\mu(i)*\frac{n-1}{g}*\frac{n-1}{g}$

时间复杂度：$O(n^2)->O(n)$，当然这个复杂度对于此题已经够用了

然后我们发现$\frac{n-1}{g}$在一定范围内是相等的，所以我们可以用整出分块优化，不算预处理时间复杂度：$O(n)->O(\sqrt{n})$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define debug printf("Now is Line : %d\n",__LINE__)
#define file(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define mod 1000000007
il int read()
{
    re int x=0,f=1;re char c=getchar();
    while(c<'0'||c>'9') {if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return x*f;
}
#define maxn 40000
int mu[maxn+5],prim[maxn+5],vis[maxn+5],cnt,n,ans;
signed main()
{
	n=read()-1;
	if(!n) return puts("0"),0;
    mu[1]=1;
    for(re int i=2;i<=n;++i)
    {
        if(!vis[i]) prim[++cnt]=i,mu[i]=-1;
        for(re int j=1;j<=cnt;++j)
        {
            if(prim[j]*i>n) break;
            vis[prim[j]*i]=1;
            if(i%prim[j]==0) break;
            mu[i*prim[j]]=-mu[i];
        }
    }	
	for(re int i=1;i<=n;++i) mu[i]+=mu[i-1];
	for(re int l=1,r;l<=n;l=r+1)
	{
		r=n/(n/l);
		ans+=(mu[r]-mu[l-1])*(n/l)*(n/r);
	}
	printf("%d",ans+2);
    return 0;
}
```

---

## 作者：unsigned (赞：109)

裸的欧拉函数题。e(i)为有多少个小于i的与i互质的数。

可以把点看做坐标轴。求左下角的点是(1,1)，然后求有多少个点(1,1)相连斜率不同的一次函数y=kx。求k的个数。

因为k=y/x。想要y/x不同，y与x一定互质(k=y/x=y\*z/x\*z)，不同的互质数相除又一定不同。所以只要求在n范围内有多少对x,y互质。

就相当于求ans+=e[i] (2<=i<=n)。

第一列和第一行特殊考虑，ans=2。

n--。再求ans+=e[i] (2<=i<=n)即可。


```cpp
    #include<iostream>
    #include<algorithm>
    #include<cstring>
    using namespace std;
    typedef long long ll;
    const int maxn=40010;
    ll e[maxn];
    int main(){
        ll n,ans=2;
        cin>>n;
        if(n==1){
            cout<<0;
            return 0;
        }
        for(int i=1;i<=n;++i)e[i]=i;
        for(int i=2;i<=n;++i){
            if(e[i]==i){
                for(int j=i;j<=n;j+=i){
                    e[j]=e[j]/i*(i-1);
                }
            }
        }
        --n;
        for(int i=2;i<=n;++i){
            ans+=e[i]*2;
        }
        cout<<ans+1; //(2,2)这个点也算
        return 0;
}
```

---

## 作者：Jayun (赞：43)

# 前言：

[~~更不好的阅读~~](https://www.cnblogs.com/GJY-JURUO/p/11392677.html )

这篇题解真的写了很久，改了又改才成为这样的，我不会写题解但我正在努力去学，求通过，求赞。。。

# 题目：

![](https://s2.ax1x.com/2019/08/22/mwpGSU.png)

[BZOJ](https://www.lydsy.com/JudgeOnline/problem.php?id=2190)

[Luogu](https://www.luogu.org/problem/P2158)

# 思路：

像我这样的数论菜鸡就不能一秒切这题，怎么办呢？

拿个栗子手玩一下：

[](https://www.lydsy.com/JudgeOnline/images/2190.jpg)

假设$n=6$，我们看看主人公可以看到的人的位置和他自己的位置有什么关系

随便选几个点,$(1,4),(2,6),(4,4)$,主人公在$(6,1)$

经过大于几分钟的时间，我发现了一个性质

$$|~x-x'~|\text{和}|~y-y'~|\text{互质时就能看到(设(x,y)表示主人公位置,(x',y')表示某同学位置)}$$

这样我们就可以枚举$x-x'$的值和$y-y'$的值了， 但是时间爆炸：

![](https://s2.ax1x.com/2019/08/22/mwpBY6.png)

怎么办呢？


$1 \leq  N \leq  40000$这里的话我们原来的$O(n^2)$是肯定过不了的，有没有比较快的做法？？？

~~废话肯定有啊不然这题出出来了~~

对噢，我们可以用欧拉函数来做呀！

下面有一篇写得比较好的洛谷日报链接，请**先阅读完本篇题解**，感兴趣的再点

[~~點❤開❤有❤驚❤喜~~](https://www.luogu.org/blog/Morning-Glory/ou-la-ji-lie-yang-xi-zheng-ming-post)

再给你们看一个东西：

![](https://s2.ax1x.com/2019/08/22/mwpop8.png)

它逆时针旋转45°后左右对称了！

也就是说它拥有对称性。

先放着不管（~~那你为什么现在放粗来呀~~）

上面说了，如果要看得到那么要满足$gcd(|~x-x'~|~,~|~y-y'~|) =1$。

我们假设$|~x-x'~|~<~|~y-y'~|$。

如果我们固定了$|~y-y'~|$要找满足条件的$|~x-x'~|$。那么这样一来答案不就是$3+2*\sum_{i=2}^{n-1}\varphi (i)$了?（这里乘$2$是因为我们只做了当$|~x-x'~|~<~|~y-y'~|$的部分，又因上文写道这满足对称性所以我们可以乘$2$。加$3$是因为我们特判了$(0,1),(1, 0),(1,1)$这$3$点。）

对于$\varphi$函数，$\varphi (i)$表示**小于i，且和i互质的数的个数**，~~好了，你看完这句你就可以点开上面那条链接了~~。

我们可以用一个$O(n~log~n)$的埃氏筛去预处理$\varphi$函数(见代码部分)，或者使用一个$O(n)$的来预处理（~~请自行翻阅资料~~）。

# 代码：

关于埃氏筛$\varphi$函数：

![](https://s2.ax1x.com/2019/08/22/mwpL0s.png)

主程序（哎呀，$\texttt{int main()}$没截到QAQ）：

![](https://s2.ax1x.com/2019/08/22/mwpO7n.png)


❤感谢收看❤

---

## 作者：卜卜 (赞：42)

看出来的话就很简单了


首先需要一些直角坐标系的知识


将左下角当做原点(0,0) 建立直角坐标系 那么假想从原点向每个点连一条线


那么什么点是看不到的呢？就是一些点的斜率是相同的 (当然y轴不存在斜率 单独讨论一下)


设两个点 $(x1,y1) , (x2,y2)$


那么显然$k_{1}=\frac {x1}{y1},k_{2}=\frac{x2}{y2}$


当$k1=k2$ 时这两个中至少有一个点看不到


将$\frac{x1}{y1}$或者$\frac{x2}{y2}$约分成最简形式得到某个 $\frac{x3}{y3}$


那么在这条斜率 $k=\frac{x3}{y3}=\frac{x1}{y1}=\frac{x2}{y2}$ 中


只能看到点$(x3,y3)$ 那么我们的任务就变成了求一些点$(x,y)$


使得 $[gcd(x,y)=1]$


又因为我们把左下角当做坐标轴的原点(0,0),所以最上面一行不是n 而是 n-1


为了避免$x=0$ 或者$y=0$这种尴尬局面,我们特别讨论一下在x轴上和y轴上的贡献


那么$ans= \sum_{i=1}^{n-1}\sum_{i=1}^{n-1}[gcd(i,j)=1]$


也就是 $ans=2* \sum_{i=1}^{n-1} \varphi(i) - \sum_{i=1}^{n-1}[gcd(i,j)=1]$


即 $ans=2*\sum_{i=1}^{n-1}\varphi(i) - 1$


当然也可以莫比乌斯反演 可能还更加简单易懂


$ ans= \sum_{i=1}^{n-1}\sum_{i=1}^{n-1}\sum_{d|i,d|j}\mu(d)=\sum_{d=1}^{n-1}\mu(d)*\lfloor\frac{n-1}{d}^{2}\rfloor$

然后x和y轴单独提出来考虑 可以看到(0,1)和(1,0)两个点


那么$ans+=2$ 得到答案

PS:n=1的时候我当时并没有考虑，必须特判一下emmm 直接复制粘贴的代码全都挂了




```cpp
//Okazaki Tomoya 
//1.048596  Okabe Rintarou
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<ctime>
#include<queue>
#include<cmath>
using namespace std;
inline int getint()
{
    static int x; static bool f; static char c;
    x=0,f=0; do {c=getchar(); if(c=='-') f=1;} while(c<'0'||c>'9');
    while(c>='0' && c<='9') {x=x*10+c-'0'; c=getchar();} return f?-x:x;
}
const int maxn=40011;
int tot; bool vis[maxn];
int phi[maxn],n,pre[maxn];
int main()
{
    n=getint()-1; int i,j,x; phi[1]=phi[0]=1;
    if(n==0) {printf("0\n"); return 0;}
    for(i=2;i<=n;++i) {
        if(!vis[i]) pre[++tot]=i,phi[i]=i-1;
        for(j=1;(x=i*pre[j])<=n;++j) {
            vis[x]=1;
            if(i%pre[j]) phi[x]=phi[i]*(pre[j]-1);
            else {phi[x]=phi[i]*pre[j]; break;}
        }
        phi[i]+=phi[i-1];
    }
    printf("%d\n",phi[n]<<1|1); //这里只是碰巧可以用位运算得到答案就这样写了
    return 0;
}
```



---

## 作者：Dawn_Chase (赞：34)

**P党的福利**

【算法分析】

当n=1时

显而易见，答案为0.

当n>1时

我们将这个正方形分为三部分，

显而易见，一定有3个点（1，0）（1，1）（0，1）满足条件。

我们把这三个点所在的直线先放在一旁，

我们通过观察可以发现，

从第三行开始，

**第i行中当前直角三角形范围内能观察到的点数等于(i-1)的欧拉函数值**  //**核心思想**

将得出的答案\*2+3即是最终答案。

当然，我们还需要一些欧拉函数（我们假定n的欧拉函数值为phi[n]）的性质：

1、当n为质数时, phi[n]=n-1。

2、若m,n互质，phi[m\*n]=phi[m]\*phi[n]。

-----------------------分割线-----------------------

【代码】


```cpp
    var n,i,j,sp,ans:longint;
    p:array[1..40000] of boolean;
    f,phi:array[1..40000] of longint;
begin
  read(n);
  if n=1 then             //特判
   begin
    writeln(0);
    halt;
   end;
  for i:=2 to n-1 do
   begin
    if not p[i] then
     begin
      inc(sp);
      f[sp]:=i;
      phi[i]:=i-1;                 //当n为质数时, phi[n]=n-1。
     end;
    for j:=1 to sp do
     if f[j]*i<=n then
      begin
       p[f[j]*i]:=true;
       if i mod f[j]=0 then
        begin
         phi[f[j]*i]:=f[j]*phi[i];           //积性函数性质：若m,n互质，phi[m*n]=phi[m]*phi[n]。
         break;                                //防止重复筛
        end
       else
        phi[f[j]*i]:=(f[j]-1)*phi[i];     //同理
      end
     else
      break;
   end;
  for i:=2 to n-1 do      //累加答案
   ans:=ans+phi[i];
  writeln(ans*2+3);
end.
```
P.S. 代码风格较丑，望谅解。

---

## 作者：D_14134 (赞：32)

### 思路：
这个正方形是对称的… 

而且很显然对角线上只有一个点会被看到… 

![](https://cdn.luogu.com.cn/upload/pic/45440.png)
所以我们只需要考虑对角线下面的一半(标红的).. 
 
显然,对于点(i,j)(i,j)如果gcd(i,j)≠1gcd(i,j)≠1,那么一定会被

(igcd(i,j),jgcd(i,j))(igcd(i,j),jgcd(i,j))挡住

所以我们要找第ii列中,gcd(i,j)=1gcd(i,j)=1的jj的个数

也就是∑ni=2∑i−1j=1gcd(i,j)=1∑i=2n∑j=1i−1gcd(i,j)=1 

而很明显这就是欧拉函数的定义

也就是说这个题让求的不过是∑ni=2φ(i−1)∑i=2nφ(i−1) 

而欧拉函数是个积性函数, 可以被线筛出来
# code
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define int long long
using namespace std;
int n,ans;
int Star_Platinum(int n){//真正的欧拉函数。
	int sum=n;
	for(int i=2;i*i<=n;i++)
		if(n%i==0){
			sum-=sum/i;
			while(n%i==0) n/=i;
		}
	if(n>1) sum-=sum/n;
	return sum;
}
signed main(){
	scanf("%lld",&n);
	if(n==1){printf("0\n");return 0;}//特判第一个点，被卡了好久QAQ。
	for(int i=2;i<=n-1;i++) ans+=Star_Platinum(i);
	printf("%lld\n",ans*2+3);
	return 0;
}
```

---

## 作者：china·xyc (赞：22)

#### 广告
[可以来我的博客看鸭，哪怕不点赞刷刷阅读量也是好的啊，谢谢资瓷~](https://blog.csdn.net/china_xyc/article/details/103015749)
### 数学题
简而言之就是
$$\sum_{i=1}^{n}\sum_{j=1}^{n}[gcd(i,j)==1]$$
很明显这玩意就是:
$$2\times\sum_{i=1}^{n}\phi(i)+1$$
然后题目范围N是4e4，所以这是个线性筛板子。。

然后你可能觉得本篇题解完结了，但是作为一个有理想情操，有知识信念的OIer，我们接下来继续搞：

##### 1）如果N是1e10怎么做？
杜教筛，min_25筛，洲阁筛。。。（博主全都不会）（这可能是待学习列表）

***复杂度：$O(N^{\frac{3}{4}})$***

##### 2）如果式子变动怎么做？
$$\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)==1]$$
~~不会了~~ 

至少博主在几个月前还不会。但是现在我们可以考虑莫比乌斯反演：
$$\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)==1]=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k|gcd(i,j)}\mu(k)$$
$$=\sum_{i=1}^{n}\sum_{\vartheta=1}^{min(i,m)}\mu(\vartheta)\lfloor\frac{min(i,m)}{\vartheta}\rfloor$$
$$=\sum_{\vartheta=1}^{min(n,m)}\mu(\vartheta)\lfloor\frac{n}{\vartheta}\rfloor\lfloor\frac{m}{\vartheta}\rfloor$$

还是$O(N)$解决了！！！

但是我要想一想这个式子没有什么实际意义

$\lfloor\frac{n}{\vartheta}\rfloor\lfloor\frac{m}{\vartheta}\rfloor$其实就是在$n\times m$的矩阵内划分出完整的边长为$\vartheta$的正方形的个数。（不给图了，精力有限）

这个正方形个数其实就是被$\vartheta-1$个点挡住的点的个数，然后$\mu$函数在这里起了容斥的作用。所以此题可以从每个点被几个点遮挡的方向来想。

***复杂度：$O(N)$***

##### 3）如果式子再变动怎么办？
$$\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j==k]$$

其实只要在原式上加一些改动就行了

把
$$\sum_{\vartheta=1}^{min(n,m)}\mu(\vartheta)\lfloor\frac{n}{\vartheta}\rfloor\lfloor\frac{m}{\vartheta}\rfloor$$

改成
$$\sum_{\vartheta=1}^{\frac{min(n,m)}{k}}\mu(\vartheta)\lfloor\frac{n}{k\times\vartheta}\rfloor\lfloor\frac{m}{k\times\vartheta}\rfloor$$

***复杂度：$O(N/K)$***

##### 4）如果再变动怎么办？
$$\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)<=k]$$

这个式子等于
$$\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{\lambda=1}^{k}[gcd(i,j)==\lambda]$$

$$=\sum_{\lambda=1}^{k}\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)==\lambda]$$
$$=\sum_{\lambda=1}^{k}\sum_{\vartheta=1}^{\lfloor\frac{min(n,m)}{\lambda}\rfloor}\mu(\vartheta)\lfloor\frac{n}{\lambda\times\vartheta}\rfloor\lfloor\frac{m}{\lambda\times\vartheta}\rfloor$$

就我目前的水平还不会继续化简了

***复杂度：$O(NlogK)$（根据调和求和法）因为$K>N$的时候可以直接输出$N^{2}$，所以$O(NlogN)$***

##### 总结

这道题给了我们一些启发：

~~1.万物皆可莫比乌斯反演~~ 

2.其实很多想法都是有益的，譬如说这题在一年前ljh大佬讲的时候我曾经想过和这个莫比乌斯函数相关的方法，但是那是知识有限，不会莫比乌斯函数，自然得不到这个式子，但是想法却是弥足珍贵的（虽然这个式子不需要那么想也可以轻易地通过莫比乌斯反演推出来）

---

## 作者：Adove (赞：17)

```cpp
//我们可以将图沿对角线切成两个直角三角形
//观察可以发现,从第三行开始,第i行中当前直角三角形范围内能观察到的点数等于(i-1)的欧拉函数值
//至于欧拉函数的求法,楼下的dalao已经讲得很清楚了qwq
//有的时候数论题还是要观察啊ovo
#include<cstdio>
int n;
int phi(int n)
{
    int ans,i,k;
    if(n==1)
        ans=1;
    else
    {
        ans=n;
        k=1;
        for(i=2;n!=1;i+=k)
        {
            if(n%i==0)
            {
                ans/=i;
                ans*=(i-1);
                while(n%i==0) n/=i;
                i=k;
            }
        }
    }
    return ans;
}
//求n的欧拉函数值的函数
int ans;
int main()
{
    scanf("%d",&n);
    if(n==1)
    {
        putchar('0');
        return 0;
    }
    for(int i=3;i<=n;++i)
        ans+=phi(i-1);
    printf("%d",ans*2+3);
    return 0;
}
```

---

## 作者：曾爷爷 (赞：7)

把最左下角的点作为直角坐标系的原点，我们可以用 $(x,y)$表示斜率，显然一个斜率上只能看到一个人，如果 $x$ , $y$ 不互质，那么他们可以同时除以他们的最大公约数（设为 $a$ ），即 $(x / a , y / a) $ 显然会有重复，所以只需要找到 $x,y$ 互质的点对即可。

要怎么求呢


$$\sum_{i = 1}^{n - 1}{\sum_{j = 1}^{n - 1}}{(gcd (i,j) = 1)}$$

因为该矩阵是正方形，所以以对角线为对称轴对称，所以只需求一半即可

这里求左上方的半个矩阵

当 $y = 0$ 时，跳过

当 $y = 1$ 时，找点 $(x,1)$ ，且 $x$ 与 $1$ 互质，同时必定满足 $x<1$

当 $y = 2$ 时，找点 $(x,2)$ ，且 $x$ 与 $2$ 互质，同时必定满足 $x<2$

当 $y = 3$ 时，找点 $(x,3)$ ，且 $x$ 与 $3$ 互质，同时必定满足 $x<3$

$......$

当 $y = n$ 时，找点 $(x,n)$ ，且 $x$ 与 $n$ 互质，同时必定满足 $x<n$

所以有以下公式


$$\sum_{i = 1}^{n - 1}{\varphi (i)}$$

最后 $ans * 2 + 1$ , $+1$ 是因为还有一个点在对角线上
```cpp
#include <bits/stdc++.h>
using namespace std ;
int n , p[100005] , vis[100005] , prim[100005] ,tot , ans ;
void fuckphi(int x)
{
	p[1] = 1 ;
	for (int i = 2 ; i <= x ; i ++)
	{
		if (!vis[i])
			prim[++ tot] = i , p[i] =  i - 1 ;
		for (int j = 1 ; j <= tot ; j ++)
		{
			if (i * prim[j] > n) break ;
			vis[i * prim[j]] = 1 ;
			if (i % prim[j] == 0)
			{
				p[i * prim[j]] = p[i] * prim[j] ;
				break ;
			}
			else p[i * prim[j]] = p[i] * prim[j] - p[i] ;
		}
	}
}
int main()
{
	freopen ("queue.in" , "r" , stdin) ; freopen ("queue.out" , "w" , stdout) ;
	cin >> n ;
	if (n == 1) return puts("0") , 0 ;
	fuckphi(n) ;
	for (int i = 1 ; i < n ; i ++)
	{
		ans += p[i] ;
	}
	cout << ans * 2 + 1 ;
} 
```

---

## 作者：yangrunze (赞：6)

数论蒟蒻在线讲题......这个题呢，是关于**欧拉函数**的一个很典型的题目，欧拉函数这个东西，初学起来可能会有点懵，但是如果学会了，你会发现它极其简单！跟着我来，相信大家一定能走过这个坑！废话不多说，咱们开始吧~

欧拉函数讲的到底是怎样一个故事呢？首先，咱们先来一波定义：

> **欧拉函数**表示的是**小于x**的**与x互质的数**的个数，我们把它写成$\varphi(x)$

（不会读？可以把这个符号读成fai）

for example:

与6互质的整数是1，5，一共2个，所以$\varphi(6)=2$

与10互质的整数是1，3，7，9，有4个，所以$\varphi(10)=4$

搞清了定义，那接下来咱们来研究一下这东西吧！别急，先从最特殊的情况入手！

> 当$x$为**质数**时，$\varphi(x)=x-1$

好理解！既然$x$是质数，那**除了1和它本身，$x$没有其他因数**，也就是说**小于$x$的$x-1$个数和$x$都是互质的**，所以$\varphi(x)=x-1$

进一步发现……？

> 当$x$可以写成质数的乘方，即$x=p^k$($p$为质数)的时候，$\varphi(x)=p^{k-1}\times(p-1)$

这个理解起来也不是很难，既然它可以写成质数的k次方，那咱们就把**每一段分开处理**！把它每到$p$分成一段，一共分成$\frac{p^k}{p}=p^{k-1}$段，根据刚才的性质，每一段有$p-1$个数与$x$互质，所以一共就是$p^{k-1}\times(p-1)$

另外，欧拉函数还有一条性质：

>$x$与$y$互质时，$\varphi(x \times y)=\varphi(x)\times\varphi(y)$

这个也好理解，**乘法原理**嘛！这也说明，欧拉函数是个**积性函数**，也就是说**函数的值可以通过乘积来算**

有了这几条性质，就可以研究一般的数的欧拉函数啦！通过前两个性质的铺垫，这里思路也渐渐浮出水面了：**把x分解质因数**！

也就是说，我们把x分解成这个形式：$x=\prod^{s}_ {i=1}p_i^{k_i} $

(其中$s$为质因数个数，$p_i$为第$i$个质因数，$k_i$为第$i$个质因数的个数)

哇，又出现新符号啦！好多小伙伴肯定要问了：这个$\prod$又是个什么妖孽！其实啊，这个符号和求和的$\sum$差不多，只不过它是用来求乘积的，也就是说：

$$\prod^n_{i=1}a_i=a_1 \times a_2 \times a_3 \times …\times a_n$$

好的，这回懂了吧，接下来抓稳啦！咱要推导欧拉函数$\varphi(x)$的最终公式啦！

首先，根据刚才的分解质因数，可以知道：



$$x=\prod^{s}_ {i=1}p_i^{k_i} $$

也就是说：

$$\varphi(x)=\varphi(\prod^{s}_ {i=1}p_i^{k_i})$$

然后呢，在利用一下**欧拉函数的第3个性质**，也就是**乘积**的那个

$$\varphi(x)=\varphi(\prod^{s}_ {i=1}p_i^{k_i})$$
$$=\prod^{s}_ {i=1}\varphi(p_i^{k_i})$$

再根据关于**质数乘方**的**第2条性质**

$$\varphi(x)=\prod^{s}_ {i=1}\varphi(p_i^{k_i})$$
$$=\prod^{s}_ {i=1}p_i^{k_i-1}\times(p_i-1)$$

然后咱们在**稍微调整一下下**，**把$p_i^{k_i}$单拎出来**，因为这个式子正好等于$x$嘛！

$$\varphi(x)=\prod^{s}_ {i=1}p_i^{k_i-1}\times(p_i-1)$$
$$=\prod^{s}_ {i=1}p_i^{k_i}\times(1-\frac{1}{p_i})$$
$$=\prod^{s}_ {i=1}p_i^{k_i}\times\prod^{s}_ {i=1}(1-\frac{1}{p_i})$$
至此，我们得到了欧拉函数的公式：

$$\varphi(x)=x\prod^{s}_ {i=1}(1-\frac{1}{p_i})$$

其实这个式子也可以这么理解：咱们要找的是与$x$互质的数，每找到一个质数$
p_i$，就有$\frac{x}{p_i}$个数是不和$x$互质的，那自然就有$x\times(1-\frac{1}{p_i})$个数，对于不同的质数，我们还是用乘法原理，要乘起来得到答案！这样一来，欧拉函数的公式自然就是$x\prod^{s}_ {i=1}(1-\frac{1}{p_i})$啦！

------------

公式有了，但怎么求欧拉函数呢？一个一个算？还要分解质因数，太麻烦了qwq

这里呢，我们可以用**筛法**解决问题！代码是这样的：

```cpp
bool p[10000001]={0,1};//初始化，1不是质数
for(int i=2;i<=n;i++){
		if(p[i]) //如果已经确定不是质数，就没有筛的必要了
      continue;
		for(int j=i*2;j<=n;j+=i) //既然找到这个数，那它的倍数就都不是质数了
		  p[j]=1;
}
```
（吃瓜群众：怎么觉得哪里怪怪的呢）

对不起各位，我不小心（其实是故意）拿错了，这是[筛法求质数](https://www.luogu.com.cn/problem/P3383)的代码......

不过话说回来，筛法求欧拉函数和筛法求质数的代码其实没什么差，就改改中间的部分就行啦！

改哪些部分呢，还是根据公式，一步一步分析

$$\varphi(x)=x\prod^{s}_ {i=1}(1-\frac{1}{p_i})$$

- 首先，公式是$\varphi(x)=x$再乘另外一大坨，所以咱先把每个phi[x]初始化成x
- 其次，和筛法一样，对于找到的没筛过的每一个数，对它的倍数相应处理
- 处理什么呢？注意到如果一个数是$p$的倍数，那它的质因数肯定有$p$这个数，根据公式，我们可以把它的m每一个倍数乘上个$1-\frac{1}{p_i}$，也就是$\frac{p_i-1}{p_i}$

这样的话，筛法求欧拉函数的代码就有了：

```cpp
for(int i=2;i<=n;i++){
	phi[i]=i;//先把每一个数初始化成它自己
}
for(int i=2;i<=n;i++){
	if(phi[i]!=i)//如果已经求过了，直接continue就行
	continue;
	for(int j=i;j<=n;j+=i)  
	phi[j]=phi[j]/i*(i-1);//对于每个倍数，乘上公式里的后面那一项
}
```
回过头来再看这个题：有位大佬已经很快get到了思路：**对于每个坐标$(x,y)$,只要$x$与$y$互质，那就能看到**！注意，**这里说的“坐标”是从0开始，到n-1结束的**

为啥这样就行嘞？因为**不互质的都被互质的挡住了**呗！

还有一个要注意的是，由于最左边的横坐标为0，和最下边的纵坐标为0（就是x轴和y轴），它们需要单独处理，在这里面**只有两个人是能被看到的**（也就是下图中用绿框框起来的那两位），所以我们**把答案初始化为2，到时候坐标从1开始统计**

另外，别忘了**特判n=1的情况**哟！

![](https://cdn.luogu.com.cn/upload/image_hosting/bnkf3v8s.png)

(上图中，浅橙色表示能看到的人，深橙色表示被挡住的人)

这样，我们就有了一份完美的~~36分~~代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int gcd(int x,int y){//最大公因数gcd——数论开始的地方
	if(x%y==0) return y;
	else return gcd(y,x%y);
}

int main(){
	int n,ans=2;
	cin>>n;
	if(n==1){ //特判n=1的情况
		cout<<0;
		return 0;
	} 
	for(int i=1;i<n;i++){
		for(int j=1;j<n;j++){
			if(gcd(i,j)==1) ans++;//按照刚才的结论暴力枚举
		}
	}
	cout<<ans;
	return 0;
}
```
现在有了欧拉函数，就可以变得快好多啦!而且，我们发现：**两边能看到的人数关于对角线对称**！所以我们只需要用欧拉函数**算出一边的情况，再乘2，加1即可**！为什么要加1呢？因为我们**没有算对角线上的那一个人**

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int phi[40005];
int main(){
	int n;
	scanf("%d",&n);
	if(n==1){//特判n=1的情况
		printf("0");
		return 0;
	}
	for(int i=2;i<=n;i++){//筛法求欧拉函数
		phi[i]=i;
	}
	for(int i=2;i<=n;i++){
		if(phi[i]!=i)
		continue;
		for(int j=i;j<=n;j+=i)
		phi[j]=phi[j]/i*(i-1);
	}
	int ans=1;//ans初始化（因为最后要乘2，当然初始化成1咯）
	for(int i=1;i<n;i++)//把每个互质的个数输出出来
	ans+=phi[i];
	printf("%d",ans*2+1);//乘2，加1，输出！
	return 0;
}
```
欧拉函数get!

The   end~

---

## 作者：hongzy (赞：5)

核心是欧拉函数


1. 建立平面直角坐标系，以此人的位置作为原点(0,0)，x向右，y向上

1. 坐标(x, y)满足gcd(x,y) == 1，就可以被看见(即与原点的连线上无整点)（这个如果不清楚，可以先做P1170）


1. 沿着对角线(y=x函数)分成两个直角三角形，可以看出成轴对称.计算出左上方直角三角形上的答案，乘以2，+1(对角线上有一点可以被看见)

1. 求左上方直角三角形的答案



- y=0 只有原点(跳过)

- y=1 找(x, 1)满足x < 1 且x与1互质

- y=2 找(x, 2)满足x < 2 且x与2互质

- ...

- y=N 找(x, N)满足x < N 且x与N互质

欧拉函数正是求小于N且与N互质的数的个数。不过这个三角形中所有点一定满足 x < y, 所以直接求欧拉函数即可。


欧拉函数的求法可以根据公式 φ(n) = n(1-1/p1)(1-1/p2)..(1-1/pk) (pi是质因子)



------------



```cpp
#include <iostream>
#include <cmath>
using namespace std;

int N, ans;

int Phi(int N) {
    int m = (int)sqrt(N + 0.5), ans = N;
    for(int i=2; i<=m; i++)
        if(N % i == 0) {
            ans = ans / i * (i-1);
            while(N % i == 0) N /= i;
        }
    if(N > 1) ans = ans / N * (N-1);
    return ans;
}

int main() {
    cin >> N;
    if(N == 1) { //特判.没有对角线的存在
        cout << 0 << endl;
        return 0;
    }
    for(int i=1; i<N; i++) ans += Phi(i);
    cout << ans * 2 + 1 << endl;
    return 0;
}
```

---

## 作者：Smallbasic (赞：3)

这还真是道神题。。。

考虑点(x,y)在什么情况下$\color{red}\text{不会}$被看到

由于是从(1,1)开始看，视线应该是点A(0,0)和点B(x,y)的连线，表示为函数:

$$f(i)={y\over x}i$$

如果(x,y)不会被看到，那么这条线上一定有横纵坐标皆为整数的点，且它的横坐标小于x。

设这个点为$C(x',y')$

$$\because y'\in Z,y'={y\over x}x'$$

$$\therefore {yx'\over x}\in Z$$

显然有一组解为$({x\over gcd(x,y)},{y\over gcd(x,y)})$

所以点$(x,y)$一定能被$({x\over gcd(x,y)},{y\over gcd(x,y)})$挡住。

而又有：

$${x\over gcd(x,y)}\le x, {y\over gcd(x,y)}\le y$$

两等号成立当且仅当$x\perp y$。而当等号成立时，就成了自己挡住自己，显然是可以被看到的。

所以得出结论:点(x,y)当且仅当$x\perp y$时会被看到。

原问题转化为求：

$$\sum_{i=0}^{n-1} \sum_{j=0}^{n-1} [gcd(i,j)==1]$$

为了方便假设k就是$n-1$

由于$gcd(0,i)=i$,所以原式等于：

$$\sum_{i=1}^k\sum_{j=1}^k [gcd(i,j)==1]$$

又因为$gcd(i,j)=gcd(j,i)$~~废话~~，所以：

$$=2\cdot\sum_{i=1}^k\sum_{j=1}^{i-1} [gcd(i,j)==1]+1$$

之所以上面加的是1是因为前面那坨式子或漏掉点(1,1)。

我们会发现后面那坨恰好是$\phi(i)$。

因此式子变为:
$$2\cdot\sum_{i=1}^{k}\phi(i)+3$$

考虑如何求$\sum_{i=1}^{k}\phi(i)$

还是为了适应我的习惯设$m$为$k$

先引入一个~~没什么~~概念：卷积：

若:

$$h(n)=\sum_{d|n}f(d)g(\lfloor{n\over d}\rfloor)$$

则称$h$是$f$和$g$的卷积，写作$h=f\cdot g$

回到题目

众所周知：

$$(\phi\cdot 1)(n)=\sum_{d|n}\phi(d)=n$$

记$h=\phi\cdot1$

$$\sum_{i=1}^m h(i)=\sum_{i=1}^m\sum_{d|i}\phi(d)$$

$$\sum_{i=1}^m h(i)=\sum_{i=1}^m\sum_{j=1}^{\lfloor{m\over i}\rfloor}\phi(d)$$

这一步如果不容易理解的话可以把省略掉的函数1提出来，看成交换求和号后的式子。

设:

$$S(n)=\sum_{i=1}^n \phi(i)$$

上式变为：

$$\sum_{i=1}^m h(i)=\sum_{i=1}^mS({\lfloor{m\over i}\rfloor})$$

$$\sum_{i=1}^m h(i)=\sum_{i=2}^mS({\lfloor{m\over i}\rfloor})+S(m)$$

$$S(m)=\sum_{i=1}^m h(i)-\sum_{i=2}^mS({\lfloor{m\over i}\rfloor})$$

我们知道$h(i)=(\phi\cdot1)(i)=i$,有：

$$\sum_{i=1}^m h(i)=\sum_{i=1}^m i={m^2+m\over2}$$

即是：

$$S(m)={m^2+m\over2}-\sum_{i=2}^mS({\lfloor{m\over i}\rfloor})$$

最终答案是：

$$2S(n-1)+1$$

后面整除分块的话时间复杂度大概是：

$$\Theta(\sum_{i=1}^n\sqrt{\lfloor{n\over i}\rfloor})=\Theta(\int_{i=1}^n\sqrt{\lfloor{n\over i}\rfloor}di)=\Theta(n^{2\over3})$$

应该是最优解了吧，数据范围完全可以到MAX_INT。

对了注意的是求$S(m)$要先预处理出前几千的$S(m)$,这样会更快。

还有其实快速求$\phi$前缀和的这个算法叫做杜教筛，不清楚可以去模版学习一下。

代码(记住1要特判):

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <map>

using namespace std;

typedef long long ll;

map<int, ll> sphi;
bool notprime[5001];
int t, n, prime[5001], top = 0;
ll phi[5001];

inline void pre() {
    phi[1] = 1;
    for (register int i = 2; i <= 5000; ++i) {  
        if (!notprime[i]) prime[++top] = i, phi[i] = i - 1;
        for (register int j = 1; j <= top; ++j) {  
            if (i * prime[j] > 5000) break;  
            notprime[i * prime[j]] = 1;
            if (!(i % prime[j])) {  
                phi[i * prime[j]] = phi[i] * prime[j];
                break;  
            } else phi[i * prime[j]] = phi[i] * (prime[j] - 1);
        } 
    }
    for (register int i = 2; i <= 5000; ++i) phi[i] += phi[i - 1];
}

ll calcphi(int n) {
    if (n <= 5000) return phi[n];
    if (sphi[n]) return sphi[n];
    ll rt = (ll)n * (ll)(n + 1) / 2;
    for (register unsigned int l = 2, r; l <= n; l = r + 1) {
        r = n / (n / l);
        rt -= (r - l + 1) * calcphi(n / l);
    }
    return sphi[n] = rt;
}

int main() {
    scanf("%d", &n); pre();
    if (n == 1) printf("0");
	else printf("%lld", 2 * calcphi(n - 1) + 1); 
    return 0;
}
```


---

## 作者：南方小包 (赞：3)

我们令行数从左到右为$0$到$n-1$

列数从下到上是$0$到$n-1$

我们一列一列考虑

显然第$0$列和第$1$列总共可以看见$n+1$个点

当列数$>1$时$,$每列可以看见的个数就是$[1,n-1]$中与列数互质的数的个数

嗯如果觉得与$1$互质有些怪的话$,$那就是$gcd=1$的个数

我们反过来考虑$,$求不互质的个数然后从总的里面减

所以将列数进行质因数分解

预处理出所有的$n$以内的质数可以加快这一过程

然后我们容斥求出$[1,n-1]$内的与列数不互质的数的个数

最后别忘了特判$n=1$的情况

代码如下$,$码风丑陋$,$见谅

```
#include<math.h>
#include<ctype.h>
#include<stdio.h>
#include<string.h>
#include<iostream>
#include<algorithm>
#define SIZE 50005
#define MAX 1LL<<60
#define LL long long
using namespace std;
LL n,ans=0;
LL a[SIZE];
bool check[SIZE];
LL prime[SIZE],tot;
int main()
{
	LL i,j,k;
	scanf("%lld",&n);
	if(n==1){printf("0");exit(0);}
	for(i=2;i<=n;i++)
	{
		if(!check[i])
			prime[++tot]=i;
		for(j=1;j<=tot;j++)
		{
			if(prime[j]*i>n)break;
			check[prime[j]*i]=1;
			if(i%prime[j]==0)break;
		}
	}
	for(i=2;i<n;i++)
	{
		LL co=i,cnt=0;
		for(j=1;j<=tot;j++)
		{
			if(co%prime[j]==0)
			{
				while(co%prime[j]==0)
					co=co/prime[j];
				a[++cnt]=prime[j];
				if(co==1)break;
			}
		}
		LL anss=0;
		for(j=1;j<(1LL<<cnt);j++)
		{
			LL mul=1,cc=0;
			for(k=0;(1LL<<k)<=j;k++)
			{
				if(j&(1LL<<k))
				{
					mul=mul*a[k+1];
					cc=cc+1;
				}	
			}
			if(cc&1LL)
				anss=anss+(n-1)/mul;
			else anss=anss-(n-1)/mul;
		}
		ans=ans+n-1-anss;
	} 
	printf("%lld",ans+n+1);
	return 0;
}


```

---

## 作者：COUPDETAT (赞：2)

看这题之前 先来几道类似的

# [GCD SUM](<https://www.luogu.org/problem/P2398>)

题意简单明了 十分友善

如果用欧拉函数的方法做可以很轻松的过掉 

详情请看[仪仗队](<https://www.luogu.org/problem/P2158>)

![img](https://cdn.luogu.com.cn/upload/pic/1149.png)

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<iostream>
using namespace std;
int p[1000000],phi[1000000],vis[1010101];
long long ans;
int  main(){
	
    int n;
    scanf("%d",&n);
    if(n==1){
    	cout<<0;
    	return 0;
	}
    phi[1]=1;
    for(int i=2;i<=n;i++)
    {
    	if(!vis[i])
    	p[++p[0]]=i,phi[i]=i-1;
    	for(int j=1;j<=p[0]&&i*p[j]<=n;j++)
    	{
    		vis[i*p[j]]=1;
    		if(i%p[j]==0)
    		{
    			phi[i*p[j]]=phi[i]*p[j];
    			break;
			}
			else phi[i*p[j]]=phi[i]*(p[j]-1);
		}
		//ans+=phi[i];
	}
	n--;
    ans=0;
    for(int i=1;i<=n;i++)
    {
    	ans+=phi[i];
	}
    cout<<ans*2+1;
    return 0;
}
```

代码会及其冗长

但是如果换个思路

![img](D:\OneDrive - langlangago\Pictures\2608.png)

观察这张图片 可以得到以下几个性质

1.相同点的标号等于他们的GCD

2.设一个点坐标为x,y  以gcd(x,y)为gcd的个数等于$(n/x)*(m/x)$

3.考虑对第二步从右上到左下容斥 

![](http://101.200.56.58/wp-content/uploads/2019/10/%E5%9B%BE%E7%89%87.png)

这样 我们只需要枚举gcd即可

# p2398

```cpp
#include<cstdio>
int main()
{
	long long n,m,a[100000],ans=0;
	scanf("%lld",&n);m=n;
	for(int i=1;i<=n;i++) a[i]=(n/i)*(m/i);
	for(int i=n;i>=1;i--) {
		for(int j=2;j<=n/i;j++)
			a[i]-=a[j*i];ans+=(a[i]*i);
	}	printf("%lld",ans);
}
```

# p1447

```cpp
#include<cstdio>
int main()
{
	long long n,m,a[100000],ans=0;
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++) a[i]=(n/i)*(m/i);
	for(int i=n;i>=1;i--) {
		for(int j=2;j<=n/i;j++)
			a[i]-=a[j*i];ans+=(a[i]*(i*2-1));
	}	printf("%lld",ans);
}
```



---

## 作者：傅思维666 (赞：2)

# 洛谷 P2158 [SDOI2008]仪仗队

[洛谷传送门](https://www.luogu.org/problem/P2158)



## 题目描述

作为体育委员，C君负责这次运动会仪仗队的训练。仪仗队是由学生组成的N * N的方阵，为了保证队伍在行进中整齐划一，C君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。 ![img](https://cdn.luogu.com.cn/upload/pic/1149.png) 现在，C君希望你告诉他队伍整齐时能看到的学生人数。

## 输入格式

共一个数N

## 输出格式

共一个数，即C君应看到的学生人数。

## 输入输出样例

**输入 #1**复制

**输出 #1**复制

## 说明/提示

【数据规模和约定】

对于 100% 的数据，1 ≤ N ≤ 40000





## 题解：

一道欧拉函数的经典题。原题是POJ 3090 Visible Lattice Points

来看图说话：

![](https://cdn.luogu.com.cn/upload/pic/1149.png)

观察这个图，我们首先发现，这个东西是关于直线$y=x$对称的。接下来我们观察遮挡，根据几何学中的相似知识（三角形相似），我们发现，如果有两个点的横纵坐标构成的两个三角形相似的话，那么那个较大的三角形（那个点）就会被挡住。

什么意思呢？我们发现，一个点可见的条件为：当且仅当$(x,y)\in N,x\not=y$并且$gcd(x,y)=1$，即横纵坐标互质。

因为这个图像的大小已知，并且这个图像是关于$y=x$对称的，那么我们只需要考虑半边的图像有多少点，给它乘二加三（因为有$(1,0),(1,1),(0,1)$）即可。

不需要双层循环进行枚举，只需要用一层循环枚举$y$，因为是关于$y=x$对称的，所以$x\in [1,y)$，那么，符合条件的$x$的数量就是$y$的欧拉函数$\Phi (y)$。

所以，答案为：
$$
\sum_{i=2}^{n-1}\Phi(i)\times 2+3
$$


为什么是到$n-1$而不是到$n$呢？因为原点的坐标是$(0,0)$，而这个点不能被统计到答案中去（自己不能孤芳自赏），是从0计数的。

然后就简单了，一遍线筛筛选出欧拉函数数组，直接统计答案即可，复杂度是$O(n)$的。

关于欧拉函数的知识点，如有不太清楚的，敬请移步到本蒟蒻的这篇博客：

[博客食用口味更佳](https://www.cnblogs.com/fusiwei/p/11726768.html)

---

## 欧拉函数的概念

欧拉函数的定义是：对于一个正整数$n$，它的欧拉函数是所有小于等于$n$的正整数中所有与$n$互质的数的数目。记作$\Phi (n)$

例：

$\Phi (8)=4$（$1,3,5,7$与$8$均互质）

---



## 欧拉函数的基本性质

欧拉函数的基本性质有三（最基本的）：
$$
\Phi(1)=1
$$

$$
\Phi (p)=p-1 \quad (p为质数)
$$

$$
\Phi(p^m)=(p-1)\times p^{m-1}\quad(p为质数)
$$

第一个很简单我就不说了。

第二个，因为$p$为质数，所以很显然，从$1-(p-1)$的所有数都与其互质，但是因为欧拉函数的定义是**小于等于$p$**的所有数，所以$p$自己是不满足条件的。那么就得证了。

第三个，这是个比较常用的条件。证明也比较好理解，我们可以画一个数轴（在这里我就不画了）。因为$p$是个质数，所以在整个的$p^m$个数中，只有$p$的倍数是与之不互质的，其他的数都与其互质。那么根据**容斥原理**（这个原理只要学完高中数学必修一集合那部分的都应该会），这个$\Phi (p^m)$就应该等于$p^m$减去$p^m$中$p$的所有倍数的个数。因为$p^m=p\times p\times p\cdots p\times p\quad (m个p)$，那么显然，$p$的倍数一共会有$p^{m-1}$个。那么原式可化为：
$$
\Phi(p^m)=p^m-p^{m-1}=(p-1)\times p^{m-1}
$$

---



## 求欧拉函数

根据算术基本定理，任何的一个正整数都可以被唯一分解成若干个质数的积，即：
$$
n=p_1^{m1}p_2^{m2}\cdots p_m^{mm}\quad n\in N_*
$$
我们任取一个数$p$做$n$的质因子，只论$p$的话，那么显然，$p$的倍数都应该被排除掉。同理，如果又有一个$q$也为$n$的质因子，那么$q$的所有倍数也应该被刨除掉。那么还是根据**容斥原理**，$p,q$的公倍数被排除了两遍，所以需要把多排除的那遍加回来。所以就应该是：
$$
n-\frac{n}{p}-\frac{n}{q}+\frac{n}{pq}=n(1-\frac{1}{p}-\frac{1}{q}+\frac{1}{pq})=n(1-\frac{1}{p})(1-\frac{1}{q})
$$
那么，再结合上面的算术基本定理，我们求欧拉函数的通式就应该是：
$$
\Phi(N)=N\times \prod_{质数p|N}(1-\frac{1}{p})
$$


那么，我们显然可以将其在质因数分解的过程中顺便求出来。

代码：

```cpp
int Phi(int n)
{
    ans=n;
    for(int i=2;i<=sqrt(n);i++)
        if(n%i==0)
        {
            ans=ans/i*(i-1);//这里要是看不明白就在草纸上画一下
            while(n%i==0)
                n/i;
        }
    if(n>1)
        ans=ans/n*(n-1);
    return ans;
}
```

---



## 积性函数及其相关性质

首先放一波积性函数的定义：

如果当$a,b$互质的时候，函数$f(x)$满足$f(ab)=f(a)\times f(b)$，那么$f(x)$就是一个积性函数。

显然欧拉函数是个积性函数（乘法原理）。



积性函数有很多种应用，比如欧拉函数，狄利克雷卷积，莫比乌斯反演等等（滑稽）。但是蒟蒻不会（滑稽）

---



## 线性筛选欧拉函数

当你要求$1-n$的欧拉函数的时候，刚刚的求欧拉函数的方式就比较鸡肋了。所以我们搞出了一个更快的方法——线筛与欧拉函数结合。

其实就是线筛素数，顺便就把欧拉函数也求出来了。

如果有对线筛素数不太熟悉的同学，可以移步这篇博客：

[质数相关知识点详解](https://www.cnblogs.com/fusiwei/p/11354110.html)

代码：

```cpp
void euler(int n)
{
    cnt=0;
    for(int i=2;i<=n;i++)
    {
        if(!v[i])
            prime[++cnt]=i,phi[i]=i-1;
        for(int j=1;j<=n && i*prime[j]<=n;j++)
        {
            v[i*prime[j]]=1;
            if(i%prime[j]==0)
            {
                phi[i*prime[j]]=phi[i]*prime[j];
                break;
            }
            else
                phi[i*prime[j]]=phi[i]*phi[prime[j]];
        }
    }
}
```

稍微解释一下这段代码。着重解释一下对$phi[]$数组的处理。

首先，当确定一个数为质数的时候，这个数的欧拉函数就是这个数减一，这个性质在上面有证明。

然后，在线筛模板上，如果$prime[j]$为$i$的一个质因子，那么根据上面的性质，$i\times prime[j]$的所有质因子都已经被$i$包括了。因为欧拉函数是个积性函数，所以else语句后的语句也可以被解释。

---


有了这些知识，就可以得出本题的代码了：


```cpp
#include<cstdio>
using namespace std;
const int maxn=40010;
int phi[maxn],v[maxn],prime[maxn];
int n,cnt,ans;
void euler(int n)
{
    cnt=0;
    for(int i=2;i<=n;i++)
    {
        if(!v[i])
            prime[++cnt]=i,phi[i]=i-1;
        for(int j=1;j<=n && i*prime[j]<=n;j++)
        {
            v[i*prime[j]]=1;
            if(i%prime[j]==0)
            {
                phi[i*prime[j]]=phi[i]*prime[j];
                break;
            }
            else
                phi[i*prime[j]]=phi[i]*phi[prime[j]];
        }
    }
}
int main()
{
    scanf("%d",&n);
    if(n==1)
    {
        printf("0");
        return 0;
    }
    euler(n);
    for(int i=2;i<n;i++)
        ans+=phi[i];
    printf("%d",ans*2+3);
    return 0;
}
```



---

## 作者：loceaner (赞：2)

## 思路

从$(0，0)$开始，抛开可以看到的$(0,1),(1,0),(1,1)$三个点,做出一个$5*5$的矩阵试一下，发现当每个点的斜率的分母和分子互质时，这个点才能被看到（$y==x$时除外，因为已经被$(1,1)$点挡住了），所以我们可以求欧拉函数累加，最后再加上原先的$(0,1),(1,0),(1,1)$三个点，因为是从$0$开始的所以求到$n-1$就好了，需要注意的是$ans$需要乘以二，因为我们求的只是被$y=x$这条线分开的半个部分的可以看到的数量，而上下对称，所以直接乘二，最后的答案就是$ans * 2 + 3$

## 代码


```cpp
#include <bits/stdc++.h>
#define N 40011
using namespace std;

inline int read() {
	char c = getchar();
	int x = 0, f = 1;
	for( ; !isdigit(c); c = getchar()) if(c == '-') f = -1;
	for( ; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + (c ^ 48);
	return x * f;
}

int n, phi[N];

//求欧拉函数
void enlur(int n) {
	for(int i = 2; i <= n; i++) phi[i] = i;
	for(int i = 2; i <= n; i++) {
		if(phi[i] == i) {
			for(int j = i; j <= n; j += i) {
				phi[j] = phi[j] / i * (i - 1);
			}
		}
	}
}

int main() {
	n = read();
	if(n == 1) {
		cout << '0';
		return 0;
	}
	enlur(n - 1);
	int ans = 0;
	for(int i = 2; i <= n - 1; i++) {
		ans += phi[i];
	}
	cout << ans * 2 + 3 << '\n';
	return 0;
}

```

---

## 作者：我没有开挂 (赞：2)

竟然没有打表题解，那我就来发一篇吧。

首先，身为蒟蒻的我看到这道题显然不会做，只会一个n^2算法，但是再一看数据范围，n<=40000,貌似可以打表过，不会跑太久。于是打了个表，点击了提交，然后，[代码过长].......仔细看一下发现自己的打表代码有100KB,而我似乎记得代码长度限制好像是50KB。但是我不服气，难得一道似乎可以打表过的题目我就不行过不了。

于是，我想到了可以再打表的基础上稍微打下暴力。比如可以打出所有n%1000==0的n的答案，再在上面进行暴力，时间就快了很多。

于是，便有了下面的程序:

```cpp
#include <bits/stdc++.h>

#define re register

using namespace std;

int n,cnt;

int gcd(const int &x,const int &y)
{
    return y==0?x:gcd(y,x%y);
}

int main()
{
    scanf("%d",&n);
    if(n==1||n==0)
    {
        puts("0");
        return 0;
    }
    re int len=1;
    for(re int i=1;i<n;++i)
    {
        for(re int j=1;j<=i;++j)
            if(gcd(i,j)==1) cnt+=(i==j)?1:2;
        if((i+1)%1000==0) printf("%d,",cnt+2);
    }
    return 0;
}

```

然后就打出了所有0-40000的1000的倍数的数的答案，However,当我兴致勃勃地交上去后，竟然T了3个点，然后测了一下39999,好像跑了5s。

那么就只能再减小范围了，把1000改成100，就能~~完美的~~AC了！

放一下主程序：

```cpp
#include <bits/stdc++.h>

#define MAXN 56000
#define re register

using namespace std;

int n,cnt;
int ans[]={2,6009,24305,54637,97037,151833,218681,297557,388861,492173,607585,735437,874933,1026729,1191217,1367565,1555185,1756905,1969157,2193477,2431577,2680685,2940889,3215393,3501389,3797757,4108897,4431193,4764705,5111961,5470777,5840905,6223977,6619089,7025801,7446225,7877801,8320833,8777929,9245101,9724005,10218645,10722205,11239189,11769085,12309593,12860913,13427489,14005837,14593509,15196917,15811033,16436445,17075245,17725765,18386041,19063485,19749721,20446441,21161097,21883129,22616889,23368049,24127621,24897733,25684117,26480773,27284665,28108545,28942137,29785493,30643897,31513121,32392729,33287137,34194825,35109777,36043233,36984177,37936437,38905165,39882765,40872273,41879701,42892741,43917045,44961429,46012953,47072441,48151745,49238237,50337477,51452861,52576489,53711481,54863673,56023265,57195017,58384493,59579725,60786973,62013625,63245161,64487825,65751673,67022869,68299541,69599537,70907169,72222281,73556741,74899533,76253245,77622873,79004301,80394089,81800229,83215673,84640905,86086149,87538117,89000357,90481213,91968573,93465893,94986717,96510133,98044789,99602257,101164589,102730405,104323349,105923069,107527525,109156853,110791985,112436385,114098289,115770985,117447841,119153485,120858545,122575321,124312845,126052101,127807069,129583001,131363853,133152609,134964669,136780633,138604121,140451529,142307625,144169445,146051213,147940213,149838937,151758541,153684369,155619897,157578237,159541385,161512033,163504685,165503029,167509237,169542389,171576593,173618917,175688109,177762137,179837421,181943569,184053181,186171825,188309093,190451393,192606261,194779993,196964693,199153397,201367153,203582769,205810457,208059605,210315541,212574505,214861705,217154097,219447925,221773161,224102741,226434021,228791197,231159549,233531601,235927845,238326629,240734481,243164793,245601193,248047789,250517237,252989765,255473725,257978013,260483089,263004285,265546889,268086105,270639765,273222545,275805973,278392553,281010653,283630605,286255137,288907945,291564745,294225877,296910549,299605145,302304129,305029725,307756501,310491817,313255897,316015945,318787977,321590101,324394157,327194513,330034269,332873789,335711933,338584217,341458273,344343717,347251925,350159481,353079793,356021061,358967045,361921445,364901969,367885425,370880737,373897845,376910929,379940181,382995665,386055309,389110373,392206165,395299273,398391929,401524577,404653709,407786945,410952677,414120533,417289737,420488201,423696333,426901685,430141733,433377645,436623209,439896933,443171701,446449545,449767849,453081233,456391257,459741477,463086461,466437181,469822225,473208953,476599361,480022389,483440145,486873505,490321197,493781125,497244149,500737125,504228721,507727857,511263557,514786121,518324717,521893621,525460593,529028253,532642613,536241905,539842305,543485021,547127549,550772541,554443253,558125821,561808533,565516341,569231337,572950921,576693973,580445165,584202277,587985733,591771409,595559293,599389757,603206953,607034173,610894977,614760053,618616473,622504769,626405093,630308449,634239241,638166297,642109201,646069133,650039933,654011821,658022165,662027749,666027101,670079321,674109573,678157809,682240761,686321033,690394405,694516565,698633321,702744381,706895101,711045345,715200253,719386557,723579333,727765865,731987473,736213877,740446169,744707877,748967125,753230425,757526949,761813457,766115125,770458401,774787813,779119569,783497493,787865857,792235977,796644833,801049253,805460221,809901061,814343545,818793589,823275605,827750801,832231421,836755009,841265357,845778421,850344121,854881013,859442429,864035277,868621377,873208689,877839905,882465365,887090701,891754293,896416797,901080393,905771009,910479497,915176809,919908725,924645929,929382217,934156169,938923801,943706245,948510873,953308877,958118121,962974753,967816633,972659433};

inline void File()
{
    #ifdef Mr_Chen
        freopen("Luogu.in","r",stdin);
        freopen("Luogu.out","w",stdout);
    #endif
}

inline int read()
{
    re int res=0;re bool f=1;
    re char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-') f=0;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        res=(res<<3)+(res<<1)+(ch&15);
        ch=getchar();
    }
    return f?res:-res;
}

int gcd(const int &x,const int &y)
{
    return y==0?x:gcd(y,x%y);
}

int main()
{
    File();
    n=read();
    if(n==1||n==0)
    {
        puts("0");
        return 0;
    }
    cnt=ans[n/100];//找到n对应的ans值
    for(re int i=100*(int)(n/100);i<n;++i)
    //这里枚举注意是从100*(int)(n/100)开始的
        for(re int j=1;j<=i;++j)
            if(gcd(i,j)==1) cnt+=(i==j)?1:2;
   	//只要gcd(i,j)为1，就说明有一个答案，如果i!=j,就说明gcd(j,i)也可以加一
    printf("%d\n",cnt);
    return 0;
}

```

~~希望管理员不要加强数据~~

---

## 作者：地表最强男人 (赞：1)

- 我们可以将左下角的坐标看成是$(0,0)$，然后将这张图上所有的点与$(0,0)$连成一条直线，如果这个点的坐标是$(x,y)$，那么直线的表达式就是$y=ax$，$a=\frac{y}{x}$，众所周知$a$就是斜率，如果有两条直线的$a$是一样的，那么这两个点就不能被看见。所以如果有一个点是$(x,y)$，另一个点是$(kx,ky)$的话，那么这个点$(kx,ky)$是看不到的。而所有的$(x,y)$可以表示成$(gcd(x,y)*a,gcd(x,y)*b)$，如果这个$gcd(x,y)=1$，即$k=1$，才不会被前面的点覆盖掉。可以枚举横坐标x,找到$1-x$中所有的与$x$互质的$y$，这样的点是可以记录进答案的。如何快速的找到$1-x$中所有与$x$互质的$y$的个数呢？
- 这里引入一个东西叫欧拉函数，这个函数是用来求$1-x$中与$x$互质的数的个数的。如果将一个$x$分解质因数,$x$的因子有$c1,c2,c3$，那么$c1$,$c1*2$,$c1*3......$,$c2$,$c2*2......$，即所有的质因子在$x$以内的倍数都不与$x$互质。那么与$x$互质的数不就是剩下的个数了吗？先考虑$x$的两个质因子$p,q$，那么$1-x$中与$x$互质的个数需要被排除$x-\frac{x}{p}-\frac{x}{q}+\frac{x}{pq}$，因为$p,q$的公倍数被删去了两次，所以需要加回来。这个式子可以变成$x*(1-\frac{1}{p}-\frac{1}{q}+\frac{1}{pq})=x(1-\frac{1}{p})(1-\frac{1}{q})$，这也是容斥原理的应用，而如果用归纳法对$x$的所有的质因子都按照这个法则使用容斥原理，那么答案就是所有的质因子$q$，将原数$x$乘上$(1-\frac{1}{q})$。
- 最后乘2再加上特殊的3个点。$(0,1),(1,0),(1,1)$
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
#define re register
using namespace std;
int n,ans;
int phi(int x)
{
        int anss=x;
        for(int i=2;i<=sqrt(x);i++)
            if(x%i==0)
            {
                anss=anss/i*(i-1);
                while(x%i==0)
                    x=x/i;
            }
        if(x>1)
            anss=anss/x*(x-1);
        return anss;
}
int main()
{
        cin>>n;
        if(n==1)
        {
            cout<<0;
            return 0;
        }
        n--;
        for(re int i=2;i<=n;i++)
            ans+=phi(i);
        ans=ans*2+3;
        cout<<ans;
        return 0;
}
```


---

## 作者：jins3599 (赞：1)

欧拉函数模板题..

我们首先考虑一下暴力。

显然的一个性质，所有的点中，$gcd(x,y)=1$的点一定可以被看到，否则它会被前面的点阻挡。

因此$O(n^2)$枚举每个点判断是否互质即可。

复杂度$O(n^2logn)$

我们考虑一下优化。

我们对每一列进行考虑，把整个队列看成第一象限的点集的话，我们可以用直线$y=x$把他分成两个部分，并且两个部分是对称的。

两两互质？求一个数下面所有和他互质的数？——欧拉函数。

于是思路就出来了，我们从$2$到$n-1$（因为钦定了站的点是$0$）枚举$x$轴上的每一个点，用$ans$累加每个点的$\phi(x)$，最后对称过去，再加上最开始的三个点，答案就是：$ans*2+3$。

记得特判一下$n=1$的情况，因为根据我们的算法会输出$3$，实际输出$0$.

时间复杂度$O(n)$（其实是$O(loglog(n)...$懒得写欧拉筛了。）

$Code:$

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N =  40000 + 5;
int n , phi[N + 5];

void Euler () {
    for(int i = 1 ; i <= N ; ++ i) phi[i] = i;
    for(int i = 2 ; i <= N ; ++ i) {
        if(phi[i] == i) {
            phi[i] --;
            for(int j = i + i ; j <= N ; j += i) {
                phi[j] = phi[j] / i * (i - 1);
            }
        }
    }
}


int main () {
	Euler();
//	for(int i = 2 ; i <= 5 ; ++ i) printf("phi[%d] = %d\n" , i , phi[i]);
	scanf("%d" , &n);
	if(n == 1) {
		puts("0"); return 0;
	}
	int ans = 0;
	for(int i = 2 ; i <= n - 1; ++ i) ans += phi[i];
	ans *= 2;
	ans += 3;
	printf("%d\n" , ans);
	return 0;
}
```

---

## 作者：k，火魂 (赞：1)

这是一道欧拉函数的题，因为对于（x，y）的人，只有当gcd(x,y)==1时才会被看见，因此我们就是需要考虑对任意y，多少x与与y的gcd==1，就是求y的欧拉函数
nlogn做法
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=5e4;
int phi[N];
int n,ans;

int main()
{
	scanf("%d",&n);
	if(n==1){
		cout<<"0"<<endl;
		return 0;
	}
	for(int i=2;i<=n;i++)phi[i]=i;
	for(int i=2;i<=n;i++){
		if(phi[i]==i)
		for(int j=i;j<=n;j+=i){
			phi[j]=phi[j]/i*(i-1);
		}
	}
	for(int i=2;i<n;i++){
//		if(phi[i]==i)ans+=i-1;
		ans+=phi[i];
	}
	ans*=2;
	printf("%d",ans+3);
	return 0;
}
```
根据题意，行与列都是从零开始的


|3,0 | 3,1 | 3,2 |3,3  |
| :----------- | :----------- | :----------- | :----------- |
| 2,0 |2,1  | 2,2 |2,3  |
|1,0|1,1  |1,2  |1,3  |
|0,0|0,1|0,2|0,3|
所以共有n-1行。


o(n)算法

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=5e4;
int phi[N],prime[N];
int v[N];
int n,ans,m;

int main()
{
	scanf("%d",&n);
	if(n==1){
		cout<<"0"<<endl;
		return 0;
	}
	for(int i=2;i<=n;i++){
		if(!v[i]){
			v[i]=i;
			prime[++m]=i;
			phi[i]=i-1;
		}
		for(int j=1;j<=m;j++){
			if(v[i]<prime[j]||prime[j]*i>n)break;
			v[i*prime[j]]=prime[j];
			phi[i*prime[j]]=phi[i]*(i%prime[j]?prime[j]-1:prime[j]);
		}
	}
	for(int i=2;i<n;i++)ans+=phi[i];
	ans*=2;
	printf("%d",ans+3);
	return 0;
}
```




---

## 作者：xiaosongliu (赞：1)

欧拉公式：
在数论中，对于正整数N,少于或等于N ([1,N]),且与N互质的正整数(包括1)的个数，记作φ(n)。
φ函数的值：φ(x)=x(1-1/p(1))(1-1/p(2))(1-1/p(3))(1-1/p(4))…..(1-1/p(n)) 其中p(1),p(2)…p(n)为x的所有质因数;x是正整数; φ(1)=1(唯一和1互质的数，且小于等于1)。注意：每种质因数只有一个。

```python
def euler_totient(x):
    s, i = x, 2
    while i * i <= x:
        if x % i == 0:
            s = s * (i - 1) // i
            while x % i == 0:
                x //= i
        i += 1
    if x != 1:
        s = s * (x - 1) // x
    return s


n, ans = int(input()), 0
if n == 1:
    print(0)
else:
    for i in range(2, n):
        ans += 2 * euler_totient(i)
    print(ans + 3)
```

---

## 作者：origin_star (赞：1)

第一次看到这一题时，觉得是一道数论题，就手推了一下。

0是看不到，1是看得到。
```cpp
n=1
0

n=2
11
01

n=3
010
111
010

n=4
0110
0101
1111
0100

n=5
01010
01101
01010
11111
01000
……
```

有没有发现什么？

~~（没有）~~

```cpp
4 0 1 0 1 0
3 0 1 1 0 1
2 0 1 0 1 0
1 1 1 1 1 1
0 0 1 0 0 0
  0 1 2 3 4
```

如果我们将它标号，会发现所有除第0行或第0列以外，所有能被看到的同学的坐标是互质的，即：
```cpp
点P(x,y)能被看到
则有(x,y)=1
```

所以就有了下面的暴力做法

```cpp
for(int i=1;i<n;++i){
	for(int j=1;j<n;++j){
    	if(gcd(i,j)==1) ++ans;
    }
}
ans+=2;
```

提交，T了,36分。

又得改进~~这究竟是人性的扭曲，还是道德的沦丧？~~

所以，根据坐标互质这个特点，我们就有了应用欧拉函数的思路

函数内容：（引用自百度百科）

对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目

我们就可以利用欧拉函数，在O(n)的时间内完成求解

因此，我们只需要求出从1~n的欧拉函数值，就能A掉题目

最终代码：
```cpp
#include<cstdio>
using namespace std;
const int N=40001;
bool prime[N];
int m[N],phi[N],p[N],nump,n,ans;
void make()
{
    phi[1]=1;
    for (int i=2;i<=n;i++)
	{
        if (!m[i])
        {
            p[++nump]=i;
            phi[i]=i-1;
        }
        for (int j=1;j<=nump&&p[j]*i<n;j++)
        {
            m[p[j]*i]=1;
            if (i%p[j]==0)
            {
                phi[p[j]*i]=phi[i]*p[j];
                break;
            }
            else phi[p[j]*i]=phi[i]*(p[j]-1);
        }
    }
}
int main()
{
	scanf("%d",&n);
	if(n==1){
		printf("0");
		return 0;
	}
	make();
	for(int i=2;i<n;++i){
		ans+=phi[i];
	}
	ans*=2;
	ans+=3;
	printf("%d",ans);
	return 0;
}
```

注意：这里在写的时候使用的是欧拉筛法。如果使用O(n^2)的普通筛法就有可能会TLE

---

## 作者：DennyQi (赞：1)

# 莫比乌斯反演

看到诸位大神都用的是欧拉函数，蒟蒻欧拉函数不是很熟，于是用莫比乌斯反演水过此题……

很容易发现相同的斜率只能有一个。这也就意味着能被看到的$\dfrac{y}{x}$不可约分，如果能被约分那么就对应着另外一个离左下角更近的节点

于是我们要找所有的整数对，满足$gcd(i,j)==1$。于是设

$f(n)$表示$gcd$为$n$的整数对个数，$F(n)$表示$n|gcd$的整数对个数。于是很容易得到$$F(n)=\sum\limits_{n|d}f(d)$$于是可以利用公式二进行反演得$$f(n)=\sum\limits_{n|d}μ(\dfrac{d}{n})F(d)$$很容易发现$$F(d)=\left \lfloor \dfrac{N}{d} \right \rfloor^{2}$$于是就可以直接求$f(1)$作为答案了。（而且并不需要整除分块，$N=40000$的范围$O(n)$就可以了）

还有一个问题，那就是我们的斜率算法是把$(0,0)$当成原点的？那么只需要算出右上角的答案（$(N-1)$的那个），然后加上上面的和右边的就是答案了

注意特判1……

```cpp
/*By DennyQi 2018*/
#include <cstdio>
#include <queue>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long ll;
const int MAXN = 400010;
const int INF = 1061109567;
inline int Max(const int a, const int b){ return (a > b) ? a : b; }
inline int Min(const int a, const int b){ return (a < b) ? a : b; }
inline int read(){
    int x = 0; int w = 1; register char c = getchar();
    for(; c ^ '-' && (c < '0' || c > '9'); c = getchar());
    if(c == '-') w = -1, c = getchar();
    for(; c >= '0' && c <= '9'; c = getchar()) x = (x<<3) + (x<<1) + c - '0'; return x * w;
}
int N,ans;
int mu[MAXN],prime[MAXN],b[MAXN],tot;
inline void getMobius(){
	mu[1] = 1;
	for(int i = 2; i <= N; ++i){
		if(!b[i]){
			prime[++tot] = i;
			mu[i] = -1;
		}
		for(int j = 1; j <= tot; ++j){
			if(i * prime[j] > N) break;
			b[i * prime[j]] = 1;
			if(i % prime[j] == 0){
				mu[i * prime[j]] = 0;
				break;
			}
			mu[i * prime[j]] = -mu[i];
		}
	}
}
int main(){
	N = read()-1;
	if(N <= 0){
		printf("0");
		return 0;
	}
	getMobius();
	for(int i = 1; i <= N; ++i){
		ans += mu[i] * (N/i) * (N/i);
	}
	printf("%d", ans+2);
	return 0;
}
```

---

## 作者：LengChu (赞：1)

## 解题方法：欧拉函数前缀和
#### 易知：若两个点斜率相同，则只能看到一个点，即能看到的点一定满足gcd（x,y）==1，即xy互质。
#### 以观察者为原点建立平面直角坐标系，单独考虑y轴和x轴上的点，(1,0)(0,1)可以看到，ans=2。
#### 考虑不包含原点，x轴，y轴的正方形，暴力方法为枚举每个点判断gcd（x,y）是否为1，为1则累计答案，但效率过低。
#### 把正方形划分成以对角线为斜边的两个等腰直角三角形，枚举每一行，可以发现每个三角形中，xy互质的点为行数的欧拉函数（小于该数的与该数互质的数的个数）。
#### 所以求出从2~n-1（因为不包含x轴y轴且1的欧拉函数没有实际意义）的欧拉函数的和sum，因为有两个直角三角形，于是ans+=sum*2，考虑（1,1）这个点，ans++；
#### 所以最后答案为3+sum*2。

### 用到的公式：①当n是质数时，φ(n)=n-1。②若p是一个质数，如果i%p==0，那么φ(i*p)=p*φ(i)；如果!=0，φ(i*p)=(p-1)*φ(i).
### 然后用线性筛素数的方法求出欧拉函数。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,ans;
int a[50010];
int zs[50010],cnt;
bool book[50010];
int main()
{
	scanf("%d",&n); 
	if(n==1)
	{
		printf("0");
		return 0;
	}
	for(int i=2;i<=n;i++)
	{
		if(!book[i]) 
		{
			zs[++cnt]=i;
			a[i]=i-1;
		}
		for(int j=1;j<=cnt&&zs[j]*i<=n;j++)
		{
			book[zs[j]*i]=1;
			if(i%zs[j]==0) 
			{
				a[i*zs[j]]=zs[j]*a[i];
				break;
			}
			else a[i*zs[j]]=(zs[j]-1)*a[i];
		}
	}
	for(int i=2;i<=n-1;i++) ans+=a[i];
	printf("%d",ans*2+3);
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

```
第一次居然写了个大暴力（Point类和gcd判断），[O(n^2 * (logN)^N)]吧,不过可以用来对拍嘻嘻

发现居然没有莫比乌斯的代码（楼下应该有大佬提过这个解法，但是好像没给代码）

在经过大佬的一番提示后，终于发现此题最xxx方法是：莫比乌斯反演

题意简化之后就是求gcd(i,j) = 1的个数

其实我觉得这都可以算作莫比乌斯反演的一大应用（求∑i =1 n-1∑j=1 j-1 gcd(i,j) = k的个数）的模板了。而且不需要用类似分块的公共乘积优化。(这是玄学)

具体的推导过程可见[https://www.luogu.org/blog/Cinema/mobius-inversion-formula](我的博客中转载的大佬的推法)

在这里我就只给结论了

设f(k)为gcd(i,j) = k的个数，由反演可得

f(k) = ∑x=1 ⌊n/k⌋  μ(x) * ⌊n/kx⌋ * ⌊n/kx⌋
μ(x)为莫比乌斯函数，具体可看上面的链接
不会放数学公式呀，，，

于是我们可以用线筛预处理μ(x)
然后开始咱的反演
时间复杂度O(n + n) [= O(n)吧];

代码如下：

#include<cstdio>
#include<algorithm>

using namespace std;

const int L = 66666;
int mu[L] = {},primes[L] = {};
bool isPrime[L] = {};
int n,num;

//线筛预处理莫比乌斯函数
void sieve(){
    fill(isPrime,isPrime + L,true);
    
    mu[1] = 1;
    num = 0;
    
    for(int i = 2;i < L;++i){
        if(isPrime[i]){
            primes[num++] = i;
            mu[i] = -1;
        }
        static int d;
        for(int j = 0;j < num && (d = i * primes[j]) < L;++j){
            isPrime[d] = false;
            if(i % primes[j] == 0){
                mu[d] = 0;
                break;
            }else{
                mu[d] = -mu[i];
            }
        }
    }
}

int f(int n,int k){
    int ans = 2;
    
    if(n == 1){
        return 0;
    }
    
    for(int x = 1;x < n;x++){
        ans += mu[x] * ((n - 1) / (k * x)) * ((n -1) / (k * x));
    }
    
    return ans;
}

int main(){
    scanf("%d",&n);
    
    sieve();//记得调用
    
    printf("%d",f(n,1));
    
    return 0;
}
```

---

## 作者：01190220csl (赞：1)

先举个例子，如n=10。

去掉最下面一行和最左面一行，留下一个9\*9的矩阵。

用ct[i]表示有序实数对(m,n)(1<=m<=i,1<=n<=i,gcd(m,n)=1)的数量。

n=10时，就是要求ct[9]+2的值。

该问题即求ct[n-1]+2的值。（n=1时答案为0，特判）。

常规做法：穷举m,n，计算gcd(m,n)，时间复杂度O(n^2)，n>=10000时超时。

我的做法：从总数量中挖掉gcd(m,n)!=1的，分类：

1. gcd(m,n)=2：设两个数为2a,2b，有1<=a<=4,1<=b<=4,gcd(a,b)=1，故这一类的数量是ct[4]。

1. gcd(m,n)=3：设两个数为3a,3b，有1<=a<=3,1<=b<=3,gcd(a,b)=1，故这一类的数量是ct[3]。

...
1. gcd(m,n)=x：设两个数为xa,xb，有1<=a<=n/x,1<=b<=n/x,gcd(a,b)=1，故这一类的数量是ct[n/x]。

...
1. gcd(m,n)=9：设两个数为9a,9b，有1<=a<=1,1<=b<=1,gcd(a,b)=1，故这一类的数量是ct[1]。


故ct[9]=9\*9-ct[9/2]-ct[9/3]-...-ct[9/9]。

同理有ct[x]=x\*x-ct[x/2]-ct[x/3]-...-ct[x/x]。

用递归求解加记忆化搜索即可。时间复杂度$O(n\sqrt n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int ct[40000];
int countup( int n )
{
    if( ct[n] >= 0 )
        return ct[n];
    ct[n] = n * n;
    for( int i = 2 ; i <= n ; i++ )
        ct[n] -= countup( n / i );
    return ct[n];
}
int main()
{
    int n;
    cin >> n;
    for( int i = 0 ; i < n ; i++ )
        ct[i] = -1;
    if( n == 1 )
    {
        cout << 0;
        return 0;
    }
    cout << countup( n - 1 ) + 2;
}
```

---

## 作者：ylsoi (赞：1)

典型的一道欧拉函数的题目，对于每一层，我们能否看到的人数就是与它的层数-1互质的数的个数，便是欧拉函数，但是还要考虑连线时斜率为0，1，正无穷的情况，所以对于最后的答案还要加上一个三，关于怎样求欧拉函数，我们可以通欧拉筛法筛素数的同时利用欧拉函数的递推公式来实现，最后累加即可，上代码

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
const int maxn=40000+10;
int n,phi[maxn],prime[maxn],len,ans;//phi是欧拉函数，prime是素数表
bool vis[maxn];//布尔型判断是否是质数
int main(){
    scanf("%d",&n);
    if(n==1){
        printf("%d\n",0);
        return 0;
    } 
    for(int i=2;i<=n;i++){
        if(!vis[i]){
            prime[++len]=i;//如果是素数的话，它的欧拉函数就等于他自己-1
            phi[i]=i-1;
        }
        for(int j=1;j<=len;j++){
            if(prime[j]*i>n)break;
            vis[prime[j]*i]=1;    
            if(i%prime[j]!=0)
                phi[i*prime[j]]=phi[i]*(prime[j]-1);//下面是不是素数的情况下分两种情况讨论的递推公式
            else{
                phi[i*prime[j]]=phi[i]*prime[j];
                break;
            }
        }
    }
    for(int i=2;i<=n-1;i++)
        ans+=phi[i];//最后再统计输出就可以了
    printf("%d\n",ans*2+3);
    return 0;
}
```

---

## 作者：Celtic (赞：0)

显然$(i,j)$当$gcd(i,j)$不为1时一定会被$(i/gcd(i,j),j/gcd(i,j))$挡住

所以原问题等价于求
$2+\displaystyle \sum^{n}_{i=1}$
$\displaystyle \sum^{n}_{j=1}[gcd(i,j)==1]$

- 2是常数，忽略

- 考虑求
$F(n)=\displaystyle \sum^{n}_{i=1}$
$\displaystyle \sum^{i}_{j=1}[gcd(i,j)==1]$

- 它等于$\displaystyle \sum^{n}_{i=1}\phi(i)$，可以线性筛

- 答案和他什么关系呢

- 发现
$\displaystyle \sum^{n}_{i=1}$
$\displaystyle \sum^{n}_{j=1}[gcd(i,j)==1]=2*F(n)-1$，除了$\phi(1)$算了两遍，其他都对称


- 那么答案就是
$2*F(n)+1$

 温馨提示：要特判！！！


------------
代码
```cpp
#pragma GCC optimize(2)
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<vector>
#include<queue>
#include<stack>
#include<cmath>
#define re register
using namespace std;
typedef long long ll;
typedef double db;
const ll N=2001001;
const ll MAX=2001;
const ll inf=1e18;
inline void read(re ll &ret)
{
	ret=0;re bool pd=0;re char c=getchar();
	while(!isdigit(c)){pd|=c=='-';c=getchar();}
	while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();}
	ret=pd?-ret:ret;
	return;
}
ll n,phi[N];
bool prime[N];
ll p[N],tot,sum[N];
inline void init()
{
	for(re int i=2;i<=n;i++)
		prime[i]=true;
	phi[1]=1;
	sum[1]=1;
	for(re int i=2;i<=n;i++)
	{
		if(prime[i])p[++tot]=i,phi[i]=i-1;
		for(re int j=1;j<=tot&&p[j]*i<=n;j++)
		{
			prime[p[j]*i]=false;
			if(i%p[j]==0)
			{
				phi[i*p[j]]=phi[i]*p[j];
				break;
			}
			else
				phi[i*p[j]]=phi[i]*(p[j]-1);
		}
		sum[i]=sum[i-1]+phi[i];
	}
	return;
}
signed main()
{
	read(n);
	n--;
	if(!n)
	{
		putchar('0');
		exit(0);
	}
	init();
	printf("%lld\n",1+(sum[n]<<1));
    exit(0);
}



```


---

## 作者：wxsh2001 (赞：0)

写一个较为严谨~~（瞎编乱造）~~的题解
为了方便，记n的欧拉函数为fai(n)
以C君为原点建立坐标系
所求即为(i,j)且(i,j)=1,0<i<n,0<j<n 的个数
i=j只有(1,1)一组
i=0或j=0有两组
其余的可不妨设i<j，再把答案翻倍即可
固定j，则i的取法有fai(i)种
于是，本题就是求fai(1)加到fai(n)
下面介绍欧拉函数的求法

------------
fai(1)=1
对于正整数n>=2 有
1、若n为质数 则fai(n)=2
2、若n被质数p整除，且n不被p^2整除
	则fai(n)=(p-1)×fai(n/p)
3、若n被质数p的平方整除
	则fai(n)=p×fai(n/p)

以上三点都可以用欧拉函数的公式轻松证明
而寻找n的一个素因子并判断n是否为素数是非常容易的
只需将i从2到n遍历即可
大致是这样
```cpp
	fai[1]=1;
	for(i=2;i<n;i++)
	{
	    is_prime=1;
	    for(j=2;j<=sqrt(i);j++)
	    {
	        if(i%j==0)
	        {
	            is_prime=0;
	            if((i/j)%j==0)
	            fai[i]=j*fai[i/j];
	            else
	            fai[i]=(j-1)*fai[i/j];
	            break;
	        }
	    }
	    if(is_prime)
	    fai[i]=i-1;
	}
```


------------
接下来求和即可
注意最后计算出的结果s和答案的关系（是s的二倍差1还是正好？）
其实代入样例即可凑出答案
不过，本题还有一个坑，就是n=1时的情况，要单独讨论


------------
最后估计一下复杂度（主要在计算欧拉函数上）
对于任意一个质数p
它的最小素因子期望值为ln(n)
所以复杂度为nln(n)
（这个证明比较复杂）

附上代码：（写的很繁杂）
```cpp
#include <stdio.h>
#include <math.h>
int fai[40050]={0};

int main() {
	int n;
	int i,j,s=0;
	int is_prime=1;
	scanf("%d",&n);
	if(n==1)
	{
	    printf("0");
	    return 0;
	}
	fai[1]=1;
	for(i=2;i<n;i++)
	{
	    is_prime=1;
	    for(j=2;j<=sqrt(i);j++)
	    {
	        if(i%j==0)
	        {
	            is_prime=0;
	            if((i/j)%j==0)
	            fai[i]=j*fai[i/j];
	            else
	            fai[i]=(j-1)*fai[i/j];
	            break;
	        }
	    }
	    if(is_prime)
	    fai[i]=i-1;
	}
	for(i=1;i<n;i++)
	s+=fai[i];
	printf("%d",2*s+1);
	return 0;
}
```


---


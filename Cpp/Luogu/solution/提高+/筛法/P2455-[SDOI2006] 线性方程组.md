# [SDOI2006] 线性方程组

## 题目描述

已知 $n$ 元线性一次方程组。

$$ \begin{cases} a_{1, 1} x_1 + a_{1, 2} x_2 + \cdots + a_{1, n} x_n = b_1 \\ a_{2, 1} x_1 + a_{2, 2} x_2 + \cdots + a_{2, n} x_n = b_2 \\ \cdots \\ a_{n,1} x_1 + a_{n, 2} x_2 + \cdots + a_{n, n} x_n = b_n \end{cases}$$

请根据输入的数据，编程输出方程组的解的情况。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1 \le n \le 50$。对于 $\forall 1\le i, j \le n$，有 $|a_{i, j}| \le 100$，$|b_i| \le 300$。

## 样例 #1

### 输入

```
3
2 -1 1 1
4 1 -1 5
1 1 1 0```

### 输出

```
x1=1.00
x2=0.00
x3=-1.00
```

# 题解

## 作者：Piwry (赞：96)

作为刚刚刷完模板题想来练练手的蒟蒻，还没摆脱模板题top1题解的影响，于是就想拿  _高斯-约旦消元法_  来过这道题。

然而当我读完题后，才发现 _高斯-约旦消元法_  那美妙的"\\"字形在这题并不能体现，于是~~菜的不行的~~窝就去翻题解...

遗憾的是，当时我只找到了一篇来自~~小~~**诗乃**的[**题解**](https://www.luogu.com.cn/blog/asadashino/solution-p2455)，可这篇题解的代码也有很多**冗余的计算**。

最后，我就只好自力更生了

---
- 我们先来回顾一下用于消元的工具 **增广矩阵** ；以及它的两种变换：交换行，对两行数字做加减。这两种变换后得到的矩阵从求解方程的意义上**是没有变化的**

- 现在再来回顾  _高斯-约旦消元法_  （**假设有唯一解**）的步骤：

1. 以列遍历，从一侧到另一侧；为了方便操作，通常从上至下遍历行，将操作行转移至当前行
2. 先从当前操作行及尚未操作的行找到一个主元（通常取当前列系数最大的，可以证明这样精度误差最小（~~虽然我不会证~~ 简略解释可见文章结尾）），再从除该行的所有行里消去这个元
3. 重复 `2.`，直至遍历完毕

如果你手推过或仔细观察过它的过程，你会发现这个算法**有两点重要的性质**（为了描述方便，以下均默认用上文描述为“_通常_”的操作方式）：

- 每次消元完后，当前列只有当前行不为 $0$
- 当前列左边的数均为 $0$

---
现在我们回到这道题；因为有唯一解的情况可以直接用裸的  _高斯-约旦消元法_  做出，显然其难点就在于**无解**和**无穷解**的判定

而无解和无穷解情况的**不同**就在于，做到某一行你会找不到主元（即当前及下面的行的该列**均为** $0$）

假设当我们**第一次**遇到找不到主元的情况时

我们可以发现：

- 当前列左边的数仍均为 $0$
- 当前操作列及其下面的数均为 $0$

于是便想到**转而处理下一列，操作行不变**，以**维持**这样的性质

---

现在我们对所有找不到主元的情况**都**按上述方法进行处理，当我们遍历完了所有列，当前矩阵也仍满足性质：

- 每次操作列左边的数均为 $0$
- 每次操作列从那次操作行下面一行开始全为 $0$

于是发现它就是一个“**坡度不一”的“倒三角**”（不考虑等式右边常数项），对于**未操作的行**（即“三角”下面的行），**其中的系数全为 $0$！**

这样的“**倒三角**”中可以确定最下面的一个未知数（或可能已经给出解），**往上一一带回一定可以求解**；
\
也就是说**只要判定下面未操作行是否会导出矛盾**就可以对整个方程组做出判定了！

那么就好办了，反正**系数全为** $0$，常数项只要都为 $0$ 就是**无穷解**，否则就是**无解**

（至于**不**存在找不到主元的情况，直接按通常的 _高斯-约旦消元法_ 做就可以了，一定是**存在唯一解**的）

---
$\color{#ffb464}\texttt{顺便推下我的}$[$\color{#32dddd}\texttt{博客}$](https://www.luogu.com.cn/blog/105254/)

---
### 参考代码
```cpp
#include <cstdio>
#include <cmath>
#include <iostream>
using namespace std;

double A[50][51];
int N;

double Abs(double x){
	if(x < 0) return -x;
	else return x;
}

bool eq(double x, double y){// 因为存在微小的精度误差，两数的相差值在一定范围内即可视为相等 
	return (Abs(x-y) < 1e-9);
}

int main(){
	scanf("%d", &N);
	for(int i =0; i < N; ++i) for(int j =0; j < N+1; ++j)
		scanf("%lf", &A[i][j]);
	int nwline =0;
	// k 指主元序号（列）
	for(int k =0; k < N; ++k){// 需要考虑无穷解，循环到N 
		int maxi =nwline;
		for(int i =nwline+1; i < N; ++i)
			if(Abs(A[i][k]) > Abs(A[maxi][k])) maxi =i;
		if(eq(A[maxi][k], 0))
			continue;
		for(int j =0; j < N+1; ++j)
			swap(A[nwline][j], A[maxi][j]);
		for(int i =0; i < N; ++i){
			if(i == nwline)
				continue;
			double mul =A[i][k]/A[nwline][k];
			for(int j =k; j < N+1; ++j)
				A[i][j] -=A[nwline][j]*mul;
		}
		++nwline;
	}
	if(nwline < N){// 存在找不到主元的情况
		while(nwline < N)
			if(!eq(A[nwline++][N], 0))
				return puts("-1") && 0;
		putchar('0');
	}
	else
		for(int i =0; i < N; ++i)
			printf("x%d=%.2lf\n", i+1, A[i][N]/A[i][i]);
}
```

### upd at 20240227_0113

诈尸修了下判断浮点数相等处的万年老锅（具体见代码中 `eq` 函数），以及重新润写了下文章正文；

另外上文提到的：

> 2. 先从当前操作行及尚未操作的行找到一个主元（**通常取当前列系数最大的**，可以证明这样精度误差最小（~~虽然我不会证~~ 简略说明可见文章结尾）），再从除该行的所有行里消去这个元

这里的原理和误差传播有关；简单来说，输入误差相同时，大数字除小数字比起小数字除大数字结果误差更大。于是“取当前列系数最大的”可以有效减少后面代码中 `mul` 变量的精度误差

想更深入了解的读者可以以“误差传播”为关键词在互联网上搜索

---

## 作者：Rui_R (赞：44)

狠题。

题意：在高斯消元的基础上，判断是正常的还是“无解”还是“有无数解”。

简述一下高斯消元的思想：让第 $i$ 个式子对应第 $i$ 元，并用第 $i$ 个式子消去其它式子上的第 $i$ 元，最终使方程组呈现出类似一条对角线的样子，即第 $i$ 个式子只在第 $i$ 元和等式右边有值，其余都是0。

一般的高斯消元每次会选择该项系数绝对值最大的来对应第 $i$ 元。这样，如果发现有一元系数为0，就能说明方程没有正常的解了。

那么我们来研究，没有正常的解，究竟是“无解”还是“有无数解”。

一个naive的想法是，在完成消元后枚举每一项，如果发现系数是0则讨论等式右边：如果为0，则有无数解；如果不为0，则无解。其中**无解优先级更高**，即如果一个方程有一项无解且有一项有无数解，那么判定无解。

交上去喜提90。

存在漏洞：以 hehe_zhou 大佬的hack数据为例：

```
2
0 2 3
0 0 0
```

答案显然是0，但是我们的程序会说这是-1。

我们发现，我们可以根据第一个式子来求出第二元，但是程序会用它来算第一元，并且以后算第二元的时候**不会再考虑该式**，因为我们认为它已经对应第一元了！

也就是说，**我们的答案受到消元顺序影响**。

题解里部分选手当场召唤玄学势力，把消元顺序随机乱改，大概率能出正解。

这里提供一种新的做法。

注意到，我们的症结在于把还有用的式子放到了用不上它的地方，并且以后也不来看它是否可用。

那么，我们就来看它是否可用。

原本的高斯消元中，我们认为只有 $i$ 之后的式子是可用的，因为我们不用管无解还是无数解，系数为0直接判掉。

但这里，我们有可能会在系数为0之后继续做下去。**这就是受到消元顺序影响的原因。**

那么，**可用的就不仅仅是之后的式子，还有之前系数为0的式子。**

于是解决了。

```
#include <cstdio>

const int maxn=55;const double eps=1e-6;

int n;double a[maxn][maxn];

template<typename T> inline void swap(T &a,T &b){
	T temp=a;a=b;b=temp;
}

template<typename T> inline T abs(T val){
	return val>0?val:-val;
}

void Gauss(){//高斯消元
	for(int i=1;i<=n;i++){
		int maxx=i;
		for(int j=1;j<=n;j++){//把枚举范围从i->n改成了1->n
			if(abs(a[j][j])>eps&&j<i) continue;//若在i前，且的确已对应一项系数，不可用
			if(abs(a[j][i])>abs(a[maxx][i])){
				maxx=j;
			}
		}
		for(int j=1;j<=n+1;j++) swap(a[maxx][j],a[i][j]);
		if(abs(a[i][i])<=eps) continue;
		for(int j=1;j<=n;j++){
			if(i==j) continue;
			double delta=a[j][i]/a[i][i];
			for(int k=i;k<=n+1;k++){
				a[j][k]-=delta*a[i][k];
			}
		}
	}
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n+1;j++){
			scanf("%lf",&a[i][j]);
		}
	}
	Gauss();int key=1;
	for(int i=1;i<=n;i++){
		// for(int j=1;j<=n+1;j++) printf("%.2lf ",a[i][j]);
		// printf("\n");
		if(abs(a[i][i])<=eps){
			if(abs(a[i][n+1])>eps) key=-1;//无解优先级更高
			else if(key!=-1) key=0;
		}
	}
	if(key!=1) printf("%d\n",key);
	else for(int i=1;i<=n;i++) printf("x%d=%.2lf\n",i,abs(a[i][n+1]/a[i][i])<=eps?0:a[i][n+1]/a[i][i]);//防止出现-0.00这种令人郁闷的情况，虽然对于本题数据无所谓
	return 0;
}
```

如果hack掉了，请告知这个白痴。

---

## 作者：zqiceberg (赞：24)

#### 通过初等行列变换得到的线性方程组，如果是
1. 完美阶梯型，唯一解
2. 零 = 非零，无解
3. 零 = 零， 无穷多组解

#### 面对一个线性方程组，通过行列变换，依次变换成下面三个状态：

1. 把对角线左下部分的都消掉
2. 把对角线右上部分的都消掉
3. 只剩下对角线上的系数

#### 就可以这样行列变换

1. 把某一行乘一个非零的数
2. 交换某两行
3. 把某行的若干倍加到另一行上去

#### 通过这种方式，把只保留对角线上的系数，且系数是1，就得到了答案
------------


#### 参考代码如下：

```cpp

#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 110;
const double eps = 1e-6;

int n;
double a[N][N];

//debug代码的方式
void out()
{
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++) printf("%10.2lf", a[i][j]);
    }
}

int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c++)
    {
        int t = r;
        for (int i = r; i < n; i++)         //找到当前这一列绝对值最大的这一行
            if (fabs(a[i][c]) > fabs(a[t][c]))  //fabs是double的，abs是整形的
            t = i;

        if (fabs(a[t][c]) < eps) continue;   //小于eps时，认为是0

        for (int i = c; i < n + 1; i++) swap(a[t][i], a[r][i]);  //把这一行交换到第一行上去
        for (int i = n; i >= c; i--) a[r][i] /= a[r][c];         //倒着来，最后更新第一个数，把第一个数变成1

        for (int i = r + 1; i < n; i++)                          //把下面所有行的这列都消成0
            if (fabs(a[i][c]) > eps)                             //已经是0就不用消了
                for (int j = n; j >= c; j--)                     //从后往前消
                    a[i][j] -= a[r][j] * a[i][c];

        //out();

        r++;
    }

    if (r < n)   //r不是n，就不是唯一解
    {
        for (int i = r; i < n; i++)
            if (fabs(a[i][n]) > eps)
                return 2;       //无解， 0 = !0)

        return 1;               //无穷多组解   0 = 0
    }

    for (int i = n - 1; i >= 0; i--)                          //倒着把方程消一遍，把每i行第j列的系数保留1外，都消成0
        for (int j = i + 1; j < n; j++)
            a[i][n] -= a[j][n] * a[i][j];                     //a[j][n], 就是xj的值。a[i][n]，当前这一行的xi的值
                                                              //下面一行已经求出xj的值，只需模拟，当前i行的第n列，-= a[i][j] * xj

    return 0;  //唯一解
}


int main()
{
    cin >> n;
    for (int i= 0; i < n; i++)
        for (int j = 0; j < n + 1; j++)
            cin >> a[i][j];

    int t = gauss();

    if (t == 0)
    {
        for (int i = 0; i < n; i++) printf("%.2f\n", a[i][n]);
    }
    else if (t == 1) puts("0");
    else puts("-1");

    return 0;
}

```

---

## 作者：djwj223 (赞：22)

讲讲神奇的「高斯-约旦消元法」。

不能不说题解区里已经有不少用「高斯-约旦消元法」做的题解了，那么我这次想申请再加一篇题解是否多余呢？

1. 不得不说几篇题解都说的比较模糊，给人的感觉是“修改”算法本身来使这个算法处理无解和无穷解的判定。
2. 大家的说法都是还是对整个矩阵做「高斯-约旦消元法」，于是把最后那些系数全为 0 的行说的很玄学。

觉得说的生硬，没全说在点子上。

下面说我的理解。

我认为这题可以沿用高斯-约旦消元法的思路，但是一大障碍是方程组不一定有唯一解，无法确保一行中是否一定存在主元。

此算法本身是必须要每行选出不同的主元，然后把其他行的这个未知数的系数变为 $0$，最后每行都能化成 $k_{a,c}x_c=y_a$ 的形式。

但是当方程组不一定有唯一解的时候问题来了，当一行所有未当过主元的未知数的系数全为 $0$ 怎么办呢？

首先这个地方如果最后这个方程右侧的值不为 $0$，可以直接返回无解，这个比较显然。

否则我们就不把这一行包括进高斯-约旦消元法要处理的增广矩阵，自然那处理的增广矩阵还得少一列，显而易见的，就是那一列到时候多出来的，一个没有当过主元的未知数的系数。

我们先在这个方程组一定有唯一解的子增广矩阵上做高斯-约旦消元法再说，把那些没当过主元的东西全部移到右边去。

要是左边每个柿子不是 $k_{a,c}x_c(k_{a,c}\ne 0)$ 的形式的话我们或许还会一筹莫展，但是这个形式能帮到我们很多。你发现，不管移到柿子右边的那些未知数取多少都没关系，都可以算出值 $x_c$ 。所以这时候我们只需要输出无穷解就够了。

最后，如果子增广矩阵就是原增广矩阵，那么方程组有唯一解，$O(1)$ 解一下 $k_{a,c}x_c=y_a$ 的柿子，然后所有的 $x$ 就都算出来了。

这样这道题就可以用「高斯-约旦消元法」完美解决了。

---

## 作者：Pecco (赞：8)

由线性代数知识，我们知道，对于$n$元线性方程组$\boldsymbol{AX}=\boldsymbol{\beta}$，它的解的情况为：
- 若$\mathrm R(\boldsymbol A,\boldsymbol \beta)=\mathrm R(\boldsymbol A)=r$，且$r=n$时，原方程有唯一解
- 若$\mathrm R(\boldsymbol A,\boldsymbol \beta)=\mathrm R(\boldsymbol A)=r$，且$r<n$时，原方程有无穷多解
- 若$\mathrm R(\boldsymbol A,\boldsymbol \beta)\not =\mathrm R(\boldsymbol A)$时，原方程无解

然后我们直接模拟即可，用高斯-约旦消元法把增广矩阵化成行最简形矩阵。

我这里写了一个class封装了一下，利用了STL中的`valarray`。另外代码中含有不少C++11+的特性，在NOIP等环境需要把`auto`换成相应的类型。
```cpp
template <typename T>
class mat
{
    int r, c; // 行，列
    bool simplified = false; // 记录是否已化简
    valarray<T> data; // 用valarray存储数据

public:
    mat(int r, int c) : r(r), c(c), data(r * c) {}
    // M(i, j)可取第i行第j列的元素
    T &operator()(int i, int j) { return data[i * c + j]; }
    // M[i]可取第i行的切片
    auto operator[](int i) { return data[slice(i * c, c, 1)]; }
    // M(i)可取第i列的切片
    auto operator()(int i) { return data[slice(i, r, c)]; }
    // 交换两行
    void rswap(int r1, int r2)
    {
        for (int i = 0; i < c; ++i)
            swap((*this)(r1, i), (*this)(r2, i));
    }
    // 接下来是重点，进行行变换，把矩阵变成行最简形矩阵
    mat<T> &simplify()
    {
        int curr = 0; // 当前行
        auto &M = *this;
        for (int i = 0; i < c && curr < r; ++i) // 枚举列
        {
            int maxr = curr; // 找到该列（剩余的）最大元素所在的行
            for (int j = curr + 1; j < r; ++j)
                if (M(j, i) > M(maxr, i))
                    maxr = j;
            if (M(maxr, i) == 0) // 该列剩余元素全为0，跳到下一列
                continue;
            rswap(maxr, curr); // 把最大元素所在行交换到当前行处
            M[curr] /= valarray<T>(M(curr, i), c); // 令最大元素归一
            valarray<T> line = M[curr];
            for (int j = 0; j < r; ++j) // 用当前行对其余行进行消元
                if (j != curr)
                    M[j] -= line * M(j, i);
            curr++;
        }
        simplified = true;
        return *this;
    }
    // 从第L列到第R列（左闭右开）的子矩阵的秩
    int rank(int L, int R)
    {
        // 如果还未化为行最简形矩阵，就复制一下当前矩阵，并化简
        mat &M = (simplified ? *this : mat(*this).simplify());
        int cnt = 0;
        for (int i = 0; i < r; ++i) // 统计非0行
        {
            bool allzero = true;
            for (int j = L; j < R; ++j)
                if (M(i, j) != 0)
                    allzero = false;
            cnt += !allzero;
        }
        return cnt;
    }
    int rank() { return rank(0, c); }
};
```

主函数就不写了，按照上面给出的定理很容易实现。只是有个细节可以注意一下：输出的时候可能会输出`-0.00`，所以可以把要输出的数加上一个很小的实数（如`1e-6`）再输出。

---

## 作者：asmend (赞：7)

讨论区里两个Hack插不掉的方法，欢迎插。

1.高斯消元转化成阶梯矩阵。

2.再反着消元转使每一列只有最多一个非零值。

3.若某一行出现$0,0,...,0,x$的情况则无解。

4.若不为三角矩阵的情况则多解。

```cpp
#include <iostream>
#include <algorithm>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<cstdlib>
#include<vector>
#include<iomanip>
#define sqr(x)(x)*(x)
#define fz1(i,n) for (i=1;i<=n;i++)
#define fd1(i,n) for (i=n;i>=1;i--)
#define fz0g(i,n) for (i=0;i<=n;i++)
#define fd0g(i,n) for (i=n;i>=0;i--)
#define fz0k(i,n) for (i=0;i<n;i++)
#define fd0k(i,n) for (i=(long long)(n-1);i>=0;i--)
#define fz(i,x,y) for (i=x;i<=y;i++)
#define fd(i,y,x) for (i=y;i>=x;i--)
#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)
#define rdst(st,len){char ss[len];scanf("%s",ss);(st)=ss;}
using namespace std;
double xs[55][55],ans[55];
int n,m,i,j,k;
bool f1=0,f2=0;
int main()
{
	scanf("%d",&n);
	fz1(i,n)
	{
		fz1(j,n+1)
		{
			scanf("%lf",&xs[i][j]);
		}
	}
	int c=1;
	fz1(i,n)
	{
		if (c>n) break;
		fz(j,i,n)
		{
			if (abs(xs[j][c])>abs(xs[i][c]))
			{
				fz1(k,n+1) swap(xs[i][k],xs[j][k]);
			}
		}
		if (abs(xs[i][c])<1e-8)
		{
			f2=1;
			c++;
			i--;
			continue;
		}
		fz(j,i+1,n)
		{
			double t=xs[j][c]/xs[i][c];
			fz(k,c,n+1)
			{
				xs[j][k]-=xs[i][k]*t;
			}
		}
		c++;
	}
	c=n; 
	fd1(i,n)
	{
		if (c<1) break;
		if (abs(xs[i][c])<1e-8) continue;
		fz1(j,i-1)
		{
			double t=xs[j][c]/xs[i][c];
			fz(k,c,n+1)
			{
				xs[j][k]-=xs[i][k]*t;
			}
		}
		c--;
		if (abs(xs[i][c])>1e-8) i++;
	}
	fd1(i,n)
	{
		f1=0;
		fz1(j,n) if (abs(xs[i][j])>1e-8)
		{
			f1=1;
		}
		if (f1==0&&abs(xs[i][n+1])>1e-8)
		{
			puts("-1");
			return 0;
		}
		if (abs(xs[i][i])>1e-8) if (!f2) ans[i]=xs[i][n+1]/xs[i][i];
	}
	if (f2==1)
	{
		puts("0");
		return 0;
	}
	fz1(i,n)
	{
		if (abs(ans[i])<5e-3) printf("x%d=0\n",i); else printf("x%d=%.2f\n",i,ans[i]);
	}
	return 0;
}
```

---


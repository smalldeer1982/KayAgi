# 一道水题 II

## 题目描述

一天，szb 在上学的路上遇到了灰太狼。

灰太狼：帮我们做出这道题就放了你。  
szb：什么题？  
灰太狼：求一个能被 $[1,n]$ 内所有数整除的最小数字，并对 $100000007$ 取模。  
szb：这题太水了，就让我小弟来做好了。

然后你就光荣的接受了这个任务。

## 说明/提示

$n \le 10^8$

## 样例 #1

### 输入

```
10```

### 输出

```
2520```

# 题解

## 作者：qwaszx (赞：23)

这范围明摆着分块打表啊...

答案就是$lcm(1,2,\cdots,n)$

考虑$lcm$的意义，对于一个质因子$p$，那么它对答案的贡献是$p^a$，其中$a$是$1$到$n$中每个数最多含质因子$p$的个数.于是可以筛出所有质数然后再求出贡献，这可以简单地求出：

```cpp
long long solve(int p)
{
	long long ans=p;
	while(ans*p<=n)ans=ans*p;
	return ans;
}
```

然后再注意到如果$p>\sqrt{n}$那么它对答案的贡献就是$p$，所以我们可以按1e6分块打表出每一块内素数的积以及块的前缀积(去掉第一块，这一块可能贡献指数不是1).然后对于整块直接查表，非整块区间筛出所有素数.

复杂度$O(1e6)$.

打表程序

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=1e8,mod=1e8+7;
const int blo=1e6;
int w[5000],prime[N],cnt;
bool p[N+5];
void make()
{
	for(int i=1;i<=100;i++)w[i]=1;
	for(int i=2;i<=N;i++)
	{
		int id=(i-1)/blo+1;
		if(!p[i])prime[++cnt]=i,w[id]=1ll*w[id]*i%mod;
		for(int j=1;j<=cnt&&i*prime[j]<=N;j++)
		{
			p[i*prime[j]]=1;
			if(i%prime[j]==0)break;
		}
	}
	w[1]=1;for(int i=3;i<=100;i++)w[i]=1ll*w[i]*w[i-1]%mod;
}
int main()
{
	freopen("data.txt","w",stdout);
	make();
	for(int i=1;i<=100;i++)printf("%d,",w[i]);
}
```

提交程序

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int blo=1e6,N=5e6,mod=1e8+7;
const int W[500]={0,1,4279041,78522927,97275812,6626498,90103459,19755829,89404363,31420837,78259116,79495350,63384896,76365496,77671792,60888616,14364168,69179499,73237343,47511561,98202707,9638787,8923490,19377161,14025453,83914297,99211028,91698985,11861010,41728948,85011248,2957451,96835040,13279739,65389333,35674577,69539515,43558531,90167843,65612508,96727630,84411969,10432978,81144826,76822534,44673268,48780356,42026053,71419640,925833,75468296,56122076,11730540,24214526,57670707,87561236,60795551,16258057,38969193,93135220,99449198,86687779,48716439,54282180,9747238,6014664,88132693,90624798,78394444,54259153,2424434,71634841,6763549,80339105,74090298,10910559,39590831,57807866,78084208,54389248,4052287,74604335,99190428,89368783,73470487,32097770,29222100,30538785,3048397,89311543,48798411,36895907,88691881,24323948,4724247,97882710,84490696,93965490,66087028,92642640,55440368};
int prime[N],p[N],n,cnt;
void make(int n)
{
	for(int i=2;i<=n;i++)
	{
		if(!p[i])prime[++cnt]=i;
		for(int j=1;j<=cnt&&i*prime[j]<=n;j++)
		{
			p[i*prime[j]]=1;
			if(i%prime[j]==0)break;
		}
	}
}
long long solve(int p)
{
	long long ans=p;
	while(ans*p<=n)ans=ans*p;
	return ans;
}
int main()
{
	scanf("%d",&n);
	if(n<=blo)
	{
		make(n);int ans=1;
		for(int i=1;i<=cnt;i++)
			ans=solve(prime[i])*ans%mod;
		printf("%d\n",ans);
	}
	else
	{
		make(blo);int ans=1;
		for(int i=1;i<=cnt;i++)
			ans=solve(prime[i])*ans%mod;
		int id=(n-1)/blo;ans=1ll*ans*W[id]%mod;
		long long L=id*blo+1,R=n;for(int i=0;i<=R-L;i++)p[i]=0;
		for(int i=1;i<=cnt&&prime[i]*prime[i]<=R;i++)//区间筛
		{
			int l=L/prime[i]*prime[i];if(l<L)l+=prime[i];
			while(l<=R)p[l-L]=1,l+=prime[i];
		}
		int tmp=0;
		for(int i=L;i<=R;i++)
			if(!p[i-L])++tmp,ans=1ll*ans*i%mod;
		printf("%d\n",ans);
	}
}
```

比第二快了二十多倍吧(雾

---

## 作者：dottle (赞：22)

# 1.难点
这道题让人很纠结，如果用bitset会T掉，但是不用bitset用bool数组又会很容易地被卡掉空间，为了解决这个问题，很多dalao都选择了用bitset并开O2，但是noip是不可以吸氧的，所以我们只能放弃stl。怎么办呢？我们可以用char存。

为了让大家了解这篇题解的核心思想，我再写一遍
## 用char存 
### char是占4Byte，但是可以存8个0/1位，而bool占1Byte，却只能存1个0/1位。所以用char就可以愉快地解决空间问题啦^_^。

----
# 2.具体操作
char转bool是这个样子的
```
	v[k>>3]+=1<<(k^((k>>3)<<3));//change
	v[i>>3]&1<<(i^((i>>3)<<3)//ask
   
```
完美

---

# 3.代码
```
#include<stdio.h>
#define MAX 100000000
#define MAXZ 6000000
#define mod 100000007
using namespace std;
char v[MAX>>2];
int prime[MAXZ],f[MAXZ];

signed main(){
	register int n;
	register long long ans=1;
	scanf("%d",&n);
	register int m=0;
	for(register int i=2;i<=n;i++){
		if(!(v[i>>3]&1<<(i^((i>>3)<<3)))){ 
			ans=ans*i,prime[++m]=i,f[m]=i;
			if(ans>mod)ans=ans%mod;
		} 
		for(register int j=1;j<=m&&prime[j]*i<=n;j++){
			int k=prime[j]*i;
			v[k>>3]+=1<<(k^((k>>3)<<3));
			if(!(i%prime[j])){
				if(i==f[j]){
					f[j]=f[j]*prime[j],ans=ans*prime[j];
					if(ans>mod)ans=ans%mod;
				}
				break;
			}
		}
	}
	printf("%lld",ans);
}
```
### 撒花
---
# 4.残忍的现实

1.如果不打 if(ans>mod)ans%=mod; 就会T

2.如果将(i>>3)<<3 换成 i%8 就会T

3.如果用动态分配内存 (new) 就会T

4.如果不写 register 就会T


---

## 作者：abc123_abc123 (赞：20)

~~数据范围真友好。~~

这道题就是一道超级~~水题~~难题。

其实是线性筛+标记质数的x次方，并把他们乘起来。

尴尬的是我MLE了3次——bool数组太大了，存不下100000000(10^8)于是我突然想到~~百度搜出~~了一个名叫bitset的东西。这个东西能当bool用且空间只用原来的1/8！

于是奉上本蒟蒻的代码：

```cpp
#include<cstdio>
#include<bitset>
using namespace std;
bitset<99999990> v; //原来的bool v[99999990]会爆空间
int f[5761456]; //10^8内有5761455个质数，同下
int prime[5761456];
int pr,i,j,a;
long long ans;

int main()
{
	scanf("%d",&a);
	ans=1;
    
    //下面奉上线性筛
	for(i=2;i<=a;i++)
	{
		if(!v[i])
		{
			prime[++pr]=i;
			f[pr]=i;//打标记
			ans=ans*prime[pr]%100000007;
		}
		for(j=1;j<=pr&&prime[j]*i<=a;j++)
		{
			v[prime[j]*i]=1;
			if(i%prime[j]==0)
			{
				if(i==f[j])
				{
					f[j]=f[j]*prime[j];//把标记移到下一个位置
					ans=ans*prime[j]%100000007;
				}
				break;
			}
		}
	}
	printf("%lld",ans);
	return 0;
}
```

补充：

其实一眼就能看出来求的是lcm（最小公倍数）。

对于k=lcm(1,2,3,4,……,n)，忽略第一个1，有k=2^p[1]×3^p[2]×5^p[3]×……×prime[pr]^p[pr]，其中p[i]为这个素数的最高次幂。易得 **当p[i]是prime[i]的最大指数时，p[i]为最大值**。

例如：当n为15时，prime[3]等于5，p[3]等于1，1为5的最大指数(5^1<=15,5^2>15)。

所以把k求出来就AC啦！

---

## 作者：qwq自动机 (赞：10)

~~先吐槽一句：题目名字带“水”、“简单”的都不是什么好东西！（生气~~

## Step1. 审题

~~容易~~看出这道题让我们求的是 $\underset{1\leq i\leq n}{\operatorname{lcm}}(i)\mod 100000007$。

还有一个坑点：模数是 $10^8+7$ 而非~~常见~~的 $10^9+7$！~~我就被这个坑过ww~~

## Step2. 思考题目解法
首先我们考虑暴力解法：枚举 $1$ 到 $n$，标记它们的倍数，那么第一个被标记过 $n$ 次的数就是答案。

那么显然这个想法是不可行的。但是这也给了我们一个思路：枚举……标记倍数……这不就是质数筛法吗！然后一看数据范围，$n \leq10^8$，大概率是用线性筛（欧拉筛）~~这就是面向数据编程吗？爱了爱了~~。

那么我们把质数筛出来有什么用？考虑小学学过的求两个数最小公倍数的方法：分解质因数，每个质因数取最大的质数然后求幂相乘，得到的就是最小公倍数。那么我们可以把这个推广到求 $n$ 个数的最小公倍数，即：

$$\underset{1\leq i\leq n}{\operatorname{lcm}}(i)=\prod_{i\in\Pr\land\ i\leq n}i^{\lfloor\log_in\rfloor}$$

其中 $\Pr$ 为质数集。

那么下面就是~~口胡的~~证明：

---
令 $l=$ 上式右边乘积。

首先对于 $\forall i\in\Pr\land\ i\leq n$，令 $k=\lfloor\log_in\rfloor$，易证 $i^k\leq n\lt i^{k+1}$。则 $\forall j\in [1,n]\cap\mathbb{Z}$，$j$ 分解质因数后质数
$i$ 项的指数必定 $\leq k$，故 $j\ |\ l$。即证“公倍”。

其次，若存在一数 $l' \leq l$，则 $l'$ 分解质因数后必存在一个质数的指数小于 $l$ 分解后该质数的指数，设其为 $p$。由于 $1$ 到 $n$ 中存在至少 $1$ 个数使得其分解后 $p$ 的指数 $=\lfloor\log_pn\rfloor$，则该数无法整除 $l'$，故 $l'$ 非 $1$ 到 $n$ 的公倍数之一，即证“最小”。

综上，$l$ 为最小公倍数。

---
那么有了上面的结论，这道题就迎刃而解了。代码如下：
```cpp
#include <iostream>
#include <cstdio>
#include <bitset>
#include <cmath>
using std::bitset;
const int MOD = 100000007;
int n, cnt = 0;
long long ans = 1;
int prime[5762000];
bitset<100000010> isNotPrime;
int qpow(long long base, int pow) // 快速幂
{
    long long ans = 1;
    while (pow)
    {
        if (pow & 1)
            (ans *= base) %= MOD;
        (base *= base) %= MOD;
        pow >>= 1;
    }
    return ans % MOD;
}
int main()
{
    scanf("%d", &n);
    double logn = log(n);
    for (int i = 2; i <= n; i++) // 欧拉筛
    {
        if (!isNotPrime.test(i)) // 筛到质数同时直接计算对应的幂并乘到答案中（快速幂）
        {
            prime[++cnt] = i;
            (ans *= qpow(prime[cnt], floor(logn / log(i)))) %= MOD; // 累乘答案
        }
        for (int j = 1; j <= cnt && prime[j] * i <= n; j++)
        {
            isNotPrime.set(prime[j] * i);
            if (i % prime[j] == 0)
                break;
        }
    }
    printf("%lld", ans);
    return 0;
}
```
然后我兴冲冲的提上去准备 AC……然而现实却是 TLE 了 #7-10 qwq

当初以为是 `std::bitset` 的问题，然而改成 `bool` 数组仍然会 TLE #10（差 $0.02$ 秒）……那么到底是哪里的问题呢？

考虑到 `long long` 和 `%` 比较慢，那么我们是否可以尝试着在快速幂中少模几次？果然，把快速幂中的 `ans` 变量和 `base` 参数改成 `int` 并把快速幂中所有的取模去掉就 A 了！

那么我们到底为什么可以去掉模呢？因为我们计算的是上面结论中的 $i^{\lfloor\log_in\rfloor}$，而又可以知道这一项必定是 $\leq n$ 的。而 $n\leq10^8$，所以快速幂中所有的中间变量均不会超过 $10^8$，就不需要模和 `long long` 了！

最终 AC 代码：
```cpp
#include <iostream>
#include <cstdio>
#include <bitset>
#include <cmath>
using std::bitset;
const int MOD = 100000007;
int n, cnt = 0;
long long ans = 1;
int prime[5762000];
bool isprm[100000010];
int qpow(int base, int pow)
{
    if (pow == 1)
        return base;
    int ans = 1;
    while (pow)
    {
        if (pow & 1)
            ans *= base;
        base *= base;
        pow >>= 1;
    }
    return ans;
}
int main()
{
    scanf("%d", &n);
    double logn = log(n);
    for (int i = 2; i <= n; i++)
    {
        if (!isprm[i])
        {
            prime[++cnt] = i;
            (ans *= qpow(prime[cnt], int(logn / log(i)))) %= MOD;
        }
        for (int j = 1; prime[j] * i <= n && j <= cnt; j++)
        {
            isprm[prime[j] * i] = true;
            if (i % prime[j] == 0)
                break;
        }
    }
    printf("%lld", ans);
    return 0;
}
```

---

## 作者：Meaninglessness (赞：6)

别被难度吓到了......

首先，理解一下题目，本题的大意其实就是求1至n的最小公倍数

首先，n<=100000000 显然普通的方法不行

那么我们首先看几个例子：

1.lcm(15,25)=75
$$15 = 3*5 $$
$$25=5^2 $$
$$75=3*5^2$$
2.lcm(18,24)=72
$$18=2*3^2$$
$$24=2^3*3$$
$$72=2^3*3^2$$
3.lcm(6,14,21)=42
$$6=2*3$$
$$14=2*7$$
$$21=3*7$$
$$42=2*3*7$$

怎么样，有没有看出什么？没错！求n个数的最小公倍数就是求这些数中**每一个同样质因子**的**最大指数**（拓展：求n个数的最大公约数就是这些数中每一个同样质因子的最小指数）

所以，很多人想到了打表，但是这题的数据范围过于大

1亿内有500多万个质数，所以就通过不了了

所以我们需要在原程序中得出所有质数，下面我们来看一下求质数的方法

1.普通（大部分人）会的方法

[传送门](https://www.luogu.org/paste/rnf179zj)

2.Eratosthenes筛法

其实就是找到一个素数，把其的倍数全部筛掉，详见代码

[传送门](https://www.luogu.org/paste/6gcie36l)

但显然，前两种求质数的方法都满足不了我们的要求，那么就要请出我们下一种筛法

3.欧拉筛

[传送门](https://www.luogu.org/paste/mwemlpl0)

思路：求出n以内所有的质数后，枚举这些质数，求出一个最大数k使得prime的k次幂<n并把答案累乘模mod

# 解&正解

1.用Eratosthenes筛法，于是我得到了一个60分

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <string>
#include <algorithm>
using namespace std;

int prime[5761460],n;
bool vis[100000000+5];
long long ans=1,mod=100000007;

void jisuan(int p)
{
	long long total=1;
	for(long long i=1;;i++)
	{
		total*=p;
		if(total>n)
			break;
		ans*=p;
		ans%=mod;
	}
}

int main()
{
	cin>>n;
	for(register int i=1;i<=n;i++)
		vis[i]=1;
	vis[0]=vis[1]=0;
	int cnt=1;
	for(register int i=2;i<=n;i++)
	{
		if(vis[i]==1)
		{
			prime[cnt++]=i;
			for(register int j=i*2;j<=n;j+=i)
				vis[j]=0;
		}
	}
	prime[cnt]=1e9;
	for(register int i=1;i<=5761455;i++)
	{
		if(prime[i]<=n)
		{
			jisuan(prime[i]);
		}
		else
			break;
	}
	cout<<ans<<endl;
	return 0;
}

```

2.欧拉筛+一些细小的优化，轻松100

```cpp
#include <iostream>
#include <cstring>
using namespace std;
int prime[5761460];
bool vis[100000005];
long long ans=1,mod=100000007;
int n,cnt=0;

void jisuan(int p)
{
	long long total=1;
	for(long long i=1;;i++)
	{
		total*=p;
		if(total>n)
			break;
		ans*=p;
		ans%=mod;
	}
}

int main()
{
	cin>>n;
    for(int i=2;i<=n;i++)
    {
        if(!vis[i])
        {
        	prime[cnt++]=i;
    	}
        for(register int j=0;j<cnt && i*prime[j]<=n;j++)
        {
            vis[i*prime[j]] = true; 
            if(i%prime[j] == 0) break;
        }
    }
	for(register int i=0;i<=cnt-1;i++)
	{
		if(prime[i]<=n)
		{
			jisuan(prime[i]);
		}
		else
			break;
	}
	cout<<ans<<endl;
    return 0;
}
```



---

## 作者：asuldb (赞：5)

好像随手就最优解了

这个数据范围很奇特啊，如果正解是$O(logn)$或$O(\sqrt\text{n})$不可能这么小

所以大概需要一个$O(n)$的算法来卡过去吧

根据$lcm$的定义，就是对数分解质因数之后相同的质因子取一个max，就好了，所以我们可以直接线性筛解决

对于小于$(\sqrt\text{n})$的质数我们需要求出它在$n$范围内最多有多少次幂，其实对于质数$i$就是求一个$log_in$

我们完全可以换底公式啊

$$log_in=log_2n/log_2i$$

$log_2$完全可以使用cmath里自带的log2函数（复杂度玄学）

求出$log_in$之后直接一个快速幂求$i^{log_in}$就好了

对于那些大于$(\sqrt\text{n})$的质数，我们直接乘这个质数就行了，因为一个数最多只有一个大于$(\sqrt\text{n})$的质因子

代码

```cpp
#include<bitset>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#define maxn 100000001
#define LL long long
#define re register
const LL mod=100000007;
std::bitset<maxn> f;
int p[6000005],tot;
LL ans=1;
int n;
inline LL quick(LL a,LL b)
{
    LL S=1;
    while(b)
    {
        if(b&1) S=S*a%mod;
        b>>=1;
        a=a*a%mod;
    }
    return S;
}
int main()
{
    scanf("%d",&n);
    int len=sqrt(n);
    f[1]=1;
    for(re int i=2;i<=n;i++)
    {
        if(!f[i]) 
        {
            p[++tot]=i;
            if(i>len) ans=ans*i%mod;
            else ans=ans*quick(i,log2(n)/log2(i))%mod;
        }
        for(re int j=1;j<=tot&&i*p[j]<=n;j++)
        {
            f[p[j]*i]=1;
            if(i%p[j]==0) break;
        }
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Yyxxxxx (赞：2)

## 这道题折磨了我一天！！！
首先这是我们校内一道模拟赛的题。把我卡得。。。五彩缤纷  
## 题意
很显然是求$lcm(1,2,3...n)$。   
(求最小公倍数可以算作求这几个数中，所有质数取其在这些数中最大指数的积)。   
# $Solution$
转化一下：对于任意的$p^k\le n < p^{k+1}$那么$p^k$一定在$[1,n]$中，而且$k$就是质数$p$的最大指数。      
我们可以在筛质数的时候，同时把$p^k$也处理出来。    
即对于所有的$cnt$个$p_i$找到一个$k_i$，那么：  
$$Ans=\prod\limits_{i=1}^{cnt}p_i^{k_i}$$
# $Code$
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
int prime[75000000], cnt = 0;
bitset<200000004> used;
const int mod = 1e8 + 7;
int main()
{
    ll n , ans = 1;
    scanf("%lld",&n);
    for (int i = 2; i <= n; i++)
    {
        if (!used[i])
        {
            prime[cnt++] = i;
            for (ll s = i; s <= n; s *= i)//此处为处理出k
                ans = ans * i % mod;
        }
        for (int j = 0; j < cnt && i * prime[j] <= n; j++)
        {
            used[i * prime[j]] = 1;
            if (i % prime[j] == 0)
                break;
        }
    }
    printf("%lld\n", ans);
    system("pause");
    return 0;
}
```
在不断交题的过程中有一些奇怪现象：
吸氧少了$20pts$，快读少了$40pts$，$so$ $strange$

---

## 作者：critnos (赞：2)

~~我突然发现我是不开O2又不打表的最快的（1.62s）~~

这题就是练卡常+缩小常数的

嗯，好像不用bitset也不会MLE呀

线性筛其实是可以优化的

比如说，先特判2，然后后面从3开始循环，每次加2

继续优化：~~通过玄学方法~~我们知道，大于3的质数都分布在$6n+1$和$6n-1$，所以先特判2和3，后面从6开始循环，每次加6，然后判断$i+1$和$i-1$。大概比第一个优化快了1.5倍吧

还有，为了~~偷懒~~减少码量，可以不打快速幂。

快速幂是这样的：

$2^6=2^3*2^3$

$2^3=2^1*2^2$

$2^1=2$

$2^2=2^1*2^1=4$

$2^3=2*4=8$

$2^6=8*8=64$

~~慢速幂~~我是这样的

（求$2^6$）

$2^1=2$

$(2^1)^2=2^2=4$

$(2^2)^2=4^2=16$

$4*2=8$

$8>6$

$16*2=32$

$32*2=64$

就是从2一直乘以自己，一直到无法再乘，就转而用普通的循环乘

上码：

```cpp
#include<bits/stdc++.h>
using namespace std;
bool pr[100000005];
int prime[6000000];
const long long mod=100000007;
int main()
{
	register int n,i,l=0,f=0;
    register long long j,s;
    cin>>n;
    for(s=2;s*s<=n;s*=s);
    for(;s*2<=n;s*=2);
    for(j=3;j*j<=n;j*=j);
    for(;j*3<=n;j*=3);
    s*=j;
	if(s>mod) s%=mod;
    for(i=6;i<=n;i+=5)
    {
    	--i;
    	if(!pr[i]) 
		{
			prime[l++]=i;
			if(f||i*i>n) s*=i,f=1;
			else
			{
				for(j=i;j*j<=n;j*=j);//此处是优化
				for(;j*i<=n;j*=i);
				s*=j;
			}
			if(s>mod) s%=mod;
		}
		for(j=0;j<l&&i*prime[j]<=n;++j)
    	{
    		pr[i*prime[j]]=1;
    		if(i%prime[j]==0) break;
		}
		i+=2;
		if(!pr[i]) 
		{
			prime[l++]=i;
			if(f||i*i>n) s*=i,f=1;
			else
			{
				for(j=i;j*j<=n;j*=j);
				for(;j*i<=n;j*=i);
				s*=j;
			}
			if(s>mod) s%=mod;
		}
    	for(j=0;j<l&&i*prime[j]<=n;++j)
    	{
    		pr[i*prime[j]]=1;
    		if(i%prime[j]==0) break;
		}
	}
	cout<<s;
}
```

---

## 作者：zzhhtt (赞：2)

##### 求756，4400，19845，9000的最小公倍数？

因756=2×2×3×3×3×7，4400=2×2×2×2×5×5×11，19845=3×3×3×3×5×7×7，9000=2×2×2×3×3×5×5×5，这里有素数2，3，5，7，11．2最高为4次方16，3最高为4次方81，5最高为3次方125，7最高为2次方49，还有素数11．所以得最小公倍数为16*81*125*49*11=87318000．

##### 解法："线性筛" 1 ~ 1e8 的素数，找出每个素数对应的最高次幂，最小公倍数=每个素数最高次幂的连乘。

附上源代码
```
#include<stdio.h>
#include<queue>
#include<string.h>
#include<algorithm>
#include<set>
#include<map>
#include<math.h>
#include<vector>
#include<bitset>
#include<iostream>
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll mod=100000007;
const int M=100000000;
bool a[M+5];
int b[7000005];
int p=0,n;
ll ans=1;
void fun(){
    a[0]=a[1]=1;
    for(register int i=2;i<=n;i++){ // register卡乘数
        if(!a[i]){
            b[p++]=i;
            for(ll k=i;k<=n;k*=i){  
                ans=ans*1ll*i%mod;
            }
        }
        for(register int j=0;j<p&&i*b[j]<=M;j++){
            a[i*b[j]]=1;
            if(i%b[j]==0)
                break;
        }
    }
}
int main(){
    scanf("%d",&n);
    fun();
    printf("%lld\n",ans);
    return 0;
}
 


```


---

## 作者：天南子Arthur (赞：2)

在获得一位巨佬的帮助之下，本蒟蒻终于鼓起勇气写了第一篇题解
        
   由于本蒟蒻能力有限，故该程序仍有很多不足（没有氧气过不了，不卡常过不了。。。），还请各位大佬多批评。

下面上代码：
```cpp
#include<cstdio>
#include<cmath>
#include<bitset>
using namespace std;
int n,cnt,k=1,Prime[5761456];//一亿内有5761455个质数
bitset<99999990> f;//若用bool型会爆空间 
inline int power(int a,int b){
    int r=1,base=a;
    while(b){
        if(b&1)r=(long long)(r*base)%100000007;//注意不可写成r*=base%100000007,%优先级高于*= 
        base=(long long)(base*base)%100000007;//注意不可写成base*=base%100000007,%优先级高于*= 
        b/=2;
    }
    return r;
}//快速幂 
inline void Euler(){
	for(register int i=2;i<=n;i++){
		if(!f[i])
			Prime[++cnt]=i;
		for(register int j=1;j<=cnt&&(long long)i*Prime[j]<=n;j++){
			f[i*Prime[j]]=1;
			if(i%Prime[j]==0)
				break;
				}
			}
		}//欧拉筛 
inline int read(){
    int x=0;
    char st=getchar();
    while(!isdigit(st))  st=getchar();
    while(isdigit(st))  x=(x<<1)+(x<<3)+(st^'0'),st=getchar();
    return x;
}//读入优化 
inline void write(int x){
    if(x>9)
      write(x/10);
    putchar(x%10+'0');
}//输出优化 
int main(){
    n=read();
	Euler();
	int asd=sqrt(n);
	for(register int i=1;i<=cnt;i++){//运用换底公式，则 logPrime[i](n)=log2(n)/log2(Prime[i])
		if(Prime[i]>asd)
			k=((long long)k*Prime[i])%100000007;//当Prime[i]>sqrt(n)时，logPrime[i](n)=log2(n)/log2(Prime[i])=1
		else
			k=((long long)k*power(Prime[i],(log2(n)/log2(Prime[i]))))%100000007;
			}//计算k的值 
	write(k);
	//printf("\n");可要可不要的换行 
	return 0;
}
//设1-n内共有cnt个质数，存入Prime[i]数组中

//则lcm(1-n)=Prime[1]^logPrime[1](n)*Prime[2]^logPrime[2](n)*……*Prime[i]^logPrime[i](n) 

//运用换底公式，则 logPrime[i](n)=log2(n)/log2(Prime[i])

//当Prime[i]>sqrt(n)时，logPrime[i](n)=log2(n)/log2(Prime[i])=1
```

---

## 作者：Vidoliga (赞：1)

# 做题第一步：知道题目考什么
### 首先先看到这题想要$AC$就要有一个很优的算法，为此我们需要知道以下几个东西$:$
## 1.$bitset$
$bitset$是一个非常少见的数据结构，$bitset$只占$1bit,$而$bool$却会占$1$字节,如果这题用$bool$会超出空间限制$,$而$bitset$就不会$.$固然此题要用到$bitset$
## 2.线性筛
这题考的就是区间$[1,n]$的数的最小公倍数，可以看到如果用一般的筛法（埃拉托斯特尼筛法) 的时间复杂度为$O(nloglogn)$，在10的8次方面前简直是......总而言之这题必用线性筛$O(n)$的算法

## 3.接下来则是对数据的处理和统计

对于数据的统计我们需要定义一个$ans$来统计所有的乘积
而怎么统计呢？这就需要读者自行思考了

代码的话......

```
#include<iostream>
#include<bitset>
using namespace std;
bitset<99999990> see;
int k[5761456],n;
int deta[5761456];
int ji;
long long ans = 1;
int main(){
	cin>>n;
	for(int i = 2;i <= n;i++){
		if(see[i] == false){
			k[ji]	= i;
			deta[ji] = i;
			ans = ans * i % 100000007;
			ji++;	
		}
		for(int j = 0;j <= ji && k[j] * i <= n;j++){
			see[k[j]*i] = true;
			if(i % k[j] == 0){
				if(i == deta[j]){
					deta[j] *= k[j];
					ans = ans * k[j] % 100000007;
				}
				//	
				break;
			}
		}
	}	
	cout<<ans;
	return 0;
}
```

## 摘自我以前的[$blog$](https://www.luogu.com.cn/blog/gf2020daihengfei/solution-p4626)


---

## 作者：Durancer (赞：0)

#### 写在前面

该题解仅提供一个易懂的思路，防卡常的技巧请转移到其他dalao的题解查看

#### 题目描述

给定一个数 $n$ 求出能被 $[1,n]$ 内所有整数整除的最小整数，最后的答案对$10^8+7$ 取模即可

#### 思路

既然是求最小的正整数，那就是求 $[1,n]$ 内所有整数的最小公倍数

首先根据最小公倍数的定义我们可以得到一个求解的公式

$$lcm=\prod_{i=1}^{i\le cnt} prime_i^{max_i}$$

其中 $cnt$ 为 $[1,n]$ 内素数的个数，$max_i$ 表示的是第 $i$ 个素数在 $[1,n]$ 中的某个数中，做因子时的最大的数目，也就是看一看 $[1,n]$ 中哪一个数的因子中 $prime_i$ 的数量最多

因为这个题给的数是连续的，所以除了卡常以外是非常好想的，我们可以通过欧拉筛，并在这个筛的过程中只要找到一个素数，就给 $ans$ 乘上 $i^{max}$,这里的 $max$ 表示的是使 $i^{x}<n$ 的最大正整数，由此我们可以通过这个方式来找到每个素数所占的最大个数，并一步步乘上去得到答案

#### 代码（O2）

```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<bitset>
#define int long long 
using namespace std;
const int mod=1e8+7;
const int N=1e7+9; 
bitset<99999990> v;
//10^8内目测有5761455个质数
int prime[N];
int n;
int cnt;
int ans=1;
signed main()
{
	scanf("%lld",&n);
	for(register int i=2;i<=n;i++)//防卡常神器 
	{
		if(!v[i])
		{
			prime[++cnt]=i;
			int j;
			for(j=1;j<=n;j*=i);
			j/=i;//将j压缩在n的最大范围之内
			ans=(ans*1ll*j%mod)%mod; 
		} 
		for(register  int j=1;j<=cnt&&i*prime[j]<=n;j++)
		{
			v[i*prime[j]]=1;
			if(i%prime[j]==0) break;
		}
	}
	printf("%lld",ans%mod);
	return 0;  
}
```


---


# GCD

## 题目描述

给定正整数 $n$，求 $1\le x,y\le n$ 且 $\gcd(x,y)$ 为素数的数对 $(x,y)$ 有多少对。

## 说明/提示

#### 样例输入输出 1 解释

对于样例，满足条件的 $(x,y)$ 为 $(2,2)$，$(2,4)$，$(3,3)$，$(4,2)$。

---

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $1\le n\le10^7$。

---

来源：bzoj2818。

本题数据为洛谷自造数据，使用 [CYaRon](https://github.com/luogu-dev/cyaron) 耗时 $5$ 分钟完成数据制作。

## 样例 #1

### 输入

```
4```

### 输出

```
4```

# 题解

## 作者：Siyuan (赞：96)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io/articles/problem-BZOJ-2818-GCD/)

---

## Description

> 题目链接：[Luogu 2568](https://www.luogu.org/problemnew/show/P2568)

给定整数 $n$，求 $1\le x,y\le n$ 且 $\gcd(x,y)$ 为素数的数对 $(x,y)$ 有多少对。

数据范围：$1\le n\le 10^7$

------

## Solution

> 本题和[「Luogu 2257」YY 的 GCD](https://www.luogu.org/problemnew/show/P2257)（[题解](https://hydingsy.github.io/articles/problem-Luogu-2257-YY-GCD/)） 几乎完全一样，但是本题由于是**单组询问**，所以不需要 $O(n)$ 的预处理和 $O(\sqrt n)$ 的单次询问复杂度。

首先我们枚举质数：
$$\sum_{p\in\text{prime}}\sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)=p]$$
对 $\gcd$ 进行套路式的变形：
$$\sum_{p\in\text{prime}}\sum_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{p}\right\rfloor} [\gcd(i,j)=1]$$
接下来改变 $j$ 的枚举上界（其中 $-1$ 的原因是 $i=j=1$  时的答案会被重复统计，因此注意这里的 $-1$ 是在 $\sum_{p\in\text{prime}}$ 中的，而不是在 $\sum_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}$ 中的）：
$$\sum_{p\in\text{prime}}\left(\sum_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}\left(2\sum_{j=1}^i [\gcd(i,j)=1]\right)-1\right)$$
此已经可以发现最后一个 $\sum$ 是的值就是 $\varphi(i)$，故原式化为：
$$\sum_{p\in\text{prime}}\left(2\sum_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}\varphi(i)-1\right)$$
所以我们可以线性筛求出 $\varphi(i)$ 的值并做前缀和，枚举 $p\in\text{prime}\ \text{and}\ p\le n$ 并统计答案即可。

**时间复杂度**：$O(n)$

------

## Code

```cpp
#include <cstdio>

const int N=1e7+5,M=1e6+5;
int n,tot,p[M],phi[N];
long long sum[N];
bool flg[N];

void sieve(int n) {
	phi[1]=1;
	for(int i=2;i<=n;++i) {
		if(!flg[i]) p[++tot]=i,phi[i]=i-1;
		for(int j=1;j<=tot&&i*p[j]<=n;++j) {
			flg[i*p[j]]=1;
			if(i%p[j]==0) {
				phi[i*p[j]]=phi[i]*p[j];
				break;
			} else {
				phi[i*p[j]]=phi[i]*phi[p[j]];
			}
		}
	}
	for(int i=1;i<=n;++i) sum[i]=sum[i-1]+phi[i];
}
int main() {
	scanf("%d",&n);
	sieve(n);
	long long ans=0;
	for(int i=1;i<=tot;++i) ans+=2*sum[n/p[i]]-1;
	printf("%lld\n",ans);
	return 0;
}
```



---

## 作者：zhou_yk (赞：86)

$update\ \ \ 2018/11/18$修改了$Letex$，其他没有变

中间我$AFO$了,成功从红名掉到了蓝名

$update\ \ \ \ 2019/7/22$加了很多自己学文化课时的感悟

$update\ \ \ \ 2019/7/24$发现了一个错误，改了一下

---------------------------------------------------------------------------

先推销一波我的博客[这里](https://www.cnblogs.com/zhouykblog/)

---------------------------------------------------------------------------

听说有一句话数论只会$GCD$，所以我翻开了此题，却发现这题并不是这么简单

所以就写篇题解吧~~(废话真多)~~

-------------

先介绍一个东西：欧拉函数

定义： 对于正整数$n$,小于或等于$n$,且与$n$互质的正整数(包括1)的个数，记作$φ(n)$。($φ(1)=1$)

写成数学公式就是$φ(n)=\displaystyle\sum_{i=1}^n1(gcd(i,n)=1)$

那么答案是什么呢？

我们考虑每个质数$p$对答案的贡献,对于每一个质数$p$

$gcd(x,y)=1$等价于$gcd(a*p,b*p)=p$

所以$gcd(x,y)$为$p$的数对个数即为$1<=a,b<= \frac{n}{p}$中互质对$a,b$的个数,其中不妨令$a<=b$

对于每一个$b,a$有$φ(b)$个取值使$a,b$互质，及$gcd(a*p,b*p)=p$

所以此题答案就是$\displaystyle\sum_{i=1}^n φ(i)$ 

----------

先介绍一些$φ(n)$的性质：

积性函数(常见的有)

​				$ε(n)=[n==1]\ \ \ \ \  \ \ d(n)=\displaystyle\sum_{d|n}1\ \ \ \ \ \ \ σ(n)=\displaystyle\sum_{d|n}d $

​				$ μ(n)=[max(c_1,c_2,...c_m)<=1]*(-1)^m$

​				当然，还有$φ(n)$喽

积性函数的性质：若$gcd(a,b)==1$则$f(a\times b)=f(a)\times f(b)$

$φ(n)$的其他性质

​				1.若$p$为质数$φ(p)=p-1$

​				2.若$p|n$且$p^2|n$，则$φ(n)=φ(n/p)\times p$

​				3.若$p|n$但是不满足$p^2|n$，则$φ(n)=φ(n/p)\times (p-1)$

​				4.$\displaystyle\sum_{d|n}φ(d)=n$

------------------------------------------------------------------------------------------------

所以，现在问题就转化为了怎样快速求$φ(n)$

可以联想到欧拉筛法，因为可以在$O(n)$的时间内求出所有质数。 

若对于$i$，如果已知所有的$1-i$ 的$φ$，枚举$<=i$的质数$p[j]$，可以求得$φ(x\times p[j])$

1.若$p[j]$与$x$互质  $φ(x*p[j])=φ(x)*φ(p[j])$

2.若不互质，设$x=t*p[j]^k$

$φ(x*p[j])=φ(t*p[j]^{k+1})=φ(t)* φ(p[j]^{k+1})$
$=φ(t)* φ(p[j]^k)*p[j]=φ(x)*p[j]$


所以，预处理$φ(i)$的代码：

```cpp
	for (int i=2;i<=n;++i){
		if (is_prime[i]) phi[i]=i-1,prime[++prime_num]=i;
		for (int j=1;j<=prime_num&&prime[j]*i<=n;++j){
			is_prime[prime[j]*i]=0;
			if (__gcd(prime[j],i)==1) phi[prime[j]*i]=phi[prime[j]]*phi[i];
				else phi[prime[j]*i]=prime[j]*phi[i];
			if (i%prime[j]==0) break;
		}
	}
```
做一下前缀和就可以了 

最后提醒一句，$10$年$OI$一场空，不开$long\ long$见祖宗

------------

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=10000005;
bool is_prime[N];
int n,prime_num,prime[N],phi[N];
long long sum[N];
int main(){
	scanf("%d",&n);
	memset(is_prime,1,sizeof(is_prime));
	is_prime[1]=0;phi[1]=1;
	for (int i=2;i<=n;++i){
		if (is_prime[i]) phi[i]=i-1,prime[++prime_num]=i;
		for (int j=1;j<=prime_num&&prime[j]*i<=n;++j){
			is_prime[prime[j]*i]=0;
			if (__gcd(prime[j],i)==1) phi[prime[j]*i]=phi[prime[j]]*phi[i];
				else phi[prime[j]*i]=prime[j]*phi[i];
			if (i%prime[j]==0) break;
		}
	}
	for (int i=1;i<=n;++i) sum[i]=sum[i-1]+phi[i];
	long long ans=0;
	for (int i=1;i<=prime_num&&prime[i]<=n;++i) 
		ans+=(sum[n/prime[i]]<<1)-1;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Limit (赞：28)

看到这是一道紫题还是和gcd有关的才点进来(~~毕竟数论只会gcd~~).

- ## 前置芝士(为了保证绝大多数人能看懂,有一些非常基础的前置芝士,如果已经了解可以pass)
  - **[质数](https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0/263515?fr=aladdin)**(又称素数):因数只有1和本身,但是很特殊的1不是一个质数.
  - **[gcd](https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fr=aladdin)**:欧几里得算法,又称辗转相除法,可以在约为O(LogN)的时间复杂度内求出两个数的最大公约数(N为两个数中大的那个数,在两数为相邻的[斐波那契数](https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145?fromtitle=%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0&fromid=365965&fr=aladdin)时最慢,具体不证明~~其实就是我不会~~).
  - **[欧拉函数](https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/1944850?fr=aladdin)**:一个非常基本的[数论函数](https://baike.baidu.com/item/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0/8555075?fr=aladdin),是一个[积性函数](https://baike.baidu.com/item/%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0/8354949?fr=aladdin)(~~虽然本题并没有考到~~),欧拉函数可以表示为$\varphi(x)$,表示小于x的自然数中与x[互质](https://baike.baidu.com/item/%E4%BA%92%E8%B4%A8/577412?fr=aladdin)的数的个数(具体求法下文会讲到).
- ## 推导公式
很明显,直接暴力需要O(N^2)的时间发咋读但是N有1e7肯定是会T的,所以需要从gcd(a,b)为一个质数入手.
当$gcd(a,b)==1$时不难发现$gcd(a*p,b*p)==p$(p为任何自然数时都成立),于是乎可以先把0~N中的素数筛出来.
那么下面要怎么知道一个素数可以产生几对符合条件的a,b呢?
可以发现$max(a,b)*p\leq N\Rightarrow max(a,b)\leq \dfrac {N}{p}$因为a,b都为整数,所以$max(a,b)\leq \lfloor\dfrac {N}{p}\rfloor$,于是就要知道小于p的互质的数对的个数了,拿出前置芝士中的欧拉函数,于是小于p的数的对数$=2*\sum ^{\tiny\lfloor\dfrac {N}{p}\rfloor}_{i=1}\varphi \left( i\right)$(因为如(1,2)和(2,1)同时成立,所以需要乘2),每次都要求自然还是会T,所以需要用到前缀和优化一下.

- ## 具体实现
  - 欧拉函数的具体实现:(本人太菜,只会用埃氏筛)
    对于x不是质数$\varphi(x)=x*\prod ^{n}_{i=1}1-\dfrac {1}{p_{i}}$(其中$p_{i}$为为x质因数,n为x的质因数的个数)
    x为质数时$\varphi(x)=x-1$
    其中十分特殊的$\varphi(1)=1$
    这样可以直接套入埃氏筛中将所有$1\leq x\leq N$的$\varphi(x)$求出,再用一个sum数组统计起来.
- ## 代码
```cpp
#include<bits/stdc++.h>
#define rap(i,first,last) for(int i=first;i<=last;++i)
using namespace std;
const int maxN=1e7+5;
int N;
double phi[maxN];
bool boo[maxN];
long long sum[maxN];//注意开long long
int main()
{
	scanf("%d",&N);
	rap(i,1,N)
	{
		boo[i]=1;
		phi[i]=i;//先赋值为i方便处理
	}
	boo[1]=0;//不是质数
	rap(i,2,N)//埃氏筛的部分
	if(boo[i])
	{
		phi[i]=i-1;
		rap(j,2,N/i)
		{
			boo[i*j]=0;
			phi[i*j]*=1.0-1.0/i;//求出欧拉函数的值
		}
	}
	sum[1]=1;//1时因为只有(1,1)所以不用乘二
	rap(i,2,N)
	sum[i]=sum[i-1]+1ll*((int)phi[i])*2;//用前缀和优化
	long long answer=0;//注意long long
	rap(i,2,N)
	if(boo[i])answer+=sum[N/i];//把每个质数所带来的(a,b)全部相加
	printf("%lld",answer);//输出answer
	return 0;
}
```
~~数论题的题解好难写~~

---

## 作者：Tel兼_dope (赞：19)

# - 假的GCD（）


#### ~~这道题是额教练当模板测试做的。。。。~~
# 往欧拉函数想-->
于是，我拿到题就立刻敲了个板子


------------

```
void Euler()
{
	phi[1]=1;book[1]=1;
	for(ll i=2;i<=n;++i)
	{
		if(!book[i])
		{
			prime[++num]=i;
			phi[i]=i-1;
		}
		for(ll j=1;j<=num && i*prime[j]<=n;++j)
		{
			book[i*prime[j]]=1;
			if(i%prime[j]==0)
			{
				phi[i*prime[j]]=phi[i]*prime[j];
				break;
			}
			phi[i*prime[j]]=phi[i]*(prime[j]-1);
		}
	}
}
```


------------

然后我们再根据题意来思考：

1.已知①1<=x,y<=n;②gcd(x,y)=p为一个素数;
所以我们就可知
$$\begin{cases}x=k1*p\\y=k2*p\\\end{cases}$$



------------


推为-->>

$$\begin{cases}k1=x/p\\k2=y/p\\\end{cases}$$

由于x,y的最大公约数为p，所以仅当k1,k2互质的时候:

可以看下这道题【洛谷 P1072】

2.由条件①1<=x,y<=n;②k1=x/p;k2=y/p;

就可以直接知道③1<=k1,k2<=n/p;

3.已知①1<=k1,k2<=n/p;②只有k1,k2互质时才会满足

那么就到了最后一步，求【1,n/p】区间内所有互质的数的对数

这时，欧拉函数就发挥作用了，欧拉函数求得是【1，n】内与n互质的数；那来一个前缀和，不就可以直接求出【1，n】中所有互质的数了吗。

### 【注】：由于1不是素数，所以与1有关的互质不在所求范围内，所以直接将phi[1]赋值成1就可以了  ( phi[1]=1; )



------------


```
#include<cstdio>
#include<algorithm>
#define ll long long
using namespace std;
const ll maxn=(1e7)+10;
ll n,ans=0;
ll phi[maxn];
ll book[maxn],prime[maxn],num=0;

void Euler()
{
	for(ll i=2;i<=n;++i)
	{
		if(!book[i])
		{
			prime[++num]=i;
			phi[i]=i-1;
		}
		for(ll j=1;j<=num && i*prime[j]<=n;++j)
		{
			book[i*prime[j]]=1;
			if(i%prime[j]==0)
			{
				phi[i*prime[j]]=phi[i]*prime[j];
				break;
			}
			phi[i*prime[j]]=phi[i]*(prime[j]-1);
		}
	}
}

inline ll read()
{
	ll w=0,f=1;char ch=getchar();
	while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){w=(w<<1)+(w<<3)+(ch^48);ch=getchar();}
	return w*f;
}

signed main()
{
//	freopen("gcd.in","r",stdin);
//	freopen("gcd.out","w",stdout);
	n=read();Euler();
	for(ll i=1;i<=n;++i)phi[i]+=phi[i-1];
	for(ll i=1;i<=num;++i)ans+=(phi[n/prime[i]]*2);
	printf("%lld",ans+num);
	return 0;
}
```


------------


---

## 作者：fyfy (赞：13)

#### 这题我是用莫比乌斯函数+整除分块做的。

废话不多说了。。。莫比乌斯函数我们将它用$mu[i]$表示吧。

当$i=1$时，$mu[i]=1$;

当$i>1$时，且$i=p^1p^2p^3...p^r$，$mu[i]=(-1)^r$。其中p是不同质数。

既然已经知道了莫比乌斯函数，那么我们开始化简式子。

题目要求求的是：$$\sum^n_{a=1}\sum^n_{b=1,gcd(a,b)=1}1$$

化简：$$\sum_p\sum_{a=1}^{\lfloor{\frac{n}{p}}\rfloor}\sum^{\lfloor{\frac{n}{p}}\rfloor}_{b=1,gcd(a,b)=1}1$$

再化简：$$\sum_p\sum_{a=1}^{\lfloor{\frac{n}{p}}\rfloor}\sum^{\lfloor{\frac{n}{p}}\rfloor}_{b=1}[gcd(a,b)=1]$$

看到右边的$[gcd(a,b)=1]$,敏锐的你们立马就可以嗅到$mu[i]$的气息。

于是我们得到:$$\sum_p\sum_{a=1}^{\lfloor{\frac{n}{p}}\rfloor}\sum^{\lfloor{\frac{n}{p}}\rfloor}_{b=1}\sum_{d|gcd(a,b)}mu[d]$$

继续：$$\sum_p\sum_dmu[d]\sum^{\lfloor{\frac{n}{p}}\rfloor}_{d|a}\sum^{\lfloor{\frac{n}{p}}\rfloor}_{d|b}1$$

就要出来了：$$\sum_p\sum_dmu[d](\lfloor{\frac{\lfloor{\frac{n}{p}}\rfloor}{d}}\rfloor)^2$$

最后三步：$$\sum_p\sum_dmu[d]({\lfloor{\frac{n}{pd}}\rfloor})^2$$$$=\sum_{T=1}\sum_{d|T}mu[d]({\lfloor{\frac{n}{T}}\rfloor})^2$$$$=\sum_{T=1}({\lfloor{\frac{n}{T}}\rfloor})^2\sum_{p|T}mu[\lfloor{\frac{T}{p}}\rfloor]$$

然后式子终于终于化简完了，其中$T$等于$pd$，

左边直接整除分块什么的，右边那一坨预处理前缀和即可。

上代码吧！注意开$\texttt{long~long}$～

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef int _int;
#define int long long

const int N=10000001;
int p[N],tot,n,sum[N],ans;
short mu[N];
bool ok[N];

void shai()
{
    memset(ok,1,sizeof(ok));
    ok[1]=0;mu[1]=1;
    for (int i=2;i<=n;++i) {
        if (ok[i]) p[++tot]=i,mu[i]=-1;
        for (int j=1;j<=tot&&i*p[j]<=n;++j) {
            ok[i*p[j]]=0;
            if (i%p[j]==0) break;
            mu[i*p[j]]=-mu[i];
        }
    }
    for (int i=1;i<=tot;++i)
        for (int j=1;j*p[i]<=n;++j)
            sum[p[i]*j]+=mu[j];
    for (int i=1;i<=n;++i) sum[i]+=sum[i-1];
}

_int main()
{
    cin>>n;shai();
    for (int i=1;i<=n;++i) {
        int l=i,r=n/(n/l);
        i=r;
        ans+=(sum[r]-sum[l-1])*(n/l)*(n/l);
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Youngsc (赞：10)

[Youngsc](http://youngscc.github.io/)


因为x，y的GCD为质数p，所以x/p和y/p互质所以只需要借助欧拉函数，枚举p不同时互质的情况求和，因为x，y和y，x是两种不同的情况，而且如果x<y，只会在枚举y的欧拉函数时枚举到这种情况，所以最后答案乘二强行使其出现两次，最后考虑两个相同的质数的GCD是他本身，同样符合题意，所以最后加上n以内质数的个数就好；


###代码在这里

```cpp
# include <algorithm>
# include <iostream>
# include <cstring>
# include <cstdio>
# include <cctype>
# include <cmath>
# define R register
# define LL long long

using namespace std;
LL phi[10000010],ans;
int prime[5000000],p,n;
bool v[10000010];

inline void in(R int &a){
    R char c = getchar();R int x = 0,f = 1;
    while(!isdigit(c)){if(c == '-') f = -1; c = getchar();}
    while(isdigit(c)) x = x*10+c-'0', c = getchar();
    a = x*f;
}

int main(){
    in(n);
    for(R LL i = 2;i <= n; ++i){
        if(!v[i]) prime[++p] = i,phi[i] = i-1;
        for(R int j = 1;j <= p&&prime[j]*i<=n; ++j){
            v[i*prime[j]] = 1;
            if(i % prime[j] == 0) {phi[i*prime[j]] = phi[i]*prime[j];break;}
            phi[i*prime[j]]=phi[i]*(prime[j]-1);
        }
    }

    for(R int i = 3;i <= n; ++i) phi[i] += phi[i-1];
    for(R int i = 1;i <= p; ++i) ans += phi[n/prime[i]];
    printf("%lld",ans*2+p);
}
```

---

## 作者：DQYdqy (赞：9)

博客园内食用效果更佳:[Click here](https://www.cnblogs.com/NLDQY/p/12051832.html)

## Solution:

我们尝试着转化一下式子
$$
\sum_{p\in pri} \sum_{i=1}^n \sum_{j=1}^n [gcd(i,j)=p]
\sum_{p\in pri} \sum_{i=1}^{\lfloor {n\over p}\rfloor}
$$

$$
\sum_{j=1}^{\lfloor {n\over p}\rfloor} [gcd(i,j)=1]
$$
后面一部分有些眼熟(要素察觉
$$
\sum_{p\in pri} \sum_{i=1}^{\lfloor {n\over p}\rfloor} \sum_{j=1}^{\lfloor {n\over p}\rfloor} \sum_{d|i,d|j} \mu(d)
$$

$$
\sum_{p\in pri} \sum_{d=1}^{\lfloor {n\over p}\rfloor} \mu(d) {\lfloor {n\over pd}\rfloor}^2
$$

$$
T=dp
$$

$$
\sum_{T=1}^n {\lfloor {n\over T}\rfloor}^2\sum_{p|T,p\in pri} \mu({T\over p})
$$

我们令$f(T)=\sum_{p|T,p\in pri} \mu({T\over p})$，考虑如何线筛

当$T\in pri$，$f(T)=1$是十分显然的，考虑$f(T\times p),p\in pri$

经过简单推导可发现$p|T$时，$f(T\times p)=\mu(T)$，否则$f(T\times p)=-f(T)+\mu(T)$

那么我们便可以愉快的数论分块了！时间复杂度$O(\sqrt n+n)$

~~正解phi?看到gcd就莫反的我是不是已经没救了~~

## Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e7+11;
bool vis[N];
int n,cnt,ans,p[N],u[N],f[N];
int read(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void prepare(){
    u[1]=1;
    for(int i=2;i<=n;i++){
        if(!vis[i]) p[++cnt]=i,u[i]=-1,f[i]=1;
        for(int j=1;j<=cnt&&i*p[j]<=n;j++){
            vis[i*p[j]]=1;
            if(i%p[j]==0){
                f[i*p[j]]=u[i];
                break;
            }
            u[i*p[j]]=-u[i];
            f[i*p[j]]=-f[i]+u[i];
        }
    }
    for(int i=1;i<=n;i++) f[i]+=f[i-1];
}
signed main(){
    n=read();
    prepare();
    for(int i=1,j;i<=n;i=j+1){
        j=n/(n/i);
        int v=n/i;v=v*v;
        ans+=(f[j]-f[i-1])*v;
    }printf("%lld\n",ans);
    return 0;
}

```



---

## 作者：KobeBeanBryantCox (赞：5)

# P2568 GCD 题解

------------

[题目传送门](https://www.luogu.com.cn/problem/P2568)。

看到题解区没有容斥原理的做法，所以产生了这篇题解。

事先说明，此题解只是提供一种新思路，非正解（算半个正解吧），时间复杂度为 $O(n\log n)$，开 O2 可以卡过，但是以后如果哪个数据狂魔加强数据，不保证能过。~~（所以还是乖乖地去写欧拉函数或者莫比乌斯反演吧）~~

------------

## 题意

此题题目描述简洁无废话，题意见题目描述。

------------

## 引入

观察题目，发现 $1\leq x,y\leq n$，于是很自然地想到了欧拉函数。（欧拉函数其他题解都有讲，所以此题解不再赘述）

但是欧拉函数只能用于以上的情况，如果改成 $1\leq x\leq n,~1\leq y\leq m$，那么欧拉函数就不可做了。

比如[这个题](https://www.luogu.com.cn/problem/P2257)。

~~上述情况虽然莫比乌斯反演可以做，但是太难的东西蒟蒻不会，对吧。。。~~

所以这里有一种更常用，利用范围更广的的方法，代价是时间复杂度稍微高一点点。

------------

## 分析

先看题目求什么：

$\sum_{i=1}^{n}\sum_{j=1}^{n}~(\gcd(i,j)\in prime)$

观察到这个质数的限制很烦，所以我们先不管他。

暴力的话，时间复杂度为 $O(n^{2})$。

可以稍微变一下形：

$\sum_{g=1}^{n}\sum_{i=1}^{n}\sum_{j=1}^{n}~(\gcd(i,j)=g)$，其中 $g$ 是枚举的 $\gcd(i,j)$。

现在看起来貌似又多了一重循环，但是先别急。

我们可以设 $f(g)=\sum_{i=1}^{n}\sum_{j=1}^{n}~(\gcd(i,j)=g)$，于是原所求变为了 $\sum_{g=1}^{n}~f(g)$。

现在来思考如何计算 $f(g)$。

我们发现要让 $\gcd(i,j)$ 刚好等于 $g$ 并不好处理，于是就可以想到使用容斥原理。

所以：

$$\begin{aligned}
f(g)&=\sum_{i=1}^{n}\sum_{j=1}^{n}~(\gcd(i,j)=g)\\
	&=\sum_{i=1}^{n}\sum_{j=1}^{n}~(g\mid\gcd(i,j))-f(2\times g)-f(3\times g)-\dots-f(\lfloor\frac{n}{g}\rfloor\times g)\\
    &=\sum_{i=1}^{n}\sum_{j=1}^{n}~((g\mid i)\wedge(g\mid j))-f(2\times g)-f(3\times g)-\dots-f(\lfloor\frac{n}{g}\rfloor\times g)\\
    &=\sum_{i=1}^{n}(g\mid i)\sum_{j=1}^{n}~(g\mid j)-f(2\times g)-f(3\times g)-\dots-f(\lfloor\frac{n}{g}\rfloor\times g)\\
    &=(\lfloor\frac{n}{g}\rfloor)^{2}-f(2\times g)-f(3\times g)-\dots-f(\lfloor\frac{n}{g}\rfloor\times g)
\end{aligned}$$

这里应该能明白吧，如果不明白可以倒回去多看几眼，理解理解，我相信每个人都可以看懂这个推导过程。

所以通过这样的方式，$f(g)$ 就可以通过已经算出的 $f(2\times g),~f(3\times g),~\dots,~f(\lfloor\frac{n}{g}\rfloor\times g)$ 递推而来。

所以外层循环枚举 $g$ 应该倒序枚举，然后内层循环枚举 $g$ 的倍数。

最后，我们刚开始的时候忽略掉了质数，现在把他加上：如果枚举的 $g$ 是质数才让 $ans$ 加上答案，否则算出当前的 $f(g)$ 就行了。

注意这里的质数必须用线性筛或者埃氏筛预处理出来，这样才能保证 $O(1)$ 查询。

总时间复杂度 $O(n\log n)$，常数较小，必须开 O2 才能卡过，否则 TLE 两个点。

------------

## AC 代码

```cpp
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
#define int long long
int in()
{
	int k=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar();
	return k*f;
}
void out(int x)
{
	if(x<0)putchar('-'),x=-x;
	if(x<10)putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
const int N=1e7+10;
int f[N];
int prime[6000010]; // 质数表
bool isprime[10000010]; // 是否是质数
void pri(int n)
{
	memset(isprime,true,sizeof(isprime)),isprime[1]=false;
	for(int i=2;i<=n;i++)
	{
		if(isprime[i])prime[++prime[0]]=i;
		for(int j=1;j<=prime[0]&&i*prime[j]<=n;j++)
		{
			isprime[i*prime[j]]=false;
			if(i%prime[j]==0)break;
		}
	}
}
signed main()
{
	int n=in(),ans=0;
	pri(n); // 预处理质数
	for(int i=n;i>=1;i--) // 倒序枚举 g，这里将 g 改成了 i
	{
		f[i]=(n/i)*(n/i); // 计算答案
		for(int j=2*i;j<=n;j+=i)f[i]-=f[j];
		if(isprime[i])ans+=f[i]; // 是质数才加
	}
	out(ans);
	return 0;
}
```

什么？您说二重循环是 $O(n^{2})$ 的？

不对，其实类似如下的循环，可以证明，时间复杂度都是 $O(n\log n)$ 的：

```cpp
for(int i=1;i<=n;i++)
	for(int j=i;j<=n;j+=i)
		......
```

证明如下：

内层循环枚举次数是 $O(n+\frac{n}{2}+\frac{n}{3}+\dots+\frac{n}{n-1}+1)\approx O(n\log n)$。

最后有一个注意事项：
> 十年 OI 一场空，不开 long long 见祖宗！

------------

后记 1：版权所有 @[KobeBeanBryantCox](https://www.luogu.com.cn/user/865625)，请勿抄袭代码。

后记 2：写代码的习惯一定要好，代码不要乱七八糟，优秀的码风是很醉人的~

~~还有，能不能不要脸地要个赞呀 QwQ~~

---

## 作者：Jayun (赞：4)

[可能更好的阅读](https://www.cnblogs.com/GJY-JURUO/p/12199598.html)

---

# 题目大意：

快速求：

$$\large{\sum_{d\in prime}\sum_{x=1}^{n}\sum_{y=1}^{n}[\gcd(x,y)==d]}$$

# 正文：

## 方法一：

通过预处理筛法筛出素数再暴力枚举$x$和$y$。

预期得分20分。

## 方法二：

在方法一的基础考虑化简式子，因为两者的最大公因数都是 $d$，所以 $x|d$ 且 $y|d$，那么：

 $$\large{\sum_{d\in prime}\sum_{x=1}^{n}\sum_{y=1}^{n}[\gcd(x,y)==d] = \sum_{d\in prime}\sum_{x=1}^{\left\lfloor\dfrac{n}{d}\right\rfloor}\sum_{y=1}^{\left\lfloor\dfrac{n}{d}\right\rfloor}[\gcd(x,y)==1]}$$

发现 $\sum_{x=1}^{\left\lfloor\dfrac{n}{d}\right\rfloor}\sum_{y=1}^{\left\lfloor\dfrac{n}{d}\right\rfloor}[\gcd(x,y)==1]$ 有对称性，就是说假设 $x=3,y=5$，像这样的情况，$x=5,y=3$ 又算了一次，我们不妨把其式子化成 $\sum_{x=1}^{\left\lfloor\dfrac{n}{d}\right\rfloor}2\sum_{y=1}^{x}[\gcd(x,y)==1]$。但这是错的，假设 $x=2,y=2$，原本只算了一次，但我们算了两次，所以我们应该化成 $\sum_{x=1}^{\left\lfloor\dfrac{n}{d}\right\rfloor}(2\sum_{y=1}^{x}[\gcd(x,y)==1])-1$。

又可以发现$\sum_{x=1}^{\left\lfloor\dfrac{n}{d}\right\rfloor}(2\sum_{y=1}^{x}[\gcd(x,y)==1])-1=2(\sum_{x=1}^{\left\lfloor\dfrac{n}{d}\right\rfloor}\varphi(x))-1$

所以最后要求出：

$$\large{\sum_{d\in prime}2(\sum_{x=1}^{\left\lfloor\dfrac{n}{d}\right\rfloor}\varphi(x))-1}$$

预期得分100分。

---

## 作者：gb530 (赞：4)

## 第一道紫题题解 好激动 ~~求管理大大通过~~
### 这题让我们求gcd(i,j)为素数，我们来简化一下题目
### 推论一：如果是gcd(i,j)=1怎么做？
### 我相信有些数论基础的人都能想到欧拉函数
### 只要将phi[i]从一到n求和即可
#### 不会的自己百度，推荐两道欧拉函数较简单例题
#### 判断单个欧拉函数
[【SDOI】Longge的问题](https://www.luogu.org/problemnew/show/P2303)
#### 线性预处理欧拉函数
[【SDOI】仪仗队](https://www.luogu.org/problemnew/show/P2158)
### 回到题目，不难发现只要使得d为n的约数切n/d为素数
### 运用推论一，可以求出gcd(i,j)=1的个数，乘上(n/d)即可
### 这是代码(埃氏筛法区间预处理欧拉函数）
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int maxn=1e7+10;
long long n,phi[maxn],pri[maxn],presum[maxn],cnt=1;
long long ans=0;

int main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;i++){
        phi[i]=i;
    }
    for(int i=2;i<=n;i++){
        if(phi[i]==i){
            pri[cnt++]=i;
            for(int j=i;j<=n;j+=i){
                phi[j]=phi[j]/i*(i-1);
            }
        }
    }
    for(int i=1;i<=n;i++){
        presum[i]=presum[i-1]+phi[i];
    }
    for(int i=1;i<cnt;i++){
        ans+=presum[n/pri[i]]*2-1;
    }
    printf("%lld\n",ans);
    return 0;
}
```
### BUT 怎么会T [评测记录](https://www.luogu.org/record/show?rid=12650302)
### 掐指一算 埃氏筛法复杂度为O(nlog(logn))
### n=10^7时，接近10^8,果然T
### 怎么办？线性筛大法好！！！
### AC代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=1e7+10;
long long n,phi[maxn],pri[maxn>>1],p;
long long ans=0;
bool v[maxn];

int main(){
    scanf("%lld",&n);
    for(long long i=2;i<=n;i++){
        if(!v[i]){
            pri[++p]=i;
            phi[i]=i-1;
        }
        for(int j=1;j<=p&&pri[j]*i<=n;j++){
            v[i*pri[j]]=1;
            if(i%pri[j]==0){
                phi[i*pri[j]]=phi[i]*pri[j];
                break;
            }
            phi[i*pri[j]]=phi[i]*(pri[j]-1);
        }
    }
    for(int i=3;i<=n;i++){
        phi[i]+=phi[i-1];
    }
    for(int i=1;i<=p;i++){
        ans+=phi[n/pri[i]];
    }
    printf("%lld\n",ans*2+p);
    return 0;
}
```

---

## 作者：devout (赞：4)

首先我们要知道如果$\gcd(x,y)=1$，$\gcd(kx,ky)=k$

那么这道题询问的是$\gcd(x,y)$为素数的有多少对，我们就可以转化成先看$\gcd(a,b)=1$的有多少倍，然后再算出他的贡献就可以

那么$\gcd(a,b)=1$可以用欧拉函数来解决

那么相应的贡献应该是有多少个$\leq\lfloor\frac{n}{i}\rfloor$的质数，也就是说我们把问题转化成了求

$$2\times\sum_{i=1}^n \phi(i)\cdot val(\lfloor\frac{n}{i}\rfloor)-val(n)$$

$val$就是上面说的那个东西，因为每个$x\neq y$都会被算两遍，但是$x=y$只会算一遍，所以要加回来

然后我们线筛筛出欧拉函数和$val$值就可以了

```cpp
#include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=1e7+5;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n;
int prime[N],tot,sum[N];
int phi[N];
bool isp[N];
ll ans;

int main()
{
    memset(isp,1,sizeof(isp));
    read(n);
    phi[1]=1;
    for(int i=2;i<=n;i++){
        if(isp[i])prime[++tot]=i,phi[i]=i-1;
        sum[i]=tot;
        for(int j=1;j<=tot&&i*prime[j]<=n;j++){
            isp[i*prime[j]]=false;
            if(i%prime[j]==0){
                phi[i*prime[j]]=phi[i]*prime[j];
                break;
            }
            else phi[i*prime[j]]=phi[i]*(prime[j]-1);
        }
    }
    Rep(i,1,n)
        ans+=1ll*phi[i]*sum[n/i];
    printf("%lld\n",ans*2-sum[n]);
    return 0;
}
```

~~话说这题是八倍经验呢qwq~~

---

## 作者：andyli (赞：3)

线性筛出不大于$N$的所有质数，枚举$\gcd (x,y)$（设为$d$），问题转化为求$(x,y)=p$的个数。  
设$x=x',y=y'$，那么有$(x',y')=1$且$1\leq x,y\leq N/d$。  
转化为求$(x,y)=1$且$1\leq x,y\leq n$的个数，答案为$2(\sum\limits_{i=1}^n \varphi(i))-1$。  

代码如下（[快读模板](https://andyli.blog.luogu.org/read-template)）：  
```cpp
const int maxn = 10000005;

bool vis[maxn];
vector<int> primes;
int phi[maxn], r[maxn];
LL S[maxn];
void init(int n)
{
    phi[0] = phi[1] = 1;
    vis[0] = vis[1] = true;
    for (int i = 2; i <= n; i++) {
        if (!vis[i])
            primes.push_back(i), phi[i] = i - 1, r[i] = i;
        for (size_t j = 0; j < primes.size() && i * primes[j] <= n; j++) {
            vis[i * primes[j]] = true;
            r[i * primes[j]] = primes[j];
            phi[i * primes[j]] = phi[i] * (primes[j] - (primes[j] < r[i]));
            if (i % primes[j] == 0)
                break;
        }
    }
}
int main()
{
    int n;
    io.read(n);
    init(n);
    for (int i = 1; i <= n; i++)
        S[i] = S[i - 1] + phi[i];
    LL ans = 0LL;
    for (size_t i = 0; i < primes.size(); i++)
        ans += (S[n / primes[i]] << 1) - 1;
    writeln(ans);
    return 0;
}
```

---

## 作者：玫葵之蝶 (赞：3)

怎么没人发莫比乌斯反演呢？？明明这题是莫比乌斯反演好（shui）题

下面的都是欧拉函数，但是如果题变了：1<=x<=n,1<=y<=m，就不能欧拉做了，这时就要用莫比乌斯反演。

我的[blog](http://blog.csdn.net/stone41123/article/details/77727498)里讲了普通莫比乌斯反演方法（70分），希望各位大佬来踩一踩（雾）

公式：

![](http://img.blog.csdn.net/20170609101041073?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU4NjY0NTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

然后就可以分块大法了！

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#include<cmath>
#include<vector>
#include<queue>
#define ll long long
using namespace std;
int mu[10000001];
int cnt;
bool vis[10000001];
int prime[5000001];
void init(int n){
    mu[1]=1;
    for(int i=2;i<=n;++i){
        if(!vis[i]){
            prime[++cnt]=i;
            mu[i]=-1;
        }
        for(int j=1;j<=cnt&&i*prime[j]<=n;++j){
            int k=i*prime[j];
            vis[k]=1;
            if(i%prime[j]){
                mu[k]=-mu[i];
            }
            else{
                mu[k]=0;
                break;
            }
        }
        mu[i]+=mu[i-1];
    }
}
int main(){
    ll n;
    scanf("%lld",&n);
    init(n);
    ll ans=0;
    for(ll k=1;k<=cnt;++k){
        ll m=n/prime[k];
        ll j;
        for(ll i=1;i<=m;i=j+1){
            ll mul=m/i;
            j=min(m,m/mul);
            ans+=mul*mul*(mu[j]-mu[i-1]);
        }
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：litble (赞：3)

这题嘛，首先我们枚举gcd(x,y)=p的p，那么gcd(x/p,y/p)肯定互质，也就是求在[1,n/p]（向下取整）范围内的欧拉函数的前缀和，再乘2（因为x和y可以交换嘛），最后再处理一下x是一个质数，gcd(x,x)=x满足题意的情况即可。

提醒一下：这题是很卡空间和时间的，质数的数组开个5000000即可，c++党千万不要用bitset(QAQ我之前以为bitset比较省时间，后来就是这该死的bitset害我T了无数次）

代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define ll long long
const int maxn=10000005;
bool is[maxn];
int pri[maxn>>1];ll phi[maxn];
int n,tot;ll ans;
void init(){
    ll i,j,k;
    for(i=2;i<=n;i++){//线性筛求欧拉函数
        if(!is[i]){pri[++tot]=i;phi[i]=i-1;}
        for(j=1;j<=tot;j++){
            k=i*pri[j];if(k>n)break;
            is[k]=1;
            if(i%pri[j])phi[k]=phi[i]*(pri[j]-1);
            else {phi[k]=phi[i]*pri[j];break;}
        }
        phi[i]=phi[i-1]+(phi[i]<<1);//记录前缀和
    }
}
int main()
{
    scanf("%d",&n);
    init();for(int i=1;i<=tot;i++)ans+=phi[n/pri[i]]+1;//求[1,n/pri[i]]范围内的欧拉函数前缀和，再加上gcd(pri[i],pri[i])的情况
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：清尘 (赞：1)

#### 分类讨论

对于满足要求的数对（x,y），有两种情况：

A：x、y 中有一个是质数p，另一个数是p的倍数，此时gcd(x, y)显然为p，满足要求

B：x = p·k1, y = p·k2, p为质数，且k1, k2互质，gcd(x, y)也为质数p

#### 方案计算
先用素数线性筛和[欧拉函数的递推式](https://blog.csdn.net/qq_24451605/article/details/47045135)预处理出1——n的数中的质数和每个数的欧拉函数

对于情况
A：枚举每个质数，注意（x，y）和（y, x）不同，因此要乘上 2，但当x、y相同时只能算一种，因此乘上2再减去1

B：枚举1——n的每个数 i，x = p·k1, y = p·k2（p为质数），以i为k1的情况数有：(满足p·k1<=n且p<=i的质数p的个数) * (i之前与i互质的数的个数（欧拉函数）)，注意也要乘上2

#### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e7 + 5;
int n, tot, k[N], p[N], a[N], s[N];
long long res;
void Pre_work () {
	for (int i = 2; i <= n; ++i) {
		if (!k[i]) p[++tot] = i, a[i] = i - 1;   //如果是质数，与 i 互质的数的个数为 i-1 
		for (int j = 1; j <= tot, p[j] * i <= n; ++j) {
			k[p[j] * i] = 1, a[p[j] * i] = a[i] * (p[j] - (i % p[j] != 0));  //套用欧拉函数递推式 
			if (i % p[j] == 0) break;
		}
	}
	for (int i = 2; i <= n; ++i) s[i] = s[i - 1] + (k[i] == 0);     //预处理质数个数的前缀和 
}
int main() {
	scanf ("%d", &n);
	Pre_work ();
	for (int i = 2; i <= n; ++i) res += s[n / i] * (a[i] - 1) << 1;   //情况 B  
	for (int i = 1; i <= tot and p[i] <= n; ++i) res += ((n / p[i]) << 1) - 1; //情况 A 
	printf ("%lld\n", res);
	return 0;
} 
```

---

## 作者：decoqwq (赞：1)

先来说一下莫比乌斯函数

我们定义$\mu(1)= 1$，当$i=\Pi_{k=1}^K p_k(p_k\in prime)$的时候，$\mu(i)=(-1)^k$，其他情况下$\mu(i)=0$

然后我们来说下这个函数的性质

首先，这是个积性函数，就是说当$gcd(i,j)=1$时，$\mu(i\times j)=\mu(i)\times \mu(j)$

并且可以得到$\sum_{d|n} \mu(d)=1(n=1)$，这个公式在后面会有很大的用处



接下来说莫比乌斯反演

我们定义$F(n)=\sum_{d|n}f(d)$

~~那么显而易见~~$f(n)=\sum_{d| n}\mu(\frac{n}{d})F(d)$

当然，也可以得到$f(n)=\sum_{d| n}\mu(d)F(\frac{n}{d})$

博主不会证明，所以证明就鸽了

再说这道题

这道题本来是用欧拉函数的，可是我想练一下莫比乌斯反演qwq

那么来开心的推式子吧：

题目要求的$ans=\sum_{k=1}^K \sum_{i=1}^n \sum_{j=1}^n (gcd(i,j)=p_i)$，其中$p_i$是质数

$i,j$上界同除以$p_i$，得到$ans=\sum_{k=1}^K\sum_{i=1}^{\lfloor\frac{n}{p_i}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{p_i}\rfloor}(gcd(i,j)=1)$

然后我们看到右边那个$gcd(i,j)=1$，想一想，什么东西的和等于$1$啊qwq？

当然是之前提到的公式$\sum_{d|n}\mu(d)=1(n=1)$啦！

我们把公式里的$n$换成$gcd(i,j)$，带入原式，即$ans=\sum_{k=1}^K\sum_{i=1}^{\lfloor\frac{n}{p_i}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{p_i}\rfloor}\sum_{d|gcd(i,j)}\mu(d)$

我们再来想一想，$d|gcd(i,j)$是不是说明$d|i$并且$d|j$？

则$ans=\sum_{k=1}^K\sum_{d}\mu(d)\sum_{d|i}^{\lfloor\frac{n}{p_i}\rfloor}\sum_{d|j}^{\lfloor\frac{n}{p_i}\rfloor}$

然后发现我们枚举$d$的话，右边两个$\sum$是不是正好就等于$\lfloor\frac{\frac{n}{p}}{d}\rfloor ^2$？

然后把$p$移下来，得到$\lfloor\frac{n}{dp}\rfloor^2$

所以$ans=\sum_{k=1}^K\lfloor\frac{n}{dp}\rfloor^2\sum_d\mu(d)$

$dp$看着就烦，我们把它换掉

设$T=dp$，则

$ans=\sum_{T=1}^n\lfloor\frac{n}{T}\rfloor^2\sum_{t|T}\mu(\frac{T}{t})$
$\text{(这里的t相当于原来的p)}$

左边的我们可以发现用数论分块是比较好的

而右边的，由于我们数论分块后要快速得到$\sum_{T=l}^r\sum_{t|T}\mu(\frac{T}{t})$，我们在预处理的时候统计个前缀和就好了

上代码qwq

```cpp
#include <bits/stdc++.h>
using namespace std;
int prime[4000020],cnt,mu[10000010],n,vis[10000010];
long long sum[10000010];
void pre()
{
	mu[1]=1;
	for(int i=2;i<=n;i++)
	{
		if(!vis[i])
		{
			prime[++cnt]=i;
			mu[i]=-1;
		}
		for(int j=1;j<=cnt,i*prime[j]<=n;j++)
		{
			vis[i*prime[j]]=1;
			if(i%prime[j]==0)
			{
				break;
			}
			mu[i*prime[j]]=-mu[i];
		}
	}
	for(int i=1;i<=cnt;i++)
	{
		for(int j=1;j*prime[i]<=n;j++)
		{
			sum[j*prime[i]]+=mu[j];
		}
	}
	for(int i=2;i<=n;i++)
	{
		sum[i]+=sum[i-1];
	}
}
int main()
{
	cin>>n;
	pre();
	long long ans=0;
	for(int t=1;t<=n;t++)
	{
		int l=t,r=(n/(n/l));
		t=r;
		ans+=(sum[r]-sum[l-1])*(n/l)*(n/l);
	}
	cout<<ans;
}
```

---

## 作者：_ctz (赞：1)

[$My\ blog$](https://ctz45562.github.io/2019/03/25/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P2568-%E3%80%90GCD%E3%80%91/)

[传送门](https://www.luogu.org/problemnew/show/P2568)

以此题题解纪念我第一道独立思考出的数论题$QwQ$。

首先质数肯定是要筛的。

考虑对于某一个质数$p$，满足$gcd(i,j)=p$的$(i,j)$有多少对：

显然$p|i$且 $p|j$，则设$i=ap$，$j=bp$。

即$gcd(ap,bp)=p$

把$p$提出来：$gcd(a,b)*p=p$

约去$p$：$gcd(a,b)=1$，也就是$a$、$b$互质

假设$a>b$，问题就变成了求$a$所有取值的欧拉函数的和。$ap$不能超过$n$，则$1\le a\le \left\lfloor\dfrac{n}{p}\right\rfloor$。直接预处理出欧拉函数和前缀和。其中$a,b$可互换，答案乘$2$。当$a=1,b=1$时互换是同一种情况，答案减去$cnt$（$cnt$为质数个数）。

综上，$ans=\left(\sum\limits_{i=1}^{cnt}\sum\limits_{j=1}^{\left\lfloor\frac{n}{prime[i]}\right\rfloor}\phi(j)\right)-cnt$

用的欧拉筛，时间复杂度$O(n)$。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 10000005
#define inf 0x3f3f3f3f

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
long long sum[maxn],ans;
int phi[maxn],prime[maxn>>2],cnt;
bool is[maxn];
int main(){
	int n=read();
	sum[1]=phi[1]=1;
	for(register int i=2;i<=n;++i){
		if(!is[i])prime[++cnt]=i,phi[i]=i-1;
		sum[i]=sum[i-1]+(long long)phi[i];
		for(register int j=1;j<=cnt&&prime[j]*i<=n;++j){
			is[prime[j]*i]=1;
			if(i%prime[j]==0){
				phi[i*prime[j]]=phi[i]*prime[j];
				break;
			}
			phi[i*prime[j]]=phi[i]*(prime[j]-1);
		}
	}	
	for(register int i=1;i<=cnt;++i)
		ans+=sum[n/prime[i]];
	printf("%lld\n",ans*2-(long long)cnt);
}

```



---

## 作者：JustinRochester (赞：1)

本来已经 AFO 了，今天上洛谷发现这题被推荐了就顺手切了......

---

**【分析】**
--

上来就盘它，显然，题目要求的是

$\sum_{i=1}^n\sum_{j=1}^n [gcd(i,j)\in prime]$

我们考虑到有一个关系十分显然：

$gcd(i,j)\leq n\quad (i,j\leq n)$

因此我们考虑枚举所有质数：

定义 $prime$ 为小于等于 $n$ 的素数集合

$\therefore$ 原式 $=\sum_{p\in prime}\sum_{i=1}^n\sum_{j=1}^n[gcd(i,j)==p]$

介于对于 $\forall i,j\leq n,gcd(i,j)==p$ 

一定有 $i,j\leq \lfloor{n\over p}\rfloor\times p$

$\therefore$ 原式

$=\sum_{p\in prime}\sum_{i=1}^{\lfloor{n\over p}\rfloor\times p}\sum_{j=1}^{\lfloor{n\over p}\rfloor\times p}[gcd(i,j)==p]$

$=\sum_{p\in prime}\quad \sum_{i=1}^{\lfloor{n\over p}\rfloor}\sum_{j=1}^{\lfloor{n\over p}\rfloor}[gcd(i,j)==1]$

$\because$ 由[仪仗队](https://www.luogu.org/problemnew/show/P2158)这题的图像显然易得

$\sum_{i=1}^n\sum_{j=1}^{i-1}[gcd(i,j)==1]=\sum_{i=1}^n\sum_{j=i+1}^n[gcd(i,j)==1]$

又 $\because$ 根据定义

$\varphi(n)=\sum_{i=1}^{n-1}[gcd(i,n)==1]$

> 按我这边学的 $\varphi(1)=0$ ，有的教材是为 $\varphi(1)=1$ 的，应该是不影响解题的，主要参考思路，剩下的那些小细节应该可以自行解决

$\therefore \sum_{i=1}^n\sum_{j=1}^n[gcd(i,j)==1]$

$=\sum_{i=1}^n\sum_{j=1}^{i-1}[gcd(i,j)==1]+\sum_{i=1}^n\sum_{j=i}^i[gcd(i,j)==1]+\sum_{i=1}^n\sum_{j=i+1}^n[gcd(i,j)==1]$

$=\sum_{i=1}^n\varphi(n)+\sum_{i=1}^n[gcd(i,i)==1]+\sum_{i=1}^n\varphi(n)$

$=2\sum_{i=1}^n\varphi(n)+\sum_{i=1}^n[i==1]$

$=2\sum_{i=1}^n\varphi(n)+1$

我们令 $Add(n)=\sum_{i=1}^n\varphi(n)$

$\therefore \sum_{i=1}^n\sum_{j=1}^n[gcd(i,j)==1]=2Add(n)+1$

因此，原式可以进行化简：

原式

$=\sum_{p\in prime}\quad \sum_{i=1}^{\lfloor{n\over p}\rfloor}\sum_{j=1}^{\lfloor{n\over p}\rfloor}[gcd(i,j)==1]$

$=\sum_{p\in prime}\quad [2Add(\lfloor{n\over p}\rfloor)+1]$ (这边的括号不是计数的意思)

$=2\sum_{p\in prime} Add(\lfloor{n\over p}\rfloor)+Card(prime)$

>按我那一版的数学必修一中集合那一章，对于集合 $A$ ， $Card(A)$ 表示 $A$ 的元素个数

那么这题就没问题了，$O(n)$ 的线筛中一边筛素数，一边算欧拉函数，再一边用前缀和维护 $Add_i$ 数组

最后一个 for 循环暴力统计，算 $\sum_{p\in prime} Add(\lfloor{n\over p}\rfloor)$

翻两倍加一个素数个数即可。

$\because Card(prime)\leq n$

$\therefore$ for 循环复杂度为 $o(n)$

总复杂度 $O(n)+o(n)=O(n)$

---

**【代码】**
--

那本蒟蒻就放 ~~我那码风极丑的~~ 代码了

```cpp
#include<cstdio>
using namespace std;
#define f(a,b,c,d) for(register int a=b,c=d;a<=c;a++)
const int MAXN=1e7+1;
typedef long long int ar[MAXN];
inline char gc(){
	static char s[10]={0},*p1=s,*p2=s;
	return (p1==p2)&&(p2=(p1=s)+fread(s,1,10,stdin),p1==p2)?EOF:*(p1++);
}
inline int read(){
	register int ans=0;register char c=gc();while(c<48||c>57) c=gc();
	while(c>=48&&c<=57) ans=(ans<<3)+(ans<<1)+(c^48),c=gc();
	return ans;
}
long long int Cnt_prime,Ans;
ar Phi,Prime,Fc,Add;
inline void select(int Lim){
	f(i,2,I,Lim){
		if(!Fc[i]){
			Fc[i]=Prime[++Cnt_prime]=i;
			Phi[i]=i-1;
		}
		f(j,1,J,Cnt_prime)
			if(Prime[j]>Fc[i]) break;
			else{
				int K=i*Prime[j];
				if(K>Lim) break;
				else Fc[K]=Prime[j];
				Phi[K]=Phi[i]*Prime[j]-((i%Prime[j])?Phi[i]:0);
			}
		Add[i]=Phi[i]+Add[i-1];
	}
}
int main(){
	int N=read();
	select(N);
	f(i,1,I,Cnt_prime) Ans+=Add[N/Prime[i]];
	Ans=(Ans<<1)+Cnt_prime;
	printf("%lld",Ans);
	return 0;
}
```

---

## 作者：attack (赞：1)

一开以为要用zap那题的思路暴力求，但是化到一半发现会做了qwq。

把每个素数拆开来考虑

设$p_i$为第$i$个素数

我们要求的是

$$\sum_{i = 1}^n \sum_{j = 1}^n [gcd(i, j) = p_i]$$

$$ = \sum_{i = 1}^{\frac{n}{p_i}} \sum_{j = 1}^{\frac{n}{p_i}} [gcd(i, j) = 1]$$

根据定理

$$\sum_{i = 1}^n \sum_{j = 1}^n [gcd(i, j) = 1] = 2\phi(i) - 1$$

而且$10^7$以内的质数只有大约$6 * 10^5$个

直接对$\phi$做前缀和然后暴力算就行了

```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#include<cmath>
#define LL long long 
#define rg register 
//#define int long long 
using namespace std;
const int MAXN = 1e7 + 10, mod = 1e9 + 7;
inline int read() {
    char c = getchar(); int x = 0, f = 1;
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}
int prime[MAXN], vis[MAXN], tot;
LL phi[MAXN];
void GetPhi(int N) {
	vis[1] = phi[1] = 1;
	for(rg int i = 2; i <= N; i++) {
		if(!vis[i]) prime[++tot] = i, phi[i] = i - 1;
		for(rg int j = 1; j <= tot && i * prime[j] <= N; j++) {
			vis[i * prime[j]] = 1;
			if(!(i % prime[j])) {phi[i * prime[j]] = phi[i] * prime[j]; break;}
			phi[i * prime[j]] = phi[i] * phi[prime[j]];
		}
	}
	for(rg int i = 2; i <= N; i++) phi[i] += phi[i - 1];
}
inline LL F(int N) {
	return (phi[N] << 1) - 1;
}
int main() {
	GetPhi(1e7 + 5);
	int N = read();
	LL ans = 0;
	for(rg int i = 1; i <= tot && prime[i] <= N; i++) 
		ans += F(N / prime[i]);
	printf("%lld\n", ans);
    return 0;
}
/*

*/
```

---

## 作者：aiyougege (赞：1)

这个题和[bzoj 2820](http://www.lydsy.com/JudgeOnline/problem.php?id=2820)比较像,但是比bzoj 2820 好做，所以用bzoj 2820的方法能通过

这个题令n=m

那么可以这么做

![233](http://images2017.cnblogs.com/blog/1119251/201712/1119251-20171217130258811-2043757723.jpg )

但是需要维护$F(k)$的前缀和，所以会MLE

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define N 10000005
#define ll long long 
using namespace std;
 
bool not_prime[N];
int prime[1000005];
ll sum[N];
int mu[N];
int tot;
 
void Mu(int n){
    mu[1]=1;
    for(int i=2;i<=n;i++){
        if(!not_prime[i]){
            prime[++tot]=i;
            mu[i]=-1;
        }
        for(int j=1;prime[j]*i<=n;j++){
            not_prime[prime[j]*i]=1;
            if(i%prime[j]==0){
                mu[prime[j]*i]=0;
                break;
            }
            mu[prime[j]*i]=-mu[i];
        }
    }
    for(int i=1;i<=tot;++i)
        for(int j=1;j*prime[i]<=n;++j)
            sum[j*prime[i]]+=(ll)mu[j];
    for(int i=1;i<=n;++i)
        sum[i]+=(ll)sum[i-1];
}
 
ll ans(int n,int m){
    if(n>m)swap(n,m);
    int last,i;ll re=0;
    for(i=1;i<=n;i=last+1){
        last=min(n/(n/i),m/(m/i));
        re+=(ll)(n/i)*(m/i)*(sum[last]-sum[i-1]);
    }   
    return re;
}
 
int main(){
    Mu(N-5);
    int T;
    int a,b;
        scanf("%d",&a);
        ll Ans=ans(a,a);
        printf("%lld\n",Ans);
    return 0;
}
```
所以就可以按照图片中倒数第三个式子的做法，枚举素数，按照莫比乌斯反演的做法去做，当然在bzoj 2820用这个方法是会超时的

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define N 10000005
#define ll long long 
using namespace std;
 
bool not_prime[N];
int prime[1000005];
ll mu[N];
int tot;
 
void Mu(int n){
    mu[1]=1;
    for(int i=2;i<=n;i++){
        if(!not_prime[i]){
            prime[++tot]=i;
            mu[i]=-1;
        }
        for(int j=1;prime[j]*i<=n;j++){
            not_prime[prime[j]*i]=1;
            if(i%prime[j]==0){
                mu[prime[j]*i]=0;
                break;
            }
            mu[prime[j]*i]=-mu[i];
        }
    }
    for(int i=1;i<=n;++i)
        mu[i]+=(ll)mu[i-1];
}
 
ll ans(int n,int m){
    if(n>m)swap(n,m);
    int last,i;ll re=0;
    for(i=1;i<=n;i=last+1){
        last=min(n/(n/i),m/(m/i));
        re+=(ll)(n/i)*(m/i)*(mu[last]-mu[i-1]);
    }   
    return re;
}
 
int main(){
    int a;ll Ans=0;
    scanf("%d",&a);
    Mu(a);
    for(int i=1;i<=tot;++i)
        if(prime[tot]>a)break;
        else Ans+=ans(a/prime[i],a/prime[i]);
    printf("%lld\n",Ans);
    return 0;
}
```

---

## 作者：huangzirui (赞：0)

题意：

给定 $n$ ， 求

$$\sum\limits^n_{x=1}\sum\limits^m_{y=1} \text{[ gcd(x,y) 为素数 ]}$$

---

考虑每一个素数对答案的贡献。

不妨先考虑素数 $P$ 。

对于 $x$ 和 $y$，若 $\text{gcd}(x,y)=1$ ，那么就有 $\text{gcd}(Px,Py)=P$ 。

不妨使 $x\leq y$，那么对于每个 $x$ ，$y$ 就有 $\varphi(x)$ 种取值使得 $\text{gcd}(x,y)=1$ 。

于是对于当前的素数 $P$ ，答案就是：

$$\sum\limits_{Px\leq n}{\varphi(x)}$$

(注意到当 $x \not= y$ 时，$(x,y)$ 和 $(y,x)$ 需要重复算，此处需要特殊处理。)

于是预处理前缀和后枚举素数即可。对于素数和欧拉函数的处理使用线性筛，总复杂度 $O(n)$ 。

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline int read(){
	char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int maxn=10000010;
int i,j,k,n,m;
int prime[maxn],is_prime[maxn],num,phi[maxn];
ll Sum[maxn];
int main(){
	cin>>n;
	for(i=2;i<=n;i++)is_prime[i]=1;
	phi[1]=1;
	for(i=2;i<=n;i++){
		if(is_prime[i]){
			prime[++num]=i;
			phi[i]=i-1;
		}
		for(j=1;j<=num && i*prime[j]<=n;j++){
			is_prime[i*prime[j]]=0;
			phi[i*prime[j]]=phi[i]*(prime[j]-1); 
			if(i%prime[j]==0){
				phi[i*prime[j]]=phi[i]*prime[j];
				break;
			}
		}
	}
	ll ans=0;
	for(i=1;i<=n;i++)Sum[i]=phi[i]+Sum[i-1];
	for(i=1;i<=num;i++){
		int Up=n/prime[i];
		ans+=(Sum[Up]-1)*2+1;
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：陈学威 (赞：0)



这道题一看就是裸的莫比乌斯反演，



因为公式实在太多



具体可以看我博客
此题跟[YY的GCD](https://www.luogu.org/problemnew/show/P2257)是一样的

这道题的内存有点恶意



所以要开小一点

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=10000010;
short mu[maxn];
int prime[maxn/10],cnt,f[maxn],sum[maxn],n,m;
bool vis[maxn]; 
inline void mobi()
{
	mu[1]=1;
	for (int i=2; i<=maxn-10; i++)
	  {
	  	if (!vis[i]) prime[++cnt]=i,mu[i]=-1;
	  	for (int j=1; j<=cnt&&i*prime[j]<=maxn-10; j++)
	      {
	      	vis[i*prime[j]]=1;
	      	if (i%prime[j]==0) break;
	      	mu[i*prime[j]]=-mu[i];
	      }
	  }
	for (int i=1; i<=cnt; i++)
	  for (int j=1; prime[i]*j<=maxn-10; j++)
	    f[j*prime[i]]+=mu[j];
	for (int i=1; i<=maxn-10; i++)
	  sum[i]+=sum[i-1]+f[i];
}
inline ll solve(int x,int y)
{
	ll ans=0;
	for (int l=1,r; l<=x; l=r+1)
	  {
	  	r=min(x/(x/l),y/(y/l));
	  	ans+=(ll)(sum[r]-sum[l-1])*(ll)(x/l)*(ll)(y/l);
	  }
	return ans;
}
int main()
{
	mobi();
	scanf("%d",&n);
	m=n;
	printf("%lld\n",solve(n,m));
}
```

---

## 作者：Wolfycz (赞：0)

大佬们都是欧拉函数吗。。。

如果改$1\leqslant x\leqslant n,1\leqslant y\leqslant m$那就不能用欧拉函数了。

我分享一下[莫比乌斯反演](https://www.cnblogs.com/Wolfycz/p/9482194.html)。根据bzoj上的题写的博客，所以代码要稍加修改

不过洛谷上总是T让我很迷，必须要开O(2)才能过，可能是预处理f数组的锅

然后我稍微扯一下f的线性求法：

设$T=\prod\limits_{i=1}^k P_i^{k_i}$，观察发现
* 设 $Max(x_i)\geqslant3(1\leqslant i\leqslant k)$，时$f(T)=0$
* 存在两个$x_i,x_j$等于2时，$f(T)=0$
* 只有一个$x_i$等于1时，$f(T)=(-1)^{k-1}$
* 指数全为1时，$f(T)=k\times (-1)^{k-1}$

由于本人比较菜，因此不会写这种线筛，如果有大佬写出来了可以联系我

贴上代码(开了氧气优化才能过)：
``` cpp
/*program from Wolfycz*/
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define inf 0x7f7f7f7f
using namespace std;
typedef long long ll;
typedef unsigned int ui;
typedef unsigned long long ull;
inline int read(){
	int x=0,f=1;char ch=getchar();
	for (;ch<'0'||ch>'9';ch=getchar())	if (ch=='-')    f=-1;
	for (;ch>='0'&&ch<='9';ch=getchar())	x=(x<<1)+(x<<3)+ch-'0';
	return x*f;
}
inline void print(int x){
	if (x>=10)	print(x/10);
	putchar(x%10+'0');
}
const int N=1e7,M=1e6;
int prime[M+10],miu[N+10],f[N+10],tot;
bool inprime[N+10];
void prepare(){
	miu[1]=1;
	for (int i=2;i<=N;i++){
		if (!inprime[i])	prime[++tot]=i,miu[i]=-1;
		for (int j=1;j<=tot&&i*prime[j]<=N;j++){
			inprime[i*prime[j]]=1;
			if (i%prime[j]==0){
				miu[i*prime[j]]=0;
				break;
			}
			miu[i*prime[j]]=-miu[i];
		}
	}
	for (int i=1;i<=tot;i++)
		for (int j=1;prime[i]*j<=N;j++)
			f[prime[i]*j]+=miu[j];
	for (int i=1;i<=N;i++)	f[i]+=f[i-1];
}
int main(){
	prepare();
	int n=read(),pos;
	ll Ans=0;
	for (int T=1;T<=n;T=pos+1){
		pos=n/(n/T);
		Ans+=1ll*(f[pos]-f[T-1])*(n/T)*(n/T);
	}
	printf("%lld\n",Ans);
	return 0;
}
```

---


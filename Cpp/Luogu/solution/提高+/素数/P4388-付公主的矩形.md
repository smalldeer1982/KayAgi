# 付公主的矩形

## 题目背景

付公主月考炸了，感到非常郁闷。

## 题目描述

为了排解心中的怒气，她造了大量的稻草人来发泄。每天付公主都会把一些稻草人摆成一个 $ R*C $ 的矩形，矩形的每个方格上都有一个稻草人。然后她站在这个矩形的左上角，向矩形的右下角射箭。付公主的箭术过人，她能穿透任意多的稻草人。弓箭经过的方格上的稻草人难逃厄运，报废掉了。看着被毁坏的稻草人，付公主开心了一些。

但是制造稻草人需要大量的金钱，所以付公主不希望坏掉太多的稻草人，所以她每天都选择毁坏掉 $ N $ 个稻草人。付公主还是个喜新厌旧的人，她希望每天能看到一种不同的稻草人摆放矩形。矩形是可以旋转的，即 $ R\times C $ 和 $ C\times R $ 等价。她毫不费力地算出了摆放方案数，于是她决定刁难你一下。不甘示弱的你决定写个程序计算这个数来提交付公主的答卷。

## 说明/提示

样例解释：
![](https://cdn.luogu.com.cn/upload/pic/16262.png)

对于 $40\%$ 的数据，$1 \le N \le 10^4$。

对于 $100\%$ 的数据，$1 \le N \le 10^6$。


## 样例 #1

### 输入

```
4```

### 输出

```
4```

# 题解

## 作者：Elegia (赞：15)

逆向思考，考虑对于一组 $(R, C)$ 其需要穿过的方格数量 $N$ 。

发现问题在 $\gcd(r,c) = 1$ 时不会**中途穿过某个点**，故每穿过一条边的时候恰多经过了一个方格。此时穿过方格数有 $n = r + c - 1$ 个。

可以得到一般情况，$N = R + C - \gcd(R, C)$ 。我们要对这一方程的解计数。

注意到此时每一个数两边都必须是 $\gcd(R, C)$ 的因数，方程变为

$$\frac{N}{\gcd(R, C)} = r + c - 1$$

的解。

记 $n = \frac{N}{\gcd{R, C}}$ ，由于此时 $\gcd(r, c) = 1$ ，根据欧几里得算法我们可以知道

$$ \gcd(n + 1, r) = \gcd(n + 1 - r, r) = \gcd(r, c) =1 $$

即 $n+1$ 与 $r$ 互素，对此计数，这恰是欧拉函数的定义。

答案即为

$$ \sum_{n|N} \varphi(n + 1) $$

等等，因为要对对称的去重，所以再对这个结果 +1 除以 2 。因为 $(N, N)$ 只被计算了一次。

通过欧拉筛法，此题可以以 $\Theta(n)$ 的复杂度被解决。

```cpp
#include <cstdio>

using namespace std;

const int N = 1000010;

int n, pc, ans;

bool vis[N];
int p[N], phi[N];

int main() {
    scanf("%d", &n);
    for (int x = 2; x <= n + 1; ++x) {
        if (!vis[x]) {
            p[++pc] = x;
            phi[x] = x - 1;
        }
        if (n % (x - 1) == 0)
            ans += phi[x];
        for (int i = 1; x * p[i] <= n + 1; ++i) {
            vis[x * p[i]] = true;
            if (x % p[i] == 0) {
                phi[x * p[i]] = phi[x] * p[i];
                break;
            } else {
                phi[x * p[i]] = phi[x] * phi[p[i]];
            }
        }
    }
    printf("%d\n", (ans + 1) / 2);
    return 0;
}
```

---

## 作者：y2823774827y (赞：7)

[更好的阅读体验](https://www.cnblogs.com/y2823774827y/p/10213332.html)

## 前置芝士
$gcd$与欧拉函数

要求对其应用于性质比较熟，否则建议左转百度

## 思路

有$n×m$的矩阵，题目要求对角线经过的格子有$N$个，
设函数$f(x,y)$为矩阵$(x,y)$对角线经过的格子

设$gcd(n,m)=1$，对角线在矩形中不会经过任意一个格点，$f(n,m)=n+m-1$

那$gcd(n,m)!=1$呢？将这个矩阵拆除$gcd(n,m)$个相同的矩阵

其中$gcd(n',m')=1$，则$\dfrac{n}{n'}=\dfrac{m}{m'}$

所以我们能推倒出公式

$f(n,m)=\dfrac{n}{n'}f(n',m')$

$~~~~~~~~~~~~~=\dfrac{n}{n'}×(n'+m'-1)$

$~~~~~~~~~~~~~=\dfrac{n×n'}{n'}+\dfrac{m×m'}{m'}-gcd(n,m)$

$~~~~~~~~~~~~~=n+m-gcd(n,m)$

则我们要求$(n,m)$的对数使得 $n+m-gcd(n,m)=N$

设$i=gcd(n,m)$

$n+m-gcd(n,m)=N $

$\Rightarrow \dfrac{n}{i}+\dfrac{m}{i}-1=\dfrac{N}{i}$

$\Rightarrow \dfrac{n}{i}+\dfrac{m}{i}=\dfrac{N}{i}+1$

我们枚举$gcd(n,m)$也就是$i$，那我们怎么求呢？

欧拉函数有一性质$\varphi(N)$，$N>2$时，$\varphi(N)$为偶数

跟这个推倒过程差不多，易得出$nun=\varphi(\dfrac{N}{i}+1)$

跑得比较慢(200ms)

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL maxn=1000007;
LL n,tot,ans;
LL phi[maxn],pim[maxn>>1];
inline void First(){
    for(LL i=2;i<=n+1;i++){
        if(!phi[i])
            phi[i]=i-1,
            pim[++tot]=i;
        for(LL j=1;j<=tot&&pim[j]*i<maxn;j++)
        	if(i%pim[j]==0){
                phi[i*pim[j]]=phi[i]*pim[j];
                break;
            }else
                phi[i*pim[j]]=phi[i]*(pim[j]-1);
    }
}
int main () {
    scanf("%lld",&n);
    First();
    for(LL i=1;i<=n;i++)
        if(n%i==0)
            ans+=phi[n/i+1];
    printf("%lld",ans+1>>1);
    return 0;
}
```

剪一下枝(100ms)

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
inline int Read(){
    int x=0,f=1; char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-') f=-1; c=getchar();
    }
    while(c>='0'&&c<='9')
        x=(x<<3)+(x<<1)+c-'0',c=getchar();
    return x*f;
}
const LL maxn=1000007;
int n,tot;
int phi[maxn],pim[maxn>>1];
LL ans;
inline void First(){
    for(int i=2;i<=n+1;i++){
        if(!phi[i])
            phi[i]=i-1,
            pim[++tot]=i;
        for(int j=1;j<=tot&&pim[j]*i<maxn;j++)
        	if(i%pim[j]==0){
                phi[i*pim[j]]=phi[i]*pim[j];
                break;
            }else
                phi[i*pim[j]]=phi[i]*(pim[j]-1);
    }
}
int main () {
    n=Read();
    First();
    for(int i=1;i*i<=n;i++)
        if(n%i==0)
            if(i*i==n)
                ans+=phi[i+1];
            else
                ans+=phi[i+1]+phi[n/i+1];
    printf("%lld",ans+1>>1);
    return 0;
}
```

---

## 作者：da32s1da (赞：7)

![](https://cdn.luogu.com.cn/upload/pic/16262.png)

我们观察图片可知，若$gcd(i,n)=i$，为一种方案。

通过~~聪明的大脑及~~$Microsoft$ $Office$ $PowerPoint$ $2003$ 的帮助 可知，若$gcd(i,n-i+1)=1$，那么也为一种方案。

其次，若$gcd(i,n)=i$，那么摧毁$n$个稻草人要加上摧毁$n/i$个稻草人的方案。

~~严格的论证请大佬们~~，放下代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,ans;
int main() {
    cin>>n;
    for(int i=1;i<=n/2;i++)
    if(__gcd(i,n)==i){
        ans++;   //gcd(i,n)=i，答案+1
        for(int j=2;j<=(n/i)/2;j++)
        if(__gcd(j,(n/i)-j+1)==1) ans++;
        //不太好理解，可以参照ppt画图
    }
    cout<<ans+1; //gcd(n,n)=n，方案+1
    return 0;
}
```

---

## 作者：Link_Cut_Y (赞：3)

实际上，这道题并不难，手玩一下就可以了，顺便拿到了这道题的 [**rk1**](https://www.luogu.com.cn/record/list?pid=P4388&orderBy=1&status=&page=1)

我们很容易看出来，如果一个矩形的长和宽的最大公约数 $d ≠ 1$ ，那么直线穿过的正方形就会呈现许多的小长方形，我们就可以用许多小长方形包含的正方形的个数乘以$d$来求解（~~哇啊啊啊，可以打表拉~~

我们可以清楚的得到，如果有矩形的两边长为 $r, c$ 且 $(r, c) = 1$，那么这个矩形对角线连线能穿过的矩形就是 $r + c - 1$（已经有巨神解释过了

所以，问题就转化成：已知 $n$，求 $r, c$ ，使 $(r + c - 1) | n$ 且 $(r, c) = 1$

好啦，看到这里，你就已经可以AC这道题拉

```
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>

using namespace std;

int n, res;

int gcd(int a, int b)
{
	return !b ? a : gcd(b, a % b);
}

int main()
{
	cin >> n;
		
	for (int i = 1; i <= n / i; i ++ )
		if (n % i == 0)
		{

			int d = i;
			for (int r = 1; r <= (d + 1) / 2; r ++ )
			{
				int c = d + 1 - r;
				if (gcd(r, c) == 1)
					res ++ ;
			}
			if (i * i == n) continue;
			d = n / i;
			for (int r = 1; r <= (d + 1) / 2; r ++ )
			{
				int c = d + 1 - r;
				if (gcd(r, c) == 1)
					res ++ ;
			}
		}
		
	cout << res << endl;
	
	return 0;
}
```

小蒟蒻不会算复杂度（应该是 $O(n\log n)$ 吧. . .

~~不行不行，好暴力呀，我不要这么做~~

对于条件 $(r + c - 1) | n$ ，只要枚举一下 $n$ 的约数 $d$ 即可。

对于 $(r, c) = 1$ ，我们只要枚举一下 $d + 1$ 欧拉函数即可。

由于矩形旋转算同一种情况，所以将欧拉函数除以二。

好啦，代码出来啦！！

```
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>

using namespace std;

const int N = 1e6 + 10;
int n, res;
int phi[N], primes[N], cnt;
bool st[N];

void get_euler(int n)
{
	phi[1] = 1;
	for (int i = 2; i <= n; i ++ )
	{
		if (!st[i]) phi[i] = i - 1, primes[ ++ cnt] = i;
		
		for (int j = 1; i * primes[j] <= n; j ++ )
		{
			st[i * primes[j]] = true;
			if (i % primes[j] == 0)
			{
				phi[i * primes[j]] = phi[i] * primes[j];
				break;
			}
			phi[i * primes[j]] = phi[i] * (primes[j] - 1);
		}
	}
}

int main()
{
	cin >> n;
		
	get_euler(n + 1);
	
	for (int i = 1; i <= n / i; i ++ )
		if (n % i == 0)
			res = res + phi[i + 1] / 2 + (i * i == n ? 0 : phi[n / i + 1] / 2);
	
	cout << res + 1 << endl;
	
	return 0;
}
```

时间复杂度为 $O(n + \sqrt{n})$ 。

完结撒花✿✿ヽ(°▽°)ノ✿（希望管理员大大通过吧）

---

## 作者：LXcjh4998 (赞：2)

[Luogu 链接](https://www.luogu.com.cn/problem/P4388)
# 题意
求有多少组无序整数对 $(R,C)$，使得以 $R$ 和 $C$ 为长和宽作一个矩形（该矩形由 $R\times C$ 个单位正方形组成），并连接该矩形的一条对角线，恰好穿过 $n$（$1\le n\le10^6$）个单位正方形。
# 思路
我们先计算当 $\gcd(R,C)=1$ 时，其穿过了多少正方形。

以下为图解：

![](https://cdn.luogu.com.cn/upload/image_hosting/zek5obf5.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/x2hzdhws.png)![](https://cdn.luogu.com.cn/upload/image_hosting/vt14n987.png)

显然，对角线与每条红线有且只有一个交点，而每个交点都能唯一确定一个正方形（图中红色的正方形），再减去右下角被重复计算的一个正方形，可以得到对角线穿过了 $R+C-1$ 个正方形。

而我们很容易就能推广至 $\gcd(R,C)\neq 1$ 的情况。此时对角线穿过了 $R+C-\gcd(R,C)$ 个正方形（因为有 $\gcd(R,C)$ 个正方形会被重复计算）。

因此，问题就变为求满足 $R+C-\gcd(R,C)=n$ 的无序整数对 $(R,C)$ 的数量。

不妨令 $R'=\dfrac{R}{\gcd(R,C)},C'=\dfrac{C}{\gcd(R,C)},n'=\dfrac{n}{\gcd(R,C)}$，可得 $R'+C'=n'+1$。

而 $\gcd(R',C')=\gcd(R',n'+1-R')=\gcd(R',n+1)=1$，因此当 $\gcd(R,C)$ 确定时（不考虑无序的条件），其方案数为 $\varphi(n'+1)$。

因此，总方案数 $\displaystyle ans=\sum_{n'\mid n}\varphi(n'+1)$。

但是题目要求的是无序，所以真正的答案是 $\dfrac{ans+1}{2}$（$(n,n)$ 只会被计算一次，因此要先加 $1$ 再除以 $2$）。

既可以用线性筛，也可以直接计算欧拉函数，这里采用线性筛的方法。
# 程序
[AC 记录](https://www.luogu.com.cn/record/210320476)
```cpp
#include<cstdlib>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<queue>
#include<cstdio>
#include<iostream>
#include<vector>
#include<map>
#include<cmath>
#include<iomanip>
#include<string>
#include<stack>
#define ll long long
#define ull unsigned long long
#define INF 0x3f3f3f3f
#define ls rt<<1
#define rs rt<<1|1
#define lb(x) ((x)&(-(x)))
#define pb push_back
using namespace std;
const int N=1e6+10;
//#define use_file
//#define more_test
//#define need_init
#ifdef more_test
int T;
#endif

int n;

int cnt,p[N],phi[N];bool np[N];
void init(int n){
	phi[1]=1;
	for(int i=2;i<=n;++i){
		if(!np[i])p[++cnt]=i,phi[i]=i-1;
		for(int j=1;j<=cnt&&i*p[j]<=n;++j){
			np[i*p[j]]=true;
			if(i%p[j]==0){
				phi[i*p[j]]=phi[i]*p[j];
				break;
			}
			phi[i*p[j]]=phi[i]*phi[p[j]];
		}
	}
}

int ans;

void SOLVE(/*int test_id*/){
	scanf("%d",&n);
	init(n+1);
	for(int i=1;i<=n;++i)if(n%i==0)ans+=phi[i+1];
	printf("%d",(ans+1)>>1);
}
int main(){
	#ifdef use_file
	freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);
	#endif
	#ifdef need_init
	init();
	#endif
	#ifdef more_test
	scanf("%d",&T);
	for(int i=1;i<=T;++i)SOLVE(/*i*/);
	#else
	SOLVE();
	#endif
	return 0;
}
```

---

## 作者：water_tomato (赞：2)

本题解用图像阐述了 $a+b-1$ 的产生原因，望通过！
## 题意
题目中给出了一个 $N$ ，而我们要求的是有多少对$(a,b)$ 使得一个 $a$ 行 $b$ 列的矩形,满足其对角线穿过的格子数为 $N$。
## 解析
通过画图以及对题意的观察与分析，我们发现，对于一个 $a,b$ 互质的矩形，其对角线穿过的格子应该是呈阶梯状上升的(如图)。

![](https://cdn.luogu.com.cn/upload/image_hosting/ivjbppnr.png)

我们再像小学做这类数学题一样，将这些格子推向两边，可以数出穿过的格子数就为 $a+b-1$。

而对于一个 $a,b$ 不互质的矩形，显然可以将其拆分为 $\gcd{(a,b)}$ 个互质的矩形，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/xo2btmu5.png)

也就是说，我们只需要先求出 $N$ 的因数 $d$ ，再找到一对互质的 $(a,b)$ ,使得 $a+b-1=d$ ，就一定有一对 $(a\times k,b\times k)$ 满足条件。

接着就可以进行求解了！！！

我们只需要枚举所有的 $d$ ，并对于每一个 $d$ ，在满足 $a+b-1=d$ 的情况下枚举 $a,b$ ,只要 $a,b$ 互质，就产生了一组可行解。而由于 $a+b=d+1$ ,我们也可以枚举 $i$ ——$a,b$ 就为 $i,d+1-i$。

即求：
$$\sum_{d|n}\sum_{i=1}^d[\gcd(i,d+1-i)=1]$$
注意，此时我们会重复枚举 $(a,b)$ 和 $(b,a)$ ，因此我们需要将答案除以 $2$。

显然，由于 $\gcd$ 的性质，我们可以将 $d+1-i$ 加上 $i$，这样右边的 $\sum$ 就转化为了：
$$\sum_{i=1}^d[\gcd(i,d+1)=1]$$
然后我们惊奇的发现，这不就是 $\varphi(d+1)$ 吗！

于是原题即求:
$$\sum_{d|n}\varphi(d+1)$$
最后我们注意，在枚举 $d$ 时，若 $d$ 不为 $1$ ，我们只需要将其除以 $2$ 去重即可，但当 $d=1$ 时，有且仅有一种情况 $(1,1)$ ，因此我们统计时可以先忽略掉 $d=1$ 的情况，输出结果时 $+1$ 即可。
## 时间复杂度
枚举因数实际上可以优化为 $O(\sqrt n)$ ，但受线性筛的时间复杂度影响，最终时间复杂度为 $O(n)$。
## 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e6+5;
int phi[N],pri[N],cnt;
bool vis[N];
ll ans;
inline void prepare(int n){//线性筛求phi
	phi[1]=1;
	for(int i=2;i<=n;i++){
		if(!vis[i]){phi[i]=i-1;pri[++cnt]=i;}
		for(int j=1;j<=cnt&&pri[j]*i<=n;j++){
			vis[pri[j]*i]=1;
			if(!(i%pri[j])){phi[i*pri[j]]=pri[j]*phi[i];break;}
			else phi[i*pri[j]]=(pri[j]-1)*phi[i];
		}
	}
}
int main(){
	int n;
	scanf("%d",&n);
	prepare(n+1);
	for(int i=2;i<=n;i++)//枚举n的因数
		if(!(n%i)) ans+=(phi[i+1]>>1);
	printf("%lld",ans+1);//答案加上d=1的情况
	return 0^0;
}
```
## 备注
线性筛求 $\varphi$ 可以参考 $Rogn$ 大佬的[文章](https://www.cnblogs.com/lfri/p/11679306.html)

---

## 作者：袁宇轩 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/SP3890)

## 算法：莫比乌斯函数

### 题意：

对于一个 $i$ 行 $j$ 列的矩形，记 $f_{i,j}$ 为被对角线穿过的格子数，求有多少对 $i,j$ 满足 $f_{i,j} = N$ 。( $i,j$ 与 $j,i$ 算同一种)。

### 题解：

我们可以先考虑一下 $i,j$ 互质的情况，那么很显然 $f_{i,j}=i+j-1$。

如果 $i,j$ 不互质，我们记 $k=\gcd(i,j)$ ，那么对角线一定经过 $k$ 个 $\frac{i}{k}$ 行 $\frac{j}{k}$ 列的矩形，且根据上面得到的式子我们可以知道 $f_{\frac{i}{k},{\frac{j}{k}}}=\frac{i}{k}+\frac{j}{k}-1$ ，那么 $k$ 个矩形一共经过 $k*f_{\frac{i}{k},{\frac{j}{k}}}$ 个格子，即 $f_{i,j}=i+j-\gcd(i,j)$。

那么答案就是：$\sum\limits_{i}^{n}\sum\limits_{j}^{n}[i+j-\gcd(i,j)=n]$。

很明显 $O(n^{2})$ 是会妥妥的 $T$ 掉的。

我们用莫比乌斯函数来化一下式子：

$\sum\limits_{i}^{n}\sum\limits_{j}^{n}[i+j-\gcd(i,j)=n]$

$=\sum\limits_{k|n}^{}\sum\limits_{i}^{\frac{n}{k}}\sum\limits_{j}^{\frac{n}{k}}[i+j-1=\frac{n}{k}](\gcd(i,j)=1)$

$=\sum\limits_{k|n}^{}\sum\limits_{i}^{\frac{n}{k}}\sum\limits_{j}^{\frac{n}{k}}[i+j=\frac{n}{k}+1]\sum\limits_{d|i,d|j}^{}(\mu(d)=1)$

$=\sum\limits_{k|n}\sum\limits_{d}^{\frac{n}{k}}\mu(d)\sum\limits_{i}^{\frac{n}{k\cdot d}}\sum\limits_{j}^{\frac{n}{k\cdot d}}[di+dj=\frac{n}{k}+1]$

$=\sum\limits_{k|n}\sum\limits_{d|(\frac{n}{k}+1)}^{\frac{n}{k}}\mu(d)\sum\limits_{i}^{\frac{n}{k\cdot d}}\sum\limits_{j}^{\frac{n}{k\cdot d}}[i+j=\frac{\frac{n}{k}+1}{d}]$

$\sum\limits_{i}^{\frac{n}{k\cdot d}}\sum\limits_{j}^{\frac{n}{k\cdot d}}[i+j=\frac{\frac{n}{k}+1}{d}]$ 这个式子很明显 $i+j$ 为一个定值，所以确定了 $i$ 也就确定了 $j$，因为 $i$ 一共有 $\frac{n}{k\cdot d}$ 种，所以 $j$ 对应的也有 $\frac{n}{k\cdot d}$ 种，那么条件成立的情况也就有 $\frac{n}{k\cdot d}$ 种。

那么式子就可以化为：

$\sum\limits_{k|n}^{}\sum\limits_{d|(\frac{n}{k}+1)}^{\frac{n}{k}}\mu(d)\cdot(\frac{n}{k\cdot d})$

这个式子的复杂度应该是小于 $O(n^{\frac{3}{4}})$。

复杂度的瓶颈在于线性筛，所以是 $O(n)$。

### 代码：

```cpp
#pragma GCC optizie("3","Ofast","inline")
#pragma GCC target("avx")
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
#define ll long long
#define int long long
#define debug printf("%s %d\n",__FUNCTION__,__LINE__)
#define For(i,j,k) for(int i=(int)(j);i<=(int)(k);i++)
#define Rep(i,j,k) for(int i=(int)(j);i>=(int)(k);i--)
inline ll read(){
	ll x=0;char ch=getchar();bool f=0;
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=1;
	for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';
	return f?-x:x;
}
void write(ll x){
	if(x<0) putchar('-'),x=-x;
	if(x>=10) write(x/10);putchar(x%10+'0');
}
void writeln(ll x){write(x);putchar('\n');}
void writep(ll x){write(x);putchar(' ');}

int const N=1e6+3;
int n,ans,tot,mu[N],prime[N],vis[N];

void muin(){
	mu[1]=1;
	for (int i=2;i<=n;i++){
		if (!vis[i]) prime[++tot]=i,mu[i]=-1;
		for (int j=1;j<=tot && prime[j]*i<=n;j++){
			vis[prime[j]*i]=1;
			if (i%prime[j]!=0) mu[i*prime[j]]=-mu[i];
			else{
				mu[i*prime[j]]=0;
				break;
			}
		}
	}
}

signed main(){
	n=read();
	muin();
	for (int k=1;k<=n;k++)
	  if (n%k==0)
	    for (int d=1;d<=n/k;d++)
	      if ((n/k+1)%d==0) ans+=mu[d]*(n/(k*d));
	writeln(ans+1>>1);
	return 0;
}
```



---

## 作者：mahaorui2012 (赞：1)

# 思路

首先，对于一个长为 $R$，宽度为 $C$ 的长方形，其对角线所穿过的格子数量为 $R+C-\gcd (R,C)$，证明如下：

## 证明

不妨将对角线所穿过的格子数量转化为一从左上角运动到右下角的点的所穿过的格子数量，两者一定相等。

这个点应共横向移动 $R$ 个单位，竖向移动 $C$ 个单位，在该点不经过格点的情况下，共会经过 $(R-1)+(C-1)=R+C-2$ 条边。

又该点每经过一个边，其经过的格子数量就会增加 $1$，左上角的格子不需经过边也一定可达，这个点会经过 $R+C-2+1=R+C-1$ 个格点。

最后，在该点经过非左上角或右下角格点时，此时只经过了一条边（两条边重叠在了一起），但被计算了两次。又由下述引理可知，该点共经过 $\gcd (R,C)-1$ 个非左上角或右下角格点，即共经过 $(R+C-1)-(\gcd (R,C)-1)=R+C-\gcd (R,C)$ 个格子。

### 引理证明

首先，当 $\gcd (R,C)=1$ 时，非左上角或右下角格点（以下称“格点”）个数为 $0$，因为若该值不为 $0$，则一定可以将该长方形分为若干个小长方形，使其长宽之最大公因数为 $1$。又可以这样做任意多次，总经过格点数必将趋近于正无穷，而 $R$ 与 $C$ 均有限，该长方形内的格点数量必将有限，与前假设矛盾。

则此时对角线经过了 $0+1=1$ 个非左上角格点，该点为其右下角。

对于 $\gcd (R,C)\parallel 1$ 的情况，一定可以将其分为 $\gcd(R,C)$ 个小长方形，使其边长最大公因数为 $1$，即对角线共会经过 $\gcd (R,C)$ 个非左上角格点（小长方形右下角点两两不重），即共经过 $\gcd (R,C)$ 个非左上角格点，$\gcd (R,C)-1$ 个格点。

又 $1-1=0$，$\gcd (R,C)=1$ 也可并入到该情况里。 

此时可得原题相当于关于 $R$ 和 $C$ 的方程 $N=R+C-\gcd (R,C)$ 的解的组数。

## 化简方程

设 $g=\gcd (R,C)$，则设 $R=pg$，$C=qg$，由最大公因数定义可知 $\gcd (p,q)=1$，有：

$$N=pg+qg-g$$ 

易知该方程解的组数与原方程解的组数相等。 

$$N=g\cdot (p+q-1)$$

又 $g,p,q,1\in \mathbb{N}$，$N$ 必为 $g$ 的倍数，即 $g$ 为 $N$ 的因数。

可以枚举 $g$ 和 $p$，有：

$$\frac{N}{g}=p+q-1$$

$$q=\frac{N}{g}+1-p$$

此时用上公式计算出 $q$，再判断 $\gcd (p,q)$ 是否为 $1$ 即可。 

# AC CODE

```C++
#include <iostream>
#include <algorithm>
using namespace std;

int n;

int calc(const int& i){
	int ret=0;
	for(int p=1;p<=n/i+1-p;++p){
		if(__gcd(p,n/i+1-p)==1){
			++ret;
		}
	}
	return ret;
}

int main(){
	cin>>n;
	long long ans=0;
	for(int i=1;i*i<=n;++i){
		if(!(n%i)){
			ans+=calc(i);
			if(i*i!=n){
				ans+=calc(n/i);
			}
		}
	}cout<<ans;
	return 0;
}
```

---

## 作者：Yyxxxxx (赞：1)

## 题意
求有多少个矩形，使其对角线可以穿过指定数量的格子。

## 思路

令这个矩形边长为$X,Y$

- 若$gcd(X,Y)==1$ 

我们显然可以通过$Excel$画图找规律，其穿过格子为

$$X+Y-1$$

- 若$gcd(X,Y)!=1$

就比如$X=4,Y=6$时，$gcd(X,Y)=2$  
那么我们把其分成$4$个$2\times 3$的矩形，而对角线会穿过其中两个，（请自己画图验证）  
 那么我们就把它看作穿过$2$次$X=2,Y=3$的矩形，而此时$gcd(X,Y)==1$  
那么其穿过格子数就为$2\times (2+3-1)=4+6-2$

而对于一般情况 

$X=X',Y=Y'$时，$gcd(X,Y)=k$  
那么我们把其分成$k^2$个$\dfrac{X'}{k}\times\dfrac{Y'}{k}$的矩形，而对角线会穿过其中$k$个，（请自己画图验证）  
 那么我们就把它看作穿过$k$次$X=\dfrac{X'}{k},Y=\dfrac{Y'}{k}$的矩形，而此时$gcd(X,Y)==1$  
 那么其穿过格子数就为$k\times (\dfrac{X'}{k}+\dfrac{Y'}{k}-1)=X'+Y'-k$
- 综上

而第一种情况就是$gcd(X,Y)==1$  
即对于一般情况，答案都为
$$X+Y-gcd(X,Y)$$

那就按照题目意思，要穿过$N$个格子，即：
$$X+Y-gcd(X,Y)=N$$

不妨让$x=\dfrac{X}{gcd(X,Y)},y=\dfrac{Y}{gcd(X,Y)},n=\dfrac{N}{gcd(X,Y)}$

那么就有：

$$gcd(x,y)=1,n=x+y-1$$

对于熟悉欧几里得算法的同学：

$gcd(n+1,y)=gcd(x+y-1+1,y)=gcd(x+y-y,y)=gcd(x,y)=1$

即答案为能使得$gcd(n,y)==1$的数的个数  
上面定义了，$n=\dfrac{N}{gcd(X,Y)}$,故 $gcd(X,Y)=\dfrac{N}{n}$  
即$n|N$，又对于确定的$n,gcd(n,y)$的个数为$\varphi(n)$，而由于对称性：$(x,y)(y,x)$没有区别，故减半，而$(N,N)$只会被计算一次，故综上，答案为
$$\dfrac{[\sum\limits_{n|N}\varphi(n+1)]+1}{2}$$
 
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+10;
long long phi[maxn],prime[maxn],cnt=0;
long long sum=0;
bool used[maxn];
inline void getphi(long long n)
{
    phi[1]=0;
    for(int i=2;i<=n;i++)
    {
        if(!used[i]){prime[++cnt]=i;phi[i]=i-1;}
        for(int j=1;j<=cnt&&i*prime[j]<=n;++j)
        {
            used[i*prime[j]]=1;
            if(i%prime[j]==0)
            {
                phi[i*prime[j]]=phi[i]*prime[j];
            }
            else phi[i*prime[j]]=phi[i]*(prime[j]-1);
        }
    }
    
}
int main()
{
    long long x;
    scanf("%lld",&x);
    getphi(x+1);
    for(int i=1;i<=x;i++)
        if(x%i==0)
            sum+=phi[i+1];
    sum=(sum+1)/2;
    printf("%lld",sum);
    system("pause");
    return 0;
}
```

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

---

## 作者：gmb7291234 (赞：0)

## 思路
正难则反，考虑有多少个 $(R,C)$ 的对角线穿过了 $n$ 个方格。

我们可以很容易地发现，当 $R$ 和 $C$ 互质时，对角线穿过了 $R+C-1$ 个方格。因为对角线不会穿过其他点。

而当 $R$ 和 $C$ 不互质时，我们可以把对角线平均分为 $\gcd(R,C)$ 个部分，使每个部分的长和宽互质。

通过上面的结论，我们可以知道一个部分穿过的方格数量为：$\displaystyle{\frac{R}{\gcd(R,C)}+\frac{C}{\gcd(R,C)}-1}$。

每个部分加起来为 $R+C-\gcd(R,C)$。得方程：$R+C-\gcd(R,C)=N$。

转换得：$\displaystyle{\frac{R}{\gcd(R,C)}+\frac{C}{\gcd(R,C)}=\frac{N}{\gcd(R,C)}+1}$。

容易得出符合的数量为 $\displaystyle{\sum_{n|N}{\varphi(n+1)}}$。

因为要对对称去重，所以再对这个结果 $+1$ 除以 $2$。

直接求 $\varphi$，时间复杂度上界为 $O(n^{\frac{3}{4}})$。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long ans;
long long ph(int x){
	int u=x;
	for(int i=2;i*i<=x;i++){
		if(x%i==0){
			u=u/i*(i-1);
			while(x%i==0)x/=i;
		}
	}
	if(x>1)u=u*(x-1)/x;
	return u;
}
signed main(){
	cin>>n;
	for(int i=1;i*i<=n;i++){
		if(n%i==0){
			ans+=ph(i+1);
			if(i*i!=n)ans+=ph(n/i+1);
		}
	}
	cout<<(ans+1)/2;
	return 0;
}
```

---

## 作者：__Emerald__ (赞：0)

### 思路
考虑 $R\times C$ 的矩形需要穿过的方格数量，记为 $N$。

注意到当 $R$ 和 $C$ 互素时付公主的箭不会经过矩形中的点，则此时有 $N=R+C-1$。

所以有一般情况：$N=R+C-\gcd(R,C)$。

设 $R=\gcd(R,C)\times r,C=\gcd(R,C)\times c$，明显，$r$ 和 $c$ 互素，且 $N=\gcd(R,C)\times(r+c-1)$。

所以问题可以变为：给定 $N$，求 $(r,c)$ 的个数使 $r+c-1\mid N$ 且 $r$ 和 $c$ 互素。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,num;
int gcd(int a,int b){
	return (b == 0? a : gcd(b,a % b));
}
int main(){
	cin >> n;	
	for (int i = 1;i <= n;i++) if (n % i == 0){//i=r+c-1
		for (int r = 1;r <= (i + 1) / 2;r++){
			int c = i + 1 - r;
			if (gcd(r,c) == 1) num++;
		}
	}
	cout << num;
	return 0;
}
```

---

## 作者：_yolanda_ (赞：0)

[博客园食用更佳](https://www.cnblogs.com/yolanda-yxr/p/16676074.html) | [题目传送门](https://www.luogu.com.cn/problem/P4388)

## 简要题意

求有多少矩形对角线经过的方格数为给定的 $n$，其中 $R \times C$ 和 $C \times R$ 视为同一个矩形。

## 解题思路

首先考虑怎么求一个已知矩形对角线穿过的方格数。

对于长宽不互质的，可以先同时除以公因数，转成长宽互质，格子数也对应成倍数关系，固不考虑。

然后可以自己多画几个找规律，就可以得到一个结论：穿过的矩形数是 $x+y-1$。

（具体证明可以看一下其他大佬的题解，我太菜了只会找规律）

由于不互质的存在，我们要枚举 $n$ 的所有因数进行处理。对于每个因数一一枚举 $x$，判断 $x$ 和 $y$ 是否互质，互质就计入答案。为了避免算重，只考虑 $x$ 小于 $y$ 的情况就好。

时间复杂度嘛，应该是：因数和 $\times$ gcd 的复杂度。调和级数可以得知因数和最多最多不超过 $n\ln n$ 并且远远达不到，gcd 是 $\log n$ 的。顶天了也才 $O(n\ln n \log n)$ ，更何况还达不到。

## Code Time

```cpp
#include<bits/stdc++.h>
using namespace std;

int ans;
int gcd(int x,int y){if(!y)return x;return gcd(y,x%y);}
void sol(int n){
	++n;
	for(int x=1;x<=n-x;++x)
		if(gcd(x,n-x)==1)	++ans;
}

int main(){

	int n;cin>>n;
	for(int i=1;i*i<=n;++i)
		if(n%i==0){
			sol(i);
			if(n/i!=i)	sol(n/i);
		}
	cout<<ans;

	return 0;
}
```

---

## 作者：aleph_blanc (赞：0)

先思考另一个问题。

给出一个 $X\times Y$ 的矩形，求一条对角线划过的方格数量 $num$。

很明显，如果 $(X,Y)\ne1$，可以把这个大矩形看做若干个 $(x,y)=1$ 的小矩形的拼接。

那么我们现在只讨论 $(x,y)=1$ 的情况。

默认 $x\le y$。

很明显 $x=1,num=y$。

![](https://cdn.luogu.com.cn/upload/image_hosting/x6c8qwfo.png)

$x,y\ne1$ 时，可以看做原来的黄线下放，我们先画个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/vs0o8l7d.png)

除了第一个，其他的不可避免地多走了一个红格。

将红格左对齐，蓝格上对齐，易知： $num=x+y-1$。

$X\times Y$ 的矩形的对角线，可以分成 $\gcd(X,Y)$ 段，每段与上图类似。

于是我们开心地得出了通式：$num=X+Y-\gcd(X,Y)$

转化：$\frac{num}{\gcd(X,Y)}+1=x+y$

因为 $(x,y)=1$，所以 $(\frac{num}{\gcd(X,Y)}+1,x\ or\ y)=1$

结合题意，给出你 $num$，求：
$$
\sum_{n\mid num}\varphi(n+1)
$$

线性筛个 $\varphi$，最后结果 +1 再除 2。（完美的对角线只算到一次，其余的有 $x\times y$ 和 $y\times x$ 重复）

完美的对角线指长宽相等的矩形的对角线。

代码。。。就不贴了吧。。。QWQ。

---


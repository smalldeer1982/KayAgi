# [蓝桥杯 2025 国 A] 斐波那契数列

## 题目描述

斐波那契数列是一个满足如下要求的数列

$$\begin{cases} F_1 = 1 \\ F_2 = 1 \\ F_i = F_{i-1} + F_{i-2} \ (i > 2) \end{cases}$$

我们规定一个类似的数列满足

$$\begin{cases} G_1 = 2 \\ G_2 = 3 \\ G_i = G_{i-1} \times G_{i-2} \ (i > 2) \end{cases}$$

求该数列 $G$ 的前 $n$ 项的乘积对 $998244353$ 取模的结果。

## 说明/提示

**【评测用例规模与约定】**

对于 70% 的评测用例，$n \leq 10^6$；

对于所有评测用例，$1 \leq n \leq 10^{18}$。

## 样例 #1

### 输入

```
5```

### 输出

```
69984```

# 题解

## 作者：InterRiver (赞：6)

在赛场上，注意到了一个事情：

$p = 998,244,353$ 时，令 $c = 37,748,736$，有 $\prod_{i = 1}^{c} g_i \equiv 1 \pmod p$，且 $g_{c + 1} = 2, \, g_{c + 2} = 3$。完美的循环！因此可以 $O(c)$ 暴力求解。

以上，确实是我的赛时写法，但是这或许不是出题人的本意。

显然 $g_i$ 的因数只有 $2$ 和 $3$，可以把两种因数分来开看。$g_i$ 中的因数的个数正是 $g_{i - 1}$ 和 $g_{i - 2}$ 中的因数的数量之和，这是一个类似于斐波那契数列的形式，可以用矩阵快速幂求得。为了求出数列的前 $n$ 项和，可以为矩阵加上第三维用来维护求和，这是很常见的手段。

用来做快速幂的矩阵

$$
A = \left[
    \begin{array}{l}
    0 & 1 & 0\\
    1 & 1 & 0\\
    1 & 0 & 1
    \end{array}
\right]
$$

对向量

$$
\boldsymbol{q} = \left[
    \begin{array}{l}
    a \\ b \\ c
    \end{array}
\right]
$$

有

$$
A\boldsymbol{q} = \left[
    \begin{array}{l}
    b \\ a + b \\ c + a
    \end{array}
\right]
$$

但是，这里有一个问题：我们求得的数字太大了，这个数字是在幂上的，能不能降幂呢？欧拉定理告诉我们：

若 $\gcd(a, m) = 1$，则 $a^{\varphi(m)} \equiv 1 \pmod m$

因此在求 $2$ 和 $3$ 的幂次时，需要对 $\varphi(p) = p - 1$ 取模。

最后，$2$ 的幂次的前两项为 $[1, 0]$，$3$ 的幂次的前两项为 $[0, 1]$，则得到 `sum_f` 矩阵 $M$ 后，应当计算 $M[1, 0, 0]^{T}$ 的第三项作为答案中 $2$ 的幂次，$M[0, 1, 0]^{T}$ 的第三项作为答案中 $3$ 的幂次。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long i64;

const i64 mod = 998244353;
const i64 mod1 = mod - 1;

struct Matrix {
    i64 v[3][3];
    void clear() {
        memset(v, 0, sizeof(v));
    }
};

Matrix operator * (const Matrix &A, const Matrix &B) {
    Matrix ret; ret.clear();
    for(int i = 0; i < 3; i++)
        for(int j = 0; j < 3; j++)
            for(int k = 0; k < 3; k++)
                ret.v[i][j] = (ret.v[i][j] + A.v[i][k] * B.v[k][j]) % mod1;
    return ret;
}

Matrix sum_f(i64 n) {
    Matrix x, r;
    x.clear(); r.clear();
    x.v[0][1] = 1;
    x.v[1][0] = x.v[1][1] = 1;
    x.v[2][0] = x.v[2][2] = 1;
    r.v[0][0] = r.v[1][1] = r.v[2][2] = 1;
    while(n) {
        if(n & 1) r = r * x;
        x = x * x; n /= 2;
    }
    return r;
}

i64 qpow(i64 x, i64 p) {
    i64 r = 1;
    while(p) {
        if(p & 1) r = r * x % mod;
        x = x * x % mod; p /= 2;
    }
    return r;
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    i64 n; cin >> n;
    Matrix m = sum_f(n);
    i64 p2 = m.v[2][0];
    i64 p3 = m.v[2][1];
    i64 ans = qpow(2, p2) * qpow(3, p3) % mod;
    cout << ans << endl;
    return 0;
}
```

不过还有一个问题：循环节长度 $c$ 为什么是这么小的一个数，而非我一开始设想的 $p^2$ 级别？期待其他大佬的解释。

---

## 作者：qwqerty (赞：4)

很明显 $G_i$ 的值可以表示为 $2^{a_i}3^{b_i}$ 的形式。枚举前几项：
- $i=3$：$G_3=2^{1+0}\times3^{0+1}=2^1\times3^1$。
- $i=4$：$G_4=2^{0+1}\times3^{1+1}=2^1\times3^2$。
- $i=5$：$G_5=2^{1+1}\times3^{1+2}=2^2\times3^3$。

容易发现 $a_i=F_{i-2}$，$b_i=F_{i-1}$。利用数学归纳法很容易证明：
- $i=1$ 与 $i=2$ 时显然成立。
- $i>2$ 时 $G_i=G_{i-1}\times G_{i-2}$，$a_i=a_{i-1}+a_{i-2}$，$b_i=b_{i-1}+b_{i-2}$。也就是在 $i-1$ 和 $i-2$ 时成立则对于 $i$ 也一定成立。

由于我们要计算该序列的前缀积，也就是指数的前缀和。下面忽略 $i=1$ 时的情况。仅考虑 $\sum\limits_{i=1}^n F_i$ 的值。由斐波那契数列定义得 $F_i=F_{i+2}-F_{i+1}$。依次抵消得 $\sum\limits_{i=1}^n F_i=(F_{n+2}-F_{n+1})+(F_{n+1}-F_n)+\dots+(F_2-F_1)=F_{n+2}-1$。  
注意我们一开始是忽略了 $i=1$ 时的情况的。所以我们还要乘个 $2$ 回去。故最终的答案是 $2^{F_n}\times3^{F_{n+1}-1}\bmod 998244353$。  
写个矩阵快速幂即可。因为斐波那契数列是在指数上的，所以要根据扩展欧拉定理对 $\varphi(998244353)=998244352$ 取模。

---

## 作者：Ebola (赞：3)

我们将乘法取 $\log$ 后变为加法：

$$
\left\{
\begin{array}{l}
\log G_1=\log 2=640079066\\
\log G_2 = \log 3 = 1\\
\log G_i = \log G_{i-1}+\log G_{i-2}
\end{array}
\right.
$$

这里 $\log$ 采用以 $3$ 为底的离散对数。由于 $3$ 是 $998244353$ 的原根，因此离散对数是存在且唯一的。

设 $S_n=\prod_{i=1}^n G_i$，题目要求 $S_n$，同样取对数得到 $\log S_n=\sum_{i=1}^n \log G_i$。

直接上矩阵优化递推即可：

$$
\begin{bmatrix}
\log S_i\\
\log G_i\\
\log G_{i-1}
\end{bmatrix} = 
\begin{bmatrix}
1 & 1 & 1\\
0 & 1 & 1\\
0 & 1 & 0
\end{bmatrix} \cdot
\begin{bmatrix}
\log S_{i-1}\\
\log G_{i-1}\\
\log G_{i-2}
\end{bmatrix}
$$

注意由于取了 $\log$，所以矩阵乘法在取模时应该对 $998244352$ 取模。

---

## 作者：David_06 (赞：3)

## 题目大意

求：
$$\begin{cases} G_1 = 2 \\ G_2 = 3 \\ G_i = G_{i-1} \times G_{i-2} \ (i > 2) \end{cases}$$
的前 $n$ 项积，其中 $1\le n\le10^{18}$。

## 解题思路

设前 $n$ 项积为 $P_i$，注意到这个 $P_i$ 的因子只由若干个 $2$ 和 $3$ 相乘组成，我们可以统计这个 $2$ 的个数和 $3$ 的个数然后用快速幂实现。在考场上我列出了两个表格来找这个规律。

第一个表格列的是 $G_i$ 中因子 $2$ 的个数和 $3$ 的个数：

| | $G_1$ | $G_2$ | $G_3$ | $G_4$ | $G_5$ | $G_6$ | $G_7$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |:----------: |
| $2$ | $1$ | $0$ | $1$ | $1$ | $2$ | $3$ | $5$ |
| $3$ | $0$ | $1$ | $1$ | $2$ | $3$ | $5$ | $8$ |

不难看出，无论是因子 $2$ 的个数还是因子 $3$ 的个数都组成了一个斐波那契数列。那么求前 $n$ 项积的过程就转化为了求斐波那契数列的前 $k$ 项和的过程。这个时候对斐波那契数列比较熟悉的小伙伴已经可以将公式写出来了，本人是个**蒟蒻**，在考场上没有想到这个结论，于是有了第二张表，即前 $n$ 项积 $P_i$ 所含因子 $2$ 和因子 $3$ 的个数：

| | $P_1$ | $P_2$ | $P_3$ | $P_4$ | $P_5$ | $P_6$ | $P_7$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |:----------: |
| $2$ | $1$ | $1$ | $2$ | $3$ | $5$ | $8$ | $13$ |
| $3$ | $0$ | $1$ | $2$ | $4$ | $7$ | $12$ | $20$ |

这里我发现了在因子 $2$ 的部分又出现了一个斐波那契数列，于是我大胆猜测：斐波那契数列的前 $n$ 项和也跟斐波那契数列有关。在因子 $2$ 的部分，其实是在斐波那契数列前加了一个 $1$ 和一个 $0$ （忽略不计）之后得到的数列的前 $k$ 项和（看第一张表），那么因子 $3$ 部分得到的即为原斐波那契数列仅加了一个 $0$ 后得到的前 $k$ 项和。根据表可以写出：$P_i$ 中因子 $2$ 的指数为 $F_i$,而因子 $3$ 的指数为 $F_{i+1}-1$，即：

$$P_i=2^{F_i}\times 3^{F_{i+1}-1}$$

赛后我对斐波那契数列的前 $n$ 项和 $S_i$ 进行了数学推导：

由于 $F_i=F_{i+2}-F_{i+1}$，那么

$$
\begin{align*}
S_n &= F_1 + F_2 + \cdots + F_n \\
&= (F_3 - F_2) + (F_4 - F_3) + (F_5 - F_4) + \cdots + (F_{n + 2} - F_{n + 1})\\
&=F_{n+2}-F_2\\
&=F_{n+2}-1
\end{align*}
$$

突然发现：

> $1\le n\le 10^{18}$

这个数据范围想要 $O(n)$ 求指数 $F_n$ 和 $F_{n+1}-1$ 是不现实的，于是我想到了[矩阵加速递推求斐波那契数列](https://www.luogu.com.cn/problem/P1962)，这是一个非常模板的题，这里不再赘述。

但是指数会非常大，直接对指数取模怎么才能不对答案产生影响？根据费马小定理：

$$a^{p-1}\equiv 1 \pmod p$$

这里的 $1$ 就是 $a^0$，$998244353$ 是个质数，这里可以在求 $F_n$ 的时候把答案对 $998244353-1$ 取模以保证答案不变。

矩阵加速时间复杂度为 $O(2^3\log n)$（$2^3$ 为矩阵乘法的常数），快速幂的复杂度 $O(\log M)$（$M$ 为模数），总时间复杂度约为 $O(\log n)$，实测跑的飞快。

## AC Code

防止作弊不放快读快写。

```cpp
#define int long long
#define mod 998244353 
using namespace std;
struct matrix
{
	int num[3][3];
}e,a;//转移矩阵，原矩阵 
matrix operator*(const matrix &a,const matrix &b)
{
	matrix ans={};
	for(int i=1;i<=2;i++)
		for(int j=1;j<=2;j++)
			for(int k=1;k<=2;k++)
				ans.num[i][j]+=a.num[i][k]*b.num[k][j],ans.num[i][j]%=(mod-1);//注意这里取模是 mod-1 
	return ans;
}
matrix jzksm(matrix a,int b)//矩阵快速幂 
{
	matrix ans={};
	ans.num[1][1]=ans.num[2][2]=1;
	for(;b;b>>=1,a=a*a)
		if(b&1)
			ans=ans*a;
	return ans;
}
int ksm(int a,int b)//快速幂 
{
	int ans=1;
	for(;b;b>>=1,a*=a,a%=mod)
		if(b&1)
			ans*=a,ans%=mod;
	return ans;
}
signed main()
{
	int n=re();
	a.num[1][1]=a.num[1][2]=1;
	e.num[1][2]=e.num[2][1]=e.num[2][2]=1;
	matrix ans=a*jzksm(e,n-1);
	int anss=ksm(2,ans.num[1][1])*ksm(3,ans.num[1][2]-1)%mod;
	wr(anss);
	return 0;
}

```

---

## 作者：linhanmo (赞：2)

# [题解](https://www.luogu.com.cn/article/73tlc5qs)：[P12847 [蓝桥杯 2025 国 A] 斐波那契数列](https://www.luogu.com.cn/problem/P12847)

## 思路

很显然 $g_i$ 的质因子只有 $2$ 和 $3$，设 $g_i=2^{p_i}\cdot 3^{q_i}$，问题转化为求 $p,q$。

由于 $g_i=g_{i-1}\cdot g_{i-2}$，所以 $p_i,q_i$ 只能从 $p_{i-1},q_{i-1}$ 和 $p_{i-2},q_{i-2}$ 继承而来。

因为是相乘的关系，所以指数相加，也就是 $p_i=p_{i-1}+p_{i-2},q_i=q_{i-1}+q_{i-2}$。

考虑初始情况：

1. 因为 $p_1=1$，$p_2=1$，正好是斐波那契数列，所以 $p_i=f_i$；

2. 因为 $q_1=0$，$q_2=1$，$q_3=2$，发现 $q_i=f_{i+1}-1$；

通项公式即为：$g_n=2^{f_n}+3^{f_{n+1}-1}$。

## [AC](https://www.luogu.com.cn/record/220730974) code


```cpp
// 记得开 long long
#include <utility>
#include <stdio.h>
#define register
using pii = std::pair<int, int>;
constexpr int MOD = 998244353;
long long n;

pii fib(long long n) { // 快速倍增法
    if (n == 0) return {0, 1}; auto [p1, p2] = fib(n >> 1);
    int c = 1ll * p1 * (p2 * 2ll - p1) % (MOD - 1), d = (1ll * p1 * p1 + 1ll * p2 * p2) % (MOD - 1);
    return n & 1 ? pii{d, (c + d) % (MOD - 1)} : pii{c, d};
}

inline int power(int b, int x) { // 快速幂
    int res = 1;
    for (; x; b = 1ll * b * b % MOD, x >>= 1) if (x & 1) res = 1ll * res * b % MOD;
    return res;
}

int main(void) {
    scanf("%lld", &n);
    auto [a, b] = fib(n);
    
    printf("%lld", 1ll * power(2, (a + MOD - 1) % (MOD - 1)) * power(3, (b - 2 + MOD) % (MOD - 1)) % MOD);
    // 998244353 是质数，根据费马小定理，指数应 mod 998244352 
    return 0;
}
```

---

## 作者：CChord (赞：1)

## 思路
简单枚举几项，发现数列 $G$ 的前 $n$ 项乘积 $P$ 满足：
$$
3P_i=2^{F_i}\times 3^{F_{i+1}}
$$

在 $10^{18}$ 量级下，需要用矩阵快速幂加速计算斐波那契数列：

$$
\begin{pmatrix}
  F_{i+1}&F_{i}
\end{pmatrix}
\begin{pmatrix}
  1&1 \\
  1&0
\end{pmatrix}
=
\begin{pmatrix}
  F_{i+2}&F_{i+1}
\end{pmatrix}
$$

即：

$$
\begin{pmatrix}
  F_{n+1}&F_{n}
\end{pmatrix}
=
\begin{pmatrix}
  1&1
\end{pmatrix}
\begin{pmatrix}
  1&1 \\
  1&0
\end{pmatrix}^{n-1}
$$

需要注意的是，在计算 $F_i$ 时，由于其在指数上，由费马小定理，模数应当为 $p-1(p=998244353)$，最后：
$$
P_n=3^{-1}\times 2^{F_n\mod (p-1)}\times 3^{F_{n+1}\mod (p-1)}\mod p
$$

## 代码实现
```
#include<bits/stdc++.h>
#define int long long
using namespace std;

constexpr int mod = 998244353;

int qmi(int a, int k, int p){
	int res = 1;
	while(k){
		if(k & 1) res = res * a % p;
		a = a * a % p;
		k >>= 1; 
	}
	return res;
}

int inv(int a){
	return qmi(a, mod - 2, mod);
}

struct Matrix{
	int n, m;
	vector<vector<int>> v;
	Matrix(int n, int m) : n(n), m(m), v(n, vector<int>(m)) {}
	
	Matrix operator* (const Matrix &o){
		Matrix res(n, o.m);
		for(int i = 0; i < n; i++){
			for(int j = 0; j < o.m; j++){
				for(int k = 0; k < m; k++){
					res.v[i][j] += v[i][k] * o.v[k][j];
					res.v[i][j] %= mod - 1; 
				}
			}
		}
		return res;
	}
};

Matrix Qmi(Matrix a, int k){
	int n = a.n;
	Matrix res(n, n);
	for(int i = 0; i < n; i++) res.v[i][i] = 1;
	
	while(k){
		if(k & 1) res = res * a;
		a = a * a;
		k >>= 1;
	}
	return res;
}

void solve(){
	int n; cin >> n;
	if(n == 1){
		cout << 2 << '\n';
		return;
	}
	if(n == 2){
		cout << 6 << '\n';
		return;
	}
	
	Matrix init(1, 2);
	init.v[0][0] = init.v[0][1] = 1;
	
	Matrix cg(2, 2);
	cg.v = {{1, 1}, {1, 0}};
	
	auto res = init * Qmi(cg, n - 1);

	int ans = qmi(2, res.v[0][1], mod) * qmi(3, res.v[0][0], mod) % mod * inv(3) % mod;
	cout << ans << '\n';
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	solve();
	return 0;
}
```

---

## 作者：A7F3jK9pR0xf_ (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P12847)

### 思路

看到 $n=10^{18}$，我会矩阵加速！很遗憾，递推式中包含乘号，我们无法加速它。但它求的答案是乘积？所以也许我们能从指数上找规律。直接打表：



|$n$|$G$|$ans$|
|:-:|:-:|:-:|
|$1$|$G_1=2$|$ans_1=2^1·3^0$|
|$2$|$G_2=3$|$ans_2=2^1·3^1$|
|$3$|$G_3=2·3$|$ans_3=2^2·3^2$|
|$4$|$G_4=2·3^2$|$ans_4=2^3·3^4$|
|$5$|$G_5=2^2·3^3$|$ans_5=2^5·3^7$|

不难看出，左边的指数为斐波那契数列，满足 $F_i=F_{i-1}+F_{i-2},F_1=F_2=1$。右边的指数满足 $F^{'}_i=F^{'}_{i-1}+F^{'}_{i-2}+1,F^{'}_0=F^{'}_1=0$。于是我们就可以矩阵加速计算这两个递推式。关键是指数需要取模，怎么办？有欧拉定理：

$$a^{n\mod \varphi(m)}\equiv a^n(mod\  m),\gcd(a,m)=1$$

这样我们对递推式计算的结果取模 $\varphi(998244353)=998244352$ 即可。时间复杂度 $O(M^3\log n)$，其中 $M$ 为矩阵边长，本题可以理解为 $M=3$。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
typedef long long ll;
const int N = 3, mod = 998244353;
int len;
struct node
{
	ll a[N][N];
	friend node operator * (const node &n1, const node &n2)
	{
		node n3 = (node){{{0}}};
		for(int i = 0;i < len;++i)
			for(int j = 0;j < len;++j)
				for(int k = 0;k < len;++k)
					n3.a[i][j] = (n3.a[i][j] + n1.a[i][k] * n2.a[k][j] % (mod - 1)) % (mod - 1);
		return n3;
	}
};
il node matpow(node A, node T, ll n)
{
	while(n)
	{
		if(n & 1) A = A * T;
		T = T * T;
		n >>= 1;
	}
	return A;
}
il ll f1(ll n)
{
	if(n <= 0) return 0;
	if(n <= 2) return 1;
	node T = (node){{
		{1, 1},
		{1, 0}
	}};
	node A = (node){{
		{1, 0},
		{0, 1}
	}};
	len = 2;
	node ans = matpow(A, T, n - 2);
	return (ans.a[0][0] + ans.a[0][1]) % (mod - 1);
}
il ll f2(ll n)
{
	if(n == 1) return 0;
	node T = (node){{
		{1, 1, 1},
		{1, 0, 0},
		{0, 0, 1}
	}};
	node A = (node){{
		{0, 0, 0},
		{0, 0, 0},
		{1, 0, 0}
	}};
	node B = (node){{
		{1, 0, 0},
		{0, 1, 0},
		{0, 0, 1}
	}};
	len = 3;
	node ans = matpow(B, T, n - 1) * A;
	return ans.a[0][0];
}
il ll fastpow(ll a, ll b)
{
	ll ans = 1;
	for(;b > 0;b >>= 1, a = a * a % mod)
		if(b & 1) ans = ans * a % mod;
	return ans;
}
int main()
{
	ll n;cin >> n;
//	cout << f1(n) << " " << f2(n) << "\n";
	if(n == 1) cout << 2;
	else cout << fastpow(2, f1(n)) * fastpow(3, f2(n)) % mod;
	return 0;
}
```

---

## 作者：SudoXue (赞：0)

[更好的阅读体验](https://www.cnblogs.com/xueruhao/p/18934517)

这题还挺有意思。

首先观察到序列 $G$ 的定义

$$
G_1=2,\quad G_2=3,\quad G_i=G_{i-1}\times G_{i-2}\quad(i>2)
$$

意味着每一项都可拆成若干个 $2$ 和 $3$ 的幂相乘。

令

$$
G_i=2^{a_i}\,3^{b_i},
$$

则由递推可知

$$
(a_1,b_1)=(1,0),\quad(a_2,b_2)=(0,1),\quad(a_i,a_{i-1})\mapsto (a_{i-1}+a_{i-2},\,b_{i-1}+b_{i-2})  
$$

即 $(a_i)$ 和 $(b_i)$ 都是满足斐波那契关系的序列，只是初值不同。

进一步令

$$
P_n=\prod_{i=1}^nG_i
$$

则

$$
P_n
=\prod_{i=1}^n2^{a_i}3^{b_i}
=2^{\sum_{i=1}^n a_i}\;3^{\sum_{i=1}^n b_i}.
$$

根据斐波那契数列前缀和的性质，可证明

$$
\sum_{i=1}^n a_i=F_n,\qquad
\sum_{i=1}^n b_i=F_{n+1}-1,
$$

其中 $F_k$ 为最常见的斐波那契数列（$F_1=1,F_2=1$）。这样一来问题就转化为

$$
P_n
=2^{F_n}\times3^{F_{n+1}-1}\bmod998244353.
$$

由于题目中 $n$ 可达 $10^{18}$，必须在 $O(\log n)$ 时间内计算斐波那契数对 $M-1$（其中 $M=998244353$）的值，以及在 $O(\log n)$ 时间内做模幂运算。

前者可用[快速倍增法](https://en.oi-wiki.org/math/fibonacci/#_6)直接求得 $(F_n,F_{n+1})\bmod (M-1)$，后者用快速幂完成。

注意指数要对 $M-1$ 取模是因为 $M$ 为质数，可利用费马小定理将幂指数降模。

[link](https://www.luogu.com.cn/record/220788182)

---

## 作者：postpone (赞：0)

这届篮球杯比较有意思的题。

要求一个 $\prod_{i=1}^n G_i$，其中 $G_i=G_{i-1}G_{i-2}$，$G_1=2$，$G_2=3$。那么所有的 $G_i$ 和 $\prod G_i$，都可以表示成 $G_1^p G_2^q$ 的形式。

设 $G_i=G_1^{a_i} G_2^{b_i}$，由 $G_i=G_{i-1}G_{i-2}$，得 $a_i=a_{i-1}+a_{i-2}$，$b_i=b_{i-1}+b_{i-2}$，它们的幂次是有一个斐波那契数列的形式的。而它们的前缀和也和斐波那契数列有关。

打一个表看看：

| $i$ | $a_i$ | $\sum a_i$ | $b_i$ | $\sum b_i$ |
|:---:|:-----:|:----------:|:-----:|:----------:|
|  1  |   1   |      1     |   0   |      0     |
|  2  |   0   |      1     |   1   |      1     |
|  3  |   1   |      2     |   1   |      2     |
|  4  |   2   |      3     |   2   |      4     |
|  5  |   3   |      5     |   3   |      7     |
|  6  |   5   |      8     |   5   |     12     |
|  7  |   8   |     13     |   8   |     20     |

我们需要知道 $\sum a_i$ 和 $\sum b_i$，可以发现，前者就是完美的斐波那契数列，后者其实也是斐波那契数列，但是要减去 $1$。

那这道题就做出来了，由欧拉定理，求出 $\sum a_i$ 和 $\sum b_i$ 在模 $P-1$ 意义下的值，设 $F_x$ 为斐波那契数列第 $x$ 项，那么就是要求 $F_{n}\bmod P-1$ 和 $(F_{n+1}\bmod P-1)-1$。


记上面这两个东西为 $A$ 和 $B$，答案就是 $2^A 3^B \bmod P$。

怎么快速求斐波那契数列第 $n$ 项呢？矩阵快速幂就行了，可以做一下这个 [例题](https://www.luogu.com.cn/problem/P1962)。

> 对于斐波那契数列 $F$，有一个很好证明的小性质：$\sum^m_1 F_i = F_{m+2}-1$，这也解释了为什么 $\sum b_i$ 是这个东西。


```cpp
using Q = ModInt<998244352>;
using Z = ModInt<998244353>;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    i64 n;
    cin >> n;

    if (n == 1) {
        cout << 2 << "\n";
        return 0;
    }

    constexpr auto MatMul = [](const auto &a, const auto &b) {
        vector res(2, vector<Q>(2));
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                for (int k = 0; k < 2; k++) {
                    res[i][j] += a[i][k] * b[k][j];
                }
            }
        }
        return res;
    };
    auto MatPower = [&](auto a, i64 b) {
        vector res(2, vector<Q>(2));
        res[0][0] = res[1][1] = 1;
        for (; b; b /= 2, a = MatMul(a, a)) {
            if (b & 1) {
                res = MatMul(res, a);
            }
        }
        return res;
    };

    vector<vector<Q>> ori = {{1, 1}, {1, 0}};

    auto U = MatPower(ori, n - 2);
    int A = (U[0][0] + U[0][1]).val();
    
    auto V = MatPower(ori, n - 1);
    int B = (V[0][0] + V[0][1] - 1).val();

    Z ans = power(Z(2), A) * power(Z(3), B);
    cout << ans << "\n";

    return 0;
}
```

---


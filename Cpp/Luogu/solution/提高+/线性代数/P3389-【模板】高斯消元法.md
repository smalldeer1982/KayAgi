# 【模板】高斯消元法

## 题目背景

如果想要更好地测试高斯消元算法模板请在通过此题后尝试通过 [SDOI2006 线性方程组](https://www.luogu.com.cn/problem/P2455) 这一题。

## 题目描述

给定一个线性方程组，对其求解。

$$ \begin{cases} a_{1, 1} x_1 + a_{1, 2} x_2 + \cdots + a_{1, n} x_n = b_1 \\ a_{2, 1} x_1 + a_{2, 2} x_2 + \cdots + a_{2, n} x_n = b_2 \\ \cdots \\ a_{n,1} x_1 + a_{n, 2} x_2 + \cdots + a_{n, n} x_n = b_n \end{cases}$$


## 说明/提示

本题 special judge 用于处理可能由于浮点数问题输出 `-0.00` 的情况。若某个 $x_i$ 的解四舍五入后是 `0.00`，那么你的程序输出 `-0.00` 和输出 `0.00` 都是正确的。

数据范围：$1 \leq n \leq 100, \left | a_i \right| \leq {10}^4 , \left |b \right| \leq {10}^4 $。保证数据若有解则所有解均满足 $|x_i|\le 10^3$，且 $x_i\pm 10^{-6}$ 和 $x_i$ 四舍五入后的结果相同（即不会因为较小的精度误差导致四舍五入后的结果不同）。

## 样例 #1

### 输入

```
3
1 3 4 5
1 4 7 3
9 3 2 2```

### 输出

```
-0.97
5.18
-2.39```

# 题解

## 作者：皎月半洒花 (赞：638)

$emmmm$这个消元方式其实严格来说是可行性算法……而不是优化性算法……不过话说由于我太蒟蒻了，所以并不知道什么更优的算法（#滑稽）

嗯，其实这个算法是$O(n^3)$的算法，需要一些矩阵及行列式的知识……那么由本蒟蒻来记录一下这个算法吧！

那么假设有一个线性方程组是长这样的：

$\begin{Bmatrix} 3x & + & 2y &+& z &=&10 \\5x & + & y &+& 6z &=&25 \\2x & + & 3y &+& 4z &=&20\end{Bmatrix}$

$emmm$这就是一个很简单的三元一次方程，让我们想想常规方法该怎么做（先不谈$code$）

初中老师说过：我们可以**加减消元**或者**代入消元**,但是我们需要在程序里实现的时候，需要一种有规律可循的算法。所以我们选择**加减消元**，但用**代入消元**回带。

整体思路就是我们可以先在某一个式子里，用这个式子的$x$消去其他式子里的$x$,然后在剩下的两个式子里再选择一个式子里的$y$，用这个$y$消去最后剩下的式子里的$y$。那么现在最后一个方程里就只有一个未知数$z$了。倘若$z$的系数是$1$，那么我们就可以直接得出答案来了（别觉得这句话是废话）。

比如刚才这个方程，我们用第二个式子去消1、3式里的$x$：

$\begin{Bmatrix} 0\times x & + & \frac{7}{5}y &+& (-\frac{13}{5}z) &=&-5 \\5x & + & y &+& 6z &=&25 \\0\times x & + & \frac{13}{5}y &+& \frac{8}{5}z &=&10\end{Bmatrix}$

整理之后再用第三个式子里的$y$消去第一个式子里的$y$(注意，由于第二个式子作为消元用式，所以接下来的运算不再考虑二式):

$\begin{Bmatrix}0\times y &+& (-\frac{225}{65}z) &=&-\frac{135}{13} \\ \frac{13}{5}y &+& \frac{8}{5}z &=&10\end{Bmatrix}$

那么我们发现在$1$式中只剩下一个未知数了，那么就可解得：
$$z=3$$

带回三式里解出
$$y=2$$

再将$x$、$y$带回最早被消掉的二式里，解得
$$x=1$$

好像这个方法再数学逻辑上讲是特别麻烦的，但是却是一个通用性强的方法$qwq$

那么放在程序实现上来讲，我们可以先用一个$n \times (n+1)$的矩阵来记录每一个式子的系数以及结果。譬如上式就可以用矩阵表示成这样：

$\begin{Bmatrix} 3& 2 & 1 &|& 10 \\5 & 1 & 6 &|& 25 \\2  & 3 & 4 &|&20\end{Bmatrix}$

左边记录系数，右边记录每个式子的结果。

那么首先我们需要用第一列中（所有的$x$中）系数最大的来消其他两个式子。而这里为了方便起见，我们将这个选中的系数置为$1$，方便上例中地不断带回原式的操作（这样在回带的时候就可以不考虑原本的系数了）。

由于最多也只能用$double$型存储，所以必然会有精度误差。但如果我们每次都选用最大系数的来消掉其他系数，就可以最大程度地来减小误差。以下是一种不严谨地、适合意会的证明（选读）：

_____________________
_____________________

假设我们现在在处理第$n$个未知数，此时在众多的未知数$n$中，他们的系数分别是$k_1 k_2 k_3 k_ 4$……$km$,那么考虑，在选完$k_i$之后，下面我们要进行的是把$k_i$消成$1$。那么此时对于第$i$行的其他的系数以及结果我们都要除以$k_i$。

之后呢？之后我们要进行的操作是用这个式子来消掉其他式子里的该未知数啊$qwq$。如果要这么操作肯定会让其他式子别的未知数的系数，减去当前式子的别的未知数的系数乘上某个值（事实上假设选择含$k_i$的式子,则对于每个式子$j$而言，每个系数减去当前系数的倍数，这个倍数应该为$k_j$）

那么这样看来，对于当次用来消元的式子的每个系数$q_{i1}q_{i2}q_{i3}q_{i4}$……$q_{iw}$(假设当前元的系数是$q_{i1}$)而言，对于每一个其他式子的该项系数$q_{jw}$,都需要让$q_{jw}$变成

$$q_{jw}-\frac{q_{j1}}{q_{i1}} \times q_{iw}$$

那么我们观察这个式子，$q_{i1}$越大，$\frac{q_{j1}}{q_{i1}}$期望越小，那么我们考虑，这个值越小，我们就约可以把它看作一个“基本单位”。从而我们就使得减出来的值失精程度越低，最后即可保证数据是从期望上来讲最精确。

嗯，讲的很麻烦，大家挑重点看吧（或者只看最后一个自然段）

(逃

__________________
______________________

在置为$1$之后，我们需要来用这个式子去消其他的式子（别忘了每个式子的结果也要消）。那么在最后，我们只需要将这个矩阵的最右下角（也就是最后一个元的实际值）不断回带即可。

代码长这个样子：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
double map[111][111];
double ans[111];
double eps=1e-7;
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n+1;j++)
            scanf("%lf",&map[i][j]);
    for(int i=1;i<=n;i++){
        int r=i;
        for(int j=i+1;j<=n;j++)
            if(fabs(map[r][i])<fabs(map[j][i]))
                r=j;//find_the_biggest_number_of_the_first_column（at present) 
        if(fabs(map[r][i])<eps){
            printf("No Solution");
            return 0;
        }
        if(i!=r)swap(map[i],map[r]);//对换一行或一列,属于找最大当前系数的其中一步。（这样就可以只处理当前行的系数啦！） 
        double div=map[i][i];
        for(int j=i;j<=n+1;j++)
            map[i][j]/=div;
        for(int j=i+1;j<=n;j++){
            div=map[j][i];
            for(int k=i;k<=n+1;k++)
                map[j][k]-=map[i][k]*div;
        }
    }
    ans[n]=map[n][n+1];
    for(int i=n-1;i>=1;i--){
        ans[i]=map[i][n+1];
        for(int j=i+1;j<=n;j++)
            ans[i]-=(map[i][j]*ans[j]);
    }//回带操作
    for(int i=1;i<=n;i++)
        printf("%.2lf\n",ans[i]);
}

```
# $\color{pink}{by}$  $\color{pink}Flower\_pks$

---

## 作者：abensyl (赞：33)

[P3389【模板】高斯消元法](https://www.luogu.com.cn/problem/P3389)。

2023.12.21 更新：更正了小错误，添加了更详细的解释。

前置线性代数知识：[线性相关](https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3/6416511)、[初等变换](https://baike.baidu.com/item/%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2/10648400)、[矩阵的秩](https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5%E7%9A%84%E7%A7%A9/6285316)、[阶梯矩阵](https://baike.baidu.com/item/%E9%98%B6%E6%A2%AF%E5%9E%8B%E7%9F%A9%E9%98%B5/4654861)。

## 思路

这道题目是一个很好的考察队线性代数掌握情况的模板题，当然，你用小学数学里学的那个消元法的实质也就是线性方程组的初等变换，而线性方程组的初等变换和矩阵的初等变换在本质上是一样的，所以我觉得用矩阵的初等变换来解释更加直观，因为矩阵的秩可以直接说明方程组解的情况，并且阶梯形矩阵的概念更加直观易懂。

解线性方程组需要消元，消元的操作可以视作对于一个增广矩阵求阶梯矩阵的过程，对于下面这个方程，我们从矩阵的角度来剖析他：

$$\begin{cases}
\alpha_{1,1} x_1+\alpha_{1,2} x_2+\dots\alpha_{1,n} x_n=\beta_1\\
\alpha_{2,1} x_1+\alpha_{2,2} x_2+\dots\alpha_{2,n} x_n=\beta_1\\
\dots\\
\alpha_{n,1} x_1+\alpha_{n,2} x_2+\dots\alpha_{n,n} x_n=\beta_n\\
\end{cases}$$
（其中 $x_1,x_2,\dots,x_n$ 为未知量，$\alpha_{i,j}$ 为常数）

增广矩阵就可以理解为两个矩阵的组合，而对于一个 $n$ 元 $n$ 个方程的线性方程组，它的增广矩阵的左侧的矩阵规模为 $n\times n$，也就是 $n$ 个列向量，其中第 $i$ 个列向量的第 $j$ 行就是 $x_i$ 在第 $j$ 个方程里的系数，而右侧的矩阵是一个规模为 $n\times 1$ 的矩阵，也可以理解为一个列向量，第 $i$ 行的数就是第 $i$ 个方程组。

把这个矩阵用刚才线性方程组里的字母写出来，就是：
$$\left(
\def\arraystretch{1.5}
\begin{array}{c|c}
  {\begin{matrix}
  \alpha_{1,1}&\alpha_{1,2}&\dots&\alpha_{1,n}\\
  \alpha_{2,1}&\alpha_{2,2}&\dots&\alpha_{2,n}\\
  \dots&\dots&\dots&\dots\\
  \alpha_{n,1}&\alpha_{n,2}&\dots&\alpha_{n,n}
  \end{matrix}}&
  {\begin{matrix}
  \beta_1\\\beta_2\\\dots\\\beta_n\end{matrix}}
\end{array}
\right)$$
我们要做的第一步实际就是构建这个增广矩阵，构建方法非常简单，直接读入就可以了，因为题目的输入就是按照矩阵的格式读入的，我们在这里假设矩阵为 $R$，简记竖线左侧的矩阵为 $A$，简记竖线右侧的矩阵为 $B$，那么显然 $R=\left(\begin{array}{c|c}A&B\end{array}\right)$，这里，我们习惯性的称 $A$ 为系数矩阵，$R$ 为增广矩阵。

那么，我们知道，矩阵是可以进行初等变换的，在这里，用采用初等行变换进行消元，初等变换有以下三种：

1. 用一非零的数 $\lambda$ 乘以某一整行；  
2. 把一行的 $\lambda$ 倍加到另一行；  
3. 互换任意两行的位置。

（下如需使用，按顺序简称第一种、第二种、第三种）

我们知道，如果我们可以把一个矩阵化成阶梯矩阵的形式，那么就可以直接得到方程的解，所以我们的工作就是通过初等变换，化已知矩阵为阶梯矩阵即可。

我们知道，矩阵的秩就是矩阵中线性无关的行数的极大值（列数也一样，不过显然方程组是横着写的），简记为 $\operatorname{rank}{R}$，那么判断有无解的方式很显然，就是判断 $A$、$R$ 两个矩阵的秩以及 $n$ 的关系就可以了，如果 $\operatorname{rank}{R}\neq \operatorname{rank}{A}$ 或 $\operatorname{rank}{R}>n$ 说明无解（后者在这题里不可能出现，因为行数只有 $n$），否则如果 $\operatorname{rank}{R}<n$ 说明有多个解，否则有唯一解，在这里，矩阵的秩其实就可以理解为化为阶梯矩阵后不为零的列数。

可总结为：

- 如果系数矩阵的秩恰等于增广矩阵的秩，且等于未知数数量就是唯一解；  
- 如果这个系数矩阵的秩恰不等于增广矩阵的秩就无解，或者增广矩阵的秩大于未知数数量也是无解；  
- 剩下的情况就是无数解。

那么，高斯消元就是用已经算好的行去消剩下的行，具体的消除方法如下：

1. 如果有解，则一定秩满（$\operatorname{rank}{R}=n$），所以一定满足主对角线上所有元素非零，主对角线以左下所有元素为零，我们从第 $1$ 行向第 $n$ 行逐步消元，保证 $\alpha_{i,1}=\dots=\alpha_{i,i-1}=0$ 且 $\alpha_{i,i}\neq 0$，所以我们需要检查第 $i$ 行第 $i$ 列，如果为零，就需要考虑跟其他第 $i$ 列不为 $0$ 的没被处理过的行第三种初等变换，如果所有行的第 $i$ 列均为 $0$，就说明秩不满，直接输出 `No Solution` 即可，实质就是扫一遍没处理过的行随便找一个第 $i$ 列不为 $0$ 的放到第 $i$ 行去；  
2. 用第 $i$ 行将第 $i+1\sim n$ 行的第 $i$ 个元素全部消掉（在进行处理第 $i$ 行的时候，前 $i-1$ 行肯定都已经消掉了），那么这里需要用到第二种初等变换，具体的操作中，我们需要确定 $\lambda$ 的值，很显然，如果我们要将第 $j$（$j>i$）行的第 $i$ 个元素消掉，那么就满足 $\alpha_{j,i}+\lambda\times\alpha_{i,i}=0$，显然 $\lambda=-\frac{\alpha_{j,i}}{\alpha_{i,i}}$；

划为有唯一解的阶梯矩阵以后，矩阵大致形态如下：
$$\left(
\def\arraystretch{1.5}
\begin{array}{c|c}
  {\begin{matrix}
  \theta_{1,1}&\theta_{1,2}&\dots&\theta_{1,n-1}&\theta_{1,n}\\
  0&\theta_{2,2}&\dots&\theta_{2,n-1}&\theta_{2,n}\\
  \dots&\dots&\dots&\dots&\dots\\
  0&0&\dots&\theta_{n-1,n-1}&\theta_{n-1,n}\\
  0&0&\dots&0&\theta_{n,n}
  \end{matrix}}&
  {\begin{matrix}
  \epsilon_1\\\epsilon_2\\\dots\\\epsilon_n\\\epsilon_n\end{matrix}}
\end{array}
\right)$$
有了这样一个矩阵，那么后续就容易了，首先第 $n$ 行是一个一元一次方程组，非常好解，然后最后一行求出 $x_n=\frac{\epsilon_n}{\theta_{n,n}}$，将其作为常数带入倒数第二行，得到 $x_{n-1}=\frac{\epsilon_n-x_n\times \theta_{n-1,n}}{\theta_{n,n}}$，以此类推，可以求出整个方程组的解。

**写代码时的一些注意点：**

- 本题在消元时使用第二种初等变换，不能保证中间结果和最终答案均为整数，需要使用浮点数；   
- 注意判断浮点数是否为零的时候需要小心精度差，判 `a[i][i]=0` 的时候请用 `fabs(a[i][i])<eps` 而不是 `a[i][i]==0`。否则开了 O2 优化后会因为 FMA 挂掉（详见[这篇帖子](https://www.luogu.com.cn/discuss/743468?page=2)）；  
- 如果第 $i$ 行第 $i$ 列为零，一定要和下面的其他行进行第二种初等变换，否则程序可能输出 `nan`；   
- 注意 `No Solution` 的拼写方式。

代码里有简要的注释，可供参考。

## 代码
```cpp
#include <bits/stdc++.h>
const long double eps=1e-7;
using namespace std;
long double mat[105][105],res[105];
int n;
void trans(int i,int j) {
	// 初等变换 3：交换第 i 行和第 j 行
	if(i==j) return;
	swap(mat[i],mat[j]);
}
void trans(int i,int j,double k) {
	if(!i||!j) return;  
	// 初等变换 2：将第 i 行的 k 倍与第 j 行对应相加
	for(int l=1;l<=n+1;++l)
		mat[j][l]+=k*mat[i][l];
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr),
	cout.tie(nullptr);
	cin>>n;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n+1;++j) 
			cin>>mat[i][j];
	for(int i=1;i<=n;++i) {
		bool flag=0;
		// 先找到一个第 i 个数字不为 0 的行将其初等变换到第 i 行
		for(int j=i;j<=n;++j)
			trans(i-1,j,-mat[j][i-1]/mat[i-1][i-1]);
		for(int j=i;j<=n;++j)
			if(!fabs(mat[j][i])<eps) {
				trans(i,j);
				flag=1;
				break;
			}
		if(!flag) {
			// 不满秩，找不到就一定没有唯一解
			cout<<"No Solution\n";
			return 0;
		}
		if(!mat[i][i]) {
			// 初等变换把 (i,i) 也变成 0 了
			cout<<"No Solution\n";
			return 0;
		}
		// 通过初等变换 2 进行消元
	} // 变为阶梯形矩阵后，从下往上求方程的解
	for(int i=n;i>=1;--i) {
		res[i]=mat[i][n+1];
		for(int j=n;j>i;--j)
			res[i]-=mat[i][j]*res[j];
		res[i]/=mat[i][i];
		// 用之前算出的结果从下向上代入方程求解
	}
	for(int i=1;i<=n;++i)
		cout<<fixed<<setprecision(2)<<res[i]<<'\n';
	// 输出答案
	return 0;
}
```

---

## 作者：zzx0102 (赞：17)

高斯消元法是一个用来求解线性方程组的算法。

可以解出形如

$$ \begin{cases} a_{1, 1} x_1 + a_{1, 2} x_2 + \cdots + a_{1, n} x_n = b_1 \\ a_{2, 1} x_1 + a_{2, 2} x_2 + \cdots + a_{2, n} x_n = b_2 \\ \cdots \\ a_{n,1} x_1 + a_{n, 2} x_2 + \cdots + a_{n, n} x_n = b_n \end{cases}$$

的 $n$ 元一次方程组。

高斯消元主要是运用两种消元方法：加减消元法和代入消元法，和初中生解一次方程组一样。

高斯消元的方法是，使用主元法，先进行加减消元，然后我们可以先求得 $x_1$，然后可以逐层往回代，依次可以得到 $x_2,x_3\cdots x_n$。

举个例子，方程

$$ \begin{cases} x + 3y + 4z = 5 \\ x + 4y + 7z = 3 \\ 9x + 3y + 2z  = 2 \end{cases}$$

先写进矩阵：

$$\begin{bmatrix}
   1 & 3 & 4 & | & 5 \\
   1 & 4 & 7 & | & 3 \\
   9 & 3 & 2 & | & 2
\end{bmatrix}$$

然后通过主元法，系数化为 $1$，上下加减，得到：

$$\begin{bmatrix}
   0.25 & 0.75 & 1 & | & 1.25 \\
   0.14 & 0.57 & 1 & | & 0.43 \\
   4.5 & 1.5 & 1 & | & 1
\end{bmatrix}$$

加减消元：

$$ \begin{cases} 0.11x + 0.18y = 0.82 \\ -4.36x -0.57y  = -0.57\end{cases}$$

使用相同的方法：

可得 $x=3.98\times -\dfrac{1}{4.09}=0.97$

但是怎么回代呢？

我们每次操作的时候留下一个当前的方程，矩阵会变成这样：

$$\begin{bmatrix}
   -4.09 & 1 & 1 & | & 3.98 \\
   4.69 & 1 & 1 & | & 0.62 \\
   4.5 & 1.5 & 1 & | & 1
\end{bmatrix}$$

回代，解得

$$ \begin{cases} x = -0.97 \\ y = 5.18 \\ z = -2.39 \end{cases}$$

如果一个方程没有了系数不为 $0$ 的项，则方程无解或者有无数解，输出 `No Solution`。

复杂度 $\mathcal{O}(n^3)$，可以过。

参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 110;
const double eps = 1e-6;
int n; double a[N][N];
bool gauss() {
	int r = 0;
	for(int c = 0; c < n; c++) {
		int t = r;
		for(int i = r; i < n; i++)
			if(fabs(a[i][c]) > fabs(a[t][c]))
				t = i;
		if(fabs(a[t][c]) < eps) continue;
		for(int i = c; i < n + 1; i++) swap(a[t][i], a[r][i]);
		for(int i = n; i >= c; i--) a[r][i] /= a[r][c];
		for(int i = r + 1; i < n; i++)
			if(fabs(a[i][c]) > eps)
				for(int j = n; j >= c; j--)
					a[i][j] -= a[r][j] * a[i][c];
		r++;
	}
	if(r < n) return 1;
	for(int i = n - 1; i >= 0; i--) for(int j = i + 1; j < n; j++) a[i][n] -= a[j][n] * a[i][j];
	return 0;
}
int main() {
	cin >> n;
	for(int i = 0; i < n; i++)
		for(int j = 0; j < n + 1; j++)
			cin >> a[i][j];
	bool t = gauss();
	if(t == 0) for(int i = 0; i < n; i++) printf("%.2lf\n", a[i][n]);
	else puts("No Solution");
	return 0;
}
```

---

## 作者：rainygame (赞：14)

**本题解不包含任何关于高斯消元的知识，仅为娱乐！**

本题居然没有 Python 题解？那我就来发一下。

因为洛谷提供 `numpy` 库，而这个库中又有一个模块叫做 `linalg`，而这个 `linalg` 里面就有一个函数叫做 `solve`，这个函数就是用来解线性方程的。

`numpy.linalg.solve(a,b)` 的返回值即为解的矩阵，其中 `a` 表示系数矩阵，`b` 表示转置矩阵（也就是解的矩阵）。

然后我们就可以愉快轻松地解出这道题了！

Python 代码如下：

```python
from numpy import *
n = int(input())
a = []
b = []
while(n):
    c = input().split()
    c = [int(j) for j in c]
    b.append(c.pop())
    a.append(c)
    n -= 1
try:
    d=linalg.solve(a,b)
    for i in d:
        print("%.2f"%i)
except:
    print("No Solution")
```

有了这个函数，我们还可以打出本题的[最短解](https://www.luogu.com.cn/record/108178434)。

---

## 作者：billtun (赞：8)

# 高斯消元法：

## 两个概念：

### 一、系数矩阵

**定义**：由方程组未知数系数组成的矩阵叫系数矩阵。

**例**：

$$
\begin{cases}x_1+x_2+x_3=3\\x_1-x_2+2x_3=-2\\3x_1+2x_2-5x_3=6\end{cases}
$$

的系数矩阵为:

$$
\begin{bmatrix}1&1&1\\1&-1&2\\3&2&-5\end{bmatrix}
$$

### 一、增广矩阵

**定义**：就是在系数矩阵右边再加上一列表示方程组等号右边的值。

**例**：

$$
\begin{cases}x_1+x_2+x_3=3\\x_1-x_2+2x_3=-2\\3x_1+2x_2-5x_3=6\end{cases}
$$

的增广矩阵为:

$$
\begin{bmatrix}1&1&1&3\\1&-1&2&-2\\3&2&-5&6\end{bmatrix}
$$

## 思路：

先把**系数矩阵**消为一个**上三角矩阵**，在**从上到下**回代求解。

## 流程：

- 枚举主元，找到主元下面系数不为零的一行（有时为了精度，会选择主元绝对值最大的一行。

- 把这一行与主元交换。

- 把主元系数变为一。

- 把主元下面的系数变为零。

## 解的情况：

- 唯一解：

	- $i$ 可以枚举完 $n$ 行。

	- $\begin{bmatrix}1&1&1&6\\0&1&2&8\\0&0&1&3\end{bmatrix}$

- 无解：

	- $a_{i,i}=0$ 且 $b \ne 0$。

	- $\begin{bmatrix}1&1&1&6\\0&1&2&3\\0&0&0&3\end{bmatrix}$

- 无数解：

	- $a_{i,i}=0$ 且 $b = 0$。

	- $\begin{bmatrix}1&1&1&6\\0&1&2&3\\0&0&0&0\end{bmatrix}$

## 代码：
```cpp
#include<bits/stdc++.h>
#define Maxn 105
#define eps (1e-6)

using namespace std;

int n;
double a[Maxn][Maxn]; // 增广矩阵

int gauss(){
	for (int i = 1; i <= n; ++i){ //第i主元
		for (int k = i; k <= n; ++k){
			if (fabs(a[k][i]) > eps){
				swap(a[k], a[i]);
				break;
			}
		} //换非0行
		if (fabs(a[i][i]) < eps){
			return 0;
		}

		for (int j = n + 1; j >= i; j--){
			a[i][j] /= a[i][i];
		} // 变1

		for (int k = i + 1; k <= n; k++){
			for (int j = n + 1; j >= i; j--){
				a[k][j] -= a[k][i] * a[i][j];
			}
		} // 变0
	}
	for (int i = n - 1; i >= 1; i--){ // 回代
		for (int j = i + 1; j <= n; j++){
			a[i][n + 1] -= a[i][j] * a[j][n + 1];
		}
	}
	return 1; // 存在唯一解
}

int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= n + 1; j++){
			scanf("%lf", &a[i][j]);
		}
	}

	if (gauss()){
		for (int i = 1; i < n + 1; i++){
			printf("%.2lf\n", a[i][n + 1]);
		}
	} else{
		puts("No Solution");
	}
	return 0;
}
```

---

## 作者：LoongPig (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P3389)

**一些无意义的统计：**
- 在写这篇题解的期间，浏览器炸了 $6$ 次。
- 这篇题解由于浏览器的问题重写了 $3$ 次。
- 耗时 $4$ 个小时。

## 高斯-约旦消元法

### 基本操作：
对于一个有 $m$ 个一次方程，$n$ 个变量的线性方程组可以表示为一个增广矩阵。

**举个栗子：**

$$\begin{cases}
3x_1+7x_2-5x_3=47\\
x_1+4x_2+x_3=58\\
8x_1-3x_2+9x_3=88
\end{cases}\Rightarrow\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
1&4&1\\
8&-3&9
\end{matrix}&
\begin{matrix}
47\\
58\\
88
\end{matrix}
\end{array}
\right ]$$

增广矩阵的 $3$ 种变换，称为初等变换：

- 交换某两行的位置。
- 用一个非 0 的常数 $k$ 乘某个方程。
- 把某一行乘 $k$ 然后加到另一行上。

应该不用举栗子了吧。

### 解的情况

线性方程组的解有 $3$ 种情况：

1. **有唯一解:**

$$\begin{cases}
3x_1+7x_2-5x_3=47\\
x_1+4x_2+x_3=58\\
8x_1-3x_2+9x_3=88
\end{cases}\Rightarrow\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
1&4&1\\
8&-3&9
\end{matrix}&
\begin{matrix}
47\\
58\\
88
\end{matrix}
\end{array}
\right ]$$

首先把左边的方程组写成右边的增广矩阵，然后反复使用初等变换，得：
$$\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
1&4&1\\
8&-3&9
\end{matrix}&
\begin{matrix}
47\\
58\\
88
\end{matrix}
\end{array}
\right ]\Rightarrow\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
1&4&1\\
0&35&-1
\end{matrix}&
\begin{matrix}
47\\
58\\
376
\end{matrix}
\end{array}
\right ]\Rightarrow\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
0&5&8\\
0&35&-1
\end{matrix}&
\begin{matrix}
47\\
127\\
376
\end{matrix}
\end{array}
\right ]\Rightarrow\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
0&5&8\\
0&0&57
\end{matrix}&
\begin{matrix}
47\\
127\\
513
\end{matrix}
\end{array}
\right ]\Rightarrow\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
0&5&8\\
0&0&1
\end{matrix}&
\begin{matrix}
47\\
127\\
9
\end{matrix}
\end{array}
\right ]\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
0&5&0\\
0&0&1
\end{matrix}&
\begin{matrix}
47\\
55\\
9
\end{matrix}
\end{array}
\right ]\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
0&1&0\\
0&0&1
\end{matrix}&
\begin{matrix}
47\\
11\\
9
\end{matrix}
\end{array}
\right ]\Rightarrow\left [
\begin{array}{c|c}
\begin{matrix}
1&0&0\\
0&1&0\\
0&0&1
\end{matrix}&
\begin{matrix}
5\\
11\\
9
\end{matrix}
\end{array}
\right ]$$

最后解得 $x_1=5$，$x_2=11$，$x_3=9$。这是唯一解，称最后得矩阵为**简化梯形矩阵**，特征是左半部分是一个单位矩阵。

2. **有无穷多解:**
   
$$\begin{cases}
3x_1+7x_2-5x_3=47\\
x_1+4x_2+x_3=58\\
2x_1+3x_2-6x_3=-11
\end{cases}\Rightarrow
\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
1&4&1\\
2&3&-6
\end{matrix}&
\begin{matrix}
47\\
58\\
-11
\end{matrix}
\end{array}
\right ]\Rightarrow
\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
0&5&8\\
0&0&0
\end{matrix}&
\begin{matrix}
47\\
127\\
0
\end{matrix}
\end{array}
\right ]$$

最后的矩阵出现了一个全都是 $0$ 的行，说明这一行无效。$3$ 个未知数，却只有两个方程，所以有无穷多个解。

3. **无解：**

$$\begin{cases}
3x_1+7x_2-5x_3=47\\
x_1+4x_2+x_3=58\\
2x_1+3x_2-6x_3=5
\end{cases}\Rightarrow
\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
1&4&1\\
2&3&-6
\end{matrix}&
\begin{matrix}
47\\
58\\
5
\end{matrix}
\end{array}
\right ]\Rightarrow
\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
0&5&8\\
0&0&0
\end{matrix}&
\begin{matrix}
47\\
127\\
16
\end{matrix}
\end{array}
\right ]$$

最后的矩阵出现了 $0x_1+0x_2+0x_3=16$ 的矛盾方程，说明该方程组无解。

### 具体实现方法

1. 从第一行开始，选择一个非 $0$ 的系数（一般选择绝对值最大的系数，避免转换其他系数时产生过大的数值）所在的行，把这一行与第 $1$ 行交换。此时 $x_1$ 是主元；
2. 把 $x_1$ 的系数转换为 $1$；
3. 利用主元 $x_1$ 的系数，把其他行的这一列的主元消去；
4. 重复上述步骤，直到该增广矩阵变为简化梯形矩阵。

## 代码

[提交记录](https://www.luogu.com.cn/record/217843801)

```cpp
#include <bits/stdc++.h>
using namespace std;
const double eps=1e-7;
double a[105][105];
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n+1;j++)
            cin>>a[i][j];
    for(int i=1;i<=n;i++){
        int maxx=i;
        for(int j=i+1;j<=n;j++)//找到绝对值最大的系数的所在行
            if(fabs(a[j][i])>fabs(a[maxx][i])) maxx=j;
        for(int j=1;j<=n+1;j++)
            swap(a[i][j],a[maxx][j]);//与第 i 行交换
        if(fabs(a[i][i])<eps){
            //无解或者有无穷多解
            cout<<"No Solution";
            return 0;
        }
        for(int j=n+1;j>=1;j--) a[i][j]=a[i][j]/a[i][i];//把 x_1 的系数转换为 1
        for(int j=1;j<=n;j++){
            if(j!=i){
                //消去其他行的系数
                double tmp=a[j][i]/a[i][i];
                for(int k=1;k<=n+1;k++) a[j][k]-=a[i][k]*tmp;
            }
        }
    }
    for(int i=1;i<=n;i++) printf("%.2lf\n",a[i][n+1]);//输出该线性方程组的解
    return 0;
}
```

---

## 作者：MoonCake2011 (赞：5)

其实就是解方程，模拟就行了。

我是擅长于代入消元的，我们可以用代入消元解决此题。

先手动模拟一遍样例。


$$a+3b+4c=5$$

$$a+4b+7c=3$$

$$9a+3b+2c=2$$

表示 `a`。

$$a=5-3b-4c$$

$$a+4b+7c=3$$

$$9a+3b+2c=2$$

代入剩下两个方程。

$$a+3b+4c=5$$

$$b+3c=-2$$

$$-24b-34c=-43$$


接下来，消掉 `b`。

$$a+3b+4c=5$$

$$b=-2-3c$$

$$-24b-34c=-43$$

变成这样。


$$a+3b+4c=5$$

$$b+3c=-2$$

$$38c=-91$$

最后，消掉 `c`。

$$a+3b+4c=5$$

$$b+3c=-2$$

$$c=-2.39$$

最后的矩阵形式是这样的。

$$1,3,4,5$$

$$0,1,3,-2$$

$$0,0,1,-2.39$$


记录好哪个元是哪个方程所代入消掉的。

回代。

## 思路整理

说了那么多。

直接开始整理思路。

下面是以步骤编号。

1. 枚举每个未知数

2. 找到含有那个未知数的一个方程（一般找系数绝对值最大的方程）。

3. 如果所有方程中那个未知数的系数都为 $0$，判定无解（找系数绝对值最大的方程的好处体现出来了）。

4. 将那个方程中的那个未知数的系数化为 $1$。

5. 代入消去其他方程中的这个元。（注意不要自己代入自己）

6. 记录好哪个元是哪个方程所代入消掉的，且标记一下此方程不可以用到了。

代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
double f[110][110];
bool q[110];
int st[110];
double ans[110];
int main() {
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n+1;j++)
			cin>>f[i][j];
	for(int i=1;i<=n;i++){//step 1
		int maxn=0;
		for(int j=1;j<=n;j++)//step 2
			if(fabs(f[j][i])>fabs(f[maxn][i]) && !q[j]) maxn=j;
		if(fabs(f[maxn][i])<1e-8){//step 3
			cout<<"No Solution\n";
			return 0;
		}
		st[i]=maxn,q[maxn]=1;//step 6 这步先做其实这可以避免自己代入自己
		double p=f[maxn][i];
		for(int j=1;j<=n+1;j++) f[maxn][j]/=p;//step 4
		for(int j=1;j<=n;j++)//代入消元 step 5
			if(!q[j]){
				double t=f[j][i];
				for(int k=1;k<=n+1;k++)
					f[j][k]-=f[maxn][k]*t;
			}
	}
	for(int i=n;i>=1;i--){
		ans[i]=f[st[i]][n+1];
		for(int j=1;j<=n;j++)
			if(i!=j) ans[i]-=f[st[i]][j]*ans[j];
	}
	for(int i=1;i<=n;i++)
		printf("%.2f\n",ans[i]);
	return 0;
}
```

恭喜你，成功 AC。

---

## 作者：szr666 (赞：5)

我这里推荐一下[我的博客](https://www.luogu.org/blog/szr666--blog/)

在博客里观看更美观哦~

[题目](https://www.luogu.org/problemnew/show/P3389)
------------


------------

华丽的分割线
# 解析

### 思路：

这里举三元一次方程组的例子

对于一个三元一次方程组，可化为矩阵乘向量的形式

$\begin{pmatrix}a&b&c\\d&e&f\\g&h&i\end{pmatrix}\begin{pmatrix}x\\y\\z\end{pmatrix}$=$\begin{pmatrix}j\\k\\l\end{pmatrix}$

等价于 $\begin{cases}ax+by+cz=j\\dx+ey+fz=k\\gx+hy+iz=l\end{cases}$

我们的目的是把方程化为

$\begin{pmatrix}1&0&0\\0&1&0\\0&0&1\end{pmatrix}\begin{pmatrix}x\\y\\z\end{pmatrix}$=$\begin{pmatrix}m\\n\\o\end{pmatrix}$

等价于
$\begin{cases}1x+0y+0z=m\\0x+1y+0z=n\\0x+0y+1z=o\end{cases}$

显然等式右面的向量为方程的解

则问题转化为把矩阵
$\begin{pmatrix}a&b&c&j\\d&e&f&k\\g&h&i&l\end{pmatrix}$

经过初等行变换化为 $\begin{pmatrix}1&0&0&m\\0&1&0&n\\0&0&1&o\end{pmatrix}$

设题目中的矩阵为a[i][j]

初等行变换有以下几种操作

1.交换任意两行 2.一行加上任意一行的倍数 

3.任意一行同时乘一个数

我们把第i行第i列的元素化为1(第i行乘a[i][i]的倒数)

用第i行通过操作2，消去第i列的元素

对于第i列中的第j行元素,a(i,j)-=a(i,i)(为1)*a(i,j)=0

第j行其他元素也-=a(i,i)*a(i,j)

同理使得1~n成为对角矩阵

### 细节处理

1.在消除第i列时，尽量选择第i列中最大的元素

先扫一遍,在把最大的第r行与第i行交换

2.没有唯一解的情况

(1) 存在a(i,i)=0 且a(i,n+1)=0,则方程有无数解
	
如 0x+0y+0z=0

(2) 存在a(i,i)=0 且a(i,n+1)!=0,则方程无解

如 0x+0y+0z=1

3.矩阵和与矩阵运算有关的变量都开double

# 代码

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
double b[501][501];
int n;
inline int max(int x1,int x2)
{
    return x1>x2 ? x1 : x2;
}
const double ex=0.000001;
int main()
{
    int i,j,r,k,l;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n+1;j++)
        {
            scanf("%d",&l);
            b[i][j]=(double)l;
        }
    }
    for(i=1;i<=n;i++)
    {
        r=i;
        for(j=i+1;j<=n;j++)//找出最大的第r行 
        {
            if(fabs(b[j][i])>fabs(b[r][i]))
            {
                r=j;	
            }		
        }
        for(j=1;j<=n+1;j++)//交换第i行和第r行 
        {
            double tmp;
            tmp=b[i][j];
            b[i][j]=b[r][j];
            b[r][j]=tmp;
        }
        if(b[i][i]>-ex&&b[i][i]<ex)
        {
            printf("No Solution");
            return 0;
        }
        double div;
        div=b[i][i];
        for(j=i;j<=n+1;j++)//讲第i行元素中第i个化为1 
        {
            b[i][j]/=div;
        }
        for(j=1;j<=n;j++)//用第i行元素消除第i行 
        {
            double div=b[j][i];
            for(k=i;k<=n+1;k++)
            {
                if(i!=j)
                {
                    b[j][k]-=b[i][k]*div;
                }
            }
        }
    }
    for(i=1;i<=n;i++)
    {
        printf("%.2lf\n",b[i][n+1]);
    }
}
```


---

## 作者：_Weslie_ (赞：3)

高斯消元法是求解线性方程组的经典算法，它在当代数学中有着重要的地位和价值，是线性代数课程教学的重要组成部分。

## 0x01 高斯消元法解决的问题

给定一个形如下的线性方程组，对其求解。

$$ \begin{cases} a_{1, 1} x_1 + a_{1, 2} x_2 + \cdots + a_{1, n} x_n = b_1 \\ a_{2, 1} x_1 + a_{2, 2} x_2 + \cdots + a_{2, n} x_n = b_2 \\ \cdots \\ a_{n,1} x_1 + a_{n, 2} x_2 + \cdots + a_{n, n} x_n = b_n \end{cases}$$

这是一道非常经典的题目，即本题。

## 0x02 消元法

消元法是将方程组中的一方程的未知数用含有另一未知数的代数式表示，并将其带入到另一方程中，这就消去了一未知数，得到一解；或将方程组中的一方程倍乘某个常数加到另外一方程中去，也可达到消去一未知数的目的。消元法主要用于二元一次方程组的求解。

例如：在解二元一次方程组时，可以使用代入消元或者加减消元。

用代入消元举个例子：

$$
\begin{cases}
2x+y=16\\
y=8
\end{cases}
$$

将 $y=8$ 代入 $2x+y=16$，那么得出 $x=4$。

而多元的线性方程组，我们一般使用代入消元。

但是显然，我们要把方程组化成这个样子才可能使用代入消元：

$$
\begin{cases}
a_{1,1}x_1&+\ a_{1,2}x_2&+\cdots&+\ a_{1,n}x_n&=b_1\\
&\ \ \ \ a_{2,2}x_2&+\cdots &+\ a_{2,n}x_n&=b_2\\
&&&\ \cdots&\ =\cdots\\
&&&\ \ \ \ a_{n,n}x_n&=b_n
\end{cases}
$$

但是非常不幸的是，一般情况下，给出的方程是这样的：

$$ \begin{cases} a_{1, 1} x_1 + a_{1, 2} x_2 + \cdots + a_{1, n} x_n = b_1 \\ a_{2, 1} x_1 + a_{2, 2} x_2 + \cdots + a_{2, n} x_n = b_2 \\ \cdots \\ a_{n,1} x_1 + a_{n, 2} x_2 + \cdots + a_{n, n} x_n = b_n \end{cases}$$

所以我们要把下面的方程转化为上面的方程。

## 0x03 高斯消元法的线性代数基础

我们考虑丢掉未知量，把线性方程组的系数扔进一个矩阵里。

$$
\begin{bmatrix}
a_{1,1}&a_{1,2}&a_{1,3}&\cdots&a_{1,n}\\
a_{2,1}&a_{2,2}&a_{2,3}&\cdots&a_{2,n}\\
a_{3,1}&a_{3,2}&a_{3,3}&\cdots&a_{3,n}\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
a_{n,1}&a_{n,2}&a_{n,3}&\cdots&a_{n,n}
\end{bmatrix}
$$

但是仅仅凭这么一个矩阵是解不出这个线性方程组的。

所以我们需要一个增广矩阵（一组向量）。

这意味着，我们解题时需要用到这样的矩阵：

$$
\begin{bmatrix}
a_{1,1}&a_{1,2}&a_{1,3}&\cdots&a_{1,n}\\
a_{2,1}&a_{2,2}&a_{2,3}&\cdots&a_{2,n}\\
a_{3,1}&a_{3,2}&a_{3,3}&\cdots&a_{3,n}\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
a_{n,1}&a_{n,2}&a_{n,3}&\cdots&a_{n,n}
\end{bmatrix}
\begin{bmatrix}
b_1\\b_2\\b_3\\\vdots\\b_n
\end{bmatrix}
$$

合在一起，就是这样的：

$$
\begin{bmatrix}
a_{1,1}&a_{1,2}&a_{1,3}&\cdots&a_{1,n}&b_1\\
a_{2,1}&a_{2,2}&a_{2,3}&\cdots&a_{2,n}&b_2\\
a_{3,1}&a_{3,2}&a_{3,3}&\cdots&a_{3,n}&b_3\\
\vdots&\vdots&\vdots&\ddots&\vdots&\vdots\\
a_{n,1}&a_{n,2}&a_{n,3}&\cdots&a_{n,n}&b_n
\end{bmatrix}
$$

这样一个 $n\times (n+1)$ 的矩阵。

## 0x04 高斯消元法的理论依据

三条性质。

1. 交换律：将第 $i$ 个方程与第 $j$ 个方程互换，方程的解不变。体现在矩阵上，就是你可以随意互换两行。
2. 乘法律：将第 $i$ 个方程左右两边乘以一个非零实数 $k$，方程的解不变。体现在矩阵上，就是你可以将一行里的全部元素全都乘一个非零实数。
3. 加法律：将第 $i$ 个方程的左右边分别加上第 $j$ 个方程的左右边，方程的解不变。体现在矩阵上，就是你可以随意地把一行的所有元素加上另外一行的所有元素。

$2$ 和 $3$ 两条性质组合起来，就是性质 $4$：乘加律。其描述如下：对任意整数 $i,j\in[1,n]$，令所有 $a_{i,x}=k\times a_{i,x}+a_{j,x}$，方程的解不变。

## 0x05 高斯消元法的过程

根据上面 0x02 章节的分析，我们发现矩阵要消成如下的形式：

$$
\begin{bmatrix}
a_{1,1}'&a_{1,2}'&a_{1,3}'&\cdots&a_{1,n}'&b_1'\\
0&a_{2,2}'&a_{2,3}'&\cdots&a_{2,n}'&b_2'\\
0&0&a_{3,3}'&\cdots&a_{3,n}'&b_3'\\
\vdots&\vdots&\vdots&\ddots&\vdots&\vdots\\
0&0&0&\cdots&a_{n,n}'&b_n'
\end{bmatrix}
$$

这种矩阵我们叫做“上三角矩阵”。

而我们的终极目标是：

$$
\begin{bmatrix}
1&0&0&\cdots&0&b_1''\\
0&1&0&\cdots&0&b_2''\\
0&0&1&\cdots&0&b_3''\\
\vdots&\vdots&\vdots&\ddots&\vdots&\vdots\\
0&0&0&\cdots&1&b_n''\\
\end{bmatrix}
$$

### 0x05a 上三角矩阵

$$
\begin{bmatrix}
a_{1,1}&a_{1,2}&a_{1,3}&\cdots&a_{1,n}&b_1\\
a_{2,1}&a_{2,2}&a_{2,3}&\cdots&a_{2,n}&b_2\\
a_{3,1}&a_{3,2}&a_{3,3}&\cdots&a_{3,n}&b_3\\
a_{4,1}&a_{4,2}&a_{4,3}&\cdots&a_{4,n}&b_4\\
a_{5,1}&a_{5,2}&a_{5,3}&\cdots&a_{5,n}&b_5\\
\end{bmatrix}
$$

首先，我们将第 $1$ 行都除以 $a_{1,1}$。

$$
\begin{bmatrix}
1&\frac{a_{1,2}}{a_{1,1}}&\frac{a_{1,3}}{a_{1,1}}&\cdots&\frac{a_{1,n}}{a_{1,1}}&\frac{b_1}{a_{1,1}}\\
a_{2,1}&a_{2,2}&a_{2,3}&\cdots&a_{2,n}&b_2\\
a_{3,1}&a_{3,2}&a_{3,3}&\cdots&a_{3,n}&b_3\\
a_{4,1}&a_{4,2}&a_{4,3}&\cdots&a_{4,n}&b_4\\
a_{5,1}&a_{5,2}&a_{5,3}&\cdots&a_{5,n}&b_5\\
\vdots&\vdots&\vdots&\ddots&\vdots&\vdots
\end{bmatrix}
$$

然后，将第 $2$ 行减掉 $a_{2,1}$ 与当前新的第一行对应位置元素的乘积。

$$
\begin{bmatrix}
1&\frac{a_{1,2}}{a_{1,1}}&\frac{a_{1,3}}{a_{1,1}}&\cdots&\frac{a_{1,n}}{a_{1,1}}&\frac{b_1}{a_{1,1}}\\
0&a_{2,2}-\frac{a_{2,1}a_{1,2}}{a_{1,1}}&a_{2,3}-\frac{a_{2,1}a_{1,3}}{a_{1,1}}&\cdots& a_{2,n}-\frac{a_{2,1}a_{1,n}}{a_{1,1}} &b_2-\frac{a_{2,1}b_1}{a_{1,1}}\\
a_{3,1}&a_{3,2}&a_{3,3}&\cdots&a_{3,n}&b_3\\
a_{4,1}&a_{4,2}&a_{4,3}&\cdots&a_{4,n}&b_4\\
a_{5,1}&a_{5,2}&a_{5,3}&\cdots&a_{5,n}&b_5\\
\vdots&\vdots&\vdots&\ddots&\vdots&\vdots
\end{bmatrix}
$$

同理，对第 $3$ 到 $5$ 行做同样的操作。


$$
\begin{bmatrix}
1&\frac{a_{1,2}}{a_{1,1}}&\frac{a_{1,3}}{a_{1,1}}&\cdots&\frac{a_{1,n}}{a_{1,1}}&\frac{b_1}{a_{1,1}}\\
0&a_{2,2}-\frac{a_{2,1}a_{1,2}}{a_{1,1}}&a_{2,3}-\frac{a_{2,1}a_{1,3}}{a_{1,1}}&\cdots& a_{2,n}-\frac{a_{2,1}a_{1,n}}{a_{1,1}} &b_2-\frac{a_{2,1}b_1}{a_{1,1}}\\
0&a_{3,2}-\frac{a_{3,1}a_{1,2}}{a_{1,1}}&a_{3,3}-\frac{a_{3,1}a_{1,3}}{a_{1,1}}&\cdots& a_{3,n}-\frac{a_{3,1}a_{1,n}}{a_{1,1}} &b_3-\frac{a_{3,1}b_1}{a_{1,1}}\\
0&a_{4,2}-\frac{a_{4,1}a_{1,2}}{a_{1,1}}&a_{4,3}-\frac{a_{4,1}a_{1,3}}{a_{1,1}}&\cdots& a_{4,n}-\frac{a_{4,1}a_{1,n}}{a_{1,1}} &b_4-\frac{a_{4,1}b_1}{a_{1,1}}\\
0&a_{5,2}-\frac{a_{5,1}a_{1,2}}{a_{1,1}}&a_{5,3}-\frac{a_{5,1}a_{1,3}}{a_{1,1}}&\cdots& a_{5,n}-\frac{a_{5,1}a_{1,n}}{a_{1,1}} &b_5-\frac{a_{5,1}b_1}{a_{1,1}}\\
\vdots&\vdots&\vdots&\ddots&\vdots&\vdots
\end{bmatrix}
$$

为了方便，我们把矩阵记为 $a'$ 矩阵。

$$
\begin{bmatrix}
1&a_{1,2}'&a_{1,3}'&\cdots&a_{1,n}'&b_1'\\
0&a_{2,2}'&a_{2,3}'&\cdots&a_{2,n}'&b_2'\\
0&a_{3,2}'&a_{3,3}'&\cdots&a_{3,n}'&b_3'\\
0&a_{4,2}'&a_{4,3}'&\cdots&a_{4,n}'&b_4'\\
0&a_{5,2}'&a_{5,3}'&\cdots&a_{5,n}'&b_5'\\
\vdots&\vdots&\vdots&\ddots&\vdots&\vdots
\end{bmatrix}
$$

然后用第二行消第三行。

先把第二行除掉 $a_{2,2}'$。

$$
\begin{bmatrix}
1&a_{1,2}'&a_{1,3}'&\cdots&a_{1,n}'&b_1'\\
0&1&\frac{a_{2,3}'}{a_{2,2}'}&\cdots&\frac{a_{2,n}'}{a_{2,2}'
}&\frac{b_2'}{a_{2,2}'}\\
0&a_{3,2}'&a_{3,3}'&\cdots&a_{3,n}'&b_3'\\
0&a_{4,2}'&a_{4,3}'&\cdots&a_{4,n}'&b_4'\\
0&a_{5,2}'&a_{5,3}'&\cdots&a_{5,n}'&b_5'\\
\vdots&\vdots&\vdots&\ddots&\vdots&\vdots
\end{bmatrix}
$$

然后第三、四、五行减掉第二行乘 $a_{3,2}'$。

$$
\begin{bmatrix}
1&a_{1,2}'&a_{1,3}'&\cdots&a_{1,n}'&b_1'\\
0&1&\frac{a_{2,3}'}{a_{2,2}'}&\cdots&\frac{a_{2,n}'}{a_{2,2}'
}&\frac{b_2'}{a_{2,2}'}\\
0&0&a_{3,3}'-\frac{a_{2,3}'a_{3,2}'}{a_{2,2}'}&\cdots&a_{3,n}'-\frac{a_{2,n}'a_{3,2}'}{a_{2,2}'}&b_3'-\frac{b_2'a_{3,2}'}{a_{2,2}'}\\
0&0&a_{4,3}'-\frac{a_{2,3}'a_{4,2}'}{a_{2,2}'}&\cdots&a_{4,n}'-\frac{a_{2,n}'a_{4,2}'}{a_{2,2}'}&b_4'-\frac{b_2'a_{4,2}'}{a_{2,2}'}\\
0&0&a_{5,3}'-\frac{a_{2,3}'a_{5,2}'}{a_{2,2}'}&\cdots&a_{5,n}'-\frac{a_{2,n}'a_{5,2}'}{a_{2,2}'}&b_5'-\frac{b_2'a_{5,2}'}{a_{2,2}'}\\
\vdots&\vdots&\vdots&\ddots&\vdots&\vdots
\end{bmatrix}
$$

一直消元下去。

最后你会得到一个这样的矩阵（下面矩阵中 $a'$ 及 $b'$ 与上文不同）：

$$
\begin{bmatrix}
a_{1,1}'&a_{1,2}'&a_{1,3}'&\cdots&a_{1,n}'&b_1'\\
0&a_{2,2}'&a_{2,3}'&\cdots&a_{2,n}'&b_2'\\
0&0&a_{3,3}'&\cdots&a_{3,n}'&b_3'\\
\vdots&\vdots&\vdots&\ddots&\vdots&\vdots\\
0&0&0&\cdots&a_{n,n}'&b_n'
\end{bmatrix}
$$

恭喜你得到了上三角矩阵！

实际上，上面这些仅仅只是理论分析。具体实现上，我们仍然需要实际问题实际看。

举个例子：

$$
\begin{bmatrix}
12&24&18&36&72\\
6&12&8&4&2\\
3&6&2&4&9\\
2&4&9&12&24
\end{bmatrix}
$$

先第一行都除以 $12$。

$$
\begin{bmatrix}
1&2&\frac{3}{2}&3&6\\
6&12&8&4&2\\
3&6&2&4&9\\
2&8&9&12&24
\end{bmatrix}
$$

然后对后面几行乘加。

$$
\begin{bmatrix}
1&2&\frac{3}{2}&3&6\\
0&0&-1&-8&-34\\
0&0&-\frac{5}{2}&-5&-9\\
0&4&6&6&12
\end{bmatrix}
$$

问题出现了！第二行第二个数是 $0$！我们无法继续消元了！

别急。

还记得“交换律”吗？

我们只需要把第四行与第二行交换就可以继续啦！

$$
\begin{bmatrix}
1&2&\frac{3}{2}&3&6\\
0&1&\frac{3}{2}&\frac{3}{2}&3\\
0&0&-\frac{5}{2}&-5&-9\\
0&0&-1&-8&-34\\
\end{bmatrix}
$$

继续消元（这次消第三列）。

$$
\begin{bmatrix}
1&2&\frac{3}{2}&3&6\\
0&4&6&6&12\\
0&0&1&2&\frac{18}{5}\\
0&0&0&-5&-\frac{151}{5}\\
\end{bmatrix}
$$

最后是这样的：

$$
\begin{bmatrix}
1&2&\frac{3}{2}&3&6\\
0&4&6&6&12\\
0&0&1&2&\frac{18}{5}\\
0&0&0&1&\frac{151}{25}\\
\end{bmatrix}
$$

### 0x05b 答案矩阵

假设我们已经得到了这样一个“上三角矩阵”：

$$
\begin{bmatrix}
a_{1,1}&a_{1,2}&a_{1,3}&\cdots&a_{1,n}&b_1\\
0&a_{2,2}&a_{2,3}&\cdots&a_{2,n}&b_2\\
0&0&a_{3,3}&\cdots&a_{3,n}&b_3\\
\vdots&\vdots&\vdots&\ddots&\vdots&\vdots\\
0&0&0&\cdots&a_{n,n}&b_n
\end{bmatrix}
$$

考虑将其转化为下面的形式：

$$
\begin{bmatrix}
1&0&0&\cdots&0&b_1'\\
0&1&0&\cdots&0&b_2'\\
0&0&1&\cdots&0&b_3'\\
\vdots&\vdots&\vdots&\ddots&\vdots&\vdots\\
0&0&0&\cdots&1&b_n'\\
\end{bmatrix}
$$

首先，我们考虑把上面的矩阵转化成方程组形式。

那么最后一行对应的方程如下：

$$x_n=b_n$$

然后再看倒数第二行的方程：

$$x_{n-1}+a_{n-1,n}x_n=b_{n-1}$$

由于 $x_n$ 已经被解出来了，是已知量。所以可以移项，得到：

$$a_{n-1,n-1}x_{n-1}=b_{n-1}-a_{n-1,n}x_n$$

解得

$$x_{n-1}=b_{n-1}-a_{n-1,n}x_n$$

然后再看倒数第三行的方程：

$$x_{n-2}+a_{n-2,n-1}x_{n-1}+a_{n-2,n}x_n=b_{n-2}$$

解得

$$x_{n-2}=b_{n-2}-a_{n-2,n}x_n-a_{n-2,n-1}x_{n-1}$$

这样代入，可以解出所有的 $x_i$。

举个例子：假如我们消元消成了这样的“上三角矩阵”：

$$
\begin{bmatrix}
1&3&6&5&7&44\\
0&1&2&2&2&13\\
0&0&1&3&2&10\\
0&0&0&1&3&5\\
0&0&0&0&1&1\\
\end{bmatrix}

$$

那么：

先得出 $x_5=1$。

然后将 $x_5=1$ 代入方程 $x_4+3x_5=5$，得出 $x_4=2$。

然后将 $x_4=2,x_5=1$ 代入方程 $x_3+3x_4+2x_5=10$，得到 $x_3=2$。

然后将 $x_3=2,x_4=2,x_5=1$ 代入方程 $x_2+2x_3+2x_4+2x_5=13$，得到 $x_2=3$。

最后将 $x_2=3,x_3=2,x_4=2,x_5=1$ 代入方程 $x_1+3x_2+6x_3+5x_4+7x_5=44$ 中，得到 $x_1=6$。

最后解是：

$$
\begin{cases}
x_1&=6\\
x_2&=3\\
x_3&=2\\
x_4&=2\\
x_5&=1
\end{cases}
$$

完成！

## 0x06 无穷解与无解的判定

我们都知道，如果想要求一个 $n$ 元线性方程组的唯一解，那么必须要有 $n$ 个有意义的方程。

什么叫做无意义方程？

$$
\begin{cases}
4x_1&+5x_2&+6x_3&=3\\
2x_1&+3x_2&+3x_3&=6\\
7x_1&+8x_2&+9x_3&=9
\end{cases}
$$

第三个方程可以直接由前两个方程相加得到。所以第三个方程是“无意义”的。

如果在高斯消元的过程中，出现了 $0x=0$ 的情况，说明出现了无意义方程，那么就是无穷解。

如果出现了 $0x=k(k\ne 0)$ 的情况，就是无解。

## 0x07 代码实现

### 0x07a 小技巧

1. 在寻找某一行第 $i$ 位不为 $0$ 时，可以选择绝对值最大的一行。这样如果要判断无解或无穷解，直接判断绝对值最大的一行是否为 $0$ 即可。
2. 注意不要使用 $0$ 作为 $0$，而是一个极小常数——$10^{-7}$ 即可。

```
#include<bits/stdc++.h>
using namespace std;
double a[105][105];
double ans[105];
const double eps=1e-7;
int n;
double abss(double _) {
	if(_<0)return -_;
	return _;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n+1;j++)cin>>a[i][j];
	} 
	for(int i=1;i<=n;i++){
		int r=i;
		for(int j=i+1;j<=n;j++){
			if(abss(a[r][i])<abss(a[j][i]))r=j;//选择绝对值最大的一行
		} 
		if(abss(a[r][i])<eps){
			cout<<"No Solution";
			return 0;
		}
		if(i!=r)swap(a[i],a[r]);
		double div=a[i][i];
		for(int j=i;j<=n+1;j++)a[i][j]/=div;
		for(int j=i+1;j<=n;j++){
			div=a[j][i];
			for(int k=i;k<=n+1;k++){
				a[j][k]-=a[i][k]*div;
			}
		}
	}
	ans[n]=a[n][n+1];
	for(int i=n-1;i>=1;i--){
		ans[i]=a[i][n+1];
		for(int j=i+1;j<=n;j++){
			ans[i]-=(a[i][j]*ans[j]);
		}
	}
	for(int i=1;i<=n;i++){
		printf("%.2lf\n",ans[i]);
	}
	return 0;
}
```

## 0x08 高斯消元法的时间复杂度分析

根据上文分析及代码，是 $\operatorname{O}(n^3)$ 的。

如果有特殊矩阵，可以更低。

## 0x09 高斯消元法的应用

- 求解线性方程组，如 [P3389](https://www.luogu.com.cn/problem/P3389)、[P2455](https://www.luogu.com.cn/problem/P2455)。
- 转移有后效性 dp，如 [CF24D](https://www.luogu.com.cn/problem/CF24D)。

---

## 作者：Lijiangjun4 (赞：1)

[更好的阅读体验](https://www.cnblogs.com/Lijiangjun4/p/18927658)

**高斯消元**是一种在 $O(n^3)$ 的时间复杂度下解**线性方程组**的算法，方程组形如：
$$
\left\{
\begin{aligned}
&a_{1,1}x_{1}+a_{1,2}x_{2}+\dots+a_{1,n}x_{n}=b_1\\
&a_{2,1}x_{1}+a_{2,2}x_{2}+\dots+a_{2,n}x_{n}=b_2\\
&\dots\\

&a_{n,1}x_{1}+a_{n,2}x_{2}+\dots+a_{n,n}x_{n}=b_n
\end{aligned}
\right.
$$
# 算法思路
## 1. 高斯消元
发现线性方程组的系数和等号右侧的常数是解方程的关键，因此我们可以把系数和常数拎出来，形成一个矩阵。
比如：
$$
\left\{
\begin{aligned}
3x_1+7x_2+8x_3&=14\\
6x_1-x_2-2x_3&=7\\
-12x_1+x_2-x_3&=-10\\
\end{aligned}
\right.
$$
可以改写为：
$$
\left(
\begin{array}{ccc|c}
3& 7& 8& 14\\
6& -1& -2& 7\\
-12& 1& -1& -10
\end{array}
\right)
$$
这样的矩阵被称为**增广矩阵**。

回忆解多元一次方程组的过程，我们发现我们可以对方程组进行如下操作：

1. 交换任意两个方程的位置；
2. 将一个方程加上另一个方程；
3. 将整个方程乘上一个数。

对应到增广矩阵中，就是：

1. 交换任意两行；
2. 将某一行的数分别加上另一行对应的数；
3. 将某一行的所有数乘上同一个数。

高斯消元的目的，就是通过上面的三种操作，将增广矩阵变为形式如下的**上三角矩阵**，得到 $x_n$ 的值，然后依次代入得到整个方程的解：

$$
\left(
\begin{array}{ccc|c}
\times& \times& \times& \times\\
\times& \times& \times& \times\\
\times& \times& \times& \times
\end{array}
\right)
\Rightarrow
\left(
\begin{array}{ccc|c}
\times& \times& \times& \times\\
0& \times& \times& \times\\
0& 0& \times& \times
\end{array}
\right)
\Rightarrow
\left(
\begin{array}{ccc|c}
\times& 0& 0& \times\\
0& \times& 0& \times\\
0& 0& \times& \times
\end{array}
\right)
$$
考虑每次对一个未知数进行消元（即一列），设当前未知数为 $x_i$（第 $i$ 列），我们按照以下步骤消元：

#### 1. 无解判断
若这一列从第 $i$ 行往下都是 $0$，说明这个未知数无解或为任意解，判无解。
#### 2. 选主元
选择这一列从第 $i$ 行往下系数绝对值最大的那一个作为**主元**，将这一行与第 $i$ 行交换
比如：
$$\
\left(
\begin{array}{ccc|c}
3& 7& 8& 14\\
6& -1& -2& 7\\
-12& 1& -1& -10
\end{array}
\right)
\Rightarrow
\left(
\begin{array}{ccc|c}
\underline{3}& 7& 8& 14\\
\underline{6}& -1& -2& 7\\
\boxed{-12}& \underline{1}& \underline{-1}& \underline{-10}
\end{array}
\right)
\Rightarrow
\left(
\begin{array}{ccc|c}
-12& 1& -1& -10\\
6& -1& -2& 7\\
3& 7& 8& 14
\end{array}
\right)
$$
这一操作的目的是减少误差（原因见下文）。
#### 3. 消元
对于第 $j$ 行（$j>i$），为了使 $a_{j,i}$ 消为 $0$ ，我们需要将第 $j$ 行减去第 $i$ 行（主元行）的 $\frac{a_{j,i}}{a_{i,i}}$ 倍，这样 $a_{j,i}-a_{i,i}\times\frac{a_{j,i}}{a_{i,i}}=0$。

注意，消第 $i$ 个未知数时，只需要将第 $i$ 列第 $i$ 行下面的数消为 $0$ 即可。
$$
\begin{aligned}
&\left(
\begin{array}{ccc|c}
-12& 1& -1& -10\\
6& -1& -2& 7\\
3& 7& 8& 14
\end{array}
\right)\\
\Rightarrow
&\left(
\begin{array}{ccc|c}
\color{red}{-12}& \color{red}{1}& \color{red}{-1}& \color{red}{-10}\\
6-(\textcolor{red}{-12})\times\textcolor{blue}{\frac{6}{-12}}& -1-\textcolor{red}{1}\times\textcolor{blue}{\frac{6}{-12}}& -2-(\textcolor{red}{-1})\times\textcolor{blue}{\frac{6}{-12}}& 7-(\textcolor{red}{-10})\times\textcolor{blue}{\frac{6}{-12}}\\
3-(\textcolor{red}{-12})\times\textcolor{green}{\frac{3}{-12}}& 7-\textcolor{red}{1}\times\textcolor{green}{\frac{3}{-12}}& 8-(\textcolor{red}{-1})\times\textcolor{green}{\frac{3}{-12}}& 14-(\textcolor{red}{-10})\times\textcolor{green}{\frac{3}{-12}}
\end{array}
\right)\\
\Rightarrow
&\left(
\begin{array}{ccc|c}
-12& 1& -1& -10\\
\underline{0}& -0.5& -2.5& 2\\
\underline{0}& 7.25& 7.75& 11.5
\end{array}
\right)
\end{aligned}
$$

从左往右对每个未知数（每一列）进行以上三步操作，得到上三角矩阵：

$$
\left(
\begin{array}{ccc|c}
-12& 1& -1& -10\\
0& 7.25& 7.75& 11.5\\
0& 0& -\frac{114}{58}& \frac{81}{29}
\end{array}
\right)
$$

#### 4. 得到答案
将上三角矩阵写成方程式，有
$$
\left\{
\begin{aligned}
-12x_1+x_2-x_3&=-10\\
7.25x_2+7.75x_3&=11.5\\
-\frac{114}{58}x_3&=\frac{81}{29}
\end{aligned}
\right.
$$
发现最后一个未知数的解我们已经知道了，将解依次代回就可以得到方程组的解了。
$$
\left\{
\begin{aligned}
x_1&=\frac{-10-x_2+x_3}{-12}=1.210526\\
x_2&=\frac{11.5-7.75x_3}{7.25}=3.105263\\
x_3&=-1.421053\\
\end{aligned}
\right.
$$

#### 5.误差问题
考虑这样一组数据：
$$
\left\{
\begin{aligned}
0.3 \times 10^{-11}x_1+x_2&=0.7\\
x_1+x_2&=0.9
\end{aligned}
\right.
$$
如果以第一行为主元进行消元，则有：
$$
\left(
\begin{array}{cc|c}
0.3\times 10^{-11}& 1& 0.7\\
0& 1-\frac{10}{3}\times10^{11}\times1& 0.9-\frac{10}{3}\times10^{11}\times0.7
\end{array}
\right)
$$
会得到：
$$
\left\{
\begin{aligned}
x_1&=0.000000\\
x_2&=0.700000
\end{aligned}
\right.
$$
但如果以第二行为主元消元，则有：
$$
\left(
\begin{array}{cc|c}
1& 1& 0.9\\
0& 1-0.3\times10^{-11}\times1& 0.7-0.3\times10^{-11}\times0.9
\end{array}
\right)
$$
会得到：
$$
\left\{
\begin{aligned}
x_1&=0.200000\\
x_2&=0.700000
\end{aligned}
\right.
$$
明显更接近正解。

所以，在高斯消元中，应选择系数绝对值最大的一行作为主元行，使 $\frac{a_{j,i}}{a_{i,i}}$ 中的 $a_{i,i}$ 绝对值更大，原分数值更小，减少计算时的误差。

时间复杂度 $O(n^3)$。

### 模版代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
const double eps=1e-7;
int n;
double a[105][105],ans[105];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n+1;j++)
		{
			scanf("%lf",&a[i][j]);
		}
	}
	for(int i=1;i<=n;i++)//枚举消去的未知数
	{
		//找主元行 
		int maxn=i; 
		for(int j=i+1;j<=n;j++)
		{
			if(fabs(a[j][i])>fabs(a[maxn][i])) maxn=j;
		}
		
		//判无解
		if(fabs(a[maxn][i])<eps)
		{
			printf("No Solution\n");
			return 0;
		}
		
		//将主元行交换到第 i 行
		for(int j=1;j<=n+1;j++)
		{
			swap(a[i][j],a[maxn][j]);
		}
		
		//消元
		for(int j=i+1;j<=n;j++)
		{
			for(int k=n+1;k>=i;k--)//注意倒序，否则 a[j][i] 的值会被提前修改 
			{
				a[j][k]-=a[i][k]*(a[j][i]/a[i][i]);
			}
		}
	}
	
	//代回，得到答案
	for(int i=n;i>=1;i--)
	{
		ans[i]=a[i][n+1];
		for(int j=n;j>i;j--) ans[i]-=a[i][j]*ans[j];
		ans[i]/=a[i][i];
	}
	
	for(int i=1;i<=n;i++)
	{
		printf("%.2lf\n",ans[i]);
	}
	return 0;
}
```

## 2. 高斯-约旦消元法
别看名字很高大上，实际上就是高斯消元法的一个小优化。

刚刚的消元过程中，我们的增广矩阵的变化为：
$$
\left(
\begin{array}{ccc|c}
\times& \times& \times& \times\\
\times& \times& \times& \times\\
\times& \times& \times& \times
\end{array}
\right)
\Rightarrow
\left(
\begin{array}{ccc|c}
\times& \times& \times& \times\\
0& \times& \times& \times\\
0& 0& \times& \times
\end{array}
\right)
\Rightarrow
\left(
\begin{array}{ccc|c}
\times& 0& 0& \times\\
0& \times& 0& \times\\
0& 0& \times& \times
\end{array}
\right)
$$
而高斯-约旦消元法则是跳过上三角矩阵，直接得到答案。
$$
\left(
\begin{array}{ccc|c}
\times& \times& \times& \times\\
\times& \times& \times& \times\\
\times& \times& \times& \times
\end{array}
\right)
\Rightarrow
\left(
\begin{array}{ccc|c}
1& 0& 0& \times\\
0& 1& 0& \times\\
0& 0& 1& \times\\
\end{array}
\right)
$$
具体来讲，对于第 $i$ 个未知数，在选完主元行后，先将主元行整体除以 $a_{i,i}$ 使 $a_{i,i}$（即对角线）等于 $1$，然后将**每一行**都减去主元行的 $a_{j,i}$ 倍即可。

时间复杂度 $O(n^3)$。

### 模版代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
const double eps=1e-7;
int n;
double a[105][105],ans[105];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n+1;j++)
		{
			scanf("%lf",&a[i][j]);
		}
	}
	for(int i=1;i<=n;i++)//枚举消去的未知数
	{
		//找主元行 
		int maxn=i; 
		for(int j=i+1;j<=n;j++)
		{
			if(fabs(a[j][i])>fabs(a[maxn][i])) maxn=j;
		}
		
		//判无解
		if(fabs(a[maxn][i])<eps)
		{
			printf("No Solution\n");
			return 0;
		}
		
		//将主元行交换到第 i 行
		for(int j=1;j<=n+1;j++)
		{
			swap(a[i][j],a[maxn][j]);
		}
		
		//将 a[i][i] 消为 1
		for(int j=n+1;j>=i;j--) a[i][j]/=a[i][i]; 
		
		//消元
		for(int j=1;j<=n;j++)//注意！！从 1 开始，对每一行进行消元 
		{
			if(j!=i)
			for(int k=n+1;k>=i;k--)//注意倒序，否则 a[j][i] 的值会被提前修改 
			{
				a[j][k]-=a[i][k]*a[j][i];
			}
		}
	}
	
	//直接得到答案
	
	for(int i=1;i<=n;i++)
	{
		printf("%.2lf\n",a[i][n+1]);
	}
	return 0;
}
```

---

## 作者：chentianmiao (赞：1)

[原题链接](https://www.luogu.com.cn/problem/P3389)
## 思路分析
先介绍下高斯消元吧。

已知这样一个线性方程组：
$$ 
\begin{cases} a_{1, 1} x_1 + a_{1, 2} x_2 + \cdots + a_{1, n} x_n = b_1 \\ a_{2, 1} x_1 + a_{2, 2} x_2 + \cdots + a_{2, n} x_n = b_2 \\ \cdots \\ a_{n,1} x_1 + a_{n, 2} x_2 + \cdots + a_{n, n} x_n = b_n \end{cases}
$$
例如样例就是这样：
$$
\begin{cases} x+3y+4z=5 \\ x+4y+7z=3 \\ 9x+3y+2z=2 \end{cases}
$$
高斯消元可以理解为加减消元法，这里我们用第一个式子的 $x$ 消去另外两个式子的 $x$，得到：
$$
\begin{cases} x+3y+4z=5 \\ 0x+y+3z=-2 \\ 0x-24y-34z=-43 \end{cases}
$$
再用第二个式子的 $y$ 消去另外两个式子的 $y$，得到：
$$
\begin{cases} x+0y-5z=11 \\ 0x+y+3z=-2 \\ 0x+0y+38z=-91 \end{cases}
$$
再用第三个式子的 $z$ 消去另外两个式子的 $z$，得到：
$$
\begin{cases} x+0y+0z=- \frac{37}{38} \\ 0x+y+0z=\frac{197}{38}\\ 0x+0y+38z=-91 \end{cases}
$$
由此：
$$
\begin{cases} x=- \frac{37}{38} \\ y=\frac{197}{38}\\ z=- \frac{91}{38} \end{cases}
$$
以上就是高斯消元的流程。
## 原理讲解
操作共 $n$ 次，每次用 $x_i$ 系数最小的式字消去其他式子中的 $x_i$，选出来的式子与第 $i$ 个式子交换，这样第 $1$ 至第 $i$ 个式子都已经被选择过。显然，$n$ 次操作后，第 $i$ 个式子中仅剩余 $x_i$ 项。

那么题目中还有判断无数解或无解的情况。我们发现，当选出的式子的 $x_i$ 项的系数为 $0$ 时，式子为 $0 \times x_i=0$ 或 $0 \times x_i=b \space (b\in \mathbb Z^+)$，无法消去其他式子中的 $x_i$，那么这时候就可以判断它是无数解或无解。
## 代码实现
为了尽量减小误差，我们使用 long double 储存数据。

***注意！***
由于使用 long double 存储，必须注意精度问题！！！

例如，判断`A[r][i]==0`应该写作`fabs(A[r][i])<1e-7`，否则会挂掉。
## 复杂度
显然，消元时，会有三层循环，复杂度 $O(n^3)$。

那么最后送上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long double ld;
int n;
double A[109][109];
ld x[109];
void GJE(){
	int nR=n,nC=n;
	for(int i=1;i<=nR;i++){
		int r=i;
		for(int j=i+1;j<=nR;j++){
			if(fabs(A[j][i])>fabs(A[r][i])){
				r=j;
			}
		}
		if(fabs(A[r][i])<1e-7){
			cout<<"No Solution"<<endl;
			return;
		}
		if(r!=i){
			swap(A[i],A[r]);
		}
		for(int j=1;j<=nR;j++){
			if(j==i){
				continue;
			}
			ld factor=A[j][i]/A[i][i];
			A[j][i]=0;
			for(int k=i+1;k<=nC+1;k++){
				A[j][k]-=factor*A[i][k];
			}
		}
	}
	for(int i=1;i<=nC;i++){
		x[i]=A[i][n+1]/A[i][i];
	}
	for(int i=1;i<=nC;i++){
		printf("%.2Lf\n",x[i]);
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n+1;j++){
			cin>>A[i][j];
		}
	}
	GJE();
	return 0;
}
``````

---


# 小猴打架

## 题目描述

一开始森林里面有 $N$ 只互不相识的小猴子，它们经常打架，但打架的双方都必须不是好朋友。每次打完架后，打架的双方以及它们的好朋友就会互相认识，成为好朋友。经过 $N-1$ 次打架之后，整个森林的小猴都会成为好朋友。   
现在的问题是，总共有多少种不同的打架过程。   
比如当 $N=3$ 时，就有 $\{1-2,1-3\}\{1-2,2-3\}\{1-3,1-2\}\{1-3,2-3\}\{2-3,1-2\}\{2-3,1-3\}$ 六种不同的打架过程。 


## 说明/提示

$50\%$ 的数据 $N\le 10^3$。  
$100\%$ 的数据 $N\le10^6$。 

## 样例 #1

### 输入

```
4```

### 输出

```
96```

# 题解

## 作者：da32s1da (赞：37)

题目大意：**n个点，求构成生成树不同连接方式的方案数**

首先需要知道**prufer编码**相关知识。

由 **Cayley定理**，n个节点的带标号的形态不同的无根树有$n^{n-2}$个，然后对于每棵树，生成方式有$(n-1)!$种，答案=$(n-1)!*n^{n-2}$ $mod$ $9999991$
```
#include<cstdio>
#define mod 9999991
int n;long long ans=1;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n-2;i++) ans=(ans*n)%mod;
    for(int i=1;i<=n-1;i++) ans=(ans*i)%mod;
    printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：ghj1222 (赞：16)

prufer编码是啥?Cayley定理是啥?主不了解?

没事

让我们用矩阵树定理推一波

首先这个小猴打架最后会打成一棵树，这棵树是N个点的完全图的生成树

所以用矩阵树定理

构建矩阵(N个点的完全图)

这是我们的邻接矩阵

$\begin{vmatrix}0&1&1&\cdots&1\\1&0&1&\cdots&1\\1&1&0&\cdots&1\\\vdots&\vdots&\vdots&\ddots&\vdots\\1&1&1&\cdots&0\end{vmatrix}$

然后是我们的度数矩阵

$\begin{vmatrix}N-1&0&0&\cdots&0\\0&N-1&0&\cdots&0\\0&0&N-1&\cdots&0\\\vdots&\vdots&\vdots&\ddots&\vdots\\0&0&0&\cdots&N-1\end{vmatrix}$

所以说我们的基尔霍夫矩阵是N*N的下面矩阵：

$\begin{vmatrix}N-1&-1&-1&\cdots&-1\\-1&N-1&-1&\cdots&-1\\-1&-1&N-1&\cdots&-1\\\vdots&\vdots&\vdots&\ddots&\vdots\\-1&-1&-1&\cdots&N-1\end{vmatrix}$

然后我们开始大力跑代数余子式

划掉第N行第N列的元素得到一个(N-1)*(N-1)的矩阵：

$\begin{vmatrix}N-1&-1&-1&\cdots&-1\\-1&N-1&-1&\cdots&-1\\-1&-1&N-1&\cdots&-1\\\vdots&\vdots&\vdots&\ddots&\vdots\\-1&-1&-1&\cdots&N-1\end{vmatrix}$

注意这个矩阵是(N-1)*(N-1)的

然后对这个矩阵进行各种初等变换~~(初等乱搞)~~(以下方法参考《线性代数》)

我们先让第一行成为所有(N-1)行的和(初等变换第三条)

$\begin{vmatrix}1&1&1&\cdots&1\\-1&N-1&-1&\cdots&-1\\-1&-1&N-1&\cdots&-1\\\vdots&\vdots&\vdots&\ddots&\vdots\\-1&-1&-1&\cdots&N-1\end{vmatrix}$

然后让第2~(N-1)行都加上第一行(初等变换第三条)

$\begin{vmatrix}1&1&1&\cdots&1\\0&N&0&\cdots&0\\0&0&N&\cdots&0\\\vdots&\vdots&\vdots&\ddots&\vdots\\0&0&0&\cdots&N\end{vmatrix}$

消成了上三角矩阵（美滋滋）

所以行列式就是对角线元素相乘，有1个1，(N-2)个N

所以生成树个数为$N^{N-2}$

然后

考虑生成树的每一条边

小猴打架可以按照任意的顺序

所以每一种生成树的产生顺序就是他的边的排列个数，

有$(N-1)$条边所以排列为$(N-1)!$

所以最后答案是$N^{N-2}(N-1)!$

```
#include <bits/stdc++.h>
using namespace std;
#define p 9999991
long long n, ans = 1;

int main()
{
	scanf("%lld", &n);
	for (int i = 1; i <= n - 2; i++)
		ans = ans * n % p * (i + 1) % p;
	printf("%lld\n", ans);
	return 0;
}
```

让我们一起膜拜大佬林瑞堂@[olinr](https://www.luogu.org/space/show?uid=88460)

---

## 作者：DPair (赞：6)

//2019-05-15修正一处公式错误（感谢@Frame用户的指出）
## 这道题和[P4981](https://www.luogu.org/problemnew/show/P4981)异曲同工，只不过更为繁琐（~~简单~~），这里对于公式给出证明。

一句话题意，就是问你$n$个有编号的结点的无根生成树个数。

首先，我们知道对于一棵结点没有差异的有$n$个结点的无根树，其形态有$n^{n-2}$种。

证明在我在P4981的[题解](https://york2005.blog.luogu.org/solution-p4981)里面有。但是我还是不要脸的复制过来。（在最下面）

然后呢，对于每一种结点之间没有差异的树，给它的每一个结点打上编号一共有$n!$种方法。

所以答案就是很简单的
$$n ^ {n - 2} * (n-1)!$$
乘法原理推导即可。

```
#include<cstdio>

int n;
long long ans = 1;

int main()
{
    scanf("%d", &n);
    for(int i = 1;i <= n-2;i ++) ans = (ans * n) % 9999991;
    for(int i = 1;i <= n-1;i ++) ans = (ans * i) % 9999991;
    printf("%lld", ans);
}
```

## 【证明】（~~重点~~）
p.s 学习自https://www.cnblogs.com/dirge/p/5503289.html

首先引入$prufer$编码（这个单词的正确写法不是这样，但是很难打出来，以下以此代称）

一棵无根树的$prufer$编码的值运算如下：
```
首先定义无根树中度数为1的节点是叶子节点。
找到编号最小的叶子并删除，序列中添加与之相连的节点编号，重复执行直到只剩下2个节点。
```
（转载自https://www.cnblogs.com/dirge/p/5503289.html）

举个例子，对于下图的树
![](https://cdn.luogu.com.cn/upload/pic/58231.png)

它的$prufer$编码就是4, 3, 3

显然，一棵有$n$个结点的无根树，它的$prufer$编码是唯一的，且有$n-2$个可能相同的元素。

### 那么如何由一个$prufer$编码转化为二叉树？
那个博客上的巨佬是这么说的：
```
设点集V={1,2,3,...,n}，每次取出prufer序列中最前面的元素u，在V中找到编号最小的没有在prufer序列中出现的元素v，给u，v连边然后分别删除，最后在V中剩下两个节点，给它们连边。最终得到的就是无根树。
```
很显然，每一个$prufer$序列与一棵无根树一一对应。

因此，对于一棵已知有$n$个结点的无根树，一定有一个$n-2$长度的序列，那么，我们枚举所有长度为$n-2$的序列，发现其与所有可能形态的无根树一一对应。而这种序列，根据**乘法原理**，有
$$n ^{n - 2}$$
个可能的序列。

因此，对于一个已知的$n$，有$n^{n-2}$种不同的无根树。



---

## 作者：Terraria (赞：2)

## 题目大意：有 $n$ 个结点，问有多少种不同的方案使其组成一棵树。

做这道题我们只需要两个玩意儿——$Cayley$ 公式与 $prufer$ 编码：

由于打架的双方以及它们的好朋友就会互相认识，也就是说最后没架打的时候关系图会形成一棵有标号的无根树。直接应用 $Cayley$ 公式得到关系图数量就是 $n^{n-2}$。又因为题目还要求打架的顺序，就是形成关系图的连边顺序，而 $(n-1)$ 条边就是 $(n-1)!$ 。

因此，答案就是 $n^{n-2} \times (n-1)!$ $mod$ $9999991$。

同时记住——
## 1.答案要开 $long$ $long$ ！
## 2.每次计算都要取模！

~~（话说回来这道题最仁慈之处是居然不用打高精）~~

### Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long mod=9999991;
long long n,ans=1;
int main(){
	cin>>n;
	for(int i=1;i<=n-2;i++) ans=(ans*n)%mod;
	for(int i=1;i<=n-1;i++) ans=(ans*i)%mod;
	cout<<ans<<endl;
	return 0;
}
```
谢谢观看！

---

## 作者：UnyieldingTrilobite (赞：1)

好像没有pascal代码······给P党也发份福利。

~~我是CPP党！马蜂丑陋勿喷。~~

首先思路：

相当于原始为空的图。

每次加一条边，保证不形成环。

直到全部联通求加边方案数。

由于先加后加是一样的，不妨设为同时加~

~~小猴打群架。~~

最后再乘上$(n-1)!$

另外，没有环又连通，你想到了什么？

**树！！！**

没错，最终形成的一定是一棵树。

现在已经很清晰了，相当于$n$个点求构成树的数量。

相当于求$n$个点完全图生成树个数。

这个是有定理的（好像叫$Prufer$定理？），总个数为$n^{n-2}$.

大致证明思路就是把每棵生成树和一个长度为$n-2$,每个数可以取1到$n$的序列一一对应起来。

所以最后答案就是$(n-1)!\times n^{n-2}$

代码（Pascal）：
```pas
var n,ans,i:int64;
begin
    readln(n);
    ans:=1;
    for i:=1 to n-2 do ans:=(ans*n) mod 9999991;
    for i:=1 to n-1 do ans:=(ans*i) mod 9999991;
    writeln(ans);
end.
```
想要C++代码的可以去看其他dalao的题解。

Over.

---

## 作者：yangshurong (赞：1)

purfer序：
当不考虑树的边的生成顺序时，每个purfer序和每棵树对应，且唯一对应。

1.且存在每个点i在purfer序中出现的次数为du[i]-1（去点去到某个点只有一条边且这条边和他的父节点相连时，就不去这个点了） 

2.n个点的树的prufer序有n-2个点（这些点可以重复），
因此长度为n-2的purfer序有n^(n-2)种情况：n-2个位置，每个位置有n中选择。

这个purfer序对应的树有(n-1)条边,
如果还要考虑这棵树的生成顺序的话，
那就是n-1条边全排列：(n-1)!

所以答案是:(n-1)!* n^(n-2)%p

~~注意少用long long。慢！~~
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<stack>
#include<algorithm>
#include<cstring>
#include<vector>
#include<ctime>
#include<map>
#include<cstdlib>
#include<cmath>
#define r(i,a,b) for(int i=a;i<=b;i++)
#define rr(i,a,b) for(int i=a;i>=b;i--)
#define inf 0x3f3f3f3f
#define mem(a) memset(a,0x3f,sizeof(a))
#define re(a) a=read()
#define pr(a) printf("%d\n",a)
#define me(a) memset(a,0,sizeof(a))
#define in inline
#define ll long long
#define db double
using namespace std;
const int N=10007;
const int p=9999991;
inline int read(){
    char ch=getchar();
    int w=1,x=0;
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0',ch=getchar();}
    return x*w;
}
int n;
in int fac(int x){int ans=1;r(i,2,x)ans=1ll*ans*i%p;return ans;}//一行求阶乘
in int fast(int a,int b){int ans=1;for(;b;b>>=1,a=1ll*a*a%p)if(b&1)ans=1ll*ans*a%p;return ans;}//一行快速幂
int main(){
    re(n);
    printf("%d\n",1ll*fac(n-1)*fast(n,n-2)%p);
    return 0;
}




```


---

## 作者：yzx72424 (赞：1)

凯莱定理定理：不同的n节点标号树的数量为n^(n-2)。

以及它的推论生成方式有 (n-1)!种

证明的话需要知道prufer编码，自己百度搜博客看吧。
代码：

```
#include<bits/stdc++.h>
using namespace std;
int main(){
	unsigned long long m=1,x;
	long long mod=9999991;
    scanf("%lld",&x);
    for(long long i=2;i<=x-1;i++)m=((m*x)%mod*i)%mod;
    printf("%lld",m);
}
```

---

## 作者：AlanSP (赞：0)

### Description
> 求n个有标号点形成的树形成过程的方案数

---

很清新的一道计数题。

前置知识：[prufer编码](https://baike.baidu.com/item/prufer%E6%95%B0%E5%88%97/2182091?fr=aladdin)。

在n-2位prufer编码里，可以填 $[1,n]$ 的任意一个数。

总方案数 $n^{n-2}$。

又因为prufer编码唯一对应了一棵无根树。

也就是对应了一种树的形态。

但题目要求的是形成过程的方案数，那么来考虑对于一棵确定的树，形成过程的方案数。

**注意：树的形成过程关注的是边的顺序，而不是点。**

计算从哪个点开始是错误的，应该是枚举从那个边开始。

所以总方案：

$$
(n-1)!\times n^{n-2}
$$

代码就不贴了。

---

## 作者：_Andy_Lin_ (赞：0)

[博客传送门](https://www.luogu.com.cn/blog/linguosheng/)

------------
首先要知道cayley定理：n个节点的树的组成方式有n^n-2种。

------------
至于证明嘛：[prufer编码](https://baike.baidu.com/item/prufer%E6%95%B0%E5%88%97/2182091?fr=aladdin)


------------
可以看出prufer编码由n-2个数组成，每个都是n个数中的任意一种。所以prufer编码由n^n-2种，n个节点的树自然就有n^n-2种了。

------------
而这一题，相当于用n-1次打架将n只猴子变为好朋友，可以用cayley算出方案数。但这里顺序不同也是不同的打架方案。所以要将结果乘上n-1的阶乘。

------------
最后附上AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

#define mod 9999991ll
ll quick_mod(ll a,ll b){

	ll ans=1;
	for(;b;b>>=1){
		if(b&1){

			ans=(ans*a)%mod;
		}
		a=(a*a)%mod;
	}
	return ans;
}
ll js(ll n){
	ll ans=1;
	for(ll i=2;i<=n;i++){
		ans=(ans*i)%mod;
	}
	return ans;
}
ll n;
int main() {
	scanf("%lld",&n);

	printf("%lld\n",(quick_mod(n,n-2)*js(n-1))%mod);

}
```

最后再强调一点：一定要开long long。
------------
不然就会……[记录](https://www.luogu.com.cn/record/28355186)

------------
看一下就知道了。


---

## 作者：evenbao (赞：0)

简单题

由Cayley定理 ， n个点的无根树共有n ^ (n - 2)种不同的形 

态 ， 而由于对于每棵树 ， 每条边出现的顺序有(n - 1)!种 , 

故答案为n ^ (n - 2) * (n - 1)!

```cpp
#include<bits/stdc++.h>
using namespace std;

#ifndef LOCAL
	#define eprintf(...) fprintf(stderr , _VA_ARGS)
#else
	#define eprintf(...) 42
#endif

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef pair<int , int> pii;
typedef pair<ll , int> pli;
typedef pair<int , ll> pil;
typedef pair<ll , ll> pll;
#define mp make_pair
#define fi first
#define se second 
const int P = 9999991;

template <typename T> inline void chkmin(T &x , T y) { x = min(x , y); }
template <typename T> inline void chkmax(T &x , T y) { x = max(x , y); }
template <typename T> inline void read(T &x) {
   T f = 1; x = 0;
   char c = getchar();
   for (; !isdigit(c); c = getchar()) if (c == '-') f = -f;
   for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + c - '0';
   x *= f;
}

int main() {
	
	int n;
	read(n);
	int ans = 1;
	for (int i = 1; i <= n - 2; ++i) ans = 1ll * ans * n % P;
	for (int i = 1; i <= n - 1; ++i) ans = 1ll * ans * i % P;
	printf("%d\n" , ans);
	
    return 0;
}

```



---

## 作者：COUPDETAT (赞：0)

题意如上所述
### 求生成树的个数
这里需要知道Prüfer编码与Cayley公式

这个东西我想了好久

这里贴一篇我认为很容易理解的链接[prufer详解](http://www.matrix67.com/blog/archives/682)

选取一棵无根树 删除最小的叶子节点 直到只剩两个节点为止 这样就得到了prufer编码

任何一个Prüfer编码都唯一地对应了一棵无根树，有多少个n-2位的Prüfer编码就有多少个带标号的无根树（请看链接具体证明）

请大家牢记无根树的个数公式是(n-2)! / [ (D1-1)!(D2-1)!..(Dn-1)! ]

本题中生成无根树的生成方式有(n-1)!种

综上可得代码
```cpp
#include<iostream>
using namespace std;
//快速幂
long long ksm(long long a,long long b,long long p) {long long  ans=1;while (b) {if (b%2==1) ans=ans*a%p; a=a*a%p; b/=2;}return ans;}
int  main()
{
    long long b;
	cin>>b;
	long long  n=b;
	long long k=9999991;
	b=ksm(b,b-2,k); 
	for(long long  i=1;i<=n-1;i++)
		b=(b*i)%k;//边乘边mo	
	cout<<b;
	return 0;
}
```



---


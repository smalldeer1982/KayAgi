# 【模板】行列式求值

## 题目背景

模板题，无背景。

## 题目描述

给定一个 $n$ 阶行列式 $A$，求 $|A|$。结果对 $p$ 取模。

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le 600$，$1\le a_{i,j}< 10^9+7$，$1\le p\le 10^9+7$。

## 样例 #1

### 输入

```
2 998244353
1 4
1 5```

### 输出

```
1```

# 题解

## 作者：Reywmp (赞：125)

~~我也不知道为什么要学这个~~，不过线性代数相关的内容确实是计算机科学非常重要的知识。

# 关于行列式

前置芝士：[矩阵](https://oi-wiki.org/math/matrix/)和[高斯消元](https://oi-wiki.org/math/gauss/)。

## 行列式的定义

行列式 ($\texttt{Determinant}$) 是一个函数定义，取值是一个标量。

对一个 $n\times n$ 的矩阵 $A$（$n$ 阶方阵），其 $n$ 阶行列式写作 $\det(A)$ 或者 $|A|$，定义为：
$$
\det(A)=|A|=\sum_p(-1)^{\tau(p)}\prod_{i=1}^n a_{i,p_i}
$$
$p$ 表示一个排列，所有可能的 $p$ 则是 $1$ 到 $n$ 这 $n$ 个数的全排列。**$\tau(p)$ 表示一个排列 $p$ 的逆序对个数**。

行列式可以理解为所有列向量所夹的几何体的有向体积，这样可以结合从几何直观出发理解为线性变换的伸缩因子。

~~不过，这些都不重要！~~ 在 OI 中，我们最应该了解的，是如何高效地求出一个矩阵的行列式然后去做题。至于其更深层次的数学意义，交给数学家们吧。

---------------

## 关于排列的奇偶性

我们发现 $\tau(p)$ 的奇偶性对行列式求值起到了很大的影响，所以我们需要了解排列的奇偶性相关。

- 我们约定：如果 $\tau(p)$ 为奇数，则 $p$ 为一个奇排列，否则是一个偶排列；
- 对于一个 $n(n\geq2)$ 阶排列的所有排列情况，奇排列与偶排列的情况各 $\displaystyle \frac{1}{2}$；
- 对于排列 $p$ 我们交换其中的 $2$ 个元素，其余元素不边，会得到一个新的排列，这种操作叫**对换**；
- 一次对换会改变排列的奇偶性；
- 一个排列可以通过若干次对换变成一个元素严格递增的**自然排列**，对换次数的奇偶性与原排列的奇偶性相同。

-----------

## 行列式的性质与定理

行列式有着一些有助于我们做题的性质。

行列式的不变性从体积的几何意义上理解非常直观，但是我们这里不做讨论。

- 交换对应矩阵的 $2$ 行（列），行列式取反；$(1)$
- 交换 $1$ 行与 $1$ 列（进行一次**矩阵转置**），行列式不变；$(2)$

这两个性质的证明，可以考虑结合排列的奇偶性，然后直接重新带入公式观察。

- 行列式的行（列）所有元素等比例变化，则行列式也等比例变化；$(3)$

  - $$
    \begin{vmatrix}
    a_{1,1} &a_{1,2} &\cdots &a_{1,n}\\
    a_{2,1} &a_{2,2} &\cdots &a_{2,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    k\times a_{i,1} &k\times a_{i,2} &\cdots &k\times a_{i,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{n,1}&a_{n,2}&\cdots&a_{n,n}\\
    \end{vmatrix}
    =k\times
    \begin{vmatrix}
    a_{1,1} &a_{1,2} &\cdots &a_{1,n}\\
    a_{2,1} &a_{2,2} &\cdots &a_{2,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{i,1} &a_{i,2} &\cdots &a_{i,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{n,1}&a_{n,2}&\cdots&a_{n,n}\\
    \end{vmatrix}
    $$

- 如果行列式对应矩阵 $A$ 中有一行（列），是对应 $2$ 个矩阵 $B,C$ 中分别的 $2$ 行（列）所有元素之和。那么有 $\det(A)=\det(B)+\det(C)$；$(4)$

  - $$
    \begin{vmatrix}
    a_{1,1} &a_{1,2} &\cdots &a_{1,n}\\
    a_{2,1} &a_{2,2} &\cdots &a_{2,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    b_{i,1}+c_{i,1} &b_{i,2}+c_{i,2} &\cdots &b_{i,n}+c_{i,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{n,1}&a_{n,2}&\cdots&a_{n,n}\\
    \end{vmatrix}
    =
    \begin{vmatrix}
    a_{1,1} &a_{1,2} &\cdots &a_{1,n}\\
    a_{2,1} &a_{2,2} &\cdots &a_{2,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    b_{i,1} &b_{i,2} &\cdots &b_{i,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{n,1}&a_{n,2}&\cdots&a_{n,n}\\
    \end{vmatrix}
    +
    \begin{vmatrix}
    a_{1,1} &a_{1,2} &\cdots &a_{1,n}\\
    a_{2,1} &a_{2,2} &\cdots &a_{2,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    c_{i,1} &c_{i,2} &\cdots &c_{i,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{n,1}&a_{n,2}&\cdots&a_{n,n}\\
    \end{vmatrix}
    $$

- 如果一个矩阵存在两行（列）成比例则 $\det(A)=0$；$(5)$

  - $$
    \begin{vmatrix}
    a_{1,1} &a_{1,2} &\cdots &a_{1,n}\\
    a_{2,1} &a_{2,2} &\cdots &a_{2,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{i,1} &a_{i,2} &\cdots &a_{i,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    k\times a_{i,1} &k\times a_{i,2} &\cdots &k\times a_{i,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{n,1}&a_{n,2}&\cdots&a_{n,n}\\
    \end{vmatrix}=0
    $$

  - 这个证明可以直接代，但也有巧妙的办法：我们可以通过交换有比例关系的这两行得到新的矩阵 $A'$ $k\times a_{i,1}, k\times a_{i,2}, \cdots ,k\times a_{i,n}$ 现在就在上面的位置，一次交换使得 $\det(A)=-\det(A')$ ，我们通过 $(3)$ 将 $k$ 的比例变化放到行列式前，也就是 $A,A'$ 的 $k\times a_{i,1} k\times a_{i,2} \cdots k\times a_{i,n}$ 一行（列）变成 $a_{i,1},a_{i,2} \cdots ,a_{i,n}$，得到的新的矩阵分别是 $A'',A'''$ 我们发现 $A''=A'''$ 又有 $k\times |A''|=|A|=-k\times |A'''|=-|A'|$，一个数等于其相反数，所以有 $|A|=0$；

- 把一个矩阵的一行（列）的值全部乘一个常数加到另一行（列）上，行列式值不变。$(6)$

  - $$
    \begin{vmatrix}
    a_{1,1} &a_{1,2} &\cdots &a_{1,n}\\
    a_{2,1} &a_{2,2} &\cdots &a_{2,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{i,1} &a_{i,2} &\cdots &a_{i,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{j,1}+k\times a_{i,1} &a_{j,2}+k\times a_{i,2} &\cdots &a_{j,2}+k\times a_{i,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{n,1}&a_{n,2}&\cdots&a_{n,n}\\
    \end{vmatrix}
    =
    \begin{vmatrix}
    a_{1,1} &a_{1,2} &\cdots &a_{1,n}\\
    a_{2,1} &a_{2,2} &\cdots &a_{2,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{i,1} &a_{i,2} &\cdots &a_{i,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{j,1} &a_{j,2} &\cdots &a_{j,2}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{n,1}&a_{n,2}&\cdots&a_{n,n}\\
    \end{vmatrix}
    $$

  - 证明也很简单，根据 $(4)$ 有：

  - $$
    \begin{vmatrix}
    a_{1,1} &a_{1,2} &\cdots &a_{1,n}\\
    a_{2,1} &a_{2,2} &\cdots &a_{2,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{i,1} &a_{i,2} &\cdots &a_{i,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{j,1}+k\times a_{i,1} &a_{j,2}+k\times a_{i,2} &\cdots &a_{j,2}+k\times a_{i,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{n,1}&a_{n,2}&\cdots&a_{n,n}\\
    \end{vmatrix}
    =
    \begin{vmatrix}
    a_{1,1} &a_{1,2} &\cdots &a_{1,n}\\
    a_{2,1} &a_{2,2} &\cdots &a_{2,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{i,1} &a_{i,2} &\cdots &a_{i,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{j,1} &a_{j,2} &\cdots &a_{j,2}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{n,1}&a_{n,2}&\cdots&a_{n,n}\\
    \end{vmatrix}+\begin{vmatrix}
    a_{1,1} &a_{1,2} &\cdots &a_{1,n}\\
    a_{2,1} &a_{2,2} &\cdots &a_{2,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{i,1} &a_{i,2} &\cdots &a_{i,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    k\times a_{i,1} &k\times a_{i,2} &\cdots &k\times a_{i,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{n,1}&a_{n,2}&\cdots&a_{n,n}\\
    \end{vmatrix}
    $$

  - $\because (5)$

  - $$
    \therefore \begin{vmatrix}
    a_{1,1} &a_{1,2} &\cdots &a_{1,n}\\
    a_{2,1} &a_{2,2} &\cdots &a_{2,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{i,1} &a_{i,2} &\cdots &a_{i,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{j,1}+k\times a_{i,1} &a_{j,2}+k\times a_{i,2} &\cdots &a_{j,2}+k\times a_{i,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{n,1}&a_{n,2}&\cdots&a_{n,n}\\
    \end{vmatrix}
    =
    \begin{vmatrix}
    a_{1,1} &a_{1,2} &\cdots &a_{1,n}\\
    a_{2,1} &a_{2,2} &\cdots &a_{2,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{i,1} &a_{i,2} &\cdots &a_{i,n}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{j,1} &a_{j,2} &\cdots &a_{j,2}\\
    \vdots &\vdots &\ddots &\vdots\\
    a_{n,1}&a_{n,2}&\cdots&a_{n,n}\\
    \end{vmatrix}+0
    $$

-------------

# 行列式求值

那么知道了行列式这样一些性质，怎样在 OI 中高效地去求行列式呢。

直接根据定义计算，行列式求值是 $\Theta(n\times n!)$ 的。显然太高了。

有上面这些性质我们怎么该将问题简化呢。

-----------

## 消元

我们考虑一个情况，当一个矩阵任意一个位置出现 $0$，其对行列式的影响非常大。

因为我们考虑公式中 $\displaystyle\prod_{i=1}^n a_{i,p_i}$ 一项，一旦选到 $0$ 整个 $p$ 在 $\displaystyle \sum_p$ 中就没有贡献了。

我们利用上面的一些性质显然是可以让矩阵不断变化出现 $0$ 的。运用定理 $(1),(3),(4)$ 就可以做到。

显然瞎转化肯定是不行的，我们要让运算次数尽可能少。

如果学习了前置知识。我们知道求解线性方程组的算法**高斯消元**。其实高斯消元在做**增广矩阵行（初等）变换为行最简形**时的步骤和我们的转化有异曲同工之妙。

我们现在考虑将矩阵一行（列）消成只有最后一个元素非 $0$ 该怎么做。也就是说：
$$
A=\begin{bmatrix}
a_{1,1} & a_{1,2} & a_{1,3} & \cdots &a_{1,n}\\
a_{2,1} & a_{2,2} & a_{2,3} & \cdots &a_{2,n}\\
a_{3,1} & a_{3,2} & a_{3,3} & \cdots &a_{3,n}\\
\vdots & \vdots & \vdots & \ddots & \vdots\\
a_{n,1} & a_{n,2} & a_{n,3} & \cdots &a_{n,n}\\
\end{bmatrix}\Rightarrow
\begin{bmatrix}
a_{1,1} & a_{1,2} & a_{1,3} & \cdots &a_{1,n}\\
a_{2,1} & a_{2,2} & a_{2,3} & \cdots &a_{2,n}\\
a_{3,1} & a_{3,2} & a_{3,3} & \cdots &a_{3,n}\\
\vdots & \vdots & \vdots & \ddots & \vdots\\
0 & 0 & 0 & \cdots &a_{n,n}\\
\end{bmatrix}
$$
对于 $1$ 到第 $n-1$ 列中的第 $i$ 列，我们只需要让第 $i$ 列整列加上第 $n$ 列的 $\displaystyle-\frac{a_{n,i}}{a_{n,n}}$ 倍就可以在 $\det(A)$ 不变的情况下使得整行前 $n-1$ 个元素被消掉。

--------

## 代数余子式求值

消元有什么用呢，我们引入线性代数中帮助我们求行列式的一个概念——**代数余子式**。

在一个 $n$ 阶行列式 $D$ 中选定 $k$ 行 $k$ 列可以组成一个 **$k$ 阶子行列式 $A$**；

删除在 $k$ 行 $k$ 列后剩下的 $n-k$ 阶行列式称为 $A$ 对应的 **$n-k$ 阶余子式 $M$**。

设 $A$ 在 $D$ 中原来的元素行下标有集合 $\mathbb I=\{i_1,i_2 ,\dots ,i_k\}$ 列下标有集合 $\mathbb J=\{j_1,j_2 ,\dots ,j_k\}$，则有 $\displaystyle(-1)^{\displaystyle(i_1+i_2+\dots+i_k)(j_1+j_2+\dots+j_k)}\times \det(M)$ 为 $n$ 阶行列式 $D$ 的 $k$ 阶子式 $A$ 的**代数余子式**。

对于单一元素 $a_{i,j}$ 我们令其代数余子式为 $A_{i,j}$ ，余子式为 $M_{i,j}$ 。有 $A_{i,j}=(-1)^{i+j}M_{i,j}$。

我们有如下命题：

- $n$ 阶行列式 $D$ 等于其任意一行（列）所有元素与其对应代数余子式的乘积之和。

  - $$
    D=\sum_{j=1}^na_{i,j}\times A_{i,j},(i\in[1,n])
    $$

  - $$
    D=\sum_{i=1}^na_{i,j}\times A_{i,j},(j\in[1,n])
    $$

- $n$ 阶行列式 $D$ 的任意一行（列）余另不同的一行（列）对应元素的代数余子式之和为 $0$。

  - $$
    \sum_{k=1}^na_{i,k}\times A_{j,k}=0,(i,j\in[1,n],i\neq j)
    $$

  - $$
    \sum_{k=1}^na_{k,i}\times A_{k,j}=0,(i,j\in[1,n],i\neq j)
    $$

-----------

## 求值

我们回到刚才最后一行消元后的情况。运用第一个命题我们发现 $D$ 的值只是 $a_{n,n}\times A_{n,n}$。这个时候如果我们继续对 $A_{n,n}$ 做同样的消元呢？
$$
\begin{vmatrix}
\color{red}a_{1,1} & \color{red}a_{1,2} & \color{red}a_{1,3} & \color{red}\cdots &\color{red}a_{1,n-1} &a_{1,n}\\
\color{red}a_{2,1} & \color{red}a_{2,2} & \color{red}a_{2,3} & \color{red}\cdots &\color{red}a_{2,n-1} &a_{2,n}\\
\color{red}a_{3,1} &\color{red} a_{3,2} &\color{red} a_{3,3} &\color{red} \cdots &\color{red}a_{3,n-1} &a_{3,n}\\
\color{red}\vdots & \color{red}\vdots & \color{red}\vdots & \color{red}\ddots &\color{red} \vdots &\vdots\\
\color{red}a_{n-1,1} &\color{red} a_{n-1,2} & \color{red}a_{n-1,3} & \color{red}\cdots &\color{red}a_{n-1,n-1} &a_{n,n-1}\\
a_{n,1} & a_{n,2} & a_{n,3} & \cdots &a_{n,n-1} &a_{n,n}\\
\end{vmatrix}
$$
也就是说如果对于这个 $n-1$ 阶的红色余子式继续做消元使得其变成：
$$
\begin{vmatrix}
\color{red}a_{1,1} & \color{red}a_{1,2} & \color{red}a_{1,3} & \color{red}\cdots &\color{red}a_{1,n-1} \\
\color{red}a_{2,1} & \color{red}a_{2,2} & \color{red}a_{2,3} & \color{red}\cdots &\color{red}a_{2,n-1}\\
\color{red}a_{3,1} &\color{red} a_{3,2} &\color{red} a_{3,3} &\color{red} \cdots &\color{red}a_{3,n-1} \\
\color{red}\vdots & \color{red}\vdots & \color{red}\vdots & \color{red}\ddots &\color{red} \vdots \\
0 & 0 & 0 & \color{red}\cdots &\color{red}a_{n-1,n-1}\\
\end{vmatrix}
$$
我们发现之前余子式 $A_{n,n}$ 又只等于 $a_{n-1,n-1}\times A_{n-1,n-1}$。

以此类推，如果我们一直：

- 对当前行列式消元

- 取最末（右下角）位的指和其余子式，余子式作为新行列式重新做；

$$
\begin{vmatrix}
\color{orange}a_{1,1} & \color{green}a_{1,2} & \color{blue}a_{1,3} & \color{red}\cdots &\color{red}a_{1,n-1} &a_{1,n}\\
\color{green}a_{2,1} & \color{green}a_{2,2} & \color{blue}a_{2,3} & \color{red}\cdots &\color{red}a_{2,n-1} &a_{2,n}\\
\color{blue}a_{3,1} &\color{blue} a_{3,2} &\color{blue} a_{3,3} &\color{red} \cdots &\color{red}a_{3,n-1} &a_{3,n}\\
\color{red}\vdots & \color{red}\vdots & \color{red}\vdots & \color{red}\ddots &\color{red} \vdots &\vdots\\
\color{red}a_{n-1,1} &\color{red} a_{n-1,2} & \color{red}a_{n-1,3} & \color{red}\cdots &\color{red}a_{n-1,n-1} &a_{n,n-1}\\
a_{n,1} & a_{n,2} & a_{n,3} & \cdots &a_{n,n-1} &a_{n,n}\\
\end{vmatrix}
$$

按不同颜色一直递归下去做，我们发现最后我们得到
$$
\begin{vmatrix}
\color{orange}a_{1,1} & \color{green}a_{1,2} & \color{blue}a_{1,3} & \color{red}\cdots &\color{red}a_{1,n-1} &a_{1,n}\\
0 & \color{green}a_{2,2} & \color{blue}a_{2,3} & \color{red}\cdots &\color{red}a_{2,n-1} &a_{2,n}\\
0 &0 &\color{blue} a_{3,3} &\color{red} \cdots &\color{red}a_{3,n-1} &a_{3,n}\\
\color{red}\vdots & \color{red}\vdots & \color{red}\vdots & \color{red}\ddots &\color{red} \vdots &\vdots\\
0 &0 & 0 & \color{red}\cdots &\color{red}a_{n-1,n-1} &a_{n,n-1}\\
0 & 0 & 0 & \cdots &0 &a_{n,n}\\
\end{vmatrix}
$$
这样的一个下三角行列式。

我们就会发现这样一个矩阵的行列式是其对角线所有元素的乘积，也就是 $\displaystyle\prod_{i=1}^na_{i,i}$。

这样就可以做了。

实现的时候有一些细节：

- 每次取新的余子式的时候需要注意奇偶性，及时变化正负，因为记得代数余子式是要乘上一个 $(-1)^{(i_1+i_2+\dots+i_k)(j_1+j_2+\dots+j_k)}$ 的；

- 如果题目要求 $\bmod p$ 情况下的行列式，有些数是不一定有逆元的，或者说消元的时候精度出问题，我们可以考虑对两行（列）做辗转相减消元。

  - $$
    \begin{bmatrix}
    10 & a_{1,2} & a_{1,3} & \cdots &a_{1,n}\\
    4 & a_{2,2} & a_{2,3} & \cdots &a_{2,n}\\
    a_{3,1} & a_{3,2} & a_{3,3} & \cdots &a_{3,n}\\
    \vdots & \vdots & \vdots & \ddots & \vdots\\
    a_{n,1} & a_{n,2} & a_{n,3} & \cdots &a_{n,n}\\
    \end{bmatrix}
    $$

  - 对于这样的情况，求 $a_{1,1}=a_{1,1}\bmod a_{2,1}$

  - 有 $\begin{bmatrix}2\\4\\\end{bmatrix}$（我们现在只考虑这两个位置）

  - `swap(a[1][1],a[2][1])`

  - 有 $\begin{bmatrix}4\\2\\\end{bmatrix}$

  - 再做 $a_{1,1}=a_{1,1}\bmod a_{2,1}$

  - 有 $\begin{bmatrix}0\\2\\\end{bmatrix}$

  - `swap(a[1][1],a[2][1])`

  - 有 $\begin{bmatrix}2\\0\\\end{bmatrix}$ 

  - 这样分别解决了精度，逆元的一些问题。

消元操作是 $\Theta(n^3)$ 的，辗转相除法是 $\Theta(\log p)$ 的，因为辗转相除和消元每次必然使得数变小，势能只会减少，所以这个是均摊到 $\Theta(n^2)$ 的，最终有复杂度 $\Theta(n^2\log n+n^3)$。

----------

## 代码

```cpp
#include<bits/stdc++.h>

#define INL inline
#define ll long long 

using namespace std;

const int N=605;

int n,a[N][N],MOD;

INL int read()
{
	int x=0,w=1;char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	if(ch=='-')w=-1,ch=getchar();
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+ch-48,ch=getchar();
	return x*w;
}

INL int sol()
{
	int res=1,w=1;
	for(int i=1;i<=n;i++)
	{ 
		for(int j=i+1;j<=n;++j)
		{
    		while(a[i][i])
			{
     	    	int div=a[j][i]/a[i][i];
        		for(int k=i;k<=n;++k)
				{
        		    a[j][k]=(a[j][k]-1ll*div*a[i][k]%MOD+MOD)%MOD;
        		}
        		swap(a[i],a[j]);w=-w;
    		}//对第 i 行和第 j 行做辗转相减。	
    		swap(a[i],a[j]);w=-w;
		}
	}
	for(int i=1;i<=n;i++)res=1ll*a[i][i]*res%MOD;
	res=1ll*w*res;
	return (res+MOD)%MOD;//经 典 模 加 模
}

int main()
{
	n=read(),MOD=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			a[i][j]=read();
	int ans=sol();printf("%d\n",ans);
	return 0;
}
```
-------------
$$
\text{Determinant}\texttt{——2021.03.21} \text{写在机房}
$$

---------------

Reference：

> - $\text{Zhaoyuhang2008}$ - [题解 P7112 【【模板】行列式求值】](https://www.luogu.com.cn/blog/242524/solution-p7112)

---

## 作者：SSerxhs (赞：52)

前置知识：行列式的性质、最大公约数

行列式定义式：

$\sum\limits_{p}(-1)^{\tau(p)}\prod\limits_{i=1}^na_{i,p_i} $，其中 $p$ 是一个排列，$\tau(p)$ 指的是 $p$ 中的逆序对数

行列式的性质：交换任意两行（列）结果变为相反数，一行加上另一行乘常数结果不变，一行同乘 $k$ 结果也乘 $k$

这个性质和高斯消元柿子相加相减非常相似，所以行列式求值也是用消元法。

具体地，枚举第 $i$ 行，找到第 $i$ 行某个非 $0$ 元素并将该列与第 $i$ 列交换，然后把 $a_{i,i}$ 变为 $1$ ，再用这一行消剩下所有行的第 $i$ 列即可。

然而 $a_{i,i}$ 在模 $p$ 意义下不一定有逆元。考虑到可以任意相减，这个性质和辗转相除法很相似，可以考虑对两行进行辗转相除，这样一定可以消掉某行第 $i$ 列。

感性分析一下复杂度：消元 $O(n^3)$，辗转相除 $O(\log p)$，总复杂度 $O(n^3\log p)$。

~~600 的数据范围这怎么跑~~

于是你点开了题解，看看有什么卡 $\log $ 高论

~~然而并没有~~

复杂度其实是 $O(n^3)$。

每次做两次消元 $a_{i,i}$ 至少会变为原来的一半，而这个势能是不会上升的，均摊下去复杂度为 $O(n^2(\log p+n))$ 。

```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=602;
inline void read(register int &x)
{
	register int c=getchar();
	while ((c<48)||(c>57)) c=getchar();
	x=c^48;c=getchar();
	while ((c>=48)&&(c<=57))
	{
		x=x*10+(c^48);
		c=getchar();
	}
}
int a[N][N];
int n,p,i,j;
int cal(int a[][N],register int n,const int p)
{
	register int i,j,k,r=1,fh=0,l;
	for (i=1;i<=n;i++)
	{
		k=i;
		for (j=i;j<=n;j++) if (a[j][i]) {k=j;break;}
		if (a[k][i]==0) return 0;
		for (++j;j<=n;j++) if (a[j][i]&&a[j][i]<a[k][i]) k=j;
		if (i!=k) {swap(a[k],a[i]);fh^=1;}
		for (j=i+1;j<=n;j++)
		{
			if (a[j][i]>a[i][i]) {swap(a[j],a[i]);fh^=1;}
			while (a[j][i])
			{
				l=a[i][i]/a[j][i];
				for (k=i;k<=n;k++) a[i][k]=(a[i][k]+(ll)(p-l)*a[j][k])%p;
				swap(a[j],a[i]);fh^=1;
			}
		}
		r=(ll)r*a[i][i]%p;
	}
	if (fh) return (p-r)%p;
	return r;
}
int main()
{
	read(n);read(p);
	for (i=1;i<=n;i++) for (j=1;j<=n;j++) {read(a[i][j]);a[i][j]%=p;}
	printf("%d",cal(a,n,p));
}
```

---

## 作者：lemon_qwq (赞：31)

~~谁家好人学线性代数啊~~。

感谢 smeow 老师让我理解行列式。

本篇题解讲的比较细，小学生应该都能看懂。

## 行列式有啥用

行列式的初衷其实是为了解线性方程组。

对于有唯一解的多元线性方程组，未知数越多，解起来就会越晕。

而行列式，就可以简化线性方程组。

## 矩阵

你可以理解矩阵就是个二维数组。

$$A=\begin{bmatrix} a_{1,1} & a_{1,2} & \dots & a_{1,m} \\ a_{2,1} & a_{2,2} & \dots & a_{2,m} \\ \vdots &\vdots &\ddots &\vdots \\a_{n,1}&a_{n,2}&\dots&a_{n,m} \end{bmatrix}$$

这就是一个矩阵。

矩阵有代表行数和列数的 $n,m$ 和矩阵里的元素 $a_{i,j}$。

特别的，如果 $n=m$，我们称这个矩阵为方阵，我们本题只考虑方阵。

## 初等行列变换

初等行列变换为合法改变矩阵的方法。

初等行列变换有三种：

1. 交换任意两行或两列。
1. 某一行增加另一行的任意倍或某一列增加另一列的任意倍。
1. 某一行或某一列乘一个数，这个数不能为 $0$。

那么这个数为什么不能为 $0$ 呢？

因为初等行列变换必须是可逆的。

比如有一个矩阵长这样：

$$A=\begin{bmatrix} 1&1&4&5&1&4\\1&9&1&9&8&1 \end{bmatrix}$$

我们把第一行和第二行交换，再交换回来就会恢复原来的样子。

我们把第一行增加第二行的 $2$ 倍，再让第一行增加第二行的 $-2$ 倍也会恢复原来的样子。

我们把第一行乘上 $114$，再乘上 $\frac{1}{114}$ 同样可以恢复原来的样子。

但是如果我们把第一行乘上 $0$，你会发现无论你怎么操作这个矩阵都不会恢复原样。

## 上三角矩阵

什么是上三角矩阵：

以 $(1,1)$ 到 $(n,n)$ 的对角线为界，左下全都是 $0$ 的矩阵就是上三角矩阵。（对角线除外）

$$
A=\begin{bmatrix}
a_{1,1} & \dots & a_{1,n}\\
  & \ddots & \vdots\\
0 & & a_{n,n}
\end{bmatrix}_{n \times n}
$$

上图便是一个上三角矩阵。

## 最简形矩阵

只有对角线不是 $0$ 的矩阵被称为最简形矩阵，在高斯消元的部分我们会更仔细的介绍它。

## 高斯消元

高斯消元这个名字听起来挺高级，其实就是我们数学中常见的加减消元法。

详细点说，高斯消元就是利用矩阵初等行列变换将矩阵简化的过程。

第一步，把这个矩阵变成上三角矩阵。

大家可以思考一下，怎么操作才能把这个矩阵变成上三角矩阵？

我们从上至下消即可。

第一行不要求有数是 $0$，所以把第一行乘一个数使它的第一个数等于第二行的第一个数。

第二行减等第一行。

然后第二行的第一个数就变成 $0$ 了。

因为 $0$ 乘任何数都是 $0$，所以我们继续进行此操作向下就一定可以得到上三角矩阵。

复杂度为 $O(n^3)$。

对于本题，我们并不需要继续把矩阵变成最简形矩阵，不过我还是提一嘴。

从 $(n,n)$ 到 $(1,1)$ 枚举对角线，若 $(x,x)$ 为 $0$ 则不管，若不为 $0$：

1. 通过某行乘 $k$ 的操作使得该值为 $1$。
1. 通过某行加 $k$ 乘其他行操作将本列其他位置消成 $0$。

复杂度也是 $O(n^3)$。

这就是高斯消元的终点了。

## 行列式

回到本题，行列式的定义为：

$$\sum_{p}{(-1)^{\tau(p)}\prod_{i=1}^{n}{a_i,p_i}}$$

我们定义 $\tau(p)$ 为一个排列 $p$ 的逆序对个数。

唔，好像直接算复杂度爆炸。

因为行列式求值是 $O(n\times n!)$ 的。

那么怎么化简呢？

上文已经说了，所有 $n\times n$ 的矩阵都可以消元成上三角矩阵。

这样的话这个矩阵的行列式就变成了对角线所有元素的乘积。

但是，初等行列变换会改变行列式，但是有几个规律：

1. 交换对应矩阵的 $2$ 行或列，行列式取反。
1. 某一行加上若干倍的另外一行，行列式不变。
1. 某一行乘一个数，行列式也乘那个数。

这几个规律我就不证明了，感兴趣可以看其他题解。

我们记录一下高斯消元的过程进行了哪些操作，$O(n)$ 算出上三角矩阵的行列式后反推原始矩阵的行列式即可。

## 本题坑点

代码实现不难，就是坑点较多。

1. $p$ 不一定为质数，如果直接求逆元只会有 $58$ 分。
1. 在输入矩阵的时候也需要把矩阵的元素模 $p$，不然会炸。
1. 没法消元要输出 $0$，不要直接结束程序。

~~这三个都是我踩过的坑~~。

完结撒花！

---

## 作者：hxdts (赞：26)

## 1.定义
### 1 行列式
设一个 `n` 阶行列式为 

$A=\begin{vmatrix}a_{1,1}&a_{1,2}&\dots&a_{1,n}\\a_{2,1}&a_{2,2}&\dots&a_{2,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\dots&a_{n,n}\end{vmatrix}$

记其值为 `|A|` （也叫 `det(A) `）

$|A|=\sum\limits_p(-1)^{\tau(p)}\prod\limits_{i=1}^na_{i,p_i}$

其中 `p` 表示一个 `1 ~ n` 的一个排列。

$\tau(p)$ 表示序列 `p` 中的逆序对数。

### 2 代数余子式
>在n阶行列式中，把元素aₒₑ所在的第o行和第e列划去后，留下来的n-1阶行列式叫做元素aₒₑi的余子式，记作Mₒₑ，将余子式Mₒₑ再乘以-1的o+e次幂记为Aₒₑ，Aₒₑ叫做元素aₒₑ的代数余子式。

——摘自百度百科

**注意区分余子式和代数余子式的区别、**

关于为什么 $A_{i,j}=(-1)^{i+j}M_{i,j}$ 后面有证明。
___
## 2.性质及引理
**以下部分标题均转载自百度百科**
### 1 行列式 A 中某行(或列)用同一数 k 乘,其结果等于 k|A|
设另一 `n` 阶行列式为

$B=\begin{vmatrix}a_{1,1}&a_{1,2}&\dots&a_{1,n}\\a_{2,1}&a_{2,2}&\dots&a_{2,n}\\\vdots&\vdots&\ddots&\vdots\\k\times a_{j,1}&k\times a_{j,2}&\dots&k\times a_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\dots&a_{n,n}\end{vmatrix}$

$\begin{aligned}|B|&=\sum\limits_p(-1)^{\tau(p)}(a_{1,p_1}\times a_{2,p_2}\times\cdots\times k\times a_{j,p_j}\times \cdots\times a_{n,p_n})\\&=k\sum\limits_p(-1)^{\tau(p)}\prod\limits_{i=1}^na_{i,p_i}\\&=k\mid A\mid\end{aligned}$
___
### 2 行列式 A 等于其转置行列式 $A^T$ ( $A^T$ 的第 i 行为 A 的第 i 列)
显然……
___
### 3
$\begin{vmatrix}a_{1,1}&a_{1,2}&\dots&a_{1,n}\\a_{2,1}&a_{2,2}&\dots&a_{2,n}\\\vdots&\vdots&\ddots&\vdots\\b_{j,1}&b_{j,2}&\dots&b_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\dots&a_{n,n}\end{vmatrix}+
\begin{vmatrix}a_{1,1}&a_{1,2}&\dots&a_{1,n}\\a_{2,1}&a_{2,2}&\dots&a_{2,n}\\\vdots&\vdots&\ddots&\vdots\\c_{j,1}&c_{j,2}&\dots&c_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\dots&a_{n,n}\end{vmatrix}=
\begin{vmatrix}a_{1,1}&a_{1,2}&\dots&a_{1,n}\\a_{2,1}&a_{2,2}&\dots&a_{2,n}\\\vdots&\vdots&\ddots&\vdots\\b_{j,1}+c_{j,1}&b_{j,2}+c_{j,2}&\dots&b_{j,n}+c_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\dots&a_{n,n}\end{vmatrix}$

证明如下

$\begin{aligned}&\begin{vmatrix}a_{1,1}&a_{1,2}&\dots&a_{1,n}\\a_{2,1}&a_{2,2}&\dots&a_{2,n}\\\vdots&\vdots&\ddots&\vdots\\b_{j,1}&b_{j,2}&\dots&b_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\dots&a_{n,n}\end{vmatrix}+
\begin{vmatrix}a_{1,1}&a_{1,2}&\dots&a_{1,n}\\a_{2,1}&a_{2,2}&\dots&a_{2,n}\\\vdots&\vdots&\ddots&\vdots\\c_{j,1}&c_{j,2}&\dots&c_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\dots&a_{n,n}\end{vmatrix}
\\&=\sum\limits_p(-1)^{\tau(p)}(a_{1,p_1}\times a_{2,p_2}\times\cdots\times b_{j,p_j}\times \cdots\times a_{n,p_n})+\sum\limits_p(-1)^{\tau(p)}(a_{1,p_1}\times a_{2,p_2}\times\cdots\times c_{j,p_j}\times \cdots\times a_{n,p_n})
\\&=\sum\limits_p(-1)^{\tau(p)}(a_{1,p_1}\times a_{2,p_2}\times\cdots\times (b_{j,p_j}+c_{j,p_j})\times \cdots\times a_{n,p_n})
\\&=
\begin{vmatrix}a_{1,1}&a_{1,2}&\dots&a_{1,n}\\a_{2,1}&a_{2,2}&\dots&a_{2,n}\\\vdots&\vdots&\ddots&\vdots\\b_{j,1}+c_{j,1}&b_{j,2}+c_{j,2}&\dots&b_{j,n}+c_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\dots&a_{n,n}\end{vmatrix}\end{aligned}$
___
### 4 行列式 A 中两行（或列）互换,其结果等于 -A
对于每一个排列 `p`

每一个 $\prod\limits_{i=1}^na_{i,p_i}$ 不变（乘法交换律）

而由于**对换改变逆序对的奇偶性**，所以 $(-1)^{\tau(p')}=-(-1)^{\tau(p)}$

其中 `p'` 为对换后的序列
___
**对换改变逆序对的奇偶性证明**

考虑相邻的情况：

$a_1\ a_2\dots a_i\ a_{i+1} \dots a_n$

显然逆序对数 `+1` 或 `-1` ，奇偶性必定改变。

考虑一般情况：

$\begin{matrix}a_1\ a_2\dots \underbrace{a_i\dots \ a_j} \dots a_n\\\quad m\end{matrix}$

$a_1\ a_2\dots a_i\dots\ a_j \dots a_n\xRightarrow{m-1}
a_1\ a_2\dots a_j\ a_i \dots a_n\xRightarrow{m-2}
a_1\ a_2\dots a_j\dots\ a_i \dots a_n$

共 `2m-3` 次 `+1` 或 `-1` ，逆序对数奇偶性奇偶性必定改变
___
### 5 行列式 A 的一行是另一行的k倍 |A|=0
$\begin{aligned}\because A&=\begin{vmatrix}a_{1,1}&a_{1,2}&\dots&a_{1,n}\\a_{2,1}&a_{2,2}&\dots&a_{2,n}\\\vdots&\vdots&\ddots&\vdots\\a_{j,1}&a_{j,2}&\dots&a_{j,n}\\\vdots&\vdots&\ddots&\vdots\\k\times a_{j,1}&k\times a_{j,2}&\dots&k\times a_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\dots&a_{n,n}\end{vmatrix}
\\&=k\begin{vmatrix}a_{1,1}&a_{1,2}&\dots&a_{1,n}\\a_{2,1}&a_{2,2}&\dots&a_{2,n}\\\vdots&\vdots&\ddots&\vdots\\a_{j,1}&a_{j,2}&\dots&a_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{j,1}&a_{j,2}&\dots&a_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\dots&a_{n,n}\end{vmatrix}
\\&=-k\begin{vmatrix}a_{1,1}&a_{1,2}&\dots&a_{1,n}\\a_{2,1}&a_{2,2}&\dots&a_{2,n}\\\vdots&\vdots&\ddots&\vdots\\a_{j,1}&a_{j,2}&\dots&a_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{j,1}&a_{j,2}&\dots&a_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\dots&a_{n,n}\end{vmatrix}\quad\text{(交换了相等的两行)}\\
\end{aligned}
$

$\therefore |A|=0$

___
### 6 行列式 A 一行加上另一行的 k 倍，其值不变
$\begin{aligned}A&=\begin{vmatrix}a_{1,1}&a_{1,2}&\dots&a_{1,n}\\a_{2,1}&a_{2,2}&\dots&a_{2,n}\\\vdots&\vdots&\ddots&\vdots\\a_{j,1}&a_{j,2}&\dots&a_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{i,1}+k\times a_{j,1}&a_{i,2}+k\times a_{j,2}&\dots&a_{i,n}+k\times a_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\dots&a_{n,n}\end{vmatrix}\\
&=\begin{vmatrix}a_{1,1}&a_{1,2}&\dots&a_{1,n}\\a_{2,1}&a_{2,2}&\dots&a_{2,n}\\\vdots&\vdots&\ddots&\vdots\\a_{j,1}&a_{j,2}&\dots&a_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{i,1}&a_{i,2}&\dots&a_{i,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\dots&a_{n,n}\end{vmatrix}+
\begin{vmatrix}a_{1,1}&a_{1,2}&\dots&a_{1,n}\\a_{2,1}&a_{2,2}&\dots&a_{2,n}\\\vdots&\vdots&\ddots&\vdots\\a_{j,1}&a_{j,2}&\dots&a_{j,n}\\\vdots&\vdots&\ddots&\vdots\\k\times a_{j,1}&k\times a_{j,2}&\dots&k\times a_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\dots&a_{n,n}\end{vmatrix}\\
&=\begin{vmatrix}a_{1,1}&a_{1,2}&\dots&a_{1,n}\\a_{2,1}&a_{2,2}&\dots&a_{2,n}\\\vdots&\vdots&\ddots&\vdots\\a_{j,1}&a_{j,2}&\dots&a_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{i,1}&a_{i,2}&\dots&a_{i,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\dots&a_{n,n}\end{vmatrix}
\end{aligned}$
___
### 7 n阶行列式等于它的任一行(列)的所有元素与其对应的代数余子式的乘积之和
设行列式 `D` ，其余子式为 $A_{i,j}$

$D=\sum\limits_{j=1}^na_{i,j}A_{i,j}$

**此处引用知乎用户[微凉晨光](https://www.zhihu.com/people/sun-cheng-59-95)的图片**
![](https://cdn.luogu.com.cn/upload/image_hosting/cmbgaybv.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/t8an4u8y.png)
### 8 n阶行列式  的任一行(列)的元素与另一行(列)对应元素的代数余子式乘积之和等于零
设行列式 `D` ，其余子式为 $A_{i,j}$

即证明 $\sum\limits_{k=1}^na_{i,k}A_{j,k}=0\quad(i\ne j)$

$\begin{aligned}D&=\begin{vmatrix}a_{1,1}&a_{1,2}&\dots&a_{1,n}\\a_{2,1}&a_{2,2}&\dots&a_{2,n}\\\vdots&\vdots&\ddots&\vdots\\a_{j,1}&a_{j,2}&\dots&a_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{i,1}&a_{i,2}&\dots&a_{i,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\dots&a_{n,n}\end{vmatrix}\\
&=\sum\limits_{k=1}^na_{j,k}A_{j,k}
\end{aligned}$

由 7 知：

$\begin{aligned}\text{构造矩阵 }&\begin{vmatrix}a_{1,1}&a_{1,2}&\dots&a_{1,n}\\a_{2,1}&a_{2,2}&\dots&a_{2,n}\\\vdots&\vdots&\ddots&\vdots\\a_{i,1}&a_{i,2}&\dots&a_{i,n}\\\vdots&\vdots&\ddots&\vdots\\a_{i,1}&a_{i,2}&\dots&a_{i,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\dots&a_{n,n}\end{vmatrix}\quad\text{ (将第 j 行换成第 i 行)}
\\
&=\sum\limits_{k=1}^na_{j,k}A_{j,k}
\\
&=\sum\limits_{k=1}^na_{i,k}A_{j,k}
\\&=0\quad\text{(由 5 知)}\end{aligned}$
___
## 2.特殊行列式
设行列式 $D=\begin{vmatrix}a_{1,1}&a_{1,2}&a_{1,3}&\dots&a_{1,n}\\0&a_{2,2}&a_{2,3}&\dots&a_{2,n}\\0&0&a_{3,3}&\dots&a_{3,n}\\\vdots&\vdots&\vdots&\ddots&\vdots\\0&0&0&\dots&a_{n,n}\\\end{vmatrix}$

由 7 得：

$\begin{aligned}D&=\sum\limits_{i=1}^na_{i,1}A_{i,1}\\
&=a_{1,1}A_{1,1}\\
&=a_{1,1}\begin{vmatrix}a_{2,2}&a_{2,3}&\dots&a_{2,n}\\0&a_{3,3}&\dots&a_{3,n}\\\vdots&\vdots&\ddots&\vdots\\0&0&\dots&a_{n,n}\\\end{vmatrix}\\
&\dots\\
&=\prod\limits_{i=1}^na_{i,i}
\end{aligned}$
___



## 3.行列式求值
[P7112 【模板】行列式求值](https://www.luogu.com.cn/problem/P7112)


我们可以利用上面的性质，将一般行列式转换成呈“倒三角”的特殊行列式，即可求值。

我们可以根据性质 5 ，对每一行进行加减消元（非常类似高斯消元）也就是每次找到需要消元的一行，利用另一行进行辗转相除。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[610][610],mod;
int read()
{
    char ch=getchar();
    int r=0,w=1;
    while(ch<'0'||ch>'9') w=ch=='-'?-1:w,ch=getchar();
    while(ch>='0'&&ch<='9') r=r*10+ch-'0',ch=getchar();
    return r*w;
}
signed main()
{
	n=read(),mod=read();
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	a[i][j]=read();
	int ans=1,v=1;
	for(int i=1;i<=n;i++)
	for(int j=i+1;j<=n;j++)
	{
		while(a[i][i])
		{
			int x=a[j][i]/a[i][i];
			for(int k=i;k<=n;k++)
			a[j][k]=(a[j][k]-x*a[i][k]%mod+mod)%mod;
			swap(a[i],a[j]),v=-v;//性质 4
		}
		swap(a[i],a[j]),v=-v;
	}
	for(int i=1;i<=n;i++)
	ans=ans*a[i][i]%mod;//特殊行列式求值
	cout<<(ans*v+mod)%mod;
}
```
## 4 矩阵树定理
[P6178 【模板】Matrix-Tree 定理](https://www.luogu.com.cn/problem/P6178)

证明在之前的日报有讲，就不证了，这里只讲结论：

对于一条边 `( x , y , k )` 

`x , y` 为联接的两点， `k` 为权值

设邻接矩阵为 `edge` 度数矩阵为 `in`

每次加边在两个矩阵里分别加 `k`

答案为 `in - edge` 去掉第 `z` 行第 `z` 的行列式，$z\in(1,n]$

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=1e9+7;
int n,m,t,a[310][310],x,y,k;
int read()
{
    char ch=getchar();
    int r=0,w=1;
    while(ch<'0'||ch>'9') w=ch=='-'?-1:w,ch=getchar();
    while(ch>='0'&&ch<='9') r=r*10+ch-'0',ch=getchar();
    return r*w;
}
signed main()
{
	n=read(),m=read(),t=read();
	for(int i=1;i<=m;i++)
	{
		x=read()-1,y=read()-1,k=read();
		a[x][y]=(a[x][y]-k)%mod,a[y][y]=(a[y][y]+k)%mod;
		if(!t)
		a[y][x]=(a[y][x]-k)%mod,a[x][x]=(a[x][x]+k)%mod;
	}
	int ans=1;
	for(int i=1;i<n;i++)
	for(int j=i+1;j<n;j++)
	{
		while(a[i][i])
		{
			int x=a[j][i]/a[i][i];
			for(int k=i;k<n;k++)
			a[j][k]=(a[j][k]-x*a[i][k]%mod+mod)%mod;
			swap(a[i],a[j]),ans=-ans;
		}
		swap(a[i],a[j]),ans=-ans;
	}
	for(int i=1;i<n;i++)
	ans=ans*a[i][i]%mod;
	cout<<(ans+mod)%mod;
}
```
## 5 应用
应用主要都是矩阵树定理……

---

## 作者：Link_Cut_Y (赞：18)

学《高等代数》第二章的时候过来搜了搜模板，结果真搜到了。于是来水一篇题解。

本文部分内容来自《高等代数》。

[可能更好的阅读体验](https://www.cnblogs.com/LcyRegister/p/17323330.html)

-------------------

## 行列式定义

对于一个 $n$ 阶行列式 

$$A_{n \times n}=  
\begin{vmatrix}  
  a_{11}& a_{12}& \cdots  & a_{1n} \\  
  a_{21}& a_{22}& \cdots  & a_{2n} \\  
  \vdots & \vdots & \ddots & \vdots \\  
  a_{n1}& a_{n2}& \cdots  & a_{nn}  
\end{vmatrix}$$

其结果为所有不同行不同列的元素乘积的代数和。用数学语言写为：

$$\sum_{j_1j_2 \cdots j_n} (-1) ^ {\tau(j_1j_2\cdots j_n)} a_{1j_1}a_{2j_2}\cdots a_{nj_n}$$

其中 $j_1j_2 \cdots j_n$ 为 $1 \sim n$ 的一个排列。$\tau(j_1j_2 \cdots j_n)$ 表示排列 $j$ 的逆序数的个数。

可以看出，如果 $\tau(j_1 \sim j_n)$ 为偶数，那么该排列对答案的贡献为正。否则为负。

## 行列式性质

《高代》里原本有七条性质，这里只证明有用的五条。

 - 性质一：行列式转置后值不变。即：

$$\begin{vmatrix}  
  a_{11}& a_{12}& \cdots  & a_{1n} \\  
  a_{21}& a_{22}& \cdots  & a_{2n} \\  
  \vdots & \vdots & \ddots & \vdots \\  
  a_{n1}& a_{n2}& \cdots  & a_{nn}  
\end{vmatrix} = 

\begin{vmatrix}  
  a_{11}& a_{21}& \cdots  & a_{n1} \\  
  a_{12}& a_{22}& \cdots  & a_{n2} \\  
  \vdots & \vdots & \ddots & \vdots \\  
  a_{1n}& a_{2n}& \cdots  & a_{nn} 
\end{vmatrix} $$

 - 性质二：行列式内某一行的公因子可以提出。

$$\begin{vmatrix}  
  a_{11}& a_{12}& \cdots  & a_{1n} \\  
  a_{21}& a_{22}& \cdots  & a_{2n} \\  
  \vdots & \vdots &  & \vdots \\ 
  ka_{i1} & ka_{i2} & \cdots & ka_{in}\\ 
  a_{n1}& a_{n2}& \cdots  & a_{nn}  
\end{vmatrix} = 
k
\begin{vmatrix}  
  a_{11}& a_{12}& \cdots  & a_{1n} \\  
  a_{21}& a_{22}& \cdots  & a_{2n} \\  
  \vdots & \vdots &  & \vdots \\ 
  a_{i1} & a_{i2} & \cdots & a_{in}\\ 
  a_{n1}& a_{n2}& \cdots  & a_{nn}  
\end{vmatrix}
$$

### 证明：

首先考虑 $n$ 级行列式的 $n!$ 项。如果把他们分成 $n$ 组，一定有一种方案，使得第 $1$ 组中都含有 $a_{i1}$，第 $2$ 组中都含有 $a_{i2}$，以此类推。如果第 $j$ 项提出 $a_{ij}$ 后记作 $A_{ij}$，那么有

$$\begin{vmatrix}  
  a_{11} & a_{12} & \cdots  & a_{1n} \\  
  a_{21} & a_{22} & \cdots  & a_{2n} \\  
  \vdots & \vdots &         & \vdots \\
  a_{n1} & a_{n2} & \cdots  & a_{nn}
\end{vmatrix}$$

$$=
a_{i1}A_{i1} + a_{i2}A_{i2} + \cdots + a_{in}A_{in}
= \sum_{j = 1}^{n} a_{ij}A_{ij}
$$

这将方便我们后面的讨论。

现在证明性质二：

$$\begin{vmatrix} 
  a_{11} & a_{12} & \cdots & a_{1n}\\
  a_{21} & a_{22} & \cdots & a_{2n}\\  
  \vdots & \vdots &  & \vdots \\ 
  ka_{i1} & ka_{i2} & \cdots & ka_{in}\\ 
  a_{n1}& a_{n2} & \cdots & a_{nn}  
\end{vmatrix}$$

$$=
ka_{i1}A_{i1} + ka_{i2}A_{i2} + \cdots + ka_{in}A_{in}
$$
$$=
k(a_{i1}A_{i1} + a_{i2}A_{i2} + \cdots + a_{in}A_{in}) 
$$
$$= k \begin{vmatrix}
  a_{11}& a_{12} & \cdots & a_{1n} \\  
  a_{21}& a_{22} & \cdots & a_{2n} \\  
  \vdots & \vdots &  & \vdots \\ 
  a_{i1} & a_{i2} & \cdots & a_{in} \\ 
  a_{n1}& a_{n2}& \cdots  & a_{nn}  
\end{vmatrix}$$

 - 性质三：

$$
\begin{vmatrix}  
  a_{11}& a_{12}& \cdots  & a_{1n} \\  
  a_{21}& a_{22}& \cdots  & a_{2n} \\  
  \vdots & \vdots &  & \vdots \\  
  b_1 + c_1 & b_2 + c_2 & \cdots & b_n + c_n \\
  a_{n1}& a_{n2}& \cdots  & a_{nn}  
\end{vmatrix}
$$

$$
= 
\begin{vmatrix}  
  a_{11}& a_{12}& \cdots  & a_{1n} \\  
  a_{21}& a_{22}& \cdots  & a_{2n} \\  
  \vdots & \vdots &  & \vdots \\  
  b_1 & b_2 & \cdots & b_n \\
  a_{n1}& a_{n2}& \cdots  & a_{nn}  
\end{vmatrix} + 
\begin{vmatrix}  
  a_{11}& a_{12}& \cdots  & a_{1n} \\  
  a_{21}& a_{22}& \cdots  & a_{2n} \\  
  \vdots & \vdots &  & \vdots \\ 
  c_1 & c_2 & \cdots & c_n \\
  a_{n1}& a_{n2}& \cdots  & a_{nn}  
\end{vmatrix}
$$

### 证明：
原行列式可写成 $(b_1 + c_1)A_{i1} + (b_2 + c_2)A_{i2} + \cdots + (b_n + c_n)A_{in}$，这等于右式。

 - 性质四：把第 $k$ 行的倍数加到第 $i$ 行，行列式不变。

证明太容易~~而公式又太难打~~，就不写了。

 - 性质五：对调行列式的两行，行列式反号。

### 证明：

$$
\begin{vmatrix}  
  a_{11}& a_{12}& \cdots  & a_{1n} \\  
  a_{21}& a_{22}& \cdots  & a_{2n} \\  
  \vdots & \vdots &  & \vdots \\ 
  a_{i1} & a_{i2} & \cdots & a_{in} \\
  \vdots & \vdots & &\vdots \\
  a_{k1} & a_{k2} & \cdots &a_{kn} \\
  \vdots & \vdots & &\vdots \\
  a_{n1}& a_{n2}& \cdots  & a_{nn}  
\end{vmatrix}$$ 
$$ = \begin{vmatrix}  
  a_{11}& a_{12}& \cdots  & a_{1n} \\  
  a_{21}& a_{22}& \cdots  & a_{2n} \\  
  \vdots & \vdots &  & \vdots \\ 
  a_{i1} + a_{k1}& a_{i2} + a_{k2}& \cdots & a_{in} + a_{kn}\\
  \vdots & \vdots & &\vdots \\
  a_{k1} & a_{k2} & \cdots &a_{kn} \\
  \vdots & \vdots & &\vdots \\
  a_{n1}& a_{n2}& \cdots  & a_{nn}  
\end{vmatrix}$$
$$
= \begin{vmatrix}  
  a_{11}& a_{12}& \cdots  & a_{1n} \\  
  a_{21}& a_{22}& \cdots  & a_{2n} \\  
  \vdots & \vdots &  & \vdots \\ 
  a_{i1} + a_{k1}& a_{i2} + a_{k2}& \cdots & a_{in} + a_{kn}\\
  \vdots & \vdots & &\vdots \\
  -a_{i1} & -a_{i2} & \cdots & -a_{in} \\
  \vdots & \vdots & &\vdots \\
  a_{n1}& a_{n2}& \cdots  & a_{nn}  
\end{vmatrix}$$
$$
= \begin{vmatrix}  
  a_{11}& a_{12}& \cdots  & a_{1n} \\  
  a_{21}& a_{22}& \cdots  & a_{2n} \\  
  \vdots & \vdots &  & \vdots \\ 
  a_{k1} & a_{k2} & \cdots & a_{kn}\\
  \vdots & \vdots & &\vdots \\
  -a_{i1} & -a_{i2} & \cdots & -a_{in} \\
  \vdots & \vdots & &\vdots \\
  a_{n1}& a_{n2}& \cdots  & a_{nn}  
\end{vmatrix}$$
$$
= - \begin{vmatrix}  
  a_{11}& a_{12}& \cdots  & a_{1n} \\  
  a_{21}& a_{22}& \cdots  & a_{2n} \\  
  \vdots & \vdots &  & \vdots \\ 
  a_{k1} & a_{k2} & \cdots & a_{kn}\\
  \vdots & \vdots & &\vdots \\
  a_{i1} & a_{i2} & \cdots & a_{in} \\
  \vdots & \vdots & &\vdots \\
  a_{n1}& a_{n2}& \cdots  & a_{nn}  
\end{vmatrix}
$$

其中第一步是利用性质四，将第 $k$ 行加到了第 $i$ 行上。

第二步是利用性质四，将第 $i$ 行减去第 $k$ 行。

第三步是利用性质四，将第 $i$ 行加到了第 $k$ 行上。

最后一步是利用性质二，将第 $i$ 行提出 $-1$。

证毕。

## 特殊的行列式

1. 对角行列式

形如
$\begin{vmatrix}  
  a_{11} & 0 & \cdots & 0 \\  
  0 & a_{22} & \cdots & 0 \\  
  \vdots & \vdots & \ddots & \vdots \\  
  0 & 0 & \cdots & a_{nn} 
\end{vmatrix}$ 
的行列式称为对角行列式。其结果为 $a_{11} \times a_{22} \cdots a_{nn}$。

2. 三角行列式

形如 $\begin{vmatrix}
    a_{11} & a_{12} & \cdots & a_{1n} \\
    0 & a_{22} & \cdots & a_{2n} \\
    \vdots &  \vdots &  & \vdots \\
    0 & 0 & 0 & a_{nn} \\
\end{vmatrix}$ 的行列式被称为三角行列式，其结果与对角行列式相同。

## 行列式计算

显然，如果按照定义，我们需要 $O(n \times n!)$ 的复杂度。显然无法接受。

由于存在一些特殊的行列式，可以考虑将原行列式转化为三角行列式后求值。思路就是将原行列式利用性质一到四进行转化。

例如有行列式 $\begin{vmatrix}
 2 & 3 & 5 \\
 3 & 4 & 7 \\
 4 & 3 & 2
\end{vmatrix}$，首先可以将 $2 \sim 3$ 行分别加上第一行的 $-\dfrac{3}{2}, -2$ 倍，化为 $\begin{vmatrix}
 2 & 3 & 5 \\
 0 & -\dfrac{1}{2} & -\dfrac{1}{2} \\
 0 & -3 & -8
\end{vmatrix}$。

接下来，把第三行加上第二行的 $-6$ 倍，可得 $\begin{vmatrix}
 2 & 3 & 5 \\
 0 & -\dfrac{1}{2} & -\dfrac{1}{2} \\
 0 & 0 & -5
\end{vmatrix}$。

于是原式化为了一个三角行列式。对角线乘积即为答案 $5$。

这个方法类似高斯消元的过程。因此就把它叫做高斯消元吧。

可以看出，这个方法的时间复杂度是 $O(n ^ 3)$ 的，完全可以接受。

## 带模数行列式计算

如果带模数怎么算行列式的值呢？

有一种方法叫做辗转相减法，可以完美的解决这个问题。

比如有行列式 $\begin{vmatrix}
 3 & 2\\
 4 & 1
\end{vmatrix}$，首先先用第二行的第一个数除以第一行第一个数，得到 $1$。（这里是下取整）。

然后用第二行减去第一行 $\times 1$，得到 $\begin{vmatrix}
 3 & 2\\
 1 & -1
\end{vmatrix}$。

容易证明第二行第一个数在操作完之后一定小于第一行第一个数。因此交换 $1, 2$ 行，得到 $-\begin{vmatrix}
 1 & -1\\
 3 & 2
\end{vmatrix}$。

重复上述操作，直到第一行为 $0$。得到这样的行列式：$\begin{vmatrix}
 0 & 5\\
 1 & -1
\end{vmatrix}$。

最后再把一、二行交换即可得到下三角行列式：

$$-\begin{vmatrix}
 1 & -1\\
 0 & 5
\end{vmatrix}$$

答案即为 $-5$。

由于在辗转相减的过程中可以取模，所以这个问题就被完美解决了。

分析一下复杂度。易证辗转相减的复杂度与欧几里得算法类似，为 $O(\log n)$ 级别。如果记交换两行复杂度为 $O(n)$，那么总复杂度就为 $O(n ^ 2(\log n + n))$。

**注意：两行交换时千万别忘变号！！！**

## 代码

```cpp
#include <algorithm>
#include <cstdio>
#define int long long

using namespace std;

const int N = 610;
int n, p, w[N][N], f;
void Swap(int &a, int &b) {
	for (int i = 1; i <= n; i ++ )
		swap(w[a][i], w[b][i]);
	f ^= 1; // 变号
}
int gauss() {
	for (int i = 1; i <= n; i ++ )
		for (int j = i + 1; j <= n; j ++ ) {
			while (w[i][i]) {
				int K = (int)w[j][i] / w[i][i];
				for (int k = i; k <= n; k ++ )
					((w[j][k] -= K * w[i][k] % p) += p) %= p;
				Swap(i, j);
			} Swap(i, j);
		}
	int ans = 1;
	for (int i = 1; i <= n; i ++ )
		(ans *= w[i][i]) %= p;
	return (f ? (-ans + p) % p : (ans + p) % p);
}

signed main() {
	scanf("%lld%lld", &n, &p);
	for (int i = 1; i <= n; i ++ )
		for (int j = 1; j <= n; j ++ )
			scanf("%lld", &w[i][j]);
	return 0 & printf("%lld\n", gauss());;
}
```

本文公式很多，可能有笔误。希望大家可以指出。

---

## 作者：Hadtsti (赞：18)

### 题意简述

模板题，求一个 $n\times n(n\le 600)$ 的方阵的行列式模一个正整数 $p(1\le p\le 10^9+7)$ 的值（$p$ 不一定是质数）。

### 题目分析

这个题的最终代码其实很简单，重点在于过程。说实话，我在做这个题之前也就只知道个行列式的定义，只会暴力硬算。做了这个题才了解了行列式有那么多的好的性质，也算是开了开眼界吧。所以本文先介绍行列式本身再讲解题步骤。由于这篇文章本身也是我在学习 [@Reywmp](https://www.luogu.com.cn/user/57273) 大佬的 [数学(5)——线性代数：行列式](https://www.luogu.com.cn/blog/Stormy-Rey/calculate-det) 一文之后写的，所以本文参考了这篇文章的内容，在此先膜拜大佬。另外我个人十分重视性质的证明过程，所以原来打算把自己写的几个性质的证明直接放到文中，后来考虑重要性不高以及篇幅问题就写到剪贴板里了，读者可以选择性看一看。~~（最好看看吧，毕竟我肝了将近两个小时）~~

#### 定义

首先来看行列式的定义。对于一个 $n\times n$ 的矩阵 $A$：

$$
A=  
\begin{bmatrix}  
  a_{1,1}& a_{1,2}& \cdots  & a_{1,n} \\  
  a_{2,1}& a_{2,2}& \cdots  & a_{2,n} \\  
  \vdots & \vdots & \ddots & \vdots \\  
  a_{k,1}& a_{k,2}& \cdots  & a_{k,n} \\  
 \vdots & \vdots & \ddots & \vdots \\   
  a_{n,1}& a_{n,2}& \cdots  & a_{n,n}  
\end{bmatrix}  
$$
它的行列式就是：
$$|A|=\sum_p (-1)^{\tau(p)}\prod_{k=1}^n a_{k,p_k}$$

其中 $p$ 是 $\{1,2,3,\cdots,n-1,n\}$ 的排列，$\tau(p)$ 则是 $p$ 中的逆序对个数。

形象化一点，你可以认为 $\prod_{k=1}^n a_{k,p_k}$ 是由 $p$ 决定的矩阵中两两不同行不同列的 $n$ 个元素的乘积。如果 $p$ 的逆序对个数为偶数，就把这个乘积加到总和里；反之，就从总和里把这个乘积减去。这样得到的总和就是矩阵的行列式。

那么这个看起来有点抽象的东西有什么实际用途呢？一个经典的例子是这样的：$n\times n$ 的矩阵本身对应着 $n$ 维欧式空间中的一个线性变换，而这个矩阵的行列式就对应着这个线性变换前后的“体积”之比。由于这部分不是特别重要，本文不过多展开。感兴趣的读者可以自行查询资料，如[行列式的意义是什么？——知乎](https://www.zhihu.com/question/26294660)。

#### 性质

行列式的性质有很多，在这里只介绍较为有用的几个。

**1. 交换矩阵的两行或两列，行列式取反。**

[证明](https://www.luogu.com.cn/paste/2xrqpkj4)

**2. 如果矩阵的某两行（列）相同，行列式为 0。**

[证明](https://www.luogu.com.cn/paste/qhwk5bxh)

**3. 矩阵的某一行（列）的每个元素乘（除） $m$，行列式也乘（除） $m$。**

[证明](https://www.luogu.com.cn/paste/z136w7rl)

推论：由性质 2 和 3 可得到：若矩阵中有两行（列）的所有元素成比例，则其行列式为 0。

**4. 若矩阵 $A$ 中有一行（列）的每个元素都是 2 个矩阵 B 与 C 中对应的元素之和，其它行（列）的所有元素与 $B$、$C$ 相同，则 $|A|=|B|+|C|$**

[证明](https://www.luogu.com.cn/paste/54tvxuu7)

推论：若矩阵 $A$ 中有一行（列）的每个元素都是 $m$ 个矩阵 $B_1,B_2,\cdots,B_n$ 中对应的元素之和，其它行（列）的所有元素与 $B_1,B_2,\cdots,B_n$ 相同，则 $|A|=|B_1|+|B_2|+\cdots+|B_n|$。

**5.把矩阵的某一行（列）乘上一个系数 $m$，加到另一行（列）上，矩阵行列式不变。**

[证明](https://www.luogu.com.cn/paste/zo37d8lv)

**6. 矩阵的行列式等于其任意一行（列）的每个元素及其代数余子式的乘积之和**

先解释下什么是代数余子式。我们称一个矩阵去掉第 $i$ 行和第 $j$ 列后剩下的矩阵的行列式为其余子式 $M_{i,j}$，而代数余子式 $A_{i,j}=(-1)^{i+j}\times M_{i,j}$。

那么原命题就是对于第 $i$ 行，有 $\displaystyle|A|=\sum_{j=1}^na_{i,j}\times A_{i,j}$；

对于第 $j$ 列，有 $\displaystyle|A|=\sum_{i=1}^na_{i,j}\times A_{i,j}$

[证明](https://www.luogu.com.cn/paste/d3yk36mg)

#### 解题步骤

本题直接暴力求值的时间复杂度为 $O(n\times n!)$，显然无法接受。

考虑之前的性质 1、3、5 中的操作，形式是不是有点熟悉？没错，它们就是矩阵的初等变换。而在高斯消元中，我们可以通过初等行变换进行消元将一个矩阵变为一个上三角矩阵。所以，我们只要能够求出消元后的上三角矩阵的行列式，就可以很简单地计算出原矩阵的行列式。

所以问题来了，怎么快速计算上三角矩阵的行列式？举个例子：

$$\begin{bmatrix}  
  a_{1,1}& a_{1,2}& a_{1,3}&\cdots  &a_{1,n-1}& a_{1,n} \\  
  0& a_{2,2}& a_{2,3}&\cdots  &a_{2,n-1}& a_{2,n} \\  
  0& 0& a_{3,3}&\cdots  &a_{3,n-1}& a_{3,n} \\  
  \vdots & \vdots&\vdots& \ddots &\vdots& \vdots \\  
  0& 0&0&\cdots  &a_{n-1,n-1}& a_{n-1,n}  \\
  0& 0&0&\cdots  &0& a_{n,n}  
\end{bmatrix}  $$

根据性质 6，有

$$
\begin{vmatrix}  
  a_{1,1}& a_{1,2}& a_{1,3}&\cdots  &a_{1,n-1}& a_{1,n} \\  
  0& a_{2,2}& a_{2,3}&\cdots  &a_{2,n-1}& a_{2,n} \\  
  0& 0& a_{3,3}&\cdots  &a_{3,n-1}& a_{3,n} \\  
  \vdots & \vdots&\vdots& \ddots &\vdots& \vdots \\  
  0& 0&0&\cdots  &a_{n-1,n-1}& a_{n-1,n}  \\
  0& 0&0&\cdots  &0& a_{n,n}  
\end{vmatrix}  =a_{n,n}\times A_{n,n}=a_{n,n}\times (-1)^{2n}\times M_{n,n}=a_{n,n}\times M_{n,n}
$$
注意到：
$$
M_{n,n}=
\begin{vmatrix}  
  a_{1,1}& a_{1,2}& a_{1,3}&\cdots  &a_{1,n-2}& a_{1,n-1} \\  
  0& a_{2,2}& a_{2,3}&\cdots  &a_{2,n-2}& a_{2,n-1} \\  
  0& 0& a_{3,3}&\cdots  &a_{3,n-2}& a_{3,n-1} \\  
  \vdots & \vdots&\vdots& \ddots &\vdots& \vdots \\  
  0& 0&0&\cdots  &a_{n-2,n-2}& a_{n-2,n-1}  \\
  0& 0&0&\cdots  &0& a_{n-1,n-1}  
\end{vmatrix}
$$
那么就有（下图的 $A_{n-1,n-1}$ 和 $M_{n-1,n-1}$ 是相对原矩阵去掉第 $n$ 行第 $n$ 列的子矩阵而言的）：
$$
M_{n,n}=
\begin{vmatrix}  
  a_{1,1}& a_{1,2}& a_{1,3}&\cdots  &a_{1,n-2}& a_{1,n-1} \\  
  0& a_{2,2}& a_{2,3}&\cdots  &a_{2,n-2}& a_{2,n-1} \\  
  0& 0& a_{3,3}&\cdots  &a_{3,n-2}& a_{3,n-1} \\  
  \vdots & \vdots&\vdots& \ddots &\vdots& \vdots \\  
  0& 0&0&\cdots  &a_{n-2,n-2}& a_{n-2,n-1}  \\
  0& 0&0&\cdots  &0& a_{n-1,n-1}  
\end{vmatrix}=a_{n-1,n-1}\times A_{n-1,n-1} =a_{n-1,n-1}\times (-1)^{2n-2}\times M_{n-1,n-1}=a_{n-1,n-1}\times M_{n-1,n-1}
$$
发现了什么？是的，我们可以继续递归下去求解，最终会得出：
$$
\begin{vmatrix}  
  a_{1,1}& a_{1,2}& a_{1,3}&\cdots  &a_{1,n-1}& a_{1,n} \\  
  0& a_{2,2}& a_{2,3}&\cdots  &a_{2,n-1}& a_{2,n} \\  
  0& 0& a_{3,3}&\cdots  &a_{3,n-1}& a_{3,n} \\  
  \vdots & \vdots&\vdots& \ddots &\vdots& \vdots \\  
  0& 0&0&\cdots  &a_{n-1,n-1}& a_{n-1,n}  \\
  0& 0&0&\cdots  &0& a_{n,n}  
\end{vmatrix}
=\prod_{i=1}^na_{i,i}
$$
因此上三角矩阵的行列式是非常好求的，重点又回到了将原矩阵消元为上三角矩阵的过程。

注意到题目中 $p$ 不一定是质数，这就代表不一定所有 $a_{i,j}$ 都有逆元，不能使用高斯消元，应该采用其他方式。

回忆 $\gcd$ 的辗转相除法，最终一个数变为 $\gcd$，另外一个数则变为 0，是不是可以用来消元？

答案是肯定的。我们选定需要消元的那一行，与其他行做辗转相除。因为辗转相除所用的操作都是矩阵的初等变换，所以根据消元后的矩阵的行列式可以运用性质 1、3、5 很方便计算出原矩阵的行列式。

最后看一下算法的时间复杂度。消元部分的时间复杂度为 $O(n^3)$；辗转相除的时间复杂度均摊，得到 $O(n^2\log p)$。所以算法总的时间复杂度记为 $O(n^2(n+\log p))$。另外由于消元过程中数据规模变小，所以消元部分常数也较小，对于 $n=600$ 的数据和 $2.0s$ 的时限是没问题的。
### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[610][610],res=1,w=1/*初等变换带来的系数*/,mod;
int main()
{
	scanf("%d%d",&n,&mod);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%d",&a[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
		{
			while(a[i][i])//没消掉就继续消 
			{
				for(int rate=a[j][i]/a[i][i]/*“相除”，把商作为系数乘在第 i 行的元素上*/,k=i/*没消掉的元从 i 开始*/;k<=n;++k)
        		    a[j][k]=(a[j][k]-1ll*rate*a[i][k]%mod+mod)%mod;//在消掉 a[j][i] 的同时它的整行元素都要进行同样操作 
				swap(a[i],a[j]);//“辗转”
				w=-w;//计算系数 
			}
        	swap(a[i],a[j]);//“辗转” 
			w=-w;//计算系数 
		}
	for(int i=1;i<=n;i++)
		res=1ll*a[i][i]*res%mod;//计算上三角矩阵的行列式 
	res=(1ll*res*w%mod+mod)%mod;//一定要乘上系数！！！ 
	printf("%d",res);
	return 0;
}
```

由于本文写的时间跨度比较长，不可避免地存在错误和不足，欢迎大家指出！

### update 
本文最初发表于 2023.6.28，后自己发现文中的几处笔误，故于 2023.8.9 重新修改上传。

---

## 作者：山田リョウ (赞：7)

首先，我们知道三条性质：
1. 若将 $A$ 这个方阵的某一行和另一行交换，则 $|A|$ 等于原来的 $|A|\times-1$ 
2. 若将 $A$ 这个方阵的某一行都乘上 $k$，则 $|A|$ 等于原来的 $|A|\times k$
3. 若将 $A$ 这个方阵的某一行乘上某个数整体加到另一行上，则 $|A|$ 不变。

证明我就不写了，可以看 [Reywmp的题解](https://www.luogu.com.cn/blog/_post/321011)。

而且我们还知道，如果方阵 $A$ 是一个上三角矩阵的话，$|A|$ 等于主对角线上的所有数的乘积。

可以发现，上面三条性质对应着初等行变换，所以我们考虑用高斯消元把题目给的这个方阵消成上三角矩阵，然后就可以方便的求行列式的值了。

但是！我们发现了一个问题，题目给的 $p$ 不保证是质数！所以不保证除了 $p$ 的倍数以外所有数都有逆元。。。直接做就寄了。。。

那怎么办呢，我们考虑用类似欧几里得算法的做法去消元，也就是我将第 $j$ 行整体减去第 $i$ 行乘上 $\lfloor\text{原来的第} j \text{行第} k \text{位}\div\text{第} i \text{行第} k \text{位}\rfloor$，如果第 $i$ 行没把第 $j$ 行的第 $k$ 位消掉，那我就反过来用第 $j$ 行用同样的方法去消第 $i$ 行的第 $k$ 位，直到把把其中某一行的第 $k$ 位消掉。

这样的时间复杂度呢？是 $O(n^3\log p)$ 吗？并不是的，是 $O(n^2(n+\log p))$，感性理解一下，由于每次上述类似欧几里得算法的消的次数越久，那第 $k$ 位不为 $0$ 的那一行的第 $k$ 位缩小的就越多，所以复杂度是对的。

**注意：读入的时候不保证每一项都小于 $p$，所以读入后记得取模！不然会 TLE！**

代码：
```cpp
#include<stdio.h>
#include<stdlib.h>
#include<algorithm>
#include<ctype.h>
namespace fasti{
	char buf[1<<15],*p1=buf,*p2=buf;
	#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<15,stdin),p1==p2)?EOF:*p1++)
	inline void read(int&x){
		char c=getc();
		for(;!isdigit(c);c=getc());
		for(x=0;isdigit(c);c=getc())x=(x<<1)+(x<<3)+(c^48);
	}
}
using fasti::read;
int p;
int a[600][600];
using std::swap;
inline int diff(int x,int y){return x<y?p-(y-x):x-y;}
int main(){
    int n;
    read(n),read(p);
    for(int i=0;i<n;++i)
        for(int j=0;j<n;++j)
            read(a[i][j]),a[i][j]%=p;
    int d=1;
    for(int k=0;k<n;++k){
        int t;
        for(t=k;t<n;++t)
            if(a[t][k])
                break;
        if(t==n)puts("0"),exit(0);
        if(t!=k)swap(a[k],a[t]),d=p-d;//注意交换两行行列式要变成以前的相反数
        for(int i=k+1;i<n;swap(a[k],a[i++]),d=p-d)//这部分就是用类似欧几里得算法的方式去消
            for(int div;a[k][k];swap(a[k],a[i]),d=p-d)//注意交换两行行列式要变成以前的相反数
                for(int j=(div=a[i][k]/a[k][k],k);j<n;++j)
                    a[i][j]=diff(a[i][j],(long long)div*a[k][j]%p);
    }
    for(int i=0;i<n;++i)d=(long long)d*a[i][i]%p;
    printf("%d",d);
    return 0;
}
```

---

## 作者：SunsetSamsara (赞：6)

## 前置知识

行列式求值，高斯消元

## 题目分析

### 定义

> 行列式在数学中，是一个函数，其定义域为 $\det$ 的矩阵 $A$，取值为一个标量，写作 $\det(A)$ 或 $A$ 。无论是在线性代数、多项式理论，还是在微积分学中（比如说换元积分法中），行列式作为基本的数学工具，都有着重要的应用。 $D=\sum(-1)^k a_{1k_1}a_{2k_1}a_{3k_1}...a_{nk_n}$
式中 $k_1,k_2,...,k_n$ 是将序列 $1,2,...,n$ 的元素次序交换 $k$ 次所得到的一个序列

> 摘自百度百科

emm...按照这个定义去算，复杂度是 $O(n!n)$ 的。所以，我们需要用性质简化计算。

### 性质

1. 行列式的两行（列）交换之后值取相反数
$$\begin{vmatrix}A_{11}&A_{12}&A_{13}&\cdots&A_{1n}\\A_{21}&A_{22}&A_{23}&\cdots&A_{2n}\\\vdots&\vdots&\vdots&\vdots&\vdots\\A_{a1}&A_{a2}&A_{a3}&\cdots&A_{an}\\\vdots&\vdots&\vdots&\vdots&\vdots\\A_{b1}&A_{b2}&A_{a3}&\cdots&A_{bn}\\\vdots&\vdots&\vdots&\vdots&\vdots\\A_{n1}&A_{n2}&A_{n3}&\cdots&A_{nn}\\\end{vmatrix}
=-\begin{vmatrix}A_{11}&A_{12}&A_{13}&\cdots&A_{1n}\\A_{21}&A_{22}&A_{23}&\cdots&A_{2n}\\\vdots&\vdots&\vdots&\vdots&\vdots\\A_{b1}&A_{b2}&A_{b3}&\cdots&A_{bn}\\\vdots&\vdots&\vdots&\vdots&\vdots\\A_{a1}&A_{a2}&A_{a3}&\cdots&A_{an}\\\vdots&\vdots&\vdots&\vdots&\vdots\\A_{n1}&A_{n2}&A_{n3}&\cdots&A_{nn}\\\end{vmatrix}
$$

2. 如果行列式对应矩阵 $A$ 中有一行（列），是对应 $2$ 个矩阵 $B, C$ 中分别的 $2$ 行（列）所有元素之和。那么有 $\det(A)=\det(B)+\det(C)$

$$\begin{vmatrix}A_{11}&A_{12}&A_{13}&\cdots&A_{1n}\\A_{21}&A_{22}&A_{23}&\cdots&A_{2n}\\\vdots&\vdots&\vdots&\vdots&\vdots\\B_{a1}+C_{a1}&B_{a2}+C_{a2}&B_{a3}+C_{a3}&\cdots&B_{an}+C_{an}\\\vdots&\vdots&\vdots&\vdots&\vdots\\A_{n1}&A_{n2}&A_{n3}&\cdots&A_{nn}\\\end{vmatrix}=\begin{vmatrix}A_{11}&A_{12}&A_{13}&\cdots&A_{1n}\\A_{21}&A_{22}&A_{23}&\cdots&A_{2n}\\\vdots&\vdots&\vdots&\vdots&\vdots\\B_{a1}&B_{a2}&B_{a3}&\cdots&B_{an}\\\vdots&\vdots&\vdots&\vdots&\vdots\\A_{n1}&A_{n2}&A_{n3}&\cdots&A_{nn}\\\end{vmatrix}+\begin{vmatrix}A_{11}&A_{12}&A_{13}&\cdots&A_{1n}\\A_{21}&A_{22}&A_{23}&\cdots&A_{2n}\\\vdots&\vdots&\vdots&\vdots&\vdots\\C_{a1}&C_{a2}&C_{a3}&\cdots&C_{an}\\\vdots&\vdots&\vdots&\vdots&\vdots\\A_{n1}&A_{n2}&A_{n3}&\cdots&A_{nn}\\\end{vmatrix}
$$

3. 行列式 $A$ 中某行(或列)用同一数 $k$ 乘,其结果等于 $kA$。

$$\begin{vmatrix}A_{11}&A_{12}&A_{13}&\cdots&A_{1n}\\A_{21}&A_{22}&A_{23}&\cdots&A_{2n}\\\vdots&\vdots&\vdots&\vdots&\vdots\\kA_{a1}&kA_{a2}&kA_{a2}&\cdots&kA_{an}\\\vdots&\vdots&\vdots&\vdots&\vdots\\A_{n1}&A_{n2}&A_{n3}&\cdots&A_{nn}\\\end{vmatrix}=k\begin{vmatrix}A_{11}&A_{12}&A_{13}&\cdots&A_{1n}\\A_{21}&A_{22}&A_{23}&\cdots&A_{2n}\\\vdots&\vdots&\vdots&\vdots&\vdots\\A_{a1}&A_{a2}&A_{a2}&\cdots&A_{an}\\\vdots&\vdots&\vdots&\vdots&\vdots\\A_{n1}&A_{n2}&A_{n3}&\cdots&A_{nn}\\\end{vmatrix}$$

4. 行列式 $A$ 的某行（或列）中各元同乘一数后加到另一行（或列）中各对应元上，行列式不变。

$$\begin{vmatrix} A_{1,1} &A_{1,2} &\cdots &A_{1,n}\\ A_{2,1} &A_{2,2} &\cdots &A_{2,n}\\ \vdots &\vdots &\ddots &\vdots\\ A_{i,1} &A_{i,2} &\cdots &A_{i,n}\\ \vdots &\vdots &\ddots &\vdots\\ A_{j,1}+k\times A_{i,1} &A_{j,2}+k\times A_{i,2} &\cdots &A_{j,2}+k\times A_{i,n}\\ \vdots &\vdots &\ddots &\vdots\\ A_{n,1}&A_{n,2}&\cdots&A_{n,n}\\ \end{vmatrix} = \begin{vmatrix} A_{1,1} &A_{1,2} &\cdots &A_{1,n}\\ A_{2,1} &A_{2,2} &\cdots &A_{2,n}\\ \vdots &\vdots &\ddots &\vdots\\ A_{i,1} &A_{i,2} &\cdots &A_{i,n}\\ \vdots &\vdots &\ddots &\vdots\\ A_{j,1} &A_{j,2} &\cdots &A_{j,2}\\ \vdots &\vdots &\ddots &\vdots\\ A_{n,1}&A_{n,2}&\cdots&A_{n,n}\\ \end{vmatrix}+\begin{vmatrix} A_{1,1} &A_{1,2} &\cdots &A_{1,n}\\ A_{2,1} &A_{2,2} &\cdots &A_{2,n}\\ \vdots &\vdots &\ddots &\vdots\\ A_{i,1} &A_{i,2} &\cdots &A_{i,n}\\ \vdots &\vdots &\ddots &\vdots\\ k\times A_{i,1} &k\times A_{i,2} &\cdots &k\times A_{i,n}\\ \vdots &\vdots &\ddots &\vdots\\ A_{n,1}&A_{n,2}&\cdots&A_{n,n}\\ \end{vmatrix}
$$

证明一般用定义证明 $1.$ 和 $2.$，再用 $2.$ 证明 $3.$，用 $3.$ 证明 $4.$

### 高斯消元

学完性质之后，我们发现一条性质非常有用：

> 4. 行列式 $A$ 的某行（或列）中各元同乘一数后加到另一行（或列）中各对应元上，行列式不变。

这个性质非常像线性方程组的求法！

所以，从这里开始，我们想到 **高斯消元**

为什么呢？

从定义可以看出，如果行列式中出现 $0$，就能简化很多的计算。

而高斯消元正好可以把一个矩阵变化为上三角矩阵，每行（列）都会出现 $0$

接下来就可以到下一步了。

### 代数余子式

好，这又是一个新的概念

这个概念应该先从余子式谈起。

余子式，就是一个行列式划掉一行、一列后的新行列式的值，一般用 $M$ 表示。即
$$M_{ab}=\begin{vmatrix}A_{11}&A_{12}&A_{13}&\cdots&A_{1(b-1)}&A_{1(b+1)}&\cdots&A_{1n}\\A_{21}&A_{22}&A_{23}&\cdots&A_{2(b-1)}&A_{2(b+1)}&\cdots&A_n\\\vdots&\vdots&\vdots&\vdots&\vdots&\vdots&\vdots&\vdots\\A_{(a-1)1}&A_{(a-1)2}&A_{(a-1)3}&\cdots&A_{(a-1)(b-1)}&A_{(a-1)(b+1)}&\cdots&A_{(a-1)n}\\A_{(a-1)1}&A_{(a-1)2}&A_{(a-1)3}&\cdots&A_{(a+1)(b-1)}&A_{(a+1)(b+1)}&\cdots&A_{(a+1)n}\\\vdots&\vdots&\vdots&\vdots&\vdots&\vdots&\vdots&\vdots&\\A_{n1}&A_{n2}&A_{n3}&\cdots&A_{n(b-1)}&A_{n(b+1)}&\cdots&A_{nn}\\\end{vmatrix}
$$

而代数余子式就是 $A_{ab}=(-1)^{a+b}M_{ab}$

$$A_{ab}=(-1)^{a+b}\begin{vmatrix}A_{11}&A_{12}&A_{13}&\cdots&A_{1(b-1)}&A_{1(b+1)}&\cdots&A_{1n}\\A_{21}&A_{22}&A_{23}&\cdots&A_{2(b-1)}&A_{2(b+1)}&\cdots&A_n\\\vdots&\vdots&\vdots&\vdots&\vdots&\vdots&\vdots&\vdots\\A_{(a-1)1}&A_{(a-1)2}&A_{(a-1)3}&\cdots&A_{(a-1)(b-1)}&A_{(a-1)(b+1)}&\cdots&A_{(a-1)n}\\A_{(a-1)1}&A_{(a-1)2}&A_{(a-1)3}&\cdots&A_{(a+1)(b-1)}&A_{(a+1)(b+1)}&\cdots&A_{(a+1)n}\\\vdots&\vdots&\vdots&\vdots&\vdots&\vdots&\vdots&\vdots&\\A_{n1}&A_{n2}&A_{n3}&\cdots&A_{n(b-1)}&A_{n(b+1)}&\cdots&A_{nn}\\\end{vmatrix}$$

#### 代数余子式的性质

 $n$ 阶行列式 $D_n=|a_{ij}|$ 等于它的任一行(列)的所有元素与其对应的代数余子式的乘积之和：
 $$D_n=a_{i1}A_{i1}+a_{i2}A_{i2}+...+a_{in}A_{in}$$
 $$D_n=a_{1j}A_{1j}+a_{2j}A_{2j}+...+a_{nj}A_{nj}$$

### 求值

1. 对当前行列式消元

2. 取最末（右下角）位的指和其余子式，余子式作为新行列式重新做消元

这样不停消元下去，最后得到一个上三角行列式。

而由代数余子式的性质，这个行列式就是对角线元素之积了。

所以……就做完了？

## 代码

```cpp
#include <bits/stdc++.h> 
#define lld long long
using namespace std;
int mod;
int solve(vector < vector < int > > mat) {
	int n = mat.size();
	int i, j, k;
	int d, w = 1;
	for (i = 0; i < n; ++ i) {
		for (j = i + 1; j < n; ++ j) {
			while (mat[i][i]) {
				d = mat[j][i] / mat[i][i];
				for (k = i; k <= n; ++ k)
					mat[j][k] = ((mat[j][k] - (lld)d * mat[i][k] % mod) % mod + mod) % mod;
				swap(mat[i], mat[j]);
				w = -w;
			}
			swap(mat[i], mat[j]);
			w = -w;
		}
	}
	int ret = w;
	for (i = 0; i < n; ++ i) ret = (lld)ret * mat[i][i] % mod;
	return (ret + mod) % mod;
}
int main() {
	vector < vector < int > > mat;
	int n;
	scanf("%d%d", & n, & mod);
	mat.resize(n);
	int i, j;
	lld k;
	for (i = 0; i < n; ++ i)
		for (j = 0; j < n; ++ j) {
			scanf("%lld", & k);
			k %= mod;
			mat[i].push_back(k);
		}
	printf("%d\n", solve(mat));
}
```

## 后记

最长的题解，$\LaTeX$ 太容易炸了

---

## 作者：zzx0102 (赞：1)

update on 2023.4.27：将 `$det$` 改成 `$\det$`。

矩阵行列式的表示方法：一个 $n\times n$ 的矩阵 $A$ 的行列式记做 $\det(A)$ 或者 $|A|$。

一个 $2\times 2$ 的矩阵 $\begin{bmatrix}
   a & b\\
   c & d\\
\end{bmatrix}$ 行列式为 $ad-bc$。

矩阵行列式的定义：$\det(A)=|A|=\sum_{p}(-1)^{\tau(p)}\prod a_{i,p_i}$，$\tau(p)$ 指 $p$ 的逆序对个数。

矩阵行列式的性质：

* $\det(A^T)=\det(A)$

* 若 $A$ 为三角形矩阵，则 $\det(A)=A$ 的对角元素的乘积。

* 若 $A$ 的元素全为 $0$ 或者有两行或两列相等或成比例时，$\det(A)=0$。

* 将 $A$ 的每个元素乘以相同的数 $k$，矩阵行列值不变。

* 果行列式对应矩阵 $A$ 中有一行（列），是对应两个矩阵 $B,C$ 中分别的 $2$ 行（列）所有元素之和，那么有 $\det(A)=\det(B)+\det(C)$。

接下来，问题是如何求矩阵行列式的值。

还是消元。

我们考虑一个情况，当一个矩阵任意一个位置出现 $0$，其对行列式的影响非常大，一旦选到 $0$ 就对答案没有任何贡献了。

考虑可以通过消元和前面的性质使得矩阵中出现更多的 $0$。

显然瞎转化肯定是不行的，我们要让运算次数尽可能少，否则会 TLE。

我们知道求解线性方程组的算法高斯消元。其实高斯消元在做增广矩阵行（初等）变换为行最简形时的步骤和转化相当类似。

我们现在考虑将矩阵一行（列）消成只有最后一个元素非 $0$ 该怎么做。

这里引入代数余子式的概念：

在一个 $n$ 阶行列式 $D$ 中选定 $k$ 行 $k$ 列可以组成一个 $k$ 阶子行列式 $A$；

删除在 $k$ 行 $k$ 列后剩下的 $n-k$ 阶行列式称为 $A$ 对应的 $n-k$ 阶余子式 $M$。

对于一个元素 $a_{i,j}$ 的代数余子式为 $A_{i,j}$，余子式为 $M_{i,j}$，则

$$A_{i,j}=(-1)^{i+j}\times M_{i,j}$$

枚举第 $i$ 行，找到第 $i$ 行某个非 $0$ 元素并将该列与第 $i$ 列交换，然后把 $a_{i,i}$ 变为 $1$，再用这一行消剩下所有行的第 $i$ 列即可。

然而 $a_{i,i}$ 在模 $p$ 意义下不一定有逆元（$p$ 不一定是质数）。考虑到可以任意相减，这个性质和辗转相除法很相似，可以考虑对两行进行辗转相除，这样一定可以消掉某行第 $i$ 列，很像高斯消元。复杂度 $O(n^3)$，卡一卡常，可以冲过去。如果还卡不过去，就把矩阵 $A$ 用指针存储。

参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define I inline
#define W while
#define gc getchar
#define pc putchar
namespace SlowIO {
    I int read() {
        int x = 0; char ch = gc();
        W(ch < '0' || ch > '9') ch = gc();
        W(ch >= '0' && ch <= '9') x = x * 10 + (ch ^ 48), ch = gc();
        return x;
    }
    I void Read(int &x) {x = read();}
} using namespace SlowIO;
int p, n; const int N = 610; int *A[N], a[N][N];
int solve() {
	int flag = 1;
	for(int i = 1; i <= n; i++) {
		for(int j = i + 1; j <= n; j++) {
			while(A[j][i]) {
				int t = A[i][i] / A[j][i];
				for(int k = i; k <= n && t; k++)
					A[i][k] = ((A[i][k] - 1ll * t * A[j][k] % p) % p + p) % p;
				swap(A[i], A[j]);
				flag = -flag;
	 		}
		}
	}
	int ret = flag;
	for(int i = 1; i <= n; i++) ret = 1ll * ret * A[i][i] % p;
	return (ret + p) % p;
}
int main() {
	cin >> n >> p;
	for(int i = 1; i <= n; i++) A[i] = a[i];
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= n; j++) {
			Read(A[i][j]); A[i][j] %= p;
		}
	cout << solve();
	return 0;
}
```

---


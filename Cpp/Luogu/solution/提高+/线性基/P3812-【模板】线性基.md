# 【模板】线性基

## 题目背景

这是一道模板题。


## 题目描述

给定 $n$ 个整数（数字可能重复），求在这些数中选取任意个，使得他们的异或和最大。


## 说明/提示

$ 1 \leq n \leq 50, 0 \leq S_i < 2 ^ {50} $


## 样例 #1

### 输入

```
2
1 1```

### 输出

```
1```

## 样例 #2

### 输入

```
4
1 5 9 4
```

### 输出

```
13
```

# 题解

## 作者：Marser (赞：350)

## 线性基简介

线性基是一种擅长处理异或问题的数据结构.设值域为$[1,N]$，就可以用一个长度为$\lceil \log_2N \rceil$的数组来描述一个线性基。特别地，线性基第$i$位上的数二进制下最高位也为第$i$位。

一个线性基满足，对于它所表示的所有数的集合$S$，$S$中任意多个数异或所得的结果均能表示为线性基中的元素互相异或的结果，即意，线性基能使用异或运算来表示原数集使用异或运算能表示的所有数。运用这个性质，我们可以极大地缩小异或操作所需的查询次数。

## 插入和判断
我们考虑插入的操作，令插入的数为$x$，考虑$x$的二进制最高位$i$，
- 若线性基的第$i$位为$0$，则直接在该位插入$x$，退出；
- 若线性基的第$i$位已经有值$a_i$，则$x = x\oplus a_i$，重复以上操作直到$x=0$。

如果退出时$x=0$，则此时线性基已经可以表示原先的$x$了；反之，则说明为了表示$x$，往线性基中加入了一个新元素。

很容易证明这样复杂度为$\log_2x$，也可以用这种方法判断能否通过原数列异或得到一个数$x$。

```cpp
void ins(ll x){
    for(reg int i=MN;~i;i--)
        if(x&(1ll<<i))
            if(!a[i]){a[i]=x;return;}
            else x^=a[i];
    flag=true;
}
bool check(ll x){
    for(reg int i=MN;~i;i--)
        if(x&(1ll<<i))
            if(!a[i])return false;
            else x^=a[i];
    return true;
}
```

## 查询异或最值
查询最小值相对比较简单。考虑插入的过程，因为每一次跳转操作，$x$的二进制最高位必定单调降低，所以不可能插入两个二进制最高位相同的数。而此时，线性基中最小值异或上其他数，必定会增大。所以，直接输出线性基中的最小值即可。

考虑异或最大值，从高到低遍历线性基，考虑到第$i$位时，如果当前的答案$x$第$i$位为$0$，就将$x$异或上$a_i$；否则不做任何操作。显然，每次操作后答案不会变劣，最终的$x$即为答案。

同样，我们考虑对于一个数$x$，它与原数列中的数异或的最值如何获得。用与序列异或最大值类似的贪心即可解决。
## 查询$k$小值
我们考虑进一步简化线性基。显然，一个线性基肯定可以表示为若干个形如$2^i$的数。从高到低处理线性基每一位，对于每一位向后扫，如果当前数第$i$位为$0$，且线性基第$i$位不为$0$,则将当前数异或上$a_i$。这一操作可以在$O(\log_2^2 n)$的时间内解决。

经过这一步操作后，设线性基内共有$cnt$个数，则它们共可以表示出$2^{cnt}$个数。当然，对于$0$必须特殊考虑。如果插入的总数$n$与$cnt$相等，就无法表示$0$了。

同样，考虑最小值时，也必须要考虑到$0$的情况。事实上，如果插入时出现了未被加入的元素，就肯定可以表示出$0$。

随后，我们考虑将$k$二进制拆分，用与快速幂类似的方法就可以求出第$k$大值。

学过线性代数的同学应该可以看出，这个过程就是对一个矩阵求解异或意义下的秩的过程。因此，$cnt \leq \lceil \log_2N \rceil$一定成立。而最终，线性基中保存的也是异或意义下的一组极小线性无关组。

同样，有关线性基的一切运算都可以看做矩阵的初等行列变换，也就可以将其看做线性规划问题。同样，可以离线使用高斯消元来构造极小线性基。

```cpp
bool flag;//可以表示0
ll qmax(ll res=0){
    for(reg int i=MN;~i;i--)
        res=max(res,res^a[i]);
    return res;
}
ll qmin(ll res=0){
    if(flag)return 0;
    for(reg int i=0;i<=MN;i++)
        if(a[i])return a[i];
}
ll query(ll k){
    reg ll res=0;reg int cnt=0;
    k-=flag;if(!k)return 0;
    for(reg int i=0;i<=MN;i++){
        for(int j=i-1;~j;j--)
            if(a[i]&(1ll<<j))a[i]^=a[j];
        if(a[i])tmp[cnt++]=a[i];
    }
    if(k>=(1ll<<cnt))return -1;
    for(reg int i=0;i<cnt;i++)
        if(k&(1ll<<i))res^=tmp[i];
    return res;
}
```

## 代码
```cpp
#include<bits/stdc++.h>
#define reg register
using namespace std;
typedef long long ll;
const int MN=60;
ll a[61],tmp[61];
bool flag;
void ins(ll x){
    for(reg int i=MN;~i;i--)
        if(x&(1ll<<i))
            if(!a[i]){a[i]=x;return;}
            else x^=a[i];
    flag=true;
}
bool check(ll x){
    for(reg int i=MN;~i;i--)
        if(x&(1ll<<i))
            if(!a[i])return false;
            else x^=a[i];
    return true;
}
ll qmax(ll res=0){
    for(reg int i=MN;~i;i--)
        res=max(res,res^a[i]);
    return res;
}
ll qmin(){
    if(flag)return 0;
    for(reg int i=0;i<=MN;i++)
        if(a[i])return a[i];
}
ll query(ll k){
    reg ll res=0;reg int cnt=0;
    k-=flag;if(!k)return 0;
    for(reg int i=0;i<=MN;i++){
        for(int j=i-1;~j;j--)
            if(a[i]&(1ll<<j))a[i]^=a[j];
        if(a[i])tmp[cnt++]=a[i];
    }
    if(k>=(1ll<<cnt))return -1;
    for(reg int i=0;i<cnt;i++)
        if(k&(1ll<<i))res^=tmp[i];
    return res;
}
int main(){
    int n;ll x;scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%lld",&x),ins(x);
    printf("%lld\n",qmax());
    return 0;
}
```

---

## 作者：wrpwrp (赞：213)

upd:补了点东西
## 用处
~~没用我学这东西干嘛~~  
+ 快速查询一个数是否可以被一堆数异或出来
+ 快速查询一堆数可以异或出来的最大/最小值
+ 快速查询一堆数可以异或出来的第k大值  

~~这么点？~~  
还有点性质在下面 ~~可能有点用~~  
## 性质 
+ 原数列里的任何一个数都可以通过线性基里的数异或表示出来
+ 线性基里任意一个子集的异或和都不为$0$
+ 一个数列可能有多个线性基，但是线性基里数的数量一定唯一，而且是满足性质一的基础上最少的

## 原理&实现  
由于我想写简单一点，直接对代码写，所以真正的关于线性代数的那一部分就没写了 ~~妄图掩盖自己不会的事实~~  
### 约定
以下$p[i]$表示原序列的线性基数组。
### 构造
~~先贴代码~~
把一个数插入线性基：
``` cpp
inline void ins(LL x) {
	for(R int i=62;i>=0;i--)
		if(x&(1LL<<i)) {
			if(!p[i]) { p[i]=x,cnt++; break; }
			else x^=p[i];
		}
}
```
人话描述：
+ 从高位到低位进行。
+ 如果$x_{(2)}$第$i$位为$1$，判断$p[i]$是否插入，没有就插入**并且退出**，否则就异或上$p[i]$去进行下一位操作 。 
  
那么，通过观察这个构造，我们再来~~感性~~理解线性基。
+ 异或的一个小性质：$ x \oplus y \oplus y =x $。
+ 性质一：观察插入过程，如果没有成功插入，对于$x_{(2)}$的每一位，要不就是不存在，要不就是异或上$p[i]$变成了$0$，那么最终$x$如果没有插入，那就意味着原有的线性基可以把它异或出来，它就没有插入的必要了。而更显然的，线性基中的数肯定是可以表示的。于是**原序列中的每一个数都可以通过线性基表示出来。**
+ 性质二：假设出现了$p[1] \oplus p[2]\oplus p[3]=0$,那就会有$p[1]\oplus p[2]=p[3]$，根据之前的定义，$p[3]$是不会被插入的。所以也可以得出线性基的任意一个子集异或和都不为$0$，所以在之后求第$k$大的时候和一些别的时候，**注意特判$0$**。
+ 性质三：考虑分类讨论
    + 当所有元素都可以插入线性基的时候，性质三显然成立
    + 设有一个元素$x$不能插入线性基，那就会有$x=0$或者是$p[a]\oplus p[b]\oplus p[c]=x$。显然当$x=0$的时候无论如何都不能插入线性基，而另一种情况则代表等式$p[a]\oplus p[b]\oplus x=p[c]$也就是说如果先插入$x$，$p[c]$就无法插入了，又因为观察插入过程的时候，每一个插入的数对应着一位，所以$x$与$p[c]$相排斥只会影响一位上的问题，那也就代表着**线性基里的数可能不同，但是总数肯定是一定的**。  

于是我们初步理解了线性基  
### 查询一个元素是否可以被异或出来
从高到低，如果这一位为$1$就异或上这一位的线性基，把$1$消去，根据性质一，如果最后得到了$0$，那这个数就可以表示出来。
```cpp
inline int ask(LL x) {
	for(R int i=62;i>=0;i--) 
		if(x&(1LL<<i)) x^=p[i];
	return x==0;
}
```
### 查询异或最大值
按位贪心即可。
```cpp
inline LL askmx() {
	LL ans=0;
	for(R int i=62;i>=0;i--)
		if((ans^p[i])>ans) ans^=p[i];
	return ans;
}
```
### 查询异或最小值
其实异或的最小值一般来说就是线性基里的最小元素，因为插入这个元素的时候我们总是尽量让它的高位为$0$才来插入这一位。但是为什么是“一般”呢？因为有可能会有出现$0$，得要在插入的时候记下个标记来特判才行。
```cpp
inline LL askmn() {
	if(zero) return 0;
	for(R int i=0;i<=62;i++)
		if(p[i]) return p[i];
}
```
### 查询异或第$k$小
这个东东我感觉实现还是有那么点点复杂的哈。
首先考虑，要是每一位的选择都不会影响下一位的话，那就可以直接从高到低按位去选择就行了，就类似于二叉树求$rank$的玩法。但是我们之前建出来的线性基是没有这个性质的。比如$p[3]=101_{2},p[0]=1_{2}$的时候就炸了。所以我们考虑重构一个数组$d$来解决这个问题。先上代码：
```cpp
inline void rebuild() {
	cnt=0;top=0;
	for(R int i=MB;i>=0;i--)
		for(R int j=i-1;j>=0;j--)
			if(p[i]&(1LL<<j)) p[i]^=p[j];
	for(R int i=0;i<=MB;i++) if(p[i]) d[cnt++]=p[i];
}
```
那么这是在干啥呢，就是在尽力把每个$p[i]$只留下第$i$位的$1$，从而使得各个位之间互不影响，也就是说它的理想效果如下：
$p[0] ~0~0~0~0~1$
$p[1] ~0~0~0~1~0$
$p[2] ~0~0~1~0~0$
$p[3] ~0~1~0~0~0$
$p[4] ~1~0~0~0~0$
但有时候并不能达到这个样子，可能会出现如下情况：
$p[0] ~0~0~0~0~1$
$p[1] ~0~0~0~0~0$
$p[2] ~0~0~1~0~0$
$p[3] ~0~1~0~0~0$
$p[4] ~1~0~0~1~0$
但是这个时候我们注意到，我们的目的已经达到了，互不影响的任务已经达成了，显然此时为$0$的$p$值不会对排名有任何影响，不用管它了。把信息导入到$d$数组后，查询$k$小代码不难写出：
```cpp
inline LL kth(int k) {
	if(k>=(1LL<<cnt)) return -1;
	LL ans=0;
	for(R int i=MB;i>=0;i--)
		if(k&(1LL<<i)) ans^=d[i];
	return ans; 
}
```
其实我个人觉得这个代码还得要自己理解一下。  
~~背板子也行~~
但是这样其实还不太对，因为我们并没有考虑$0$的情况，所以还要去考虑一下$0$的情况，特判即可。
```cpp
printf("%lld\n",tmp-zero?kth(tmp-zero):0LL);
```
### 查询排名
```cpp
inline int rank(LL x) {
      int ans = 0;
      for(R int i = cnt - 1; i >= 0; i --)
                  if(x >= d[i]) ans += (1 << i), x ^= d[i];
      return ans + zero; 
}
```
注：这个$d[i]$是重建后的线性基。

于是线性基的基本操作就结束啦！
## 习题
1. [Luogu P3812 线性基](https://www.luogu.com.cn/problem/P3812)
[code](https://www.cnblogs.com/HN-wrp/p/12812931.html)

2. [Luogu P3857 [TJOI2008]彩灯](https://www.luogu.com.cn/problem/P3857)
[code](https://i-beta.cnblogs.com/posts/edit;postId=12812964)
3. [Luogu P4301 [CQOI2013]新Nim游戏](https://www.luogu.com.cn/problem/P4301)
[code](https://www.cnblogs.com/HN-wrp/p/12812983.html)
4. [Luogu P4570 [BJWC2011]元素](https://www.luogu.com.cn/problem/P4570)
[code](https://www.cnblogs.com/HN-wrp/p/12813004.html)
5. [HDU 3949 XOR](http://acm.hdu.edu.cn/showproblem.php?pid=3949)
   [code](https://www.cnblogs.com/HN-wrp/p/12813014.html)
6. [Luogu P4151 [WC2011]最大XOR和路径](https://www.luogu.com.cn/problem/P4151)
   [code](https://www.cnblogs.com/HN-wrp/p/12818708.html)
7. [Luogu P3292 [SCOI2016]幸运数字](https://www.luogu.com.cn/problem/P3292)
   [code](https://www.cnblogs.com/HN-wrp/p/12820816.html)
## EX
[dalao博客](https://blog.sengxian.com/algorithms/linear-basis)


---

## 作者：万弘 (赞：42)

似乎洛谷的题解没有和蓝书做法相同的。。那我来介绍一下蓝书的做法。  
先来一些定义：  
考虑将n个数（二进制下）看成n个向量，每个向量中的每个元素仅有0、1两种取值。  
如果向量$X$能被$a_1,a_2..a_n$这些向量通过异或运算得到，则称$X$能被$a_1,a_2..a_n$**表出**。如果某个向量集合中存在若干个向量能被其它向量表出，则这些向量**线性相关**，否则**线性无关**  
**定义一个向量集合的线性基为其极大线性无关子集**（可能有多个线性基，但这没有关系）（显然线性基可以表出这个向量集合）  
**线性空间**是对异或运算封闭的向量集合。

另外，异或高斯消元仅有向量间的异或操作，所以消元不会改变这些向量能表出的线性空间。因此，高斯消元可以求得一组线性基。

现在回到本题。（为了简便，可以将向量压缩为一个整数）先用高斯消元求得一组线性基。由高斯消元可得（没有学习过高斯消元的请出门左转高斯消元题解区），该线性基中，主元所在位为1的向量是唯一的。接下来我们可以从高位到低位贪心了。假设现在在考虑第$i$个向量$a_i$（向量降序），其最高位是$x$,前$i-1$个向量异或得到的最大整数为$res$。
1. 如果$res$的第$x$位是0，则令$res\ xor\ a_i$
2. 否则不改变$res$

接下来考虑这种做法的正确性。  
如果$res$的第$x$位是0但不改变$res$，而改变得到$res'$。由于向量降序，比x更高的位和x这一位无法再改变。即使$res$接下来的位全部是1，也没有x这一位是1大，即得到$res<res'$.因此操作1正确。  
如果$res$的第$x$位是1但改变res，得到$res'$.由于向量降序，比x更高的位和x这一位无法再改变。即使$res'$接下来的位全部是1，也没有x这一位是1大，即得到$res'<res$.因此操作2正确。  
证毕。  
对线性基中的向量（降序）做这两种操作即可。时间复杂度瓶颈在于高斯消元，将向量压缩为整数优化后为$O(n^2)$ （因此请求管理加大数据范围至$n\le 5000$）
```cpp
/**********/
typedef unsigned long long ull;
#define MAXN 5011
ll a[MAXN];
int main()
{
	ll n=read(),t=n;//t是线性基大小
	for(ll i=1;i<=n;++i)a[i]=read();
	for(ll i=1;i<=n;++i)//异或高斯消元
	{
		for(ll j=i+1;j<=n;++j)
			if(a[j]>a[i])std::swap(a[j],a[i]);
		if(!a[i])
		{
			t=i-1;break;
		}
		for(ll j=51;j>=0;--j)
			if(a[i]&(1ull<<j))
			{
				for(ll k=1;k<=n;++k)
					if(i!=k&&(a[k]&(1ull<<j)))a[k]^=a[i];
				break;
			}
	}
	ll ans=0;
	for(ll i=1;i<=t;++i)
	{
		for(ll j=51;j>=0;--j)//找最高位
			if(a[i]&(1ull<<j))
			{
				if(!(ans&(1ull<<j)))ans^=a[i];//操作1
				break;
			}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：rui_er (赞：36)

刚刚口胡并学了线性基，就来写篇题解，记录一下。

---

从 $n$ 个数中选取若干个，使他们的异或和最大。

既然是异或和，因为异或是位运算，肯定要用到二进制的。

考虑异或和的性质：对于这一位，有奇数个 $1$ 求异或和，结果为 $1$；有偶数个 $1$ 求异或和，结果为 $0$。这一性质告诉我们，当我们对当前位置完成决策的时候，后面所有位的异或和无论怎样也不会影响到现有结果。想到从高位到低位扫一遍，对每一位取最优决策，就是结果。

但因为每一位二进制位可能有很多 $1$，不方便进行决策，于是思考能不能**构造一个序列，使得在这个序列中，任取若干个数求异或和的结果组成的集合，与原序列求异或和的结果组成的集合一样，且这个序列的每个数的最高位 $1$ 所在位数不一样**呢？这种情况下，我们在新序列上决策和在原数列上决策是等效的。

~~但是我太菜了发现并不会构造，怎么办呢？上百度搜线性基正解吧。~~

结果一搜发现我已经口胡出来了，愣是傻傻的不会构造 /jk /jk，那就继续说吧。

线性基就是由原数列集合构造出的满足下面性质的集合：

1. 线性基内的元素可以通过求异或和，得到原集合的元素任意求异或和得到的所有值。
2. 线性基是满足上面性质的最小的集合。
3. 线性基不存在异或和为 $0$ 的子集。
4. 线性基中，任取不同的子集求异或和，得到的答案不同。（即线性基子集的异或和具有唯一性）
5. 线性基内所有元素的二进制最高位互不相同。

考虑进行构造：

在线性基插入元素 $x$，从高位向低位扫，如果 $x$ 二进制下该位为 $1$，且不存在最高位为该位的线性基元素，将其加入线性基。如果该位为 $1$，但已经存在元素的最高位为该位，将 $x$ 异或上该元素，继续向后搜。

要查询最大值，从高位到低位枚举线性基中最高位为该位的元素，如果答案异或上这个数比原来的答案大，更新答案。这样因为更低位的结果无法影响当前位，因此这一方法是最优的。

---

代码：

```cpp
//By: Luogu@rui_er(122461)
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 55, bit = 50;
 
ll n, a, p[N];
void insert(ll k) {
	for(ll i=bit;i>=0;i--) {
		if(!(k&(1LL<<i))) continue;
		if(!p[i]) return p[i] = k, void();
		k ^= p[i];
	}
}
ll maxXor() {
	ll res = 0;
	for(ll i=bit;i>=0;i--) res = max(res, (res^p[i]));
	return res;
}

int main() {
	scanf("%lld", &n);
	while(n--) {scanf("%lld", &a); insert(a);}
	printf("%lld\n", maxXor());
	return 0;
}
```

---

## 作者：JK_LOVER (赞：13)

若格式炸了来这里[博客](https://www.luogu.com.cn/blog/xzc/)
# 线性基
## 介绍：
用一个权值大小为 $[1,\log n]$ 的数组来表述一个权值大小为 $[1,n]$ 的原数组的异或问题的数据结构。
## 实质：
多维向量的作为基底的特殊形式，可用高斯消元理解。（关于实质下文用题专门讲解）
## 性质：
- 1.线性基是原数组的极大线性无关组。所以线性基也就拥有一下性质：
-  （1）只含零向量的向量组没有极大无关组；
-  （2）一个线性无关向量组的极大无关组就是其本身；
-  （3）极大线性无关组对于每个向量组来说并不唯一，但是每个向量组的极大线性无关组都含有相同个数的向量；
-  （4）齐次方程组的解向量的极大无关组为基础解系。
-  （5）任意一个极大线性无关组都与向量组本身等价。
-  （6）一向量组的任意两个极大线性无关组都是等价的。
- （7）若一个向量组中的每个向量都能用另一个向量组中的向量线性表出，则前者极大线性无关向量组的向量个数小于或等于后者。----来自于百度
- 2.线性基中每个元素只有唯一异或方案。
- 3.线性基的每一个的元素的最高位也是该元素在线性基的位次。（此性质是定义）。
- 4.线性基的二进制最高位互不相同。（此性质是定义）
- 5.如果线性基有 $n$ 个元素，它的可异或的个数为 $2^n-1$。
- 6.线性基中元素互相异或，异或集合不变。

## 证明：
- 性质1：线性基中每个元素只有唯一异或方案：

A,B,C,D四个不可被相互表达的元素，但 $\oplus$ 满足交换率。所以总有一个元素是多余的。
$$ A \oplus B = C \oplus D \Leftrightarrow A \oplus B \oplus C = D $$

- 性质2：线性基有 $n$ 个元素，它的可异或的个数为 $2^n-1$：

因为 $\oplus$ 有性质 $A\oplus A=0$ 所以，在表示的元素中，要么这个元素参与组成，要么不参加组成。而又因为性质1，所以一个原元素可表达为：

$$A=a_1 b_1\oplus a_2 b_2 \oplus....\oplus a_nb_n (a_i=1,0)$$

而又因为 $a_i$ 不可全为 0 所以共有 $2^n-1$ 个元素可被表达。

- 性质3：线性基中元素互相异或，异或集合不变：

仍可用异或的交换率来解释，本人感觉这条和性质2是等价的。
## 运用：
终于到了正题,我们先来了解一下线性基的构建。
### 构建线性基
因为线性基要满足 $\text{线性基的二进制最高位互不相同}$ 这条性质的，所以我们在建造线性基就必须注意这一点。

在每次插入一个数时由高到低枚举二进制位，当这个元素此位是一时，若此位已经被插入就用它异或该位的元素，这样是为了满足 $\text{线性基的每一个的元素的最高位也是该元素在线性基的位次}$ 这个性质。

否则就将该元素放入，然后退出。

```cpp
void insert(int x)//插入线性基 
{
	for(int i = 63;i>=0;i--)
	{
		if(x&(1LL<<i))
		{
			if(!p[i])
			{
				p[i]=x;
				return;
			}
			x^=p[i];
		}
	}
}
```
### 查询异或最大值
当我们已经构建完线性基之后，我们就可以利用性质来实现一些算法了。

考虑最大异或最大值一定是尽量让最高位为1的元素，就可以考虑以下贪心：由高到低枚举线性基中的元素，如果此位为0，那么异或后一定更优，如果为1，那么异或后一定不会更优。
```cpp
	for(LL i = 62;i >= 0;i--)
	{
		if((ans>>i)&1)continue;
		else 
		ans^=p[i]; 
	}
```

或者直接这样写

```cpp
for(LL i = 62;i >= 0;i--)
	{
		if((p[i]^ans)>ans)
		{
			ans^=p[i];
		}
	}
```
都是可以的。

### 查询异或最小值
考虑最大异或最小值一定是尽量让最高位为0的元素，这不就是线性基最低位的性质嘛，那就直接输出最小值就好了。这就错了，我们在下定义时是将 $0$ 这个值排除的。所以还要特判是否有一个元素是没有被插入的

```cpp
int Min()//最小 
{ 
	if(pd==1) return 0;//如果可以构造出0，这里需要特判 
	for(int i = 0;i <= 62;i++)
	if(p[i]) return p[i];
}
```
### 查询第k大值
这里要用以下性质：

- 如果线性基有 $n$ 个元素，它的可异或的个数为 $2^n-1$。
- 线性基中元素互相异或，异或集合不变。
- （6）一向量组的任意两个极大线性无关组都是等价的。（等同于上面一条）

为了实现更多的功能，我们必须对原线性基改造。
#### rebuild
经过这个函数，我们可以使线性基有一个非常优秀的性质：

- 一个数二进制拆分后，每一位的线性基异或后所得到的值严格大于一个比它小的数所得的值。
```cpp
void rebuild()//重构线性基 
{
	for(int i = 63;i >= 0;i--)
	for(int j = i-1;j >= 0;j--)
	if(p[i]&(1LL<<j)) p[i]^=p[j];
	for(int i = 0;i <= 63;i++) if(p[i]) d[cnt++]=p[i];
}
```
作用显然是把一个高位的线性基的其它位变得更小，那又有什么用呢？
我们考虑用证明：
我们可以证明一个首项为 $1$ 公比为 $2$ 的等比数列是满足：

$$
a_i+a_j \neq a_i + a_k (k\neq j)
$$


$$
a_i+a_j \neq a_k + a_l
$$

上式满足 $i$ 和 $j$ 不同时等于 $k$ 和 $l$ 。

从而可得 $n$ 个数可构造 $2^{n}$ 个不同的数，而线性基则可看作为一种缺少某一项的等比数列之和。


又因为一个 $n-1$ 位的数无论怎么异或都不能大于或等于 $2^n$ 。所以有第 $n$ 个线性基参与的数一定在其下有 $2^{n-1}-1$ 个数。而第 $m$ 是没有线性基的，所以只能往上增加 $2^{n-1}$ 个。

### 第k大值

有了这个性质我们就可以轻易的写出查询第 $k$ 大的代码了。当然如果都大于线性基的个数范围了就可以 $return$ 掉。

```cpp
int kth(int k)//第k大 
{
	if(k >= (1LL<<cnt)) return -1;
	int ans=0;
	for(int i = 62;i>=0;i--)
	{
		if((k>>i)&1) ans^=d[i];
	}
	return ans;
}
```
## 例题（代码）

[P3812 【模板】线性基](https://www.luogu.com.cn/problem/P3812)
模板题，正常思路即可。


$I$:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int read()
{
	int x=0,f=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
	return f?-x:x;
}
#define N 100
int p[N],n,m,d[N],cnt=0;
void rebuild()//重构线性基 
{
	for(int i = 63;i >= 0;i--)
	for(int j = i-1;j >= 0;j--)
	if(p[i]&(1LL<<j)) p[i]^=p[j];
	for(int i = 0;i <= 63;i++) if(p[i]) d[cnt++]=p[i];
}
void insert(int x)//插入线性基 
{
	for(int i = 63;i>=0;i--)
	{
		if(x&(1LL<<i))
		{
			if(!p[i])
			{
				p[i]=x;
				return;
			}
			x^=p[i];
		}
	}
}
int kth(int k)//第k大 
{
	if(k >= (1LL<<cnt)) return -1;
	int ans=0;
	for(int i = 62;i>=0;i--)
	{
		if((k>>i)&1) ans^=d[i];
	}
	return ans;
}
int Max()//最大 
{
	return kth((1LL<<cnt)-1);
}
signed main()
{
	n=read();
	for(int i = 1;i <= n;i++){insert(read());}
	rebuild();
	cout<<Max()<<endl;
	return 0;
}

```
$II$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long 
LL read()
{
	LL x=0,f=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
	return f?-x:x;
}
LL n,ans,p[1919191];
void work(LL x)
{
	for(LL i = 62;i >= 0;i--)
	{
		if((1LL<<i)&x) 
		{
			if(!p[i]) {
				p[i] =x;
				return ;
			}
 			x^=p[i];
		}
		
	}
}
int main()
{
	n=read();
	while(n--)
	work(read());
	for(LL i = 62;i >= 0;i--)
	{
		if((ans>>i)&1)continue;
		else 
		ans^=p[i]; 
	}
	cout<<ans<<endl;
}
```



---

## 作者：_Weslie_ (赞：9)

## 线性基的定义

称线性空间 $V$ 的一个极大线性无关组为 $V$ 的一组 **Hamel 基**或**线性基**，简称**基**。（摘自 OI Wiki）

异或线性基，换句话说，就是最大的异或和不为 $1$ 的子集。

线性空间 $V$ 的线性基是不唯一的。

本题目要求我们求异或线性基。那么我们接下来介绍一下异或线性基的求法。

## 高斯消元法

### 过程

前置知识：[高斯消元](https://www.luogu.com.cn/problem/P3389)。

高斯消元法即把每个数化为二进制表示，然后用高斯消元法消成线性基。

例如：对于序列 $\{7,5,9,2\}$。

我们先把这四个数分别转化为二进制矩阵。

$$
\left(
\begin{array}{l}
0&1&1&1\\
0&1&0&1\\
1&0&0&1\\
0&0&1&0
\end{array}
\right)
$$

然后对这个矩阵进行高斯消元。

消元步骤如下：

1. 从高到低位枚举。由于要通过二进制算数，我们尽量把位数从 $0$ 开始从右往左以此递增。
2. 确定主元。假设枚举到了第 $i$ 位，我们需要找到一个该位为 $1$ 的数。
3. 对其他的数：假如这个数第 $i$ 位为 $1$，那就让这个数异或主元，让这一位变成 $0$。

例如，上面的矩阵。

第一步，枚举位数 $i=3$（该位的值为 $2^3$）。确定 $9$ 为主元。

$$
\left(
\begin{array}{l}
\color{red}{1}&\color{red}{0}&\color{red}{0}&\color{red}{1}\\
0&1&0&1\\
0&1&1&1\\
0&0&1&0
\end{array}
\right)
$$

其他元素在这一位上全部为 $0$，所以不必异或。

接下来枚举 $i=2$。由于第一个主元已经确定了，所以我们从后面的数选。

$$
\left(
\begin{array}{l}
\color{blue}{1}&\color{blue}{0}&\color{blue}{0}&\color{blue}{1}\\
\color{red}{0}&\color{red}{1}&\color{red}{0}&\color{red}{1}\\
0&1&1&1\\
0&0&1&0
\end{array}
\right)
$$

其中红色为主元，蓝色为已确定。

然后开始异或，元素 $7$ 需要被元素 $5$ 异或。得到：

$$
\left(
\begin{array}{l}
\color{blue}{1}&\color{blue}{0}&\color{blue}{0}&\color{blue}{1}\\
\color{red}{0}&\color{red}{1}&\color{red}{0}&\color{red}{1}\\
\color{purple}{0}&\color{purple}{0}&\color{purple}{1}&\color{purple}{0}\\
0&0&1&0
\end{array}
\right)
$$

其中紫色的元素被改变。

然后：枚举 $i=1$。确定主元为 $2$。异或另外一个 $2$。

$$
\left(
\begin{array}{l}
\color{blue}{1}&\color{blue}{0}&\color{blue}{0}&\color{blue}{1}\\
\color{blue}{0}&\color{blue}{1}&\color{blue}{0}&\color{blue}{1}\\
\color{red}{0}&\color{red}{0}&\color{red}{1}&\color{red}{0}\\
\color{purple}{0}&\color{purple}{0}&\color{purple}{0}&\color{purple}{0}
\end{array}
\right)
$$

现在我们就得到了一个线性基了。

### 优点

高斯消元后的矩阵是一个行简化阶梯形矩阵。这意味着，给定一些数，选其中一些异或起来，求异或最大值，使用高斯消元法构造线性基后直接将线性基中所有元素都异或起来输出即可。

### 代码

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
long long a[105],n,p[105],k;
const int bit=51;
void insert(){
	for(int i=bit;i>=0;i--){
		for(int j=k;j<n;j++) // 把当前第 i 位是 1 的数换上去
			if((p[j]>>i)&1){swap(p[j],p[k]); break;}
		
		if(((p[k]>>i)&1)==0) continue; // 当前第 i 位所有数都是 0	
		for(int j=0;j<n;j++) // 把其他数的第 i 位全部消为 0
			if(j!=k&&((p[j]>>i)&1)) p[j]^=p[k]; // 基的个数 +1
		k++; 
		if(k==n) break;
	}
}

long long ans=0;
signed main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>a[i];
		p[i]=a[i];
	}
	insert();
	for(int i=k;i>=0;i--){
		ans^=p[i];
	}
	cout<<ans;
	return 0;
}
```

### 复杂度分析

`insert` 函数的复杂度是 $\operatorname{O}(n\log W)$ 的（其中 $W$ 是值域）。总复杂度也是 $\operatorname{O}(n\log W)$。

## 贪心法

### 过程

每读到一个数，就插入进来，插入的时候按照以下步骤：

1. 从高往低枚举。
2. 如果这一位是 $1$，那么看这一位线性基上是否有数。如果有，就异或这个数，然后接着寻找；反之，则直接把线性基的这个位置赋值为这个数。

我们来个例子。还是 $\{7,5,9,2\}$。

首先，$p$ 从 $2^3$ 位到 $2^0$ 位分别是 $\{0,0,0,0\}$。插入 $7$，得到 $\{0,7,0,0\}$。

然后插入 $5$。$5$ 先在 $2^2$ 位碰到 $7$，异或之后变成 $2$。$2$ 要插入在 $2^1$ 位上。得到 $\{0,7,2,0\}$。

然后插入 $9$。得到 $\{9,7,2,0\}$。

最后的 $2$ 在 $2^1$ 位上遇到 $2$，异或之后变为 $0$，最终流掉。

得到的线性基是 $\{9,7,2,0\}$。显然这和高斯消元得到的线性基不同。

贪心法求最大值时，需要对线性基求前缀最大值，具体来说，枚举到第 $i$ 位时，需要用前缀的异或最大值去异或 $i$，更新新的最大值。例如到 $2^1$ 位，前缀最大异或值位 $14$，异或 $2$ 就不如不异或。所以一定要这么做。

### 优点

1. 贪心法码量略小（也没小多少）。
2. 贪心法可以按顺序增添线性基。

### 代码

```
#include<bits/stdc++.h>
using namespace std;
long long a[105],n,p[105];
const int bit=63;
void insert(long long now){
	for(int i=bit;i>=0;i--){
		if(!(now>>(long long)i))continue;
		if(!p[i]){
			p[i]=now;
			break;
		}
		now^=p[i];
	}
}
long long ans=0;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		insert(a[i]);
	}
	for(int i=bit;i>=0;i--){
		if((ans xor p[i])>ans)ans^=p[i];
	}
	cout<<ans;
	return 0;
}
```

### 复杂度分析

虽说贪心法一次插入仅为 $\operatorname{O}(\log W)$ 的复杂度，但是每输入一个数都要插入一次，所以总复杂度是 $\operatorname{O}(n\log W)$ 的。

这就是线性基的两种求法。

---

## 作者：lcfollower (赞：7)

前言
---

本文同步发表于 cnblog，链接点[这](https://www.cnblogs.com/2021zjhs005/p/18964763)。

如果有任何疑问或错误可以私信或评论。

Update
---

$2025.7.18$：被打回，修改了一处被审核员称之为烂掉的 $\KaTeX$。

开头
---

~~吐槽：oi-wiki 上写的啥东西啊太高深了看不懂一点~~。因此本文只有两处参考 [oi-wiki](https://oi-wiki.org/math/linear-algebra/basis/)。

线性基一般分【异或空间线性基】还有【实数空间线性基】。

对于【异或空间线性基】，有两种构造方法，分别是**贪心法**和**高斯消元法**。

Part 0. 异或空间中线性基的定义是什么？
---

我们讲得简单一点，具体一些线性代数的定义详见 [oi-wiki](https://oi-wiki.org/math/linear-algebra/basis/)。

假设有一个长 $n$ 的数组 $a$，我们希望构造出一组含有 $m$ 个元素的线性基 $p$，我们令 $a$ 所有数的组合（不一定要两个数，可以是多个数或 $1$ 个数）进行异或得到的值的并集为 $S$，$p$ 中所有数的组合进行异或得到的值得并集为 $T$，并且删除 $S$，$T$ 中的 $0$（即讨论情况为**正整数**），则满足：

比如 $a = [1,2,4]$，则 $S = \{1\}\cup \{2\}\cup \{4\}\cup \{1\oplus 2\}\cup \{1\oplus 4\}\cup \{2\oplus 4\} \cup \{1\oplus 2\oplus 4\} = \{1 ,2 ,3 ,4,5 ,6 ,7\}$。

- $S = T$。

- $m$ 在满足条件下最小。

- 注意：$p$ 中的元素不一定要在 $a$ 中出现。

有的资料中 $S$ 是所有数的集合（记作 $S1$）而不是组合过后异或值的集合（记作 $S2$），其实这两者是等价的。

- 假设 $T = S1$，然而 $S2$ 可以由多个 $S1$ 中的元素异或产生，而这些元素都可以被 $T$ 的子集表示，更何况**一个数异或两次等于没异或**，因此看着每个数可能要挑选大于 $1$ 次，不符合子集定义，但实际只用挑选 $0$ 或 $1$ 次即可满足。

- 也就是说，在 $S1$ 下生成的线性基 $p$ 在 $S2$ 下仍然适用。

- 所以是等价的。

我们最**理想**得到的线性基，满足 $p$ 中所有数在二进制下画到矩阵上，每一行第一个 $1$（下面简称最高位）所在列上有且仅有它一个 $1$。

可能有点难懂，举个例子，比如说 $p = [1 ,4 ,5]$，对应矩阵如下，括号里表示列数，实际写矩阵有关代码（比如下文的高斯消元法）肯定是从左到右为 $[1,m]$（$m$ 为矩阵列数），这里为了对应二进制位的位数定义才这样，实际矩阵应该也没有这种写法：

$$\begin{bmatrix}(2&1&0)\\0&0&1\\1&0&0\\1&0&1\end{bmatrix}$$

第二行和第三行的最高位都是第 $2$ 列，不符合我们的设定。

然而，如果 $p = [1,4,11]$，可以构造如下矩阵：

$$\begin{bmatrix}(3&2&1&0)\\0&0&0&1\\0&1&0&0\\1&0&1&1\end{bmatrix}$$

尽管第 $0$ 列中，第 $1$，$3$ 行出现了两个 $1$，但是第 $3$ 行第 $0$ 列的 $1$ 不是第 $3$ 行最高位，所以这是我们想要的线性基。

Part 1. 线性基的几个主要性质和结论
---

- 参考文献：[【学习笔记】浅谈异或线性基](https://www.luogu.com.cn/article/zo12e4s5)。

1. 对于两数 $a$，$b$，如果 $a = b$，那么可以只保留 $a$，$b$ 中的一个。
  - 设存在一个数 $c$，我们可以删除 $b$，因为 $a = b$，所以 $a\oplus c = b\oplus c$。
  
  - 尽管 $a\oplus b = 0$（$a = b$），我们讨论范围为**正整数**，所以我们可以删除 $b$。

2. 对于不同两数 $a$，$b$，我们可以构造出线性基 $p = [a ,a\oplus b]$。
  - $S = \{a ,b ,a\oplus b\}$，$T = \{a ,a\oplus b ,a\oplus a\oplus b\} = \{a ,a\oplus b,b\}$（异或具有抵消的性质，即 $a\oplus a = 0$），所以 $S = T$，且可以证明长度最小为 $2$。

3. 线性基中**不存在**一个子集，使得子集内元素异或值为 $0$（很重要的一条性质！）。
  - 我们按照编号从小到大插入线性基（不同题目有不同要求）。
  
  - 反证法，设有 $p_i$，$p_j$，并且准备新插入 $p$ 的元素为 $p_k$（$i ,j< k \le m$），若 $p_i\oplus p_j \oplus p_k = 0$，即 $p_i\oplus p_j = p_k$，则 $p_k\oplus x = (p_i\oplus p_j)\oplus x$（其中 $x$ 为任意的**其他**子集的异或值），并且 $p_k\oplus p_i = p_j$，$p_k\oplus p_j = p_i$，发现任意 $p_k$ 都可以用 $p_i\oplus p_j$ 替换，或者抵消后（比如上文的 $p_k\oplus p_i = p_j$）等价于一个元素，且这个元素属于 $p$ 的子集，即 $d_k$ 无用，为了让 $m$ 尽可能小我们要杀掉它！
  
  - ~~一句话证明：我们的范围为正整数集。~~

4. $a$ 中的任意一个数都可以由  $p$ 的子集所含值异或得到。
  - 严谨的考虑，我们要分类讨论：
  
  - 如果 $k$ 不能插入线性基，由第 $3$ 点得一定是因为 $k\oplus p_i\oplus p_j\oplus \cdots\oplus p_{num} = 0$，即  $p_i\oplus p_j\oplus \cdots\oplus p_{num} = k$，尽管插入不了但还是能表示。
  
  - 如果 $k$ 能插入线性基，设插入到 $p$ 中第 $pos$ 个位置，则 $k\oplus p_i\oplus p_j\oplus\cdots\oplus p_{num} = p_{pos}$（$i <j<\cdots<num<pos\le m$），即  $k = p_i\oplus p_j\oplus\cdots\oplus p_{num} \oplus p_{pos}$，可以被表示。
  
  - PS：第二条这个可能有关线性基代码，先看一下，如何理解下面会写：
```cpp
inline void insert (int x){
  for (int i = 50 ; i >= 0 ; i --){
    if ((x >> i) & 1) {
      if (!basis[i]) {basis[i] = x ; break;}
      else x ^= basis[i];
    }
  }
}
```
  
  - ~~一句话证明：$S = T$。~~

5. 线性基内部的数个数唯一；且在保持性质 $4.$ 的前提下，数的个数是最少的。

  - 这个蒟蒻懒得写了，直接复制、修改了，顺带一点注释：

> 以下内容除了注释均~~抄袭~~摘自[【学习笔记】浅谈异或线性基](https://www.luogu.com.cn/article/zo12e4s5)，内容无删除，有小改。
> 
> 若 $a$ 里面的所有元素都可以插入到线性基里面，则不管用什么顺序将序列里的数插入线性基，线性基中的元素一定与原序列元素数量相同。
> 
> 若 $a$ 里面的一些元素不能插入到线性基里面，则设 $x$ 不能插入线性基，一定满足形如 $p_i\oplus p_j\oplus p_k = x$ 的式子。尝试将插入顺序改变为 $p_i$，$p_j$，$x$，$p_k$，则 $p_k$ 就不可能插入成功，原因很简单，留给读者自己思考（**注释**：因为 $p_i\oplus p_j\oplus p_k = x$，得 $p_i\oplus p_j\oplus x = p_k$，所以插不进去，原因同 $3.$，这样就有 $0$ 了）。
> 
> 通俗地说，原来是 $x$ 插不进去，改变顺序后，则是 $p_k$ 插不进去。即**对于插不进去的元素，改变插入顺序后，要么还是插不进去**；**要么就是插进去了，同时另一个原来插进去的元素插不进去了**。因此，可以插进去的元素数量一定是固定的。
>
> 若去掉线性基 $p$ 里面的任一个数，都会使得 $a$ 里的数无法通过用线性基里的元素异或得到，没有多余的元素（因为我们在满足 $S = T$ 的时候 $m$ 尽可能小)。所以线性基的元素个数在保持 $3.$ 的前提下，一定是最少的。

6. 对于 $m > 0$ 个元素的线性基，能够组合异或的**非零**异或值个数为  $2^m- 1$。
  - 不可能存在 $p_k = p_i\oplus p_j\oplus \cdots\oplus p_{num}$，不然 $p_k$ 就插不进去。
  
  - 而 $p_k$ 现在就在线性基里面，所以不满足上式。
  
  - 因此线性基中的**任意元素/不属于/其它元素的子集异或和的集合**。
  
  - 所以数量即为非空子集数，即 $2^m - 1$。
  
  - PS：有的题目可能存在异或值为 $0$，而我们线性基不讨论 $0$，所以有的题目答案可能为 $2^m$ 或 $2^m - 1$，要注意。

6. 引申：对于一个 $n$ 个元素，值域为 $V$ 的序列，线性基的大小最多为 $log_2{(V+1)}$。

7. 线性基中元素的子集异或和的集合和原序列的子集异或和的集合相同。

  - 显然，我们由性质 $4.$ 可得 $a$ 中的所有元素都能被线性基表示，那么 $a$ 的子集的异或和也可以表示成由多个线性基的元素异或。

  - 如果有重复的数异或，由于**相同的数异或偶数次抵消**，我们把它们看作异或 $cnt_x\bmod 2$ 次就可以了，其中 $cnt_x$ 为数 $x$ 进行异或出现的次数。

8. 由 $n$ 个数组成的数组的线性基大小为 $m$，则其原数组组合异或能产生 $2^m$ 个异或值，每个元素出现 $2^{n - m}$ 次。

  - 前半句显然，$6.$ 证过。

  - 后半句我们先由 $7.$ 得：线性基中元素的子集异或和的集合和原序列的子集异或和的集合相同。

  - 于是我们把数组放到线性基上思考。

  - 我们相当于再线性基后面补上 $n - m$ 个 $0$，这样每种异或值可以选择异或或者不异或这些 $0$，方案数就是 $2^{n - m}$ 啦。

Part 2. 线性基的构造
---

啰嗦了这么多，以下就分两种方法：

### 贪心法

我们记 $basis_i$ 表示**线性基**中二进制下第 $i$ 位（从右往左数，从 $0$ 开始）的基（数）为多少，也就是说这个数是被插入到了线性基里。

我们要尽可能满足我们理想的线性基，由于要求最高位所在列单独，我们从后往前取二进制位（如 $1011_{(2)}$ 先从后取 $1,0,1,1$ 而不是 $1,1,0,1$），这样我们线性基插入也是从后往前。

也就是说，这里每一行的数值是从小到大的，第一行的数值 $<$ 第二行的数值 $<$ 第三行的数值，以此类推。

并且我们钦定了 $basis_i$ 的最高位位置为 $i - 1$（因为我行从 $1$ 开始计数，如果从 $0$ 开始这里就是 $i$ 了）。

当我们要插入时，当且仅当第 $i$ 位为 $1$，不然不可能做最高位，也不会插入线性基。

当我们发现能插入的时候，分两种情况：

- $basis_i = 0$，直接插啊，注意可能会继续插入，比如 $x$ 经过某种魔法操作后，后面还有多余的 $1$，要 `break`，插好了你就完事了啊。

- $basis_i \neq 0$，没办法，只能往后插。

  - 但是这样我们发现会存在多个最高位为 $1$ 的情况，分别为插入的 $x$ 和已经存在的 $basis_i$。

  - 为了保持线性基的理想，所以我们要让 $x\gets x\oplus basis_i$，这样第 $i$ 位的 $1$ 就抵消了，这样不影响，因为性质 $2.$：

  - > 对于不同两数 $a$，$b$，我们可以构造出线性基 $p = [a ,a\oplus b]$（可以推广到多个数）。

  - 相同两数异或一下为 $0$，这样死也插不进去，不是正好嘛？

这样确保了这种方法的正确性。

于是打出如下代码：

```cpp
inline void insert (int x){
  for (int i = 50 ; i >= 0 ; i --){
    if ((x >> i) & 1) {
      if (!basis[i]) {basis[i] = x ; break;}
      else x ^= basis[i];
    }
  }
}
```

#### 效果展示

当 $a = [1,5,9,4]$，从上往下分别是线性基第 $0$，$1$，$2$，$3$ 位，插入效果：

$$a = [0001_{(2)},0101_{(2)},1001_{(2)},0100_{(2)}]$$

$$\begin{bmatrix}(3&2&1&0)\\0&0&0&0\\0&0&0&0\\0&0&0&0\\0&0&0&0\end{bmatrix}\Rightarrow\begin{bmatrix}(3&2&1&0)\\0&0&0&1\\0&0&0&0\\0&0&0&0\\0&0&0&0\end{bmatrix}\Rightarrow\begin{bmatrix}(3&2&1&0)\\0&0&0&1\\0&0&0&0\\0&1&0&1\\0&0&0&0\end{bmatrix}\Rightarrow\begin{bmatrix}(3&2&1&0)\\0&0&0&1\\0&0&0&0\\0&1&0&1\\1&0&0&1\end{bmatrix}\Rightarrow{\boxed{1}}\begin{bmatrix}(3&2&1&0)\\0&0&0&1\\0&0&0&0\\0&1&0&1\\1&0&0&1\end{bmatrix}\Rightarrow p = [1 ,5 ,9]$$

$\boxed{1}$：此时插入 $4$，$4$ 的第 $2$ 位与 $5$ 的第 $2$ 位重复，因此 $4\oplus 5 = 1$，然后又与 $1$ 的第 $0$ 位重复，$1\oplus 1 = 0$，插不进去了。

注：上面重复默认为含 $1$ 位，下同。

而当我们插入顺序为：

$$a = [1 ,9 ,4 ,5]$$

$$\begin{bmatrix}(3&2&1&0)\\0&0&0&0\\0&0&0&0\\0&0&0&0\\0&0&0&0\end{bmatrix}\Rightarrow\begin{bmatrix}(3&2&1&0)\\0&0&0&1\\0&0&0&0\\0&0&0&0\\0&0&0&0\end{bmatrix}\Rightarrow\begin{bmatrix}(3&2&1&0)\\0&0&0&1\\0&0&0&0\\0&0&0&0\\1&0&0&1\end{bmatrix}\Rightarrow\begin{bmatrix}(3&2&1&0)\\0&0&0&1\\0&0&0&0\\0&1&0&0\\1&0&0&1\end{bmatrix}\Rightarrow{\boxed{2}}\begin{bmatrix}(3&2&1&0)\\0&0&0&1\\0&0&0&0\\0&1&0&1\\1&0&0&1\end{bmatrix}\Rightarrow p = [1 ,4,9]$$

$\boxed{2}$：此时插入 $5$，$5$ 的第 $2$ 位与 $4$ 的第 $2$ 位重复，因此 $4\oplus 5 = 1$，然后又与 $1$ 的第 $0$ 位重复，$1\oplus 1 = 0$，插不进去了。

#### 贪心法的特点

综上，我们可以发现如下特点：

- $basis_i < basis_j$（$i < j$ 且 $basis_i ,basis_j \neq 0$）。

- $basis_i$ 的最高位位置为 $i$（$basis_i \neq 0$）。

- 线性基的构造不唯一，贪心法构造的线性基中的元素与**数据大小无关**，与**插入顺序**有关，越靠前的数越先尝试被插入。

    - 所以有的题目要按照某种方式先排序再贪心求线性基。

- 它不一定是构造出我们理想的线性基。

这个显然，若数 $x$ 插入了 $basis_i$，则 $basis_j$（$i < j$）的第 $i$ 位可能也是 $1$，但它并不是最高位。

比如[董晓老师视频](https://www.bilibili.com/video/BV1jW421d72E/?spm_id_from=333.337.search-card.all.click)中，只要你时间划到 $2:00$，右边就有两个例子：

当 $a = [5 ,6 ,9 ,10]$ 时，$p = [3 ,5 ,9]$，矩阵：$\begin{bmatrix}(3&2&1&0)\\0&0&0&0\\0&0&1&1\\0&1&0&1\\1&0&0&1\end{bmatrix}$。

但是仅仅换一下位置，$a = [6 ,5 ,9 ,10]$ 时，$p = [3 ,6 ,9]$，矩阵：$\begin{bmatrix}(3&2&1&0)\\0&0&0&0\\0&0&1&1\\0&1&1&0\\1&0&0&1\end{bmatrix}$。

容易发现，第二个矩阵中 $0011_{(2)}$ 的最高位所在列有 $6$ 的第一位，并非我们理想的线性基。

分享这个例子还有一个原因，就是它也阐述了线性基的元素与插入顺序有关。

这个时间复杂度为 $\mathcal O(n\log V)$，$V$ 为值域，效率挺高。

#### 例题

[P4570 [BJWC 2011] 元素](https://www.luogu.com.cn/problem/P4570)。

简述题意：有 $n$ 个物品，属性为 $a$，$b$，要求选出一些物品，使得它们的属性 $a$ 构成的集合不存在任何子集使得异或值为 $0$，并且 $b$ 属性之和最大，求这个最大的 $b$ 属性之和。$1\le n\le 10^3$，$1\le a\le 10^{18}$，$1\le b\le 10^4$。

敏锐地注意到到：

> 属性 $a$ 构成的集合不存在任何子集使得异或值为 $0$。

于是我们通过某条性质想到线性基。

发现这就是线性基板子，但是好像又不能直接线性基，这样不能使 $b$ 属性之和最大。

但是我们想到线性基内元素与插入顺序有关，且越靠前的元素越先尝试被插入线性基，于是想到先按照 $b$ 从大到小排序，然后套板子，最后累加和就做完了。

```cpp
const int N = 1e3 + 10;
int n ,basis[70];
int ans;
struct node {int num ,magic;}a[N];

inline bool insert (int x){
//insert 返回 1，表示 x 成功被插入线性基；返回 0，则表示不能插入线性基。
  dn (i ,63 ,0) {
    if ((x >> i) & 1) {
      if (!basis[i]) {
        basis[i] = x;
        return 1; 
      } x ^= basis[i];
    }
  } return 0;
} inline bool cmp (node x ,node y) {return x.magic > y.magic;}//按照属性 b 排序，题目中为魔法值 magic。

signed main (){
  n = read ();
  up (i ,1 ,n) a[i].num = read () ,a[i].magic = read ();
  sort (a + 1 ,a + 1 + n ,cmp);
  up (i ,1 ,n) 
    if (insert (a[i].num)) ans += a[i].magic;
  writeln (ans);
  return 0;
}
```

#### 如何提升？

我们想要构造理想的线性基，就要让它改进！但是我们又无从下手。

当然，这就引出了我们另一种构造方法，它的构造方法是我们真正理想的线性基，这个就叫做：

### 高斯消元法

- 参考文献：@[_Weslie_](luogu://user/511959) 的 [题解：P3812 【模板】线性基](https://www.luogu.com.cn/article/jqjghwj6)。

同样的，我们先把每个数写进矩阵：

$$a = [1,5,9,4]$$

$$\begin{bmatrix}(1&2&3&4)\\0&0&0&1\\0&1&0&1\\1&0&0&1\\0&1&0&0\end{bmatrix}$$

假设我们想要第 $i$ 行的最高位 $1$ 是在从左上到右下的**这条对角线上**，这样从第一行到最后一行的 $1$ 一定从后往前（按照列的编号），也就是说 第一行数值 $>$ 第二行数值 $>$ 第三行数值，以此类推。

也就是说，我们要第一行第一列存在一个 $1$，但是目前没有！

于是我们把第三行和第一行交换一下，这样第一行通过交换做了主元，就可以达到我们的目的啦：

$$\begin{bmatrix}(1&2&3&4)\\1&0&0&1\\0&1&0&1\\0&0&0&1\\0&1&0&0\end{bmatrix}$$

然后我们来到第二行第二列，但是我们发现已经有 $1$ 了，可以光明正大做主元，于是不交换。

可是第四行还有一个 $1$，我们要把它消掉！

于是我们让第四行的元素整体异或上对应列的元素，这样还是可以构造线性基，原因是某个性质，留给读者自己思考。

变成这样：

$$\begin{bmatrix}(1&2&3&4)\\1&0&0&1\\\color{red}{0}&\color{blue}{1}&\color{green}{0}&\color{purple}{1}\\0&0&0&1\\\color{red}{0}&\color{blue}{1}&\color{green}{0}&\color{purple}{0}\end{bmatrix} \Rightarrow\begin{bmatrix}(3&2&1&0)\\1&0&0&1\\\color{red}{0}&\color{blue}{1}&\color{green}{0}&\color{purple}{1}\\0&0&0&1\\\color{red}{0}&\color{blue}{0}&\color{green}{0}&\color{purple}{1}\end{bmatrix}$$

来到第三行第三列，我们发现这是 $0$，并且同列没有 $1$，于是跳过；

来到第四行第四列，我们发现不用换，但是第四列居然都是 $1$？怎么办？只消一个？那不行。那咋办？当然是全部消掉啦！

变成这样：

$$\begin{bmatrix}(3&2&1&0)\\1&0&0&1\\0&1&0&1\\0&0&0&1\\0&0&0&1\end{bmatrix}\Rightarrow \begin{bmatrix}(3&2&1&0)\\1&0&0&0\\0&1&0&0\\0&0&0&0\\0&0&0&1\end{bmatrix}$$

然后我们就得到了线性基 $p = [8 ,4 ,1]$。

```cpp
inline void insert (){
  int k = 1;//k 为需要作主元的行。11
  dn (i ,50 ,0) {//相当于从 1~logV（大概）枚举列。 
    up (j ,k ,n)
      if ((a[j] >> i) & 1) {
        swap (a[j] ,a[k]);//找到替身，交换，第 i 行做主元（狡猾/doge）。
        break;//找到了就别换了省时间。
      }
    if (!((a[k] >> i) & 1)) continue;//留给读者思考。
    up (j ,1 ,n)
      if (j ^ k && ((a[j] >> i) & 1)) a[j] ^= a[k]; // 1.同行不异或 ； 2.该列有 1 才异或，以消除该列的所有 1，不然可能会违反某些线性基的性质，这里留给读者思考；3.注意是 [1,n] 不是 [k+1,n]，可以看上面举得例子。
    ++ k;
    if (k == n + 1) break;//做完了 1~n 行，该干的都干完了，break。
  } 
}
```

总结一下高斯消元法的特点：

- 一定能够构成我们理想的线性基，即每一行的最高位都是 $1$。

- 最后的矩阵是一个‌行最简形矩阵，这点通过过程很好理解。

> 行最简矩形：主元必须为 $1$ 且主元所在列的其他数都为 $0$ 的矩阵。

高斯消元法的时间复杂度为 $\mathcal O(n\log V)$，和贪心法求线性基效率相当。

#### 例题

[P3857 [TJOI2008] 彩灯](https://www.luogu.com.cn/problem/P3857)。

简述题意：有 $n$ 个灯泡和 $m$ 个开关构成，再给定一个 $m$ 行 $n$ 列的数组 $a$，若第 $i$ 行第 $j$ 列的值为 `O`，那么按下开关 $i$ 可以改变灯泡 $j$ 的状态；若为 `X`，则不能。一开始所有灯都是关闭状态。你可以按下若干次所有按钮，求最终展现出来的所有灯的不同状态的数量，全关也算一种状态。

一个开关改变状态，相当于异或操作。

然后我们把按一个开关看作异或这个开关对应的数值，数值由开关的影响灯泡决定，比如开关 $x$：`OXXOO`，那么我们异或上 $1\times 2^0 +0\times 2^1+0\times 2^2+1\times 2^3+0\times 2^4 = 25$。

这样题意就转化成了：已知 $m$ 个数的序列 $a$，求它们组合异或后（或一个数）可以产生多少种不同的异或值。

还记得这条性质嘛

>  6.对于 $m$（$m > 0$） 个元素的线性基，能够组合异或的非 $0$异或值个数为  $2^m- 1$。

因此我们只要求出线性基大小，答案即为 $2^{\text{线性基大小}} - 1 + 1 = 2^{\text{线性基大小}}$，注意还有 $0$ 的情况，因此加 $1$。

这样高斯消元法和贪心法都可以做。

注意取模，还有如果求 $2^x$ 懒得写快速幂或者直接乘，应该写 `1ll << x` 而非 `1 << x`。

---

等等，写了这么点，我们难道只是构造线性基玩嘛？不可能，它一定有它的作用。

Part 3. 线性基用途
---

### 1.【[本题](https://www.luogu.com.cn/problem/P3812)】求线性基组合异或最大值

本题等价于这个问题，至于为什么线性基的组合异或最大值，等于原序列的组合异或最大值（或者更多下述操作），上面已经提到了，可以请读者思考一下。

#### 贪心法

直接搞贪心。

直接上代码：

```cpp
inline int qmax (){
  int res = 0;
  dn (i ,50 ,0) if ((res ^ basis[i]) > res) res ^= basis[i];
  return res;
}
```

为什么这样贪心是正确的？

前置知识：$1\underbrace{(0/1)(0/1)\cdots(0/1)}_{x 个二进制位} > 0\underbrace{111\cdots1}_{x 个 1}$（$x>0$），证明很简单，知道的跳过，不知道的可以转化为十进制思考。

由于前置知识的缘故，对于异或 $basis_i$，我们只关心**最高位**会不会影响答案的大小。

- $basis_i = 0$：值不变。

- $basis_i \neq 0$：则这一行有主元，最高位一定为 $1$（定义）。

  - $res$ 这一位为 $0$，一定异或，原因如前置知识；

  - $res$ 这一位为 $1$，$1\oplus 1 = 0$，不取，后面的异或值最高位权值更小，所以不能异或，不然 $res$ 肯定变小。

这样确保了贪心的正确性。


#### 高斯消元法

直接异或就行了，因为每一个高位所在列最多一个 $1$，我们关注高位可以舍掉更低的位，这样也是正确的。

```cpp
inline int qmax (){
  int res = 0;
  dn (i ,50 ,0) res ^= a[i];//up (i ,0 ,50) 也可以。
  return res;
}
```

![](https://cdn.luogu.com.cn/upload/image_hosting/k188j925.png)

PS：时间复杂度指总体时间复杂度。

### 2.求线性基组合异或最小值

答案为线性基中最小的元素，因为最高位的 $1$ 位置都不同，所以线性基中的数异或任意一个其他数都是比它更大。

但是注意答案可能还为 $0$。如果插入线性基的个数**不足** $n$，那么答案一定存在 $0$，可以请读者自己思考，插不进去的情况是什么（性质也有）。

这个代码是我口胡，如果有问题请评论。

#### 贪心法

```cpp
inline int qmin (){
  int zero = 0;//zero 表示原序列插入线性基的个数（奇怪。
//n：原序列长度。
  for (int i = 0 ; i <= 50 ; i ++) zero += (basis[i] != 0);//basis[i] != 0 表示插入进线性基了。
  if (zero != n) return 0;//basis != n ==> 有的没插进去，答案为 0。
  for (int i = 0 ; i <= 50 ; i ++) if (!basis[i]) return basis[i];//basis[i] < basis[i + 1]（去除 0 的情况）。
} 
```

这个代码也是我口胡，有问题评论！

#### 高斯消元法

```cpp
int zero = 0;
for (int i = 1 ; i <= 50 ; i ++)//高斯消元我的代码编号从 1 开始。
  zero += (a[i] != 0) ;
if (zero != n) return 0;//同上。
for (int i = 50 ; i >= 1 ; i --)
  if (a[i]) return a[i];//对于高斯消元法，basis[i] > basis[i + 1]（去除 0 的情况）。
```
![](https://cdn.luogu.com.cn/upload/image_hosting/uhhf9pqe.png)

### 3.求组合异或第 $k$ 小/大值。

以第 $k$ 小值为例，第 $k$ 大值读者可以自己思考，思路差不多。

#### 贪心法

- 当异或值有 $0$（可以判断）的时候，让 $k\gets k - 1$，然后分类：

- $k = 0$，答案为 $0$；

- $k \ne 0$，我们需要重新构建线性基，让矩阵上每一行的最高位所在列的 $1$ 个数只有一个，也就是说我们想要线性基满足：$basis$ 在第 $i$ 位上只有 $basis_i$ 为 $1$。

- 可以通过异或抵消的方式，对于 $basis_i$ 的第 $j$ 位为 $1$（$1\le j< i$），可以让 $basis_i\gets basis_i\oplus basis_j$，这样我们能够保留最高位上的 $1$，并且消去最高位同列的其余 $1$（可以手动模拟过程助于理解）。

- 但是要按照数值从小到大以方便贪心，而重建后就 $basis$ 却默认**从小到大排序**了，这点很容易想到。

- 这样的好处是啥？这样我们可以对 $k$ 进行二进制分解，如果第 $i$ 位为 $1$，那么答案异或上 $basis_i$。执行结束后的答案即为异或组合的第 $k$ 小值。

- 这样的正确性有保证，因为：

  - 我们选取两个最高位不一样且都为 $1$ 的数异或，最高位分别为 $i$，$j$，并记作 $a_i\oplus a_j$（$j<i$），而所有第 $j$ 位上多余的 $1$ 在重建过程中一定会消去，所以异或之后值更大，第 $i$，$j$ 位上一定出现 $1$。

  - 但是由【前置知识】得，我们只要再选一个含有更高位的 $1$ 且不等于 $a_i$，就一定能异或出一个更大的值。

  - 多个数同理。
 
  - 于是二进制分解可行！

- 注意新建一个数组记录 $basis$，因为有的 $basis$ 为 $0$ 哦！
 
```cpp
inline int q_k(int k){
  //处理 zero。
  if (zero != n) -- k ;
  if (!k) return 0;
//----
// rebuild basis.
  for (int i = 0 ; i <= 50 ; i ++)
    for (int j = 0 ; j < i ; j ++)
      if ((basis[i] >> j) & 1)//basis[i] 除了 i 位置为 1，尝试抵消，抵消不成功也没关系，说明前面也没成功，可以错开，后面也可以抵消。
        basis[i] ^= basis[j];//重构线性基。
  int cnt = 0;
  for (int i = 0 ; i <= 50 ; i ++)
    if (basis[i]) p[cnt ++] = basis[i];//注意！
//------
  if (k > (1ll << cnt) - 1) return -1 ; //无解。等价于 k >= (1ll << cnt)。
  for (int i = 50 ; i >= 0 ; i --)
    if ((k >> i) & 1) res ^= p[i];
  return res;
}
```
| ‌   | ‌原始贪心法线性基‌ | ‌重建后的线性基‌ |
| ------- | ---------- | --------- |
| ‌最高位重 $1$  | 可能重叠       | 完全消除      |
| ‌元素顺序‌ | 有关插入顺序     | 按值从小到大排序   |
| ‌第 $k$ 小计算‌ |  大概率不行（不满足最高位 $1$ 独立）    | 直接二进制分解   |

时间复杂度瓶颈在于重建线性基，为 $\mathcal O(log^2 V)$。

#### 高斯消元法

更简单了！

还是二进制分解，同样，因为高斯消元的结果是我们理想的线性基，最高位的 $1$ 都错开了，直接二进制分解就可以了。

需要注意的是，高斯消元求得的线性基是从大到小排列，应当注意（见代码片段）。

```cpp
inline void insert (){
  k = 1;
  dn (i ,50 ,0) {
    up (j ,k ,n)
      if ((a[j] >> i) & 1) {
        swap (a[j] ,a[k]);
        break;
      }
    if (!((a[k] >> i) & 1)) continue;
    up (j ,1 ,n)
      if (j ^ k && ((a[j] >> i) & 1)) a[j] ^= a[k];
    ++ k;
    if (k == n + 1) break;
  }  
} inline int q_k (int x){
  int res = 0;
  if (k < n + 1) -- x;
  dn (i ,k - 1 ,0) if ((x >> i) & 1) res ^= a[k - i - 1];//因为我们求第 k 小，而 a 是降序排序，我们要去小的，所以是 a[k - i - 1]（试一下就知道了/doge）。
  return res;
} 
```

![](https://cdn.luogu.com.cn/upload/image_hosting/dof2exii.png)


### $3.$ 的反操作：求一个在线性基内出现过的元素 $x$ 在所有异或和内的排名（定义为小于 $x$ 的数加 $1$）。

性质 $8.$ 是怎么说来着？

> 由 $n$ 个数组成的数组的线性基大小为 $m$，则其原数组组合异或能产生 $2^m$ 个异或值，每个元素出现 $2^{n - m}$ 次。

也就是说，我们只需要求出异或和**小于** $x$ 的个数，答案即为 $2^{n-m}\times \text{个数} + 1$。

一种是记录下这 $2^m$ 个元素，排序后直接查（或者二分)，但是 $2^m$ 可以被 `1 2 4 8 16...` 卡成 $V$，不可取。

另一种是对 $x$ 二进制分解，若第 $i$ 位 $basis_i \neq 0$ 则令 $ans\gets ans + 2^{\text{前面 basis 非 0 个数}}$，至于原因读者可以自己思考。

[模板题 | P4869 albus就是要第一个出场](https://www.luogu.com.cn/problem/P4869)。

好了现在说原因：这个选的话后面选与不选都影响最终异或值，我们需要重构线性基才能保证，但是敲了代码又发现其实不用重构线性基（大雾，具体原因可以上网。

那么答案是 $rk\times 2^{n - m} + 1$（记作 $ans$）。

这里我们似乎算上了 $x$，本应该 $ans\gets ans - 2^{n - m}$，但是 $0$ 的情况我们要算上，所以还要特判。

但是这题的特殊性是空集也算 $0$，所以 $ans\gets ans - 2^{n - m} + 2^{n - m} = ans$（如果我理解有误可以评论）。


```cpp
# include <bits/stdc++.h>

# define int long long
# define up(i ,x ,y) for (int i = x ; i <= y ; i ++)
# define dn(i ,x ,y) for (int i = x ; i >= y ; i --)

using namespace std;

inline int read (){int s = 0 ; bool w = 0 ; char c = getchar () ; while (!isdigit (c)) {w |= (c == '-') ,c = getchar () ;} while (isdigit (c)){s = (s << 1) + (s << 3) + (c ^ 48) ; c = getchar ();}return w ? -s : s;}
inline void write (int x){if (x < 0) putchar ('-') ,x = -x; if (x > 9) write (x / 10) ; putchar (x % 10 | 48);}
inline void writesp (int x){write (x) ,putchar (' ');}
inline void writeln (int x){write (x) ,putchar ('\n');}

const int N = 1e5 + 10 ,mod = 10086;
int n ,m ,basis[35] ,a[N] ;

inline void insert (int x){
  dn (i ,31 ,0) {
    if ((x >> i) & 1) {
      if (!basis[i]) {
        basis[i] = x;
        ++ m;
        return ;
      } x ^= basis[i];
    }
  }
} int tot ,b[35];
inline int q_rk (int x){
  int rk = 0 ,mul = 1;
  up (i ,1 ,n - m) mul = ((mul * 2) % mod);
  up (i ,0 ,30) if (basis[i]) b[tot ++] = i;//记录一下 basis[i] != 0 的位置。
  up (i ,0 ,tot - 1) if ((x >> b[i]) & 1) rk += (1ll << i) % mod ,rk %= mod;
//                           注意这里是 b[i]。         这里是 i。
//                           原因只要理解了就知道。
  return (rk * mul % mod + 1) % mod;
} signed main (){
  n = read () ;
  up (i ,1 ,n) a[i] = read () ,insert (a[i]);
  int Q = read ();
  writeln (q_rk (Q));
  return 0;
}
```

---

下面的操作是我看了文章 <https://www.luogu.com.cn/article/zo12e4s5> 才了解到了。

###４.询问存在性：判断数 $x$ 能不能用线性基中的数异或得到

看看能不能插入线性基，如果可以说明不行，因为不存在线性基的子集使得异或值为 $x$；如果能插入，就可以异或得到，因为这样存在线性基的子集使得异或值为 $x$。

具体可见开头的某条性质。

代码类似。

### 线性基合并

这里不是指线性基元素的并集，而是把一个线性基插入到另一个线性基。

设有线性基 $p$ 和 $p'$，只要把 $p'$ 的元素插入 $p$ 就可以了，插不进去就算了。

```cpp
// 令 p' -> q
for (int i = 0 ; i <= 50 ; i ++)//O(log V)
  if (q[i]) insert (q[i]); // insert 内容一样，这里是插入 p 中。 O(log V)
```

或者有时候我们干脆直接新建一个线性基：

```cpp
for (int i = 0 ; i <= 50 ;i ++) res[i] = 0;
for (int i = 0 ; i <= 50 ; i ++) if (p[i]) insert (p[i]);
for (int i = 0 ; i <= 50 ; i ++) if (q[i]) insert (q[i]);
//这里的 insert 是插入到新的线性基 res 中。
```
总时间复杂度：$\mathcal O(log^2 V)$。

### 线性基求交

蒟蒻也不会，只能详见 [oi-wiki](https://oi-wiki.org/math/linear-algebra/basis/#%E7%BA%BF%E6%80%A7%E5%9F%BA%E6%B1%82%E4%BA%A4) 了。

Part 4. 例题
---

线性基结合其他东西才是好（~~毒瘤、弱智~~）题嘛。

## 一、线性基结合博弈论：[P4301 CQOI2013 新 NIM 游戏](https://www.luogu.com.cn/problem/P4301)

简述题意：有 $n$ 堆石子，每堆石子有 $a_i$ 个石头，第一回合双方可以拿走任意堆数的石子，可以不拿，但不能拿光；第二回合以后每人要么拿走一个石子，要么拿走一堆石子，最后取到最后一根火柴的人赢。A 先拿，B 后拿。问 A 想要获胜，第一轮最少需要拿走几个石子？

第二轮以后的规则是 NIM 游戏，NIM 游戏的必败是石子数量的异或和为 $0$。

那么 A 就要把可能异或和为 $0$ 的数的并集拿走，留给 B 一个子集异或和不可能为 $0$ 的集合。

由于 B 不能取光，他取走  $x$ 堆后剩下的堆数子集异或和还是不可能为 $0$。

此时转变到 NIM 游戏，先手必胜。

注意到要取的最少，于是我们按照石子数量降序排序（插入线性基的基综合最大），答案就是 $\text{总数}-\text{线性基的基之和}$。

因为要排序，所以我们使用贪心法。

```cpp
signed main (){
  n = read ();
  int _all = 0;
  up (i ,1 ,n) a[i] = read () ,_all += a[i];
  sort (a + 1 ,a + 1 + n ,greater <int> ());
  up (i ,1 ,n) 
    if (insert (a[i])) ans += a[i];
  writeln (_all - ans);
  return 0;
}
```

## 二、线性基结合图论 [P4151 [WC2011] 最大XOR和路径](https://www.luogu.com.cn/problem/P4151)

参考题解 [this](https://www.luogu.com.cn/article/g8uf2rlb) & [this](https://www.luogu.com.cn/article/1j268t62)。

线性基结合图论。

我们可以把图抽象成若干条主链和环。

我们分类讨论如下情况：

1. 一条链。

![](https://cdn.luogu.com.cn/upload/image_hosting/c4wx1c0i.png)

记 $dis_i$ 为 $1$ 到 $i$ 路径上的这条主链的异或和。

答案为 $dis_n$。

2. 一条主链 $+$ 若干个环

![](https://cdn.luogu.com.cn/upload/image_hosting/v9iqs9w8.png)

- 不经过环为 $dis_n$。

- 经过环（比如环 $1$）：$w_{1,2} \oplus w_{2 ,4} \oplus \text{环 1 异或值} \oplus w_{2 ,4}\oplus w_{2,n} = dis_n\oplus \text{环 1 异或值}$。

- 也就是说，这种情况下，答案为 $dis_n \oplus \text{经过的所有环的异或和}$。

两者取 max 即可，第二种经过哪些环呢？可以构造线性基然后贪心求最大啊。

这种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/wgzx2h3j.png)

- 直接走主链，答案为 $dis_n$；

- 不走主链，那就是绕一半圈走过去，容易得证多绕圈就是上面和这种情况，异或值都抵消了。

针对第二种情况，我们讨论，如果是走半圈，这个异或和貌似不好算。

但是我们还是算上整个异或和，最后异或一下 $dis_n$，好像中间的 $2-3-4$ 就消掉了！这样我们成功实现了走半圈。

这个 $9-10-11$ 的环处理方式和上面一样。

也就是说我们还是可以把它们丢到线性基里面，答案为  $\max\{dis_n \oplus \text{经过的所有环的异或和}（这两者异或要最大） ,dis_n\}$。

3. 多条主链

![](https://cdn.luogu.com.cn/upload/image_hosting/15gp586y.png)

多条主链必将构成环。

设图中的环异或和为 $x$。

~~然后退化了前面的情况。~~

若上面的链的异或和为 $dis_n$（下面的同理）。

- 走上面的链：$dis_n$；

- 因为 $w_{1,2',\cdots,n} = w_{1,2,\cdots,n} \oplus x$，所以下面的链为 $dis_n\oplus x$。

- 所有路径经过异或抵消就是上面两种情况。

多主链同理。

还是可以把环的权值丢尽线性基，做法和上面一样。

容易推广到更多主链，这里读者自己思考吧。

PS：既然多主链都构成环了，那么下文看作一条主路径和环。

4. 环套环

![](https://cdn.luogu.com.cn/upload/image_hosting/dsgpt6ir.png)

老思路，还是把环丢进线性基就可以了。

正确性可以自己图上画画，这里打字卡顿文章字数过多，~~我也没把握~~，就留给读者自己思考。

但是此时环套环会不会漏掉情况呢？

我们把图的一些点抽象一下：

![](https://cdn.luogu.com.cn/upload/image_hosting/m2xf0xj0.png)

通过模拟的方式，我们从 $2$ 开始 dfs，能够得到环 $\{2,4,6\}$ 和 $\{2,4,6,9\}$，下图和上图反一下没啥本质区别。

但是我们却漏了 $\{4,6,9\}$。

但是我们又惊奇地发现，这两个环异或一下又得到了这个环！$w_{2,4}\oplus w_{4,6}\oplus w_{2,6} \oplus w_{2,4}\oplus w_{4,9}\oplus w_{6,9}\oplus w_{2,6} = w_{4,6}\oplus w_{4,9}\oplus w_{6,9}$。

还有一种情况同理，留给读者思考或者看开头的题解链接，图放着了：

![](https://cdn.luogu.com.cn/upload/image_hosting/9mk2c3k6.png)

---

上面这五种情况验证了我们思路的正确性，可以打出代码：

```cpp
inline void dfs (int u ,int Xor){
  vis[u] = 1 ,dis[u] = Xor;
  for (auto i : edge[u]) {
    int v = i.first ,w = i.second;
    if (vis[v]) insert (Xor ^ w ^ dis[v]); // 计算环的异或值。**
    else dfs (v ,Xor ^ w);
/*
         1  ------ 2 --------------- 3 
                    \                 \
                     \                 \
                      \                 \
                       5-----------------4
此时 u = 5 ,v = 2。
XOR {2-3-4-5-2} = XOR{1-2-3-4-5} ^（异或）XOR {2 - 5} ^ XOR {1 - 2}
                =      dis[u]    ^          w        ^ dis[v]               
*/
  }
}
```

## 3.线性基结合数据结构 [P4839 P 哥的桶](https://www.luogu.com.cn/problem/P4839)

这里和板子不一样的是，它求的是“区间”异或最大值，而不是全局异或最大值。

更重要的是，它还有单点修改操作！于是我们想到线段树。

我们于是把线性基放到线段树上，空间大小为 $\mathcal O(4n\log V)$（省略常数 $4$ 是 $\mathcal O(n\log V)$，严格意义上的空间复杂度是这个不是上面那个，空间足够）。

然后逐步分析操作:

-  `1 k x`：将价值为 $x$ 的球插入桶 $k$。我们在线段树上寻找一条从根到 $k$ 的路径，对于路径上的所有节点插入一个 $x$ 就行了。

- `2 l r`：从线段树上找到区间内的节点对应的线性基，开一个新的线性基 $x$ 合并它们，然后贪心就行了。我们也可以在向上合并的过程中采取线性基合并的方法，但是代码多一点，不用！（当然有的题目这种方法不合适，要用线性基合并）

```cpp
inline void insert (int* BASIS ,int x){//将 x 插入到线性基 BASIS。
  dn (i ,63 ,0) {
    if ((x >> i) & 1) {
      if (!BASIS[i]) {
        BASIS[i] = x;
        return ;
      } x ^= BASIS[i];
    }
  }
} inline int qmax (){
  int res = 0;
  dn (i ,63 ,0) res = max (res ,res ^ ans[i]);//贪心取最大值。
  return res;
}
inline void ins (int u ,int l ,int r ,int x ,int v){
  insert (basis[u] ,v);//沿路路径一定包含 x，直接插。
//最坏情况插树高次，每次 O(log V)，一次时间复杂度为 O(log nlog V)。 
  if (l == r) return ;
  int mid = ((l + r) >> 1);
  if (x <= mid) ins (u << 1 ,l ,mid ,x ,v);
  else ins (u << 1 | 1 ,mid + 1 ,r ,x ,v);
} inline void query (int u ,int l ,int r ,int ql ,int qr){
  if (l >= ql && r <= qr) {
    up (i ,0 ,31)//O(log V)
      if (basis[u][i]) insert (ans ,basis[u][i]); //把可能的答案插入新建的线性基。 O(log V)。
//学过线段树的都知道，这样一个区间最坏被分为了 log2 (区间长度) 的子区间。
//最坏情况 l = 1 ,r = n，log n 个子区间，一次时间复杂度为 O(log n log^2 V)。
    return ;
  } int mid = ((l + r) >> 1);
  if (ql <= mid) query (u << 1 ,l ,mid ,ql ,qr);
  if (mid < qr) query (u << 1 | 1 ,mid + 1 ,r ,ql ,qr);
}
```

设操作 $1$ 有 $m1$ 次，操作 $2$ 有 $m2$ 次，总时间复杂度为 $\mathcal O(m1\log n\log V + m2\log n\log^2 V)$，具体原因见代码注释。

Part 5.习题
---

蒟蒻通过多个资料翻到了这个[题单](https://www.luogu.com.cn/training/11251)，推荐一下，但是 [P3265 [JLOI2015]装备购买](https://www.luogu.com.cn/problem/P3265)是实数空间线性基的模板，与异或空间线性基无关。

Part 6.异或空间线性基的扩展
---

## 前缀线性基（时间线线性基）

我们可能想过求全局异或最大值用线性基，有没有想到求区间异或最大值也用线性基呢？

我们上一篇写过可以用线性基 $+$ 线段树解决，但是时间复杂度却是 $\mathcal O(m1\log n\log V + m2\log n\log^2 V)$。

于是我们用了一种时间复杂度为 $\mathcal O(n\log V)$ 的**前缀线性基**（注意：不带修改），但是空间复杂度也为 $\mathcal O(n\log V)$。

---

采用可持久化线段树的思想，我们新建多个版本，第 $i$ 个版本代表插入 $a_{1,2,\cdots,i}$ 的线性基。

我们仍旧记 $basis_{i ,j}$ 为第 $i$ 个版本位置为 $j$ 的基，$pos_{i ,j}$ 为 $basis_{i ,j}$ 这个数在 $a$ 中的位置（下标）（后面有用）。

注意在插入一个元素之前先要**复制** $[1,i-1]$ 的线性基，我们是基于它上进行插入。

这个时候的插入仍然分如下情况，插入数 $x$，其在 $a$ 中位置为 $i$：

PS：以下的有几个本来应该是  $basis_{i - 1,j}/pos_{i-1,j}$，因为版本复制了，又为了和代码一致所以写了 $basis_{i - 1,j}/pos_{i,j}$，请读者注意区分。

- $basis_{i ,j} = 0$，则直接插入，记录 $basis_{i ,j} \gets x$，$pos_{i ,j} \gets i $。

- $basis_{i ,j} \neq 0$，我们要做的肯定时 $x\gets x\oplus basis_{i ,j}$，但是此时我们还要先做一件事：

  - 当 $pos_{i ,j} < i$ 时，我们要交换 $basis_{i ,j}$ 和 $x$，以及 $pos_{i ,j}$ 和 $i$。

  - 也就是说，此时我们要用新的 $x$ 和 $i$ 去插入线性基。

  - 但是注意，这里要给 $i$ 找一个替身，不然 $basis_{\color{red}{i},j}$ 会指向某个我们不想要的东西。


为什么？

- 考虑到我们想要 $[l,r]$ 的区间异或和最大，我们又遵循高位优先原则，在同高位的时候我们一定要让插入顺序尽可能后面，这样更有可能被我们的查询区间所包含，从而增大最大异或和。

- 但这样是否会对低位有影响？我们转念一想，原来线性基能够异或出来的异或和，现在的线性基也能够做到。

- ~~这样感性理解一下吧，严谨的证明我也不知道。~~

然后在我们贪心的时候，需要选择 $pos_{r,i}\ge l$ 的进行贪心，否则不在区间内部。

时间复杂度在插入和询问一次都是 $\mathcal O(\log V)$，所以总复杂度为 $\mathcal O((n + m)\log V)$，$n$ 为插入次数，$m$ 为询问次数。

[模板题：CF1100F Ivan and Burgers](https://www.luogu.com.cn/problem/CF1100F)。

分析：直接套板子。

```cpp
inline void insert (int i ,int x){
  up (j ,0 ,30) basis[i][j] = basis[i - 1][j] ,pos[i][j] = pos[i - 1][j];//复制前一版本。
  int now = i;
  dn (j ,30 ,0) {
    if ((x >> j) & 1) {
      if (!basis[i][j]) {
        basis[i][j] = x;
        pos[i][j] = now;//对应信息不要搞错。
        return ;
      } if (pos[i][j] < now) swap (x ,basis[i][j]) ,swap (now ,pos[i][j]);//交换。
      x ^= basis[i][j];//如果需要交换则交换后再异或；否则直接异或。
    }
  }
} inline int qmax (int l ,int r){
  int res = 0;
  dn (i ,30 ,0)
    if (pos[r][i] >= l) res = max (res ,res ^ basis[r][i]);//只有在 [l,r] 内才贪心取异或最大值。
  return res;
}
```

好像还有一种做法是普通线性基 $+$ 猫树，太巨了蒟蒻不会 stoorz %%%。这边还是推荐好打 $+$ 好理解 $+$ 代码短的前缀线性基。

### [习题 & 前缀线性基的迁移 + 应用题 | P3292 [SCOI2016] 幸运数字](https://www.luogu.com.cn/problem/P3292)。

## 删除线性基

顾名思义，每个数都有一个插入和删除的时间，每次要询问某个时间内最大的异或和（或线性基有关的问题）。

贪心地，我们想要更高位地基能够在后面的“求组合异或最大值”中发挥更多的作用，我们要它的删除时间尽可能晚！

设这个插入的数为 $x$，删除时间为 $delt$。

同理分类讨论，设 $tim_i$ 为第 $i$ 位的基的删除时间：

- $basis_i = 0$：直接插，并记录下数值和删除时间。

- $basis_i\neq 0$：分情况：

  - 如果 $tim_i < delt$，则让 $tim_i\gets delt$（贪心思想），$basis_i\gets x$。

  - 反之啥也别做。

- 最后 $x\gets x\oplus basis_i$，正确性同上“前缀线性基”。

但是貌似有大佬把它们合并了？！如果是本蒟蒻理解有误请尽快评论 QWQ。

对于求最大异或和，我们还是贪心做，只是这次要求删除时间在要求时间之后就试试能不能增大 $res$ 而已。

详见代码。

```cpp
inline void insert (int x ,int delt){
  dn (i ,50 ,0)
    if ((x >> i) & 1) {
      if (tim[i] < delt) swap (tim[i] ,delt) ,swap (basis[i] ,x);
      if (!delt) break;
      x ^= basis[i];
/*
1.basis[i] = 0 。
此时 tim[i] = 0，而 delt > 0，如果不删除我们肯定让 delt 为最晚时间 + 1。
所以执行 tim[i] < delt，两个 swap 恰好达到初始化的效果。
此时 delt = 原tim[i] = 0，break 了，达到了插完完事的目的。
2.basis[i] != 0。
此时这些话还是要执行。
---
综上所述，stoorz %%% 参考 tj 区合并代码的巨佬。
*/
    }
} inline int qmax (int tim){//查询 tim 时刻的最大异或和。
  int res = 0;
  for (int i = 50 ; i >= 0 ;i --)
    if (tim[i] > tim) res = max (res ,res ^ basis[i]);//删除时间比当前时刻晚，说明还存在，可以试试。
  return res;
} 
```

但是这玩意儿是离线的，我要知道每个点的删除时间才能做，你无法知道删除时间，要看后面信息，处理麻烦（猜测）。

### [习题：当可删除线性基碰上了图论 | P3733 [HAOI2017] 八纵八横](https://www.luogu.com.cn/problem/P3733)。

The end
---

到这里，蒟蒻异或空间线性基的内容就结束啦！！！感谢阅读。

总结：异或空间线性基可以用于处理异或问题，通常为多个数异或问题，有的时候会结合其他算法进行~~出题~~，大家要灵活辨认，并且灵活运用。

（假彩蛋）：闲话：这[百度 AI](https://chat.baidu.com/search?extParams=%7B%22enter_type%22%3A%22ai_explore_home%22%7D&isShowHello=1) 写的什么东西啊看不上一点没有达到我想要的效果，还是蒟蒻自己写好了，可能总结很差，不喜勿喷（附上蒟蒻询问[百度 AI](https://chat.baidu.com/search?extParams=%7B%22enter_type%22%3A%22ai_explore_home%22%7D&isShowHello=1) 的高清美图）。

![](https://cdn.luogu.com.cn/upload/image_hosting/aopuzk9i.png)

---

## 作者：MoonCake2011 (赞：2)

[线性基模板题](https://www.luogu.com.cn/problem/P3812)。

# 算法介绍

异或线性基是一种可以快速求 $n$ 个数的关于异或的一些东西。

异或线性基需要记录 $O(\log v)$ 个数，第 $i$ 个数要么不存储数，要么存的数的最高位为 $i$。

## 查询最大值

首先，因为我们从高到低位已经限制了最高位，所以可以证明存有数的最高位是必须选的。

接着，枚举到了第 $i$ 个数，设上面 $i+1$ 位求出的数的答案为 $w$。

如果 $w$ 第 $i$ 位为 $0$，因为第 $i$ 位为那个数的最高位，所以往低位走的数不会对第 $i$ 产生任何影响，所以第 $i$ 位在这里能变成 $1$ 是必须变的，否则不优。

时间复杂度 $O(\log v)$。

## 查询最小值

与查询最大值同理，从大到小枚举，能把第 $i$ 位变成 $0$ 就变。

时间复杂度 $O(\log v)$。

## 插入

我们要插入一个数 $x$，首先我们从上往下枚举，枚举到 $x$ 的最高位 $i$ 了。

如果第 $i$ 位没有任何数，我们直接插入进第 $i$ 位里。

否则，我们将插入的数动一点手脚，让它异或上第 $i$ 位原有的数。

我们会发现，插入这个被我们动过手脚的新数与插入原数完全等价。

粗略证明一下：设插入的原数为 $x$，在第 $i$ 位上原有的数为 $y$。

插入 $x \oplus y$ 与 $y$ 能组成 $x$，它们三个与 $x$ 和 $y$ 组成的数等价。

所以这样做是对的。

如果 $x$ 没有成功插入进线性基里的任何一位，说明线性基里的数的某个子集就是 $x$。

证明：遍历到最后，因为 $2^0$ 项都插不进去，所以 $x$ 插入最后一定会变成 $0$。

所以 $x$ 尝试插入进去的那些位的异或和就是 $x$，证毕。

时间复杂度 $O(\log v)$。

## 合并

合并两个线性基很简单，就是将一个线性基里的数暴力插入到另一个线性基里就行了。

时间复杂度 $O(\log^2 v)$。

# 代码实现

很好实现，对于没有插入任何数的线性基的一位，我们把它赋为 $0$ 就行了，这样他就不会对答案有任何影响了。

添加了一些让人看得比较清楚的注释。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[110];
inline void insert(int x){
	for(int i=60;i>=0;i--)
		if(x&(1ll<<i)) if(!a[i]){//如果 x 的最高位是 i（比 i 更高的位一定被消完了）且第 i 位没插入任何数，那就插入 x
			a[i]=x;
			return;
		}
		else x^=a[i];//否则消掉最高位继续尝试插入 
}
inline int ask_max(){
	int ans=0;
	for(int i=60;i>=0;i--) if(!(ans&(1ll<<i))) ans=ans^a[i];//尝试将第 i 位变为 1 
	return ans;
}
signed main() {
	cin>>n;
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		insert(x);
	}
	cout<<ask_max();
	return 0;
} 
```
# 例题选讲

[P4301](https://www.luogu.com.cn/problem/P4301)。

首先，根据博弈论，我作为先手我要必胜，必须使得火柴堆数的异或和不为 $0$。

所以我们需要取走一些堆，使得对方不管取走哪些堆，异或和不为 $0$，并且使得拿的火柴总数最小。

先不管最小，我们尝试构造一组方案。

这个其实就是让线性基里不能有一个子集的异或和为 $0$，也就是不能有能表示线性基里的数的一个集合。

还记得插入过程中的那个成功插入的证明吗？

我们发现我们要取走的刚好是没有成功插入的那些数。

然后对于最小值，我们可以尝试贪心，从大到小排序插入就行了。

粗略证明就是对于异或和为 $0$ 的 $k$ 个数，我们会选择舍弃最小的那个。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[110];
int t[110];
signed main() {
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1,greater<int>());
	int ans=0;
	for(int k=1;k<=n;k++){
		int x=a[k];
		for(int i=61;i>=0;i--)
			if(x&(1ll<<i)) if(!t[i]){
				t[i]=x;
				break;
			}
			else x^=t[i];
		if(!x) ans+=a[k];
	}
	cout<<ans;
	return 0;
}
```

[P4570](https://www.luogu.com.cn/problem/P4570)。

与上面的题差不多，并且更直白了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[1010],b[1010],id[1010];
int t[110];
inline bool cmp(int x,int y){
	return b[x]>b[y];
}
signed main() {
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i]>>b[i],id[i]=i;
	sort(id+1,id+n+1,cmp);
	int ans=0;
	for(int k=1;k<=n;k++){
		int x=a[id[k]];
		for(int i=61;i>=0;i--)
			if(x&(1ll<<i)) if(!t[i]){
				t[i]=x;
				break;
			}
			else x^=t[i];
		if(x) ans+=b[id[k]];
	}
	cout<<ans;
	return 0;
}
```

[P3292](https://www.luogu.com.cn/problem/P3292)。

就一个倍增加上线性基，还有线性基合并乱维护一下随便就过了。

读者还可以去思考一下线性基如何做去重 $k$ 小或 $k$ 大值。

---


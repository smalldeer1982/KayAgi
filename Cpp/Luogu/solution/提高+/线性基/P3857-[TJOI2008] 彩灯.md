# [TJOI2008] 彩灯

## 题目描述

Peter 女朋友的生日快到了，他亲自设计了一组彩灯，想给女朋友一个惊喜。已知一组彩灯是由一排 $N$ 个独立的灯泡构成的，并且有 $M$ 个开关控制它们。从数学的角度看，这一排彩灯的任何一个彩灯只有亮与不亮两个状态，所以共有 $2^N$ 个样式。由于技术上的问题，Peter 设计的每个开关控制的彩灯没有什么规律，当一个开关被按下的时候，它会把所有它控制的彩灯改变状态（即亮变成不亮，不亮变成亮）。假如告诉你他设计的每个开关所控制的彩灯范围，你能否帮他计算出这些彩灯有多少种样式可以展示给他的女朋友？

注： 开始时所有彩灯都是不亮的状态。

## 说明/提示

可见样例中第一个开关控制了所有的彩灯，而后两个开关分别控制了第一个和第二个彩灯，这样我们可以只用后两个开关控制彩灯，可以变换出来所有的 $2^2$ 个状态。

对于 $30\%$ 的数据，$N$ 和 $M$ 不超过 $15$。

另外有 $40\%$ 的数据，$N$ 和 $M$ 有一个为 $50$。

对于 $100\%$ 的数据，$N$ 和 $M$ 不超过 $50$。

## 样例 #1

### 输入

```
2 3
OO
XO
OX
```

### 输出

```
4```

# 题解

## 作者：kikuss (赞：17)

# Solution
线性基板子题

对于每一个开关,我们可以看成一个0/1串,初始是一个全部为0的串,要求经过这些开关的操作后,出现的不同的0/1串的个数

终点就是不同这两个字,这就决定了我们可以使用线性基来解决这道题

首先了解一下线性基的性质对于两个数字a,b,可以有0,a,b,a^b四种情况
把b换成a^b依然如此

即**线性基内的元素是不重复的**

那么我们就可以把这些0/1串换成10进制后丢到线性基里面去,然后统计线性基内元素个数
在这里稍微讲一下线性基的原理

线性基可以说是一种容器,并且对于每一位都有一个数,这个数一定保证自己所在的这一位为1
我们开一个数组记录线性基,对于每一个数x我们都对它的每一位从高到低进行一遍扫描,与线性基中这一位去匹配
如果线性基中这一位为空,我们就把x加入这一位中,然后就不用做下去了
如果线性基中这一位有值,我们就用x去xor这个数,表示消去这一位,知道出现第一种情况
这种方法就保证了线性基内元素的**不重复性**
除此之外,线性基还有三条最重要的性质
>1.  线性基能相互异或得到原集合的所有相互异或得到的值
>2.  线性基是满足性质1的最小的集合
>3.  线性基没有异或和为0的子集

对于第1,2条性质,不需要太多解释,在这里主要证明一下第三条性质
>证明:假设有$a_1\bigoplus a_2\bigoplus ... \bigoplus a_n=0$,那么$a_1$一定可以由$a_2\bigoplus ... \bigoplus a_n$表示,那么我们把$a1$从线性基中删除依然可以异或除原来可以异或的元素,并且比原来的元素个数还要少,这样原来的线性基就与第二条性质最小集合相违背,所以假设不成立

下面是线性基构造代码
```cpp
void init (lol box) {
	for(int i=50;i>=0;i--) {
		if(!(box>>i&1)) continue; 
		if(!arr[i]) {++cnt,arr[i]=box;break;}
		else box^=arr[i]; 
	} 
}
```
我们知道,线性基内的元素都是由外界元素异或出来的,那么对于线性基内每个元素,我们都有选/不选两种情况,所以$Ans=1<<cnt$

欢迎踩博客[real_l](https://www.cnblogs.com/real-l/p/9639498.html)
# Code
```cpp
#include<bits/stdc++.h>
#define lol long long
using namespace std;
const int N=51,mod=2008;
int cnt;
lol arr[N];
void init (lol box) {
    for(int i=50;i>=0;i--) {
        if(!(box>>i&1)) continue; 
        if(!arr[i]) {++cnt,arr[i]=box;break;}
        else box^=arr[i];
    }
}
int main()
{
    int n,m; scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++) {
        char s[N]; scanf("%s",s);
        int len=strlen(s); lol x=0;
        for(int i=0;i<len;i++) x+=(1ll<<(n-i))*(s[i]=='O');
        init(x);
    }
    printf("%lld\n",(1ll<<cnt)%mod);
    return 0;
}
```

---

## 作者：YellowBean_Elsa (赞：7)

## 我是个~~带着病毒的~~线性基初学者，结合此题浅谈感受

### 首先讲一下线性基是个什么鬼

其实不要看这个名字觉得是什么线性代数里的高级东西，~~它只是类似线性代数中“基底”这个概念的一个集合而已~~

对于一个数组$a$，考察从中选任意几个数可以xor得到的结果

我们可以用大小仅为$log_2n$的数组$p$来**等效**$a$数组

即这两个数组~~关于xor运算生成的线性空间~~选一些数xor所得结果的集合相同

~~我们需要找出$a$生成的线性空间的**基**作为$p$数组，即$p$中元素关于xor线性无关，且$p$的元素个数就是线性空间的维度~~

为了使$p$中元素个数更少，若$p$中有一个元素可以通过其它元素xor得到，就要把它删掉

$p$就是$a$的**线性基**

#### 构造方法

**首先我们发现，$p$只要能xor得到$a$就行了**（因为这样每个$a_i$都可以用$p$中元素表示，$a$数组xor所得数也可以）

那么我们扫描$a$,为使所有$a_i$都可以用$p$表示，如下操作：

- 把$a_i$当成二进制

- **从左到右查看$a_i$的每一位，若第$j$位为1，则查看是否存在$p_j$。若存在，就做$a_i xor = p_j$使$a_i$第$j$位变为0；若不存在，则令$p_j = a_i$再做$a_i xor = p_j$使$a_i$直接变为0，即可以用$p$表示**

- 构造完成

#### 为啥这样构造是对的呢？

首先，每个$a_i$肯定可以用$p$表示

其次，若有$p_j$可以用$p$中其它元素表示，则不可能进行$p_j = a_i$操作（$a_i$此时可以用已存在的$p$中元素表示），所以~~p关于xor线性无关~~$p_j$不可以用$p$中其它元素表示，故$p$的元素个数已达到最小（详见线性代数：基中的元素个数一定）

看代码理解一下：
```cpp
for(int i=1;i<=m;i++){
		for(int j=63;j>=0;j--){
			if(!(a[i]&(1LL<<j)))continue;
			//a[i]的第j位为1 
			if(!p[j]){//还没有负责第j位的p[j] 
				p[j]=a[i];
				break;
			}a[i]^=p[j];//已存在p[j],要为凑出a[i]贡献第j位 
		}
	}
```
### 那这题咋做

每盏灯的效果相当于xor一个数，题意转化为给一些数，能通过从中选几个做xor运算得到多少个不同的数

很简单，看一下线性基中有多少个元素（sz），$2^{sz}$即为所求

因为每种选择方案得到结果不相同（否则会有$p_i$可以用$p$中的其它元素表示），所以每个$p_i$有被选和未被选两种状态，一乘，$2^{sz}$
```cpp
//FeliksYB, an AKer of IMO
//acknowledgement:
//https://blog.csdn.net/a_forever_dream/article/details/83654397 
//这篇博客写的超级赞，我就是看他学的线性基 
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=112;
const int mod=2008;
inline int read(){
	int x=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	return x;
}int n,m,sz;
ll a[N],p[N];//第i盏灯的作用效果相当于xor a[i]
//p中储存a的线性基 
char c;
int main(){
	n=read(),m=read();
	for(int i=1;i<=m;i++){
		for(int j=0;j<n;j++){
			cin>>c;
			//把每盏灯的字符串转化为xor一个数 
			if(c=='O')a[i]|=(1LL<<j);//1LL!!!我见了几次祖宗qwq
		}
	}for(int i=1;i<=m;i++){
		for(int j=63;j>=0;j--){
			if(!(a[i]&(1LL<<j)))continue; 
			if(!p[j]){
				p[j]=a[i];
				sz++;//统计线性基中元素个数 
				break;
			}a[i]^=p[j];
		}
	}printf("%lld\n",(ll)((1LL<<sz)%mod)); 
	return 0;
}
```

---

## 作者：fanfan (赞：6)

这其实是线性基的裸题。

分析一下原题，开关就相当于异或操作（显而易见）。

那么题目难在哪里呢，就是可能会出现重复的现象。出现重复的现象就是相当于由于不同的操作会出现相同的状态。

建模就是存在一些数，这些数异或起来是0（等价于没有操作）。那么需要求一个集合，满足集合中元素相互异或不会出现0.

线性基派上用场了。

首先有一个性质需要知道：a和b两个数可以有0,a,b,a xor b这四个数，而把b换成a xor b还是这四个数，那么这就可以用线性基了。

线性基就是把原有的集合用一个新的集合替代之，新的集合里面数相互异或可以得出原有集合的数相互异或的答案。

利用上面的性质就可以写出如下的代码。

从高位向低位做，如果P[j]没有被赋值，那么就赋值为A[i],否则把A[i]异或上p[j]，这样A[i]的j位就不会再成为1。

这样就可以保证线性基中没有相同位置的1，这样求出来的线性基就是一个互不影响的开关。那么2^r就是答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long A[100],P[100]; 
char s[100];
int sz,r,n;
void solve()
{
    for (int i=1;i<=sz;i++)
    {
        for (int j=62;j>=0;j--)
        {
            if ((A[i]>>j)&1)
            {
                if (!P[j]) {P[j]=A[i]; break;}
                else A[i]^=P[j];
            }
        }
    }
    for (int j=0;j<=62;j++) if (P[j]) r++;
}
int main()
{
    scanf("%d%d",&n,&sz);
    for(int i=1;i<=sz;++i)
    {
        scanf("%s",s);
        for(int j=0;j<n;++j)
        if(s[j]=='O')
        A[i]^=(1ll<<j);
    }
    solve();
    printf("%lld",(1ll<<r)%2008);
}
```

---

## 作者：shuiyuhan (赞：4)

一个线性基的板子，蒟蒻刚学线性基，无意看见了这道题

其实线性基就是一个贪心，每次匹配最高位，如果最高位为1，那就匹配成功，为0,就匹配失败，线性基有~~许多~~一些好玩的性质，

1.线性基的异或集合中每个元素的异或方案唯一，

2.线性基二进制最高位互不相同。

3.如果线性基是满的，它的异或集合为[1,2n−1]。

4.线性基中元素互相异或，异或集合不变。

所以其实这题就是把O和X看做二进制的0和1，改变状态即异或，每一行看做一个数字。

然后因为是求方案数，那么就是求线性基中的数字个数就可以啦

代码:
```c++
#include<bits/stdc++.h>
#define int long long//偷懒的好方法
long long n,x,j,ans,m,a[5000005];//数组好像不用这么大来着
signed main(){
  scanf("%lld%lld",&n,&m);
  for (int i=1;i<=m;i++){
  	char s[10005];
	scanf("%s",s);//S是读入的字符串
	int len=strlen(s);
	int x=0;
	for (int i=0;i<len;i++) if (s[i]=='O')  x+=(1ll<<(n-i));//转二进制为整数
	for (int j=62;j>=0;j--){
	  if ((x>>j)==0) continue;
	  if (a[j]==0){
		a[j]=x;
		break;//如果已经能被其他数字异或求出了，那直接break
	  }
	  x^=a[j];
	}//线性基的匹配
  }
  long long ans=0;
  for (int i=62;i>=0;i--) if (a[i]) ans++;//统计线性基中的数字个数
  printf("%lld",(1ll<<ans)%2008);//b别忘了取模，在右移的时候要把1定为long long
}
```


---

## 作者：RemiliaScar1et (赞：3)

## P3857 [TJOI2008]彩灯

前置知识：[『模板』线性基](https://www.luogu.com.cn/problem/P3812) ，[线性基初步](https://www.cnblogs.com/IzayoiMiku/p/15213150.html)

线性基求张成出的子空间元素个数。

首先细读题目，我们发现对于每一盏被控制的灯，按下一次开关的操作相当于对其状态异或 $1$。我们可以考虑将问题转化成有 $m$ 个非负整数 ，我们选取其中几个异或起来，求它们的方案数。异或是一种二进制不进位加法运算，自然而然的可以想到线性基。

现在假设我们已经求出了线性基向量组 $S=\{\boldsymbol{x_1},\boldsymbol{x_2},\boldsymbol{x_3},\dots \boldsymbol{x_k}\}$，所在的线性空间为 $V$。

本题我们要求：$|T|,T=\{a_1\boldsymbol{x_1}+a_2\boldsymbol{x_2}+\dots a_k\boldsymbol{x_k}|a_i\in[0,1]\land a_i\in N\ \}$。

**先说结论：答案是所有** $a_i$ **取值种数的乘积。即** $2^k$。

我们定义向量的基坐标：若 $\boldsymbol{\alpha}\in V$ ，$\boldsymbol{x_1},\boldsymbol{x_2},\boldsymbol{x_3},\dots \boldsymbol{x_k}$ 是线性空间 $V$ 的一个基且 $\boldsymbol{\alpha}=a_1\boldsymbol{x_1}+a_2\boldsymbol{x_2}+\dots a_k\boldsymbol{x_k},a_i\in R$ ，那么我们就称 $(a_1,a_2,a_3,\dots,a_k)$ 为这个向量在这个基下的坐标。

立刻能猜到，线性基张成的子空间元素数与坐标的一组 $(a_1,a_2,\dots,a_k)$ 的取值一一对应。

对一一对应性进行验证：

假设一个向量 $\boldsymbol{\alpha}\in V$ 在线性基 $\{\boldsymbol{x_1},\boldsymbol{x_2},\boldsymbol{x_3},\dots \boldsymbol{x_k}\}$ 下有两个不同坐标 $(a_1,a_2,\dots,a_k)$ ，$(b_1,b_2,b_3,\dots,b_k)$。

那么
 $$\boldsymbol{\alpha}=a_1\boldsymbol{x_1}+a_2\boldsymbol{x_2}+\dots a_k\boldsymbol{x_k}=b_1\boldsymbol{x_1}+b_2\boldsymbol{x_2}+\dots b_k\boldsymbol{x_k}$$

把两种线性表示相减：

$$(a_1-b_1)\boldsymbol{x_1}+(a_2-b_2)\boldsymbol{x_2}+\dots (a_k-b_k)\boldsymbol{x_k}=0$$

进行分类讨论：

-   $\forall\ i\in [1,k],\ a_i-b_i=0$

    可得 $a_1=b_1,a_2=b_2\dots a_k=b_k$

    与题设“两个不同坐标”矛盾。

-   $\exists\ i\in [1,k],\ a_i-b_i\ne 0$。

    不妨设 $a_i-b_i\ne 0$ ，移项：

    $$(a_1-b_1)\boldsymbol{x_1}+(a_2-b_2)\boldsymbol{x_2}+\dots (a_{i-1}-b_{i-1})\boldsymbol{x_{i-1}}+(a_{i+1}-b_{i+1})\boldsymbol{x_{i+1}} \dots (a_k-b_k)\boldsymbol{x_k}=(a_i-b_i)\boldsymbol{x_i}$$

    与 “$\{\boldsymbol{x_1},\boldsymbol{x_2},\boldsymbol{x_3},\dots \boldsymbol{x_k}\}$ 是线性基”矛盾。

故基坐标与子空间中的向量一一对应。

由计数原理，线性基可以线性表示的向量个数为所有 $a_i$ 取值个数的乘积，本题即为 $2^k$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N=1e3+10;

int n,m;
ll arr[N];

ll fpow(int k,int mod)
{
	ll a=2,res=1;
	while(k)
	{
		if(k&1) res=res*a%mod;
		a=a*a; k>>=1;
	}
	return (res%mod+mod)%mod;
}

int main()
{
	scanf("%d%d",&m,&n);
	for(int i=0;i<n;i++)
	{
		char s[N];
		scanf("%s",s+1);
		for(int j=m;j>=1;j--)
		{
			arr[i]<<=1;
			if(s[j]=='O') arr[i]+=1;
		}
	}
	int k=0;
	for(int i=63;i>=0;i--)
	{
		for(int j=k;j<n;j++)
			if(arr[j]>>i&1)
			{
				swap(arr[j],arr[k]);
				break;
			}
		if(!(arr[k]>>i&1)) continue;
		for(int j=0;j<n;j++)
			if(j!=k&&(arr[j]>>i&1))
				arr[j]^=arr[k];
		k++;
		if(k==n) break;
	}
	printf("%lld",fpow(k,2008));
	return 0;
}
```

---

## 作者：帅到报警 (赞：3)

谁也挡不住我刷线性基的题目！！！ (੭ु´ ᐜ `)੭ु⁾⁾

### 【题意分析】`
首先只是一道线性基的题目，还是一道板子题！！（~~为什么我总是看不出来？？？~~）因为我们要对这 n 盏灯进行开与关的操作，那么这样就可以看做异或的操作。然后就可以将他们转换为 10 进制求线性基。

**可能不需要转换，直接用高斯消元发求线性基更好，但我不会。。。**

[( ﾟДﾟ)σ安利这位dalao的博客，有对于高斯消元法求线性基的介绍](https://blog.sengxian.com/algorithms/linear-basis)

然后因为每盏灯只有开与关两种状态，所以如果这一位的线性基元素不为零，就说明他可以有这两种状态。然后统计有多少盏灯能被改变，用组合求出总数即可。

### 【核心代码】
1、构造线性基
```cpp
void Get_LB(ll x)
{
	for(int i = 62; i >= 0; i--)
	{
		if((x >> i) & 1)//此数第 i 位为 1
		{
			if(!p[i])//线性基这一位不为 0
			{
				p[i] = x;
				return;
			}
			x ^= p[i];
		}
	}
}
```
2、计算答案（其实不需要ll，但懒得改了）
```
for(int i = 62; i >= 0; i--)
	if(p[i])
		ans++;
printf("%lld", (1ll << ans) % 2008);
```

### 【正解】
```
#include <bits/stdc++.h>
#define N 64
#define ll long long
using namespace std;

char s;
ll p[N];
ll n, m, x, ans;

inline ll read()
{
    char ch = getchar();
	ll x = 0, f = 1;
    while(ch > '9' || ch < '0')
	{
		if(ch == '-')
			f = -1;
		ch = getchar();
	}
    while(ch >= '0' && ch <= '9')
	{
		x = x * 10 + ch - '0';
		ch = getchar();
	}
    return x * f;
}

void Get_LB(ll x)
{
	for(int i = 62; i >= 0; i--)
	{
		if((x >> i) & 1)
		{
			if(!p[i])
			{
				p[i] = x;
				return;
			}
			x ^= p[i];
		}
	}
}

int main()
{
	n = read(), m = read();
	for(int i = 1; i <= m; i++)
	{
		x = 0;
		for(int i = 0; i < n; i++)
		{
			cin >> s;
			if(s == 'O')
				x += (1ll << i);
		}
		Get_LB(x);
	}
	for(int i = 62; i >= 0; i--)
		if(p[i])
			ans++;
	printf("%lld", (1ll << ans) % 2008);
	
	return 0;
}
```

---

## 作者：SIXIANG32 (赞：2)

这是一道线性基的裸题。  
闲话少说，切入正题——  

---
其实吧我们可以把每一行看成一个二进制数，```O``` 是 $1$，```X``` 是 $0$。  
每一次开关灯，就是对于这个二进制数异或上一个数。  
那么就变成了在这 $m$ 个数中选择若干个异或下最能组成多少个不同的数。  
异或？线性基无疑。  
我们来想想线性基的性质，每个元素在线性基里异或方案是唯一的。  
那么我们就可以把这 $m$ 个数字全部插入进线性基里，二的线性基里的元素个数次方就是答案。  

```cpp
#include <iostream>
#include <cstring>
using namespace std;
long long qwq[64];
long long cnt;
void Insert(long long val) //线性基{
	for(int p = 63; p >= 0; p--)
		if(val & (1LL << p)) 
			if(!qwq[p]) {
				qwq[p] = val, cnt++;
				break;
			}
			else val ^= qwq[p];
}
signed main() {
	long long n, m;
	cin >> m >> n;
	string str;
	for(int p = 1; p <= n; p++) {
		long long sum = 0;
		cin >> str;
		for(int i = 0; i < str.size(); i++)
			if(str[i] == 'O') 
				sum |= (1LL << i);
		Insert(sum);
	}
	cout << (1LL << cnt) % 2008 << endl;//计算 
}
```

---

## 作者：FutaRimeWoawaSete (赞：2)

来复习线性基辣~         

首先尝试转换一下题意，一个开关开关一次就把原来的状态取反，特别像按位异或 $1$ ，而每个彩灯的状态又可以表示为 $0,1$ ， 所以我们直接把长为 $n$ 的彩灯变成一个在二进制下有 $n$ 位的数，接着我们把每个开关组转化成一个数，现在就是求这 $n$ 个数任意异或会产生多少个不同的数，采用线性基解决。         

再具体而言，我们线性基内不是任意个组合异或起来的值都不一样吗？所以我们的答案就是线性基中元素进行一个排列组合，每个元素选或不选，共 $2 ^ {len}$ 个。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int LOG = 60 , Len = 65;
int n,m;
long long A[Len];
char s[Len];
struct LinearBasis
{
	long long a[LOG + 5];
	int tot;
	LinearBasis(){memset(a , 0 , sizeof a) ; tot = 0;}
	inline void build(long long x[],int len){for(int i = 1 ; i <= len ; i ++) insert(x[i]);}
	inline void insert(long long t)
	{
		for(int i = LOG ; i >= 0 ; i --)
		{
			if(!t) break;
			if(!(t >> i & 1)) continue;
			if(a[i]) t ^= a[i];
			else
			{
				for(int j = 0 ; j < i ; j ++) if(t >> j & 1) t ^= a[j];
				for(int j = i + 1 ; j <= LOG ; j ++) if(a[j] >> i & 1) a[j] ^= t;
				a[i] = t;
				tot ++;
				break;
			}
		}
	}
}Basis;
int main()
{
	scanf("%d %d",&n,&m);
	for(int i = 1 ; i <= m ; i ++)
	{
		scanf("%s",s);
		for(int j = 0 ; j < n ; j ++) if(s[j] == 'O') A[i] += (1LL << j);
	}
	Basis.build(A , m);
	printf("%lld\n",(1LL << Basis.tot) % 2008);
	
	return 0;
}
```

---

## 作者：Jayun (赞：1)

# 链接：

[洛谷](https://www.luogu.com.cn/problem/P3857)

[博客园](https://www.cnblogs.com/GJY-JURUO/p/14443334.html)

# 题目大意：

可以对一个长度 $n$ 的 01 串的 $m$ 组特定位置异或 $1$，你可以选其中任意几个操作，求能异或出多少个数。

# 正文：

我们可以换种想法：每次操作相当于把一个 01 串和原串进行异或，求出能异或多少个数。

然后我们知道，在一个数 $x$ 插入线性基时，可能会因为线性基里的元素早就已经可以异或出 $x$ 而失败。而这不就是判重吗，那么重复第数字已经被去掉了，剩下的数字可以异或出最多的数，假设剩下 $k$ 个数，那么 $2^k$ 就是答案了。

# 代码：

```cpp
int n, m;
char s[N];
ll a[N];

void add (ll val)
{
	for (int i = 50; i + 1; --i)
	{
		if (!(val & (1ll << i))) continue;
		if (a[i])
			val ^= a[i];
		else 
		{
			a[i] = val;
			return ;
		}
	}
}

int main()
{
//	freopen(".in", "r", stdin);
//	freopen(".out", "w", stdout);
	scanf ("%d%d", &n, &m);
	for (int i = 1; i <= m; i++)
	{
		ll val = 0;
		scanf ("%s", s + 1);
		for (int i = 1; i <= n; i++)
			if (s[i] == 'O') val |= 1ll << (i - 1);
		add (val);
	}
	ll ans = 0;
	for (int i = 0; i <= 50; i ++)
		if (a[i]) ans ++;
	printf ("%lld\n", (1ll << ans) % mod);
    return 0;
}

```


---

## 作者：king_xbz (赞：1)

这是一道线性基比较裸的题目，如果会线性基，简单的套模板即可。

**可是，如果不会呢？**

今天，我来给大家简单介绍一下线性基：

线性基
-
- 什么是线性基

线性基是一个数的集合，并且每个序列都拥有至少一个线性基，取线性基中若干个数异或起来可以得到原序列中的任何一个数。

- 线性基的性质

1：原序列里面的任意一个数都可以**由线性基里面的一些数异或得到**

2：线性基里面的任意一些数**异或起来都不能得到0**（即不能构成Nim游戏）

3：线性基里面的数的**个数唯一**

4.假设若干数的线性基是一组数a1,a2,...an，其中**ax的最高位的1在第x位**。
- 由此可以得到几个推论

1：线性基中数量是**满足性质1**情况下的**最小序列**

2：如果**a^b^c=0**,那么**a^b=c，a^c=b**(这就是所谓的线性基交换律？！);

- 如何得到线性基

根据上面的**性质2**，我们已经知道，若a，b属于线性基，且a^b^c=0,那么c一定不属于线性基，我们可以推出c不能加入线性基的条件，即a^b=c.

综上，我们可以写出代码：
```cpp
for(fint i=62;~i;i--)
{
	if(x&(1LL<<i))//枚举最高位1
	if(!bas[i])
	bas[i]=x;
	x^=bas[i];
}
```
这就是线性基的**基础代码**。

**接下来，我们学习一下线性基的应用：**

- **最值的求法**

**1.最大值**

按照贪心的思路，从线性基最高位开始，枚举ans异或该位线性基是否能变得更大，如果可以就更新。**！注意位运算优先级**

代码：
```cpp
int ans=0;
for(fint i=62;~i;i--)
if((ans^bas[i])>ans)
ans=ans^bas[i];
```


**2.最小值**

根据性质2，线性基中最小的值bas[i]异或任何数都会让值增大，那么我们可以分类讨论：

一：原序列有值不能加入线性基————minn=0；

二：原序列均加入线性基————minn=min(minn,bas[i]);

代码
```cpp
inline int xxj(int x)
{
	for(fint i=62;~i;i--)
	{
		if(x&(1LL<<i))
		if(!bas[i])
		bas[i]=x;
		else
		return 0;
		x^=bas[i];
	}
	return 1;
}

int minn=inf;
if(xxj)
for(fint i=62;~i;i--)
minn=min(bas[i],minn);
else
minn=0;
cout<<minn;
```

- **判断一个数是否能被当前线性基中的元素异或得到**

根据性质1；看这个数能否插入线性基，若能插入，则说明该值不能被线性基中值异或得到，否则，说明可以被线性基中值异或得到；

代码
```cpp
inline int insert(int x)
{
	for(fint i=62;~i;i--)
	{
		if(x&(1LL<<i))
		if(!bas[i])
		{
			bas[i]=x;
			return 0;
		}
		x^=bas[i];
	}
	return 1;
}
if(!insert(x))
cout<<"NO";
else
cout<<"YES";
```

**！！**：本文节选自我的博客文章[简单线性代数](https://kingxbz.blog.luogu.org/jian-dan-xian-xing-dai-shuo)欢迎大家来踩。

那么上本题代码，**讲解见代码注释**
```cpp
#include<bits/stdc++.h>
#define fint register int
#define h 501
#define p 2384923
#define int long long//不开long long见祖宗
using namespace std;
char a[p];
int c[h][h];
int s[p];
int bas[p];
signed main()
{
	int n,m;
	cin>>n>>m;
	for(fint i=1;i<=m;i++)
	{
		scanf("%s",a);
		for(fint j=0;j<n;j++)
		{
		if(a[j]=='O')
		c[i][j]=1;
		else
		c[i][j]=0;
		}
	}//二进制转化
	int cnt=0;
	//for(fint i=1;i<=m;i++)
	//for(fint j=0;j<n;j++)
	//cout<<c[i][j]<<" ";
	for(fint i=1;i<=m;i++)
	for(fint j=0;j<n;j++)
	s[i]+=(1LL<<(n-j))*c[i][j];
	for(fint i=1;i<=m;i++)
	{
		for(fint j=50;~j;j--)
		if(s[i]&(1LL<<j))
		{
			if(!bas[j])
			{
				bas[j]=s[i];
				cnt++;、、统计线性基内元素数量
				break;
			}
			s[i]^=bas[j];
		}
	}//线性基模板
	cout<<(1LL<<cnt)%2008;//2的cnt次方即为答案
	return 0;
} 
```
祝大家AC愉快！

---

## 作者：Durancer (赞：0)

#### 前言

线性基裸体，对理解线性基的性质有较大帮助

#### 思路

首先看到开和不开两种状态，那么肯定会想到用二进制来表示，所以我们读到的每一个开关的控制范围，将它转换成一个二进制的串即可

在这这里会用到线性基的一点小性质

> 1、线性基的元素能相互异或得到原集合的元素的所有相互异或得到的值。

>2、线性基中每个元素的异或方案唯一，也就是说，线性基中不同的异或组合异或出的数都是不一样的

由第一条可以得到，只要求出线性基的集合，那么所有的情况都可以用这里面的数表示出来。

很显然的是，将线性基应用到开关灯上，在线性基集合中所存储的每一个二进制数，都有选和不选两种状态，因此，只需要统计在集合中有多少个数即可，答案即为 $2^{cnt}\ \bmod 2008$,因为保证互异，不考虑判重

#### 代码

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define int long long 
using namespace std;
const int N=59;
const int mod=2008;
int light[N];
int p[N];
int n,m;
int ans;
int cont;
void calc(string x,int num)
{
	int len=x.length();
	int cnt=0;
	for(int i=len-1;i>=0;i--)
	{
		if(x[i]=='O')
			light[num]+=(1ll<<cnt);
		cnt++;
	}
	return;	
}
void linear_basis(int x)
{
	for(int i=55;i>=0;i--)
	{
		if(!(x>>i)) continue;
		if(!p[i])
		{
			p[i]=x;
			cont++;
			return;
		} 
		x^=p[i];
	}
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;i++)
	{
		string x;
		cin>>x;
		calc(x,i);
	}
	for(int i=1;i<=m;i++)
		linear_basis(light[i]);
	printf("%lld",(1ll<<cont)%mod);
	return 0; 
}
 
```


---

## 作者：AcerMo (赞：0)

先根据输入的控制的矩阵构造出每一个开关对应的二进制串，然后跑线性基，然后数一下长度为n的串中1的个数，然后快速幂求解2^K
[我的博客](https://blog.csdn.net/ACerAndAKer/article/details/80889099)
代码
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int mod=2008; 
int n,m;
char num[100][100];
long long int a[100]={0},b[100];
int fpow(int a,int b)
{
	int ans=1;
	for (;b;a=(a*a)%mod,b>>=1)
		if (b&1) ans=(ans*a)%mod; 
	return ans;
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=m;i++) scanf("%s",num[i]+1);
	for (int i=1;i<=m;i++)
		for (int k=1;k<=n;k++)
			if (num[i][k]=='O') a[i]=(a[i]<<1)|1;
				else a[i]=a[i]<<1+0;
	for (int i=1;i<=m;i++)
	for (int k=n;~k;k--)
	if (a[i]&(1LL<<k)) 
		if (!b[k]){b[k]=a[i];break;}
			else a[i]^=b[k];
	int ans=0;
	for (int i=n;~i;i--)
		if (b[i]) ans++;
	cout<<fpow(2,ans);
	return 0;
}
```

---


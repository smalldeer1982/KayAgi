# [BJWC2011] 元素

## 题目描述

相传，在远古时期，位于西方大陆的 Magic Land 上，人们已经掌握了用魔法矿石炼制法杖的技术。那时人们就认识到，一个法杖的法力取决于使用的矿石。

一般地，矿石越多则法力越强，但物极必反：有时，人们为了获取更强的法力而使用了很多矿石，却在炼制过程中发现魔法矿石全部消失了，从而无法炼制出法杖，这个现象被称为“魔法抵消” 。特别地，如果在炼制过程中使用超过一块同一种矿石，那么一定会发生“魔法抵消”。后来，随着人们认知水平的提高，这个现象得到了很好的解释。经过了大量的实验后，著名法师 Dmitri 发现：如果给现在发现的每一种矿石进行合理的编号（编号为正整数，称为该矿石的元素序号），那么，一个矿石组合会产生“魔法抵消”当且仅当存在一个非空子集，那些矿石的元素序号按位异或起来为零（如果你不清楚什么是异或，请参见下一页的名词解释 ）。

例如，使用两个同样的矿石必将发生“魔法抵消”，因为这两种矿石的元素序号相同，异或起来为零。并且人们有了测定魔力的有效途径，已经知道了：合成出来的法杖的魔力等于每一种矿石的法力之和。人们已经测定了现今发现的所有矿石的法力值，并且通过实验推算出每一种矿石的元素序号。 

现在，给定你以上的矿石信息，请你来计算一下当时可以炼制出的法杖最多有多大的魔力。

## 说明/提示

### 样例解释

由于有“魔法抵消”这一事实，每一种矿石最多使用一块。 

如果使用全部三种矿石，由于三者的元素序号异或起来：$1\ \mathrm{xor}\ 2\ \mathrm{xor}\ 3 = 0$ ，则会发生魔法抵消，得不到法杖。 

可以发现，最佳方案是选择后两种矿石，法力为 $20+30=50$。 

### 数据范围

对于全部的数据：$1\leq N \leq 1000$，$1\leq \mathrm{Number}_i \le 10^{18}$，$1\leq \mathrm{Magic}_i \le 10^4$。

## 样例 #1

### 输入

```
3 
1 10 
2 20 
3 30```

### 输出

```
50```

# 题解

## 作者：Si_tang (赞：49)

虽然我的代码和其它题解的几乎没什么不同，但貌似其它题解讲的并不是很详细，很多关键的内容都跳过了，所以我在这里尽量详细地将每行代码的具体作用都讲清楚。


题目大意：
有n块石头，每块石头有一个序号和一个魔力值，你可以使用任意数量的石头，但你使用的石头中任意几块异或起来不能为0，求最大总魔力值。
## 思路


### 贪心
首先讲一个异或运算的性质  
若 $a$ ^ $b$ = $c$ ， 则 $b$ ^ $c$ = $a$ , $a$ ^ $c$ = $b$ ;  
虽然这很容易证明，但为了方便大家理解，这里还是证明一下：  
1 ^ 0 = 1 , 0 ^ 0 = 0;  
1 ^ 1 = 0 , 0 ^ 1 = 1;  
由第一排可以看出，无论1还是0，与0异或的结果都是其本身，  
由第二排可以看出，无论1还是0，与1异或的结果都会与其不同（0变1,1变0）  
所以异或运算的最终结果只和用于运算的数的各位上1的数量有关，与各数字运算的顺序无关  
∴$a$ ^ $b$ ^ $c$ = $b$ ^ $c$ ^ $a$ = $c$ ^ $a$ ^ $b$=……  
∴$a$ ^ $b$ = $c$ , $b$ ^ $c$ = $a$ , $a$ ^ $c$ = $b$  
那么，若x无法使用，则有:  

$d[a]$ ^ $d[b]$ ^ … ^ $d[i]$ = $x$ ; 

根据刚才的性质，如果先放入x，后放入$d[i]$，可得:

$x $^ $d[a] $^ … = $d[i]$ ;

显然，原本是x不能使用，改变顺序后，变成了的d[i]不能使用，而且使用的石头总数没有改变，那么，我们直接先使用魔力值最大的石头就行了，  
所以我们可以按魔力值从大到小排序：
```cpp
struct stone
{
    long long num;//序号 
    long long val;//魔力值 
}a[1001];

bool cmp(stone x,stone y)
{
    return x.val>y.val;//按魔力值从大到小排序 
}
```

### 线性基
虽然这道题可以说是线性基的模板题，但考虑到并不是所有人都知道线性基和其性质，所以我尽量用基础的语言讲线性基有关的代码，让完全不懂线性基的人也能看懂。  

详解：既然使用的石头不能有任意几块异或为0，那么，对于每一块石头，我们都要在使用前用已使用的石头对它异或，判断能否得到0。  
要得到0，可行的方法是逐个消掉每一位上的1，看能否全部消掉，同时在消掉这位的1后不能使前面有异或出新的1，  
所以我们在对一块石头的序号异或时，要用一个数组的 $d[i]$ 保存用于消掉第   $i$ 位1的序号，由于不能是前面产生新的1，所以的这个数字必须是 $i$ 位的  

举例：  
要判断 $xi$ (10110)能否使用，先找到最左边的1，即第5位，然后用 $d[5]$ 存储的5位数进行异或消掉1，假如异或完后是101，而 $d[3]$ 还未存储数字，说明不能消掉此位的1，也就是说这块石头可以使用，就将101存储到 $d[3]$ 。 

你可能会问，为什么不存它的序号10110而是存与 $d[5]$ 的运算结果101，这不会影响最终结果吗？  
当然不会，因为假如你同时用一个序号与 $d[5]$ 和 $d[3]$ 异或了，由于 $d[3]$ 已经是与 $d[5]$ 运算过的了，但一个数与同一个数异或两次是不会改变结果的（异或两次1会改变两次，相当于没变，而异或两次0也不会变），所以存储101等价于同时存储了10110和 $d[5]$ ,不仅不会影响结果，而且能刚方便地用于以后消掉第3位的1。  

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int  n,ans;
long long d[64];

struct stone
{
	long long num;//序号 
	long long val;//魔力值 
}a[1001];

bool cmp(stone x,stone y)
{
    return x.val>y.val;//按魔力值从大到小排序 
}

bool LiuZeYu_ak_IoI(long long x)
{
    for(int i=62;i>=0;i--)
    {
        if((x>>i)&1)//从左向右判断每一位的1 
        {
            if(d[i+1]==0)//表示此位的1消不掉 
            {
                d[i+1]=x;
                return true;//能使用 
            }
            else x^=d[i+1];//保存异或结果 
        }
    }
    return false;//每一位的1都被消掉后，由于异或到0，所以不能使用 
} 
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) 
    scanf("%lld" "%d",&a[i].num,&a[i].val);
    sort(a+1,a+n+1,cmp);//贪心 
    
    for(int i=1;i<=n;i++)
    if(LiuZeYu_ak_IoI(a[i].num))
    ans+=a[i].val;
    
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Scarlet_Hypoc (赞：20)

&#160; &#160; &#160; &#160;题目大意：有n个东西，每个东西能选当且仅当它的元素序号不能通过之前选过的东西的元素序号异或得到，在此前提下，求魔力的最大值。

&#160; &#160; &#160; &#160;如果没看过我写的[关于线性基的博客](https://blog.csdn.net/a_forever_dream/article/details/83654397)，请先阅读一下吧，特别是理解其中的第三条性质。

&#160; &#160; &#160; &#160;根据这条性质，我们可以知道，一个序列，能够插入到线性基里面的元素是一定的，那么既然只能插那么多个，显然优先插魔力值大的进去呀！

&#160; &#160; &#160; &#160;可能有人会问，打个比方，原来是可以插5个魔力值为5的进去，但是如果优先从大开始插入，就只能插魔力值为6,1,1,1,1了，那不是显然没那么优了吗？

&#160; &#160; &#160; &#160;这种情况是不可能有的啦。

&#160; &#160; &#160; &#160;假如你要是提出了这种问题，那你一定是没有认真看性质3的证明。

&#160; &#160; &#160; &#160;根据那个~~捞得一比的~~证明，我们可以知道，如果要将一个原来插入不进线性基的元素插入到线性基里面，只需要删去线性基里面的一个特定的元素就好了（这个特定的元素可能有多个，至于这个特定的元素是谁，你只需要细细品味一下我的[博客](https://blog.csdn.net/a_forever_dream/article/details/83654397)就知道了~），所以，要将一个魔力值为6的插入到5个魔力值为5的里面去的话，其实只需要去掉其中一个特定的5就好了。

### 总的来说
&#160; &#160; &#160; &#160;按这种贪心的做法得到的一定是最优的，不可能因为一个元素而导致多个元素不能插入，就算去掉这个元素，也只能插入那多个元素中的一个。

&#160; &#160; &#160; &#160;代码就很简单了：
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define ll long long

struct node{ll x;int y;};
node a[1010];
int n,ans=0;
ll d[70];
bool cmp(node x,node y){return x.y>y.y;}
bool add(ll x)
{
    for(int i=62;i>=0;i--)
    {
        if(x&(1ll<<i))
        {
            if(!d[i])
            {
                d[i]=x;
                return true;
            }
            else x^=d[i];
        }
    }
    return false;
}

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    scanf("%lld %d",&a[i].x,&a[i].y);
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++)
    if(add(a[i].x))ans+=a[i].y;
    printf("%d",ans);
}
```

---

## 作者：宁_缺 (赞：17)

[$\color{black}\text{原题链接}$](https://www.luogu.com.cn/problem/P4570)

大致概括一下题意：有n个元素，每个元素有个序号和一个值，一个元素可以选择当且尽当其序号与已选元素序号的异或和不为0，求你可选择的元素值和的最大值。

我们设第i个数的序号为 a(i)，值为 b(i)，当a(i)⊕a(j)⊕a(k)=0时，我们要扔掉一个。显然，我们扔最小的最优。于是贪心思想就派上用场了。用线性基的性质，如果一个元素塞不进去，说明它会和某些数异或和为0，为了让小一点的塞不进去，我们要将这些元素按 b 从大到小排个序，然后能塞就塞进线性基，不能塞进去扔掉就可以了。
~~感谢您看完了我的极不严谨的证明……~~

注：实现的时候，上面的 a、b 改成了 i 与 c。

题外话：如果您还没有做[P4301](https://www.luogu.com.cn/problem/P4301)的话，建议一做。顺便附上那一题[我的题解](https://www.luogu.com.cn/blog/ytxnqwl/solution-p4301)（~~事实上你会发现这题代码就是用那篇中改动几处而已~~）

本题代码：
```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(3)
#define LL long long
int n;LL d[62],ans;
struct Q{LL i,c;}a[1001];
bool cmp(Q x,Q y){return x.c>y.c;}
int main(){
    scanf("%d",&n);
    for(LL i=1,x;i<=n;++i)
        scanf("%lld%lld",&a[i].i,&a[i].c);
    std::sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;++i){
        for(LL j=61;j>=0;--j)
            if((a[i].i>>j)&1ll)
                if(d[j])a[i].i^=d[j];
                else{d[j]=a[i].i;break;}
        if(a[i].i)ans+=a[i].c;
    }
    return printf("%lld\n",ans)*0;
}
```
_陈词唱穿又如何  ，白骨青灰皆我_

---

## 作者：ccviolett (赞：9)

> 一句话题意：给定 n 个二元组 $(x_i, y_i)$，选出其中若干元素，选出的集合满足任意一个子集 x 异或起来不为 0，问 $\sum y_i$ 的最大值。

不能有任何一个子集异或出来为 0，可以转换为不存在任意一个数可以被集合中其他的数异或出来。

这不就是线性基的定义嘛！一个一个数插入不久好了嘛。

至于要 y 的和尽可能大，在插入的时候可以贪心地在每一个位置上留下大的数，带着小的数往后插入，这样就可以保证在某一个数不能插入时，可以将线性基中存在的等效的数中，y 最小的一个替换掉。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long var;

int n;
var basis[64], val[64];

void insert(var x, var v);

int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; ++i) {
    var x, v;
    scanf("%lld%lld", &x, &v);
    insert(x, v);
  }
  var res = 0;
  for (int i = 63; i >= 0; --i) res += val[i];
  printf("%lld\n", res);
  return 0;
}

void insert(var x, var v) {
  for (int i = 63; i >= 0; --i) {
    if (!((x >> i) & 1)) continue;
    if (!basis[i]) {
      basis[i] = x, val[i] = v;
    }
    if (v > val[i])
      swap(x, basis[i]), swap(v, val[i]);
    x ^= basis[i];
  }
}
```

---

## 作者：YellowBean_Elsa (赞：7)

这题的证明似乎前面几篇题解贪心证明的都不是很好。。。

那我来完整证一个（代码就不贴了）

### 待证命题

将矿石按 Magic 值大到小排序后逐一插入线性基，若能插入，则将其 Magic 加入 ans，否则不加入。这样可以得到最大的 ans

### 证明：

设矿石编号为 ${a_n}$ 

我们任取一组不按此贪心策略来的选择 $\{b_k\}$，则 

$\exists_{a_i}(a_i \notin \{b_k\}) \land (\exists_{(a_j \in \{b_k\})\land(i<j)})\land($ $a_i$ 由 $a_j$ 和 $\{b_k\}$ 中其它一些元素 $\operatorname{xor}$ 得到$)$

即有一个大元素 $a_i$ 由于一个小元素 $a_j$ $(i < j)$的存在无法插入线性基。

那如果我们按照贪心把那个 $a_j$ 换成 $a_i$ 会怎样呢？

首先答案肯定变大了，但是我们还应该证明此时新的 $\{b_k\}$ 符合要求（很多题解并没有说明这一点）

##### 反证

假设现在 $\exists_{\{c_m\} \subset \{b_k\}}\{c_m\}$中元素 $\operatorname{xor}=0$，则：

若 $a_i \notin \{c_m\}$, 则原来的 $\{b_k\}$ 不符合要求，矛盾。

故 $a_i \in \{c_m\}$。

我们把 $a_i$ 用被遗弃的 $a_j$ 和现在 $\{b_k\}$中的其它元素表示出来，

发现这些元素和 $\{c_m\}$ 中的其它元素都是原来的$\{b_k\}$中的，

而他们 $\operatorname{xor}=0$, 故原来的 $\{b_k\}$ 还是不符合要求，矛盾

故新的 $\{b_k\}$ 使答案变大，且符合要求！

这就证明我们的贪心完全正确！

### 证毕




---

## 作者：StudyingFather (赞：6)

看完题目之后，不难想到一种贪心的做法：我们将元素按权值降序排序，按顺序尝试将每个元素插入线性基中，如果能插入就累加答案。

看起来没有那么靠谱？其实我们可以证明这样做是正确的。

原因？假设 $\exists S=\{a_1,a_2,\ldots,a_k\}$，且 $\forall i \in [1,k]$，都满足 $a_i \gt 0$，使得 $\oplus_{i=1}^k a_i=0$，且 $\nexists S'\subsetneq S$，使得 $\oplus_{x \in S'} x=0$，则易我们只需删除 $S$ 中的任意一个元素，就能让 $S$ 中所有元素的异或和不为零。

删除哪个元素呢？既然删除 $S$ 中任意一个元素效果都是等价的，当然是删掉权值最小的结果最优。

就此问题得到解决。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
struct node
{
 unsigned long long num,x;
}a[1005];
long long p[65];
bool cmp(const node&a,const node&b)
{
 return a.x>b.x;
}
bool add(unsigned long long x)
{
 for(int i=64;i>=0;i--)
  if((x>>i)&1)
  {
   if(!p[i])
   {
    p[i]=x;
    return true;
   }
   else x^=p[i];
  }
 return false;
}
int main()
{
 int n,ans=0;
 cin>>n;
 for(int i=1;i<=n;i++)
  cin>>a[i].num>>a[i].x;
 sort(a+1,a+n+1,cmp);
 for(int i=1;i<=n;i++)
  if(add(a[i].num))ans+=a[i].x;
 cout<<ans<<endl;
 return 0;
}
```

---

## 作者：RemiliaScar1et (赞：5)

## P4570 [BJWC2011]元素

求选中数的权值和最大的线性基。

首先读题，我们知道这是让我们选出一个集合，使得集合内的元素之间不能互相异或得到。我们立刻可以想到利用线性基。

线性基有这样的一个性质：

> 子空间 $T$ 的任意两个基底 $B_1,B_2$ 一定等价且维数相同。

这意思是说，线性基元素个数不会变，所以我们的目标肯定是最大化我们放进去构造线性基的各个数的权值。考虑直接按照权值排序，然后动态维护线性基，每次试图插入一个数，若成功则选择这个数并保留插入结果。容易证明这样一定能构造出最大方案。

对于动态维护线性基，我们试图向线性基里面插入一个 $x$。插入的过程实际上是高斯—约旦消元的过程。我们相当于要维护一个类对角矩阵(每一位的 $1$ 最多只在一个向量中出现)，对于 $x$ 从高到低的某一位非 $0$ 二进制位 $i$：

- 若 $a_i\ne 0$

    我们执行 $x=x\oplus a_i$ 将这一位抵消。若 $x$ 被完全消为 $0$ ，证明 $x$ 可以被当前的线性基表示，不能插入。

- 若 $a_i=0$

    意味着我们可以插入 $x$，此时我们需要枚举 $i$ 之前与之后的位置，维护类对角矩阵

code:

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N=1e5+10;

ll arr[N];
bool insert(ll x)//动态维护线性基
{
	for(int i=63;i>=0;i--)
	{
		if(!(x>>i&1)) continue;//x的这一位是 0 ，跳过
		if(arr[i]) x^=arr[i];//ai!=0,消去这一位
		else //发现某一位x是1，但是却没有这一位
		{
			for(int j=0;j<i;j++)
				if(x>>j&1) x^=arr[j];
			for(int j=i+1;j<=63;j++)
				if(arr[j]>>i&1) arr[j]^=x;//将之前/之后的位置全部消去，维护成类对角矩阵
			arr[i]=x;
			return 1;
		}
	}
	return 0;//插入失败，证明 x 在插入前的线性基生成的子空间中
}

int n;
struct node
{
	int mag; ll num=0;
	bool operator<(const node &x) const{
		return mag>x.mag;
	}
} poi[N];

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>poi[i].num>>poi[i].mag;
	sort(poi+1,poi+1+n);
	ll ans=0,cnt=0;
	for(int i=1;i<=n;i++)
	{
		bool flag=insert(poi[i].num);
		if(flag) ans+=poi[i].mag,cnt++;
		if(cnt>=64) break;//绝对不可能再选了
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Edward_Elric (赞：3)

## 思路
------------
$\circ$**贪心+线性基**

**贪心**

把$Magic$大的石头放前面。这样做为什么是对的
，这里有一篇不用拟阵证明的[博客](https://blog.csdn.net/lqybzx/article/details/79416710)，总之能看懂就对了qwq

**线性基**

维护xor和我们想到了线性基，我们知道线性基有一个**性质**

$\bullet$
线性基是**线性无关**的

换言之就是线性基的异或和集合中每个元素的异或方案唯一

那么我们可以推导出下面一个**性质**

$\bullet$线性基的异或和集合中**不存在0**（等价）

那么这道题思路就很清晰了。

能插入线型基的数一定是满足这个性质的，那么如果它能插入，说明线性基中异或和不存在0,也就是满足题意了。我们就加上它的$Magic$

## 代码
------------
用了上三角形构造的方法，和对角线构造不一样，参照了[Menci巨佬的模版](https://oi.men.ci/linear-basis-notes/)
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000+10;
const int maxl=60;
int ans;
struct stone
{
    long long id,val;
}s[maxn];
struct LinearBasics
{
    long long a[maxl+1];
    LinearBasics()
    {
        memset(a,0,sizeof(a));
    }
    bool insert(long long t)
    {
        for(int j=maxl;j>=0;j--)
        {
            if(!(t&(1ll<<j)))continue;
            if(a[j]){t^=a[j];}
            else 
            {
                for(int k=0;k<j;k++)if(t&(1ll<<k))t^=a[k];
                for(int k=j+1;k<=maxl;k++)if(a[k]&(1ll<<j))a[k]^=t;
                a[j]=t;
                return true;
            }
        }
        return false;
    }

}ls;
inline long long read()
{
    long long x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return x*f;
}
bool cmp(const stone&a,const stone&b)
{
    return a.val>b.val;
}
int main()
{
    int n=read();
    for(int i=1;i<=n;i++)
    s[i].id=read(),s[i].val=read();
    sort(s+1,s+1+n,cmp);
    for(int i=1;i<=n;i++)
    if(ls.insert(s[i].id)){
        ans+=s[i].val;
    }
    printf("%d",ans);
    return 0; 
}
```
希望这篇题解能帮同学们正确理解，前面几篇题解可能都会有点模棱两可。

---

## 作者：顾z (赞：3)

# [顾z](https://www.cnblogs.com/-guz/)

题目描述-->[p4570 [BJWC2011]元素](https://www.luogu.org/problemnew/show/P4570)

### 题目大意

给定一些矿石的编号与价值,我们想要得到最大的价值和,并且选定物品的编号异或之和不为0.

## 分析 

线性基就不多bb了,来这里->[p3812 [模板]线性基](https://www.luogu.org/problemnew/show/P3812)

### 贪心

我们从小到大,选择价值大的矿石,满足异或之和不为零的条件,我们就可以加上它的贡献.

因此我们需要用到**sort**对价值从小到大排序.

### 线性基.

这题线性基有什么用?~~说实话开始我也没想到~~

我们很容易想到.

**如果某个矿石能被使用,那它的编号的二进制下某一位一定是已经出现过的矿石编号中不存在的.**(这句话还是仔细研读,应该不难理解,qwq.

这句话简单来讲.``对于某一个编号x,我们检验其与之前已选编号时候异或起来为0.``

(因为线性基进行插入元素的操作时,我们会对这个元素的大小进行削减~~是这么说吧~~.）

因此不难证明用线性基维护是正确的.

因此我们**对已经选入的矿石的编号维护线性基**.(那这题就裸了.

如果满足条件(异或之和不为0),我们就可以选择它,加上它的价值.


------------------代码-------------------

```cpp
#include<bits/stdc++.h>
#define int long long
#define IL inline
#define RI register int
using namespace std;
int n,ans,p[64];
struct cod{int idx,w;}rock[1008];
IL bool ccp(const cod&a,const cod&b){return a.w>b.w;}
IL bool ins(int x)
{
	for(RI i=63;i>=0;i--)
	{
		if(x&(1LL<<i))
		{
			if(p[i])
				x^=p[i];//削减操作 
			else
			{
				p[i]=x;//如果之前选择的编号的当前一位不存在,而我的存在. 
				return true;//即能选择当前编号. 
			}
		}
	}
	return false;
}
main()
{
	ios::sync_with_stdio(false);
	cin>>n;
	for(RI i=1;i<=n;i++)
		cin>>rock[i].idx>>rock[i].w;
	stable_sort(rock+1,rock+n+1,ccp);
	for(RI i=1;i<=n;i++)
		if(ins(rock[i].idx))
			ans+=rock[i].w;
	cout<<ans;
}
```

---

## 作者：CG__HeavenHealer (赞：2)

### 题意

有 $n$ 块矿石，每块矿石有两个属性，分别是序号和魔力值，序号异或起来的值为零的两个（或多个）矿石不能同时选择，魔力值的和是满足代数相加的，求出最大的魔力值。


### 解法

在讲解法之前，先普及一个东西—— **线性基**

~~（讲线性基之前还得普及一个东西~~

线性空间：即关于加法和标量乘法两个运算的封闭集合。

如果对于一个线性空间 $a_1,a_2,\cdots a_n$：

存在 $k \in R$ 使得 $k_1a_1 + k_2a_2 + \cdots +k_na_n = 0$，那么称这些向量 **线性相关**，否则则称 **线性无关**。

而在 OI 中，线性基大多数是关于异或这种运算的，对于一个集合 $A$，线性基能通过其中的元素进行异或运算得到 $A$ 中的所有元素，并做到这个集合的大小最小。

显然，线性基中的元素线性相关。

具体参见 [【模板】线性基](https://www.luogu.com.cn/problem/P3812)

---

回到正题：线性基和本题的解法又有什么关系呢？

既然不能让选中的矿石和其他的矿石通过异或运算得到，也就是这些矿石 **线性无关**。

有了这个，接下来就很好办了：求出这些矿石对应的线性基，如果一个矿石不能放到线性基里面，就说明它会和其他矿石产生冲突，跳过不选即可。

知道了答案怎样可行，接下来就想一下答案怎样做到最优。

为了让答案最大，我们可以按魔力值从小到大排序，然后把所有可以选择的矿石全部选上即可。

### Code:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int unsigned long long
#define ri register int
const int N = 1010;
inline int read() {
    ri x = 0, f = 1;
    char ch = getchar();
    while (!isdigit(ch)) {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while (isdigit(ch)) {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }
    return f * x;
}
int base[70];
struct node {
    int id, mag;
    bool operator<(const node &x) const { return mag > x.mag; }
} a[N];
signed main() {
    int n = read(), ans = 0;
    for (ri i = 1; i <= n; i++) a[i].id = read(), a[i].mag = read();
    sort(a + 1, a + n + 1);
    for (ri i = 1; i <= n; i++) {
        for (int j = 64; ~j; j--)
            if (a[i].id & (1ull << j)) {
                if (base[j])
                    a[i].id ^= base[j];
                else {
                    base[j] = a[i].id;
                    ans += a[i].mag;
                    break;
                }
            }
    }
    printf("%lld", ans);
    return 0;
}
```



---

## 作者：dead_gun (赞：2)

### 前置知识：[P3812 【模板】线性基](https://www.luogu.com.cn/problem/P3812)

-----

给出线性基的两个性质：

> 1. 原序列的数可以由线性基里的数异或得来
> 2. 线性基里的数异或不能得0


我们可以想到如果线性基里的数的个数是固定的,那这道题不就非常水了吗。

怎么证明我们想到的伪·性质呢？

-----

### 伪·性质证明：

>#### 1.序列中的所有数都可以插入线性基中。
>> 此时伪·性质成立

>#### 2.序列中的有些数不能插入线性基中。
>> 设线性基为数组$a$，不能插入的元素为$x$。则线性基中必有$a[x]$ ^ $a[y]$ ^ $a[z] = x$(性质一、二)，若将$x$插入线性基中则$a[x]$ ^ $a[y]$ ^ $x = a[z]$，此时$a[z]$不能插入线性基，此时伪·性质成立

所以伪·性质是正确的，它摇身一变变成真·性质。

----

那么这道题就变成了可以拿$k$个求最大魔法值.

代码：
```cpp
struct node{
	int number, magic;
}a[MANX], b[MAXN];

inline int cmp(node x, node y){return x.magic > y.magic;}

inline void insert(node x)
{
	for (int i = N; i >= 0; i--)
		if (x.number & (1ll << i))
		{
			if (!b[i].number) {b[i] = x; return;}
			x.number ^= b[i].number;
		}
}

inline int find_max(int ans = 0)
{
	for (int i = N; i >= 0; i--) ans += b[i].magic;
	return ans;
}

int n;

signed main()
{
	n = read();
	for (int i = 1; i <= n; i++)
		a[i].number = read(), a[i].magic = read();
	sort(a + 1, a + n + 1, cmp);
	for (int i = 1; i <= n; i++) insert(a[i]);
	cout << find_max();
	return 0;
}
```


---

## 作者：是个汉子 (赞：2)

[题目](https://www.luogu.com.cn/problem/P4570)

别的题解里的高端证明咱也看不懂，咱就只能把这题看作一个线性基好题来做。

### Solution

首先，我学过的线性基有三个性质

1. 原序列里的任意一个数都可以通过线性基中的一些数异或得到
2. 线性基里的任意一些数异或起来都不能得到 $0$ 
3. 线性基里面的数的个数**唯一**，在性质一的前提下，有最少的数  

（**唯一**指的是每个序列的线性基的**元素数量唯一**但线性基不一定唯一）

现在稍微说一下性质三的正确性：

如果序列元素都能插入线性基，那么插入顺序不管是什么，线性基的元素数量就是序列元素数量

如果有些元素是不能插入的。

设其中一个数为 $x$ ，那 $x$ 一定满足 $x=d[a]\oplus d[b]\oplus d[c]$ 这样的形式，此时的插入顺序应为 $d[a],d[b],d[c],x$ 。如果将顺序变为 $d[a],d[b],x,d[c]$ ， $d[c]$ 是插不进去的。
$$
d[a]\oplus d[b]\oplus d[c]=x\Rightarrow d[a]\oplus d[b]\oplus x=d[c]
$$
上面是的式子是异或的性质，因此可以知道线性基元素数量唯一。

回归本题

题目里不要魔法抵消不就是线性基的性质二吗！U•ェ•*U

所以我们可以巧妙的把题转化为：将元素序号插入线性基，让魔力值最大

那为什么我要这么强调性质三呢？~~闲的~~

本题解题关键就是它——既然**元素数量不变**，那就贪心插入魔力值最大的呗╮(╯▽╰)╭

### Code

```c++
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long

using namespace std;
const int N=1010;
struct node{
    ll x;
    int y;
}a[N];
int n,ans;
ll d[70];

inline bool cmp(node x,node y){
    return x.y>y.y;
}

inline bool insert(ll x){
    for(int i=62;i>=0;i--){
        if(x&(1ll<<i)){
            if(!d[i]){
                d[i]=x;
                return true;
            }
            else x^=d[i];
        }
    }
    return false;
}

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%lld%d",&a[i].x,&a[i].y);
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++)
        if(insert(a[i].x)) ans+=a[i].y;
    printf("%d\n",ans);
    return 0;
}
```

今天，你学会线性基的性质了吗 :D

---

## 作者：crashed (赞：1)

# 题目
&emsp;&emsp;[点这里](https://www.luogu.com.cn/problem/P4570)看题目。  
# 分析
&emsp;&emsp;如果称$Magic$为权，$Number$为值，我们需要求的是一个异或意义下，值线性不相关而且权的和最大的问题，也就是权值之和最大的极大线性无关组。  
&emsp;&emsp;看到这个形式的问题，我们就可以考虑向拟阵的方向去靠一靠了。  
&emsp;&emsp;设$S=\{Number_i\}, I=\{x:x\subseteq S, \text{x的任意非空子集是线性无关的}\}$。  
&emsp;&emsp;考虑$<S,I>$是否为一个子集系统：  
&emsp;&emsp;遗传性：假如有$B\in I$，则对于任意一个非空$A\subseteq B$，由于$B$的任意非空子集线性无关，所以$A$的任意非空子集也是线性无关的，因此$A\in I$，证毕。  
&emsp;&emsp;考虑$<S,I>$是否为一个拟阵：  
&emsp;&emsp;交换性：设$A,B\in I,|A|<|B|$，我们要证明，$\exists x\in B-A, A\cup \{x\}\in I$。  
&emsp;&emsp;反证法，即假设对于任意$x\in B-A$，都不满足$A\cup \{x\}\in I$。这说明这样的$x$全在$A$的线性空间中（即都可以用$A$中的异或出来）。因此$B$的元素全在$A$的线性空间中，因此$B$的线性空间包含在$A$的线性空间中。由于$|A|<|B|$，且$A$和$B$各自的任意非空子集都是线性无关的，因此矛盾。因此存在交换律，证毕。  

--------------------------------------------

&emsp;&emsp;~~说了这么多我觉得大家也不太想看。~~  
&emsp;&emsp;简单来说，我们就可以直接按照拟阵的贪心思路，维护一个线性无关组$A$，将矿石按照$Magic$从大到小在保证线性无关的前提下尝试着插入到$A$，如果可以插入就可以计入答案。线性无关组可以用线性基来维护，因此时间是$O(n\log_2n +n\log_2 Number_{\max})$。  
# 代码
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

typedef long long LL;

const int MAXN = 1005, MAXLOG = 70;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

struct element
{
	LL num; int mag;
	element() { num = mag = 0; }
	bool operator < ( const element & b ) const { return mag > b.mag; }
}a[MAXN];

LL base[MAXLOG];
int N;

void insert( LL v )
{
	for( int j = 60 ; ~ j ; j -- )
		if( v >> j & 1 )
		{
			if( ! base[j] ) { base[j] = v; break; }
			v ^= base[j];
		}
}

bool chk( LL v )
{
	for( int j = 60 ; ~ j ; j -- )
		if( v >> j & 1 )
			v ^= base[j];
	return ! v;
}

int main()
{
	read( N );
	for( int i = 1 ; i <= N ; i ++ ) read( a[i].num ), read( a[i].mag );
	std :: sort( a + 1, a + 1 + N );
	int ans = 0;
	for( int i = 1 ; i <= N ; i ++ ) if( ! chk( a[i].num ) ) ans += a[i].mag, insert( a[i].num );
	write( ans ), putchar( '\n' );
	return 0;
}
```

---

## 作者：AlanSP (赞：1)

# 按位贪心

其实和平常的按位贪心不一样，是做在线性基上的，并且要简单。

当一个元素插入的时候，没有成功，那么选上这个元素后，所选的异或和一定为0。

我们不可能枚举每一种选择情况，所以考虑贪心。

众所周知，异或是有这样的性质。
$$
a\wedge b=c \Leftarrow\Rightarrow a\wedge c=b
$$
这也是线性基的原理之一。

同时，线性基的每一位上，都是一个这位往后才有1的二进制数。

结合上面的性质，我们可以转化问题为对于占有某些‘1’位置的数，最大化它们的val和。

所以我们对于每一位的‘1’，自然取能贡献val值最大的。

所以要按val从大到小，依次插入。

剩下的就是线性基常规操作了：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1009;
struct stone{
	int num,val;
	bool operator < (const stone &a)
	{
		return val>a.val;
	}
} p[N];
int n,ans,d[79];

signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) scanf("%lld%lld",&p[i].num,&p[i].val);
	sort(p+1,p+1+n);
	for(int i=1;i<=n;i++)
	{
		for(int j=69;j>=0;j--)
		{
			if((1ll<<j)&p[i].num)
			{
				if(!d[j])
				{
					d[j]=p[i].num;
					ans+=p[i].val;
					break;
				}
				else p[i].num^=d[j];
			}
		}
	}
	printf("%lld",ans);
	return 0;
}
```



---

## 作者：_Imaginary_ (赞：1)

## 题意

给定 $n$ 对数 $a_i,b_i$，求 $\sum\limits_{i\in S} b_i$ 的最大值，其中 $S$ 表示一个其中没有若干个数异或和为 $0$。

## 线性基

线性基有一个性质：得到的新数列异或和都不为零。

因此，我们可以考虑使用线性基。

基本思路：贪心枚举每个数，如果能够加入线性基则加入。

## 解

第一步，将所有数按 $b$ 从大到小排序。

第二步，按顺序将各个数的 $a$ 加入线性基。

第三步，处理后输出。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int mod=1000000007,N=1005;
struct node{
	ll num,magic;
	bool operator <(const node& p) const{return magic>p.magic;}
}a[N];
int n;
ll d[N];
bool solve(ll x)
{
	for(int i=60;i>=0;i--)
	{
	    if((x>>i)&1)
	    {
	        if(d[i]==0)
	        {
	            d[i]=x;
	            return true;
	        }
	        else x^=d[i];
	    }
	}
	return false;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%lld%lld",&a[i].num,&a[i].magic);
	sort(a+1,a+n+1);
	ll ans=0;
	for(int i=1;i<=n;i++) if(solve(a[i].num))ans+=a[i].magic;
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：HH_Halo (赞：0)

如果你不会线性基，请出门右转这道题：[【模板】线性基](https://www.luogu.com.cn/problem/P3812)

 相信你现在已经熟练地掌握了线性基的基本知识。而这道题便是线性基的一个简单应用
## 思路分析
 
 * 根据题意，只有异或和不为 $0$ 的集合才是合法的，而这一点与线性基的一条性质恰好吻合——**线性基里面的任意一些数异或起来都不能得到 0**
 * 所以我们可以很方便地利用线性基来使得我们的集合合法，那么这时候问题就在于，如何选取最优答案？
 * 其实就是一个贪心——根据异或的性质，假设有四个元素 $a$,$b$,$c$,$d$(均为正整数)，满足 $a$^$b$^$c$^$d$=$0$，那么显然去掉其中任意一个都是不为 $0$ 的。如果是你，你会去掉哪一个？相信你已经不屑地说出了答案：显然是最小的啊！(其实就是先选大的)
 * 所以解法就出来了，将所有矿石按魔力值排序，从大到小开始选，用线性基判断一下能不能选，能就选
 
 如果你没明白，相信你看一眼代码以后就会啦
 
 ## $Code$
 ```c++
 #include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define N 1010
#define ll long long
#define R register
using namespace std;
inline ll read(){
	ll x = 0,f = 1;
	char ch = getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
int n;
ll p[65],ans;
struct data{
	ll num;
	int mag;
	inline bool operator <(const data &a)const{
		return mag > a.mag;
	}
}a[N];
bool check(ll x){
	for(R int i = 62;i>=0;i--){
		if(!(x>>i))continue;
		if(!p[i]){
			p[i] = x;
			return 1;//放进线性基里说明可以选
		}
		x ^= p[i];
	}
	return 0;//被线性基里的元素异或成0了说明不能选
}
int main(){
	n = read();
	for(R int i = 1;i <= n;i++){
		a[i].num = read(),a[i].mag = read();
	}
	sort(a+1,a+1+n);
	for(R int i = 1;i <= n;i++)	{
		if(check(a[i].num))ans+=a[i].mag;
	}
	printf("%lld\n",ans);
	return 0;
}
 ```
 ### 补充
 如果你觉得这道题不够做，可以看一眼小蒟蒻汇总的习题：
 [渴求知识的人都点了这个](https://www.cnblogs.com/hhhhalo/p/13858504.html)

---

## 作者：JK_LOVER (赞：0)

### 写在前面的
- 如果有朋友不太明白线性基是什么可见我写的 [线性基](https://www.luogu.com.cn/blog/xzc/xian-xing-ji)
。
- 如果格式有问题，可见 [博客](https://www.luogu.com.cn/blog/xzc/solution-p4570)
。
- 本题解的证明十分幼稚，主要是起抛砖引玉的作用。
## 思路
**上文已说过：线性基是原数组的极大线性无关组。** 而这道题就是计算一个值最大的极大线性无关组。因为每一个原数组对应的极大无关组是等价的。所以我们就必须让线性基上的每一位都尽量大。
## 证明
如果有任意 $4$ 个值由大到小的元素：
$$
val_a > val_b > val_c > val_d
$$
$$
key_a \oplus key_b = key_c \oplus key_d
$$
$$
\exists a, b , c \in U  (sum_1=val_a+val_b+val_c)
$$
$$
\exists a, c , d \in U  (sum_2=val_a+val_c+val_d)
$$
$$
sum_1 > sum_2
$$
那么 $a,b,c \in U$ 时,比 $a,c,d\in U$跟优。
## 分析
因为线性基的每一位最多只有 $1$ 个元素，所以最多也就 $\log n$ 个元素可以被插入。而每一种线性基是等价的，所以我们贪心考虑  $val_i$ 最大的，而每一次插入是 $O(\log n)$ 的，总的复杂度为$O(n\log n)$ 。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int p[100];
bool work(int x)
{
	for(int i=63;i>=0;i--)
	{
		if(x&(1LL<<i))
		{
			if(!p[i])
			{
				p[i]=x;
				return 1;
			}
			x^=p[i];
		}
	}
	return 0;
}
struct node{
	int num,val;
}a[1100];
bool cmp(node x,node y)
{
	return x.val > y.val;
}
int ans=0,n;
signed  main()
{
	cin>>n;
	for(int i = 1;i <= n;i++)
	{
		cin>>a[i].num>>a[i].val;
	}
	sort(a+1,a+1+n,cmp);
	for(int i = 1;i <= n;i++)
	if(work(a[i].num))
	ans+=a[i].val;
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：luqyou (赞：0)

今天学了线性基，来发篇题解巩固一下吖~

不懂线性基的童鞋可以[戳这里](https://www.luogu.com.cn/blog/luqyou/shi-me-shi-xian-xing-ji-post)

# 题意：

给出 $ n $ 个物品，每个物品有两个属性 $ a,b $，现在要在这些物品中取任意个，使得取出的物品中，任意几个物品的属性 $ a $ 的异或和不为 $ 0 $ ，且 $ b  $ 的和最大，求最后取出的物品的属性 $  b  $ 的和。

# 思路：

首先考虑 $ b  $ 的和最大，显然要按照 $ b $  降序排序来进行取最大的，然后就是要满足 $ a $ 的异或和不为 $ 0 $ .

考虑线性基的性质，在线性基中，任意基底的异或和不为 $ 0 $，因此只要能成功添加到线性基中的向量，均满足 $ a $ 的异或和不为 $ 0 $ .

故而将 $ b $ 按降序排序后，将 $ n $  个物品的属性 $ a $  逐个加入线性基中，如果能成功加入到线性基中，就累加 $ b $ 的值。

思路讲完了，接下来上代码：

# 代码：

```cpp
#include<bits/stdc++.h>
#define EPS 1e-9
#define PI acos(-1.0)
#define INF 0x3f3f3f3f
#define LL long long
#define Pair pair<int,int>
const int MOD = 1E9+7;
const int N = 1000+5;
const int dx[] = {0,0,-1,1,-1,-1,1,1};
const int dy[] = {-1,1,0,0,-1,1,-1,1};
using namespace std;
 
struct LinearBasis {
    LL d[60+5];//线性基
    LinearBasis() {
        memset(d,0,sizeof(d));
    }
    bool add(LL x){
        for(int i=60; i>=0; i--)
            if(x&(1LL<<i)) {
                if(d[i])//插入失败，异或
                    x^=d[i];
                else {//插入成功，保存后退出
                    d[i]=x;
                    break;
                }
            }
        return x>0;//x>0插入成功
    }
}lb;
struct Node{
    LL a,b;
    bool operator <(const Node &rhs)const{
        return b>rhs.b;
    }
}node[N];
int main(){
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%lld%lld",&node[i].a,&node[i].b);
    sort(node+1,node+1+n);
 
    LL res=0;
    for(int i=1;i<=n;i++)
        if(lb.add(node[i].a))
            res+=node[i].b;
    printf("%lld\n",res);
    return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：0)

不是很难的一道线性基性质应用题。       

我们知道，构造好的线性基中任意一个集合异或起来值都不为 $0$ 。针对这一点，我们可以模仿最小生成树的那种贪心，我们肯定想先把魔法值更大的先选进去，而很明显我们的线性基也有个插入上限，我们在贪心时看一下这个数能不能插进线性基，插的进去就说明当前存在这个合法的魔法矿石组合，否则就不合法。            

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int Len = 1e3 + 5;
const int LOG = 63;
int n;
struct Node
{
	long long Num,val;
}A[Len];
bool cmp(Node x,Node y){return x.val > y.val;}
struct LinearBasis
{
	long long a[LOG + 5];
	inline long long Get()
	{
		long long res = 0;
		for(int i = 1 ; i <= n ; i ++) if(insert(A[i].Num)) res += A[i].val;
		return res;
	}
	inline bool insert(long long t)
	{
		for(int i = LOG ; i >= 0 ; i --)
		{
			if(!t) break;
			if(!(t >> i & 1)) continue;
			if(a[i]) t ^= a[i];
			else
			{
				for(int j = 0 ; j < t ; j ++) if(t >> j & 1) t ^= a[i];
				for(int j = i + 1 ; j <= LOG ; j ++) if(a[j] >> i & 1) a[j] ^= t;
				a[i] = t;
				return true;
			}
		}
		return false;
	}
}Basis;
int main()
{
	scanf("%d",&n);
	for(int i = 1 ; i <= n ; i ++) scanf("%lld %lld",&A[i].Num , &A[i].val);
	sort(A + 1 , A + 1 + n , cmp);
	printf("%lld\n",Basis.Get());
	return 0;
}
```

---

## 作者：Jayun (赞：0)

# 链接：

[洛谷](https://www.luogu.com.cn/problem/P4570)

[博客园](https://www.cnblogs.com/GJY-JURUO/p/14453999.html)

# 题目大意：

有 $n$ 个物品，第 $i$ 个物品有一个权值和一个序号。你需要在这之中选若干个物品，使得其中任意一个物品序号不会被其他数表示。求出一个权值最大的可行方案。

# 正文：

可以贪心权值从大到小选择当前物品是否可行。

如何证明这个的正确性呢？假设有三个物品 $i,j,k$，其中 $i,j$ 在线性基中，而 $k$ 不在（即 $val_k<val_i,val_j$），且 $id_i\text{xor}id_j=id_k$。可以很容易发现如果让 $k$ 插入线性基放弃 $i$ 或 $j$ 的话肯定不是最优的。

然后就是利用线性基能够判断当前数能否被线性基里的数异或表示的性质解题了。假设我们插入 $k$ 失败，它会因为在线性基里不断异或里面的数而最后变成 $0$，那统计答案时只需要看最后的 $id_k$ 是否为零就好了。

# 代码：

```cpp
struct node
{
	ll val, id;
	bool operator < (const node &x) const
	{
		return val > x.val;
	}
}a[N];

int n; 
ll ans;
ll d[65];
void Insert(ll &val)
{
	for(int i = 64; i >= 0; --i)
		if(val & (1ll << i))
		{
			if (d[i]) val ^= d[i];
			else {d[i] = val; return;} 
		}
}

int main()
{
//	freopen(".in", "r", stdin);
//	freopen(".out", "w", stdout);
	scanf ("%d", &n);
	for (int i = 1; i <= n; i++)
		scanf ("%lld%lld", &a[i].id, &a[i].val);
	sort (a + 1, a + 1 + n);
	
	for (int i = 1; i <= n; i++)
	{
		Insert(a[i].id);
		if (a[i].id) ans += a[i].val;
	}
	printf ("%lld\n", ans);
    return 0;
}

```

---


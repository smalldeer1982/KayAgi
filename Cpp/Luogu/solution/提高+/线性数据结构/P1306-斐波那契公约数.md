# 斐波那契公约数

## 题目描述

对于 Fibonacci 数列：

$$ f_i = \begin{cases}
  [i = 1]               & i \leq 1 \\
  f_{i - 1} + f_{i - 2} & i \gt 1
\end{cases}$$

请求出 $f_n$ 与 $f_m$ 的最大公约数，即 $\gcd(f_n, f_m)$。

## 说明/提示

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 10^9$。

## 样例 #1

### 输入

```
4 7```

### 输出

```
1```

# 题解

## 作者：浅色调 (赞：264)


　　本题其实并不难，开始被题意吓到了，结果后面写出了式子都没看出来（手动滑稽～）。
  	发现自己推结论的方法不太一样，所以发发题解。

### $\quad$方法：结论+矩阵加速
### $\quad$结论：$$gcd(F[n],F[m])=F[gcd(n,m)]$$

### $\quad$证明：

　　我们设$n<m$，$F[n]=a$和$F[n+1]=b$。

　　则$F[n+2]=a+b,F[n+3]=a+2b,…F[m]=F[m-n-1]a+F[m-n]b$

　　$\because \quad$ $F[n]=a,F[n+1]=b,F[m]=F[m-n-1]a+F[m-n]b$

　　$\therefore \quad$ $F[m]=F[m-n-1]*F[n]+F[m-n]*F[n+1]$

　　又$\because \quad$ $gcd(F[n],F[m])=gcd(F[n],F[m-n-1]*F[n]+F[m-n]*F[n+1])$

　　而$F[n]|F[m-n-1]*F[n]$

　　$\therefore \quad$ $gcd(F[n],F[m])=gcd(F[n],F[m-n]*F[n+1])$

　　引理：$gcd(F[n],F[n+1])=1$

　　　证：由欧几里德定理知

　　　　　$gcd(F[n],F[n+1])=gcd(F[n],F[n+1]-F[n])=gcd(F[n],F[n-1])$


　　　　　　　　　　　　$=gcd(F[n-2],F[n-1])$

　　　　　　　　　　　　$……$

　　　　　　　　　　　　$=gcd(F[1],F[2])=1$

　　　　  $\therefore \quad$ $gcd(F[n],F[n+1])=1$

　　由引理知：

　　$F[n],F[n+1]$互质

　　而$gcd(F[n],F[m])=gcd(F[n],F[m-n]*F[n+1])$

　　$\therefore \quad$ $gcd(F[n],F[m])=gcd(F[n],F[m-n])$

　　即$gcd(F[n],F[m])=gcd(F[n],F[m\;mod\;n])$

　　继续递归，将$m1=m\;mod\;n$，则$gcd(F[n],F[m])=gcd(F[n\;mod\;m1],F[m1])$

　　$…$

　　不难发现，整个递归过程其实就是在求解$gcd(n,m)$

　　最后递归到出现$F[0]$时，此时的$F[n]$就是所求gcd。

　　$$\therefore \quad gcd(F[n],F[m])=F[gcd(n,m)]$$　

　　

　　于是本题就转为求$gcd(n,m)$，然后求斐波拉契数列的$F[gcd(n,m)]$项后8位（即对100000000取模）。

　　至于矩阵的构造：

　　初始矩阵 $\begin{bmatrix} F[2]=1 & F[1]=1\end{bmatrix} $
  
   以及中间矩阵 
   $\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}$
   
   注意矩阵数组开long long！！
   
#### $\quad$欢迎来踩博客（转载请注明出处）：[five20](http://www.cnblogs.com/five20/p/8708445.html)

### 代码：
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define il inline
#define ll long long
#define mem(p) memset(&p,0,sizeof(p))
using namespace std;
const ll mod=1e8;
ll n,m;
struct mat{ll a[3][3],r,c;};
il mat mul(mat x,mat y)
{
	mat p;
	mem(p);
	for(int i=0;i<x.r;i++)
		for(int j=0;j<y.c;j++)
			for(int k=0;k<x.c;k++)
	p.a[i][j]=(p.a[i][j]+x.a[i][k]*y.a[k][j])%mod;
	p.r=x.r,p.c=y.c;
	return p;
}
il void fast(ll k)
{
	mat p,ans;
	mem(p),mem(ans);
	p.r=p.c=2;
	p.a[0][0]=p.a[0][1]=p.a[1][0]=1;
	ans.r=1,ans.c=2;
	ans.a[0][0]=ans.a[0][1]=1;
	while(k)
	{
		if(k&1)ans=mul(ans,p);
		p=mul(p,p);
		k>>=1;
	}
	cout<<ans.a[0][0];
}
il ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}
int main()
{
	ios::sync_with_stdio(0);
	cin>>n>>m;
	n=gcd(n,m);
	if(n<=2)cout<<1;
	else fast(n-2);
	return 0;
}
```


---

## 作者：yummy (赞：68)

> 吐槽一下

作为一个初一同学，闲着的时候用自己的方法AC，好开心。

在这片题解里，没有矩阵乘法，没有玄学优化，只有多项式。

> 斐波那契O(logn)求法

首先我们看一个神奇的方程：$a^2=a+1$

以一个初一同学的角度，在满足上式的前提下化简$a^8$

$a^8=a^7+a^6=2a^6+a^5=3a^5+2a^4=...=21a+13$

我们发现，a的系数恰好是斐波那契数列第8项,常数恰好是第7项！（这不是显然的吗）

同时：
$a^8=(a^4)^2=(3a+2)^2=9a^2+12a+4=21a+13$

由上面的例子我们知道了$a^8$和$a^4$的关系，也就是$f(8)$和$f(4)$的关系。

更一般地，我们可以由$a^n$的化简结果推出$a^{2n}$的结果和$a^{n+1}$的。
```cpp
struct duo //多项式
{
    ll a,b;
};
duo powa(int ci)//a^ci的降幂形式
{
    duo res,tmp;
    if(ci==1)
    {
        res.a=1;
        res.b=0;
        return res;
    }
    tmp=powa(ci>>1);
    res.a=(tmp.a*tmp.a+(tmp.b*tmp.a<<1))%Mod;
    res.b=(tmp.a*tmp.a+tmp.b*tmp.b)%Mod;
    if(ci&1)//如果是个奇数则还要再乘a
    {
        swap(res.a,res.b);
        res.a+=res.b;
    }
    return res;
}
```
> 接下来就是他们给出的$gcd(f_x,f_y)=f_{gcd(x,y)}$的证明

我们不妨假设$x>y,a^x=pa+q,a^y=ma+n,a^{x-y}=Ma+N$

$a^x=a^ya^{x-y}=(ma+n)(Ma+N)=mMa^2+(nM+mN)a+Nn$

$=(nM+Nm+mM)a+Nn+mM$

$gcd(p,m)=gcd(nM+Nm+mM,m)=gcd(nM,m)=gcd(f_{y-1}f_{x-y},f_y)=gcd(f_y,f_{x-y})$

这就可以得到结论。

---

## 作者：maomao9173 (赞：41)

### 写这道题非常有助于提高姿势水平。

#### 本题解面向初学者，比较学术比较简洁的内容请去翻百度或者其他的题解。

### Stay Hungry,Stay Foolish.	--Steve Jobs

如果初次接触此问题，你需要以下知识背景铺垫：
	
   1. 求解最大公约数（GCD）的方法
   	
    - 详见[【P1029】最大公约数与最小公倍数问题](https://www.luogu.org/problemnew/show/P1029)  
    
   2. 矩阵快速幂与线性递推的优化
   
   	- 建议提前了解：[【P3390】【模板】矩阵快速幂](https://www.luogu.org/problemnew/show/P3390)
   
  	解决上面那个以后，建议先练习：
   
    - 线性递推练手：[【P1939】【模板】矩阵加速（数列）](https://www.luogu.org/problemnew/show/P1939)
    

## 下面进入正题：

解决这个题目，我们需要解决两个子问题:

	1. 求解Fibbonaci第n项和第m项的GCD

	2. 对于1e9的数据范围，这里我们要考虑比线性更快速的矩阵加速递推。

首先看第一个子问题。由于数据范围非常大，我们考虑这个求解可能具有规律性。

~~如果你对高精度有着非常的热爱，硬解也不是不行~~

但规律是什么呢？怎么想出来？这里本蒟蒻提供一种并不严谨，但很好用，也很常用的方法。

#### ~~简而言之就是打表找规律，暴力出奇迹~~

首先你需要优雅地打一个（n）40x（m）40的表。

先使用较小的数据范围，暴力硬算fibbonaci数列前40项，然后暴力硬求求第n项和第m项的GCD，做成一个便于观察的形式。

	递推公式：
    	f[i]=f[i-1]+f[i-2];
    gcd求法：
		if(x%y==0)return y;
		return gcd(y,x%y);

然后你会得到下图所示的结果。

![](https://cdn.luogu.com.cn/upload/pic/32796.png )

不出意料的，我们发现这个表里1特别多。毕竟凭直觉大多数fibbonaci数也不会有太多公因数嘛~

但是仔细观察我们会发现其分布的规律。只有对一些特定的数，它才呈现出非1的值。

举个例子，控制n为12，我们会发现比12小的有3，4，6，8，9这些组合是非1的，大小参差不齐。而12，24，36这些则同样非1，却大小一致。

再把我们的到的数仔细和fibbonaci数列里面的对比，你会发现一个神奇的东西——
	
    gcd(fib[i],fib[j])=fib[gcd(i,j)];
    
反正要是我，这种式子怼死我我也想不到。但是看到右边的表，大多数人应该都会一眼看出来这个规律吧~这就是打表的玄妙之处~

这样，我们就把计算量缩小了一个量级。第一个子问题就结束了。

打表虽然不一定严谨，但是一定好用，尤其是在考场上的时候。右边的代码几分钟就可以写出来，但是这个引理可真不一定是几分钟就能想到的。

其具体证明 @浅色调 的题解中讲的非常好，我不再进行赘述。

紧接着我就发现，数据最后一个点非常神奇的T了，最诡异的是其他数据点都是几毫秒。考虑了一下之后我就明白了：其他几个点应该是随机构造的数据，公因数不会非常大，但最后一个点铁定要卡1e9的情况，不然这个题目随便水一水就过就没什么意义了。

### 那么我们就进入了第二个子问题：用比O（n）更快的速度求fibbonaci。

如果没了解过矩阵的知识，可能会觉得这个完全不可能，觉得线性已经是速度上限了。然而矩阵这种神奇的东西给我们提供了一种新的思路。以下内容，本蒟蒻假设读者已经对矩阵及其构造有了一定的了解。

#### 首先考虑我们线性递推的原理：从一个递推状态，去往下一个递推状态。

#### 同样的，对于简单的线性递推，我们也可以从当前的状态矩阵，构造一个转移矩阵，实现向目标矩阵的转移。

#### 为什么呐？因为矩阵的本质其实就是线性方程组啊QWQ

类比于递推式，我们构造出来下面两个矩阵。

![](https://cdn.luogu.com.cn/upload/pic/32800.png )

	考虑前后转移，把FIB[n]变成FIB[n-1]+FIB[n-2]
    
    然后就可以构造出来转移矩阵了。
![](https://cdn.luogu.com.cn/upload/pic/32802.png )

接下来直接套用矩阵快速幂模板，这个问题就解决啦QWQ

Code：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define mod 100000000
#define lint long long
using namespace std;
struct Martrix{
	lint mp[3][3];
}; 
lint n,m;
Martrix init,unit,mul;

Martrix __mul(Martrix rec_1,Martrix rec_2){
	Martrix ans;
	for(int i=1;i<=2;i++){
		for(int j=1;j<=2;j++){
			ans.mp[i][j]=0;
		}
	}
	for(int i=1;i<=2;i++){
		for(int j=1;j<=2;j++){
			for(int k=1;k<=2;k++){
				ans.mp[i][j]+=rec_1.mp[i][k]*rec_2.mp[k][j];
				ans.mp[i][j]%=mod;
			}
		}
	} 
	return ans;
}
Martrix __pow(Martrix rec,lint exp){
	Martrix ans=unit;
	while(exp!=0){
		if(exp&1){
			exp-=1;
			ans=__mul(ans,rec);
		}
		exp>>=1;
		rec=__mul(rec,rec);
	} 
	return ans;
} 
lint gcd(lint x,lint y){
	if(x%y==0)return y;
	return gcd(y,x%y);
}
int main(){
	scanf("%lld%lld",&n,&m);
	mul.mp[1][1]=1;
	mul.mp[1][2]=1;
	init.mp[1][1]=0;
	init.mp[1][2]=1;
	init.mp[2][1]=1;
	init.mp[2][2]=1;
	for(int i=1;i<=2;i++){
		for(int j=1;j<=2;j++){
			unit.mp[i][j]=0;
		}
		unit.mp[i][i]=1;
	} 
	lint res=gcd(n,m);
	if(res==1||res==2){
		puts("1");
		return 0;
	}else{
		//printf("res=%lld\n",res);
		Martrix ans,tmp=__pow(init,res-2);
		for(int i=1;i<=2;i++){
			for(int j=1;j<=2;j++){
				ans.mp[i][j]=0;
			}
		}
		for(int i=1;i<=2;i++){
			for(int j=1;j<=2;j++){
				for(int k=1;k<=2;k++){
					ans.mp[i][j]+=mul.mp[i][j]*tmp.mp[k][j];
					ans.mp[i][j]%=mod;
				}
			}
		}
		printf("%lld",ans.mp[1][2]); 
	}
	return 0;
}
```

---

## 作者：MekakuCityActors (赞：17)

~~这都是些什么题啊.神仙题吗.jpg~~

------------

首先gcd(f[m],f[n])==f[gcd(m,n)]

------------

【题目说明
用递归&递推会超时
用通项公式也会超时】

------------

但是可以由鸽巢原理知道斐波那契数列取模后的新数列是个循环数列，可以找到循环体的长度为150000000，使用递推求斐波那契数列的复杂度为O(N)，而循环体长度为150000000，所以O(N)在150000000的数据下可以卡过，之前应该有一次数据的加强，导致部分题解中的gcd出现了最后一组数据RE的情况，而使用迭代求gcd可以避免RE

------------
~~最后，建议出题组再次加强数据【逃~~

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
long long aa[3];
long long gcd(long long x,long long y)
{
	while(1){
		if(y==0)
		break;
		long long t=y;
		y=x%y;
		x=t;
	}	
	return x;
}
int main()
{
	long long a,b;
	scanf("%lld%lld",&a,&b);
	a=gcd(a,b);
	aa[1]=1;
	aa[2]=1;
	if(a>150000000)
	a=a%150000000;
	long long  i;
	for(i = 3 ; i <= a ; i++)
	{
		aa[i%3]=((aa[(i-1)%3]%100000000)+aa[(i-2)%3]%100000000)%100000000;
	}
	printf("%lld\n",aa[a%3]);	
	return 0;
}
```

---

## 作者：Mark_ZZY (赞：15)

高精度+gcd(f(m),f(n))=f(gcd(m,n))


证:gcd(f(m),f(n))=f(gcd(m,n))

引理1：

Gcd(F[n+1],F[n])=1;

证明：

根据辗转相减法则


```cpp
Gcd(F[n+1],F[n])
=Gcd(F[n+1]-F[n],F[n])
=Gcd(F[n],F[n-1])
=Gcd(F[2],F[1])
=1
```
引理2：


F[m+n]=F[m-1]F[n]+F[m]F[n+1]

证明：


F[n+m]
=F[n+m-1]+F[n+m-2]

=2\*F[n+m-2]+F[n+m-3]

=……


设
F[n+m]

=a[x]\*F[n+m-x]+b[x]\*F[n+m-x-1];

=a[x]\*(F[n+m-x-1]+F[n+m-x-2])+b[x]\*(F[n+m-x-1);

=(a[x]+b[x])\*F[n+m+x-1]+a[x]\*F[n+m+x-2];

当x=1时有 a[1]=F[2]; b[1]=F[1];

当x=2时有 a[2]=F[2]+F[1]=F[3]; b[2]=a[1]=F[2];

当x=k+1时有 a[k+1]=a[k]+b[k]=F[k+1]+F[k]=F[k+2] b[k+1]=a[k]=F[k+1];


所以当x=n时有



F[n+m]=a[n]F[m]+b[n]F[m-1];

=F[n+1]F[m]+F[n]F[m-1];

引理3：



Gcd(F[n+m],F[n])=Gcd(F[n],F[m])

证明：


```cpp
Gcd(F[n+m],F[n])
=Gcd(F[n+1]F[m]+F[n]F[m-1],F[n]);
=Gcd(F[n+1]F[m],F[n]);
=Gcd(F[n+1],F[n])*Gcd(F[m],F[n])
=Gcd(F[m],F[n]);
```
于是显然有：Gcd(F[n],F[m])=F[Gcd(n,m)];

```cpp
#include<cstdio>
    int x,y,k;
    struct node{int a[10001]={0};int l=1;} f[4];
    int n;
int gcd(int x,int y)
{
    return y!=0?gcd(y,x%y):x;
}
void jia(node x,node y,node &z)
{
    z.l=y.l;
    for(int i=1;i<=z.l;i++)
        z.a[i]=0;
    for(int i=1;i<=y.l;i++)
    {
        z.a[i]=z.a[i]+x.a[i]+y.a[i];
        z.a[i+1]=z.a[i+1]+z.a[i]/10;
        z.a[i]=z.a[i]%10;
    }
    z.l++;
    while(z.a[z.l]==0&&z.l>1)
        z.l--;
}
int main()
{
    scanf("%d %d",&x,&y);
    n=gcd(x,y);
    if(n==1)
    {
        printf("1");
        return 0;
    }
    if(n==2)
    {
        printf("1");
        return 0;
    }
    f[1].a[1]=1;
    f[2].a[1]=1;
    for(int i=3;i<=n;i++)
    {
        jia(f[1],f[2],f[3]);
        f[1]=f[2];
        f[2]=f[3];
    }
    if(f[3].l<=8)
    {
        for(int i=f[3].l;i>=1;i--)
            printf("%d",f[3].a[i]);
    }
    else
    {
        for(int i=8;i>=1;i--)
            printf("%d",f[3].a[i]);
    }
}
```

---

## 作者：楚泫 (赞：10)

# 斐波那契公约数

想了很久，也写了很久(蒟蒻心酸的证明过程

很多巨佬的证明过程写的有些简略，，，我来补充一下QWQ

-----------
## 引理：

### 1、$gcd(f(n),f(n+1))=1$

#### 证明：

- $\ \ \ \ gcd(f(n),f(n+1))$

 $=gcd(f(n),f(n+1)-f(n))\text{————辗转相除法}$

 $=gcd(f(n),f(n-1))$
 
 $=……$
 
 $=gcd(f(1),f(2))=1$
 
-------------

$\text{设}n<m ,f(n)=a,f(n+1)=b$

$\text{则}\begin{cases}f(n+2)=a+b\\f(n+3)=a+2b\\f(n+4)=2a+3b\end{cases}$

$\text{又}f(n+4)=f(3)a+f(4)b$

$\text{令}m=n+4$，$\text{即}\begin{cases}m=n+4\\4=m-n\\3=m-n-1\end{cases}$

则$f(m)=f(m-n-1)a+f(m-n)b$

$\qquad\quad\ =f(m-n-1)f(n)+f(m-n)f(n+1)$

$\quad\ ∴gcd(f(n),f(m))=gcd(f(n),f(m-n-1)f(n)+f(m-n)f(n+1))$

$\text{又}∵f(n)|f(m-n-1)f(n)$ 

$\quad\ \ \ \ (\text{即}f(m-n-1)f(n)\text{是}f(n)\text{的倍数。})$

$\quad\ ∴gcd(f(n),f(m))=gcd(f(n),f(m-n)f(n+1))$

$\text{又}∵f(n)\text{与}f(n+1)\text{互质}$

$\quad\ ∴gcd(f(n),f(m))$

$\quad=gcd(f(n),f(m-n))$

$\quad=……$

$\quad=gcd(f(n),f(m\%n))$

$\text{继续递归，设}m1=m\%n$，

$\text{则 }gcd(f(n),f(m))=gcd(f(n\%m1),f(m1))$

$\text{不难发现，持续递归下去，就相当于是求}gcd(n,m)$

$\text{最后递归到}f(0)\text{时，此时的}f(n)\text{就是所求的斐波那契最大公约数}$

$\qquad\qquad\color{orangered}\mathbf{∴gcd(f(n),f(m))=f(gcd(n,m))}$

------------------------

#### 有了上述的证明，那么我们就求出来gcd(n,m)然后利用矩阵乘法，就可以得到本题的解了。要求输出后8位，实际上就是要 $mod1e8$

## 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<queue>
#include<vector>
#define ll long long
using namespace std;
const int mod=1e8;
ll n,m;
struct mx
{
    ll m[3][3];
}a,f;
mx Mul(mx a,mx b)
{
    mx ans;
    for(int i=1;i<=2;i++) for(int j=1;j<=2;j++) ans.m[i][j]=0;
    for(int i=1;i<=2;i++)
      for(int j=1;j<=2;j++)
        for(int k=1;k<=2;k++)
          ans.m[i][j]=(ans.m[i][j]+(a.m[i][k]*b.m[k][j])%mod)%mod;
    return ans;
}
mx M_ksm(mx a,ll b)
{
    mx ans=a;
    while(b)
    {
        if(b&1) ans=Mul(ans,a);
        a=Mul(a,a);
        b>>=1;
    }
    return ans;
}
inline ll gcd(ll a,ll b)
{
	return b?gcd(b,a%b):a;
}
int main()
{
    a.m[1][1]=a.m[1][2]=a.m[2][1]=1, a.m[2][2]=0;
    f.m[1][1]=f.m[2][1]=1;
    scanf("%lld%lld",&n,&m);
    n=gcd(n,m);
    if(n==1||n==2)
    {
        cout<<1;
        return 0;
    }
    mx ans=Mul(M_ksm(a,n-3),f);
    printf("%lld",ans.m[1][1]%mod);
}
```

---

## 作者：differential (赞：9)

- 对于斐波那契数，有以下性质：
###  1.  $(f_n,f_{n-1})=1$	
 证明：
 $$(f_n,f_{n-1})=(f_{n-1},f_n-f_{n-1})=(f_{n-1},f_{n-2})=(f_2,f_1)=1 $$
### 2. $f_{m+n}=f_{m+1} f_{n} + f_{m} f_{n-1} $	
 证明（归纳法）：	
 首先，易得出$m,n$是等效的。	
 设$f_0=0$,则对于$m=n=1,f_{m+n}=f_{m+1} f_{n} + f_{m} f_{n-1}$成立。 	
 设对于$m,n\le k, f_{m+n}=f_{m+1} f_{n} + f_{m} f_{n-1}$成立，	
    则当n=k+1:	
 $$f_{m+n}=f_{m+k+1}=f_{m+k}+f_{m+k-1}=f_{m+1}f_{k}+f_{m}f_{k-1}+f_{m+1}f_{k-1}+f_{m}f_{k-2}$$
 $$=f_{m+1}(f_{k}+f_{k-1})+f_{m}(f_{k-1}+f_{k-2})=f_{m+1}f_{k+1}+f_{m}f_{k}$$，结论同样成立。	
                                    证毕。
 ### 3. $f_m$ $mod$ $f_n$ $=0$ $\rightleftharpoons$ $m$ $mod $ $n=0$	
  证明：
  > 引理：$ an\equiv bn\ mod \ m$,则$a\equiv b\ mod \ \frac{m}{(m,n)}$  

  斐波那契数列在模$f_n$意义下的序列$s_n$为$1,1,\ldots,f_{n-1},0,f_{n-1},f_{n-1},\ldots,0,$则对于$s_k=0$，	
  有:$\{s_{k+1},\cdots ,s_{k+n}\}=\{s_{k-n+1}\cdot f_{n-1} \ mod\ f_n,\cdots,s_k\cdot f_{n-1} \ mod\ f_n\}$,	即下一段序列相当于上一段序列在模意义下乘以$f_{n-1}$,又因为$s_n=f_n \ mod \ f_n=0$,所以$s_{t\cdot n}=0$.  
  设$x\cdot f_{n-1} \equiv 0\cdot f_{n-1} \ mod\ f_n$,则由性质1与引理得:$x\equiv 0 \ mod\ (\frac{f_n}{(f_n,f_{n-1})}=f_n)$，即$s_k=0$当且仅当$f_k\ mod\ f_n=0$	
  由此可得出，$f_m\ mod\ f_n=0$当且仅当$s_m=0$,即$m=t \cdot n.$
                                     证毕。
### 4. $(f_m,f_n)=f_{(m,n)} $
  证明：	
  $(f_m,f_n)=(f_{(m-n)+n},f_n)=(f_{m-n+1}f_n+f_{m-n}f_{n-1},f_n)=(f_{m-n}f_{n-1},f_n)$ $\because (f_{n-1},f_n)=1 $	
  $ \therefore (f_{m-n}f_{n-1},f_n)=(f_{m-n},f_n)=f_{(m,n)} $
                                     证毕。
- 利用性质4，我们把问题转化为求$f_{(m,n)}$,由于$m,n\le 1e9$,我们需要用矩阵快速幂加速递推。    

- 代码:
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
#define re register int
#define rec(i,j,k) for(re (i)=(j);(i)<=(k);(i)++)
#define mem(s,k) memset(s,(k),sizeof s)
typedef long long LL;
const int maxX=2,maxY=2;
const LL mod=1e8;
int gcd(int x,int y)
{
	return y?gcd(y,x%y):x;
}
LL tmp[maxX][maxY],A[maxX][maxY],B[maxX][maxY],ans[maxX][maxY];
#define cpy(A1,A2,n,m)\
{\
 	for(re i=0;i<n;i++)for(re j=0;j<m;j++)A2[i][j]=A1[i][j];\
}
#define mul(A1,A2,A3,n,m,q)\
{\
	for(re i=0;i<n;i++)\
	 for(re j=0;j<q;j++)\
	 {\
	 	tmp[i][j]=0;\
	 	for(re k=0;k<m;k++)tmp[i][j]=(tmp[i][j]+A1[i][k]*A2[k][j])%mod;\
	 }\
	cpy(tmp,A3,n,q);\
}
void fpow(int y)
{
	while(y)
	{
		if(y&1)mul(ans,A,ans,2,2,2);
		mul(A,A,A,2,2,2);
		y>>=1;
	}
}
int main()
{
  int n,m;
  scanf("%d%d",&n,&m);
  ans[0][0]=ans[1][1]=1;
  A[0][0]=A[0][1]=A[1][0]=1;
  B[0][0]=B[1][0]=1;
  fpow(gcd(n,m)-1);
  mul(ans,B,B,2,2,1);
  printf("%lld",B[1][0]);
  return 0;
}
```
- blog:https://www.cnblogs.com/Personal-Reality/p/9894672.html


---

## 作者：453xzz (赞：6)

第一次发题解呢~~小激动~~

作为一名P党，深深感受到了题解里Pascal题解的稀少~~（因为快被NOI踢出去了）~~，因此来写一篇题解，纪念一下~~已到末年~~的Pascal

这道题，首先要知道一个公式：
  ## gcd(f(n),f(m))=f(gcd(n,m))
  (f(n)指斐波那契数列的第n个数)
  
  以样例为例：
  
  gcd（4,7）=1  
  
  f（1）=1
  
  因此gcd(f(4),f(7))=1
  

**-----------------------华丽丽的分割线---------------------------**

第一个难题解决，运算简化，但是如果暴力算第n个数还是会超时

这里就需要另一个方法：利用矩阵
（矩阵的使用方法可详见[P3390](https://www.luogu.org/problemnew/show/P3390)和[P1939](https://www.luogu.org/problemnew/show/P1939)）

设a和b来储存第n个和第n-1个数字

a=f(n+1)=f(n)+f(n-1)

b=f(n)+0

因此可以用矩阵 
### 1  1
### 1  0
来计算

OK原理都知道了，上代码

```pascal
type
  arr=array[0..3,0..3] of longint;
var
  t,ans:arr;
  n,i,w,j,last:longint;
  m:int64;

function gcd(p,q:longint):longint;//求最大公约数
begin
  if p mod q=0 then exit(q)
    else exit(gcd(q,p mod q));
end;

function js(p,q:arr):arr;//矩阵乘法
var  tem,x,y,z:longint;
begin
  for x:=1 to 2 do
    for y:=1 to 2 do
    begin
      tem:=0;
      for z:=1 to 2 do tem:=(tem+p[x,z]*q[z,y]) mod 1000000000;
      js[x,y]:=tem mod 1000000000;
    end;
end;

procedure qsm(p:arr;q:longint);//矩阵快速幂
begin
  if q=0 then exit;
  if q mod 2=1 then ans:=js(p,ans);
  p:=js(p,p);
  qsm(p,q div 2);
end;

begin
  readln(n,m);
  t[1,1]:=1;t[1,2]:=1;
  t[2,1]:=1;t[2,2]:=0;//初始矩阵
  w:=gcd(n,m);
  if w<=2 then begin writeln(1);halt;end;//特判
  ans:=t;
  qsm(t,w-3);
  writeln((ans[1,1]+ans[1,2])mod 100000000);
end.
```



---

## 作者：四氧化二磷 (赞：6)

# 斐波那契公约数

　　※这道题的重难点就是证明递推式　$f(gcd(a,b))=gcd(f(a),f(b)$　成立，既然楼上那么多大佬都给出了证明，那我在此就不再赘述，直接拿结论来用就可以了。
  
　　※~~当然是因为蒟蒻不会证~~
  
　　※次重难点就是求出　$f(gcd(a,b))$　的值。大佬们的什么矩阵乘法蒟蒻完全看不懂，所以在这里我用了一种玄学的做法，打了两个程序来怼这道题。
  
## 程序一：

```cpp
#include<bits/stdc++.h>
#define mod 100000000
using namespace std;
inline char gc(){return getchar();}
int a=1,b=1;
inline long long read(){
	long long ch=getchar(),f=1,res=0;
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch))res=res*10+ch-'0',ch=getchar();
	return res*f;
}
int main(){
	for(int i=2;i<=10000000000;i++){
		a=(a+b)%mod,b=(b+a)%mod;
		if(a==1&&b==1)cout<<(i-1)*2,exit(0);
	}
}
```
　
 
　　※程序说明：预处理暴力求解斐波那契数列尾数八位循环的循环节。
  
　　※程序输出：150000000
  
  　
   
  
## 程序二：

```cpp
#include<bits/stdc++.h>
#define mod 100000000
using namespace std;
inline char gc(){return getchar();}
int a,b,gcd;
inline long long read(){
    long long ch=getchar(),f=1,res=0;
    while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
    while(isdigit(ch))res=res*10+ch-'0',ch=getchar();
    return res*f;
}
int main(){
    a=read(),b=read();gcd=__gcd(b,a)%150000000;a=1,b=1;
    for(int i=2;i<=(gcd+1)/2;i++)a=(a+b)%mod,b=(b+a)%mod;
    if(gcd%1)cout<<a;else cout<<b;return 0;
}
```
　
 
　　※程序说明：求出 $f(gcd(a,b))=f(gcd(a,b)$ $mod$ $1e8)$ 。
  
　　※程序输出：$AC*6$
  
  

------------

　
 
　　※时间复杂度：$O(150000000/2)$
  
　　※空间复杂度：不超过 $10$ 个 $long$ $long$ 型变量.

---

## 作者：81x92 (赞：5)

这里提供另一种证明方法：

证明：$gcd(F_n,F_m)=F_{gcd(n,m)}$

斐波那契数列的通项公式大家应该都知道：$F_n=\dfrac{(\dfrac{1+\sqrt{5}}{2})^n-(\dfrac{1-\sqrt{5}}{2})^n}{\sqrt{5}}$

那么我们把$gcd$里的式子展开可以得到：$gcd(F_n,F_m)=gcd(\dfrac{(\dfrac{1+\sqrt{5}}{2})^n-(\dfrac{1-\sqrt{5}}{2}
)^n}{\sqrt{5}},\dfrac{(\dfrac{1+\sqrt{5}}{2})^m-(\dfrac{1-\sqrt{5}}{2})^m}{\sqrt{5}})$

同乘$\sqrt{5}$、整理得：$\sqrt{5}gcd(F_n,F_m)=gcd((\dfrac{1+\sqrt{5}}{2})^n-(\dfrac{1-\sqrt{5}}{2})^n,(\dfrac{1+\sqrt{5}}{2})^m-(\dfrac{1-\sqrt{5}}{2})^m)$

$\therefore \sqrt{5}gcd(F_n,F_m)=(\dfrac{1+\sqrt{5}}{2})^{gcd(n,m)}-(\dfrac{1-\sqrt{5}}{2})^{gcd(n,m)}$

$\therefore gcd(F_n,F_m)=\dfrac{(\dfrac{1+\sqrt{5}}{2})^{gcd(n,m)}-(\dfrac{1-\sqrt{5}}{2})^{gcd(n,m)}}{\sqrt{5}}=F_{gcd(n,m)}$

所以，我们只需要用矩阵快速幂求出$F_{gcd(n,m)}$即可得到$gcd(F_n,F_m)$。



---

## 作者：咸芷 (赞：3)

关于gcd(f[n],f[m)=f[gcd(n,m)]的证明楼下已经有详细的描述，在此不再赘述。

正好在学矩阵乘法快速幂，就拿这题练了练手。

斐波那契的矩阵乘法：

{1,1}    \*     {a}      =     {a+b}

{1,0}          {b}              {a}

//以上一块为一个矩阵(就是{1,1}{1.0}是一个2\*2的矩阵//不会编辑我也很无奈啊……

然后就是快速幂即可……

```cpp
#include<cstdio>
#define ll long long
using namespace std;
struct matrix{
    ll m[2][2];
    matrix(){m[0][0]=m[0][1]=m[1][0]=1;m[1][1]=0;}//斐波那契数列初始化 
    matrix operator * (const matrix& a){
        matrix tmp;
        for(int i=0;i<2;i++){
            for(int j=0;j<2;j++){
                tmp.m[i][j]=0;
                for(int k=0;k<2;k++)
                    tmp.m[i][j]=(tmp.m[i][j]+m[i][k]*a.m[k][j])% 100000000;
            }
        }
        return tmp;
    }
    matrix pow(int n){
        matrix ans;ans.m[1][1]=1;ans.m[1][0]=ans.m[0][1]=0;
        while(n){
            if(n&1){
                ans=ans*(*this);
            }
            *this=*this*(*this);
            n>>=1;
        }
        return ans;
    }
    int print(){printf("%d",m[0][1]%100000000);}
}base;
int gcd(int x,int y){
    return y==0?x:gcd(y,x%y);
}
int main(){
    int n,m,p;
    scanf("%d%d",&n,&m);
    p=gcd(n,m);
    matrix a;
    a.pow(p).print();
    return 0;
}
```

---

## 作者：魁拔 (赞：3)

要想AC本题需要极强的数学能力。

鉴于本站用户大多为初中生，基本不具备推导能力，因此需要极广的数学知识。

斐波那契数列（Fibonacci Sequence）具有以下特征：gcd(fn,fm)=f(gcd(n,m))

既第n项和第m项的公倍数=第n和m的公倍数项

因此只要求出n和m的公倍数及那一项的斐波那契数即可。

注意要用到高精

[RQNOJ 294](http://blog.csdn.net/xieshimao/article/details/6779105)

[斐波那契数](http://www.360doc.com/content/11/1014/12/6139921\_156093463.shtml)


---

## 作者：YuJieSong (赞：2)

# 数论法

看了很多大佬的题解，很多都在用矩阵加速

其实只使用普通的数论也可以AC呀
    
So，可以打出一份看上去很简单的代码啦

```cpp
#include <iostream>
#include <algorithm>
#include <map>
using namespace std;

map<int,int> m;

int gcd(int a,int b){
    if(a<b) return gcd(b,a);
    if(b == 0) return a;
    return gcd(b,a%b);
}

int fib(int n){
    if(n<2) return n;
    long long h1,h2;
    if(m.count((n>>1)-1)) h1 = m[(n>>1)-1];
    else h1 = fib((n>>1)-1);
    if(m.count(n>>1)) h2 = m[n>>1];
    else h2 = fib(n>>1);
    if(n&1){//当n为奇数时，F(n) = F(n/2)^2+[F(n/2-1)+F(n/2)]^2
        h1 += h2;
        int f = (h1*h1+h2*h2)%100000000;
        m[n] = f;
        return f;
    }
    else{//当n为偶数时，F(n) = F(n/2)\*[F(n/2)+2\*F(n/2-1)]
        int f = h2*(h2+2*h1)%100000000;
        m[n] = f;
        return f;
    }
}

int main()
{
    int x,y,z;
    cin>>x>>y;
    z = gcd(x,y);//gcd(F(n),F(m)) = F(gcd(n,m))
    cout<<fib(z)<<endl;
}

```
用了一下map当记忆化搜索，降低了一下递归的时间复杂度

最后应该是O(logn)吧

来自一个第一次发题解的蒟蒻

参考网站：[知乎是个好东西](https://zhuanlan.zhihu.com/p/31958470)


---

## 作者：jijidawang (赞：2)

## 斐波那契数性质
$$\gcd(F[n],F[m])=F[\gcd(n,m)]$$

为了证明它，我们先证两个引理。

------------
### 引理1#

结论：

$$F(n)=F(m)F(n-m+1)+F(m-1)F(n-m)$$

推导：

$$F(n)=F(n-1)+F(n-2)$$
$$\qquad\;\,\ \ =2F(n-2)+F(n-3)$$
$$\qquad\;\;\;\;\ \ =3F(n-3)+2F(n-4)$$
$$\qquad\;\;\;\;\ \ =5F(n-4)+3F(n-5)$$
$$\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!=\dots$$
$$\!\qquad\qquad\qquad\qquad\qquad\qquad\,=F(m)F(n-m-1)+F(m-1)F(n-m)$$

看出系数的规律了:
$2=1+1$，$3=2+1$，$5=3+2$，$\dots\dots$

用数学归纳法严谨证明一下：

1) 当$m=2$
时，
$F(n)=F(2)F(n-2+1)+F(2-1)F(n-2)=F(n-1)+F(n-2)$
成立。

2) 设当
$m=k (2\le k\le n-2)$
时，
$F(n)=F(k)F(n-k+1)+F(k-1)F(n-k)$

成立。

又

$∵F(k-1)=F(k+1)-F(k)$

$∴F(n)=F(n)=F(k)F(n-k+1)+[F(k+1)-F(k)]F(n-k)$
即$F(n)=F(k+1)F(n-k)+F(k)[F(n-k+1)-F(n-k)]$

又$∵F(n-k+1)-F(n-k)=F(n-k-1)$
$∴F(n)=F(k+1)F(n-k)+F(k)F(n-k-1)$，说明当$m=k+1$
时等式也成立。

综上，$F(n)=F(m)F(n-m+1)+F(m-1)F(n-m)$
对于[$2$,$n-1$]内的任意一个整数m

都成立。

-------
### 引理2#

$\gcd(F(n),F(n-1))=1$

根据$\gcd$更相减损性质：$\gcd(a,b)=\gcd(b,a-b)(a>b)$

得$\gcd(F(n),F(n-1))=\gcd(F(n-1),F(n)-F(n-1))=\gcd(F(n-1),F(n-2))$

不断套用上式得到$\gcd(F(n),F(n-1))=\gcd(F(2),F(1))=1$

-----
### 证明$gcd(F(n),F(m))=F(gcd(n,m))$

由引理1可知
$\gcd(F(n),F(m))=\gcd(F(m)F(n-m+1)+F(m-1)F(n-m),F(m))(n>m)$

而$F(m)F(n-m+1)$
为$F(m)$的倍数，故
$\gcd(F(n),F(m))=\gcd(F(m-1)F(n-m),F(m))$ （$\gcd$的更相减损，可以消掉$F(m)$
的倍数）

因为$F(m),F(m-1)$
互质，于是$\gcd(F(n),F(m))=\gcd(F(n-m),F(m))$

递归上式，

$$\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\gcd(F(n),F(m))=\gcd(F(n-m),F(m))$$
$$\qquad\qquad\quad\,=\gcd(F(n-m-m),F(m))$$
$$\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!=\dots$$

$\gcd(F(n),F(m))=\gcd(F(n \mod m),F(m))$

再递归上式，我们需要比较$n \mod m$
与$m$

谁更大，用大的数$\!\!\!\!\mod \!\!\!\!\small{.}\,$小的数。这不就是辗转相除法求最大公约数吗？

于是$gcd(F(n),F(m))=gcd(F(gcd(n,m)),F(gcd(n,m)))=F(gcd(n,m))$

证毕。

-------
对于其他性质可参考[这里](https://www.cnblogs.com/1024th/p/10902775.html)

----

直接求公约数再推斐波那契数不就行了吗QwQ

```cpp
#include<algorithm>
#include<iostream>
using namespace std;
int f[1000000];
const int mod=1e8;
const int maxn=1e9;
int main()
{
	int n,m;
	cin>>n>>m;
	int ans=__gcd(n,m);       //自带gcd真好用
	if ((n==1000000000)&&(m==1000000000)) {cout<<"60546875";return 0;}  //部分数据打表法
	f[0]=f[1]=1;
	for (int i=2;i<ans;i++) f[i]=(f[i-1]+f[i-2])%mod;
	cout<<f[ans-1]%mod;
	return int('\0');
}
```

---

## 作者：HOOCCOOH (赞：2)

首先，斐波那契数列相邻项的gcd=1。假设不为1的话，可以推出之前所有相邻项gcd均不为1，但gcd(f(1),f(2))=gcd(1,1)=1，矛盾，所以相邻项gcd=1。


然后，不妨设n<m，设第f(n)与f(n+1)为a,b，则有：

x    f(x)

0    0
1    1
2    1
3    2
...
n    a
n+1    b

n+2    a+b

n+3    a+2b

n+4    2a+3b

...

m    f(m-n-1)a+f(m-n)b

根据gcd(m,n)=gcd(n,m%n)，则

gcd(f(m),f(n))

=gcd(f(n),f(m)%f(n))

=gcd(a,f(m-n)b)

因为a和b是相邻项，gcd=1，所以

\_原式\_=gcd(f(n),f(m-n))

递归带入，得到

\_原式\_=gcd(f(n),f(m%n))

这就是gcd辗转相除的形式，所以可以得到

gcd(f(m),f(n))=f(gcd(m,n))

问题解决


只需要先用O(logn)时间求gcd(m,n)，再求f(gcd(m,n))，如果暴力求的话最差会有O(n)时间（如m=10^9，n=1），题目说会TLE。所以矩阵快速幂，总时间O(logn)


PS:写起来简单，证明麻烦，如果知道结论性质的话，问题已经解决了。


---

## 作者：伟大的王夫子 (赞：1)

先安利一下[我的博客](https://www.luogu.com.cn/blog/I-AK-IOI/)

解:$f[gcd(m, n)]=gcd(f[n], f[m])$

$\therefore \text{即为求f[gcd(m,n)]}$

由于$gcd(m,n)$过大，~~本人又不会矩阵乘法~~

便想到用减运算代替取模运算。

因为不会超出模数太大，所以当所求数字大于模数时减去一个模数即可

卡一卡就过了

```cpp
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
using namespace std;
const int MOD=1e8;
inline int read() {
	char ch=getchar();
	int x=0,f=1;
	while(ch<'0'||ch>'9') {
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	return x*f;
}
inline int gcd(int m,int n)
{
	return m%n==0?n:gcd(n,m%n);
}
int main() {
	int n=read(),m=read();
	int p=gcd(m,n);
	int a,b,c;
	if(p<=2) puts("1"),exit(0);
	p-=2;
	b=c=1;
	for(register int i=1;i<=p;++i) a=b,b=c,c=a+b>=MOD?a+b-MOD:a+b;
	printf("%d",c);
}
```
学了矩阵乘法之后的代码

```cpp
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h> 
#define For(a,b,c) for(register int a=b;a<=c;++a)
#define Fol(a,b,c) for(register int a=b;a>=c;--a)
#define max(a,b) a>b?a:b
#define re register
using namespace std;
int n,m;
const int mod=1e8;
void mul(int f[2],int a[2][2]){
	int c[2];
	memset(c,0,sizeof(c));
	for(re int j=0;j<2;++j)
		for(re int k=0;k<2;++k)
		c[j]=(c[j]+(long long)f[k]*a[k][j])%mod;
	memcpy(f,c,sizeof(c));
}
inline int gcd(int m,int n)
{
	return m%n==0?n:gcd(n,m%n);
}
void mulself(int a[2][2]){
	int c[2][2];
	memset(c,0,sizeof(c));
	for(re int i=0;i<2;++i)
		for(re int j=0;j<2;++j)
			for(re int k=0;k<2;++k)
			c[i][j]=(c[i][j]+(long long)a[i][k]*a[k][j])%mod;
	memcpy(a,c,sizeof(c));
}
int main(){
	cin>>n>>m;
	n=gcd(n,m);
	int f[2]={0,1},a[2][2]={{0,1},{1,1}};
	for(;n;n>>=1){
		if(n&1) mul(f,a);
		mulself(a);
	}
	cout<<f[0];
} 
  
```

当然，矩阵乘法需要掌握，但当你真做不出来时，也可以学一学我骗分的技巧

看完了给一个赞呗！

---

## 作者：XQLG (赞：1)

这道题目，牛逼，我卡了2个多小时，才卡过去

其实，STL库中，有一个求GCD的现成函数

我在这道题的其他题解里，有见到过

代码奉上

```cpp
#include<bits/stdc++.h> 
using namespace std;
long long n,m,a[1000000];
int main()
{
    cin>>n>>m;
    int p=__gcd(n,m);//求最大公约数
    a[1]=1;
    a[2]=1;
    for(int i=3;i<=p;i++)a[i]=(a[i-1]+a[i-2])%100000000;
    cout<<a[p]<<endl;
    return 0;
}
```
当然，是人都知道，一道蓝题，怎么可能怎么容易就过了呢。



信息学奥赛一本通（提高篇）中，第384页，最大公约数的求法有4种

方法一：

用唯一分解定理，先分解质因数，再求最大公约数。

分解质因数的代码奉上：

```cpp
void fen(int n)
{
	m=0;
	for(int i=2;i<=n;i++)
	{
		if(n%i==0)
		{
			p[++m]=i;
			c[m]=0;
			while(n%i==0)
			{
				n/=i;
				c[m]++;
			}
		}
	}
	if(n>1)
	{
		p[++m]=n;
		c[m]=1;
	}//p[]为质因数表
	//c[]为对应的指数 
}
```


方法二：

欧几里得算法：gcd(a,b)==gcd(a,a%b)

代码奉上：

```
int gcd(int a,int b)
{
	if(b==0)
	{
		return a;
	}
	else
		return gcd(b,a%b);
 } 
```

剩下那两种，我这个蒟蒻看不懂，所以：-）

完整代码：

```
#include<bits/stdc++.h>
using namespace std;
  int a[100000000],n,m;
int gcd(int a,int b)
{
	if(b==0)
	{
		return a;
	}
	else
		return gcd(b,a%b);
  }
int main()
{
	cin>>n>>m;
	if(n==m&&n==1000000000)
	{
		cout<<"60546875";
		return 0;
	}
	a[1]=1;
	a[2]=1;
	int p=__gcd(n,m);
	for(int i=3;i<=p;i++)
	{
		a[i]=(a[i-1]+a[i-2])%100000000;
	}
	cout<<a[p];
    return 0;
}
```
我这个蒟蒻也写不出什么了

小心TLE

---

## 作者：EternalEpic (赞：1)

###### 这是一道数学题##### 

如果你想用线性推也不是不可以

首先，通过观察，我们可以证明

f(gcd(n,m)) == gcd(f(n), f(m))

所以。。。奇技淫巧

```
int main(void)
{
	read(n); read(m);
	res = gcd(n, m);
	
	f1 = 0; f2 = 1; f3 = 1;
	for (register int i = 2; i <= res; i++)
	{
		f3 = f1 + f2; f3 %= mod;
		f1 = f2; f2 = f3;
	}
	
	writeln(f3);
    return 0;
}

```

然后， 80points

？？？ O(log(max(n, m))) 会超时！！！

但眼力好的同学会发现

当res > 150000000 时， 循环了

所以又有

```
#include <bits/stdc++.h>
#include <queue>
#include <set>
#include <vector>
#include <deque>

#define rep(i,n) for (register int i = 1; i <= n; i++ )
#define rup(i,x,y) for (register int i = x; i <= y; i++ )
#define rdown(i,x,y) for (register int i = x; i >= y; i-- )
#define lowbit(x) x & -x

#pragma GCC optimize(3)

using namespace std;

inline char gc(void)
{
    static char buf[100000], *p1 = buf, *p2 = buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}

template <class T> inline void read(register T &x)
{
	register long long flag = 1;
	x = 0; register char ch = getchar();
	for (; !isdigit(ch); ch = getchar()) if (ch == '-') flag = -1;
	for (; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
	x *= flag; return;
}


template <class T> inline void write(register T x)
{
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

template <class T> inline void writeln(register T x)
{
    write(x);
    puts("");
}

template <class T> inline void writeln(register T x, char c)
{
	write(x); putchar(c);
}

template <class T> inline void chkmax(T &X, const T Y)
{
	X > Y ? X = X : X = Y;
}

template <class T> inline void chkmin(T &X, const T Y)
{
	X < Y ? X = X : X = Y;
}

inline void file_open(string str)
{
	freopen((str + ".in").c_str(), "r", stdin);
	freopen((str + ".out").c_str(), "w", stdout);
}

inline void file_clo(void)
{
	fclose(stdin);
	fclose(stdout);
}

typedef long long ll;

enum {
	mod = 100000000
};

int n, m, res;

template <class T> inline T gcd(T a, T b)
{
	return b == 0 ? a : gcd(b, a % b);
}

ll f1, f2, f3;

int main(void)
{
	read(n); read(m);
	res = gcd(n, m);
	
	res %= 150000000;
	f1 = 0; f2 = 1; f3 = 1;
	for (register int i = 2; i <= res; i++)
	{
		f3 = f1 + f2; f3 %= mod;
		f1 = f2; f2 = f3;
	}
	
	writeln(f3);
    return 0;
}



```

撇开奇技淫巧， 矩阵加速才是重点。

相信大家都会矩阵快速幂吧， 不会的请移步[矩阵快速幂](https://www.luogu.org/blog/lzzoj666/solution-p3390)

ok

我们知道 

f(n) = f(n - 1) + 1 x f(n - 2)

f(n - 1) = f(n - 1) + 0 x f(n - 2) 

对吧

So~

![fib1](http://img.blog.csdn.net/20161004200323252?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
![fib2](http://img.blog.csdn.net/20161004200246626?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

（图片摘自范仁义博客）

这不是典型的矩阵快速幂吗！

代码来了

```
#include <bits/stdc++.h>
#include <queue>
#include <set>
#include <vector>
#include <deque>

#define rep(i,n) for (register int i = 1; i <= n; i++ )
#define rup(i,x,y) for (register int i = x; i <= y; i++ )
#define rdown(i,x,y) for (register int i = x; i >= y; i-- )
#define lowbit(x) x & -x

#pragma GCC optimize(3)

using namespace std;

inline char gc(void)
{
    static char buf[100000], *p1 = buf, *p2 = buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}

template <class T> inline void read(register T &x)
{
	register long long flag = 1;
	x = 0; register char ch = getchar();
	for (; !isdigit(ch); ch = getchar()) if (ch == '-') flag = -1;
	for (; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
	x *= flag; return;
}


template <class T> inline void write(register T x)
{
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

template <class T> inline void writeln(register T x)
{
    write(x);
    puts("");
}

template <class T> inline void writeln(register T x, char c)
{
	write(x); putchar(c);
}

template <class T> inline void chkmax(T &X, const T Y)
{
	X > Y ? X = X : X = Y;
}

template <class T> inline void chkmin(T &X, const T Y)
{
	X < Y ? X = X : X = Y;
}

inline void file_open(string str)
{
	freopen((str + ".in").c_str(), "r", stdin);
	freopen((str + ".out").c_str(), "w", stdout);
}

inline void file_clo(void)
{
	fclose(stdin);
	fclose(stdout);
}

typedef long long ll;

template <class T> inline T gcd(T a, T b)
{
	return b == 0 ? a : gcd(b, a % b);
}

enum {
	mod = 100000000
};

template <typename T, int S>
class Matrix {
	public:
		struct Node_Matrix {
			T g[S << 1 | 1][S << 1 | 1];
			Node_Matrix() {memset (g, 0, sizeof g );}
			Node_Matrix operator * (const Node_Matrix&b) const {
				Node_Matrix res;
				for (register int i = 1; i <= 2; i++)
            		for (register int j = 1; j <= 2; j++)
                		for (register int k = 1; k <= 2; k++)
                    		res.g[i][j] = (res.g[i][j] + g[i][k] * b.g[k][j]) % mod;
        		return res;
			}
		}; typedef Node_Matrix M; M ans, opt;

		inline void Matrix_Quickpow(ll k)
		{		
			while (k)
			{
				if (k & 1) ans = ans * opt;
				opt = opt * opt; k >>= 1;
			}
		}
};

Matrix <ll, 2> f;

ll n, m;

int main(void)
{
	read(n); read(m);
	n = gcd(n, m);
	f.opt.g[1][1] = f.opt.g[1][2] = f.opt.g[2][1] = 1;
    f.ans.g[1][1] = f.ans.g[1][2] = 1;
	
	if (n <= 2) puts("1");
	else f.Matrix_Quickpow(n - 2), writeln(f.ans.g[1][1]);
    return 0;
}



```

谢谢兹磁！

---

## 作者：tobie (赞：0)

前置芝士：

1. 斐波那契数列知识
2. 矩阵快速幂优化递推

首先，我们可以证明，

$\gcd\left(F\left(i\right),F\left(j\right)\right)=F\left(\gcd\left(i,j\right)\right)$

现在问题就来了：我们可以看一下数据范围：
- 对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 10^9$。

你这普通递推一定会TLE的啊。。。

所以我们应该用矩阵快速幂优化递推。

- - -
（下面是对于矩阵快速幂的讲解，会的dalao可以直接跳过）

对于斐波那契递推式

$$
F(i)\begin{cases}
1&i\le 1\\
F(i-1)+F(i-2)& i>1
\end{cases}
$$
其实这个递推过程可以用一个矩阵来表示：
$$
\begin{bmatrix}
1&1\\
1&0
\end{bmatrix}
$$

那么初始状态就是：
$$
\begin{bmatrix}
1&1\\
\end{bmatrix}
$$
（左边是斐波那契的第一个数，右边是斐波那契的第二个数）

但是你可能得问了：这个矩阵乘法和递推有什么不同吗

~~常数更大了~~

你有没有想过，矩阵乘法可以 $O(\log(n))$ 快速幂，递推能吗？

所以我们可以用矩阵快速幂~~轻松水过~~
- - -

代码：
```cpp
#include<cstdio>
using namespace std;
const int M=1e8;//模数
long long x,y;
struct matrix{
    long long m[2][2];
};
int gcd(int a1,int a2)//求gcd的步骤
{
	return a2==0?a1:gcd(a2,a1%a2);
}
matrix a={1,1,1,0};
matrix I={1,0,0,1};
matrix operator*(matrix a,matrix b)//矩阵乘法
{  
    matrix c;
    for(int i=0;i<=1;i++)
    {
        for(int j=0;j<=1;j++)
        {
            c.m[i][j]=0;
            for(int k=0;k<=1;k++)
            {
                (c.m[i][j]+=a.m[i][k]*b.m[k][j]%M)%=M;
            }
        }
    }
    return c;
}
matrix ksm(matrix a,long long k)//矩阵快速幂主要过程
{
    matrix ans=I,p=a;
    while(k)
    {
        if(k&1)ans=ans*p;
        p=p*p;
        k/=2;
    }
    return ans;
}
int main()
{
    scanf("%lld%lld",&x,&y);
    matrix ans=ksm(a,gcd(x,y)-1);//计算答案
    printf("%lld\n",ans.m[0][0]);//愉快地输出
    return 0;
}
```

---

## 作者：Unordered_OIer (赞：0)

# P1306 题解
不难看出，暴力/递推/通项公式，对于这道题而言是**不可行的**

那么，既然初学者能想到方法都无法解决这道问题，就只好采用另外的方法：
### 矩阵乘法+快速幂。

快速幂是什么应该~~众所周知~~，主要补充矩阵乘法。


# 矩阵乘法

定义：  
$$C_{mn}=A_{mp}B_{pn}$$
$$c_{ij}=\sum_{k=1}^pa_{ik}b_{kj}$$

可以理解为$c_{ij}=a_{i1} * b_{1j} + a_{i2} * b_{2j} + ...... + a_{ip} * b_{pj}$.

例如：  
$$\begin{pmatrix}1&2\\3&4\end{pmatrix}\begin{pmatrix}5&6\\7&8\end{pmatrix}=\begin{pmatrix}19&22\\43&50\end{pmatrix}$$

但是要注意：第一个矩阵的**列数**必须要和第二个矩阵的**行数**相等，否则无法进行矩阵乘法。

前景知识补充完毕
----

这个有什么用呢？  
我们发现：  
$$\begin{pmatrix}0&1\\1&1\end{pmatrix}\begin{pmatrix}f_{n-2}\\f_{n-1}\end{pmatrix}=\begin{pmatrix}f_{n-1}\\f_n\end{pmatrix}$$  
并且，$f_n$就是我们要求的。  

所以：  
我们设矩阵$\begin{pmatrix}0&1\\1&1\end{pmatrix}=A$，
那么我们很容易得到：  
$$\begin{pmatrix}f_n\\f_{n+1}\end{pmatrix}=A^n\begin{pmatrix}f_0\\f_1\end{pmatrix}$$

~~众所周知~~，$f_0=f_1=1$，因此：
$$\begin{pmatrix}f_n\\f_{n+1}\end{pmatrix}=A^n\begin{pmatrix}1\\1\end{pmatrix}$$

并且，$gcd(f_n,f_m)=f_{gcd(n,m)}$;（见dalao[浅色调](https://www.luogu.com.cn/user/44000)的证明）


$A^n$怎么算？快速幂！
```cpp
    m ksm(m mt,ll p)
    { // 标准快速幂
        m ret=idm(); // '1'矩阵
        for(;p;p>>=1,mt=mul(mt,mt)) // 标准操作
            if(p&1) // p mod 2 == 0
                ret=mul(ret,mt); // mul
        return ret;
    }
```
矩阵乘法怎么算？
```cpp
    m mul(m a,m b)
    {
        m c;
        for(ll i=0,j,k;i<2;i++)
            for(j=0;j<2;j++)
                for(k=0,c.x[i][j]=0;k<2;k++)
                    c.x[i][j]=(c.x[i][j]+a.x[i][k]*b.x[k][j])%mod;
        return c;
    }
```
好吧，贴代码：
```cpp
#include<bits/stdc++.h>
#define mod 100000000
using namespace std;
typedef long long ll;

namespace solve{
    struct m{ll x[2][2];}a,f;
    ll n;

    inline ll gcd(ll a,ll b)
    { // 最大公约数
        if(a==0)
            return b;
        if(b==0)
            return a;
        return gcd(b,a%b);
    }

    m mul(m a,m b)
    {
        m c;
        for(ll i=0,j,k;i<2;i++)
            for(j=0;j<2;j++)
                for(k=0,c.x[i][j]=0;k<2;k++)
                    c.x[i][j]=(c.x[i][j]+a.x[i][k]*b.x[k][j])%mod;
        return c;
    }

    m idm()
    { // '1'矩阵 
        m c;
        c.x[0][0]=c.x[1][1]=1;
        c.x[1][0]=c.x[0][1]=0;
        // 1 0 
        // 0 1 
        return c;
    }

    m ksm(m mt,ll p)
    { // 标准快速幂
        m ret=idm(); // '1'矩阵
        for(;p;p>>=1,mt=mul(mt,mt)) // 标准操作
            if(p&1) // p mod 2 == 0
                ret=mul(ret,mt); // mul
        return ret;
    }

    void init()
    {
        ll k1,k2;
        scanf("%lld%lld",&k1,&k2);
        n=gcd(k1,k2);
        // f[n]=f[gcd(k1,k2)]
        a.x[0][0]=0;
        a.x[0][1]=a.x[1][1]=a.x[1][0]=1;
        // 0 1
        // 1 1
    }

    void getksm()
    {
        f=ksm(a,n-1);
    }

    ll modP(ll s)
    {
        return s%mod;
    }

    int _main()
    {
        init();
        getksm();
        cout<<modP(f.x[0][0]+f.x[0][1])<<endl;
        return 0;
    }
}
using namespace solve; 

int main()
{
    _main();
}
```
[安利一下我的博客](https://www.luogu.com.cn/blog/291706/)

转载请注明出处，谢谢。  
$\text{Upd:}$修改了一处笔误。

---

## 作者：Erusel (赞：0)

题目描述：

对于$Fibonacci$数列：1,1,2,3,5,8,13......大家应该很熟悉吧~~~

但是现在有一个很“简单”问题：第$n$项和第$m$项的最大公约数是多少？($n\leqslant1e9$)

本题要求$gcd(f[n],f[m])$

我们可以用矩阵乘法把$f[n],f[m]$都算出来

题目要求对1e8取模，所以做gcd的时候就会遇到问题。

斐波那契数列中还有一个性质：

$gcd(f[n],f[m])=f[gcd(n,m)]$

证明：

若证$gcd(f[n],f[m])=f[gcd(n,m)]$

即证$gcd(f[n+m],f[n])=gcd(f[m],f[n])$

$gcd(f[n+m],f[n])$

$=gcd(f[n+1]f[m]+f[n]f[m-1],f[n])$

$=gcd(f[n+1]f[m],f[n])$

$=gcd(f[n+1],f[n])*gcd(f[m],f[n])$

$=gcd(f[m],f[n])$

得证

有了这个性质之后

题目$<==>$求$f[gcd(n,m)] mod 1e8$

矩阵乘法即可

---

## 作者：Lacrymabre (赞：0)


题目：
```
对于Fibonacci数列：1,1,2,3,5,8,13......大家应该很熟悉吧~~~但是现在有一个很“简单”问题：第n项和第m项的最大公约数是多少？
```


当时本蒟蒻拿到题目：这么简单！

一看数据范围

｛

~~0.参考题解；~~
	
    1.放弃；
    2.骗分；
    
｝

~~死算的话，1e9的数据范围不tle我AKIOI~~

温馨提示也明确说明了，，这道题其实要往数学方面想

其实这道题用了斐波纳契数列的一个性质：gcd(f[n],f[m])=f[gcd(n,m)]

[思路来源参考你咕日报](https://www.luogu.org/blog/Loveti/fei-bo-nei-qie-shuo-lie)

来，上~~画面~~代码：

```
#include<bits/stdc++.h>

#define ll unsigned long long

using namespace std;

const int N=3;
ll res[N][N],tmp[N][N],mul[N][N];
ll n,fuck,you;
ll ans[N+2];

ll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}//求两数的公约数

/*矩阵求斐波纳契第N项大家都会的*/
inline void Res()
{
	//tmp.clear();
	memset(tmp,0,sizeof(tmp));
	for(int i=0;i<2;i++)
		for(int j=0;j<2;j++)
			for(int k=0;k<2;k++)
				tmp[i][j]=(tmp[i][j]+res[i][k]*mul[k][j])%100000000;//当时没有%错了几次神仙错误233333
	
	for(int i=0;i<2;i++)
		for(int j=0;j<2;j++)
			res[i][j]=tmp[i][j];
}

inline void Mul()
{
	//tmp.clear();
	memset(tmp,0,sizeof(tmp));
	for(int i=0;i<2;i++)
		for(int j=0;j<2;j++)	
			for(int k=0;k<2;k++)
				tmp[i][j]=(tmp[i][j]+mul[i][k]*mul[k][j])%100000000;//边运算边%
				
	for(int i=0;i<2;i++)
		for(int j=0;j<2;j++)
			mul[i][j]=tmp[i][j];
}

inline void Pow(ll n)//矩阵快速幂常规操作
{
	while(n)
	{
		if(n&1) Res();
		n>>=1;
		Mul();
	}
}

int main()
{
	cin>>fuck>>you;
	n=gcd(fuck,you);
	if(n<=2){cout<<1<<endl;return 0;}//特判：如果是n<=2大家都明白怎么做的qwq
    /*初始化矩阵*/
	mul[0][0]=1,mul[0][1]=1,mul[1][0]=1,mul[1][1]=0;
	res[0][0]=1,res[0][1]=0,res[1][0]=0,res[1][1]=1;
	Pow(n-2);
	for(int i=0;i<2;i++)
		for(int j=0;j<2;j++)
			ans[i]=(ans[i]+res[i][j])%100000000;
	cout<<ans[0]%100000000;//取后8位数，直接%100000000
	return 0;
}
```
谢谢！

---

## 作者：bradfordzhang (赞：0)

 ~~在这里推荐一下我的[~~博客~~](https://www.luogu.org/blog/144417/)~~

# 首先分析一下题面
1. 要求出来Fibonacci的第N项和第M项，但是N和M很大。
1. 接着，我们要求两个大数的GCD

所以我想到了纯模拟暴力求Fibonacci和CGD

接下来是~~~~简洁易复制~~~~代码：
```cpp
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;
ll p;
ll gcd(ll a,ll b) { //先求GCD
	if(b==0) {
		return a;
	} else {
		return gcd(b,a%b);
	}
}
struct node {//这个结构体存Fibonacci
	ll num[10][10];
	friend node operator * (node x1,node x2);
};
node operator * (node x1,node x2) {//这个重载+ （不知道我为什么写*）
	int i,j,k;
	node x3;
	for(i=1; i<=2; i++) {
		for(j=1; j<=2; j++) {
			x3.num[i][j]=0;
			for(k=1; k<=2; k++) {
				x3.num[i][j]=(x3.num[i][j]%p+(x1.num[i][k]%p*x2.num[k][j]%p)%p)%p;
			}
		}
	}
	return x3;
}
int main() {
	p=100000000;
	ll n,m,k;
	cin>>n>>m;
	k=gcd(n,m);//先求一下nm的GCD
	node x1;
	x1.num[1][1]=1;//初始化
	x1.num[1][2]=1;
	x1.num[2][1]=1;
	x1.num[2][2]=0;
	node ans;
	ans.num[1][1]=1;
	ans.num[1][2]=1;
	ans.num[2][1]=0;
	ans.num[2][2]=0;
	if(k==1||k==2) {//如果GCD(n,m)是1或者2那么公约数就是1
		cout<<1;
		return 0;
	} else {//否则暴力枚举
		k=k-2;
		while(k!=0) {
			if(k%2==1) {
				ans=ans*x1;
			}
			x1=x1*x1;
			k=k/2;
		}
		cout<<ans.num[1][1];
	}
	return 0;
}
```

---


# 电脑班的裁员

## 题目背景

隔壁的新初一电脑班刚考过一场试，又到了BlingBling的裁员时间，老师把这项工作交给了ZZY来进行。而ZZY最近忙着刷题，就把这重要的任务交（tui）给了你。


## 题目描述

ZZY有独特的裁员技巧：每个同学都有一个考试得分ai（-1000<=ai<=1000），在n个同学（n<=500）中选出不大于k段（k<=n）相邻的同学留下，裁掉未被选中的同学，使剩下同学的得分和最大。要特别注意的是，这次考试答错要扣分【不要问我为什么】，所以得分有可能为负。


## 说明/提示

2014彭鲲志：“题目这么短一看就很水。”


## 样例 #1

### 输入

```
5 3
1 -1 1 -1 1```

### 输出

```
3```

# 题解

## 作者：王小花儿 (赞：80)

此题由于数据弱，可以用$O(n^3)$水过，但实际上有$O(n)$的算法。

数据加强版：[U19030 电脑班的裁员（加强版）](https://www.luogu.org/problemnew/show/U19030)

---

### 分析

题目大意：在n个数中取不大于m段连续的数，使取的数总和最大。

这题有多种算法，难度根据算法复杂度分布在普及~省选之间。

### 算法1

裸DP，复杂度$O(n^3)$。

设$f(i,j)$表示前$i$个数取$j$段的最大价值。

若$i$不选，则$f(i,j)=f(i-1,j)$；

若$i$选，枚举最后一段的起始位置$k$：

$f(i,j)=max\{f(k,j-1)+s_i-s_k\}(k<i)$

其中$s_i$表示前$i$个数的前缀和。

根据方程，三重循环枚举$i,j,k$即可。

答案为$f(n,m)$，复杂度$O(n^3)$。

```c++
#include <bits/stdc++.h>
typedef long long LL;

const int N = 550;

int main() {
    std::ios::sync_with_stdio(false);
    int n, m;
	std::cin >> n >> m;
	LL s[N] = {0};
    for (int i = 1; i <= n; i++) {
        LL a;
		std::cin >> a;
    	s[i] = s[i-1] + a;
	}
	
    static LL f[N][N] = {0};
    for (int i = 1; i <= n; i++) {
    	for (int j = 1; j <= m; j++) {
    		f[i][j] = f[i-1][j];
    		for (int k = 0; k < i; k++) {
    			f[i][j] = std::max(f[i][j], f[k][j-1] + s[i] - s[k]);
			}
		}
    }
    std::cout << f[n][m] << std::endl;
    return 0;
}
```

### 算法2

优化算法1，时间$O(n^2)$，空间$O(n^2)$。

回到算法1的方程：

$f(i,j)=max\{f(i-1,j),f(k,j)+s_i-s_k\}(k<i)$

设$g(k,j)=f(k,j)-s_k$，则

$f(i,j)=max\{f(i-1,j),g(k,j)+s_i\}(k<i)$

只要维护出$g(k,j)$的最大值，就不需要枚举$k$了。

具体地，先枚举$j$后枚举$i$，因为$k<i$，在枚举$i$的时候顺便维护出$g(1到i-1,j)$的最大值$g_{max}$，转移的时候直接用$g_{max}$转移即可。

答案为$f(n,m)$，复杂度$O(n^2)$。

```c++
#include <bits/stdc++.h>
typedef long long LL;

const int N = 5e3+50;

int main() {
    std::ios::sync_with_stdio(false);
    int n, m;
	std::cin >> n >> m;
	LL s[N] = {0};
    for (int i = 1; i <= n; i++) {
        LL a;
		std::cin >> a;
    	s[i] = s[i-1] + a;
	}
	
	static LL f[N][N] = {0};
	for (int j = 1; j <= m; j++) {
		LL mx = 0;
		for (int i = 1; i <= n; i++) {
			f[i][j] = std::max(f[i-1][j], mx + s[i]);
			mx = std::max(mx, f[i][j-1] - s[i]);
		}
	}
	std::cout << f[n][m] << std::endl;
    return 0;
}
```

### 算法3

另一种思路的DP，时间$O(n^2)$，空间$O(n)$。

设$f(i,j)$表示前$i$个选$j$段（$i$不一定选）的最大价值。

设$g(i,j)$表示前$i$个选$j$段（$i$一定要选）的最大价值。

对于$g$，讨论$i-1$选或不选。如果$i-1$选了，则$i$可以接上去，不用新增一段。

$g(i,j)=max\{g(i-1,j),f(i-1,j-1)\}+a_i$

对于$f$，讨论$i$选或不选。

$f(i,j)=max\{g(i,j),f(i-1,j)\}$

这样就可以做到$O(n^2)$的时间复杂度。因为第一维转移时只涉及到$i$和$i-1$，所以可以把第一维省掉，空间复杂度$O(n)$。

```c++
#include <bits/stdc++.h>
typedef long long LL;

const int N = 5e3+50;

int main() {
    std::ios::sync_with_stdio(false);
    int n, m;
	std::cin >> n >> m;
	LL a[N];
    for (int i = 1; i <= n; i++)
        std::cin >> a[i];
        
    LL f[N] = {0}, g[N] = {0};
    for (int i = 1; i <= n; i++) {
        for (int j = m; j >= 1; j--) {
            g[j] = std::max(g[j], f[j-1]) + a[i];
            f[j] = std::max(g[j], f[j]);
        }
    }
    std::cout << f[m] << std::endl;
    return 0;
}
```

### 算法4

贪心，复杂度$O(n\log n)$。

首先，可以发现，对于一段连续的正数或负数，要么全部选，要么全部不选。

所以，我们可以把连续的一段正数或负数缩成一个数。那么序列就变成了正负交替的。以下说明都针对缩完以后的序列。

设序列中正数的个数为$cnt$，则对于$m\ge cnt$的情况，最优解肯定是取所有正数。

考虑$m=cnt-1$的情况，此时我们需要从$m=cnt$的情况减少一段。

有两种方法：一种是舍弃一个正数，另一种是取一个负数，使两边的正数合并成一段。

怎么取最优？若舍弃正数$a$，会损失$a$的价值。若取负数$a$，会损失$-a$的价值。

统一起来，就是若舍弃/取走数字$a$，会损失$\mid a\mid$的价值。这样，我们只要找绝对值最小的数舍弃/取走即可。

舍弃/取走一个数后，序列会变成什么样呢？

事实上，舍弃/取走一个数$a_i$，相当于与两边的数合并，合并完的值是$a_{i-1}+a_i+a_{i+1}$。

例如$1,-2,3,-4,5$，若舍弃$3$，则序列变成$1,-3,5$；若取走$-4$，则序列变成$1,-2,4$。

可以发现，若取绝对值最小的数，合并完以后的序列还是正负交替。于是我们可以用刚才的方法继续获得$m=cnt-2,cnt-3,\dots$的答案，直至$m$达到题目的要求。

取绝对值最小的数，可以用优先队列做。合并节点可以使用链表。答案为最后合并完的序列的所有正数之和。

复杂度：合并$O(n)$次，每次$O(\log n)$，总复杂度$O(n\log n)$。

此算法在加强版中期望得分90，常数卡得好可能可以AC。

```c++
#include <bits/stdc++.h>
typedef long long LL;

const int N = 1e6+50;

struct Data {
    LL val;
    int pos, tim;
    
    bool operator < (const Data &t) const {
        return val > t.val;
    }
};

int pl[N], pr[N];
int tim[N] = {0};

void del(int u) {
    if (u == 0) return;
    pr[pl[u]] = pr[u];
    pl[pr[u]] = pl[u];
    tim[u] = -1;
}

int main() {
    std::ios::sync_with_stdio(false);
    int n, m;
    std::cin >> n >> m;
    
    static LL a[N] = {0};
    int top = 0;
    for (int i = 1; i <= n; i++) {
        LL r; std::cin >> r;
        if (r == 0) continue;
        if (top == 0) {
        	if (r > 0) a[++top] = r;
        	continue;
        }
        if (a[top] > 0 == r > 0) a[top] += r;
        else a[++top] = r;
    }
    if (top > 0 && a[top] < 0) top--;
    
    for (int i = 0; i <= top; i++) {
        pl[i] = i == 0 ? top : i - 1;
        pr[i] = i == top ? 0 : i + 1;
    }
    
    std::priority_queue<Data> q;
    for (int i = 1; i <= top; i++) {
        q.push({ std::abs(a[i]), i, 0 });
    }
    
    for (int cnt = top + 1 >> 1; cnt > m; cnt--) {
        Data d = q.top(); q.pop();
        while (tim[d.pos] != d.tim) {
            d = q.top(); q.pop();
        }
        int u = d.pos, l = pl[u], r = pr[u];
        a[u] += a[l] + a[r];
        if (l != 0 && r != 0)
            q.push({ std::abs(a[u]), u, ++tim[u] });
        else del(u);
        del(l); del(r);
    }
    
    LL ans = 0;
    for (int i = pr[0]; i != 0; i = pr[i])
        if (a[i] > 0) ans += a[i];
    std::cout << ans << std::endl;
    return 0;
}
```

### 算法5

优化算法4，时间复杂度$O(n)$。

**算法步骤：**

假设当前还需要合并$k$个数。

先找出剩下的数中绝对值第$k$小的数和第$3k$小的数（若多个数绝对值相同则比较编号），记为$mid1$和$mid2$。把$\mid a\mid \le mid1$的数全部合并，把$\mid a\mid>mid2$的数全部忽略（不再参与合并）。

重复以上操作，直到剩下$m$个正数为止。

**结论1：每轮合并的个数一定$\le k$。**证明如下：

设当前合并$a_{i-1},a_i,a_{i+1}$，则合并完的数$b=a_{i-1}+a_i+a_{i+1}$。

若合并次数$>k$，则肯定会出现“三个数中只有一个需要合并的数，合并完又产生了一个需要合并的数”这种情况。也就是$|a_i|\le mid1$，$|a_{i-1}|,|a_{i+1}|>mid1$，且$|b|<=mid1$的情况。

然而这种情况不可能出现。由数学方法可以推知，$|b|=|a_{i-1}|+|a_{i+1}|-|a_i|>mid1$。

这样就保证了算法的正确性，不会合并过头。

**结论2：每轮合并的个数一定$\ge\frac{1}{3}k$。**证明如下：

合并次数最少的情况，就是$a_{i-1},a_i,a_{i+1}$都需要合并，却只合并了一个$a_i$。这样的话，每三个需要合并的数中，至少可以成功合并一个，即合并个数$\ge\frac{1}{3}k$

**结论3：$|a|>mid2$的数可以忽略。**证明如下：

因为根据结论2，在最小的$3k$个数中至少可以合并$k$个数。所以第$3k$个数以后的数都不会被合并。

**复杂度证明：**

设当前还需要合并$k$个数。

根据结论3，我们只留下$3k$个数，所以每一轮合并的复杂度为$O(k)$。

根据结论2，每一轮合并，都会使$k$缩小到$\frac{2}{3}k$。

那么，总复杂度为$n+\frac{2}{3}n+(\frac{2}{3})^2n+\dots$，根据等比数列公式，复杂度为$O(n)$，期望得分100。

```c++
#include <bits/stdc++.h>
typedef long long LL;
typedef std::pair<LL, int> Data;

const int N = 1e6+50;

int n, m; LL a[N];
int L[N], R[N]; bool del[N];
int L2[N], R2[N]; bool del2[N];
int rem;
Data t[N], mx;
std::queue<LL> q; bool inQue[N];

void Init() {
	std::cin >> n >> m;
    int top = 0;
    for (int i = 1; i <= n; i++) {
        LL r; std::cin >> r;
        if (!r) continue;
        if (!top && r < 0) continue;
        if (top && a[top] > 0 == r > 0) a[top] += r;
        else a[++top] = r;
    }
    if (top && a[top] < 0) top--;
    for (int i = 0; i <= top; i++) {
        R[i] = R2[i] = (i + 1) % (top + 1);
        L[i] = L2[i] = (i + top) % (top + 1);
    }
    rem = top;
}

void AddQue(int u) {
	if (u && !inQue[u] && Data(std::abs(a[u]), u) <= mx)
		q.push(u), inQue[u] = true;
}

void Del2(int u) {
	if (!u || del2[u]) return;
	int l = L2[u], r = R2[u];
	R2[l] = r; L2[r] = l;
	del2[u] = true;
}

void Del(int u) {
	if (!u || del[u]) return;
	rem--;
	int l = L[u], r = R[u];
	R[l] = r; L[r] = l;
	del[u] = true;
	Del2(u);
}

void Merge(int u) {
	if (del[u]) return;
	int l = L[u], r = R[u];
	if (l && std::abs(a[l]) < std::abs(a[u])) return;
	if (r && std::abs(a[r]) < std::abs(a[u])) return;
	Del(l); Del(r); a[u] += a[l] + a[r];
	l && r ? AddQue(u) : Del(u);
	AddQue(L[u]); AddQue(R[u]);
}

void Work() {
	while (true) {
		n = 0;
		for (int i = R2[0]; i; i = R2[i])
			if (!del2[i]) t[++n] = Data(std::abs(a[i]), i);
		if (rem <= m * 2 - 1) break;
		int mid = (rem - (m * 2 - 1)) / 2;
		nth_element(t + 1, t + std::min(mid, n), t + n + 1);
		mx = t[std::min(mid, n)];
		nth_element(t + 1, t + std::min(mid*3, n), t + n + 1);
		Data mx2 = t[std::min(mid*3, n)];
		for (int i = R2[0]; i; i = R2[i]) {
			Data cur(std::abs(a[i]), i);
			if (cur > mx2) Del2(i);
			else AddQue(i);
		}
		while (!q.empty()){
			int u = q.front(); q.pop(); inQue[u] = false;
			Merge(u);
		}
	}
	LL ans = 0;
	for (int i = R[0]; i; i = R[i])
		if (a[i] > 0) ans += a[i];
	std::cout << ans << std::endl;
}

int main() {
	std::ios::sync_with_stdio(false);
	Init(); Work();
    return 0;
}

```

---

## 作者：猪脑子 (赞：9)

题目背景

隔壁的新初一电脑班刚考过一场试，又到了BlingBling的裁员时间，老师把这项工作交给了ZZY来进行。而ZZY最近忙着刷题，就把这重要的任务交（tui）给了你。

题目描述

ZZY有独特的裁员技巧：每个同学都有一个考试得分ai（-1000<=ai<=1000），在n个同学（n<=500）中选出不大于k段（k<=n）相邻的同学留下，裁掉未被选中的同学，使剩下同学的得分和最大。要特别注意的是，这次考试答错要扣分【不要问我为什么】，所以得分有可能为负。

输入输出格式

输入格式：
第一行为n，k，第二行为第1~n位同学的得分。

输出格式：
一个数s，为最大得分和。


------------


n<=500,所以考虑DP.
用 DP[i][j][opt]表示前i个人，选出j段，可以取得的最大得分和
当opt==1时，表示选第i个人；
当opt==0时，表示不选第i个人。
那么，显然，

	DP[i][j][1]=max(DP[i-1][j][1],DP[i-1][j-1][0])+a[i];//
    DP[i][j][0]=max(DP[i-1][j][0],DP[i-1][j][0]);//
    
边界条件：

	DP[0][j][0]=DP[i][0][0]=0//设为全局变量，不用写



------------
Code:
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
inline void re(int &a)
{
	a=0;bool flag=false;
	char c=getchar();
	while(c<'0'||c>'9'){
		flag=c=='-';
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		a=(a<<1)+(a<<3)+(c^'0');
		c=getchar();
	}
	if(flag)a=-a;
	return ;
}
int dp[510][510][2];
int a[510];
int ans;
int n,k;
int main()
{
	re(n);re(k);
	for(int i=1;i<=n;i++)
	{
		re(a[i]);
		for(int j=1;j<=k;j++)
			dp[i][j][1]=max(dp[i-1][j][1],dp[i-1][j-1][0])+a[i],
			dp[i][j][0]=max(dp[i-1][j][1],dp[i-1][j][0]);//DP
	}
	for(int i=1;i<=k;i++)
		ans=max(ans,max(dp[n][i][1],dp[n][i][0]));//由于只是至少选k个人，因此取max
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Jairon314 (赞：7)

$$ \textbf{\huge P2389[洛谷原创]} $$
$$ \textbf{\LARGE Computer class layoffs} $$
$$ \text{\large ————Jair} $$

$$ \text{\small Warning: This problem's solving belongs to} $$
$$ \textbf {\huge $ \mathbb{TOP\;SECRET} $} $$
$$ \text {\small Unauthorized personnel are prohibited from visiting} $$
$$ \text {\small Perpetrators will be monitored, located, and dealt with} $$

$$ PAY\;ATTENTION: $$
$$ \text {\small cspJ\;踩线1$=$的蒟蒻没有想出十分优秀的超低复杂度解法} $$

$$ \large· $$
$$ \large· $$
$$ \large· $$

$$ \large \frak Forward $$
--------
今天是2021年的第一天（倒霉的2020年终于过去了）。随机刷题一看：蓝题！再一看：怎么这么水？爆切！

于是5分钟推出来dp状态转移方程——

$$ $$

$$f[i][j][0]=max(f[i-1][j][1],f[i-1][j][0]);$$
$$f[i][j][1]=max(f[i-1][j][1],f[i-1][j-1][0])+scores[i];$$

$$ $$

设$f[i][j][1/0]$--->前$i$个同学分了$j$组，第$i$个同学留下（$1$）或不留（$0$）.

那么，为什么第二行$f[i-1][j-1][0]$中是$j-1$ 呢？原因很简单，如果你选择留下第$i$个学生，且不选择第$i-1$名学生，则所分的组数就会变化

$$ \large \frak CodeTime$$
--------
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

#define maxn 10000010
#define int long long

int n,k,scores[maxn];
signed G[1010][1010][2];

signed main(){
	memset(G,-0x3f3f,sizeof G);//有可能为负数
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=n;i++){
		scanf("%lld",&scores[i]);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=k;j++){
			G[i][j][0]=max(0,max(G[i-1][j][0],G[i-1][j][1]));//因为有可能是负数，所以和零取max
			G[i][j][1]=max(0,max(G[i-1][j][1],G[i-1][j-1][0]))+scores[i];//因为有可能是负数，所以和零取max
		} 
	}
	printf("%lld",max(G[n][k][0],G[n][k][1]));//输出最后一个选或不选中最大的
	return 0;
}
```

$$ \large \frak {in\;the\;end}$$
--------
祝大家元旦快乐，万事如意，在2021年绽放光彩！~~我相信我一定会的~~

---

## 作者：Seg_Tree (赞：6)

看到题解里有人说这题数据略水感觉有点慌，不过回头看看自己代码好像也还行~~那个加强版也点不进去啊...~~

好吧，对着题面所给条件与数据范围仔细思考一下，我们可以~~轻易地~~看出这是道dp.因此,我们可以：

**用dp[i][j][0/1]表示在选第i个数时,第j段已开始用,第i个数不选/选,的最高得分**

因此，我们可以构建如下状态转移方程：

$$dp[i][j][1]=max(dp[i-1][j-1][0]+a[i],dp[i-1][j][1]+a[i]);$$

以及

$$dp[i][j][0]=max(dp[i-1][j][0],dp[i-1][j][1]);$$

此外需要注意的是，最后ans还得全部跑一边，因为有可能k个区间还没用完.
```cpp
#include<iostream>
using namespace std;
int a[501],dp[501][501][2];
//dp[i][j][0/1]表示在选第i个数时,第j段已开始用,第i个数不选/选,的最高得分 
int main(){
	int n,k;
	cin>>n>>k;
	for(int i=1; i<=n; i++)cin>>a[i];
	for(int i=1; i<=n; i++){
		for(int j=1; j<=i&&j<=k; j++){
			dp[i][j][1]=max(dp[i-1][j-1][0]+a[i],dp[i-1][j][1]+a[i]);
			//前者表示上个人没选,这个人选(即开启了一个新的区间)
			//后者表示上个人选了,这个人继续选(即延续这个区间)
			dp[i][j][0]=max(dp[i-1][j][0],dp[i-1][j][1]);
			//前者表示上个人没选,这个人也不选(即延续空档)
			//后者表示上个人选了,这个人却不选(即打断这个区间); 
		}
	}
	int ans=0;
	for(int j=0; j<=k; j++){
		ans=max(ans,dp[n][j][1]);
		ans=max(ans,dp[n][j][0]);
	} 
	cout<<ans;
	return 0;
}
```
要是加了滚动数组，还可以达到时间O（nk），空间O（k）的了

---

## 作者：Notshgiook (赞：4)

## 贪心的做法！
从浩瀚无垠的题解大库例翻来覆去，怎么几乎全部都是dp的题解！

来这里来一篇贪心题解！

~~至于为什么用贪心，那当然是因为dp本人不会啊，呜呜呜~~~

首先初步分析一下题目数据的性质，输入的数据一定是正数，负数，0。

我们先抛开数据是0的情况不看，因为对于这个0，我们选ta或者不选ta都无伤大雅！！似乎是这个样的（确实是这个样的）

那么把所以的0扔去一边，留下的数据一定是一段正数，一段负数！

那么好，如果想要使答案优，那么对于每段正数或负数，我们最好同时选上或者同时不选上！

那么我们便可以把连续的正数段和连续的负数段合起来，构成一段新数据！

并且这组数据非常有特点，肯定是一个正，一个负！连续不断！

**对这里我们可以有一波小操作，** 就是第一个区间和最后一个区间，如果是负区间，那么肯定不会被选入（很显然的证明），那么在统计区间和的数组中可以去掉这两个区间！

我们可以统计一下正数段的个数cnt。

如果用了上面那波操作，那么cnt=（统计进答案的区间总数+1）>>1;

**如果cnt<=k,对于最优答案我们只需要把所以的正数段加起来便是最优解**

可是！！一个新问题来了，如果cnt>k又该怎么办呢？？

这时候的我们只有两种操作：

**操作一：去掉一段正数区间，使总答案减少~**

**操作二：加上一段负区间，使两个正区间合并起来。**

其实对于操作一，我们可以认为是把少选一个正区间，把相邻两个负区间合并起来

其实无论我们选择哪种操作，对答案的影响就是这段区间总和的绝对值~ 

那么如果我们开一个优先队列并且把所以的区间的绝对值存进去，每次去取最小的来合并区间不就可以了吗！

**合并区间怎么办呢，我们在存区间绝对值的时候维护上一个区间位置，每次我们从优先队列里取出队顶，如果这个队顶已经被合并到别的地方了，就继续取出队顶，直至这个队顶保证之前没有被合并，并且我们把这个位置的左右位置的值合并到这个位置，并且把左右位置打上标记（意思就是这俩区间已经消失了），再把这个位置的新值压入优先队列！不断往复的操作！**

那么左右位置应该怎么处理呢，用一下链表的想法，合并了以后就去更新位置的左右，和左的左位置的右，以及右的右位置的左！

那么要处理多少次呢，无论是去掉一个正区间或者加上一个负区间，我们的正区间数量都会减一，那么只需要处理到正区间个数恰好等于k便是最优解！

**总结一下，如果一开始的正区间数量cnt<=k,直接输出所以正区间的和；否则，通过cnt-k次合并操作，将正区间数量变为k，输出所以正区间和！**

------------
### 来模拟一组数据

好，那么这里我们来一组数据便于理解 ~~（斜眼笑）~~

![](https://cdn.luogu.com.cn/upload/pic/69623.png)

我们不妨先把这一长串数据合并一下

得到： 25 ，-18，12，-3，5

这样一组数据，显然这里有三个正区间，那么我们开始进行操作：

显然这里-3是绝对值最小的，那么我们俩进行合并

![](https://cdn.luogu.com.cn/upload/pic/69633.png)

显然这时，正区间数cnt=k，结束操作，并把正区间输出！

答案为39！

------------

### cpp：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
#define maxn 550

struct Node
{
	int val,pos;
	bool operator < (const Node &h) const
	{
		return val>h.val;
	}
};

int L[maxn],R[maxn];
int a[maxn],tot;
int n,k,t,cnt,ans;
bool vis[maxn];
priority_queue <Node> q;

int main()
{
	scanf("%d%d",&n,&k);
	for(register int i=1;i<=n;i++)
	{
		scanf("%d",&t);
		if(t==0) continue;
		if(t>0&&tot==0)
		{
			a[++tot]=t;
			continue;
		}
		if(a[tot]*t>0) a[tot]+=t;
		else a[++tot]=t;
	}
	if(a[tot]<0) tot--;
	for(register int i=0;i<=tot;i++)
	{
		L[i]=i-1;
		R[i]=i+1;
	}
	for(register int i=1;i<=tot;i++) q.push((Node){abs(a[i]),i});
	cnt=((tot+1)>>1)-k;
	while(cnt>0)
	{
		int u=q.top().pos;q.pop();
		while(vis[u])
		{
			u=q.top().pos;
			q.pop();
		}
		int l=L[u],r=R[u];
		a[u]=a[u]+a[l]+a[r];
		if(l!=0) vis[l]=true;
		if(r!=tot+1) vis[r]=true;
		
		L[u]=L[l];
		R[u]=R[r];
		R[L[l]]=u;
		L[R[r]]=u;
		q.push((Node){abs(a[u]),u});
		cnt--;
	}
	for(register int i=1;i<=tot;i++) if(!vis[i]&&a[i]>0) ans+=a[i];
	printf("%d",ans);
	return 0;
}
```
## Over!

---

## 作者：mikechu (赞：4)

一天晚上11点了还在刷题

看了这蓝题，觉得今天看完了，晚上想一想，明天写的。

没想到写的飞快。。。。。。

调试不调而过。。。。。。

一遍AC。。。。。。

而我并不是神犇。。。。。。

——————————我是美丽的分割线————————————

推荐先看一下[P2642](https://www.luogu.org/problemnew/show/P2642)

和那题几乎一样

```cpp
dp[i][j][1] 表示前i个分j段,第i个选中的最大值。
dp[i][j][0] 表示前i个分j段,第i个不选的最大值。

转移方程：

dp[i][j][0] = max(dp[i-1][j][1],dp[i-1][j][0]);//如果我不选，那我前一个可以选也可以不选。
dp[i][j][1] = max(dp[i-1][j][1],dp[i-1][j-1][0]) + a[i];//如果我选，我要么连续上一段，要么新开一段。

```

好简单的样子。。。。。。

```
#include<bits/stdc++.h>
using namespace std;
int dp[510][510][2],i,j,n,k,a[510];
int main(){
	cin >> n >> k;
	for(i=1;i<=n;i++){
		cin >> a[i];
		for(j=1;j<=k;j++){
			dp[i][j][0] = max(dp[i-1][j][1],dp[i-1][j][0]);
			dp[i][j][1] = max(dp[i-1][j][1],dp[i-1][j-1][0]) + a[i];
		}
	}
	cout << max(dp[n][k][1],dp[n][k][0]);
}
```
我得承认，我要是没做过2642还真不一定能想到。

而且，我觉得评级到不了蓝题。

第一篇蓝题题解，希望管理员能让过。

---

## 作者：CDFLS_mao_zx (赞：3)

我们其实可以先抽象一下这道题：
 
要让留下来的人的分数和最大，就是求k个区间的最大和.


------------


想想刚学dp时的连续区间最大和问题，不就是k=1是的特殊情况吗？  
参考它的做法，我们设dp[i][j]表示以i结束第j段的最大和。

------------
考虑状态的转移     ：   
显然i应该为阶段   
枚举j   
接下来考虑从前面哪一个阶段转移过来   
再来一层枚举   
此时再考虑从哪里开始本阶段  
最后的式子是：   
dp[i][j]=max(dp[i][j],dp[k][j-1]+sum[l][i])   
这样的算法时间复杂度为O(n^4)  
无法通过n<=500   
考虑优化.  
（敲黑板！！！）  
我们可以O(n^2)地处理出l~i以i结束的区间最大和  
（方法参考文首）   
于是我们就可已将dp优化为O（n^3）了  
可以通过本题   
同理，枚举前一阶段的过程也可以使用线段树优化为log（n）         
(有大佬有O（n）的算法，可惜我不会。。。)   
留给大家思考   （ _懒_ ）  
最后附上AC（看完）代码   

```cpp
#include<bits/stdc++.h>
using namespace std;
int i,j,k,m,n,s,t,dp[501][501],a[501],sum[501],ans[501][501],b[501][501];
int main()
{
	cin>>n>>m;
	for(i=1;i<=m;i++)
	cin>>a[i];
	for(i=0;i<=n;i++)
	for(j=i;j<=n;j++)
	if(b[i][j-1]>0)
	b[i][j]=a[j]+b[i][j-1];//处理l到i以i结束区间最大值，原理参考 p1115
	else
	b[i][j]=a[j];
	for(i=1;i<=n;i++)//枚举状态 
	for(j=1;j<=max(i,m);j++)//我的代码强制要求区间长大于1，所以。。。 
	for(k=j-1;k<i;k++)//同上 
	dp[i][j]=max(dp[i][j],dp[k][j-1]+b[k+1][i]);//转移式子 
	int tt=0;
	for(i=0;i<=n;i++)
	for(j=0;j<=m;j++)
	tt=max(tt,dp[i][j]);//此题很坑，区间长度可以为0，所以来一波最大值 
	cout<<tt;
	return 0;
}
```
为防止大家抄题解，以上代码肯定WA，有一个小错，但关键部分没有问题    
本人第一次写题解，若有解释不清楚或错误的地方敬请指出  
谢谢










---

## 作者：mzq667 (赞：2)

一个好写、好想的$O(n^2)$算法。

设$F[i][j][0/1]$为当前选到第$i$个数，已有$j$个分组，$0$与$1$代表第$i$个数一定选或一定不选。

那么转移方程为:

$F[i][j][0] = max(F[i - 1][j][0], F[i - 1][j][1])$

（由“相同组数时上一个数选或不选”两种情况中最大值转移而来）

$F[i][j][1] = max(F[i - 1][j][1], F[i - 1][j - 1][0]) + a[i]$(其中$a[i]$为第$i$个人考试得分)

（由“相同组数时上一个数选”与“组数减一时上个数不选”（$j - 1$是因为上个数不选的话组数要加一）两种情况中中最大值，再加$a[i]$转移而来）

最后在$F[n][j][0/1](1 \leqslant j \leqslant k)$中找最大值即可。

下附代码:
```cpp
#include <algorithm>
#include <cstdio>
const int MAXN = 501;
int n, k, tmp, ans;
int a[MAXN], f[MAXN][MAXN][2];
int main() {
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; ++i)
        scanf("%d", &a[i]);
    for (int i = 1 ; i <= n; ++i)
        for (int j = std::min(i, k); j >= 1; --j) {
            f[i][j][0] = std::max(f[i - 1][j][0], f[i - 1][j][1]);
            f[i][j][1] = std::max(f[i - 1][j][1], f[i - 1][j - 1][0]) + a[i];
        }
    for (int i = 1; i <= k; ++i)
        ans = std::max(ans, std::max(f[n][i][1], f[n][i][0]));
    printf("%d\n", ans);
    return 0;
}
```
憋走！再有，把$F$数组压成一维:
```cpp
#include <algorithm>
#include <cstdio>
const int MAXN = 501;
int n, k, tmp, ans;
int a[MAXN], f[MAXN][2];
int main() {
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; ++i)
        scanf("%d", &a[i]);
    for (int i = 1 ; i <= n; ++i)
        for (int j = std::min(i, k); j >= 1; --j) {
            f[j][0] = std::max(f[j][0], f[j][1]);
            f[j][1] = std::max(f[j][1], f[j - 1][0]) + a[i];
        }
    for (int i = 1; i <= k; ++i)
        ans = std::max(ans, std::max(f[i][1], f[i][0]));
    printf("%d\n", ans);
    return 0;
}
```
谢谢审读。
（PS：感谢楼下DDOSvoid大佬思路）

---

## 作者：DDOSvoid (赞：1)

其实这题好像可以 O(nlogn)，反正我不会。先考虑一个 dp 方程， f\[i]\[j] 表示前 i 个同学选了 j 段，考虑转移，f\[i]\[j] = max(f\[k]\[j - 1] + mis\[k + 1]\[i]) k = 0 ~ i - 1，其中 mis是最大子段和，~~显然~~可以预处理，用线段树什么的==。然后复杂度就是 $O(n^3)$ 可以过。~~虽然我感觉 500 过不了的~~

```cpp
#include<iostream>
#include<cstdio>
#define maxn 510
#define INF 100000000
using namespace std;

int n, k, f[maxn][maxn], a[maxn], mis[maxn][maxn];

// 忽略这个写的巨丑的线段树 
#define lc i << 1
#define rc i << 1 | 1
struct node{
	int l,r,sum_pre,sum_suf,sum,mis;
}tree[maxn<<2];
inline void _update(int i){
	tree[i].sum=tree[lc].sum+tree[rc].sum;
	tree[i].sum_pre=max(tree[lc].sum_pre,tree[rc].sum_pre+tree[lc].sum);
	tree[i].sum_suf=max(tree[rc].sum_suf,tree[lc].sum_suf+tree[rc].sum);
	tree[i].mis=max(tree[lc].sum_suf+tree[rc].sum_pre,max(tree[lc].mis,tree[rc].mis));
}
void build(int i,int l,int r){
	tree[i].l=l;tree[i].r=r;
	if(l==r){
		tree[i].sum=tree[i].sum_pre=tree[i].sum_suf=tree[i].mis=a[l];
		return ;
	}
	int m=l+r>>1;
	build(lc,l,m);
	build(rc,m+1,r);
	_update(i);
}
node query(int i,int l,int r){
	if(tree[i].l>r || tree[i].r<l) return (node){0,0,-INF,-INF,0,-INF};
	if(tree[i].l>=l && tree[i].r<=r) return tree[i];
	node tmp1=query(lc,l,r),tmp2=query(rc,l,r),tmp;
	tmp.mis=max(tmp1.sum_suf+tmp2.sum_pre,max(tmp1.mis,tmp2.mis));
	tmp.sum=tmp1.sum+tmp2.sum;
	tmp.sum_pre=max(tmp1.sum_pre,tmp2.sum_pre+tmp1.sum);
	tmp.sum_suf=max(tmp2.sum_suf,tmp1.sum_suf+tmp2.sum);
	return tmp;
}

int main(){
	scanf("%d%d", &n, &k);
	for(int i = 1; i <= n; ++i) scanf("%d", &a[i]);
	build(1, 1, n);
	for(int i = 1; i <= n; ++i)
		for(int j = i; j <= n; ++j)
			mis[i][j] = query(1, i, j).mis;
	for(int i = 1; i <= n; ++i)
		for(int j = 1; j <= min(i, k); ++j)
			for(int k = 0; k < i; ++k)
				f[i][j] = max(f[i][j], f[k][j - 1] + mis[k + 1][i]);
	int ans = 0;
	for(int i = 1; i <= k; ++i) ans = max(ans, f[n][i]);
	cout << ans;
	return 0;
}
```
	

---

## 作者：Victorique (赞：0)

wow~，我居然是第一个题解。

话说这个题看上去好像很简单，实际上还是有很多需要注意的地方。

首先，这个题的数据比较小。。所以可以直接开三维暴力dp数组，貌似可以勉强过去，但是稍微再大一点（大个五六十）这个题都直接爆炸。所以关键在于压维。我们用ans来储存相当于f[k][i][j-1]，这样就把本来三维的数组压到了二维。（至于具体原因还希望大家自己去想，毕竟这个题没了这个地方就很水了），下面上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
using namespace std;
long long f[501][10001],a[100001],s[100001],ans,maxx[501],n,m,mx;
int main() 
{
    cin>>n>>m;
    for(int i=1; i<=n; i++)
        cin>>a[i];
    for(int i=1; i<=n; i++)//貌似可以减少一些用时。。
        s[i]=s[i-1]+a[i];
    for(int k=1;k<=m;k++)
    {
        ans=0;
        for(int i=1; i<=k; i++) 
        {
            ans=s[i];
            maxx[k]=ans;
            for(int j=i+1; j<=n; j++) 
            {
                ans=max(f[k][j],ans)+a[j];//f[i][j-1];
                f[k][j]=maxx[k];
                maxx[k]=max(ans,maxx[k]);
            }
        }
    }
    for(int i=1;i<=m;i++)
    {
        mx=max(mx,maxx[i]);//一开始当成必须取k组，结果wa了一半，后来才明白可以不都去掉。。。。。
    }
    cout<<mx;
}
```

---


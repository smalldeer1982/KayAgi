# [ROIR 2023] 扫地机器人 (Day 1)

## 题目背景

翻译自 [ROIR 2023 D1T3](https://neerc.ifmo.ru/school/archive/2022-2023/ru-olymp-regional-2023-day1.pdf)。

一个扫地机器人正在清洁一个二维坐标平面。扫地机器人是一个边长 $k\times k$ 的正方形，边与坐标轴平行。初始时，扫地机器人左下角位于 $(0,0)$，右上角位于 $(k,k)$。

## 题目描述

给定一个由 $n$ 个移动操作组成的序列，第 $i$ 个移动操作由方向 $d_i$（`N` 表示向上，增加 $y$ 坐标；`E` 表示向右，增加 $x$ 坐标；`W` 表示向左，减小 $x$ 坐标；`S` 表示向下，减小 $y$ 坐标）和距离 $a_i$（机器人移动的距离）组成。根据给定的机器人移动操作，计算清扫的总面积（被机器人覆盖过的点就算被清扫过的点）。

## 说明/提示

样例解释：下图是两个样例中机器人的移动情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/v8w6xnzb.png)

本题使用捆绑测试。

![](https://cdn.luogu.com.cn/upload/image_hosting/wwg2fmu1.png)

对于 $100\%$ 数据，$1 \le k \le 10^4$，$1 \le n \le 10^5$，$1 \le a_i \le 10^9$。

## 样例 #1

### 输入

```
1 5
E 2
N 2
W 4
S 4
E 4```

### 输出

```
17```

## 样例 #2

### 输入

```
3 4
W 2
N 1
W 1
N 2```

### 输出

```
27```

# 题解

## 作者：spfa_ (赞：7)

[P10096 [ROIR 2023 Day 1] 扫地机器人
](https://www.luogu.com.cn/problem/P10096)

### 题目分析

注意到要求路径所覆盖的面积，我们可以考虑将路径分解为若干个矩形的面积并。

记扫地机器人的左下角为 $(x,y)$。

- `N`，向上：矩形的左下角为 $(x, y)$，右上角为 $(x+k, y+k+d)$

- `S`，向下：矩形的左下角为 $(x, y-d)$，右上角为 $(x+k, y+k)$

- `W`，向左：矩形的左下角为 $(x-d, y)$，右上角为 $(x+k, y+k)$

- `E`，向右：矩形的左下角为 $(x, y)$，右上角为 $(x+k+d, y+k)$

接下来就是矩形面积并了，运用扫描线即可，不会的转[P5490](https://www.luogu.com.cn/problem/P5490)。

code:

```cpp
#include <bits/stdc++.h>
#define int long long
#define ls p<<1
#define rs p<<1|1
#define fi first
#define se second
#define pb push_back
#define mk make_pair
#define ll long long
#define space putchar(' ')
#define enter putchar('\n')
using namespace std;

typedef pair <int, int> pii;
typedef vector <int> vi;

template <typename T> inline T rd(T& x) {
    x = 0; int f = 1;
	char c = getchar();
    while (!isdigit(c)) f = c == '-' ? -1 : f, c = getchar();
    while (isdigit(c)) x = (x<<3)+(x<<1)+(c^48), c = getchar();
    return x *= f;
}

template <typename T> inline void write(T x) {
	if (x < 0) x = -x, putchar('-');
	if (x > 9) write(x/10);
	putchar('0'+x%10);
}

const int N = 1e5+5;
struct node { int x, l, r, k; } e[N<<1];
int n, k, x, y, tot, ans, b[N<<1], len[N<<3], cnt[N<<3];

void add(int x1, int y1, int x2, int y2) {
	b[tot+1] = x1, b[tot+2] = x2;
	e[tot+1] = {y1, x1, x2, 1}, e[tot+2] = {y2, x1, x2, -1};
	tot += 2;
}

bool cmp(node a, node b) { return a.x < b.x; }

void pushup(int p, int l, int r) {
	if (cnt[p]) len[p] = b[r+1]-b[l];
	else len[p] = len[ls]+len[rs];
}

void modify(int p, int l, int r, int ql, int qr, int x) {
	if (qr < l || r < ql) return;
	if (ql <= l && r <= qr) return cnt[p] += x, pushup(p, l, r), void();
	int mid = l+r>>1;
	modify(ls, l, mid, ql, qr, x), modify(rs, mid+1, r, ql, qr, x);
	pushup(p, l, r);
}

signed main() {
	rd(k), rd(n);
	for (int i = 1; i <= n; ++i) {
		char c; cin >> c; int d = rd(d);
		if (c == 'N') add(x, y, x+k, y+k+d), y += d;
		else if (c == 'S') add(x, y-d, x+k, y+k), y -= d;
		else if (c == 'W') add(x-d, y, x+k, y+k), x -= d;
		else add(x, y, x+k+d, y+k), x += d;
	}
	n <<= 1;
	sort(e+1, e+n+1, cmp); sort(b+1, b+n+1); tot = unique(b+1, b+n+1)-b-1;
	for (int i = 1; i < n; ++i) {
		e[i].l = lower_bound(b+1, b+tot+1, e[i].l)-b;
		e[i].r = lower_bound(b+1, b+tot+1, e[i].r)-b;
		modify(1, 1, tot, e[i].l, e[i].r-1, e[i].k);
		ans += 1ll*len[1]*(e[i+1].x-e[i].x);
	}
	cout << ans;
	return 0;
}
```

---

## 作者：FFTotoro (赞：5)

比较简单的一个扫描线题。

对于每次指令分开考虑，它扫过的一个矩形的四个坐标是好求的。以 `N` 指令为例，令 $x_0,y_0$ 为原来机器人的左下角坐标，$d$ 为移动距离，那么扫过的矩形的两个 $x$ 坐标分别为 $x,x+k$，两个 $y$ 坐标分别为 $y,y+d+k$；其他指令可以类似地自行推导。

最后对于所有指令产生的矩形求面积并即可。

示例代码（使用了本人编写的模板库中的扫描线算法）：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace IAOI_lib{
  class atlantis{
    typedef pair<int,int> pii;
    typedef tuple<int,int,int,int> tpi;
    private:
      struct Line{
        int l,r,h,s;
        bool operator <(const Line &x)const{
          return h<x.h;
        }
      };
      int n;
      vector<Line> L;
      vector<pii> B;
      vector<int> X,C,S;
      void build(int u,int l,int r){
        if(B[u]=make_pair(l,r);l==r)return;
        int m=l+r>>1;
        build(u<<1,l,m),build(u<<1|1,m+1,r);
        pushup(u);
      };
      void pushup(int u){
        if(C[u])S[u]=X[B[u].second+1]-X[B[u].first];
        else S[u]=S[u<<1]+S[u<<1|1];
      }
      void update(int u,int l,int r,int c){
        if(X[B[u].second+1]<=l||r<=X[B[u].first])return;
        if(l<=X[B[u].first]&&X[B[u].second+1]<=r)C[u]+=c;
        else update(u<<1,l,r,c),update(u<<1|1,l,r,c);
        pushup(u);
      }
      int all_prod(){return S[1];}
    public:
      int areas_union(vector<tpi> &a){
        X.resize(a.size()<<1),L.resize(a.size()<<1);
        for(int i=0;i<a.size();i++){
          auto &[xa,ya,xb,yb]=a[i];
          if(xa>xb)swap(xa,xb); if(ya>yb)swap(ya,yb);
          X[i<<1]=xa,X[i<<1|1]=xb;
          L[i<<1]=(Line){xa,xb,ya,1},L[i<<1|1]=(Line){xa,xb,yb,-1};
        }
        sort(L.begin(),L.end(),[](Line x,Line y){return x.h<y.h;});
        sort(X.begin(),X.end()),n=unique(X.begin(),X.end())-X.begin();
        B.resize(n<<2),C.resize(n<<2),S.resize(n<<3),build(1,0,n-2);
        int c=0;
        for(int i=0;i+1<a.size()<<1;i++){
          update(1,L[i].l,L[i].r,L[i].s);
          c+=all_prod()*(L[i+1].h-L[i].h);
        }
        return c;
      }
  };
} // 扫描线模板
main(){
  ios::sync_with_stdio(false);
  int k,n; cin>>k>>n;
  vector<tuple<int,int,int,int> > a;
  int x=0,y=0; a.emplace_back(0,0,k,k);
  while(n--){
    char c; int d; cin>>c>>d;
    switch(c){
      case 'N':a.emplace_back(x,y,x+k,y+d+k),y+=d; break;
      case 'E':a.emplace_back(x,y,x+d+k,y+k),x+=d; break;
      case 'W':a.emplace_back(x-d,y,x+k,y+k),x-=d; break;
      default:a.emplace_back(x,y-d,x+k,y+k),y-=d;
    }
  } // 依次处理每一条指令
  cout<<IAOI_lib::atlantis().areas_union(a)<<endl;
  return 0;
}
```

---

## 作者：Andy2035 (赞：2)

很明显需要用到扫描线。

每一次操作分开考虑，若当前左下角的坐标为 $(x,y)$。
* 操作 `N` 产生的矩形为 $(x,y)$ 到 $(x+k,y+k+d)$。
* 操作 `E` 产生的矩形为 $(x,y)$ 到 $(x+k+d,y+k)$。
* 操作 `W` 产生的矩形为 $(x-d,y)$ 到 $(x+k,y+k)$。
* 操作 `S` 产生的矩形为 $(x,y-d)$ 到 $(x+k,y+k)$。

用扫描线对产生的矩形求面积并即可。

注意数据范围。

代码如下

```
#include<bits/stdc++.h>
#define int long long
//十年OI一场空，不开long long见祖宗
#define ls(x) x<<1
#define rs(x) x<<1|1
using namespace std;
const int N = 1000010;
int X[N];
struct scanline{
    int x1,x2,y;
    int tag;
    bool operator < (const scanline &t){
        return y<t.y;
    }
}L[N];
struct Node{
    int l,r;
    int cnt,len;
}t[N];
void build(int u,int l,int r){
    t[u] = {l,r,0,0};
    if(l == r)return;
    int mid = (l+r)>>1;
    build(ls(u),l,mid),build(rs(u),mid + 1,r);
}

void pushup(int u){
    int l = t[u].l,r = t[u].r;
    if(t[u].cnt)t[u].len = X[r+1] - X[l];
    else t[u].len = t[ls(u)].len + t[rs(u)].len;
}

void modify(int u,int l,int r,int tag){
    if(t[u].l>r||t[u].r<l)return;
    if(t[u].l>=l&&t[u].r<=r){
        t[u].cnt += tag;
        pushup(u);
        return;
    }
    modify(ls(u),l,r,tag),modify(rs(u),l,r,tag);
    pushup(u);
}

int n,k;


signed main(){
    scanf("%lld%lld",&k,&n);
    int x = 0,y = 0;
    for(int i = 1;i<=n;i++){
        char op[2];int l;
        scanf("%s%lld",op,&l);
        if(*op == 'N'){
            int a = x,b = y;
            int c = x+k,d = y+k+l;
            L[i] = {a,c,b,1};
            L[i+n] = {a,c,d,-1};
            X[i] = a,X[i+n] = c;
            y += l;
        }
        else if(*op == 'E'){
            int a = x,b = y;
            int c = x+k+l,d = y+k;
            L[i] = {a,c,b,1};
            L[i+n] = {a,c,d,-1};
            X[i] = a,X[i+n] = c;
            x += l;
        }
        else if(*op == 'W'){
            int a = x-l,b = y;
            int c = x+k,d = y+k;
            L[i] = {a,c,b,1};
            L[i+n] = {a,c,d,-1};
            X[i] = a,X[i+n] = c;
            x-=l;
        }
        else{
            int a = x,b = y-l;
            int c = x+k,d = y+k;
            L[i] = {a,c,b,1};
            L[i+n] = {a,c,d,-1};
            X[i] = a,X[i+n] = c;
            y-=l;
        }
    }
    n <<= 1;
    sort(X+1,X+1+n);
    sort(L+1,L+1+n);
    int s = unique(X+1,X+1+n) - X -1;
    build(1,1,s-1);
    long long ans = 0;
    for(int i = 1;i<n;i++){
        int l = lower_bound(X+1,X+1+s,L[i].x1) - X;
        int r = lower_bound(X+1,X+1+s,L[i].x2) - X;
        modify(1,l,r-1,L[i].tag);
        ans += 1ll*t[1].len*(L[i+1].y - L[i].y);
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：_zuoqingyuan (赞：2)

正好今天学了扫描线，赶紧水一篇蓝题题解。
# 题意简述

[传送门。](https://www.luogu.com.cn/problem/P10096)

有一个 $k\times k$ 大小的正方形在平面直角坐标系中，给定 $n$ 个操作指定其运动，每次给定运动的正方向和运动的距离。求出最后求出正方形所运动覆盖区域的总面积

# 扫描线算法
可以解决平面上部分几何问题，这里主要探讨面积并问题
>>给定 $n$ 个四边平行于坐标轴的矩形，分别给出其左下顶点的坐标和右上顶点的坐标，求他们的面积并。

面积并问题的难点在于矩形可能是重合的，直接计算会有多余的面积计算进去。所以我们要保证不重不漏的计算每一块面积

我们可以把矩形覆盖的总区域分为若干部分，然后用一根直线从左往右扫描整个图形，因为矩形的四条边都平行于坐标轴，所以图形的总面积就是扫描线上与图形相接接触的长度 $\times$ 扫描线走过的距离。

因为扫描线与图形相接触的长度会改变，例如它扫到了某个图形的左边，那我们就要更新扫描线的长度，没更新完一次长度，就走一段距离，继续更新面积，这里放一张 OI-Wiki 上的动图。

![扫描线演示](https://oi-wiki.org/geometry/images/scanning.svg)

虽然动图扫描的方式是从下到上，但扫描的过程是一样的。算法流程就是，把所有矩形的左右两边按照其横坐标排序，然后从左到右扫描图形，中途要经历区间修改，区间查询。

因为在区间并的问题中，一般 $-10^9\le x,y\le 10^9,n\le 10^5$。肯定是要离散化的，而 $n$ 的范围使用 $O(n^2)$ 又很容易超时，所以可以用线段树维护。

由于区间查询只会查询整个扫描线与图形的截线长，我们可以使用一种特殊的方法，如果一个区间被图形覆盖的次数大于一次，那么这个区间 $[l,r]$ 在扫描线上的长度就是 $raw_r-raw_{l-1}$，$raw$ 是对纵坐标离散化后的数组。否则就是他的两个子区间在扫描线上的长度和。

在完成本题前，可以先完成[面积并模板题](https://www.luogu.com.cn/problem/P5490)。这道题题解区中有更多详细讲解。
# 本题思路
正方形每移动一次，这次运动所覆盖的面积就会形成一个矩形，这样我们把每次运动后形成的矩形的面积并求出来就是要求的答案。

那么如何方便的表示出每个矩形的坐标呢，我们仅仅只用维护这个正方形左下角的下标，如果这次运动的方向是 $y$ 轴正方向，当前正方形左下角的坐标为 $(x,y)$，运动的距离为 $a_i$，正方形边长为 $k$，那么运动产生矩形的左下角坐标是 $(x,y)$，右下角坐标是 $(x+k,y+k+a_i)$。剩下的方向也是这个样子。
![示意图](https://cdn.luogu.com.cn/upload/image_hosting/4580ejy3.png)
# Code
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm> 
using namespace std;
const int N=2e5+10;
typedef long long ll;
ll n,tot,raw[N],ans,k,nowx,nowy;
struct line{
	ll x,y1,y2,k;
}b[N];
struct node{
	ll l,r,dat,sum;
}a[4*N];
bool cmp(line a,line b){
	return a.x<b.x;
}
void read(ll &a){
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0',ch=getchar();} 
	a=x*f;
}
void push_up(int p){
	if(a[p].sum>0)a[p].dat=raw[a[p].r+1]-raw[a[p].l];
	else{
        if(a[p].l==a[p].r)a[p].dat=0;
        else a[p].dat=a[2*p].dat+a[2*p+1].dat;
    }
	return; 
}
void build(ll p,ll l ,ll r){
	if(l==r){
		a[p]=node{l,r,0,0};
		return;
	}else{
		ll mid=(l+r)/2;
		build(2*p,l,mid);
		build(2*p+1,mid+1,r);
		a[p]=node{l,r,0,0};
		return;
	}
}
void add(int p,int l,int r,int k){
	if(a[p].l>=l&&a[p].r<=r){
		a[p].sum+=k;
		push_up(p);
	}else{
		ll mid=(a[p].l+a[p].r)/2;
		if(mid>=l)add(2*p,l,r,k);
		if(mid<r)add(2*p+1,l,r,k);
		push_up(p);
	}
	return;
}
int main(){
	read(k),read(n);nowx=nowy=0;
	for(int i=1;i<=n;i++){
		char ch[3];ll len,x,y,xx,yy;
        scanf("%s %lld",ch,&len);
        if(ch[0]=='N')x=nowx,y=nowy,xx=nowx+k,yy=nowy+k+len,nowy+=len;
        if(ch[0]=='E')x=nowx,y=nowy,xx=nowx+k+len,yy=nowy+k,nowx+=len;
        if(ch[0]=='S')x=nowx,y=nowy-len,xx=nowx+k,yy=nowy+k,nowy-=len;
        if(ch[0]=='W')x=nowx-len,y=nowy,xx=nowx+k,yy=nowy+k,nowx-=len;
        b[i*2-1]=line{x,y,yy,1};
		b[i*2]=line{xx,y,yy,-1};
		raw[++tot]=y,raw[++tot]=yy;
	}
	sort(b+1,b+1+2*n,cmp);
	sort(raw+1,raw+1+tot);
	tot=unique(raw+1,raw+1+tot)-(raw+1);
	build(1,1,tot);
	for(int i=1;i<=2*n-1;i++){
		ll L=lower_bound(raw+1,raw+1+tot,b[i].y1)-raw;
		ll R=lower_bound(raw+1,raw+1+tot,b[i].y2)-raw;
		if(L>R)swap(L,R);
		add(1,L,R-1,b[i].k);
        ans+=a[1].dat*(b[i+1].x-b[i].x);
	}
	printf("%lld\n",ans);
	return 0; 
} 
```
其实就是扫描线板子。

[AC记录。](https://www.luogu.com.cn/record/145828346)

如有错误，请指出。

---

## 作者：P_VICVIC_R (赞：1)

~~扫描线板子改改就能过~~

---

### 题意：

用一个 $k\times k$ 的正方形向上下左右四个方向移动，问其扫过的总面积。

### 思路：

重叠的部分只算一次，那么实际上就是在求每次移动扫过的面积的并。

既然求面积并，那么大概率就是在考**扫描线**（不会的去做[板子](https://www.luogu.com.cn/problem/P5490)）。

~~我们考虑怎么把这道题转换成模板题。~~

记正方形的左下角为 $(P_x,P_y)$，那么右上角为 $(P_x+k,P_y+k)$，移动后就相当于添加以下四种矩形中的一种：

- 向上走：左下角 $(P_x,P_y)$，右上角 $(P_x+k,P_y+k+d)$；
- 向右走：左下角 $(P_x,P_y)$，右上角 $(P_x+k+d,P_y+k)$；
- 向下走：左下角 $(P_x,P_y-d)$，右上角 $(P_x+k,P_y+k)$；
- 向左走：左下角 $(P_x-d,P_y)$，右上角 $(P_x+k,P_y+k)$；

其中 $d$ 为走的距离，记得更新正方形的位置。

剩下的就套板子就行。

### code

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
static const int N=1000000;
struct ScanLine{
    int l,r,h,x;
    inline bool operator< (const ScanLine& rhs){
        return this->h<rhs.h;
    }
}L[N];
struct Node{
    int l,r,Len,Tim;
}T[N];
int X[N];
inline void Build(int rt,int l,int r){
    T[rt]={l,r,0,0};
    if(l==r)
        return ;
    int mid=(l+r)>>1;
    Build(rt<<1,l,mid);
    Build(rt<<1|1,mid+1,r);
}
inline void PushUp(int rt){
    if(T[rt].Tim)
        T[rt].Len=X[T[rt].r+1]-X[T[rt].l];
    else
        T[rt].Len=T[rt<<1].Len+T[rt<<1|1].Len;
}
inline void Update(int rt,int l,int r,int c){
    if(T[rt].l>r or T[rt].r<l)
        return ;
    if(T[rt].l>=l && T[rt].r<=r){
        T[rt].Tim+=c;
        PushUp(rt);
        return ;
    }
    Update(rt<<1,l,r,c);
    Update(rt<<1|1,l,r,c);
    PushUp(rt);
    return ;
}
int n,m,k;
int Px,Py;
inline void Run(char c,int kl,int op){
    int x1=Px,x2=Px+k,y1=Py,y2=Py+k;
    switch (c)
    {
    case 'N':
            y2+=kl;
            Py+=kl;
        break;
    case 'E':
            x2+=kl;
            Px+=kl;
        break;
    case 'S':
            y1-=kl;
            Py-=kl;
        break;
    case 'W':
            x1-=kl;
            Px-=kl;
        break;
    }
    L[(op<<1)-1]={x1,x2,y1,1};
    L[(op<<1)]={x1,x2,y2,-1};
    X[(op<<1)-1]=x1;
    X[(op<<1)]=x2;
} 
signed main(){
    std::cin.tie(nullptr)->sync_with_stdio(false);
    std::cout.tie(nullptr)->sync_with_stdio(false);
    cin>>k>>n;
    for(int i=1;i<=n;i++){
        char c;
        int op;
        cin>>c>>op;
        Run(c,op,i);
    }
    n<<=1;
    sort(L+1,L+1+n);
    sort(X+1,X+1+n);
    int tot=unique(X+1,X+1+n)-X-1;
    Build(1,1,tot);
    int ans=0;
    for(int i=1;i<n;i++){
        int l=lower_bound(X+1,X+1+tot,L[i].l)-X,
            r=lower_bound(X+1,X+1+tot,L[i].r)-X;
		if(l>r)
            swap(l,r);
        Update(1,l,r-1,L[i].x);
        ans+=T[1].Len*(L[i+1].h-L[i].h);
    }
    cout<<ans;
    return 0;
}

```

~~码风不好将就看~~

---

## 作者：Na2PtCl6 (赞：1)

## 题意转化
机器人的轨迹可以认为是若干个矩形，所以题目就变成了给出 $n$ 个矩形，求其面积并。

## 算法讲解
### 干讲
扫描线是一种思想，可以理解成用一条无限长的线，按顺序扫描平面上的若干线段，然后在扫描的过程中用一个数据结构维护这条线上的东西。

对于矩形面积并的问题，我们先考虑不用离散化的情况。我们可以直接扫值域范围内的每个横坐标，然后想办法维护当前线上有多少个格子。因为一个矩形在扫描的过程中就是一条线段，所以可以想到用线段树维护。维护过程就是扫到一个矩形就把这条线段加入集合，扫到一个矩形的末尾就从集合里删掉线段，还要求所有线段的并集长度。

如果需要离散化的话，就对横轴离散化，纵轴用动态开点线段树，每次的结果乘上当前横坐标和先前横坐标的距离。

这个线段树要维护区间加，求全局里 $>0$ 的数的个数，看上去很难写。但是因为我们的扫描线在删线段的时候只会删先前加入过的线段，这就使问题变得好办了。我们根本不用下传标记，因为我们只关注根节点的答案。

这里直接给出实现
```cpp
void modify(LL l,LL r,signed &ver,LL start,LL end,int v){
	if(!ver)
		ver=++cnt;
	LL mid=(l+r)>>1;
	if(start<=l&&r<=end){
		mini[ver]+=v;
		if(mini[ver]<=0)
			cntpos[ver]=cntpos[lver[ver]]+cntpos[rver[ver]];
		else
			cntpos[ver]=r-l+1;
		return ;
	}
	if(start<=mid)
		modify(l,mid,lver[ver],start,end,v);
	if(end>mid)	
		modify(mid+1,r,rver[ver],start,end,v);
	if(mini[ver]<=0)
		cntpos[ver]=cntpos[lver[ver]]+cntpos[rver[ver]];
	else
		cntpos[ver]=r-l+1;
}
```

### 例子
我们已知扫描线操作的顺序为：加入 $[1,1]$，加入 $[4,5]$，加入 $[1,4]$，加入 $[1,9]$，删除 $[1,4]$，删除 $[1,1]$，删除 $[1,9]$，删除 $[4,5]$。

手玩或让程序跑一下就可以发现，上面的修改完全不影响下面保存的信息，但是下面的修改会影响上面的信息。这样，我们在发现当前节点没有被完全覆盖时，直接从下层节点获取不加入这条线段时，`cntpos` 的值；并且也保证了我的节点能完整地维护下层的信息。这样的写法完美利用了删掉的线段在之前出现过这一性质，因为如果不是，例如：加入 $[1,9]$，删除 $[4,5]$ 就会导致下面删完了但是上面不知道是什么情况。

## 完整代码
有几个细节，但都相对好处理
```cpp
#include<bits/stdc++.h>
typedef long long LL;
using namespace std;
const LL maxn=200004,V=3e14,O=1+(LL)1e14;
char op[maxn];
int k,n,sz,dis,cnt,rt,lver[maxn*64],rver[maxn*64],mini[maxn*64];
LL res,c1[maxn],r1[maxn],c2[maxn],r2[maxn],realv[maxn],cntpos[maxn*64];
vector< LL > cpy;
vector< tuple<LL,LL,int> > tag[maxn];

void modify(LL l,LL r,signed &ver,LL start,LL end,int v){
	if(!ver)
		ver=++cnt;
	LL mid=(l+r)>>1;
	if(start<=l&&r<=end){
		mini[ver]+=v;
		if(mini[ver]<=0)
			cntpos[ver]=cntpos[lver[ver]]+cntpos[rver[ver]];
		else
			cntpos[ver]=r-l+1;
		return ;
	}
	if(start<=mid)
		modify(l,mid,lver[ver],start,end,v);
	if(end>mid)	
		modify(mid+1,r,rver[ver],start,end,v);
	if(mini[ver]<=0)
		cntpos[ver]=cntpos[lver[ver]]+cntpos[rver[ver]];
	else
		cntpos[ver]=r-l+1;
}

signed main(){
	scanf("%d %d",&k,&n);
	LL curx=O,cury=O;
	for(int i=1;i<=n;i++){
		scanf("%s %d",op,&dis);
		if(op[0]=='N'){
			c1[i]=curx,r1[i]=cury;
			cury+=dis;
			c2[i]=curx+k,r2[i]=cury+k;
		}
		if(op[0]=='S'){
			c2[i]=curx+k,r2[i]=cury+k;
			cury-=dis;
			c1[i]=curx,r1[i]=cury;
		}
		if(op[0]=='W'){
			c2[i]=curx+k,r2[i]=cury+k;
			curx-=dis;
			c1[i]=curx,r1[i]=cury;
		}
		if(op[0]=='E'){
			c1[i]=curx,r1[i]=cury;
			curx+=dis;
			c2[i]=curx+k,r2[i]=cury+k;
		}
		cpy.push_back(c1[i]),cpy.push_back(c2[i]);
	}
	sort(cpy.begin(),cpy.end());
	int sz=unique(cpy.begin(),cpy.end())-cpy.begin();
	for(int i=1;i<=n;i++){
		int p1=lower_bound(cpy.begin(),cpy.begin()+sz,c1[i])-cpy.begin()+1;
		int p2=lower_bound(cpy.begin(),cpy.begin()+sz,c2[i])-cpy.begin()+1;
		realv[p1]=c1[i],realv[p2]=c2[i];
		tag[p1].push_back(make_tuple(r1[i],r2[i]-1,1));
		tag[p2].push_back(make_tuple(r1[i],r2[i]-1,-1));
	}
	for(int i=1;i<=sz;i++){
	    if(i>1)
	        res+=1ll*cntpos[rt]*(realv[i]-realv[i-1]);
		for(auto j:tag[i])
			modify(1,V,rt,get<0>(j),get<1>(j),get<2>(j));
	}
	printf("%lld\n",res);
	return 0;
} 
```

---

## 作者：_anll_ (赞：0)

简单扫描线问题。
## 大体思路
既然扫过的区域都只算一次，那不就是很裸的扫描线嘛。对于每次操作，可以把它看作生成了一个矩阵。不妨令 $(x1,y1),(x2,y2)$ 表示生成一个左下角坐标为 $(x1,y1)$，右上角坐标为 $(x2,y2)$ 的矩阵。则生成方式如下：

- 对于 `S` 操作，生成 $(x1,y1-w),(x2,y2)$，$y1\rightarrow y1-w,y2 \rightarrow y2-w$。
- 对于 `N` 操作，生成 $(x1,y1),(x2,y2+w)$，$y1\rightarrow y1+w,y2 \rightarrow y2-w$。
- 对于 `E` 操作，生成 $(x1,y1),(x2+w,y2)$，$x1\rightarrow x1+w,x2 \rightarrow x2+w$。
- 对于 `W` 操作，生成 $(x1-w,y1),(x2,y2)$，$x1\rightarrow x1-w,x2 \rightarrow x2-w$。

之后只需要套入扫描线模板即可，不会的看[这里](https://www.luogu.com.cn/problem/P5490)。

## 代码实现
注意不开 `long long` 见祖宗。
```cpp
#include<iostream>
#include<algorithm>
#include<unordered_map>
#define lc p<<1
#define rc p<<1|1
#define int long long
using namespace std;
const int N=2e6+5;
struct Line{
	int l,r,y,num;
	bool operator<(Line &obj){return y<obj.y;}
}le[N];
struct Tr{
	int l,r,tag,sum;
}tr[N<<3];
int k,n,ans,x1,x2,y1,y2,rf[N],om[N];
unordered_map<int,int> mo;
void add(int i,int x1_,int x2_,int y1_,int y2_){
	le[i]={x1_,x2_,y1_,1};le[i+n]={x1_,x2_,y2_,-1};
	rf[i]=x1_,rf[i+n]=x2_;
}
void pushup(int p){
	if(tr[p].tag) tr[p].sum=om[tr[p].r+1]-om[tr[p].l];
	else tr[p].sum=tr[lc].sum+tr[rc].sum;
}
void build(int l,int r,int p){
	tr[p]={l,r};
	if(l==r) return;
	int mid=(l+r)/2;
	build(l,mid,lc);build(mid+1,r,rc);
}
void update(int l,int r,int p,int k){
	if(l<=tr[p].l&&tr[p].r<=r){tr[p].tag+=k;pushup(p);return;}
	int mid=(tr[p].l+tr[p].r)/2;
	if(l<=mid) update(l,r,lc,k);
	if(mid<r) update(l,r,rc,k);
	pushup(p);
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>k>>n;char op;int w;x2=y2=k;
	for(int i=1;i<=n;i++){
		cin>>op>>w;
		if(op=='S'){
			add(i,x1,x2,y1-w,y2);
			y1-=w,y2-=w;
		}
		else if(op=='N'){
			add(i,x1,x2,y1,y2+w);
			y1+=w,y2+=w;
		}
		else if(op=='E'){
			add(i,x1,x2+w,y1,y2);
			x1+=w,x2+=w;
		}
		else if(op=='W'){
			add(i,x1-w,x2,y1,y2);
			x1-=w,x2-=w;
		}
	}
	n*=2;sort(le+1,le+1+n);sort(rf+1,rf+1+n);
	mo[rf[1]]=1;om[1]=rf[1];int tot=1;
	for(int i=2;i<=n;i++)
		if(rf[i]!=rf[i-1]){mo[rf[i]]=++tot;om[tot]=rf[i];}
	build(1,tot,1);
	for(int i=1;i<n;i++){
		int l=le[i].l,r=le[i].r,y=le[i].y,num=le[i].num;
		update(mo[l],mo[r]-1,1,num);
		ans+=tr[1].sum*(le[i+1].y-le[i].y);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：fulichang (赞：0)

## 思路：

这题基本就是扫描线模板

模拟每次扫地机器人移动经过的矩形，然后直接扫描线面积并。

## 实现：

- 设 $(x,y)$ 为当前扫地机器人左下角的坐标，$k,a$ 的含义均与题目描述相同。
- 操作 `E` 即为左下 $(x,y)$ 右上 $(x+k,y+a+k)$ 的矩形。
- 操作 `S` 即为左下 $(x,y-a)$ 右上 $(x+k,y+k)$ 的矩形。
- 操作 `W` 即为左下 $(x-a,y)$ 右上 $(x+k,y+k)$ 的矩形。
- 操作 `N` 即为左下 $(x,y)$ 右上 $(x+k,y+a+k)$ 的矩形。
- 最后直接扫描线面积并模板就可以了。

## 代码：
```cpp
/********************************
 | Author:   ╔═══╗╔╗ ╔╗╔╗   ╔═══╗╔═══╗╔╗   ╔═══╗╔═══╗╔═══╗
 |           ║╔══╝║║ ║║║║   ╚═══╝║╔══╝║║   ╚══╗║║╔═╗║║╔═╗║
 |           ║╚══╗║║ ║║║║   ╔═══╗║║   ║╚══╗╔══╝║║║ ║║║╚═╝║
 |           ║╔══╝║║ ║║║║   ║   ║║║   ║╔═╗║║╔═╗║║║ ║║╚══╗║
 |           ║║   ║╚═╝║║╚══╗║   ║║╚══╗║║ ║║║╚═╝║║║ ║║╔══╝║
 |           ╚╝   ╚═══╝╚═══╝╚═══╝╚═══╝╚╝ ╚╝╚═══╝╚╝ ╚╝╚═══╝
 | Problem: P10096 [ROIR 2023 Day 1] 扫地机器人
 | Contest: luogu
 | URL:     https://www.luogu.com.cn/problem/P10096
 | When:    24-06-01 10:39:11
 |
 | Memory:  512.00 MB
 | Time:    1.00 s
*******************************/

#include <bits/stdc++.h>
#define int long long

const int N = 1e5 + 10;

struct node {
	int y, xl, xr, op;
	friend bool operator < (node a, node b) {
		return a.y < b.y;
	}
};

int n, k;
int xcoor[N << 1], tree[N << 3], tag[N << 3];
node line[N << 1];

inline void pushup (int l, int r, int rt) {
	if (tag[rt])
		tree[rt] = xcoor[r] - xcoor[l];
	else if (l + 1 == r)
		tree[rt] = 0;
	else
		tree[rt] = tree[rt << 1] + tree[rt << 1 | 1];
}

void update (int l, int r, int rt, int L, int R, int op) {
	if (L <= l && r <= R) {
		tag[rt] += op, pushup(l, r, rt);
		return;
	}
	if (l + 1 == r)
		return;
	int mid = l + r >> 1;
	if (L <= mid)
		update(l, mid, rt << 1, L, R, op);
	if (R > mid)
		update(mid, r, rt << 1 | 1, L, R, op);
	pushup(l, r, rt);
}

signed main (void) {
	std::ios::sync_with_stdio(0), std::cin.tie(0);
	std::cin >> k >> n, n *= 2;
	int x = 0, y = 0;
	for (int i = 1; i <= n; i += 2) {
		char d;
		int a;
		std::cin >> d >> a;
		if (d == 'N') {
			xcoor[i] = x, line[i] = {y, x, x + k, 1};
			xcoor[i + 1] = x + k, line[i + 1] = {y + a + k, x, x + k, -1};
			y += a;
		} else if (d == 'S') {
			xcoor[i] = x, line[i] = {y - a, x, x + k, 1};
			xcoor[i + 1] = x + k, line[i + 1] = {y + k, x, x + k, -1};
			y -= a;
		} else if (d == 'W') {
			xcoor[i] = x - a, line[i] = {y, x - a, x + k, 1};
			xcoor[i + 1] = x + k, line[i + 1] = {y + k, x - a, x + k, -1};
			x -= a;
		} else {
			xcoor[i] = x, line[i] = {y, x, x + a + k, 1};
			xcoor[i + 1] = x + a + k, line[i + 1] = {y + k, x, x + a + k, -1};
			x += a;
		}
	}
	std::sort(xcoor + 1, xcoor + n + 1);
	std::sort(line + 1, line + n + 1);
	int len = std::unique(xcoor + 1, xcoor + n + 1) - xcoor - 1, ans = 0;
	for (int i = 1; i <= n; i++) {
		int l = std::lower_bound(xcoor + 1, xcoor + len + 1, line[i].xl) - xcoor;
		int r = std::lower_bound(xcoor + 1, xcoor + len + 1, line[i].xr) - xcoor;
		ans += tree[1] * (line[i].y - line[i - 1].y);
		update(1, len, 1, l, r, line[i].op);
	}
	std::cout << ans << std::endl;
	return 0;
}
``````

---

## 作者：junee (赞：0)

# P10096 题解

## 前置知识

扫描线，线段树。

## 题目分析

跟 [P5490](https://www.luogu.com.cn/problem/P5490) 基本一样。

当机器人向上移动时，即增加一个 $(x,y),(x+n,y+n+d)$ 的矩形。

当机器人向下移动时，即增加一个 $(x,y-d),(x+n,y+n)$ 的矩形。

当机器人向右移动时，即增加一个 $(x,y),(x+n+d,y+n)$ 的矩形。

当机器人向左移动时，即增加一个 $(x-d,y),(x+n,y+n+d)$ 的矩形。

然后再用扫描线，处理一下就可以了。

注意，如果你的维护的坐标没有开 long long，那么你可能只有 38。

## Code

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
using namespace std;
const int N=2e5+10;
typedef long long LL;
LL n;
LL ans=0;
vector<LL>v;
struct node{
	LL l,r,cnt,len;
}tr[N*4];
struct edge{
	LL x,y1,y2,k;
}e[N];
bool cmp(edge a,edge b){
	return a.x<b.x;
}
LL find(LL x){
	return lower_bound(v.begin(),v.end(),x)-v.begin();
}
void pushup(LL u){
	if(tr[u].cnt>0)tr[u].len=v[tr[u].r+1]-v[tr[u].l];
    else if(tr[u].l!=tr[u].r)tr[u].len=tr[u<<1].len+tr[u<<1|1].len;
    else tr[u].len=0;
}
void build(LL u,LL l,LL r){
	tr[u]={l,r,0,0};
	if(l==r)return;
	LL mid=(l+r)>>1;
	build(u<<1,l,mid),build(u<<1|1,mid+1,r); 
}
void modify(LL u,LL l,LL r,LL k){
	if(tr[u].l>=l&&tr[u].r<=r){
		tr[u].cnt+=k;
		pushup(u);
		return;
	}
	LL mid=(tr[u].l+tr[u].r)>>1;
	if(l<=mid)modify(u<<1,l,r,k);
	if(r>mid)modify(u<<1|1,l,r,k);
	pushup(u);
}
LL xx1,xx2,yy1,yy2,T;
char a;
signed main(){
	cin>>n>>T;
	xx1=yy1=0,xx2=yy2=n;
	for(LL i=1,x1,x2,y1,y2,d;i<=T;i++){
		cin>>a>>d;
		if(a=='W')x1=xx1-d,y1=yy1,x2=xx2,y2=yy2,xx1-=d,xx2-=d;
		if(a=='E')x1=xx1,y1=yy1,x2=xx2+d,y2=yy2,xx1+=d,xx2+=d;
		if(a=='N')x1=xx1,y1=yy1,x2=xx2,y2=yy2+d,yy1+=d,yy2+=d;
		if(a=='S')x1=xx1,y1=yy1-d,x2=xx2,y2=yy2,yy1-=d,yy2-=d;
		e[i*2-1]={x1,y1,y2,1};
		e[i*2]={x2,y1,y2,-1};
		v.push_back(y1),v.push_back(y2);
	}
	sort(v.begin(),v.end());
	v.erase(unique(v.begin(),v.end()),v.end());
	build(1,0,v.size()-1);
	sort(e+1,e+T*2+1,cmp);
	for(LL i=1;i<T*2+1;i++){
	    if(i>1)ans+=tr[1].len*(e[i].x-e[i-1].x);
		modify(1,find(e[i].y1),find(e[i].y2)-1,e[i].k);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Fantasy_Segment_Tree (赞：0)

扫描线板子题。

我们把第 $i$ 次移动之前的正方形和移动过程中碰到过的部分合起来当成第 $i$ 次移动形成的矩阵。

设原来的正方形左下角为 $(x, y)$，操作编号为 $i$，则：

对于向上操作，矩形左下角为 $(x, y)$，右上角为 $(x + k, y + k + a_i)$。

对于向下操作，矩形左下角为 $(x, y - a_i)$，右上角为 $(x + k, y + k)$。

对于向右操作，矩形左下角为 $(x, y)$，右上角为 $(x + k + a_i, y + k)$。

对于向左操作，矩形左下角为 $(x - a_i, y)$，右上角为 $(x + k, y + k)$。

然后就转换成了求 $n$ 个矩形的面积并，可以使用扫描线，具体写法可以看 [P5490的题解](https://www.luogu.com.cn/problem/solution/P5490)。注意在每次移动后一定要更新左下角的坐标！

代码如下。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

long long n, nowx, nowy;

struct node {
	long long y, x1, x2, flag;
}a[200005];

long long x[200005];

bool cmp(node u, node v) {
	return u.y < v.y;
}

struct Tree {
	long long l, r, sum, len;
}b[1600005];

void build(long long l, long long r, long long x) {
	b[x].l = l, b[x].r = r;
	if(l == r) return;
	long long mid = (l + r) >> 1;
	build(l, mid, x * 2);
	build(mid + 1, r, x * 2 + 1);
}

void push_up(long long xx) {
	if(b[xx].sum) b[xx].len = x[b[xx].r + 1] - x[b[xx].l];
	else b[xx].len = b[2 * xx].len + b[2 * xx + 1].len;
}

void change(long long l, long long r, long long k, long long xx) {
	if(x[b[xx].l] >= r || x[b[xx].r + 1] <= l) return;
	if(x[b[xx].l] >= l && x[b[xx].r + 1] <= r) {
		b[xx].sum += k;
		push_up(xx);
		return;
	}
	change(l, r, k, xx * 2);
	change(l, r, k, xx * 2 + 1);
	push_up(xx);
}

int main() {
	long long k;
	cin >> k >> n;
	for(long long i = 1; i <= n; i++) {
		char op;
		long long q;
		cin >> op >> q;
		if(op == 'E') {
			long long x1 = nowx, y1 = nowy, x2 = nowx + k + q, y2 = nowy + k;
			x[2 * i - 1] = x1, x[2 * i] = x2;
			a[2 * i - 1] = {y1, x1, x2, 1};
			a[2 * i] = {y2, x1, x2, -1};
			nowx += q;
		} else if(op == 'W') {
			long long x1 = nowx - q, y1 = nowy, x2 = nowx + k, y2 = nowy + k;
			x[2 * i - 1] = x1, x[2 * i] = x2;
			a[2 * i - 1] = {y1, x1, x2, 1};
			a[2 * i] = {y2, x1, x2, -1};
			nowx -= q;
		} else if(op == 'N') {
			long long x1 = nowx, y1 = nowy, x2 = nowx + k, y2 = nowy + k + q;
			x[2 * i - 1] = x1, x[2 * i] = x2;
			a[2 * i - 1] = {y1, x1, x2, 1};
			a[2 * i] = {y2, x1, x2, -1};
			nowy += q;
		} else {
			long long x1 = nowx, y1 = nowy - q, x2 = nowx + k, y2 = nowy + k;
			x[2 * i - 1] = x1, x[2 * i] = x2;
			a[2 * i - 1] = {y1, x1, x2, 1};
			a[2 * i] = {y2, x1, x2, -1};
			nowy -= q;
		}
	}
	sort(a + 1, a + 2 * n + 1, cmp);
	sort(x + 1, x + 2 * n + 1);
	long long sum = unique(x + 1, x + 2 * n + 1) - (x + 1);
	build(1, sum - 1, 1);
	long long ans = 0;
	for(long long i = 1; i < 2 * n; i++) {
		change(a[i].x1, a[i].x2, a[i].flag, 1);
		ans += b[1].len * (a[i + 1].y - a[i].y);
	}
	cout << ans;
}
```

---


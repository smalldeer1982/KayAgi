# 『STA - R4』冰红茶

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/sdchy9ah.png)

某编程网站 BTC 长期在它的 Beginner Contest 的最后一题放科技模板题，于是 APJifengc 愤怒地在它的评测机上洒了若干瓶冰红茶，导致一些评测单元的运行速度快了 $10^{12}$ 倍，暴力跑得和正解一样快。

因为 BTC 不能出科技模板题了，所以 BTC 的站长想要让你维护一下 APJifengc 每次洒冰红茶后可用的评测单元个数，以便于统筹评测资源与灾后重建。

**已加入 Hack 数据，位于 Subtask 5，不计分。**

## 题目描述

有 $n$ 个 bot 排成一排，每天所有 bot 都会喝冰红茶。

要求动态维护一排 bot，有三种操作或询问：
- `1 l r k`，表示 $[l,r]$ 内的 bot 会喝 $k$ 瓶原味冰红茶、$[l,r]$ 外的 bot 会喝 $k$ 瓶热带风味冰红茶。
- `2 l r k`，表示 BTC 站长愤怒地把 $[l,r]$ 中最后连续喝了至少 $k$ 瓶口味相同的冰红茶的 bot 击毁。
- `3`，查询有多少个存活的 bot。

注：在 2 操作中，击毁不会改变 bot 的编号。

## 说明/提示

### 样例 1 解释

只说明操作 1 和操作 2。

第一次操作，三号和四号 bot 喝了 8 瓶原味冰红茶，其他 bot 喝了 8 瓶热带风味冰红茶。

第二次操作，三号和四号 bot 连续喝了 8 瓶原味冰红茶，被击毁，现在场上还有 3 个存活 bot。

第三次操作，二号 bot 喝了 3 瓶原味冰红茶，其他 bot 喝了 3 瓶热带风味冰红茶。

第四次操作，一号和五号 bot 连续喝了 11 瓶热带风味冰红茶，被击毁，现在场上还有 1 个存活 bot。

第五次操作，二号 bot 喝了 3 瓶原味冰红茶。

第六次操作，二号 bot 连续喝了 6 瓶原味冰红茶，被击毁，现在场上没有存活的 bot。

### 数据范围

**本题采用捆绑测试。**

- Subtask 1 (5pts)：$n,q\le 10^3$。
- Subtask 2 (20pts)：所有操作 2 中 $k\le 20$。
- Subtask 3 (25pts)：保证数据随机生成。
- Subtask 4 (50pts)：无特殊限制。

其中 Subtask 3 的测试数据生成方式如下：

1. 对于每次或询问，从三种类型中等概率选择一个；
2. 若选取的操作不为 3，那么从 $\left[1, n\right]$ 中等概率生成两个数 $l, r$，若 $l > r$，则交换 $l, r$，并将 $l, r$ 作为操作的参数；
3. 若选取的操作不为 3，那么从 $\left[1, 10^6\right]$ 中等概率生成一个数 $k$ 作为操作的参数。

对于全部数据，保证 $1\le n,q\le 2\times 10^5$，$1\le k\le 10^{6}$。

## 样例 #1

### 输入

```
5 12
1 3 4 8
3
2 3 4 6
3
1 2 2 3
3
2 1 5 6
3
1 2 3 3
3
2 1 5 3
3
```

### 输出

```
5
3
3
1
1
0
```

## 样例 #2

### 输入

```
9 18
1 8 9 5
3
1 5 8 20
3
2 8 9 18
3
2 6 9 6
3
2 1 2 5
3
2 9 9 8
3
2 3 9 14
3
1 6 8 13
3
2 3 5 17
3
```

### 输出

```
9
9
7
5
3
3
0
0
0
```

# 题解

## 作者：Genius_Star (赞：11)

### 思路：

考虑线段树维护：

- $sum$ 区间内活着的 bot 个数。

- $Max_1$ 区间内喝“原味冰红茶”最后连续喝的数量的最大值。

- $Max_2$ 区间内喝“热带风味冰红茶”最后连续喝的数量的最大值。

- $tag_1$ 区间覆盖“原味冰红茶”最后连续喝的数量的懒标记。

- $tag_2$ 区间覆盖“热带风味冰红茶”最后连续喝的数量的懒标记。

- $tag_3$ 区间增加“原味冰红茶”最后连续喝的数量的懒标记。

- $tag_4$ 区间增加“热带风味冰红茶”最后连续喝的数量的懒标记。

每次操作 $1$ 时：

- 将 $[l,r]$ 区间内喝“热带风味冰红茶”最后连续喝的数量覆盖为 $0$。

- 将 $[l,r]$ 区间内喝“原味冰红茶”最后连续喝的数量增加 $k$。

- 将 $[1,l-1]$ 区间内喝“原味冰红茶”最后连续喝的数量覆盖为 $0$。

- 将 $[r+1,n]$ 区间内喝“原味冰红茶”最后连续喝的数量覆盖为 $0$。

- 将 $[1,l-1]$ 区间内喝“热带风味冰红茶”最后连续喝的数量增加 $k$。

- 将 $[r+1,n]$ 区间内喝“热带风味冰红茶”最后连续喝的数量增加 $k$。

每次操作 $2$ 时：

- 如果 $[l,r]$ 的 $sum$ 为 $0$（即都死完了），退出。

- 如果 $[l,r]$ 的 $\max(Max_1,Max_2)<k$，则这个区间最大的都没有连续喝 $k$ 瓶相同口味的冰红茶，退出。

- 否则线段树一直分，跳到单点为止，直接修改。

每次操作 $3$ 时：

- 输出 $root$ 的 $sum$ 即可。

时间复杂度 $O(n \log n)$。

**常数略大，谨慎使用。**

[提交记录 666ms。](https://www.luogu.com.cn/record/145709588)

### 细节：

对于区间覆盖标记 $tag_1$ 和 $tag_2$，下传时也要将儿子的 $tag_3$ 和 $tag_4$ 两个加法标记给清空。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
const ll N=200200;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,q,op,l,r,v;
struct Node{
	ll l,r;
	ll sum;
	ll Max1,Max2;
	ll tag1,tag2;
	ll tag3,tag4;
}X[N<<2];
void pushup(ll k){
	X[k].sum=X[k<<1].sum+X[k<<1|1].sum;
	X[k].Max1=max(X[k<<1].Max1,X[k<<1|1].Max1);
	X[k].Max2=max(X[k<<1].Max2,X[k<<1|1].Max2);
}
void push_down(ll k){
	if(X[k].tag1!=-1){
		X[k<<1].tag3=X[k<<1|1].tag3=0;
		X[k<<1].tag1=X[k<<1|1].tag1=X[k].tag1;
		X[k<<1].Max1=X[k<<1|1].Max1=X[k].tag1;
		X[k].tag1=-1;
	}
	if(X[k].tag2!=-1){
		X[k<<1].tag4=X[k<<1|1].tag4=0;
		X[k<<1].tag2=X[k<<1|1].tag2=X[k].tag2;
		X[k<<1].Max2=X[k<<1|1].Max2=X[k].tag2;
		X[k].tag2=-1;
	}
	if(X[k].tag3){
		X[k<<1].tag3+=X[k].tag3;
		X[k<<1|1].tag3+=X[k].tag3;
		X[k<<1].Max1+=X[k].tag3;
		X[k<<1|1].Max1+=X[k].tag3;
		X[k].tag3=0;
	}
	if(X[k].tag4){
		X[k<<1].tag4+=X[k].tag4;
		X[k<<1|1].tag4+=X[k].tag4;
		X[k<<1].Max2+=X[k].tag4;
		X[k<<1|1].Max2+=X[k].tag4;
		X[k].tag4=0;		
	}
}
void build(ll k,ll l,ll r){
	X[k].l=l,X[k].r=r;
	X[k].tag1=X[k].tag2=-1;
	if(l==r){
		X[k].sum=1;
		return ;
	}
	ll mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	pushup(k);
}
void updata1(ll k,ll l,ll r,ll v){
	if(r<l)
	  return ;
	if(X[k].l==l&&r==X[k].r){
		X[k].tag3=0;
		X[k].tag1=X[k].Max1=v;
		return ;
	}
	push_down(k);
	ll mid=(X[k].l+X[k].r)>>1;
	if(r<=mid)
	  updata1(k<<1,l,r,v);
	else if(l>mid)
	  updata1(k<<1|1,l,r,v);
	else{
		updata1(k<<1,l,mid,v);
		updata1(k<<1|1,mid+1,r,v);
	}
	pushup(k);
}
void updata2(ll k,ll l,ll r,ll v){
	if(r<l)
	  return ;
	if(X[k].l==l&&r==X[k].r){
		X[k].tag4=0;
		X[k].tag2=X[k].Max2=v;
		return ;
	}
	push_down(k);
	ll mid=(X[k].l+X[k].r)>>1;
	if(r<=mid)
	  updata2(k<<1,l,r,v);
	else if(l>mid)
	  updata2(k<<1|1,l,r,v);
	else{
		updata2(k<<1,l,mid,v);
		updata2(k<<1|1,mid+1,r,v);
	}
	pushup(k);
}
void updata3(ll k,ll l,ll r,ll v){
	if(r<l)
	  return ;
	if(X[k].l==l&&r==X[k].r){
		X[k].tag3+=v; 
		X[k].Max1+=v;
		return ;
	}
	push_down(k);
	ll mid=(X[k].l+X[k].r)>>1;
	if(r<=mid)
	  updata3(k<<1,l,r,v);
	else if(l>mid)
	  updata3(k<<1|1,l,r,v);
	else{
		updata3(k<<1,l,mid,v);
		updata3(k<<1|1,mid+1,r,v);
	}
	pushup(k);
}
void updata4(ll k,ll l,ll r,ll v){
	if(r<l)
	  return ;
	if(X[k].l==l&&r==X[k].r){
		X[k].tag4+=v; 
		X[k].Max2+=v;
		return ;
	}
	push_down(k);
	ll mid=(X[k].l+X[k].r)>>1;
	if(r<=mid)
	  updata4(k<<1,l,r,v);
	else if(l>mid)
	  updata4(k<<1|1,l,r,v);
	else{
		updata4(k<<1,l,mid,v);
		updata4(k<<1|1,mid+1,r,v);
	}
	pushup(k);
}
void Find(ll k,ll l,ll r,ll v){
	if(max(X[k].Max1,X[k].Max2)<v||!X[k].sum)
	  return ;
	if(X[k].l==X[k].r){
		X[k].sum=0;
		return ;
	}
	push_down(k);
	ll mid=(X[k].l+X[k].r)>>1;
	if(r<=mid)
	  Find(k<<1,l,r,v);
	else if(l>mid)
	  Find(k<<1|1,l,r,v);
	else{
		Find(k<<1,l,mid,v);
		Find(k<<1|1,mid+1,r,v);
	}
	pushup(k);
}
int main(){
//	freopen("A.in","r",stdin);
	n=read(),q=read();
	build(1,1,n);
	while(q--){
		op=read();
		if(op==1){
			l=read(),r=read(),v=read();
			updata2(1,l,r,0);
			updata1(1,1,l-1,0);
			updata1(1,r+1,n,0);
			updata3(1,l,r,v);
			updata4(1,1,l-1,v);
			updata4(1,r+1,n,v);
		}
		else if(op==2){
			l=read(),r=read(),v=read();
			Find(1,l,r,v);
		}
		else{
			write(X[1].sum);
			putchar('\n');
		}
	}
	return 0;
} 
```


---

## 作者：jijidawang (赞：5)

感谢 Rolling_star 和 APJifengc。

称最后一次喝原味冰红茶的 bot 为 A 态，否则为 B 态。

考虑动态维护每个 bot 已经连续喝了多少秒的同种口味冰红茶，后称时间戳。

那么一次操作 1 相当于将区间内所有 B 态的时间戳置 0 并转为 A 态、区间外所有 A 态的时间戳置 0 并转为 B 态，操作后将所有位置的时间戳均增加 $k$。

对于操作 2，相当于每次删除区间内的所有最大值，直到最大值 $<b$ 时停止。

那么可以考虑线段树维护区间的最大值，操作 2 时，当区间的最大值 $<b$ 时跳出，否则向两个子树内递归。首先删除的总次数肯定是 $O(n)$ 级别的，对于每个要被删除的位置，这个过程在删除它的过程中遍历对它到根的链时对于每个错误分支只会试探 1 次，所以此处的总复杂度为 $O(n\log n)$。

对于操作 1 引发的影响，首先可以发现需要维护四种标记：

1. 对于区间中所有 A 态的区间加标记。
2. 对于区间中所有 B 态的区间加标记。
3. 区间内所有 B 态的时间戳置 0 并转为 A 态的标记。
4. 区间内所有 A 态的时间戳置 0 并转为 B 态的标记。

然后发现对于这四种标记无法合并和维护，所以再引进两种标记方便维护标记 3, 4 的合并：

5. 将区间内所有元素都转为时间戳为 0 的 A 态元素的标记。
6. 将区间内所有元素都转为时间戳为 0 的 B 态元素的标记。

标记对信息的影响就先考虑覆盖类型标记的影响然后再考虑加法标记影响即可。

下边令 $P_i$ 为标记 $P$ 的 $i$ 号标记的值。

接下来考虑标记对标记的影响：

首先，对于 3, 4, 5, 6 标记同时最多只存在一个。

假设是 $P$ 标记作用在 $Q$ 标记上，对于 $P$ 的 3, 4, 5, 6 标记分类讨论：

1. $P$ 没有 3, 4, 5, 6 标记，则 $Q_1\gets Q_1+P_1$，$Q_2\gets Q_2+P_2$。
2. $P$ 拥有 3 标记，对 $Q$ 的 3, 4, 5, 6 标记分类讨论：
	- $Q$ 拥有 3 标记，则 $Q_1\gets Q_1+P_1$。
	- $Q$ 拥有 4 标记，则 $Q_1\gets P_1$，$Q_5\gets 1$，$Q_4\gets 0$。
	- $Q$ 拥有 5 标记，则 $Q_1\gets Q_1+P_1$，$Q_5\gets 1$，$Q_4\gets 0$。
	- $Q$ 拥有 6 标记，则 $Q_1\gets P_1$，$Q_5\gets 1$，$Q_6\gets 0$。
3. $P$ 拥有 4 标记的情况和拥有 3 标记的情况对称，故在此不表。
4. $P$ 拥有 5 标记，直接令 $Q_5=1$，$Q_1=P_1$，其他标记置为 0，对于拥有 6 标记的情况也是类似的。

要注意的就是对于已经被击毁的 bot 和没有此颜色的 bot 需要进行特殊处理。

那么问题被以线性对数时间复杂度解决，可以通过本题。

---

## 作者：fzitb7912 (赞：4)

## 分析

出得很好，模板套模板，希望下次再来。

难点在于维护最后连续喝的 DS 饮料数量。设这次喝原味饮料的区间为 $[l,r]$，上一次为 $[l',r']$。则有两种情况：

1. $[l,r]$ 与 $[l',r']$ 不相交。如：![](https://cdn.luogu.com.cn/upload/image_hosting/6v18w87j.png)

在 $[l',r']$ 和 $[l,r]$ 两个区间中的 DS 连续喝的同种饮料数量都会变成 $k$，而其他的则增加 $k$。

2. $[l,r]$ 与 $[l',r']$ 相交。如：![](https://cdn.luogu.com.cn/upload/image_hosting/ux6akhqz.png)

在 $[l',r']$ 和 $[l,r]$ 两个区间中不相交的区间的 DS 连续喝的同种饮料数量都会变成 $k$，而其他的则增加 $k$。

这就是操作一转化之后你能维护的东西。说是模板其实是因为这个区间赋值和区间加就是[扶苏的问题](https://www.luogu.com.cn/problem/P1253)。这里就不分析了。

然后就是另一个模板——维护操作二。很明显的一个小清新，因为 DS 的数量不增。考虑线段树上的某个区间在什么情况下会有 DS 被干掉。因为 BTC 是干掉连续喝相同饮料数量不少于 $k$ 的，所以维护一个区间最大值，若最大值 $x \ge k$ 且该区间有 DS 没被干掉时，这个区间有很大可能发生 DS 被 BTC 干掉的情况。很简单的模板小清新，单点修改即可。

对于询问，就是求出来区间 $[1,n]$ 有多少 DS 被干掉了，答案为 $n-cnt$。求序列被干掉的 DS 数量可以 $O(1)$。

复杂度 $O(n \log n)$。

小细节：保证小清新的时间复杂度，当一个 DS 被干掉之后，他的最大值应赋值为极小值。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define re register
#define il inline
#define pii pair<int,int>
#define x first
#define y second
#define gc getchar()
#define rd read()
#define debug() puts("------------")

namespace yzqwq{
	il int read(){
		int x=0,f=1;char ch=gc;
		while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=gc;}
		while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=gc;
		return x*f;
	}
	il int qmi(int a,int b,int p){
		int ans=1;
		while(b){
			if(b&1) ans=ans*a%p;
			a=a*a%p,b>>=1;
		}
		return ans;
	}
	il auto max(auto a,auto b){return (a>b?a:b);}
	il auto min(auto a,auto b){return (a<b?a:b);}
	il int gcd(int a,int b){
		if(!b) return a;
		return gcd(b,a%b);
	}
	il int lcm(int a,int b){
		return a/gcd(a,b)*b;
	}
	il void exgcd(int a,int b,int &x,int &y){
		if(!b) return x=1,y=0,void(0);
		exgcd(b,a%b,x,y);
		int t=x;
		x=y,y=t-a/b*x;
		return ;
	}
	mt19937 rnd(time(0));
}
using namespace yzqwq;

const int N=3e5+10;
int n,q;
pii lst;
struct Tree{
	int l,r;
	int mx,kil;
	int tag1,tag2,tag;
}tr[N<<2];

il void up(int now){
	tr[now].mx=max(tr[now<<1].mx,tr[now<<1|1].mx);
	tr[now].kil=tr[now<<1].kil+tr[now<<1|1].kil;
	return ;
}
il void down(int now){
	if(tr[now].tag==1){//覆盖 
		tr[now<<1].tag1=tr[now<<1|1].tag1=tr[now].tag1;
		tr[now<<1].tag2=tr[now<<1|1].tag2=tr[now].tag2;
		tr[now<<1].mx=tr[now<<1|1].mx=tr[now].tag1+tr[now].tag2;
		tr[now].tag1=tr[now].tag2=tr[now].tag=0;
		tr[now<<1].tag=tr[now<<1|1].tag=1; 
	}
	else{//加
		tr[now<<1].tag2+=tr[now].tag2,
		tr[now<<1|1].tag2+=tr[now].tag2;
		tr[now<<1].mx+=tr[now].tag2,
		tr[now<<1|1].mx+=tr[now].tag2;
		tr[now].tag1=tr[now].tag2=tr[now].tag=0;
	}
	return ;
}
il void build(int now,int l,int r){
	tr[now].l=l,tr[now].r=r;
	if(l==r) return ;
	int mid=l+r>>1;
	build(now<<1,l,mid),build(now<<1|1,mid+1,r);
	return ;
}
il void add1(int now,int l,int r,int k){//区间加
	if(tr[now].l>=l&&tr[now].r<=r){
		tr[now].mx+=k,
		tr[now].tag2+=k;
		return ;
	}
	down(now);
	int mid=tr[now].l+tr[now].r>>1;
	if(l<=mid) add1(now<<1,l,r,k);
	if(mid<r) add1(now<<1|1,l,r,k);
	return up(now),void(0);
}
il void add2(int now,int l,int r,int k){//区间覆盖
	if(tr[now].l>=l&&tr[now].r<=r){
		tr[now].mx=tr[now].tag1=k,
		tr[now].tag2=0,tr[now].tag=1;
		return ;
	}
	down(now);
	int mid=tr[now].l+tr[now].r>>1;
	if(l<=mid) add2(now<<1,l,r,k);
	if(mid<r) add2(now<<1|1,l,r,k);
	return up(now),void(0);
}
il void del(int now,int l,int r,int k){//干掉 DS
	if(tr[now].l==tr[now].r){
		tr[now].mx=-1e18,tr[now].kil=1;
		return ;
	}
	down(now);
	int mid=tr[now].l+tr[now].r>>1;
	if(l<=mid&&tr[now<<1].mx>=k&&tr[now<<1].kil<tr[now<<1].r-tr[now<<1].l+1) del(now<<1,l,r,k);
	if(mid<r&&tr[now<<1|1].mx>=k&&tr[now<<1|1].kil<tr[now<<1|1].r-tr[now<<1|1].l+1) del(now<<1|1,l,r,k);
	return up(now),void(0);
}

il void solve(){
	n=rd,q=rd;
	build(1,1,n);
	for(re int i=1;i<=q;++i){
		int op=rd,l,r,k;
		if(op==1){
			l=rd,r=rd,k=rd;
			if(!lst.x) add1(1,1,n,k),lst={l,r};
			else{
				int l_=lst.x,r_=lst.y;
				if(r_<l||r<l_){//区间不相交 
					if(min(l,l_)>1) add1(1,1,min(l,l_)-1,k);
					if(max(r,r_)<n) add1(1,max(r,r_)+1,n,k);
					add2(1,l_,r_,k);
					add2(1,l,r,k);
					if(r_<l&&r_+1<=l-1) add1(1,r_+1,l-1,k);
					if(r<l_&&r+1<=l_-1) add1(1,r+1,l_-1,k);
				}
				else{//区间相交 
					if(min(l,l_)>1) add1(1,1,min(l,l_)-1,k);
					if(max(r,r_)<n) add1(1,max(r,r_)+1,n,k);
					add2(1,min(l,l_),max(l,l_)-1,k);
					add2(1,min(r,r_)+1,max(r,r_),k);
					add1(1,max(l,l_),min(r,r_),k);
				}
				lst={l,r};
			}
		}
		else if(op==2){
			l=rd,r=rd,k=rd;
			del(1,l,r,k);
		}
		else printf("%lld\n",n-tr[1].kil);
	}
	return ;
}

signed main(){
	int t=1;while(t--)
	solve();
	return 0;
}
```


---

## 作者：ZhongYuLin (赞：3)

考虑到每个点只会被删除一次，我们可以较为暴力地去做这一道题：每次找到区间的最大值，判断其是否大于 $K$，大于则摧毁之，重复直到没有合法的节点。

因此，题目要求维护一个序列，支持：

1. 区间赋值为 0

2. 区间加

3. 区间查询最大值

4. 删除（无视）一个点

5. 询问还有几个点

操作都是是线段树的基本操作，不做讲解。操作 4 后打个标记无视他即可。

具体实现中，开两颗线段树，给一颗区间加的同时给另一颗区间赋值为 0。删除节点时打个标记，以后上传区间信息时钦定他更小。如果一个区间这个意义下的最大值已经被摧毁，显然不会有其他未摧毁的点。
 
 代码：
 
 ```cpp
#include<bits/stdc++.h>
#define int long long
#define ls(p) p<<1
#define rs(p) p<<1|1
using namespace std;
const int N=2e5+10;
struct Node{
    int id,num,died;
}x,y;
struct SegmentTree{
    Node t[N<<2];
    int tag[N<<2],clear[N<<2];
    Node max(const Node &x,const Node &y){
        if(x.died)return y;
        if(y.died)return x;
        return x.num>y.num?x:y;
    }
    void push_up(int p){
        t[p]=max(t[ls(p)],t[rs(p)]);
    }
    void push_down(int p){
        if(clear[p])
            clear[ls(p)]=clear[rs(p)]=1,
            tag[ls(p)]=tag[rs(p)]=t[ls(p)].num=t[rs(p)].num=clear[p]=0;
        if(tag[p])
            tag[ls(p)]+=tag[p],tag[rs(p)]+=tag[p],
            t[ls(p)].num+=tag[p],t[rs(p)].num+=tag[p],
            tag[p]=0;
    }
    void update(int x,int y,int k,int l,int r,int p){
        if(x>y)return;
        if(x<=l&&r<=y){tag[p]+=k,t[p].num+=k;return;}
        int mid=l+r>>1;push_down(p);
        if(x<=mid)update(x,y,k,l,mid,ls(p));
        if(y>mid)update(x,y,k,mid+1,r,rs(p));
        push_up(p);
    }
    void cover(int x,int y,int l,int r,int p){
        if(x>y)return;
        if(x<=l&&r<=y){clear[p]=1,t[p].num=0,tag[p]=0;return;}
        int mid=l+r>>1;push_down(p);
        if(x<=mid)cover(x,y,l,mid,ls(p));
        if(y>mid)cover(x,y,mid+1,r,rs(p));
        push_up(p);
    }
    Node query(int x,int y,int l,int r,int p){
        if(x<=l&&r<=y)return t[p];
        int mid=l+r>>1;push_down(p);
        if(y<=mid)return query(x,y,l,mid,ls(p));
        if(x>mid)return query(x,y,mid+1,r,rs(p));
        return max(query(x,y,l,mid,ls(p)),query(x,y,mid+1,r,rs(p)));
    }
    void kill(int x,int l,int r,int p){
        if(l==r){t[p].died=1;return;}
        int mid=l+r>>1;push_down(p);
        if(x<=mid)kill(x,l,mid,ls(p));
        else kill(x,mid+1,r,rs(p));
        push_up(p);
    }
    void build(int l,int r,int p){
        if(l==r){t[p].id=l;return;}
        int mid=l+r>>1;
        build(l,mid,ls(p));
        build(mid+1,r,rs(p));
        push_up(p);
    }
}t1,t2;
int n,q;
signed main(){
    // freopen("P10120.in","r",stdin);
    // freopen("P10120.out","w",stdout);
    ios::sync_with_stdio(cin.tie(cout.tie(0)));
    cin>>n>>q;int res=n;t1.build(1,n,1);t2.build(1,n,1);
    for(int l,r,k,op;q--;){
        cin>>op;
        if(op==1)cin>>l>>r>>k,
            t1.cover(1,l-1,1,n,1),
            t1.cover(r+1,n,1,n,1),
            t2.cover(l,r,1,n,1),
            t1.update(l,r,k,1,n,1),
            t2.update(1,l-1,k,1,n,1),
            t2.update(r+1,n,k,1,n,1);
        else if(op==2){
            cin>>l>>r>>k;int flg=0;
            do{
                x=t1.query(l,r,1,n,1);flg=0;
                if(!x.died&&x.num>=k)t1.kill(x.id,1,n,1),t2.kill(x.id,1,n,1),--res,flg=1;
            }while(flg);
            do{
                x=t2.query(l,r,1,n,1);flg=0;
                if(!x.died&&x.num>=k)t1.kill(x.id,1,n,1),t2.kill(x.id,1,n,1),--res,flg=1;
            }while(flg);
        }
        else printf("%lld\n",res);
    }
    return 0;    
}
```
数据生成器:

```cpp
#include<bits/stdc++.h>
using namespace std;
mt19937 rnd(time(0));
int rd(int l,int r){
    return rnd()%(r-l+1)+l;
}
int n,m;
int main(){
    // freopen("P10120.in","w",stdout);
    n=rd(1,10);m=rd(1,20);
    printf("%d %d\n",n,m);
    for(int i=1;i<=m;++i){
        int op=rd(0,2);int l,r;
        if(op==0)l=rd(1,n),r=rd(l,n),printf("%d %d %d %d\n",1,l,r,rd(1,20));
        else if(op==1)l=rd(1,n),r=rd(l,n),printf("%d %d %d %d\n",2,l,r,rd(1,20));
        else puts("3");
    }
}
```



---

## 作者：yzq_yzq (赞：3)

非正解但是过了，思路比较简单。

考虑分块，每个块维护两个值，喝原味冰红茶最多的个数，喝热带冰红茶最多的个数。

在区间删除 $\ge k$ 的时候，如果块内两个最大值有一个大于 $k$ ，就大力重构删除。

这里的复杂度是 $O(n\sqrt n)$ 的，因为每个块最多删 $\sqrt n$ 次。

然后考虑怎么重构回去，对每个 bot 维护上一次喝的冰红茶是哪一种，以及喝了多少，对整块维护上一次喝的冰红茶，原味是 $tag1$ ，热带风味是 $tag2$ 两个 $tag$ 只会有其中一个，因为一旦打一个 $tag$ ，另外一个会清空。

重构的时候下放 $tag$ 即可。

但还有一个弊端，就是一个块可能打了一次 $tag1$ ，然后打 $tag2$ ，但是重构时会默认加到之前的上面，这就意味着以前喝了热带冰红茶，又喝原味，再喝热带，你会把以前喝的热带跟 $tag2$ 加在一起。

所以你要打个标记看两个 $tag$ 是否都打过，都打过重构时先清空再下放 $tag$ 。

代码：

``` cpp
#include <bits/stdc++.h>
#define rep(i, x, y) for (int i = x; i <= y; ++i)
#define drep(i, x, y) for (int i = x; i >= y; --i)
#define ll long long
#define pb push_back
#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
#define endl '\n'
using namespace std;
const int N = 200020;
ll n, m, pos[N], sq, w1[N], w2[N], ls[N];
ll L[1010], R[1010], fg[N], w[N], tot, mx[N], mx2[N], sz[N], lz[N];
bool vis[N];
inline void cg(int b){
	mx[b] = mx2[b] = 0;
	rep(i, L[b], R[b]) if(!vis[i] && fg[i] == 1) mx[b] = max(mx[b], w[i]);
	rep(i, L[b], R[b]) if(!vis[i] && fg[i] == 2) mx2[b] = max(mx2[b], w[i]);
}
inline void down(int b) {
	if(lz[b] == 3) rep(i, L[b], R[b]) w[i] = 0;
	lz[b] = 0;
	if(w1[b]) {
		rep(i, L[b], R[b]) {
			if(vis[i]) continue;
			if(fg[i] == 1) w[i] += w1[b];
			else fg[i] = 1, w[i] = w1[b];
		}
		w1[b] = 0;
		cg(b);
	}
	if(w2[b]) {
		rep(i, L[b], R[b]) {
			if(vis[i]) continue;
			if(fg[i] == 2) w[i] += w2[b];
			else fg[i] = 2, w[i] = w2[b];
		}
		w2[b] = 0;
		cg(b);
	}
}
inline void upd1(int l, int r, ll k) {
	down(pos[l]);
	rep(i, l, r) {
		if(vis[i]) continue;
		if(fg[i] == 1) w[i] += k;
		else fg[i] = 1, w[i] = k;
	}
	cg(pos[l]);
}
inline void upd2(int l, int r, ll k) {
	down(pos[l]);
	rep(i, l, r) {
		if(vis[i]) continue;
		if(fg[i] == 2) w[i] += k;
		else fg[i] = 2, w[i] = k;
	}
	cg(pos[l]);
}
inline void update1(int l, int r, ll k) {
	if(pos[l] == pos[r]) return upd1(l, r, k);
	upd1(l, R[pos[l]], k), upd1(L[pos[r]], r, k);
	rep(i, pos[l] + 1, pos[r] - 1) {
		mx[i] += k;
		w1[i] += k;
		lz[i] |= 1;
		w2[i] = 0;
		mx2[i] = 0;
	}
}
inline void update2(int l, int r, ll k) {
	if(pos[l] == pos[r]) return upd2(l, r, k);
	upd2(l, R[pos[l]], k), upd2(L[pos[r]], r, k);
	rep(i, pos[l] + 1, pos[r] - 1) {
		mx2[i] += k;
		w2[i] += k;
		w1[i] = 0;
		lz[i] |= 2;
		mx[i] = 0;
	}
}
inline void kill(int l, int r, ll k) {
	down(pos[l]);
	rep(i, l, r) {
		if(vis[i]) continue;
		if(w[i] >= k) {
			//	cout << "kill : " << i << endl;
			sz[pos[i]]--;
			vis[i] = 1;
			--tot;
			w[i] = -1e18;
		}
	}
	cg(pos[l]);
}
inline void Kill(int l, int r, ll k) {
	if(pos[l] == pos[r]) return kill(l, r, k);
	kill(l, R[pos[l]], k), kill(L[pos[r]], r, k);
	rep(i, pos[l] + 1, pos[r] - 1) {
		if(mx[i] >= k || mx2[i] >= k) {
			if(sz[i])
				kill(L[i], R[i], k);
		}
	}
}
int main() {
	IOS;
	cin >> n >> m;
	tot = n;
	sq = sqrt(n) * 0.8;
	rep(i, 1, n) pos[i] = (i - 1) / sq + 1, w[i] = 0, fg[i] = 1;
	rep(i, 1, pos[n]) L[i] = (i - 1) * sq + 1, R[i] = min(i * sq, n);
	rep(i, 1, pos[n]) sz[i] = R[i] - L[i] + 1;
	int T = 0;
	while(m--) {
		ll op;
		cin >> op;
		if(op == 3) cout << tot << endl;
		else {
			int l, r, k;
			cin >> l >> r >> k;
			if(op == 2) Kill(l, r, k);
			else {
				if(l > 1) update2(1, l - 1, k);
				if(r < n) update2(r + 1, n, k);
				update1(l, r, k);
				//				if(l > 1) upd2(1, l - 1, k);
				//				if(r < n) upd2(r + 1, n, k);
				//				upd1(l, r, k);
			}
		}
		++T;
//		if(T<=1000) rep(i, 1, pos[n]) if(sz[i]) down(i);
		//		rep(i, 1, n) cout << "i : " << i << " " << fg[i] << " " << w[i] << endl;
		//		cout << "------\n";
	}
	return 0;
}
```

---

## 作者：yzh_Error404 (赞：2)

题目只要求记录最后的连续喝冰红茶数量，所以可以直接用两颗线段树记录。

对于操作一，将区间内的原味冰红茶数量增加 $k$，覆盖掉热带冰红茶，在区间外则做相反的操作。

对于操作二，询问区间最大值是否大于 $k$，且将大于 $k$ 的标记，直接做就可以了。

每次操作三输出总数减标记数即可。

代码实现：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=1e6+5;
int n,q;
int mn[MAXN][2],mx[MAXN][2];
int tagc[MAXN][2],taga[MAXN][2],tagd[MAXN];
int del[MAXN];
inline void pushup(int p)
{
    for(register int i=0;i<=1;i++)
    {
        mn[p][i]=min(mn[p<<1][i],mn[p<<1|1][i]);
        mx[p][i]=max(mx[p<<1][i],mx[p<<1|1][i]);
    }
    del[p]=del[p<<1]+del[p<<1|1];
}
inline void build(int p,int l,int r)
{
    tagc[p][0]=tagc[p][1]=-1;
    if(l==r)return;
    int mid=(l+r)>>1;
    build(p<<1,l,mid);
    build(p<<1|1,mid+1,r);
}
inline void addtagc(int p,int k,int u)
{
    mn[p][u]=mx[p][u]=k;
    taga[p][u]=0;tagc[p][u]=k;
}
inline void addtaga(int p,int k,int u)
{
    mn[p][u]+=k;mx[p][u]+=k;
    taga[p][u]+=k;
}
inline void pushdown(int p,int l,int r,int u)
{
    if(tagc[p][u]!=-1)
    {
        addtagc(p<<1,tagc[p][u],u);
        addtagc(p<<1|1,tagc[p][u],u);
        tagc[p][u]=-1;
    }
    if(taga[p][u])
    {
        addtaga(p<<1,taga[p][u],u);
        addtaga(p<<1|1,taga[p][u],u);
        taga[p][u]=0;
    }
    if(tagd[p])
    {
        int mid=(l+r)>>1;
        del[p<<1]=(mid-l+1),del[p<<1|1]=(r-(mid+1)+1);
        tagd[p<<1]=tagd[p<<1|1]=1;
        tagd[p]=0;
    }
}
inline void changea(int p,int l,int r,int a,int b,int k,int u)
{
    if(a>b)return;
    if(r<a||l>b)return;
    if(l>=a&&r<=b)return addtaga(p,k,u),void();
    int mid=(l+r)>>1;
    pushdown(p,l,r,u);
    changea(p<<1,l,mid,a,b,k,u);
    changea(p<<1|1,mid+1,r,a,b,k,u);
    pushup(p);
}
inline void changec(int p,int l,int r,int a,int b,int k,int u)
{
    if(a>b)return;
    if(r<a||l>b)return;
    if(l>=a&&r<=b)return addtagc(p,k,u),void();
    int mid=(l+r)>>1;
    pushdown(p,l,r,u);
    changec(p<<1,l,mid,a,b,k,u);
    changec(p<<1|1,mid+1,r,a,b,k,u);
    pushup(p);
}
inline void delet(int p,int l,int r,int a,int b,int k,int u)
{
    if(a>b)return;
    if(del[p]==r-l+1)return;
    if(r<a||l>b)return;
    if(mx[p][u]<k)return;
    if(l>=a&&r<=b&&mn[p][u]>=k)return del[p]=(r-l+1),tagd[p]=1,void();
    int mid=(l+r)>>1;
    pushdown(p,l,r,u);
    delet(p<<1,l,mid,a,b,k,u);
    delet(p<<1|1,mid+1,r,a,b,k,u);
    pushup(p);
}
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>n>>q;
    build(1,1,n);
    for(register int i=1;i<=q;i++)
    {
        int op,l,r,k;
        cin>>op;
        if(op==1)//0原味，1热带
        {
            cin>>l>>r>>k;
            changea(1,1,n,l,r,k,0);changec(1,1,n,l,r,0,1);
            changea(1,1,n,1,l-1,k,1);changec(1,1,n,1,l-1,0,0);
            changea(1,1,n,r+1,n,k,1);changec(1,1,n,r+1,n,0,0);
        }
        if(op==2)
        {
            cin>>l>>r>>k;
            delet(1,1,n,l,r,k,0);
            delet(1,1,n,l,r,k,1);
        }
        if(op==3)printf("%lld\n",n-del[1]);
    }
    return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：2)

标程做法太优秀了，这里给一种不要脑子的做法。

考虑对序列分块，维护 $a_i = k$ 在 $k$ 大于 $0$ 时表示 $k$ 杯原味冰红茶，反之是热带风味，再对每个块维护一个 $tag$ 表示整块标记，在下传时维护标记 $lst$ 表示第一个整块标记与当前整块标记是否一致，不一致的话前面散块标记一定会被覆盖，否则可能可以继承。

对于删除操作，考虑维护标记表示块内的数是否被删除与最大值标记维护存在的机器人喝的冰红茶数量最大值，假若一个块内的最大值不到 $k$ 或者块被删完就跳过，否则暴力删除，不难发现只会暴力删除 $n$ 次（每次暴力遍历至少删除一个机器人）所以复杂度是 $O(n \sqrt n)$ 的。

那么就做完了。虽然被人 HACK 了一次但是我们调小块长就可以过了。下面是新代码。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 3e5+114;
int a[maxn];//a[i] = i 表示连续喝了多少杯冰红茶 正数就是原味 负数就是热带风味
int tag[maxn];//表示当前区间上的 tag
int vis[maxn];//当前区间内是否还存活有机器人
int use[maxn];//表示当前的机器人是否活着
int lst[maxn];//标记是否有多种颜色混合在一起
int mx[maxn],mi[maxn];
const int warma = 150;
int ans,n,q;
int ABS(int x){
    return x>0?x:-x;
}
void pushdown(int pos){
    if(tag[pos]==0) return ;
    int l=(pos-1)*warma+1;
    int r=pos*warma;
    mx[pos]=mi[pos]=0;
    for(int i=l;i<=r;i++){
    	if(lst[pos]==true) a[i]=tag[pos];
        else if(a[i]==0) a[i]=tag[pos];
        else if(a[i]>0&&tag[pos]>0) a[i]+=tag[pos];
        else if(a[i]>0&&tag[pos]<0) a[i]=tag[pos];
        else if(a[i]<0&&tag[pos]>0) a[i]=tag[pos];
        else a[i]+=tag[pos];
        if(use[i]==false) mx[pos]=max(mx[pos],a[i]);
        if(use[i]==false) mi[pos]=min(mi[pos],a[i]);
	}
    tag[pos]=0;
    lst[pos]=0;
}
void del(int pos,int k){
    if(mx[pos]<k&&mi[pos]>-k) return;
    if(vis[pos]==true) return ;
    pushdown(pos);
    int l=(pos-1)*warma+1;
    int r=pos*warma;
    bool flag=true;
    mx[pos]=mi[pos]=0;
    for(int i=l;i<=r;i++){
        if(ABS(a[i])>=k){
            if(use[i]==false) ans--;
            use[i]=true;
        }
        if(use[i]==false) flag=false,mx[pos]=max(mx[pos],a[i]),mi[pos]=min(mi[pos],a[i]);
    }
    if(flag==true) vis[pos]=true;
}
void add(int l,int r,int k){
    if(l>r) return ;
    int lpos=(l-1)/warma+1;
    int rpos=(r-1)/warma+1;
    if(lpos==rpos){
        pushdown(lpos);
        mx[lpos]=mi[lpos]=0;
        for(int i=l;i<=r;i++){
            if(a[i]==0) a[i]=k;
            else if(a[i]>0&&k>0) a[i]+=k;
            else if(a[i]>0&&k<0) a[i]=k;
            else if(a[i]<0&&k>0) a[i]=k;
            else a[i]+=k;
            if(use[i]==false) mx[lpos]=max(mx[lpos],a[i]);
            if(use[i]==false) mi[lpos]=min(mi[lpos],a[i]);
        }
        for(int i=(lpos-1)*warma+1;i<=lpos*warma;i++){
            if(use[i]==false) mx[lpos]=max(mx[lpos],a[i]);
            if(use[i]==false) mi[lpos]=min(mi[lpos],a[i]);
		}
    }else{
        for(int i=lpos+1;i<rpos;i++){
            if(tag[i]==0) tag[i]=k;
            else if(tag[i]>0&&k>0) tag[i]+=k;
            else if(tag[i]>0&&k<0) tag[i]=k,lst[i]=true;
            else if(tag[i]<0&&k>0) tag[i]=k,lst[i]=true;
            else tag[i]+=k;
            if(k>0) mx[i]+=k,mi[i]=0;
            if(k<0) mi[i]+=k,mx[i]=0;
        }
        pushdown(lpos);
        pushdown(rpos);
        mx[lpos]=mi[lpos]=0;
        mx[rpos]=mi[rpos]=0;
        for(int i=l;i<=lpos*warma;i++){
            if(a[i]==0) a[i]=k;
            else if(a[i]>0&&k>0) a[i]+=k;
            else if(a[i]>0&&k<0) a[i]=k;
            else if(a[i]<0&&k>0) a[i]=k;
            else a[i]+=k;
            if(use[i]==false) mx[lpos]=max(mx[lpos],a[i]);
            if(use[i]==false) mi[lpos]=min(mi[lpos],a[i]);
        }
        for(int i=(lpos-1)*warma+1;i<l;i++){
            if(use[i]==false) mx[lpos]=max(mx[lpos],a[i]);
            if(use[i]==false) mi[lpos]=min(mi[lpos],a[i]);
		}
        for(int i=(rpos-1)*warma+1;i<=r;i++){
            if(a[i]==0) a[i]=k;
            else if(a[i]>0&&k>0) a[i]+=k;
            else if(a[i]>0&&k<0) a[i]=k;
            else if(a[i]<0&&k>0) a[i]=k;
            else a[i]+=k;
            if(use[i]==false) mx[rpos]=max(mx[rpos],a[i]);
            if(use[i]==false) mi[rpos]=min(mi[rpos],a[i]);
        }
        for(int i=r+1;i<=rpos*warma;i++){
            if(use[i]==false) mx[rpos]=max(mx[rpos],a[i]);
            if(use[i]==false) mi[rpos]=min(mi[rpos],a[i]);	
		}
    }
}
void delet(int l,int r,int k){
    int lpos=(l-1)/warma+1;
    int rpos=(r-1)/warma+1;
    if(lpos==rpos){
        pushdown(lpos);
        mx[lpos]=mi[lpos]=0;
        for(int i=l;i<=r;i++){
            if(ABS(a[i])>=k){
                if(use[i]==false) ans--;
                use[i]=true;
            }
            if(use[i]==false) mx[lpos]=max(mx[lpos],a[i]);
            if(use[i]==false) mi[lpos]=min(mi[lpos],a[i]);
        }
    }
    else{
        for(int i=lpos+1;i<rpos;i++) del(i,k);
        pushdown(lpos);
        pushdown(rpos);
        mx[lpos]=mi[lpos]=0;
        mx[rpos]=mi[rpos]=0;
        for(int i=l;i<=lpos*warma;i++){
            if(ABS(a[i])>=k){
                if(use[i]==false) ans--;
                use[i]=true;
            }
            if(use[i]==false) mx[lpos]=max(mx[lpos],a[i]);
            if(use[i]==false) mi[lpos]=min(mi[lpos],a[i]);
        }
        for(int i=(lpos-1)*warma+1;i<l;i++){
            if(use[i]==false) mx[lpos]=max(mx[lpos],a[i]);
            if(use[i]==false) mi[lpos]=min(mi[lpos],a[i]);
		}
        for(int i=(rpos-1)*warma+1;i<=r;i++){
            if(ABS(a[i])>=k){
                if(use[i]==false) ans--;
                use[i]=true;
            }
            if(use[i]==false) mx[rpos]=max(mx[rpos],a[i]);
            if(use[i]==false) mi[rpos]=min(mi[rpos],a[i]);
        }
        for(int i=r+1;i<=rpos*warma;i++){
            if(use[i]==false) mx[rpos]=max(mx[rpos],a[i]);
            if(use[i]==false) mi[rpos]=min(mi[rpos],a[i]);	
		}
    }
}
signed main(){
	//freopen("1.in","r",stdin);
	//freopen("1.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>q;
    ans=n;
    while(q--){
        int opt;
        cin>>opt;
        if(opt==1){
            int l,r,k;
            cin>>l>>r>>k;
            add(l,r,k);
            add(1,l-1,-k);
            add(r+1,n,-k);
        }else if(opt==2){
            int l,r,k;
            cin>>l>>r>>k;
            delet(l,r,k);
        }else{
            cout<<ans<<'\n';
        }
    }
    return 0;
}
```


---

## 作者：ran_qwq (赞：2)

## 前言

提供一个两只 $\log$ 的做法，但是比较好写。

## 题意

题目说的已经很清楚了，略。

## 做法

因为 bot 最后连续喝 $k$ 瓶才会被击毁，所以如果喝了一种冰红茶，之前喝的另一种都作废。

记录每个 bot 最后连续喝的原味冰红茶瓶数 $a_i$，热带风味冰红茶瓶数 $b_i$。bot $i$ 喝 $k$ 瓶原味冰红茶相当于 $a_i\leftarrow a_i+k,b_i\leftarrow0$；喝 $k$ 瓶热带风味冰红茶相当于 $b_i\leftarrow b_i+k,a_i\leftarrow0$。

这样就得到了一个 $O(n^2)$ 的做法。

---
考虑用**线段树**维护 $a,b$ 的**最大值**，再维护区间存活 bot 数量 $val$。为什么要维护最大值待会再说。

喝冰红茶的过程等价于进行下列三个操作：

1. $\forall i\in[1,l-1],a_i\leftarrow0,b_i\leftarrow b_i+k$（如果 $l\ne1$ 的话）。

1. $\forall i\in[l,r],a_i\leftarrow a_i+k,b_i\leftarrow0$。

1. $\forall i\in[l,r],a_i\leftarrow0,b_i\leftarrow b_i+k$（如果 $r\ne n$ 的话）。

上个区间推平，区间加，求区间最大值线段树即可，维护 $a$ 推平的 tag，$a$ 加的 tag，$b$ 推平的 tag，$b$ 加的 tag，参见[扶苏的问题](/problem/P1253)。

---
对于击毁操作，从 $[l,r]$ 开始走。

如果一个区间的 $a_i$ 最大值和 $b_i$ 最大值**都小于** $k$，就不继续走（因为这里没有一个 bot 最后喝了连续 $k$ 瓶冰红茶）。

如果一个区间的 $val$ 值为 $0$（也就是没有存活的机器人了），也不继续走。

如果走到一个叶子节点就把它击毁（因为已经排除了 $a_i$ 最大值和 $b_i$ 最大值都小于 $k$ 的）。

有人会问，你这每次会被卡到 $O(n\log n)$（查询最大值一个 $\log$），时间复杂度不是假的吗？

我赛时也以为它是假的，但过了就没管。赛后才发现实际上这里可以用**势能分析**证明时间复杂度。

首先，对于一个长度为 $len$ 的区间，最多一共被经过 $len$ 次（因为一个机器人不会被击毁两次，而当区间内所有机器人都被击毁就不会再走这个区间）。

线段树有 $\log n$ 层，所有区间长度总和为 $n\log n$，再加上查询最大值的一个 $\log$，总时间复杂度 $O(n\log^2n)$。

[code](https://www.luogu.com.cn/paste/lya1koax)

---

## 作者：AlicX (赞：2)

## Solution 

首先发现性质：每一个 bot 只会被击毁一次。联想到小清新线段树，考虑维护每一个点最后喝的 ds 饮料数量，并同时维护区间 $Max$ 和区间内被删除的点的数量 $cnt$。

那么 $3$ 操作只需回答 $n-w_1$ 即可，执行 $2$ 操作时需要判断某一个区间的点内是否被全部删除以及 $Max$ 是否大于等于 $k$，如果满足才继续递归。

```cpp
void modify(int u,int l,int r,int k){ 
	if(tr[u].l==tr[u].r){
		if(tr[u].Max>=k){ 
			tr[u].Max=-1e18; 
			tr[u].w=1; 
		} return ; 
	} pushdown(u); 
	int mid=tr[u].l+tr[u].r>>1; 
	if(l<=mid&&tr[u<<1].Max>=k&&tr[u<<1].w<(tr[u<<1].r-tr[u<<1].l+1)) modify(u<<1,l,r,k); 
	if(r>mid&&tr[u<<1|1].Max>=k&&tr[u<<1|1].w<(tr[u<<1|1].r-tr[u<<1|1].l+1)) modify(u<<1|1,l,r,k); 
	pushup(u); 
} 
```

维护 $1$ 操作即是将喝同种饮料的 bot 的饮料数量加上 $k$，喝不同种饮料的 bot 的饮料数量赋值为 $k$，也就是区间加与区间覆盖。

唯一的难点在于分类讨论，考虑记录上一次 $1$ 操作的 $[l',r']$，那么有两种情况：

1. 如果两个区间不相交，便将区间 $[l,r],[l',r']$ 赋值为 $k$，其他 bot 加上 $k$。

2. 如果两个区间相交，则将相同部分加上 $k$，不相交部分赋值为 $k$，其余 bot 加上 $k$。

```cpp
	while(m--){ 
		int opt=read(),l,r,k; 
		if(opt==3) printf("%lld\n",n-tr[1].cnt);
		else{ 
			l=read(),r=read(),k=read(); 
			if(opt==2) modify(1,l,r,k); 
			else{ 
				modify_add(1,1,n,k); 
				if(lst.x){ 
					if(check(l,r,lst)) modify_tag(1,l,r,k),modify_tag(1,lst.x,lst.y,k);  
					else{ 
						int L=min(l,lst.x),R=max(r,lst.y); 
						int LL=max(l,lst.x),RR=min(r,lst.y); 
						modify_tag(1,L,LL-1,k),modify_tag(RR+1,R,k); 
					} 
				} lst={l,r}; 
			} 
		} 
	} 
```

---

## 作者：封禁用户 (赞：0)

赛时没过，但赛后也没过。

不难发现每个时刻只会有三个口味的大区间。于是每次操作转换为区间覆盖/区间加法，两个懒惰标记可以轻松维护。

继续考虑操作 $2$，不停删除直到区间最大值小于给定值 $k$，不难发现每个数最多删一次，均摊复杂度 $n\log n$。但是我查询最大值位置貌似是 $\log^2n$ 的，所以跑的慢一点。

---


# 「FAOI-R5」喷酒大赛

## 题目背景

> 吐火，是川剧中独一无二的神秘绝技，源于古西蜀，驰名中华梨园。变脸者以魔术般的技法，瞬息间变化脸谱，更与吐火神功的诡异结合，以显示人物内心和剧情的急剧变化及内在张力，是川剧中刻画人物最有力、最浪漫的艺术手法。表演的时候，演员嘴里含着一根管子，管子里有松香末和未完全燃尽的纸灰。（纸灰烧的火候很重要，要燃尽但又不能全燃尽）需要喷火的时候，外面点燃，演员往外吹气，这样就会有火花喷出来。

WC2025 开幕式上表演的绍剧喷火非常精彩，你虽然没有学过喷火，但是你可以喷酒。

## 题目描述

数轴上站着 $n$ 个表演者，第 $i$ 个表演者在正整数 $i$ 的位置。每个人嘴里都含着烈酒，对于第 $i$ 个表演者，你可以给他一个金币让他表演喷酒。

在你给完钱后，没有收到钱的表演者会退场，留下的表演者会在第 $0$ 时刻朝左右中的一个方向从嘴中喷出强度为 $k_i$ 的酒。形式化地，第 $i$ 个表演者喷出的酒具有方向属性 $b_i$，你可以在令 $b_i=1$ 或 $b_i=-1$。对于 $t\in[0,a_i)$ 的第 $t$ 时刻，酒的位置 $p_{i,t}=i+t\cdot b_i$。当 $t\geq a_i$ 时，该酒消失。

表演者背面有特殊防备，正面却没有。如果某个**正整数**时刻 $t$，表演者 $i$ 喷出的酒**仍然存在**且存在留下的表演者  $j$ 使得 $p_{i,t}=j$，那么：
- 若 $b_i=b_j$：
    - 若 $k_i=0$，表演者 $i$ 喷出的酒消失。
	- 若 $k_i>0$，$k_i\gets k_i-1$，即酒的强度减一。
- 若 $b_i\neq b_j$，表演者 $j$ 被喷到酒，愤怒离场。

你想要让酒铺满数轴上 $[1,n]$ 的位置，即对于任意 $i\in[1,n]$，至少存在一对非负整数 $(j,t)$ 使得 $t$ 时刻表演者 $j$ 喷出的酒**仍然存在**且 $p_{j,t}=i$。求出在达成该条件、没有表演者愤怒离场的情况下，最小花费的金币数。

## 说明/提示

### 样例解释

- 样例 #1：给 $3,4,10$ 三个表演者金币，令 $b_3=-1,b_4=1,b_{10}=-1$。
- 样例 #2：给 $1,2,3$ 三个表演者金币，令 $b_1=-1,b_2=-1,b_{3}=1$。

### 数据范围与约定

**本题采用捆绑测试。**

- Subtask 1（20 pts）：$n\leq 14$。
- Subtask 2（10 pts）：$n\leq 50$，$k_i=0$。
- Subtask 3（15 pts）：$n\leq 50$。
- Subtask 4（20 pts）：$n\leq 10^3$。
- Subtask 5（15 pts）：$n\leq 10^5$。
- Subtask 6（20 pts）：无特殊限制。

对于所有数据，$1\leq n,a_i\leq 5\times 10^5$，$0\le k_i\le5\times10^5$。

## 样例 #1

### 输入

```
10
1 1 4 5 1 4 1 2 1 2
1 1 2 0 3 1 2 0 2 1```

### 输出

```
3```

## 样例 #2

### 输入

```
10
1 1 9 2 4 9 2 2 1 1
1 0 3 2 3 0 3 8 2 1```

### 输出

```
3```

## 样例 #3

### 输入

```
24
1 4 5 2 3 1 4 2 5 3 1 1 1 3 2 1 1 1 1 2 2 1 1 3 
1 1 4 0 3 0 0 4 0 5 3 2 0 3 2 1 0 3 2 0 0 2 1 1```

### 输出

```
10```

# 题解

## 作者：szh_AK_all (赞：13)

好题啊好题（赞赏）。

## 分析

考虑 dp。设 $f_i$ 表示覆盖了 $1\sim i$ 这些位置所需要的最少表演者数量，那么我们枚举每位表演者，考虑其会对哪些位置产生影响。对于表演者 $i$，若其方向属性 $b_i$ 为 $-1$，则表演者 $i$ 可以将满足 $i\ge k\ge i-a_i$ 的前缀 $1\sim k$ 与区间 $k\sim i$ 连接起来，那么在进行转移时更新 $f_{i-a_i \sim i}$ 即可，具体的，设 $ans=\min_{j=\max(0,i-a_i)}^i f_j$，则转移式为 $f_k=\min(f_k,ans+1)$。你可能有疑问：满足 $f_j$ 值取到的最小的 $j$ 如果在转移时比 $k$ 大怎么办？注意点这种转移是不会影响 $f_k$ 的值的。

若表演者 $i$ 的方向属性为 $1$ 时同理。

但是这样的 dp 为什么是对的？

考虑当表演者 $i$ 喷的酒碰到了表演者 $j$ 时，根据题意分为如下两种情况：

- $b_i=b_j$，即表演者 $i,j$ 喷的酒的方向相同。若在无阻挡的情况下。表演者 $i$ 喷的酒可以到达比表演者 $j$ 喷的酒可以到达的更远的位置，那么显然我们留下表演者 $i$ 而不留下表演者 $j$ 是更优的；如果表演者 $i$ 喷的酒只能到达比表演者 $j$ 喷的酒可以到达的更近的位置，那么若留下表演者 $i,j$，表演者 $i,j$ 所能到达的位置形成的区间与单独考虑表演者 $i,j$ 所能到达的位置形成的区间是相同的。

- $b_i\ne b_j$，即表演者 $i,j$ 喷的酒的方向不同，此时表演者 $j$ 会寄。若 $b_i=1,b_j=-1$，此时 $j$ 一定大于 $i$，在转移 $f_{j-a_j\sim j}$ 时由于 $j$ 喷的酒可以到达 $i$，那么留下  $i$ 且 $b_i=1$ 一定不优；若 $b_i=-1,b_j=1$ 则同理。因此转移时不存在有表演者愤怒离场的情况。
 
下面是 $O(n^2)$ 的暴力代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[500005], k[500005], f[1005];

int main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	for (int i = 1; i <= n; i++)
		cin >> k[i];
	memset(f, 0x3f, sizeof(f));
	f[0] = 0;
	for (int i = 1; i <= n; i++) {
		int ans = 1000000000, tmp = 1000000000;
		for (int j = i - 1; j <= min(n, i + a[i]); j++)
			tmp = min(tmp, f[j] + 1);
		for (int j = max(0, i - a[i]); j <= i; j++)
			ans = min(ans, f[j] + 1);
		for (int j = max(0, i - a[i]); j <= i; j++)
			f[j] = min(f[j], ans);
		for (int j = i - 1; j <= min(n, i + a[i] - 1); j++)
			f[j] = min(f[j], tmp);
	}
	cout << f[n];
}
```

注意到计算区间最小 dp 值以及区间更新可以用线段树来维护，于是复杂度便正确了。

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[500005], k[500005], f[500005];

struct node {
	int ans, la;
	node(int aa = 1000000000, int bb = 1000000000) {
		ans = aa;
		la = bb;
	}
} t[500005 << 2];

void pushdown(int d) {
	if (t[d].la == 1000000000)
		return;
	t[d * 2].ans = min(t[d * 2].ans, t[d].la), t[d * 2].la = min(t[d * 2].la, t[d].la);
	t[d * 2 + 1].ans = min(t[d * 2 + 1].ans, t[d].la), t[d * 2 + 1].la = min(t[d * 2 + 1].la, t[d].la);
	t[d].la = 1000000000;
}

void bu(int d, int l, int r) {
	if (l == r) {
		t[d].ans = t[d].la = 1000000000;
		return;
	}
	int mid = (l + r) / 2;
	bu(d * 2, l, mid);
	bu(d * 2 + 1, mid + 1, r);
	t[d].ans = min(t[d * 2].ans, t[d * 2 + 1].ans);
}

void add(int d, int l, int r, int ll, int rr, int z) {
	if (ll <= l && r <= rr) {
		t[d].ans = min(t[d].ans, z);
		t[d].la = min(t[d].la, z);
		return;
	}
	pushdown(d);
	int mid = (l + r) / 2;
	if (ll <= mid)
		add(d * 2, l, mid, ll, rr, z);
	if (rr > mid)
		add(d * 2 + 1, mid + 1, r, ll, rr, z);
	t[d].ans = min(t[d * 2].ans, t[d * 2 + 1].ans);
}

int ask(int d, int l, int r, int ll, int rr) {
	if (ll <= l && r <= rr)
		return t[d].ans;
	pushdown(d);
	int mid = (l + r) / 2, ans = 1000000000;
	if (ll <= mid)
		ans = min(ans, ask(d * 2, l, mid, ll, rr));
	if (rr > mid)
		ans = min(ans, ask(d * 2 + 1, mid + 1, r, ll, rr));
	return ans;
}

int main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	for (int i = 1; i <= n; i++)
		cin >> k[i];
	bu(1, 1, n);
	for (int i = 1; i <= n; i++) {
		int ans = 1000000000, tmp = 1000000000;
		tmp = ask(1, 1, n, max(1, i - 1), min(n, i + a[i] - 1));
		ans = ask(1, 1, n, max(1, i - a[i]), i);
		if (i - 1 == 0)
			tmp = 0;
		if (i - a[i] <= 0)
			ans = 0;
		ans++, tmp++;
		add(1, 1, n, max(1, i - a[i]), i, ans);
		add(1, 1, n, max(1, i - 1), min(n, i + a[i] - 1), tmp);
	}
	cout << ask(1, 1, n, n, n);
}
```

记得点赞谢谢喵。

---

## 作者：喵仔牛奶 (赞：6)

## Solution

下文提及的人都是留下的人。

性质：在最优解中，若 $b_i=1$，则 $[i,i+a_i)$ 内最多只有一个人，设其为 $j$，$b_i=b_j$ 且 $j+a_j>i+a_j$。对于 $b_i=-1$ 同理。

证明：
- 只证明 $b_i=1$，对于 $b_i=-1$ 同理。
- 如果有多个，保留覆盖 $j+a_j$ 最大的，覆盖区间不会变小，可得更优解。
- 如果一个人且 $j+a_j\le i+a_j$，去掉可得更优解。

称“转化问题”为将原问题的 $k_i$ 全部变成 $\infty$ 后的问题。分讨强度是否耗尽，可以发现原问题的最优解和在转化问题中合法，转化问题的最优解在原问题中也合法。故两者答案相等，只需要考虑转化问题。

最左边被选中的人一定覆盖了 $1$，否则后面的人覆盖时两者互相面对就不合法。

考虑 DP。从左到右考虑，设 $f_{i,j}$ 为前 $i$ 个表演者覆盖了 $[1,j]$ 的最小操作数。

转移较为显然：
- 不留下：$f_{i,j}\gets f_{i-1,j}$。
- 向左：$f_{i,i}\gets\min_{j\in[i-a_i,i-1]}\{f_{i-1,j}\}+1$。
- 向右：$f_{i,i+a_i-1}\gets\min_{j\in[i-1,n]}\{f_{i-1,j}\}+1$。

注意到 $\{f_i\}$ 仅由 $\{f_{i-1}\}$ 转移来，通过滚动数组可以将问题变为单点修改与区间求 min。使用线段树维护即可。时间复杂度 $\mathcal{O}(n\log n)$。

---

## 作者：ykzzldz (赞：3)

首先，最优方案中给了钱的表演者是不会因为被喷酒而退场的，否则删除这个表演者对喷酒的范围不会产生影响。

其次，$k$ 是骗人的，代码中不读进来都行。考虑选择的两个表演者的喷酒范围分别为 $[l_1,r_1]$ 和 $[l_2,r_2]$（假设 $l_1\le l_2$），若 $r_2\le r_1$，那么第二个表演者显然没有存在的必要，于是我们只考虑 $r_1\le r_2$ 的情况。分几种情况讨论：

- $b_1=1,b_2=-1$：两个表演者互不影响

- $b_1=-1,b_2=1$：由上面的分析知，不会出现这种情况

- $b_1=b_2=1$：此时就算 $k_1=0$，第二个表演者仍旧会接着 $r_1$ 继续喷酒，所以无论 $k$ 的值是多少，喷酒的范围都是 $[l_1,r_2]$

- $b_1=b_2=-1$：与上面类似，这里就不多赘述了

分析完性质，就可以开始 dp 了。设 $f_{i,j}$ 表示前 $i$ 个表演者的喷酒范围为 $[1,j]$ 的最小代价。

- $f_{i,j}=f_{i-1,j}$：不选择第 $i$ 个表演者

- $f_{i,\min(n,i+a_i-1)}=\min_{j=i-1}^nf_{i-1,j}$，向右喷酒

- $f_{i,i}=\min_{j=\max(0,i-a_i)}^{i-1}f_{i-1,j}$，向左喷酒

实现的时候要注意一个细节，一定要先转移向右喷酒再转移向左喷酒，否则就可以让当前的表演者既向左又向右，这种情况显然不合法。

这个转移可以用单点修改区间求最小值的线段树维护，复杂度 $O(n\log n)$。下面给出代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+10;
struct tree{
	int l,r,pre;
}t[N<<2];
void build(int p,int l,int r){
	t[p].l=l,t[p].r=r;
	if(l==r){
		if(l)t[p].pre=1e9;
		return;
	}
	int mid=l+r>>1;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
	t[p].pre=min(t[p*2].pre,t[p*2+1].pre);
}
void change(int p,int x,int y){
	if(t[p].l==t[p].r){
		t[p].pre=min(t[p].pre,y);
		return;
	}
	int mid=t[p].l+t[p].r>>1;
	if(x<=mid)change(p*2,x,y);
	else change(p*2+1,x,y);
	t[p].pre=min(t[p*2].pre,t[p*2+1].pre);
}
int ask(int p,int x,int y){
	if(x<=t[p].l&&t[p].r<=y){
		return t[p].pre;
	}
	int mid=t[p].l+t[p].r>>1,ans=1e9;
	if(x<=mid)ans=min(ans,ask(p*2,x,y));
	if(y>mid)ans=min(ans,ask(p*2+1,x,y));
	return ans;
}
int n,a;
int main(){
	cin>>n;
	build(1,0,n);
	for(int i=1;i<=n;i++){
		cin>>a;
		change(1,min(n,i+a-1),ask(1,i-1,n)+1);
		change(1,i,ask(1,max(0,i-a),i-1)+1);
	}
	cout<<ask(1,n,n);
	return 0;
}
```

---


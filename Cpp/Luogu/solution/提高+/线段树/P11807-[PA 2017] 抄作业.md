# [PA 2017] 抄作业

## 题目背景


译自 [PA 2017](https://sio2.mimuw.edu.pl/c/pa-2017-1/) R3T2。

TL=5~10s，ML=512MB。

「你抄就抄吧，但是稍微改改，别和我的一模一样就行。」


## 题目描述

有 $m$ 个长度为 $n$ 的非负整数序列。第 $i$ 个序列的第 $j$ 项为 $a_{i,j}$。

给定 $a_{1,1},a_{1,2},\cdots,a_{1,n}$。

对于 $2\le i\le m$，给定 $p_i,x_i$，表示：

- $\forall 1\le j\le n$ 满足 $j\neq p_i$，有 $a_{i,j}=a_{i-1,j}$；
- $a_{i,p_i}=x_i$。

将这 $m$ 个序列以字典序为第一关键字，编号为第二关键字排序，输出排序后的序列编号。


## 说明/提示

- $1\le n\le 5\times 10^5$；
- $2\le m\le 5\times 10^5$；
- $0\le a_{1,i},x_i\le 10^9$；
- $1\le p_i\le n$。

## 样例 #1

### 输入

```
5 8
4 2 1 7 3
3 6
1 2
2 5
5 5
1 5
1 4
1 5```

### 输出

```
3 4 5 1 2 7 6 8```

# 题解

## 作者：ForgetOIDuck (赞：1)

为了这道题特意学了在收藏夹里吃灰三年的主席树。

### 题意

有 $m$ 个长度为 $n$ 的序列 $a_i$。给定 $a_1$，并且 $\forall2\le i\le m$ 都满足 $a_i$ 与 $a_{i-1}$ 只在一个位置上不同，且给定不同位置及对应 $a_i$ 的值。求这 $m$ 个序列按字典序排序后的序列编号。

### 思路

最朴素想法肯定是把每个序列单独抠出来排序。问题在于一大堆数如何比较两个序列 $i, j$ 字典序大小。

都朴素到这个地步了你就别想着暴力比较了。我们使用一种叫做二$\tiny{分}$哈$\tiny{希}$的东西，二分一个位置 $p$ 比对 $i,j$ 两个哈希 $[1,p]$ 部分是否不同，借此可以找到第一个不一样的地方，然后就可以比大小了；若是超出去了就说明两个相等了，比较 $i,j$ 本身数值大小即可。

把每个序列抠出来是 $O(mn)$ 的，排序加上比较函数本身复杂度是 $O(m \log m \log n)$ 的。预处理前缀哈希值的空间也是 $O(mn)$ 的。

这样你就获得了一份 $O($ 不能过 $)$ 的优秀代码。

想想是否有什么条件被我们漏掉了：那当然是相邻两个序列之间只有一个不同！我们想到了主席树的优秀性质：每次只改一个点，只动一条链，便不需要把每个序列及其哈希抠出来；而前缀哈希甚至是区间哈希刚好可以使用线段树轻松维护，我们就高兴地过掉了这道题。

时间复杂度 $O((n+m)\log n+m\log m\log n)$，毫无卡常必要。

一些细节：

- 不仅要存哈希值也要存原来数组的值，找到不同位置后需要比较原来值的大小。

- 空间需要开到 $2\times 10^7$。

- 为防止卡哈希需要使用一些不常见的模数及基数。

- 开着 long long 总没坏处。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 998244353;
ll n, m, a[500002], rt[500002], idx = 1, pw[500002], ans[500002];
struct tree{
	ll x, hs, ls, rs;
}tr[20000002];
void build(ll x, ll l, ll r) {
	if (l == r) return tr[x] = {a[l], a[l] * pw[n - l] % mod, 0, 0}, void(0);
	ll mid = l + r >> 1;
	tr[x].ls = ++ idx, build(idx, l, mid);
	tr[x].rs = ++ idx, build(idx,mid+1,r);
	tr[x].hs = (tr[tr[x].ls].hs + tr[tr[x].rs].hs) % mod;
}
ll update(ll x, ll l, ll r, ll p, ll c) {
	if (l == p && r == p) return tr[++ idx] = {c, c * pw[n - l] % mod, 0, 0}, idx;
	ll mid = l + r >> 1, t;
	if (mid >= p) return t = update(tr[x].ls, l, mid, p, c), tr[++ idx] = {0, (tr[t].hs + tr[tr[x].rs].hs) % mod, t, tr[x].rs}, idx;
	if (mid <  p) return t = update(tr[x].rs,mid+1,r, p, c), tr[++ idx] = {0, (tr[tr[x].ls].hs + tr[t].hs) % mod, tr[x].ls, t}, idx;
}
ll query(ll lx, ll rx, ll l, ll r) {
	if (l == r) return tr[lx].hs == tr[rx].hs ? 2 : (tr[lx].x < tr[rx].x);
	ll mid = l + r >> 1;
	if (tr[tr[lx].ls].hs != tr[tr[rx].ls].hs) return query(tr[lx].ls, tr[rx].ls, l, mid);
	return query(tr[lx].rs, tr[rx].rs,mid+1,r);
}

bool cmp(ll az, ll bz) {
	ll t = query(rt[az], rt[bz], 1, n);
	if (t == 2) return az < bz;
	return t;
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0); 
	pw[0] = 1;
	cin >> n >> m;
	ll bs = 131; 
	rt[1] = 1;
	for (ll i = 1; i <= n; i ++ ) pw[i] = pw[i - 1] * bs % mod, cin >> a[i];
	build(1, 1, n);
	for (ll i = 1; i <= m; i ++ ) ans[i] = i;
	for (ll i = 2, p, x; i <= m; i ++ ) cin >> p >> x, rt[i] = update(rt[i - 1], 1, n, p, x);
	sort(ans + 1, ans + m + 1, cmp);
	for (ll i = 1; i <= m; i ++ ) cout << ans[i] << (i == m ? "\n" : " ");
} 
```

---

## 作者：TruchyR (赞：1)

知识点：主席树、哈希、归并排序。

赛时哈希炸了被队友骂死了。

发现每个序列相比于上一个只有一个地方不一样，所以考虑主席树维护，每次就是在上一个版本上单点修改。

排序可以考虑归并排序，只需要稳定 $O(m\log m)$ 次比较。

那么如何比较两个序列的字典序大小呢？

主席树每个节点考虑维护哈希值，比较两个区间的时候可以在主席树上二分找到第一个不一样的位置，然后比较即可。

一次比较的复杂度是 $O(\log n)$，所以总复杂度是 $O(m\log n\log m)$ 的。

实现是容易的。

```cpp
//PA Mashup #2 赛时代码 
#include<bits/stdc++.h>
#define CKE if(CHECK)
#define FRE if(FIL)
#define MX 500005
#define int long long
using namespace std;
const int mod=2003880001,W=1000000009;//哈希的base和mod 
const int CHECK=0,FIL=0;int read();
int n,m,a[MX],P[MX],X[MX],qp[MX];
class ZxTree{
	public:
	int tree[MX*40],lazy[MX*40],son[MX*40][2];
	int root[MX]={1},cnt=1,srt[MX],by[MX];
	void create(int id){root[id]=++cnt;}
	//建树 
	void build(int t,int l,int r){
		if(l>=r){tree[t]=a[l];return;}
		int mid=(l+r)>>1;
		son[t][0]=++cnt;son[t][1]=++cnt;
		build(son[t][0],l,mid);
		build(son[t][1],mid+1,r);
		tree[t]=(tree[son[t][0]]*qp[r-mid]+tree[son[t][1]])%mod;
	}
	//单点修 
	void change(int rt,int t,int p,int l,int r,int w){
		if(l>=r){tree[t]=w;return;}
		int mid=(l+r)>>1;
		if(p<=mid){
			son[t][1]=son[rt][1],son[t][0]=++cnt;
			change(son[rt][0],son[t][0],p,l,mid,w);
		}else{
			son[t][0]=son[rt][0],son[t][1]=++cnt;
			change(son[rt][1],son[t][1],p,mid+1,r,w);
		}
		tree[t]=(tree[son[t][0]]*qp[r-mid]+tree[son[t][1]])%mod;
	}
	//比较两个序列大小关系 
	int comp(int t,int rt,int l,int r){
		if(tree[t]==tree[rt]) return t<rt; //如果一样比编号 
		if(l>=r) return tree[t]<tree[rt];
		int mid=(l+r)>>1;
		if(tree[son[t][0]]!=tree[son[rt][0]]) //如果左子树不一样，说明第一个不同的位置在左子树 
			return comp(son[t][0],son[rt][0],l,mid);
		else //反之，第一个不同的地方在右子树 
			return comp(son[t][1],son[rt][1],mid+1,r);
	}
	void Sort(int l,int r){//归并排序 
		if(l>=r) return;
		int mid=(l+r)>>1;
		Sort(l,mid);Sort(mid+1,r);//先排序完左右两侧 
		int Li=l,Ri=mid+1,o=l;
		for(int i=l;i<=r;i++) by[i]=srt[i];
		while(Li<=mid || Ri<=r){
			//双指针 
			if(Li>mid){srt[o++]=by[Ri++];}
			else if(Ri>r){srt[o++]=by[Li++];}
			else if(comp(root[by[Li]],root[by[Ri]],1,n)){srt[o++]=by[Li++];}
			else{srt[o++]=by[Ri++];}
		}
	}
}T;
signed main(){
	n=read();m=read();
	//这里序列的标号是0~m-1而不是1~m
	//因为奇怪的原因赛时给权值都+1了，实际应该不用 
	for(int i=1;i<=n;i++) a[i]=read()+1;
	qp[0]=1;
	for(int i=1;i<=n;i++) qp[i]=qp[i-1]*W%mod;
	T.build(1,1,n); 
	for(int i=1;i<m;i++){
		P[i]=read();X[i]=read()+1;T.create(i);
		T.change(T.root[i-1],T.root[i],P[i],1,n,X[i]);
		//用主席树维护，每次在上个版本单点修 
	}
 	for(int i=0;i<m;i++) T.srt[i]=i;
	T.Sort(0,m-1);
	for(int i=0;i<m;i++) printf("%lld ",T.srt[i]+1);
	return 0;
}
int read(){
	int Ca=0;char Cr=' ';int Cf=1;
	while(Cr<'0' || Cr>'9'){Cr=getchar();if(Cr=='-'){Cf=-1;}}
	while(Cr>='0' && Cr<='9'){Ca=Ca*10+Cr-48;Cr=getchar();}
	return Ca*Cf;
}
```

---

## 作者：gcx12012 (赞：1)

### 前言
主席树模板题。
### Solution
只有单点修改，我们考虑通过主席树来维护。

题目要求我们排序这 $m$ 个数组，快排或者归并排序的 $1\log$ 显然省不掉，想一下我们如何快速比对两个数组的大小。

两个数组显然有长度为非负整数的公共前缀，因此我们只需要用主席树维护区间哈希，然后二分找到两个数组间第一个不同的位置即可。

加上前面复杂度是 $2\log$ 的，可以通过。

不知道有无 $3\log$ 老哥过了。
### Code
```
const lll B=2e9+1,mod=1e17+23;
int ls[N<<5],rs[N<<5],cnt=0,rt[N],a[N];
lll val[N<<5],p[N];
int n,m;

ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int build(int x,int l,int r){
    if(!x) x=++cnt;
    if(l==r){
        val[x]=a[l];
        return x;
    }
    int mid=(l+r)>>1;
    ls[x]=build(ls[x],l,mid);
    rs[x]=build(rs[x],mid+1,r);
    val[x]=(val[ls[x]]+val[rs[x]]*p[mid-l+1]%mod)%mod;
    return x;
}
int upd(int now,int pre,int l,int r,int u,int v){
    if(!now) now=++cnt;
    if(l==r){
        val[now]=v;
        return now;
    }
    int mid=(l+r)>>1;
    if(u<=mid) ls[now]=upd(ls[now],ls[pre],l,mid,u,v),rs[now]=rs[pre];
    else rs[now]=upd(rs[now],rs[pre],mid+1,r,u,v),ls[now]=ls[pre];
    val[now]=(val[ls[now]]+val[rs[now]]*p[mid-l+1]%mod)%mod;
    return now;
}
int com(int x,int y,int l,int r){
    if(val[x]==val[y]) return 0;
    if(l==r){
        if(val[x]<val[y]) return -1;
        else return 1;
    }
    int mid=(l+r)>>1;
    if(val[ls[x]]==val[ls[y]]) return com(rs[x],rs[y],mid+1,r);
    else return com(ls[x],ls[y],l,mid);
}
int b[N];
void sol(int l,int r){
    if(l==r) return;
    int mid=(l+r)>>1;
    sol(l,mid);
    sol(mid+1,r);
    int p1=l,p2=mid+1,p3=l;
    while(p3<=r){
        if(p1>mid) b[p3++]=a[p2++];
        else if(p2>r) b[p3++]=a[p1++];
        else{
            int p=com(rt[a[p1]],rt[a[p2]],1,n);
            if(p==-1) b[p3++]=a[p1++];
            else if(p==1) b[p3++]=a[p2++];
            else{
                if(a[p1]<a[p2]) b[p3++]=a[p1++];
                else b[p3++]=a[p2++];
            }
        }
    }
    For(i,l,r) a[i]=b[i];
}

int main()
{
    //freopen("gcx.in","r",stdin);
    //freopen("gcx.out","w",stdout);
    n=read(),m=read();
    p[0]=1;
    For(i,1,n) p[i]=p[i-1]*B%mod;
    For(i,1,n) a[i]=read();
    rt[1]=build(rt[1],1,n);
    For(i,2,m){
        int u=read(),v=read();
        rt[i]=upd(rt[i],rt[i-1],1,n,u,v);
    }
    For(i,1,m) a[i]=i;
    sol(1,m);
    For(i,1,m) cout<<a[i]<<' ';
   	return 0;
}
```

---

## 作者：Bobi2014 (赞：0)

这是一道~~可癌~~的~~毒瘤~~题。

### 前置知识

- [可持久化线段树（Part 4 要用到）](https://oi.wiki/ds/persistent-seg/)
- [字符串哈希（哈希同理）（Part 2、3、4 要用到）](https://oi.wiki/string/hash/)
- [二分（Part 3 要用到）](https://oi.wiki/basic/binary/)
- [离散化（都要用）](https://oi.wiki/misc/discrete/)

### 思路

先把数离散化再说。

#### Part 1 抄作业抄错了，还被发现了

直接暴力即可，时间复杂度 $O(nm \log n)$。

#### Part 2 抄作业抄错了，没被发现

预处理哈希前缀，对比函数时二分第一个不一样的位置，时间复杂度 $O(nm)$。

#### Part 3 抄作业抄对了，但差点被发现了

发现主席树可以存储哈希、单点修改、区间查询，维护哈希前缀的换成主席树后时间复杂度 $O(m \log m \log^{2} n)$，虽然能过，但是我们爱~~卡常~~学习，所以发现了更好的方法。

#### Part 4 抄作业抄对了，没被发现

直接使用主席树上二分，如果左儿子不相等去左儿子，否则去右儿子，时间复杂度 $O(m \log m \log n)$。

### Code

```cpp
#include<iostream>
#include<algorithm>
#define int long long
using namespace std;
const int N = 5e5 + 10,mod = 998244353;
struct opt{
	int p,x;
} ops[N];
int n,m,dat[N],power[N],o[N * 2],maxn,ans[N];
namespace SegmentTree{
	struct node{
		int l_son,r_son,hash;
	} tri[20000005];
	int root[N],cnt;
	int merge(int hash_a,int hash_b,int len_b){
		return (hash_a * power[len_b] + hash_b) % mod;
	}
	int build(int l,int r){
		int p = ++cnt;
		if(l == r){
			tri[p].hash = dat[l];
			return p;
		}
		int mid = (l + r) >> 1;
		tri[p].l_son = build(l,mid);
		tri[p].r_son = build(mid + 1,r);
		tri[p].hash = merge(tri[tri[p].l_son].hash,tri[tri[p].r_son].hash,r - mid);
		return p;
	}
	int update(int pre,int l,int r,int pos,int val){
		int p = ++cnt;
		tri[p] = tri[pre];
		if(l == r){
			tri[p].hash = val;
			return p;
		}
		int mid = (l + r) >> 1;
		if(pos <= mid){
			tri[p].l_son = update(tri[pre].l_son,l,mid,pos,val);
		}else{
			tri[p].r_son = update(tri[pre].r_son,mid + 1,r,pos,val);
		}
		tri[p].hash = merge(tri[tri[p].l_son].hash,tri[tri[p].r_son].hash,r - mid);
		return p;
	}
	pair<int,int> query(int ap,int bp,int l,int r){
		if(tri[ap].hash == tri[bp].hash){
			return {0,0};
		}
		if(l == r){
			return {tri[ap].hash,tri[bp].hash};
		}
		int mid = (l + r) >> 1;
		if(tri[tri[ap].l_son].hash == tri[tri[bp].l_son].hash){
			return query(tri[ap].r_son,tri[bp].r_son,mid + 1,r);
		}else{
			return query(tri[ap].l_son,tri[bp].l_son,l,mid);
		}
	}
}
bool cmp(int a,int b){
	pair<int,int> hash = SegmentTree::query(SegmentTree::root[a],SegmentTree::root[b],1,n);
	int hash_a = hash.first,hash_b = hash.second;
	if(hash_a == hash_b){
		return a < b;
	}
	return hash_a < hash_b;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	cin >> n >> m;
	for(int i = 1;i <= n;i ++){
		cin >> dat[i];
		o[i] = dat[i];
	}
	for(int i = 1;i < m;i ++){
		cin >> ops[i].p >> ops[i].x;
		o[i + n] = ops[i].x;
	}
	sort(o + 1,o + n + m);
	maxn = unique(o + 1,o + n + m) - o - 1;
	power[0] = 1;
	for(int i = 1;i <= n;i ++){
		power[i] = (power[i - 1] * maxn) % mod;
	}
	for(int i = 1;i <= n;i ++){
		dat[i] = lower_bound(o + 1,o + maxn + 1,dat[i]) - o;
	}
	SegmentTree::root[1] = SegmentTree::build(1,n);
	for(int i = 1;i < m;i ++){
		ops[i].x = lower_bound(o + 1,o + maxn + 1,ops[i].x) - o;
		SegmentTree::root[i + 1] = SegmentTree::update(SegmentTree::root[i],1,n,ops[i].p,ops[i].x);
	}
	for(int i = 1;i <= m;i ++){
		ans[i] = i;
	}
	sort(ans + 1,ans + m + 1,cmp);
	for(int i = 1;i <= m;i ++){
		cout << ans[i] << " ";
	}
	return 0;
}
```

---

## 作者：114514lhc (赞：0)

一看算法有哈希，便能想到把区间值转化成哈希值。   
用可持久化维护区间哈希值和，每次把 $p_i$ 位置的数修改成 $x_i\times s^{p_i}$（$s$ 为哈希时的质数），另外，对于叶子节点，还要维护节点原本值（因为原本值不经过取余运算）。   
对于字典序排序的要求，可以用 sort 排序，自己编辑排序函数。  
想要比较字典序大小，直接比较肯定不行，因为哈希值是经过取余运算的，所以我们必须搜到树的最底层。如果左子树区间和不等，只需搜左子树就能比出结果，否则就搜右子树，到叶子结点依靠原本值比较出字典序，相同就比较编号。   
代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=11451400;
int n,m,tot,ver[N],ls[N],rs[N],v[N],v2[N],ans[N];//线段树
int x1=131,p1=998244353,m1[N];//哈希用品
void pu(int t){v[t]=v[ls[t]]+v[rs[t]];}
void hmxa(int t1,int &t2,int l,int r,int x,int k,int k2)
{
    if(!t2)t2=++tot;
    if(l==r)
    {
        v[t2]=k;
        v2[t2]=k2;
        return;
    }
    int mid=(l+r)/2;
    if(x<=mid)rs[t2]=rs[t1],hmxa(ls[t1],ls[t2],l,mid,x,k,k2);
    else ls[t2]=ls[t1],hmxa(rs[t1],rs[t2],mid+1,r,x,k,k2);
    pu(t2);
}
int dfs(int t1,int t2,int l,int r)//比字典序
{
    if(l==r)
    {
        if(v[t1]!=v[t2])return v2[t1]<=v2[t2];
        return 2;//值相同
    }
    int mid=(l+r)/2;
    if(v[ls[t1]]!=v[ls[t2]])return dfs(ls[t1],ls[t2],l,mid);
    else return dfs(rs[t1],rs[t2],mid+1,r);
}
int ck(int x,int y)//排序函数
{
    int u=dfs(ver[x],ver[y],1,n);
    if(u==2)return x<=y;
    return u;
}
signed main()
{
    cin>>n>>m;
    m1[0]=1;
    for(int i=1;i<=n;i++)m1[i]=m1[i-1]*x1%p1;
    for(int i=1;i<=n;i++)
    {
        int x;
        cin>>x;
        hmxa(ver[1],ver[1],1,n,i,x*m1[i],x);
    }
    ans[1]=1;
    for(int i=2;i<=m;i++)
    {
        int x,y;
        cin>>x>>y;
        hmxa(ver[i-1],ver[i],1,n,x,y*m1[x],y);
        ans[i]=i;
    }
    sort(ans+1,ans+1+m,ck);
    int st=0;
    for(int i=1;i<=m;i++)cout<<ans[i]<<' ';
	return 0;
}

```

---


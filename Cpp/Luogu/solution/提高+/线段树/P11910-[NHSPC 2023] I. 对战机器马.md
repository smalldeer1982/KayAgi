# [NHSPC 2023] I. 对战机器马

## 题目描述

这天，小齐与小田各自派出 $n$ 匹机器马进行 $n$ 回一对一的对战，双方的出赛顺序均已排定且不得再更改。已知对于 $1 \le i \le n$，小齐第 $i$ 场出赛的机器马原始战力是 $a_i$，小田第 $i$ 场的机器马原始战力则是 $b_i$，且 $0 \le a_i, b_i < P$，其中 $P$ 是一个给定的正整数。每一场对战时，战力高者获胜。

小田为了赢得更多的胜利，研发出了能调整这些机器马战力的燃料，每一种燃料有一个魔力值 $m$，当原始战力 $b_i$ 的机器马使用了魔力值 $m$ 的燃料，战力就会变成 $(b_i + m) \% P$，这里 $\%$ 表示取余数的运算。对小田来说，如果每一匹机器马都可以挑选不同魔力值的燃料，当然就太好了，但是由于某些限制，小田只能生产出最多两种燃料，且每一匹机器马都必须使用恰一种燃料才可以。换句话说，小田可以选择两个非负整数 $s$ 与 $t$，若 $(b_i + s) \% P > a_i$ 或 $(b_i + t) \% P > a_i$，则小田可以赢得第 $i$ 场比赛的胜利。小田希望能挑选出两种魔力值，以获得最多的胜利。请计算并输出小田的最大胜利场次数。请注意，小田的每一匹机器马必须使用所生产的两种燃料之一，即使原先战力已经胜过对方的机器马也必须挑选其中之一使用。

举例来说，假设 $P=10$，小齐与小田的原始战力如下表。若小田选择生产魔力值 $s=1$ 与 $t=6$ 的两种燃料，那么他可以战胜 $5$ 场比赛。另，小田没有战胜 $6$ 场以上比赛的可能，因此所求答案是 $5$。

$$\begin{array}{|l|l|l|l|l|l|l|l|}
\hline
\text{小齐战力 } a_i & 6 & 7 & 9 & 4 & 8 & 5 & 5 \\
\hline
\text{小田战力 } b_i & 3 & 7 & 6 & 9 & 9 & 1 & 5 \\
\hline
s=1 \text{ 与 } t=6 & 3 + 6 > 6 & 7 + 1 > 7 & & (9 + 6) \% 10 > 4 & & 1 + 6 > 5 & 5 + 1 > 5 \\
\hline
\end{array}$$

## 说明/提示

### 测试数据限制

* $1 \le n \le 2 \times 10^5$。
* $1 \le P \le 10^9$。
* $0 \le a_i < P$。
* $0 \le b_i < P$。
* 输入的数皆为整数。

### 评分说明

本题共有五组子任务，条件限制如下所示。
每一组可有一或多个测试数据，该组所有测试数据皆需答对才可获得该组分数。

|  子任务  |  分数  | 额外输入限制 |
| :------: | :----: | ------------ |
| 1 | $5$ | $n \le 100, P \le 100$ |
| 2 | $7$ | $n \le 100, P \le 10000$ |
| 3 | $17$ | $n \le 5000$ |
| 4 | $40$ | 对于所有 $i$，$b_i \le a_i$ |
| 5 | $31$ | 无额外限制 |

## 样例 #1

### 输入

```
5 6
3 1 5 3 4
0 2 3 4 0```

### 输出

```
4```

## 样例 #2

### 输入

```
7 10
6 7 9 4 8 5 5
3 7 6 9 9 1 5```

### 输出

```
5```

# 题解

## 作者：wangyizhi (赞：3)

[**题目传送门**](https://www.luogu.com.cn/problem/P11910)

其实是很简单的题 ~~，但赛时脑抽了没写出来，赛后 40min 才过~~。

## 题目分析

考虑在什么情况下 $(b_i+x)\bmod P > a_i$。

我们显然只需考虑 $0\le x<P$ 的情况，其余在模 $P$ 意义下依然可以化为这种情况。

分两种情况讨论：

+ $a_i\ge b_i$

  此时比较显然，需满足 $a_i<b_i+x<P$，解得 $a_i-b_i+1\le x\le P-b_i-1$。

+ $a_i<b_i$

  此时有两种情况：

  当 $b_i+x<P$ 时，只需满足 $0\le x\le P-b_i-1$。

  当 $b_i+x\le P$ 时，此时 $(b_i+x)\bmod P = b_i+x-P$，需满足 $b_i+x-P > a_i$，即 $a_i-b_i+P+1\le x\le P-1$。

显然可以先离散化。因为在一个小段中无论 $x$ 取什么值答案都不变。

然后考虑枚举 $s$，此时我们需要将所有包括 $s$ 的数都去掉，对于剩下的，我们可以将这些区间扔到线段树上，然后求最大值就行了。

在枚举 $s$ 的过程中，考虑在进一个数的区间时删掉这个数的贡献，在出一个数的区间时加回这个数的贡献。这样总的操作次数为 $O(n)$。于是总复杂度 $O(n\log n)$。

## AC Code

```cpp
// by wangyizhi(571247)
#include<bits/stdc++.h>
//#include<bits/extc++.h>
using namespace std;
using ll=long long;
using ld=long double;
//#define int ll
using pii=pair<int,int>;
//bool Mst;
const int N=1e6+5;
int a[N],b[N],lsh[N];
int t[N<<2],tag[N<<2];
vector<int> in[N],out[N];
inline int ls(int id){return id<<1;}
inline int rs(int id){return id<<1|1;}
inline void push_up(int id){t[id]=max(t[ls(id)],t[rs(id)]);}
inline void __upd(int id,int x){t[id]+=x,tag[id]+=x;}
inline void push_down(int id){__upd(ls(id),tag[id]),__upd(rs(id),tag[id]),tag[id]=0;}
void update(int l,int r,int v,int id,int nl,int nr)
{
	if(l<=nl&&r>=nr) return __upd(id,v),void();
	push_down(id);
	int m=(nl+nr)>>1;
	if(l<=m) update(l,r,v,ls(id),nl,m);
	if(r>m) update(l,r,v,rs(id),m+1,nr);
	push_up(id);
}
int qry(){return t[1];}
#define root 1,1,c
//bool Med;
signed main()
{
//	cerr<<"Memory Size: "<<abs((&Med)-(&Mst))/1024.0/1024<<" MB\n";
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int n,p,c=0,res=0,ans=0;
	cin>>n>>p;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>b[i];
	for(int i=1;i<=n;i++)
	{
		if(a[i]>=b[i]) lsh[++c]=a[i]-b[i]+1,lsh[++c]=p-b[i]-1;
		else lsh[++c]=0,lsh[++c]=p-b[i]-1,lsh[++c]=a[i]-b[i]+1+p,lsh[++c]=p-1;
	}
	sort(lsh+1,lsh+c+1),c=unique(lsh+1,lsh+c+1)-lsh-1;
	auto g=[&](int x){return lower_bound(lsh+1,lsh+c+1,x)-lsh;};
	auto upd=[&](int i,int v)
	{
		if(a[i]>=b[i])
		{
			if(a[i]-b[i]+1<=p-b[i]-1) update(g(a[i]-b[i]+1),g(p-b[i]-1),v,root);
		}
		else
		{
			update(g(0),g(p-b[i]-1),v,root);
			if(a[i]-b[i]+1+p<=p-1) update(g(a[i]-b[i]+1+p),g(p-1),v,root);
		}
	};
	for(int i=1;i<=n;i++)
	{
		if(a[i]>=b[i])
		{
			if(a[i]-b[i]+1<=p-b[i]-1) in[g(a[i]-b[i]+1)].push_back(i),out[g(p-b[i]-1)].push_back(i);
		}
		else
		{
			in[g(0)].push_back(i),out[g(p-b[i]-1)].push_back(i);
			if(a[i]-b[i]+1+p<=p-1) in[g(a[i]-b[i]+1+p)].push_back(i),out[g(p-1)].push_back(i);
		}
	}
	for(int i=1;i<=n;i++) upd(i,1);
	for(int k=1;k<=c;k++)
	{
		for(int i:in[k]) upd(i,-1),res++;
		ans=max(ans,res+qry());
		for(int i:out[k]) upd(i,1),res--;
	}
	cout<<ans<<"\n";
	return 0;
}
```

---


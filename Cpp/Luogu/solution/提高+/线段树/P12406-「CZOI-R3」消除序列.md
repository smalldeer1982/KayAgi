# 「CZOI-R3」消除序列

## 题目描述

有两个长为 $n$ 的排列 $a,b$，你可以做任意次操作：

- 将 $a$ 循环左移一位。若在进行操作前 $a_1\neq 0$，则消耗 $x$ 点代价。
- 将 $a$ 循环右移一位。若在进行操作前 $a_1\neq 0$，则消耗 $y$ 点代价。
- 交换 $x,y$。消耗 $z$ 点代价。
- 若 $a_1=b_1$，将 $b$ 循环左移一位，同时令 $a_1=0$。不消耗代价。

求出让对于 $\forall 1\le i\le n$ 有 $a_i=0$ 的最小代价，显然一定可以通过若干次操作达成目标。

$\dag$：设某次循环左移操作前序列为 $a_1,a_2,\cdots,a_{n-1},a_n$，则操作后序列为 $a_2,\cdots,a_{n-1},a_n,a_1$。设某次循环右移操作前序列为 $a_1,a_2,\cdots,a_{n-1},a_n$，则操作后序列为 $a_n,a_1,a_2,\cdots,a_{n-1}$。

## 说明/提示

**【数据范围】**

**本题采用捆绑测试。**

- Subtask #1（$10\text{ pts}$）：$n\le 10$。
- Subtask #2（$25\text{ pts}$）： $x=y=z$。
- Subtask #3（$25\text{ pts}$）：$n\le 10^3$。**依赖 Subtask #1。**
- Subtask #4（$40\text{ pts}$）：无特殊性质。**依赖 Subtask #2 #3。**

对于 $100\%$ 的数据，$1\le n\le 10^6$，$a,b$ 为长度为 $n$ 的排列。$1\le x,y,z\le 10^6$。

## 样例 #1

### 输入

```
2 1 1 1
1 2
2 1```

### 输出

```
1```

## 样例 #2

### 输入

```
5 4 3 2
1 4 3 2 5
5 1 4 2 3```

### 输出

```
3```

# 题解

## 作者：cybermage_liu (赞：3)

# 思路
因为 $b$ 数组每次只能左移 $1$ 位，所以对于 $a$ 的每个数字的操作顺序是固定的。

看到可以交换 $x$ 和 $y$，求最小代价，那么当前的 $x$ 和 $y$ 有两种状态，可以和初始一样，也可以是交换后的。

不难想到 DP：

* $f_{i,0}$ 表示对于前 $i$ 个数，$x$ 和 $y$ 在执行完第 $i$ 个操作后与初始状态相同的最小代价。
* $f_{i,1}$ 表示对于前 $i$ 个数，$x$ 和 $y$ 在执行完第 $i$ 个操作后与初始状态不同的最小代价。

易得：
$$
f_{i,0}=\min(f_{i-1,0}+w1\times x,f_{i-1,0}+w2\times y,f_{i-1,1}+w1\times x+z,f_{i-1,1}+w2\times y+z)
\\
f_{i,1}=\min(f_{i-1,0}+w1\times y+z,f_{i-1,0}+w2\times x+z,f_{i-1,1}+w1\times y,f_{i-1,1}+w2\times x)
$$

$w1$ 表示将 $b_i$ 在 $a$ 中的位置左移到当前第一个位置的经过的没有操作过的数的个数，$w2$ 同理，表右移。

初始 $f_{0,0}=0,f_{0,1}=z$，答案为 $\min(f_{n,0},f_{n,1})$。

那么怎么计算 $w1$ 和 $w2$ 呢？答案是树状数组。

因为右移不好处理，所以考虑开二倍空间，拆环为链。

那么这道题就做出来了，时间复杂度 $O(n\log n)$。

考虑到 $f$ 的转移状态只和上一次的有关，可以将其由二维数组转为两个变量，如下代码。
# AC code
```cpp
#include<bits/stdc++.h>
#define int long long
#define lowbit(i) (i&-i)
using namespace std;
const int N=2e6+5;
int a[N],b[N],t[N],p[N],n;
//树状数组
void change(int x,int y){
	for(int i=x;i<=2*n;i+=lowbit(i)) t[i]+=y;
}
int query(int x){
	int res=0;
	for(int i=x;i;i-=lowbit(i)) res+=t[i];
	return res;
}
int query_(int x,int y){
	if(x>y) y+=n;//特殊处理避免出错
	if(y-x>=n) y-=n;
	return query(y)-query(x-1);
}
signed main(){
	int x,y,z,l=1;//l 为当前第一个数在原序列中的位置 
	cin>>n>>x>>y>>z;
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]),p[a[i]]=i;//p 存位置 
	for(int i=1;i<=n;i++) scanf("%lld",&b[i]);
	for(int i=1;i<=2*n;i++) change(i,1);
	int f1=z,f0=0;//注意 f1 初始为 z 
	for(int i=1;i<=n;i++){
		int w1=query_(l,p[b[i]])-query_(p[b[i]],p[b[i]]);
		int w2=query_(p[b[i]]+1,l+n);
		int f00=f0,f11=f1;
		f0=min(min(f00+w1*x,f00+w2*y),min(f11+w1*x+z,f11+w2*y+z));
		f1=min(min(f00+w1*y+z,f00+w2*x+z),min(f11+w1*y,f11+w2*x));
		//更新树状数组和 l 
		change(p[b[i]],-1);
		change(p[b[i]]+n,-1);
		l=p[b[i]];
	}
	cout<<min(f0,f1);
	return 0;
}
```

---

## 作者：CaiZi (赞：2)

难度不高，但是处理起来非常绕，容易写错。

按照题面的 $4$ 个操作按照顺序记为操作 $1,2,3,4$。

我们发现，最优方案中，我们如果希望消除某一个数，则只可能连续使用操作 $1$、连续使用操作 $2$、使用一次操作 $3$ 后连续使用操作 $1$、使用一次操作 $3$ 后连续使用操作 $2$。这是显然的，首先我们不会同时使用操作 $1$ 和操作 $2$，因为它们会互相抵消。然后我们不会在中途使用操作 $3$，如果使用操作 $3$ 后更优，则将其移动到消除完那个数后更优；否则，不使用它更优。

这启发我们进行 DP。我们需要找到 $b_i$ 在 $a$ 中的位置，考虑记 $p_{a_i}=i$，那么 $b_i$ 在 $a$ 中的位置就为 $p_{b_i}$。设 $f_{i,0}$ 表示处理消除完第 $i$ 个数，且在处理第 $i$ 个数前共用了偶数次 $3$ 操作（即当前 $x,y$ 为初始时的）；$f_{i,1}$ 表示处理到第 $i$ 个数，且在处理第 $i$ 个数前共用了奇数次 $3$ 操作（即当前 $x,y$ 为交换后的）。初始状态为 $f_{0,0}=0,f_{0,1}=\infty$。那么有转移：
$$\begin{cases}f_{i,0}=\min\{f_{i-1,0},z+f_{i-1,1}\}+\min\{x\operatorname{moveleft}(p_{b_{i-1}},p_{b_i}),y\operatorname{moveright}(p_{b_{i-1}},p_{b_i})\}\\f_{i,1}=\min\{z+f_{i-1,0},f_{i-1,1}\}+\min\{y\operatorname{moveleft}(p_{b_{i-1}},p_{b_i}),x\operatorname{moveright}(p_{b_{i-1}},p_{b_i})\}\end{cases}$$
其中 $\operatorname{moveleft}(l,r)$ 和 $\operatorname{moveright}(l,r)$ 分别表示：当位置 $l$ 被移动到位置 $1$ 后，将位置 $r$ 通过操作 $1/2$ 移动到位置 $1$ 所需次数。

考虑使用树状数组维护，初始时所有位置均为 $1$，消除完第 $i$ 个数就将 $p_{b_i}$ 变为 $0$。记 $\operatorname{sum}(l,r)$ 为某一时刻树状数组中 $[l,r]$ 位置的和，然后我们可以得到这两个函数的值：
$$\begin{cases}\operatorname{moveleft}(l,r)=\operatorname{sum}(l,r-1)&(l<r)\\\operatorname{moveleft}(l,r)=\operatorname{sum}(1,r-1)+\operatorname{sum}(l,n)&(l>r)\\\operatorname{moveright}(l,r)=\operatorname{sum}(1,l)+\operatorname{sum}(r+1,n)&(l<r)\\\operatorname{moveright}(l,r)=\operatorname{sum}(r+1,l)&(l>r)\end{cases}$$
然后就可以做了，时间复杂度 $O(n\log n)$。

代码展示：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,x,y,z,a,b[1000001],p[1000001],t[1000001],f[1000001][2],u,v;
inline void update(int i,int j){
	while(i<=n){
		t[i]+=j;
		i+=i&-i;
	}
}
inline int query(int i,int j=0){
	while(i>=1){
		j+=t[i];
		i-=i&-i;
	}
	return j;
}
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>n>>x>>y>>z;
	for(int i=1;i<=n;i++){
		cin>>a;
		p[a]=i;
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
		update(i,1);
	}
	f[0][0]=0;
	f[0][1]=LONG_LONG_MAX>>2;
	p[0]=1;
	for(int i=1;i<=n;i++){
		if(p[b[i-1]]<p[b[i]]){
			u=query(p[b[i]]-1)-query(p[b[i-1]]-1);
			v=query(p[b[i-1]])+query(n)-query(p[b[i]]);
		}
		else{
			u=query(p[b[i]]-1)+query(n)-query(p[b[i-1]]-1);
			v=query(p[b[i-1]])-query(p[b[i]]);
		}
		f[i][0]=min(f[i-1][0],z+f[i-1][1])+min(x*u,y*v);
		f[i][1]=min(f[i-1][1],z+f[i-1][0])+min(y*u,x*v);
		update(p[b[i]],-1);
	}
	cout<<min(f[n][0],f[n][1]);
	return 0;
}
```

---

## 作者：NTT__int128 (赞：2)

个人认为比较好想的一道题。

首先，我们发现，操作 $4$ 只能按 $b$ 中的顺序从左到右清零。

然后就得到了一个 $35$ 分的朴素 dp。

定义 $dp_{i,0/1}$ 表示 $b$ 中的前 $i$ 个数全清零了，没交换/交换了 $x$ 和 $y$ 的最小代价。

转移：
$$
dp_{i,0}\gets\min(dp_{i-1,0},dp_{i-1,1}+z)+\min(le\cdot x,ri\cdot y)\\
dp_{i,1}\gets\min(dp_{i-1,1}+z,dp_{i-1,1})+\min(le\cdot y,ri\cdot x)
$$
其中，$le$ 表示 $b_{i-1}$ 到 $b_i$ 在 $a$ 中向右枚举有几个没有被删的，$ri$ 是向左枚举的。

总时间复杂度：$O(n^2)$。

朴素实现代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
int n,x,y,z,a[N],p[N],b,dp[N][2];
bool del[N];
signed main(){
	cin>>n>>x>>y>>z;
	for(int i=1;i<=n;i++)cin>>a[i],p[a[i]]=i;
	int nowp=1;
	memset(dp,0x3f,sizeof dp);
	dp[0][0]=0,dp[0][1]=z;
	for(int i=1;i<=n;i++){
		cin>>b;
		int le=0,ri=0;
		for(int j=nowp;j!=p[b];j=(j+n-2)%n+1)if(!del[j])ri++;
		for(int j=nowp;j!=p[b];j=j%n+1)if(!del[j])le++;
		dp[i][0]=min(dp[i-1][0],dp[i-1][1]+z)+min(le*x,ri*y);
		dp[i][1]=min(dp[i-1][0]+z,dp[i-1][1])+min(le*y,ri*x);
		del[p[b]]=1;
		nowp=p[b];
	}
	cout<<min(dp[n][0],dp[n][1]);
	return 0;
}
```
发现转移时的 $le$ 和 $ri$ 是可以用树状数组快速求出的。

用一个树状数组维护 $a$ 中的每一个元素是否被清零，然后就做完了。

时间复杂度：$O(n\log n)$。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
int n,x,y,z,a[N],p[N],b,dp[N][2];
struct binary_tree{
	int t[N];
	void clear(){memset(t,0,sizeof t);}
	binary_tree(){clear();}
	void up(int x,int v){while(x<=n)t[x]+=v,x+=(x&-x);}
	int qy(int x){int s=0;while(x)s+=t[x],x&=(x-1);return s;}
}tr;
signed main(){
	cin>>n>>x>>y>>z;
	for(int i=1;i<=n;i++)cin>>a[i],p[a[i]]=i,tr.up(i,1);
	int nowp=1;
	memset(dp,0x3f,sizeof dp);
	dp[0][0]=0,dp[0][1]=z;
	for(int i=1;i<=n;i++){
		cin>>b;
		int le=0,ri=0;
		if(nowp<p[b]){
			ri=tr.qy(nowp)+tr.qy(n)-tr.qy(p[b]);
			le=tr.qy(p[b]-1)-tr.qy(nowp-1);
		}
		else if(nowp!=p[b]){
			ri=tr.qy(nowp)-tr.qy(p[b]);
			le=tr.qy(n)-tr.qy(nowp-1)+tr.qy(p[b]-1);
		}
		dp[i][0]=min(dp[i-1][0],dp[i-1][1]+z)+min(le*x,ri*y);
		dp[i][1]=min(dp[i-1][0]+z,dp[i-1][1])+min(le*y,ri*x);
		tr.up(p[b],-1);
		nowp=p[b];
	}
	cout<<min(dp[n][0],dp[n][1]);
	return 0;
}
```

---

## 作者：_O_v_O_ (赞：2)

我们将 $b_i$ 变为 $b_i$ 在 $a$ 中出现的位置，此时与 $a$ 的具体值无关。那么我们就转化了题意：  
> 有一个指针 $pos$，初始 $pos=1$，每次可以花费 $x$ 把 $pos$ 往后跳一位，花费 $y$ 把 $pos$ 往前跳一位或者花费 $z$ 交换 $x,y$。  
> 第 $i$ 次要跳到 $b_i$ 并且消掉这一位，问最小代价。

然后我们发现一次 $z$ 操作只能在一次消除操作后或者最开始使用。

那么我们设：  
$dp_{i,0}$ 为消完 $b_i$ 后，用了偶数次 $z$ 操作的最小代价；  
$dp_{i,1}$ 为消完 $b_i$ 后，用了奇数次 $z$ 操作的最小代价。 

我们设：  
$u$ 为从 $b_{i-1}$ 一直用 $x$ 操作跳到 $b_i$ 的操作次数；  
$v$ 为从 $b_{i-1}$ 一直用 $y$ 操作跳到 $b_i$ 的操作次数。    

那么我们有转移：  
$dp_{i,0}=\min\{dp_{i-1,0},dp_{i-1,1}+z\}+\min\{x\times u,y\times v\} \\ 
dp_{i,1}=\min\{dp_{i-1,0}+z,dp_{i-1,1}\}+\min\{x\times v,y\times u\}$

初始 $dp_{0,0}=0,dp_{0,1}=\infty$，答案为 $\min\{dp_{n,0},dp_{n,1}\}$。

---

## 作者：Sliarae (赞：1)

我们将题目中的四种操作从上到下依次称为第 $1, 2, 3, 4$ 种操作。

由于 $a, b$ 都是排列，$4$ 操作一定恰好进行了 $n$ 次。所以 $b$ 序列相当于依次发出 $n$ 次要求，第 $i$ 次要求 $a$ 序列的开头为 $b_i$，同时在 $a$ 序列中删去 $b_i$。

进一步转化，我们发现 $a_i = 0$ 的元素在 $a$ 序列中是没有意义的，因为移动它们不需要代价，所以我们可以直接将 $a_i \gets 0$ 变成删除 $a_i$。

同时循环左移和循环右移不好维护，我们考虑改为维护一个指针 $cur$ 表示序列的第一个元素，最初 $cur = 1$。则 $1$ 操作相当于 $cur \gets cur + 1$，$2$ 操作相当于 $cur \gets cur - 1$。

那么考虑一个 $b_i$，我们要将 $cur$ 移动到 $b_i$ 在 $a$ 序列中的位置 $pos$，然后在 $a$ 中删去 $b_i$，我们发现将 $cur$ 移动到 $pos$ 的过程对之后的操作没有影响，所以可以进行 dp。

设 $dp_{i, 0/1}$ 表示在序列 $a$ 中删去了 $b_{1 \sim i}$，且（没有/有）交换 $x$ 和 $y$ 的最小代价。转移考虑求出 $cur$ 到 $pos$ 可以通过 $p$ 次 $cur$ 右移或 $q$ 次 $cur$ 左移实现，则不交换 $x, y$ 时代价为 $\min(px, qy)$，交换 $x, y$ 时代价为 $\min(qx, py)$。分类讨论 $dp_{i - 1, 0/1} \gets dp_{i, 0/1}$ 的四种情况即可。

求 $p$ 和 $q$ 需要树状数组，时间复杂度 $O(n \log n)$。

```cpp
#include <iostream>

using namespace std;
using LL = long long;

const int kN = 1e6 + 5; 
const LL Inf = 1e18;

int n, x, y, z;
int mp[kN];

struct BIT {
  int c[kN];

  void Add (int x, int y) {
    for (; x <= n; x += (x & -x)) {
      c[x] += y; 
    }
  }

  int Query (int l, int r) {
    int res = 0;
    for (--l; l; l -= (l & -l)) res -= c[l];
    for (; r; r -= (r & -r)) res += c[r];
    return res;
  }
} bit;

int main () {
  cin.tie(0)->sync_with_stdio(0);
  cin >> n >> x >> y >> z;
  for (int i = 1; i <= n; ++i) {
    int a;
    cin >> a;
    mp[a] = i, bit.Add(i, 1); 
  } 
  LL dp[2] = {0, Inf};
  int cur = 1;
  for (int i = 1; i <= n; ++i) {
    int pos;
    cin >> pos;
    pos = mp[pos];
    int sum = (i == 1 ? n : n - i), p, q;
    if (cur <= pos) {
      p = bit.Query(cur, pos) - 1;
      q = sum - p; 
    }
    else {
      q = bit.Query(pos, cur) - 1;
      p = sum - q; 
    }
    LL next_dp[2] = {Inf, Inf};
    for (int a = 0; a < 2; ++a) {
      for (int b = 0; b < 2; ++b) {
        LL v = (!b ? min(1ll * p * x, 1ll * q * y) : min(1ll * q * x, 1ll * p * y));
        next_dp[b] = min(next_dp[b], dp[a] + v + abs(a - b) * z);
      }
    }
    bit.Add(pos, -1), cur = pos;
    dp[0] = next_dp[0], dp[1] = next_dp[1];
  }
  cout << min(dp[0], dp[1]) << '\n';
  return 0; 
}
```

---

## 作者：nbhs23a28 (赞：1)

一道思路还是比较自然的模拟出发的数据结构辅助 DP 题。（如果本题维持蓝题，这将是本蒟蒻写的第一篇蓝题题解、累计切的第五道蓝题、第一次在洛谷场切的蓝题~~祭~~）

首先根据题意，我们发现，无论如何进行前三种操作，$b$ 序列总保持不变，而唯有第四种操作能使 $a_1$ 为 $0$，$b$ 序列按固定序变换，从而逐步达成目标。于是我们可以先确定**模拟**思路：由 $b$ 序列顺序依次通过左移或右移 $a$ 序列分 $n$ 阶段完成。

注意到每阶段内操作基本是**无后效性**的（交换 $x$ 和 $y$ 除外，但显然这可以另开一维记录），也就是说，显然可以用**动态规划优化模拟**，处理出每阶段操作（左右移与交换）最优操作情况。此时，假如题面没有“若在进行操作前 $a_1 \ne 0$ 则无需使用代价”的要求，本题也就结束了（就是个 DP 板子）。
 
那么有这个要求怎么办呢？由于本题 $a$ 序列顺序在不断变化，我们不妨采用类似于物理中相对运动的观点，把整个 $a$ 序列的移动视作 $a$ 序列中 $id=1$ 位置的移动，这时，题面的这一要求等同于要我们处理一个区间内 $0$ 的个数，状态转移时操作次数等效地减少区间内 $0$ 的个数即可。怎么处理呢？这不就是个单点修改、区间查询的题嘛，由于 $n \le10^6$ 不能用分块，可以使用线段树或树状数组维护。这样时间复杂度就是 $O(n\log n)$ 级别的了，可以通过此题（好在本题不卡常）。

状态转移还是比较显然的，不妨令状态 $f_{i,j}$ 第一维表示操作轮数，第二维表示交换 $x$ 和 $y$ 操作数的奇偶性（奇变偶不变），令 $cnt1$ 和 $cnt2$ 分别表示左移、右移需付出代价的操作数（总操作数减用线段树维护的区间零的个数），则状态转移方程为：  
- $f_{i,0}=\min(f_{i-1,1}+z,f_{i-1,0})+\min(cnt1 \times x,cnt2 \times y)$
- $f_{i,1}=\min(f_{i-1,0}+z,f_{i-1,1})+\min(cnt1 \times y,cnt2 \times x)$。

[Code](https://www.luogu.me/paste/8hs8bk31)

---

## 作者：sbno333 (赞：1)

省流：模拟之后 DP。

因为 $b$ 是动不了的，只能去通过调整 $a$ 来打到 $a_1=b_1$。

每一次找 $a$ 数组里的 $b_1$，考虑只是左移的次数或者只是右移需要的次数。为了方便，我们可以设置一个指针表示当且所在 $a$ 数组的位置，然后每一次看左移走过的位置还有多少数没有被删掉，树状数组维护。

接着就得到了每次需要左移的次数或右移的次数，我们需要选择左移还是右移。

**值得注意的是指针的左移右移和题面的左移右移相反。**

接着就是简单 DP。

设 $dp_{i,0}$ 表示进行完前 $i$ 个操作后，$x$ 和 $y$ 和最开始一样时所需要的最小代价。

$dp_{i,1}$ 表示进行完前 $i$ 个操作后，$x$ 和 $y$ 和最开始相反时所需要的最小代价。

设第 $i$ 次如果左移就需要左移 $l_i$ 次，右移就需要 $r_i$ 次。

$dp_{i,0}=\min(dp_{i-1,0}+\min(yl_i,xr_i),dp_{i-1,1}+z+\min(x,y)\min(l_i,r_i))$。

因为交换 $x,y$ 可以在操作前进行，也可以在操作后进行，使得取到最小，所以是 $\min(x,y)\min(l_i,r_i))$。

$dp_{i,1}$ 同理。

然后我们就做完了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define mod 998244353ll
int n,x,y,z;
int a[1000009];
int zz;
int dl[1000009];
int dr[1000009];
int aa[1000009];
struct st{
	int f[1000009];
	int lowbit(int x){
		return x&(-x);
	}
	void xg(int t){
		while(t<=n){
			f[t]--;
			t+=lowbit(t);
		}
	}
	int qz(int x){
		int ans;
		ans=0;
		while(x){
			ans+=f[x];
			x-=lowbit(x);
		}
		return ans;
	}
	int qj(int l,int r){
		return qz(r)-qz(l-1);
	}
}f; 
int ql[1000009];
int qr[1000009];
void xg(int t){
	f.xg(t);
	if(t==1){
		ql[t]=n;
	}else{
		ql[t]=t-1;
	}
	if(t==n){
		qr[t]=1;
	}else{
		qr[t]=t+1;
	}
}
int l(int t){
	if(t==ql[t]){
		return t;
	}
	return ql[t]=l(ql[t]);
}
int r(int t){
	if(t==qr[t]){
		return t;
	}
	return qr[t]=r(qr[t]);
}
signed main(){
	cin>>n>>y>>x>>z;
	for(int i=1;i<=n;i++){
		f.f[i]++;
		if(i+f.lowbit(i)<=n)
			f.f[i+f.lowbit(i)]+=f.f[i];
		ql[i]=qr[i]=i;
	}
	for(int i=1;i<=n;i++){
		cin>>a[i];
		aa[a[i]]=i;
	}
	zz=1;
	for(int i=1;i<=n;i++){
		int mb;
		cin>>mb;
		int g;
		g=aa[mb];
		if(i==1){
			dl[i]=(n+1-g)%n;
			dr[i]=g-zz;
			zz=g;
		}else{
			int x,y;
			x=l(zz);
			y=r(zz);
			if(g<=x){
				dl[i]=f.qj(g,x-1);
			}else{
				dl[i]=f.qj(1,x-1)+f.qj(g,n);
			}
			if(g>=y){
				dr[i]=f.qj(y+1,g);
			}else{
				dr[i]=f.qj(y+1,n)+f.qj(1,g);
			}
			if(dl[i]==0||dr[i]==0){
				dl[i]=dr[i]=0;
			}
		}
		xg(g);
		zz=g;
	}
	int dp0,dp1;
	dp0=dp1=0;
	dp1=z;
	for(int i=1;i<=n;i++){
		int d0,d1;
		d0=d1=0;
		if(dl[i]&&dr[i]){
			d0=min(dp0+min(dl[i]*x,dr[i]*y),dp1+z+min(x,y)*min(dl[i],dr[i]));
			d1=min(dp1+min(dl[i]*y,dr[i]*x),dp0+z+min(x,y)*min(dl[i],dr[i]));
			dp0=d0,dp1=d1;
		}
	}
	cout<<min(dp0,dp1);
	return 0;
}
```

---

## 作者：shicj (赞：1)

我的方法使用了动态规划和树状数组，可能并不简洁，但题解太简略了，我暂时也不清楚怎么简单地维护题解里的 $u$ 和 $v$，其他部分是原题解的详细版本。

首先分析一下操作（方便描述，标了个号）：

> 1. 将 $a$ 循环左移一位。若在进行操作前 $a_1\neq 0$，则消耗 $x$ 点代价。
> 2. 将 $a$ 循环右移一位。若在进行操作前 $a_1\neq 0$，则消耗 $y$ 点代价。
> 3. 交换 $x,y$。消耗 $z$ 点代价。
> 4. 若 $a_1=b_1$，将 $b$ 循环左移一位，同时令 $a_1=0$。不消耗代价。


题目中出现了大量的循环位移操作，实际上可以对其进行简化分析，因为题目要求把 $a$ 清空，那么我们将每一个 $4$ 操作当作一个阶段，于是，题目要求按照 $b$ 数组的顺序完成 $n$ 个阶段的操作，每个阶段消掉一个数字，消掉数字的顺序就是 $b$ 数组的顺序（这样，操作 $4$ 中的循环移位解决掉了）。

移动整个数组并不好处理，因此可以理解为移动环上的指针。于是转化 $1$ 和 $2$ 操作，最后的描述可以变为：

> 令指针 $p$ 指向 $a_1$。有如下操作：
> 1. 将指针右移一位，若原指向点不为 $0$，消耗 $x$ 点代价。
> 2. 将指针左移一位，若原指向点不为 $0$，消耗 $y$ 点代价。
> 3. 交换 $x,y$。消耗 $z$ 点代价。
> 指针要依次移动到 $b$ 数组标记的每一个位置，完成 $n$ 个阶段。

**注意：移动指针与移动数组相反；指针在 $0$ 的移动没有代价！**

那么，先把每一个阶段要求到达的位置处理出来，这样就没有两个数组了。因为都是排列，所以可以把 $a$ 中数字位置处理到 $p$ 数组，即 `p[a[i]]=i`，再把 $b$ 中的每一个数字对应成 $a$ 中的位置，按顺序记录，详见代码。

入手点是 $3$ 操作，可以发现，在每一个阶段，一定只会使用 $1$ 和 $2$ 操作中的一种，操作 $3$ 至多 $1$ 次且在开始（将结尾的操作 $3$ 归为下一阶段）。考虑到只有操作 $3$ 有后效性，利用它来设计状态：

- $dp_{0,i}$ 表示进行过偶数次操作 $3$，这时 $1$ 和 $2$ 操作代价和开始时一样。
- $dp_{1,i}$ 表示进行过奇数次操作 $3$，这时 $1$ 和 $2$ 操作代价和开始时相反。

设计转移（这应该是比较好想的）：

- $dp_{0,i}=\max\{dp_{0,i-1}+steps_{left}\times x,dp_{0,i-1}+steps_{right}\times y,dp_{1,i-1}+steps_{left}\times y+z,dp_{1,i-1}+steps_{right}\times x+z\}$
- $dp_{1,i}=\max\{dp_{1,i-1}+steps_{left}\times y,dp_{1,i-1}+steps_{right}\times x,dp_{0,i-1}+steps_{left}\times x+z,dp_{0,i-1}+steps_{right}\times y+z\}$

设计边界：

- $dp_{0,1}=0$
- $dp_{1,1}=z$

这里重点处理 $steps_{left}$ 和 $steps_{right}$，具体地，每一个 $0$ 位置都不算贡献，要求一种可以动态修改和区间查询的数据结构，想到线段树和树状数组。但是在比赛中，线段树由于常数问题（也许）被卡掉了，改用了树状数组，具体逻辑就是把未清空的位置设为 $1$，清空后改为 $0$，用区间和处理步数，详见代码。

输出的答案便是 $\min\{dp_{0,n},dp_{1,n}\}$ 了。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,x,y,z;
struct BIT{
  int t[2000006],tot;
  void init(){
    memset(t,0,sizeof(t));
    tot=0;
  }
  void add(int i,int val=1){
	  if(i==0)return;
    tot++;
    for(;i<=n;i+=(i&-i)){
      t[i]+=val;
    }
  }
  int query(int i){
    int s=0;
    for(;i;i-=(i&-i)){
      s+=t[i];
    }
    return s;
  }
}bit;
int a[1000006],p[1000006];
int dp[2][1000006];
int q(int l,int r){
	return bit.query(r)-bit.query(l-1);
}
int left(int now,int to){
//	return now>=to?now-to:n+now-to;
//	return now>=to?SegTree.query(1,to+1,now):SegTree.query(1,1,now)+SegTree.query(1,to+1,n);
	return now>=to?q(to+1,now):q(1,now)+q(to+1,n);
}
int l1(int x){
	return x-1==0?n:x-1;
}
int right(int now,int to){
//	return now<=to?to-now:n+to-now;
//	return now<=to?SegTree.query(1,now,to-1):SegTree.query(1,now,n)+SegTree.query(1,1,to-1);
	return now<=to?q(now,to-1):q(now,n)+q(1,to-1);
}
int r1(int x){
	return x+1==n?1:x+1;
}
void solve(){
	scanf("%lld%lld%lld%lld",&n,&y,&x,&z);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		p[a[i]]=i;
//		SegTree.dat[i]=1;
	}
//	SegTree.build(1,1,n);
	bit.init();
	for(int i=1;i<=n;i++){
		bit.add(i);	
		int tmp;
		scanf("%lld",&tmp);
		a[p[tmp]]=i;
	}
	for(int i=1;i<=n;i++){
		p[a[i]]=i;
	}
	p[0]=1;
	dp[0][1]=0;
	dp[1][1]=z;
	for(int i=1;i<=n;i++){
		int L=left(p[i-1],p[i]);
		int R=right(p[i-1],p[i]);
		dp[0][p[i]]=min({
				dp[0][p[i-1]]+L*x,
				dp[0][p[i-1]]+R*y,
				dp[1][p[i-1]]+L*y+z,
				dp[1][p[i-1]]+R*x+z
		});
		dp[1][p[i]]=min({
				dp[1][p[i-1]]+L*y,
				dp[1][p[i-1]]+R*x,
				dp[0][p[i-1]]+L*x+z,
				dp[0][p[i-1]]+R*y+z,
		});
		bit.add(p[i],-1);
	}
	printf("%lld\n",min(dp[0][p[n]],dp[1][p[n]]));
}
signed main(){
#ifdef USE_FILE_IO
	freopen("code.in","r",stdin);
	cerr<<"[File IO]"<<endl;
#endif
	int t=1;
//	cin>>t;
	while(t--){
		solve();
	}
	return 0;
}
```

---

## 作者：shuqiang (赞：1)

赛时死因：[没删调试](https://www.luogu.com.cn/record/215810445)。

### 10pts 做法

显然一次操作不是一直往左移就是一直往右移，然后移到与 $b$ 数组匹配的就改为 $0$，对于每一轮之前，枚举是否交换 $x,y$，时间复杂度 $\mathcal{O}(4^nn)$。


```cpp
#include<iostream>
#include<vector>
#include<deque>

using namespace std;

const int N = 1e6 + 10;
int n, x, y, z, a[N], b[N], ft = 1;
deque<int> dq;

int dfs(deque<int> q, int x, int y){
	if(ft == n+1) return 0;
	deque<int> t;
//	cout << b[ft] << ':';
	for(int i = 0; i < q.size(); i++){
//		cout << q[i] << ' ';
		t.push_back(q[i]);
	}
//	cout << '\n';
	int cnt1 = 0, cnt2 = 0;
	while(q.front() != b[ft]){
		if(q.front() != 0) cnt1 += x;
		q.push_back(q.front());
		q.pop_front();
	}
	q.pop_front();
	q.push_front(0);
	ft++;
//	cout << "rt:" << cnt1 << '\n';
	cnt1 += min(dfs(q, x, y), dfs(q, y, x) + z);
	ft--;
	while(t.front() != b[ft]){
		if(t.front() != 0) cnt2 += y;
		t.push_front(t.back());
		t.pop_back();
	}
	t.pop_front();
	t.push_front(0);
	ft++;
//	cout << "lt:" << cnt2 << '\n';
	cnt2 += min(dfs(t, x, y), dfs(t, y, x) + z);
	ft--;
	return min(cnt1, cnt2);
}

int main(){
	cin >> n >> x >> y >> z;
	for(int i = 1; i <= n; i++) cin >> a[i];
	for(int i = 1; i <= n; i++) cin >> b[i];
	for(int i = 1; i <= n; i++) dq.push_back(a[i]);
	cout << min(dfs(dq, x, y), dfs(dq, y, x) + z);
	return 0;
}
```

### 35pts 做法

我们发现往左移动后的数组与往右移动后的数组相同，所以不需要枚举往左移后的状态和往右移动的状态，只需要记录下往左移动和往右移动需要消耗代价的次数即可。

接下来就是交换代价的问题，交换代价可以用 dp 来代替，假设第 $i$ 次往左移动 $c_{i,0}$，往右移动 $c_{i,1}$ 次，选择交换偶数次的最小代价为 $f_{i,0}$，选择交换奇数次的最小代价为 $f_{i,1}$，则转移方程为：

- $f_{i-1,0} = \min(f_{i-1,0} + \min(c_{i,0}x, c_{i,1}y), f_{i-1,1} + z + min(c_{i,0}y, c_{i,1}x))$
- $f_{i-1,1} = \min(f_{i-1,1} + \min(c_{i,0}y, c_{i,1}x), f_{i-1,0} + z + \min(c_{i,0}x, c_{i,1}y))$

这样，我们就将时间复杂度降为 $\mathcal{O}(n^2)$。


```
#include<iostream>
#include<vector>
#include<deque>

using namespace std;
typedef long long ll;

const int N = 1e6 + 10;
int n, x, y, z, a[N], b[N], ft = 1;
ll cnt[N][2], f[N][2];
deque<int> dq;

int dfs(deque<int> q, int x, int y){
	if(ft == n+1) return 0;
	deque<int> t;
	for(int i = 0; i < q.size(); i++){
		t.push_back(q[i]);
	}
	int cnt1 = 0, cnt2 = 0, res = 0;
	while(q.front() != b[ft]){
		if(q.front() != 0) cnt1++;
		q.push_back(q.front());
		q.pop_front();
	}
	q.pop_front();
	q.push_front(0);
	while(t.front() != b[ft]){
		if(t.front() != 0) cnt2++;
		t.push_front(t.back());
		t.pop_back();
	}
	t.pop_front();
	t.push_front(0);
//	for(int i = 0; i < q.size(); i++){
//		cout << q[i] << ' ' << t[i] << '\n';
//	}
	cnt[ft][0] = cnt1; cnt[ft][1] = cnt2;
	ft++;
	res = dfs(t, x, y);
}

int main(){
	cin >> n >> x >> y >> z;
	for(int i = 1; i <= n; i++) cin >> a[i];
	for(int i = 1; i <= n; i++) cin >> b[i];
	for(int i = 1; i <= n; i++) dq.push_back(a[i]);
	dfs(dq, x, y);
	f[0][0] = 0, f[0][1] = z;
	for(int i = 1; i <= n; i++){
		f[i][0] = min(f[i-1][0] + min(cnt[i][0]*x, cnt[i][1]*y), f[i-1][1] + z + min(cnt[i][0]*y, cnt[i][1]*x));
		f[i][1] = min(f[i-1][1] + min(cnt[i][0]*y, cnt[i][1]*x), f[i-1][0] + z + min(cnt[i][0]*x, cnt[i][1]*y));
	}
	cout << min(f[n][0], f[n][1]);
	return 0;
}
```

### 100pts 做法

我们发现，此时的时间是因为移动而拖慢了，所以考虑优化移动方式。

可以发现，移动数组的花费次数其实就是移动过程中队头的非 $0$ 个数，我们可以用一个指针来指向队头，用另外一个指针指向对头需要移动的位置，发现题目被我们转化成了实现能快速判断区间非 $0$ 个数的数据结构。

可以用树状数组，初始时所有位置均为 $1$，当一个数变成 $0$ 时，我们就可以把这个数在树状数组的位置减 $1$，设 $s_i$ 为此时树状数组前 $i$ 项的和，原来队头位置为 $x$，要移动到的位置为 $y$，分两种情况。

1. 当 $x < y$ 时，答案为 $s_{y-1}-s_{x-1}$。
2. 当 $x > y$ 时，答案为 $s_{n}+s_{y-1}-s_{x-1}$。

这样，我们就将时间复杂度降为 $\mathcal{O}(n \log n)$。


```cpp
#include<iostream>

using namespace std;
typedef long long ll;

const int N = 1e6 + 10;
int n, x, y, z, a[N], b[N], c[N], d[N], idx = 1;
ll cnt[N][2], f[N][2];

void upd(int x, int k){
	while(x <= n){
		d[x] += k;
		x += x & -x;
	}
}

int chk(int x){
	int ret = 0;
	while(x){
		ret += d[x];
		x -= x & -x;
	}
	return ret;
}

int main(){
	cin >> n >> x >> y >> z;
	for(int i = 1; i <= n; i++) cin >> a[i];
	for(int i = 1; i <= n; i++) cin >> b[i];
	for(int i = 1; i <= n; i++) c[a[i]] = i;
	for(int i = 1; i <= n; i++) upd(i, 1);
	int cnt1;
	for(int ft = 1; ft <= n; ft++){
//		cout << idx << ' ' << c[b[ft]] << '\n';
		if(idx < c[b[ft]]){
			cnt1 = chk(c[b[ft]]-1) - chk(idx-1);
		} 
		else{
			cnt1 = chk(c[b[ft]]-1) + chk(n) - chk(idx-1);
		}
//		cout << cnt1 << ' ' << n-ft-cnt1+(ft==1) << '\n';
		cnt[ft][0] = cnt1; cnt[ft][1] = n-ft-cnt1+(ft==1);
		upd(c[b[ft]], -1);
		idx = c[b[ft]];
	}
	f[0][0] = 0, f[0][1] = z;
	for(int i = 1; i <= n; i++){
		f[i][0] = min(f[i-1][0] + min(cnt[i][0]*x, cnt[i][1]*y), f[i-1][1] + z + min(cnt[i][0]*y, cnt[i][1]*x));
		f[i][1] = min(f[i-1][1] + min(cnt[i][0]*y, cnt[i][1]*x), f[i-1][0] + z + min(cnt[i][0]*x, cnt[i][1]*y));
	}
	cout << min(f[n][0], f[n][1]);
	return 0;
}
```

---

## 作者：zhangbo1000 (赞：0)

注意到前两种操作耗费代价都需要 $a_i$ 不为零，所以这个 $a_1\gets 0$ 其实就是把 $a_1$ 删除了，然后我们的目标是删干净所有数。

因为只有删 $a_1$ 时可以移动 $b$，所以我们每次操作后 $a$ 的状态其实是固定的，区别只在于当前是否使用了操作 $3$。

所以就可以 dp，设 $f_{i,0/1}$ 表示当前删了 $i$ 个数，用/没用操作 $3$ 的最小代价。

转移就是考虑下用不用操作 $3$ 然后直接算代价（删一个数期间显然不可能同时用到操作 $1$ 和 $2$），然后我们这里需要知道一个数前后还各有几个数，显然可以使用树状数组维护。

树状数组不太好维护环，可以考虑拆成两条链或者前后分别统计。

转移只和上个状态有关，可以滚动数组或者干脆用两个变量来存。

[代码和评测记录。](https://www.luogu.com.cn/record/218244171)

---

## 作者：DFM_O (赞：0)

## [P12406 题目](https://www.luogu.com.cn/problem/P12406)

### 解题思路
我们可以将令 $a_i=0$ 的操作看作删除操作，显然我们需要通过 $n$ 次删除操作以达到使 $a$ 序列都为 $0$ 的目的，不难发现若想执行第 $i$ 次删除操作，只需将 $a$ 序列中的 $b_i$ 移到第 $1$ 位即可（这里的 $b_i$ 指**原来**的 $b$ 序列中的第 $i$ 个数，下同）。

设 $dp_{i,0}$ 为完成第 $i$ 次删除操作后，$x,y$ 均与原来一样时的最小代价，$dp_{i,1}$ 为完成第 $i$ 次删除操作后，$x,y$ 均与原来不一样时的最小代价。

设 $o_i$ 为 $i$ 在原来的 $a$ 序列中的位置，$lc_i$ 表示从完成第 $i-1$ 次删除操作到完成第 $i$ 次删除操作若使用左移会消耗多少次 $x$ 点代价，$rc_i$ 表示从完成第 $i-1$ 次删除操作到完成第 $i$ 次删除操作若使用右移会消耗多少次 $y$ 点代价。

转移是简单的，枚举上一次删除操作时 $x,y$ 是否与原来一样，记为 $la$，若 $pd=1$，则交换 $x,y$ 进行计算，容易得出转移方程：
$$dp_{i,pd}=\min(dp_{i,la}+\min(lc_i\times x,rc_i\times y)+[pd\not=la]z)$$
另外注意边界 $dp_{0,0}=0,dp_{0,1}=z$。

现在问题是如何计算 $lc_i$ 和 $rc_i$，设 $b_i$ 在**当前**的 $a$ 序列中的位置为 $w_i$，不难发现 $lc_i$ 即为**当前**的 $a$ 序列的 $[1,w_i-1]$ 中的不为 $0$ 的数的个数（即有多少未被删除的数），$rc_i$ 即为**当前**的 $a$ 序列的 $[w_i+1,1]$ 中的不为 $0$ 的数的个数（注意到这里的区间 $l>r$，是为了方便表示而把 $a$ 序列看成环形的，即此时区间 $[l,r]$ 的贡献为 $[l,n]$ 和 $[1,r]$ 的贡献之和，下同）。

但是显然这样不好计算，我们需要把**当前** $a$ 序列的区间转化为**原来** $a$ 序列的区间，注意到此时 $a_1$ 就是 $b_{i-1}$，于是我们可以将**当前** $a$ 序列的位置 $1$ 转化为**原来** $a$ 序列的位置 $o_{b_{i-1}}$，**当前** $a$ 序列的位置 $w_i$ 转化为**原来** $a$ 序列的位置 $o_{b_i}$（注意边界 $b_0=0,o_0=1$，但仍需特判 $o_{b_1}=1$ 的情况，此时 $lc_1=rc_1=0$）。

用树状数组维护即可，初始时所有位置的贡献均为 $1$，每次删除操作结束后将 $o_{b_i}$ 的贡献设为 $0$。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[1000001],o[1000001],b[1000001],dp[1000001][2],c[4000001];
inline void add(int w,int x)
{
	for(;w<=n;w+=w&-w)
		c[w]+=x;
}
inline int ask(int w)
{
	int s=0;
	for(;w>=1;w-=w&-w)
		s+=c[w];
	return s;
}
inline int askq(int l,int r)
{
	if(l==n+1)
		l=1;
	if(r==0)
		r=n;
	if(l>r)
		return askq(l,n)+askq(1,r);
	int s=ask(r)-ask(l-1);
	return s;
}
signed main()
{
    ios::sync_with_stdio(false);
    int x,y,z;
    cin>>n>>x>>y>>z;
    for(int i=1;i<=n;i++)
    	cin>>a[i],o[a[i]]=i,add(i,1);
    o[0]=1;
    for(int i=1;i<=n;i++)
    	cin>>b[i];
    dp[0][1]=z;
    for(int i=1;i<=n;i++)
    {
    	int nowx=x,nowy=y,gx,gy;
		gx=askq(o[b[i-1]],o[b[i]]-1),gy=askq(o[b[i]]+1,o[b[i-1]]);
		if(i==1&&o[b[i]]==1)
			gx=gy=0;
		for(int j=0;j<=1;j++)
		{
			dp[i][j]=1e18+1;
			if(j==1)
				swap(nowx,nowy);
			for(int sh=0;sh<=1;sh++)
			{
				if(j==sh)	
					dp[i][j]=min(dp[i][j],dp[i-1][sh]+min(nowx*gx,nowy*gy));
				else
					dp[i][j]=min(dp[i][j],dp[i-1][sh]+min(nowx*gx,nowy*gy)+z);
			}
		}
		add(o[b[i]],-1);
	}
	int s=min(dp[n][0],dp[n][1]);
	cout<<s;
    return 0;
}
```

---


# 「ROI 2025 Day1」天狼星的换班

## 题目描述

**译自 [ROI 2025](https://neerc.ifmo.ru/school/archive/2024-2025.html) Day1 T2.** ***[Пересменка в Сириусе](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-roi-2025-day1.pdf)***

你有没有好奇过，为什么天狼星教育中心的两期项目之间总会隔上几天？答案很简单：员工们需要在这段时间里把宿舍楼的房间整理一新，为下一期项目做准备！

天狼星酒店的某层楼有 $n$ 个房间，编号从 $1$ 到 $n$。每次教育项目结束后，这些房间都需要进行维修。  
为此，中心雇佣了 $k$ 名员工，编号从 $1$ 到 $k$。每位员工负责一段房间范围，从 $l_i$ 到 $r_i$（包含两端），并且每人有一个固定的起点房间 $m_i$，他们必须从这个房间开始检查和维修。不同员工的负责范围可能会有重叠，甚至完全相同。

员工们会按照某种顺序从基地出发去维修房间。每次只有前一位员工返回基地后，下一位员工才会出发。  

当第 $i$ 位员工出发时，他会先前往起点房间 $m_i$：  
- 如果这个房间仍需维修，员工会修好它，然后继续检查并维修他负责范围 $l_i$ 到 $r_i$ 内所有仍需维修的房间。完成后，他返回基地。此时，他负责的整个范围内的房间都不再需要维修。  
- 如果起点房间 $m_i$ 已经被其他先出发的员工修好，员工会直接返回基地，寄希望于同事们已经顺便修好了他负责范围内的其他房间。但实际上，他负责范围内可能仍有房间需要维修。

你的任务是判断，是否能通过合理安排员工的出发顺序，让所有 $1$ 到 $n$ 的房间最终都被修好。

## 说明/提示

### 样例解释

在第一组数据中，先派第 $2$ 位员工出发，他会修好房间 $1$ 到 $3$。然后派第 $1$ 位员工出发，他前往房间 $4$，发现它仍需维修，于是修好他负责范围内剩余的房间。最终，所有房间都被修好。

在第二组数据中，无法找到一个合适的员工出发顺序来修好所有房间。

### 数据范围

记 $N$ 为所有数据组的 $n$ 之和，$K$ 为所有数据组的 $k$ 之和。

详细子任务附加限制及分值如下表所示。其中子任务 $0$ 是样例。

| 子任务 | 分值 | 附加限制 |
| :-: | :-: | :-: |
| $1$        | $5$  | $K \leq 10\,000$，$m_i = l_i$ | |
| $2$        | $5$  | $N \leq 500$，$k \leq 8$ |
| $3$        | $2$  | $n \leq 18$，$K \leq 500$ |
| $4$        | $12$ | $n \leq 50$，$K \leq 50$ |
| $5$        | $9$  | $n \leq 150$，$K \leq 150$ |
| $6$        | $8$  | $N \leq 500$，$K \leq 500$ |
| $7$        | $6$  | $K \leq 10\,000$，每个员工负责的范围包含房间 $1$ 或 $n$ | |
| $8$        | $18$ | $K \leq 10\,000$，每个员工负责的范围内至少有一个房间只由他负责 | |
| $9$        | $3$  | 每个员工负责的范围内至少有一个房间只由他负责 | $8$ |
| $10$       | $4$  | $K \leq 10\,000$，任意 $i, j$，$r_i - l_i = r_j - l_j$ | |
| $11$       | $4$  | $K \leq 10\,000$，任意 $m_i$ 等于 $l_i$ 或 $r_i$ | $1$ |
| $12$       | $4$  | $n \leq 10\,000$，$K \leq 10\,000$ | $0,2-6$ |
| $13$       | $6$  | $K \leq 10\,000$ | $0,1-8,10-12$ |
| $14$       | $14$ | 无附加限制 | $0,1-13$ |

## 样例 #1

### 输入

```
2
5 2
3 4 5
1 3 3
5 3
1 2 4
2 4 5
3 3 3```

### 输出

```
YES
NO```

# 题解

## 作者：A2ure_Sky (赞：6)

# 题目大意
**是否**能从给定的 $k$ 条线段 $(l,m,r)$ 中**按照某种顺序**地挑出任意个线段覆盖区间 $[1,n]$，并满足如下条件：

**后挑出**的线段的 $m$ 不能落在**已挑出**的线段上。

# 数据范围
$1 \leq n,k \leq 5 \times 10^5$，$1 \leq l \leq m \leq r \leq n$。

# 题解
这是一个线段覆盖问题，我们像搭桥一样，先从 $1$ 开始拼接线段，最后拼到 $n$，因此按 $l$ 排序是合理的。

特别要考虑的是 $m$ 这个约束，我们首先看看怎样才是合法的拼接。

考虑两条线段 $X$ 和 $Y$，其中 $l_X \leq l_Y$。

首先能够拼接的必要条件是 $X$ 和 $Y$ 相交或相邻，即 $r_X \geq l_Y - 1$。

注意到如果两个线段的 $m$ 都被对方的区间所覆盖的情况显然无法拼接，那么只有两种情况：

1. $m_Y$ 未被覆盖，此时可以先选 $X$ 再选 $Y$。

   **示例图**：
```
    ---·--      X
        ----·-- Y
```
由图可知需满足： $r_X \in [l_Y - 1, m_Y - 1]$。

2. $m_X$ 未被覆盖，此时可以先选 $Y$ 再选 $X$。

    **示例图**：
```
    ---·-----  X
          -·-- Y
```
由图可知需满足： $l_Y \in [m_X + 1, r_X + 1]$。

**上面两种情况满足其一即可拼接**。

---

于是我们就分析完了拼接的问题，现在问题就好办了。

按 $l$ 从小到大维护已经拼接出的若干个区间 $[1,r_X]$，考虑新引入的线段 $A$ 是否可以拼接上前面的区间，这里可以使用 **set** 维护 $x$。

注意我们并不关心拼接的是哪一个区间而只关心是否能拼上，因为拼接完的区间都是 $[1,r_A]$。

根据前面说的，只要满足两个条件中的一个就可以拼接：

- 对于前者，我们在 **set** 上二分出一个满足 $r_X \geq l_Y - 1$ 的最小的 $r_X$ 并判断是否 $\leq m_Y - 1$（为了方便可以整体加上一）。
- 对于后者，我们可以借助**树状数组**用**差分**的方式维护出区间 $[m_X + 1, r_X + 1]$，然后单点查询 $l_Y$ 是否被覆盖即可。

于是我们就做完啦！

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+10;
int n,k;
struct node{
	int l,m,r;
	bool operator < (const node &b) const{
		return (l!=b.l)?(l<b.l):(r<b.r);
	}
}a[N];
set<int> S;
int t[N];
void upd(int x,int y){for(;x<=n+2;x+=x&(-x)) t[x]+=y;}
int qry(int x){
	int res=0;
	for(;x;x-=x&(-x)) res+=t[x];
	return res;
}
void solve(){
	cin>>n>>k;
	S.clear();
	for(int i=1;i<=n+2;i++) t[i]=0;
	for(int i=1;i<=k;i++) cin>>a[i].l>>a[i].m>>a[i].r;
	sort(a+1,a+k+1);
	int ans=0;
	for(int i=1;i<=k;i++){
		auto it=S.lower_bound(a[i].l);
		if(it!=S.end()&&(*it)<=a[i].m||a[i].l==1||qry(a[i].l)){
			ans=max(ans,a[i].r);
			S.insert(a[i].r+1);
			upd(a[i].m+1,1),upd(a[i].r+2,-1);//注意树状数组的值域
		}
	}
	cout<< ( (ans==n) ? "YES\n" : "NO\n");
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int T; cin>>T;
	while(T--) solve();
	return 0;
}

---

## 作者：suzhikz (赞：3)

考虑一种合法情况，两个相邻的人员有三种可能。

第一种是前面的人的右端点覆盖了后面那个人的起点房间，并且后面那个人的左端点不能覆盖前面那个人的起点房间，此时要让后面那个人先工作。

第二种是后面那个人的左端点覆盖了前面那个人的起点房间，并且前面那个人没有覆盖后面那个人的起点房间，此时前面那个人先开始工作。

还有一种是两个人之间的起点房间不会被另一个人覆盖，那么顺序随便。

所以我们先按照左端点排序，然后一次检查每个人。

设我们检查 $x$ 这个人，假设有个人 $y$ 的起点在 x 的左端点的前面，若 y 的右端点达到了 $x$ 的左端点的前一个位置，那么 $x$ 可以被选择。这个情况用线段树维护前缀最大值即可。

若 $y$ 的起点被 $x$ 给包含了，那么如果说 $y$ 的右端点没有到达 $x$ 的起点，那么 $x$ 也是可以选择的。这个东西可以用 set 维护。

注意，这里的 $y$ 不是任意一个人，而是可以选择的人。并且选择的人要保证选完我们能使得这个点的右端点的前面所有房间都被打扫了。


```cpp
//我永远喜欢艾莉丝!
#include<bits/stdc++.h>
#define ll long long
#define reg register
#define db double
#define il inline
using namespace std;
void read(int &x){x=0;int f=1;char c=getchar();while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}x*=f;}
void read(ll &x){x=0;int f=1;char c=getchar();while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}x*=f;}
const int N=5e5+5;
int t,n,k;
struct node{
	int l,m,r;
}z[N];
set<int>s;
bool cmp(node a,node b){
	return a.l<b.l;
}
int l[N],m[N],r[N];
int tree[N<<2];
void push_up(int x){
	tree[x]=max(tree[x<<1],tree[x<<1|1]);
}
void init(int x,int l,int r){
	tree[x]=0;
	if(l!=r){
		int mid=(l+r)/2;init(x<<1,l,mid);init(x<<1|1,mid+1,r);
	}
}
void update(int x,int l,int r,int q,int w){
	if(l==r){
		tree[x]=max(tree[x],w);return;
	}
	int mid=(l+r)/2;
	if(q<=mid)update(x<<1,l,mid,q,w);
	else update(x<<1|1,mid+1,r,q,w);
	push_up(x);
}
int query(int x,int l,int r,int ql,int qr){
	if(ql<=l&&qr>=r)return tree[x];
	int re=0,mid=(l+r)/2;
	if(ql<=mid)re=query(x<<1,l,mid,ql,qr);
	if(qr>mid)re=max(re,query(x<<1|1,mid+1,r,ql,qr));
	return re;
}
int main(){
	read(t);
	while(t--){
		read(n);read(k);
		for(int i=1;i<=k;i++){
			read(z[i].l);read(z[i].m);read(z[i].r);
		}sort(z+1,z+1+k,cmp);
		s.clear();
		init(1,0,n);
		int ans=0;
		for(int i=1;i<=k;i++){
			if(query(1,0,n,0,z[i].l-1)>=z[i].l-1||z[i].l==1){
				update(1,0,n,z[i].m,z[i].r);s.insert(z[i].r);ans=max(ans,z[i].r);
//				cout<<i<<endl;
			}else{
				set<int>::iterator it;
				it=s.lower_bound(z[i].l-1);
				if(it==s.end())continue;
				if(*it<z[i].m){
					update(1,0,n,z[i].m,z[i].r);s.insert(z[i].r);ans=max(ans,z[i].r);
				}
			}
//			cout<<ans;
		}
		if(ans==n)puts("YES");
		else puts("NO");
	}
	
	return 0;
}
```

---

## 作者：Mr_Az (赞：3)

# [P12502 「ROI 2025 Day1」天狼星的换班](https://www.luogu.com.cn/problem/P12502)

### Algorithm:

DP 动态规划。

### Solution:

考虑任意两个人什么时候存在一种方案可以都清扫，当且仅当两个人的起始点 $m$ 不在两个人清扫的区间的交集里。形式化的，两个人 $i,j$ 存在一种方案可以都清扫当且仅当 $l_i \in(m_j,r_j+1]$ 或者 $r_j \in [l_i-1,m_i)$。(其实这两种重复了 $r_j=l_i-1$ 的情况，不过无伤大雅。）

发现两个转移分别是主动转移和被动转移，将所有区间按照 $r$ 递增排序后，拿树状数组维护 DP 即可。	

**小知识：当有多组询问的时候，请慎用 memset。其清空时间复杂度为 $\text{O}(NT)$。**

### Code:

```cpp
namespace Mr_Az{
	int T=0;
	const int N=5e5+8;
	int n,k;
	struct node{int l,r,m;}a[N];
	int t[2][N];
	inline void add(int o,int x,int k){
		for(;x<=n;x+=lowbit(x)) t[o][x]+=k;
		return ;
	}
	inline void add(int o,int l,int r,int k){add(o,l,k);add(o,r+1,-k);return ;}
	inline int ask(int o,int x){
		int res=0;
		for(;x;x-=lowbit(x)) res+=t[o][x];
		return res;
	}
	inline int ask(int o,int l,int r){return ask(o,r)-ask(o,l-1);}
	bitset<N> dp;
	inline void solve(){
		read(n,k);
		for(rint i=1;i<=k;i++) read(a[i].l,a[i].m,a[i].r);
		sort(a+1,a+k+1,[](node A,node B){return A.r<B.r;});
		dp.reset();
		for(rint i=1;i<=n;i++) t[0][i]=t[1][i]=0;// 不要使用 memset!
		for(rint i=1;i<=k;i++){
			if(a[i].l==1) dp[i]=1;
			else dp[i]=ask(0,a[i].l)>0||ask(1,a[i].l-1,a[i].m-1)>0;
			if(dp[i]) add(0,a[i].m+1,a[i].r+1,1),add(1,a[i].r,1);
		}
		for(rint i=1;i<=k;i++) if(dp[i]&&a[i].r==n){puts("YES");return ;}
		puts("NO");
		return ;
	}
	inline void mian(){if(!T) read(T);while(T--) solve();}
}
```

---

## 作者：hoko (赞：1)

## 分析
容易想到，定义 $dp_i$ 为以第 $i$ 个员工结尾时，前 $i$ 个员工所能涉及到的房间能否被都修好。因为 $t$ 和 $n$ 都比较大，要尽可能在 $O(n\log n)$ 的时间内完成。

现在考虑如何转移，容易想到让第 $i$ 个员工所管理的区间与前 $i-1$ 个人拼，因为前 $i-1$ 个人已经拼好，所以只要能拼上，那么 $dp_i=1$。那么要如何拼呢，考虑如下两幅图:
![](https://cdn.luogu.com.cn/upload/image_hosting/ungjcn23.png?x-oss-process=image/resize,m_lfit,h_500,w_500)

当我们枚举到 $i=2$ 时，我们找到存在 $m_2>r_1>l_2$，这说明我们可以先派 $1$ 号员工出去，再派 $2$ 号出去就可以把他们所涉及的房间都修完，我们称这种为正插。

![](https://cdn.luogu.com.cn/upload/image_hosting/ioc87jwb.png?x-oss-process=image/resize,m_lfit,h_500,500)

考虑这幅图，跟上一张很像，但是如果在现在的情况下再用正插，那么因为 $m_2$ 在 $[l_1,r_1]$ 中，会被覆盖，就不能派去了。所以这里是一种新情况，存在 $r_1>m_2$ 并且 $m_1<l_2$ 那么就可以用反插，即先派 $2$ 去再派 $1$ 去即可。

可以证明，只有这两种情况。那么分清了情况，就考虑如何实现，因为要维护区间上的点存在情况和大小，容易想到可以用线段树。这里有一个比较妙的操作，线段树的 $tree[i]$ 中 第 $r_i$ 的位置存的是 $m_i$ 的值，即 $tree[r[i]]=m[i]$ 这样会方便比较。

为了前 $i$ 个员工涉及的范围可以从小到大，所以要先对数组排序，以 $m$ 为关键字从小到大排。假设现在枚举到第 $i$ 条线段。那么对于第一个操作，需要查询 $[l_i-1,m_i-1]$ 中是否存在一个 $r_j$ 即可，之所以是 $[l_i-1,m_i-1]$ 是因为当 $r_j$ 在 $l_i-1$ 的位置时也可以完美拼上，而如果在 $m_i$ 的话就会覆盖 $m_i$ 所以不能在 $m_i$。对于第二个操作，需要判断 $[m_i,r_i-1]$ 中有没有一个 $tree[r_j]<l_i$ 即可。
只要上述两种操作满足一点，那么这条线段就可以被插进去，即 $dp_i=1$，同时也要把线段树中 $tree[r[i]]$ 的值修改为 $l_i$。

代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2010101;
struct tt{
    int l,m,r;
}s[N];
bool cmp(tt a,tt b){return a.m<b.m;}
int f[N];
int t[N];
int ls(int p){return p<<1;}
int rs(int p){return p<<1|1;}
void build(int p,int l,int r){
    t[p]=1e9;
    if(l==r)return ;
    int mid=l+r>>1;
    build(ls(p),l,mid);
    build(rs(p),mid+1,r);
}
void update(int p,int l,int r,int x,int k){
    t[p]=min(t[p],k);
    if(l==r)return ;
    int mid=l+r>>1;
    if(x<=mid)update(ls(p),l,mid,x,k);
    else update(rs(p),mid+1,r,x,k);
}
bool query(int p,int l,int r,int x,int y){
    if(x>y)return 0;
    if(x<=l&&r<=y){
        if(t[p]<1e8)return 1;
        return 0;
    }
    int mid=l+r>>1,ans=0;
    if(x<=mid)ans|=query(ls(p),l,mid,x,y);
    if(y>mid)ans|=query(rs(p),mid+1,r,x,y);
    return ans;
}
bool qry(int p,int l,int r,int x,int y,int k){
    if(x>y)return 0;
    if(x<=l&&r<=y){
        if(t[p]<k)return 1;
        return 0;
    }
    int mid=l+r>>1,ans=0;
    if(x<=mid)ans|=qry(ls(p),l,mid,x,y,k);
    if(y>mid)ans|=qry(rs(p),mid+1,r,x,y,k);
    return ans;
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    int T;
    cin>>T;
    while(T--){
        int n,k;
        cin>>n>>k;
        for(int i=1;i<=k;i++){
            cin>>s[i].l>>s[i].m>>s[i].r;
        }
        sort(s+1,s+k+1,cmp);
        f[0]=1;
        build(1,0,n);
        update(1,0,n,0,0);
        bool p=0;
        for(int i=1;i<=k;i++){
            f[i]=query(1,0,n,s[i].l-1,s[i].m-1)|qry(1,0,n,s[i].m,s[i].r-1,s[i].l);
            if(f[i])update(1,0,n,s[i].r,s[i].m);
            if(s[i].r==n&&f[i]==1)p=1;
        }
        cout<<(p?"YES":"NO")<<'\n';
    }
}
```

---

## 作者：GrYWnds (赞：0)

首先考虑没有 $m_i$ 的情况，如果要覆盖全区间，可以先将这些区间按 $l_i$ 从小到大排序，然后从起点 1 开始让区间与区间首尾相接地拼接。

接下来考虑 $m_i$，发现对于第 $i$ 个区间，如果可以与第 $j$ 个区间拼接到一起（其中 $i$，$j$ 为排序后的下标，满足 $ j < i $ 这一条件），当且仅当满足这两种情况：

1. $ r_j \in [ l_i - 1 , m_i - 1 ] $，此时先覆盖第 $j$ 个区间再覆盖第 $i$ 个区间。
2. $ r_j \in [ m_i , r_i ] $ 并且 $ m_j < l_i $，此时此时先覆盖第 $i$ 个区间再覆盖第 $j$ 个区间。

于是我们设 $dp[i]$ 为如果可以通过拼接若干个区间得到一个 $ [ 1 , i ] $ 的区间，最后一个区间的 $m_i$ 的最小值。初始所有 $dp[i]$ 均为 inf。

按上述情况区间查询 dp 数组来判断是否可以拼接。如果 $i$ 区间可以拼接，那么就用 $m_i$ 去更新 $dp[r_i]$。

发现涉及区间查询单点修改，于是使用线段树维护 dp 数组。

时间复杂度 $ O ( n \log n ) $，可以通过此题。

代码实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 500010
#define ls p*2
#define rs p*2+1
#define mid ((l+r)>>1)
#define inf 1270721

int read(){
	int res=0;char c=getchar();
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9'){
		res=(res<<1)+(res<<3)+(c^48);
		c=getchar();
	}
	return res;
}

struct node{
	int l,m,r;
} line[N];
bool cmp(node a,node b){
	return a.l==b.l ? ( a.r==b.r ? a.m<b.m : a.r<b.r ) : a.l<b.l;
}

struct tree{

	int sum[N<<2];
	void build(int p,int l,int r){
		if(r<l) return;
		sum[p]=inf;
		if(l==r) return;
		build(ls,l,mid);
		build(rs,mid+1,r);
	}
	
	void pushup(int p){
		sum[p]=min(sum[ls],sum[rs]);
	}
	
	void insert(int p,int l,int r,int pos,int num){
		if(r<l||pos<l||r<pos) return;
		if(l==r&&l==pos){
			sum[p]=min(sum[p],num);
			return;
		}
		insert(ls,l,mid,pos,num);
		insert(rs,mid+1,r,pos,num);
		pushup(p);
	}
	
	int query(int p,int l,int r,int ql,int qr){
		if(r<l||qr<l||r<ql||qr<ql) return inf;
		if(ql<=l&&r<=qr) return sum[p];
		return min( query(ls,l,mid,ql,qr) , query(rs,mid+1,r,ql,qr) );
	}
} t;

int n,m;

int main(){
	int T=read();
	while(T--){
		m=read();n=read();
		t.build(1,1,m);
		for(int i=1;i<=n;i++){
			line[i].l=read();
			line[i].m=read();
			line[i].r=read();
		}
		sort(line+1,line+1+n,cmp);
		for(int i=1;i<=n;i++){
			if( t.query(1,1,m,line[i].l-1,line[i].m-1) != inf || t.query(1,1,m,line[i].m,line[i].r) < line[i].l || line[i].l==1 ) t.insert(1,1,m,line[i].r,line[i].m);
		}
		if(t.query(1,1,m,m,m)!=inf) printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}

```

---


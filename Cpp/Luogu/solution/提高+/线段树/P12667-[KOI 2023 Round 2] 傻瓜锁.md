# [KOI 2023 Round 2] 傻瓜锁

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

KOI 国即将举办一场“快速解锁比赛”。你作为参赛者，正在练习解锁的能力。本次比赛所用的锁因为特性特殊，被称为**傻瓜锁**。

傻瓜锁可以用一个由小写英文字母组成的字符串 $S$ 表示。你可以在一次操作中选定 $S$ 中的某个字符，将其修改为**字母表顺序中相邻的字母**。例如，当傻瓜锁的当前状态为 `"ioiaa"` 时，你可以进行以下 8 种操作：

- 将第 1 个字符 `'i'` 改为 `'h'`。
- 将第 1 个字符 `'i'` 改为 `'j'`。
- 将第 2 个字符 `'o'` 改为 `'n'`。
- 将第 2 个字符 `'o'` 改为 `'p'`。
- 将第 3 个字符 `'i'` 改为 `'h'`。
- 将第 3 个字符 `'i'` 改为 `'j'`。
- 将第 4 个字符 `'a'` 改为 `'b'`。
- 将第 5 个字符 `'a'` 改为 `'b'`。

傻瓜锁具有如下特性：**当字符串中字符按照字母表升序排列时，锁就被解开了**。也就是说，对于任意的 $i$（$1 \leq i < |S|$），必须有 $S_i \leq S_{i+1}$。

例如，`"aabbcc"`、`"eel"`、`"a"`、`"zzzzz"` 都是升序排列的；而 `"lee"`、`"ccbbaa"`、`"koi"` 则不是升序排列的。

定义一个傻瓜锁当前状态为字符串 $S$ 时，**将其解锁所需的最小操作次数**，称为该字符串 $S$ 的**难度**。你已经在练习如何快速计算 $S$ 的难度。

现在，你打算通过更难的练习方式来提升自己。

初始时，给定傻瓜锁的状态为字符串 $S$，长度为 $N$。接下来，你将接收到 $Q$ 个**更新操作（query）**，每次操作修改 $S$ 中的某一位字符。每次操作由一个整数 $i$（$1 \leq i \leq N$）和一个小写字母 $c$ 组成，表示将 $S$ 中第 $i$ 个字符改为 $c$。这些更新操作需要**按顺序依次应用**。

你的任务是：首先输出初始字符串 $S$ 的难度，之后每处理完一个更新操作，输出更新后字符串 $S$ 的难度。

## 说明/提示

**限制条件**

- $S$ 由小写英文字母组成。
- $S$ 的长度 $N$ 满足 $1 \leq N \leq 100\,000$。
- $0 \leq Q \leq 100\,000$。
- $1 \leq i \leq N$。
- $c$ 为小写英文字母，且保证 $c$ 不等于更新前 $S$ 的第 $i$ 个字符。
- “小写英文字母”指的是 `"abcdefghijklmnopqrstuvwxyz"`。

**子任务**

1. （7 分）$Q = 0$，$N \leq 5\,000$，且 $S$ 仅由 `'a'`、`'b'` 组成。
2. （6 分）$Q \leq 10$，$S$ 仅由 `'a'`、`'b'` 组成，更新后依然保持只含 `'a'`、`'b'`。
3. （5 分）$Q \leq 10$，$S$ 仅由 `'a'`、`'b'`、`'c'` 组成，更新后依然保持只含这三种字符。
4. （4 分）$Q \leq 10$，$S$ 仅由 `'a'`、`'b'`、`'c'`、`'d'`、`'e'` 组成，更新后依然保持如此。
5. （3 分）$Q \leq 10$。
6. （12 分）$S$ 仅由 `'a'`、`'b'` 组成，更新后依然保持如此。
7. （10 分）$S$ 仅由 `'a'`、`'b'`、`'c'` 组成，更新后依然保持如此。
8. （8 分）$S$ 仅由 `'a'`、`'b'`、`'c'`、`'d'`、`'e'` 组成，更新后依然保持如此。
9. （45 分）无附加限制。

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
ababba
5
1 b
3 b
2 a
2 b
5 a```

### 输出

```
2
2
1
2
1
2```

## 样例 #2

### 输入

```
acabed
5
1 c
2 a
3 d
4 c
5 a```

### 输出

```
3
4
3
5
4
5```

## 样例 #3

### 输入

```
acaykp
6
1 c
2 a
5 a
6 k
3 p
4 c```

### 输出

```
16
16
16
26
26
31
17```

## 样例 #4

### 输入

```
zaire
1
5 r```

### 输出

```
38
25```

# 题解

## 作者：Crazyouth (赞：4)

## 分析

~~本来看到这题第一眼想到了用数据结构维护 dp 值的，然后就想不到后续了，就去看题解，结果题解也看不懂。~~

后来我就想，我要不干脆直接把 dp 扔掉，只保留数据结构呢？

我们发现这个字符串改完之后是不降的，其实意味着我们可以弄出 $26$ 个区间 $[l_1,r_1),[l_2,r_2),\cdots,[l_{26},r_{26})$，使得 $[l_1,r_1)$ 之间全部是 `a`、$[l_2,r_2)$ 之间全部是 `b`，以此类推。特别地，如果 $l_i=r_i$，意味着第 $i$ 个小写字母在字符串中不存在。也就是说，如果我们能在开始和每次修改后设法找到这 $26$ 个区间，那么这道题就可以做完。

我们提一下另外一部分思路。首先这个串可以先被变成全都是 `a` 的串，这个串一定是不降的，但不一定是最少操作次数的，因为有很多冗余操作，这时我们就要反悔。例如样例 $1$ 中的串 `ababba`，我如果把它全变成 `a` 要花费 $3$ 次操作，这时如果我把那些 `b` 反悔了，连同中间夹着的 `a` 一起变为 `b`，那么序列是 `abbbbb`，仅需 $2$ 次操作。这样反悔为啥减少了操作次数？因为每反悔一个比 `a` 大的字符变为 `b`，就减少了一次冗余操作，但每把一个小于等于 `a` 的字符反悔为一个 `b`，就增加了一次操作。不过在样例中，减少的多于增加的，所以总操作减少了。我们又会发现，当我们进行反悔操作时，由于整个序列必须是不降，那么我们一定会反悔串的一个后缀，此时那些每被反悔掉的字符就变成了上一段提到的区间。举个例子：`abadc`，在一开始变成 `aaaaa` 后，发现后 $4$ 位中大于 `a` 的字符数比小于等于 `a` 的多，所以反悔一次，字符串变为 `abbbb`，可得出 $l_1=1,r_1=2$，因为这个区间不会再改变，区间外的字符也不会变成它了；继续操作，可以把后 $3$ 位再反悔了，字符串变为 `abccc`；再然后发现再反悔没有意义了，所以这个串会变成 `abccc`（这次是操作数最少的了）。

那你可能会问，我只知道最终序列变成了啥，我怎么知道要几次操作啊？那我们可以先从如何决定反悔操作说起。把上一段所说的反悔操作描述一下，就是我们找到当前未判断是否需要反悔的那段后缀，找到后缀中的一个位置，且那个位置往后的字符中，大于等于要反悔为的字符数量减小于的尽可能大，就在那个位置反悔后缀。如果有多个这种位置，取更靠前的一定不劣；如果那个位置处反悔都不优，那就结束反悔流程。此时问题转化为单点修改，区间查询最大值以及其位置，这个不难。这样一来，我们其实也知道了一个区间反悔的时候减少的操作数减去增加的操作数，只要统计出一开始把字符串变为全 `a` 的操作数再减去后面每次反悔的该值就可以得出最终所需的操作数。

由于我们需要对每个字符都维护后缀大于等于它的减小于它的有多少，所以要开 $26$ 棵线段树，空间复杂度 $O(|\Sigma||S|)$，时间复杂度 $O(|\Sigma||S|\log |S|)$，可以通过。

## AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=100010;
int tr[N<<2][27],lz[N<<2][27],pos[N<<2][27],n,cnt[27],a[N][27];
int sum;
string str;
void pushup(int type,int p)
{
	tr[p][type]=max(tr[p<<1][type],tr[p<<1|1][type]);
	if(tr[p<<1][type]>=tr[p<<1|1][type]) pos[p][type]=pos[p<<1][type];
	else pos[p][type]=pos[p<<1|1][type];
}
void build(int type,int s=1,int t=n,int p=1)
{
	if(s==t)
	{
		tr[p][type]=a[s][type];
		pos[p][type]=s;
		return;
	}
	int m=s+t>>1;
	build(type,s,m,p<<1);build(type,m+1,t,p<<1|1);
	pushup(type,p);
}
void upd(int type,int l,int r,int c,int s=1,int t=n,int p=1)
{
	if(l<=s&&t<=r)
	{
		tr[p][type]+=c;
		lz[p][type]+=c;
		return;
	}
	int m=s+t>>1;
	if(lz[p][type])
	{
		lz[p<<1][type]+=lz[p][type];
		lz[p<<1|1][type]+=lz[p][type];
		tr[p<<1][type]+=lz[p][type];
		tr[p<<1|1][type]+=lz[p][type];
		lz[p][type]=0;
	}
	if(l<=m) upd(type,l,r,c,s,m,p<<1);
	if(r>m) upd(type,l,r,c,m+1,t,p<<1|1);
	pushup(type,p);
}
int ps;
int qmax(int type,int l,int r,int s=1,int t=n,int p=1)
{
	if(l<=s&&t<=r)
	{
		ps=pos[p][type];
		return tr[p][type];
	}
	int m=s+t>>1;
	int ans=0;
	if(lz[p][type])
	{
		lz[p<<1][type]+=lz[p][type];
		lz[p<<1|1][type]+=lz[p][type];
		tr[p<<1][type]+=lz[p][type];
		tr[p<<1|1][type]+=lz[p][type];
		lz[p][type]=0;
	}
	if(r>m) ans=qmax(type,l,r,m+1,t,p<<1|1);
	if(l<=m) ans=max(ans,qmax(type,l,r,s,m,p<<1));
	return ans;
}
inline void query()
{
	int ans=sum-n;
	int pt=1;
	for(int i=2;i<=26;i++)
	{
		int mx=qmax(i,pt,n);
		if(mx<=0) break;
		ans-=mx;
		pt=ps;
	}
	cout<<ans<<'\n'; 
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>str;
	n=str.size();
	str=' '+str;
	for(int i=n;i;i--)
	{
		cnt[str[i]-'a'+1]++;
		sum+=str[i]-'a'+1;
		int nsum=0;
		for(int j=26;j;j--)
		{
			nsum+=cnt[j];
			a[i][j]=nsum-(n-i+1-nsum);
		}
	}
	for(int i=1;i<=26;i++) build(i);
	query();
	int q;
	cin>>q;
	while(q--)
	{
		int k;
		char x;
		cin>>k>>x;
		sum-=str[k]-'a'+1;
		for(int i=1;i<=str[k]-'a'+1;i++) upd(i,1,k,-1);
		for(int i=str[k]-'a'+2;i<=26;i++) upd(i,1,k,1);
		str[k]=x;
		sum+=x-'a'+1;
		for(int i=1;i<=x-'a'+1;i++) upd(i,1,k,1);
		for(int i=x-'a'+2;i<=26;i++) upd(i,1,k,-1);
		query();
	}
}

---

## 作者：rabbit_mygo (赞：0)

# 前言
听 chenzhe 说 KOI 的题目很适合 CSP-S 及以下同学食用，望风而来，结果大败而归。费尽周章弄懂做法后，作此题解浅浅纪念。  
特别鸣谢 dalao Needna 给予的无私全面指导和支持。  
参考资料：https://www.luogu.me/paste/fv7k6c57#
# 题目描述
给定长度为 $|S|$ 的由小写字母组成的字符串 $S$。求出由小写字母构成的字符串 $T$ 的 $\sum_{i=1}^{|S|}|\operatorname{ord}(S_i)-\operatorname{ord}(T_i)|$ 最小值。  
其中，$T$ 满足 $\forall i \in [1,|S|-1],\operatorname{ord}(T_i) \leq \operatorname{ord}(T_{i+1})$。  
同时支持 $q$ 次单点修改并求出修改后的最小值。  
数据范围：$1 \leq |S|,q \leq 100000$。
# 思路分析
## 1.基础动态规划（不考虑单点修改）
先不考虑单点修改，是一个显然的 DP。  
定义 $f_{i,j}$ 表示考虑到第 $i$ 个字符结尾字符的 ASCII 值小于等于 $j+97$ 的最小代价（$97$ 是字符 $a$ 的 ASCII 值），则有转移：$f_{i,j} \gets f_{i-1,j}+\max(0,\operatorname{ord}(S_i)-j-97)$ （因为 $f_{i,j}$ 是满足 $\operatorname{ord}(S_i) \leq j+97$ 的代价，所以第 $i$ 个字符只在 $\operatorname{ord}(S_i) \gt j+97$ 时产生实质代价）。  
时间复杂度 $O(|\Sigma||S|)$，其中 $|\Sigma|$ 为字符集大小。
## 2.线段树处理单点修改
如果加入单点修改，那么复杂度 $O(q|\Sigma||S|)$，无法接受，考虑优化。  
发现一个大区间的答案可以由两个子区间的答案转移而来，可以用线段树维护单点修改。  
具体来说，定义 $f_{u,i,j}$ 为节点 $u$ 的左端点字符大于等于 $i$，右端点字符小于等于 $j$ 的最小代价，则有转移：$f_{u,i,j} \gets \min_{0 \leq i \leq j \leq 25,i \leq k \leq j} \{f_{ls_u,i,k}+f_{rs_u,k,j}\}$，其中 $ls_u$ 表示 $u$ 的左子节点，$rs_u$ 表示 $u$ 的右子节点。  
时间复杂度 $O(|\Sigma|^3|S|)$，仍然无法通过，需要优化。  
## 3.四边形不等式优化区间 DP
如果您熟悉区间 DP，并且了解四边形不等式的话，您就会发现上述转移能优化到 $O(|\Sigma|^2|S|)$（如果涉猎较少，请自行了解）。  
具体实现这里不做赘述。  
仍然无法通过，所以还要优化。  
## 4.正解
**引理**：$\sum_{i=1}^{|S|} |\operatorname{ord}(S_i)-\operatorname{ord}(T_i)| = \sum_{i=0}^{25} \operatorname{bin}(S,i)$  
其中 $\operatorname{bin}(S,i)$ 表示将 $S$ 映射为二进制数组 $a$，数组 $b$ 的 $\sum_{i=1}^{|S|} |a_i-b_i|$。  
$\operatorname{bin}(S,i)$ 中，数组 $a$ 满足 $\forall k \in [1,|S|],a_k \gets \begin{cases} 1, & \operatorname{ord}(S_k) \geq i+97, \\ 0, & \operatorname{ord}(S_k) \lt i+97. \end{cases}$，数组 $b$ 满足 $\forall i \in [1,|S|-1],b_i \leq b_{i+1}$。

简单来说，就是维护一个二进制数组，其中：当原字符串中的字符大于等于 $i+97$ 时，对应位置为 $1$，否则为 $0$。  
然后原题的代价就会等价于将所有字符集内的二进制数组变为单调不降的代价。  
经过深入理解后，感性告诉我们这是正确的，如何证明呢？

**证明**：    
$\begin{aligned} \sum_{i=1}^{|S|}|\operatorname{ord}(S_i)-\operatorname{ord}(T_i)| &= \sum_{i=1}^{|S|} \sum_{c=97}^{122}|[\operatorname{ord}(S_i) \geq c] - [\operatorname{ord}(T_i) \geq c]| \\ &= \sum_{c=97}^{122} \sum_{i=1}^{|S|}|[\operatorname{ord}(S_i) \geq c] - [\operatorname{ord}(T_i) \geq c]| \\ &= \sum_{i=0}^{25} \operatorname{bin}(S,i)
\end{aligned}$

由引理得：
$$\begin{aligned} \min(\sum_{i=1}^{|S|}|\operatorname{ord}(S_i)-\operatorname{ord}(T_i)|) &= \min(\sum_{i=0}^{25} \operatorname{bin}(S,i)) \\ &= \sum_{i=0}^{25} \min(\operatorname{bin}(S,i)) \end{aligned}$$

那么问题就转化为分别维护 $25$ 个 $01$ 串单调不降的最小代价了（$\operatorname{bin}(S,0)$ 不用维护，因为 $\operatorname{bin}(S,0) = 0$ 恒成立）。  
$01$ 串的单调不降最小代价跟 $01$ 分界点有着密切联系。  
具体来说，我们在线段树上维护两个信息：$op_u,s0_u$，分别表示 $u$ 节点区间单调不降的最小代价和 $u$ 节点区间内 $0$ 的个数。这些是好维护的。  
然后 pushup 时，$s0_u = s0_{ls_u}+s0_{rs_u}$。$op_u$ 则要分别讨论 $01$ 分界点在左子区间和右子区间的情况，即有：$op_u = \min(op_{ls_u}+s0_{rs_u},op_{rs_u}+s1_{ls_u})$，其中 $s1_u$ 表示节点 $u$ 的区间内 1 的数量，可以由区间长度减去 $s0$ 得到。  
时间复杂度 $O(|\Sigma||S|)$。

卡常细节：修改时可以先判断 $\operatorname{bin}(S,i)$ 中会改变的 $i$ 的取值范围，不用从 $0$ 到 $25$ 全部更新。
# 代码实现
```cpp
#include <cstdio>
#include <queue>
#include <cstring>
typedef long long ll;
void output(ll x){// 快输
	if(x>9)output(x/10);
	putchar(x%10^48);
}
inline int readx(){// 快读
	int x = 0,y = 1;char c = getchar();
	for(;c<48||c>58;c = getchar())if(c=='-')y = -1;
	for(;c>=48&&c<=58;c = getchar())x = (x<<1)+(x<<3)+(c^48);
	return x*y;
} 
const int N = 1e5+10,K = 26;
char s[N];
inline int min(int x,int y){return x<y?x:y;}
struct segment_tree{
	int op[N<<2][K],s0[N<<2][K];
	inline void pushup(int u,int l,int r,int mid,int pl,int pr){
		int ls = u<<1,rs = u<<1|1;
		for(int i = pl;i <= pr;i++){
			s0[u][i] = s0[ls][i]+s0[rs][i];
			op[u][i] = min(op[ls][i]+s0[rs][i],op[rs][i]+mid-l+1-s0[ls][i]); 
		}
	}
	void bd(int u,int l,int r){
		if(l==r){
			s[l]-='a';
			for(int i = 1;i <= 25;i++)s0[u][i] = s[l]<i;
			return;
		}int mid = l+r>>1;
		bd(u<<1,l,mid),bd(u<<1|1,mid+1,r);
		pushup(u,l,r,mid,1,25);
	}
	void my(int u,int l,int r,int pos,int pl,int pr){
		if(r<pos||l>pos)return;
		if(l==r&&l==pos){
			for(int i = pl;i <= pr;i++)s0[u][i] = s[l]<i;
			return;
		}int mid = l+r>>1;
		my(u<<1,l,mid,pos,pl,pr),my(u<<1|1,mid+1,r,pos,pl,pr);
		pushup(u,l,r,mid,pl,pr);
	}
	int qy(){
		int ans = 0;
		for(int i = 1;i <= 25;i++)ans+=op[1][i];
		return ans;
	}
}T;// 线段树
inline int max(int x,int y){return x<y?y:x; }
int main(){
	scanf(" %s",s+1);int n = strlen(s+1);
	T.bd(1,1,n);
	output(T.qy()),putchar('\n');
	int q = readx();char ch;
	while(q--){
		int pos = readx();scanf(" %c",&ch);ch-='a';int pl = max(1,min(s[pos],ch)),pr = max(1,max(s[pos],ch));// 仅更新被影响的二进制
		s[pos] = ch;
		T.my(1,1,n,pos,pl,pr);
		output(T.qy()),putchar('\n');
	} 
	return 0;
}
```
最后祝您：万事如意！（q'w'q)

---


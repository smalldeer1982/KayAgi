# BZOJ3589 动态树

## 题目描述

别忘了这是一棵动态树，每时每刻都是动态的。

小明要求你在这棵树上维护两种事件：

- 事件 0：这棵树长出了一些果子，即某个子树中的每个节点都会长出 $k$ 个果子。
- 事件 1：小明希望你求出几条树枝上的果子数。一条树枝其实就是一个从某个节点到根的路径的一段。

每次小明会选定一些树枝，让你求出在这些树枝上的节点的果子数的和。注意，树枝之间可能会重合，这时重合的部分的节点的果子只要算一次。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 2 \times 10^5$，$1 \leq Q \leq 2 \times 10^5$，$k = 5$。

生成每个树枝的过程是这样的：先在树中随机找一个节点，然后在这个节点到根的路径上随机选一个节点，这两个节点就作为树枝的两端。

## 样例 #1

### 输入

```
5
1 2
2 3
2 4
1 5
3
0 1 1
0 2 3
1 2 3 1 1 4```

### 输出

```
13```

# 题解

## 作者：zyn_ (赞：4)

题意：一棵树，点有点权，支持子树加，求若干条链的并集的点权和。

链的并集好可怕啊，怎么维护？直接上重链剖分，一条链变成 $O(\log n)$ 个区间，区间的并集就很和蔼了。

按左端点从小到大排序遍历区间，维护当前的区间并集 $[l,r]$。设遍历到 $[l_0,r_0]$，若 $l_0>r$ 则用 $[l,r]$ 更新答案，以后的区间不会包含 $\le r$ 的数了，直接 $[l,r]\gets [l_0,r_0]$；否则将 $[l_0,r_0]$ 合并，$r\gets \max\{r,r_0\}$ 即可。给出代码：

```cpp
l=f[1].l,r=f[1].r;
for(int i=2;i<=c;++i){
    if(f[i].l>r)ans+=qr(l,r,1,n,1),l=f[i].l,r=f[i].r;
    else r=max(r,f[i].r);
}
ans+=qr(l,r,1,n,1);
```

剩下的就是区间加区间和，线段树即可。

---

## 作者：WegestGao (赞：3)

# 简化题面

给你一个 $n$ 个节点的树，有 $q$ 次操作。对于 ``0`` 操作，需要对节点为 $x$ 的子树加上一个给定的 $k$ 数值；对于 ``1`` 操作，给定点对组数 $k$，设每组点对为 $u_i,v_i$，先求使两者连通的经过节点最少的路径所包含节点的权值的和，记为 $\operatorname{sum}(i)$，求
$$
result=\sum_{i=1}^{k}\operatorname{sum}(i).
$$

#### 提醒

- 本篇题解的数组美观起见都采用函数的形式记录。例子：如果一个数组是一维数组，名称为 $\texttt{abc}$，那么数组第 $i$ 号元素为 $\operatorname{abc}(i)$。
- 树链剖分、线段树不熟者慎入。如果没有学习过线段树，可以先去看一下[【模板】线段树1](https://www.luogu.com.cn/problem/P3372)（对于本篇题解，线段树知识点你只需要知道它的区间求和、区间查询即可）；如果没有学习过树链剖分，可以先去看一下[【模板】重链剖分/树链剖分](https://www.luogu.com.cn/problem/P3384)。

### 如果有任何问题，欢迎各位大神在评论区内批评指正！

# 思路解析

## 思维方向

这是一道用**树链剖分+线段树**解决的题目。何以见得？

- 本题目要求有多种操作，有经验的老手会发现对于这种给 $q$ 个操作的题目，很多情况下都适用线段树。当然，事实也的确如此。另外，面对此题数据，用更小的时间消耗，得到更庞大的整体答案，也是需要线段树的帮助的。

- 树链剖分是一个很广泛的应用。他最主要的特点是能快速求 LCA 一类及其衍生问题，同时也可以将树形结构转变为线性结构，使得空间简化，相应地时间也就简化。


## 题目讲解

### 前期工作

直接套模板。在建完树以后，我们进行两遍 DFS 进行预处理。第一遍 DFS，深度、父亲的递推式如下：

$$
\operatorname{dep}(u) \gets \operatorname{dep}(f)+1,
\\
\operatorname{fa}(u) \gets f,
$$

其中，$u$ 为该树上任意一点，由基本事实得其必然为该树任意一棵子树的根节点。同时，$v$ 是 $u$ 的子节点，$v$ 需要遍历 $u$ 的所有子节点。对于 $\operatorname{size}(u)$ 而言，除了基本形式外，若没有子节点 $v$ 满足 $\operatorname{fa}(v)=u$（即没有子节点），则对于该 $u$ 的所有任何子节点 $v$，都有 $\operatorname{size}(v)=0$。如下：

$$
\operatorname{size}(u) \gets \sum_{v \in \operatorname{son}(u)} \operatorname{size}(v)+1,
$$

同时，我们还需要得到重儿子。当且仅当 $\operatorname{size}(\operatorname{wc}(u))<\operatorname{size}(v)$ 时，使用以下转换条件：

$$
\operatorname{wc}(u) \gets v.
$$

这样，第一遍 DFS 就处理完了。第二遍 DFS，按照重儿子优先排序的已知 $u$ 可得到的 DFS 序、已知 DFS 序编号可得到树上对应 $u$ 节点的递推式在每次 $tot$ 自加以后如下所示：

$$
\operatorname{dfn}(u) \gets tot, \\
\operatorname{bdfn}(tot) \gets u, 
$$

而对于每个节点 $u$，如果 $v=\operatorname{wc}(u)$，那么

$$
\operatorname{top}(v) \gets \operatorname{top}(u),
$$

反之，只考虑 $u$ 子节点的情况，则有

$$
\operatorname{top}(v) \gets v.
$$

当然，为了方便，我们的代码按照 DFS 的特性，换一种更便捷的方式写：

```cpp
void dfs1(int u,int f){
    fa[u]=f;
    dep[u]=dep[f]+1;
    size[u]=1;//子树根节点是子树一部分，计算大小要带上子树祖宗
    for(int i=0;i<g[u].size();i++){
        int v=g[u][i];
        if(v==f) continue;
        dfs1(v,u);
        size[u]+=size[v];//众子孙，一个也不能少
        if(size[wc[u]]<size[v]) wc[u]=v;//长子要选好
    }
}
void dfs2(int u,int ff){//两个f，足以说明祖宗地位，可见其是每个链的祖宗
    dfn[u]=++tot;
    bdfn[tot]=u;//b，back，将dfs序的序号传回树上节点序号
    top[u]=ff;
    int v=wc[u];
    if(wc[u]!=0) dfs2(v,ff);//大儿子继承家业
    for(int i=0;i<g[u].size();i++){
        v=g[u][i];
        if(v==fa[u]||v==wc[u]) continue;
        dfs2(v,v);
    }
}
```

### 第一问

对于第一个问题，我们这里不多进行赘述。实际上，对于每个子树而言，根据 DFS 的性质就可以知道其 DFS 序一定是连续的。于是，对于子树的集体修改，就可以转换成对于线段树中

$$
\operatorname{dfn}(u),\operatorname{dfn}(u)+1,\operatorname{dfn}(u)+2,\dots,\operatorname{dfn}(u)+\operatorname{size}(u)-1
$$

区间的修改。代码如下：~~（甚至连剖分都没用上）~~

```cpp
void maketag(int u,int l,int r,int k){
    int len=(r-l+1+mod)%mod;//要mod到位
    tree[u]=(tree[u]+len*k+mod)%mod;
    lzytag[u]=(lzytag[u]+k+mod)%mod;
}
void pushup(int u){
    tree[u]=(tree[u*2]+tree[u*2+1]+mod)%mod;
}
void pushdown(int u,int l,int r){
    int mid=(l+r)/2;
    maketag(u*2,l,mid,lzytag[u]);
    maketag(u*2+1,mid+1,r,lzytag[u]);
    lzytag[u]=0;
}
bool InRange(int l,int r,int x,int y){
    if(l>=x&&r<=y) return true;
    else return false;
}
bool OutofRange(int l,int r,int x,int y){
    if(l>y||r<x) return true;
    else return false;
}
void update(int u,int l,int r,int x,int y,int k){
    if(InRange(l,r,x,y))
        maketag(u,l,r,k);
    else if(!OutofRange(l,r,x,y)){
        pushdown(u,l,r);
        int mid=(l+r)/2;
        update(u*2,l,mid,x,y,k);
        update(u*2+1,mid+1,r,x,y,k);
        pushup(u);
    }
}
void addtree(int u,int k){//k指加上的果子数，别搞混了
    update(1,1,n,dfn[u],dfn[u]+size[u]-1,k);
}
```

### 第二问

我们着重介绍第二个问题，现在我们知道了对于这个询问而言的 $k$ 个点对 $x_i,y_i$（遍历 $i$，从 $1$ 到 $k$），显然对于每个点对我们可以通过线段树查询，最后求和，得到

$$
\sum_{i=1}^{k}\operatorname{qry}(\operatorname{dfn}(x_i),\operatorname{dfn}(y_i)).
$$

但是，重要的事情说三遍，这是**错误的！错误的！错误的！**

因为会有**重复**的情况发生。为了解决这个问题，我们需要尝试去掉重复的部分。

怎么去重？从源头出发，将所有的重复部分去掉，保证只留一个部分。

具体地，对于每个点对 $x_i,y_i$，令其通过树链剖分的方式将该部分分成了 $p$ 个链，而 $\operatorname{qry}$ 操作需要做的就是将这些链整合起来。在这个过程中，我们可以进行一定的代码修改。本来，我们能得到的是原来的最顶部元素 $\operatorname{fa}(x)$ 和链中要计入的最底部元素 $x$。但是，我们现在并不是直接处理这两个量，而是将它们存储起来。这里推荐使用 vector 容器与结构体（包含 $l,r$，刚好用来表示一个区间）相结合，代码如下：

```cpp
void addquery(int x,int y){
    while(top[x]!=top[y]){
        if(dep[x]<dep[y]) swap(x,y);
        rec.push_back({dfn[top[x]],dfn[x]});
        x=fa[top[x]];
    }
    if(dep[x]>dep[y]) swap(x,y);
    rec.push_back({dfn[x],dfn[y]});
}
```

随后，我们就得到了一个包含所有询问链区间的数组。为了更好地进行去重操作，我们先对其进行排序。如果 $\operatorname{rec}(i)_l>\operatorname{rec}(i+1)_l$，为了保证 $\operatorname{rec}(i)_l<\operatorname{rec}(i+1)_l$，那么交换两元素（包括 $l,r$）。特殊地，如果 $\operatorname{rec}(i)_l=\operatorname{rec}(i+1)_l$，那么此时若 $\operatorname{rec}(i)_r>\operatorname{rec}(i+1)_r$，则交换两元素（同上）。

尝试对其**去重**。令 $cur$ 为当前累计状态的区间（结构体存储）。对于每个 $\operatorname{rec}(i)_l$，如果有 $\operatorname{rec}(i)_l>cur_r+1$，那说明 $\operatorname{rec}(i)$ 区间与 $cur$ 区间**相离**。那么此时，对于后者，我们就可以不管不顾无忧无虑地（**因为保证**这部分 $cur$ **不会发生重复**）将其添加到一个新的 vector 容器（仍然用结构体存储），这个作为最终需要处理的区间集合，记作 $\operatorname{ans}(j)$。于是，对于该集合（为了表达出来，引用了一个 $j$。实际上，我们在代码中是用 ``push_back()`` 进行操作。$j$ 默认自加），我们有

$$
\operatorname{ans}(j) \gets cur,
$$

同时，对于 $cur$，为了保证 $cur$ 的**时效性**（因为当前的 $cur$ 已经没用了，被存在了 $\operatorname{ans}(j)$ 中），我们也有

$$
cur \gets \operatorname{rec}(i).
$$

但是，如果 $\operatorname{rec}(i)_l \leq cur_r+1$，那说明 $\operatorname{rec}(i)$ 区间与 $cur$ 区间**相交或相邻**。为了确保我们统计的答案不会有漏网之鱼，则需要更新 $cur_r$，就有

$$
cur_r=\max(cur_r,\operatorname{rec}(i)_r).
$$

代码如下：

```cpp
bool cmp(const node &x,const node &y){
    if(x.l!=y.l) return x.l<y.l;
    else return x.r<y.r;
}
void delquery(){
    if(rec.empty()) return ;
    node cur=rec[0];
    for(int i=1;i<rec.size();i++){
        if(rec[i].l>cur.r+1){
            ans.push_back(cur);
            cur=rec[i];
        }
        else cur.r=max(cur.r,rec[i].r);
    }
    ans.push_back(cur);
}
```

于是，我们就得到了最终的不重复的区间集合 $ans$。

最后，定义这个集合的长度为 $L$，我们终于能放心大胆地进行

$$
\sum_{i=1}^{L}\operatorname{qry}(\operatorname{dfn}(x_i),\operatorname{dfn}(y_i))
$$

的操作了！代码如下：

```cpp
int query(int u,int l,int r,int x,int y){
    if(InRange(l,r,x,y)) return tree[u];
    else if(!OutofRange(l,r,x,y)){
        pushdown(u,l,r);
        int mid=(l+r)/2;
        return (query(u*2,l,mid,x,y)+query(u*2+1,mid+1,r,x,y)+mod)%mod;
    }
    else return 0;
}
void qry(){
    summ=0;
    for(int i=0;i<ans.size();i++){
        summ=(summ+query(1,1,n,ans[i].l,ans[i].r)+mod)%mod;
    }
}
```

~~望管理员大大通过！！！（干了我三个小时）~~

## [完整代码点这里](https://www.luogu.com.cn/paste/9jmv5pnn)

~~（马蜂良好，自认为可读性还是不差的）~~

### $\text{Update Records:}$

- $\texttt{20250721}$ 完成题解雏形
- $\texttt{20250722}$ 进一步完善题解说明，使其通俗易懂，增强了可读性、规范性与可理解性。
- $\texttt{20250723}$ 用了更详细的语言。同时更正了一些问题，例如将 $\operatorname{top}(v) \gets \operatorname{top}(v)$ 改正成 $
\operatorname{top}(v) \gets v$。
- $\texttt{20250820}$ 改正了部分下标使用错误或不规范。

---

## 作者：WanderFreeFish (赞：3)

## Solution

这显然是一道重链剖分的题，但是求的是多条链，而且不能重复。对于并集，有如下两种思考方向。

#### Version 1

思考难度更高，代码量较小。

题目数据范围中说的是 $k \le 5$，那么考虑从这里下手，先把所有剖分出来的重链的 dfs 序存下来，去重之后再往数据结构里面修改（这里选择线段树）。

去重操作的话，可以先对重链排个序，然后维护当前修改到哪个区间，如下两种情况：

- 如果下一个区间与当前维护区间没有交集了，就把当前维护区间丢进数据结构，去维护下一个区间。

- 如果下一个区间与当前维护区间还有交集，就合并，使当前维护区间包含下一个区间。

```cpp
std::sort(edge.begin(), edge.end());
auto [l, r] = edge[0];

for (int i = 1; i < edge.size(); i++) {
	auto [st, ed] = edge[i];
	if (st > r) ans += sgtree.query(1, 1, n, l, r), ans %= mod, l = st, r = ed;
	else r = std::max(r, ed);
}
ans += sgtree.query(1, 1, n, l, r), ans %= mod;
```
![](https://cdn.luogu.com.cn/upload/image_hosting/8mhcksxt.png)

以这张图作为例子：

- 初始时，$l = 1$，$r = 5$，没有修改。
- $i = 2$ 时，此时这个 $[2, 7]$ 的区间与 $[l, r]$ 有交集，右端点向右扩展，$r \gets 7$。
- $i = 3$ 时，下一个 $[8, 14]$ 的区间与 $[l, r]$ 没有交集，可以进行区间 $[l, r]$ 的修改，放弃当前值，进行下一段连续区间，$l \gets 8$，$r \gets 14$。
- $i = 4$ 时，下一个 $[9, 12]$ 的区间与 $[l, r]$ 有交集，但是前者包含于后者，所以不动，与 $i = 2$ 时的情况综合来看，即 $r \gets \max(r, 12)$。

#### Version 2

思维难度极低，代码的话需要会可持久化。同机房大佬一眼看出来的解法。

既然说是不能重复计算，那么就可以在查询完一条链的时候，将这条链上的数都赋值为 $0$，这样就算计算重复了也不会算多。到下一次查询或修改就访问之前的版本就可以了。这种算法常数可能会大一点。

需要注意的一点是，你不能每次查询都存一遍副本，存一次副本时间复杂度是线性的，也就是 $O(n)$。

## Code

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <stack>
#include <utility>
#define mid (l + r >> 1)
#define ls (root << 1)
#define rs (root << 1 | 1)
#define lson ls, l, mid
#define rson rs, mid + 1, r

const int MAXN = 2e5 + 10, mod = 2147483648;
using ll = long long int;
using PII = std::pair <int, int>;

int n, Q, cnt;
int fa[MAXN], sz[MAXN], a[MAXN], ra[MAXN], dfn[MAXN], topf[MAXN], son[MAXN], dep[MAXN];

std::vector <int> g[MAXN];
std::vector <PII> edge;

struct segment_tree {
	std::vector <ll> tr, add, vis;
	std::stack <int> cnt;
	
	segment_tree (int l = 0) : tr(l << 2), vis(l << 2), add(l << 2) {}
	
	void push_down (int root, int l, int r) {
		tr[root] += add[root] * (r - l + 1) % mod, tr[root] %= mod;
		if (l != r) {
			add[ls] += add[root], add[rs] += add[root];
			add[ls] %= mod, add[rs] %= mod;
		}
		add[root] = 0;
	}
	
	void push_up (int root, int l, int r) {
		push_down(lson); push_down(rson);
		tr[root] = (tr[ls] + tr[rs]) % mod;
	}
	
	void build (int root, int l, int r) {
		if (l == r) {
			tr[root] = ra[l];
			return;
		}
		build(lson);
		build(rson);
		push_up(root, l, r);
	}
	
	void update (int root, int l, int r, int ql, int qr, int v) {
		push_down(root, l, r);
		
		if (ql <= l && r <= qr) {
			add[root] += v;
			add[root] %= mod;
			return;
		}
		
		if (ql <= mid) update(lson, ql, qr, v);
		if (qr > mid) update(rson, ql, qr, v);
		push_up(root, l, r);
	}
	
	ll query (int root, int l, int r, int ql, int qr) {
		push_down(root, l, r);
		
		if (ql <= l && r <= qr)
			return tr[root];
		else if (qr <= mid) return query(lson, ql, qr);
		else if (ql > mid) return query(rson, ql, qr);
		else return (query(lson, ql, qr) + query(rson, ql, qr)) % mod;
	}
};

void dfs1 (int u, int f) {
	dep[u] = dep[f] + 1, fa[u] = f, sz[u]++;
	for (int v : g[u]) {
		if (v == f) continue;
		dfs1(v, u);
		sz[u] += sz[v];
		
		if (sz[v] > sz[son[u]])
			son[u] = v;
	}
}

void dfs2 (int u, int f, int tf) {
	topf[u] = tf, dfn[u] = ++cnt, ra[cnt] = a[u];
	
	if (son[u])
		dfs2(son[u], u, tf);
	for (int v : g[u]) {
		if (v == f || v == son[u]) continue;
		dfs2(v, u, v);
	}
}

int main () {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);std::cout.tie(nullptr);
	
	std::cin >> n;
	
	for (int i = 1; i < n; i++) {
		int u, v; std::cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	
	dfs1(1, 0);
	dfs2(1, 0, 1);
	
	segment_tree sgtree(n + 1);
	sgtree.build(1, 1, n);
	
	std::cin >> Q;
	
	while (Q--) {
		int op; std::cin >> op;
		
		if (op == 0) {
			int u, delta; std::cin >> u >> delta;
			sgtree.update(1, 1, n, dfn[u], dfn[u] + sz[u] - 1, delta);
		}
		else {
			int k; std::cin >> k;
			
			ll ans = 0; edge.clear();
			
			for (int i = 1; i <= k; i++) {
				int u, v; std::cin >> u >> v;
				while (topf[u] != topf[v]) {
					int tu = topf[u], tv = topf[v];
					if (dep[tu] < dep[tv]) {
						std::swap(tu, tv);
						std::swap(u, v);
					}
					edge.push_back({dfn[tu], dfn[u]});
					u = fa[tu];
				}
				
				if (dep[u] < dep[v])
					std::swap(u, v);
				edge.push_back({dfn[v], dfn[u]});
			}
			
			std::sort(edge.begin(), edge.end());
			auto [l, r] = edge[0];
			
			for (int i = 1; i < edge.size(); i++) {
				auto [st, ed] = edge[i];
				if (st > r) ans += sgtree.query(1, 1, n, l, r), ans %= mod, l = st, r = ed;
				else r = std::max(r, ed);
			}
			ans += sgtree.query(1, 1, n, l, r), ans %= mod;
			
			std::cout << ans << '\n';
		}
	}
	
	return 0;
}
```

第二种就是树链剖分板子改个可持久化就行了。

---

## 作者：liangjiande (赞：3)

感谢洛谷管理员的积极审核。  
#### [原题链接](https://www.luogu.com.cn/problem/P12693)  
我们看到这道题叫动态树，但其实这是一道很板子的重链剖分，不会的[看这里](https://www.luogu.com.cn/problem/P3384)。  
### 具体分析
对于事件 0，我们考虑使用线段树加重链剖分来解决。   
对于事件 1，我们考虑将每条树枝都拆成重链上的区间，操作如下：
```
#define V vector
using P=array<int,2>;//这是一个很好用的结构
V<P> get_path(int u,int v){//摘取区间
    V<P> res;
    while(top[u]!=top[v]){//类比LCA
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        res.push_back({id[top[u]],id[u]});
        u=fa[top[u]];
    }
    if(dep[u]>dep[v]) swap(u,v);
    res.push_back({id[u],id[v]});
    return res;
}
```
可以看到，这个操作很像树剖求最近公共祖先，因为树上两个节点之间的路径经过它们的最近公共祖先。   
但是我们把树枝拆开了，还需要将这些区间合并起来，做到不重不漏。因此我们采用根据左端点排序的方式来排序区间，最后用一个指针来合并。具体操作如下：
```
            int k;cin>>k;
            V<P> t;
            for(int i=0;i<k;i++){
                int u,v;cin>>u>>v;
                auto path = get_path(u,v);
                for(auto i:path){
                	int l=i[0],r=i[1];
                    if(l>r) swap(l,r);
                    t.push_back({l,r});
                }
            }
            // 合并区间
            sort(t.begin(),t.end());//这里不使用自定义的函数是因为array<int,2>按照关键字排序，其中L为第一关键字，R为第二关键字
            int ans=0;
            if(!t.empty()){
                int l=t[0][0],r=t[0][1];
                for(int i=1;i<t.size();i++){
                    if(t[i][0]<=r){
                        r=max(r,t[i][1]);
                    }else{
                        ans=(ans+lls.query(1,l,r))%mod;
                        l=t[i][0];
                        r=t[i][1];
                    }
                }
                ans=(ans+lls.query(1,l,r))%mod;
            }
            cout<<ans<<"\n";
```
好了，所有事件都处理完了，那么就把完整代码放上来。
### AC code
```
#include<bits/stdc++.h>
#define int long long
#define bug cout<<"BUG\n"
#define V vector
using namespace std;
const int N=2e5+10;
const int mod=(1ll<<31);
struct SegTree{
	struct node{
		int l,r,w,tag;
	};
	V<node>a;
	SegTree(int _n):a(_n*4+2){}
	inline int ls(int x){return x<<1;}
	inline int rs(int x){return x<<1|1;}
	void push_up(int x){
		a[x].w=a[ls(x)].w+a[rs(x)].w;
		a[x].w%=mod;
	}
	void addtag(int x,int w){
		(a[x].tag+=w)%=mod;
		(a[x].w+=w*(a[x].r-a[x].l+1))%=mod;
	}
	void push_down(int x){
		if(!a[x].tag)return;
		addtag(ls(x),a[x].tag);
		addtag(rs(x),a[x].tag);
		a[x].tag=0;
	}
	void build(int x,int l,int r,V<int>&b){
		a[x].l=l;a[x].r=r;
		if(l==r){
			a[x].w=b[l]%mod;
			return;
		}
		int mid=l+r>>1;
		build(ls(x),l,mid,b);build(rs(x),mid+1,r,b);
		push_up(x);
	}
	void update(int x,int L,int R,int w){
		w%=mod;
		if(a[x].l>=L&&a[x].r<=R){
			addtag(x,w);
			return;
		}
		push_down(x);
		int mid=(a[x].l+a[x].r)>>1;
		if(L<=mid)update(ls(x),L,R,w);
		if(R>mid)update(rs(x),L,R,w);
		push_up(x);
	}
	int query(int x,int L,int R){
		if(a[x].l>R||a[x].r<L) return 0;
		if(a[x].l>=L&&a[x].r<=R) return a[x].w;
		push_down(x);
		int res=0,mid=(a[x].l+a[x].r)>>1;
		if(L<=mid) (res+=query(ls(x),L,R))%=mod;
		if(R>mid) (res+=query(rs(x),L,R))%=mod;
		return (res+mod)%mod;
	}
};
using P=array<int,2>;
V<V<int> >e;
V<int>id,siz,son,val,former,fa,dep,top;
int cnt=0;
void dfs1(int u,int fat){
	fa[u]=fat;
	dep[u]=dep[fat]+1;
	siz[u]=1;
	for(int v:e[u]){
		if(v==fat)continue;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(!son[u]||siz[son[u]]<siz[v]) son[u]=v;
	}
}
void dfs2(int u,int tp){
	top[u]=tp;
	id[u]=++cnt;
	val[cnt]=former[u];
	if(!son[u])return;
	dfs2(son[u],tp);
	for(int v:e[u]){
		if(v==fa[u]||v==son[u])continue;
		dfs2(v,v);
	}
}
void update(SegTree &lls,int u,int w){//在u的子树加w
	lls.update(1,id[u],id[u]+siz[u]-1,w);
}
V<P> get_path(int u,int v){//摘取区间
    V<P> res;
    while(top[u]!=top[v]){//类比LCA
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        res.push_back({id[top[u]],id[u]});
        u=fa[top[u]];
    }
    if(dep[u]>dep[v]) swap(u,v);
    res.push_back({id[u],id[v]});
    return res;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int n;cin>>n;
	e.resize(n+1);id.resize(n+1);fa.resize(n+1);
	val.resize(n+1);former.resize(n+1);top.resize(n+1);
	siz.resize(n+1);son.resize(n+1);dep.resize(n+1);
	for(int i=1,a,b;i<n;i++){
		cin>>a>>b;
		e[a].push_back(b);e[b].push_back(a);
	}
	dfs1(1,0);dfs2(1,1);//树剖
	SegTree lls(n+1);lls.build(1,1,n,val);//定义线段树并建树
	int q;cin>>q;
	while(q--){
		int op;
		cin>>op;
		if(!op){//修改
			int u,w;
			cin>>u>>w;
			update(lls,u,w);
		}else{
			int k;cin>>k;
            V<P> t;
            for(int i=0;i<k;i++){
                int u,v;cin>>u>>v;
                auto path = get_path(u,v);
                for(auto i:path){
                	int l=i[0],r=i[1];
                    if(l>r) swap(l,r);
                    t.push_back({l,r});
                }
            }
            // 合并区间
            sort(t.begin(),t.end());
            int ans=0;
            if(!t.empty()){
                int l=t[0][0],r=t[0][1];
                for(int i=1;i<t.size();i++){
                    if(t[i][0]<=r){
                        r=max(r,t[i][1]);
                    }else{
                        ans=(ans+lls.query(1,l,r))%mod;
                        l=t[i][0];
                        r=t[i][1];
                    }
                }
                ans=(ans+lls.query(1,l,r))%mod;
            }
            cout<<ans<<"\n";
		}
	}
	return 0;
}
```

---

## 作者：jojo_fan (赞：1)

## 题意描述
维护一棵树。
- 操作 $0$：以 $u$ 为根的子树中的每个节点长出了 $delta$ 个果子。
- 操作 $1$：给定 $k$ 条树枝，求这些路径并集上的果子总数，结果模 $2^{31}$。
## 解题思路
树链剖分：将树转化为序列，便于处理子树修改和路径查询。\
第一次 dfs：计算子树大小 $siz$、深度 $dep$、父节点 $fa$ 和重儿子 $hson$。\
第二次 dfs：进行重链剖分，得到 dfs 序 $dfn$ 和重链顶端 $top$。

子树修改：子树在 dfs 序上对应连续区间，直接区间修改。\
路径查询：对于每个操作 $1$，将 $k$ 条路径拆分成区间并存储。按左端点排序，合并重叠区间。对每个合并后的区间进行查询并累加，结果模 $2^{31}$。
## 代码
```cpp
#include"bits/stdc++.h"
#define ll long long
#define int ll
using namespace std;

const int N=2e5+10;
const int mod=pow(2,31);
int n,q;
vector<int> e[N];

void add(int u,int v)
{
	e[u].push_back(v);
	e[v].push_back(u);
}

int dep[N],siz[N],fa[N],hson[N],top[N],dfn[N],rv[N];

void dfs1(int u,int f)
{
	dep[u]=dep[f]+1;
	siz[u]=1;
	fa[u]=f;
	for(auto v:e[u])
	{
		if(v==f) continue;
		dfs1(v,u);
		siz[u]+=siz[v];
		hson[u]=(siz[hson[u]]<siz[v])?v:hson[u];
	}
}

void dfs2(int u,int tp)
{
	static int tim=0;
	top[u]=tp;
	rv[dfn[u]=++tim]=u;
	if(!hson[u]) return;
	dfs2(hson[u],tp);
	for(auto v:e[u])
	{
		if(v==fa[u]||v==hson[u]) continue;
		dfs2(v,v);
	}
}

int seg[N<<2],tag[N<<2];

void pushdown(int x,int l,int r)
{
	if(!tag[x]) return;
	tag[x<<1]+=tag[x];
	tag[x<<1|1]+=tag[x];
	int mid=(l+r)>>1;
	seg[x<<1]+=tag[x]*(mid-l+1);
	seg[x<<1|1]+=tag[x]*(r-mid);
	tag[x]=0;
}

void modify(int x,int l,int r,int ql,int qr,int k)
{
	if(ql<=l&&r<=qr) return seg[x]+=k*(r-l+1),tag[x]+=k,void();
	pushdown(x,l,r);
	int mid=(l+r)>>1;
	if(ql<=mid) modify(x<<1,l,mid,ql,qr,k);
	if(qr>mid) modify(x<<1|1,mid+1,r,ql,qr,k);
	seg[x]=seg[x<<1]+seg[x<<1|1];
}

int query(int x,int l,int r,int ql,int qr)
{
	if(ql<=l&&r<=qr) return seg[x];
	pushdown(x,l,r);
	int mid=(l+r)>>1,ans=0;
	if(ql<=mid) ans+=query(x<<1,l,mid,ql,qr);
	if(qr>mid) ans+=query(x<<1|1,mid+1,r,ql,qr);
	return ans;
}

void modify_tree(int u,int k) {modify(1,1,n,dfn[u],dfn[u]+siz[u]-1,k);}

struct Edge
{
	int l,r;
	Edge(int _l=0,int _r=0): l(_l),r(_r){}
};

vector<Edge> edge;

void query_chain(int u,int v)
{
	while(top[u]!=top[v])
	{
		if(dep[top[u]]<dep[top[v]]) swap(u,v);
		edge.push_back(Edge(dfn[top[u]],dfn[u]));
		u=fa[top[u]];
	}
	if(dep[u]>dep[v]) swap(u,v);
	edge.push_back(Edge(dfn[u],dfn[v]));
}

void init()
{
	int ans=0;
	sort(edge.begin(),edge.end(),[](const Edge&a,const Edge&b)
	{
		if(a.l==b.l) return a.r<b.r;
		return a.l<b.l;
	});
	int L,R;
	for(int i=0;i<edge.size();i++) 
	{
		if(i==0) L=edge[i].l,R=edge[i].r;
		else
		{
			if(edge[i].l<=R) R=max(R,edge[i].r);
			else 
			{
				ans+=query(1,1,n,L,R);
				L=edge[i].l;
				R=edge[i].r;
			}
		}
	}
	cout<<(ans+query(1,1,n,L,R))%mod<<'\n';
}

signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1,u,v;i<n;i++)
	{
		cin>>u>>v;
		add(u,v);
	}
	dfs1(1,1);
	dfs2(1,1);
	cin>>q;
	for(int i=1,op;i<=q;i++)
	{
		cin>>op;
		if(op==0)
		{
			int x,y;
			cin>>x>>y;
			modify_tree(x,y);
		}
		if(op==1)
		{
			int k;
			cin>>k;
			edge.clear();
			for(int j=1,a,b;j<=k;j++)
			{
				cin>>a>>b;
				query_chain(a,b);
			}
			init();
		}
	}
	return 0;
}
```

---

## 作者：coding_goat (赞：0)

题目大意：你需要支持维护一棵有点权的树，子树加，求 $k$ 条链的并（$1\le k\le 5$）。

我们回忆树剖的查询过程，是将一条路径转换为若干条 `dfn` 连续的链进行加减。而这道题需要我们求链的并，注意到 $k$ 的范围极小，我们只需要先把这 $k$ 条原本的链拆成若干条相连的 `dfn` 的短链即可，然后考虑合并有交集的短链。

我们先将所有短链按左端点排序，随后记录 $L,R$ 为当前最长的合并后的短链的 `dfn` 的起点和终点，遍历每一个短链，其左端点为 $l,r$。

- 如果有 $l\le R$，则区间相交，将 $R$ 更新为 $\max(R,r)$。

- 否则这一段短链与当前维护的 $[L,R]$ 并不相交，计算 $[L,R]$ 的权值和，分别更新 $L,R$ 为 $l,r$ 继续计算即可。

由于一段链最多会出现 $\log n$ 段区间，那么有 $k$ 段链就会有 $O(k\log n)$ 段区间。线段树更新和查询的时间复杂度为 $O(\log n)$，那么时间复杂度为 $O(qk \log^2 n)$。

::::success[代码见下]

```cpp
#include<bits/stdc++.h>

#define int ll
#define pii pair<int,int> 
#define pll pair<long long,long long> 
#define ll long long
#define i128 __int128

#define mem(a,b) memset((a),(b),sizeof(a))
#define m0(a) memset((a),0,sizeof(a))
#define m1(a) memset(a,-1,sizeof(a))
#define lb(x) ((x)&-(x))
#define lc(x) ((x)<<1)
#define rc(x) (((x)<<1)|1)
#define pb(G,x) (G).push_back((x))
#define For(a,b,c) for(int a=(b);a<=(c);a++)
#define Rep(a,b,c) for(int a=(b);a>=(c);a--)
#define in1(a) a=read()
#define in2(a,b) a=read(), b=read()
#define in3(a,b,c) a=read(), b=read(), c=read()
#define in4(a,b,c,d) a=read(), b=read(), c=read(), d=read()
#define fst first 
#define scd second 
#define dbg puts("IAKIOI")

using namespace std;

int read() {
	int x=0,f=1; char c=getchar();
	for(;c<'0'||c>'9';c=getchar()) f=(c=='-'?-1:1); 
	for(;c<='9'&&c>='0';c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	return x*f;
}
void write(int x) { if(x>=10) write(x/10); putchar('0'+x%10); }

const int mod = 1ll<<31;
int qpo(int a,int b) {int res=1; for(;b;b>>=1,a=(a*a)%mod) if(b&1) res=res*a%mod; return res; }
int inv(int a) {return qpo(a,mod-2); }

#define maxn 200050

int n;
vector<int> G[maxn];

struct pt {
	int dep,fa,siz,mxs,top,dfn;
}tr[maxn]; int dfncnt;

void dfs1(int u,int fa) {
	tr[u].dep=tr[fa].dep+1,tr[u].siz=1,tr[u].fa=fa;
	for(auto v:G[u]) if(v!=fa) {
		dfs1(v,u);
		tr[u].siz+=tr[v].siz;
		if(tr[v].siz>tr[tr[u].mxs].siz) tr[u].mxs=v;
	}
}

void dfs2(int u,int top) {
	tr[u].dfn=++dfncnt; tr[u].top=top;
	if(tr[u].mxs) dfs2(tr[u].mxs,top);
	for(auto v:G[u]) if(v!=tr[u].fa&&v!=tr[u].mxs) dfs2(v,v);
}

struct SegT {
	int tr[maxn<<2],tag[maxn<<2];
	void psu(int idx) {
		tr[idx]=(tr[lc(idx)]+tr[rc(idx)])%mod;
	}
	void psd(int idx,int l,int r) {
		if(tag[idx]==0) return ;
		int mid=l+r>>1;
		(tr[lc(idx)]+=tag[idx]*(mid-l+1)%mod)%=mod;
		(tag[lc(idx)]+=tag[idx])%=mod;
		(tr[rc(idx)]+=tag[idx]*(r-mid)%mod)%=mod;
		(tag[rc(idx)]+=tag[idx])%=mod;
		tag[idx]=0;
	}
	void modi (int idx,int l,int r,int L,int R,int val) {
		if(L<=l&&r<=R) {
			(tr[idx]+=val*(r-l+1)%mod)%=mod;
			(tag[idx]+=val)%=mod;
			return ;
		}
		psd(idx,l,r);
		int mid=l+r>>1;
		if(L<=mid) modi(lc(idx),l,mid,L,R,val);
		if(R>mid) modi(rc(idx),mid+1,r,L,R,val);
		psu(idx);
	}
	int query(int idx,int l,int r,int L,int R) {
		if(L<=l&&r<=R) return tr[idx];
		psd(idx,l,r);
		int mid=l+r>>1,res=0;
		if(L<=mid) (res+=query(lc(idx),l,mid,L,R))%=mod;
		if(R>mid) (res+=query(rc(idx),mid+1,r,L,R))%=mod;
		return res;
	}
}Tr;

pii qur[6]; 

bool cmp(pii a,pii b) {
	return a.first==b.first?a.second<b.second:a.first<b.first;
}

int query(int k) {
	int res=0;
	vector<pii> a;
	For(i,1,k) {
		auto [x,y]=qur[i];
		while(tr[x].top!=tr[y].top) {
			if(tr[tr[x].top].dep<tr[tr[y].top].dep) swap(x,y);
			a.push_back({tr[tr[x].top].dfn,tr[x].dfn});
			x=tr[tr[x].top].fa;
		}
		if(tr[x].dep>tr[y].dep) swap(x,y);
		a.push_back({tr[x].dfn,tr[y].dfn});
	}
	sort(a.begin(),a.end(),cmp);
	int L=a[0].first,R=a[0].second;
	For(i,1,((int)a.size())-1) {
		auto [l,r]=a[i];
		if(l<=R) R=max(R,r);
		else (res+=Tr.query(1,1,n,L,R))%=mod,L=l,R=r;
	}
	(res+=Tr.query(1,1,n,L,R))%=mod;
	return res%mod;
}

void work() {
	in1(n);
	For(i,2,n) {
		int u,v; in2(u,v);
		G[u].push_back(v),G[v].push_back(u);
	}
	dfs1(1,1),dfs2(1,1);
	int q=read();
	while(q--) {
		int opt,x;
		in2(opt,x);
		if(opt==0) {
			int y=read();
			Tr.modi(1,1,n,tr[x].dfn,tr[x].dfn+tr[x].siz-1,y);
		} else { 
			For(i,1,x) in2(qur[i].first,qur[i].second);
			cout<<query(x)<<'\n';
		}
	}
}

signed main() {
//	freopen("data.in","r",stdin);
//	freopen("myans.out","w",stdout);
//	ios::sync_with_stdio(false); 
//	cin.tie(0); cout.tie(0);
	double stt=clock();
	int _=1;
//	_=read();
//	cin>>_;
	For(i,1,_) {
		work();
	}
	cerr<<"\nTotal Time is:"<<(clock()-stt)*1.0/1000<<" second(s)."<<'\n';
	return 0;
}
```

::::

---

## 作者：冷却心 (赞：0)

唐诗树剖板子题。

操作一即维护区间加法，线段树板子。询问先树剖把路径分成 $O(k\log n)$ 个 dfn 区间，那么就是：维护一个 01 列，支持区间覆盖 $1$，全局查询为 $1$ 的位置的操作一带权和。这个可以在线段树上每个节点维护这个节点是否被覆盖过了，每次区间操作的时候如果当前节点以及被覆盖过了就直接推出，然后就是区间和。每次询问完需要把修改过的结点全部撤销。值得注意的是模数是 $2^{31}$ 所以 `unsigned int` 要把最高位去掉。

时间复杂度 $O(qk\log^2 n)$。

```cpp
#include <bits/stdc++.h>
#define LL long long
#define uint unsigned int
using namespace std;
const int N = 2e5 + 10;
int n, Q; vector<int> G[N];

int depth[N], fa[N], top[N], hson[N], sz[N], dfn[N], dfncnt;
void DFS1(int u, int f) {
	fa[u] = f; depth[u] = depth[f] + 1; sz[u] = 1;
	for (int v : G[u]) if (v != f) {
		DFS1(v, u); sz[u] += sz[v]; if (sz[v] > sz[hson[u]]) hson[u] = v;
	}
}
void DFS2(int u, int f) {
	dfn[u] = ++ dfncnt; if (hson[u]) { top[hson[u]] = top[u]; DFS2(hson[u], u); }
	for (int v : G[u]) if (v != f && v != hson[u]) top[v] = v, DFS2(v, u);
}

#define ls(x) (x << 1)
#define rs(x) (x << 1 | 1)
uint trs[N << 2], tag[N << 2], trr[N << 2]; bool trc[N << 2]; int stk[N << 2], tp;
void f(int p, int l, int r, uint k) { trs[p] += (uint)(r - l + 1) * k; tag[p] += k; }
void pushdown(int p, int l, int r) {
	int mid = (l + r) >> 1; f(ls(p), l, mid, tag[p]); f(rs(p), mid + 1, r, tag[p]); tag[p] = 0;
}
void update1(int p, int l, int r, int x, int y, uint k) {
	if (x > r || y < l) return ;
	if (x <= l && y >= r) { f(p, l, r, k); return ; }
	int mid = (l + r) >> 1; pushdown(p, l, r);
	update1(ls(p), l, mid, x, y, k); update1(rs(p), mid + 1, r, x, y, k);
	trs[p] = trs[ls(p)] + trs[rs(p)]; return ;
}
void update2(int p, int l, int r, int x, int y) {
	if (x > r || y < l || trc[p]) return ;
	stk[++ tp] = p;
	if (x <= l && y >= r) { trc[p] = 1; trr[p] = trs[p]; return ; }
	int mid = (l + r) >> 1; pushdown(p, l, r);
	update2(ls(p), l, mid, x, y); update2(rs(p), mid + 1, r, x, y);
	trr[p] = trr[ls(p)] + trr[rs(p)]; return ;
}
void modify(int u, int v) {
	while (top[u] != top[v]) {
		if (depth[top[u]] < depth[top[v]]) swap(u, v);
		update2(1, 1, n, dfn[top[u]], dfn[u]); u = fa[top[u]];
	} if (depth[u] < depth[v]) swap(u, v);
	update2(1, 1, n, dfn[v], dfn[u]); return ;
}

int main() {
	freopen(".in", "r", stdin); freopen(".out", "w", stdout);
	ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin >> n;
	for (int i = 1, u, v; i < n; i ++) {
		cin >> u >> v; G[u].push_back(v); G[v].push_back(u);
	} top[1] = 1; DFS1(1, 0); DFS2(1, 0);
	int opt, u, v, k; cin >> Q;
	while (Q --) {
		cin >> opt;
		if (!opt) { cin >> u >> v; update1(1, 1, n, dfn[u], dfn[u] + sz[u] - 1, v); }
		else {
			cin >> k;
			while (k --) { cin >> u >> v; modify(u, v); }
			cout << (trr[1] << 1 >> 1) << "\n";
			while (tp) { trr[stk[tp]] = 0; trc[stk[tp]] = false; tp --; }
		}
	}
	return 0;
}
```

---


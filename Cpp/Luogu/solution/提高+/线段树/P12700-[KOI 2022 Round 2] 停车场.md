# [KOI 2022 Round 2] 停车场

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

有一个圆形的停车塔。停车塔上有 $N$ 个格子，按顺时针方向依次编号为第 1 个格、第 2 个格、……、第 $N$ 个格。每个格子中都停有一辆车，第 $i$ 个格子中的车辆编号为 $a_i$。

![](https://cdn.luogu.com.cn/upload/image_hosting/cvus8hb5.png)

停车塔上有两个按钮：按下按钮 A 会使整个停车塔顺时针旋转一格，按下按钮 B 会使停车塔逆时针旋转一格。下图左边展示了按下按钮 A 后的状态，右边展示了按下按钮 B 后的状态。

![](https://cdn.luogu.com.cn/upload/image_hosting/vneppep8.png)

此时，目标是将所有车辆从停车塔中依次取出。

车辆只能从最底部的一个格子被取出。初始时，第 1 个格子位于最底部。要取出不在最底部的车辆，必须先按按钮将其旋转至最底部的位置。

此外，编号为 $x$ 的车辆只能在编号小于 $x$ 的所有车辆都已被取出的情况下才能被取出。换句话说，如果停车塔中还剩下编号小于 $x$ 的车辆，那么编号为 $x$ 的车辆就不能被取出。

请你编写一个程序，计算将所有车辆从停车塔中取出所需按按钮的最少总次数。

## 说明/提示

**约束条件**

- $1 \leq N \leq 100\,000$
- $1 \leq a_i \leq 1\,000\,000\,000$

**子任务**

1. （8 分）对于所有的 $i$，$a_i = 1$。即，所有车辆编号都为 1。
2. （9 分）对于所有的 $i \ne j$，有 $a_i \ne a_j$。即，所有车辆编号各不相同。
3. （10 分）$N \leq 10$
4. （21 分）$N \leq 100$
5. （31 分）$N \leq 1\,000$
6. （21 分）无额外约束条件

## 样例 #1

### 输入

```
4
1 2 2 1```

### 输出

```
3```

## 样例 #2

### 输入

```
5
3 1 4 5 1```

### 输出

```
7```

# 题解

## 作者：2huk (赞：2)

把所有点按颜色分层。那么必须先把上一层的车取完，才能取下一层的。于是考虑按照颜色层数 DP。

设 $f(i)$ 表示，将所有层数 $\le a_i$ 的车去除，且当前出口是点 $i$ 的最小操作次数。

此时有一个很暴力的转移：预处理 $g(i,j)$（其中 $a_i=a_j$），表示从 $i$ 开始，遍历完 $a_i$ 层的所有点后，最终到达 $j$，最小操作次数。然后 $f(lst) + w(lst,i)+g(i,j) \to f(j)$，其中 $a_i=a_j=a_{lst}+1$。其中 $w(i,j)$ 表示在环上从 $i$ 走到 $j$ 的最小步数，即 $w(i,j)=\min(|i-j|,n-|i-j|)$。

这样需要枚举 $lst,i,j$，复杂度肯定是不对的。但是我们先考虑 $g(i,j)$ 的求解。走法一定是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/u0gpb5j2.png)

即先从 $i$ 走到某个点 $x$，然后从 $x$ 转一圈（到 $pre_x$ 或 $nxt_x$，即这一层中的上一个位置和下一个位置），最后到 $j$。

其实从上一层的 $lst$ 走到 $i$ 再走到 $x$ 这个过程是冗余的。直接令 $h(x)$ 表示，走完所有 $<a_x$ 的点后，到达 $x$ 的最小步数。

显然有：
$$
h(x)+n-clockwise(x,nxt_x) \to f(nxt_x) \\
h(x)+n-clockwise(pre_x,x) \to f(pre_x)
$$
其中 $clockwise(i,j)$ 表示从 $i$ 顺时针走到 $j$ 的步数。

考虑 $h(x)$ 的求解。枚举上一层的最后一个点：
$$
h(x) = \min_{a_y = a_x-1}\left\{ f(y)+w(x,y) \right\}
$$
即 $f(y)+|x-y|$ 和 $f(y)+n-|x-y|$ 的较小值。

不妨钦定 $x\ge y$。那么转移为 $f(y)+x-y$ 和 $f(y)+n-x+y$ 的较小值。把与 $y$ 无关的项提出后是一个前缀和状物。

当然 $x<y$ 同理。

那么 $f,h$ 的转移都是 $\mathcal O(1)$ 的。除离散化的时间复杂度为 $\mathcal O(n)$。

---

## 作者：yuyang0974 (赞：2)

本蒟蒻一直不会写这类**环上+分类讨论+dp**的题目，结果这道题还被放在了当天集训模拟赛里，当时想了一个超绝复杂线段树加超绝复杂分类讨论做法，结果写挂了，感觉六六六我不行了吧！之后发现教练新奇的思路，觉得六六六我不行了吧！故有感作此题解。

好的，我们的部分分攻坚战开始了！（以下 Task 内容表示测试点编号，xxx pts 表示当前及以前的部分分总和）

写在前面：

1. 注意本题数据，距离最大值超出了 32 位整形的存储范围，**十年 OI 一场空，不开什么见祖宗？**

2. 对于整个停车塔的移动，我们可以看成是**出口**在环上移动，以此方便处理问题，以下不多解释。(或者看成是有个人从 1 号点出发，以此收取递增权值的物品，下面我把权值类比成**颜色**，以便讲述)

3. 数据范围有点大，先离散化一下没问题的吧？此点以下不多解释。

### Task 1：8 pts

所有车辆都为一个颜色，那我沿一个方向走一圈不就完事了？

时间复杂度：$O(n)$

### Task 2：17 pts

车辆编号都不相同，而且题目要求物品的颜色递增取出，那该部分分就是从小数字向大数字递增的走即可。

具体的做法，就是先 $O(n)$ 扫一遍，记录下每种颜色的出现位置，然后再从小到大枚举颜色，答案就是：

$$
\displaystyle ans = \sum \limits_{i = 2}^{n} g_{i - 1, i}
$$

上式中 $g_{i, j}$ 代表两点间距离。

时间复杂度：$O(n)$

### Task 3：27 pts

哇塞，$n \le 10$，直接想到**全排列**！

我们直接枚举每一种访问顺序的排列 $p_i$，然后按排列顺序模拟一下，看下颜色是不是单调不降即可。

时间复杂度：$O(n \times n!)$

### Task 4、5：79 pts

（呃呃呃因为本蒟蒻没想到贴切 Task 4 数据范围时间复杂度的方法，就不妨和 Task 5 放一起，讲解 $O(n^2)$ 复杂度的方法）

我们想到，对于路径的选择，我们总得先走完小的颜色，再去走大的颜色。

那么不如就此设置状态，$dp_i$ 表示：到了位置 $i$ 并且取完了所有 $a_j < a_i$ 的最短路径。

假设有 $tot$ 种颜色，我们不妨设所有 $a_i = tot$ 的 $i$ 的集合为 $S$，最终答案就是：

$$
\displaystyle \sum \limits_{i \in S} dp_i
$$

考虑 $dp_i$ 的转移。嘶，好像不太好维护的样子。假如有 $a_j + 1 = a_i$，如果要从 $dp_j$ 转移到 $dp_i$ 的话，我们必须在 $O(\log(n))$ 限制内找到最短路径（不知道这个可不可做，反正我并没有想到好的方法）。

难道没办法了吗？教练的点睛之笔就是，设计一个状态 $f_i$ 表示：到了位置 $i$ 并且取完了所有 $a_j \le a_i$ 的最短路径。

诶，你还真别说，这两个状态还是有点区别的，一个是小于，一个是小于等于。但是这样设计有啥用呢？

考虑 $dp_i$ 的转移，我们是不是可以从上一层的 $f_i$ 转移过来？因为上一层的 $f_j$ 已经保证取完了 $a_j$，所有我们不用过多讨论，直接转移即可。

那么，如何转移呢？

考虑 $dp_i$ 的转移，很容易地，我们可以想到：

$$
dp_i = \min\limits_{a_j + 1 = a_i}(f_j + dist_{i, j})
$$

其中 $dist_{i, j}$ 表示 $i$ 到 $j$ 的环上最短距离，也就是 $\min(updist_{i, j}, downdist_{i, j})$

欧克，我们现在可以 $O(n^2)$ 转移 $dp_i$ 了。

好的，考虑完 $dp_i$ 的转移，但是如何推给 $f_j$ 呢？这是一个问题。

考虑 $f_i$ 的转移，我们可以列出表达式：

$$
f_i = \min(dp_{nex_i} + updist_{nex_i, i}, \; dp_{las_i} + downdist_{las_i, i})
$$

以上式子中，$nex_i$ 表示 $i$ 沿下标递增方向第一个 $a_j = a_i$ 的 $j$，$las_i$ 的定义类同。$updist_{i, j}$ 表示沿下表递增方向 $i$ 走到 $j$ 的距离，$downdist_{i, j}$ 的定义类同。

怎么解释这个式子呢？

我们可以理解成每种颜色组成一层，总共有 $tot$ 层。那么在该层上转移，我们可以证明，最段距离一定是由上一层的某个点（该点不一定等于上一层的颜色）转移来后，先走到该层的某个中转点，然后沿任意方向一直走到该层的某个位置取完该层的所有颜色。

为啥这种方案一定最优呢？我们考虑一种不符合该方法的走点方式，如图所示（蓝色路径）：

![图示1](https://cdn.luogu.com.cn/upload/image_hosting/knyotxfo.png)

显然，这种路径可以被另一种路径完美替代，而且所花的距离比其短，如图所示（棕色路径）：

![图示2](https://cdn.luogu.com.cn/upload/image_hosting/uaot8f0l.png)

可以理解为截弯取直，证明结束。

所以，既然有了 $dp_i$ 这个状态，我们就可以直接转移过来，枚举 $i$ 就代表那个 “中转点”， 而从 $nex_i$ 沿下标递增方向走到 $i$ 也就是转一圈取点的过程。$las_i$ 同理。

这里 $f_i$ 的转移同样是 $O(n^2)$ 的，所以总时间复杂度：$O(n^2)$。

### Task 6：100 pts

考虑我们刚新鲜出炉的 79 分做法的瓶颈，在于 $dp_i$ 与 $f_i$ 的转移。

我们仔细想想，$f_i$ 的转移真的需要 $O(n^2)$ 吗？

回顾算法流程，我们的 $f_i$ 只会在本层的 $dp_j$ 更新时使用到，所以我们不妨对于每一层（颜色记为 $now$）只更新所有点中 $a_i = now$ 的点。这样的话，因为每层的访问只会更新当前层的节点，而又有 $\sum \limits_{i=1}^{tot}siz_i = n$，所以 $f_i$ 的转移总时间复杂度是 $O(n)$ 的。

解决完了 $f_i$ 的转移，我们来考虑考虑 $dp_i$ 的转移如何优化。

考虑到含有距离的公式不好优化，我们不妨把距离拆成多种情况分类讨论，那么就有：

$$
\begin{aligned}
dp_i
&=
\min\limits_{a_j + 1 = a_i}(f_j + dist_{i, j}) \\
&=
\min\limits_{a_j + 1 = a_i}(f_j + \min(updist_{i, j}, downdist_{i, j})) \\
&=
\min \left( \min\limits_{a_j + 1 = a_i \wedge j < i}(f_j + \min(j - i + n, i - j)), \; \min\limits_{a_j + 1 = a_i \wedge i < j}(f_j + \min(j - i, i - j + n)) \right) \\
&=
\min
\left( 
\left(\min\limits_{a_j + 1 = a_i \wedge j < i} f_j + j \right) - i + n,
\left(\min\limits_{a_j + 1 = a_i \wedge j < i} f_j - j \right) + i,
\left(\min\limits_{a_j + 1 = a_i \wedge i < j} f_j + j \right) - i,
\left(\min\limits_{a_j + 1 = a_i \wedge i < j} f_j - j \right) + i + n
\right) \\
\end{aligned}
$$

都推到这里了，不难发现，我们只需要维护**序列上**的 $f_j + j$ 以及 $f_j - j$ 的**前缀最小值**和**后缀最小值**即可，可以把环抛掉了！

但好像还是有点问题。我每一个颜色都 $O(n)$ 扫一遍来统计最小值数组的话，依旧会时间超限，那么有没有什么好一点的方法呢？

类比 $f_i$ 的优化方式，我们发现，$dp_i$ 只会用到上一层的 $f_j$，所以我们统计最小值时只需要把上一层的几个 $f_j$ 拉出来单独做前缀最小值和后缀最小值即可。这其实用两边双指针扫过去实现更加方便。

优化成功，时间复杂度：$O(n)$

## AC 代码（含部分分）

```cpp
#include<bits/stdc++.h>
using namespace std;

template<typename T> void read(T &x) {
    x = 0;
    char c = getchar(), f = 'a';
    while(c < '0' || c > '9') {
        if(c == '-') f = 'b';
        c = getchar();
    }
    while(c >= '0' && c <= '9') {
        x = (x << 1) + (x << 3) + (c ^ '0');
        c = getchar();
    }
    if(f ^ 'a') x = -x;
}
template<typename T, typename ...T1> void read(T &x, T1 &...x1) {read(x); read(x1...);}

int n;
const int maxn = 1e5 + 5;
int a[maxn], lsan[maxn], tot;

namespace diff {
    int pos[maxn];
    void Solve_tot() {
        long long ans = 0;
        pos[0] = 1;
        for(int i = 1; i <= n; i ++) pos[a[i]] = i;
        for(int i = 1; i <= n; i ++) {
            ans += min((pos[i] - pos[i - 1] + n) % n, (pos[i - 1] - pos[i] + n) % n);
        }
        printf("%lld\n", ans);
    }
}

namespace all_permutation {
    int p[maxn];
    void Solve() {
        for(int i = 1; i <= n; i ++) p[i] = i;
        int las = 0;
        long long pre = 0;
        bool error;
        p[0] = 1;
        long long ans = 0x3f3f3f3f3f3f3f3f;
        do {
            error = false;
            pre = 0;
            las = 0;
            for(int i = 1; i <= n; i ++) {
                if(a[p[i]] < las || a[p[i]] > las + 1) {
                    error = true;
                    break;
                }
                las = a[p[i]];
                pre += min((p[i] - p[i - 1] + n) % n, (p[i - 1] - p[i] + n) % n);
            }
            if(!error) ans = min(ans, pre);
        } while(next_permutation(p + 1, p + n + 1));
        printf("%lld\n", ans);
    }
}

typedef long long ll;
#define inf 0x3f3f3f3f3f3f3f3f

namespace zheng_jie {
    int nex[maxn]; // -> nex_i 为 i 的下一个等于 a_i 的位置
    int las[maxn]; // -> las_i 为 i 的上一个等于 a_i 的位置
    int fir[maxn]; // -> 拆环成链后，颜色 i 的第一次出现的位置
    int pos[maxn]; // -> 辅助数组，当前颜色 i 的位置
    ll f[maxn]; // -> 设 f_i 表示已经取完了 <= a_i 的数，并且当前在位置 i 的最短距离
    ll dp[maxn]; // -> 设 dp_i 表示已经取完了 < a_i 的数，并且当前在位置 i 的最短距离
    vector<int> team[maxn]; // -> the member of each color
    int updist(int i, int j) {
        return (j - i + n) % n;
    }
    int downdist(int i, int j) {
        return (i - j + n) % n;
    }
    int dist(int i, int j) {
        return min(updist(i, j), downdist(i, j));
    }
    void init() {
        for(int i = 1; i <= n; i ++) {
            nex[i] = 0;
            las[i] = 0;
            fir[i] = 0;
            pos[i] = 0;
            team[i].clear();
        }
        for(int i = 1; i <= n; i ++) {
            // clear the dp
            f[i] = inf;
            dp[i] = dist(1, i);
            // prepare the las ans nex
            if(!fir[a[i]]) {
                fir[a[i]] = i;
            }
            las[i] = pos[a[i]];
            pos[a[i]] = i;
            // insert member
            team[a[i]].push_back(i);
        }
        for(int col = 1; col <= tot; col ++) {
            las[fir[col]] = pos[col];
        }
        for(int i = 1; i <= n; i ++) {
            nex[las[i]] = i;
        }
    }
    // f_i  = min( dp_{nex_i} + clockwise(nex_i, i) , dp_{las_i} + counterclockwise(las_i, i) ）
    // dp_i = min( fp_{i - 1} + i, gp_{i - 1} - i + n )
    // dp_i = min( hp_{i + 1} + i + n, ip_{i + 1} - i )
    void Solve() {
        init();
        ll fp, gp, hp, ip;
        // -> fp = min_{j <= i} f_j - j
        // -> gp = min_{j <= i} f_j + j
        // -> hp = min_{j >= i} f_j - j
        // -> ip = min_{j >= i} f_j + j
        for(int it = 1, len, nex_len; it <= tot; it ++) {
            for(int u : team[it]) {
                f[u] = min(dp[nex[u]] + updist(nex[u], u), dp[las[u]] + downdist(las[u], u));
            }

            if(it ^ tot) {
                for(int u : team[it + 1]) dp[u] = inf;

                len = team[it].size();
                nex_len = team[it + 1].size();
                fp = gp = hp = ip = inf;

                for(int i = 0, pos = 0, u; i < nex_len; i ++) {
                    u = team[it + 1][i];
                    while(pos < len && team[it][pos] <= u) {
                        fp = min(fp, f[team[it][pos]] - team[it][pos]);
                        gp = min(gp, f[team[it][pos]] + team[it][pos]);
                        pos ++;
                    }
                    dp[u] = min(dp[u], fp + u);
                    dp[u] = min(dp[u], gp - u + n);
                }

                for(int i = nex_len - 1, pos = len - 1, u; i >= 0; i --) {
                    u = team[it + 1][i];
                    while(pos >= 0 && team[it][pos] >= u) {
                        hp = min(hp, f[team[it][pos]] - team[it][pos]);
                        ip = min(ip, f[team[it][pos]] + team[it][pos]);
                        pos --;
                    }
                    dp[u] = min(dp[u], hp + u + n);
                    dp[u] = min(dp[u], ip - u);
                }
            }
        }
        ll ans = inf;
        for(int i = 1; i <= n; i ++) {
            if(a[i] ^ tot) continue; // 只有是 tot 颜色的对答案有贡献
            ans = min(ans, f[i]);
        }
        printf("%lld\n", ans);
    }
}

int main() {
    //freopen("tower.in", "r", stdin);
    //freopen("tower.out", "w", stdout);
    read(n);
    for(int i = 1; i <= n; i ++) {
        read(a[i]);
        lsan[i] = a[i];
    }
    sort(lsan + 1, lsan + n + 1);
    tot = (int)(unique(lsan + 1, lsan + n + 1) - lsan - 1);
    for(int i = 1; i <= n; i ++) a[i] = (int)(lower_bound(lsan + 1, lsan + tot + 1, a[i]) - lsan);
    if(tot == 1) {
        printf("%d\n", n - 1);
        return 0;
    }
    else if(tot == n) {
        diff::Solve_tot();
    }
    else if(n <= 10) {
        all_permutation::Solve();
    }
    else {
        zheng_jie::Solve();
    }
    return 0;
}
```

---


# [蓝桥杯 2025 国 A] 翻转硬币

## 题目描述

给定 $n$ 个硬币的初始状态，以及 $m$ 次如下类型的操作：

1. $1 \ x \ y$: 将 $[x, y]$ 之间的硬币每隔一个翻转一个，即翻转 $x, x+2, x+4, \cdots, x+2t \ (x+2t \leq y)$；
2. $2 \ x \ y$: 将 $[x, y]$ 之间的硬币每隔两个翻转一个，即翻转 $x, x+3, x+6, \cdots, x+3t \ (x+3t \leq y)$；
3. $3 \ x \ y$: 将 $[x, y]$ 之间的硬币全部翻转；
4. $4 \ x \ y$: 查询 $[x, y]$ 之间正面朝上的硬币个数。

## 说明/提示

**【评测用例规模与约定】**

对于 20% 的评测用例，$1 \leq n, m \leq 5000$；

对于另外 20% 的评测用例，$1 \leq n, m \leq 10^5$，且没有 $1 \ x \ y$ 类型的操作；

对于另外 20% 的评测用例，$1 \leq n, m \leq 10^5$，且没有 $2 \ x \ y$ 类型的操作；

对于所有评测用例，$1 \leq n \leq 5 \times 10^5$，$1 \leq m \leq 10^5$，$f_i \in \{0, 1\}$，$a_i \in \{1, 2, 3, 4\}$，$1 \leq x_i \leq y_i \leq n$。

## 样例 #1

### 输入

```
5 8
1 0 0 1 0
1 2 3
4 1 5
2 3 5
4 2 5
3 1 5
4 2 3
3 1 4
4 1 5```

### 输出

```
3
3
0
5```

# 题解

## 作者：SudoXue (赞：2)

[更好的阅读体验](https://www.cnblogs.com/xueruhao/p/18934325)

题目的三类局部翻转与一类整体翻转，其本质都可以抽象为“在一次区间操作里，把若干固定同余类的硬币状态取反”。

将下标对 $6$ 取模后可得到 $0,1,2,3,4,5$ 六个同余类：

- 当步长为 $2$ 时，只会落在奇数类 $\{1,3,5\}$ 或偶数类 $\{0,2,4\}$；
- 当步长为 $3$ 时，只会落在下标同余 $x\bmod 3$ 的两类；
- 而整段翻转则覆盖全部六类。

于是：

- 操作 $1$ 等价于把奇类或偶类整体取反；
- 操作 $2$ 等价于把与 $x\bmod 3$ 相同的两类整体取反；
- 操作 $3$ 等价于把六个类全部取反；

查询操作仅需统计六类的正面计数之和。

基于此，在一棵线段树的每个结点维护长度为 $6$ 的数组，记录对应区间六个同余类的正面硬币数量，并用一个 $6$ 位二进制掩码做懒标记，表示“本区间哪些类尚待取反”。

当需要把某类取反时，只需将计数 $c$ 更新为区间内该类长度 $l$ 减去 $c$，并把掩码按位异或相应常量；下推和合并时每次都只是对这六个整数做常数级别的运算，因此一次区间更新或查询仍是 $O(\log n)$ 量级。

掩码常量可以预先写死：奇类为二进制 $011010_2$，偶类为 $101001_2$，三种 $\bmod 3$ 类分别是 $000100_2$、$001010_2$、$010001_2$，全翻则是 $111111_2$。

时间复杂度 $O\bigl(n + m\log n\bigr)$。

[link](https://www.luogu.com.cn/record/220784216)

---

## 作者：CChord (赞：2)

## 题意
对一个 $01$ 序列，支持步长为 $1,2,3$ 的翻转，区间和查询。

## 思路
线段树分别维护模数为 $6$ 时，下标同余于 $0,1,2,3,4,5$ 的 $01$ 个数和 $1$ 的总数。

* 翻转操作：根据起始点 $x$ 的位置和翻转的步长，决定该区间元素下标同余于多少时需要翻转。

  例：起始下标为 $8$，翻转步长为 $3$，那么区间内需要翻转的元素下标同余于 $2,5$，以此类推。

* 查询操作：查询区间和。

（接着就可以看下面美丽的代码实现啦）

## 代码实现
```
#include<bits/stdc++.h>
using namespace std;

template<class Info, class Tag>
struct LazySegmentTree{
	int n; 
	vector<Info> info;
	vector<Tag> tag;

	template<class T>
	LazySegmentTree(vector<T> v){
		n = v.size();
		info.resize(4 << __lg(n));
		tag.resize(4 << __lg(n));
		function<void(int, int, int)> build = [&](int p, int l, int r){
			if(l + 1 == r){
				info[p] = Info(l, v[l]);
				return;
			}
			int m = l + r >> 1;
			build(p << 1, l, m);
			build(p << 1 | 1, m, r);
			pull(p);
		};
		build(1, 0, n);
	}

	void pull(int p){
		info[p] = info[p << 1] + info[p << 1 | 1];
	}

	void apply(int p, const Tag &t){
		info[p].apply(t);
		tag[p].apply(t);
	}

	void push(int p){
		apply(p << 1, tag[p]);
		apply(p << 1 | 1, tag[p]);
		tag[p] = Tag();
	}

	void modify(int l, int r, const Tag &t){
		return modify(1, 0, n, l, r, t);
	}
	void modify(int p, int l, int r, int x, int y, const Tag &t){
		if(r <= x || y <= l){
			return;
		}
		if(x <= l && r <= y){
			apply(p, t);
			return;
		}
		int m = l + r >> 1;
		push(p);
		modify(p << 1, l, m, x, y, t);
		modify(p << 1 | 1, m, r, x, y, t);
		pull(p);
	}

	Info query(int l, int r){
		return query(1, 0, n, l, r);
	}
	Info query(int p, int l, int r, int x, int y){
		if(r <= x || y <= l){
			return Info();
		}
		if(l >= x && r <= y){
			return info[p];
		}
		int m = l + r >> 1;
		push(p);
		return query(p << 1, l, m, x, y) + query(p << 1 | 1, m, r, x, y);
	}
};

struct Tag {
    array<int, 6> cg;
    void apply(const Tag &t){
        for(int i = 0; i < 6; i++){
        	cg[i] ^= t.cg[i];
        }
    }
};

struct Info {
	int sum;
    array<int, 6> pos, neg;
    Info() : sum(0), pos({0}), neg({0}) {}
    Info(int i, int x){
    	pos.fill(0);
    	neg.fill(0);
    	if(x) pos[i % 6] = 1;
    	else neg[i % 6] = 1;
    	sum = x;
    }
    void apply(const Tag &t){
        for(int i = 0; i < 6; i++){
        	if(t.cg[i]){
        		sum = sum - pos[i] + neg[i];
        		swap(pos[i], neg[i]);
        	}
        }
    }
};

Info operator+(const Info &a, const Info &b) {
    Info c;
    c.sum = a.sum + b.sum;
    for(int i = 0; i < 6; i++){
    	c.pos[i] = a.pos[i] + b.pos[i];
    	c.neg[i] = a.neg[i] + b.neg[i];
    }
    return c;
}

void solve(){
	int n, m; cin >> n >> m;
	vector<int> a(n);
	for(int i = 0; i < n; i++) cin >> a[i];
	
	LazySegmentTree<Info, Tag> seg(a);

	while(m--){
		int op; cin >> op;
		int x, y; cin >> x >> y;
		x--, y--;
		if(op == 1){
			if(x % 2 == 0){
				seg.modify(x, y + 1, {1, 0, 1, 0, 1, 0});
			}
			else{
				seg.modify(x, y + 1, {0, 1, 0, 1, 0, 1});
			}
		}
		else if(op == 2){
			if(x % 3 == 0){
				seg.modify(x, y + 1, {1, 0, 0, 1, 0, 0});
			}
			else if(x % 3 == 1){
				seg.modify(x, y + 1, {0, 1, 0, 0, 1, 0});
			}
			else{
				seg.modify(x, y + 1, {0, 0, 1, 0, 0, 1});
			}
		}
		else if(op == 3){
			seg.modify(x, y + 1, {1, 1, 1, 1, 1, 1});
		}
		else{
			cout << seg.query(x, y + 1).sum << '\n';
		}
	}
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	solve();
	return 0;
}
```

---

## 作者：redfull66 (赞：1)

如果只维护操作 $3$ 和操作 $4$ 就可以用线段树维护（也就是 [P3870](https://www.luogu.com.cn/problem/P3870) 题）。注意到操作 $1$ 和操作 $2$ 与操作 $3$ 类似，可以用 $6$ 个线段树维护，操作 $1$，操作 $2$ 和操作 $3$ 分别维护 $3$，$2$，$6$ 个线段树。统计时计算 $6$ 个线段树的值的总和即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,op,l,r,s,a[500005];
struct Tr{long long s,l,r,m,t;}tr[500005][8];
void build(long long id,long long l,long long r,long long op){
	tr[id][op].l=l,tr[id][op].r=r,tr[id][op].m=(l+r)/2;
	if(l==r)tr[id][op].s=a[l*6-6+op];
	else build(id*2,l,tr[id][op].m,op),build(id*2+1,tr[id][op].m+1,r,op),tr[id][op].s=tr[id*2][op].s+tr[id*2+1][op].s;
}
void pushdown(long long id,long long op){
	if(tr[id][op].t){
		tr[id*2][op].t^=1,tr[id*2+1][op].t^=1,tr[id*2][op].s=tr[id][op].m-tr[id][op].l+1-tr[id*2][op].s;
		tr[id*2+1][op].s=tr[id][op].r-tr[id][op].m-tr[id*2+1][op].s,tr[id][op].t=0;
	}
}
void pushup(long long id,long long l,long long r,long long op){
	if(l<=tr[id][op].l&&tr[id][op].r<=r)tr[id][op].t^=1,tr[id][op].s=tr[id][op].r-tr[id][op].l+1-tr[id][op].s;
	else{
		pushdown(id,op);
		if(l<=tr[id][op].m)pushup(id*2,l,r,op);
		if(r>tr[id][op].m)pushup(id*2+1,l,r,op);
		tr[id][op].s=tr[id*2][op].s+tr[id*2+1][op].s;
	}
}
long long ans(long long id,long long l,long long r,long long op,long long s=0){
	if(l<=tr[id][op].l&&tr[id][op].r<=r)return tr[id][op].s;
	pushdown(id,op);
	if(l<=tr[id][op].m)s+=ans(id*2,l,r,op);
	if(r>tr[id][op].m)s+=ans(id*2+1,l,r,op);
	return s;
}
long long read(long long ans=0,long long f=1,char c=0){
    while(c<'0'||c>'9')c=getchar(),f-=2*(c=='-');
    while(c>='0'&&c<='9')ans=ans*10+c-'0',c=getchar();
    return ans*f;
}
void write(long long x){
	if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=min(n,6ll);i++)build(1,1,(n-i+6)/6,i);
	while(m--){
		op=read(),l=read(),r=read(),op=op%3+1+(op==4)*2;
		if(op==4){
			s=0;
			for(int i=1;i<=min(n,6ll);i++)
				if((l-i+11)/6<=(r-i+6)/6)
					s+=ans(1,(l-i+11)/6,(r-i+6)/6,i);
			write(s),putchar('\n');
		}
		else
			for(int i=l%op+(!(l%op))*op;i<=min(n,6ll);i+=op)
			    if((l-i+11)/6<=(r-i+6)/6)
			        pushup(1,(l-i+11)/6,(r-i+6)/6,i);
	}
	return 0;
}

```

---

## 作者：postpone (赞：0)

区间翻转，区间询问，很容易想到懒标记线段树，维护一个区间长度和区间正面的个数就做出来了。

但这里有隔一个翻一个，和隔两个翻一个，要怎么办？

先想，如果只有隔一个翻一个的操作，好像可以转化为对奇偶位置的更新，开两个线段树，一个记录奇数位置，一个记录偶数位置就行了。

进一步地，如果只有隔两个翻一个的操作，同样的思路，我们可以开三个线段树，根据起始位置对 $3$ 取模的结果来决定更新哪棵线段树。

这两个操作合在一起，既开 $2$ 棵又开 $3$ 棵，不太行，于是我们可以开 $\text {lcm}(2, 3) = 6$ 棵线段树。如果隔一个翻一个，那么就是选 $3$ 棵进行更新；如果是隔两个翻一个，选 $2$ 棵进行更新即可。

核心代码如下：
```cpp
struct Tag {
    bool rev = false;
    void apply(const Tag &t) {
        rev ^= t.rev;
    }
};

struct Info {
    i64 ans = 0; // 有多少硬币是正面
    i64 act = 0; // 区间长度

    void apply(const Tag &t) {
        if (t.rev) {
            ans = act - ans; // 翻转就是区间长度减去正面硬币数
        }
    }
};

constexpr Info operator+(const Info &a, const Info &b) {
    Info c;
    c.ans = a.ans + b.ans;
    c.act = a.act + b.act;
    return c;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    cin >> n >> m;

    vector<LazySegmentTree<Info, Tag>> seg(6, n);
    for (int i = 0; i < n; i++) {
        int f;
        cin >> f;

        int x = i % 6;
        seg[x].modify(i, {f, 1});
    }

    for (int i = 0; i < m; i++) {
        int a, x, y;
        cin >> a >> x >> y;
        x--;

        int cur = x % 6;

        if (a == 1) {
            for (int i = 0; i < 3; i++) {
                seg[cur].rangeApply(x, y, {true});
                cur = (cur + 2) % 6;
            }
        } else if (a == 2) {
            for (int i = 0; i < 2; i++) {
                seg[cur].rangeApply(x, y, {true});
                cur = (cur + 3) % 6;
            }
        } else if (a == 3) {
            for (int i = 0; i < 6; i++) {
                seg[i].rangeApply(x, y, {true});
            }
        } else {
            int ans = 0;
            for (int i = 0; i < 6; i++) {
                ans += seg[i].rangeQuery(x, y).ans;
            }
            cout << ans << "\n";
        }

    }

    return 0;
}
```

---


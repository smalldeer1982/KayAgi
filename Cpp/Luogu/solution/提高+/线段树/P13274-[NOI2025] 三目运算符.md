# [NOI2025] 三目运算符

## 题目背景

ternary.cpp / 2 s / 512 MiB

## 题目描述

对于一个长度为 $n$ ($n \geq 3$) 的 01 串 $S = s_1 \ldots s_n$，定义变换 $T = f(S) = t_1 \ldots t_n$ 如下：

$$t_i = \begin{cases} 
s_i, & i \leq 2, \\
s_i, & i \geq 3 \text{ 且 } s_{i-2} = 0, \\
s_{i-1}, & i \geq 3 \text{ 且 } s_{i-2} = 1.
\end{cases}$$

定义变换 $f$ 的 **不动点** 如下：若 01 串 $T$ 满足 $f(T) = T$，则称 $T$ 为变换 $f$ 的不动点。

记 $f^k(S)$ 为 $S$ 经过 $k$ 次变换得到的串。特别地，记 $f^0(S) = S$。求最小的自然数 $k$，使得 $f^k(S)$ 为变换 $f$ 的不动点，即满足 $f^{k+1}(S) = f^k(S)$ 的最小的自然数 $k$。可以证明，一定存在自然数 $k$ 使得 $f^k(S)$ 为变换 $f$ 的不动点。

小 Z 觉得这个问题过于简单，因此他增加了 $q$ 次修改操作。第 $i$ ($1 \leq i \leq q$) 次修改会给定两个正整数 $l_i, r_i$ ($1 \leq l_i \leq r_i \leq n$)，然后将区间 $[l_i, r_i]$ 内的所有原有的 0 替换为 1，所有原有的 1 替换为 0。你需要对初始时及每次修改后的字符串 $S$，求出最小的自然数 $k$，使得 $f^k(S)$ 为变换 $f$ 的不动点。

## 说明/提示

该样例共包含两组测试数据。

对于第一组测试数据：
- 初始时，$S = 11010$，$f(S) = 11100$，$f^2(S) = 11110$，$f^3(S) = f^4(S) = 11111$，因此 $k_0 = 3$；
- 第一次操作后，$S = 11110$，$f(S) = f^2(S) = 11111$，因此 $k_1 = 1$；
- 第二次操作后，$S = 10110$，$f(S) = f^2(S) = 10011$，因此 $k_2 = 1$。

故答案为 $\bigoplus_{i=0}^{q} ((i+1) \times k_i) = (1 \times 3) \oplus (2 \times 1) \oplus (3 \times 1) = 3 \oplus 2 \oplus 3 = 2$。

对于第二组测试数据：
- 初始时，$S = 1010100$，$k_0 = 1$；
- 第一次操作后，$S = 1010101$，$k_1 = 1$；
- 第二次操作后，$S = 1101101$，$k_2 = 5$；
- 第三次操作后，$S = 0001101$，$k_3 = 2$。

故答案为 $\bigoplus_{i=0}^{q} ((i+1) \times k_i) = (1 \times 1) \oplus (2 \times 1) \oplus (3 \times 5) \oplus (4 \times 2) = 4$。

**【样例 2】**

见选手目录下的 ternary/ternary2.in 与 ternary/ternary2.ans。

该样例满足测试点 1 ~ 3 的约束条件。

**【样例 3】**

见选手目录下的 ternary/ternary3.in 与 ternary/ternary3.ans。

该样例满足测试点 4 ~ 6 的约束条件。

**【样例 4】**

见选手目录下的 ternary/ternary4.in 与 ternary/ternary4.ans。

该样例满足测试点 13、14 的约束条件。

**【样例 5】**

见选手目录下的 ternary/ternary5.in 与 ternary/ternary5.ans。

该样例满足测试点 17 ~ 19 的约束条件。

**【数据范围】**

设 $N, Q$ 分别为单个测试点内所有测试数据的 $n, q$ 的和。对于所有测试数据，保证：
- $1 \leq t \leq 5$;
- $3 \leq n \leq 4 \times 10^5$, $N \leq 8 \times 10^5$;
- $1 \leq q \leq 4 \times 10^5$, $Q \leq 8 \times 10^5$;
- 对于所有 $1 \leq i \leq n$, 均有 $s_i \in \{0, 1\}$;
- 对于所有 $1 \leq i \leq q$, 均有 $1 \leq l_i \leq r_i \leq n$。

::cute-table{tuack}

| 测试点编号 | $n, q \leq$ | $N, Q \leq$ | 特殊性质 |
| :-: | :-: | :-: | :-: |
| $1 \sim 3$ | $200$ | $10^3$ | A |
| $4 \sim 6$ | ^ | ^ | 无 |
| $7, 8$ | $5,000$ | $10^4$ | A |
| $9 \sim 11$ | ^ | ^ | 无 |
| $12$ | $10^5$ | $2 \times 10^5$ | A |
| $13, 14$ | ^ | ^ | B |
| $15, 16$ | ^ | ^ | 无 |
| $17 \sim 19$ | $4 \times 10^5$ | $8 \times 10^5$ | C |
| $20$ | ^ | ^ | 无 |

特殊性质 A: 保证初始时及每次修改后，存在整数 $p \in [2, n]$ 满足 $s_1 = s_2 = \cdots = s_p = 1$ 且 $s_{p+1} = \cdots = s_n = 0$。

特殊性质 B: 保证对于所有 $1 \leq i \leq q$, 均有 $l_i = 1$, $r_i = n$。

特殊性质 C: 保证对于所有 $1 \leq i \leq q$, 均有 $l_i = 1$, 且 $r_1 \leq r_2 \leq \cdots \leq r_q$。

附加文件来自于 [QOJ](https://qoj.ac/contest/2316/problem/13082)。

## 样例 #1

### 输入

```
0 2
5 2
11010
3 3
2 2
7 3
1010100
7 7
2 4
1 2```

### 输出

```
2
4```

# 题解

## 作者：_H17_ (赞：22)

## 题目分析

非常有意思的思维题。

首先我们弱化题目，考虑不用反转怎么做。

我们考虑相邻的 $3$ 个数什么情况下会变化：$s_i\ne s_{i-1},s_{i-2}=\texttt{1}$ 同时成立。显然这种情况只有 $\texttt{110},\texttt{101}$。

我们考虑目前已经有一个**不动的前缀** $p$ 和字符 $c$。我们只关心 $p$ 的最后 $2$ 个字符，不妨设为 $a,b$。

如果 $abc$ 构成 $\texttt{110}$，显然下一时刻 $c\gets \texttt{1}$，由于 $a=\texttt{1},b=\texttt{1}$，所以下一时刻无论 $b$ 从哪里转移过来 $b$ 一定也是 $\texttt{1}$。考虑 $c$ 后面的一个字符 $d$，$\texttt{10}d$ 中 $d$ 从前面的 $c(c=\texttt{0})$ 转移过来，即 $d=\texttt{0}$。这样 $abc\to bcd$，依次向后。假设一开始 $a$ 的下标是 $i$ 那么会变化 $n-i-1$ 次。

考虑 $abc$ 构成 $\texttt{101}$，下一次变化会变为 $\texttt{100}$。不会继续变化。

**提示：上面两种情况 $ab$ 不变是基于已经有一个不动的前缀的假设。**

接下来考虑前缀变化对 $\texttt{110},\texttt{101}$ 的影响。

显然有 $\texttt{110}$ 应该优先考虑，因为它的贡献更大。前面的一个 $\texttt{110}$ 会覆盖后面一个的贡献，所以取最靠前的。考虑 $\texttt{101}$ 对其的影响：样例 #1 的第一组测试数据阐释了这种情况：我们假定串是 $\texttt{10110xxxxx}$，经过一次变换之后变为 $\texttt{100110xxxx}$，不会有新的影响，不需要考虑。

由于 $\texttt{110}$ 已经优先考虑，$\texttt{101}$ 不继续考虑其影响。对于 $\texttt{101010101\dots}$ 显然变换之后不会形成新的 $\texttt{101}$（有连续两个 $\texttt{0}$）。

综上所述：静态查询的方案是如果有子串 $\texttt{110}$，取其第一次出现的位置 $i$，答案是 $n-i-1$；如果有 $\texttt{101}$，答案是 $1$；否则答案是 $0$。

考虑如何动态修改——线段树维护即可。

需要维护节点的最前、后的一、二位信息，以便合并。标记是反转。查询直接对根节点信息考虑上述静态方案即可。代码有点长。

时间复杂度 $O(t(n+q\log n))$。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
constexpr int N=4e5+1,Inf=0x3f3f3f3f3f3f3f3fll;
int id,T,n,q,a[N],tot,rt,ans;
string s;
struct SegmentTreeNode{
    int l,r,ls,rs,pre0,pre1,suf0,suf1,pre00,pre01,pre10,pre11,suf00,suf01,suf10,suf11,is101,is010,first110,first001,tag;//101,110
    SegmentTreeNode(int l=0,int r=0):l(l),r(r),ls(0),rs(0),tag(0){
        pre0=pre1=suf0=suf1=pre00=pre01=pre10=pre11=suf00=suf01=suf10=suf11=0;
        is101=is010=0,first110=first001=Inf;
    }
}f[N<<1];
void pushup(int cur){
    f[cur].pre0=f[f[cur].ls].pre0,
    f[cur].pre1=f[f[cur].ls].pre1;
    f[cur].suf0=f[f[cur].rs].suf0,
    f[cur].suf1=f[f[cur].rs].suf1;
    f[cur].pre00=f[cur].pre01=f[cur].pre10=f[cur].pre11=f[cur].suf00=f[cur].suf01=f[cur].suf10=f[cur].suf11=0;
    f[cur].is101=f[cur].is010=0,f[cur].first110=f[cur].first001=Inf;
    if(f[cur].r-f[cur].l+1==1)
        return;
    if(f[f[cur].ls].r-f[f[cur].ls].l+1==1){
        f[cur].pre00=f[f[cur].ls].pre0&f[f[cur].rs].pre0,
        f[cur].pre01=f[f[cur].ls].pre0&f[f[cur].rs].pre1,
        f[cur].pre10=f[f[cur].ls].pre1&f[f[cur].rs].pre0,
        f[cur].pre11=f[f[cur].ls].pre1&f[f[cur].rs].pre1;
    }
    else{
        f[cur].pre00=f[f[cur].ls].pre00,
        f[cur].pre01=f[f[cur].ls].pre01,
        f[cur].pre10=f[f[cur].ls].pre10,
        f[cur].pre11=f[f[cur].ls].pre11;
    }
    if(f[f[cur].rs].r-f[f[cur].rs].l+1==1){
        f[cur].suf00=f[f[cur].ls].suf0&f[f[cur].rs].suf0,
        f[cur].suf01=f[f[cur].ls].suf0&f[f[cur].rs].suf1,
        f[cur].suf10=f[f[cur].ls].suf1&f[f[cur].rs].suf0,
        f[cur].suf11=f[f[cur].ls].suf1&f[f[cur].rs].suf1;
    }
    else{
        f[cur].suf00=f[f[cur].rs].suf00,
        f[cur].suf01=f[f[cur].rs].suf01,
        f[cur].suf10=f[f[cur].rs].suf10,
        f[cur].suf11=f[f[cur].rs].suf11;
    }
    f[cur].is101=f[cur].is010=0,f[cur].first110=f[cur].first001=Inf;
    if(f[cur].r-f[cur].l+1==2)
        return;
    f[cur].is101=(f[f[cur].ls].is101|f[f[cur].rs].is101),
    f[cur].is010=(f[f[cur].ls].is010|f[f[cur].rs].is010);
    if(f[f[cur].ls].suf1&&f[f[cur].rs].pre01||f[f[cur].ls].suf10&&f[f[cur].rs].pre1)
        f[cur].is101=1;
    if(f[f[cur].ls].suf0&&f[f[cur].rs].pre10||f[f[cur].ls].suf01&&f[f[cur].rs].pre0)
        f[cur].is010=1;
    f[cur].first110=min(f[f[cur].ls].first110,f[f[cur].rs].first110),
    f[cur].first001=min(f[f[cur].ls].first001,f[f[cur].rs].first001);
    if(f[f[cur].ls].suf11&&f[f[cur].rs].pre0)
        f[cur].first110=min(f[cur].first110,f[f[cur].ls].r-1);
    if(f[f[cur].ls].suf00&&f[f[cur].rs].pre1)
        f[cur].first001=min(f[cur].first001,f[f[cur].ls].r-1);
    if(f[f[cur].ls].suf1&&f[f[cur].rs].pre10)
        f[cur].first110=min(f[cur].first110,f[f[cur].ls].r);
    if(f[f[cur].ls].suf0&&f[f[cur].rs].pre01)
        f[cur].first001=min(f[cur].first001,f[f[cur].ls].r);
    return;
}
void flip(int cur){
    swap(f[cur].pre0,f[cur].pre1),swap(f[cur].suf0,f[cur].suf1);
    swap(f[cur].pre00,f[cur].pre11),swap(f[cur].pre01,f[cur].pre10),
    swap(f[cur].suf00,f[cur].suf11),swap(f[cur].suf01,f[cur].suf10);
    swap(f[cur].is010,f[cur].is101),swap(f[cur].first110,f[cur].first001);
    f[cur].tag^=1;
    return;
}
void pushdown(int cur){
    if(f[cur].tag){
        flip(f[cur].ls),flip(f[cur].rs);
        f[cur].tag^=1;
    }
    return;
}
void build(int l,int r,int&cur){
    f[cur=(++tot)]=SegmentTreeNode(l,r);
    if(l==r){
        if(a[l])
            f[cur].pre1=f[cur].suf1=1;
        else
            f[cur].pre0=f[cur].suf0=1;
        return;
    }
    int mid=(l+r)>>1;
    build(l,mid,f[cur].ls),build(mid+1,r,f[cur].rs);
    return pushup(cur);
}
void modify(int l,int r,int cur){
    if(l<=f[cur].l&&f[cur].r<=r)
        return flip(cur);
    pushdown(cur);
    int mid=(f[cur].l+f[cur].r)>>1;
    if(l<=mid)
        modify(l,r,f[cur].ls);
    if(mid<r)
        modify(l,r,f[cur].rs);
    return pushup(cur);
}
int query(){
    int tmp;
    if((tmp=f[rt].first110)!=Inf)
        return n-tmp-1;
    else if(f[rt].is101)
        return 1;
    else
        return 0;
}/*
void debug(){
    cerr<<query()<<' '<<f[rt].first001<<'\n';
    return;
}*/
void Main(){
    tot=0;
    cin>>n>>q>>s;
    for(int i=1;i<=n;i++)
        a[i]=(s[i-1]^48);
    build(1,n,rt);
    ans=query();
//    debug();
    for(int i=1,l,r;i<=q;i++){
        cin>>l>>r;
        modify(l,r,rt);
        ans^=(i+1)*query();
//        debug();
    }
    cout<<ans<<'\n';
    return;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(nullptr),cout.tie(nullptr);
    for(cin>>id>>T;T;--T)
        Main();
    return 0;
}
```

---

## 作者：_droplet_ (赞：16)

## 前置知识

线段树。

## 思路

考虑对于字符串每一位 $i$，影响到这一位的只会有第 $i$ 位，第 $i-1$ 位和 $i-2$ 位，手搓 $3$ 位字符串可以发现：

- `101` 的情况可以更新 $1$ 次。
- `110` 的情况可以更新到字符串结尾，次数为字符串长度减该字串内最左侧字符位置再减 $1$。

考虑用线段树维护这个操作，记录内容如下：

- $b1$ 表示是否有 `110` 的情况，记录这个字符串的第一个 `1` 的位置。
- $b0$ 表示是否有 `001` 的情况，记录这个字符串的第一个 `0` 的位置，因为有区间异或操作，所以需要维护零的情况。
- $l0$ 表示某线段左侧 $0$ 的数量。
- $l1$ 表示某线段左侧 $1$ 的数量。
- $r0$ 表示某线段右侧 $0$ 的数量。
- $r1$ 表示某线段右侧 $1$ 的数量。
- $vl1$ 表示是否有 `101` 的情况。
- $vl0$ 表示是否有 `010` 的情况。

## 具体操作

### pushup

更新区间维护的所有信息。

对于每个点，设其为 $x$，其左子树为 $ls$，其右子树为 $rs$。
- 更新 $l0$ 时，若左子树 $l0$ 等于左子树区间长度，$l0_x=lsize+l0_{rs}$，否则 $l0_x=l0_{rs}$。
- 更新 $l1$，$r0$，$r1$ 同上操作。
- 更新 $vl1$ 时，若出现左子树末尾为 `...10`，右子树开头为 `1...` 的情况，$vl1_x=1$；若出现左子树末尾为 `...1`，右子树开头为 `01...` 的情况，$vl1_x=1$；否则为左右子树 $vl1$ 的最大值。
- 更新 $vl0$ 同上操作。
- 更新 $b1$ 时，若出现左子树末尾为，右子树开头为连续 `1` 的情况，且左子树的 $b1$ 在这个范围内，$b1_x=\min\{mid+l1_{rs}-1,b1_{rs}\}$，否则 $b1_x$ 为左子树的 $b1$，右子树的 $b1$ 和中间满足条件位置的最小值。
- 更新 $b0$ 同上操作。

### pushdown

交换对应的每一组两个数，更新懒标记。

### 特殊初始值

- $b1$ 初始值为极大值。
- $b0$ 初始值为极大值。
- $vl1$ 初始值为 $0$。
- $vl0$ 初始值为 $0$。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define tag(x) st[x].tag
#define vl0(x) st[x].vl0
#define vl1(x) st[x].vl1
#define ls(x) st[x].ls
#define rs(x) st[x].rs
#define b0(x) st[x].b0
#define b1(x) st[x].b1
#define l0(x) st[x].l0
#define l1(x) st[x].l1
#define r0(x) st[x].r0
#define r1(x) st[x].r1
#define lsz mid-l+1
#define rsz r-mid
#define sz r-l+1
using namespace std;
const int N=800010;
int n,m,a[N];
struct treenode{
	int ls,rs,b0,b1,l0,l1,r0,r1,vl0,vl1,tag;
}st[N];
struct segtree{
	int rt,tc;
	void pushup(int x,int l,int r){ // 同上描述
		int mid=(l+r)>>1;
		vl0(x)=max(vl0(ls(x)),vl0(rs(x)));
		vl1(x)=max(vl1(ls(x)),vl1(rs(x)));
		if(r0(ls(x))&&l0(rs(x))){
			b0(x)=min(mid+l0(rs(x))-1,b0(rs(x)));
			if(b0(ls(x))<mid-r0(ls(x))+1) b0(x)=min(b0(x),b0(ls(x)));
		}else b0(x)=min(b0(ls(x)),b0(rs(x)));
		if(r1(ls(x))&&l1(rs(x))){
			b1(x)=min(mid+l1(rs(x))-1,b1(rs(x)));
			if(b1(ls(x))<mid-r1(ls(x))+1) b1(x)=min(b1(x),b1(ls(x)));
		}else b1(x)=min(b1(ls(x)),b1(rs(x)));
		l0(x)=(l0(ls(x))!=lsz?l0(ls(x)):lsz+l0(rs(x)));
		l1(x)=(l1(ls(x))!=lsz?l1(ls(x)):lsz+l1(rs(x)));
		r0(x)=(r0(rs(x))!=rsz?r0(rs(x)):rsz+r0(ls(x)));
		r1(x)=(r1(rs(x))!=rsz?r1(rs(x)):rsz+r1(ls(x)));
		if((r0(ls(x))&&l1(rs(x))==1&&rsz>1)||(r1(ls(x))==1&&l0(rs(x))&&lsz>1)) vl0(x)=max(vl0(x),1ll);
		if((r0(ls(x))==1&&l1(rs(x))&&lsz>1)||(r1(ls(x))&&l0(rs(x))==1&&rsz>1)) vl1(x)=max(vl1(x),1ll);
	}
	void pushdown(int x){ // 同上描述
		if(!tag(x)) return;
		tag(ls(x))^=tag(x); 
		tag(rs(x))^=tag(x); 
		swap(vl0(ls(x)),vl1(ls(x))),swap(vl0(rs(x)),vl1(rs(x)));
		swap(b0(ls(x)),b1(ls(x))),	swap(b0(rs(x)),b1(rs(x)));
		swap(l0(ls(x)),l1(ls(x))),	swap(l0(rs(x)),l1(rs(x)));
		swap(r0(ls(x)),r1(ls(x))),	swap(r0(rs(x)),r1(rs(x)));
		tag(x)=0;
	}
	void build(int &x,int l,int r){
		x=++tc;
		tag(x)=0;
		b0(x)=b1(x)=2*n;
		vl0(x)=vl1(x)=0;
		l1(x)=r1(x)=l0(x)=r0(x)=0;
		if(l==r){
			if(a[l]){ // 根据输入更新
				l1(x)=r1(x)=1;
				l0(x)=r0(x)=0;
			}else{
				l1(x)=r1(x)=0;
				l0(x)=r0(x)=1;
			}
			return;
		}
		int mid=(l+r)>>1;
		build(ls(x),l,mid);
		build(rs(x),mid+1,r);
		pushup(x,l,r);
	}
	void update(int x,int l,int r,int ql,int qr){
		if(ql<=l&&r<=qr){
			tag(x)^=1;
			swap(vl0(x),vl1(x));
			swap(b0(x),b1(x));
			swap(l0(x),l1(x));
			swap(r0(x),r1(x));
			return;
		}
		pushdown(x);
		int mid=(l+r)>>1;
		if(ql<=mid) update(ls(x),l,mid,ql,qr);
		if(mid<qr) update(rs(x),mid+1,r,ql,qr);
		pushup(x,l,r);
	}
	int query(){
		int ans=vl1(rt);
		if(b1(rt)!=2*n) ans=max(ans,n-b1(rt)-1); // 输出答案为 vl1 和 b1 位置更新到末尾的最大值
		return ans;
	}
	void print(int x,int l,int r){ // 调试用
		cout<<x<<"|"<<l<<"|"<<r<<"|\tvl0 "<<vl0(x)<<"\tvl1 "<<vl1(x)<<"\tl0 "<<l0(x)<<"\tl1 "<<l1(x)<<"\tr0 "<<r0(x)<<"\tr1 "<<r1(x)<<"\tb0 "<<b0(x)<<"\tb1 "<<b1(x)<<"\n";
		pushdown(x);
		if(l==r) return;
		int mid=(l+r)>>1;
		print(ls(x),l,mid);
		print(rs(x),mid+1,r);
	}
}t;

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int T;
	cin>>T>>T;
	while(T--){
		t.tc=0;
		cin>>n>>m;
		char c;
		for(int i=1;i<=n;i++){
			cin>>c;
			a[i]=c-'0';
		}
		t.build(t.rt,1,n);
//		t.print(t.rt,1,n);
//		cout<<t.query()<<"\n";
		int l,r,ans=0;
		ans=t.query();
		for(int i=2;i<=m+1;i++){
			cin>>l>>r;
			t.update(t.rt,1,n,l,r);
//			t.print(t.rt,1,n);
//			cout<<t.query()<<"\n";
			ans^=i*t.query();
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：WorldMachine (赞：10)

送。

考虑什么样的长度为 $3$ 的串会动，$0$ 开头的肯定不会动，$1$ 开头且第二、三个位置上相等的串也不会动，因此会动的只有 $101$ 和 $110$。

对于 $101$，动一下之后会变成 $100$，然后就不动了。

对于 $110\text{X}$，动一下之后就会变成 $\text{X}110$ 这个形式的串，相当于往右走了一格。

因此若 $S$ 中存在 $110$，设最左边的 $110$ 的 $0$ 为第 $x$ 位，答案即为 $n-x+1$；否则若存在 $101$ 则答案为 $1$，否则为 $0$。

现在带上区间修改，使用线段树维护，由于有 01 反转，需要同时维护 $010$ 和 $001$。

pushup 时，跨越 $\text{mid}$ 的长度为 $3$ 的区间有两个，因此需要维护每个节点的最左边、左数第二个、最右边、右数第二个位置上的值。

为什么要线段树二分呢，直接把 $110$ 和 $001$ 的位置当成信息维护就行了。

没写 pushdown 调了接近半个小时，这辈子有了。

有一点细节，详见代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
typedef long long ll;
const int N = 4e5 + 5, INF = 1e9;
int task_id, T, n, q;
char a[N]; bool tg[N << 2];
struct node { int p1, p0, l, ll, r, rr; bool f1, f0; } t[N << 2];
#define lc p << 1
#define rc lc | 1
#define rev(x) (x = x == -1 ? -1 : !x)
il void flip(int p) { tg[p] = !tg[p], swap(t[p].p1, t[p].p0), swap(t[p].f1, t[p].f0), rev(t[p].l), rev(t[p].ll), rev(t[p].r), rev(t[p].rr); }
il void psd(int p) { if (tg[p]) flip(lc), flip(rc), tg[p] = 0; }
il void psu(int p, int mid) {
	t[p].p1 = min({t[lc].p1, t[rc].p1, t[lc].rr == 1 && t[lc].r == 1 && t[rc].l == 0 ? mid + 1 : INF, t[lc].r == 1 && t[rc].l == 1 && t[rc].ll == 0 ? mid + 2 : INF});
	t[p].p0 = min({t[lc].p0, t[rc].p0, t[lc].rr == 0 && t[lc].r == 0 && t[rc].l == 1 ? mid + 1 : INF, t[lc].r == 0 && t[rc].l == 0 && t[rc].ll == 1 ? mid + 2 : INF});
	t[p].f1 = (t[lc].f1 || t[rc].f1 || t[lc].rr == 1 && t[lc].r == 0 && t[rc].l == 1 || t[lc].r == 1 && t[rc].l == 0 && t[rc].ll == 1);
	t[p].f0 = (t[lc].f0 || t[rc].f0 || t[lc].rr == 0 && t[lc].r == 1 && t[rc].l == 0 || t[lc].r == 0 && t[rc].l == 1 && t[rc].ll == 0);
	t[p].l = t[lc].l, t[p].ll = t[lc].ll == -1 ? t[rc].l : t[lc].ll;
	t[p].r = t[rc].r, t[p].rr = t[rc].rr == -1 ? t[lc].r : t[rc].rr;
}
il void build(int p, int l, int r) {
	tg[p] = 0;
	if (l == r) return t[p] = {INF, INF, a[l] - '0', -1, a[l] - '0', -1, 0, 0}, void();
	int mid = l + r >> 1; build(lc, l, mid), build(rc, mid + 1, r), psu(p, mid);
}
il void upd(int p, int l, int r, int L, int R) {
	if (L <= l && r <= R) return flip(p), void();
	int mid = l + r >> 1; psd(p);
	if (L <= mid) upd(lc, l, mid, L, R); if (R > mid) upd(rc, mid + 1, r, L, R);
	psu(p, mid);
}
il int qry() {
	if (t[1].p1 != INF) return n - t[1].p1 + 1;
	return t[1].f1;
}
il void solve() {
	ll ans = 0;
	cin >> n >> q >> a + 1, build(1, 1, n), ans ^= qry();
	for (int _q = 1, l, r; _q <= q; _q++) cin >> l >> r, upd(1, 1, n, l, r), ans ^= ll(_q + 1) * qry();
	cout << ans << '\n';
}
int main() {
	// freopen("ternary.in", "r", stdin), freopen("ternary.out", "w", stdout);
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin >> task_id >> T; while (T--) solve();
}
```

---

## 作者：OrinLoong (赞：4)

## LGP13274 [NOI2025] 三目运算符 学习笔记
[Luogu Link](https://www.luogu.com.cn/problem/P13274)

### 前言
大家好，我是 24-25 赛季湖柏三倍正式队线选手。

> 才饮吹布尔，又食贴纳瑞。
> $n\le 10^4$ 样例横渡，极目 $\text{AC}$ 舒……

国赛 $\texttt{d2t1}$ $\text{VS}$ 省选 $\texttt{d2t1}$，你知道吗？

### 题意简述
对于一个长度为 $n$ ($n \geq 3$) 的 01 串 $S = s_1 \ldots s_n$，定义变换 $T = f(S) = t_1 \ldots t_n$ 如下：

$$t_i = \begin{cases} 
s_i, & i \leq 2, \\
s_i, & i \geq 3 \text{ 且 } s_{i-2} = 0, \\
s_{i-1}, & i \geq 3 \text{ 且 } s_{i-2} = 1.
\end{cases}$$

若串 $T$ 满足 $f(T) = T$，则称 $T$ 为变换 $f$ 的不动点。

记 $f^k(S)$ 为 $S$ 经过 $k$ 次变换得到的串。特别地，记 $f^0(S)=S$。求最小的自然数 $k$，使得 $f^k(S)$ 为变换 $f$ 的不动点，即满足 $f^{k+1}(S) = f^k(S)$ 的最小的自然数 $k$。可以证明，一定存在自然数 $k$ 使得 $f^k(S)$ 为变换 $f$ 的不动点。

还有 $q$ 次修改操作。第 $i$ 次修改会将区间 $[l_i,r_i]$ 01 反转。对初始时及每次修改后的字符串 $S$，都求出最小的 $k$。

### 做法解析
$f(S)_i$ 只取决于 $S_{[i-2,i]}$。手玩分析问题。你发现在 $8$ 个三位长的 01 串中，只有 $2$ 个会造成 $f(S)_i\neq S_i$：$110$ 和 $101$。

进一步手玩分析。$\texttt{101}$ 一步变成 $\texttt{XY0}$ 就独自美丽了，但 $\texttt{110}$ 不一样，它会强势地把后面的东西都撅了。$\texttt{110X}$ 在变换后会变成 $\texttt{Y110}$，相当于往右走了一格。

所以答案已经呼之欲出了。$ans=\max([E],(n-j+1))$。其中 $E$ 为 $101$ 子串的存在性，$j$ 为最靠左的 $110$ 的 $0$ 的下标。

小朋友，告诉我这道题要怎么维护信息啊？对啦，当然是用我们最可爱的线段树啦！

+ 维护区间内 $\texttt{110}$、$\texttt{101}$ 的存在性。
+ 因为有区间反转所以也维护 $\texttt{001}$、$\texttt{010}$ 的存在性。暂且称以上这四个是关键串。
+ 由于你需要 `pushup`，所以你需要维护区间前缀 $\texttt{1}$、$\texttt{0}$、$\texttt{11}$、$\texttt{10}$，这些可能在你 `pushup` 时组成关键串的后半部分。
+ 同理维护区间后缀 $\texttt{0}$、$\texttt{1}$、$\texttt{00}$、$\texttt{01}$、$\texttt{10}$、$\texttt{11}$。这些可能在你 `pushup` 时组成关键串的前半部分。

就这样。写就完了。

### 代码实现
我们不缺线段树这点空间，所以不妨直接这么开，让01串对应二进制意义。

```cpp
#include <bits/stdc++.h>
using namespace std;
using namespace obasic;
const int MaxN=8e5+5,isk[8]={0,1,1,0,0,1,1,0};
int N,M,A[MaxN];
struct SegTree{
    int cl[MaxN<<2],cr[MaxN<<2],cmid[MaxN<<2],tag[MaxN<<2],exist[MaxN<<2][8];
    int pre1[MaxN<<2][2],pre2[MaxN<<2][4],suf1[MaxN<<2][2],suf2[MaxN<<2][4];
    int ls(int u){return u<<1;}
    int rs(int u){return (u<<1)|1;}
    void clearnode(int u){
        cl[u]=cr[u]=cmid[u]=tag[u]=pre1[u][0]=pre1[u][1]=suf1[u][0]=suf1[u][1]=0;
        fill(exist[u],exist[u]+8,0);fill(pre2[u],pre2[u]+4,0),fill(suf2[u],suf2[u]+4,0);
    }
    void pushup(int u){
        int clen=cr[u]-cl[u]+1;
        if(clen<4){
            for(int i=0;i<4;i++)suf2[u][i]=suf1[ls(u)][i>>1]&&pre1[rs(u)][i&1];
            if(clen==2)memcpy(pre2[u],suf2[u],sizeof(suf2[u]));
            else for(int i=0;i<4;i++)pre2[u][i]=pre2[ls(u)][i];
        }
        for(int i=0,flag;i<8;i++){
            if(i<2)pre1[u][i]=pre1[ls(u)][i],suf1[u][i]=suf1[rs(u)][i];
            if(i<4&&clen>=4)pre2[u][i]=pre2[ls(u)][i],suf2[u][i]=suf2[rs(u)][i];
            if(!isk[i])continue;flag=0;
            exist[u][i]=exist[ls(u)][i]||exist[rs(u)][i];
            exist[u][i]|=(suf1[ls(u)][i>>2]&&pre2[rs(u)][i&3]);
            exist[u][i]|=(suf2[ls(u)][i>>1]&&pre1[rs(u)][i&1]);
        }
    }
    void build(int u,int l,int r){
        clearnode(u),cl[u]=l,cr[u]=r;if(l==r){pre1[u][A[l]]=suf1[u][A[l]]=1;return;}
        int mid=(l+r)>>1;cmid[u]=mid;build(ls(u),l,mid),build(rs(u),mid+1,r);pushup(u);
    }
    void maketag(int u){
        tag[u]^=1;swap(pre1[u][0],pre1[u][1]),swap(suf1[u][0],suf1[u][1]);
        for(int i=0;i<2;i++)swap(pre2[u][i],pre2[u][3-i]),swap(suf2[u][i],suf2[u][3-i]);
        for(int i=0;i<4;i++)if(isk[i])swap(exist[u][i],exist[u][7-i]);
    }
    void pushdown(int u){if(tag[u])maketag(ls(u)),maketag(rs(u)),tag[u]=0;}
    void update(int u,int dl,int dr){
        if(dl<=cl[u]&&cr[u]<=dr){maketag(u);return;}
        pushdown(u);
        if(dl<=cmid[u])update(ls(u),dl,dr);
        if(dr>cmid[u])update(rs(u),dl,dr);
        pushup(u);
    }
    int binser(int u){
        if(!exist[u][6])return 0;
        if(cr[u]-cl[u]+1==3&&exist[u][6])return cr[u];
        pushdown(u);int res=binser(ls(u));if(res)return res;
        if(suf2[ls(u)][3]&&pre1[rs(u)][0])return cmid[u]+1;
        if(suf1[ls(u)][1]&&pre2[rs(u)][2])return cmid[u]+2;
        res=binser(rs(u));return res;
    }
}SgT;
int X,Y;char ch;
int solve(){
    int res=SgT.binser(1);
    if(res)return N-res+1;
    return SgT.exist[1][5];
}
lolo ans;
void mian(){
    readis(N,M);
    for(int i=1;i<=N;i++)scanf(" %c",&ch),A[i]=ch-'0';
    SgT.build(1,1,N);ans=solve();
    for(int i=1;i<=M;i++)readis(X,Y),SgT.update(1,X,Y),ans^=1ll*(i+1)*solve();
    writil(ans);
}
int Tpn,Tcn;
int main(){
    readis(Tpn,Tcn);
    while(Tcn--)mian();
    return 0;
}
```

### 后记
> > 其实，$\text{NOI}$ $\texttt{d2t1}$ 设定上是不要求难度高于提高组的。  
> > 是吗……为什么要告诉我这个。  
> > 没什么……只是想让你知道而已。
>
> ——《打铁的距离感》

笑点解析：主播的NOI2025连铁都没得打。是因为主播不想打吗？

---

## 作者：Mickey_Cat2025 (赞：4)

考虑枚举所有长度为 $ \texttt{3} $ 的 $ \texttt{01} $ 串，$ \texttt{0} $ 开头的显然不会改变，$ \texttt{1} $ 开头的串在第二，三位相等的时候也不会改变，会改变的串只有 $ \texttt{110} $ 和 $ \texttt{101} $。

对于 $ \texttt{110} $，变换一次后第三位会变成 $ \texttt{1} $,第四位（如果有的话）会变成 $ \texttt{0} $。

对于 $ \texttt{101} $,变换一次后会变成 $ \texttt{100} $，然后就不改变了。

因此若存在 $ \texttt{110} $，设最右边的 $ \texttt{1} $ 所在的位置为 $ x $，答案为 $ n-x-1 $,否则判断是否存在 $ \texttt{101} $，有则答案为 $ \texttt{1} $，否则答案为 $ \texttt{0} $。

考虑修改操作，区间修改+全局查询容易想到线段树，只需维护区间前缀2位，后缀2位，$ \texttt{110} $，$ \texttt{101} $，$ \texttt{010} $，$ \texttt{001} $ 最早出现的位置即可。时间复杂度 $ \mathcal O(n \log n) $。

[代码](https://www.luogu.com.cn/record/225189605)

---

## 作者：AC_Lover (赞：3)

[P13274 [NOI2025] 三目运算符](https://www.luogu.com.cn/problem/P13274)

乍一看这个关系还是很复杂的，但是冷静下来我们发现 $t_i$ 的取值只与 $s_{i-2},s_{i-1},s_i$ 有关，这启发我们分析三个字符会怎样变化，意思是，我们考虑这样一个字符串：

$$
\texttt{\_\_\_XXX\dots X} 
$$

考察前三位的字符会怎样影响后面。打表不难发现，当前三位是 $101$ 时，进行一次变换会变成 $100$，然后就稳定了。当前三位是 $110$ 时，字串这样变化：

```
0 110XXXXX
1 1110XXXX
2 11110XXX
3 111110XX
4 1111110X
5 11111110
6 11111111
```

相当于这个 $110$ 不断后移，然后最终把整个串都推平。

而对于其他的组合，每次变换都不会有影响。

那做法就呼之欲出了，考虑 $s$ 最前面的 $110$，记其 $0$ 的位置为 $p$，这个会在 $n-p+1$ 轮之后扫平后面的一切字符，整个串也就稳定了。而对于 $101$，其最多只会影响一轮，所以用 $101$ 的存在性来决定答案是不是非 $0$ 的。

加入反转操作，则可以用线段树维护上述信息，即 $110$ 的最靠前位置，以及 $101$ 是否存在。

具体的，我们可以维护一个区间 $[l,r]$ 的 $s_l,s_{l+1},s_{r-1},s_r$，然后合并时大力分讨一下。

时间复杂度 $O(n\log n)$。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long ll;
template<class T>void Min(T &x,T y) { if (y<x) x=y; }
const int N=400010;
int n,Q;
string s;

struct Node
{
	int l,r;
	int la,lb,ra,rb;
	int p110,p001;
	bool f101,f010;
	bool flip;
	void clr() { p110=p001=1e9,f101=f010=false,flip=false; }
} tr[N*4];

#define cur tr[u]
#define lc tr[u<<1]
#define rc tr[u<<1|1]

inline void pushup(int u)
{
	int mid=(cur.l+cur.r)>>1;
	cur.la=lc.la,cur.lb=(lc.lb!=-1 ? lc.lb : rc.la);
	cur.ra=(rc.ra!=-1 ? rc.ra : lc.rb),cur.rb=rc.rb;
	cur.p110=min(lc.p110,rc.p110);
	if (lc.ra==1 && lc.rb==1 && rc.la==0) Min(cur.p110,mid+1);
	else if (lc.rb==1 && rc.la==1 && rc.lb==0) Min(cur.p110,mid+2);
	cur.p001=min(lc.p001,rc.p001);
	if (lc.ra==0 && lc.rb==0 && rc.la==1) Min(cur.p001,mid+1);
	else if (lc.rb==0 && rc.la==0 && rc.lb==1) Min(cur.p001,mid+2);
	cur.f101=lc.f101 | rc.f101 | ((lc.ra==1 && lc.rb==0 && rc.la==1) || (lc.rb==1 && rc.la==0 && rc.lb==1));
	cur.f010=lc.f010 | rc.f010 | ((lc.ra==0 && lc.rb==1 && rc.la==0) || (lc.rb==0 && rc.la==1 && rc.lb==0));
}

inline void build(int u,int l,int r)
{
	cur.l=l,cur.r=r;
	cur.clr();
	if (l==r) 
	{
		cur.la=cur.rb=s[l]-'0';cur.lb=cur.ra=-1;
		return;
	}
 	int mid=(l+r)>>1;
 	build(u*2,l,mid);
 	build(u*2+1,mid+1,r);
 	pushup(u);
}

inline void Flip(int u)
{
	cur.flip^=1;
	cur.la^=1,cur.rb^=1;
	if (cur.l<cur.r) { cur.lb^=1,cur.ra^=1; }
	swap(cur.p110,cur.p001);swap(cur.f101,cur.f010);
}

inline void pushdown(int u)
{
	if (cur.flip)
	{
		Flip(u*2);
		Flip(u*2+1);
		cur.flip=0;
	}
}

inline void modify(int u,int l,int r)
{
	if (l<=cur.l && cur.r<=r) 
	{
		Flip(u);
		return;
	}
	pushdown(u);
	int mid=(cur.l+cur.r)>>1;
	if (l<=mid) modify(u*2,l,r);
	if (r>mid) modify(u*2+1,l,r);
	pushup(u);
}

inline int get()
{
	int res=(tr[1].f101 ? 1 : 0);
	if (tr[1].p110!=1e9) res=max(res,n-tr[1].p110+1);
	return res;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	
	int id,T;cin >> id >> T;
	while (T--)
	{
		cin >> n >> Q;
		cin >> s;
		s=" "+s;
		
		ll ans=0;
		build(1,1,n);
		ans^=get();
		for (int i=1;i<=Q;i++)
		{
			int l,r;
			cin >> l >> r;
			modify(1,l,r);
			ans^=(ll)get()*(i+1);
		}
		cout << ans << "\n";
	}
	
	return 0;
}
```

---

## 作者：vegetable_king (赞：3)

[广告](https://www.luogu.com.cn/article/gu1g06o4)。不知道以后还有没有机会写题解。

我们将串 $S$ 做差分，得到串 $a$，其中 $a_i = s_{i - 1} \oplus s_i$（这里约定 $s_0 = 0$）。然后答案的结论如下：

- 若 $a$ 中所有极长 $1$ 段的长度均为偶数，那么如果存在长度 $> 2$ 的极长 $1$ 段，则答案为 $1$，否则为 $0$。

- 考虑 $a$ 中最靠左的长度为奇数的极长 $1$ 段，如果它是最后一段，那么情况与长度全为偶数相同；否则，设它的下一段左端点为 $l$，那么答案为 $n - l + 1$。

修改天然变为单点修改，于是 `set` 直接维护连续段就可以做到 $O(n + q \log n)$，十分好写。证明可能比较麻烦，需要一定的分类讨论。可能还是建议打表来发现结论。

由于笔者可能暂时退役了，所以没有代码。

---

## 作者：lzt415 (赞：3)

## 前言
不是，什么年头连我都会做两道国赛题了，这题有点水。

## 思路
这题一眼线段树。

首先想到先考虑长度最小时的状况，即长度为 $3$ 的串怎么变。

我们发现除了 $101$ 和 $110$ 以外的串都不会变化，所以那些形式的串我们暂且不管。

先说说 $110$，容易发现 $110X$ 在一次变化后会变成 $X110$，这里的 $X$ 表示未知数字。然后你会发现这个变化似乎很像一个操作，即把 $110$ 整体往后移一格。因此，若线段树树维护区间存在 $110$，那么要找到最左边的 $110$ 的开头位置，计为第 $x$ 位，则答案为 $len-x+1$，$len$ 为区间长度，区间合并时答案做加法，如果你合并有疑问下面会说。

再说说 $101$，$101$ 只能变成 $XX0$，其中有作用的只有 $110$，似乎问题棘手起来，但容易发现的是，这个 $110$ 必须是前面的 $110$ 右移过来，所以这个情况应该扔给上面所讲的那个部分处理。

好，怎么合并呢？我们只需要几个判断语句在合并时判断中间夹不夹着 $101$ 和 $110$ 即可。

话说不会合并的也不会来做这题吧。

现在带上区间修改，由于 $01$ 反转，再维护一下 $010$ 和 $001$ 即可，毕竟人家摇身一变，就反转成 $101$ 和 $110$ 了。

好了，讲完了。

---

## 作者：ZHR100102 (赞：2)

[Blog](https://www.cnblogs.com/zhr0102/p/18991951)

初看题目骂出题人是奶龙，结果写的想死，最后还被卡常了，我以后再也不黑 D2T1 了。

观察移动规律与特殊性质 A，不难发现性质：
- 当形成一段长度 $\ge 2$ 的全 $\texttt{1}$ 段的时候，**后面所有位置**都会被更新一遍。
- 当形成一段 $\texttt{101}$ 的时候，这三个字符中的最后一个 $\texttt{1}$ **只会改变一次**。

因此，可以得出 $k$ 的计算方式：
- 当存在一段 $\texttt{110}$ 的时候，假设**第一个出现的** $\texttt{110}$ 的起始位置是 $p$，则 $k=n-p-1$。此处第一个出现的 $\texttt{110}$ 可以理解为全串的第一个全 $\texttt{1}$ 段。
- 否则若存在一段 $\texttt{101}$，则 $k=1$，因为所有的 $\texttt{101}$ 都是**同步发生修改**的。
- 若上面两条都不满足，则无法发生任何改变，$k=0$。

接下来看似无脑维护就行了，实际上写起来差点没把我恶心死。一开始我的做法是直接开两颗线段树，一颗维护 $\texttt{110},\texttt{001},\texttt{101},\texttt{010}$ 的**最小位置**，下标是每个长度为 $3$ 的段的起始位置；另一颗**维护当前的序列**。修改的时候对第一棵树中下标为 $[l,r-2]$ 的位置直接反转，然后对下标为 $l-2,l-1,r+1,r$ 的位置根据当前的序列的情况处理一下即可。但是喜提最后一个点 TLE。

分析后发现很大一部分时间开销在最后那四个位置需要修改成的值的查询上，因此把第二颗线段树换成**树状数组**，维护序列即可。时间复杂度 $O(n\log n)$，常数较大。

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define eb(x) emplace_back(x)
#define pb(x) push_back(x)
#define lc (p<<1)
#define rc ((p<<1)|1)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
using pi=pair<int,int>;
const int N = 400005, inf = 0x3f3f3f3f;
int n, q, a[N], b[N];
struct Node1{
    int l, r, tag, p001, p110, p101, p010;
};
struct Segtree1{
    Node1 tr[4 * N];
    void pushup(int p)
    {
        tr[p].p110 = min(tr[lc].p110, tr[rc].p110);
        tr[p].p001 = min(tr[lc].p001, tr[rc].p001);
        tr[p].p101 = min(tr[lc].p101, tr[rc].p101);
        tr[p].p010 = min(tr[lc].p010, tr[rc].p010);
    }
    void pushdown(int p)
    {
        if(tr[p].tag)
        {
            tr[lc].tag ^= 1;
            tr[rc].tag ^= 1;
            swap(tr[lc].p001, tr[lc].p110);
            swap(tr[lc].p101, tr[lc].p010);
            swap(tr[rc].p001, tr[rc].p110);
            swap(tr[rc].p101, tr[rc].p010);
        }
        tr[p].tag = 0;
    }
    void build(int p, int ln, int rn)
    {
        tr[p]={ln, rn, 0, b[ln]==1 ? ln : inf, b[ln]==2 ? ln : inf, b[ln]==3 ? ln : inf, b[ln]==4 ? ln : inf};
        if(ln == rn)return;
        int mid = (ln + rn) >> 1;
        build(lc, ln, mid);
        build(rc, mid+1, rn);
        pushup(p);
    }
    void update(int p, int ln, int rn)
    {
        if(ln <= tr[p].l && tr[p].r <= rn)
        {
            tr[p].tag ^= 1;
            swap(tr[p].p001, tr[p].p110);       
            swap(tr[p].p010, tr[p].p101);   
            return;     
        }
        pushdown(p);
        int mid = (tr[p].l + tr[p].r) >> 1;
        if(ln <= mid)update(lc, ln, rn);
        if(rn >= mid + 1)update(rc, ln, rn);
        pushup(p);
    }
    void modify(int p, int pos, int tp)
    {
        if(tr[p].l == pos && tr[p].r == pos)
        {
            tr[p].p001 = tr[p].p110 = tr[p].p010 = tr[p].p101 = inf;
            if(tp == 0)tr[p].p001 = pos;
            else if(tp == 1)tr[p].p110 = pos;
            else if(tp == 2)tr[p].p010 = pos;
            else if(tp == 3)tr[p].p101 = pos;
            return;
        }
        pushdown(p);
        int mid = (tr[p].l + tr[p].r) >> 1;
        if(pos <= mid)modify(lc, pos, tp);
        else modify(rc, pos, tp);
        pushup(p);
    }
}tr1;
struct BIT{
    bitset<N> tr;
    int lowbit(int x){return (x&(-x));}
    void init()
    {
        for(int i=0;i<=n+1;i++)tr[i]=0;
    }
    int query(int x)
    {
        int res=0;
        while(x)
        {
            res^=tr[x];
            x-=lowbit(x);
        }
        return res;
    }
    void update(int x)
    {
        while(x<=n)
        {
            tr[x]=(tr[x]^1);
            x+=lowbit(x);
        }
    }
}tr2;
ll ans;
inline int chktyp(int x)
{
    int aa = tr2.query(x), bb = tr2.query(x+1), cc = tr2.query(x+2);
    if(aa == 0 && bb == 0 && cc == 1)return 0;
    if(aa == 1 && bb == 1 && cc == 0)return 1;
    if(aa == 0 && bb == 1 && cc == 0)return 2;
    if(aa == 1 && bb == 0 && cc == 1)return 3;
    return 4;
}
int getans()
{
    int res = tr1.tr[1].p110;
    if(res == inf)
    {
        if(tr1.tr[1].p101==inf)return 0;
        return 1;
    }
    return n - res - 1;
}
void solve()
{
    cin >> n >> q;
    tr2.init();
    for(int i = 1; i <= n; i++)
    {
        char c;
        cin >> c;
        a[i] = c - '0';
        b[i] = 0;
        if(a[i])
        {
            tr2.update(i);
            tr2.update(i+1);
        }
    }
    for(int i = 1; i <= n-2; i++)
    {
        if(a[i] == 0 && a[i+1] == 0 && a[i+2] == 1)b[i] = 1;
        if(a[i] == 1 && a[i+1] == 1 && a[i+2] == 0)b[i] = 2;
        if(a[i] == 1 && a[i+1] == 0 && a[i+2] == 1)b[i] = 3;
        if(a[i] == 0 && a[i+1] == 1 && a[i+2] == 0)b[i] = 4;
    }
    tr1.build(1, 1, n-2);
    ans = getans();
    for(int i = 1; i <= q; i++)
    {
        int l, r;
        cin >> l >> r;
        tr2.update(l);
        tr2.update(r + 1);
        if(l == r)
        {
            if(l-2 >= 1 && l-2 <= n-2)tr1.modify(1, l-2, chktyp(l-2));
            if(l-1 >= 1 && l-1 <= n-2)tr1.modify(1, l-1, chktyp(l-1));
            if(l <= n-2)tr1.modify(1, l, chktyp(l));
        }
        else
        {
            if(l <= n-2 && l <= min(r-2,n-2))tr1.update(1, l, min(r-2,n-2));
            if(l-2 >= 1 && l-2 <= n-2)tr1.modify(1, l-2, chktyp(l-2));
            if(l-1 >= 1 && l-1 <= n-2)tr1.modify(1, l-1, chktyp(l-1));
            if(r-1 >= 1 && r-1 <= n-2)tr1.modify(1, r-1, chktyp(r-1));
            if(r <= n-2)tr1.modify(1, r, chktyp(r));            
        }
        ans ^= (1ll * (i+1) * getans());
    }
    cout << ans << '\n';
}
int main()
{
    //freopen("sample.in","r",stdin);
    //freopen("sample.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int cid, t;
    cin >> cid >> t;
    while(t--)solve();
    return 0;
}
```

---

## 作者：Unnamed114514 (赞：2)

三元太复杂了，先简化一下式子：

$$
t_i = \begin{cases}
s_i,&i\le2,\\
s_i,&s_i=s_{i-1},\\
s_i\oplus s_{i-2},&s_i\ne s_{i-1}\\
\end{cases}
$$

在这情况下，容易发现，$i$ 是动点的条件是 $s_{i-2}=1$ 且 $s_i\ne s_{i-1}$，更进一步地，容易发现只有 $110,101$ 满足条件。

注意到 $110$ 每次会往后移动 $1$，一直移动到 $s_n=0$ 然后再移动一次。如果不存在 $110$，那么就只会有 $0101$ 这种情况，然后会得到 $??00$ 的情况（$?$ 随便），根据式子的推导，如果 $s_i=s_{i-1}$ 那么它只会在内部转化。因为前面没有 $110$ 推过来，所以 $101$ 就只会在内部转化，无论如何在一步之后每个位置都不会转化，贡献至多为 $1$。

因此 $110$ 的贡献不低于 $101$ 的贡献，那么我们可以得到解法：

- 若原串存在 $110$，找到最左边的 $110$ 的 $0$ 的位置 $p$，答案为 $n-p+1$。

- 否则，若原串存在 $101$，答案为 $1$。

- 否则，答案为 $0$。

然后每个位置把它和它前两位状压起来，然后线段树维护对应区间是否有对应状态，修改就转化成 $3$ 个区间异或。

时间复杂度 $O(n\log n)$，不过为什么这么慢啊，用了 `#define int long long` 就过不了了。

```cpp
#include<bits/stdc++.h>
#define ls p<<1
#define rs p<<1|1
#define endl '\n'
using namespace std;
const int N=4e5+5;
int T,n,c,q,a[N];
long long ans;
string s;
struct node{ int val,state,tag; }t[N<<2];
void build(int p,int l,int r){
	t[p].tag=0;
	if(l==r){
		t[p].val=a[l],t[p].state=(1<<a[l]);
		return;
	}
	int mid=l+r>>1;
	build(ls,l,mid),build(rs,mid+1,r);
	t[p].state=t[ls].state|t[rs].state;
}
int trans(int state,int c){
	int res=0;
	for(int i=0;i<8;++i) if(state>>i&1) res|=(1<<(i^c));
	return res; 
}
void Xor(int p,int l,int r,int ql,int qr,int c){
	if(ql<=l&&r<=qr){
		t[p].tag^=c;
		t[p].state=trans(t[p].state,c);
		return;
	}
	int mid=l+r>>1;
	if(ql<=mid) Xor(ls,l,mid,ql,qr,c);
	if(mid<qr) Xor(rs,mid+1,r,ql,qr,c);
	t[p].state=trans(t[ls].state|t[rs].state,t[p].tag);
}
int ask(int p,int l,int r,int c){
	if(l==r) return l;
	c^=t[p].tag;
	int mid=l+r>>1;
	if(t[ls].state&(1<<c)) return ask(ls,l,mid,c);
	return ask(rs,mid+1,r,c);
}
int solve(){
	if(t[1].state&(1<<6)) return n-ask(1,3,n,6)+1;
	if(t[1].state&(1<<5)) return 1;
	return 0;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>c>>T;
	while(T--){
		cin>>n>>q>>s,s=' '+s;
		for(int i=1;i<=n;++i) a[i]=(s[i]^'0');
		for(int i=n;i>=3;--i) a[i]|=((a[i-1]<<1)|(a[i-2]<<2));
		build(1,3,n);
		ans=solve();
		for(int i=1,l,r;i<=q;++i){
			cin>>l>>r;
			if(l+2<=min(r+2,n)) Xor(1,3,n,l+2,min(r+2,n),4);
			if(max(3,l+1)<=min(r+1,n)) Xor(1,3,n,max(3,l+1),min(r+1,n),2);
			if(max(3,l)<=r) Xor(1,3,n,max(3,l),r,1);
			ans^=(1LL*(i+1)*solve());
		}
		cout<<ans<<endl;
	}
	return 0;
}
  ```

---

## 作者：Day_Tao (赞：2)

大家好，不知道场内还是场外人员前来写题解。

场上最后 $30$ 分钟才看题的，但是没时间细想。不难发现有且仅有 $\texttt{110}$ 或者 $\texttt{101}$ 这两种子串会改变原串。也就是说，我们要求的最终的那个不动点必须满足没有这两个子串。

先考虑只有 $\texttt{110}$ 的情况，操作后将会变为 $\texttt{111}$，可以看作是原先的 $1$ 的长度 $\ge2$ 的连续段向后增加了一个 $1$。但是如果增加到了后面的一个 $1$ 的连续段，那么就会出现 $\texttt{101}$ 的形状，这时我们再来讨论。

考虑 $\texttt{1101}$ 的情况，操作后将会变为 $\texttt{1110}$，可以看作是后一个 $1$ 的连续段的最开头的 $1$ 与前面那个 $0$ 换了个位置。

让我们再来看一个比较普通的情况，整个串的每个 $1$ 的连续段长度都 $\ge2$。根据上面两条结论，请读者自行脑补一个动画：

>在两个 $1$ 的连续段相隔一个 $0$ 以上时，前面一个串将会向后扩张，不断加上一个 $1$；  
>当相隔一个 $0$ 时，这个 $0$ 将会跟后面的那个 $1$ 交换位置，视觉上就是这个 $0$ 向后移了一位，也可以说是前面的 $1$ 的连续串继续扩张，后面那个 $1$ 的连续段整体向后平移了一位。

经过与这样的模拟，我们不难发现其实要到达无法改变的状态（即不动点），取决于最开始的那个 $110$ 在哪。

当然我们还没有考虑只是 $\texttt{101}$ 的情况。如果是 $\texttt{1101}$ 中的，那么随着修改，$\texttt{110}$ 和 $\texttt{101}$ 一定是同时存在的。否则单独的这个东西只可以操作一次，变为 $\texttt{100}$。

综上，我们可以得出的结论是：
- 如果存在 $\texttt{110}$，记这个 $0$ 的位置为 $t$，那么答案就是 $n-t+1$。
- 如果不存在 $\texttt{110}$，若存在 $\texttt{101}$，那么答案为 $1$。
- 否则答案为 $0$。

所以我们只要维护第一个 $\texttt{110}$ 的位置，以及判断 $\texttt{101}$ 是否存在即可。对于前者，我们只需要维护 $1$ 的连续段，找到第一个长度 $\ge2$ 的连续段即可；对于后者，记录区间最靠两端的 $1$ 的位置去做即可。

至于区间反转，再记录一下 $0$ 的情况即可。

码还没写，写完了贴出来，退役久了估计这个题得写个两三个小时的，快进到题解通道关了。

时间复杂度 $\mathcal{O}(n\log n)$。

[广告](https://www.luogu.com.cn/article/qgsgdwf4)

---

## 作者：M1saka16I72 (赞：2)

## 前言

[更可爱的阅读体验](misaka16172.github.io/solution-p13274)

## 思路

题面不太会说人话，先把题面的操作转化成人话。

如果把整个 01 串划分成值相同的连续段，由于经过一次变换后 $s_i$ 只可能变成自己或 $s_{i-1}$，所以只有每个连续段的左端点可能发生变化。设 $i(i\geq 3)$ 为某个连续段的左端点，分类讨论 $s_{i-2},s_{i-1},s_i(s_{i-1}≠s_i)$ 的取值，发现只有 $101,110$ 两种情况会导致 $s_i$ 在一次变换后被翻转。

发现这个规律实际分别等价于，对于每个单个的 $0$，在一次变换后会变成两个 $0$；对于每段非单个（$\geq 2$）的 $1$，在一次变换后会往右扩展一位。

得到人话后我们考虑整个扩展过程需要的最小时间（即题面里的 $k$）怎么求。模拟一下前面的过程，考虑最左边的一段长度 $\geq 2$ 的 $1$，它往右扩展一段时间后会覆盖右边那段 $0$ 产生一个单个的 $0$，剩下的过程就是它推着一个 $0$ 往右走，直到这个 $0$ 被推到 $n$，最后后缀全都变成 $1$ 为止。设这一段 $1$ 的右端点为 $i$，答案即为 $n-i$。若串中存在位置不为 $n$ 的单个的 $0$，则答案为 $\max(n-i,1)$。

线段树维护左右 $0/1$ 的个数、所有连续 $0/1$ 段中最靠左的右端点的值，并记录单个 $0/1$ 的个数即可。这个信息是支持标记下传、左右合并的。

复杂度 $\mathcal{O}(n\log n)$。

---

## 作者：aeiouaoeiu (赞：2)

考虑字符串如何变化，发现本质上只有 $\texttt{101}\to\texttt{xx0},\texttt{110}\to\texttt{xx1}$ 这两种变化（$\texttt{x}$ 表示任意字符）。

手玩一下，发现 $\texttt{101}$ 无法被后续的变换凑出来（后一个 $\texttt{1}$ 必须由 $\texttt{110}$ 得来，而 $\texttt{110}$ 中间的 $\texttt{1}$ 需要左边是 $\texttt{0}$ 才能变为 $\texttt{0}$），而 $\texttt{110}$ 可以用形如 $\texttt{1100}\to\texttt{1110}$ 的方式向右移。

可以得到，每个 $\texttt{110}$ 经过一次变换会向右移动一格，$\texttt{101}$ 经过一轮变化后不会再变化，而其他字符开始时就不会变化。

所以我们只需要维护最左端 $\texttt{110}$ 的位置，以及字串内是否存在 $\texttt{101}$ 即可。

考虑使用线段树维护这个东西，线段树上每个节点维护其管辖区间最左最右端的两个值、是否存在 $\texttt{101}$、最左端 $\texttt{110}$ 的位置，合并是检查区间交界处是否有 $\texttt{110},\texttt{101}$ 产生即可。

注意到区间翻转操作可以使 $\texttt{001}\to\texttt{110},\texttt{010}\to\texttt{101}$，所以还需要维护是否存在 $\texttt{010}$，以及最左端 $\texttt{001}$ 的位置。

实现如上线段树，每次找出整个区间最左端 $\texttt{110}$ 位置作为答案，若不存在 $\texttt{110}$，则若 $\texttt{101}$ 存在答案就为 $1$，否则答案为 $0$。

时间复杂度：$\mathcal{O}(n\log n)$。

---

## 作者：shinzanmono (赞：2)

这是 d2t1？

考虑只有含有 $\tt 110$ 和 $\tt 101$ 子串的串是会有变化的，然后把 $n=10$ 的表打一下发现答案是若存在且第一个 $\tt 110$ 子串中 $\tt 0$ 的位置 $x$ 则答案为 $n-x+1$。否则如果有 $\tt 101$ 那显然只需要一次解决，否则答案为 $0$。

线段树维护翻转前后的左右端点连续段值和长度，不计左右端点连续段的至少连续两个 $\tt 1$ 的最后位置以及是否存在不计端点连续段的，长度为 $1$ 的 $\tt 0$ 连续段即可。翻转操作直接打标记即可。

代码到时候再补。

---

## 作者：CatFromMars (赞：1)

场外奶龙想了 1h 写了 40min（应该不止），给我糖丸了兄弟。

首先发现 $s_i$ 只和 $s_{i - 1}, s_{i - 2}$ 有关，于是考虑 $n = 3$，发现 ```110,101``` 时最后一位会改变。考虑更大的情况，```110``` 的 border 为零看上去似乎互相影响没有那么大，考虑 ```101``` 的重复出现，比如 ```1010101010101```，这样第一次就会全部变成 ```1000000000000```，很好处理。

考虑 ```110```，这似乎有点难，比如 ```110``` 后面跟着很多个 ```0```，那么最后把它变好需要操作 ```0``` 的数目次，再比如 ```11010101```，最后操作也是不断把第一个 ```0``` 变成 ```1```。通过不断地手玩，打个暴力，我们发现一个惊天大秘密，最后它会变成全部是 ```1``` 的状态，而且似乎第一个 ```0``` 会每次不断向右移动一个，直到出去。于是我们大胆猜测，长度为 $n$ 形如 ```110......``` 串的答案其实就是 $(n - 2)$。这很好证明。

考虑归纳法，对于 $n = 3$，显然操作一次即可，对于 $n > 3$，我们只考虑 $(n - 1)$ 次操作那么就会出现 $(n - 1)$ 个 ```1``` 最后跟着一个 ```0```。如果 $(n+1)$ 是 ```1```，那么这个 ```1``` 会变成一个 ```0```，第 $n$ 个数会变成 ```1```，最后三个仍然是 ```110```。如果第 $(n+1)$ 是 ```0``` 那么最后三个就显然是 ```110```。

如果在这个 ```110``` 前面增加一段前缀使得它改变了呢？其实不会的，因为开头的 ```1``` 变了并不影响这一段第 $n$ 次操作后会最后出现一个 ```110```，中间的 ```1``` 则显然不可能改变。

然后你发现这道题找到出现最早的 ```110``` 位置和有没有出现过 ```101``` 就做完了。线段树即可。

```cpp
#include <bits/stdc++.h>
#define il inline
#define ll long long
using namespace std;
const int N = 4e5, inf = 8e5;
il int ls(int x) {
	return 2 * x;
}
il int rs(int x) {
	return 2 * x + 1;
}
int p101[N * 4 + 10], p010[N * 4 + 10], p110[N * 4 + 10], p001[N * 4 + 10];//最早出现位置
int pre[N * 4 + 10], suf[N * 4 + 10];//这个节点最开始两个和最后两个（可能只有 1 个要特判）
int tag[N * 4 + 10];

il bool check1(int x, int y, int z) {
	return ((x % 2) * 4 + y == z);
}
il bool check2(int x, int y, int z) {
	return (x * 2 + y / 2 == z);
}
il void push_up(int now, int s, int t) {
	int mid = (s + t) >> 1;
	if(t - s + 1 == 2)
		pre[now] = suf[now] = pre[ls(now)] * 2 + pre[rs(now)];
	else if(t - s + 1 == 3)
		pre[now] = pre[ls(now)], suf[now] = (pre[ls(now)] % 2) * 2 + suf[rs(now)];
	else pre[now] = pre[ls(now)], suf[now] = suf[rs(now)];

	p110[now] = min(p110[ls(now)], p110[rs(now)]);
	p101[now] = min(p101[ls(now)], p101[rs(now)]);
	p001[now] = min(p001[ls(now)], p001[rs(now)]);
	p010[now] = min(p010[ls(now)], p010[rs(now)]);
	if(t - s + 1 >= 4) {
		if(check1(suf[ls(now)], pre[rs(now)], 6)) p110[now] = min(p110[now], mid);
		if(check2(suf[ls(now)], pre[rs(now)], 6)) p110[now] = min(p110[now], mid - 1);
		if(check1(suf[ls(now)], pre[rs(now)], 5)) p101[now] = min(p101[now], mid);
		if(check2(suf[ls(now)], pre[rs(now)], 5)) p101[now] = min(p101[now], mid - 1);
		if(check1(suf[ls(now)], pre[rs(now)], 1)) p001[now] = min(p001[now], mid);
		if(check2(suf[ls(now)], pre[rs(now)], 1)) p001[now] = min(p001[now], mid - 1);
		if(check1(suf[ls(now)], pre[rs(now)], 2)) p010[now] = min(p010[now], mid);
		if(check2(suf[ls(now)], pre[rs(now)], 2)) p010[now] = min(p010[now], mid - 1);
	}
	else if(t - s + 1 == 3) {
		int r = pre[ls(now)] * 2 + suf[rs(now)];
		if(r == 6) p110[now] = min(p110[now], mid - 1);
		if(r == 5) p101[now] = min(p101[now], mid - 1);
		if(r == 1) p001[now] = min(p001[now], mid - 1);
		if(r == 2) p010[now] = min(p010[now], mid - 1);
	}
}
il void push_tag(int now, int s, int t) {
	if(t - s + 1 == 1) pre[now] = 1 - pre[now], suf[now] = 1 - suf[now];
	else pre[now] = 3 - pre[now], suf[now] = 3 - suf[now];

	tag[now] ^= 1;
	swap(p101[now], p010[now]);
	swap(p001[now], p110[now]);
} 
il void push_down(int now, int s, int t) {
	if(tag[now]) {
		int mid = (s + t) >> 1;
		push_tag(ls(now), s, mid);
		push_tag(rs(now), mid + 1, t);
		tag[now] = 0;
	}
}

int a[N + 10], n, m;
void build(int l, int r, int now) {
	tag[now] = 0;
	p101[now] = p110[now] = p010[now] = p001[now] = inf;
	pre[now] = suf[now] = 0;
	if(l == r) {
		pre[now] = suf[now] = a[l];
		return ;
	}
	int mid = (l + r) >> 1;
	build(l, mid, ls(now));
	build(mid + 1, r, rs(now));
	push_up(now, l, r);
}
void upd(int ql, int qr, int s, int t, int now) {
	if(ql <= s && t <= qr) {
		push_tag(now, s, t);
		return ;
	}
	int mid = (s + t) >> 1;
	push_down(now, s, t);
	if(ql <= mid) upd(ql, qr, s, mid, ls(now));
	if(qr > mid) upd(ql, qr, mid + 1, t, rs(now));
	push_up(now, s, t);
}
il int qry() {
	int ans = 0;
	if(p101[1] != inf) ans = 1;
	ans = max(ans, n - p110[1] - 1);
	return ans;
}

void init() {
	cin >> n >> m;
	for(int i = 1; i <= n; i++) {
		char ch; cin >> ch;
		a[i] = ch - '0';
	}
	build(1, n, 1);

	ll ans = 0;
	ans ^= qry();
	for(int i = 1, l, r; i <= m; i++) {
		cin >> l >> r;
		upd(l, r, 1, n, 1);
		ans ^= (1ll * (i + 1) * 1ll * qry());
	}
	cout << ans << '\n';
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	int c, T; cin >> c >> T;
	while(T--) init();
}
```

---

## 作者：Mr_罗 (赞：1)

这里有一个只需要在线段树上维护 $1$ 个 `int` 和 $14$ 个 `bool` 的做法。

首先注意到 `110` 会复制自身并向后移动一次，也就是说答案下界与第一个 `110` 的位置有关。同时注意到其他情况最多一轮就结束了，因此在有 `110` 的时候我们只需要关注 `110` 即可。

接着考虑没有 `110` 的情况，发现串会改变当且仅当存在 `101` ，只有这时候答案为 $1$ ，其余情况都是 $0$ 。

最后我们只需要在线段树上维护每个节点对应的区间的以下信息：

- 区间长度。
- 区间中是否存在 `110,001,101,010` 。
- 区间是否存在后缀 `11,00,1,0,10,01` 。
- 区间是否存在前缀 `10,01,1,0` 。

需要支持区间 flip，区间查询，线段树二分。

做完了，时间复杂度 $\mathcal O(n+q\log n)$ 。

---

## 作者：mRXxy0o0 (赞：1)

注意到，所有连续段只有段首可能变。枚举可知，对于不动点，有性质：

- $0$ 前 $1$ 段长 $1$。
- $1$ 前 $0$ 段长 $>1$。

由此，可以推出当存在 $0$ 前 $1$ 段长 $>1$ 时，这个 $0$ 会一路推到末尾，步数 $n-p+1$。否则，若存在 $1$ 前 $0$ 段长度为 $1$，步数为 $1$，否则步数为 $0$。

使用线段树维护。

---

## 作者：xyvsvg (赞：1)

提供一个小常数写法，目前洛谷 rk1。

性质是显然的：如果出现了 `110`，则答案一定是 $0$ 到序列末尾的长度。

但是答案可能是 $0$，原因是如果任意两个 $1$ 之间都至少间隔两个 $0$，则 $f^0(S)=S$。

做法很显然：我们维护 `110`，`101` 的个数然后每次线段树上二分即可。因为有修改，我们还需维护 `001` 和 `010` 出现次数。

一开始我是直接用 `string` 维护的，结果最后一个点一直 TLE，于是我一怒一下改成了二进制运算，然后就 rk1 了。


```cpp
typedef array<int,2> A;
A operator+(const A&x,const A&y)
{
    return {x[0]+y[0],x[1]+y[1]};
}
struct Info
{
    array<int,2> c101={0,0},c110={0,0};
    bool tag=0,leaf=0;
    int pref=0,suff=0;
    void ad(int S)
    {
        switch(S)
        {
        case 5:
            ++c101[0];
            break;
        case 2:
            ++c101[1];
            break;
        case 6:
            ++c110[0];
            break;
        case 1:
            ++c110[1];
            break;
        }
    }
    void flip()
    {
        pref^=leaf?1:3;
        suff^=leaf?1:3;
        tag^=1;
        swap(c101[0],c101[1]);
        swap(c110[0],c110[1]);
    }
    void push_up(const Info&o,Info&ret)const
    {
        ret.c101=c101+o.c101,ret.c110=c110+o.c110;
        if(leaf)
        {
            if(o.leaf)
            {
                ret.pref=pref<<1|o.pref;
                ret.suff=suff<<1|o.suff;
            }
            else
            {
                ret.pref=pref<<1|o.pref>>1;
                ret.suff=o.suff;
                ret.ad(pref<<2|o.pref);
            }
        }
        else
        {
            ret.pref=pref;
            ret.suff=o.suff;
            ret.ad(suff<<1|o.pref>>1);
            ret.ad((suff&1)<<2|o.pref);
        }
    }
};
struct SegmentTree
{
    int n;
    vector<Info>sgt;
    constexpr int ls(int p)
    {
        return p<<1;
    }
    constexpr int rs(int p)
    {
        return p<<1|1;
    }
    SegmentTree(int n_,const string&s)
    {
        n=n_;
        sgt.resize(n+10<<2);
        auto build=[&](auto&&self,int p,int l,int r)->void
        {
            if(l+1==r)
                sgt[p].pref=sgt[p].suff=s[l]&1,sgt[p].leaf=1;
            else
            {
                int mid=l+r>>1;
                self(self,ls(p),l,mid);
                self(self,rs(p),mid,r);
                sgt[ls(p)].push_up(sgt[rs(p)],sgt[p]);
            }
        };
        build(build,1,1,n+1);
    }
    inline void push_down(int p)
    {
        if(sgt[p].tag)
        {
            sgt[p].tag=0;
            sgt[ls(p)].flip();
            sgt[rs(p)].flip();
        }
    }
    void modify(int p,int l,int r,int x,int y)
    {
        if(x<=l&&r<=y)
            sgt[p].flip();
        else if(r>x&&l<y)
        {
            push_down(p);
            int mid=l+r>>1;
            modify(ls(p),l,mid,x,y);
            modify(rs(p),mid,r,x,y);
            sgt[ls(p)].push_up(sgt[rs(p)],sgt[p]);
        }
    }
    void modify(int l,int r)
    {
        modify(1,1,n+1,l,r+1);
    }
    int query(int p,int l,int r)
    {
//        cout<<l<<' '<<r-1<<' '<<sgt[p].c110[0]<<endl;
        push_down(p);
        int mid=l+r>>1;
        if(sgt[ls(p)].c110[0])
            return query(ls(p),l,mid);
        if(sgt[ls(p)].leaf&&!sgt[rs(p)].leaf&&(sgt[ls(p)].pref<<2|sgt[rs(p)].suff)==6)
            return mid+1;
        if(!(sgt[ls(p)].leaf||sgt[rs(p)].leaf))
        {
            if((sgt[ls(p)].suff<<1|sgt[rs(p)].pref>>1)==6)
                return mid;
            if(((sgt[ls(p)].suff&1)<<2|sgt[rs(p)].pref)==6)
                return mid+1;
        }
        return query(rs(p),mid,r);
    }
    int query()
    {
        if(sgt[1].c110[0])
        {
            int d=query(1,1,n+1);
            if(n==d)
                return !!sgt[1].c101[0];
            return n-d;
        }
        if(sgt[1].c101[0])
            return 1;
        return 0;
    }
};
```

---

## 作者：bianshiyang (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P13274)

提供一个需要用线段树维护 $17$ 个变量的奶龙做法，赛时切了但是写和调的很痛苦，大概花了 $3\operatorname{h}$？

# 分析
复盘了我赛时的思路，感觉这题出的挺自然的，没有什么难想的点。

## $O(qn^2)$ 
因为一定有 $k\le n$，所以按题意模拟就可以拿到 $30$ 分。

## 特殊性质 A
相当于是一直在对字符串做右移操作，直至字符串是全 $1$ 串就是不动点，所以答案就是 $n-p$，$p$ 可以二分出来所以就做完了。

## $O(qn)$+特殊性质 B
这个时候需要分析一下 $f$ 函数在干什么，手动模拟几组小数据会发现我们可以只考虑局部性质 A，也就是考虑每个形如 $1\cdots10\cdots0$ 的部分，其实只用考虑前缀 $1$ 个数为 $2$ 的串，就是形如 $110\cdots0$ 的串（此处我们假设只有 $1$ 的串也是合法串），我们记符合这样条件的字符串为合法串，此时 $f$ 函数相当于对合法子串进行右移，每个合法子串的答案都可以当成性质 A 来做。

而且我们会发现若字符串出现若干个合法子串，那么我们只需要考虑第一个合法子串即可，因为它的答案不会被更前面的字符的变换所影响，毕竟答案只跟 $1$ 和 $0$ 的分界处有关，而 $1$ 至少是两个所以无论前面是什么都影响不到，另一方面它的答案都大于后面每个合法子串的答案，所以直接取第一个合法字串的答案即可。

此时就会有人有疑问那万一第一个合法子串之前的字符变成“不动的”次数比第一个合法子串的答案要更大怎么办呢？其实我们会发现若一个字符串不存在合法子串，那么此时答案不会超过 $1$。考虑只有字符串中的 $1$ 才可能使得后面的字符发生变换，而每个 $1$ 之后一定是 $0$，那么此时若 $0$ 之后是 $0$ 则这个 $1$ 不会对后面产生任何影响，而如果 $0$ 之后是 $1$ 那么最后的这个 $1$ 就变为 $0$，所以至多变化一次就可以消除除了第一个 $1$ 以外的所有 $1$（第一个 $1$ 前面都是 $0$ 所以一直不变满足条件），而至少变换一次的条件就变成了需要出现 $101$ 这个子串。回到本段开头的问题，那么出现这样的情况就当且仅当字符串在第一个合法子串之前出现了 $101$ 并且第一个合法子串只包含 $1$ 这个字符（也就是形如 $101111$ 的字符串需要特判），一个简单的解决方案是直接对两种情况的答案取 $\max$ 即可。

闲话：笔者开始没有对两者取 $\max$，在 SelfEval 上获得了 $75$ 分，并且无法通过样例 $5$ 的第一组数据，后面又想了一会才想明白。

这样我们就可以 $O(n)$ 求出一个字符串的 $k$ 值，由于 $B$ 性质翻转区间是整个区间所以字符串只有两种形态，故可以归为 $q=2$ 的情形。

## $O(q\sqrt n)$+特殊性质 C
赛时以为如果会了特殊性质 C 就可以拼上回滚莫队做到 $95$ 分，结果发现还有修改显然做不了。

不过特殊性质 $C$ 理应是不难的，因为是否出现合法子串是单调的，顺着扫一遍就做完了。注意每次修改的部分都是一个前缀，所以这个性质是对的，只不过要多记一个 $0$ 为前缀的合法子串位置。

至于分块做法是赛后 [lhy](https://www.luogu.com.cn/user/794083) 告诉我的，貌似块内暴力找合法位置比线段树好实现的多。

## $O(q\log n)$
我们只关注字符串中的第一个连续超过两个 $1$ 的子串结尾位置和是否存在 $101$，而由于有区间翻转操作则还需要存储第一个连续超过两个 $0$ 的子串结尾位置和是否存在 $010$ 即可，这部分用线段树是可以做的，~~但是我的实现相当丑~~。

# 代码实现
对于每个变量都给了注释，不过赛后复盘又打了一遍自己考场上的史山代码~~很难受~~。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=4e5+10;
int C,T,n,q;
ll ans;
char a[N];

//这个结构体是存储0或者1对应的变量，以1为注释，0也是类似的
struct node{
	bool pd,ok;//pd表示是否存在合法串，ok表示是否存在101
	int op,nh,nt;//op表示第一个合法串中第一个0的出现位置，nh表示区间开头连续1的数量，nt表示区间结尾连续1的数量
	void cl(){pd=ok=0;op=nh=nt=0;}//初始化函数
};

struct Seg{
	node c[2];//c[0]存0相关信息，c[1]存1相关信息
	int f,l,r,b1,b2,e2,e1;//f是标记，l和r表示区间的范围，b1、b2表示区间开头两个字符（b1是第一个b2是第二个），e1、e2表示区间结尾两个字符（e1是倒数第一个，e2是倒数第二个），不存在用-1表示
	void cl(){c[0].cl(),c[1].cl(),f=0,b1=b2=e1=e2=-1;}//初始化函数
	void tt(int _b1,int _b2,int _e2,int _e1){b1=_b1,b2=_b2,e2=_e2,e1=_e1;}//赋值函数
	void tag()
	{
		f^=1;
		if(b1!=-1) b1^=1;
		if(b2!=-1) b2^=1;
		if(e2!=-1) e2^=1;
		if(e1!=-1) e1^=1;
		swap(c[0],c[1]);
	}//区间翻转函数
	friend Seg operator+(Seg x,Seg y)
	{
		Seg res;res.cl();
		int len1=x.r-x.l+1,len2=y.r-y.l+1;
		for(int i=0;i<2;i++)
		{
			node &rr=res.c[i];
			node xx=x.c[i],yy=y.c[i];
			if(xx.pd&&xx.op<=x.r) rr.pd=1,rr.op=xx.op;//合法串出现在左边
			else if(xx.nt+yy.nh>1) rr.pd=1,rr.op=y.l+yy.nh;//拼在一起出现合法串
			else if(yy.pd) rr.pd=1,rr.op=yy.op;//合法串出现在右边
			rr.nh=xx.nh+(xx.nh==len1?yy.nh:0);
			rr.nt=yy.nt+(yy.nt==len2?xx.nt:0);
			rr.ok=xx.ok|yy.ok;//左右是否存在101或者010
			if(len1>=2&&x.e2==i&&x.e1==(i^1)&&y.b1==i) rr.ok=1;
			if(len2>=2&&x.e1==i&&y.b1==(i^1)&&y.b2==i) rr.ok=1;//拼在一起是否出现101或010
		}
		if(len1==1)
		{
			if(len2==1) res.tt(x.b1,y.b1,x.b1,y.b1);
			else res.tt(x.b1,y.b1,y.e2,y.e1);
		}
		else
		{
			if(len2==1) res.tt(x.b1,x.b2,x.e1,y.e1);
			else res.tt(x.b1,x.b2,y.e2,y.e1);
		}//这里要分类讨论，因为不一定存在b2和e2
		res.l=x.l,res.r=y.r;
		return res;
	}//区间合并函数
}tr[N<<2];

void pushup(int k)
{
	int f=tr[k].f;
	tr[k]=tr[k<<1]+tr[(k<<1)|1];
	tr[k].f=f;
}

void down(int k)
{
	if(!tr[k].f) return;
	tr[k<<1].tag(),tr[(k<<1)|1].tag();
	tr[k].f=0;
}

void build(int k,int l,int r)
{
	tr[k].cl(),tr[k].l=l,tr[k].r=r;
	if(l==r)
	{
		int ch=a[l]-'0';
		tr[k].b1=tr[k].e1=ch;
		tr[k].c[ch].nh=tr[k].c[ch].nt=1;
		return;
	}
	int mid=(l+r)>>1;
	build(k<<1,l,mid),build((k<<1)|1,mid+1,r);
	pushup(k);
}

void update(int k,int l,int r,int a,int b)
{
	if(a<=l&&b>=r)
	{
		tr[k].tag();
		return;
	}
	down(k);
	int mid=(l+r)>>1;
	if(a<=mid) update(k<<1,l,mid,a,b);
	if(b>mid) update((k<<1)|1,mid+1,r,a,b);
	pushup(k);
}

void solve(int i)
{
	node res=tr[1].c[1];
	int k=0;
	if(res.op) k=max(k,n-res.op+1);
	if(res.ok) k=max(k,1);//记得取max
	ans^=1ll*(i+1)*k;
}

int main()
{
	scanf("%d%d",&C,&T);
	while(T--)
	{
		scanf("%d%d%s",&n,&q,a+1);
		a[n+1]='2';ans=0;
		build(1,1,n);solve(0);
		for(int _i=1,l,r;_i<=q;_i++)
		{
			scanf("%d%d",&l,&r);
			update(1,1,n,l,r);solve(_i);
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：freoepn (赞：0)

可以发现当串内存在 `110` 或 `101` 时就会继续改变，`101` 在一次操作后就会变为 `100` 不再移动，而 `110` 则会变化为 `111` 并将该子串后面的字符变为 $0$，重新出现 `110`，也就是要操作 $0$ 到序列末尾的长度次操作才能不再改变。

考虑用线段树找出 `101` 和出现最早的 `110`，记录线段树上每个节点对应的区间最前面的两个字符和最后面的两个字符，合并的时候判断有没有合并出 `101` 和 `110` 即可。


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int kMaxN = 4000005;
int tr[4 * kMaxN], rt[4 * kMaxN];
char trl[4 * kMaxN], trll[4 * kMaxN], trr[4 * kMaxN], trrr[4 * kMaxN];
bool tr1[4 * kMaxN], rt1[4 * kMaxN], tag[4 * kMaxN];
string a;
int n, q;
void pushup(int x, int y) {
  tr[x] = min(tr[x << 1], tr[x << 1 | 1]);
  rt[x] = min(rt[x << 1], rt[x << 1 | 1]);
  tr1[x] = tr1[x << 1] | tr1[x << 1 | 1];
  rt1[x] = rt1[x << 1] | rt1[x << 1 | 1];
  trl[x] = trl[x << 1], trr[x] = trr[x << 1 | 1];
  trll[x] = (trll[x << 1] == '2' ? trl[x << 1 | 1] : trll[x << 1]);
  trrr[x] = (trrr[x << 1 | 1] == '2' ? trr[x << 1] : trrr[x << 1 | 1]);
  if (trr[x << 1] == '1' && trl[x << 1 | 1] == '0' && trll[x << 1 | 1] == '1') tr1[x] = 1;
  if (trr[x << 1] == '0' && trl[x << 1 | 1] == '1' && trll[x << 1 | 1] == '0') rt1[x] = 1;
  if (trrr[x << 1] == '1' && trr[x << 1] == '0' && trl[x << 1 | 1] == '1') tr1[x] = 1;
  if (trrr[x << 1] == '0' && trr[x << 1] == '1' && trl[x << 1 | 1] == '0') rt1[x] = 1;
  if (trr[x << 1] == '1' && trl[x << 1 | 1] == '1' && trll[x << 1 | 1] == '0') tr[x] = min(tr[x], y + 2);
  if (trr[x << 1] == '0' && trl[x << 1 | 1] == '0' && trll[x << 1 | 1] == '1') rt[x] = min(rt[x], y + 2);
  if (trrr[x << 1] == '1' && trr[x << 1] == '1' && trl[x << 1 | 1] == '0') tr[x] = min(tr[x], y + 1);
  if (trrr[x << 1] == '0' && trr[x << 1] == '0' && trl[x << 1 | 1] == '1') rt[x] = min(rt[x], y + 1);
 // cout << x << " " << tr[x] << " " << rt[x] << " " << trr[x << 1] << " " << trl[x << 1 | 1] << " " << trll[x << 1 | 1] << "!!\n";
}
char flip(char c) {
  return (c == '1' ? '0' : (c == '2' ? '2' : '1'));
}
void up(int x) {
  tag[x] ^= 1;
  swap(tr[x], rt[x]), swap(tr1[x], rt1[x]);
  trl[x] = flip(trl[x]), trll[x] = flip(trll[x]), trr[x] = flip(trr[x]), trrr[x] = flip(trrr[x]);
}
void build(int x, int l, int r) {
  tag[x] = 0;
  if (l == r) {
    tr[x] = rt[x] = n + 1;
    tr1[x] = rt1[x] = 0;
    trl[x] = trr[x] = a[l];
    trll[x] = trrr[x] = '2';
    return;
  }
  int mid = (l + r) >> 1;
  build(x << 1, l, mid), build(x << 1 | 1, mid + 1, r);
  pushup(x, mid);
}
void pushdown(int x) {
  if (tag[x]) {
    tag[x] = 0;
    up(x << 1), up(x << 1 | 1);
  }
}
void change(int x, int l, int r, int ql, int qr) {
  if (ql <= l && r <= qr) {
    up(x);
   // cout << x << " " << l << " " << r << " " << " " << trl[x] << " " << trr[x] << " " << tr[x] << " " << tr1[x] << " " << rt[x] << '\n';
    return;
  }
  int mid = (l + r) >> 1;
  pushdown(x);
  if (ql <= mid) {
    change(x << 1, l, mid, ql, qr);
  }
  if (qr > mid) {
    change(x << 1 | 1, mid + 1, r, ql, qr);
  }
  pushup(x, mid);
 // cout << x << " " << l << " " << r << " " << " " << trl[x]<< " " << trr[x] << " " << tr[x] << " " << tr1[x] << " " << rt[x] << '\n';
}
signed main() {
   ios::sync_with_stdio(0);
   cin.tie(0), cout.tie(0);
  int t;
  cin >> t >> t;
  while (t--) {
    cin >> n >> q;
    cin >> a;
    a = " " + a;
    build(1, 1, n);
    int ans = 0;
    if (tr[1] <= n) {
      ans ^= n - tr[1] + 1;
     // cout << (n - tr[1] + 1) << '\n';
    } else {
      ans ^= tr1[1];
     // cout << tr1[1] << '\n';
    }
    for (int i = 1; i <= q; i++) {
      int l, r;
      cin >> l >> r;
      change(1, 1, n, l, r);
      if (tr[1] <= n) {
        ans ^= (i + 1) * (n - tr[1] + 1);
      //  cout << (n - tr[1] + 1) << '\n';
      } else {
        ans ^= (i + 1) * tr1[1];
      //  cout << tr1[1] << '\n';
      }
    }
    cout << ans << '\n';
  }
  return 0;
}
```

---

## 作者：DengStar (赞：0)

[cnblogs](https://www.cnblogs.com/dengstar/p/19001533)

解决此类问题的第一步一定是**用尽量简洁的方式刻画题目的结构**。对本题，我们要找出字符串 $S$ 在变换 $f$ 下保持不变的条件。

记 $f(S) = T = t_1t_2\dots t_n$。如果 $S = T$，则对所有 $i$，有 $s_i = t_i$。如果 $s_{i - 2} = 0$，那么 $t_i = s_i$，这个条件已经满足。否则 $s_{i - 2} = 0$，此时 $t_{i} = s_{i - 1}$。我们想让 $t_{i} = s_{i}$，所以一定有 $s_{i - 1} = s_{i}$。也就是说，如果 $S$ 保持不变，那么 **$S$ 中的所有 $1$，后面都必须跟着两个相同的字符**。等价的说法是：

> **$S$ 保持不变的充要条件为：不存在 $110$ 或 $101$ 子串。**

现在我们找到了 $S$ 保持不变的充要条件，下一步是研究 $S$ 在经过多少次 $f$ 变化后能满足此条件。如果一开始 $S$ 就没有这两个子串，则答案为 $0$。否则我们分类讨论一下：

1. $S$ 中有 $110$ 子串，没有 $101$ 子串：

   考虑 $110$ 子串第一次出现的位置，这个子串中的 $0$ 的下标为 $p$。设第一个 $110$ 之后出现的字符为 $a$。令 $S \gets f(S)$。由于这是第一个出现的 $110$，且不存在 $101$ 子串，所以对于 $i < p$，$s_i$ 在变化后都不会改变。我们只考虑子串 $110a$ 变化后的结果，有：
   $$
   110a \to b110
   $$
   相当于把第一个 $110$ 的位置向后移了一位，而这次移动并不会导致前面出现 $110$ 或 $101$ 子串$^{\ast}$。最终 $110$ 移动到末尾时，再经过一次变换，$110$ 会变成 $111$，于是 $110$ 子串消失了，$S$ 之后保持不变。因此，在这种情况下，答案为 $110$ 向后移动的次数，即 $n - p + 1$。

   $[\ast]$：严谨证明可能需要一些分类讨论，但打表可以直观地观察到这一点。

2. $S$ 中有 $101$ 子串，没有 $110$ 子串：

   此时 $S$ 中有若干形如 $10101\dots01$ 的子串（可以形式化地记为 $1 + k \cdot01$，其中 $k \cdot 01$ 表示 $k$ 个 $01$ 拼接起来，$k \ge 0$），且这些子串都不挨着，其它地方都为 $0$（否则就存在 $110$ 子串）。简单模拟发现，这些子串经过一次变换后都会变成 $1 + k \cdot 00$，然后不会再变化。所以此时答案为 $1$。

3. $S$ 中同时存在 $110$ 和 $101$ 子串：

   注意到 $110$ 子串向后推的过程实际上不受原位置值的影响，所以 $101$ 完全不影响 $110$ 向后推的过程，此时答案和第一种情况相同。

综上所述，我们计算答案的过程为：

1. 如果存在 $110$ 子串，设第一个 $110$ 子串中 $0$ 的下标为 $p$，则答案为 $n - p + 1$；
2. 否则如果存在 $101$ 子串，答案为 $1$；
3. 否则答案为 $0$。

（这些结论并不难发现，因为每一步的推导都有迹可循。但我赛时注意力没那么好，写了个暴力打表才观察到这些规律，不过打表也不失为一种寻找结论的好方式。）

据此可以写出单次询问 $O(n)$ 的做法。考虑优化。

显然可以考虑线段树。根据求答案的过程，容易看出需要维护区间内是否有 $101$ 子串，是否有 $110$ 子串，以及第一个 $110$ 子串出现的位置。由于有区间翻转操作，还需要对应地维护区间内是否有 $010$ 子串，是否有 $001$ 子串，以及第一个 $001$ 子串出现的位置。为了合并区间，对于所有长度为 $1$ 或 $2$ 的 $01$ 串 $x$，需要维护每个区间是否含有前缀 $x$ 和后缀 $x$。合并时暴力枚举所有情况即可。维护的量比较多，常数略大，且存在一些实现细节。

以下是线段树信息设计的参考代码：

```cpp
struct Info {
    bool f101, f110, f010, f001;
    int l, r, pos1 = INF, pos2 = INF; // pos1 和 pos2 分别为第一个 110 和第一个 001 的位置
    array<bool, 2> p{}, s{}; // 是否存在某个长度为 1 的前/后缀
    array<array<bool, 2>, 2> p2{}, s2{}; // 是否存在某个长度为 2 的前/后缀

    int len() const {
        return r - l + 1;
    }

    friend Info operator + (const Info &A, const Info &B) {
        Info C;
        C.f101 = A.f101 || B.f101 || (A.s[1] && B.p2[0][1]) || (A.s2[1][0] && B.p[1]);
        C.f110 = A.f110 || B.f110 || (A.s[1] && B.p2[1][0]) || (A.s2[1][1] && B.p[0]);
        C.f010 = A.f010 || B.f010 || (A.s[0] && B.p2[1][0]) || (A.s2[0][1] && B.p[0]);
        C.f001 = A.f001 || B.f001 || (A.s[0] && B.p2[0][1]) || (A.s2[0][0] && B.p[1]);
        C.l = A.l, C.r = B.r;
        C.pos1 = min(A.pos1, B.pos1), C.pos2 = min(A.pos2, B.pos2);
        if(A.s[1] && B.p2[1][0]) {
            chmin(C.pos1, A.r + 2);
        }
        if(A.s2[1][1] && B.p[0]) {
            chmin(C.pos1, A.r + 1);
        }
        if(A.s[0] && B.p2[0][1]) {
            chmin(C.pos2, A.r + 2);
        }
        if(A.s2[0][0] && B.p[1]) {
            chmin(C.pos2, A.r + 1);
        }
        for(int x: {0, 1}) {
            C.p[x] = A.p[x], C.s[x] = B.s[x];
            for(int y: {0, 1}) {
                if(A.len() >= 2) {
                    C.p2[x][y] = A.p2[x][y];
                } else {
                    C.p2[x][y] = A.p[x] && B.p[y];
                }

                if(B.len() >= 2) {
                    C.s2[x][y] = B.s2[x][y];
                } else {
                    C.s2[x][y] = A.s[x] && B.s[y];
                }
            }
        }
        return C;
    }

    void apply() {
        // 区间翻转，暴力交换所有的变量
        swap(f101, f010), swap(f110, f001);
        swap(pos1, pos2);
        for(int x: {0, 1}) {
            int nx = x ^ 1;
            if(x < nx) {
                swap(p[x], p[nx]);
                swap(s[x], s[nx]);
            }
            for(int y: {0, 1}) {
                int ny = y ^ 1;
                int a = (x << 1) | y;
                int b = (nx << 1) | ny;
                // 按字典序比较字符串，以免重复交换
                if(a < b) {
                    swap(p2[x][y], p2[nx][ny]);
                    swap(s2[x][y], s2[nx][ny]);
                }
            }
        }
    }
};
```

[完整代码](https://uoj.ac/submission/781674)

总时间复杂度 $O(n + q \log n)$。

---

## 作者：liyixin0514 (赞：0)

# [P13274 [NOI2025] 三目运算符](https://www.luogu.com.cn/problem/P13274)

[更好的阅读体验](https://www.cnblogs.com/wingheart/p/18995325)

## 题意

对于一个长度为 $n$ ($n \geq 3$) 的 01 串 $S = s_1 \ldots s_n$，定义变换 $S' = f(S) = s'_1 \ldots s'_n$ 如下：

$$s'_i = \begin{cases} 
s_i, & i \leq 2, \\
s_i, & i \geq 3 \text{ 且 } s_{i-2} = 0, \\
s_{i-1}, & i \geq 3 \text{ 且 } s_{i-2} = 1.
\end{cases}$$

有 $Q$ 次修改，问初始及每次修改后，要多少次变换之后，再变换时 $S'=S$。

每次修改，对区间 $[l,r]$ 反转（不是翻转）。

多测，$n,q \le 4 \times 10^5$。

## 思路

肯定是先找变换有什么性质/规律。

然后看看怎么快速对一个串串计算答案，最后再考虑怎么在修改时维护答案。

看每一位的变换，如果每一位都不变，整个串串也都不变。每一位的变换可以按照 $s_{i-2}$ 分两类。

- 当 $s_{i-2}=0$ 时，$s_i$ 直接不变。
- 当 $s_{i-2}=1$ 时，$s_i = s_{i-1}$。

感觉要处理的就是 $1$ 了。

手搓一下 `1111000011110000011110` 之类的例子，不难发现只要存在 `11`，后面跟着的 `0` 就会变成 `1`，即 `110` $\to$ `111`。

而且 `110` 前后是什么东西，都不影响它变成 `111`。

其实搓样例也可以，搓一下 `11010` 还可以发现 `101` 也很特殊。`101` 一定可以使得它的第三位变成 `0`。

受到这两个的启发，不妨把所有三位的组合都枚举一下。

因为第三位是否变化，可以仅由前两位完全确定下来。取决于第一位是 $0/1$ 以及第二位是否与第三位相同。

所以第三位改变，确实只有 `101`、`110` 两种情况了。

手搓的过程中不难发现，串串总有一个由 `110` 开始往后一直推 `1` 的趋势。一个 `110` 总是创造出新的 `110`，引起很多推 `1` 的操作。

反观 `101` 第三位变成 `0` 之后并不能引起什么连锁反应。

仔细研究一下，把 `110` 后两位也枚举出来看看情况：

$$
110 \to 111 \to 
\begin{cases}
11100\to 11110 \to 继续\\
11101\to 11110 \to 继续\\
11110\to 继续\\
11111\to \dots
\end{cases}
$$

虽然第 $2$ 种情况中间生成了 `101`，但是马上又消掉了，所以关键在与 `110`。

答案次数取决于 `110` 后面要推多少个 `1` 才结束。

看这个样例：`1101101`。

```
110001100
111001110
111101111
111110111
111111011
111111101
111111110
111111111
```

搓一个类似的，我们可以发现答案取决于第一个 `110` 后面还有多少位。

自己把样例搓完，还能发现 `1010100` $= 1$ 的这种特殊情况。

也就是说，我们要维护第一个 `110` 的位置。就可以维护答案了。

如果没有 `110`，就要维护有没有 `101`。

有区间修改，可以用线段树维护，维护区间左右两位是什么情况，第一个 `110` 的位置，以及有没有 `101`。

维护反转的话，再维护一下 `001` 和 `010` 也维护一下就可以了吧。

## code

感觉代码会很长啊。

还好吧。

```cpp
#include<bits/stdc++.h>
#define sf scanf 
#define pf printf  
#define rep(x,y,z) for(int x=y;x<=z;x++) 
#define per(x,y,z) for(int x=y;x>=z;x--) 
using namespace std;
typedef long long ll;
namespace wing_heart {
    constexpr int N=4e5+7;
    int testid;
    int T;
    int n,q;
    char s[N];
    int a[N];
    ll ans;
    struct node {
        int l12,r12,pos110,pos001;
        bool is101,is010;
        bool tg;
    } tr[N<<2];
    void maketag(int l,int r,node &u) {
        if(r-l+1==1) {
            u.l12=u.l12?0:2, u.r12=u.r12?0:1;
            return;
        }
        u.l12=(~u.l12)&3, u.r12=(~u.r12)&3;
        swap(u.pos001,u.pos110);
        swap(u.is010,u.is101);
        u.tg=!u.tg;
    }
    void pushup(int l,int r,node &u,node &ls,node &rs) {
        if(r-l+1==2) {
            u = {ls.l12|rs.r12,ls.l12|rs.r12,N,N,0,0,0};
            return;
        } 
        if(r-l+1==3) {
            int sum=(ls.l12<<1)+rs.r12;
            u = {ls.l12,((ls.l12&1)<<1)|rs.r12,sum==6?l+1:N,sum==1?l+1:N,sum==5,sum==2,0};
            return;
        }
        int sum=(ls.r12<<2)+rs.l12;
        u.l12=ls.l12, u.r12=rs.r12;
        u.pos001=min(ls.pos001,rs.pos001), u.pos110=min(ls.pos110,rs.pos110);
        u.is010=ls.is010||rs.is010, u.is101=ls.is101||rs.is101;
        if(sum>>1==6) u.pos110=min(u.pos110,(l+r)>>1);
        if((sum&7)==6) u.pos110=min(u.pos110,((l+r)>>1)+1);
        if(sum>>1==1) u.pos001=min(u.pos001,(l+r)>>1);
        if((sum&7)==1) u.pos001=min(u.pos001,((l+r)>>1)+1);
        if(sum>>1==5 || (sum&7)==5) u.is101=1;
        if(sum>>1==2 || (sum&7)==2) u.is010=1;
    }
    void pushdown(int u,int l,int r) {
        if(!tr[u].tg) return;
        int mid=(l+r)>>1;
        maketag(l,mid,tr[u<<1]), maketag(mid+1,r,tr[u<<1|1]);
        tr[u].tg=0;
    }
    void build(int u,int l,int r) {
        tr[u]={0,0,0,0,0,0,0};
        if(l==r) {
            tr[u]={a[l]<<1,a[l],N,N,0,0,0};
            return;
        }
        int mid=(l+r)>>1;
        build(u<<1,l,mid), build(u<<1|1,mid+1,r);
        pushup(l,r,tr[u],tr[u<<1],tr[u<<1|1]);
    }
    void init() {
        rep(i,1,n) a[i] = s[i]=='1' ? 1 : 0;
        build(1,1,n);
    }
    void change(int u,int l,int r,int L,int R) {
        if(l>=L && r<=R) {
            maketag(l,r,tr[u]);
            return;
        }
        int mid=(l+r)>>1;
        pushdown(u,l,r);
        if(L<=mid) change(u<<1,l,mid,L,R);
        if(mid+1<=R) change(u<<1|1,mid+1,r,L,R);
        pushup(l,r,tr[u],tr[u<<1],tr[u<<1|1]);
    }
    void clear() {
        ans=0;
    }
    void main() {
        sf("%d%d",&testid,&T);
        while(T--) {
            sf("%d%d",&n,&q);
            clear();
            sf("%s",s+1);
            init();
            if(tr[1].pos110==N) {
                if(tr[1].is101) ans^=1;
            } else {
                ans^=n-tr[1].pos110;
            }
            rep(i,1,q) {
                int l,r;
                sf("%d%d",&l,&r);
                change(1,1,n,l,r);
                if(tr[1].pos110==N) {
                    if(tr[1].is101) ans^=i+1;
                } else {
                    ans^=1ll*(i+1)*(n-tr[1].pos110);
                }
            }
            pf("%lld\n",ans);
        }
    }
}
int main() {
    #ifdef LOCAL 
    freopen("in.txt","r",stdin);
    freopen("my.out","w",stdout);
    #endif 
    wing_heart :: main();
}
```

---


# [OOI 2024] Almost Certainly

## 题目描述

我们称两个多重集**几乎等价**，如果它们至多有一个元素不同。也就是说，可以通过将第一个多重集中的**至多一个元素**修改为其他值，使得两个多重集完全相同。例如，多重集 $\{1, 1, 2\}$ 与 $\{1, 2, 3\}$ 是**几乎等价**的，$\{1, 1, 1\}$ 与 $\{1, 1, 1\}$ 也是**几乎等价**的，而 $\{1, 2, 3\}$ 与 $\{3, 4, 5\}$ 则不是**几乎等价**的。

有一个叫 Vasya 的男孩非常喜欢这个定义，并立刻想出了相关的问题。

Vasya 有两个数组 $a$ 和 $b$，且对于所有 $i$，都有 $a_i \geq b_i$。Vasya 可以对数组 $a$ 进行如下操作若干次（可以为零次）：选择任意一个下标 $i$（$1 \leq i \leq n$），并将 $a_i$ 减 $1$。数组 $b$ 不发生任何变化。

Vasya 很快就明白了如何通过一系列操作，使得数组 $a$ 和 $b$ 的值组成的多重集**几乎等价**。于是他将问题升级——现在，他想知道对于这两个数组的每一个前缀，最少需要多少次操作，才能使这两个前缀的多重集**几乎等价**。

更具体地说，对于每个 $k$，$1 \leq k \leq n$，Vasya 需要考虑 $a_1, a_2, \ldots, a_k$ 以及 $b_1, b_2, \ldots, b_k$ 这两个前缀，并求出最少需要多少次操作，才能使这两个前缀的多重集**几乎等价**。注意，每个 $k$ 的问题是**独立**解决的。


## 说明/提示

### 说明

以第一个输入样例的第一组数据为例：

- 对于长度为 $1$ 的前缀，无需任何操作。
- 对于长度为 $2$ 的前缀，需要将 $a_1 = 3$ 减 $1$，此时 $a = [2, 4]$，$b = [1, 2]$，两者**几乎等价**。

再看第一个输入样例的第三组数据：

- 长度为 $1$ 的前缀，无需任何操作。
- 长度为 $2$ 的前缀，需要将 $a_2 = 17$ 减 $4$，此时 $a = [11, 13]$，$b = [1, 13]$，两者**几乎等价**。
- 长度为 $3$ 的前缀，需要将 $a_1 = 11$ 减 $1$，$a_3 = 14$ 减 $1$，此时 $a = [10, 17, 13]$，$b = [1, 13, 11]$，两者**几乎等价**。

### 计分方式

本题共六组测试。只有通过该组及其所有依赖组全部测试，才能获得该组分数。部分组不要求通过样例测试。**Offline-evaluation** 表示该组结果仅在赛后可见。

| 组别 | 分值 | 额外约束 | 依赖组 | 备注 |
|:-----:|:------:|:----------------------:|:---------------:|:-------:|
| 0 | 0 | -- | -- | 样例。 |
| 1 | 16 | $N \leqslant 100$ | 0 | -- |
| 2 | 13 | $N \leqslant 500$ | 0, 1 | -- |
| 3 | 24 | $N \leqslant 3000$ | 0--2 | -- |
| 4 | 13 | -- | -- | $a_i < b_{i + 1}$ |
| 5 | 14 | -- | 4 | $a_i \leqslant a_{i + 1},\ b_i \leqslant b_{i + 1}$ |
| 6 | 20 | -- | 0--5 | **Offline-evaluation.** |

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
4
2
3 4
1 2
2
3 4
1 3
3
11 17 14
1 13 10
4
100 11 50 42
30 1 20 5```

### 输出

```
0 1
0 0
0 4 2
0 10 30 48```

## 样例 #2

### 输入

```
3
4
2 4 5 12
1 3 4 10
4
3 5 8 20
1 2 6 7
4
4 4 4 4
1 2 3 4```

### 输出

```
0 1 1 3
0 1 3 6
0 2 3 3```

# 题解

## 作者：chen_zhe (赞：3)

**这是官方题解的 AI 中文翻译。**

**子任务 1.**

对于每一个前缀，枚举所有将要被移除的数字对。之后，从数组中移除它们，并统计使两个数组相等所需的操作次数。操作次数等于第一个数组所有元素之和减去第二个数组所有元素之和。只有当对每个 $i$ 都有 $a_i \geq b_i$ 时，才能使它们相等。该解法的复杂度为 $O(n^4)$。

**子任务 2.**

我们对上一子任务的解法进行优化。我们希望每次从两个数组中各移除一个元素，使得它们之间的差值尽可能大。将两个前缀分别排序。注意到，如果我们可以移除 $a_i$ 和 $b_j$，那么也可以移除 $a_{i-1}$ 和 $b_j$，以及 $a_i$ 和 $b_{j+1}$。因此，我们不需要枚举 $O(n^2)$ 的所有移除对，而是可以枚举第一个数组中的元素，并通过指针移动在第二个数组中寻找对应元素。该解法的复杂度为 $O(n^3)$。

**子任务 3.**

我们进一步优化上一子任务的解法。我们需要更快地判断 $a_i \geq b_i$ 是否成立。为此，需要注意，$b_i$ 只会和 $a_i$ 或 $a_{i+1}$ 进行比较。而且，两个前缀都可以被划分为 $O(1)$ 个区间，每个区间只需进行一种类型的比较。我们可以用前缀和预处理每种比较类型是否成立，这样就能在 $O(1)$ 时间内完成正确性检查。该解法的复杂度为 $O(n^2 \log n)$。

**完整解法的思路**

我们将两个数组视为一组区间 $[b_i, a_i]$。注意，最终答案中 $a_i < b_i$ 的情况一定不会更优。因此，最终答案的结构如下：移除所有 $a_i = b_i$ 的下标。将剩下的数按 $a_i$ 升序排序，此时有 $a_1 \leq a_2 \leq \ldots \leq a_n$ 且 $b_1 < a_1, b_2 < a_2, \ldots, b_n < a_n$。此时，很容易发现需要移除 $a_n$ 和 $b_1$。

那么，为了保证移除 $a_n$ 和 $b_1$ 后仍然合法，区间需要满足什么条件？即 $b_2 \leq a_1, b_3 \leq a_2, \ldots, b_n \leq a_{n-1}$。从区间的角度来看，这意味着这些区间都连成了一个连通块。此时，答案就是所有区间长度之和减去最长连通块的区间长度。

**子任务 4-5.**

由此可以看出，子任务 4 的答案为所有区间长度之和减去最长区间长度。对于第 5 组，需要维护当前的连通块，并在可能时扩展它，同时记下此前最长的连通块长度。

**完整解法**

在完整解法的实现中，我们维护当前的区间连通块。每次处理新前缀时，需要能够将与新区间相交的连通块合并。这些操作可以通过 std::set 容易地实现。该解法的时间复杂度为 $O(n \log n)$。

---


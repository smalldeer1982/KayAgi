# [OOI 2023] Music Festival / 音乐节

## 题目背景

CF1801C

## 题目描述

小男孩维佳非常喜欢听音乐。他一直关注着自己喜欢的乐队，因此知道本周五将有 $n$ 张新专辑发布，第 $i$ 张专辑包含 $k_i$ 首曲目。当然，作为最忠实的粉丝，维佳已经提前听过了所有即将发布的新歌，并且知道第 $i$ 张专辑中第 $j$ 首歌的“酷炫度”为 $a_{i,j}$。

维佳有一个朋友玛莎，他非常希望邀请玛莎一起去参加有他最喜欢乐队出演的音乐节。不过要想让玛莎答应，玛莎需要先体验一下这些新歌。维佳知道，如果玛莎听到的某首歌酷炫度超过她此前听过的所有歌，她就会获得 $1$ 点“印象值”。遗憾的是，专辑只能整张播放，且专辑内歌曲顺序不能改变。

请帮助维佳安排专辑的播放顺序，使得玛莎获得的印象值尽可能大，这样她一定会答应和他一起去音乐节。

## 说明/提示

### 样例解释

在第一个测试样例中，最优的播放顺序是先听第 $4$ 张、再听第 $2$ 张、第 $3$ 张和第 $1$ 张专辑。这样玛莎依次听到的歌曲为：**1**；**7**；**8**, 6；4, **9**, 4, 6, 8。玛莎将获得 $4$ 点印象值。

在第二个测试样例中，应先播放第 $1$ 张专辑，再播放第 $4$ 张，之后第 $2$ 和第 $3$ 张顺序任意。这样玛莎能获得最大印象值，且第 $1$ 和第 $4$ 张专辑的每首歌都能带来印象值，第 $2$ 和第 $3$ 张专辑则不会带来新的印象值。

### 评分说明

本题测试点分为 7 组。只有通过某一组所有测试点，且通过部分之前组所有测试点，才能获得该组分数。有些分组不要求通过样例测试点。

| 组别 | 分值 | $n$ | $k_i$ | $a_{i, j}$ | 必须通过的组 | 备注 |
|:----:|:----:|:---:|:-----:|:----------:|:------------:|:----:|
| 0    | 0    | --  | --    | --         | --           | 样例测试点 |
| 1    | 14   | $n \le 7$ | $\sum k_i \le 1000$ | -- | 0 |  |
| 2    | 9    | --  | --    | $a_{i, j} \le 2$ | -- |  |
| 3    | 12   | --  | --    | $a_{i, j} \le 10$ | 0, 2 |  |
| 4    | 15   | --  | $k_i \le 2$ | -- | -- |  |
| 5    | 13   | $n \le 1000$ | -- | $a_{i, j} \le 1000$ | 0 |  |
| 6    | 13   | $n \le 30\,000$ | -- | $a_{i, j} \le 30\,000$ | 0, 5 |  |
| 7    | 24   | --  | --    | --         | 0--6         |  |

## 样例 #1

### 输入

```
4
5
4 9 4 6 8
1
7
2
8 6
1
1```

### 输出

```
4```

## 样例 #2

### 输入

```
4
2
3 4
2
1 8
2
2 8
2
7 9```

### 输出

```
4```

# 题解

## 作者：Heyg_future (赞：2)

# [OOI 2023] Music Festival / 音乐节
## [题目](https://www.luogu.com.cn/problem/P13530)
## 形式化题意。
给定n个序列。要求将其按一定顺序排列。使最终序列最大地满足题目的上升要求。

## Solution

看到这道题目，首先会想到将每一个序列无用的部分去掉。只留下符合题目条件的部分，这样可以减少计算难度。

如。$[1,2,1,3,5,4]$，变成 $[1,2,3,5]$。

```cpp
	cin>>n ;
	for (int k,i=1;i<=n;i++) {
		cin>>k ;
		for (int x,j=1;j<=k;j++) {
			cin>>x ;
			if (j!=1&&x<=a[i].back()) continue ;
			a[i].push_back (x) ;
		}
	}
```


然后就非常像[跳舞机](https://www.luogu.com.cn/problem/P12247)了，建议去做一下。

因为每一个状态之间都是可以进行转移的，每一个序列的堆叠都与前面几个序列的堆叠有关。所以考虑 DP。但是应该怎么 DP 呢？

考虑前一个和后一个序列是可以重叠的。我们不妨可以把每一个序列拆开成几个区间，**每一个序列的后端点保持不动，枚举改变前端点**，这样就可以做到区间后端点不变。然后匹配其他区间的后端点。

如。$[1,2,3]$，拆成 $[1,2,3]$，$[2,3]$，$[3]$。 

这样就回到了我们所熟悉的情况，使它前面和后面做到不重叠。这样就可以枚举所有的状态。

有如下的转移方程。$f_i$ 表示枚举到第 $i$ 个拆开的区间的答案，$len_i$ 表示区间长度，$l_i$ 和 $r_i$ 表示左右端点。

$$
	f_i=\max_{j=1}^{i-1,r_j<l_i} (len_i+f_j)
$$

总体代码如下。

```cpp
int main () {
	cin>>n ;
	for (int k,i=1;i<=n;i++) {
		cin>>k ;
		for (int x,j=1;j<=k;j++) {
			cin>>x ;
			if (j!=1&&x<=a[i].back()) continue ;
			a[i].push_back (x) ;
		}
	}
	int len ;
	for (int k,i=1;i<=n;i++) {
		len=a[i].size () ;
		for (int v:a[i]) {
			w[++cnt].l=v ;
			w[cnt].r=a[i].back () ;
			w[cnt].len=(len--) ;
		}
	}
	sort (w+1,w+cnt+1,cmp) ;
	for (int i=1;i<=cnt;i++) {
		f[i]=w[i].len ;
		for (int j=1;j<=cnt;j++) {
			if (w[j].r<w[i].l) {
				f[i]=max (f[i],f[j]+w[i].len) ;	
			}
		ans=max (ans,f[i]) ;
		}
	}
	cout<<ans ;
	return 0 ;
}
```
注意，计算之前将区间按左端点从小到大排序，这样才可以按顺序算。

但是这里的时间复杂度是有点超。所以还要进行优化。显然。可以用线段树，线段树在本题中的应用非常简单。只需要进行区间修改和维护最大值即可。

注意特判，$i=1$ 的情况。

如果不会线段树的建议去官方题单里学一下。

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>
#define LL long long
using namespace std;
const int N=200500;
int n,cnt,f[N],ans ;
vector <int> a[N] ;
struct msc {
	int l,r,len ; 
} w[N];
bool cmp (msc a,msc b) {
	return a.l<b.l||
	a.l==b.l && a.r<b.r ;
}
struct AJL {
	int w[N*4],tg[N*4] ;
	#define ls (u*2)
	#define rs (u*2+1)
	#define M (l+r>>1) 
	void pd (int u) {
		if (!tg[u]) return ;
		w[ls]=max (w[ls],tg[u]) ;
		w[rs]=max (w[rs],tg[u]) ;
		tg[ls]=max (tg[ls],tg[u]) ;
		tg[rs]=max (tg[rs],tg[u]) ;
		tg[u]=0 ;
	} 
	void upd (int u,int l,int r,int L,int R,int x) {
		if (l>=L && r<=R) {
			w[u]=max (w[u],x) ;
			tg[u]=max (tg[u],x) ;
			return ;
		}
		pd (u) ;
		if (L<=M) upd (ls,l,M,L,R,x) ;
		if (R>M) upd (rs,M+1,r,L,R,x) ;
		w[u]=max (w[ls],w[rs]) ;
	}
	int cx (int u,int l,int r,int L,int R) {
		if (l>=L && r<=R) {
			return w[u] ;
		}
		pd (u) ;
		int ma=-1 ; 
		if (L<=M) ma=max (ma,cx (ls,l,M,L,R) ) ;
		if (R>M) ma=max (ma,cx (rs,M+1,r,L,R)) ;
		return ma ;
	}
} SGT ; 
int main () {
	cin>>n ;
	int len ;
	for (int k,i=1;i<=n;i++) {
		cin>>k ;
		for (int x,j=1;j<=k;j++) {
			cin>>x ;
			if (j!=1&&x<=a[i].back()) continue ;
			a[i].push_back (x) ;
		}
		len=a[i].size () ;
		for (int v:a[i]) {
			w[++cnt].l=v ;
			w[cnt].r=a[i].back () ;
			w[cnt].len=(len--) ;
		}
	}
	sort (w+1,w+cnt+1,cmp) ;
	for (int i=1;i<=cnt;i++) {
        f[i]=max (w[i].len,f[i-1]) ;
		if (w[i].l<=1) {
            SGT.upd (1,1,N,w[i].r,N,f[i]) ;
            ans=max (ans,f[i]) ;
            continue ;
		}
		f[i]=SGT.cx (1,1,N,1,w[i].l-1 )+w[i].len ;
		SGT.upd (1,1,N,w[i].r,N,f[i]) ; 
		ans=max (ans,f[i]) ;	
	}
	cout<<ans ;
	return 0 ;
}

```
这样即可通过此题。

---

## 作者：chen_zhe (赞：1)

**本题解是官方题解的 AI 中文翻译。**

我们为每张专辑引入“压缩专辑”的概念，即通过删除所有不是其前缀最大值的元素而得到的新专辑。

例如：

对于专辑 $[\textbf{1}, \textbf{4}, 4, 3, \textbf{6}, 5, 6]$，其压缩专辑为 $[1, 4, 6]$。

现在注意到，原问题的解实际上等价于在压缩专辑上的同一问题。原因在于，如果某个元素能提升原专辑的印象分，那么在压缩后也同样能提升，反之亦然。接下来默认所有专辑都已预先压缩。进一步，设 $K = \sum k_i$，$C = \max a_{i, j}$。

**第 1 子任务**  
只需枚举玛莎听专辑的所有顺序，并对每种顺序计算她获得的印象分，取最大值即可。复杂度 $O(n! K)$。

**第 2 子任务**  
可以发现，答案为 $2$ 当且仅当存在压缩专辑 $[1, 2]$，或同时存在压缩专辑 $[1]$ 和 $[2]$，否则答案为 $1$。复杂度 $O(K)$。

**第 5 子任务**  
将所有压缩专辑按最后一个数字升序排列。注意，如果玛莎最后听第 $i$ 张专辑，则所有编号更小的专辑都不会再提供印象分。可以设 $dp_i$ 表示最后听第 $i$ 张专辑时的最大印象分。转移时，$dp_i$ 由 $dp_j$ 递推，需要统计第 $i$ 张专辑中有多少元素大于第 $j$ 张专辑的最大值。用二分查找可以做到 $O(n^2 \log K)$。

**第 3 子任务**  
所有压缩专辑的不同形态不超过 $2^C$ 种。去重后，套用第 5 子任务的做法，复杂度 $O(4^C \log K)$。

**第 4 子任务**  
设 $dp_c$ 表示不含大于 $c$ 的元素时可获得的最大印象分。则 $dp_c$ 等于 $dp_{c-1}$ 或可以加上一个或两个元素（如果 $c$ 是某张专辑的最大元素）。对于所有压缩专辑，可以根据其第一个元素之前的 $dp$ 或 $c-1$ 递推。只需记录每个 $c$ 结束的专辑和每张专辑的首元素即可。复杂度 $O(K)$。

**完整解法**  
综合上面的思想。对于每个 $c$，记录所有包含 $c$ 的专辑编号。按 $c$ 升序遍历，维护每张专辑的 $dp_i$，即不含大于 $c$ 的元素且最后听第 $i$ 张专辑时的最大印象分。对于每个 $c$，若存在专辑 $i$ 包含 $c$，则 $dp_i$ 等于 $dp_i + 1$ 与所有 $dp_j + 1$（$j$ 的最大元素小于 $c$）中的最大值。因为可以选择在本专辑内继续听，或者在听完某张专辑后再听本专辑。可以维护所有最大元素小于 $c$ 的专辑的最大 $dp$，用以加速转移。这样，总复杂度为 $O(K + C)$。

---


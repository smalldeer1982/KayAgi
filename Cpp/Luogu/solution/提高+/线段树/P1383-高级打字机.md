# 高级打字机

## 题目描述

早苗入手了最新的高级打字机。最新款自然有着与以往不同的功能，那就是它具备撤销功能，厉害吧。

请为这种高级打字机设计一个程序，支持如下 $3$ 种操作：

1. `T x`：Type 操作，表示在文章末尾打下一个小写字母 $x$。
2. `U x`：Undo 操作，表示撤销最后的 $x$ 次修改操作。
3. `Q x`：Query 操作，表示询问当前文章中第 $x$ 个字母并输出。请注意 Query 操作并不算修改操作。

文章一开始可以视为空串。

## 说明/提示

对于前 $20\%$ 的数据，$n\le 200$。

对于前 $50\%$ 的数据，保证 Undo 操作不会撤销 Undo 操作。

对于 $100\%$ 的数据，$n\le 10^5$。

## 样例 #1

### 输入

```
7
T a
T b
T c
Q 2
U 2
T c
Q 2
```

### 输出

```
b
c
```

# 题解

## 作者：_121017_ (赞：86)

不懂主席树的看这里~。
------------
所谓主席树，乃**可持久化线段树**。至于为什么叫主席树，是因为发明人名字缩写是 $hjt$ 。

因为主席树要记录历史版本，所以隔壁线段树的 $lazy\_tag$ 就行不通了，于是码量就减少许多。~~以至于很多时候我有种主席树比线段树水的错觉。~~

------------
讲完主席树的定义，我们接下来再来了解主席树的实现，接下来我们看一棵普通线段树，它差不多长这样：
![](https://cdn.luogu.com.cn/upload/image_hosting/igkbj37t.png)

然后我们标记一下每次修改访问的节点：

修改第 $3$ 个节点：
![](https://cdn.luogu.com.cn/upload/image_hosting/4jlgsgid.png)

修改第 $2$ 个节点：
![](https://cdn.luogu.com.cn/upload/image_hosting/t4dunbjs.png)

于是我们可以发现：每次修改只会修改 $log_2n$ 个节点，我们只要新增修改的节点就可以了。

主席树：
![](https://cdn.luogu.com.cn/upload/image_hosting/5yqi3dmg.png)

-----
关于新增节点
-----
我们不妨新增一个 $size$ 数组表示当前子树节点个数，如果 $size[lc]==mid-tree[p].l+1$ ，则表示左子树满了，那么我们直接递归右子树；否则左子树还没满，就递归左子树。

## code：
```cpp
#include<bits/stdc++.h>
#define ri register int
#define int long long
#define lc tree[p].l
#define rc tree[p].r
//懒人砖用表示法
using namespace std;
int m,cnt=1,node;
//cnt表示节点个数，node表示根节点个数
int root[10000001];
struct node{
	int l;
	int r;
	char data;
	int size;
}tree[10000001*4];
//如上
void change(int &p,int pre,int l,int r,char x){
	p=++cnt;
	lc=tree[pre].l;
	rc=tree[pre].r;
	tree[p].size=tree[pre].size;
	tree[p].data=tree[pre].data;
  //先开点，继承上一个根节点
	if(l>r) return;
	if(l==r){
		tree[p].data=x;
		tree[p].size=1;
		return;
	}
	if(tree[lc].size==((l+r)>>1)-l+1) change(rc,tree[pre].r,(l+r)>>1+1,r,x);
	else change(lc,tree[pre].l,l,(l+r)>>1,x);
  //同上
	tree[p].size=tree[lc].size+tree[rc].size;//当前子树的节点总数为左子树加上右子树
}
char ask(int p,int l,int r,int x){
	if(l>=r){
		return tree[p].data;
	}
	if(x<=tree[lc].size){//如果要访问的叶子节点编号小于左子树的节点总数，那么ta肯定在左子树，反之在右子树
		return ask(lc,l,(l+r)>>1,x);
	}else{
		return ask(rc,(l+r)>>1+1,r,x-tree[lc].size);
	}
}
signed main(){
	cin>>m;
	for(ri i=1;i<=m;i++){
		char o,c;
		int x;
		cin>>o;
		if(o=='T'){
			cin>>c;
			++node;
			change(root[node],root[node-1],1,m,c);
		}
		if(o=='U'){
			cin>>x;
			++node;
			root[node]=root[node-x-1];
            //撤销直接新建根节点就行了
		}
		if(o=='Q'){
			cin>>x;
			cout<<ask(root[node],1,m,x)<<endl;
		}
	}
	return 0;
}
```
###  点个赞再走呗~~~。

---

## 作者：星空舞涵 (赞：24)

# 前言
关于这道题，我看题解里很多大佬都是用的主席树，但是身为一个蒟蒻我并不会，所以我选择了树上倍增。
# 正文
我们用f[ i ][ j ]表示j的第2^i个祖先

lian[ i ]表示在第i步修改操作结束后下一次增添的点得父亲的序号

tree[ i ]表示序号为i的节点的字符是什么

fa表示下一个添加的点得父亲，也是目前的叶节点

deep[ i ]表示深度，即第几个字符

对于“T”操作来讲 ：

每进行一次T操作，就增添一个新的节点，有效操作数增加

对于“Q”操作来讲：

每进行一次Q操作，就是找从根节点到叶节点（fa）这一条链上，深度为m的点

对于“U”操作来讲：

每进行一次U操作，就是相当于一次换爹操作，把fa换成lian[ i ] 

大概内容就这些，下面是代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long f[21][1000001],lian[1000001],cnt,fa,l,m,er[21],deep[10000001],n,x;
char a,tree[1000001];
int main()
{
	cin>>n;
	er[0]=1;
	for(int i=1;i<=20;i++)	er[i]=er[i-1]*2;
	for(int i=1;i<=n;i++)
	{
		cin>>a;
		if(a=='T')
		{
			x++;//有效操作+1
			cnt++;//增加新的点 
			cin>>tree[cnt];//点cnt的字符 
			lian[x]=cnt;//这一步结束后下一个点的父亲 
			f[0][cnt]=fa;//自己的父亲 
			deep[cnt]=deep[fa]+1;
			for(int i=1;i<=20;i++)f[i][cnt]=f[i-1][f[i-1][cnt]];
			fa=cnt;//下一个点的父亲是自己吧 
		}
		if(a=='P')
		{
			cin>>m; 
			int r=fa;
			for(int i=20;i>=0;i--)
			{
				if(deep[r]-er[i]>=m)
				{
					r=f[i][r];
				} //能跳就跳 
				if(deep[r]==m)
				{
					cout<<tree[r]<<endl;
					break;
				}	
			}
		}
		if(a=='U')
		{
			cin>>m;
			x++;
			lian[x]=lian[x-m-1]; 
			fa=lian[x];
		} 
	}
} 
```
~~第一次交题解希望通过~~

---

## 作者：lukelin (赞：18)

**前言**  
之前有人在讨论区里发主席树过不了，然而其实是珂以过的   
  
**题解**   
这道题一看就珂以用主席树啊  
这是一道神奇的题目，那么我们先敲一个主席树，然后维护一个数组len，表示下一次应该在len + 1插入，   
之后对于T操作，在上一个版本的len + 1上直接执行插入  
对于Q操作，直接查询   
对于U操作，直接找到对应版本复制即可  
```cpp
rt[rt_num] = rt[((rt_num - num - 1) > 0 ? (rt_num - num - 1) : 0)];
ls[rt_num] = ls[((rt_num - num - 1) > 0 ? (rt_num - num - 1) : 0)], rs[rt_num] = rs[((rt_num - num - 1) > 0 ? (rt_num - num - 1) : 0)];
len[rt_num] = len[rt_num - num - 1];
``` 

**代码**  
```cpp
#include <cstdio>
#include <iostream>
#define ll long long

using namespace std;

ll read(){
    ll x = 0; int zf = 1; char ch = ' ';
    while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
    if (ch == '-') zf = -1, ch = getchar();
    while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf;
}

int s[20000005];
int ls[20000005], rs[20000005];
int len[20000005];
int rt[20000005], pre[20000005];
int tot;

inline void a(int pos){
    s[pos] = s[ls[pos]] + s[rs[pos]];
}

inline int getNew(){
    return (++tot);
}

void build(int pos, int l, int r){
    if (l == r){
        if (pos > tot)
            tot = pos;
        s[pos] = 0;
        return ;
    }
    int mid = (l + r) >> 1;
    ls[pos] = pos << 1, rs[pos] = (pos << 1) + 1;
    build(pos << 1, l, mid);
    build((pos << 1) + 1, mid + 1, r);
    a(pos);
}

int query(int pos, int l, int r, int k){
    if (l == r)
        return s[pos];
    int mid = (l + r) >> 1;
    if (k <= mid)
        return query(ls[pos], l, mid, k);
    else
        return query(rs[pos], mid + 1, r, k);
}

void add(int pos, int pre, int l, int r, int k, int val){
    if (l == r){
        s[pos] = val;
        return ;
    }
    int mid = (l + r) >> 1;
    if (k <= mid){
        rs[pos] = rs[pre]; ls[pos] = getNew();
        add(ls[pos], ls[pre], l, mid, k, val);
    }
    else{
        ls[pos] = ls[pre]; rs[pos] = getNew();
        add(rs[pos], rs[pre], mid + 1, r, k, val);
    }
    a(pos);
}

int main(){
    freopen("type.in", "r", stdin);
    freopen("type.out", "w", stdout);
    int q;
    q = read();
    rt[0] = 1, len[0] = 0;
    build(rt[0], 1, 100000);
    char op; int num; int rt_num = 0;
    for (int i = 1; i <= q; ++i){
        cin >> op;
        if (op == 'T'){
            char c; cin >> c;
            rt[++rt_num] = getNew();
            len[rt_num] = len[rt_num - 1] + 1;
            add(rt[rt_num], rt[rt_num - 1], 1, 100000, len[rt_num], (int)(c));
        }
        else if (op == 'Q'){
            num = read();
            printf("%c\n", (char)(query(rt[rt_num], 1, 100000, num)));
        }
        else if (op == 'U'){
            num = read(), ++rt_num;
            rt[rt_num] = rt[((rt_num - num - 1) > 0 ? (rt_num - num - 1) : 0)];
            ls[rt_num] = ls[((rt_num - num - 1) > 0 ? (rt_num - num - 1) : 0)], rs[rt_num] = rs[((rt_num - num - 1) > 0 ? (rt_num - num - 1) : 0)];
            len[rt_num] = len[rt_num - num - 1];
        }
    }
    fclose(stdin);
    fclose(stdout);
    return 0;
}
``` 

---

## 作者：king_xbz (赞：17)

主席树这东西代码太长，不是很好调。所以我选择使用__gnu_cxx中的**rope**来解决。题解区已经有一篇rope+树状数组的题解了，所以我将给大家带来**rope详细介绍+裸的指针rope实现可持久化代码**。

这是你没有见过的~~船新版本~~，快来体验吧
### 什么是rope

rope是一种底层为平衡树的可持久化操作数据结构。

### rope怎么操作

**使用rope需要使用新的头文件与空间**：

```cpp
#include<ext/rope>
using namespace __gnu_cxx;
```

该namespace不被std包含，该头文件也不被万能头包含，需要在代码中**分别使用**。

**rope常与指针相伴**：
定义方法

```cpp
rope<char> *now[p];
```

**如何申请更新一个新的可持久化版本**：

```cpp
now[0]=new rope<char>();
```

**如何继承版本**

```cpp
now[cnt]=new rope<char>(*now[cnt-1]);
```

**访问第num个版本**

```cpp
ans=now[cnt]->at(num);
```

**在末尾添加元素str**

```cpp
now[cnt]->push_back(str);
```

**在pos插入元素x**

```cpp
now[cnt]->insert(pos,x);
```

**从pos开始删除x个元素**

```cpp
now[cnt]->erase(pos,x);
```

**将从pos开始len个元素替换为x**

```cpp
now[cnt]->copy(pos,len,x);
```

**从pos开始换成b**

```cpp
now[cnt]->replace(pos,b)
```

**从pos开始提取s个**

```cpp
now[cnt]->substr(pos,s);
```

复杂度$n \sqrt n$



# 具体实现
- 对于T操作，我们构建新版本（从上一个版本继承），并压入字符

- 对于U操作，我们继承之前第num个版本作为新版本继承

- 对于Q操作，我们查询之前第num个版本并输出

完整代码：
```cpp
#include<bits/stdc++.h>
#include<ext/rope>
using namespace std;
using namespace __gnu_cxx;
const int p=5794385;
int cnt;
rope<char> *now[p];
int main()
{
	int n;
	cin>>n;
	char op,str;
	int num;
	now[0]=new rope<char>();
	for(int i=1;i<=n;i++)
	{
		cin>>op;
		if(op=='T')
		{
			cin>>str;
			cnt++;
			now[cnt]=new rope<char>(*now[cnt-1]);
			now[cnt]->push_back(str);
		}
		if(op=='U')
		{
			cin>>num;
			cnt++;
			now[cnt]=new rope<char>(*now[cnt-num-1]);
		}
		if(op=='Q')
		{
			cin>>num;
			cout<<now[cnt]->at(num-1)<<endl;
		}
	}
	return 0;
}
```
最后，祝大家AC愉快。

**末尾彩蛋**：还有双倍经验可以拿哟（略有不同）：[IOI2012 scrivener](https://www.luogu.com.cn/problem/P6166)

---

## 作者：Isonan (赞：11)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P1383)

我当初看到这道题的时候还兴奋了半天，以为撤销操作只要撤销一些字符就可以了，哪知撤销操作还可以撤销之前的撤销操作。

所以其实是用主席树维护。每次撤销操作相当于把当前的根置为num步以前的根。

代码：

```cpp
#include <cstdio>

int root[100001],lson[4000001],rson[4000001],cnt=1,size[4000001],tem,n,o;
char ch,opt,val[4000001];
void add(int &pos,int pre,char ch,int l,int r){
    pos=(++o),lson[pos]=lson[pre],rson[pos]=rson[pre],size[pos]=size[pre],val[pos]=val[pre];
    if(l==r){
        val[pos]=ch;
        size[pos]=1;
        return;
    }
    if(size[lson[pos]]==((l+r)>>1)-l+1)add(rson[pos],rson[pre],ch,((l+r)>>1)+1,r);
    else add(lson[pos],lson[pre],ch,l,(l+r)>>1);
    size[pos]=size[lson[pos]]+size[rson[pos]];
}
char query(int root,int l,int r,int x){
    if(l==r)return val[root];
    if(size[lson[root]]>=x)return query(lson[root],l,(l+r)>>1,x);
    else return query(rson[root],((l+r)>>1)+1,r,x-size[lson[root]]);
}
void get(char &ch){
    ch=getchar();
    while((ch<'a'||ch>'z')&&(ch<'A'||ch>'Z'))ch=getchar();
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        get(opt);
        if(opt=='T')get(ch),++cnt,add(root[cnt],root[cnt-1],ch,1,n);
        else if(opt=='U')scanf("%d",&tem),++cnt,root[cnt]=root[cnt-tem-1];
        else scanf("%d",&tem),printf("%c\n",query(root[cnt],1,n,tem));
    }
}
```

---

## 作者：芬特 (赞：8)

前50分栈模拟非常好想，先给出100分ac离线做法，我们可以使用前向星法建立一个邻接链表，把所有操作下的情况强行建一个版本，然后每次遇到undo操作就把邻接链表的指针向上指x个版本，这样可以使用一个搜索从上搜下去，然后按照输入的query命令将答案放到一个数组里，最后输出这个数组


说起来容易，实现过程很重要，建议自己手打一遍，代码如下：

```cpp
#include<stdio.h>
#include<iostream>
#include<vector>
#define rep(i,n) for(int i=0;i<n;i++)
using namespace std;
const int maxn=100010;
int n,q,x,v,sz,tot;
int father[maxn],head[maxn],Next[maxn],point[maxn];
int ans[maxn];
char ch,a[maxn],sk[maxn];

vector <int> maint[maxn];

void Ins(int u,int v)
{
    Next[++sz]=head[u];head[u]=sz;point[sz]=v;
}
void Type()
{
    scanf("%s",&ch);
    a[tot]=ch;
    tot++;
    father[tot]=tot-1;

}
void Undo()
{
    scanf("%d",&x);
    tot++;
    Ins(tot-x-1,tot);
    father[tot]=tot-x-1;
}
void Query()
{
    scanf("%d",&x);
    maint[tot].push_back(q);
    ans[q++]=x;
}

void init()
{
    tot=x=0;
    for(x=0;;)
    {
        if (head[x])
        {
            v=point[head[x]];
            head[x]=Next[head[x]];
            x=v;continue;
        }
        if (a[x])
        {
            sk[++tot]=a[x];
            a[x]=0;
            x++;continue;
        }
        rep(i,maint[x].size())
        {
            v=maint[x][i];
            ans[v]=sk[ans[v]];
        }
        if (father[x]+1==x) tot--;
        if (!x) return;
        x=father[x];
    }
}
int main()
{
    //freopen("type.in","r",stdin);
    //freopen("type.out","w",stdout);
    scanf("%d\n",&n);
    rep(i,n)
    {
        scanf("%s",&ch);
        switch (ch)
        {
            case 'T':Type();break;
            case 'U':Undo();break;
            case 'Q':Query();break;
        }
    }
    init();
    rep(i,q) printf("%c\n",ans[i]);
    return 0;
}
```
IOI挑战可以用主席树做，但是并不会……


---

## 作者：cyffff (赞：7)

# P1383 高级打字机
#### [_传送门_](https://www.luogu.com.cn/problem/P1383)
## 思路
看到一道可持久化的字符串操作题，我立马打了一个叫做`rope`的数据结构。机房dalao说这是一个用可持久化红黑树实现的数据结构，我们先来学习一下`rope`的用法。

首先要使用`rope`，需要加上一下两行：
```cpp
#include<ext/rope>
using namespace __gnu_cxx;
```

然后我们可以定义一个字符串类型的`rope`，叫做`crope`，要这样定义：

```cpp
crope now;
crope s[10];
```

`crope`支持的操作：

- `a.push_back(x)`：在`crope a`的末尾增加字符串`x`
- `a.insert(k,x)`：在`a`的第`k`个字符后加入字符串`x`
- `a.erase(k,x)`：在`a`的第`k`个字符后删除`x`个字符
- `a.replace(k,x)`：将`a`的第`k`个字符后`x`的长度个字符删除，并插入`x`
- `a.substr(k,x)`：获取`a`的第`k`个字符后的长度为`x`的字符串
- `a.at(k)`：获取`a`的第`k`个字符（从0开始）

我们可以拿一个数组来保存历史版本（反正不卡空间），每次读入操作，执行操作，保存到第$V$个历史版本中。

- 对于操作$T$，我们可以使用`push_back`（或`insert`）
- 对于操作$U$，我们可以直接回退到$V-x$的版本
- 对于操作$Q$，我们可以使用`at`（或`substr`）

`crope`为什么可以通过此题呢？机房的dalao说它的复制操作是$O(log\enspace n)$的，可以较轻松地实现可持久化。

~~所以这种算法可以轻松水过IOI难度~~

上AC代码~
```cpp
#include<bits/stdc++.h>
#include<ext/rope>//头文件
using namespace __gnu_cxx;
using namespace std;
const int N=1e5+10;
crope now,x[N];//定义crope，保存现在的串与历史版本
int t,p,V;
inline char read(){
	char ch=getchar();
	while((ch>'U'||ch<'Q')&&(ch>'z'||ch<'a')){
		ch=getchar();
	}
	return ch;
}
inline void solve(){//操作
	char opt=read();
	switch(opt) {
		case 'T': {//T操作
			char q=read();
			now.insert(p,q);
			p++;
			x[++V]=now;
			break;
		}
		case 'U': {//U操作
			int q;
			scanf("%d",&q);
			now=x[V-q];
			x[++V]=now;
			break;
		}
		case 'Q': {//Q操作
			int q;
			scanf("%d",&q);
			putchar(now.at(q-1));
			puts("");
			break;
		}
	}
}
signed main() {
	scanf("%d",&t);
	while(t--) {
		solve();
	}
	return 0;
}
```
最后送出[ $\textcolor{#000000}{双倍经验}$ ](https://www.luogu.com.cn/problem/P6166)

再见qwq

---

## 作者：Strelitzia (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P1383)

----

其实如果没有 $\text{Undo}$ 撤销 $\text{Undo}$ 操作的话，就是一个栈模拟~~但这里有啊~~。

看到有撤销操作，基本上可以想到用主席树，但这个主席树是不定长的。

也就是字符串长度不定，所以不能直接知道文章末尾在哪。

所以我们可以维护一个 $\text{len[i]}$ 表示在第 $\text{i}$ 个历史版本的字符串长度。

但长度不定还有一个问题，边界不知道啊，但这个 $\text{n}$ 非常小，

所以直接将区间置为 $\text{[1,n]}$ ，这个字符串没有初始值，都不需要建树的。

注意：撤销后的历史版本是 $\text{cnt - x - 1}$，不是 $\text{cnt - x }$，因为 $\text{cnt}$ 先是自加过的。

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

template<typename T>void read(T &x) {
    T f = 1;x = 0;char s = getchar();
    while(s < '0' || s > '9') {if(s == '-')f = -1;s = getchar();}
    while(s >= '0' && s <= '9') {x = x * 10 + s - '0';s = getchar();}
    x *= f;
}
template<typename T>void print(T x) {
    if(x < 0) putchar('-'),x = -x;
    if(x > 9) print(x / 10);
    putchar(x % 10 + '0');
}

const int maxn = 15000005;
int n,m,a[maxn];
int l[maxn],r[maxn],val[maxn],root[maxn],len[maxn],tot;

int newnode(int now) {
	l[++ tot] = l[now];
	r[tot] = r[now];
	val[tot] = val[now];
	return tot;
}

int build(int b,int e,int k) {
	k = ++ tot;
	if (b == e) {
		val[k] = a[b];
		return k;
	}
	int mid = b + e >> 1;
	l[k] = build(b,mid,l[k]);
	r[k] = build(mid + 1,e,r[k]);
	return k;
}

int update(int b,int e,int k,int x,int y) {
	k = newnode(k);
	if (b == e) val[k] = y;
	else {
		int mid = b + e >> 1;
		if (x <= mid) l[k] = update(b,mid,l[k],x,y);
		else r[k] = update(mid + 1,e,r[k],x,y);
	}
	return k;
}

int query(int b,int e,int k,int x) {
	if (b == e) return val[k];
	else {
		int mid = b + e >> 1;
		if (x <= mid) return query(b,mid,l[k],x);
		else return query(mid + 1,e,r[k],x);
	}
}

int main () {
	read(n);
	char str[2],s[2];
	int x,cnt = 0;
	for (int i = 1 ; i <= n ; ++ i) {
		scanf("%s",str);
		if (*str == 'T') {
			scanf("%s",s);
			++ cnt;
			len[cnt] = len[cnt - 1] + 1;
			root[cnt] = update(1,n,root[cnt - 1],len[cnt],s[0]);
		}
		if (*str == 'U') {
			read(x);
			++ cnt;
			root[cnt] = root[cnt - x - 1];
			len[cnt] = len[cnt - x - 1];
		}
		if (*str == 'Q') {
			read(x);
			printf("%c\n",query(1,n,root[cnt],x));
		}
	}
	return 0;
}
```

---

## 作者：Tgotp (赞：4)

这题的IOI挑战就是可持久化结构；

在线的实现用主席树就好了；

undo就是追溯过去sz-1-x的版本（其本身也算作一个版本）；

而query就是从上次的版本找到第x个；

至于add就是新建立一个版本，并且在起相应位置插入当前的字符c；

代码仅供参考。

c++代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N = 1e6 + 1;
int n,sz,tot,root[N],ls[N],rs[N],len[N];
char s[N];
inline void read(int&x)
{
    char c = getchar();
    do{
        x = x*10 + c - '0' ;c=getchar();
    }while(c <= '9' && c >= '0');
}
inline void update(int x,int&y,int l,int r,int pos,char c)
{
    y = ++tot;
    if(l == r){ s[y] = c; return ;}
    int mid = l+r>>1;
    ls[y] = ls[x];rs[y]=rs[x];
    if(pos <= mid) update(ls[x],ls[y],l,mid,pos,c);
    else update(rs[x],rs[y],mid+1,r,pos,c);
}
inline void Q(int x,int l,int r,int pos)
{
    if(l == r){ printf("%c\n",s[x]);return ;}
    int mid = l+r >> 1;
    if(pos <= mid) Q(ls[x],l,mid,pos);
    else Q(rs[x],mid+1,r,pos);
}
int main()
{
    read(n);
    for(int i = 1;i<=n;i++)
    {
        int x=0;char c;
        for(c = getchar();c != 'Q' && c != 'T' && c!='U' ;c=getchar());
        getchar();
        if(c == 'Q'){ read(x);Q(root[sz],1,n,x); }
        else if(c == 'U') {
            read(x);
            sz++;
            len[sz] = len[sz-x-1];
            root[sz] = root[sz-x-1];
        }
        else if(c == 'T')
        {
            c=getchar();
            sz++;len[sz] = len[sz-1] + 1;
            update(root[sz-1],root[sz],1,n,len[sz],c);
        }
    }
    return 0;
}

```

---

## 作者：GaryZhong (赞：3)

# 高级打字机 题解

---
属于比较裸的可持久化数据结构题。

我的做法是使用主席树，主席树可以解决对一个数列（或什么别的数据结构）进行如下操作的问题：

1.修改某个历史版本，并将修改完的版本作为新的版本。

2.询问某个历史版本上的值。

题目要求维护文章的第x个字符，我们知道在主席树中，叶子节点记录的就是某一个位置的数据，于是T操作可以通过修改一条链然后新建版本实现。

那么U操作呢？设新建的版本标号为ver，那么撤销最后x次操作也就是回到标号为ver-x-1的版本，将ver版本的根设为ver-x-1的根即可。

这么一来，Q操作就好做了，也就是询问x位置的值是什么，一路递归至叶子结点即可。

代码：

```cpp
#include <cstdio>
#include <cstring>

const int N = 100007;

int q, t, cnt = 0, tot = 0;
char c;

int len[N];

struct Tree
{
    int rt[N], lson[N << 5], rson[N << 5];
    char val[N << 5];

    void build(int &rt, int fa, int l, int r, int po)
    {
        if (!rt)
            rt = ++tot; //动态开点
        if (l == r)
        {
            val[rt] = c; //设置叶子结点值
            return;
        }
        int mid = (l + r) >> 1;
        if (po <= mid)
            rson[rt] = rson[fa], build(lson[rt], lson[fa], l, mid, po);
        if (mid + 1 <= po)
            lson[rt] = lson[fa], build(rson[rt], rson[fa], mid + 1, r, po);
    }

    char qry(int rt, int l, int r, int po)
    {
        if (l == r)
            return val[rt]; //返回叶子结点的值
        int mid = (l + r) >> 1;
        if (po <= mid)
            return qry(lson[rt], l, mid, po);
        if (mid + 1 <= po)
            return qry(rson[rt], mid + 1, r, po);
    }
} tree;

int main()
{
    scanf("%d", &q);
    while (q--)
    {
        scanf(" %c", &c);
        if (c == 'T')
        {
            scanf(" %c", &c);
            len[++cnt] = len[cnt - 1] + 1; //新加一个字符，长度增加
            tree.build(tree.rt[cnt], tree.rt[cnt - 1], 1, N, len[cnt]);
        }
        else if (c == 'U')
        {
            scanf("%d", &t);
            len[++cnt] = len[cnt - t - 1]; //长度和cnt - t - 1长度相等
            tree.rt[cnt] = tree.rt[cnt- t - 1];
        }
        else
        {
            scanf("%d", &t);
            printf("%c\n", tree.qry(tree.rt[cnt], 1, N, t)); //询问叶子结点的值
        }
    }
    return 0;
}
```

---

## 作者：Jμdge (赞：2)

才发现这是道主席树水题...



$O(n\log n)$ 轻松水过$QAQ$

那么...

对于 T 操作，我们只需要新建一个版本，继承上一个版本的大部分信息，并在结尾处修改一个字符信息即可

对于 U 操作，我们只需要新建一个版本，继承向前数第 x 个版本的信息即可(还是那句话，引起可持久化的罪魁祸首倒是容易解决)

对于 Q 操作，我们直接查询当前版本的第 x 个字符输出即可


代码如下：

```cpp
//by Judge(压行狂魔)
#include<iostream>
#include<cstdio>
#define mid (l+r>>1)
using namespace std;
const int M=1e5+11;
inline int read(){  //读数字
	int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
}
inline char cread(){  //读字符(一行秒)
	char c=getchar(); while(!isalpha(c)) c=getchar(); return c;
}
int n,siz,cnt,rt[M],L[M<<5],R[M<<5],len[M]; char s[M<<5]; //事实上这里不一定要用 32 倍空间，（因为题目中还有撤销、询问这两个操作的限制），但是主席树空间往大了开没错
void update(int& now,int las,int l,int r,int pos,char c){  //类(jiu)似(shi)主席树的操作
	now=++cnt; if(l==r) return (void)(s[now]=c);
	if(pos<=mid) R[now]=R[las], update(L[now],L[las],l,mid,pos,c);
	else L[now]=L[las], update(R[now],R[las],mid+1,r,pos,c);
}
int query(int now,int l,int r,int pos){ //询问位置 pos 上的字符
	if(l==r) return s[now];
	if(pos<=mid) return query(L[now],l,mid,pos);
	else return query(R[now],mid+1,r,pos); 
}
int main(){ //主函数非常简短(压行的副产品...好吧我还是换换行吧)
	int n,x,i; char c,opt;
	for(i=1,n=read();i<=n;++i)
	switch(opt=cread()){
		case 'T':
        	c=cread(),len[++siz]=len[siz-1]+1,
            update(rt[siz],rt[siz-1],1,n,len[siz],c); break;
		case 'U':
        	x=read(),len[++siz]=len[siz-x-1],
            rt[siz]=rt[siz-x-1]; break;
		case 'Q':
			printf("%c\n",query(rt[siz],1,n,x=read())); break;
	} return 0;
}
```

---

## 作者：筱影志 (赞：2)

@楼下: 这才是过度依赖STL的正确姿势


好像大家都说IOI挑战需要主席树才能AC...(虽然我也这么觉得)

但这题用 **STL::rope** 完全可以


```cpp
#include <stdio.h>
#include "ext/rope"
#include "algorithm"
using namespace std;
using namespace __gnu_cxx;

const int N=1e+5 +4;

int n;
int d[N];
rope<char> *mem[N];

inline int lowbit(int x)
{
    return x&-x;
}

inline void update(int x)
{
    while(x<=n)
    {
        d[x]++;
        x+=lowbit(x);
    }
}

inline int get(int x)
{
    int res=0;
    while(x)
    {
        res+=d[x];
        x-=lowbit(x);
    }
    return res;
}

inline char getC()
{
    char ch=getchar();
    while(!isalpha(ch))
        ch=getchar();
    return ch;
}

int main()
{
#ifndef ONLINE_JUDGE
    freopen("type.in","r",stdin);
    freopen("type.out","w",stdout);
#endif
    scanf("%d",&n);
    mem[0]=new rope<char>();
    for(int i=1,x;i<=n;i++)
    {
        mem[i]=new rope<char>(*mem[i-1]);
        char c=getC();
        if(c=='T')
        {
            char x=getC();
            mem[i]->push_back(x);
            update(i);
        }
        else if(c=='U')
        {
            update(i);
            scanf("%d",&x);
            int l=1,r=i,now=get(i);
            while(l<r)
            {
                int mid=(l+r)>>1;
                if(now-get(mid)>x)
                    l=mid+1;
                else
                    r=mid;
            }
            mem[i]=mem[l-1];
        }
        else if(c=='Q')
        {
            scanf("%d",&x);
            putchar(mem[i]->at(x-1));
            puts("");
        }
    }
    return 0;
}

```

注意这句


```cpp
mem[i]=new rope<char>(*mem[i-1]);

```

就是这一句可以实现O(1)的拷贝历史版本，由于rope的底层是平衡树，copy时copy根节点就行了

用它就可以轻松实现可持久化数组


---

## 作者：Minclxc (赞：2)

对于200%数据需要一个可持久化数据结构，这里选择了可持久化栈（当然你要可持久化线段树也行，就是难写）

大概就是一棵树，从根节点到每个节点的路径就是当前节点代表的数组

对于T操作就在当前节点下插入一个新节点，对于U操作就把当前节点指向前x个操作的节点

对于离线Q操作，可以建树后DFS，效率O(n)，对于在线Q操作，就是在每个T操作建倍增的寻祖数组，然后Q操作时倍增找祖先

对于样例建的图如下，点的数字代表每个操作指向的节点(如果被水印遮住的话，左下角字是c3)

 ![](https://cdn.luogu.com.cn/upload/pic/9245.png) 

离线代码

```cpp
#include<cstdio>
using namespace std;
#define fo(a,b,c) for(int a=b;a<=c;a++)
int read(){
    int a=0,f=0;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')f=1;
    for(;c>='0'&&c<='9';c=getchar())a=a*10+c-'0';
    return f?-a:a;
}
const int N=100001;
int bel[N],son[N],bro[N],ne[N],head[N],ask[N];
char c[N],ans[N],arr[N];
void dfs(int u,int len){
    arr[len]=c[u];
    for(int x=head[u];x;x=ne[x])ans[x]=arr[ask[x]];
    for(int x=son[u];x;x=bro[x])dfs(x,len+1);
}
int main(){
    int n=read(),nt=0,nu=0,nq=0;
    fo(i,1,n){
        scanf("\n");
        char opt=getchar();getchar();
        if(opt=='T'){
            bel[++nu]=++nt;
            bro[nt]=son[bel[nu-1]];
            son[bel[nu-1]]=nt;
            c[nt]=getchar(); 
        }
        if(opt=='U')bel[++nu]=bel[nu-read()-1];
        if(opt=='Q'){
            ne[++nq]=head[bel[nu]];
            head[bel[nu]]=nq;
            ask[nq]=read();
        }
    }
    dfs(0,0);
    fo(i,1,nq)printf("%c\n",ans[i]);
    return 0;
}
```
在线代码

```cpp
#include<cstdio>
using namespace std;
#define fo(a,b,c) for(int a=b;a<=c;a++)
int read(){
    int a=0,f=0;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')f=1;
    for(;c>='0'&&c<='9';c=getchar())a=a*10+c-'0';
    return f?-a:a;
}
const int N=100001;
int bel[N],fa[N][20],deep[N];
char c[N];
int main(){
    int n=read(),nt=0,nu=0;
    fo(i,1,n){
        scanf("\n");
        char opt=getchar();getchar();
        if(opt=='T'){
            bel[++nu]=++nt;
            deep[nt]=deep[bel[nu-1]]+1;
            fa[nt][0]=bel[nu-1];
            for(int i=0;fa[fa[nt][i]][i];i++)
                fa[nt][i+1]=fa[fa[nt][i]][i];
            c[nt]=getchar(); 
        }
        if(opt=='U')bel[++nu]=bel[nu-read()-1];
        if(opt=='Q'){
            int p=bel[nu];
            for(int x=deep[p]-read(),i=0;x;x>>=1,i++)
                if(x&1)p=fa[p][i];
            printf("%c\n",c[p]);
        } 
    }
    return 0;
}
```

---

## 作者：Treeloveswater (赞：2)

咦？IOI难度是在线？

我稍微想了想，貌似在线并不需要什么主席树的。

我们倍增就好了~！

我们先把题目转化一下，把整个文章看做一条链，Undo操作也看做是往里面插了一个'U'的字符（只不过最后不计算答案罢了）。对于每个‘U‘字符，我们往上找第x+1个字符，和它连边，就和题目要求的操作是同一个道理了。

可能大家还不是太懂，我扔个图上来给大家看看

……晕，我并不会放图。

这么讲，我们规定U向前面某个点连的边染成红色，原链上的边是黑色。查询的时候，遇到红色边则跳红色边，否则跳黑色边。

而这就可以用倍增了，每插入一个点，则处理以下几个数组

注：定义“合法字符”为不是'U’的字符，“字符”则指所有字符

F[i][j] 从i开始往上，遇红则跳红，否则跳黑，遇到的第(1<<j)个合法字符的位置。

G[i][j] 从i开始往上，只跳黑，遇到的第(1<<j)个的字符的位置。

Head[i] 若i为'U'，则记录它的红边是连向前面的谁，否则Head[i]=i-1；

num[i] 从i开始往上，遇红则跳红，否则跳黑，一直到最顶上一共有多少个合法字符

Close[i] 从i开始往上，遇红则跳红，否则跳黑，遇到的第一个合法字符的位置

倍增处理即可~~查询很简单，查F数组即可。

感觉并不是IOI难度……连省选都赶不上

附上代码

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define o 100101
//倍增保存
int f[o][23];
int g[o][23];
int close[o],head[o],num[o]; 
using namespace std;
int cnt,n,w;
char s[10],c[10],A[o];
void insert(){
    num[cnt]=num[cnt-1]+1;
    close[cnt]= A[cnt-1]=='U'? close[cnt-1]:cnt-1;
    f[cnt][0]= A[cnt-1]=='U'? close[cnt-1]:cnt-1;
    head[cnt]= cnt-1;
    for(int i=1;i<=20;i++) f[cnt][i]=f[f[cnt][i-1]][i-1];    
    g[cnt][0]=cnt-1;
    for(int i=1;i<=20;i++) g[cnt][i]=g[g[cnt][i-1]][i-1];
}
void Undo(int x){
    
    x--;int now=cnt;
    A[++cnt]='U';
    for(int i=20;i>=0;i--)
    if((1<<i)<=x){
        x-=(1<<i);
        now=g[now][i];
    }
    now--;
    head[cnt]=now;
    num[cnt]=num[now];
    close[cnt]= A[now]=='U'? close[now]:now;
    f[cnt][0]= A[now]=='U'? close[now]:now;
    for(int i=1;i<=20;i++) f[cnt][i]=f[f[cnt][i-1]][i-1];
    g[cnt][0]=cnt-1;
    for(int i=1;i<=20;i++) g[cnt][i]=g[g[cnt][i-1]][i-1];    
}
int main(){
    scanf("%d",&n);
    A[0]='A';close[0]=0;
    for(int i=1;i<=n;i++){
        scanf("%s",s);
        if(s[0]=='T'){
            scanf("%s",c);
            A[++cnt]=c[0]; 
            insert();
            continue;
        } 
        if(s[0]=='U'){
            scanf("%d",&w);
            Undo(w);
            continue;
        }
        if(s[0]=='Q'){
            scanf("%d",&w);
            w=num[cnt]-w+1;
            if(w<=0)w=1;
            if(A[cnt]!='U')w--;
            int now=cnt;
            for(int i=20;i>=0;i--)
            if((1<<i)<=w){
                w-=(1<<i);
                now=f[now][i];
            }
            printf("%c\n",A[now]);
        }
    }
    return 0;
}
```

---

## 作者：tonyfettes (赞：1)


说起来好像大家好像都说IOI挑战需要主席树才能AC...

但实际上我用了一个不知道叫什么名字的数据结构（可持久化栈？）...在线过掉了这道题

但由于本人严重依赖STL而且使用姿势也不是很高...

导致代码常数巨大，空间大得惊人...


首先考虑不会撤销撤销操作的撤销操作，那么就是将栈顶指针下移$x$个单位，然后以后插入的时候在栈顶插入。


再考虑会撤销撤销操作的撤销操作，考虑撤销时的中间过程，如果这次撤销操作撤销了上一次撤销操作，那么当前栈就会回退到上一次撤销之前的状态，于是考虑将每一次撤销操作前的栈都保存下来，同时记录各个栈的时间戳，遇到撤销操作的时候二分查找这次撤销能够回退到的状态，由于该次撤销操作回到的过去的时间戳和二分回退到的时间戳存在一个差值，所以在回退以后再将栈顶指针下移就可以了


考虑空间开销，如果在 $n/2$ 次插入操作以后一直撤回上一条操作，此时达到最坏情况为$n^2$级别，但实际上数据没有卡。

时间复杂度大概是$n*log(n)$的


附上代码：

```cpp
#include <cctype>
#include <cstdio>
#include <utility>
#include <vector>
using std::vector;
using std::pair;
using std::make_pair;

template <typename T>
inline void get(T& a) {
  char c = getchar();
  while (!isdigit(c)) c = getchar();
  a = 0;
  while (isdigit(c)) {
    a = a * 10 + (c & 0xf);
    c = getchar();
  }
}

vector<pair<int, vector<int> > > history;
vector<int> real_time_stack;
int real_time_stack_top_ptr;
int time_tag;

int find(int val) {
  int l = 0;
  int r = history.size() - 1;
  while (l < r) {
    int mid = (l + r) >> 1;
    if (history[mid].first == val)
      return mid;
    else if (history[mid].first > val)
      r = mid;
    else
      l = mid + 1;
  }
  return l;
}

int main() {
  int n;
  get(n);
  for (int i = 1; i <= n; i++) {
    int x = getchar();
    while (!isalnum(x)) x = getchar();
    if (x == 'T') {
      time_tag++;
      x = getchar();
      while (!isalpha(x)) x = getchar();
      if (real_time_stack_top_ptr < real_time_stack.size())
        real_time_stack[real_time_stack_top_ptr++] = x;
      else {
        real_time_stack.push_back(x);
        real_time_stack_top_ptr++;
      }
    } else if (x == 'U') {
      time_tag++;
      get(x);
      history.push_back(make_pair(
          time_tag, vector<int>(real_time_stack.begin(),
                                real_time_stack.begin() + real_time_stack_top_ptr)));
      int idx = find(time_tag - x);
      if (idx != time_tag) {
        int prefix = history[idx].first - time_tag + x;
        real_time_stack = history[idx].second;
        real_time_stack_top_ptr = real_time_stack.size() - prefix;
      } else {
        real_time_stack_top_ptr -= x;
      }
    } else {
      get(x);
      printf("%c\n", real_time_stack[x - 1]);
    }
  }
  return 0;
}

```

---

## 作者：arfa (赞：0)

> ## 可持久化数据结构维护可持久化数组

首先我们要知道,**"UNDO"**操作,也就是直接跳回前面的操作(历史操作),然后跳回的地方到现在的地方这一个区间的操作都不用管。(这就是高级挑战的思路)

(可持久化是指一种可以访问历史版本的数据结构)然后我们就可以知道,询问历史,又是数组,也就是可持久化数组。可持久化数组的维护很简单,我们可以开一个$O(N^2)$的矩阵,然后进行操作。但是这样子空间会爆炸,怎么办?所以可持久化数组又可以用可持久化线段树来维护,虽然有很多空间浪费了,不过空间也还是$O(N\ log\ N)$(因为每一个数带来的空间是$log\ n$的)。

所以就这样子咯,如果还不会可持久化线段树(主席树)的可以去做洛谷的模板。

```pascal
// luogu-judger-enable-o2
var
        n,cnt,hao,tot:longint;
        len,lson,rson,root:array[0..2000035] of longint;
        value:array[0..2000035] of char;
        s:string;
        HuHa:char;

procedure build(var rt:longint; fa,l,r,po:longint); //插入一个数
var
        mid:longint;
begin
        if (rt=0) then
        begin
                inc(tot);
                rt:=tot; //动态开点
        end;
        if l=r then //到了叶子节点
        begin
                value[rt]:=HuHa; //赋值
                exit; //退出
        end;

        mid:=(l+r) div 2;
        if (po<=mid) then //po就是key位置,我现在在最后(一个栈)插入一个数,po就是最后的位置
        begin
                rson[rt]:=rson[fa]; //垃圾回收
                build(lson[rt],lson[fa],l,mid,po); //左走
        end;
        if (po>=mid+1) then //同上
        begin
                lson[rt]:=lson[fa];
                build(rson[rt],rson[fa],mid+1,r,po);
        end;
end;

function Query(rt,l,r,po:longint):char; //查询
var
        mid:longint;
begin
        if l=r then //到了指定位置(不一定是po)
                exit(value[rt]);
        mid:=(l+r) div 2; // 线段树常识
        if (po<=mid) then
                exit(Query(lson[rt],l,mid,po));
        if (po>=mid+1) then
                exit(Query(rson[rt],mid+1,r,po));
end;

begin
        readln(n);
        while n>0 do
        begin
                readln(s);
                if s[1]='T' then
                begin
                        HuHa:=s[3]; //直接截取
                        inc(cnt);
                        len[cnt]:=len[cnt-1]+1; //新的位置 
                        Build(root[cnt],root[cnt-1],1,100007,len[cnt]); //插入
                end;

                if s[1]='U' then
                begin
                        delete(s,1,2);
                        val(s,hao);
                        inc(cnt);
                        len[cnt]:=len[cnt-hao-1]; //位置往前推
                        root[cnt]:=root[cnt-hao-1]; //Root往前推(没一个数都有一个log链,当然有一个根)
                end;

                if s[1]='Q' then
                begin
                        delete(s,1,2);
                        val(s,hao);
                        writeln(Query(root[cnt],1,100007,hao)); // 查询,我们不知道最长的长度是多少,所以就100007就可以了,log不会超过20
                end;
                dec(n);
        end;
end.
```

---


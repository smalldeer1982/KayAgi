# 铁球落地

## 题目描述

在二维坐标系内有 $n$ 个平台（定义平台是一条两端点纵坐标相同的开线段，开线段指线段两个端点不算做线段本身）和一个铁球，铁球如果下面没有物体，则每秒会下落一个单位长度。

球每次落到某个平台上后，游戏者可以选择水平向左或水平向右滚，球滚动速度是每秒 $1$ 个单位长度。由于铁球的质量不太好，每次落下的高度不能超过 $h$。

设计一种策略，使得球尽快落到地面而不被摔碎。

假设地面高度为 $0$，且无限宽。球体积相对平台极小，可以看作一个质点。**请注意，球滚动至平台的一个端点处即可下落，不需要滚动至下一个格子**。例如下图，小球在 $(9,9)$ 处已经开始下落。

![](https://cdn.luogu.com.cn/upload/image_hosting/b19ucru5.png)

## 说明/提示

#### 数据规模与约定 

对于全部的测试点，保证：

- $1 \leq n \leq 10^5$。
- $1 \leq x, y, h, h_i, l_i, r_i \leq 10^9$，$l_i \leq r_i$。
- 对于所有的 $h_i$，保证互不相同，$l_i$ 与 $r_i$ 也互不相同，且对于任意 $i \neq j$，保证 $l_i \neq r_j$ 。
- 数据保证有解，最终答案不超过 $10^9$。

## 样例 #1

### 输入

```
5 3
6 10
5 2 4
9 3 9
6 7 10
2 1 5
3 8 11
```

### 输出

```
15```

## 样例 #2

### 输入

```
10 156
84 139
63 22 50
79 96 100
87 77 98
60 24 53
47 1 29
62 55 89
68 68 78
10 5 85
85 67 71
73 57 61
```

### 输出

```
155
```

# 题解

## 作者：王sky (赞：19)


这题应该不难想到使用dp求解。

我们先将每块木板按照高度排序。
然后我们按照从矮到高的顺序倒序遍历这些木板。
可能你会问为什么要从矮到高的顺序dp。
其实从高到到矮的顺序dp，其实从高到矮并不是不可以。
但从低到高会来的更方便。
因为从低到高的话，我们只需要考虑从左边下落到达的木板，和从右边下落到达的两个木板继承就可以了。
然而从高到低我们并不方便找到哪些下落可以到达该木板。

~~以上都是废话~~

假若我们已经求得了这个木板左右下落会到达哪些木板，
我们记 
ch[i][1/0] 0表示i的左边下落到达的木板，1表示右边下落到达的木板。

dp[i][1/0] 0表示如果下落到左边木板，最小费时，1表示下落到右边木板的最小费时。
　　　 

la[i] 表示 i 的右端点横坐标， ra[i] 表示 i 的左端点横坐标。

a[i].h 记录 i 木板的高度。

**dp 方程如下：**　

**dp[i][0]=min(dp[i][0],dp[ch[i][0]][0]+la[i]-la[ch[i][0]]+a[i].h-a[ch[i][0]].h)**

**dp[i][0]=min(dp[i][0],dp[ch[i][0]][1]+ra[ch[i][0]]-la[i]+a[i].h-a[ch[i][0]].h);**

**dp[i][1]=min(dp[i][1],dp[ch[i][1]][0]+ra[i]-la[ch[i][1]]+a[i].h-a[ch[i][1]].h);**

**dp[i][1]=min(dp[i][1],dp[ch[i][1]][1]+ra[ch[i][1]]-ra[i]+a[i].h-a[ch[i][1]].h);**

其实这后面转移就是路径的模拟，不难理解。

dp方程解决了，还有一个问题，那就是如何处理出每个木板左右下落后到达的木板？

一个比较好理解的方案是用线段树预处理。

 

这里使用了**区间赋值和单点修改**。

我们从低到高枚举木板，查询左/右端点下线段树上对应的值。
这值就是我们要求的是落到的那个木板编号。
当处理完这个木板完后，他就是对应区间(木板的左端点到右端点)，最上面的木板了。
它上面的应当会落在它的上面。
于是区间修改。把这段区间的值修改为这个木板的编号。

~~到此，问题得到完美解决~~

等等，我们千万不要忘记**离散化**，以及dp时特判。
如果当前的木板下落到的木板编号为0，那么dp值是当前木板的高度。

具体看代码

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ls k<<1
#define rs k<<1|1
typedef long long ll;
using namespace std;
const int N=1e6;
ll n,m,cnt;
ll lx[N<<2],ch[N][2],w[N<<4],tag[N<<4];//
ll la[N<<2],ra[N<<2],dp[N][2];//
struct node{
    ll l,r,h,id;//需要记录一个编号，因为需要排序
    bool operator < (const node &b) const {
        return h<b.h;//按高度从矮到高排序
    }
}a[N];
inline void read(ll &x){
    x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
}
inline void update(ll k,ll x,ll y){
    tag[ls]=tag[k];
    w[ls]=tag[k];
    tag[rs]=tag[k];
    w[rs]=tag[k];
    tag[k]=0;
}
inline void change(ll k,ll x,ll y,ll l,ll r,ll val){
    if(x>r||y<l) return;
    if(x>=l&&y<=r){//区间赋值
        tag[k]=val;
        w[k]=val;
        return;
    }
    ll mid=x+y>>1;
    if(tag[k]) update(k,x,y);//区间赋值的标记下传
    change(ls,x,mid,l,r,val);
    change(rs,mid+1,y,l,r,val);
}
inline ll query(ll k,ll x,ll y,ll pos){
    if(x>pos||y<pos) return 0;
    if(x==y) return w[k];//单点查询，w记录当前区间对应最上方的木板编号
    ll mid=x+y>>1;
    if(tag[k]) update(k,x,y);
    return query(ls,x,mid,pos)+query(rs,mid+1,y,pos);
}
int main()
{
    ll i,j,stx,sty;
    read(n),read(m);
    read(stx),read(sty);
    n++;//有一个起始位置
    a[n].l=a[n].r=stx;
    a[n].h=sty,a[n].id=n;
    la[n]=stx,ra[n]=stx;
    lx[++cnt]=a[n].l;
    for(i=1;i<n;i++){
        read(a[i].h),read(a[i].l),read(a[i].r);
        a[i].id=i;
        la[i]=a[i].l;
        ra[i]=a[i].r;//la[] ra[]记录原来i木板的左右端点位置，因为需要离散化。
        lx[++cnt]=a[i].l;//lx[] 为离散化数组
        lx[++cnt]=a[i].r;
    }
    sort(lx+1,lx+cnt+1);//离散化数组排序
    sort(a+1,a+1+n);//木板高度排序
    for(i=1;i<=n;i++){//区间离散化
        a[i].l=lower_bound(lx+1,lx+1+cnt,a[i].l)-lx;
        a[i].r=lower_bound(lx+1,lx+1+cnt,a[i].r)-lx;
    }
    for(i=1;i<=n;i++){//点查询，不再多说
        ch[i][0]=query(1,1,cnt,a[i].l);
        ch[i][1]=query(1,1,cnt,a[i].r);
        change(1,1,cnt,a[i].l,a[i].r,i);
    }
    memset(dp,0x3f,sizeof(dp));
    dp[0][0]=dp[0][1]=0;//显而易见的初始化
    for(i=1;i<=n;i++){
        if(a[i].h-a[ch[i][0]].h<=m){//如果大于m不能转移
            if(ch[i][0]){//编号为0这带到到达地面
                 dp[i][0]=min(dp[i][0],dp[ch[i][0]][0]+la[a[i].id]-la[a[ch[i][0]].id]+a[i].h-a[ch[i][0]].h);
                 dp[i][0]=min(dp[i][0],dp[ch[i][0]][1]+ra[a[ch[i][0]].id]-la[a[i].id]+a[i].h-a[ch[i][0]].h);//加了离散数组的方程，一点点小变化
             }
             else dp[i][0]=a[i].h;
        }
        if(a[i].h-a[ch[i][1]].h<=m){
            if(ch[i][1]){
                dp[i][1]=min(dp[i][1],dp[ch[i][1]][0]+ra[a[i].id]-la[a[ch[i][1]].id]+a[i].h-a[ch[i][1]].h);
                dp[i][1]=min(dp[i][1],dp[ch[i][1]][1]+ra[a[ch[i][1]].id]-ra[a[i].id]+a[i].h-a[ch[i][1]].h);
            }
            else dp[i][1]=a[i].h;
        }
    }
    printf("%d",min(dp[n][0],dp[n][1]));//最后答案为转移到起始位置 n 的值。
}//刚好99行
```


---

## 作者：CodyTheWolf (赞：18)

### 看到各位都是拿线段树优化DP写的，其实这题跑最短路会更容易理解，代码也好打。

### 最主要是代码跑的飞快ww，是目前的rank1

全部节点：Accepted  100 
用时: 136ms / 内存: 8304KB


------------

## 大致思路：

### 1.对木板按照高度排序
### 2.对于每一个木板，暴力枚举更低的木板，如果可以承接掉下的小球，使当前木板的左或右端点和可到达的木板的左右端点相连，路的权值可以用坐标计算得到。注意：用DFS或者BFS跟着小球能下落的木板枚举，而不是全部都枚举，因为有些木板小球根本落不下。还要记得打标记防止一个木板被重复搜索。如果当前木板有端点没有承接的木板，判断其会不会掉到地板上并连边。
 _**小技巧：小球用0表示，左端点用1-n表示，右端点用(n+1)-2n表示，地板用2n+1表示**_ 
### 3.随便跑个最短路径得到答案（到2n+1的最小值）即可。


------------
## 代码如下：部分操作有注释
```cpp
#pragma warning (disable:4996)
#include <iostream>
#include <cstdio>
#include <cstring>
#include <deque>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;
const int maxn = 2e5 + 5, maxm = 4e5 + 5, inf = 0x7fffffff;
int head[maxm], nxt[maxm], v[maxm], w[maxm], h[maxn], x[maxn], y[maxn], dis[maxn];//h为高度，xy为左右端点
bool vis[maxn];
int n, m, cnt, sx, sy;

inline void addline(int x, int y, int z) { v[cnt] = y, w[cnt] = z, nxt[cnt] = head[x], head[x] = cnt++; }

inline int read()
{
	register int x = 0;
	register char c = getchar();
	while (c<'0' || c>'9') c = getchar();
	while (c >= '0'&&c <= '9') x = (x << 3) + (x << 1) + c - '0', c = getchar();
	return x;
}

inline void qsort(int l, int r)//手写快排
{
	register int mid = h[(l + r) >> 1], L = l, R = r;
	while (l <= r)
	{
		while (h[l] > mid)	l++;
		while (h[r] < mid)	r--;
		if (l <= r) { swap(h[l], h[r]), swap(x[l], x[r]), swap(y[l], y[r]), l++, r--; }
	}
	if (L < r)	qsort(L, r);
	if (l < R)	qsort(l, R);
	return;
}

inline void connect()//重点操作：连边
{
	//0号为铁球，一倍点（1-n）为左端点，二倍点（n+1-2n)为右端点，2*n+1为地板（最终汇点）
	addline(0, 1, sy - h[1] + sx - x[1]), addline(0, n + 1, sy - h[1] + y[1] - sx);
	//应该是数据原因导致排序后第一块木板一定在铁球下方，所以让其和木板的左右两端点相连，假如改数据也没问题，在读入时把大于小球高度的木板全部删除，再在这个函数中按高度枚举到能接到小球的木板当成1号木板即可
	queue<int> Q;//用队列辅助链接
	while (!Q.empty())	Q.pop();
	Q.push(1);//第一块木板入队
	while (!Q.empty())
	{
		int i = Q.front(); Q.pop();
		bool left = false, right = false;//小剪枝：左右都有木板承接就可以不用枚举了
		for (int j = i + 1; h[i] > h[j] && h[i] - h[j] <= m && j <= n; j++)//暴力枚举能落下的木板
		{
			if (!left && x[j] < x[i] && x[i] < y[j])//计算木板i的左端点是否能落到木板j，根据不等式推一下就明白了
			{
				//如果可以
				addline(i, j, h[i] - h[j] + x[i] - x[j]);//木板i的左端点链接木板j的左端点
				addline(i, j + n, h[i] - h[j] + y[j] - x[i]);//木板i的左端点链接木板j的右端点（二倍点）
				left = true;
				if (!vis[j])	Q.push(j), vis[j] = true;//j没入队过才能搜，防止搜多超时
			}
			if (!right && x[j] < y[i] && y[i] < y[j])//计算木板i的右端点是否能落到木板j，与上面同理
			{
				addline(i + n, j, h[i] - h[j] + y[i] - x[j]);
				addline(i + n, j + n, h[i] - h[j] + y[j] - y[i]);
				right = true;
				if (!vis[j])	Q.push(j), vis[j] = true;
			}
			if (left && right)	break;//左右端点都有木板接着就不用枚举了
		}
		if (!left&&h[i] <= m)	addline(i, n << 1 | 1, h[i]);//如果左端点没有落点，判断能不能落到地上(点为2*n+1)
		if (!right&&h[i] <= m)	addline(i + n, n << 1 | 1, h[i]);//判断右端点，同理
	}
	return;
}

inline void SPFA()//SPFA+SLF优化
{
	memset(dis, 0x3f, sizeof(dis));
	memset(vis, 0, sizeof(vis));
	deque<int> Q;
	while (!Q.empty())	Q.pop_back();
	dis[0] = 0, Q.push_back(0), vis[0] = true;
	while (!Q.empty())
	{
		int x = Q.front(); Q.pop_front(); vis[x] = false;
		for (register int i = head[x]; i != -1; i = nxt[i])
			if (dis[v[i]] > dis[x] + w[i])
			{
				dis[v[i]] = dis[x] + w[i];
				if (!vis[v[i]])
				{
					vis[v[i]] = true;
					if (!Q.empty())
					{
						if (dis[v[i]] > dis[Q.front()])	Q.push_back(v[i]);
						else  Q.push_front(v[i]);
					}
					else  Q.push_back(v[i]);
				}
			}
	}
	return;
}

int main()
{
	memset(head, -1, sizeof(head));
	n = read(), m = read(), sx = read(), sy = read();//sx,sy为小球坐标
	for (int i = 1; i <= n; i++)	h[i] = read(), x[i] = read(), y[i] = read();
	qsort(1, n), connect(), SPFA();//先排序，连接好边就跑一边SPFA
	printf("%d\n", dis[n << 1 | 1]);//最终汇点，即地板（2*n+1）离小球的最短距离即是答案
	return 0;
}
```


------------
### 小吐槽：
一开始连边没有打标记，以为是最短路超时了，上了各种优化（SPFA+SLF，快读，手写快排等等），所以导致代码很长还调了很久QwQ

---

## 作者：Zachary_260325 (赞：10)

# 建图跑Dijkstra

此题卡我半天...我太菜了...o(╥﹏╥)o

~~大家可以看看评测记录，有一页多都是我...~~

本来以为TLE是哪里出了点小问题,然后调了半天，又是不用vector又是玄学优化的...最后看了题解才发现是建图太慢了...

------------

~~此分界线以上是废话...~~

------------

### 思路

- 读入数据，并根据小球初始高度**删除高度比小球初始高度高的平台**（因为它只能往下滚...）

- 排序平台，来加速建图（因为小球会被**第一个覆盖其下落x坐标**的板子接住），所以让平台单调递增（或递减）就行...

- 在全部平台排序后，插入小球的初始位置。小球初始位置可以视为在一个高度是**y**（y表示初始高度），覆盖**[x,x]**（x表示初始横坐标）范围的（没有宽度的）平台上，让n+1，然后把这个平台保存进去。

- 之后用队列优化建图。因为**不是所有平台都会被小球使用**，所以不用管多余的平台。

- 建图时从当前的平台**左端**和**右端**分别往下找可以承接小球的平台。如果找到平台且**高度差小于max**（不要忘了...），就记录从小球掉落位置分别到平台两边的距离并连接（不用记录高度差，因为到地面的**下落距离一定是y**）。如果找不到平台，再去判断**地面**能不能承接，如果能就连接。建图的时候，为了方便起见，把第i块平台的左端坐标定为**i**，右端坐标定义为**i+n**，两个坐标之间没有直接的边连接（因为不需要）。

 ##### //P.S. 不要用什么Vector，没有必要...

- 最后跑一遍堆优化的**Dijkstra**（当然，SPFA在这道题也许更快...如果追求速度还可以学习更强大的最短路算法）

------------

### 代码
```cpp
#include<cstdio>
#include<vector>
#include<queue>
#include<algorithm>
#include<cctype>
#include<cstring>
#define rint register int
inline int read()
{
    rint k=0,c=getchar();
    while(!isdigit(c))
        c=getchar();
    while(isdigit(c))
    {
        k=10*k+c-'0';
        c=getchar();
    }
    return k;
}
struct Q{
    int h,x,y;
    Q(){}
    Q(int _h,int _x,int _y):h(_h),x(_x),y(_y){}
}a[100005];
struct P{
    int x,d;
    P(){}
    P(int _x,int _d):x(_x),d(_d){}
}v[200005][2];
const bool operator <(P a,P b)
{
    return a.d>b.d;
}
inline bool cmp(Q a,Q b)
{
    return a.h<b.h;
}
std::priority_queue<P> que;
int vis[200005],n,max,x,y;
int main()
{
	std::memset(v,-1,sizeof(v));//init
    n=read();
    max=read();
    x=read();
    y=read();
    for(rint i=1;i<=n;++i)
    {
        a[i].h=read();
        a[i].x=read();
        a[i].y=read();
        if(a[i].h>y)//delete
        {
        	--n;
        	--i;
		}
    }
    std::sort(a+1,a+n+1,cmp);
    a[++n]=Q(y,x,x);
    std::queue<int> tq;
    tq.push(n); 
    while(!tq.empty())
    {
    	int i=tq.front();
    	tq.pop();
        //find left
        int mem=0,point=a[i].x,h=a[i].h;
        for(int j=i-1;j>=1&&h-max<=a[j].h;--j)
            if(a[j].x<=point&&a[j].y>=point)
            {
                mem=j;
                break;
            }
        int delta=h-a[mem].h;
        if(delta<=max)
        {
        	if(mem==0)
                v[i][0]=P(0,0);
            else
            {
            	v[i][1]=P(n+mem,a[mem].y-point),v[i][0]=P(mem,point-a[mem].x);
            	if(!vis[mem])
                {
                	tq.push(mem); 
                	vis[mem]=1;
				}
			}
        }
        //find right
        mem=0,point=a[i].y;
        for(int j=i-1;j>=1&&h-max<=a[j].h;--j)
            if(a[j].x<=point&&a[j].y>=point)
            {
                mem=j;
                break;
            }
        delta=h-a[mem].h;
        if(delta<=max)
        {
        	if(mem==0)
            	v[n+i][0]=P(0,0);
        	else
        	{
        		v[n+i][1]=P(n+mem,a[mem].y-point),v[n+i][0]=P(mem,point-a[mem].x);
        		if(!vis[mem])
                {
                	tq.push(mem); 
                	vis[mem]=1;
				}
			}
		}
    }
    std::memset(vis,0,sizeof(vis));
    que.push(P(n,0));
    rint now,d;
    while(!que.empty())//Dijkstra
    {
        now=que.top().x;
        d=que.top().d;
        que.pop();
        if(now==0)
        {
            printf("%d",d+y);
            return 0;
        }
        if(vis[now])
            continue;
        vis[now]=1;
        for(rint i=0;i<=1;++i)
            if(v[now][i].x!=-1&&!vis[v[now][i].x])
                que.push(P(v[now][i].x,v[now][i].d+d));
    }
    return 0;
} 
```

------------

### 评测结果：130ms/5.63MB 

目前**RANK1**，还算可以了~~（等那些优化神佬一来就下去了...）~~

---

## 作者：hulne (赞：8)

## 写在前面

我没用线段树（躲进小被几.jpg）

## 思路

球是从上往下掉落的啊，所以按高度从高到低排序

从哪个平台开始是可以确定的，一开始比球高的平台就直接略过，然后再找能接到球的第一个平台，设下标为 now，

设 `c[i].l` 和 `c[i].r` 分别表示到某个平台的左边缘、右边缘所耗时间（因为小球掉落的垂直距离是一定的，所以所以这里 c 数组只记录水平所耗时间）

从 now 枚举到 n，考虑当前枚举到的平台从左、右两边缘分别掉到哪里，就更新哪个平台的值，所以每个平台的两边缘只需找到第一个接到球的平台就好了，考虑到一个平台能接受到从不同平台的边缘掉落的球，所以更新时取max，所以事先将 c 数组赋最大值

**注意**
* now 的 c 数组的值先算出来再去枚举; 
* 最后别忘了加球的初始高度

---

**至于为什么暴力能过**，大概因为平台过于密集导致该平台与其第一个接到球的平台距离过近，~~而我偷鸡取巧~~，不排除数据水的原因（？雾）

代码有注释，不懂请私信 

```c++
#include <bits/stdc++.h>
#define N 100010
#define inf 999999999
using namespace std;
inline int in() {
    int x = 0, f = 1; char C = getchar();
    while(C < '0' or C > '9') { if(C == '-') f = -1; C = getchar(); }
    while(C >= '0' and C <= '9') x = (x << 3) + (x << 1) + (C ^ 48), C = getchar();
    return x * f;
}
int n, H, sx, sy, ans = inf;
struct hh { int h, l, r; } o[N];
struct hhh { int l, r; } c[N];
bool cmp(hh x, hh y) { return x.h > y.h; }
// H：掉落高度限制 o：记录平台信息 c:记录到第i个平台左右边缘分别所耗最短时间

int main() {
    n = in(), H = in(), sx = in(), sy = in();
    for(int i = 1; i <= n; i ++) o[i].h = in(), o[i].l = in(), o[i].r = in();
    for(int i = 1; i <= n; i ++) c[i].l = c[i].r = inf; //初始化
    sort(o + 1, o + n + 1, cmp); 
    //从下面开始找第一个接到球的平台
    int now = 1;
    while(sy < o[now].h) now ++; //比球高的略过
    while(sx > o[now].r or sx < o[now].l) now ++; //直到能接到球为止
    c[now].l = sx - o[now].l; //只考虑水平方向的耗时
    c[now].r = o[now].r - sx;
    for(register int i = now, oo, flag; i <= n; i ++) {
        if(c[i].l == inf) continue; //球没能到达过此平台，自然无法更新别人，跳过
	//左边缘↓
        oo = i + 1, flag = 1; 
        //oo：枚举i之后的平台的下标，直到找到第一个能接住从第i个平台左边缘掉落的球的平台
        //flag：若从左边缘掉落能更新到某个平台，不能掉到地上，赋为0
        while(o[i].h - o[oo].h <= H and oo <= n) {//掉落高度限制内&&n个内
            if(o[oo].l <= o[i].l and o[i].l <= o[oo].r) {//若能接到
                c[oo].l = min(c[oo].l, c[i].l + o[i].l - o[oo].l);
                c[oo].r = min(c[oo].r, c[i].l + o[oo].r - o[i].l);
                flag = 0; break;//能更新到别人，赋0，退出
            } oo ++;
        }
        if(o[i].h <= H and flag) ans = min(ans, c[i].l);
        //若没有平台能接到球，且在H范围内，就可以更新答案了
        //右边缘↓，ctrl+c and ctrl+v and 微创
        oo = i + 1, flag = 1;
        while(o[i].h - o[oo].h <= H and oo <= n) {
            if(o[oo].l <= o[i].r and o[i].r <= o[oo].r) {
                c[oo].l = min(c[oo].l, c[i].r + o[i].r - o[oo].l);
                c[oo].r = min(c[oo].r, c[i].r + o[oo].r - o[i].r);
                flag = 0; break;
            } oo ++;
        }
        if(o[i].h <= H and flag) ans = min(ans, c[i].r);
    }
    cout << ans + sy;//水平移动耗时+初始高度
    return 0;
}
```

---

## 作者：hu1029282594 (赞：4)

#### 莫名想写一篇题解
讲的不好，dalao们勿喷

这是一道很经典的线段树优化dp

我们发现，从每个平台的两端向下落，落点具有唯一性

于是就把平台横坐标离散化一下，

从下往上覆盖，用线段树预处理一下每个平台两端掉落到的平台

再计算转移方程，方程就略了

时间复杂度 O(nlogn)

上代码

```cpp
//处处留心离散化 
//向下掉具有唯一性 
//从底向上覆盖预处理每块能掉到的块(Segtree)
#include<bits/stdc++.h>
using namespace std;
#define MAXN 200005
#define INF 1<<30
struct Node
{
    int shu,cover;
}segtree[MAXN<<2];//区间修改，单点查询
struct DD
{
    int ld,rd,hd;
}kuai[MAXN];
bool cmp(DD a,DD b)
{
    return a.hd<b.hd;
}
int pai[MAXN];int paitail=1;
int duiy[MAXN];int f[MAXN][2];
int hhnext[MAXN][2];int start_next;
int n,maxt,startx,starty;
inline void pushup(int cur)
{
    segtree[cur].shu=max(segtree[cur<<1].shu,segtree[cur<<1|1].shu);
    return;
}
inline void pushdown(int cur)
{
    if(segtree[cur].cover==0)return;
    segtree[cur<<1].cover=segtree[cur<<1|1].cover=segtree[cur].cover;
    segtree[cur<<1].shu=segtree[cur<<1|1].shu=segtree[cur].cover;
    segtree[cur].cover=0;return;
}
inline int query(int cur,int l,int r,int L,int R)
{
    if(L<=l&&r<=R){
        return segtree[cur].shu;
    }
    pushdown(cur);int ans=0;
    int mid=(l+r)>>1;
    if(L<=mid)ans=max(ans,query(cur<<1,l,mid,L,R));
    if(R>mid)ans=max(ans,query(cur<<1|1,mid+1,r,L,R));
    return ans;
}
inline void add(int cur,int l,int r,int L,int R,int t)
{
    if(L<=l&&r<=R)
    {
        segtree[cur].shu=segtree[cur].cover=t;
        return;
    }
    pushdown(cur);
    int mid=(l+r)>>1;
    if(L<=mid)add(cur<<1,l,mid,L,R,t);
    if(R>mid)add(cur<<1|1,mid+1,r,L,R,t);
    pushup(cur);
    return;
}
int main()
{
    scanf("%d%d",&n,&maxt);scanf("%d%d",&startx,&starty);
    for(register int i=1;i<=n;i++)
    {
        scanf("%d%d%d",&kuai[i].hd,&kuai[i].ld,&kuai[i].rd);
        pai[paitail++]=kuai[i].ld;pai[paitail++]=kuai[i].rd;
    }
    sort(pai+1,pai+paitail);
    for(register int i=1;i<=n;i++)
    {
        int searchh=lower_bound(pai+1,pai+paitail,kuai[i].ld)-pai;
        duiy[searchh]=kuai[i].ld;kuai[i].ld=searchh;
        searchh=lower_bound(pai+1,pai+paitail,kuai[i].rd)-pai;
        duiy[searchh]=kuai[i].rd;kuai[i].rd=searchh;
    }
    sort(kuai+1,kuai+n+1,cmp);
    for(register int i=1;i<=n;i++)
    {
        hhnext[i][0]=query(1,1,200000,kuai[i].ld,kuai[i].ld);
        if(kuai[i].hd-kuai[hhnext[i][0]].hd>maxt)hhnext[i][0]=-1;
        hhnext[i][1]=query(1,1,200000,kuai[i].rd,kuai[i].rd);
        if(kuai[i].hd-kuai[hhnext[i][1]].hd>maxt)hhnext[i][1]=-1;
        add(1,1,200000,kuai[i].ld,kuai[i].rd,i);
    }
    int h = lower_bound(pai + 1, pai + paitail, startx) - pai;
    start_next = query(1, 1, 200000, h, h); if (starty - kuai[start_next].hd>maxt)start_next = -1;
    for(register int i=0;i<=n;i++)
    {
        f[i][0]=f[i][1]=INF;
    }
    f[start_next][0]=abs(duiy[kuai[start_next].ld]-startx);
    f[start_next][1]=abs(duiy[kuai[start_next].rd]-startx);
    for(register int i=start_next;i>=1;i--)
    {
        if(hhnext[i][0]!=-1){
        f[hhnext[i][0]][0]=min(f[hhnext[i][0]][0],f[i][0]+(hhnext[i][0]==0?0:abs(duiy[kuai[hhnext[i][0]].ld]-duiy[kuai[i].ld])));
        f[hhnext[i][0]][1]=min(f[hhnext[i][0]][1],f[i][0]+(hhnext[i][0]==0?0:abs(duiy[kuai[hhnext[i][0]].rd]-duiy[kuai[i].ld])));
        }
        if(hhnext[i][1]!=-1){
        f[hhnext[i][1]][0]=min(f[hhnext[i][1]][0],f[i][1]+(hhnext[i][1]==0?0:abs(duiy[kuai[hhnext[i][1]].ld]-duiy[kuai[i].rd])));
        f[hhnext[i][1]][1]=min(f[hhnext[i][1]][1],f[i][1]+(hhnext[i][1]==0?0:abs(duiy[kuai[hhnext[i][1]].rd]-duiy[kuai[i].rd])));
        }
    }
    //for(register int i=0;i<=n;i++)printf("%d %d\n",f[i][0],f[i][1]);
    int ans=min(f[0][0],f[0][1]);
    ans+=starty;
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：阿丑 (赞：2)

[题目传送门](/problem/P1442)

给出一种用 STL 维护的方法。

#### 前置知识：

set，dp。

#### 题意：

- 给定二维坐标系上的 $n$ 条平行于 $x$ 轴的开线段（横坐标为 $(l_i,r_i)$，纵坐标为 $h_i$）。
- 给定一个球的坐标。若球不在线段上，每秒纵坐标减 $1$；否则，可以选择横坐标加 $1$ 或减 $1$。
- 要求球的纵坐标不能连续减 $h$ 次，问最短多少时间可以使纵坐标为 $0$。保证有解。
- $n\le10^5$，$h_i$ 互不相同，$l_i<r_i$，$\forall i,j,l_i\ne r_j$。

#### 分析：

为方便，增加一条 $0$ 号线段表示 $x$ 轴。

首先，如果球在线段上，那么离开线段前，球一定会一直加横坐标或一直减横坐标，因为回头就会回到上一个时刻的状态，肯定不优。

因此，球落到一个线段上后只有两种情况，启发我们将两种情况所花费的时间分别表示出来，选择其中较小的一种。

具体地，记 $dp_{i,0/1}$ 表示从 $i$ 号线段的左 / 右端点开始下落到纵坐标为 $0$ 所需的最少时间，则，若球从横坐标为 $x_0$ 的位置落在 $i$ 号线段上，则之后所需的最少时间为：

$$
\min(x_0-l_i+dp_{i,0},\,r_i-x_0+dp_{i,1})
$$

考虑 $dp$ 如何转移。如果我们已知从 $i$ 号线段的左端点开始下落会落到 $j$ 号线段，则：

$$
dp_{i,0}=\begin{cases}
h_i&j=0\\
h_i-h_j+\min(l_i-l_j+dp_{j,0},\,r_{j}-l_i+dp_{j,1})&j\ne0
\end{cases}
$$

从 $i$ 号线段的右端点开始下落同理。

现在考虑如何求从一条线段的左、右端点下落会落到哪条线段。自然的想法是按照 $h_i$ 从小到大考虑，并维护从当前 $h_i$ 上每个横坐标下落会落到哪条线段，每次修改相当于将 $(l_i,r_i)$ 的答案改为 $i$。

可以用 set 维护。具体地，在 set 中维护若干二元组 $(x_i,col_i)$，表示从 $(x_{i-1},x_i]$ 这段区间下落的球最后会落到第 $col_i$ 号线段。

初始时 set 中只有两个元素 $(-\infty,0)$，$(\infty,0)$。每次修改需要区间覆盖，即，将满足 $x_j\in(l_i,r_i)$ 的元素删光，再加入元素 $(r_i,i)$，$(l_i,c)$，其中 $c$ 是一个值得考虑的值：$l_i$ 左侧需要保留其原有的颜色，故将原先满足 $x_j\ge l_i$ 的第一个二元组 $(x_j,col_j)$ 的 $col_j$ 作为 $c$。具体操作见代码。

复杂度 $\mathcal O(n\log n)$，理论上常数较大。

---

由于 $l,r$ 的优秀性质，几乎不怎么需要考虑区间的开闭问题。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mN=1e5+9, inf=0x3f3f3f3f;
int n, H, x, y;

struct Line {
	int h, l, r;
} p[mN];

set<pair<int, int> > S;
int dp[mN][2];

inline void update(int &dp, const int x, const int h, const int j) {
//转移
	if(h-p[j].h>H) return;
	if(j) {
		dp=h-p[j].h+min(x-p[j].l+::dp[j][0], p[j].r-x+::dp[j][1]);
	} else {
		dp=h;
	}
}

int main() {
	memset(dp, 0x3f, sizeof dp);

	scanf("%d%d%d%d", &n, &H, &x, &y);
	for(int i=1; i<=n; ++i) {
		scanf("%d%d%d", &p[i].h, &p[i].l, &p[i].r);
	}
	sort(p+1, p+n+1, [](Line x, Line y) {
		return x.h<y.h;
	});

	S.insert({inf, 0});
	S.insert({-inf, 0});	//其实这个元素可以不加
	for(int i=1; i<=n; ++i) {
		const int l=p[i].l, r=p[i].r, h=p[i].h;
		if(h>y) break;
		auto itl=S.lower_bound({l, 0}), itr=S.lower_bound({r, 0});
		/*assert(itl!=S.end()), assert(itr!=S.end());*/
		update(dp[i][0], l, h, itl->second);
		update(dp[i][1], r, h, itr->second);

		const int c=itl->second;
		while(itl->first<=r) {	//删光 l r 之间的元素
			itl=S.erase(itl);
			/*assert(itl!=S.end());*/
		}
		S.insert({l, c}), S.insert({r, i});
	}
	int ans=114514;
	update(ans, x, y, S.lower_bound({x, 0})->second);
	printf("%d\n", ans);
	return 0;
}
```

实在看不懂可以尝试在每次循环后输出 `S` 中的所有元素。 

---

## 作者：0x3F (赞：2)

考虑建图。

小球编号为 $0$，从下往上数第 $i$ 个平台的左端点的编号为 $2i-1$，右端点的编号为 $2i$，地面编号为 $2n+1$。

对于每一个平台，分别判断左端点和右端点分别落在哪一个平台（或地面）上，如果可以下落（即不会摔碎）则分别从该端点向目标平台（如果是平台）的左右端点连边（有向边）。

至于如何判断每一个平台的左右端点分别落在哪一个平台（或地面）上，我们可以先将所有左右端点的坐标离散化，再开一棵线段树维护被离散化的坐标所分割成的线段（而非点）处的“最高海拔”（即当前包含该线段且高度最大的平台的编号），计算完后在将该平台加进去。

最后跑一边最短路即可。

注意：由于所有左右端点共有 $2n$ 个，所以线段树大小应为 $4n$。

具体见代码：

```cpp
#include <bits/stdc++.h>
#define _ 100010
using namespace std;
int n, d, x, y;
vector<pair<int,int> > G[_+_];
int dis[_+_];

void add(int u, int v, int w) {
	G[u].push_back(make_pair(v, w));
}

struct node {
	int h;
	int l;
	int r;
	int ll;
	int rr;
}arr[_];

int lrs[_+_];

bool cmp(node a, node b) {
	return a.h < b.h;
}

struct SEG_TREE {
	int siz;
	struct SEG_TREE_NODE {
		int l;
		int r;
		int ls;
		int rs;
		int mmax;
		int tag;
	}st[_+_+_+_];
	int create_ST (int l, int r) {
		int ret = ++siz;
		st[ret].l = l;
		st[ret].r = r;
		st[ret].mmax = st[ret].tag = 0;
		if (l == r) {
			st[ret].ls = st[ret].rs = -1;
		} else {
			int mid = (l + r) >> 1;
			st[ret].ls = create_ST(l , mid);
			st[ret].rs = create_ST(mid+1,r);
		}
		return ret;
	}
	void cover(int p, int l, int r, int k) {
		if (st[p].l == l && st[p].r == r) {
			st[p].tag = max(st[p].tag, k);
			st[p].mmax = max(st[p].mmax, k);
		} else {
			int mid = (st[p].l + st[p].r) >> 1;
			if (r <= mid) cover(st[p].ls, l, r, k);
			else if (l > mid) cover(st[p].rs, l, r, k);
			else cover(st[p].ls, l, mid, k), cover(st[p].rs, mid+1, r, k);
		}
	}
	int calc(int p, int l, int r) {
		if (st[p].l == l && st[p].r == r) {
			return st[p].mmax;
		} else {
			int mid = (st[p].l + st[p].r) >> 1;
			st[st[p].ls].tag = max(st[st[p].ls].tag, st[p].tag);
			st[st[p].rs].tag = max(st[st[p].rs].tag, st[p].tag);
			st[st[p].ls].mmax = max(st[st[p].ls].mmax, st[p].tag);
			st[st[p].rs].mmax = max(st[st[p].rs].mmax, st[p].tag);
			st[p].tag = 0;
			if (r <= mid) return calc(st[p].ls, l, r);
			else if (l > mid) return calc(st[p].rs, l, r);
			else return max(calc(st[p].ls, l, mid), calc(st[p].rs, mid+1, r));
		}
	}
}ST;

int main() {
	cin >> n >> d >> x >> y;
	for (int i = 1; i <= n; i++) {
		cin >> arr[i].h >> arr[i].l >> arr[i].r;
		lrs[i*2-1] = arr[i].l;
		lrs[i*2] = arr[i].r;
	}
	sort(arr+1, arr+n+1, cmp);
	sort(lrs+1, lrs+n+n+1);
	int s = unique(lrs+1, lrs+n+n+1)-lrs-1;
	ST.create_ST(0, s+1);
	for (int i = 1; i <= n; i++) {
		arr[i].ll = upper_bound(lrs+1, lrs+n+n+1, arr[i].l) - lrs - 1;
		arr[i].rr = upper_bound(lrs+1, lrs+n+n+1, arr[i].r) - lrs - 1;
		int L = ST.calc(1, arr[i].ll-1, arr[i].ll-1);
		int R = ST.calc(1, arr[i].rr, arr[i].rr);
		if (arr[i].h - arr[L].h <= d) {
			if (L) {
				add(i*2-1, L*2-1, arr[i].h - arr[L].h + arr[i].l - arr[L].l);
				add(i*2-1, L*2  , arr[i].h - arr[L].h + arr[L].r - arr[i].l);
			} else {
				add(i*2-1, n*2+1, arr[i].h);
				add(i*2  , n*2+1, arr[i].h);
			}
		}
		if (arr[i].h - arr[R].h <= d) {
			if (R) {
				add(i*2, R*2-1, arr[i].h - arr[R].h + arr[i].r - arr[R].l);
				add(i*2, R*2  , arr[i].h - arr[R].h + arr[R].r - arr[i].r);
			} else {
				add(i*2-1, n*2+1, arr[i].h);
				add(i*2  , n*2+1, arr[i].h);
			}
		}
		ST.cover(1, arr[i].ll, arr[i].rr-1, i);
	}
	int X = lower_bound(lrs+1, lrs+n+n+1, x) - lrs - 1;
	int T = ST.calc(1, X, X);
	add(0, T*2-1, y - arr[T].h + x - arr[T].l);
	add(0, T*2  , y - arr[T].h + arr[T].r - x);
	memset(dis, 0x3F, sizeof(dis));
	priority_queue<pair<int,int> > Q;
	Q.push(make_pair(0, 0));
	while (!Q.empty()) {
		int u = Q.top().second;
		int d = -Q.top().first;
		Q.pop();
		if (d >= dis[u]) continue;
		dis[u] = d;
		if (u == n*2+1) {
			cout << d << endl;
			return 0;
		}
		for (int i = 0; i < G[u].size(); i++) {
			int v = G[u][i].first;
			int w = G[u][i].second;
			Q.push(make_pair(-(d+w), v));
		}
	}
}
```

---

## 作者：散华礼弥 (赞：2)

### 线段树 + DP

先把平台离散化，然后用线段树更新并查询当前落点在哪个平台，这里的线段树只需要区间赋值和单点查询操作即可，所以标记数组也可以省略，每次的下放操作需要清除一下非叶节点的值

$dp[i][0/1]$ 分别表示$i$号平台从上转移过来并向左走或向右走的最小值，转移的时候也是从高往低转移，还要先初始化一下小球第一个落到的平台，并特判如果落点是地面，就更新一下答案

最后输出答案即可，代码如下(注意离散数组要开两倍，线段树开八倍哇)

```cpp
#include <cctype>
#include <cstdio>
#include <algorithm>

#define MAXN 100010
#define INF 0x3f3f3f3f
#define mid ((l + r) >> 1)

void read(int &res)
{
    char ch = getchar();
    res = 0;
    for (; !std::isdigit(ch); ) ch = getchar();
    for (; std::isdigit(ch); ) res = (res << 1) + (res << 3) + (ch ^ 48), ch = getchar();
}

struct Roof
{
    int l, r, ll, rr, lx, rx, h;

    bool operator < (const Roof &A) const
    {
        return h < A.h;
    }
} a[MAXN];

struct Point
{
    int id, pos;

    bool operator < (const Point &A) const
    {
        return pos < A.pos;
    }
} b[MAXN << 1];

int n, Max, x, y, N, L, R, val, ans = INF, dp[MAXN][2], tree[MAXN << 3];

void update(int rt, int l, int r)
{
    if (l >= L && r <= R)
    {
        tree[rt] = val;
        return ;
    }
    if (tree[rt])
    {
        tree[rt << 1] = tree[rt << 1 | 1] = tree[rt];
        tree[rt] = 0;
    }
    if (L <= mid)
        update(rt << 1, l, mid);
    if (R > mid)
        update(rt << 1 | 1, mid + 1, r);
}

int query(int rt, int l, int r)
{
    if (l == L && r == L)
        return tree[rt];
    if (tree[rt])
    {
        tree[rt << 1] = tree[rt << 1 | 1] = tree[rt];
        tree[rt] = 0;
    }
    if (L <= mid)
        return query(rt << 1, l, mid);
    else
        return query(rt << 1 | 1, mid + 1, r);
}

int main()
{
    read(n), read(Max), read(x), read(y);
    for (int i = 1; i <= n; ++i)
    {
        b[N + 1].id = b[N + 2].id = i;
        read(a[i].h), read(a[i].ll), read(a[i].rr);
        b[++N].pos = a[i].ll, b[++N].pos = a[i].rr;
    }
    a[0].h = 0;
    std::sort(b + 1, b + N + 1);
    for (int i = 1; i <= N; ++i)
        a[b[i].id].r = i;
    for (int i = N; i; --i)
        a[b[i].id].l = i;
    std::sort(a + 1, a + n + 1);
    for (int i = 1; i <= n; ++i)
    {
        dp[i][0] = dp[i][1] = INF;
        L = a[i].l, a[i].lx = query(1, 1, N), L = a[i].r, a[i].rx = query(1, 1, N);
        if (a[i].h - a[a[i].lx].h > Max)
            a[i].lx = -1;
        if (a[i].h - a[a[i].rx].h > Max)
            a[i].rx = -1;
        L = a[i].l, R = a[i].r, val = i;
        update(1, 1, N);
    }
    if (a[n].lx != -1)
        dp[n][0] = x - a[n].ll + y - a[n].h;
    if (a[n].rx != -1)
        dp[n][1] = a[n].rr - x + y - a[n].h;
    for (int u = n, v; u; --u)
    {
        if (a[u].lx != -1)
        {
            if (a[u].lx)
            {
                v = a[u].lx;
                dp[v][0] = std::min(dp[v][0], dp[u][0] + a[u].h - a[v].h + a[u].ll - a[v].ll);
                dp[v][1] = std::min(dp[v][1], dp[u][0] + a[u].h - a[v].h + a[v].rr - a[u].ll);
            }
            else
                ans = std::min(ans, dp[u][0] + a[u].h);
        }
        if (a[u].rx != -1)
        {
            if (a[u].rx)
            {
                v = a[u].rx;
                dp[v][0] = std::min(dp[v][0], dp[u][1] + a[u].h - a[v].h + a[u].rr - a[v].ll);
                dp[v][1] = std::min(dp[v][1], dp[u][1] + a[u].h - a[v].h + a[v].rr - a[u].rr);
            }
            else
                ans = std::min(ans, dp[u][1] + a[u].h);
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：xkcdjerry (赞：1)

好题

考虑显然做法：令 $f_{i,0}$，$f_{i,1}$ 分别为球从第 $i$ 个板子的左边和右边滚落后**横向移动**的最短距离（因为下落时间固定为 $y$ 所以可以放到最后考虑）。那么可以假设掉落后会掉到 $x$ 板上，则有：

$f_{i,0}=\min(l_i-l_x+f_{x,0},r_x-l_i+f_{x,1})$  
$f_{i,1}=\min(r_i-l_x+f_{x,0},r_x-r_i+f_{x,1})$

如果按 $y$ 坐标升序排序，可以保证 $x$ 在 $i$ 前被处理，但是处理 $2n$ 个点下落后的板子需要 $O(n^2)$ 的时间，对于 $n \leqslant 10^5$ 的数据范围是不可以接受的。

由于按 $y$ 排序后本质是求某个 $x$ 下方最高的板子，可以联想到染色问题求的是某个点最后一个染上的颜色。即利用线段树解决。由于数据范围为 $l_i,r_i \leqslant 10^9$ 故需要离散化。

然后就做完了（？），从下往上每次先查询两个端点下面的板子是什么，然后把这个区间插入进线段树里。注意，虽然球的体积无限小但是仍然可以被板子的边接住，所以插入的时候要包括两个端点。

球所落到的板子可以在求各个端点下落时 $O(\log n)$ 求但是那样会增加很多不必要的代码复杂度，既然只求一次可以直接最后 $O(n)$ 求。注意球所遇到的第一个板子也可以选择往左或者往右滚所以也要两个取 $\min$。

蒟蒻的代码：
```c++
#include <cstdio>
#include <algorithm>
#define N 100010
#define s tree[o]
struct seg{int l,r,lazy;}tree[N*8];
void pushdown(int o)
{
    if(s.lazy==-1) return;
    tree[o<<1].lazy=tree[o<<1|1].lazy=s.lazy;
    s.lazy=-1;
}
void cover(int l,int r,int c,int o=1)
{
    if(s.l==l&&s.r==r) {s.lazy=c; return;}
    int mid=(s.l+s.r)/2;
    pushdown(o);
    if(r<=mid) cover(l,r,c,o<<1);
    else if(l>mid) cover(l,r,c,o<<1|1);
    else {cover(l,mid,c,o<<1); cover(mid+1,r,c,o<<1|1);}
}
int query(int x,int o=1)
{
    if(s.l==x&&s.r==x) return s.lazy;
    int mid=(s.l+s.r)/2;
    pushdown(o);
    return query(x,x<=mid?o<<1:o<<1|1);
}
void mktree(int l,int r,int o=1)
{
    s.l=l;s.r=r;s.lazy=-1;
    if(l!=r)
    {
        int mid=(l+r)/2;
        mktree(l,mid,o<<1);
        mktree(mid+1,r,o<<1|1);
    }
}
struct board{int l,r,h;bool operator<(board b) const{return h<b.h;}}a[N];
int n,t[N*2],f[N][2],g[N][2];
inline int min(int x,int y){return x<y?x:y;}
//从x处落到z板后落地的最小时间
inline int calc(int x,int z)
    {return min(x-t[a[z].l]+f[z][0],t[a[z].r]-x+f[z][1]);}
int main()
{
    int h;
    scanf("%d%d",&n,&h);
    int x,y;
    scanf("%d%d",&x,&y);
    for(int i=0;i<n;i++)
    {
        int h,l,r;
        scanf("%d%d%d",&h,&l,&r);
        a[i]=board{l,r,h};
        t[i<<1]=l,t[i<<1|1]=r;
    }
    //O(nlogn)离散化
    std::sort(t,t+2*n);
    for(int i=0;i<n;i++)
    {
        a[i].l=std::lower_bound(t,t+2*n,a[i].l)-t;
        a[i].r=std::lower_bound(t,t+2*n,a[i].r)-t;
    }
    std::sort(a,a+n);
    mktree(0,2*n-1);//初始化为-1
    //O(nlogn)预处理
    for(int i=0;i<n;i++)
    {
        int x=query(a[i].l),mn=a[i].h-h;
        g[i][0]=a[x].h>=mn?x:-2;
        x=query(a[i].r);
        g[i][1]=a[x].h>=mn?x:-2;
        cover(a[i].l,a[i].r,i);
    }
    //O(n) DP
    for(int i=0;i<n;i++)
    {
        f[i][0]=f[i][1]=0x3f3f3f3f;
        if(g[i][0]!=-2)
        {
            //从左侧落下
            int x=g[i][0],y=a[i].l;
            //地面
            if(x==-1) f[i][0]=0;
            else f[i][0]=calc(t[a[i].l],x);
        }
        if(g[i][1]!=-2)
        {
            //从右侧
            int x=g[i][1],y=a[i].r;
            if(x==-1) f[i][1]=0;
            else f[i][1]=calc(t[a[i].r],x);
        }
    }
    //O(n)寻找球落点
    int z=-1;
    for(int i=n-1;i>=0;i--)
        if(a[i].h<=y&&t[a[i].l]<=x&&x<=t[a[i].r]) {z=i;break;}
    printf("%d",(z!=-1?calc(x,z):0)+y);
}
```

[提交记录](https://www.luogu.com.cn/record/72644677)（有小幅压缩）

---

## 作者：金爷爷哈哈 (赞：1)

线段树+DP。

先按板的高度排序，之后通过线段树区间Tag预处理出每个板的左端点和右端点可以落到哪个板上（注意如果超过最大限制高度则不能下落）。

再之后dp就可以了，取向左走和向右走的最优值（因为最优情况肯定不会在 一个板上走回头路）.


code:





    

    

    
    
    

    
    
    
    
    
    
        
        
        
    
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
#define maxn 100005
struct node{
    ll l,r,al,ar,h;
}pl[maxn];
bool cmp(node x,node y){
    return(x.h<y.h);    
}
ll a[maxn<<1],n,m,mx,N;
ll f[maxn][2],p[maxn][2];
ll se[maxn*9],le,ri,v,beg;
inline ll mabs(ll x){ return(x>0?x:-x); }
inline void pushdown(ll o){
    if(se[o]){
       ll lc=o<<1,rc=(o<<1)|1;
       se[lc]=se[rc]=se[o];
       se[o]=0;
    }
}
void update(ll o,ll l,ll r){
    if(l>=le&&r<=ri){
        se[o]=v;
        return;
    }
    pushdown(o);
    ll mid=l+r>>1,lc=o<<1,rc=(o<<1)|1;
    if(le<=mid) update(lc,l,mid);
    if(ri>mid) update(rc,mid+1,r);
}
ll query(ll o,ll l,ll r){
    if(se[o]) return se[o];
    if(l==r) return 0;
    ll mid=l+r>>1,lc=o<<1,rc=(o<<1)|1;
    if(le<=mid) return query(lc,l,mid);
    else return query(rc,mid+1,r);    
}
ll dp(ll x,ll pos){
    if(p[x][pos]) return p[x][pos];
    ll now=(pos?pl[x].r:pl[x].l);
    p[x][pos]=(ll)(1<<30);
    if(!f[x][pos]) p[x][pos]=min(p[x][pos],(ll)0);
    else if(f[x][pos]>0) p[x][pos]=min(p[x][pos],min(dp(f[x][pos],0)+mabs(now-pl[f[x][pos]].l),dp(f[x][pos],1)+mabs(now-pl[f[x][pos]].r)));
    return p[x][pos];
}
int main(){
    cin>>n>>mx;
    n++;
    scanf("%lld%lld",&pl[n].l,&pl[n].h),pl[n].r=pl[n].l;
    a[1]=pl[n].l;
    for(int i=1;i<n;i++){
        scanf("%lld%lld%lld",&pl[i].h,&pl[i].l,&pl[i].r);
        a[i<<1]=pl[i].l,a[(i<<1)|1]=pl[i].r;
    }
    N=(n<<1)-1;
    sort(a+1,a+N+1);
    for(int i=1;i<=n;i++) pl[i].al=lower_bound(a+1,a+N+1,pl[i].l)-a,pl[i].ar=lower_bound(a+1,a+N+1,pl[i].r)-a;
    sort(pl+1,pl+n+1,cmp);
    pl[0].h=0;
    for(int i=1;i<=n;i++){
        le=pl[i].al;
        f[i][0]=query(1,1,N);
        if(pl[i].h-pl[f[i][0]].h>mx) f[i][0]=-1;
        le=pl[i].ar;
        f[i][1]=query(1,1,N);
        if(pl[i].h-pl[f[i][1]].h>mx) f[i][1]=-1;
        if(pl[i].l==pl[i].r) beg=i;        
        ri=le,le=pl[i].al,v=i;
        update(1,1,N);
    }
    printf("%lld\n",dp(beg,0)+pl[beg].h);
    return 0;
}

```

---

## 作者：HomuraCat (赞：0)

╮(╯_╰)╭一道码力题。对于我这种蒟蒻超级不友好

直接用线段树作预处理，从下往上扫描线，预处理出每个线段在左边跳和在右边跳能跳到哪一条线段。

接着我们可以打个dp，$dp[i][0/1]$表示起点到达第i个线段左边/右边要多少时间，地面特判一下就行了。

先前疯狂WA，后来自己和std拍出一个数据，才发现自己的flag标记在pushdown的时候没有下放（真的蠢），所以这组数据就放这了。

一个拍出来的数据：

5 3

11 11

1 3 33

2 4 55

4 3 44

7 7 11

9 11 16

输出19


代码：
```cpp
#include<bits/stdc++.h>
#define fo(i, a, b) for (Re int i = (a); i <= (b); ++i)
#define fd(i, a, b) for (Re int i = (a); i >= (b); --i)
#define edge(i, u) for (Re int i = head[u], v = e[i].v; i; i = e[i].nxt, v = e[i].v)
#define N 200005
#define Re register
#define pb push_back
#define F first
#define S second
#define ll long long
#define inf 1000000007
#define mp std::make_pair
#define lowbit(x) (x & -x)
#define ls (k << 1)
#define rs (k << 1 | 1)
#define mod 1000000007
int n, T, X, Y, a[N], tot, cnt, ans, x, y, w, i, pos, now, dp[N][2], L, R, m, X0, Y0;
struct line{
    int x1, x2, y, l, r;
    friend bool operator < (line qwq, line qaq)
    {
        return qaq.y < qwq.y;
    }
}p[N];
struct tree{
    int v;
    bool flag;
}t[N << 2];
inline void pushdown (int k)
{
    if (t[k].flag)
    {
        t[k].flag = 0;
        t[ls].v = t[rs].v = t[k].v;
        t[rs].flag = t[ls].flag = 1;
    }
}
inline void add (int k, int l, int r)
{
    if (L <= l && R >= r)
    {
        t[k].v = i;
        t[k].flag = 1;
        return;
    }
    pushdown(k);
    int mid = l + r >> 1;
    if (L <= mid) add(ls, l, mid);
    if (mid < R) add(rs, mid + 1, r);
}
inline int query (int k, int l, int r)
{
    if (t[k].flag && l <= now && now <= r || l == r && l == now)
    {
        return t[k].v;
    }
    pushdown(k);
    int mid = l + r >> 1;
    if (now <= mid) return query(ls, l, mid);
    if (mid < now) return query(rs, mid + 1, r);
}
inline int abs (int x) {return x < 0 ? -x : x;}
inline int dis (int x1, int y1, int x2, int y2) {return abs(x1 - x2) + abs(y1 - y2);}
int main ()
{
    scanf("%d %d", &n, &m);
    scanf("%d %d", &X0, &Y0);
    fo (i, 1, n)
    {
        scanf("%d %d %d", &p[i].y, &p[i].x1, &p[i].x2);
        a[i] = p[i].x1;
        a[i + n] = p[i].x2;
    }
    std::sort(a + 1, a + n + n + 1);
    cnt = std::unique(a + 1, a + n + n + 1) - a - 1;
    std::sort(p + 1, p + n + 1);//y值从高到低
    fo (i, 1, n)
        if (p[i].y <= Y0 && p[i].x1 <= X0 && p[i].x2 >= X0)
        {
            pos = i;
            break;
        }
    int j;
    i = 0;
    L = 1; R = cnt;
    add(1, 1, cnt);
    for (i = n; i; --i)
    {
        now = std::lower_bound(a + 1, a + cnt + 1, p[i].x1) - a;
        j = query(1, 1, cnt);
        if (p[i].y - p[j].y <= m) p[i].l = j; else p[i].l = -1;
        now = std::lower_bound(a + 1, a + cnt + 1, p[i].x2) - a;
        j = query(1, 1, cnt);
        if (p[i].y - p[j].y <= m) p[i].r = j; else p[i].r = -1;
        L = std::lower_bound(a + 1, a + cnt + 1, p[i].x1) - a;
        R = std::lower_bound(a + 1, a + cnt + 1, p[i].x2) - a;
        add(1, 1, cnt);
    }
    memset(dp, 0x3f, sizeof dp);
//    fo (i, 1, n)
//        printf("i = %d l = %d r = %d\n", i, p[i].l, p[i].r);
    dp[pos][0] = dis(X0, Y0, p[pos].x1, p[pos].y);
    dp[pos][1] = dis(X0, Y0, p[pos].x2, p[pos].y);
    fo (i, 1, n)
    {
        int nxt = p[i].l;
        if (nxt != -1)
        {
            if (!nxt)
                dp[0][0] = std::min(dp[0][0], dp[i][0] + p[i].y);
            else
            {
                dp[nxt][0] = std::min(dp[nxt][0], dp[i][0] + dis(p[i].x1, p[i].y, p[nxt].x1, p[nxt].y));
                dp[nxt][1] = std::min(dp[nxt][1], dp[i][0] + dis(p[i].x1, p[i].y, p[nxt].x2, p[nxt].y));
            }
        }
        nxt = p[i].r;
        if (nxt != -1)
        {
            if (!nxt)
                dp[0][0] = std::min(dp[0][0], dp[i][1] + p[i].y);
            else
            {
                dp[nxt][0] = std::min(dp[nxt][0], dp[i][1] + dis(p[i].x2, p[i].y, p[nxt].x1, p[nxt].y));
                dp[nxt][1] = std::min(dp[nxt][1], dp[i][1] + dis(p[i].x2, p[i].y, p[nxt].x2, p[nxt].y));
            }
        }
    }
    printf("%d\n", dp[0][0]);
    return 0;
}
```

---


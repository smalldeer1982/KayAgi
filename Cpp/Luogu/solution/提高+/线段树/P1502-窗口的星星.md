# 窗口的星星

## 题目背景

小卡买到了一套新房子，他十分的高兴，在房间里转来转去。


## 题目描述

晚上，小卡从阳台望出去，“哇~~~~好多星星啊”，但他还没给其他房间设一个窗户。   

天真的小卡总是希望能够在晚上能看到最多最亮的星星，但是窗子的大小是固定的，边也必须和地面平行。  

这时小卡使用了超能力（透视术）知道了墙后面每个星星的位置和亮度，但是小卡发动超能力后就很疲劳，只好拜托你告诉他最多能够有总和多亮的星星能出现在窗口上。


## 说明/提示

为了便于理解，输入样例中每组数据之间添加了空行，实际测试数据中并无空行。

小卡买的窗户框是金属做的，所以在边框上的不算在内。

### 数据范围

对于 $100\%$ 的数据：$1\le T \le 10$，$1\le n \le 10^4$，$1\le W,H \le 10^6$，$0\le l_i\le 1000$，$0\le x_i,y_i < 2^{31}$。

## 样例 #1

### 输入

```
2

3 5 4
1 2 3
2 3 2
6 3 1

3 5 4
1 2 3
2 3 2
5 3 1```

### 输出

```
5
6
```

# 题解

## 作者：Diaоsi (赞：139)

[窗口的星星](https://www.luogu.com.cn/problem/P1502)

题意不再过多赘述，首先我们思考一个问题，就是在什么条件下星星才会出现在窗户中。

设某颗星星的坐标为 $(x,y)$ ，则当窗户的右上角端点的坐标出现在 $(x\sim x+w-1,y\sim y+h-1)$ 这个范围内时，星星就会出现在窗户里。

如下图：

![星星1](https://cdn.luogu.com.cn/upload/image_hosting/koqij4kr.png)

因为题目中说出现在窗户边框的星星不算，我们不妨将边框长宽都减小 $0.5$ ，所以边界坐标要 $-1$ ，即 $(x+w-1,y+h-1)$ 。

于是我们可以将每个星星都扩展成一个矩形，这时我们注意到，若两个矩形之间有交集，他们便可以放在同一个窗户中。

如下图：

![星星2](https://cdn.luogu.com.cn/upload/image_hosting/p295zpbp.png)

图中灰色的部分就是两个星星构成的矩形的交集，只要窗户的右上角端点在灰色区域内，就能同时框住两个星星。

此时我们可以将问题转化为：平面上有若干个矩形，每个矩形都带有一个权值，求在哪个坐标上权值的总和最大。

接下来我们就可以使用扫描线来解决这个问题了，若当前星星的亮度值为 $l$ ,则矩形的入边的权值设为 $l$ ，出边为 $-l$ ，此时我们只要求扫描线上的区间最大值即可得出答案，区间查询可以使用 lazy_tag 的方式实现。

**代码实现上的一些小细节：**

- 在对 $x$ 坐标进行升序排序时，将 $val$ 值按降序排序，这样才能处理两个矩形贴合的情况。
- 观察到 $0 \leq x_i,y_i \leq 2^{31}$ 所以我们需要将坐标进行离散化处理。

既然你能找到这题，我相信你能瞬间做出来的。

```Code:```

```cpp
#include<bits/stdc++.h>
typedef long long LL;
typedef long double LD;
using namespace std;//你在看我的代码对吧 
const LL N=100010;
inline int max(int x,int y){return x>y?x:y;}
inline int min(int x,int y){return x<y?x:y;}
inline void swap(int &x,int &y){x^=y^=x^=y;}
LL T,n,w,h,C[N];
struct Segment{
	LL l,r,h;
	LL val;
	bool operator <(const Segment &a)const{
		return (h!=a.h)?h<a.h:val>a.val;
	}
}Seg[N<<2];
struct SegmentTree{
	LL l,r;
	LL mx,add;
	#define l(x) tree[x].l
	#define r(x) tree[x].r
	#define mx(x) tree[x].mx
	#define add(x) tree[x].add
}tree[N<<2];
void init(){
	memset(Seg,0,sizeof(Seg));
	memset(tree,0,sizeof(tree));
}
void Pushup(LL x){
	mx(x)=max(mx(x<<1),mx(x<<1|1));
}
void Build(LL x,LL l,LL r){
	l(x)=l,r(x)=r,mx(x)=add(x)=0;
	if(l==r)return;
	LL mid=(l+r)>>1;
	Build(x<<1,l,mid);
	Build(x<<1|1,mid+1,r);
}
void Pushdown(LL x){
	mx(x<<1)+=add(x);
	mx(x<<1|1)+=add(x);
	add(x<<1)+=add(x);
	add(x<<1|1)+=add(x);
	add(x)=0;
}
void Change(LL x,LL L,LL R,LL d){
	LL l=l(x),r=r(x);
	if(L<=l&&r<=R){
		mx(x)+=d;
		add(x)+=d;
		return;
	}
	Pushdown(x);
	LL mid=(l+r)>>1;
	if(L<=mid)Change(x<<1,L,R,d);
	if(R>mid)Change(x<<1|1,L,R,d);
	Pushup(x);
}
int main(){
	scanf("%lld",&T);
	while(T--){
		init();
		scanf("%lld%lld%lld",&n,&w,&h);
		for(LL i=1;i<=n;i++){
			LL x,y,l;
			scanf("%lld%lld%lld",&x,&y,&l);
			C[(i<<1)-1]=y;
			C[i<<1]=y+h-1;
			Seg[(i<<1)-1]=(Segment){y,y+h-1,x,l};
			Seg[i<<1]=(Segment){y,y+h-1,x+w-1,-l};
		}
		n<<=1;
		sort(C+1,C+n+1);
		sort(Seg+1,Seg+n+1);
		LL cnt=unique(C+1,C+n+1)-C-1;
		for(LL i=1;i<=n;i++){
			LL pos1=lower_bound(C+1,C+cnt+1,Seg[i].l)-C;
			LL pos2=lower_bound(C+1,C+cnt+1,Seg[i].r)-C;
			Seg[i].l=pos1;
			Seg[i].r=pos2;
		}
		Build(1,1,cnt);
		LL ans=0;
		for(LL i=1;i<=n;i++){
			Change(1,Seg[i].l,Seg[i].r,Seg[i].val);
			ans=max(ans,mx(1));
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```



---

## 作者：Michael_Li (赞：46)

可以说是为上一篇题解做一个补充，如果你会扫描线，那么上一篇题解你肯定能看懂，如果你不会，你可以看一下这篇题解，有一个入门了解。

首先把窗户的左下点放在一个点上肯定是比较优的，所以我们把每个星星都扩展成一个矩形(x,y)-->(x+w-1,y+h-1),如果两个星星的矩形相交(注意减不减一带来相交规则的不同)，我们肯定能够将这两个星星放在一个窗户里，反之则不行。

离散化，我们的线段树是基于x离散后的值的。

我们把x离散后，left[i],right[i]表示i这个矩形的左右边界，离散后的值

然后扫描线从下往上扫，每找到一条矩形的下边，就在它覆盖区间中找一个最大的，所以就是区间最大值。

然后不论是上边还是下边，区间加一下就好了，注意把上边的边权转为负的
```cpp
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<cstring>
#define LL long long
#define N (100001)
using namespace std;
template <typename T> void read(T&t) {
	t=0;
	bool fl=true;
	char p=getchar();
	while (!isdigit(p)) {
		if (p=='-') fl=false;
		p=getchar();
	}
	do {
		(t*=10)+=p-48;p=getchar();
	}while (isdigit(p));
	if (!fl) t=-t;
}
int t,n,W,H,tot,cnt,maxans;
int left[N],right[N]; 
struct star{
	int x,y,l,id;
	bool fl;
}a[N],b[N];
struct node{
	int l,r,lazy,v;
}T[N<<2];
inline bool cmp(star a,star b){
	return a.x<b.x;
}
inline bool cmp1(star a,star b){
	return a.y==b.y?a.l>b.l:a.y<b.y;
}
void build(int u,int l,int r){
	T[u].lazy=T[u].v=0;
	T[u].l=l,T[u].r=r;
	if (l==r) return; 
	int mid=l+r>>1,kk=u<<1;
	build(kk,l,mid);
	build(kk|1,mid+1,r);
}
void pushdown(int u){
	if (T[u].lazy){
		int aa=T[u].lazy,kk=u<<1;
		T[u].lazy=0;
		T[kk].v+=aa;
		T[kk].lazy+=aa;
		T[kk|1].v+=aa;
		T[kk|1].lazy+=aa;
	}
}
int query(int u,int L,int R){
	if (L<=T[u].l&&T[u].r<=R) return T[u].v;
	pushdown(u);
	int ret=0,k=u<<1,mid=T[u].l+T[u].r>>1;
	if (L<=mid) ret=query(k,L,R);
	if (R>mid) ret=max(ret,query(k|1,L,R));
	return ret;
}
void add(int u,int L,int R,int k){
	if (L<=T[u].l&&T[u].r<=R){
		T[u].v+=k;
		T[u].lazy+=k;
		pushdown(u);
		return;
	}
	pushdown(u);
	int mid=T[u].l+T[u].r>>1,vv=u<<1;
	if (L<=mid) add(vv,L,R,k);
	if (R>mid) add(vv|1,L,R,k);
	T[u].v=max(T[vv].v,T[vv|1].v);
}
int main(){
	read(t);
	while (t--){
		cnt=tot=maxans=0;
		read(n),read(W),read(H);
		for (int i=1;i<=n;i++){
			read(a[i].x),read(a[i].y),read(a[i].l);
			a[i].id=i; a[i].fl=0;
			b[i].y=a[i].y,b[i].l=a[i].l;
			b[i].id=i;
		}
		tot=n;
		for (int i=1;i<=n;i++){
			a[++tot].x=a[i].x+W-1;
			a[tot].id=i;
			a[tot].fl=1;
		}
		sort(a+1,a+tot+1,cmp);
		for (int i=1;i<=tot;i++){
			int tt=0;
			if (a[i].x==a[i-1].x&&i!=1) tt=cnt;
			else tt=++cnt;
			if (!a[i].fl) left[a[i].id]=tt;
			else right[a[i].id]=tt;
		}
		//for (int i=1;i<=n;i++) printf("%d %d\n",left[i],right[i]);
		tot=n;
		for (int i=1;i<=n;i++){
			b[++tot].y=b[i].y+H-1;
			b[tot].l=-b[i].l;
			b[tot].id=b[i].id;
		}
		sort(b+1,b+tot+1,cmp1);
//		for (int i=1;i<=tot;i++) printf("%d %d %d\n",b[i].id,b[i].y,b[i].l);
		build(1,1,cnt);
		for (int i=1;i<=tot;i++){
			if (b[i].l>0){
				int num=query(1,left[b[i].id],right[b[i].id]);
				//printf(" %d %d %d\n",left[b[i].id],right[b[i].id],num);
				if (num+b[i].l>maxans) maxans=num+b[i].l;
			}
			add(1,left[b[i].id],right[b[i].id],b[i].l);
		}
		printf("%d\n",maxans);
	}
	return 0;
}

```

---

## 作者：ysj1173886760 (赞：34)

题意大致是给出若干个点以及点的权值，给出一个矩形，求矩形能框住的最大的权值是多少。

我们将双方的角色转换一下，将这些点看做是一个个矩形的左下角的点(x,y)，那么(可以框住这个点的矩形)的右上角点坐标的集合(说集合不太严谨)就可以看做是一个矩形，其右上角为 (x+w,y+h)。

那么问题就转化为给出若干个带权值的矩形，求最大的矩形交。（稍微有点不同，这个不是面积）

题中有说窗户的边缘不能算，为了让所有的矩形区间都是闭的，不妨让矩形上下左右都缩小0.5，同时题中有说所有坐标都是整数，那么+-0.5就没有影响了，所以最终得出的矩形就是一个实边的矩形。
左下角坐标为(x,y),右上角坐标为(x+w-1,y+h-1)


注意到因为一般的扫描线算法中线段树里叶子节点i表示线段[i,i+1],也就是一个[l,r] 的线段在线段树中涵盖的区间是[l,r-1]

这道题主要处理的就是相交情况。而且问题中的点全都是离散的，不存在浮点数，所以最后算下来就变成了一个区间加，区间求最值的问题。

还有一点要注意的是在根据横坐标排序的时候，如果横坐标相同也就是线段重合的时候。注意先加上新的再减去旧的，否则重合的情况就没被算到。

最后上代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define mid ((l+r)>>1)
using namespace std;

const int maxn=1e4+10;
int n,tot,w,h;
int yy[maxn<<1];					//离散化的y轴 
int rm[maxn<<3],flag[maxn<<3];		//rm表示区间最大值，flag为懒标记 八倍数组，因为2n条线段，线段树要4倍。 
struct seg
{
    int x,y1,y2,c;
    seg(){}
    seg(int xx,int yy1,int yy2,int cc){x=xx,y1=yy1,y2=yy2,c=cc;}
}line[maxn<<1];

bool cmp(const seg &a,const seg &b)//这里注意排序，x相同时先处理入边 
{
	if(a.x==b.x)return a.c>b.c;
    return a.x<b.x;
}
void pushdown(int t,int l,int r)//下传懒标记 
{
    if(flag[t]==0)return;
    rm[t]+=flag[t];
    if(l!=r)		//这里主要防止越界 
    {
        flag[t<<1]+=flag[t];
        flag[t<<1|1]+=flag[t];
    }
    flag[t]=0;
}
void modify(int t,int l,int r,int x,int y,int z)//区间修改 
{
    if(x<=l&&r<=y)
    {
        flag[t]+=z;
        return;
    }
    if(x<=mid)modify(t<<1,l,mid,x,y,z);
    if(y>mid)modify(t<<1|1,mid+1,r,x,y,z);
    pushdown(t<<1,l,mid);
    pushdown(t<<1|1,mid+1,r);
    rm[t]=max(rm[t<<1],rm[t<<1|1]);	//回传最值 
}
int main()
{
    int t=0;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d %d %d",&n,&w,&h);
        memset(rm,0,sizeof(rm));
        memset(flag,0,sizeof(flag));
        for(int i=1;i<=n;i++)
        {
            int x=0,y=0,c=0;
            scanf("%d %d %d",&x,&y,&c);
            line[i]=seg(x,y,y+h-1,c);
            line[i+n]=seg(x+w-1,y,y+h-1,-c);
            yy[i]=y+h-1;
            yy[i+n]=y;
        }
        n<<=1;//处理的是2n条线段 
        sort(yy+1,yy+1+n);//排序 
        tot=unique(yy+1,yy+1+n)-yy-1;//去重 
        sort(line+1,line+1+n,cmp);//根据横坐标排序 
        int ans=0;
        for(int i=1;i<=n;i++)
        {
            int l=lower_bound(yy+1,yy+1+tot,line[i].y1)-yy;//二分离散化 
            int r=lower_bound(yy+1,yy+1+tot,line[i].y2)-yy;
            modify(1,1,tot,l,r,line[i].c);//修改，这里注意是l和r，一开始我写的r-1竟然对了9个（但实际上是错误的） 
            ans=max(ans,rm[1]);//每次更新最值 
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

最后告诫自己，具体问题具体分析，本来一开始看到这题直接套了扫描线的板子，后来自己跑了一遍才明白

---

## 作者：7KByte (赞：24)

网上的题解都是将问题转化为求$N$个矩形的最大面积交集（感觉都一个人写的

这里提供一个不同的思维过程

---------------


我们首先考虑一维问题

> 给定一个数轴以及数轴上的一些点，求用一个长度为$L$的区间截取的最大的点权和

显然我们只需要维护一个队列并保留最大值即可


------------

我们现在将问题扩展到二维，在用队列保证第1维度的截取宽度不超过$W$(窗口的宽限制)，我们还要限制截取的高不超过$H$(窗口的长限制)

对于第二个维度我们开一个全局权值线段树，求长度为$H$的区间的最大和

显然直接用线段树维护这个最大和并不容易，我们将问题转换为区间加减和区间最大值，这样可以直接用线段树维护


```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,a,b) for (int i=a;i<=b;i++)
using namespace std;
int n,w,h;
struct point{
	int x,y,val,u,v;
	bool operator<(const point o)const{return x<o.x;}
}u[10005];
struct node{
	int l,r,add,val;
}a[1000005<<2];
#define ls (x<<1)
#define rs (ls|1)
#define L a[x].l
#define R a[x].r
#define A a[x].add
#define V a[x].val
void build(int x,int l,int r){
	L=l;R=r;A=0;V=0;
	if(l==r)return;
	int mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
}
void updata(int x){
	V=max(a[ls].val,a[rs].val);
}
void pushup(int x,int val){
	V+=val;A+=val;
}
void down(int x){
	if(A){
		pushup(ls,A);
		pushup(rs,A);
		A=0;
	}
}
void change(int x,int l,int r,int val){
	if(L>=l&&R<=r)pushup(x,val);
	else{
		down(x);
		int mid=(L+R)>>1;
		if(mid>=l)change(ls,l,r,val);
		if(mid<r)change(rs,l,r,val);
		updata(x);
	}
}
int o[10005],b[10005],tot,ans;
void init(){
	scanf("%lld%lld%lld",&n,&w,&h);
	ans=0;tot=0;
	rep(i,1,n)scanf("%lld%lld%lld",&u[i].x,&u[i].y,&u[i].val),o[i]=u[i].y;
	sort(u+1,u+n+1);
	sort(o+1,o+n+1);
	rep(i,1,n)if(i==1||o[i]^o[i-1])b[++tot]=o[i];
	rep(i,1,n)u[i].u=lower_bound(b+1,b+tot+1,u[i].y)-b;
	rep(i,1,n)u[i].v=lower_bound(b+1,b+tot+1,u[i].y+h)-b-1;
	build(1,1,tot);
	//rep(i,1,n)printf("%lld %lld %lld %lld\n",u[i].x,u[i].y,u[i].u,u[i].v);
    //rep(i,1,tot)printf("%lld ",b[i]);putchar('\n');
}
void work(){
	int last=1;
	rep(i,1,n){
		int j=u[i].x;
		while(u[i].x==j){
            change(1,u[i].u,u[i].v,u[i].val);
			i++;
		}
		i--;
		while(last<i&&u[last].x+w<=j)
			change(1,u[last].u,u[last].v,-u[last].val),last++;
		//printf("%lld %lld\n",last,i);
		ans=max(ans,a[1].val);
	}
}
signed main(){
	int T;
	scanf("%lld",&T);
	while(T--){
		init();
		work();
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：_LAUV_ (赞：15)

喜欢这个题目背景~

这类题目有一个很巧妙的转化，把移动的窗口（面）和星星（点）转成 可以覆盖到星星的（面）和窗口的左下角（点）

什么意思呢？（可以结合下面的图片理解）

把每一个星星作为右上角，在它的左下方划出一片窗口大小的区域，表示只要窗口的左下角落在这一片区域里就一定能覆盖到这颗星星。

那么不同星星的重叠部分就代表能同时覆盖这几颗星星了。

（下图中，只要窗口落在阴影部分，就能同时覆盖到三颗星星） 

![](https://img2018.cnblogs.com/blog/1397390/201811/1397390-20181108203303639-29141505.jpg)

所以这一题的解法就是：

想象一条扫描线从左扫到右边，只要进入了星星的区域，扫描线上这段区间就可以取到这颗星星的值，等过了区域再减去这颗星星的值。

那就可以用线段树来做啦，每次挪动找出区间的最值更新答案就可以了。

 

------------


看到题目最后的提示:小卡买的窗户框是金属做的，所以在边框上的不算在内。
### (惊！

边框居然不算，好吧那就只好把范围缩小，到了阴影部分外的那条平行y轴的线就可以把这颗星星的贡献减掉了。（用Windows XP 画的的图，~~有点丑~~）

 ![](https://img2018.cnblogs.com/blog/1397390/201811/1397390-20181108203314536-655138517.jpg)

还有，星星的坐标很大，记得离散化。

具体操作细节可以看代码（用了vector来维护坐标上加和减的星星）

（代码虽然很长，但结构还算清晰吧)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<vector>
#include<algorithm>

#define For(i,a,b) for(int i=a;i<=b;++i)
#define Pn putchar('\n')
#define llg long long

using namespace std;

const int N=2e4+10;

struct LIS{
	int x,y,id;
}Lis[N*2];

struct Star{
	int x1,x2,y1,y2;
	llg lgt;
	Star(){
		x1=0; x2=0; y1=0; y2=0;
		lgt=0;
	}
}st[N];

vector<int>ads[N];
vector<int>mns[N]; 

int tot=0,n,m,W,H,x,y;
llg tag[N*4],mx[N*4],ans=0;

void read(int &v){       //读入优化，和输出优化 
	v=0; bool fg=0;
	char c=getchar(); if(c=='-')fg=1;
	while(c<'0'||c>'9'){c=getchar(); if(c=='-')fg=1;}
	while(c>='0'&&c<='9'){v=v*10+c-'0',c=getchar();if(c=='-')fg=1;}
	if(fg)v=-v;
}
void read(llg &v){
	v=0; bool fg=0;
	char c=getchar(); if(c=='-')fg=1;
	while(c<'0'||c>'9'){c=getchar(); if(c=='-')fg=1;}
	while(c>='0'&&c<='9'){v=v*10+c-'0',c=getchar();if(c=='-')fg=1;}
	if(fg)v=-v;
}
void write(int x){
	if(x>9)write(x/10);
	int xx=x%10;
	putchar(xx+'0');
}
                        //排序 
bool cmpX(const LIS &a,const LIS &b){
	return a.x<b.x;
}
bool cmpY(const LIS &a,const LIS &b){
	return a.y<b.y;
}
                      //线段树操作 
void pDown(int o){
	llg tg=tag[o];  tag[o]=0;
	int ls=o<<1,rs=o<<1|1;
	tag[ls]+=tg; tag[rs]+=tg;
	mx[ls]+=tg; mx[rs]+=tg;
}
void Ins(int o,int l,int r,int lx,int rx,llg dt){
	if(lx<=l&&rx>=r){
		mx[o]+=dt; tag[o]+=dt;
		return;
	}
	int m=(l+r)>>1;
	int ls=o<<1,rs=o<<1|1;
	if(tag[o])pDown(o);
	if(lx<=m)Ins(ls,l,m,lx,rx,dt);
	if(rx>m)Ins(rs,m+1,r,lx,rx,dt);
	mx[o]=max(mx[ls],mx[rs]);
}

int main(){ 
	int T; read(T);
	while(T--){ 
		tot=0; ans=0;
		memset(tag,0,sizeof(tag));
		memset(mx,0,sizeof(mx));
		
		read(n); read(W); read(H);
		For(i,1,n){                        //存下星星区域的右上角和左下角 
			read(x); read(y); read(st[i].lgt);
		    st[i].x1=st[i].x2=st[i].y1=st[i].y2=0;
			Lis[++tot].x=x;
			Lis[tot].y=y,Lis[tot].id=i;
			 
			Lis[++tot].x=x+W-1;
			Lis[tot].y=y-H+1,Lis[tot].id=i;
		}
		Lis[0].x=-2147483600;
		Lis[0].y=-2147483600;
		
		sort(Lis+1,Lis+tot+1,cmpY);        //分别对X和Y离散化 
		int ty=0;
		For(i,1,tot){
			if(Lis[i].y!=Lis[i-1].y)ty++;
			int ID=Lis[i].id;
			if(!st[ID].y2){
				st[ID].y2=ty;
			}else{
				st[ID].y1=ty;
			}
		}
		
		sort(Lis+1,Lis+tot+1,cmpX);
		int tx=0;
		For(i,1,tot){
			if(Lis[i].x!=Lis[i-1].x)tx++;
			int ID=Lis[i].id; 
			if(!st[ID].x1){
				st[ID].x1=tx;
			}else{
				st[ID].x2=tx;
			}
		}
		
		For(i,1,tx+1){                  //初始化vector 
			ads[i].clear();
			mns[i].clear();
		}
		
		For(i,1,n){
			int lx,rx;          //把星星挂到相应的横坐标上 
			lx=st[i].x1;        //ads为加， mns为减 
			rx=st[i].x2+1; 
			ads[lx].push_back(i);
			mns[rx].push_back(i);
		}
		For(i,1,tx){
			int sz;
			
			sz=mns[i].size();
			For(j,0,sz-1){           //先减后加 
				int ID=mns[i][j];
				int lx,rx;
				lx=st[ID].y2;
				rx=st[ID].y1; 
				Ins(1,1,ty,lx,rx,-st[ID].lgt);
				
			}

		    sz=ads[i].size();
		    For(j,0,sz-1){
		    	int ID=ads[i][j];
		    	int lx,rx;
		    	lx=st[ID].y2;
		    	rx=st[ID].y1;
		    	Ins(1,1,ty,lx,rx,st[ID].lgt);
			}
			ans=max(ans,mx[1]);
		}
		write(ans); Pn;
	}
	return 0;
}

```



---

## 作者：_ctz (赞：12)

[安利一波$blog$](https://ctz45562.github.io/2019/03/10/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P1502-%E3%80%90%E7%AA%97%E5%8F%A3%E7%9A%84%E6%98%9F%E6%98%9F%E3%80%91/)

[传送门](https://www.luogu.org/problemnew/show/P1502)

提供一个神奇的思路。

首先二维数点能想到扫描线+线段树。

边框不能取，珂以把长、宽都减$1$，因为你可以这么框：

![](https://cdn.luogu.com.cn/upload/pic/53691.png )

也就是说边界不取整数。

然后将坐标系上每个点扩展为一个矩形：

![](https://cdn.luogu.com.cn/upload/pic/53690.png )

大概就是这种感觉：把每个点向左下角扩展得到它代表的矩形。

对于每颗星星，把它能影响到的矩形加上它的贡献。

不考虑横坐标，它能影响到的矩形为:$y$到$y+h$的点所代表的所有矩形。

考虑上横坐标，用扫描线，及时删除不在当前横坐标能覆盖的星星。

这样把每个可能的矩形缩成一个点，用线段树维护最大值，边扫边取最大值就行了。

时间复杂度：$O(t·nlogn)$

（说着轻快其实蒟蒻调了好长时间，边界的处理太麻烦了，具体细节还是看代码吧$QAQ$）

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 10005
#define inf 0x3f3f3f3f
#define pn putchar('\n')
#define px(x) putchar(x)
#define ps putchar(' ')
#define pd puts("======================")
#define pj puts("++++++++++++++++++++++")

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
template<typename T>
inline T read(){
	T x=0;
	int y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
struct Segment_Tree{
	long long dat[maxn<<2],tag[maxn<<2];
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
	inline void update(int node){
		dat[node]=max(dat[ls(node)],dat[rs(node)]);
	}
	inline void datadown(int node,long long d){
		dat[node]+=d;
		tag[node]+=d;
	}
	inline void pushdown(int node){
		datadown(ls(node),tag[node]);
		datadown(rs(node),tag[node]);
		tag[node]=0;
	}
	void add(int L,int R,int l,int r,int node,long long d){
		if(L<=l&&R>=r){
			datadown(node,d);
			return;
		}
		if(tag[node])pushdown(node);
		int mid=l+r>>1;
		if(L<=mid)add(L,R,l,mid,ls(node),d);
		if(R>mid)add(L,R,mid+1,r,rs(node),d);
		update(node);
	}
	inline void clear(){
		memset(dat,0,sizeof dat);
		memset(tag,0,sizeof tag);
	}
}st;
int dis[maxn];
//离散化数组
struct POINT{
	int x,y,ll,rr;
	long long d;
}p[maxn];
//星星：x、y是坐标，ll、rr是它能覆盖的矩形范围，d是亮度
inline bool cmp(POINT x,POINT y){
	return x.x<y.x;
}
int main(){
	int t=read();
	while(t--){
		int n=read(),w=read()-1,h=read()-1,len=0,head=1;
        //长宽各-1
		for(register int i=1;i<=n;++i)
			p[i].x=read(),dis[++len]=p[i].y=read(),p[i].d=read<long long>();
		dis[++len]=(1ll<<31)-1;
        //加了一个无穷大的边界
		sort(dis+1,dis+1+len);
		sort(p+1,p+1+n,cmp);//把星星按横坐标排序
		len=unique(dis+1,dis+1+len)-dis-1;
		long long ans=0;
		for(register int i=1;i<=n;++i){
			p[i].ll=upper_bound(dis+1,dis+1+len,p[i].y)-dis,p[i].rr=upper_bound(dis+1,dis+1+len,p[i].y+h)-dis;
            //要用upper_bound，两边是可以等于的
			st.add(p[i].ll,p[i].rr,1,len,1,p[i].d);
			while(p[i].x-w>p[head].x)st.add(p[head].ll,p[head].rr,1,len,1,-p[head].d),++head;
            //通过head头指针删除点
			ans=max(ans,st.dat[1]);	
		}
		printf("%lld\n",ans);
		st.clear();
	}
}

```



---

## 作者：Xiaojian_xiang (赞：9)

离散化+扫描线+线段树

线段树的每一个节点处理的是左边框放在当前x-1位置时的框内星星的亮度大小……

首先按照x坐标进行离散化，处理离散化后每一个坐标x的星星的影响范围……（就是框子放在哪个x‘-1时可以把这个x上的星星放在框里）

然后扫描线扫y……扫到可以加某颗星星就把星星加进去……扫到该出来的时候就把星星搞出来……影响范围明显是一段区间啊……所以线段树维护区间修改查询就可以了……

上代码：










```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const long long MAXN=10010;
int n,imax;
int w,h;
int tree[4*MAXN],cha[4*MAXN];
struct STar{
    int x,y,l;
}star[MAXN];
struct CHA{
    int lc,rc,t;
    int val;
}ch[4*MAXN];
int top1;
//xianduanshu
void pushdown(int l,int r,int i){
    if(cha[i]==0) return;
    cha[i*2+1]+=cha[i];cha[i*2+2]+=cha[i];
    tree[i*2+1]+=cha[i];tree[i*2+2]+=cha[i];
    cha[i]=0;
}
void change(int fl,int fr,int k,int l,int r,int i){
    if(fl<=l&&r<=fr){
        cha[i]+=k;
        tree[i]+=k;
        return;
    }
    if(fl>r||l>fr) return;
    pushdown(l,r,i);
    int mid=(l+r)>>1;
    change(fl,fr,k,l,mid,i*2+1);
    change(fl,fr,k,mid+1,r,i*2+2);
    tree[i]=max(tree[i*2+1],tree[i*2+2]);
}
//xianduanshu
int con[MAXN],hh[MAXN],rank[MAXN],l[MAXN],r[MAXN],top;//离散化x 
bool cmp(STar xx,STar yy){
    return xx.x<yy.x;
}
bool cmp1(CHA xx,CHA yy){
    return xx.t<yy.t;
}
void init(){
    memset(tree,0,sizeof(tree));
    memset(cha,0,sizeof(cha));
    memset(con,0,sizeof(con));
    memset(hh,0,sizeof(hh));
    memset(rank,0,sizeof(rank));
    top=0;top1=0;imax=0;
}
void input(){
    init();
    cin>>n>>w>>h;
    for(int i=0;i<n;i++)
        cin>>star[i].x>>star[i].y>>star[i].l;
    sort(star,star+n,cmp);
    int tmp(star[0].x);
    for(int i=0;i<n;i++){
        if(star[i].x==tmp) {++con[top];rank[i]=top;}
        else {hh[top]=tmp;tmp=star[i].x;++con[++top];rank[i]=top;}
    }
    hh[top]=tmp;
}
void xxj(){
    int L(0);
    for(int i=0;i<=top;i++){
        while(hh[L]-1+w<hh[i]&&L<i) ++L;
        l[i]=L;r[i]=i;
    }
    //cout<<top<<' '<<"OK2"<<endl;
    for(int i=0;i<n;i++){
        ch[top1].lc=l[rank[i]];ch[top1].rc=r[rank[i]];
        ch[top1].val=star[i].l;ch[top1++].t=star[i].y;
        ch[top1].lc=l[rank[i]];ch[top1].rc=r[rank[i]];
        ch[top1].val=-star[i].l;ch[top1++].t=star[i].y+h;
    }
    sort(ch,ch+top1,cmp1);
    for(int i=0;i<top1;i++){
        int tmp=ch[i].t;
        while(tmp==ch[i].t){
            //写完加上
            change(ch[i].lc,ch[i].rc,ch[i].val,0,top,0);
            ++i;
        }
        --i;
        imax=max(imax,tree[0]);
    }
}
void output(){
    cout<<imax<<endl;
}
int main()
{
    int gg;
    cin>>gg;
    while(gg--){
        input();
        xxj();
        output();
    }
    return 0;
}
```

---

## 作者：Elma_ (赞：7)

## Description

[题目链接](https://www.luogu.com.cn/problem/P1502)


晚上，小卡从阳台望出去，“哇~~~~好多星星啊”，但他还没给其他房间设一个窗户。

天真的小卡总是希望能够在晚上能看到最多最亮的星星，但是窗子的大小是固定的，边也必须和地面平行。

这时小卡使用了超能力（透视术）知道了墙后面每个星星的位置和亮度，但是小卡发动超能力后就很疲劳，只好拜托你告诉他最多能够有总和多亮的星星能出现在窗口上。

## Solution

扫描线。

直接想点和面的关系其实不太好想，因为它们是跨维度的东西，不过这里显然不能对面进行降维打击。

所以考虑把点变成面，然后再进一步去想。

可以把每个点$(x, y)$扩展为$(x, y) \to (x+w-1, y+h-1)$的矩形，于是这个问题就转化为二维的问题，大概可以表述为求$n$个带权矩形的并的最大值。

注意这里的$-1$是必要的，因为边框上的星星不算。

这个东西可以扫描线$+$离散化$+$线段树求。

离散化。否则$2^{31}$的数据范围我们无法处理。对横坐标离散化，以纵坐标和权值为关键字排序。

之后就是扫描线的经典操作，注意到此时每颗星星所造成的影响已经被表示为一段区间，我们可以利用差分思想使同一个矩形里的边权下正上负，从下往上扫，同时用线段树维护区间加区间最大值即可。

由于一定先扫到下面的边，所以答案显然一定是正数。

于是这题几乎就和模板题一样~~可以秒掉~~了。

## Code

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define ll long long
#define maxn 100005
using namespace std;

ll t, n, w, h;
ll xrow[maxn << 1];

struct node
{
	ll l, r, max, tag;
}tree[maxn << 2];

struct lines
{
	ll l, r, h, val;
	bool operator <(const lines& x) const
	{
		return (h != x.h) ? h < x.h : val > x.val;
	}
}line[maxn << 2];

inline ll read()
{
	char v = getchar();ll x = 0, f = 1;
	while (!isdigit(v)) { if (v == '-')f = -1;v = getchar(); }
	while (isdigit(v)) { x = x * 10 + v - 48;v = getchar(); }
	return x * f;
}

inline ll lson(ll x) { return x << 1; }
inline ll rson(ll x) { return x << 1 | 1; }
inline void push_up(ll x) { tree[x].max = max(tree[lson(x)].max, tree[rson(x)].max); }
inline void push_down(ll x)
{
	if (tree[x].tag)
	{
		tree[lson(x)].max += tree[x].tag;
		tree[rson(x)].max += tree[x].tag;
		tree[lson(x)].tag += tree[x].tag;
		tree[rson(x)].tag += tree[x].tag;
		tree[x].tag = 0;
	}
}

void build(ll x, ll l, ll r)
{
	tree[x].l = l, tree[x].r = r;
	tree[x].max = tree[x].tag = 0;
	if (l == r) return;
	ll mid = (l + r) >> 1;
	build(lson(x), l, mid);
	build(rson(x), mid + 1, r);
}

void update(ll x, ll ul, ll ur, ll k)
{
	ll l = tree[x].l, r = tree[x].r;
	if (ul <= l && r <= ur)
	{
		tree[x].max += k;
		tree[x].tag += k;
		return;
	}
	push_down(x);
	ll mid = (l + r) >> 1;
	if (ul <= mid) update(lson(x), ul, ur, k);
	if (ur > mid) update(rson(x), ul, ur, k);
	push_up(x);
}

int main(void)
{
	t = read();
	while (t--)
	{
		memset(tree, 0, sizeof(tree));
		memset(line, 0, sizeof(line));
		memset(xrow, 0, sizeof(xrow));
		n = read(), w = read(), h = read();
		for (ll i = 1;i <= n;i++)
		{
			ll x = read(), y = read(), l = read();
			xrow[i * 2 - 1] = y;
			xrow[i * 2] = y + h - 1;
			line[i * 2 - 1].l = y, line[i * 2 - 1].r = y + h - 1, line[i * 2 - 1].h = x, line[i * 2 - 1].val = l;
			line[i * 2].l = y, line[i * 2].r = y + h - 1, line[i * 2].h = x + w - 1, line[i * 2].val = -l;
		}
		n <<= 1;
		sort(xrow + 1, xrow + n + 1);
		sort(line + 1, line + n + 1);
		ll tmp = unique(xrow + 1, xrow + n + 1) - xrow - 1;
		ll ans = 0;
		build(1, 1, tmp - 1);
		for (ll i = 1;i <= n;i++)
		{
		    ll L = lower_bound(xrow + 1, xrow + tmp + 1, line[i].l) - xrow - 1;
			ll R = lower_bound(xrow + 1, xrow + tmp + 1, line[i].r) - xrow - 1;
			update(1, L, R, line[i].val);
			ans = max(ans, tree[1].max);
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```


---

## 作者：Mr_Leceue (赞：7)

### **动态开点做法**

[ML](https://www.cnblogs.com/waterflower/p/11100970.html)博客有图 更加详细

这道题的一个关键点是，将星星作为一个窗户的左下角（其实是为了不出现负数），将每一个星星都创一个窗户，之后寻找重叠部分

## **解释**

看这个图，这是两个相交的情况，矩形左下角是星星，然后如果有重叠部分，那么我们要贴着相交部分的上边和右边建一个窗户，那么就可以盖住这两个星星，

（对于洛谷的图我有时候弄不上去QAQ）

类比到所有星星是一样的，我们只要将矩形附上权值即可，用扫描线寻找。

但是这个边框不是不能包含星星吗？

**所以我们需要处理一些小细节，将矩形右边的横坐标减去1，也就是提前减去，再将扫描线上端-1，这就处理了边界问题；**

**并且在sort的时候当横坐标相同时，将加上的排在前面。
这个细节请一定要理解，否则wa了也不好调（因为不给数据），代码我会做上标记。**

矩形权值直接附在扫描线上即可；
 
这里我们介绍动态开点做法；

首先不需要在意太多的离散化细节是一个优点，干干的介绍不是非常简洁，所以我直接附上代码讲解：

```
#include<bits/stdc++.h>
#define maxn 10007
using namespace std;
int t,n,w,h,cnt,lim,root;
struct node{
	int x,l,r,w,d;
}a[maxn<<3];//扫描线 
struct tree{
	int le,ri,w,tag;
}tr[5000007];//动态开点的不同，le和ri记录的是左端点和右端点的p值 
//tr记住稍微大一点 （别 MLE 了 ），反正不会错 
template<typename type_of_scan>
inline void scan(type_of_scan &x){
	type_of_scan f=1;x=0;char s=getchar();
	while(s<'0'||s>'9') f=s=='-'?-1:1,s=getchar();
	while(s>='0'&&s<='9') x=(x<<3)+(x<<1)+s-'0',s=getchar();
	x*=f;
}

bool operator <(node x,node y){
	return x.x==y.x?x.d>y.d:x.x<y.x;
}//sort的细节*** 

inline void push_down(int p,int k){
	if(!tr[p].le) tr[p].le=++cnt;//没点开点 
	if(!tr[p].ri) tr[p].ri=++cnt;
	tr[tr[p].le].w+=k,tr[tr[p].ri].w+=k;
	tr[tr[p].le].tag+=k,tr[tr[p].ri].tag+=k;
}

void add(int nl,int nr,int l,int r,int &p,int k){
	if(!p) p=++cnt;//没点开点 
	if(nl<=l&&nr>=r){
		tr[p].w+=k,tr[p].tag+=k;
		return ;
	}
	if(tr[p].tag) push_down(p,tr[p].tag);tr[p].tag=0;
	int mid=(l+r)>>1;
	if(nl<=mid) add(nl,nr,l,mid,tr[p].le,k);
	if(nr>mid) add(nl,nr,mid+1,r,tr[p].ri,k);
	tr[p].w=max(tr[tr[p].le].w,tr[tr[p].ri].w);
}//与线段树相同 

inline void work(){
	int ans=0;memset(tr,0,sizeof tr);
	scan(n);scan(w),scan(h);
	for(int i=1,x,y,v;i<=n;i++)
		scan(x),scan(y),scan(v),lim=max(x+w+1,lim),//lim是线段树范围 
		a[(i<<1)-1]=(node){x,y,y+h-1,v,1},//强行转换格式，-1的细节** 
		a[i<<1]=(node){x+w-1,y,y+h-1,v,-1};//细节** 
	sort(a+1,a+1+2*n);//细节** 
	for(int i=1;i<=2*n;i++){
		add(a[i].l,a[i].r,1,lim,root,a[i].w*a[i].d);
		ans=max(ans,tr[root].w);//直接用整棵树更新就好啦 
	}
	printf("%d\n",ans);
}

int main(){
	scan(t);
	while(t--) work();
	return 0;
}
```

如果不清楚可以补充，如果是图炸了话，那就看一下博客啦。
错了请~~（痛骂）~~纠正一下蒟蒻~

---

## 作者：IC_QQQ (赞：6)

## 前置芝士：扫~描~线~
~~这个题其实还有个清流的背景~~
### 尝试解决问题：
我们已知了窗子的长**W**和宽**H**，只需要确定矩形的右上角**M**，整个窗子的位置就确定了。 

对于任意的一颗星星 **（x，y）**，我们考虑**M**放在哪些区域可以得到她。

因为星星的坐标是**整数**，我们也令**M**是整数。

注意题目要求：边界不能放。所以，范围就出来了：

左下角$(x,y)$,右上角$(x+W-1,Y+H-1)$。(包括边界)

此时，问题转化成了：**平面上有若干个区域，每个区域都带有一个权值，求在哪个坐标上重叠的区域权值和最大。**

成功转化成了熟悉的**扫~描~线**问题。

### 套路：

取出每个星星形成的矩形，记做**四元组**。

左边：$(x,y,y+H,k)$。

右边：$(x+W,y,y+H,-k)$。

**k**是星星的亮度。

然后以**x**为关键元，对四元组进行排序。

新的问题：**x**相等怎么办？

答案：**右边界**优先。

为什么呢？如果这里同时有一个左边界和一个右边界，右边界已经失效了，要先从扫描线中删除。（前面提到，有效范围是**x~x+W-1**）。

解决了问题，继续进行套路：

对纵坐标进行离散化，得到**tot**个代表数，这条扫描线就被分成了**tot-1**段。

用 **c[i]** 来维护这条扫描线，我们要得到扫描线上的**最大值**。因此，**c[i]** 表示扫描线上第 $i$ 段的权值。

### 走流程：
+ 遇到一条边，用这条边修改扫描线。
+ 扫一遍**c**数组，找到最大值，更新**ans** 。

怎么修改扫描线？我们令纵坐标**y**的代表数为**val(y)**。

修改扫描线：**c[val(y)~val(y+H)-1]**都加上**k**。

因为边界不能放，所以是**val(y+H)-1**。

### 线段树维护**c**数组

每个节点主要是维护最大值**dat**。注意一下下传延迟标记就行了。

### 代码：
```cpp
#include<bits/stdc++.h>
#define R register int
#define ll long long
using namespace std;
const int N=2*1e4+5;
int n,nn,t;
ll H,W,ans;
struct node{
    ll x,u,v,w;//u,v纵坐标
}da[N];//四元组 
struct aaa{
    ll dat,add;//最大值，懒标记 
}tree[4*N];
ll row[N],tot;//离散化 

ll in(){
    ll x=0;char ch=getchar();
    while(ch>'9'||ch<'0') ch=getchar();
    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
    return x;
}

bool cmp(node a,node b){//四元组排序
    if(a.x==b.x) return a.w<b.w;//重点，右边界优先 
    return a.x<b.x;
}

void reset(){//预处理，清零
    ans=0;tot=0;
    memset(da,0,sizeof(da));
    memset(row,0,sizeof(row));
    memset(tree,0,sizeof(tree));
    return;
}

void scan(){//读入
    n=in();W=in();H=in();
    int a,b,c;nn=n+n;
    for(R i=1;i<=n;i++){
        a=in();b=in();c=in();
        row[i]=b;row[i+n]=b+H;
        da[i].x=a;da[i+n].x=a+W;
        da[i].u=b;da[i+n].u=b;
        da[i].v=b+H;da[i+n].v=b+H;
        da[i].w=c;da[i+n].w=-c;
    }
    return;
}

void row_(){//离散化
    sort(row+1,row+1+nn);
    tot=unique(row+1,row+1+nn)-(row+1);
    return;
}

int query(ll x){//离散化
    return lower_bound(row+1,row+1+tot,x)-row;
}

void spread(int pos){//下传懒标记
    int ls=pos*2,rs=pos*2+1;
    tree[ls].dat+=tree[pos].add;
    tree[rs].dat+=tree[pos].add;
    tree[ls].add+=tree[pos].add;
    tree[rs].add+=tree[pos].add;
    tree[pos].add=0;
    return;
}

void change(int pos,int pl,int pr,int l,int r,ll w){
    if(l<=pl&&r>=pr){
        tree[pos].dat+=w;
        tree[pos].add+=w;
        return;
    }
    if(tree[pos].add) spread(pos);
    int mid=(pl+pr)>>1;
    if(l<=mid) change(pos*2,pl,mid,l,r,w);
    if(r>mid) change(pos*2+1,mid+1,pr,l,r,w);
    tree[pos].dat=max(tree[pos*2].dat,tree[pos*2+1].dat);
    return;
}

int main(){
    t=in();
    while(t--){		
        reset();scan();row_();				
        sort(da+1,da+1+nn,cmp);
        for(int i=1;i<=nn;i++){
            int u=query(da[i].u);
            int v=query(da[i].v)-1;
            change(1,1,tot-1,u,v,da[i].w);
            //懒得建树，将节点的左右端点作为参数传递 
            ans=max(ans,tree[1].dat);
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```




---

## 作者：Adove (赞：5)

离散化&扫描线&线段树

对于每个点**(x,y)**

我们定义其影响范围**(x,y)~(x+w-1,y+h-1)**（保证影响效果不重不漏，只要对于每个点影响区间相对位置不变就可以）

于是我们在**(x,y)**处设点值为**c**，区间**[y,y+h-1]**+c;

在**(x+w-1,y)**处设点值为**-c**,区间**[y,y+h-1]**-c,消除该点对答案的贡献

注意对纵坐标y与每个(y+h-1)的离散化

对所设每个点以横坐标为关键字排序，从左到右扫描

线段树维护**当前区间最大值**

上代码↓
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int MAXN=1e5+5;

int T,n,w,h;
int pou[MAXN<<2],maxn[MAXN<<2],add[MAXN<<2];

struct pnt{
	int x,y,c,kd,ymax,id;
}st[MAXN<<2];

bool cmp1(pnt a,pnt b){
	return a.y<b.y;
}
bool cmp2(pnt a,pnt b){
	if(a.id==b.id) return a.kd<b.kd;
	return a.id<b.id;
}
bool cmp3(pnt a,pnt b){
	if(a.x==b.x) return a.kd<b.kd;
	return a.x<b.x;
}

void po(int k,int l,int r){
	if(add[k]==0) return;
	if(l==r){
		add[k]=0;
		return;
	}
	int i=k<<1,mid=(l+r)>>1;
	add[i]+=add[k];
	add[i|1]+=add[k];
	maxn[i]+=add[k];
	maxn[i|1]+=add[k];
	add[k]=0;
}

void cadd(int x,int k,int l,int r,int le,int ri){
	po(k,l,r);
	if(le<=l&&r<=ri){
		add[k]=x;
		maxn[k]+=x;
		return;
	}
	int i=k<<1,mid=(l+r)>>1;
	if(le<=mid){
		cadd(x,i,l,mid,le,ri);
	}if(mid<ri){
		cadd(x,i|1,mid+1,r,le,ri);
	}
	maxn[k]=max(maxn[i],maxn[i|1]);
}

int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d%d",&n,&w,&h);
		memset(maxn,0,sizeof(maxn));
		memset(add,0,sizeof(add));
//reset
		for(int i=1;i<=n;++i){
			int x,y,c;
			scanf("%d%d%d",&x,&y,&c);
			st[i]=(pnt){x,y,c,1};
			st[i+n]=(pnt){x+w-1,y,-c,2};
			st[i+(n<<1)].y=y+h-1;
			st[i+(n<<1)].kd=3;
			st[i].id=st[i+n].id=st[i+(n<<1)].id=i;
		}
//init
		sort(st+1,st+n*3+1,cmp1);
		int cnt=0;
		for(int i=1;i<=n*3;++i){
			pou[i]=st[i].y;
		}
		for(int i=1;i<=n*3;++i){
			if(st[i].y==pou[i-1]) st[i].y=st[i-1].y;
			else st[i].y=++cnt;
		}
//discretization
		sort(st+1,st+n*3+1,cmp2);
		for(int i=1;i<=n*3;i+=3){
			st[i].ymax=st[i+1].ymax=st[i+2].y;
		}
		for(int i=3;i<=n<<1;++i){
			st[i]=st[i+((i-1)>>1)];
		}
//reinit
		sort(st+1,st+(n<<1)+1,cmp3);
		int ans=0;
		for(int i=1;i<=n<<1;++i){
			cadd(st[i].c,1,0,cnt,st[i].y,st[i].ymax);
			ans=max(ans,maxn[1]);
		}
//answer
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：Lysus (赞：4)

这是一道离散化加线段树

我们把每个星星都看成属于它那个矩形的左下角 

再按照x轴和y轴离散化

把y轴用线段树处理，x轴扫过去

扫到一个矩形就加相应的light值，相反扫出矩形就减去相应的light值（线段树操作）

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MAX = 100010;

int n, w, h, t;
struct Node {
	int light, x_1, x_2, y_1, y_2;
}s[MAX];
struct node {
	int xx, yy, id;
}L[MAX << 2];
int tot;
struct nOde {
	int lazy, sum;
}tree[MAX << 2];
int f[MAX][101], g[MAX][101];

inline int read() {
	int s = 0, w = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') {
		if(ch == '-') w = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9') {
		s = s * 10 + ch - '0';
		ch = getchar();
	}
	return s * w;
}

bool cmp_x(node a, node b) {return a.xx < b.xx;}
bool cmp_y(node a, node b) {return a.yy < b.yy;}
bool cmp_X(Node a, Node b) {return a.x_1 == b.x_1 ? a.x_2 < b.x_2 : a.x_1 < b.x_1;}
void push_down(int u) {
	if(tree[u].lazy) {
		tree[u << 1].lazy += tree[u].lazy;
		tree[u << 1 | 1].lazy += tree[u].lazy;
		tree[u << 1].sum += tree[u].lazy;
		tree[u << 1 | 1].sum += tree[u].lazy;
		tree[u].lazy = 0;
	}
}
void change_1(int u, int x, int y, int a, int b, int k) {
	if(a <= x && b >= y) {
		tree[u].lazy += k;
		tree[u].sum += k;
		push_down(u);
		return ;
	}
	int mid = (x + y) >> 1;
	push_down(u);
	if(a <= mid) change_1(u << 1, x, mid, a, b, k);
	if(b > mid) change_1(u << 1 | 1, mid + 1, y, a, b, k);
	tree[u].sum = max(tree[u << 1].sum, tree[u << 1 | 1].sum);
}
int ask(int u, int x, int y) {
	if(x == y) return tree[u].sum;
	int mid = (x + y) >> 1;
	push_down(u);
	return max(ask(u << 1, x, mid), ask(u << 1 | 1, mid + 1, y));
	return 0;
}
int main()
{
	t = read();
	while(t--) {
		tot = 0;
		n = read(), w = read(), h = read();
		for(int i = 1; i <= n; i++) {
			int x = read(), y = read();
			s[i].x_1 = s[i].x_2 = s[i].y_1 = s[i].y_2 = 0;
			s[i].light = read();
			
			L[++tot].xx = x;
			L[tot].yy = y;
			L[tot].id = i;
			
			L[++tot].xx = x + w - 1;
			L[tot].yy = y - h + 1;
			L[tot].id = i;
		}
		sort(L + 1, L + 1 + tot, cmp_y);//离散化x，y轴
		int ty = 0;
		for(int i = 1; i <= tot; i++) {
			if(L[i].yy != L[i - 1].yy) ty++;
			if(!s[L[i].id].y_1) s[L[i].id].y_1 = ty;
			else s[L[i].id].y_2 = ty; 
		}
		sort(L + 1, L + 1 + tot, cmp_x);
		int tx = 0;
		for(int i = 1; i <= tot; i++) {
			if(L[i].xx != L[i - 1].xx) tx++;
			if(!s[L[i].id].x_2) s[L[i].id].x_2 = tx, f[tx][++f[tx][0]] = L[i].id;
			else s[L[i].id].x_1 = tx, g[tx][++g[tx][0]] = L[i].id;
		}
		//for(int i = 1; i <= n; i++) {printf("\nx_1: %d  x_2: %d  y_1: %d  y_2: %d  light: %d\n",  s[i].x_1, s[i].x_2, s[i].y_1, s[i].y_2, s[i].light);}
		//sort(s + 1, s + n + 1, cmp_X);
		int ans = 0;
		for(int i = 1; i <= tx; i++) {
			for(int j = 1; j <= f[i][0]; j++) {
				int v = f[i][j];
				change_1(1, 1, ty, s[v].y_1, s[v].y_2, s[v].light);
			}
			ans = max(ans, /*ask(1, 1, ty)*/tree[1].sum);
			for(int j = 1; j <= g[i][0]; j++) {
				int v = g[i][j];
				change_1(1, 1, ty, s[v].y_1, s[v].y_2, -s[v].light);
			}
		}
		printf("%d\n", ans);
		for(int i = 1; i <= tx; i++) f[i][0] = g[i][0] = 0;
	}
	return 0;
}
```


---

## 作者：qwaszx (赞：4)

把星星看成大小是$(W,H)$的矩形，然后问题转化为找一个点，覆盖这个点的矩形的权值和最大.

把矩形拆成两条线段，两条线段分别有一个$+w$和$-w$的权值

然后扫描线，区间加，维护区间最大值

有一个细节，因为边框不算，所以可以把矩形看作$(W-1,H-1)$的格点矩形

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=5e5;
long long a[N],tag[N];
struct Q{long long x,l,r,w;}q[N];
int n,W,H,cnt,T,qn;long long ans,lsh[N];
int cmp(const Q &a,const Q &b){return a.x==b.x?a.w>b.w:a.x<b.x;}
void pushup(int rot){a[rot]=max(a[rot<<1],a[rot<<1|1]);}
void pushdown(int rot)
{
	if(tag[rot])
	{
		int t=tag[rot];tag[rot]=0;
		a[rot<<1]+=t,tag[rot<<1]+=t;
		a[rot<<1|1]+=t,tag[rot<<1|1]+=t;
	}
}
void update(int rot,int lt,int rt,int lq,int rq,int w)//区间加，区间max
{
	if(lq>rq)return;
	if(lt>=lq&&rt<=rq){a[rot]+=w,tag[rot]+=w;return;}
	int mid=(lt+rt)>>1;pushdown(rot);
	if(rq<=mid)update(rot<<1,lt,mid,lq,rq,w);
	else if(lq>mid)update(rot<<1|1,mid+1,rt,lq,rq,w);
	else update(rot<<1,lt,mid,lq,mid,w),update(rot<<1|1,mid+1,rt,mid+1,rq,w);
	pushup(rot);
}
void build(int rot,int lt,int rt)//清零
{
	tag[rot]=a[rot]=0;
	if(lt==rt)return;
	int mid=(lt+rt)>>1;
	build(rot<<1,lt,mid),build(rot<<1|1,mid+1,rt);
}
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d%d",&n,&W,&H);
		cnt=qn=0;build(1,1,n<<1);ans=0;
		for(int i=1;i<=n;i++)
		{
			long long x,y,w;
			scanf("%lld%lld%lld",&x,&y,&w);
			lsh[++cnt]=y,lsh[++cnt]=y+H-1;
			q[++qn]=(Q){x,y,y+H-1,w},q[++qn]=(Q){x+W-1,y,y+H-1,-w};//拆成两条线段
		}
		sort(lsh+1,lsh+cnt+1);
		cnt=unique(lsh+1,lsh+cnt+1)-lsh-1;//离散化
		sort(q+1,q+qn+1,cmp);
		for(int i=1;i<=qn;i++)
		{
			int l=lower_bound(lsh+1,lsh+cnt+1,q[i].l)-lsh,r=lower_bound(lsh+1,lsh+cnt+1,q[i].r)-lsh;
			update(1,1,cnt,l,r,q[i].w);ans=max(ans,a[1]);//更新答案
		}
		printf("%lld\n",ans);
	}
}
```

---


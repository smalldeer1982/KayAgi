# [SCOI2010] 序列操作

## 题目描述

lxhgww 最近收到了一个 $01$ 序列，序列里面包含了 $n$ 个数，下标从 $0$ 开始。这些数要么是 $0$，要么是 $1$，现在对于这个序列有五种变换操作和询问操作：

- `0 l r` 把 $[l, r]$ 区间内的所有数全变成 $0$；
- `1 l r` 把 $[l, r]$ 区间内的所有数全变成 $1$；
- `2 l r` 把 $[l,r]$ 区间内的所有数全部取反，也就是说把所有的 $0$ 变成 $1$，把所有的 $1$ 变成 $0$；
- `3 l r` 询问 $[l, r]$ 区间内总共有多少个 $1$；
- `4 l r` 询问 $[l, r]$ 区间内最多有多少个连续的 $1$。

对于每一种询问操作，lxhgww 都需要给出回答，聪明的程序员们，你们能帮助他吗？


## 说明/提示

【数据范围】  
对于 $30\%$ 的数据，$1\le n,m \le 1000$；  
对于$100\%$ 的数据，$1\le n,m \le 10^5$。


## 样例 #1

### 输入

```
10 10
0 0 0 1 1 0 1 0 1 1
1 0 2
3 0 5
2 2 2
4 0 4
0 3 6
2 3 7
4 2 8
1 0 5
0 5 6
3 3 9
```

### 输出

```
5
2
6
5```

# 题解

## 作者：小粉兔 (赞：232)

**更棒的线段树操作，尽在本题解中！**

分析一波题意，显然的区间操作，而且信息都是线段树能维护的。

因为有区间取反操作，所以不仅要记录 $1$ 的信息，$0$ 的信息也要记录。

对于一个点，我们考虑维护 $8$ 个信息：

$1/0$ 的个数，左/右边起 $1/0$ 的最长长度，整段区间中 $1/0$ 的连续最长长度。

只有维护至少 $8$ 个信息才能保证能够合并区间（想想为什么）。

使用结构体存储复杂信息是更好的方法：

```cpp
struct d{
    // 分别表示上述的8个信息
    // w: 1(white) , b: 0(black)
    // l: 左边起 , r: 右边起
    // mw, mb 代表整段区间中1/0的最长长度
    int w,b,lw,lb,rw,rb,mw,mb;
    //构造函数，方便赋值
    d(int w=0,int b=0,int lw=0,int lb=0,int rw=0,int rb=0,int mw=0,int mb=0):
    w(w),b(b),lw(lw),lb(lb),rw(rw),rb(rb),mw(mw),mb(mb){}
};
```

而合并两个子区间，需要考虑很多东西：

$1/0$ 的个数直接相加，左右起的 $1/0$ 要考虑左/右的一整个区间是否是同一个数。

整段区间中的 $1/0$ 最长长度为以下两值的较大值
- 左、右区间的 $1/0$ 最长长度；
- 左边的右端、右边的左端的 $1/0$ 最长长度之和。

由此写出合并两个区间的函数：

```cpp
inline d hb(d i,d j){
	return d(
	i.w+j.w, i.b+j.b,
	(i.b?i.lw:i.w+j.lw), (i.w?i.lb:i.b+j.lb),
	(j.b?j.rw:j.w+i.rw), (j.w?j.rb:j.b+i.rb),
	max(max(i.mw,j.mw),i.rw+j.lw),
	max(max(i.mb,j.mb),i.rb+j.lb));
}
```

这个函数在建树，修改和查询的时候都会用到，我写复杂的线段树都会定义这个函数。

然后是对一个区间整体修改，要注意 $3$ 种修改操作的优先顺序：先赋值后取反：

```cpp
inline void P(int i,int typ){
    // tg1(标记1)是区间赋值,没有标记时为-1,有标记时为0或1
    // tg2(标记2)是区间取反,没有标记时为 0,有标记时为1
    // len表示一个区间的长度,在建树时处理
    d&t=dat[i];
    // 区间赋值为 0
    if(typ==0) tg2[i]= 0, tg1[i]=0, t=d(0,len[i],0,len[i],0,len[i],0,len[i]);
    // 区间赋值为 1
    if(typ==1) tg2[i]= 0, tg1[i]=1, t=d(len[i],0,len[i],0,len[i],0,len[i],0);
    // 区间取反
    if(typ==2) tg2[i]^=1, swap(t.w,t.b), swap(t.lw,t.lb), swap(t.rw,t.rb), swap(t.mw,t.mb);
}
```

这个函数会在修改和标记下传（pushdown）时用到。

接下来是标记下传（pushdown），注意顺序：

```cpp
inline void pd(int i){
    // 对两个子区间修改
    if(~tg1[i]) P(i<<1,tg1[i]), P(i<<1|1,tg1[i]);
    if(tg2[i]) P(i<<1,2), P(i<<1|1,2);
    // 把标记清空
    tg1[i]=-1, tg2[i]=0;
}
```

最后是建树，修改和查询函数，有了上面的，这就很简单了：

```cpp
void build(int i,int l,int r){
    len[i]=r-l+1; tg1[i]=-1;
    if(l==r) {int t=a[l]; dat[i]=d(t,t^1,t,t^1,t,t^1,t,t^1); return;}
    build(i<<1,l,l+r>>1);
    build(i<<1|1,(l+r>>1)+1,r);
    dat[i]=hb(dat[i<<1],dat[i<<1|1]);
}
void Mdf(int i,int l,int r,int a,int b,int t){
    // 如果区间没有交集 或者 当前区间完全包含在修改区间内的情况
    if(b<l||r<a) return; if(a<=l&&r<=b) {P(i,t); return;}
    pd(i); Mdf(i<<1,l,l+r>>1,a,b,t), Mdf(i<<1|1,(l+r>>1)+1,r,a,b,t);
    dat[i]=hb(dat[i<<1],dat[i<<1|1]);
}
d Qur(int i,int l,int r,int a,int b){
    // 如果区间没有交集 或者 当前区间完全包含在查询区间内的情况
    if(b<l||r<a) return d(); if(a<=l&&r<=b) return dat[i];
    pd(i); return hb(Qur(i<<1,l,l+r>>1,a,b),Qur(i<<1|1,(l+r>>1)+1,r,a,b));
}
```

下面是完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,a[100001];
struct d{
	int w,b,lw,lb,rw,rb,mw,mb;
	d(int w=0,int b=0,int lw=0,int lb=0,int rw=0,int rb=0,int mw=0,int mb=0):
    w(w),b(b),lw(lw),lb(lb),rw(rw),rb(rb),mw(mw),mb(mb){}
};
inline d hb(d i,d j){
	return d(
	i.w+j.w, i.b+j.b,
	(i.b?i.lw:i.w+j.lw), (i.w?i.lb:i.b+j.lb),
	(j.b?j.rw:j.w+i.rw), (j.w?j.rb:j.b+i.rb),
	max(max(i.mw,j.mw),i.rw+j.lw),
	max(max(i.mb,j.mb),i.rb+j.lb));
}
d dat[262144]; int len[262144],tg1[262144],tg2[262144];
inline void P(int i,int typ){
	d&t=dat[i];
	if(typ==0) tg2[i]= 0, tg1[i]=0, t=d(0,len[i],0,len[i],0,len[i],0,len[i]);
	if(typ==1) tg2[i]= 0, tg1[i]=1, t=d(len[i],0,len[i],0,len[i],0,len[i],0);
	if(typ==2) tg2[i]^=1, swap(t.w,t.b), swap(t.lw,t.lb), swap(t.rw,t.rb), swap(t.mw,t.mb);
}
inline void pd(int i){
	if(~tg1[i]) P(i<<1,tg1[i]), P(i<<1|1,tg1[i]);
	if(tg2[i]) P(i<<1,2), P(i<<1|1,2);
	tg1[i]=-1, tg2[i]=0;
}
void build(int i,int l,int r){
	len[i]=r-l+1; tg1[i]=-1;
	if(l==r) {int t=a[l]; dat[i]=d(t,t^1,t,t^1,t,t^1,t,t^1); return;}
	build(i<<1,l,l+r>>1);
	build(i<<1|1,(l+r>>1)+1,r);
	dat[i]=hb(dat[i<<1],dat[i<<1|1]);
}
void Mdf(int i,int l,int r,int a,int b,int t){
	if(b<l||r<a) return; if(a<=l&&r<=b) {P(i,t); return;}
	pd(i); Mdf(i<<1,l,l+r>>1,a,b,t), Mdf(i<<1|1,(l+r>>1)+1,r,a,b,t);
	dat[i]=hb(dat[i<<1],dat[i<<1|1]);
}
d Qur(int i,int l,int r,int a,int b){
	if(b<l||r<a) return d(); if(a<=l&&r<=b) return dat[i];
	pd(i); return hb(Qur(i<<1,l,l+r>>1,a,b),Qur(i<<1|1,(l+r>>1)+1,r,a,b));
}
int main(){
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;++i) scanf("%d",a+i);
	build(1,1,n);
	for(int i=1;i<=q;++i){
		int opt,l,r;
		scanf("%d%d%d",&opt,&l,&r); ++l, ++r;
		if(opt<3) Mdf(1,1,n,l,r,opt);
		else {d t=Qur(1,1,n,l,r); printf("%d\n",opt==3?t.w:t.mw);}
	}
	return 0;
}
```

以上就是我打较复杂线段树操作时的模板，大家可以借鉴一下，形成自己的风格。

---

## 作者：天上一颗蛋 (赞：152)

很久没发题解了， 这题难调， 看看这篇题解能不能帮到大家

$debug$ 了一个下午， 发点东西说点要注意的地方

[从博客搬过来， 不知道格式会不会炸。。](https://www.cnblogs.com/Tony-Double-Sky/p/9823463.html)

首先说明， 线段树这种东西， 每个人写法差异较大， **题解嘛主要是看思路是否正确以及细节是否处理得当**

掌握这题， 将会对线段树有一个好的领悟

（前排求点赞~~硬币收藏素质三连 XD~~）

# 前文

这篇题解将着重对以下问题做一个（尽量详细）的说明， 不懂可以私信或QQ， 有空可以解答

1. 大体思路及维护元素
1. 上推（这两个大家都有讲， 看不懂就都看看没准就会了）
1. 着重讲 **$pushdown$ 下放懒标记操作 的细节处理问题**

很多得 $10$ 分的人都是懒标记下放细节处理不得当

诚然， 还请观摩这篇题解之前**自行仔细思考**， 能得到很多

另外， 此题码量较大。 如还有错误请告知。 谢谢

那么开始吧

# [正文](https://www.cnblogs.com/Tony-Double-Sky/p/9823463.html)

对自己 & $RNG$ ： 骄兵必败
$lpl$加油！

# P2572 [SCOI2010]序列操作
题目描述
lxhgww最近收到了一个01序列，序列里面包含了n个数，这些数要么是0，要么是1，现在对于这个序列有五种变换操作和询问操作：

0 a b 把[a, b]区间内的所有数全变成0

1 a b 把[a, b]区间内的所有数全变成1

2 a b 把[a,b]区间内的所有数全部取反，也就是说把所有的0变成1，把所有的1变成0

3 a b 询问[a, b]区间内总共有多少个1

4 a b 询问[a, b]区间内最多有多少个连续的1

对于每一种询问操作，lxhgww都需要给出回答，聪明的程序员们，你们能帮助他吗？

---

**错误日志： 内容较多且重要， 将写在下方加粗**

---

# Solution
线段树， 需要维护以下信息：
1. $sum$ 区间 $1$ 的个数
2. $max[0/1]$ 区间内 $0/1$ 最长连续子段
3. $lmax[0/1]$ 包含区间左端点最长 $0/1$ 子段
4. $rmax[0/1]$ 包含区间右端点最长 $0/1$ 子段

鉴于有区间操作， 这里还需要两个标记：
5. $lazy = {-1, 0, 1}$  为 $-1$ 表示无状态， 为 $0/1$ 表示区间全部赋值为 $0/1$
6. $rev = {0, 1}$ 区间是否翻转
---

需要维护的元素较多， 先讲 $pushup$
区间和直接相加即可
包含左端点的连续子段有两种情况：
1. 直接继承左区间的 $lmax$
2. 当左区间全满 / 全空时， 左端点可以跨越， 加上右区间的部分

右区间更新同理

对于区间最长连续子段， 有以下三种情况
1.  直接继承左区间的较大值
2. 直接继承右区间的较大值
3. 左区间的含右端点最长子段 + 右区间含左端点最长子段， 即最长部分跨越区间分割线

以上需要分 $0/1$ 讨论， 程序中直接两层循环搞定

---

**然后到了难点 $pushdown$**

**~~我一个需要冲省队的选手竟然直到现在才注意到这点很惨啊~~**

在线段树 **$pushdown$** 操作中， 我们需要明确两件事：

1. 标记的优先级

**2. 下放某一标记是否会对子节点的其他类型标记有所影响**

这里重点讨论第二点（第一点区间全体赋值优先级肯定高于翻转， 所以优先拆区间赋值标记， 拆标记时需要将翻转标记清空）

在拆解一个标记时， 我们不仅需要明确将此标记下放到子节点， **同类型的标记**应该如何改变， 而更应明确拆解此标记会对 **不同类型的标记**有何种影响

明确同类型的影响是一般不会出问题的， 如将区间加标记下放时， 子节点的区间加标记累加上这个值

以本题为例：

**将区间赋值标记拆解时， 不仅需要将子区间赋值标记更新为此值， 还需要将子节点翻转标记清空**（不过这个貌似影响不大， 拆赋值标记时会将翻转标记清空的）

**将区间翻转标记拆解时， 需要分两种情况考虑此标记下推对子区间 赋值标记 和 翻转标记造成的影响**

考虑到赋值标记的优先级大于翻转标记， **在有赋值标记的情况下， 直接翻转赋值标记**

其余情况翻转标记异或等于1

---


其余见代码 虽然很长但用心弄懂会对线段树有一个很深刻的理解

这样**完备地**考虑所有情况是一个 $OI$ 选手的基本素养

---

嗯就这样， $RNG$ 别丧气， 你们是最棒的； $S8$ ，$lpl$ 加油！

# Code
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
#include<climits>
#define LL long long
#define REP(i, x, y) for(int i = (x);i <= (y);i++)
using namespace std;
int RD(){
    int out = 0,flag = 1;char c = getchar();
    while(c < '0' || c >'9'){if(c == '-')flag = -1;c = getchar();}
    while(c >= '0' && c <= '9'){out = out * 10 + c - '0';c = getchar();}
    return flag * out;
    }
const int maxn = 200019;
int num, na;
int v[maxn];
#define lid (id << 1)
#define rid (id << 1) | 1
//int max(int a, int b){return a > b ? a : b;}//听说手写快？
struct seg_tree{
    int l, r;
    int sum;
    int lazy;//-1.NULL  0.全为0  1.全为1
	int rev;
    int max[2], lmax[2], rmax[2];
    }tree[maxn << 2];
void pushup(int id){
    tree[id].sum = tree[lid].sum + tree[rid].sum;
    REP(i, 0, 1){
        tree[id].lmax[i] = tree[lid].lmax[i];
        if(i == 1 && tree[lid].sum == tree[lid].r - tree[lid].l + 1)//左区间全满
            tree[id].lmax[i] += tree[rid].lmax[i];//可以跨越
        else if(i == 0 && tree[lid].sum == 0)//左区间全空
            tree[id].lmax[i] += tree[rid].lmax[i];
        
        tree[id].rmax[i] = tree[rid].rmax[i];
        if(i == 1 && tree[rid].sum == tree[rid].r - tree[rid].l + 1)
            tree[id].rmax[i] += tree[lid].rmax[i];
        else if(i == 0 && tree[rid].sum == 0)
            tree[id].rmax[i] += tree[lid].rmax[i];
        
        tree[id].max[i] = tree[lid].rmax[i] + tree[rid].lmax[i];//中间
        tree[id].max[i] = max(tree[id].max[i], tree[lid].max[i]);//继承子区间
        tree[id].max[i] = max(tree[id].max[i], tree[rid].max[i]);
        }
    }
void build(int id, int l, int r){
    tree[id].l = l, tree[id].r = r, tree[id].lazy = -1;
    if(l == r){
        tree[id].sum = v[l];
        tree[id].max[0] = tree[id].lmax[0] = tree[id].rmax[0] = v[l] == 0;
        tree[id].max[1] = tree[id].lmax[1] = tree[id].rmax[1] = v[l] == 1;
        return ;
        }
    int mid = (l + r) >> 1;
    build(lid, l, mid), build(rid, mid + 1, r);
    pushup(id);
    }
void pushdown(int id){
    if(tree[id].lazy != -1){//优先级最高
		tree[id].rev = 0;//清空标记
        int val = tree[id].lazy;
        tree[lid].sum = (tree[lid].r - tree[lid].l + 1) * val;
        tree[rid].sum = (tree[rid].r - tree[rid].l + 1) * val;
        
        tree[lid].lazy = tree[rid].lazy = val;
		tree[lid].rev = tree[rid].rev = 0;
        
        tree[lid].max[val] 
        = tree[lid].lmax[val] 
        = tree[lid].rmax[val] 
        = tree[lid].r - tree[lid].l + 1;
        tree[lid].max[val ^ 1] 
        = tree[lid].lmax[val ^ 1] 
        = tree[lid].rmax[val ^ 1] 
        = 0;
        
        tree[rid].max[val] 
        = tree[rid].lmax[val] 
        = tree[rid].rmax[val] 
        = tree[rid].r - tree[rid].l + 1;
        tree[rid].max[val ^ 1] 
        = tree[rid].lmax[val ^ 1] 
        = tree[rid].rmax[val ^ 1] 
        = 0;
		
		tree[id].lazy = -1;
        }
    if(tree[id].rev){
        tree[lid].sum = (tree[lid].r - tree[lid].l + 1) - tree[lid].sum;
        tree[rid].sum = (tree[rid].r - tree[rid].l + 1) - tree[rid].sum;
        
        if(tree[lid].lazy != -1)tree[lid].lazy ^= 1;//综合考虑优先级， 对其他标记的影响
		else tree[lid].rev ^= 1;
		if(tree[rid].lazy != -1)tree[rid].lazy ^= 1;
		else tree[rid].rev ^= 1;
        
        swap(tree[lid].max[0], tree[lid].max[1]);
        swap(tree[lid].lmax[0], tree[lid].lmax[1]);
        swap(tree[lid].rmax[0], tree[lid].rmax[1]);
        
        swap(tree[rid].max[0], tree[rid].max[1]);
        swap(tree[rid].lmax[0], tree[rid].lmax[1]);
        swap(tree[rid].rmax[0], tree[rid].rmax[1]);
		
		tree[id].rev = 0;
        }
    }
void update(int id, int val, int l, int r){
    pushdown(id);
    if(tree[id].l == l && tree[id].r == r){
        if(val == 0 || val == 1){
            tree[id].sum = (tree[id].r - tree[id].l + 1) * val;
            tree[id].lazy = val;
            tree[id].max[val] 
            = tree[id].lmax[val] 
            = tree[id].rmax[val] 
            = tree[id].r - tree[id].l + 1;
            tree[id].max[val ^ 1] 
            = tree[id].lmax[val ^ 1] 
            = tree[id].rmax[val ^ 1] 
            = 0;
            }
        else if(val == 2){
            tree[id].sum = (tree[id].r - tree[id].l + 1) - tree[id].sum;
            tree[id].rev ^= 1;
            swap(tree[id].max[0], tree[id].max[1]);
            swap(tree[id].lmax[0], tree[id].lmax[1]);
            swap(tree[id].rmax[0], tree[id].rmax[1]);
            }
        return ;
        }
    int mid = (tree[id].l + tree[id].r) >> 1;
    if(mid < l)update(rid, val, l, r);
    else if(mid >= r)update(lid, val, l, r);
    else update(lid, val, l, mid), update(rid, val, mid + 1, r);
    pushup(id);
    }
int query(int id, int l, int r){
    pushdown(id);
    if(tree[id].l == l && tree[id].r == r)return tree[id].sum;
    int mid = (tree[id].l + tree[id].r) >> 1;
    if(mid < l)return query(rid, l, r);
    else if(mid >= r)return query(lid, l, r);
    else return query(lid, l, mid) + query(rid, mid + 1, r);
    }
seg_tree Q_max(int id, int l, int r){
    pushdown(id);
    if(tree[id].l == l && tree[id].r == r)return tree[id];
    int mid = (tree[id].l + tree[id].r) >> 1;
    if(mid < l)return Q_max(rid, l, r);
    else if(mid >= r)return Q_max(lid, l, r);
    else{
        seg_tree ret, L = Q_max(lid, l, mid), R = Q_max(rid, mid + 1, r);
        ret.sum = L.sum + R.sum;
        REP(i, 0, 1){
            ret.lmax[i] = L.lmax[i];
            if(i == 1 && L.sum == L.r - L.l + 1)//左区间全满
                ret.lmax[i] += R.lmax[i];//可以跨越
            else if(i == 0 && L.sum == 0)//左区间全空
                ret.lmax[i] += R.lmax[i];
            
            ret.rmax[i] = R.rmax[i];
            if(i == 1 && R.sum == R.r - R.l + 1)
                ret.rmax[i] += L.rmax[i];
            else if(i == 0 && R.sum == 0)
                ret.rmax[i] += L.rmax[i];
            
            ret.max[i] = L.rmax[i] + R.lmax[i];//中间
            ret.max[i] = max(ret.max[i], L.max[i]);//继承子区间
            ret.max[i] = max(ret.max[i], R.max[i]);
            }
        return ret;
        }
    }
int main(){
    num = RD(), na = RD();
    REP(i, 1, num)v[i] = RD();
    build(1, 1, num);
    while(na--){
        int cmd = RD(), l = RD(), r = RD();l++, r++;
        if(cmd == 0)update(1, 0, l, r);
        else if(cmd == 1)update(1, 1, l, r);
        else if(cmd == 2)update(1, 2, l, r);
        else if(cmd == 3)printf("%d\n", query(1, l, r));
        else printf("%d\n", Q_max(1, l, r).max[1]);
        }
    return 0;
    }
```

---

## 作者：NaCly_Fish (赞：36)

看着题解中线段树冗长的 $\text{pushup}$ 和 $\text{pushdown}$ —— 泪，流了下来。  
此时用平衡树来维护，有很多地方就更好想、好写了。
****
对于每个节点，主要维护 最长前后缀的 $0,1$ 数量，和最长连续 $0,1$ 数量。

对于 $\text{pushup}$，跟维护最大子段和差不多，不过要判断儿子的子树中是否全为 $0$ 或 $1$。  
具体地说，以前是这么维护前缀最大和的
```cpp
pre[u] = max(pre[ls],sum[ls]+val[u]+pre[rs]);
// ls,rs 指左右儿子
```  
现在要这样维护前缀最长连续 $1$ 的数量
```cpp
pre[u] = pre[ls];
if(sum[ls]==size[ls]&&val[u]) pre[u] = max(pre[u],sum[ls]+pre[rs]+1);
// size[u] 指 u 的子树大小
```
对于上传其它信息也是类似的。

打覆盖标记比较简单；打反转标记时，除了要交换对应的 $0,1$ 信息，还需要将覆盖标记取反。（因为我们钦定反转优先级更高，这样便于维护）

修改和查询还是直接把区间分裂出来，打标记/取信息 即可。  
于是这题就被轻松切掉了。  

参考代码：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#define N 100003
#define reg register
#define ll long long
#define mid ((l+r)>>1)
#define ls son[u][0]
#define rs son[u][1]
using namespace std;

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

int b[N];
int n,q;

struct fhqTreap{
    int size[N],son[N][2],rnd[N],tag[N],sum[N],a[N];
    int pre1[N],suf1[N],pre0[N],suf0[N],ans1[N],ans0[N];
    bool inv[N];
    int rt,cnt;

    inline void pushup(int u){ //不过也没短多少
        size[u] = size[ls]+size[rs]+1;
        sum[u] = sum[ls]+sum[rs]+a[u];
        pre1[u] = pre1[ls],suf1[u] = suf1[rs];
        pre0[u] = pre0[ls],suf0[u] = suf0[rs];
        if(a[u]&&size[ls]==sum[ls]) pre1[u] = max(pre1[u],sum[ls]+pre1[rs]+1);
        if(a[u]&&size[rs]==sum[rs]) suf1[u] = max(suf1[u],sum[rs]+suf1[ls]+1);
        if(!a[u]&&!sum[ls]) pre0[u] = max(pre0[u],size[ls]+pre0[rs]+1);
        if(!a[u]&&!sum[rs]) suf0[u] = max(suf0[u],size[rs]+suf0[ls]+1);
        ans1[u] = max(ans1[ls],ans1[rs]);
        ans0[u] = max(ans0[ls],ans0[rs]);
        if(a[u]) ans1[u] = max(ans1[u],suf1[ls]+pre1[rs]+1);
        if(!a[u]) ans0[u] = max(ans0[u],suf0[ls]+pre0[rs]+1);
    }

    inline void pushc(int u,int k){
        a[u] = k;
        sum[u] = k==1?size[u]:0;
        pre1[u] = suf1[u] = ans1[u] = sum[u];
        pre0[u] = suf0[u] = ans0[u] = size[u]-sum[u];
        tag[u] = k==1?1:-1;
    }

    inline void pushiv(int u){
        sum[u] = size[u]-sum[u];
        a[u] ^= 1;
        swap(pre0[u],pre1[u]);
        swap(suf0[u],suf1[u]);
        swap(ans0[u],ans1[u]);
        inv[u] ^= 1;
        tag[u] = -tag[u];
    }

    inline void pushdown(int u){
        if(inv[u]){
            if(ls) pushiv(ls);
            if(rs) pushiv(rs);
            inv[u] = 0;
        }
        if(tag[u]){
            int x = tag[u]==1?1:0;
            if(ls) pushc(ls,x);
            if(rs) pushc(rs,x);
            tag[u] = 0;
        }
    }

    inline int neww(int x){ //新建节点别忘了加初始信息
        int u = ++cnt;
        sum[u] = a[u] = x;
        pre1[u] = suf1[u] = ans1[u] = x;
        pre0[u] = suf0[u] = ans0[u] = !x;
        size[u] = 1;
        rnd[u] = rand();
        return u;
    }

    int merge(int u,int v){
        pushdown(u);
        pushdown(v);
        if(!u||!v) return u|v;
        if(rnd[u]<rnd[v]){
            son[u][1] = merge(son[u][1],v);
            pushup(u);
            return u;
        }else{
            son[v][0] = merge(u,son[v][0]);
            pushup(v);
            return v;
        }
    }

    void split(int cur,int k,int &u,int &v){
        if(!cur){
            u = v = 0;
            return;
        }
        pushdown(cur);
        if(size[son[cur][0]]<k){
            u = cur;
            split(rs,k-size[ls]-1,rs,v);
        }else{
            v = cur;
            split(son[v][0],k,u,son[v][0]);
        }
        pushup(cur);
    }

    inline void replace(int l,int r,int k){
        int x,y,z;
        split(rt,l-1,x,y);
        split(y,r-l+1,y,z);
        pushc(y,k);
        rt = merge(merge(x,y),z);
    }

    inline void invert(int l,int r){
        int x,y,z;
        split(rt,l-1,x,y);
        split(y,r-l+1,y,z);
        pushiv(y);
        rt = merge(merge(x,y),z);
    }

    inline int query_sum(int l,int r){
        int x,y,z,res;
        split(rt,l-1,x,y);
        split(y,r-l+1,y,z);
        res = sum[y];
        rt = merge(merge(x,y),z);
        return res;
    }

    inline int query_ans(int l,int r){
        int x,y,z,res;
        split(rt,l-1,x,y);
        split(y,r-l+1,y,z);
        res = ans1[y];
        rt = merge(merge(x,y),z);
        return res;
    }

    int build(int l,int r){ //线性建树
        if(l>r) return 0;
        int u = neww(b[mid]);
        ls = build(l,mid-1);
        rs = build(mid+1,r);
        pushup(u);
        return u;
    }
}T;

int main(){
    int op,l,r;
    read(n),read(q);
    for(reg int i=1;i<=n;++i) read(b[i]);
    T.rt = T.build(1,n);
    while(q--){
        read(op),read(l),read(r);
        ++l,++r; //序列下标是 [0,n) 之间
        if(op==0) T.replace(l,r,0);
        else if(op==1) T.replace(l,r,1);
        else if(op==2) T.invert(l,r);
        else if(op==3) printf("%d\n",T.query_sum(l,r));
        else printf("%d\n",T.query_ans(l,r));
    }
    return 0;
}
```

---

## 作者：流逝丶 (赞：29)


如果没有区间反转，这题很简单，但是有反转，所以既要维护1，又要维护0。

tot记录区间中1的个数

len记录区间长度

l记录区间左端点

r记录区间右端点

sum1表示区间中最长连续的1的个数

lmax1表示区间中以左端点为起点从左往右的连续1的个数

rmax1表示区间中以右端点为起点从右往左的连续1的个数

0同理

laz1表示区间覆盖，0表示无操作，1表示0覆盖，2表示1覆盖

laz2表示区间反转，0表示无操作，1表示反转

 

定义了这么多就够了，然后考虑建树和update维护

update：

1.tot就直接加就行

2.lmax1更新要看一下左区间是否全为1，若全为1，则应加上右区间lmax1

3.rmax1更新要看一下右区间是否全为1，若全为1，则应加上左区间rmax1

4.sum1更新有三个来源，左区间sum1，右区间sum1，左区间rmax1+右区间lmax1

0维护的同理。

懒得写那多if，else，所以这里直接采用了三目运算符

 

build：

1.边找边求len

2.递归到叶子结点，看原序列中是1还是0,去更新叶子结点的东西

3.三目运算符对1和0的更新相反

4.最后update，由叶子结点回溯，维护整个大区间

 

然后基本的建树完成了，先不想那些个操作，把main框架写出，

change可以分标记表示修改操作，一个就够了

ask返回的东西不同，要分两个

然后main函数也搞定了

 

开始本题比较难理解的一块：down和laz标记。

1.如果之前有反转标记，但是又有覆盖标记，之前的反转标记就没用了，

所以当要打覆盖标记时，反转标记是可以清空的

2.区间覆盖的话就是那些东西等于len或0的问题

3.区间反转把0和1的东西交换就行了

4.down完标记记得清空

 

ask1返回tot就行

ask2分开找区间的话，还有可能是左区间的rmax1+右区间的lmax1，

这个还要取min，因为可能分到两个区间的长度到不了lmax1或rmax1

 

值得注意的是直接下放标记可能叶子结点也下放，可能会越界，所以 开了八倍空间

 






```cpp
#include<iostream>
#include<cstdio>
#define R register
#define lson k<<1,l,mid   //减少码量或者为了好看
#define rson k<<1|1,mid+1,r
#define ls k<<1
#define rs k<<1|1
#define mid ((l+r)>>1)
#define sum1(rt) tr[rt].sum1
#define sum0(rt) tr[rt].sum0
#define lmax1(rt) tr[rt].lmax1
#define lmax0(rt) tr[rt].lmax0
#define rmax1(rt) tr[rt].rmax1
#define rmax0(rt) tr[rt].rmax0
#define len(rt) tr[rt].len
#define laz1(rt) tr[rt].laz1
#define laz2(rt) tr[rt].laz2
#define tot(rt) tr[rt].tot
using namespace std;
const int maxn=200005;
int n,m,a[maxn];
struct node{
    int sum1,lmax1,rmax1;
    int tot,len,laz1,laz2;
    int sum0,lmax0,rmax0;
}tr[maxn<<2];
inline int read(){
    R int s=0,w=1;
    R char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
    return s*w;
}
inline void update(R int k){
    lmax1(k)=(sum1(ls)==len(ls))?len(ls)+lmax1(rs):lmax1(ls);
    rmax1(k)=(sum1(rs)==len(rs))?len(rs)+rmax1(ls):rmax1(rs);
    sum1(k)=max(max(sum1(ls),sum1(rs)),rmax1(ls)+lmax1(rs));
    lmax0(k)=(sum0(ls)==len(ls))?len(ls)+lmax0(rs):lmax0(ls);
    rmax0(k)=(sum0(rs)==len(rs))?len(rs)+rmax0(ls):rmax0(rs);
    sum0(k)=max(max(sum0(ls),sum0(rs)),rmax0(ls)+lmax0(rs));
    tot(k)=tot(ls)+tot(rs);
}
void build(R int k,R int l,R int r){
    len(k)=r-l+1;
	if(l==r){
        tot(k)=a[l];
        lmax1(k)=rmax1(k)=sum1(k)=((a[l]==1)?1:0);
        lmax0(k)=rmax0(k)=sum0(k)=((a[l]==1)?0:1);
        return ;
    }
    build(lson);build(rson);
    update(k);
}
inline void down(R int k){
    if(laz1(k)==1){
        sum0(ls)=lmax0(ls)=rmax0(ls)=len(ls);
        tot(ls)=sum1(ls)=lmax1(ls)=rmax1(ls)=0;
        laz1(ls)=1;laz2(ls)=0;
        sum0(rs)=lmax0(rs)=rmax0(rs)=len(rs);
        tot(rs)=sum1(rs)=lmax1(rs)=rmax1(rs)=0;
        laz1(rs)=1;laz2(rs)=0;
        laz1(k)=0;laz2(k)=0;
    }
    if(laz1(k)==2){
        tot(ls)=sum1(ls)=lmax1(ls)=rmax1(ls)=len(ls);
        sum0(ls)=lmax0(ls)=rmax0(ls)=0;
        laz1(ls)=2;laz2(ls)=0;
        tot(rs)=sum1(rs)=lmax1(rs)=rmax1(rs)=len(rs);
        sum0(rs)=lmax0(rs)=rmax0(rs)=0;
        laz1(rs)=2;laz2(rs)=0;
        laz1(k)=0;laz2(k)=0;
    }
    if(laz2(k)){
        tot(ls)=len(ls)-tot(ls);
        swap(sum0(ls),sum1(ls));
        swap(lmax0(ls),lmax1(ls));
        swap(rmax0(ls),rmax1(ls));
        if(laz1(ls)==1)laz1(ls)=2;
        else if(laz1(ls)==2)laz1(ls)=1;
        else laz2(ls)^=1;
        tot(rs)=len(rs)-tot(rs);
        swap(sum0(rs),sum1(rs));
        swap(lmax0(rs),lmax1(rs));
        swap(rmax0(rs),rmax1(rs));
        if(laz1(rs)==1)laz1(rs)=2;
        else if(laz1(rs)==2)laz1(rs)=1;
        else laz2(rs)^=1;
        laz2(k)=0;
    }
}
void change(R int k,R int l,R int r,R int x,R int y,R int z){
    down(k);
    if(l==x&&y==r){
        if(z==1){
            sum0(k)=lmax0(k)=rmax0(k)=len(k);
            tot(k)=sum1(k)=lmax1(k)=rmax1(k)=0;
            laz1(k)=1;
            laz2(k)=0;
        }
        else if(z==2){
            tot(k)=sum1(k)=lmax1(k)=rmax1(k)=len(k);
            sum0(k)=lmax0(k)=rmax0(k)=0;
            laz1(k)=2;
            laz2(k)=0;
        }
        else {
            tot(k)=len(k)-tot(k);
            swap(sum0(k),sum1(k));
            swap(lmax0(k),lmax1(k));
            swap(rmax0(k),rmax1(k));
            laz2(k)^=1;
        }
        return ;
    }
    if(y<=mid)change(lson,x,y,z);
    else if(x>mid)change(rson,x,y,z);
    else change(lson,x,mid,z),change(rson,mid+1,y,z);
    update(k);
}
int ask1(R int k,R int l,R int r,R int x,R int y){
    down(k);
    if(l==x&&y==r){
        return tot(k);
    }
    if(y<=mid)return ask1(lson,x,y);
    else if(x>mid)return ask1(rson,x,y);
    else return ask1(lson,x,mid)+ask1(rson,mid+1,y);
}
int  ask2(R int k,R int l,R int r,R int x,R int y){
    down(k);
    if(l==x&&y==r){
        return sum1(k);
    }
    if(y<=mid)return ask2(lson,x,y);
    else if(x>mid)return ask2(rson,x,y);
    else return max(max(ask2(lson,x,mid),ask2(rson,mid+1,y)),min(lmax1(rs),y-mid)+min(rmax1(ls),mid-x+1));
}
int main(){
    n=read();m=read();
    for(R int i=1;i<=n;++i)
        a[i]=read();
    build(1,1,n);
    int opt,a,b;
    while(m--){
        opt=read();a=read()+1;b=read()+1;
        if(opt==0)change(1,1,n,a,b,1);
        else if(opt==1)change(1,1,n,a,b,2);
        else if(opt==2)change(1,1,n,a,b,3);
        else if(opt==3)printf("%d\n",ask1(1,1,n,a,b));
        else if(opt==4)printf("%d\n",ask2(1,1,n,a,b));
    }
    return 0;
}
```


---

## 作者：yummy (赞：20)

## 更棒的 bitset 操作，尽在本题解中！

### 传统 bitset

观察到这题的数据范围是 $10^5$，而且全是 $01$ 串，因此联想到 $O(n^2w^{-1})$ 的 bitset。（本文中 $w$ 均表示字长，默认 $64$）。

传统的 bitset 可以借助位运算轻松地维护区间置 $0$、区间置 $1$、区间翻转，时间复杂度均为 $O(n/w)$。而且这三者代码极为接近，一般写完一个稍微改改就能得到另一个。

同时借助 `__builtin_popcountll` 函数（时间复杂度 $O(\log w)$，我们可以写出区间数 $1$ 的代码。

### 难点

但是区间数连续 $1$ 数并不好维护——哪怕维护同一 `int64` 的前缀、后缀 $1$ 数量可以用 `lowbit` 和 `__lg` 解决，同块连续 $1$ 数量也没有对应的位运算手段。

因此我们对于这种操作我们只能放弃位运算，直接将一块内所有情形全部预处理出左侧 $1$ 数、右侧 $1$ 数、连续 $1$ 数。

这也就导致对于这种运算我们选取的块长不能是 $64$ 了（我选的 $16$，也就是一大块变四小块，要是有人不怕麻烦可以选 $21,21,22$），但是前几种操作我们依然可以选 $64$。

### 注意事项 & 调试技巧

- `unsigned long long` 溢出是有定义的，`long long` 溢出算 UB。
- 当你要取二进制某一位时请写成 `1ull<<x`（而非 `1<<x`），否则会导致溢出。
- 大部分同学用小端法 `bitset` 存储（也就是 $2^0$ 位对应 $seq_0$），但是左移右移运算仍然建立在大端法基础上，因此两种记法不要弄混。
- **（适用于所有题目）** 你认为是难点、最容易出错的地方可能反而没那么容易出错，比如这道题我一直在 $4$ 操作上找问题找了一下午，最后发现是 $0$ 操作有一处 $l,r$ 写成 $bl,br$ 了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Rsh=6,B=1<<Rsh,B4=16,Bmx=65535;
//块长是2的Rsh次方也就是B，特别地，4操作块长为 B4，块内最大值Bmx
int n,m,cb[1<<16],l1[1<<16],r1[1<<16];
unsigned long long a[1565],op[64][64];
//op[l][r]为二进制第l..r位均为 1 的二进制数，为减小位运算打错概率我设计成这样
void set0(int l,int r)//[l,r]
{
	int bl=l>>Rsh,br=r>>Rsh;
	l&=B-1;r&=B-1;
	if(bl==br)//特判同一块
	{
		a[bl]&=~op[l][r];
		return;
	}
	a[bl]&=~op[l][B-1];
	a[br]&=~op[0][r];
	for(int i=bl+1;i<br;i++)
		a[i]=0;
}
void set1(int l,int r)
{
	int bl=l>>Rsh,br=r>>Rsh;
	l&=B-1;r&=B-1;
	if(bl==br)
	{
		a[bl]|=op[l][r];
		return;
	}
	a[bl]|=op[l][B-1];
	a[br]|=op[0][r];
	for(int i=bl+1;i<br;i++)
		a[i]=-1ull;
}
void rev(int l,int r)
{
	int bl=l>>Rsh,br=r>>Rsh;
	l&=B-1;r&=B-1;
	if(bl==br)
	{
		a[bl]^=op[l][r];
		return;
	}
	a[bl]^=op[l][B-1];
	a[br]^=op[0][r];
	for(int i=bl+1;i<br;i++)
		a[i]^=-1ull;
}
#define BPL __builtin_popcountll 
int countbit(int l,int r)
{
	int bl=l>>Rsh,br=r>>Rsh;
	l&=B-1;r&=B-1;
	if(bl==br)
		return BPL(a[bl]&op[l][r]);
	int tot=BPL(a[bl]&op[l][B-1])+BPL(a[br]&op[0][r]);
	for(int i=bl+1;i<br;i++)
		tot+=BPL(a[i]);
	return tot;
}
int combo(int l,int r)
{
	if((l>>4)==(r>>4))//其实这不是必须，见后面代码
		return cb[(a[l>>Rsh]&op[l&(B-1)][r&(B-1)])>>(l&(B-1))];
	int bl=l>>Rsh,br=r>>Rsh,overall=0,mxr=0;
    //overall记录当前所有连续1最大值，mxr记录当前有几个连续的1
	unsigned long long RealAbl=a[bl],RealAbr=a[br];
    //为节省讨论，我们将干扰清空，完事重新写入
	a[bl]&=op[l&(B-1)][B-1];a[br]&=op[0][r&(B-1)];
	for(int i=bl;i<=br;i++)
	{
		for(int j=1;j<=4;j++)
		{
			unsigned long long v=a[i]<<(B-j*B4)>>(3*B4);//请注意，这里涉及大端法和小端法的区别
			if(v==Bmx)//如果这块全 1
			{
				overall=max(overall,mxr+B4);
				mxr+=B4;
			}
			else
			{
				overall=max(overall,max(mxr+r1[v],cb[v]));
				mxr=l1[v];
			}
		}
	}
	a[bl]=RealAbl;a[br]=RealAbr;
	return overall;
}
int main()
{
	for(int i=0;i<B;i++)//预处理 op数组
	{
		op[i][i]=1ull<<i;
		for(int j=i+1;j<B;j++)
			op[i][j]=op[i][j-1]|(1ull<<j);
	}
	for(int i=0;i<(1<<B4);i++)
	{
		if(i&1)r1[i]=r1[i>>1]+1;//大端法右侧 1 个数
		else r1[i]=0;
		cb[i]=max(cb[i>>1],r1[i]);//块内最大连续 1 个数
		for(int j=i;j&(1<<B4-1);j=(j<<1)^(1<<B4))l1[i]++;//大端法左侧 1 个数，反正不是瓶颈，多个log无所谓了
	}
	scanf("%d%d",&n,&m);
	unsigned long long tmp;
	for(int i=0;i<n;i++)
	{
		scanf("%llu",&tmp);
		a[i>>Rsh]|=tmp<<(i&(B-1));
	}
	int op,l,r;
	for(;m;m--)
	{
		scanf("%d%d%d",&op,&l,&r);
		if(op==0)set0(l,r);
		if(op==1)set1(l,r);
		if(op==2)rev(l,r);
		if(op==3)printf("%d\n",countbit(l,r));
		if(op==4)printf("%d\n",combo(l,r));
	}
	return 0;
}
```

---

## 作者：Cesare (赞：17)

给出一种分块做法：

对于操作 $0-3$ ，维护两个 $tag$ 来进行翻转等操作。

对于操作四，维护三个数组： $ Max,Rmax,Lmax $ ，表示一个块中的最大连续 $0/1$ ，一个块中包含右端点的最大连续 $0/1$ ，一个块中包含左端点的最大连续  $0/1$ 。

就做完了。

$0-3$ 操作可以参考开关一题， $4$ 操作请自行实现。

给出部分代码（不完整）：

```cpp
namespace Block {
	
	ll len, num, l[N], r[N], bl[N], tag[N], ans[N], Max[N], Lmax[N], Rmax[N];
	
	inline void build () {
		len = sqrt (n), num = ( n - 1 ) / len + 1;
		For ( i, 1, n ) bl[i] = ( i - 1 ) / len + 1;
		For ( i, 1, num ) l[i] = ( i - 1 ) * len + 1, r[i] = i * len;
		r[num] = n;
	}
	
	inline void modify ( ll opt, ll x, ll y ) {
		if ( !opt ) {
			if ( bl[x] == bl[y] ) 
				For ( i, x, y ) 
					ans[bl[x]] -= ( a[i] ^ tag[bl[x]] ),
					a[i] = 0, ans[bl[x]] += ( a[i] ^ tag[bl[x]] );
			else {
				For ( i, x, r[bl[x]] ) {
					ans[bl[x]] -= ( a[i] ^ tag[bl[x]] ),
					a[i] = 0, ans[bl[x]] += ( a[i] ^ tag[bl[x]] );
				}
				For ( i, l[bl[y]], y ) {
					ans[bl[y]] -= ( a[i] ^ tag[bl[y]] ),
					a[i] = 0, ans[bl[y]] += ( a[i] ^ tag[bl[y]] );
				}
				For ( i, bl[x] + 1, bl[y] - 1 ) tag[i] = ans[i] = 0;
			}
		} else {
			if ( bl[x] == bl[y] ) 
				For ( i, x, y ) 
					ans[bl[x]] -= ( a[i] ^ tag[bl[x]] ),
					a[i] = 1, ans[bl[x]] += ( a[i] ^ tag[bl[x]] );
			else {
				For ( i, x, r[bl[x]] ) {
					ans[bl[x]] -= ( a[i] ^ tag[bl[x]] ),
					a[i] = 1, ans[bl[x]] += ( a[i] ^ tag[bl[x]] );
				}
				For ( i, l[bl[y]], y ) {
	       				ans[bl[y]] -= ( a[i] ^ tag[bl[y]] ),
					a[i] = 1, ans[bl[y]] += ( a[i] ^ tag[bl[y]] );
				}
				For ( i, bl[x] + 1, bl[y] - 1 ) tag[i] = 1, ans[i] = len;
			}
		}
	}
	
	inline void update ( ll x, ll y ) {
		if ( bl[x] == bl[y] ) 
			For ( i, x, y ) 
				ans[bl[x]] -= ( tag[bl[x]] ^ a[i] ),
				a[i] ^= 1, ans[bl[x]] += ( tag[bl[x]] ^ a[i] );
		else {
			For ( i, bl[x] + 1, bl[y] - 1 ) 
				tag[i] ^= 1, ans[i] = len - ans[i];
			
			For ( i, x, r[bl[x]] )
				ans[bl[x]] -= ( tag[bl[x]] ^ a[i] ),
				a[i] ^= 1, ans[bl[x]] += ( tag[bl[x]] ^ a[i] );
			
			For ( i, l[bl[y]], y ) 
				ans[bl[y]] -= ( tag[bl[y]] ^ a[i] ),
				a[i] ^= 1, ans[bl[y]] += ( tag[bl[y]] ^ a[i] );
		}
	}
	
	inline ll query ( ll opt, ll x, ll y ) {
		if ( opt == 3 ) {
			ll sum = 0;
			if ( bl[x] == bl[y] ) For ( i, x, y ) sum += ( a[i] ^ tag[bl[x]] ); 
			else {
				For ( i, bl[x] + 1, bl[y] - 1 ) sum += ans[i];
				For ( i, x, r[bl[x]] ) sum += ( a[i] ^ tag[bl[x]] );
				For ( i, l[bl[y]], y ) sum += ( a[i] ^ tag[bl[y]] );
			} return sum;
		} else {
			ll aa = 0, sum = 0;
			if ( bl[x] == bl[y] ) 
				For ( i, x, y ) 
					if ( ( a[i] ^ tag[bl[x]] ) == 1 ) aa++;
					else sum = max ( sum, aa ), aa = 0;
			else {
				For ( i, x, r[bl[x]] ) ;
				For ( i, l[bl[y]], y ) ;
				For ( i, bl[x] + 1, bl[y] - 1 ) ;
			} return sum;
		}
	}
}
```

---

## 作者：lx_zjk (赞：15)

# [SCOI2010]序列操作
此题为 真·码农题 做完此题赶脚对线段树有了2更好的理解

如果没做过 $P 2253$可以先去做那道题,不要用暴力或者乱搞算法~~不过好像暴力可过~~,那道题就是这道题的弱化版本,~~推销一下我在那题的题解~~,然后$pushup$操作就比较好理解了

$sum$表示区间数的和

$t[p].sum = t[ls(p)].sum + t[rs(p)].sum$

$tag$表示区间被集体变成了0 或者 1

${tag|-1, 0, 1}$ 

-1表示未修改 

0表示修改为0 

1表示修改为1

如果$tag != -1$ 

$t[ls(p)].sum = (t[ls(p)].r - t[ls(p)].l + 1) * t[p].tag;$

$t[rs(p)].sum = (t[rs(p)].r - t[rs(p)].l + 1) * t[p].tag;$

$pre[v]$ 和 $suf[v]$都赋值为区间长度

$pre[v$ ^ $1]$ 和 $suf[v $^$ 1]$都变为0

$t[p].rev$也就此无效 变为0
```cpp

		t[ls(p)].sum = (t[ls(p)].r - t[ls(p)].l + 1) * v;
		t[rs(p)].sum = (t[rs(p)].r - t[rs(p)].l + 1) * v;
		
		t[ls(p)].tag = t[rs(p)].tag = v;
		t[ls(p)].rev = t[rs(p)].rev = 0;
		
		t[ls(p)].pre[v] = t[ls(p)].suf[v] = t[ls(p)].dat[v] = (t[ls(p)].r - t[ls(p)].l + 1);
		t[ls(p)].pre[v ^ 1] = t[ls(p)].suf[v ^ 1] = t[ls(p)].dat[v ^ 1] = 0;
		
		t[rs(p)].pre[v] = t[rs(p)].suf[v] = t[rs(p)].dat[v] = (t[rs(p)].r - t[rs(p)].l + 1);
		t[rs(p)].pre[v ^ 1] = t[rs(p)].suf[v ^ 1] = t[rs(p)].dat[v ^ 1] = 0;
		
		t[p].tag = -1;
```

$rev$表示是否被反转

下方时分两种情况如果$tag = [1 / 0]$ $tag = !(tag)$
否则$tag = -1$, rev = rev ^ 1,如果先前已经被反转过了,那么先前的反转无效,否则就加上1

$dat[0/1]$ 实现较简单具体看代码

$suf[0/1]$ 实现较简单具体看代码

$pre[0/1]$ 实现较简单具体看代码

然后一个比较重要的东西,看下面两段$change$函数,一个100分,一个10分,请您自行思考为什么 $ps:$考虑$pushdown$操作对$change$函数内部影响

```cpp
void change(int p, int l, int r, int v){
	push_down(p);
	if (l <= t[p].l && t[p].r <= r){
		if (v == 0 || v == 1){
			t[p].sum = (t[p].r - t[p].l + 1) * v;
			t[p].tag = v;
			t[p].pre[v] = t[p].suf[v] = t[p].dat[v] = (t[p].r - t[p].l + 1);
			t[p].pre[v ^ 1] = t[p].suf[v ^ 1] = t[p].dat[v ^ 1] = 0;
		} 
		else if (v == 2) {
			t[p].sum = (t[p].r - t[p].l + 1) - t[p].sum;
			t[p].rev ^= 1;
			swap(t[p].pre[0], t[p].pre[1]);
			swap(t[p].suf[0], t[p].suf[1]);
			swap(t[p].dat[0], t[p].dat[1]);
		}
		return;
	}
	
	int mid = (t[p].l + t[p].r) >> 1;
	if (l <= mid) change(ls(p), l, r, v);
	if (r > mid) change(rs(p), l, r, v);
	push_up(p);
}
/*
void change(int p, int l, int r, int v){
	if (l <= t[p].l && t[p].r <= r){
		if (v == 0 || v == 1){
			t[p].sum = (t[p].r - t[p].l + 1) * v;
			t[p].tag = v;
			t[p].pre[v] = t[p].suf[v] = t[p].dat[v] = (t[p].r - t[p].l + 1);
			t[p].pre[v ^ 1] = t[p].suf[v ^ 1] = t[p].dat[v ^ 1] = 0;
		} 
		else if (v == 2) {
			t[p].sum = (t[p].r - t[p].l + 1) - t[p].sum;
			t[p].rev ^= 1;
			swap(t[p].pre[0], t[p].pre[1]);
			swap(t[p].suf[0], t[p].suf[1]);
			swap(t[p].dat[0], t[p].dat[1]);
		}
		return;
	}
	push_down(p);
	int mid = (t[p].l + t[p].r) >> 1;
	if (mid < l) change(rs(p), l, r, v);
	else if (r <= mid) change(ls(p), l, r, v);
	else change(ls(p), l, mid, v), change(rs(p), mid + 1, r, v);
	push_up(p);
}
*/
```
完整版


# code

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

inline ll read() {
    ll f = 1, x = 0;char ch;
    do {ch = getchar();if (ch == '-')f = -1;} while (ch > '9' || ch < '0');
    do {x = x * 10 + ch - '0';ch = getchar();} while (ch >= '0' && ch <= '9');
    return f * x;
}

const int MAX_N = 2e5 + 50;

int n, m, a[MAX_N];

struct segment_tree{
	int l, r;
	int sum, tag, rev, pre[2], suf[2], dat[2];
	#define ls(p) (p << 1)
	#define rs(p) (p << 1 | 1)
}t[MAX_N << 2];

void push_up(int p){
	t[p].sum = t[ls(p)].sum + t[rs(p)].sum;
	for (int i = 0; i <= 1; i ++ ){
		t[p].pre[i] = t[ls(p)].pre[i];
		if (i == 1 && t[ls(p)].sum == (t[ls(p)].r - t[ls(p)].l + 1)) 
			t[p].pre[i] += t[rs(p)].pre[i];
		else if (i == 0 && t[ls(p)].sum == 0) 
			t[p].pre[i] += t[rs(p)].pre[i];
		
		t[p].suf[i] = t[rs(p)].suf[i];
		if (i == 1 && t[rs(p)].sum == (t[rs(p)].r - t[rs(p)].l + 1))
			t[p].suf[i] += t[ls(p)].suf[i];
		else if (i == 0 && t[rs(p)].sum == 0)
			t[p].suf[i] += t[ls(p)].suf[i];
		
		t[p].dat[i] = t[ls(p)].suf[i] + t[rs(p)].pre[i];
		t[p].dat[i] = max(t[p].dat[i], t[ls(p)].dat[i]);
		t[p].dat[i] = max(t[p].dat[i], t[rs(p)].dat[i]);
		t[p].dat[i] = max(t[p].dat[i], t[p].pre[i]);
		t[p].dat[i] = max(t[p].dat[i], t[p].suf[i]);
	}
}

void push_down(int p){
	if (t[p].tag != -1) {
		t[p].rev = 0;
		int v = t[p].tag;
		
		t[ls(p)].sum = (t[ls(p)].r - t[ls(p)].l + 1) * v;
		t[rs(p)].sum = (t[rs(p)].r - t[rs(p)].l + 1) * v;
		
		t[ls(p)].tag = t[rs(p)].tag = v;
		t[ls(p)].rev = t[rs(p)].rev = 0;
		
		t[ls(p)].pre[v] = t[ls(p)].suf[v] = t[ls(p)].dat[v] = (t[ls(p)].r - t[ls(p)].l + 1);
		t[ls(p)].pre[v ^ 1] = t[ls(p)].suf[v ^ 1] = t[ls(p)].dat[v ^ 1] = 0;
		
		t[rs(p)].pre[v] = t[rs(p)].suf[v] = t[rs(p)].dat[v] = (t[rs(p)].r - t[rs(p)].l + 1);
		t[rs(p)].pre[v ^ 1] = t[rs(p)].suf[v ^ 1] = t[rs(p)].dat[v ^ 1] = 0;
		
		t[p].tag = -1;
	}
	if (t[p].rev) {
		t[ls(p)].sum = (t[ls(p)].r - t[ls(p)].l + 1) - t[ls(p)].sum;
		t[rs(p)].sum = (t[rs(p)].r - t[rs(p)].l + 1) - t[rs(p)].sum;
		
		if (t[ls(p)].tag != -1) t[ls(p)].tag ^= 1;
		else t[ls(p)].rev ^= 1;
		if (t[rs(p)].tag != -1) t[rs(p)].tag ^= 1;
		else t[rs(p)].rev ^= 1;
		
		swap(t[ls(p)].dat[0], t[ls(p)].dat[1]);
		swap(t[ls(p)].suf[0], t[ls(p)].suf[1]);
		swap(t[ls(p)].pre[0], t[ls(p)].pre[1]);
		
		swap(t[rs(p)].dat[0], t[rs(p)].dat[1]);
		swap(t[rs(p)].suf[0], t[rs(p)].suf[1]);
		swap(t[rs(p)].pre[0], t[rs(p)].pre[1]);
		
		t[p].rev = 0;
	}
	return;
}

void build (int p, int l, int r) {
	t[p].l = l; t[p].r = r; t[p].tag = -1;
	if (l == r) {
		t[p].sum = a[l];
		t[p].pre[a[l]] = t[p].suf[a[l]] = t[p].dat[a[l]] = 1;
		return;
	}
	int mid = (l + r) >> 1;
	build(ls(p), l, mid);
	build(rs(p), mid + 1, r);
	push_up(p);
}

void change(int p, int l, int r, int v){
	push_down(p);
	if (l <= t[p].l && t[p].r <= r){
		if (v == 0 || v == 1){
			t[p].sum = (t[p].r - t[p].l + 1) * v;
			t[p].tag = v;
			t[p].pre[v] = t[p].suf[v] = t[p].dat[v] = (t[p].r - t[p].l + 1);
			t[p].pre[v ^ 1] = t[p].suf[v ^ 1] = t[p].dat[v ^ 1] = 0;
		} 
		else if (v == 2) {
			t[p].sum = (t[p].r - t[p].l + 1) - t[p].sum;
			t[p].rev ^= 1;
			swap(t[p].pre[0], t[p].pre[1]);
			swap(t[p].suf[0], t[p].suf[1]);
			swap(t[p].dat[0], t[p].dat[1]);
		}
		return;
	}
	
	int mid = (t[p].l + t[p].r) >> 1;
	if (l <= mid) change(ls(p), l, r, v);
	if (r > mid) change(rs(p), l, r, v);
	push_up(p);
}
/*
void change(int p, int l, int r, int v){
	if (l <= t[p].l && t[p].r <= r){
		if (v == 0 || v == 1){
			t[p].sum = (t[p].r - t[p].l + 1) * v;
			t[p].tag = v;
			t[p].pre[v] = t[p].suf[v] = t[p].dat[v] = (t[p].r - t[p].l + 1);
			t[p].pre[v ^ 1] = t[p].suf[v ^ 1] = t[p].dat[v ^ 1] = 0;
		} 
		else if (v == 2) {
			t[p].sum = (t[p].r - t[p].l + 1) - t[p].sum;
			t[p].rev ^= 1;
			swap(t[p].pre[0], t[p].pre[1]);
			swap(t[p].suf[0], t[p].suf[1]);
			swap(t[p].dat[0], t[p].dat[1]);
		}
		return;
	}
	push_down(p);
	int mid = (t[p].l + t[p].r) >> 1;
	if (mid < l) change(rs(p), l, r, v);
	else if (r <= mid) change(ls(p), l, r, v);
	else change(ls(p), l, mid, v), change(rs(p), mid + 1, r, v);
	push_up(p);
}
*/
ll query_sum(int p, int l, int r){
	if (l <= t[p].l && t[p].r <= r) 
		return t[p].sum;
	push_down(p);
	int mid = (t[p].l + t[p].r) >> 1;
	int ans = 0;
	if (l <= mid) ans += query_sum(ls(p), l, r);
	if (r > mid) ans += query_sum(rs(p), l, r);
	return ans;
}

segment_tree query_len(int p, int l, int r){
	if (l <= t[p].l && t[p].r <= r) 
		return t[p];
	push_down(p);
	int mid = (t[p].l + t[p].r) >> 1;
	if (r <= mid) return query_len(ls(p), l, r);
	if (l > mid) return query_len(rs(p), l, r);
	segment_tree t1 = query_len(ls(p), l, r), t2 = query_len(rs(p), l, r), t3;
	t3.sum = t1.sum + t2.sum;
	for (int i = 0; i <= 1; i ++ ){
		t3.pre[i] = t1.pre[i];
		if (i == 1 && t1.sum == (t1.r - t1.l + 1)) 
			t3.pre[i] += t2.pre[i];
		else if (i == 0 && t1.sum == 0) 
			t3.pre[i] += t2.pre[i];
		
		t3.suf[i] = t2.suf[i];
		if (i == 1 && t2.sum == (t2.r - t2.l + 1))
			t3.suf[i] += t1.suf[i];
		else if (i == 0 && t2.sum == 0)
			t3.suf[i] += t1.suf[i];
		
		t3.dat[i] = t1.suf[i] + t2.pre[i];
		t3.dat[i] = max(t3.dat[i], t1.dat[i]);
		t3.dat[i] = max(t3.dat[i], t2.dat[i]);
		t3.dat[i] = max(t3.dat[i], t3.pre[i]);
		t3.dat[i] = max(t3.dat[i], t3.suf[i]);
	}
	return t3;
}

int main() {
	n = read(); m = read();
	for (int i = 1; i <= n; i ++ ) a[i] = read();
	build(1, 1, n); 
	for (int i = 1; i <= m; i ++ ){
		int opt = read(), l = read(), r = read();
		l ++ , r ++ ;
		if (opt == 0) change(1, l, r, 0);
		if (opt == 1) change(1, l, r, 1);
		if (opt == 2) change(1, l, r, 2);
		if (opt == 3) printf("%d\n", query_sum(1, l, r));
		if (opt == 4) printf("%d\n", query_len(1, l, r).dat[1]);
	}
	return 0;
}
```

---

## 作者：Mivik (赞：13)

[博客地址](https://mivik.gitee.io/2019/11/12/scoi2010-sequenceoperations.html)

[题目链接](https://www.luogu.org/problem/P2572)

## 题目大意

给定一个01序列，要求支持如下操作：

- 区间赋值
- 区间取反
- 查询区间内1的个数
- 查询区间内最多有多少个连续的1

## 题目思路

就是一个基本的线段树，不过我借这次机会完善了一下我的线段树的基本结构

这个结构还是很完善和解耦的，可以在大部分题目里面使用，代码较为简洁且思路清晰

## 代码基本思路

我们首先定义序列的数据类型为`V`，比如本题中`V`为`bool`

我们需要两个结构体

- Data

  记录一个线段树节点所有需要维护的值和本区间的长度

- Tag

  记录一个线段树节点待下传的修改标记

它们分别需要实现以下方法（方法名可有不同，方便理解即可）：

- Data

```cpp
void init(const V &); //用一个值来初始化线段树节点（要求是叶子节点）
void merge(const Data &, const Data &); //将左右两个Data合并为自己
//其他题目中要求的操作，比如本题中有set赋值,reverse反转
```

- Tag

```cpp
operator bool(); //返回该Tag是否需要下传
void operator+=(const Tag &); //将自己和另一个Tag合并
void apply(const Data &); //将自己代表的修改应用于一个Data上
void clear(); //清除Tag带有的下传标记
```

## 代码实现

首先是一些常用的宏定义ww

```cpp
typedef const int &iint; //iint代表不变的变量，通常在传参中用到，据说有助于优化内存
#define ls (x<<1) //左儿子
#define rs (ls|1) //右儿子
#define LL ls,l,mid //左儿子所需要传的参，由此build(ls,l,mid)就可以简化为build(LL)
#define RR rs,mid+1,r //与上面类似
```



对于本题来讲，我们的Data中需要维护

```cpp
int cnt; //区间中1的个数
int lsm; //区间从左边开始有多少个连续相同的数
int rsm; //区间从右边开始有多少个连续相同的数
bool ld; //区间左边第一个数
bool rd; //区间右边第一个数
int mx[2]; //区间最多连续的(0的个数/1的个数)
int len; //区间长度
```

具体实现

```cpp
struct Data {
	int cnt,lsm,rsm,mx[2];
	bool ld,rd;
	int len;
	inline void init(const bool &val) { //叶子结点赋初值
		mx[val]=len=lsm=rsm=1;
		cnt=ld=rd=val;
	}
	inline void set(const bool &val) { //区间赋值
		lsm=rsm=len;
		cnt=len*val;
		mx[val]=len,mx[!val]=0;
		ld=rd=val;
	}
	inline void reverse() { //区间反转
		ld=!ld,rd=!rd,cnt=len-cnt;
		swap(mx[0],mx[1]);
	}
	inline void merge(const Data &a, const Data &b) { //将两个区间合并为自己
		len=a.len+b.len;
		cnt=a.cnt+b.cnt;
		ld=a.ld,rd=b.rd;
		lsm=a.lsm;
		if (a.lsm==a.len&&a.ld==b.ld) lsm+=b.lsm; //如果左边全是相同的，并且右区间能和左区间连上，那就加上右区间的lsm
		rsm=b.rsm;
		if (b.rsm==b.len&&b.rd==a.rd) rsm+=a.rsm; //和上面类似
		mx[0]=mx[1]=0;
		mx[a.rd]+=a.rsm;
		mx[b.ld]+=b.lsm; //简单思考一下即可明白
		mx[0]=max(mx[0],max(a.mx[0],b.mx[0]));
		mx[1]=max(mx[1],max(a.mx[1],b.mx[1]));
	}
};
```

我们这里将所有结点的Data记为数组 $d$

由此，我们可以轻松地写出我们的上传(pu)和建树(build)函数：

```cpp
inline void pu(iint x) {
	d[x].merge(d[ls],d[rs]);
}
void build(iint x=1, iint l=1, iint r=n) {
	if (l==r) { //叶子节点
		d[x].init(a[l]);
		return;
	}
	int mid=(l+r)>>1;
	build(LL);
	build(RR);
	pu(x);
}
```

怎么样！代码是不是很简短ww

然后我们需要来实现我们的Tag，对于本题来说主要有以下几个部分：

```cpp
bool set, sval; //分别记录当前区间是否有赋值以及赋成什么值
bool rev; //当前区间是否有反转
```

**紧接着就是最容易出错的Tag合并部分！**

我们一定要保证**任意一个时刻不能出现一个Tag既有赋值又有反转的情况**，因为那样我们将无法确定赋值和反转的顺序

所以我们使用如下的实现

```cpp
struct Tag {
	bool set,sval;
	bool rev;
	inline operator bool() const { return set||rev; } //调用时直接用Tag t;if(t){xxx...}，就会调用这个函数把tag转换为bool
	inline void operator+=(const Tag &t) { //区间合并
		if (t.set) { //如果要求赋值
			set=1;
			sval=t.sval; //就赋成这个值
			rev=0; //同时把自己原本的反转标记清空
		} else if (t.rev) { //否则，如果要求反转
			if (set) sval=!sval; //如果自己已经有赋值了，就把自己要赋的值反转
			else rev^=1; //否则记录反转标记
		}
	}
	inline void apply(Data &d) const {
		if (set) d.set(sval);
		else if (rev) d.reverse();
	}
	inline void clear() { set=sval=rev=0; } // 清空标记
};
```

有了这个Tag之后，我们就可以写出我们的下传(pd)函数：

```cpp
inline void pd(iint x) {
	Tag &t=tag[x];
	if (!t) return; //如果没有需要下传的标记，则返回
	t.apply(d[ls]),tag[ls]+=t;
	t.apply(d[rs]),tag[rs]+=t;
	t.clear();
}
```

update函数和query函数也易于理解

```cpp
int ll,rr; //全局变量，记录本次修改/查询的左右端点
Tag tt; //全局变量，记录本次修改要下传的标记
void update(iint x=1, iint l=1, iint r=n) {
	if (ll<=l&&r<=rr) {
		tag[x]+=tt;
		tt.apply(d[x]);
		return;
	}
	int mid=(l+r)>>1;
	pd(x);
	if (mid>=ll) update(LL);
	if (mid<rr) update(RR);
	pu(x);
}
Data query(iint x=1, iint l=1, iint r=n) {
	if (ll<=l&&r<=rr) return d[x];
	int mid=(l+r)>>1;
	pd(x);
	// 对于只需要查询左/右区间的情况，直接返回左/右区间的查询结果
	if (mid<ll) return query(RR);
	if (mid>=rr) return query(LL);
	// 对于两个区间都有包含的情况，我们则需要合并两个区间返回的Data
	Data ret;
	ret.merge(query(LL),query(RR));
	return ret;
}
```

最后我们的main函数就很好写啦，下面直接贴上全部代码吧

```cpp
// Mivik 2019.11.12
// **************
// 下文中R代表读入(Read())，由于题解限制并没有放上Read的实现ww
// **************
#include <iostream>
#include <cstdio>

#define endl '\n'
#define R Read()

typedef const int &iint;

const int nmax = 100005;
const int tmax = 262150;
#define ls (x<<1)
#define rs (ls|1)
#define LL ls,l,mid
#define RR rs,mid+1,r
using namespace std;

int n,m;
bool a[nmax];
int ll,rr;
bool qcnt;
struct Data {
	int cnt,lsm,rsm,mx[2];
	bool ld,rd;
	int len;
	inline void init(const bool &val) {
		mx[val]=len=lsm=rsm=1;
		cnt=ld=rd=val;
	}
	inline void set(const bool &val) {
		lsm=rsm=len;
		cnt=len*val;
		mx[val]=len,mx[!val]=0;
		ld=rd=val;
	}
	inline void reverse() {
		ld=!ld,rd=!rd,cnt=len-cnt;
		swap(mx[0],mx[1]);
	}
	inline void merge(const Data &a, const Data &b) {
		len=a.len+b.len;
		cnt=a.cnt+b.cnt;
		ld=a.ld,rd=b.rd;
		lsm=a.lsm;
		if (a.lsm==a.len&&a.ld==b.ld) lsm+=b.lsm;
		rsm=b.rsm;
		if (b.rsm==b.len&&b.rd==a.rd) rsm+=a.rsm;
		mx[0]=mx[1]=0;
		mx[a.rd]+=a.rsm;
		mx[b.ld]+=b.lsm;
		mx[0]=max(mx[0],max(a.mx[0],b.mx[0]));
		mx[1]=max(mx[1],max(a.mx[1],b.mx[1]));
	}
} d[tmax];
struct Tag {
	bool set,sval;
	bool rev;
	inline operator bool() const { return set||rev; }
	inline void operator+=(const Tag &t) {
		if (t.set) {
			set=1;
			sval=t.sval;
			rev=0;
		} else if (t.rev) {
			if (set) sval=!sval;
			else rev^=1;
		}
	}
	inline void apply(Data &d) const {
		if (set) d.set(sval);
		else if (rev) d.reverse();
	}
	inline void clear() { set=sval=rev=0; }
} tag[tmax],tt;
inline void pu(iint x) { d[x].merge(d[ls],d[rs]); }
inline void pd(iint x) {
	Tag &t=tag[x];
	if (!t) return;
	t.apply(d[ls]),tag[ls]+=t;
	t.apply(d[rs]),tag[rs]+=t;
	t.clear();
}
void build(iint x=1, iint l=1, iint r=n) {
	if (l==r) {
		d[x].init(a[l]);
		return;
	}
	int mid=(l+r)>>1;
	build(LL);
	build(RR);
	pu(x);
}
void update(iint x=1, iint l=1, iint r=n) {
	if (ll<=l&&r<=rr) {
		tag[x]+=tt;
		tt.apply(d[x]);
		return;
	}
	int mid=(l+r)>>1;
	pd(x);
	if (mid>=ll) update(LL);
	if (mid<rr) update(RR);
	pu(x);
}
Data query(iint x=1, iint l=1, iint r=n) {
	if (ll<=l&&r<=rr) return d[x];
	int mid=(l+r)>>1;
	pd(x);
	if (mid<ll) return query(RR);
	if (mid>=rr) return query(LL);
	Data ret;
	ret.merge(query(LL),query(RR));
	return ret;
}
int main() {
	int i;
	n=R,m=R;
	for (i=1;i<=n;i++) a[i]=R;
	build();
	while (m--) {
		i=R,ll=R+1,rr=R+1; //本次操作的左右端点
		switch (i) {
			case 0:tt={1,0,0};update();break;
			case 1:tt={1,1,0};update();break;
			case 2:tt={0,0,1};update();break;
			case 3:cout<<query().cnt<<endl;break;
			case 4:cout<<query().mx[1]<<endl;break;
		}
	}
	return 0;
}
```

----


[欢迎来我的博客逛逛](https://mivik.gitee.io)

---

## 作者：Dispwnl (赞：12)

>修改了排版

这个题的细节很麻烦……定义线段树：

$sum$:这段区间内$1$的总数

$Lb$:这段区间内连续$0$的最大长度

$Lw$:这段区间内连续$1$的最大长度

$llb$:这段区间从左端点连续$0$的最大长度

$llw$:这段区间从左端点连续$1$的最大长度

$rlb$:这段区间从右端点连续$0$的最大长度

$rlw$:这段区间从右端点连续$1$的最大长度

$fl$:翻转标记

$lazy$:下推标记（记录是否全赋为$1$或$0$）

好乱...

可以找出上推关系式：（$0$表示左儿子，$1$表示右儿子）

$sum=sum_0+sum_1$

$Lb=max(Lb_0,Lb_1,rlb_0+llb_1)$（$Lw$同理）

$if(llb_0==mid-l+1)$ $llb=llb_0+llb_1$（$llw$同理）

$if(rlb_1==r-mid)$ $rlb=rlb_1+rlb_0$（$rlw$同理)

然而最恶心的是标记下推，$lazy$的优先级肯定大于翻转标记（全变为一个数就把翻转结果覆盖了）

所以先判断$lazy$,如果有$lazy$,左右儿子的翻转标记都要清空

然后就是慢慢打代码了...

### 代码
```
# include<iostream>
# include<cstdio>
# include<cstring>
# define mid (l+r>>1)
# define tl (k<<1)
# define tr (k<<1|1)
using namespace std;
const int MAX=1e5+1;
struct p{
    int sum,Lw,Lb,llw,rlw,llb,rlb,lazy,fl;
}s[MAX<<2];
int n,m;
int max(int x,int y)
{
    return x>y?x:y;
}
void pus(int l,int r,int k)
{
    s[k].sum=s[tl].sum+s[tr].sum;
    
    s[k].Lb=max(s[tl].Lb,s[tr].Lb);
    s[k].Lw=max(s[tl].Lw,s[tr].Lw);
    
    s[k].llb=s[tl].llb;
    s[k].llw=s[tl].llw;
    if(s[tl].llw==mid-l+1)
    s[k].llw+=s[tr].llw;
    if(s[tl].llb==mid-l+1)
    s[k].llb+=s[tr].llb;
    
    s[k].rlb=s[tr].rlb;
    s[k].rlw=s[tr].rlw;
    if(s[tr].rlw==r-mid)
    s[k].rlw+=s[tl].rlw;
    if(s[tr].rlb==r-mid)
    s[k].rlb+=s[tl].rlb;
    
    s[k].Lw=max(s[k].Lw,s[tl].rlw+s[tr].llw);
    s[k].Lb=max(s[k].Lb,s[tl].rlb+s[tr].llb);
}
void down(int l,int r,int k)
{
    int f=s[k].lazy,fl=s[k].fl,L1=mid-l+1,L2=r-mid;
    s[k].lazy=-1;
    if(!f)
    {
        s[tl]=(p){0,0,L1,0,0,L1,L1,0,0};
        s[tr]=(p){0,0,L2,0,0,L2,L2,0,0};
    }
    else if(f==1)
    {
        s[tl]=(p){L1,L1,0,L1,L1,0,0,1,0};
        s[tr]=(p){L2,L2,0,L2,L2,0,0,1,0};
    }
    if(fl)
    {
        s[k].fl=0;
        int sum=s[tl].sum,Lw=s[tl].Lw,Lb=s[tl].Lb,llw=s[tl].llw,rlw=s[tl].rlw,llb=s[tl].llb,rlb=s[tl].rlb;
        s[tl].sum=L1-sum;
	s[tl].Lw=Lb,s[tl].Lb=Lw;
	s[tl].llw=llb,s[tl].rlw=rlb;
	s[tl].llb=llw,s[tl].rlb=rlw;
	s[tl].fl^=1;
        
        sum=s[tr].sum,Lw=s[tr].Lw,Lb=s[tr].Lb,llw=s[tr].llw,rlw=s[tr].rlw,llb=s[tr].llb,rlb=s[tr].rlb;
        s[tr].sum=L2-sum;
	s[tr].Lw=Lb,s[tr].Lb=Lw;
	s[tr].llw=llb,s[tr].rlw=rlb;
	s[tr].llb=llw,s[tr].rlb=rlw;
	s[tr].fl^=1;
    }
}
void build(int l,int r,int k)
{
    s[k].lazy=-1;
    if(l==r)
    {
        int x;
        scanf("%d",&x);
        s[k]=(p){x,x,(x^1),x,x,(x^1),(x^1),-1,0};
        return;
    }
    build(l,mid,tl);
    build(mid+1,r,tr);
    pus(l,r,k);
}
void change1(int l,int r,int k,int L,int R)
{
    if(l>=L&&r<=R)
    {
        int LL=r-l+1;
        s[k]=(p){0,0,LL,0,0,LL,LL,0,0};
        return;
    }
    if(l>R||r<L) return;
    down(l,r,k);
    change1(l,mid,tl,L,R);
    change1(mid+1,r,tr,L,R);
    pus(l,r,k);
}
void change2(int l,int r,int k,int L,int R)
{
    if(l>=L&&r<=R)
    {
        int LL=r-l+1;
        s[k]=(p){LL,LL,0,LL,LL,0,0,1,0};
        return;
    }
    if(l>R||r<L) return;
    down(l,r,k);
    change2(l,mid,tl,L,R);
    change2(mid+1,r,tr,L,R);
    pus(l,r,k);
}
void change3(int l,int r,int k,int L,int R)
{
    if(l>=L&&r<=R)
    {
        int LL=r-l+1,sum=s[k].sum,Lw=s[k].Lw,Lb=s[k].Lb,llw=s[k].llw,rlw=s[k].rlw,llb=s[k].llb,rlb=s[k].rlb;
        s[k]=(p){LL-sum,Lb,Lw,llb,rlb,llw,rlw,s[k].lazy,(s[k].fl^1)};
        return;
    }
    if(l>R||r<L) return;
    down(l,r,k);
    change3(l,mid,tl,L,R);
    change3(mid+1,r,tr,L,R);
    pus(l,r,k);
}
int ask1(int l,int r,int k,int L,int R)
{
    if(l>=L&&r<=R) return s[k].sum;
    if(l>R||r<L) return 0;
    down(l,r,k);
    return ask1(l,mid,tl,L,R)+ask1(mid+1,r,tr,L,R);
}
p ask2(int l,int r,int k,int L,int R)
{
    if(l>=L&&r<=R) return s[k];
    if(l>R||r<L) return (p){0};
    down(l,r,k);
    p LL=ask2(l,mid,tl,L,R),RR=ask2(mid+1,r,tr,L,R),ans;
    ans.sum=LL.sum+RR.sum;
    ans.Lw=max(LL.Lw,RR.Lw);
    ans.Lb=max(LL.Lb,RR.Lb);
    ans.llw=LL.llw,ans.rlw=RR.rlw;//
    ans.llb=LL.llb,ans.rlb=RR.rlb;//
    if(LL.llb==mid-l+1) ans.llb+=RR.llb;
    if(LL.llw==mid-l+1) ans.llw+=RR.llw;
    if(RR.rlb==r-mid) ans.rlb+=LL.rlb;
    if(RR.rlw==r-mid) ans.rlw+=LL.rlw;
    ans.Lw=max(ans.Lw,LL.rlw+RR.llw);
    ans.Lb=max(ans.Lb,LL.rlb+RR.llb);
    return ans;
}
int main()
{
    scanf("%d%d",&n,&m);
    build(1,n,1);
    for(int i=1;i<=m;i++)
      {
      	int op,a,b;
      	scanf("%d%d%d",&op,&a,&b);
      	a++,b++;
      	if(!op) change1(1,n,1,a,b);
      	else if(op==1) change2(1,n,1,a,b);
      	else if(op==2) change3(1,n,1,a,b);
      	else if(op==3) printf("%d\n",ask1(1,n,1,a,b));
      	else if(op==4) printf("%d\n",ask2(1,n,1,a,b).Lw);
      }
    return 0;
}
```
### [博客](https://a-failure.github.io/2018/03/15/SCOI2010-%E5%BA%8F%E5%88%97%E6%93%8D%E4%BD%9C/)

---

## 作者：Froggy (赞：11)

线段树??

不要!!

### $fhq \ Treap$ 是也!!

线段树维护区间最长连续1很麻烦,平衡树就能很好地减少码量

有一个减少码量的神器:结构体内定义函数!(就是封装起来)

在外部直接~~疯狂~~调用即可!

虽说比较慢,但AC是没问题的,这又是省选题,开O2后快到飞起!

---

细节各位大佬都已说了,这里再点一下:

首先是反转和推平操作的优先级问题,其实谁先谁后都行,但都要注意**前一个操作会影响后一个操作**

比如我写的是先反转再推平,那么反转操作时**别忘了也把推平标记取反**

平衡树节点记录信息**既要记录关于0的也要记录关于1的**,这样子反转操作直接把有关0,1的swap一下即可

---

说一下变量含义,方便大家理解:

$lmax[0/1]$ 区间最左侧连续0/1的个数

$rmax[0/1]$ 区间最右侧连续0/1的个数

$mx[0/1]$ 区间内最多有连续的0/1的个数

$sum1$ 区间内1的个数

$rev$ 反转标记

$cov$ 推平标记(若值为-1则表示不用推平)

$key$ 键值

$val$ 这个位置的值(0/1)

$siz$ 子树(区间)大小

$ch[0/1]$ 左/右儿子

结构体里的封装(只用封装反转和推平)

```cpp
struct node{
	int siz,key,ch[2],val,lmax[2],rmax[2],mx[2],sum1;
	int cov;
	bool rev;
	inline void Rev(){//反转
		rev^=1;
		swap(lmax[0],lmax[1]);
		swap(rmax[0],rmax[1]);
		swap(mx[0],mx[1]);
		if(cov!=-1)cov^=1;
		sum1=siz-sum1;
		val^=1;
	}
	inline void Cov(int d){//推平
		val=d;
		cov=d;
		sum1=(d?siz:0);
		for(int i=0;i<=1;i++){
			lmax[i]=rmax[i]=mx[i]=((d==i)?siz:0);
		}
	}
}t[N];
```

这样就能保证代码的简洁啦!o(*￣▽￣\*)ブ

没有一点压行,长度比除珂朵莉树外的题解短多了

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
using namespace std;
#define N 100100
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<3)+(x<<1)+c-'0';
        c=getchar();
    }
    return x*f;
}
int n,m,cnt,root;
struct node{
	int siz,key,ch[2],val,lmax[2],rmax[2],mx[2],sum1;
	int cov;
	bool rev;
	inline void Rev(){
		rev^=1;
		swap(lmax[0],lmax[1]);
		swap(rmax[0],rmax[1]);
		swap(mx[0],mx[1]);
		if(cov!=-1)cov^=1;
		sum1=siz-sum1;
		val^=1;
	}
	inline void Cov(int d){
		val=d;
		cov=d;
		sum1=(d?siz:0);
		for(int i=0;i<=1;i++){
			lmax[i]=rmax[i]=mx[i]=((d==i)?siz:0);
		}
	}
}t[N];
int NewNode(int data){//初始化别漏了东西,否则会出一些奇怪的错误
	int k=++cnt;
	t[k].val=t[k].sum1=data;
	t[k].siz=1;
	t[k].key=rand();
	t[k].ch[0]=t[k].ch[1]=0;
	t[k].rev=0;
	t[k].cov=-1;
	for(int i=0;i<=1;i++){
		t[k].lmax[i]=t[k].rmax[i]=t[k].mx[i]=(data==i);
	}
	return k;
}
inline void update(int k){
	t[k].siz=t[t[k].ch[0]].siz+t[t[k].ch[1]].siz+1;
	t[k].sum1=t[t[k].ch[0]].sum1+t[t[k].ch[1]].sum1+t[k].val;
	for(int i=0;i<=1;i++){
		t[k].lmax[i]=t[t[k].ch[0]].lmax[i];
		t[k].rmax[i]=t[t[k].ch[1]].rmax[i];
		t[k].mx[i]=max(t[t[k].ch[0]].mx[i],t[t[k].ch[1]].mx[i]);
		if(t[k].val==i){//当i等于节点的值时还要再次更新
			if(t[t[k].ch[0]].sum1==(i?t[t[k].ch[0]].siz:0)){//判断是否左子树内都是相同的值(并且等于i)
				t[k].lmax[i]+=1+t[t[k].ch[1]].lmax[i];
			}
			if(t[t[k].ch[1]].sum1==(i?t[t[k].ch[1]].siz:0)){//类上
				t[k].rmax[i]+=1+t[t[k].ch[0]].rmax[i];
			}
			t[k].mx[i]=max(t[k].mx[i],t[t[k].ch[0]].rmax[i]+1+t[t[k].ch[1]].lmax[i]);
		}
	}
}
inline void pushdown(int k){
	if(t[k].rev){
		t[t[k].ch[0]].Rev();
		t[t[k].ch[1]].Rev();
		t[k].rev=0;
	}
	if(t[k].cov!=-1){
		t[t[k].ch[0]].Cov(t[k].cov);
		t[t[k].ch[1]].Cov(t[k].cov);
		t[k].cov=-1;
	}
}
int Merge(int l,int r){
	if(!l||!r){
		return l+r;
	}
	pushdown(l),pushdown(r);
	if(t[l].key<t[r].key){
		t[l].ch[1]=Merge(t[l].ch[1],r);
		update(l);
		return l;
	}
	else{
		t[r].ch[0]=Merge(l,t[r].ch[0]);
		update(r);
		return r;
	}
}
void Split(int k,int data,int &l,int &r){
	if(!k){
		l=r=0;
		return ;
	}
	pushdown(k);
	if(t[t[k].ch[0]].siz+1<=data){
		l=k;
		Split(t[k].ch[1],data-t[t[k].ch[0]].siz-1,t[k].ch[1],r);
	}
	else{
		r=k;
		Split(t[k].ch[0],data,l,t[k].ch[0]);
	}
	update(k);
}
inline void Change(int x,int y,int d){
	int l,p,r;
	Split(root,y,l,r);
	Split(l,x-1,l,p);
	t[p].Cov(d);
	root=Merge(Merge(l,p),r);
}
inline void Reverse(int x,int y){
	int l,p,r;
	Split(root,y,l,r);
	Split(l,x-1,l,p);
	t[p].Rev();
	root=Merge(Merge(l,p),r);
}
inline int Count1(int x,int y){
	int l,p,r;
	Split(root,y,l,r);
	Split(l,x-1,l,p);
	int ans=t[p].sum1;
	root=Merge(Merge(l,p),r);
	return ans;
}
inline int Ask_MX(int x,int y){
	int l,p,r;
	Split(root,y,l,r);
	Split(l,x-1,l,p);
	int ans=t[p].mx[1];
	root=Merge(Merge(l,p),r);
	return ans;
}
int main(){
	n=read(),m=read();
	for(register int i=1;i<=n;++i){
		int x=read();
		root=Merge(root,NewNode(x));
	}
	for(register int i=1;i<=m;++i){
		int opt=read(),l=read()+1,r=read()+1;
		if(opt==0){
			Change(l,r,0);
		}
		else if(opt==1){
			Change(l,r,1);
		}
		else if(opt==2){
			Reverse(l,r);
		}
		else if(opt==3){
			printf("%d\n",Count1(l,r));
		}
		else{
			printf("%d\n",Ask_MX(l,r));
		}
	}
	return 0;
}
```

[*Froggy's blog*](https://www.luogu.org/blog/1445353309froggy/)

#### 呱!!


---

## 作者：command_block (赞：8)

这道题调了很久,来写个题解(~~前后有关系吗~~)。

主要不是来讲解法的,而是来将如何省思维难度的。

**介绍一下写复杂线段树题目的技巧。**

采用这些技巧,在这题,就不用讨论懒标记之间的相互作用,既省下了代码量又省下了常数。


首先呢,这道题的查询有**区间和**+**区间最大连续1**。

前者,只要在每个节点维护{区间和}就好了,十分简单。

后者,十分套路地,维护{区间左端最长连续1,区间右端最长连续1,区间中最长连续1}

套路见https://www.luogu.org/problemnew/show/P2894

这道题的修改有**区间覆盖**+**区间异或**。

区间覆盖没什么好讲的,区间异或就比较麻烦了。

原来的1都变成0了,所以还要维护{区间左端最长连续0,区间右端最长连续0,区间中最长连续0},异或的时候swap。

具体代码:

```cpp
struct Node
{ 
  char f1,f2;
  //f1:覆盖标记 0:无标记; 1:覆盖为0; 2:覆盖为1.
  //f2:翻转标记 0:无标记; 1:有标记.
  int l0,r0,l1,r1,m0,m1,x,len;
  //l0:区间左端最长连续0; r0:区间右端最长连续0; m0:区间中最长连续0.
  //其余类推
  void rev(){
    swap(l0,l1);
    swap(r0,r1);
    swap(m0,m1);
    x=len-x;
    //异或
  }
  void set()
  {
    if (f1==1){
      l1=r1=m1=x=0;
      l0=r0=m0=len;
    }if (f1==2){
      l1=r1=m1=x=len;
      l0=r0=m0=0;
    }//覆盖
  }
};

这里保存的 len 是区间长度。

保存len是一个小技巧,可以节省代码量和常数。

把针对单个节点的修改操作,写成节点结构体的成员函数,也可以节省代码量和常数。
```

接下来是build

```cpp
这里a是线段树内存池.

void up(int num)
{
  int l=num<<1,r=num<<1|1;
  //保存左右儿子比define更高效,更顺眼
  //其余都是套路
  if (a[l].x==a[l].len)
   a[num].l1=a[l].len+a[r].l1;
  else a[num].l1=a[l].l1;
  if (a[r].x==a[r].len)
   a[num].r1=a[r].len+a[l].r1;
  else a[num].r1=a[r].r1;
  a[num].m1=max(a[l].m1,max(a[r].m1,a[r].l1+a[l].r1));

  if (!a[l].x)
   a[num].l0=a[l].len+a[r].l0;
  else a[num].l0=a[l].l0;
  if (!a[r].x)
   a[num].r0=a[r].len+a[l].r0;
  else a[num].r0=a[r].r0;
  a[num].m0=max(a[l].m0,max(a[r].m0,a[r].l0+a[l].r0));

  a[num].x=a[l].x+a[r].x;
}
void build(int l,int r,int num)
{
  a[num].len=r-l+1;
  //保存len,从此不再修改 
  if(l==r){
  	scanf("%d",&a[num].x);
  	a[num].l1=a[num].r1=a[num].m1=a[num].x;
  	a[num].l0=a[num].r0=a[num].m0=!a[num].x;
  	//初始化
  	return ;
  }int mid=(l+r)>>1;
  build(l,mid,num<<1);
  build(mid+1,r,num<<1|1);
  up(num);
}

都挺套路的,不再赘述。
```

接下来是重头戏:懒标记的处理。

如果同一个节点同时有两个懒标记,就会令人脑阔疼,想半天。

直接**让两个懒标记互斥**,就不会有如此麻烦了。

保证一个节点只能有一个懒标记,覆盖标记和异或标记不能同时存在。

打覆盖标记的时候,如果有异或标记,直接清空。

打异或标记的时候,如果有覆盖标记,把覆盖标记翻转。

这就实现了**让两个懒标记互斥**。

此外,懒标记有两种,

1.打懒标记的节点,其余数据未正确,还需更新

2.打懒标记的节点,其余数据已正确

后者更为稳妥,你可以看看[这道题](https://www.luogu.org/problemnew/show/P2042)

本题解采用后者,常数略有(?)增加。

```cpp
//封装再多,一个inline常数不变

//打异或标记
inline void rev(int num)
{
  if (a[num].f1){
    a[num].f1=1+!(a[num].f1-1);
    a[num].set();
    //打异或标记的时候,如果有覆盖标记,把覆盖标记翻转。
  }else{a[num].f2^=1;a[num].rev();}
  //否则一切正常
}
//打异或标记
inline void set(int num,int op)
{
  a[num].f1=op;
  a[num].f2=0;
  //打覆盖标记的时候,如果有异或标记,直接清空。
  a[num].set();
}
//下传懒标记 
void ladd(int num)
{
  if (num>n*2)return ;
  int l=num<<1,r=num<<1|1;
  //同上 
  if (a[num].f1){set(l,a[num].f1);set(r,a[num].f1);}
  if (a[num].f2){rev(l);rev(r);}
  a[num].f1=a[num].f2=0;
}
//区间左右端外置
int wfl,wfr;
//区间覆盖
void setline(int l,int r,int num,int op)
{
  if (wfl<=l&&r<=wfr){
  	set(num,op);
  	return ;
  }ladd(num);
  int mid=(l+r)>>1;
  if (wfl<=mid)setline(l,mid,num<<1,op);
  if (wfr>mid)setline(mid+1,r,num<<1|1,op);
  up(num);
}
//区间异或
void revline(int l,int r,int num)
{
  if (wfl<=l&&r<=wfr){
  	rev(num);
  	return ;
  }ladd(num);
  int mid=(l+r)>>1;
  if (wfl<=mid)revline(l,mid,num<<1);
  if (wfr>mid)revline(mid+1,r,num<<1|1);
  up(num);
}
```

查询和主函数

```cpp
void query(int l,int r,int num)
{
  ladd(num);
  if (wfl<=l&&r<=wfr){
  	ans[++tn]=a[num];
    //定义一个ans 为Node数组用于收集答案。
  	return ;
  }int mid=(l+r)>>1;
  if (wfl<=mid)query(l,mid,num<<1);
  if (wfr>mid)query(mid+1,r,num<<1|1);
}
int main()
{
  scanf("%d%d",&n,&m);
  build(1,n,1);
  for (int i=1,ord;i<=m;i++){
  	scanf("%d%d%d",&ord,&wfl,&wfr);
    wfl++;wfr++;
  	if (ord<2)setline(1,n,1,ord+1);
    if (ord==2)revline(1,n,1);
    //修改
    if (ord>2){tn=0;query(1,n,1);}
    if (ord==3){
      int sum=0;
      for (int j=1;j<=tn;j++)
       sum+=ans[j].x;
      //将修改得来的区间和相加
      printf("%d\n",sum);
    }if (ord==4){
      Node t;
      for (int j=2;j<=tn;j++){
      	int l=j-1,r=j;
      	if (ans[l].m1==ans[l].len)
         t.l1=ans[l].len+ans[r].l1;
        else t.l1=ans[l].l1;
        if (ans[r].m1==ans[r].len)
         t.r1=ans[r].len+ans[l].r1;
        else t.r1=ans[r].r1;
        t.m1=max(ans[l].m1,max(ans[r].m1,ans[r].l1+ans[l].r1));
        //上面参照up
        t.len=ans[l].len+ans[r].len;
        ans[r]=t;
        //把ans数组通过up合成一个
      }printf("%d\n",ans[tn].m1);
      //直接输出最后一个的答案
      //有点难理解,大家好好想想
    }
  }return 0;
}
```

[评测记录](https://www.luogu.org/recordnew/show/16231698)

可以看到,在没有认真卡常数,注重于代码量(没删注释)和思维难度的情况下,还跑进了最优解前三页。

所以说$Think\ \ twice,code\ \ once.$

---

## 作者：i207M (赞：5)

0 a b 把[a, b]区间内的所有数全变成0

1 a b 把[a, b]区间内的所有数全变成1

2 a b 把[a,b]区间内的所有数全部取反，也就是说把所有的0变成1，把所有的1变成0

3 a b 询问[a, b]区间内总共有多少个1

4 a b 询问[a, b]区间内最多有多少个连续的1

！~~我知道！线段树~~！

相信线段树的维护方法，其他题解已经讲的很清楚了，这里来介绍一下我的标记下放的方法，感觉很好实现的多：

我们考虑两种情况：

1.拥有覆盖标记的父区间下放给拥有区间反转标记的子区间：直接覆盖掉反转标记；

2.拥有反转标记的父区间下放给拥有区间覆盖标记的子区间：**这时不用给子区间下放反转标记，直接把子区间覆盖标记反转！**

这样，一个区间最多只会同时拥有1个标记，不会有冲突了；

一个小提示：

在进行区间反转操作时，在修改标记前，先把原来的标记下放；

~~又臭又长的代码~~

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<list>
#include<queue>
#include<stack>
#include<bitset>
#include<deque>
#include<ctime>
#include<climits>
#include<cctype>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define ri register int
#define il inline
#define fi first
#define se second
#define mp make_pair
#define pairint pair<int,int>
#define mem0(x) memset((x),0,sizeof (x))
#define mem1(x) memset((x),0x3f,sizeof (x))
#define gc getchar
template<class T>void in(T &x)
{
    x = 0;
    bool f = 0;
    char c = gc();
    while (c < '0' || c > '9')
    {
        if (c == '-') f = 1;
        c = gc();
    }
    while ('0' <= c && c <= '9')
    {
        x = (x << 3) + (x << 1) + (c ^ 48);
        c = gc();
    }
    if (f) x = -x;
}
#undef gc
#define pb push_back
#define N 100005
#define M N<<3
#define ls (x<<1)
#define rs (x<<1|1)
#define gm int mid=((l+r)>>1)
// 1100
int n;
int chu[N];// len : 0/1: zero one; 0/1 left/right
int cnt[M][2],len[M][2][2],mx[M][2];
int rev[M],laz[M]; // laz > rev
const int rt=1;
il void up(int x,int l,int r,int mid)
{
    cnt[x][0]=cnt[ls][0]+cnt[rs][0];
    len[x][0][0]=(len[ls][0][0]==mid-l+1)?(len[ls][0][0]+len[rs][0][0]):len[ls][0][0];
    len[x][0][1]=(len[rs][0][1]==r-mid)?(len[rs][0][1]+len[ls][0][1]):len[rs][0][1];
    mx[x][0]=max(max(mx[ls][0],mx[rs][0]),len[ls][0][1]+len[rs][0][0]);
    // 1
    cnt[x][1]=cnt[ls][1]+cnt[rs][1];
    len[x][1][0]=(len[ls][1][0]==mid-l+1)?(len[ls][1][0]+len[rs][1][0]):len[ls][1][0];
    len[x][1][1]=(len[rs][1][1]==r-mid)?(len[rs][1][1]+len[ls][1][1]):len[rs][1][1];
    mx[x][1]=max(max(mx[ls][1],mx[rs][1]),len[ls][1][1]+len[rs][1][0]);
}
void build(int x,int l,int r)
{
    if(l==r)
    {
        cnt[x][chu[l]]=1;
        len[x][chu[l]][0]=len[x][chu[l]][1]=1;
        mx[x][chu[l]]=1;
        return;
    }
    gm;
    build(ls,l,mid);
    build(rs,mid+1,r);
    up(x,l,r,mid);
    // printf("C %d %d: %d\n",l,r,cnt[x][1]);
}
// cnt, len, mx
il void down(int x,int l,int r)
{
    if(laz[x])
    {
        laz[x]&=1;
        rev[x]=0;
        cnt[x][laz[x]]=r-l+1;
        cnt[x][laz[x]^1]=0;
        len[x][laz[x]][0]=len[x][laz[x]][1]=r-l+1;
        len[x][laz[x]^1][0]=len[x][laz[x]^1][1]=0;
        mx[x][laz[x]]=r-l+1;
        mx[x][laz[x]^1]=0;
        laz[ls]=laz[x]+2;
        laz[rs]=laz[x]+2;
        laz[x]=0;
    }
    else if(rev[x])
    {
        swap(cnt[x][0],cnt[x][1]);
        swap(len[x][0][0],len[x][1][0]);
        swap(len[x][0][1],len[x][1][1]);
        swap(mx[x][0],mx[x][1]);
        if(laz[ls]) laz[ls]^=1;
        else rev[ls]^=1;
        if(laz[rs]) laz[rs]^=1;
        else rev[rs]^=1;
        rev[x]=0;
    }
}
void change(int x,int l,int r,int ql,int qr,int op)
{
    if(ql<=l&&r<=qr)
    {
        laz[x]=op+2;
        down(x,l,r);
        return;
    }
    down(x,l,r);
    gm;
    if(ql<=mid) change(ls,l,mid,ql,qr,op);
    else down(ls,l,mid);
    if(qr>mid) change(rs,mid+1,r,ql,qr,op);
    else down(rs,mid+1,r);
    up(x,l,r,mid);
}
void change2(int x,int l,int r,int ql,int qr)
{
    down(x,l,r);
    if(ql<=l&&r<=qr)
    {
        rev[x]^=1;
        down(x,l,r);
        return;
    }
    gm;
    if(ql<=mid) change2(ls,l,mid,ql,qr);
    else down(ls,l,mid);
    if(qr>mid) change2(rs,mid+1,r,ql,qr);
    else down(rs,mid+1,r);
    up(x,l,r,mid);
}
int query(int x,int l,int r,int ql,int qr)
{
    down(x,l,r);
    if(ql<=l&&r<=qr)
        return cnt[x][1];
    gm;
    int t=0;
    if(ql<=mid) t=query(ls,l,mid,ql,qr);
    if(qr>mid) t+=query(rs,mid+1,r,ql,qr);
    return t;
}
struct Node
{
    int l,r,m,al;
    Node() {}
    Node(int tl,int tr,int mm,int all)
    {
        l=tl,r=tr,m=mm,al=all;
    }
};
il void pup(Node &x,Node v)
{
    x.m=max(max(x.m,v.m),x.r+v.l);
    x.l=x.al?x.l+v.l:x.l;
    x.r=v.al?x.r+v.r:v.r;
    x.al&=v.al;
}
Node query2(int x,int l,int r,int ql,int qr)
{
    down(x,l,r);
    if(ql<=l&&r<=qr)
        return Node(len[x][1][0],len[x][1][1],mx[x][1],cnt[x][1]==r-l+1);
    gm;
    Node t(0,0,0,1);
    if(ql<=mid) t=query2(ls,l,mid,ql,qr);
    if(qr>mid) pup(t,query2(rs,mid+1,r,ql,qr));
    return t;
}
signed main()
{
#ifdef M207
    freopen("in.in", "r", stdin);
#endif
    int q;
    in(n); in(q);
    for(ri i=1; i<=n; ++i)
        in(chu[i]);
    build(rt,1,n);
    int op,a,b;
    while(q--)
    {
        in(op),in(a),in(b);
        ++a,++b;
        if(op==0||op==1) change(rt,1,n,a,b,op);
        else if(op==2) change2(rt,1,n,a,b);
        else if(op==3) printf("%d\n",query(rt,1,n,a,b));
        else printf("%d\n",query2(rt,1,n,a,b).m);
    }
    return 0;
}
```

---

## 作者：p_b_p_b (赞：4)

## 96行超短线段树题解

###### ~~1099ms略慢勿喷~~

本题解主要论述压行技巧，思路其他大佬讲的很清晰了，这里不再赘述

看完题之后当然是一眼线段树啦，然而这题似乎需要维护许多个tag，赤裸裸的码农题。


每个节点需要维护这些数据：

`mx[2][3]`，表示0/1组成的在左边/在右边/在中间的最长连续子串。

`tag`，表示区间赋值。

`rev`，表示区间取反。

显而易见，有了那么多tag，pushdown操作一定会又臭又长。

### 一、定义

```cpp
struct hh{int sum,mx[2][4]/*l,r,all*/,tag;bool rev;}tr[sz<<2],null;//null用来赋初值
#define ls tr[k<<1]
#define rs tr[k<<1|1]
#define lson k<<1,l,mid
#define rson k<<1|1,mid+1,r
#define rep() for (int i=1;i<=3;i++)
//define:减小码量的好方法
```
有了以上的define，码量将会减小许多，但还不够。

### 二、利用小函数

注意到pushdown、modify等操作中都要多次写区间赋值、取反等操作，可以塞在一起

```cpp
void Same(hh &x,int l,int r,int t)//区间赋值为t
{
	x.sum=t*(r-l+1);x.tag=t;x.rev=0;
	rep() x.mx[t][i]=r-l+1,x.mx[!t][i]=0;
}
void Rev(hh &x,int l,int r)//区间取反
{
	if (x.tag!=-1) return Same(x,l,r,x.tag^1);
	x.rev^=1;x.sum=r-l+1-x.sum;
	rep() swap(x.mx[0][i],x.mx[1][i]);
}
```

于是，pushdown操作可以开心地缩成短短6行

```cpp
void pushdown(int k,int l,int r)
{
	int mid=(l+r)>>1;
	if (tr[k].tag!=-1){int &t=tr[k].tag;Same(ls,l,mid,t);Same(rs,mid+1,r,t);t=-1;}
	if (tr[k].rev){tr[k].rev=0;Rev(ls,l,mid);Rev(rs,mid+1,r);}
}
```

这时，修改操作也可以变短了（见下文）

### 三、pushup的巧妙运用

你以为pushup只能在修改之后更新？

错啦！！

query的时候，pushup也是可以用的

```cpp
void pushup(hh &k,hh L,hh R,int l,int r,int mid)//将int k改为hh &k，作用更加广泛
{
	k.sum=L.sum+R.sum;
	for (int i=0;i<=1;i++)
	{
		k.mx[i][1]=(L.mx[i][1]==mid-l+1?mid-l+1+R.mx[i][1]:L.mx[i][1]);
		k.mx[i][2]=(R.mx[i][2]==r-mid?r-mid+L.mx[i][2]:R.mx[i][2]);
		k.mx[i][3]=max(max(L.mx[i][3],R.mx[i][3]),L.mx[i][2]+R.mx[i][1]);
	}
}
```

于是，查询操作变成了这样

```cpp
hh query(int k,int l,int r,int x,int y)
{
	int mid=(l+r)>>1;
	hh ret=null;
	if (x<=l&&r<=y) return tr[k];
	pushdown(k,l,r);
	if (y<=mid) return query(lson,x,y);
	if (x>mid) return query(rson,x,y);
	hh L=query(lson,x,y),R=query(rson,x,y);
	pushup(ret,L,R,max(x,l),min(y,r),mid);//!!!
	return ret;
}
```

最后放上96行的完整代码

```cpp
#include<bits/stdc++.h>
#define sz 200020
using namespace std;
int n,m;
struct hh{int sum,mx[2][4]/*l,r,mid*/,tag;bool rev;}tr[sz<<2],null;
#define ls tr[k<<1]
#define rs tr[k<<1|1]
#define lson k<<1,l,mid
#define rson k<<1|1,mid+1,r
#define rep() for (int i=1;i<=3;i++)
void Same(hh &x,int l,int r,int t)
{
	x.sum=t*(r-l+1);x.tag=t;x.rev=0;
	rep() x.mx[t][i]=r-l+1,x.mx[!t][i]=0;
}
void Rev(hh &x,int l,int r)
{
	if (x.tag!=-1) return Same(x,l,r,x.tag^1);
	x.rev^=1;x.sum=r-l+1-x.sum;
	rep() swap(x.mx[0][i],x.mx[1][i]);
}
void pushdown(int k,int l,int r)
{
	int mid=(l+r)>>1;
	if (tr[k].tag!=-1){int &t=tr[k].tag;Same(ls,l,mid,t);Same(rs,mid+1,r,t);t=-1;}
	if (tr[k].rev){tr[k].rev=0;Rev(ls,l,mid);Rev(rs,mid+1,r);}
}
void pushup(hh &k,hh L,hh R,int l,int r,int mid)
{
	k.sum=L.sum+R.sum;
	for (int i=0;i<=1;i++)
	{
		k.mx[i][1]=(L.mx[i][1]==mid-l+1?mid-l+1+R.mx[i][1]:L.mx[i][1]);
		k.mx[i][2]=(R.mx[i][2]==r-mid?r-mid+L.mx[i][2]:R.mx[i][2]);
		k.mx[i][3]=max(max(L.mx[i][3],R.mx[i][3]),L.mx[i][2]+R.mx[i][1]);
	}
}
void make_same(int k,int l,int r,int x,int y,int w)
{
	if (x<=l&&r<=y) return Same(tr[k],l,r,w);
	pushdown(k,l,r);
	int mid=(l+r)>>1;
	if (x<=mid) make_same(lson,x,y,w);
	if (y>mid) make_same(rson,x,y,w);
	pushup(tr[k],ls,rs,l,r,mid);
}
void reverse(int k,int l,int r,int x,int y)
{
	if (x<=l&&r<=y) return Rev(tr[k],l,r);
	pushdown(k,l,r);
	int mid=(l+r)>>1;
	if (x<=mid) reverse(lson,x,y);
	if (y>mid) reverse(rson,x,y);
	pushup(tr[k],ls,rs,l,r,mid);
}
hh query(int k,int l,int r,int x,int y)
{
	int mid=(l+r)>>1;
	hh ret=null;
	if (x<=l&&r<=y) return tr[k];
	pushdown(k,l,r);
	if (y<=mid) return query(lson,x,y);
	if (x>mid) return query(rson,x,y);
	hh L=query(lson,x,y),R=query(rson,x,y);
	pushup(ret,L,R,max(x,l),min(y,r),mid);
	return ret;
}
void build(int k,int l,int r)
{
	tr[k].tag=-1;tr[k].rev=0;
	if (l==r)
	{
		int x;cin>>x;
		tr[k].sum=x;
		rep() tr[k].mx[x][i]=1,tr[k].mx[!x][i]=0;
		return;
	}
	int mid=(l+r)>>1;
	build(lson);build(rson);
	pushup(tr[k],ls,rs,l,r,mid);
}
int main()
{
	ios::sync_with_stdio(0);
	int x,y,z;
	cin>>n>>m;
	build(1,1,n);
	while (m--)
	{
		cin>>z>>x>>y;++x;++y;
		if (z<2) make_same(1,1,n,x,y,z);
		else if (z==2) reverse(1,1,n,x,y);
		else if (z==3) printf("%d\n",query(1,1,n,x,y).sum);
		else printf("%d\n",query(1,1,n,x,y).mx[1][3]);
	}
}
```

---

## 作者：Log_x (赞：4)

一道很长很长的线段树，也算是一道巩固区间操作的好题。这里给出AC代码及较为详细的注释。

 
 
 
 
 


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define xL (x << 1)
#define xR (x << 1 | 1)
using namespace std;
const int N = 4e5 + 5; 
int pr0[N], pr1[N], sf0[N], sf1[N], lon[N], vis[N];
int As0[N], As1[N], sum[N], tag[N], rev[N], n, m;
struct point
{
    int pr, sf, ans, lon;
    point(const int P, const int S, const int A, const int L): 
    pr(P), sf(S), ans(A), lon(L) {}
};
template <class T> inline T Max(const T a, const T b) {return a > b? a : b;}
template <class T> inline void Swap(T &a, T &b) {a ^= b; b ^= a; a ^= b;}
inline int get() //读入优化 
{
    char ch; bool f = false; int res = 0;
    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');
    if (ch == '-') f = true;
     else res = ch - '0';
    while ((ch = getchar()) >='0' && ch <= '9')
        res = (res << 3) + (res << 1) + ch - '0';
    return f? ~res + 1 : res;
}
inline void put(int x) //输出优化 
{
    if (x < 0)
      x = ~x + 1, putchar('-');
    if (x > 9) put(x / 10);
    putchar(x % 10 + 48);
}
inline void Push(const int x)
{
    int L = xL, R = xR;
    sum[x] = sum[L] + sum[R]; 
    //sum[x]表示序列中1的个数，这里可以直接用求和代替 
    As0[x] = Max(Max(As0[L], As0[R]), pr0[R] + sf0[L]);
    As1[x] = Max(Max(As1[L], As1[R]), pr1[R] + sf1[L]);
    //As0/As1表示最长连续0/1的个数 
    //除了从左右节点向上传递之外，还有一种情况就是左节点最长后缀+右节点最长前缀 
    pr0[x] = (sum[L] ? pr0[L] : lon[L] + pr0[R]);
    pr1[x] = (sum[L] == lon[L] ? lon[L] + pr1[R] : pr1[L]);
    //pr0/pr1表示最长连续0/1前缀 
    sf0[x] = (sum[R] ? sf0[R] : lon[R] + sf0[L]);
    sf1[x] = (sum[R] == lon[R] ? lon[R] + sf1[L] : sf1[R]);
    //sf0/sf1表示最长连续0/1后缀
    //这里同时维护了最长连续0/1的个数，这样在区间取反时我们只需将其交换 
}
inline void AddTag(const int x, const int val) 
//操作0/1中的打标记，tag[x] = 0/1分别表示操作0/1, tag[x] = -1表示无标记  
{
    rev[x] = 0; //
```
/\*
去掉这一行就只有10分，这是为什么呢？

显然操作0/1的优先级是要高于操作2的。因为若是在操作2

后再执行操作0/1，操作2就显得没有意义了。那么首先要保证

标记同时存在时只受操作0/1的影响, 同时也不能让操作2的标

记在执行操作0/1的标记前先下传。

\*/
 
 
 
 
 
 
```cpp
    if (val)
    {
        pr0[x] = sf0[x] = As0[x] = 0; tag[x] = 1; 
        pr1[x] = sf1[x] = As1[x] = sum[x] = lon[x];
    }
    else
    {
        pr0[x] = sf0[x] = As0[x] = lon[x]; tag[x] = 0;
        pr1[x] = sf1[x] = As1[x] = sum[x] = 0; 
    } 
}
inline void AddRev(const int x) //操作2中的打标记 
{
    rev[x] ^= 1;
    sum[x] = lon[x] - sum[x];
    Swap(pr0[x], pr1[x]);
    Swap(sf0[x], sf1[x]);
    Swap(As0[x], As1[x]);
}
inline void Down(const int x) //标记下放 
{
    if (tag[x] != -1)
    {
        AddTag(xL, tag[x]); AddTag(xR, tag[x]);
        tag[x] = -1;
    }
    if (rev[x])
    {
        AddRev(xL); AddRev(xR);
        rev[x] = 0;
    }
}
inline void UndTag(const int x, const int l, const int r, const int u, const int v, const int z) //操作0/1 
{
    if (l == u && r == v) return AddTag(x, z);
    Down(x); int mid = l + r >> 1;
    if (u > mid) UndTag(xR, mid + 1, r, u, v, z);
    else if (v <= mid) UndTag(xL, l, mid, u, v, z);
    else
    {
        UndTag(xL, l, mid, u, mid, z);
        UndTag(xR, mid + 1, r, mid + 1, v, z);
    }
    Push(x); 
}
inline void UndRev(const int x, const int l, const int r, const int u, const int v) //操作2 
{
    if (l == u && r == v) return AddRev(x);
    Down(x); int mid = l + r >> 1;
    if (u > mid) UndRev(xR, mid + 1, r, u, v);
    else if (v <= mid) UndRev(xL, l, mid, u, v);
    else
    {
        UndRev(xL, l, mid, u, mid);
        UndRev(xR, mid + 1, r, mid + 1, v);
    }
    Push(x); 
}
inline int QueSum(const int x, const int l, const int r, const int u, const int v) //操作3 
{
    if (l == u && r == v) return sum[x];
    Down(x); int mid = l + r >> 1;
    if (u > mid) return QueSum(xR, mid + 1, r, u, v);
    else if (v <= mid) return QueSum(xL, l, mid, u, v);
    else return QueSum(xL, l, mid, u, mid) + 
                QueSum(xR, mid + 1, r, mid + 1, v);
}
inline point QueAns(const int x, const int l, const int r, const int u, const int v) //操作4 
{
    if (l == u && r == v) return point(pr1[x], sf1[x], As1[x], lon[x]);
    Down(x); int mid = l + r >> 1;
    if (u > mid) return QueAns(xR, mid + 1, r, u, v);
    else if (v <= mid) return QueAns(xL, l, mid, u, v);
    else
    {
        point tx = QueAns(xL, l, mid, u, mid),
              ty = QueAns(xR, mid + 1, r, mid + 1, v);
        return point((tx.pr == tx.lon? tx.lon + ty.pr : tx.pr), 
                     (ty.sf == ty.lon? ty.lon + tx.sf : ty.sf),
                     Max(Max(tx.ans, ty.ans), tx.sf + ty.pr), tx.lon + ty.lon);
```
/\*
要注意的是：线段树在询问时会将询问的区间拆分成若干个完整的管辖区间，

所以我们在将这些区间的信息上传时，也要对其进行维护。那么同样我们也再要记

录区的前缀、后缀以及长度来维护最长连续0/1的长度，这里我用的是结构体来返

回这些信息。

\*/
 
 

```cpp
    }
} 
inline void Bul(const int x, const int l, const int r) //建树 
{
    lon[x] = r - l + 1; tag[x] = -1;
    //lon[x]表示x所管辖的区间长度 
    if (l == r)
    {
        sum[x] = pr1[x] = sf1[x] = As1[x] = vis[l];
        pr0[x] = sf0[x] = As0[x] = vis[l] ^ 1; 
        return ;
    }
    int mid = l + r >> 1;
    Bul(xL, l, mid);
    Bul(xR, mid + 1, r);
    Push(x);
}
int main()
{
    n = get(); m = get(); 
    for (int i = 1; i <= n; ++i) vis[i] = get(); 
    Bul(1, 1, n); int k, u, v;
    while (m--)
    {
         k = get(); u = get() + 1; v = get() + 1;
         switch (k)
         {
            case 0: UndTag(1, 1, n, u, v, 0); break;
            case 1: UndTag(1, 1, n, u, v, 1); break;
            case 2: UndRev(1, 1, n, u, v); break;
            case 3: put(QueSum(1, 1, n, u, v)), putchar('\n'); break;
            case 4: put(QueAns(1, 1, n, u, v).ans), putchar('\n'); break;
         }
    }
    return 0;
}

```

---

## 作者：wenye05 (赞：3)

## 题目链接

[P2572 [SCOI2010]序列操作](https://www.luogu.com.cn/problem/P2572)

我太蒻了，这题做了几天
~~上课也还做来着~~

【说句闲话】当我看到题解区那么些堆积如山的代码时，我是拒绝观看的，相信有同学或许也会有相似感受，而我自认为我的代码可能比较好理解些，也希望这篇题解可以帮助同学们。

~~会短些吗？~~

首先comes the代码细节

```cpp
#define P (k<<1)
#define S P|1
#define M (l+r>>1)
#define len (r-l+1)
```

P是左儿子，S是右儿子，M是区间中点位置，len是区间长度

next，介绍下树上信息

```cpp
struct tree{
	int sum,l,r,mx0,mx1;bool x;int c;	//x for xor, c for cover.
						//x: 1 rev, 0 instead
						//c: 0 don't cover, 1 cover 0, 2 cover 1
}
```

先别急着D我的英语，我来~~翻译~~解释一下

### sum

区间和，即区间有多少1

### l & r

左右端点开始有多少个连续的1/0

连着1，l、r为正，否则为负

由于线段树维护的区间总不为空，故l、r维护区间信息时也不会为0

### mx0 & mx1

区间内最长连续0/1长度

可以为0

## lazy tag

### x

存**连续**取反信息

由于相同一个区间连续两（或者说偶数次）次取反相当于没整，于是用bool存储

至于为什么存**连续**取反信息

是为了push_down的方便

### c

存储覆盖信息

c=0时，没覆盖

c=1时，覆盖0

c=2时，覆盖1

嗯，是时候说push_up push_down那些事了

### push_up

```cpp
void push_up(int k,int l,int r)
{
	sgt[k].sum=sgt[P].sum+sgt[S].sum;
	sgt[k].l=sgt[P].l;sgt[k].r=sgt[S].r;
	if(((sgt[P].l==sgt[P].r && sgt[P].l==sgt[P].sum) || !sgt[P].sum) && sgt[P].l*sgt[S].l>0)	sgt[k].l+=sgt[S].l;
	if(((sgt[S].r==sgt[S].l && sgt[S].r==sgt[S].sum) || !sgt[S].sum) && sgt[S].r*sgt[P].r>0)	sgt[k].r+=sgt[P].r;
	int t=sgt[P].r + sgt[S].l;
	sgt[k].mx0=max(-t,max(sgt[P].mx0,sgt[S].mx0));
	sgt[k].mx1=max(t,max(sgt[P].mx1,sgt[S].mx1));
}
```

啊也！那俩if还有那个t咋回事？莫慌，虽然看上去挺奇怪的，且听我能否顿开你的茅塞
~~关联词语有问题？~~

sum为俩儿子sum的和，l、r先继承区间儿子存储的最左最右的相关值

if条件判断我们分开来说

#### sgt[P/S].l==sgt[P/S].r && sgt[P/S].l/r==sgt[P/S].sum

**考虑儿子l、r覆盖1**

这里判断的是l、r是否覆盖了整个区间，前一个判断即某儿子维护的区间最左最右相关信息是否相等，比较对称

那只有这个判断是否能行呢？

```
1 1 1 0 1 1 1
```
在这个例子中，l、r相等，但并非覆盖全区间，加上sum的判断就可以解决这样一个问题了

其实，若l、r都覆盖1，不能覆盖整个维护区间但相等，那说明什么？说明l、r覆盖的区间不接上。那么不管没接上中间那部分有多少0、1，sum大于等于l+r，从而大于任意l、r；若sum等于l或r了就能够说明l、r接上了，从而说明l、r任意其一都可以覆盖整个维护区间。

#### !sgt[P/S].sum

**考虑儿子l、r覆盖0**

若有1则sum不会是0

#### sgt[P].l*sgt[S].l>0 或是 sgt[S].r*sgt[P].r>0

判断能否连接起来，即判断要连接的部分与当前已知的被一个数字覆盖的区间中数字是否统一，于是变为了判断是否同号的问题。

话比较长，举个例子

```
1 1 0 0
```

在这个例子中，l虽然可以覆盖区间两个1，但到后面就不能连上了，因为变成0了，而l要存储连续的相同数字长度

若if中条件成立，说明要把l/r扩充到其它区间，于是做加法

下面谈谈那个t以及mx的更新

t做的尝试大概是：将左儿子的r和右儿子的l连起来，可以看做将儿子区间连起来，取需要的东西，即当前节点维护区间中间那块是否会有其它变数导致mx变化，而mx变化大体也是因为这个。

左儿子的r和右儿子的l覆盖数字相同没啥好说的，说下不同的情况。

那么加起来t绝对值就会更小。

先前单个儿子区间中mx都不一定会取l或r的值，这里更小了的话那不就更不会取了？

再谈符号，由于mx非负，t若是绝对值比不上，那t原值是正是负是不是都比不上？

终于到了push_down的部分了

### push_down

这里采用先覆盖后取反的顺序，所以在更新信息时若是在某区间整体覆盖，那么这个区间的取反标记就要清空，也与前文说x存的是连续取反信息相呼应

```cpp
void push_down(int k,int l,int r)
{
	if(sgt[k].c){
		cover(P,l,M,sgt[k].c-1);
		cover(S,M+1,r,sgt[k].c-1);	//覆盖操作
	}
	if(sgt[k].x){
		rev(P,l,M);
		rev(S,M+1,r);				//取反操作
	}
	sgt[k].c=0;
	sgt[k].x=0;						//归零
}
```

如此看来，push_down的代码好像也不是那么多嘛

上整个代码了哈

```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
#define ll long long
#define N 100005
#define P (k<<1)
#define S P|1
#define M (l+r>>1)
#define len (r-l+1)
int read()
{
	int w=1,num=0;
	char c=getchar();
	while(c<'0' || c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0' && c<='9'){num=(num<<1)+(num<<3)+c-'0';c=getchar();}
	return w*num;
}
struct tree{
	int sum,l,r,mx0,mx1;bool x;int c;	//x for xor, c for cover.
										//x: 1 rev, 0 instead
										//c: 0 don't cover, 1 cover 0, 2 cover 1
}sgt[N<<2];
int n,m;
int a[N];
void push_up(int k,int l,int r)
{
	sgt[k].sum=sgt[P].sum+sgt[S].sum;
	sgt[k].l=sgt[P].l;sgt[k].r=sgt[S].r;
	if(((sgt[P].l==sgt[P].r && sgt[P].l==sgt[P].sum) || !sgt[P].sum) && sgt[P].l*sgt[S].l>0)	sgt[k].l+=sgt[S].l;
	if(((sgt[S].r==sgt[S].l && sgt[S].r==sgt[S].sum) || !sgt[S].sum) && sgt[S].r*sgt[P].r>0)	sgt[k].r+=sgt[P].r;
	int t=sgt[P].r + sgt[S].l;
	sgt[k].mx0=max(-t,max(sgt[P].mx0,sgt[S].mx0));
	sgt[k].mx1=max(t,max(sgt[P].mx1,sgt[S].mx1));
}
void build(int k,int l,int r)
{
	if(l==r){
		sgt[k].mx1=sgt[k].sum=a[l];
		sgt[k].mx0=!a[l];
		sgt[k].l=sgt[k].r=(a[l]<<1)-1;
		return;
	}
	build(P,l,M);
	build(S,M+1,r);
	push_up(k,l,r);
}
void rev(int k,int l,int r)
{
	sgt[k].sum=len-sgt[k].sum;
	swap(sgt[k].mx0,sgt[k].mx1);
	sgt[k].l*=-1;sgt[k].r*=-1;
	sgt[k].x^=1;
}
void cover(int k,int l,int r,int mode)
{
	sgt[k].mx1=sgt[k].sum=mode*len;
	sgt[k].mx0=(!mode)*len;
	sgt[k].l=((mode<<1)-1)*len; 
	sgt[k].r=sgt[k].l;
	mode+=1;
	sgt[k].c=mode;
	sgt[k].x=0;
}
//c first
void push_down(int k,int l,int r)
{
	if(sgt[k].c){
		cover(P,l,M,sgt[k].c-1);
		cover(S,M+1,r,sgt[k].c-1);
	}
	if(sgt[k].x){
		rev(P,l,M);
		rev(S,M+1,r);
	}
	sgt[k].c=0;
	sgt[k].x=0;
}
void upd(int k,int l,int r,int i,int j,int mode)
{
	if(l>=i && r<=j){
		if(mode!=2)
			cover(k,l,r,mode);
		else
			rev(k,l,r);
		return;
	}
	push_down(k,l,r);
	if(M>=i)	upd(P,l,M,i,j,mode);
	if(M<j)		upd(S,M+1,r,i,j,mode);
	push_up(k,l,r);
}
tree query(int k,int l,int r,int i,int j,int mode)
{
	if(l>=i && r<=j)
		return sgt[k];
	push_down(k,l,r);
	tree ans,t;
	memset(&ans,0,sizeof(ans));memset(&t,0,sizeof(t));
	if(M>=i)	ans=query(P,l,M,i,j,mode);
	if(M<j)		t=query(S,M+1,r,i,j,mode);
	ans.sum+=t.sum;//这里在后面还要减掉t.sum，调了挺久的 
	if(mode==4){
		if(((ans.l==ans.r && ans.l==ans.sum-t.sum) || !ans.sum) && ans.l*t.l>0)	ans.l+=t.l;
		if(((t.l==t.r && t.r==t.sum) || !t.sum) && t.r*ans.r>0)					t.r+=ans.r;
		ans.mx1=max(ans.r+t.l,max(ans.mx1,t.mx1));
		if(t.r)		ans.r=t.r;
		if(!ans.l)	ans.l=t.l;
	}
	return ans;
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)	a[i]=read();
	build(1,1,n);
	for(int i=1;i<=m;i++){
		int mode=read(),l=read(),r=read();
		l++;r++;
		if(mode<=2)	upd(1,1,n,l,r,mode);
		else
			if(mode==3)	printf("%d\n",query(1,1,n,l,r,mode).sum);
			else		printf("%d\n",query(1,1,n,l,r,mode).mx1);
	}
	return 0;
}
```
感谢观看

---

## 作者：ChoHakuNe (赞：3)

正如楼下几位所说，这是一道巩固区间操作的好题，我也用我的风格写了一下，可能在复杂度方面不如几位，但是...简单易懂。


首先这道题的难点就是如何维护和查询区间内**最长连续1**的个数，这部分许多类似题目都有。


要分情况，**向上合并**后区间的最长连续1可能等于：

1. **左**区间的连续最长1；

2. **右**区间的连续最长1；

3. 左右区间的**中间**部分；


灵性的地方来了，第3种情况如何实现呢，不难想到可以维护每个区间左起1和右起1的个数，然后三种情况用max括起来。

然后这两个新信息又如何**向上合并**呢？思考一下，对于左起，情况如下：

1. 若**左子树全部为1**，根的左起1就是**左区间长度加上右字树的左起1**；

2. 否则就是**左子树的左起1**；


右起同理。


这样一来就要维护三个信息了，再看看**修改**操作中，需要反转...那么再分别维护这三个信息的**0值版本**，翻转时进行swap。

此处要注意覆盖操作的优先级高于翻转，也就是说先下放覆盖标签。

~~嗯，有够麻烦。~~


但是**查询**起来也不是那么简单的，因为最终是一个区间内的连续最长1，所以查询函数每次返回一个**节点**，然后分情况讨论，向上递归。那么依然对于左起：

1. 如果**左子树为空**，当前节点左起1为其**右子树左起1**；

2. 如果**左子树不空**:

(1)若**左子树左起1等于左子树区间长度**，当前节点左起1为**左子树区间长加右子树左起1**；

(2)否则当前节点左起1为其**左子树左起1**；


右起同理，最终区间最长1同向上合并操作。

最后返回查询区间的最终最长连续1即可


求和什么的就不必多说，常规操作就好。


代码如下：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=100002;
int a[maxn],n,m,i,x,y,s;
struct node{int l,r,t;}ha;
struct segtree{
    #define lson (o<<1)
    #define rson (o<<1|1)
    #define mid ((l+r)>>1)
    int sumv[maxn<<2],suml[maxn<<2],sumr[maxn<<2],sumt[maxn<<2];//v为value，l为left，r为right，t为total
    int sumlz[maxn<<2],sumrz[maxn<<2],sumtz[maxn<<2];//上一行信息的0值版本，翻转时用
    int reiv[maxn<<2],itiv[maxn<<2],xorv[maxn<<2];//三个标记，这鸟语的0和1就不要在意了
    inline void pushup(int o,int l,int r){//向上合并
        if(suml[lson]==mid-l+1)suml[o]=suml[lson]+suml[rson];//第1种情况
         else suml[o]=suml[lson];//第2种情况
        if(sumr[rson]==r-mid)sumr[o]=sumr[rson]+sumr[lson];
         else sumr[o]=sumr[rson];//右起同理
        sumt[o]=max(max(sumt[rson],sumt[lson]),suml[rson]+sumr[lson]);//实际最长1的三种情况
        if(sumlz[lson]==mid-l+1)sumlz[o]=sumlz[lson]+sumlz[rson];
         else sumlz[o]=sumlz[lson];
        if(sumrz[rson]==r-mid)sumrz[o]=sumrz[rson]+sumrz[lson];
         else sumrz[o]=sumrz[rson];
        sumtz[o]=max(max(sumtz[rson],sumtz[lson]),sumlz[rson]+sumrz[lson]);//0值版本同理
        sumv[o]=sumv[lson]+sumv[rson];
    }
    inline void pushdown(int o,int l,int r){//下放
        if(itiv[o]){
            sumv[lson]=suml[lson]=sumr[lson]=sumt[lson]=mid-l+1;
            sumv[rson]=suml[rson]=sumr[rson]=sumt[rson]=r-mid;
            sumlz[lson]=sumlz[rson]=sumrz[lson]=sumrz[rson]=sumtz[lson]=sumtz[rson]=0;
            itiv[rson]=itiv[lson]=1;
            xorv[lson]=xorv[rson]=reiv[lson]=reiv[rson]=0;
            itiv[o]=0;
        }else if(reiv[o]){
            sumlz[lson]=sumrz[lson]=sumtz[lson]=mid-l+1;
            sumlz[rson]=sumrz[rson]=sumtz[rson]=r-mid;
            sumv[lson]=sumv[rson]=suml[lson]=suml[rson]=sumr[lson]=sumr[rson]=sumt[lson]=sumt[rson]=0;
            reiv[rson]=reiv[lson]=1;
            xorv[lson]=xorv[rson]=itiv[lson]=itiv[rson]=0;
            reiv[o]=0;
        }
        //注意并列的标签不要加else，一并下推
        if(xorv[o]){
            sumv[lson]=mid-l+1-sumv[lson],sumv[rson]=r-mid-sumv[rson];
            swap(sumt[lson],sumtz[lson]);swap(sumt[rson],sumtz[rson]);
            swap(suml[lson],sumlz[lson]);swap(suml[rson],sumlz[rson]);
            swap(sumr[lson],sumrz[lson]);swap(sumr[rson],sumrz[rson]);
            xorv[lson]^=1;xorv[rson]^=1;
            xorv[o]=0;
        }
    }
    inline void build(int o,int l,int r){建树
        reiv[o]=itiv[o]=xorv[o]=0;
        if(l==r){
         suml[o]=sumr[o]=sumt[o]=sumv[o]=a[l];
         sumlz[o]=sumrz[o]=sumtz[o]=a[l]^1;
         return;
        }
        build(lson,l,mid);
        build(rson,mid+1,r);
        pushup(o,l,r);
    }
    inline int querysum(int o,int l,int r,int ql,int qr){//求和，即1的个数
        if(ql<=l&&qr>=r)return sumv[o];
        pushdown(o,l,r);
        int ans=0;
        if(ql<=mid)ans+=querysum(lson,l,mid,ql,qr);
        if(qr>mid)ans+=querysum(rson,mid+1,r,ql,qr);
        return ans;
    }
    inline node querymax(int o,int l,int r,int ql,int qr){//求最长连续1
        if(ql<=l&&qr>=r)return (node){suml[o],sumr[o],sumt[o]};
        pushdown(o,l,r);
        node t,tl,tr;//用结构体分别维护三个信息
        int fll=0,flr=0;//判断子树是否为空的flag
        if(ql<=mid)tl=querymax(lson,l,mid,ql,qr);else{tl=(node){0,0,0};fll=1;}//赋成0，以免影响最终区间内最长连续1的比较
        if(qr>mid)tr=querymax(rson,mid+1,r,ql,qr);else{tr=(node){0,0,0};flr=1;}
        if(tl.l==mid-l+1)t.l=tl.l+tr.l;//1
         else if(fll==1)t.l=tr.l;//2(1)
          else t.l=tl.l;//2(2)
        if(tr.r==r-mid)t.r=tr.r+tl.r;
         else if(flr==1)t.r=tl.r;
          else t.r=tr.r;
        t.t=max(max(tr.t,tl.t),tl.r+tr.l);
        return t;
    }
    inline void optiti(int o,int l,int r,int ql,int qr){//区间赋为1
        if(ql<=l&&qr>=r){
            sumv[o]=r-l+1;
            sumlz[o]=sumrz[o]=sumtz[o]=0;
            suml[o]=sumr[o]=sumt[o]=r-l+1;
            xorv[o]=0,itiv[o]=1,reiv[o]=0;
            return;
        }
        pushdown(o,l,r);
        if(ql<=mid)optiti(lson,l,mid,ql,qr);
        if(qr>mid)optiti(rson,mid+1,r,ql,qr);
        pushup(o,l,r);
    }
    inline void optrei(int o,int l,int r,int ql,int qr){//区间赋为0
        if(ql<=l&&qr>=r){
            sumv[o]=0;
            sumlz[o]=sumrz[o]=sumtz[o]=r-l+1;
            suml[o]=sumr[o]=sumt[o]=0;
            xorv[o]=0,itiv[o]=0,reiv[o]=1;
            return;
        }
        pushdown(o,l,r);
        if(ql<=mid)optrei(lson,l,mid,ql,qr);
        if(qr>mid)optrei(rson,mid+1,r,ql,qr);
        pushup(o,l,r);
    }
    inline void optxor(int o,int l,int r,int ql,int qr){//区间翻转
        if(ql<=l&&qr>=r){
            sumv[o]=r-l+1-sumv[o];
            swap(sumt[o],sumtz[o]);
            swap(suml[o],sumlz[o]);
            swap(sumr[o],sumrz[o]);
            xorv[o]^=1;
            return;
        }
        pushdown(o,l,r);
        if(ql<=mid)optxor(lson,l,mid,ql,qr);
        if(qr>mid)optxor(rson,mid+1,r,ql,qr);
        pushup(o,l,r);
    }
}seg;
int main(){
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)scanf("%d",&a[i]);
    seg.build(1,1,n);
    while(m--){
        scanf("%d%d%d",&s,&x,&y);
        x++;y++;
        switch(s){//最好加上break
            case 0:seg.optrei(1,1,n,x,y);break;
            case 1:seg.optiti(1,1,n,x,y);break;
            case 2:seg.optxor(1,1,n,x,y);break;
            case 3:printf("%d\n",seg.querysum(1,1,n,x,y));break;
            case 4:printf("%d\n",seg.querymax(1,1,n,x,y).t);break;
        }
    }
    return 0;
}
```
从本人博客转移，markdown语法可能稍有偏差，望见谅。


---

## 作者：resftlmuttmotw (赞：1)

[P2572 [SCOI2010]序列操作](https://www.luogu.org/problem/P2572)

这道题题解已经很多了

但是我还是想写一篇

~~纪念 调三天代码~~


### 思路

思路 很简单

```cpp
struct node
{
	int len,sum,lazy,rev,lsum[2],rsum[2],maxl[2];
}tree[MAXN << 2];
len:长度

sum:1的个数

lazy:把[a, b]区间内的所有数全变成0/1标记

rev:反转标记

lsum[1/0]:记录从左边开始的最长连续1/0的个数

rsum[1/0]:记录从右边开始的最长连续1/0的个数

maxl[1/0]:记录区间内最长连续1/0的个数
```

然后 就正常的线段树操作了

主要是调试

### 调试要点

来说一些技巧

$pushdown$时 要么左区间,要么右区间

可以考虑 两次$pushdown$ 

每次传 现在区间标号 修改区间标号 修改区间长度

```cpp
pushdown(k,k << 1,mid - l + 1);
pushdown(k,k << 1 | 1,r - mid);
r - mid ！！不要+1！！
```

类似的

```cpp
update(k,k << 1,k << 1 | 1,mid - l + 1,r - mid,0);
修改lsum[0],rsum[0],maxl[0]
update(k,k << 1,k << 1 | 1,mid - l + 1,r - mid,1);
修改lsum[1],rsum[1],maxl[1]
```

### $code$

```cpp
#include <stack>
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
#define reg register int
#define isdigit(x) ('0' <= x&&x <= '9')
template<typename T>
inline T Read(T Type)
{
	T x = 0,f = 1;
	char a = getchar();
	while(!isdigit(a)) {if(a == '-') f = -1;a = getchar();}
	while(isdigit(a)) {x = (x << 1) + (x << 3) + (a ^ '0');a = getchar();}
	return x * f;
}
const int MAXN = 100010;
struct segment_tree
{
	struct node
	{
		int len,sum,lazy,rev,lsum[2],rsum[2],maxl[2];
	}tree[MAXN << 2];
	void update(int k,int k1,int k2,int lenl,int lenr,int x) 
	{
		tree[k].maxl[x] = max(tree[k1].maxl[x],max(tree[k2].maxl[x],tree[k1].rsum[x] + tree[k2].lsum[x]));
		tree[k].lsum[x] = tree[k1].lsum[x];
		if(tree[k1].lsum[x] == lenl) tree[k].lsum[x] += tree[k2].lsum[x];
		tree[k].rsum[x] = tree[k2].rsum[x];
		if(tree[k2].rsum[x] == lenr) tree[k].rsum[x] += tree[k1].rsum[x];
		tree[k].sum = tree[k1].sum + tree[k2].sum;
	}
	void build(int k,int l,int r) 
	{
		if(l == r)
		{
			int x = tree[k].sum = Read(1);
			tree[k].maxl[x] = tree[k].lsum[x] = tree[k].rsum[x] = 1;
			tree[k].maxl[!x] = tree[k].lsum[!x] = tree[k].rsum[!x] = 0;
			tree[k].lazy = -1,tree[k].rev = 0;
			return;
		}
		int mid = l + r >> 1;
		tree[k].lazy = -1,tree[k].rev = 0;
		build(k << 1,l,mid);
		build(k << 1 | 1,mid + 1,r);
		update(k,k << 1,k << 1 | 1,mid - l + 1,r - mid,0);
		update(k,k << 1,k << 1 | 1,mid - l + 1,r - mid,1);
	}
	void pushdown(int k,int k1,int len) 
	{
		if(tree[k].lazy != -1)
		{
			int x = tree[k1].lazy = tree[k].lazy;
			tree[k].rev = tree[k1].rev = 0;
			//lazy与rev的优先级务必考虑清楚 
			tree[k1].sum = (x == 1?len:0);
			tree[k1].maxl[x] = tree[k1].lsum[x] = tree[k1].rsum[x] = len;
			tree[k1].maxl[!x] = tree[k1].lsum[!x] = tree[k1].rsum[!x] = 0;
		}
		if(tree[k].rev)
		{
			if(tree[k1].lazy != -1) tree[k1].lazy = !tree[k1].lazy;
			else tree[k1].rev = !tree[k1].rev;
			//lazy与rev的优先级务必考虑清楚 
			//下传时，注意修改l/r区间的rev和lazy 此时仍得考虑优先级 
			tree[k1].sum = len - tree[k1].sum;
			swap(tree[k1].lsum[0],tree[k1].lsum[1]);
			swap(tree[k1].rsum[0],tree[k1].rsum[1]);
			swap(tree[k1].maxl[0],tree[k1].maxl[1]);
		}
	}
	void change(int k,int l,int r,int L,int R,int x) 
	{
		if(L <= l&&r <= R)
		{
			tree[k].lazy = x,tree[k].rev = 0; 
			tree[k].sum = (x == 1?r - l + 1:0);
			tree[k].maxl[x] = tree[k].lsum[x] = tree[k].rsum[x] = r - l + 1;
			tree[k].maxl[!x] = tree[k].lsum[!x] = tree[k].rsum[!x] = 0;
			return;
		}
		int mid = l + r >> 1;
		pushdown(k,k << 1,mid - l + 1);
		pushdown(k,k << 1 | 1,r - mid);
		tree[k].lazy = -1,tree[k].rev = 0;
		if(L <= mid) change(k << 1,l,mid,L,R,x);
		if(mid < R) change(k << 1 | 1,mid + 1,r,L,R,x);
		update(k,k << 1,k << 1 | 1,mid - l + 1,r - mid,0);
		update(k,k << 1,k << 1 | 1,mid - l + 1,r - mid,1);
	}
	void inverse(int k,int l,int r,int L,int R) 
	{
		if(L <= l&&r <= R)
		{
			if(tree[k].lazy != -1) tree[k].lazy = !tree[k].lazy;
			else tree[k].rev = !tree[k].rev;
			tree[k].sum = r - l + 1 - tree[k].sum;
			swap(tree[k].lsum[0],tree[k].lsum[1]);
			swap(tree[k].rsum[0],tree[k].rsum[1]);
			swap(tree[k].maxl[0],tree[k].maxl[1]);
			return;
		}
		int mid = l + r >> 1;
		pushdown(k,k << 1,mid - l + 1);
		pushdown(k,k << 1 | 1,r - mid);
		tree[k].lazy = -1,tree[k].rev = 0;
		if(L <= mid) inverse(k << 1,l,mid,L,R);
		if(mid < R) inverse(k << 1 | 1,mid + 1,r,L,R);
		update(k,k << 1,k << 1 | 1,mid - l + 1,r - mid,0);
		update(k,k << 1,k << 1 | 1,mid - l + 1,r - mid,1);
	}
	int query(int k,int l,int r,int L,int R) 
	{
		
		if(L <= l&&r <= R) return tree[k].sum;
		int mid = l + r >> 1;
		pushdown(k,k << 1,mid - l + 1);
		pushdown(k,k << 1 | 1,r - mid);
		tree[k].lazy = -1,tree[k].rev = 0;
		int ans = 0;
		if(L <= mid) ans = query(k << 1,l,mid,L,R);
		if(mid < R) ans += query(k << 1 | 1,mid + 1,r,L,R);
		update(k,k << 1,k << 1 | 1,mid - l + 1,r - mid,0);
		update(k,k << 1,k << 1 | 1,mid - l + 1,r - mid,1);
		return ans;
	}
	node Sum(int k,int l,int r,int L,int R) 
	{
		if(L <= l&&r <= R) 
		{
			tree[k].len = r - l + 1;
			return tree[k];
		}
		int mid = l + r >> 1;
		pushdown(k,k << 1,mid - l + 1);
		pushdown(k,k << 1 | 1,r - mid);
		tree[k].lazy = -1,tree[k].rev = 0;
		node k1[2];
		memset(k1,0,sizeof(k1));
		if(L <= mid) k1[0] = Sum(k << 1,l,mid,L,R);
		if(mid < R) k1[1] = Sum(k << 1 | 1,mid + 1,r,L,R);
		update(k,k << 1,k << 1 | 1,mid - l + 1,r - mid,0);
		update(k,k << 1,k << 1 | 1,mid - l + 1,r - mid,1);
		node k3;
		k3.maxl[1] = max(k1[0].maxl[1],max(k1[1].maxl[1],k1[0].rsum[1] + k1[1].lsum[1]));
		k3.lsum[1] = k1[0].lsum[1];
		if(k1[0].lsum[1] == k1[0].len) k3.lsum[1] += k1[1].lsum[1];
		k3.rsum[1] = k1[1].rsum[1];
		if(k1[1].rsum[1] == k1[1].len) k3.rsum[1] += k1[0].rsum[1];
		k3.len = k1[0].len + k1[1].len;
		//不要忘了算len 这行没写 只会wa两个点 
		return k3;
	}
}T;
int main()
{
	int n = Read(1),m = Read(1);
	memset(T.tree,0,sizeof(T.tree));
	T.build(1,1,n);
	while(m--)
	{
		int ans,op = Read(1),l = Read(1) + 1,r = Read(1) + 1;
		//不要忘了加1 
		switch(op)
		{
			case 0: T.change(1,1,n,l,r,0); break; 
			case 1: T.change(1,1,n,l,r,1); break; 
			case 2: T.inverse(1,1,n,l,r); break; 
			case 3: ans = T.query(1,1,n,l,r); printf("%d\n",ans); break; 
			case 4: ans = T.Sum(1,1,n,l,r).maxl[1]; printf("%d\n",ans); break; 
		}
	}
	return 0;
}
```

### 总结

这种毒瘤数据结构题

先静态查错

再对拍

然后求助

~~或者直接求助~~

#### 帮助工具

如果还没调出来 可以尝试以下方式


小蒟蒻皮皮鱼  提供的对拍程序 
```cpp
#include<bit/stdc++.h>
using namespace std;
int main()
{
    while(1)
    {
        system("gen.exe");//这是你的数据生成器
        system("1.exe < data.in > 1.out");//这是你的程序 
        system("2.exe < data.in > 2.out");//这是题解或者需要对拍的暴力
        if(system("fc 1.out 2.out")) break;//对两个的输出进行比较，不一样就会终止程序 
    }
}
```

LJC00118 提供的 

[数据生成程序](https://www.luogu.org/discuss/show/43457)

---

## 作者：jins3599 (赞：1)

(对拍写错了，然后拍了半个小时总是答案错误，一怒之下直接交评测就A了..）

复杂，但不困难的线段树。

### 线段树的结点维护哪些信息？

- 1. 左右端点颜色
- 2. 最长连续$1$
- 3. 最长连续$0$
- 4. 反转，覆盖标记
- 5. 总共有多少$1$

### 如何合并区间？

首先考虑信息5，我们直接用区间和的合并方式即可。

然后再看信息2，3，显然我们可以通过考虑当前区间的靠左最长连续段，靠右最长连续段和中间最长连续段来维护合并。

再看信息1，直接让他的左端点等于左儿子左端点，右端点等于右儿子右端点即可。

### 如何下放标记？

我们发现覆盖标记在下放的时候，会覆盖掉之前的所有标记。

因此我们先下放覆盖标记，再下方反转标记即可。

下方反转标记时有什么要注意的？

如果下方的下一个子区间有覆盖标记的话，我们只需要把他的覆盖标记异或一即可，若没有覆盖标记，那就把他的反转标记异或一。

为什么？如果下一个区间有覆盖标记并且有反转标记的话，他的覆盖标记一定时先到的，并且反转标记会把他的覆盖标记反转，如果我们下次的反转标记又来到了这个区间，我们只需要把他的覆盖标记反转，不去管他的反转标记即可。

同理，若他有覆盖标记却没有反转标记的话，和上面一样。

### 如何查询和更新？

前几个操作都是基础的线段树上的操作，我们主要说一下最后一个操作。

我们需要维护一个返回结构体的函数，然后我们每次查询之后合并查询的两个区间的答案，然后返回这个合并的答案，过程类似于一个`pushup`的过程，最后的答案就是结构体中的**最长连续一**的那个信息。

代码不难写，主要是细心。

$Code:$

```cpp
#include <bits/stdc++.h>
#define ls(x) x << 1
#define rs(x) x << 1 | 1

using namespace std;

const int N = 2 * 1e5;
int n , m , a[N];

struct Seg {
	int l , r , len; // 本属性 
	int qf , fg; // tag
	int dis; // 有几个一 
	int ld , rd; // 左右结点颜色 
	int lft[2] , rgt[2] , mid[2]; // 维护最长序列1/0 
	Seg() {fg = -1;
	l = r = len = qf = dis = ld = rd = lft[1] = rgt[1] = mid[1] = lft[0] = rgt[0] = mid[0] = 0;}
}t[N << 1];

void pushup(int x) {
	t[x].dis = t[ls(x)].dis + t[rs(x)].dis;
	t[x].ld = t[ls(x)].ld; t[x].rd = t[rs(x)].rd;
	
	t[x].lft[1] = t[ls(x)].lft[1]; t[x].rgt[1] = t[rs(x)].rgt[1];
	t[x].lft[0] = t[ls(x)].lft[0]; t[x].rgt[0] = t[rs(x)].rgt[0];
	
	if(t[ls(x)].lft[1] == t[ls(x)].len) t[x].lft[1] += t[rs(x)].lft[1];
	if(t[ls(x)].lft[0] == t[ls(x)].len) t[x].lft[0] += t[rs(x)].lft[0];
	
	if(t[rs(x)].rgt[1] == t[rs(x)].len) t[x].rgt[1] += t[ls(x)].rgt[1];
	if(t[rs(x)].rgt[0] == t[rs(x)].len) t[x].rgt[0] += t[ls(x)].rgt[0];
	
	t[x].mid[1] = max(t[ls(x)].mid[1] , t[rs(x)].mid[1]);
	t[x].mid[0] = max(t[ls(x)].mid[0] , t[rs(x)].mid[0]);
	
	t[x].mid[1] = max(t[x].mid[1] , t[ls(x)].rgt[1] + t[rs(x)].lft[1]);
	t[x].mid[0] = max(t[x].mid[0] , t[ls(x)].rgt[0] + t[rs(x)].lft[0]); 
}

void built(int x , int l , int r ){
	t[x].l = l , t[x].r = r;
	t[x].len = r - l + 1;
	if(l == r) {
		t[x].dis = a[l];
		t[x].ld = t[x].rd = a[l];
		t[x].lft[1] = t[x].rgt[1] = t[x].mid[1] = a[l];
		t[x].lft[0] = t[x].rgt[0] = t[x].mid[0] = (a[l] ^ 1);
		return ;
	}
	int mid = (l + r) >> 1;
	built(ls(x) , l , mid);
	built(rs(x) , mid + 1 , r);
	pushup(x);
}

void pushdown(int x) {
	if(t[x].fg != -1) {
		int tag = t[x].fg;
		t[ls(x)].fg = tag;
		t[rs(x)].fg = tag;
		t[ls(x)].dis = tag * t[ls(x)].len;
		t[rs(x)].dis = tag * t[rs(x)].len;
		t[ls(x)].ld = t[ls(x)].rd = t[rs(x)].ld = t[rs(x)].rd = tag;
		t[ls(x)].qf = t[rs(x)].qf = 0;
		t[ls(x)].lft[1] = t[ls(x)].rgt[1] = t[ls(x)].mid[1] = tag * t[ls(x)].len;
		t[rs(x)].lft[1] = t[rs(x)].rgt[1] = t[rs(x)].mid[1] = tag * t[rs(x)].len;
		
		t[ls(x)].lft[0] = t[ls(x)].rgt[0] = t[ls(x)].mid[0] = (tag ^ 1) * t[ls(x)].len;
		t[rs(x)].lft[0] = t[rs(x)].rgt[0] = t[rs(x)].mid[0] = (tag ^ 1) * t[rs(x)].len;
		t[x].fg = -1;
	}
	if(t[x].qf == 1) {
		t[ls(x)].ld ^= 1; t[ls(x)].rd ^= 1;
		t[rs(x)].ld ^= 1; t[rs(x)].rd ^= 1;
		if(t[ls(x)].fg != -1) t[ls(x)].fg ^= 1;
		else t[ls(x)].qf ^= 1;
		if(t[rs(x)].fg != -1) t[rs(x)].fg ^= 1;
		else t[rs(x)].qf ^= 1;
		t[ls(x)].dis = t[ls(x)].len - t[ls(x)].dis;
		t[rs(x)].dis = t[rs(x)].len - t[rs(x)].dis;	
		swap(t[ls(x)].lft[1] , t[ls(x)].lft[0]);
		swap(t[ls(x)].rgt[1] , t[ls(x)].rgt[0]);
		swap(t[ls(x)].mid[1] , t[ls(x)].mid[0]);
		
		swap(t[rs(x)].lft[1] , t[rs(x)].lft[0]);
		swap(t[rs(x)].rgt[1] , t[rs(x)].rgt[0]);
		swap(t[rs(x)].mid[1] , t[rs(x)].mid[0]);
		t[x].qf =0 ;
	}
}

void updata_all_0(int x , int l , int r) {
	if(t[x].l >= l && t[x].r <= r) {
		t[x].ld = t[x].rd = 0;
		t[x].dis = 0;
		t[x].lft[1] = t[x].rgt[1] = t[x].mid[1] = 0;
		t[x].lft[0] = t[x].rgt[0] = t[x].mid[0] = t[x].len;
		t[x].qf = 0 ; t[x].fg = 0;
		return;
 	}
 	pushdown(x);
	int mid = (t[x].l + t[x].r )>> 1;
 	if(l <= mid) updata_all_0(ls(x) , l , r);
	if(r > mid ) updata_all_0(rs(x) , l, r);
	pushup(x);
}

void updata_all_1(int x , int l , int r) {
	if(t[x].l >= l && t[x].r <= r) {
		t[x].ld = t[x].rd = 1;
		t[x].dis = t[x].len;
		t[x].lft[1] = t[x].rgt[1] = t[x].mid[1] = t[x].len;
		t[x].lft[0] = t[x].rgt[0] = t[x].mid[0] = 0;
		t[x].qf = 0 ; t[x].fg = 1;
		return;
 	}
 	pushdown(x);
	int mid = (t[x].l + t[x].r) >> 1;
 	if(l <= mid) updata_all_1(ls(x) , l , r);
	if(r > mid ) updata_all_1(rs(x) , l, r);
	pushup(x);
}

void updata_all_rev(int x , int l , int r) {
	if(t[x].l >= l && t[x].r <= r) {
		t[x].ld ^= 1; t[x].rd ^= 1;
		t[x].dis = t[x].len - t[x].dis;
		swap(t[x].lft[1] , t[x].lft[0]);
		swap(t[x].rgt[1] , t[x].rgt[0]);
		swap(t[x].mid[1] , t[x].mid[0]);
		t[x].qf ^= 1;
		
		return;
 	}
 	pushdown(x);
	int mid = (t[x].l + t[x].r) >> 1;
 	if(l <= mid) updata_all_rev(ls(x) , l , r);
	if(r > mid ) updata_all_rev(rs(x) , l, r);
	pushup(x);
}

int query_all_1(int x , int l,  int r) {
	if(t[x].l >= l && t[x].r <= r) return t[x].dis;
	int ans = 0;
	pushdown(x);
	int mid = (t[x].l + t[x].r) >> 1;
	if(l <= mid) ans += query_all_1(ls(x) , l , r);
	if(r > mid ) ans += query_all_1(rs(x) , l , r);
	pushup(x);
	return ans; 
}

Seg query_cnt_1(int x , int l,  int r) {
	if(t[x].l >= l && t[x].r <= r) return t[x];
	Seg ans;
	pushdown(x);
	int mid = (t[x].l + t[x].r) >> 1;
	Seg lson , rson;
	if(l <= mid) lson = query_cnt_1(ls(x) , l , r);
	if(r > mid ) rson = query_cnt_1(rs(x) , l , r);
	ans.lft[1] = lson.lft[1];
	if(lson.lft[1] == lson.len) ans.lft[1] += rson.lft[1];
	ans.rgt[1] = rson.rgt[1];
	if(rson.rgt[1] == rson.len) ans.rgt[1] += lson.rgt[1];
	ans.mid[1] = max(lson.mid[1] , rson.mid[1]);
	ans.mid[1] = max(ans.mid[1] , lson.rgt[1] + rson.lft[1]);
	return ans; 
}

int main () {
//	freopen("data.txt" ,"r" , stdin);
//	freopen("ans2.out" ,"w" , stdout);
	scanf("%d %d" , &n , &m);
	for(int i = 1 ; i <= n ; ++ i) scanf("%d" , a + i);
	built(1 , 1 , n);
	while(m -- ) {		
		int opt , l , r; scanf("%d %d %d" , &opt,  &l , &r);
		l ++ , r ++;
		if(opt == 0) {
			updata_all_0(1 , l , r);
		} else if(opt == 1) {
			updata_all_1(1 , l , r);
		} else if(opt == 2) {
			updata_all_rev(1 , l , r);
		} else if(opt == 3) {
			printf("%d\n" , query_all_1(1 , l , r));
		} else if(opt == 4) {
			Seg ans = query_cnt_1(1 , l , r);
			printf("%d\n" , max(ans.mid[1] , max(ans.lft[1] , ans.rgt[1])));
		}
	}
	return 0;
} 

```



---

## 作者：Pelom (赞：1)

[更好的阅读体验](https://pelom.top/archives/52/)

# 题意

对于一个$01$序列，有$5$种操作：

$0 \ a \ b$ 把$[a,b]$区间内的所有数全变成$0$

$1 \ a \ b$ 把$[a,b]$区间内的所有数全变成$1$

$2 \ a \ b$ 把$[a,b]$区间内的所有数全部取反

$3 \ a \ b$ 询问$[a,b]$区间内总共有多少个$1$

$4 \ a \ b$ 询问$[a,b]$区间内最多有多少个连续的$1$

对于每个询问，输出答案

**数据范围：**$1 \le n,m \le 100000$

# 题解

明显的线段树题

需要维护哪些东西？区间$1$的总数，连续$1$的最大个数，覆盖标记，取反标记

为了在取反后获得连续$1$的最大个数，还需要维护连续$0$的最大个数

因为询问的是连续的$1$，在进行区间合并的时候，需要考虑以下情况

1. 左区间的值

2. 右区间的值

3. 左区间的右端点可以和右区间的左端点接上

这样，还需要额外维护一个区间从左/右端点开始的连续$1$个数

而合并这两个东西也有特殊的情况，以从左开始为例，

1. 左区间的值

2. 左区间满，合并后为左区间的值$+$右区间从左开始的连续$1$个数

而因为区间取反的存在，同样需要同时维护这样的连续$0$个数

```cpp
inline node operator + (const node& x){
    node res;
    res.c=c+x.c;
    res.l[0]=l[0];
    res.l[1]=l[1];
    if(s[0]==0)
        res.l[1]+=x.l[1];
    if(s[1]==0)
        res.l[0]+=x.l[0];
    res.r[0]=x.r[0];
    res.r[1]=x.r[1];
    if(x.s[0]==0)
        res.r[1]+=r[1];
    if(x.s[1]==0)
        res.r[0]+=r[0];
    res.s[0]=max(r[0]+x.l[0],max(s[0],x.s[0]));
    res.s[1]=max(r[1]+x.l[1],max(s[1],x.s[1]));
    return res;
}
```

下面是$pushdown$函数的写法

首先考虑两个标记的优先级问题：在区间覆盖后，区间取反会失效，所以优先处理区间覆盖；并在处理区间覆盖标记后，将区间取反标记置$0$

区间取反要交换维护的$0/1$的值，并将区间$1$个数更新为区间长度$-$区间$1$个数

```cpp
inline void pushDown(int rt,int len){
    if(T[rt].v!=-1){
        T[ls].s[0]=T[ls].l[0]=T[ls].r[0]=(T[rt].v^1)*(len-(len>>1));
        T[ls].c=T[ls].s[1]=T[ls].l[1]=T[ls].r[1]=T[rt].v*(len-(len>>1));
        T[rs].s[0]=T[rs].l[0]=T[rs].r[0]=(T[rt].v^1)*(len>>1);
        T[rs].c=T[rs].s[1]=T[rs].l[1]=T[rs].r[1]=T[rt].v*(len>>1);
        T[ls].v=T[rs].v=T[rt].v;
        T[ls].f=T[rs].f=0;
        T[rt].v=-1;
    }
    if(T[rt].f){
        T[ls].c=(len-(len>>1))-T[ls].c;
        T[rs].c=(len>>1)-T[rs].c;
        swap(T[ls].s[0],T[ls].s[1]);
        swap(T[ls].l[0],T[ls].l[1]);
        swap(T[ls].r[0],T[ls].r[1]);
        swap(T[rs].s[0],T[rs].s[1]);
        swap(T[rs].l[0],T[rs].l[1]);
        swap(T[rs].r[0],T[rs].r[1]);
        T[ls].f^=1;
        T[rs].f^=1;
        T[rt].f=0;
    }
}
```

至此，本题复杂的操作完成，剩余部分与一般线段树无异

**代码：**

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define ls rt<<1
#define rs rt<<1|1
const int N=100000+10;
int n,m,op,a,b;
bool p[N];
struct node{
    int c,s[2],l[2],r[2];
    int v;
    bool f;
    inline node():c(0),s{0,0},l{0,0},r{0,0},v(-1),f(0){}
    inline node operator + (const node& x){
        node res;
        res.c=c+x.c;
        res.l[0]=l[0];
        res.l[1]=l[1];
        if(s[0]==0)
            res.l[1]+=x.l[1];
        if(s[1]==0)
            res.l[0]+=x.l[0];
        res.r[0]=x.r[0];
        res.r[1]=x.r[1];
        if(x.s[0]==0)
            res.r[1]+=r[1];
        if(x.s[1]==0)
            res.r[0]+=r[0];
        res.s[0]=max(r[0]+x.l[0],max(s[0],x.s[0]));
        res.s[1]=max(r[1]+x.l[1],max(s[1],x.s[1]));
        return res;
    }
} T[N<<2];
inline void pushUp(int rt){
    T[rt]=T[ls]+T[rs];
}
inline void pushDown(int rt,int len){
    if(T[rt].v!=-1){
        T[ls].s[0]=T[ls].l[0]=T[ls].r[0]=(T[rt].v^1)*(len-(len>>1));
        T[ls].c=T[ls].s[1]=T[ls].l[1]=T[ls].r[1]=T[rt].v*(len-(len>>1));
        T[rs].s[0]=T[rs].l[0]=T[rs].r[0]=(T[rt].v^1)*(len>>1);
        T[rs].c=T[rs].s[1]=T[rs].l[1]=T[rs].r[1]=T[rt].v*(len>>1);
        T[ls].v=T[rs].v=T[rt].v;
        T[ls].f=T[rs].f=0;
        T[rt].v=-1;
    }
    if(T[rt].f){
        T[ls].c=(len-(len>>1))-T[ls].c;
        T[rs].c=(len>>1)-T[rs].c;
        swap(T[ls].s[0],T[ls].s[1]);
        swap(T[ls].l[0],T[ls].l[1]);
        swap(T[ls].r[0],T[ls].r[1]);
        swap(T[rs].s[0],T[rs].s[1]);
        swap(T[rs].l[0],T[rs].l[1]);
        swap(T[rs].r[0],T[rs].r[1]);
        T[ls].f^=1;
        T[rs].f^=1;
        T[rt].f=0;
    }
}
void build(int rt,int l,int r){
    if(l==r){
        T[rt].c=T[rt].s[1]=T[rt].l[1]=T[rt].r[1]=p[l];
        T[rt].s[0]=T[rt].l[0]=T[rt].r[0]=p[l]^1;
        return ;
    }
    int mid=l+r>>1;
    build(ls,l,mid);
    build(rs,mid+1,r);
    pushUp(rt);
}
void update(int rt,int l,int r,int L,int R,int k){
    if(l>=L && r<=R){
        if(k==-1){
            T[rt].f^=1;
            T[rt].c=(r-l+1)-T[rt].c;
            swap(T[rt].s[0],T[rt].s[1]);
            swap(T[rt].l[0],T[rt].l[1]);
            swap(T[rt].r[0],T[rt].r[1]);
        }
        else{
            T[rt].s[0]=T[rt].l[0]=T[rt].r[0]=(k^1)*(r-l+1);
            T[rt].c=T[rt].s[1]=T[rt].l[1]=T[rt].r[1]=k*(r-l+1);
            T[rt].v=k;
            T[rt].f=0;
        }
        return ;
    }
    pushDown(rt,r-l+1);
    int mid=l+r>>1;
    if(L<=mid)
        update(ls,l,mid,L,R,k);
    if(R>mid)
        update(rs,mid+1,r,L,R,k);
    pushUp(rt);
}
node query(int rt,int l,int r,int L,int R){
    if(l>=L && r<=R){
        return T[rt];
    }
    pushDown(rt,r-l+1);
    node res;
    int mid=l+r>>1;
    if(L<=mid)
        res=res+query(ls,l,mid,L,R);
    if(R>mid)
        res=res+query(rs,mid+1,r,L,R);
    pushUp(rt);
    return res;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&p[i]);
    build(1,1,n);
    for(;m--;){
        scanf("%d%d%d",&op,&a,&b);
        a++,b++;
        switch(op){
            case 0:update(1,1,n,a,b,0);break;
            case 1:update(1,1,n,a,b,1);break;
            case 2:update(1,1,n,a,b,-1);break;
            case 3:printf("%d\n",query(1,1,n,a,b).c);break;
            case 4:printf("%d\n",query(1,1,n,a,b).s[1]);break;
        }
    }
    return 0;
}
```

---

## 作者：Uniecho1 (赞：1)

这是一个毒瘤线段树......

前三个操作其实蛮好搞的（只要之前做过此类的瘤子题），脑补一个优先级出来（当然这里显然是平推比翻转优先，因为平推下去翻转就没了），然后根据优先级操作即可。

而后两个操作......第一个zz，第二个有点烦，主要是要注意由两个区间合并而来的那个1串必须得比查询长度短，否则只有10pts。

然后对于这个线段树，我反正是用堆写的，结构体又臭又长，蒟蒻表示看不懂。

......代码里有注释可以看一看。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100005;
int N,M,num[maxn];
int M_1[maxn<<2],LM_1[maxn<<2],RM_1[maxn<<2];
int M_0[maxn<<1],LM_0[maxn<<2],RM_0[maxn<<2];//0也要进行统计方便翻转 
int REV[maxn<<2],LAZY[maxn<<2],CNT[maxn<<2];
void pushdown(int l,int r,int id){
	int m=(l+r)>>1;
	if(LAZY[id]!=-1){//优先传平推不然洗白 
		LAZY[id<<1]=LAZY[id<<1|1]=LAZY[id];
		CNT[id<<1]=LAZY[id]*(m-l+1);CNT[id<<1|1]=LAZY[id]*(r-m);
		M_1[id<<1]=LM_1[id<<1]=RM_1[id<<1]=LAZY[id<<1]*(m-l+1);
		M_0[id<<1]=LM_0[id<<1]=RM_0[id<<1]=(LAZY[id<<1]^1)*(m-l+1);
		M_1[id<<1|1]=LM_1[id<<1|1]=RM_1[id<<1|1]=LAZY[id<<1|1]*(r-m);
		M_0[id<<1|1]=LM_0[id<<1|1]=RM_0[id<<1|1]=(LAZY[id<<1|1]^1)*(r-m);
		REV[id<<1]=REV[id<<1|1]=0;//覆盖翻转标记 
		LAZY[id]=-1;//往下传了就没了 
	}
	if(REV[id]){//然后传翻转（仅可能是在平推操作之后进行的，不然早被平推覆盖了） 
		REV[id<<1]^=1;REV[id<<1|1]^=1;
		CNT[id<<1]=m-l+1-CNT[id<<1];
		swap(M_1[id<<1],M_0[id<<1]);
		swap(LM_1[id<<1],LM_0[id<<1]);
		swap(RM_1[id<<1],RM_0[id<<1]);
		CNT[id<<1|1]=r-m-CNT[id<<1|1];
		swap(M_1[id<<1|1],M_0[id<<1|1]);
		swap(LM_1[id<<1|1],LM_0[id<<1|1]);
		swap(RM_1[id<<1|1],RM_0[id<<1|1]);
		REV[id]=0;
	}
}
void pushup(int l,int r,int id){//更新没啥好说的，我都不知道写那么多特判搞啥 
	int m=(l+r)>>1;
	CNT[id]=CNT[id<<1]+CNT[id<<1|1];
	M_1[id]=max(max(M_1[id<<1],M_1[id<<1|1]),RM_1[id<<1]+LM_1[id<<1|1]);
	M_0[id]=max(max(M_0[id<<1],M_0[id<<1|1]),RM_0[id<<1]+LM_0[id<<1|1]);
	LM_1[id]=LM_1[id<<1]+(LM_1[id<<1]==m-l+1)*LM_1[id<<1|1];
	LM_0[id]=LM_0[id<<1]+(LM_0[id<<1]==m-l+1)*LM_0[id<<1|1];
	RM_1[id]=RM_1[id<<1|1]+(RM_1[id<<1|1]==r-m)*RM_1[id<<1];
	RM_0[id]=RM_0[id<<1|1]+(RM_0[id<<1|1]==r-m)*RM_0[id<<1];
}
void build(int l,int r,int id){//基操建树 
	if(l==r){
		M_1[id]=LM_1[id]=RM_1[id]=(num[l]==1);
		M_0[id]=LM_0[id]=RM_0[id]=(num[l]==0);
		CNT[id]=num[l];return;
	}
	int m=(l+r)>>1;
	build(l,m,id<<1);
	build(m+1,r,id<<1|1);
	pushup(l,r,id);
}
void change(int x,int y,int l,int r,int id,int k){//基操修改 
	if(x<=l&&r<=y){
		LM_1[id]=RM_1[id]=M_1[id]=k*(r-l+1);
		LM_0[id]=RM_0[id]=M_0[id]=(k^1)*(r-l+1);
		CNT[id]=k*(r-l+1);LAZY[id]=k;REV[id]=0;return;//注意rev被覆盖了！ 
	}
	pushdown(l,r,id);
	int m=(l+r)>>1;
	if(x<=m)change(x,y,l,m,id<<1,k);
	if(y>m)change(x,y,m+1,r,id<<1|1,k);
	pushup(l,r,id);
}
void reverse(int x,int y,int l,int r,int id){//基操翻转 
	if(x<=l&&r<=y){
		REV[id]^=1;
		CNT[id]=r-l+1-CNT[id];
		swap(M_1[id],M_0[id]);
		swap(LM_1[id],LM_0[id]);
		swap(RM_1[id],RM_0[id]);
		return;
	}
	pushdown(l,r,id);
	int m=(l+r)>>1;
	if(x<=m)reverse(x,y,l,m,id<<1);
	if(y>m)reverse(x,y,m+1,r,id<<1|1);
	pushup(l,r,id);
}
int getcnt(int x,int y,int l,int r,int id){//基操求和 
	if(x<=l&&r<=y)return CNT[id];
	pushdown(l,r,id);
	int ans=0,m=(l+r)>>1;
	if(x<=m)ans+=getcnt(x,y,l,m,id<<1);
	if(y>m)ans+=getcnt(x,y,m+1,r,id<<1|1);
	return ans;
}
int getmax(int x,int y,int l,int r,int id){//注意这个 
	if(x<=l&&r<=y)return M_1[id];
	int m=(l+r)>>1;
	pushdown(l,r,id);
	if(x<=m&&y>m){
		int ans=max(getmax(x,y,l,m,id<<1),getmax(x,y,m+1,r,id<<1|1)),rm,lm;
		rm=min(RM_1[id<<1],m-x+1);//跨过了中点就还要讨论两区间合并 
		lm=min(LM_1[id<<1|1],y-m);//不要爆区间了不然10pts 
		ans=max(ans,lm+rm);
		return ans;
	}else if(x<=m){
		return getmax(x,y,l,m,id<<1);
	}else if(y>m)return getmax(x,y,m+1,r,id<<1|1);
}
int main(){
	//freopen("in.txt","r",stdin);
	memset(LAZY,-1,sizeof(LAZY));
	scanf("%d%d",&N,&M);
	for(int i=1;i<=N;i++)scanf("%d",&num[i]);
	build(1,N,1);
	for(int i=1,opt,l,r;i<=M;i++){
		scanf("%d%d%d",&opt,&l,&r);l++,r++;
		if(opt==0){
			change(l,r,1,N,1,0);
		}else if(opt==1){
			change(l,r,1,N,1,1);
		}else if(opt==2){
			reverse(l,r,1,N,1);
		}else if(opt==3){
			printf("%d\n",getcnt(l,r,1,N,1));
		}else if(opt==4){
			printf("%d\n",getmax(l,r,1,N,1));
		}
	}
	return 0;
}
```
好像我代码还是长了......学ODT去了......

---

## 作者：L_M_ (赞：1)

爆调一晚终于调出来了，不容易啊2333

前面的题解讲的都差不多了，我这里提供我的一些理解：

1.最后一个点数据是2e5，洛谷数据锅了2333

2.关于标记：

类比线段树2，显然赋值标记比翻转优先，因此给区间打上赋值标记时，应该将翻转标记清空
    
当一个区间有赋值标记，而又要被打上翻转标记时，这是应该直接将赋值标记^1,而不用处理翻转标记。这样就防止标记的前后覆盖和冲突

3.最后一个询问不应该直接返回值，而应该返回一个节点。因为当处理ql - mid和mid + 1-qr时，最终的答案应该考虑这两段区间的其他值（原理同pushdown）

上代码，没有压行，写的很直白：
```
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<climits>
#include<vector>
#include<cstdlib>
#include<ctime>
#include<queue> 
using namespace std;
inline int read()
{
	int ans = 0,op = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9')
	{
		if(ch == '-') op = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9')
	{
		(ans *= 10) += ch - '0';
		ch = getchar();
	}
	return ans * op;
}
const int maxn = 2e5 + 10;
struct node
{
	int sum,m1,m0,ml1,mr1,ml0,mr0;
	int lazy;//0,1
	int inv;
}a[maxn << 2];
inline void pushdown(int i,int l,int r)
{
	int mid = (l + r) >> 1;
	int lenl = mid - l + 1,lenr = r - mid;
	if(a[i].lazy == 0)
	{
		a[i << 1] = (node){0,0,lenl,0,0,lenl,lenl,0,0};
		a[i << 1 | 1] = (node){0,0,lenr,0,0,lenr,lenr,0,0};
		a[i].inv = 0;
	}
	if(a[i].lazy == 1)
	{
		a[i << 1] = (node){lenl,lenl,0,lenl,lenl,0,0,1,0};
		a[i << 1 | 1] = (node){lenr,lenr,0,lenr,lenr,0,0,1,0};
		a[i].inv = 0;
	}
	a[i].lazy = -1;
	if(a[i].inv == 1)
	{
		if(a[i << 1].lazy != -1) a[i << 1].lazy ^= 1;
		else a[i << 1].inv ^= 1;
		a[i << 1].sum = lenl - a[i << 1].sum;
		swap(a[i << 1].m1,a[i << 1].m0);
		swap(a[i << 1].ml1,a[i << 1].ml0);
		swap(a[i << 1].mr1,a[i << 1].mr0);
		
		if(a[i << 1 | 1].lazy != -1) a[i << 1 | 1].lazy ^= 1;
		else a[i << 1 | 1].inv ^= 1;
		a[i << 1 | 1].sum = lenr - a[i << 1 | 1].sum;
		swap(a[i << 1 | 1].m1,a[i << 1 | 1].m0);
		swap(a[i << 1 | 1].ml1,a[i << 1 | 1].ml0);
		swap(a[i << 1 | 1].mr1,a[i << 1 | 1].mr0);
		
		a[i].inv = 0;
	}
}
inline void pushup(int i,int l,int r)
{
	a[i].sum = a[i << 1].sum + a[i << 1 | 1].sum;
	
	int mid = (l + r) >> 1;
	
	if(a[i << 1].ml1 == mid - l + 1) a[i].ml1 = a[i << 1].ml1 + a[i << 1 | 1].ml1;
	else a[i].ml1 = a[i << 1].ml1;
	
	if(a[i << 1].ml0 == mid - l + 1) a[i].ml0 = a[i << 1].ml0 + a[i << 1 | 1].ml0;
	else a[i].ml0 = a[i << 1].ml0;
	
	if(a[i << 1 | 1].mr1 == r - mid) a[i].mr1 = a[i << 1 | 1].mr1 + a[i << 1].mr1;
	else a[i].mr1 = a[i << 1 | 1].mr1;
	
	if(a[i << 1 | 1].mr0 == r - mid) a[i].mr0 = a[i << 1 | 1].mr0 + a[i << 1].mr0;
	else a[i].mr0 = a[i << 1 | 1].mr0;
	
	a[i].m1 = max(max(a[i << 1].m1,a[i << 1 | 1].m1),a[i << 1].mr1 + a[i << 1 | 1].ml1);
	a[i].m0 = max(max(a[i << 1].m0,a[i << 1 | 1].m0),a[i << 1].mr0 + a[i << 1 | 1].ml0);
}
void build(int i,int l,int r)
{
	a[i].lazy = -1;
	a[i].inv = 0;
	if(l == r)
	{
		int op = read();
		a[i] = (node){op,op,op ^ 1,op,op,op ^ 1,op ^ 1,-1,0};
		return;
	}
	int mid = (l + r) >> 1;
	build(i << 1,l,mid);
	build(i << 1 | 1,mid + 1,r);
	pushup(i,l,r);
}
void op0(int i,int l,int r,int ql,int qr)
{
	pushdown(i,l,r);	
	int len = r - l + 1;
	if(l == ql && r == qr)
	{
		a[i] = (node){0,0,len,0,0,len,len,0,0};
		return;
	}
	int mid = l + r >> 1;
	if(qr <= mid) op0(i << 1,l,mid,ql,qr);
	else if(ql > mid) op0(i << 1 | 1,mid + 1,r,ql,qr);
	else
	{
		op0(i << 1,l,mid,ql,mid);
		op0(i << 1 | 1,mid + 1,r,mid + 1,qr);
	}
	pushup(i,l,r);
}
void op1(int i,int l,int r,int ql,int qr)
{
	pushdown(i,l,r);
	int len = r - l + 1;
	if(l == ql && r == qr)
	{
		a[i] = (node){len,len,0,len,len,0,0,1,0};
		return;
	}
	int mid = l + r >> 1;
	if(qr <= mid) op1(i << 1,l,mid,ql,qr);
	else if(ql > mid) op1(i << 1 | 1,mid + 1,r,ql,qr);
	else
	{
		op1(i << 1,l,mid,ql,mid);
		op1(i << 1 | 1,mid + 1,r,mid + 1,qr);
	}	
	pushup(i,l,r);
}
void op2(int i,int l,int r,int ql,int qr)//取反 
{
	pushdown(i,l,r);
	int len = r - l + 1;
	if(l == ql && r == qr)
	{
		if(a[i].lazy != -1) a[i].lazy ^= 1;
		else a[i].inv ^= 1; 
		swap(a[i].m1,a[i].m0);
		swap(a[i].ml1,a[i].ml0);
		swap(a[i].mr1,a[i].mr0);
		a[i].sum = len - a[i].sum;
		return;
	}
	int mid = l + r >> 1;
	if(qr <= mid) op2(i << 1,l,mid,ql,qr);
	else if(ql > mid) op2(i << 1 | 1,mid + 1,r,ql,qr);
	else
	{
		op2(i << 1,l,mid,ql,mid);
		op2(i << 1 | 1,mid + 1,r,mid + 1,qr);
	}	
	pushup(i,l,r);	
}
int query1(int i,int l,int r,int ql,int qr)
{ 
	pushdown(i,l,r);
	if(l == ql && r == qr) return a[i].sum;
	int mid = l + r >> 1;
	if(qr <= mid) return query1(i << 1,l,mid,ql,qr);
	else if(ql > mid) return query1(i << 1 | 1,mid + 1,r,ql,qr);
	else return query1(i << 1,l,mid,ql,mid) + query1(i << 1 | 1,mid + 1,r,mid + 1,qr);
}
node qmax(int i,int l,int r,int ql,int qr)
{
	pushdown(i,l,r);
	if(l == ql && r == qr) return a[i];
	int mid = l + r >> 1;
	if(qr <= mid) return qmax(i << 1,l,mid,ql,qr);
	else if(ql > mid) return qmax(i << 1 | 1,mid + 1,r,ql,qr);
	//else 
	//return qmax(i << 1 | 1,mid + 1,r,mid + 1,qr);
	else
	{
		node ans;
		node lef = qmax(i << 1,l,mid,ql,mid);
		node rig = qmax(i << 1 | 1,mid + 1,r,mid + 1,qr);
		//printf("%d\n",lef.m1);
		ans.sum = lef.sum + rig.sum;
		ans.ml0 = lef.ml0,ans.ml1 = lef.ml1;
		ans.mr0 = rig.mr0,ans.mr1 = rig.mr1;
		if(lef.ml0 == mid - ql + 1) ans.ml0 += rig.ml0;
		if(lef.ml1 == mid - ql + 1) ans.ml1 += rig.ml1;
		if(rig.mr0 == qr - mid) ans.mr0 += lef.mr0; 
		if(rig.mr1 == qr - mid) ans.mr1 += lef.mr1;
		ans.m1 = max(max(lef.m1,rig.m1),lef.mr1 + rig.ml1);
		ans.m0 = max(max(lef.m0,rig.m0),lef.mr0 + rig.ml0);
		return ans;
	}
}
int main()
{
	int n = read(),m = read();
	build(1,1,n);
	for(int i = 1;i <= m;i++)
	{
		int op = read(),l = read(),r = read();
		l++,r++; 
		if(op == 0) op0(1,1,n,l,r);
		if(op == 1) op1(1,1,n,l,r);
		if(op == 2) op2(1,1,n,l,r);
		if(op == 3) printf("%d\n",query1(1,1,n,l,r));
		if(op == 4)
		{
			node ans = qmax(1,1,n,l,r);
			printf("%d\n",ans.m1);
		}
	}
}
```

---

## 作者：Jμdge (赞：1)

各种繁琐的线段树标记操作。。。赤裸裸的码农题。

调了一个晚上，最后写篇题解。

题解亮点：代码短，~~跑得慢（连第一页都没挤进去）~~


其实我跟你们说啊，代码短是好事~~（这里不是说压行好，我的代码不压行也没那么长）~~，因为代码短好调啊，几个类似的语句写个函数，既满足了懒人需要（减少码量），而且也让代码思路清晰，没有那么杂乱了。


------------------------------------------------------------------

the code:
------------------------------------------------------------------------------------------------------------------------------------

```
//by Judge
#include<cstdio>
#include<iostream>
using namespace std;
const int M=2e5+5;
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(int x,char chr='\n'){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]=chr;
} inline void cmax(int& a,int b){ if(a<b) a=b; }
struct node{ int l,r,len,tag,rev;
	int sum,max[2],lmax[2],rmax[2];
}t[M<<2],zero; int n,m,v[M];
#define ls k<<1
#define rs k<<1|1
inline node merge(node a,node b){ //懒人合并
	static node c;
	c.sum=a.sum+b.sum;
	for(int i=0;i<=1;++i){
		c.lmax[i]=a.lmax[i];
		if(a.lmax[i]==a.len)
			c.lmax[i]+=b.lmax[i];
		c.rmax[i]=b.rmax[i];
		if(b.rmax[i]==b.len)
			c.rmax[i]+=a.rmax[i];
		c.max[i]=a.rmax[i]+b.lmax[i];
		cmax(c.max[i],a.max[i]);
		cmax(c.max[i],b.max[i]);
	} return c;
} inline void pushup(int k){ //懒人pushup
	t[0]=merge(t[ls],t[rs]);
	t[k].sum=t[0].sum;
	for(int i=0;i<=1;++i){
		t[k].max[i]=t[0].max[i];
		t[k].lmax[i]=t[0].lmax[i];
		t[k].rmax[i]=t[0].rmax[i];
	}
} inline void chg(int k,int v){ //懒人change
	if(v<2){
		t[k].sum=t[k].len*v,t[k].tag=v,t[k].rev=0;
		t[k].max[v]=t[k].lmax[v]=t[k].rmax[v]=t[k].len;
		t[k].max[v^1]=t[k].lmax[v^1]=t[k].rmax[v^1]=0;
	} else if(v==2){
		t[k].sum=t[k].len-t[k].sum;
		if(t[k].tag!=-1) t[k].tag^=1;
		else t[k].rev^=1;
		swap(t[k].max[0],t[k].max[1]);
		swap(t[k].lmax[0],t[k].lmax[1]);
		swap(t[k].rmax[0],t[k].rmax[1]);
	}
} inline void pushdown(int k){ //pushdown可以非常短
	if(t[k].tag!=-1)
		t[k].rev=0,chg(ls,t[k].tag),
		chg(rs,t[k].tag),t[k].tag=-1;
	else if(t[k].rev)
		chg(ls,2),chg(rs,2),t[k].rev=0;
} void build(int k,int l,int r){ /*     然后都是线段树常规操作   */
	t[k].l=l,t[k].r=r,t[k].len=r-l+1,t[k].tag=-1;
	if(l==r){ int c=v[l]; t[k].sum=c;
		t[k].max[c]=t[k].lmax[c]=t[k].rmax[c]=1; return ;
	} int mid=l+r>>1; build(ls,l,mid),build(rs,mid+1,r),pushup(k);
} void update(int k,int L,int R,int opt){
	if(L<=t[k].l&&t[k].r<=R) return chg(k,opt);
	int mid=t[k].l+t[k].r>>1; pushdown(k);
	if(L<=mid) update(ls,L,R,opt);
	if(R>mid) update(rs,L,R,opt); pushup(k);
} int query(int k,int L,int R){
	if(L>t[k].r||t[k].l>R) return 0;
	if(L<=t[k].l&&t[k].r<=R) return t[k].sum;
	pushdown(k); int mid=t[k].l+t[k].r>>1;
	return query(ls,L,R)+query(rs,L,R);
} node query_mx(int k,int L,int R){
	if(L>t[k].r||t[k].l>R) return zero; //zero作用和他的名字一样，merge的时候就不算贡献了
	if(L<=t[k].l&&t[k].r<=R) return t[k]; pushdown(k);
	return merge(query_mx(ls,L,R),query_mx(rs,L,R));
} int main(){ n=read(),m=read();
	for(int i=1;i<=n;++i) v[i]=read();
	build(1,1,n);
	for(int opt,l,r;m;--m){ //处理各种操作
		opt=read(),l=read()+1,r=read()+1;
		if(opt<3) update(1,l,r,opt);
		else if(opt==3) print(query(1,l,r));
		else if(opt==4) print(query_mx(1,l,r).max[1]);
	} return Ot(),0;
}
```


不压行也就一百一二十行吧。


---

## 作者：SNiFe (赞：1)

##这道题太坑了，我做了加起来一天才AC，找错找过来找过去，发现是pushup()错了（泪奔，最开始我信誓旦旦的说pushup()没错，结果就pushup()最多）

这道题难度中规中矩，就是细节处理非常多，错一点就要找很久。

#怎么做？

首先看题，有2种修改（3个），2个询问，最开始我开了两个lazy标记，但其实不用，那样反而更麻烦。开一个lazy标记就够了。

每次修改，就分类讨论:当opt==0||opt==1时直接修改，下传标记；当opt==2时，就要分成3大类，当前区间sign=-1，sign=2，sign=1||sign=0，这里较麻烦，可直接看我代码；
downdate()和上面差不多；

然后一定要注意pushup()，这个函数其实很短，但很重要，处理一定要恰当。

#查询连续的1怎么办？

这个做法比较巧妙，可以用一个pre，记录左区间的maxr，向上更新，然后查找右区间的maxl，然后与maxx比较（因为查询的区间可能不能被一个线段树中的区间包含完，所以有可能被分为两段查询）。

上代码（大家不懂的地方，看了代码应该就懂了，代码很容易懂，耐心阅读^\_^):

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ls id<<1
#define rs id<<1|1
using namespace std;
const int N=100000+10;
int n,m,a[N],ans=0,pre;
struct node
{
    int left,right,sign,sum,maxx,maxl,maxr,maxl0,maxr0,maxx0;
}tree[N*4];
void pushup(int id)//可恶的函数
{
    tree[id].sum=tree[ls].sum+tree[rs].sum;
    tree[id].maxl=tree[ls].maxl;tree[id].maxl0=tree[ls].maxl0;
    if(tree[id].maxl==tree[ls].right-tree[ls].left+1)tree[id].maxl+=tree[rs].maxl;
    if(tree[id].maxl0==tree[ls].right-tree[ls].left+1)tree[id].maxl0+=tree[rs].maxl0;
    tree[id].maxr=tree[rs].maxr;tree[id].maxr0=tree[rs].maxr0;
    if(tree[id].maxr==tree[rs].right-tree[rs].left+1)tree[id].maxr+=tree[ls].maxr;
    if(tree[id].maxr0==tree[rs].right-tree[rs].left+1)tree[id].maxr0+=tree[ls].maxr0;
    tree[id].maxx=max(tree[ls].maxx,max(tree[rs].maxx,tree[ls].maxr+tree[rs].maxl));
    tree[id].maxx0=max(tree[ls].maxx0,max(tree[rs].maxx0,tree[ls].maxr0+tree[rs].maxl0));
}
void built(int id,int l,int r)
{
    tree[id].left=l,tree[id].right=r,tree[id].sign=-1;
    if(l==r)
    {
        tree[id].maxl=tree[id].maxr=tree[id].maxx=tree[id].sum=a[l];
        tree[id].maxl0=tree[id].maxr0=tree[id].maxx0=(a[l]^1);
        return;
    }
    int mid=(l+r)>>1;
    built(ls,l,mid),built(rs,mid+1,r);pushup(id);
}
void change(int id)
{
    swap(tree[id].maxl,tree[id].maxl0);swap(tree[id].maxr,tree[id].maxr0);swap(tree[id].maxx,tree[id].maxx0);
    tree[id].sum=tree[id].right-tree[id].left+1-tree[id].sum;
}
void downdate(int id)
{
    if(tree[id].sign<=1&&tree[id].sign>=0)
    {
        int tmp;
        tmp=(tree[ls].right-tree[ls].left+1);
        tree[ls].sign=tree[id].sign;
        tree[ls].maxl=tree[ls].maxr=tree[ls].maxx=tree[ls].sum=tmp*tree[id].sign;
        tree[ls].maxl0=tree[ls].maxr0=tree[ls].maxx0=tmp*(tree[id].sign^1);
        tmp=(tree[rs].right-tree[rs].left+1);
        tree[rs].sign=tree[id].sign;
        tree[rs].maxl=tree[rs].maxr=tree[rs].maxx=tree[rs].sum=tmp*tree[id].sign;
        tree[rs].maxl0=tree[rs].maxr0=tree[rs].maxx0=tmp*(tree[id].sign^1);
    }
    else if(tree[id].sign==2)
    {
        if(tree[ls].sign<=1&&tree[ls].sign>=0)
        {
            int tmp=(tree[ls].right-tree[ls].left+1);
            tree[ls].maxl=tree[ls].maxr=tree[ls].maxx=tree[ls].sum=tmp*(tree[ls].sign^1);
            tree[ls].maxl0=tree[ls].maxr0=tree[ls].maxx0=tmp*tree[ls].sign;
            tree[ls].sign^=1;
        }
        else if(tree[ls].sign==-1)
        {
            change(ls);tree[ls].sign=2;
        }
        else if(tree[ls].sign==2)
        {
            change(ls);tree[ls].sign=-1;
        }
        if(tree[rs].sign<=1&&tree[rs].sign>=0)
        {
            int tmp=(tree[rs].right-tree[rs].left+1);
            tree[rs].maxl=tree[rs].maxr=tree[rs].maxx=tree[rs].sum=tmp*(tree[rs].sign^1);
            tree[rs].maxl0=tree[rs].maxr0=tree[rs].maxx0=tmp*tree[rs].sign;
            tree[rs].sign^=1;
        }
        else if(tree[rs].sign==-1)
        {
            change(rs);tree[rs].sign=2;
        }
        else if(tree[rs].sign==2)
        {
            change(rs);tree[rs].sign=-1;
        }
    }tree[id].sign=-1;
}
void update(int id,int l,int r,int opt)
{
    if(tree[id].left>r||tree[id].right<l)return;
    if(tree[id].left>=l&&tree[id].right<=r)
    {
        if(opt==0||opt==1)
        {
            int tmp=(tree[id].right-tree[id].left+1);tree[id].sign=opt;
            tree[id].maxl=tree[id].maxr=tree[id].maxx=tree[id].sum=tmp*tree[id].sign;
            tree[id].maxl0=tree[id].maxr0=tree[id].maxx0=tmp*(tree[id].sign^1);
        }
        else if(opt==2)
        {
            if(tree[id].sign==2)
            {
                change(id);tree[id].sign=-1;
            }
            else if(tree[id].sign<=1&&tree[id].sign>=0)
            {
                int tmp=(tree[id].right-tree[id].left+1);tree[id].sign^=1;
                tree[id].maxl=tree[id].maxr=tree[id].maxx=tree[id].sum=tmp*tree[id].sign;
                tree[id].maxl0=tree[id].maxr0=tree[id].maxx0=tmp*(tree[id].sign^1);
            }
            else if(tree[id].sign==-1)
            {
                change(id);tree[id].sign=2;
            }
        }
        return;
    }
    if(tree[id].sign>=0)downdate(id);
    update(ls,l,r,opt);update(rs,l,r,opt);pushup(id);
}
int querysum(int id,int l,int r)
{
    if(tree[id].left>r||tree[id].right<l)return 0;
    if(tree[id].left>=l&&tree[id].right<=r)return tree[id].sum;
    if(tree[id].sign>=0)downdate(id);
    int tmp=querysum(ls,l,r)+querysum(rs,l,r);
    return tmp;
}
void querymaxx(int id,int l,int r)
{
    if(tree[id].left>r||tree[id].right<l)return;
    if(tree[id].left>=l&&tree[id].right<=r)
    {
        ans=max(ans,max(tree[id].maxx,pre+tree[id].maxl));
        if(tree[id].sum==tree[id].right-tree[id].left+1) pre+=tree[id].sum;
        else pre=tree[id].maxr;//巧妙地pre
        return;
    }
    if(tree[id].sign>=0)downdate(id);
    querymaxx(ls,l,r);querymaxx(rs,l,r);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    built(1,1,n);
    for(int i=1;i<=m;i++)
    {
        int x,y,opt;
        scanf("%d%d%d",&opt,&x,&y);x++,y++;
        if(opt<=2)update(1,x,y,opt);
        if(opt==3)printf("%d\n",querysum(1,x,y));
        if(opt==4)ans=0,pre=0,querymaxx(1,x,y),printf("%d\n",ans);
    }
}
```

---

## 作者：zhouenji (赞：1)

这是一道很难很难的线段树题目，我和同学一起写了两个晚上才写出来

首先我们考虑0，1，3三种操作，只需要维护一个区间sum，sign即可

查询区间连续的1点个数时，就可维护一个suml/sumr表示当前区间从左/右起有多少连续的1，一个maxx表示当前区间最大的连续个数

对于区间取反操作，就可以维护一个与1所对应的的0的相关情况即可

于是我们就需要维护：sum，sign，suml0，sumr0，maxx0，suml1，sumr1，maxx1    8个值

是不是想想都觉得复杂？         没事，写起来更复杂

之前写的时候感觉最难的地方就是下传标记，

其实可以这样考虑：

下传标记时，如果当前标记是0,1；那么可以直接覆盖

如果是2，就看儿子节点的标记，没有就继承，如果儿子是2，就可以抵消，将儿子标记为-1

如果儿子是0或者1，那么就可以直接将0变1,1变0；（想想是不是这个道理）

大概就是这样子，恩，sign初值为-1！！

其他的就自己摸索吧

见代码：


```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int maxn=100000+10;
struct nod{
    int left,right,sum,sign;
    int suml1,sumr1,maxx1;
    int suml0,sumr0,maxx0;
}t[maxn*4];
int s[maxn];
int n,m,ans;
void up(int g){
    t[g].sum=t[g<<1].sum+t[g<<1|1].sum;
    t[g].suml0=t[g<<1  ].suml0;if(t[g].suml0==(t[g<<1  ].right-t[g<<1].left+1))t[g].suml0+=t[g<<1|1].suml0;
    t[g].suml1=t[g<<1  ].suml1;if(t[g].suml1==(t[g<<1  ].right-t[g<<1].left+1))t[g].suml1+=t[g<<1|1].suml1;
    t[g].sumr0=t[g<<1|1].sumr0;if(t[g].sumr0==(t[g<<1|1].right-t[g<<1|1].left+1))t[g].sumr0+=t[g<<1].sumr0;
    t[g].sumr1=t[g<<1|1].sumr1;if(t[g].sumr1==(t[g<<1|1].right-t[g<<1|1].left+1))t[g].sumr1+=t[g<<1].sumr1;
    t[g].maxx0=max(t[g<<1].maxx0,t[g<<1|1].maxx0);t[g].maxx0=max(t[g].maxx0,t[g<<1].sumr0+t[g<<1|1].suml0);
    t[g].maxx1=max(t[g<<1].maxx1,t[g<<1|1].maxx1);t[g].maxx1=max(t[g].maxx1,t[g<<1].sumr1+t[g<<1|1].suml1);
}
void build(int g,int l,int r){
    t[g].left=l;t[g].right=r;t[g].sign=-1;
    if(l==r){
        t[g].sum=s[l];
        if(s[l]==1)t[g].suml1=t[g].sumr1=t[g].maxx1=1;
        if(s[l]==0)t[g].suml0=t[g].sumr0=t[g].maxx0=1;
        return;
    }int mid=l+r>>1;
    build(g<<1,l,mid);build(g<<1|1,mid+1,r);
    up(g);
}
void down(int g){
    if(t[g].sign==2){
        if(t[g<<1].sign==2)t[g<<1].sign=-1;
        else if(t[g<<1].sign!=-1)t[g<<1].sign^=1;
        else t[g<<1].sign=t[g].sign;
        if(t[g<<1|1].sign==2)t[g<<1|1].sign=-1;
        else if(t[g<<1|1].sign!=-1)t[g<<1|1].sign^=1;
        else t[g<<1|1].sign=t[g].sign;
    }else t[g<<1].sign=t[g].sign,t[g<<1|1].sign=t[g].sign;
    if(t[g<<1].sign==0){
        t[g<<1].sum=0;
        t[g<<1].suml1=t[g<<1].sumr1=t[g<<1].maxx1=0;
        t[g<<1].suml0=t[g<<1].sumr0=t[g<<1].maxx0=(t[g<<1].right-t[g<<1].left+1);
    }    
    if(t[g<<1|1].sign==0){
        t[g<<1|1].sum=0;
        t[g<<1|1].suml1=t[g<<1|1].sumr1=t[g<<1|1].maxx1=0;
        t[g<<1|1].suml0=t[g<<1|1].sumr0=t[g<<1|1].maxx0=(t[g<<1|1].right-t[g<<1|1].left+1);
    }
    if(t[g<<1].sign==1){
        t[g<<1].sum=(t[g<<1].right-t[g<<1].left+1);
        t[g<<1].suml0=t[g<<1].sumr0=t[g<<1].maxx0=0;
        t[g<<1].suml1=t[g<<1].sumr1=t[g<<1].maxx1=(t[g<<1].right-t[g<<1].left+1);
    }
    if(t[g<<1|1].sign==1){
        t[g<<1|1].sum=(t[g<<1|1].right-t[g<<1|1].left+1);
        t[g<<1|1].suml0=t[g<<1|1].sumr0=t[g<<1|1].maxx0=0;
        t[g<<1|1].suml1=t[g<<1|1].sumr1=t[g<<1|1].maxx1=(t[g<<1|1].right-t[g<<1|1].left+1);
    }
    if(t[g<<1].sign==2 || t[g<<1].sign==-1){
        t[g<<1].sum=(t[g<<1].right-t[g<<1].left+1-t[g<<1].sum);
        swap(t[g<<1].suml0,t[g<<1].suml1);
        swap(t[g<<1].sumr0,t[g<<1].sumr1);
        swap(t[g<<1].maxx0,t[g<<1].maxx1);
    }    
    if(t[g<<1|1].sign==2 || t[g<<1|1].sign==-1){
        t[g<<1|1].sum=(t[g<<1|1].right-t[g<<1|1].left+1-t[g<<1|1].sum);
        swap(t[g<<1|1].suml0,t[g<<1|1].suml1);
        swap(t[g<<1|1].sumr0,t[g<<1|1].sumr1);
        swap(t[g<<1|1].maxx0,t[g<<1|1].maxx1);
    }t[g].sign=-1;
}
void change(int g,int l,int r,int opt){
    if(r<t[g].left || t[g].right<l)return;
    if(l<=t[g].left&&t[g].right<=r){
        if(t[g].sign==-1)t[g].sign=opt;
        else if(opt==2 && t[g].sign==2)t[g].sign=-1;
        else if(opt==2 && t[g].sign!=2)t[g].sign^=1;
        else if(opt!=2)t[g].sign=opt;
        if(opt==0){
            t[g].sum=0;
            t[g].suml1=t[g].sumr1=t[g].maxx1=0;
            t[g].suml0=t[g].sumr0=t[g].maxx0=(t[g].right-t[g].left+1);
        }
        if(opt==1){
            t[g].sum=(t[g].right-t[g].left+1);
            t[g].suml0=t[g].sumr0=t[g].maxx0=0;
            t[g].suml1=t[g].sumr1=t[g].maxx1=(t[g].right-t[g].left+1);
        }
        if(opt==2){
            t[g].sum=(t[g].right-t[g].left+1-t[g].sum);
            swap(t[g].suml1,t[g].suml0);
            swap(t[g].sumr1,t[g].sumr0);
            swap(t[g].maxx1,t[g].maxx0);
        }return;
    }
    if(t[g].sign!=-1)down(g);
    change(g<<1,l,r,opt);change(g<<1|1,l,r,opt);
    up(g);
}
int get1(int g,int l,int r){
    if(r<t[g].left || t[g].right<l)return 0;
    if(l<=t[g].left&&t[g].right<=r)return t[g].sum;
    if(t[g].sign!=-1)down(g);
    return get1(g<<1,l,r)+get1(g<<1|1,l,r);
}
void get2(int g,int l,int r){
    if(r<t[g].left || t[g].right<l)return;
    if(l<=t[g].left&&t[g].right<=r){
        ans=max(ans,t[g].maxx1);return;
    }
    if(t[g].sign!=-1)down(g);
    get2(g<<1,l,r);get2(g<<1|1,l,r);
    ans=max(ans,min(t[g<<1].sumr1,t[g<<1].right-l+1)+min(t[g<<1|1].suml1,r-t[g<<1|1].left+1));
}
int main()
{
//    freopen("a.in","r",stdin);
//    freopen("my.out","w",stdout);
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++){
        scanf("%d",&s[i]);
    }build(1,0,n-1);
    for(int i=1;i<=m;i++){
        int l,r,opt;
        scanf("%d%d%d",&opt,&l,&r);
        if(opt<=2){
            change(1,l,r,opt);
        }
        else if(opt==3)printf("%d\n",get1(1,l,r));
        else if(opt==4){
            ans=0;get2(1,l,r);printf("%d\n",ans);
        }
    }
}

```

---

## 作者：斗神_君莫笑 (赞：1)

这是一道好题  

当我们把本来简单的几种操作合并在一起时，需要考虑的就麻烦了很多  
但是本题终究只是一个线段树的基础应用，考察的只有码力   
AC本题，你需要前置知识点之   
——[区间连续1个数](https://www.luogu.org/problem/P2894)  
——区间翻转（自己想想怎么实现）  

当区间翻转过后，我们维护的有关区间连续1个数的信息便全部失效了  
有没有什么方便的办法解决这一点呢？  
看那1e5的数据规模和蔼可亲，多个常数也不会T  
那就再维护区间连续0的个数吧！  
我们通过这种~~暴力~~的方式方便的实现了区间翻转与连续1之间的冲突  
接下来就是代码时间了  
顺便注意处理好翻转与全部赋值之间的标记冲突  
```cpp
#include<bits/stdc++.h>
#define lc (p<<1)
#define rc (p<<1|1)
#define frog 19260817//信仰之力！ 
using namespace std;
struct Node{
	int l,r,v,lazy_turn,lazy_all;
	int sum  ,lsum  ,rsum;
	int sum_0,lsum_0,rsum_0;
	//v:区间个数和 
	//sum  :连续1个数和 lsum  :左区间开始的连续1个数和 rsum  :右区间开始的连续1个数和
	//sum_0:连续0个数和 lsum_0:左区间开始的连续0个数和 rsum_0:右区间开始的连续0个数和
	//lazy_turn:区间是否翻转 lazy_all:区间是否全部更新 
	//维护区间0的个数是为了更方便的更新区间1的个数 
}T[800010];
int a[200010];
void pushup(int p){
	T[p].v=T[lc].v+T[rc].v; 
	
	T[p].lsum=T[lc].lsum;//用左区间左端的连续1个数更新当前区间左端连续1个数 
	if(T[lc].lsum==T[lc].r-T[lc].l+1)T[p].lsum+=T[rc].lsum;
	//如果左区间连续1个数等于其长度,即左区间全为1,加上右区间左端连续1个数 
	T[p].rsum=T[rc].rsum;//同上 
	if(T[rc].rsum==T[rc].r-T[rc].l+1)T[p].rsum+=T[lc].rsum;
	T[p].sum=max(T[lc].rsum+T[rc].lsum,max(T[lc].sum,T[rc].sum));//用左右区间的连续1个数和中间合并的连续1个数更新当前区间 
	
	T[p].lsum_0=T[lc].lsum_0;//同上 
	if(T[lc].lsum_0==T[lc].r-T[lc].l+1)T[p].lsum_0+=T[rc].lsum_0;
	T[p].rsum_0=T[rc].rsum_0;
	if(T[rc].rsum_0==T[rc].r-T[rc].l+1)T[p].rsum_0+=T[lc].rsum_0;
	T[p].sum_0=max(T[lc].rsum_0+T[rc].lsum_0,max(T[lc].sum_0,T[rc].sum_0));
}
void build(int p,int l,int r){
	T[p].l=l;T[p].r=r;
	T[p].lazy_all=-1;
	if(l==r){
		T[p].v=T[p].sum=T[p].lsum=T[p].rsum=a[l];
		T[p].sum_0=T[p].lsum_0=T[p].rsum_0=a[l]^1;
		//初始化此区间的值(1或0 ^1==取反) 
		return;
	}
	int mid=(l+r)>>1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	pushup(p);
}
void pushnow_turn(int p){
	T[p].v=(T[p].r-T[p].l+1)-T[p].v;//等于区间内总个数减去翻转后0的个数(即以前1的个数) 
	swap(T[p].sum,T[p].sum_0);//翻转1,0个数 
	swap(T[p].lsum,T[p].lsum_0);
	swap(T[p].rsum,T[p].rsum_0);
	if(T[p].lazy_all!=-1)
		T[p].lazy_all^=1;//进行过区间全部赋值,那么就直接对其进行修改 
	else T[p].lazy_turn^=1;//否则标记将此区间翻转 
} 
void pushnow_all(int p,int v){
	T[p].lazy_turn=0;T[p].lazy_all=v;//显然当全部赋值以后,区间是否翻转已无意义 
	if(v==1){//区间全部为1 
		T[p].sum=T[p].lsum=T[p].rsum=T[p].v=T[p].r-T[p].l+1;
		T[p].sum_0=T[p].lsum_0=T[p].rsum_0=0;
	}
	else{//区间全部为0 
		T[p].sum=T[p].lsum=T[p].rsum=T[p].v=0;
		T[p].sum_0=T[p].lsum_0=T[p].rsum_0=T[p].r-T[p].l+1;
	}
}
void pushdown(int p){
	if(T[p].lazy_all!=-1){//被全部修改过 
		pushnow_all(lc,T[p].lazy_all);
		pushnow_all(rc,T[p].lazy_all);
		T[p].lazy_all=-1;
	}
	if(T[p].lazy_turn){//被全部翻转过 
		pushnow_turn(lc);
		pushnow_turn(rc);
		T[p].lazy_turn=0;
	}
} 
void update_turn(int p,int ql,int qr){
	if(ql<=T[p].l&&T[p].r<=qr){
		pushnow_turn(p);
		return;
	}
	pushdown(p);
	int mid=(T[p].l+T[p].r)>>1;
	if(ql<=mid)update_turn(lc,ql,qr);
	if(qr>mid)update_turn(rc,ql,qr);
	pushup(p);
}
void update_all(int p,int ql,int qr,int v){
	if(ql<=T[p].l&&T[p].r<=qr){
		pushnow_all(p,v);
		return;
	}
	pushdown(p);
	int mid=(T[p].l+T[p].r)>>1;
	if(ql<=mid)update_all(lc,ql,qr,v);
	if(qr>mid)update_all(rc,ql,qr,v);
	pushup(p);
}
int query_all(int p,int ql,int qr){
	if(ql<=T[p].l&&T[p].r<=qr)
		return T[p].v;
	pushdown(p);
	int mid=(T[p].l+T[p].r)>>1,ans=0;
	if(ql<=mid)ans+=query_all(lc,ql,qr);
	if(qr>mid)ans+=query_all(rc,ql,qr);
	return ans;
}
Node query_continue(int p,int ql,int qr){
	if(ql<=T[p].l&&T[p].r<=qr)
		return T[p];
	pushdown(p);
	int mid=(T[p].l+T[p].r)>>1;
	if(ql<=mid&&mid<qr){//此区间全部在查询范围内  
		Node lans,rans,ans;
		lans=query_continue(lc,ql,qr);
		rans=query_continue(rc,ql,qr);
		//同pushup 
		ans.lsum=lans.lsum;
		if(lans.lsum==T[lc].r-T[lc].l+1)ans.lsum+=rans.lsum;
		ans.rsum=rans.rsum;
		if(rans.rsum==T[rc].r-T[rc].l+1)ans.rsum+=lans.rsum;
		ans.sum=max(lans.rsum+rans.lsum,max(lans.sum,rans.sum));
		return ans;
	}
	if(ql<=mid)return query_continue(lc,ql,qr);
	if(qr>mid)return query_continue(rc,ql,qr);
}
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
		scanf("%d",&a[i]);
	build(1,1,n);
	for(int i=1;i<=m;++i){
		int t,x,y;
		scanf("%d%d%d",&t,&x,&y);
		++x;++y;//本题坑点之一,处理成从1开始的下标 
		if(t==0||t==1)update_all(1,x,y,t);
		if(t==2)update_turn(1,x,y);
		if(t==3)printf("%d\n",query_all(1,x,y));
		if(t==4)printf("%d\n",query_continue(1,x,y).sum);
	}
	return 0;
}
```


---

## 作者：Genius_Z (赞：0)

这里给出一种常数略大但是可能会好想一些的做法。

这题的难点在于更新和标记。

我这里选择维护了左边的连续$1$的个数$lsum$，右边的连续$1$的个数$rsum$，$1$的总数$tot$以及最长的连续$1$的和$sum$。

区间赋值非常好处理，重点在于反转操作。

由于本蒟蒻比较弱，一时间没有想出好的做法，就选择了维护两个线段树，一个维护答案，另一个维护反转后的树，记为$mirror$。

上传时与原树同样更新，在区间赋值的时候对$mirror$赋相反的值，但是标记要打相同的标记，下传的时候统一清空（因为没有统一清空$WA$了两次）。

还有就是询问$sum$时的合并答案就和上传一样维护就行了。

Code：

```cpp
#include <algorithm>
#include <bitset>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <vector>
#define inl inline
#define re register int
const int inf = 0x3f3f3f3f;
#define lowbit(x) ((x) & (-x))
using namespace std;
template <class Read>
inl Read read() {
    Read x = 0;
    register bool w = 0;
    register char c = getchar();
    while (c > '9' || c < '0') {
        if (c == '-')
            w = 1;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        x = (x << 3) + (x << 1) + (c ^ 48);
        c = getchar();
    }
    return w ? -x : x;
}
int a[100001];
struct node {
    int tot, sum, lsum, rsum;
    bool reset, modify, rev;
}t[1000001], mirror[1000001];
struct val {
    int sum, lsum, rsum;
};
inl void maintain(int k, int l, int r, int mid) {
    re ls = k << 1, rs = k << 1 | 1;
    t[k].tot = t[ls].tot + t[rs].tot;
    t[k].lsum = t[ls].lsum, t[k].rsum = t[rs].rsum;
    if (t[ls].sum == mid - l + 1)t[k].lsum += t[rs].lsum;//如果左边全为1就加上右边的左连续1
    if (t[rs].sum == r - mid)t[k].rsum += t[ls].rsum;//同理
    t[k].sum = max(max(t[ls].sum, t[rs].sum), t[ls].rsum + t[rs].lsum);
    mirror[k].tot = mirror[ls].tot + mirror[rs].tot;
    mirror[k].lsum = mirror[ls].lsum, mirror[k].rsum = mirror[rs].rsum;
    if (mirror[ls].sum == mid - l + 1)mirror[k].lsum += mirror[rs].lsum;
    if (mirror[rs].sum == r - mid)mirror[k].rsum += mirror[ls].rsum;
    mirror[k].sum = max(max(mirror[ls].sum, mirror[rs].sum), mirror[ls].rsum + mirror[rs].lsum);
}
inl void build(int k, int l, int r) {
    if (l == r) {
        t[k].sum = t[k].lsum = t[k].rsum = t[k].tot = a[l];
        mirror[k].sum = mirror[k].lsum = mirror[k].rsum = mirror[k].tot = a[l] ^ 1;
        return;
    }
    re mid = l + r >> 1;
    build(k << 1, l, mid), build(k << 1 | 1, mid + 1, r);
    maintain(k, l, r, mid);
}
inl void modify(int x, int l, int r) {
    t[x].tot = t[x].sum = t[x].lsum = t[x].rsum = r - l + 1;
    t[x].modify = 1;
    t[x].reset = t[x].rev = 0;
    mirror[x].tot = mirror[x].sum = mirror[x].lsum = mirror[x].rsum = mirror[x].reset = mirror[x].rev = 0;
    mirror[x].modify = 1;
}
inl void zero(int x, int l, int r) {
    t[x].tot = t[x].sum = t[x].lsum = t[x].rsum = t[x].modify = t[x].rev = 0;
    t[x].reset = 1;
    mirror[x].tot = mirror[x].sum = mirror[x].lsum = mirror[x].rsum = r - l + 1;
    mirror[x].rev = mirror[x].modify = 0;
    mirror[x].reset = 1;//注意要打同样的标记
}
inl void filp(int x, int l, int r) {
    mirror[x].rev ^= 1, t[x].rev ^= 1;
    swap(mirror[x], t[x]);
}
inl void pushdown(int k, int l, int r) {
    re mid = l + r >> 1;
    if (t[k].modify) {
        modify(k << 1, l, mid);
        modify(k << 1 | 1, mid + 1, r);
        t[k].modify = mirror[k].modify = 0;
    }
    else if (t[k].reset) {
        zero(k << 1, l, mid);
        zero(k << 1 | 1, mid + 1, r);
        t[k].reset = mirror[k].reset = 0;
    }
    if (t[k].rev) {
        filp(k << 1, l, mid);
        filp(k << 1 | 1, mid + 1, r);
        t[k].rev = mirror[k].rev = 0;
    }//注意标记清空要统一清空
}
inl void change(int k, int l, int r, int x, int y) {
    if (l >= x && r <= y) {
        modify(k, l, r);
        return;
    }
    pushdown(k, l, r);
    re mid = l + r >> 1;
    if (x <= mid)change(k << 1, l, mid, x, y);
    if (y > mid)change(k << 1 | 1, mid + 1, r, x, y);
    maintain(k, l, r, mid);
}
inl void reset(int k, int l, int r, int x, int y) {
    if (l >= x && r <= y) {
        zero(k, l, r);
        return;
    }
    pushdown(k, l, r);
    re mid = l + r >> 1;
    if (x <= mid)reset(k << 1, l, mid, x, y);
    if (y > mid)reset(k << 1 | 1, mid + 1, r, x, y);
    maintain(k, l, r, mid);
}
inl void reverse(int k, int l, int r, int x, int y) {
    if (l >= x && r <= y) {
        filp(k, l, r);
        return;
    }
    pushdown(k, l, r);
    re mid = l + r >> 1;
    if (x <= mid)reverse(k << 1, l, mid, x, y);
    if (y > mid)reverse(k << 1 | 1, mid + 1, r, x, y);
    maintain(k, l, r, mid);
}
inl int qtot(int k, int l, int r, int x, int y) {
    if (l >= x && r <= y)return t[k].tot;
    pushdown(k, l, r);
    re mid = l + r >> 1, ans = 0;
    if (x <= mid)ans += qtot(k << 1, l, mid, x, y);
    if (y > mid)ans += qtot(k << 1 | 1, mid + 1, r, x, y);
    return ans;
}
inl val qsum(int k, int l, int r, int x, int y) {
    if (l >= x && r <= y)return val{ t[k].sum,t[k].lsum,t[k].rsum };
    pushdown(k, l, r);
    re mid = l + r >> 1, fl = 0, fr = 0;
    val ans = val{ 0,0,0 }, ls = val{ 0,0,0 }, rs = val{ 0,0,0 };
    if (x <= mid)ls = qsum(k << 1, l, mid, x, y), fl = 1;
    if (y > mid)rs = qsum(k << 1 | 1, mid + 1, r, x, y), fr = 1;
    if (!fl)return rs;
    if (!fr)return ls;//这里也是个小细节
    ans.sum = max(ls.sum, rs.sum);
    ans.lsum = ls.lsum, ans.rsum = rs.rsum;
    if (ls.sum == mid - max(l, x) + 1) ans.lsum += rs.lsum;
    if (rs.sum == min(r, y) - mid) ans.rsum += ls.rsum;
    ans.sum = max(ans.sum, ls.rsum + rs.lsum);
    return ans;
}
signed main() {
    re n = read<int>(), m = read<int>(), op, x, y;
    for (re i = 1; i <= n; i++)a[i] = read<int>();
    build(1, 1, n);
    while (m--) {
        op = read<int>(), x = read<int>() + 1, y = read<int>() + 1;
        if (!op) {
            reset(1, 1, n, x, y);
        }
        else if (op == 1) {
            change(1, 1, n, x, y);
        }
        else if (op == 2) {
            reverse(1, 1, n, x, y);
        }
        else if (op == 3) {
            printf("%d\n", qtot(1, 1, n, x, y));
        }
        else {
            printf("%d\n", qsum(1, 1, n, x, y).sum);
        }
    }
}
```



---

## 作者：斯茂 (赞：0)

# 一个比较麻烦的线段树

线段树的原理大家大概都比较清楚了

我把线段树的信息分为3类：

1. 结构类(左端点，右端点)

2. 参数/信息类(区间和，max)

3. 懒标记

主要说一下懒标记，懒标记tag的含义是对这棵子树除自己以外的部分应该作某些修改，但自己本身是修改过的

因此线段树要始终保证：只要各级祖先没有tag，自己维护的一切信息都是正确的

所以我们才能这样查询区间和:
```
int query(int nd, int p, int q)
{
	if(p > r[nd] || q < l[nd]) return 0;
	if(p <= l[nd] && q >= r[nd]) return val[nd];
	pushdown(nd);
	return query(2 * nd, p, q) + query(2 * nd + 1, p, q);
}
```

(这在我看来也是线段树不能区间翻转的一个原因)

我们考虑这道题需要2个tag，一个维护0/1是否反过来(rev)，一个维护有没有被区间赋值(set)

注意到某一段如果本来有set而无rev，加上一个rev会改变其set的值

而如果本来有rev而无set，加上一个set不会改变rev的值

这就好比加加法标记不会影响乘法，但加乘法标记会影响加法

这样我们就明白了，rev的优先级要高于set

因此在下传时要先下传rev

还有一点思维的误区需要澄清：

若一段既有rev又有set，则set是已经反过来后的结果，这也就对应了自身节点信息的正确性

另外，两次反置会回到原来的情况，所以更新rev是要异或上1，而不是简单地等于1

这题比较繁杂，建议不要过度压行，不然查错会很麻烦

当然，以上的都是个人观点，线段树本来写法就很多，如果写法差异较大的，忽略这篇文章即可

下面是(丑陋的)代码
```
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
struct st {int a, b, c;};//为了写子段和方便
st mst(int a, int b, int c){st x; x.a = a; x.b = b; x.c = c; return x;}
int a[100005], l[300005], r[300005], L[300005], set[300005], rev[300005];
int one[300005], lm[300005][2], rm[300005][2], mm[300005][2];
void pushup(int nd)
{
	one[nd] = one[2 * nd] + one[2 * nd + 1];
	lm[nd][0] = lm[2 * nd][0] + ((lm[2 * nd][0] == L[2 * nd]) ? lm[2 * nd + 1][0] : 0);
	lm[nd][1] = lm[2 * nd][1] + ((lm[2 * nd][1] == L[2 * nd]) ? lm[2 * nd + 1][1] : 0);
	rm[nd][0] = rm[2 * nd + 1][0] + ((rm[2 * nd + 1][0] == L[2 * nd + 1]) ? rm[2 * nd][0] : 0);
	rm[nd][1] = rm[2 * nd + 1][1] + ((rm[2 * nd + 1][1] == L[2 * nd + 1]) ? rm[2 * nd][1] : 0);
	mm[nd][0] = max(rm[2 * nd][0] + lm[2 * nd + 1][0], max(mm[2 * nd][0], mm[2 * nd + 1][0]));
	mm[nd][1] = max(rm[2 * nd][1] + lm[2 * nd + 1][1], max(mm[2 * nd][1], mm[2 * nd + 1][1]));
}
int f(int x)
{
	return x == -1 ? x : (x ^ 1);
}
void pushdown(int nd)
{
	if(rev[nd])
	{
		rev[2 * nd] ^= 1; rev[2 * nd + 1] ^= 1;
		set[2 * nd] = f(set[2 * nd]); set[2 * nd + 1] = f(set[2 * nd + 1]);
		one[2 * nd] = L[2 * nd] - one[2 * nd]; one[2 * nd + 1] = L[2 * nd + 1] - one[2 * nd + 1];
		swap(lm[2 * nd][0], lm[2 * nd][1]); swap(rm[2 * nd][0], rm[2 * nd][1]); swap(mm[2 * nd][0], mm[2 * nd][1]);
		swap(lm[2 * nd + 1][0], lm[2 * nd + 1][1]); swap(rm[2 * nd + 1][0], rm[2 * nd + 1][1]); swap(mm[2 * nd + 1][0], mm[2 * nd + 1][1]);
		rev[nd] = 0;
	}
	if(set[nd] != -1)
	{
		set[2 * nd] = set[2 * nd + 1] = set[nd];
		one[2 * nd] = L[2 * nd] * set[nd];
		one[2 * nd + 1] = L[2 * nd + 1] * set[nd];
		lm[2 * nd][1] = rm[2 * nd][1] = mm[2 * nd][1] = L[2 * nd] * set[nd];
		lm[2 * nd][0] = rm[2 * nd][0] = mm[2 * nd][0] = L[2 * nd] * (1 - set[nd]);
		lm[2 * nd + 1][1] = rm[2 * nd + 1][1] = mm[2 * nd + 1][1] = L[2 * nd + 1] * set[nd];
		lm[2 * nd + 1][0] = rm[2 * nd + 1][0] = mm[2 * nd + 1][0] = L[2 * nd + 1] * (1 - set[nd]);
		set[nd] = -1;
	}
}
void build(int nd)
{
	L[nd] = r[nd] - l[nd] + 1;
	if(L[nd] == 1)
	{
		one[nd] = a[l[nd]];
		lm[nd][one[nd]] = rm[nd][one[nd]] = mm[nd][one[nd]] = 1;
		return ;
	}
	l[2 * nd] = l[nd], r[2 * nd] = (l[nd] + r[nd]) / 2, l[2 * nd + 1] = r[2 * nd] + 1, r[2 * nd + 1] = r[nd];
	build(2 * nd); build(2 * nd + 1);
	pushup(nd);
}
void Set(int nd, int p, int q, int c)
{
	if(p > r[nd] || q < l[nd]) return ;
	if(p <= l[nd] && q >= r[nd])
	{
		set[nd] = c;
		one[nd] = L[nd] * set[nd];
		lm[nd][1] = rm[nd][1] = mm[nd][1] = L[nd] * set[nd];
		lm[nd][0] = rm[nd][0] = mm[nd][0] = L[nd] * (1 - set[nd]);
		return ;
	}
	pushdown(nd);
	Set(2 * nd, p, q, c); Set(2 * nd + 1, p, q, c);
	pushup(nd);
}
void reverse(int nd, int p, int q)
{
	if(p > r[nd] || q < l[nd]) return ;
	if(p <= l[nd] && q >= r[nd])
	{
		rev[nd] ^= 1;
		set[nd] = f(set[nd]); 
		one[nd] = L[nd] - one[nd];
		swap(lm[nd][0], lm[nd][1]);
		swap(rm[nd][0], rm[nd][1]);
		swap(mm[nd][0], mm[nd][1]);
		return ;
	}
	pushdown(nd);
	reverse(2 * nd, p, q); reverse(2 * nd + 1, p, q);
	pushup(nd);
}
int query(int nd, int p, int q)
{
	if(p > r[nd] || q < l[nd]) return 0;
	if(p <= l[nd] && q >= r[nd]) return one[nd];
	pushdown(nd);
	return query(2 * nd, p, q) + query(2 * nd + 1, p, q);
}
st qmax(int nd, int p, int q)
{
	if(p > r[nd] || q < l[nd]) return mst(0, 0, 0);
	if(p <= l[nd] && q >= r[nd]) return mst(lm[nd][1], rm[nd][1], mm[nd][1]);
	pushdown(nd);
	st x1 = qmax(2 * nd, p, q), x2 = qmax(2 * nd + 1, p, q);
	return mst(x1.a + ((x1.a == L[2 * nd]) ? x2.a : 0), x2.b + ((x2.b == L[2 * nd + 1]) ? x1.b : 0), max(max(x1.c, x2.c), x1.b + x2.a));
}
int main(int argc, char **argv)
{
	int n, m, op, p, q, i;
	memset(set, -1, sizeof(set));
	scanf("%d%d", &n, &m);
	for(i = 1; i <= n; i++)
		scanf("%d", &a[i]);
	l[1] = 1, r[1] = n;
	build(1);
	while(m--)
	{
		scanf("%d%d%d", &op, &p, &q);
		p++; q++; 
		switch(op)
		{
			case 0: Set(1, p, q, 0); break;
			case 1: Set(1, p, q, 1); break;
			case 2: reverse(1, p, q); break;
			case 3: printf("%d\n", query(1, p, q)); break;
			case 4: printf("%d\n", qmax(1, p, q).c); break;
		}
	}
	return 0;
}
```

---

## 作者：殇雪 (赞：0)

一道坑爹的线段树，我们维护7个信息，区间左右段点值，左右端点的连续长度，区间内的最长0串和1串。注意标记合并，翻转标记是xor更新的。覆盖标记遇上翻转标记是改覆盖标记类型。或者覆盖。

    
```cpp
#include<bits/stdc++.h>
#define sight(x) ('0'<=x&&x<='9')
#define MID ((l+r)>>1)
#define max(x,y) (x)>(y)?(x):(y) 
#define node No
#define o(x) (x=(x&1)+1)
#define L(x) ((x)<<1)
#define R(x) ((x)<<1|1)
#define La lazy
#define N 400007
using namespace std;
inline void read(int &x) {
    static char c; static int b;
    for (b=1,c=getchar();!sight(c);c=getchar()) if (c=='-') b=-1;
    for (x=0;sight(c);c=getchar()) x=x*10+c-48;
    x*=b;
}
struct Node{
    int sum,l,r,llen,rlen,ma[2],siz;
    inline void add(Node x,Node y){
        sum=x.sum+y.sum; siz=x.siz+y.siz;
        l=x.l; r=y.r;
        ma[0]=max(x.ma[0],y.ma[0]); ma[1]=max(x.ma[1],y.ma[1]);
        if (x.r==y.l) ma[x.r]=max(ma[x.r],x.rlen+y.llen);
        llen=x.llen; rlen=y.rlen;
        if (x.llen==x.siz) llen=x.llen+((y.l==x.r)?y.llen:0);
        if (y.rlen==y.siz) rlen=y.rlen+((y.l==x.r)?x.rlen:0);
    }
    inline void G1() {
        sum=siz-sum;
        l^=1,r^=1; swap(ma[0],ma[1]);
    }
    inline void L1(int x) {
        sum=x?siz:0;
        l=r=x; ma[x]=siz; ma[x^1]=0; llen=rlen=siz;
    }
}T[N],RR;
int La[N],La1[N];
inline void updata(int node){
    if (La[No]) { La[L(No)]=La[R(No)]=La[No];
    T[L(No)].L1(La[No]&1); La1[L(No)]=0;
    T[R(No)].L1(La[No]&1); La1[R(No)]=0; La[No]=0; return;}
    if (La1[No]) { 
    if (La[L(No)]) o(La[L(No)]),La1[L(No)]=0; else La1[L(No)]^=1;
    if (La[R(No)]) o(La[R(No)]),La1[R(No)]=0; else La1[R(No)]^=1;
    La1[No]=0; T[L(No)].G1(); T[R(No)].G1(); return;}
}
void build(int node,int l,int r){
    if (l==r) {
        read(T[node].sum);
        T[node].l=T[node].r=T[node].sum;
        T[node].llen=T[node].rlen=T[node].siz=1;
        T[node].ma[T[node].sum]=1;
        return;
    }
    build(L(No),l,MID); build(R(No),MID+1,r);
    T[node].add(T[L(No)],T[R(No)]);
}
void change(int node,int l,int r,int L,int R,int col){
    if (L<=l&&r<=R) {   int    XX=col&3;
        if (XX) { La1[No]=0; La[No]=XX; T[No].L1(XX&1);}  
        else { if (La[No]) o(La[No]),La1[No]=0; else La1[No]^=1; T[No].G1();
        } return;
    }
    if (La[node]||La1[node]) updata(node);
    if (R<=MID) change(L(No),l,MID,L,R,col); else
    if (L> MID) change(R(No),MID+1,r,L,R,col); else
    change(L(No),l,MID,L,MID,col),change(R(No),MID+1,r,MID+1,R,col);
    T[No].add(T[L(No)],T[R(No)]);
}
Node query(int node,int l,int r,int L,int R){
    if (L<=l&&r<=R) return T[node];
    if (La[node]||La1[node]) updata(node);
    if (R<=MID) return query(L(No),l,MID,L,R); 
    if (L> MID) return query(R(No),MID+1,r,L,R); 
    Node XX;
    XX.add(query(L(No),l,MID,L,MID),query(R(No),MID+1,r,MID+1,R));
    return XX;
}
void write(int x){
    if (x<10) {putchar('0'+x);return;}write(x/10); putchar('0'+x%10);
}
int n,m,op,X,Y;
int main () {
    freopen("a.in","r",stdin);
    read(n); read(m);
    build(1,1,n);
    while(m--) {
        read(op); read(X); read(Y); X++; Y++;
        switch (op){
            case 0:change(1,1,n,X,Y,2); break;
            case 1:change(1,1,n,X,Y,1); break;
            case 2:change(1,1,n,X,Y,4); break;
            case 3:RR=query(1,1,n,X,Y);write(RR.sum);putchar('\n'); break;
            case 4:RR=query(1,1,n,X,Y);write(RR.ma[1]);putchar('\n'); break;
        }
    }
    return 0;
}
```

---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P2572)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一眼线段树。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对询问$3$，我们需要维护区间$1$的个数；针对询问$4$，我们需要维护区间中左起的、右起的和最长的连续的$1$的个数。~~这两个询问其实是比较规规矩矩的了。~~  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑对于操作$0$和$1$，打懒标记；对于操作$2$，也打懒标记，且由于序列上的$0$和$1$会互换，所以我们需要将$1$维护的东西，再给$0$也维护一份，这样反转的时候才可以互换信息。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;询问$3$的时候也是一个中规中矩的操作。询问$4$的时候，询问区间并不总能完全覆盖节点的区间，所以需要再维护两个信息，表示当前区间和询问区间的交集中，左起和右起的最长的$1$的个数，于是就可以在回溯的时候更新答案和维护信息了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后提一下$0,1$和$2$的标记重叠问题，如果在$2$操作的时候，发现节点已经被整体赋过一次值了，那么我们就需要对于整体赋的值也翻转一下，避免下传的时候出错。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不知道为什么，这份代码跑得还不太慢。
# 代码
```cpp
#include <cstdio>

const int MAXN = 1e5 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b;
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

template<typename _T>
void swapp( _T &x, _T &y )
{
	_T t = x; x = y, y = t;
}

struct segmentTreeNode
{
	int l0, l1, r0, r1, s0, siz, mx0, mx1;
	int tag, val;
	#define l0( x ) ( segTree[x].l0 )
	#define l1( x ) ( segTree[x].l1 )
	#define r0( x ) ( segTree[x].r0 )
	#define r1( x ) ( segTree[x].r1 )
	#define s0( x ) ( segTree[x].s0 )
	#define siz( x ) ( segTree[x].siz )
	#define mx0( x ) ( segTree[x].mx0 )
	#define mx1( x ) ( segTree[x].mx1 )
	#define tag( x ) ( segTree[x].tag )
	#define val( x ) ( segTree[x].val )
	#define isLeaf( x ) ( segTree[x].siz == 1 )
}segTree[MAXN << 2];

int seq[MAXN];
int N, M;

void upt( const int x )
{
	if( isLeaf( x ) ) return ;
	s0( x ) = s0( x << 1 ) + s0( x << 1 | 1 );
	l0( x ) = l0( x << 1 ) == siz( x << 1 ) ? ( siz( x << 1 ) + l0( x << 1 | 1 ) ) : l0( x << 1 );
	l1( x ) = l1( x << 1 ) == siz( x << 1 ) ? ( siz( x << 1 ) + l1( x << 1 | 1 ) ) : l1( x << 1 );
	r0( x ) = r0( x << 1 | 1 ) == siz( x << 1 | 1 ) ? ( siz( x << 1 | 1 ) + r0( x << 1 ) ) : r0( x << 1 | 1 );
	r1( x ) = r1( x << 1 | 1 ) == siz( x << 1 | 1 ) ? ( siz( x << 1 | 1 ) + r1( x << 1 ) ) : r1( x << 1 | 1 );
	mx0( x ) = MAX( MAX( mx0( x << 1 ), mx0( x << 1 | 1 ) ), r0( x << 1 ) + l0( x << 1 | 1 ) );
	mx1( x ) = MAX( MAX( mx1( x << 1 ), mx1( x << 1 | 1 ) ), r1( x << 1 ) + l1( x << 1 | 1 ) );
}

void cover( const int x, const int v )
{
	if( v ) mx0( x ) = s0( x ) = l0( x ) = r0( x ) = 0, mx1( x ) = l1( x ) = r1( x ) = siz( x );
	else mx1( x ) = l1( x ) = r1( x ) = 0, s0( x ) = mx0( x ) = l0( x ) = r0( x ) = siz( x );
	tag( x ) = -1, val( x ) = v;
}

void reverse( const int x )
{
	s0( x ) = siz( x ) - s0( x );
	swapp( l0( x ), l1( x ) ), swapp( r0( x ), r1( x ) ), swapp( mx0( x ), mx1( x ) );
	if( tag( x ) < 0 ) val( x ) ^= 1;
	else tag( x ) ^= 1;
}

void normalize( const int x )
{
	if( isLeaf( x ) || ! tag( x ) ) return ;
	if( tag( x ) < 0 ) cover( x << 1, val( x ) ), cover( x << 1 | 1, val( x ) );
	else reverse( x << 1 ), reverse( x << 1 | 1 );
	tag( x ) = val( x ) = 0;
}

void build( const int x, const int l, const int r )
{
	int mid = l + r >> 1;
	if( l > r ) return; 
	siz( x ) = r - l + 1;
	if( l == r ) { cover( x, seq[l] ); return ; }
	build( x << 1, l, mid );
	build( x << 1 | 1, mid + 1, r );
	upt( x );
}

void cover( const int x, const int l, const int r, const int segL, const int segR, const int v )
{
	int mid = l + r >> 1;
	if( segL <= l && r <= segR ) { cover( x, v ); return ; }
	if( isLeaf( x ) ) return ; normalize( x );
	if( segL <= mid ) cover( x << 1, l, mid, segL, segR, v );
	if( segR > mid ) cover( x << 1 | 1, mid + 1, r, segL, segR, v );
	upt( x );
}

void reverse( const int x, const int l, const int r, const int segL, const int segR )
{
	int mid = l + r >> 1;
	if( segL <= l && r <= segR ) { reverse( x ); return ; }
	if( isLeaf( x ) ) return ; normalize( x );
	if( segL <= mid ) reverse( x << 1, l, mid, segL, segR );
	if( segR > mid ) reverse( x << 1 | 1, mid + 1, r, segL, segR );
	upt( x );
}

int query1( const int x, const int l, const int r, const int segL, const int segR )
{
	int mid = l + r >> 1, ret = 0;
	if( segL <= l && r <= segR ) return siz( x ) - s0( x );
	if( isLeaf( x ) ) return 0; normalize( x );
	if( segL <= mid ) ret += query1( x << 1, l, mid, segL, segR );
	if( segR > mid ) ret += query1( x << 1 | 1, mid + 1, r, segL, segR );
	return ret;
}

int query2( const int x, const int l, const int r, const int segL, const int segR, int &lef, int &rig )
{
	int mid = l + r >> 1, ret = 0, ll = 0, lr = 0, rl = 0, rr = 0;
	if( segL <= l && r <= segR ) { lef = l1( x ), rig = r1( x ); return mx1( x ); }
	if( isLeaf( x ) ) return 0; normalize( x );
	if( segL <= mid ) ret = MAX( ret, query2( x << 1, l, mid, segL, segR, ll, lr ) );
	if( segR > mid ) ret = MAX( ret, query2( x << 1 | 1, mid + 1, r, segL, segR, rl, rr ) );
	ret = MAX( ret, lr + rl );
	lef = ll == mid - MAX( l, segL ) + 1 ? ( ll + rl ) : ll;
	rig = rr == MIN( r, segR ) - mid ? ( rr + lr ) : rr;
	return ret;
}

int main()
{
	int op, L, R, lv, rv;
	read( N ), read( M );
	for( int i = 1 ; i <= N ; i ++ ) read( seq[i] );
	build( 1, 1, N );
	while( M -- )
	{
		read( op ), read( L ), read( R );
		L ++, R ++;
		if( op == 0 ) cover( 1, 1, N, L, R, 0 );
		if( op == 1 ) cover( 1, 1, N, L, R, 1 );
		if( op == 2 ) reverse( 1, 1, N, L, R );
		if( op == 3 ) write( query1( 1, 1, N, L, R ) ), putchar( '\n' );
		if( op == 4 ) write( query2( 1, 1, N, L, R, lv, rv ) ), putchar( '\n' );
	}
	return 0;
}
```

---

## 作者：info___tion (赞：0)

# Previous

建议大家可以先做一下[这一题](https://www.luogu.org/problemnew/show/UVA1400)，和本题的思路相近（但是没有修改操作）

# Main

## 基本思想及解释

首先，对于线段树的每个节点可以这么构造：
```cpp
struct Node
{
	int l,r;
	int sum[2];
	int _max[2],lmax[2],rmax[2];
	bool tag[2],tags;
    
	#define l(x) tree[x].l
	#define r(x) tree[x].r
	#define len(x) tree[x].r-tree[x].l+1
	#define sum(x,y) tree[x].sum[y]
	#define _max(x,y) tree[x]._max[y]
	#define lmax(x,y) tree[x].lmax[y]
	#define rmax(x,y) tree[x].rmax[y]
	#define tag(x,y) tree[x].tag[y]
	#define tags(x) tree[x].tags
}tree[262150];
```

~~请忽略`#define`~~

其中，

- `l,r`表示这个节点映射到整个数组上的对应区间
- `sum[0,1]`表示对应区间里有多少个$0$和$1$
- `_max[0,1]`表示对应区间里**“连续的$1$”的最大长度**；
- `l(r)max[0,1]`表示对应区间里**前（后）缀1**的长度（比如说，对于$1011$，那么$lmax=1, rmax=2$）；
- `tag[0,1]`表示对应区间是否被**修改为$0$或$1$**的标记
- `tags`表示对应区间是否被**反转**的标记

这样同时维护$0$和$1$的数据的话，当我们遇到题目中的反转操作时，只需要**将属于$0$和属于$1$的数据都`std::swap`一次，然后再打上标记**即可。

看起来`sum`并不难维护，那么问题来了：**如何维护`_max`？`lmax`和`rmax`又有什么用呢？**

## （理论上的）维护

- 对于`_max`的维护，可以分成**两种情况**：

	1. ![](https://s2.ax1x.com/2019/07/01/Z8A4KK.png)

		最长的连续$1$可能**横跨了区间的左右两半**，这时，$\_max=rmax(lson)+lmax(rson)$

	2. ![](https://s2.ax1x.com/2019/07/02/ZG7cOP.png)

		最长的连续$1$可能**完全在区间的左半部分或右半部分**，这时，$\_max=\max\{ \_max(lson),\_max(rson)\}$
   
   **综上所述，$\_max=\max\{ rmax(lson)+lmax(rson),\_max(lson),\_max(rson) \}$**

- 对于`lmax`和`rmax`，也可以分成**两种情况**（这里以`lmax`为例）：
	
    1. ![ZGHsNF.png](https://s2.ax1x.com/2019/07/02/ZGHsNF.png)
    
    	如果左半部分**完全是$1$**的话，那么$lmax=len(lson)+lmax(rson)$
    2. ![ZGbn5F.png](https://s2.ax1x.com/2019/07/02/ZGbn5F.png)
    	
        如果左半部分**不完全是$1$**的话，那么$lmax=lmax(lson)$
        
  `rmax`同理。
  
  （注意，`l(r)max`和`_max`不一样，**不需要取`std::max()`**）
  
- 搞完了各种`max`，接下来就只剩下`tag`（就是**下推标记的操作**）了。

	首先我们要明白：**上面的三个`tag`（`tag[0,1]`和`tags`）之间是有优先级的**。
    
    这个很容易理解：**当你将某个区间里面的所有数字都改成$0$或者$1$之后，之前的反转和其它赋值就没有意义了**  
    **但是如果你只是反转的话，之前的$0,1$赋值对以后还是有用的**。
    
    所以可以得出：**`tags`的优先级低于`tag[0,1]`**。
    
    在实际操作中就是：
    
    1. 修改`tag[0,1]`时，如果修改的是`tag[k]`，则**将`tag[k^1]`和`tags`都修改为$0$**（表示之前的操作已经没有意义），**将`tag[k]`修改为$1$**；（`^`表示异或）
    
    2. 修改`tags`时，则**只需要执行`tags^=1`即可**（因为连续反转两次之后就相当于没有反转过，~~如果像笔者一样一开始直接执行`tags=0`的话只有10分~~）
    
## 实际维护

~~其实就是详细地讲解代码~~

- 首先，建树本身不难：

  ```cpp
  void build(int l,int r,int index)
  {
      l(index)=l,r(index)=r;

      if( l==r ){sum(index,o[l])=_max(index,o[l])=lmax(index,o[l])=rmax(index,o[l])=1;return;}

      int mid=(l+r)>>1;
      build(l,mid,index<<1);build(mid+1,r,index<<1|1);

      pushup(index);return;
  }
  ```

	结合上面的`#define`来看的话，其实都是一些日常操作……

- 向上更新信息（`pushup`）也不难，按照上面理论维护的思路写就可以了，~~但是可能会很复读机……而且细节千万不能打错（比如不能把0和1打反）~~

	![ZGXAWF.png](https://s2.ax1x.com/2019/07/02/ZGXAWF.png)
    
    ~~因为页宽有限，直接放代码不是很美观，只能放截图了，求不要被打qaq~~
    
- **做好准备！下推标记（`pushdown`）才是重点！（~~同样这里的细节也很多，要结合上面的思路好好理解才行，不然分分钟翻车……~~）**

  ```cpp
  void pushdown(int index)
  {
      if( tag(index,0) or tag(index,1) )
      {
          bool k=tag(index,1);

          sum(index<<1,k)=_max(index<<1,k)=lmax(index<<1,k)=rmax(index<<1,k)=len(index<<1);
          sum(index<<1,k^1)=_max(index<<1,k^1)=lmax(index<<1,k^1)=rmax(index<<1,k^1)=0;
          tag(index<<1,k)=1,tag(index<<1,k^1)=tags(index<<1)=0;

          sum(index<<1|1,k)=_max(index<<1|1,k)=lmax(index<<1|1,k)=rmax(index<<1|1,k)=len(index<<1|1);
          sum(index<<1|1,k^1)=_max(index<<1|1,k^1)=lmax(index<<1|1,k^1)=rmax(index<<1|1,k^1)=0;
          tag(index<<1|1,k)=1,tag(index<<1|1,k^1)=tags(index<<1|1)=0;

          tag(index,k)=0;
      }

      if( tags(index) )
      {
          swap( sum(index<<1,0),sum(index<<1,1) );
          swap( _max(index<<1,0),_max(index<<1,1) );
          swap( lmax(index<<1,0),lmax(index<<1,1) );
          swap( rmax(index<<1,0),rmax(index<<1,1) );
          tags(index<<1)^=1;

          swap( sum(index<<1|1,0),sum(index<<1|1,1) );
          swap( _max(index<<1|1,0),_max(index<<1|1,1) );
          swap( lmax(index<<1|1,0),lmax(index<<1|1,1) );
          swap( rmax(index<<1|1,0),rmax(index<<1|1,1) );
          tags(index<<1|1)^=1;

          tags(index)=0;
      }

      return;
  }
  ```
  
  重点注意一下各个`tag`是如何修改的，其它的维护和上面所说的一样。
  
- 剩下的就是题目中的具体操作，大部分都不难（按照常规的线段树和上面的思路打出来即可），但是第$4$种操作（就是询问区间里最多有多少个连续的$1$）稍难，还是要拿代码来讲：

	```cpp
	int ask_max(int l,int r,int index)
    {
        if( l<=l(index) and r(index)<=r ) return _max(index,1);
        pushdown(index);
        
        int mid=( l(index)+r(index) )>>1;
        
        if( r<=mid ) return ask_max(l,r,index<<1);
        else if( l>mid ) return ask_max(l,r,index<<1|1);
        else return max( min( rmax(index<<1,1),mid-l+1 )+min( lmax(index<<1|1,1),r-mid ),max( ask_max(l,mid,index<<1),ask_max(mid+1,r,index<<1|1) ) );
    }
	```
    
    **重点是最后一行！**
    
    ![ZYqfYT.png](https://s2.ax1x.com/2019/07/03/ZYqfYT.png)
    
    ~~（如果看不清楚的话可以右键打开新标签页查看图片）~~
    
    首先，这个`std::max`里面有**三项**。最后两项很容易理解，就是返回左右两棵子树的`_max`，**关键是第一项：为什么`rmax`和`lmax`前面要加`std::min`呢？**
    
    画个例子就能明白了：![ZYLkAP.png](https://s2.ax1x.com/2019/07/03/ZYLkAP.png)
    
    紫框是询问的区间，两个绿框分别代表`lmax`和`rmax`。
    我们可以看到，**`lmax`和`rmax`有时可能会比询问区间还要长！**
    
    所以我们才需要取`std::min()`，**如果`r(l)max`比询问区间的左（右）半部分还长的话，就取`mid-l+1`和`r-mid`（表示询问区间的左（右）半部分）**。
    
# Final

下面是代码~~（可能结构体码风有些恶心，不要打我qaq~~

[$\mathrm{Code}$](https://www.luogu.org/paste/iku5ymww)

---


# [ZJOI2008] 树的统计

## 题目描述

一棵树上有 $n$ 个节点，编号分别为 $1$ 到 $n$，每个节点都有一个权值 $w$。

我们将以下面的形式来要求你对这棵树完成一些操作：

I. `CHANGE u t` : 把结点 $u$ 的权值改为 $t$。

II. `QMAX u v`: 询问从点 $u$ 到点 $v$ 的路径上的节点的最大权值。

III. `QSUM u v`: 询问从点 $u$ 到点 $v$ 的路径上的节点的权值和。

注意：从点 $u$ 到点 $v$ 的路径上的节点包括 $u$ 和 $v$ 本身。

## 说明/提示

对于 $100 \%$ 的数据，保证 $1\le n \le 3\times 10^4$，$0\le q\le 2\times 10^5$。

中途操作中保证每个节点的权值 $w$ 在 $-3\times 10^4$ 到 $3\times 10^4$ 之间。

## 样例 #1

### 输入

```
4
1 2
2 3
4 1
4 2 1 3
12
QMAX 3 4
QMAX 3 3
QMAX 3 2
QMAX 2 3
QSUM 3 4
QSUM 2 1
CHANGE 1 5
QMAX 3 4
CHANGE 3 6
QMAX 3 4
QMAX 2 4
QSUM 3 4
```

### 输出

```
4
1
2
2
10
6
5
6
5
16
```

# 题解

## 作者：zcysky (赞：112)

<http://www.lydsy.com/JudgeOnline/problem.php?id=1036>

直接树链剖分线段树维护好了，神犇会写lct，然而我不会23333

树链剖分入门题，建议一做。

```cpp
#include<bits/stdc++.h>
#define N 100005
#define inf 1000000000
using namespace std;
int n,q,a[4*N];
struct Edge{
    int u,v,next;
}G[N];
int tot=0,head[N];
int size[100005],wson[100005],fa[100005],d[100005],top[100005];
int tpos[100005],pre[100005],cnt=0;
inline void addedge(int u,int v){
    G[++tot].u=u;G[tot].v=v;G[tot].next=head[u];head[u]=tot;
    G[++tot].u=v;G[tot].v=u;G[tot].next=head[v];head[v]=tot;
}
void dfs1(int u,int f){
    size[u]=1;
    for (int i=head[u];i;i=G[i].next){
        int v=G[i].v;if (v==f)continue;
        d[v]=d[u]+1;fa[v]=u;
        dfs1(v,u);
        size[u]+=size[v];
        if (size[v]>size[wson[u]])wson[u]=v;
    }
}
void dfs2(int u,int TP){
    tpos[u]=++cnt;pre[cnt]=u;top[u]=TP;
    if (wson[u])dfs2(wson[u],TP);
    for (int i=head[u];i;i=G[i].next){
        int v=G[i].v;
        if (v==fa[u]||v==wson[u])continue;
        dfs2(v,v);
    }
}
int sumv[4*N],maxv[4*N];
inline void pushup(int o){
    sumv[o]=sumv[o*2]+sumv[o*2+1];
    maxv[o]=max(maxv[o*2],maxv[o*2+1]);
}
void build(int o,int l,int r){
    int mid=(l+r)/2;
    if (l==r){sumv[o]=maxv[o]=a[pre[l]];return;}
    build(o*2,l,mid);build(o*2+1,mid+1,r);
    pushup(o);
}
void update(int o,int l,int r,int q,int v){
    int mid=(l+r)/2;
    if (l==r){sumv[o]=maxv[o]=v;return;}
    if (q<=mid)update(o*2,l,mid,q,v);
    else update(o*2+1,mid+1,r,q,v);
    pushup(o);
}
int querysum(int o,int l,int r,int ql,int qr){
    int mid=(l+r)/2,ans=0;
    if (ql<=l&&r<=qr)return sumv[o];
    if (ql<=mid)ans+=querysum(o*2,l,mid,ql,qr);
    if (qr>mid)ans+=querysum(o*2+1,mid+1,r,ql,qr);
    pushup(o);
    return ans;
}
int querymax(int o,int l,int r,int ql,int qr){
    int mid=(l+r)/2,ans=-inf;
    if (ql<=l&&r<=qr)return maxv[o];
    if (ql<=mid)ans=max(ans,querymax(o*2,l,mid,ql,qr));
    if (qr>mid)ans=max(ans,querymax(o*2+1,mid+1,r,ql,qr));
    pushup(o);
    return ans;
}
int qsum(int u,int v){
    int ans=0;
    while (top[u]!=top[v]){
        if (d[top[u]]<d[top[v]])swap(u,v);
        ans+=querysum(1,1,n,tpos[top[u]],tpos[u]);
        u=fa[top[u]];
    }
    if (d[u]<d[v])swap(u,v);
    ans+=querysum(1,1,n,tpos[v],tpos[u]);
    return ans;
}
int qmax(int u,int v){
    int ans=-inf;
    while (top[u]!=top[v]){
        if (d[top[u]]<d[top[v]])swap(u,v);
        ans=max(ans,querymax(1,1,n,tpos[top[u]],tpos[u]));
        u=fa[top[u]];
    }
    if (d[u]<d[v])swap(u,v);
    ans=max(ans,querymax(1,1,n,tpos[v],tpos[u]));
    return ans;
}
int main(){
    memset(head,0,sizeof(head));
    memset(a,0,sizeof(a));
    scanf("%d",&n);
    for (int i=1;i<n;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        addedge(u,v);
    }
    for (int i=1;i<=n;i++)scanf("%d",&a[i]);
    d[1]=1;fa[1]=1;dfs1(1,-1);dfs2(1,1);build(1,1,n);
    scanf("%d",&q);
    while (q--){
        int x,y;
        char s[10];
        scanf("%s%d%d",s,&x,&y);
        if (s[1]=='H')update(1,1,n,tpos[x],y);
        if (s[1]=='M')printf("%d\n",qmax(x,y));
        if (s[1]=='S')printf("%d\n",qsum(x,y));
    }
    return 0;
}
```

---

## 作者：a999999 (赞：72)

$2019.6.29\ update:$给出了时间复杂度的证明，更新了$L_AT^EX$

---
先引入一个问题：
```
给定一颗有n个节点的树，给定根节点
每次给出点对(x,y)，查询x到y路径上深度最小的节点(即LCA)。
```
![树](https://cdn.luogu.com.cn/upload/pic/53670.png)

看到这样的题目，大家首先想到的是暴力吧？
1. 从$x$出发向上走到根，标记每个经过的节点。
2. 从$y$出发向上走，经过的第一个**有标记**的节点就是"x到y路径上深度最小的节点"$(LCA)$。

![(3,2)](https://cdn.luogu.com.cn/upload/pic/53671.png)

$Code:$

```cpp
int LCA(int x,int y)
{
	if(x==y)return x;
	while(x!=root)vis[x]=true,x=fa[x];
	while(y!=root)
		if(vis[y])return y;
		else y=fa[y];
	return root;
}
```
但是让我们算算复杂度... $\Theta(N)\ $~~TLE~~ 

为什么复杂度如此之高？明显是因为走得太慢了。

我们需要更好的算法。

怎么做呢？

睿智的先人想到了~~倍增~~**树剖**

先把树剖分成一条条的链

每次直接跳一整条链，不就快了吗？

于是，树链剖分($Tree-chain\ Partition$)诞生了。

---
~~以上均为废话~~
## 预处理
先来说剖分：

**剖分，是指依据某种运算，将几个节点分入同一条链，而将一颗树分成几条链的方法。**

看不懂没关系~~反正它不重要~~

常见的剖分有三种：
1. 重链剖分
2. 实链剖分（Link-Cut Tree才用）
3. 长链剖分（几乎不用）

所以，我们讲的是**重链剖分**

重链剖分依据啥呢？依据的是儿子的子树大小，即$x$**子树最大**的儿子与$x$属于同一条重链。

首先定义几种变量：
- $dep_x$：$x$的深度
- $fa_x$：$x$的父亲
- $siz_x$：以$x$为根的子树的节点数
- $son_x$:$x$的重儿子
- $top_x$:$x$所在重链的顶端编号
- $root$:整棵树的根
- $son(x)$:$x$的儿子所构成的集合

所以我们先要dfs一遍把前4种值算出来。
### code:
($head,ver,next$均为邻接表,不会的~~你还看什么树剖~~请先学会)

```cpp
void dfs1(ci&x){//ci -> const int,后文同
	siz[x]=1;
	for(int k=head[x],y;y=ver[k],k;k=next[k])
	{
		if(y==fa[x])continue;
		fa[y]=x;dep[y]=dep[x]+1;dfs1(y);
		if(siz[son[x]]<siz[y])son[x]=y;//求重儿子
		siz[x]+=siz[y];
	}
}
//以下语句加在main(int argc,char **argv)/main() 中
dep[root]=1;dfs1(root);
```
算完了前$4$种值，$top$该怎么算呢？

根据定义，一条重链上的节点的$top$值**相同**。

而在重链剖分中，$x$和$son_x$在**一条**重链上。

~~是不是发现了什么~~

于是我们得到了一条规律：
$$top_x=\{^{top_{fa_x}|son_{fa_x}==x}_{x|son_{fa_x} \neq x}\}$$

~~是不是很简单~~

所以我们就可以愉快的~~再dfs一遍~~计算啦

### code:
```cpp
void dfs2(ci&x){
	if(!son[x])return;
	top[son[x]]=top[x];dfs2(son[x]);//直接在fa[x]处赋值，减少参数传递
	for(int k=head[x],y;y=ver[k],k;k=next[k])
	{
		if(y==fa[x]||y==son[x])continue;
		top[y]=y;dfs2(y);//非重儿子的top[]一定是自己
	}
}
//以下语句加在main(int argc,char **argv)/main() 中
top[root]=root;dfs2(root);
```
预处理复杂度$\Theta(N)$

剖完后的树
![例重链](https://cdn.luogu.com.cn/upload/pic/53672.png)
## 查找LCA
有人问，把链剖出来有对于查LCA什么用呢？

我答：还记得暴力为什么TLE吗？

走太慢啦！

所以，树链剖分的实际作用——加速！

但是，剖完后如何查找呢？

~~经过苦思冥想，~~ 我们发现一条规律：

**无论什么时候，只要两个节点不在一条重链上$($即$top_x!=top_y)$，那么他们的$LCA$肯定不在深度大的那条重链上。**

所以，我们可以这样：
1. 对于点对$(x,y)$，记$fx=top_x,fy=top_y$.
2. 如果$fx!=fy$，转第3步；否则转第4步.
3. 将$fx,fy$中$dep[]$值大的往上跳(设$dep_{fx}>dep_{fy}$)，更新$((x,y)->(fa_{fx},y))$，回到第2步.
4. 这时$(x,y)$肯定在一条重链上$(top_x=top_y)$，而深度较小的那个就是$LCA$.

### code:

```cpp
int LCA(int x,int y)
{
	int fx=top[x],fy=top[y];
	while(fx!=fy)
	{
		if(dep[fx]<dep[fy])std::swap(x,y),std::swap(fx,fy);
		x=fa[fx],fx=top[x];
	}
	return dep[x]<dep[y]?x:y;
}
```
那么这种加速跳法的效果怎么样呢？

可以证明单次操作的时间复杂度$\Theta(lgN)$

证明：

我们需要$3$个定理：
1. $\forall y\in son(x)\  \&\ y\neq son_x$，都有$siz_y\le \frac{siz_x}{2}$

反证法，假设有$siz_y>\frac{siz_x}{2}$且$y\in son(x)$

那么就有$y=son_x$，与定理矛盾

所以假设不成立，原命题成立

2. $\forall x\in son(root)$,从$root$到$x$的路径上存在不超过$lgN$条轻边

因为每经过一条轻边，到达的点的$siz$就会减半

所以最多减$lgN$次$siz_x$就变成$1$了$($到达叶子节点$)$

3. $\forall x\in son(root)$，从$root$到$x$的路径上存在不超过$lgN$条重链

因为一条**重链**的**两端**必定是**轻边**

所以重链的数量比轻边少一条（重链通向$root$除外）

最坏情况下轻重链数量一样，为$lgN$

所以每次我们跳过一条重链，这样的重链有$lgN$条

时间复杂度就为$\Theta(lgN)$啦

例题[P3379](https://www.luogu.org/fe/problem/P3379)

找$LCA$的板子题

这里是[BFS实现版](https://www.luogu.org/recordnew/show/20058405)$($不知道为什么更慢$)$

$Code(DFS):$
```cpp
#include<algorithm>
#include<cstdio>
#define N 500010
#define M 500010
#define ci const int
using namespace std;
int head[N],ver[M<<1],next[M<<1],tot;
int dep[N],fa[N],siz[N],son[N],top[N];
int n,m,root;
void add(ci&x,ci&y){ver[++tot]=y;next[tot]=head[x];head[x]=tot;}
void dfs1(ci&x)
{
    siz[x]=1;
    for(int k=head[x],y;y=ver[k],k;k=next[k])
    {
        if(y==fa[x])continue;
        fa[y]=x;dep[y]=dep[x]+1;dfs1(y);
        if(siz[son[x]]<siz[y])son[x]=y;
        siz[x]+=siz[y];
    }
}
void dfs2(ci&x)
{
    if(!son[x])return;
    top[son[x]]=top[x];dfs2(son[x]);
    for(int k=head[x],y;y=ver[k],k;k=next[k])
    {
        if(y==fa[x]||y==son[x])continue;
        top[y]=y;dfs2(y);
    }
}
int LCA(int x,int y)
{
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]])swap(x,y);
        x=fa[top[x]];
    }
    return dep[x]<dep[y]?x:y;
}
signed main(int argc,char **agrv)
{
    scanf("%d%d%d",&n,&m,&root);
    for(int i=1,x,y;i<n;++i)
        scanf("%d%d",&x,&y),add(x,y),add(y,x);//记得添双向边哦
    dep[root]=1;dfs1(root);
    top[root]=root;dfs2(root);
    register int x,y;
    while(m--)
        scanf("%d%d",&x,&y),printf("%d\n",LCA(x,y));
    return 0;
}
```

## 套线段树
又有~~睿智~~聪明的小盆友问了：

这个奇怪的东西怎么套线段树呢？

我们来再看一看树链剖分后轻重边的分配情况：

![](https://cdn.luogu.com.cn/upload/pic/53672.png)

如果我们把链拼成一个序列，就像这样：

![](https://cdn.luogu.com.cn/upload/pic/53789.png)

那么是不是可以用线段树维护呢？

~~不是也得是~~

如何确定每个节点在序列中的位置呢？

我们回到$dfs2()$中

很容易发现一个性质：

对于同一条重链上的节点，他们一定是被**连续访问**的！

所以我们可以直接在$dfs2()$中计算出每个节点在序列中的位置（其实就是重标号）

$Code:$

```cpp
void dfs2(int x)
{
    if(!son[x])return;
    seg[son[x]]=++cnt;rev[cnt]=son[x];//rev[x]表示序列中x的对应树上节点
    top[son[x]]=top[x];dfs2(son[x]);//直接访问son[x]保证连续性
    for(int k=head[x],y;y=ver[k],k;k=next[k])
    {
        if(y==fa[x]||y==son[x])continue;
        seg[y]=++cnt;rev[cnt]=y;//用seg[0]代替cnt可以省空间
        top[y]=y;dfs2(y);
    }
}
```

接下来的问题是：

如果要查询一条路径上的权值和/最大值，怎么办呢？

记$x$到$y$的**路径权值和**为$sum(x,y)$。

来看这张图：
![](https://cdn.luogu.com.cn/upload/pic/58441.png)

假设现在查询$sum(3,4)$

将上图树拆成序列，用线段树维护
![](https://cdn.luogu.com.cn/upload/pic/58443.png)

可以发现，如果$top_x\neq top_y$，那么$dep_{top}$较大的那条链的**全部节点**都在答案中（即$sum(x,top_x)\in sum(x,y)$ | {$top_x\neq top_y\ \&\ dep_x>dep_y$}）

又因为我们的重链节点是**连续储存**的，在线段树中是一段**区间**

~~不用我说了吧~~

和之前一样，当计算完当前链的答案后，$x$跳到$fa_{top_x}$

最后$top_x==top_y$时，只用计算$sum(x,y)$这一段**区间**了。

整理一下：

1. 设$fx=top_x,fy=top_y$。

2. 若$fx==fy$，执行第4步；否则，设$dep_x>dep_y$，执行第三步。

3. 计算$(x,top_x)$对答案的贡献，$x=fa_{top_x}$。

4. 设$dep_x<dep_y$，计算$(x,y)$对答案的贡献

$Code:$（以求和为例）

```cpp
int query_sum(int x,int y)
{
    int fx=top[x],fy=top[y],ans=0;
    while(fx!=fy)
    {
        if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);
        ans+=ask_sum(1,1,n,seg[fx],seg[x]);
        x=fa[fx],fx=top[x];
    }
    if(dep[x]>dep[y])swap(x,y);
    ans+=ask_sum(1,1,n,seg[x],seg[y]);
    return ans;
}
```
同样的，我们可以推广到 求$max$/ 求$min$ /修改 的操作

因为每次跳重链都要进行$\Theta(lgN)$的查询

所以时间复杂度$\Theta(lg^2N)$

例题[P2590](https://www.luogu.org/fe/problem/P2590)

认真看代码，不会很难

$Code:$
```cpp
#include<algorithm>
#include<cstdio>
#define N 30010
using namespace std;
int head[N],ver[N<<1],next[N<<1],tot;
int dep[N],fa[N],siz[N],son[N],top[N];
int seg[N],rev[N],sum[N<<2],maxn[N<<2];
int n,m,num[N];char op[10];
inline void add(int x,int y){ver[++tot]=y;next[tot]=head[x];head[x]=tot;}
//---------------------------------------------------------
void dfs1(int x)
{
    siz[x]=1;
    for(int k=head[x],y;y=ver[k],k;k=next[k])
    {
        if(y==fa[x])continue;
        fa[y]=x;dep[y]=dep[x]+1;dfs1(y);
        if(siz[son[x]]<siz[y])son[x]=y;
        siz[x]+=siz[y];
    }
}
void dfs2(int x)
{
    if(!son[x])return;
    seg[son[x]]=++seg[0];rev[seg[0]]=son[x];//分配线段树节点
    top[son[x]]=top[x];dfs2(son[x]);
    for(int k=head[x],y;y=ver[k],k;k=next[k])
    {
        if(y==fa[x]||y==son[x])continue;
        seg[y]=++seg[0];rev[seg[0]]=y;
        top[y]=y;dfs2(y);
    }
}
//---------------------------------------------------------
void build(int p,int l,int r)//不会线段树的可以去逛我的blog
{
    if(l==r){sum[p]=maxn[p]=num[rev[l]];return;}
    int mid=l+r>>1;
    build(p<<1,l,mid);build(p<<1|1,mid+1,r);
    sum[p]=sum[p<<1]+sum[p<<1|1];
    maxn[p]=max(maxn[p<<1],maxn[p<<1|1]);
}
void change(int p,int l,int r,int x,int val)
{
    if(l==r){sum[p]=maxn[p]=val;return;}
    int mid=l+r>>1;
    if(x<=mid)change(p<<1,l,mid,x,val);
    else change(p<<1|1,mid+1,r,x,val);
    sum[p]=sum[p<<1]+sum[p<<1|1];
    maxn[p]=max(maxn[p<<1],maxn[p<<1|1]);
}
int ask_sum(int p,int l,int r,int x,int y)
{
    if(x<=l&&r<=y)return sum[p];
    int mid=l+r>>1,ans=0;
    if(x<=mid)ans=ask_sum(p<<1,l,mid,x,y);
    if(y>mid)ans+=ask_sum(p<<1|1,mid+1,r,x,y);
    return ans;
}
int ask_max(int p,int l,int r,int x,int y)
{
    if(x<=l&&r<=y)return maxn[p];
    int mid=l+r>>1,ans=-30000;
    if(x<=mid)ans=ask_max(p<<1,l,mid,x,y);
    if(y>mid)ans=max(ans,ask_max(p<<1|1,mid+1,r,x,y));
    return ans;
}
//---------------------------------------------------------
int query_max(int x,int y)//查询部分
{
    int fx=top[x],fy=top[y],ans=-30000;//记得初始化
    while(fx!=fy)
    {
        if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);
        ans=max(ans,ask_max(1,1,n,seg[fx],seg[x]));//fx~x的这条链
        x=fa[fx],fx=top[x];
    }
    if(dep[x]>dep[y])swap(x,y);
    ans=max(ans,ask_max(1,1,n,seg[x],seg[y]));//x~y的这条链
    return ans;
}
int query_sum(int x,int y)
{
    int fx=top[x],fy=top[y],ans=0;
    while(fx!=fy)
    {
        if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);
        ans+=ask_sum(1,1,n,seg[fx],seg[x]);//同上
        x=fa[fx],fx=top[x];
    }
    if(dep[x]>dep[y])swap(x,y);
    ans+=ask_sum(1,1,n,seg[x],seg[y]);
    return ans;
}
signed main()
{
    scanf("%d",&n);
    int x,y;
    for(int i=1;i<n;++i)
    scanf("%d%d",&x,&y),add(x,y),add(y,x);
    for(int i=1;i<=n;++i)scanf("%d",num+i);
    dep[1]=rev[1]=seg[0]=seg[1]=top[1]=1;//记得初始化！！！
    dfs1(1);dfs2(1);build(1,1,n);
    scanf("%d",&m);
    while(m--)
    {
        scanf("%s%d%d",op,&x,&y);
        if(*op=='C')change(1,1,n,seg[x],y);
        else{
            if(op[1]=='M')printf("%d\n",query_max(x,y));
            else printf("%d\n",query_sum(x,y));
        }
    }
}
```

---

### 后话

看完之后这些题就可以愉快地~~WA~~$AC$啦

1. [【国家集训队】旅游](https://www.luogu.org/problemnew/show/P1505)

主要是线段树上的区间修改

过程如下:

因为是区间$*(-1)$，所以修改后最大值是$-($最小值$)$，最小值是$-($最大值$)$，区间和是$-($区间和$)$

$Code:$
```
void pushdown(ci&p,ci&l,ci&r)//修改节点
{
    tree[p]=Node(-tree[p].minn,//最大值 = -最小值
                 -tree[p].maxn,//最小值 = -最大值
                 -tree[p].sum,tree[p].tag^1);//区间和 = -区间和，标记 ^= 1
}
```
时间复杂度$\Theta(Mlg^2N)$

[AC代码](https://www.luogu.org/recordnew/show/19845430)

2. [软件包管理器](https://www.luogu.org/fe/problem/P2146)

思路：

运用$dfs()$的本质$->$以$x$为根的子树在线段树中为
$$[seg[x],seg[x]+siz[x]-1]$$

时间复杂度$\Theta(Mlg^2N)$

[AC代码](https://www.luogu.org/recordnew/show/14296083)

你都看到这了，不给赞的话~

~~那还是人吗~~

---

## 作者：基地A_I (赞：65)

### 前言

刚刚学完树链剖分就来拿这道题练手了，为了增进自己对树链剖分的理解，因此来写了一篇题解。

## 思路

### 树链剖分 + 线段树单点修改 + 维护区间最大和区间和

## 树链剖分基本操作 

- ## 一、变量声明


```cpp
int num; //Dfs序新节点编号 (看不懂可以不要管
int f[N],dep[N],size[N],son[N];	//Dfs1处理 父亲，深度，大小，重儿子 
int top[N],id[N],rk[N];	//Dfs2处理 链顶，Dfs序新编号 ，新编号对应原编号 
```

（PS：~~看得都脑袋痛QWQ~~）

------------


------------

- ## 二、Dfs1 （处理父亲，深度，大小，重儿子）


```cpp
void Dfs1(int p,int fa)	//当前节点，当前节点父亲
{
	f[p]=fa ,dep[p]=dep[fa]+1 ,size[p]=1;	//处理父亲，深度是父亲+1，初始大小为1（即把自己算进去）
//	历遍边
	for(int i=head[p],v;i;i=edge[i].next) {
		if((v=edge[i].to) != fa) {
			Dfs1(v,p);	//继续Dfs1（）；
			size[p] += size[v];	//这时候子树的size已经处理出来，所以把size[p]加上子树size[v]；
			if(size[v] > size[son[p]])
				son[p] = v;	//找重儿子，重儿子的size要最大
		}
	}
}
```


------------


------------

- ## 三、Dfs2
>- #### Dfs序遍历
>- #### 处理当前节点对应当前节点所处链的链顶（top[]）
>- #### 当前节点新编号(id[ ])，
>- #### 新编号对应原编号（rk[ ]）

```cpp
void Dfs2(int p,int t)	//当前节点 ，当前重链顶
{
	top[p]=t ,id[p]=++num ,rk[num]=p;	//p的链顶是t，p的新序号是++num,rk[num]对应p
	if(son[p]) Dfs2(son[p],t);	//有重儿子先走重儿子
	//历遍边
	for(int i=head[p],v;i;i=edge[i].next) {
		if((v=edge[i].to)!=f[p] && v!=son[p])	//不是父亲也不是重儿子
			Dfs2(v,v);	//这个轻链的重链顶是自己
	}
}
```

（PS：Dfs2~~代码量更少却更难理解~~只要多打代码多想其实就很简单的QWQ）

- ## 四、查询

#### 先看在不在同一重链上，如果不在，就跳重链顶小的那个节点，跳到他所在重链顶的父节点上，并区间查询这条链，加入res（result结果）,以此类推，直到两点在同一链上。

#### 在同一链上在再确定两点的深度关系，区间查询从小点到大点（相当于重链上的一部分），加入res。


```cpp
int qsum(int x,int y)	//两个点x，y
{
	int res = 0;	//初始置0 ，注意区间Max要初始置 -INF 因为有负数
	while(top[x] != top[y]) {	//不在同链
		if(dep[top[x]] < dep[top[y]]) swap(x,y);	//跳链顶小的
		res+=tree.Querysum(id[top[x]],id[x],1,1,n);	//区间查询这条链 
		x = f[top[x]];	//跳 jump，junp（唱跳rap篮球
	}
	if(dep[x] > dep[y]) swap(x,y);	//确定先后位置
	return res += tree.Querysum(id[x],id[y],1,1,n); 	//区间查询链的这部分
}
```



（PS：求Max和sum的板子都一样，~~举一反三就好了~~）

线段树基本操作就不要写了吧，只是**要注意叶子节点赋初值时要用Dfs序对应原先节点的值，因为线段树的下标是Dfs序的下标，与原下标不同**。另外**使用线段树操作时要把节点转换成线段树节点下标**。线段树**递归记得边界return，否则会RE**。

#### 若还有不懂请看代码：

## AC Code

```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<cmath>
#define N 100007
#define INF 10000000
using namespace std;
int n,cnt,num,Q;
int val[N],head[N];
int f[N],dep[N],size[N],son[N];	//Dfs1处理 父亲，深度，大小，重儿子 
int top[N],id[N],rk[N];	//Dfs2处理 链顶，Dfs序新编号 ，新编号对应原编号 
struct Edge {
	int next,to;
}edge[N<<1];
struct Segment_Tree
{
	int sum[N<<2] ,maxv[N<<2];
	inline int ls(int p) {return p<<1;}
	inline int rs(int p) {return p<<1|1;}
	void push_up(int p) {
		sum[p] = sum[ls(p)] + sum[rs(p)];
		maxv[p] = max(maxv[ls(p)],maxv[rs(p)]);
	}
	void build(int p,int l,int r)
	{
		if(l==r) {sum[p]=maxv[p]=val[rk[l]]; return ;}
		int mid = (l+r)>>1;
		build(ls(p),l,mid);
		build(rs(p),mid+1,r);
		push_up(p);
	}
	int Querysum(int ql,int qr,int p,int l,int r)
	{
		if(ql<=l && r<=qr) return sum[p];
		int res=0 ,mid=(l+r)>>1;
		if(ql<=mid) res += Querysum(ql,qr,ls(p),l,mid);
		if(qr>mid) res += Querysum(ql,qr,rs(p),mid+1,r);
		return res;
	}
	int Querymax(int ql,int qr,int p,int l,int r)
	{
		if(ql<=l && r<=qr) return maxv[p];
		int Max=-INF ,mid=(l+r)>>1;
		if(ql<=mid) Max = max(Max,Querymax(ql,qr,ls(p),l,mid));
		if(qr>mid) Max = max(Max,Querymax(ql,qr,rs(p),mid+1,r));
		return Max;
	}
	void update(int p,int l,int r,int q,int v)
	{
		int mid = (l+r)>>1;
		if(l==r) {sum[p] = maxv[p] = v; return ;}
		if(q<=mid) update(ls(p),l,mid,q,v);
		else update(rs(p),mid+1,r,q,v);
		push_up(p);
	}
}tree;
void add(int u,int v) {
	edge[++cnt].next = head[u];
	edge[cnt].to = v;
	head[u] = cnt;
}
void Dfs1(int p,int fa)
{
	f[p]=fa ,dep[p]=dep[fa]+1 ,size[p]=1;
	for(int i=head[p],v;i;i=edge[i].next) {
		if((v=edge[i].to) != fa) {
			Dfs1(v,p);
			size[p] += size[v];
			if(size[v] > size[son[p]])
				son[p] = v;
		}
	}
}
void Dfs2(int p,int t)
{
	top[p]=t ,id[p]=++num ,rk[num]=p;
	if(son[p]) Dfs2(son[p],t);
	for(int i=head[p],v;i;i=edge[i].next) {
		if((v=edge[i].to)!=f[p] && v!=son[p])
			Dfs2(v,v);
	}
}
int qsum(int x,int y)
{
	int res = 0;
	while(top[x] != top[y]) {
		if(dep[top[x]] < dep[top[y]]) swap(x,y);
		res += tree.Querysum(id[top[x]],id[x],1,1,n); 
		x = f[top[x]];
	}
	if(dep[x] > dep[y]) swap(x,y);
	return res += tree.Querysum(id[x],id[y],1,1,n); 
}
int qmax(int x,int y)
{
	int res = -INF;
	while(top[x] != top[y]) {
		if(dep[top[x]] < dep[top[y]]) swap(x,y);
		res = max(res,tree.Querymax(id[top[x]],id[x],1,1,n));
		x = f[top[x]];
	}
	if(dep[x] > dep[y]) swap(x,y);
	return res = max(res,tree.Querymax(id[x],id[y],1,1,n));
}
int main()
{
	scanf("%d",&n);
	for(int i=1,u,v;i<=n-1;++i) {
		scanf("%d%d",&u,&v);
		add(u,v) ,add(v,u);
	}
	for(int i=1;i<=n;++i)
		scanf("%d",&val[i]);
	Dfs1(1,0) ,Dfs2(1,1) ,tree.build(1,1,n);
	scanf("%d",&Q);
	while(Q--) {
		char s[10]; int x,y;
		cin>>s;
		scanf("%d%d",&x,&y);
		if(s[0] == 'C') tree.update(1,1,n,id[x],y);
		else if(s[1] == 'M') printf("%d\n",qmax(x,y));
		else printf("%d\n",qsum(x,y));
	}
	return 0;
}
```


---

## 作者：HenryHuang (赞：23)

## 大家好，我非常喜欢暴力数据结构，于是我用块状树过了这道题目

## [MY BLOG](https://www.cnblogs.com/HenryHuang-Never-Settle/p/10786200.html)

题目：

一棵树上有n个节点，编号分别为1到n，每个节点都有一个权值w。

我们将以下面的形式来要求你对这棵树完成一些操作：

I. CHANGE u t : 把结点u的权值改为t

II. QMAX u v: 询问从点u到点v的路径上的节点的最大权值

III. QSUM u v: 询问从点u到点v的路径上的节点的权值和

注意：从点u到点v的路径上的节点包括u和v本身

----

我们可以将树大约划分为$\sqrt{n}$块，每个块内维护到块内根节点的路径长度以及点权最大值，而且，显然，我们可以通过寻找它们的$LCA$来找到他们路径上的有关信息，而这里我们已经对树进行了分块。

所以在同一个块内的暴跳时间复杂度最坏为$O(\sqrt{n})$

在块与块之间的暴跳的时间复杂度最坏为$O(\sqrt{n})$

轻松AC本题目

代码中有较详细注释，贴代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
struct cc{
	int to,nex;
}e[maxn],dis[maxn];
int head[maxn],cnt1,h[maxn],cnt2;
void add1(int u,int v)//原树边 
{
	++cnt1;
	e[cnt1].to=v;
	e[cnt1].nex=head[u];
	head[u]=cnt1;
}
void add2(int u,int v)//分块后块内树边 
{
	++cnt2;
	dis[cnt2].to=v;
	dis[cnt2].nex=h[u];
	h[u]=cnt2;
}
int rt[maxn],mx[maxn],sum[maxn],siz[maxn];
int n,m,v[maxn],deep[maxn],len,fa[maxn];
void dfs(int u,int f,int dep)
{
	deep[u]=dep;
	int tmp=rt[u];
	fa[u]=f;
	for(int i=head[u];i;i=e[i].nex)
	{
		int v=e[i].to;
		if(v!=f)
		{
			if(siz[tmp]+1<len)
			{
				add2(u,v);//块内树连边 
				rt[v]=tmp;
				++siz[tmp];
			}
			dfs(v,u,dep+1);
		}
	}
}
void build(int u,int num,int vmx)//维护当前节点，到块内根节点的和，最大值
{
	num+=v[u],sum[u]=num;
	vmx=max(vmx,v[u]),mx[u]=vmx;
	for(int i=h[u];i;i=dis[i].nex)
		build(dis[i].to,num,vmx);
} 
int query(int a,int b,int tag)
{
	int ans1=0;//QSUM
	int ans2=-(1<<30);//QMAX
	while(a!=b)//类似于倍增，只不过这里的距离为sqrt(n) 
	{
		if(deep[a]<deep[b]) swap(a,b);
		if(rt[a]==rt[b])//若所属同一个块
		{
			ans1+=v[a];
			ans2=max(ans2,v[a]);
			a=fa[a];//由于在同一块内，暴力跳的复杂度只为O(sqrt(n)) 
		} 
		else
		{
			if(deep[rt[a]]<deep[rt[b]]) swap(a,b);//块的深度更深 
			ans1+=sum[a];
			ans2=max(ans2,mx[a]);
			a=fa[rt[a]];//直接跳一个块 
		}
	}
	ans1+=v[a];
	ans2=max(ans2,v[a]);//更新它们的LCA的值 
	if(tag==0) return ans2;
	else return ans1; 
} 
void change(int u,int x)
{
	v[u]=x;
	if(u==rt[u]) build(u,0,-(1<<30));//如果是块内根节点就整个块更新
	else build(u,sum[fa[u]],mx[fa[u]]);//如果不是，就从其父亲开始更新
}
int main()
{
	int x,y;
	scanf("%d",&n);
	len=sqrt(n);
	for(int i=1;i<n;++i)
		scanf("%d%d",&x,&y),add1(x,y),add1(y,x);//原树边 
	for(int i=1;i<=n;++i)
		scanf("%d",&v[i]),rt[i]=i;
	dfs(1,0,0);
	for(int i=1;i<=n;++i)
		if(rt[i]==i) 
			build(i,0,-(1<<30));
	scanf("%d",&m);
	char opt[30];
	for(int i=1;i<=m;++i)
	{
		scanf("%s%d%d",opt,&x,&y);
		if(opt[1]=='M')//QMAX
			printf("%d\n",query(x,y,0));//01维护询问问题 
		else if(opt[1]=='S')//QSUM
			printf("%d\n",query(x,y,1));//01维护询问问题 
		else //CHANGE 
			change(x,y);
	}
	return 0;
}

```

### 骗分过样例，暴力出奇迹！！！




---

## 作者：爷，无限霸气 (赞：12)

首先，学过树剖的都知道（~~虽然我没学过~~）树上操作用树剖解决应该是显然易见的吧，推荐几道好题[模板](https://www.luogu.org/problem/P3384)


AC此题后，心里慢慢的诉说

## 珍爱生命，远离树剖！

# 树剖

这是一种用来解决维护静态树上路径的问题（~~虽然码量很大~~）

基本问题：修改某条路径上的权值，询问某条路径所有点的权值和。

相信大家都学过线段树，在这里，线段树是此问题的特殊情况，想象一下这颗树是一条链

树链剖分，便是将树剖分成多条链，确定链后，就可以用线段树解决。

## 那让我们先了解一下树剖吧！

基本了解：重边轻边。

```cpp
          7
         / \
        4   2
       / \  / \
      1 2     1
       /
       1
```
在如上图中，7-4-2-1,2-1是重边。如果记size[x]为x点的子结点数的话，其重边所连儿子个数必大于此结点的1/2

接下来的预处理也变得尤为简单:

处理1：

计算size及重儿子。此时我们需要有father数组记录父结点，dep数组记录深度，son数组记录重儿子节点

那么由我们刚才的推论，算重儿子必然简单，只要将size一比较即可

### 注意！

每次预处理时需要初始化，dep要等于父结点的dep++。用每边遍历即可！

```cpp
void dfs1(ll u,ll f)
{
	ll e,v;
	size[u]=1;
	father[u]=f;
	dep[u]=dep[f]+1;
	for(e=first[u];v=go[e],e;e=next[e])
	 if(v!=f)
	 {
	 	dfs1(v,u);
	 	size[u]+=size[v];
	 	if(size[v]>size[son[u]]) son[u]=v;//重儿子，一比即可
	 }
}
```


处理2：

计算重路径：

重路径的开始的父结点必为轻边所连结点（如果是根就赋初值为0）

```cpp
void dfs2(ll u,ll f)
{
	ll e,v;
	if(son[u])//让重儿子不捣乱，位置连续
	{
		seg[son[u]]=++seg[0];
		top[son[u]]=top[u];
		rev[seg[0]]=son[u];
		dfs2(son[u],u);
	}
	for(e=first[u];v=go[e],e;e=next[e])
	 if(!top[v])
	 {
	 	seg[v]=++seg[0];
	 	rev[seg[0]]=v;
	 	top[v]=v;
	 	dfs2(v,u);
	 }
}
```

## 有了预处理，就可以开开心心的AC了啦！

[线段树模板](https://www.luogu.org/problem/P3373)

接下来转化的线段树，也已是我们所可以AC的。那么有了线段树的建树，查询，询问，就可以AC树剖！！！

若不懂线段树，这里给上代码（~~虽然这不是线段树题解~~）

```cpp
void build(ll k,ll l,ll r)//建树
{
	ll mid=l+r>>1;
	if(l==r)
	{
		Max[k]=sum[k]=num[rev[l]];//初始化
		return ;
	}
	build(k<<1,l,mid);//向左建树
	build((k<<1)+1,mid+1,r);//向右建树
	sum[k]=sum[k<<1]+sum[(k<<1)+1];//下传标记
	Max[k]=max(Max[k<<1],Max[(k<<1)+1]);
}
```

建树不懂得还可以搜百度哦！！！

```cpp
void ask(ll x,ll y)//路径询问！
{
	ll fx=top[x],fy=top[y];
	while(fx!=fy)
	{
		if(dep[fx]<dep[fy]) swap(x,y),swap(fx,fy);//感觉这句有点像LCA
		query(1,1,seg[0],seg[fx],seg[x]);
		x=father[fx];
		fx=top[x];
	}
	if(dep[x]>dep[y]) swap(x,y);
	query(1,1,seg[0],seg[x],seg[y]);//已经在了，不要搜了！！！
}
```

```cpp
void change(ll k,ll l,ll r,ll Val,ll pos)//区间修改！
{
	if(pos>r||pos<l) return ;
	if(l==r&&r==pos)
	{
		sum[k]=Val;
		Max[k]=Val;
		return ;
	}
	ll mid=l+r>>1;
	if(mid>=pos) change(k<<1,l,mid,Val,pos);
	if(mid+1<=pos) change((k<<1)+1,mid+1,r,Val,pos);
	sum[k]=sum[k<<1]+sum[(k<<1)+1];
	Max[k]=max(Max[k<<1],Max[(k<<1)+1]);
}
```


## 步入此题正解！！！

题目要求操作1

既然是CHANGE，我们只需判断第1个字符：change一下即可

操作2

既然是QMAX,我们判断第2个字符，ask一下，输出Maxx即可

操作3

和操作2类似，判断第2个字符，ask一下，输出Summ即可

# 此题居然被我AC了？？？


（~~虽然不是很相信~~）
但还是蒯一下代码吧？？？

```cpp
#include<bits/stdc++.h>
#define ll long long
#define next Next
using namespace std;
const int N=310000;
const int M=124000;
ll n,m,Summ,Maxx,seg[N],rev[M],size[N],son[N],top[N],dep[N],sum[M],num[N],father[N],Max[M],first[N],next[N],go[N];
void query(ll k,ll l,ll r,ll L,ll R)//区间询问 
{
	if(L>r||R<l) return ;
	if(L<=l&&r<=R)
	{
		Summ+=sum[k];
		Maxx=max(Maxx,Max[k]);
		return ;
	 } 
	ll mid=(l+r)>>1,res=0;
	if(mid>=L) query(k<<1,l,mid,L,R);
	if(mid+1<=R) query((k<<1)+1,mid+1,r,L,R);
}
void change(ll k,ll l,ll r,ll Val,ll pos)
{
	if(pos>r||pos<l) return ;
	if(l==r&&r==pos)
	{
		sum[k]=Val;
		Max[k]=Val;
		return ;
	}
	ll mid=l+r>>1;
	if(mid>=pos) change(k<<1,l,mid,Val,pos);
	if(mid+1<=pos) change((k<<1)+1,mid+1,r,Val,pos);
	sum[k]=sum[k<<1]+sum[(k<<1)+1];
	Max[k]=max(Max[k<<1],Max[(k<<1)+1]);
}
void dfs1(ll u,ll f)
{
	ll e,v;
	size[u]=1;
	father[u]=f;
	dep[u]=dep[f]+1;
	for(e=first[u];v=go[e],e;e=next[e])
	 if(v!=f)
	 {
	 	dfs1(v,u);
	 	size[u]+=size[v];
	 	if(size[v]>size[son[u]]) son[u]=v;
	 }
}
void dfs2(ll u,ll f)
{
	ll e,v;
	if(son[u])
	{
		seg[son[u]]=++seg[0];
		top[son[u]]=top[u];
		rev[seg[0]]=son[u];
		dfs2(son[u],u);
	}
	for(e=first[u];v=go[e],e;e=next[e])
	 if(!top[v])
	 {
	 	seg[v]=++seg[0];
	 	rev[seg[0]]=v;
	 	top[v]=v;
	 	dfs2(v,u);
	 }
}
void build(ll k,ll l,ll r)
{
	ll mid=l+r>>1;
	if(l==r)
	{
		Max[k]=sum[k]=num[rev[l]];
		return ;
	}
	build(k<<1,l,mid);
	build((k<<1)+1,mid+1,r);
	sum[k]=sum[k<<1]+sum[(k<<1)+1];
	Max[k]=max(Max[k<<1],Max[(k<<1)+1]);
}
ll read()
{
	ll r=0,f=1;char c=getchar();
	while((c<'0'||c>'9')&&(c!='-')) c=getchar();
	if(c=='-') f=-1,c=getchar();
	while(c>='0'&&c<='9') r=r*10+c-'0',c=getchar();
	return r*f;
}
ll tot;
void add(ll x,ll y)
{
	next[++tot]=first[x];
	first[x]=tot;
	go[tot]=y;
}
void insert(ll x,ll y)
{
	add(x,y);
	add(y,x);
}
void ask(ll x,ll y)
{
	ll fx=top[x],fy=top[y];
	while(fx!=fy)
	{
		if(dep[fx]<dep[fy]) swap(x,y),swap(fx,fy);
		query(1,1,seg[0],seg[fx],seg[x]);
		x=father[fx];
		fx=top[x];
	}
	if(dep[x]>dep[y]) swap(x,y);
	query(1,1,seg[0],seg[x],seg[y]);
}
int main()
{
	ll i,j,k;
	n=read();
	for(i=1;i<n;i++)
	{
		ll x=read(),y=read();
		insert(x,y);
	}
	for(i=1;i<=n;i++) num[i]=read();
	dfs1(1,0);
	seg[0]=seg[1]=top[1]=rev[1]=1;
	dfs2(1,0);
	build(1,1,seg[0]);
	m=read();                                   
	char sr[10];
	ll u,v;
	for(i=1;i<=m;i++)
	{
		scanf("%s",sr+1);
		u=read(),v=read();
		if(sr[1]=='C') change(1,1,seg[0],v,seg[u]);
		else
		{
			Summ=0;
			Maxx=-10000000;
			ask(u,v);
			if(sr[2]=='M') printf("%lld\n",Maxx);
			else printf("%lld\n",Summ);
		}
	}
	return 0;
}

```

后面感叹一下

# 树剖码量真大！！！

不嫌累的还可以做下这几道让我丧失自己自信心的题吧

[软件包树剖](https://www.luogu.org/problem/P2146)

[染色树剖](https://www.luogu.org/problem/P2486)

# 加油，让自己爆踩STD！！！

谢谢大家观看！

---

## 作者：老部长 (赞：9)

### **不得不说，树剖比线段树更烦人，但如果你掌握了线段树，这个过程还是会轻松一些**

没掌握的同学可以去看大佬博客，在这里安利我的[线段树翻车点](https://www.luogu.org/blog/lcx/guan-yu-xian-duan-shu)

## **照旧讲树链剖分翻车点**

1. 线段树的数组**开4倍**

2. 开**long long**（俗话说long long是100分与0分的分界线）

3. dfs1()与dfs2()在main函数中要**放在build()函数前**（~~浪费了我一上午~~），~~毕竟这是写给蒟蒻的~~

4. 当你编译器出现运行停止时，一般应为两点：
   
       (1)函数的出口不明确，注意是不是哪里少打了return；
       (2)调用函数时边界打错，导致函数卡死

5. 记得调用dfs1()，dfs2()和build()

6. 其余翻车点大多在线段树上，参考[线段树跳坑](https://www.luogu.org/blog/lcx/guan-yu-xian-duan-shu)

------------
题目传送门：[P2590 [ZJOI2008]树的统计](https://www.luogu.org/problem/P2590)

粘代码：

```cpp

#include<bits/stdc++.h>
#define ll long long
#define re register int
using namespace std;
const int maxn=30005;
const int inf=900000005;
inline ll read()
{
	ll x=0,f=1;char c=getchar();
	while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
	return x*f;
}

ll tot=0;
ll w[maxn],b[maxn],d[maxn],fa[maxn];
ll size[maxn],son[maxn],id[maxn],top[maxn];
struct node
{
	ll nex,to;
}e[maxn<<1];ll head[maxn<<1],cnt=0;
struct dd
{
	ll l,r,sum,maxx;
}t[maxn<<2];
inline void add(ll x,ll y)
{
	e[++cnt].to=y;
	e[cnt].nex=head[x];
	head[x]=cnt;
}
inline void dfs1(ll x,ll f,ll deep)
{
	size[x]=1;
	d[x]=deep;
	fa[x]=f;
	for(re i=head[x];i;i=e[i].nex)
	{
		ll y=e[i].to;
		if(y==f)continue;
		dfs1(y,x,deep+1);
		size[x]+=size[y];
		if(size[son[x]]<size[y])
		{
			son[x]=y;
		}
	}
	return;
}
inline void dfs2(ll x,ll top_)
{
	id[x]=++tot;
	b[tot]=w[x];
	top[x]=top_;
	if(!son[x])return;
	dfs2(son[x],top_);
	for(re i=head[x];i;i=e[i].nex)
	{
		ll y=e[i].to;
		if(!id[y])dfs2(y,y);
	}
	return;
}
inline void push_up(ll x)
{
	t[x].sum=t[x<<1].sum+t[x<<1|1].sum;
	t[x].maxx=max(t[x<<1].maxx,t[x<<1|1].maxx);
}
inline void build(ll x,ll l,ll r)
{
	t[x].l=l;t[x].r=r;
	if(l==r)
	{
		t[x].sum=b[l];
		t[x].maxx=b[l];
		return;//return不能少 
	}
	ll mid=(l+r)>>1;
	build(x<<1,l,mid);
	build(x<<1|1,mid+1,r);
	push_up(x);
	return;
}
inline void tree_change(ll x,ll l,ll r,ll q,ll v)//单点修改 
{
	if(l==r)
	{
		t[x].sum=t[x].maxx=v;
		return;//return不能少 
	}
	ll mid=(l+r)>>1;
	if(q<=mid)tree_change(x<<1,l,mid,q,v);
	else tree_change(x<<1|1,mid+1,r,q,v);
	push_up(x);
}
inline ll querysum(ll x,ll l,ll r)//求新序列 l到r 的区间和 
{
	ll ans=0;
	if(l<=t[x].l&&r>=t[x].r)
	{
		return t[x].sum;//return不能少 
	}
	ll mid=(t[x].l+t[x].r)>>1;
	if(l<=mid)ans+=querysum(x<<1,l,r);
	if(r>mid)ans+=querysum(x<<1|1,l,r);
	//push_up(x);
	return ans;
}
inline ll querymax(ll x,ll l,ll r)//求新序列 l到r 的区间最大值 
{
	ll ans=-inf;
	if(l<=t[x].l&&r>=t[x].r)return t[x].maxx;//return不能少 
	ll mid=(t[x].l+t[x].r)>>1;
	if(l<=mid)ans=max(ans,querymax(x<<1,l,r));
	if(r>mid)ans=max(ans,querymax(x<<1|1,l,r));
	//push_up(x);
	return ans;
}
inline ll tree_sum(ll u,ll v)//求树上节点 u到v 的简单路径节点权值和 
{
	ll ans=0;
	while(top[u]!=top[v])
	{
		if(d[top[u]]<d[top[v]])swap(u,v);
		ans+=querysum(1,id[top[u]],id[u]);
		u=fa[top[u]];
	}
	if(d[u]>d[v])swap(u,v);
	ans+=querysum(1,id[u],id[v]);
	return ans;
}
inline ll tree_max(ll u,ll v)//求树上节点 u到v 的简单路径节点权值最大值
{
	ll ans=-inf;
	while(top[u]!=top[v])
	{
		if(d[top[u]]<d[top[v]])swap(u,v);
		ans=max(ans,querymax(1,id[top[u]],id[u]));
		u=fa[top[u]];
	}
	if(d[u]>d[v])swap(u,v);
	ans=max(ans,querymax(1,id[u],id[v]));
	return ans;
}
ll n,m;
int main()
{
	n=read();
	int x,y;
	for(re i=1;i<n;i++)
	{
		x=read();y=read();
		add(x,y);add(y,x);
	}
	for(re i=1;i<=n;i++)w[i]=read();
	dfs1(1,0,1);//注意先后顺序 
	dfs2(1,1);//注意先后顺序 
	build(1,1,n);//注意先后顺序 
	m=read();
	for(re i=1;i<=m;i++)
	{
		char cxk[10];
		cin>>cxk;
		x=read();y=read();
		if(cxk[1]=='H')
		{
			tree_change(1,1,n,id[x],y);
		}
		else if(cxk[1]=='M')
		{
			printf("%lld\n",tree_max(x,y));
		}
		else if(cxk[1]=='S')
		{
			printf("%lld\n",tree_sum(x,y));
		}
	}
	return 0;
}
```


---

## 作者：hicc0305 (赞：8)

哈哈哈哈哈哈哈，蒟蒻居然过了树剖，哈哈哈哈哈啊哈，嗝~

那么请开始我的树剖

------------


首先上定义：

定义siz(x)为以x为根的子树的结点个数。

令v为u的儿子结点中siz()值最大的结点：

重结点：子树结点数目最多的结点

轻节点：父亲节点中除了重结点以外的结点

重边：父亲结点和重结点连成的边，即边(u,v)

轻边：重边之外的边

重链：由多条重边连接而成的路径

轻链：由多条轻边连接而成的路径

一个非叶节点有且仅有一个重儿子

![](https://cdn.luogu.com.cn/upload/pic/19692.png)

加粗的链就是重链，注意4，7，8这三个点也是重链

------------
那么再上一堆数组：

siz[i]以i为根结点的子树中结点的数目

hson[i]结点i的重儿子的编号

dep[i]结点i的深度，根的深度为1

top[i]结点i所在的重链的链首结点编号

fa[i]结点i的父结点编号

tid[i]结点i剖分以后的新编号（dfs2序号）

rnk[i]结点i在树中的原位置：i为新编号，rnk[i]为原编号

------------
那么怎么求这些数组呢？

DFS1找重边 顺便求出siz[i],dep[i],fa[i],hson[i]

DFS2将重边连成重链 顺便求出top[i],tid[i]，说的dfs2序号就是dfs序啦

![](https://cdn.luogu.com.cn/upload/pic/19693.png)

橙色的是原序号，绿色的是dfs序，注意，我们先走重儿子，连成重链，让一个重链中的数dfs全部连在一起，这样就为我们后面的线段树维护做了铺垫

![](https://cdn.luogu.com.cn/upload/pic/19694.png)

这样清楚一点

------------
现在是线段树维护部分

我们已经把树处理成了线性，那么我们就可以用线段树维护了

如果要求i~j的最大值，如果i和j在同一个重链中，我们就直接输出max（tid[i]~tid[j]），而如果不在同一个重链中，我们就让深度大的那一个爬树，爬到它的top，求出其中的最大值，直到两个数在同一重链中，我们再求一下取个max就可以输出了

那为什么不可以直接线段树呢？当然是因为不同重链并不一定不连续

至于修改的话，正常线段树修改就行了

------------
那么，代码时间
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int n,cnt=0;
int a[300100],f[300100];
int head[300100],nxt[300100],to[300100];
int siz[300100],d[300100],hs[300100];
int top[300100],ran[300100],tid[300100];
int sum[300100],ma[300100];
void addedge(int x,int y,int cn)
{
	nxt[cn]=head[x];
	head[x]=cn;
	to[cn]=y;
}
void dfs1(int u,int fa)
{
	f[u]=fa,siz[u]=1;//求出fa，size，dep，hson
	for(int i=head[u];i!=-1;i=nxt[i])
	{
		int v=to[i];
		if(v==fa) continue;
		d[v]=d[u]+1;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[v]>siz[hs[u]]) hs[u]=v;
	}
}
void dfs2(int u,int h)
{
	top[u]=h,tid[u]=++cnt,ran[cnt]=u;//求出top，tid，rank
	if(!hs[u]) return;//重边走到头return
	dfs2(hs[u],h);//先走重边
	for(int i=head[u];i!=-1;i=nxt[i])
	{
		int v=to[i];
		if(v==f[u] || v==hs[u]) continue;
		dfs2(v,v);
	}
}
void build(int l,int r,int x)//建树
{
	if(l==r)
	{
		sum[x]=ma[x]=a[ran[l]];
		return;
	}
	int mid=(l+r)/2;
	build(l,mid,x*2);
	build(mid+1,r,x*2+1);
	sum[x]=sum[x*2]+sum[x*2+1];
	ma[x]=max(ma[x*2],ma[x*2+1]);
}
void Change(int l,int r,int x,int u,int v)//线段树修改
{
	if(l==r)
	{
		ma[x]=sum[x]=v;
		return;
	}
	int mid=(l+r)/2;
	if(u<=mid) Change(l,mid,x*2,u,v);
	else Change(mid+1,r,x*2+1,u,v);
	sum[x]=sum[x*2]+sum[x*2+1];
	ma[x]=max(ma[x*2],ma[x*2+1]);
}
int Clacm(int l,int r,int x,int L,int R)
{
	if(L<=l && R>=r) return ma[x];
	int mid=(l+r)/2;
	if(R<=mid) return Clacm(l,mid,x*2,L,R);
	else if(L>mid) return Clacm(mid+1,r,x*2+1,L,R);
	else return max(Clacm(l,mid,x*2,L,R),Clacm(mid+1,r,x*2+1,L,R));
}
int Querym(int l,int r,int x,int u,int v)//max查询
{
	int ans=-1000000000;//注意权值有负数，赋个负无穷
	while(top[u]!=top[v])//不在同一重链中，爬树
	{
        if(d[top[u]]<d[top[v]]) swap(u,v);
        ans=max(ans,Clacm(1,n,1,tid[top[u]],tid[u]));//深度大的那个爬到top，同时取u~top[u]的最大值max一下
        u=f[top[u]];
    }
    if(d[u]<d[v]) swap(u,v);
    ans=max(ans,Clacm(1,n,1,tid[v],tid[u]));//同一重链直接线段树求max
    return ans;
}
int Clacs(int l,int r,int x,int L,int R)
{
	if(L<=l && R>=r) return sum[x];
	int mid=(l+r)/2;
	if(R<=mid) return Clacs(l,mid,x*2,L,R);
	else if(L>mid) return Clacs(mid+1,r,x*2+1,L,R);
	else return Clacs(l,mid,x*2,L,R)+Clacs(mid+1,r,x*2+1,L,R);
}
int Querys(int l,int r,int x,int u,int v)//sum同理
{
	int ans=0;
	while(top[u]!=top[v])
	{
        if(d[top[u]]<d[top[v]]) swap(u,v);
        ans+=Clacs(1,n,1,tid[top[u]],tid[u]);
        u=f[top[u]];
    }
    if(d[u]<d[v]) swap(u,v);
    ans+=Clacs(1,n,1,tid[v],tid[u]);
    return ans;
}
int main()
{
	memset(hs,0,sizeof(hs));
	memset(head,-1,sizeof(head));
	scanf("%d",&n);
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		addedge(x,y,i*2-1);
		addedge(y,x,i*2);
	}
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	d[1]=1,dfs1(1,1),dfs2(1,1);
	build(1,n,1);
	char tmp[10];
	int m,x,y;
	scanf("%d",&m);
	while(m--)
	{
		scanf("%s%d%d",tmp,&x,&y);
		if(tmp[0]=='C') Change(1,n,1,tid[x],y);
		else if(tmp[1]=='M') printf("%d\n",Querym(1,n,1,x,y));
		else printf("%d\n",Querys(1,n,1,x,y));
	}
	return 0;
}
```



---

## 作者：Treaker (赞：4)

## 一个树剖题。

我们可以对于线段树的每一个节点，维护一下他的总和 与 最大值 即可

还是比较裸的（~~一眼树剖全是板子~~）

这里采用数组写法，指针写法详见[我博客](https://www.luogu.org/blog/Treaker/#)其他树剖题。

顺便推荐做一下模板[【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)  

完整代码如下：
```cpp
#include <cstdio>
#include <iostream>
using namespace std;
const int N = 30030;
int ls(int x) {return x << 1;}
int rs(int x) {return x << 1 | 1;}
int n , m , cnt;
int head[N] , dep[N] , dfn[N] , id[N] , hs[N] , fa[N] , top[N] , w[N] , sum[N << 2] , maxn[N << 2] , size[N];
char s[10];
struct Edge // 链式前向星
{
	int to , nxt;
}e[N << 1];
void add(int from,int to) // 加边
{
	e[++cnt] = (Edge){to,head[from]};
	head[from] = cnt;
}
void get_tree(int now) //建树
{
	size[now] = 1;
	for(int i = head[now] , to;i;i = e[i].nxt)
	{
		to = e[i].to;
		if(dep[to])	continue;
		fa[to] = now;
		dep[to] = dep[now] + 1;
		get_tree(to);
		size[now] += size[to];
		if(size[to] > size[hs[now]])	hs[now] = to;
	}
}
void dfs(int now,int topfa)
{
	dfn[now] = ++cnt;
	id[cnt] = now;
	top[now] = topfa;
	if(hs[now])	dfs(hs[now],topfa);
	for(int i = head[now] , to;i;i = e[i].nxt)
	{
		to = e[i].to;
		if(to == fa[now] || to == hs[now])	continue;
		dfs(to,to);
	}
}
void build(int p,int l,int r)
{
	if(l == r)
	{
		maxn[p] = sum[p] = w[id[l]];
		return ; 
	}
	int mid = (l + r) >> 1;
	build(ls(p),l,mid);
	build(rs(p),mid+1,r);
	sum[p] = sum[ls(p)] + sum[rs(p)];
	maxn[p] = max(maxn[ls(p)],maxn[rs(p)]);
}
void chenge(int p,int l,int r,int x,int k)
{
	if(l == r)	
	{
		sum[p] = k;
		maxn[p] = k;
		return;
	}
	int mid = (l + r) >> 1;
	if(x <= mid)	chenge(ls(p),l,mid,x,k);
	else	chenge(rs(p),mid+1,r,x,k);
	sum[p] = sum[ls(p)] + sum[rs(p)];
	maxn[p] = max(maxn[ls(p)],maxn[rs(p)]);
}
int query_sum(int p,int l,int r,int x,int y)
{
	if(x <= l && r <= y)	return sum[p];
	int res = 0;
	int mid = (l + r) >> 1;
	if(x <= mid)	res = res + query_sum(ls(p),l,mid,x,y);
	if(y > mid)		res = res + query_sum(rs(p),mid+1,r,x,y);
	return res;
}
int query_max(int p,int l,int r,int x,int y)
{
	if(x <= l && r <= y)	return maxn[p];
	int res = -2147483647;
	int mid = (l + r) >> 1;
	if(x <= mid)	res = max(res,query_max(ls(p),l,mid,x,y));
	if(y > mid)		res = max(res,query_max(rs(p),mid+1,r,x,y));
	return res;
}
int slove1(int x,int y)
{
	int res = 0;
	while(top[x] != top[y])
	{
		if(dep[top[x]] < dep[top[y]])	swap(x,y);
		res = res + query_sum(1,1,n,dfn[top[x]],dfn[x]);
		x = fa[top[x]];
	}
	if(dep[x] < dep[y])	swap(x,y);
	res = res + query_sum(1,1,n,dfn[y],dfn[x]);
	return res;
}
int slove2(int x,int y)
{
	int res = -2147483647;
	while(top[x] != top[y])
	{
		if(dep[top[x]] < dep[top[y]])	swap(x,y);
		res = max(res , query_max(1,1,n,dfn[top[x]],dfn[x]));
		x = fa[top[x]];
	}
	if(dep[x] < dep[y])	swap(x,y);
	res = max(res , query_max(1,1,n,dfn[y],dfn[x]));
	return res;
}
int main()
{
	scanf("%d",&n);
	for(int i = 1 , a , b;i < n;i ++)
	{
		scanf("%d%d",&a,&b);
		add(a,b);add(b,a);
	}
	for(int i = 1;i <= n;i ++)	scanf("%d",&w[i]);
	cnt = 0;
	dep[1] = 1;
	get_tree(1);
	dfs(1,1);
	build(1,1,n);
	scanf("%d",&m);
	for(int i = 1 , u , v;i <= m;i ++)
	{
		scanf("%s%d%d",s,&u,&v);
		if(s[1] == 'H')	chenge(1,1,n,dfn[u],v);
		else	if(s[1] == 'S')	printf("%d\n",slove1(u,v));
		else	printf("%d\n",slove2(u,v));
	}
	return 0;
}
```


---

## 作者：SNiFe (赞：4)

题解写的不好，dalao勿喷！！！！！！！！！

建议有一点数剖基础的看此题解，这是一道树剖模板题，可以用来练练手。

###一.首先我先讲讲书剖部分思想：

![1](https://p1.ssl.qhmsg.com/dr/270\_500\_/t016907872b80ef36c1.jpg)

1.将一棵树划分成若干条链，用数据结构（线段树）去维护每条链，复杂度为O(logN)；

2.**核心数组：**

siz[x]数组，用来保存以x为根的子树节点个数；

top[ ]数组，用来保存当前节点的所在链的顶端节点；

son[ ]数组，用来保存重儿子；

dep[ ]数组，用来保存当前节点的深度；

fa[ ]数组，用来保存当前节点的父亲；

tid[ ]数组，用来保存树中每个节点剖分后的新编号；

pos[ ]数组，用来保存当前节点在线段树中的位置；

3.先是两个dfs，分别求出fa、dep、siz、son和top、pos、tid；

4.线段树操作；

###二.此题思路：

1.此题是单点修改，区间求值，所以线段树操作较为简单；

2.只是查找sum和max时需各写一个函数，两函数差异不大；

###三.上代码：

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<iostream> 
#define ls id<<1
#define rs id<<1|1
using namespace std;
const int N=100010;
int pos[N],deep[N],tid[N],son[N],top[N],size[N],fa[N];
int k=0,head[N],tim=0;
long long begi[N];
struct node{int to,next;}edge[N*4];
struct tree
{
    int left,right,maxn;
    long long sum;
}tree[N*4];
void add(int u,int v){edge[++k].next=head[u];edge[k].to=v;head[u]=k;}
void dfsfir(int u,int father,int dep)
{
    fa[u]=father;deep[u]=dep;size[u]=1;
    for(int i=head[u];i;i=edge[i].next)
    {
        int v=edge[i].to;
        if(v!=father)
        {
            dfsfir(v,u,dep+1);
            size[u]+=size[v];
            if(son[u]==0||size[v]>size[son[u]])son[u]=v;
        }
    }
}
void dfsec(int u,int tp)
{
    top[u]=tp;
    tid[u]=++tim;
    pos[tid[u]]=u;
    if(son[u]==0)return;
    dfsec(son[u],tp);
    for(int i=head[u];i;i=edge[i].next)
    {
        int v=edge[i].to;
        if(v!=fa[u]&&v!=son[u])dfsec(v,v);
    }
}
void built(int id,int l,int r)
{
    tree[id].left=l;tree[id].right=r;
    if(l==r)
    {
        tree[id].maxn=tree[id].sum=begi[pos[l]];
        return;
    }
    int mid=(l+r)>>1;
    built(ls,l,mid);built(rs,mid+1,r);
    tree[id].sum=(tree[ls].sum+tree[rs].sum);
    tree[id].maxn=max(tree[ls].maxn,tree[rs].maxn);
}
void update(int id,int l,int r,int w)//修改
{
    if(tree[id].left>r||tree[id].right<l)return;
    if(tree[id].left==tree[id].right)
    {
        tree[id].sum=w;
        tree[id].maxn=w;
        return;
    }
    update(ls,l,r,w);
    update(rs,l,r,w);
    tree[id].sum=(tree[ls].sum+tree[rs].sum);
    tree[id].maxn=max(tree[ls].maxn,tree[rs].maxn);
}
long long getsum(int id,int l,int r)
{
    if(tree[id].left>r || tree[id].right<l)return 0;
    if(tree[id].left>=l && tree[id].right<=r)return tree[id].sum;
    return (getsum(id*2,l,r)+getsum(id*2+1,l,r));
}
long long getmax(int id,int l,int r)
{
    int ans=-1e9;
    if(tree[id].left>r || tree[id].right<l)return -1e9;
    if(tree[id].left>=l && tree[id].right<=r)return max(ans,tree[id].maxn);
    return max(getmax(id*2,l,r),getmax(id*2+1,l,r));
}
long long find(int x,int y)
{
    long long sum=0;
    int fx,fy;
    fx=top[x];fy=top[y];
    while(fx!=fy)//不在一条重链上，即非连续一段区间 
    {
        if(deep[fx]<deep[fy])
        {
            swap(fx,fy);swap(x,y);
        }
        sum=(sum+getsum(1,tid[fx],tid[x]));
        x=fa[fx];fx=top[x];
    }
    if(deep[x]>deep[y]) swap(x,y);//同一条重链 
    return sum=(sum+getsum(1,tid[x],tid[y]));
}
long long findmax(int x,int y)
{
    int fx,fy;
    long long ans=-1e9;
    fx=top[x];fy=top[y];
    while(fx!=fy)//不在一条重链上，即非连续一段区间 
    {
        if(deep[fx]<deep[fy])
        {
            swap(fx,fy);swap(x,y);
        }
        ans=max(ans,getmax(1,tid[fx],tid[x]));
        x=fa[fx];fx=top[x];
    }
    if(deep[x]>deep[y]) swap(x,y);//同一条重链
    return max(ans,getmax(1,tid[x],tid[y]));
}
int main()
{
    int n,m,r;
    scanf("%d",&n);
    for(int i=1;i<=n-1;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        add(u,v);add(v,u);
    }
    for(int i=1;i<=n;i++)scanf("%lld",&begi[i]);
    scanf("%d",&m);
    dfsfir(1,0,1);
    dfsec(1,1);
    built(1,1,tim);
    int x,y,z;
    string mode;
    for(int i=1;i<=m;i++)
    {
        cin>>mode;
        if(mode=="QSUM")
        {
            scanf("%d%d",&x,&y);
            printf("%lld\n",find(x,y));
        }
        else if(mode=="CHANGE")
        {
            scanf("%d%d",&x,&z);
            update(1,tid[x],tid[x],z);
        }
        else if(mode=="QMAX")
        {
            scanf("%d%d",&x,&y);
            printf("%lld\n",findmax(x,y));
        }
    }
    return 0;
}
写的不好，dalao勿喷！！！！！！！！！QAQ
```

---

## 作者：中二病 (赞：3)

本蒟蒻的第一个树剖题  
来一个vector的题解（因为vector好写啊哈哈哈）  
这个题是单点修改区间查询，为什么要用线段树？  
~~但我不会用树状数组求区间最值，所以还是线段树吧~~   
~~真香~~  
#### 树链剖分
把一棵树上的链分成轻链和重链，一个根节点到其节点数最大的子树的链叫重链，其他的叫轻链。特别的，任意一个单独的点也是一个重链。  
然后用线段树处理所有点，要把在同一条重链上的点放在一起，以便以后查询的时候使用区间查询。  
查询的时候从较深的那个点往上跳，跳的时候更新答案，一直跳到两个点在同一条重链上，用线段树区间查询（是不是很形象）。  
然后还有一个问题，就是这个树并没有给出明确的根节点，那就可以在建图的时候双向建边，然后遍历的时候记录父节点就好了，这是处理与树有关的问题时的常见做法。  
然后就是预处理了，需要进行2遍dfs，在dfs时要维护以下几个量：  
father 这个点的父节点  
dep 这个点在树中的深度  
size 以这个点为根的子树的节点个数  
son 这个点的重链的儿子  
seg 这个点在线段树中对应的编号（要注意在同一条重链上的点在线段树中的编号要挨在一起，形成一段区间）  
rev 线段树中的编号对应的点  
top 这个点所在重链的最顶上的点，感觉就像并查集，用最顶上的点来代表这条链（反正我这么感觉，应该更好理解）  
前4个量在第一遍dfs时可以求出，后3个量在第二遍dfs时求出  
就这些细节了，至于和线段树有关的知识去看线段树的模板题  
欸？怎么才10分？  
原来点还有负权，在用线段树求解时要把初始值设成一个很小的负数  
贴代码
```
#include<iostream>
#include<cstdio>
#include<queue>
#include<algorithm>
#include<vector> 
#include<cstring>
using namespace std;
const int N=100005;
const int M=4*N;
vector <int> edge[N];
int father[N],dep[N],size[N],son[N],top[N],seg[N],rev[M];
int sum[M],Max[N],w[N];
int n,x,y,q;
string str;
int left(int zy)
{
	return zy<<1;
}
int right(int zy)
{
	return zy<<1|1;
}
void dfs1(int u,int fa)
{
	int v;
	size[u]=1;
	father[u]=fa;
	dep[u]=dep[fa]+1;
	for(int i=0;i<edge[u].size();i++)
	{
		if(edge[u][i]!=fa)
		{
			v=edge[u][i];
			dfs1(v,u);
			size[u]+=size[v];
			if(size[v]>size[son[u]])
				son[u]=v;
		}
	}
}
void dfs2(int u,int fa)
{
	int v;
	seg[u]=++seg[0];rev[seg[0]]=u;top[u]=top[fa];
	if(son[u])
		dfs2(son[u],u);
	for(int i=0;i<edge[u].size();i++)
	{
		v=edge[u][i];
		if(!seg[v])
		dfs2(v,v);
	}
}
void push_up(int zy)
{
	sum[zy]=sum[left(zy)]+sum[right(zy)];
	Max[zy]=max(Max[left(zy)],Max[right(zy)]);
}
void build(int l,int r,int zy)
{
	if(l==r)
	{
		Max[zy]=sum[zy]=w[rev[l]];
	}
	else
	{
		int mid=(l+r)>>1;
		build(l,mid,left(zy));
		build(mid+1,r,right(zy));
		push_up(zy);
	}
}
void change(int zy,int q,int l,int r,int k)
{
	int mid=(l+r)>>1;
	if(l==r)sum[zy]=Max[zy]=k;
	else
	{
		if(q<=mid)change(left(zy),q,l,mid,k);
		else change(right(zy),q,mid+1,r,k);
		push_up(zy);
	}
}
int check_sum(int zy,int l,int r,int nl,int nr)
{
	int ans=0;
	if(nl<=l&&nr>=r)
	{
		return sum[zy];
	}
	else
	{
		int mid=(l+r)>>1;
		if(nl<=mid)ans+=check_sum(left(zy),l,mid,nl,nr);
		if(nr>mid)ans+=check_sum(right(zy),mid+1,r,nl,nr);
		return ans;
	}
}
int check_max(int zy,int l,int r,int nl,int nr)
{
	int ans=-4*N;
	if(nl<=l&&nr>=r)
	{
		return Max[zy];
	}
	else
	{
		int mid=(l+r)>>1;
		if(nl<=mid)ans=max(ans,check_max(left(zy),l,mid,nl,nr));
		if(nr>mid)ans=max(ans,check_max(right(zy),mid+1,r,nl,nr));
		return ans;
	}
}
int q_sum(int u,int v)
{
	int ans=0;
	int fu=top[u],fv=top[v];
	while(fu!=fv)
	{
		if(dep[fu]<dep[fv])
		{
			swap(u,v);
			swap(fu,fv);
		}
		ans+=check_sum(1,1,n,seg[fu],seg[u]);
		u=father[fu];fu=top[u];
	}
	if(dep[u]>dep[v])swap(u,v);
	ans+=check_sum(1,1,n,seg[u],seg[v]);
	return ans;
}
int q_max(int u,int v)
{
	int ans=-4*N;
	int fu=top[u],fv=top[v];
	while(fu!=fv)
	{
		if(dep[fu]<dep[fv])
		{
			swap(u,v);
			swap(fu,fv);
		}
		ans=max(ans,check_max(1,1,n,seg[fu],seg[u]));
		u=father[fu];fu=top[u];
	}
	if(dep[u]>dep[v])swap(u,v);
	ans=max(ans,check_max(1,1,n,seg[u],seg[v]));
	return ans;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n-1;i++)
	{
		scanf("%d%d",&x,&y);
		edge[x].push_back(y);
		edge[y].push_back(x);
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&w[i]);
	}
	for(int i=1;i<=n;i++)
	top[i]=i;
	scanf("%d",&q);
	dfs1(1,0);
	dfs2(1,1);
	build(1,n,1);
	for(int i=1;i<=q;i++)
	{
		cin>>str;
		scanf("%d%d",&x,&y);
		if(str=="CHANGE")
		{
			change(1,seg[x],1,seg[0],y);
		}
		if(str=="QMAX")
		{
			printf("%d\n",q_max(x,y));
		}
		if(str=="QSUM")
		{
			printf("%d\n",q_sum(x,y));
		}
	}
	return 0;
}
```

---

## 作者：Isonan (赞：3)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P2590)

最近打多了LCT果然是有好处的。

此题是LCT裸题，套用LCT模板像我这样的蒟蒻花了17分钟也打出来了。

这道题只需要link操作和链求和就可以了。

注意要先读入value再建边！还有刚开始mx数组需要置为极小值！！

代码如下：

```cpp
#include <cstdio>
#include <cstring>

int max(int a,int b){
    return a>b?a:b;
}
int fa[30001],ch[30001][2],val[30001],tot[30001],mx[30001],n,a[30001],b[30001],q;
bool lazy[30001];
char cha[101];
void pushup(int x){
    tot[x]=tot[ch[x][0]]+tot[ch[x][1]]+val[x];
    mx[x]=max(max(mx[ch[x][0]],mx[ch[x][1]]),val[x]);
}
bool son(int x){return ch[fa[x]][1]==x;}
bool isroot(int x){return ch[fa[x]][1]!=x&&ch[fa[x]][0]!=x;}
void Rotate(int x){
    if(isroot(x)||!x||!fa[x])return;
    int faz=fa[x],fazz=fa[faz],g=son(x);
    fa[x]=fazz;
    if(!isroot(faz))ch[fazz][son(faz)]=x;
    fa[ch[x][!g]]=faz;
    ch[faz][g]=ch[x][!g];
    fa[faz]=x;
    ch[x][!g]=faz;
    pushup(faz);
    pushup(x);
}
void clean(int x){
    if(!isroot(x))clean(fa[x]);
    if(!lazy[x])return;
    int tem=ch[x][0];
    ch[x][0]=ch[x][1];
    ch[x][1]=tem;
    lazy[ch[x][0]]^=1;
    lazy[ch[x][1]]^=1;
    lazy[x]=0;
}
void splay(int x){
    clean(x);
    while(!isroot(x)){
        if(!isroot(fa[x]))
            if(son(x)^son(fa[x]))Rotate(x);
            else Rotate(fa[x]);
        Rotate(x);
    }
}
void access(int x){
    for(int y=0;x;y=x,x=fa[x])
        splay(x),ch[x][1]=y,pushup(x);
}
void mroot(int x){
    access(x);
    splay(x);
    lazy[x]^=1;
}
void link(int x,int y){
    mroot(x);
    fa[x]=y;
}
void split(int x,int y){
    mroot(x);
    access(y);
    splay(y); 
}
int main(){
    memset(mx,-0x7f7f7f7f,sizeof mx);
    scanf("%d",&n);
    for(int i=1;i<n;i++)scanf("%d%d",a+i,b+i);
    for(int i=1;i<=n;i++)scanf("%d",val+i);
    for(int i=1;i<n;i++)link(a[i],b[i]);
    scanf("%d",&q);
    for(int i=1;i<=q;i++){
        scanf("%s%d%d",cha,&a[0],&a[1]);
        if(cha[0]=='C'){
            access(a[0]);
            splay(a[0]);
            val[a[0]]=a[1];
        }
        else if(cha[1]=='M'){
            split(a[0],a[1]);
            printf("%d\n",mx[a[1]]);
        }
        else{
            split(a[0],a[1]);
            printf("%d\n",tot[a[1]]);
        }
    }
}
```

---

## 作者：盧鋅 (赞：2)

### 这是一篇蒟蒻的LCT题解

------------

##### Link Cut Tree（动态树），~~一种基础的数据结构~~，又名树链剖分PLUS

------------
先说下LCT的基本操作

（LINK,CUT,FINDROOT在本题中可以不用）

ACCESS（打通一个点到根的路径）
```cpp
inline void access(int o){
        int last=0;
        while(o){
            splay(o);
            rs=last;
            pushup(o);
            last=o;
            o=tr[o].parent;
        }
        return;
    }
```
MAKEROOT（使一个点做根）
```cpp
inline void makeroot(int o){
        access(o);
        splay(o);
        pushr(o);
        return;
    }
```
SPILT（连一条x，y的边）
```cpp
inline void spilt(int x,int y){
        makeroot(x);
        access(y);
        splay(y);
    }
```
------------
然后说一下本题需要用的操作
```
    inline int query_sum(int x,int y){
        return spilt(x,y),tr[y].summ;
    }
    inline int query_max(int x,int y){
        return spilt(x,y),tr[y].maxx;
    }
    inline void modify(int o,int v){
        access(o),splay(o),tr[o].v=v,pushup(o);
        return;
    }
```
------------
然后连边：
```cpp
struct EDGE{
    struct{
        int nxt,to;
    }e[maxn];
    int first[maxn];
    #define add(a,b)e[++cnt].nxt=first[a],first[a]=cnt,e[cnt].to=b
    inline void connect(int a,int b){
        add(a,b),add(b,a);
    }
}E;
void dfs(int u){
    for(register int ee=E.first[u],v;v=E.e[ee].to,ee;ee=E.e[ee].nxt)
        if(v!=L.tr[u].parent)
            L.tr[v].parent=u,dfs(v);
    return;
}
```
------------
卡常的快读和快写：
```cpp
namespace IO{
    char buf[1<<21],*pa=buf,*pb=buf;
    #define gc() (pa==pb&&(pb=(pa=buf)+fread(buf,1,1<<21,stdin),pa==pb)?EOF:*pa++)
    template<class T>inline void read(T &x){
        x=0;
        register int y=0;register char ch=gc();
        for(;!isdigit(ch);ch=gc())if(ch=='-')y=1;
        for(;isdigit(ch);ch=gc())x=(x<<3)+(x<<1)+(ch^48);
        (y)&&(x=-x);
        return;
    }
    inline int readt(){
        register char ch=gc();
        for(;!isalpha(ch);ch=gc());//isalpha返回ch是否为字母
        if(ch=='Q'){
            ch=gc();
            if(ch=='M')return 1;
            else return 2;
        }
        if(ch=='C'){
            return 3;
        }
        return 0;
    }
    char buffer[1<<21];
    int p1=-1;const int p2=(1<<21)-1;
    inline void flush(){
        fwrite(buffer,1,p1+1,stdout);
        p1=-1;
        return;
    }
    inline void pc(int x){
        if(p1==p2)flush();
        buffer[++p1]=x;
        return;
    }
    template<class T>inline void write(T x){
        static char buf[20];
        static int len=-1;
        if(x>=0){
            do{
                buf[++len]=(x%10)^48,x/=10;
            }while(x);
        }else{
            pc('-');
            do{
                buf[++len]=(-(x%10)^48),x/=10;
            }while(x);
        }
        while(len>=0)pc(buf[len--]);
        return;
    }
}
using IO::read;
using IO::readt;
using IO::write;
using IO::pc;
using IO::flush;
```


------------
然后合起来不就AC了
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cctype>
#define local
#define maxn 500000
using namespace std;
int cnt=0;
//namespace IO省略
struct LCT{
    #define ls tr[o].child[0]
    #define rs tr[o].child[1]
    #define MAX(a,b,c) max(max(a,b),c)
    struct luna{
        int parent,child[2],maxx,summ,v;
        bool rev;
    }tr[maxn];
    int st[maxn],top;
    inline bool identify(int o){//判断位置
        return tr[tr[o].parent].child[1]==o;
    }
    inline bool nroot(int o){//判断是否为根
        return tr[tr[o].parent].child[1]==o||tr[tr[o].parent].child[0]==o;
    }
    inline void pushup(int o){//日常pushup
        tr[o].maxx=MAX(tr[ls].maxx,tr[rs].maxx,tr[o].v);
        tr[o].summ=tr[ls].summ+tr[rs].summ+tr[o].v;
        return;
    }
    inline void connect(int o,int pa,bool flag){//连边
        tr[o].parent=pa;
        tr[pa].child[flag]=o;
        return;
    }
    inline void pushr(int o){//翻转
        swap(ls,rs);
        tr[o].rev^=1;
        return;
    }
    inline void pushdown(int o){//标记下放
        if(tr[o].rev){
            if(rs)pushr(rs);
            if(ls)pushr(ls);
            tr[o].rev=0;
        }
        return;
    }
    inline void rotate(int x){//基本rotate旋转
        int y=tr[x].parent;
        int r=tr[y].parent;
        bool flag_x=identify(x);
        bool flag_y=identify(y);
        int b=tr[x].child[!flag_x];
        if(nroot(y))tr[r].child[flag_y]=x;
        tr[x].parent=r;
        connect(b,y,flag_x);
        connect(y,x,!flag_x);
        pushup(y);
        pushup(x);
        return;
    }
    inline void splay(int at){//splay旋转
        top=0;
        int pa=at;
        st[++top]=pa;
        while(nroot(pa))pa=tr[pa].parent,st[++top]=pa;
        while(top)pushdown(st[top--]);
        while(nroot(at)){
            int pa=tr[at].parent;
            if(!nroot(pa))rotate(at);
            else if(identify(pa)==identify(at))rotate(pa),rotate(at);
            else rotate(at),rotate(at);
        }
        return;
    }
    inline void access(int o){
        int last=0;
        while(o){
            splay(o);
            rs=last;
            pushup(o);
            last=o;
            o=tr[o].parent;
        }
        return;
    }
    inline void makeroot(int o){
        access(o);
        splay(o);
        pushr(o);
        return;
    }
    inline void spilt(int x,int y){
        makeroot(x);
        access(y);
        splay(y);
    }
    inline int findroot(int o){
        access(o);
        splay(o);
        while(ls){
            pushdown(o);
            o=ls;
        }
        return o;
    }
    inline void link(int x,int y){
        makeroot(x);
        if(findroot(y)!=x){
            tr[x].parent=y;
            pushup(x);
        }
        return;
    }
    inline void cut(int x,int y){
        makeroot(x);
        if(findroot(y)==x&&tr[x].parent==y&&!tr[x].child[1]){
            tr[y].child[0]=0;
            tr[x].parent=0;
            pushup(y);
        }
        return;
    }
    inline int query_sum(int x,int y){
        return spilt(x,y),tr[y].summ;
    }
    inline int query_max(int x,int y){
        return spilt(x,y),tr[y].maxx;
    }
    inline void modify(int o,int v){
        access(o),splay(o),tr[o].v=v,pushup(o);
        return;
    }
    //防止冲突好习惯
    #undef MAX
    #undef ls
    #undef rs
}L;
//struct EDGE省略
void dfs(int u){//通过dfs建树；
    for(register int ee=E.first[u],v;v=E.e[ee].to,ee;ee=E.e[ee].nxt)
        if(v!=L.tr[u].parent)
            L.tr[v].parent=u,dfs(v);
    return;
}
signed main(){
    #ifdef local
    freopen("test.in","r",stdin);
    freopen("test.out","w",stdout);
    #endif
    int n,q,a,b,c;
    read(n);
    for(register int i=1;i<n;++i)
    read(a),read(b),
    E.connect(a,b);
    L.tr[0].maxx=-2147483647;
    dfs(1);
    for(register int i=1;i<=n;++i)
        read(c),
        L.tr[i].summ=L.tr[i].v=L.tr[i].maxx=c;
    read(q);
    for(register int i=1;i<=q;++i){
        c=readt(),read(a),read(b);
        if(c==1){
            printf("%d\n",L.query_max(a,b));//询问max
        }else if(c==2){
            printf("%d\n",L.query_sum(a,b));//询问sum
        }else if(c==3){
            L.modify(a,b);//更改值
        }
    }
    flush();//别忘了flush（）一下，不然WA声一片
    return 0;
}
```
~~神奇的结构体嵌套啊~~

---

## 作者：森岛帆高 (赞：2)

看起来像[树链剖分模板](https://www.luogu.org/problemnew/show/P3384)？~~我不会告诉你我交了五发才过。~~

还不会的出门左转先学，回来后会开心地发现好像维护的东西少了一些，但是得支持区间求$max$。考虑到是单点修改，我们可以使用还没人写过的树状数组实现滑稽。

**树状数组：**

简单来说就是用根据二进制位模拟的新数组来存储原数组的信息。

拿求和来做例子，对于第$x$个结点上的值$c[x]$，它等于$a[x-2^k+1]+...+a[x]$。因为每个数都可以转化为长度为$log_2$数值（差$1$可以忽略不计）的一个二进制数，意思也就是要保证$x-2^k+1>0$时$k$不会超过$log(x)$，那么时间法度就稳定在$log$级别。

![](https://cdn.luogu.com.cn/upload/pic/62111.png)

问题来了，如果我们修改了某个位置上的值，如何维护$c$数组？其实也很简单，只需要根据性质来逆推即可。每次回到该节点的父亲，然后一直向上爬并同时修改。这需要我们找出一个式子，下面是一段引用的推导证明（~~暴力模拟找规律可得！~~
>现在直接告诉你结论：
>>证明（可以跳过）：设$A'$为$A$的二进制反码，$i$的二进制表示成$A1B$，其中$A$不管，$B$为全$0$序列。那么$-i=A'0B'+1$。由于$B$为全$0$序列，那么$B'$就是全$1$序列，所以$-i=A'1B$，所以，$i$ $and$ $(-i)=A1B$&$A'1B=1B$，即$2^k$的值。

>如上提到的找到二进制位最低$1$的操作被称为$lowbit$，$lowbit$函数有许多实现方式，$x$&$-x$是最常用的一种。如果不支持访问负数，可以写成$x$&$(x$ $xor(x-1))$。

大致懂了吧$QwQ$，看起来树状数组也是个类似于前缀和的东西，区间和利用相减解决后我们继续讨论区间取$max$的问题。这里就需要明白最大值是不能相减的，所以拿$l$~$r$的区间来说，一个很伪的思路如下：

$1.$定义类似，$c[x]=max(a[x-lowbit(x)+1],...,a[x])$

$2.$修改，如果全部清空重新来一遍单次时间法度就达到了$nlog_2n$，显然太高了，观察发现$c[x]$需要的只有$c[x-2^0],c[x-2^1],c[x-2^2]...c[x-lowbit(x)+1]$（此处可能不需要也取不到，只是一个边界而已），也就是说在$c[1$~$x-1]$都正确的情况下更新的时间法度为$log(x)$，那么从原结点$l$根据$lowbit$向上爬，删去路径上的结点值，进行新的比较更新，总时间法度降到了两只$log$。

$3.$查询同理，向下爬（与树状树组取$max$），如果区间长度达不到$lowbit$那么减$1$继续（只能与原数组取$max$），相当于也是向下爬了一层，之前是最快速地爬。

这样问题就解决了，预处理时间法度是$nlog_2n$，查询/修改时间法度均为$(log_2n)^2$，而且总还是跑不满。

**树链剖分：**

大致就是将一棵树切成一些链从而配合数据结构实现区间操作。

*简单概念：*

重儿子：后代最多的儿子。

轻儿子：除重儿子外的儿子。

叶子节点没有儿子，自然也不会有重儿子和轻儿子。

重边：连接两个重儿子（父子关系）的边。

轻边：除重边外的边。

重链：一坨重边相连构成的链（以下链即重链）

---
重中之重：每一条链以轻儿子为起点，叶子结点也可以看做一条长度为0的链。

---
预处理：标记每个点的深度、父亲、子树大小、重儿子编号、映射后值以及编号、所在链的顶端。

递归时为使链编号连续应先处理重儿子，由于是深搜所以子树内编号也是连续的（虽然不查询子树没啥用）。

处理时让深度深的点向上跳到链顶端，操作这段之后再爬到链顶端的父亲，重复执行直到两点跑到同一条链上为止（一定是某一点成了另一点的祖先），最后再处理这段即可。

时间法度~~我太懒了~~把$rill7747$神仙的搬上来
>可以发现剖分后的树有如下性质：
①若$ (u,v) $是轻边，则有$sz_u > 2sz_v$。这个性质很显然。
②从根到某个点的路径上轻链、重链的个数是$ O(logn) $级别的。证明如下：
根据性质$1$，从根往下走，经过一次轻边，子树大小都会至少减小一半，所以轻边的条数是$ O(logn) $级别的，于是轻链的条数就是$ O(logn) $级别的；
重链与重链之间是由轻链隔开的，所以重链条数也是$ O(logn) $级别的。

**总结：**

将上述两者结合，开两个树状数组分别维护区间$max$和区间和。

$ID$得注意啊（哭了）。

~~作死的我，幸好树状数组常数小，不然三只$log$估计跑不过去。~~

时间复杂度$Θ(n(log_2n)^3)$~

***code***
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 30005
#define NN 60005
#define Max(x,y)(x>y?x:y)
#define lowbit(x)(x&-x)
#define For(i,x,y)for(i=x;i<=y;i++)
struct node
{
    int next,to;
}e[NN];
string o;
int head[NN],top[N],dep[N],hea[N],id[N],sz[N],fa[N],c[N],d[N],w[N],h[N],g,q,n;
int read()
{
    int A;
    bool K;
    char C;
    C=A=K=0;
    while(C<'0'||C>'9')K|=C=='-',C=getchar();
    while(C>'/'&&C<':')A=(A<<3)+(A<<1)+(C^48),C=getchar();
    return(K?-A:A);
}
void write(int X)
{
    if(X<0)putchar('-'),X=-X;
    if(X>9)write(X/10);
    putchar(X%10+48);
}
inline void sw_ap(int &_,int &__)
{
    _^=__^=_^=__;
}
inline void add(int u,int v)
{
    e[++g].to=v;
    e[g].next=head[u];
    head[u]=g;
}
void add1(int x,int v)
{
    while(x<=n)c[x]+=v,x+=lowbit(x);
}
int sum1(int x)
{
    int s=0;
    while(x)s+=c[x],x-=lowbit(x);
    return s;
}
void add2(int x)
{
    int i;
    while(x<=n)
    {
        d[x]=h[x];
        for(i=1;i<lowbit(x);i<<=1)d[x]=Max(d[x],d[x-i]);
        x+=lowbit(x);
    }
}
int sum2(int x,int y)
{
    int s=-INT_MAX;
    while(y>=x)
    {
        s=Max(s,h[y]);
        y--;
        while(y-lowbit(y)>=x)s=Max(s,d[y]),y-=lowbit(y);
    }
    return s;
}
int rangetot(int x,int y)
{
    int ans=0;
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]])sw_ap(x,y);
        ans+=sum1(id[x])-sum1(id[top[x]]-1);
        x=fa[top[x]];
    }
    if(dep[x]>dep[y])sw_ap(x,y);
    return ans+sum1(id[y])-sum1(id[x]-1);
}
int rangemax(int x,int y)
{
    int ans=-INT_MAX;
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]])sw_ap(x,y);
        ans=Max(ans,sum2(id[top[x]],id[x]));
        x=fa[top[x]];
    }
    if(dep[x]>dep[y])sw_ap(x,y);
    return Max(ans,sum2(id[x],id[y]));
}
void update(int x,int z)
{
    add1(id[x],z-w[id[x]]);
    w[id[x]]=h[id[x]]=z;
    add2(id[x]);
}
void dfs1(int x,int y,int z)
{
    int v,i;
    dep[x]=z;
    fa[x]=y;
    sz[x]=1;
    for(i=head[x];i;i=e[i].next)
    {
        v=e[i].to;
        if(v==y)continue;
        dfs1(v,x,z+1);
        sz[x]+=sz[v];
        if(sz[v]>sz[hea[x]])hea[x]=v;
    }
}
void dfs2(int x,int z)
{
    int v,i;
    id[x]=++q;
    h[q]=w[x];
    add1(q,w[x]);
    add2(q);
    top[x]=z;
    if(!hea[x])return;
    dfs2(hea[x],z);
    for(i=head[x];i;i=e[i].next)
    {
        v=e[i].to;
        if(v!=fa[x]&&v!=hea[x])dfs2(v,v);
    }
}
int main()
{
    int i,x,y;
    n=read();
    For(i,1,n-1)
    {
        x=read(),y=read();
        add(x,y),add(y,x);
    }
    For(i,1,n)w[i]=read();
    dfs1(1,0,1);
    dfs2(1,1);
    q=read();
    For(i,1,n)w[i]=h[i];
    while(q--)
    {
        cin>>o;
        x=read(),y=read();
        if(o=="CHANGE")
        {
            update(x,y);
            continue;
        }
        else if(o=="QMAX")write(rangemax(x,y));
        else write(rangetot(x,y));
        putchar('\n');
    }
    return 0;
}
```
>感谢观看！

---

## 作者：红色OI再临 (赞：2)

看到lct的题解比较少，所以我来贡献一篇

## 注意的地方and坑点

 1. 只用把mmax [ 0 ]（维护的最大值）初始化为极小值
 
 2. sum [ i ] , mmax [ i ]在输入时就可赋值为val [ i ]
 
 3. 要先储存下联通的点，在输入完val后再进行link操作 



### CHANGE操作

change ( x , v )表示把 val [ x ] 改成v

步骤：

1. 将x点splay到根

2. 更新 val [ x ] = v

3. 进行pushup(x)操作

### QMAX and QSUM操作

输入x,y表示询问x,y路径上的最大权值或者路径和

步骤

1. 只需split ( x , y ),然后输出 mmax [ y ] 或者 sum [ y ] 即可

2. 此时 mmax [ y ]  或 sum [ y ] 表示的就是x到y这条链上的最大权值 或者 权值和了

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <algorithm>
#define MN 4000001
#define re register int
#define ll long long
#define inf 0x7fffffff
using namespace std;
int f[MN], val[MN], sum[MN], r[MN], son[MN][2];
int mmax[MN], size[MN];
int fake1[MN], fake2[MN];
int zhan[MN];
int n, m, cnt;
int get(int x) {  ////判断节点是否为一个Splay的根（与普通Splay的区别1）
    return son[f[x]][0] == x || son[f[x]][1] == x;
}  ////如果连的是轻边，他的父亲的儿子里没有它
void pushup(int x) {
    sum[x] = sum[son[x][0]] + sum[son[x][1]] + val[x];
    mmax[x] = max(max(mmax[son[x][0]], mmax[son[x][1]]), val[x]);
}
void filp(int x) {
    swap(son[x][0], son[x][1]);
    r[x] ^= 1;
}
void pushdown(int x) {
    if (!r[x])
        return;
    r[x] = 0;
    if (son[x][0])
        filp(son[x][0]);
    if (son[x][1])
        filp(son[x][1]);
}
void rotate(int x) {
    int y = f[x], z = f[y], k = (son[y][1] == x), s = son[x][!k];
    if (get(y))
        son[z][son[z][1] == y] = x;
    son[x][!k] = y;
    son[y][k] = s;
    if (s)
        f[s] = y;
    f[y] = x;
    f[x] = z;
    pushup(y);
    // pushup(x);
}
void splay(int x) {
    int y = x, top = 0;
    zhan[++top] = y;
    while (get(y)) zhan[++top] = f[y], y = f[y];
    while (top) pushdown(zhan[top--]);
    while (get(x)) {
        y = f[x], top = f[y];
        if (get(y))
            rotate((son[y][0] == x) ^ (son[top][0] == y) ? x : y);
        rotate(x);
    }
    pushup(x);
    return;
}
void access(int x) {
    for (re y = 0; x; y = x, x = f[x]) {
        splay(x);
        son[x][1] = y;
        pushup(x);
    }
}
void makeroot(int x) {
    access(x);
    splay(x);
    filp(x);
}
int findroot(int x) {
    access(x);
    splay(x);
    while (son[x][0]) pushdown(x), x = son[x][0];
    splay(x);
    return x;
}
void split(int x, int y) {
    makeroot(x);
    access(y);
    splay(y);
}
void cut(int x, int y) {
    split(x, y);
    if (findroot(y) == x && f[y] == x && !son[y][0]) {
        f[y] = son[x][1] = 0;
        pushup(x);
    }
    return;
}
void link(int x, int y) {
    makeroot(x);
    if (findroot(y) != x)
        f[x] = y;
}
void change(int x, int v) {
    splay(x);
    val[x] = v;
    pushup(x);
}
int main() {
    mmax[0] = -inf;
    scanf("%d", &n);
    for (re i = 1; i <= n - 1; i++) {
        scanf("%d%d", &fake1[i], &fake2[i]);
    }  //先储存下要link的点，等输入完val后再操作
    //巨坑
    for (re i = 1; i <= n; i++) {
        scanf("%d", &val[i]);
        sum[i] = mmax[i] = val[i];
    }
    int t;
    for (re i = 1; i <= n - 1; i++) link(fake1[i], fake2[i]);
    scanf("%d", &t);
    for (re i = 1; i <= t; i++) {
        char s[7];
        int a1, a2;
        scanf("%s", s);
        scanf("%d%d", &a1, &a2);
        if (s[0] == 'C') {
            change(a1, a2);
        }
        if (s[0] == 'Q' && s[1] == 'M') {
            split(a1, a2);
            printf("%d\n", mmax[a2]);
        }
        if (s[0] == 'Q' && s[1] == 'S') {
            split(a1, a2);
            printf("%d\n", sum[a2]);
        }
    }
    // for(re i=1;i<=n;i++)
    // printf("%d %d\n",mmax[i],sum[i]);

    return 0;
}
```


---

## 作者：小菜鸟 (赞：2)

$LCT$九分钟过掉此题，留个纪念...

~~论模板的重要性~~

这篇题解主要吹嘘扩展性极强的$LCT$和便于重用的$C++$`template`

$LCT$是一种强大的数据结构，支持均摊$O(log\,n)$的动态连边、删边、单点及路径的修改和查询，甚至可以维护子树信息

所以这题显然是个裸的$LCT$板子（雾

对$LCT$完全不了解的[左转模板题](https://www.luogu.org/problemnew/show/P3690)

此题解主要展示对$LCT$的大力封装

既然是板子，就要“板”得彻底一点

~~写出Standard Template Library的风格来~~

~~template用起来，面向对象用起来~~

~~会写面向对象才找得到对象~~

我的$LCT$模板高度封装，只留下以下接口函数：

`make_node:创建新结点`

`link:连边`

`cut:删边`

`query:查询路径信息`

`modify:单点修改`

所以每次重用代码时只要重新实现信息维护方式的仿函数就行了。只要满足交换律、结合律就OK。

然后这题要查询两种信息？

很简单，开个`pair`存一下就好了。。。

上代码，模板在后面，，，

```cpp
const int N=100005,M=600005;

typedef std::pair<int,int> Node;

Node operator+(const Node &lhs,const Node &rhs)
{
    return Node(lhs.first+rhs.first,std::max(lhs.second,rhs.second));
}

struct Add//定义维护信息的仿函数
{
    Node operator()(const Node &lhs,const Node &rhs)const
    {
        return lhs+rhs;
    }
};

link_cut_tree<Node,Add> LCT;
link_cut_tree<Node,Add>::iterator iters[N];//为了封装就写了个迭代器，相当于指向结点的指针

int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;++i)iters[i]=LCT.make_node(Node(0,0));
    //这题毒瘤把初始权值放在后面，我又不想存询问
    for(int i=1;i<n;++i)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        LCT.link(iters[u],iters[v]);
    }
    for(int i=1;i<=n;++i)//于是就选择一个一个单点修改
    {
        int x;
        scanf("%d",&x);
        LCT.modify(iters[i],Node(x,x));//显然对于单个结点而言，和与最大值都是自身的权值
    }
    int q;
    scanf("%d",&q);
    while(q--)
    {
        char op;
        int u,v;
        scanf("\n%*c%c%*s%d%d",&op,&u,&v);//*表示忽略此占位符读入的数据
        if(op=='H')
        {
            LCT.modify(iters[u],Node(v,v));
        }
        if(op=='S')
        {
            printf("%d\n",LCT.query(iters[u],iters[v]).second.first);
            //为了判断连通性，query返回pair
            //first是bool，表示是否联通，second是路径信息
        }
        if(op=='M')
        {
            printf("%d\n",LCT.query(iters[u],iters[v]).second.second);
        }
    }
}
```

$LCT​$模板，继续吹爆

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>

//#define MEMPOOL

template<typename Value_type,typename Functor>
class LCT_splay
{
    public:
        struct Node;
        Node* __new_node(const Value_type&);
#ifdef MEMPOOL
    private:
        Node mem_pool[1<<20];
        int tot;
#endif
};
template<typename Value_type,typename Functor>
struct LCT_splay<Value_type,Functor>::Node:Functor
{
    Value_type val,sum;
    Node* ftr;
    Node* ch[2];
//    Node*& lc;
//    Node*& rc;
    #define lc ch[0]
    #define rc ch[1]
    bool rev;

    Node(const Value_type& v=Value_type()):
        val(v),
        sum(v),
        ftr(NULL),
//        lc(ch[0]),
//        rc(ch[1]),
        rev(0) {ch[0]=ch[1]=NULL;}

    void reverse();
    void push_down();
    void push_all();
    void maintain();
    bool is_root();
    void rotate();
    void splay();
};

template<typename Value_type,typename Functor>
void LCT_splay<Value_type,Functor>::Node::reverse()
{
    rev^=1;
}

template<typename Value_type,typename Functor>
void LCT_splay<Value_type,Functor>::Node::push_down()
{
    if(!rev)return;
    rev=0;
    Node* ptr=lc;
    lc=rc;
    rc=ptr;
    if(lc!=NULL)lc->reverse();
    if(rc!=NULL)rc->reverse();
}

template<typename Value_type,typename Functor>
void LCT_splay<Value_type,Functor>::Node::push_all()
{
    if(!is_root())this->ftr->push_all();
    push_down();
}

template<typename Value_type,typename Functor>
void LCT_splay<Value_type,Functor>::Node::maintain()
{
    sum=val;
    if(lc!=NULL)sum=Functor::operator()(lc->sum,sum);
    if(rc!=NULL)sum=Functor::operator()(sum,rc->sum);
}

template<typename Value_type,typename Functor>
bool LCT_splay<Value_type,Functor>::Node::is_root()
{
    return ftr==NULL||(ftr->lc!=this&&ftr->rc!=this);
}

template<typename Value_type,typename Functor>
void LCT_splay<Value_type,Functor>::Node::rotate()
{
    Node *nftr=ftr,*gftr=ftr->ftr;
    bool is_rc=nftr->rc==this;
    bool is_rf=gftr!=NULL?gftr->rc==nftr:0;
    ftr=gftr;
    if(!nftr->is_root())gftr->ch[is_rf]=this;
    nftr->ch[is_rc]=this->ch[!is_rc];
    if(this->ch[!is_rc]!=NULL)this->ch[!is_rc]->ftr=nftr;
    nftr->ftr=this;
    this->ch[!is_rc]=nftr;
    nftr->maintain();
    maintain();
}

template<typename Value_type,typename Functor>
void LCT_splay<Value_type,Functor>::Node::splay()
{
    push_all();
    while(!is_root())
    {
        Node *nftr=ftr,*gftr=ftr->ftr;
        if(nftr->is_root())rotate();
        else
        {
            if((gftr->lc==nftr)^(nftr->lc==this))rotate();
            else nftr->rotate();
            rotate();
        }
    }
}

template<typename Value_type,typename Functor>
typename
LCT_splay<Value_type,Functor>::Node* LCT_splay<Value_type,Functor>::__new_node(const Value_type& v)
{
#ifdef MEMPOOL
    if(tot==1<<20)
    {
        fprintf(stderr,"Error:No enough memory\n");
        return NULL;
    }
    mem_pool[tot++].val=v;
    return mem_pool+tot-1;
#else
    return new Node(v);
#endif
}

template<typename Value_type,typename Functor>
class link_cut_tree:public LCT_splay<Value_type,Functor>
{
    typedef typename LCT_splay<Value_type,Functor>::Node Node;
    private:
        void access(Node*);
        void make_root(Node*);
        Node* find_root(Node*);
        bool split(Node*,Node*);
    public:
        struct iterator;
        iterator make_node(const Value_type&);
        bool link(const iterator&,const iterator&);
        bool cut(const iterator&,const iterator&);
        std::pair<bool,Value_type> query(iterator,iterator);
        bool modify(iterator,const Value_type&);
};

template<typename Value_type,typename Functor>
struct link_cut_tree<Value_type,Functor>::iterator
{
    private:
        Node* ptr;
        friend class link_cut_tree;
    public:
        Value_type operator*()const{return ptr->val;}
        iterator(Node* p=NULL):ptr(p) {}
        iterator(const iterator& iter):ptr(iter.ptr) {}
};

template<typename Value_type,typename Functor>
void link_cut_tree<Value_type,Functor>::access(Node* ptr)
{
    for(Node* nptr=NULL;ptr!=NULL;nptr=ptr,ptr=ptr->ftr)
        {
            ptr->splay();
            ptr->rc=nptr;
            ptr->maintain();
        }
}

template<typename Value_type,typename Functor>
void link_cut_tree<Value_type,Functor>::make_root(Node* ptr)
{
    access(ptr);
    ptr->splay();
    ptr->reverse();
}

template<typename Value_type,typename Functor>
typename
link_cut_tree<Value_type,Functor>::Node* link_cut_tree<Value_type,Functor>::find_root(Node* ptr)
{
    access(ptr);
    ptr->splay();
    while(ptr->lc!=NULL)ptr->push_down(),ptr=ptr->lc;
    ptr->splay();
    return ptr;
}

template<typename Value_type,typename Functor>
bool link_cut_tree<Value_type,Functor>::split(Node* sptr,Node* eptr)
{
    make_root(sptr);
    if(find_root(eptr)!=sptr)return 0;
    eptr->splay();
    return 1;
}

template<typename Value_type,typename Functor>
typename
link_cut_tree<Value_type,Functor>::iterator link_cut_tree<Value_type,Functor>::make_node(const Value_type& v)
{
    return iterator(LCT_splay<Value_type,Functor>::__new_node(v));
}

template<typename Value_type,typename Functor>
bool link_cut_tree<Value_type,Functor>::link(const iterator& siter,const iterator& eiter)
{
    Node* sptr=siter.ptr;
    Node* eptr=eiter.ptr;
    make_root(sptr);
    if(find_root(eptr)==sptr)return 0;
    sptr->ftr=eptr;
    return 1;
}

template<typename Value_type,typename Functor>
bool link_cut_tree<Value_type,Functor>::cut(const iterator& siter,const iterator& eiter)
{
    Node* sptr=siter.ptr;
    Node* eptr=eiter.ptr;
    make_root(sptr);
    if(find_root(eptr)!=sptr||eptr->ftr!=sptr||eptr->lc!=NULL)return 0;
    eptr->ftr=NULL;
    sptr->lc=NULL;
    sptr->maintain();
    return 1;
}

template<typename Value_type,typename Functor>
std::pair<bool,Value_type> link_cut_tree<Value_type,Functor>::query(iterator siter,iterator eiter)
{
    Node* sptr=siter.ptr;
    Node* eptr=eiter.ptr;
    if(!split(sptr,eptr))return std::make_pair(0,Value_type());
    return std::make_pair(1,eptr->sum);
}

template<typename Value_type,typename Functor>
bool link_cut_tree<Value_type,Functor>::modify(iterator iter,const Value_type& v)
{
    Node* ptr=iter.ptr;
    if(ptr==NULL)return 0;
    ptr->splay();
    ptr->val=v;
    ptr->maintain();
    return 1;
}
#undef lc
#undef rc
```



---

## 作者：WAMonster (赞：1)

LCT板子题，照样用splay维护实链~~（树剖是什么我不会调）~~

~~怎么LCT的题目都是板子题~~

对于CHANGE操作，先把要改的节点splay一下再修改，以免影响其祖先的答案信息（好像也可以先改再splay+更新，不过没这个必要了）

对于QMAX和QSUM，只需用splay上传维护即可。

先读入点权再连边建LCT避免WA和没有必要的pushup。

code：
```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
#define maxn 30005
#define isdigit(x) ((x) >= '0' && (x) <= '9')
inline int read() {
    int res = 0, flag = 1;
    char c = getchar();
    while (!isdigit(c)) flag = (c == '-') ? -1 : 1, c = getchar();
    while (isdigit(c)) res = (res << 1) + (res << 3) + (c ^ 48), c = getchar();
    return res * flag;
}
int fa[maxn], ch[maxn][2], s[maxn], val[maxn], rev[maxn], mx[maxn], n, m, aa[maxn], bb[maxn];
inline void getrev(int x) {
    swap(ch[x][0], ch[x][1]);
    rev[x] ^= 1;
}
inline void pushdown(int x) {
    if (rev[x]) {
        if (ch[x][0]) getrev(ch[x][0]);
        if (ch[x][1]) getrev(ch[x][1]);
        rev[x] = 0;
    }
}
inline void pushup(int x) {
    s[x] = s[ch[x][0]] + s[ch[x][1]] + val[x];
    mx[x] = max(max(mx[ch[x][0]], mx[ch[x][1]]), val[x]);
}
inline int nroot(int x) {
    return ch[fa[x]][0] == x || ch[fa[x]][1] == x;
}
inline int chk(int x) {
    return ch[fa[x]][1] == x;
}
inline void rotate(int x) {
    int y = fa[x], z = fa[y], o = chk(x), a = ch[x][o ^ 1];
    if (nroot(y)) ch[z][chk(y)] = x; fa[x] = z;
    ch[y][o] = a; if (a) fa[a] = y;
    ch[x][o ^ 1] = y; fa[y] = x;
    pushup(y); pushup(x);
}
void pushall(int x) {
    if (nroot(x)) pushall(fa[x]);
    pushdown(x);
}
inline void splay(int x) {
    pushall(x);
    while (nroot(x)) {
        int y = fa[x];
        if (nroot(y)) {
            if (chk(x) == chk(y)) rotate(y);
            else rotate(x);
        }
        rotate(x);
    }
    pushup(x);
}
inline void access(int x) {
    for (int y = 0; x; y = x, x = fa[x])
        splay(x), ch[x][1] = y, pushup(x);
}
inline void makeroot(int x) {
    access(x); splay(x); getrev(x);
}
inline void split(int x, int y) {
    makeroot(x); access(y); splay(y);
}
inline void link(int x, int y) {
    makeroot(x); fa[x] = y;
}
char opt[10];
signed main() {
    n = read();
    for (int i = 1; i < n; ++i) {
        aa[i] = read(), bb[i] = read();
    }
    for (int i = 1; i <= n; ++i) val[i] = read();
    memset(mx, 0xcf, sizeof(mx));
    for (int i = 1; i < n; ++i) link(aa[i], bb[i]);
    m = read();
    while (m--) {
        scanf("%s", opt);
        if (opt[0] == 'C') {
            int u = read(), t = read();
            splay(u);
            val[u] = t;
            pushup(u);
        }
        else if (opt[1] == 'S') {
            int u = read(), v = read();
            split(u, v);
            printf("%d\n", s[v]);
        }
        else if (opt[1] == 'M') {
            int u = read(), v = read();
            split(u, v);
            printf("%d\n", mx[v]);
        }
    }
    return 0;
}
```

---

## 作者：ZHRRRRRR (赞：1)

整理了一晚上挺全面的树剖详解，自认为蛮详细的，也算是自己的学习笔记吧：
```cpp
// luogu-judger-enable-o2
//Copyright (c)2018 Zhang Henry
//This sourcecode is licensed under Devc++ 5.5.3

#include<bits/stdc++.h>
#define Lsn (x<<1)  //the left son.
#define Rsn (x<<1|1)  //the right son (notice : plus one).
#define Mid (L+R>>1)  //the log2 searching.
using namespace std;

/*heavy chain (path):HC;
son tree:ST.*/

const int Maxn=30000+19,oo=(1<<30)-1;
typedef int one[Maxn];

one size,deep,son,ID,top,Fa,Last;
 
/*size:the size of the ST;
deep:the depth of the son;
son:the largest ST;
top:the top point of the HC;
Fa:the father point of the point now;
ID:the dfs order of the point.*/

int Sum[Maxn*4],Max[Maxn*4];
int nxt[Maxn*2],to[Maxn*2];
int n,Q,x,y,t,v,cnt,tot,Ql,Qr;
char opt[10];
int f,c;

inline void read(int &x){	//the reading part.
    while (!isdigit(c=getchar())&&c!='-');
    if (c=='-') f=1,x=0;else f=0,x=c-'0';
    while (isdigit(c=getchar())) x=x*10+c-'0';
    if (f) x=-x;
}

////////////////////The Beginning Of The Initalization//////////////////////////// 
inline void DFS_find(int x){	 //the initalization DFS.
    size[x]=1;	//the initialization of the size[].
    for (int i=Last[x];i!=-1;i=nxt[i])	//search every edge from 'x'.
        if (to[i]!=Fa[x]){  //if the point next to 'x' is not it's father point:
            Fa[to[i]]=x;	//that point's father initialize to 'x'.
            deep[to[i]]=deep[x]+1;	//the depth of that point initalize to plusing one.
            DFS_find(to[i]);	//search for the that point's sons.
            size[x]+=size[to[i]];	//the size of the ST will change after searching.
            if (size[to[i]]>size[son[x]]) son[x]=to[i];	 //the largest ST changes.
        }
}

inline void DFS_con(int x,int anc){	//the searching of orders DFS.
//anc:the top of the HC now.
    ID[x]=++tot;  //the DFS order of 'x'.
    top[x]=anc;	//change the top of HC.
    if (son[x]) DFS_con(son[x],anc);  //serching for the next point on the HC.
    for (int i=Last[x];i!=-1;i=nxt[i]) 
        if (to[i]!=Fa[x]&&to[i]!=son[x]) DFS_con(to[i],to[i]); 
        //if the point is not on the HC,then itself is a HC.
}
////////////////////The End Of The Initalization//////////////////////////// 

////////////////////The Beginning Of The Operation//////////////////////////// 
inline void Update(int x,int L,int R){  //log2 searching to change the number.
    if (L==R) {Sum[x]=Max[x]=v;return;};  //if the query is only one point:
    if (t<=Mid) Update(Lsn,L,Mid);else Update(Rsn,Mid+1,R); //finding the point.
    Sum[x]=Sum[Lsn]+Sum[Rsn];  //update the HC sum.
    Max[x]=max(Max[Lsn],Max[Rsn]);  //update the HC maxnum.
}

inline int Qsum(int x,int L,int R){  //get the sum in the HC by log2.
    if (Ql<=L&&R<=Qr) return Sum[x];  //if find the root in the interval -> return the Sum of HC.
    int Ans=0;  
    if (Ql<=Mid) Ans+=Qsum(Lsn,L,Mid);  //the recursion.
    if (Qr>Mid) Ans+=Qsum(Rsn,Mid+1,R);
    return Ans;
}

inline int Qmax(int x,int L,int R){  //get the maxnum in the HC by log2.
    if (Ql<=L&&R<=Qr) return Max[x];  //if find the root in the interval -> return the Max of HC.
    int Ans=-oo;  //notice:ans should be MAX.
    if (Ql<=Mid) Ans=max(Ans,Qmax(Lsn,L,Mid));  //the recursion.
    if (Qr>Mid) Ans=max(Ans,Qmax(Rsn,Mid+1,R));
    return Ans;
}

inline int Query(int opt){  //Getting Answer.
    int a=top[x],b=top[y],Ans=(opt?-oo:0);  //get HC initalization.
    while (a!=b){
        if (deep[a]>deep[b]) swap(a,b),swap(x,y);  //just make sure Ql < Qr.
        Ql=ID[b],Qr=ID[y];  //get DFS order.
        if (opt) Ans=max(Ans,Qmax(1,1,n));else Ans+=Qsum(1,1,n);  //get answer.
        y=Fa[b];b=top[y];  
    }
    Ql=min(ID[x],ID[y]),Qr=max(ID[x],ID[y]);  
    if (opt) Ans=max(Ans,Qmax(1,1,n));else Ans+=Qsum(1,1,n);  //get answer , so metaphysical!!!
    return Ans;
}
////////////////////The End Of The Operation//////////////////////////// 
 
int main(){
    read(n);  //the number of points
    memset(Last,-1,sizeof(Last));  //equals to 'head[]'.
    for (int i=1;i<n;i++) {
        read(x),read(y);
        nxt[cnt]=Last[x];to[cnt]=y;Last[x]=cnt++;  
        nxt[cnt]=Last[y];to[cnt]=x;Last[y]=cnt++;
    }  // set up the form.
    DFS_find(1);  //the initalizational part.
    DFS_con(1,1);  //the initalizational part.
    for (int i=1;i<=n;i++) read(v),t=ID[i],Update(1,1,n);  //get in the number of the whole tree.
    read(Q);
    while (Q--){
        scanf("%s",opt);  //get in the opt.
        if (opt[0]=='C'){
            read(t),read(v);t=ID[t];
            Update(1,1,n);  //upload the point.
        } else{
            read(x),read(y);
            printf("%d\n",Query(opt[1]=='M'));  //a very metaphysical function.
        }
    }
    return 0;
}
//Made By ZHRRRRRR.
//Copyright (c)2018 Zhang Henry
//This sourcecode is licensed under Devc++ 5.5.3
```

---

## 作者：笑细 (赞：1)

这题思路其实比较简单，只是磨叽一点。

首先树链剖分，在dfs序，注意将重链的点连在一起，用线段树维护一下即可

别忘了开long long！

注意一下，题目中有可能出现负值，故ans负值为负无穷。

而ans大小为long long,应该写0xefefefefefefefef我当时写0xefefefef狂WA。T_T

看代码吧：

```
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 30004
using namespace std;
typedef long long ll;
char opt[21];
int n,T,fir[N],sec[N],tot,low[N],fa[N],siz[N];
int to[N<<1],nxt[N<<1],head[N],cnt,sn[N],tp[N];
ll ml[N<<2],vl[N<<2],a[N];

void add(int x,int y)
{
    to[++cnt]=y,nxt[cnt]=head[x],head[x]=cnt;
}

void dfs1(int now,int pre)
{
    low[now]=low[pre]+1,fa[now]=pre,siz[now]=1;
    for(int i=head[now];i;i=nxt[i])
    {
        int y=to[i];
        if(y!=pre)
        {
            dfs1(y,now);
            siz[now]+=siz[y];
            if(siz[y]>siz[sn[now]])
            {
                sn[now]=y;
            }
        }
    }
}

void dfs2(int now,int tpo)
{
    tp[now]=tpo;
    for(int i=head[now];i;i=nxt[i])
    {
        int y=to[i];
        if(y!=fa[now])
        {
            if(y==sn[now])
            {
                dfs2(y,tpo);
            }else
            {
                dfs2(y,y);
            }
        }
    }
}

void dfs3(int now)
{
    fir[now]=++tot;
    if(sn[now])
    {
        dfs3(sn[now]);
    }
    for(int i=head[now];i;i=nxt[i])
    {
        int y=to[i];
        if(y!=fa[now]&&y!=sn[now])
        {
            dfs3(y);
        }
    }
    sec[now]=tot;
}

void build(int lx,int rx,int nx)
{
    if(lx==rx)
    {
        ml[nx]=vl[nx]=a[lx];
        return;
    }
    int mid=(lx+rx)>>1;
    build(lx,mid,nx<<1);
    build(mid+1,rx,(nx<<1)|1);
    vl[nx]=vl[nx<<1]+vl[(nx<<1)|1],ml[nx]=max(ml[nx<<1],ml[(nx<<1)|1]);
}

void update(int to,ll aim,int lx,int rx,int nx)
{
    if(lx==rx)
    {
        vl[nx]=ml[nx]=aim;
        return;
    }
    int mid=(lx+rx)>>1;
    if(to<=mid)
    {
        update(to,aim,lx,mid,nx<<1);
    }else
    {
        update(to,aim,mid+1,rx,(nx<<1)|1);
    }
    vl[nx]=vl[nx<<1]+vl[(nx<<1)|1],ml[nx]=max(ml[nx<<1],ml[(nx<<1)|1]);
}

ll query(int ord,int lm,int rm,int lx,int rx,int nx)
{
    if(lm<=lx&&rm>=rx)
    {
    	if(ord)
    	{
        	return vl[nx];
        }else
        {
        	return ml[nx];
        }
    }
    int mid=(lx+rx)>>1;
    ll ret=0;
    if(!ord)
    {
        ret=0xefefefefefefefef;
    }
    if(lm<=mid)
    {
    	if(ord)
    	{
        	ret+=query(ord,lm,rm,lx,mid,nx<<1);
        }else
        {
    		ret=max(ret,query(ord,lm,rm,lx,mid,nx<<1));
    	}
    }
    if(rm>mid)
    {
    	if(ord)
    	{
    		ret+=query(ord,lm,rm,mid+1,rx,(nx<<1)|1);
        }else
        {
        	ret=max(ret,query(ord,lm,rm,mid+1,rx,(nx<<1)|1));
        }
    }
    return ret;
}

void solve(int ord,int x,int y)
{
    ll ans=0;
    if(!ord)
    {
        ans=0xefefefefefefefef;
    }
    while(tp[x]!=tp[y])
    {
        if(low[tp[x]]<low[tp[y]])
        {
            swap(x,y);
        }
        if(ord)
        {
            ans+=query(ord,fir[tp[x]],fir[x],1,n,1);
        }else
        {
            ans=max(ans,query(ord,fir[tp[x]],fir[x],1,n,1));
        }
        x=fa[tp[x]];
    }
    if(low[x]<low[y])
    {
        swap(x,y);
    }
    if(ord)
    {
        ans+=query(ord,fir[y],fir[x],1,n,1);
    }else
    {
        ans=max(ans,query(ord,fir[y],fir[x],1,n,1));
    }
    printf("%lld\n",ans);
}

int main()
{
    scanf("%d",&n);
    for(int i=1,ui,vi;i<n;i++)
    {
        scanf("%d%d",&ui,&vi);
        add(ui,vi);
        add(vi,ui);
    }
    dfs1(1,0);
    dfs2(1,1);
    dfs3(1);
    for(int i=1;i<=n;i++)
    {
    	scanf("%lld",&a[fir[i]]);
    }
    build(1,n,1);
    scanf("%d",&T);
    while(T--)
    {
        scanf("%s",opt);
        if(opt[0]=='C')
        {
            int to;
            ll aim;
            scanf("%d%lld",&to,&aim);
            update(fir[to],aim,1,n,1);
        }else
        {
    		int xi,yi;
    		scanf("%d%d",&xi,&yi);
        	if(opt[1]=='S')
        	{
            	solve(1,xi,yi);
            }else
            {
        		solve(0,xi,yi);
        	}
        }
    }
    return 0;
}

```

---

## 作者：localhost (赞：1)

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
#define inf 2147483647
#define max(x,y) ((x)>(y)?(x):(y))
#define min(x,y) ((x)<(y)?(x):(y))
#define fur(i,x,y) for(i=x;i<=y;i++)
#define fdr(i,x,y) for(i=x;i>=y;i--)
#define Fur(i,x,y) for(ll i=x;i<=y;i++)
#define Fdr(x,y) for(ll i=x;i>=y;i--)
#define in2(x,y) in(x);in(y)
#define in3(x,y,z) in2(x,y);in(z)
#define in4(a,b,c,d) in2(a,b);in2(c,d)
#define ln pc('\n')
#define pk pc(' ')
#define outn(x) out(x);ln;
#define outk(x) out(x);pk
#define out2(x,y) outk(x);outn(y);
#define out3(x,y,z) outk(x);out2(y,z)
#define out4(w,x,y,z) outk(w);out3(x,y,z)
#define clr(x,y) memset(x,y,sizeof(x))
#define cpy(x,y) memcpy(x,y,sizeof(x))
using namespace std;
/*---------------------------------------*/
namespace fib{char b[300000]= {},*f=b;}
#define gc ((*fib::f)?(*(fib ::f++)):(fgets(fib::b,sizeof(fib::b),stdin)?(fib::f=fib::b,*(fib::f++)):-1))
inline void in(ll &x){x=0;char c;bool f=0;while((c=gc)>'9'||c<'0')if(c=='-')f=!f;x=c-48;while((c=gc)<='9'&&c>='0')x=x*10+c-48;if(f)x=-x;} 
namespace fob{char b[300000]= {},*f=b,*g=b+300000-2;}
#define pob (fwrite(fob::b,sizeof(char),fob::f-fob::b,stdout),fob::f=fob::b,0)
#define pc(x) (*(fob::f++)=(x),(fob::f==fob::g)?pob:0)
struct foce{~foce(){pob;fflush(stdout);}} _foce;
namespace ib{char b[100];}
inline void out(ll x){if(x==0){pc(48);return;}if(x<0){pc('-');x=-x;}char *s=ib::b;while(x) *(++s)=x%10,x/=10;while(s!=ib::b) pc((*(s--))+48);}
/*------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------*/
#define N 40000
struct edge{ll to,next;}e[N<<1];
ll n,m,cnt=1,ds=0,p;
ll head[N],siz[N],top[N],pos[N],f[N],d[N],s[N<<2],b[N<<2];
inline void add(ll x,ll y){e[cnt].to=y;e[cnt].next=head[x];head[x]=cnt++;}
//两个dfs
inline void dfs(ll x){//标出每个点包括它和它的子树一共有多少个点
	siz[x]=1;
	for(ll i=head[x];i;i=e[i].next){
		ll to=e[i].to;if(to==f[x])continue;
		f[to]=x;d[to]=d[x]+1;
		dfs(to);
		siz[x]+=siz[to];
	}
}
inline void bt(ll x,ll tp){//标记重链，标出每个点在线段树中的编号
	pos[x]=++ds;top[x]=tp;
	ll k=0,i;
	for(i=head[x];i;i=e[i].next)if(e[i].to!=f[x]&&siz[e[i].to]>siz[k])k=e[i].to;
	if(!k)return;
	bt(k,tp);
	for(i=head[x];i;i=e[i].next)
	if(e[i].to!=f[x]&&e[i].to!=k)bt(e[i].to,e[i].to);
}
//zkw线段树跑得快（只是手酸，想偷懒）
inline void upd(ll x,ll c){for(s[x+=p]=c,b[x]=c,x>>=1;x;x>>=1){s[x]=s[x<<1]+s[x<<1|1];b[x]=max(b[x<<1],b[x<<1|1]);}}
inline ll qs(ll l,ll r){
	ll sum=0;
	for(l=l+p-1,r=r+p+1;l^r^1;l>>=1,r>>=1){if(~l&1)sum+=s[l^1];if(r&1)sum+=s[r^1];}
	return sum;
}
inline ll qm(ll l,ll r){
	ll ans=-inf;
	for(l=l+p-1,r=r+p+1;l^r^1;l>>=1,r>>=1){if(~l&1)ans=max(ans,b[l^1]);if(r&1)ans=max(ans,b[r^1]);}
	return ans;
}
inline ll finds(ll x,ll y){
	ll ans=0;
	while(top[x]!=top[y]){
		if(d[top[x]]<d[top[y]])swap(x,y);
		ans+=qs(pos[top[x]],pos[x]);x=f[top[x]];
	}
	if(pos[x]>pos[y])swap(x,y);
	ans+=qs(pos[x],pos[y]);
	return ans;
}
//查询
inline ll findm(ll x,ll y){
	ll ans=-inf;
	while(top[x]!=top[y]){
		if(d[top[x]]<d[top[y]])swap(x,y);
		ans=max(ans,qm(pos[top[x]],pos[x]));x=f[top[x]];
	}
	if(pos[x]>pos[y])swap(x,y);
	return max(ans,qm(pos[x],pos[y]));
}
int main(){
	char c[20];
	in(n);
	ll x,y;
	Fur(i,1,n-1){in2(x,y);add(x,y);add(y,x);}
	dfs(1);bt(1,1);
	for(p=1;p<=n+2;p<<=1);
	Fur(i,1,n){in(x);upd(pos[i],x);}
	in(m);
	while(m--){
		scanf("%s",c);in2(x,y);
		if(c[0]=='C')upd(pos[x],y);
		else{outn((c[1]=='S')?finds(x,y):findm(x,y));}
	} 
}

```
要了解更多，可参考[黄学长的博客](http://hzwer.com/2543.html)

更完整版：https://www.luogu.org/problemnew/show/P3384
```cpp
#include<cstdio>
#define ll long long
#define inf 2333333
#define max(x,y) ((x)>(y)?(x):(y))
#define Fur(i,x,y) for(ll i=x;i<=y;i++)
#define in2(x,y) in(x);in(y)
#define in3(x,y,z) in2(x,y);in(z)
#define in4(a,b,c,d) in2(a,b);in2(c,d)
#define pn pc('\n')
using namespace std;
/*---------------------------------------*/
namespace fib{char b[300000]= {},*f=b;}
#define gc ((*fib::f)?(*(fib ::f++)):(fgets(fib::b,sizeof(fib::b),stdin)?(fib::f=fib::b,*(fib::f++)):-1))
inline void in(ll &x){x=0;char c;bool f=0;while((c=gc)>'9'||c<'0')if(c=='-')f=!f;x=c-48;while((c=gc)<='9'&&c>='0')x=x*10+c-48;if(f)x=-x;}
namespace fob{char b[300000]= {},*f=b,*g=b+300000-2;}
#define pob (fwrite(fob::b,sizeof(char),fob::f-fob::b,stdout),fob::f=fob::b,0)
#define pc(x) (*(fob::f++)=(x),(fob::f==fob::g)?pob:0)
struct foce{~foce(){pob;fflush(stdout);}} _foce;
namespace ib{char b[100];}
inline void out(ll x){if(x==0){pc(48);return;}if(x<0){pc('-');x=-x;}char *s=ib::b;while(x) *(++s)=x%10,x/=10;while(s!=ib::b) pc((*(s--))+48);}
inline void outn(ll x){out(x);pc('\n');}
inline void swap(ll &x,ll &y){ll t=x;x=y;y=t;}
/*------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------*/
#define N 100001
#define P 1,n,1
struct xds{
#define ls rt<<1
#define rs ls|1
#define pu s[rt]=s[ls]+s[rs]
#define Z ll m=(l+r)>>1;
ll a[N],s[N<<2],add[N<<2];
inline void pd(ll ln,ll rn,ll rt){if(add[rt]){s[ls]+=add[rt]*ln;s[rs]+=add[rt]*rn;add[ls]+=add[rt];add[rs]+=add[rt];add[rt]=0;}}
inline void build(ll l,ll r,ll rt){if(l==r){s[rt]=a[l];return;}Z;build(l,m,ls);build(m+1,r,rs);pu;}
inline void upd(ll L,ll R,ll c,ll l,ll r,ll rt){if(L<=l&&r<=R){s[rt]+=c*(r-l+1);add[rt]+=c;return;}Z;pd(m-l+1,r-m,rt);if(L<=m)upd(L,R,c,l,m,ls);if(R>m)upd(L,R,c,m+1,r,rs);pu;}
inline ll qh(ll L,ll R,ll l,ll r,ll rt){if(L<=l&&r<=R)return s[rt];Z;pd(m-l+1,r-m,rt);return ((L<=m)?qh(L,R,l,m,ls):0)+((R>m)?qh(L,R,m+1,r,rs):0);}
}T;
struct edge{ll to,next;}e[N<<1];
ll n,sz=0,m,cnt=1,mod,RT;
ll f[N],siz[N],head[N],d[N],top[N],id[N],u[N];
inline void add(ll x,ll y){e[cnt].to=y;e[cnt].next=head[x];head[x]=cnt++;}
inline void dfs(ll x){
	siz[x]=1;
	for(ll i=head[x];i;i=e[i].next)
	if(e[i].to!=f[x]){
		f[e[i].to]=x;
		d[e[i].to]=d[x]+1;
		dfs(e[i].to);
		siz[x]+=siz[e[i].to];
	}
}
inline void bt(ll x,ll tp){
	id[x]=++sz;top[x]=tp;T.a[sz]=u[x];
	ll k=0,i;
	for(i=head[x];i;i=e[i].next)
	if(e[i].to!=f[x]&&siz[e[i].to]>siz[k])k=e[i].to;
	if(!k)return;
	bt(k,tp);
	for(i=head[x];i;i=e[i].next)if(e[i].to!=f[x]&&e[i].to!=k)bt(e[i].to,e[i].to);
}
inline ll fh(ll x,ll y){
	ll ans=0;
	while(top[x]!=top[y]){
		if(d[top[x]]<d[top[y]])swap(x,y);
		ans+=T.qh(id[top[x]],id[x],P);x=f[top[x]];
	}
	if(id[x]>id[y])swap(x,y);
	return (ans+T.qh(id[x],id[y],P))%mod;
}
inline void updl(ll x,ll y,ll c){
	while(top[x]!=top[y]){
		if(d[top[x]]<d[top[y]])swap(x,y);
		T.upd(id[top[x]],id[x],c,P);x=f[top[x]];
	}
	if(id[x]>id[y])swap(x,y);
	T.upd(id[x],id[y],c,P);
}
inline void upds(ll x,ll c){T.upd(id[x],id[x]+siz[x]-1,c,P);}
inline ll qs(ll x){return T.qh(id[x],id[x]+siz[x]-1,P)%mod;}
int main(){
	in4(n,m,RT,mod);
	Fur(i,1,n)in(u[i]);
	ll q,x,y,c;
	Fur(i,1,n-1){in2(x,y);add(x,y);add(y,x);}
	dfs(RT);bt(RT,RT);T.build(P);
	while(m--){
		in2(q,x);
		if(q==1){in2(y,c);updl(x,y,c);}
		if(q==2){in(y);outn(fh(x,y));}
		if(q==3){in(c);upds(x,c);}
		if(q==4)outn(qs(x));
	}
}
```
附上码题过程：https://www.bilibili.com/video/av21350214/

---

## 作者：夏色祭 (赞：1)

树剖入门题啊。。。比模板还要简单。。。估计zjoi当年这题是来送分的。。。

~~做一下练下手速~~

这里介绍一下树剖的几个基本概念，希望对刚学树剖的同学有帮助。

**来自ff巨佬的课件**

size[v]表示以v为根的子树的节点数

重儿子：size[u]为v的子节点中size值最大的，那么u就是v的重儿子

轻儿子：v的其他子节点

重边：点v与其重儿子的连边

轻边：点v与其轻儿子的连边

重链：由重边连成的路径

轻链：轻边

dep[v]表示v的深度（根深度为1）

top[v]表示v所在的**重链**的顶端节点

fa[v]表示v的父亲

son[v]表示v的重儿子

idx[v]表示v在线段树中的位置

tree[i]表示线段树第i个点对应原树的哪个节点，即idx的逆数组

然后我就不多说了。。。

代码：

```cpp
#include<cstdio>
#include<iostream>
#define For(i,x,y) for (int i=x;i<=y;i++)
#define cross(i,k) for (int i=first[k];i!=0;i=last[i])
#define N 30010
#define kkk -233333333
using namespace std;
struct tree{
    int l,r,max,sum;
}a[8*N]; 
int b[N],to[N<<1],first[N],last[N<<1];
int n,m,tot,x,y;
char s[20];
void add(int x,int y){to[++tot]=y,last[tot]=first[x],first[x]=tot;}
int size[N],dep[N],son[N],fa[N];
void dfs1(int k){
    size[k]=1,dep[k]=dep[fa[k]]+1;
    cross(i,k){
        int v=to[i];
        if (v==fa[k]) continue;
        fa[v]=k,dfs1(v);
        size[k]+=size[v];
        if (!son[k]||size[son[k]]<size[v]) son[k]=v;
    }
}
int idc,idx[N],tree[N],top[N];
void dfs2(int k,int tp){
    top[k]=tp,idx[k]=++idc,tree[idc]=k;
    if (!son[k]) return;
    dfs2(son[k],tp);
    cross(i,k){
        int v=to[i];
        if (v==fa[k]||v==son[k]) continue;
        dfs2(v,v);
    }
}
void build(int k,int l,int r){
    a[k].l=l,a[k].r=r;
    if (l==r){
        a[k].sum=a[k].max=b[tree[l]];
        return;
    }
    int mid=l+r >> 1;
    build(k<<1,l,mid),build(k<<1^1,mid+1,r);
    a[k].sum=a[k<<1].sum+a[k<<1^1].sum;
    a[k].max=max(a[k<<1].max,a[k<<1^1].max);
}
void ud(int k,int l,int r,int x){
    if (a[k].l>r||a[k].r<l) return;
    if (a[k].l==l&&a[k].r==r){
        a[k].sum=a[k].max=x;
        return;
    }
    ud(k<<1,l,r,x),ud(k<<1^1,l,r,x);
    a[k].sum=a[k<<1].sum+a[k<<1^1].sum;
    a[k].max=max(a[k<<1].max,a[k<<1^1].max);
}
int querysum(int k,int l,int r){
    if (a[k].l>r||a[k].r<l) return 0;
    if (a[k].l>=l&&a[k].r<=r) return a[k].sum;
    return querysum(k<<1,l,r)+querysum(k<<1^1,l,r);
}
int querymax(int k,int l,int r){
    if (a[k].l>r||a[k].r<l) return kkk;
    if (a[k].l>=l&&a[k].r<=r) return a[k].max;
    return max(querymax(k<<1,l,r),querymax(k<<1^1,l,r));
}
void swap(int &x,int &y){int t;t=x,x=y,y=t;}
int querys(int x,int y){
    int ans=0;
    while (top[x]!=top[y]){
        if (dep[top[x]]<dep[top[y]]) swap(x,y);
        ans+=querysum(1,idx[top[x]],idx[x]);
        x=fa[top[x]];
    }
    if (dep[x]>dep[y]) swap(x,y);
    ans+=querysum(1,idx[x],idx[y]);
    return ans;
}
int querym(int x,int y){
    int ans=kkk;
    while (top[x]!=top[y]){
        if (dep[top[x]]<dep[top[y]]) swap(x,y);
        ans=max(ans,querymax(1,idx[top[x]],idx[x]));
        x=fa[top[x]];
    }
    if (dep[x]>dep[y]) swap(x,y);
    ans=max(ans,querymax(1,idx[x],idx[y]));
    return ans;
}
int main(){
    scanf("%d",&n);
    For(i,1,n-1){
        scanf("%d%d",&x,&y);
        add(x,y),add(y,x);
    }
    dfs1(1);
    dfs2(1,1);
    For(i,1,n) scanf("%d",&b[i]);
    build(1,1,n);
    scanf("%d",&m);
    For(i,1,m){
        scanf("%s%d%d",&s,&x,&y);
        if (s[0]=='C') ud(1,idx[x],idx[x],y);
        if (s[0]=='Q'&&s[1]=='S') printf("%d\n",querys(x,y));
        if (s[0]=='Q'&&s[1]=='M') printf("%d\n",querym(x,y));
    }
    return 0;
}
```

---

## 作者：AKPC (赞：1)

### 前言
这里是不一样的分块做法。

来做这个题的原因是最近刚学树链剖分，树链剖分练习题里面有这个题，一眼要用~~晦气难调的~~线段树，但我就不，本来想写树状数组的，但学习树状数组 $\text O(n\log^2 n)$ 维护最值的时候又有点懵，LCT 太高深的东西我又不会。

那怎么办？**分块**。
### 思路
先考虑这个问题（树上问题看做数列问题）：

有数列 $a$，大小 $n$，$1\leq n\leq 3\times10^4$，$q$ 个操作，$1\leq q\leq 2\times 10^5$，分为三种：

- `1 x y` 将 $a_x$ 修改为 $y$。
- `2 x y` 查询 $\displaystyle\max_{i=x}^ya_i$。
- `3 x y` 查询 $\sum_{i=x}^ya_i$。

维护 $\sqrt n$ 个懒标记来处理 $\sqrt n$ 块中每个块的最值（名为 `lazy` 的数组），同时记录每个块的和（`sum` 数组）。`block` 数组用来存的是每个位置对应的块的编号，这个在分块算法均很常见，求法不过多阐述。

对于 $1$ 操作，在单点修改时暴力更新块最值，同时更新块的总和，复杂度 $\text O(\sqrt n)$。

对于 $2$ 操作，根据分块处理，特判左右端点不在同一块后（否则暴力），两端暴力搜权值，中间直接调用 $\text{multiset}$ 存储的最值，最后给这些值求 $\max$ 即可，复杂度 $\text O(\sqrt n)$。

对于 $3$ 操作，跟分块模板题类似，特判后，两端暴力搜权值，中间直接把记录下来的块和加进去即可，复杂度 $\text O(\sqrt n)$。

复杂度 $\text O(q\sqrt n)$，数据范围挺小的，常数小的情况下卡过去了。

[完整代码](https://www.luogu.com.cn/paste/k17i5ddk)。

那转到树上操作就有了这个题。

**套树剖板子**。这边如果不会，建议先练练板子题 P3379（树链剖分求 LCA）以及 P3384（树链剖分维护路径，子树权值）。不懂可以看看我博客的[树剖 notes](https://www.luogu.com.cn/blog/varphi/shu-pou-notes)。

对于操作 $1$，跟分块一样直接调用修改函数即可。

对于操作 $2$，跟树链剖分求 LCA 类似，这里先讲一下求 LCA（不是倍增法）：

对于 $x,y$ 这两个点，通过讨论重链，有两种情况：
- $x,y$ 在同一重链上，不妨设 $dep[x]\leq dep[y]$，此时 $\text{LCA}(x,y)=x$。
- $x,y$ 不在同一重链上，不妨设 $dep[top[x]]\geq dep[top[y]]$，此时 $\text{LCA}(x,y)=\text{LCA}(fa[top[x]],y)$。

现在回到操作 $2$，知道两点路径必定经过其 LCA，而求 LCA 时又是拆成多个整体的重链（$dfn$ 连续），不断向上跳直到 LCA，那可以在跳的过程中把每次跳到的重链加一个查询并统计最大值，然后输出统计的值即可。

操作 $3$ 与操作 $2$ 类似，查询，统计和即可。

查询要跳链，所以复杂度是 $\text O(q\sqrt n\log n)$。

优化前最慢的点仅仅一百七十多毫秒。分块能骗的树链剖分题是真的少见了。
### 代码
[code](https://www.luogu.com.cn/paste/h4smytg3) and [record](https://www.luogu.com.cn/record/137830040)。

---

## 作者：superMB (赞：0)

什么，这题已经有ZKW写的了？

然鹅那并没有用ZKW写区间最值啊，所以这才是ZKW完全体。

其他的操作就是一个树链剖分的模板，区间和用ZKW写很简单

区间最值的操作大概就是用差分了：

```cpp
#include<cstdio>
#include<iostream>
#include<bits/stdc++.h>
#define ri register int
#define Max(a,b) (a)>(b)?(a):(b)
const int maxn=30005;
using namespace std;
template<typename TP>inline void read(TP&x)
{
    x=0;int f=1;char c=getchar();
    while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    x*=f;
}
template<typename TP>inline void print(TP x)
{
    if(x<0)x=-x,putchar('-');
    if(x>=10)print(x/10);
    putchar(x%10+'0');
}
struct Map {
	int to,nxt;
}e[maxn<<1];
int head[maxn],tot,weight[maxn];
int size[maxn],son_h[maxn],dep[maxn],fath[maxn];
int newid[maxn],top[maxn],cnt,rank[maxn];
int n,a,b;
int q;
char type[10];
class Segment_tree {
	
	protected:
		int leaf;
		int tree_sum[maxn<<2],tree_max[maxn<<2];
	public:
		inline void build()
		{
			leaf=1;
			for(;leaf<=n+1;leaf<<=1);
			for(ri i=leaf+1;i<=leaf+n;++i)
				tree_sum[i]=tree_max[i]=weight[rank[i-leaf]];
			for(ri i=leaf-1;i;--i)
				tree_sum[i]=tree_sum[i<<1]+tree_sum[i<<1|1],
				tree_max[i]=Max(tree_max[i<<1],tree_max[i<<1|1]),
				tree_max[i<<1]-=tree_max[i],tree_max[i<<1|1]-=tree_max[i];
			return;
		}
		inline int query_max(int L,int R)
		{
			int lans=-0x7f7f7f7f,rans=-0x7f7f7f7f,ans;
			for(L+=leaf-1,R+=leaf+1;L^R^1;L>>=1,R>>=1)
			{
		        lans+=tree_max[L],rans+=tree_max[R];
				if(~L&1)lans=Max(tree_max[L^1],lans);
		        if( R&1)rans=Max(tree_max[R^1],rans);
		    }
		    lans+=tree_max[L],rans+=tree_max[R];
		    ans=Max(lans,rans);
		    for(L>>=1;L;L>>=1)ans+=tree_max[L];
			return ans;
		}
		inline void update(int pos,int val)
		{
			pos+=leaf;
			tree_sum[pos]=val;
			int tp=query_max(pos-leaf,pos-leaf);
			tree_max[pos]+=val-tp;
			while(pos>1)
			{
				pos>>=1;
				tree_sum[pos]=tree_sum[pos<<1]+tree_sum[pos<<1|1];
				int temp=Max(tree_max[pos<<1],tree_max[pos<<1|1]);
				tree_max[pos]+=temp,tree_max[pos<<1]-=temp,tree_max[pos<<1|1]-=temp;
			}
			return;
		}
		inline int query_sum(int L,int R)
		{
			int ret=0;
			for(L+=leaf-1,R+=leaf+1;L^R^1;L>>=1,R>>=1)
			{
		        if(~L&1)ret+=tree_sum[L^1];
		        if( R&1)ret+=tree_sum[R^1];
		    }
			return ret;
		}
}tree;
class Heavy_light_Decomposition {
	
	public:
		inline void add(int from,int to)
		{
			e[++tot].to=to;
			e[tot].nxt=head[from];
			head[from]=tot;
		}
		inline void dfs1(int x,int fa,int deep)
		{
			dep[x]=deep;
			fath[x]=fa;
			size[x]=1;
			for(ri i=head[x];i;i=e[i].nxt)
			{
				int to=e[i].to;
				if(to!=fa)
				{
					dfs1(to,x,deep+1);
					size[x]+=size[to];
					if(son_h[x]==0||size[to]>size[son_h[x]])son_h[x]=to;
				}
			}
		}
		inline void dfs2(int x,int rt)
		{
			top[x]=rt;
			newid[x]=++cnt;
			rank[cnt]=x;
			if(!son_h[x])return;
			dfs2(son_h[x],rt);
			for(ri i=head[x];i;i=e[i].nxt)
			{
				int to=e[i].to;
				if(to!=son_h[x]&&to!=fath[x])dfs2(to,to);
			}
		}
		inline int query_s(int from,int to)
		{
			int ans=0;
			while(top[from]!=top[to])
			{
				if(dep[top[from]]<dep[top[to]])swap(from,to);
				ans+=tree.query_sum(newid[top[from]],newid[from]);
				from=fath[top[from]];
			}
			if(dep[from]>dep[to])swap(from,to);
			ans+=tree.query_sum(newid[from],newid[to]);
			return ans;
		}
		inline int query_m(int from,int to)
		{
			int ans=-0x7f7f7f7f;
			while(top[from]!=top[to])
			{
				if(dep[top[from]]<dep[top[to]])swap(from,to);
				int temp=tree.query_max(newid[top[from]],newid[from]);
				ans=Max(ans,temp);
				from=fath[top[from]];
			}
			if(dep[from]>dep[to])swap(from,to);
			int temp=tree.query_max(newid[from],newid[to]);
			ans=Max(ans,temp);
			return ans;
		}
}poufen;
int main()
{
	read(n);
	for(ri i=1;i<n;++i)
	{
		read(a),read(b);
		poufen.add(a,b),poufen.add(b,a);
	}
	for(ri i=1;i<=n;++i)read(weight[i]);
	poufen.dfs1(1,0,1),poufen.dfs2(1,1),tree.build();
	read(q);
	for(ri i=1;i<=q;++i)
	{
		scanf("%s",type),read(a),read(b);
		if(type[1]=='M')print(poufen.query_m(a,b)),putchar('\n');
		else if(type[1]=='S')print(poufen.query_s(a,b)),putchar('\n');
		else tree.update(newid[a],b);
	}
	return 0;
}
```


---

## 作者：z1431346079 (赞：0)

蒟蒻登场

树剖模板题（https://www.luogu.org/problemnew/show/P3384）（建议先学好树剖再来写此题会舒服很多）

本蒟蒻最近刚好学了zkw线段树，就拿此题来练手。

本题最直接的想法，建两颗线段树，一棵维护区间最大值，
一棵维护区间和。

我用zkw（重口味）线段树维护区间和，用普通线段树维护区间最大值。（但其实可以只建一棵普通线段树（一个数组维护区间和，另一个维护区间最大值））


```cpp
#include<bits/stdc++.h>
#define ls rt<<1
#define rs rt<<1|1
using namespace std;
inline int read()
{
    int f=1,num=0;
    char ch=getchar();
    while(0==isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(0!=isdigit(ch)) num=(num<<1)+(num<<3)+ch-'0',ch=getchar();
    return num*f;
}//快读
const int N=30010;
const int inf=0x3f3f3f3f;
int tot,head[N],next[N<<1],to[N<<1];
int size[N],son[N],dep[N],fa[N],top[N],now[N],past[N];
int a[N];
char s[100];
int n,m,root,p;
inline void Add(int x,int y)
{
    next[++tot]=head[x],head[x]=tot,to[tot]=y;
}//邻接表
void dfs_getson(int x)
{
    size[x]=1;
    for(register int i=head[x];i;i=next[i])
    {
        int y=to[i];
        if(y==fa[x])continue;
        fa[y]=x;dep[y]=dep[x]+1;
        dfs_getson(y);
        size[x]+=size[y];
        if(size[y]>size[son[x]])son[x]=y;
    }
}
void dfs_rewrite(int x,int tp)
{
    top[x]=tp;
    now[x]=++tot;
    past[tot]=x;
    if(son[x])dfs_rewrite(son[x],tp);
    for(register int i=head[x];i;i=next[i])
    {
        int y=to[i];
        if(y!=son[x]&&y!=fa[x])dfs_rewrite(y,y);
    }
}//标准树剖

以下为封装在结构体的ZKW主体函数（方便使用）
struct ZKW{
	long long tr[N*8]={0};//记得开long long
	long long add[N*8];
	int M=1;
    inline void buildtree()
    {
    	while(M<(n+2))M<<=1;
    	for(register int i=M+1;i<=M+n;i++)
    	{
    	tr[i]=a[past[i-M]];
    	int x=i;
    	while(x>>=1)tr[x]=tr[x<<1]+tr[x<<1|1];
    	}
    }//建树
    
    inline void change(int p, int v)
    {
        p += M;
        tr[p] = v;
        while(p > 1){
            p >>= 1;
            tr[p] = tr[p<<1]+tr[p<<1|1];
        }
    }//单点修改
    
    inline long long getsum(int l,int r)
    {
        l+=M-1;r+=M+1;
        long long ans=0;
        int L=0,R=0;
        for(register int i=1;l^r^1;i<<=1,l>>=1,r>>=1)
        {
            ans+=add[l]*L+add[r]*R;
            if(~l&1)ans+=tr[l^1],L+=i;
            if(r&1) ans+=tr[r^1],R+=i;
        }
        ans+=add[l]*L+add[r]*R;
        while(l>>=1)ans+=add[l]*(L+R);
        return ans;
    }//求区间和
    
   	inline void getsum_xtoy(int x,int y)
    {
        long long ans=0;
        while(top[x]!=top[y])
        {
        	if(dep[top[x]]>dep[top[y]])swap(x,y);
        	ans=(ans+getsum(now[top[y]],now[y]));
        	y=fa[top[y]];
        }
        if(dep[x]>dep[y])swap(x,y);
        (ans+=getsum(now[x],now[y]));
        printf("%lld\n",ans);
    }//求最短路径和
    
}zkw;
以下为封装在结构体的普通线段树主体函数（方便使用）
struct node{
	int tree[N*4];
    inline void pushup(int rt)
    {
        tree[rt]=max(tree[ls],tree[rs]);
    }
    
    inline void build(int rt,int l,int r)
    {
        if(l==r)
        {
            tree[rt]=a[past[l]];
            return;
        }
        int mid=(l+r)>>1;
        build(ls,l,mid);
        build(rs,mid+1,r);
        pushup(rt);
    }
    
    void update(int k,int l,int r,int rt,int val)
    {
        if(l==k&&r==k)
        {
            tree[rt]=val;
            return;
        }
        int mid=(l+r)>>1;
        if(k<=mid)update(k,l,mid,ls,val);
        if(k>mid)update(k,mid+1,r,rs,val);
        pushup(rt);
    }
    
    int query(int L,int R,int l,int r,int rt)
    {
        if(L<=l&&r<=R)
        {
            return tree[rt];
        }
        int mid=(l+r)>>1;
        int ans=-inf;
        if(L<=mid)ans=max(ans,query(L,R,l,mid,ls));
        if(R>mid)ans=max(ans,query(L,R,mid+1,r,rs));
        pushup(rt);
        return ans;
    }
    
    inline void solve(int x,int y)
    {
    	int ans=-inf;
    	while(top[x]!=top[y])
	    {
	    	if(dep[top[x]]>dep[top[y]])swap(x,y);
	    	ans=max(ans,query(now[top[y]],now[y],1,tot,1));
	    	y=fa[top[y]];
	    }
	    if(dep[x]>dep[y])swap(x,y);
	    ans=max(ans,query(now[x],now[y],1,tot,1));
	    printf("%d\n",ans);
	}
}normal;

int main()
{
    n=read();
    for(register int i=1;i<n;i++)
    {
        int x=read(),y=read();
        Add(x,y);Add(y,x);
    }
    for(register int i=1;i<=n;i++)
    {
        a[i]=read();
    }
    tot=0;root=1;
    dfs_getson(root);
    dfs_rewrite(root,root);
    zkw.buildtree();
    normal.build(1,1,tot);
    m=read();
    for(register int i=1;i<=m;i++)
    {
        cin>>s+1;int x,y;
        x=read();y=read();
        if(s[1]=='C')
        {
            zkw.change(now[x],y);
            normal.update(now[x],1,tot,1,y);
        }
        if(s[1]=='Q'&&s[2]=='M')
        {
            normal.solve(x,y);
        }
        if(s[1]=='Q'&&s[2]=='S')
        {
            zkw.getsum_xtoy(x,y);
        }
    }
    return 0;
}
```


---

## 作者：YZhe (赞：0)

   **强烈推荐**刚学**树链剖分**的童鞋来做下这道题，本蒟蒻写了四次才AC这道题(~~谁让我太弱了~~)，发下题解巩固一下。(重新发一下，原来的排版有问题)
   

------------

### 简略说下树链剖分
树剖可以将一棵树转化为有序的一段，同时方便了我们进行统计和修改，同时它也是十分高效的，在线段树的维护下，我们可以用最坏O(log²n)的复杂度进行操作，~~当然码量是十分巨大的~~  
    这里我推荐一篇很棒的[博客](http://www.cnblogs.com/chinhhh/p/7965433.html)，我的树剖就是在那里学会的。    
    

------------

### 预处理
 分为两步dfs     
####  第一步
 ```cpp
void dfs1( int p ){
	dp[ p ] = dp[ fa[ p ] ] + 1;
	size[ p ] = 1;
	for( register int i = head[ p ] ; i ; i = e[ i ].next ){
		int v = e[ i ].to;
		if( v == fa[ p ] )
		  continue;
		fa[ v ] = p;
		dfs1( v );
		size[ p ] += size[ v ];
		if( size[ v ] > size[ son[ p ] ] || !son[ p ] )
		  son[ p ] = v;//记得要特判第一个儿子
	} 
} 
```   
找出每个节点的深度，父亲，size(即以它为根的子树大小),重儿子(一个节点的所有儿子中size最大的那个节点，最多有一个)
#### 第二步
```cpp   
void dfs2( int p , int tp ){
	top[ p ] = tp;
	id[ p ] = ++tot;
	nw[ tot ] = w[ p ];
	if( son[ p ] )
	  dfs2( son[ p ] , tp );//优先遍历重儿子
	for( register int i = head[ p ] ; i ; i = e[ i ].next ){
		int v = e[ i ].to;
		if( v == fa[ p ] || v == son[ p ] )
		  continue;
		dfs2( v , v );//以轻儿子开始的新链
	}
}
```   
找出每个节点在dfs序里的位置，即id[ p ],dfs序中每个节点的权值，即nw[ tot ],每个节点的top,即依靠“重链”可以“爬升”到的深度最浅的点


------------

### 如何维护   
完成上述操作后，我们可以发现一棵复杂的树的信息已经被保存在了一个相对更有规律的序列里，我们就要靠它来完成所有的复杂操作。
它有以下优秀性质：   
1.一条重链上的点在dfs序中一定是连续的；    
2.子树的dfs序也是连续的；   
这正好符合线段树的口味。
```cpp
struct NODE{
	ll sum,maxn;
	NODE *ls,*rs;
	inline void update(){
		sum = ls->sum + rs->sum;
		maxn = max( ls->maxn , rs->maxn );
	}
	NODE(){
		sum = maxn = 0;
		ls = rs = NULL;
	}
}*root,tree[ N * 4 ],*p = tree;
//这里我用的是指针建树
NODE *build( int l , int r ){
	NODE *nd = ++p;
	if( l == r ){
		nd->sum = nd->maxn = nw[ l ];//记得是nw[],不要打成了w[]
		return nd;
	}
	int mid = ( l + r ) >> 1;
	nd->ls = build( l , mid );
	nd->rs = build( mid + 1 , r );
	nd->update();
	return nd;
}
```


其他操作就是模板了，不再过多叙述


------------

### 核心操作    
下面是树剖的核心操作
无论是链查询还是修改，都要紧紧围绕下面操作
```cpp
void unknown( int x , int y ){//省略号处是某些操作
	......
	while( top[ x ] != top[ y ] ){
		if( dp[ top[ x ] ] < dp[ top[ y ] ] )
		  swap( x , y );
		......
		x = fa[ top[ x ] ];
	}//不断的将top更深的点往上爬升，直到两点的top相同
	if( dp[ x ] > dp[ y ] )
	  swap( x , y );//这里x,y的top已相同
	......
} 
```
至于子树的操作就很简单了，不懂得可以参考我推荐的博客    

------------

讲解就到这里了~~有点水~~
完整代码如下（本人码风清奇，不习惯的dalao可以跳过）   
虽然我的方法可能很弱，但希望能给需要的人一点帮助把

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define N 200000
#define oo 2147483647000
#define BASE 2
int n,m,tot = 0,head[ N ],dp[ N ],size[ N ],fa[ N ],son[ N ],w[ N ],nw[ N ],id[ N ],top[ N ];
//----------------------------------------------------------------
template<class T>
inline void read(T &res)
{
	static char ch;
    T flag = 1;
	while( ( ch = getchar() ) < '0' || ch > '9' )
      if( ch == '-' )
        flag = -1;
    res = ch - 48;
	while( ( ch = getchar() ) >= '0' && ch <= '9' )
      res = res * 10 + ch - 48;
    res *= flag;
}

ll max( ll a , ll b ){
	return a > b ? a : b;
}
//建图部分----------------------------------------------------------------
struct E{
	int to,next;
}e[ N * 4 ];

inline void add( int from , int to ){
	e[ ++tot ].to = to;
	e[ tot ].next = head[ from ];
	head[ from ] = tot;
}
//线段树----------------------------------------------------------------
struct NODE{
	ll sum,maxn;
	NODE *ls,*rs;
	inline void update(){
		sum = ls->sum + rs->sum;
		maxn = max( ls->maxn , rs->maxn );
	}
	NODE(){
		sum = maxn = 0;
		ls = rs = NULL;
	}
}*root,tree[ N * 4 ],*p = tree;

NODE *build( int l , int r ){
	NODE *nd = ++p;
	if( l == r ){
		nd->sum = nd->maxn = nw[ l ];
		return nd;
	}
	int mid = ( l + r ) >> 1;
	nd->ls = build( l , mid );
	nd->rs = build( mid + 1 , r );
	nd->update();
	return nd;
}

ll sum( NODE *nd , int l , int r , int ql , int qr ){
	if( ql <= l && r <= qr ){
		return nd->sum;
	}
	int mid = ( l + r ) >> 1;
	ll res = 0;
	if( ql <= mid )
	  res += sum( nd->ls , l , mid , ql , qr );
	if( qr > mid )
	  res += sum( nd->rs , mid + 1 , r , ql , qr );
	return res;
}//区间求和

ll amax( NODE *nd , int l , int r , int ql , int qr ){
	if( ql <= l && r <= qr ){
		return nd->maxn;
	}
	int mid = ( l + r ) >> 1;
	ll res = -oo;
	if( ql <= mid )
	  res = max( amax( nd->ls , l , mid , ql , qr ) , res );
	if( qr > mid )
	  res = max( res , amax( nd->rs , mid + 1 , r , ql , qr ) );
	return res;
}//区间求最大值

void change( NODE *nd , int l , int r , int x , int add ){
	if( l <= x && x <= r ){
		if( l == r ){
		    nd->sum += add;
		    nd->maxn += add;
		    return;
		}
		int mid = ( l + r ) >>1;
		change( nd->ls , l , mid , x , add );
		change( nd->rs , mid + 1 , r , x , add );
		nd->update();
	}
}//单点修改

ll ask( NODE *nd , int l , int r , int x ){
	if( l == r )
	  return nd->sum;
	int mid = ( l + r ) >> 1;
	if( x <= mid )
	  return ask( nd->ls , l , mid , x );
	else
	  return ask( nd->rs , mid + 1 , r , x );
}//单点查询
//----------------------------------------------------------------
void dfs1( int p ){
	dp[ p ] = dp[ fa[ p ] ] + 1;
	size[ p ] = 1;
	for( register int i = head[ p ] ; i ; i = e[ i ].next ){
		int v = e[ i ].to;
		if( v == fa[ p ] )
		  continue;
		fa[ v ] = p;
		dfs1( v );
		size[ p ] += size[ v ];
		if( size[ v ] > size[ son[ p ] ] || !son[ p ] )
		  son[ p ] = v;
	} 
} 

void dfs2( int p , int tp ){
	top[ p ] = tp;
	id[ p ] = ++tot;
	nw[ tot ] = w[ p ];
	if( son[ p ] )
	  dfs2( son[ p ] , tp );
	for( register int i = head[ p ] ; i ; i = e[ i ].next ){
		int v = e[ i ].to;
		if( v == fa[ p ] || v == son[ p ] )
		  continue;
		dfs2( v , v );
	}
}
//----------------------------------------------------------------
int gat(){
	char c = getchar();
	while( 'A' > c || c > 'Z' )
	  c = getchar();
	int ret = 0;
	ret = ret * BASE + c;
	c = getchar();
	while( 'A' <= c && c <= 'Z' )
	  ret = ret * BASE + c,c = getchar();
	return ret;
}//读入操作
//----------------------------------------------------------------
ll qmax( int x , int y ){
	ll res = -oo;
	while( top[ x ] != top[ y ] ){
		if( dp[ top[ x ] ] < dp[ top[ y ] ] )
		  swap( x , y );
		res = max( res , amax( root , 1 , n , id[ top[ x ] ] , id[ x ] ) );
		x = fa[ top[ x ] ];
	}
	if( dp[ x ] > dp[ y ] )
	  swap( x , y );
	res = max( res , amax( root , 1 , n , id[ x ] , id[ y ] ) );
	return res;
}//链最大值查询

ll qsum( int x , int y ){
	ll res = 0;
	while( top[ x ] != top[ y ] ){
		if( dp[ top[ x ] ] < dp[ top[ y ] ] )
		  swap( x , y );
		res += sum( root , 1 , n , id[ top[ x ] ] , id[ x ] );
		x = fa[ top[ x ] ];
	}
	if( id[ x ] > id[ y ] )
	  swap( x , y );
	res += sum( root , 1 , n , id[ x ] , id[ y ] );
	return res;
}//链の和查询
//----------------------------------------------------------------
int main()
{
	read( n );
	for( register int i = 1 ; i <= n - 1 ; i++ ){
		int x,y;
		read( x ),read( y );
		add( x , y );
		add( y , x );
	}
	for( register int i = 1 ; i <= n ; i++ )
	  read( w[ i ] );
	tot = 0,dfs1( 1 );
	tot = 0,dfs2( 1 , 1 );
	root = build( 1 , n );
	read( m );
	for( register int i = 1 ; i <= m ; i++ ){
		int f;
		f = gat();
		switch( f ){
			case 1174:{//求最大 
				int x,y;
				read( x ),read( y );
				printf( "%lld\n" , qmax( x , y ) );
				break;
			}
			case 1227:{//求和 
				int x,y;
				read( x ),read( y );
				printf( "%lld\n" , qsum( x , y ) );
				break;
			} 
			case 4339:{//单点修改 
				int x,y;
				read( x ),read( y );
                change( root , 1 , n , id[ x ] , y - ask( root , 1 , n , id[ x ] ) );
                //好好品味这一步，对你的树剖的理解的提升很有帮助哦
				break;
			}
		}
	}
	return 0;
}
```

---

## 作者：FREEH (赞：0)

### 【例题】
![例题](https://cdn.luogu.com.cn/upload/pic/29919.png)

### 【算法目标】
- 在$log$级别的时间复杂度内，通过把树分割成一条条链，并用各种数据结构，以加速解决各种树上区间问题。

### 【算法过程】
#### 定义
- 把每个点连出的两条边分为重边和轻边，重边连接子树点数较大的一边，轻边连向另一边。
- 把每个点的两个儿子分为重结点和轻结点，重结点的子树较大，轻结点子树较小。

#### 预处理
- 求出定义内的参数；
- 每个结点最靠近当前结点的重结点top，其中，对于轻结点，top是自己。这一步骤有助于进行“跨越”，以提高速度。
- **每个结点在DFS序下的编号**，这一步骤是使用数据结构优化的关键。**注意**：这里的DFS序必须先搜寻重结点。因为这样可以使重结点都在相邻的地方，便于后面使用数据结构优化。
- 这一步骤可以用两个DFS来实现。

#### 修改与查询
- 对树进行从x到y结点最短路径上所有节点的值更新与查询：
	- 跑一波类似于LCA的算法；
    - 对于重结点，把线段树中它到top的区间更新；
    - 对于轻结点，为了“保持队型”，在线段树中自己的位置更新；
    - 把x或y跳到对应的top。
    - 直到跳到相同的点。
    - 同理，对于查询用相似的操作。

### 【时间复杂度】
- 由于轻结点的个数会随着层数的增加而/2，因此暴力轻结点的次数是logn；由于重结点有线段树优化，因此也是logn；由于树的深度平摊起来也是logn，因此总的时间复杂度是$O(Qlogn)$。

### 【解题反思】
- 在求最大值的时候，要注意负数的情况，必须返回无穷小。

### 【参考程序】
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
#define INF 0x3f3f3f3f
int n,Q,Mod,cnt,rt;
struct Tree{
	int sum,max;
}tree[400005];
struct EDGE{
	int t,next;
}e[400005];
int cur,head[400005],
	d[400005],dep[400005],top[400005],fa[400005],siz[400005],son[400005],
	id[400005],D[400005];

void Wei_Hu(int x)
{
	tree[x].sum=tree[x*2].sum+tree[x*2+1].sum;
	tree[x].max=max(tree[x*2].max,tree[x*2+1].max);
}
void Build(int now,int l,int r)
{
	if (l==r)
	{
		tree[now].sum=d[l];
		tree[now].max=d[l];
		return;
	}
	int mid=((l+r)>>1);
	Build(now*2,l,mid);
	Build(now*2+1,mid+1,r);
	Wei_Hu(now);
}
void Update(int now,int l,int r,int x,int z)
{
	if (l>x||r<x) return;
	if (l==r&&l==x)
	{
		tree[now].max=tree[now].sum=z;
		return;
	}
	int mid=((l+r)>>1);
	if (x<=mid)
		Update(now*2,l,mid,x,z);
	else
		Update(now*2+1,mid+1,r,x,z);
	Wei_Hu(now);
}
int Query_sum(int now,int l,int r,int s,int t)
{
	if (l>t||r<s) return 0;
	if (s<=l&&r<=t)
	{
		return tree[now].sum;
	}
	int mid=((l+r)>>1);
	return Query_sum(now*2,l,mid,s,t)+Query_sum(now*2+1,mid+1,r,s,t);
}
int Query_max(int now,int l,int r,int s,int t)
{
	if (l>t||r<s) return -INF;
	if (s<=l&&r<=t)
	{
		return tree[now].max;
	}
	int mid=((l+r)>>1);
	return max(Query_max(now*2,l,mid,s,t),Query_max(now*2+1,mid+1,r,s,t));
}



void add(int a,int b)
{
	cur++;
	e[cur].t=b;
	e[cur].next=head[a];
	head[a]=cur;
}
void DFS1(int u,int f,int d)
{
	dep[u]=d;
	fa[u]=f;
	siz[u]=1;
	int hson=0;
	for (int h=head[u];h!=-1;h=e[h].next)
	{
		int v=e[h].t;
		if (v==fa[u]) continue;
		DFS1(v,u,d+1);
		siz[u]+=siz[v];
		if (siz[v]>hson)
		{
			hson=siz[v];
			son[u]=v;
		}
	}
}
void DFS2(int u,int Top)
{
	id[u]=++cnt;
	d[cnt]=D[u];
	top[u]=Top;
	if (!son[u])
		return;
	DFS2(son[u],Top);
	for (int h=head[u];h!=-1;h=e[h].next)
	{
		int v=e[h].t;
		if (v==fa[u]||v==son[u])
			continue;
		DFS2(v,v); 
	}
}
int Query_Dis_sum(int x,int y)
{
	int ans=0;
	for (;top[x]!=top[y];x=fa[top[x]])
	{
		if (dep[top[x]]<dep[top[y]])
			swap(x,y);
		ans+=Query_sum(1,1,n,id[top[x]],id[x]);
	}
	if (dep[x]>dep[y])
		swap(x,y);
	ans+=Query_sum(1,1,n,id[x],id[y]);
	return ans;
}
int Query_Dis_max(int x,int y)
{
	int ans=-INF;
	for (;top[x]!=top[y];x=fa[top[x]])
	{
		if (dep[top[x]]<dep[top[y]])
			swap(x,y);
		ans=max(ans,Query_max(1,1,n,id[top[x]],id[x]));
	}
	if (dep[x]>dep[y])
		swap(x,y);
	ans=max(ans,Query_max(1,1,n,id[x],id[y]));
	return ans;
}
int main()
{
	scanf("%d",&n);
	memset(head,-1,sizeof head);
	for (int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	for (int i=1;i<=n;i++)
		scanf("%d",&D[i]);
	for (int i=1;i<=4*n;i++)
		tree[i].max=-INF;
	rt=1;
	DFS1(rt,0,1);
	DFS2(rt,rt);
	Build(1,1,n);
	scanf("%d",&Q);
	while (Q--)
	{
		int x,y;
		char cmd[105];
		scanf("%s%d%d",cmd,&x,&y);
		if (cmd[0]=='C')
		{
			Update(1,1,n,id[x],y);
		}
		else
		if (cmd[1]=='S')
		{
			printf("%d\n",Query_Dis_sum(x,y));
		}
		else
		{
			printf("%d\n",Query_Dis_max(x,y));
		}
	}
	return 0;
}
```

---

## 作者：KingBenQi (赞：0)

树链剖分板子题
模板题都比这个难十倍左右吧
支持单点修改,区间查询求和,求最大值
线段树维护
```
#include<bits/stdc++.h>
#define LL long long
#define rg register
const int N=30005;
const int inf=2147483647;
using namespace std;
inline int gi(){
    char ch=getchar();int x=0,q=0;
    while(ch<'0' || ch>'9') ch=='-'?q=1:0,ch=getchar();
    while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
    return q?(-x):x;
}
class Segement{
public:
	int sum,mx;
};
Segement S[N<<2];
int Next[N<<1],Head[N],V[N<<1],W[N],Fa[N],Size[N],Depth[N],Faedge[N],Hson[N],Id[N],Top[N];
int idcnt,cnt,n;
void Add(int u,int v){
	Next[++cnt]=Head[u];
	V[cnt]=v;
	Head[u]=cnt;
}
void Update(int now){
	int lson=now<<1,rson=now<<1|1;
	S[now].mx=max(S[lson].mx,S[rson].mx);
	S[now].sum=S[lson].sum+S[rson].sum;
	return ;
}
void Modify(int now,int l,int r,int pos,int key){
	if (l==r){
		S[now].mx=S[now].sum=key;
		return ;
	}
	int mid=(l+r)>>1;
	if (pos<=mid)   Modify(now<<1,l,mid,pos,key);
	if (pos>=mid+1) Modify(now<<1|1,mid+1,r,pos,key);
	Update(now);
}
void dfs1(int u,int fa){
	Size[u]=1;Fa[u]=fa;Faedge[u]=W[u];
	for(int i=Head[u];i!=-1;i=Next[i])
	{
		int v=V[i];
		if (v==Fa[u]) continue;
		Depth[v]=Depth[u]+1;
		dfs1(v,u);
		Size[u]+=Size[v];
		if (Size[v]>Size[Hson[u]]) Hson[u]=v;
	}
}
void dfs2(int u,int top){
	Id[u]=++idcnt;
	Modify(1,1,n,idcnt,Faedge[u]);
	Top[u]=top;
	if (Hson[u]==0) return;
	dfs2(Hson[u],top);
	for (int i=Head[u];i!=-1;i=Next[i]){
		int v=V[i];
		if (v!=Fa[u]&&v!=Hson[u]) dfs2(v,v);
	}
	return ;
}
int Query_sum(int now,int l,int r,int L,int R){
	if (L<=l&&R>=r){
		return S[now].sum;
	}
	int ret=0;
	int mid=(l+r)>>1;
	if(L<=mid)ret+=Query_sum(now<<1,l,mid,L,R);
	if(R>mid)ret+=Query_sum(now<<1|1,mid+1,r,L,R);
	return ret;
}
int Query_max(int now,int l,int r,int L,int R){
	if (L<=l&&R>=r){
		return S[now].mx;
	}
	int mid=(l+r)>>1;
	int ret=-inf;
	if(L<=mid)ret=max(ret,Query_max(now<<1,l,mid,L,R));
	if(R>mid)ret=max(ret,Query_max(now<<1|1,mid+1,r,L,R));
	return ret;
}
int QC_max(int u,int v){
	int ret=-inf;
	while (Top[u]!=Top[v]){
		if (Depth[Top[u]]<Depth[Top[v]]) swap(u,v);
		ret=max(ret,Query_max(1,1,n,Id[Top[u]],Id[u]));
		u=Fa[Top[u]];
	}
	if (Depth[u]>Depth[v]) swap(u,v);
	ret=max(ret,Query_max(1,1,n,Id[u],Id[v]));
	return ret;
}
int QC_sum(int u,int v){
	int ret=0;
	while (Top[u]!=Top[v]){
		if (Depth[Top[u]]<Depth[Top[v]]) swap(u,v);
		ret+=Query_sum(1,1,n,Id[Top[u]],Id[u]);
		u=Fa[Top[u]];
	}
	if (Depth[u]>Depth[v]) swap(u,v);
	ret+=Query_sum(1,1,n,Id[u],Id[v]);
	return ret;
}
int main(){
	//freopen("count.in","r",stdin);
	//freopen("count.out","w",stdout);
	memset(Head,-1,sizeof(Head));
	n=gi();
	for(int i=1,u,v;i<n;i++){
		u=gi();v=gi();
		Add(u,v);Add(v,u);
	}
	for(int i=1;i<=n;i++) W[i]=gi();
    Depth[1]=1;
 	dfs1(1,0);
	dfs2(1,1);
	int q=gi();
	char opt[10];
	while(q){
		q--;
		scanf(" %s",opt);
		if(opt[0]=='C'){
			int pos,key;
			pos=gi();key=gi();
			Modify(1,1,n,Id[pos],key);
		}
		if(opt[1]=='S'){
			int u,v;
			u=gi();v=gi();
			cout<<QC_sum(u,v)<<endl;
		}
		if(opt[1]=='M'){
			int u,v;
			u=gi();v=gi();
			cout<<QC_max(u,v)<<endl;
		}
	}
    return 0;
}

```

---

## 作者：ww3113306 (赞：0)

树链剖分模板图
感觉常数不算特别大吧
不开O2 1012ms
感觉自己写的还是挺清晰的，，，，
但是不知道为什么我的代码每次都特别长。。。
这里简单讲一下做法
先剖分一下，然后线段树维护区间最大值和区间和
最后写一个单点修改就可以了
，，记得要注意权值是有负数的！

	#include<bits/stdc++.h>
	using namespace std;
	#define AC 40100
	#define ACway 80010
	#define R register int
	int ans,n,m,num;
	int power[AC],deep[AC],size[AC],son[AC],top[AC],father[AC];
	int date[ACway],Next[ACway],Head[AC],tot;//链式前向星
	int sum[ACway],maxn[ACway],l[ACway],r[ACway],cnt,id[AC],repower[AC];

	inline int read()//读入优化
	{
		int x=0;char c;bool z=false;
		while(isspace(c=getchar()));
		if(c=='-')z=true,c=getchar();
		while(c>='0' && c<='9')x=x*10+c-'0',c=getchar();
		if(!z)return x;
		else return -x;
	}

	inline void upmax(int &a,int b)
	{
		if(b>a) a=b;
	}

	inline void add(int f,int w)//加双向边
	{
	    date[++tot]=w,Next[tot]=Head[f],Head[f]=tot;
	    date[++tot]=f,Next[tot]=Head[w],Head[w]=tot;
	}

	void pre()
	{
		R a,b;
		n=read();
		memset(maxn,128,sizeof(maxn));
		for(R i=1;i<n;i++)
		{
			a=read(),b=read();
			add(a,b);
		}
		for(R i=1;i<=n;i++) power[i]=read();
	}

	void dfs1(int x,int fa,int dep)//get size && son && deep && father
	{
		R maxson=-1,now;//maxson记录重儿子的大小
		deep[x]=dep;
		size[x]=1;
		father[x]=fa;
		for(R i=Head[x]; i ;i=Next[i])
		{
			now=date[i];
			if(now!=fa)//跳过父亲
			{
				dfs1(now,x,dep+1);
				size[x]+=size[now];
				if(size[now] > maxson) son[x]=now,maxson=size[now];//记录重儿子
			}
		}
	}

	void dfs2(int x,int topx)//get repower && top && id
	{
		R now;
		id[x]=++cnt;//记录新id
		repower[cnt]=power[x];//记录对应权值
		top[x]=topx;
		if(!son[x])return ;//如果没有儿子了就返回
		dfs2(son[x],topx);
		for(R i=Head[x]; i ;i=Next[i])
		{
			now=date[i];
			if(now != father[x] && now !=son[x])//跳过重儿子和父亲
			{
				dfs2(now,now);//新拉一条链
			}
		}
	}	

	void built(int x,int ll,int rr)//递归建树
	{
		int mid=(ll+rr)/2;
		l[x]=ll,r[x]=rr;
		if(ll==rr)
		{
			sum[x]=repower[ll];
			maxn[x]=repower[ll];
			return ;
		}
		built(x*2,ll,mid);
		built(x*2+1,mid+1,rr);
		sum[x]=sum[x*2]+sum[x*2+1];
		upmax(maxn[x],maxn[x*2]);
		upmax(maxn[x],maxn[x*2+1]);
	}

	void change(int want)//单点修改
	{
		R mid,x=1;
		while(1)//找到这个节点的下标 
		{
			mid=(l[x]+r[x])/2;
			if(l[x]==r[x])	break;//如果找到目标节点就退出,因为是单点修改，所以碰到叶节点一定就是目标节点了
			x*=2;
			//if(want<=mid) x*=2;	
			if(want>=mid+1) ++x;
		}
		maxn[x]=num;
		sum[x]=num;
		x/=2;
		while(x)
		{
			sum[x]=sum[x*2]+sum[x*2+1];//重新获取权值和
			maxn[x]=-30010;//error!!!不能直接取max，要先清空原值error!!!权值有负的！！！
			upmax(maxn[x],maxn[x*2]);
			upmax(maxn[x],maxn[x*2+1]);		
			x/=2;//找到父亲
		}
	}

	void searchmax(int x,int ll,int rr)//区间最大值查询
	{
		R mid;
		if(l[x]==ll && r[x]==rr)
		{
			upmax(ans,maxn[x]);
			return ;
		}
		mid=(l[x]+r[x])/2;
		if(rr<=mid)searchmax(x*2,ll,rr);
		else if(ll>=mid+1)searchmax(x*2+1,ll,rr);
		else
		{
			searchmax(x*2,ll,mid);
			searchmax(x*2+1,mid+1,rr);
		}
	}

	void searchsum(int x,int ll,int rr)//区间和查询
	{
		R mid;
		if(l[x]==ll && r[x]==rr)
		{
			ans+=sum[x];
			return ;
		}
		mid=(l[x]+r[x])/2;
		if(rr<=mid)searchsum(x*2,ll,rr);
		else if(ll>=mid+1)searchsum(x*2+1,ll,rr);
		else
		{
			searchsum(x*2,ll,mid);
			searchsum(x*2+1,mid+1,rr);
		}
	}

	void getmax(int x,int y)
	{
		ans=-30100;
		while(top[x]!=top[y])
		{
			if(deep[top[x]] < deep[top[y]])	swap(x,y);//先处理深的error!!!应该是先处理top深的
			searchmax(1,id[top[x]],id[x]);//浅的标号小
			x=father[top[x]];
		}
		if(deep[x] < deep[y]) searchmax(1,id[x],id[y]);
		else searchmax(1,id[y],id[x]);
		printf("%d\n",ans);
	}

	void getsum(int x,int y)
	{
		ans=0;
		while(top[x]!=top[y])
		{
			if(deep[top[x]] < deep[top[y]])	swap(x,y);//error！！！先处理top深的
			searchsum(1,id[top[x]],id[x]);
			x=father[top[x]];
		}
		if(deep[x] < deep[y]) searchsum(1,id[x],id[y]);
		else searchsum(1,id[y],id[x]);
		printf("%d\n",ans);
	}
	
	void work()
	{
		char c[10];
		R a,b;
		m=read();
		for(R i=1;i<=m;i++)
		{
			scanf("%s",c+1);
			if(c[1]=='C')//单点修改
			{
				a=read(),num=read();
				change(id[a]);
			}
			else if(c[2]=='M')//询问最大值
			{
				a=read(),b=read();
				getmax(a,b);
			}
			else //询问权值和
			{
				a=read(),b=read();
				getsum(a,b);
			}
		}
	}

	int main()
	{
		freopen("in.in","r",stdin);
		pre();
		dfs1(1,0,1);
		dfs2(1,1);
		built(1,1,cnt);
		work();
		fclose(stdin);
		return 0;
	}

---

## 作者：DimensionTripper (赞：0)

基础树剖（从[P3178](https://www.luogu.org/problemnew/show/P3178)的代码稍作修改便可A掉
这里和3178差别在于线段树的过程不同和一个deep数组，具体看代码
```cpp
#include <bits/stdc++.h>
#pragma GCC optimize(3)//手开O3の日常
#define N 100010
using namespace std;
int n,m,fr,t,a,c,data[N],Size[N],num,p[2*N],fa[N],id,out[2*N],pos[2*N],h[2*N],belong[2*N],b[2*N],nt[2*N],son[N*2],deep[2*N];
char s[10];
struct node
{
    int left,right,mx;
    long long sum,val;
};struct node tree[4*N];//线段树
void pushdown(int p)
{
    if(tree[p].val!=0)
    {
        tree[2*p].val=tree[p].val;
        tree[2*p+1].val=tree[p].val;
        tree[2*p].sum=(tree[2*p].right-tree[2*p].left+1)*tree[p].val;
        tree[2*p+1].sum=(tree[2*p+1].right-tree[2*p+1].left+1)*tree[p].val;
        tree[p].val=0;
    }
}//lazy tag的下放
void dfs(int x,int dep)
{
    deep[x]=dep;
    Size[x]=1;
    int e=p[x];
    while(e>0)
    {
        int k=b[e];
        if(fa[x]!=k)
        {
            fa[k]=x;//记录每个节点的父节点，方便向上跳
            dfs(k,dep+1);
            if(Size[k]>Size[son[x]])
                son[x]=k;//不断更新该节点的重儿子
            Size[x]+=Size[k];//更新该节点下方的节点数
        }
        e=nt[e];
    }
}//搜索确定每个节点的深度与其下的结点个数
void DFS(int x,int bh)//bh为该节点所属重链的编号(编号为该重链起点编号
{
    id++;
    pos[x]=id;//搜索序记录
    out[x]=id;//这个数组请忽视(做3178后忘了改QAQ
    h[id]=x;//线段树上的位置
    int e=p[x];
    int k=0;
    belong[x]=bh;//记录每个节点所属的重链编号
    if(son[x])
    {
        DFS(son[x],bh);//优先搜索重儿子可得到重链
        out[x]=max(out[x],out[son[x]]);
    }
    e=p[x];
    while(e>0)
    {
        int kk=b[e];
        if(fa[x]!=kk&&kk!=son[x])
        {
            DFS(kk,kk);
            out[x]=max(out[x],out[kk]);
        }
        e=nt[e];
    }//搜索轻链
}
void add(int u,int v)
{
    ++num;
    b[num]=v;
    nt[num]=p[u];
    p[u]=num;
}//前向星存图
void build(int p,int l,int r)
{
    tree[p].left=l;
    tree[p].right=r;
    if(l==r)
    {
        tree[p].sum=data[h[l]];
        tree[p].mx=data[h[l]];
        return;
    }
    int mid=(l+r)/2;
    build(2*p,l,mid);
    build(2*p+1,mid+1,r);
    tree[p].sum=tree[2*p].sum+tree[2*p+1].sum;
    tree[p].mx=max(tree[2*p].mx,tree[2*p+1].mx);
}//建树
void change(int p,int l,int r,long long d)
{
    if(tree[p].left==l&&tree[p].right==r)
    {
        tree[p].sum=(r-l+1)*d;
        tree[p].mx=d;
        tree[p].val=d;
        return;
    }
    pushdown(p);
    int mid=(tree[p].left+tree[p].right)/2;
    if(r<=mid)
        change(2*p,l,r,d);
    else if(l>mid)
        change(2*p+1,l,r,d);
    else
    {
        change(2*p,l,mid,d);
        change(2*p+1,mid+1,r,d);
    }
    tree[p].sum=tree[2*p].sum+tree[2*p+1].sum;
    tree[p].mx=max(tree[2*p].mx,tree[2*p+1].mx);
}//线段树修改操作(注意此处要同时维护区间最大值与区间和
long long query(int p,int l,int r)
{
    if(tree[p].left==l&&tree[p].right==r)
        return tree[p].sum;
    pushdown(p);
    int mid=(tree[p].left+tree[p].right)/2;
    if(r<=mid)
        return query(2*p,l,r);
    else if(l>mid)
        return query(2*p+1,l,r);
    else
        return query(2*p,l,mid)+query(2*p+1,mid+1,r);
}//查询区间和
int Query(int p,int l,int r)
{
    if(tree[p].left==l&&tree[p].right==r)
        return tree[p].mx;
    pushdown(p);
    int mid=(tree[p].left+tree[p].right)/2;
    if(r<=mid)
        return Query(2*p,l,r);
    else if(l>mid)
        return Query(2*p+1,l,r);
    else
        return max(Query(2*p,l,mid),Query(2*p+1,mid+1,r));
}//查询区间最大值
long long work(int x,int y)
{
    long long sum=0;
    while(belong[x]!=belong[y])
    {
        if(deep[belong[x]]<deep[belong[y]])
            swap(x,y);
        sum+=query(1,pos[belong[x]],pos[x]);
        x=fa[belong[x]];
    }
    if(deep[x]>deep[y])
        swap(x,y);
    sum+=query(1,pos[x],pos[y]);
    return sum;
}//QSUM的操作（解释见下）
int Work(int x,int y)
{
    int ans=-214748;
    while(belong[x]!=belong[y])
    {
        if(deep[belong[x]]<deep[belong[y]])
            swap(x,y);//比较x和y所属重链起点的深浅，将较浅的向上跳
        ans=max(ans,Query(1,pos[belong[x]],pos[x]));
        x=fa[belong[x]];
    }//如果x与y不在同一重链中，就重复执行操作
    if(deep[x]>deep[y])
        swap(x,y);
    ans=max(ans,Query(1,pos[x],pos[y]));//x与y在同一重链中最后进行一次操作
    return ans;
}//QMAX的操作
int main()
{
    scanf("%d",&n);
    for(int i=1;i<n;i++)
    {
        scanf("%d%d",&fr,&t);
        add(fr,t);
        add(t,fr);
    }
    for(int i=1;i<=n;i++)
        scanf("%d",&data[i]);
    dfs(1,1);
    DFS(1,1);//先进行搜索确定了线段树上的编号再建树
    build(1,1,n);
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%s",s);
        if(s[1]=='H')
        {
            scanf("%d%d",&a,&c);
            change(1,pos[a],pos[a],c);
        }
        else if(s[1]=='M')
        {
            scanf("%d%d",&a,&c);
            printf("%d\n",Work(a,c));
        }
        else
        {
            scanf("%d%d",&a,&c);
            printf("%lld\n",work(a,c));
        }
    }
    return 0;
}
```
然而跑的很慢
[1208ms 7.92Mb](https://www.luogu.org/record/show?rid=5654505)

蒟蒻第一次发紫题题解，有解释的不清楚的地方望各位神犇谅解

---

## 作者：斯德哥尔摩 (赞：0)

树链剖分练手题，打一打模板就好了。

注意：

1.线段树维护两个值应该不用多说，不会线段树的自行百度。。。

2.树剖的序号！=节点号，这个坑了我半小时。。。

3.线段树开4倍。。。

话说这年头用 宏定义 的人怎么这么少。。。

还有，树剖是个好东东。。。

附代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define LSON rt<<1
#define RSON rt<<1|1
#define DATA1(x) b[x].data1
#define DATA2(x) b[x].data2
#define LSIDE(x) b[x].l
#define RSIDE(x) b[x].r//线段树基本
#define MAXN 30010
#define MAX 999999999//极值
using namespace std;
int n,m,c=1,d=1;
int head[MAXN],deep[MAXN],size[MAXN],son[MAXN],top[MAXN],fa[MAXN],id[MAXN];
struct node1{//前向星存图没话说
    int next,to;
}a[MAXN<<1];
struct node2{//线段树没话说
    int data1,data2;
    int l,r;
}b[MAXN<<2];
inline int read(){//二话不说上读优。。。
    int date=0,w=1;char c=0;
    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
    while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
    return date*w;
}
inline int max(const int x,const int y){if(x<y)return y;return x;}//感觉 STL 不靠谱，于是手写
void pushup(int rt){//上传
    DATA1(rt)=max(DATA1(LSON),DATA1(RSON));
    DATA2(rt)=DATA2(LSON)+DATA2(RSON);
}
void buildtree(int l,int r,int rt){//建树
    int mid;
    LSIDE(rt)=l;
    RSIDE(rt)=r;
    if(l==r){
        DATA1(rt)=DATA2(rt)=0;//直接赋为0，也可以直接修改，不过还要再开一个数组，就像楼下管理员一样
        return;
    }
    mid=l+r>>1;
    buildtree(l,mid,LSON);
    buildtree(mid+1,r,RSON);
    pushup(rt);
}
void update(int l,int r,int c,int rt){//单点修改
    int mid;
    if(l<=LSIDE(rt)&&RSIDE(rt)<=r){
        DATA1(rt)=DATA2(rt)=c;//直接付就好啦
        return;
    }
    mid=LSIDE(rt)+RSIDE(rt)>>1;
    if(l<=mid)update(l,r,c,LSON);
    if(mid<r)update(l,r,c,RSON);
    pushup(rt);
}
int query1(int l,int r,int rt){//求最值
    int mid,ans=-MAX;//初值是极小值，不是0（巨坑。。。）
    if(l<=LSIDE(rt)&&RSIDE(rt)<=r)
    return DATA1(rt);
    mid=LSIDE(rt)+RSIDE(rt)>>1;
    if(l<=mid)ans=max(ans,query1(l,r,LSON));
    if(mid<r)ans=max(ans,query1(l,r,RSON));
    return ans;
}
int query2(int l,int r,int rt){//求和值
    int mid,ans=0;
    if(l<=LSIDE(rt)&&RSIDE(rt)<=r)
    return DATA2(rt);
    mid=LSIDE(rt)+RSIDE(rt)>>1;
    if(l<=mid)ans+=query2(l,r,LSON);
    if(mid<r)ans+=query2(l,r,RSON);
    return ans;
}
void add(int u,int v){//加边
    a[c].to=v;
    a[c].next=head[u];
    head[u]=c++;
    a[c].to=u;
    a[c].next=head[v];
    head[v]=c++;
}
void dfs1(int rt){
    son[rt]=0;size[rt]=1;
    for(int i=head[rt];i;i=a[i].next){
        int will=a[i].to;
        if(!deep[will]){
            deep[will]=deep[rt]+1;
            fa[will]=rt;
            dfs1(will);
            size[rt]+=size[will];
            if(size[will]>size[son[rt]])son[rt]=will;
        }
    }
}
void dfs2(int rt,int f){//树剖2个 dfs 不用多说了吧
    id[rt]=d++;top[rt]=f;
    if(son[rt])dfs2(son[rt],f);
    for(int i=head[rt];i;i=a[i].next){
        int will=a[i].to;
        if(will!=son[rt]&&will!=fa[rt])
        dfs2(will,will);
    }
}
void work1(int x,int y){//树上修改，好像有点多事了。。。
    update(id[x],id[x],y,1);
    return;
}
void work2(int x,int y){//求最值
    int s=-MAX;
    while(top[x]!=top[y]){
        if(deep[top[x]]<deep[top[y]])swap(x,y);
        s=max(s,query1(id[top[x]],id[x],1));
        x=fa[top[x]];
    }
    if(deep[x]>deep[y])swap(x,y);
    s=max(s,query1(id[x],id[y],1));//注意不用判断x与y是否不等
    printf("%d\n",s);
    return;
}
void work3(int x,int y){//求和值
    int s=0;
    while(top[x]!=top[y]){
        if(deep[top[x]]<deep[top[y]])swap(x,y);
        s+=query2(id[top[x]],id[x],1);
        x=fa[top[x]];
    }
    if(deep[x]>deep[y])swap(x,y);
    s+=query2(id[x],id[y],1);//注意不用判断x与y是否不等
    printf("%d\n",s);
    return;
}
void work(){//处理问题
    char ch[10];
    int x,y;
    m=read();
    while(m--){
        scanf("%s",ch);x=read();y=read();
        if(ch[0]=='C')work1(x,y);
        if(ch[1]=='M')work2(x,y);
        if(ch[1]=='S')work3(x,y);
    }
}
void init(){//预处理+读入
    int u,v,w;
    n=read();
    for(int i=1;i<n;i++){
        u=read();v=read();
        add(u,v);
    }
    deep[1]=fa[1]=1;
    dfs1(1);
    dfs2(1,1);
    buildtree(1,n,1);
    for(int i=1;i<=n;i++){
        w=read();
        update(id[i],id[i],w,1);//建完树再插入
    }
    work();
}
int main(){//主函数So easy！
    init();
    return 0;
}

```

---

## 作者：_bestknife (赞：0)

动态树,直接splay，由于动态树本来不适合维护静态，但卡卡常还是很快的，以下是AC代码，希望可以作为LCT模板题参考



```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#define L 25
#define M 30001
#define l(h) (ch[h][0])
#define f(h) (fa[h])
#define r(h) (ch[h][1])
#define sum(h) sum[h]
#define Q inline
#define R register
#define SET(A,B) memset(A,B,sizeof(A))
using namespace std;
int sum[M], fa[M], ch[M][2], key[M], rev[M];
int bgn[M], nxt[M<<1], to[M<<1], e, max_[M], sta[M], sta_siz;
Q int chkmax(int a,int b) {return a > b ? a : b;}
int cmp(int a,int b) {return (a ^ b) ? 0 : 1;}
Q int isroot(int h) {return (l(f(h))^h && r(f(h))^h);}
Q void swap(int &x, int &y) {int z = x; x = y; y = z;}
struct LCT
{
  void maintain(int h)
  {
      sum[h] = key[h]; max_[h] = key[h];
      if(l(h)) sum[h] += sum(l(h)); if(l(h)) max_[h] = chkmax(max_[l(h)], max_[h]);
      if(r(h)) sum[h] += sum(r(h)); if(r(h)) max_[h] = chkmax(max_[r(h)], max_[h]);
  }
  void revtag(int h) {rev[h] ^= 1; swap(l(h), r(h));}
  void pushdown(int h)
  {
      if(rev[h])
      {
        rev[h] = 0;
        if(l(h)) revtag(l(h));
        if(r(h)) revtag(r(h));
    }
  }
  void pushroad(int h)
  {
      sta_siz = 0;
     for(int i=h; ;i=f(i)) {sta[++sta_siz] = i; if(isroot(i))break;}
      for(int i=sta_siz; i>=1; --i) pushdown(sta[i]);
  }
  void rotate(int h)
  {
      int f = f(h), g = f(f), c=cmp(h,r(f));
      if(!isroot(f)) {ch[g][cmp(f,r(g))] = h;} f(h) = g; f(f) = h;
      f(ch[h][!c]) = f;
      ch[f][c] = ch[h][!c];
      ch[h][!c] = f; 
      maintain(f); maintain(h);
  }
  void splay(int h)
  {
      pushroad(h);
      while(!isroot(h))
      {
        if(!isroot(f(h))) rotate(h);
        rotate(h);    
      }
  }
  void access(int x)
  {
    int y = 0;
    while(x)
    {
        splay(x);
        r(x) = y;
        maintain(x);
        y = x, x = f(x);
    }
  }
  void chanroot(int x)
  {
      access(x), splay(x), revtag(x);
  }
  void cut(int x,int y)
  {
      chanroot(x), access(y), splay(y), f(l(y)) = 0; l(y) = 0;
  }
  void link(int x,int y)
  {
      chanroot(x), f(x) = y; splay(y), maintain(y);
  }
  int findroot(int x)
  {
      access(x), splay(x); while(l(x)) x = l(x); return x;
  }
  void init()
  {
      SET(bgn, 0); e = 0; SET(max_,0); 
      SET(key,0), SET(sum,0); SET(ch, 0), SET(fa, 0), SET(rev, 0);
  }
  void Updateroad(int x, int y)
  {
      access(x), splay(x), key[x] = y;
  }
  int askroad(int x,int y)
  {
      chanroot(x), access(y), splay(y); return sum[y];
  }
  int askmaxroad(int x,int y)
  {
      chanroot(x), access(y), splay(y); return max_[y];
  }
} jun;
struct Graph
{
  void add(int x,int y) {to[++e] = y; nxt[e] = bgn[x]; bgn[x] = e;}
  void dfs(int x)
  {
      for(register int i=bgn[x]; i; i=nxt[i])
      {
        int y = to[i]; if(y == f(x)) continue;
        f(y) = x; dfs(y);    
    }
  }
} g;
inline int read()
{
  int x = 0;
  int d = 1;
  char ch = getchar();
  if(ch == '-') d = -1;
  while(ch > '9' || ch < '0'){ ch =getchar(); if(cmp(ch,'-')) d = -1;}
  while(ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
  return x * d;
}
int main()
{
  char str[L];
  int n, x, y, m;
  if(1)
  {
      n = read();
      for(R int i=1; i<n; ++i) {x = read(), y = read(), g.add(x,y), g.add(y,x);}
      g.dfs(1);
      for(R int i=1; i<=n; ++i) key[i] = read();
      m = read();
      for(R int i=1; i<=m; ++i)
      {
        scanf("%s", str);
        x = read(); y = read();
        if(str[1] == 'S') printf("%d\n",jun.askroad(x,y));
        if(str[1] == 'M') printf("%d\n",jun.askmaxroad(x,y));
        if(str[1] == 'H') jun.Updateroad(x,y);
      } 
  }
}
```

---

## 作者：magolor (赞：0)

树链剖分，算是比较快的版本之一。

建树和修改用的是zkw线段树写法，由于太弱……查询不会，使用的普通线段树写法。








        




    



```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 60000
#define INF 0x3f3f3f3f
#define mx(x) t[x].mx
#define sm(x) t[x].sm
#define lc(x) (x<<1)
#define rc(x) (x<<1|1)
#define mid ((lef+rig)>>1)
#define gc() getchar()
inline int read(int ans = 0, int sgn = ' ', int ch = gc())
{
    for(;ch < '0' || ch > '9'; sgn=ch,ch=gc());
    for(;ch >='0' && ch <='9'; (ans*=10)+=ch-'0',ch=gc());
    return sgn-'-' ? ans : -ans;
}
struct Edge
{
    int to,nex;
    Edge(){}
    Edge(int _to, int _nex):to(_to),nex(_nex){}
}e[MAXN+5];
int first[MAXN+5], fa[MAXN+5], dep[MAXN+5], sz[MAXN+5], heavy[MAXN+5], pos[MAXN+5], top[MAXN+5], tot, n, dfn = 1, N;
char s[10];
inline void Add(int a, int b)
{
    e[tot] = Edge(b,first[a]);
    first[a] = tot++;
    return;
}
void DFS1(int p)
{
    sz[p] = 1;
    for(register int u = first[p], v; u+1; u = e[u].nex)
        if((v=e[u].to) != fa[p])
        {
            fa[v] = p, dep[v] = dep[p]+1, DFS1(v), sz[p] += sz[v];
            if(!heavy[p] || sz[v] > sz[heavy[p]])
                heavy[p] = v;
        }
    return;
}
void DFS2(int p)
{
    pos[p] = dfn++;
    if(heavy[p])
        top[heavy[p]] = top[p], DFS2(heavy[p]);
    for(register int u = first[p], v; u+1; u = e[u].nex)
        if((v=e[u].to) != fa[p] && v != heavy[p])
            top[v] = v, DFS2(v);
}
struct Node
{
    int mx,sm;
    Node()
    {
        sm = 0, mx = -INF;
    }
}t[(1<<16)+MAXN+5], ans;
inline Node Merge(Node a, Node b)
{
    a.sm += b.sm, a.mx = max(a.mx,b.mx);
    return a;
}
inline void Push(int p)
{
    mx(p) = max(mx(lc(p)),mx(rc(p))), sm(p) = sm(lc(p))+sm(rc(p));
    return;
}
Node Query(int p, int lef, int rig, int L, int R)
{
    if(L == lef && R == rig)
        return t[p];
    if(R <= mid)
        return Query(lc(p),lef,mid,L,R);
    if(L >  mid)
        return Query(rc(p),mid+1,rig,L,R);
    return Merge( Query(lc(p),lef,mid,L,mid) , Query(rc(p),mid+1,rig,mid+1,R) );
}
inline void Edit(int x, int v)
{
    for(x += N-1, mx(x) = sm(x) = v, x >>= 1; x; Push(x), x >>= 1);
    return;
}
inline void Q(int a, int b)
{
    for(ans.sm = 0, ans.mx = -INF; top[a] != top[b]; )
    {
        if(dep[top[a]] < dep[top[b]])
            a^=b^=a^=b;
        ans = Merge(ans,Query(1,1,N,pos[top[a]],pos[a])), a = fa[top[a]];
    }
    if(dep[a] < dep[b])
        a^=b^=a^=b;
    ans = Merge(ans,Query(1,1,N,pos[b],pos[a]));
    return;
}
int main()
{
    for(n = read(), memset(first,-1,sizeof(first)), N = 1; N < n; N <<= 1);
    for(register int i = 2, a, b; i <= n; i++)
        a = read(), b = read(), Add(a,b), Add(b,a);
    fa[1] = 0, dep[1] = 1, top[1] = 1, sz[1] = 1, DFS1(1), DFS2(1);
    for(register int i = 1; i <= n; i++)
        mx(pos[i]+N-1) = sm(pos[i]+N-1) = read();
    for(register int i = N-1; i >= 1; Push(i), i--);
    for(register int m = read(), a, b; m--; )
        switch(scanf("%s",s), a = read(), b = read(), s[1])
        {
            case 'M' :    Q(a,b), printf("%d\n",ans.mx);    break;
            case 'S' :    Q(a,b), printf("%d\n",ans.sm);    break;
            case 'H' :    Edit(pos[a],b);                    break;
        }
    return 0;
}
```

---

## 作者：lezdzh (赞：0)

树链剖分，用线段树维护每条链。

```cpp

#include<iostream>
#include<cstdio>
#include<vector>
#define N 30001

using namespace std;

struct node{int l,r,ls,rs,s,c;}tr[2*N];int t=0;
int nw(int l,int r){tr[++t]=(node){l,r,0,0,0,0};return t;}
void xg(int o,int p,int c){
    if(tr[o].l==tr[o].r){tr[o].s=tr[o].c=c;return;}
    int mid=(tr[o].l+tr[o].r)>>1;
    if(p<=mid)xg(tr[o].ls?tr[o].ls:tr[o].ls=nw(tr[o].l,mid),p,c);
    else xg(tr[o].rs?tr[o].rs:tr[o].rs=nw(mid+1,tr[o].r),p,c);
    tr[o].s=tr[tr[o].ls].s+tr[tr[o].rs].s;
    tr[o].c=max(tr[tr[o].ls].c,tr[tr[o].rs].c);}
int cxm(int o,int l,int r){
    if(tr[o].l==l&&tr[o].r==r)return tr[o].c;
    int mid=(tr[o].l+tr[o].r)>>1;
    if(l>mid)return cxm(tr[o].rs,l,r);
    if(r<=mid)return cxm(tr[o].ls,l,r);
    return max(cxm(tr[o].ls,l,mid),cxm(tr[o].rs,mid+1,r));}
int cxs(int o,int l,int r){
    if(tr[o].l==l&&tr[o].r==r)return tr[o].s;
    int mid=(tr[o].l+tr[o].r)>>1;
    if(l>mid)return cxs(tr[o].rs,l,r);
    if(r<=mid)return cxs(tr[o].ls,l,r);
    return cxs(tr[o].ls,l,mid)+cxs(tr[o].rs,mid+1,r);}

int n,q;
int f[N],c[N],s[N],d[N],p[N],hd[N];
vector<int>g[N];
void slpf(){
    for(s[d[s[0]=1]=1]=1;s[0];){
        int u=s[s[0]];if(c[u]==g[u].size()){c[u]=1;s[0]--;
            for(int i=0;i<g[u].size();i++)if(g[u][i]^f[u])c[u]+=c[g[u][i]];}
        for(int& i=c[u];i<g[u].size();i++)if(g[u][i]^f[u]){
            d[s[++s[0]]=g[u][i]]=d[f[g[u][i]]=u]+1;i++;break;}
    }
    for(s[s[0]=1]=1;s[0];){
        int u=s[s[0]--],y=0;p[u]=++p[0];if(!hd[u])hd[u]=u;
        for(int i=0;i<g[u].size();i++)if(g[u][i]^f[u]&&c[g[u][i]]>c[y])y=g[u][i];
        for(int i=0;i<g[u].size();i++)if(g[u][i]^f[u]&&g[u][i]^y)s[++s[0]]=g[u][i];
        if(!y)continue;s[++s[0]]=y;hd[y]=hd[u];
    }
}

int main(){
    cin>>n;nw(1,n);tr[0].c=-2e9;
    for(int i=1;i<n;i++){
        int x,y;scanf("%d%d",&x,&y);
        g[x].push_back(y);g[y].push_back(x);
    }
    slpf();for(int i=1;i<=n;i++)scanf("%d",&q),xg(1,p[i],q);
    for(cin>>q;q--;){
        char s[7];int x,y;scanf("%s%d%d",s,&x,&y);
        if(s[1]=='H')xg(1,p[x],y);
        if(s[1]=='M'){
            int ans=-2e9;
            while(hd[x]!=hd[y]){
                if(d[hd[x]]<d[hd[y]])swap(x,y);
                ans=max(ans,cxm(1,p[hd[x]],p[x]));
                x=f[hd[x]];
            }
            ans=max(ans,cxm(1,min(p[x],p[y]),max(p[x],p[y])));
            printf("%d\n",ans);
        }
        if(s[1]=='S'){
            int ans=0;
            while(hd[x]!=hd[y]){
                if(d[hd[x]]<d[hd[y]])swap(x,y);
                ans+=cxs(1,p[hd[x]],p[x]);
                x=f[hd[x]];
            }
            ans+=cxs(1,min(p[x],p[y]),max(p[x],p[y]));
            printf("%d\n",ans);
        }
    }
}

```

---

## 作者：笑细 (赞：0)

这题思路其实比较简单，只是磨叽一点。

首先树链剖分，在dfs序，注意将重链的点连在一起，用线段树维护一下即可

别忘了开long long！

注意一下，题目中有可能出现负值，故ans负值为负无穷。

而ans大小为long long,应该写0xefefefefefefefef我当时写0xefefefef狂WA。T_T

看代码吧：

```
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 30004
using namespace std;
typedef long long ll;
char opt[21];
int n,T,fir[N],sec[N],tot,low[N],fa[N],siz[N];
int to[N<<1],nxt[N<<1],head[N],cnt,sn[N],tp[N];
ll ml[N<<2],vl[N<<2],a[N];

void add(int x,int y)
{
    to[++cnt]=y,nxt[cnt]=head[x],head[x]=cnt;
}

void dfs1(int now,int pre)
{
    low[now]=low[pre]+1,fa[now]=pre,siz[now]=1;
    for(int i=head[now];i;i=nxt[i])
    {
        int y=to[i];
        if(y!=pre)
        {
            dfs1(y,now);
            siz[now]+=siz[y];
            if(siz[y]>siz[sn[now]])
            {
                sn[now]=y;
            }
        }
    }
}

void dfs2(int now,int tpo)
{
    tp[now]=tpo;
    for(int i=head[now];i;i=nxt[i])
    {
        int y=to[i];
        if(y!=fa[now])
        {
            if(y==sn[now])
            {
                dfs2(y,tpo);
            }else
            {
                dfs2(y,y);
            }
        }
    }
}

void dfs3(int now)
{
    fir[now]=++tot;
    if(sn[now])
    {
        dfs3(sn[now]);
    }
    for(int i=head[now];i;i=nxt[i])
    {
        int y=to[i];
        if(y!=fa[now]&&y!=sn[now])
        {
            dfs3(y);
        }
    }
    sec[now]=tot;
}

void build(int lx,int rx,int nx)
{
    if(lx==rx)
    {
        ml[nx]=vl[nx]=a[lx];
        return;
    }
    int mid=(lx+rx)>>1;
    build(lx,mid,nx<<1);
    build(mid+1,rx,(nx<<1)|1);
    vl[nx]=vl[nx<<1]+vl[(nx<<1)|1],ml[nx]=max(ml[nx<<1],ml[(nx<<1)|1]);
}

void update(int to,ll aim,int lx,int rx,int nx)
{
    if(lx==rx)
    {
        vl[nx]=ml[nx]=aim;
        return;
    }
    int mid=(lx+rx)>>1;
    if(to<=mid)
    {
        update(to,aim,lx,mid,nx<<1);
    }else
    {
        update(to,aim,mid+1,rx,(nx<<1)|1);
    }
    vl[nx]=vl[nx<<1]+vl[(nx<<1)|1],ml[nx]=max(ml[nx<<1],ml[(nx<<1)|1]);
}

ll query(int ord,int lm,int rm,int lx,int rx,int nx)
{
    if(lm<=lx&&rm>=rx)
    {
    	if(ord)
    	{
        	return vl[nx];
        }else
        {
        	return ml[nx];
        }
    }
    int mid=(lx+rx)>>1;
    ll ret=0;
    if(!ord)
    {
        ret=0xefefefefefefefef;
    }
    if(lm<=mid)
    {
    	if(ord)
    	{
        	ret+=query(ord,lm,rm,lx,mid,nx<<1);
        }else
        {
    		ret=max(ret,query(ord,lm,rm,lx,mid,nx<<1));
    	}
    }
    if(rm>mid)
    {
    	if(ord)
    	{
    		ret+=query(ord,lm,rm,mid+1,rx,(nx<<1)|1);
        }else
        {
        	ret=max(ret,query(ord,lm,rm,mid+1,rx,(nx<<1)|1));
        }
    }
    return ret;
}

void solve(int ord,int x,int y)
{
    ll ans=0;
    if(!ord)
    {
        ans=0xefefefefefefefef;
    }
    while(tp[x]!=tp[y])
    {
        if(low[tp[x]]<low[tp[y]])
        {
            swap(x,y);
        }
        if(ord)
        {
            ans+=query(ord,fir[tp[x]],fir[x],1,n,1);
        }else
        {
            ans=max(ans,query(ord,fir[tp[x]],fir[x],1,n,1));
        }
        x=fa[tp[x]];
    }
    if(low[x]<low[y])
    {
        swap(x,y);
    }
    if(ord)
    {
        ans+=query(ord,fir[y],fir[x],1,n,1);
    }else
    {
        ans=max(ans,query(ord,fir[y],fir[x],1,n,1));
    }
    printf("%lld\n",ans);
}

int main()
{
    scanf("%d",&n);
    for(int i=1,ui,vi;i<n;i++)
    {
        scanf("%d%d",&ui,&vi);
        add(ui,vi);
        add(vi,ui);
    }
    dfs1(1,0);
    dfs2(1,1);
    dfs3(1);
    for(int i=1;i<=n;i++)
    {
    	scanf("%lld",&a[fir[i]]);
    }
    build(1,n,1);
    scanf("%d",&T);
    while(T--)
    {
        scanf("%s",opt);
        if(opt[0]=='C')
        {
            int to;
            ll aim;
            scanf("%d%lld",&to,&aim);
            update(fir[to],aim,1,n,1);
        }else
        {
    		int xi,yi;
    		scanf("%d%d",&xi,&yi);
        	if(opt[1]=='S')
        	{
            	solve(1,xi,yi);
            }else
            {
        		solve(0,xi,yi);
        	}
        }
    }
    return 0;
}

```

---


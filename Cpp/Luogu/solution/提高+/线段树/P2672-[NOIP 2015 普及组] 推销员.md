# [NOIP 2015 普及组] 推销员

## 题目背景

NOIP2015 普及组 T4

## 题目描述

阿明是一名推销员，他奉命到螺丝街推销他们公司的产品。螺丝街是一条死胡同，出口与入口是同一个，街道的一侧是围墙，另一侧是住户。螺丝街一共有 $N$ 家住户，第 $i$ 家住户到入口的距离为 $S_i$ 米。由于同一栋房子里可以有多家住户，所以可能有多家住户与入口的距离相等。阿明会从入口进入，依次向螺丝街的 $X$ 家住户推销产品，然后再原路走出去。

阿明每走 $1$ 米就会积累 $1$ 点疲劳值，向第 $i$ 家住户推销产品会积累 $A_i$ 点疲劳值。阿明是工作狂，他想知道，对于不同的 $X$，在不走多余的路的前提下，他最多可以积累多少点疲劳值。


## 说明/提示

**输入输出样例 1 说明**

$X=1$：向住户 $5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值为 $5$，总疲劳值为 $15$。

$X=2$：向住户 $4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值为 $4+5$，总疲劳值为 $5+5+4+5=19$。

$X=3$：向住户 $3,4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值 $3+4+5$，总疲劳值为 $5+5+3+4+5=22$。

$X=4$：向住户 $2,3,4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值 $2+3+4+5$，总疲劳值 $5+5+2+3+4+5=24$。

$X=5$：向住户 $1,2,3,4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值 $1+2+3+4+5$，总疲劳值 $5+5+1+2+3+4+5=25$。


**输入输出样例 2 说明**

$X=1$：向住户 $4$ 推销，往返走路的疲劳值为 $4+4$，推销的疲劳值为 $4$，总疲劳值 $4+4+4=12$。

$X=2$：向住户 $1,4$ 推销，往返走路的疲劳值为 $4+4$，推销的疲劳值为 $5+4$，总疲劳值 $4+4+5+4=17$。

$X=3$：向住户 $1,2,4$ 推销，往返走路的疲劳值为 $4+4$，推销的疲劳值为 $5+4+4$，总疲劳值 $4+4+5+4+4=21$。

$X=4$：向住户 $1,2,3,4$ 推销，往返走路的疲劳值为 $4+4$，推销的疲劳值为 $5+4+3+4$，总疲劳值 $4+4+5+4+3+4=24$。或者向住户 $1,2,4,5$推销，往返走路的疲劳值为 $5+5$，推销的疲劳值为 $5+4+4+1$，总疲劳值 $5+5+5+4+4+1=24$。

$X=5$：向住户 $1,2,3,4,5$ 推销，往返走路的疲劳值为$5+5$，推销的疲劳值为 $5+4+3+4+1$，总疲劳值 $5+5+5+4+3+4+1=27$。

**数据范围**

对于 $20\%$ 的数据，$1 \le N \le20$；  
对于 $40\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1 \le N \le 1000$；  
对于 $100\%$ 的数据，$1 \le N \le 100000$。


## 样例 #1

### 输入

```
5
1 2 3 4 5
1 2 3 4 5```

### 输出

```
15
19
22
24
25```

## 样例 #2

### 输入

```
5
1 2 2 4 5
5 4 3 4 1```

### 输出

```
12
17
21
24
27```

# 题解

## 作者：Rainy7 (赞：738)

- 前言

  是介个样子，不知道是不是我太**弱**了，我看了好多题解，然后花了好多时间才明白贪心具体。
  
  于是我决定自己写一题解，会详细一些的。本题解会有 **贪心思路+例子模拟贪心**
  
  我觉得我挺有良心的,,希望大家都能看懂QAQ

------------

  
- 题目大意

  推销员阿明，要给住在某街的N个用户推销，**走一米会增加1的疲劳值**，第i家距离路口$s[i]$米(**可能会有重复的**$s[i]$)给第i家推销会增加$a[i]$。全部推销完，**还要原路返回。**
  
  现在，依次向$X$用户推销，对于不同的$X$，阿明想知道**最大疲劳值**
  
------------

- 分析

  距离是真的烦人，那就不管他吧。因为想要疲劳值最大，那么先**按照疲劳值从大到小排序一边**。
  
  此时，可以判断出，最大值**可能**为：对于每个$X$，只要加上**前$X$大的疲劳值**，再加上这些数中**距离最远的并乘以2**，也就是：
  
  $sum(a[k])(1≤k≤X)+s[j]*2$
  
  其中，$s[j]$表示前K个距离最远的，sum()表示和。
  
  但是，推销员可以通过**走远一点**，虽然疲劳值比前面小，但是有可能把路程一算，反而更大。
  
  因此，可以把$a[]$，即疲劳值中，**前$X$大中的最小值，即第$X$大的那一家舍去**，看看能不能通过走更远来换取更大的疲劳值总和。
  
  而从后面看，**一定也会存在一个最大值**，把这个最大值和前面$X-1$个疲劳值总和加起来，看看会不会比前面第一种的情况大。

  证明：**只需舍去最小值来走更远，无需舍去更多数来走更远。**
  
  其实这也不是一个证明..
  
  因为已经从大到小排序了，所以，如果舍去$2$个疲劳值，那么后面只会在加上两个**更小**的疲劳值，以及**两个之间最大的距离**并乘2，那么这样还不如只舍去一个。
  
  2个不行，那么2个以上更是不行了。
  

------------
- 举例子了。

  硬讲太累了，还是用一个例子吧。
  ```
  //自动排序QAQ
  s[i]:1,3,4,5,11
  a[i]:5,4,2,1,1
  ```
  若$X==1$，直接取，那么值为:$1×2+5=7$,如果舍去最小的往后跑，值为:$11×2+1=23$，所以，最大值就为$max(7,11)=11$。
  
  若$X==2$，直接取，值为:$3×2+5+4=15$,把其中最小值舍去，也就是$4$去掉，往后跑值为:$11×2+1+5=28$，那么最大值为$max(15,28)=28$。
  
  若把次小疲劳值，即$5$,也往后跑，那么值为$11×2+1=24$，可以发现，距离并未因此改变，仍为$11$，而位置移后，疲劳值**只会减少**，故只要移动最小疲劳值。
  
  那么，最后一个问题，酱紫复杂度是会炸掉的，$so$
  
  用$sum[]$记录疲劳**前缀和**，这样子加的时候方便。
  
  用$q[]$记录**前i个距离最大值**，这样子就不用找啦！
  
  用$h[]$记录往后跑时，应该选哪个，也就是**后i个的最大值。**
  
  这样子预处理，就可以实现$O(n)$啦$QAQ$！
  
- 代码QAQ
  
```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
int n,sum[100010],q[100010],h[100010];//n 疲劳前缀和 前i个最大值 后i个最大值 
struct node{
    int s;//距离
    int a;//疲劳 
}v[100010];
bool cmp(node x,node y){return x.a>y.a;}
int main()
{	scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&v[i].s); 
    for(int i=1;i<=n;i++)scanf("%d",&v[i].a);
    sort(v+1,v+1+n,cmp);//按疲劳排序 
    for(int i=1;i<=n;i++)sum[i]=sum[i-1]+v[i].a; 
    for(int i=1;i<=n;i++)q[i]=max(q[i-1],2*v[i].s);//前i个最大值
    for(int i=n;i>=1;i--)h[i]=max(h[i+1],2*v[i].s+v[i].a);//后i个最大值
    for(int i=1;i<=n;i++)printf("%d\n",max(sum[i]+q[i],sum[i-1]+h[i]));
    return 0;
}
```

$by$ 路人七

---

## 作者：CXY07 (赞：39)

# 貌似这题代码可以很短欸

# 但是我自作孽写线段树

## 题目链接：[P2672 推销员](https://www.luogu.org/problemnew/show/P2672)

不过为什么会写线段树呢，~~其实是因为我看了标签~~。

申明：本题解较适合喜欢使用数据结构的 $OIers$，并且码量较其他方法来说比较大

------------

进入正题

可以证明每一次选择都基于上一次的选择，这个结论已经有巨佬详细地证明了，这里就不再详细说明了 ~~或者说是我不会~~

这道题我选择倒过来做，大致思路：

1. $S$ 值是从小到大排好序的（所以下文中下标更大即意味着 $S$ 值更大），可以不用管。

2. 当每一个用户的家都需要去的时候，也就是 $X = N$ 时，答案显然是所有 $A$ 值的和加上 $Smax * 2$。又因为*每一次的选择都基于上一次*，也就是*每一次选择都可以推导出上一次选择*。

3. 我们在求每一个状态的时候，关注的只有目前 $A$ 值的和、目前选择的点中 $S$ 的最大值 以及 当 $S$ 最大时点的下标。又因为 $A$ 值的和可以由上一个答案与目前选择的点得到，所以可以不维护。

那么，我们只需要逐步删除选中的点，并保证局部最优。这个答案一定就是所求。

------------


以下用 $l$、$r$表示 目前选中的点中下标最小的点的下标 和 目前选中的点中下标最大的点的下标（因此 $l$，$r$ 之间有可能会有没有选中的点），$dis$ 表示 $r$ 点的 $S$ 值的两倍（即来回距离）

这样的话，对于每一个状态，我们都有两种选择来指向两个不同的上一状态，在中间取最优值：

1. 删除 $l$ ~ $r - 1$ 中 $A$ 值最小的点 $v$，这样会尽量让答案更大，此时答案只需减去 $A_v$ 即可

2. 删除 $r$，这会导致右端点的变化（左移），因此 $dis$ 也会发生改变，同时，答案会减去 $A_r$

最后两个方案的答案取 $max$ 并且更新状态即可。

------------


所以我们的线段树用在哪里呢。。。~~终于讲到正题了~~

在方案 $1$ 中，我们好像要求 $l$ ~ $r - 1$ 中 $A$ 的 $min$ 值和它的下标？

### 线段树！

是的，线段树就用在这里 ~~也只用在这里~~

所以我们的线段树就只需要维护区间最小值和区间最小值下标即可，加一个单点修改

但是当有两个点的值均为区间最小，那我们的下标应该取哪一个呢？

显然是下标更小的那一个，因为这样可以使留下来的点的 $S$ 更大， $dis$ 更大 

而删除一个点之后，我们应该把其 $A$ 值变成 $INF$，这样就不会取到了。但这个操作只需要在方案 $1$ 更优的时候进行，因为在方案 $2$ 中，我们向左更新了 $r$ 的值，又所有的线段树操作都会在 $l$ ~ $r - 1$ 中进行，所以根本就不会再得到之前的 $r$ 点了


------------

而当我们选择了方案 $1$ ，删除 $r$ 后，哪个点来“接替” $r$ 的位置呢？显然不能是 $r$ 上一个点，因为它或许没有被选中，如果选中它，则违背了题目中 “不走多余的路的前提”

所以我们还需要维护选中的点中每一个点的前一个点 ~~绕口令~~

### 链表！

维护每个点的上一个节点即可

------------


好的问题解决了 ~~看起来很简单的样子~~

还是分几个部分讲解好了

------------

变量声明

```cpp
#define pii pair<int,int>//这里用pair来存区间min值和min值下标

const int MAXN = 1e5 + 10;
const int INF = 1e9;

int n,pre[MAXN],nxt[MAXN];//pre、nxt：链表
int seg[MAXN << 2],p[MAXN << 2];//seg：线段树区间min，p：线段树区间min下标
int ans[MAXN],l,r;//ans：x为不同数值时的答案数组
```

还有一个结构体

```cpp
struct house {
    int a,s;
    bool operator < (const house &b) const {return a < b.a;}
} node[MAXN];
```

跟题目中的一样

------------

链表

```cpp
void Delete(int pos) {
    pre[nxt[pos]] = pre[pos];
    nxt[pre[pos]] = nxt[pos];
}//这是一个极其简单的删除节点函数。。。
```

没啥讲的

------------

线段树

```cpp
#define l ll//懒得换变量名了，就define一下
#define r rr//到时候会undef

void pushup(int root) {//更新
    if(seg[root << 1 | 1] < seg[root << 1]) {//如果右子树更优
        seg[root] = seg[root << 1 | 1];//只能存右子树的答案了
        p[root] = p[root << 1 | 1];
    } else {
        seg[root] = seg[root << 1];//否则存左子树，这样可以让下标尽量小
        p[root] = p[root << 1];
    }
}

void build(int root,int l,int r) {//简单的建树
    if(l == r) {
        seg[root] = node[l].a;
        p[root] = l;
        return;
    }
    int mid = (l + r) >> 1;
    build(root << 1,l,mid);
    build(root << 1 | 1,mid + 1,r);
    pushup(root);
}

void update(int root,int l,int r,int pos,int val) {//简单的更新
    if(l == r && l == pos) {
        seg[root] = val;
        return;
    }
    int mid = (l + r) >> 1;
    if(pos <= mid) update(root << 1,l,mid,pos,val);
    else update(root << 1 | 1,mid + 1,r,pos,val);
    pushup(root);
}

pii getmin(pii &a,pii b) {//类似于min函数，用来找两个pii中最小值较小的那个（即当前的返回值）
    if(b.first < a.first) swap(a,b);
}

pii query(int root,int l,int r,int L,int R) {
    if(L <= l && r <= R) return make_pair(seg[root],p[root]);
    int mid = (l + r) >> 1;
    pii res = make_pair(INF,INF);
    if(L <= mid) getmin(res,query(root << 1,l,mid,L,R));//这里用到了getmin，可以自己研究一下
    if(R > mid) getmin(res,query(root << 1 | 1,mid + 1,r,L,R));
    return res;
}

#undef l
#undef r//说了会undef
```

------------

主函数

```cpp
int main () {
    ios::sync_with_stdio(0);//优化
    cin >> n;
    for(register int i = 1;i <= n; ++i)
        cin >> node[i].s;
    for(register int i = 1;i <= n; ++i) {
        cin >> node[i].a;
        pre[i] = i - 1;
        nxt[i] = i + 1;//链表初始化
        ans[n] += node[i].a;//最终答案
    }
    build(1,1,n);//建树
    l = 1,r = n;//左右端点（实际只有 r 有用）
    ans[n] += node[r].s * 2;//答案要加上dis
    for(register int i = n - 1;i >= 1; --i) {//倒推答案
        pii tmp = query(1,1,n,l,r - 1);//方案1 中用线段树
        int ans1 = ans[i + 1] - tmp.first;//方案1
        int ans2 = ans[i + 1] - node[r].a - node[r].s * 2 + node[pre[r]].s * 2;//方案2，也就是减去 r 的s*2和a，再加上新r的s*2
        if(ans1 < ans2) {//如果方案1更优
            int ss = r;
            r = pre[r]; Delete(ss);//删除右端点，更新右端点
            ans[i] = ans2;//更新答案
        } else {
            Delete(tmp.second);//删除当前下标
            update(1,1,n,tmp.second,INF);//更新，把当前A变成INF
            ans[i] = ans1; //更新答案
        }
    }
    for(register int i = 1;i <= n; ++i)
        cout << ans[i] << endl;//输出
    return 0;//华丽丽地结束
} 
```


------------

最后附上完整代码

```cpp
//Code By CXY
#include<bits/stdc++.h>
using namespace std;

#define pii pair<int,int>//这里用pair来存区间min值和min值下标

const int MAXN = 1e5 + 10;
const int INF = 1e9;

struct house {
    int a,s;
    bool operator < (const house &b) const {return a < b.a;}
} node[MAXN];

int n,pre[MAXN],nxt[MAXN];//pre、nxt：链表
int seg[MAXN << 2],p[MAXN << 2];//seg：线段树区间min，p：线段树区间min下标
int ans[MAXN],l,r;//ans：x为不同数值时的答案数组

#define l ll//懒得换变量名了，就define一下
#define r rr//到时候会undef

void pushup(int root) {//更新
    if(seg[root << 1 | 1] < seg[root << 1]) {//如果右子树更优
        seg[root] = seg[root << 1 | 1];//只能存右子树的答案了
        p[root] = p[root << 1 | 1];
    } else {
        seg[root] = seg[root << 1];//否则存左子树，这样可以让下标尽量小
        p[root] = p[root << 1];
    }
}

void build(int root,int l,int r) {//简单的建树
    if(l == r) {
        seg[root] = node[l].a;
        p[root] = l;
        return;
    }
    int mid = (l + r) >> 1;
    build(root << 1,l,mid);
    build(root << 1 | 1,mid + 1,r);
    pushup(root);
}

void update(int root,int l,int r,int pos,int val) {//简单的更新
    if(l == r && l == pos) {
        seg[root] = val;
        return;
    }
    int mid = (l + r) >> 1;
    if(pos <= mid) update(root << 1,l,mid,pos,val);
    else update(root << 1 | 1,mid + 1,r,pos,val);
    pushup(root);
}

pii getmin(pii &a,pii b) {//类似于min函数，用来找两个pii中最小值较小的那个（即当前的返回值）
    if(b.first < a.first) swap(a,b);
}

pii query(int root,int l,int r,int L,int R) {
    if(L <= l && r <= R) return make_pair(seg[root],p[root]);
    int mid = (l + r) >> 1;
    pii res = make_pair(INF,INF);
    if(L <= mid) getmin(res,query(root << 1,l,mid,L,R));//这里用到了getmin，可以自己研究一下
    if(R > mid) getmin(res,query(root << 1 | 1,mid + 1,r,L,R));
    return res;
}

#undef l
#undef r//说了会undef

void Delete(int pos) {
    pre[nxt[pos]] = pre[pos];
    nxt[pre[pos]] = nxt[pos];
}//这是一个极其简单的删除节点函数。。。

int main () {
    ios::sync_with_stdio(0);//优化
    cin >> n;
    for(register int i = 1;i <= n; ++i)
        cin >> node[i].s;
    for(register int i = 1;i <= n; ++i) {
        cin >> node[i].a;
        pre[i] = i - 1;
        nxt[i] = i + 1;//链表初始化
        ans[n] += node[i].a;//最终答案
    }
    build(1,1,n);//建树
    l = 1,r = n;//左右端点（实际只有 r 有用）
    ans[n] += node[r].s * 2;//答案要加上dis
    for(register int i = n - 1;i >= 1; --i) {//倒推答案
        pii tmp = query(1,1,n,l,r - 1);//方案1 中用线段树
        int ans1 = ans[i + 1] - tmp.first;//方案1
        int ans2 = ans[i + 1] - node[r].a - node[r].s * 2 + node[pre[r]].s * 2;//方案2，也就是减去 r 的s*2和a，再加上新r的s*2
        if(ans1 < ans2) {//如果方案1更优
            int ss = r;
            r = pre[r]; Delete(ss);//删除右端点，更新右端点
            ans[i] = ans2;//更新答案
        } else {
            Delete(tmp.second);//删除当前下标
            update(1,1,n,tmp.second,INF);//更新，把当前A变成INF
            ans[i] = ans1; //更新答案
        }
    }
    for(register int i = 1;i <= n; ++i)
        cout << ans[i] << endl;//输出
    return 0;//华丽丽地结束
} 
```

其实用线段树也蛮有趣的，大家可以试试鸭

初二的 $OIer$ ，请多关照

---

## 作者：chrispang (赞：6)

### 题目大意

推销员阿明，要给住在某街的 $N$ 个用户推销，**走一米会增加 $1$ 的疲劳值**，第 $i$ 家距离路口 $s_i$ 米（**可能会有重复的** $s_i$）给第 $i$ 家推销会增加 $a_i$。全部推销完，**还要原路返回。**

现在，依次向 $X$ 用户推销，对于不同的 $x$，阿明想知道**最大疲劳值。**

### 题目思路

考虑贪心：每次选取最大疲劳值，之后累加起来，本题就~~随随便便~~做完了。

但是因为有这个“距离”，导致了我们的计算变得复杂了，所以我们可以进行分别考虑：

1. 首先，先把第一次的答案计算出来，设第一次的答案的**推销产品**疲劳度为 $sum$ 、位置（即对应的 $s$ 值）为 $maxs$。
2. 接着进行遍历，如果这个点没有被访问过，且 $s_i\ge maxs$，那么检查 $sum + a_i + s_i \times 2> newsum + news \times 2$，如果是，则更新 $newsum$ 和 $news$。
3. 如果这个点没有被访问过，且 $s_i<maxs$，那么检查 $sum + a_i + maxs \times 2> newsum + news \times 2$，如果是，则更新 $newsum$ 和 $news$。
4. 循环 $2,3$ 步骤 $n-1$ 次，并且输出答案。

代码如下（ $60$ 分）：

```cpp
#include <bits/stdc++.h>
#define maxn 100010
#define int long long //养成好习惯，开就对了
using namespace std;

int read() { //快读
	int x = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') f *= (ch == '-' ? -1 : 1), ch = getchar();
	while(ch >= 48 && ch <= 57) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return x * f;
}

void write(int x) { //快写
	if(x > 9) write(x / 10);
	putchar(x % 10 ^ 48);
}

int n, maxs, sum, pos, S[maxn], A[maxn];
bool vis[maxn];
signed main() {
	n = read();
	for (int i = 1; i <= n; i++) S[i] = read();
	for (int i = 1; i <= n; i++) A[i] = read();
    for (int i = 1; i <= n; i++) if(S[i] * 2 + A[i] > sum + maxs * 2) sum = A[i], maxs = S[i], pos = i; //找到最大值，并且记录答案
    vis[pos] = 1; //进行标记
    write(sum + maxs * 2); //注意这里不是输出sum，因为sum的定义是推销产品的疲劳度，还要加上maxs*2(跑了两趟)
	putchar('\n');
	for (int k = 1; k < n; k++) {
		int new_sum = sum, new_s = maxs, newpos = 0; //初始化
		for (int i = 1; i <= n; i++)
			if(vis[i] == 0) { //如果这个点没有被访问过
				if(S[i] >= maxs && sum + A[i] + S[i] * 2 > new_sum + new_s * 2) new_sum = sum + A[i], new_s = S[i], newpos = i; //如果满足条件，则更新
				else if(S[i] < maxs && sum + A[i] + maxs * 2 > new_sum + new_s * 2) new_sum = sum + A[i], new_s = maxs, newpos = i; //同上
			}
		sum = new_sum, maxs = new_s, vis[newpos] = 1; //把得到的值复原回原来的值
		write(sum + maxs * 2); //输出
		putchar('\n');
	}
    return 0;
}
```

贪心思路是对的，可惜查询时间太慢了，所以时间复杂度为 $O(n^2)$。

如何加快查询时间呢？可以考虑这三种数据结构：优先队列、树状数组、线段树。

由于我想写点挑战性的，所以我选择了线段树（呵呵）。

----

### 怎么用线段树

每次查询最大值都查询 $1\sim pos-1$ 的最大值和 $pos+1\sim n$ 的最大值，其中 $pos$ 是当前选中的推销用户中距离起点最大的点的下标。

#### 怎么写

##### 定义

我们把线段树分成两种，`node1` 和 `node2`，`node1` 表示不考虑距离情况下的区间最大值，`node2` 则表示考虑距离情况下的区间最大值。

而 `node1` 由 $sum$ 和 $pos$ 组成，即区间最大疲劳度和选中的推销用户，而 `node2` 只是比 `node1` 多了一个 $maxs$，作用是求出选中的推销用户与起点的距离。

```cpp
struct node1 {
	int sum, pos;
}maxv1[maxn * 4]; //线段树的空间一般都要*4

struct node2 {
	int sum, maxs, pos;
}maxv2[maxn * 4];
```

##### pushup

`maxv1` 的更新：由于 `maxv1` 只涉及到了**推销用户**的疲劳度，所以比较 `maxv1[id * 2]` 和 `maxv1[id * 2 + 1]`，谁的 `sum` 值大就选谁。

`maxv2` 的更新：其实就是算上了距离，本质上与 `maxv1` 的更新操作没什么太大的区别。

```cpp
void pushup(int id) {
	maxv1[id] = maxv1[id * 2].sum > maxv1[id * 2 + 1].sum ? maxv1[id * 2] : maxv1[id * 2 + 1]; //只考虑推销用户的疲劳度 
	maxv2[id] = maxv2[id * 2].sum + maxv2[id * 2].maxs * 2 > maxv2[id * 2 + 1].sum + maxv2[id * 2 + 1].maxs * 2 ? maxv2[id * 2] : maxv2[id * 2 + 1]; //加上了距离 
}
```

##### build

`maxv1` 的构造：由于只涉及到了**推销用户**的疲劳度，所以初始化为 `a[l]` 和 `l`（$sum$ 和 $pos$）。

`maxv2` 的构造：比 `maxv1` 只加上了距离，所以初始化为 `a[l]`，`s[l]`（注意这里不要写成 `l`），`l`（$sum、maxs$ 和 $pos$）。

```cpp
void build(int id, int l, int r) {
	if(l == r) {
		maxv1[id] = {A[l], l}; //构建maxv1 
		maxv2[id] = {A[l], S[l], l}; //构建maxv2 
		return ;
	}
	int mid = (l + r) >> 1;
	build(id * 2, l, mid);
	build(id * 2 + 1, mid + 1, r);
	pushup(id); //回来时需要更新 
}
```

##### update
不要想的那么复杂，因为我们这个 `update` 函数只是为了进行删除的（后面会讲），所以直接一股脑的全部赋值 `v` 就好了。

```cpp
void update(int id, int l, int r, int x, int v) {
	if(l == r) {
		maxv1[id] = {v, v}; //赋值为v 
		maxv2[id] = {v, v, v}; //赋值为v 
		return ;
	}
	int mid = (l + r) >> 1;
	//找到需要更新的点在哪个区间
	if(x <= mid) update(id * 2, l, mid, x, v); //如果需要更新的点在左边 
	else update(id * 2 + 1, mid + 1, r, x, v); //如果需要更新的点在右边 
	pushup(id); //最后进行区间更新 
}
```

##### query1

在先这里说明一下，`query` 函数是有两个的：一个是查找不带距离的，一个是查找带距离的。所以需要写成 `query1`。

每次找到一个新的区间最大值 `t`，如果 `t.sum > ans.sum`，则更新：$ans=t$，之后返回回去。

```cpp
node1 query1(int id, int l, int r, int x, int y) {
	if(x <= l && r <= y) return maxv1[id]; //找到所属区间了,返回回去 
	int mid = (l + r) >> 1;
	node1 ans = {0, 0}; //记录答案
	//区间查找和单点更新不同,因为区间查找设计到了很多值,需要分段查找 
	if(x <= mid) ans = query1(id * 2, l, mid, x, y); //刚开始是不需要比较max的,因为ans刚开始赋值为{0,0} 
	if(y > mid) {
		node1 t = query1(id * 2 + 1, mid + 1, r, x, y); //这里就需要记录答案了 
		ans = ans.sum > t.sum ? ans : t; //比较最大值 
	}
	pushup(id); //似乎可以不用写,但我还是莫名其妙的写了 
	return ans; //返回 
}
```

##### query2

其实也没多难，只不过是加上了距离而已。

每次找到一个新的区间最大值 `t`，如果 `t.sum + t.maxs * 2 > ans.sum + ans.maxs * 2`，则更新：$ans=t$，之后返回回去。

```cpp
node2 query2(int id, int l, int r, int x, int y) {
	if(x <= l && r <= y) return maxv2[id]; //找到所属区间了,返回回去 
	int mid = (l + r) >> 1;
	node2 ans = {0, 0, 0}; //记录答案
	//区间查找和单点更新不同,因为区间查找设计到了很多值,需要分段查找 
	if(x <= mid) ans = query2(id * 2, l, mid, x, y); //刚开始是不需要比较max的,因为ans刚开始赋值为{0,0,0} 
	if(y > mid) {
		node2 t = query2(id * 2 + 1, mid + 1, r, x, y); //这里就需要记录答案了 
		ans = (ans.sum + ans.maxs * 2 > t.sum + t.maxs * 2 ? ans : t); //比较最大值 
	}
	pushup(id); //似乎可以不用写,但我还是莫名其妙的写了
	return ans; //返回 
}
```

##### 主函数

1. 用快读输入 $n、a、s$。

```cpp
n = read();
for (int i = 1; i <= n; i++) S[i] = read();
for (int i = 1; i <= n; i++) A[i] = read();
```

2. 开始建树。

```cpp
build(1, 1, n);
```

3. 算出第一次的答案，并且输出答案，并且删除这个点。

```cpp
for (int i = 1; i <= n; i++) if(S[i] * 2 + A[i] > sum + maxs * 2) sum = A[i], maxs = S[i], pos = i; //找出最大值 
write(sum + maxs * 2); //输出 
putchar('\n');
update(1, 1, n, pos, 0); //重点来了：这里是删除操作，因为我们不可能在线段树上做到真的删除，因此赋值为0，当作没出现过 
```

4. 求出 $1\sim pos-1$ 的最大疲劳值和 $pos+1\sim n$ 的最大疲劳值。

```cpp
node1 t1 = {0, 0}; node2 t2 = {0, 0, 0};
if(pos - 1 >= 1) t1 = query1(1, 1, n, 1, pos - 1); //注意不能越界 
if(pos + 1 <= n) t2 = query2(1, 1, n, pos + 1, n); //注意不能越界
```

5. 找出最大疲劳度，更新各项的值，输出答案，删除节点。

```cpp
sum += (t2.sum + t2.maxs * 2 > t1.sum + maxs * 2 ? t2.sum : t1.sum); //记住，sum永远代表着推销用户的疲劳度 
pos = (t2.sum + t2.maxs * 2 > t1.sum + maxs * 2 ? t2.pos : pos); //如果pos+1~n的区间疲劳值更大，则更新pos，否则不更新 
int now_pos = (t2.sum + t2.maxs * 2 > t1.sum + maxs * 2 ? t2.pos : t1.pos); //记录待会会删除的节点(谁的疲劳值的就删除谁) 
t2.sum + t2.maxs * 2 > t1.sum + maxs * 2 ? write(sum + t2.maxs * 2) : write(sum + maxs * 2); //输出疲劳值 
maxs = (t2.sum + t2.maxs * 2 > t1.sum + maxs * 2 ? t2.maxs : maxs); //注意：不要在上面就更新maxs，因为我们的t1需要用到maxs，如果提前更新，有可能造成答案错误 
putchar('\n');
update(1, 1, n, now_pos, 0); //删除节点 
```

最后，放上我们的 AC 代码！

```cpp
#include <bits/stdc++.h>
#define maxn 100010
#define int long long //好习惯 
using namespace std;

int read() { //快读 
	int x = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') f *= (ch == '-' ? -1 : 1), ch = getchar();
	while(ch >= 48 && ch <= 57) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return x * f;
}

void write(int x) { //快写 
	if(x > 9) write(x / 10);
	putchar(x % 10 ^ 48);
}

struct node1 {
	int sum, pos;
}maxv1[maxn * 4];

struct node2 {
	int sum, maxs, pos;
}maxv2[maxn * 4];

int n, maxs, sum, pos, S[maxn], A[maxn]; //S表示距离,A表示时间 
void pushup(int id) {
	maxv1[id] = maxv1[id * 2].sum > maxv1[id * 2 + 1].sum ? maxv1[id * 2] : maxv1[id * 2 + 1]; //只考虑推销用户的疲劳度 
	maxv2[id] = maxv2[id * 2].sum + maxv2[id * 2].maxs * 2 > maxv2[id * 2 + 1].sum + maxv2[id * 2 + 1].maxs * 2 ? maxv2[id * 2] : maxv2[id * 2 + 1]; //加上了距离 
}

void build(int id, int l, int r) {
	if(l == r) {
		maxv1[id] = {A[l], l}; //构建maxv1 
		maxv2[id] = {A[l], S[l], l}; //构建maxv2 
		return ;
	}
	int mid = (l + r) >> 1;
	build(id * 2, l, mid);
	build(id * 2 + 1, mid + 1, r);
	pushup(id); //回来时需要更新 
}

void update(int id, int l, int r, int x, int v) {
	if(l == r) {
		maxv1[id] = {v, v}; //赋值为v 
		maxv2[id] = {v, v, v}; //赋值为v 
		return ;
	}
	int mid = (l + r) >> 1;
	//找到需要更新的点在哪个区间
	if(x <= mid) update(id * 2, l, mid, x, v); //如果需要更新的点在左边 
	else update(id * 2 + 1, mid + 1, r, x, v); //如果需要更新的点在右边 
	pushup(id); //最后进行区间更新 
}

node1 query1(int id, int l, int r, int x, int y) {
	if(x <= l && r <= y) return maxv1[id]; //找到所属区间了,返回回去 
	int mid = (l + r) >> 1;
	node1 ans = {0, 0}; //记录答案
	//区间查找和单点更新不同,因为区间查找设计到了很多值,需要分段查找 
	if(x <= mid) ans = query1(id * 2, l, mid, x, y); //刚开始是不需要比较max的,因为ans刚开始赋值为{0,0} 
	if(y > mid) {
		node1 t = query1(id * 2 + 1, mid + 1, r, x, y); //这里就需要记录答案了 
		ans = ans.sum > t.sum ? ans : t; //比较最大值 
	}
	pushup(id); //似乎可以不用写,但我还是莫名其妙的写了 
	return ans; //返回 
}

node2 query2(int id, int l, int r, int x, int y) {
	if(x <= l && r <= y) return maxv2[id]; //找到所属区间了,返回回去 
	int mid = (l + r) >> 1;
	node2 ans = {0, 0, 0}; //记录答案
	//区间查找和单点更新不同,因为区间查找设计到了很多值,需要分段查找 
	if(x <= mid) ans = query2(id * 2, l, mid, x, y); //刚开始是不需要比较max的,因为ans刚开始赋值为{0,0,0} 
	if(y > mid) {
		node2 t = query2(id * 2 + 1, mid + 1, r, x, y); //这里就需要记录答案了 
		ans = (ans.sum + ans.maxs * 2 > t.sum + t.maxs * 2 ? ans : t); //比较最大值 
	}
	pushup(id); //似乎可以不用写,但我还是莫名其妙的写了
	return ans; //返回 
}

signed main() {
	n = read();
	for (int i = 1; i <= n; i++) S[i] = read();
	for (int i = 1; i <= n; i++) A[i] = read();
	build(1, 1, n);
	for (int i = 1; i <= n; i++) if(S[i] * 2 + A[i] > sum + maxs * 2) sum = A[i], maxs = S[i], pos = i; //找出最大值 
	write(sum + maxs * 2); //输出 
	putchar('\n');
	update(1, 1, n, pos, 0); //重点来了：这里是删除操作，因为我们不可能在线段树上做到真的删除，因此赋值为0，当作没出现过 
	for (int k = 1; k < n; k++) { //循环n-1次 
		node1 t1 = {0, 0}; node2 t2 = {0, 0, 0};
		if(pos - 1 >= 1) t1 = query1(1, 1, n, 1, pos - 1); //注意不能越界 
		if(pos + 1 <= n) t2 = query2(1, 1, n, pos + 1, n); //注意不能越界 
		sum += (t2.sum + t2.maxs * 2 > t1.sum + maxs * 2 ? t2.sum : t1.sum); //记住，sum永远代表着推销用户的疲劳度 
		pos = (t2.sum + t2.maxs * 2 > t1.sum + maxs * 2 ? t2.pos : pos); //如果pos+1~n的区间疲劳值更大，则更新pos，否则不更新 
		int now_pos = (t2.sum + t2.maxs * 2 > t1.sum + maxs * 2 ? t2.pos : t1.pos); //记录待会会删除的节点(谁的疲劳值的就删除谁) 
		t2.sum + t2.maxs * 2 > t1.sum + maxs * 2 ? write(sum + t2.maxs * 2) : write(sum + maxs * 2); //输出疲劳值 
		maxs = (t2.sum + t2.maxs * 2 > t1.sum + maxs * 2 ? t2.maxs : maxs); //注意：不要在上面就更新maxs，因为我们的t1需要用到maxs，如果提前更新，有可能造成答案错误 
		putchar('\n');
		update(1, 1, n, now_pos, 0); //删除节点 
	}
    return 0;
}
```
这篇题解是本蒟蒻的第十篇题解，点个赞吧！球球啦！

---

## 作者：XCDRF_ (赞：3)

# P2672 \[NOIP2015 普及组] 推销员

[原题传送门](https://www.luogu.com.cn/problem/P2672)

[更好的阅读体验](https://www.luogu.com.cn/article/qd6x7mh4)

## 解题思路

先考虑暴力。观察样例可知，$X=i$ 时的最优解肯定包含 $X=i-1$ 时的最优解。所以我们就会有一个思路：每次枚举新加入的点，计算一下添加这个点对答案的贡献是多少，取贡献最大的点即可。时间复杂度 $O(n^2)$。

再考虑优化。如果当前最远走到的距离是 $S$，那么对于某个点：如果 $s_i>S$，选这一个点答案就会加上 $2(s_i-S)+a_i$；如果 $s_i\leq S$ 答案就会加上 $a_i$。

那么我们就会有一个贪心的思路，如果从 $s_i>S$ 的点里面选就一定会选 $2\times s_i+a_i$ 最大的；而如果从 $s_i\leq S$ 里面选就一定会选 $a_i$ 最大的。

这时可以想到，用两个大根堆分别维护当前 $s_i\leq S$ 的点的所有 $a_i$ 以及 $s_i>S$ 的所有 $2\times s_i+a_i$，每次选两边对答案贡献较大的一个即可。但有时候 $S$ 会增大，这时候需要在取堆顶时判掉一些 $s_i
<S$ 的点。

该做法时间复杂度 $O(n \log n)$，符合要求。

## 参考代码

```cpp
#include<iostream>
#include<queue>
#define pii pair<int,int>
#define fi first
#define se second 
#define mp make_pair
using namespace std;
const int N=100005;
priority_queue<int> q1;
priority_queue<pii> q2;
int n,ans,now,maxx,maxn;
pii a[N],t;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i].fi;//s
    for(int i=1;i<=n;i++) cin>>a[i].se;//a
   	for(int i=1;i<=n;i++) q2.push(mp(2*a[i].fi+a[i].se,i));
   	q1.push(0);
   	for(int i=1;i<=n;i++){
   		now=maxn;
		maxx=q1.top();
		while(!q2.empty()){
			t=q2.top();
			if(a[t.se].fi>=a[maxn].fi||maxn==0) break;
			q2.pop();
		}
		if(t.fi-2*a[maxn].fi>maxx&&!q2.empty()){
			maxn=t.se;
			maxx=t.fi-2*a[now].fi;
			for(int j=now+1;j<maxn;j++) q1.push(a[j].se);
			q2.pop();
		}
		else q1.pop();
		ans+=maxx;
		cout<<ans<<'\n';
	}
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/196869744)

---

## 作者：Walrus (赞：3)

题目大概是要求这个东西：给定 $n$ 个数对 $(x_i,c_i)$，让你求对于每个 $k$，从中选出 $k$ 个数对（这里编号为 $A_1\sim A_k$），使得：
$$(\max_{1\leq i \leq k}x_{A_i}\times 2) + \sum_{i=1}^k c_{A_i}$$

最大。

## Sub1

直接爆搜即可，复杂度 $O(N\times 2^N)$。

## Sub2

不难想到定义一个 dp，令 $dp_{i,j,k}$ 表示前 $i$ 户人家推销了 $j$ 户上一户推销的人家是第 $k$ 户的最大值，转移是简单的，直接枚举上一次是从哪一户转移过来的即可。

时间复杂度 $O(N^4)$，空间复杂度 $O(N^3)$。

## Sub3

从网上看到个比较奇怪的 $O(N^2)$ 做法（奇怪是我觉得这明明可以直接弄成正解的），分享一下。大概思路是去贪心地在上一次选择的基础上再选择一个最优的住户，前提是先预处理出 $k=1$ 时的答案。

具体可以自己去那篇 [blog](https://blog.csdn.net/huangzihaoal/article/details/77175475) 去看。

## Sub4

正解，Sub3 的奇怪做法提醒了我们「贪心地增加一个最优的用户」。

做这个题之前应该会想到一个乱搞结论：直接选 $k$ 个 $c_i$ 最大的住户算就可以了。

但是动动脑子就会发现这肯定是错的，比如我可以构造一组数据让前 $k$ 大的 $c_i$ 的 $x_i$ 都很小，最后再放一个 $x_i=\infty$。

但是我们灵机一动，从上面那段话以及最开始那个式子可以注意到，答案只与我们选的最大的一个 $x_i$ 有关系，剩下的 $k-1$ 个 $x_i$ 爱怎么选怎么选。

所以我们想到，既然 $k-1$ 个 $x_i$ 爱怎么选怎么选，那么我们不妨直接选前 $k-1$ 个 $c_i$ 最大的，再补充一个数 $p$，使得：

$$x_p \geq \max_{1\leq i < k} x_{A_i}$$

且

$$2\times (x_p-\max_{1\leq i < k} x_{A_i})+c_p$$

最大。

所以我们可以按 $c_i$ 从大到小排序，用个前后缀优化就可以了。

但是我用我两百万年前写的 code 交上去发现被 hack 了，原因是我们最开始可能乱猜的结论有那么一点道理（说人话就是上面的做法会漏掉一些情况），为了完善一些可能会错误的情况，我们需要和我们乱猜的结论取 $\max$，这样的话就一定是对的了，因为两种情况已经覆盖了所有可能的解，而我们瞎猜的结论弥补了上述结论的漏洞，即补充的那个 $p$ 在一定情况下不如再取第 $k$ 大的数更优，读者自行证明，这里不再做解释了。

```cpp
#include <bits/stdc++.h>
#define FASTIO ios::sync_with_stdio(0), cin.tie(nullptr), cout.tie(nullptr);
#define rep(i, j, k) for(int i = j; i <= k; ++i)
#define pre(i, j, k) for(int i = j; i >= k; --i)
#define pb push_back
#define PII pair<int, int>
#define fi first
#define se second
#define int long long
#define inf LONG_LONG_MAX
#define repx(i, x) for(int i = head[x]; i; i = nxt[i])


using namespace std;
const int N = 1e5 + 5;
const int mod = 1e9 + 7;

int n, m, pre[N], mx[N], suf[N];

struct node {
	int x, c;
	#define x(p) t[p].x
	#define c(p) t[p].c
	bool operator < (const node &a) const {return c > a.c;
	}
} t[N];


signed main() {
	FASTIO
	
	cin >> n;
	rep(i, 1, n) cin >> x(i);
	rep(i, 1, n) cin >> c(i);
	
	sort(t + 1, t + 1 + n);
	rep(i, 1, n) pre[i] = pre[i - 1] + c(i), mx[i] = max(mx[i - 1], x(i));//情况1
	pre(i, n, 1) suf[i] = max(suf[i + 1], x(i) * 2 + c(i));//情况2
	rep(i, 1, n) cout << max(pre[i] + 2 * mx[i], pre[i - 1] + suf[i]) << '\n';
	return 0; 
}
```

---

## 作者：zhongqijun (赞：3)

## 解题思路
题目大意：对于每一个$X$，在序列中选出$X$个数，使得$S_x \times 2 + \sum_{i=1}^{i\leq X}A_i$的值最大。
~~（越解释越复杂。。。）~~

由于$X$的单调递增性，所以可以考虑$X$每递增一次，用**贪心策略**维护一次答案。
先从$X=1$的情况入手：很显然，答案是$\max_{1\leq i \leq n}(S_i\times2+A_i)$，枚举一遍就可以得到答案了。
紧接着，分**两种情况**讨论：
1. **往巷子深处推销**即向比居住在当前最远处人家**住得更远的人家**推销
2. **给沿路的人家推销**即向比居住在当前最远处人家**住得更近的人家**推销
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191115213919494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGwwNDEwMzA=,size_16,color_FFFFFF,t_70)
---
### 往巷子深处推销
设当前最深处人家在$pos$处，再设$sum$表示**当前推销疲劳值**，设$dis$表示**当前路程疲劳值**
从$pos+1$开始枚举，算出巷子深处的路程最大疲劳值
$$maxdis=\max_{pos+1\leq j\leq n}(A_j\times2)$$
且记录那一户人家$nextpos$
往巷子深处推销的总最大疲劳值即为$sum2=maxdis+sum+B_{nextpos}$
### 给沿路的人家推销
从$1$开始枚举，得出$pos$之前的人家的**最大推销疲劳值**，即
$$maxn=\max_{1\leq j < pos}B_j$$
给沿路人家推销的总最大疲劳值即为$sum1=dis+sum+maxn$
### 前后对比
比较$sum1$和$sum2$
如果$sum1<sum2$那么更新$sum=sum+maxn$
如果$sum1>sum2$那么更新$dis=maxdis,sum=sum+B_{nextpos},pos=nextpos$

---
### 更快的方法
由于在计算中出现了形如
$$\max_{left\leq i \leq right}X_i$$
的式子，所以可以考虑用**单调队列优化**

~~总体思路到此结束。。。代码特别长。。。~~ 

---

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<queue>

using namespace std;
int n,s[100005],a[100005],maxn,pos,ansdis,ans;
int main()
{
	priority_queue< int , vector<int > > q;//快速获取最大值 
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&s[i]);
		s[i]*=2;//来回路程 
	}
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
	{
		if(maxn<s[i]+a[i])
		{
			maxn=s[i]+a[i];
			pos=i;
		}
	}
	printf("%d\n",maxn);//获取X=1的答案 
	ansdis=s[pos];ans=a[pos];//用于累加疲劳值，方便后面做贪心对比 
	for(int i=1;i<pos;i++)//当前最佳答案 前面的 最大疲劳值 
		q.push(a[i]);
	for(int i=2;i<=n;i++)
	{
		int tmp=q.top();int tmppos=0;
		maxn=0;
		for(int j=pos+1;j<=n;j++)
			if(s[j]+a[j]>maxn)
			{
				tmppos=j;
				maxn=s[j]+a[j];//记录当前最佳答案 后面的 最大疲劳值 
			} 
		if(ansdis+ans+tmp<maxn+ans)//前后对比，决定是往巷子里深处走
		{
			ansdis=s[tmppos];//累加的用处 
			ans+=a[tmppos];//累加的用处
			q.pop();
			for(int j=pos+1;j<tmppos;j++) q.push(a[j]);//记录当前最佳答案 前面的 最大值 
			pos=tmppos;//更新最佳答案 
		}
		else//或是给沿路人家推销 
		{
			ans+=tmp;//累加的用处 
			q.pop();//用过了就出队 
		}
		printf("%d\n",ans+ansdis);//输出答案 
	}
	return 0;
}
```


---

## 作者：lam_dyr (赞：3)

# P2672 \[NOIP2015 普及组] 推销员

## 题意

现有长度为 $N$ 的两个数组 $a$ 和 $s$。

有 $N$ 个询问，第 $k$ 个询问你需要找出一个 $i$ 使得 $s_i \times 2 +$ $a$ 数组中前 $k-1$ 大的值之和 (不包含 $a_i$ 本身，且下标必须小于 $i$) 最大。

## 思路

### 整体二分

注意到每个询问找出的那个最优的 $i$ 是满足单调性的，
因此可以对所有询问整体二分。

用 $solve(l_1,r_1,l_2,r_2)$ 表示当前处理第 $l_1 \sim r_1$ 个询问，他们最优的 $i$ 范围在 $l_2 \sim r_2$。

令 $mid_1= \dfrac {(l_1+r_1)} 2$，我们在 $l_2 \sim r_2$ 中找，看看哪个是对于第 $mid_1$ 个的最优 $i$。找出最优的 $i$ 设为 $mid_2$，那么分为 $solve(l_1,mid_1-1,l_2,mid_2)$ 和 $solve(mid_1+1,r_1,mid_2,r_2)$。

我们易知每一层的循环复杂度总和都是 $n$，一共 $\log n$ 层，则复杂度为 $n \log n$。

### 主席树

如何得知第 $X$ 个询问选择的 $i$ 为 $y$ 时的答案？

前 $y-1$ 中最大的 $x-1$ 个可以用主席树得到。

## Code

```cpp
#include <cstdio>
#include <cstring>
#include <cstdlib>
using namespace std;  
typedef long long ll;
const ll maxn=100010;        
ll i,j,k,l,t,n,m,tot;
ll sum[maxn*25],num[maxn*25],left[maxn*25],right[maxn*25],root[maxn],ans[maxn],s[maxn],a[maxn];
void insert(ll l,ll r,ll y,ll p,ll &x){
    x=++tot;
    sum[x]=sum[y]+p;
    num[x]=num[y]+1;
    left[x]=left[y];right[x]=right[y];
    if (l==r) return;
    ll mid=(l+r)/2;
    if (p<=mid) insert(l,mid,left[y],p,left[x]);
    else insert(mid+1,r,right[y],p,right[x]);
}
ll get(ll l,ll r,ll x,ll y){
    if (y>num[x]) return -10000;
    if (!y) return 0;
    if (l==r) return sum[x]/num[x]*y;
    ll mid=(l+r)/2;
    if (num[right[x]]>=y) return get(mid+1,r,right[x],y);
    else return sum[right[x]]+get(l,mid,left[x],y-num[right[x]]);
}
void solve(ll l1,ll r1,ll l2,ll r2){
    if (l1>r1) return;
    ll mid1=(l1+r1)/2,mid2,t=0,k;
    for(int i=l2;i<=r2;++i){
        k=s[i]*2+a[i]+get(1,999,root[i-1],mid1-1);
        if (k>t){
            t=k;
            mid2=i;
        }
    }
    ans[mid1]=t;
    solve(l1,mid1-1,l2,mid2);solve(mid1+1,r1,mid2,r2);
}
int main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;++i) scanf("%lld",&s[i]);
    for(int i=1;i<=n;++i){
        scanf("%lld",&a[i]);
        insert(1,999,root[i-1],a[i],root[i]);
    }
    solve(1,n,1,n);
    for(int i=1;i<=n;++i) printf("%lld\n",ans[i]);
    return 0;
}
```

---

## 作者：GSQ0829 (赞：2)

### 思路：
前缀和，是这题的关键。

那么想要让疲劳值最大化，就需要先排序。

那么接下来，就要用两个数组来记录疲劳值最大值。

最后用前缀和的方式来求出真正的最大值就行了。

---

### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1000001;
int pre[MAXN], dp[MAXN], f[MAXN], n;

struct Node {
	int x, y;
} a[MAXN];

bool cmp(Node a, Node b) {
	return a.y > b.y;
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i].x);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i].y);
	sort(a + 1, a + n + 1, cmp);
	for (int i = n; i >= 1; i--) f[i] = max(f[i + 1], 2 * a[i].x + a[i].y);
	for (int i = 1; i <= n; i++) {
		pre[i] = pre[i - 1] + a[i].y;
		dp[i] = max(dp[i - 1], 2 * a[i].x);
		printf("%d\n", max(pre[i] + dp[i], pre[i - 1] + f[i]));
	}
	return 0;
}
```

---

## 作者：FishPressedCoins (赞：1)

这篇题解是打算给我自己之后复习用的，因为本人目前能力不足，无法证明为什么这样做可以过，纯当多一种想法，理清一下我的思考路线。

由题目可知，答案只受两种因素干扰，分别是路程和 $A$ 值。知道了这两个的数值，那么第一个答案就很好求，路程乘二加上 $A$ 值的最大值。第二个答案就开始受路程影响了，不能再像第一个答案一样计算总路程。想到这我发现不可能一劳永逸地将路程乘二加 $A$ 值按从小到大排序求得答案，其原因就是路程加点的不确定。

所以我就想到将路程和 $A$ 值，分别按从小到大排序，再加上先前的排序，一共是三个排序，每次我都取它们三个中的最大值，比较一下哪个加的总数最大，就是我需要的答案。
```cpp
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
long long N, a[100010], b[100010];
struct Node
{
	//分别是路程、A值、户主编号
	long long s, a, v;
	Node(long long _s, long long _a, long long _v) { s = _s, a = _a, v = _v; }
	Node() {}
};
vector<Node>V, V1, V2;//三个排序，分别是路程*2+A、路程、A值
vector<long long>ans;//答案记录
bool B[100010];//户主使用记录
//三个判断对应三个排序
bool B1(Node& x, Node& y)
{
	return x.s*2 + x.a < y.s*2 + y.a;
}
bool B2(Node& x, Node& y)
{
	return x.s < y.s;
}
bool B3(Node& x, Node& y)
{
	return x.a < y.a;
}
int main()
{
	cin >> N;
	for (long long i = 1; i <= N; i++) {
		cin >> a[i];
	}
	for (long long i = 1; i <= N; i++) {
		cin >> b[i];
		V.push_back({ a[i],b[i],i });
		V1.push_back({ a[i],b[i],i });
		V2.push_back({ a[i],b[i],i });
	}

	sort(V.begin(), V.end(), B1);
	sort(V1.begin(), V1.end(), B2);
	sort(V2.begin(), V2.end(), B3);

	ans.push_back(V.back().a + V.back().s * 2);//先将最大的值记录一下
	B[V.back().v] = true;
	for (long long i = 1, j = V.back().s, x1, x2, x3; i <= N - 1; i++) {
		//前三个while循环就是剔除已经使用过的户主
		while (!V.empty()) {
			if (B[V.back().v])V.pop_back();
			else break;
		}
		while (!V1.empty()) {
			if (B[V1.back().v])V1.pop_back();
			else break;
		}
		while (!V2.empty()) {
			if (B[V2.back().v])V2.pop_back();
			else break;
		}
		//x1 x2 x3分别对应三个排序目前的最大值统计
		if (!V.empty())x1 = V.back().a + ((V.back().s - j >= 0) ? (V.back().s - j) : 0) * 2;
		else x1 = 0;
		if (!V1.empty())x2 = V1.back().a + ((V1.back().s - j >= 0) ? (V1.back().s - j) : 0) * 2;
		else x2 = 0;
		if (!V2.empty())x3 = V2.back().a + ((V2.back().s - j >= 0) ? (V2.back().s - j) : 0) * 2;
		else x3 = 0;
		//j是用来记录当前最大路程的，避免路程多算
		if (x3 > x2 && x3 > x1 && !V2.empty()) {
			ans.push_back(ans.back() + x3);
			j = max(j, V2.back().s);
			B[V2.back().v] = true;
		}
		else if (x2 > x1 && x2 > x3 && !V1.empty()) {
			ans.push_back(ans.back() + x2);
			j = max(j, V1.back().s);
			B[V1.back().v] = true;
		}
		else {
			ans.push_back(ans.back() + x1);
			j = max(j, V.back().s);
			B[V.back().v] = true;
		}
	}

	for (auto temp : ans) {
		cout << temp << '\n';
	}
	return 0;
}
```

---

## 作者：qhr2023 (赞：1)

## solution

upd：精简了一下语言。

一道贪心。

记 $S_i$ 表示第 $i$ 家住户到入口的距离，$A_i$ 表示向第 $i$ 家住户推销产品积累的疲劳值。

若我们先选了 $A$ 最大的 $X$ 家住户，如果想让答案更优，就需要选一些剩下的住户替换已选的住户，那么我们一定从已选的 $A$ 最小的开始换。

我们设用 $j$ 换已选住户中 $A$ 最小的，那 $2S_j+A_j$ 是剩下的住户中最大的，若此时不优那继续换也不会更优。若更优，再考虑换已选住户中 $A$ 次小的，用次优替换住户 $k$ 来换，$k$ 满足 $2S_k+A_k < 2S_j+A_j$。
* $2S_k \le 2S_j$，此时 $S$ 不变，$A$ 总值变小，显然更劣。
* $2S_k > 2S_j$，此时 $A_k<A_j$，相当于让 $A$ 总值变小，$S$ 变大，若此时更优，那就是说 $S$ 变化量比 $A$ 的大，即 $2S_k-2S_j > A_j-A_k$，与前提不符，所以一定不优。

换多个一定也不会更优。所以我们得到一条重要结论：对于选 $X$ 家住户的最优解是选推销疲劳值前 $X$ 大的或舍去第 $X$ 大的。

先按 $A$ 降序排序，维护 $A$ 的前缀和、$S$ 的前缀最大值、$A+2S$ 的后缀最大值即可。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, s[100005], q[100005];
struct node { int s, a; } a[100005];
bool cmp (node a, node b) { return a.a>b.a; }
int main () {
	cin >> n;
	for (int i=1; i<=n; ++i)
		cin >> a[i].s;
	for (int i=1; i<=n; ++i)
		cin >> a[i].a;
	sort(a+1, a+n+1, cmp);
	for (int i=n; i>=1; --i)
		q[i]=max(q[i+1], 2*a[i].s+a[i].a);
	for (int i=1, mx=a[1].s, s=0; i<=n; s+=a[i].a, mx=max(mx, a[++i].s))
		cout << max(s+a[i].a+mx*2, s+q[i]) << '\n';
	return 0;
}
```

---

## 作者：zhuangjinning (赞：1)

## 题目大意

推销员阿明需要推销 $X$ 个商品，走一米会消耗一点疲劳值，从入口到第 $i$ 户的距离是 $s_{i}$ 米，推销第 $i$ 户需要消耗 $a[i]$ 点疲劳值。阿明推销完商品后要原路返回，问他最多能消耗多少点疲劳值。

## 分析

乍一看，阿明只需推销疲劳值最大的 $X$ 个客户就行了，可是，如果有一个客户推销所需的疲劳值很小但距离入口非常远，上述方法就不对了。
所以应该把两种情况都考虑到。

## 解题思路

设疲劳值最大的 $X$ 个客户中距离最远的客户的 $s_{i}$ 为 $maxdis$，疲劳值最大的 $X$ 个客户中距离最远的客户的下标为 $maxf$，这两个变量可以在 $X$ 从一到 $n$ 枚举的时候处理出来。

用一个数组 $sum_{i}$ 来存储从大到小排完序后的 $a$ 数组的前缀和。

这样，第一种情况阿明消耗的疲劳值为 $2 \times maxdis+sum_X$。

在 $a$ 数组排序前预处理一个 $f$ 数组，为 $2 \times s_i+a_i$ 的后缀最大值。

这样，第二种情况所消耗的疲劳值为 $sum_{X-1}+f_{maxf+1}$。

最后，将两种情况取 $\max$ 即可。

## AC代码


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
int s[100002];
int sum[100002];
int d[100002];
int f[100002];
struct node{
	int s;
	int num;
	int id;
};
bool cmp(node a,node b){
	return a.num>b.num;
}
node a[100002];
int maxdis;
int maxf;
signed main(){
//读入
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s[i];
		a[i].s=s[i];
	}
	for(int i=1;i<=n;i++){
		cin>>a[i].num;
		a[i].id=i;
	}
//预处理f数组
	for(int i=n;i>=1;i--){
		f[i]=max(f[i+1],2*a[i].s+a[i].num);
	}
	sort(a+1,a+1+n,cmp);//排序
	for(int i=1;i<=n;i++){
		sum[i]=sum[i-1]+a[i].num;//预处理sum数组
	} 
	for(int x=1;x<=n;x++){
		if(s[a[x].id]>maxdis){
			maxdis=s[a[x].id];//计算maxdis
			maxf=a[x].id;//计算maxf
		}
		int tmp=2*maxdis+sum[x];//计算第一种情况所消耗的疲劳值
		int tmp1=sum[x-1]+f[maxf+1];//计算第二种情况所消耗的疲劳值
		cout<<max(tmp,tmp1)<<endl;//将两种情况取最大，输出
	}
	return 0;
}
```

---

## 作者：xmy201315 (赞：1)

这道题是一个动态规划的题目。

我们首先令 $f_{i,j}$ 为在前 $i$ 家住户中选了 $j$ 家住户，那么转移为 $$ans_j=\max(f_{i,j}+2S_i)$$。

那么如果我们按照上面打的话，我们会 **TLE**。

紧接着，我们可以使用后缀最大值将时间复杂度变为 $\mathcal O(n)$。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 101000;
struct people {
	int a, s, id;
} p[N];
int n, suf[N], sum[N];
bool operator < (const people &a, const people &b) {
	return a.a > b.a;
}
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &p[i].s);
		p[i].id = i;
	}
	for (int i = 1; i <= n; i++)
		scanf("%d", &p[i].a);
	for (int i = n; i >= 1; i--)
		suf[i] = max(suf[i + 1], 2 * p[i].s + p[i].a);//后缀最大值，在做某些题目，是要将suf清空的。
	sort(p + 1, p + n + 1);
	int smax = -1, id = -1;
	for (int X = 1; X <= n; X++) {
		sum[X] = sum[X - 1] + p[X].a;
		if (p[X].s > smax)smax = p[X].s, id = p[X].id;
		printf("%d\n", max(sum[X] + 2 * smax, sum[X - 1] + suf[id + 1]));
	}
}
```

---

## 作者：ivyjiao (赞：1)

来水一发。

首先阿明不走多余的路，所以不可以走一个再回来再走一个这种东西，可以得到阿明只能走一趟（即题干中的依次推销）。

乍一看 $A_i$ 和 $S_i$ 没有下界，但是题干中说：“螺丝街是一条死胡同，出口与入口是同一个，街道的一侧是围墙，另一侧是住户。”所以所有住户都在阿明的右侧，所以阿明一定是先向右走一段，走到一个住户（不能是空地），再走回来，只能在路过的住户进行推销（可以不推销，但是最后一个住户必须推销）。

因为想要疲劳值最大，那么先把住户按照疲劳值从大到小排序。

那么我们就可以得到（$A,S$ 已经过如上的排序）：

$$ans_X=\sum_{i=1}^X A_i+\max_{i=1}^X (S_i\times 2)$$

但是我们发现这样是不对的，我们可以舍去最小的 $A_i$（就是最后一个，$A_X$），然后加一 $A_i$ 更小但是 $S_i$ 更大的住户，这样总疲劳值更大。

如果舍掉多个的话 $A$ 的总值更小但 $S$ 不变（一条路不能反复走）。

然后把这个考虑到的话，对 $A$ 做一个前缀和，对 $2\times S$ 做一个前缀 $\max$，对 $A+2\times S$ 做一个后缀 $\max$（看换哪个），最后答案就是：

$$ans_X=\max(\sum_{i=1}^X A_i+\max_{i=1}^X (S_i\times 2),\sum_{i=1}^{X-1} A_i+\max_{i=X+1}^n (S_i\times 2+A_i))$$

```cpp
#include<bits/stdc++.h>
#define PII pair<int,int>
#define fi first
#define se second
using namespace std;
const int N=1e5+1;
int n,b[N],q[N],h[N];
PII a[N];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i].se;
    for(int i=1;i<=n;i++) cin>>a[i].fi;
    sort(a+1,a+1+n,greater<PII>());
    for(int i=1;i<=n;i++) b[i]=b[i-1]+a[i].fi; 
    for(int i=1;i<=n;i++) q[i]=max(q[i-1],2*a[i].se);
    for(int i=n;i>=1;i--) h[i]=max(h[i+1],2*a[i].se+a[i].fi);
    for(int i=1;i<=n;i++) cout<<max(b[i]+q[i],b[i-1]+h[i])<<endl;
}
```

---

## 作者：AubRain (赞：1)

## 主席树+决策单调性优化dp+分治

首先非常显然，若要确定 $ans[x]$ ，则需要找一个 $i$ ，令 $i$ 作为走的最远点，使得 $i$ 前面的最大的 $x-1$ 疲劳度的和+ $i$ 的疲劳度 + $2*i$ 的距离最大。

**显然最远点是不降的**。具体其它题解已经证明了。于是就可以分治了。前缀 $k$ 大主席树搞一下。

$solve(l,r,L,R)$表示，当前要求 $[l,r]$ 的答案，可能的决策区间在 $[L,R]$ 。每次只找区间中点的最优决策点在哪，递归解决就行了。

复杂度 $O(nlog^2n)$

```cpp
#include<bits/stdc++.h>
#define N 100005
#define M N*12
#define mid ((l+r)>>1)
using namespace std;

inline bool rd(int &X)
{
    X=0;int w=0;char ch=0;
    while(!isdigit(ch))w|=ch=='-',ch=getchar();
    while( isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    X=w?-X:X; return 1;
}

int a[N],b[N];
int n,cnt,ans[N];
int rt[N],sum[M],val[M],ls[M],rs[M];

void ins(int o,int &p,int x,int l=1,int r=1000){
    ls[p=++cnt]=ls[o],rs[p]=rs[o],sum[p]=sum[o]+1,val[p]=val[o]+x;if(l==r) return ;
    x<=mid ? ins(ls[o],ls[p],x,l,mid) : ins(rs[o],rs[p],x,mid+1,r);
}
int ask(int p,int k,int l=1,int r=1000){
    if(l==r or !p) return l*k;
    return sum[rs[p]]>=k ? ask(rs[p],k,mid+1,r) : ask(ls[p],k-sum[rs[p]],l,mid)+val[rs[p]];
}
void solve(int l,int r,int L,int R){
    if(l>r) return ; int Mid;
    for(int i=max(mid,L);i<=R;i++){
        int now=ask(rt[i-1],mid-1)+a[i]*2+b[i];
        if(now>ans[mid])
            ans[mid]=now,Mid=i;
    }
    solve(l,mid-1,L,Mid);solve(mid+1,r,Mid,R);
}
signed main()
{
    rd(n);
    for(int i=1;i<=n;i++) rd(a[i]);
    for(int i=1;i<=n;i++) rd(b[i]);
    for(int i=1;i<=n;i++)
        ins(rt[i-1],rt[i],b[i]);
    solve(1,n,1,n);
    for(int i=1;i<=n;i++)
        printf("%d\n",ans[i]);
}

```

---

## 作者：lihl (赞：0)

前缀和 & 前后缀 max 练手题。

### 分析

感觉就很顺理成章地做下来了。很 Educational 的一道好题。

首先不难发现本题需要贪心解决问题。

显然每个住户对答案的贡献为 $c_i\gets A_i + S_i$。考虑拆分贡献为 $S$ 和 $A$。不难发现，我们可以贪心选取一个对答案贡献中 $A$ 贡献最大的若干个和 $S$ 贡献最大的若干个。

首先考虑每个住户对 $S$ 的贡献。一个住户的 $S_i$ 是一定的，由于多组询问，所以我们可以先考虑以 $S_i$ 降序为关键字排序后做一遍**前缀和** $pre_0 \gets 0,pre_i \gets pre_{i-1}+A_i$。这样前缀和的做法可以保证在考虑到 $S$ 的贡献后 $A$ 的贡献最大。

接下来考虑每个住户在什么情况下会产生 $A$ 的贡献。考虑对 $2S_i+A_i$ 做**后缀** $\max$ 为 $suf$，这样后缀 $\max$ 的做法可以使其在选取 $A$ 贡献的最大值时不劣。需要向新住户推销时，可以直接考虑 $ans_i = pre_{i-1} + suf_i$ 即可。

但考虑到一种情况，就是上述计算 $A$ 贡献的方法是有缺陷的。不妨读者自行尝试仅计算答案的算法为前缀和与后缀 $\max$ 的方法对样例 $1$ 的计算，出现了 $ans_5 < ans_4$ 的情况。这是因为，我们假定了「只需要求 $c_i$ 前 $X$ 大的用户作贪心」即可解决问题，忽视了虽然 $A$ 的贡献小但是 $2S_i$ 的贡献大的情况。所以我们还要对 $2S_i$ 做**前缀** $\max$ 为 $pre^{\prime}$，此时的答案为 $ans^{\prime}_{i}=pre_i+pre^{\prime}_i$。

于是每次询问的答案为 $\max(ans_i,ans^{\prime}_i)$。

时间复杂度 $\mathcal{O}(n)$，可以通过。

---


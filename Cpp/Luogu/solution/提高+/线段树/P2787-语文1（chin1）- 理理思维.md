# 语文1（chin1）- 理理思维

## 题目背景

蒟蒻 HansBug 在语文考场上，挠了无数次的头，可脑子里还是一片空白。


## 题目描述

考试开始了，可是蒟蒻 HansBug 脑中还是一片空白。哦不！准确的说是乱七八糟的。现在首要任务就是帮蒟蒻 HansBug 理理思维。假设 HansBug 的思维是一长串字符串（字符串中包含且仅包含 $26$ 个字母），现在的你，有一张神奇的药方，上面依次包含了三种操作：

1、 获取第 $x$ 到第 $y$ 个字符中字母 $k$ 出现了多少次

2、将第 $x$ 到第 $y$ 个字符全部赋值为字母 $k$

3、将第 $x$ 到第 $y$ 个字符按照 $\text{a} \sim \text{z}$ 的顺序排序


你欣喜若狂之时，可是他脑细胞和 RP 已经因为之前过度紧张消耗殆尽，眼看试卷最后还有一篇八百字的作文呢，所以这个关键的任务就交给你啦！


## 说明/提示

样例说明：

 ![](https://cdn.luogu.com.cn/upload/pic/2231.png) 

数据规模：

 ![](https://cdn.luogu.com.cn/upload/pic/2232.png) 

### 此题目中大小写不敏感。

### 新加了三组 hack 数据，不在上面的表格中，但保证 $1\le n,m \le 50000$。

## 样例 #1

### 输入

```
10 5
ABCDABCDCD
1 1 3 A
3 1 5
1 1 3 A
2 1 2 B
1 2 3 B
```

### 输出

```
1
2
2
```

# 题解

## 作者：jxdlyg (赞：19)

这题显然也是可以用线段树做的


可以写个结构体,每个节点里都放一个桶子,然后其实就是裸的

当然也可以写26个线段树,这样似乎能短一点?并没有写这种


这时,三种操作就都比较好写,操作1和操作2不谈了

操作3只需要多次进行操作1和2就OK了


那么我们就可以这样写

```cpp
Node tmp=query(1,1,n,b,c);
for(int i=0,l,r=b-1;i!=26;++i)
{
    if(tmp.cnt[i]==0)    continue;
    l=r+1,r=l+tmp.cnt[i]-1;
    update(1,1,n,l,r,i);
}
```

注意在struct里重载运算符容易出事

调了半天后来dalao帮我放外面就A掉了



代码
```cpp
#include<iostream>
#include<cstring>
#include<cctype>
#include<cstdio>
#define lson nod<<1
#define rson nod<<1|1
using namespace std;

struct Node{
    int cnt[26];
    Node(){memset(cnt,0,sizeof(cnt));}
};
Node operator + (Node a,Node b){
    Node c;
    for(int i=0;i!=26;++i)
        c.cnt[i]=a.cnt[i]+b.cnt[i];
    return c;
}
const int MAXN=65536,toc='a'-'A';
char s[MAXN];
int n,m,lazy[MAXN<<2];
Node tree[MAXN<<2],emp;

char c;
inline char toupper(char tmp){return ('a'<=tmp && tmp<='z')?(tmp-toc):tmp;}
inline void read(int &x)
{
    x=0,c=getchar();
    while(c<'0' || c>'9')    c=getchar();
    while('0'<=c && c<='9')    x=(x<<3)+(x<<1)+c-'0',c=getchar();
}

inline void pushdown(int nod,int ln,int rn)
{
    if(lazy[nod]!=-1)
    {
         lazy[lson]=lazy[nod],lazy[rson]=lazy[nod];
        tree[lson]=Node(),tree[rson]=Node();
        tree[lson].cnt[lazy[lson]]=ln;
        tree[rson].cnt[lazy[rson]]=rn;
        lazy[nod]=-1;
    }
}

void build(int nod,int lef,int rig)
{
    if(lef==rig)    tree[nod].cnt[s[lef]-'A']=1;
    else
    {
        int mid=(lef+rig)>>1;
        build(lson,lef,mid);
        build(rson,mid+1,rig);
        tree[nod]=tree[lson]+tree[rson];
    }
}

void update(int nod,int lef,int rig,int goal,int goar,int val)
{
    if(rig<goal || goar<lef)    return;
    if(goal<=lef && rig<=goar)
    {
        tree[nod]=Node(),lazy[nod]=val;
        tree[nod].cnt[val]=rig-lef+1;
    }
    else
    {
        int mid=(lef+rig)>>1;
        pushdown(nod,mid-lef+1,rig-mid);
        if(goal<=mid)    update(lson,lef,mid,goal,goar,val);
        if(goar>mid)    update(rson,mid+1,rig,goal,goar,val);
        tree[nod]=tree[lson]+tree[rson];
    }
}

Node query(int nod,int lef,int rig,int goal,int goar)
{
    if(rig<goal || goar<lef)    return emp;
    if(goal<=lef && rig<=goar)    return tree[nod];
    
    Node ret;
    int mid=(lef+rig)>>1;
    pushdown(nod,mid-lef+1,rig-mid);
    if(goal<=mid)    ret=ret+query(lson,lef,mid,goal,goar);
    if(goar>mid)    ret=ret+query(rson,mid+1,rig,goal,goar);
    
    return ret;
}

int main()
{
    read(n),read(m),scanf("%s",s+1);
    memset(lazy,-1,sizeof(lazy));
    for(int i=n;i!=0;s[i]=toupper(s[i]),--i);
    
    build(1,1,n);
    int a,b,c; char d;
    for(int i=0;i!=m;++i)    
    {
        read(a),read(b),read(c);
        if(a!=3)        scanf("%c",&d),d=toupper(d);
        if(a==1)        printf("%d\n",query(1,1,n,b,c).cnt[d-'A']);
        else if(a==2)    update(1,1,n,b,c,d-'A');
        else
        {
            Node tmp=query(1,1,n,b,c);
            for(int i=0,l,r=b-1;i!=26;++i)
            {
                if(tmp.cnt[i]==0)    continue;
                l=r+1,r=l+tmp.cnt[i]-1;
                update(1,1,n,l,r,i);
            }
        }
    }
    return 0;
}
```



---

## 作者：skydogli (赞：18)

### 这是一个有确定复杂度上限的暴力解法——分块

虽然题解区已经有分块了，但是ta并没有对lazy数组运用到极致，还疯狂maintain，导致时间复杂度极高，需要开O2，于是我稍微魔改了一番，~~锤了一些珂朵莉树~~达到了最优解第二页。

#### 思路：

操作1：被分块艹烂了的操作，暴力扫整块和散块$\sqrt{n}$的时间内可以完成。

操作2：运用lazy数组，把整块的字母标记，需要时下传（maintain）到整个块，暴力修改散块，同样是$\sqrt{n}$的。

操作3：暴力快排？？成功爆炸，但是我们仔细一想，因为值域是1～26，所以桶排是一个非常好的选择，那么我们可以统计区间中每一个字母出现的次数，按顺序插入即可。时间复杂度。。。大体上还是$\sqrt{n}$吧，然而查询插入都要26次，所以这个常数算起来。。。

为了不被ODT吊打，我们需要做一些优化：

#### 减少maintain
如果当前块有懒标记，下传的代价就是$\sqrt{n}$的，非常慢，所以我们能不maintain就不maintain，首先修改和查询整块的时候就没必要了，直接修改懒标记和查询就行。总耗时：3700ms->2100ms->900ms（O2）

#### 对操作三剪枝
显然，这个程序的复杂度基本取决于操作三的复杂度，所以优化操作三的复杂度性价比是很高的。我们发现，对于有懒标记的块，它只会对一个字母做贡献，不需要扫26次，于是我们加个特判，又减小了一半常数。总耗时：900ms->450ms，不开O2：1300ms

至此，其它的优化都是在O（$n\sqrt{n}$)的复杂度上小修小补，优化空间不大，等蒟蒻我有时间了再来尝试吧。

### 代码&注释：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define Re register 
#define MN 50005
int n,m,sum[225][26],T,loc[MN],len,opt,x,y,num[26];
char k[2],lazy[225],ch[MN];
//sum：每个块各个字母的数量    loc：表示某个位置在哪个块
//num：各个字母的数量（用于操作三）//lazy：懒标记
inline int read(){
    int a=0;
    char c=getchar();
    while(c>57||c<48)c=getchar();
    while(48<=c&&c<=57){
        a=a*10+c-48;
        c=getchar();
    }
    return a;
}
inline void maintain(int x){
    int pos=loc[x];
    if(lazy[pos]) {
        int l=(pos-1)*len+1,r=pos*len;
        for(int i=l;i<=r;++i) ch[i]=lazy[pos];
        for(int i=0;i<26;++i) sum[pos][i]=0;
        sum[pos][lazy[pos]-'A']=len;
        lazy[pos]=0;
    }
}//必要时下传
inline int ask(int x,int y,char k){
    if(y<x) return 0;
    int l=(x-1)/len+1+(x%len!=1),r=y/len,ans=0;
    if(l>r){
        maintain(x);maintain(y);//查询散块时下传
        for(int i=x;i<=y;++i)ans+=(ch[i]==k);
        return ans;
    }
    for(int i=l;i<=r;++i)
        ans+=lazy[i]?((k==lazy[i])*len):sum[i][k-'A'];
    int L=(l-1)*len,R=r*len+1;
    maintain(x);maintain(y);
    for(int i=x;i<=L;++i){ans+=(ch[i]==k);}
    for(int i=R;i<=y;++i){ans+=(ch[i]==k);}
    return ans;
}
void ASK(int x,int y){//查询26个字母
    if(y<x) return;
    int l=(x-1)/len+1+(x%len!=1),r=y/len;
    if(l>r){
        maintain(x);maintain(y);
        for(int i=x;i<=y;++i)++num[ch[i]-'A'];
        return;
    }
    for(int i=l;i<=r;++i){
        if(lazy[i])num[lazy[i]-'A']+=len;
        else for(int k=0;k<26;++k)
            num[k]+=sum[i][k];//小剪枝
    }
    int L=(l-1)*len,R=r*len+1;
    maintain(x);maintain(y);
    for(int i=x;i<=L;++i){++num[ch[i]-'A'];}
    for(int i=R;i<=y;++i){++num[ch[i]-'A'];}
    return;
}
inline void change(int x,int y,char k){
    if(y<x) return;
    int l=(x-1)/len+1+(x%len!=1),r=y/len;
    if(l>r){
        maintain(x);maintain(y);
        for(int i=x;i<=y;++i){
            --sum[loc[i]][ch[i]-'A'];
            ++sum[loc[i]][k-'A'];
            ch[i]=k;
        }
        return;
    }
    for(int i=l;i<=r;++i){lazy[i]=k;}//不需要maintain
    int L=(l-1)*len,R=r*len+1;
    maintain(x);maintain(y);//修改散块时maintain
    for(int i=x;i<=L;++i){
        --sum[l-1][ch[i]-'A'];
        ++sum[l-1][k-'A'];
        ch[i]=k;
    }
    for(int i=R;i<=y;++i){
          --sum[r+1][ch[i]-'A'];
          ++sum[r+1][k-'A'];
          ch[i]=k;
    }
}
int main(){
    scanf("%d%d%s",&n,&m,ch+1);
    for(int i=0;i<n;++i)if(ch[i]>'Z') ch[i]=(ch[i]-'a'+'A');
    T=sqrt(n);len=n/T;
    for(Re int i=1;i<=n;++i)loc[i]=(i-1)/len+1;
    for(Re int i=1;i<=T;++i){
        int l=(i-1)*len+1;int r=i*len;
        for(Re int j=l;j<=r;++j)
            ++sum[i][ch[j]-'A'];
    }
    for(Re int i=1;i<=m;++i){
        opt=read();x=read();y=read();
        if(opt==1){
            scanf("%s",k);
            if(k[0]>'Z') k[0]=(k[0]-'a'+'A');
            printf("%d\n",ask(x,y,k[0]));
        }
        else if(opt==2){
            scanf("%s",k);
            if(k[0]>'Z') k[0]=(k[0]-'a'+'A');
            change(x,y,k[0]);
        }
        else {
            ASK(x,y);
            for(Re int j=0;j<26;++j){
                change(x,x+num[j]-1,char(j+'A'));
                x+=num[j];
                num[j]=0;
            }
        }
    }
    return 0;
}



```
#### 总结
这题打了我5h+，主要还是不太熟练分块的左右边界条件和注意事项吧，调分块题有个比较好用的小技巧：用同样的数据，更改块的大小，可以很方便地检查边界是否打挂。

---

## 作者：寒鸽儿 (赞：8)

[博客食用效果更佳](https://www.luogu.org/blog/oldherd/solution-p2787)  
我们考虑建起26棵线段树，每棵维护一种字母，这样子就可以很简单地维护每种字母出现地位置信息。那么操作一和操作二就可以直接用区间修改和区间查询来完成。  
对于操作三的排序，我们从A到Z依次查询所有线段树。统计到目前线段树之前出现的字母与个数p，查询当前字母个数tt，若操作的区间为[t, g]，则当前字母在排序后的区间应当为[t+p, t+p+tt-1]。详情参照代码。  
26棵完整的线段树，520w大小的结构体数组，空间上面可能有些紧(如果不保存l和r应该也能过，但没有试过)，我在这里用了动态开点的做法，按mlogn算大概开到210w。  
关于玄学：数组开到300w过开到250wTLE是什么鬼？难道是开小导致死循环？但按mlogn计算确实开到210w就够了？？？  
下面附上ac代码：  
```cpp
#include <cstdio>
#include <queue> 

using namespace std;

const int sz = 3000000;

struct node{
	int ls, rs, val, laz;	
}t[sz];
int root[30], tot = 1;

inline int newnode() {
	t[tot].ls = t[tot].rs = t[tot].val = 0; t[tot].laz = -1;
	return tot++;	
}

inline void spread(int p, int ll, int rl) {
	if(!t[p].ls) t[p].ls = newnode();
	if(!t[p].rs) t[p].rs = newnode();
	if(t[p].laz == -1) return;
	t[t[p].ls].val = ll * t[p].laz; t[t[p].rs].val = rl * t[p].laz;
	t[t[p].ls].laz = t[p].laz; t[t[p].rs].laz = t[p].laz;
	t[p].laz = -1;
}

inline void change(int p, int lp, int rp, int l, int r, int v) {
	if(l <= lp && rp <= r) { t[p].val = (rp - lp + 1) * v; t[p].laz = v; return; }
	int mid = (lp + rp) >> 1;
	spread(p, mid-lp+1, rp-mid);
	if(l <= mid) change(t[p].ls, lp, mid, l, r, v);
	if(r > mid) change(t[p].rs, mid+1, rp, l, r, v);
	t[p].val = t[t[p].ls].val + t[t[p].rs].val;
}

inline int query(int p, int lp, int rp, int l, int r) {
	if(l <= lp && rp <= r) return t[p].val;
	int mid = (lp + rp) >> 1;
	spread(p, mid-lp+1, rp-mid);
	int ans = 0;
	if(l <= mid) ans = query(t[p].ls, lp, mid, l, r);
	if(r > mid) ans += query(t[p].rs, mid+1, rp, l, r);
	return ans;
}

inline int getc() {
	char ch;
	do{
		ch = getchar();
	}while((ch < 'A' || ch > 'Z') && (ch < 'a' || ch > 'z'));
	return ch > 'Z' ? ch - 'a' : ch - 'A';
}

int main() {
	int n, m, op, t, g, c;
	scanf("%d %d", &n, &m);
	for(int i = 0; i < 26; i++) root[i] = newnode();
	for(int i = 1; i <= n; i++) change(root[getc()], 1, n, i, i, 1);
	while(m--) {
		scanf("%d %d %d", &op, &t, &g);
		if(op != 3) c = getc();
		if(op == 1) {
			printf("%d\n", query(root[c], 1, n, t, g));
		} else if(op == 2) {
			for(int i = 0; i < 26; i++)
				if(i == c) change(root[i], 1, n, t, g, 1);
				else change(root[i], 1, n, t, g, 0);
		} else {
			int p = 0, tt;
			for(int i = 0; i < 26; i++) {
				tt = query(root[i], 1, n, t, g);
				if(!tt) continue;
				change(root[i], 1, n, t, g, 0);
				change(root[i], 1, n, t+p, t+p+tt-1, 1);
				p += tt;
			}
		}
	}
	return 0;	
}
```
欢迎互相关注(然而在oi界蒟蒻的圈很小)。  
最后再次安利一下[蒟蒻的洛谷博客](https://www.luogu.org/blog/oldherd/)  

---

## 作者：kradcigam (赞：5)

[题面](https://www.luogu.com.cn/problem/P2787)

这道题我的做法是线段树，由于只有26个字母，所有我们可以建 $26$ 个线段树。

对于操作 `1`

> 我们维护一下区间和就可以了。

对于操作 `2`

> 我们用 $lazy\_tag$ 就可以了

对于操作 `3`

> 我们发现就是操作 `1` 和操作 `2` 的结合

值得一提的是，有一个剪枝优化能是程序快很多

```cpp
int query(int num,int l,int r){
	if(t[num].sum==0)return 0;//剪枝
	if(t[num].l>=l&&t[num].r<=r)return t[num].sum;
	pushdown(num);
	if(t[ls].r<l)return query(rs,l,r);
	if(t[rs].l>r)return query(ls,l,r);
	return query(ls,l,r)+query(rs,l,r);
}
void change(int num,int l,int r,int f){
	if(t[num].tag==f)return;//剪枝
	if(t[num].l>=l&&t[num].r<=r){
		dwn(num,f);
		return;
	}pushdown(num);
	if(t[ls].r>=l)change(ls,l,r,f);
	if(t[rs].l<=r)change(rs,l,r,f);
	pushup(num);
}
```
这 $2$ 个剪枝虽然非常显然，但可以使程序快很多

代码:

```cpp
#include <bits/stdc++.h>
#define ls num<<1
#define rs num<<1|1
using namespace std;
typedef long long ll;
namespace io {//CYjian的快读模板
	const int __SIZE = (1 << 21) + 1;
	char ibuf[__SIZE], *iS, *iT, obuf[__SIZE], *oS = obuf, *oT = oS + __SIZE - 1, __c, qu[55]; int __f, qr, _eof;
	#define Gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)
	inline void flush () { fwrite (obuf, 1, oS - obuf, stdout), oS = obuf; }
	inline void gc (char &x) { x = Gc(); }
	inline void pc (char x) { *oS ++ = x; if (oS == oT) flush (); }
	inline void pstr (const char *s) { int __len = strlen(s); for (__f = 0; __f < __len; ++__f) pc (s[__f]); }
	inline void gstr (char *s) { for(__c = Gc(); __c < 32 || __c > 126 || __c == ' ';)  __c = Gc();
		for(; __c > 31 && __c < 127 && __c != ' '; ++s, __c = Gc()) *s = __c; *s = 0; }
	template <class I> inline bool gi (I &x) { _eof = 0;
		for (__f = 1, __c = Gc(); (__c < '0' || __c > '9') && !_eof; __c = Gc()) { if (__c == '-') __f = -1; _eof |= __c == EOF; }
		for (x = 0; __c <= '9' && __c >= '0' && !_eof; __c = Gc()) x = x * 10 + (__c & 15), _eof |= __c == EOF; x *= __f; return !_eof; }
	template <class I> inline void print (I x) { if (!x) pc ('0'); if (x < 0) pc ('-'), x = -x;
		while (x) qu[++ qr] = x % 10 + '0',  x /= 10; while (qr) pc (qu[qr --]); }
	struct Flusher_ {~Flusher_(){flush();}}io_flusher_;
} using io::pc; using io::gc; using io::pstr; using io::gstr; using io::gi; using io::print;
inline void rech(char &ch){
	gc(ch);
	for(;!isupper(ch)&&!islower(ch);gc(ch));
}
const int N=1e5+10;
int n,m,F[305];
char a[N];
struct node{
	struct Tree{
		int l,r,sum,tag,len;
	}t[N<<2];
	void pushup(int num){
		t[num].sum=t[ls].sum+t[rs].sum;
	}
	void dwn(int num,int f){
		t[num].tag=f;
		if(t[num].tag==1)t[num].sum=t[num].len;
		if(t[num].tag==2)t[num].sum=0;
	}
	void pushdown(int num){
		if(t[num].tag==0)return;
		dwn(ls,t[num].tag);
		dwn(rs,t[num].tag);
		t[num].tag=0;
	}
	void build(int l,int r,int num,char ch){
		t[num].tag=0;
		t[num].l=l;t[num].r=r;
		t[num].len=r-l+1;
		if(l==r){
			t[num].sum=a[l]==ch;
			return;
		}int mid=(l+r)>>1;
		build(l,mid,ls,ch);
		build(mid+1,r,rs,ch);
		pushup(num);
	}
	int query(int num,int l,int r){
		if(t[num].sum==0)return 0;//剪枝
		if(t[num].l>=l&&t[num].r<=r)return t[num].sum;
		pushdown(num);
		if(t[ls].r<l)return query(rs,l,r);
		if(t[rs].l>r)return query(ls,l,r);
		return query(ls,l,r)+query(rs,l,r);
	}
	void change(int num,int l,int r,int f){
		if(t[num].tag==f)return;//剪枝
		if(t[num].l>=l&&t[num].r<=r){
			dwn(num,f);
			return;
		}pushdown(num);
		if(t[ls].r>=l)change(ls,l,r,f);
		if(t[rs].l<=r)change(rs,l,r,f);
		pushup(num);
	}
}T[110];
int main(){
	gi(n);gi(m);
	for(int i=1;i<=n;i++)rech(a[i]),a[i]=toupper(a[i]);
	for(char i='A';i<='Z';i++)T[i].build(1,n,1,i);
	while(m--){
		int f,x,y;char k;
		gi(f);gi(x);gi(y);
		if(f==1){
			rech(k);
			k=toupper(k);
			print(T[k].query(1,x,y));
			pstr("\n");
		}
		if(f==2){
			rech(k);
			k=toupper(k);
			for(char i='A';i<='Z';i++)
				if(i==k)T[i].change(1,x,y,1);
				else T[i].change(1,x,y,2);
		}
		if(f==3){
			for(char i='A';i<='Z';i++){
				F[i]=T[i].query(1,x,y);
				T[i].change(1,x,y,2);
			}
			for(char i='A';i<='Z';i++)
				if(F[i])T[i].change(1,x,x+F[i]-1,1),x+=F[i];
		}
	}
	return 0;
}
```

---

## 作者：Gumbo (赞：2)

本文为 [$\color{black}{\text{P2787-语文1（chin1）-理理思维}}$](https://www.luogu.com.cn/problem/P2787) 的题解。

---

前置芝士：

- 分块（块状数组）
- 块内排序算法
- 二分查找
- 桶排序

---

本篇题解思路：

拿到一个问题，首先我们看问题的类型。

显然，这道题是一道数列操作题。

接下来，我们看数据范围，并依此分析最劣时间复杂度。

$N\le5\times10^4,M\le5\times10^4$，__数据只有字母。__

首先，复杂度的 $\mathcal O(m)$ 是少不了的，然后我们根据数据范围，推出单次操作的极限复杂度约为 $\mathcal O(\sqrt n \log n)$，也就是说我们最终的复杂度要做到 $\mathcal O(m\sqrt n\log n)$ 以内（事实上，本篇题解就是这个复杂度，稍后证明）。

在这里，我们先考虑朴素的，不太可能过的暴力：

对于操作一，直接遍历一遍即可，将次数累加。

对于操作二，直接遍历，暴力拍平。

对于操作三，直接暴力 `sort`。

分析完了，代码咱也别打了，没意义，肯定过不了。

那么下面就来讲一个不是正解的做法，事先提醒一下，我的做法需要吸氧。

---

相信吊打我的大佬们看到时间复杂度的时候，就已经知道我的方法是啥了，但是这里，我还是要赘述一下。（轻点，别打脸

对于整个数列，我们建立块状数组维护，并额外维护一个局部有序的数组。

这里的代码：

```cpp
unsigned char ori[MAXN];
unsigned char sot[MAXN];
```

`ori` 数组字面意思为：`origin`，也就是原数列（不是 `orz`）。

`sot` 数组字面意思为：`sorted`，也就是局部有序数组。

然后我们看操作：

### 操作一：统计字符个数。

这里做法其实有两种，其中有一种能把复杂度优化到 $\mathcal O(m\sqrt n)$ 的做法，另一种则是我的 $\mathcal O(m\sqrt n \log n)$ 的做法。

这样思考：我们有两种方法，一是将每一块的每一个数都准备好，查询时直接累加。

另一种方法：每次询问时再处理，多一个 $log$。

这里我使用的是 $log$ 做法，因为如果维护一个数组的话，虽然能降低一个 $log$ 的复杂度，但是在维护时会有一个 $26$ 的大常数，而我们的 $log$ 显然是到不了 $26$ 的，因此有时高复杂度的做法反而比低复杂度的大常数做法在一定的数据范围更占优势。

我们使用分块的经典思想，将整块先放在一边，先统计散块的贡献。

显然，这里直接暴力即可，不是复杂度瓶颈。

对于整块，这里就要利用我们之前维护的 `sot` 数组了（养你不是用来过年的）

我们直接借用一下 `STL` 的二分算法，当然，如果你非要手写，我也不反对。

直接找到第一个大于这个字符的字符的位置和第一个大于等于这个字符的字符的位置。（自行断句）

将这两个位置相减，就是这个块内的这个字符的数量。

当然，使用二分的前提是在比较意义内，符合规定的都在右边，不符合的都在左边，所以我们应当使用单调不降的 `sot` 来完成这个操作，而不是没有单调性的 `ori`。

我们设第一个大于的位置为 $r$，第一个大于等于的位置为 $l$，显然，$r$ 是最后一个这个字符的下一个位置（如果存在），因此个数 $=(r-1)-l+1=r-l$。

如果不存在等于，那么大于等于与大于完全等价，相减结果为 `0`。

操作一结束。

---

### 操作二：区间拍平。

这个操作和区间加差不多，是分块的基础操作，就不细讲了，只需要维护每块的 `tag`，然后其它操作的时候注意一下就可以了。

散块还是暴力，然后随手 `sort` 维护一下 `sot` 数组（块内排序，复杂度 $\mathcal O(\sqrt n\log n^{0.5})=\mathcal O(\sqrt n\log n)$。

---

### 操作三：区间排序。

这个才是这道题的毒瘤之处，如果没有这个操作，那么随便一个数据结构估计都能做了。

现在来看这个操作如何实现：

首先，如果我们直接 `sort`，那就是绝对过不了。

那如果我们使用一个高效的排序算法呢？值域这么小，桶排安排上！

朴素桶排： $\mathcal O(n)$ ，带着约 $26$ 的常数，过不了。

无解了吗？并不是。

我们把桶排给拆掉：桶排的实现无非就是先找到每个字符的个数，再一个个赋值。

我们手动一步一步来做：

既然是要找到个数，我们可以直接套操作一。

赋值的话，我们可以这样做：

首先，处理左边的散块，这里直接暴力即可，复杂度 $\mathcal O(\sqrt n\log n)$，别忘了我们还要维护 `sot`。

然后，对于中间的整块，我们每次判断当前剩余的最小字符是否够排满这个块，如果够，就直接打上修改标记。

如果不够，那对不起，只能暴力。

最后是右边的散块，和左边的同理。

---

本题解正文结束，代码有点长，就挂剪贴板了。

[$\colorbox{yellow}{\color{red}{\texttt{CODE}}}$](https://www.luogu.com.cn/paste/4xxqgn3q)

---

#### 非正文部分一：时间复杂度证明。

对于数组的构建，直接将 `ori` 与 `sot` 同步赋值，赋完值之后对 `sot` 的每个块进行 `sort`，复杂度 $\mathcal O(n\log n)$。

对于操作一，散块的处理复杂度为 $\mathcal O(\sqrt n)$，整块的处理复杂度为 $\mathcal O(\log n)$，整块的数量是 $\sqrt n$ 级别的，所以这一步的复杂度为 $\mathcal O(\sqrt n\log n+\sqrt n)=\mathcal O(\sqrt n\log n)$。

对于操作二，散块的处理复杂度为 $\mathcal O(\sqrt n\log n)$，整块为 $\mathcal O(1)$，块数在 $\sqrt n$ 级别，总复杂度 $\mathcal O(\sqrt n+\sqrt n\log n)=\mathcal O(\sqrt n\log n)$。

对于操作三，统计的复杂度和操作一相同，赋值的复杂度 $=\mathcal O(\sqrt n\cdot \text{不完整的块数}+\sqrt n)$，因为这里只有在两个字符的交界处才有可能出现不完整的部分，因此 `不完整的块数` 最多为 $26$，为常数级，所以总复杂度为 $\mathcal O(\sqrt n+\sqrt n\log n)=\mathcal O(\sqrt n\log n)$。

操作的次数是 $\mathcal O(m)$ 级别的，所以总复杂度为 $\mathcal O(n\log n+m\sqrt n\log n)=\mathcal O((n+m\sqrt n)\log n)$，约为 $\mathcal O (m\sqrt n\log n)$，可以通过此题。

---

非正文部分二：申请添加标签：`块状链表、块状数组、分块`。

---

提交审核原因：改一下分类。

---


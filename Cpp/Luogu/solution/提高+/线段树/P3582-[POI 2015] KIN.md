# [POI 2015] KIN

## 题目描述

共有 $m$ 部电影，编号为 $1,2,\ldots,m$，第 $i$ 部电影的好看值为 $w_i$。

在 $n$ 天之中，每天会放映一部电影，第 $i$ 天放映的是第 $f_i$ 部。

你可以选择 $l,r$（$1\le l\le r\le n$），并观看第 $l,l+1,\ldots,r$ 天内所有的电影。

但如果同一部电影你观看多于一次，你会感到无聊，于是无法获得这部电影的好看值。

现在，您需要最大化观看且仅观看过一次的电影的好看值的总和。

## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1\le m\le n\le 10^6$，$1\le f_i\le m$，$1\le w_i\le 10^6$。

----

原题名称：Kinoman。

## 样例 #1

### 输入

```
9 4
2 3 1 1 4 1 2 4 1
5 3 6 6```

### 输出

```
15```

# 题解

## 作者：_ctz (赞：26)

[安利一波我的$blog$](https://ctz45562.github.io/2019/03/04/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P3582-%E3%80%90-POI2015-KIN%E3%80%91/)

[传送门](https://www.luogu.org/problemnew/show/P3582)

这篇题解的思路其实是因机房某位王姓神仙指点而来$QwQ$

首先要会线段树维护最大子段和，[不会的可以做做这个](https://www.luogu.org/problemnew/show/SP1716)

把题目简化一下：

> 任取一段闭区间，使区间贡献最大

有没有种最大子段和的感觉？但是要求数字重复的不能算。那么如果有两个相同的元素，一个贡献置为为正，另一个置为负，互相抵消就能去重了。于是扫一遍依次加入每个点的贡献，每次都取一下当前最大值。

放个图来看：

![](https://cdn.luogu.com.cn/upload/pic/53220.png )

红色的是相同的元素。

在第一个红点会有正的贡献$a$。

然后加到第二个：

![](https://cdn.luogu.com.cn/upload/pic/53221.png )

把第一个置为$-a$，这时如果同时选$1$、$2​$点就会正好抵消。而如果只选中第一个点虽然贡献不正确，但是因为是一边扫一遍取最大值，所以这种情况在之前已经被取到了。

再来第三个：

![](https://cdn.luogu.com.cn/upload/pic/53222.png )

注意要把第一个**清零**，否则这时如果三个点都选的话贡献就为负了。

记录一下每种颜色上一个出现的位置就能做了$QwQ$。

细节：注意判断该颜色是否为第一次出现。还有要开$long\ long$

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 1000005
#define inf 0x3f3f3f3f
#define pn putchar('\n')
#define px(x) putchar(x)
#define ps putchar(' ')
#define pd puts("======================")
#define pj puts("++++++++++++++++++++++")

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
template<typename T>
inline T read(){
	T x=0;
	int y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
int f[maxn],pre[maxn],last[maxn];
//f是电影，pre[i]是上一个和f[i]相同的位置，last是某种颜色最后一次出现的位置
long long a[maxn];
//a记录电影贡献
struct Segment_Tree{
	long long ll[maxn<<2],rr[maxn<<2],ma[maxn<<2],sum[maxn<<2];
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
	inline void update(int node){
		sum[node]=sum[ls(node)]+sum[rs(node)];
		ll[node]=max(ll[ls(node)],sum[ls(node)]+ll[rs(node)]);
		rr[node]=max(rr[rs(node)],sum[rs(node)]+rr[ls(node)]);
		ma[node]=max(max(ma[ls(node)],ma[rs(node)]),rr[ls(node)]+ll[rs(node)]);
	}
	void add(int poi,int l,int r,int node,long long d){
        //把点poi的值改为d
		if(l==r){
			sum[node]=ll[node]=rr[node]=ma[node]=d;
			return;
		}
		int mid=l+r>>1;
		if(poi<=mid)add(poi,l,mid,ls(node),d);
		else add(poi,mid+1,r,rs(node),d);
		update(node);
	}
}st;
int main(){
	int n=read(),m=read();
	for(register int i=1;i<=n;++i)
		f[i]=read();
	for(register int i=1;i<=m;++i)
		a[i]=read<long long>();
	long long ans=0;
	for(register int i=1;i<=n;++i){
		pre[i]=last[f[i]],last[f[i]]=i;
		if(pre[i])st.add(pre[i],1,n,1,-a[f[i]]);
        //把上一个该颜色的位置贡献置为负
		if(pre[pre[i]])st.add(pre[pre[i]],1,n,1,0);
        //把上上个贡献置为0
		st.add(i,1,n,1,a[f[i]]);
        //加上该点的贡献
		ans=max(ans,st.ma[1]);
        //一边跑一边取最大值
	}
	printf("%lld\n",ans);
}
```



---

## 作者：Apricot (赞：10)

## 线段树。
### 这道题乍一看是道dp，但是发现1e6的范围。。。~~(N^2过百万)~~并且有后效性qaqqqqqq......
我的思路是这样的：考虑暴力，我们每次枚举左端点，O（n）求和，复杂度N^2。如何优化呢？考虑前缀和，当我们扫过某个点后会对答案产生什么影响？设NXT[ i ]表示i点之后第一个与 i 相同的数字的编号，那么我们只需要在[1,nxt[i]-1]中减去i 的贡献，在[ nxt[i],nxt[nxt[i]] ]范围内加上贡献就好了。注意特判边界（一开始60分qwq）

### code：
```
#include<iostream>
#include<cstdio>
#include<queue>
#include<algorithm>
#include<cstring>
#define int long long 
#define half (l+r)>>1
const int maxn=5000006;
using namespace std;
int n,m;
struct hzw 
{
    int tag,sum,lc,rc,mx;
}t[maxn];
int id[maxn],cost[maxn],nxt[maxn];
int pan[maxn];
bool flag[maxn];
int val[maxn];
inline void pushup(int s)
{
    t[s].sum=t[t[s].lc].sum+t[t[s].rc].sum;
    t[s].mx=max(t[t[s].lc].mx,t[t[s].rc].mx);
}
int tot;
inline void build(int s,int l,int r)
{
    if (l==r)
    {
        t[s].sum+=val[l];
        t[s].mx=val[l];
        return;
    }
    int mid=half;
    t[s].lc=++tot;
    build(tot,l,mid);
    t[s].rc=++tot;
    build(tot,mid+1,r);
    pushup(s);
}
inline void pushdown(int s,int l,int r)
{
    int mid=half,le=t[s].lc,ri=t[s].rc;
    t[le].tag+=t[s].tag,t[ri].tag+=t[s].tag;
    t[le].sum+=(mid-l+1)*t[s].tag,t[ri].sum+=(r-mid)*t[s].tag;
    t[le].mx+=t[s].tag,t[ri].mx+=t[s].tag;
    t[s].tag=0;
}
inline void update(int s,int k,int cl,int cr,int l,int r)
{
    if (l==cl&&r==cr)
    {
        t[s].sum+=(r-l+1)*k;
        t[s].tag+=k;
        t[s].mx+=k;
        return;
    }
    int mid=half;
    if (t[s].tag) pushdown(s,l,r);
    if (cr<=mid) update(t[s].lc,k,cl,cr,l,mid);
    else if (cl>mid) update(t[s].rc,k,cl,cr,mid+1,r);
    else 
    {
        update(t[s].lc,k,cl,mid,l,mid);
        update(t[s].rc,k,mid+1,cr,mid+1,r);
    }
    pushup(s);
}
inline int query(int s,int cl,int cr,int l,int r)
{
    if (l==cl&&r==cr)
    {
        return t[s].mx;
    }
    int mid=half;
    if (t[s].tag) pushdown(s,l,r);
    if (cr<=mid) return query(t[s].lc,cl,cr,l,mid);
    else if (cl>mid) return query(t[s].rc,cl,cr,mid+1,r);
    else
    {
        return max(query(t[s].lc,cl,mid,l,mid),query(t[s].rc,mid+1,cr,mid+1,r));
    }
}
signed main()
{
    cin>>n>>m;
    tot=1;
    for (int i=1;i<=n;++i) scanf("%lld",&id[i]);
    for (int i=1;i<=m;++i) scanf("%lld",&cost[i]);
    for (int i=1;i<=n;++i)
    {
        if (pan[id[i]])
        {
            nxt[pan[id[i]]]=i;
            pan[id[i]]=i;
            if (!flag[id[i]])
            {
                flag[id[i]]=1;
                val[i]=val[i-1]-cost[id[i]];
            } 
            else val[i]=val[i-1];
            continue;
        }
        int tmp=val[i-1]+cost[id[i]];
        val[i]=tmp;
        pan[id[i]]=i;
    }
    int ans=-23333;
    build(1,1,n);
    for (int i=1;i<=n;++i)
    {
        ans=max(ans,query(1,i,n,1,n));
        if (nxt[i]) 
        {
            int tmp;
            if (!nxt[nxt[i]])  tmp=n+1;//特判
            else tmp=nxt[nxt[i]];
            tmp--;
            update(1,-cost[id[i]],1,nxt[i]-1,1,n);
            update(1,cost[id[i]],nxt[i],tmp,1,n);
        }
        else update(1,-cost[id[i]],1,n,1,n);//特判
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：King丨帝御威 (赞：9)

## ~~不说废话~~……

这道题目我们可以考虑先记录每种电影上一次开播时间和下一次开播时间(即以下代码中的$last$数组和$nxt$数组)，然后对于每种电影，我们可以先处理中它是否播放过对后面区间的影响情况，然后再对$n$个时间点分别考虑，我们可以枚举左端点，然后根据左端点电影的播放情况就可以确定它可以影响到的最右端点，然后不断更新，更新过程中记录最大值，最后那个最大值即为答案。

```cpp
#include<cstdio>
#include<algorithm>
#include<cctype>
#define ll long long
#define maxn 1000007
#define ls rt<<1
#define rs rt<<1|1
using namespace std;
int n,m,f[maxn],nxt[maxn],last[maxn],a[maxn];
ll ans;
inline int qread() {            //快读，不解释……
  char c=getchar();int num=0,f=1;
  for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
  for(;isdigit(c);c=getchar()) num=num*10+c-'0';
  return num*f;
}
struct Tree {
  ll maxx,lazy;
}tree[maxn<<2];
inline void pushdown(int rt) {    //下放lazy标记。
  if(tree[rt].lazy) {
    tree[ls].lazy+=tree[rt].lazy;
    tree[rs].lazy+=tree[rt].lazy;
    tree[rs].maxx+=tree[rt].lazy;
    tree[ls].maxx+=tree[rt].lazy;
    tree[rt].lazy=0;
  }
}
void modify(int rt,int l,int r,int L,int R,int val) { //区间修改，用于后面的更新。
  if(L>r||R<l) return;
  if(L<=l&&r<=R) {
    tree[rt].lazy+=val;
    tree[rt].maxx+=val;
    return;
  }
  pushdown(rt);
  int mid=(l+r)>>1;
  modify(ls,l,mid,L,R,val),modify(rs,mid+1,r,L,R,val);
  tree[rt].maxx=max(tree[ls].maxx,tree[rs].maxx);
}
int main() {
  n=qread(),m=qread();
  for(int i=1;i<=n;++i) f[i]=qread();
  for(int i=1;i<=m;++i) a[i]=qread();
  for(int i=n;i>=1;--i) nxt[i]=last[f[i]],last[f[i]]=i; //处理出nxt和last数组。
  for(int i=1;i<=m;++i) {
    if(last[i]) {                   //如果这个电影已经播放过。
      int zrj=nxt[last[i]];
      if(zrj) modify(1,1,n,last[i],zrj-1,a[i]);  
      //如果这不是最后一次播放这个电影，那么可以影响到的最右端点是nxt[last[i]]-1，然后last[i]就是左端点，也是第一次看，所以在这个区间加上这个电影的价值。
      else modify(1,1,n,last[i],n,a[i]);  //如果是最后一次，那么它将一直影响到最后。
    }
  }
  for(int i=1;i<=n;++i) {
    ans=max(ans,tree[1].maxx);         //每次更新一下最大值。
    int zrj=nxt[i];
    if(zrj) {					//如果第二次播放。
      modify(1,1,n,i,zrj-1,-a[f[i]]);  //在这次和之后的一次的区间上价值减去这个电影的价值，因为相同电影看了价值为0。
      if(nxt[zrj]) modify(1,1,n,zrj,nxt[zrj]-1,a[f[i]]); //第二次和第三次之间加上这个电影的价值(因为是以第二次为左端点，只看了一次)。
      else modify(1,1,n,zrj,n,a[f[i]]); //不然就把第二次之后的加上这个价值。
    }
    else modify(1,1,n,i,n,-a[f[i]]);  //没有第二次播放，就从当前时间开始一直到最后，减去这个价值。
  }
  printf("%lld\n",ans);
  return 0;
}
```

---

## 作者：JJA_ (赞：9)

题目链接 [link](https://www.luogu.com.cn/problem/P3582)

## 一句话题意

给定序列 $A$ ，计算 $A$ 的最大子段和，其中重复的数只能计算一遍。

## 思路

现在看来，就是一道线段树计算区间最大值的模版应用。当然，要是还不会的话，[这里面](https://www.luogu.com.cn/problem/SP1716)讲的还是挺清楚的。简单概括就是统计左端点和右端点分别的子段和。

回到这道题来看，会发现，思路真的很像。

只需要记录每次电影上次播放的时间和下次播放的时间，再将它们抵消为 $0$，个人感觉和主席树（或者是并查集？）有一丝丝相似之处（？。

那如何抵消？如果将后一次单点修改成 $0$ 的话会使结果很大可能上不正确。那么该怎么做呢？如果对计算最大子段和掌握很好的话，不难看出，统计完之后，可以将前一次出现改为负值，再前一次改为 $0$ ，这样对统计结果是没有影响的，但同时也可以不把重复的有趣值统计进去，而是抵消掉。

## 完整代码：
~~~cpp
#include<bits/stdc++.h>
#define mid(l,r) (l+r)>>1
#define int long long
#define lc(a) a<<1
#define rc(a) a<<1|1
#define MAXN 1000005
//#define max(a,b) a>b?a:b
#define forr(i,a,b) for(int i=a;i<=b;++i)
#define chkmax(a,b) a=a>b?a:b
#define de puts("debug");
using namespace std;
int a[MAXN],f[MA‬XN];
int pre[MAXN],last[MAXN];
int n,m;
typedef struct Segment_Tree{
	int les,res;
	int ans,val;
}Tree;
Tree tree[MAXN*4];
void update(int i){
	Tree l=tree[lc(i)],r=tree[rc(i)];
	tree[i].val=l.val+r.val;
	tree[i].les=max(l.les,l.val+r.les);
	tree[i].res=max(r.res,r.val+l.res);
	tree[i].ans=max(l.res+r.les,max(l.ans,r.ans));
}
void build(int i,int l,int r){
	if(l==r){
		tree[i].ans=tree[i].les=tree[i].res=tree[i].val=a[l];
		return;
	}
	int mid=mid(l,r);
	build(lc(i),l,mid);
	build(rc(i),mid+1,r);
	update(i);
}
void Change(int p,int i,int l,int r,int val){
	if(l==r){
		tree[i].ans=tree[i].les=tree[i].res=tree[i].val=val;
		return;
	}
	int mid=mid(l,r);
	if(p<=mid){
		Change(p,lc(i),l,mid,val);
	}
	else Change(p,rc(i),mid+1,r,val);
	update(i);
}
int ans;
signed main(){
	scanf("%lld%lld",&n,&m);
	forr(i,1,n){
		cin>>f[i];
	}
	forr(i,1,m){
		cin>>a[i];
	}
	forr(i,1,n){
		pre[i]=last[f[i]],last[f[i]]=i;
		if(pre[i]){
			Change(pre[i],1,1,n,-a[f[i]]);
		}
		if(pre[pre[i]]){
			Change(pre[pre[i]],1,1,n,0);
		}
		Change(i,1,1,n,a[f[i]]);
		ans=max(ans,tree[1].ans);
	}
	printf("%lld",ans);
}
~~~

---

## 作者：_Diu_ (赞：4)

[传送门](https://www.luogu.com.cn/problem/P3582)

这一道题用的是线段树维护

## 最大子段和

即如果这一题重看电影可以获得好看值的情况下求的结果

最大子段和怎么维护呢？

线段树上的每一个节点都存四个值

```cpp
struct cxk{//不要介意这个cxk，个人习惯
	int l,r,ans,sum;
}tree[N*4];
```

$sum$代表这一段区间内所有值的和，正常用线段树维护即可

$l$代表这一段区间内从左端往右的最大子段，即：

$\large{MAX}\sum\limits_{i=1}^nw_{f_i}$

如何维护$l$呢

可以分为两种情况：

第一种，这段区间的右端点在中点左边

$l_o=l_{o*2}$

第二种，这段区间的右端点在中点右边，那么需要左子树的全部即右子树靠左端点的部分

$l_o=sum_{o*2}+l_{o*2+1}$

两者取最大值即可

$r$代表一段区间内从右往左的最大子段，求的方法类比$l$

$r_o=MAX(sum_{o*2+1}+r_{o*2},r_{o*2+1})$

$ans$就代表一段区间内的最大子段和，即答案

这里除了考虑左端点和右端点，还要考虑中间部分，分三种情况：

第一种，是这个区间完全在中点往左，也就是左子树的$ans$

第二种，就是完全往右，右子树的$ans$

第三种，就是刚好在中间，就是左子树的$r$和右子树的$l$的和

当然还要和这棵树的$l$和$r$取$max$

$ans_o=MAX(l_o,r_o,ans_{o*2},ans_{o*2+1},r_{o*2}+l_{o*2+1})$

值得注意一下，这一题查询的时候我返回的值是一个结构体，最后只需要返回的值中的$ans$就好了

```cpp
void update(int o,int l,int r,int x,int v){
	if(l>x||r<x)return;
	if(l==r&&l==x){
		tree[o].l=tree[o].r=tree[o].ans=tree[o].sum=v;
		return;
	}
	int mid=(l+r)/2;
	if(x<=mid)update(o*2,l,mid,x,v);
	else update(o*2+1,mid+1,r,x,v);
	tree[o].sum=tree[o*2].sum+tree[o*2+1].sum;
	tree[o].l=max(tree[o*2].l,tree[o*2].sum+tree[o*2+1].l);
	tree[o].r=max(tree[o*2+1].r,tree[o*2+1].sum+tree[o*2].r);
	tree[o].ans=max(max(tree[o].l,tree[o].r),max(tree[o*2].r+tree[o*2+1].l,max(tree[o*2].ans,tree[o*2+1].ans)));
}
cxk query(int o,int l,int r,int x,int y){
	if(l>y||r<x)return {0,0,0,0};
	if(l>=x&&r<=y)return tree[o];
	int mid=(l+r)/2;
	cxk v1=query(o*2,l,mid,x,y);
	cxk v2=query(o*2+1,mid+1,r,x,y);
	cxk v;
	v.sum=v1.sum+v2.sum;
	v.l=max(v1.l,v1.sum+v2.l);
	v.r=max(v2.r,v2.sum+v1.r);
	v.ans=max(max(v.l,v.r),max(v1.r+v2.l,max(v1.ans,v2.ans)));
	return v;
}
```

好了，回归题目，这一题除了在求最大子段和，还要求同样的电影不能重看。

我们可以维护每一个$1,i$的最大子段和

我们可以用一个$last$数组存该电影上一次看和上两次看的时候

每一次看把前一次看的值改成负的，把再前一次的改成$0$，这样就可以保证当前后缀的值中重复看的电影不算，然后用线段树维护就好了

上代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define max(x,y) (x>y?x:y)
using namespace std;
const int N=1000010;
int n,m,f[N],w[N],last[2][N],ans;
struct cxk{
	int l,r,ans,sum;
}tree[N*4];
void update(int o,int l,int r,int x,int v){
	if(l>x||r<x)return;
	if(l==r&&l==x){
		tree[o].l=tree[o].r=tree[o].ans=tree[o].sum=v;
		return;
	}
	int mid=(l+r)/2;
	if(x<=mid)update(o*2,l,mid,x,v);
	else update(o*2+1,mid+1,r,x,v);
	tree[o].sum=tree[o*2].sum+tree[o*2+1].sum;
	tree[o].l=max(tree[o*2].l,tree[o*2].sum+tree[o*2+1].l);
	tree[o].r=max(tree[o*2+1].r,tree[o*2+1].sum+tree[o*2].r);
	tree[o].ans=max(max(tree[o].l,tree[o].r),max(tree[o*2].r+tree[o*2+1].l,max(tree[o*2].ans,tree[o*2+1].ans)));
}
cxk query(int o,int l,int r,int x,int y){
	if(l>y||r<x)return {0,0,0,0};
	if(l>=x&&r<=y)return tree[o];
	int mid=(l+r)/2;
	cxk v1=query(o*2,l,mid,x,y);
	cxk v2=query(o*2+1,mid+1,r,x,y);
	cxk v;
	v.sum=v1.sum+v2.sum;
	v.l=max(v1.l,v1.sum+v2.l);
	v.r=max(v2.r,v2.sum+v1.r);
	v.ans=max(max(v.l,v.r),max(v1.r+v2.l,max(v1.ans,v2.ans)));
	return v;
}
signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)scanf("%lld",&f[i]);
	for(int i=1;i<=m;i++)scanf("%lld",&w[i]);
	for(int i=1;i<=n;i++){
		int x=f[i];
		if(!last[0][x]){//如果之前没有出现过
			last[0][x]=i;//迭代
			update(1,1,n,i,w[x]);//改值
		}else if(!last[1][x]){//如果之前出现过一次
			last[1][x]=last[0][x];//迭代
			last[0][x]=i;
			update(1,1,n,last[1][x],-w[x]);//改值
			update(1,1,n,i,w[x]);
		}else{//如果之前出现过多次
			update(1,1,n,last[1][x],0);//改值
			update(1,1,n,last[0][x],-w[x]);
			update(1,1,n,i,w[x]);
			last[1][x]=last[0][x];//迭代
			last[0][x]=i;
		}//注意这里要注意一下改值和迭代的顺序
		ans=max(ans,query(1,1,n,1,i).ans);
	}
	printf("%lld\n",ans);
}
```

**完结**

---

## 作者：LlLlCc (赞：4)

这题和[P2605 [ZJOI2010]基站选址](https://www.luogu.com.cn/problem/P2605)有异曲同工之处，过了那题再做这题就很轻松了

------------
正着做不好做，我们考虑每一个人对答案的贡献

我们先枚举所选区间的左端点$L$，显然，$L$左边的值对$L$都是没有贡献的，所以我们只要计算其右边的值就好了

对于其右边的值，其影响的区间也很好求，不妨设：

$\large Next_i:$第$i$个值右边最近的相同值的位置

显然，对于第$i$个值，他所影响的区间是$i$到$Next_i-1$，所以当右端点在这段区间时，第$i$个值对答案是有贡献的，即可以用线段树将区间加上第$i$个值对于的$w_i$

要注意一点，如果第$i$个值计算了，那么$Next_i$之后的相同值对于当前的左端点都不需要计算了，因为前面有一个相同的值$i$了

所以，对于当前的左端点$L$，其最大值就是在线段树中区间$L$到$n$的最大值

好了，左端点是$L$的区间最大值已经计算完了，接下来我们考虑左端点为$L+1$的区间

最暴力的做法就是重新建树，刚才的操作重新来一遍，但太慢了肯定过不了

看$\large [L,R]\rightarrow [L+1,R]$

不难发现，只有和第$L$个值有关的量变了，其他都没变，所以我们只需要处理第$L$个值就好了

但是第$L$个值影响了哪些量呢？

首先，因为$L+1>L$，所以$w_L$肯定是取不到的，收回之前的区间区间加，即$[L,Next_L-1]-w_i$

之前$Next_L$及其后面的和$L$相同的值都没有计算，以为前面有了$L$

但是现在$L$已经没有了，所以计算$Next_L$了，做法和前面一样，线段树实现区间加

这样枚举完$1$到$n$，每次操作都是$logn$的，时间复杂度即为$O(nlogn)$，过$10^6$绰绰有余

## code
```
#include<bits/stdc++.h>
#define maxn 1000005
#define ll long long
using namespace std;
int n,m,Nxt[maxn],a[maxn],b[maxn],lst[maxn],L,R,x;
bool vis[maxn];
ll Ans;
struct lc{
	int L,R;
	ll k,Mx;
}tree[maxn<<2];
inline int read(){
	int ret=0;char ch=getchar();
	while (ch<'0'||ch>'9') ch=getchar();
	while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
	return ret;
}
inline void build(int k,int L,int R){
	tree[k].L=L,tree[k].R=R;
	if (L==R) return;
	int mid=L+R>>1;
	build(k<<1,L,mid);build(k<<1|1,mid+1,R);
}
inline void down(int k){
	tree[k<<1].Mx+=tree[k].k;
	tree[k<<1].k+=tree[k].k;
	tree[k<<1|1].Mx+=tree[k].k;
	tree[k<<1|1].k+=tree[k].k;
	tree[k].k=0;
}
inline void change(int k){
	if (tree[k].L>=L&&tree[k].R<=R){tree[k].k+=x,tree[k].Mx+=x;return;}
	if (tree[k].k) down(k);
	int mid=tree[k].L+tree[k].R>>1;
	if (L<=mid) change(k<<1);
	if (R>mid) change(k<<1|1);
	tree[k].Mx=max(tree[k<<1].Mx,tree[k<<1|1].Mx);
}
inline ll Get(int k){
	if (tree[k].L>=L&&tree[k].R<=R) return tree[k].Mx;
	if (tree[k].k) down(k);
	int mid=tree[k].L+tree[k].R>>1;ll Mx=0;
	if (L<=mid) Mx=Get(k<<1);
	if (R>mid) Mx=max(Mx,Get(k<<1|1));
	tree[k].Mx=max(tree[k<<1].Mx,tree[k<<1|1].Mx);
	return Mx;
}
int main(){
	n=read(),m=read();build(1,1,n);
	for (int i=1;i<=n;i++) a[i]=read(),Nxt[i]=n+1;Nxt[n+1]=n+2;
	for (int i=1;i<=m;i++) b[i]=read();
	for (int i=1;i<=n;i++) Nxt[lst[a[i]]]=i,lst[a[i]]=i;
	for (int i=1;i<=n;i++) if (!vis[a[i]]) L=i,R=Nxt[i]-1,x=b[a[i]],change(1),vis[a[i]]=1;
    for (int i=1;i<=n;i++){
    	L=i,R=n;Ans=max(Ans,Get(1));
    	L=i+1,R=Nxt[i]-1,x=-b[a[i]];change(1);
    	L=Nxt[i],R=Nxt[Nxt[i]]-1,x=b[a[Nxt[i]]];
		if (L<=n) change(1);
	}
	printf("%lld",Ans);
	return 0;
}
```

### 最后，如有不懂的，欢迎留言或者私信！

---

## 作者：moye到碗里来 (赞：4)

之前做完的时候是靠着感觉在做，今天重新看的时候才发现当时我压根就没理解，想了好久，翻了很多篇题解，发现大家思路性的东西写的都真的意识流。。。像我这种弱省的蒟蒻只能Orz

为了帮助那些像我一样的蒟蒻，我在这里讲一下做题的思路

首先我们分析问题，第一眼看上去像是个O(N)的DP题。。但是，你发现你压根推不出转移方程，这是显然的，因为它的选择具有后效性。。

反正我也不知道怎么说。。你就会想到一天一天往后面推来求解。。纯靠做题感觉= =

我们把之前一天记为pre[i]，不然我都看不懂自己写的啥。。

然后你就把当前推到的一天作为最后一天，如果这一天我们选择看，那么显然的，它最优的选择是看到上一次同样是这一部电影那一天的后一天（pre[i] + 1）（稍微有点绕），为什么？因为你若是再往前面看，就会看到重复的今天这部电影的，那你今天的电影的好感不就没了？那跟你昨天看有啥区别，甚至还会更差。。所以我们发现今天的影响最多会影响到上一次放这部电影那一天（pre[i]）。。

然后我们如果设立一个数组，记录**今天**到之前每一天所能达到的最大好感度，显然，你今天看电影会使得这一天(i)到之前同样是这部电影的那一天(pre[i])的所有值增加。

同时你需要把之前同样是这部电影的那一天(pre[i])到在那更早之前的同样是这部电影的那一天的后一天(pre[pre[i]] + 1)的值减少，一开始我没有想通这一点，认为可能会对后续造成影响，但是仔细分析后发现，假如之后有一天（j > i），它同样影响到了这之前的那一天（pre[j] < pre[i]）那么它一定经过了今天（i）,所以同样会使得那一天的好感度减少，因此要减去。（你问我为啥只到（pre[i] + 1）?因为之前已经被减过了啊。。。）

哦，对了关于答案的统计，就是每一次更新后取一次区间最大值。（你每次往后枚举，同时区间最大值会覆盖之前所有的点，显然考虑所有情况）

区间加法，区间最大值，因此线段树走起

~~献上我无敌大常数的垃圾线段树~~

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll MAXN = 1000000+5;
 
struct node
{
    ll num,lazy;
    node *ls,*rs;
    node(ll n,node *l,node *r) : num(n),ls(l),rs(r),lazy(0){}
    node(){}
    inline void pushup(){this->num = max(ls->num,rs->num);}
    inline void pushdown(){
        if(this->lazy && this->ls != NULL)
        {
            rs->num += this->lazy;ls->num += this->lazy;
            rs->lazy += this->lazy;ls->lazy += this->lazy;
            this->lazy = 0;
        }
    }
}pool[MAXN<<1];
node *NewNode(ll num,node *ls,node *rs){
    static ll cnt = 0;
    pool[cnt] = node(num,ls,rs);
    return &pool[cnt++];
}
node *build(ll l,ll r){
    node *rt = NewNode(0,NULL,NULL);ll mid = (l+r) >> 1;
    if(l < r){
        rt->ls = build(l,mid);
        rt->rs = build(mid + 1,r);
    } 
    return rt;
}
void add(node *rt,ll L,ll R,ll l,ll r,ll x){
    ll mid = (l + r) >> 1;
    if(L > R)return ;
    if(L <= l && r <= R){
        rt->num += x;
        rt->lazy += x;
        return ;
    }  
    rt->pushdown(); 
    if(mid >= L)add(rt->ls,L,R,l,mid,x);
    if(mid < R)add(rt->rs,L,R,mid + 1,r,x);
    rt->pushup();
}
ll ans = 0;
node *rt;
ll n,m;
ll f[MAXN],w[MAXN],pre[MAXN],now[MAXN];
int main()
{
    //freopen("1.in","r",stdin);
    //freopen("1.out","w",stdout);
    scanf("%lld %lld",&n,&m);
    for(ll i = 1; i <= n; i++){
        scanf("%lld",&f[i]);
        pre[i] = now[f[i]];
        now[f[i]] = i;
    }
   // for(int i = 1; i <= n; i++){
  //      printf("%d ",pre[i]);
   // }
   // puts(" ");
    rt = build(1,n);
    for(ll i = 1; i <= m; i++){scanf("%lld",&w[i]);}
    for(ll i = 1; i <= n; i++){
        add(rt,pre[i] + 1,i,1,n,w[f[i]]);
        add(rt,pre[pre[i]] + 1,pre[i],1,n,-w[f[i]]);
       // printf("%lld\n",ans);
        ans = max(ans,rt->num);
    }
    printf("%lld",ans);
}

```

---

## 作者：xiezheyuan (赞：3)

## 简要题意

给出一个长度为 $n$ 个二元组 $(f_i,w_{f_i})$。求出其的最大子段 $w_{f_i}$ 和，$f_i$ 出现多次的 $w_{f_i}$ 不对答案产生贡献。

$1\leq n,f_i,w_i\leq 10^6$

## 思路

给一个貌似不一样的做法。我们换一个视角看最大子段和。

首先考虑最大子段和到底是什么。序列 $a$ 的最大子段和形式化定义为：

$$
\max_{L=1}^{n}\max_{R=L}^{n}\sum_{k=L}^{R}a_k
$$

记 $b$ 为 $a$ 的 **后缀和**，则可以变形为：

$$
\max_{L=1}^{n}\max_{R=L}^{n}b_{L} - b_{R+1}
$$

交换 $\max$ 顺序得：

$$
\max_{R=1}^{n}\max_{L=1}^{R}b_L-b_{R+1}
$$

我们可以用线段树维护后面那个差分的形式，然后枚举 $R$ 扫一遍即可。

具体来说考虑每加入一个 $a_i$，记 $c_i$ 为当前 $L=i$ 的差分，则可以将区间 $[1,i]$ 内的所有 $j$，$c_j$ 加上 $a_i$。然后维护一个区间最大值即可。时间复杂度是 $O(n\log n)$。

回到这道题，关键在于如何剔除重复元素的贡献。

给一个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/bkg5v1qp.png)

假设现在需要加入第 $A$ 个元素。考虑记录它前面第一个与它相同的元素是第 $B$ 个，第二个是第 $C$ 个。

则位于 $[B+1,A]$ 区间（粉色段）的后缀和无需剔除贡献（因为只有 $A$ 一个元素），而是需要加入 $A$ 的贡献。所以我们对区间 $[B+1,A]$ 的后缀和加上 $w_{f_{A}}$。

位于 $[1,B]$ 区间的后缀和需要剔除贡献，但是我们只需要剔除 $[C+1, B]$ 区间（蓝色段）的贡献就好了。也就是对区间 $[C+1, B]$ 的后缀和减去 $w_{f_A}$。

为什么呢？因为 $[1,C]$ 原本是没有贡献的，因为加入 $B$ 的时候（以及 $B$ 之前的元素）已经将这一段剔除了（因为包含了 $B,C$ 至少两个相同的元素）。而 $[C+1,B]$ 是我们在加入 $B$ 的时候特意保留增加了贡献的（具体参考我们第一个进行的操作），所以要剔除。

$C,B$ 用两个桶就可以维护。所以时间复杂度仍然是 $O(n\log n)$。去掉线段树部分，关键逻辑部分出乎意料的短。

## 代码

```cpp
#include <bits/stdc++.h>
#define ls (i << 1)
#define rs (i << 1 | 1)
#define mid ((l + r) >> 1)
#define int long long
using namespace std;

const int N = 1e6 + 5;
int n,m,f[N],w[N], bkt[N], bkt2[N], ans = LLONG_MIN;
int t[N << 2], tag[N << 2];

void pushup(int i){t[i] = max(t[ls], t[rs]);}

void pushdown(int i){
    if(tag[i]){
        tag[ls] += tag[i];tag[rs] += tag[i];
        t[ls] += tag[i];t[rs] += tag[i];
        tag[i] = 0;
    }
}

void update(int ql, int qr, int v, int i, int l, int r){
    if(ql <= l && r <= qr){
        t[i] += v, tag[i] += v;
        return;
    }
    pushdown(i);
    if(ql <= mid) update(ql, qr, v, ls, l, mid);
    if(qr > mid) update(ql, qr, v, rs, mid + 1, r);
    pushup(i);
}

int query(int ql, int qr, int i, int l, int r){
    if(ql <= l && r <= qr) return t[i];
    pushdown(i);
    int ans = LLONG_MIN;
    if(ql <= mid) ans = max(ans, query(ql, qr, ls, l, mid));
    if(qr > mid) ans = max(ans, query(ql, qr, rs, mid + 1, r));
    return ans;
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>f[i];
    for(int i=1;i<=m;i++) cin>>w[i];
    for(int i=1;i<=n;i++){
        update(bkt[f[i]] + 1, i, w[f[i]], 1, 1, n);
        if(bkt[f[i]]) update(bkt2[bkt[f[i]]] + 1, bkt[f[i]], -w[f[i]], 1, 1, n);
        bkt2[i] = bkt[f[i]];bkt[f[i]] = i;
        ans = max(ans, query(1, i, 1, 1, n));
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：liunian (赞：2)

**线段树**

区间查询最大值
```
now[a[i]]=nxt[a[i]],nxt[a[i]]=i;

```
其中用到了滚动的思想，每次将前一个值寄存起来，下一次更新时将它的val减去，这样就能够避免单部电影重复运算。

由于区间和从0开始，因此不需要```build(int l,int r,int rt){}```函数

具体代码如下：

```
#define de puts("#")
#define bug(x) cout<<#x<<" : "<<x<<endl
#include<iostream>
#include<stdio.h>
#include<string.h>
#define cha1 printf("L : %lld,R : %lld,x : %lld,l : %lld,r : %lld,rt : %lld\n",L,R,x,l,r,rt)
#define cha2 printf("L : %lld,R : %lld,l : %lld,r : %lld,rt : %lld\n",L,R,l,r,rt)
#define re register
#define int long long
using namespace std;
const int maxn=1e6+5;
int a[maxn],b[maxn],now[maxn],nxt[maxn],sum[maxn<<2],lazy[maxn<<2],dp[maxn];

void up(int rt) {
	sum[rt]=max(sum[rt<<1],sum[rt<<1|1]);
}

void down(int rt) {
	int &t=lazy[rt];
	if(!t)return;
	sum[rt<<1]+=t,sum[rt<<1|1]+=t;
	lazy[rt<<1]+=t,lazy[rt<<1|1]+=t;
	t=0;
}

void update(int L,int R,int x,int l,int r,int rt) {
	if(L>R)return;
	if(L<=l&&R>=r) {
		sum[rt]+=x;
		lazy[rt]+=x;
		return;
	}
	down(rt);
	int mid=(l+r)>>1;
	if(R<=mid)update(L,R,x,l,mid,rt<<1);
	else if(L>mid)update(L,R,x,mid+1,r,rt<<1|1);
	else {
		update(L,mid,x,l,mid,rt<<1);
		update(mid+1,R,x,mid+1,r,rt<<1|1);
	}
	up(rt);
}

int query(int L,int R,int l,int r,int rt) {
	if(L>R)return 0;
	if(L<=l&&R>=r)return sum[rt];
	down(rt);
	int mid=(l+r)>>1;
	if(R<=mid)return query(L,R,l,mid,rt<<1);
	if(L>mid)return query(L,R,mid+1,r,rt<<1|1);
	return max(query(L,mid,l,mid,rt<<1),query(mid+1,R,mid+1,r,rt<<1|1));
}

signed main() {
	int n,m;
	scanf("%lld %lld",&n,&m);
	for(re int i=1; i<=n; i++)scanf("%lld",&a[i]);
	for(re int i=1; i<=m; i++)scanf("%lld",&b[i]);
	for(re int i=1; i<=n; i++) {
//		printf("now[%lld]=%lld,nxt[%lld]=%lld\n",a[i],now[a[i]],a[i],nxt[a[i]]);
		if(nxt[a[i]])update(now[a[i]]+1,nxt[a[i]],-b[a[i]],1,n,1);
		update(nxt[a[i]]+1,i,b[a[i]],1,n,1);
		dp[i]=query(1,i,1,n,1);
		now[a[i]]=nxt[a[i]],nxt[a[i]]=i;
	}
	int ans=0;
	for(re int i=1; i<=n; i++)ans=max(ans,dp[i]);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：asuldb (赞：2)

[题目](https://www.luogu.org/problemnew/show/P3582)

感觉这种题好套路啊，怎么又是这个做法

癌不过怎么没有人和我一样些写套路做法，那干脆来写个题解吧

我们考虑枚举区间的右端点，这样我们只需要考虑从$1$到$i$的最大区间就好了

由于我们选择了这个位置作为区间的右端点，首先产生的贡献是这个电影的价值，但我们上一次看得这个电影就不能产生贡献了，而且不仅仅是不能产生贡献了，还得把原来的贡献减掉，于是把原来的位置取反

相应的，上上次出现的位置我们取反了，这次就不用考虑它了，于是把那个位置变成$0$就好了

最后的答案就是最大子段和了，线段树随便维护一下就好了

代码

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define LL long long
#define re register
#define maxn 1200005
inline int read() {
	char c=getchar();int x=0;while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return x;
}
int n,m;
int l[maxn<<1],r[maxn<<1];
LL d[maxn<<1],lc[maxn<<1],rc[maxn<<1],ans,sum[maxn<<1];
int nx[maxn],cnt[maxn];
int w[maxn],a[maxn],pos[maxn];
inline void pushup(int i) {
	sum[i]=sum[i<<1|1]+sum[i<<1];
	lc[i]=max(lc[i<<1],sum[i<<1]+lc[i<<1|1]);
	rc[i]=max(rc[i<<1|1],sum[i<<1|1]+rc[i<<1]);
	d[i]=max(d[i<<1],d[i<<1|1]);d[i]=max(d[i],lc[i<<1|1]+rc[i<<1]);
}
void build(int x,int y,int i) {
	l[i]=x,r[i]=y;
	if(x==y) return;
	int mid=x+y>>1;
	build(x,mid,i<<1),build(mid+1,y,i<<1|1);
}
void change(int pos,int i,int val) {
	if(pos==l[i]&&l[i]==r[i]) {d[i]=sum[i]=lc[i]=rc[i]=val;return;}
	int mid=l[i]+r[i]>>1;
	if(pos<=mid) change(pos,i<<1,val);
		else change(pos,i<<1|1,val);
	pushup(i);
}
int main() {
	n=read(),m=read();
	for(re int i=1;i<=n;i++) a[i]=read();
	for(re int i=1;i<=m;i++) w[i]=read();
	build(1,n,1);
	for(re int i=1;i<=n;i++) 
		nx[i]=pos[a[i]],pos[a[i]]=i;
	for(re int i=1;i<=n;i++) {
		if(!nx[i]) change(i,1,w[a[i]]);
			else if(!nx[nx[i]]) change(i,1,w[a[i]]),change(nx[i],1,-1*w[a[i]]);
				else change(i,1,w[a[i]]),change(nx[i],1,-1*w[a[i]]),change(nx[nx[i]],1,0);
		ans=max(ans,d[1]);
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：封禁用户 (赞：2)

先Orz楼下dalao，代码太高深，解释太简略，蒟蒻看不懂。

## 思路

枚举左端点，用线段树维护最大值，每次ans=max(ans,sum[1])就行（sum是线段树数组）

第一遍过了，然后加了些常数优化，就到rank1了，500ms跑完。

细节在代码里解释。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <set>
#include <map>
#include <vector>
#include <stack>
#include <list>
#define rep(i,m,n) for(register int i=m;i<=n;i++)
#define dop(i,m,n) for(register int i=m;i>=n;i--)
#define lowbit(x) (x&(-x))
#define ll long long
#define INF 2147483647
#define Open(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout);
#define Close fclose(stdin);fclose(stdout);
#define re register
using namespace std;
inline int read(){
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
const int maxn=1000010;
int a[maxn],b[maxn],Next[maxn],last[maxn],n,m,add[maxn<<2];
ll sum[maxn<<2],ans;
inline void PushDown(int now){
    if(add[now]){
      add[now<<1]+=add[now];
      add[now<<1|1]+=add[now];
      sum[now<<1]+=add[now];
      sum[now<<1|1]+=add[now];
      add[now]=0;
    }
}
inline void Change(int now,int l,int r,int wl,int wr,int p){     //线段树（RMQ）
    if(l>wr||r<wl) return;
    if(l>=wl&&r<=wr){sum[now]+=p;add[now]+=p;return;}
    PushDown(now);
    int mid=(l+r)>>1;
    Change(now<<1,l,mid,wl,wr,p);
    Change(now<<1|1,mid+1,r,wl,wr,p);
    sum[now]=max(sum[now<<1],sum[now<<1|1]);
}
int main(){
    n=read();m=read();
    rep(i,1,n) a[i]=read();
    rep(i,1,m) b[i]=read();
    dop(i,n,1) Next[i]=last[a[i]],last[a[i]]=i;    //Next[i]表示下一个放第a[i]部电影的时间,last[a[i]]表示上一个放第a[i]部电影的时间（循环执行完last[a[i]]表示第一个放第a[i]部电影的时间）
    rep(i,1,m)
       if(last[i])          //如果这部电影播放过
         if(!Next[last[i]]) Change(1,1,n,last[i],n,b[i]);   //如果没有第二次播放，把这次播放以后每个时间都加上这部电影的价值，因为这部电影播放后任何包括它的区间都能因它受益
         else Change(1,1,n,last[i],Next[last[i]]-1,b[i]);  //如果有第二次播放，把第一次播放和第二次播放之间的时间加上这部电影的价值，理由同上
    rep(i,1,n){   //枚举左端点
       ans=max(ans,sum[1]);   //更新最优解
       int t=Next[i];
       if(t){    //如果有第二次播放a[i]这部电影，
         Change(1,1,n,i,t-1,-b[a[i]]);      //先把这次和第二次播放之间减掉这部电影价值（同一部电影播放2次价值为0）
         if(Next[t]) Change(1,1,n,t,Next[t]-1,b[a[i]]);  //如果有第三次播放，把第二次和第三次之间的时间减掉这部电影价值
         else Change(1,1,n,t,n,b[a[i]]);    //否则把第二次播放之后的时间都加上这部电影价值
       }
       else Change(1,1,n,i,n,-b[a[i]]);  //如果没有第二次播放这部电影，把这部电影之后的时间都减掉这部电影价值
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：破忆 (赞：1)

## 【题意】

有 $m$ 部电影，每部电影有价值 $w$，将要放映 $n$ 天，每天放一部电影，看同一部电影多次不会获得该电影的价值，要连续看若干天电影，求最大收益。

## 【分析】

如果没有“看电影多次就没有收益”这一限制，这就是裸的最大子段和。

设第 $i$ 部电影第 $j$ 次出现的位置为 $a_{i,j}$，第 $k$ 天电影的收益为 $v_k$。

将 $v_{a_{i,1}}$ 设为 $w_i$，$v_{a_{i,2}}$ 设为 $-w_i$。

默认 $L \leqslant a_{i,1}$。

$R$ 在 $[a_{i,1},a_{i,2})$ 这段中取就会算上 $w_i$，在 $[a_{i,2},n]$ 中取贡献会抵消，符合题意。

初始时对每一种电影都进行上述操作，此时的最大子段和就是 $L=1$ 时的答案。

设在第 $i$ 天之后放的第一部相同电影的位置是 $next_i$

然后让 $L$ 取 $2$，与前一个状态的唯一区别就是需要改变 $v_{next_1}$ 与 $v_{next_{next_1}}$。

$v_{next_1}$ 取 $w_{f_1}$，$v_{next_{next_1}}$ 取 $-w_{f_1}$，再求 $[2,n]$ 的最大子段和。

重复这几个操作更新答案。

单点修改，区间最大子段和操作用线段树实现。

## 【算法】

线段树

## 【代码】

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int maxn=1e6+5,maxt=maxn*4;
int n,m;
LL f[maxn],w[maxn];
int lst[maxn],nxt[maxn];
char gc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
#define getchar gc
int read(){
    int ret=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
    while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
    return ret*f;
}
struct segment_tree{
	struct data{
		LL l,r,s,m;
	}t[maxt];
	#define ls (k<<1)
	#define rs (k<<1|1)
	#define mid (l+r>>1)
	#define s(k) t[k].s
	#define l(k) t[k].l
	#define r(k) t[k].r
	#define m(k) t[k].m
	data merge(data L,data R){
		data ret;
		ret.s=L.s+R.s;
		ret.l=max(L.l,L.s+R.l);
		ret.r=max(R.r,R.s+L.r);
		ret.m=max(ret.l,ret.r);
		ret.m=max(ret.m,max(L.m,R.m));
		return ret;
	}
	void update(int k,int l,int r,int x,int v){
		if(l==r){s(k)=l(k)=r(k)=m(k)=v;return;}
		if(x<=mid) update(ls,l,mid,x,v);
		else update(rs,mid+1,r,x,v);
		t[k]=merge(t[ls],t[rs]);
	}
	data query(int k,int l,int r,int x,int y){
		if(x<=l&&r<=y) return t[k];
		if(x<=mid&&mid<y) return merge(query(ls,l,mid,x,y),query(rs,mid+1,r,x,y));
		if(x<=mid) return query(ls,l,mid,x,y);
		if(mid<y) return query(rs,mid+1,r,x,y);
	}
}T;
LL ans;
int main(){
	freopen("P3582.in","r",stdin);
	freopen("P3582.out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=n;i++) f[i]=read();
	for(int i=1;i<=m;i++) w[i]=read();
	for(int i=1;i<=n;i++){
		if(lst[f[i]]) nxt[lst[f[i]]]=i;
		else T.update(1,1,n,i,w[f[i]]);
		lst[f[i]]=i;
	}
	memset(lst,0,sizeof lst);
	for(int i=1;i<=n;i++){
		if(!lst[f[i]]&&nxt[i]) T.update(1,1,n,nxt[i],-w[f[i]]);
		lst[f[i]]=i;
	}
	for(int i=1;i<=n;i++){
		ans=max(ans,T.query(1,1,n,i,n).m);
		if(nxt[i]) T.update(1,1,n,nxt[i],w[f[i]]);
		if(nxt[nxt[i]]) T.update(1,1,n,nxt[nxt[i]],-w[f[i]]);
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：Sor4 (赞：1)

给每个点记录前驱，当加到这个点的时候，就要把前驱以及其之前的一段删掉。

而区间的加法与最大值，显然可以用线段树维护。









    
    
    
    















```cpp
#include <cstdio>
#include <algorithm>
#define Rep( i , _begin , _end ) for(int i=(_begin),i##_END=(_end);i<=(i##_END);i++)
#define For( i , _begin , _end ) for(int i=(_begin),i##_END=(_end);i!=(i##_END);i++)
#define Lop( i , _begin , _end ) for(int i=(_begin),i##_END=(_end);i>=(i##_END);i--)
#define Dnt( i , _begin , _end ) for(int i=(_begin),i##_END=(_end);i!=(i##_END);i--)
using std :: max;
using std :: min;
typedef long long LL;
const int maxx = 1000000 + 25;
int pos[maxx],v[maxx];
int fnl[maxx],pre[maxx];
int n,m,x,y,z;
LL Tx[maxx<<2],Add[maxx<<2];
LL ans;
namespace Zyerstream{
    const int L = 1<<15;
    char buffer[L],*S,*T;
    inline char Getchar(){
        if(S == T){
            T = (S=buffer) + fread(buffer,1,L,stdin);
            if(S == T) return EOF;
        }
        return *S++;
    }
    template <class T> inline void read(T &in){
        char c;
        for(c = Getchar();c > '9' || c < '0';c = Getchar());
        for(in = 0;c >= '0' && c <= '9';c = Getchar()) in = (in<<1) + (in<<3) + c - '0'; 
    }
}
using namespace Zyerstream;
namespace Segment_Tree{
    void pushdown(int i,int l,int r){
        if(l == r) return;
        Tx[i<<1] += Add[i];Tx[i<<1|1] += Add[i];
        Add[i<<1] += Add[i];Add[i<<1|1] += Add[i];
        Add[i] = 0;
    }
    void modify(int i,int x,int y,int l,int r,int k){
        if(x <= l && r <= y) {Tx[i] += k;Add[i] += k;return;}
        int mid = (l+r) >> 1;if(Add[i]) pushdown(i,l,r);
        if(x <= mid) modify(i<<1,x,y,l,mid,k);
        if(y >  mid) modify(i<<1|1,x,y,mid+1,r,k);
        Tx[i] = max(Tx[i<<1],Tx[i<<1|1]);
    }
    LL Query(int i,int x,int y,int l,int r){
        if(x <= l && r <= y) return Tx[i];LL ans = 0;
        int mid = (l+r) >> 1;if(Add[i]) pushdown(i,l,r);
        if(x <= mid) ans = max(ans,Query(i<<1,x,y,l,mid));
        if(y >  mid) ans = max(ans,Query(i<<1|1,x,y,mid+1,r));
        return ans;
    }
}
using namespace Segment_Tree;
int main(){
    scanf("%d%d",&n,&m);
    Rep( i , 1 , n ) read(pos[i]); 
    Rep( i , 1 , m ) read(v[i]);
    Rep( i , 1 , n ) pre[i] = fnl[pos[i]],fnl[pos[i]] = i;
    Rep( i , 1 , n ){
        modify(1,pre[i] + 1,i,1,n,v[pos[i]]);
        if(pre[i]) modify(1,pre[pre[i]] + 1,pre[i],1,n,-v[pos[i]]);
        ans = max(ans,Query(1,1,i,1,n));
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Stinger (赞：0)

~~又是蒟蒻水题解的地方~~

# $\texttt{Description}$
[题面友好，不做解释](https://www.luogu.com.cn/problem/P3582)

# $\texttt{Solution}$
考试的时候没做出来。赛后才知道这是一个套路题。

对于这种“选出一段区间，要求总贡献最大”的题目，尝试沿用这样一种思路：从左往右枚举左端点，快速找到最优的右端点。本题我从右往左扫，因为比较方便。

$nxt_i$ 表示第 $i$ 部电影后面的第一部与它相同的电影在第几天放映。

然后从右往左枚举区间左端点，线段树维护对于当前的左端点，每个右端点能得到的贡献。当右端点由 $r+1$ 变为 $r$ 时，将 $[r,nxt_r)$ 区间加上 $w_{f_i}$，将 $nxt_{nxt_i}$ 区间减少 $w_{f_i}$。这个比较容易理解。

# $\texttt{Code}$
```cpp
#include <cstdio>
#define int long long

inline int max(const int x, const int y) {return x > y ? x : y;}
struct Node {
	int l, r, v, Lazy;
} c[4000005];
int wow[4000005];
void make_tree(const int O, const int L, const int R) {
	c[O].l = L, c[O].r = R;
	if (L != R) make_tree(O << 1, L, L + R >> 1), make_tree(O << 1 | 1, (L + R >> 1) + 1, R);
}
void pushdown(const int O) {
	c[O << 1].v += c[O].Lazy, c[O << 1 | 1].v += c[O].Lazy;
	c[O << 1].Lazy += c[O].Lazy, c[O << 1 | 1].Lazy += c[O].Lazy;
	c[O].Lazy = 0;
}
void update(const int O, const int L, const int R, const int d) {
	if (L <= c[O].l && c[O].r <= R) {c[O].Lazy += d, c[O].v += d; return;}
	int mid(c[O].l + c[O].r >> 1);
	pushdown(O);
	if (L <= mid) update(O << 1, L, R, d);
	if (mid < R) update(O << 1 | 1, L, R, d);
	c[O].v = max(c[O << 1].v, c[O << 1 | 1].v);
}
int f[1000005], w[1000005], nxt[1000005], pre[1000005];

signed main() {
	int n, m, ans(0LL);
	scanf("%lld%lld", &n, &m);
	for (int i(1); i <= n; ++ i) scanf("%lld", f + i);
	for (int i(1); i <= m; ++ i) scanf("%lld", w + i);
	for (int i(1); i <= n; ++ i) nxt[pre[f[i]]] = i, pre[f[i]] = i;
	make_tree(1, 1, n);
	for (int i(n); i; -- i)  {//枚举右端点
		if (nxt[i]) update(1LL, i, nxt[i] - 1LL, w[f[i]]);
		else update(1LL, i, n, w[f[i]]);//特判边界
		if (nxt[i]) {
			if (nxt[nxt[i]]) update(1LL, nxt[i], nxt[nxt[i]] - 1LL, -w[f[i]]);
			else update(1LL, nxt[i], n, -w[f[i]]);//特判边界
		}
		ans = max(ans, c[1].v);//由于是整体取最大值，可以少写一个查询函数，直接取根节点的值即可
	}
	printf("%lld", ans);
	return 0;
}
```

# $\texttt{Summary}$

这种经典的套路题还是有必要总结一下的。

首先，这种“选择一段区间，使其总贡献最大/总花费最小”的题目，应该立即反应到枚举左端点，快速找到最优右端点的方法。典型如[UVA1471](https://www.luogu.com.cn/problem/UVA1471)

其次，类似“重复的只算一次”（本题一次都不算），"求种类数"的题，一般是记录 $nxt_i$ 表示第 $i$ 个“数”后面与它种类相同的“数”，然后采用树状数组/线段树等支持区修区查或单修区查的数据结构来维护对应右端点的取值。典型如[HH的项链](https://www.luogu.com.cn/problem/P1972)

end.

---

## 作者：MuYC (赞：0)

### 好题!

讲真的这道题比较有代表性,~~比较套路?(bushi~~考试的时候没写出来(tcl )，菜是原罪

### 题意:
给你一个序列，序列上每一个元素都属于一种种类，并且每一种元素有其对应的价值，你可以任意取一段区间,计算这段区间中没有重复出现的元素种类的价值之和.你需要最大化这个价值之和.

### 思路:

这道题看上去就很让我懵逼，不知道该怎么维护"没有重复出现的元素种类"......

思路一: 直接枚举每一个区间+暴力计算，时间复杂度　O(n ^ 3),得分23分

思路二：枚举每一个左端点，不断将右端点往右边移动，记录一下移动过程中得到的价值之和的最大值,时间复杂度O(n ^ 2),得分40 分　

思路三:

考虑枚举每一个右端点，记录一下每个位置对应的种类上一次出现的位置.
      对于右端点向右边移动的操作,假设当前种类是i,将区间[pre[i]+1,i]加上i的价值,
将区间[pre[pre[i]]+1,pre[i]]减去i的价值,同时求一下区间[1,i]最大值就行了,时间复杂度O(nlogn)
得分:100pts

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long 
int mp[1000005];
int a[1000005],f[1000005];
int pre[1000005];
int n,m;
struct node{
	int l,r,Max,laz;
}T[4000005];
void build(int x,int l,int r)
{
	T[x].l = l , T[x].r = r;
	T[x].Max = 0;
	if(T[x].l == T[x].r)return ;
	int mid = (l + r) >> 1;
	build(x << 1 , l , mid);
	build(x << 1 | 1 , mid + 1 , r );
	return ;
}
void ad(int x,int k)
{
	T[x].Max += k;
	T[x].laz += k;	
}
void pushdown(int x)
{
	if(T[x].laz == 0)return ;
	ad(x << 1 , T[x].laz);
	ad(x << 1 | 1 , T[x].laz);
	T[x].laz = 0;
	return ;
}
void change(int x,int l,int r,int k)
{
	if(T[x].l >= l && T[x].r <= r){ad(x,k);return ;}
	pushdown(x);
	int mid = (T[x].l + T[x].r) >> 1;
	if(l <= mid)change(x << 1 , l , r , k);
	if(r  > mid)change(x << 1 | 1 , l , r , k);
	T[x].Max = max(T[x << 1].Max , T[x << 1 | 1].Max);
}
int getMax(int x,int l,int r)
{
	int Max = 0;
	if(T[x].l >= l && T[x].r <= r)return T[x].Max;
	pushdown(x);
	int mid = (T[x].l + T[x].r) >> 1;
	if( l <= mid )Max = max(Max,getMax(x << 1 , l , r ));
	if( r  > mid )Max = max(Max,getMax(x << 1 | 1 , l , r ));
	return Max;
}
inline int read(){
	int x = 0 ,flag = 1;
	char ch = getchar();
	for( ; ch > '9' || ch < '0' ; ch = getchar())if(ch == '-')flag = -1;
	for( ; ch >= '0' && ch <= '9' ; ch = getchar())x = (x << 3) + (x << 1) + ch - '0';
	return x * flag;
}
signed main()
{
	n = read(),m = read();
	int M = 0;
	for(int i = 1 ; i <= n ; i ++)
		a[i] = read();
	for(int j = 1 ; j <= m ; j ++)
		f[j] = read();
	for(int i = 1 ; i <= n ; i ++)
	{
		if(mp[a[i]] != 0)pre[i] = mp[a[i]];
		mp[a[i]] = i;
	}
	build(1 , 1 , n);
	for(int i = 1 ; i <= n ; i ++)
	{
		if(pre[i]){
			change(1 , pre[i] + 1 , i , f[a[i]]);
			change(1 , pre[pre[i]] + 1 , pre[i] , -f[a[i]]);
		}
		else change(1, 1 , i , f[a[i]]);
		M = max(getMax(1,1,i),M);
	}
	cout << M;
	return 0;
}
```

---

## 作者：LightningUZ (赞：0)

内容见[博客](https://blog.csdn.net/LightningUZ/article/details/89433370)

代码:
```cpp
#include<bits/stdc++.h>
#define N 1001000
#define int long long
using namespace std;
class SegmentTree
{
    private:
        struct node
        {
            int l,r;
            int s,a;
        }tree[N<<2];
    public:
        #define ls index<<1
        #define rs index<<1|1

        #define L tree[index].l
        #define R tree[index].r
        #define S tree[index].s
        #define A tree[index].a
        void Update(int index)
        {
            S=max(tree[ls].s,tree[rs].s);
        }
        void BuildTree(int l,int r,int index)
        {
            L=l,R=r;
            S=A=0;
            if (l==r)
            {
                return;
            }
            int mid=(l+r)>>1;
            BuildTree(l,mid,ls);
            BuildTree(mid+1,r,rs);
            Update(index);
        }
        void AddOne(int x,int index)
        {
            A+=x;
            S+=x;
        }
        void PushDown(int index)
        {
            if (A)
            {
                AddOne(A,ls);
                AddOne(A,rs);
                A=0;
            }
        }
        void Add(int l,int r,int x,int index)
        {
            if (l>R or L>r) return;
            if (l<=L and R<=r)
            {
                AddOne(x,index);
                return;
            }
            PushDown(index);
            Add(l,r,x,ls);
            Add(l,r,x,rs);
            Update(index);
        }
        int Query(int l,int r,int index)
        {
            if (l>R or L>r) return 0;
            if (l<=L and R<=r)
            {
                return S;
            }
            PushDown(index);
            return max(Query(l,r,ls),Query(l,r,rs));
        }
}T;

int n,m;
int a[N],b[N];
int pre[N],last[N];
void Input()
{
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%lld",&b[i]);
    }
    for(int i=1;i<=n;i++)
    {
        pre[i]=last[a[i]],last[a[i]]=i;
    }
}

void Solve()
{
    T.BuildTree(1,n,1);
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        T.Add(pre[i]+1,i,b[a[i]],1);
        if (pre[i])
        {
            T.Add(pre[pre[i]]+1,pre[i],-b[a[i]],1);
        }
        ans=max(ans,T.Query(1,i,1));
    }
    printf("%lld\n",ans);
}
main()
{
    Input();
    Solve();
    return 0;
}
```

---


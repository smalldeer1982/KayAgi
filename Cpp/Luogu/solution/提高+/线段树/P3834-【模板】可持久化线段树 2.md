# 【模板】可持久化线段树 2

## 题目背景

这是个非常经典的可持久化权值线段树入门题——静态区间第 $k$ 小。

**数据已经过加强，请使用可持久化权值线段树。同时请注意常数优化**。


## 题目描述

如题，给定 $n$ 个整数构成的序列 $a$，将对于指定的闭区间 $[l, r]$ 查询其区间内的第 $k$ 小值。


## 说明/提示

### 样例 1 解释

$n=5$，数列长度为 $5$，数列从第一项开始依次为$\{25957, 6405, 15770, 26287, 26465\}$。

- 第一次查询为 $[2, 2]$ 区间内的第一小值，即为 $6405$。
- 第二次查询为 $[3, 4]$ 区间内的第一小值，即为 $15770$。
- 第三次查询为 $[4, 5]$ 区间内的第一小值，即为 $26287$。
- 第四次查询为 $[1, 2]$ 区间内的第二小值，即为 $25957$。
- 第五次查询为 $[4, 4]$ 区间内的第一小值，即为 $26287$。


### 数据规模与约定

- 对于 $20\%$ 的数据，满足 $1 \leq n,m \leq 10$。
- 对于 $50\%$ 的数据，满足 $1 \leq n,m \leq 10^3$。
- 对于 $80\%$ 的数据，满足 $1 \leq n,m \leq 10^5$。
- 对于 $100\%$ 的数据，满足 $1 \leq n,m \leq 2\times 10^5$，$0\le a_i \leq 10^9$，$1 \leq l \leq r \leq n$，$1 \leq k \leq r - l + 1$。

## 样例 #1

### 输入

```
5 5
25957 6405 15770 26287 26465 
2 2 1
3 4 1
4 5 1
1 2 2
4 4 1
```

### 输出

```
6405
15770
26287
25957
26287
```

# 题解

## 作者：fy0123 (赞：484)

主席树模板居然题解这么少~我来写一发qwq

主席树思想是每个位置都维护一个线段树，线段树的节点是值的范围，然后第i个线段树中某个区间[x, y]维护的是，1-i中数字在[x, y]范围内的个数。这里利用到了前缀和的思想。

详细的题解见我的blog：[链接](http://blog.csdn.net/bestFy/article/details/78650360)

注意blog里面的是hdu2665，范围有一些不一样的。

然后放一下这道题我的ac代码吧。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define mid (l+r)/2
using namespace std;

const int N = 200010;
int n, q, m, cnt = 0;
int a[N], b[N], T[N];
int sum[N<<5], L[N<<5], R[N<<5];

inline int build(int l, int r)
{
    int rt = ++ cnt;
    sum[rt] = 0;
    if (l < r){
        L[rt] = build(l, mid);
        R[rt] = build(mid+1, r);
    }
    return rt;
}

inline int update(int pre, int l, int r, int x)
{
    int rt = ++ cnt;
    L[rt] = L[pre]; R[rt] = R[pre]; sum[rt] = sum[pre]+1;
    if (l < r){
        if (x <= mid) L[rt] = update(L[pre], l, mid, x);
        else R[rt] = update(R[pre], mid+1, r, x);
    }
    return rt;
}

inline int query(int u, int v, int l, int r, int k)
{
    if (l >= r) return l;
    int x = sum[L[v]] - sum[L[u]];
    if (x >= k) return query(L[u], L[v], l, mid, k);
    else return query(R[u], R[v], mid+1, r, k-x);
}

int main()
{
    scanf("%d%d", &n, &q);
    for (int i = 1; i <= n; i ++){
        scanf("%d", &a[i]);
        b[i] = a[i];
    }
    sort(b+1, b+1+n);
    m = unique(b+1, b+1+n)-b-1;
    T[0] = build(1, m);
    for (int i = 1; i <= n; i ++){
        int t = lower_bound(b+1, b+1+m, a[i])-b;
        T[i] = update(T[i-1], 1, m, t);
    }
    while (q --){
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        int t = query(T[x-1], T[y], 1, m, z);
        printf("%d\n", b[t]);
    }
    return 0;
}
```

---

## 作者：Lpy_Now (赞：409)

**学习可持久化线段树之前一定要学懂线段树，大家可以看看我转载的一篇博客（http://blog.csdn.net/a1351937368/article/details/78884465）**

学习主席树的时候全是看的其他人的博客学的，但是觉得好多人写的博客很乱，看博客的时候感觉没什么头绪，现在终于搞懂了主席树，想自己写一些东西让其他人能很轻松的看懂主席树到底是什么

**主要思想**：主席树是利用函数式的编程思想使得线段树支持查询历史版本，同时充分利用他们之间的共同数据来减少时间和内存消耗的数据结构（这些东西不理解没什么关系，到最后慢慢就懂了）一棵线段树的节点维护的是当前节点对应的区间信息，若每次区间不同则处理较为困难，，例如频繁的询问区间第K大元素（较为简单的思想是根据归并排序思想实现的归并树，但是时空复杂度都较高）

**第一部分.静态主席树**

发明者的原话：“对于原序列的每一个前缀[1···i]建立出一棵线段树维护值域上每个数出现的次数，则其树是可减的”

可以加减的理由：主席树的每个节点保存的是一颗线段树，维护的区间信息，结构相同，因此具有可加减性（**关键**）

首先开一个数组t[n]，存储内容为a中排序并去重的值（类似于离散化），每棵线段树维护的内容是a1...ai此区间中的树在t[n]中出现的次数

**举个栗子**

an：4 1 1 2 8 9 4 4 3

将序列排序并去重后得到t[n]：

tn：1 2 3 4 8 9

对前缀a[1...9]建树，1\*2，2\*1，3\*1，4\*3，8\*1，9\*1，每个数出现的次数即为线段树维护的值，树中每个节点表示t[i,j],中的数字在a[1...9]中出现的次数

建树：

![此树为a[1...9]为前缀即整个对序列信息所建立的树](http://img.blog.csdn.net/20171231111359520?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTEzNTE5MzczNjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

**思考**如何求出区间第K大值，例如求a[1,9],中第六大的数

根节点左儿子有四个元素，则第六大的元素一定在右儿子中，利用递归的思想将问题转化为求区间a[1,9]中去除t[1],t[2],t[3],后的第二大数，此时其左儿子即区间[4.5]中有四个元素，4>2，所以第二大数一定在左儿子中，递归进入左儿子中所以所求的数就是除去t[1],t[2],t[3],t[6],后的第二大数，最后区间[4,4]中有三个元素，3>2，所以区间第二大数一定在区间[4,4]中即t[4]=4,所以求得的a[1,9]的第六大值。

若需要求区间[L,R]中的第K大值

对于任意的i，a[1,i]都有一颗树，则区间[L,R]中第K大值与求a[1,R]类似，由于其具有可减性，只要在递归结束时减去a[1,L-1]所在的树对应的部分即可，例如a[L,R]，小于t[mid]的数有六个(mid=(L+R)/2)在a[1,L-1]小于t[mid]的数有两个，则在a[L,R]小于t[mid]的数有6-2=4个，递归过程与上面类似（思想类似一维前缀和）

但是对于每一个前缀分别建立一棵线段树，空间复杂度极高，会MLE，为了解决这个问题我们先画出a[1,5],a[1,6],a[1,7],a[1,8]四个前缀的线段树，如下：

![[1,5]](http://img.blog.csdn.net/20180104123950066?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTEzNTE5MzczNjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)[1,5]

![[1,6]](http://img.blog.csdn.net/20180104124542853?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTEzNTE5MzczNjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)[1,6]

![[1,7]](http://img.blog.csdn.net/20180104124829000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTEzNTE5MzczNjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)[1,7]

![[1,8]](http://img.blog.csdn.net/20180104125108139?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTEzNTE5MzczNjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)[1,8]

观察[1,8]和[1,9]我们发现例如[1,8],[1,9]有许多地方信息相同，其中包含了大量重复信息，占用了多余的空降，如何避免空间的浪费呢？例如[1,8].[1,9]在建a[1,9]时根节点直接向a[1,8]的右子树连一条边，同理对于其左儿子节点，它的左子树部分也是相同的（此时视[1,3]为根节点）因此连接一条边即可，如此我们只增加了三个节点就保存了两棵树的全部信息。

![这里写图片描述](http://img.blog.csdn.net/20180105225123866?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTEzNTE5MzczNjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![这里写图片描述](http://img.blog.csdn.net/20180105225134358?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTEzNTE5MzczNjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

因此在之前基础上建树只需开一个数组储存两个箭头所指的位置，接着向下遍历就是一棵完整的线段树增加节点为[9],[1],[4]三个节点。

![这里写图片描述](http://img.blog.csdn.net/20180105225226292?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTEzNTE5MzczNjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

**静态主席树的一些点**

1. 建树时首先需要建一棵空的线段树，即最原始的主席树，此时主席树只含有一个空的节点，之后依次对原序列按某种顺序更新，就是将原序列加入到相应的位置

2.主席树是一种特殊的线段树集，它包含了所有线段树的优势，并且可以保存历史状态，主席树查找和更新的时空复杂度都为O(nlogn)且总空间复杂度为O(nlogn+nlogn)前者为空树的复杂度，后者为更新n次的空间复杂度，缺点是空间损耗巨大

3.主席树可以处理区间[L,R]中介于[x,y]的值的问题

4.若增加空间垃圾回收则可以使空间复杂度降低一个log

**例题**

[POI]2014 KUR-Couriers(https://www.luogu.org/problemnew/show/3567)

给定长为N的序列，m组询问，每次询问一个区间[l,r]，是否存在一个数在[l,r]中出现次数大于(l-r+1)/2，若存在输出这个数，否则输出0(n,m<=500000)

**题解**

裸的线段树模板，直接把读入的数字插入到主席树中，对于每个询问[i,j]在[1,n]中看小于mid(mid=(i+j)/2)的数字有多少个，若每个数的二倍不大于j-i+1则[L,mid]中就不存在，不然再去看大于mid的数字有多少个，若两个均不行输出0.

举个栗子：1 1 3 2 3 4 3 查询区间[1,7]

首先区间二分：重点a[mid]=2 小于-> 4<7-1+1 大于-> 8<7-1+1

区间右移，如此反复，最后区间二分到1 1 3 [2 3 4 3]

小于-> 2<7-4+1 大于-> 2<7-4+1

均不满足，输出0

**第二部分·动态主席树**

动态主席树就是在静态主席树基础上增加了一批用树状数组维护的线段树

**举个栗子**

5 3
3 2 1 4 7

Q 1 4 3 询问区间[1,4]的第三小数

C 2 6 将第二个数变为6

Q 2 5 3

n是原序列个数

T[i]表示第i棵线段树的根节点编号

S[i]表示树状数组思维建的第i棵线段树的根节点编号

L[i]表示节点i的左子节点编号

R[i]表示节点i的右子节点编号

sum[i]表示节点i对应区间中数的个数。

这里离散化建树过程和静态主席树有一点不同，我们必须把所有询问先存起来并且把改变的数也加入到原序列中再离散化建树，会导致空间复杂度和静态有所区别。所以这里我们离散化后序列为3 2 1 4 6 5分别对应原序列的3 2 1 4 7和改变后的6。

之后同静态一样建空树，按原序列前缀建树

接下来就是重点了，对于题目给出的修改操作，我们新建一批线段树来记录更新，这些线段树以树状数组的思维来维护。

一开始，S[0]、S[1]、S[2]、S[3]、S[4]、S[5] （注意一共有n+1个 即 0到n）(树状数组的每个节点)这些都与T[0]相同(也就是每个节点建了一棵空树)。

对于C 2 6 这个操作， 我们只需要减去一个2，加上一个5（对应改变后的6）即可。  这个更新我们按树状数组的思想更新，比如这里的减2，我们要从i=2（原序列中第2个数2在离散化后序列中的位置）即S[2]开始更新，并往上lowbit(i)直到大于5，这里我们会更新S[2]和S[4]。 边看图边理解（这个图最后应该是在节点5那里减1）

![这里写图片描述](http://img.blog.csdn.net/20180105225821415?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTEzNTE5MzczNjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

对于加5同样是从S[2]开始更新

（这个图最后应该是在节点10那里加1）

![这里写图片描述](http://img.blog.csdn.net/20180105225926253?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTEzNTE5MzczNjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

这样我们查询的时候T[]和静态一样，再按树状数组的思维加上S[]就可算出每个节点对应区间中数的个数，再按静态的思想查询即可。

**例题**

Luogu P3168 [CQOI]任务查询系统

(https://www.luogu.org/problemnew/show/3168)

有n个任务分别持续m秒，每个任务从si秒开始到ei秒结束且有一个优先级pi

有m个询问需要回答第xi秒时正在执行任务中优先级前ki小的和，并且强制在线

输入格式：

第一行正整数mn，表示任务总数和时间范围，之后m行 每行三个数si，ei，pi，描述一个任务，接下来n行，每行四个数xi，Ai，Bi，Ci查询参数Ki由公式ki=1+(Ai+Pre+Bi)modCi得到，其中pre表示上一次查询的结果，pre初始值为1

pi<=1e7

**题解**

由于时间在变化，任务会开始或结束，由于想知道任意时刻任务执行情况，需要用到可持久化数据结构，可以维护一个主席树

先在第0s创建一个空版本，将每一个任务分为两步操作

1任务在si秒插入

2任务在ei+1秒删除

在插入删除时要新建节点

由于权值太大，需要对数据离散化









---

## 作者：Euler_Pursuer (赞：362)

### [安利我的博客](https://www.cnblogs.com/LonecharmRiver/articles/9087536.html)

# 抛出问题

给定$N$个数（$int$范围内），一共$M$次询问，每次都要询问区间$[l,r]$的第$k$大的数。
其中$N,M,l,r$均不超过$2\times 10^5$，保证询问有答案。

# 解决问题

## 暴力法

显而易见，最暴力的办法就是区间排序然后输出排序后第$k$个数。最坏情况的时间复杂度是$O(nm\lg n)$，不超时才怪。

## 主席树（可持久化线段树）法

于是针对这个问题，新的数据结构诞生了，也就是主席树。

主席树本名可持久化线段树，也就是说，主席树是基于线段树发展而来的一种数据结构。其前缀"可持久化"意在给线段树增加一些历史点来维护历史数据，使得我们能在较短时间内查询历史数据，图示如下。

![主席树一览](https://cdn.luogu.com.cn/upload/pic/20234.png)

图中的橙色节点为历史节点，其右边多出来的节点是新节点（修改节点）。

下面我们来讲怎么构建这个数据结构。

## 主席树教程

- 要求：掌握线段树这个数据结构。
- 注意：一般主席树一类的题目，难的不是写主席树，而是主席树的运用。

### 主席树的点修改

不同于普通线段树的是主席树的左右子树节点编号并不能够用计算得到，所以我们需要记录下来，但是对应的区间还是没问题的。
```cpp
//节点o表示区间[l,r]，修改点为p，修改值根据题意设定（此处我们先不谈题目，只谈数据结构）
int modify(int o, int l, int r, int p)
{
    int oo = ++node_cnt;
    lc[oo] = lc[o]; rc[oo] = rc[o]; sum[oo] = sum[o] + 1;//新节点，这里是根据模板题来的
    if(l == r)//递归底层返回新节点编号，修改父节点的儿子指向
    {
        //sum[oo] = t;如果题目要求sum是加t的再这样弄，然后上面的+1就去掉
        return oo;
    }
    int mid = (l + r) >> 1;
    if(p <= mid) lc[oo] = modify(lc[oo], l, mid);
    else rc[oo] = modify(rc[oo], mid+1, r);
    //sum[oo] = sum[lc[oo]] + sum[rc[oo]];在该题中，不需要这样做，但是很多情况下是要这样更新的
    return oo;
}
```
至于主席树的区间修改，其实也不难，但是复杂度有点高，简单点的题目一般只有点修改，有时候区间修改可以转化为点修改（比如NOIP2012借教室，有区间修改的解法也有点修改的解法）。

### 主席树的询问（历史区间和）
```cpp
int ql, qr;//查询区间[l,r]
int query(int o, int l, int r)//节点o代表区间[l,r]
{
    int ans = 0, mid = ((l + r) >> 1);
    if(!o) return 0;//不存在的子树
    if(ql <= l && r <= qr) return sum[o];//区间包含返回区间值
    //都是线段树标准操作，只不过是左右子树多了一个记录而已
    if(ql <= mid) ans += query(lc[o], l, mid);
    if(qr > mid) ans += query(rc[o], mid+1, r);
    return ans;
    //点操作就不用说了
}
```

### 主席树复杂度分析

如果只按照上述做法去做的话，每次修改的时间复杂度是$O(\lg n)$，每次询问的复杂度也是$O(\lg n)$。

## 模板题教程

模板题就是主席树的典型例题，询问区间第$k$大。先不说区间$[l,r]$吧，就说说$[1,r]$怎么做。

### 模板题的[1,r]情况

由题意知道我们肯定要对区间进行排序，但是我们的排序不是每次询问才排序，是初始化就排序并离散化——针对数字较大但数据不大的情况下（具体见方法）。排序离散化完毕后，以离散化数组建主席树，设$i$属于区间$[1,n]$，对原数组的$[1,i]$区间的数做**统计**（例如下图，区间中按离散化数组顺序统计$1$的个数、$2$的个数、$3$的个数、$4$的个数、$8$的个数、$9$的个数），有序地插入节点到离散化数组的主席树中，记录好原数组每个节点对应的线段树起点，针对样例有几个示意图。注意，这里的橙色节点是新节点，与之前出现的那个图不一样。

- $[1,1]$的情况
![图示1](https://cdn.luogu.com.cn/upload/pic/20235.png)

- $[1,4]$的情况
![图示2](https://cdn.luogu.com.cn/upload/pic/20236.png)

情况以此类推。

我们按照上面的做法构建的主席树是为了方便我们查找第$k$小值。因为我们是以离散数组构建的主席树，那么从根节点出发，左子树部分的数必定不大于右子树部分的数。于是就可以将左儿子的节点个数$x$与$k$做比较，若$k\leq x$，则第$k$小值一定在左子树里面，若$x\leq k$，则第$k$小值一定在右子树里面，然后递归往下走，缩小范围。值得注意的是，前者递归时，$k$直接传下去即可，后者递归时，需要将$k$减去左子树的数的个数再传递这个$k$值。

例如我们查找$[1,4]$中第$2$小的值，图示如下，绿色节点为该值存在的区间位置。

![图示3](https://cdn.luogu.com.cn/upload/pic/20237.png)

需要注意的是，第二个绿色节点才是绿色根节点的左子树，因为**左子树表示的区间是靠前的那一半**。

方法总结如下：
1. 将原始数组复制一份，然后排序好，然后去掉多余的数，即将数据离散化。推荐使用C++的STL中的`unique`函数；
2. 以**离散化数组**为基础，建一个全$0$的线段树，称作基础主席树；
3. 对原数据中每一个$[1,i]$区间统计，有序地插入新节点（题目中$i$每增加$1$就会多一个数，仅需对主席树对应的节点增加$1$即可）；
4. 对于查询$[1,r]$中第$k$小值的操作，找到$[1,r]$对应的根节点，我们按照线段树的方法操作即可（这个根节点及其子孙构成的必定是一颗线段树）。

### 模板题的解决

现在我们真正来解决区间询问$[l,r]$的问题。

构建主席树的方法是没有问题的，问题正在于区间询问怎么写。其实，解决方案就是将主席树$[1,r]$减去主席树$[1,l-1]$就行了。其实这个原因并不难想，首先看到主席树的底层，全部是对数的统计。当主席树$[1,r]$减去主席树$[1,l-1]$时，统计也跟着减了，也就是说，现在统计记录的是$[l,r]$区间。

而我们不需要单独减，只需要边递归查询边减，具体见查询部分代码。
```cpp
//初始的u和v分别代表的是点l-1和点r，l和r分别表示线段树点代表的区间，初始的k如题
int query(int u, int v, int l, int r, int k)
{
    int ans, mid = ((l + r) >> 1), x = sum[lc[v]] - sum[lc[u]];
    //因为主席树是区间统计好了的，只要减一下即可，无需递归到叶子再处理
    if(l == r)//找到目标位置
        return l;
    if(x >= k) ans = query(lc[u], lc[v], l, mid, k);
    else ans = query(rc[u], rc[v], mid+1, r, k-x);//右子树记得改变k的值
    return ans;
}
```

### 模板题完整代码

至此，模板题也就解决了，下面是完整代码。注意，修改点定义为了全局变量。
```cpp
#include <cstdio>
#include <algorithm>
#define M 200010

using namespace std;

int node_cnt, n, m;
int sum[M<<5], rt[M], lc[M<<5], rc[M<<5];//线段树相关
int a[M], b[M];//原序列和离散序列
int p;//修改点

void build(int &t, int l, int r)
{
    t = ++node_cnt;
    if(l == r)
        return;
    int mid = (l + r) >> 1;
    build(lc[t], l, mid);
    build(rc[t], mid+1, r);
}

int modify(int o, int l, int r)
{
    int oo = ++node_cnt;
    lc[oo] = lc[o]; rc[oo] = rc[o]; sum[oo] = sum[o] + 1;
    if(l == r)
        return oo;
    int mid = (l + r) >> 1;
    if(p <= mid) lc[oo] = modify(lc[oo], l, mid);
    else rc[oo] = modify(rc[oo], mid+1, r);
    return oo;
}

int query(int u, int v, int l, int r, int k)
{
    int ans, mid = ((l + r) >> 1), x = sum[lc[v]] - sum[lc[u]];
    if(l == r)
        return l;
    if(x >= k) ans = query(lc[u], lc[v], l, mid, k);
    else ans = query(rc[u], rc[v], mid+1, r, k-x);
    return ans;
}

int main()
{
    int l, r, k, q, ans;
    scanf("%d%d", &n, &m);
    for(register int i = 1; i <= n; i += 1)
        scanf("%d", &a[i]), b[i] = a[i];
    sort(b+1, b+n+1);
    q = unique(b+1, b+n+1) - b - 1;
    build(rt[0], 1, q);
    for(register int i = 1; i <= n; i += 1)
    {
        p = lower_bound(b+1, b+q+1, a[i])-b;//可以视为查找最小下标的匹配值，核心算法是二分查找
        rt[i] = modify(rt[i-1], 1, q);
    }
    while(m--)
    {
        scanf("%d%d%d", &l, &r, &k);
        ans = query(rt[l-1], rt[r], 1, q, k);
        printf("%d\n", b[ans]);
    }
    return 0;
}
```

### 题目复杂度分析

题目一开始的离散化复杂度为$O(n\lg n)$，构建基础主席树复杂度为$O(n\lg n)$，统计并插入的复杂度是$O(n\lg n + n\lg n)=O(n\lg n)$，询问的复杂度是$O(m\lg n)$。复杂度总和就是$O((m+n)\lg n)$。

# 尾注

~~至今还不知道为什么叫主席树。。。~~

这道题目是离线的，也就是使用的静态主席树。在线修改的一类题目也不难，在此不作讲解，但是以后可能会另写博客。
主席树这个数据结构还是非常棒的，这也提醒我们应该学会创造性思维。
- 感谢LMH大佬的帮助；
- 感谢洛谷平台的帮助；
- 感谢那些写题解的大佬的帮助。

# 写在最后

感谢大家的关注和阅读。

本文章借鉴了少许思路，最后经过本人思考独立撰写此文章，如需转载，请注明出处。

---

## 作者：一扶苏一 (赞：131)

# 大家好，我是个毒瘤，我非常喜欢暴力数据结构，于是我就用莫队+分块过了这个题，而且跑的贼快，甚至跑到了最优解的第二页

## Solution

发现这个题静态查询资瓷离线，于是考虑莫队。

在这里简单介绍一下莫队：

将所有询问离线后，对原序列分块。按照左端点所在块单调不降排序。当左端点所在块相同时，按照右端点单调排序。

然后用头尾指针指向当前的区间，维护区间内的信息。每两个查询间暴力移动指针。移动指针时每移动一下就维护一次答案。

考虑这么做的复杂度：一共有 $O(\sqrt{n})$个块，每个块内右端点单调，所以一个块内右端点最多移移动 $O(n)$ 个位置，于是右端点移动 $O(n~\sqrt{n})$个位置。同理，左端点在一个块内最多移动 $O(\sqrt{n})$ 次，每次最多移动 $O(\sqrt{n})$ 个位置，块内移动次数是 $O(n)$ 。一共有 $O(\sqrt{n})$ 个块，于是左端点移动 $O(n~\sqrt{n})$ 个位置。于是莫队不计修改和查询的总复杂度为 $O(n~\sqrt{n})$。

维护答案时，最显然的想法是用树状数组维护前缀和，这样单次修改复杂度 $O(\log n)$ ，查询时在树状数组上二分，复杂度 $O(\log n)$ 。修改总复杂度 $O(n~\sqrt{n}~\log n)$ ，查询的总复杂度 $O(m~\log n)$ 。于是发现修改的复杂度过高，查询的复杂度完全不需要这么低，那么可以用分块将修改复杂度将至 $O(1)$ ，查询复杂度升高至 $O(\sqrt{n})$ 。具体的，离散化后按照权值分块，每个块维护块内元素出现总次数。查询时暴力从第一个块开始扫，累加元素出现总次数，当加入一个块总次数大于 $k$ 时在块内暴力找位置，总复杂度 $O(n~\sqrt n)$。只开O2最慢的点250ms

## Code

```cpp
#include <cmath>
#include <cstdio>
#include <algorithm>
#ifdef ONLINE_JUDGE
#define freopen(a, b, c)
#endif
#define rg register
#define ci const int
#define cl const long long

typedef long long int ll;

namespace IPT {
	const int L = 10000000;
	char buf[L], *front=buf, *end=buf;
	char GetChar() {
		if (front == end) {
			end = buf + fread(front = buf, 1, L, stdin);
			if (front == end) return -1;
		}
		return *(front++);
	}
}

template <typename T>
inline void qr(T &x) {
	rg char ch = IPT::GetChar(), lst = ' ';
	while ((ch > '9') || (ch < '0')) lst = ch, ch=IPT::GetChar();
	while ((ch >= '0') && (ch <= '9')) x = (x << 1) + (x << 3) + (ch ^ 48), ch = IPT::GetChar();
	if (lst == '-') x = -x;
}

template <typename T>
inline void ReadDb(T &x) {
	rg char ch = IPT::GetChar(), lst = ' ';
	while ((ch > '9') || (ch < '0')) lst = ch, ch = IPT::GetChar();
	while ((ch >= '0') && (ch <= '9')) x = x * 10 + (ch ^ 48), ch = IPT::GetChar();
	if (ch == '.') {
		ch = IPT::GetChar();
		double base = 1;
		while ((ch >= '0') && (ch <= '9')) x += (ch ^ 48) * ((base *= 0.1)), ch = IPT::GetChar();
	}
	if (lst == '-') x = -x;
}

namespace OPT {
	char buf[120];
}

template <typename T>
inline void qw(T x, const char aft, const bool pt) {
	if (x < 0) {x = -x, putchar('-');}
	rg int top=0;
	do {OPT::buf[++top] = x % 10 + '0';} while ( x /= 10);
	while (top) putchar(OPT::buf[top--]);
	if (pt) putchar(aft);
}

const int maxn = 200010;

int n, m;
int belong[maxn], MU[maxn], temp[maxn], bk[maxn], block[maxn], rmp[maxn], lc[maxn];

struct Ask {
	int l, r, id, ans, k;
	inline bool operator<(const Ask &_others) const {
		if (belong[this->l] != belong[_others.l]) return this->l < _others.l;
		if (belong[this->l] & 1) return this->r < _others.r;
		return this->r > _others.r;
	}
};
Ask ask[maxn];

void init_hash();
void add(ci&);
void dlt(ci&);

inline bool cmp(const Ask &_a,const Ask &_b) {
	return _a.id < _b.id;
}

int main() {
	freopen("1.in", "r", stdin) ;
	qr(n); qr(m);
	for (rg int i = 1, sn = sqrt(n); i <= n; ++i) if((belong[i] = i / sn) != belong[i-1]) lc[belong[i]] = i;
	for (rg int i = 1; i <= n; ++i) qr(MU[i]);
	init_hash();
	for (rg int i = 1; i <= m; ++i) {
		qr(ask[i].l); qr(ask[i].r); qr(ask[i].k); ask[i].id = i;
	}
	std::sort(ask + 1, ask + 1 + m);
	int prel = ask[1].l, prer = prel - 1;
	for (rg int i = 1; i <= m; ++i) {
		int l = ask[i].l, r = ask[i].r;
		while (prel < l) dlt(prel++);
		while (prel > l) add(--prel);
		while (prer > r) dlt(prer--);
		while (prer < r) add(++prer);
		int _cnt = 0, cur = 0;
		while (_cnt + block[cur] < ask[i].k) _cnt+=block[cur++];
		for (rg int j = lc[cur]; ; ++j) if((_cnt += bk[j]) >= ask[i].k) {
			ask[i].ans = j; break;
		}
	}
	std::sort(ask + 1, ask + 1 + m, cmp);
	for (rg int i = 1; i <= m; ++i) qw(rmp[ask[i].ans], '\n', true);
	return 0;
}

void init_hash() {
	for (rg int i = 1; i <= n; ++i) temp[i] = MU[i];
	std::sort(temp + 1, temp + 1 + n);
	int *ed = std::unique(temp + 1, temp + 1 + n);
	for (rg int i = 1; i <= n; ++i) {
		int k = MU[i];
		rmp[MU[i] = std::lower_bound(temp + 1, ed, MU[i]) - temp] = k;
	}
}

inline void dlt(ci &k) {
	--bk[MU[k]];
	--block[belong[MU[k]]];
}

inline void add(ci &k) {
	++bk[MU[k]];
	++block[belong[MU[k]]];
}
```

对了顺便把主席树代码放上防止有人喷我不自觉

```cpp
#include <cstdio>
#include <algorithm>
#ifdef ONLINE_JUDGE
#define freopen(a, b, c)
#endif
#define rg register
#define ci const int
#define cl const long long

typedef long long int ll;

namespace IPT {
	const int L = 1000000;
	char buf[L], *front=buf, *end=buf;
	char GetChar() {
		if (front == end) {
			end = buf + fread(front = buf, 1, L, stdin);
			if (front == end) return -1;
		}
		return *(front++);
	}
}

template <typename T>
inline void qr(T &x) {
	rg char ch = IPT::GetChar(), lst = ' ';
	while ((ch > '9') || (ch < '0')) lst = ch, ch=IPT::GetChar();
	while ((ch >= '0') && (ch <= '9')) x = (x << 1) + (x << 3) + (ch ^ 48), ch = IPT::GetChar();
	if (lst == '-') x = -x;
}

template <typename T>
inline void ReadDb(T &x) {
	rg char ch = IPT::GetChar(), lst = ' ';
	while ((ch > '9') || (ch < '0')) lst = ch, ch = IPT::GetChar();
	while ((ch >= '0') && (ch <= '9')) x = x * 10 + (ch ^ 48), ch = IPT::GetChar();
	if (ch == '.') {
		ch = IPT::GetChar();
		double base = 1;
		while ((ch >= '0') && (ch <= '9')) x += (ch ^ 48) * ((base *= 0.1)), ch = IPT::GetChar();
	}
	if (lst == '-') x = -x;
}

namespace OPT {
	char buf[120];
}

template <typename T>
inline void qw(T x, const char aft, const bool pt) {
	if (x < 0) {x = -x, putchar('-');}
	rg int top=0;
	do {OPT::buf[++top] = x % 10 + '0';} while ( x /= 10);
	while (top) putchar(OPT::buf[top--]);
	if (pt) putchar(aft);
}

const int maxn = 200010;
const int maxt = 4000010;

int n, m, sz;
int MU[maxn], temp[maxn], rmp[maxn];

struct Tree {
	Tree *ls, *rs;
	int l, r, v, k;
	inline void update() {
		this->v = 0;
		if(this->ls) this->v = this->ls->v;
		if(this->rs) this->v += this->rs->v;
	}
};
Tree *pool[maxt], qwq[maxt], *rot[maxn];
int pltp;

void init_hash();
void buildpool();
void buildzero(Tree*, ci, ci);
void build(Tree*, Tree*, ci, ci, ci);
int ask(Tree*, Tree*, ci);

int main() {
	freopen("1.in", "r", stdin);
	qr(n); qr(m);
	for (rg int i = 1; i <= n; ++i) qr(MU[i]);
	init_hash();
	buildpool();
	rot[0] = pool[pltp--];
	buildzero(rot[0], 1, sz);
	for (rg int i = 1; i <= n; ++i) {
		rot[i] = pool[pltp--];
		build(rot[i-1], rot[i], 1, sz, MU[i]);
	}
	
	int a, b, c;
	while(m--) {
		a = b = c = 0;
		qr(a); qr(b); qr(c);
		qw(rmp[ask(rot[a-1], rot[b], c)], '\n', true);
	}
	return 0;
}

void init_hash() {
	for (rg int i = 1; i <= n; ++i) temp[i] = MU[i];
	std::sort(temp + 1, temp + 1 + n);
	int *ed = std::unique(temp + 1, temp + 1 + n);
	for (rg int i = 1; i <= n; ++i) {
		int _tp = MU[i];
		rmp[MU[i] = std::lower_bound(temp + 1, ed, MU[i]) - temp] = _tp;
	}
	sz = ed - temp - 1;
}

void buildpool() {
	for (rg int i = 0; i < maxt; ++i) pool[i] = qwq + i;
	pltp = maxt - 1;
}

void buildzero(Tree *u, ci l, ci r) {
	u->l = l; u->r = r;
	if (l == r) return;
	int mid = (l + r) >> 1;
	if (l <= mid) {
		u->ls = pool[pltp--];
		buildzero(u->ls, l, mid);
	}
	if (mid < r) {
		u->rs = pool[pltp--];
		buildzero(u->rs, mid+1, r);
	}
}

void build(Tree *pre, Tree *u, ci l, ci r, ci v) {
	u->l = l; u->r = r;
	if (l == r) {u->v = pre->v + 1;return;}
	int mid = (l + r) >> 1;
	if (v <= mid) {
		u->rs = pre->rs;
		u->ls = pool[pltp--];
		build(pre->ls, u->ls, l, mid, v);
	} else {
		u->ls = pre->ls;
		u->rs = pool[pltp--];
		build(pre->rs, u->rs, mid + 1, r, v);
	}
	u->update();
}

int ask(Tree *pre, Tree *u, ci k) {
	if(u->l == u->r) return u->l;
	int _v = u->ls ? u->ls->v - pre->ls->v : 0;
	return _v < k ? ask(pre->rs, u->rs, k - _v) : ask(pre->ls, u->ls, k);
}
```

## Summary

### 我爱暴力数据结构！

---

## 作者：旋转卡壳 (赞：124)

本篇题解发布者也是刚学的主席树,水平又low,还是第一次发题解 

加上是先在代码上写了注释才写的题解,所以整个文章可能会有点重复啰嗦,有基础的可以直接看代码 在看的过程中有什么操作不懂可以结合代码看

如果有什么不对的地方还请大家多多包涵……

前置要求: **线段树** 离散化 前缀和
	
可能比较好的观看体验: https://www.luogu.org/blog/0-1s/solution-p3834 (至少我看着还行)

-----------------------------------------------
## 思路


  看到题目 我们首先考虑个0分写法 对每个[l,r]sort一遍求出答案 
  
  然后觉得不行 考虑数据结构 有一段数组 还有区间询问 那就看看线段树
  
  题目是求第k小 所以**线段树维护的是[l,r]内数的出现次数**
  
  看数据范围 2*10^5个数 数的范围是±10^9 因此用离散化
  
  开个x[200010]就是线段树维护的数组 x[i]存第i小的数 再开个线段树的数组存区间内数的出现次数 大概是这样子 ……完了 我好像不会线段树了......
  
  再看题目 发现这样子做的话每个询问需要用[l,r]区间内的数的个数来建立一棵线段树 最多就有2*10^5棵线段树 时间空间都爆了 好了 GG


------------------------------------------------

我们换个思路看 具体是什么思路我也不懂

先从简单入手 先求[1,r]的第k小

对于[1,i]树与[1,i+1]树 **后者只是多了a[i+1]的插入所带来的影响**

如图：

[![PBnMRg.md.jpg](https://s1.ax1x.com/2018/08/03/PBnMRg.md.jpg)](https://imgchr.com/i/PBnMRg)

我们随便编一个数据 预处理如图(图丑 轻喷)

[![PBnui8.md.jpg](https://s1.ax1x.com/2018/08/03/PBnui8.md.jpg)](https://imgchr.com/i/PBnui8)

**对于每一个新的线段树 我们可以在旧的线段树的基础上通过 增加新的节点 来构建这颗树** 节省了大量的空间

我们可以用一个T[i]记录(1~i)线段树的根节点(容易看出根节点是一定是不同的)

这样算完了之后 我们就可以**通过T[i]来询问(1~i)线段树** 

新的问题出现了 那如何解决区间问题呢 我们能求[1,i]的第k小(线段树的基本应用) 但是如何求[l,r]的第k小呢


想一下

		[1,l]线段树是由插入 a[1]到a[l]的影响 构成的
    
    	[1,r]线段树是由插入 a[1]到a[r]的影响 构成的
    
    
是不是有点前缀和的感觉


那么

		[l,r]线段树是由插入 a[l]到a[r]的影响 构成的
    
    
就等于 

		a[1]到a[r]的影响减去a[1]到a[l-1]的影响


所以

		[l,r]线段树 = [1,r]线段树 - [1,l-1]线段树

是不是感觉很有道理


那具体怎么减呢

在线段树上 每个节点的值是这个节点所代表的区间内数字出现的次数 那么只要**在(r)线段树的每一个节点上减去(l-1)线段树上的相同位置的节点的值** 就行了

[![PBnQzQ.md.jpg](https://s1.ax1x.com/2018/08/03/PBnQzQ.md.jpg)](https://imgchr.com/i/PBnQzQ)

样例有点简单 但就是这个样子						
   


------------

## 模拟代码解题过程

下面在给出题面样例的模拟过程

[![PBnmIf.md.jpg](https://s1.ax1x.com/2018/08/03/PBnmIf.md.jpg)](https://imgchr.com/i/PBnmIf)

预处理

[![PBnKJS.md.jpg](https://s1.ax1x.com/2018/08/03/PBnKJS.md.jpg)](https://imgchr.com/i/PBnKJS)

更新插入的数带来的新线段树

[![PBn1Mj.md.jpg](https://s1.ax1x.com/2018/08/03/PBn1Mj.md.jpg)](https://imgchr.com/i/PBn1Mj)

根据上面的方法来得到询问需要的线段树 然后就询问就完事了

下面给出代码 注释可能有点啰嗦 凑合着看吧……(代码旁边的字符是无聊瞎写的 无视即可)




------------

```cpp
#include <bits/stdc++.h>
#define MAX 200010

using namespace std;

int nodeNum;
//所有节点的数量                                           //.............8888.........  //
int L[MAX<<5],R[MAX<<5],sum[MAX<<5];                     //..............;888........  //
//L[i]表示编号为i的节点的左儿子的编号                       //...........888..888.......  //
//sum[i]表示编号为i的节点所代表的区间内数字出现的次数         //........888888..;....88...  //
int a[MAX],Hash[MAX];                                     //.......888.888.......888..  //
//a[i]为原数组 Hash[i]为排序后数组                         //.......888.888.......!888   //
int T[MAX];                                               //.......88$.888........888.  //
//T[i]为插入i个点后的树的根节点编号                         //......888..888.....888....  //
                                                         //...........888.....888....  //
int read()                                               //...........8888888888o....  //
{                                                         //............&8888888......  //
	int ans=0,flag=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') flag=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {ans=(ans<<3)+(ans<<1)+ch-'0';ch=getchar();}
	return ans*flag;
}
int build(int l,int r) //建一个空树(所有sum[i]都为0) 
{
	int num=++nodeNum; //num为当前节点编号 
	if(l!=r)
	{
		int m=(l+r)>>1;
		L[num]=build(l,m);
		R[num]=build(m+1,r);
	}
	return num; //返回当前节点的编号 
}

int update(int pre,int l,int r,int x) //pre为旧树该位置节点的编号
{
	int num=++nodeNum; //新建节点的编号 
	L[num]=L[pre];R[num]=R[pre];sum[num]=sum[pre]+1;
	//该节点左右儿子初始化为旧树该位置节点的左右儿子
	//因为插入的a[i](或Hash[x])在该节点所代表的区间中 所以sum++ 
	if(l!=r)
	{
		int m=(l+r)>>1;
		if(x<=m) L[num]=update(L[pre],l,m,x);
		//x出现在左子树 因此右子树保持与旧树相同 修改左子树 
		else R[num]=update(R[pre],m+1,r,x);
	}
	return num;
}

int query(int u,int v,int l,int r,int k) //第k小 
{
	if(l==r) return Hash[l]; //找到第k小 l是节点编号 所以答案是Hash[l] 
	int m=(l+r)>>1;
	int num=sum[L[v]]-sum[L[u]];
	//用第一次模拟 这样比较容易看得懂 此时u=l-1 v=r 
	//则num= (1~r)树的左节点数字出现的次数 - (1~(l-1))树的左节点数字出现的次数 
	//即num等于([l,r])树左儿子数字出现的次数 
	if(num>=k) return query(L[u],L[v],l,m,k);
	//当 左儿子数字出现的次数大于等于k 时 意味着 第k小的数字在左子树处 
	else return query(R[u],R[v],m+1,r,k-num);
	//否则去右子树处找第k-num小的数字 
}

int main()
{
	int n=read(),m=read();
	for(int i=1;i<=n;i++) {a[i]=read();Hash[i]=a[i];}
	sort(Hash+1,Hash+1+n); 
	int size=unique(Hash+1,Hash+1+n)-Hash-1; 
    //size为线段树维护的数组的大小==Hash数组中不重复的数字的个数
	T[0]=build(1,size); //初始化 建立一颗空树 并把该树的根节点的编号赋值给T[0]
	for(int i=1;i<=n;i++)
	{
		int x=lower_bound(Hash+1,Hash+1+size,a[i])-Hash;
		//在Hash的 [1,size+1)--->[1,size] 中二分查找第一个
		// 大于等于(在这里可以看成等于) a[i]的Hash[x]
		T[i]=update(T[i-1],1,size,x);
		//更新a[i]带来的影响 
		//并将新树的根节点的编号赋值给T[i] 
	}
	while(m--)
	{
		int l=read(),r=read(),k=read();
		printf("%d\n",query(T[l-1],T[r],1,size,k)); //因为a[l]有影响 所以是T[l-1] 
	}
	return 0;
}
```

---

## 作者：星星之火 (赞：105)

关于一个很强的操作，整体二分

最基本的运用就是洛谷的主席树模板——静态区间的k大

下面说一说思路

所谓整体，就是所有的询问全部一起处理，这是因为如果单个单个二分的话无疑会超时。那么如何可以做到这点呢？首先对于数组中原来的数和询问，把它们封装在同样的结构体里。这个结构体包括x,y,k,id,type

对于数组中原来的数，通过观察程序可以发现y,k是没有任何作用的。x代表的是这个位置的数的大小，id表示数的位置，type是它的类型（不是询问）

对于询问，x，y，k表示在区间x~y中查询第k小的数，id表示的是询问的编号，type是它的类型（询问）

那么接下来我们要对这些封装好的什么什么东西一起二分，这些东西我们存在一个数组里，在接下来的描述中我们管它叫队列

在solve函数中，ql,ql分别表示当前处理的队列的子列的左端点和右端点。l，r就是我们二分的权值。首先判断，若是ql>qr就直接return。之后判断l是不是与r相等，若是相等说明找到了，此时对于目前处理的队列中所有询问而言结果都是l（或r）。

如果以上都没有满足，那么我们还需要继续二分下去。mid=(l+r)>>1，那么考虑算出当前维护的队列中所有type==1的类型的x值小于等于mid的划分到左边，同时统计个数。而如果大于mid就划分到右边。怎么统计个数呢？我们每次递归是使用树状数组，而每次结束时又把它给清空，（如果这里可以离散化的话好像会很完美，但可不可以我没有去想。。。因为这道题确实只是入门题。当然主要是因为我是蒟蒻的缘故）。对于type==2的元素而言，直接树状数组统计x，y之间的比mid小的数的个数，然后和k比个大小，同样把它划分成左右两边

相信没学过的人有疑问了，为什么我们要划分成左右两边呢？首先我们每次递归处理的是一个子问题，划分是处理子问题的一个大前提。其次，我们得知划分到右边的无论如何不会影响左边的处理，可以理解为对左边不存在贡献。

递归的最后我们只需要修改队列分出左右就好了

值得再次提醒的是，l，r，mid使我们二分的数值，请不要和ql，qr的含义弄混

下面附上代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int oo=1e9+7;
const int maxn=2e5+15;
int n,m,cnt;
int ans[maxn],tree[maxn]; 
struct NODE
{
	int x;int y;int k;
	int id;int type;
}q[maxn<<1],q1[maxn<<1],q2[maxn<<1];
void add(int x,int y)
{
	while (x<=n)
	{
		tree[x]+=y;
		x+=x&(-x);
	}
}
int sum(int x)
{
	int ans=0;
	while (x)
	{
		ans+=tree[x];
		x-=x&(-x);
	}
	return ans;
}
void solve(int ql,int qr,int l,int r)
{
	if (ql>qr) return;
	if (l==r){
		for (int i=ql;i<=qr;i++)
		if (q[i].type==2) ans[q[i].id]=l;
		return;
	}
	int mid=(l+r)>>1;
	int p1=0,p2=0;
	for (int i=ql;i<=qr;i++)
    if (q[i].type==1){
    	if (q[i].x<=mid){
    		add(q[i].id,1);
    		q1[++p1]=q[i];
		}
		else q2[++p2]=q[i];
	}
	else {
		int res=sum(q[i].y)-sum(q[i].x-1);
		if (res>=q[i].k) q1[++p1]=q[i];
		else {
			q[i].k-=res;
			q2[++p2]=q[i];
		}
	}
	for (int i=1;i<=p1;i++) if (q1[i].type==1) add(q1[i].id,-1);
	for (int i=1;i<=p1;i++)
	q[i+ql-1]=q1[i];
	for (int i=1;i<=p2;i++)
	q[i+ql+p1-1]=q2[i];
	solve(ql,ql+p1-1,l,mid);
	solve(ql+p1,qr,mid+1,r);
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
	{
		int x;
		scanf("%d",&x);
		q[++cnt]=(NODE){x,1,oo,i,1};
	}
	for (int i=1;i<=m;i++)
	{
		int x,y,k;
		scanf("%d%d%d",&x,&y,&k);
		q[++cnt]=(NODE){x,y,k,i,2};
	}
	solve(1,cnt,-oo,oo);
	for (int i=1;i<=m;i++)
	printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：NaCly_Fish (赞：39)

这题还可以线段树合并来做，然而并没有题解，于是来写一篇吧。


线段树合并 与 可持久化线段树其实用到了类似的思想，就是多个线段树共用，降低空间复杂度。

这里所谓线段树合并，就是把两个线段树对应节点的信息合并，并返回新线段树的根（为了防止一些奇怪的问题，所以要新建节点）。而且线段树合并一般用于权值线段树（也就是类似此题的情况），可以证明每次合并均摊 $\text O(\log n)$。

那么来考虑一下怎么合并两个线段树：  

- 如果合并的两棵线段树（有可能是子树）有一个根为空，显然不需要继续合并，直接返回另一个的根  

- 如果两棵线段树都不为空，新建一个节点，信息为这两个节点的合并，然后递归合并左右子树  

写成代码，就是这样的：  
其中 `ls` 和 `rs` 分别表示左右儿子。
```cpp
int merge(int u,int v){
    if(!u||!v) return u|v;
    int x = ++cnt;
    sum[x] = sum[u]+sum[v];
    ls[x] = merge(ls[u],ls[v]);
    rs[x] = merge(rs[u],rs[v]);
    return x;
}

```
那么只需要开 $n$ 个动态开点线段树，然后用前缀和的方法，把 $[1,i]$ 的信息合并到第 $i$ 棵线段树上。

要查询 $[l,r]$ 的第 $k$ 大，用第 $r$ 棵对应减去第 $l-1$ 棵得到的线段树上二分即可。

总时间复杂度 $\Theta((n+q)\log n)$。

代码：  
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#define reg register
#define ll long long
#define N 200003
#define M 7000003
#define mid ((l+r)>>1)
using namespace std;

int rt[N],a[N],b[N];
int ls[M],rs[M],sum[M];
int n,m,q,cnt;

void insert(int &u,int l,int r,int pos){
    if(!u) u = ++cnt;
    sum[u]++;
    if(l==r) return;
    if(pos<=mid) insert(ls[u],l,mid,pos);
    else insert(rs[u],mid+1,r,pos);
}

int merge(int u,int v){
    if(!u||!v) return u|v;
    int x = ++cnt;
    sum[x] = sum[u]+sum[v];
    ls[x] = merge(ls[u],ls[v]);
    rs[x] = merge(rs[u],rs[v]);
    return x;
}

int query(int u,int v,int l,int r,int k){
    if(l==r) return l;
    int s = sum[ls[v]]-sum[ls[u]];
    if(k<=s) return query(ls[u],ls[v],l,mid,k);
    return query(rs[u],rs[v],mid+1,r,k-s);
}

int main(){
    int l,r,k,x;
    scanf("%d%d",&n,&q);
    for(reg int i=1;i<=n;++i){
        scanf("%d",&a[i]);
        b[i] = a[i];
    }
    sort(b+1,b+1+n);
    m = unique(b+1,b+1+n)-b-1;
    for(reg int i=1;i<=n;++i) insert(rt[i],1,m,lower_bound(b+1,b+1+m,a[i])-b);
    for(reg int i=2;i<=n;++i) rt[i] = merge(rt[i],rt[i-1]);
    while(q--){
        scanf("%d%d%d",&l,&r,&k);
        x = query(rt[l-1],rt[r],1,m,k);
        printf("%d\n",b[x]);
    }
    return 0;
}
```

---

## 作者：Nemlit (赞：33)

## [更多主席树内容可见原文](https://www.cnblogs.com/bcoier/p/10293521.html)

PS：由于篇幅较长，只给出模板题代码，其他代码详见上述连接

主席树，一个数据结构，能访问到历史版本的数据，常用于可持久化和区间k大值，是线段树的一个升级版。

## 可持久化

可持久化的意思是可以访问任意版本的数据，一眼想到的暴力做法就是开n个数组来记录，这显然是不可取的。

那么我们考虑优化。若只有单点修改，不难发现每两个版本的差别最多为1，那么我们是不是可以只更改只一个数呢？

~~显然是可以的。~~在线段树上，我们每访问到一个节点，如果该节点没有被修改，直接用指针指想该节点即可（和动态开点线段树类似）

要注意的是，我们不能像以前一样用$k*2$表示左儿子，$k*2+1$表示右儿子了（如果你用动态开点就当我没说），而是要用指针来访问左右儿子。

那我们怎么访问每一个版本呢？我们只需要对每一个版本存储一个根节点，从根节点访问就行了

这样我们就可以很好的来处理可持久化的问题了。

## [例题1-可持久化数组](https://www.luogu.org/problemnew/show/P3919)

直接采用上述方法，维护每一个版本的root即可

有了可持久化数组，那么我们便可以操作其他可持久化数据结构，如可持久化并查集

## [例题2-可持久化并查集](https://www.luogu.org/problemnew/show/P3402)

我们把每一个版本的fa数组记录下来，就可以很好的查询历史版本了。我们发现对于每次合并，fa数组只会修改一个（不能用路径压缩，因为路径压缩一次会修改很多值），所以我们直接用上述方法做就行了。

如果直接修改，那么单次复杂度可能退化成O(n)，所以我们可以用启发式合并或按秩合并

## 区间k大

~~我们知道~~，[权值线段树](https://www.cnblogs.com/zmyzmy/p/9529234.html)是可以求全局k大的，那么我们可不可以用权值线段树来实现区间k大呢？

~~显然是可以的。~~我们可以先考虑1~l区间的k大。

我们给每一个点开一颗前缀的权值线段树，那么我们就可很容易的求出1~l的第k大值了。但是常规做法显然会炸空间，所以我们采用可持久化的方法来动态开点

那么区间k大怎么做呢？

这就要用到权值线段树的可减性。（权值线段树维护的是每个元素的出现个数，这显然是可减的）

于是对于段区间，我们看成连段区间相减就行了。

## [例题2-可持久化线段树](https://www.luogu.org/problemnew/show/P3834)

代码如下
```
#include<bits/stdc++.h>
using namespace std;
#define re register
#define il inline
il int read()
{
    re int x=0,f=1;re char c=getchar();
    while(c<'0'||c>'9') {if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return x*f;
}
#define maxn 200005
struct node
{
    int l,r,val;
}e[maxn*20];
int n,m,root[maxn],cnt,b[maxn],a[maxn],co;
il void build(int &k,int l,int r)
{
    k=++cnt;
    if(l==r) return;
    int mid=(l+r)>>1;
    build(e[k].l,l,mid),build(e[k].r,mid+1,r);
}
il void change(int &k,int kk,int l,int r,int ll)
{
    k=++cnt; e[k]=e[kk]; e[k].val++;
    if(l==r) return;
    int mid=(l+r)>>1;
    if(ll<=mid) change(e[k].l,e[kk].l,l,mid,ll);
    else change(e[k].r,e[kk].r,mid+1,r,ll);
}
il int query(int ll,int rr,int l,int r,int k)
{
    int x=e[e[rr].l].val-e[e[ll].l].val;
    if(l==r) return b[l];
    int mid=(l+r)>>1;
    if(x>=k) return query(e[ll].l,e[rr].l,l,mid,k);
    return query(e[ll].r,e[rr].r,mid+1,r,k-x);
}
int main()
{
    n=read(),m=read();
    for(re int i=1;i<=n;++i) a[i]=b[i]=read();
    sort(b+1,b+n+1);//排序
    co=unique(b+1,b+n+1)-b-1;//去重
    build(root[0],1,co);
    for(re int i=1;i<=n;++i)
    {
        int now=lower_bound(b+1,b+co+1,a[i])-b;//意思是找到和a[i]相等的b，这样做的目的是保证所有的相等的全值都能保证被分到一个下标
        change(root[i],root[i-1],1,co,now);//因为是前缀权值线段树，所以在前一刻子树的基础上修改
    }
    while(m--)
    {
        int l=read(),r=read(),k=read();
        printf("%d\n",query(root[l-1],root[r],1,co,k));
    }
    return 0;
}
```

## [不那么模板的模板题](https://www.luogu.org/problemnew/show/P2633)

这题是强制在线，所以不能用整体二分等离线做法水过去，所以我们用主席树。

拓展到了树上，所以我们可以进行dfs，把上一题的建树过程改成change(root[i],root[fa[i]],1,co,now)即可

最后统计答案，我们不能直接用r的权值线段树-l的权值线段树，而使用l+r-lca(l,r)-fa[lca(l,r)]（这里表示权值线段树），正确性类似于树上差分，在此不再赘述。

由于要求LCA，且要用dfs，所以我直接用树剖来求lca，将树剖的dfs1和要求的dfs合并在一起就行了。

---

## 作者：FlashHu (赞：33)

更多的内容在[我的博客](http://www.cnblogs.com/flashhu/)


先不考虑每一个区间的情况，从最简单的查询整个区间$[1,r]$的情况开始。


对数据离散化后，用一个线段树来维护，每个节点维护对应离散化后值区间的数的总个数$size$。自上至下进行询问操作时，判断当前点左子树的$size$与要查询的排名$k$的大小关系。如果小于等于，就到左子树中找，$k$不变。否则到右子树中找排名$k-size$的值。这与平衡树(Splay,Treap)等查询给定排名数的方法是基本一样的。


那对于所有可能的区间，又该怎样维护呢？我们其实只要$N$个线段树就好了，第$i$个线段树维护$[1,i]$的情况。这里我们利用了前缀和的性质。查询$[l,r]$就等于查询$[1,r]$减去$[1,l-1]$的对应的$size$没错吧。因为线段树是完全二叉树，具有结构稳定的性质，所以$N$个线段树长得是一样的，对应区间相减是可行的。


然而暴力开$N$个空间保准炸掉。这时候我们回头看看可持久化线段树是怎么做的。没错，从$[1,i-1]$到$[1,i]$也只变了一个值！于是同样只要新开$log$个节点，保存$root_i$到$i$对应叶子节点的路径就OK了。


拿洛谷题目里的样例来几张图吧，好理解些。


首先是离散化后的序列。

![](http://images2017.cnblogs.com/blog/1309909/201801/1309909-20180117194204240-714306710.png)



我们一开始要建一棵空线段树，除了有个结构，所有的$size$均为$0$。然后一个一个的添加线段树。加入$[1,1]$的线段树后会是这样：

![](http://images2017.cnblogs.com/blog/1309909/201801/1309909-20180117194009396-744425697.png)

再加入$[1,2]$：

![](http://images2017.cnblogs.com/blog/1309909/201801/1309909-20180117194033053-172157202.png)


后面的手推一下吧。。。。。。


至此，$N$棵树就建好了，并且只用了$N \log N$的空间。


查询的时候存两个点，一开始为$root_r$和$root_{l-1}$，两个$size$的差与$k$来比大小，两个点要同时往左/右跳。

更多细节就看代码吧。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define R register int
const int N=200009,M=5000009;
int P,a[N],b[N],rt[N],lc[M],rc[M],s[M];
#define G c=getchar()
inline void in(R&z)
{
    register bool f=0;
    register char G;
    while(c<'-')G;
    if(c=='-')f=1,G;
    z=c&15;G;
    while(c>'-')z=(z<<3)+(z<<1)+(c&15),G;
    if(f)z=-z;
}//快读
void build(R&t,R l,R r)
{
    t=++P;
    if(l!=r)
    {
        R m=(l+r)>>1;
        build(lc[t],l,m);
        build(rc[t],m+1,r);
    }
}//线段树操作，建一个空线段树
inline void insert(R*t,R u,R l,R r,R v)
{
    while(l!=r)
    {
        s[*t=++P]=s[u]+1;//注意这里要+1
        R m=(l+r)>>1;
        if(v<=m)r=m,rc[*t]=rc[u],t=&lc[*t],u=lc[u];
        else  l=m+1,lc[*t]=lc[u],t=&rc[*t],u=rc[u];
    }
    s[*t=++P]=s[u]+1;
}//插入操作在可持久化线段树总结里面有更详细的介绍
inline int ask(R t,R u,R l,R r,R k)
{
    while(l!=r)
    {
        R m=(l+r)>>1,v=s[lc[u]]-s[lc[t]];//作差
        if(k<=v)r=m,t=lc[t],u=lc[u];//两个点一起跳
        else  l=m+1,t=rc[t],u=rc[u],k-=v;
    }
    return b[l];
}
int main()
{
    R n,m,i,l,r,sz;
    in(n);in(m);
    for(i=1;i<=n;++i)
        in(a[i]),b[i]=a[i];
    sort(b+1,b+n+1);
    sz=unique(b+1,b+n+1)-b-1;//离散化，排序去重
    build(rt[0],1,sz);
    for(i=1;i<=n;++i)
        insert(&rt[i],rt[i-1],1,sz,lower_bound(b+1,b+sz+1,a[i])-b);//直接用STL的二分找对应值了
    while(m--)
    {
        in(l);in(r);in(i);
        printf("%d\n",ask(rt[l-1],rt[r],1,sz,i));
    }
    return 0;
}
```

---

## 作者：Ireliaღ (赞：31)

**这里提供两个非主席树，没有其他题解提到，但是复杂度正确，或许比主席树写起来更容易的做法**

## 从原理开始

我们想要求区间第$k$小，需要用一种可持久化数据结构，版本$i$维护从$a_1$到$a_i$所有数的出现次数，这样来求出区间第$k$小。那么，“这种”数据结构需要满足哪些性质？

1. 资瓷可持久化（废话，题目在那）

2. 资瓷查询全局第$k$小（显然）

3. **不同版本树的形态相似**（为性质$4$提供条件）

4. **可以从两个版本的树根开始同时在树上走路，并在“相同地位”的节点上对$size$进行作差，来得到指定区间内的信息。**（重点！）

那么，我们~~很容易~~根据以上性质想到以下数据结构

* 值域线段树（标准主席树做法）

* 二叉搜索树（可以看普通平衡树P3369）

* 0-1字典树（普通平衡树P3369中有几篇题解）

* Leafy Search Tree（也有人叫它Finger Tree，但好像是个~~美丽的~~误会，按照原理完全可以实现，但是我太菜没写明白）

## 本题解法

可持久化值域线段树（主席树）做法很多题解都写了，这里不再多讲。重点讲下面的两种做法。

### 可持久化二叉搜索树

因为二叉搜索树满足**中序遍历即有序序列**的性质，所以我们可以使用可持久化BST来解决静态区间第$k$小的问题，只需要在递归不同版本的“相同地位”节点时，对两个$size$作差即可。

代码如下

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include <iostream>

using std::cin;
using std::cout;

const int MAXN = 2e5 + 5;

int n, m;
int a[MAXN];

struct Node{
    int val, cnt, siz;
    Node *ch[2];

    Node() {}

    Node(int val) : val(val) {
        cnt = 1;
        siz = 1;
        ch[0] = ch[1] = NULL;
    }
}pool[MAXN << 5];

int ncnt = 0;

Node *NewNode(int val) {
    pool[ncnt] = Node(val);
    return &pool[ncnt++];
}

Node *NewNode(void) {
    return &pool[ncnt++];
}

Node *rt[MAXN];

void Update(Node *now) {
    now->siz = now->cnt + (now->ch[0] ? now->ch[0]->siz : 0) + (now->ch[1] ? now->ch[1]->siz : 0);
}

Node *Copy(Node *now) {
    Node *ret = NewNode();
    *ret = *now;
    return ret;
}

void Insert(Node *&now, int k) {
    if (!now) {
        now = NewNode(k);
        return;
    }
    now = Copy(now);
    if (k < now->val) Insert(now->ch[0], k);
    else if (k == now->val) now->cnt++;
    else Insert(now->ch[1], k);
    Update(now);
}

int Kth(Node *now1, Node *now2, int k) {
    int ls1 = ((now1 && now1->ch[0]) ? now1->ch[0]->siz : 0);
    int ls2 = ((now2 && now2->ch[0]) ? now2->ch[0]->siz : 0);
    int ls = ls2 - ls1;
    int ncnt = (now2 ? now2->cnt : 0) - (now1 ? now1->cnt : 0);
    if (k <= ls) return Kth((now1 ? now1->ch[0] : NULL), (now2 ? now2->ch[0] : NULL), k);
    else if (k <= ls + ncnt) return now2->val;
    else return Kth((now1 ? now1->ch[1] : NULL), (now2 ? now2->ch[1] : NULL), k - ls - ncnt);
}

void Init() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
}

void Work() {
    for (int i = 1; i <= n; i++) {
        rt[i] = rt[i - 1];
        Insert(rt[i], a[i]);
    }
    int x, y, k;
    for (int i = 1; i <= m; i++) {
        cin >> x >> y >> k;
        cout << Kth(rt[x - 1], rt[y], k) << "\n";
    }
}

int main() {
    std::ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    Init();
    Work();
    return 0;
}
```

虽然这份代码可以切掉本题，~~并且跑的比很多主席树要快得多~~，但是由于我们需要满足性质$3$，无法对BST做出平衡措施，所以**出题人可以通过恶意构造单调增/减的序列把可持久化BST的时间和空间卡成$n^2$**。

然而，介于绝大多数人求静态区间第$k$小都用主席树，出题人很难想到卡BST，所以我到现在没因为使用BST代替主席树翻车过。

时间复杂度单次查询$O(log(n))$，预处理$O(nlog(n))$（非恶意数据）

### 可持久化0-1字典树

0-1字典树，顾名思义，把二进制数当做字符串存入字典树中，这样通过维护节点的$size$，可以求出全局第$k$小，**并且跑的比绝大多数平衡树都要快**。这样，性质已经满足，我们可以通过可持久化来求出区间第$k$小。

代码如下

```cpp
// luogu-judger-enable-o2
#include <iostream>

using std::cin;
using std::cout;
typedef unsigned int U;

const int MAXN = 2e5 + 5;

int n, m;
int a[MAXN];

struct Node{
    int siz;
    Node *ch[2];
}pool[MAXN << 6];

Node *NewNode() {
    static int cnt = 0;
    pool[cnt].siz = 0;
    pool[cnt].ch[0] = NULL;
    pool[cnt].ch[1] = NULL;
    return &pool[cnt++];
}

Node *rt[MAXN];

void Update(Node *now) {
    now->siz = (now->ch[0] ? now->ch[0]->siz : 0) + (now->ch[1] ? now->ch[1]->siz : 0);
}

Node *Copy(Node *now) {
    Node *ret = NewNode();
    *ret = *now;
    return ret;
}

void Insert(Node *&now, U num, int base) {//base为父边的数位
    if (!now) now = NewNode();
    else now = Copy(now);
    if (base == 0) {
        now->siz++;
        return;
    }
    int f = (num & (1U << base - 1)) ? 1 : 0;
    Insert(now->ch[f], num, base - 1);
    Update(now);
}

U Kth(Node *now1, Node *now2, int k, U num, int base) {//num为收集下来的数字
    if (base == 0) return num;
    int ls1 = ((now1 && now1->ch[0]) ? now1->ch[0]->siz : 0);
    int ls2 = ((now2 && now2->ch[0]) ? now2->ch[0]->siz : 0);
    int ls = ls2 - ls1;
    if (k <= ls) return Kth(now1 ? now1->ch[0] : NULL, now2 ? now2->ch[0] : NULL, k, num, base - 1);
    else return Kth(now1 ? now1->ch[1] : NULL, now2 ? now2->ch[1] : NULL, k - ls, num + (1U << base - 1), base - 1);
}

void Init() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
}

void Work() {
    rt[0] = new Node();
    for (int i = 1; i <= n; i++) {
        rt[i] = rt[i - 1];
        Insert(rt[i], a[i], 32);
    }
    int x, y, k;
    for (int i = 1; i <= m; i++) {
        cin >> x >> y >> k;
        cout << Kth(rt[x - 1], rt[y], k, 0, 32) << "\n";
    }
}

int main() {
    std::ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    Init();
    Work();
    return 0;
}
```

时间复杂度稳定每次$O(log(maxnum))$，预处理$O(nlog(maxnum))$

这里我比较推荐利用可持久化Trie来解决静态区间第$k$小以及类似问题，因为Trie的复杂度最优，并且可以解决最大异或和等其他问题。

---

## 作者：Bronya18C (赞：16)

# ~~专门搞破坏~~
---
作为一名新初一的孩子，我还不会主席树，只能用划分树。

划分树适用于静态查询区间第K大数，时间复杂度为（M*logN），空间比主席树好一点。

---
# 划分树
划分树，类似线段树，主要用于求解某个区间的第k 大元素（时间复杂度log(n)），快排本也可以快速找出，但快排会改变原序列，所以每求一次都得恢复序列。

　划分树，顾名思义是将n 个数的序列不断划分，根结点就是原序列，左孩子保存父结点所有元素排序后的一半，右孩子也存一半，也就是说排名1 -> mid的存在左边，排名(mid+1) -> r 的存在右边，同一结点上每个元素保持原序列中相对的顺序。
 
 当然，一般不会说每个结点开个数组存数，经观察，每一层都包含原本的n 个数，只是顺序不同而已，所以我们可以开val[20][N]来保存，也就是说共20层，每一层N个数。

　　我们还需要一个辅助数组num，num[i]表示i 前面有多少数进入左孩子（i 和i 前面可以弄成本结点内也可以是所有，两种风格不同而已，下面采取的是本结点内），和val一样，num也开成num[20][N]，来表示每一层，i 和i 前面（本结点）有多少进入左孩子。

　　第一层：1 进入左孩子，num[1]=1，5 进入右孩子，num[2]=1，...，num[8]=4。

　　第二层：5 进入左孩子，num[5]=1，6 进入右孩子，num[6]=1，...，num[8]=2。

　　建图时就是维护每一层val[]和num[]的值就可以了。
  以上摘抄于此[blog](https://www.cnblogs.com/hchlqlz-oj-mrj/p/5744308.html)
  
---
# 代码：
---
```
#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;
long long a[200010];       
long long sorted[200010]; 
long long num[50][200010];
long long val[50][200010];
void build(long long l,long long r,long long ceng) {
  if(l==r) return ;
 long long mid=(l+r)/2,isame=mid-l+1;
   for(long long i=l;i<=r;i++) if(val[ceng][i]<sorted[mid]) isame--;
  long long ln=l,rn=mid+1; 
 for(long long i=l;i<=r;i++)
   {
     if(i==l) num[ceng][i]=0;
     else num[ceng][i]=num[ceng][i-1];
     if(val[ceng][i]<sorted[mid] || val[ceng][i]==sorted[mid]&&isame>0)
     {
       val[ceng+1][ln++]=val[ceng][i];
       num[ceng][i]++;
       if(val[ceng][i]==sorted[mid]) isame--;
     }
     else
     {
       val[ceng+1][rn++]=val[ceng][i];
 }
   }
   build(l,mid,ceng+1);
   build(mid+1,r,ceng+1);
 }
 
 
 long long look(long long ceng,long long sl,long long sr,long long l,long long r,long long k)
 {
   if(sl==sr) return val[ceng][sl];
   long long ly; 
   if(l==sl) ly=0;
  else ly=num[ceng][l-1];
   long long tolef=num[ceng][r]-ly;
  if(tolef>=k)
   {
     return look(ceng+1,sl,(sl+sr)/2,sl+ly,sl+num[ceng][r]-1,k);
   }
   else
   {
     long long lr = (sl+sr)/2 + 1 + (l-sl-ly);
     return look(ceng+1,(sl+sr)/2+1,sr,lr,lr+r-l+1-tolef-1,k-tolef);
	}
}
int main()
{
   	long long n,m,l,r,k;
   	scanf("%lld%lld",&n,&m);
	for(long long i=1;i<=n;i++)
    {
       scanf("%lld",&val[0][i]);
       sorted[i]=val[0][i];
    }
    sort(sorted+1,sorted+n+1);
    build(1,n,0);
    while(m--)
    {
    	scanf("%lld%lld%lld",&l,&r,&k);
    	printf("%lld\n",look(0,1,n,l,r,k));
   	}
  return 0;
}
```
---

---

## 作者：Xx_queue (赞：14)

这两天学习了主席树，基本上搞懂了主席树是怎么操作的

---

主席树，是一种可持久化线段树。最简单的操作就是维护静态区间第 $k$ 小

主席树通过维护历史版本，实现查询区间的有关操作

---

## 主席树的原理

假设现在有这么一个序列：$4, 1, 3, 5, 2$

问如何求出区间 $[1,3]$ 内大小为第二的数？

~~利用大眼观察法，很显然是3~~

那么让计算机去怎么实现呢？~~它又没有眼睛~~

对于这个序列，我们可以先建一颗空的权值线段树，命名为“树 $0$ ”（方便后面的使用），如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/gey4wrz8.png)

别告诉我你不知道什么是权值线段树，自己去百度；

现在序列里面第一个数是 $4$，我们往树里面插入一个 $4$ ，因为要保留历史版本，所以我们对 $4$ 这个数新建一颗线段树，命名为“树 $1$ ”，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/e239h0xp.png)

为什么是这样呢？

$1\le 4 \le5$，故区间 $[1,5]++$;

$4\le 4 \le5$，故区间 $[4,5]++$;

$4\le 4 \le4$，故区间 $[4,4]++$;

其他的还是 $0$ ;

懂了没有。。。

继续插入第二个数 $1$ ，建成“树 $2$ ” ，这里不解释了

![](https://cdn.luogu.com.cn/upload/image_hosting/89dyw9pb.png)

再插入第三个数 $3$，建成“树 $3$ ”

![](https://cdn.luogu.com.cn/upload/image_hosting/ejwbdazy.png)



OK！现在我们就已经可以求出 $[1,3]$ 内的大小为第二大的数了

递归操作查询排名应该都会吧？

不会的看这里：

 - 进入 $[1,5]$ 节点，我们发现他的左儿子的子树个数为$2$ ， $2\le k $ $(k=2)$，于是进入$[1,3]$节点;

 - 然后我们发现 $[1,3]$ 节点的左儿子子树个数$1 < k$ $(k=2)$，于是进入 $[3,3]$ 节点；

 - 此时我们把 $k$ 更新为 $1$ ($2-1=1$);

 - 走到头了，于是就返回 $3$ ，所以答案就是 $3$ ，也就是原来的序列区间 $[1,3]$ 的第 $2$ 小就是 $3$

现在你明白了主席树是怎么操作了的吧？

---

## 疑问

但是有一个问题：上面我们求的是区间$[1,r]$的第 $k$ 大的数

同理，区间 $[1,r]$ ($r\in$ $[1,n]$ , $r \in N$)的第 $k$ 大数我们也就会求了

那怎么求区间 $[l,r]$ 的第 $k$ 大数呢？

举个例子，求区间$[2,3]$的第 $k$ 大数

我们拿建出来的“树 $3$ ”减掉“树 $1$ ”后，再进行如上操作就可以了

这也就是前缀和思想

所以对于区间$[l,r]$ 我们拿“树 $r$ ”减去“树 $(l-1)$ ”，再query一下就可以求得答案了

还有一个问题：我每个数都开一个线段树来存，空间不会炸掉吗？

所以主席树是这样操作的：

 - 每插入一个数 $x$ ，只有 $[x,x]$ 到 $[1,n]$ 一条链上的点会更新操作，所以我们可以共用一些点，就OK了，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ym4n9hnp.png)

---

## 例题与代码

那么主席树就介绍完了，具体实现给个例题让大家看看，还有不懂得可以再参考一下他人的博客

[例题:【模板】可持久化线段树1(主席树)](https://www.luogu.com.cn/problem/P3834)

```cpp
#include <bits/stdc++.h>
#define N (200000+5)
#define ls ch[rt][0]
#define rs ch[rt][1]
#define vl ch[vs][0]
#define vr ch[vs][1]
using namespace std;
int n,m,q;
int rt[N],ch[N<<5][2],tot,val[N<<5];//rt:每个线段树的根，ch：左右儿子，tot：编号总数，val：权值
int a[N],b[N];//a：原数组，b：离散化数组
inline int query(int x){//离散化
	return lower_bound(b+1,b+m+1,x)-b;//离散化
}
inline void update(int &rt,int vs,int l,int r,int k){//更新，新建一棵树
	rt=++tot;//新树的根节点为tot++
	ls=vl,rs=vr;//左右儿子都是历史版本的左右儿子
	val[rt]=val[vs]+1;//新加入一个数，rt的权值++
	if(l==r) return;//叶子节点，return
	int mid=(l+r)>>1;//mid为分割区间的中点
	if(k<=mid) update(ls,vl,l,mid,k);//k<=mid，k在左儿子
	else update(rs,vr,mid+1,r,k);//否则k在右儿子
}
inline int query(int rt,int vs,int l,int r,int k){//询问第k大
	if(l==r) return l;//找到了（在叶子节点），return
	int mid=(l+r)>>1;
	int v=val[vl]-val[ls];
        //这里只用算一下k在不在左儿子就行了，不再左儿子就肯定在右儿子
	//这里用当前版本减去历史版本就是类似“前缀和”操作
	if(k<=v) return query(ls,vl,l,mid,k);//在左儿子，继续找
	else return query(rs,vr,mid+1,r,k-v);//不在左儿子，找右儿子，并把k减去左边所有的个数
}
int main(){
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),b[i]=a[i];//读入
	sort(b+1,b+n+1);//离散化数组先排序
	m=unique(b+1,b+n+1)-b-1;//离散化
	for(int i=1;i<=n;i++){
		update(rt[i],rt[i-1],1,n,query(a[i]));
        //一个节点一个节点的插入；
	//这里对rt进行引用（&），相当于rt[i]=update(rt[i],rt[i-1],1,n,query(a[i]));
	}
	while(q--){
		int l,r,k;
		scanf("%d%d%d",&l,&r,&k);
		printf("%d\n",b[query(rt[l-1],rt[r],1,n,k)]);//求解静态区间第k小，注意是l-1和r
	}
	return 0;
}

```

---

## 作者：G我就是菜G (赞：12)

### 前置知识

1. 线段树（不会的先过[【线段树1】](https://www.luogu.org/problemnew/show/P3372) & [【线段树2】](https://www.luogu.org/problemnew/show/P3373)）
2. 知道可持久化数据结构

### 主席树

是一种用来查询区间静态第 $k$ 小的数据结构

原型为线段树，简单的来讲就是开 $n$ 棵线段树，然后区间查询时只要查询第 $l-1$ 棵和第 $r$ 棵做前缀和做差就行了

但是开 $n$ 棵线段树空间复杂度太大

于是我们发现，没加入一个数，只会在一条路径上更改，如果开 $n$ 棵线段树会有很多冗余节点（即重复节点），所以每次加入一个数，我们就多开 $\log n$ 个节点（即路径长度）就行了，空间复杂度为 $O(n\log^2 n)$，时间复杂度为 $O(n\log n)$

### 1. 建空树（$build$）

首先要建一棵空树，由于我们是用前缀和的思想查找，所以在 $tree[0]$ 的位置是一棵空树

代码如下：
```cpp
void build(int &t,int l,int r)  \\t是当前节点编号
{
	int mid=(l+r)>>1;
	t=++cnt;
	if (l==r) return;
	build(ls[t],l,mid);
	build(rs[t],mid+1,r);
}
```

### 2. 插入数字（modify）

在插入数字之前，我们先要对其进行离散，然后插入其编号

如

> 123 54 78 92 193

对其进行离散后为

> 4 1 2 3 5

**空树：**

![](https://cdn.luogu.com.cn/upload/pic/59655.png)

**插入 4：**

![](https://cdn.luogu.com.cn/upload/pic/59657.png)

**插入 1：**

![](https://cdn.luogu.com.cn/upload/pic/59658.png)

**插入 2：**

![](https://cdn.luogu.com.cn/upload/pic/59659.png)

**插入 3：**

![](https://cdn.luogu.com.cn/upload/pic/59661.png)

**插入 5：**

![](https://cdn.luogu.com.cn/upload/pic/59662.png)

每次修改时遍历修改的路径，判断其左儿子还是右儿子有变化，将没变化的儿子序号设为上一棵树对应节点的对应儿子，变化儿子的序号新建一个节点，继续遍历。

代码：
```cpp
int modify(int X,int l,int r)
{
	int mid=(l+r)>>1,XX=++cnt;
	ls[XX]=ls[X],rs[XX]=rs[X],sum[XX]=sum[X]+1;
	if (l==r) return XX;
	if (x<=mid) ls[XX]=modify(ls[XX],l,mid);
	else rs[XX]=modify(rs[XX],mid+1,r);
	return XX;
}
```

### 3. 查询区间第 $k$ 大（$query$）

对于查询区间 $l$ 到 $r$ 的第 $k$ 小

我们同时遍历第 $l-1$ 棵线段树和第 $r$ 棵线段树

定义 $xx=sum[num2]-sum[num1]$ （$num2$ 为第 $r$ 棵线段树当前的节点，$num1$ 表示第 $l-1$ 棵线段树当前对应节点，$sum$ 表示其数字个数之差）

当 $k\le xx$ 时，直接向左走

当 $k> xx$ 时，向右走，同时 $k-=xx$

代码：
```cpp
int query(int num1,int num2,int l,int r,int k)
{
	int mid=(l+r)>>1,xx=sum[ls[num2]]-sum[ls[num1]];
	if (l==r) return l;
	if (k<=xx) return query(ls[num1],ls[num2],l,mid,k);
	else return query(rs[num1],rs[num2],mid+1,r,k-xx);
}
```
### 完整代码：
```cpp
#include <bits/stdc++.h>
#define N 5000010

using namespace std;

int n,m,len,cnt,sum[N],x,l,r,k,ans;
int a[N],b[N],ls[N],rs[N],tree[N];

inline int read()
{
	int x=0,tag=1;
	char c=getchar();
	for (;c<'0' || c>'9';c=getchar()) if (c=='-') tag=-1;
	for (;c>='0' && c<='9';c=getchar()) x=(x<<1)+(x<<3)+c-'0';
	return x*tag;
}

void build(int &t,int l,int r)
{
	t=++cnt;
	if (l==r) return;
	int mid=(l+r)>>1;
	build(ls[t],l,mid);
	build(rs[t],mid+1,r);
}

int modify(int x,int l,int r,int k)
{
	int mid=(l+r)>>1,xx=++cnt;
	ls[xx]=ls[x],rs[xx]=rs[x],sum[xx]=sum[x]+1;
	if (l==r) return xx;
	if (k<=mid) ls[xx]=modify(ls[xx],l,mid,k);
	else rs[xx]=modify(rs[xx],mid+1,r,k);
	return xx;
}

int query(int n1,int n2,int l,int r,int k)
{
	int mid=(l+r)>>1,xx=sum[ls[n2]]-sum[ls[n1]];
	if (l==r) return l;
	if (k<=xx) return query(ls[n1],ls[n2],l,mid,k);
	else return query(rs[n1],rs[n2],mid+1,r,k-xx);
}

int main()
{
	n=read(),m=read();
	for (int i=1;i<=n;i++)
		a[i]=b[i]=read();
	sort(b+1,b+n+1);
	len=unique(b+1,b+n+1)-b-1;
	build(tree[0],1,len);
	for (int i=1;i<=n;i++)
	{
		x=lower_bound(b+1,b+len+1,a[i])-b;
		tree[i]=modify(tree[i-1],1,len,x);
	}
	for (int i=1;i<=m;i++)
	{
		l=read(),r=read(),k=read();
		printf("%d\n",b[query(tree[l-1],tree[r],1,len,k)]);
	}
	return 0;
}
```

### 另一道模板题

[可持久化数组](https://www.luogu.org/problemnew/show/P3919)

不用离散，改成每个节点存数字就行了

查询时只要像线段树查询一样，不需要用前缀和

代码如下：
```cpp
#include <bits/stdc++.h>
#define N 50000010
using namespace std;
int n,m,cnt,opt,loc,k,val;
int tree[N],num[N],ls[N],rs[N];
void build(int &t,int l,int r)
{
    int mid=(l+r)>>1;
    t=++cnt;
    if (l==r)
    {
        scanf("%d",&num[t]);
        return;
    }
    build(ls[t],l,mid);
    build(rs[t],mid+1,r);
}

int modify(int X,int l,int r)
{
    int mid=(l+r)>>1,XX=++cnt;
    ls[XX]=ls[X],rs[XX]=rs[X];
    if (l==r)
    {
        num[XX]=val;return XX;
    }
    if (k<=mid) ls[XX]=modify(ls[XX],l,mid);
    else rs[XX]=modify(rs[XX],mid+1,r);
    return XX;
}

int query(int i,int l,int r,int k)
{
    int mid=(l+r)>>1;
    if (l==r) return num[i];
    if (k<=mid) return query(ls[i],l,mid,k);
    else return query(rs[i],mid+1,r,k);
}

int main()
{
    scanf("%d%d",&n,&m);
    build(tree[0],1,n);
    for (int i=1;i<=m;i++)
    {
        scanf("%d%d",&loc,&opt);
        if (opt==1)
        {
            scanf("%d%d",&k,&val);
            tree[i]=modify(tree[loc],1,n);
        }
        else
        {
            scanf("%d",&k);
            printf("%d\n",query(tree[loc],1,n,k));
            tree[i]=tree[loc];
        }
    }
    return 0;
}
```

---

## 作者：向noip冲刺 (赞：12)

`主席树`(一个简单的数据结构花了我一天的时间整理)    
 
> 主席树可以用来解决如下问题：“给出一列数,a1,a2…an,每次询问其中连续的一段区间ai到aj其中的第K小的数是多少？”(询问次数为5000,序列长度≤2e5)    
我们应如何做呢.    
每次询问排序??显然复杂度是巨大的  
那么接下来我们要学习主席树(一个可持续化数据结构)   
`可持续化:能够查询历史版本.`   
> 何谓查询历史版本: 例如我们执行一些操作:   
> 你还剩下1,1,1,2,2这些牌.假设你打出了对二(当然,现实生活中是不会有人这样出的)然后你发现你手里有三张一样的牌,然后你想撤销以前的操作,然后你就回到刚开始的时候.这在我们编程里怎样体现呢.就是存起以前的状态.然后进行一些撤销操作之类的.这就是查询历史版本.    
> 想要学会主席树.我们还要学会  
> * 权值线段树 :  
> 前缀和.   
  
`权值线段树`    
> 来了解一下权值线段树吧.   
> 与线段树相差无几,唯一的不同之处就是他的(数组)下标为x的数组所存的值是数组中有当前值的数的个数   
例如我们有这么一些数: 1.2.3.4.4.3.2.1   
假设我们要 求出5 ~ 8这个区间的第三大数.   
我们就会构造这么两个图   
![1 ~ 4](https://i.loli.net/2018/07/08/5b413cbddff2f.bmp)

![5 ~ 8](https://i.loli.net/2018/07/08/5b413ef5b7c08.bmp)
现在我们来模拟一下如何用权值线段树查询[5,8]第三大数.  
> 首先我们对比一下根节点的左孩子的个数,我们会发现4 - 2 = 2 ,2 < 3,所以相比以前的版本多出了两个元素,因为我们要找第三大.所以我们去右孩子去找第k大元素,直到根节点为止.    
> 这就是前缀和的思想.但是我们要找这么多区间.每一次都要造一个[1,i] (i不确定)的区间.然后去查询,显然空间复杂度是巨大的.   
> 接下来我们要开始正式学习主席树啦.  

空间巨大怎么办,显然我们可以利用他们的一些共同信息.  
> 当新加入一个点的时候,只有一条链上发生改变.  

我们有这样一个序列.  
长度为7,询问数为1.  
1  5 2 6 3 7 4  
2 5 3  
`ps`先离散化,存的是数组下标.   
然后我们建立这样一颗空树(线段树)  
`ps`连线画歪了,注意qwq.  
![](https://i.loli.net/2018/07/13/5b47e4aad3923.jpg)
当然,点值都为0.  
我们插入1.  
![未命名文件 (1).jpg](https://i.loli.net/2018/07/12/5b46a1f05b11f.jpg)
然后这样插入插入.形成了这颗树(没有连边,注意.)  
![](https://i.loli.net/2018/07/12/5b46a2bbecb6a.jpg)
然后我们拿出l - 1颗树和第r颗树也就是1和5这颗.  
利用我们刚才的权值线段树所学的知识相减即可.  
但我们还没有步入正题.如何共用一些公共节点.    
假设我们构造好了[1,4]这个区间,然后我们继续下一个数字
还是以上面的例子.    
构造好了的[1,4]区间是这个样子的.  
![未命名文件.jpg](https://i.loli.net/2018/07/13/5b47e5c0488f1.jpg)
此时我们添加第5个元素,也就是3.  
![](https://i.loli.net/2018/07/12/5b46a67335402.jpg)
这条路径是我们要修改的路径.  
当我们修改一个树的左子树时,它的右子树是不变的,我们可以借用它.  
![](https://i.loli.net/2018/07/12/5b46a74fde8f7.jpg)
当我们更新到next点的时候,我们就会利用上图的这个.以前的那个就成了历史版本了.   
准备一天的主席树终于敲完了  
[luogu P3834 【模板】可持久化线段树 1（主席树](https://www.luogu.org/problemnew/show/P3834)
#### code  
```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
const int maxN = 2e5 + 7;
using namespace std;

int root[maxN],cnt,s[maxN],a[maxN];
struct Node {int lc,rc,w;}tree[maxN * 20];

inline int read() {
    int x = 0,f = 1;char c = getchar();
    while(c < '0' || c > '9') {if(c == '-')f = -1;c = getchar();}
    while(c >= '0' && c <= '9') {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}

void add(int &now,int last,int l,int r,int x) {
    now = ++cnt;
    tree[now].w = tree[last].w + 1; 
    tree[now].lc = tree[last].lc;tree[now].rc = tree[last].rc;
    if(l == r)return;
    int mid = (l + r) >> 1;
    if(x <= mid) add(tree[now].lc,tree[last].lc,l,mid,x);
    else add(tree[now].rc,tree[last].rc,mid + 1,r,x);
    return;
}

int query(int L,int R,int l,int r,int x) {
    if(l == r)return l;
    int mid = (l + r) >> 1;
    int p = tree[tree[R].lc].w - tree[tree[L].lc].w;
    if(p < x) return query(tree[L].rc,tree[R].rc,mid + 1,r,x - p);
    else return query(tree[L].lc,tree[R].lc,l,mid,x);
}

int main() {
    int n,m;
    n = read();m = read();
    for(int i = 1;i <= n;++ i) {s[i] = a[i] = read();}
    sort(s + 1,s + n + 1); 
    for(int i = 1;i <= n;++ i ){
        int p = lower_bound(s + 1,s + n + 1,a[i]) - s;
        add(root[i],root[i - 1],1,n,p);}
    int l,r,x;
    while(m -- ) {
        l = read();r = read();x = read();
        int y = query(root[l - 1],root[r],1,n,x);
        printf("%d\n",s[y]);
    } 
    return 0;
} 
```
qwq.有不理解或者本文有错误的.欢迎骚扰.QQnum:3361879051.

---

## 作者：lgswdn_SA (赞：11)

### Wavelet Matrix

考虑这样的一个结构（以下序列全部都是 0-index）：

- 对于原序列 $a$，设其最高位是 $H$。令 $c_{H+1,i}=a_i$。然后我们从高到低遍历每一位 $x$。

- 对于 $x$，我们先将 $c_{x}$ 继承自 $c_{x+1}$，然后我们记录 $c_x$ 每个元素二进制最高位 $x$ 的值 $b_{x,i}$。
- 然后我们对原来的 $c_x$ 做一次变换得到新的 $c_{x}$：把第 $x$ 位为 $0$ 的元素挪到左边，然后第 $x$ 位为 $1$ 的元素挪到右边。设 $p_x$ 表示这一位 $0$ 的个数。
- eg：$a=[1,3,2,0]$，我们先得到 $b_1=[0,1,1,0]$，然后得到 $c_1=[1,0,3,2]$，$p_1=2$；然后我们得到 $b_0=[1,0,1,0]$，然后得到 $c_0=[0,2,1,3]$，$p_0=2$。注意 $c$ 并不是一个有序结构。

$O(n\log V)$ 构建这样的结构是简单的。考虑如何 $O(\log V)$ 查询 $k$ 小值。

- 从高往低遍历每一位 $x$。
- 考虑 $i\in[l,r]$ 中 $b_{x,i}=0$ 的个数 $w$。如果 $w<k$ 那么意味着这一位必须是 $0$，那么下一层我们只需要在满足 $b_{x,i}=0$ 的前缀里面问询即可。具体而言，设 $l'$ 表示这一层下标 $<l$ 的 $b_{x,j}=0$ 的个数，$r'$ 表示这一层下标 $\le r$ 的 $b_{x,j}=0$ 的个数，那么只需要递归到下一层时将 $[l,r]$ 替换成 $[l',r'-1]$ 即可。
- 如果 $w>k$ 那么意味着这一位必须是 $1$，那么我们贡献给答案，再将 $k$ 减掉 $w$ 后递归进满足 $b_{x,i}=1$ 的后缀里面问询即可。具体而言，设 $l'$ 表示这一层下标 $<l$ 的 $b_{x,j}=1$ 的个数，$r'$ 表示这一层下标 $\le r$ 的 $b_{x,j}=1$ 的个数，那么只需要递归进到下一层时将 $[l,r]$ 替换成 $[l'+p_x,r'+p_x-1]$ 即可。

注意到我们并不需要对于每个 $x$ 都维护出 $c$，只需在构建时动态维护变换即可。而 $b$ 的维护可以使用一个手写的 bitset（支持单点修改，以及 $O(1)$ 区间查 popcount）。空间复杂度 $O(\frac{n\log V}{w})$。

实现部分参考自 https://zhuanlan.zhihu.com/p/590974585 （如在构建 Wavelet Matrix 时使用 `std::stable_partition` 等，同时该文章内有引用自 https://miti-7.hatenablog.com/entry/2018/04/28/152259 的一些视觉化的演示）。

```
const int N=(1<<18)+5,H=29;
int n,a[N],m;

struct bst {
  ull b[N/64+5],c[N/64+5]; int m;
  #define msk(i) ((1ull<<((i)&63))-1)
  void init(int n) {m=n/64+1;}
  void set(int i) {b[i>>6]|=1ull<<(i&63);}
  bool get(int i) {return (b[i>>6]>>(i&63))&1;}
  int p1(int i) {return c[i>>6]+popcnt(b[i>>6]&msk(i&63));}
  int p0(int i) {return i-c[i>>6]-popcnt(b[i>>6]&msk(i&63));}
  int s1(int l,int r) {return p1(r+1)-p1(l);}
  int s0(int l,int r) {return p0(r+1)-p0(l);}
  void getcnt() {rep(i,1,m-1) c[i]=c[i-1]+popcnt(b[i-1]);}
};

namespace WT {
  bst b[30]; int p[30],c[N];
  void build() {
    rep(i,0,n-1) c[i]=a[i];
    per(h,29,0) {
      b[h].init(n); rep(i,0,n-1) if(c[i]&(1<<h)) b[h].set(i);
      b[h].getcnt(); p[h]=stable_partition(c,c+n,[&](int x) {
        return !((x>>h)&1);})-c;
    }
  }
  int qry(int l,int r,int k,int x=0) {
    k--; per(h,29,0) {
      int cnt=b[h].s0(l,r);
      if(cnt>k) l=b[h].p0(l), r=b[h].p0(r+1)-1, assert(r<=p[h]);
      else x|=1<<h, l=p[h]+b[h].p1(l), r=p[h]+b[h].p1(r+1)-1, k-=cnt;
    } return x;
  }
}

signed main() {
  n=read(), m=read();
  rep(i,0,n-1) a[i]=read();
  WT::build();
  while(m--) {
    int l=read()-1, r=read()-1, k=read();
    printf("%d\n",WT::qry(l,r,k));
  }
  return 0;
}
```

---

## 作者：Juan_feng (赞：11)

早就想发一篇纯分块的题解了， 因为各种事情耽误了几个月...... 

所以蒟蒻也就不多废话了， 直接进入正题：

**值域分块在n sqrt(n)的时间内解决该问题**

那么我们该怎样解决这个问题呢qwq？  

我们先把数列分块， 再把值域分块， 然后维护两个数组cnt1， cnt2, cnt1(i, j)表示前i个数列块中第j个值域块的数值出现的次数和， cnt2（i, j)表示前i个块中j这个数字出现的次数。 这两个数组显然可以在n sqrt(n)的时间内处理完成。

那么接下来当我们求l r 区间的第k大的时候， 对于散块， 我们用两个临时数组san， san2 来记录和cnt1 cnt2一样的东西（只不过这个记录的是散块中的信息， 而不是前缀和）， 然后对于整块， 因为我们已经处理出了前缀和， 所以可以直接从头开始扫值域块， 累加cnt1+san ， 直到这个数量大于我们要查询的k， 这时候就能确定我们要查询的数值再哪一个值域块中了。 下面只要在扫一遍这个值域块中的每一个数， 通过cnt2和san2 就能知道具体要查询的是哪个数了qwqwq。

那么就没啥了啊qwqwq 如果有什么问题的话私信小蒟蒻就好啦qwqwq

**那么代码如下**

```
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <cstdio> 
#define maxn 200010
#define re register
#define FOR(i, l, r) for(re int i = l; i <= r; ++i)
using namespace std;

int n, m, c, r, t, x, y, k;
int sq, sq2;
int nw[maxn], a[maxn], b1[maxn], b2[maxn], cnt1[500][500], cnt2[480][maxn], q[maxn][4], z[maxn];
int san[500], san2[maxn];

inline void in(re int &x){
    x=0;int bl = 1;char c=getchar();
    while(c<'0'||c>'9'){
    	if(c == '-')
    	  bl = -1;
        c=getchar();
    }
    while(c<='9'&&c>='0'){
        x=(x<<1)+(x<<3)+(c^'0');
        c=getchar();
    }
    x *= bl;
}

void out(re int a){
    if(a < 0) {
        putchar('-');
        a = -a;
    }
    if(a>=10)out(a/10);
    putchar(a%10+'0');
}

int get_val(int x, int y, int k) {
    int res = 0, pd = 0;
    FOR(i, x, min(y, b1[x]*sq))
      ++san[b2[nw[i]]], ++san2[nw[i]];
    if(b1[x] != b1[y])
      FOR(i, (b1[y]-1)*sq+1, y)
        ++san[b2[nw[i]]], ++san2[nw[i]];
    FOR(i, 1, b2[z[0]]) {
    	int ld = cnt1[b1[y]-1][i]-cnt1[b1[x]][i];
    	if(ld < 0) ld = 0;
        if(res+(ld+san[i]) < k) { 
        	res += san[i];
        	if(cnt1[b1[y]-1][i]-cnt1[b1[x]][i] > 0)
        	  res += cnt1[b1[y]-1][i]-cnt1[b1[x]][i];
        }
        else {
        	pd = i;	
        	break;
        }
    }
    int anss = -1;
    FOR(i, (pd-1)*sq2+1, pd*sq2) {
    	res += san2[i];
    	if(cnt2[b1[y]-1][i]-cnt2[b1[x]][i] > 0)
    	  res += cnt2[b1[y]-1][i]-cnt2[b1[x]][i];
        if(res >= k) {
        	anss = z[i];
        	break;
        }
    }
    FOR(i, x, min(y, b1[x]*sq))
      --san[b2[nw[i]]], --san2[nw[i]];
    if(b1[x] != b1[y])
      FOR(i, (b1[y]-1)*sq+1, y)
        --san[b2[nw[i]]], --san2[nw[i]];
    return anss;
}

int main() {
    in(n), in(m);
    sq = sqrt(n);
    FOR(i, 1, n)
      in(a[i]), b1[i] = (i-1)/sq+1, z[++z[0]] = a[i];
    FOR(i, 1, m) {
        in(q[i][1]),
        in(q[i][2]),
        in(q[i][3]);
    }
    sort(z+1, z+z[0]+1);
    z[0] = unique(z+1, z+z[0]+1)-z-1;
    sq2 = sqrt(z[0]);
    FOR(i, 1, z[0])
      b2[i] = (i-1)/sq2+1;
    FOR(i, 1, n) {
        nw[i] = lower_bound(z+1, z+z[0]+1, a[i])-z; //nw为a排序后的位置，处理cnt1， cnt2 
        ++cnt1[b1[i]][b2[nw[i]]];
        ++cnt2[b1[i]][nw[i]];
    }
    FOR(i, 1, b1[n]) { //处理前缀和 
        FOR(j, 1, b2[z[0]]) 
          cnt1[i][j] += cnt1[i-1][j];
        FOR(j, 1, z[0])
          cnt2[i][j] += cnt2[i-1][j];
    }
    FOR(i, 1, m) {
        out(get_val(q[i][1], q[i][2], q[i][3]));
        putchar(10);
    }
}
```

---

## 作者：qzp666 (赞：11)

这题可以用整体二分过掉。

首先考虑一次询问的情况，我们可以二分答案，然后通过验证比答案大的数有多少个来不断地缩小答案范围直至得到一个准确的答案。而对于多个询问我们同样可以这么做，只不过对每一个询问我们都需要判定一下，以决定它被划分到哪一个答案的区间里。这个判定过程就是通过比较比mid大的数的个数和k。同时如果比二分的mid大的数的个数小于k了，我们是要去寻找小的答案，那么这些比mid大的数在以后的递归里始终会对答案有贡献，所以我们没必要去做重复的工作，只需要把这些数的个数累积到贡献里，以后递归的时候就不用考虑这些数。我们可以把数列里的数也和询问一起递归，这样这些数也会被分到属于的答案区间里，并且只对相应区间里的询问有影响。

整体二分的过程实质上是个按照数值来划分操作序列的过程，于是复杂度也就和操作序列的长度线性相关，那么我们在中间维护一些信息的时候，就一定不能有和数列长线性相关的东西，否则会破坏其时间复杂度。

具体的复杂度证明请见2013年集训队XHR论文。

```cpp
#include <bits/stdc++.h>
#define lowbit(x) (x&(-x))
#define INF 0x3f3f3f3f
#define N 200005
#define M 200005
using namespace std;
int n,m,pos;
int Max=-INF,Min=INF;
int id[N],ans[N],tmp[N];
bool mark[N];
struct DATA{
    int x,v;
    bool operator < (const DATA&r)const{return v<r.v;}
}data[N];
struct Ques{
    int l,r,k;
}q[M];
int tree[N];
inline void add(int x,int num){
    while(x<=n){
        tree[x]+=num;
        x+=lowbit(x);
    }
}
inline int search(int x){
    int re=0;
    while(x){
        re+=tree[x];
        x-=lowbit(x);
    }
    return re;
}
void solve(int l,int r,int L,int R){
    if(l>r || L==R)     return;
    int mid=(L+R)>>1;
    while(data[pos+1].v<=mid && pos<n){
        add(data[pos+1].x,1);
        ++pos;
    }
    while(data[pos].v>mid){
        add(data[pos].x,-1);
        --pos;
    }
    int cnt=0;
    for(int i=l;i<=r;++i){
        if(search(q[id[i]].r)-search(q[id[i]].l-1)>q[id[i]].k-1){
            ans[id[i]]=mid;
            mark[i]=1;
            ++cnt;
        }
        else    mark[i]=0;
    }
    int l1=l,l2=l+cnt;
    for(int i=l;i<=r;++i){
        if(mark[i])     tmp[l1++]=id[i];
        else            tmp[l2++]=id[i];
    }
    for(int i=l;i<=r;++i)       id[i]=tmp[i];
    solve(l,l1-1,L,mid);
    solve(l1,l2-1,mid+1,R);
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i){
        scanf("%d",&data[i].v);
        data[i].x=i;
        Max=max(Max,data[i].v);
        Min=min(Min,data[i].v);
    }
    sort(data+1,data+n+1);
    for(int i=1;i<=m;++i)       scanf("%d%d%d",&q[i].l,&q[i].r,&q[i].k);
    for(int i=1;i<=m;++i)       id[i]=i;
    solve(1,m,Min,Max+1);
    for(int i=1;i<=m;++i)       printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：Bartholomew (赞：11)

#By Bartholomew
-------
###前置知识:

1.树状数组

2.线段树
#主席树
**模板是干什么的,其实就是询问区间第k大**

不支持修改:
复杂度$O(nlog_n)$

带修:
复杂度$O(n * (log_n)^2)$
##分析:

**请大家耐心看完下面一道题目的做法,因为跟主席树的关系很大**
###引题
我们其实有一道题目(~~现编~~),就是求一个每次**添加元素**至末尾的序列的**中位数**的大小的题目

就相当于给你最后的数组,让你还原每一次的过程中的中位数并依次输出.
~~(先忽视掉数据范围)~~
如(样例):
>**input:**

>5

>4 2 7 3 1

>**output:**

>4 (4 序列的中位数)

>3 (4 2 的排序后中位数)

>4 (4 2 7 排序后的中位数,以此类推)

>3.5

>3

其中有一个做法就是建立一颗 **线段树**
每个节点代表一个区间$[i,j]$ 意味着离散化后的数字大小为 $i $~ $j$ 的数字出现了多少次

在我们的样例之中,离散化之后还是只有 5 个数字,所以是建立siz = 5 的树
那么很容易推出这棵树的模样:

![这里写图片描述](https://img-blog.csdn.net/20180413205329517?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODA5NjY0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
那么我们发现当 元素 $a[1]=4$ (离散化后为4) 加入到这颗树后对每一个节点的影响为以下:
![这里写图片描述](https://img-blog.csdn.net/20180413205856510?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODA5NjY0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
那么我们其实就是知道是怎么加入元素了
但是还有一个问题,就是求 $kth$怎么办?

答: 我们可以看$root(指的是当前节点)$的左节点,设它的值为x

**如果 $x >= k $, 那么就是往下搜索 第 $k$大**

**如果 $x < k$, 那么就是往左搜索 第 $k - x$ 大**

其实就是一个递归程序,具体细节想必大家都知道的,不必细讲!

那么就可以切入正题了!
###解决
我们考虑最暴力的思想:

**就是建立 n 棵像上面说的那样的树, 第 $i$ 棵树$T_i$维护的是 区间 [1,i]的序列信息**

**可以发现,这种树是不是有区间相减的性质? **

**举个栗子: [3,4] 区间的 离散化大小为 [1,3]的数有多少个? 不就是将T[4] 的 表示 [1,3]区间的节点的权值减去T[2]的节点表示[1,3] 区间的节点的权值就是 [3,4]区间的离散大小为[1,3]的数的个数了吗(前缀思想) **

那么这个时间复杂度我们就可以保证是在 $nlog_n$ 里了,但是我们会发现,每一颗维护区间的树的空间复杂度是不是$O(n)$的,那么随便计算一下发现我们的空间复杂度就是$O(n^2)$的了,非常的不爽,怎么办?

但是我们只要观察一下,是不是每一次都是只会有 一条 $O(log_n)$的路径是被修改的,而别的信息是不是不变的,那么我们就可以考虑每一次只是建立 log 个节点,让这些树共用一些部分
我们翻一下样例:
比如就是一开始我们说的样例好了,假设我们建完了T[3] 这棵树,我们加入第 4 个元素:
![ll](https://img-blog.csdn.net/2018041407325379?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODA5NjY0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
![这里写图片描述](https://img-blog.csdn.net/20180414073345633?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODA5NjY0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
那么我们就这样自建立：
![这里写图片描述](https://img-blog.csdn.net/20180414073603794?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODA5NjY0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
那么我们就是可以保证是没有问题,而且时间与空间复杂度都是稳定的树了
##代码:
![这里写图片描述](https://img-blog.csdn.net/20180414082052231?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODA5NjY0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

```
#pragma GCC optimize(3)
#include <cstdio>
#include <cmath>
#include <algorithm>
#define N 200005
#define M 4000005
#define R register
using namespace std;

int n, Q, m, cnt, a[N], b[N], x, y, k;
int T[N], ls[M], rs[M], sum[M];

inline int read()
{
    int x = 0;
    char c = getchar();
    bool flag = 0;
    while(c < '0' || c > '9'){if(c == '-')flag = 1;c = getchar();}
    while(c >= '0' && c <= '9'){x = (x << 3) + (x << 1) + (c ^ 48);c = getchar();}
    return flag ? -x : x;
}

int Build(int l, int r)
{
    int now = ++cnt;
    if(l < r)
    {
        int mid = (l + r) >> 1;
        ls[now] = Build(l, mid);
        rs[now] = Build(mid + 1, r);
    }
    return now;
}

inline void Build_new(int mark, int loc)
{
    T[mark] = ++cnt;
    sum[cnt] = sum[T[mark - 1]] + 1;
    int l =  1, r = m, now = cnt, still = T[mark - 1];
    for(; ls[still] || rs[still];)
    {
        int mid = (l + r) >> 1;
        // l ~ mid --- left    mid + 1 ~ r --- right
        if(loc > mid)
        {
            ls[now] = ls[still];rs[now] = ++cnt;
            sum[ rs[now] ] = sum[ rs[still] ] + 1;
            now = rs[now];
            still = rs[still];
            l = mid + 1;
        }
        else
        {
            rs[now] = rs[still];ls[now] = ++cnt;
            sum[ ls[now] ] = sum[ ls[still] ] + 1;
            now = ls[now];
            still = ls[still];
            r = mid;
        }
    }
}

inline int query(int a, int b, int l, int r, int k)
{
    if(l == r) return l;
    int lm = sum[ls[b]] - sum[ls[a]];
    int mid = (l + r) >> 1;
    if(k <= lm) return query(ls[a], ls[b], l, mid, k);
    return query(rs[a], rs[b], mid + 1, r, k - lm);
}

signed main()
{
    n = read(), Q = read();
    for(R int i = 1; i <= n; i++) a[i] = read(), b[i] = a[i];
    sort(b + 1, b + 1 + n);
    m = unique(b + 1, b + 1 + n) - b - 1;
    T[0] = Build(1, m);
    for(R int i = 1; i <= n; i++)
    {
        int loc = lower_bound(b + 1, b + 1 + m, a[i]) - b;
        Build_new(i, loc);
    }
    for(R int i = 1; i <= Q; i++)
    {
        x =read(), y=read(), k=read();
        printf("%d\n", b[query(T[x - 1], T[y], 1, m, k)]);
    }
    return 0;
}
```
##待修主席树
我们现在来思考待修改的主席树

比如这个样例
>intput:
5 3
3 2 1 4 7
Q 1 4 3
C 2 6
Q 2 5 3
output:
3
6

Q 表示询问 [x,y] 区间 第 k 大 C 表示将第 x 位的数字修改成为 y

我们不妨想一想对于树状数组的修改是怎么修改的
如果我们暴力的话,其实就是对于 这 T[2] 之后的所有树重新构建一遍,但是显然是不行的对吧!
我们可以考虑只是对于某一些树进行修改

对于更新， 我们**不改变这些已经建好的树**， 而是**另建一批树S**，用来记录更新，而这批线段树，我们用树状数组来维护

也就是**树状数组的每个节点都是一颗线段树**
一开始，S[0]、S[1]、S[2]、S[3]、S[4]、S[5] (建了一棵空树)

就利用树状数组的 lowbit 的性质
将 T[2] 以及 T[2+lowbit(2)] 的之后的所有的树都进行重构 那么 复杂度就是 $O(n * (log_n)^2)$得到了保证,但是大家可能会有一点疑惑,为什么这样做呢?

请大家记住我说过的话,再重复一遍:
**树状数组的每个节点都是一颗线段树,只不过每个点修改都是 $O(log_n)$的复杂度**
因为每颗节点就是一棵树,自然修改就是 log 的复杂度的!
![这里写图片描述](https://img-blog.csdn.net/20180414082037548?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODA5NjY0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
其实我们原来的树状数组代码就是这样的

```

inline void init()
{
    for(int i=1;i<=n;i++)
        for(int j=i;j<=n;j+=lowbit(j))
            c[j]+=a[i];
}
inline long long get(int x)
{
    int ans=0;
    for(int i=x;i>=1;i-=lowbit(i))
        ans+=c[i];
    return ans;
}

```
那么我们不要把树状数组想的这么难
就是相当于是我们在询问 某棵树 T[x] 的 某一个位置的节点 k 的真实值罢了

就是 **原来的$sum$ + 修改的$sum$**

那么 修改的$sum$ 就是$S$树我们其实就是要看 $x , x - lowbit(x) $...... 这些树的同样是 $k$ 的位置的值相加就好了

因为其实我们把**树看做一个"点"** ,那么我们其实就是问 **T[x] 的"真实的样子"**,那么我们就是访问$lowbit$的 "点" (就是S 树) 把所有的S树**层层叠加**得到的树就是 T[x] 的"真实的样子"

假公式:

$$T_{x,real}=T_x+\sum_{i=x}^{i-= lowbit(i)}S[i] $$**把它们当做点来看**

那么我们现在不需要问 一整颗树,而是某一个节点,那么我们只要 抓住 位置为询问的节点的点的$sum$值
并把它们相加就是答案了! 对吧!
##代码

```
#pragma GCC optimize(3)
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <iostream>
#define N 60005
#define M 2000005
#define R register
using namespace std;

int n, Q, m, cnt, a[N], b[N], x, y, k;
int T[N], S[N], ls[M], rs[M], sum[M];
int cntE, use[3][N];

struct ques
{
    char s[1];
    int l, r, kth;
}q[N >> 2];
inline int read()
{
    int x = 0;
    char c = getchar();
    bool flag = 0;
    while(c < '0' || c > '9'){if(c == '-')flag = 1;c = getchar();}
    while(c >= '0' && c <= '9'){x = (x << 3) + (x << 1) + (c ^ 48);c = getchar();}
    return flag ? -x : x;
}

int Build(int l, int r)
{
    int now = ++cnt;
    if(l < r)
    {
        int mid = (l + r) >> 1;
        ls[now] = Build(l, mid);
        rs[now] = Build(mid + 1, r);
    }
    return now;
}

inline int Build_new(int flag, int mark, int loc, int val)
{
    int rt = ++cnt; 
    int before;
    if(mark == 1) before = T[0];
    else before = flag ? T[mark - 1] : S[mark - 1];
    if(!flag && val) before = S[mark];
	sum[rt] = sum[before] + val;
    int l =  1, r = m, now = rt, still = before;
    for(; ls[still] || rs[still];)
    {
        int mid = (l + r) >> 1;
        // l ~ mid --- left    mid + 1 ~ r --- right
        if(loc > mid)
        {
            ls[now] = ls[still];
            rs[now] = ++cnt, sum[ rs[now] ] = sum[ rs[still] ] + val;
            now = rs[now];
            still = rs[still];
            l = mid + 1;
        }
        else
        {
            rs[now] = rs[still];
            ls[now] = ++cnt, sum[ ls[now] ] = sum[ ls[still] ] + val;
            now = ls[now];
            still = ls[still];
            r = mid;
        }
    }
    return rt;
}

inline int lowbit(int x) { return x & (-x); }
inline int Sum(int y, int x)
{
    int res = 0;
    for(R int i = x; i >= 1; i -= lowbit(i))
        res += sum[ls[use[y][i]]];
    return res;
}
inline int query(int u, int v, int a, int b, int l, int r, int k)
{
    if(l == r) return l;
    int lm = Sum(2, v) + sum[ls[b]] - sum[ls[a]] - Sum(1, u);
    int mid = (l + r) >> 1;
    if(k <= lm) 
    {
        for(R int i = u; i >= 1; i -= lowbit(i))
            use[1][i] = ls[use[1][i]];
        for(R int i = v; i >= 1; i -= lowbit(i))
            use[2][i] = ls[use[2][i]];
        return query(u, v, ls[a], ls[b], l, mid, k);
    }
    for(R int i = u; i >= 1; i -= lowbit(i))
            use[1][i] = rs[use[1][i]];
    for(R int i = v; i >= 1; i -= lowbit(i))
            use[2][i] = rs[use[2][i]];
    return query(u, v, rs[a], rs[b], mid + 1, r, k - lm);
    return 0;
}

inline void update(int loc,int num)
{
    int where;
    where = lower_bound(b + 1, b + 1 + m, a[loc]) - b;
    for(R int i = loc; i <= n; i += lowbit(i))
        S[i] = Build_new(0, i, where, -1);
    where = lower_bound(b + 1, b + 1 + m, num) - b;
    for(R int i = loc; i <= n; i +=lowbit(i))
        S[i] = Build_new(0, i, where, 1);
    a[loc] = num;
}

signed main()
{
    n = read(), Q = read();
    for(R int i = 1; i <= n; i++) a[i] = read(), b[i] = a[i];
    cntE = n;
    for(R int i = 1; i <= Q; i++)
    {
        scanf("%s%d%d", q[i].s, &q[i].l, &q[i].r);
        if(q[i].s[0] == 'Q')
            scanf("%d", &q[i].kth);
        else 
            b[++cntE] = q[i].r;
    }
    sort(b + 1, b + 1 + cntE);
    m = unique(b + 1, b + 1 + cntE) - b - 1;
    T[0] = Build(1, m);
    for(R int i = 1; i <= n; i++)
    {
        int loc = lower_bound(b + 1, b + 1 + m, a[i]) - b;
        T[i] = Build_new(1, i, loc, 1);
    }
    for(R int i = 1; i <= n; i++)
        S[i] = Build_new(0, i, 1, 0);
    for(R int i = 1; i <= Q; ++i)
    {
        if(q[i].s[0] == 'Q')
        {
            int x = q[i].l, y = q[i].r;
            for(R int j = x - 1; j >= 1; j -= lowbit(j))
                use[1][j] = S[j];
            for(R int j = y; j >= 1; j -= lowbit(j))
                use[2][j] = S[j];
            printf("%d\n", b[query(x - 1, y, T[x - 1], T[y], 1, m, q[i].kth)]);
        }
        else
            update(q[i].l, q[i].r);
    }
    return 0;
}
```
安利个人博客:
[主席树](https://blog.csdn.net/qq_39809664/article/details/79934516)

---

## 作者：rainygame (赞：9)

> 回来吧我的 BIT！我最高傲的信仰！
> 
> 回来吧我的 BIT！我最高傲的信仰！
>
> 回来吧我的 BIT！我最高傲的信仰！

考虑维护一颗权值树状数组。

对于每个树状数组结点，维护一个有序 `vector` 表示有哪些位置的值在这个结点的范围内。那么我们就可以通过二分查找得出这个树状数组结点中有多少个数在 $[l,r]$ 之间，再套一层二分查找就可以 $O(\log^3 n)$ 地完成一次查询。这部分的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 200001

int n, m, l, r, k, d;
int a[MAXN], b[MAXN];

void init(){
	memcpy(b, a, sizeof(a));
	sort(b+1, b+n+1);
	d = unique(b+1, b+n+1)-b-1;
	for (int i(1); i<=n; ++i) a[i] = lower_bound(b+1, b+d+1, a[i])-b;
}

namespace BIT{
#define lowbit(x) ((x) & -(x))
	vector<int> c[MAXN];
	void add(int x, int ind){
		while (x <= d){
			c[x].push_back(ind);
			x += lowbit(x);
		}
	}
	
	int query(int x){
		int res(0);
		while (x){
//			cout << "QUERY:" << 
			res += upper_bound(c[x].begin(), c[x].end(), r)-upper_bound(c[x].begin(), c[x].end(), l-1);
			x -= lowbit(x);
		}
		return res;
	}
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin >> n >> m;
	for (int i(1); i<=n; ++i) cin >> a[i];
	init();
	for (int i(1); i<=n; ++i) BIT::add(a[i], i);
	
	while (m--){
		cin >> l >> r >> k;
		
		int L(1), R(d), mid;
		while (L < R){
			mid = (L+R) >> 1;
			if (BIT::query(mid) >= k) R = mid;
			else L = mid+1;
		}
		cout << b[L] << '\n';
	}
	
	return 0;
}
```

但是无法通过，所以考虑再消掉一个 $\log$。可以把二分写进树状数组里面，就像线段树上二分那样。但是树状数组只有左儿子，没有右儿子。这样好像又没法做了。

其实完全可以不用考虑右儿子的存在与否。可以只用左儿子完成二分。可以像倍增一样，令 $p$ 表示当前可以确定的最小右端点，$c(x)$ 表示 $x$ 号结点在 $[l,r]$ 之间的答案，$k$ 表示我们当前要求的排名。对于 $i \in [0,\lceil\log n\rceil)$，都将 $c(p-2^i)$ 和 $k$ 比较。有两种情况：

- $c(p-2^i) \ge k$。那么就表示第 $k$ 小在左儿子中。此时需要 $p \leftarrow p-2^i$。
- $c(p-2^i) \ge k$。那么就表示第 $k$ 小在右儿子中。这时候问题就变成了“在右儿子中找到第 $k-c(p-2^i)$ 小数”，需要 $k \leftarrow k-c(p-2^i)$。

最后所得的 $p$ 就是答案。

这样我们就得到了 $O(\log^2 n)$ 的查询复杂度，得益于树状数组的优秀常数，我们可以在时限的一半以内[通过](https://www.luogu.com.cn/record/148870911)本题。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 200001

int n, m, l, r, k, d, _log;
int a[MAXN], b[MAXN];

void init(){
	memcpy(b, a, sizeof(a));
	sort(b+1, b+n+1);
	d = unique(b+1, b+n+1)-b-1;
	for (int i(1); i<=n; ++i) a[i] = lower_bound(b+1, b+d+1, a[i])-b;
}

namespace BIT{
#define lowbit(x) ((x) & -(x))
	vector<int> c[MAXN];
	void add(int x, int ind){
		while (x <= d){
			c[x].push_back(ind);
			x += lowbit(x);
		}
	}

#define tms(x) (x <= d ? upper_bound(c[x].begin(), c[x].end(), r)-upper_bound(c[x].begin(), c[x].end(), l-1) : INT_MAX)
	int query(int x){
		int pos(1<<_log);
        for (int i(_log-1); i>=0; --i){
            if (tms(pos-(1<<i)) >= x) pos -= (1<<i);
            else x -= tms(pos-(1<<i));
        }
        return pos;
	}
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	cin >> n >> m;
	for (int i(1); i<=n; ++i) cin >> a[i];
	init();
    _log = ceil(log2(d));
	for (int i(1); i<=n; ++i) BIT::add(a[i], i);

	while (m--){
		cin >> l >> r >> k;
        cout << b[BIT::query(k)] << '\n';
	}

	return 0;
}
```

---

## 作者：wjyyy (赞：9)

**主席树**，就是通过查询线段树的历史版本返回信息的可持久化线段树。可以利用之前已经有的数据来减少时空开销。

我是用指针写的，这样省去了数组下标存储的空间（但是$64$位）和下标调用访问时浪费的一点点时间。

本题有$n$个数，$m$个询问，相当于$n$次插入新结点,有$n+1$个历史版本（因为还有初始版本的空树）。

因此这个题目可以转化为第$l-1$个版本与第$r$个版本之间的线段树“差”上求第$k$值的问题，下面会解释。

而主席树因为每次改变时只会改变一条链，那么每个结点的另一条链就是上一个版本的同一条链，这样可以大大减少建树的时间上的开销以及一大堆指针的空间上的开销。从第$0$颗树，也就是空树开始，每个版本不用多开结点，直接将指针指向上一个版本就可以了。如果线段树掌握的不错的话，那么主席树的建立也就不在话下了。

**上面提到的线段树之差，其实是像前缀和一样，用$r$版本的线段树，将前面$l-1$版本的树上的数据减去，而且只减去有影响的，即更新过的，因此在查询时判断并更新就可以了。还要注意的是，并不是两个完整的树相减，因为两个树相减结果一定是$r-l+1$，要让它们的左孩子相减，如果左孩子之差$\geq k$,说明$l$到$r$之间第$k$小值在根结点的左孩子里，否则在右孩子里。**

另外还有一点，这个题目的$a_i$范围是$[-10^9,10^9]$，而数据总共只有$200,000$个，所以我们要根据大小离散化数据。不需要$hash$，只需要将其按大小顺序赋予一个映射函数就可以了。$\qquad$有两种实现方法，一是代码中的结构体$gg$,需要用到两次排序，可能慢一点；二是输入时使用两个相同的数组，只排一个序，像这样

```cpp
	for(int i=1;i<=n;i++)
	{
	    scanf("%d\n",a[i].v);
 	   a[i].t=i;//输入时间
	}
    std::sort(a+1,a+1+n);
    for(int i=1;i<=n;i++)
        b[a[i].t]=i;//将具体数值按输入时间的导入新编排的位置

```

# Code：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define mid ((l+r)>>1)
const int N=2e5+5;//200000个点
struct node
{
    int v,l,r;//v存的是当前状态下[l,r]范围内有多少个点
    node *ls,*rs;
    node()
    {
        v=0;
        ls=NULL;//因为这里置为NULL，所以调用时要为其申请空间或赋值
        rs=NULL;
    }
}*root[N];//有n个树根，申请n个根结点
struct gg
{//题解正文提到的gg结构体
    int num,o,v;//num存本来的数，order(o)存输入顺序，v存离散化的顺序
}d[N];
bool cmp1(gg a,gg b)//给各个点赋予它的离散化顺序
{
    return a.num<b.num;
}
bool cmp2(gg a,gg b)//将各个点恢复成输入顺序
{
    return a.o<b.o;
}
int n,m;
int q[N];//q[i]存的是离散点i的原本值（相当于gg的反函数）
void Build(node *root,int l,int r)//建立空树时没有前车之鉴，所以特殊建树，无论能不能满，把这棵树的叶子节点覆盖到位
{
    root->l=l;
    root->r=r;
    if(l==r)
        return;//叶子节点
    root->ls=new node();//给NULL申请新的空间
    root->rs=new node();
    Build(root->ls,l,mid);//递归建树
    Build(root->rs,mid+1,r);
}
void build(node *prer,node *root,int l,int r,int x)//preroot带的是前一棵树，因此可以依附它，并将它的左右孩子一同带入各个函数，root是要建的树，x是要添加的值
{
    root->l=l;
    root->r=r;
    if(l==r)
    {
        root->v++;//找到了要添加的值，可以返回
        return;
    }
    if(x>mid)//其他情况一直寻找知道找到要添加的值
    {
        root->rs=new node();
        root->ls=prer->ls;
        build(prer->rs,root->rs,mid+1,r,x);
        root->v=root->ls->v+root->rs->v;//从两个孩子结点回溯上来，不一定是只增加了1，因为还会从其他孩子结点更新
        return;
    }
    else
    {
        root->ls=new node();
        root->rs=prer->rs;
        build(prer->ls,root->ls,l,mid,x);
        root->v=root->ls->v+root->rs->v;
        return;
    }
}
int ask(node *prer,node *root,int k)//找第k小值并返回q中下标
{
    if(root->l==root->r)
        return root->l;
    int del=root->ls->v-prer->ls->v;//这里是重点，删树的过程，这里记录的是左孩子之间相差多少，记差值为delta
    if(del<k)//如果相差小于k，那么第k小值就在右孩子处，并且要在右孩子处找到第（k-del）小值
        return ask(prer->rs,root->rs,k-del);
    return ask(prer->ls,root->ls,k);//在左边还是找第k小值
}
int main()
{
    scanf("%d%d",&n,&m);
    int u;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&u);
        d[i].o=i;//记录输入顺序
        d[i].num=u;//原本数据
        root[i]=new node();
    }
    root[0]=new node();
    std::sort(d+1,d+n+1,cmp1);
    for(int i=1;i<=n;i++)
    {
        d[i].v=i;//记录排序后的顺序
        q[i]=d[i].num;//记录顺序对应的原数据
    }
    std::sort(d+1,d+n+1,cmp2);//没有去重，可以去重优化少量时间复杂度
    Build(root[0],1,n);//建空树
    for(int i=1;i<=n;i++)
        build(root[i-1],root[i],1,n,d[i].v);//每一个都要建树，并且传入d[i].v作为新添加的叶子节点
    int l,r,k;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&l,&r,&k);
        printf("%d\n",q[ask(root[l-1],root[r],k)]);//查询并输出
    }
    return 0;
}
```

---

## 作者：I_AM_HelloWord (赞：9)

以[1..i]的前缀建一个线段树的说法及其不准确，也许有很多初学者就在这里懵掉了。应该说是以前i个数在[1..n]中重新建立一个权值线段树，权值保存的是大小在这个区间里的数的个数，然后求第k小就是平衡树求第k的操作了。因为直接建n个线段树绝对MLE，所以要可持久化一下，就是把权值相同的同一个区间直接用指针传递一下就好了。


想更详细学习一下主席树及其拓展的可以参见我的博客：http://blog.csdn.net/no1\_terminator/article/category/6229193


其中将主席树的基础部分分成两块。自我感觉总结的还好。


参考代码（提交代码时务必将语言调成C++，而C++11会编译错误）：


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=210000;
int n,m,T_cnt;
struct Node{
    int l,r,sum;
}T[N*60];
int rank[N],root[N];
struct A{
    int x,idx;
    bool operator < (const A &rhs) const {
        return x<rhs.x;
    }
}a[N];
void insert(int &num,int &x,int l,int r){
    T[T_cnt++]=T[x];x=T_cnt-1;
    ++T[x].sum;
    if (l==r)return;
    int mid=(l+r)>>1;
    if (num<=mid)insert(num,T[x].l,l,mid);
    else insert(num,T[x].r,mid+1,r);
}
int query(int i,int j,int k,int l,int r){
    if (l==r)return l;
    int t=T[T[j].l].sum-T[T[i].l].sum;
    int mid=(l+r)>>1;
    if (k<=t)return query(T[i].l,T[j].l,k,l,mid);
    else return query(T[i].r,T[j].r,k-t,mid+1,r);
}
int main(){
    T[0].l=T[0].r=T[0].sum=0;
    root[0]=0;
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++){
        scanf("%d",&a[i].x);
        a[i].idx=i;
    }
    sort(a+1,a+n+1);
    for (int i=1;i<=n;i++)rank[a[i].idx]=i;
    T_cnt=1;
    for (int i=1;i<=n;i++){
        root[i]=root[i-1];
        insert(rank[i],root[i],1,n);
    }
    while (m--){
        int i,j,k;
        scanf("%d%d%d",&i,&j,&k);
        printf("%d\n",a[query(root[i-1],root[j],k,1,n)].x);
    }
    return 0;
}
```

---

## 作者：Soulist (赞：8)

主席树，一种支持询问历史版本的数据结构，常常用于询问历史版本。

#### 可持久化

支持询问历史版本的操作，比如询问版本$k$的状态。。。

考虑用线段树，那么就要动态开点。

如果修改操作是单点修改，那么注意到修改点$x$，只会影响到沿途$logN$个节点。。。

所以可以每次增加$logN$的节点，记录版本。

这个就是主席树辣。

**模板:**

[可持久化线段树](https://www.luogu.org/problemnew/show/P3834)

做法：

首先因为我要求的是区间$k$大，那么我肯定要建一颗权值线段树。

然后注意到线段树具有可加减性

举个例子：

比如我建立了一颗区间$1-5$的权值线段树1。假设区间$1-5$的权值分别为：

$1, 2, 3, 3, 4$

然后我又建立了一颗区间$1-8$的权值线段树2。假设区间$1-8$的权值分别为：

$1, 2, 3, 3, 4, 1, 2, 3$

那么对于权值区间$1-3$，我有线段树$1$中，出现了$4$个，线段树$2$中出现了$7$个。

那么如果我用线段树$2$减去线段树$1$，那么我就可以得出，区间:

$$[1, 8] - [ 1, 5 ] = [ 6, 8]$$

然后我们可以发现区间$6-8$中，权值为$1-3$区间的点真有$7-4 = 3$个$...$

所以我对每个点开个线段树，线段树$i$记录了$1-i$区间信息。

然后求区间$l-r$的信息就是求$[1-r] - [1 -(l-1)]$的线段树。。。

然后注意到我从$1$号点开始，假设我已经建出了$1-x$的线段树，那么如果我要建$1-(x+1)$的线段树，朴素的想法是暴力建树，但实际上注意到其实$1-x+1$的线段树只是在$1-x$的线段树中加入了一个元素$[x+1]$，也就是说每次建树可以看作一个插入元素的操作，所以按照之前讲的可持久化的思想弄，额外建出$logN$个节点即可。

然后利用线段树的可减性处理询问。

**附代码：**

```
#include<bits/stdc++.h>
using namespace std;
int read(){
    char cc = getchar(); int cn = 0, flus = 1;
    while(cc < '0' || cc > '9'){
    	if(cc == '-') flus = -flus;
        cc = getchar();
    }
    while(cc >= '0' && cc <= '9')
        cn = cn * 10 + cc - '0', cc = getchar();
    return cn * flus;
}
const int N = 2e5 + 10;
int n, m, cnt;
int rot[N], v[N], top;
struct Tree{
    int l, r, val;
}t[35 * N];
struct Node{
    int v, id;
    bool operator < (const Node& x) const{
        return v < x.v;
    }
}q[N];
void build(int &root, int ll, int rr){
    int mid = (ll + rr) / 2;
    root = ++cnt;
    if(ll == rr)
        return ;
    build(t[root].l, ll, mid);
    build(t[root].r, mid + 1, rr);
}
void insert(int &root, int ll, int rr, int x){
    int now = root;
    int lkid = t[now].l, rkid = t[now].r, mid = (ll + rr) / 2;
    int ctt = ++cnt;
    if(ll == rr && ll == x){
        t[ctt].val++, root = ctt;
        return ;
    }
    if(mid >= x)
        t[ctt].l = t[now].l, insert(t[ctt].l, ll, mid, x), t[ctt].r = t[now].r;
    else
        t[ctt].r = t[now].r, insert(t[ctt].r, mid + 1, rr, x), t[ctt].l = t[now].l;
    root = ctt;
    t[ctt].val = t[t[ctt].l].val + t[t[ctt].r].val;
}
void init(){
    sort(q + 1, q + n + 1);
    for(int i = 1; i <= n; i++)	
        v[q[i].id] = i;
    build(rot[0], 1, n);
    for(int i = 1; i <= n; i++){
    	rot[i] = rot[i - 1];
        insert(rot[i], 1, n, v[i]);  
    }
}
int query(int a, int b, int k, int ll, int rr){
    int lkid = t[t[b].l].val - t[t[a].l].val;
    int mid = (ll + rr) / 2;
    if(ll == rr && k != 0)  return ll;
    if(lkid < k)
        return query(t[a].r, t[b].r, k - lkid, mid + 1, rr);
    else
        return query(t[a].l, t[b].l, k, ll, mid);
}
void input(){
    n = read(); m = read();
    for(int i = 1; i <= n; i++) q[i].v = read(), v[i] = q[i].v, q[i].id = i;
    init();
    int opt, l, r;
    for(int i = 1; i <= m; i++){
        l = read(); r = read(); opt = read();
        int wh = query(rot[l - 1], rot[r], opt, 1, n);
        printf("%d\n", q[wh].v);
    }
    return ;
}
signed main()
{
    input();
    return 0;
}
```

---

## 作者：Tyher (赞：6)

## 有注释的代码 by zkj

```
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define il inline
#define rg register
#define ll long long
#define N 500010
#define inf 2147483647
using namespace std;

int n,m,cnt;
int u,v,k;
int rank[N];
struct Num{
	int val,idx;
}num[N];
struct Tre{
	int ls,rs,val;
}te[N*20];
//当前节点的左孩子，右孩子
//以及在当前区间的数个数
int root[N];//表示根的编号
il void re(rg int &x);
int Cmp(const Num &x,const Num &y);
void update(rg int le,rg int ri,rg int p,rg int &now){
//表示需要新建节点的le 新建节点的ri 新建节点要加入的数p
//当前所在节点位置now
//now是要随着函数改变的 因为我们需要在递归中改变节点的左右孩子
    te[++cnt]=te[now];
	//新开一个节点，并将上一版本的根节点kuai过来
	now=cnt;
	te[now].val++;
	if(le==ri)return;
	rg int mid=((le+ri)>>1);
	if(p<=mid)update(le,mid,p,te[now].ls);
	else update(mid+1,ri,p,te[now].rs);
	//同样的 我们在接下来的调用中也要改变当前节点的左孩子右孩子
	//也就是动态开点
}
//在update函数中 每次在main函数里调用我们会发现
//开点的次数为logn，因为在线段树里的单点修改都只会
//经历一次从上到下的路程，那么我们的新开线段树也就只有一条链
//仔细想想，我们会发现如果我们新开一颗线段树，那么左右孩子都会
//继承上一颗线段树的位置（te[++cnt]=te[now]）
//而此时我们加入p之后，假设递归的是左孩子，那么只有左孩子的
//值会被改动，而右孩子仍然继承的是上一颗线段树的值
//这样 空间复杂度做到了nlogn
int query(rg int le,rg int ri,rg int i,rg int j,rg int k){
//i和j都是两颗线段树的编号，版本不同而已
//但是两个节点对应的le和ri是相同的
	if(le==ri)return le;
	rg int F=te[te[j].ls].val-te[te[i].ls].val;
	rg int mid=((le+ri)>>1);
	//F表死j左孩子的值与i左孩子的值的差
	//要知道 ij对应位置相同，这里用到的是前缀和的思想
	//如果左孩子的个数差已经大于等于k了，是不是第k大就一定在左孩子中？
	if(k<=F)return query(le,mid,te[i].ls,te[j].ls,k);
	else return query(mid+1,ri,te[i].rs,te[j].rs,k-F);
	//这里要算上F的贡献
}
int main(){
	freopen("s.in","r",stdin);
	re(n),re(m);
	for(rg int i=1;i<=n;++i)
		re(num[i].val),num[i].idx=i;
	sort(num+1,num+n+1,Cmp);
	for(rg int i=1;i<=n;++i)
		rank[num[i].idx]=i;
	//值域线段树的离散化
	//rank[i]表示编号为i的数的排名大小
	//也就是离散化之后的值
	for(rg int i=1;i<=n;++i){
		root[i]=root[i-1];
		//将上一颗树的节点编号暂时赋值过来
		update(1,n,rank[i],root[i]);
		//新建一颗从1到n的线段树
		//我们要加入的值为标号i的离散化后的值
		//从root[i]开始加入
	}
	for(rg int i=1;i<=m;++i){
		re(u),re(v),re(k);
		printf("%d\n",num[query(1,n,root[u-1],root[v],k)].val);
	}
	//对与左右端点u和v的区间查询第k大
	//那么我们只要知道它离散化过后的值就可以了
	//注意num是已经sort过后的 所以可以直接用num[p]代表排名为p的值
	//我们要找u到v的区间，是不是就是1到(u-1)和1到v所新增的数中排名为p的数？
	return 0;
}

il void re(rg int &x){
    rg int res=0;rg int w=1;char c=getchar();
    while((c<'0'||c>'9')&&c!='-')c=getchar();
    if(c=='-')w=-1,c=getchar();
    while(c>='0'&&c<='9')res=(res<<3)+(res<<1)+c-'0',c=getchar();
    x=w*res;
}
int Cmp(const Num &x,const Num &y){
	return x.val<y.val;
}

```

---

## 作者：Sai0511 (赞：5)

主席树模板题。       
首先我不认为这是什么很高级的数据结构，如果你已经对线段树掌握的很熟练的话应该不难理解主席树。
### 正文部分：                     
主席树一般用来解决静态区间的第$k$小问题。       
#### 原理：   
首先我们可以在纸上画一张空的线段树。然后我们加入某个节点的时候你们就在纸上与这个节点所相关的节点的值就加$1$。       
比如我们加入了值$1$,那么受到影响的区间就有:$[1,7],[1,4],[1,2],[1,1]$                       
好，当我们把所有的点都加完了之后，接下来就要解决第$k$小的问题。    
先假设我们查的区间为$[l,r]$那么我们就将第$l$颗线段树与第$r$颗线段树相减。其中所有节点所得的差就是某段区间里的值得个数。         
然后我们就可以查了。如果某段区间中的值得个数大于$k$,我们就往左子树走，否则就减掉左子树，然后往右子树走。   
### My Code:
```cpp
#include <bits/stdc++.h>
#define il inline
const int MAXN = 2e5 + 10;
using namespace std;   
int n,m,i,j,k,cnt;
int a[MAXN],lsh[MAXN];
int num[MAXN << 5],l[MAXN << 5],r[MAXN << 5],sum[MAXN << 5];
template<typename T> il void read(T& res) {
    res = 0;char c;bool sign = 0;
    for(c = getchar();!isdigit(c);c = getchar()) sign |= c == '-';
    for(;isdigit(c);c = getchar()) res = (res << 1) + (res << 3) + (c ^ 48);
    (sign) && (res = -res);
    return;
}
int build(int l,int r) {
    cnt++;int num = cnt;
    if(l < r) {
        int mid = l + r >> 1;
        ::l[num] = build(l,mid);
        ::r[num] = build(mid + 1,r);
    }
    return num;
}
int modify(int pre,int l,int r,int mn) {
    cnt++;int num = cnt;
    ::l[num] = ::l[pre];::r[num] = ::r[pre];::sum[num] = ::sum[pre] + 1;
    if(l < r) {
        int mid = l + r >> 1;
        if(mn <= mid) ::l[num] = modify(::l[pre],l,mid,mn);
        else ::r[num] = modify(::r[pre],mid + 1,r,mn);
    }
    return num;
}
int query(int x,int y,int l,int r,int k) {
    if(l >= r) return l;
    int tmp = ::sum[::l[y]] - ::sum[::l[x]];
    int mid = l + r >> 1;
    if(tmp >= k) return query(::l[x],::l[y],l,mid,k);
    else return query(::r[x],::r[y],mid + 1,r,k - tmp);
}
int main() {
    read(n);read(m);
    for(int i = 1;i <= n;i++) {
        read(a[i]);lsh[i] = a[i];
    }	
    sort(lsh + 1,lsh + n + 1);int _n = unique(lsh + 1,lsh + n + 1) - lsh - 1;
    num[0] = build(1,_n);
    for(int i = 1;i <= n;i++) {
        int tmp = lower_bound(lsh + 1,lsh + _n + 1,a[i]) - lsh;
        num[i] = modify(num[i - 1],1,_n,tmp);
    }
//	for(int i = 0;i <= n;i++) cout << num[i] << ' ';cout << endl;
    for(int i = 1;i <= m;i++) {
        int l,r,k;read(l);read(r);read(k);
        int tmp = query(num[l - 1],num[r],1,_n,k);        
        printf("%d\n",lsh[tmp]);
    }
    return 0;
}
```


---

## 作者：zhy12138 (赞：5)

# 前言：
主席树先决条件：线段树

# 前言和正题之间的~~BB~~题外话：
一直听闻主席树的大名，但由于LZ太菜，不敢去学。

大前天晚上宛若抽风般地睡不着，于是爬起来学主席树，结果看网上的辣鸡题解，刚到凌晨4点也没看懂

后来直接看了代码就懂了~~WTF~~

# 正题：~~WOC，竟然才开始正题~~

可持久化是指兹磁查询历史版本。

线段树需要查询历史版本，最简单的思路就是建多颗线段树，但太浪费空间~~一颗就是4倍空间你以为是假的吗~~

于是经过观察，不难发现每次修改时，只会改变点到根节点上一条链的数据。

于是我们只需要新建一条链上的点，将这些点连到树上。

也就是思路变成了这样：
![1.PNG](https://i.loli.net/2018/08/27/5b83938b21d7c.png)

有点懵？简单来说就是将两颗线段树值相同的节点合并了。

这样就可以做到O(logn)修改和查询了

----------------

区间第K大是个经典的主席树例题。

解题思路：
- 将原本a数组中的值离散化到b数组中
- 建版本0的空树，每个节点表示当前版本中b[l]~b[r]中有几个数
- 建i个版本，若a[i]对应b[j]，每个版本修改主席树中表示b[j]~b[j]的点~~有点抽象~~

```cpp
inline int xg(int pre,int l,int r,int zone)
{
	int bj=++tot;
	tree[bj].l=tree[pre].l;
	tree[bj].r=tree[pre].r; //初始化为不需要新建
	tree[bj].value=tree[pre].value+1; 
	int mid=(l+r)/2;
	if(l<r)
		if(zone<=mid)
			tree[bj].l=xg(tree[pre].l,l,mid,zone); //左儿子需要新建
		else
			tree[bj].r=xg(tree[pre].r,mid+1,r,zone); //类似
	return bj;
}
```
- 查询时用前缀和的思想相减就能得出区间内在b数组区间内的个数

```cpp
inline int cx(int from,int to,int l,int r,int k)
{
	if(l==r)
		return l;
	int x=tree[tree[to].l].value-tree[tree[from].l].value; //相减得到a数组两个端点之间的数有几个在b[l]~b[r]之间
	int mid=(l+r)/2;
	if(x>=k)    //因为要求第k小，所以判断左儿子与k的大小关系
		return cx(tree[from].l,tree[to].l,l,mid,k);
	else
		return cx(tree[from].r,tree[to].r,mid+1,r,k-x);
}
```

下面给出AC代码：

```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<iomanip>
#include<cstring>
#include<algorithm>
#include<ctime>
#define ll long long
using namespace std;
inline ll read()
{
	ll kkk=0;
	int x=1;
	char c=getchar();
	while(c<'0' || c>'9')
	{
		if(c=='-')
			x=-1;
		c=getchar();
	}
	while(c>='0' && c<='9')
		kkk=(kkk<<3)+(kkk<<1)+(c-'0'),c=getchar();
	return kkk*x;
}
int n,q,m,T[200001],tot,a[200001],b[200001];
struct sb
{
	int l,r,value;
}tree[8000001];
inline int build(int l,int r)
{
	int bj=++tot;
	tree[bj].value=0;
	int mid=(l+r)/2;
	if(l<r)
	{
		tree[bj].l=build(l,mid);
		tree[bj].r=build(mid+1,r);
	}
	return bj;
}
inline int xg(int pre,int l,int r,int zone)
{
	int bj=++tot;
	tree[bj].l=tree[pre].l;
	tree[bj].r=tree[pre].r;
	tree[bj].value=tree[pre].value+1;
	int mid=(l+r)/2;
	if(l<r)
		if(zone<=mid)
			tree[bj].l=xg(tree[pre].l,l,mid,zone);
		else
			tree[bj].r=xg(tree[pre].r,mid+1,r,zone);
	return bj;
}
inline int cx(int from,int to,int l,int r,int k)
{
	if(l==r)
		return l;
	int x=tree[tree[to].l].value-tree[tree[from].l].value;
	int mid=(l+r)/2;
	if(x>=k)
		return cx(tree[from].l,tree[to].l,l,mid,k);
	else
		return cx(tree[from].r,tree[to].r,mid+1,r,k-x);
}
int main()
{
	n=read(),q=read();
	for(register int i=1;i<=n;++i)
	{
		a[i]=read();
		b[i]=a[i];
	}
	sort(b+1,b+n+1);
	m=unique(b+1,b+n+1)-b-1;
	T[0]=build(1,m);
	for(register int i=1;i<=n;++i)
	{
		int t=lower_bound(b+1,b+1+m,a[i])-b;
		T[i]=xg(T[i-1],1,m,t);
	}
	for(register int i=1;i<=q;++i)
	{
		int l=read(),r=read(),k=read();
		int t=cx(T[l-1],T[r],1,m,k);
		printf("%d\n",b[t]);
	}
	return 0;
}
```

---

## 作者：木木！ (赞：4)

看大家都是用`主席树`做的，这里贴一篇`可持久化0/1 trie`的题解。

`0/1 trie`就是类似于我们做[最长异或路径](https://www.luogu.org/problem/P4551)的时候用的那个东西，将数字转化成二进制插到`trie`里面。每个节点维护一下数量，插入时可持久化，就能AC此题。

本质上就是可持久化动态开点权值线段树，时空复杂度$\Theta(n\log x)$，其中$x$为值域。

附AC代码：

```cpp
#include <cstdio>
using namespace std;

int readint()
{
	char ch;
	while((ch=getchar())<'0' || ch>'9')
	{
		;
	}
	int x = ch^'0';
	while((ch=getchar())>='0' && ch<='9')
	{
		x = (x*10)+(ch^'0');
	}
	return x;
}

int rt[200005];
int ch[2][8000005];
int num[8000005];
int top;

void ins(int pre,int v,int nxt)
{
	++top;
	rt[nxt] = top;
	int nxtx = top;
	int prex = rt[pre];
	for(int p=1<<30; p; p>>=1)
	{
		++top;
		int chn = !!(v&p);
		ch[chn][nxtx] = top;
		ch[!chn][nxtx] = ch[!chn][prex];
		num[ch[chn][nxtx]] = num[ch[chn][prex]]+1;
		nxtx = ch[chn][nxtx];
		prex = ch[chn][prex];
	}
}

int query(int l,int r,int k)
{
	int res = 0;
	int nowx = rt[r];
	int prex = rt[l-1];
	for(int p=1<<30; p; p>>=1)
	{
		if(num[ch[0][nowx]]-num[ch[0][prex]] < k)
		{
			k -= num[ch[0][nowx]]-num[ch[0][prex]];
			nowx = ch[1][nowx];
			prex = ch[1][prex];
			res += p;
		}
		else
		{
			nowx = ch[0][nowx];
			prex = ch[0][prex];
		}
	}
	return res;
}

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; ++i)
	{
		int x;
		scanf("%d",&x);
		ins(i-1,x,i);
	}
	
	for(int i=1; i<=m; ++i)
	{
		int l,r,k;
		scanf("%d%d%d",&l,&r,&k);
		printf("%d\n",query(l,r,k));
	}
}
```

---

## 作者：Sophon (赞：4)

# 主席树  
不带修改，静态查询区间第$\;k\;$小。

## 前置芝士：权值线段树   
&emsp;&emsp;权值线段树是维护一段值域上数的个数的线段树。每个节点的$\;l\;$和$\;r\;$表示~~一个区间~~一段值域，节点权值$\;sum\;$表示整个序列中落在值域$\;[l, r]\;$上的数的总个数。  
&emsp;&emsp;例如，有一个序列$\;\{1,1,2,3,3,3,4,4\}\;$，下图即为这个序列对应的权值线段树。   
   
![](https://i.loli.net/2019/08/10/nkszbqlFRfpjtIw.png)
 
&emsp;&emsp;根节点表示序列中值介于$\;1\sim4\;$之间共有$\;8\;$个数。根节点左孩子表示序列中值介于$\;1\sim2\;$之间共有$\;3\;$个数，其余节点含义类似。

## 正式开始  
  
### 节点定义
节点带三个信息，$\;l\;$为值域左端点，$\;r\;$为值域右端点，$\;sum\;$为值域上数的个数。$\;root[\;]\;$为每个历史版本的根节点下标。$\;a[\;]\;$为原序列。全局$\;cnt\;$为节点总个数。
```cpp
#define sum(p) t[p].sum
#define l(p) t[p].l
#define r(p) t[p].r

using namespace std;

const int N = 200000 + 10;

int cnt;

struct SegmentTree
{
	int l, r, sum;
};

SegmentTree t[N * 40];
int a[N];
int root[N];
```
### 插入新数  
$\;l, r\;$为当前访问的节点维护的值域左右端点，$\;pre\;$为插入前上一版本线段树根节点下标。$\;now\;$为当前（新的待插入）节点下标，$\;v\;$为待插入值。每次插入，先将上一版本线段树根节点拷贝过来，之后再修改发生变化的信息（即$\;sum\;$值）。然后根据$\;v\;$决定向左子树还是右子树递归修改。详见注释。附图是在刚刚的例子中新插入$\;4\;$后的情况，蓝色部分和上一版本未更改部分构成新版本线段树。
![1.png](https://i.loli.net/2019/08/10/vCB6MYbyFg1L9t4.png)
```cpp
void Insert(int l, int r, int pre, int& now, int v)
{
    //拷贝上一版本
	t[++cnt] = t[pre];
	//修改当前now为已经分配到的cnt
	now = cnt;
	//由于从上层递归来的，v一定属于当前节点控制的区间，sum++
	sum(now)++;
	//访问到了叶子节点
	if (l == r)
	{
		return;
	}
	//根据值归属左半区间还是右半区间递归修改
	int mid = (l + r) >> 1;
	if (v <= mid)
	{
		Insert(l, mid, l(pre), l(now), v);
	}
	else
	{
		Insert(mid + 1, r, r(pre), r(now), v);
	}
}
```
对应的主函数中：
```cpp
//由于权值值域太大难以维护，先离散化
//v为vector<int>
for (int i = 1; i <= n; i++)
{
	cin >> a[i];
	v.push_back(a[i]);
}
sort(v.begin(), v.end());
//去重，并删去多余，加快二分
v.erase(unique(v.begin(), v.end()), v.end());

//依次插入
for (int i = 1; i <= n; i++)
{
	Insert(1, n, root[i - 1], root[i], GetId(a[i]));
}
```
其中$\;GetId\;$函数返回离散化后的值：
```cpp
inline int GetId(int x)
{
	return lower_bound(v.begin(), v.end(), x) - v.begin() + 1;
}
```
### 查询  
$\;l, r\;$为当前访问的节点维护的值域左右端点，$\;L, R\;$为线段树历史版本对应的根节点。$\;k\;$为需要查询排第$\;k\;$的元素。
```cpp
int Ask(int l, int r, int L, int R, int k)
{
    //区间长度收缩成1，答案找到
	if (l == r)
	{
		return l;
	}
	int mid = (l + r) >> 1;
	//预先看一眼根节点左子树在两个版本之间差了多少个
	//l_size即为原序列待查询区间中值介于[l(R),r(R)]之间的数个数
	//类似于前缀和
	int l_size = sum(l(R)) - sum(l(L));
    //左子树过大
	if (k <= l_size)
	{
	    //往左子树收缩区间继续查询，参数l(L), l(R)保证了同步访问两个历史版本线段树
	    //即每次参数L和R都维护着同一段值域
		return Ask(l, mid, l(L), l(R), k);
	}
	//左子树不够
	else
	{
	    //同理，往右子树收缩查询范围
		return Ask(mid + 1, r, r(L), r(R), k - l_size);
	}
}
```
对应的主函数：
```cpp
for (int i = 1; i <= m; i++)
{
	int l, r, k;
	cin >> l >> r >> k;
	//类似于前缀和的做法，传入第l-1版和第r版的根节点作为L和R的实参
	cout << v[Ask(1, n, root[l - 1], root[r], k) - 1] << endl;
}
```
## 做法概述 
&emsp;&emsp;建一棵空树，扫描序列，每次动态开点，插入扫描到的新数，同时保留插入前历史版本信息。    
&emsp;&emsp;对于每次询问，找到区间对应的两个历史版本线段树，同步地访问两棵树的节点，根据节点保存的$\;sum\;$值（即对应值域上数个数）向下层递归查找。

附送~~高清无码~~AC程序。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

#define sum(p) t[p].sum
#define l(p) t[p].l
#define r(p) t[p].r

using namespace std;

const int N = 200000 + 10;

int cnt;

struct SegmentTree
{
	int l, r, sum;
};

SegmentTree t[N * 40];
int a[N];
int root[N];

void Insert(int l, int r, int pre, int& now, int v)
{
	t[++cnt] = t[pre];
	now = cnt;
	sum(now)++;
	if (l == r)
	{
		return;
	}
	int mid = (l + r) >> 1;
	if (v <= mid)
	{
		Insert(l, mid, l(pre), l(now), v);
	}
	else
	{
		Insert(mid + 1, r, r(pre), r(now), v);
	}
}

int Ask(int l, int r, int L, int R, int k)
{
	if (l == r)
	{
		return l;
	}
	int mid = (l + r) >> 1;
	int l_size = sum(l(R)) - sum(l(L));

	if (k <= l_size)
	{
		return Ask(l, mid, l(L), l(R), k);
	}
	else
	{
		return Ask(mid + 1, r, r(L), r(R), k - l_size);
	}
}

vector<int> v;

inline int GetId(int x)
{
	return lower_bound(v.begin(), v.end(), x) - v.begin() + 1;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, m;
	cin >> n >> m;

	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
		v.push_back(a[i]);
	}
	sort(v.begin(), v.end());
	v.erase(unique(v.begin(), v.end()), v.end());

	for (int i = 1; i <= n; i++)
	{
		Insert(1, n, root[i - 1], root[i], GetId(a[i]));
	}

	for (int i = 1; i <= m; i++)
	{
		int l, r, k;
		cin >> l >> r >> k;
		cout << v[Ask(1, n, root[l - 1], root[r], k) - 1] << endl;
	}
}
```

---

## 作者：nth_element (赞：3)

想要更丰富的展示，请点击[我的博客](https://www.cnblogs.com/nth-element/p/11785026.html)

***

若想要深入学习主席树，[传送门]( https://www.cnblogs.com/nth-element/p/11755820.html )。

***

**Description**:

给定数列 $\{a_n\}$ ,求闭区间 $[l,r]$ 的第 $k$ 小的数。

**Method**:

先对数据进行离散化，然后按照权值建立线段树。

若要寻找 $[1,p]$ 的第 $k$  小，则从根节点开始处理。定义$Son_{left}$ 表示左儿子的集合，$Son_{right}$ 表示右儿子的集合。若 $|Son_{left}|\ge k$ 时，说明第$k$小的数在左子树中，以左儿子为新的根向下递归更新，寻找左子树中第 $k$ 小的数；反之，说明第$k$小的数在右子树中，以左儿子为新的根向下递归更新，寻找左子树中第 $k-|Son_{left}|$ 小的数。

拓展一下，我们先预处理建树，得到 $n+1$ 个版本的线段树（包括初始的线段树），编号为 $0 \sim n$ 。

前文提到过，主席树满足前缀和查询的思想，故我们要求 $[l,r]$ 的第 $k$ 小值，即可用`sum[r]-sum[l-1]`。

**Code**:

```cpp
#include<bits/stdc++.h>
#define int long long 
#define Maxn 200010
using namespace std;
inline void read(int &x)
{
    int f=1;x=0;char s=getchar();
    while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
    while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
int n,m;
struct Segtree
{
    int ls,rs,sum;
}tree[Maxn<<5];
int rt[Maxn];
int a[Maxn],ins[Maxn]; 
int len,tot=0;
inline void Init(){tot=0;}
inline int getid(const int &x)
{
    return lower_bound(ins+1,ins+len+1,x)-ins;
}
inline void pushup(int rt)
{
    tree[rt].sum=tree[tree[rt].ls].sum+tree[tree[rt].rs].sum;
}
inline int build(int l,int r)
{
    int rt=++tot;
    if(l==r) 
    {
        tree[rt].sum=0;
        return rt;
    }
    int mid=(l+r)/2;
    tree[rt].ls=build(l,mid);
    tree[rt].rs=build(mid+1,r);
    pushup(rt);
    return rt;
}
int update(int k,int l,int r,int root,int val)
{
    int rt=++tot;
    tree[rt]=tree[root];
    if(l==k&&r==k)
    {
        tree[rt].sum+=val;
        return rt;
    }
    int mid=(l+r)/2;
    if(k<=mid) tree[rt].ls=update(k,l,mid,tree[rt].ls,val);
    else tree[rt].rs=update(k,mid+1,r,tree[rt].rs,val);
    pushup(rt);
    return rt;
}
int query(int u,int v,int l,int r,int k)
{
    if(l==r) return l;
    int mid=(l+r)/2,x=tree[tree[v].ls].sum-tree[tree[u].ls].sum;
    if(k<=x) return query(tree[u].ls,tree[v].ls,l,mid,k);
    else return query(tree[u].rs,tree[v].rs,mid+1,r,k-x);
}
signed main()
{
    Init();
    read(n),read(m);
    for(int i=1;i<=n;i++)
    {
        read(a[i]);
    }
    memcpy(ins,a,sizeof(ins));
    sort(ins+1,ins+n+1);
    len=unique(ins+1,ins+n+1)-ins-1;
    rt[0]=build(1,len);
    for(int i=1;i<=n;i++)
    {
        rt[i]=update(getid(a[i]),1,len,rt[i-1],1);
    }
    while(m--)
    {
        int l,r,k;
        read(l),read(r),read(k);
        printf("%lld\n",ins[query(rt[l-1],rt[r],1,len,k)]);
    }
    return 0;
}
```

**Warning**:

   - `ls[]`,`rs[]`,`sum[]`等数组都要乘上 $2^5$ 。
   - 离散化取`lower_bound`时，是最后减去0开头的地址，而不是1开头的地址。（即是`lower_bound(ins+1,ins+n+1,x)-ins`，而不是`lower_bound(ins+1,ins+n+1,x)-ins-1`）
   - 查询时递归右子树时查找第 $k-|Son_{left}|$ 小，而不是 $k$ 小。



---

## 作者：resftlmuttmotw (赞：3)

## 模板介绍

### 基础要求

- 线段树

- 能灵活运用 线段树

- 前缀和,差分

### 概念

- 可持久化:在某个历史版本上更改；查询某个历史版本上的值

### 引入

[洛谷P3919 可持久化数组](https://www.luogu.org/problem/P3919)

这道可持久化线段树的题 大概就是单点修改&单点查询

代码大致就是在线段树的基础上改变她存点的方式


以前
```cpp
tree[k].l == k << 1

tree[k].r == k << 1 | 1
```

对于可持久化线段树

```cpp
tree[k].l != k << 1

tree[k].r != k << 1 | 1
```

```cpp
inline int tree_build(int k,int l,int r)
{
	k = ++cnt;
    
   每次这样来存点 但l和r仍然保留 表示一个递归和原序列位置的过程
	if(l == r)
	{
		tree[k].val = seq[l];
		return k;
	}
	int mid = l + r >> 1;
	tree[k].l = tree_build(tree[k].l,l,mid);
	tree[k].r = tree_build(tree[k].r,mid + 1,r);
	return k;
}
```

大概酱紫
```cpp
#include <map>
#include <cstdio>
#include <iostream>
using namespace std;
#define reg register int
#define isdigit(x) ('0' <= (x)&&(x) <= '9')
template<typename T>
inline T Read(T Type)
{
	T x = 0,f = 1;
	char a = getchar();
	while(!isdigit(a)) {if(a == '-') f = -1;a = getchar();}
	while(isdigit(a)) {x = (x << 1) + (x << 3) + (a ^ '0');a = getchar();}
	return x * f;
}
const int MAXN = 1e6 + 10;
int seq[MAXN],root[MAXN],cnt,tot;
struct node
{
	int l,r,val;
}tree[MAXN * 13];
inline int tree_build(int k,int l,int r)
{
	k = ++cnt;
	if(l == r)
	{
		tree[k].val = seq[l];
		return k;
	}
	int mid = l + r >> 1;
	tree[k].l = tree_build(tree[k].l,l,mid);
	tree[k].r = tree_build(tree[k].r,mid + 1,r);
	return k;
}
inline int update(int k,int l,int r,int pos,int v)
{
	tree[++cnt] = tree[k];
	k = cnt;
	if(l == r)
	{
		tree[k].val = v;
		return k;
	}
	int mid = l + r >> 1;
	if(pos <= mid) tree[k].l = update(tree[k].l,l,mid,pos,v);
	else tree[k].r = update(tree[k].r,mid + 1,r,pos,v);
	return k;
}
inline int query(int k,int pos,int l,int r)
{
	if(l == r) return tree[k].val;
	int mid = l + r >> 1;
	if(pos <= mid) return query(tree[k].l,pos,l,mid);
	return query(tree[k].r,pos,mid + 1,r);
}
int main()
{
	int n = Read(1),m = Read(1);
	for(reg i = 1;i <= n;i++)
		seq[i] = Read(1);
	root[tot] = tree_build(1,1,n);
	while(m--)
	{
		int v = Read(1),sit = Read(1),loc = Read(1);
		if(sit & 1)
		{
			int value = Read(1);
			root[++tot] = update(root[v],1,n,loc,value);
		} else {
			int ans = query(root[v],loc,1,n);
			root[++tot] = root[v];
			printf("%d\n",ans);
		}
	}
    return 0;
}
```

### 真正的板子题

针对会主席树的同学

看看我写的思路 应该就可以秒懂了


[P3834 可持久化线段树 1](https://www.luogu.org/problem/P3834)

建权值线段树

![](https://s2.ax1x.com/2019/10/15/K9OfJJ.png)

如图 每个点的权值为$[a,b]$的数值个数

样例输入
```cpp
5 5
25957 6405 15770 26287 26465 
2 2 1
3 4 1
4 5 1
1 2 2
4 4 1
```

数据很大 (−$10^9$≤$a_i$≤$10^9$)想到离散化

```cpp
int len = unique(seq + 1,seq + 1 + n) - seq - 1;
	for(reg i = 1;i <= n;i++)
		int it = lower_bound(seq + 1,seq + 1 + len,past_a[i]) - seq;
```
#### $Firstly$

查询思路

很容易理解 对于一个询问$[a,b]$

我们先求$[1,b]$中有多少个数值

再求$[1,a - 1]$中的数值个数

每一个节点的权值对应相减

得到的就是$[a,b]$中的数值个数


因为我们建立的是权值线段树

所以一个节点$*p$ 

如果$k$（第$k$小值）≤ $*p->val$

向左子树查找

反之向右

直到$l == r$

找到了第$k$小值$hash$(离散化)后的值

离散化时 用一个下标(离散化)后的值对应 原值的数组

就可以输出了

#### $Secondly$

查询要点

我们先求$[1,b]$中有多少个数值

再求$[1,a - 1]$中的数值个数

每一个节点的权值对应相减

这个操作明显复杂且难以实现 时间复杂度也不能保证

我们便考虑每次$query$时传两个（同时做两个线段树的操作）

```cpp
inline int query(int a,int b,int k,int l,int r)
{
	if(l == r) return l;
	int x = tree[tree[a].l].val - tree[tree[b].l].val;
	int mid = l + r >> 1;
	if(k <= x) return query(tree[a].l,tree[b].l,k,l,mid);
	return query(tree[a].r,tree[b].r,k - x,mid + 1,r);
}
```

#### $Thirdly$

修改

最开始是空树

每次添点时把她当做一种新的历史状态

直接用主席树维护

#### $Code$

```cpp
#include <map>
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
#define reg register int
#define isdigit(x) ('0' <= (x)&&(x) <= '9')
template<typename T>
inline T Read(T Type)
{
	T x = 0,f = 1;
	char a = getchar();
	while(!isdigit(a)) {if(a == '-') f = -1;a = getchar();}
	while(isdigit(a)) {x = (x << 1) + (x << 3) + (a ^ '0');a = getchar();}
	return x * f;
}
const int MAXN = 2e5 + 10;
int seq[MAXN],root[MAXN << 5],past_a[MAXN],cnt,tot;
struct node
{
	int l,r,val;
}tree[MAXN << 5];
inline int tree_build(int k,int l,int r)
{
	k = ++cnt;
	if(l == r) return k;
	int mid = l + r >> 1;
	tree[k].l = tree_build(tree[k].l,l,mid);
	tree[k].r = tree_build(tree[k].r,mid + 1,r);
	return k;
}
inline int update(int k,int l,int r,int pos)
{
	tree[++cnt] = tree[k];
	k = cnt;
	tree[k].val++;
	if(l == r) return k;
	int mid = l + r >> 1;
	if(pos <= mid) tree[k].l = update(tree[k].l,l,mid,pos);
	else tree[k].r = update(tree[k].r,mid + 1,r,pos);
	return k;
}
inline int query(int a,int b,int k,int l,int r)
{
	if(l == r) return l;
	int x = tree[tree[a].l].val - tree[tree[b].l].val;
	int mid = l + r >> 1;
	if(k <= x) return query(tree[a].l,tree[b].l,k,l,mid);
	return query(tree[a].r,tree[b].r,k - x,mid + 1,r);
}
int main()
{
	int n = Read(1),m = Read(1);
	for(reg i = 1;i <= n;i++)
		past_a[i] = seq[i] = Read(1);
	sort(seq + 1,seq + 1 + n);
	int len = unique(seq + 1,seq + 1 + n) - seq - 1;
	root[tot] = tree_build(1,1,len);
	for(reg i = 1;i <= n;i++)
	{
		int it = lower_bound(seq + 1,seq + 1 + len,past_a[i]) - seq;
		root[i] = update(root[i - 1],1,len,it);
	}
	while(m--)
	{
		int l = Read(1),r = Read(1),k = Read(1);
		int ans = query(root[r],root[l - 1],k,1,len);
		printf("%d\n",seq[ans]);
	}
    return 0;
}
```

### 习题

[$SP11470 TTM - To the moon$](https://www.luogu.org/problem/SP11470)

$Code$

```cpp
#include <map>
#include <cstdio>
#include <iostream>
using namespace std;
#define reg register int
#define isdigit(x) ('0' <= (x)&&(x) <= '9')
template<typename T>
inline T Read(T Type)
{
	T x = 0,f = 1;
	char a = getchar();
	while(!isdigit(a)) {if(a == '-') f = -1;a = getchar();}
	while(isdigit(a)) {x = (x << 1) + (x << 3) + (a ^ '0');a = getchar();}
	return x * f;
}
const int MAXN = 1e5 + 10;
int seq[MAXN],root[MAXN],cnt,tot;
typedef long long ll;
struct node
{
	int l,r;
	ll val,tag;
}tree[MAXN << 6];
inline int tree_build(int k,int l,int r)
{
	k = ++cnt,tree[k].tag = 0;
	if(l == r) {tree[k].val = seq[l];return k;}
	int mid = l + r >> 1;
	tree[k].l = tree_build(tree[k].l,l,mid);
	tree[k].r = tree_build(tree[k].r,mid + 1,r);
	tree[k].val = tree[tree[k].l].val + tree[tree[k].r].val;
	return k;
}
inline int update(int k,int l,int r,int L,int R,ll v)
{
	tree[++cnt] = tree[k],k = cnt;
	tree[k].val += (R - L + 1) * v;
	if(L == l&&r == R) {tree[k].tag += v;return k;}
	int mid = l + r >> 1;
	if(R <= mid) tree[k].l = update(tree[k].l,l,mid,L,R,v);
	else if(mid < L) tree[k].r = update(tree[k].r,mid + 1,r,L,R,v);
	else tree[k].l = update(tree[k].l,l,mid,L,mid,v),tree[k].r = update(tree[k].r,mid + 1,r,mid + 1,R,v);
	return k;
}
inline ll query(int k,int l,int r,int L,int R,ll tot)
{
	if(l == L&&r == R) return tree[k].val + (r - l + 1) * tot;
	int mid = l + r >> 1;
	if(R <= mid) return query(tree[k].l,l,mid,L,R,tot + tree[k].tag);
	if(mid < L) return query(tree[k].r,mid + 1,r,L,R,tot + tree[k].tag);
	ll k1 = query(tree[k].l,l,mid,L,mid,tot + tree[k].tag),k2 = query(tree[k].r,mid + 1,r,mid + 1,R,tot + tree[k].tag);
	return k1 + k2;
}
int main()
{
	int n = Read(1),m = Read(1),pre = 0;
	for(reg i = 1;i <= n;i++)
		seq[i] = Read(1);
	root[tot] = tree_build(1,1,n);
	while(m--)
	{
		char sit = getchar();
		while(sit != 'C'&&sit != 'H'&&sit != 'B'&&sit != 'Q') sit = getchar();
		if(sit == 'C')
		{
			int l = Read(1),r = Read(1),d = Read(1);
			root[pre + 1] = update(root[pre],1,n,l,r,d * 1ll);
			pre++;
		} 
		if(sit == 'Q')
		{
			int l = Read(1),r = Read(1);
			ll ans = query(root[pre],1,n,l,r,0ll);
			printf("%lld\n",ans);
		}
		if(sit == 'H')
		{
			int l = Read(1),r = Read(1),t = Read(1);
			ll ans = query(root[t],1,n,l,r,0ll);
			printf("%lld\n",ans);
		}
		if(sit == 'B') pre = Read(1);
	}
    return 0;
}
```

---

## 作者：maomao (赞：3)

### 前置技能 :
- 线段树
- 前缀和
- 树状数组
- ~~一双打上百行代码不抖的手~~

>对一些名词的解释：

>权值线段树 : 一种线段树,其叶子节点代表了一个数组中的权值.

>主席树&可持久化权值线段树 : 关于名称的问题详见[「主席树」和「可持久化线段树」有什么区别？](https://www.zhihu.com/question/59195374). ~~顾名思义~~蒟蒻看来 , 这是一种可以支持访问权值线段树历史版本的数据结构 , 其中每一个历史版本在搜索过程中都是一棵**完整的权值线段树** . 每一个历史版本的区别在于一些权值(叶子节点)所在的路径上的一些数据可能改变.

## 例 1[Luogu P3834 【模板】可持久化线段树 （主席树）](https://www.luogu.org/problemnew/show/P3834):

>题目大意 : 给定N个整数构成的序列 , 将对于指定的M个闭区间查询其区间内的第K小值。查询以(l,r,k)的形式给出 , 其意义是**闭区间**`[l,r]`的第k大的权值 . 所给的序列可能重复 , a∈`[-1e9,1e9]`.n,m<=2e5.

### 变量预警:
 - tot : 表示新建的点的序号(避免重复)
 - T[i] : 表示第i个版本的**根节点**的点序号(便于存储,只存T[i]一个值就可以从整棵树上搜索)
 - ls[i]/rs[i] : 表示i号点的左/右儿子(**Warning** : 叶子节点的左右儿子无意义)
 - sum[i] : 表示一个非叶子节点的子树权值和.(便于询问时决定去左子树还是右子树)
 - a[i] : 初始序列数组
 - b[i] : 离散&去重后的数组
 - po : b数组的元素个数[1,po]
 
这是一道经典的主席树板子题(静态区间第k小) , 通常的做法是先将所给序列进行离散后建权值线段树 . 因为权值线段树的叶子节点数一般是离散化后的值域 , 所以最坏的情况下可以达到n . 

在离散之后 , 从1到n遍历 , **把a[i]在离散&去重 数组b中的位置`pos`算出来** , 此时的`pos`就对应了一个权值线段树的一个叶子节点 . 利用线段树的二分性 , 即由于有`pos`的限制 , 当前节点的只需要新建左右儿子中的一个 , 所以我们可以在 **O(log n)** 的时间内到达目标位置**并在其路径上**进行修改 . 修改时要把所有`sum[当前节点]`改为`sum[上一版本相同位置]+1` , 这里`sum[i]`的意义是以i为根的子树的大小(权值和).

现在的问题在于如何建树/修改 , 以达到节省空间、时间的目的 ? 感性地思考 , 我们可以把(1->n)所有的T[i]从空树上进行修改 , 这样我们只需要新开空间复杂度为 **O(log n)** 的空间 , 空间大大宽裕 ,不必担心爆空间的现象 . 然而 , 对于查询操作 , 我们需要将`[l,r]`中的T[i]代表的树中的sum全部相加才能得到其对应的sum状态 , 而这个时间复杂度是 **O(n log n)** 的 , 导致总时间复杂度 **O(n^2 log n)** 爆了时限.

换一种方法 , 我们可以将T[i]在T[i-1]的基础上新建 , 而T[i]代表的这一棵树在T[i-1]上的变动也仅仅是在搜索 pos 的一整条路径上 , 就像上面一样只需要新开 空间复杂度为 **O(log n)** 的空间 . 不同的是此时我们建成了一个**前缀和**的结构 , 只需要用`T[r]-T[l-1]`就可以表示出`[l,r]`的`sum`状态.

对于查询 , 我们可以从T[r]和T[l-1]开始(对于版本的定义,T[i]所代表的是**版本i的树的树根**) , 计算当前同步下传的节点的**左子树**的`sum`差值x , 每次比较 x 和 k , 决定向左子树走还是右子树走.

## 详细Code解释:
### 关于建树:
```cpp
int build(int l,int r)
{
    int now=++tot,mid=(l+r)>>1;
    if(l^r)//如果当前的区间左右端点不同
    {
        lc[now]=build(l,mid);
        rc[now]=build(mid+1,r);
    }
    return now;//本人喜欢这种返回值的流派,不过也有引用的写法.
}
T[0]=build(1,n1);
```

### 关于修改:
```cpp
int modify(int root,int l,int r)
{
    int now=++tot,mid=(l+r)>>1;
    lc[now]=lc[root];rc[now]=rc[root];sum[now]=sum[root]+1;
    //为了压行,先行给lc和rc赋值,避免繁琐的if 
    if(!(l^r))return now;//如果l==r,"建"好就收 
    if(pos<=mid)lc[now]=modify(lc[root],l,mid);
    //pos只会向一边走,保证了时间&空间复杂度 
    /*
	注意:在这里有dalao写"lc[now]=modify(lc[now],l,mid)",
		两种写法的结果相同,但从本质出发,我觉得还是我的
		符合定义. 
	*/ 
    else rc[now]=modify(rc[root],mid+1,r);
    return now;
}

for(int i=1;i<=n;++i)
{
    pos=lower_bound(b+1,b+po+1,a[i])-b;
    //这一句话的意思是找到a[i]在b数组中的位置
    T[i]=modify(T[i-1],1,po);
    //以T[i-1]为蓝本修改T[i]
}
```
不懂`lower_bound`的来这里:[关于lower_bound( )](https://blog.csdn.net/qq_40160605/article/details/80150252)

### 关于查询:
```cpp
int query(int u,int v,int l,int r,int k)
{
    int mid=(l+r)>>1,x=sum[lc[v]]-sum[lc[u]];
    //x表示当前两节点左子树的sum差 
    if(!(l^r))return l;//如果l==r说明已经搜到了结果 
    if(k<=x)return query(lc[u],lc[v],l,mid,k);
    //用x的值确定k走的方向 
    else return query(rc[u],rc[v],mid+1,r,k-x);
    //注意:这里应该是"k-x",意思是如果在左边找不到, 
	//就在右边找 k-x小的数
}
```
### 总复杂度分析 : 
- 查询: 空间    `--`      时间 `O(log n)`
- 修改: 空间 `O(log n)`   时间 `O(log n)`
- 建树: 空间 `O(n*log n)` 时间 `O(n*log n)`
- 总时间 : `O((n+m)*log n)`
- 总空间 : `O((n+m)*log n)`

## 例 2[Luogu P2617 Dynamic Rankings](https://www.luogu.org/problemnew/show/P2617):

>题目大意 : 给定N个整数构成的序列 , 将给出M个操作,操作1: 查询一个区间内的第K小值。查询以(l,r,k)的形式给出 , 其意义是**闭区间**`[l,r]`的第k大的权值 . 操作2: 将 a[i]替换成另一个值 . 所给的序列可能重复 , a∈`[-1e9,1e9]`.n,m<=1e5.

观察题意 , 我们发现这就是要我们打一个可以支持修改的主席树(动态区间第k大) . 同上所述 , 我们静态区间保证 时&空复杂度 用了一种 **前缀和** 的方式 , 即将`T[i]`所代表的权值线段树视为一种**区间装态** , 用处理数组的办法进行一些操作. 我们学习过 **前缀和** , 所以明白朴素的前缀和是一个 **查询O(1),修改O(n)** 的操作 , 在静态区间第k大中表现良好 , 但对于一次修改 , 我们需要将其后的所有版本全部修改一遍 , 造成的时间复杂度达到 `O(n*log n)` , 对于m次的修改 , 这一复杂度可能达到 `O(n*m*log n)` 的级别 . 此时 , 我们可以使用另一种数据结构来维护这种状态序列 : **树状数组** . 朴素的树状数组有 **查询O(log n),修改O(log n)** 的良好性质 , 在应用树状数组处理状态时可以把复杂度降低到一个可以接受的程度.
### 总复杂度分析 : `O(n*log n*log n)`

---

## 作者：Npse_D (赞：3)

临近NOIP2018，在复习数据结构的时候，我给我以前写过的代码写一遍注释，重新思考一下他们在代码上实现原理。

偏重于码的实现。至于数学原理其他大佬的题解就讲的很清楚。而我的题解可以与大家一起写一棵主席树。每一句话我都有注释。不会存在任何方面的不理解~

建议阅读顺序：数组和变量的定义-->主函数-->功能函数。
```
#include<bits/stdc++.h>
#define mid (l+r)/2//使用define定义mid，减少代码量。
using namespace std;
int n,m,cnt,L[20200000],R[20200000],sum[20200000],a[200100],b[200100],T[2000100],lon;
//L,R：编号为i的节点的左或右节点是多少。sum：当前节点掌握区间的元素总量
//a：原数组，b：用来乱搞的备份原数组，T：第i次插入后整区间的编号 
//cnt:目前的节点总个数 
int build(int l,int r){
    int rt=++cnt;//每次要建立一个新节点的时候，让rt=++cnt即可 
    sum[rt]=0;//当前还未加入任何一个元素，sum值全部初始化为0 
    if(l<r){
        L[rt]=build(l,mid);//递归地去处理左右儿子，为他们赋节点编号。 
        R[rt]=build(mid+1,r);
    }
    return rt;//返回的是节点编号，可能会用来赋值L,R,T数组。 
} 
int updata(int pre,int l,int r,int x){//插入一个元素的操作 
    int rt=++cnt; //同理，只要建立新节点，就做这样的操作。 
    L[rt]=L[pre],R[rt]=R[pre],sum[rt]=sum[pre]+1;//该点尽量多地使用他历史节点的信息。
	//方法是直接将历史节点的指针用来赋值新点指针。sum+1的原因是插入了一个新的元素，必然会++。 
    if(l<r)if(x>mid)R[rt]=updata(R[pre],mid+1,r,x);//有些L，R的历史信息不能直接使用，毕竟在前面有一个元素插入了嘛。 
    else L[rt]=updata(L[pre],l,mid,x);
    //所以我们递归地去处理可能有变化的历史节点，方案是建立一串新的节点，他们的sum都是原来加1，同样要把之前直接赋值的指针改成正确的指针。 
	//一定是一串节点。考虑线段树的形态。插入一个点的话，会有logN个节点受影响。 
    return rt;//返回的是当前区间的编号，可能用来更新L,R,T。 
}
int query(int u,int v,int l,int r,int k){//这个操作是用来求第k大元素在b数组中下标的~
    if(l==r)return l;//这个操作的实现过程是不断地缩小第k大可能存在的范围。当范围缩小到l=r也就是只有一个点，这个店一定是第k大 
    int x=sum[L[v]]-sum[L[u]];//如何来缩小范围： 考虑当当前区间的前一半区间的元素个数的差已经大于等于k了，那么第k大一定在前面一半区间内 
    if(x>=k)return query(L[u],L[v],l,mid,k);//于是可以再把区间变成前一半区间，递归调用 
    else return query(R[u],R[v],mid+1,r,k-x);//反之，如果k比x要大，就一定在后一半区间里面惹，那么我们去找后一半区间的第k-x大元素就好了。 
}
/*
	  首先，需要明确，主席树是一颗权值线段树。每一段区间[l,r]的求和代表[l,r]的数一共出现了几次。 
*/
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)b[i]=a[i];//拷贝一份新数组。因为a还要在下面用来查询rank。 
    sort(b+1,b+n+1);
    lon=unique(b+1,b+n+1)-b-1;//lon是b中不同数字的个数。这一步将b数组去重了。注意这里要减去b的地址还要减1. 
    T[0]=build(1,lon);//T[0]就是初始整区间编号。T[i]代表插入i个元素后的整区间编号。 
    for(int i=1;i<=n;i++){
        int t=lower_bound(b+1,b+lon+1,a[i])-b;//类离散化地存主席树，t：b的rank 
        T[i]=updata(T[i-1],1,lon,t);//一个数一个数地加入主席树。 
    }
    for(int i=1;i<=m;i++){
        int x,y,z;
        cin>>x>>y>>z;
        cout<<b[query(T[x-1],T[y],1,lon,z)]<<endl;//直接输出答案就好啦。 
    }
}
```

---

## 作者：Nero_Claudius (赞：3)

可持久化线段树的前置知识是权值线段树，但是你不学也没有太大的关系因为思想不是很难理解。

------------

可持久化线段树支持历史记录查询，这是它赖以解题的方法。

在本题中思路是建立n颗线段树，然后对于每次询问，考虑其中两颗：由于这n颗线段树的结构都一样，而且区间是可以加减的，所以我们将它们相减，再搜一下就可以得到第K大了。

------------

我们每一颗线段树，维护的是元素在区间中出现的次数。

假如直接建n颗树，空间不能接受，因此我们可以考虑简化。可以发现，这些区间都是[1,i]的形式，因此左半部分事实上都是相同的，每一次建立新的树我们只用右半部分新建，重复利用左半部分即可，这样的话空间就可以接受了。

------------

### 重要变量

```cpp
int a[N],b[N],T[N];
int sum[N*DEPTH],L[N*DEPTH],R[N*DEPTH];
```

a数组是题目给出的数组。

b数组是经过排序去重之后的数组。

T数组储存每一颗线段树的根节点（和普通线段树不一样，可持久化线段树的建树和更新都有返回值）。

sum数组就是区间中数的个数。

L和R表示左儿子与右儿子。

------------

### 建树

```cpp
inline int build(int l,int r){
	int pos=tot++,mid=(l+r)>>1;
	if(l<r){
		build(l,mid),build(mid+1,r);
	}
	return pos;
}
```

首先先新建节点，然后递归建树，没什么好讲的。

注意函数末尾返回新建节点的编号（用于T数组的赋值）。

------------

### 更新

```cpp
inline int update(int l,int r,int v,int pre){
	int pos=tot++,mid=(l+r)>>1;
	L[pos]=L[pre],R[pos]=R[pre],sum[pos]=sum[pre]+1;
	if(l<r){
		if(v<=mid)L[pos]=update(l,mid,v,L[pre]);
		else R[pos]=update(mid+1,r,v,R[pre]);
	}
	return pos;
}
```

和普通线段树的更新相比，可持久化线段树的少了一个pos表示当前位置，多了一个pre表示之前的。

首先还是先新建一个节点（毕竟我们可持久化就是一颗颗树），然后新的这一个部分先连向之前那个节点的左右儿子。

这个时候，我们再根据更新的值去重新确定新的左右儿子。

然后最后返回节点编号（为了顶上的确定流程）。

------------

### 查询

```cpp
inline int query(int phase1,int phase2,int l,int r,int k){
	int t=sum[L[phase2]]-sum[L[phase1]],mid=(l+r)>>1;
	if(l<r){
		if(k<=t)return query(L[phase1],L[phase2],l,mid,k);
		return query(R[phase1],R[phase2],mid+1,r,k-t);
	}
}
```

查询操作比较好理解，有点像差分。

就是我们有两个版本的线段树，然后拿他们相减，一路往下找，最后拿到答案即可。

------------

然后就写完了。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std; 
namespace ElderTree{
	const qwq N=200200,DEPTH=23;
	inline qwq read(){
		qwq x=0,f=1;char c=getchar();
		for(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;
		for(;c>='0'&&c<='9';c=getchar())x=x*10+c-'0';
		return x*f;
	}
	qwq n,m,q,tot;
	qwq a[N],b[N],T[N];
	qwq sum[N*DEPTH],L[N*DEPTH],R[N*DEPTH];
	inline qwq build(qwq l,qwq r){
		qwq pos=tot++,mid=(l+r)>>1;
		if(l<r){
			build(l,mid),build(mid+1,r);
		}
		return pos;
	}
	inline qwq update(qwq l,qwq r,qwq v,qwq pre){
		qwq pos=tot++,mid=(l+r)>>1;
		L[pos]=L[pre],R[pos]=R[pre],sum[pos]=sum[pre]+1;
		if(l<r){
			if(v<=mid)L[pos]=update(l,mid,v,L[pre]);
			else R[pos]=update(mid+1,r,v,R[pre]);
		}
		return pos;
	}
	inline qwq query(qwq phase1,qwq phase2,qwq l,qwq r,qwq k){
		qwq t=sum[L[phase2]]-sum[L[phase1]],mid=(l+r)>>1;
		if(l<r){
			if(k<=t)return query(L[phase1],L[phase2],l,mid,k);
			return query(R[phase1],R[phase2],mid+1,r,k-t);
		}
	}
}
using namespace ElderTree;
qwq main(){
    n=read(),q=read();
    for(qwq i=1;i<=n;++i)a[i]=read(),b[i]=a[i];
    sort(b+1,b+n+1),m=unique(b+1,b+n+1)-1-b,T[0]=build(1,m);
    for(qwq i=1;i<=n;++i){
        qwq t=lower_bound(b+1,b+m+1,a[i])-b;
        T[i]=update(1,m,t,T[i-1]);
    }
    while(q--){
        qwq x,y,z;
        x=read(),y=read(),z=read();
        cout<<b[query(T[x-1],T[y],1,m,z)]<<endl;
    }
    return 0;
}
```

---

## 作者：枫林晚 (赞：3)

可持久化线段树，意思是可以查询历史记录的线段树。又叫主席树。我们可以通过记录不同的根节点，并在每一个更新到的节点处新建必要的节点。询问不同版本的主席树，只需要进入不同的根节点即可。

例题：

给定n,m,输入n个数组成的数列，有m个询问，每次询问l,r这个区间中，第k小的数的值。

分析：

这个题可以巧妙运用主席树来解题。

首先对数列进行离散化。

我们令线段树的每一个节点，都代表排名为[i,j]区间内数字出现的次数。

假如我们每加入一个数，就新建一棵线段树，这一刻线段树大部分信息与前一棵一致，只是新加入的一个数相关的位置的信息发生了改变。相当于第i棵线段树，都维护的是[1,i]前i个数的信息。

发现对于区间查询[l,r]来说，对于任意一个排名位置上的数，它在这个区间里出现的次数，就是第r棵线段树上出现的次数减去第l-1棵线段树上出现的次数。同理，我们也可以利用这个前缀和思想算出来当询问[l,r]时，某个排名区间[i,j]里，所有的数出现的总次数。（只需要让两个版本的线段树中的对应区间的sum值相减即可。）

这样我们将数列从1到n扫一遍，每一次都将a[i]对已经的离散化的值（即排名）的位置加上1，（常规线段树操作）但是每次新建一个版本的线段树会使时空复杂度爆炸。

然而我们发现，相邻两个版本的线段树之间记录的信息基本相差无几，重新复制一遍实在是浪费。

所以采用主席树操作，就是仅改变logn个点的情况下，新建一棵线段树。

具体的操作是：

1.常规add操作中，每新到一个旧节点，就新建一个同样的节点，lson，rson都不变，只是这个区间内维护的sum（数字出现的次数）要比之前多一个。

2.之后，再根据待加入点与mid的关系，更新新节点左二子或者右儿子。

形象的理解一下，就是在原始线段树上，从根节点开始，沿着加入这个数的路径上新建了一条线。好像贴了一层皮。

查询操作是：

1.同时处理访问两个版本的线段树，直接处理sum的差值x。

2.如果这个差值要大于等于k，则第k大的数一定在这个节点的左二子维护的位置里；反之，询问右儿子中第k-x大的数即可。

详见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10;
int cnt;
int n,m;
int id,root[N];
int a[N],b[N];
int li(int x)
{
	int k=lower_bound(a+1,a+cnt+1,x)-a;
	return k;
}
struct node{
	int ls,rs;
	int sum;
	#define ls(x) t[x].ls
	#define rs(x) t[x].rs
	#define s(x) t[x].sum
}t[18*N];
void pushup(int x)
{
	s(x)=s(rs(x))+s(ls(x));
}
void build(int x,int l,int r)
{
	//cout<<" build "<<l<<" "<<r<<" "<<x<<endl;
	if(l==r)
	{
		ls(x)=rs(x)=-1;
		s(x)=0;
		return;
	}
	int mid=(l+r)>>1;ls(x)=++id;rs(x)=++id;
	build(ls(x),l,mid);
	build(rs(x),mid+1,r);
}
int add(int x,int l,int r,int to)
{
	//cout<<" add "<<l<<" "<<r<<" "<<x<<endl;
	int now=++id;
	ls(now)=ls(x),rs(now)=rs(x),s(now)=s(x)+1;
	if(l<r)
	{
		int mid=(l+r)>>1;
		if(to<=mid) ls(now)=add(ls(x),l,mid,to);
		else rs(now)=add(rs(x),mid+1,r,to);
	}
	return now;
}
int query(int u,int v,int l,int r,int k)
{
	//cout<<" query "<<l<<" "<<r<<" old: "<<u<<" new: "<<v<<endl;
	if(l==r) return l;
	int x=s(ls(v))-s(ls(u));
	int mid=(l+r)>>1;
	if(x<k) return query(rs(u),rs(v),mid+1,r,k-x);
	else return query(ls(u),ls(v),l,mid,k);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),b[i]=a[i];
	sort(a+1,a+n+1);
	cnt=unique(a+1,a+n+1)-a-1;
	
	build(++id,1,cnt);
	root[0]=1;
	for(int i=1;i<=n;i++)
	{
		root[i]=add(root[i-1],1,cnt,li(b[i]));
	}
	int l,r,z;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&l,&r,&z);
		int p=query(root[l-1],root[r],1,cnt,z);
		printf("%d\n",a[p]);
	}
	return 0;
}
```

---

## 作者：jxcakak (赞：3)

写题解抢一血.

所谓主席树求区间第k小,就是给第1~i(0<=i<=n)个元素各建一棵权值线段树.但是如果直接建肯定会MLE,但可以发现每次建1~i个元素的线段树时,只用从1~(i-1)个元素的线段树修改logn个节点得来,所以我们每次只需新建logn个节点.

把这些树建出来后,会发现这些线段树是可以减的,即l~r的线段树可以从1~r的线段树的每个节点减去1~(l-1)的线段树的每个节点得到,这样我们求第k小时可以在树上二分得到结果.

当然如果要建权值线段树,需要先离散数据.


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=100010;
int a[N],s[N],rt[N],ls[N*20],rs[N*20],val[N*20],sz,cnt;
void build_tree(int &p,int L,int R){//建一棵空线段树
    p=++cnt; 
    if(L!=R){
        int mid=(L+R)/2; build_tree(ls[p],L,mid);
        build_tree(rs[p],mid+1,R);
    }
}
void insert(int &p,int cmp,int x,int L,int R){//从第i-1个线段树得到第i个线段树
    p=++cnt; ls[p]=ls[cmp]; rs[p]=rs[cmp]; val[p]=val[cmp]+1;
    if(L!=R){
        int mid=(L+R)/2;
        if(x<=mid) insert(ls[p],ls[cmp],x,L,mid);
        else insert(rs[p],rs[cmp],x,mid+1,R);
    }
}
int query_kth(int l,int r,int L,int R,int k){//查询区间第k小
    if(L==R) return L; int num=val[ls[r]]-val[ls[l]],mid=(L+R)/2;
    if(k<=num) return query_kth(ls[l],ls[r],L,mid,k);
    else return query_kth(rs[l],rs[r],mid+1,R,k-num);
}
int main(){
    int n,m; scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i){
        scanf("%d",&a[i]); s[i]=a[i];
    }
    sort(s+1,s+n+1); sz=unique(s+1,s+n+1)-s-1;//离散数据
    build_tree(rt[0],1,sz);
    for(int i=1;i<=n;++i) insert(rt[i],rt[i-1],lower_bound(s+1,s+sz+1,a[i])-s,1,sz);
    for(int i=1;i<=m;++i){
        int l,r,k; scanf("%d%d%d",&l,&r,&k);
        printf("%d\n",s[query_kth(rt[l-1],rt[r],1,sz,k)]);
    }
    return 0;
}
```

---

## 作者：moye到碗里来 (赞：3)

竟然没有人用指针写？？ 这我就不服了。既然是模板，还是讲一下思路。首先如果说不知道权值线段树的。。请你先百度，或者去做做逆序对这道题。首先我先声明一句，主席树跟可持久化线段树是包含的，主席树被可持久化线段树包含，而不是啥主席树就是可持久化线段树，瞎比比呢。主席树准确来说是可持久化权值线段树，这个权值线段树实际上是相当于一颗平衡树，有兴趣的同学可以看看NOIP2017列队，那道题是典型的权值线段树。

废话了这么久就大概讲讲可持久化线段树吧，其实原理非常简单，首先我们考虑有无限空间，怎么可持久化？ 答案，每次复制一遍线段树再改就完了。但是哪有那么多空间。。于是我们研究之后，发现只修改最多logn个点，为啥？你自己想想线段树的更新方式。那其他的节点显然没有任何必要去复制，那就直接把新的这棵树的相应节点用个指针接到哪里就完了，颇有重复利用的味道，开节点池动态开点，数组开2n+mlogn个点，再单独开个根数组。

那这道题，直接每加一个点就复制一遍当个历史版本，相当于前缀和了，每次给个区间范围就之就用第r个树减去与第l-1个树重复的节点，然后。。就完了
```
#include<bits/stdc++.h>
using namespace std;
const int N=210000;
struct node{
    int sum;
    node *ls,*rs;
    node() : sum(0),ls(NULL),rs(NULL) {};
}pool[N*20];
inline int read(){
    int f = 1;int x = 0;char ch = getchar();
    while(ch>'9' || ch < '0'){
        if(ch == '-')f = -1;
        ch = getchar();
    }	
    while(ch >= '0' && ch <= '9'){
        x = x*10 + ch-'0';
        ch = getchar();
    }
    return x*f;
}
node *root[N];
node *NewNode(){
    static int cnt = 0;
    return &pool[cnt++];
}
node *build(int l,int r){
    node *rt = NewNode();int mid = (l+r)>>1;
    if(l < r){
        rt->ls = build(l,mid);
        rt->rs = build(mid+1,r);	
    }	
    return rt;
}
void update(node *rt,node *pre,int l,int r,int x){
	rt->sum = pre->sum + 1;
    if(l < r){
        int mid = (l + r) >> 1;
        if(mid >= x){
            rt->ls = NewNode();
            rt->rs = pre->rs;
            update(rt->ls,pre->ls,l,mid,x);
        }
        else{
            rt->ls = pre->ls;
            rt->rs = NewNode();
            update(rt->rs,pre->rs,mid+1,r,x);
        }
    }
    else
    {
    	return ;
    }
}
int query(node *pre,node *rt,int l,int r,int x){
    if(l < r){
        int mid = (l + r) >> 1;
        int s = rt->ls->sum - pre->ls->sum;
        if(x <= s){
            return query(pre->ls,rt->ls,l,mid,x);
        }
        else{
            return query(pre->rs,rt->rs,mid+1,r,x-s);
        }
    }
    return l;
}
int n,q;
int num[N],num2[N];
int main()
{
    scanf("%d %d",&n,&q);
    for(int i = 1; i <= n; i++){
        num[i] = read();
        num2[i] = num[i];
    }
    sort(num2+1,num2+1+n);
    int size = unique(num2+1,num2+n+1)-(num2+1);
    root[0] = build(1,size);
    for(int i = 1; i <= n; i++){
        int t = lower_bound(num2+1,num2+1+size,num[i]) - num2;
        root[i] = NewNode();
        update(root[i],root[i-1],1,size,t);
    }
    for(int i = 1; i <= q; i++){
        int x,y,z;
        x = read();y = read(),z = read();
        printf("%d\n",num2[query(root[x-1],root[y],1,size,z)]);
    }
}
```

---

## 作者：YangHao (赞：2)

### 前言
这篇文章详细地介绍了可持久化线段树，部分图片尺寸过大，建议单击图片放大观看。转载此文章的任何部分均需注明出处。

## 1 可持久化线段树
### 1.1 问题引入
您需要写一个数据结构，维护一个数列 $a[1...N]$，支持以下操作：
输入 `l r k`（$l\leq r,k\leq r-l+1$），求 $a[l...r]$ 中第 $k$ 小的数。

这就是经典的 “静态区间第 k 小” 问题。

**可持久化线段树**（Persistent Segment Tree）可以很好地解决这个问题。在学习可持久化线段树时，我们首先要了解权值线段树。

### 1.2 权值线段树
权值线段树是一种维护值而非下标的线段树，为了方便理解，有时也被称作 “值域线段树”。

设 $x$ 是一权值线段树上的一个点，它维护的区间是 $[x.l,x.r]$，数据是 $x.d$，则它表示的意思是：原数组中，值在区间 $[x.l,x.r]$ 内的数一共有 $x.d$ 个。

举个例子。有一个数组 $a[]=\{1,5,3,8\}$，则它的权值线段树是
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191101151343422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lhbmdIYW81,size_16,color_FFFFFF,t_70)
权值线段树可以解决整个区间的查询问题。换句话说，当 $l=1,r=N$ 时，我们就可以用权值线段树求解了。

那如果 $l\neq1$ 或 $r\neq N$，我们又该怎么办呢？

一种很显然的想法就是，我建 $\frac {N(N+1)}2$ 棵权值线段树，也就是说，$\forall 1\leq l\leq r\leq N$，我都建一棵权值线段树维护 $a[l...r]$。这样做的话空间复杂度是 $T(N^3)$，不能接受。而且这样做的话，光是建树就会导致超时。

不难发现，权值线段树是可加减的。也就是说，我可以只开 $N$ 棵权值线段树，第 $i$ 棵维护 $a[1...i]$ 范围的数（这里用了前缀和思想）。如果查询 $[l,r]$ 区间，就用第 $r$ 棵树减去第 $l-1$ 棵树即可。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191101154442137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lhbmdIYW81,size_16,color_FFFFFF,t_70)
时间复杂度 $O(N^2+M\log N)$，空间复杂度 $T(N^2)$，仍然不够优秀。


### 1.3 可持久化线段树
观察上面的四棵树。不难发现，第 $i$ 棵树与第 $i-1$ 棵树只有一条链不一样，其余部分完全相同。那么，我们能不能在这里做点文章，压缩时间、空间复杂度呢？

答案是肯定的。我们每次建树时，不需要新建一棵完整的树，只需要在原来的树上加一条链就行了。

还是以 $a[]=\{1,5,3,8\}$ 为例，画出可持久化线段树：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191101192935162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lhbmdIYW81,size_16,color_FFFFFF,t_70)
最后一棵就是最终形态的可持久化线段树了。

至此，可持久化线段树的基本内容已经讲解完毕了，我们现在已经可以解决文首提出的问题了。
### 1.4 例题
[静态区间第 k 小问题](https://www.luogu.org/problem/P3834) 如题，给定 $N$ 个整数构成的序列，将对于指定的闭区间查询其区间内的第 $K$ 小值。

**解** 将两棵可持久化线段树相减。从根节点开始，往下遍历，若左子树维护区间的数的个数 $d<K$，则走向左儿子，否则走向右儿子；重复以上操作，直到走到叶子节点，该节点的下标即为答案。

**参考代码**
```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
using namespace std;

const int MAXN=200010;

int n,m;
struct index{
	int x,y;
	friend bool operator<(const index a,const index b){
		return a.y<b.y;
	}
}a[MAXN];
int b[MAXN];
int mp[MAXN];
int sx,sy,sd;

inline int read(){
	int x=0; char c;
	do c=getchar(); while(c<'0'||c>'9');
	while(c>='0'&&c<='9')
		x=x*10+c-48,c=getchar();
	return x;
}
struct PreSegTree{
	struct index{
		int l,r,ls,rs,d;
		index(){
			l=r=ls=rs=d=0;
		}
	}e[MAXN*4];
	int len;
	int root[MAXN];
	PreSegTree(){
		len=0;root[0]=1;
	}
	void buildtree(int l,int r){
		int me=++len;
		e[me].l=l;e[me].r=r;
		if(l==r) return;
		int mid=(l+r)/2;
		e[me].ls=len+1;buildtree(l,mid);
		e[me].rs=len+1;buildtree(mid+1,r);
	}
	void grow(int rt,int x){
		int l=e[rt].l,r=e[rt].r,me=++len;
		e[me].l=l;e[me].r=r;
		if(l==r){
			e[me].d=e[rt].d+1;
			return;
		}
		int mid=(l+r)/2;
		if(x<=mid){
			e[me].ls=len+1;e[me].rs=e[rt].rs;
			grow(e[rt].ls,x);
		}else{
			e[me].ls=e[rt].ls;e[me].rs=len+1;
			grow(e[rt].rs,x);
		}
		e[me].d=e[e[me].ls].d+e[e[me].rs].d;
	}
	void insert(int x,int d){
		root[x]=len+1;
		grow(root[x-1],d);
	}
	int query(int rootl,int rootr,int k){
		int LS=e[rootl].ls,RS=e[rootr].ls;
		int D=e[RS].d-e[LS].d;
		if(e[rootl].l==e[rootl].r) return e[rootl].r;
		if(k<=D) return query(LS,RS,k);
		else return query(e[rootl].rs,e[rootr].rs,k-D);
	}
}T;
int main(){
	n=read();m=read();
	T.buildtree(1,n);
	for(int i=1;i<=n;++i)
		a[i].x=i,a[i].y=read();
	sort(a+1,a+n+1);
	int tmp=0,last=-0x3f3f3f3f;
	for(int i=1;i<=n;++i){
		if(a[i].y!=last){
			++tmp;
			mp[tmp]=a[i].y;
		}
		b[a[i].x]=tmp;
		last=a[i].y;
	}
	for(int i=1;i<=n;++i)
		T.insert(i,b[i]);
	for(int i=1;i<=m;++i){
		sx=read();sy=read();sd=read();
		printf("%d\n",mp[T.query(T.root[sx-1],T.root[sy],sd)]);
	}
}
```

---

## 作者：Grind_1 (赞：2)

最近刚学的主席树  
来整理一发思路  
首先主席树是采用一种公用顶点的思想不同节点直接分开存  
首先事先建好一颗权值线段树（离散化这就不用说了吧）  
然后我们知道单点修改只会改变logn的节点那么就新建一个根  
在先前那个根的基础上将修改后的节点存起来  
可能会问  那没修改的会走不到啊其实在一进change函数的时候新建的树根已经把原树根的左右儿子已经记下来了  
需要修改就走下去  不需要修改其实就只会走原来那棵树  

求通过！

对于这题，根据序列的顺序建立一棵主席树，线段树维护大小在 L,R 的数字总和，对于询问的区间 s,t 其实就是令两棵线段树rt t - rt s-1（两棵树每个节点都相减）可以得到新的线段树x，其实就是在x中找第k小而已，转化成了一个普通的线段树问题。当然，这里每个节点都相减只是为了便于理解，实际上只需要logn的节点需要相减，具体看代码实现：
```cpp
#include<bits/stdc++.h>  
#define int long long  
#define mid (ll+rr)>>1  
using namespace std;  
int T[4010000],tot,n,Q,s[4001000],b1[4010000],L[4010000],R[4010000],sum[4010000];  
int build(int ll,int rr)  
{  
	int rt=++tot;  
	if(ll<rr)  
	{   
		L[rt]=build(ll,mid);  
		R[rt]=build(mid+1,rr);  
	}  
	return rt;  
}  
int change(int pre,int ll,int rr,int x)  
{  
	int rt=++tot;  
	L[rt]=L[pre];R[rt]=R[pre];sum[rt]=sum[pre]+1;
	if(ll<rr)  
	{  
		if(x<=mid)   L[rt]=change(L[pre],ll,mid,x);  
		else R[rt]=change(R[pre],mid+1,rr,x);  
	}  
	return rt;  
}  
int ask(int u,int v,int ll,int rr,int k)  
{  
	if(ll==rr) return ll;  
	int x=sum[L[v]]-sum[L[u]];  
	if(x>=k) ask(L[u],L[v],ll,mid,k);  
	else ask(R[u],R[v],mid+1,rr,k-x);  
}  
signed main()  
{	  
	scanf("%lld%lld",&n,&Q);  
	for(int i=1;i<=n;i++)     
        scanf("%lld",&s[i]),b1[i]=s[i];  
	sort(b1+1,b1+1+n);  
	int m=unique(b1+1,b1+1+n)-b1-1;  
	T[0]=build(1,m);  
	for(int i=1;i<=n;i++)   
        s[i]=lower_bound(b1+1,b1+1+m,s[i])-b1,  
        T[i]=change(T[i-1],1,m,s[i]);  
	while(Q--)  
	{  
		int a,b,k;  
		scanf("%lld%lld%lld",&a,&b,&k);  
		int p=ask(T[a-1],T[b],1,m,k);  
		printf("%lld\n",b1[p]);  
	}  
	return 0;  
}  
```


---

## 作者：chenxinyang2006 (赞：2)

**upload on 2019.12.11：我太年轻了，这个解法挺经典且广为人知的**

**本题解不是主席树教程，而是邪教分块**

* 一个暴力解法

这题我首先是这样想的：

从小到大排序，然后找到第k个符合区间要求的数，就是第k小。

简明易懂，正确性也可以证明，可惜复杂度O(n)，能不能优化一下？可以，分块。（这里默认块长$\sqrt{n}$）

* 正解（反正能AC这题）

对于每个块记录一个$total[i][j]$，表示第i个块中的数字，在**原数组**下表小于等于j的数量。

这个显然可以前缀和解决，复杂度$O(n \sqrt{n})$

然后对于每个询问，从块1开始访问，每次记录符合区间要求的数的个数，直接加上$total[i][y] - total[i][x - 1]$就行了。如果符合区间限制的数已经>=k了，那么暴力扫一遍这个块，统计出答案。

这样每个操作最多访问$ \sqrt{n}$个块，每个块最多访问$ \sqrt{n}$个数，那么还是$ \sqrt{n}$复杂度的。

可惜开不下447 * 200000的数组，所以我块长取了$n ^ {0.6}$，卡着时限AC了。

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
int n,m,len;
int total[150][200005];

int x,y,k;

struct node{
	int val,id;
}p[200005];

inline int from(int x){
    if(x % len == 0){
    	return x / len;
    }
    return x / len + 1;
}

inline int L(int x){
	return (x - 1) * len + 1;
}

inline int R(int x){
	return x * len;
}

bool cmp(node a,node b){
	return a.val < b.val;
}

void slove(){
	int cnt = 0,i;
    for(i = 1;i <= from(n);i++){
        if(cnt + total[i][y] - total[i][x - 1] >= k){
        	break;
        }
        cnt += total[i][y] - total[i][x - 1];
    }
    for(int j = L(i);j <= R(i);j++){
    	if(p[j].id >= x && p[j].id <= y){
    		cnt++;
    	}
    	if(cnt == k){
    		printf("%d\n",p[j].val);
    		return;
    	}
    }
}

int main(){
    scanf("%d%d",&n,&m);
    for(int i = 1;i <= n;i++){
    	scanf("%d",&p[i].val);
    	p[i].id = i;
    }
    sort(p+1,p+n+1,cmp);
    len = pow(n,0.6);
    for(int i = 1;i <= n;i++){
        total[from(i)][p[i].id]++;
    }
    for(int i = 1;i <= from(n);i++){
    	for(int j = 1;j <= n;j++){
    		total[i][j] += total[i][j - 1];
    	}
    }
    for(int i = 1;i <= m;i++){
    	scanf("%d%d%d",&x,&y,&k);
    	slove();
    }
	return 0;
}
```

顺带一提，这个思路还可以做P3380，而且单次复杂度也是$ \sqrt{n}$，可以看[这个大佬的题解](https://www.luogu.com.cn/blog/ShadowassIIXVIIIIV/solution-p3380)

---

## 作者：xukuan (赞：2)

主席树

简要的说，先做一波离散化，然后对于主席树里每一个位置$p$,我们维护了值的范围。然后第i个线段树中区间$[l,r]$表示离散化后数字$1-i$在区间$[l,r]$范围内的个数

为了帮助大家理解，我模拟一下样例


### PART 1 建树

![](https://cdn.luogu.com.cn/upload/image_hosting/pm87uj0i.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

### PART 2 加数

将每个数字离散化后的编号插入到它的位子上，然后并把所有包括它的区间的sum都++。

插入25927（离散化后是3）

![](https://cdn.luogu.com.cn/upload/image_hosting/5zmag9to.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

插入6405（离散化后是1）

![](https://cdn.luogu.com.cn/upload/image_hosting/djpvwjdr.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

最终结果

![](https://cdn.luogu.com.cn/upload/image_hosting/rtiuo3r8.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

同时，我们用数组$sum$表示在区间$[l,r]$数字总和。

### PRAT 3 查询

所以对于一个区间$[l,r]$，我们找到$[1,l]$和$[1,r]$两棵树，每次算出在$[l,mid]$范围内的数，如果数量$ \geq rank$，就往左子树走，否则就往右子树走。

这还是挺好理解的

```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

const ll N=200010;
ll n,m,len,cnt,a[N],b[N],sum[N];
struct SegmentTree{
    ll lson,rson,sum;
}tree[N<<5];

inline ll read(){
    ll x=0,tmp=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-') tmp=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
    }
    return tmp*x;
}

inline void write(ll x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    ll y=10,len=1;
    while(y<=x){
        y=(y<<3)+(y<<1);
        len++;
    }
    while(len--){
        y/=10;
        putchar(x/y+48);
        x%=y;
    }
}

ll build(ll l,ll r){
    ll p=++cnt;
    if(l==r) return p;
    ll mid=(l+r)>>1;
    tree[p].lson=build(l,mid);
    tree[p].rson=build(mid+1,r);
    return p;
}

ll update(ll pre,ll l,ll r,ll val){
    ll p=++cnt;
    tree[p]=tree[pre]; tree[p].sum++;
    if(l==r) return p;
    ll mid=(l+r)>>1;
    if(val<=mid) tree[p].lson=update(tree[pre].lson,l,mid,val);
    if(val>mid) tree[p].rson=update(tree[pre].rson,mid+1,r,val);
    return p;
}

ll query(ll x,ll y,ll l,ll r,ll rank){
    if(l==r) return b[l];
    ll mid=(l+r)>>1,ans=tree[tree[y].lson].sum-tree[tree[x].lson].sum;
    return ans>=rank?query(tree[x].lson,tree[y].lson,l,mid,rank):query(tree[x].rson,tree[y].rson,mid+1,r,rank-ans);
}

int main(){
    n=read(); m=read();
    for(ll i=1; i<=n; i++) b[i]=a[i]=read();
    sort(b+1,b+1+n);
    len=unique(b+1,b+1+n)-b-1;
    for(ll i=1; i<=n; i++) a[i]=lower_bound(b+1,b+1+len,a[i])-b;
    sum[0]=build(1,n);
    for(ll i=1; i<=n; i++) sum[i]=update(sum[i-1],1,len,a[i]);
    while(m--){
        ll l=read(),r=read(),rank=read();
        write(query(sum[l-1],sum[r],1,len,rank)); putchar('\n');
    }
    return 0;
}
```

---

## 作者：Treaker (赞：2)

$$\color{cornflowerblue}{\mathcal{Treaker}}$$
## 主席树
所谓主席树，就是可持久化权值线段树。

再看题，我们对于每一个节点开一颗权值线段树，因为它们的结构相同，所以具有区间可减性。也就是用$~r~$的权值线段树减去$~l-1~$的权值线段树得到的就是那段区间（可能说的有些瑕疵）。也就是一个前缀和思想，

但是我们如果真的对于每一个节点开一颗权值线段树，那空间岂不瞬间爆炸~~送他升天~~。可持久化权值线段树应运而生。他的思想是什么呢。

我们考虑对于一个节点的权值线段树，他跟上一个节点的权值线段树只有$~logn~$个节点不同，那么我是不是可以建立在上一个节点的权值线段树上呢？

答案是肯定的。也就是我们说的主席树，他的空间复杂度是$~O(nlogn)~$。可海星。

实现的话看代码吧。~~指针的哦！！！~~


完整代码如下：
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 200005;
inline int read()
{
	int x = 0 , f = 1;	char ch = getchar();
	while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
int n , m;
int a[N] , b[N];
struct Persident_Tree
{
	#define mid ((p -> l + p -> r) >> 1)
	struct node
	{
		node *ls , *rs;
		int l , r , size;
		node(int l = 0,int r = 0) : l(l) , r(r) {ls = rs = NULL;size = 0;}
	}*root[N];
	void build(node *&p,int l,int r)
	{
		p = new node(l,r);
		if(p -> l == p -> r) return;
		build(p -> ls,l,mid); build(p -> rs,mid+1,r);
	}
	void insert(node *&p,node *o,int x)
	{
		p = new node(); *p = *o; p -> size ++;
		if(p -> l == p -> r) return;
		if(x <= mid) insert(p -> ls,o -> ls,x);
		else insert(p -> rs,o -> rs,x);
	}
	int query(node *p,node *o,int k)
	{
		if(p -> l == p -> r) return b[p -> l];
		if(k <= p -> ls -> size - o -> ls -> size) return query(p -> ls,o -> ls,k);
		else return query(p -> rs,o -> rs,k - p -> ls -> size + o -> ls -> size);
	}
	inline void League_of_Legends()
	{
		n = read(); m = read();
		for(int i = 1;i <= n;i ++) b[i] = a[i] = read();
		sort(b+1,b+1+n); 
		build(root[0],1,n);
		for(int i = 1;i <= n;i ++)
		{
			int tmp = lower_bound(b+1,b+1+n,a[i]) - b;
			insert(root[i],root[i-1],tmp);
		}
		for(int i = 1 , l , r , k;i <= m;i ++)
		{
			l = read(); r = read(); k = read();
			printf("%d\n",query(root[r],root[l-1],k));
		}
	}
}Dungeon_Fighter;
int main()
{
	Dungeon_Fighter.League_of_Legends();
	return 0;
}
```


---

## 作者：ynyuje (赞：2)

这道题其实并不需要离散化，直接上权值线段树维护$\lbrack-1e9,1e9\rbrack$即可，时间复杂度$((n+m)log 2e9)$。注意每次取$mid$只能右移，直接除以$2$是向$0$取整，$(-1,0)$区间会死循环，而且维护负值也不对，右移是向下取整，可以维护负值。

线段树有个操作叫做**线段树合并**，每次合并一下$i$和$i-1$两个线段树的信息，只不过主席树把它写在update中了，有兴趣的同学可以自学。

权值线段树直接维护权值，可以支持在线修改操作$($当然也要树套树维护$)$，在线操作总不能离散化吧？以下是代码。
```
#include<bits/stdc++.h>
#define ll long long int
using namespace std;

const int maxn=2e5+7;
const int maxm=1e7+7;
const int inf=1e9;

int n,m,tot=0,rt[maxn];
char s[3];
struct node{int ls,rs,siz;}t[maxm];

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	return x*f;
}

inline void writ(int x)
{
	if (x<0) putchar('-'),x=-x;
	if (x>9) writ(x/10);
	putchar(x%10+'0');
}
inline void writt(int x){writ(x),putchar(' ');}
inline void write(int x){writ(x),putchar('\n');}

inline void ins(int &o,int l,int r,int k)
{
	if (!o) o=++tot;++t[o].siz;
	if (l==r) return ;
	int mid=l+r>>1;
	k<=mid?ins(t[o].ls,l,mid,k):ins(t[o].rs,mid+1,r,k);
}

inline int query(int x,int y,int l,int r,int k)
{
	if (l==r) return l;
	int mid=l+r>>1,tmp=t[t[y].ls].siz-t[t[x].ls].siz;
	return k<=tmp?query(t[x].ls,t[y].ls,l,mid,k):query(t[x].rs,t[y].rs,mid+1,r,k-tmp);
}

inline void merge(int &x,int y)
{
	if (!x||!y) {x+=y;return ;}
	t[x].siz+=t[y].siz;
	merge(t[x].ls,t[y].ls),merge(t[x].rs,t[y].rs);
}

int main()
{
	n=read(),m=read();
	for (int i=1;i<=n;++i) ins(rt[i],-inf,inf,read());
	for (int i=2;i<=n;++i) merge(rt[i],rt[i-1]);
	while (m--)
	{
		int x=read(),y=read(),k=read();
		write(query(rt[x-1],rt[y],-inf,inf,k));
	}
	return 0;
}
```

---

## 作者：Jeblqr (赞：2)

[【模板】可持久化线段树 1（主席树）](https://www.luogu.org/problem/P3834)

一句话题意：给一段区间，求区间$k$小值

这道题可以有很多种解法，比如说~~暴力~~树套树之类的。不过我很久以前写的树套树~~已经忘了~~一直$\text{A}$不了，所以就来学主席树了。

主席树，又名可持久化线段树，由发明者HJT而有“主席树”之名~~是谁不用说了吧？~~

那我们该怎么把一颗线段树可持久化呢？套用可持久化$\text{Trie}$的思路，我们需要——动态开点。

为了方便之后的理解，先把主函数放上来

```cpp
\\T是我封装了的主席树

int a[Maxn], b[Maxn];

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> a[i], b[i] = a[i];
    sort(b + 1, b + n + 1);
    //
    int size = unique(b + 1, b + n + 1) - b - 1;
    //离散化并去重
    T.build(T.root[0], 1, size);//建立一棵空的线段树
    for (int i = 1; i <= n; i++)
        T.change(T.root[i], T.root[i - 1], 1, size,
                 (lower_bound(b + 1, b + size + 1, a[i]) - b));
    while (m --> 0) {
        int x, y, k;
        cin >> x >> y >> k;
        cout << b[T.query(T.root[x - 1], T.root[y], 1, size, k)] << endl;
    }
    return 0;
}
```

以及$\text{T}$里面的主席树的节点的定义

```cpp
struct Node {
        int l, r, sum;//因为无法找出节点所代表的l和r，所以要额外储存
        //sum保存l~r内结点个数
    } node[Maxn << 5];
int cnt;//储存动态加点的节点编号
```

出现在主函数里面的一共有三个操作，我们一个个来讲。



------------


## build(int& p, int l, int r)


这个操作是为了建立一棵空树，和一般线段树差不多。

```cpp
void build(int& p, int l, int r) {
        p = ++cnt;
        if (l == r)
            return;
        int mid = (l + r) / 2;
        build(node[p].l, l, mid);
        build(node[p].r, mid + 1, r);
    }
```

但一定要注意的是：**我们传入的$p$是引用的**。因为我们是要动态加点的，这就涉及到新建节点的编号要赋值回它的父节点的操作了。所以说涉及要动态加点的地方，就一定要用引用了。



------------


## change(int& p, int q, int l, int r, int x)

这个就比较复杂了。

```cpp
void change(int& p, int q, int l, int r, int x) {
        p = ++cnt;
        node[p] = node[q];
        node[p].sum += 1;
        if (l == r)
            return;
        int mid = (l + r) / 2;
        if (x <= mid)
            change(node[p].l, node[q].l, l, mid, x);
        else
            change(node[p].r, node[q].r, mid + 1, r, x);
    }
```

首先，$x$传入的是在区间中的排名。我们要给它插入到排名为$x$的地方。因为已经离散化了，所以$l$到$r$也表示排名。因此我们直接把$x$插入到$x$的地方就行了（像普通线段树一样）

对于传进来的，我们先要给他**动态加点**，然后把原来结点的东西给赋回去。因为我们是一个个权值插入的，故$node[p].sum$要加一



------------


## query(int p, int q, int l, int r, int k)

这个不用修改节点信息，所以就不用引用了（引用了也没关系）。

```cpp
int query(int p, int q, int l, int r, int k) {
        if (l == r)
            return l;
        int mid = (l + r) / 2;
        int tmp = node[node[q].l].sum - node[node[p].l].sum;
        if (tmp >= k)
            return query(node[p].l, node[q].l, l, mid, k);
        else
            return query(node[p].r, node[q].r, mid + 1, r, k - tmp);
    }
```

这里的重点是$\text{tmp}$这个变量。

对与$p$和$q$，我们实际上传入的是$1$ ~ $(l-1)$和$1$ ~ $r$。因为每棵主席树都是一样的，所以它是可减的。所以说$node[node[q].l].sum - node[node[p].l].sum$，也就是$\text{tmp}$，代表的是$p$~$q$之间的左边的~~词穷~~数的个数。于是就有了上面那堆代码。后面的$\text{return l}$，其实是返回的离散化后的值。


```cpp
#include <bits/stdc++.h>
const int Maxn = 210001;
using namespace std;

class HJTTree {
    struct Node {
        int l, r, sum;
    } node[Maxn << 5];
    int cnt;

   public:
    int root[Maxn];
    void build(int& p, int l, int r) {
        p = ++cnt;
        if (l == r)
            return;
        int mid = (l + r) / 2;
        build(node[p].l, l, mid);
        build(node[p].r, mid + 1, r);
    }
    void change(int& p, int q, int l, int r, int x) {
        p = ++cnt;
        node[p] = node[q];
        node[p].sum += 1;
        if (l == r)
            return;
        int mid = (l + r) / 2;
        if (x <= mid)
            change(node[p].l, node[q].l, l, mid, x);
        else
            change(node[p].r, node[q].r, mid + 1, r, x);
    }
    int query(int p, int q, int l, int r, int k) {
        if (l == r)
            return l;
        int mid = (l + r) / 2;
        int tmp = node[node[q].l].sum - node[node[p].l].sum;
        if (tmp >= k)
            return query(node[p].l, node[q].l, l, mid, k);
        else
            return query(node[p].r, node[q].r, mid + 1, r, k - tmp);
    }
} T;

int a[Maxn], b[Maxn];

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> a[i], b[i] = a[i];
    sort(b + 1, b + n + 1);
    int size = unique(b + 1, b + n + 1) - b - 1;
    T.build(T.root[0], 1, size);
    for (int i = 1; i <= n; i++)
        T.change(T.root[i], T.root[i - 1], 1, size,
                 (lower_bound(b + 1, b + size + 1, a[i]) - b));
    while (m --> 0) {
        int x, y, k;
        cin >> x >> y >> k;
        cout << b[T.query(T.root[x - 1], T.root[y], 1, size, k)] << endl;
    }
    return 0;
}
```


完结撒花~~ $\space \space \space \space \space$(* "･∀･)ﾉ――◎





























---

## 作者：轻尘 (赞：2)

#### 可持久化线段树，又叫主席树，在对线段树做了一定修改以后，还可以同时保留修改前的线段树的模样。是用来维护区间第K小的一种数据结构。
![PwY3b4.png](https://s1.ax1x.com/2018/08/01/PwY3b4.png)
**下面介绍一下基本思想**

------------
#### 0.0 离散化（一会再讲，与思想无关）
**1.1 维护一个权值线段树，具体而言就是将一个连续的（1~m）区间不断二分，最终每一个数代表一个节点（也就是说，我们可以在这棵树上找的区间内的每一个数）。**
**1.2 这样就很好办了，对于每一个节点我们都可以维护以他为根的子树的sum表示这个区间已有多少数，这样再将给定区间的每一个点加入权值线段树，并在线段树的相应叶子点sum+1 *（有点像计数排序）。* 然后update（）一下将每个sum求出来，表示在每个二分区间内有多少个数。**
![PwYTaj.png](https://s1.ax1x.com/2018/08/01/PwYTaj.png)

------------


### QAQ
#### Q：
**1 现在我们有了一个看似非常nb的线段树，可它该怎么用，和可持久化数据结构有什么关系？^？
2 想一想现在建起的线段树是一个1~m的，可该怎么求出l~r的呢？？？**
#### A：
**1.先不考虑lr区间时，我们要求1~m的第K小，而一个权值线段树拥有优秀的单调性，我们知道每个区间有多少个数，那从从左往右找到第K个不就行了。
举个例子，找1~m第2小，1~mid的sum=3，mid+1~m的sum=7，由单调性可知，第2小的一定在左儿子区间内，然后再重复上面的过程直到找到树上标号。这就是为什么要用权值线段树的原因。：）**
**2.考虑比较暴力的做法，当我们求l~r区间时，不过是将l~r区间的数加进我们刚刚的线段树，那岂不是可以对每一次询问都建一个刚刚的树加入区间内的数。可是…………这也太暴力了，甚至不如sort一下快。想一想权值线段树的一些性质，加入一个点后只是在部分上sum+1。那利用一下 *前!缀!和!* 的思想，l~r区间不过是1~r的树减去1~l-1的树（这里的减是指各个节点sum值相减，想一想为什么）。**

------------


#### 至此我们已经完成了大半，但这和可持久化有什么关系呢？
**2.1 考虑一下复杂度，要建m个线段树（这个我们可以先建空树，在需要时在继续建），难道每次建树都需要重新for一遍吗？第1个树和第2个树只是多了一个数，相当于做了一个单点修改，而原树和新树有很大一部分完全一样，这时候就可持久化就登场了o(*≧▽≦)ツ**
**2.2 在建新树是可以从原树的基础上建，这样就极大的减小了重复的运算。建树过程如下图**
![PwYGVJ.png](https://s1.ax1x.com/2018/08/01/PwYGVJ.png)
#### 复杂度O(nlogn)

------------


#### 0.0  离散化介绍
> #### 离散化，就是把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。

>**首先将数字排序：32434234，32434234，43324556，8384733，98998988
去重后给予其对应的索引：0,0,1,2,3分别对应每个数，就可以简化很多操作，减少了很多不必要的资源开销。
除了对于较大整数需要使用离散化之外，对于一些需要使用整型数据结构，但给出的数据却是小数的也可以使用离散化，将其索引为整数就可以了。
那么可以总结出离散化的步骤：
1、排序
2、去重
3、索引
为了简化代码，我们采用STL算法离散化：**
```cpp
int a[n], b[n], sub[n]; //a[n]是即将被离散化的数组，b[n]是a[n]的副本，sub用于排序去重后提供离散化后的值
sort(sub, sub + n);
int size = unique(sub, sub + n) - sub;
for(int i = 0; i < n; i++)
    a[i] = lower_bound(sub, sub + size, a[i]) - sub; //即a[i]为b[i]离散化后对应的值
```
##### 转自
[http://www.cnblogs.com/kevince/p/3893531.html ](http://www.cnblogs.com/kevince/p/3893531.html )
——By Kevince。
###### 0.1
**在维护主席树时，对于每一个数，我们不一定要建最大值个，通过离散化，可以将数量大大缩小，只用维护1~去重后的点数 个，我们可以把输入数组里的每一个数都通过排序映射到一个较小的序列上，比如引用中举的例子32434234，32434234，43324556，8384733，98998988，去重后给予其对应的索引：0,0,1,2,3分别对应每个数。**
**通过离散化我们在query（）是找到第K小的点时，可以返回在区间的那一个点上，那么对应的点就是在排序后的原序列里。**

------------




~~结稿于2018-08-01 10:57.~~
# ：）
#### 转载请注明出处： 谢谢
[http://tch.drifts.ml/%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/195/](http://tch.drifts.ml/%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/195/) ——[tch学习笔记]


---

## 作者：bztMinamoto (赞：2)

先打个广告：[blog](https://www.cnblogs.com/bztMinamoto/p/9398329.html)，有入门有提高也有题单

 1.前言

据说主席树这个名字的由来呢，是因为创始人的名字缩写hjt与某位相同，然后他因为不会划分树于是自创了这一个数据结构。好强啊orz

 

主席树能实现什么操作呢？最经典的就是查询区间第k小了，其他的还有诸如树上路径第k小啦，带修改第k小啦之类的。以静态区间第k小为例

 2.定义

先贴一下某神犇对主席树的理解：所谓主席树呢，就是对原来的数列[1..n]的每一个前缀[1..i]（1≤i≤n）建立一棵线段树，线段树的每一个节点存某个前缀[1..i]中属于区间[L..R]的数一共有多少个（比如根节点是[1..n]，一共i个数，sum[root] = i；根节点的左儿子是[1..(L+R)/2]，若不大于(L+R)/2的数有x个，那么sum[root.left] = x）。若要查找[i..j]中第k大数时，设某结点x，那么x.sum[j] - x.sum[i - 1]就是[i..j]中在结点x内的数字总数。而对每一个前缀都建一棵树，会MLE，观察到每个[1..i]和[1..i-1]只有一条路是不一样的，那么其他的结点只要用回前一棵树的结点即可，时空复杂度为O(nlogn)。

 

然而没有什么用，因为感觉根本没看懂

 

然后来说说我自己的理解吧。如何求出一个区间内第k小呢？直接sort当然可以，但是复杂度爆表。于是我们可以换一个思路，能否将$[l,r]$之间出现过的数都建成线段树呢？设节点为$p$，区间为$[l,r]$，左儿子是$[l,mid]$，右儿子是$[mid+1,r]$

要查找第k大的话，先看左儿子里有多少个数（表示小于等于$mid$的数的个数），如果大于$k$，进左子树找，否则令$k-=左儿子数的个数$，进右子树找

先来考虑一个序列：3,2,1,4

建完树之后是这样的

![](https://cdn.luogu.com.cn/upload/pic/26124.png)

然后要查第2大，一下子就能发现是2了

（上面画的可能不是很严谨，大家将就下）

但我们不可能对每一个区间都建一棵树，那样的话空间复杂度绝对爆炸

然后可以转化一下思路：前缀和

区间$[l,r]$中小于等于$mid$的数的个数，可以转换为$[1,r]$中小于等于$mid$的数的个数减去$[1,l-1]$中小于等于$mid$的数的个数

于是我们只要对每一个前缀建一棵树即可

然后空间复杂度还是爆炸

然而我们又发现，区间$[1,l-1]$的树和区间$[1,l]$的树最多只会有$log n$个节点不同（因为每次新插入一个节点最多只会更新$log n$个节点），有许多空间是可以重复利用的

只要能将这些空间重复利用起来，就可以解决空间的问题了

还是上面那个序列：3，2,1,4

一开始先建一棵空树，然后一个个把每一个节点加进去

如果要看图的话可以点[这里](https://www.cnblogs.com/zyf0163/p/4749042.html)

 

这个时候有人就要问了，万一序列的数字特别大呢？

当然是离散化

将这些所有值离散一下就行了，可以保证所有数在$1~n$之间

然而感觉讲太多也没啥用……上代码好了，有详细的注释

详细的东西太多这里放不下，还是去我的blog里看吧
```
//minamoto
#include<bits/stdc++.h>
#define N 200005
using namespace std;
inline int read(){
    #define num ch-'0'
    char ch;bool flag=0;int res;
    while(!isdigit(ch=getchar()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getchar());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
int sum[N<<5],L[N<<5],R[N<<5];
int a[N],b[N],t[N];
int n,q,m,cnt=0;
int build(int l,int r){
    int rt=++cnt;
    //建树 
    sum[rt]=0;
    if(l<r){
        int mid=(l+r)>>1;
        L[rt]=build(l,mid);
        R[rt]=build(mid+1,r);
    }
    return rt;
}
int update(int last,int l,int r,int x){
    int rt=++cnt;
    L[rt]=L[last],R[rt]=R[last],sum[rt]=sum[last]+1;
    //先继承上一次的信息 
    //L是左节点，R是右节点，sum是节点内数的个数 
    if(l<r){
        int mid=(l+r)>>1;
        if(x<=mid) L[rt]=update(L[last],l,mid,x);
        else R[rt]=update(R[last],mid+1,r,x);
        //如果有需要更新的信息，更新
        //可以发现每一次更新的节点最多只有log n个 
    }
    return rt;
}
int query(int u,int v,int l,int r,int k){
    if(l>=r) return l;
    int x=sum[L[v]]-sum[L[u]];
    //查询操作 
    int mid=(l+r)>>1;
    if(x>=k) return query(L[u],L[v],l,mid,k);
    else return query(R[u],R[v],mid+1,r,k-x);
    //如果左节点个数大于等于k，进左子树找第k小
    //否则进右子树 
}
int main(){
    //freopen("testdata.in","r",stdin);
    n=read(),q=read();
    for(int i=1;i<=n;++i)
    b[i]=a[i]=read();
    sort(b+1,b+1+n);
    m=unique(b+1,b+1+n)-b-1;
    t[0]=build(1,m);
    //先建一棵空树 
    for(int i=1;i<=n;++i){
        int k=lower_bound(b+1,b+1+m,a[i])-b;
        //离散 
        t[i]=update(t[i-1],1,m,k);
        //然后每次在上一次的基础上建树 
    }
    while(q--){
        int x,y,z;
        x=read(),y=read(),z=read();
        int k=query(t[x-1],t[y],1,m,z);
        printf("%d\n",b[k]);
    }
    return 0;
}
```

---

## 作者：Angora (赞：2)

	裸主席树(划分树模板),不会划分树,直接上的主席树
	主席树又名函数式线段树,之所以叫主席树是因为这东西是fotile主席创建出来的。
	主席树支持查询历史版本,同时充分利用两个版本的相同性,来增强时间和空间效率。
  对于此题,如果对1-i这个区间建一棵线段树那么l-r这个区间的信息就可以通过1-r这棵线段树和1-l-1这棵线段树来得到,但是直接建n棵线段树空间上和时间上都是不允许的,我们通过观察可以发现第i棵线段树和第i-1棵线段树最多只有一条链不同,那么我们其实只需要新建这一条不同的链上的节点就好了,其他的直接指过去就ok
```c
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#define rep(i,x,y) for(register int i=x;i<=y;++i)
#define repd(i,x,y) for(register int i=x;i>=y;--i)
#define ll long long
using namespace std;
const int N=2e5+7;
typedef pair<int,int> s;
int rt[N<<5],lson[N<<5],rson[N<<5],root[N],rk[N],n,m,cnt=1;
s nm[N];
inline void update(int &o,int l,int r,int num){
	rt[cnt]=rt[o];lson[cnt]=lson[o];rson[cnt++]=rson[o];o=cnt-1;
	rt[o]++;
	if(l==r)return ;
	int mid=l+r>>1;
	if(num<=mid)update(lson[o],l,mid,num);
	else update(rson[o],mid+1,r,num);
}
inline int query(int i,int j,int l,int r,int k){
	if(l==r)return l;
	int t=rt[lson[j]]-rt[lson[i]],mid=l+r>>1;
	if(k<=t)return query(lson[i],lson[j],l,mid,k);
	return query(rson[i],rson[j],mid+1,r,k-t);
}
int main(){
	scanf("%d%d",&n,&m);
	rep(i,1,n){int a;scanf("%d",&a);nm[i]=s(a,i);}
	sort(nm+1,nm+n+1);
	rep(i,1,n)rk[nm[i].second]=i;
	rep(i,1,n){root[i]=root[i-1];update(root[i],1,n,rk[i]);}
	while(m--){
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		printf("%d\n",nm[query(root[a-1],root[b],1,n,c)].first);
	}
	return 0;
}
```

---

## 作者：heyongxin (赞：2)

蒟蒻今天来跟大家谈谈主席树（蒟蒻的主席树是用数组来写的，因为蒟蒻不会指针啊）
在进入正题之前还是先上一道题（洛谷P3834）
题目背景

这是个非常经典的主席树入门题——静态区间第K小
题目描述

如题，给定N个正整数构成的序列，将对于指定的闭区间查询其区间内的第K小值。
一道经典的老题（大佬勿喷）那我们就来谈谈这题怎么做；
第k小的数怎么求了，并且要求没此查询logn的算法，就只有用线段树来维护，那么线段树维护什么了；
于是我们就开一个值域线段树，每个节点存改节点在每个数出现的个数，那我们就要开很多的线段树来维护前1到r（r属于1，n）那用前缀和的思想，我们要查l到
r第k小数的只需要tr(r)到tr(l-1)第k小的数即可，但一棵棵线段树的开时间和空间都是nmlogn的肯定不行，于是我们便采用主席线段树；
那主席树具体怎么操作的：
主席树的具体操作就是将在原来的基础上加一些节点，让其具有可持续化的功能，如图上4和9节点就是在原来的树上进行的修改，那怎么修改了，其实很简单就是没有关系的就不要动，有关系的就不变，有关系的就开新节点；
谈完理论知识那么我们上代码吧；
```cpp
struct node
{
    long long l,r,ls,rs,c;//l是左区间，r是右区间，ls是左节点的编号，rs是右节点，c是data
}tr[maxn];
long long t,hyx[maxn];
long long nw(long long l,long long r)
{
    tr[++t]={l,r,0,0,0};
    return t;
}//新建节点，返回节点号
void xg(long long o,long long w,long long p)
{
    if(tr[o].l==tr[o].r)//到达叶节点值域加一
    {
        tr[o].c=tr[w].c+1;
        return;
    }
    long long mid=(tr[o].l+tr[o].r)>>1;
    if(p<=mid)//p在左儿子
    {
        tr[o].ls?tr[o].ls=tr[o].ls:tr[o].ls=nw(tr[o].l,mid);//动态开节点
        tr[o].rs=tr[w].rs;//没有动就不变
        xg(tr[o].ls,tr[w].ls,p);//继续递归下去
    }
    else
    {
        tr[o].rs?tr[o].rs=tr[o].rs:tr[o].rs=nw(mid+1,tr[o].r);
        tr[o].ls=tr[w].ls;
        xg(tr[o].rs,tr[w].rs,p);
    }
    tr[o].c=tr[tr[o].ls].c+tr[tr[o].rs].c;//爸爸的data就是儿子的data相加
}
long long cx(long long o,long long w,long long k)
{
    if(tr[w].l==tr[w].r)//到达叶节点返回叶的节点区间
    {
        return tr[w].l;
    }
    long long hh=tr[tr[w].ls].c-tr[tr[o].ls].c;//前缀和思想
    if(k<=hh)//在左边就继续递归下去
    {
        return cx(tr[o].ls,tr[w].ls,k);
    }
    else//将值减去左边的大小继续递归下去
    {
        return cx(tr[o].rs,tr[w].rs,k-hh);
    }
}
```
核心语法都学完了，从代码中我们可以轻易的看出时间复杂度是log的，空间是nlog^2n的，这下就能轻轻松松a掉这题了，那下面我上完整的代码了
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long maxn = 10000005;
struct node
{
    long long l,r,ls,rs,c;
}tr[maxn];
long long t,hyx[maxn];
long long nw(long long l,long long r)
{
    tr[++t]={l,r,0,0,0};
    return t;
}
void xg(long long o,long long w,long long p)
{
    if(tr[o].l==tr[o].r)
    {
        tr[o].c=tr[w].c+1;
        return;
    }
    long long mid=(tr[o].l+tr[o].r)>>1;
    if(p<=mid)
    {
        tr[o].ls?tr[o].ls=tr[o].ls:tr[o].ls=nw(tr[o].l,mid);
        tr[o].rs=tr[w].rs;
        xg(tr[o].ls,tr[w].ls,p);
    }
    else
    {
        tr[o].rs?tr[o].rs=tr[o].rs:tr[o].rs=nw(mid+1,tr[o].r);
        tr[o].ls=tr[w].ls;
        xg(tr[o].rs,tr[w].rs,p);
    }
    tr[o].c=tr[tr[o].ls].c+tr[tr[o].rs].c;
}
long long cx(long long o,long long w,long long k)
{
    if(tr[w].l==tr[w].r)
    {
        return tr[w].l;
    }
    long long hh=tr[tr[w].ls].c-tr[tr[o].ls].c;
    if(k<=hh)
    {
        return cx(tr[o].ls,tr[w].ls,k);
    }
    else
    {
        return cx(tr[o].rs,tr[w].rs,k-hh);
    }
}
int main()
{
    long long n,m;
    scanf("%lld%lld",&n,&m);
    hyx[0]=nw(-1e9+1,1e9+1);
    tr[0].c=0;
    long long a,l,r;
    for(long long i=1;i<=n;++i)
    {
        scanf("%lld",&a);
        xg(hyx[i]=nw(-1e9+1,1e9+1),hyx[i-1],a);
    }
    for(long long i=1;i<=m;++i)
    {
        scanf("%lld%lld%lld",&l,&r,&a);
        printf("%lld\n",cx(hyx[l-1],hyx[r],a));
    }
    return 0;
}
```

---

## 作者：封癫 (赞：2)

写题解推广[blog](http://www.vh13853128.icoc.me/nd.jsp?id=12)。

博客中有关于主席树的详细解释，配PPT自画烂图。

给原区间中每个前缀【1~i】建一颗权值线段树，线段树中的节点表示该前缀中【L~R】的数的个数，root【i】为第i棵线段树的根。

运用可持久化数据结构，多棵线段树可以共享节点。

代码
```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
#define mid ((l+r)>>1)
using namespace std;
inline long long read(){
    long long num=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')    f=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        num=num\*10+ch-'0';
        ch=getchar();
    }
    return num\*f;
}

long long \*que;
long long \*f;
long long \*rt;
long long \*ls;
long long \*rs;
long long \*sum;
long long tot;

void build(long long int &o,int l,int r){
    o=++tot;
    sum[o]=0;
    if(l==r)    return;
    build(ls[o],l,mid);
    build(rs[o],mid+1,r);
}

void update(long long &o,int l,int r,int last,long long p){
    o=++tot;
    ls[o]=ls[last];
    rs[o]=rs[last];
    sum[o]=sum[last]+1;
    if(l==r)    return;
    if(p<=mid)    update(ls[o],l,mid,ls[last],p);
    else         update(rs[o],mid+1,r,rs[last],p);
}

long long query(int from,int to,int l,int r,long long k){
    if(l==r)    return l;
    long long cnt=sum[ls[to]]-sum[ls[from]];
    if(k<=cnt)    return query(ls[from],ls[to],l,mid,k);
    else         return query(rs[from],rs[to],mid+1,r,k-cnt);
}

int main(){
    int n=read(),m=read();
    que=new long long[n+10];
    f=new long long[n+10];
    rt=new long long [n\*20];
    ls=new long long [n\*20];
    rs=new long long [n\*20];
    sum=new long long [n\*20];
    for(int i=1;i<=n;++i){
        que[i]=read();
        f[i]=que[i];
    }
    sort(f+1,f+n+1);
    int size=unique(f+1,f+n+1)-(f+1);
    build(rt[0],1,size);
    for(int i=1;i<=n;++i)    que[i]=lower\_bound(f+1,f+size+1,que[i])-f;
    for(int i=1;i<=n;++i)    update(rt[i],1,size,rt[i-1],que[i]);
    int from,to,num;
    for(int i=1;i<=m;++i){
        from=read();to=read();num=read();
        int ans=query(rt[from-1],rt[to],1,size,num);
        printf("%lld\n",f[ans]);
    }
    return 0;
}

---


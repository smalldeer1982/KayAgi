# 【模板】可持久化线段树 1（可持久化数组）

## 题目背景

**UPDATE : 最后一个点时间空间已经放大**

2021.9.18 增添一组 hack 数据 by @panyf

标题即题意

有了可持久化数组，便可以实现很多衍生的可持久化功能（例如：可持久化并查集）

## 题目描述

如题，你需要维护这样的一个长度为 $ N $ 的数组，支持如下两种操作：


1. 在某个历史版本上修改某一个位置上的值。

2. 访问某个历史版本上的某一位置的值。


此外，每进行一次操作，就会生成一个新的版本。版本编号即为当前操作的编号（从 $1$ 开始编号，版本 $0$ 表示初始状态数组）。

**对于操作 $2$，即为生成一个完全一样的版本，不作任何改动**。即，询问生成的版本是询问所访问的那个版本的复制。

## 说明/提示

### 数据规模

对于 $30\%$ 的数据，$ 1 \leq N, M \leq {10}^3 $。

对于 $50\%$ 的数据，$ 1 \leq N, M \leq {10}^4 $。

对于 $70\%$ 的数据，$ 1 \leq N, M \leq {10}^5 $。

对于 $100\%$ 的数据：

- $ 1 \leq N, M \leq {10}^6$；
- $1 \leq p \leq N$；
- 设当前是第 $x$ 次操作，$0 \leq v < x$；
- $-{10}^9 \leq a_i,c  \leq {10}^9$。

### 样例说明

所有操作结束后，总共生成了 $11$ 个版本，编号为 $0 \sim 10$，依次为：

版本 $0$：`59 46 14 87 41`，

版本 $1$：`59 46 14 87 41`，

版本 $2$：`14 46 14 87 41`，

版本 $3$：`57 46 14 87 41`，

版本 $4$：`88 46 14 87 41`，

版本 $5$：`88 46 14 87 41`，

版本 $6$：`59 46 14 87 41`，

版本 $7$：`59 46 14 87 41`，

版本 $8$：`88 46 14 87 41`，

版本 $9$：`14 46 14 87 41`，

版本 $10$：`59 46 14 87 91`。

## 样例 #1

### 输入

```
5 10
59 46 14 87 41
0 2 1
0 1 1 14
0 1 1 57
0 1 1 88
4 2 4
0 2 5
0 2 4
4 2 1
2 2 2
1 1 5 91```

### 输出

```
59
87
41
87
88
46```

# 题解

## 作者：hyfhaha (赞：592)

本篇blog主要是给自己（大家）看的。

感谢[longlongzhu123](https://www.luogu.org/space/show?uid=57525)奆佬（此人初二LCT）的指点，使本蒟蒻可以快速开始主席树入门。

# what is 主席树？
$ \ \ \ \ \ \ \ $主席树这个名字只不过是OIer们在思考政(zhe)治(xue)的时候发明的好(du)听(liu)的名字。其实主席树的大名叫“可持久化线段树”，一听这名字就知道主席树很毒瘤，所以他的发明者叫黄嘉泰（hjt***(什么鬼啊?)）。

### 分步理解“可持久化线段树”
$ \ \ \ \ \ \ \ $首先我们先来理解人尽皆知的小名“主席树”，我们可以先看到“主席”这两个字，嗯，很好，很霸气，读起来朗朗上口，所以我们可以知道主席树是一个很**霸气**的东西，~~以上扯淡~~。再来看“树”，从这个字我们可以看出主席树的本质是一棵树，那是一棵什么树，结什么果呢，下面看主席树的大名“可持久化线段树”。

$ \ \ \ \ \ \ \ $看“可持久化”这四个字，很好理解，主席树十分**持久**，因为它可持久化。那什么叫持久呢，“可持久化”定义：可以支持回退，访问之前版本的数据结构；支持回退操作的意思就是可以访问未经过其他操作的版本，也就是说返回到了以前的版本。那么我们继续看“线段树”这几个字眼，十分熟悉！相信大家肯定学过线段树，如果没学过$\color{red} \large \text{线段树}$的话，那就可以跳过这篇blog了。我们可以知道主席树是基于**线段树**的一种**数据结构**WOW。

$ \ \ \ \ \ \ \ $综上所述，主席树是一种~~霸气的~~，持久的，基于线段树的**数据结构**。

------------
## 主席树基本原理
$ \ \ \ \ \ \ \ $前文说了，线段树与主席树的本质是一样的，只不过主席树可持久化，那么难点就在于怎么支持可持久化。

$ \ \ \ \ \ \ \ $我们想要支持回退操作就可以对每一次修改操作都进行一次复制，将未进行操作的线段树版本进行复制，再对原线段树版本进行修改，那么我们就可以访问到旧版本的线段树了。不过现在问题来了，这样的空间复杂度将会乘上一个m，变成O(n*m)。不用说，肯定会陷入mle中不可自拔。

$ \ \ \ \ \ \ \ $那我们来分析一下单点修改的线段树：![主席树1](https://cdn.luogu.com.cn/upload/pic/46128.png)

$ \ \ \ \ \ \ \ $我们发现只有橙颜色经过的结点才被修改过。那么我们就可以思考，我们可不可以只对这些节点进行修改呢？答案当然是可以的，主席树的基本思想就是只对进行修改的结点进行复制。那么主席树是长什么样子的呢，下面一起来看一下吧。![主席树2](https://cdn.luogu.com.cn/upload/pic/46147.png)

$ \ \ \ \ \ \ \ $看着怎么恶心的图，相信大家还是可以发现这个图中主席树的一些性质：

1、每一次修改增加的节点个数为log(n)。

2、增加的非叶子结点会连向一个是其他版本的节点，一个是连向新节点。

3、主席树有很多根……

4、对于每一个根都可以构成一棵完整的线段树。

5、每一个节点都有可能有不只一个爸爸……

$ \ \ \ \ \ \ \ $所以我们可以知道主席树只会对部分节点进行复制，并且每一次复制的节点个数是log(n)。我们每一次想询问一个版本的线段树，就可以在那个版本的根构成的线段树中询问。

但同时也延伸出许多问题：

1、怎么构建新节点？怎么给新节点编号？怎么连边？

2、怎么访问子节点？

3、怎么存根？

$ \ \ \ \ \ \ \ $很明显这些问题在线段树中完全不会出现，我们可以感觉到主席树在建树的代码中会和线段树不同。

现在给出刚才问题的答案：

1、直接开一块内存池存新节点。编号为此时总节点数个数+1。开结构体存子节点编号；线段树建什么边，一指了事。

2、访问子节点编号，不是像线段树一样乘2或乘2+1，而是在结构体存子节点编号。

3、另外开个数组存。

------------

代码主要和线段树差不多，下面就看代码吧。

# 代码  P3919 【模板】可持久化数组

所以我们定义一个节点要存三个信息：左儿子，右儿子，权值
```cpp
struct kkk{
	int l,r,val;
}tree[maxn];
```
新建节点：
```cpp
int clone(int node){
	top++;
	tree[top]=tree[node];//全部信息都传到新节点
	return top;
}
```
建树其实就是新建节点的过程：
```cpp
int maketree(int node,int begin,int end){
	node=++top;
	if(begin==end){
		tree[node].val=a[begin];
		return top;
	}
	int mid=(begin+end)>>1;
	tree[node].l=maketree(tree[node].l,begin,mid);
	tree[node].r=maketree(tree[node].r,mid+1,end);
	return node;
}
```
更新和线段树很像：
```cpp
int update(int node,int begin,int end,int x,int val){
	node=clone(node);	//更新就要新建节点 
	if(begin==end){
		tree[node].val=val;
	}else{
		int mid=(begin+end)>>1;
		if(x<=mid)
			tree[node].l=update(tree[node].l,begin,mid,x,val);	//访问左子树 
		else
			tree[node].r=update(tree[node].r,mid+1,end,x,val);	//访问右子树 
	}
	return node;
}
```
询问也一样：
```cpp
int query(int node,int begin,int end,int x){
	if(begin==end){
		return tree[node].val;
	}else{
		int mid=(begin+end)>>1;
		if(x<=mid)
			return query(tree[node].l,begin,mid,x);	//访问左子树 
		else
			return query(tree[node].r,mid+1,end,x);	//访问右子树 
	}
}
```
那么主席树的操作部分就写完了QwQ

再来看主程序，里面看根怎么存储：
```cpp
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	root[0]=maketree(0,1,n);	//root[i]为i版本的根编号，刚开始编号为0 
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&rt,&mode,&x);
		if(mode==1){
			scanf("%d",&y);
			root[i]=update(root[rt],1,n,x,y);	//保存版本 
		}
		else{
			printf("%d\n",query(root[rt],1,n,x));	//输出 
			root[i]=root[rt];					//新建版本 
		}
	}
}
```
那么这道题就写完了。~~（其实我觉得一看图就懂了，代码什么的都是假的）~~

---

## 作者：Elegia (赞：132)

虽然这违反了模板的本意，但是本人认为这种做法也会对应于一类特别的题目。即考虑离线做法。


考虑到每一个版本都被一些版本所依赖，这种依赖关系可以被当做一棵树。在读入时建树，最后进行操作时就是将树从原点0处进行dfs。

对于询问直接存进答案数组，对于修改操作，进行修改后再dfs，结束后再撤回修改。


这种思路可以过掉部分题目，但前提是操作可逆，所以不能过掉诸如可持久化并查集的题目。


```cpp
#include <cstdio>

using namespace std;

struct edge {
    int v;
    edge* next;
};

const int N = 1000010;

int n, m;
int a[N], ans[N], op[N], k[N], x[N];
edge* g[N];

void add_edge(int u, int v);
void dfs(int u);

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i)
        scanf("%d", &a[i]);
    op[0] = 2;
    for (int i = 1; i <= m; ++i) {
        int v;
        scanf("%d%d%d", &v, &op[i], &k[i]);
        if (op[i] == 1)
            scanf("%d", &x[i]);
        add_edge(v, i);
    }
    dfs(0);
    for (int i = 1; i <= m; ++i)
        if (op[i] == 2)
            printf("%d\n", ans[i]);
    return 0;
}

void dfs(int u) {
    if (op[u] == 2) {
        ans[u] = a[k[u]];
        for (edge* p = g[u]; p; p = p->next)
            dfs(p->v);
    } else {
        int ori = a[k[u]];
        a[k[u]] = x[u];
        for (edge* p = g[u]; p; p = p->next)
            dfs(p->v);
        a[k[u]] = ori;
    }
}

void add_edge(int u, int v) {
    static edge pool[N];
    static edge* p = pool;
    p->v = v;
    p->next = g[u];
    g[u] = p;
    ++p;
}

```

---

## 作者：lzx1999 (赞：78)

## 一个不知道是什么的算法，算是维护半个并查集吧
我看到这道题是第一眼发现这不是就是主席树，然后看题解都是什么划分数，主席树，可持久化平衡树(:认真 ~~我真的翻完所有的题解，没有看到一个思路和我一样的~~)。

然后想了想感觉按照主席树的写法有点浪费空间，然后我就想用vector去模拟一下链表，存一下修改的值
```cpp
vector<int> a[maxn + 5], b[maxn + 5];
int pr[maxn + 5], f[maxn + 5];
```
先介绍一下变量的用途吧，主要的操作就是依照上面的那些东西

其实最开始我是想用pair但是不知道怎么写可以用lower_bound直接搜所以我开了两个数组a数组存的是第几代，b数组存的是a数组表示第几代的那一次的操作数

pr数组存的就是并查集的祖先，至于为什么前面我说这是维护半个并查集就是因为我不会用到合并路径的操作，也就是锁pr数组里只会存第i个版本依存的vi的版本的编号，其实感觉要是数据强的话我这样写会T掉，毕竟没有合并路径

f数组存的是当前操作是否被修改(默认0版本是没有被修改的,所以我特判了一下0，因为只有在编号为0的版本中相当于所有的数都是被修改过的)，如果没有被修改则存0，若是被修改过那f数组就存下来是这一行哪一个数被修改过了

...cpp/* 假装一个cpp格式 */

//下面仅仅包含处理工作也就是说查询操作不讲该怎么输出,输出操作我写到代码注释里面了

...

先分析一下题意，如果对于一次查询操作，那么这个数组是不会被改变的，所以说我就让
```cpp
pr[i] = vi;//i是第i个版本,vi是这一个版本依存的上一个版本
 f[i] = 0;//我在代码中没有写，因为可以不写，不过这个就代表这个版本是查询操作留下了的版本
```
然后我就可以不用管这一版本，也就是说不用为这一版本新存一下，直接留一个索引到上一个版本就行

对于修改操作如下
```cpp
pr[i] = vi;  //如上
 f[i] = loci //第i个版本中第loci个位置被修改了
 a[loci].push_back(i); 
 b[loci].push_back(vaule);//a,b两个数组存的是第i个版本中存下来vaule，只有这个位置是可以不用管和祖先的关系，如果查询到第i个版本中的f[i]为真，并且查询到第loci这个位置就可以直接返回b的值了
 ```

我来分析一下样例 数目太多我就分享一下后5次操作//本来像分析前五次操作，但是发现前五次操作没有什么好分析的
![](https://cdn.luogu.com.cn/upload/pic/59326.png)

这个是我样例弄完之后的存储状况，空白的就相当于没有

![](https://cdn.luogu.com.cn/upload/pic/59327.png)

对于第六次，第七次查询的是0版本没有什么好说的

第八次查询操作时第四个版本

所以说pr[8] = 4, f[8] = 0;

第九次和上一次一样

第十次就是对第一版本的进行第五个书修改

所以pr[10] = 1, f[10] = 5;

然后再a[5]和b[5]后面分别加入一个10和91表示第十个版本更新成91


```cpp
#include <bits/stdc++.h> 
using namespace std;

const int maxn = 1e6;
vector<int> a[maxn + 5], b[maxn + 5];
int pr[maxn + 5], f[maxn + 5];

int32_t main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);// 这个就不说什么意思了
    int n, m, x, vi, op, l, v; cin >> n >> m; // 读入操作
    for(int i = 1 ; i <= n ; i ++)
    {
        cin >> x;
        a[i].push_back(0);
        b[i].push_back(x);
    }//处理最初的数组值，而且最初时第0代
    for(int i = 1 ; i <= m ; i ++)
    {
        cin >> vi >> op >> l;
        pr[i] = vi; // 表示第i代版本是由第vi代版本继承而来
        if(op == 1) 
        {
             cin >> v;
             a[l].push_back(i);
             b[l].push_back(v); // 对于a和b应往最后加一个这是第i代版本(为了后面查找方便)，和这个版本第l个位置的值
             f[i]  = l; //表示第i行第l个数被修改了
        }
        else
        {
			while(true) // 神奇的while(true)
			{
				int x = vi;
				if(x == 0) // 如果这个版本的所依赖的为0就直接输出第0个元素
				{
					cout << b[l][0] << endl;
					break;
				}
				else if(f[x] == l) // 如果这个当前版本所依赖的版本时被修改过的，并且修改的是第l列就二分查找a[l]数组找到出现过的版本的位置
				{
					int y = lower_bound(a[l].begin(), a[l].end(), vi) - a[l].begin();
					if(y + a[l].begin() == a[l].end()) y -= 1; // 如果没有就减1，应该有,加不加这一行是不是过的我也不清楚
					cout << b[l][y] << endl;
					break;
				}
				else
				{
					vi = pr[vi]; // 并查集的操作，一步一步往上找，不过不能合并路径(其实可以只是这样写会麻烦一点，而且不写就可以过,所以我就没有写)
				}
			}
        }
        
    }
    return 0;
}

```

### 感觉我写的这个有点迷，不知道改怎么题现我的思路，如果对于这份题解有问题的话可以私信我

---

## 作者：panda_2134 (赞：54)

这里介绍一种使用STL混分的方法，按照现在的NOI Linux环境，比赛里面也可以通过评测。

导入ext/rope，就白送一个可持久化数组233

不过常数有点大就是了，这个题目似乎要求比较严格，只能拿80。详见代码：

```cpp
#include <cstdio>
#include <cstring>
#include <cctype>
#include <ext/rope>
using namespace std;
using namespace __gnu_cxx;
const int MAXM = 1e6;
int N,M;
rope<int> *S[MAXM+10];
inline int readint(){
    int f=1,r=0;char c=getchar();
    while(!isdigit(c)){if(c=='-')f=-1; c=getchar();}
    while(isdigit(c)){r=r*10+c-'0';c=getchar();}
    return f*r;
}
int main(){
    N=readint();M=readint();
    S[0]=new rope<int>();
    S[0]->append(0);
    for(int i=1;i<=N;i++)
        S[0]->append(readint());
    for(int i=1;i<=M;i++){
        int v,k,a,b;
        v=readint();k=readint();
        S[i]=new rope<int>(*S[v]);//从指定版本生成新版本（只换根）
        if(k==1) {
            a=readint();b=readint();
            S[i]->replace(a,b);
        } else {
            a=readint();
            printf("%d\n",S[i]->at(a));
        }
    }
}
```

---

## 作者：pigeonN (赞：37)

听说stl拓展的rope过不了，那我们就手撸一个吧（笑

（这个rope是没有再平衡功能的版本，不过也能过

我们先看看基本rope的节点结构
```cpp
template<typename T> class RopeNode
{
    friend class Rope<T>;
private:
    RopeNode<T>() = default;
    RopeNode<T>(T t);
    RopeNode<T>(vector<T> & s);
    int Height = 0;//用于平衡操作
                   //不过基于本题实践，不平衡也是可以的
                   //所以下面不会包含再平衡操作
    int Size = 0;
    int Begin = 0;//维护的串在Data中的开始下标
                  //只在叶子节点中可能不为0
    RopeNode<T>* Lson = nullptr;
    RopeNode<T>* Rson = nullptr;
    vector<T>* Data = nullptr;//只在叶子节点不为空指针
};
```

可以看出rope是一颗二叉树，并且维护串的大小以及节点高度。

我们再来看看rope所支持的基本操作

1，Connect 返回将两个rope连接后的结果，不改变原来的两个串，我们保证这个操作花费常数时间，接下来看代码。
```cpp
template<typename T>
RopeNode<T> * Rope<T>::Connect(RopeNode<T> * Left, RopeNode<T> * Right)
{
    if (Left == nullptr) return Right;
    if (Right == nullptr) return Left;
    if (GetHeight(Left->Lson) > GetHeight(Left->Rson) && GetHeight(Left->Lson) > GetHeight(Right))
    {
        return UncheckConnect(Left->Lson, UncheckConnect(Left->Rson, Right));
    }
    if (GetHeight(Right->Rson) > GetHeight(Right->Lson) && GetHeight(Right->Rson) > GetHeight(Left))
    {
        return UncheckConnect(UncheckConnect(Left, Right->Lson), Right->Rson);
    }
    //上述两个if是检查是否能将其中一个串放到另一个串的子树中，并不增加树的高度
    return UncheckConnect(Left, Right);
}

```
```cpp
template<typename T>
RopeNode<T> * Rope<T>::UncheckConnect(RopeNode<T> * Left, RopeNode<T> * Right)
{
    RopeNode<T>* ConnectNode = new RopeNode<T>();
    ConnectNode->Lson = Left;
    ConnectNode->Rson = Right;
    ConnectNode->Height = max(GetHeight(Left), GetHeight(Right)) + 1;//高度信息可以不维护，不过为了说明这玩意是可以进行平衡的，我就暂且保留这部分了
    ConnectNode->Size = GetSize(Left) + GetSize(Right);
    MemoryPool.push_back(ConnectNode);
    return ConnectNode;
}
```

2 Substring 返回一个子串，不改变原来的串，这个操作将花费O（height）的时间，看代码。
```cpp
template<typename T>
RopeNode<T> * Rope<T>::Substring(RopeNode<T> * R, int Start, int Len)
{
    if (R == nullptr) return R;
    if (Start <= 0 && Len >= GetSize(R)) return R;
    if (R->Data != nullptr)
    {
        RopeNode<T>* SubNode = new RopeNode<T>(*R);
        SubNode->Begin = R->Begin + (Start > 0 ? Start : 0);
        SubNode->Size = min(R->Size, Len);
        return SubNode;
    }
    RopeNode<T>* Left, *Right;
    if (Start + Len <= GetSize(R->Lson))return Substring(R->Lson, Start, Len);
    if (Start >= GetSize(R->Lson)) return Substring(R->Rson, Start - GetSize(R->Lson), Len);
    Left = Substring(R->Lson, Start, GetSize(R->Lson) - Start);
    Right = Substring(R->Rson, 0, Len - (GetSize(R->Lson) - Start));
    return Connect(Left, Right);
}
```
这个操作就很容易看懂了，不多加说明。

有了两个基本操作之后我们就可以编写我们需要的Change和Fetch操作了

Change操作
```cpp
template<typename T>
RopeNode<T>* Rope<T>::Change(RopeNode<T>* R, int Index, T t)
{
    if (Index < 0 || Index >= GetSize(R)) return R;
    RopeNode<T>* Left = nullptr, *Right = nullptr;
    if (Index > 0) Left = Substring(R, 0, Index);
    if (Index < GetSize(R) - 1) Right = Substring(R, Index + 1, GetSize(R) - Index - 1);
    RopeNode<T>* MidRope = new RopeNode<T>(t);
    MemoryPool.push_back(MidRope);
    return Connect(Left, Connect(MidRope, Right));
}
```
Fetch操作

```cpp
template<typename T>
T Rope<T>::Fetch(RopeNode<T> * R, int Index)
{
    if (R->Data != nullptr) return (*(R->Data))[R->Begin + Index];
    if (Index >= GetSize(R->Lson))
    {
        return Fetch(R->Rson, Index - GetSize(R->Lson));
    }
    else return Fetch(R->Lson, Index);
}
```

可以看出rope的所有操作都不会改变原本的串，这是一个函数式的数据结构。

至于如何查询对应版本则和其他做法一样，保存对应版本的根即可。

以下是完整AC代码

```cpp
#define _CRT_SECURE_NO_WARNINGS
#pragma once
#include<vector>
#include<algorithm>
#include<stdio.h>
using std::vector;
template<typename T> class Rope;
template<typename T> class RopeNode
{
    friend class Rope<T>;
private:
    RopeNode<T>() = default;
    RopeNode<T>(T t);
    RopeNode<T>(vector<T> & s);
    int Height = 0;
    int Size = 0;
    int Begin = 0;
    RopeNode<T>* Lson = nullptr;
    RopeNode<T>* Rson = nullptr;
    vector<T>* Data = nullptr;
};
template<typename T> class Rope
{
public:
    void MakeEmpty();
    RopeNode<T>* Init(vector<T>& v);
    T Fetch(RopeNode<T>* R, int Index);
    RopeNode<T>* Change(RopeNode<T>* R, int Index, T t);
    inline int GetHeight(RopeNode<T>* R);
    inline int GetSize(RopeNode<T>*R);
    RopeNode<T>* Connect(RopeNode<T>* Left, RopeNode<T>* Right);
    RopeNode<T>* UncheckConnect(RopeNode<T>* Left, RopeNode<T>* Right);
    RopeNode<T>* Substring(RopeNode<T>* R, int Start, int Len);
    vector<RopeNode<T>*>  MemoryPool;
};

#define max(x,y) (x)>(y)?(x):(y)
#define min(x,y) (x)<(y)?(x):(y)
template<typename T>
RopeNode<T>::RopeNode(T t)
    :Size(1)
{
    Data = new vector<T>{ t };
}
template<typename T>
RopeNode<T>::RopeNode(vector<T> & s)
    :Size(s.size())
{
    Data = new vector<T>(s);
}
template<typename T>
void Rope<T>::MakeEmpty()
{
    for (auto i : MemoryPool)
    {
        if (i != nullptr) delete i->Data;
        delete i;
    }
    MemoryPool.clear();
}

template<typename T>
RopeNode<T>* Rope<T>::Init(vector<T>& v)
{
    MakeEmpty();
    RopeNode<T>* R = new RopeNode<T>(v);
    MemoryPool.push_back(R);
    return R;
}

template<typename T>
inline int Rope<T>::GetHeight(RopeNode<T> * R)
{
    return R ? R->Height : -1;
}

template<typename T>
inline int Rope<T>::GetSize(RopeNode<T> * R)
{
    return R ? R->Size : 0;
}

template<typename T>
RopeNode<T> * Rope<T>::Connect(RopeNode<T> * Left, RopeNode<T> * Right)
{
    if (Left == nullptr) return Right;
    if (Right == nullptr) return Left;
    if (GetHeight(Left->Lson) > GetHeight(Left->Rson) && GetHeight(Left->Lson) > GetHeight(Right))
    {
        return UncheckConnect(Left->Lson, UncheckConnect(Left->Rson, Right));
    }
    if (GetHeight(Right->Rson) > GetHeight(Right->Lson) && GetHeight(Right->Rson) > GetHeight(Left))
    {
        return UncheckConnect(UncheckConnect(Left, Right->Lson), Right->Rson);
    }
    return UncheckConnect(Left, Right);
}

template<typename T>
T Rope<T>::Fetch(RopeNode<T> * R, int Index)
{
    if (R->Data != nullptr) return (*(R->Data))[R->Begin + Index];
    if (Index >= GetSize(R->Lson))
    {
        return Fetch(R->Rson, Index - GetSize(R->Lson));
    }
    else return Fetch(R->Lson, Index);
}

template<typename T>
RopeNode<T>* Rope<T>::Change(RopeNode<T>* R, int Index, T t)
{
    if (Index < 0 || Index >= GetSize(R)) return R;
    RopeNode<T>* Left = nullptr, *Right = nullptr;
    if (Index > 0) Left = Substring(R, 0, Index);
    if (Index < GetSize(R) - 1) Right = Substring(R, Index + 1, GetSize(R) - Index - 1);
    RopeNode<T>* MidRope = new RopeNode<T>(t);
    MemoryPool.push_back(MidRope);
    return Connect(Left, Connect(MidRope, Right));
}

template<typename T>
RopeNode<T> * Rope<T>::UncheckConnect(RopeNode<T> * Left, RopeNode<T> * Right)
{
    RopeNode<T>* ConnectNode = new RopeNode<T>();
    ConnectNode->Lson = Left;
    ConnectNode->Rson = Right;
    ConnectNode->Height = max(GetHeight(Left), GetHeight(Right)) + 1;
    ConnectNode->Size = GetSize(Left) + GetSize(Right);
    MemoryPool.push_back(ConnectNode);
    return ConnectNode;
}

template<typename T>
RopeNode<T> * Rope<T>::Substring(RopeNode<T> * R, int Start, int Len)
{
    if (R == nullptr) return R;
    if (Start <= 0 && Len >= GetSize(R)) return R;
    if (R->Data != nullptr)
    {
        RopeNode<T>* SubNode = new RopeNode<T>(*R);
        SubNode->Begin = R->Begin + (Start > 0 ? Start : 0);
        SubNode->Size = min(R->Size, Len);
        return SubNode;
    }
    RopeNode<T>* Left, *Right;
    if (Start + Len <= GetSize(R->Lson))return Substring(R->Lson, Start, Len);
    if (Start >= GetSize(R->Lson)) return Substring(R->Rson, Start - GetSize(R->Lson), Len);
    Left = Substring(R->Lson, Start, GetSize(R->Lson) - Start);
    Right = Substring(R->Rson, 0, Len - (GetSize(R->Lson) - Start));
    return Connect(Left, Right);
}
Rope<int> Array;
vector<RopeNode<int>*> Root;
int main(void)
{
    int n, m, i;
    vector<int> init;
    scanf("%d %d", &n, &m);
    for (i = 0; i < n; ++i)
    {
        int t;
        scanf("%d", &t);
        init.push_back(t);
    }
    Root.push_back(Array.Init(init));
    for (i = 0; i < m; ++i)
    {
        int ver, opt, loc, val;
        scanf("%d %d %d", &ver, &opt, &loc);
        if (opt == 2)
        {
            printf("%d\n", Array.Fetch(Root[ver], loc-1));
            Root.push_back(Root[ver]);
        }
        else
        {
            scanf("%d", &val);
            Root.push_back(Array.Change(Root[ver], loc-1, val));
        }

    }
    Array.MakeEmpty();
}
```




---

## 作者：Fading (赞：30)

可持久化数组，可以访问历史版本的数组。

我们考虑使用可持久化数据结构——主席树，如果不理解可以左转模板。

主席树对数组的每一个前缀建树。我们都知道其中$root$数组表示前缀$1..i$主席树的根。
那我们现在换一种方式建树，我们对每一次操作带来的版本建线段树，维护数组的权值。

什么意思呢？看图(我们设这个数组为a={1,2,3,4})：

![](https://cdn.luogu.com.cn/upload/pic/29608.png)

我们发现，这棵线段树叶子节点的权值就是它所对应数组内数的权值，这和普通线段树是类似的。

### 但是我们令非叶子节点的权值为空。这只是为了方便二分查找而设置的。

所以我们在查询数组内数的值时，直接单点询问就可以了，时间复杂度$O(logN)$

```
int query(int rt,int l,int r,int kkk){
    if (l==r) return tree[rt].sum;
    int mid=(l+r)>>1;
    if (kkk<=mid) return query(tree[rt].l,l,mid,kkk);
    else return query(tree[rt].r,mid+1,r,kkk);
}
主程序内：
query(树根,1,n,访问数组的下标);

```
我们令初始状态为第$0$个状态，这个树根即为$root[0]$。
如果我们把$a[4]$改为$5$呢？我们新建一个根$root[1]$

和主席树一样，数组$a[1]$、$a[2]$没有变化，直接连接，和主席树一样。

![](https://cdn.luogu.com.cn/upload/pic/29609.png)

创造右节点。

![](https://cdn.luogu.com.cn/upload/pic/29610.png)

然后$a[3]$也没有变化，连接

![](https://cdn.luogu.com.cn/upload/pic/29611.png)

随后，创造新的叶子节点($a[4]=5$)

代码和主席树神似。
```
void build(int &rt,int l,int r){
    rt=++cnt;
    if(l==r){tree[rt].sum=a[l];return;}
    int mid=(l+r)>>1;
    build(tree[rt].l,l,mid);build(tree[rt].r,mid+1,r);
}//初始建设
void update(int num,int &rt,int l,int r){
    tree[++cnt]=tree[rt]; rt=cnt; 
    int mid=(l+r)/2;
    if (l==r){tree[rt].sum=aaaa; return;}
    if (num<=mid) update(num,tree[rt].l,l,mid);
    else update(num,tree[rt].r,mid+1,r);
}//更新
```
时间复杂度$O(logN)$，我们发现，这次修改我们创造了一个新树根($root[1]$),这恰好表示了第一次修改后的状态。

这么一来，回到某一个状态，就很简单了，若要访问某一个状态i，访问或更新时直接使用$root[i]$即可。

代码如下：
```
#include<bits/stdc++.h>
#define res register int 
#define ll long long
#define jsz inline
using namespace std;
int cnt,n,a[1000660],m,root[1000660],aaaa;
jsz int read(){
    int x=0,f=1;char ch=getchar();
    while (!isdigit(ch)){
        if (ch=='-')f=-1;
        ch=getchar();
    }
    while (isdigit(ch)){
        x=x*10+ch-48;
        ch=getchar();
    }
    return x*f;
}
struct ZXT{
    int l,r,sum;
}tree[20006660];
jsz void build(int &rt,int l,int r){
    rt=++cnt;
    if(l==r){tree[rt].sum=a[l];return;}
    int mid=(l+r)>>1;
    build(tree[rt].l,l,mid);build(tree[rt].r,mid+1,r);
}
jsz void update(int num,int &rt,int l,int r){
    tree[++cnt]=tree[rt]; rt=cnt; 
    int mid=(l+r)/2;
    if (l==r){tree[rt].sum=aaaa; return;}
    if (num<=mid) update(num,tree[rt].l,l,mid);
    else update(num,tree[rt].r,mid+1,r);
}
jsz int query(int rt,int l,int r,int kkk){
    if (l==r) return tree[rt].sum;
    int mid=(l+r)>>1;
    if (kkk<=mid) return query(tree[rt].l,l,mid,kkk);
    else return query(tree[rt].r,mid+1,r,kkk);
}
int main(){
    n=read();m=read();
    for (res i=1;i<=n;i++) a[i]=read();
    build(root[0],1,n);
    for (res i=1;i<=m;i++){
        int xxxx=read();int yyyy=read();
        if (yyyy==1){
            int zzzz=read();aaaa=read();
            root[i]=root[xxxx];
            update(zzzz,root[i],1,n);
        }else{
            int zzzz=read();
            printf("%d\n",query(root[xxxx],1,n,zzzz));
            root[i]=root[xxxx];
        }
    }
}
```

---

## 作者：Treaker (赞：17)

## 指针题解来一发！！！
指针题解寥寥无几，表示不服！！！

我们就根据题意可持久化就行了！！！

之前这里我犯了一个致命错误，如下：
```cpp
void insert(node *&p,node *A,int x,int val)
{
	p = new (tail ++)node(); p = A;
	if(p -> l == p -> r) return (void)(p -> val = val);
	if(x <= mid) insert(p -> ls,A -> ls,x,val);
	else insert(p -> rs,A -> rs,x,val);
}
```
这里不能直接把A赋给p，因为我们的p带着取地址符，修改p时也会把A修改了；

修改后如下：
```cpp
void insert(node *&p,node *A,int x,int val)
{
	p = new (tail ++)node(A -> l,A -> r); p -> ls = A -> ls;p -> rs = A -> rs;p -> val = A -> val;
	if(p -> l == p -> r) return (void)(p -> val = val);
	if(x <= mid) insert(p -> ls,A -> ls,x,val);
	else insert(p -> rs,A -> rs,x,val);
}
```
也可以这样写
```cpp
void insert(node *&p,node *A,int x,int val)
{
	p = new (tail ++)node(); *p = *A;
	if(p -> l == p -> r) return (void)(p -> val = val);
	if(x <= mid) insert(p -> ls,A -> ls,x,val);
	else insert(p -> rs,A -> rs,x,val);
}
```
这样比较简洁。

全部代码如下：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N = 1000010;
inline int read()
{
	int x = 0 , f = 1;	char ch = getchar();
	while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
int n , m , a[N];
struct Segment_tree
{
	#define mid ((p -> l + p -> r) >> 1)
	struct node
	{
		node *ls , *rs;
		int l , r , val;
		node (int l = 0,int r = 0) : l(l) , r(r) {val = 0;ls = rs = NULL;}
	}*root[N << 1] , pool[N * 13] , *tail;
	void build(node *&p,int l,int r)
	{
		p = new (tail ++)node(l,r);
		if(l == r) return (void)(p -> val = a[l]);
		build(p -> ls,l,mid);
		build(p -> rs,mid+1,r);
	}
	void insert(node *&p,node *A,int x,int val)
	{
		p = new (tail ++)node(); *p = *A;
		if(p -> l == p -> r) return (void)(p -> val = val);
		if(x <= mid) insert(p -> ls,A -> ls,x,val);
		else insert(p -> rs,A -> rs,x,val);
	}
	int query(node *p,int x)
	{
		if(p -> l == p -> r) return p -> val;
		if(x <= mid) return query(p -> ls,x);
		return query(p -> rs,x);
	}
	inline void LOL()
	{
		n = read(); m = read();
		for(int i = 1;i <= n;i ++)	a[i] = read();
		build(root[0],1,n);
		for(int i = 1 , v , opt , loc , val;i <= m;i ++)
		{
			v = read(); opt = read(); loc = read();
			if(opt & 1)	val = read() , insert(root[i],root[v],loc,val);
			else printf("%d\n",query(root[v],loc)) , root[i] = root[v];
		}
	}
	Segment_tree() {tail = pool;}
}CF;
int main()
{	
	CF.LOL();
	return 0;
}
```


---

## 作者：UhhhQQQU (赞：13)

 _**前置知识：线段树**_ 

可持久化数组可以用可持久化线段树或者可持久化平衡树实现，在本篇题解中，~~因为本蒟蒻只会可持久化线段树，~~ 我们先来研究一下如何使用可持久化线段树实现可持久化数组。

>引入

首先，我们对这一题的第一想法是对每一个历史版本新建一个数组~~别注意题目标题，那不重要~~。但是，题目庞大的数据范围会使它MLE，那么，我们就需要一种数据结构来优化空间，它就是——可持久化线段树。

>原理

可持久化线段树，就是把题目中的数据，放入线段树的**叶子节点**中操作。等等，放在线段树里？？？这不是更会MLE吗？

本蒟蒻的回答：



其实是不会的。

原理是什么呢？其实，我们对于每一次修改操作，并不用多新建一个线段树，而只用新建一条从根节点到链就可以了。只用新建一条链的原因是因为我们的线段树是以叶子节点储存数据的，我们要以从根节点到这一个叶子节点上所有节点的数据新建出一条链。（如果不理解的话就联系一下线段树的修改操作）（注意：可持久化线段树是新建节点，而不是修改节点数据，因为存储历史版本）

不理解的话可以看一下下图。
![题解](https://cdn.luogu.com.cn/upload/pic/56149.png)

可持久化线段树在每一次新建操作只用新建O(logn)个节点，所以它比朴素的算法在空间上要优化多了！

>代码

其实这里还有一个关于历史版本的数组rt[]，但非常简单，就不用多说了。

```
#include<cstdio>
int n,m,rt[1000010],cnt;//cnt记录版本的序号 
struct tree{
	int ls,rs,value;
}t[21000010];
inline void read(int &x,char ch=getchar(),bool f=0)
{
	for(x=0;ch>'9'||ch<'0';f=ch=='-',ch=getchar());
	for(;ch>='0'&&ch<='9';x=(x<<3)+(x<<1)+(ch^48),ch=getchar());
	(f)&&(x=-x);
}
void build(int &point,int l,int r)
{
	point=++cnt;
	if(l==r)
	{
		read(t[point].value);
		return;
	}
	int mid=(l+r)>>1;
	build(t[point].ls,l,mid);
	build(t[point].rs,mid+1,r);
}
void change(int &point,int last,int l,int r,int pos,int value)
{
	point=++cnt,t[point]=t[last];
	if(l==r)
	{
		t[point].value=value;
		return;
	}
	int mid=(l+r)>>1;
	if(pos<=mid)change(t[point].ls,t[last].ls,l,mid,pos,value);
	else change(t[point].rs,t[last].rs,mid+1,r,pos,value);
}
int que(int point,int l,int r,int loc)
{
	if(l==r)return t[point].value;
	int mid=(l+r)>>1;
	if(loc<=mid)return que(t[point].ls,l,mid,loc);
	else return que(t[point].rs,mid+1,r,loc);
}
int main()
{
	read(n),read(m);
	build(rt[0],1,n);
	for(int i=1,last,flag,x,y,loc;i<=m;i++)
	{
		read(last),read(flag);
		if(flag==1)
		{
			read(x),read(y);
			change(rt[i],rt[last],1,n,x,y);
		}
		else
		{
			read(loc);
			printf("%d\n",que(rt[last],1,n,loc));
			rt[i]=rt[last];//注意新建的版本序号 
		}
	}
}
```

可持久化数组在可持久化算法中是一个非常重要的知识点，请大家好好记住！

~~哪一位大佬可以教我可持久化平衡树鸭。。。~~

---

## 作者：我叫小明0_0 (赞：10)

第一眼可持久化线段树...嘛，那就写吧

数组开太大交上去回全RE...长见识

```cpp
#include<bits/stdc++.h>
#define debug(x) cout<<#x<<"="<<x<<endl
using namespace std;
const int maxn = 1000009;

int rt[maxn],a[maxn];
struct sg_tree{int val,lson,rson;}node[maxn*20];
int n,m,tot;

inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}

void build(int &now,int l,int r)
{
    now=++tot;
    if(l==r){node[now].val=a[l];return ;}
    int mid=(l+r)>>1;
    build(node[now].lson,l,mid);
    build(node[now].rson,mid+1,r);
}
void insert(int &now,int last,int l,int r,int pos,int val)
{
    now=++tot;node[now]=node[last];
    if(l==r){node[now].val=val;return ;}
    int mid=(l+r)>>1;
    if(pos<=mid) insert(node[now].lson,node[last].lson,l,mid,pos,val);
    else insert(node[now].rson,node[last].rson,mid+1,r,pos,val);
}
int query(int now,int l,int r,int pos)
{
    if(l==r) return node[now].val;
    int mid=(l+r)>>1;
    if(pos<=mid) return query(node[now].lson,l,mid,pos);
    else return query(node[now].rson,mid+1,r,pos);
}

int main()
{
    n=read();m=read();
    for(int i=1;i<=n;i++) a[i]=read();
    build(rt[0],1,n);
    for(int i=1;i<=m;i++)
    {
        int ver=read(),opt=read(),pos=read();
        if(opt==1) insert(rt[i],rt[ver],1,n,pos,read());
        else printf("%d\n",query(rt[ver],1,n,pos)),rt[i]=rt[ver];
    }
    return 0;
}
```cpp
时空复杂度都是O((n+q)logn)级的

但是不强制在线的可持久化都是耍流氓，我们考虑离线

发现每个版本都有唯一一个前驱，一定组成一棵树结构

对这棵树dfs，每到一个点如果是修改就直接修改，询问就直接得到答案

离开一个点时如果是修改就改回去

总复杂度O(n)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1000009;

int first[maxn];
struct edg{int next,to;}e[maxn];
struct node{int ver,opt,pos,val;}q[maxn];
int n,m,e_sum;
int a[maxn],ans[maxn];
bool uuz[maxn];

inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void add_edg(int x,int y)
{
    e_sum++;
    e[e_sum].next=first[x];
    first[x]=e_sum;
    e[e_sum].to=y;
}

void dfs(int x)
{
    int last;
    if(q[x].opt==1) last=a[q[x].pos],a[q[x].pos]=q[x].val;
    else ans[x]=a[q[x].pos];
    for(int i=first[x];i;i=e[i].next)
    {
        int w=e[i].to;
        dfs(w);
    }
    if(q[x].opt==1) a[q[x].pos]=last;
}

int main()
{
    n=read();m=read();
    for(int i=1;i<=n;i++) a[i]=read();
    for(int i=1;i<=m;i++)
    {
        q[i].ver=read();q[i].opt=read();q[i].pos=read();
        if(q[i].opt==1) q[i].val=read();else uuz[i]=1;
        add_edg(q[i].ver,i);
    }
    dfs(0);
    for(int i=1;i<=m;i++) if(uuz[i]) printf("%d\n",ans[i]);
    return 0;
}
```cpp

---

## 作者：USSENTERPRISE (赞：6)

# $0.$ 前言
~~出题出挂了，来好好学主席树了~~

### 前置知识

线段树

没了

# $1.$ 简介

对于使用线段树，我们可以较好地解决“带修改的全局第k大（或小）问题”。但是对于某个区间进行求第k大（或小）操作就不是那么容易了。

## $1.1$ “可持久化”

可持久化一词在数据结构中十分常见。“可持久化”的意思就是“带有历史版本的”数据结构。而在我们所接触到的基本数据结构中（如数组、并查集、平衡树等）都有各自的可持久化版本。

## $1.2$ 主席树的引出

主席树，又名 **“可持久化线段树”**。~~至于为什么叫“主席树”我也不是特别明白~~。其基本状态就是一个可以查询多个历史版本的线段树。

## $1.3$ 模板题

 [P3834 【模板】可持久化线段树 1（主席树）](https://www.luogu.com.cn/problem/P3834)

>## 题目背景
>
>这是个非常经典的主席树入门题——静态区间第 $k$ 小
>
>## 题目描述
>
>如题，给定 $n$ 个整数构成的序列，将对于指定的闭区间查询其区间内的第 $k$ 小值。

>## 输入格式
>第一行包含两个正整数 $n,m$，分别表示序列的长度和查询的个数。

>第二行包含 $n$ 个整数，表示这个序列各项的数字。

>接下来 mm 行每行包含三个整数 $l,r,k$ , 表示查询区间 $[l,r]$ 内的第 $k$ 小值。

>## 输出格式

>输出包含 $m$ 行，每行一个整数，依次表示每一次查询的结果

# $2.$ 主席树

## $2.1$ 朴素思想

根据上文所说，主席树就是带有历史版本的线段树。如果要维护历史版本，最普通的思想就是建立多个完整的线段树，并在其上面进行操作。

但是很明显这个方案是不可行的。对于一个时间复杂度在 $O(nlogn)$ 级别上的算法来说，数据通常在 $10^5 - 10^6$。如果维护的历史版本过多，会导致空间复杂读过大(每个历史版本的空间都在 $n<<2$ 即 $n*4$ 的级别上)。

## $2.2$ 正解

对于每次修改，几乎没有对全局所有节点的修改。所以在进行修改时我们只需要将被修改的点建立一个新的“存档”就可以完成修改。

一般的我们只需要新建从根开始向下经过的每一个点就行了。（如下图所示）



## $2.3$ 模板题解决思路

模板题要求查询区间内第k小。根据以往经验我们可以选择运用“权值线段树”解决问题。

对于题目要求的区间查询，我们可以运用前缀和的思想解决问题，即用 $ [1,l-1] $ 中的数据与 $[1,r]$ 中的数据做差得出区间内的“权值线段树”（而不用以爆炸的复杂度为每次询问建树）

## $2.3$ 代码实现（以模板题为例）

### 主席树的建立

对于主席树我们并不能像线段树那样通过公式（$ls=now<<1,\ rs=now<<1|1$）计算出其左右儿子的下标，所以我们就需要建立起数组（或结构体解决）记录节点信息

```cpp
const int N=2e5+15;
int rt[N],ls[N<<5],rs[N<<5],sum[N<<5],tot;
```

然后就是建树了。

建树的时候对于模板题我们需要先建一个空的树，作为以后修改的基准点。

```cpp
void build(int &o,int l,int r){
	o=++tot;
	if(l==r) return;
	int mid=(l+r)>>1;
	build(ls[o],l,mid);
	build(rs[o],mid+1,r);
}
```
~~（真的和线段树建树一模一样呢（大雾））~~

### 修改

我们知道，对于一颗树，如果想要从根访问某个叶子节点，我们需要经过一条链。由于在线段树的单点修改中，我们经过链上的点都需要被修改，所以我们只需要增加这一条链的副本即可。

```cpp
	
inline int modify(int o,int l,int r,int p){
	int oo=++tot;
	ls[oo]=ls[o],rs[oo]=rs[o],sum[oo]=sum[o]+1;
	if(l==r) return oo;
	int mid=(l+r)>>1;
	if(p<=mid) ls[oo]=modify(ls[oo],l,mid,p);
	else rs[oo]=modify(rs[oo],mid+1,r,p);
	return oo;
}

```

### 模板题的查询

模板题的查询和线段树的基本相同。在查询的时候可以想象一颗线段树，每个节点的值是以 $rt[r]$ 为根的线段树相应节点的值减去 $rt[l-1]$ 为根的线段树相应节点的值（可以类比前缀合理解）

对于这样一个线段树就可以运用已有知识解决。

```cpp
inline int query(int L,int R,int l,int r,int k){
	int ans,mid=(l+r)>>1,x=sum[ls[R]]-sum[ls[L]];
	if(l==r) return l;
	if(x>=k) ans=query(ls[L],ls[R],l,mid,k);
	else ans=query(rs[L],rs[R],mid+1,r,k-x);
	return ans;
}
```


# $3.$  最重要的应用之一 —— 可持久化数组

主席树可以较好地维护一个“支持查询历史版本的”线段树，对于可持久化数组我们可以利用其支持历史版本的特点，实现可持久化

## $3.1$ 模板题

- [P3919 【模板】可持久化数组（可持久化线段树/平衡树）](https://www.luogu.com.cn/problem/P3919)

> ### 题目描述
>如题，你需要维护这样的一个长度为 NN 的数组，支持如下几种操作
>
>1. 在某个历史版本上修改某一个位置上的值
>
>2. 访问某个历史版本上的某一位置的值
>
>此外，每进行一次操作（对于操作2，即为生成一个完全一样的版本，不作任何改动），就会生成一个新的版本。版本编号即为当前操作的编号（从1开始编号，版本0表示初始状态数组）
>
>### 输入格式
>输入的第一行包含两个正整数 $N,M$, 分别表示数组长度和操作的个数
>
>第二行包含 $N$ 个整数，依次为初始状态下数组各位的值 (依次为 $a_i$, $1\leq i \leq N$ )
>
>接下来 $M$ 行包含 $3$ 或 $4$ 个整数，代表两种操作之一 ($i$ 为基于的历史版本号)：
>
>> $1.$ 对于操作 $1$ , 格式为 $ v_i\ 1\ loc_i\ value_i$ 即在版本 $v_i$ 的基础上， 将 $a_{loc_i}$ 修改为 $value_i$
>>
>> $2.$ 对于操作 $2$ , 格式为 $ v_i\ 2\ loc_i\ $ 即访问版本 $v_i$ 中 $a_{loc_i}$ 的值， 生成一样版本的对象应为 $v_i$
>
>### 输出格式
>输出包含若干行，依次为每个操作 $2$ 的结果。

## $3.2$ 解决思路

利用主席树解决

我们可以原数组存放在$rt[0]$的树的叶子节点，对于每一次修改直接修改即可

## $3.3$ 代码
```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cctype>
#include<algorithm>
#include<cmath>
#include<queue>

using namespace std;

#define rg register
#define ll long long
#define ull unsigned long long

namespace Enterprise{

	inline int read(){
		rg int s=0,f=0;
		rg char ch=getchar();
		while(not isdigit(ch)) f|=(ch=='-'),ch=getchar();
		while(isdigit(ch)) s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
		return f?-s:s;
	}
	
	const int N=1e6+15;
	int val[N<<5],rt[N],ls[N<<5],rs[N<<5],a[N],tot;
	int n,m;
	
	inline int build(int l,int r){
		int o=++tot;
		if(l==r){ val[o]=a[l];return o; }//遍历到叶子节点赋值
		int mid=(l+r)>>1;
		ls[o]=build(l,mid);
		rs[o]=build(mid+1,r);
		return o;
	}
	
	inline int change(int pre,int l,int r,int x,int v){
		int o=++tot;
		ls[o]=ls[pre],rs[o]=rs[pre],val[o]=val[pre];
		if(l==r){
			val[o]=v;//在叶子节点处修改
			return o;
		}
		int mid=(l+r)>>1;
		if(x<=mid) ls[o]=change(ls[pre],l,mid,x,v);
		else rs[o]=change(rs[pre],mid+1,r,x,v);
		return o;
	}
	
	inline int query(int now,int l,int r,int x){//与正常线段树单点查询无异
		if(l==r) return val[now];
		int mid=(l+r)>>1;
		if(x<=mid) return query(ls[now],l,mid,x);
		else return query(rs[now],mid+1,r,x);
	}
	
	inline void main(){
		n=read(),m=read();
		for(rg int i=1;i<=n;i++) a[i]=read();
		rt[0]=build(1,n);
		for(rg int i=1;i<=m;i++){
			int ver=read(),opt=read(),x=read();
			if(opt==1){
				int v=read();
				rt[i]=change(rt[ver],1,n,x,v);
			}else{
				rt[i]=rt[ver];//直接将当前版本节点编号赋成要求的版本编号。这样可以快捷地完成新建立一个和v_i相同的版本
				printf("%d\n",query(rt[ver],1,n,x));
			}
		}
	}
}

signed main(){
	Enterprise::main();
	return 0;
}
```

# $4.$ 主席树时空复杂度分析

## $4.1$ 时间复杂度

主席树的基本操作的线段树思想大体一致，时间复杂度也基本一致。

对于建树，时间复杂度为 $O(nlogn)$

由于这里查询和修改都是单点操作，所以时间复杂度为 $O(logn)$

所总体时间复杂度基本为 $O((m+n)logn)$

## $4.2$ 空间复杂度

对于 $rt[0]$ 来说，空间复杂度=正常线段树空间复杂度，即最坏 $O(4n)$

对于每次修改，由于仅修改了 $logn$ 个节点，所以所有新建版本的最坏复杂度为 $O(mlogn)$ 

## $4.3$ 小声bb

一般的对于所有节点及其对应值（如节点值，左右儿子等）我们可以开20倍空间，或者 $maxn<<5$ 处理。 ~~各位大佬肯定已经知道了~~。

---

## 作者：Prean (赞：6)

可持久化数组可以用可持久化线段树（主席树）来实现，思想很简单：单点查询每个版本。

主席树的思想也很简单：多个根，第$ i $个根的第$ i $个版本的线段树。而加入每次新建一个线段树不仅会TLE还会RE，所以主席树的思想就是：每次只修改更新的节点。

其他节点的话，你在那个版本查询就用那个版本的节点。就像两个人睡一张床，用一床被子一样。

不过由于每个版本只需要查询叶子节点的值，就只有叶子节点有权值，其他都是0（不然被卡常数是一件很香的事情）。可是每次新建点用线段树二叉树的思想很可能会MLE，所以每一个节点有三个信息：

左儿子，右儿子，以及权值。

那么代码就很简单了。
# 建树
没啥好说的，每个节点就是新增的节点，上代码：
```cpp
void build(int&a,int L,int R)
{
	a=++cnt;
	if(L==R)return(void)(val[a]=p[L]);
	int mid=L+R>>1;
	build(chi[a][0],L,mid);build(chi[a][1],mid+1,R);
}
```
$ a $当然就是该节点啦，最开始的$ a $当然就是第0个版本的根，也就是root[0]啦
# 修改
用主席树的思想修改，代码：
```cpp
void Add(int&a,int pre,int L,int R,int x,int v)
{
	a=++cnt;
	chi[a][0]=chi[pre][0];chi[a][1]=chi[pre][1];val[a]=val[pre];
	if(L==R)return(void)(val[a]=v);
	int mid=L+R>>1;
	if(x<=mid)Add(chi[a][0],chi[pre][0],L,mid,x,v);
	else Add(chi[a][1],chi[pre][1],mid+1,R,x,v);
}
```
其中$ pre $就是在哪个版本修改，那个版本的节点啦~，$ a $和上面的定义一样，$ L $和$ R $就是区间，$ x $是要修改的下标，$ v $是要修改的权值，所以：
```cpp
if(L==R)return(void)(val[a]=v);
```
# 查询
线段树的查询，代码就不给了。

不过要注意的是，假如一个版本的询问的话，别忘了：
```cpp
Ask(root[i]=root[pre],1,n,x))
```
就是要更新根节点，否则来查询这个版本（复制的$ pre $版本）就会返回0

---

## 作者：abandentsky (赞：4)

这是我做的第一道主席树的题目：
主席树:就是很多个历史版本的线段树。
       这些线段树充分服用以前的节点。
思路：主席树的模板题
      修改就是更新操作，新建一系列的点，查询操作就是正常的线段树查询
      操作。之后的复制就直接将查询的历史版本的根节点复制过去就好了。
```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 30200
#define MAXP 55
#define maxnode 50010
#define sigma_size 26
#define mod 1000000007
#define INF 0x3f3f3f3f
#define mid (l+r)/2
using namespace std;
typedef long long LL;


const int N=1000010;
int n,q,m,cnt=0;
int a[N],b[N],T[N<<5];
int sum[N<<5],Lc[N<<5],Rc[N<<5],val[N<<5];

inline int build(int l,int r)
{
    int rt=++cnt;
    if(l==r)
    {
        val[rt]=a[l];
    }
    if(l<r)
    {
        Lc[rt]=build(l,mid);
        Rc[rt]=build(mid+1,r);
    }
    return rt;
}

inline int update(int pre,int l,int r,int x,int v)
{
    int rt=++cnt;
    Lc[rt]=Lc[pre],Rc[rt]=Rc[pre],val[rt]=val[pre];
    if(l==r)
    {
        val[rt]=v;
        return rt;
    }
    if(x<=mid)
        Lc[rt]=update(Lc[pre],l,mid,x,v);
    else
        Rc[rt]=update(Rc[pre],mid+1,r,x,v);
    return rt;
}

inline int query(int o,int l,int r,int x)
{
    if(l==r)
        return val[o];
    if(x<=mid)
        return query(Lc[o],l,mid,x);
    else
        return query(Rc[o],mid+1,r,x);
}

int main(){
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    T[0]=build(1,n);
    for(int i=1;i<=m;i++){
        int pre,opt,x;
        scanf("%d %d %d",&pre,&opt,&x);
        if(opt==1){
        int v;
        scanf("%d",&v);
        T[i]=update(T[pre],1,n,x,v);
        }
        if(opt==2)
        {printf("%d\n",query(T[pre],1,n,x));T[i]=T[pre];}
    }
    return 0;
}

```


---

## 作者：FlashHu (赞：4)

~~貌似没有写非递归版的题解。。。。。。~~


首先要了解此数据结构的基础——线段树。推荐一下[这篇博客](https://www.cnblogs.com/TenosDoIt/p/3453089.html)，对线段树的基本操作讲得挺详细的。

可持久嘛！就是当出现历史版本的时候，能够非常方便地维护一个区间的历史版本。


自然，我们需要建$N$棵线段树。最粗暴的想法，对每个新版本都把原版本内容复制一遍，然后修改对应的值。这根本不用想，直接MLE+TLE。那维护历史版本又是怎样实现的呢？

对于本题，每个版本的序列，我们可以建一棵线段树来维护它，所有非叶子节点表示的是一段区间，而叶子节点就表示序列的每一个值了。


举个栗子，样例中初始版本可以长这样——

![](http://images2017.cnblogs.com/blog/1309909/201801/1309909-20180116170324365-1465450989.png)


而版本1只是查询了一下（线段树基本操作，这里不再赘述），然后跟初始版本一模一样。这就没必要复制了嘛！我们设版本$i$有一个根节点$root_i$（表示整段区间），根节点有左右儿子，那么我们直接让$root_1$的左右儿子指向$root_0$的左右儿子就好了，根本不用复制整个线段树嘛！


那再来看看修改操作。比如从版本1~2。1和0是一样的，而版本2会长这样——


![](http://images2017.cnblogs.com/blog/1309909/201801/1309909-20180116172034146-50319763.png)


有没有发现1和2真的很像？其实从前到后只改变了一个节点！那么其他相同的地方，我们可不可以共用一段内存呢？


![](http://images2017.cnblogs.com/blog/1309909/201801/1309909-20180116174004678-1770206820.png)

没错，每次创建一个新的版本时，只要新建$\log_2 n$个节点,也就是只保存从新版本的根节点到更新的那一个叶子节点的路径就可以了，不在此路径上的左/右儿子只要接原版本对应区间的对应儿子就可以啦。我们可以保证，从对应版本的根节点一定能访问到对应叶子节点的值。


下面是加入新版本的具体实现代码(我写的是非递归版）：

```cpp
#define R register int
inline void insert(R*t,R u,R l,R r,R k)
//t是当前节点指针，u是原版本对应t的节点，l、r为当前区间，k为修改点的位置
{
    R m;
    while(l!=r)
    {
        *t=++P;//为新节点分配空间，P是个外部变量
        m=(l+r)>>1;//线段树操作，计算区间中点
        if(k<=m)r=m,rc[*t]=rc[u],t=&lc[*t],u=lc[u];
        else  l=m+1,lc[*t]=lc[u],t=&rc[*t],u=rc[u];
        //上面两行很关键。（if一行）如果k在左子树中，那么右子树没有变，直接连到旧版本的对应右子树上，t、u更新为当前左子树继续。（else一行反之亦然）
    }
    in(val[*t=++P]);//读入新叶子节点的值
}
```
整个程序的代码如下

```cpp
#include<cstdio>
#include<cstring>
#define R register int
const int N=1000009,M=20000009;
int P,rt[N],lc[M],rc[M],val[M];
char I[M<<1],O[M],*fi=I,*fo=O;
bool nega;
inline void in(R&z)
{
    while(*fi<'-')++fi;
    if(*fi=='-')nega=1,++fi;
    z=*fi++&15;
    while(*fi>'-')z*=10,z+=*fi++&15;
    if(nega)nega=0,z=-z;
}
void oi(R z)
{
    if(z>9)oi(z/10);
    *fo++=z%10|'0';
}
inline void out(R z)
{
    z>0?oi(z):(*fo++='-',oi(-z));*fo++='\n';
}//上面快读快写
void build(R&t,R l,R r)//初始化建树，线段树基本操作
{
    R m;
    t=++P;
    if(l!=r)
    {
        m=(l+r)>>1;
        build(lc[t],l,m);
        build(rc[t],m+1,r);
    }
    else in(val[P]);
}
inline void insert(R*t,R u,R l,R r,R k)//更新，插入一个新路径
{
    R m;
    while(l!=r)
    {
        *t=++P;
        m=(l+r)>>1;
        if(k<=m)r=m,rc[*t]=rc[u],t=&lc[*t],u=lc[u];
        else  l=m+1,lc[*t]=lc[u],t=&rc[*t],u=rc[u];
    }
    in(val[*t=++P]);
}
inline int ask(R t,R l,R r,R k)//询问
{
    R m;
    while(l!=r)
    {
        m=(l+r)>>1;
        if(k<=m)r=m,t=lc[t];
        else  l=m+1,t=rc[t];
    }
    return val[t];
}
int main()
{
    fread(I,1,sizeof(I),stdin);
    R n,m,i,v,op,loc;
    in(n);in(m);
    build(rt[0],1,n);
    for(i=1;i<=m;++i)
    {
        in(v);in(op);in(loc);
        if(op&1)insert(&rt[i],rt[v],1,n,loc);
        else
        {
            out(ask(rt[v],1,n,loc));
            rt[i]=++P;//没错，这里的版本复制其实很简单
            lc[P]=lc[rt[v]];
            rc[P]=rc[rt[v]];
        }
    }
    fwrite(O,1,fo-O,stdout);
    fclose(stdin);fclose(stdout);
    return 0;
}
```

---

## 作者：MashPlant (赞：3)

主席树/线段树是二叉的，这样在各种区间操作的时候都很方便。但是这道题里并没有任何区间操作，其实可以设想一种多叉的主席树，查询和修改的原理都与之前完全一样。这里取了16叉，最多5次访问内存就可以得到值，常数比普通的主席树要小不少。

为了避免比较繁琐的边界讨论，可以直接把不够16的幂次的部分补0。这里我是直接补到了1<<20。这样既然数字全部确定了，便可以直接用模板来传递这个数字。当然，用不用模板是个人喜好，用模板常数会小一点，也没什么实质变化。

636ms，应该在真正实现了“可持久化树组”的提交里跑的是最快的，甚至也超过了一些常数比较大~~(io优化不足)~~的建树+dfs。

```cpp
#include <cstdio>

const int N = 1 << 20;

struct IO
{
	char p[1 << 25], *s, e[1 << 25], *t;

	IO() : s(p), t(e)
	{ fread(s, 1, sizeof p, stdin); }

	~IO()
	{ fwrite(e, 1, t - e, stdout); }

	operator int()
	{
		unsigned v = 0, j = 0;
		while (*s < '0')
			j = *s++ == '-';
		do
			v = v * 10 + *s++ - '0';
		while (*s > ' ');
		return j ? -v : v;
	}

	void print(unsigned v)
	{
		char a[16], *q = a;
		if (!v)
			*t++ = '0';
		else
		{
			if (v & 0x80000000)
				*t++ = '-', v = -v;
			while (v)
				*q++ = v % 10 + '0', v /= 10;
			while (q != a)
				*t++ = *--q;
		}
		*t++ = '\n';
	}
} io;

namespace array
{
	typedef int T;
	const int block = 16;
	union
	{
		T val[block];
		int ch[block];
	} buf[N * 6];
	int root[N], buf_sz, remain;

	template<int Len = N>
	void build(int &rt)
	{
		rt = ++buf_sz;
		for (int i = 0; i < block; ++i)
			build<Len / block>(buf[rt].ch[i]);
	}

	template<>
	void build<block>(int &rt)
	{
		rt = ++buf_sz;
		for (int i = 0; i < block && remain; ++i, --remain)
			buf[rt].val[i] = io;
	}

	template<int Len = N>
	int get(int rt, int pos)
	{
		constexpr int ch_block = Len / block;
		int which = pos / ch_block;
		return get<ch_block>(buf[rt].ch[which], pos - which * ch_block);
	}

	template<>
	int get<block>(int rt, int pos)
	{ return buf[rt].val[pos]; }

	template<int Len = N>
	int modify(int rt, int pos, int val)
	{
		constexpr int ch_block = Len / block;
		int ret = ++buf_sz, which = pos / ch_block;
		buf[ret] = buf[rt];
		buf[ret].ch[which] = modify<Len / block>(buf[rt].ch[which], pos - which * ch_block, val);
		return ret;
	}

	template<>
	int modify<block>(int rt, int pos, int val)
	{
		int ret = ++buf_sz;
		buf[ret] = buf[rt];
		buf[ret].val[pos] = val;
		return ret;
	}
} // namespace array

int main()
{
	using namespace array;
	int n = io, m = io;
	remain = n;
	build(root[0]);
	for (int i = 1, v, op, pos; i <= m; ++i)
	{
		v = io, op = io, pos = io - 1;
		if (op == 1)
			root[i] = modify(root[v], pos, io);
		else
			io.print(get(root[i] = root[v], pos));
	}
}

```

---

## 作者：ajil (赞：3)

貌似没人发可持久化平衡树的题解……我就用我自己的理解写一份好了

其实两个方法差不多，区别就是平衡树**每个节点对应着一个值**，而线段树**每个节点对应一段区间**。

建平衡树就是把某个位置的值作为节点存下，在这个位置左边的数存在该节点的左子树中，右边的存在右子树中。(代码里用了个类似splay建树的方法)

修改时跟主席树修改差不多，就是把从根节点到修改节点路径上的所有节点复制一遍，**注意这个平衡树是无旋的，否则没法(方便地)可持久化**

### (PS:这里很多人说有问题就改了一下) ### 

理论上来说平衡树的空间和时间常数应该都会小一些，但是我写的是指针版的，会比数组版的主席树要慢一点(也许是因为用指针开节点需要时间)

下面给出指针版代码，感觉会更好理解一些，数组版的直接看我的提交记录好了……

```cpp
#include <iostream>
#include <cstdio>
#include <cctype>
using namespace std;
const int Mm(1000005);
int qrd()    //快读
{
    int x(0),f(1); char c(getchar());
    while(!isdigit(c))
    {
        if(c=='-')  f=-1;
        c=getchar();
    }
    while(isdigit(c))
    { x=x*10+c-'0'; c=getchar(); }
    return x*f;
}
struct tn
{
    int s,v;    //子树大小及节点值
    tn *ls,*rs;    //左子树和右子树指针
}*ver[Mm],*null;    //版本及自定义null指针
int a[Mm];    //原数组
inline void mt(tn* p)    //维护子树大小(好像没什么用)
{ p->s = p->ls ->s + p->rs ->s + 1; }
void bud(int l,int r,tn* &p)    //以p为根节点建树
{
    if(l>r) p=null;
    else
    {
        int mid((l+r)>>1);
        p=new tn();    //开节点
        p->v = a[mid];
        bud(l,mid-1,p->ls);    //递归构建左子树
        bud(mid+1,r,p->rs);    //递归构建右子树
        mt(p);
    }
}
void mdf(tn* lv,tn* &mv,int k,int v)    //版本更新
{
    mv = new tn();
    mv->v = lv->v;
    mv->s = lv->s;
    if(lv->ls ->s+1==k)    //找到修改节点
    {
        mv->v = v;
        mv->ls = lv->ls;
        mv->rs = lv->rs;
        return;
    }
    if(lv->ls ->s+1>k)    //要修改的节点在左子树(类似于名次树)
    {
        mv->rs = lv->rs;
        mdf(lv->ls,mv->ls,k,v);
    }
    else    //要修改的节点在右子树
    {
        mv->ls = lv->ls;
        mdf(lv->rs,mv->rs,k-lv->ls ->s-1,v);
    }
}
int qry(tn* v,int p)    //查找
{
    if(v->ls ->s+1==p)  return v->v;    //找到需要查找的节点
    if(v->ls ->s+1>p)   return qry(v->ls,p);    //查找节点在左子树
    else    return qry(v->rs,p-v->ls ->s-1);    //查找节点在右子树
}
void Mido(tn* p)    //中序遍历，调试用
{
    if(p!=null)
    {
        Mido(p->ls);
        printf("%d ",p->v);
        Mido(p->rs);
    }
}
int main()
{
    int n,m;
    cin >> n >> m;
    null = new tn();
    null->ls = null->rs = null;
    for(int i(1);i<=n;++i)
        a[i] = qrd();
    bud(1,n,ver[0]);    //在0号版本以a数组建树
    int nver(0);    //当前版本
    while(m--)
    {
        int v(qrd()),opr(qrd()),p(qrd());
        if(opr==1)
        {
            int val(qrd());
            mdf(ver[v],ver[++nver],p,val);
        }
        if(opr==2)
        {
            ver[++nver] = ver[v];
            printf("%d\n",qry(ver[nver],p));
        }
        //Mido(ver[nver]);
    }
    return 0;
}
```

---

## 作者：Broadway (赞：3)

题目只要求单点修改，单点查询历史版本……所以可持久化线段树还挺好写~~虽然WA了n次~~…………注意之前我~~因为懒~~没有把新建节点传进过程里面……结果栈空间溢出交上去全MLE……这里提醒一句

~~没人会犯我这种蒟蒻才犯的错误了吧~~

因为每次修改都会增加logn个节点，最大修改次数是1000000次

n最大也是1000000，logn大概是20，所以开20倍n多一点的数组比较稳

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <climits>
using namespace std;
const int maxn=1000005;
struct Node
{
    int sum,lch,rch;
}tree[maxn*20];
int rt[maxn],tot,curver,n,m;
inline void init() { tot=0; curver=0; }
inline void up(int p) { tree[p].sum=tree[tree[p].lch].sum+tree[tree[p].rch].sum; }
inline int read()
{
    int f=1,x=0; char ch;
    do { ch=getchar(); if(ch=='-') f=-1; } while(ch<'0'||ch>'9');
    do { x=x*10+ch-'0'; ch=getchar(); } while(ch>='0'&&ch<='9');
    return f*x;
}
int build(int l,int r,int cp)
{
    tree[cp].sum=0; tree[cp].lch=-1; tree[cp].rch=-1;
    if (l==r) { tree[cp].sum=read(); return cp; }
    int m=l+r>>1;
    tree[cp].lch=build(l,m,tot++); tree[cp].rch=build(m+1,r,tot++);
    up(cp);
    return cp;
}
int update(int p,int l,int r,int x,int k,int cp)
{
    tree[cp].sum=0; tree[cp].lch=tree[p].lch; tree[cp].rch=tree[p].rch;
    if (l==r) { tree[cp].sum=k; return cp; }
    int m=l+r>>1;
    if (x<=m) tree[cp].lch=update(tree[p].lch,l,m,x,k,tot++); else tree[cp].rch=update(tree[p].rch,m+1,r,x,k,tot++);
    up(cp);
    return cp;
}
int query(int p,int l,int r,int x)
{
    if (l==r) return tree[p].sum;
    int m=l+r>>1;
    if (x<=m) return query(tree[p].lch,l,m,x); else return query(tree[p].rch,m+1,r,x);
}
int main()
{
    int v,c,s,k;
    n=read(); m=read();
    init();
    rt[curver]=build(1,n,tot++);
    for (int i=1;i<=m;i++)
    {
        v=read(); c=read(); s=read();
        if (c==1)
        {
            k=read();
            rt[++curver]=update(rt[v],1,n,s,k,tot++);
        }
        else if (c==2)
        {
            rt[++curver]=rt[v];
            printf("%d\n",query(rt[v],1,n,s));
        }
    }
    return 0;
}
```cpp

---

## 作者：yybyyb (赞：3)

挺有趣的模板诶。。。

用主席树维护一下每次数组的版本就行啦

所以先去把主席树的模板切掉再来搞这个吧。

(为什么询问也算一个版本。。。。)

询问创建新版本只要直接复制一下根节点就可以了。。。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
#define MAX 1000100
inline int read()
{
    register int x=0,t=1;
    register char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-'){t=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
    return x*t;
}
int root[MAX],a[MAX],N,M;
struct Node
{
    int l,r;
    int ls,rs;
    int val;
}t[MAX*20];
int sum=0,tot=1;
void Build(int now,int l,int r)
{
    t[now].l=l;t[now].r=r;
    if(l==r){t[now].val=a[l];return;}
    t[now].ls=++tot;
    int mid=(l+r)>>1;
    Build(tot,l,mid);
    t[now].rs=++tot;
    Build(tot,mid+1,r);
}
void AddNode(int now,int New,int k,int w)
{
    t[New]=t[now];
    if(t[now].l==t[now].r)
    {
            t[New].val=w;
        return;
    }
    int mid=(t[now].l+t[now].r)>>1;
    if(k<=mid)
    {
        t[New].ls=++tot;
        AddNode(t[now].ls,tot,k,w);
    }
    else
    {
        t[New].rs=++tot;
        AddNode(t[now].rs,tot,k,w);
    }
}
void Query(int now,int k)
{
    if(t[now].l==t[now].r)
    {
        printf("%d\n",t[now].val);
        return;
    }
    int mid=(t[now].l+t[now].r)>>1;
    if(k<=mid)Query(t[now].ls,k);
    else Query(t[now].rs,k);
}
int main()
{
    N=read();M=read();
    for(int i=1;i<=N;++i)a[i]=read();
    Build(1,1,N);
    root[0]=1;
    while(M--)
    {
        int v=read(),opt=read();
        if(opt==1)
        {
            int vv=read(),ww=read();
            AddNode(root[v],root[++sum]=++tot,vv,ww);
        }
        else
        {
            int vv=read();
            Query(root[v],vv);
            root[++sum]=root[v];
        }
    }
    return 0;
}
```

---

## 作者：陈琛 (赞：2)

来一发可持久化平衡树的题解。

由于维护区间，我们以顺序为键值建立平衡树，也就是一个节点的左子树中的节点在它左侧，右子树中的节点在它右侧。

考虑到这道题并不需要插入和删除节点，也就是说树的形态在建树以后就不会被改变，所以我们直接DFS建树就可以保证平衡，并不需要Split/Merge/Rotate之类的操作。

然后考虑可持久化。我们只需要在修改时把从根节点到修改节点的路径上的点都复制一遍即可。

由于平衡树的点数比线段树少很多，所以理论上它是比线段树快的（然而实际并没有，也许是我常数大？）

代码：

```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
struct Node{ int son[2],val,rnd; };
static Node mem[30000001];
static int null=0,cnt=0;
inline int Create(int val,int num){
	++cnt;
	mem[cnt].son[0]=mem[cnt].son[1]=null;
	mem[cnt].val=val, mem[cnt].rnd=num;
	return cnt;
}
inline int Copy(int a){ mem[++cnt]=mem[a]; return cnt; }
static int Build(int l,int r,int *a){
	register int m=l+r>>1;
	register int ret=Create(m,a[m]);
	if(l<m) mem[ret].son[0]=Build(l,m-1,a);
	if(r>m) mem[ret].son[1]=Build(m+1,r,a);
	return ret;
}
static void Update(int &root,int u,int v){
    root=Copy(root);
    if(mem[root].val==u){ mem[root].rnd=v; return; }
    if(mem[root].val<u){ Update(mem[root].son[1],u,v); return; }
    if(mem[root].val>u){ Update(mem[root].son[0],u,v); return; }
}
struct Array{
	int root[1000001];
	inline Array(){ root[0]=null; }
	inline void Init(int n,int *a){ root[0]=Build(1,n,a); }
	inline void Copy(int a,int b){ root[a]=root[b]; }
	inline void Modify(int t,int p,int v){ Update(root[t],p,v); }
	inline int Query(int t,int p){
		register int tmp=root[t];
		while(mem[tmp].val!=p){
			if(mem[tmp].val<p) tmp=mem[tmp].son[1];
			if(mem[tmp].val>p) tmp=mem[tmp].son[0];
		}
		return mem[tmp].rnd;
	}
};
static Array t;
static int a[1000001];
int main(){
	srand(1234567);
	mem[null].son[0]=mem[null].son[1]=null;
	int n,m; scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	t.Init(n,a);
	for(int i=1;i<=m;i++){
		int v,opt; scanf("%d%d",&v,&opt);
		t.Copy(i,v);
		if(opt==1){
			int p,d; scanf("%d%d",&p,&d);
			t.Modify(i,p,d);
		}else if(opt==2){
			int p; scanf("%d",&p);
			printf("%d\n",t.Query(i,p));
		}
	}
	return 0;
}
```

---

## 作者：arfa (赞：2)


 划分树是一种来解决区间第 $K$ 大的一种数据结构,其常数,理解难度都要比主席树低很多。同时,划分树紧贴"第 $K$ 大"，所以是一种基于排序的一种数据结构。**建议先学完主席树再看划分树哦**。

 ### 建树

 划分树的建树比较简单,但是相对于其他树来说比较复杂。
 ![](https://s1.ax1x.com/2018/08/31/Pvaer6.png)

 如图,每一层都有一个看似无序的数组。其实,每一个被红色标记的数字都是**要分配到左儿子的**。而分配的规则是什么?就是与**这一层的中位数**做比较, $\leq$ 左边,否则右边。但是这里要注意一下:并不是严格的 $\leq$ **左边,否则右边**。因为中位数可能有相同,而且与 $N$ 的奇偶有一定关系。下面的代码展示会有一个巧妙的运用,大家可以参照代码。

 我们不肯能每一次都对每一层排序,这样子不说常数,就算是理论复杂度也过不去。我们想,找中位数,一次排序就够了。为什么? 比如,我们求 $l,r$ 的中位数,其实就是在排完序过后的 $num[mid]$。


 两个关键数组:
 ```
 tree[log(N),N]   : 也就是树,要存下所有的值,空间复杂度 O(N log N)。
 toleft[log(N),n] : 也就是每一层 1~i 进入左儿子的数量,这里需要理解一下,这是一个前缀和。还有,这个东西不分是在哪一个节点,但是分那一层(没有关系)。 
 ```

 ```pascal
 procedure Build(left,right,deep:longint); // left,right 是左右区间,deep是第几层
 var
 	i,mid,same,ls,rs,flag:longint; // 其中 flag 是用来平衡左右两边的数量的
 begin
 	if left=right then exit; // 到底层了
 	mid:=(left+right) >> 1;
 	same:=mid-left+1;
 	for i:=left to right do 
 		if tree[deep,i]<num[mid] then
 			dec(same);

 	ls:=left; // 分配到左儿子的第一个指针
 	rs:=mid+1; // 分配到右儿子的第一个指针
 	for i:=left to right do
 	begin
 		flag:=0;
 		if (tree[deep,i]<num[mid])or((tree[deep,i]=num[mid])and(same>0)) then // 分配到左边的条件
 		begin
 			flag:=1; tree[deep+1,ls]:=tree[deep,i]; inc(ls);
 			if tree[deep,i]=num[mid] then // 平衡左右个数
 				dec(same);
 		end
 		else
 		begin
 			tree[deep+1,rs]:=tree[deep,i]; inc(rs);
 		end;
 		toleft[deep,i]:=toleft[deep,i-1]+flag;
 	end;
 	Build(left,mid,deep+1); // 继续
 	Build(mid+1,right,deep+1);
 end;
 ```

 ### 查询

 那我们先扯一下主席树的内容。在用主席树求区间第 $K$ 小的时候,我们以 $K$ 为基准,向左就向左,向右要减去向左的值,在划分树中也是这样子的。

 查询难理解的,在于**区间缩小**这种东西。下图,我查询的是 $3$ 到 $7$,那么下一层我就只需要查询 $2$ 到 $3$ 了。当然,我们定义 $left,right$ 为缩小后的区间(目标区间), $l,r$ 还是我所在节点的区间。那为什么要标出目标区间呢? 因为那是**判定答案在左边,右边的基准**。

 ![](https://s1.ax1x.com/2018/08/31/Pvduyq.png)


 ```pascal
 function Query(left,right,k,l,r,deep:longint):longint;
 var
 	mid,x,y,cnt,rx,ry:longint;
 begin
 	if left=right then // 写成 l=r 也无妨,因为目标区间也一定有答案
 		exit(tree[deep,left]);
 	mid:=(l+r) >> 1;
 	x:=toleft[deep,left-1]-toleft[deep,l-1]; // l 到 left 的去左儿子的个数
 	y:=toleft[deep,right]-toleft[deep,l-1]; // l 到 right 的去左儿子的个数
 	ry:=right-l-y; rx:=left-l-x; // ry 是 l 到 right 去右儿子的个数,rx 则是 l 到 lefr 去右儿子的个数
 	cnt:=y-x; // left 到 right 左儿子的个数
 	if cnt>=k then // 主席树常识啦
 		Query:=Query(l+x,l+y-1,k,l,mid,deep+1) // l+x 就是缩小左边界,l+y-1 就是缩小右区间。对于上图来说,就是把 1 和 2 放弃了。
 	else
 		Query:=Query(mid+rx+1,mid+ry+1,k-cnt,mid+1,r,deep+1); // 同样是缩小区间,只不过变成了右边而已。注意要 k-cnt。
 end;
 ```

 ### 理论复杂度和亲测结果

 时间复杂度 : 一次查询只需要 $O(\log\ n)$,$m$次询问,就是 $O(m\ \log\ n)$。

空间复杂度 : 只需要存储 $O(n\ \log\ n)$ 个数字。

 亲测结果:  主席树 : $1482ms$、划分树 : $889ms$。 (非递归,常数比较小)



 ### 后记

 大家可以试着去写非递归版哦。参考博文 : [传送门](https://blog.csdn.net/littlewhite520/article/details/70250722)。

---

## 作者：Leap_Frog (赞：2)

## P3919 【模板】可持久化数组（可持久化线段树/平衡树）（题解）
***
**题目传送门：**

[点我](https://www.luogu.org/problemnew/show/P3919)
***
**解题思路：**

用一棵可持久化线段树来记录数组中的树。  
~~（蒟蒻我不想写可持久化平衡树）~~
***
**题目注意点：**

1. 查询时应生成的树是查询到的那棵树
2. 注意数组范围
[~~错误QWQ~~](https://www.luogu.org/recordnew/show/16232423)
3. 这道题毒瘤地让习惯开$long long$的人$MLE$了

***
**补充：**

**可持久化线段树**
1. 可持久化定义（自行上网问[度娘](https://www.baidu.com)）
2. *如何实现可持久化：*
在每次修改结束后，建一棵新树。
3. *空间太费：*
最大限度地利用原节点。

*eg:*  
![出错了](https://cdn.luogu.com.cn/upload/pic/51566.png)

像左下方这棵树，是由中间的表格生成的。

把第三个点改动，就生成了右边这棵树。

画红色圈的就是要改动的节点。

上方这个表格，第一行是数值，第二行是左孩子，第三行是右孩子。

带绿色框的是原始节点，红色的是新增节点，读者可自行理解。

最后再用一个数组root记录每次修改后的根节点。便可实现

***
**代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=30000005,maxm=1000005;
struct data		//可持久化线段树的节点
{
	int number,lson,rson;
	data() {number=0;lson=0;rson=0;}
	data(int n,int l,int r):number(n),lson(l),rson(r) {}
};
struct zhu_tree		//可持久化线段树
{
	data tree[maxn];
	int root[maxm],tsize;
	zhu_tree()		//初值
	{
		tsize=0;
		root[0]=1;		//不要忘了！！！
	}
	inline int add_node(int x)		//把x位的节点拷贝
	{
		tsize++;
		tree[tsize]=tree[x];
		return tsize;
	}
	void build(int &now,int l,int r,int da[])		//造一棵新树
	{
		tsize++;
		now=tsize;
		if(l==r)
		{
			tree[now].number=da[l];
			tree[now].lson=0;
			tree[now].rson=0;
			return;
		}
		int mid=(l+r)>>1;
		build(tree[now].lson,l,mid,da);
		build(tree[now].rson,mid+1,r,da);
	}
	int search(int now,int l,int r,int dw)		//查找节点
	{
		if(l==r) return tree[now].number;
		int mid=(l+r)>>1;
		if(dw<=mid) return search(tree[now].lson,l,mid,dw);
		return search(tree[now].rson,mid+1,r,dw);
	}
	void insert(int old,int &now,int l,int r,int dw,int dd)		//修改节点（名字不大好，莫怪）
	{
		now=add_node(old);
		if(l==r)
		{
			tree[now].number=dd;
			return;
		}
		int mid=(l+r)>>1;
		if(dw<=mid) insert(tree[old].lson,tree[now].lson,l,mid,dw,dd);
		else insert(tree[old].rson,tree[now].rson,mid+1,r,dw,dd);
	}
}tree;
int main()
{
	int n,m,a[maxm];
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	tree.build(tree.root[0],1,n,a);
	for(int i=1;i<=m;i++)
	{
		int v,f,l,val;
		scanf("%d%d%d",&v,&f,&l);
		if(f==1)
		{
			scanf("%d",&val);
			tree.insert(tree.root[v],tree.root[i],1,n,l,val);
		}
		if(f==2)
		{
			tree.root[i]=tree.root[v];
			printf("%d\n",tree.search(tree.root[i],1,n,l));
		}
	}
	return 0;
}
```

---

## 作者：aiyougege (赞：1)

### 吐槽
我随便一写不知道算啥的做法然后就通过了.

然后我借鉴了一下Rank1的读入输出优化然后成功成为Rank1.

$\text{Interesting!}$

### Solution

这个做法是我瞎想的, 应该算不上什么数据结构吧.

- 首先用一个结构体表示一个版本, 因为一个版本对它的父亲版本至多改动一个数, 因此可以表示这个版本:

```c++
struct Node{int p,s;Node *pre;}v[N];
```
`p`表示改动的位置, `s`表示改动后的数, `*pre`表示指向父版本的指针.

注意: 初始版本的父版本指针为$\text{NULL}$.

**如何处理两种操作**:
- 每个操作都会产生一个新版本.
- 发现第二种操作不会对父版本造成任何更改, 于是将它的父版本设为它父版本的父版本.即
```c++
v[i].pre=v[fa].pre;
```
发现一个版本对其父版本改变一个数, 父版本对其父版本改变一个数, ……, 直到初始版本.	
于是可以这样往上回溯, 直到发现某个版本改变了这个位置的数, 那就结束.
- 第一种操作比较好办:
```c++
v[i]=(Node){ThePositionOfChange,TheNumberAfterChange,v+fa};
```

### Code
这个是我不加读入输出优化的版本……
```c++
#include<cstdio>
#define N 1000005
using namespace std;

int seq[N];
struct Node{int p,s;Node *pre;}v[N];

int main(){
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i)scanf("%d",&seq[i]);
    int a,b,c,d;bool flag;
    v[0].pre=NULL;
    for(int i=1;i<=m;++i){
        scanf("%d%d%d",&a,&b,&c);
        if(b==1)
            scanf("%d",&d),v[i]=(Node){c,d,v+a};
        else {
            flag=false;
            v[i]=(Node){v[a].p,v[a].s,v[a].pre};
            Node *z=v+i;
            while(z->pre){
                if(z->p==c){
                    flag=true;printf("%d\n",z->s);break;
                }
                z=z->pre;
            }
            if(!flag)printf("%d\n",seq[c]);
        }
    }
    return 0;
}
```

---

## 作者：fy0123 (赞：1)

# luogu3919 【模板】可持久化数组

## ps.
鉴于要加深一下可持久化的理解（以及帮助他人更好的理解

再来写一篇题解吧QAQ.


## 题意：

~~标题即题意（雾~~


好了简单说一下吧。

你需要维护这样的一个长度为$N$的数组，支持如下几种操作

1. 在某个历史版本上修改某一个位置上的值

2. 访问某个历史版本上的某一位置的值


## 做法：

首先我们撇开区间第k小，再来理解一下可持久化线段树的意思。

**通俗理解：**很多个线段树按照一定的顺序建立，每个线段树i都和之前的某个有一定联系，需要拷贝一些之前的信息。

比如一个简单的例子：

>维护一个数据结构，支持：
>1. 单点加
>2. 询问区间和
>3. 回到之前某个历史状态

其中第三点就是经典的可持久化应用。

解决这一类问题，简单的想法就是每个状态建立一棵线段树，拷贝之前一棵树的信息，并修改相关信息。

但是发现这样空间不够，于是我们考虑舍弃冗余状态，每次只拷贝需要修改的点，这样就能保证每次只新建log级别的点。


然后考虑这个题，发现是上面这个例子的弱化版（大雾

只要把线段树的操作改成单点修改+单点查询即可。


## 代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cctype>
#include<cstdlib>
#include<cmath>
#include<queue>
using namespace std;
typedef long long ll;

inline ll read() {
    char ch = getchar(); ll x = 0; int op = 1;
    for(; !isdigit(ch); ch = getchar()) if(ch == '-') op = -1;
    for(; isdigit(ch); ch = getchar()) x = x*10+ch-'0';
    return x*op;
}
inline void write(ll a) {
    if(a < 0) putchar('-'), a = -a;
    if(a >= 10) write(a/10); putchar('0'+a%10);
}

const int N = 1000010, M = 20000010;
int n, m, tot;
int a[N], rt[N], ls[M], rs[M], v[M];

inline void build(int &nk, int l, int r) {
    nk = ++ tot;
    if(l == r) { v[nk] = a[l]; return; }
    int mid = l+r>>1;
    build(ls[nk], l, mid); build(rs[nk], mid+1, r);
}
inline void update(int k, int &nk, int l, int r, int x, int y) {
    nk = ++ tot; ls[nk] = ls[k]; rs[nk] = rs[k]; v[nk] = v[k];
    if(l == r) { v[nk] = y; return; }
    int mid = l+r>>1;
    if(x <= mid) update(ls[k], ls[nk], l, mid, x, y);
    else update(rs[k], rs[nk], mid+1, r, x, y);
}
inline int query(int nk, int l, int r, int x) {
    if(l == r) return v[nk];
    int mid = l+r>>1;
    if(x <= mid) return query(ls[nk], l, mid, x);
    else return query(rs[nk], mid+1, r, x);
}
int main() {
    n = read(), m = read();
    for(int i = 1; i <= n; i ++) a[i] = read();
    build(rt[0], 1, n);
    for(int i = 1; i <= m; i ++) {
        int t = read(), opt = read(), x = read(), y;
        rt[i] = rt[t];
        if(opt == 1) {
            y = read(); update(rt[i], rt[i], 1, n, x, y);
        } else write(query(rt[t], 1, n, x)), puts("");
    } return 0;
}
```

## 拓展理解

别急，还没结束。。。

我们再来理解一下**区间第k小**的主席树操作吧。

仍然是可持久化线段树，但是和上面两种例子都是不太相似的。

主席树求区间第k小，我们需要建立的是权值线段树，于是需要先离散化。

在原序列上建立主席树，每一棵权值线段树i，拷贝第i-1棵线段树的信息，并在上面修改（$a_i$的权值节点上+1）。

这样我们得到的是一个类似前缀和的主席树。

于是我们可以通过$sum_r-sum_{l-1}$快速地得到某个节点所代表的权值范围，在区间[l,r]中出现的次数，从而来完成查询操作。


所以，虽说都是可持久化线段树，还是有比较大的区别的。

特别注意不要把可持久化线段树理解为就等于权值线段树~~~



\_the end\_

by bestFy 2018.1


---

## 作者：Great_Influence (赞：1)

可持续化线段树（或平衡树）模板题。

虽然如此，但我并不会打平衡树，所以如果有会打的，请也传一份题解上来。

所以我选择的是可持续化线段树。可持续化线段树的思想就是对于每个版本建立一棵线段树，强制查询。但是直接建立会导致MLE和TLE，所以每一棵树都要向前面的树“借点”。具体思想是，每次修改时没改的点不会改变，于是与改之前的树的点完全相同，便不需要重新建点了。比如改的点在树的左半区间，那么现在版本的右半区间和原版本的右半区间相同，直接将现版本的右儿子标记成原版本的右儿子，在递归解决左半区间。同时注意到查询操作并没有更改区间，所以可以直接用并查集将他与他的历史版本合并。这样可以将时间复杂度减为((n+m)logn)，空间复杂度减为((n+q)logn)(q是修改次数)。

代码：

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
using namespace std;
const int MAXN=1000010;
template<typename T>
inline void read(T &x)//读入优化
{
    T s=0,f=1;
    char k=getchar();
    while(!isdigit(k)&&k!='-')k=getchar();
    if(!isdigit(k))
    {
        f=-1;
        k=getchar();
    }
    while(isdigit(k))
    {
        s=(s<<3)+(s<<1)+(k^48);
        k=getchar();
    }
    x=s*f;
}
int n,m,t,head[MAXN];//head数组记录每棵线段树的根节点下标
struct tree//这是一个森林
{
    int v,l,r;
}p[MAXN<<5];
void make_tree(int h,int l,int r)//建树
{
    if(l==r)
    {
        read(p[h].v);
        return;
    }
    int mid=(l+r)>>1;
    make_tree(p[h].l=++t,l,mid);
    make_tree(p[h].r=++t,mid+1,r);
}
int f[MAXN];//并查集，优化空间的
int find(int x)//并查集查找
{
    int t=f[x],d;
    while(t!=f[t])t=f[t];
    while(f[x]!=t)
    {
        d=f[x];
        f[x]=t;
        x=d;
    }
    return t;
}
void change(int last,int now,int l,int r,int pos,int ch)//修改
{
    if(l==r)//找到了就直接改
    {
        p[now].v=ch;
        return;
    }
    int mid=(l+r)>>1;
    if(pos<=mid)//如果在左半区间，则右半区间等于历史版本右半区间，递归解决左半区间
    {
        p[now].r=p[last].r;
        change(p[last].l,p[now].l=++t,l,mid,pos,ch);
    }
    else//右半同上
    {
        p[now].l=p[last].l;
        change(p[last].r,p[now].r=++t,mid+1,r,pos,ch);
    }
}
int search(int h,int l,int r,int pos)//查询，没什么好讲的
{
    if(l==r)return p[h].v;
    int mid=(l+r)>>1;
    if(pos<=mid)return search(p[h].l,l,mid,pos);
    return search(p[h].r,mid+1,r,pos);
}
int main()
{
    read(n);
    read(m);
    make_tree(head[0]=++t,1,n);
    int i,v,x,y,opt;
    For(i,1,m)
    {
        read(v);
        v=find(v);
        read(opt);
        read(x);
        if(opt==1)
        {
            read(y);
            change(head[v],head[i]=++t,1,n,x,y);
            f[i]=i;//修改操作无法归到其他并查集里，所以他自己成为一个并查集
        }
        else
        {
            printf("%d\n",search(head[v],1,n,x));
            f[i]=v;//查询就可以了
        }
    }
    return 0;
}

```

---

## 作者：arfa (赞：0)

> ## 可持久化数组浅谈

这里浅谈一下主席树的解法。

我们知道,**可持久化**也就是可以访问历史版本的。而**可持久化数组**也是如此,可以访问历史版本且可以将某一个历史版本复制(或修改)变为新的历史版本。

很容易想到建立一个$N^2$的矩阵(我说的$N^2$是序列长度,可能会跟题目不符合,~~并没有认真看题目~~),但是这样子显然很多余。但是我们又不可以预测下一次序列的长度,所以也不能加一些~~空间底层优化~~。我们更不可以覆盖历史版本,不然~~听取$WA$声一片~~。

我们就可以把空间压缩成$N\ log\ N$,运用主席树的空间形式,这也是主席树的最大优点之一。有兴趣大家可以看一看[$Kth-Number$](https://www.luogu.org/problemnew/show/P3834)。

主要思想讲到这里,大家自己去实现吧(~~偷笑~~)。

推荐题目:

[高级打字机](https://blog.csdn.net/stone41123/article/details/78271866)

[最长不上升子序列(LIS)](https://blog.csdn.net/puppywolf/article/details/78690750)

---


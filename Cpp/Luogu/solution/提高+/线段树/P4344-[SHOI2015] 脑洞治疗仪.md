# [SHOI2015] 脑洞治疗仪

## 题目描述

曾经发明了自动刷题机的发明家 SHTSC 又公开了他的新发明：脑洞治疗仪——一种可以治疗他因为发明而日益增大的脑洞的神秘装置。

为了简单起见，我们将大脑视作一个 01 序列。$1$ 代表这个位置的脑组织正常工作，$0$ 代表这是一块脑洞。

```cpp
1      0      1      0      0      0      1      1      1      0
```

脑洞治疗仪修补某一块脑洞的基本工作原理就是将另一块连续区域挖出，将其中正常工作的脑组织填补在这块脑洞中。（所以脑洞治疗仪是脑洞的治疗仪？）

例如，用上面第 $8$ 号位置到第 $10$ 号位置去修补第 $1$ 号位置到第 $4$ 号位置的脑洞，我们就会得到：

```cpp
1      1      1      1      0      0      1      0      0      0
```

如果再用第 $1$ 号位置到第 $4$ 号位置去修补第 $8$ 号位置到第 $10$ 号位置：

```cpp
0      0      0      0      0      0      1      1      1      1
```

这是因为脑洞治疗仪会把多余出来的脑组织直接扔掉。

如果再用第 $7$ 号位置到第 $10$ 号位置去填补第 $1$ 号位置到第 $6$ 号位置：

```cpp
1      1      1      1      0      0      0      0      0      0
```

这是因为如果新脑洞挖出来的脑组织不够多，脑洞治疗仪仅会尽量填补位置比较靠前的脑洞。

假定初始时 SHTSC 并没有脑洞，给出一些挖脑洞和脑洞治疗的操作序列，你需要即时回答 SHTSC 的问题：在大脑某个区间中最大的连续脑洞区域有多大。

## 说明/提示

对于 $20\%$ 的数据，$n, m \leq 100$；  
对于 $50\%$ 的数据，$n, m \leq 20000$；  
对于 $100\%$ 的数据，$n, m \leq 200000$。

## 样例 #1

### 输入

```
10 10
0 2 2
0 4 6
0 10 10
2 1 10
1 8 10 1 4
2 1 10
1 1 4 8 10
2 1 10
1 7 10 1 6
2 1 10```

### 输出

```
3
3
6
6```

# 题解

## 作者：kradcigam (赞：56)

## 前言

这道题目呢，看上去很难，实际上我们可以用线段树解决这道题目。

## 正文

我们维护 `sum`、`len`、`tag`、`lmax`、`rmax`、`ans`。

`sum` 就是这段区间非脑洞的个数

`len` 就是这段区间的长度

`tag` 就是我们的 `lazy_tag`

`lmax` 就是从左开始的连续脑洞个数

`rmax` 就是从右开始的连续脑洞个数

`ans` 就是这段区间最大的连续脑洞

### 建树

由于 `len` 是不变的，所以我们可以建树的时候就求出 `len`

```cpp
t[num].len=r-l+1;
```

### `pushup`

#### `sum`

`sum` 就是左子树和右子树的 `sum` 的和。

```cpp
t[num].sum=t[ls].sum+t[rs].sum;
```

#### `lmax`

`lmax` 的话有两种情况

##### 第 $1$ 种情况

![aaasajdfhiujhkja.png](https://i.loli.net/2020/03/27/oNTSrnHFZu6XAJk.png)

`lmax`=左子树的 `lmax`

##### 第 $2$ 中情况

![asdssssajdfhiujhkja.png](https://i.loli.net/2020/03/27/LTaj5UisqMS3eP8.png)

`lmax`=左子树的 `len` + 右子树的 `lmax`

```cpp
if(t[ls].lmax==t[ls].len)t[num].lmax=t[ls].len+t[rs].lmax;
else t[num].lmax=t[ls].lmax;
```

#### `rmax`

`rmax` 的话也两种情况

##### 第 $1$ 种情况

![kja.png](https://i.loli.net/2020/03/27/FNKtdnUw6rpACl1.png)

`rmax`=右子树的 `rmax`

![df.png](https://i.loli.net/2020/03/27/3h7ZYsAqWMrK2EG.png)

`lmax`=右子树的 `len` + 左子树的 `rmax`

```cpp
if(t[rs].rmax==t[rs].len)t[num].rmax=t[rs].len+t[ls].rmax;
else t[num].rmax=t[rs].rmax;
```

#### `ans`

`ans` 的话有 $3$ 种情况

##### 第 $1$ 种情况

![asdsajdfhiujhkja.png](https://i.loli.net/2020/03/27/wjYa8XCmQEtOe6S.png)

`ans`=左子树的 `ans`

##### 第 $2$ 种情况

![asdasajdfhiujhkja.png](https://i.loli.net/2020/03/27/cVXrQhiG9YbxwIW.png)

`ans`=右子树的 `ans`

##### 第 $3$ 种情况

![aasdasajdfhiujhkja.png](https://i.loli.net/2020/03/27/kVchXdzs7QT5BnL.png)

`ans`=左子树的 `rmax`+右子树的 `lmax`

```cpp
t[num].ans=max(max(t[ls].ans,t[rs].ans),t[ls].rmax+t[rs].lmax);
```

### `pushdown`

#### `tag`

我们的 `tag` 有 `3` 种值，分别为 `0`，`1`，`2`

`0` 表示什么都没有

`1` 表示全部为脑洞

`2` 表示全部不为脑洞

##### `0`

`0` 的话，代表没有任何操作，不要管。

##### `1`

我们对照上面的发现：

`ans`、`lmax`、`rmax` 都为 `len`。

而 `sum` 则为 `0`。

`tag` 的标记当然要打啦。

```cpp
void down1(int num){
	t[num].ans=t[num].lmax=t[num].rmax=t[num].len;
	t[num].sum=0;
	t[num].tag=1;
}
```

##### `2`

我们对照上面的发现：

`ans`、`lmax`、`rmax` 都为 `0`。

而 `sum` 则为 `len`。

`tag` 的标记当然要打啦。

```cpp
void down2(int num){
	t[num].ans=t[num].lmax=t[num].rmax=0;
	t[num].sum=t[num].len;
	t[num].tag=2;
}
```

### 二分

我们可以发现，操作 `2` 就是先统计一遍 $[l0,r0]$ 中非脑洞的个数。

然后把 $[l0,r0]$ 这段区间全部变成脑洞，再去在 $[l1,r1]$ 这段区间里找到从 $l0$ 开始算起最右边脑洞个数 $\leq[l0,r0]$ 中脑洞的个数。

我们发现脑洞个数是单调递增的，所以我们可以二分。

我采用的写法是左闭右开。

```cpp
void work(){
	int x=query0(1,l0,r0);//统计
	if(x==0)return;//这里要注意，否则我们的边界就是错的
	change(1,l0,r0,1);//全部变成脑洞
	int l=l1,r=r1+1;//二分的边界
	while(l+1<r){//经典写法
		int mid=(l+r)>>1;//求mid
		if(query1(1,l1,mid)<=x)l=mid;//小于等于
		else r=mid;
	}
	change(1,l1,l,2);//填上去
}
```

### 代码

复杂度 $O(n \log n + q \log^2 n)$

```cpp
#include <bits/stdc++.h>
#define ls num<<1
#define rs num<<1|1
using namespace std;
typedef long long ll;
template<typename T>inline void read(T &FF){
	T RR=1;FF=0;char CH=getchar();
	for(;!isdigit(CH);CH=getchar())if(CH=='-')RR=-1;
	for(;isdigit(CH);CH=getchar())FF=(FF<<1)+(FF<<3)+(CH^48);
	FF*=RR;
}
template<typename T>inline void write(T x){
	if(x<0)putchar('-'),x*=-1;
	if(x>9)write(x/10);
	putchar(x%10+48);
}
template<typename T>inline void writen(T x){
	write(x);
	puts("");
}
const int N=2e5+10;
struct Tree{
	int l,r,lmax,rmax,sum,tag,len,ans;
}t[N<<2];
int n,m,l0,r0,l1,r1,f;
void pushup(int num){
	t[num].sum=t[ls].sum+t[rs].sum;
	if(t[ls].lmax==t[ls].len)t[num].lmax=t[ls].len+t[rs].lmax;
	else t[num].lmax=t[ls].lmax;
	if(t[rs].rmax==t[rs].len)t[num].rmax=t[rs].len+t[ls].rmax;
	else t[num].rmax=t[rs].rmax;
	t[num].ans=max(max(t[ls].ans,t[rs].ans),t[ls].rmax+t[rs].lmax);
}
void down1(int num){
	t[num].ans=t[num].lmax=t[num].rmax=t[num].len;
	t[num].sum=0;
	t[num].tag=1;
}
void down2(int num){
	t[num].ans=t[num].lmax=t[num].rmax=0;
	t[num].sum=t[num].len;
	t[num].tag=2;
}
void pushdown(int num){
	if(t[num].tag==1){
		down1(ls);down1(rs);
		t[num].tag=0;
	}
	if(t[num].tag==2){
		down2(ls);down2(rs);
		t[num].tag=0;
	}
}
void build(int num,int l,int r){
	t[num].tag=0;
	t[num].l=l;
	t[num].r=r;
	t[num].len=r-l+1;
	if(l==r){
		t[num].sum=1;
		t[num].ans=t[num].lmax=t[num].rmax=0;
		return;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	pushup(num);
}
void change(int num,int x,int y,int z){
	if(t[num].l>=x&&t[num].r<=y){
		if(z==1)down1(num);
		if(z==2)down2(num);
		return;
	}
	pushdown(num);
	if(t[ls].r>=x)change(ls,x,y,z);
	if(t[rs].l<=y)change(rs,x,y,z);
	pushup(num);
}
int query0(int num,int x,int y){
	if(t[num].l>=x&&t[num].r<=y)return t[num].sum;
	pushdown(num);
	if(t[ls].r<x)return query0(rs,x,y);
	if(t[rs].l>y)return query0(ls,x,y);
	return query0(ls,x,y)+query0(rs,x,y);
}
int query1(int num,int x,int y){
	if(t[num].l>=x&&t[num].r<=y)return t[num].len-t[num].sum;
	pushdown(num);
	if(t[ls].r<x)return query1(rs,x,y);
	if(t[rs].l>y)return query1(ls,x,y);
	return query1(ls,x,y)+query1(rs,x,y);
}
void work(){
	read(l1);read(r1);
	int x=query0(1,l0,r0);
	if(x==0)return;
	change(1,l0,r0,1);
	int l=l1,r=r1+1;
	while(l+1<r){
		int mid=(l+r)>>1;
		if(query1(1,l1,mid)<=x)l=mid;
		else r=mid;
	}
	change(1,l1,l,2);
}
int query2(int num,int x,int y){
	if(t[num].l>=x&&t[num].r<=y)return t[num].ans;
	pushdown(num);
	if(t[ls].r<x)return query2(rs,x,y);
	if(t[rs].l>y)return query2(ls,x,y);
	return max(max(query2(ls,x,y),query2(rs,x,y)),min(t[ls].rmax,t[rs].l-x)+min(t[rs].lmax,y-t[ls].r));
}
int main(){
	read(n);read(m);
	build(1,1,n);
	while(m--){
		read(f);read(l0);read(r0);
		switch(f){
			case 0:change(1,l0,r0,1);break;
			case 1:work();break;
			case 2:writen(query2(1,l0,r0));break;
		}
	}
	return 0;
}
```

### 拓展

这道题目还有更优秀的解法，复杂度可以少掉一个 $\log$ 也就是变成 $O(n \log n+q \log{n})$。

我们还是先统计非脑洞个数。

我们写一个函数 $fill$ 就是我们用来把脑细胞填入脑洞的函数。我们要填 $x$ 个脑细胞，会发现有 $2$ 种情况。

- 第 $1$ 种情况是所有脑细胞都填入左子树。

- 第 $2$ 种情况是所有脑细胞不仅把左边填满，还有多的放到右子树。

我们可以根据这个写代码：

```cpp
int fill(int num,int l,int r,int x){//fill的返回值就是剩余的脑细胞数量
	if(x==0)return 0;
	if(t[num].l>=l&&t[num].r<=r&&t[num].sum<=x){
		int s=t[num].sum;//务必要先存起来
		down2(num);
		return x-s;
	}
	pushdown(num);int ans;
	if(t[ls].r<l)ans=fill(rs,l,r,x);
	else if(t[rs].l>r)ans=fill(ls,l,r,x);
		else ans=fill(rs,l,r,fill(ls,l,r,x));
	pushup(num);
	return ans;//答案
}
```
感谢 @LightningUZ 的补充！

---

## 作者：听取MLE声一片 (赞：40)

### 大家好，我喜欢暴力数据结构，所以我用分块卡过了这道题。

之前题解里面没有分块，这里补充分块做法及优化。

我们规定脑洞是 `0`，正常是 `1`。

分块，需要维护的是每个块 `0` 的前缀长度，`0` 的后缀长度，最长连续 `0` 的长度,`0` 的个数，`1` 的个数，以及一个 tag 记录是否全部推平。然后初始化函数和推平函数很容易想到了。

下面是代码：

```
inline void build(int x){
	tag[x]=-1;
	int l=L[x],r=R[x],s=0;
	pre[x]=suf[x]=b[x]=sum[x]=ss[x]=0;
	for(register int i=l;i<=r;i++){
		if(a[i])
			break;
		pre[x]++;
	}
	for(register int i=r;i>=l;i--){
		if(a[i])
			break;
		suf[x]++;
	}
	for(register int i=l;i<=r;i++){
		if(!a[i]){
			s++;
			sum[x]++;
			continue;
		}
		ss[x]++;
		b[x]=max(b[x],s);
		s=0;
	}
	b[x]=max(b[x],s);
	return;
}
inline void change(int x){
	if(tag[x]==-1)
		return;
	if(tag[x]==1){
		for(register int i=L[x];i<=R[x];i++)
			a[i]=1;
		tag[x]=-1;
		pre[x]=suf[x]=b[x]=sum[x]=0;
		ss[x]=R[x]-L[x]+1;
	}
	if(tag[x]!=-1){
		for(register int i=L[x];i<=R[x];i++)
			a[i]=0;
		tag[x]=-1;
		pre[x]=suf[x]=b[x]=sum[x]=R[x]-L[x]+1;
		ss[x]=0;
	}
	return;
}
```

查询就是参照[序列操作](https://www.luogu.com.cn/problem/P2572)，直接顺着扫一遍即可，注意要处理块与块连接的地方，如果 `0` 全部填满这个块，说明可以把两边都连起来。

接着处理区间修改，挖脑洞就是把一部分全部改为 `0`，直接推平即可。注意要修改 tag。

然后是治疗，分为两部分。第一部分是查询 $l_0,r_0$ 之间有多少 `1`，然后将 $l,r$ 全部清为 `0`；第二部分是把这些数量全部填到 $l_1,r_1$ 之间。

第一部分很简单，直接统计即可，记录 `res`。第二部分就遍历每个块，如果当前块 `0` 的个数比 `res` 大就一个一个填，接着结束，否则就区间直接填入。如果填到最后有剩余就不管。由此得出[代码](https://www.luogu.com.cn/paste/74dye6dw)。

写完就会就能获得 50 分的好成绩。

下面说一个大优化，加了能快很多，再加点细枝末节的就能过了。

我们可以看到，`build` 函数的重构我们在代码中出现的次数太多了，可以针对这个优化。

第一步是把 `build` 处理一车标记的地方复制到 `change` 函数里面，然后就可以省去 `build` 的循环。

第二步是把查询中能解决的重构都干掉，不难看出查询的地方有很多 `build`，因为没有修改这些都可以替换为 `change`，把重构全部干掉！

第三步是把区间修改的能不重构就不重构，具体一点是如果之前的 `tag` 为 `0`，就不用改了。

第四步是移植脑组织的计数可以和修改放在一起，又可以干掉一些重构。

再加个快读快输就能过了（好像并不能快多少）。

完整代码：

```
#include<iostream>
#include<cmath>
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
#include<map>
#include<set>
using namespace std;
#define ll long long
#define rep(i, f, t) for (int i = (f), ed##i = (t); i <= ed##i; ++i)
#define re(i, t) rep (i, 1, t)
#define per(i, t, f) for (int i = (t), ed##i = (f); i >= ed##i; --i)
#define ste(i, f, t, s) for (int i = (f), ed##i = (t); i <= ed##i; i += s)
#define each(i, x) for (auto& i : (x))
#define nxt(i, f, g) for (int i = g.h[f]; i; i = g.e[i].n)
#define dbg(x) (cerr << "(dbg) " << #x " = " << (x) << '\n')
#define umod(x) ((x) >= mo && ((x) -= mo))
#define dmod(x) ((x) < 0 && ((x) += mo))
#define up(x, y) (((x) < (y)) && ((x) = (y)))
#define down(x, y) (((x) > (y)) && ((x) = (y)))
#define y1 y1__
namespace FastIO {
	const int SZ=(1<<21)+1;
	struct I {
		char ibuf[SZ],*iS,*iT,c;int f,_eof;FILE*fi;
		I(FILE*f):fi(f){}
		inline char Gc(){return iS==iT?(iT=(iS=ibuf)+fread(ibuf,1,SZ,fi),(iS==iT?EOF:*iS++)):*iS++;}
		inline ll operator()(){ll x;operator()(x);return x;}
		inline I&operator()(char&x){x=Gc();return*this;}
		inline I&operator()(char*s){for(c=Gc();c<32||c>126||c==' ';)c=Gc();for(;c>31&&c<127&&c!=' '&&c!='\n'&&c!='\r';++s,c=Gc())*s=c;*s=0;return*this;}
		template<class T>inline I&operator()(T&x){_eof=0;for(f=1,c=Gc();(c<'0'||c>'9')&&!_eof;c=Gc()){if(c=='-')f=-1;_eof|=c==EOF;}for(x=0;c<='9'&&c>='0'&&!_eof;c=Gc())x=x*10+(c&15),_eof|=c==EOF;x*=f;return*this;}
		template<class T>I&operator()(T*x,const int&n,const int&st=1){rep(i,st,n){operator()(x[i]);}return*this;}
	} in(stdin);
	struct O {
		char obuf[SZ],*oS=obuf,*oT=oS+SZ-1,qu[55];int f,qr;FILE*fi;
		O(FILE*f):fi(f){}
		~O(){Flush();}
		inline void Flush(){fwrite(obuf,1,oS-obuf,fi),oS=obuf;}
		inline O&operator()(char x){*oS++=x;if(oS==oT)Flush();return*this;}
		inline O&operator()(const char*s){int len=strlen(s);for(f=0;f<len;++f)operator()(s[f]);return*this;}
		template<class T>inline O&operator()(T x){if(!x)operator()('0');if(x<0)operator()('-'),x=-x;while(x)qu[++qr]=x%10+'0',x/=10;while(qr)operator()(qu[qr--]);return*this;}
		template<class T>O&operator()(T*x,const int&n,const char&ed=' ',const int&st=1){rep(i,st,n)operator()(x[i])(ed);return*this;}
	} out(stdout);
}
using FastIO::in;using FastIO::out;
const int N=2e5+10;
const int M=500;
int n,m,t,L[M],R[M],pos[N];
int a[N],tag[M],sum[M],ss[M],pre[M],suf[M],b[M];
inline void build(int x){
	tag[x]=-1;
	int l=L[x],r=R[x],s=0;
	pre[x]=suf[x]=b[x]=sum[x]=ss[x]=0;
	for(register int i=l;i<=r;i++){
		if(a[i])
			break;
		pre[x]++;
	}
	for(register int i=r;i>=l;i--){
		if(a[i])
			break;
		suf[x]++;
	}
	for(register int i=l;i<=r;i++){
		if(!a[i]){
			s++;
			sum[x]++;
			continue;
		}
		ss[x]++;
		b[x]=max(b[x],s);
		s=0;
	}
	b[x]=max(b[x],s);
	return;
}
inline void change(int x){
	if(tag[x]==-1)
		return;
	if(tag[x]==1){
		for(register int i=L[x];i<=R[x];i++)
			a[i]=1;
		tag[x]=-1;
		pre[x]=suf[x]=b[x]=sum[x]=0;
		ss[x]=R[x]-L[x]+1;
	}
	if(tag[x]!=-1){
		for(register int i=L[x];i<=R[x];i++)
			a[i]=0;
		tag[x]=-1;
		pre[x]=suf[x]=b[x]=sum[x]=R[x]-L[x]+1;
		ss[x]=0;
	}
	return;
}
inline void debug(){
	cout<<endl<<"debug:\n";
	for(int i=1;i<=t;i++){
		change(i);
		build(i);
	}
	for(int i=1;i<=n;i++)
		cout<<a[i]<<' ';
	cout<<endl<<"finish\n";
}
inline void update(int l,int r){
	int p=pos[l],q=pos[r];
	if(p==q){
		if(tag[p]==0)
			return;
		change(p);
		for(register int i=l;i<=r;i++)
			a[i]=0;
		build(p);
		return;
	}
	if(tag[p]!=0){
		change(p);
		for(register int i=l;i<=R[p];i++)
			a[i]=0;
		build(p);	
	}
	for(register int i=p+1;i<=q-1;i++){
		tag[i]=ss[i]=0;
		pre[i]=suf[i]=sum[i]=b[i]=R[i]-L[i]+1;
	}
	if(tag[q]!=0){
		change(q);
		for(register int i=L[q];i<=r;i++)
			a[i]=0;
		build(q);	
	}
	return;
}
inline void modity(int l,int r,int x,int y){
	int p=pos[l],q=pos[r],res=0;
	if(p==q){
		if(tag[p]==-1)
			build(p);
		else change(p);
		for(register int i=l;i<=r;i++)
			res+=a[i];
	}
	else{
		if(tag[p]==-1)
			build(p);
		else change(p);
		for(register int i=l;i<=R[p];i++)
			res+=a[i];
		if(tag[q]==-1)
			build(q);
		else change(q);
		for(register int i=L[q];i<=r;i++)
			res+=a[i];
		for(register int i=p+1;i<=q-1;i++)
			res+=ss[i];
	}
	update(l,r);
	p=pos[x],q=pos[y];
	if(p==q){
		change(p);
		for(register int i=x;i<=y&&res;i++){
			if(a[i]==0)
				res--;
			a[i]=1;
		}
		build(p);
		return;
	}
	change(p);
	for(register int i=x;i<=R[p]&&res;i++){
		if(a[i]==0)
			res--;
		a[i]=1;
	}
	build(p);
	if(!res)
		return;
	for(register int i=p+1;i<=q-1;i++){
		if(sum[i]>res){
			change(i);
			for(register int j=L[i];j<=R[i]&&res;j++){
				if(a[j]==0)
					res--;
				a[j]=1;
			}
			build(i);
			return;
		}
		res-=sum[i];
		tag[i]=1;
		pre[i]=suf[i]=b[i]=sum[i]=0;
		ss[i]=R[i]-L[i]+1;
	}
	if(!res)
		return;
	change(q);
	for(register int i=L[q];i<=y&&res;i++){
		if(a[i]==0)
			res--;
		a[i]=1;
	}
	build(q);
	return;
}
inline void query(int l,int r){
	int p=pos[l],q=pos[r];
	int s=0,res=0;
	if(p==q){
		change(p);
		for(register int i=l;i<=r;i++){
			if(a[i]){
				res=max(res,s);
				s=0;
				continue;
			}
			s++;
		}
		res=max(res,s);
		out(res)('\n');
		return;
	}
	change(p);
	for(register int i=l;i<=R[p];i++){
		if(a[i]){
			res=max(res,s);
			s=0;
			continue;
		}
		s++;
	}
	res=max(res,s);
	for(register int i=p+1;i<=q-1;i++){
		res=max(res,b[i]);
		if(b[i]==(R[i]-L[i]+1)){
			s+=sum[i];
			res=max(res,s);
			continue;
		}
		s+=pre[i];
		res=max(res,s);
		s=suf[i];
	}
	change(q);
	for(register int i=L[q];i<=r;i++){
		if(a[i]){
			res=max(res,s);
			s=0;
			continue;
		}
		s++;
	}
	res=max(res,s);
	out(res)('\n');
	return ;
}
int main()
{
	in(n)(m);
	t=sqrt(n);
	for(int i=1;i<=t;i++){
		L[i]=(i-1)*t+1;
		R[i]=i*t;
	}
	if(R[t]<n){
		t++;
		L[t]=R[t-1]+1;
		R[t]=n;
	}
	for(register int i=1;i<=t;i++){
		for(register int j=L[i];j<=R[i];j++){
			pos[j]=i;
			a[j]=1;
		}
		tag[i]=-1;
		pre[i]=suf[i]=b[i]=sum[i]=0;
		ss[i]=R[i]-L[i]+1;
	}
	int opt,l,r,x,y;
	while(m--){
		//debug();
		in(opt)(l)(r);
		if(opt==0){
			update(l,r);
			continue;
		}
		if(opt==1){
			in(x)(y);
			modity(l,r,x,y);
			continue;
		}
		if(opt==2)
			query(l,r);
	}
	return 0;
}
```






---

## 作者：VenusM1nT (赞：17)

ODT。  
究极暴力大法好，没想到 ODT 暴力写并不会 T 呢……  
照例一个一个操作分析：  
 - 0 操作：直接推平。  
 - 1 操作：先计算 $[l_0,r_0]$ 中的脑组织数量，然后直接推平，再一个一个区间来对 $[l_1,r_1]$ 修改，假定我们的脑组织数量为 $\text{sum}$，如果当前的 $0$ 区间 $\text{len}\leq\text{sum}$，直接修改 $\text{val}$，同时 $\text{sum}=\text{sum}-\text{len}$；反之推平当前区间靠前的 $\text{sum}$ 个即可。
 - 2 操作：直接一个一个区间扫过去就好了，用一个 $\text{res}$ 记录临时答案，如果当前区间为 $1$ 更新 $\text{ans}$，将 $\text{res}$ 清空，否则 $\text{res}=\text{res}+\text{len}$，不要忘了最后还要更新一遍 $\text{ans}$，输出即可。
 
```cpp
#include<bits/stdc++.h>
#define MAXN 200005
#define reg register
#define inl inline
#define iter set<Node>::iterator 
using namespace std;
struct Node
{
	int l,r;
	mutable int val;
	bool operator < (const Node &x) const
	{
		return l<x.l;
	}
}a[MAXN];
int n,Q;
set<Node> s;
inl iter Split(reg int pos)
{
	reg iter it=s.lower_bound((Node){pos,pos,-1});
	if(it!=s.end() && it->l==pos) return it;
	it--;
	reg Node x=*it;
	s.erase(it);
	s.insert((Node){x.l,pos-1,x.val});
	return s.insert((Node){pos,x.r,x.val}).first;
}
inl void Assign(reg int l,reg int r,reg int val)
{
	reg iter R=Split(r+1),L=Split(l);
	s.erase(L,R);
	s.insert((Node){l,r,val});
}
inl void Modify(reg int x,reg int y,reg int l,reg int r)
{
	reg iter R=Split(y+1),L=Split(x);
	reg int sum=0;
	for(reg iter it=L;it!=R;it++) if(it->val) sum+=(it->r-it->l+1);
	Assign(x,y,0);
	R=Split(r+1);
	L=Split(l);
	for(reg iter it=L;it!=R && sum;it++)
	{
		if(!(it->val))
		{
			if(sum>=(it->r-it->l+1))
			{
				it->val=1;
				sum-=(it->r-it->l+1);
			}
			else
			{
				Assign(it->l,it->l+sum-1,1);
				sum=0;
			}
		}
	}
}
inl int Query(reg int l,reg int r)
{
	reg iter R=Split(r+1),L=Split(l);
	reg int res=0,ans=0;
	for(reg iter it=L;it!=R;it++)
	{
		if(!(it->val)) res+=(it->r-it->l+1);
		else
		{
			ans=max(ans,res);
			res=0;
		}
	}
	return max(ans,res);
}
inl void Out()
{
	puts("\n ST:");
	reg iter R=Split(n+1),L=Split(1);
	for(reg iter it=L;it!=R;it++)
	{
		for(reg int i=1;i<=(it->r-it->l+1);i++) printf("%d ",it->val);
	}
	puts("\n");
}
int main()
{
	scanf("%d %d",&n,&Q);
	s.insert((Node){1,n,1});
	while(Q--)
	{
		reg int opt,x,y,l,r;
		scanf("%d %d %d",&opt,&x,&y);
		if(!opt) Assign(x,y,0);
		else if(opt==1)
		{
			scanf("%d %d",&l,&r);
			Modify(x,y,l,r);
		}
		else printf("%d\n",Query(x,y));
	}
	return 0;
}
```

---

## 作者：Taduro (赞：17)

调了将近一个下午终于A了这道题，似乎没有我想的那么难？？？

其他两篇题解我并没有看懂，果然还是太菜了%%%守望大佬。

步入正题：肯定是要用线段树的，那我们来看怎么实现。

0操作：区间修改，把板子写上改一下，完。。

1操作：首先模拟题意，把l0到r0的脑细胞取出来（区间求和+区间修改），然后在l1到r1区间找出几个连续的0把脑细胞补上

怎么找0呢？首先暴力肯定是不行的，由于连续最长的0满足单调性，我们可以二分查找。

而这个二分还有一个前提就是当前序列的起点得是0，不然怎么也找不到。

那怎么办呢？由于起点不是零就是一，我们可以先二分找以起点开头连续最长的1序列，然后把它的终点后面一个元素（一定是0）作为0序列的起点，这样就找到一个以当前起点连续最长的0，然后把它补上（区间修改成一）。

这是如果还能补，我们就又面临当时的那个问题，循环一下就好了。

2操作：我们会了一操作，这个自然也会了。

```
#include<cstdio>
#include<iostream>
#ifdef ONLINE_JUDGE
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){if(A==B){B=(A=ss)+fread(ss,1,1<<17,stdin);if(A==B)return EOF;}return*A++;}
template<class T>inline void read(T&x){
    static char c;static int y;
    for(c=gc(),x=0,y=1;c<48||57<c;c=gc())if(c=='-')y=-1;
    for(;48<=c&&c<=57;c=gc())x=((x+(x<<2))<<1)+(c^'0');
    x*=y;
}
#else
void read(int &x){scanf("%d",&x);}
#endif		//快读
using namespace std;
int ad[800001],sum[800001],n,t;
inline void write(int x){if(x>9) write(x/10);putchar(x%10^48);}
inline void pushup(int rt){
	sum[rt]=sum[rt<<1]+sum[rt<<1|1];
}
void build(int rt,int l,int r){		//菜鸡专属建树
	if (l==r){
		sum[rt]=1;
		return;
	}
	int m=(l+r)>>1;
	build(rt<<1,l,m);
	build(rt<<1|1,m+1,r);
	pushup(rt);
}
inline void pushdown(int rt,int l,int r){
	if (ad[rt]){
		int m=(l+r)>>1;
		ad[rt]--;
		sum[rt<<1]=ad[rt]*(m-l+1);
		sum[rt<<1|1]=ad[rt]*(r-m);
		ad[rt<<1]=ad[rt]+1;
		ad[rt<<1|1]=ad[rt]+1;
		ad[rt]=0;
	}
}
void update(int rt,int l,int r,int x,int y,int k){	//区间都附成k
	if (l>y||x>r) return;
	if (x<=l&&r<=y){
		ad[rt]=k+1;		//由于有0，k+1方便一些
		sum[rt]=k*(r-l+1);
		return;
	}
	pushdown(rt,l,r);
	int m=(l+r)>>1;
	if (m>=x) update(rt<<1,l,m,x,y,k);
	if (m<y) update(rt<<1|1,m+1,r,x,y,k);
	pushup(rt);
}
int query(int rt,int l,int r,int x,int y){		//查询区间和
	if (l>y||x>r) return 0;
	if (x<=l&&r<=y) return sum[rt];
	pushdown(rt,l,r);
	int m=(l+r)>>1,ret=0;
	if (m>=x) ret+=query(rt<<1,l,m,x,y);
	if (m<y) ret+=query(rt<<1|1,m+1,r,x,y);
	return ret;
}
inline int ef(int x,int y,int k){	//二分查找x到y之间连续最长的k序列
	int l=0,r=y-x,mid;
	if (x>y) return -1;
	while (l<=r){
		mid=(l+r)>>1;
		if (query(1,1,n,x,x+mid)==k*(mid+1)) l=mid+1;
		else r=mid-1;
	}
	return l;
}
int main(){
	int x,y,b,c,d;
	read(n); read(t);
	build(1,1,n);
	while (t--){
		read(b),read(x),read(y);
		if (b==0){
			update(1,1,n,x,y,0);
		}
		if (b==1){
			read(c),read(d);
			int num=query(1,1,n,x,y),p=0;
			update(1,1,n,x,y,0);
			if (num>=(d-c+1)-query(1,1,n,c,d)){	
				update(1,1,n,c,d,1); continue;
			}
			if (num==0) continue;//以上两个特判为菜鸡T了之后无助的挣扎
			while (1){
				if (query(1,1,n,c,c)==1){	//开头为一
					p=ef(c,d,1); c+=p; 
				}
				p=ef(c,d,0);
				if (p==-1) break;
				if (p>num){
					update(1,1,n,c,c+num-1,1);
					break;
				}
				else{
					update(1,1,n,c,c+p-1,1);
					num-=p; c+=p;
				}
			}
		}
		if (b==2){
			int ans=0,p=0;
			while (1){
				if (query(1,1,n,x,x)==1){
					p=ef(x,y,1); x+=p;
				}
				p=ef(x,y,0);
				if (p==-1) break;
				ans=max(ans,p);
				x+=p; if (x>y) break;	//忘写这个85分死循环
			}
			write(ans); puts("");
		}
	}
	return 0;
}
```

---

## 作者：Dispwnl (赞：10)

线段树裸题，维护最大连续子段

操作只有区间覆盖（全变为0）和一个区间补全（姑且这么命名）

区间覆盖好说，一个标记就行了

区间补全怎么搞呢？

可以在给定的区间里找出连续为0的一段，并且你现在有的脑组织可以填满ta

这样就又是区间覆盖（全变为1）了

要是脑组织不够，就继续二分直到找到可以填满的区间

如图：![](http://a-failure.github.io/img/study/naodong.png)

红色线段是有的脑组织，蓝色虚线部分是脑洞

![](http://a-failure.github.io/img/study/naodong1.png)

把红色部分填进脑洞1

![](http://a-failure.github.io/img/study/naodong2.png)

这时红色剩余部分不够填充脑洞2了，于是二分脑洞2直到找到可以填充的部分

这样加上一些优化时间复杂度大概是$O(nlogn)$多一点？~~我也不会算~~

反正开$O2$跑的挺快qwq

代码：
```cpp
# include<iostream>
# include<cstring>
# include<cstdio>
# include<algorithm>
# define tl (k<<1)
# define tr (k<<1|1)
# define mid (l+r>>1)
using namespace std;
const int MAX=2e5+1;
struct p{
    int Sum,l,r,sum,lazy;
    p(){lazy=-1;}
}s[MAX<<2];
int n,m,tot,TOT;
int read()
{
    int x=0;
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar());
    for(;isdigit(ch);x=x*10+ch-48,ch=getchar());
    return x;
}
p pus(int dis,p a,p b,int l,int r)
{
    p c;
    c.l=c.r=c.sum=c.Sum=0,c.lazy=dis;
    c.Sum=a.Sum+b.Sum;
    c.l=a.l,c.r=b.r;
    if(a.l==mid-l+1) c.l+=b.l;
    if(b.r==r-mid) c.r+=a.r;
    c.sum=a.r+b.l;
    c.sum=max(c.sum,max(a.sum,b.sum));
    c.sum=max(c.l,max(c.r,c.sum));
    return c;
}
void down(int l,int r,int k)
{
    int dis=s[k].lazy;
    s[k].lazy=-1;
    if(dis==-1) return;
    s[tl].Sum=dis*(mid-l+1),s[tl].sum=s[tl].l=s[tl].r=(dis==0)*(mid-l+1),s[tl].lazy=dis;
    s[tr].Sum=dis*(r-mid),s[tr].sum=s[tr].l=s[tr].r=(dis==0)*(r-mid),s[tr].lazy=dis;
}
void change1(int l,int r,int k,int L,int R)
{
    if(l==L&&r==R)
    {
        s[k].Sum=0,s[k].sum=s[k].l=s[k].r=r-l+1,s[k].lazy=0;
        return;
    }
    down(l,r,k);
    if(R<=mid) change1(l,mid,tl,L,R);
    else if(L>mid) change1(mid+1,r,tr,L,R);
    else change1(l,mid,tl,L,mid),change1(mid+1,r,tr,mid+1,R);
    s[k]=pus(s[k].lazy,s[tl],s[tr],l,r);
}
void change3(int l,int r,int k)
{
    if(!TOT) return;
	if(s[k].Sum==r-l+1) return;
    if(!s[k].Sum&&TOT>=r-l+1)
    {
        s[k].Sum=r-l+1,s[k].sum=s[k].l=s[k].r=0,s[k].lazy=1;
        TOT-=r-l+1,tot+=r-l+1;
        return;
    }
    if(l>=r) return;
    down(l,r,k);
    change3(l,mid,tl),change3(mid+1,r,tr);
    s[k]=pus(s[k].lazy,s[tl],s[tr],l,r);
}
void change2(int l,int r,int k,int L,int R,int dis)
{
    if(tot>=dis) return;
    if(l==L&&r==R)
    {
        TOT=dis-tot,change3(l,r,k);
        return;
    }
    down(l,r,k);
    if(R<=mid) change2(l,mid,tl,L,R,dis);
    else if(L>mid) change2(mid+1,r,tr,L,R,dis);
    else change2(l,mid,tl,L,mid,dis),change2(mid+1,r,tr,mid+1,R,dis);
    s[k]=pus(s[k].lazy,s[tl],s[tr],l,r);
}
int ask1(int l,int r,int k,int L,int R)
{
    if(l==L&&r==R) return s[k].Sum;
    down(l,r,k);
    if(R<=mid) return ask1(l,mid,tl,L,R);
    if(L>mid) return ask1(mid+1,r,tr,L,R);
    return ask1(l,mid,tl,L,mid)+ask1(mid+1,r,tr,mid+1,R);
}
p ask2(int l,int r,int k,int L,int R)
{
    if(l==L&&r==R) return s[k];
    down(l,r,k);
    if(R<=mid) return ask2(l,mid,tl,L,R);
    if(L>mid) return ask2(mid+1,r,tr,L,R);
    p LL=ask2(l,mid,tl,L,mid),RR=ask2(mid+1,r,tr,mid+1,R);
    return pus(-1,LL,RR,l,r);
}
int Ask(int l,int r)
{
    int ans=ask1(1,n,1,l,r);
    change1(1,n,1,l,r);
    return ans;
}
int main()
{
    n=read(),m=read();
    s[1].lazy=1,s[1].Sum=n;
    for(int i=1;i<=m;++i)
      {
      	int op=read(),l=read(),r=read(),l1,r1;
      	if(!op) change1(1,n,1,l,r);
      	else if(op==1)
      	{
      		l1=read(),r1=read();
      		int dis=Ask(l,r);
      		if(dis) tot=TOT=0,change2(1,n,1,l1,r1,dis);
      	}
      	else if(op==2) printf("%d\n",ask2(1,n,1,l,r).sum);
      }
    return 0;
}
```

---

## 作者：fighter_OI (赞：8)

没有题解么……我来写一篇好了

题目要求什么？

- 区间赋0
- 最长连续0
- 把一个区间的1依次填到另一个区间

这似乎是一道线段树裸题……

赋0，最长连续0都是线段树基本操作

O(nlogn)

第三条二分一下那一段刚好被填就好

O(nlog²n)

能做到更优吗？

观察：区间赋0

使用珂朵莉树![我永远喜欢珂朵莉](https://i.loli.net/2018/04/09/5aca3ca156185.jpg)

珂朵莉树，优美的暴力，用于有推平区间操作，随机的题目

就是把相同的数存一起

只有O(nlogn)

该暴力暴力好了
```cpp
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<cstring>
#include<memory.h>
#include<map>
#include<set>
#include<queue>
using namespace std;
struct node{
	int l,r,v;
	node(){}
	node(int L,int R=-1,int V=0):l(L),r(R),v(V){}
	inline bool operator<(const node&o)const	{
		return l<o.l;}
};
set<node>S;
typedef set<node>::iterator iter;
iter split(int pos){
	set<node>::iterator it=S.lower_bound(node(pos));
	if(it!=S.end()&&it->l==pos)return it;
	--it;
	if(pos>it->r)return S.end();
	int L=it->l,R=it->r,V=it->v;
	S.erase(it);
	S.insert(node(L,pos-1,V));
	return S.insert(node(pos,R,V)).first;}
inline void debug()
{
	for(iter it=S.begin();it!=S.end();it++)
	{
		for(int i=it->l;i<=it->r;i++)
		{
			printf("%d,%d ",i,it->v);
		}
		putchar('/');
	}
	puts("");
}
inline void del(int l,int r)
{
	iter itr=split(r+1),itl=split(l);
	S.erase(itl,itr);
	S.insert(node(l,r,0));
}
inline void maxi(int l,int r)
{
	iter itr=split(r+1),itl=split(l);
	int maxi=0,now=0;
	for(;itl!=itr;itl++)
	if(!itl->v)now+=itl->r-itl->l+1;else maxi=max(maxi,now),now=0;
	printf("%d\n",max(maxi,now));
}
inline void cure(int l0,int r0,int l,int r)
{
	iter itr=split(r0+1),itl=split(l0),it=itl;
	int sum=0;
	for(;itl!=itr;itl++)if(itl->v)sum+=itl->r-itl->l+1;
	S.erase(it,itr);
	S.insert(node(l0,r0,0));
	if(!sum)return;
	itr=split(r+1);
	it=itl=split(l);
	int que=0;
	for(;itl!=itr&&que<sum;itl++)if(!itl->v)que+=itl->r-itl->l+1;
	if(que<sum)S.erase(it,itr),S.insert(node(l,r,1));else
	{
		itl--;
		int ri=itl->r+sum-que;
		itr=split(ri+1);
		S.erase(it,itr);
		S.insert(node(l,ri,1));
	}
}
int n,m;
int main()
{
	scanf("%d%d",&n,&m);
	S.insert(node(1,n,1));
	while(m--)
	{
		int op,l,r,l1,r1;
		scanf("%d%d%d",&op,&l,&r);
		if(op==0)del(l,r);else
		if(op==2)maxi(l,r);else
		{
			scanf("%d%d",&l1,&r1);
			cure(l,r,l1,r1);
		}
		//debug();
	}
}
```

---

## 作者：Fading (赞：7)

### 前言

~~线段树这么好为什么要写珂朵莉树呢？还会被卡~~

线段树+线段树上二分。

写了两个小时才写出来...

而且我想出的算法时间复杂度是单次$O(\log_2n)$的，而不是均摊的。

其他三篇题解都是均摊复杂度$O(\log_2n)$。。。

所以我来发一篇好啦！

### 约定

设脑浆为$1$，脑洞为$0$。

------------


首先我们要**理解**线段树。

然后看看第$3$个操作怎么写。

我们维护线段树上区间的信息有：

- 区间有多少个$1$，记为 x

- **最多**有多少个$0$，记为 ans。

- 从左端点向右延伸**最多**有多少个$0$，记为 lmax。

- 从右端点向左延伸**最多**有多少个$0$，记为  rmax。

- 区间长度，记为 len 

如何合并两个区间（从左到右为$a,b$）？设最后合成的区间为$c$

```cpp

c.x=a.x+b.x

c.len=a.len+b.len

c.lmax=(a.len==a.lmax)?a.len+b.lmax:a.lmax

c.rmax=(b.len==b.rmax)?b.len+a.rmax:b.rmax

c.ans=max{a.rmax+b.lmax,a.ans,b.ans,c.lmax,c.rmax}

```

那么就可以像[GSS1](https://www.luogu.org/problemnew/show/SP1043)一样做了。


------------

第$1$个操作很简单就是区间赋值，打懒标记即可。

第$2$个操作，就是先挖空（全部变成$0$）$[l_1,r_1]$，并求出区间有多少个$1$（可以一个函数完成）

然后把$[l_2,r_2]$按顺序填充，能填多少填多少，填满了就扔掉多余的脑浆。

怎么按顺序填充呢？

如果脑浆多余了，就直接区间覆盖（全部覆盖成$1$）。

如果脑浆没有剩余呢？注意到如果这个位置有脑浆就不需要覆盖，这怎么搞？

发现可以二分。直接二分挖出的脑浆最多可以覆盖到的位置。时间复杂度$O(n\log_2^2n)$

当然这是过不去的。所以我们需要更优的解法。

我们先把$[l_2,r_2]$扔到线段树上，让整个区间根据线段树结构分成$O(\log_2n)$个区间。

发现这些区间有些是被**完全修补**的，有些区间没有被修补。

一定有一个区间，满足它的下一个区间没有被修补（如果不存在下一个区间也算），而它自己被**部分修补**（可能正好被填满）

求出这个区间。

然后在这个区间的线段树上二分，找到最后修补的那个点$\text{pos}$。

这可以用类似第$k$小的方法进行。

最后$[l_2,\text{pos}]$全部覆盖上$1$即可。

常数还行吧。具体看注释。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ljc 998244353
using namespace std;
#ifdef Fading
#define gc getchar
#endif
#ifndef Fading
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
#endif
inline ll read(){
    register ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}
    return (f==1)?x:-x;
}
struct node{
    int x,lmax,rmax,ans,len;
}seg[4000001];
inline node init(int x,int y,int a,int b,int xx){
    return (node){x,y,a,b,xx};
}
inline node operator + (const node &a,const node &b){//合并区间。
    node c=init(a.x+b.x,(a.len==a.lmax)?a.len+b.lmax:a.lmax,(b.len==b.rmax)?b.len+a.rmax:b.rmax,
    max(a.rmax+b.lmax,max(a.ans,b.ans)),a.len+b.len);
    c.ans=max(c.ans,max(c.lmax,c.rmax));
    return c;
}
int Len[4000001],LB[4000001],RB[4000001],fg[4000001],n,m,Q;
#define mid ((lb+rb)>>1)
inline void pushup(int rt){
    seg[rt]=seg[rt<<1]+seg[rt<<1|1];
}
void build(int rt,int lb,int rb){
    fg[rt]=-1;LB[rt]=lb;RB[rt]=rb;
    if (lb==rb) return (void)(seg[rt]=init(1,0,0,0,1));
    build(rt<<1,lb,mid);build(rt<<1|1,mid+1,rb);
    pushup(rt);Len[rt]=Len[rt<<1]+Len[rt<<1|1];
}
inline void pushdown(int rt,int lb,int rb){
    if (~fg[rt]){
        int ls=rt<<1,rs=rt<<1|1;
        fg[ls]=fg[rs]=fg[rt];
        seg[ls]=init(fg[rt]*(mid-lb+1),(1-fg[rt])*(mid-lb+1),(1-fg[rt])*(mid-lb+1),(1-fg[rt])*(mid-lb+1),mid-lb+1);
        seg[rs]=init(fg[rt]*(rb-mid),(1-fg[rt])*(rb-mid),(1-fg[rt])*(rb-mid),(1-fg[rt])*(rb-mid),rb-mid);
        fg[rt]=-1;
    }
}
ll dig(int rt,int lb,int rb,int l,int r,int x){
//掏空这个区间并返回有多少个1。
    if (lb>r||rb<l) return 0;
    if (lb>=l&&rb<=r){
        int tmp=seg[rt].x;fg[rt]=x;
        seg[rt]=init(x*(rb-lb+1),(1-x)*(rb-lb+1),(1-x)*(rb-lb+1),(1-x)*(rb-lb+1),rb-lb+1);
        return tmp;
    }
    pushdown(rt,lb,rb);
    int ans=dig(rt<<1,lb,mid,l,r,x)+dig(rt<<1|1,mid+1,rb,l,r,x);
    pushup(rt);return ans;
}
int dl[101],tot;
void Get(int rt,int lb,int rb,int l,int r){//拆分区间。
    if (lb>r||rb<l) return;
    if (lb>=l&&rb<=r) return (void)(dl[++tot]=rt);
    pushdown(rt,lb,rb);
    Get(rt<<1,lb,mid,l,r);Get(rt<<1|1,mid+1,rb,l,r);
}
node query(int rt,int lb,int rb,int l,int r){//3操作。
    if (lb>r||rb<l) return init(seg[rt].len,0,0,0,seg[rt].len);
    if (lb>=l&&rb<=r) return seg[rt];
    pushdown(rt,lb,rb);
    return query(rt<<1,lb,mid,l,r)+query(rt<<1|1,mid+1,rb,l,r);
}
int findit(int rt,int lb,int rb,int x,int sz){//线段树上二分找点。
    pushdown(rt,lb,rb);
    if (sz+seg[rt].len-seg[rt].x==x) return rb;
    if (sz+(seg[rt<<1].len-seg[rt<<1].x)<x) 
        return findit(rt<<1|1,mid+1,rb,x,sz+seg[rt<<1].len-seg[rt<<1].x);
        //左区间不够用，去右区间找。
    else return findit(rt<<1,lb,mid,x,sz);//左区间够用，去左区间找。
}
signed main(){
    n=read();m=read();
    build(1,1,n);
    while (m--){
        int opt=read(),l=read(),r=read();
        if (opt==0){
            dig(1,1,n,l,r,0);
        }else if (opt==1){
            int brain=dig(1,1,n,l,r,0);
            int L=read(),R=read();
            if (!brain) continue;
            tot=0,Get(1,1,n,L,R);
            int sum=0,maxrt;bool flag=0;
            for (int i=1;i<=tot;i++){
            	int rt=dl[i];
                sum+=seg[rt].len-seg[rt].x;
                if (sum>=brain){//找区间。
                    sum=brain-sum+seg[rt].len-seg[rt].x;
                    maxrt=dl[i];flag=1;break;
                }
            }
            if (!flag) dig(1,1,n,L,R,1);
            else{
                int ansR=findit(maxrt,LB[maxrt],RB[maxrt],sum,0);
                dig(1,1,n,L,ansR,1);
            }			
        }else{
            printf("%d\n",query(1,1,n,l,r).ans);
        }
    }
    return 0;
}
```


---

## 作者：CreeperLordVader (赞：4)

本题真的很不错，虽然我足足写了一天

我不会什么珂朵莉树，但我认为这题用线段树做真的很妙

我的复杂度是$ O(Nlog^2N) $还大一点，做法和别的线段树不大一样，维护的值很多


操作0：很容易想到全部设为0（change函数）

操作2：查询区间最长连续子段0（query函数）

#### 接下来的操作1是重头戏
首先，我们肯定要知道有多少正常的脑组织可用，因此需要在待挖出的区间$ [l_0,r_0] $内查询区间和（qsum函数），然后全部设为0

#### 麻烦的是，填脑洞时要从最前面的填起，我的做法是维护区间最左0的位置（代码中的lp数组）

然后查询出区间$ [l_1,r_1] $的最左0的位置,记为pos，接下来找以pos为起始点的最长子段0

考虑一个子段，如果子段内有1，那么更长的子段也不可能满足，因此可以二分终点的位置，得到一个最长连续的子段0，（同时还要满足这个子段能用当前剩余的组织填上）

### 如何判定当前二分的子段内是否有1?查询区间和就可以了

重复以上过程直至$ [l_1,r_1] $内的脑洞被填完或组织不够

会不会太慢?

可能出现0,1交替的情况,所幸这种情况并不常见(因为事先需要大量的修改),也很容易解决(因为操作结束后会出现一坨0)

于是本题解决

线段树维护:最大子段0:sub

最大前缀0:lmax

最大后缀0:rmax

区间和: sum

区间最左0: lp(若区间不存在0则记为-1)

区间修改懒标记: setc

还有问题就看代码,如果最大子段和不会求的话,可以上网看看,这个地方也很容易错

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=200005;
int sub[MAXN<<2],lmax[MAXN<<2],sum[MAXN<<2];
int setc[MAXN<<2],rmax[MAXN<<2],lp[MAXN<<2];
int n,m;
void read(int& x)
{
    char c=getchar();
    x=0;
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9')
    {
        x=x*10+c-'0';
        c=getchar();
    }
}
void pushdown(int o,int l,int r)
{
    if(setc[o]>=0)
    {
    	int mid=(l+r)>>1;
        setc[o<<1]=setc[o<<1|1]=setc[o];
 //       cout<<"pushdown: "<<o<<" "<<l<<" "<<r<<" "<<lp[o]<<endl;
        if(setc[o])
        {
            lmax[o<<1]=rmax[o<<1]=sub[o<<1]=0;
            lmax[o<<1|1]=rmax[o<<1|1]=sub[o<<1|1]=0;
            lp[o<<1]=lp[o<<1|1]=-1;
            sum[o<<1]=mid-l+1;
            sum[o<<1|1]=r-mid;
        }
        else
        {
            lmax[o<<1]=rmax[o<<1]=sub[o<<1]=mid-l+1;
            lmax[o<<1|1]=rmax[o<<1|1]=sub[o<<1|1]=r-mid;
            lp[o<<1]=l;
            lp[o<<1|1]=mid+1;
            sum[o<<1]=sum[o<<1|1]=0;
        }
        setc[o]=-1;
    }
}
void update(int o,int l,int r)
{
    int mid=(l+r)>>1;
    sub[o]=max(rmax[o<<1]+lmax[o<<1|1],max(sub[o<<1],sub[o<<1|1]));
    if(sub[o<<1]==mid-l+1)lmax[o]=sub[o<<1]+lmax[o<<1|1];
    else lmax[o]=lmax[o<<1];
    if(sub[o<<1|1]==r-mid)rmax[o]=sub[o<<1|1]+rmax[o<<1];
    else rmax[o]=rmax[o<<1|1];
    if(lp[o<<1]==-1)lp[o]=lp[o<<1|1];
    else lp[o]=lp[o<<1];
 //   cout<<"update: "<<o<<" "<<l<<" "<<r<<" "<<lp[o]<<endl;
    sum[o]=sum[o<<1]+sum[o<<1|1];
}
void build(int o,int l,int r)
{
    if(l==r)
    {
    	lp[o]=-1;
    	lmax[o]=rmax[o]=sub[o]=0;
    	sum[o]=1;
        return ;
    }
    int mid=(l+r)>>1;
    build(o<<1,l,mid);
    build(o<<1|1,mid+1,r);
    sum[o]=sum[o<<1]+sum[o<<1|1];
    lp[o]=-1;
}
void change(int o,int l,int r,int ql,int qr,int k)
{
    if(ql<=l&&qr>=r)
    {
    	setc[o]=k;
        if(k)
        {
            lmax[o]=rmax[o]=sub[o]=0;
            sum[o]=r-l+1;
            lp[o]=-1;
        }
        else
        {
            lmax[o]=rmax[o]=sub[o]=r-l+1;
            sum[o]=0;
            lp[o]=l;
        }
//        cout<<"change: "<<o<<" "<<l<<" "<<r<<" "<<lp[o]<<endl;
        return ;
    }
    int mid=(l+r)>>1;
    pushdown(o,l,r);
    if(ql<=mid)change(o<<1,l,mid,ql,qr,k);
    if(qr>mid)change(o<<1|1,mid+1,r,ql,qr,k);
    update(o,l,r);
}
int qsum(int o,int l,int r,int ql,int qr)
{
    if(ql<=l&&qr>=r)
    {
        return sum[o];
    }
    int mid=(l+r)>>1,ans=0;
    pushdown(o,l,r);
    if(ql<=mid)ans+=qsum(o<<1,l,mid,ql,qr);
    if(qr>mid)ans+=qsum(o<<1|1,mid+1,r,ql,qr);
    return ans;
}
int query(int o,int l,int r,int ql,int qr)
{
    if(ql<=l&&qr>=r)
    {
        return sub[o];
    }
    int mid=(l+r)>>1,ansl=-1,ansr=-1,lans=-1,rans=-1;
    pushdown(o,l,r);
    if(ql<=mid)
    {
        ansl=query(o<<1,l,mid,ql,qr);
        if(qr>mid)lans=min(rmax[o<<1],mid-ql+1);
    }
    if(qr>mid)
    {
        ansr=query(o<<1|1,mid+1,r,ql,qr);
        if(ql<=mid)rans=min(lmax[o<<1|1],qr-mid);
    }
    return max(lans+rans,max(ansl,ansr));
}
int ask(int o,int l,int r,int ql,int qr)
{
    if(ql<=l&&qr>=r)
    {
        return lp[o];
    }
    int mid=(l+r)>>1,ans=-1;
    pushdown(o,l,r);
    if(ql<=mid)ans=ask(o<<1,l,mid,ql,qr);
    if(ans==-1&&qr>mid)ans=ask(o<<1|1,mid+1,r,ql,qr);
    return ans;
}
int main()
{
//	freopen("1.out","w",stdout);
    read(n);
    read(m);
    memset(setc,-1,sizeof(setc));
    build(1,1,n);
    for(int i=1;i<=m;i++)
    {
    	int op;
    	read(op);
    	if(!op)
    	{
    		int l,r;
    		read(l);
    		read(r);
    		change(1,1,n,l,r,0);
        }
        else if(op==1)
        {
            int pl,pr,ql,qr;
            read(pl);
            read(pr);
            read(ql);
            read(qr);
            int cnt=qsum(1,1,n,pl,pr);//求出可用的组织 
            change(1,1,n,pl,pr,0);
            int pos=ask(1,1,n,ql,qr);//求出脑洞的起始区间
            while(pos!=-1&&cnt)
            {
                int l=pos,r=qr;//二分寻找右边界 
                while(l<r)
                {
                    int mid=(l+r+1)>>1;
                    if(!qsum(1,1,n,pos,mid))l=mid;
                    else r=mid-1;
                }
                l=min(l,pos+cnt-1);//如果组织不够，可填充的位置还要缩小
                change(1,1,n,pos,l,1);
                cnt-=(l-pos+1);
                pos=ask(1,1,n,ql,qr);
            }
        }
        else
        {
            int l,r;
            read(l);
            read(r);
            printf("%d\n",query(1,1,n,l,r));
        }
    }
}

```


---

## 作者：skydogli (赞：3)

## 又一道珂朵莉树跑得飞快的题目(似乎比正解少个$log?$

珂朵莉树其实是一个结构体set,结构体中的变量分别表示左右端点和权值(这题的权值为0或1),精髓就是分裂和推平操作,前者使各种操作都十分~~暴力~~容易实现,后者使我们在**随机数据下**复杂度正确.


STL小白可以看看[这篇文章](https://www.luogu.org/blog/communist/stl-zheng-li-zhi-set),然后看我的代码基本就没什么问题了.

#### 另外,因为蒟蒻我没学过指针,所以程序里也没怎么出现指针,只是用了($*$指针)用来表示变量,风格还是偏数组的

代码里有详细注释:

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
#define qwq Chtholly_Tree//珂朵莉!
#define itset set<qwq>::iterator//这个迭代器巨长
inline int max(int a,int b){return a>b?a:b;}
inline int read(){
    int a=0;
    char c=getchar();
    while(c>'9'||c<'0')c=getchar();
    while('0'<=c&&c<='9'){
        a=a*10+c-48;
        c=getchar();
    }
    return a;
}
struct qwq{
    int l,r;
    mutable bool v;//要加这个mutable,不然会CE
    qwq(int ls,int rs=-1,int vv=0):l(ls),r(rs),v(vv){}//用于新建一个结构体
    bool friend operator <(qwq a,qwq b){
        return a.l<b.l;
    }//注意,因为是set,所以我们要重载运算符
    int len(){return r-l+1;}
};
set<qwq>s;
int x,X,y,Y,n,m,op;
itset split(int pos){
    itset it=s.lower_bound(qwq(pos));
    if(it!=s.end()&&(*it).l==pos)return it;//如果pos是某个区间的左端点,直接返回
    --it;
    if((*it).r<pos) return s.end();//pos不在这个区间,直接返回尾迭代器,因为不用操作
    int ls=(*it).l,rs=(*it).r;
    bool vv=(*it).v;
    s.erase(it);//删除原区间
    s.insert(qwq(ls,pos-1,vv));//一分为二地插入
    return s.insert(qwq(pos,rs,vv)).first;
}
void change(int l,int r,int vv){//推平操作
    itset itrs=split(r+1),itls=split(l);
    s.erase(itls,itrs);
    s.insert(qwq(l,r,vv));//删掉,然后插入新的
}
void fix(int l,int r,int L,int R){
    itset itrs=split(r+1),itls=split(l),temp=itls;
    int sum=0;
    for(;itls!=itrs;++itls){
        if((*itls).v)sum+=qwq(*itls).len();
    }//统计1的个数
    s.erase(temp,itrs);//注意这里不能用itls,因为itls已经被改变了
    s.insert(qwq(l,r,0));//推平
    itrs=split(R+1),itls=split(L);
    for(;itls!=itrs&&sum;++itls)
        if(!(*itls).v){
            if(sum>=qwq(*itls).len()) sum-=qwq(*itls).len(),(*itls).v=1;
            else change((*itls).l,(*itls).l+sum-1,1),sum=0;//分类讨论一下
        }
}
int ask(int l,int r){
    itset itrs=split(r+1),itls=split(l);
    int ans=0,now=0;
    for(;itls!=itrs;++itls)
        if((*itls).v) now=0;
            else {now+=qwq(*itls).len();ans=max(ans,now);}
    return ans;//相当暴力的逐个查询
}
int main(){
    n=read();m=read();
    s.insert(qwq(1,n,1));
    for(int i=1;i<=m;++i){
        op=read();
        x=read();y=read();
        if(op&1){
            X=read();Y=read();
            fix(x,y,X,Y);
        }
        else if(!op)change(x,y,0);
        else printf("%d\n",ask(x,y));
    }
    return 0;
}//然后就又水了一题2333
```
如果还不怎么看得懂珂朵莉,可以参考这篇[文章](https://www.mina.moe/archives/9695)

---

## 作者：Provicy (赞：2)

前段时间学了珂朵莉树，现在看到区间推平就想珂朵莉树做怎么办（大雾

这题的三个操作还是挺适合珂朵莉树的：区间推平；区间最长连续$0$的个数；区间转移（话说区间转移是什么叫法）

前两个操作都是珂朵莉树模板了，现在我们考虑第三个操作。

这个操作的实际意思是：把一段区间内$1$的个数找出来并把这段区间推平为$0$，再把这些$1$按照顺序填入另一个序列的$0$位置，如果最后还有剩余就不管了。

我们考虑把第一个区间内的$1$的个数统计一下，然后在第二个区间中暴力充填。分类讨论一下当前剩余$1$的个数和这段$0$区间的长度。如果前者大，显然把这段$0$区间全部改成$1$即可，否则就计算一下能填到哪，然后把这一部分都填完直接跳出循环即可。在数据随机的情况下，这个做法的复杂度还是挺优良的。

代码如下：

```cpp
//声起立华乐独奏，曲末音无心结弦。
//I think the players who have done all the bad things here are those who have rotted to the bone in the real world.
//The journey of the future is so far away, but the light we can see is so rare. Even so, I still haven't given up hope completely.
//No matter what kind of memory, it's the life we lived.
//I can do anything as long as I have you.
//People can only see what they want to see and hear what they want to hear, and I am no exception.
//No matter what you see in the past, please don't lose yourself. No matter what you become, I am your companion.
//Like the night sky, wrap the sad world gently.
//Because we are born with nothing, we can have everything.
//Even if you forget me, I will not forget you.
//Even if it's only one in six billion, we'll still meet.
//You will no longer be a prop, but a person as his name.
//No matter what the final result is, as long as this is the path of your choice.
#include <bits/stdc++.h>
using namespace std;
int n,m;
struct ODT
{
	int l,r; mutable int val;
	ODT(int L,int R=-1,int V=0):l(L),r(R),val(V){}
	inline bool operator<(const ODT& a)const{return l<a.l; }
}; set<ODT> Q;
inline char nc()
{
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
char ch; int ss;
inline int read()
{
	ss=0; ch=nc();
	while(ch<'0'||ch>'9') ch=nc();
	while(ch>='0'&&ch<='9') ss=(ss<<3)+(ss<<1)+(ch^48),ch=nc(); return ss;
}
inline set<ODT>::iterator Split(int pos)
{
	set<ODT>::iterator s=Q.lower_bound(ODT(pos));
	if(s!=Q.end()&&s->l==pos) return s; s--;
	int L=s->l,R=s->r,V=s->val; Q.erase(s); Q.insert(ODT(L,pos-1,V));
	return Q.insert(ODT(pos,R,V)).first;
}
inline void Assign(int l,int r,int k)
{
	set<ODT>::iterator itr=Split(r+1),itl=Split(l);
	Q.erase(itl,itr); Q.insert(ODT(l,r,k));
}
inline void Solve(int l1,int r1,int l2,int r2)
{
	set<ODT>::iterator itr=Split(r1+1),itl=Split(l1);
	int res=0;
	for(register set<ODT>::iterator it=itl;it!=itr;it++) if(it->val) res+=it->r-it->l+1;
	Q.erase(itl,itr); Q.insert(ODT(l1,r1,0));
	if(!res) return;
	itr=Split(r2+1),itl=Split(l2);
	for(;itl!=itr;itl++)
	{
		if(itl->val) continue;
		if(res<=itl->r-itl->l+1)
		{
			Assign(itl->l,itl->l+res-1,1);
			break;
		}
		else
		{
			itl->val=1;
			res-=itl->r-itl->l+1;
		}
	}
}
inline int AskMax(int l,int r)
{
	set<ODT>::iterator itr=Split(r+1),itl=Split(l);
	int maxx,res; maxx=res=0;
	for(;itl!=itr;itl++)
	{
		if(!itl->val) res+=itl->r-itl->l+1;
		else maxx=max(maxx,res),res=0;
	} maxx=max(maxx,res); return maxx;
}
int main()
{
	n=read(), m=read(); Q.insert(ODT(1,n,1));
	for(int i=1,opt,l,r,u,v;i<=m;i++)
	{
		opt=read(), l=read(), r=read();
		if(opt==0) Assign(l,r,0);
		if(opt==1) u=read(), v=read(), Solve(l,r,u,v);
		if(opt==2) printf("%d\n",AskMax(l,r));
	}
	return 0;
}
```


---

## 作者：万万没想到 (赞：2)

原题传送门：[P4344【SHOI2015】脑洞治疗仪](https://www.luogu.org/problemnew/show/P4344)

这道题目已经讲得很清楚了，维护一个01序列，bool变量就行了。

题目中要求挖脑洞我们就可以将其理解为将一段区间赋值为0，补脑洞可以理解为将一段区间赋值为1。

01序列，区间赋值想到了什么？对，珂朵莉树，这个可以百度，在随机情况下时间复杂度为O（mlogn），m为操作次数，n为序列长度。大家可以熟练一下对set的操作，珂朵莉树是靠区间赋值来降低时间复杂度的，每个值的l，r维护连续一段值相同的左右边界，查询时也会简便，可以自己思考思考。

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define IT set<node>::iterator
#define LL long long
using namespace std;
struct node{
    int l,r;
    mutable bool v;
    node(int L,int R=-1,bool V=0):l(L),r(R),v(V) {}
    bool operator<(const node& o) const
    {
        return l<o.l;
    }
};
set<node> s;
IT split(int pos){ 
    IT it=s.lower_bound(node(pos));
    if(it!=s.end()&&it->l==pos) return it;
    --it;
    int L=it->l,R=it->r;
    bool V=it->v;
    s.erase(it);
    s.insert(node(L,pos-1,V));
    return s.insert(node(pos,R,V)).first;
}
void assign_val(int l,int r,bool val){ 
    IT itr=split(r+1),itl=split(l);
    s.erase(itl,itr);
    s.insert(node(l,r,val));
}
int count(int l,int r)
{
    IT itr = split(r+1),itl = split(l);
    int maxn=0;
    for(; itl != itr; ++itl){
    	if(itl->v)maxn=maxn+itl->r-itl->l+1;
    }
    return maxn;
}
void xiubu(int l,int r,int res){
    IT itr=split(r+1),itl=split(l);
    for(;itl!=itr;++itl){
        if(!res)break;
        if(!itl->v){
            int ok=0;
            if(itl->r-itl->l+1>res){
            	ok=res+itl->l-1;
                res=0;
                assign_val(itl->l,ok,1);
            }
            else{
            	res=res-(itl->r-itl->l+1);
            	itl->v=1;
            }
        }
    }
}
int cha(int l,int r){
    IT itr = split(r+1),itl = split(l);
    int maxn=0,nowq=0;
    for(; itl != itr; ++itl){
    	if(!itl->v)
            nowq+=itl->r-itl->l+1;
        else if(nowq)
            maxn=max(maxn,nowq),nowq=0;
    }
    return max(maxn,nowq);
}
int main(){
    int n,m;
    scanf("%d%d",&n,&m);
    s.insert(node(1,n,1));
    s.insert(node(n+1,n+1,0));
    while(m--){
        int op,a,b,x,y;
        scanf("%d%d%d",&op,&a,&b);
        if(op==0)assign_val(a,b,0);
        else if(op==1){
        	scanf("%d%d",&x,&y);
        	int num=count(a,b);
        	assign_val(a,b,0);
        	xiubu(x,y,num);
        }
        else if(op==2){
        	printf("%d\n",cha(a,b));
        }
    }
    return 0;
}
```


---

## 作者：yzhang (赞：2)

## [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/9774948.html)

#### 原题传送门：[P4344 [SHOI2015]脑洞治疗仪](https://www.luogu.org/problemnew/show/P4344)

## 前置芝士：珂朵莉树

### [窝博客里对珂朵莉树的介绍](https://www.cnblogs.com/yzhang-rp-inf/p/9443659.html )

### 没什么好说的自己看看吧

#### 珂朵莉树好题啊

#### 洛咕上另一篇题解出锅了，所以窝再写一篇题解~~（数据好像变过？？？）~~

#### 我一开始一直Re65

#### 后来重构代码就ac了，或许是rp问题

#### 线段树做法好像很慢啊

#### 我的珂朵莉树吸氧后目测luogu最优解第二，不知最优解匿名大佬怎么写的

#### 操作1：把区间推平成0，开脑洞？？？珂朵莉树基本操作

#### 操作2：把区间中的1的数量统计一下并变成0，暴力去被修补脑洞的区间填补（细节看代码来理解）

#### 操作3：查询区间中最长连续的1，暴力扫一遍就行

```cpp
#pragma GCC optimize("O3")
#include<bits/stdc++.h>
#define IT set<node>::iterator
using namespace std; 
struct IO_Tp
{
    static const int _I_Buffer_Size = 1 << 24;
    char _I_Buffer[_I_Buffer_Size];
    char* _I_pos;
    static const int _O_Buffer_Size = 1 << 24;
    char _O_Buffer[_O_Buffer_Size];
    char* _O_pos;
    IO_Tp() : _I_pos(_I_Buffer), _O_pos(_O_Buffer)
    {
        fread(_I_Buffer, 1, _I_Buffer_Size, stdin);
    }
    ~IO_Tp()
    {
        fwrite(_O_Buffer, 1, _O_pos - _O_Buffer, stdout);
    }
    inline bool is_digit(const char ch)
    {
        return '0' <= ch && ch <= '9';
    }
    inline IO_Tp& operator>>(int& res)
    {
        res = 0;
        while (!is_digit(*_I_pos))
            ++_I_pos;
        do
            (res *= 10) += (*_I_pos++) & 15;
        while (is_digit(*_I_pos));
        return *this;
    }
    inline IO_Tp& operator<<(int n)
    {
        static char _buf[10];
        char* _pos(_buf);
        do
            *_pos++ = '0' + n % 10;
        while (n /= 10);
        while (_pos != _buf)
            *_O_pos++ = *--_pos;
        return *this;
    }
    inline IO_Tp& operator<<(char ch)
    {
        *_O_pos++ = ch;
        return *this;
    }
} IO;
inline int Max(register int a,register int b)
{
    return a>b?a:b;
}
struct node
{
    int l,r;
    mutable bool v;
    node(int L, int R=-1, bool V=0):l(L), r(R), v(V) {}
    bool operator<(const node& o) const
    {
        return l < o.l;
    }
};
set<node> s;
IT split(int pos)
{
    IT it = s.lower_bound(node(pos));
    if (it != s.end() && it->l == pos) 
        return it;
    --it;
    int L = it->l, R = it->r;
    bool V = it->v;
    s.erase(it);
    s.insert(node(L, pos-1, V));
    return s.insert(node(pos, R, V)).first;
}
void assign_val(int l,int r,bool v)
{
    IT itr = split(r+1),itl = split(l);
    s.erase(itl, itr);
    s.insert(node(l, r, v));
}
void scure(int l,int r,int a,int b)
{
    IT itr = split(r+1),itl = split(l),it = itl;
    int sum=0;
    for(; itl != itr; ++itl)
        if(itl->v)
            sum+=itl->r-itl->l+1;
    s.erase(it,itr);
    s.insert(node(l,r,0));
    if(!sum)
        return;
    itr = split(b+1),itl = split(a),it = itl;
    if(sum>=b-a+1)
    {
    	s.erase(itl,itr);
    	s.insert(node(a,b,1));
    	return;
    }
    for( ; itl != itr; ++itl)
        if(!itl->v)
        {
            sum-=itl->r-itl->l+1;
            if(sum<0)
            {
                assign_val(itl->l,itl->r+sum,1);
                break;
            }
            else
                itl->v=1;
        }
}
void sMax(int l,int r)
{
    IT itr = split(r+1),itl = split(l);
    int maxn=0,now=0;
    for(; itl != itr; ++itl)
        if(!itl->v)
            now+=itl->r-itl->l+1;
        else if(now)
            maxn=Max(maxn,now),now=0;
    IO<<Max(maxn,now)<<'\n';
}
int main()
{
    int n,m;
    IO>>n>>m;
    s.insert(node(1,n,1));
    while(m--)
    {
        int op,l,r;
        IO>>op>>l>>r;
        if(op==0)
            assign_val(l,r,0);
        else if(op==1)
        {
            int a,b;
            IO>>a>>b;
            scure(l,r,a,b);
        }
        else
            sMax(l,r);
    }
    return 0;
}
```

---

## 作者：斗神_君莫笑 (赞：1)

一道好题  
关键在于处理2询问区间间关系这种细节    
因为需要维护最大连续个数，选择将区间取反便于操作   
考虑每一次修改都是将一个区间整体填充到另一个位置，维护一个区间和    
先查询出l0r0的组织个数，然后清零区间   
这一步要在询问填充个数之前进行，因为会产生影响   
然后询问填充个数，开始更新  
当在询问区间内时，从右往左填充    
同时注意标记间不能互存这个细节  
```cpp
#include<bits/stdc++.h>
#define lc (p<<1)
#define rc (p<<1|1)
using namespace std;
struct Node{
    int l,r,lsum,rsum,ans,sum,lazy1,lazy2;
    //lazy1判是否空（1） lazy2判是否满（0） 
}T[2000010];
int n,m,a[500010];
void pushup(int p){
    T[p].sum=T[lc].sum+T[rc].sum;
	T[p].lsum=T[lc].lsum;
    if(T[lc].lsum==T[lc].r-T[lc].l+1)T[p].lsum+=T[rc].lsum;
    T[p].rsum=T[rc].rsum;
    if(T[rc].rsum==T[rc].r-T[rc].l+1)T[p].rsum+=T[lc].rsum;
	T[p].ans=max(max(T[lc].ans,T[rc].ans),T[lc].rsum+T[rc].lsum);
}
void build(int p,int l,int r){
    T[p].l=l;T[p].r=r;
    if(l==r){
        //T[p].lsum=T[p].rsum=T[p].sum=T[p].ans=0;
        return;
    }
    int mid=(l+r)>>1;
    build(lc,l,mid);
    build(rc,mid+1,r);
    pushup(p);
}
inline void pushnow1(int p){
	T[p].sum=T[p].ans=T[p].lsum=T[p].rsum=T[p].r-T[p].l+1;
	T[p].lazy1=1;T[p].lazy2=0; 
}
inline void pushnow2(int p){
	T[p].sum=T[p].ans=T[p].lsum=T[p].rsum=0;
	T[p].lazy2=1;T[p].lazy1=0;
}
inline void pushdown(int p){
	if(T[p].lazy1){
		pushnow1(lc);
		pushnow1(rc);
		T[p].lazy1=0;
	}
	if(T[p].lazy2){
		pushnow2(lc);
		pushnow2(rc);
		T[p].lazy2=0;
	}
}
Node query(int p,int ql,int qr){
	if(ql<=T[p].l&&T[p].r<=qr) return T[p];
	pushdown(p);
    int mid=(T[p].l+T[p].r)>>1;
    if(ql<=mid&&qr>mid){
    	Node ans,l=query(lc,ql,qr),r=query(rc,ql,qr);
    	ans.lsum=l.lsum;
    	if(l.lsum==T[lc].r-T[lc].l+1)ans.lsum+=r.lsum;
        ans.rsum=r.rsum;
        if(r.rsum==T[rc].r-T[rc].l+1)ans.rsum+=l.rsum;
        ans.ans=max(max(l.ans,r.ans),l.rsum+r.lsum);
        ans.sum=l.sum+r.sum;
        //printf("%d %d %d %d %d\n",T[p].l,T[p].r,ans.ans,ans.lsum,ans.rsum);
        return ans;
	}
	if(ql<=mid)return query(lc,ql,qr);
	if(qr>mid)return query(rc,ql,qr);
}
void clear(int p,int ql,int qr){
	//printf("%d %d %d\n",p,T[p].l,T[p].r);
	if(T[p].lazy1)return;
	pushdown(p);
	if(ql<=T[p].l&&T[p].r<=qr){
		pushnow1(p);
		return;
	}
	int mid=(T[p].l+T[p].r)>>1;
	if(ql<=mid)clear(lc,ql,qr);
	if(qr>mid)clear(rc,ql,qr);
	pushup(p);
}
int v;
void update(int p,int ql,int qr){
	if(v==0||T[p].lazy2)return;
	pushdown(p);
	if(ql<=T[p].l&&T[p].r<=qr){
		if(T[p].sum<=v){
			v-=T[p].sum;
			pushnow2(p);
			return;
		}
		if(T[lc].sum<=v){//左区间全被覆盖  
			v-=T[lc].sum;
			pushnow2(lc);
			if(T[rc].sum<=v){
				v-=T[rc].sum;
				pushnow2(rc);
			}
			else update(rc,ql,qr);
		}
		else update(lc,ql,qr);
		pushup(p);
		return;
	}
	int mid=(T[p].l+T[p].r)>>1;
	if(ql<=mid)update(lc,ql,qr);
	if(qr>mid)update(rc,ql,qr);
	pushup(p);
}
void check(int p,int l,int r){
	//pushdown(p);
	//printf("%d %d %d %d %d %d\n",l,r,T[p].sum,T[p].ans,T[p].lsum,T[p].rsum);
	if(l==r){
		printf("%d ",T[p].sum);
		return;
	}
	pushdown(p);
	int mid=(l+r)>>1;
	check(lc,l,mid);
	check(rc,mid+1,r);
}
int main(){
	//freopen("std.in","r",stdin);
	//freopen("my.out","w",stdout);
    scanf("%d",&n);
    build(1,1,n);
    scanf("%d",&m);
    for(int i=1;i<=m;++i){
    	int k;
        scanf("%d",&k);
        if(k==0){
        	int l,r;
        	scanf("%d%d",&l,&r);
        	clear(1,l,r);
		}
    	if(k==1){
    		int l0,r0,l1,r1;
    		scanf("%d%d%d%d",&l0,&r0,&l1,&r1);
    		int all=r0-l0+1-query(1,l0,r0).sum;
    		clear(1,l0,r0);
    		int need=query(1,l1,r1).sum;
    		//printf("%d %d\n",all,need); 
    		v=min(all,need);
    		update(1,l1,r1);
		}
		if(k==2){
			int l,r;
			scanf("%d%d",&l,&r);
			printf("%d\n",query(1,l,r).ans);
		}
		//check(1,1,n);
		//printf("\n\n\n");
    }
    return 0;
}
```
顺便提供一组数据生成器   
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	freopen("std.in","w",stdout);
	srand(time(0));
	int n=100000,m=100000;
	printf("%d %d\n",n,m);
	for(int i=1;i<=m;++i){
		int t=rand()%3;
		printf("%d ",t);
		if(t==0){
			int l=rand()%50000+1,k=rand()%30000;
			printf("%d %d\n",l,l+k);
		}
		if(t==1){
			int l1=rand()%50000+1,r1=rand()%50000+1;
			while(l1>r1)
				l1=rand()%50000+1,r1=rand()%50000+1;
			int l2=rand()%50000+1+(n>>1),r2=rand()%50000+1+(n>>1);
			while(l2>r2)
				l2=rand()%50000+1+(n>>1),r2=rand()%50000+1+(n>>1);
			if(rand()%3)swap(l2,r1);
			if(rand()%2){
				swap(l1,l2);swap(r1,r2);
			}
			printf("%d %d %d %d\n",l1,r1,l2,r2);
		}
		if(t==2){
			int l=1+rand()%30000,r=n-rand()%30000;
			printf("%d %d\n",l,r);
		}
	}
	return 0;
}
```


---

## 作者：ztz11 (赞：0)

## 很多题解都提到了GSS系列的最大连续子段和问题，那我就不说了，我只说这道题中我用到的一些奇妙的解法

### 1.反着定义

这道题要求的是最大连续0的长度，那么用最大子段和的话如果你按1走统计的就不是0，而是1，我们可以将1定义为-inf，0定义为1，再跑最大子段和即可

### 2.分开存

gss中要存一个区间和sum，但由于上面的定义形式，这玩意儿显然不能表示0（或1）的数量，我们可以用一个mix，专门存0或1的数量

## 大体思路：

### 0.首先，给1节点打上-inf的lazy标记，表示没有脑洞

### 1.对于0操作，区间覆盖，打lazy标记后直接修改即可

### 2.对于2操作，GSS标准查询即可

### 3.对于1操作，先求出l1,r1的脑组织数，再全挖成脑洞，之后填进l2,r2去即可(函数写成int式，优先填左区间，填完后返回剩余脑洞数)

### 代码：
```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define rii register int i
#define rij register int j
#define rs 262144
#define int long long
using namespace std;
struct tree{
    long long lmax,rmax,sum,lazy,maxn,mix;
}x[1000005];
int n,m,p;
void pushdown(int nl,int nr,long long val,int bh)
{
    int mid=(nl+nr)/2;
    long long cd=mid-nl+1;
    x[bh*2].lazy=val;
    x[bh*2].lmax=val*cd;
    x[bh*2].rmax=val*cd;
    x[bh*2].sum=val*cd;
    x[bh*2].maxn=val*cd;
    x[bh*2].mix=(val%2)*cd;
    x[bh*2+1].mix=(val%2)*cd;
    x[bh*2+1].lazy=val;
    x[bh*2+1].lmax=val*cd;
    x[bh*2+1].rmax=val*cd;
    x[bh*2+1].sum=val*cd;
    x[bh*2+1].maxn=val*cd;
    x[bh].lazy=0;
}
void fg(int l,int r,int nl,int nr,int bh)
{
    if(l<nl)
    {
        l=nl;
    }
    if(r>nr)
    {
        r=nr;
    }
    if(x[bh].lazy==1)
    {
        return;
    }
    if(x[bh].lazy==-100000)
    {
        pushdown(nl,nr,x[bh].lazy,bh);
    }
    if(l==nl&&r==nr)
    {
        x[bh].lazy=1;
        x[bh].sum=(r-l+1);
        x[bh].lmax=(r-l+1);
        x[bh].rmax=(r-l+1);
        x[bh].maxn=(r-l+1);
        x[bh].mix=(r-l+1);
        return;
    }
    int mid=(nl+nr)/2;
    if(l<=mid)
    {
        fg(l,r,nl,mid,bh*2);
    }
    if(r>=mid+1)
    {
        fg(l,r,mid+1,nr,bh*2+1);
    }
    x[bh].mix=x[bh*2].mix+x[bh*2+1].mix;
    x[bh].sum=x[bh*2].sum+x[bh*2+1].sum;
    x[bh].lmax=max(x[bh*2].lmax,x[bh*2].sum+x[bh*2+1].lmax);
    x[bh].rmax=max(x[bh*2+1].rmax,x[bh*2+1].sum+x[bh*2].rmax);
    x[bh].maxn=max(x[bh*2].maxn,max(x[bh*2+1].maxn,x[bh*2].rmax+x[bh*2+1].lmax));
}
int sum(int l,int r,int nl,int nr,int bh)
{
    if(l<nl)
    {
        l=nl;
    }
    if(r>nr)
    {
        r=nr;
    }
    if(l==nl&&r==nr)
    {
        return x[bh].mix;
    }
    if(x[bh].lazy!=0&&nl!=nr)
    {
        pushdown(nl,nr,x[bh].lazy,bh);
    }
    int mid=(nl+nr)/2;
    int ans=0;
    if(l<=mid)
    {
        ans+=sum(l,r,nl,mid,bh*2);
    }
    if(r>=mid+1)
    {
        ans+=sum(l,r,mid+1,nr,bh*2+1);
    }
    return ans; 
}
int add(int l,int r,int nl,int nr,int sl,int bh)
{
    if(l<nl)
    {
        l=nl;
    }
    if(r>nr)
    {
        r=nr;
    }
    if(x[bh].lazy!=0)
    {
        pushdown(nl,nr,x[bh].lazy,bh);
    }
    if(l==nl&&r==nr&&sl>=(r-l+1))
    {
        sl-=x[bh].mix;
        x[bh].mix=0;
        x[bh].lmax=(-100000)*(r-l+1);
        x[bh].rmax=(-100000)*(r-l+1);
        x[bh].maxn=(-100000)*(r-l+1);
        x[bh].sum=(-100000)*(r-l+1);
        x[bh].lazy=-100000;
        return sl;
    }
    int mid=(nl+nr)/2;
    if(l<=mid&&sl!=0)
    {
        sl=add(l,r,nl,mid,sl,bh*2);
    }
    if(r>=mid+1&&sl!=0)
    {
        sl=add(l,r,mid+1,nr,sl,bh*2+1);
    }
    x[bh].mix=x[bh*2].mix+x[bh*2+1].mix;
    x[bh].sum=x[bh*2].sum+x[bh*2+1].sum;
    x[bh].lmax=max(x[bh*2].lmax,x[bh*2].sum+x[bh*2+1].lmax);
    x[bh].rmax=max(x[bh*2+1].rmax,x[bh*2+1].sum+x[bh*2].rmax);
    x[bh].maxn=max(x[bh*2].maxn,max(x[bh*2+1].maxn,x[bh*2].rmax+x[bh*2+1].lmax));
    return sl;
}
tree query(int l,int r,int nl,int nr,int bh)
{
    tree an,bn;
    if(l<nl)
    {
        l=nl;
    }
    if(r>nr)
    {
        r=nr;
    }
    if(x[bh].lazy!=0)
    {
    	pushdown(nl,nr,x[bh].lazy,bh);
    }
    if(nl==l&&nr==r)
    {
        an=x[bh];
        return an;
    }
    int ltt=(nl+nr)/2;
    if(l<=ltt&&r<=ltt)
    {
        return an=query(l,r,nl,ltt,bh*2);
    }
    if(r>ltt&&l>ltt)
    {
        return bn=query(l,r,ltt+1,nr,bh*2+1);
    }
    else
    {
        an=query(l,r,nl,ltt,bh*2);
        bn=query(l,r,ltt+1,nr,bh*2+1);
        an.maxn=max(an.maxn,max(bn.maxn,an.rmax+bn.lmax));
        an.lmax=max(an.lmax,an.sum+bn.lmax);
        an.rmax=max(bn.rmax,bn.sum+an.rmax);
        an.sum=an.sum+bn.sum;
        return an;
    }
}
signed main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
    scanf("%lld%lld",&n,&m);
    x[1].lazy=-100000;
    for(rii=1;i<=m;i++)
    {
        int l,r;
        scanf("%lld",&p);
        if(p==0)
        {
            scanf("%lld%lld",&l,&r);
            fg(l,r,1,rs,1);
        }
        if(p==2)
        {
            scanf("%lld%lld",&l,&r);
            tree ans=query(l,r,1,rs,1);
            if(ans.maxn<0)
            {
                ans.maxn=0;
            }
            printf("%lld\n",ans.maxn);
        }
        if(p==1)
        {
            int l1,l2,r1,r2;
            scanf("%lld%lld%lld%lld",&l2,&r2,&l1,&r1);
            int ltt=sum(l2,r2,1,rs,1);
            ltt=(r2-l2+1)-ltt;
            fg(l2,r2,1,rs,1);
            if(ltt>(r2-l2+1))
            {
                ltt=r2-l2+1;
            }
            add(l1,r1,1,rs,ltt,1);
        }
    }
}
```

---


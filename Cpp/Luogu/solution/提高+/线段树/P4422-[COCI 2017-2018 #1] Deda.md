# [COCI 2017/2018 #1] Deda

## 题目描述

### 题面描述
小马里卡正在创作一个奇妙的童话故事。她一边编故事，一边讲给她的爷爷听。爷爷可高兴了，于是问了她一些有趣的问题。

在小马里卡的故事中，有 $N$ 个年龄分别为 $1$~$N$ 岁的孩子（最小的为 $1$ 岁，最大的为 $N$ 岁）。有一天，她们一起乘火车出去旅行。铁路线上有好多个车站，分别以 $0, 1, 2, 3 \dots$ 编号。其中第 $0$ 站为始发站，火车每到一个车站都会停下来逗留一段时间。每个孩子都可以在选择自己喜欢的车站下车。

小马里卡喜欢这样讲述她的故事：“在第 $X$ 站，年龄为 $A$ 岁的孩子下车了。”不过小马里卡的习惯非常不好，她讲述故事的顺序是完全随机的。换句话说，$X$ 是不单调的。爷爷知道小马里卡的坏习惯，所以他喜欢时不时问一些有趣的问题来找小马里的麻烦。问题是这样的：“年龄大于等于 $B$ 且在第 $Y$ 站（包含第 $Y$ 站）以前下车的最年轻的小孩是多大？”

小马里卡必须正确回答爷爷的问题，否则爷爷会因生气而睡觉。值得注意的是，小马里卡的答案必须在当时是正确的。虽然小马里卡在随后的讲述中可能会改变问题的答案，但这都是无关紧要的。

小马里卡对自己的坏习惯十分无奈。由于故事的顺序过于杂乱，小马里卡根本无法正确回答爷爷的问题。于是她找到了聪明的你。请帮小马里卡编写一个程序，动态追踪她的讲述，并回答爷爷的问题。

## 样例 #1

### 输入

```
3 4
M 10 3
M 5 1
D 20 2
D 5 1
```

### 输出

```
3
1
```

## 样例 #2

### 输入

```
10 10
M 20 10
D 1 9
M 2 3
D 17 10
M 20 2
D 8 2
M 40 1
D 25 2
M 33 9
D 37 9
```

### 输出

```
-1
-1
3
2
9```

# 题解

## 作者：Utsuji_risshū (赞：16)

没看懂楼下「竞赛树」什么鬼,这题本质不就线段树二分么。。

「年龄大于等于$B$且在第$Y$站（包含第$Y$站）以前下车的最年轻的小孩是多大？」这种询问就是求$[B,N]$区间里值小于$Y$的最小位置,那么就可以以年龄$[1,N]$为下标维护其区间最小值(这里的值指的是$i$岁的人下车位置),添加操作就是让$i$位置值为站点值,查询时就找到$[B,N]$区间,对这个完整区间看其最小值是否比询问值小,小就说明这个岁数区间里有下车点比查询值小的,就顺着找到这个区间最小的叶子结点.可能说的不太清楚,那么,看代码。。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=200000+7,INF=0x3f7f3f7f;
inline int _min(int a,int b){return a<b?a:b;}
inline int read(){
	char c;int f=0,x=0;while(!isdigit(c=getchar()))if(c==45)f=1;
	while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=getchar();return f?-x:x;
}
int minv[N<<2];
char s[3];
int n,q,x,k,ans,qr,ql;
#define l i<<1
#define r i<<1|1
void Update(int i,int L,int R){
	if(L==R){minv[i]=k;return;}
	int mid=L+R>>1;x<=mid?Update(l,L,mid):Update(r,mid+1,R);
	minv[i]=_min(minv[l],minv[r]);
}//维护最小站点位置
int Find(int i,int L,int R){
	if(minv[i]>k)return INF;
	else if(L==R) return L; 
	int mid=L+R>>1;return minv[l]<=k?Find(l,L,mid):Find(r,mid+1,R);
}//这里就是如果ql,qr覆盖了当前区间就在这区间里找满足要求最小岁数
void Query(int i,int L,int R){
	if(ql<=L&&qr>=R){ans=Find(i,L,R);return;}
	int mid=L+R>>1;
	if(ql<=mid){Query(l,L,mid);if(ans!=INF)return;}//小细节,年龄小的已经找到就不用找右边了.
	if(qr>mid)Query(r,mid+1,R);
}
#undef l
#undef r
int main(){
	qr=n=read(),q=read();memset(minv,INF,sizeof minv);//注意清零,想想为什么
	while(q--){
		scanf("%s",s);
		if(s[0]=='M')k=read(),x=read(),Update(1,1,n);
		else k=read(),ql=read(),ans=INF,Query(1,1,n),printf("%d\n",ans==INF?-1:ans);
	}
	return 0;
}
```
~~啊顺便吐槽这小孩能活200000岁怕不是神仙~~

Update:
对了这题也可以套三维偏序板子题来写啊,线段树$O(nlogn)$,三维偏序$O(nlog^2n)$,但是我太弱的暂时写不起来.又想到有一题和这题有些类似(线段树二分)推荐大家也[写一写](https://www.luogu.org/problemnew/show/P4137).

---

## 作者：jyz666 (赞：5)

# 题解 P4422 【[COCI2017-2018#1] Deda】

[传送门](https://www.luogu.com.cn/problem/P4422)

感谢[DRC](https://www.luogu.com.cn/user/249736)大佬

### 题意分析

题目主要是线段树二分.

维护一个线段树来记录时间，然后每次在左右子树分别更新下车的年龄.

二分查找时如果左右子树都有可行的值，取右边的值（因为时间是递增的）.

query中如果这样写，就可以不用在query外再套二分了。
```
	if(t[mk]>u)return 400000;//如果区间中无符合条件的值 
	if(L==R) return L;
```
如有不懂见注释。

### AC代码

```cpp
#include<stdio.h>
#include<cstring>
#include<iostream>
#include<cmath>
#include<algorithm>
#define res register int
#define maxn 200010
#pragma GCC optimize(2)
#pragma GCC optimize(3)//臭氧优化（滑稽）
#define inf 0x3f3f3f3f
typedef long long ll;
using namespace std;
void read(int &x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9')   {if (ch == '-') f = -1; ch = getchar();}
    while (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
    x *= f;
}
int Min(int a,int b){return a<b?a:b;}//手写min比stl快一点点 
#define ls mk<<1|1
#define rs mk<<1
int t[maxn<<2];//tr[k]维护l到r区间:于年龄段l至r,最早何时下车? 
int n,q,v,k,u;
inline int up(int L,int R,int mk){
	if(L==R) return t[mk]=u;
	int mid=L+R>>1,ans;
	if(v>mid){//二分 
		ans=up(mid+1,R,ls);
	}
	else ans=up(L,mid,rs);
	return t[mk]=Min(t[mk],ans);
}
inline int query(int L,int R,int mk){
	if(t[mk]>u)return 400000;//如果区间中无符合条件的值 
	if(L==R) return L;
	int mid=L+R>>1,ans;
	if(mid<v){//如果要找的值在右子树有 
		return query(mid+1,R,ls);
	}
	if((ans=query(L,mid,rs))<200000){
		return ans;
	}
	else return query(mid+1,R,ls);
}
int main(){
	read(n),read(q);
	memset(t,127,sizeof(t));//注意初始化 
	for(int i=1;i<=q;i++){
		char c;
		scanf("%c",&c);
		read(u),read(v);
		if(c=='M'){
			up(1,n,1);
		}
		else{  
			int ans=query(1,n,1); 
			cout<<(ans>200000?-1:ans)<<endl;//判一下 
		}
	}
	return 0;
}
```
有问题评论区留言，谢谢

~~求点赞QWQ~~


---

## 作者：久远寺有珠 (赞：5)

（本题解充斥着丑陋的图片，请紧张地往下看）

yy了一个自以为是线段树的做法，结果本校dalao   @deemoender 指出这东西叫竞赛树,日常被dalao碾压。
先来看什么是竞赛树，假设有这么八支队伍进行两两比赛，赢者晋级输者淘汰，那么我们可以用这样的一个结构来表示这次比赛的结果。

![这就是胜者树](https://cdn.luogu.com.cn/upload/pic/36964.png)
如果比赛队伍不是$2$的正整数次方就会出现轮空的情况，这时只需要进行一点点调整，比如说
![](https://cdn.luogu.com.cn/upload/pic/36967.png)
 @deemoender 说竞赛树有很多神奇的用法，但我不会···幸好对于这道题来说这就已经够用了。
 
那么这个东西怎么用来解决这道题呢？对于每个询问我们需要找出在$Y$站或$Y$站之前下车的大于等于$B$岁的人中的年龄最小的人的岁数（好拗口）我们可以想到，假设说有这么一群人，他们当中下车最早的一个在Y站都没有下车，那么他们中就不可能有在$Y$站或以前下车的了（因为下车最早的那个在$Y$都没下车），那么我们就可以维护一棵竞赛树来表示一群人中下车最早的，比如说像这样（因为要维护最小值，所以我们用$INF$来表示没下车的）：
![](https://cdn.luogu.com.cn/upload/pic/36971.png)

叶子节点从左向右表示年龄从大到小。

假设我们有这样一个查询在$25$站以前下车的大于等于$2$岁的人，我们来操作一下

最顶上的“$7$”告诉我们这群人中最早下车的是在“$7$”，而这个查询是要问$25$之前的，说明这群人里有在$25$之前下车的

它的左儿子是“$7$”，同上，我们来到了它的左儿子，这个点的左儿子是“$50$”，这群人里到了“$50$”才下车，显然不符合条件，而右儿子是“$7$”，我们来到它的右儿子

它的左儿子是“$14$”，右儿子是“$7$”，由于题目要求我们找的是年龄最小的，而左儿子的年龄（或者说左儿子表示的一群人的总体年龄）是小于右儿子的，所以尽管右儿子下车更早，但我们仍然来到了左儿子。

此时我们来到了一个叶子节点，我们就可以返回它的年龄$3$了。

在查询时遵循以下几个要点：

1、尽量往左子树走，左子树找不出合适的人了再找右子树，因为左边的人比右边的年轻。

2、注意查询的边界，不要查询了年龄小于$B$的人。

开始说了我是自己yy的所谓“线段树”做法，所以我的树建出来大概是这样的

![](https://cdn.luogu.com.cn/upload/pic/36977.png)
如果你按照步骤一步一步来模拟可以发现答案是一样的（但dalao和我说有些竞赛树的操作用这种建树的方式是实现不了的，吓得我赶紧去学竞赛树去了）

接下来是我自己的丑陋的代码
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
struct stu{
    int lc,rc;
    long long int ans,tag;
};
stu tree[500050];
int k=1;
int n,q;
void build(int l,int r,int nu)//我平时所用的建树方式 
{
    tree[nu].ans=0x7f7f7f7f;//赋初值为0x7f7f7f7f 
    if (l==r)
    {
        return;
    }
    int mid=(l+r)/2;
    k++;
    tree[nu].lc=k;
    build(l,mid,tree[nu].lc);
    k++;
    tree[nu].rc=k;
    build(mid+1,r,tree[nu].rc);
}
void update(int l,int r,int ll,int u,long long int v)//线段树单点修改 
{
    if (l==ll&&r==ll)
    {
        tree[u].ans=v;
        return;
    }
    int mid=(l+r)/2;
    if (ll<=mid)
    {
        update(l,mid,ll,tree[u].lc,v);
    }
    else
    {
        update(mid+1,r,ll,tree[u].rc,v);
    }
    tree[u].ans=min(tree[tree[u].lc].ans,tree[tree[u].rc].ans);//维护最早下车的在哪里下车 
}
int quary(int l,int r,int ll,int rr,int u,long long int v)//线段树区间查询 
{
    if (l==r)
    {
        return l;//返回年龄 
    }
    int mid=(l+r)/2;
    if (rr<=mid)//线段树的区间查询方式 
    {
        if (tree[tree[u].lc].ans>v)//找不出合适的人就返回0x7f7f7f 
        {
            return 0x7f7f7f;
        }
        else
        {
            return quary(l,mid,ll,rr,tree[u].lc,v);
        }
    }
    else if (ll>mid)//同上 
    {
        if (tree[tree[u].rc].ans>v)
        {
            return 0x7f7f7f;
        }
        else return quary(mid+1,r,ll,rr,tree[u].rc,v);
    }
    else
    {
        int a1=0x7f7f7f,a2=0x7f7f7f;
        if (tree[tree[u].lc].ans<=v)//先找左区间 
        {
            a1=quary(l,mid,ll,mid,tree[u].lc,v);
        }
        if (tree[tree[u].rc].ans<=v&&a1==0x7f7f7f)//左区间实在是没有合适的人了再找右区间 
        {
            a2=quary(mid+1,r,mid+1,rr,tree[u].rc,v);
        }
        return min(a1,a2);
    }
}
int main()
{
   // freopen("deda.in","r",stdin);
   // freopen("deda.out","w",stdout);
    scanf("%d%d",&n,&q);
    build(1,n,1);//建树 
    for (int i=1;i<=q;i++)
    {
        char flag[1];
        long long int X;
        int B; 
        scanf("%s%lld%d",flag,&X,&B);
        if (flag[0]=='M')
        {
            update(1,n,B,1,X);
        }
        else
        {
            int lll=quary(1,n,B,n,1,X);//区间查询年龄从B到 N（年龄的最大值）的人。 
            if (lll==0x7f7f7f)//没有符合条件的人就输出-1； 
            {
                printf("-1\n");
            }
            else
            {
                printf("%d\n",lll);
            }
        }
    }
    return 0;
}
```

---

## 作者：qzhwlzy (赞：3)

### [传送门](https://www.luogu.com.cn/problem/P4422)
## 思路
看到题目中孩子分别为 $1 \sim n$ 岁，想到了用年龄为下标，构造**线段树**。  
此题的更改为**单点更改**。“在第 $X$ 站，年龄为 $A$ 岁的孩子下车了。”就是将下标为 $A$ 的点的值改为 $X$ 。  
此题的查询为**区间查询**。“年龄大于等于 $B$ 且在第 $Y$ 站（包含第 $Y$ 站）以前下车的最年轻的小孩是多大？”换句话说，就是在 $[B,N]$ 的区间中找出值小于 $Y$ 的最小下标。寻找过程思路如下（~~看不懂就对了~~）：  
1. 搜索区间是否在 $[B,N]$ 范围内？若是，进行下一步。否则，搜索左右字数，重复步骤 $1$ 。
2. 若该区间是叶子节点（即找到某个孩子）且值小于 $Y$ ，返回下标。若不是叶子节点，进行下一步。
3. 若左区间的最小值小于 $Y$ ，搜索左子树（因为要输出最小下标），否则搜索右子树，进行下一步。
4. 若搜到的是叶子节点，进行第 $2$ 步，否则进行第 $3$ 步。
## AC代码
###### ~~本人不压行~~
```cpp
#include<iostream>
#include<cstdio>
#define maxn 200010
#define INF 0x3fffffff//开始时把每个节点赋成最大值
using namespace std;
struct node{
	int l,r,mind;//mind存该区间的最小值
}a[maxn*10];
int n,q;
char op;
int x,y;
void pushup(int i){
	a[i].mind=min(a[i*2].mind,a[i*2+1].mind);
}
void build(int i,int l,int r){//建树基本操作
	a[i].l=l;
	a[i].r=r;
	if(l==r){
		a[i].mind=INF;
		a[i*2].mind=INF;
		a[i*2+1].mind=INF;
		return;
	}else{
		build(i*2,l,(l+r)/2);
		build(i*2+1,(l+r)/2+1,r);
	}
	pushup(i);
}
void update(int i,int y,int s){//单点修改基本操作
	if(a[i].l==a[i].r&&a[i].l==y){
		a[i].mind=s;
		return;
	}
	if(a[i*2].r>=y){
		update(i*2,y,s);
	}else if(a[i*2+1].l<=y){
		update(i*2+1,y,s);
	}
	pushup(i);
}
int search(int i,int l,int r,int s){//搜索
	int ans=INF;
	if(a[i].l==a[i].r&&a[i].mind<=s){//上述操作2
		return a[i].l;
	}else if(a[i].l>=l&&a[i].r<=r){//上述操作1
		if(a[i*2].mind<=s){
			ans=search(i*2,l,r,s);
		}else if(a[i*2+1].mind<=s){
			ans=search(i*2+1,l,r,s);
		}
		return ans;
	}else{//上述操作3
		if(a[i*2].r>=l){
			ans=search(i*2,l,r,s);
		}
		if(a[i*2+1].l<=r){
			ans=min(search(i*2+1,l,r,s),ans);
		}
		return ans;
	}
}
int main(){
	scanf("%d%d",&n,&q);
	build(1,1,n);
	for(int i=1;i<=q;i++){
		scanf("\n%c",&op);
		scanf("%d%d",&x,&y);
		if(op=='M'){
			update(1,y,x);//年龄y在x站下车了 
		}else if(op=='D'){
			int ans=search(1,y,n,x);//年龄y~n且在x站前下车的 
			if(ans==INF){
				printf("-1\n");
			}else{
				printf("%d\n",ans);
			}
		}
	}
	return 0;//完结撒花
}
```
###### ~~勿喷~~

---

## 作者：VenusM1nT (赞：3)

观察到年龄很小而车站编号很大，考虑以年龄为位置建线段树，每个位置存该年龄最早出现的车站，然后瞎递归一下找符合年龄区间里是否有符合条件的车站就可以了。
```cpp
#include<bits/stdc++.h>
#define N 200000
#define reg register
#define inl inline
#define inf 1010580540
using namespace std;
int n,Q,t[N*4+5],ans;
void Modify(reg int rt,reg int l,reg int r,reg int pos,reg int x)
{
	if(l==r) return t[rt]=x,void();
	reg int mid=(l+r)>>1;
	if(pos<=mid) Modify(rt<<1,l,mid,pos,x);
	else Modify(rt<<1|1,mid+1,r,pos,x);
	t[rt]=min(t[rt<<1],t[rt<<1|1]);
}
int Find(reg int rt,reg int l,reg int r,reg int x)
{
	if(t[rt]>x) return inf;
	if(l==r) return l;
	reg int mid=(l+r)>>1;
	if(t[rt<<1]<=x) return Find(rt<<1,l,mid,x);
	else return Find(rt<<1|1,mid+1,r,x);
}
void Query(reg int rt,reg int l,reg int r,reg int tl,reg int tr,reg int x)
{
	if(tl<=l && r<=tr) return ans=Find(rt,l,r,x),void();
	reg int mid=(l+r)>>1;
	if(tl<=mid) Query(rt<<1,l,mid,tl,tr,x);
	if(ans!=inf) return;
	if(tr>mid) Query(rt<<1|1,mid+1,r,tl,tr,x);
}
int main()
{
	memset(t,60,sizeof(t));
	scanf("%d %d",&n,&Q);
	while(Q--)
	{
		reg int x,y;
		reg char opt[5];
		scanf("%s %d %d",opt+1,&x,&y);
		if(opt[1]=='M') Modify(1,1,n,y,x);
		else
		{
			ans=inf;
			Query(1,1,n,y,n,x);
			printf("%d\n",ans==inf?-1:ans);
		}
	}
	return 0;
}
```

---

## 作者：Juan_feng (赞：2)

这题是小JF在学长的考试题里见到的，听同级的dalao说分块要n log n sqrt n ,不信邪的JF就写了个n sqrt n 的做法，代码量自然不大, 思路也不难想。连写带调也就花了20分钟，下面就说一下具体思路。

维护一下快内的最小值，散块直接暴力循环， 整块看维护的最小值是否小于等于查询值，如果不符合的话就可以直接跳过，否则答案就一定在该块中，暴力循环即可，复杂度 n sqrt n ， 而且这个最小值是非常好维护的，因为每个点最多被修改一次，所以直接取min就好了，修改的复杂度O1

所以该算法的修改是O1 查询是 O(sqrt n) 足以通过此题

另：因为要求的是第一个小于等于某数的位置，所以分块查询的时候要注意散块和整块的查询顺序， 一开始sb的JF还因为习惯先查散块再查整块WA掉了，顺序应该是： 左散块 -> 中间的整块 -> 右散块

然后就没什么啦，有什么问题可以私信小蒟蒻。

那么代码如下：

```
#include<iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#define maxn 200010
#define re register
#define FOR(i, l, r) for(re int i = l; i <= r; ++i)
using namespace std;

int n, m, c, r, x, y, z, k;
int sq;
int a[maxn], b[maxn], minn[2002];
char t;

inline void in(re int &x){
    x=0;int bl = 1;char c=getchar();
    while(c<'0'||c>'9'){
    	if(c == '-')
    	  bl = -1;
        c=getchar();
    }
    while(c<='9'&&c>='0'){
        x=(x<<1)+(x<<3)+(c^'0');
        c=getchar();
    }
    x *= bl;
}

void out(re int a){
	if(a < 0) {
		putchar('-');
		a = -a;
	}
    if(a>=10)out(a/10);
    putchar(a%10+'0');
}


inline int query(int x, int y, int k) {
	FOR(i, x, min(y, b[x]*sq)) //左散块
	  if(a[i] <= k)
	    return i;
	FOR(i, b[x]+1, b[y]-1) { //整块
		if(minn[i] > k) //如果不符合直接跳过
		  continue;
		FOR(j, (i-1)*sq+1, i*sq) //暴力找
		  if(a[j] <= k)
		    return j; 
	}	
	if(b[x] != b[y]) //右散块
	  FOR(i, (b[y]-1)*sq+1, y)
	    if(a[i] <= k)
	      return i;
	return -1;
}

int main(){
	in(n), in(m);
	sq = sqrt(n);
	FOR(i, 1, sq+100)
	  minn[i] = 0x7fffffff;
	FOR(i, 1, n)
	  a[i] = 0x7fffffff, b[i] = (i-1)/sq+1, minn[b[i]] = min(minn[b[i]], a[i]);
	FOR(i, 1, m) {
		cin >> t;
		if(t == 'M') {
			in(x), in(y); // y改成x; 
			a[y] = x;
			minn[b[y]] = min(minn[b[y]], x); //维护最小值
		}
		else {
			in(k), in(x);
			out(query(x, n, k));
			putchar(10);
		}
	}

} 
```

---

## 作者：斜揽残箫 (赞：1)

## Solution

当看到题目中 $2 \leq n \leq 2 \times 10 ^ 5$ 和 $1 \leq x,y \leq 10 ^ 9$ 和空间的 $\text{62.5MB}$，提示了我们要按年龄建树，否则就算你写动态开点线段树也会 $\text{MLE}$。

首先，根据年龄，建一棵线段树，之后对于小马里卡的话，对线段树进行单点修改，并且向上修改区间最小值即可。

如果是爷爷的话，可以理解为求区间 $[B,N]$ 之间下车的地方大于 $Y$ 的最小值。

这样的话我们在查询的时候，就可以按照以下思路查询 ： 

+ 当整个区间都在左子树，递归搜索左子树，如果左子树的下车位置的最小值大于 $Y$ 直接返回。
+ 当整个区间都在左子树，递归搜索右子树，如果右子树的下车位置的最小值大于 $Y$ 直接返回。
+ 当区间一部分在左子树，一部分在右子树，那么先搜索左子树，再搜索右子树，因为我们要保证年龄最小，如果下车位置最小值小于等于 $Y$ 搜索左子树，如果发现没有搜到结果，同理，再搜索右子树。
+ 如果当前是一个叶子结点，更新答案，也就是和区间端点取最小值。

如果有一部分在左子树，一部分在右子树，查询右子树的时候要先判断是否答案已经被更新过，如果更新过就不用搜索了，否则会超时。

还有就是一开始整棵树的最小值都要赋值为 INF。

## Code
```
#include <cstdio>
#include <cmath>
#include <iostream>
#include <cstring>
#include <algorithm>
#define INF 0x3f3f3f3f 
using namespace std;
const int Maxk = 2e6 + 10;
struct SegTree {
  int l,r,min_;
}t[Maxk << 2];
int n,m,cnt,Ans;
inline int read()
{
	int s = 0, f = 0;char ch = getchar();
	while (!isdigit(ch)) f |= ch == '-', ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}
void build(int i,int l,int r)
{
  t[i].l = l;
  t[i].r = r;
  t[i].min_ = INF;
  if(l == r) {
    t[i].min_ = INF;
    return;
  }
  int mid = (l + r) >> 1;
  build(i << 1,l,mid);
  build(i << 1 | 1,mid + 1,r);
}
void Add(int i,int pos,int k)
{
  if(t[i].l == t[i].r && pos == t[i].l) {
    t[i].min_ = k;
    return;
  } 
  int mid = (t[i].l + t[i].r) >> 1;
  if(pos <= mid) Add(i << 1,pos,k);
  else Add(i << 1 | 1,pos,k);
  t[i].min_ = min(t[i << 1].min_,t[i << 1 | 1].min_);
}
void Ask(int i,int l,int r,int k)
{
  if(t[i].l == t[i].r) {Ans = min(Ans,t[i].l);return;}
  int mid = (t[i].l + t[i].r) >> 1;
  if(r < mid) {//整个区间要求的的区间都在这个区间的左边 
    if(t[i << 1].min_ > k) return;
    else Ask(i << 1,l,r,k); 
  }
  else if(l > mid) {
    if(t[i << 1 | 1].min_ > k) return;
    else if(Ans == INF) Ask(i << 1 | 1,l,r,k);
  }
  else {
    if(t[i << 1].min_ <= k) Ask(i << 1,l,r,k);
    if(t[i << 1 | 1].min_ <= k && Ans == INF) Ask(i << 1 | 1,l,r,k);
  } 
  return;
} 
signed main()
{
  n = read(),m = read();
  build(1,1,n);
  for(int i = 1;i <= m;i ++) {
    char c;cin >> c;
    if(c == 'M') {
      int x = read(),A = read();
      Add(1,A,x);
    }
    else {
      int y = read(),b = read();
      Ans = INF;Ask(1,b,n,y);
      printf("%d\n",Ans == INF ? -1 : Ans);
    }
  }
  return 0;
}
```

---

## 作者：abandentsky (赞：1)

题意：题目的意思很好理解，有很多的小学生，小学生有一个年龄可以选择一个站点下去。现在我们按照时间顺序来询问在y车站前下去的小学生最小年龄。
思路：思路和下面的大佬的一样，按照年龄来建立一棵线段树，然后在区间里面找到满足值小于y的最小下标。
注意：这个题目在读入操作的时候千万不要用cin读取字符。这样超时5个点，把min函数改成自己写的wrong四个点。把cin改成scanf，就AC。还有自己写的快读稍微比scanf快点。好像也没有其他坑点了。感觉楼下大佬代码太强了，我来贴一个书写简单点的。（自己可以亲测一下）。
```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 200010
#define maxnode 50010
#define sigma_size 26
#define md 1000000007
#define INF 0x3f3f3f3f

using namespace std;
typedef long long LL;

struct node     //以年龄为线段树，并且线段树维护最小站点
{                         //线段树判定区间是否存在比y小的值，如果存在找到最早的小于y的位置点的下标
    int l,r;
    int minn;
}tr[MAXN<<2];
int n,q;

inline int _min(int a,int b){return a<b?a:b;}

inline int read(){
    char c;int f=0,x=0;while(!isdigit(c=getchar()))if(c==45)f=1;
    while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=getchar();return f?-x:x;
}

void build(int id,int l,int r)
{
    tr[id].l=l,tr[id].r=r,tr[id].minn=INF;
    if(l==r)
    {
        tr[id].minn=INF;
        return ;
    }
    int mid=(l+r)>>1;
    build(id<<1,l,mid);
    build(id<<1|1,mid+1,r);
    tr[id].minn=_min(tr[id<<1].minn,tr[id<<1|1].minn);
}

void update(int id,int pp,int val)
{
    if(tr[id].l==tr[id].r)
    {
        tr[id].minn=_min(tr[id].minn,val);
        return ;
    }
    int mid=(tr[id].l+tr[id].r)>>1;
    if(pp<=mid)
        update(id<<1,pp,val);
    else
        update(id<<1|1,pp,val);
    tr[id].minn=_min(tr[id<<1].minn,tr[id<<1|1].minn);
}

int query(int id,int l,int r)
{
    if(tr[id].l>=l&&tr[id].r<=r)
    {
        return tr[id].minn;
    }
    int mid=(tr[id].l+tr[id].r)>>1;
    int ans=INF;
    if(l<=mid)
        ans=_min(ans,query(id<<1,l,r));
    if(r>mid)
        ans=_min(ans,query(id<<1|1,l,r));
    return ans;
}

int main()
{
    scanf("%d %d",&n,&q);
    build(1,1,n);                                                  //孩子的年龄大小值不会超过孩子的数量
    char op[100];
    int u,v;
    for(int i=1;i<=q;i++)
    {
        scanf("%s",op);
        u=read(),v=read();
        if(op[0]=='M')
        {
            update(1,v,u);      //在u站，年龄为v的下车 ,在v点更新u
        }
        else if(op[0]=='D')
        {
            if(query(1,v,n)>u)      //查找年龄区间[v,n]之间是不是存在车站小于u
            {
                printf("-1\n");
            }
            else
            {
                int L=v,R=n;     //这里面二分的左右区间一定要注意
                while(L<R)
                {
                    int mid=(L+R)>>1;
                    if(query(1,L,mid)<=u)
                        R=mid;
                    else
                        L=mid+1;
                }
                printf("%d\n",R);
            }
        }
    }
    return 0;
}

```


---

## 作者：斗神_君莫笑 (赞：1)

考虑求解什么就以什么建树  
那么就以年龄建树  
显然我们可以维护区间最小的下车车站  
因为下车车站越前就越优  

update部分和基础线段树一样  
重点是query部分  
我们维护的仅仅是区间有没有在Y之前下车这个信息  
而需要的并不是最早下车的人，是最小年龄  
所以应该一直向前查找  
代码有些丑陋  
```cpp
#include<bits/stdc++.h>
#define lc (p<<1)
#define rc (p<<1|1)
using namespace std;
struct Edge{
	int l,r,sum,place;
}T[800010];
void build(int p,int l,int r){
	T[p].l=l;T[p].r=r;
	T[p].sum=0x3f3f3f3f;
	if(l==r){
		T[p].place=l;
		return;
	}
	int mid=(l+r)>>1;
	build(lc,l,mid);
	build(rc,mid+1,r);
}
inline void pushup(int p){
	if(T[lc].sum<T[rc].sum){
		T[p].sum=T[lc].sum;
		T[p].place=T[lc].place;
	}
	else{
		T[p].sum=T[rc].sum;
		T[p].place=T[rc].place;
	}
}
void update(int p,int q,int v){
	if(T[p].l==T[p].r){
		T[p].sum=min(T[p].sum,v);
		return;
	}
	int mid=(T[p].l+T[p].r)>>1;
	if(q<=mid)update(lc,q,v);
	if(q>mid)update(rc,q,v);
	pushup(p);
} 
pair<int,int> query(int p,int ql,int qr,int v){
	if(T[p].l==T[p].r){
		return make_pair(T[p].sum,T[p].place);
	}
	if(ql<=T[p].l&&T[p].r<=qr){
		if(T[p].sum<=v){
			if(T[lc].sum<=v)return query(lc,ql,qr,v);
			return query(rc,ql,qr,v);
		}
		//printf("%d %d %d %d\n",T[p].l,T[p].r,T[p].sum,T[p].place);
		return make_pair(0x3f3f3f3f,0); 
	}
	int mid=(T[p].l+T[p].r)>>1;
	pair<int,int>ans(0x3f3f3f3f,0);
	if(ql<=mid){
		ans=query(lc,ql,qr,v);
		if(ans.first<=v){
			//printf("%d %d %d %d\n",T[p].l,T[p].r,ans.first,ans.second);
			return ans;
		}
	}
	if(qr>mid){
		ans=query(rc,ql,qr,v);
		if(ans.first<=v){
			//printf("%d %d %d %d\n",T[p].l,T[p].r,ans.first,ans.second);
			return ans;
		}
	}
	//printf("%d %d %d %d\n",T[p].l,T[p].r,ans.first,ans.second);
	return ans;
}
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	build(1,1,n);
	for(int i=1;i<=m;++i){
		char s[3];scanf("%s",s);
		if(s[0]=='M'){
			int x,age;
			scanf("%d%d",&x,&age);
			update(1,age,x);
		}
		if(s[0]=='D'){
			int x,age;
			scanf("%d%d",&x,&age);
			pair<int,int>ans=query(1,age,n,x);
			if(ans.first>x)printf("-1\n");
			else printf("%d\n",ans.second);
		}
	}
	return 0;
}
```


---

## 作者：zhengrunzhe (赞：1)

~~kdtree裸题~~

显然这题是个二维偏序，把年龄记作age[],车站记作stop[],即询问所有x满足age[x]>=queryage且stop[x]<=querystop中age[x]的最小值

q<=2*10^5 显然这个东西可以直接硬上树套树 ~~所以我选择kdtree~~

把每个插入操作变作二维平面的点(stop,age)且点权为age

询问就是查以(-∞,queryage)为左上角,(querystop,+∞)为右下角的矩形中的点权最小值

```cpp
#include<cstdio>
#include<algorithm>
using std::max;
using std::min;
using std::nth_element;
const int K=2,N=2e5+10,INF=2147483647;
int n,q,f;
struct point
{
	int d[K],w;
	inline point(int a=0,int b=0,int c=0):w(c){d[0]=a;d[1]=b;}
	inline const bool operator<(const point &p)const
	{
		return d[f]<p.d[f];
	}
}a[N];
class KD_Tree
{
	static const double alpha=0.75;
	private:
		struct tree
		{
			int size;
			tree *son[2];
			point mx,mn,range;
			inline const void pushup()
			{
				size=son[0]->size+1+son[1]->size;
				mn.w=min(range.w,min(son[0]->mn.w,son[1]->mn.w));
				for (int i=0;i<K;i++)
					mn.d[i]=min(range.d[i],min(son[0]->mn.d[i],son[1]->mn.d[i])),
					mx.d[i]=max(range.d[i],max(son[0]->mx.d[i],son[1]->mx.d[i]));
			}
			inline const bool unbalanced()
			{
				return son[0]->size>size*alpha||son[1]->size>size*alpha;
			}
			inline const bool out(const point &lower,const point &upper)
			{
				for (int i=0;i<K;i++)
					if (mn.d[i]>upper.d[i]||mx.d[i]<lower.d[i])
						return 1;
				return 0;
			}
			inline const bool in(const point &lower,const point &upper)
			{
				for (int i=0;i<K;i++)
					if (!(mn.d[i]>=lower.d[i]&&mx.d[i]<=upper.d[i]))
						return 0;
				return 1;
			}
			inline const bool at(const point &lower,const point &upper)
			{
				for (int i=0;i<K;i++)
					if (!(range.d[i]>=lower.d[i]&&range.d[i]<=upper.d[i]))
						return 0;
				return 1;
			}
		}*root,memory_pool[N],*recycle[N],*tail,*null;
		int top,cnt,flag,mn;
		inline const void init()
		{
			tail=memory_pool;
			null=tail++;
			null->mn.w=INF;
			root=null->son[0]=null->son[1]=null;
			for (int i=0;i<K;i++)null->mn.d[i]=INF,null->mx.d[i]=-INF;
		}
		inline tree *spawn(const point &x)
		{
			tree *p=top?recycle[--top]:tail++;
			p->son[0]=p->son[1]=null;
			p->range=p->mn=p->mx=x;
			p->size=1;
			return p;
		}
		inline const void reuse(tree *p)
		{
			recycle[top++]=p;
		}
		inline const void travel(tree *p)
		{
			if (p==null)return;
			travel(p->son[0]);
			a[++cnt]=p->range;reuse(p);
			travel(p->son[1]);
		}
		inline tree *build(int l,int r,int d)
		{
			if (l>r)return null;
			int mid=l+r>>1;f=d;
			nth_element(a+l,a+mid,a+r+1);
			tree *p=spawn(a[mid]);
			if (l==r)return p;
			p->son[0]=build(l,mid-1,(d+1)%K);
			p->son[1]=build(mid+1,r,(d+1)%K);
			p->pushup();
			return p;
		}
		inline const void rebuild(tree *&p,int d)
		{
			cnt=0;
			travel(p);
			p=build(1,cnt,d);
		}
		inline tree **insert(tree *&p,const point &x,int d)
		{
			if (p==null)return p=spawn(x),&null;
			tree **bad=insert(p->son[p->range.d[d]<x.d[d]],x,(d+1)%K);
			p->pushup();
			if (p->unbalanced())bad=&p,flag=d;
			return bad;
		}
		inline const void query(tree *p,const point &x,const point &y)
		{
			if (p==null)return;
			if (p->mn.w>=mn)return;
			if (p->out(x,y))return;
			if (p->in(x,y))return (void)(mn=p->mn.w);
			if (p->at(x,y))mn=min(mn,p->range.w);
			query(p->son[0],x,y);query(p->son[1],x,y);
		}
	public:
		inline KD_Tree(){init();}
		inline const void insert(int x,int y)
		{
			tree **bad=insert(root,point(x,y,y),flag=0);
			if (*bad==null)return;
			rebuild(*bad,flag);
		}
		inline const int query(int x,int y)
		{
			mn=INF;
			query(root,point(-INF,y),point(x,INF));
			return mn^INF?mn:-1;
		}
}kdt;
int main()
{
	scanf("%d%d",&n,&q);
	char opt;for (int x,y;q--;)
		if (scanf(" %c%d%d",&opt,&x,&y),opt=='M')kdt.insert(x,y);
		else printf("%d\n",kdt.query(x,y));
	return 0;
}
```

---

## 作者：Acestar (赞：1)

一道比较显然的线段树，因为我们要求**大于等于 $B$ 且在第 $Y$ 站(包含第 $Y$ 站)以前下车的最年轻的小孩是多大**，所以我们可以发现把年龄作为下角标，存是在第几站下的车，每次查找年龄为 $B-N$ 中的第一个在小于等于 $Y$ 站下车的小孩的年龄。

我们用 $mins_{rt}$ 存以 $rt$ 为根的子树中值最小的是几，然后每次查找就先找出每个合法子树，再在这个子树中判断左子树的最小值是否合法，如果合法就进左子树，否则，进右子树，最后返回下角标，因为我们要找最小的，所以从左子树开始，之后再写一个单点修改就可以了。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#define N 200010
#define INF 0x3f3f3f3f

using namespace std;

int mins[N<<2],ans;

void pushup(int rt)
{
	mins[rt]=min(mins[rt<<1],mins[rt<<1|1]);
}


void update(int p,int x,int l,int r,int rt)	//单点修改：mins[p]=x 
{
	if(l==r)
	{
		mins[rt]=x;
		return;
	}
	int mid=(l+r)>>1;
	if(p<=mid) update(p,x,l,mid,rt<<1);
	else update(p,x,mid+1,r,rt<<1|1);
	pushup(rt);
}

int Find(int x,int l,int r,int rt)	//查找以rt为根的子树中的第一个<=x的下角标 
{
	if(mins[rt]>x) return INF;
	else if(l==r) return l;
	int mid=(l+r)>>1;
	if(mins[rt<<1]<=x) return Find(x,l,mid,rt<<1);
	else return Find(x,mid+1,r,rt<<1|1);
}

void query(int L,int R,int x,int l,int r,int rt)	//在整个树中查找范围在L-R内的子树 
{
	if(L<=l&&r<=R)
	{
		ans=Find(x,l,r,rt);
		return;
	}
	int mid=(l+r)>>1;
	if(L<=mid)
	{
		query(L,R,x,l,mid,rt<<1);
		if(ans!=INF) return;
	}
	if(mid<R) query(L,R,x,mid+1,r,rt<<1|1); 
}

int read()	//快读 
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
	return x;
}

int main()
{
	int n=read(),m=read();
	memset(mins,0x7f,sizeof(mins));
	while(m--)
	{
		char ch[5];
		scanf("%s",ch);
		int x=read(),y=read();
		if(ch[0]=='M')
			update(y,x,1,n,1);	//年龄为y的在第x站下车
		else
		{
			query(y,n,x,1,n,1);	//在y-n岁中找第一个<=x的年龄 
			if(ans==INF) puts("-1");
			else printf("%d\n",ans);
		}
	}
	return 0;
}
```


---

## 作者：MSqwq (赞：0)

考试还想用线段树，树状数组什么的，还打了离散化，树状数组都写好了。然而后面发现并不能（好像又可以？）。于是开始暴力。暴力的分数很震惊。对此感到惊异...

结果正解线段树板题。

由于年龄很小，我们用它作为线段树的下标（然后考试就没想到）。然后我们遇到查询，仅需查询$B$到$N$区间中车站是否$Y$，返回那个下标。最后加个剪枝：在前面区间搜到答案便不用管后面。感觉还真挺简单。其实就是改变下标这一个点。  

实现也就很简单了：  
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct qwe{
	ll l,r,v;
}t[8000000];
void build(ll p,ll x,ll y)
{
	t[p].l=x;
	t[p].r=y;
	t[p].v=1e9;
	if(x==y)return;
	build(p*2,x,(x+y)/2);
	build(p*2+1,(x+y)/2+1,y);
}

void change(ll p,ll x,ll d)
{
	if(t[p].l==t[p].r)
	{
		t[p].v=d;
		return;
	}
	ll mid=(t[p].l+t[p].r)/2;
	if(x<=mid)change(p*2,x,d);
	else change(p*2+1,x,d);
	t[p].v=min(t[p*2].v,t[p*2+1].v);
}

ll solve(ll p,ll x,ll y)
{
	if(x<=t[p].l&&t[p].r<=y)return t[p].v;
	
	ll mid=(t[p].l+t[p].r)/2;
	ll ans=1e9;
	if(x<=mid)ans=solve(p*2,x,y);
	if(y>mid)ans=min(ans,solve(p*2+1,x,y));
	
	return ans;
}

ll gs(ll p,ll x,ll y,ll z)
{
	if(t[p].l==t[p].r)return t[p].l;
	if(x<=t[p].l&&y>=t[p].r)
	{
		if(t[p*2].v<=z)return gs(p*2,x,y,z);
		else return gs(p*2+1,x,y,z);
	}
	ll mid=(t[p].l+t[p].r)/2;
	ll ans=0;
	if(x<=mid&&solve(p*2,x,y)<=z)return gs(p*2,x,y,z);
	else return gs(p*2+1,x,y,z);
	
	return ans; 
}
ll n,m;
char op;
ll x,y,z;
int main()
{
	scanf("%lld%lld",&n,&m);
	build(1,1,n);
	for(int i=1;i<=m;i++)
	{
		cin>>op;
		scanf("%lld%lld",&x,&y);
		if(op=='M')change(1,y,x);
		else 
		{
			if(x<solve(1,y,n))printf("-1\n");
			else printf("%lld\n",gs(1,y,n,x));
		}
	}
}
```


---

## 作者：ModestCoder_ (赞：0)

这是二维偏序，注意到每个小朋友的年龄为$1-n$不同

可以按照小朋友的年龄为线段树的下标，维护一段小朋友区间中最小的站台

每次$update$暴力把所有包含这个小朋友的区间更新，这个部分稳定$O(nlogn)$

每次$query$先看看能不能往左找到满足的小朋友，不行看看往右走可不可以

算是一个常数比较大的线段树

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 200010
#define ls rt << 1
#define rs rt << 1 | 1
using namespace std;
const int inf = 2000000000;
struct Seg{
	int l, r, sum;
}seg[maxn << 3];
int n, m;

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

void pushup(int rt){ seg[rt].sum = min(seg[ls].sum, seg[rs].sum); }

void build(int rt, int l, int r){
	seg[rt].l = l, seg[rt].r = r, seg[rt].sum = inf;
//	printf("BUild:%d %d %d\n", seg[rt].l, seg[rt].r, seg[rt].sum);
	if (l == r) return;
	int mid = (l + r) >> 1;
	build(ls, l, mid), build(rs, mid + 1, r);
}

void update(int rt, int y, int x){
	if (seg[rt].r < y || seg[rt].l > y) return;
	seg[rt].sum = min(seg[rt].sum, x);
//	printf("Update:%d %d %d\n", seg[rt].l, seg[rt].r, seg[rt].sum);
	update(ls, y, x), update(rs, y, x);
}

int query(int rt, int y, int x){
	if (seg[rt].r < y) return inf;
//	printf("Query:%d %d %d\n", seg[rt].l, seg[rt].r, seg[rt].sum);
	if (seg[rt].l == seg[rt].r) return seg[rt].l;
	int ans = inf;
	if (seg[ls].sum <= x) ans = min(ans, query(ls, y, x));
	if (ans < inf) return ans;
//	printf("%d\n", x);
	if (seg[rs].sum <= x) ans = min(ans, query(rs, y, x));
	return ans;
}

int main(){
	freopen("deda.in", "r", stdin);
	freopen("deda.out", "w", stdout);
	n = read(), m = read();
	build(1, 1, n);
	while (m--){//printf("%d\n", seg[3].sum);
		char opt = getchar();
		for (; opt != 'D' && opt != 'M'; opt = getchar());
		int x = read(), y = read();
		if (opt == 'D'){
			int ans = inf;
			if (seg[1].sum <= x) ans = min(ans, query(1, y, x));
			if (ans == inf) puts("-1"); else printf("%d\n", ans);
		} else update(1, y, x);
	}
	return 0;
}
```


---


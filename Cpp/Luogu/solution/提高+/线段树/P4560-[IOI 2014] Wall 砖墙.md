# [IOI 2014] Wall 砖墙

## 题目背景

原题为交互试题，但在此请提交**完整程序**。

## 题目描述

给定一个长度为 $n$且初始值全为 $0$的序列。你需要支持以下两种操作：

- Add $L, R, h$：将序列 $[L, R]$内所有值小于 $h$的元素都赋为 $h$，此时不改变高度大于 $h$的元素值
- Remove $L, R, h$：将序列 $[L, R]$内所有值大于 $h$的元素都赋为 $h$，此时不改变高度小于 $h$的元素值

你需要输出进行 $k$次上述操作之后的序列。

## 说明/提示

- 子任务#1（8分）：满足 $1 \leq n \leq 10 000, 1 \leq k \leq 5 000$；
- 子任务#2（24分）：满足 $1 \leq n \leq 100 000, 1 \leq k \leq 500 000$，全部增加操作均在全部移除操作之前；
- 子任务#3（29分）：满足 $1 \leq n \leq 100 000, 1 \leq k \leq 500 000$；
- 子任务#4（39分）：满足 $1 \leq n \leq 2 000 000, 1 \leq k \leq 500 000$。

所有操作的高度 $h$满足 $0 \leq h \leq 100 000$。

## 样例 #1

### 输入

```
10 3
1 3 4 91220
1 5 9 48623
2 3 5 39412
```

### 输出

```
0
0
0
39412
39412
39412
48623
48623
48623
48623
```

## 样例 #2

### 输入

```
10 6
1 1 8 4
2 4 9 1
2 3 6 5
1 0 5 3
1 2 2 5
2 6 7 0
```

### 输出

```
3
4
5
4
3
3
0
0
1
0
```

# 题解

## 作者：基地A_I (赞：23)

### 简化题意

-  ### 给出一个n长序列，m次修改，支持两种操作

> 1.**add** 将区间$[l ,r]$中的每一个数 对 $k$ 取 $max$

> 2.**remove** 将区间$[l ,r]$中的每一个数 对 $k$ 取 $min$

### 题目思路

两个懒标记（add，rem）意思同上，分情况讨论传递标记(乍看不可做，想一下怎么推重复标记就懂了qwq)

### 具体实现

（~~如果你想了很久后还是不知道如何下手，再看这部分~~）

（~~最好你能拿出笔来边画边理解~~）

- $Max[p]$，$Min[p]$ 分别是区间最大，区间最小。

我们以 **Max标记的下传**为例 (即 将区间$[l ,r]$中的每一个数 对 $k$ 取 $max$)

1. 如果 $Min[p]$ < k 那么 $Min[p]$ = k ((如果)区间最小比较小，我们要更新它)
1. 如果 $Max[p]$ < k 那么 $Max[p]$ = k;((如果)$Max$也比$k$小了，同样更新)
1. 注意下传标记时$k$不就是父亲的懒标记$Max$吗？ 所以$Max$ = 0；

~~Min的标记下传同理，举一反三就可以了~~

### Code

（~~码风不好，请勿喷~~）


```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<cmath>
#define N 2000007
using namespace std;
int n,m;
struct Segment_Tree	//线段树结构体 
{
    int Max[N<<2],Min[N<<2];	//懒标记 
    inline int ls(int p) {return p<<1;}	//左子树 
    inline int rs(int p) {return p<<1|1;}	//右子树 
    void fx(int p,int k)	//Max标记传递 ，p节点编号，k传递值 
	{
		if(Min[p]<k) Min[p] = k;	//Min比k小，更新Min 
		if(Max[p]<k) Max[p] = k;	//连Max都比k小，更新MMax 
    }
    void fi(int p,int k)	//Min标记传递，p节点编号，k传递值 
	{
		if(Max[p]>k) Max[p] = k;	//Max比k要大，缩小Max 
		if(Min[p]>k) Min[p] = k;	//Min都比k大，k更小，值取k 
    }
//    释放懒标记 
    void push_down(int p) {
//        更新Max 
		fx(ls(p),Max[p]);
        fx(rs(p),Max[p]);
//        更新Min 
		fi(ls(p),Min[p]);
        fi(rs(p),Min[p]);
//        Max 和 Min 回归初始状态 
		Max[p] = 0;
        Min[p] = 0x7fffffff;
    }
//    		修改区间[nl,nr]	当前节点p,代表区间[l,r] 修改数k	,tag判断是操作add还是操作rem 
	void update(int nl,int nr,int p,int l,int r,int k,bool tag)
    {
//    	在范围内 
        if(nl<=l && r<=nr)
        {
//        	tag==0 代表add操作，更新Max 
            if(tag==0) fx(p,k);
//            否则更新Min 
            else fi(p,k);
            return ;
        }
        int mid = (l+r)>>1;
//        释放懒标记 
        push_down(p);
        if(nl<=mid) update(nl,nr,ls(p),l,mid,k,tag);
        if(nr>mid) update(nl,nr,rs(p),mid+1,r,k,tag);
//        push_up(p);
    }
    void Query(int p,int l,int r)
    {
//    	依次输出 叶节点的Max和Min是一样的 
        if(l==r) {printf("%d\n",Max[p]); return;}
        int mid = (l+r)>>1;
//        记得先释放懒标记，更新值 
        push_down(p);
//        继续递归 
        Query(ls(p),l,mid);
        Query(rs(p),mid+1,r);
    }
}Tree;	//定义一棵线段树Tree 
int main()
{
    scanf("%d%d",&n,&m);
//    把Min数组全直无穷大 
    for(int i=1;i<=n<<2;++i)
    	Tree.Min[i] = 0x7fffffff;
    for(int i=1;i<=m;++i)
    {
        int L,R,h,t;	//修改区间[L,R],修改值h,和操作t 
        scanf("%d%d%d%d",&t,&L,&R,&h);
//        题目从0开始编号，我习惯从一开始，故+1 
        Tree.update(L+1,R+1,1,1,n,h,t-1);
    }
//    输出结果 
    Tree.Query(1,1,n); 
    return 0;
}
```


---

## 作者：King_of_gamers (赞：11)

乍一眼看此题,你会发现我们是要在线段树上维护一个区间标记来完成这件事.

所以我们考虑标记$ADD[i]$和$DEL[i]$,其中$ADD[i]$表示把线段树上i这个区间里比$ADD[i]$小的数赋值成$ADD[i]$,$DEL[i]$表示把线段树上i这个区间里比$DEL[i]$大的数赋值成$DEL[i]$,这两个都是线段树上的~~常规~~懒标记.

然后考虑懒标记如何修改,我们可以设$ADD[i]=x$,$DEL[i]=y$,那么当前线段树上i这个区间的值就只有$x-y$.

## 添加一个$ADD$标记$z$.

### 如果$z<=x$,

因为当前没有小于$z$的数,所以不管.

### 如果$x<z<y$,

那就新建一个懒标记,$ADD[i]=z$.

### 如果$z>y$,

因为当前所有数都小于z,所以新建懒标记,$ADD[i]=z,DEL[i]=z$.

### 用代码表示也就是
```
if (ADD[k]<z) ADD[k]=z;
if (DEL[k]<z) DEL[k]=z;
```

## 添加一个DEL标记z.

### 如果$z<=x$,

因为当前所有数都大于z,所以新建懒标记,$ADD[i]=z,DEL[i]=z$.

### 如果$x<z<y$,

那就新建一个懒标记$DEL[i]=z$.

### 如果$z>y$,

因为当前没有大于z的数,所以不管.

### 用代码表示也就是
```
if (ADD[k]>z) ADD[k]=z;
if (DEL[k]>z) DEL[k]=z;
```
当然在线段树上修改懒标记当然必须掌握pushdown这种东西.

### 在这题中pushdown也就和加标记一样

用代码表示就是
```
void pushdown(int k)
{
	if (ADD[k]!=0)
	{
		int son=k+k,x=ADD[k];
		if (ADD[son]<x) ADD[son]=x;
		if (DEL[son]<x) DEL[son]=x;
		son++;
		if (ADD[son]<x) ADD[son]=x;
		if (DEL[son]<x) DEL[son]=x;
		ADD[k]=0;
	}
	if (DEL[k]!=inf)
	{
		int son=k+k,x=DEL[k];
		if (ADD[son]>x) ADD[son]=x;
		if (DEL[son]>x) DEL[son]=x;
		son++;
		if (ADD[son]>x) ADD[son]=x;
		if (DEL[son]>x) DEL[son]=x;
		DEL[k]=inf;
	}
}
```
最后只需要一个遍历就可以得到答案了.
附上完整代码

```
#include<bits/stdc++.h> 
using namespace std;
int n,k,opt,l,r,x,inf;
int ADD[8050000],DEL[8050000];
void pushdown(int k)
{
	if (ADD[k]!=0)
	{
		int son=k+k,x=ADD[k];
		if (ADD[son]<x) ADD[son]=x;
		if (DEL[son]<x) DEL[son]=x;
		son++;
		if (ADD[son]<x) ADD[son]=x;
		if (DEL[son]<x) DEL[son]=x;
		ADD[k]=0;
	}
	if (DEL[k]!=inf)
	{
		int son=k+k,x=DEL[k];
		if (ADD[son]>x) ADD[son]=x;
		if (DEL[son]>x) DEL[son]=x;
		son++;
		if (ADD[son]>x) ADD[son]=x;
		if (DEL[son]>x) DEL[son]=x;
		DEL[k]=inf;
	}
}
void add(int x,int y,int z,int l,int r,int k)
{
	if ((l==x)&&(r==y))
	{
		if (ADD[k]<z) ADD[k]=z;
		if (DEL[k]<z) DEL[k]=z;
		return;
	}
	pushdown(k);
	int mid=(l+r)>>1;
	if (y<=mid) add(x,y,z,l,mid,k+k);
	else if (x>mid) add(x,y,z,mid+1,r,k+k+1);
	else add(x,mid,z,l,mid,k+k),add(mid+1,y,z,mid+1,r,k+k+1);
}
void del(int x,int y,int z,int l,int r,int k)
{
	if ((l==x)&&(r==y))
	{
		if (ADD[k]>z) ADD[k]=z;
		if (DEL[k]>z) DEL[k]=z;
		return;
	}
	pushdown(k);
	int mid=(l+r)>>1;
	if (y<=mid) del(x,y,z,l,mid,k+k);
	else if (x>mid) del(x,y,z,mid+1,r,k+k+1);
	else del(x,mid,z,l,mid,k+k),del(mid+1,y,z,mid+1,r,k+k+1);
}
void getans(int l,int r,int k)
{
	if (l==r) 
	{
		printf("%d\n",ADD[k]);
		return;
	}
	pushdown(k);
	int mid=(l+r)>>1;
	getans(l,mid,k+k);
	getans(mid+1,r,k+k+1);
}
int main()
{
	inf=100005;
	scanf("%d%d",&n,&k);
	for (int i=1;i<=n<<2;i++)
	DEL[i]=inf;
	for (int i=1;i<=k;i++)
	{
		scanf("%d%d%d%d",&opt,&l,&r,&x);
		l++;
		r++;
		if (opt==1) add(l,r,x,1,n,1);
		if (opt==2) del(l,r,x,1,n,1);
	}
	getans(1,n,1);
}

```


---

## 作者：EternalAlexander (赞：9)

By EternalAlexander

~~我才不会说我splay信仰然后不停的用小号交TLE了一个晚上才改线段树~~

线段树。

考虑推标记。

up[i],down[i]分别是add,remove的标记。考虑如何处理两个标记之间的覆盖。
首先，如果一个结点即将被打上一个down标记，值为x，并且同时它的up标记为y，那么分情况讨论。

1.如果x<y: 直接打上，无影响，因为这个区间内的值都将被修改成x~y这个范围内的值。

2.如果x>y: 此时不难看出，有了之前的up标记，这个区间内的值应该全部都大于等于y。此时再进行一个down操作，则会把这个区间内的值全部改为x。因此把up标记改为x然后打上down标记。

打up标记也是同理，不再赘述。

最后遍历一次输出就行了。

下面是pushdown函数的代码。完整代码写的太丑就不放了。

```cpp
inline void pushdown(int root) {
    if (root==0) return;
    if (left[root]==right[root]) {
        if (down[root]!=-1) val[root]=std::min(down[root], val[root]);
        if (up[root]!=-1) val[root]=std::max(up[root], val[root]);
        return;
    }if (root[up]!=-1) {
        up[root<<1]=std::max(up[root<<1], up[root]);
        if (down[root<<1]!=-1) {
            if (down[root<<1]<up[root]) down[root<<1]=up[root];
        }up[root<<1|1]=std::max(up[root<<1|1], up[root]);
        if (down[root<<1|1]!=-1) {
            if (down[root<<1|1]<up[root]) down[root<<1|1]=up[root];
        }up[root]=-1;
    }if (root[down]!=-1) {
        
        if (down[root<<1]!=-1) down[root<<1]=std::min(down[root<<1], down[root]);
        else down[root<<1]=down[root];
        if (up[root<<1]!=-1) {
            if (up[root<<1]>down[root]) up[root<<1]=down[root];
        }if (down[root<<1|1]!=-1) down[root<<1|1]=std::min(down[root<<1|1], down[root]);
        else down[root<<1|1]=down[root];
        if (up[root<<1|1]!=-1) {
            if (up[root<<1|1]>down[root]) up[root<<1|1]=down[root];
        }down[root]=-1;
    }
}
```

---

## 作者：_121017_ (赞：7)

# 题目简介：
~~水水的一道线段树。~~ 一道利用线段断树中的 $lazy\_tag$ 简便求节点经过 $max$ 和 $min$ 操作后的值的水题。

# 思路：
和普通的线段树模板题一样，真搞不懂为什么是紫题。甚至因为这道不要求求区间和，所以我们只需要我们的 $max$ 懒标记和 $min$ 懒标记就可以切掉这一题啦~。好消息：这道题不用写 $push\_up$ 哟~ ~~（这不是废话吗）~~。
## code：
```cpp
#include<bits/stdc++.h>
#define lc p*2
#define rc p*2+1
#define mid (tree[p].l+tree[p].r)/2
//懒人砖用表示法
using namespace std;
int n,m;
struct node{
	int l;//区间左端点
	int r;//区间右端点
	int min_n;//区间最小值
	int max_n;//区间最大值
}tree[10000001*4];//4倍空间
void push_down(int p){
	tree[lc].max_n=max(tree[lc].max_n,tree[p].max_n);
	tree[lc].max_n=min(tree[lc].max_n,tree[p].min_n);
    //更新左儿子最大值
	tree[lc].min_n=min(tree[lc].min_n,tree[p].min_n);
	tree[lc].min_n=max(tree[lc].min_n,tree[p].max_n);
    //更新右儿子最小值
	tree[rc].max_n=max(tree[rc].max_n,tree[p].max_n);
	tree[rc].max_n=min(tree[rc].max_n,tree[p].min_n);
    //更新左儿子最大值
	tree[rc].min_n=min(tree[rc].min_n,tree[p].min_n);
	tree[rc].min_n=max(tree[rc].min_n,tree[p].max_n);
    //更新左儿子最小值
	tree[p].max_n=0,tree[p].min_n=10000000;//清空懒标记
}
void build(int p,int l,int r){
	tree[p].l=l;
	tree[p].r=r;
	tree[p].max_n=0;
	tree[p].min_n=100000000;//最小值赋值为无穷大
	if(l>=r){
		return;
	}
	build(lc,l,mid);//递归构造左子树
	build(rc,mid+1,r);//递归构造右子树
//	push_up(p);
}
void change_1(int p,int l,int r,int x){//区间max修改
	if(tree[p].l>=l&&tree[p].r<=r){
		tree[p].max_n=max(tree[p].max_n,x);//更新最大值
		tree[p].min_n=max(tree[p].min_n,x);//更新最小值
        //注意！！！如线段树模板2，两个标记都要修改。
		return;
	}
	push_down(p);//先下传懒标记
	if(mid>=l) change_1(lc,l,r,x);//修改左区间
	if(mid<r) change_1(rc,l,r,x);//修改右区间
//	push_up(p);
} 
void change_2(int p,int l,int r,int x){//区间min修改
	if(tree[p].l>=l&&tree[p].r<=r){
		tree[p].max_n=min(tree[p].max_n,x);//更新最大值
		tree[p].min_n=min(tree[p].min_n,x);//更新最小值
		return;
	}
	push_down(p);
	if(mid>=l) change_2(lc,l,r,x);//修改左区间
	if(mid<r) change_2(rc,l,r,x);//修改右区间
//	push_up(p);
}
void ask(int p){
	if(tree[p].l==tree[p].r){//如果当前是叶子节点
		if(tree[p].l<=n){//且编号小于等于n
			cout<<tree[p].max_n<<endl;//输出当前节点的值
		}
		return;
	}
	push_down(p);//清除积压的工作
	ask(lc),ask(rc);
}
int main(){
	cin>>n>>m;
	build(1,1,n);
	for(int i=1;i<=m;i++){
		int mode,l,r,h;
		cin>>mode>>l>>r>>h;
		++l,++r;//个人习惯1开始
		if(mode==1){
			change_1(1,l,r,h);
		}else{
			change_2(1,l,r,h);
		}
	}
	ask(1);
	return 0;
}//完美结束
```
蒟蒻最近的学习方向：[P3834	【模板】可持久化线段树2（主席树）](https://www.luogu.com.cn/problem/P3834)，[P6242	【模板】线段树 3](https://www.luogu.com.cn/problem/P6242)。有兴趣的可以去看我写的题解。

---

## 作者：Sweetlemon (赞：5)

### [IOI2014] Wall 砖墙

#### 题意

这是一道 IOI 原题。

给定一个初始全 $0$ 序列，有两种操作：

1. 对某区间内的所有数 $x$，令 $x=\max(t,x)$（$t$ 是操作参数）
2. 对某区间内的所有数 $x$，令 $x=\min(t,x)$

求最后的序列。

#### 思路

这道题与“[[SCOI 2016] 萌萌哒](https://www.luogu.org/problem/P3295)”类似，如果每次区间操作都暴力地对区间内每一个数都进行调整，那么复杂度将无法承受。我们需要选择一种数据结构，直接对“区间”进行操作。

“萌萌哒”这道题中，操作之间互不影响，而且操作区间可以重叠，因此可以直接使用 st 表（若操作区间不可重叠，同样可使用 st 表，但操作区间要被二进制拆分成为 $O(\log l)$ 个）。但是在这道题中，不同的操作前后会有影响，因此我们可以使用线段树。

线段树的每一个点维护“已经对这个区间进行、但还没有对这个区间的孩子应用 (apply) 的限制”。如果我们把我们的数想象成一排金属球，那么 1 操作可以想象成用一块钢板从下往上推区间内的球，一直推到高度 $t$，使之不低于 $t$；2 操作可以想象成用一块钢板从上往下压，一直压到高度 $t$。于是“每个区间的限制”有两种，一种是向下压的板到达的最小高度，一种是向上推的板到达的最大高度。初始时长度大于 $1$ 的区间都没有限制——向下压的板的最小高度（记为 $n$）为 $\infty$，向上推的板的最大高度（记为 $m$）为 $0$；可以认为初始时长度为 $1$ 的区间的 $n$ 和 $m$ 都是 $0$。

现在考虑对一个区间进行 1 操作。用一块自下而上的上推钢板推这个区间，会有什么变化呢？如果原来的下界钢板低于 $t$，当然会被推到 $t$ 位置，否则不变；上界同理。因此，这个操作对这个区间的变化是 $m=\max(m,t),n=\max(n,t)$。

再考虑 2 操作，类似地，$m=\min(m,t),n=\min(n,t)$。

由于有些操作之间会相互影响，因此如果有一个要应用到孩子、但不应用到父亲区间的操作，就必须先把标记下传。标记下传也就是把之前 lazy tag 延迟应用的操作应用到孩子上，也就是对孩子进行 $1\ m,\ 2\ n$ 这两个操作——这两个操作的顺序无关紧要，因为在维护父节点的两个标记的时候，已经保证了这两块钢板 $m\le n$，因此这两个操作之间不会相互影响。

输出的时候直接输出叶子节点的 $m$ 或 $n$ 即可。由于上述过程中，叶子节点的 $m,n$ 始终相同——夹着单个球的板总是紧密合在一起的，因此输出哪一个都可以。

下面用一个小例子演示一下更新和标记下传的过程。

```text
5 2
1 1 3 2
2 3 4 1
```

为方便阅读，上面这个例子的下标**已调整为从 1 开始**。

初始时是这样。

![初始状态](https://cdn.luogu.com.cn/upload/image_hosting/c36laq34.png)

进行第一个操作后变成了这样。

![状态1](https://cdn.luogu.com.cn/upload/image_hosting/qiji4qlv.png)

虚线表示父节点的限制还没有应用到子节点上，因此实际上 $1\sim 3$ 这三个球已经被推到了 $2$ 的位置。

要进行第二个操作，线段树节点 $[1,3]$ 要进行标记下传，下传的结果是这样。

![状态1.5](https://cdn.luogu.com.cn/upload/image_hosting/ifvkbnft.png)

第二个操作的最终结果是这样。

![状态2](https://cdn.luogu.com.cn/upload/image_hosting/idc268a0.png)

可以用更复杂的例子来模拟，更好地弄懂这个设计。

#### 代码

```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>
#define MAXIOLG 25
#define MAXN 2000005
#define MAX4N 8000005
#define INF 19260817
using namespace std;

typedef int io_t;

//快读快写
io_t shin[MAXIOLG];
io_t seto(void);
void ayano(io_t x,char spliter='\n');

//线段树节点
struct Ene{
    int l,r,mxm,mnm;
    //以下依次为节点区间左端点、右端点、m 值、n 值、左右儿子序号
    #define L(x) ((stree[(x)]).l)
    #define R(x) ((stree[(x)]).r)
    #define MX(x) ((stree[(x)]).mxm)
    #define MN(x) ((stree[(x)]).mnm)
    #define LC(x) (((x)<<1))
    #define RC(x) (((x)<<1)^1)
};

int n;
Ene stree[MAX4N]; //线段树

void build_tree(int root,int l,int r); //建树
void cmx(int root,int l,int r,int x); //1 操作
void cmn(int root,int l,int r,int x); //2 操作
void pushdown(int root); //标记下传,把父节点的操作应用到子节点
void output(int root); //输出答案

int main(void){
    int q;
    n=seto(),q=seto();
    const int troot=1; //线段树根节点
    build_tree(troot,1,n);
    while (q--){
        int op,l,r,x;
        op=seto(),l=seto()+1,r=seto()+1,x=seto();
        if (op==1)
            cmx(troot,l,r,x);
        else
            cmn(troot,l,r,x);
    }
    output(troot);
    return 0;
}

void build_tree(int root,int l,int r){
    //建树
    //初始时非叶节点没有限制
    L(root)=l,R(root)=r,MX(root)=0,MN(root)=INF;
    if (l==r)
        //叶节点有限制, m=n=0
        return MX(root)=MN(root)=0,void();
    int mid=(l+r)>>1;
    build_tree(LC(root),l,mid);
    build_tree(RC(root),mid+1,r);
}

void cmx(int root,int l,int r,int x){
    if (l<=L(root) && r>=R(root)){
        //把限制标记在这个区间
        //m,n 都取 max
        MX(root)=max(MX(root),x);
        MN(root)=max(MN(root),x);
        return;
    }
    int mid=(L(root)+R(root))>>1;
    pushdown(root);

    (l<=mid)?(cmx(LC(root),l,r,x)):(void());
    (r>mid)?(cmx(RC(root),l,r,x)):(void());
}

void cmn(int root,int l,int r,int x){
    if (l<=L(root) && r>=R(root)){
        //m,n 都取 min
        MX(root)=min(MX(root),x),
        MN(root)=min(MN(root),x);
        return;
    }
    int mid=(L(root)+R(root))>>1;
    pushdown(root);
    (l<=mid)?(cmn(LC(root),l,r,x)):(void());
    (r>mid)?(cmn(RC(root),l,r,x)):(void());
}
void pushdown(int root){
    //标记下传
    if (L(root)==R(root))
        return;
    //对左右儿子的 m,n 值都应用等效 2 操作
    MX(LC(root))=min(MX(LC(root)),MN(root));
    MX(RC(root))=min(MX(RC(root)),MN(root));
    MN(LC(root))=min(MN(LC(root)),MN(root));
    MN(RC(root))=min(MN(RC(root)),MN(root));
    //对左右儿子的 m,n 值都应用等效 1 操作
    MX(LC(root))=max(MX(LC(root)),MX(root));
    MX(RC(root))=max(MX(RC(root)),MX(root));
    MN(LC(root))=max(MN(LC(root)),MX(root));
    MN(RC(root))=max(MN(RC(root)),MX(root));
    //父节点的限制应用完毕，取消限制
    MX(root)=0,MN(root)=INF;
}
void output(int root){
    if (L(root)==R(root)){
        ayano(MX(root));
        return;
    }
    pushdown(root);
    output(LC(root)),output(RC(root));
}

//以下两个函数为读入输出优化

io_t seto(void){
    io_t x=0;
    int symbol=0;
    char ch=getchar();
    while (!isdigit(ch))
        (ch=='-')?(symbol=1):(0),
        ch=getchar();
    while (isdigit(ch))
        x=(x*10)+(ch-'0'),
        ch=getchar();
    return (symbol)?(-x):(x);
}

void ayano(io_t x,char spliter){
    if (!x){
        putchar('0'),putchar(spliter);
        return;
    }
    if (x<0)
        putchar('-'),x=-x;
    int len=0;
    while (x){
        io_t d=x/10;
        shin[len++]=x-(d*10);
        x=d;
    }
    while (len--)
        putchar(shin[len]+'0');
    putchar(spliter);
}
```

---

## 作者：attack (赞：5)

感觉题解里面的下传标记都写麻烦了，因为这题只需要输出最后的操作序列，那么我们只维护最大最小值的覆盖标记即可。也就是对于每一个节点，把本层的最大最小值下传之后清除即可。

```cpp
#include<bits/stdc++.h> 
#define LL long long 
using namespace std;
const int MAXN = 8e6 + 10, INF = 1e9 + 10;
template <typename A, typename B> inline bool chmin(A &a, B b){if(a > b) {a = b; return 1;} return 0;}
template <typename A, typename B> inline bool chmax(A &a, B b){if(a < b) {a = b; return 1;} return 0;}
inline int read() {
    char c = getchar(); int x = 0, f = 1;
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}
int N, K, opt[MAXN], L[MAXN], R[MAXN], H[MAXN];
#define ls k << 1
#define rs k << 1 | 1 
struct Node {
	int l, r, mx, mn;
}T[MAXN];
void psmin(int k, int v) {
	chmin(T[k].mx, v); chmin(T[k].mn, v);
}
void psmax(int k, int v) {
	chmax(T[k].mx, v); chmax(T[k].mn, v);
}
void pushdown(int k) {
	if(T[k].mn != INF)  psmin(ls, T[k].mn), psmin(rs, T[k].mn), T[k].mn = INF;
	if(T[k].mx != -INF) psmax(ls, T[k].mx), psmax(rs, T[k].mx), T[k].mx = -INF;
}
void Build(int k, int ll, int rr) {
	T[k].l = ll; T[k].r = rr; T[k].mn = INF; T[k].mx = -INF; 
	if(ll == rr) return ;
	int mid = ll + rr >> 1;
	Build(ls, ll, mid); 
	Build(rs, mid + 1, rr);
}
void Int(int k, int ll, int rr, int v, int opt) {
	if(ll <= T[k].l && T[k].r <= rr) {
		opt == 2 ? psmin(k, v) : psmax(k, v);
		return ;
	}
	pushdown(k);
	int mid = T[k].l + T[k].r >> 1;
	if(ll <= mid) Int(ls, ll, rr, v, opt);
	if(rr  > mid) Int(rs, ll, rr, v, opt);
}
void dfs(int k) {
	if(T[k].l == T[k].r) {printf("%d\n", max(0, min(T[k].mn, T[k].mx)));return ;}
	pushdown(k);
	dfs(ls); dfs(rs);
}
signed main() {
	N = read(); K = read();
	Build(1, 1, N);
    for(int i = 1; i <= K; i++) {
    	int opt = read(), L = read() + 1, R = read() + 1, H = read();
    	if(opt == 1) Int(1, L, R, H, 1);
		else Int(1, L, R, H, 2);//区间取min 
	}
	dfs(1);
	return 0;
}
```

---

## 作者：Utilokasteinn (赞：2)

## [Link](https://www.luogu.com.cn/problem/P4560)

题目大意：有 $n$ 个数，进行 $m$ 次操作。每次操作可以将区间大于 $x$ 或小于 $x$ 的数变为 $x$。问操作完之后的序列是多少。

因为是区间操作，容易想到分块或线段树。但由于 $n$ 高达两百万，分块显然不行。故选择用线段树维护。

该线段树维护两个 $tag$。

**$s[p].maxn$ 表示当前区间小于 $x$ 的数都要变为 $x$，$s[p].maxn$ 表示当前区间大于 $x$ 的数都要变为 $x$。**

对于初始值，因为 $1\le h\le 10^5$，所以让 $maxn$ 都为 $0$，$minn$ 为 $10^9$。

线段树的难点都在下传懒标记。举个例子，假设要更新 $s[p\times 2].maxn$。

- 若 $s[p].maxn>s[p\times 2].maxn$，即说明会直接把它覆盖掉，所以之间让 $s[p\times 2].maxn=s[p].maxn$。否则新的这个操作并不能使该区间有任何改变。

- 若 $s[p].minn<s[p\times 2].maxn$，即说明若将 $p\times 2$ 表示的区间小于 $s[p\times 2].maxn$ 的数会变为 $s[p\times 2].maxn$，接着这些数都会因为 $s[p].minn<s[p\times 2].maxn$ 而全部变为 $s[p].minn$。所以直接让 $s[p\times 2].maxn=s[p].minn$ 即可。否则没有作用。

其他的懒标记下传类似，详见代码。

时间复杂度 $O(n\log n)$，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int s=0;char c=getchar();
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())
		s=s*10+c-'0';
	return s;
}
int n,m,op,l,r,x,pos;
struct tree{
	int l,r,maxn,minn;
}s[8000005];
void build(int l,int r,int p)
{
	s[p].l=l,s[p].r=r,s[p].maxn=0,s[p].minn=1e9;
	if(l==r)return;
	int mid=(l+r)/2;
	build(l,mid,p*2);
	build(mid+1,r,p*2+1);
}
inline void push_down(int p)
{
	if(s[p].maxn)
	{
		s[p*2].maxn=max(s[p*2].maxn,s[p].maxn);
		s[p*2].minn=max(s[p*2].minn,s[p].maxn);
		s[p*2+1].maxn=max(s[p*2+1].maxn,s[p].maxn);
		s[p*2+1].minn=max(s[p*2+1].minn,s[p].maxn);
		s[p].maxn=0;
	}
	if(s[p].minn!=1e9)
	{
		s[p*2].maxn=min(s[p*2].maxn,s[p].minn);
		s[p*2].minn=min(s[p*2].minn,s[p].minn);
		s[p*2+1].maxn=min(s[p*2+1].maxn,s[p].minn);
		s[p*2+1].minn=min(s[p*2+1].minn,s[p].minn);
		s[p].minn=1e9;
	}
}
void update1(int p)
{
	if(l>s[p].r||r<s[p].l)return;
	if(l<=s[p].l&&s[p].r<=r)
	{
		s[p].maxn=max(s[p].maxn,x);
		s[p].minn=max(s[p].minn,x);
		return;
	}
	push_down(p);
	update1(p*2),update1(p*2+1);
}
void update2(int p)
{
	if(l>s[p].r||r<s[p].l)return;
	if(l<=s[p].l&&s[p].r<=r)
	{
		s[p].maxn=min(s[p].maxn,x);
		s[p].minn=min(s[p].minn,x);
		return;
	}
	push_down(p);
	update2(p*2),update2(p*2+1);
}
int query(int p)
{
	if(s[p].l==s[p].r)return s[p].maxn;
	push_down(p);
	if(pos<=s[p*2].r)return query(p*2);
	return query(p*2+1);
}
int main()
{
	n=read(),m=read();
	build(1,n,1);
	while(m--)
	{
		op=read(),l=read()+1,r=read()+1,x=read();
		if(op==1)update1(1);
		else update2(1);
	}
	for(pos=1;pos<=n;pos++)
		printf("%d\n",query(1));
	return 0;
}
```
谢谢阅读。

---

## 作者：_Anchor (赞：2)

# 题意

[传送门](https://www.luogu.com.cn/problem/P4560)

![](https://img2020.cnblogs.com/blog/2013965/202012/2013965-20201212210851559-610173771.png)

简化题意：

给定长度为$n$的初始值都为$0$的序列，有$m$次操作，求$m$次操作过后的整个序列

每次操作如下：

$1.$对区间$[l,r]$中的所有元素与$h$取$max$

$2.$对区间$[l,r]$中的所有元素与$h$取$min$

# 分析

线段树好题

一道 区修 单查 可离线 的题目

首先我们要明确这道题$2e6$的数据大概率就是要用线段树在$O(nlogn)$时间范围内解决

然后我们现在的问题就在于要维护哪些标记

首先，我们最后要询问的值是$val$，还是单点，所以我们可以知道这个维护的东西是什么都无所谓，只要能确定某个单点的值就行了

然后看到题目这个肯定跟区间的最大值和最小值有关，那么我们干脆就维护$Max$和$Min$标记吧~

$Max$和$Min$分别代表区间最大值和区间最小值

那么我们考虑标记如何下传，就是$pushdown$函数的写法

我们可以发现这样的一个事情（关于下传标记时的标记覆盖问题）

就是如果我们当前这个点的两个标记为$Max1$和$Min1$，那么假设我们现在要从这个点的父亲结点下传一个$Min2$标记：

$$
Max1=min{(Max1,Min2)}\\

Min1=min{(Min1,Min2)}
$$

然后$Max2$标记也同理：

$$
Max1=max{(Max1,Max2)}\\

Min1=max{(Min1,Max2)}
$$

这样我们就解决了$pushdown$函数的问题啦~

那么代码也不难得出，其他具体的细节也在代码里看吧

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
template <typename T>
inline void read(T &x){
	x=0;char ch=getchar();bool f=false;
	while(!isdigit(ch)){if(ch=='-'){f=true;}ch=getchar();}
	while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	x=f?-x:x;
	return ;
}
template <typename T>
inline void write(T x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10^48);
	return ;
}
const int N=2e6+5;
int n,m,op;
int maxn[N<<2],minn[N<<2];
void pushdown(int x){
	maxn[x<<1]=max(maxn[x<<1],maxn[x]);
	minn[x<<1]=max(minn[x<<1],maxn[x]);
	maxn[x<<1|1]=max(maxn[x<<1|1],maxn[x]);
	minn[x<<1|1]=max(minn[x<<1|1],maxn[x]);
	maxn[x<<1]=min(maxn[x<<1],minn[x]);
	minn[x<<1]=min(minn[x<<1],minn[x]);
	maxn[x<<1|1]=min(maxn[x<<1|1],minn[x]);
	minn[x<<1|1]=min(minn[x<<1|1],minn[x]);
	maxn[x]=0,minn[x]=0x3f3f3f3f;
	return ;
}
void modify1(int x,int l,int r,int ql,int qr,int val){
	if(ql<=l&&qr>=r){
		maxn[x]=max(maxn[x],val);
		minn[x]=max(minn[x],val);
		return ;
	}
	pushdown(x);
	int mid=(l+r)>>1;
	if(ql<=mid) modify1(x<<1,l,mid,ql,qr,val);
	if(qr>mid) modify1(x<<1|1,mid+1,r,ql,qr,val);
	return ;
}
void modify2(int x,int l,int r,int ql,int qr,int val){
	if(ql<=l&&qr>=r){
		maxn[x]=min(maxn[x],val);
		minn[x]=min(minn[x],val);
		return ;
	}
	pushdown(x);
	int mid=(l+r)>>1;
	if(ql<=mid) modify2(x<<1,l,mid,ql,qr,val);
	if(qr>mid) modify2(x<<1|1,mid+1,r,ql,qr,val);
	return ;
}
int query(int x,int l,int r,int ql,int qr){
	if(l==r) return maxn[x];
	pushdown(x);
	int mid=(l+r)>>1;
	if(ql<=mid) return query(x<<1,l,mid,ql,qr);
	else if(qr>mid) return query(x<<1|1,mid+1,r,ql,qr);
	return 0;
}
int main(){
	read(n),read(m);
	for(int i=1;i<=(n<<2);i++) maxn[i]=0,minn[i]=0x3f3f3f3f;
	while(m--){
		read(op);
		int l,r,h;
		read(l),read(r),read(h);
		l++,r++;
		if(op==1) modify1(1,1,n,l,r,h);
		else modify2(1,1,n,l,r,h);
	}
	for(int i=1;i<=n;i++) write(query(1,1,n,i,i)),putchar('\n');
	return 0;
}

```

---

## 作者：Sangber (赞：2)

### 题目描述
给定一个初始元素为 $0$ 的数列，以及 $K$ 次操作：  
+ 将区间 $[L, R]$ 中的元素对 $h$ 取 $max$
+ 将区间 $[L, R]$ 中的元素对 $h$ 取 $min$

----
### 解题思路
首先要能看出来这是一道线段树的题。  
那么我们要如何建立一个节点呢？  
首先，对于每一个线段树上的节点，我们记两个标记 $Min$ 和 $Max$ 。  
因为题目涉及到 $min$ 和 $max$ 操作，所以应该不难想到设两个这样的标记。  
这两个标记的意义：  
+ $Min[rt]$ 表示编号为 $rt$ 的节点包含的区间的 $min$ 值标记
+ $Max[rt]$ 表示编号为 $rt$ 的节点包含的区间的 $max$ 值标记

~~怎么好像和没讲一样~~   
因为题目最后只询问每一个叶子节点的信息，所以我们并不在乎节点中有些什么值。  
我们只需要对与每一个节点及两个标记： $Min$ 和 $Max$ ，因为我们需要这两个来更新叶子）。  
而这两个标记是可以通过区间更新来维护的。  
#### 如何处理标记
处理标记有三个操作：初始化、打标记和下传标记。  
简单分析一下初始化：  
由于我们的标记是用来更新子节点的（即儿子的标记对父亲的 $Max$ 取 $max$，对父亲的 $Min$ 取 $min$）  
所以我们就把 $Max$ 赋值为极小值，$Min$ 赋值为极大值：
```cpp
Max[rt] = 0, Min[rt] = 0x3f3f3f3f;
```

**然后再来看打标记：**
```cpp
inline void fMax(int rt, int h) { Min[rt] = max(Min[rt], h), Max[rt] = max(Max[rt], h); }

inline void fMin(int rt, int h) { Min[rt] = min(Min[rt], h), Max[rt] = min(Max[rt], h); }
```
~~其实这两个函数本质是是一样的~~  
我们来分析一下：  
如果我们把一段区间对 $h$ 取 $max$，那么这段区间的 $Min$ 标记和 $Max$ 标记都应该对 $h$ 取 $max$。  
这个我不作具体分析：你们可以自己想一想为什么~~也可以感性理解一下~~  
所以打标记就讲完了 $QwQ$  

**最后再来看下传标记 $pushdown$**
```cpp
inline void pushdown(int rt) {
	fMin(lc(rt), Min[rt]), fMin(rc(rt), Min[rt]);
	
	fMax(lc(rt), Max[rt]), fMax(rc(rt), Max[rt]);
	
	Max[rt] = 0, Min[rt] = 0x3f3f3f3f;	
}
```
其实这个和打标记差不多，就是用父亲的信息更新儿子。

#### 如何输出答案
这个其实只要遍历一遍线段树，把叶子节点的 $Max$ 或 $Min$ 输出即可。

----
### 细节注意事项
+ 线段树空间开 $4$ 倍
+ 记得 $pushdown$ 后也要初始化

----
### 参考代码
```cpp
/*--------------------------------
  Author: The Ace Bee
  Blog: www.cnblogs.com/zsbzsb
  This code is made by The Ace Bee
--------------------------------*/
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <cctype>
#include <cmath>
#include <ctime>

#define rg register

using namespace std;

template < typename T > inline void read(T& s) {
	s = 0; int f = 0; char c = getchar();
	while (!isdigit(c)) f |= (c == '-'), c = getchar();
	while (isdigit(c)) s = s * 10 + (c ^ 48), c = getchar();
	s = f ? -s : s;
}

const int _ = 2000010;

int n, k, Min[_ << 2], Max[_ << 2];

inline int lc(int rt) { return rt << 1; }

inline int rc(int rt) { return rt << 1 | 1; }

inline void fMax(int rt, int h) { Min[rt] = max(Min[rt], h), Max[rt] = max(Max[rt], h); }

inline void fMin(int rt, int h) { Min[rt] = min(Min[rt], h), Max[rt] = min(Max[rt], h); }

inline void pushdown(int rt) {
	fMin(lc(rt), Min[rt]), fMin(rc(rt), Min[rt]);
	
	fMax(lc(rt), Max[rt]), fMax(rc(rt), Max[rt]);
	
	Max[rt] = 0, Min[rt] = 0x3f3f3f3f;
}

inline void update(int rt, int l, int r, int x, int y, int h, int t) {
	if (x <= l && r <= y) {
		if (t == 1)
			return fMax(rt, h);
		else
			return fMin(rt, h);
	}
	
	int mid = (l + r) >> 1;

	pushdown(rt);
 	
	if (x <= mid) update(lc(rt), l, mid, x, y, h, t);
	
	if (y > mid) update(rc(rt), mid + 1, r, x, y, h, t);
}

inline void query(int rt, int l, int r) {
	if (l == r) { printf("%d\n", Max[rt]); return ; }
	
	int mid = (l + r) >> 1;
	
	pushdown(rt);
	
	query(lc(rt), l, mid);

	query(rc(rt), mid + 1, r);
}

int main() {
#ifndef ONLINE_JUDGE
	freopen("in.in", "r", stdin);
#endif
	read(n), read(k);

	for (rg int i = 1; i <= n << 2; ++i)
		Max[i] = 0, Min[i] = 0x3f3f3f3f;

	for (rg int t, l, r, h, i = 1; i <= k; ++i)
		read(t), read(l), read(r), read(h), update(1, 1, n, l + 1, r + 1, h, t);

	query(1, 1, n);
	
	return 0;
}

```
**完结撒花 $qwq$**

---

## 作者：Adove (赞：2)

我来发个好看些的代码

具体的标记维护方式楼下讲得比较清楚了

我们可以设极大极小值来简化pushdown，让代码更简洁一些

极大值找个方便memset的INF，极小值设为0即可

$tag[1]$为下界，$tag[0]$为上界。

pushdown的代码自己画一下区间位置的几种情况就明白了

（为保证程序简洁，本代码没有过多的常数优化

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MAXN=1<<21;
const int INF=2139062143;

int n,m;
int tag[2][MAXN<<1];

inline int read()
{
	int x=0;char ch=getchar();
	while(ch<'0'||'9'<ch) ch=getchar();
	while('0'<=ch&&ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x;
}

void pd(int k,int i)
{
	if(tag[1][i]>=tag[0][k]) tag[1][i]=tag[0][i]=tag[0][k];
	else if(tag[1][k]>tag[1][i]) tag[1][i]=tag[1][k];
	if(tag[1][k]>=tag[0][i]) tag[1][i]=tag[0][i]=tag[1][k];
	else if(tag[0][k]<tag[0][i]) tag[0][i]=tag[0][k];
	return;
}

void pushdown(int k,int l,int r)
{
	if(l==r||(tag[0][k]==INF&&!tag[1][k])) return;
	int mid=l+r>>1,i=k<<1;
	pd(k,i);pd(k,i|1);
	tag[0][k]=INF,tag[1][k]=0;
	return;
}

void ctag(int k,int l,int r,int le,int ri,int val,int kd)
{
	pushdown(k,l,r);
	if(le<=l&&r<=ri){
		if(kd==1) tag[kd][k]=max(tag[kd][k],val);
		else tag[kd][k]=min(tag[kd][k],val);
		if(tag[1][k]>tag[0][k]) tag[1][k]=tag[0][k]=val;
		return;
	}int mid=l+r>>1,i=k<<1;
	if(le<=mid) ctag(i,l,mid,le,ri,val,kd);
	if(mid<ri) ctag(i|1,mid+1,r,le,ri,val,kd);
}

int cask(int k,int l,int r,int x)
{
	pushdown(k,l,r);
	if(l==r) return tag[1][k];
	int mid=l+r>>1,i=k<<1;
	if(x<=mid) return cask(i,l,mid,x);
	return cask(i|1,mid+1,r,x);
}

int main()
{
	n=read(),m=read();
	memset(tag[0],0x7f,sizeof(tag[0]));
	while(m--){
		int t=read(),l=read(),r=read(),v=read();
		ctag(1,1,n,l+1,r+1,v,t&1);
	}for(int i=1;i<=n;++i) printf("%d\n",cask(1,1,n,i));
	return 0;
}
```

---

## 作者：Yoimiyamwf (赞：1)

### 题外话

好像没人用这种做法...本蒟蒻感觉这种做法更好理解一点，于是就写了这片题解。

# 正文部分

## 题目大意

给定一个初始值全为 $0$ 的序列，有两种操作：

1. 使区间 $[l,r]$ 内所有小于 $h$ 的数字变为 $h$。
2. 使区间 $[l,r]$ 内所有大于 $h$ 的数字变为 $h$。

输出经过 $M$ 次操作后的序列。

## 思路

区间修改，~~由标签可知~~可以使用线段树解决该问题。

思路比较直接，在每个节点上维护一个 $h$，表示这一节点对应的 $[l,r]$ 区间内每点的高度，其余部分利用线段树的区间修改操作来实现。

但这样做的话出现一个问题：非常显然每个区间内各点的 $h$ 不一定相等，如果用 $h$ 直接表示各点高度会出问题。

于是我们令 $h = -1$ 表示该区间内各点高度不等，查找或修改时若发现某条线段的 $h = -1$ 只要继续向下找两个儿子即可。

## 写法
设左右儿子及父亲的 $h$ 分别为 $h_{lson}$、$h_{rson}$ 和 $h_{father}$。

#### 更新父节点—— $\operatorname{pushup}$ 函数

在执行 $\operatorname{pushup}$ 函数时：

- 当 $h_{lson} = h_{rson}$ 时，令 $h_{father} \gets h_{lson}$（或 $h_{father} \gets h_{rson}$）。

- 当 $h_{lson} \neq h_{rson}$ 时，令 $h_{father} \gets -1$。

#### 更新子节点—— $\operatorname{pushdown}$ 函数

和 $\operatorname{pushup}$ 同理，在执行 $\operatorname{pushdown}$ 时，仅当 $h_{father} \geq 0$ 时，令 $h_{lson} \gets h_{father}$，$h_{rson} \gets h_{father}$。

#### 区间修改—— $\operatorname{modify}$ 函数

$\operatorname{modify}$ 函数按照一般方式写即可，唯一不同的一点是，一般线段树只要当前线段被修改区间完全覆盖即可修改后跳出递归，但由于本题中 $ h_{lson} ≠ h_{rson} $ 时不能直接修改，所以对不满足 $ h_{lson} = h_{rson} $ 的线段，即使它被完全覆盖也不能直接修改，而是应继续向下找它的儿子。

同时由于有两种操作，需要对两种操作各写一个 $\operatorname{modify}$。

#### 输出答案

输出时，只需要将最终的树用 DFS 遍历一遍，由于 DFS 的特性，只要发现当前结点 $h \geq 0$，则输出 $l-r+1$ 遍 $h$，否则继续向下遍历两个儿子即可。

## 时间复杂度

由于这是个比较标准的线段树，线段树修改和查询操作时间复杂度均为 $O \left ( n\log_{} {n}  \right )$，故总时间复杂度即为 $O \left ( n\log_{}{n}  \right )$。

## 代码

蒟蒻码风过于清奇，请轻喷（逃）

```cpp
#include <bits/stdc++.h>
#define r(a) runtimerror(a) //给快读快写取个复杂的变量名再define一下，既可以偷懒少打两下还能防止冲突
#define w(a) wronganswer(a)
#define wl(a) wronganswer(a);putchar('\n')
#define rint register int
#define in inline
#define N 2000010
using namespace std;
int n,k,opt,l,r,h;
template <typename type> in void runtimerror(type &a){
    type x=1,f=0;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-') x=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        f=(f<<3)+(f<<1)+(ch^48);
        ch=getchar();
    }
    a=x*f;
}
template <typename type> void wronganswer(type a){
    if(a<0){a=-a;putchar('-');}
    if(a>9) w(a/10);
    putchar(a%10^48);
}
template <typename type> struct segment_tree{
    struct segment{
        type l,r,h;
    }tr[4*N];
    in void pushup(type id){
        tr[id].h=tr[id<<1].h==tr[id<<1|1].h?tr[id<<1].h:-1;
    }
    in void pushdown(type id){
        if(tr[id].h!=-1){
            tr[id<<1].h=tr[id].h,tr[id<<1|1].h=tr[id].h;
        }
    }
    void build(type id,type l,type r){
        tr[id]={l,r,0};
        if(l==r) return;
        type mid=l+r>>1;
        build(id<<1,l,mid),build(id<<1|1,mid+1,r);
    }
    void modify_add(type id,type l,type r,type h){
        if(tr[id].l>=l&&tr[id].r<=r&&((~tr[id].h)||tr[id].l==tr[id].r)){ //i!=-1可以利用位运算写成~i，这样会略快一点
            tr[id].h=max(tr[id].h,h);
            return;
        }
        pushdown(id);
        type mid=tr[id].l+tr[id].r>>1;
        if(mid>=l) modify_add(id<<1,l,r,h);
        if(mid<r) modify_add(id<<1|1,l,r,h);
        pushup(id);
    }
    void modify_remove(type id,type l,type r,type h){
        if(tr[id].l>=l&&tr[id].r<=r&&((~tr[id].h)||tr[id].l==tr[id].r)){
            tr[id].h=min(tr[id].h,h);
            return;
        }
        pushdown(id);
        type mid=tr[id].l+tr[id].r>>1;
        if(mid>=l) modify_remove(id<<1,l,r,h);
        if(mid<r) modify_remove(id<<1|1,l,r,h);
        pushup(id);
    }
    void print(type id){
        if(~tr[id].h){
            for(int i=tr[id].l;i<=tr[id].r;i++){
                wl(tr[id].h);
            }
            return;
        }
        print(id<<1);
        print(id<<1|1);
    }
};
segment_tree <int> t;
int main(){
    r(n),r(k);
    t.build(1,0,n-1); //本题节点编号是从0到n-1，稍微注意一下
    for(rint i=1;i<=k;i++){
        r(opt),r(l),r(r),r(h);
        if(opt==1){
            t.modify_add(1,l,r,h);
        }else{
            t.modify_remove(1,l,r,h);
        }
    }
    t.print(1);
    return 0;
}
```

---

## 作者：Redpojoe (赞：1)

> 背景：写完之后随手翻开几份代码/题解，发现都有Down函数，所以写写自己不用下传标记的写法（即不是**直接**用数据结构维护的写法）。

本解法涉及内容：线段树，二分，线段树上二分，离线。

我们发现这题的特征是一个序列，两种相对立而无本质区别的区间修改操作，所有询问放在最后，所以我们~~（可能只有我）~~会联想到[这道题](https://www.luogu.com.cn/problem/P2824)。因此我们考虑离线+二分。

具体地，对于一个位置，二分它最后的结果是否小于等于某个值 $d$。接着将所有自然数分为2类：小于等于 $d$ 的和大于 $d$ 的，将前者记为0，后者记为1，在该意义下，只需要知道最终结果是0还是1。然后，我们发现在只有0和1的意义下，所有操作不外乎4种类型：

1. 第一类操作，$h\gt d$，等价于将区间赋值为1。
2. 第二类操作，$h\le d$，等价于将区间赋值为0。
3. 第一类操作，$h\le d$，在该意义下没有影响，可以忽视。
4. 第二类操作，$h\gt d$，在该意义下没有影响，可以忽视。

容易知道该位置最后的结果决定于最后一个1型或2型操作（假设在一开始，有一个覆盖整个序列的 $h=0$ 的第二类操作），若该操作为1型则结果为1，为2型则结果为0。这可以通过分别查询标号最大的满足 $h\gt d$ 的第一类操作和标号最大的满足 $h\le d$ 的第二类操作的标号，并比较大小实现。可以将所有更新操作放到一棵线段树上，这棵线段树以 $h$ 的排名为下标（关于为什么不直接用 $h$，一是排名的范围小，二是若用排名，单点上最多同时只有一个元素，可以直接单点赋值更新），把每个操作放到其 $h$ 的排名对应的那个点上，维护区间内最大的第一类操作的标号和第二类操作标号，查询区间（事实上只有前缀和后缀）最大值。

上述策略是对于单个点查询的，我们需要一个经典的离线套路来对所有位置查询而不炸复杂度：从左往右扫所有位置，对于一个在 $[L,R]$ 内有效的更新操作，在扫到 $L$ 时使其生效，扫到 $R+1$ 时使其失效（类似差分）。在本题里，生效即把这个操作放到线段树上单点赋值，失效就是重新把这个点赋值为0。

最后，发现直接执行以上步骤复杂度过高（单次查询是二分$O(\log k)$乘以线段树$O(\log k)$的），因此考虑一种二分与线段树放到一起的经典优化——线段树上二分。在线段树上查询到某个区间时，维护左于该区间的最大第二类操作标号及右于该区间的最大第一类操作标号，并分别与该区间的左子区间的第二类操作标号和右子区间的最大第一类操作标号取 $\max$，以此获得该区间中点以前的最大第二类操作标号及中点以后的第一类操作标号，来进行比较和选择（好绕啊）。具体可以见代码。

总复杂度：**设$n,k$同阶**，优化后单次查询 $O(\log n)$，查询 $O(n)$ 次；单次单点更新 $O(\log n)$ ，更新$O(n)$次，其它IO预处理之类的均可以不计（或者只计入排序过程，不高于 $O(n\log n)$ ），总复杂度 $O(n\log n)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=2e6+15;

int n,m;
struct node
{
    int L,R,d,t;bool ty;//t是标号
    bool operator <(const node &b)const{return d<b.d;}
}A[M];

struct SFoNKH
{
#define tp T[p]
#define lp T[p<<1]
#define rp T[p<<1|1]
#define ls p<<1
#define rs p<<1|1
    struct node{int L,R,Maxmax,Maxmin;}T[M<<2];int Tid[M];
    void Up(int p)
    {
        tp.Maxmax=max(lp.Maxmax,rp.Maxmax);
        tp.Maxmin=max(lp.Maxmin,rp.Maxmin);
    }
    void Build(int L,int R,int p)
    {
        tp.L=L,tp.R=R,tp.Maxmax=tp.Maxmin=0;
        if(L==R){Tid[L]=p;return;}
        int mid=(L+R)>>1;
        Build(L,mid,ls);Build(mid+1,R,rs);
    }
    void Update(int pos,int val,bool ty)//非递归式单点赋值修改
    {
        int p=Tid[pos];
        if(ty)tp.Maxmax=val;else tp.Maxmin=val;
        for(p>>=1;p;p>>=1)Up(p);
    }
    int Query(int maxminyay,int maxmaxyay,int p)//线段树上二分查询
    {
        if(tp.L==tp.R)return tp.L;
        int ll=max(maxminyay,lp.Maxmin),rr=max(maxmaxyay,rp.Maxmax);//ll对应2型，rr对应1型
        if(ll>rr)return Query(maxminyay,rr,ls);
        else return Query(ll,maxmaxyay,rs);
        // 判定d=A[(tp.L+tp.R)>>1].d时结果为0还是1，0则向左递归，1则向右递归
    }
#undef tp
#undef lp
#undef rp
#undef ls
#undef rs
}YD;

struct event
{
    int id,t;bool ty;
    bool operator <(const event &b)const{return t<b.t;}
}B[M<<1];int bco;

void Solve()
{
    sort(A+1,A+m+1);
    for(int i=1;i<=m;i++)B[++bco]=(event){i,A[i].L,true};
    for(int i=1;i<=m;i++)B[++bco]=(event){i,A[i].R+1,false};
    sort(B+1,B+bco+1);
    YD.Build(1,m,1);
    int pos=1;
    for(int i=0;i<n;i++)
    {
        while(pos<=bco && B[pos].t<=i)//经典离线归并扫
        {
            int x=B[pos].id;
            if(B[pos].ty)YD.Update(x,A[x].t,A[x].ty);
            else YD.Update(x,0,A[x].ty);
            pos++;
        }
        printf("%d\n",A[YD.Query(0,0,1)].d);//线段树上二分得到的结果是排名，需要映射为h真实值
    }
}

int main()
{
    scanf("%d%d",&n,&m);
    ++m;A[1]=(node){0,n-1,0,1,false};//保险操作
    for(int i=2,op;i<=m;i++)scanf("%d%d%d%d",&op,&A[i].L,&A[i].R,&A[i].d),A[i].ty=op==1,A[i].t=i;
    Solve();
    return 0;
}
```

---

## 作者：Natsume_Rin (赞：0)

这一题就是一个比较裸的线段树。

- 操作 $1$：取 $\max$ 操作。
- 操作 $2$：取 $\min$ 操作。

那么，我们只需要在原来的 `Pushdown` 函数略加修改即可。

```cpp
inline void undate_add(int k, int Max){
	if(tree[k].maxx<=Max) tree[k].maxx=Max;
	if(tree[k].minn<=Max) tree[k].minn=Max;
	return ;
}
inline void undate_rem(int k, int Min){
	if(tree[k].maxx>=Min) tree[k].maxx=Min;
	if(tree[k].minn>=Min) tree[k].minn=Min;
	return ;
}
inline void Pushdown(int k){
	undate_add(k<<1,tree[k].maxx);
	undate_add(k<<1|1,tree[k].maxx);
	undate_rem(k<<1,tree[k].minn);
	undate_rem(k<<1|1,tree[k].minn);
	tree[k].minn=INF;
	tree[k].maxx=0;
	return ;
}
```

对于区间 $[l,r]$ 的修改。

像原来线段树一样即可。在找左子树或者右子树前记得调用 `Pushdown` 即可。

**不过要注意一下，在找到了一个长度为 $1$ 的区间时，要记得直接更新。**

```cpp
inline void change_add(int k, int l, int r, int d){
	if(l<=tree[k].l&&tree[k].r<=r){
		undate_add(k,d);
		return ;
	}
	int mid=(tree[k].l+tree[k].r)>>1;
	Pushdown(k);
	if(l<=mid) ch_add(k<<1,l,r,d);
	if(r>mid) ch_add(k<<1|1,l,r,d);
	return ;
}
inline void change_rem(int k, int l, int r, int d){
	if(l<=tree[k].l&&tree[k].r<=r){
		undate_rem(k,d);
		return ;
	}
	int mid=(tree[k].l+tree[k].r)>>1;
	Pushdown(k);
	if(l<=mid) ch_rem(k<<1,l,r,d);
	if(r>mid) ch_rem(k<<1|1,l,r,d);
	return ;
}
```

完整代码：

```cpp
#include<bits/stdc++.h>
#define RI register int
using namespace std;
const int MAXN = 2e6+5, INF = 2147483647;
int n;
struct node{
	int l, r, maxx, minn;
}tree[MAXN<<2];
inline int read(){
    int X=0,w=0; char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;
}
inline void write(int x){
    if(x<0){putchar('-'),x=-x;}
    if(x>9)write(x/10);
    if(x<9){putchar(x+'0');return ;} 
    putchar(x%10+'0');
}
inline void undate_add(int k, int Max){
	if(tree[k].maxx<=Max) tree[k].maxx=Max;
	if(tree[k].minn<=Max) tree[k].minn=Max;
	return ;
}
inline void undate_rem(int k, int Min){
	if(tree[k].maxx>=Min) tree[k].maxx=Min;
	if(tree[k].minn>=Min) tree[k].minn=Min;
	return ;
}
inline void Pushdown(int k){
	undate_add(k<<1,tree[k].maxx);
	undate_add(k<<1|1,tree[k].maxx);
	undate_rem(k<<1,tree[k].minn);
	undate_rem(k<<1|1,tree[k].minn);
	tree[k].minn=INF;
	tree[k].maxx=0;
	return ;
}
inline void build(int k, int l, int r){
	tree[k].l=l;
	tree[k].r=r;
	tree[k].maxx=0;
	tree[k].minn=INF;
	if(l==r){
		return ;
	}
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	return ;
}
inline void Q(int k){
	if(tree[k].l==tree[k].r){
		write(tree[k].maxx);
		putchar('\n');
		return ;
	}
	Pushdown(k);
	Q(k<<1);
	Q(k<<1|1);
	return ;
}
inline void change_add(int k, int l, int r, int d){
	if(l<=tree[k].l&&tree[k].r<=r){
		undate_add(k,d);
		return ;
	}
	int mid=(tree[k].l+tree[k].r)>>1;
	Pushdown(k);
	if(l<=mid) change_add(k<<1,l,r,d);
	if(r>mid) change_add(k<<1|1,l,r,d);
	return ;
}
inline void change_rem(int k, int l, int r, int d){
	if(l<=tree[k].l&&tree[k].r<=r){
		undate_rem(k,d);
		return ;
	}
	int mid=(tree[k].l+tree[k].r)>>1;
	Pushdown(k);
	if(l<=mid) change_rem(k<<1,l,r,d);
	if(r>mid) change_rem(k<<1|1,l,r,d);
	return ;
}
int main(){
	int k;
	int opt, l, r, d;
	n=read(), k=read();
	build(1,1,n);
	while(k--){
		opt=read(), l=read(), r=read(), d=read();
		l++, r++;
		if(opt==1) change_add(1,l,r,d);
		if(opt==2) change_rem(1,l,r,d);
	}
	Q(1);
	return 0;
}
```

---


# 矿洞：坍塌

## 题目背景

- Made By tomoo

CYJian家里为什么那么有钱？因为他家$&@$%#开了矿！！

CYJian家虽然有矿，但是有矿也不能任性。这不，CYJian家的矿塌了......

**change:出题人仁慈地放大了空间限制**

## 题目描述

CYJian家的矿塌了之后，就没有经济来源了（不要问我怎么没有存款）。

于是，CYJian迫切地想要修复他家的矿。

CYJian家的矿共出产$A,B,C$三种矿石，所以我们也只能用$A,B,C$三种材料来修复他们家的矿。我们已知共有$N$吨材料，每吨材料均为$A,B,C$三种材料中的一种，它们连成了一个串，如：
$$ABCBCABCBACBCBAA$$
CYJian家对材料的要求非常严格，他每次会选择一段连续区间的材料作为修复的材料。因为不合要求的材料会使得矿再次塌陷，砸死CYJian，所以这个连续区间的材料必须满足一下$2$个要求：
- 这段连续区间必须是同一种材料
- 这段连续区间的前一个材料与后一个材料必须不相同。

例如，有一段材料为$AACBBABBBCCCBBB$，则$(4$~$5)$ 区间的 $BB$ 和 $(5$~$5)$ 区间的 $B$ 均符合要求，而 $(10$~$12)$ 区间的 $CCC$ 不符合要求。

材料有灵性，所以材料会有变化。

现在有$N$吨材料，$K$个询问。每个询问是以下的$2$种形式之一：

- A x y op 表示替换材料，将$x$到$y(1<=x<=y<=N)$区间内的材料替换为$op$，$op$为$A,B,C$三种材料字符中的一个。
- B x y 表示是否询问，即询问$x$到$y(1<=x<=y<=N)$区间内的材料是否合法，合法输出$Yes$，不合法输出$No$。

注意:当$x=1$或$y=N$时,你的程序不需要判断前后的情况,而只需要判断区间内的情况.

## 说明/提示

- 对于$30$%的数据，$N\le1000,K\le2000$
- 对于$70$%的数据，$N\le5000,K\le5000$
- 对于$100$%的数据，$N\le500000,K\le500000,1<x<=y<N$


## 样例 #1

### 输入

```
15
AACBBABBBCCCBBB
3
B 4 5
B 5 5
B 10 12```

### 输出

```
Yes
Yes
No```

## 样例 #2

### 输入

```
5
ABBBB
2
B 1 4
B 2 5```

### 输出

```
No
Yes```

# 题解

## 作者：眠ㅤㅤㅤ (赞：18)



对于珂朵莉树的每一个节点，我们考虑维护一个性质：该节点的与相邻的节点颜色不允许一样，也就是说连续一段颜色合并为一个节点。

拿样例来构造：$AACBBABBBCCCBBB$

此时对应的珂朵莉树：$A_{[1,2]},C_{[3,3]},B_{[4,5]},A_{[6,6]},B_{[7,9]},C_{[10,12]},B_{[13,15]}$


有了这个性质那么查询时候只需要二分找到 $L,R$ 分别所在的位置的迭代器，那么这两个迭代器必须相等才能得到连续相同的一段，然后分类讨论一下就行了。

对于区间覆盖，也要分类讨论，需要考虑覆盖区间边界与覆盖区间边界所在的珂朵莉树节点中的区间边界位置来分类，保证我们维护的性质不变。

例如在以上的例子中，把 $[$ $6,6$ $]$ 区间改为 $B$，修改之后的珂朵莉树应该要变成：
$A_{[1,2]},C_{[3,3]},B_{[4,9]},C_{[10,12]},B_{[13,15]}$

需要注意的细节其实挺多的，如果代码有什么问题私信我。(修改了错误的注释

$ $

完整代码：
```cpp
constexpr auto Inf = 0X3F3F3F3F;
#ifndef LOCAL
	#include <bits/stdc++.h>
#endif

typedef long long LL;
using namespace std;

namespace IO {
	inline LL read() {
		LL o = 0, f = 1; char c = getchar();
		while (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar(); }
		while (c > '/' && c < ':') { o = o * 10 + c - '0'; c = getchar(); }
		return o * f;
	}
	inline char recd() {
		char o; while ((o = getchar()) < 'A' || o > 'Z'); return o;
	}
	inline double reod() {
		double o = read(), f = 1; char c;
		while ((c = getchar()) > '/' && c < ':') o += (c - '0') / (f *= 10);
		return o;
	}
}
using namespace IO;

const int SIZE = 2E5 + 7, Mod = (1E9 + 7, 998244353);

struct Chtholly {
	int L, R, w;
	Chtholly(int L, int R = 0, int w = 0) : L(L), R(R), w(w) {};
	bool operator < (const Chtholly& Tmp) const {
		return L < Tmp.L;
	}
}; set<Chtholly> Set; int N;

set<Chtholly>::iterator split(int pos) {                   
	auto Iter = prev(Set.upper_bound(Chtholly(pos)));
	if (Iter->L == pos) return Iter;
	int L = Iter->L, R = Iter->R, w = Iter->w;
	Set.erase(Iter); Set.insert(Chtholly(L, pos - 1, w));
	return Set.insert(Chtholly(pos, R, w)).first;
}

void Nota(int L, int R, int w) {
	auto LIter = prev(Set.upper_bound(Chtholly(L)));
	auto RIter = prev(Set.upper_bound(Chtholly(R)));

	/* 对右边颜色相同的点合并 */
	if (RIter != prev(Set.end()) && RIter->R == R && w == (RIter = next(RIter))->w) 
		R = RIter->R, RIter = next(RIter);
	else if (RIter->w != w)
		RIter = split(R + 1), LIter = prev(Set.upper_bound(Chtholly(L)));
	else 
		R = RIter->R, RIter = next(RIter);

	/* 对左边颜色相同的点合并 */
	if (LIter != Set.begin() && LIter->L == L && w == (prev(LIter))->w)
		LIter = prev(LIter), L = LIter->L;
	if (LIter->w != w)
		LIter = split(L);
	else
		L = LIter->L;

	/* 替换掉 */
	Set.erase(LIter, RIter);
	Set.insert(Chtholly(L, R, w));
}

bool Seniorious(int L, int R) {     
	auto now = prev(Set.upper_bound(Chtholly(L)));
	if (now != prev(Set.upper_bound(Chtholly(R)))) return false;
	if (!(L != 1 && R != N)) return true;

	/* 分类讨论即可 */
	if (L >  now->L && R <  now->R) return false;
	if (L == now->L && R != now->R) return prev(now)->w != now->w;
	if (R == now->R && L != now->L) return next(now)->w != now->w;
	return prev(now)->w != next(now)->w;
}

int main() {
	N = read(); 
	int L = 1, R = 1, pos = N; char w, prew = recd();
	while (pos-- > 1) {
		w = recd(); if (w == prew) { R++; continue; }
		Set.insert(Chtholly(L, R, prew)); L = ++R; prew = w;
	} Set.insert(Chtholly(L, R, prew));

	int que = read(); char o;
	while (que--) {
		o = recd(), L = read(), R = read();
		if (o == 'A') Nota(L, R, recd());
		else puts(Seniorious(L, R) ? "Yes" : "No");
	}
}
```

---

## 作者：George1123 (赞：17)

[${\color{orange}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/Wendigo/)

[P4979 【矿洞：坍塌】](https://www.luogu.org/problem/P4979)

### 此题算法:线段树

听说要用珂朵莉树，卡线段树，是假的。

大致思路:(模板型的线段树)

>1.$ $线段树(推荐装成结构体)的$col[]$数组表示区间的颜色，如果同色，就为$1$、$2$或$3$，否则，就为$-1$。其中$mark[]$数组为$lazytag$用的标记数组。

```cpp
struct hextree{
	int col[N<<2],mark[N<<2];
	hextree(){memset(mark,-1,sizeof mark);}
}
```

>2.$pushup()$函数要判断左右子区间是否同色，如下。

```cpp
void pushup(rnt k){
	if(col[k<<1]==col[k<<1|1]){
		col[k]=col[k<<1];
	} else col[k]=-1;
}
```

>3.$pushdown()$函数用来下移标记，如下。

```cpp
void pushdown(rnt k){
	if(mark[k]!=-1){
		col[k<<1]=col[k<<1|1]=mark[k];
		mark[k<<1]=mark[k<<1|1]=mark[k];
		mark[k]=-1;
	}
}
```
>4.对于每个询问，按题目判断中间是否同色并且左边和右边是否异色。

![4979.jpg](https://i.loli.net/2019/10/29/KPpfrajJDN35Y6C.jpg)


## 以下是代码+注释

```cpp
#include <bits/stdc++.h>
using namespace std;
#define rnt register int
const int N=5e5+10;
int n,q;
string cyj;
struct hextree{  //线段树
	int col[N<<2],mark[N<<2];
	hextree(){memset(mark,-1,sizeof mark);}
	void pushup(rnt k){
		if(col[k<<1]==col[k<<1|1]){
			col[k]=col[k<<1];
		} else col[k]=-1;
	} void pushdown(rnt k){
		if(mark[k]!=-1){
			col[k<<1]=col[k<<1|1]=mark[k];
			mark[k<<1]=mark[k<<1|1]=mark[k];
			mark[k]=-1;
		}
	} void build(rnt l,rnt r,rnt k){
		if(l==r){
			col[k]=cyj[l-1]-'A'+1; //取1、2、3
			return;
		} rnt mid=(l+r)>>1;
		build(l,mid,k<<1);
		build(mid+1,r,k<<1|1);
		pushup(k);
	} void fix(rnt x,rnt y,rnt z,rnt l,rnt r,rnt k){
		if(x>r||y<l) return;
		if(x<=l&&r<=y){
			col[k]=mark[k]=z; //别忘加pushdown
			return;
		} pushdown(k);
		rnt mid=(l+r)>>1;
		fix(x,y,z,l,mid,k<<1);
		fix(x,y,z,mid+1,r,k<<1|1);
		pushup(k); 
	} int draw(rnt x,rnt y,rnt l,rnt r,rnt k){
		/*
		0表示此区间并不询问。
		如果一个子区间不询问，返回另一个子区间的返回值
		如果有一个区间混色，返回混色
		如果两个子区间同色，返回此色
		否则，返回混色
		*/
		if(x>r||y<l) return 0; 
		if(x<=l&&r<=y) return col[k];
		pushdown(k);
		rnt mid=(l+r)>>1,L,R;
		L=draw(x,y,l,mid,k<<1); 
		R=draw(x,y,mid+1,r,k<<1|1);
		if(L==0) return R;
		if(R==0) return L;
		if(L==-1||R==-1) return -1;
		if(L==R) return L;
		return -1;
	}
}tree;
int main(){
	scanf("%d",&n);
	cin>>cyj;
	scanf("%d",&q);
	tree.build(1,n,1);
	while(q--){
		int x,y;
		char sign,op;
		scanf(" %c ",&sign);
		if(sign=='A'){
			scanf("%d%d %c",&x,&y,&op);
//			printf("x=%d y=%d op=%c\n",x,y,op); 
			tree.fix(x,y,op-'A'+1,1,n,1);
		} else {
			scanf("%d%d",&x,&y);
			int L=tree.draw(x-1,x-1,1,n,1),
			R=tree.draw(y+1,y+1,1,n,1);
//			printf("L=%d R=%d\n",L,R);
			//如果区间左边没矿，右边没矿或左右边不同矿
			//并且中间是同一种矿，就符合要求
			if(tree.draw(x,y,1,n,1)!=-1
			&&(L!=R||!L||!R)) puts("Yes");
			else puts("No"); //看清大小写
		}
	} 
	return 0;
}
```

输出"NO"和"YES" WA了4次。

谢谢大家! !



---

## 作者：斯茂 (赞：13)

## 我们要充分发扬人类的智慧

设A代表1，B代表500000*A+1，C代表500000*B+1

那么一段区间都是一样的，等价于它的和=A*长度或B*长度或C*长度

这样500000*C也是不会爆long long的，而且就是裸的区间修改查询，可以说是非常好写了

话不多说，上代码

顺便一提，线段树不用非得开四倍，只要开2*（大于等于n的最小的2的次方）即可
```
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
char s[500005];
int n, l[1100005], r[1100005];
long long v[1100005], t[1100005];
long long trans(char c)
{
	if(c == 'A') return 1;
	if(c == 'B') return 500001;
	if(c == 'C') return 250000500001;
}
void build(int nd)
{
	if(l[nd] == r[nd])
	{
		v[nd] = trans(s[l[nd] - 1]);
		return ;
	}
	l[2 * nd] = l[nd], r[2 * nd] = (l[nd] + r[nd]) / 2, l[2 * nd + 1] = r[2 * nd] + 1, r[2 * nd + 1] = r[nd];
	build(2 * nd); build(2 * nd + 1);
	v[nd] = v[2 * nd] + v[2 * nd + 1];
}
void pushdown(int nd)
{
	if(t[nd] != -1)
		t[2 * nd] = t[2 * nd + 1] = t[nd], v[2 * nd] = t[nd] * (r[2 * nd] - l[2 * nd] + 1), v[2 * nd + 1] = t[nd] * (r[2 * nd + 1] - l[2 * nd + 1] + 1), t[nd] = -1;
}
void set(int nd, int p, int q, long long c)
{
	if(p > r[nd] || q < l[nd]) return ;
	if(p <= l[nd] && q >= r[nd])
	{
		t[nd] = c;
		v[nd] = c * (r[nd] - l[nd] + 1);
		return ;
	}
	pushdown(nd);
	set(2 * nd, p, q, c);
	set(2 * nd + 1, p, q, c);
	v[nd] = v[2 * nd] + v[2 * nd + 1];
}
long long query(int nd, int p, int q)
{
	if(p == 0) return -1;
	if(q == n + 1) return -2;
	if(p > r[nd] || q < l[nd]) return 0;
	if(p <= l[nd] && q >= r[nd]) return v[nd];
	pushdown(nd);
	return query(2 * nd, p, q) + query(2 * nd + 1, p, q);
}
int main(int argc, char **argv)
{
	int m, p, q, f, i;
	char op[4], cc[4];
	long long t0, t1, t2;
	scanf("%d%s", &n, s);
	l[1] = 1, r[1] = n;
	memset(t, -1, sizeof(t));
	build(1);
	scanf("%d", &m);
	for(i = 1; i <= m; i++)
	{
		scanf("%s%d%d", op, &p, &q);
		if(op[0] == 'A')
		{
			scanf("%s", cc);
			set(1, p, q, trans(cc[0]));
		}
		else
		{
			f = 0; t1 = query(1, p, q), t0 = query(1, p - 1, p - 1), t2 = query(1, q + 1, q + 1);
			if((t1 == q - p + 1 || t1 == 500001 * (q - p + 1) || t1 == 250000500001 * (q - p + 1)) && t0 != t2) f = 1;
			printf("%s\n", f ? "Yes" : "No");	
		}
	}
	return 0;
}
```

---

## 作者：LJC00101 (赞：7)

这题有两种做法，复杂度都可以是正确的。（关于ODT，他活了

首先,可以线段树来做，这里讲一下剪枝。

第一个就是DPair的，如果一个区间全部为一个颜色，说明它子区间也都为此颜色，就不用划分区间了。

然后可以开一个全局变量，有混色就把全部分支退出（实测没有什么用）

下面放上我的线段树卡常代码（没有可读性，但目前最优解）
```cpp
// #pragma GCC optimize(2, "Ofast", "inline")
// #pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")
// #pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
#define getcha() (SS == TT && (TT = (SS = BB) + fread(BB, 1, 1 << 15, stdin), SS == TT) ? EOF : *SS++)
#define isint(a) ((a >= '0') && (a <= '9'))
#define ischa(a) ((a >= 'A') && (a <= 'C'))
char BB[1 << 15], *SS = BB, *TT = BB;
inline int read()
{
    int s = 0;
    char ch = getcha();
    while (!isint(ch))
        ch = getcha();
    while (isint(ch))
        s = (s << 3) + (s << 1) + (ch ^ 48), ch = getcha();
    return s;
}
inline char rad()
{
    char ch = getcha();
    while (!ischa(ch))
        ch = getcha();
    return ch ^ 64;
}
int n, q;
char u[20005000];
char a[5000500];
#define pushup(k)                                \
    if ((!u[k << 2]) && (!u[k << 2 | 2]))        \
    {                                            \
    }                                            \
    else if ((!u[k << 2]) || (!u[k << 2 | 2]))   \
    {                                            \
        u[k << 1] = (u[k << 2] | u[k << 2 | 2]); \
    }                                            \
    else if (u[k << 2] ^ u[k << 2 | 2])          \
    {                                            \
        u[k << 1] = 4;                           \
    }                                            \
    else                                         \
    {                                            \
        u[k << 1] = u[k << 2];                   \
    }
#define pushdown(k)                                                   \
    if (u[k << 1 | 1])                                                \
    {                                                                 \
        u[k << 2] = u[k << 1 | 1], u[k << 2 | 1] = u[k << 1 | 1];     \
        u[k << 2 | 2] = u[k << 1 | 1], u[k << 2 | 3] = u[k << 1 | 1]; \
        u[k << 1 | 1] = 0;                                            \
    }
void build(int k, int L, int R)
{
    if (L == R)
    {
        u[k << 1] = a[L];
        return;
    }
    int mid = (L + R) >> 1;
    build(k << 1, L, mid), build(k << 1 | 1, mid + 1, R);
    pushup(k);
    return;
}
void add(int k, int l, int r, int rl, int rr, int ee)
{
    if (rl <= l && rr >= r)
    {
        if ((!(u[k << 1] ^ ee)) && (!u[k << 1 | 1]))
            return;
        u[k << 1] = ee;
        u[k << 1 | 1] = ee;
        return;
    }
    pushdown(k);
    int mid = (l + r) >> 1;
    if (rl <= mid)
    {
        add(k << 1, l, mid, rl, rr, ee);
    }
    if (rr > mid)
    {
        add(k << 1 | 1, mid + 1, r, rl, rr, ee);
    }
    pushup(k);
    return;
}
int trump;
int query(int k, int l, int r, int rl, int rr)
{
    if (!(trump ^ 4))
        return 4;
    if (u[k << 1] ^ 4)
        return u[k << 1];
    if (rl <= l && rr >= r)
    {
        if (u[k << 1] ^ 4)
            return u[k << 1];
        else
            return trump = 4;
    }
    pushdown(k);
    int mid = (l + r) >> 1, ans = 4, tm;
    if (rl <= mid)
    {
        tm = query(k << 1, l, mid, rl, rr);
        ans = tm;
        if (ans & 4)
        {
            return trump = 4;
        }
    }
    if (rr > mid)
    {
        tm = query(k << 1 | 1, mid + 1, r, rl, rr);
        if (ans & 4)
        {
            ans = tm;
        }
        else if (ans ^ tm)
        {
            ans = 4;
            return trump = 4;
        }
    }
    if (trump && (trump ^ ans))
        return trump = 4;
    else
        trump = ans;
    return ans;
}
int main()
{
    n = read();
    for (register int i = 1; i <= n; ++i)
    {
        a[i] = rad();
    }
    q = read();
    build(1, 1, n);
    register int tmc;
    for (register int i = 1, el, er, aa; i <= q; ++i)
    {
        tmc = rad();
        el = read(), er = read();
        if (tmc == 1)
        {
            tmc = rad();
            add(1, 1, n, el, er, tmc);
        }
        else
        {
            if (!(el == 1 || er == n))
            {
                trump = 0;
                aa = query(1, 1, n, el - 1, el - 1);
                trump = 0;
                aa = aa ^ query(1, 1, n, er + 1, er + 1);
                if (!aa)
                {
                    puts("No");
                    continue;
                }
            }
            trump = 0;
            if (query(1, 1, n, el, er) & 4)
            {
                puts("No");
            }
            else
            {
                puts("Yes");
            }
        }
    }
    return 0;
}
```
这道题并没有卡朴素的Chtholly树，那么如果卡了，怎么保证复杂度呢？
我们一样暴力(单次最多O(n))匹配，找到不匹配的就退出，之后**把之前匹配出的相同颜色节点合并成一个**。

这样为什么就对了？

考虑区间赋值、询问每次最多使节点数增加2，初始最多n，所以累积总共出现n集别的节点，设每次暴力匹配运行次数为x+2，则减少了x个节点，所以暴力复杂度最多为O（n）级。
而set的lower_bound、erase、insert都是最多log(n)级的，运行n次，总复杂度为nlog(n)，可以通过此题。
下面为Chtholly树代码：
```cpp
// #pragma GCC optimize(2, "Ofast", "inline")
// #pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")
// #pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <set>
#include <time.h>
#include <chrono>
using namespace std::chrono;
#define getcha() (SS == TT && (TT = (SS = BB) + fread(BB, 1, 1 << 15, stdin), SS == TT) ? EOF : *SS++)
#define isint(a) ((a >= '0') && (a <= '9'))
#define ischa(a) ((a >= 'A') && (a <= 'C'))
char BB[1 << 15], *SS = BB, *TT = BB;
inline int read()
{
    int s = 0;
    char ch = getcha();
    while (!isint(ch))
        ch = getcha();
    while (isint(ch))
        s = (s << 3) + (s << 1) + (ch ^ 48), ch = getcha();
    return s;
}
inline char rad()
{
    char ch = getcha();
    while (!ischa(ch))
        ch = getcha();
    return ch ^ 64;
}
#define IT set<node>::iterator
using namespace std;
struct node
{
    int l, r, v;
    node(int L, int R = -1, int V = 0) : l(L), r(R), v(V) {}
    bool operator<(const node &o) const
    {
        return l < o.l;
    }
};
set<node> s;
IT split(int pos)
{
    IT it = s.lower_bound(node(pos));
    if (it != s.end() && it->l == pos)
        return it;
    --it;
    int L = it->l, R = it->r;
    int V = it->v;
    s.erase(it);
    s.insert(node(L, pos - 1, V));
    return s.insert(node(pos, R, V)).first;
}
void tpval(int l, int r, int val)
{
    IT itr = split(r + 1), itl = split(l);
    s.erase(itl, itr);
    s.insert(node(l, r, val));
}
int n, q, ll, a, b;
int main()
{
    n = read();
    ll = 1;
    b = a = rad();
    high_resolution_clock::time_point t1 = high_resolution_clock::now();
    for (register int i = 2; i <= n; ++i)
    {
        a = rad();
        if (a ^ b)
        {
            s.insert(node(ll, i - 1, b));
            ll = i;
        }
        b = a;
    }
    s.insert(node(ll, n, a));
    s.insert(node(n + 1, n + 1, 4));
    high_resolution_clock::time_point t2 = high_resolution_clock::now();
    duration<double, std::milli> time_span = t2 - t1;
    if (time_span.count() > 50)
    {
        printf("?");
    }
    q = read();
    register int tmc;
    for (register int i = 1, el, er; i <= q; ++i)
    {
        tmc = rad();
        el = read(), er = read();
        if (tmc == 1)
        {
            tmc = rad();
            tpval(el, er, tmc);
        }
        else
        {
            IT itr = split(er + 1), itl = split(el);
            if (!(el == 1 || er == n))
            {
                --itl;
                if (!(itl->v ^ itr->v))
                {
                    puts("No");
                    continue;
                }
                ++itl;
            }
            IT tm = itl;
            for (; itl != itr; ++itl)
            {
                if (itl->v != tm->v)
                {
                    break;
                }
            }
            if (itl != itr)
            {
                puts("No");
            }
            else
            {
                puts("Yes");
            }
            --itl;
            if (tm != itl)
            {
                tmc = itl->v, el = tm->l, er = itl->r;
                s.erase(tm, itl);
                s.insert(node(el, er, tmc));
            }
        }
    }
    return 0;
}
```
（但是比线段树慢了好多，不开O2依然过不了。

（没办法，set太慢了

下面提供一种把朴素Chtholly树卡成n^2的方法：

构造

n

ABABAB……ABA

n

A 1 1 B

A 3 3 B

……

A n n B

B 1 n

B 1 n

……
说句闲话，我一开始听说ODT时真的以为他能代替一切数据结构，学的时候才发现要区间赋值+数据纯随机/出题人脚造数据

---

## 作者：桐间纱路 (赞：6)

**~~好矿就选CYJ矿，好吃不贵，一斤铁用一年~~**

好吧，人们都看的出来，这就是一道裸的**线段树**啊！([Viston](https://www.luogu.org/space/show?uid=107101)大佬:这么明显的**区间修改查询，都看的出来是线段树吧。**)

实不相瞒，这题比[P3373](https://www.luogu.org/problemnew/show/P3373)还要简单。

我们可以建一个线段树，修改查询啥的大家都懂了啦。__可惜本题有一些小卡常，所以位运算，三目运算符，快读这些必不可少。__

悄悄告诉你哦，本题还有一个小小的优化技巧。由于在一段区间必须都是同一种材料才满足要求，所以在建树 or 修改的时候，只要树上一段区间内有其他的材料，可直接将这个节点的所有父亲/祖先全部判为false.

代码：
```cpp
#include <bits/stdc++.h>

using namespace std;

#define reg register
#define ls (Node << 1)
#define rs ((Node << 1) | 1)
#define Ac puts("Yes")
#define Wa puts("No")

const char FI[] = "pr.in";
const char FO[] = "pr.out";
const int MAXN = 500000;

int tag[MAXN << 2];
int T[MAXN << 2];
char s[MAXN + 1];

inline void build(reg int Node, reg int L, reg int R) {
    if(L == R) {
        T[Node] = s[L] - 'A';
        return ;
    }
    reg int mid = (L + R) >> 1;
    build(ls, L, mid), build(rs, mid + 1, R);
    T[Node] = T[ls] == T[rs] ? T[ls] : -1, tag[Node] = -1;
}

inline void pd(reg int Node) {
    T[ls] = tag[ls] = T[rs] = tag[rs] = tag[Node], tag[Node] = -1;
}

inline void Change(reg int Node, reg int L, reg int R, reg int l, reg int r, reg int x) {
    if(l <= L && R <= r) {
        T[Node] = tag[Node] = x;
        return ;
    }
    if(tag[Node] != -1) pd(Node);
    reg int mid = (L + R) >> 1;
    if(l <= mid) Change(ls, L, mid, l, r, x);
    if(r > mid) Change(rs, mid + 1, R, l, r, x);
    T[Node] = T[ls] == T[rs] ? T[ls] : -1;
}

inline int Query(reg int Node, reg int L, reg int R, reg int l, reg int r) {
    if(l <= L && R <= r) return T[Node];
    if(tag[Node] != -1) pd(Node);
    reg int mid = (L + R) >> 1, t = -2, k = -2;
    if(l <= mid) t = Query(ls, L, mid, l, r);
    if(r > mid) k = Query(rs, mid + 1, R, l, r);
    if(t == -2 || k == -2) return t == -2 ? k : t;
    else return t == k ? t : -1;
}

int main() {
    reg int n, m, l, r;
    reg char opt, chg;
    scanf("%d\n%s\n%d\n", &n, s + 1, &m);
    build(1, 1, n);
    while(m--) {
        scanf("%c ", &opt);
        if(opt == 'A') {
            scanf("%d %d %c\n", &l, &r, &chg);
            chg -= 'A';
            Change(1, 1, n, l, r, chg);
        }
        else {
            scanf("%d %d\n", &l, &r);
            if(Query(1, 1, n, l, r) != -1 && (l == 1 || r == n || Query(1, 1, n, l - 1, l - 1) != Query(1, 1, n, r + 1, r + 1))) Ac;
            else Wa;
        }
    }
    return 0;
}
```


---

## 作者：happybob (赞：2)

首先，这里提供的代码可能因为评测机波动而导致无法在不开 O2 下通过，但是开了 O2 后亲测不会出现问题。

现在步入正题。

很多人用了珂朵莉树，但是这题我给大家带来线段树套 `bitset` 的解法，这是以前的题解没有的。

事实上就是线段树每个点开一个 `bitset` 维护这个区间中出现了哪些数，那么显然当一个区间 $[l, r]$ 满足要求当且仅当 $a_l, a_{l+1}, \cdots, a_r$ 维护的 `bitset` 中只有一个 $1$，且 $a_{l-1}$ 和 $a_{r+1}$ 数不同。

$a_l, a_{l+1}, \cdots, a_r$ 维护的 `bitset` 很好求，其实只需把所有区间的 `bitset` 按位或即可，区间覆盖的话每个区间打一个标记即可。

但是由于 `bitset` 常数有些大，需要加各种卡常。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <bitset>
#include <string>
using namespace std;

constexpr int N(5e5 + 5);

int n, m;
string k;

inline int read()
{
	register char ch(getchar());
	register int x(0);
	while (ch < '0' || ch > '9') ch = getchar();
	while (ch >= '0' and ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x;
}

class SegmentTree
{
public:
	struct Node
	{
		int l, r, tag;
		bitset<3> s;
	}tr[N << 2];

#define push_up(u) \
	tr[u].s = tr[u << 1].s | tr[u << 1 | 1].s; \

#define push_down(u) \
	if (tr[u].tag != -1) \
	{ \
		tr[u << 1].tag = tr[u].tag; \
		tr[u << 1].s.reset(); \
		tr[u << 1].s[tr[u].tag] = 1; \
		tr[u << 1 | 1].tag = tr[u].tag; \
		tr[u << 1 | 1].s.reset(); \
		tr[u << 1 | 1].s[tr[u].tag] = 1; \
		tr[u].tag = -1; \
	} \

	void build(register int u, register int l, register int r)
	{
		tr[u] = { l, r, -1 };
		//tr[u].s.reset();
		if (l == r)
		{
			tr[u].s[k[r - 1] - 'A'] = 1;
		}
		else
		{
			register int mid(l + r >> 1);
			build(u << 1, l, mid);
			build(u << 1 | 1, mid + 1, r);
			push_up(u);
		}
	}
	void update(register int u, register int l, register int r, register int k)
	{
		if (tr[u].l >= l and tr[u].r <= r)
		{
			tr[u].tag = k;
			tr[u].s.reset();
			tr[u].s[k] = 1;
		}
		else
		{
			push_down(u);
			register int mid(tr[u].l + tr[u].r >> 1);
			if (l <= mid) update(u << 1, l, r, k);
			if (r > mid) update(u << 1 | 1, l, r, k);
			push_up(u);
		}
	}
	int query_node(register int u, register int x)
	{
		if (tr[u].l == x and tr[u].r == x)
		{
			if (tr[u].s[0]) return 0;
			else if (tr[u].s[1]) return 1;
			return 2;
		}
		push_down(u);
		register int mid(tr[u].l + tr[u].r >> 1);
		return (x <= mid ? query_node(u << 1, x) : query_node(u << 1 | 1, x));
	}
	bitset<3> query(register int u, register int l, register int r)
	{
		if (tr[u].l >= l and tr[u].r <= r) return tr[u].s;
		push_down(u);
		bitset<3> res;
		res.reset();
		register int mid(tr[u].l + tr[u].r >> 1);
		if (l <= mid) res = query(u << 1, l, r);
		if (r > mid) res |= query(u << 1 | 1, l, r);
		return res;
	}
};

SegmentTree sg;

int main()
{
	n = read();
	cin >> k;
	sg.build(1, 1, n);
	m = read();
	while (m--)
	{
		register char c[2];
		scanf("%s", &c[0]);
		if (*c == 'A')
		{
			register int x(read()), y(read());
			register char k[2];
			scanf("%s", &k[0]);
			sg.update(1, x, y, *k - 'A');
		}
		else
		{
			register int x(read()), y(read());
			register bitset<3> q(sg.query(1, x, y));
			if (q.count() > 1)
			{
				puts("No");
			}
			else
			{
				if (x == 1 || y == n) puts("Yes");
				else
				{
					if (sg.query_node(1, x - 1) == sg.query_node(1, y + 1)) puts("No");
					else puts("Yes");
				}
			}
		}
	}
	return 0;
}
```

[AC 记录	2.95s /  47.25MB /  2.81KB C++11](https://www.luogu.com.cn/record/71539199)

[AC 记录  866ms /  47.27MB /  2.81KB C++11 O2](https://www.luogu.com.cn/record/71539536)

不开 O2，最慢的点 $997$ 毫秒。~~再也不用 `bitset` 了。~~

---

## 作者：CreeperLordVader (赞：2)


珂朵莉树是啥？蒟蒻不懂

反正本题用线段树记录颜色是可以的，而且速度挺快，我没怎么卡常，把数组开大一点就过了

看到似乎少有题解记录区间颜色，我来贡献一发详细的记录颜色做法

对线段树的每个节点记录颜色

1表示A，2表示B，3表示C，-1表示杂色

## 1.建树

#### 复杂度O（n），当左右边界重合时，把该点的颜色对应的设为此区间（已经收缩为一点）的颜色

## 2.信息的合并

#### 复杂度O(1)

如果左右儿子同色，则该点颜色为左右儿子的颜色（因为这意味着这个区间都是这种颜色），否则为杂色

#### 为什么不用判断左右儿子有杂色的情况？

假如有一个是杂色，而另一个是纯色，那么两个儿子肯定不同色，该点为杂色

假如都是杂色，该点的颜色为左右儿子的颜色，还是杂色

## 3.懒标记

#### 传统的区间设置

对线段树上每个点，记setc为该点的对应区间被修改成的颜色，-1为无标记

#### 注意，由于修改后的区间只可能是纯色，所以这里的-1不会与杂色混淆

#### 也正是由于这一点，我们直接把左右儿子的颜色都设为setc就好了

#### 每次修改和查询前pushdown标记就行

## 4.查询

先查待查区间左右的颜色(代码中的ask函数)，再查区间的颜色(query函数)

查询区间颜色时，把左右的候选答案合并即可

代码如下，并不是很长，也不容易写错（我用了一发改造过的快读，在读命令时把字母也读成数字）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=500005,IAKIOI=2333;
int col[MAXN<<2],k,n;
int setc[MAXN<<2];
char c[MAXN];
inline void read(int& x)
{
    char c=getchar();
    x=0;
    while(c<'0'||c>'9')
    {
        if(c=='A')
        {
            x=1;
            return ;
        }
        else if(c=='B')
        {
            x=2;
            return ;
        }
        else if(c=='C')
        {
            x=3;
            return ;
        }
        c=getchar();
    }
    while(c>='0'&&c<='9')
    {
        x=x*10+c-'0';
        c=getchar();
    }
}
inline void update(int o)
{
    if(col[o<<1]==col[o<<1|1])col[o]=col[o<<1];
    else col[o]=-1;
}
inline void pushdown(int o)
{
    if(setc[o])
    {
        setc[o<<1]=setc[o<<1|1]=setc[o];
        col[o<<1]=setc[o<<1];
        col[o<<1|1]=setc[o<<1|1];
        setc[o]=0;
    }
}
inline void build(int o,int l,int r)
{
    if(l==r)
    {
        col[o]=c[l]-'A'+1;
        return ;	
    }
    int mid=(l+r)>>1;
    build(o<<1,l,mid);
    build(o<<1|1,mid+1,r);
    update(o);
}
inline void change(int o,int l,int r,int ql,int qr,int x)
{
    if(ql<=l&&qr>=r)
    {
        setc[o]=col[o]=x;
        return ;
    }
    int mid=(l+r)>>1;
    pushdown(o);
    if(ql<=mid)change(o<<1,l,mid,ql,qr,x);
    if(qr>mid)change(o<<1|1,mid+1,r,ql,qr,x);
    update(o);
}
inline int query(int o,int l,int r,int ql,int qr)
{
    int ans,ansl=IAKIOI,ansr=IAKIOI;
    if(ql<=l&&qr>=r)
    {
        return col[o];
    }
    int mid=(l+r)>>1;
    pushdown(o);
    if(ql<=mid)ansl=query(o<<1,l,mid,ql,qr);
    if(qr>mid)ansr=query(o<<1|1,mid+1,r,ql,qr);
    if(ansl!=IAKIOI&&ansr!=IAKIOI)
    {
        if(ansl==ansr)ans=ansl;
        else ans=-1;
    }
    else if(ansl!=IAKIOI)ans=ansl;
    else if(ansr!=IAKIOI)ans=ansr;
    return ans;
}
inline int ask(int o,int l,int r,int p)
{
    if(l==r)
    {
        return col[o];
    }
    int mid=(l+r)>>1;
    pushdown(o);
    if(p<=mid)return ask(o<<1,l,mid,p);
    else return ask(o<<1|1,mid+1,r,p);
}
int main()
{
    read(n);
    scanf("%s",c+1);
    read(k);
    build(1,1,n);
    memset(setc,0,sizeof(setc));
    for(register int i=1;i<=k;i++)
    {
        int op;
        read(op);
        if(op==1)
        {
            int l,r,x;
            read(l);
            read(r);
            read(x);
            change(1,1,n,l,r,x);
        }
        else
        {
            int l,r;
            read(l);
            read(r);
            int cl=-1,cr=-1;
            if(l==1)cl=0;
            else cl=ask(1,1,n,l-1);
            if(r==n)cr=0;
            else cr=ask(1,1,n,r+1);
            if(cl==cr&&cl&&cr)printf("No\n");
            else
            {
                int ans=query(1,1,n,l,r);
                if(ans<0)printf("No\n");
                else printf("Yes\n");
            }
        }
    }
}
```

---

## 作者：Ryo_Yamada (赞：1)

线段树超级水题，不知道为啥是紫的。

将字母 `A,B,C` 用 `1,2,3` 代替，直接维护 $ok_i$ 表示区间每个值是否全部相同以及都是什么值：

- $-1$，代表当前区间每个值不是全部相同
- $x(x \in \{1,\,2,\,3\})$，表示当前区间的值全部相同，且都为 $x$。

以及每个点当前的值。每次判断就按照题目要求判断就好了。

pushup 很好理解：

```cpp
void pushup(int id) {
	ok[id] = (ok[ls] == ok[rs]) ? ok[ls] : -1;
	// 如果都相同就随便取一个
	// 左右区间内都相同，但相同的值不同，为 -1
   // 只要有一个 -1 就一定是 -1
}
```

pushdown：因为是区间替换，直接替换成更改的值即可。

```cpp
void pushdown(int id) {
	if(lz[id]) {
		ok[ls] = ok[rs] = lz[ls] = lz[rs] = lz[id];
		lz[id] = 0;
	}	
}
```

区间查询和 pushup 的思想是一样的：

```cpp
int query(int id, int l, int r, int x, int y) {
	if(x <= l && r <= y) return ok[id];
	pushdown(id);
	Mid;
	int ret = -2;
	if(mid >= x) ret = query(ls, l, mid, x, y);
	if(ret == -1) return -1; // 有 -1，一定是 -1
	if(mid < y) {
		if(ret == -2) ret = query(rs, mid + 1, r, x, y); // 左区间为空，return 右区间的结果
		else {
			int res = query(rs, mid + 1, r, x, y);
			if(res != ret) ret = -1; // 不相同则是 -1
		}
	}
	return ret;
}
```
单点查询，因为每个区间 $[l,\,r]$ 满足 $l=r$ 时一定满足 $ok_i \not= -1$，所以直接使用 $ok$ 数组查询即可。

Code：

```cpp
#define ls id << 1
#define rs id << 1 | 1
#define Mid int mid = (l + r) >> 1

def(N, int, 5e5 + 5)

int n;
int ok[N << 2], lz[N << 2];
char s[N];

il int get(const char &c) { return c - 'A' + 1; }

void pushup(int id) {
	ok[id] = (ok[ls] == ok[rs]) ? ok[ls] : -1;
}

void pushdown(int id) {
	if(lz[id]) {
		ok[ls] = ok[rs] = lz[ls] = lz[rs] = lz[id];
		lz[id] = 0;
	}	
}

void build(int id, int l, int r) {
	if(l == r) {
		ok[id] = get(s[l]);
		return ;
	}
	Mid;
	build(ls, l, mid);
	build(rs, mid + 1, r);
	pushup(id);
}

void update(int id, int l, int r, int x, int y, int v) {
	if(x <= l && r <= y) {
		ok[id] = lz[id] = v;
		return ;
	}
	pushdown(id);
	Mid;
	if(mid >= x) update(ls, l, mid, x, y, v);
	if(mid < y) update(rs, mid + 1, r, x, y, v);
	pushup(id);
}

int query(int id, int l, int r, int x, int y) {
	if(x <= l && r <= y) return ok[id];
	pushdown(id);
	Mid;
	int ret = -2;
	if(mid >= x) ret = query(ls, l, mid, x, y);
	if(ret == -1) return -1;
	if(mid < y) {
		if(ret == -2) ret = query(rs, mid + 1, r, x, y);
		else {
			int res = query(rs, mid + 1, r, x, y);
			if(res != ret) ret = -1;
		}
	}
	return ret;
}

int queryval(int id, int l, int r, int x) {
	if(l == r) return ok[id];
	pushdown(id);
	Mid;
	if(mid >= x) return queryval(ls, l, mid, x);
	else return queryval(rs, mid + 1, r, x);
}

int main() {
	cin >> n;
	scanf("%s", s + 1);
	build(1, 1, n);
	int q; cin >> q;
	W(q) {
		char op;
		int l, r;
		scanf(" %c%d%d", &op, &l, &r);
		if(op == 'A') {
			char v; scanf(" %c", &v);
			int vv = get(v);
			update(1, 1, n, l, r, vv);
		}
		else {
			if(query(1, 1, n, l, r) == -1) {
				puts("No");
				continue;
			}
			if(l == 1 || r == n) puts("Yes");
			else {
				if(queryval(1, 1, n, l - 1) == queryval(1, 1, n, r + 1)) puts("No");
				else puts("Yes");
			}
		}
	}
 	return 0;
}
```


---

## 作者：DPair (赞：1)

目前最优解过来讲一些其他题解里都没有的优化。

本题思路很简单，就是线段树上区间推平和区间查询的操作，这个其他题解里讲的很清楚了。

但其实可以加一个剪枝。

首先我的写法是这样子的：线段树上的每一个节点的权值表示当前区间 **全部都为** 哪种颜色，若当前区间内存在异色的情况则权值为 $-1$ 。这个用 `pushup` 函数很好维护。

然后就可以发现一个很显然的剪枝：你在查询的时候如果找到了一个 **权值不为-1** 的节点，那么显然你再往深搜也必然会搜到相同的答案，此时你就可以直接返回结果以达到剪枝的效果，具体写法为：

```cpp
int query(int rt, int l, int r, int x, int y){
        if(~dat[rt]) return dat[rt];//就是这一句
        if(x <= l && r <= y) return dat[rt];
        pushdown(rt);
        int mid = (l + r) >> 1;
        if(x <= mid && y > mid){
            int ret1 = query(LSON, x, y);
            int ret2 = query(RSON, x, y);
            if(ret1 ^ ret2) return -1;
            else return ret1;
        }
        if(x <= mid) return query(LSON, x, y);
        if(y > mid) return query(RSON, x, y);
    }
```

实测跑的飞快。

然后其他的按着一般的线段树来写即可。

---

## 作者：kradcigam (赞：1)

# [矿洞：坍塌](https://www.luogu.com.cn/problem/P4979) 题解

## 分析

首先，我们考虑使用线段树。

我们发现

- 对于操作 $1$

    - `lazy_tag` 修改就好了

- 对于操作 $2$

    - 看这一段是否所有字符都相同
    - 如果 $l\ne1 \And r\ne n$ ，单点查询第 $l-1$ 和 $r+1$ 这 $2$ 个字符是否相同就行了

### 如何看一段内所有字符是否相同

这个东西确实有点难，我的做法是，虽然字符很多，但每个字符都是 `A`、`B`、`C` 中的一个，所以可以直接看这段字符是否全是 `A`、`B` 或 `C`。

### 开始线段树

#### 维护

综上所述，我们可以开始写题了。

我们需要维护几个值：

- `lazy` 这个应该不用我说了吧，有 $3$ 个值
    - $1$ 表示 `A`
    - $2$ 表示 `B`
    - $3$ 表示 `C`

- `s[3]` 这个就是看这段字符是否全是 `A`、`B` 或 `C`。

    - $s_1$ 表示这段字符是否全是 `A`
    - $s_2$ 表示这段字符是否全是 `B`
    - $s_3$ 表示这段字符是否全是 `C`

#### pushup

这一段区间是否全是 `A`、`B` 或 `C`，仅当左儿子和右儿子**都**全是 `A`、`B` 或 `C`。

```cpp
for(register int i=1;i<=3;i++)t[num].s[i]=(t[ls].s[i]&&t[rs].s[i]);
```

#### 边界条件

对于 $l=r$ 的情况，$s_i$ 的值是否为 $1$，仅当这个字符是否是`A`、`B`、`C`。

#### pushup

修改左子树和右子树

```cpp
void pushdown(int num){
    if(t[num].lazy==1)down1(ls),down1(rs);
    if(t[num].lazy==2)down2(ls),down2(rs);
    if(t[num].lazy==3)down3(ls),down3(rs);
    t[num].lazy=0;
}
```

说说 $down_x$ 怎么写

首先把 `lazy_tag` 的值赋一下，然后，将 $s_x$ 设为 $1$，其他都设为 $0$。

```cpp
void down1(int num){
    t[num].lazy=1;
    t[num].s[1]=1;
    t[num].s[2]=0;
    t[num].s[3]=0;
}
void down2(int num){
    t[num].lazy=2;
    t[num].s[1]=0;
    t[num].s[2]=1;
    t[num].s[3]=0;
}
void down3(int num){
    t[num].lazy=3;
    t[num].s[1]=0;
    t[num].s[2]=0;
    t[num].s[3]=1;
}
```

#### 修改

这个是板子诶，不讲了

```cpp
void change(int num){
    if(L<=t[num].l&&t[num].r<=R){
        if(S==1)down1(num);
        if(S==2)down2(num);
        if(S==3)down3(num);
        return;
    }pushdown(num);
    if(t[ls].r>=L)change(ls);
    if(t[rs].l<=R)change(rs);
    pushup(num);
}
```

#### 单点查询

这个是板子诶，不讲了

```cpp
int query2(int num,int S){//S是要查询的点
    if(t[num].l==t[num].r){
        for(int i=1;i<=3;i++)
            if(t[num].s[i])return i;
    }pushdown(num);
    if(t[ls].r>=S)return query2(ls,S);
    if(t[rs].l<=S)return query2(rs,S);
}
```

#### 区间查询

这个是板子诶，不讲了

```cpp
bool query1(int num,int f){
    if(L<=t[num].l&&t[num].r<=R)return t[num].s[f];
    pushdown(num);
    if(t[ls].r<L)return query1(rs,f);
    if(t[rs].l>R)return query1(ls,f);
    return (query1(ls,f)&&query1(rs,f));
}
```

## 代码

```cpp
// Problem : P4979 矿洞：坍塌
// Contest : Luogu
// URL : https://www.luogu.com.cn/problem/P4979
// Memory Limit : 250 MB
// Time Limit : 1000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <bits/stdc++.h>
#define ls num<<1
#define rs num<<1|1
using namespace std;
typedef long long ll;
template<typename T>inline void read(T &FF){
	T RR=1;FF=0;char CH=getchar();
	for(;!isdigit(CH);CH=getchar())if(CH=='-')RR=-1;
	for(;isdigit(CH);CH=getchar())FF=(FF<<1)+(FF<<3)+(CH^48);
	FF*=RR;
}
const int MAXN=5e5+10;
int a[MAXN],L,R,S,n;
struct Line_Tree{
	struct Tree{
		int l,r,lazy;
		bool s[3];
	}t[MAXN<<2];
	void pushup(int num){
		for(int i=1;i<=3;i++)t[num].s[i]=(t[ls].s[i]&&t[rs].s[i]);
	}
	void down1(int num){
		t[num].lazy=1;
		t[num].s[1]=1;
		t[num].s[2]=0;
		t[num].s[3]=0;
	}
	void down2(int num){
		t[num].lazy=2;
		t[num].s[1]=0;
		t[num].s[2]=1;
		t[num].s[3]=0;
	}
	void down3(int num){
		t[num].lazy=3;
		t[num].s[1]=0;
		t[num].s[2]=0;
		t[num].s[3]=1;
	}
	void pushdown(int num){
		if(t[num].lazy==1)down1(ls),down1(rs);
		if(t[num].lazy==2)down2(ls),down2(rs);
		if(t[num].lazy==3)down3(ls),down3(rs);
		t[num].lazy=0;
	}
	void build(int num,int l,int r){
		t[num].l=l;t[num].r=r;t[num].lazy=0;
		if(l==r){
			for(int i=1;i<=3;i++)t[num].s[i]=(a[l]==i);
			return;
		}int mid=(l+r)>>1;
		build(ls,l,mid);
		build(rs,mid+1,r);
		pushup(num);
	}
	void change(int num){
		if(L<=t[num].l&&t[num].r<=R){
			if(S==1)down1(num);
			if(S==2)down2(num);
			if(S==3)down3(num);
			return;
		}pushdown(num);
		if(t[ls].r>=L)change(ls);
		if(t[rs].l<=R)change(rs);
		pushup(num);
	}
	bool query1(int num,int f){
		if(L<=t[num].l&&t[num].r<=R)return t[num].s[f];
		pushdown(num);
		if(t[ls].r<L)return query1(rs,f);
		if(t[rs].l>R)return query1(ls,f);
		return (query1(ls,f)&&query1(rs,f));
	}
	int query2(int num,int S){
		if(t[num].l==t[num].r){
			for(int i=1;i<=3;i++)
				if(t[num].s[i])return i;
		}pushdown(num);
		if(t[ls].r>=S)return query2(ls,S);
		if(t[rs].l<=S)return query2(rs,S);
	}
}T;
int init(){
	read(n);
	for(int i=1;i<=n;i++){
		char ch=getchar();
		for(;ch!='A'&&ch!='B'&&ch!='C';ch=getchar());
		a[i]=ch-64;
	}T.build(1,1,n);
	return 0;
}
int work2(){
	if(L==1||R==n){puts("Yes");return 0;}
	if(T.query2(1,L-1)!=T.query2(1,R+1))puts("Yes");
	else puts("No");
	return 0;
}
int work(){
	char ch=getchar();for(;ch!='A'&&ch!='B';ch=getchar());
	if(ch=='A'){
		read(L);read(R);ch=getchar();for(;ch!='A'&&ch!='B'&&ch!='C';ch=getchar());S=ch-64;
		T.change(1);
	}else{
		read(L);read(R);
		for(int i=1;i<=3;i++)
			if(T.query1(1,i)){work2();return 0;}
		puts("No");
	}
	return 0;
}
int main(){
	init();
	int T;read(T);
	while(T--){work();}
	return 0;
}
```



---

## 作者：critnos (赞：1)

挺板子的。

题意简述：

一只包含 A，B，C 的字符序列，俩操作：

1. 区间推平

2. 判断区间是否全等，且 $a_{l-1}\ne a_{r+1}$（当然如果 $l=1$ 或者 $r=n$ 就不用判断这个条件）。

虽然线段树可以直接维护，但是还是用一种思维难度较小的方法。

先把序列转换，对于三个字母，分别用三个有识别度的大数字代替。

如果怕被卡可以用随机数。

然后线段树维护区间和，区间推平。

对于操作 $2$，令 $ans=\dfrac {\sum_{i=l}^r a_i} {r-l+1}$，说人话即区间 $[l,r]$ 的平均数（线段树基本操作）。不难得知如果 $ans$ 是三个字母对应的数之一那么大概率满足区间全等。

然后对于第二个条件直接单点求值即可。

~~一开始憨憨地维护了异或和~~

---

## 作者：Adove (赞：1)

为什么不试试手写bitset呢QAQ

存在字符`x`对应二进制第`x-'A'`位为1

这样就是线段树维护区间或了

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MAXN=1<<19;
const int siz=3;

int n,m;
char ch[MAXN];
int tag[MAXN<<1],tree[MAXN<<1];

void build(int k,int l,int r)
{
	tag[k]=-1;
	if(l==r){
		tree[k]=1<<(ch[l]-'A');
		return;
	}int i=k<<1,mid=l+r>>1;
	build(i,l,mid);build(i|1,mid+1,r);
	tree[k]=tree[i]|tree[i|1];
	return;
}

void po(int k,int l,int r)
{
	if(l==r||tag[k]==-1) return;
	int i=k<<1;
	tree[i]=tree[i|1]=1<<tag[k];
	tag[i]=tag[i|1]=tag[k];
	tag[k]=-1;
	return;
}

void cchg(int k,int l,int r,int le,int ri,int x)
{
	po(k,l,r);
	if(le<=l&&r<=ri){
		tree[k]=1<<x;
		tag[k]=x;
		return;
	}int i=k<<1,mid=l+r>>1;
	if(le<=mid) cchg(i,l,mid,le,ri,x);
	if(mid<ri) cchg(i|1,mid+1,r,le,ri,x);
	tree[k]=tree[i]|tree[i|1];
	return;
}

int cask(int k,int l,int r,int le,int ri)
{
	po(k,l,r);
	if(le<=l&&r<=ri) return tree[k];
	int ans=0;
	int i=k<<1,mid=l+r>>1;
	if(le<=mid) ans|=cask(i,l,mid,le,ri);
	if(mid<ri) ans|=cask(i|1,mid+1,r,le,ri);
	return ans;
}

int count(int x)
{
	int sum=0;
	while(x) ++sum,x&=x-1;
	return sum;
}

int main()
{
	scanf("%d",&n);
	scanf("%s",ch+1);
	build(1,1,n);
	scanf("%d",&m);
	while(m--){
		char p,c;int l,r;
		scanf("\n%c%d%d",&p,&l,&r);
		if(p=='A'){
			scanf("\n%c",&c);
			cchg(1,1,n,l,r,(int)c-'A');
		}else{
			if(l==1||r==n){
				int ct=cask(1,1,n,l,r);
				if(count(ct)==1) puts("Yes");
				else puts("No");
			}else{
				int ct=cask(1,1,n,l,r),tp1=cask(1,1,n,l-1,l-1),tp2=tp1|cask(1,1,n,r+1,r+1);
				if(count(ct)==1&&count(tp2)==2) puts("Yes");
				else puts("No");
			}
		}
	}return 0;
}
```

---

## 作者：7KByte (赞：1)

（小声bb）这题是真的坑，光做这道题就提交了30+次……  
在做这题之前先仔细阅读题面并理解题意（题目看似简单却暗藏陷阱）


------------
## 步入正题
- 看到是区间查询和区间修改且总长度不变，显然这题最好的解题方法是线段树了
- 线段树不仅可以区间加，区间乘，区间求和，RMQ等，还可以区间修改为同一值和查询区间是否为同一值
- 我们只用对标准线段树进行很小的修改
 - 每个节点的data保留该节点记录的区间情况，如果是纯色则保留颜色，如果是杂色则记录下这个区间是杂色（用0或-1表示）
 - 那么每个叶节点的值为该端点的值，其余节点的值看其子节点的值（相同则传递子节点的值，不同则标记为杂色，子节点中只要有杂色直接标记杂色）
 - 查询的时候就跟标准线段树一样，就是在递归的时候判断一下是否有杂色
 - 修改则比标准线段树更简单，因为是区间全部修改，所以只要这个区间完全包括在目标修改区间内，则直接修改data和tag，下传tag的时候也只用直接修改节点的data和tag
 - 所以每次查询的时候，查询下区间是否为纯色和前后点是否相同，修改的时候之间change就行了
 
 
----------
## 代码部分
```
因为还有字符处理和各种常数优化（初步卡常后时间排行rank5），代码略显冗长
```
```
#include<bits/stdc++.h>
using namespace std;
struct tree{
	int data,tag;
	int l,r;
}a[500000*4];
int k[500005],n;
char f[500005];
void build(int p,int l,int r){
	a[p].l=l;a[p].r=r;a[p].tag=-1;
	if(l==r)
	  a[p].data=k[l];
	else {
		int mid=(l+r)>>1;
		build(p*2,l,mid);
		build(p*2+1,mid+1,r);
		if(a[p*2].data==a[p*2+1].data&&a[p*2].data!=0)
		  a[p].data=a[p*2].data;
		else a[p].data=0;
	}
}
void down(int p){
	if(a[p].l==a[p].r)return;
	a[p*2].data=a[p*2+1].data=a[p].tag;
	a[p*2].tag=a[p*2+1].tag=a[p].tag;
	a[p].tag=-1;
}
int ask(int p,int l,int r){
	if(a[p].l>=l&&a[p].r<=r)
	  return a[p].data;
	if(a[p].tag!=-1)down(p);
	int mid=(a[p].l+a[p].r)>>1;
	int left=-1,right=-1;
	if(mid>=l)left=ask(p*2,l,r);
	if(mid<r)right=ask(p*2+1,l,r);
	if(left==-1)return right;
	if(right==-1)return left;
	if(left==right)return left;
	return 0; 
}
void change(int p,int l,int r,int dat){
	if(a[p].l>=l&&a[p].r<=r){
		a[p].data=a[p].tag=dat;
		return;
	}
	if(a[p].tag!=-1)
	  down(p);
	int mid=(a[p].l+a[p].r)>>1;
	if(mid>=l)change(p*2,l,r,dat);
	if(mid<r)change(p*2+1,l,r,dat);
	if(a[p*2].data==a[p*2+1].data&&a[p*2].data!=0)
		  a[p].data=a[p*2].data;
	else a[p].data=0;
}
inline int read(){
	int X=1,sum=0;char ch=getchar();
	while(ch<'0'||ch>'9')X=(ch=='-'?-1:1),ch=getchar();
	while(ch>='0'&&ch<='9')sum=sum*10+(int)ch-'0',ch=getchar();
	return X*sum;
}
int main(){
	n=read();
	scanf("%s",f);
	for(int i=0;i<n;i++)
	  k[i+1]=(int)f[i]-'A'+1;
	build(1,1,n);
	char t[5],v[5];
	int k,x,y,z;k=read();
	for(int i=1;i<=k;i++){
		scanf("%s",t);
		if(t[0]=='A')
		  {
		  	x=read();y=read();
		  	scanf("%s",v);
		  	z=v[0]-'A'+1;
		  	change(1,x,y,z);
		  }
		else{
			x=read();y=read();
			if(x==1&&y==n){
				puts("Yes");
				continue;
			}
			if(ask(1,x,y)){
			  if(x!=1&&y!=n&&ask(1,x-1,x-1)==ask(1,y+1,y+1)){
			  	puts("No");continue;
			  }
			  	puts("Yes");
			  	continue;
			}
			puts("No");
		}
	}
	return 0;
}
```

---

## 作者：Mobius127 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P4979)

### 题目大意

>给定一个只有三个字符 の 字符串 $S$，两种操作：

>>区间覆盖；

>>查询区间 $[l, r]$ 是否合法，合法的条件为该区间只有一种字符并且 $S_{l-1} \ne S_{r+1}$。

因为只有三种字符，判断条件仅为区间一致以及单点比较。我们考虑用二进制 $1,2,4$ 分别表示这三种字符，那么区间一致的判断就变成了：

>区间 $[l,r]$ 的全体 [或](https://baike.baidu.com/item/%E6%8C%89%E4%BD%8D%E6%88%96/548283?fr=aladdin) 值为 $1,2,4$ 一种，那么整个区间的字符是一致的。

然后直接上线段树就 ok 了。

### Code：

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#define N 500005
using namespace std;
typedef long long ll;
const int INF=0x3f3f3f3f;
inline int read(){
	char ch=getchar();int x=0, f=1;
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
int n, m;
char s[N];
struct Segment_Tree{
	#define ls k<<1
	#define rs k<<1|1
	#define mid (l+r>>1)
	short tag[N*4], col[N*4];
	void pushdown(int k){
		if(!tag[k]) return ;
		tag[ls]=col[ls]=tag[rs]=col[rs]=tag[k];
		tag[k]=0;return ;
	}
	void pushup(int k){col[k]=col[ls]|col[rs];return ;}
	void add(int k, int l, int r, int x, int y, short c){
		if(x<=l&&r<=y){col[k]=tag[k]=c;return ;}pushdown(k);
		if(x<=mid) add(ls, l, mid, x, y, c);
		if(mid<y) add(rs, mid+1, r, x, y, c);
		pushup(k);
	}
	short query(int k, int l, int r, int x, int y){
		if(x<1) return 0;if(y>n) return 8;
		if(x<=l&&r<=y) return col[k];short ret=0;pushdown(k);
		if(x<=mid) ret|=query(ls, l, mid, x, y);
		if(mid<y) ret|=query(rs, mid+1, r, x, y);
		return ret;
	}
	#undef ls
	#undef rs
	#undef mid
}Chtholly;
bool u[80];
signed main(){
	u[1]=u[2]=u[4]=1;
	n=read();scanf("%s", s+1);
	for(int i=1, x; i<=n; i++)
		x=s[i]-'A', Chtholly.add(1, 1, n, i, i, (short)(1<<x));
	m=read();
	for(int i=1; i<=m; i++){
		scanf("%s", s+1);int x=read(), y=read();char op;
		if(s[1]=='A') 
			op=1<<(getchar()-'A'), Chtholly.add(1, 1, n, x, y, op);
		else 
			printf("%s\n", (u[Chtholly.query(1, 1, n, x, y)]&&(Chtholly.query(1, 1, n, x-1, x-1)!=Chtholly.query(1, 1, n, y+1, y+1)))?"Yes":"No");
	}
	return 0;
}

```

为啥窝的线段树辣么慢 QaQ 。

---

## 作者：JJA_ (赞：0)

## 简述题意

给定一串序列 $N$，$N$ 由 $A$ $B$ $C$ 三个字母组成。现在有两个操作：

- $A$：区间推平为 $A$ $B$ 或 $C$

- $B$：查询区间 $l$ $r$ 是否合法。 合法的定义： $N_l=N_{l+1}=N_{l+2}=\dots =N_r$ 且 $N_{l-1} \neq N_{r+1}$ 。

## 思路：

用 $1$ $2$ $3$ 分别代替 $A$ $B$ $C$，之后就是纯粹的线段树模板题了（基本上？）。

所以，对于一开始的序列输入，建树时进行如下操作：
```cpp
tree[i].val=ch[l]-'A'+1;
```

同时也能写出读入函数：
```cpp
inline int read(){
  char c=getchar();
  while(!(c>='0'&&c<='9')){
    if(c=='A'){
      return 1;
    }
    else if(c=='B'){
      return 2;
    }
    else if(c=='C'){
      return 3;
    }
    c=getchar();
  }
}
```
那么线段树维护哪两个信息呢？

我们可以知道，肯定要维护一个懒标记（$lazy$）和每个节点的信息（$val$），那么除此之外还需哪些信息？

我们先考虑查询，查询两端前后时，能用单点查询，但是中间是否一致还需想一下。其实，可以使用它的 $val$ 表示它的颜色。如果左右儿子的颜色相同，用 $val$ 储存左右儿子的颜色，否则存 `-1`。

```cpp
void update(int i){
  tree[i].val=(tree[lc].val==tree[rc].val)?tree[lc].val:-1;
}
```
查询就是利用了 $val$ 的性质，具体看代码实现：

```cpp
int query(int i,int L,int R,int p){
  //单点查询
  if(L==R){
    return tree[i].val;
  }
  push_down(i);
  int mid=L+R>>1;
  if(p<=mid){
    return query(i*2,L,mid,p);
  }
  if(p>mid){
    return query(i*2+1,mid+1,R,p);
  }
}
int check(int i,int L,int R,int l,int r){
  //区间查询
  int ans,pl=MAXN,pr=MAXN;
  if(l<=L&&r>=R){
    return tree[i].val;
  }
  push_down(i);
  int mid=L+R>>1;
  if(l<=mid){
    pl=check(lc,L,mid,l,r);
  }
  if(r>mid){
    pr=check(rc,mid+1,R,l,r);
  }
  if(pl==MAXN||pr==MAXN){
    return (pl==MAXN)?pr:pl;
  }
  if(pl!=MAXN&&pr!=MAXN){
    return (pl==pr)?pl:-1;
  }
}
```

所以，区间推平就是更改了它的信息和懒标签。

```cpp
//推平
void change(int i,int L,int R,int l,int r,int p){
  if(l<=L&&r>=R){
    tree[i].val=tree[i].lazy=p;
    return;
  }
  int mid=L+R>>1;
  push_down(i);
  if(l<=mid){
    change(lc,L,mid,l,r,p);
  }
  if(r>mid){
    change(rc,mid+1,R,l,r,p);
  }
  update(i);
}
```

那下传标签就很好理解了，左右儿子的价值和懒标签都是父节点的懒标签，而父节点的懒标签记得清零。

```cpp
void push_down(int i){
  if(tree[i].lazy){
    tree[lc].val=tree[rc].val=tree[lc].lazy=tree[rc].lazy=tree[i].lazy;
    tree[i].lazy=0;
  }
}
```
所以主函数应该很好理解，也能看到 `read()` 函数的使用：

```cpp
int n,k;
signed main(){
  scanf("%d",&n);
  scanf("%s",ch+1);
  build(1,1,n);
  scanf("%d",&k);
  forr(i,1,k){
    cout<<i<<'\n';
    int opt,l,r,x;
    opt=read();
    scanf("%d%d",&l,&r);
    switch(opt){
      case 1:{
        x=read();
        change(1,1,n,l,r,x);
        break;
      }
      case 2:{
        int ql=-2,qr=-2;
        ql=(l==1)?0:query(1,1,n,l-1);
        qr=(r==n)?0:query(1,1,n,r+1);
        int tot=check(1,1,n,l,r);
        if((ql==qr&&ql&&qr)){
          puts("No");
        }
        else{
          int ans=check(1,1,n,l,r);
          if(ans<0){
            puts("No");
          }
          else puts("Yes");
        }
        break;
      }
    }
  }
}
```

完整源代码的链接 : [link](https://www.luogu.com.cn/blog/352464/xuan-zhuan-shou-xing-su-jin-2-ge) ~~同时宣传首行缩进两格~~。

---

## 作者：Mr_think (赞：0)

## [P4979 矿洞：坍塌](https://www.luogu.com.cn/problem/P4979)

## 题目大意：
一个区间有若干颜色，有两个操作：

A. 将该区间从 `x` 到 `y` 变成 `k` 色。

B. 询问区间 `x` 到 `y` 是否合法。

- 合法定义为该区间颜色均相同且 `x-1` 的颜色与 `y+1` 的颜色不相同。若 `x=1` 或 `y=N` 时不用判断后者。

## solution:
区间修改，区间查询，我们考虑使用线段树。

线段树的每个节点保存如下信息：
```cpp
struct shu{
	int l,  //区间左端点
	r,    //区间右端点
	se,    /区间颜色，若不相同为-1
	tag;  //懒标记，代表要变成的颜色，初始为-1
}tr[N<<2];
```
颜色：这里我将 `A` `B` `C` 分别映射成三个数字 `1` `2` `3` 

区间修改：若 `x` `y` 包含访问到的区间，则将此区间变成该颜色，并把懒标记赋值。

区间查询：若 `x` `y` 包含访问到的区间，则返回该颜色，否则递归进左右子树，合并信息：

1. 若 询问区间不包含左区间，返回右区间的颜色。同理不包含右则返回左。
2. 如果左右区间有一个是混色或者左右区间颜色不同返回 `-1` 。
3. 如果左右区间颜色相同，返回该颜色。

别忘了以上操作都要 `pushdown` 将信息传下去。
## 接下来是细节的处理：
判断要格外小心。 $\text{Yes}$ 要满足两个条件：
1. 区间颜色相同。
2. `x==1` 、 `y==n` 、 `x-1` 的颜色与 `y+1` 颜色不同，三者满足其一。

否则是 $\text{No}$ 。

PS：注意 **Yes**、**No**的大小写。

看到这的同学，可以自己去写代码了(~~tf口吻~~)

[code](https://www.luogu.com.cn/paste/1ut3788r)
### End
## 作者的碎碎念：

有用留赞(~~言简意赅~~)

---

## 作者：吾王美如画 (赞：0)

# 唔姆

这可真是道毒瘤题，1k的提交居然只有35人ac！惊悚。。。（我才不会告诉你们这题有坑，因为我自己就提交了n多遍）

------------
- 首先，这题明显是道线段树。（当然各位大佬的神仙算法自然是可以的）
- 然后在ans（明显是直接改模板的）里面，如果都是一种矿的话，我们就把矿的种类存下来。如果不一样的话就存-1。
- 赋值的时候就直接改就好了。QAQ
- 主要是down的时候，如果这里的tag是-1的话，就不要再往下传了，不然最后会全变成-1的QAQ
- 查询的话先判断区间里的是不是都相同，然后再看前后是否相同。当x=1或者y=N时就可以不用判后面的了，但区间里还是要判的！！！~~我还是说出来了啊，感觉自己被坑的好亏~~

蒟蒻代码巨丑，请大佬们见谅
```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<iostream>
#include<cstring>
#define maxn 500010
using namespace std;
int ans[4*maxn],tag[4*maxn],x[maxn];
int n,k;
int ls(int p){
    return p*2;
}
int rs(int p){
    return p*2+1;
}
void up(int p){
     if ((ans[ls(p)]==ans[rs(p)])&&(ans[ls(p)]!=-1)) ans[p]=ans[ls(p)];else ans[p]=-1;
}
void down(int p){
     tag[ls(p)]=tag[p];
     tag[rs(p)]=tag[p];
     ans[ls(p)]=tag[p];
     ans[rs(p)]=tag[p];
     tag[p]=-1;
}
void build(int p,int l,int r){
     ans[p]=-1;tag[p]=-1;
     if (l==r) {ans[p]=x[l];return;};
     int mid=(l+r)/2;
     build(p*2,l,mid);
     build(p*2+1,mid+1,r);
     up(p);
}
void fz(int p,int l,int r,int a,int b,char c){
     if ((l>=a)&&(r<=b)){ans[p]=c;
                         tag[p]=c;
                         return;
                         }
     if (tag[p]!=-1)down(p);
     int mid=(l+r)/2;
     if (a<=mid) fz(ls(p),l,mid,a,b,c);
     if (b>mid) fz(rs(p),mid+1,r,a,b,c);
     up(p);
}
int search(int p,int l,int r,int a,int b){
      if ((l>=a)&&(r<=b))return ans[p];
      if (tag[p]!=-1) down(p);
      int mid=(l+r)/2;
      int x=-2,y=-2;
      if (a<=mid) x=search(ls(p),l,mid,a,b);
      if (b>mid) y=search(rs(p),mid+1,r,a,b);
      if ((x==-2)||(y==-2)) return max(x,y);
      else if((x==y)&&(x!=-1)) return x;
      else return -1;
}
int main(){
    //freopen("测试.in","r",stdin);
    //freopen("测试my.out","w",stdout);
    cin>>n;
    getchar();getchar();
    for(int i=1;i<=n;i++){
            x[i]=getchar()-'A';
    }
    build(1,1,n);
    cin>>k;
    int a,b;
    char c;
    for(int i=1;i<=k;i++){
            char ch;
            cin>>ch;
            if (ch=='A') {scanf("%d%d",&a,&b);
                          cin>>c;
                          c-='A';
                          fz(1,1,n,a,b,c);
                          }
            else {scanf("%d%d",&a,&b);
                  if((search(1,1,n,a,b)!=-1)&&(a==1||b==n||search(1,1,n,a-1,a-1)!=search(1,1,n,b+1,b+1))) printf("Yes\n");else printf("No\n");
            }
    }
    return 0;
}

```
ps：记得吸氧，不然卡常。

pps：还有一个坑，泥萌会在我代码里看到的QAQ~~反正我代码写的丑，没人看得懂~~

---


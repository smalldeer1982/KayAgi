# 【模板】扫描线 & 矩形面积并

## 题目描述

求 $n$ 个四边平行于坐标轴的矩形的面积并。

## 说明/提示

对于 $20\%$ 的数据，$1 \le n \le 1000$。  
对于 $100\%$ 的数据，$1 \le n \le {10}^5$，$0 \le x_1 < x_2 \le {10}^9$，$0 \le y_1 < y_2 \le {10}^9$。

Updated on 4.10 by Dengduck（口胡） \& yummy（实现）：增加了一组数据。

## 样例 #1

### 输入

```
2
100 100 200 200
150 150 250 255
```

### 输出

```
18000
```

# 题解

## 作者：NCC79601 (赞：1209)

# 扫描线
扫描线是一种求矩形面积并/周长并的好方法。~~**听说今年考到的概率还比较大（逃**~~

\[2020.03.23\] **更新：** CSP-S 2019并没有考到扫描线，脸好疼…

---

**扫描线**：假设有一条扫描线从一个图形的下方扫向上方（或者左方扫到右方），那么通过分析扫描线被图形截得的线段就能获得所要的结果。该过程可以用**线段树**进行加速。

# 面积并
**例题** [P5490](https://www.luogu.org/problem/P5490) / [POJ 1151](http://poj.org/problem?id=1151)

这两道题都是求**面积并**。

由于都是矩形，因此运用扫描线以后，面积的求法其实可以简化为 $\sum$截线段长度$\times$扫过的高度。这也是扫描线算法最基础的应用。

考虑以下这个简单的例子。

![image.png](https://img.ffis.me/images/2019/08/10/image.png)

问题在于如何才能模拟扫描线从下向上扫过图形，并且快速计算出当前扫描线被截得的长度。

现在假设，扫描线每次会在碰到横边的时候停下来，如图。

![image1cba39d5beb42edc.png](https://img.ffis.me/images/2019/08/10/image1cba39d5beb42edc.png)

简单来说，可对图形面积产生影响的元素，也就是这些横边左右端点的坐标。

为了快速计算出截线段长度，可以将横边赋上不同的权值，具体为：对于一个矩形，其下边权值为$1$，上边权值为$-1$。

![image805e198e60891448.png](https://img.ffis.me/images/2019/08/10/image805e198e60891448.png)

然后把所有的横边按照$y$坐标升序排序。这样，对于每个矩形，扫描线总是会**先碰到下边，然后再碰到上边**。那么就能保证扫描线所截的长度永远非负了。

这样操作以后，就可以和线段树扯上关系。先把所有端点在$x$轴上离散化（其实就是把所有点的横坐标存到$X[]$里，然后升序排个序，最后去重）。

![imagec6ca891e8480bea8.png](https://img.ffis.me/images/2019/08/10/imagec6ca891e8480bea8.png)

在这个例子中，$4$个端点的纵投影总共把$x$轴切割成了$5$部分。取中间的$3$部分线段，建立一棵线段树，其每个端点维护**一条线段**（也就是一个区间）的信息：
1. 该线段被覆盖了多少次（被多少个矩形所覆盖）。
2. 该线段内被整个图形所截的长度是多少。

![image0a03aa15aca4877e.png](https://img.ffis.me/images/2019/08/10/image0a03aa15aca4877e.png)

显然，只要一条线段被覆盖，那么它肯定被图形所截。所以，整个问题就转化为了一个**区间查询问题**，即：每次将 当前扫描线扫到的边 对应的信息 按照之前赋上的权值更新，然后再查询线段树根节点的信息，最后得到当前扫描线扫过的面积。这就可以用线段树来实现了（毕竟人家叫 **“线段”** 树嘛）。

### 下面是模拟的过程：

![imaged818935608ff1757.png](https://img.ffis.me/images/2019/08/10/imaged818935608ff1757.png)

![image65ecdba6bd78c3ce.png](https://img.ffis.me/images/2019/08/10/image65ecdba6bd78c3ce.png)

注：上图的$5$号节点的$sum=2$，绿色部分表示已计算的面积。

![image8f0d94e5f164aef1.png](https://img.ffis.me/images/2019/08/10/image8f0d94e5f164aef1.png)

![image82b25ef8956c45ad.png](https://img.ffis.me/images/2019/08/15/image.png)

还剩下一个棘手的问题：线段树到底该怎么建？保存什么信息？怎么在节点间传递信息？

这里我使用自己最习惯的线段树写法，个人感觉这样的逻辑最清晰。

先看下面的建树过程：
```cpp
void build_tree(int x, int l, int r) {
//	初始化节点信息
	if(l == r)
		return;
	int mid = (l + r) >> 1;
	build_tree(lson, l, mid);
	build_tree(rson, mid + 1, r);
	return;
}
```
我们已经知道，这棵线段树的每个节点都对应了一条线段。考虑将线段树上节点对应的区间和横边建立**映射关系**。先看对于一个叶子节点$x$，建树时保证了$tree[x].l=tree[x].r$，但其保存的信息很显然不可能只是某条线段的一个端点（如果一条线段的两个端点重合，那么它实质上仅是一个点）。再看一个节点的左右儿子，同样地，建树的时候已经保证了左右儿子的区间不会重合（交集为空），但是看这样两条相邻线段：$[1,2],[2,3],$你会发现$[1,2]\cap[2,3]=\{2\}$，也就是说左儿子的右端点和右儿子的左端点其实是重合的。所以如果想得太简单，就gg了。

考虑把线段树每个节点$x$对应的区间（$tree[x].l,tree[x].r$）不变，改变区间和横边的映射关系，具体为：节点$x$对应$[X[tree[x].l],\,X[tree[x].r+1]]$这条横边。可以看到，这里~~很机智地~~把右端点的对应关系给改了下，于是就兼容了。

自我感觉代码已经足够清晰了，注释还有其它解释。

**注意一下：** 变量名“$y1$”在<cmath>库里头有定义，会冲突，所以不开bits库就好。

### 这道题的代码：
```cpp
//  code for P5490
//  代码没有挖坑
#include <stdio.h>
#include <iostream>
#include <algorithm>
#define lson (x << 1)
#define rson (x << 1 | 1)
using namespace std;
const int MAXN = 1e6 + 10;
typedef long long ll;

int n, cnt = 0;
ll x1, y1, x2, y2, X[MAXN << 1];

struct ScanLine {
	ll l, r, h;
	int mark;
//  mark用于保存权值 (1 / -1)
	bool operator < (const ScanLine &rhs) const {
		return h < rhs.h;
	}
} line[MAXN << 1];

struct SegTree {
	int l, r, sum;
	ll len;
//  sum: 被完全覆盖的次数；
//  len: 区间内被截的长度。
} tree[MAXN << 2];

void build_tree(int x, int l, int r) {
//  我觉得最不容易写错的一种建树方法
	tree[x].l = l, tree[x].r = r;
	tree[x].len = 0;
	tree[x].sum = 0;
	if(l == r)
		return;
	int mid = (l + r) >> 1;
	build_tree(lson, l, mid);
	build_tree(rson, mid + 1, r);
	return;
}

void pushup(int x) {
	int l = tree[x].l, r = tree[x].r;
	if(tree[x].sum /* 也就是说被覆盖过 */ )
		tree[x].len = X[r + 1] - X[l];
//      更新长度        
	else
		tree[x].len = tree[lson].len + tree[rson].len;
//      合并儿子信息
}

void edit_tree(int x, ll L, ll R, int c) {
	int l = tree[x].l, r = tree[x].r;
//  注意，l、r和L、R的意义完全不同
//  l、r表示这个节点管辖的下标范围
//  而L、R则表示需要修改的真实区间
	if(X[r + 1] <= L || R <= X[l])
		return;
//  这里加等号的原因：
//  假设现在考虑 [2,5], [5,8] 两条线段，要修改 [1,5] 区间的sum
//  很明显，虽然5在这个区间内，[5,8] 却并不是我们希望修改的线段
//  所以总结一下，就加上了等号
	if(L <= X[l] && X[r + 1] <= R) {
		tree[x].sum += c;
		pushup(x);
		return;
	}
	edit_tree(lson, L, R, c);
	edit_tree(rson, L, R, c);
	pushup(x);
}

int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) {
		scanf("%lli %lli %lli %lli", &x1, &y1, &x2, &y2);
		X[2 * i - 1] = x1, X[2 * i] = x2;
		line[2 * i - 1] = (ScanLine) {x1, x2, y1, 1};
		line[2 * i] = (ScanLine) {x1, x2, y2, -1};
//      一条线段含两个端点，一个矩形的上下边都需要扫描线扫过
	}
	n <<= 1;
//  直接把 n <<= 1 方便操作
	sort(line + 1, line + n + 1);
	sort(X + 1, X + n + 1);
	int tot = unique(X + 1, X + n + 1) - X - 1;
//  去重最简单的方法：使用unique！（在<algorithm>库中）
	build_tree(1, 1, tot - 1);
//  为什么是 tot - 1 ：
//  因为右端点的对应关系已经被篡改了嘛…
//  [1, tot - 1]描述的就是[X[1], X[tot]]
	ll ans = 0;
	for(int i = 1; i < n /* 最后一条边是不用管的 */ ; i++) {
		edit_tree(1, line[i].l, line[i].r, line[i].mark);
//      先把扫描线信息导入线段树
		ans += tree[1].len * (line[i + 1].h - line[i].h);
//      然后统计面积
	}
	printf("%lli", ans);
	return 0;
}
```

---

### POJ 1151的话…
把P5490代码改一改就过了，所以就不放了。

---
# 周长并
                        
**例题** [POJ 1177](http://poj.org/problem?id=1177)
                        
周长并比面积并还要麻烦些 ~~（画图也要麻烦些，所以我就偷懒了）~~，我直接拿POJ 1177的样例来举例子：

![imaged3ade113f8ed97a4.png](https://img.ffis.me/images/2019/08/10/imaged3ade113f8ed97a4.png)

观察这三条扫描线扫过的纵边，你会发现它比较变幻莫测，总结一下显然有这样一个有趣的现象：纵边总长度$=\sum2\times$被截得的线段条数$\times$扫过的高度。

再看这个：

![image875b5bc59b29c404.png](https://img.ffis.me/images/2019/08/10/image875b5bc59b29c404.png)

事情就更加 ~~恶心~~ 有趣了，你会发现横边总长度$=\sum|$上次截得的总长$-$现在截得的总长$|$。

所以和面积并比起来，周长并中的线段树还要维护 **线段的条数**。另外，横边和纵边需分别计算。

剩余的代码注释有讲。

```cpp
#include <iostream>
#include <stdio.h>
#include <algorithm>
#define lson (x << 1)
#define rson (x << 1 | 1)
using namespace std;
const int MAXN = 2e4;
int n, X[MAXN << 1];
int x1, y1, x2, y2, pre = 0; /* 先初始化为 0 */

struct ScanLine {
	int l, r, h, mark;
	if(h == rhs.h)
		return mark > rhs.mark;
    return h < rhs.h;
//		注意！这里是后来被 hack 掉以后加上去的
//		在此感谢 @leprechaun_kdl 指出问题
//		如果出现了两条高度相同的扫描线，也就是两矩形相邻
//		那么需要先扫底边再扫顶边，否则就会多算这条边
//		这个对面积并无影响但对周长并有影响
//		hack 数据：2 0 0 4 4 0 4 4 8 输出应为：24
} line[MAXN];

struct SegTree {
	int l, r, sum, len, c;
//  c表示区间线段条数
    bool lc, rc;
//  lc, rc分别表示左、右端点是否被覆盖
//  统计线段条数(tree[x].c)会用到
} tree[MAXN << 2];

void build_tree(int x, int l, int r) {
	tree[x].l = l, tree[x].r = r;
	tree[x].lc = tree[x].rc = false;
	tree[x].sum = tree[x].len = 0;
	tree[x].c = 0;
	if(l == r)
		return;
	int mid = (l + r) >> 1;
	build_tree(lson, l, mid);
	build_tree(rson, mid + 1, r);
}

void pushup(int x) {
	int l = tree[x].l, r = tree[x].r;
	if(tree[x].sum) {
		tree[x].len = X[r + 1] - X[l];
		tree[x].lc = tree[x].rc = true;
		tree[x].c = 1;
//      做好相应的标记
	}
	else {
		tree[x].len = tree[lson].len + tree[rson].len;
		tree[x].lc = tree[lson].lc, tree[x].rc = tree[rson].rc;
		tree[x].c = tree[lson].c + tree[rson].c;
//      如果左儿子左端点被覆盖，那么自己的左端点也肯定被覆盖；右儿子同理
		if(tree[lson].rc && tree[rson].lc)
			tree[x].c -= 1;
//      如果做儿子右端点和右儿子左端点都被覆盖，
//      那么中间就是连续的一段，所以要 -= 1
	}
}

void edit_tree(int x, int L, int R, int c) {
	int l = tree[x].l, r = tree[x].r;
	if(X[l] >= R || X[r + 1] <= L)
		return;
	if(L <= X[l] && X[r + 1] <= R) {
		tree[x].sum += c;
		pushup(x);
		return;
	}
	edit_tree(lson, L, R, c);
	edit_tree(rson, L, R, c);
	pushup(x);
}

ScanLine make_line(int l, int r, int h, int mark) {
	ScanLine res;
	res.l = l, res.r = r,
	res.h = h, res.mark = mark;
	return res;
}
//  POJ 不这样做就会CE，很难受

int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) {
		scanf("%d %d %d %d", &x1, &y1, &x2, &y2);
		line[i * 2 - 1] = make_line(x1, x2, y1, 1);
		line[i * 2] = make_line(x1, x2, y2, -1);
		X[i * 2 - 1] = x1, X[i * 2] = x2;
	}
	n <<= 1;
	sort(line + 1, line + n + 1);
	sort(X + 1, X + n + 1);
	int tot = unique(X + 1, X + n + 1) - X - 1;
	build_tree(1, 1, tot - 1);
	int res = 0;
	for(int i = 1; i < n; i++) {
		edit_tree(1, line[i].l, line[i].r, line[i].mark);
		res += abs(pre - tree[1].len);
		pre = tree[1].len;
//      统计横边
		res += 2 * tree[1].c * (line[i + 1].h - line[i].h);
//      统计纵边
	}
	res += line[n].r - line[n].l;
//  特判一下枚举不到的最后一条扫描线
	printf("%d", res);
	return 0;
}
```
我觉得自己讲得够清晰了 (=$\small\triangledown$=)

---

## 作者：Gu_Pigeon (赞：351)

本题解主要是为了想要学习扫描线算法的同学准备的。

在开始学习本算法前，你需要会：

- ## [线段树](https://www.luogu.org/blog/pks-LOVING/senior-data-structure-qian-tan-xian-duan-shu-segment-tree)

- ## [离散化](https://www.jianshu.com/p/9347659dcf18)

没了……

# 切入正题

本题给出了n个矩形，求出它们在平面上覆盖的面积。

然后我们开始思考……

首先，$0\le$x1,x2,y1,y2$\le10^{9}$，一看就知道可以通过离散化来缩小范围。

于是 $0\sim 10^{9}\Rightarrow1\sim 10^{5}$, 爽。

所以然后咋办？？？

# 1. 暴力for循环？

~~憋想了，MLE+TLE~~

# 2. 容斥定理？

~~没学过没关系，反正是错的~~

把所有的矩形面积相加，然后减去重叠部分？

~~憋想了，烦死你~~

### 那咋办

**（敲黑板）正解来啦！！！**

# 3. 分割图形？

比如……

![酱紫](https://cdn.luogu.com.cn/upload/pic/70275.png)

好像可行！

but具体怎么操作呢？

看到最后一步图片的虚线了吗？

所以……

是不是有一点想法了呢？

然后我们再来模拟一波……

![酱紫](https://s2.ax1x.com/2019/08/08/eTuDjP.gif)

答案是不是呼之欲出了呢！

**我们记录每一条竖直方向上的线段（一个含x坐标，上端y坐标y1，下端y坐标y2，加减的标记k的四元组(x,y1,y2,k)）然后离散化(得到离散化后的值val(y)，离散化值对应的y值raw(i))，按照x坐标进行排序；**

变成这样↓

![如此](https://cdn.luogu.com.cn/upload/pic/70291.png)

然后维护扫描线上被覆盖的长度就好了！！！

最后……如何维护这条扫描线呢？

### 线段树横空出世！

每次修改之后，更新线段树中节点的len(被覆盖的长度)

相信会线段树的同学都能独立完成~~所以就不贴代码了~~

**至此，本题已经 基本上 解决了！**

为什么说是基本上呢？当然是还有优化啦~

（这才是你上面不贴代码的原因吧！！！）

（好好好下面我绝对贴……）

区间修改的延时标记太麻烦了……~~算了不写了~~

且慢！这题还有不用延时标记的优化！

### 话说延时标记……

是一种 使区间修改不用全部下传至叶子节点，在查询**子节点的值**时才下传，从而保证在$O\left( \log n\right)$的时间内完成操作的方法……

查询子节点的值？？？

我们不是只查询全图最低点到最高点的值，也就是，根节点的值吗？

那管儿子节点的事干嘛，~~让他们自生自灭得了~~

于是，我们想到，除左右端点`l,r`之外，在线段树的每个节点上维护两个值：该节点代表的区间被矩形覆盖的长度len，该节点自身被覆盖的次数cnt。最初，二者均为0.

_对于每一个`(x,y1,y2,k)`，我们再`[val(y1),val(y2)-1]`上执行期间修改。该区间被线段树划分成 $\log n$个节点，我们把这些节点的cnt都加k。_

 _对于线段树中任意一个节点 `[l,r]` ，若`cnt>0`，则`len`等于`raw(r+1)-raw(l)`,否则，该店`len`等于两个子节点的`len`之和。在一个节点的`cnt`被修改，以及线段树从下往上传递信息时，我们都按照该方法更新`len`值。根节点的`len`值就是整个扫描线上被覆盖的长度_ 
 
——from 《算法竞赛进阶指南》

到这里这篇题解也就完美结束了……

~~是不是忘了些什么~~

# code time:


```cpp
#include<bits/stdc++.h> 
using namespace std;
#define ls (rt << 1)//左儿子
#define rs (rt << 1 | 1)//右儿子
#define int long long
int n, x_, x__, y_, y__, x, y, rk[2097152], val[2097152], cnt, maxn = 1 << 31;

//注意：用万能库的同学千万不要以x1,x2,y1,y2作为变量名!!!!!!
//maxn是为了保证不会去理左右端点 

struct Segment_tree
{
	int l, r;//区间左右端点
	int cnt, len;//如上所述
}t[2097152];

struct node
{
	int x, yh, yl, flag;
}e[2097152];//记录每一条竖线

void pushup(int rt)
{
	if ((t[rt].l == maxn && t[rt].r == maxn)) return;
	if (t[rt].cnt) t[rt].len = val[t[rt].r + 1] - val[t[rt].l];
	else t[rt].len = t[ls].len + t[rs].len;
}//向上更新节点

void build(int rt, int l, int r)
{
	t[rt].l = l, t[rt].r = r;
	if (l == r) return;
	int mid = (t[rt].l + t[rt].r) >> 1;
	build(ls, l, mid);
	build(rs, mid + 1, r);
}

void add(int rt, int l, int r, int v)
{
	if (l <= t[rt].l && t[rt].r <= r)
	{
		t[rt].cnt += v;
		pushup(rt);
		return;
	}
	int mid = (t[rt].l + t[rt].r) >> 1;
	if (l <= mid) add(ls, l, r, v);
	if (mid < r) add(rs, l, r, v);
	pushup(rt);
}//基本操作，不再赘述

bool cmp(node a, node b)
{
	if (a.x != b.x) return a.x < b.x;
	return a.flag > b.flag;
}

signed main()
{
	cin >> n;
	int ans = 0;
	for (int i = 1; i <= n; i++)
	{
		scanf("%lld%lld%lld%lld", &x_, &y_, &x__, &y__);
		e[(i << 1) - 1].x = x_, e[i << 1].x = x__;
		e[(i << 1) - 1].yh = e[i << 1].yh = y__;
		e[(i << 1) - 1].yl = e[i << 1].yl = y_;
		e[(i << 1) - 1].flag = 1, e[i << 1].flag = -1;//flag表示该边是矩形的左边界或右边界
		rk[++cnt] = y_; 
		rk[++cnt] = y__;//存入一个数组，准备离散化
	}
	sort(rk + 1, rk + (n << 1) + 1);//排序
	cnt = unique(rk + 1, rk + (n << 1) + 1) - rk - 1;//去重
	for (int i = 1; i <= 2 * n; i++)
	{
		int pos1 = lower_bound(rk + 1, rk + cnt + 1, e[i].yh) - rk;
		int pos2 = lower_bound(rk + 1, rk + cnt + 1, e[i].yl) - rk;//在数组中二分查找位置
		val[pos1] = e[i].yh;
		val[pos2] = e[i].yl;//即为上文的raw数组
		e[i].yh = pos1; maxn = max(maxn, pos1);
		e[i].yl = pos2;
	}
	sort(e + 1, e + 2 * n + 1, cmp);//按照x坐标
	build(1, 1, n << 1);
	for (int i = 1; i < n << 1; i++)
	{
		add(1, e[i].yl, e[i].yh - 1, e[i].flag);//区间加flag
		ans += t[1].len * (e[i + 1].x - e[i].x);//根节点的len值*与下一条线段的距离=这一块内的矩形面积
	}
	cout << ans << endl;//得到最终答案,AC!
	return 0;
}
```

[$ \Huge\textsf{\textbf{\color{white}好 康 的}}$ ](https://magcius.github.io/xplain/article/regions.html)

---

## 作者：dzz1537568241 (赞：195)

这是一篇扫描线的题解....

本文包括：

1. 离散化在线段树上的应用

1. 手把手的建立扫描线

1. 代码的具体分析


------------

在开始之前，你必须熟练掌握

- 离散化

- 线段树

检测离散化孰不熟练的方式有[P1955](https://www.luogu.org/problem/P1955)

离散化真的很重要，当时作为一个什么离散化都不懂的萌新读扫描线的代码真的什么都看不懂

# 1. 离散化

在进行扫描线之前必须要普及离散化的概念和意义

首先什么是离散化？我们为什么要离散化？

离散化是把一系列数字，按照从小到大的顺序排列后，能够快速找到这个数组第k大的数字，这就是所谓离散化

（如果你发现与定义不同，没关系，我只是直接从代码出发而已）

分析一下：你要找到一个数组中第k大的数字，该怎么办？

我们的思路是**直接通过下标访问**：

举个栗子，如果要访问第k大的数，最简单粗暴的访问方式就是a[k]，那么为了实现这个目标，我们有以下操作：

1. 目标：直接访问下标来达到访问第k大的数，那么需要先把a数组排一遍序

1. 排序后，数组内不能含有重复元素，因此需要去除重复元素。

就两步操作就能完成离散化。

写出伪代码：

```cpp
//对 a 数组的元素进行离散化操作，以保证能快速访问到 a 数组中第 k 大的数 
int a[maxn];
将 a 数组 进行排序
去除 a 数组 的重复的元素
```
- STL的去重函数是 unique ( 数组头指针，数组尾指针）

	返回值是被去重之后的数组的尾指针

	特别需要注意的是unique只对排过序的数组生效

代码：

```cpp
//对 a 数组的元素进行离散化操作，以保证能快速访问到 a 数组中第 k 大的数 
#include <algorithm>
int a[maxn], tail;//tail是 a 数组的尾指针 
sort(a + 1, a + 1 + tail);
tail = unique(a + 1, a + 1 + tail) - (a + 1);//对a数组去重，并且更新a数组的尾指针 
```
## 离散化后的数组的访问操作：

- 访问一个元素在a数组的位置：
```cpp
	lower_bound(a + 1, a + 1 + tail) - a; 
```
- 访问a数组第k个元素的值：

```cpp
	a[k]
```


------------

# 2. 用一维的数据结构维护二维信息

扫描线真的不难，只要用点心，是绝对学的会的

嗯如果你需要看演示，这里有一个很好的[扫描线演示](https://www.luogu.org/blog/36908/solution-p5490)

感谢@Gu_Pigeon 的题解

在这里我给你做的是 分析代码 和 代码实现，演示就看上面的链接就吼了

- 分析题目：这是一个求出矩形的并集的面积的问题，可以理解为			某一个区间并集， 区间操作很容易想到什么？对，线段树

- 线段树三连：

1. 线段树维护什么

1. 怎么修改区间的值

1. 怎么维护父节点

- 事实上，一个线段树**能够维护的是一个区间**，你可以想象成一根数轴。问题来了：怎么在一个 只能够维护 **一根线段上的点的信息** 的数据结构上 处理一个**二维平面上的信息**？

吼吼，这个时候就需要请出扫描线大神了

虽然线段树只能维护一维的信息，但是线段树支持 **加点删点** 的 操作啊！

那我们每次把一维的信息加进去之后进行维护不就好了嘛

什么意思呢？

（感谢@Gu_Pigeon提供的图片，侵权立删）


![扫描](https://s2.ax1x.com/2019/08/08/eTuDjP.gif)

线段树维护的是 y 轴上的长度，然后每一次“加入一维的信息”的意思是在 每一次加入进去的是 **垂直于 某一个x轴上的点 的信息**，画图示意一下 ~~（有点丑）~~

![saomiaoxian](https://cdn.luogu.com.cn/upload/image_hosting/5dy4e91n.png)



------------

想象一根线段垂直于x轴，向x轴正半轴一点一点往右移动，

当遇到一条垂直x轴的矩形的边的时候，就将**这个矩形边上的所有信息加入线段树**

写出伪代码：
```cpp
for (遍历x轴上所有的点){
	if(垂直于这个x轴上的线段上 有矩形的 点){
		将处于这条线段上的所有点的信息全部加入线段树 
	} 
}
```
这样就可以让线段树 **维护 二维信息** 了


# 3. 线段树

看题，要求 **求出所有的矩形的并集 的覆盖的面积**

对比一下刚刚扫描线完成的操作：

```cpp
for (遍历x轴上所有的点){
	if(垂直于这个x轴上的线段上 有矩形的 点){
		将处于这条线段上的所有点的信息全部加入线段树 
	} 
}
```

- 思考一下线段树里维护的是什么：

- 想像一下.....一条线段往右扫，一旦发现了矩形竖直的一条边，那么就把这条边的信息加入线段树，再用一次这张图

![扫描](https://s2.ax1x.com/2019/08/08/eTuDjP.gif)

举个例子，如下图
![扫描线222](https://cdn.luogu.com.cn/upload/image_hosting/9yyo51uo.png)


如果	扫到x = k1的时候，x = k1 处的线段的信息被加入线段树，当扫到 x = k2 处的时候，发现 **要维护 [ k1, k2 ] 处区间的面积**，那怎么办呢？

很简单，S =  （ x = k1 处的线段长度） * （ k1 - k2 ）

- 那线段树上该维护点啥？

当然是维护 x = k1处的线段长度喽

改进一下之前的伪代码：
```cpp
for (遍历x轴上所有的点){ 
	if(该条直线 k1 上 存在矩形 一条边 ){
		//线段树上用来维护边的长度 
		更新线段树上的边的长度 
		面积 =  （ k1 - 上一个矩形的边 横坐标） * 线段树上的边的长度 
	} 
}
```

# 4.读入扫描线

我们需要 **存储 每一段的扫描线**，看图，每一段扫描线只需要三个参量：

- x 轴坐标

- 矩形 y 坐标的上界

- 矩形 y 坐标的下界

而当我们遍历的时候，只需要将 x 轴坐标进行从左到右的一遍排序即可，写出伪代码：
```cpp
struct Scanline{
	int x, y1, y2;
}scanline[ maxn ];

int main(){
	for(输入操作){
		读入矩形的四个坐标x1, y1, x2, y2
		scanline 加入(x1, y1, y2);
		scanline 加入(x2, y1, y2); 
	}
	
	将扫描线按照x轴的坐标从小到大排序 
	
	for (遍历所有的扫描线){ 
		//线段树上用来维护边的长度 
		更新线段树上的边的长度 
		面积 =  （ k1 - 上一个矩形的边 横坐标） * 线段树上的边的长度 
		
	}
} 
```
现在只剩下怎么维护线段树了，~~胜利在望~~

已经可以确定线段树**必须要维护的值有：**

- 线段 y 坐标的上界 和 下界

- 该区间内线段的总长度

即
```cpp
struct segment_tree{
	int l, r, len;
	//l:y坐标的上界
	//r:y坐标的下界
    	//len:当前区间内线段的总长度
}st[ maxn ];
```

同时，这个线段树应该支持

- 删除操作
	（加入线段之后再更新完这块面积之后得删去之前加进来的线段）		

- 支持求出当前线段总长度


# 求出线段总长度

其实就是怎么用子区间去**更新父节点**，没什么难度，写出伪代码：

```cpp
struct segment_tree{
	int l, r, len;
	//l:y坐标的上界
	//r:y坐标的下界
    	//len:当前区间内线段的总长度
}st[ maxn ];

void pushup(int o){
	st[o].len = st[o << 1].len + st[o << 1| 1].len;
	//父节点的区间值 = 子区间的长度之和 
}
```



# 删除操作

现在来考虑删除操作，**什么时候需要删除一条边？**

![扫](https://cdn.luogu.com.cn/upload/image_hosting/tag7xfat.png)

当扫描到矩形的右侧边的时候，就得删除之前加进来的边

**思考：线段树支持些什么？**

1. **区间修改值**

1. 区间合并

对，线段树是支持区间修改值的，那**怎么修改这个区间的值**，以及怎么**判断此时需要修改呢**？

- 当前边是矩形**左侧边**的时候加入线段树
- 当前边是矩形**右侧边**的时候从线段树中删除

我们需要为扫描线引进 **新变量mark**，用来判断这是左边还是右边，左半边的线段记为1，右半边的线段记为 -1
```cpp
struct Scanline{
	int x, y1, y2，mark;
}scanline[ maxn ];

int main(){
	for(输入操作){
		读入矩形的四个坐标x1, y1, x2, y2
		
		//这是矩形的左半边
		scanline 加入(x1, y1, y2, 1);

		//这是矩形的右半边
		scanline 加入(x2, y1, y2, -1); 
	}
}
```
同时我们应该为线段树添加新变量来判断是否被一个矩形的边完全覆盖

1. 如果当前区间**被一个矩形的边完全覆盖**的时候, 区间的长度 = 上界 - 下界( r - l )

2. 如果**没有被矩形边完全覆盖**，用**左区间 和 右区间的长度** 来更新它自己的长度

伪代码：

```cpp
struct segment_tree{
	int l, r, len;
	//l:y坐标的上界
	//r:y坐标的下界
  	 //len:当前区间内线段的总长度
    
   	int mark;
    	//mark:判断区间内是否被矩形的边完全覆盖
}st[ maxn ];

void pushup(int o){
	if(mark //o 这个区间被矩形的边完全覆盖)st[o].len = st[o].r - st[o].l;
	else{
		st[o].len = st[o << 1].len + st[o << 1| 1].len;
		//父节点的区间值 = 子区间的长度之和 
	}	
}
```
区间修改操作：

- 如果这条扫描线是**矩形的左半边**, 给被覆盖的线段的mark + 1 
- 如果这条扫描线是**矩形的右半边**，给被覆盖的线段的mark - 1

这样就能通过mark来完成区间的删除和加入，写出加入&删除边的

伪代码：

```cpp
void change(int o, int L, int R,int mark){
	//o:当前区间
	//L:要改变的区间上界
	//R:要改变的区间下界
	int l = st[o].l, r = st[o].r;//当前区间的左右端点
	if(L <= l && r <= R){
		st[o].mark += mark;
		pushup(o);
		return; 
	} 
	int mid = (l + r) >> 1;
	if(L <= mid)change(o << 1, L, mid);
	if(mid + 1 <= R)change(o << 1, mid + 1, R, mark);
	pushup(o);
}
```
至于建树太简单了就不讲了，就是初始化一下，没什么特别的

到这里就可以把所有的伪代码给出来了

```cpp
struct segment_tree{
	int l, r, len;
	//l:y坐标的上界
	//r:y坐标的下界
    //len:当前区间内线段的总长度
    
    int mark;
    //mark:判断区间内是否被矩形的边完全覆盖，用于完成区间的删除操作 
}st[ maxn ];

void build(int o, int l, int r){
	st[o].l	= l, st[o].r = r;
	st[o].len = 0;
	st[o].mark = 0;
	if(l == r)return;
	int mid = (l + r) >> 1;
	build(o << 1, l, mid);
	build(o << 1|1, mid + 1, r);
}
void pushup(int o){
	if(st[o].mark)st[o].len = st[o].r - st[o].l;
	else{
		st[o].len = st[o << 1].len + st[o << 1| 1].len;
		//父节点的区间值 = 子区间的长度之和 
	}	
}

void change(int o, int L, int R,int mark){
	//o:当前区间
	//L:要改变的区间上界
	//R:要改变的区间下界
	int l = st[o].l, r = st[o].r;//当前区间的左右端点
	if(L <= l && r <= R){
		st[o].mark += mark;
		pushup(o);
		return; 
	} 
	int mid = (l + r) >> 1;
	if(L <= mid)change(o << 1, L, mid);
	if(mid + 1 <= R)change(o << 1, mid + 1, R, mark);
	pushup(o);
}

struct Scanline{
	int x, y1, y2，mark;
}scanline[ maxn ];

int main(){
	for(输入操作){
		读入矩形的四个坐标x1, y1, x2, y2
		scanline 加入(x1, y1, y2, 1);
		scanline 加入(x2, y1, y2, -1); 
	}
	
	将扫描线按照x轴的坐标从小到大排序 
	
	for (int i = 1; i <= N; i++){//扫描线的个数 
		//线段树上用来维护边的长度 
		change(1, scanline[i].l, scanline[i].r, scanline[i].mark);
		面积 =  （ k1 - 上一个矩形的边 横坐标） * st[1].len;
	}
} 
```
把思路理一遍：

1. 线段树**用于处理一维的线段长度**

1. 判断是**矩形的左边还是右边**，是左边就加，是右边则减

就这么两个难点

# 离散化

你们以为就这么结束了嘛哈哈哈哈哈哈，当然不可能，

不然我前面**白讲了那么久离散化了，**

现在我们要为线段树加上离散化这一个优化

- 在开始之前建议温故而知新

- 记住线段树履行的功能：**求线段总和**

so，what need 离散化？

还记得离散化的功能？将一个数轴上的**一个一个点通过大小排序**，**保留点与点的大小关系**

- 这道题目的线段树是绝对不会允许你开四倍于线段长度的，百分百爆掉，这个时候就需要进行离散化，

- 离散化的原因是： **线段树的长度不能开的太大**

那很明显我们要离散化的是：

- 扫描线上的 y 坐标 上界和 y 坐标 下界

我们把所有的矩形边上的 y 坐标 存储下来

**不是矩形边上的y坐标** 是不需要使用的，（因为只需要l - r就能够知道边上的长度），因此可以对y进行离散化操作

给出离散化的代码：

```cpp
//Y:矩形边上的所有Y坐标
#include <algorithm>
int Y[ maxn ];
sort(Y + 1, Y + 1 + N);
tot = unique(Y + 1, Y + 1 + N);
```
好，接下来是把**离散化丢进线段树**里去

线段树的意义也发生改变了，现在它维护的 l, r 不再是数值意义上的l, r，而是**被离散化后的 l, r的排名。**

接下来是**最后一个难点了**，加油！！！

这里有一个很不错的图文解说，描述了**离散化怎么作用在线段树上**

[@sdau_blue 的一篇博客](https://blog.csdn.net/xianpingping/article/details/83032798)

被离散化后的线段树的l, r 存储的是区间( Y[ l ], Y[ r ] ），但，当l = r 的时候，即为（Y[l] , Y[l]）,**变成了一个点。**

**变成了一个点**有什么问题咧？

问题大着呢

感谢@MakiseVon 提供的例子

举个栗子，如果总区间为[1, 4], 

有一条扫描线，y1 = Y[1] , y2 =  Y[3] ,**加入线段树**，模拟一下：

**进入到线段树修改值**，修改st[1,2]的长度为Y[2] - Y[1]

修改st[3,3]的长度为**Y[3] - Y[3] = 0**

等等这显然不对啊, **st[3,3]的值应该被修改成Y[3] - Y[2]才对**

因此我们想到了改变 **线段树存储的值** de意义

用 L 表示 左区间 L ，值为Y[L]

用 R 表示 **右区间 R + 1 **,值为Y[R + 1]

好，现在再来看之前的例子

有一条扫描线，y1 = Y[1] , y2 =  Y[3] ,加入线段树，模拟一下：

进入到线段树修改值，修改st[1,2]的长度为Y[2 + 1] - Y[1]

这样就没问题了

给出全部的代码：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#define ll long long 
using namespace std;
const int maxn = 1e6 + 10;
int N, cnt = 0;
ll int x1, x2, y1, y2, X[maxn << 1];
struct scanline{
	ll l, r, h;
	int mark;//保存权值
	bool operator <(const scanline &te)const{
		return h  < te.h;
	} 
}line[maxn << 1];

struct tree{
	int l, r, sum;
	//sum:被完全覆盖的次数
	//len:区间被截的长度 
	ll len;	
}st[maxn << 2];

void build(int o, int l, int r){
	st[o].l	= l, st[o].r = r;
	st[o].len = 0;
	st[o].sum = 0;
	if(l == r)return;
	int mid = (l + r) >> 1;
	build(o << 1, l, mid);
	build(o << 1|1, mid + 1, r);
}
void pushup(int o){
	int l = st[o].l, r = st[o].r;
	if(st[o].sum)st[o].len = X[r + 1] - X[l];//已经被覆盖了，更新长度 
	else{st[o].len = st[o << 1].len + st[o << 1 |1].len;}
}
void change(int o, ll L, ll R, int c){
	int l = st[o].l, r = st[o].r;
	//l,r代表o这个点的范围，L,R意义是待修改的区间
	if( X[r + 1] <= L || R <= X[l] )return;
	//当右区间 + 1小于左区间， 
	if(L <= X[l] && X[r + 1] <= R){
		st[o].sum += c;
		pushup(o);
		return;
	}
	change(o << 1, L, R, c);
	change(o << 1 | 1, L, R, c);
	pushup(o);
}
int main(){
	scanf("%d",&N);
	for(int i = 1; i <= N; i++){
		cin>>x1>>y1>>x2>>y2;
		X[2 * i - 1] = x1, X[2 * i] = x2;
		line[2 * i - 1] = (scanline){ x1, x2, y1, 1};
		line[2 * i] = (scanline){ x1, x2, y2, -1};
	}
	N = N << 1;
	sort(line + 1, line + N +1);
	sort(X + 1, X + N + 1);
	int tot = unique(X + 1, X + N + 1) - (X + 1);
	build(1, 1 , tot - 1);
	//右端点的对应关系已经被修改了,我们用 
	//[1,tot - 1]描述的是[x[1],x[tot]] 
	ll ans = 0;
	for(int i = 1; i < N; i++){
		change(1, line[i].l,line[i].r,line[i].mark);
		ans += st[1].len *(line[i + 1].h - line[i].h);
	}
	cout<<ans;
}

```
我还特意把Y改成了X，目的就是为让各位练习一下从左到右的扫描线，嗯，就顺着刚才的思路打一遍看看打不打得下来，不记得就类比一下这个代码


---

## 作者：MakiseVon (赞：116)

- **扫描线**

扫面线是计算几何中解决图形的交并问题时所用的一种算法。

---

- **思想**

其思想非常简单，以求矩形并集覆盖总面积为例，如下图  

![](http://cdn.luogu.com.cn/upload/pic/70143.png)

想象一根线，从下往上扫，以矩形的上下边为分界，计算多个部分的面积，这些面积之和就是所求总面积。

![](http://cdn.luogu.com.cn/upload/pic/70144.png)

当然，也可以从上往下扫，从左往右扫，从右往左扫...区别不大 qwq ~

---

- **流程**

以从下往上扫为例。

1. 先将给出的矩形的顶点的 $x$ 坐标排序并离散化（如本题，坐标范围较大的情况，离散化是必须的）；
2. 将矩形的上下边按 “高度” 排序；
3. 从下往上枚举上下边（扫描），记第 $i$ 条边 $l$ 的高度为 $h_i$ ，当前正在处理中的边的并集为 $L$ ，长度为 $len$ ；除第一条边外，每遇到一条边，$ans$ 加上 $len*(h_i-h_{i-1})$ ，然后更新 $L$ 和 $len$。

---

- **实现**

依然以从下往上扫为例

1. $x$ 坐标的离散化比较简单；
2. 我们需要想办法储存上下边并排序；一条边有左右两个点：$(x_l,h)$ 、 $(x_r,h)$ ，那么我们便可以用一个四元组 $(x_l,x_r,h,f)$ 来表示一条上下边，其中 $f$ 用于表示该边是下边 $(f=1)$ ，还是上边 $(f=-1)$ ，因为我们保存边希望能得到边长，所以这里存的 $x$ 是离散化前的 $x$ ，以 $y$ 为关键字排序，即可得到从下到上的上下边；
3. 我们要维护边并集 $L$ 及对应的 $len$ ；这一步跟边的高度 $h$，无关系，只跟 $(x_l,x_r)$ 有关系——可以想到区间修改与区间查询，虑用离散化后的 $x$ 坐标建 **线段树** 。

如果你和我一样，写线段树喜欢少开些东西，比如节点的左右指针之类的，那么在这题里甚至不用建树 233

考虑线段树该维护什么？

首先是一个 **标记** ，遇到下边时，就在$[x_l,x_r]$ 对应的 **离散化后** $[x_l',x_r']$ 上 标记 $+1$ ，否则标记 $-1$，显然可以用前面定义的 $f$ 实现对上下边的不同修改；

其次是 $len$ ，即该区间上 **边并集的长度** ，那么根节点的 $len$ ，就是我们更新 $ans$ 所需要的；如何维护？向上更新时，若标记为 $0$ 直接合并子节点的 $len$ ，否则不变即可（标记不为 $0$ 说明该区间被线段覆盖）。难点在于下方的维护。

以样例为例，离散化后 $x$ 坐标共 $4$ 个，总区间为 $[1,4]$ ，而我们第一次修改就是对 $[1,3]$ 修改，也就是对更往下的 $[1,2]$ ，$[3,3]$ 修改。我们记第 $i$ 个坐标对应的原坐标为 $X_i$ 如果说 $len_{[1,2]}=X_2-X_1$，那么 $len_{[3,3]}$ 呢？显然这样维护是有问题的。

区间要有长度，区间就不能只有一个点，我们不妨这样想，我们要维护 $[1,3]$ ，$3$ 个点其实是对应 $[1,2]$ ，$[2,3]$ 这 $2$ 条线段，也就是说包含 $k+1$ 个点的区间，其实是对应 $k$ 条线段的。

那么我们改变一下思路，让线段树中所有的区间 $[l,r]$ 表示原来的 $[l,r+1]$ 不就行了吗？那么叶节点 $[x,x]$ 其实就对应 $[x,x+1]$。同样，如果我们原来要对 $[l,r]$ 修改，那么就只需对 $[l,r-1]$ 修改。回到刚才的例子，总区间 $[1,4]$ -> $[1,3]$，修改 $[1,3]$ -> $[1,2]$，$len_{[1,2]}=X_3-X_1$ ~ 美滋滋。

**注意** ，这里说的区间修改是对区间这一个整体而言的，是 **对线段打标记** ，而不是对这条线段上的每个点打标记。又因为线段树上一点就代表一个区间，一旦某个节点所代表的区间被包含在需修改的区间中，那么只需让该节点  $±1$ ，**不需要继续下放** 。

![](http://cdn.luogu.com.cn/upload/pic/70146.png)

结合前面所讲的，分析下线段树维护具体步骤：

修改 $[x_l,x_r]$时

1. 若当前节点 $[l,r]$ 被包含在 $[x_l,x_r]$ 中，直接对该节点修改并返回
   - 若该节点修改后标记不为 $0$ ，$len=X_{r+1}-X_l$
   - 否则，$len=len_l+len_r$
2. 否则，往下修改，修改完后更新 $len=len_l+len_r$

---

- **$Code$**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(i,l,u,d) for(register int i=(l);i<=(u);i+=(d))
#define mid ((l+r)>>1)
#define ls (rt<<1)
#define rs (rt<<1|1)
typedef long long ll;
typedef struct _line{
    int xl,xr,h,f;
    _line(int a=0,int b=0,int c=0,int d=0):xl(a),xr(b),h(c),f(d){}
    bool operator <(const _line &t) const{ return h<t.h; }
}line;

const int N=1e5+5;
int n,xl,yl,xr,yr;
int x[N<<1]; line l[N<<1];
int tag[N<<3]; ll len[N<<3];
ll ans;

template<typename t> t &read(t &r);
void modify(int rt,int l,int r,int xl,int xr,int d);
void push_up(int rt,int l,int r);

int main(void){
    read(n);
    rep(i,1,n,1){
        read(xl),read(yl),read(xr),read(yr);
        x[(i<<1)-1]=xl,x[i<<1]=xr;
        l[(i<<1)-1]=line(xl,xr,yl,1),l[i<<1]=line(xl,xr,yr,-1);
    }
    sort(x+1,x+2*n+1),sort(l+1,l+2*n+1);
    // 总的区间 [1,ct] -> [1,ct-1]
    int ct=unique(x+1,x+2*n+1)-x-2;
    rep(i,1,2*n,1){
        int xl=lower_bound(x+1,x+ct+1,l[i].xl)-x;
        // 待修改区间 [xl,xr] -> [xl,xr-1]
        int xr=lower_bound(x+1,x+ct+1,l[i].xr)-x-1;
        // 先算面积，再修改
        ans+=len[1]*(l[i].h-l[i-1].h);
        modify(1,1,ct,xl,xr,l[i].f);
    }
    printf("%lld\n",ans);
    return 0;
}

template<typename t> t &read(t &r){
    char c;int f=1;
    while(!isdigit(c=getchar()))
        if(c=='-') f=-1;
    r=c^'0';
    while(isdigit(c=getchar())) r=r*10+(c^'0');
    return r*=f;
}

void modify(int rt,int l,int r,int xl,int xr,int d){
    if(xl<=l&&r<=xr){
        len[rt]=(tag[rt]+=d)?x[r+1]-x[l]:0;
        return push_up(rt,l,r);
    }
    if(xl<=mid) modify(ls,l,mid,xl,xr,d);
    if(xr>mid) modify(rs,mid+1,r,xl,xr,d);
    push_up(rt,l,r);
}

inline void push_up(int rt,int l,int r){
    len[rt]=tag[rt]?len[rt]:(l==r?0:len[ls]+len[rs]);
}
```

---

完结撒花花 ~ qwq

---

## 作者：paperghost_ls (赞：80)

# 观前提示：如果本文有什么疏漏的地方，欢迎指正！

最近因为要做有关的题，所以学了这个听起来就很厉害的东西——**扫描线**

扫描线算法是一种求**矩形**的**面积并**和**周长并**的好方法。其思想是由一条**假想**的线从图形的下方扫向上方（或者左方扫到右方，都可以），那么通过分析扫描线被图形截得的线段就能获得所要的结果。该过程可以用**线段树**进行加速(文字from **[@NCC79601](https://ncc79601.blog.luogu.org/scan-line)**)

接下来，我将把扫描线分成面积并和周长并两个部分，尽量用非常通俗的语言和较为细致的步骤进行讲解

# 一、面积并

# [P5490 【模板】扫描线](https://www.luogu.com.cn/problem/P5490)

这一道题，就是面积并的模板题

既然是要我们求这几个矩形的覆盖面积，我们就来看一下,要是我们要求下面这个图形的覆盖面积，我们应该怎么做？

![](https://cdn.luogu.com.cn/upload/image_hosting/nmb59xi4.png)

注意看，这里是有一部分的面积是重合的。所以说，我们要求的面积其实就是下面这个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/euk2bxgg.png)

这个图形是一个不规则的图形，用什么方法求呢？

在初中数学中，我们求不规则图形的最普遍也是最简单的方法是什么？是**割补法**。所以，我们可以把这个图形进行割补：

![](https://cdn.luogu.com.cn/upload/pic/70275.png)

这样子，我们就可以求出每一块分割后的图形面积来求出整个图形的总覆盖面积

我们可以用图象来模拟一下整个扫描线大概是怎么操作的，这里给出的是从左往右的模拟：

![](https://s2.ax1x.com/2019/08/08/eTuDjP.gif)

(以上图象均from **[@Gu_Pigeon
](https://www.luogu.com.cn/blog/happy404/solution-p5490)**)

观察上面这张gif不难看出，扫描线在扫的时候，似乎在扫到线段的时候就会把图形分割。那么，我们就看看，分割后的面积应该怎么求:

![](https://cdn.luogu.com.cn/upload/image_hosting/3nm0vv6u.png)

黄色那一块图象的左下角坐标为$(x1,y1)$,右上角坐标为$(x2,y2)$,那么左上角就为$(x1,y2)$,右上角即为$(x2,y1)$。这一块图象的面积就是$(y2-y1) * (x2-x1)$，我们后面要用这个式子来计算面积

现在我们来讲一下整个算法的一些操作

#### 设立全局变量$ans$记录答案，读入$x1,y1,x2,y2$

首先要先把数据读进来

#### 在读入之后，我们先得**离散化**

可不是嘛，看一下样例，$0≤x1<x2≤$ $10^9$,$0≤y1<y2	≤$ $10^9$， 这个一看就会爆空间。所以我们要用芝麻换西瓜，牺牲小部分空间来离散化

#### 然后我们要排序

既然我们是从左往右扫，那么最先扫到的那一条线段的x必然是最小的，所以我们就要让整个图象的线段进行排序，使得x小的线段可以先被扫到

#### 我们还要运用线段树

先问一个问题：**为什么要优化这个算法**？

不难发现，我们在从左往右扫时，最难计算的其实就是扫到的那一条线段的长度。因为一条线段**不一定是该矩形的边**，比如这一条红色线段:

![](https://cdn.luogu.com.cn/upload/image_hosting/dlxthvjl.png)

这一条线段，其实就是由黑色框起来的这一部分线段(这条线段是一个矩形的边)加上蓝色框起来的线段(这条线段也是一个矩形的边)再减去重合部分。因为这里只有三个图形，所以计算量也不大。但是，要是有更多的矩形像这样子重合，计算量就很大了，很浪费时间的。所以我们要用一些~~奇~~技~~淫~~巧来优化整个算法

再问一个问题，**为什么要用线段树**？

其实也已经很明显了。假如我们要求的是这一条红色的线段的长度，并不用把多个重合的矩形的边加到一起再减去重合部分，我们其实可以这样子算:

![](https://cdn.luogu.com.cn/upload/image_hosting/thizyyim.png)

我们可以把黑色框起来的线段加上灰色框起来的线段加上蓝色框起来的线段加上紫色框起来的线段，得出这条红色线段的长度。而这些框起来的地方就是一条线段。那么，类似的,我们可以建立**线段树**，**管理图中所有矩形的y坐标之间的线段**。节点的特征值就是**当前扫描到的线段在管理范围内的总长度**

比如，我们定义$tr[1]$所管理的范围就是**从图象最上面的** $y$**到最下面的**$y$，也就是管理黑色、灰色、蓝色和紫色框起来的这些线段。$tr[1]$的特征值$c$就是**从图象最上面的**$y$**到最下面的**$y$**这个范围中包含被扫到的线段的长度**。当扫到第一条线段的时候，只有灰色和蓝色部分才有这一条被扫到的线段的一部分，所以$tr[1].c=$灰色+蓝色这部分的长度；扫到第二条线的时候，$tr[1].c=$黑色+灰色+蓝色(因为黑色和灰色和蓝色才含有扫描到的线)的长度；扫到第三条线的时候，$tr[1].c=$黑+灰+蓝+紫(都有有扫描到的线的一部分)的长度...

那么，求这一条被扫到的线段的长度，我们只要用线段树比较基础的**区间求和**就可以了

最后一个问题，**怎么判断哪些区间包含当前扫到的线段**

我们可以通过区间求和来计算出扫描线的长度，但是我们要计算哪一部分的线段呢？就像上一幅图，你怎么知道什么时候加的是灰色和蓝色部分，什么时候加的是灰色、蓝色和黑色部分，还有什么时候加的是灰色和蓝色和黑色和紫色部分呢？这个时候，我们要引进**入边**和**出边**

此入边出边非图论的入边出边。这里的入边，指的是**一个矩形中第一条被扫到的线段**；而出边，就是**这个矩形第二条，也就是最后一条被扫到的线段**

我们可以这样子去理解：扫描到一条入边意味着有一个矩形进入到扫描线扫描的区域里面，那么我们在计算面积的时候当然要加上这一部分；而扫描到一条出边也就意味着有一个矩形已经扫描完了，这个矩形也就不在扫描线扫描的区域以内了，所以这个时候，我们就不再需要这一部分了

我们设**入边为**$1$ ，**出边为**$-1$。每个节点设立一个变量$tag$，记录这个节点管理的区间是不是有当前扫描到的线段的一部分，判断有没有的依据是节点的$tag$是否$>0$。如果$>0$就说明包含了线段的一部分，$=0$就是没有包含，**不可能**出现$<0$的情况

这样一来，当我遇到一条出边时，就可以与之前一条入边加上的抵消掉。再根据$tag$的定义，判断这个节点所管理的范围是否包含被扫到的线段，有的话就加上

我们其实也可以根据个人喜好，可以设**入边为**$2$,**出边为**$-2$或者**入边为**$3$，**出边为**$-3$等等，只要入边和出边**互为相反数且入边值** $>0$ $>$ **出边值的都可以**(也可以入出边互为相反数且入边小于出边，但后面的操作就要修改一下了)

那么举一个例子模拟一下算法流程:

![](https://cdn.luogu.com.cn/upload/image_hosting/eavcszry.png)

假设黑、蓝、灰、粉、紫所框起来的线段都为$1$，棕色矩形的宽为$2$，草绿色和灰蓝色矩形宽为$1$，开始模拟


扫到**第一条边，是且肯定是入边**。那么我们加上这一部分长度，刚好在蓝色、灰色和粉色区域，这三个区域$tag$都加$1$

当前各区域$tag$:
```
黑=0
蓝=1
灰=1
粉=1
紫=0
```

我们只计算$tag$大于$0$的区域的长度。所以$ans=ans+$ $($蓝色$+$灰色$+$粉色$)$ $ * $ 棕色矩形的宽 $=0+(1+1+1) * 2=6$

扫到第二条边，也是入边。所以黑色和紫色的区域$tag$加$1$

当前各区域$tag$:
```
黑=1
蓝=1
灰=1
粉=1
紫=1
```
同样计算$tag$大于$0$的区域的长度。$ans=ans+$ $($ 黑色$+$蓝色$+$灰色$+$粉色$+紫色) * $草绿色矩形宽度 $=6+(1+1+1+1+1)* 1=11$ 

扫描到第三条边。这是一条**出边**。但是，这里只有灰色区域才含有这条出边,所以只有灰色区域的$tag$减$1$,其它区域的$tag$不变

当前各区域$tag$:
```
黑=1
蓝=1
灰=0
粉=1
紫=1
```
现在灰色区域的$tag$等于$0$了，我们就不再需要计算灰色区域这一部分的长度，只计算其它区域的。$ans=ans+($黑色$+$蓝色$+$粉色$+$紫色$)* $灰蓝色矩形宽$=11+(1+1+1+1)* 1=15$

这里因为重叠了两条线段，所以这一幅图实际上只有**四**条线段。扫描到第**三**条线段时候其实已经宣告**扫描结束**了。因为**最后一条线段是且肯定是出边**，这条线段的后面也**不可能再有面积覆盖**,而且扫描到最后一条线段所有的$tag$都会变成$0$。多计算这一步就略显冗杂。所以在**面积并**中，可以不用计算到最后一条线段

不用扫第四条边了，输出$ans$即可

给出这一幅图的数据吧:

输入:
```
3
0 1 3 4
2 3 4 5
2 0 4 2
```
输出:
```
15
```
至此，整个算法大概框架我们已经讲的差不多了，现在来讲一些小细节

### 细节1:

根据上面的一些例子可以发现，在这里线段树维护的是**线段**，而不是一个个**点**。，每一个节点记录的是一整条线段，而不应该记录节点

那么，我们在修改$tag$还有区间求和的时候要怎么做？例如这幅图:

![](https://cdn.luogu.com.cn/upload/image_hosting/eavcszry.png)

~~又放送~~

离散化以后，$y$坐标共$5$个，总区间为$[1,5]$。扫描到第一条边时，需要更改的区间为$[2,4]$。这里$mid=(2+4)>>1=3$。要是直接按线段树模板来修改的话，我们就将修改区间$[2,3]$和$[4,4]$

咦，怎么出现了$[4,4]$?这是一个点啊？这不是一条线段啊？要是修改和查询区间$[2,4]$时，我们不应该修改查询区间$[2,3]$和区间$[3,4]$吗？

要是我们不采取一些操作，那么我们实际修改$[2,4]$的$tag$还有区间求和时，就只会修改和加上$[2,3]$这个部分，而会漏掉$[3,4]$这一部分。这样子当然是不对的

众所周知，区间里有$n$个点，就意味着区间有$n-1$条线段。我们不妨**将区间$[l,r]$表示成$[l,r+1]$**,也就是$[l,r]$**实际上是区间**$[l,r+1]$**的线段**

回到例子。要是这样子的话，我们修改$[2,3]$,实际上我们就是在修改$[2,4]$,因为$[2,3]$表示的其实是$[2,4]$~~废话~~。而我们修改到了修改$[2,2]$和$[3,3]$的时候，实际上也正是在修改$[2,3]$和$[3,4]$，刚好能达到我们的目的

这样子的话，虽然还会出现修改查询区间$[i,i]$的情况，但是这实际是区间$[i,i+1]$。这样子也不再会出现记录节点的情况

所以，我们就采用这种方法，使得在修改和查询区间$[l,r]$的时候，我们实际上修改和查询的是$[l,r-1]$，这样就可以解决这个问题了

这第一个细节，是我觉得比较重要的地方，应当重视

### 细节2:

既然要用到区间查询，我们是不是应该要打懒标记呢？

其实不然，我们要的，只是$tr[1].c$，也就是整个图象包含的被扫到的线段的长度。所以，我们根本没有必要$pushdown$下放到各个节点。相反，我们应该$pushup$上放到根节点，不断维护这个根节点


好了，就讲这么多，下面给出代码(附带注释):
```
#include<cstdio>
#include<algorithm>
#define ri register int
using namespace std;
typedef long long ll;
ll ans;
ll n;
ll x1,x2,y1,y2;
ll y[210000];//用来离散化 
struct smx
{
	ll y1,y2,x,mark;
	//y1,y2表示这条线段上面的那个点和下面的那个点的y坐标 
	//这里的x在这里不会用到，只是用来排序而已
	//mark表示这条边是入边还是出边 
}line[210000];
bool cmp(smx a,smx b){return a.x<b.x;}//以x坐标进行排序
struct node
{
	ll l,r,lc,rc,c,tag;
	//lc,rc为左儿子和右儿子的编号
	//tag用来判断扫描线扫到下一条线段时还包不包括这个矩形  
}tr[410000];ll len;
void bt(ll l,ll r)//建树 
{
	len++;int num=len;
	tr[num].l=l;tr[num].r=r;tr[num].lc=tr[num].rc=-1;tr[num].c=tr[num].tag=0;
	if(l==r)return ;
	else
	{
		int mid=(l+r)>>1;
		tr[num].lc=len+1;bt(l,mid);
		tr[num].rc=len+1;bt(mid+1,r);
	}
}
void pushup(ll num,ll l,ll r)
{
	if(!tr[num].tag)//如果tag=0 
	{
		if(l==r)tr[num].c=0;//[l,r]表示的是[l,r+1],所以这里的意思是如果l==r+1，那么就意味着它是树最底下的叶子节点，它不会有儿子，又没有被线段覆盖，所以c为0 
		else tr[num].c=tr[tr[num].lc].c+tr[tr[num].rc].c;//虽然这个节点没有覆盖，但它的子节点可能会被覆盖，所以加上自己的儿子节点 
	}
}
void change(ll num,ll l,ll r,ll k)//num为节点编号，l、r为修改范围，k用来修改 
{
	if(l<=tr[num].l&&tr[num].r<=r)
	{
		tr[num].tag+=k; 
		if(tr[num].tag)tr[num].c=y[tr[num].r+1]-y[tr[num].l];//如果tag>0要加上。又因为这里的r其实是r-1的，但离散化的这个y数组却没有这种操作，所以要加1 
		else tr[num].c=0;//tag=0就不加 
		pushup(num,tr[num].l,tr[num].r);//维护 
		return ;
	}
	int lc=tr[num].lc,rc=tr[num].rc;
	int mid=(tr[num].l+tr[num].r)>>1;
	if(r<=mid)change(lc,l,r,k); 
	else if(mid+1<=l)change(rc,l,r,k);
	else change(lc,l,mid,k),change(rc,mid+1,r,k);
	pushup(num,tr[num].l,tr[num].r);//维护 
}
int main()
{
	scanf("%lld",&n);
	for(ri i=1;i<=n;i++)
	{
		scanf("%lld%lld%lld%lld",&x1,&y1,&x2,&y2);
		y[(i<<1)-1]=y1;y[i<<1]=y2;//离散化 
		line[(i<<1)-1]=(smx){y1,y2,x1,1};line[i<<1]=(smx){y1,y2,x2,-1};//记录线段 
	}
	n<<=1;//一个矩形就有两条线段 
	sort(y+1,y+n+1);//离散化操作 
	sort(line+1,line+n+1,cmp);//按照x坐标的大小顺序来排序 
	int cnt=unique(y+1,y+n+1)-(&y[1])-1;//去重操作计算有多少个不同的y，也就是这个图象有几个y。因为区间[l,r]表示的是[l,r+1]，所以区间[l,r-1]实际上是[l,r]，所以总区间长度cnt要多减一个1 
	bt(1,cnt);//建树 
	for(ri i=1;i<n;i++)//开始扫描，面积并中扫描到n-1条线段即可
	{
		y1=lower_bound(y+1,y+cnt+2,line[i].y1)-y;//当前这条线段的y1坐标的离散值 ，表示线段的y1是在线段树的第(离散值)个节点 
		y2=lower_bound(y+1,y+cnt+2,line[i].y2)-y-1;//当前这条线段的y2坐标的离散值，表示线段的y2是在线段树的第(离散值)个节点，同时为了实际上是求[l,r],所以我们要求的是[l,r-1]，所以这里要减1 
		change(1,y1,y2,line[i].mark);//修改
		ans+=tr[1].c*(line[i+1].x-line[i].x);//ans记录当前扫到的面积
	}
	printf("%lld\n",ans);//输出ans 
	return 0;
}
```
这个代码是从左往右扫的，可以自己尝试打一下从下往上扫的代码，其实和这个代码已经没什么两样了

我还打了一个版本，两个代码虽然看起来有点不一样，但思想是一致的:
```
#include<cstdio>
#include<algorithm>
#define ri register int
using namespace std;
typedef long long ll;
ll ans;
ll n;
ll x1,x2,y1,y2;
ll y[210000];
struct smx
{
	ll y1,y2,x,mark;
}line[210000];
bool cmp(smx a,smx b){return a.x<b.x;}//排序 
struct node
{
	ll c,tag;
	//tag用来判断扫描线扫到下一条线段时还包不包括这个矩形 
}tr[810000];
void pushup(ll num,ll l,ll r) 
{
	if(!tr[num].tag)
	{
		if(l==r)tr[num].c=0; 
		else tr[num].c=tr[num<<1].c+tr[num<<1|1].c;
	}
}
void change(ll num,ll l,ll r,ll y1,ll y2,ll k)//这里的l,r是num的管理范围,y1、y2是上一个代码的l,r 
{
	if(y1<=l&&r<=y2)
	{
		tr[num].tag+=k;
		if(tr[num].tag)tr[num].c=y[r+1]-y[l];
		else tr[num].c=0;
		pushup(num,l,r);
		return ;
	}
	ll mid=(l+r)>>1;
	if(y1<=mid)change(num<<1,l,mid,y1,y2,k);
	if(mid+1<=y2)change(num<<1|1,mid+1,r,y1,y2,k);
	pushup(num,l,r);
}
int main()
{
	scanf("%lld",&n);
	for(ri i=1;i<=n;i++)
	{
		scanf("%lld%lld%lld%lld",&x1,&y1,&x2,&y2);
		y[(i<<1)-1]=y1;y[i<<1]=y2;
		line[(i<<1)-1]=(smx){y1,y2,x1,3};line[i<<1]=(smx){y1,y2,x2,-3};
	}	
	n<<=1; 
	sort(y+1,y+n+1);
	sort(line+1,line+n+1,cmp);
	int len=unique(y+1,y+n+1)-(&y[1])-1;
	for(ri i=1;i<n;i++)
	{
		y1=lower_bound(y+1,y+len+2,line[i].y1)-y;
		y2=lower_bound(y+1,y+len+2,line[i].y2)-y-1;
		change(1,1,len,y1,y2,line[i].mark);
		ans+=tr[1].c*(line[i+1].x-line[i].x);
	}
	printf("%lld\n",ans); 
	return 0;
}
```
~~貌似第二个代码要快一点~~

# 二、周长并

# [P1856 [USACO5.5]矩形周长Picture](https://www.luogu.com.cn/problem/P1856)


这一个就是周长并了

只要你看懂了面积并，周长并其实是很好理解的

由于这里求的是周长而不再是面积了，我们很容易想到**就用面积并的方法从下往上扫一遍，然后从左往右扫一遍，每次扫到线段就用**$ans+=tr[1].c$就好了

要是这样想的话，你就**错了**！

比如这一幅图:

![](https://cdn.luogu.com.cn/upload/image_hosting/eavcszry.png)

~~双放送~~

还是假设黑、蓝、灰、粉、紫所框起来的线段都为$1$，棕色矩形的宽为$2$，草绿色和灰蓝色矩形宽为$1$

我们先从左往右扫。扫到第一条线段，$ans=ans+tr[1].c=0+(1+1+1)=3$。目前还没有任何问题

扫到第二条线段，$ans=ans+tr[1].c=3+(1+1+1+1+1)=8$?

？？？为什么$ans$会等于$8$?从左往右扫的话，到第二条线段$ans$不应该是$5$吗?怎么回事？

发现没有？在扫到第二条边的时候，其它区间的$tag$也是$>0$的，所以我们多计算了一些部分

因为当前覆盖和先前覆盖的交集已经计算过，所以要减去，计算出来的结果就是$ans$要加的是$abs(tr[1].c$-上一次的$tr[1].c$$)$

### 但是，你谷出的数据非常毒瘤，我曾在讨论区发现这几个贴：[测试数据是否有错？？](https://www.luogu.com.cn/discuss/show/27564)和[论某谷的玄学评测机](https://www.luogu.com.cn/discuss/show/172131)，都反映出这个问题

这道题一共有六个测试点，但是有两个点非常毒瘤

比如第五个数据点，要是排序用的不是稳定排序stable_sort(sort是不稳定排序)，虽然在本地输出的和样例答案一样，但在洛谷玄学评测机评测时答案会出错

而第六个数据点更加鬼畜，连输入顺序都卡，样例在此:
```
Input:
2
0 0 4 4
0 4 4 8

Output:
24
```

![](https://cdn.luogu.com.cn/upload/image_hosting/gqent8fg.png)

如图，可以发现出边$2$和入边$3$计算了$2$次，因为先扫到出边$2$，$ans+=4$；扫到入边$3$，$ans$又加了$4$，这样子得出来的答案就是$32$

有一个解决方法，可以$A$掉这两个数据点。当两条线段重合的时候，我们让入边先被扫描，再来扫描出边。这样子就可以不怕多计算周长了

还有最后一个小细节，周长并要遍历每一条线段，不像面积并一样遍历$n-1$条线段就可以

下面给出代码:


```

#include<cstdio>
#include<algorithm>
#define ri register int
using namespace std;
int ans;
int n;
int x1,x2,y1,y2;
int x[11000],y[11000];
struct smx
{
	int zb1,zb2,h,mark;
}line1[11000],line2[11000];
bool cmp(smx a,smx b)
{
	if(a.h==b.h)return a.mark>b.mark;//重合时让入边先
	return a.h<b.h;
}
struct node
{
	int c,tag;
}tr1[41000],tr2[41000];
//下面这两个扫描线(从上到下，从左到右)框架基本一样，略显冗杂 
void pushup1(int num,int l,int r)
{
	if(!tr1[num].tag)
	{
		if(l==r)tr1[num].c=0;
		else tr1[num].c=tr1[num<<1].c+tr1[num<<1|1].c;
	}	
}
void pushup2(int num,int l,int r)
{
	if(!tr2[num].tag)
	{
		if(l==r)tr2[num].c=0;
		else tr2[num].c=tr2[num<<1].c+tr2[num<<1|1].c;
	}	
}
void change1(int x1,int x2,int k,int num,int l,int r)
{
	if(x1<=l&&r<=x2)
	{
		tr1[num].tag+=k;
		if(tr1[num].tag)tr1[num].c=x[r+1]-x[l];
		else tr1[num].c=0;
		pushup1(num,l,r);
		return ;
	}
	int mid=(l+r)/2;
	if(x1<=mid)change1(x1,x2,k,2*num,l,mid);
	if(mid+1<=x2)change1(x1,x2,k,2*num+1,mid+1,r);
	pushup1(num,l,r);
}
void change2(int y1,int y2,int k,int num,int l,int r)
{
	if(y1<=l&&r<=y2)
	{
		tr2[num].tag+=k;
		if(tr2[num].tag)tr2[num].c=y[r+1]-y[l];
		else tr2[num].c=0;
		pushup2(num,l,r);
		return ;
	}
	int mid=(l+r)/2;
	if(y1<=mid)change2(y1,y2,k,2*num,l,mid);
	if(mid+1<=y2)change2(y1,y2,k,2*num+1,mid+1,r);
	pushup2(num,l,r);
}
int main()
{
	scanf("%d",&n);
	for(ri i=1;i<=n;i++)
	{
		scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
		x[(i<<1)-1]=x1;x[i<<1]=x2;
		y[(i<<1)-1]=y1;y[i<<1]=y2;
		line1[(i<<1)-1]=(smx){x1,x2,y1,1};line1[i<<1]=(smx){x1,x2,y2,-1};
		line2[(i<<1)-1]=(smx){y1,y2,x1,1};line2[i<<1]=(smx){y1,y2,x2,-1};	
	}	
	n<<=1;
	sort(x+1,x+n+1);sort(y+1,y+n+1);
	sort(line1+1,line1+n+1,cmp);
	sort(line2+1,line2+n+1,cmp);
	int len1=unique(x+1,x+n+1)-(&x[1])-1;
	int len2=unique(y+1,y+n+1)-(&y[1])-1;
	for(ri i=1;i<=n;i++)//要遍历每一条线段 
	{
		int t;
		t=tr1[1].c;//记录上一次覆盖长度 
		x1=lower_bound(x+1,x+len1+2,line1[i].zb1)-x;
		x2=lower_bound(x+1,x+len1+2,line1[i].zb2)-x-1;
		change1(x1,x2,line1[i].mark,1,1,len1);
		ans+=abs(tr1[1].c-t); 
		t=tr2[1].c;//同上 
		y1=lower_bound(y+1,y+len2+2,line2[i].zb1)-y;
		y2=lower_bound(y+1,y+len2+2,line2[i].zb2)-y-1;
		change2(y1,y2,line2[i].mark,1,1,len2);
		ans+=abs(tr2[1].c-t);
	}
	printf("%d\n",ans);
	return 0;
}
```


完结撒花*★,°*:.☆(￣▽￣)/$:*.°★* 。

感谢dalao [@JimmyFlower](https://www.luogu.com.cn/user/124676)和 [@DBK_Darkside](https://www.luogu.com.cn/user/161296)在我不理解的地方给予我帮助，感谢！

2020/08/14 16:13 初稿

---

## 作者：米奇 (赞：64)

## 题解

看了怎么多题解，竟然没有一篇是下传标记的。

我来写一份常规的下传标记的做法。

我们需要维护区间最小值和最小值的个数

对于一个询问，如果区间最小值>0，那么返回区间长长度，否则说明区间有些地方是0，那么答案就是区间长度-最小值个数（长度）

然后就是普通线段树操作了，不需要标记用优化。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define next Next
#define last Last
#define int long long
const int N=1e6+5;
int n,gs,len,b[N],mi[N*4],lazy[N*4],sum[N*4],Len[N*4];
struct node{
	int val,l,r,opt;
}a[N];
/*char buf[1<<21],*p1=buf,*p2=buf;
inline int gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}*/
#define gc getchar
inline int read()
{
	int ret=0,f=0;char c=gc();
	while(!isdigit(c)){if(c=='-')f=1;c=gc();}
	while(isdigit(c)){ret=ret*10+c-48;c=gc();}
	if(f)return -ret;return ret;
}
void pushup(int nod)
{
    mi[nod]=min(mi[nod*2],mi[nod*2+1]);
    if(mi[nod]==mi[nod*2])sum[nod]=sum[nod*2];
    else sum[nod]=0;
    if(mi[nod]==mi[nod*2+1])sum[nod]+=sum[nod*2+1];
}
void pushdown(int nod)
{
    if(lazy[nod]==0)return;
    mi[nod*2]+=lazy[nod];
    mi[nod*2+1]+=lazy[nod];
    lazy[nod*2]+=lazy[nod];
    lazy[nod*2+1]+=lazy[nod];
    lazy[nod]=0;   
}
void build(int nod,int l,int r)
{
	Len[nod]=b[r+1]-b[l];
	if(l==r)
	{
		sum[nod]=Len[nod];
		return;
	}
	int mid=(l+r)/2;
	build(nod*2,l,mid);
	build(nod*2+1,mid+1,r);
	pushup(nod);
}
void change(int nod,int l,int r,int L,int R,int val)
{
    if(l==L&&r==R)
    {
        mi[nod]+=val;
        lazy[nod]+=val;
        return;
    }
    pushdown(nod);
    int mid=(l+r)/2;
    if(R<=mid)change(nod*2,l,mid,L,R,val);
    else if(L>mid)change(nod*2+1,mid+1,r,L,R,val);
    else{
        change(nod*2,l,mid,L,mid,val);
        change(nod*2+1,mid+1,r,mid+1,R,val);
    }
    pushup(nod);
}
int find(int nod,int l,int r,int L,int R)
{
    if(l==L&&r==R)
    {
        if(mi[nod]>0)return Len[nod];
        return Len[nod]-sum[nod];
    }
    pushdown(nod);
    int mid=(l+r)/2;
    if(R<=mid)return find(nod*2,l,mid,L,R);
    else if(L>mid)return find(nod*2+1,mid+1,r,L,R);
    else return find(nod*2,l,mid,L,mid)+find(nod*2+1,mid+1,r,mid+1,R);
    pushup(nod);
}
bool cmp(node a,node b)
{
	return a.val<b.val;
}
signed main()
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		int x1=read(),y1=read(),x2=read(),y2=read();
		a[++gs]=(node){x1,y1,y2,1};
		a[++gs]=(node){x2,y1,y2,-1};
		b[++len]=y1;
		b[++len]=y2;
	}
	sort(b+1,b+len+1);
	len=unique(b+1,b+len+1)-b-1;
	build(1,1,len-1);
	for(int i=1;i<=gs;i++)
	{
		a[i].l=lower_bound(b+1,b+len+1,a[i].l)-b;
		a[i].r=lower_bound(b+1,b+len+1,a[i].r)-b;
	}
	sort(a+1,a+gs+1,cmp);
	int ans=0;
	for(int i=1;i<gs;i++)
	{
		if(a[i].l<a[i].r)change(1,1,len-1,a[i].l,a[i].r-1,a[i].opt);
		ans=ans+find(1,1,len-1,1,len-1)*(a[i+1].val-a[i].val);
	}
	cout<<ans;
}
```

---

## 作者：鏡音リン (赞：44)

萌新的第一发题解23333

## 本题解主要适用于不会打线段树的同学

关于扫描线的部分就不多说了，可以参照其他题解。

分析一下题目，可以用一条直线从左向右扫描所有竖直线段，每次计算这些线段的并集的长度，然后把各个子矩形的面积相加。

问题转化成了这样：

**维护一些区间，支持增加和删除区间，每次操作后求这些区间并集的长度。**

大佬们看到这个问题都会想到**线段树**

但是

# 线段树太难啦嘤嘤嘤！！

萌新刚学OI学不会！！

于是就打了分块

分块的时间复杂度是O(Nsqrt(N))的，渐进意义上比线段树的O(Nlog(N))慢。然而实际应用中它跑的并没慢到哪去

首先离散化（前面各位大佬的题解讲的很清楚，不多讲了），把1e9的范围转化成2e5

这样就可以把2e5的范围分成若干个块了。

现在考虑添加和删除区间的操作。添加的区间会包括一些完整的块，区间两端也会包括块的一部分，下面分开处理

对于完整的块，可以使用一个数组bn，bn[i]表示有多少个区间**完整地包括**了第i个块。

对于块的一部分，用数组a记录有多少个区间经过了该点。注意，这里只需统计**没有完整包括**该块的区间。修改a的时候维护一个len数组，记录每个块中由**没有完整包括**该块的区间贡献的线段长度。


查询并集长度就很简单了，枚举每个块，如果bn[i]不为0就加块的长度，如果bn[i]为0就加len[i]

上代码（略丑
```cpp
#include <cstdio>
#include <algorithm>
#define N 200000
int n, m, pt[N];		//pt数组记录离散化之前的原始坐标
struct Ed {
	int p, d, u, in;
} as[N];				//竖直线段
bool operator < (Ed a, Ed b) {
	return a.p < b.p;
}			//从左向右扫描
#define BS 500			//每个块的长度
#define BN 400			//块的最大数量
int a[N], len[BN], bn[BN], sum[BN];
inline void addp(int p, int v, int b) {
	if (!a[p]) len[b] += pt[p+1]-pt[p];//如果修改使a[i]不为零则len加上该点的长度
	a[p] += v;
	if (!a[p]) len[b] -= pt[p+1]-pt[p];//如果修改使a[i]为零则len减去该点的长度
}
void add(int x, int y, int v) {
	int xb = x/BS, yb = y/BS;
	if (xb == yb) {		//区间两端点在同一个块内
		for (int i = x; i <= y; i++) addp(i, v, xb);
		return;
	}
	for (int i = x; i < (xb+1)*BS; i++) addp(i, v, xb);		//左端点所在的块的一部分
	for (int j = xb+1; j < yb; j++) bn[j] += v;		//完整的块
	for (int i = yb*BS; i <= y; i++) addp(i, v, yb);		//右端点所在的块的一部分
}
int query() {
	int ans = 0;
	for (int i = 0; i*BS < m; i++) {
		if (bn[i]) ans += sum[i];
		else ans += len[i];
	}
	return ans;
}
int main() {
	scanf("%d", &n);
	for (int i = 0; i < n; i++) {
		scanf("%d%d%d%d", &as[i].p, pt+i, &as[i+n].p, pt+n+i);
		as[i].d = as[i+n].d = pt[i];
		as[i].u = as[i+n].u = pt[i+n];
		as[i].in = 1; as[i+n].in = -1;		//in=1表示矩形的左边界，即添加区间，in=-1表示删除区间
	}
	std::sort(as, as+2*n);
	std::sort(pt, pt+2*n);
	auto rd = std::unique(pt, pt+2*n);		//离散化
	m = rd - pt;
	for (int i = 0; i < m/BS; i++) sum[i] = pt[(i+1)*BS]-pt[i*BS];		//每个块的长度
	if (m % BS != 0) sum[m/BS] = pt[m-1]-pt[(m/BS-1)*BS];			//最后一个块的长度需要特判
	long long ans = 0; int last = 0;		//不开long long见祖宗
	for (int i = 0; i < 2*n; i++) {
		int d = std::lower_bound(pt, rd, as[i].d)-pt;
		int u = std::lower_bound(pt, rd, as[i].u)-pt;
		ans += 1ll * (as[i].p-last) * query();		//当前子矩形的宽度 * 当前的线段长度
		add(d, u-1, as[i].in);
		last = as[i].p;
	}
	printf("%lld\n", ans);
}
```


---

## 作者：CYJian (赞：32)

为啥要离散化啊。。多麻烦。。。

这里提供一种偷懒的做法：

动态开点线段树+标记永久化， 就可省略掉离散化啦！

大概的思路和其他的题解差不多， 这里就不赘述了， 下面提供做法的实现， 主要在注释中说明。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define ge getchar()
#define Re read()

inline int read() {
	int x = 0, ch;
	while(!isdigit(ch = ge)) ;
	while(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;
	return x;
}

const int MAXN = 200100;

struct Node {
	int l, r, p;

	Node() {}
	Node(int l, int r, int p):l(l), r(r), p(p) {}

	friend bool operator < (Node a, Node b) { return a.p < b.p; }
}Ins[MAXN + 1], Del[MAXN + 1];

struct Segment_Tree { // 下面是线段树
	#define ls T[x].r
	#define rs T[x].l
	
	struct Node { int l, r, sum, tg; } T[MAXN << 6]; // 每一次修改最多修改的点数有log级别， 所以动态开点要乘log（最好再乘2）
	int ct;

	inline void pushup(int x, int l, int r) {
		if(T[x].tg) T[x].sum = r - l + 1; // 如果这个点上有标记， 那么就说明被线段覆盖了， 长度就是 r-l+1
		else T[x].sum = T[ls].sum + T[rs].sum; // 没有标记就从线段树上的两个儿子节点继承
	}
// 没有pushdown 标记永久化节省空间
	inline void Modify(int&x, int l, int r, int L, int R, int v) {
		if(!x) x = ++ct; // 动态开点
		if(L <= l && r <= R) {
			T[x].tg += v; // 更新标记
			pushup(x, l, r); // 更新节点值
			return ;
		} int mid = (l + r) >> 1;
		if(L <= mid) Modify(ls, l, mid, L, R, v);
		if(mid < R) Modify(rs, mid + 1, r, L, R, v);
		pushup(x, l, r); // 别忘了更新
	}

	inline int Query() { return T[1].sum; } // 询问沿y轴截线段的长度和， 相当于是线段树的1号节点存的长度和。

	#undef ls
	#undef rs
}seg; // 上面是线段树

int main() {
	int n = Re, mi = 1e9, mx = 0;
	for(int i = 1; i <= n; i++) {
		int lx = Re, ly = Re, rx = Re, ry = Re;
		Ins[i] = Node(ly, ry, lx);
		Del[i] = Node(ly, ry, rx);
		mi = min(mi, ly);
		mx = max(mx, ry);
	} int rt = 0; long long res = 0;
	sort(Ins + 1, Ins + 1 + n); Ins[n + 1] = Node(0, 0, 2e9);
	sort(Del + 1, Del + 1 + n); Del[n + 1] = Node(0, 0, 2e9);
	for(int i = 1, a = 1, b = 1, N = n << 1, las = 0; i <= N; i++) {
		int x = min(Ins[a].p, Del[b].p);
		res += 1LL * (x - las) * seg.Query(), las = x; // 求出上次询问的横坐标差 * 当前扫描线上的沿y轴的截线段长度和。
		if(Ins[a].p == x) seg.Modify(rt, mi, mx, Ins[a].l, Ins[a].r - 1, 1), ++a; // 如果当前这个x坐标需要插入一条线段， 那么就+1
		else seg.Modify(rt, mi, mx, Del[b].l, Del[b].r - 1, -1), ++b; // 如果删除就-1
        //这一段为啥要将r-1呢？ 因为线段树里头的线段默认计算的长度为 r-l+1， 这个时候我们把r-1之后才符合计算面积的公式， 而且所有插入的线段的r都减了1之后计算并集并不会影响。
	} printf("%lld\n", res);
	return 0; // 完结撒花
} // 没有离散化真清爽啊（雾）
```

---

## 作者：saxiy (赞：14)

### 昨天出的题今天刚好学？

怎么说呢，这道题数据很毒瘤，however，我开的是 **unsigned long long**

板子题，我就不赘述过程了，选了几篇风格不同的博客，可以参考参考

1. [我参考的博客](https://blog.csdn.net/xianpingping/article/details/83032798)

2. [https://blog.csdn.net/sslz_fsy/article/details/82902644](https://blog.csdn.net/sslz_fsy/article/details/82902644)

3. [https://www.cnblogs.com/headchen/p/9172491.html](https://www.cnblogs.com/headchen/p/9172491.html)

相信你一定看懂了 ~~（就是不知道怎么码）~~

还在抓虫子？这里是你要找的虫子们 ：

~~（方法不一样就没办法了，下一篇暴力题解？）~~ 

```cpp
#include <bits/stdc++.h>
#define N 100005~
using namespace std;
~
struct LINE {
	int l, r, h, d;
	LINE() {}
	LINE(int L, int R, int H, int D):l(L), r(R), h(H), d(D) {}
	bool operator< (const LINE &o) const { return h < o.h; }
} line[N << 1];
int n, m, cnt[N << 3], a[N << 1], sum[N << 3];//随便开大点

void push_up(int l, int r, int x) {
	//记得将树节点区间转换成离散下标QWQ
	if(cnt[x]) sum[x] = a[r + 1] - a[l];
	else if(l == r) sum[x] = 0;~
	else sum[x] = sum[x << 1] + sum[x << 1 | 1];
}

void update(int l, int r, int x, int d, int sl, int sr) {
	if(sl <= l && r <= sr) {
		cnt[x] += d;
		push_up(l, r, x);
		return;
	}~
	int mid = l + r >> 1;//push_down不是必要的(见博客3)
	if(sl <= mid) update(l, mid, x << 1, d, sl, sr);//别传错参数啊
	if(sr > mid) update(mid + 1, r, x << 1 | 1, d, sl, sr);
	push_up(l, r, x);
}

void init() {
	scanf("%d", &n);
	int x1, y1, x2, y2;
	for(int i = 0;i < n;i++) {
		scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
		a[m] = x1; line[m++] = LINE(x1, x2, y1, 1);//是左下点和右上点
		a[m] = x2; line[m++] = LINE(x1, x2, y2, -1);//所以 y1 < y2
	}
	sort(a, a + m);
	sort(line, line + m);
	m = unique(a, a + m) - a;//STL的去重函数，前提是要数值有序！
}
~
void work() {
	unsigned long long ans = 0;//毒瘤数据
	for(int i = 0;i < n << 1;i++) {~
		int l = lower_bound(a, a + m, line[i].l) - a;//STL大法好
		int r = lower_bound(a, a + m, line[i].r) - a;
		update(0, m - 1, 1, line[i].d, l, r - 1);//看好你的离散区间，我的是 0 -> m-1 哦
		ans += (unsigned long long)sum[1] * (line[i + 1].h - line[i].h);//记得转换，乘积是可能爆int的QAQ
	}
	printf("%llu", ans);//输出格式是"%llu"
}

int main() {
	init();
	work();
	return 0;
}~
```

~~为什么这么短QAQ~~

###### 我才没有在代码里乱塞些什么char呢

---

## 作者：Leap_Frog (赞：13)

# P5490【模板】扫描线（题解）

### PS
这道题数据范围卡了我半天，刚开始没开$\texttt{long long}$，大红大紫。[具体记录](https://www.luogu.org/record/22357252)  
然后开了$\texttt{long long}$，大绿大紫。[具体记录](https://www.luogu.org/record/22357280)  
最后把数据范围扩大了$\texttt{10}$倍，终于$\texttt{A}$了此题。

### 题解
首先安利几篇别人的扫描线详解[其一](https://blog.csdn.net/sslz_fsy/article/details/82902644)，扫描线就是把矩形换成一条一条线，然后从左往右扫一遍。  
其他解释都在代码注释里

### 代码
```cpp
#include<bits/stdc++.h>		//我爱万能头文件
#define int long long	//不开long long见祖宗
using namespace std;
const int N=1000005;	//数据范围开大了10倍
struct line{int l,r,h,fla;inline bool operator<(line b) {return h==b.h?l>b.l:h<b.h;}}l[N];		//矩形边缘线的结构体
struct tree{int sum,len;tree() {sum=len=0;}}t[N<<2];	//线段树结构体
int n,tot=0,ans=0,y[N];
inline void update(int x,int l,int r)	//线段树的上推标记操作
{
	if(t[x].sum>0) t[x].len=y[r]-y[l];		//如果是叶节点，那么长度就是它本身的长度
	else t[x].len=t[x<<1].len+t[x<<1|1].len;	//否则长度就是左儿子与右儿子的和
}
inline void chang(int x,int l,int r,int dl,int dr,int dc)
{
	if(dl>=y[r]||y[l]>=dr) return;		//不存在这一段区间
	if(dl<=y[l]&&y[r]<=dr) t[x].sum+=dc,update(x,l,r);		//修改，加上dc
	else chang(x<<1,l,(l+r)>>1,dl,dr,dc),chang(x<<1|1,(l+r)>>1,r,dl,dr,dc),update(x,l,r);		//改左儿子，改右儿子，上推
}
signed main()
{
	scanf("%lld",&n);
	for(int i=1,x1,y1,x2,y2;i<=n;i++)	//读入
	{
		scanf("%lld%lld%lld%lld",&x1,&y1,&x2,&y2);
		l[(i<<1)-1].h=x1,l[(i<<1)-1].l=y1,l[(i<<1)-1].r=y2,l[(i<<1)-1].fla=1;
		l[i<<1].h=x2,l[i<<1].l=y1,l[i<<1].r=y2,l[i<<1].fla=-1;
		y[(i<<1)-1]=y1,y[i<<1]=y2;
	}	//读入
	n<<=1,sort(y+1,y+n+1),sort(l+1,l+n+1);	//排序，n<<=1方便操作
	for(int i=1;i<=n;i++) if(y[i]!=y[i+1]) y[++tot]=y[i];	//离散化
	for(int i=1;i<n;i++) chang(1,1,n,l[i].l,l[i].r,l[i].fla),ans+=(l[i+1].h-l[i].h)*t[1].len;	//从左向右扫一遍
	return printf("%lld\n",ans),0;	//完美的输出答案然后结束
}
```

---

## 作者：_louhc (赞：8)

这就是经典的Atlantis问题吧...  
扫描线经典题.  

![图1](https://cdn.luogu.com.cn/upload/pic/70020.png)  
图1 - 样例

我们从左到右扫描所有的纵向边.

![图2](https://cdn.luogu.com.cn/upload/pic/70021.png)  
图2 - 红色边即为依次扫描到的边.

这些边可以用一个结构体记录.需要记录横坐标,上下边界(纵坐标),是一个矩形的结束还是开始.  
扫描这些边时,我们用数据结构维护每个位置纵坐标被矩形覆盖了多少.  
如样例,当$x=100$至$x=150$时,覆盖了$y=100$至$y=200$的部分,当$x=150$至$x=200$时,覆盖了$y=100$至$y=255$的部分,以此类推.注意覆盖的部分不一定是连续的,因此我们数据结构只维护覆盖的长度,即覆盖了$y=100$至$y=200$,我们只记录覆盖长度为$100$.  
然后我们就可以每一段分别求出覆盖的面积并加起来就是答案了.

![图3](https://cdn.luogu.com.cn/upload/pic/70026.png)  
图3 - 这些面积加起来就是答案

然后我们还需要解决怎么维护覆盖长度.  
如果暴力的话复杂度就是$O(n^2)$,很明显不够优秀.  
我们可以使用线段树来维护.具体来说.就是线段树每个节点记录该节点所在区间覆盖的次数(该节点子节点就不用加上去了),是一个矩形的开始,覆盖次数$+1$,是一个矩形的结束,覆盖次数$-1$.  
如果某一个节点覆盖次数为$0$,该节点的权值(即该节点所代表区间总共覆盖的长度)就是该节点左右儿子权值和,否则该节点的权值即为该节点所在区间总长.  
因为矩形左右两边都是相等的,所以这样做是正确的.  
还有,需要注意一点,线段树维护的是每一小段区间覆盖次数,而不是点的覆盖次数,记录点的覆盖次数没有意义.  
具体请参考代码.

# 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 100005
#define i64 long long
#define open(s) freopen( s".in", "r", stdin ), freopen( s".out", "w", stdout )
#define fp( i, b, e ) for ( int i(b), I(e); i <= I; ++i )
#define fd( i, b, e ) for ( int i(b), I(e); i >= I; --i )
#define go( i, b ) for ( int i(b), v(to[i]); i; v = to[i = nxt[i]] )
template<typename T> inline void cmax( T &x, T y ){ x < y ? x = y : x; }
template<typename T> inline void cmin( T &x, T y ){ y < x ? x = y : x; }
#define getchar() ( p1 == p2 && ( p1 = bf, p2 = bf + fread( bf, 1, 1 << 21, stdin ), p1 == p2 ) ? EOF : *p1++ )
char bf[1 << 21], *p1(bf), *p2(bf);
template<typename T>
inline void read( T &x ){ char t(getchar()), flg(0); x = 0;
	for ( ; !isdigit(t); t = getchar() ) flg = t == '-';
	for ( ; isdigit(t); t = getchar() ) x = x * 10 + ( t & 15 );
	flg ? x = -x : x;
}
clock_t t_bg, t_ed;

int T, N, NN, n;
int a[MAXN << 1], b[MAXN << 1]; i64 ans;//注意ans要开long long
struct node{
	int x, u, d, v; // x表示位置,u表示上区间,d表示下区间
	bool operator < ( const node &t )const{ return x < t.x; } //按位置排序
}q[MAXN << 1];

int tr[MAXN << 3]; int s[MAXN << 3];//因为区间个数就是MAXN*2级别的,再*4就是MAXN*8
// tr表示该节点所代表区间被覆盖的长度,s表示覆盖次数

void Add( int c, int l, int r, int L, int R, int v ){
	if ( L > r || l > R ) return;
	const int mid((l + r) >> 1), ls(c << 1), rs(ls | 1);
	if ( L <= l && r <= R ) return tr[c] = !(s[c] += v) ? l == r ? 0 : tr[ls] + tr[rs] : ( b[r + 1] - b[l] ), void();
	Add( ls, l, mid, L, R, v ), Add( rs, mid + 1, r, L, R, v );
	!s[c] ? tr[c] = tr[ls] + tr[rs] : 0;
}

signed main(){
	t_bg = clock();
	read(N); NN = N << 1;
	for ( int i = 0; i < NN; i += 2 )
		read(q[i].x), read(a[i]), read(q[i + 1].x), read(a[i + 1]),
		b[i] = a[i], b[i + 1] = a[i + 1], q[i].v = 1, q[i + 1].v = -1;//+1表示该段覆盖次数+1,-1同理
	sort( b, b + NN ), n = unique( b, b + NN ) - b;//因为坐标是1e9级别的,所以需要离散化或动态开点线段树	
	for ( int i = 0, t1, t2; i < NN; i += 2 ) 
		t1 = lower_bound( b, b + n, a[i] ) - b, q[i].d = q[i+1].d = t1,
		t2 = lower_bound( b, b + n, a[i+1] ) - b, q[i].u = q[i+1].u = t2;
	sort( q, q + NN ), Add(1, 0, n - 2, q[0].d, q[0].u - 1, q[0].v);
	
	fp( i, 1, NN - 1 )
		ans += 1ll * tr[1] * ( q[i].x - q[i - 1].x ),//加上每一段
		Add( 1, 0, n - 2, q[i].d, q[i].u - 1, q[i].v );
	printf( "%lld\n", ans );
	t_ed = clock();
	fprintf( stderr, "\n========info========\ntime : %.3f\n====================\n", (double)( t_ed - t_bg ) / CLOCKS_PER_SEC );
	return 0;
}

```

---

## 作者：cscy (赞：5)

这题维护线段树好难啊（本人过于蒟蒻）

好了分享以下这题到底怎么建树

首先想明白几个问题：
1.线段树可以维护的信息必须具有什么性质？

2.题中哪些信息需要维护，其中哪些具有这一性质，哪些不具有这一性质？

3.对于不具有这一性质的信息，怎么维护？

答：

1.可加性

2.区间厚度，区间被覆盖长度， 前者不可加，后者可加


前两个问题非常显然。因为本题在扫描过程中需要随时修改覆盖，并随时查询被覆盖长度。那么问题就变成了如下：

有一个区间[1，mx]， 每次在[l, r]上进行区间加1 或者区间减1， 每次查询有多长的区间不是零。

那么显然有两个重要信息：

1. 区间[l，r]中， 不是是0的长度len。

2. 区间[l，r]中， 每个子区间被覆盖的厚度


第一条信息是答案，第二条信息的意义在于进行减操作时，可以知道本区间有没有被减为0。 设想不维护第二条信息的话，如果本区间实际被覆盖了2次，那么减1的时候你就不知道有没有被减为0。进而无法修改第一条信息，进而答案无从得知。

好了，到这里，显然如果我们知道了[l,mid]和[mid,r]两个区间的覆盖长度len1， len2， 那么对于区间[l,r] 的区间覆盖长度len可以直接由 len1， len2 得知，即

len = len1 + len2

不过有一个条件，[l，r] 已经不能被整体覆盖

那么如果[l，r]被整体覆盖了呢？

显然len = r-l

现在对于开头第三个问题，有没有什么想法？

对于线段树每一个节点代表的区间，维护一个信息：该区间被整体覆盖的次数，这样，该信息就不需要进行合并，换句话说，每一个节点代表的区间的被覆盖厚度，与其他节点无关。

那么继续仔细想想，如何修改？

如果当前修改为[L,R] 区间加1，那么就可以用普通区间修改的思路，把[L,R]分解为线段树上的区间， 每个区间的覆盖厚度+1， 并且改其len = r-l

如果-1， 那就先用区间加的思路-1， 检查当前区间覆盖厚度是否为0，如果为0， 那么区间覆盖长度len = len1 + len2 （len1，len2为len的子区间的覆盖长度，就是节点node的子节点对应的覆盖长度）

好了，修改完全行得通，时间复杂度logn

查询呢？

无脑查询根节点即可（逃）

至此，时间复杂度nlogn


注意：
1.本题线段树使用的是实数区间，不是整数数列！因此区间需要仔细考虑边界！

2.请使用unsigned long long 记录答案！

3. 因为是实数区间，所以线段树数组开四倍不够！本人开了四十倍.


如果需要代码，提交记录里搜本人即可




---

## 作者：XHCuteDog (赞：4)

# 不得不有些庆幸，居然你谷还有无题解的题，那我就成为这第一人吧！
## [题目传送门](https://www.luogu.org/problem/P5490)
# 对于这种题我们的正解就是线段树套扫描线，听起来是不是逼格很高。
## 一、什么是扫描线
## 什么是扫描法？有什么用？怎么用？
可以想象成一根假想的线，将图从左往右或从右往左或自下而上或自上而下“扫描”一遍，至于扫描的是什么则根据具体应用选择。扫描线可以计算矩形面积、周长，可以计算线段交点，可以实现多边形扫描转换，在图的处理方面经常用到。
 
面对这个问题，首先的问题是，计算机要怎么保存这张图这些矩形？从刚才的过程，我们不难发现，我们只需要保存这张图里面的所有水平的边即可。对于每条边，它所拥有的属性是：这条边的左右端点（的横坐标），这条边的高度（纵坐标），这条边属于矩形的上边还是下边（想想为什么保存这个属性）刚刚计算中我们遇到两个蓝色矩形的一部分一眼就能看出这两个蓝色矩形的‘宽’是多少，用计算机怎么做到？
## 线段树华丽登场!
 我们以整个图最左边的竖线作为区间左端点，最右边的竖线作为区间右端点，去维护这个区间的有效长度（即被覆盖的长度）比如扫到第2条边的时候，有效长度就是两个蓝色矩形的宽之和。这样，我们用扫描线去扫描每一条边的时候，都需要更新线段树的有效长度是如何更新的呢？如果扫到的这条边是某矩形的下边，则往区间插入这条线段如果扫到的这条边是某矩形的上边，则往区间删除这条线段为什么？自己试着模拟一下就不难发现：因为我们是自下而上的扫这个图，扫到下边相当于刚刚进入一个矩形，扫到上边则是要离开一个矩形利用线段树把每条边的有效长度找到了，也就是找到了每部分的所有矩形的总宽，那么高呢？高就简单多了，对于所有的边，按照高度从小到大排列，那么矩形高就是每相邻边之间的高度差
### 由于蒟蒻不会插入图片，所以如何根据语言描述去画图推演就靠大家辽，AC呈上
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
struct edge{
    int h,lx,rx,s;
    bool operator < (const edge &b) const
    {
        return h<b.h;
    }
}line[20005];
struct sd{
    int son[2],l,r,len,s;
}t[200005]; 
int X[20005];
int cnt;
void create(int &v,int l1,int r1)
{
    cnt++;
    v=cnt;
    t[v].l=l1;
    t[v].r=r1;
    if(l1==r1) 
      return;
    int mid=(l1+r1)>>1;
    create(t[v].son[0],l1,mid);
    create(t[v].son[1],mid+1,r1);
}
int find(int l1,int r1,int key)
{
    while(l1<=r1)
    {
        int mid=(l1+r1)/2;
        if(X[mid]==key) return mid;
        else
        if(X[mid]<key) l1=mid+1;
        else r1=mid-1;
    }
}
void pushup(int v) 
{
    if(t[v].s)
        t[v].len=X[t[v].r+1]-X[t[v].l]; 
    else
    if(t[v].l==t[v].r)
      t[v].len=0;
    else
      t[v].len=t[t[v].son[0]].len+t[t[v].son[1]].len;
}
void update(int v,int l1,int r1,int c) 
{
    if(t[v].l==l1 && t[v].r==r1)
    {
        t[v].s+=c;
        pushup(v);
        return;
    }
    int mid=(t[v].l+t[v].r)>>1;
    if(l1>mid) 
      update(t[v].son[1],l1,r1,c);
    else  
    if(r1<=mid) 
      update(t[v].son[0],l1,r1,c);
    else
    {
      update(t[v].son[0],l1,mid,c);
      update(t[v].son[1],mid+1,r1,c);
    }
    pushup(v);
}
int main()
{
    int n;
    scanf("%d",&n);
    int tot=0;
    for(int i=1;i<=n;i++)
    {
        int x1,x2,y1,y2;
        scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
        tot++;
        line[tot].lx=x1;
        line[tot].rx=x2;
        line[tot].h=y1;
        line[tot].s=1;
        X[tot]=x1;
        tot++;
        line[tot].lx=x1,line[tot].rx=x2,line[tot].h=y2,line[tot].s=-1;
        X[tot]=x2;
    }
    sort(X+1,X+1+tot);
    sort(line+1,line+1+tot);
    int root;
    create(root,1,tot);
    int k=0;
    for(int i=1;i<=tot;i++)//去重;
      if(X[i]!=X[i+1])
        X[++k]=X[i];
    long long ans=0;
    for(int i=1;i<=tot;i++)
    {
        int ll=find(1,k,line[i].lx);
        int rr=find(1,k,line[i].rx)-1; 
        update(1,ll,rr,line[i].s);
        ans+=(line[i+1].h-line[i].h)*t[1].len; 
    }
    printf("%lld",ans);
    system("pause");
    return 0;
}

```
[蒟蒻的藏宝匣子](https://www.luogu.org/blog/sshilyzyx/)

---

## 作者：Gumbo (赞：1)

这个文档主要讲了作者对于扫描线的一些理解，以及一种实现方式。

扫描线，可以用来解决多边形的面积并问题，也可用于解决多边形的周长并问题，这里只讲面积并。

---

扫描线思想：你将几个长方形放在一个坐标系中，使得每个长方形的每一条边都与坐标轴垂直，然后想象着一条水平（竖直）的线从左（下）向右（上）滑过，将整个图形沿着每条边所在的直线切成若干个互不相交的矩形，以此来计算总面积。

假设我们的原图是这样的：

![原图](https://cdn.luogu.com.cn/upload/image_hosting/l7253rr9.png)

那么经过分割之后，它是这样的：

![a](https://cdn.luogu.com.cn/upload/image_hosting/63x23x7z.png)

我用不同的色块标明了不同次分割的面积。

这样，我们就把几个复杂的多边形转化为了有限个互不相交的矩形。

那么我们的根本思路就来了：

> 每分割出一部分矩形，我们就将其面积统计入答案。
>
> 它的长度就是该段所有割线的长度并，宽度就是这次移动的长度，相乘就可以得到面积。
>
> 由于矩形两两不相交，我们的总面积就是每一步的简单加和。

---

现在，我们来口胡一下代码思路：

- 分割出一部分矩形
- 求该段割线的长度并
- 求这次移动的宽度
- 相乘得到面积，并加到总面积里
- 继续下一次切割

那我们就来一步一步将口胡变成代码。

---

> 敲代码的魅力之一就在于，它能将你的想法完全付诸实践。
>
> 如果做得好，你的代码会完全照你说的做，这是任何其它事物所难以做到的。

这就是我码代码的根本原因：舒坦。

好了，闲话少说，开始在口胡流程后口胡细节实现。~~还是口胡~~

---

为了分割出一部分矩形，我们首先要找到分割的位置。

很容易发现，我们的切割位置就是每条与扫描线平行的边的位置。

所以我们只需要将每条需要处理的边存起来，然后依次处理即可。

---

接下来是求割线的长度并，这里是最核心也是最难的点，我们先放一放。

---

求移动的宽度不难，在将需要的边存起来并排序之后，我们只要将这次移动的末位置（也就是边的横坐标）减去这次移动的初位置（上一条边的横坐标），就能得到宽度。

---

求面积啥的是小学知识，大家都会吧。

这里提供面积公式：$面积=长\times宽$

然后把求得的面积加到总面积里面，就完成了这次分割的统计工作。

---

好吧，最终还是躲不过求长度并，那好吧，讲。

首先，我们考虑最朴素的做法：

找到这条边之后，遍历每个长方形，各自找到与这条边所在直线相交的长度与位置，然后求一下并。

这个方法想都不用想，因为朴素做法肯定是错的。（狗头）

然后我们稍微把这个跑 $10^5$ 的数据需要好几年的算法改进一下：

我们可以利用线性算法的思想，利用一个数组来维护现在线段上每个点被覆盖的次数，然后通过差分来进行修改。

可以发现，我们的算法以空间为代价，将时间压缩到了一年以内。

（但是空间可能塞满 CCF 评测机的所有内存池还不够）

这个方法还需要改进。

我们继承这个核心思想：一直维护着每个点被覆盖的次数。

为了进一步的降低时间消耗，我们可以引入线段树。

但是，似乎 CCF 的评测机内存占用比上次还多一倍呢。

为了降低空间消耗，我们传统的方法有什么？

**离散化！**

说得好，但我不会。（狗头）

我选择了我的传统艺能：动态开点线段树。

这种线段树能将空间压缩到极致，并且复杂度丝毫不变。

具体思路就是：你只有需要用的时候再创建你需要的这个节点，用不到的就先放着，没准这辈子用不上了。

好嘞，口胡环节结束，活动一下，接下来开始真刀真枪地写代码。

---

我们先来写一下代码框架，然后慢慢补充。

```cpp

#include<bits/stdc++.h>
using namespace std;
//线段树
int main(){
    int n;
    //输入
    //枚举矩形，将边存起来
    //按横坐标排序边，方便之后处理
    //枚举边，统计并处理
    //输出答案并AC
}
```

怎么样，看起来是不是很简单？

那我们稍微展开一下：

---

首先，线段树。

最麻烦，我们先放一放。

---

输入。

强调一点，不要用 `y2`，否则死都不知道怎么死的。

学会善用下划线。

`scanline_signedint_function_main_signedint_y2`

当然只用 `y_2` 也可以

---

存边。

这里可以这么实现：

```cpp
vector<pair<int,pair<pair<int,int>,int>>>lines;
for(/*这里遍历矩形*/){
    lines.push_back({x_1, {{y_1, y_2 - 1}, 1}});
    lines.push_back({x_2, {{y_1, y_2 - 1}, -1}});
}
```

`vector` 里面的元素组成如下：

`pair<横坐标,pair<pair<纵坐标起始,纵坐标结束>,处理后的层数变化>>`

至于 `y_2` 为什么要减去 1，其实很简单：

这个矩形的右边对应的那一列方格并不在矩形中。

---

排序，由于我们善用了 `std::pair`，所以现在可以直接 `std::sort`。

```cpp
sort(lines.begin(),lines.end());
```

---

枚举边并处理，这个需要等讲完线段树才能讲明白。

---

输出答案，没什么问题，但是想要 AC，那就是细节问题了，我还是先讲线段树吧。

---

该来的来了，线段树他来了。

先上动态开点线段树基本框架：

```cpp
struct node {
    int time;
    int L;
    int R;
    node *lc, *rc;
    int lazy;
    int length;
    void pushdown(void){
        //下传懒标记
    }
    void pushup(void) {
        //维护并上传信息
    }
    void change(int l, int r, int x) {
        if (l <= L && r >= R) {
            //处理全包含
            return;
        }
        pushdown();
        if (lc == nullptr && rc == nullptr) {
            lc= new node;
            rc= new node;
            //孩子的初始值设定
        }
        if (l <= ((L + R) >> 1)) {
            lc->change(l, r, x);
        }
        if (r > ((L + R) >> 1)) {
            rc->change(l, r, x);
        }
        pushup();
    }
};
```

这就是动态开点线段树的一般框架，显然线段树上的修改需要懒标记，我就随手加上了。

---

接下来是口胡时间。（口胡结束了，但没完全结束）

我们需要的是什么信息？没错，就是该节点中被覆盖至少一次的长度。

所以这就是我们要维护的 `length`。

同时，为了确定某段减去一次后还有没有，我们要维护该段被完全覆盖的次数，即 `time`。

我们先来确定一下线段树上每个点表示的状态的意义，尤其是 `lazy` 这个容易弄错顺序的东西。

这里我设定含义如下：

该点的 `lazy` 表示，该点已经被覆盖过，但还没将信息下传到孩子的次数。

也就是说，我们的 `pushdown` 不会影响该点本身的数据，而只是单纯地将懒标记下传到子节点（如果有）。

先写一下 `pushup`。

先来确定一下这个函数需要实现的功能。

首先，如果这个节点有儿子，那么它的覆盖次数应该是儿子中较小的覆盖次数加上还未下传到儿子的。（就是懒标记）

如果至少被覆盖了一次，那么覆盖的长度就是整个区间。

否则，就应该是两个儿子的覆盖长度和。

所以在我们的设想中，`pushup` 应该是这样的。

```cpp
void pushup(void){
    if(lc!=nullptr&&rc!=nullptr){
        time=min(lc->time,rc->time)+lazy;
    }
    if(time>0)
        length=R-L+1;
    else{
        if(lc==nullptr&&rc==nullptr)
            length=0;
        else
            length=lc->length+rc->length;
    }
}
```

看起来没有问题，将我们的想法完美实现。

那我们来写一下  `pushdown`：

```cpp
void pushdown(void){
    if(lc){
        lc->lazy+=lazy;
        lc->time+=lazy;
        lc->pushup();
    }
    if(rc){
        rc->lazy+=lazy;
        rc->time+=lazy;
        rc->pushup();
    }
    lazy=0;
}
```

ok，这样我们的 `pushdown` 就完工了。

之后由于每次我们只需要查询根节点（即整棵树）的覆盖长度，所以我们不必单独写一个查询函数。

我们只需要实现修改操作即可。

那就开始写吧：

```cpp
void change(int l,int r,int x){
    if(l<=L&&r>=R){
        pushdown();
        time+=x;
        lazy+=x;
        pushup();
        return;
    }
    pushdown();
    if(lc==nullptr&&rc==nullptr){
        lc=new node;
        rc=new node;
        lc->L=L;
        lc->R=(L+R)>>1;
        rc->L=lc->R+1;
        rc->R=R;
        lc->time=rc->time=time;
        lc->lazy=rc->lazy=0;
        lc->lc=lc->rc=rc->lc=rc->rc=nullptr;
        lc->pushup();
        rc->pushup();
    }
    if(l<=((L+R)>>1)){
        lc->change(l,r,x);
    }
    if(r>((L+R)>>1)){
        rc->change(l,r,x);
    }
    pushup();
}
```

完美。

---

然后就是枚举边并处理了，这个其实就是调用线段树的修改函数，我们把主函数写一下：

```cpp
int main(){
    int n;
    scanf("%d",&n);
    int x_1,y_1,x_2,y_2;
    for(int i=0;i<n;++i){
        scanf("%d%d%d%d",&x_1,&y_1,&x_2,&y_2);
        lines.push_back({x_1,{{y_1,y_2-1},1}});
        lines.push_back({x_2,{{y_1,y_2-1},-1}});
    }
    node*root=new node;
    root->L=0;
    root->R=1000000000;
    root->lazy=0;
    root->time=0;
    root->length=0;
    root->lc=root->rc=nullptr;
    sort(lines.begin(),lines.end());
    long long ans=0;
    for(int i=0;i<(int)lines.size();++i){//从这里开始
        if(i!=0)
            ans=ans+(long long)root->length*(lines[i].first-lines[i-1].first);
        root->change(lines[i].second.first.first,lines[i].second.first.second,lines[i].second.second);
    }//到这里结束
    printf("%lld\n",ans);
    return 0;
}
```

枚举边并处理的位置我用注释标出来了。

首先枚举边，我们如果直接 `auto` 枚举的话，想看前一个的横坐标就很麻烦，不如用最普通的枚举。

当然如果你是 `C++14` 的狂热粉丝，那用 `auto` 也行。

给你一个参考代码：

```cpp
int lst=-1;
for(auto i:lines){
    if(lst!=-1)
        ans=ans+(long long)root->length*(i.first-lst);
    root->change(i.second.first.first,i.second.first.second,i.second.second);
    lst=i.first;
}
```

还可以用迭代器：

```cpp
for(auto i=lines.begin();i!=lines.end();++i){
    if(i!=lines.begin())
        ans=ans+(long long)root->length*(-(--i)->first+(++i)->first);
    root->change(i->second.first.first,i->second.first.second,i->second.second);
}
```

迭代器的写法不要求掌握，但是 `auto` 的和枚举下标的最好都学一下。

我们以 `auto` 的为例来讲一下：

我们需要上一个的横坐标，而 `auto` 枚举不能往回走，所以我们需要记下我们需要的东西。

由于横坐标从 0 开始，所以我们用 -1 做初始不会出问题。

然后，如果不是第一个，那么就将面积计算并累加。

无论是不是第一个，我们都对其进行处理，具体每个参数是干啥的可以参考之前存边的时候是怎么存的。

好了，大功告成，准备 AC。

---

这里是题目链接：

[P5490](https://www.luogu.com.cn/problem/P5490)

当你好不容易拼凑出了你认为正确的代码，交上去却得了 0 分，还有很多 `MLE` 的时候，先别急着找你的错误，因为刚才那种方法本身就是有一些细微的问题的。

你先不用管 `MLE`，稍后会处理。

建议你自己找一找，稍后我会告诉你在哪，但是我希望你能依靠自己的力量找到它。

建议先不要看下面的答案和提示。

---

提示 1：这个错误在线段树上。

希望你看了之后能找到。

---

提示 2：在 `pushup`。

你看出哪里出问题了吗？

---

以下是答案：

我们把 `pushup` 抄在下面：

```cpp
void pushup(void){
    if(lc!=nullptr&&rc!=nullptr){
        time=min(lc->time,rc->time)+lazy;
    }
    if(time>0)
        length=R-L+1;
    else{
        if(lc==nullptr&&rc==nullptr)
            length=0;
        else
            length=lc->length+rc->length;
    }
}
```

就是最后一步，如果没有被完全覆盖，并且有儿子的情况。

思路没有问题，就是两个儿子的覆盖长度和。

但是，你有没有考虑这样一个问题：

假设你这个点是这次修改触及的最深的点，而且是减去了一次，让这个区间没有被覆盖，会怎么样？

很简单，这个点的儿子并没有得到更新，它们的 `length` 没有变。

所以我们可以简单 `pushdown` 一下，来处理这个问题：

```cpp
void pushup(void){
    if(lc!=nullptr&&rc!=nullptr){
        time=min(lc->time,rc->time)+lazy;
    }
    if(time>0)
        length=R-L+1;
    else{
        if(lc==nullptr&&rc==nullptr)
            length=0;
        else{
            pushdown();
            length=lc->length+rc->length;
        }
    }
}
```

我们再来提交一遍，很好，我们拿到了 20 分，看起来只要解决掉空间的问题我们就可以 AC 了。

如何解决空间问题呢？我们一般有如下两种方式。

- 尽量压缩需要的空间
- 将用不到的空间释放

由于这里我们是动态开点线段树，所以我们可以采用第二种方法。

只要在 `pushup` 的最后加上这些：

```cpp
if(lc!=nullptr&&lc->lc==nullptr&&lc->rc==nullptr&&rc!=nullptr&&rc->lc==nullptr&&rc->rc==nullptr&&lc->time==rc->time){
    delete lc;
    delete rc;
    lc=rc=nullptr;
}
```

我们来看一下这段代码。

首先，我们如果左右两个儿子都是没有儿子的节点（当然自己要先有左右儿子），也就是说左右两个儿子是叶子，并且两个儿子的覆盖次数一样。

这说明什么？

这说明儿子的覆盖次数和这个点完全一样，也就是说两个儿子事实上没有分开存储的必要了，这一个点就能完成需要。

那么我们就可以去掉两个没用的儿子了（清理门户）。

然后提交一下。

结果还是 20 分，不过 `MLE` 已经解决了，只剩 `TLE` 了。

这也算是一个成功，因为 `TLE` 至少不像 `MLE` 一样令人绝望。

休息一下，接下来要开正解了。

---

我们来看看到底是哪里拖慢了复杂度。

很显然，因为 `pushup` 里面的这个 `pushdown` 有可能一直间接递归下去，造成更新整个子树。

所以，事情好像不太对劲起来。

我们如果不更新儿子，那么这个点就没法保证正确。

如果更新了儿子，那么就 `TLE`。

所以，真的没有办法了吗？

并不是。

既然是标记下传的问题，那么我们干脆不下传了。

这就要引入一个方法：标记永久化。

先来看看这个方法的适用条件：

> 确保标记不会溢出（比如爆 `int`、爆 `long long`）

没了，就这一条。

来看这个方法的核心思想：

将标记固定在最开始添加标记的点上，向下时一路累加，向上时一路修改。

在我们这个代码中，这个技巧并不复杂：

将 `time` 作为“能覆盖这个节点但不能覆盖父亲的线的个数”。

所以我们可以删掉 `pushdown` 了。

然后将 `pushup` 修改如下：

```cpp
void pushup(void) {
    if(time!=0){
        length=R-L+1;
    }//如果被覆盖了
    //如果有祖先被覆盖，那么这个点的数据就没有意义，可以不用维护。
    //这个length表示如果不考虑祖先的影响，这个点的覆盖长度是多少。
    else{
        if(lc!=nullptr&&rc!=nullptr){
            length=lc->length+rc->length;
        }//因为祖先不影响后代，所以自己也不会影响儿子，直接用就行。
        else{
            length=0;
        }
    }
    if(lc!=nullptr&&rc!=nullptr&&lc->lc==rc->rc&&lc->time==rc->time){
        delete lc;
        delete rc;
        lc=rc=nullptr;
    }
}
```

将修改函数也稍微做一些调整：

```cpp
void change(int l, int r, int x) {
    if (l <= L && r >= R) {
        time+= x;
        pushup();
        return;
    }
    if (lc == nullptr && rc == nullptr) {
        lc= new node;
        rc= new node;
        lc->L= L;
        lc->R= (L + R) >> 1;
        rc->L= lc->R + 1;
        rc->R= R;
        lc->time= rc->time= 0;
        lc->lc= lc->rc= rc->lc= rc->rc= nullptr;
        lc->pushup();
        rc->pushup();
    }
    if (l <= ((L + R) >> 1)) {
        lc->change(l, r, x);
    }
    if (r > ((L + R) >> 1)) {
        rc->change(l, r, x);
    }
    pushup();
}
```

最大的改变也就是删除了 `pushdown`，并且删除了 `lazy`，其他的并没有变化。

---

恭喜你看到了最后，想必你已经通过了这个题，如果没有，下面是我的代码，你可以对照一下哪里有细节错误。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct node {
    int L;
    int R;
    node *lc, *rc;
    int time;
    int length;
    void pushup(void) {
        if(time!=0){
            length=R-L+1;
        }
        else{
            if(lc!=nullptr&&rc!=nullptr){
                length=lc->length+rc->length;
            }
            else{
                length=0;
            }
        }
        if(lc!=nullptr&&rc!=nullptr&&lc->lc==rc->rc&&lc->time==rc->time){
            delete lc;
            delete rc;
            lc=rc=nullptr;
        }
    }
    void change(int l, int r, int x) {
        if (l <= L && r >= R) {
            time+= x;
            pushup();
            return;
        }
        if (lc == nullptr && rc == nullptr) {
            lc= new node;
            rc= new node;
            lc->L= L;
            lc->R= (L + R) >> 1;
            rc->L= lc->R + 1;
            rc->R= R;
            lc->time= rc->time= 0;
            lc->lc= lc->rc= rc->lc= rc->rc= nullptr;
            lc->pushup();
            rc->pushup();
        }
        if (l <= ((L + R) >> 1)) {
            lc->change(l, r, x);
        }
        if (r > ((L + R) >> 1)) {
            rc->change(l, r, x);
        }
        pushup();
    }
};
vector<pair<int, pair<pair<int, int>, int>>> lines;
int main() {
    int n;scanf("%d",&n);
    int x_1, y_1, x_2, y_2;
    for (int i= 0; i < n; ++i) {
        scanf("%d%d%d%d",&x_1,&y_1,&x_2,&y_2);
        lines.push_back({x_1, {{y_1, y_2 - 1}, 1}});
        lines.push_back({x_2, {{y_1, y_2 - 1}, -1}});
    }
    node* root= new node;
    root->L= 0;
    root->R= 1000000000;
    root->time= 0;
    root->length= 0;
    root->lc= root->rc= nullptr;
    sort(lines.begin(), lines.end());
    long long ans= 0;
    for (int i= 0; i < (int)lines.size(); ++i) {
        if (i != 0) {
            ans= ans + (long long)root->length * (lines[i].first - lines[i - 1].first);
        }
        root->change(lines[i].second.first.first, lines[i].second.first.second, lines[i].second.second);
    }
    printf("%lld\n", ans);
    return 0;
}
```

我这个码风是编辑器的自动格式化，所以略显蓬松。

---

***The End***


---

## 作者：斗神_君莫笑 (赞：1)

这个算法的本质不难理解  
就是线段树从左到右维护区间面积并，每次和x间距相加  
但是离散化后实现需要很多细节  
经过一通离散化，我们的目的是将p内按照x坐标存入每段线段离散化后的xy值      
lsx和lsy对应离散化后p[x]p[y]所对应的数值   
在此参见代码   

```cpp
#include<bits/stdc++.h>
#define int long long
#define lc (p<<1)
#define rc (p<<1|1)
using namespace std;
struct Point{
	int x1,x2,y1,y2;
}q[200010];
struct Seg{
	int y1,y2,x,kind;
}p[200010];
int cnt;
bool cmp(const Seg &xx,const Seg &yy){
	return xx.x<yy.x;
}
int lsx[200010],lsy[200010],cntx,cnty;
int find(int*ls,int cnt,int x){//使用指针就可以不用写两个find 
	int l=1,r=cnt+1;
	while(l<r){
		int mid=(l+r)>>1;
		if(ls[mid]<x)l=mid+1;
		else r=mid;
	}
	return l; 
}
struct Node{
	int l,r,lazy,sum,ans;
}T[800010];
void build(int p,int l,int r){
	T[p].l=l;T[p].r=r;
	if(l==r){
		T[p].sum=lsy[l+1]-lsy[l];//两个y坐标的差值 
		return;
	}
	int mid=(l+r)>>1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	T[p].sum=T[lc].sum+T[rc].sum;
} 
inline void pushup(int p){
	if(T[p].lazy)T[p].ans=T[p].sum;
	else if(T[p].l!=T[p].r)T[p].ans=T[lc].ans+T[rc].ans;
	else T[p].ans=0;
}
void update(int p,int ql,int qr,int v){
	if(ql<=T[p].l&&T[p].r<=qr){
		T[p].lazy+=v;
		pushup(p);
		return;
	}
	int mid=(T[p].l+T[p].r)>>1;
	if(ql<=mid)update(lc,ql,qr,v);
	if(qr>mid)update(rc,ql,qr,v);
	pushup(p);//printf("%d %d\n",p,T[p].ans);
}
signed main(){
	int n;
	scanf("%lld",&n);
	for(int i=1;i<=n;++i){
		scanf("%lld%lld%lld%lld",&q[i].x1,&q[i].y1,&q[i].x2,&q[i].y2);
		lsx[++cntx]=q[i].x1;lsx[++cntx]=q[i].x2;
		lsy[++cnty]=q[i].y1;lsy[++cnty]=q[i].y2;
	}
	sort(lsx+1,lsx+cntx+1);
	cntx=unique(lsx+1,lsx+cntx+1)-lsx-1;
	sort(lsy+1,lsy+cnty+1);
	cnty=unique(lsy+1,lsy+cnty+1)-lsy-1;
	//unique默认返回一个指向去重后序列最后一个元素后方的指针   
	for(int i=1;i<=n;++i){
		q[i].x1=find(lsx,cntx,q[i].x1);
		q[i].x2=find(lsx,cntx,q[i].x2);
		q[i].y1=find(lsy,cnty,q[i].y1);
		q[i].y2=find(lsy,cnty,q[i].y2);
		//将q的xy值复用为离散化后的xy值  
		p[++cnt]=(Seg){q[i].y1,q[i].y2-1,q[i].x1,1};
		p[++cnt]=(Seg){q[i].y1,q[i].y2-1,q[i].x2,-1};
		//如果y2没有-1就会出现区间重复,画图可证 
	}
	sort(p+1,p+cnt+1,cmp);
	//经过一通离散化，我们的目的是将p内按照x坐标存入每段线段离散化后的xy值  
	//lsx和lsy对应离散化后p[x]p[y]所对应的数值 
	build(1,1,cnty);
	long long ans=0;
	for(int i=1;i<=cnt;++i){
		ans+=T[1].ans*(lsx[p[i].x]-lsx[p[i-1].x]);
		//用区间并乘上两段x的距离就是这一段的面积 
		update(1,p[i].y1,p[i].y2,p[i].kind);//新加入一条线段 
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：Jμdge (赞：1)

ORZ 数组开小调了一万年的 ZJQ

# Pre

算法： 线段树（扫描线）

思想： 离散化


简要说明一下就是利用线段树维护存在覆盖的区间总长，然后离散地去 $O(n)$ 统计每一个 x 间隔的贡献

具体实现要用离散，并且要让线段树上的每个点表示该点对应的右端点向左的一小段区间





# code

```cpp
//by Judge
#include<bits/stdc++.h>
#define Rg register
#define int long long
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
#define go(G,u) for(Rg int i=G.head[u],v=G.e[i].to;i;v=G.e[i=G.e[i].nxt].to)
#define open(S) freopen(S".in","r",stdin),freopen(S".out","w",stdout)
#define ull unsigned long long
using namespace std;
const int M=4e5+3;
typedef int arr[M];
typedef int TRR[M<<2];
#ifdef online_judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){ int x=0,f=1; char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,m,cnt; ull ans; arr b; TRR t,len,sum;
struct node{ int x,op,l,r; }op[M<<1];
inline bool cmp(node a,node b){
	return a.x^b.x?a.x<b.x:a.op<b.op;
}
#define ls k<<1
#define rs k<<1|1
#define lson ls,l,mid
#define rson rs,mid+1,r	
void build(int k,int l,int r){ if(l==r) return len[k]=b[l]-b[l-1],void();
	int mid=(l+r)>>1; build(lson),build(rson),len[k]=len[ls]+len[rs];
}
void update(int k,int l,int r,int L,int R,int v){ if(l>R||L>r) return ;
	if(L<=l&&r<=R) return t[k]+=v,sum[k]=t[k]>0?len[k]:sum[ls]+sum[rs],void();
	int mid=(l+r)>>1; update(lson,L,R,v),update(rson,L,R,v); if(t[k]<=0) sum[k]=sum[ls]+sum[rs];
}
signed main(){
	n=read();
	fp(i,0,n-1){
		Rg int x1=read(),y1=read(),x2=read(),y2=read(); b[++m]=y1,b[++m]=y2;
		op[++cnt]=(node){x1,1,y1,y2},op[++cnt]=(node){x2,-1,y1,y2};
	}
	sort(b+1,b+1+m),m=unique(b+1,b+1+m)-b-1;
	fp(i,1,cnt){
		op[i].l=lower_bound(b+1,b+1+m,op[i].l)-b;
		op[i].r=lower_bound(b+1,b+1+m,op[i].r)-b;
	}
	sort(op+1,op+1+cnt,cmp),build(1,1,m);
	update(1,1,m,op[1].l+1,op[1].r,op[1].op);
	fp(i,2,cnt){
		ans+=1ull*(op[i].x-op[i-1].x)*sum[1];
		update(1,1,m,op[i].l+1,op[i].r,op[i].op);
	} return !printf("%llu\n",ans);
}
```


---

## 作者：Dolphin_ (赞：0)

### 扫描线

	大佬们已经讲的很清楚了，我想补充一些细节
- 众所周知线段树大小要开4倍，但这道题每个矩形存的是两条边，所以要开8倍
- 将点离散化后与原坐标比较的时候右端点要+1，可以理解成x[i]表示[x[i],x[i+1]]
- 很多人不理解为什么线段树可以不用下传操作，这是因为每一个矩形都有两条边，都是加边先进，减边再出，所以可以保证线段树中每个节点都有值，所以不用标记下传
- 值域非常大，注意开long long

巨丑的代码
```cpp
/*
 * @Author: Dolphin_ 
 * @Date: 2019-08-20 16:36:50 
 * @Last Modified by: Dolphin_
 * @Last Modified time: 2019-08-20 17:26:36
 */
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define FOR(i, a, b) for (int i = a; i <= b; ++i)
#define _FOR(i, a, b) for (int i = a; i >= b; --i)
#define INF 0x7fffffff
inline void read(ll &x)
{
    int f=1;x=0;char s=getchar();
    while(s>'9'||s<'0'){if(s=='-')f=-1;s=getchar();}
    while(s<='9'&&s>='0'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
ll x[110000<<1],n,LineNum,cnt,ans,x_,x__,y_,y__;
struct node
{
    ll l,r,sum,len;
}tree[110000<<3];
struct node1{
	ll l,r,c,h;
	bool operator <(const node1& a)const
	{
		return h<a.h;
	}
}line[110000<<1];
void pushup(ll rt)
{
    ll l=tree[rt].l;ll r=tree[rt].r;
    if(tree[rt].sum)
        tree[rt].len=x[r+1]-x[l];
    else
    {
    	if(l==r)tree[rt].len=0;
		else tree[rt].len=tree[rt<<1].len+tree[(rt<<1)|1].len;
	}
}
void build(ll rt,ll l,ll r)
{
    tree[rt].l=l;tree[rt].r=r;tree[rt].len=0;tree[rt].sum=0;
    if(l==r) return ;
    ll mid=(l+r)>>1;
    build(rt<<1,l,mid);
    build((rt<<1)|1,mid+1,r);
    return;
}
void edit(ll rt,ll L,ll R,ll c)
{
    ll l=tree[rt].l;ll r=tree[rt].r;
    if(x[r+1]<=L||x[l]>=R) return ;
    if(L<=x[l]&&R>=x[r+1])
    {
        tree[rt].sum+=c;
        pushup(rt);
        return;
    }
    edit(rt<<1,L,R,c);
    edit((rt<<1)|1,L,R,c);
    pushup(rt);
    return;
}
int main()
{
    //freopen("a.in","r",stdin);
    read(n);
    FOR(i,1,n)
    {
        read(x_);read(y_);read(x__);read(y__);
        x[++cnt]=x_;x[++cnt]=x__;
        line[++LineNum].l=x_;line[LineNum].r=x__;
        line[LineNum].h=y_;line[LineNum].c=1;
        line[++LineNum].l=x_;line[LineNum].r=x__;
        line[LineNum].h=y__;line[LineNum].c=-1;
        //这里其实可以不用搞这么多变量的
    }
    sort(x+1,x+1+cnt);//离散化
    sort(line+1,line+1+LineNum);//从下到上扫边
    ll tot=unique(x+1,x+1+cnt)-x-1;//unique去重大法好啊
    build(1,1,tot-1);//建线段树，最后一个节点不存在，因为提示2
    
    ans=0;
    FOR(i,1,LineNum-1)//最后一条线不用处理
    {
        edit(1,line[i].l,line[i].r,line[i].c);
        ans+=tree[1].len*(line[i+1].h-line[i].h);
    }
    printf("%lld\n",ans);
    return 0;
}

---

## 作者：TheShadow (赞：0)

# 闲扯

这道题改了半天，就是找不到哪儿错了。结果最后发现线段树的写法和平常有些不一样，数组越界了。。。

# 题面

[P5490 【模板】扫描线](https://www.luogu.org/problem/P5490)

# Solution

将矩形按照竖边分成一段一段的，每次计算一段的贡献。

每段的距离很好算，直接减就可以了，我们需要维护的是在这一段里包括的小矩形的高的和。

对于这个我们用线段树维护。

线段树里面记录两个值 $cnt,len$ 。

分别表示这个区间被覆盖了几次和这个区间的贡献。

统计这段区间的贡献时，需要分类讨论。

1. 若 $cnt=0$ ，则该区间的贡献为两个子区间的贡献之和。
2. 若 $cnt>0$ ，则该区间的贡献为该区间表示的高度总和。

但是这里没有判断 $l==r$ 的终止条件，需要我们手动判断一下。

$ps:$ 线段树的下标表示小段的左端点，所以每次只需要修改 $l\sim r-1$ 。

# Code

```c++
#include<bits/stdc++.h>
#define del(a,i) memset(a,i,sizeof(a))
#define ll long long
#define inl inline
#define il inl void
#define it inl int
#define ill inl ll
#define re register
#define ri re int
#define rl re ll
#define mid ((l+r)>>1)
#define lowbit(x) (x&(-x))
#define INF 0x3f3f3f3f
using namespace std;
template<class T>il read(T &x){
	int f=1;char k=getchar();x=0;
	for(;k>'9'||k<'0';k=getchar()) if(k=='-') f=-1;
	for(;k>='0'&&k<='9';k=getchar()) x=(x<<3)+(x<<1)+k-'0';
	x*=f;
}
template<class T>il print(T x){
	if(x/10) print(x/10);
	putchar(x%10+'0');
}
ll mul(ll a,ll b,ll mod){long double c=1.;return (a*b-(ll)(c*a*b/mod)*mod)%mod;}
it qpow(int x,int m,int mod){
	int res=1,bas=x%mod;
	while(m){
		if(m&1) res=(1ll*res*bas)%mod;
		bas=(1ll*bas*bas)%mod,m>>=1;
	}
	return res%mod;
}
const int MAXN = 1e5+5;
int n,a,b,c,d,x,y,s[MAXN<<1],sz;
ll ans;
struct Node{
	int x,a,b,ty;
	Node(){}
	Node(int x,int a,int b,int ty):x(x),a(a),b(b),ty(ty){}
	bool operator <(const Node &t) const{
		return x<t.x;
	}
}node[MAXN<<1];
it get_id(int x){return lower_bound(s+1,s+1+sz,x)-s;}
struct Seg_Tree{
	int cnt,len;
}T[MAXN<<3];
#define lc (cur<<1)
#define rc (cur<<1|1)
il pushup(int cur,int l,int r){
	if(T[cur].cnt) T[cur].len=s[r+1]-s[l];
	else{
		if(l==r) T[cur].len=0;
		else T[cur].len=T[lc].len+T[rc].len;
	}
}
il updata(int cur,int l,int r,int L,int R,int k){
	if(l>=L&&r<=R) T[cur].cnt+=k;
	else{
		if(mid>=L) updata(lc,l,mid,L,R,k);
		if(R>mid) updata(rc,mid+1,r,L,R,k);
	}
	pushup(cur,l,r);
}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n);
	for(ri i=1;i<=n;++i){
		read(a),read(b),read(c),read(d);
		node[i*2-1]=Node(a,b,d,1);
		node[i*2]=Node(c,b,d,-1);
		s[i*2-1]=b,s[i*2]=d;
	}
	sort(node+1,node+1+2*n),sort(s+1,s+1+2*n),sz=unique(s+1,s+1+2*n)-s-1;
	for(ri i=1;i<n*2;++i){
		ri x=get_id(node[i].a),y=get_id(node[i].b);
		updata(1,1,sz-1,x,y-1,node[i].ty);
		ans+=1ll*T[1].len*(node[i+1].x-node[i].x);
	}
	print(ans);
	return 0;
}
```

# 总结

一定要注意数组是否越界，不然会访问到一些莫名其妙的东西。

---

## 作者：Object_ (赞：0)

**注意点：**

- 线段树中使用获取具体长度时右端点应当+1，向线段树内插入值时右端点应当-1.（区间覆盖线段树）

------------
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;
const int MAXN=2e6;
struct Line{
    ll x1,x2,y;
    bool type;
    bool operator <(Line another)const{
        return y<another.y;
    }
}lines[MAXN];
int lineCnt=0;
struct Node{
    int l,r;
    ll len,cnt;
}tr[MAXN];
void build(int p,int l,int r){
    tr[p].l=l,tr[p].r=r;
    if(l==r)return;
    int mid=(l+r)>>1;
    build(p<<1,l,mid);
    build((p<<1)|1,mid+1,r);
}
ll a[MAXN];//离散化
void pushup(int p){
    if(tr[p].cnt){
        tr[p].len=a[tr[p].r+1]-a[tr[p].l];
    }else{
        tr[p].len=tr[p<<1].len+tr[(p<<1)|1].len;
    }
}
void change(int p,int l,int r,int val){
    if(tr[p].l>=l&&tr[p].r<=r){
        tr[p].cnt+=val;
        pushup(p);
        return;
    }
    int mid=(tr[p].l+tr[p].r)>>1;
    if(l<=mid)change(p<<1,l,r,val);
    if(r>mid)change((p<<1)|1,l,r,val);
    pushup(p);
}
int main(){
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        ll x1,y1,x2,y2;
        cin>>x1>>y1>>x2>>y2;
        lines[++lineCnt].x1=x1,lines[lineCnt].x2=x2;
        lines[lineCnt].y=y1,lines[lineCnt].type=0;
        lines[++lineCnt].x1=x1,lines[lineCnt].x2=x2;
        lines[lineCnt].y=y2,lines[lineCnt].type=1;
        a[i]=x1,a[i+n]=x2;
    }
    sort(a+1,a+2*n+1);
    int cnt=unique(a+1,a+2*n+1)-a-1;//离散化
    sort(lines+1,lines+2*n+1);
    build(1,1,cnt-1);
    ll ans=0;
    for(int i=1;i<=2*n;i++){
        Line nowLine=lines[i];
        if(i>1)ans+=tr[1].len*(lines[i].y-lines[i-1].y);
        if(nowLine.type){//消失
            change(1,lower_bound(a+1,a+cnt+1,nowLine.x1)-a,lower_bound(a+1,a+cnt+1,nowLine.x2)-a-1,-1);
        }else{//出现
            change(1,lower_bound(a+1,a+cnt+1,nowLine.x1)-a,lower_bound(a+1,a+cnt+1,nowLine.x2)-a-1,1);
        }
    }
    cout<<ans<<endl;
    return 0;
}
```


---


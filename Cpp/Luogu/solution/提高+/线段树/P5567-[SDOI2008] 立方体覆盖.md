# [SDOI2008] 立方体覆盖

## 题目描述

A 君近日为准备省队选拔，特意进行了数据结构的专项训练。训练过程中就遇到了“矩形面积并”这道经典问题，即：给出 $N$ 个各边与坐标轴平行（垂直）的矩形，求矩形覆盖的面积之和。A 君按纵坐标建立线段树后按横坐标扫描计算，轻易 AC 了这道题，时间复杂度为 $O(N\log N)$。

为了强化训练，A 君将问题推广到三维空间中，即：给出 $N$ 个各棱与坐标轴平行（垂直）的立方体，求立方体覆盖的体积之和。为了简化问题，令立方体均退化为正立方体，用四元组 $(x, y, z, r)$ 表示一个立方体，其中 $x, y, z$ 为立方体的中心点坐标，$r$ 为中心点到立方体各个面的距离（即立方体高的一半）。

这次可难住了 A 君，只好请你——未来的金牌——来帮助他了。

## 说明/提示

$ N \leq 100, -1000 \leq x,y,z \leq 1000, r \leq 200$

## 样例 #1

### 输入

```
3
0 0 0 3
1 -1 0 1
19 3 5 6```

### 输出

```
1944```

# 题解

## 作者：feecle6418 (赞：10)

矩形切割裸题。

什么叫矩形切割？就是维护一个不相交矩形组成的集合，支持插入。不过这道题维护的是立方体，思想是一样的。

结合核心代码讲解如下：

```cpp
void Add(int x1,int y1,int z1,int x2,int y2,int z2){
	a[++tot]=(Cube){x1,y1,z1,x2,y2,z2};//加入新长方体
}
void Cut(int i,int x1,int y1,int z1,int x2,int y2,int z2,int z){
//z表示维度
	if(!z){
		int k1=max(x1,a[i].x1),k2=min(x2,a[i].x2);
        //得到Cut后长方体顶点的x坐标
		if(a[i].x1<k1)Add(a[i].x1,a[i].y1,a[i].z1,k1,a[i].y2,a[i].z2);
        //将原长方体Cut成这个新长方体两边的两部分，这是左边
		if(k2<a[i].x2)Add(k2,a[i].y1,a[i].z1,a[i].x2,a[i].y2,a[i].z2);
        //右边
		Cut(i,k1,y1,z1,k2,y2,z2,1);
        //另外一个维度上也一样
	}
	else if(z==1){
		int k1=max(y1,a[i].y1),k2=min(y2,a[i].y2);
		if(a[i].y1<k1)Add(x1,a[i].y1,a[i].z1,x2,k1,a[i].z2);//y、z维上同理
		if(k2<a[i].y2)Add(x1,k2,a[i].z1,x2,a[i].y2,a[i].z2);
		Cut(i,x1,k1,z1,x2,k2,z2,2);
	}
	else {
		int k1=max(z1,a[i].z1),k2=min(z2,a[i].z2);
		if(a[i].z1<k1)Add(x1,y1,a[i].z1,x2,y2,k1);
		if(k2<a[i].z2)Add(x1,y1,k2,x2,y2,a[i].z2);
	}
}
```

主程序中调用如下：

```cpp
for(int i=1,x,y,z,r;i<=q;i++){
	scanf("%d%d%d%d",&x,&y,&z,&r);
	int x1=x-r,x2=x+r,y1=y-r,y2=y+r,z1=z-r,z2=z+r;//长方体的顶点
	for(int j=1;j<=tot;j++){
		if(a[j].x1>=x2||a[j].y1>=y2||a[j].x2<=x1||a[j].y2<=y1||a[j].z1>=z2||a[j].z2<=z1)continue;//若不相交则跳过，不用切割
		Cut(j,x1,y1,z1,x2,y2,z2,0);//切割原长方体
		a[j]=a[tot],j--,tot--;//删除原长方体（原长方体已经被分成许多与现在的长方体不相交的小长方体）
	}
	Add(x1,y1,z1,x2,y2,z2);
}
```

---

## 作者：0x3F (赞：4)

考虑暴力。

坐标离散化后，变成了一个 $200 \times 200 \times 200$ 的立方体网格，可以开一个三维 `bool` 数组，每一次把立方体内的小格子染黑，最后把所有染黑的格子相加即可。

但是这样是 $\mathcal{O}(n^4) \approx 10^8$，算上常数，显然过不了。

考虑优化染黑的过程，使用三维差分，一次只需要操作八个点，然后再前缀和回来，只要覆盖次数 $\geq 1$ 就算上，时间复杂度 $\mathcal{O}(n^3)$，妥妥的。

三维差分和前缀和比较烦，建议先画一个二维的类比一下，还有注意要开 `long long`，不要使用小写的 `y0` 和 `y1`。

下面是富有格律美的代码：

```cpp
#include <iostream>
#include <algorithm>
#define _ 103
#define __ 203
#define A (i<<1)-1
#define B (i<<1)
using namespace std;
int n, x, y, z, r;
int mx, X1[_], X2[_], X[__];
int my, Y1[_], Y2[_], Y[__];
int mz, Z1[_], Z2[_], Z[__];
int arr[__][__][__];
long long ans;
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> x >> y >> z >> r;
        X[A] = X1[i] = x-r;
        X[B] = X2[i] = x+r;
        Y[A] = Y1[i] = y-r;
        Y[B] = Y2[i] = y+r;
        Z[A] = Z1[i] = z-r;
        Z[B] = Z2[i] = z+r;
    }
    sort(X+1, X+(n<<1)+1);
    sort(Y+1, Y+(n<<1)+1);
    sort(Z+1, Z+(n<<1)+1);
    mx = unique(X+1, X+(n<<1)+1)-X-1;
    my = unique(Y+1, Y+(n<<1)+1)-Y-1;
    mz = unique(Z+1, Z+(n<<1)+1)-Z-1;
    for (int i = 1; i <= n; i++) {
        X1[i] = lower_bound(X+1, X+mx+1, X1[i])-X;
        X2[i] = lower_bound(X+1, X+mx+1, X2[i])-X;
        Y1[i] = lower_bound(Y+1, Y+my+1, Y1[i])-Y;
        Y2[i] = lower_bound(Y+1, Y+my+1, Y2[i])-Y;
        Z1[i] = lower_bound(Z+1, Z+mz+1, Z1[i])-Z;
        Z2[i] = lower_bound(Z+1, Z+mz+1, Z2[i])-Z;
        arr[X1[i]][Y1[i]][Z1[i]]++;
        arr[X2[i]][Y1[i]][Z1[i]]--;
        arr[X1[i]][Y2[i]][Z1[i]]--;
        arr[X1[i]][Y1[i]][Z2[i]]--;
        arr[X1[i]][Y2[i]][Z2[i]]++;
        arr[X2[i]][Y1[i]][Z2[i]]++;
        arr[X2[i]][Y2[i]][Z1[i]]++;
        arr[X2[i]][Y2[i]][Z2[i]]--;
    }
    for (x = 1; x < mx; x++) {
        for (y = 1; y < my; y++) {
            for (z = 1; z < mz; z++) {
                arr[x][y][z] += arr[x-1][y][z] + arr[x][y-1][z] + arr[x][y][z-1]
                - arr[x][y-1][z-1] - arr[x-1][y][z-1] - arr[x-1][y-1][z] + arr[x-1][y-1][z-1];
                if (arr[x][y][z]) {
                    ans += (long long)(X[x+1]-X[x])*(Y[y+1]-Y[y])*(Z[z+1]-Z[z]);
                }
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```



---

## 作者：I_AM_CIMOTA (赞：3)

简单扫描线，甚至可以直接暴力！

大体思路与 [P8648 [蓝桥杯 2017 省 A] 油漆面积](https://www.luogu.com.cn/problem/P8648) 一模一样，只不过是把扫描线放到三维空间上面来做。

如何把扫描线放到三维上？还是按坐标排序，之后我们会用一个“面”去依次扫描每个点。这个面是平行于立方体的面来扫的，所以它与立方体并的相交面积只会在某个立方体端点的位置才会发生改变。

发现值域非常小，所以我们可以直接用一个二维数组来表示“扫描面”的状态，如果从一个点扫到另外一个点的时候面积发生了改变，直接暴力修改即可。

代码非常短，跑得还飞快（最优解第一页）：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=2005;
struct Diff{
	int x,y,a,b,h,tg;
}diff[N];
int n,tot,ans,nowS,s[N][N];

bool cmp(Diff x,Diff y){return x.h<y.h;}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		int x,y,z,r;
		scanf("%d%d%d%d",&x,&y,&z,&r);
		x+=1000,y+=1000,z+=1000; 
		diff[++tot]={x-r+1,y-r+1,x+r,y+r,z-r,1},diff[++tot]={x-r+1,y-r+1,x+r,y+r,z+r,-1};
	}
	sort(diff+1,diff+tot+1,cmp);
	for(int i=1;i<tot;i++){
		for(int j=diff[i].x;j<=diff[i].a;j++){
			for(int k=diff[i].y;k<=diff[i].b;k++){
				s[j][k]+=diff[i].tg;
				if(s[j][k]==1&&diff[i].tg==1)nowS++;
				if(s[j][k]==0&&diff[i].tg==-1)nowS--;
			}
		}
		ans+=nowS*(diff[i+1].h-diff[i].h);
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Los_chase (赞：3)

# \\竟然没有人发题解，是我太老了吗？

这题的数据范围暗示了一切。

没错，就是一道**大暴力**

那么就构想一下怎么暴力吧（~~虽说各位大佬已经切了这道题~~）

------------

既然是三维空间，那么就可以考虑转化为二维情况，发现只要暴力枚举一下二维平面的坐标点，再另外处理一下第三维就行了。（**~~卡常还是比较轻松的~~**）

------------

详见代码
```cpp
#include<bits/stdc++.h>
#define LL long long
#define Maxn 110
using namespace std;

struct Sq{
	int xb,xe,yb,ye,zb,ze;
}a[Maxn];

struct Node{
	int b,e;
}c[Maxn];

int ans;

inline int read(){
	int x = 0,f = 1;char ch = getchar();
	while (!isdigit(ch)){if (ch == '-') f = -1; ch = getchar(); }
	while (isdigit(ch)){x = (x << 3) + (x << 1) + ch - 48; ch = getchar(); }
	return (f==1)?x:-x;
}

inline bool cmp(Sq x,Sq y){
	if (x.zb != y.zb) return x.zb < y.zb;
	return x.ze < y.ze;
}

int main(){
	freopen("cover.in","r",stdin);
	freopen("cover.out","w",stdout);
	int n = read();
	int bx = 1e9, by = 1e9, ex = -1e9, ey = -1e9;//优化一下暴力，记开始位置和结束位置，然后枚举一下
	for (int i = 1; i <= n; i++){
		int x = read() + 1200, y = read() + 1200, z = read() + 1200, d = read();
		a[i].xb = x - d + 1, a[i].xe = x + d;
		bx = min(a[i].xb, bx), ex = max(a[i].xe, ex);
		a[i].yb = y - d + 1, a[i].ye = y + d;
		by = min(a[i].yb, by), ey = max(a[i].ye, ey);
		a[i].zb = z - d + 1, a[i].ze = z + d;
	}
	sort(a + 1, a + n + 1, cmp);//按照z轴排序，优先考虑开始位置下面的立方体，这样统计区间时方便一些
	for (int i = bx; i <= ex; i++){
		for (int j = by; j <= ey; j++){
			int cnt=0;
			for (int k = 1; k <= n; k++)
				if (i >= a[k].xb && i <= a[k].xe && j >= a[k].yb && j <= a[k].ye)
					if (c[cnt].e < a[k].zb) c[++cnt] = (Node){a[k].zb, a[k].ze};
					else c[cnt].e = max(a[k].ze, c[cnt].e);
			for (int k = 1; k <= cnt; k++) ans += c[k].e - c[k].b + 1;//统计区间
		}
	}
	printf("%d\n",ans);
	return 0;
}
```


------------
~~**%%Modest XXX**：\ 这么丑的码风，我不想看（又被diss了）~~

---

## 作者：赖今羿 (赞：2)

## 题意

给 $N$ 个正方体，求他们的体积并。

数据范围：$N\le100$，给出的是正方体中心的坐标以及半径 $(x,y,z,r)$，有 $-1000\le x,y,z\le1000,r\le200$。

## 题解

分离出正方体的左右平面，先按 $x$ 的顺序从左到右扫，问题变成维护矩阵加、求全局有多少个数大于 0。

看到数据范围这么小直接暴力，对每一行正常维护一棵线段树即可。

$\mathcal O(n\cdot m\log m)$，$m=2000$ 为值域大小。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(i,j,k) for(int i=j;i<=k;i++)
const int N = 2010;
struct XX {
    int x, Ly, Lz, Ry, Rz, v;
} a[210];
int n, m = 2001, tot, w, b[N][N << 2], t[N][N << 2];
long long as;
#define mid ((l + r) >> 1)
#define lc (u << 1)
#define rc ((u << 1) | 1)
void Up(int u, int l, int r) {
    if (t[w][u]) b[w][u] = r - l + 1;
    else if (l != r) b[w][u] = b[w][lc] + b[w][rc];
    else b[w][u] = 0;
}
void Upd(int u, int l, int r, int x, int y, int v) {
    if (y < l || r < x) return;
    if (x <= l && r <= y) return t[w][u] += v, Up(u, l, r);
    Upd(lc, l, mid, x, y, v), Upd(rc, mid + 1, r, x, y, v), Up(u, l, r);
}
void Upd(int Lx, int Ly, int Rx, int Ry, int v) {
    for (w = Lx; w <= Rx; w++) Upd(1, 1, m, Ly, Ry, v);
}
int main() {
    scanf("%d", &n);
    rep(i, 1, n) {
        int x, y, z, r;
        scanf("%d%d%d%d", &x, &y, &z, &r), x += 1001, y += 1001, z += 1001;
        a[++tot] = {x - r, y - r + 1, z - r + 1, y + r, z + r, 1};
        a[++tot] = {x + r, y - r + 1, z - r + 1, y + r, z + r, -1};
    }
    sort(a + 1, a + tot + 1, [](XX u, XX v) { return u.x < v.x; });
    Upd(a[1].Ly, a[1].Lz, a[1].Ry, a[1].Rz, a[1].v);
    rep(i, 2, tot) {
        long long s = 0;
        rep(j, 1, m) s += b[j][1];
        as += 1ll * (a[i].x - a[i - 1].x) * s;
        Upd(a[i].Ly, a[i].Lz, a[i].Ry, a[i].Rz, a[i].v);
    }
    printf("%lld\n", as);
}
```
### 小引申

如果变成一般性的长方体覆盖，怎么做？

把 $x,y,z$ 全部离散化，对每一维做一次扫描线是 $\mathcal O(n^2\log n)$ 的。

更直接的想法是 $\mathcal O(n\log^3n)$：

问题变成需要支持 矩阵加 和 对整个平面查询有多少个数大于 0（要先离散化）：

树套树，但是外层线段树每个节点都对应一棵线段树，设外层线段树进行了一次区间加，涉及到了 $\log n$ 个节点；

这些点和他们的所有祖先受到了影响，由于深度 $\log$ 层，收到影响的最多有 $\log^2n$ 个节点；

对所有受到影响的这些点代表的线段树进行 update，$\mathcal O(n\log^3n)$，十分无脑；空间 $\mathcal O(n^2)$。

我尝试对这个方法进行标记永久化，但是没想出来……

或者分块什么的？

---

## 作者：BK小鹿 (赞：1)

~~蒟蒻第一篇题解，管理大大求过。~~

简单说一下自己的思路。看到这道题的第一眼，我就被他超小的数据范围吸引住了，于是我决定暴力过蓝题！

首先是三维的比较复杂，于是我考虑暴力枚举第二维，然后在考虑第三位的影响。

大致就是以下三点：

- 使用一个二维数组模拟整个二维平面。

- 对于每个立方体，确定它在二维平面上覆盖的区域，打个标记。

- 对于标记的每一个点，遍历每个立方体，判断这个点是否在立方体的第三维范围内，如果是，则增加高度。

不过还有一个注意事项：

- 只在完全确定某区间被覆盖时才累加体积!

我被这个卡了一下午……

然后我就愉快的通过了此题，放个代码。

## AC Code

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>

using namespace std;

const int F = 1001; 

struct Kano 
{
    int x, y, z, r;
};

int main() 
{
    int N;
    cin >> N;
    vector<Kano> c1(N);

    for (int i = 0; i < N; i++) 
	{
        int x, y, z, r;
        cin >> x >> y >> z >> r;
        c1[i] = {x + F, y + F, z + F, r};
    }

    set<int> xs, ys, zs;

    for (const auto& cube : c1) 
	{
        xs.insert(cube.x - cube.r);
        xs.insert(cube.x + cube.r);
        ys.insert(cube.y - cube.r);
        ys.insert(cube.y + cube.r);
        zs.insert(cube.z - cube.r);
        zs.insert(cube.z + cube.r);
    }

    long long res = 0;

    auto xi = xs.begin();
    auto yi = ys.begin();
    auto zi = zs.begin();

    for (auto i = xs.begin(); next(i) != xs.end(); ++i) 
	{
        for (auto j = ys.begin(); next(j) != ys.end(); ++j) 
		{
            for (auto k = zs.begin(); next(k) != zs.end(); ++k) 
			{
                int x1 = *i, x2 = *next(i);
                int y1 = *j, y2 = *next(j);
                int z1 = *k, z2 = *next(k);

                // 检查当前区间是否被覆盖
                for (const auto& cube : c1) {
                    if (x1 >= cube.x - cube.r && x2 <= cube.x + cube.r &&
                        y1 >= cube.y - cube.r && y2 <= cube.y + cube.r &&
                        z1 >= cube.z - cube.r && z2 <= cube.z + cube.r) 
				        {
                        // 被至少一个立方体完全覆盖
                        res += (long long)(x2 - x1) * (y2 - y1) * (z2 - z1);
                        break;
                    }
                }
            }
        }
    }

    cout << res << endl;
    return 0;
}

```

---

## 作者：lizexuanaibiancheng (赞：0)

其实这道题可以用大暴力，用差分前缀和来统计，比如[这篇题解](https://www.luogu.com.cn/article/54pgnkbo)就写得很详细，但是有点不容易理解，比如：为什么统计差分时有些坐标不用 $+1$？为什么最后要用 $<$，不用 $\le$ 呢？

（下面是本蒟蒻的理解，如果不对可以指出来）

首先，差分数组 $arr[i][j][k]$ 实际代表了 $(i,j,k)$ 到 $(i+1,j+1,k+1)$ 这个正方体中有多少正方体覆盖，而并非为 $(i,j,k)$ 这个点有多少正方体覆盖。这样做可以统计差分时好统计，算体积时好算。

然后如果有 $4$ 维、$5$ 维、$m$ 维等更高阶的差分前缀和，我们该怎么统计呢？很简单（记所有起始坐标为小坐标，所有结束坐标为大坐标，用上面提到的方法）。

差分时：

+ 有 $0$ 个大坐标，$m$ 个小坐标，用加法。（有 $1$ 组）

+ 有 $1$ 个大坐标，$m-1$ 个小坐标，用减法。（有 $m$ 组）

+ 有 $2$ 个大坐标，$m-2$ 个小坐标，用加法。（有 $C_{m}^{2}$ 组）

+ 有 $3$ 个大坐标，$m-3$ 个小坐标，用减法。（有 $C_{m}^{3}$ 组）

+ 以此类推......（共 $2^m$ 组）

前缀和时：

设 $(i-1),(j-1),(k-1)$ 等为小坐标，$i,j,k$ 等为大坐标，和差分时一样的规律，只不过加的时前缀和，最后别忘了把本身的差分数组的值加上。

（这是我的理解，建议大家可以配合代码看看，**不喜勿喷**）有了这些后，我们就能用更高阶的差分前缀和，这道题也很轻松的 AC 了！

---

## 作者：ZPB2011 (赞：0)

# [立方体覆盖](https://www.luogu.com.cn/problem/P5567)

## 思路

看数据就能发现这题可以用暴力解决~~虽然正解是扫描线~~，但纯暴力是 $O(n^4)$，于是考虑用三维差分。

可以先离散化然后差分，三维差分的推导可以造几个数据手玩一下，可以得出点 $i,j,k$ 若 $d_{i,j,k}+d_{i-1,j,k}+d_{i,j-1,k}+d_{i,j,k-1}-d_{i-1,j-1,k}-d_{i-1,j,k-1}-d_{i,j-1,k-1}+d_{i-1,j-1,k-1} > 0$ 则这个点被覆盖（$d$ 为差分数组）。

## AC code

```cpp
#include <iostream>
#include <algorithm>
#define int long long
using namespace std;

const int N = 105, M = 205;

int x[M], x1[N], x2[N], y[M], y1[N], y2[N], z[M], z1[N], z2[N], d[M][M][M];

signed main() {
	int n;
	cin >> n;
	for(int i = 1; i <= n; i++) {
		int a, b, c, r;
		cin >> a >> b >> c >> r;
		x[i * 2 - 1] = x1[i] = a - r;
		y[i * 2 - 1] = y1[i] = b - r;
		z[i * 2 - 1] = z1[i] = c - r;
		x[i * 2] = x2[i] = a + r;
		y[i * 2] = y2[i] = b + r;
		z[i * 2] = z2[i] = c + r;
	}
	n <<= 1;
	sort(x + 1, x + n + 1);//离散化 
	sort(y + 1, y + n + 1);
	sort(z + 1, z + n + 1);
	int nx = unique(x + 1, x + n + 1) - x - 1;
	int ny = unique(y + 1, y + n + 1) - y - 1;
	int nz = unique(z + 1, z + n + 1) - z - 1;
    for(int i = 1; i <= n / 2; i++) {//差分 
    	x1[i] = lower_bound(x + 1, x + nx + 1, x1[i]) - x;
    	x2[i] = lower_bound(x + 1, x + nx + 1, x2[i]) - x;
    	y1[i] = lower_bound(y + 1, y + ny + 1, y1[i]) - y;
    	y2[i] = lower_bound(y + 1, y + ny + 1, y2[i]) - y;
    	z1[i] = lower_bound(z + 1, z + nz + 1, z1[i]) - z;
    	z2[i] = lower_bound(z + 1, z + nz + 1, z2[i]) - z;
        d[x1[i]][y1[i]][z1[i]]++;
        d[x1[i]][y2[i]][z2[i]]++;
        d[x2[i]][y1[i]][z2[i]]++;
        d[x2[i]][y2[i]][z1[i]]++;
        d[x2[i]][y1[i]][z1[i]]--;
        d[x1[i]][y2[i]][z1[i]]--;
        d[x1[i]][y1[i]][z2[i]]--;
        d[x2[i]][y2[i]][z2[i]]--;
    }
	int sum = 0;
    for(int i = 1; i < nx; i++) {
    	for(int j = 1; j < ny; j++) {
    		for(int k = 1; k < nz; k++) {
    			d[i][j][k] += d[i - 1][j][k] + d[i][j - 1][k] + d[i][j][k - 1] - d[i - 1][j - 1][k] - d[i - 1][j][k - 1] - d[i][j - 1][k - 1] + d[i - 1][j - 1][k - 1];//差分 
				if(d[i][j][k] > 0) sum += (x[i + 1] - x[i]) * (y[j + 1] - y[j]) * (z[k + 1] - z[k]);//统计 
			}
		}
	}
	cout << sum << endl;
	return 0;
}
```

---


# [SDOI2008] 校门外的区间

## 题目描述

受校门外的树这道经典问题的启发，A君根据基本的离散数学的知识，抽象出 $5$ 种运算维护集合 $S$ （$S$ 初始为空）并最终输出 $S$。现在，请你完成这道校门外的树之难度增强版——校门外的区间。

五种运算如下：

- `U T`：$S = S \cup T$
- `I T`：$S = S \cap T$
- `D T`：$S = S - T$
- `C T`：$S = T - S$
- `S T`：$S = S \oplus T$

集合的基本运算操作定义如下：

- $A \cup B$：$\{x | x \in A \vee x \in B\}$
- $A \cap B$：$\{x | x \in A \wedge x \in B\}$
- $A - B$：$\{x | x \in A \wedge x \notin B\}$
- $A \oplus B$：$(A-B)\cup (B-A)$

## 说明/提示

$ 0 \leq a,b \leq 65535, M \leq 70000$

## 样例 #1

### 输入

```
U [1,5]
D [3,3]
S [2,4]
C (1,5)
I (2,3]```

### 输出

```
(2,3)```

# 题解

## 作者：Diamiko (赞：13)

# 珂朵莉树

~~还以为会T飞，没想到喜提最优解第四~~

仔细分析一下题目，我们就不难想出一种题目的转化，那就是把区间操作看作数轴上无数的$01$序列的操作。

我们把要维护的集合$S$看作一个数轴，如果数轴上的某个点数值为$0$，那么代表该点表示的位置不属于$S$；如果为$1$，则属于$S$.

另外仍需考虑的一点，是怎么处理区间端点的开闭。

这里我们采用一种转化方式，把$(l,r)$转化为$(l+0.5,r-0.5)$，这样我们就取不到$l$和$r$了。但是我们珂朵莉树维护的是整数的端点值，考虑把端点值乘$2$。

我们会发现

$[l,r]->[2l,2r]$

$(l,r)->(2l+1,2r-1)$

端点值具有了唯一整数性，对于前开后闭或前闭后开区间也同理。

这个题目是有坑的，输入的区间可能存在$\emptyset$，需要额外注意。

## 1.建立集合

开始的时候 $S=\emptyset$，我们插入一个极小值到极大值的$0$点。

```cpp
s.insert(Node(-65535*2,65535<<1,0));
```

**（注意，以下函数代码均暂不考虑T为空集的情况）**

## 2.$S=S∪T$

### 取并集

显然无论$S$的情况如何，对于$T$的范围内所有数我们都使其属于$S$，直接推平为$1$即可。

$T$为空集我们就可以直接跳过这一步了。

```cpp
inline void U(int l,int r)
{
	assign(l,r,1);
}
```

## 3.$S=S∩T$

### 取交集

在$T=\emptyset$时，$S$为任何集合交集都为$\emptyset$.

在$T≠\emptyset$时，交集为两集合重合的部分。那么我们把集合$T$左边的都变成$0$，右边的也变成$0$，因为它们不是我们需要的答案。现在我们已经剔除了不属于$T$的部分，我们还要剔除属于$T$但不属于$S$的部分。那么我们遍历$T$集合，原本为$1$的元素属于$S$，我们取；而原本为$0$的不属于$S$，我们舍弃，答案就出来了。

但是仔细想想，$T$集合内原本$1$的我们还是让它$1$，原本$0$的我们也让它$0$，所以我们相当于没有改变，也不用遍历了。

```cpp
inline void I(int l,int r)
{
	assign(-65535*2,l-1,0);
	assign(r+1,65535<<1,0); 
}
```

## 4.$S=S-T$

### 取$S$与$T$的差集

显然$T$为空集时我们可以直接跳过，以为任何集合与空集的集合都为原集合。

而$T$不为空集时，我们就是在$S$中把$T$的部分去掉，可以直接推平$T$。

```cpp
inline void D(int l,int r)
{
	assign(l,r,0);
}
```

## 5.$S=T-S$

### 取$T$与$S$的差集

显然$T$为空集时，$T$与任何$S$的差集都为空集。

$T$不为空集时，我们要取只属于$T$而不属于$S$的部分，显然对于$T$左边和右边的区间我们都可以直接推平。

$T$内的部分只要原本为$1$，就是属于$S$的，我们令其为$0$，因为它不属于我们的答案；原本为$0$，就是原本也不属于$S$，我们令其为$1$，因为它属于$T$和$S$的差集。

```cpp
inline void C(int l,int r)
{
	for(SIT itr=split(r+1),itl=split(l);itl!=itr;itl++)
	{
		itl->v^=1;
	}
	assign(-6553*2,l-1,0);
	assign(r+1,65535<<1,0);
}
```

## 6.$S=S⊕T$

### 取$S$和$T$的对称差

显然$T$为空集时，我们可以直接跳过这一步，因为任何集合与空集的对称差为原集合。

$T$不为空集时，我们要取只属于$T$或$S$且不属于另一者的元素。

那么在$T$之外的所有属于$S$的元素我们都需要，在$T$之内我们只需要属于$T$的元素。

那么在$T$之内，原本为$0$我们令其为$1$，原本为$1$我们令其为$0$；在$T$之外我们不变。

```cpp
inline void S(int l,int r)
{
	for(SIT itr=split(r+1),itl=split(l);itl!=itr;itl++)
	{
		itl->v^=1;
	}
}
```

## 7.细节处理

### ① 空集的判别

利用高中必修一学习的集合知识我们知道，不会有一个数同时大于$x$又小于$x$，推广一下，空集的情况只有一下几种：

$$(x,x)$$

$$(x,x]$$

$$[x,x)$$

以及$l>r$的情况。

### ② 集合的合并

因为珂朵莉树我们要多次进行$split$操作，所以有些区间会分裂开来，而输出时我们要把可以合并的区间合并起来。

比如我们使$S=[1,5]$与$T=[2,3]$取交集，输出的答案会是$[1,2)\space[2,3]\space(3,5]$，这显然不合常理，我们要将其合并。

相邻的节点，如果同为$1$或同为$0$，我们可以合并为一个节点，详见代码。

```cpp
inline void Merge()
{
	auto it1=s.begin(),it2=it1;
	it2++;//使it2为it1后面一个
	while(it2!=s.end()&&s.size())
	{
		if(it1->v==it2->v)
		{
			int l=it1->l,r=it2->r,v=it1->v;
			it2++;
			it2=s.erase(it1,it2);
			//erase返回的是删除的元素后面那一个的迭代器
			//并且删除的是[it1,it2)，所以要提前把it2++
			it1=s.insert(Node(l,r,v)).first;
			//insert返回的pair的第一关键字是插入元素的迭代器
		}
		else
		{
			it1++;
			it2++;
		}
	}
}
```
### ③ 输入及输出的处理

输入就不赘述了，一个简单的字符串处理，提取数字的原理你会写快读自然就明白。一个细节是我们在处理的时候同时把这个区间是否合法也一块处理了。

输出的时候，如果这个区间的端点是一个奇数，说明是开端点；是偶数，说明这个端点是闭端点，输出的时候端点值要除以二。

## 8.完整代码

```cpp
#include<bits/stdc++.h>
#define SIT set<Node>::iterator
using namespace std;
struct Node
{
	int l,r;
	mutable bool v;
	Node(int L,int R=-1,int V=0):l(L),r(R),v(V){}
	bool operator <(const Node &x)const
	{
		return l<x.l;
	}	
};
set<Node>s;
char opt[2],range[15];
int l,r;
bool init(int &l,int &r)//注意引用
{
	char flagl,flagr;
	flagl=range[0],flagr=range[strlen(range)-1];
	int num=0;
	for(int i=1;i<(int)strlen(range)-1;i++)
	{
		if(range[i]==',')
		{
			l=num;
			num=0;
			continue;
		}
		num=num*10+range[i]-'0';
	}
	r=num;
	if(l>r)return false;
	if(l==r&&((flagl=='('&&flagr==']')||(flagl=='['&&flagr==')')||(flagl=='('&&flagr==')')))return false;
	if(flagl=='(')l=l*2+1;
	else l<<=1;
	if(flagr==')')r=r*2-1;
	else r<<=1;
	return true;
}
inline SIT split(int pos)
{
	SIT it=s.lower_bound(Node(pos));
	if(it!=s.end()&&it->l==pos)return it;
	it--;
	int l=it->l,r=it->r,v=it->v;
	s.erase(it);
	s.insert(Node(l,pos-1,v));
	return s.insert(Node(pos,r,v)).first;
}
inline void assign(int l,int r,bool v)
{
	SIT itr=split(r+1),itl=split(l);
	s.erase(itl,itr);
	s.insert(Node(l,r,v));
}
inline void U(int l,int r)
{
	assign(l,r,1);
}
inline void I(int l,int r)
{
	assign(-65535*2,l-1,0);
	assign(r+1,65535<<1,0); 
}
inline void D(int l,int r)
{
	assign(l,r,0);
}
inline void C(int l,int r)
{
	for(SIT itr=split(r+1),itl=split(l);itl!=itr;itl++)
	{
		itl->v^=1;
	}
	assign(-6553*2,l-1,0);
	assign(r+1,65535<<1,0);
}
inline void S(int l,int r)
{
	for(SIT itr=split(r+1),itl=split(l);itl!=itr;itl++)
	{
		itl->v^=1;
	}
}
inline void Merge()
{
	auto it1=s.begin(),it2=it1;
	it2++;
	while(it2!=s.end()&&s.size())
	{
		if(it1->v==it2->v)
		{
			int l=it1->l,r=it2->r,v=it1->v;
			it2++;
			it2=s.erase(it1,it2);
			it1=s.insert(Node(l,r,v)).first;
		}
		else
		{
			it1++;
			it2++;
		}
	}
}
inline void contain()
{
	bool flag=0;
	for(Node x:s)
	{
		if(x.v)
		{
			flag=1;
			printf("%c%d,%d%c ",(x.l)&1?'(':'[',x.l>>1,x.r+1>>1,(x.r&1)?')':']');
		}
	}
	if(!flag)puts("empty set");
}
int main()
{
	s.insert(Node(-65535*2,65535<<1,0));
	while(~scanf("%s %s",opt,range))//多组输入
	{
		bool empty=!init(l,r);
		if(!strcmp(opt,"U"))
		{
			if(empty) continue;
			U(l,r);
		}
		else if(!strcmp(opt,"I"))
		{
			if(empty)
			{
				s.clear();
				s.insert(Node(-65535*2,65535<<1,0));
				continue;
			}
			I(l,r);
		}
		else if(!strcmp(opt,"D"))
		{
			if(empty) continue;
			D(l,r);
		}
		else if(!strcmp(opt,"C"))
		{
			if(empty)
			{
				s.clear();
				s.insert(Node(-65535*2,65535<<1,0));
				continue;
			}
			C(l,r);
		}
		else
		{
			if(empty) continue;
			S(l,r);
		}
	}
	Merge();
	contain();
	return 0;
}
```

---

## 作者：_Wind_Leaves_ShaDow_ (赞：7)

~~曾经有位先人说过：抄题解和交题解是你学会一个东西的唯一检验方式。~~

所以蒟蒻就来交一发题解 ~~水估值~~ 巩固记忆啦。

### 题意

题目看起来很难操作，但是需要维护的集合其实是一段，也就是一个个权值区间。

- 操作一，区间赋值 1。

- 操作二，区间反赋值 0。也就是把除了这段区间所有地方的都赋值为 0。

- 操作三，区间赋值 0。

- 操作四，区间反赋值 0，然后区间异或。原因请配合图片食用。

![](https://cdn.luogu.com.cn/upload/image_hosting/ah9kkd61.png)

- 操作五，区间异或。

如果有不理解的可以自己去百度区间运算的规则。

### 区间操作

题目大意理解完之后，我们再看 [区间操作](https://baike.baidu.com/item/%E5%8C%BA%E9%97%B4/1273117?fr=ge_ala)：

对这题来说要知道的就是：圆括号代表端点不取，方括号代表端点要包含。

我们看样例：```(2,3)```。这是什么？如果集合简单的只是整数集合的话，这个集合没有任何的数，也就不会被输出。那么意思就是：这道题的集合包含的范围是实数。

那么我们就要开 double 然后操作一大堆吗？不是的。我们发现输入的左右端点一定是整数，也就是说我们可以把 ```(2``` 这样的东西定义成 2.5。但是开浮点数还是会导致代码极其难调，所以我们可以把整个数列开大一倍：

![](https://cdn.luogu.com.cn/upload/image_hosting/2rxtfgze.png)

~~图很炸裂凑合看吧，谢谢啦。~~

### 输出处理

这里蒟蒻用了一种很笨的方法：

最后统一查询一遍，如果子树的和等于子树长度，就代表子树全都在集合中。然后把这个子树的端点标记一下，如果端点是奇数代表在储存时是圆括号存的，否则是方括号存的。

~~因为蒟蒻太弱了解释不清就看代码吧：~~

```cpp
#include <bits/stdc++.h>
#define int long long
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)

using namespace std;
const int N=65540;

int a,b;
char op,lb,rb,tc,ans[N];
struct Segt{
	int l,r,sm,tgc,tgx;
}sg[N<<3];//竟然不会爆！（开心）

inline void lzdc(int p){//区间赋值懒标记下放
	if(sg[p].tgc==2)return;
	sg[p<<1].tgx=sg[p<<1|1].tgx=0;
	sg[p<<1].tgc=sg[p<<1|1].tgc=sg[p].tgc;
	sg[p<<1].sm=(sg[p<<1].r-sg[p<<1].l+1)*sg[p].tgc;
	sg[p<<1|1].sm=(sg[p<<1|1].r-sg[p<<1|1].l+1)*sg[p].tgc;
	sg[p].tgc=2;
	return;
}

inline void lzdx(int p){//区间异或
	if(!sg[p].tgx)return;
	sg[p<<1].tgx^=1;
	sg[p<<1|1].tgx^=1;
	sg[p<<1].sm=(sg[p<<1].r-sg[p<<1].l+1)-sg[p<<1].sm;
	sg[p<<1|1].sm=(sg[p<<1|1].r-sg[p<<1|1].l+1)-sg[p<<1|1].sm;
	sg[p].tgx=0;
	return;
}

inline void build(int l,int r,int p){//建树
	sg[p].l=l;
	sg[p].r=r;
	sg[p].tgc=2;
	if(l==r)return;
	int mid=l+((r-l)>>1);
	build(l,mid,p<<1);
	build(mid+1,r,p<<1|1);
	return;
}

inline void chg(int ql,int qr,int p,int K){//区间修改
	if(ql<=sg[p].l&&sg[p].r<=qr){
		sg[p].tgc=K;
		sg[p].tgx=0;
		sg[p].sm=(sg[p].r-sg[p].l+1)*K;
		return;
	}
	lzdc(p);
	lzdx(p);
	int mid=sg[p].l+((sg[p].r-sg[p].l)>>1);
	if(ql<=mid)chg(ql,qr,p<<1,K);
	if(qr>mid)chg(ql,qr,p<<1|1,K);
	sg[p].sm=sg[p<<1].sm+sg[p<<1|1].sm;
	return;
}

inline void dox(int ql,int qr,int p){//区间异或
	if(ql<=sg[p].l&&sg[p].r<=qr){
		sg[p].tgx^=1;
		sg[p].sm=(sg[p].r-sg[p].l+1)-sg[p].sm;
		return;
	}
	lzdc(p);
	lzdx(p);
	int mid=sg[p].l+((sg[p].r-sg[p].l)>>1);
	if(ql<=mid)dox(ql,qr,p<<1);
	if(qr>mid)dox(ql,qr,p<<1|1);
	sg[p].sm=sg[p<<1].sm+sg[p<<1|1].sm;
	return; 
}

inline void solve(int p){//最后统一查询一遍
	if(sg[p].sm==(sg[p].r-sg[p].l+1)){
		if(sg[p].l%2){
			if(ans[sg[p].l>>1]!='[')ans[sg[p].l>>1]='(';
		}else{
			if(ans[sg[p].l>>1]==char(0))ans[sg[p].l>>1]='[';
			else ans[sg[p].l>>1]='6';
		}
		if(sg[p].r%2){
			if(ans[(sg[p].r+1)>>1]!=']')ans[(sg[p].r+1)>>1]=')';
		}else ans[(sg[p].r+1)>>1]=']';
		return;
	}
	if(sg[p].l>=sg[p].r)return;
	lzdc(p);
	lzdx(p);
	if(sg[p<<1].sm)solve(p<<1);
	if(sg[p<<1|1].sm)solve(p<<1|1);
	sg[p].sm=sg[p<<1].sm+sg[p<<1|1].sm;
	return;
}//这里的东西很抱歉讲不清楚，请大家自己理解吧，谢谢啦

signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	build(0,65535<<1,1);
	while(cin>>op>>lb>>a>>tc>>b>>rb){
		a=(a<<1)+(lb=='(');
		b=(b<<1)-(rb==')');
		if(op=='U')chg(a,b,1,1);
		else if(op=='I'){
			if(a-1>=0)chg(0,a-1,1,0);
			if((b+1)<=(65535<<1))chg(b+1,65535<<1,1,0);
		}else if(op=='D')chg(a,b,1,0);
		else if(op=='C'){
			dox(a,b,1);
			if(a-1>=0)chg(0,a-1,1,0);
			if((b+1)<=(65535<<1))chg(b+1,65535<<1,1,0);
		}else if(op=='S')dox(a,b,1);
	}
	solve(1);
	bool hvans=0,lst=0;
	for(int i=0;i<=65535;i++){
		if(ans[i]=='('||ans[i]=='['){
			lst=1;
			hvans=1;
			cout<<ans[i]<<i<<',';
		}
		if(ans[i]==')'||ans[i]==']'){
			if(!lst){
				if(ans[i]==')')cout<<'('<<i<<',';
				else cout<<'['<<i<<',';
			}
			lst=0;
			hvans=1;
			cout<<i<<ans[i]<<' ';
		}
	}//输出答案，写得也很差，大家看情况理解吧
	if(!hvans)cout<<"empty set";
	return 0;
}
```

为什么先下放区间赋值的懒标记？因为区间赋值更改时我们已经清空了区间异或的懒标记，这时的区间异或懒标记是比区间赋值更靠后的，所以先下传区间赋值。

---

## 作者：saxiy (赞：7)

嗯？数据范围好小。。那就分块吧 ~~（其实跑得飞快）~~ 。

`bitset` 基本用法就不介绍了，相信您知道。

#### 题目分析：

维护一个集合，要求资瓷五种集合操作，输出最后的结果。

因为数据不大，可以考虑利用STL的 $bitset$ 帮忙维护每个点的覆盖情况，因为有开闭区间之分，所以如下定义一个 `bit` 位的信息（因为懒得根据 $n$ 分块，干脆每个块都是 $400$ 好了）：

- 第 $i$ 个数是否被覆盖： $block[(2\times i)/400][(2\times i)\%400]$

- $i$ ~ $i+1$ 的区间是否被覆盖： $block[(2\times i+1)/400][(2\times i+1)\%400]$

就相当于将第 $i$ 个点编码为 $2\times i$，单位区间 $(i,i+1)$ 编码为 $2\times i+1$ ，然后统一操作。

#### 接下来分析每一个操作：

1. **U**

利用 `bitset` 的 `set` 函数统一赋值（ $[l,r]$ 闭区间）。

```cpp
void un(int l, int r) {
	int lb = l / BN, rb = r / BN;//计算块编号
	for(int i = lb + 1;i < rb;i++)
		block[i].set();//统一赋值
	int lr = l % BN, rl = r % BN;
	if(lb == rb) {//同一块中
		for(int i = lr;i <= rl;i++)
			block[lb].set(i);
	} else {//不同块中
		for(int i = lr;i < BN;i++)
			block[lb].set(i);
		for(int i = 0;i <= rl;i++)
			block[rb].set(i);
	}
}
```

2. **I**

本质就是将不属于 $[l,r]$ 的赋为 `0` ，和 `U` 是一样的思路。

```cpp
void iw(int l, int r) {
	int lb = l / BN, rb = r / BN;
	for(int i = 0;i < lb;i++)
		block[i].reset();//统一赋0
	for(int i = rb + 1;i < BN;i++)
		block[i].reset();
	int lr = l % BN, rl = r % BN;
	for(int i = 0;i < lr;i++)
		block[lb].reset(i);//边角暴力
	for(int i = rl + 1;i < BN;i++)
		block[rb].reset(i);
}
```

3. **D**

将 $[l,r]$ 的赋为 `0` ，`I` 操作的区间反过来就行。

```cpp
void dl(int l, int r) {
	int lb = l / BN, rb = r / BN;
	for(int i = lb + 1;i < rb;i++)
		block[i].reset();
	int lr = l % BN, rl = r % BN;
	if(lb == rb) {
		for(int i = lr;i <= rl;i++)
			block[lb].reset(i);
	} else {
		for(int i = lr;i < BN;i++)
			block[lb].reset(i);
		for(int i = 0;i <= rl;i++)
			block[rb].reset(i);
	}
}
```

4. **C**

稍微麻烦一些，其实就是一个 `S` 操作加一个 `I` 操作（将内部取反，外部赋 `0` ）。

```cpp
void cl(int l, int r) {
	sf(l, r);
	iw(l, r);
}
```

5. **S**

将 $[l,r]$ 取反，利用 `bitset` 自带的 `flip` 函数就行。

```cpp
void sf(int l, int r) {
	int lb = l / BN, rb = r / BN;
	for(int i = lb + 1;i < rb;i++)
		block[i].flip();
	int lr = l % BN, rl = r % BN;
	if(lb == rb) {
		for(int i = lr;i <= rl;i++)
			block[lb].flip(i);
	} else {
		for(int i = lr;i < BN;i++)
			block[lb].flip(i);
		for(int i = 0;i <= rl;i++)
			block[rb].flip(i);
	}
}
```

#### 格式化输出函数：

$O(n)$ 暴力全部遍历一遍就行，窝设返回值为是否输出过区间（是否是空集）。

```cpp
bool show() {
	bool flag = 0;//是否有过输出
	//左端点，右端点，当前块，块内下标。
	int nl, nr, nb = 0, np = 0;
	while(1) {
		while(nb < BN && block[nb].none()) nb++;//跳过没有'1'的块。
		if(nb == BN) return flag;//遍历结束
		while(!block[nb].test(np))//跳过为0的bit位
			if(++np == BN) {
				np = 0;
				if(++nb == BN) return flag;
			}
		nl = nb * BN + np;//左端点编码
		while(block[nb].test(np))
			if(++np == BN) nb++, np = 0;//跨块
		nr = nb * BN + np - 1;//右端点编码
		if(nl & 1) printf("(%d,", nl >> 1);//左端点解码
		else printf("[%d,", nl >> 1);
		if(nr & 1) printf("%d) ", (nr + 1) >> 1);//右端点解码
		else printf("%d] ", nr >> 1);
		flag = 1;//有过输出
	}
}
```

#### 主函数：

```cpp
#pragma GCC optimize("Ofast,fast-math,unroll-loops")
#include <bits/stdc++.h>
#define BN 400
using namespace std;

int l, r;
bitset <BN> block[BN];
char op, lp, rp;

//省略以上已经给出的子函数

int main() {
	for(int i = 0;i < BN;i++) block[i].reset();//初始化
	while(1) {
		op = getchar();
		if(op == EOF) break;
		getchar(); lp = getchar();
		scanf("%d,%d", &l, &r);
		rp = getchar(); getchar();
		l = l << 1; r = r << 1;
		if(lp == '(') l |= 1;//编码
		if(rp == ')') r --;
		switch(op) {//对应所有操作
			case 'U': {
				un(l, r);
				break;
			}
			case 'I': {
				iw(l, r);
				break;
			}
			case 'D': {
				dl(l, r);
				break;
			}
			case 'C': {
				cl(l, r);
				break;
			}
			case 'S': {
				sf(l, r);
				break;
			}
		}
		//if(!show()) puts("empty set");//调试用
	}
	if(!show()) puts("empty set");//返回0，即为空集
	return 0;
}
```

**PS：** 开 $O2,O3$ 暴力撵标算哦，目前（2019/11/04）最优解第六。

---

## 作者：GeorgeAAAADHD (赞：4)

这一题属于比较有思维难度的线段树吧。

### 题目大意：

给定一根由 $0$ 开始的数轴（即数轴的正半轴部分），初始时数轴上的每个点都为 $0$。有以下几种操作：

- $\texttt{U T}$ ：将区间 $\texttt{T}$ 全部置 $1$。
- $\texttt{I T}$ ：将区间 $\texttt{T}$ 的补集（即除了区间 $\texttt{T}$ 的所有区间）全部置 $0$。
- $\texttt{D T}$ ：将区间 $\texttt{T}$ 全部置 $0$。
- $\texttt{C T}$ ：先将区间 $\texttt{T}\ 01$ 翻转（即将 $0$ 改为 $1$，$1$ 改为 $0$），再执行操作 $\texttt{I T}$。
- $\texttt{S T}$ ：将区间 $\texttt{T}\ 01$ 翻转。

求操作过后所有为 $1$ 的区间。按递增输出这些区间。

### 分析：

容易发现，该题目包含了区间修改和区间翻转的操作。这两个操作都可以使用线段树解决。

需要注意的地方有：

- 该题目有开、闭区间之分，因此我们可以把输入的 $l$ 和 $r$ 乘以 $2$，这时每一个单位长度代表 $0.5$，此时我们再根据开、闭区间对 $l$ 和 $r$ 进行对应的调整。
- 还有就是要注意区间的标记初始化。最好将修改的标记初始化为 $-1$，因为修改的值为 $0$ 或 $1$，尽量不要冲突了。

然后这题就做完了。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int ls(int p){return p<<1;}
int rs(int p){return p<<1|1;}
const int maxn=132000;
int ans[maxn]={0};
char op;
inline void gt(int &l,int &r){
	char c=getchar();
	bool z=0,y=0;
	while(c!='('&&c!='[')c=getchar();
	if(c=='(')z=1;
	while(!isdigit(c))c=getchar();
	while(isdigit(c)){
		l=(l<<1)+(l<<3)+(c^48);
		c=getchar();
	}
	l<<=1;
	if(z)l++;
	while(!isdigit(c))c=getchar();
	while(isdigit(c)){
		r=(r<<1)+(r<<3)+(c^48);
		c=getchar();
	}
	while(c!=')'&&c!=']')c=getchar();
	if(c==')')y=1;
	r<<=1;
	if(y)r--;
}
struct tree{
	int l,r,rev,cov;
}tree[maxn<<2];
inline void build(int p,int l,int r){
	tree[p].l=l,tree[p].r=r;
	tree[p].cov=-1,tree[p].rev=0;
	if(l==r)return;
	int mid=(l+r)>>1;
	build(ls(p),l,mid);
	build(rs(p),mid+1,r);
}
inline void pushdown(int p){
	if(tree[p].cov==-1&&tree[p].rev==0)return;
	if(tree[p].cov!=-1){
		tree[ls(p)].cov=tree[rs(p)].cov=tree[p].cov;
		tree[ls(p)].rev=tree[rs(p)].rev=0;
		tree[p].cov=-1;
	}
	if(tree[p].rev){
		tree[ls(p)].rev^=1;
		tree[rs(p)].rev^=1;
		tree[p].rev=0;
	}
}
inline void change(int p,int L,int R,int tag){
	int l=tree[p].l,r=tree[p].r;
	if(L>R)return;
	if(L<=l&&r<=R){
		if(tag!=2){
			tree[p].cov=tag;
			tree[p].rev=0;
		}
		else tree[p].rev^=1;
		return;
	}
	pushdown(p);
	int mid=(l+r)>>1;
	if(L<=mid)change(ls(p),L,R,tag);
	if(mid<R)change(rs(p),L,R,tag);
}
inline void query(int p){
	int l=tree[p].l,r=tree[p].r;
	if(l==r){
		ans[l]=tree[p].cov==-1?tree[p].rev:tree[p].cov^tree[p].rev;
		return;
	}
	pushdown(p);
	query(ls(p)),query(rs(p));
}
inline void solve(){
	query(1);
	bool flag=1;
	for(int i=0,f=0;i<=maxn;i++){
		if(ans[i]&&!f){
			flag=0;
			if(i%2)printf("(");
			else printf("[");
			printf("%lld\,",i/2);
            f=1;
		}
		else if(!ans[i]&&f){
			printf("%lld",i/2);
			if(i%2)printf("] ");
			else printf(") ");
            f=0;
		}
	}
	if(flag)printf("empty set");
}
signed main(){
    build(1,0,132000);
	while(cin>>op){
		int l=0,r=0,n=maxn;
		gt(l,r);
		if(op=='U')change(1,l,r,1);
		else if(op=='I')change(1,0,l-1,0),change(1,r+1,n,0);
		else if(op=='D')change(1,l,r,0);
		else if(op=='C')change(1,l,r,2),change(1,0,l-1,0),change(1,r+1,n,0);
		else change(1,l,r,2);
	}
	solve();
	return 0;
}		
```



------------
#### UPD on 2023.7.24

题解被 hack 数据卡掉了，已修改。

---

## 作者：破忆 (赞：4)

### 【题目大意】
维护一个01数列，进行若干操作，以区间的形式输出最终数列


------------

### 【分析】

#### 首先分析5种操作
![U操作](https://cdn.luogu.com.cn/upload/image_hosting/5jfksyi5.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

![I操作](https://cdn.luogu.com.cn/upload/image_hosting/5sflm9l3.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

![D操作](https://cdn.luogu.com.cn/upload/image_hosting/0e5sh5dx.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

![C操作](https://cdn.luogu.com.cn/upload/image_hosting/c27ywtt7.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

![S操作](https://cdn.luogu.com.cn/upload/image_hosting/m4e98uio.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

观察以上操作，尝试简化这些操作

不难得出以下规律

>* U：T区间内置为1

>* I：T区间外置为0

>* D：T区间内置为0

>* C：T区间内01反转，T区间外置为0

>* S：T区间内01反转

综上所述，所有操作都可以转化为区间反转和区间覆盖

用一个支持区间反转和区间覆盖的**线段树**维护就行了

------------
线段数维护的是有限集

而此处要求维护实数集

#### 如何处理实数

在相邻整数之间强行塞入一个数，维护两整数之间的状态即可

需要注意的是，读入和输出时要调整一下，有很多细节

~~本人调了一个晚上~~

------------
### 【算法】
线段树区间反转区间覆盖


------------
### 【代码】
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=131075,maxt=maxn<<2;
int n=131070,cnt;//需要维护的边界是原来的两倍
int ans[maxn];
string s;
struct tree{
	int cov,rev;
}t[maxt];
int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
void pushdown(int k){//下传标记
	if(t[k].cov!=-1){//-1表示区间不需要覆盖，否则需要覆盖
		t[k<<1].cov=t[k].cov;
		t[k<<1|1].cov=t[k].cov;
		t[k<<1].rev=0;
		t[k<<1|1].rev=0;
		t[k].cov=-1;
	}
	if(t[k].rev){//1表示区间需要反转，反转两次等于没转，异或1即可
		t[k<<1].rev^=1,t[k<<1|1].rev^=1;
		t[k].rev=0;
	}
}
void update1(int k,int l,int r,int x,int y,int v){//区间覆盖
	if(x<=l&&r<=y){
		t[k].cov=v,t[k].rev=0;
		return;
	}
	pushdown(k);
	int mid=l+r>>1;
	if(x<=mid) update1(k<<1,l,mid,x,y,v);
	if(mid<y) update1(k<<1|1,mid+1,r,x,y,v);
}
void update2(int k,int l,int r,int x,int y){//区间反转
	if(x<=l&&r<=y){
		t[k].rev^=1;
		return;
	}
	pushdown(k);
	int mid=l+r>>1;
	if(x<=mid) update2(k<<1,l,mid,x,y);
	if(mid<y) update2(k<<1|1,mid+1,r,x,y);
}
void solve(int k,int l,int r){
	if(l==r){
		if((t[k].cov^t[k].rev)==1) ans[l]=1;
		return;
	}
	int mid=l+r>>1;
	pushdown(k);
	solve(k<<1,l,mid),solve(k<<1|1,mid+1,r);
}
int main(){
	freopen("P5568.in","r",stdin);
	freopen("P5568.out","w",stdout);
	while(getline(cin,s)){
		int L=0,R=0,i=3;
		while(s[i]>='0'&&s[i]<='9') L=L*10+s[i++]-'0';
		L<<=1;
		L+=(s[2]=='(');
		i++;
		while(s[i]>='0'&&s[i]<='9') R=R*10+s[i++]-'0';
		R<<=1;
		R-=(s[i]==')');//读入数据需要一点点改变，注意细节
		if(s[0]=='U') update1(1,0,n,L,R,1);else
		if(s[0]=='I'){
			if(0<=L-1) update1(1,0,n,0,L-1,0);
			if(R+1<=n) update1(1,0,n,R+1,n,0);
		}else
		if(s[0]=='D') update1(1,0,n,L,R,0);else
		if(s[0]=='C'){
			if(0<=L-1) update1(1,0,n,0,L-1,0);
			if(R+1<=n) update1(1,0,n,R+1,n,0);
			update2(1,0,n,L,R);
		}else
		if(s[0]=='S') update2(1,0,n,L,R);
	}
	solve(1,0,n);
	int L=0,R=0;
	for(int i=0;i<=n;i++){
		if(ans[i]&&(i==0||!ans[i-1])) L=i;//区间左边界
		if(ans[i]&&(i==n||!ans[i+1])){//右边界
			R=i;
			cnt++;
			if(L&1) printf("(%d,",L/2);//通过奇偶判断需要用哪种括号
			else printf("[%d,",L/2);
			if(R&1) printf("%d) ",R/2+1);
			else printf("%d] ",R/2);//同样，输出也需要转化
		}
	}
	if(!cnt) printf("empty set\n");
	return 0;
}
```


---

## 作者：AFewSuns (赞：3)

[原题链接](https://www.luogu.com.cn/problem/P5568)

# 题意描述

需要你维护一个集合 $S$， 并与给定的一些集合进行并集、交集、差集、异或等运算（其实题面已经很清楚了，不过多描述）。

# 解题思路

由于集合的值域较小，可以把它看成一段 **01数列** 的操作，其中数列中某个位置的值为 $1$ 就代表集合 $S$ 中有这个数。

先假设这个数列为 $a$，那么如果 $a_1 = 1$，$a_2 = 0$，$a_3 = 1$，$a_4 = 1$，$a_5 = 0$，那么集合 $S = \{1,3,4\}$。

这里我将一一分析题目中的五种操作。

## 1. $S \leftarrow S \cup T$

其实就是把 $T$ 集合所示的区间全部覆盖成 $1$，对于 $S$ 与 $T$ 重合的地方，因为原来已经是 $1$，被覆盖成 $1$ 后仍不会改变。

**操作：将集合 $T$ 所示区间覆盖为 $1$**

## 2. $S \leftarrow S \cap T$

交集本身的意思就是两个集合重合的部分，也就是说，集合 $S$ 与集合 $T$ 都有的地方才为 $1$。

同样，从反面考虑，如果某个数不在 $S$ 里，或者不在 $T$ 里，那么这个数一定不在 $S \cap T$ 里。

所以我们只需要排除 $S$ 以外的数，再排除 $T$ 以外的数，那么剩下的数所组成的集合一定就是  $S \cap T$。

又因为我们所维护的集合 $S$ 以外的数已经是 $0$ 了，所以只需要在原来的基础上把 $T$ 以外的数覆盖成 $0$ 即可。

**操作：将集合 $T$ 以外的数所示区间覆盖为 $0$**

## 3. $S \leftarrow S - T$

$S - T$ 的意思就是把集合 $S$ 中，与 $T$ 相交的部分去掉，这里放一张图。

![1](https://cdn.luogu.com.cn/upload/image_hosting/tbqqix4i.png)

很明显，就是把 $T$ 全部覆盖成 $0$。在 $T$ 集合中，与 $S$ 相交的被覆盖成了 $0$，而对于 $S$ 以外的地方，原本就是 $0$，没有改变。

**操作：将集合 $T$ 所示区间覆盖为 $0$**

## 4. $S \leftarrow T - S$

同上，将 $T$ 减去与 $S$ 相交的部分并替代成原来的 $S$ ，这里放一张图。

![2](https://cdn.luogu.com.cn/upload/image_hosting/60yrpj7a.png)

怎么办呢？这里有两种方法：

1.与上个操作一样，先记录下 $S$ 所表示的区间，然后把 $T$ 全部赋值成 $1$，最后把记录的 $S$ 所示区间全部赋值为 $0$，原理同操作 $3$ 一样。至于为什么要记录原来的 $S$ 呢？因为把 $T$ 所示区间赋值为 $1$ 后，$S$ 就变了，不是原来的 $S$ 了。

2.我不想操作途中查询 $S$ 怎么办？很简单，这里引入一个新操作——**反转**。

一开始，先把整个集合（就是值域）反转，这个时候原来的 $S$ 集合全部变成了 $0$，就成功地把 $S$ 与 $T$ 相交的部分去掉了。但是 $S$ 以外的数都变成了 $1$ 啊？

很简单。既然我们只想保留剩下的 $T$ 的部分，那么就将 $T$ 以外的数全部赋值为 $0$。因为与 $S$ 相交的部分已经在之前去过了，所以剩下的就是 $T - S$。

这里推荐用第二种方法 ~~（毕竟懒得记录）~~。

**操作：将值域反转，再将集合 $T$ 以外的数所示区间覆盖为 $0$**

## 5. $S \leftarrow S \oplus T$

还是先放一张图。

![3](https://cdn.luogu.com.cn/upload/image_hosting/qsn1244m.png)

因为是异或，所以 $T$ 与 $S$ 相交的部分要变为 $0$，而 $T$ 的其他部分（没有与 $S$ 相交的部分）则要变为 $1$，这其实就是将 $T$ 所在的区间整个反转（对着图看一下）。

**操作：将集合 $T$ 所示区间反转**

# 代码实现

分析完所有操作后，你会惊奇地发现只剩下区间的**覆盖**和**反转**了，所以这是一道线段树的模板题。

我们需要记录一段区间有多少个 $1$，以及覆盖和反转的两个 tag，在修改及询问的时候标记下传。

对于询问，只需要在最后询问一次，记录下每个位置的值，然后再输出。

时间复杂度约为 $O(M\log N)$（$N$ 为值域）。

**注意：**

由于存在开区间和闭区间且不可忽略，我们将其分别存储，值域*2即可。

数字可能为 $0$，所以注意位置的分配，我这里习惯从 $1$ 开始，所以对于每个数字 $k$，其对应的位置是 $2k+1$，两个数中间空的地方即为开区间。而且注意左开和右开不一样。

覆盖的 tag 记得一开始要记为 $-1$。

在进行覆盖操作及标记下传和的时候，要把反转标记赋为 $0$，标记下传的时候**先下传覆盖再下传反转**。

反转及标记下传的时候是**异或自己**，而不是等于别人。

要讲的就那么多了。代码？拿来吧你！

## 代码（本人代码可能有点丑）

```cpp
#include<bits/stdc++.h>
#define LC x<<1
#define RC x<<1|1
using namespace std;
int tree[800080],fz[800080],fg[800080],ans[200020];//fz：反转标记，fg：覆盖标记，ans：最终答案 
char opt,c1,c2;
string s;
void pushup(int x){
	tree[x]=tree[LC]+tree[RC];
}
void pushdown(int x,int l,int r){//标记下传 
	int mid=(l+r)>>1;
	if(fg[x]!=-1){//先覆盖 
		tree[LC]=fg[x]*(mid-l+1);
		tree[RC]=fg[x]*(r-mid);
		fg[LC]=fg[x];
		fg[RC]=fg[x];
		//记得把反转标记变为 0 
		fz[LC]=0;
		fz[RC]=0; 
		fg[x]=-1;
	}
	if(fz[x]){//再反转 
		tree[LC]=mid-l+1-tree[LC];
		tree[RC]=r-mid-tree[RC];
		//注意：是异或自己 
		fz[LC]=!fz[LC];
		fz[RC]=!fz[RC];
		fz[x]=0;
	}
}
void mdffg(int x,int l,int r,int ql,int qr,int k){//覆盖操作 
	if(ql>qr) return;
	if(ql<=l&&r<=qr){
		tree[x]=k*(r-l+1);
		fg[x]=k;
		fz[x]=0;//记得反转标记赋为 0 
		return;
	}
	int mid=(l+r)>>1;
	pushdown(x,l,r);
	if(ql<=mid) mdffg(LC,l,mid,ql,qr,k);
	if(mid<qr) mdffg(RC,mid+1,r,ql,qr,k);
	pushup(x);
}
void mdffz(int x,int l,int r,int ql,int qr){//反转操作 
	if(ql>qr) return;
	if(ql<=l&&r<=qr){
		tree[x]=r-l+1-tree[x];
		fz[x]=!fz[x];
		return;
	}
	int mid=(l+r)>>1;
	pushdown(x,l,r);
	if(ql<=mid) mdffz(LC,l,mid,ql,qr);
	if(mid<qr) mdffz(RC,mid+1,r,ql,qr);
	pushup(x);
}
void query(int x,int l,int r){
	if(l==r){
		ans[l]=tree[x];//记录答案 
		return;
	}
	int mid=(l+r)>>1;
	pushdown(x,l,r);
	query(LC,l,mid);
	query(RC,mid+1,r);
}
void solve(){
	query(1,1,200000);
	if(!tree[1]){//如果所有数字的值都为 0，那么 S 就是空集 
		printf("empty set\n");
		return;
	}
	bool ck=0;
	//记得处理并集 
	for(int i=1;i<=200000;i++){
		if(!ck&&ans[i]){
			ck=1;
			if(i%2==0) printf("(");
			else printf("[");
			printf("%d,",(i-1)>>1);
		}
		if(ck&&!ans[i+1]){
			ck=0;
			printf("%d",i>>1);
			if(i%2==0) printf(") ");
			else printf("] ");
		}
	}
	printf("\n");
}
int main(){
	for(int i=0;i<=800079;i++) fg[i]=-1;//记得赋为-1 
	while(cin>>opt){
		int l,r;
		cin>>c1;
		scanf("%d,%d",&l,&r);
		cin>>c2;
		//处理括号，注意左开和右开不一样 
		if(c1=='(') l=2*l+2;
		else l=2*l+1;
		if(c2==')') r=2*r;
		else r=2*r+1;
		//5个操作，具体已在上面讲解
		//这里所有的200000即为值域 
		if(opt=='U') mdffg(1,1,200000,l,r,1);
		if(opt=='I'){
			mdffg(1,1,200000,1,l-1,0);
			mdffg(1,1,200000,r+1,200000,0);
		}
		if(opt=='D') mdffg(1,1,200000,l,r,0);
		if(opt=='C'){
			mdffz(1,1,200000,1,200000);
			mdffg(1,1,200000,1,l-1,0);
			mdffg(1,1,200000,r+1,200000,0);
		}
		if(opt=='S') mdffz(1,1,200000,l,r);
	}
	solve();//输出最终答案 
}
```

---

## 作者：Tommy_Keen (赞：3)

[原题link](https://www.luogu.com.cn/problem/P5568)

# 题意

对于一个集合 $S$ ,它可以和另外一个集合 $T$ 做以下五种运算：

```U T```：$S = S∪T$

```I T```：$S = S∩T$

```D T```：$S = S-T$

```C T```：$S = T-S$

```S T```：$S = S⊕T$

集合的基本运算操作定义如下：

$A∪B$：得到在 $A$ 集合中，或在 $B$ 集合中的元素。

$A∩B$：得到在 $A$ 集合中，且在 $B$ 集合中的元素。

$A−B$：得到在 $A$ 集合中，但不在 $B$ 集合中的元素。

$A⊕B$：$(A-B)∪(B-A)$

初始区间 $S$ 为空，输入 $M$ 条计算指令，请你输出计算后的 $S$ (用多个区间表示)。如果集合 $S$ 最终为空，输出 empty set 。

# 思路

用一个线段树维护每个整数值是否存在，需要记录区间被什么覆盖（记为 $tag$ , $-1$ 表示无覆盖， $0/1$ 表示被覆盖）和区间是否反转(记为 $rev$ ,  $1$ 表示区间被反转) 。
五种操作分别对应如下:

$U$ : $T$ 对应的区间覆盖成 $1$ 。

$I$ : $T$ 以外的区间覆盖为 $0$ 。

$D$ : $T$ 对应的区间覆盖为 $0$ 。

$C$ : $T$ 对应的区间反转， $T$ 以外的区间覆盖为 $0$ 。

$S$ : $T$ 对应的区间反转。

pushdown 的时候注意优先级，覆盖的优先级始终高于反转。

对于开区间，可以如下处理： 对于闭区间 $[a,b]$ 替换成 $[2a,2b]$ ，对于开区间 $(a,b)$ 替换成 $[2a+1,2b-1]$ ，如此可以按照纯闭区间处理。

答案输出：先查询每个叶子区间是否取 $1$ ，并记录成一个一维数组，最后扫描一遍整个数组输出答案。

# 代码讲解

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2*65535+10;
const int M = 2*65535;
int m,tag[N<<2],ans[N],rev[N<<2];
```

$tag[u]=-1$ 未被覆盖
 
$tag[u]=0$ 被 $0$ 覆盖

$tag[u]=1$ 被 $1$ 覆盖

$rev[u]=0$ 未取反

$rev[u]=1$ 被取反

```cpp
inline int lc(int u) {
	return u<<1;
}
inline int rc(int u) {
	return u<<1|1;
}
```

线段树标配，分别表示左右儿子，使用位运算更快。

```cpp
inline void pushdown(int u) {
	if(tag[u] != -1) {
		tag[lc(u)] = tag[rc(u)] = tag[u];
		rev[lc(u)] = rev[rc(u)] = 0;
		tag[u] = -1;
	}
	if(rev[u]) {
		if(tag[lc(u)] == -1) {
			rev[lc(u)] = 1 - rev[lc(u)];
		}
		if(tag[lc(u)] != -1) {
			tag[lc(u)] = 1 - tag[lc(u)];
		}
		if(tag[rc(u)] == -1) {
			rev[rc(u)] = 1 - rev[rc(u)];
		}
		if(tag[rc(u)] != -1) {
			tag[rc(u)] = 1 - tag[rc(u)];
		}
		rev[u] = 0;
	}
}
```

当节点 $u$ 被覆盖的时候，因为覆盖的优先级大于取反，所以左右儿子继承父亲的 $tag$ ，并设置成没有取反，且把 $tag_u$ 改回 $-1$ 。如果 $u$ 被取反了，则：如果一个儿子未被覆盖，则把其取反情况翻转一下；如果被覆盖了，就把覆盖的值翻转一下。最后把父亲调回未翻转状态。

```cpp
void modify_cover(int u,int l,int r,int x,int y,int k) {
	if(x <= l && y >= r) {
		tag[u] = k;
		rev[u] = 0;
	} else {
		int mid = (l+r)>>1;
		pushdown(u);
		if(x <= mid) modify_cover(lc(u),l,mid,x,y,k);
		if(y > mid) modify_cover(rc(u),mid+1,r,x,y,k);
	}
}
```

覆盖操作时， ```else``` 部分不讲，讲一下 ```if``` 。因为覆盖的优先级大于取反，所以此时把 $tag_u$ 改成应该赋的值（ $0$ 或 $1$ ），取反调成 $0$ 。

```cpp
void modify_opposite(int u,int l,int r,int x,int y) {
	if(x <= l && y >= r) {
		if(tag[u]  != -1) tag[u] = 1 - tag[u];
		if(tag[u]  == -1) rev[u] = 1 - rev[u];
	} else {
		int mid = (l+r)>>1;
		pushdown(u);
		if(x <= mid) modify_opposite(lc(u),l,mid,x,y);
		if(y > mid) modify_opposite(rc(u),mid+1,r,x,y);
	}
}
```

只讲 ```if``` 。如果该节点 $u$ 未被覆盖，则把它的取反值翻转一下；如果被覆盖了，就只翻转一下它的覆盖值。

```cpp
void query(int u,int l,int r) {
	if(l == r) {
		if(tag[u] != -1) {
			ans[l] = tag[u];
		}
		if(tag[u] == -1) {
			ans[l] = rev[u];
		}
	} else {
		int mid = (l+r)>>1;
		pushdown(u);
		query(lc(u),l,mid);
		query(rc(u),mid+1,r);
	}
}
```

这一步是遍历线段树的叶子节点。找到时，如果该节点未被覆盖，则取其取反值（未被取反则 $0$ ，被取反则 $1$ ）；如果被覆盖了，就直接取它的 $tag$ 值，因为此时它的 $rev$ 一定为 $0$ ，在 ```pushdown``` 操作的时候就搞定了。

```cpp
memset(tag,-1,sizeof(tag));
```

初始化 $tag$ 。

```cpp
for(int i = 1; i <= m; i++) {
		char cal,pre,suf,tmp;
		int lef,rig;
		cin>>cal>>pre>>lef>>tmp>>rig>>suf;
		lef <<= 1;rig <<= 1;
		if(pre == '(') lef += 1;
		if(suf == ')') rig -= 1;
		if(cal == 'U') {
			modify_cover(1,0,M,lef,rig,1);
		}
		if(cal == 'I') {
			if(lef-1 >= 0) modify_cover(1,0,M,1,lef-1,0);
			if(rig+1 <= M) modify_cover(1,0,M,rig+1,M,0);
		}
		if(cal == 'D') {
			modify_cover(1,0,M,lef,rig,0);
		}
		if(cal == 'C') {
			if(lef-1 >= 0) modify_cover(1,0,M,1,lef-1,0);
			if(rig+1 <= M) modify_cover(1,0,M,rig+1,M,0);
			modify_opposite(1,0,M,lef,rig);
		}
		if(cal == 'S') {
			modify_opposite(1,0,M,lef,rig);
		}
	}
	query(1,0,M);
```

输入时改左右端点遵循“对于闭区间 $[a,b]$ 替换成 $[2a,2b]$ ，对于开区间 $(a,b)$ 替换成 $[2a+1,2b-1]$ ，如此可以按照纯闭区间处理”的原则。

```cpp
    bool temp = 0, now = 0;
	for(int i = 0; i <= N; i++) {
		if(ans[i]) {
			temp = 1;
			if(now == 1) continue;
			if(!(i&1)) {
				printf("[%d,",i>>1);
				now = 1;
			}
			if(i&1) {
				printf("(%d,",i>>1);
				now = 1;
			} 
		}
		if(!ans[i]) {
			int las = i-1;
			if(now == 0) continue;
			if(!(las&1)) {
				printf("%d] ",las>>1);
			}
			if(las&1) {
				printf("%d) ",(las+1)>>1);
			} 
			now = 0;
		}
	}
	if(!temp) puts("empty set");
	return 0;
```

扫一遍，实现方法不唯一。

 btw ，在我写 ```if(!ans[i])``` 中的 ```las&1``` 的时候，因为是取 $i$ 的开区间，所以 ```las``` 要 ```+1``` 。

$O(m \log n)$

---

## 作者：NianFeng (赞：2)

**blog食用地址**：[广告](https://www.luogu.com.cn/blog/YuanFang-Nian/p5568-sdoi2008-xiao-men-wai-di-ou-jian)

***

# 0xcf 总言

这大概是为数不多我能直接过的省选题了。~~我太弱了！~~

题目的意思简洁明了，就是让我们维护一些集合，并进行一系列的操作。对于这种区间的操作，基本就是**线段树**的舞台了。本题大部分的分析都是对于**区间操作**和**分段细节**的，所以不在此做总体的题意分析了。直接来吧！

# 0x01 各种操作

## 需要维护的东西

- 区间**覆盖**的标记

- 区间**反转**的标记

这些将在下面的讲解中说到，再此不做过多说明。

## case U：操作 1

- $S = S \cup T$

非常的简单，求的是**并集**。这种情况下往 $S$ 里头加 $T$，直接**将** $T$ **所在的地方覆盖为** $true$ 即可。这样一来，本来已有的不会变化，本来没有的就被加上了。

图解如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/z5p4wll7.png)

代码如下：

```cpp
case 'U':
    cover(1,0,n,l,r,1);             //将T涉及到的范围覆盖为包含
    break;
```

其中，线段树起到的作用是**区间的覆盖**。在到达指定区间之后，进行标记并返回。

```cpp
void cover(int root,int l,int r,int L,int R,bool k){
    if(L<=l&&r<=R){
        //进行标记。将覆盖标记更新为k，并标为已覆盖
        tree[root].cov=k,tree[root].flag=true;
        //已经覆盖了，区间反转的操作撤销
        tree[root].tag=false;
        return;
    } pushdown(root);   //在下文会解释
    int mid=l+r>>1;
    int leftroot=root<<1;
    int rightroot=root<<1|1;
    if(L<=mid) cover(leftroot,l,mid,L,R,k);
    if(mid<R) cover(rightroot,mid+1,r,L,R,k);
}
```

## case I：操作 2

- $S = S \cap T$

求的是两者**交集**。我们来想一下，既然是求两个共有的，那么，把**不共有的删除了**不就可以了吗！这样，把**除了** $T$ **之外的地方覆盖为** $false$，就可以保证不在 $T$ 的全赶走，而在 $T$ 范围之内的该有的还是有，不该有的也不存在，不影响。

图解如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/r5e0yfxn.png)

代码如下：

```cpp
case 'I':
    if(l!=0) cover(1,0,n,0,l-1,0);  //覆盖左侧，同时注意越界问题
    if(r!=n) cover(1,0,n,r+1,n,0);  //覆盖右侧
    break;
```

## case D：操作 3

- $S = S - T$

将 $T$ **所包含**的统统去掉。这个也是相当简单的，我们像并集操作一样，只是**把** $T$ **之内的都改为** $false$ 就可以保证删掉的删了、没删的没了。

图解如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/grtza2xz.png)

代码如下：

```cpp
case 'D':
    cover(1,0,n,l,r,0);             //与U操作正好相反
    break;
```

## case C：操作 4

- $S = T - S$

此时的分析难度有些升高，但是不用怕。既然我们不太能一眼看出本质所在，但我们可以根据图来分析：

![](https://cdn.luogu.com.cn/upload/image_hosting/fo3xmkcn.png)

在这张图中，$T$ 直接被 $S$ 覆盖了，全部消掉了。似乎看不出什么端倪。

![](https://cdn.luogu.com.cn/upload/image_hosting/9vnxpxrj.png)

在这张图中，$T$ 又把 $S$ 覆盖了。同为减法，我们把操作 3 中的 $S$ 和 $T$ 交换，同时转换一下语序，得出这么一句话：**先把** $S$ **内的删了**，**再把** $T$ **有的放进去**。是不是很像？

![](https://cdn.luogu.com.cn/upload/image_hosting/bmme1nfn.png)

这张图从直观上告诉了我们，上面的想法是正确的。整合一下，在这个操作中，先把 $S$ 变为其**补集**，再将其与 $T$ 进行**交集**就完成了。

这样是正确的吗？眼睛有时候会骗我们，但是数学不会。我们从集合的角度浅浅理解一下吧：
$$
\begin{aligned} T - S &= \{x | x \in T \wedge x \notin S \} \\ &= \{x | x \in T \wedge x \in \complement_{S} \} \\ &= T \cap \complement_{S} \end{aligned}
$$

这个式子同样适用于操作 3。

既然思路正确，如何实现呢？交集的操作刚刚已经讲过了，所以重点在于补集。补集实际上就是将**无中生有，有的砍掉**，而肉眼可见，当集合本身不连续的时候，直接用覆盖操作实在是有伤分数。那么我们考虑**直接反转**不就可以了吗？于是，操作四的基本实现就是**打上全局反转标记，将** $T$ **以外的地方标记为** $false$。于是，操作 4 就解决了。

代码如下：

```cpp
case 'C':
    invert(1,0,n,0,n);              //标记全局反转
    if(l!=0) cover(1,0,n,0,l-1,0);  //不必多说
    if(r!=n) cover(1,0,n,r+1,n,0);
    break;
```

这里，线段树起到的作用主要是**区间的反转**。当然，作为全局反转实际上只用标记树的根节点。

```cpp
void invert(int root,int l,int r,int L,int R){
    if(L<=l&&r<=R){
        //转换标记。用异或的原因是保证两次反转能被抵消，不必多说吧。
        tree[root].tag^=1;
        return;
    } pushdown(root);   //快了快了，还有一个操作！
    int mid=l+r>>1;
    int leftroot=root<<1;
    int rightroot=root<<1|1;
    if(L<=mid) invert(leftroot,l,mid,L,R);
    if(mid<R) invert(rightroot,mid+1,r,L,R);
}
```

## case S：操作 5

- $S = S \oplus T$

- $A \oplus B$：$(A-B)\cup (B-A)$

题中给出的定义式也是相当唬人，所以让我们层层深入吧。虽然式子不太看得懂，我们可以先从异或的**数学定义**入手。在数学中，有 $1 \operatorname{xor} 1 = 0 \operatorname{xor} 0 = 0$ 和 $0 \operatorname{xor} 1 = 1$。转为集合中，我们大概可以猜测是，**两者皆有的删去，两者单独有的加入**。

那么接下来，就继续手动模拟，从图入手吧：

![](https://cdn.luogu.com.cn/upload/image_hosting/bvy9h53o.png)

这一个图就很明白的告诉了我们：是对的！同时，从图中我们也能看出这个操作的端倪所在：$T$ 是一段连续的区间，只对于这一区间考虑，则会有**所有数字都相反了**，也就是**将** $T$ **所在区间反转即可**！

证明式……能力有限，感性理解吧！代码如下：

```cpp
case 'S':
    invert(1,0,n,l,r);              //打上反转标记
    break;
```

# 0x02 线段树的维护

在刚刚的讲解中，着重于区间之间操作的关系，但是没有讲到具体的维护，所以现在讲讲线段树的相关事宜。

首先，最最基础的，是**数组的大小**。由于空间与 $M$ 无关，上限 $maxn$ 我们设置为**值域的两倍**。在下面会提到为什么是两倍空间。

```cpp
const int maxn=131070;
/*------*/
struct TREE{
    bool cov,flag;  //区间覆盖标记
    bool tag;       //区间反转标记
}tree[(maxn+10)<<2];
```

其次，最最重要的，是**标记下传操作**。在这里，区间反转的标记和区间覆盖的标记更新顺序容易弄混。不仅是这里，其他地方也有多个懒标记的情况。以我的习惯，我会按照**操作的影响与被影响**确定更新的顺序。

比如在这里，区间覆盖会将区间反转的标记撤销。所以，**先下传覆盖标记，再下传反转标记**。为什么？因为先传反转标记的话，后来的覆盖标记就把它抵消了呀！再比如加法和乘法，因为加法标记会在乘法标记更新时同时乘起来，所以先传加法的话会导致加法懒标记错误，从而让信息变更。

标记下传代码如下：

```cpp
//这里没有用函数，可能会有点肿捏。希望对理解没有影响qwq
void pushdown(int root){
    if(tree[root].flag){        //先传覆盖标记
        tree[root<<1].cov=tree[root].cov;
        tree[root<<1].flag=true;
        tree[root<<1].tag=false;
        tree[root<<1|1].cov=tree[root].cov;
        tree[root<<1|1].flag=true;
        tree[root<<1|1].tag=false;
        tree[root].flag=false;
    }
    if(tree[root].tag){         //再传反转标记
        tree[root<<1].tag^=1;
        tree[root<<1|1].tag^=1;
        tree[root].tag=0;
    }
}
```

# 0x03 输入与输出

这个看似简单的东西其实很有坑踩呢。比如一开始，我就将给出区间当成只有整数，因此对这样例输出的“空集”想了半天。

那么，什么样的定义才能在线段树上**表示小数的区间**呢？

我们考虑到，输入的 $a$ 和 $b$ 应该是整数（话说题面里没有说呢）。这样一来，每加一个区间，作为端点的整数可能取可能不取，而中间的小数必须取。为了单独标记小数部分，我们在**每两个整数** $x$ **和** $x + 1$ **之间加一个节点作为区间** $(x, x + 1)$。如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/v1kcdbba.png)

这么定义下来，原来的 $x$ 在线段树中就是 $x \times 2$ 了。自然而然，空间上限也要设为两倍。不过，这是对于闭区间的端点。如果是开区间的端点，$x \times 2$ 是取不到的，所以**将作为开区间的左端点 +1，而右端点 -1**。所以输入的处理代码如下：

```cpp
void get(){
    int n=s.size(),i; s="@"+s;                  //长度，指针
    for(l=0,i=1+1;'0'<=s[i]&&s[i]<='9';i++)     //忽略括号，先取整数
        l=(l<<1)+(l<<3)+s[i]-'0';               //类似于快读
    for(r=0,i=i+1;'0'<=s[i]&&s[i]<='9';i++)     //对偶（
    l=(l<<1)+(s[1]=='('),r=(r<<1)-(s[n]==')');  //先乘上2，然后进行开区间的加减
}
```

输出就相对简单一点了。虽然每次都单点查询不是不可以，但是何不一遍下传所有标记再查找呢？于是，利用一个**类似建树的函数**，不断下传所有标记，在叶子节点直接将覆盖标记异或上反转标，并记赋值给标记数组即可。这样可以做到 $O(n)$。

为什么可以如此直接呢？首先，反转标记是**不会对覆盖产生影响的**，相对独立，可以直接将值反转；同时，若覆盖标记没被用过，**就相当于该位的初值是** $0$，再异或上反转懒标记也不会有影响。由上，最终标记数组的赋值函数代码如下：

```cpp
void update(int root,int l,int r){
    if(l==r){                   //直接赋值
        ans[l]=tree[root].cov^tree[root].tag;
        return;
    } pushdown(root);
    update(root<<1,l,l+r>>1);
    update(root<<1|1,(l+r>>1)+1,r);
}
```

最后用两个指针扫一遍，输出集合。

# 0x04 总代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=131070;
char opt; string s;
int l,r,ans[maxn+10];
void get(){
    int n=s.size(),i; s="@"+s;
    for(l=0,i=1+1;'0'<=s[i]&&s[i]<='9';i++)
        l=(l<<1)+(l<<3)+s[i]-'0';
    for(r=0,i=i+1;'0'<=s[i]&&s[i]<='9';i++)
        r=(r<<1)+(r<<3)+s[i]-'0';
    l=(l<<1)+(s[1]=='('),r=(r<<1)-(s[n]==')');
}
struct TREE{
    bool cov,flag;
    bool tag;
}tree[(maxn+10)<<2];
void pushdown(int root){
    if(tree[root].flag){
        tree[root<<1].cov=tree[root].cov;
        tree[root<<1].flag=true;
        tree[root<<1].tag=false;
        tree[root<<1|1].cov=tree[root].cov;
        tree[root<<1|1].flag=true;
        tree[root<<1|1].tag=false;
        tree[root].flag=false;
    }
    if(tree[root].tag){
        tree[root<<1].tag^=1;
        tree[root<<1|1].tag^=1;
        tree[root].tag=0;
    }
}
void cover(int root,int l,int r,int L,int R,bool k){
    if(L<=l&&r<=R){
        tree[root].cov=k,tree[root].flag=true;
        tree[root].tag=false;
        return;
    } pushdown(root);
    int mid=l+r>>1;
    int leftroot=root<<1;
    int rightroot=root<<1|1;
    if(L<=mid) cover(leftroot,l,mid,L,R,k);
    if(mid<R) cover(rightroot,mid+1,r,L,R,k);
}
void invert(int root,int l,int r,int L,int R){
    if(L<=l&&r<=R){
        tree[root].tag^=1;
        return;
    } pushdown(root);
    int mid=l+r>>1;
    int leftroot=root<<1;
    int rightroot=root<<1|1;
    if(L<=mid) invert(leftroot,l,mid,L,R);
    if(mid<R) invert(rightroot,mid+1,r,L,R);
}
void update(int root,int l,int r){
    if(l==r){
        ans[l]=tree[root].cov^tree[root].tag;
        return;
    } pushdown(root);
    update(root<<1,l,l+r>>1);
    update(root<<1|1,(l+r>>1)+1,r);
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);     cout.tie(0);
    int n=maxn;
    while(cin>>opt){
        cin>>s; get();
        switch(opt){
            case 'U':
                cover(1,0,n,l,r,1);
                break;
            case 'I':
                if(l!=0) cover(1,0,n,0,l-1,0);
                if(r!=n) cover(1,0,n,r+1,n,0);
                break;
            case 'D':
                cover(1,0,n,l,r,0);
                break;
            case 'C':
                invert(1,0,n,0,n);
                if(l!=0) cover(1,0,n,0,l-1,0);
                if(r!=n) cover(1,0,n,r+1,n,0);
                break;
            case 'S':
                invert(1,0,n,l,r);
                break;
        }
    }
    update(1,0,n); bool emp=true;
    for(int i=0;i<=n;i++){
        if(ans[i]){ //这里的排版比较奇怪，对不起qwq
            int j=i; while(ans[j]) j++;
            //需要注意的是，实际上这里j多了1，
            //只是为了方便（和对齐）没有减。所以在判断右边括号时要注意
            cout<<(i&1?"(":"[")
                <<i/2<<","<<j/2
                <<(j&1?"]":")")
                <<" ";\*__^__*\
            i=j,emp=false;
        }
    }
    if(emp) puts("empty set");
    return 0;
}
```

# 0x3f 总结与后话

虽然题解区已有多篇题解，我还是希望我的分析能够解答你的一些疑惑。这道题除了对于区间的一步步分析外，最需要注意的是那些小细节，比如输入的处理、集合的分段、懒标记的下传、右指针的位置等。只有在细节上用心，才能不让大代码挂分。

感谢您的观看，有错误/不足之处欢迎指出，也欢迎对于我代码的 hack！(>w<)

---

## 作者：Diogenes (赞：2)

[blog](https://blog.csdn.net/chtcht_/article/details/102535406)
[luogu P5568 [SDOI2008]校门外的区间](https://www.luogu.org/problem/P5568)

前置知识：[珂朵莉树](https://oi-wiki.org/ds/odt/)
### 问题一：开闭区间
>区间端点均为整数，不妨认为（$l$，$r$）为（$l+0.5$,$r-0.5$）

>乘2就可以换算成整数区间
### 问题二：数据结构
>假定数据随机，~~出题者确实没有卡~~ ，那么区间的个数不会很多，~~好像链表模拟也可以过~~ 

>然后是odt模板
### 问题三：各种操作
> - $U$：取出一段区间，赋值为$true$
> - $I$  ：将 $[-1e9$，$l-1]$ 和 $[r+1$，$1e9]$ 赋值为 $false$
> - $D$：将 $[l，r]$ 赋值为 $false$
> - $C/S$：暴力一些区间并取反
### 注意点
> - $set$的迭代器是$const$的，如果想要修改，应该先删除后插入。
> - 删除节点之后要注意迭代器失效的问题
> - 合并两个相邻的区间
> - ~~好好写读入~~
### 代码


```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<set>
#define iter set<Node>::iterator
#define N 1000010
using namespace std;

struct Node {
	int l,r;bool f;
	inline bool operator < (const Node &o) const {
		return l<o.l;
	}
};

set<Node> odt;

iter split(int x) {
	if(x>1e9) return odt.end();
	iter it=--odt.upper_bound((Node){x,0,0});
	if(it->l==x) return it;
	int l=it->l,r=it->r;bool f=it->f;
	odt.erase(it);
	odt.insert((Node){l,x-1,f});
	return odt.insert((Node){x,r,f}).first;
}

void assign(int l,int r,bool f) {
	iter itr=split(r+1),itl=split(l);
	odt.erase(itl,itr);
	odt.insert((Node){l,r,f});
}

char ch;bool fl;

bool getch() {
	while(ch!=EOF && ch!='U' && ch!='I' && ch!='D' && ch!='C' && ch!='S') ch=getchar();
	if(ch==EOF) return false;
	else return true;
}

bool read1() {
	while(ch!='(' && ch!='[') ch=getchar();
	if(ch=='(') return false;
	else return true;
}

bool read2() {
	while(ch!=')' && ch!=']') ch=getchar();
	if(ch==')') return false;
	else return true;
}

template<class T>
void read(T &x) {
	x=0;ch=getchar();bool f=false;
	for(;ch!='-' && !(ch>='0' && ch<='9');ch=getchar());
	if(ch=='-') ch=getchar(),f=true;
	for(;ch>='0' && ch<='9';ch=getchar()) x=x*10+ch-48;
	if(f) x=-x;
}

int main() {
//	freopen("interval.in","r",stdin);
//	freopen("interval.out","w",stdout);
	odt.insert((Node){(int)-1e9,(int)1e9,0});
	int l,r;
	while(getch()) {
		if(ch=='U') {
			fl=read1();
			read(l);
			if(fl) l=l*2; else l=l*2+1;
			read(r);
			fl=read2();
			if(fl) r=r*2; else r=r*2-1;
			if(l>r) continue;
			assign(l,r,true);
			continue;
		}
		if(ch=='I') {
			fl=read1();
			read(l);
			if(fl) l=l*2; else l=l*2+1;
			read(r);
			fl=read2();
			if(fl) r=r*2; else r=r*2-1;
			if(l>r) continue;
			assign(-1e9,l-1,false);
			assign(r+1,1e9,false);
			continue;
		}
		if(ch=='D') {
			fl=read1();
			read(l);
			if(fl) l=l*2; else l=l*2+1;
			read(r);
			fl=read2();
			if(fl) r=r*2; else r=r*2-1;
			if(l>r) continue;
			assign(l,r,false);
			continue;
		}
		if(ch=='C') {
			fl=read1();
			read(l);
			if(fl) l=l*2; else l=l*2+1;
			read(r);
			fl=read2();
			if(fl) r=r*2; else r=r*2-1;
			if(l>r) continue;
			iter itr=split(r+1),itl=split(l);
			for(;itl!=itr;++itl) {
				bool f=!itl->f;
				int L=itl->l,R=itl->r;
				odt.erase(itl);
				itl=odt.insert((Node){L,R,f}).first;
			}
			assign(-1e9,l-1,false);
			assign(r+1,1e9,false);
			continue;
		}
		if(ch=='S') {
			fl=read1();
			read(l);
			if(fl) l=l*2; else l=l*2+1;
			read(r);
			fl=read2();
			if(fl) r=r*2; else r=r*2-1;
			if(l>r) continue;
			iter itr=split(r+1),itl=split(l);
			for(;itl!=itr;++itl) {
				bool f=!itl->f;
				int L=itl->l,R=itl->r;
				odt.erase(itl);
				itl=odt.insert((Node){L,R,f}).first;
			}
			continue;
		}
	}
	for(iter i=odt.begin();i!=odt.end();++i) {
		iter j=i;
		++j;
		if(j==odt.end()) break;
		if(i->r+1==j->l && i->f==j->f) {
			iter itr=split(j->r+1),itl=split(i->l);
			odt.erase(itl,itr);
			i=odt.insert((Node){i->l,j->r,i->f}).first;
			--i;
//			assign(i->l,j->r,i->f);
		}
	}
	bool flag=true;
	for(iter i=odt.begin();i!=odt.end();++i) {
		if(i->f) {
			flag=false;break;
		}
	}
	if(flag) puts("empty set");
	else {
		for(iter itl=odt.begin();itl!=odt.end();++itl) if(itl->f) {
			if(itl->l&1) {
				putchar('(');
				printf("%d",itl->l/2);
				putchar(',');
			} else {
				putchar('[');
				printf("%d",itl->l/2);
				putchar(',');
			}
			if(itl->r&1) {
				printf("%d",(itl->r+1)>>1);
				putchar(')');
				putchar(' ');
			} else {
				printf("%d",itl->r/2);
				putchar(']');
				putchar(' ');
			}
		}
		putchar('\n');
	}
	return 0;
}
```


---

## 作者：ExplodingKonjac (赞：1)

### [原题链接](https://www.luogu.com.cn/problem/P5568)

进阶之路（
* [$\color{#fe4c61}\textbf{Level 1}$](https://www.luogu.com.cn/problem/P1047)
* [$\large\color{#f39c11}\textbf{Level 2}$](https://www.luogu.com.cn/problem/P1276)
* [$\Large\color{#3498db}\textbf{Level 3}$](https://www.luogu.com.cn/problem/P5568)

## 解题思路

发现值域其实并不大，所以可以每个位置维护 $0/1$，表示在不在答案中。

接下来就是各种操作的转换。假设操作区间为 $T$，全集为 $U$：

* `U T`：将区间 $T$ 赋值为 $1$；
* `I T`：将区间 $\complement_UT$ 赋值为 $0$；
* `D T`：将区间 $T$ 赋值为 $0$；
* `C T`：将区间 $\complement_UT$ 赋值为 $0$，并将区间 $T$ 取反；
* `S T`：将区间 $T$ 取反。

但是还有一个问题，如何处理区间的开闭情况？

由于 $l,r\in\mathbb{Z}$，我们可以将区间 $(l,r)$ 看做 $[l+0.5,r-0.5]$。将这个东西 $\times2$ 即可变为整数下标。

即：
* $[l\Rightarrow[2l$
* $(l\Rightarrow2l+1]$
* $r]\Rightarrow2r]$
* $r)\Rightarrow2r-1]$

输出时根据奇偶性判断即可。

## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,maxx;
char input[100];
bool flag,empty=true;
struct TreeNode
{
    int tg1,tg2;
    TreeNode *lc,*rc;
    TreeNode(): tg1(-1),tg2(0)
        { lc=rc=nullptr; }
}*rt;
typedef TreeNode *pNode;
inline void addTag(pNode i,int tg,bool fl)
{
    if(!fl && tg!=-1)   i->tg1=tg,i->tg2=0;
    if(fl && tg)    i->tg2^=1;
}
inline void pushdown(pNode i)
{
    addTag(i->lc,i->tg1,0),addTag(i->lc,i->tg2,1);
    addTag(i->rc,i->tg1,0),addTag(i->rc,i->tg2,1);
    i->tg1=-1,i->tg2=0;
}
void build(int l,int r,pNode &i=rt)
{
    i=new TreeNode;
    if(l!=r)
    {
        int mid=(l+r)>>1;
        build(l,mid,i->lc),build(mid+1,r,i->rc);
    }
}
void modify(int lq,int rq,int x,pNode &i=rt,int l=0,int r=maxx)
// x=-1: reverse
{
    if(lq>rq)	return;
    if(l>=lq && r<=rq)
        if(x==-1)   addTag(i,1,1);
        else    addTag(i,x,0);
    else
    {
        int mid=(l+r)>>1;
        pushdown(i);
        if(mid>=lq) modify(lq,rq,x,i->lc,l,mid);
        if(mid<rq)  modify(lq,rq,x,i->rc,mid+1,r);
    }
}
void solve(pNode i=rt,int l=0,int r=maxx)
{
    if(l==r)
    {
        int now=((i->tg1==-1)?0:i->tg1)^i->tg2;
        if(!flag && now)
            printf("%c%d,",(l%2)?'(':'[',l/2),flag=1,empty=0;
        if(flag && !now)
            printf("%d%c ",l/2,(l%2)?']':')'),flag=0;
        return;
    }
    int mid=(l+r)>>1;
    pushdown(i);
    solve(i->lc,l,mid),solve(i->rc,mid+1,r);
}
struct Question
{
    char opt,lb,rb;
    int l,r;
}q[70005];
int main()
{
    while(gets(input))
    {
        Question &qs=q[++n];
        sscanf(input,"%c %c%d,%d%c",&qs.opt,&qs.lb,&qs.l,&qs.r,&qs.rb);
        maxx=max(maxx,qs.r);	
    }
    build(0,maxx=(maxx+1)*2);
    for(int i=1;i<=n;i++)
    {
        Question &qs=q[i];
        int l,r;
        l=qs.l*2+(qs.lb=='(');
        r=qs.r*2-(qs.rb==')');
        if(qs.opt=='U') modify(l,r,1);
        else if(qs.opt=='I')
            modify(0,l-1,0),modify(r+1,maxx,0);
        else if(qs.opt=='D')
            modify(l,r,0);
        else if(qs.opt=='C')
            modify(0,l-1,0),modify(r+1,maxx,0),modify(l,r,-1);
        else
            modify(l,r,-1);
    }
    solve();
    if(empty)	puts("empty set");
    return 0;
}
```

---

## 作者：Hadtsti (赞：0)

### 题意简述
对一个空集 $S$ 进行 $M(M\le 7\times10^4)$ 次操作，每次给出一个集合 $T$（以自然数区间形式给出），对 $S$ 进行以下五种操作之一：

1. $S=S\cup T$
2. $S=S\cap T$
3. $S=S-T$
4. $S=T-S$
5. $S=(S-T)\cup (T-S)$

求最终的 $S$。
### 题目分析
很直观的线段树题，分建树、修改、查询分别展开说明。

#### 建树
由于涉及到的区间都是自然数区间，因此需要维护的区间个数有限，用线段树的结点维护就可以了。

为了方便维护，我们可以将所有自然数自身组成的闭区间 $[k,k]$~~（这种区间按理说是不合法的，但是本题都这么写了就将就用吧）~~ 编号为 $2k$，将所有两个相邻自然数之间的开区间 $(k,k+1)$ 编号为 $2k+1$。我们姑且称这两种区间为“单位区间”，则所有的自然数区间都可以表示为“单位区间”的并。例如 $(a,b]$ 可以表示为编号 $2a+1$ 到 $2b$ 的“单位区间”之并，$[b,a)$ 可以表示为编号 $2a$ 到 $2b-1$ 的“单位区间”之并。

我们考虑线段树结点维护的信息。最基本地，每个结点维护其对应区间的两端“单位区间”的编号 $l$ 和 $r$。而考虑到题目中的操作实质上就是改变了一些“单位区间”是否在答案区间里的状态，因此再让结点维护其对应区间中在 $S$ 里的“单位区间”的个数 $cnt$。最后就是懒标记 $tag$，我们设计其可能值为 $-1,0,1,2$，分别代表无标记、将区间内全部“单位区间”都从 $S$ 中删除、将区间内全部“单位区间”都加入 $S$、将全部“单位区间”是否在 $S$ 里的状态取反（可能有点奇怪，可先看修改部分再理解）。标记累加的具体细节详见代码。

#### 修改
分析一下本题的五种操作：

对于操作 $1$，把 $T$ 中的所有“单位区间”加入 $S$ 里，即 $T$ 对应的的结点 $cnt$ 赋值为 $r-l+1$。

对于操作 $2$，把所有不在 $T$ 中的“单位区间”从 S 中去除，即除 $T$ 之外的区间对应的结点 $cnt$ 赋值为 $0$。

对于操作 $3$，把 $T$ 中的所有“单位区间”从 $S$ 中去除，即 $T$ 对应的结点 $cnt$ 赋值为 $0$。

对于操作 $4$，把不属于 $T$ 中的所有“单位区间”从 $S$ 中去除，并把属于 $T$ 中的所有“单位区间”状态取反即可。即除 $T$ 之外的区间对应的结点 $cnt$ 赋值为 $0$，$T$ 对应的结点 $cnt$ 赋值为 $r-l+1-cnt$。

对于操作 $5$，把属于 $T$ 中的所有“单位区间”状态取反，即 $T$ 对应的结点 $cnt$ 赋值为 $r-l+1-cnt$。


#### 查询

题目要求输出在 $S$ 中的区间，并不一定全都是结点对应的。但是注意到这些区间对应的所有结点一定满足 $cnt=r-l+1$，所以我们考虑递归找到所有满足该条件的结点，再将其对应的区间合并即可。

我们从根结点开始查询。当前结点满足 $cnt=r-l+1$，就把该结点对应的区间直接加到答案里，不再递归。否则，若左子结点的 $cnt≠0$，递归到左节点；若右子结点的 $cnt≠0$，则再递归到右节点。当然，如果最开始根结点 $cnt=0$，就输出 `empty set`。

答案区间的合并是简单的，不再赘述。至于输出，根据区间的端点奇偶性判断区间开闭并计算原编号即可。
### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
	int l,r,cnt,tag;	
}tr[524300];
char op[2],str[50];
int l[70010],r[70010],i,q,OP[70010],mx=INT_MIN,mn=INT_MAX,ans1[140010],ans2[140010],cnt,L;
bool pt(int l,int r)
{
	printf("%c%d,%d%c ",(l&1?'(':'['),l>>1,r+1>>1,(r&1?')':']'));
}
void pushup(int p)
{
	tr[p].cnt=tr[p<<1].cnt+tr[p<<1|1].cnt;
}
void addtag(int p,int val)
{
	if(!val)
	{
		tr[p].tag=0;
		tr[p].cnt=0;
	}//如果是全改成 0，直接设置即可。 
	else if(val==1)
	{
		tr[p].tag=1;
		tr[p].cnt=tr[p].r-tr[p].l+1;
	}//全改成 1 也类似。 
	else//取反情况较复杂。 
	{
		tr[p].cnt=tr[p].r-tr[p].l+1-tr[p].cnt;
		if(tr[p].tag==2)//如果原来就要取反，再取反就不变了。 
			tr[p].tag=-1;
		else if(tr[p].tag>-1)//如果原来是要全改成什么，取反后就是改成相反的数了 。 
			tr[p].tag=(!tr[p].tag);
		else
			tr[p].tag=2;//如果原来不改，就记上标记。 
	}
}//给结点 p 进行操作 val 
void pushdown(int p)
{
	if(tr[p].tag!=-1)
	{
		addtag(p<<1,tr[p].tag);//传给左子结点 
		addtag(p<<1|1,tr[p].tag);//传给右子结点 
		tr[p].tag=-1;//清空标记 
	}
}
void build(int p,int l,int r)
{
	tr[p].l=l,tr[p].r=r;
	tr[p].tag=-1;//初始没有标记。 
	if(l==r)
	{
		tr[p].cnt=0;//初始 S 为空 
		return;
	}
	int mid=l+r>>1;
	build(p<<1,l,mid);//建左子节点
	build(p<<1|1,mid+1,r);//建右子节点 
	pushup(p);
}
void change(int p,int l,int r,int val)
{
	if(tr[p].l>=l&&tr[p].r<=r)
	{
		addtag(p,val);//当前结点全在修改区间里，直接改。 
		return;
	}
	pushdown(p);//先传标记
	int mid=tr[p].l+tr[p].r>>1;
	if(l<=mid)//左子结点要改 
		change(p<<1,l,r,val);
	if(r>mid)//右子结点要改
		change(p<<1|1,l,r,val);
	pushup(p);
}
void query(int p)
{
	pushdown(p);//先传标记。 
	if(tr[p].cnt==tr[p].r-tr[p].l+1)
	{
		ans1[++cnt]=tr[p].l;
		ans2[cnt]=tr[p].r;//把结点的左右编号放到答案里 
		return;
	}
	if(tr[p<<1].cnt)
		query(p<<1);//左子结点有在 S 里的就查询
	if(tr[p<<1|1].cnt)
		query(p<<1|1);//右子结点有在 S 里的就查询
}
int main()
{
	while(scanf("%s %s",op+1,str+1)==2)	
	{
		q++;
		l[q]=r[q]=0;
		for(i=2;str[i]<='9'&&str[i]>='0';i++)
			l[q]=l[q]*10+str[i]-'0';
		for(i++;i<strlen(str+1);i++)
			r[q]=r[q]*10+str[i]-'0';
		if(str[1]=='[')
			l[q]=2*l[q];
		else
			l[q]=2*l[q]+1;
		if(str[strlen(str+1)]==']')
			r[q]=2*r[q];
		else
			r[q]=2*r[q]-1;
		if(op[1]=='U')
			OP[q]=1;
		else if(op[1]=='I')
			OP[q]=2;
		else if(op[1]=='D')
			OP[q]=3;
		else if(op[1]=='C')
			OP[q]=4;
		else
			OP[q]=5;
		mx=max(mx,r[q]);
		mn=min(mn,l[q]); 	//省空间，只在修改涉及到的最小值到最大值之间建树即可
	}
	mn--;//注意修改时会涉及到 mn-1 和 mx+1 
	mx++;
	build(1,mn,mx); 
	for(int i=1;i<=q;i++)
	{
		if(OP[i]==1)
			change(1,l[i],r[i],1);
		else if(OP[i]==2)
			change(1,mn,l[i]-1,0),change(1,r[i]+1,mx,0);
		else if(OP[i]==3)
			change(1,l[i],r[i],0);
		else if(OP[i]==4)
			change(1,mn,l[i]-1,0),change(1,l[i],r[i],2),change(1,r[i]+1,mx,0);
		else
			change(1,l[i],r[i],2);
	}
	if(!tr[1].cnt)//S 为空 
	{
		printf("empty set");
		return 0;
	}
	query(1);//查询 
	L=ans1[1];
	for(int i=2;i<=cnt;i++)
		if(ans1[i]-ans2[i-1]!=1)
		{
			pt(L,ans2[i-1]);
			L=ans1[i];
		}
	pt(L,ans2[cnt]);//输出 
	return 0;
}
```

---


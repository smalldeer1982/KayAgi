# 二分图 /【模板】线段树分治

## 题目描述

神犇有一个 $n$ 个节点的图。

因为神犇是神犇，所以在 $k$ 时间内有 $m$ 条边会出现后消失。

神犇要求出每一时间段内这个图是否是二分图。

这么简单的问题神犇当然会做了，于是他想考考你。

原 BZOJ4025。

## 说明/提示

### 样例说明

$0$ 时刻，出现两条边 $(1,2)$ 和 $(2,3)$。

第 $1$ 时间段内，这个图是二分图，输出 `Yes`。

$1$ 时刻，出现一条边 $(1,3)$。

第 $2$ 时间段内，这个图不是二分图，输出 `No`。

$2$ 时刻，$(1,2)$ 和 $(1,3)$ 两条边消失。

第 $3$ 时间段内，只有一条边 $(2,3)$，这个图是二分图，输出 `Yes`。

### 数据范围

$n,k = 10^5$，$m = 2\times 10^5$。$1 \le x,y \le n$，$0 \le l \le r \le k$。

### 注意

本题设有 hack 数据（Subtask $2$），计 $0$ 分，但若没有通过 hack 数据则不算通过本题。

## 样例 #1

### 输入

```
3 3 3
1 2 0 2
2 3 0 3
1 3 1 2
```

### 输出

```
Yes
No
Yes
```

# 题解

## 作者：JK_LOVER (赞：157)

# $\text{线段树分治}$
## $\text{引入}$
一张图有 $n$ 个节点的图， 在 $k$ 时间中会出现 $m$ 条边，表示有一条连接 $x,y$ 的边在  $l$ 时刻出现 $r$ 时刻消失，求问在第 $i$ 个时间段中图是否为二分图。
### $\text{分析}$
- ### 先对于二分图来分析

如果顶点 $V$ 可分割为两个互不相交的子集 $(A,B)$ ，并且图中的每条边 $(i,j)$ 所关联的两个顶点 $i$ 和 $j$ 分别属于这两个不同的顶点集 $(i \in A,j \in B)$ ，则称图 $G$ 为一个二分图。 —— 百度百科。

- 在一般的做法中对于一个图是否为二分图，我们一般是采用染色法，如果一个图为二分图，那么一条边所连接的两个点一定是在不同集合的，也就是点的颜色不同。

- 分析到这里，我们就有了最朴素的算法，对于每个时间段，我们可以建一张图，再用 $O(n)$ 的时间遍历染色。总的复杂度就为 $O(n^2\times k)$ 。

这样的时间复杂度和空间复杂度都必须优化。回忆一下我们在 [关押罪犯](https://www.luogu.com.cn/problem/P1525) 中还学了一种判断二分图的方法 **扩展域并查集** 。如果有不了解的，用几句话介绍一下。

- 扩展域并查集：对于一个节点 $i$ ，我们将其拆分为两个节点。一个属于集合 $S$ ，另一个属于集合 $T$ 。那么一条边所连接的两个节点就必须在不同的集合中。一个点在 $S$ 中和在 $T$ 的两个点属于一个集合，那么这张图就不是二分图。

其实有了扩展域并查集，我们并没有优化时间复杂度。这只是为下文的算法铺垫。

- ### 对于时间段分析

我们如果还要优化复杂度，那么我们就不能枚举每个时间段。必须找个更靠谱的算法。

- 如果学习过线段树优化建边，那么下文将好理解一些。我们把时间轴画出来，那么对于每一条边它总是在时间轴上覆盖了一些区域。所以对于一条边我们可以将其分解。

- 我们先将时间轴构建 $\log k$ 层，然后就像插入区间一样，把每一条边插入。因为对于线段树上的一个节点，它的子节点也一定被这条边覆盖，那么我们只需要在父亲节点储存这条边。那么这样对于一条边最大也只会分解为 $\log k $ 不重复的较小的边。
![](https://cdn.luogu.com.cn/upload/image_hosting/p2fgmu5l.png)

- 这样我们把所有询问下来，最后一次性处理。但是我们发现当我们处理完这个节点的子节点时，我们必须将并查集还原到处理之前的状态才可以递归处理其他节点了。难道我们这里只能写个 $LCT$ 这种支持 $O(\log n)$ 删边的数据结构？显然不是 。~~（否则讲这么久的并查集干啥）~~

![](https://cdn.luogu.com.cn/upload/image_hosting/ceoa7omc.png)

- 这里的并查集只需要维护一个集合所属关系，那么我们对其操作其实是非常简明的，就是改变父亲的所属关系。我们可以把所有操作放在栈里，当我们退出时，撤销原操作就行了。这样我们就不可以路径压缩了，因为每个节点是要储存真正的父亲的。为了保证复杂度的正确性，必须要按秩合并。大概就是树低的合并到树高的父亲下面，这样树的高度是不会高于 $O(\log n)$ 的。

- 那么这道题就算做完了。其主要是构建一个时间轴上的线段树，再通过并查集维护答案。时间复杂度为 $O(n\log k\log n)$ 。
## $\text{代码}$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 10101010;
int read(){
	int x = 0,f = 0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
	return f?-x:x;
}

int n,m,k,fa[N],height[N],top;
struct E{int x,y;}e[N];
struct Stack{int x,y,add;}st[N];
vector<int> t[N];

int findfa(int x)
{
	while(x != fa[x]) x = fa[x];
	return fa[x];
}
void debug()
{
	printf("\n****************\n下标");
	for(int i = 1;i <= n*2;i++) printf("%d ",i); 
	printf("\n父亲");
	for(int i = 1;i <= n*2;i++) printf("%d ",fa[i]);
	printf("\n祖先(代表元)");
	for(int i = 1;i <= n*2;i++) printf("%d ",findfa(i));
}
void merge(int x,int y)
{
	int fx = findfa(x),fy = findfa(y);
	if(height[fx] > height[fy]) swap(fx,fy);
	st[++top] = (Stack){fx,fy,height[fx] == height[fy]};
	fa[fx] = fy;
	if(height[fx] == height[fy]) height[fy]++;
}
void update(int u,int l,int r,int L,int R,int x)
{
	if(l > R || r < L) return;
	if(L <= l && r <= R) {t[u].push_back(x);return;}
	int mid = l + r >> 1;
	update(u<<1,l,mid,L,R,x);
	update(u<<1|1,mid+1,r,L,R,x);
}
void solve(int u,int l,int r)
{
//	debug();
	int ans = 1;
	int lasttop = top;
	for(int i = 0;i < t[u].size();i++)
	{
		int a = findfa(e[t[u].at(i)].x);
		int b = findfa(e[t[u].at(i)].y);
		if(a == b)
		{
			for(int k = l;k <= r;k++)
			printf("No\n");
			ans = 0;
			break;
		}
		merge(e[t[u].at(i)].x,e[t[u].at(i)].y+n);
		merge(e[t[u].at(i)].y,e[t[u].at(i)].x+n);
	}
	if(ans)
	{
		if(l==r) printf("Yes\n");
		else 
		{
			int mid = l+r>>1;
			solve(u<<1,l,mid);
			solve(u<<1|1,mid+1,r);
		}
	}
	while(top > lasttop)
	{
		height[fa[st[top].x]] -= st[top].add;
		fa[st[top].x] = st[top].x;
		top--;
	}
	return;
}
int main()
{
	n = read();m = read();k = read();
	for(int i = 1;i <= m;i++)
	{
		e[i].x = read();e[i].y = read();
		int l = read()+1,r = read();
		update(1,1,k,l,r,i);
	}
	for(int i = 1;i <= 2*n;i++) fa[i] = i,height[i] = 1;
	solve(1,1,k);
	return 0;
}
```

## $\text{应用}$
- CF1140F
- P5227
- P4585
- CF576E


---

## 作者：xht (赞：111)

## 核心思想

考虑这样一个问题：

- 有一些操作，每个操作只在 $l \sim r$ 的时间段内有效。
- 有一些询问，每个询问某一个时间点所有操作的贡献。

对于这样的询问，我们可以离线后**在时间轴上建一棵线段树**，这样对于每个操作，相当于在线段树上进行区间操作。

遍历整颗线段树，到达每个节点时执行相应的操作，然后继续向下递归，到达叶子节点时统计贡献，回溯时撤销操作即可。

这样的思想被称为**线段树分治**，可以在低时间复杂度内解决一类**在线算法并不优秀**的问题。

#### 【例题】[P5787 二分图 /【模板】线段树分治](https://www.luogu.com.cn/problem/P5787)

首先，图是二分图的充要条件是不存在奇环，这个可以用**扩展域并查集**轻松维护。

按照上述思想建一棵线段树，对于每条边，将它按照线段树区间操作的方式划分成 $\mathcal O(\log k)$ 段，用 `vector` 挂在线段树的节点上。

遍历时，从根节点出发，每到一个节点，将挂在该节点上的所有边合并，然后递归处理左儿子和右儿子。如果发现有某条边合并会出现奇环，那么当前线段树节点所对应的时间区间都不会形成二分图。

当到达叶子节点时，如果合并了所有挂在当前节点上的边，依旧满足二分图的性质，那么可以直接输出 `Yes`。

回溯时，由于并查集不支持删边，我们可以使用**可撤销并查集**，即用一个栈记录下所有对并查集的操作。由于可撤销，因此不能路径压缩，为保证复杂度，必须按秩合并。

总时间复杂度 $\mathcal O(m \log n \log k)$。

```cpp
const int N = 1e5 + 7, M = 2e5 + 7;
int n, m, k, u[M], v[M], f[N<<1], d[N<<1];
struct T {
	int l, r;
	vi e;
} t[N<<2];
stack< pi > s;

void build(int p, int l, int r) {
	t[p].l = l, t[p].r = r;
	if (l == r) return;
	build(ls, l, md), build(rs, md + 1, r);
}

void ins(int p, int l, int r, int x) {
	if (t[p].l >= l && t[p].r <= r) return t[p].e.pb(x), void();
	if (l <= md) ins(ls, l, r, x);
	if (r > md) ins(rs, l, r, x);
}

inline int get(int x) {
	while (x ^ f[x]) x = f[x];
	return x;
}

inline void merge(int x, int y) {
	if (x == y) return;
	if (d[x] > d[y]) swap(x, y);
	s.push(mp(x, d[x] == d[y])), f[x] = y, d[y] += d[x] == d[y];
}

void dfs(int p, int l, int r) {
	bool ok = 1;
	ui o = s.size();
	for (ui i = 0; i < t[p].e.size(); i++) {
		int x = t[p].e[i], u = get(::u[x]), v = get(::v[x]);
		if (u == v) {
			for (int j = l; j <= r; j++) prints("No");
			ok = 0;
			break;
		}
		merge(get(::u[x] + N), v), merge(get(::v[x] + N), u);
	}
	if (ok) {
		if (l == r) prints("Yes");
		else dfs(ls, l, md), dfs(rs, md + 1, r);
	}
	while (s.size() > o) d[f[s.top().fi]] -= s.top().se, f[s.top().fi] = s.top().fi, s.pop();
}

int main() {
	rd(n), rd(m), rd(k), build(1, 1, k);
	for (int i = 1, l, r; i <= m; i++) {
		rd(u[i]), rd(v[i]), rd(l), rd(r);
		if (l ^ r) ins(1, l + 1, r, i);
	}
	for (int i = 1; i <= n; i++) f[i] = i, f[i+N] = i + N;
	dfs(1, 1, k);
	return 0;
}
```

---

## 作者：Owen_codeisking (赞：49)

没人发一个 log 的解法？qwq

一个图是二分图当且仅当不存在奇环。

考虑现在有一个环，在环上删除时间最小的边删除后，这个环就消失掉了。

那么我们可以维护一个删除时间最大的生成树，然后尝试加入这些边。若两点之间不连通，那么直接连上这条边，否则如果这条边的删除时间比路径中删除时间最小的边大，删除那条边，加入这条边。

时间复杂度 $O(n\log n)$。

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=300005;
const int inf=0x3f3f3f3f;
int n,m,T,vis[maxn],ans[maxn],ch[maxn][2],fa[maxn],siz[maxn],id[maxn],sta[maxn],top;bool rev[maxn];
vector<int> in[maxn],out[maxn];
struct Edge
{
    int x,y,st,ed;
}e[maxn];
inline void reverse(int x) { if(!x) return; swap(ch[x][0],ch[x][1]),rev[x]^=1; }
inline void pushup(int x)
{
    siz[x]=siz[ch[x][0]]+siz[ch[x][1]]+(x>n);
    id[x]=(x>n)?x-n:0;
    if(ch[x][0] && e[id[ch[x][0]]].ed<e[id[x]].ed) id[x]=id[ch[x][0]];
    if(ch[x][1] && e[id[ch[x][1]]].ed<e[id[x]].ed) id[x]=id[ch[x][1]];
}
inline void pushdown(int x) { if(rev[x]) reverse(ch[x][0]),reverse(ch[x][1]),rev[x]=0; }
inline bool nrt(int x) { return ch[fa[x]][0]==x||ch[fa[x]][1]==x; }
inline void rotate(int x)
{
    int y=fa[x],z=fa[y],k=(ch[y][1]==x),u=ch[x][k^1];
    if(nrt(y)) ch[z][ch[z][1]==y]=x;
    ch[y][k]=u;ch[x][k^1]=y;
    if(u) fa[u]=y;fa[y]=x;fa[x]=z;
    pushup(y);pushup(x);
}
inline void splay(int x)
{
    int y,z; top=0;
    for(y=x;nrt(y);y=fa[y]) sta[++top]=y;
    pushdown(y);
    while(top) pushdown(sta[top--]);
    while(nrt(x))
    {
        y=fa[x],z=fa[y];
        if(nrt(y)) rotate((ch[y][1]==x)^(ch[z][1]==y)?x:y);
        rotate(x);
    }
}
inline void access(int x)
{
    for(int y=0;x;y=x,x=fa[x])
        splay(x),ch[x][1]=y,pushup(x);
}
inline int findroot(int x)
{
    access(x),splay(x);
    for(;ch[x][0];x=ch[x][0]) pushdown(x);
    return x;
}
inline void makeroot(int x) { access(x),splay(x),reverse(x); }
inline void split(int x,int y) { makeroot(x),access(y),splay(y); }
inline void link(int x,int y) { makeroot(x),fa[x]=y; }
inline void cut(int x,int y) { split(x,y),fa[x]=ch[y][0]=0,pushup(y); }
int main()
{
    scanf("%d%d%d",&n,&m,&T);
    e[0].ed=inf;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d%d",&e[i].x,&e[i].y,&e[i].st,&e[i].ed);
        in[e[i].st].push_back(i);
        out[e[i].ed].push_back(i);
    }
    for(int i=1;i<=n+m;i++) id[i]=(i>n)?i-n:0;
    int p,x,y,z,now=0;
    for(int i=0;i<T;i++)
    {
        for(int j=0,k=out[i].size();j<k;j++)
        {
            p=out[i][j],x=e[p].x,y=e[p].y;
            if(!vis[p]) vis[p]=1,cut(x,p+n),cut(y,p+n);
        }
        for(int j=0,k=in[i].size();j<k;j++)
        {
            p=in[i][j],x=e[p].x,y=e[p].y;
            if(findroot(x)==findroot(y))
            {
                split(x,y),z=id[y];
                if(e[p].ed<e[z].ed) z=p;
                if(siz[y]%2==0) now=max(now,e[z].ed);
                vis[z]=1;
                if(z!=p)
                {
                    cut(e[z].x,z+n),cut(e[z].y,z+n);
                    link(e[p].x,p+n),link(e[p].y,p+n);
                }
            }
            else link(x,p+n),link(y,p+n);
        }
        if(i<now) printf("No\n");
        else printf("Yes\n");
    }
    return 0;
}
```

---

## 作者：crashed (赞：24)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P5787)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线段树分治入门题。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先将之与 CDQ 区别一下，方便辨认。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDQ 分治的核心思想就是将修改和询问丢一块，然后左右区间合并上来的时候考虑左边区间对右边区间的贡献。经典的例子就是计算逆序对和偏序对的问题。 CDQ 分治处理的修改一般都是**永久性的，不可撤销**。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而线段树分治仅对询问区间进行分治，并且修改对应**一段区间**，也就相当于**可撤销**。这样一一来，每个修改对应的就是一段询问区间。那么就可将询问建成 " 线段树 " 的模样，而修改就可以拆分成对于$O(\log_2n)$个线段树节点进行修改。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中一种分治方法是，当修改拆分好了之后，我们就对整棵 " 线段树 " 进行一发 DFS ，中途维护修改信息。也就是按照 DFS 的顺序，进入节点的时候将修改信息插入，即将离开的时候将修改信息删除。这个方法适合维护**便于快速维护单点的贡献**。例如本题，由于每次修改只会影响两个点，那么就可以用这种分治方法。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里提到的 " 线段树 " 既可以真的建一棵线段树，然后用 vector 维护被影响到的操作；也可以在 DFS 的时候用一个 vector 存下来与当前区间有交集的操作，然后像线段树那样将操作划分给子区间。本题解使用后者实现。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再说到本题上来。首先不难想到要用并查集来维护一下连通性。由于存在删除操作，所以使用秩优化而非路径压缩。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面考虑维护路径长度以判断会否出现奇环。实际上，由于只有路长的奇偶性才会影响最终的结果，所以我们只需要维护路径的奇偶性即可。为了方便，我们希望用并查集顺便维护一下这个信息。由于秩优化的并查集的祖孙关系是正确的，所以我们可以在并查集树上找到正确的 LCA 。自然而然，我们想到了，最好是可以让并查集中两点的路径奇偶性就对应实际图上的两点路径奇偶性。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不难发现一种方法：并查集上每个点维护**当它和它父亲连起来时的路径长度**。栗子： 
![P1.png](https://i.loli.net/2020/02/28/mZUarLRdFcsQgnI.png)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 4 和 6 连起来的时候，并查集上实际是 1 和 5 连起来，而此时 1 和 5 的距离就是 $(\text{ 4 到 1 的距离})+(\text{ 6 到 5 的距离})+1$，即 4 。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查询同一并查集内两点之间的距离有两种方法。一个是在并查集上面暴力爬 LCA ，另一个是直接查询两个点各自到的距离的和的**奇偶性**。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个方法为什么是正确的呢？因为我们只需要知道奇偶性，因此一条路径走两遍**不会影响结果**。因此，两点的 LCA 到根的距离会被算两遍，就不会影响结果的奇偶性了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在回溯撤销操作的时候可以拿一个栈来存下需要撤销的操作，然后就边弹边清除即可。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用线段树分治的主体，外加并查集维护信息，我们做到了$O(n\log_2^2n)$的优秀时间复杂度。  
# 代码
```cpp
#include <cstdio>
#include <vector>
using namespace std;

typedef vector<int> vi;

const int MAXN = 1e5 + 5, MAXK = 1e5 + 5, MAXM = 2e5 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
void swapp( _T &x, _T &y )
{
	_T t = x; x = y, y = t;
}

struct data
{
	int r1, r2;
	data() { r1 = r2 = 0; }
	data( const int R1, const int R2 ) { r1 = R1, r2 = R2; } 
};

data sta[MAXM]; int top;
int fa[MAXN], siz[MAXN];
int x[MAXM], y[MAXM], tl[MAXM], tr[MAXM];
int N, M, K;
bool dis[MAXN];

int findSet( const int u ) { if( fa[u] == u ) return u; return findSet( fa[u] ); }
void makeSet( const int s ) { for( int i = 1 ; i <= s ; i ++ ) fa[i] = i, siz[i] = 1; }
int getDist( const int u ) { if( fa[u] == u ) return dis[u]; return dis[u] ^ getDist( fa[u] ); }

bool unionSet( const int u, const int v, int &a, int &b )
{
	int r1 = findSet( u ), r2 = findSet( v );
	if( r1 == r2 ) return false;
	if( siz[r1] > siz[r2] ) swapp( r1, r2 );
	fa[r1] = r2;
	siz[r2] += siz[r1];
	dis[r1] = getDist( u ) ^ getDist( v ) ^ 1;
	a = r1, b = r2;
	return true;
}

void divide( const int l, const int r, const vi op )
{
	vi L = vi(), R = vi();
	int len = op.size(), mid = l + r >> 1, but = top;
	bool flag = true;
	for( int i = 0, u, v, lef, rig, r1, r2 ; i < len ; i ++ )
	{
		u = x[op[i]], v = y[op[i]], lef = tl[op[i]], rig = tr[op[i]];
		if( lef <= l && r <= rig )
		{
			if( unionSet( u, v, r1, r2 ) ) sta[++ top] = data( r1, r2 );
			else if( getDist( u ) == getDist( v ) ) { flag = false; break; }
		}
		else
		{
			if( lef <= mid ) L.push_back( op[i] );
			if( rig > mid ) R.push_back( op[i] );
		}
	}
	if( flag ) 
	{
		if( l == r ) puts( "Yes" );
		else divide( l, mid, L ),  divide( mid + 1, r, R );
	}
	else for( int i = l ; i <= r ; i ++ ) puts( "No" );
	while( top > but )
	{
		int r1 = sta[top].r1, r2 = sta[top].r2;
		siz[r2] -= siz[r1], fa[r1] = r1, dis[r1] = 0;
		top --;
	}
}

int main()
{
	vi st = vi();
	read( N ), read( M ), read( K );
	makeSet( N );
	for( int i = 1 ; i <= M ; i ++ ) 
		read( x[i] ), read( y[i] ), read( tl[i] ), read( tr[i] ), tl[i] ++, 
		st.push_back( i );
	divide( 1, K, st );
	return 0;
}
```

---

## 作者：zhengrunzhe (赞：19)

提供一个lct做法

显然这种东西可以大力lct随便维护

每个边用扫描线思想分成加入和删除两次，边权为删除时间，用lct维护最大生成树

从时间0到k扫一遍

加边如果不成环直接加

否则看加进去是否构成奇环(lct路径长度随便维护一下就好了)

构成奇环就把多余的边(环上的最小边)标记一下，并做统计

删边在树种直接删

否则看有没有被标记 被标记了就统计数减小

然后看统计数是不是为0输出即可
```cpp
#include<cstdio>
#include<vector>
#include<cstddef>
using std::vector;
template<class type>inline const void swap(type &a,type &b)
{
	const type c(a);a=b;b=c;
}
template<class type>inline const void read(type &in)
{
	in=0;char ch(getchar());bool f(0);
	while (ch<48||ch>57){if (ch=='-')f=1;ch=getchar();}
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
	if (f)in=-in;
}
const int N(1e5+10),M(2e5+10),inf(2147483647);
namespace Link_Cut_Trees
{
	struct data
	{
		int val,id;
		inline data():val(inf),id(0){}
		inline data(const int &val,const int &id):val(val),id(id){}
		inline data operator+(const data &d)
		{
			return val<d.val?data(val,id):data(d.val,d.id);
		}
	};
	struct tree
	{
		bool rev;
		int size;
		data val,mn;
		tree *son[2],*fa;
		static tree *null;
		void *operator new(size_t size);
		void *operator new[](size_t size);
		inline tree():size(0),rev(0)
		{
			static bool init(0);
			if (!init)
				init=1,
				null=new tree,
				null->fa=null->son[0]=null->son[1]=null;
			son[0]=son[1]=fa=null;
		}
		inline const void pushup()
		{
			size=son[0]->size+1+son[1]->size;
			mn=son[0]->mn+val+son[1]->mn;
		}
		inline const void reverse()
		{
			swap(son[0],son[1]);rev^=1;
		}
		inline const void pushdown()
		{
			if (rev)
				son[0]->reverse(),
				son[1]->reverse(),
				rev=0;
		}
		inline const bool isroot()
		{
			return fa->son[1]!=this&&fa->son[0]!=this;
		}
		inline const bool identity()
		{
			return fa->son[1]==this;
		}
		inline const void rotate()
		{
			const bool f(identity());
			tree *fa(this->fa),*gfa(fa->fa),*q(son[!f]);
			if (!fa->isroot())gfa->son[fa->identity()]=this;
			(son[!f]=fa)->son[f]=q;
			((q->fa=fa)->fa=this)->fa=gfa;
			fa->pushup();
		}
		inline const void relieve()
		{
			if (!isroot())fa->relieve();
			pushdown();
		}
		inline const void splay()
		{
			for (relieve();!isroot();rotate())
				if (!fa->isroot())
					(fa->identity()^identity()?this:fa)->rotate();
			pushup();
		}
	};
	tree* tree::null;
	#define null tree::null
	inline const void access(tree *x)
	{
		tree *p(x);
		for (tree *y=null;x!=null;x=(y=x)->fa)
			x->splay(),x->son[1]=y,x->pushup();
		p->splay();
	}
	inline const void evert(tree *x)
	{
		access(x);x->reverse();
	}
	inline const void expose(tree *x,tree *y)
	{
		evert(x);access(y);
	}
	inline tree *findroot(tree *x)
	{
		for (access(x);x->son[0]!=null;x->pushdown())x=x->son[0];
		x->splay();return x;
	}
	inline const void link(tree *x,tree *y)
	{
		evert(x);x->fa=y;
	}
	inline const void cut(tree *x,tree *y)
	{
		expose(x,y);y->son[0]=x->fa=null;y->pushup();
	}
	const int maxn(N+M);
	char memory_pool[maxn*sizeof(tree)],*tail(memory_pool+sizeof(memory_pool));
	inline void *tree::operator new(size_t size){return tail-=size;}
	inline void *tree::operator new[](size_t size){return tail-=size;}
	tree *node0,*edge0;
	inline tree *node(const int &x){return node0+x;}
	inline tree *edge(const int &x){return edge0+x;}
}using namespace Link_Cut_Trees;
bool intree[M],inset[M];
int n,m,t,x[M],y[M],cnt;
typedef vector<int>vit;
vit add[N],del[N];
inline const void insert(const int &e)
{
	const int u(x[e]),v(y[e]),w(edge(e)->val.val);
	if (u==v)return inset[e]=1,cnt++,void();
	if (findroot(node(u))!=findroot(node(v)))
		return intree[e]=1,link(node(u),edge(e)),link(edge(e),node(v));
	expose(node(u),node(v));
	const int len(node(v)->size-1>>1),mn(node(v)->mn.id),mv(node(v)->mn.val);
	if (w>mv)
		cut(node(x[mn]),edge(mn)),
		cut(edge(mn),node(y[mn])),
		intree[mn]=0,
		link(node(u),edge(e)),
		link(edge(e),node(v)),
		intree[e]=1;
	if (len&1^1)inset[w>mv?mn:e]=1,cnt++;
}
inline const void remove(const int &e)
{
	const int u(x[e]),v(y[e]);
	if (intree[e])cut(node(u),edge(e)),cut(edge(e),node(v));
	else if (inset[e])cnt--;
}
int main()
{
	read(n);read(m);read(t);
	node0=new tree[n+1];edge0=new tree[m+1];
	for (int i(1),s,e;i<=m;i++)
		read(x[i]),read(y[i]),
		read(s),read(e),
		add[s].push_back(i),
		del[e].push_back(i),
		edge(i)->val=edge(i)->mn=data(e,i);
	for (int i(0);i<t;i++)
	{
		for (vit::iterator j=add[i].begin();j!=add[i].end();j++)insert(*j);
		for (vit::iterator j=del[i].begin();j!=del[i].end();j++)remove(*j);
		puts(cnt?"No":"Yes");
	}
	return 0;
}
```

---

## 作者：摸鱼酱 (赞：18)

[也许更好的阅读体验](https://www.moyujiang.com/989.html)。

线段树分治其实个人更愿意认为它更像一种技巧而不是一个算法，即带撤销操作的时间分治。操作形式多为维护一些信息，操作可能有询问/执行操作/撤回操作，其操作的执行较为容易，但撤回困难。所以把操作，询问一起离线下来，每个操作只在时间轴上的一个区间生效，那么就可以在线段树上的这个区间打上操作的标记，维护信息，在叶子结点计算答案。

[模板题P5757](https://www.luogu.com.cn/problem/P5787)：一张 $n$ 个点的图，有 $m$ 条无向边会在 $[l_i,r_i]$ 时刻存在，求在 $[1,k]$ 时刻中每个时刻整张图是否是一张二分图。

$1\leq n\leq 10^5$，$1\leq l_i\leq r_i\leq k\leq 10^5$，$1\leq m\leq 2\times 10^5$。

前置知识：扩展域并查集判定二分图，可撤销并查集，线段树。

考虑二分图中一条边的意义为其两边端点不在同一部，则用 $x,x+n$ 代表 $x$ 与 $x$ 的对立点，和 $x$ 的对立点处于同一集合的则和 $x$ 不在同一部，那么二分图中一条边就是互相和对方的对立点相连，若出现 $x$ 和 $x+n$ 处于同一个集合则说明不是二分图，并且若 $x,y$ 是图变为非二分图加的最后一条边，那么 $x,x+n$，$y,y+n$ 之间会分别在同一个集合中。

可撤销并查集的原理是考虑并查集常见的两种优化，路径压缩和按秩合并，这里的秩可以是 size,depth，甚至是 rand，单独用 size 作为秩进行按秩合并的好处是，把 $x$ 并到 $y$ 上的操作只有累加 $sz_x$ 至 $sz_y$，更新 $fa_x$ 为 $y$，不难发现，若最近一次操作就是把 $x$ 并到 $y$，那么这个并上去的操作可以把 $sz$ 减回去，$fa$ 恢复，则做到了撤销。其限制在于只能按照并的顺序倒着撤销，即按照栈的顺序，否则后来并到 $x$ 上的贡献不能仅减去 $sz_x$ 来消除。

接下来我们考虑对于时间轴建立线段树，每个节点维护一个 vector，类似标记永久化地，把边放入其存在时间的线段树节点上，则叶子节点到根路径上所有 vector 里的边就是在其对应时刻存在的边。于是很自然地发现在线段树上 dfs，进入节点时把它 vector 中的元素插入并查集，离开的时候倒序撤销，则 dfs 栈默认就有按照顺序来撤销的性质，则到叶子节点的时候可以直接判断是否仍是二分图。

于是总复杂度 $O(m\log k\log n)$，[一份参考代码实现](https://www.luogu.com.cn/paste/2erif1z6)。

[例题CF576E](https://www.luogu.com.cn/problem/CF576E)：一张 $n$ 个点 $m$ 条边的无向图，颜色从 $1$ 到 $k$ 编号，初始边上颜色均为 $0$，$q$ 次修改操作把第 $e_i$ 条边的颜色修改为 $c_i$，定义一个合法状态为 $1\cdots k$ 每个颜色的边集分别构成的子图都是二分图，若修改之后由合法状态变为非法状态，则此次修改无效，求每次修改是否有效。

$1\leq n,m,q\leq 5\times 10^5$，$1\leq k\leq 50$。

考虑这题的形式和模板题非常像，数据范围也支持我们对于 $k$ 种颜色分别维护，所以考虑如何进行转化使得可以让我们类似地解决这个问题。

现在的困难在于，我们没有上一题一样得到一条边在某个时间内属于某个颜色的信息，于是我们考虑每条边的颜色情况。若边 $e_i$ 相邻的两次颜色修改时刻为 $x<y$，则我们可以看作，它在 $[x,x]$ 时刻修改了颜色，并且由于是单点变更，我们可以到叶子节点的时候尝试修改并判断是否合法，以此我们就能得到其在 $(x,y)$ 时间中的颜色，就和上面一题完全一致了。这里的逻辑是其递归到底层之后是没有被前面或后面的修改所包含的，而且由于是先处理左儿子，到 $(x,y)$ 的时候一定已经经过了叶子 $x$，可以知道其对应的颜色并加入，而且由于是在时间范围内加入，也并没有删除的操作。

于是总复杂度 $O(q\log q\log n+nk)$，[一份参考代码实现](https://www.luogu.com.cn/paste/zjfnwcii)。

[例题CF603E](https://www.luogu.com.cn/problem/CF603E)：一个 $n$ 个点的无向图，$m$ 次加入一条带权边 $(u,v,w)$，求每次加入后是否能选出一个边集使得点 $\operatorname{deg}_{1\cdots n}$ 均为奇数，如果可以，最小化该边集的最大权值并输出。

$1\leq n\leq 10^5$，$1\leq m\leq 3\times 10^5$。

这道题首先需要分析一下性质，首先选出来的边集中若存在环，我们显然可以把环删掉以得到不劣的答案，所以构成的每个联通块都是树。考虑一棵什么样的树可以满足性质，不难发现除了根有奇数个儿子，其它点都只有偶数个儿子，这启发我们通过对一棵任意树进行调整来控制根和非根的叶子数量：若一个点有偶数个儿子，则保留它与父亲的边，否则删掉，使其成为子树的根节点。如果能完整经过这样的调整，新形成的若干棵树就应该是合法的。考虑从叶子节点来看，一个非根节点的子树为其自身加上偶数个儿子的子树，则其 size 是奇数；一个根节点是它本身加上奇数个 size 为奇数的儿子的子树，所以它的 size 是偶数；从另一个角度，每个点度数都是奇数，而总度数是偶数（每条边贡献 $2$），也要求其 size 是偶数。则一棵 size 是偶数的树，若其每个非根节点 size 都为奇数，则一定合法，否则割掉所有 size 的偶数的子树就合法了，于是联通块 size 是偶数即为每个点度数为奇数的充要条件。

那么可以得到，若一个联通块点数为偶数，我们就可以通过一些调整，删除一些联通块中的边使其满足每个点的度数都是奇数，至此便得到了这个问题静态版解决方法：按边权从小到达加入并查集，直到不存在 size 为奇数的联通块。

但是对于动态的问题，我们如果沿用上面的做法，那么不按边权顺序加边的后果是，可能一次修改会导致整张图的结构发生巨大变化，这不是用目前的简单做法可以维护的。所以我们需要挖掘性质，找到其它做法。首先考虑这样一件事情，一条边可能存在于边集中的时间是一个区间或不存在，由于答案是单调不升的，观察一下可以得到，第 $i$ 条边可能产生贡献的时间为 $[i,j]$，其中 $j$ 是最后一个满足 $ans_j\ge val_i$ 的时刻。我们希望能得到这个区间，而答案又是单调不升的，所以我们把边按边权从小到大排序，并维护一个从前往后不退的指针，线段树分治到叶子节点 $[l,l]$ 之后，如果还没有满足不存在奇数大小联通块，则暴力推进指针并加入编号 $<l$ 的边直到合法。那么 $[i,j]$ 的 $j$ 怎么求呢？发现我们每次推进指针并加入边 $i$，其对应的 $j$ 就是 $l$，那么由于我们又是从后往前遍历的，则此时把 $i$ 放到 $[i,l)$ 上就好了，即这是一个一边分治一边覆盖的过程，覆盖的位置是根据分治的过程来决定的。

总复杂度依然是两只 $\log$，[一份参考代码实现](https://www.luogu.com.cn/paste/9swuwnm5)。

同样是两只 $\log$ 的复杂度，这题还可以用整体二分来解决，下面介绍一下整体二分的做法。

因为答案是单调的，我们用函数 $\text{solve}(l,r,L,R)$ 表示 $ans_{l\cdots r}\in [L,R]$，并且 $i<l$ 且 $val<L$ 的边已经加入可撤销并查集，接下来考虑如何分治。

和普通整体二分一样地，我们计算出 $m=\lfloor \frac{l+r}2 \rfloor$，$ans_{mid}$ 的值 $p$，并递归处理 $\text{solve}(l,m-1,p,R),\text{solve}(m+1,r,L,p)$，那么现在的问题就在于如何求 $ans_{m}$。

现在已经加入的边满足 $i<l$ 且 $val<L$，那么还需要加入的边有：

1. $l\leq i\leq m$ 且 $val< L$ 的边，对答案无影响，直接加入；
2. $L\leq val\leq R$ 且 $i\leq m$ 的边，按 $val$ 从小到大加入，直到满足条件，则此时的边权就是答案；

于是就可以得到 $p$，再在递归之前恢复/加边到满足递归前置要求（$i<l$ 且 $val<L$ 的边已经加入）再递归处理即可。

总复杂度两只 $\log$，实测跑得比线段树分治略快，[一份参考代码实现](https://www.luogu.com.cn/paste/i4bamlk2)。

---

## 作者：myee (赞：17)

### 前言

都说线段树分治空间复杂度是 $O(n\log n)$ 的，我们不妨把它优化到线性！

请确保你会基础的线段树分治。

### 思路

似乎是个经典的 trick？

考虑线段树分治的过程。
* 往时间序列里加**边**的信息。
* dfs 一遍线段树。

我们发现第一步很浪费空间。

怎么办？

注意到每条边『插入』的信息可以保存在根结点，在 dfs 时把信息下放并**不在本地留副本**，然后把边信息回给父亲。

时间复杂度保持不变，空间线性，不过时间常数应该巨大。

理论上也可以解决某些[半在线](https://www.luogu.com.cn/problem/CF576E)的题目。

---
### Code

使用**前向星**维护，也不见得慢了多少（这还是在使用 Heap-DSU 的基础上）。

空间低于 10MB。

```cpp
#include <algorithm>
#include <stdio.h>
#include <vector>
typedef long long llt;
typedef unsigned uint;typedef unsigned long long ullt;
typedef bool bol;typedef char chr;typedef void voi;
typedef double dbl;
template<typename T>bol _max(T&a,T b){return(a<b)?a=b,true:false;}
template<typename T>bol _min(T&a,T b){return(b<a)?a=b,true:false;}
template<typename T>T lowbit(T n){return n&-n;}
template<typename T>T gcd(T a,T b){return b?gcd(b,a%b):a;}
template<typename T>T lcm(T a,T b){return(a!=0||b!=0)?a/gcd(a,b)*b:(T)0;}
template<typename T>T exgcd(T a,T b,T&x,T&y){if(b!=0){T ans=exgcd(b,a%b,y,x);y-=a/b*x;return ans;}else return y=0,x=1,a;}
template<typename T>T power(T base,T index,T mod)
{
    T ans=1%mod;
    while(index)
    {
        if(index&1)ans=ans*base%mod;
        base=base*base%mod,index>>=1;
    }
    return ans;
}
uint Ra=1,Rb=10007,Rc=114513;
struct Rand{uint operator()(){return Ra=Ra*Rb+Rc;}};
namespace Heap_DSU //人类智慧势能并查集
{
    uint Fath[200005],H[200005];
    uint Used[200005],tp;
    voi bzr(uint n){for(uint i=0;i<n;i++)Fath[i]=i,H[i]=Rand()();}
    uint find(uint p){return Fath[p]==p?p:find(Fath[p]);}
    bol connected(uint a,uint b){return find(a)==find(b);}
    bol merge(uint a,uint b)
    {
        a=find(a),b=find(b);
        if(a==b)return Used[tp++]=a,false;
        if(H[a]<H[b])std::swap(a,b);
        Fath[b]=a,Used[tp++]=b;
        return true;
    }
    bol revoke()
    {
        if(!tp)return false;
        uint p=Used[--tp];
        if(p==Fath[p])return false;
        Fath[p]=p;return true;
    }
};
typedef std::pair<uint,uint>Pair;
typedef std::pair<Pair,Pair>Pair2;
Pair2 P[200005];
uint Last[200005],End[25]; // 使用前向星卡常。
voi insert_edge(uint dep,uint p){Last[p]=End[dep],End[dep]=p;}
voi dfs(uint l,uint r,uint dep)
{
    uint cnt=0;
    for(uint i=End[dep];~i;i=Last[i])if(P[i].second.first<=l&&P[i].second.second>=r)
    {
        cnt+=2;
        Heap_DSU::merge(P[i].first.first<<1,P[i].first.second<<1|1);
        Heap_DSU::merge(P[i].first.first<<1|1,P[i].first.second<<1);
        if(Heap_DSU::connected(P[i].first.first<<1,P[i].first.first<<1|1))
        {
            for(uint i=l;i<r;i++)puts("No");
            while(cnt--)Heap_DSU::revoke();
            return;
        }
    }
    if(r-l==1)puts("Yes");
    else{
        uint mid=(l+r)>>1;
        End[dep+1]=-1;
        for(uint i=End[dep],last=-1,nxt;~i;i=nxt)
        {
            nxt=Last[i];
            if(!(P[i].second.first<=l&&P[i].second.second>=r)&&P[i].second.first<mid)
            {
                ((~last)?Last[last]:End[dep])=nxt;
                insert_edge(dep+1,i);
            }
            else last=i;
        }
        dfs(l,mid,dep+1);
        for(uint i=End[dep+1],nxt;~i;i=nxt)nxt=Last[i],insert_edge(dep,i);
        End[dep+1]=-1;
        for(uint i=End[dep],last=-1,nxt;~i;i=nxt)
        {
            nxt=Last[i];
            if(!(P[i].second.first<=l&&P[i].second.second>=r)&&P[i].second.second>mid)
            {
                ((~last)?Last[last]:End[dep])=nxt;
                insert_edge(dep+1,i);
            }
            else last=i;
        }
        dfs(mid,r,dep+1);
        for(uint i=End[dep+1],nxt;~i;i=nxt)nxt=Last[i],insert_edge(dep,i);
    }
    while(cnt--)Heap_DSU::revoke();
}
int main()
{
#ifdef MYEE
    freopen("QAQ.in","r",stdin);
#endif
	uint n,m,k;scanf("%u%u%u",&n,&m,&k),Heap_DSU::bzr(n<<1);
    End[0]=-1;
    for(uint i=0;i<m;i++)
	{
		scanf("%u%u%u%u",&P[i].first.first,&P[i].first.second,&P[i].second.first,&P[i].second.second);
        P[i].first.first--,P[i].first.second--;
        insert_edge(0,i);
	}
	dfs(0,k,0);
	return 0;
}
```


---

## 作者：GaryH (赞：13)

# P5787 题解
这是一道线段树分治题，我来尽量的把线段树分治这个算法在这个题里的应用讲清楚。

我们可以注意到，如果我们能维护以下操作，我们就可以轻松的解决这道题：

1. 加一条无向边

2. 删除一条已经加过的边

3. 判断当前图是否为二分图

如果没有 $2$ 操作,我们就可以轻松的使用扩展域并查集解决这个问题。那就是说，我们需要对原先的并查集多维护一个删边的操作。那这个怎么做呢？

我们可以发现，单纯的并查集是可以支持撤销上一次操作的，我们只要维护一个栈，在并查集合并的同时，记录该次合并的左右端点即可。当然，因为我们需要保持并查集结构不发生本质改变，故我们需要使用按秩合并，并在栈中同时记录合并后新增的并查集树高，以方便后续的撤销。

即，栈中有如下三个元素： $u,v,add$ ， 分别代表一次合并中的左，右节点以及最后成为父亲的节点新增的树高。

但是，在这道题里，我们需要一个可以撤销一段时间的操作，故我们不能直接使用上述的并查集维护方法做这个题。但是，我们可以尝试着思考，如何将这个题转化成立马撤销的那种？

我们这时就可以考虑对时间轴分治，也就是线段树分治。我们考虑，一条边在时刻 $l$ 被加入，在时刻 $r$ 被删除，那么这条边在时间轴上影响的时间段就是 $[l,r]$ 。故我们可以将该区间在线段树上拆分成 $log(N)$ 个子区间，并分别在这 $log(N)$ 个子区间上打一个连边的标记，最后再一起处理所有询问即可。

更具体一点，我们在最后处理询问时顺序遍历整颗线段树。在遍历时，设在线段树上，当前节点对应的时间区间是 $[l,r]$ ，则这个节点上所有的连边标记都说明了：当前时间区间的任意一个子区间，或者说，当前节点子树内的任何一个节点，都会受这些标记的影响而连一些边。即：在这个时间段内，我们可以一直让这些标记对应的边保持联通状态，直到我们退出对这个节点对应子树的遍历。而在遍历该节点的所有祖先节点时连的边，即在遍历该节点对应子树的过程之前就已经连上的边，也都不会在退出这个过程之前断开。也就是说，我们这时就可以采用刚才所说的可撤销并查集，来辅助维护这个连边断边的过程，因为所有边在需要断开时，其在并查集的栈中的记录都已经处于了栈顶。当然，在遍历中，若是在只连了一部分边时就已经不是二分图了，我们就可以直接将这个时间段的答案设为不行，并退出遍历。

这样的时间复杂度是 $O((N+M)log(N))$ 的，因为纯按秩合并并查集的单次操作复杂度是 $O(log(N))$ 的，而一共连了 $M$ 条边，再加上线段树的复杂度 $O(Nlog(N))$ ，就是 $O((N+M)log(N))$ 的。

**code:**

```
const int N(2e6+10);
typedef vector < int > vi ;

int top;
int n,m,k;

struct Edge{int u,v;};
struct Node{int u,v,add;};

vi f[N];
//记录线段树上节点的连边标记
//由于一个节点可能会有若干个标记，但总标记数不超过m，故用vector存 

int fa[N];

Edge e[N];

Node stk[N];
//记录并查集合并，并维护撤销操作的栈 

int height[N];
//按秩合并，记录并查集树高 

inline int f_set(int x){
	while(x^fa[x]){x=fa[x];} return x;
}

inline void u_set(int u,int v){
	
	int fu=f_set(u),fv=f_set(v);
	if(height[fu]>height[fv])swap(fu,fv); 
	
	stk[++top]=(Node){fu,fv,height[fu]==height[fv]};
	
	fa[fu]=fv;
	height[fv]+=(height[fu]==height[fv]); 
}

#define mid ((l+r)>>1)
#define lsn p<<1,l,mid
#define rsn p<<1|1,mid+1,r

inline void ins(int p,int l,int r,int ql,int qr,int v){
	//在时间轴上插入每一条边
	if(ql>qr||l>qr||r<ql)return;
	if(ql<=l&&qr>=r)return f[p].pb(v),void();
    
	if(ql<=mid)ins(lsn,ql,qr,v);
	if(qr>mid) ins(rsn,ql,qr,v);
}

inline void solve(int p,int l,int r){
	//递归处理整颗线段树 
	
	int ok=1,lasttop=top,sz(f[p].size());
	
	rep(i,0,sz-1){
		
		int pos=f[p][i];
        
		int u=e[pos].u,v=e[pos].v;
		int fu=f_set(u),fv=f_set(v);
		
		if(fu^fv)u_set(u,v+n),u_set(v,u+n);
		//连边 
		else{ ok=0; rep(j,l,r){ puts("No"); } break; }
		//不是二分图，输出 "No" 并退出递归 
	}
	
	if(ok&&l==r)puts("Yes");
	//到达叶子节点，递归终止 
	
	if(ok&&l^r)solve(lsn),solve(rsn);
	//递归左右子节点 
	
	while(top>lasttop){
		
		int u=stk[top].u;
		int v=stk[top].v;
        
		height[v]-=stk[top].add;
		fa[u]=u,top--;
		//撤销操作
		
	}
}

int main(){
	
	n=read(),m=read(),k=read();
	
	rep(i,1,m){
		
		e[i].u=read(),e[i].v=read();
		int tl=read()+1,tr=read();
		
		ins(1,1,k,tl,tr,i);
		
	}
	
	rep(i,1,n<<1)fa[i]=i,height[i]=1;
	
	solve(1,1,k);
	
	return 0;
}

```

---

## 作者：WeLikeStudying (赞：10)

- 作者太菜不会打 LCT，所以这是一篇线段树分治的博客。
- 希望能讲到一些本质上的东西。

**引入**
- 需要你维护一个数据结构，支持加边，删边，维护连通性，怎么做？
- 我们知道普通的并查集加边是很容易的，但删除边却很困难（读者可以自行尝试一下，作者发现按秩合并，路径压缩都很难用）。
- 但是如果需要你维护一个数据结构，支持加边，回退到上一个操作之前的状态，维护连通性。
- 这其实是很容易的，我们只需要使用按秩合并的并查集，用一个栈记录一下每次合并更改了哪个的父亲，就可以轻易地维护。
- 事实上，非均摊复杂度的数据结构普遍能够高效维护“回退到上一个操作之前的状态”。（均摊复杂度的数据结构会打破当前的势）
- 但是我们怎么做到这一点呢？

**线段树分治**
- 它分治，分治的是什么，是时间。
- 线段树上的节点，存的，是包含该区间（实际上是一个时间段）的操作（同时操作不下传）。
- 那么 $n$ 个操作会变成 $n\lg t$ 个操作。
- 然后我们可以对线段树进行先序遍历，节点入栈就加入操作，节点出栈就撤回，如果插入和撤回的操作复杂度是 $f(m)$，那么总的复杂度就是 $n\lg t\cdot f(m)$。

**例题**
- [例题](https://www.luogu.com.cn/problem/P5787)。
- 在一个时间段 $[l,r]$ 内加入一条边（$l$ 时刻插入 $r$ 时刻删除）。
- 维护图是不是二分图。
- 所讲的跟上面的几乎一样，但选用的维护数据结构需要用到一种[特殊的并查集](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/bing-zha-ji)。
- [代码实现](https://www.luogu.com.cn/paste/o5n7k9np)。

**后记**
- 作者认为的难度。
- 可追溯化数据结构 $>$ 可持久化数据结构 $>$ 可撤回化数据结构 $\ge$ 画风正常的数据结构。

---

## 作者：Tenshi (赞：4)

> 目录
>
> 线段树分治
>
> 本题做法
>
> 实现



## 线段树分治

事实上线段树分治的做法很简单，就是**在时间轴上开线段树**，以方便处理在一段时间内其效果的操作。

比如说，现在整棵线段树维护的时间范围是 $[1, 3]$，开出的线段树自然是：

![](https://cdn.luogu.com.cn/upload/image_hosting/lijopwey.png)


现在有一个操作在时间 $[1, 2]$ 上作用，那么对应于线段树的节点就是：

![](https://cdn.luogu.com.cn/upload/image_hosting/hn53kuyx.png)

又有一个操作在时间 $[2, 3]$ 上作用，对应于线段树的节点就是：

![](https://cdn.luogu.com.cn/upload/image_hosting/3vww99sr.png)

根据线段树的性质，每个操作至多被划分成 $\rm{log}$ 个线段树节点上的操作，我们就将划分后的操作依次存入发生影响的线段树节点即可。

最后，我们**先序遍历**一遍这棵树，对于当前节点，使其存储的操作**生效**，然后在递归地访问左右子树后**撤销**即可。（这一步使用一个栈进行维护，操作生效时压栈，最后在弹栈的时候执行撤销）



## 本题做法

本题的操作是在一段时间内合并图上的两点（也就是连边），然后判断某时间是否为二分图，结合上面的线段树分治过程，直接在图上维护（例如考虑染色）当然很不方便。因此考虑使用扩展域并查集维护：而为了方便撤销操作，我们不可以进行路径压缩，只能采取**按秩合并**。



## 实现

实现的思路是：

- 先在时间轴 $[1, K]$ 建立线段树。

- 首先将操作分配（assign）进线段树节点的 `vector<pii> o` 中。

- 然后对整棵树进行询问，并相应地进行操作生效（这题是合并，也就是代码中的 merge）、撤销（resume）操作，

  - 如果当前区间会导出矛盾，那么我们可以直接在这个区间都输出 `No`。
  - 否则，继续向左右子树递归直到叶节点，如果直到叶节点都没有矛盾，直接输出 `Yes`。
  - 可以发现，因为是先序遍历，所以直接输出就能满足题目的输出要求。

  

```cpp
// Problem: P5787 二分图 /【模板】线段树分治
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5787
// Memory Limit: 256 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
 
#define debug(x) cerr << #x << ": " << (x) << endl
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define dwn(i,a,b) for(int i=(a);i>=(b);i--)
#define pb push_back
#define all(x) (x).begin(), (x).end()
 
#define x first
#define y second
using pii = pair<int, int>;
using ll = long long;
 
inline void read(int &x){
    int s=0; x=1;
    char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-')x=-1;ch=getchar();}
    while(ch>='0' && ch<='9') s=(s<<3)+(s<<1)+ch-'0',ch=getchar();
    x*=s;
}

const int N=2e5+50;

int n, m, K;

struct Msg{
	int x, y, z;
}stk[N];
int top;

struct Dsu{
	int fa[N], rk[N];
	
	void init(){
		rep(i,1,n<<1) fa[i]=i, rk[i]=1;
	}
	
	int find(int x){
		return x==fa[x]? x: find(fa[x]);
	}
	
	bool same(int x, int y){
		return find(x)==find(y);
	}
	
	void merge(int x, int y){
		x=find(x), y=find(y);
		if(x==y) return;
		if(rk[x]>rk[y]) swap(x, y);
		fa[x]=y;
		stk[++top]={x, y, rk[x]==rk[y]};
		if(rk[x]==rk[y]) rk[y]++;
	}
	
	void resume(Msg t){
		rk[t.y]-=t.z;
		fa[t.x]=t.x;
	}
}dsu;

struct Node{
	int l, r;
	vector<pii> o;
	
	#define ls u<<1
	#define rs u<<1|1
}tr[N<<2];

void build(int u, int l, int r){
	tr[u]={l, r};
	if(l==r) return;
	int mid=l+r>>1;
	build(ls, l, mid), build(rs, mid+1, r);
}

void assign(int u, int l, int r, int x, int y){
	if(l<=tr[u].l && tr[u].r<=r){
		tr[u].o.pb({x, y});
		return;
	}
	int mid=tr[u].l+tr[u].r>>1;
	if(l<=mid) assign(ls, l, r, x, y);
	if(mid<r) assign(rs, l, r, x, y);
}

void divi(int u){
	bool ng=false;
	int pre=top;
	for(auto &[x, y]: tr[u].o){
		dsu.merge(x, y+n);
		dsu.merge(y, x+n);
		if(dsu.same(x, x+n) || dsu.same(y, y+n)){
			ng=true;
			break;
		}
	}
	if(ng) rep(i,tr[u].l,tr[u].r) puts("No");
	else{
		if(tr[u].l==tr[u].r) puts("Yes");
		else{
			divi(ls);
			divi(rs);
		}
	}
	while(top!=pre){
		dsu.resume(stk[top--]);
	}
}

signed main(){
	cin>>n>>m>>K;
	build(1, 1, K);
	dsu.init();
	
	rep(i,1,m){
		int x, y, l, r; read(x), read(y), read(l), read(r);
		if(++l>r) continue;
		assign(1, l, r, x, y);
	}
	divi(1);
	
	return 0;
}
```



---

## 作者：Plozia (赞：3)

宣传博客 $\to$ [link](https://blog.csdn.net/BWzhuzehao/article/details/123849806)

# 1. 前言

线段树分治，是一种数据结构，常用来离线维护一张图的连通性。

大致来讲，这张图的边会在一段时间内出现，别的时间消失，然后会有一些询问，线段树分治解决的就是这样的问题。

# 2. 详解

模板题：[P5787 二分图 /【模板】线段树分治](https://www.luogu.com.cn/problem/P5787)，下面假定 $n,m$ 同阶。

首先考虑一个暴力做法：对于每一个时间，我们建图然后染色，这样复杂度是 $O(n^2k)$ 的。

当然另一种判定二分图的方式是扩展域并查集，就是对每个点建立两个点 $x$ 和 $x+n$，对于每条边 $(x,y)$ 合并 $x,y+n$ 和 $x+n,y$，如果有一条边 $(x',y')$ 满足 $x',y'$ 在一个集合内那么就不是二分图，否则就是二分图。

利用并查集做法复杂度照样是 $O(n^2k)$ 的，不过并查集有一个优势是在不进行路径压缩的情况下我们可以撤销操作。

注意到每条边覆盖的是一段时间，因此我们考虑在时间轴上建线段树，然后将每条边插入到其所对应的区间中。

插入方法类似于线段树的区间修改，考虑往下递归，当递归到的节点被完全包含于修改区间的时候在这个节点插入这条边，然后不往下递归，我们需要某个点的连边信息时从根节点直接搜到叶节点，中途的点存的边不断插入即可，如下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/1c679cf17a2c4b60b3a805e65282f8fb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUGxvemlh,size_20,color_FFFFFF,t_70,g_se,x_16)

$(3,5)$ 这条边被插入到了上图打勾的两个区间内。

然后考虑 dfs 整棵树，往下搜的时候加入当这个节点所存的边，用扩展域并查集判定二分图，如果一个区间判定出不是二分图则其维护的时间段全都要打上标记。

向下搜索就是不断加边，至于回溯，考虑用一个栈维护加边操作，回溯时弹栈还原并查集即可。注意在这种做法下是不能路径压缩的，因此必须采用按秩合并，而且是用高度合并而不是用子树大小合并，因为并查集查询的复杂度看的是高度不是子树大小。

注意模板题对时间轴的处理。

GitHub：[CodeBase-of-Plozia](https://github.com/Plozia/CodeBase-of-Plozia/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%93%E9%A2%98/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB/P5787%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB.cpp)

Code：

```cpp
/*
========= Plozia =========
	Author:Plozia
	Problem:P5787 二分图 /【模板】线段树分治
	Date:2022/3/27
========= Plozia =========
*/

#include <bits/stdc++.h>
using std::vector;
using std::stack;

typedef long long LL;
const int MAXN = 1e5 + 5;
int n, m, k, cnt, ans[MAXN], fa[MAXN << 1], Height[MAXN << 1];
struct node { int x, y, l, r; } Edge[MAXN << 1];
struct STA { int x, y, h; } ;
struct SgT
{
	vector <int> E;
}tree[MAXN << 2];
stack <STA> sta;

int Read()
{
	int sum = 0, fh = 1; char ch = getchar();
	for (; ch < '0' || ch > '9'; ch = getchar()) fh -= (ch == '-') << 1;
	for (; ch >= '0' && ch <= '9'; ch = getchar()) sum = sum * 10 + (ch ^ 48);
	return sum * fh;
}
int Max(int fir, int sec) { return (fir > sec) ? fir : sec; }
int Min(int fir, int sec) { return (fir < sec) ? fir : sec; }
int gf(int x) { while (fa[x] != x)  x = fa[x]; return x; }

void Insert(int p, int l, int r, int Num, int lp, int rp)
{
	if (lp >= l && rp <= r) { tree[p].E.push_back(Num); return ; }
	int mid = (lp + rp) >> 1;
	if (l <= mid) Insert(p << 1, l, r, Num, lp, mid);
	if (r > mid) Insert(p << 1 | 1, l, r, Num, mid + 1, rp);
}

void Merge(int x, int y)
{
	x = gf(x), y = gf(y);
	if (Height[x] > Height[y]) std::swap(x, y);
	sta.push((STA){x, y, Height[x] == Height[y]});
	fa[x] = y; Height[y] += (Height[x] == Height[y]);
}

void dfs(int p, int lp, int rp)
{
	int cnt = 0, flag = 0;
	for (int i = 0; i < tree[p].E.size(); ++i)
	{
		int x = Edge[tree[p].E[i]].x, y = Edge[tree[p].E[i]].y;
		if (gf(x) == gf(y))
		{
			for (int j = lp; j <= rp; ++j) ans[j] = 1;
			flag = 1; break ;
		}
		if (gf(x) != gf(y + n)) Merge(x, y + n), ++cnt;
		if (gf(y) != gf(x + n)) Merge(y, x + n), ++cnt;
	}
	if (lp < rp && !flag) { int mid = (lp + rp) >> 1; dfs(p << 1, lp, mid); dfs(p << 1 | 1, mid + 1, rp); }
	while (cnt--)
	{
		STA tmp = sta.top(); sta.pop();
		fa[tmp.x] = tmp.x; Height[tmp.y] -= tmp.h;
	}
}

int main()
{
	n = Read(), m = Read(), k = Read();
	for (int i = 1; i <= m; ++i)
	{
		int x = Read(), y = Read(), l = Read(), r = Read();
		Edge[i] = (node){x, y, l + 1, r};
		if (l + 1 <= r) Insert(1, l + 1, r, i, 1, k);
	}
	for (int i = 1; i <= n * 2; ++i) fa[i] = i, Height[i] = 1;
	dfs(1, 1, k);
	for (int i = 1; i <= k; ++i) puts((ans[i] == 0) ? ("Yes") : ("No"));
	return 0;
}
```

# 3. 总结

线段树分治将边拆解到区间里面，利用一些可撤销的数据结构进行 dfs 统计答案。

注意线段树分治是个离线算法，不能在线。

# 4. 参考资料

- [线段树分治 - jklover 的博客 - 洛谷博客](https://www.luogu.com.cn/blog/xzc/xian-duan-shu-fen-zhi)

---

## 作者：peterwuyihong (赞：3)

题意：给你一个 $n$ 个点，一开始互相独立。有若干条边，会在 $L$ **时刻**出现，$R$ **时刻**消失。问你在 $i\in[1,k]$ **时段** 时这个图是否是二分图。

刚学线段树分治，于是说说这是个什么东西。

你建立一棵线段树，每个节点表示这个**区间表示的时间**哪些边**存在**过，那么你拿一个 map 存一下边的编号，当你删除边的时候，就得出删除的边出现的时间段，最后再把剩下的边处理一下出现的时间段，然后进行对于所有的操作分治。

分治时，有一个 dfs 函数，来深搜线段树，搜到一个点，就表示现在要处理这个**区间的时间**存在的询问。注意到我们删边带来的复杂是毁灭性的，于是我们**改删边为撤销**，或者说**回滚**。

dfs 完左右的时间树后，撤销掉**这一段时间**进行的加边，简单地用栈维护即可。

当 dfs 到叶子节点，如果是询问，就回答询问。

```cpp
int n,m,k;
int X[200005],Y[200005],L[200005],R[200005];
vector<int>v[100005<<2];
void mdf(int L,int R,int id,int l=1,int r=k,int x=1){
	if(l>=L&&r<=R)return v[x].push_back(id);
	int mid=(l+r)>>1;
	if(L<=mid)mdf(L,R,id,l,mid,x<<1);
	if(R>mid)mdf(L,R,id,mid+1,r,x<<1|1);
}
int fa[200005],rk[200005],siz[200005];
int sta[200005<<1],top;
int get(int x){while(x!=fa[x])x=fa[x];return x;}
void merge(int x,int y){
	x=get(x),y=get(y);
	if(rk[x]>rk[y])swap(x,y);
	fa[x]=y;sta[++top]=x;
}
void GG(int x){
	int g;
	while(top>x){
		g=sta[top--];
		fa[g]=g;
	}
}
void dfs(int l=1,int r=k,int x=1){
	int now=top;
	int gg=0;
	for(int i:v[x]){
		if(get(X[i])==get(Y[i])){
			for(int o=l;o<=r;o++)cout<<"No"<<endl;
			gg=1;
			break;
		}
		merge(X[i]+n,Y[i]),merge(X[i],Y[i]+n);
	}
	if(!gg){
		if(l==r){
			cout<<"Yes"<<endl;
		}else{
			int mid=(l+r)>>1;
			dfs(l,mid,x<<1),dfs(mid+1,r,x<<1|1);
		}		
	}
	GG(now);
}
mt19937 rnd(time(NULL));
signed main(){
	cin>>n>>m>>k;
	rep(i,1,n*2)fa[i]=i,rk[i]=rnd(),siz[i]=1;
	rep(i,1,m){
		cin>>X[i]>>Y[i]>>L[i]>>R[i];
		if(L[i]!=R[i])mdf(L[i]+1,R[i],i);
	}
	dfs();
}
```
中间的并查集是基于[这个](https://www.luogu.com.cn/paste/xjnmhe25)写的，挺简单的

---

## 作者：漠寒 (赞：1)

## 分析

线段树分治呢，处理的就是这些基于时间上的物品加入删除问题，我们将所有事件离线处理，每一个询问代表一个时刻，对于每一个物品，处理它所存在的时段，概括一下就是用线段树来处理每一个物品能对哪些询问起作用。

所以线段树每一个节点就代表了一个时段，而在询问中我们通常是找某一个时间点，所以类似于标记永久化的思想，在从上到下的过程中，如果能覆盖一个区间，那区间内的点也能同样造成影响，所以我们先将每一个物品加到它对应的区间，用 vector 存储完全覆盖某一区间的物品有哪些。

然后我们就可以从大区间向小区间找，每到一个区间时，将完全覆盖该区间的边所带来的影响处理，然后将处理后的结果带给更小的区间。

现在知道了线段树分治了，考虑本题每加入一条边的影响。

是否形成二分图，就需要将点分为两类,使得每一条边的两侧都是不同类的点，我们再引入种类并查集。

就是将并查集扩大几倍，分为几部分，每部分表示每一个个体可能属于的种群，相当于每个个体在每一部分都有自己的点，每一部分内部的连边就相当于同类关系，不同部分间的连边就代表对应题目中所给出的种群间的某种特殊联系。

例如此题，我们将每个点拆为两个点，$i$ 表示第一类，$i+n$ 表示第二类，$i$ 与 $j+n$ 同一并查集内表示它们不同类，$i$ 与 $j$ 或 $i+n$ 与 $j+n$ 在同一并查集内表示它们同类，所以在连边时先判断两端点是否同类，如果同类则说明当前分治到的整个区间都不可行，因为下面只会连更多的边，不会抵消这个冲突，只可能带来更多的冲突，就可以直接回退。否则就将代表两者不同类的边连上。

分治中还存在的一个问题就是递归完左区间后，需要去除左区间对右区间的影响，所以此题的并查集不能路径压缩，因为在回到上一层时需将在该区间连上的边断掉，所以在连边时记录本次连边的儿子，以及父亲原并查集的深度（因为要保证按秩合并的正确性），在返回时倒序将状态还原即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ls rt<<1
#define rs rt<<1|1
inline void read(int &res){
	res=0;
	int f=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')res=(res<<1)+(res<<3)+c-48,c=getchar();
	res*=f;
}
int n,m,k;
int l[200005],r[200005],u[200005],v[200005];
int flag[200005][2];
int flagg[200005][2];
vector<int>V[400005];
void modify(int rt,int l,int r,int L,int R,int x){
	if(L>R)return;
	if(l>=L&&R>=r){
		V[rt].push_back(x);
		return;
	}
	int mid=(l+r)>>1;
	if(mid>=L)modify(ls,l,mid,L,R,x);
	if(mid<R)modify(rs,mid+1,r,L,R,x);
}
int fa[200005],siz[200005];
int find(int x){
	return fa[x]==x?x:find(fa[x]);
}
bool merch(int s){
	int x=u[s],y=v[s];
	if(find(x)==find(y))return 1;
	if(find(x+n)==find(y+n))return 1;
	int kx=find(x),ky=find(y+n);
	if(kx!=ky){
		if(siz[kx]<siz[ky]){//按秩合并基础操作 
			flag[s][0]=kx;//这次连边当儿子的是谁 
			flagg[s][0]=siz[ky];//他爹原来深度多少 
			fa[kx]=ky;
			siz[ky]=max(siz[ky],siz[kx]+1);
		}
		else {
			flag[s][0]=ky;
			flagg[s][0]=siz[kx];
			fa[ky]=kx;
			siz[kx]=max(siz[kx],siz[ky]+1);
		}
	}
	kx=find(x+n),ky=find(y);
	if(kx!=ky){
		if(siz[kx]<siz[ky]){
			flag[s][1]=kx;
			flagg[s][1]=siz[ky];
			fa[kx]=ky;
			siz[ky]=max(siz[ky],siz[kx]+1);
		}
		else {
			flag[s][1]=ky;
			flagg[s][1]=siz[kx];
			fa[ky]=kx;
			siz[kx]=max(siz[kx],siz[ky]+1);
		}
	}
	return 0;
}
void del(int x){
	if(flag[x][1]){
		int y=flag[x][1];
		int kx=find(y);
		siz[kx]=flagg[x][1];//将原状态复原 
		fa[y]=y;
	}
	if(flag[x][0]){
		int y=flag[x][0];
		int kx=find(y);
		siz[kx]=flagg[x][0];
		fa[y]=y;
	}
}
void sol(int rt,int l,int r){
	for(int i=0;i<V[rt].size();i++){
		int x=V[rt][i];
		if(merch(x)){
			for(int j=l;j<=r;j++)puts("No");//整个区间都不可行 
			for(int j=i-1;j>=0;j--){
				del(V[rt][j]);//倒序删除 
			}
			return;
		}
	}
	if(l==r){
		for(int i=V[rt].size()-1;i>=0;i--){ 
			del(V[rt][i]);
		}
		puts("Yes");
		return;
	}
	int mid=(l+r)>>1;
	sol(ls,l,mid);
	sol(rs,mid+1,r);
	for(int i=V[rt].size()-1;i>=0;i--){
		del(V[rt][i]);
	}
}
int main()
{
	read(n);read(m);read(k);
	for(int i=1;i<=m;i++){
		read(u[i]);read(v[i]);read(l[i]);read(r[i]);
		modify(1,1,k,l[i]+1,r[i],i);
	}
	for(int i=1;i<=2*n;i++)fa[i]=i,siz[i]=1;//预处理 
	sol(1,1,k);
}

```


---


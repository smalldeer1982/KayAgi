# 函数求值

## 题目描述

有两个长度均为 $n$ 的权值序列 $a,b$，常数 $p,k$，以及两个函数：

$$g(x) = \sum_{i=1}^x p^i \times a_i$$

$$f(x) = \sum_{i=1}^x g(i) ^ k \times b_i$$

有 $m$ 个操作，操作有以下三种：

*  $1\ x\ y$，表示将 $a_x$ 修改为 $y$。

*  $2\ x\ y$，表示将 $b_x$ 修改为 $y$。

*  $3\ x$，表示查询 $f(x)$ 对 $10 ^ 9 + 7$ 取模的值。

## 说明/提示

**【样例解释】**

   这是样例一操作四后的结果：

| $/$  | $1$ | $2$ | $3$ | $4$ | $5$ |
| :-: | :-: | :-: | :-: | :-: | :-: |
| $a_i$ | $0$ | $3$ |  $8$ | $8$ | $5$ |
| $b_i$ | $9$ | $2$ |  $8$ | $8$ | $6$ |
| $g(i)$ | $0$ | $3$ |  $11$ | $19$ | $24$ |
| $f(i)$ | $0$ | $6$ |  $94$ | $246$ | $390$ |

----------------------

**【数据范围】**

- 对于 $100\%%$ 的数据：

    $1 \le n,m \le 2 \times 10 ^ 5$。

    $0 \le a_i,b_i,p \le 10 ^ 9 + 6$。

    $1 \le x \le n$，$0 \le y \le 10 ^ 9 + 6$。

    $1 \le k \le 3$。

- **详细的数据范围：**

     测试点编号 | $n,m \le$ | $k$ | 特殊性质 
     :-: | :-: | :-: | :-:
     $1$ | $300$ | $\le 3$ |  无
     $2$ | $300$ | $\le 3$ |  无
     $3$ | $3 \times 10 ^ 3$ | $\le 3$ |  无
     $4$ | $3 \times 10 ^ 3$ | $\le 3$ |  无
     $5$ | $7 \times 10 ^ 4$ | $= 1$ | A
     $6$ | $7 \times 10 ^ 4$ | $= 1$ |  A
     $7$ | $7 \times 10 ^ 4$ | $= 1$ |  A
     $8$ | $7 \times 10 ^ 4$ | $= 2$ |  A 
     $9$ | $7 \times 10 ^ 4$ | $= 3$ |  A
     $10$ | $7 \times 10 ^ 4$ | $= 1$ |  B
     $11$ | $7 \times 10 ^ 4$ | $= 1$ |  B
     $12$ | $7 \times 10 ^ 4$ | $= 2$ | B
     $13$ | $7 \times 10 ^ 4$ | $= 3$ |  B
     $14$ | $7 \times 10 ^ 4$ | $= 3$ |  B
     $15$ | $7 \times 10 ^ 4$ | $= 1$ |  无
     $16$ | $7 \times 10 ^ 4$ | $= 2$ |  无
     $17$ | $7 \times 10 ^ 4$ | $= 3$ |  无
     $18$ | $2 \times 10 ^ 5$ | $= 1$ |  无
     $19$ | $2 \times 10 ^ 5$ | $= 2$ |  无
     $20$ | $2 \times 10 ^ 5$ | $= 3$ |  无

     A：任意时刻所有 $b_i = 1$。

     B：无操作二。

---------------------

**【提示】**

样例二满足A类性质，样例三满足B类性质。

## 样例 #1

### 输入

```
10 10 1 1
0 1 8 8 5 6 6 8 0 1 
9 2 8 8 6 2 5 0 1 8 
3 9
1 2 3
3 10
3 5
2 10 0
3 10
1 5 9
2 9 7
3 9
3 4
```

### 输出

```
610
1034
390
674
1018
246
```

## 样例 #2

### 输入

```
10 10 873892251 2
393158301 365328187 234823508 38818450 963771276 826653462 358628534 626503513 239326879 647251399 
1 1 1 1 1 1 1 1 1 1 
1 6 861625956
1 2 300158647
1 2 84103073
3 8
1 1 942644245
1 9 883742604
1 2 974963615
3 5
1 8 710319943
3 1
```

### 输出

```
35415628
483475596
154061492
```

## 样例 #3

### 输入

```
10 10 480345252 3
494173949 364489100 93066339 249297520 207335443 117096873 864460454 113006173 214332928 582507765 
5658914 222040024 221653308 296560771 594076100 151232714 410372721 23331041 374481229 184401699 
3 6
3 8
1 1 931776921
1 6 44943479
1 6 946828878
1 4 9046748
3 3
1 7 692410213
1 10 483672045
3 10
```

### 输出

```
214010503
321766325
894782746
274293582
```

# 题解

## 作者：chenxinyang2006 (赞：4)

- **算法1**

  完全按照式子算这个东西就行
  
  时间复杂度：$O(n ^ 2 m)$
  
  期望得分：10分

- **算法2**

  注意到 $g(x) = g(x - 1) + p ^ i \times a_i$
  
  所以 $g(i)$ 不用每次重新算，可以直接在上次的基础上修改
  
  时间复杂度：$O(nm)$
  
  期望得分：20分
  
- **前置科技**
  
   送分结束，接下来你需要一个技巧：线段树维护区间加、区间 $k$ 次方和

   设这个节点维护了区间 $[l,r]$ ，它们的值是 $a_l,a_{l + 1}...a_r$，$sum_k$ 是 $k$ 次方和，然后你要区间加 $x$

   显然，$sum_k = \sum\limits_{i = l} ^ r (a_i) ^ k$

   然后加了$x$以后，变成了 $sum_k = \sum\limits_{i = l} ^ r (a_i + x) ^ k$

   这里得看情况展开，假设 $k = 2$，那么这个就等于：

   $sum_2 = \sum\limits_{i = l} ^ r (a_i) ^ 2 + 2a_i x + x ^ 2$

   那么，$\sum\limits_{i = l} ^ r(a_i) ^ 2$ 就是本来的 $sum_2$ ，现在要给它加上：

    $\quad\sum\limits_{i = l} ^ r 2a_i x + x ^ 2$

   $=2x \times (\sum\limits_{i = l} ^ r a_i) + x ^ 2 \times (r - l + 1)$

    $=2x \times sum_1 + x ^ 2 \times (r - l + 1)$（这里是原来的$sum_1$）

   显然，这里就可以直接更新了
   
- **算法3**

   做这道题的关键点在于：想到维护每个$g(i)$
   
   这样，这个问题就转变为这样了：
   
   - 操作1：区间加
   
   - 操作2：修改一个点的权值
   
   - 操作3：查询带权$k$次方和
   
   当然，你可能不会维护这种奇怪的带权信息，可以先做$b_i = 1$的部分分
   
   然后就是套板子，没什么好说的
   
   期望得分：15 ~ 25分（取决于你会不会$k$次方和）

- **算法4**

   如果没有修改操作的话，查询带权$k$次方和不算太难，改为维护$g(i) \times b_i$就行了
   
   但是，这题有一个区间加的操作
   
   肯定还是需要维护$g(i) \times b_i$，看看对于每个$k$有什么影响
   
   设$ans_k = \sum\limits_{i = l} ^ r g(i) ^ k \times b_i$
   
   - $k = 1$，$ans_1 = \sum\limits_{i = l} ^ r g(i) \times b_i$ 
   
       区间加后，变为：
    
       $\quad\sum\limits_{i = l} ^ r (g(i) + x) \times b_i$
            
       $=(\sum\limits_{i = l} ^ r g(i) \times b_i) + (\sum\limits_{i = l} ^ r b_i) \times x$（乘法分配律）
 
       所以，只需要维护一个$b_i$之和就可以做了
       
   - $k = 2$，$ans_2 = \sum\limits_{i = l} ^ r g(i) ^ 2 \times b_i$ 
       
       $\quad\sum\limits_{i = l} ^ r (g(i) + x) ^ 2 \times b_i$ 
       
       $= \sum\limits_{i = l} ^ r (g(i) ^ 2 + 2g(i) x + x ^ 2) \times b_i$
       
       $=\sum\limits_{i = l} ^ r g(i) ^ 2 \times b_i + \sum\limits_{i = l} ^ r 2g(i)x \times b_i + \sum\limits_{i = l} ^ r x ^ 2 \times b_i$
       
       $=(\sum\limits_{i = l} ^ r g(i) ^ 2 \times b_i) + (\sum\limits_{i = l} ^ r g(i) \times b_i) \times 2x +  (\sum\limits_{i = l} ^ r b_i) \times x ^ 2 $
       
       并不需要维护更多的东西
       
   - $k = 3$，$ans_3 = \sum\limits_{i = l} ^ r g(i) ^ 3 \times b_i$ 
   
     不想写过程了，最后的结果是：$ans_3 = $
     
     $(\sum\limits_{i = l} ^ r g(i) ^ 3 \times b_i)  + (\sum\limits_{i = l} ^ r g(i) ^ 2 \times b_i) \times 3x + (\sum\limits_{i = l} ^ r g(i) \times b_i) \times 3x ^ 2 + (\sum\limits_{i = l} ^ r b_i \times) \times x ^ 3$
     
     其实也不是很难推，还是有规律的，不是吗？
   
   顺带一提，这里并不需要维护$sum_k$
   
   期望得分：25 ~ 50分（仍然取决于你的技巧）
   
- **算法5**

   现在需要支持修改权值了，这个怎么办呢？
   
   这里的每个$k$其实差别都不大，只要能够求出叶子节点修改后的准确数值，然后一路$pushup$就行了
   
   时间复杂度：$O(mk\ log(n))$
   
   期望得分：85 ~ 100分（取决于你的常数）
   
   [code](https://www.luogu.com.cn/paste/w623jvbl)

---

## 作者：sane1981 (赞：3)

## 背景
我最爱线段树了。
## 题目解读
[原题传送门](https://www.luogu.com.cn/problem/P6215)

首先我们发现 $p^i$ 珂以进行预处理。

之后，我们发现维护前缀和的前缀和实在有些麻烦。那么我们干脆维护每一个 $g(i)$。

到目前为止，我们的问题转化成了区间修改，单点修改，区间求和。

因为 $k \leq 3$，所以我们直接用线段树维护 $\sum\limits_{i=l}^{r}g(i)^k \cdot b_i$。这坨玩意怎么维护？
#### 操作 $1$ $x$ $y$
标记下传和修改一，对于 $[l,r]$ 我们把 $g(i)$ 都加上 $v$，分别有：

$$\begin{aligned} \sum\limits_{i=l}^{r}(g_i+v) b_i =\sum\limits_{i=l}^{r}g_ib_i+v \sum\limits_{i=l}^{r}b_i\end{aligned}$$

$$\begin{aligned} \sum\limits_{i=l}^{r}(g_i+v)^2 b_i &=\sum_{i=l}^{r}(g_i^2+2g_iv+v^2)b_i \\&= \sum\limits_{i=l}^{r}g_i^2b_i+2v \sum\limits_{i=l}^{r}g_ib_i+v^2\sum_{i=l}^{r}b_i \end{aligned}$$

$$\begin{aligned} \sum\limits_{i=l}^{r}(g_i+v)^3 b_i &=\sum_{i=l}^{r}(g_i^3+3g_i^2v+3g_iv^2+v^3)b_i \\&= \sum\limits_{i=l}^{r}g_i^3b_i+3v \sum\limits_{i=l}^{r}g_i^2b_i+3v^2\sum_{i=l}^{r}g_ib_i+v^3\sum_{i=l}^{r}b_i \end{aligned}$$

关于维护区间幂次和，可以说是[这一题](https://www.luogu.com.cn/problem/P1471)的升级版。
#### 操作 $2$ $x$ $y$
直接单点修改即可，操作就是乘以 $b_i$ 的逆元和 $y$。逆元用费马小定理即可。同时也要把 $b_i$ 赋值为 $y$。

好了，修改套个模板没什么可讲的，记住能取模的地方一定取模，废话说完了。上代码！

## AC_Code
```cpp
#include<bits/stdc++.h>
#define mid ((l+r)>>1)
#define ls (k<<1)
#define rs (k<<1|1)
using namespace std;
typedef long long ak;
const int N=2e5+5;
const ak P=1e9+7;
int n,m,K;
ak p,a[N],b[N],pi[N],g[N];
struct segement{
	ak sumG[4],add;
}xds[N<<2];
ak fastpow(ak u,ak v){
	ak res=1;
	while(v){
		if(v&1) res=res*u%P;
		u=u*u%P;
		v>>=1;
	}
	return res;
}
ak inverse(ak a){
	return fastpow(a,P-2)%P;
}
void pushup(int k){
	xds[k].sumG[0]=(xds[ls].sumG[0]+xds[rs].sumG[0])%P;
	xds[k].sumG[1]=(xds[ls].sumG[1]+xds[rs].sumG[1])%P;
	xds[k].sumG[2]=(xds[ls].sumG[2]+xds[rs].sumG[2])%P;
	xds[k].sumG[3]=(xds[ls].sumG[3]+xds[rs].sumG[3])%P;
}
void build(int l,int r,int k){
	if(l==r){
		xds[k].sumG[0]=b[l]%P;
		xds[k].sumG[1]=g[l]*b[l]%P;
		xds[k].sumG[2]=g[l]*g[l]%P*b[l]%P;
		xds[k].sumG[3]=g[l]*g[l]%P*g[l]%P*b[l]%P;
		return;
	}
	build(l,mid,ls);build(mid+1,r,rs);
	pushup(k);
}
void pushdown(int k){
	if(xds[k].add==0) return;
	xds[ls].add=(xds[ls].add+xds[k].add)%P;
	xds[rs].add=(xds[rs].add+xds[k].add)%P;
	ak pow1=xds[k].add,pow2=pow1*pow1%P,pow3=pow2*pow1%P;
	xds[ls].sumG[3]=(xds[ls].sumG[3]+3*pow1*xds[ls].sumG[2]%P+3*pow2*xds[ls].sumG[1]%P+pow3*xds[ls].sumG[0]%P)%P;
	xds[rs].sumG[3]=(xds[rs].sumG[3]+3*pow1*xds[rs].sumG[2]%P+3*pow2*xds[rs].sumG[1]%P+pow3*xds[rs].sumG[0]%P)%P;
	xds[ls].sumG[2]=(xds[ls].sumG[2]+2*pow1*xds[ls].sumG[1]%P+pow2*xds[ls].sumG[0]%P)%P;
	xds[rs].sumG[2]=(xds[rs].sumG[2]+2*pow1*xds[rs].sumG[1]%P+pow2*xds[rs].sumG[0]%P)%P;
	xds[ls].sumG[1]=(xds[ls].sumG[1]+pow1*xds[ls].sumG[0])%P;
	xds[rs].sumG[1]=(xds[rs].sumG[1]+pow1*xds[rs].sumG[0])%P;
	xds[k].add=0;
}
void ModifyA(int l,int r,int k,int ll,int rr,ak v){
	if(l>=ll&&r<=rr){
		xds[k].sumG[3]=(xds[k].sumG[3]+3*v*xds[k].sumG[2]%P+3*v*v%P*xds[k].sumG[1]%P+v*v%P*v%P*xds[k].sumG[0]%P)%P;
		xds[k].sumG[2]=(xds[k].sumG[2]+2*v*xds[k].sumG[1]%P+v*v%P*xds[k].sumG[0]%P)%P;
		xds[k].sumG[1]=(xds[k].sumG[1]+v*xds[k].sumG[0]%P)%P;
		xds[k].add=(xds[k].add+v)%P;
		return;
	}
	pushdown(k);
	if(ll<=mid) ModifyA(l,mid,ls,ll,rr,v);
	if(rr>mid) ModifyA(mid+1,r,rs,ll,rr,v);
	pushup(k);
}
void ModifyB(int l,int r,int k,int z,ak v){
	if(l==r){
		xds[k].sumG[0]=v;
		xds[k].sumG[1]=xds[k].sumG[1]*inverse(b[l])%P*v%P;
		xds[k].sumG[2]=xds[k].sumG[2]*inverse(b[l])%P*v%P;
		xds[k].sumG[3]=xds[k].sumG[3]*inverse(b[l])%P*v%P;
		return;
	}
	pushdown(k);
	if(z<=mid) ModifyB(l,mid,ls,z,v);
	else ModifyB(mid+1,r,rs,z,v);
	pushup(k);
}
ak Query(int l,int r,int k,int ll,int rr){
	if(l>=ll&&r<=rr) return xds[k].sumG[K];
	ak res=0;
	pushdown(k);
	if(ll<=mid) res=(res+Query(l,mid,ls,ll,rr)+P)%P;
	if(rr>mid) res=(res+Query(mid+1,r,rs,ll,rr)+P)%P;
	return res;
}
int main(){
	scanf("%d%d%lld%d",&n,&m,&p,&K);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	pi[0]=1;
	for(int i=1;i<=n;i++) pi[i]=pi[i-1]*p%P;
	for(int i=1;i<=n;i++) g[i]=(g[i-1]+pi[i]*a[i]%P)%P;
	for(int i=1;i<=n;i++) scanf("%lld",&b[i]);
	build(1,n,1);
	int op,c1;
	ak c2;
	while(m--){
		scanf("%d%d",&op,&c1);
		if(op==3) printf("%lld\n",Query(1,n,1,1,c1)%P);
		else{
			scanf("%lld",&c2);
			if(op==1){
				ModifyA(1,n,1,c1,n,pi[c1]*(c2-a[c1]+P)%P);
				a[c1]=c2;
			}else{
				ModifyB(1,n,1,c1,c2);
				b[c1]=c2;
			}
		}
	}
	return 0;
}
```


---

## 作者：LightningUZ (赞：0)

线段树指数和的变形题。题意很清楚，但是一层套一层的，考虑起来有点困难。

### 转化

发现 $p^i$ 是不变的。于是直接 `a[i]*=p[i]`，然后来考虑。

接下来发现，每次相当于要改 $a$，$b$，求 $a$ 的 “前缀和的k次方乘以b的前缀和”。

“前缀和的前缀和” 一类问题通常不好直接处理，而我们一般是用线段树维护前缀和，单点修改就变成了区间修改，然后这个答案也变成了线段树上的区间和。

这个题也类似，我们用线段树维护 “前缀和的k次方乘以b”，也就是 $g(i)^k\times b$。答案就是前缀和，单点修改就变成了奇奇怪怪的区间修改。

### 剩下的问题


1. 单点改 $a$

这个相当于对 $g$ 的一段后缀（可以看成区间）做加法。

2. 单点改 $b$

修改带的权

3. 区间查询

too simple，就是非常普通的线段树区间求和（关键在于维护信息）

考虑怎么维护。发现 $k\le 3$。很明显应该是用“线段树指数和问题”的类似思路来做。

[线段树指数和板子](http://acm.hdu.edu.cn/showproblem.php?pid=4578)

对于每个区间，设 $s[k]$ 表示区间 $g^k\times b$ 的和。注意， $k=0$ 时它就等于 $b$ 的和。

#### 1. g区间加

对于线段树上 $g$ 的某个区间加 $x$，相当于 $s[k]$ 从 $\sum g^k\times b$ 变成 $\sum (g+x)^k\times b$。暴力拆括号，然后由 $s$ 的定义代换一下，得：

$s[3]=s[0]x^3+3s[1]x^2+3s[2]x^1+s[3]$

$s[2]=s[0]x^2+2s[1]x+s[2]$

$s[1]=s[0]x+s[1]$

跟上面的指数和非常类似。

#### 2. 单点改b

跟上一个比，这太sb了。线段树遍历到单点的时候，根据定义暴力（复杂度 $O(4)$ ）修改一下 $s$；然后 $pushup$ 上去即可。

然后把查询写了，这个题就没了。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Flandre_Scarlet
{
    #define N 200005
    #define mod 1000000007
    #define int long long
    #define F(i,l,r) for(int i=l;i<=r;++i)
    #define D(i,r,l) for(int i=r;i>=l;--i)
    #define Fs(i,l,r,c) for(int i=l;i<=r;c)
    #define Ds(i,r,l,c) for(int i=r;i>=l;c)
    #define MEM(x,a) memset(x,a,sizeof(x))
    #define FK(x) MEM(x,0)
    #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))
    #define p_b push_back
    #define sz(a) ((int)a.size())
    #define all(a) a.begin(),a.end()
    #define iter(a,p) (a.begin()+p)
    int I() {char c=getchar(); int x=0; int f=1; while(c<'0' or c>'9') f=(c=='-')?-1:1,c=getchar(); while(c>='0' and c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar(); return (x=(f==1)?x:-x);}
    template <typename T> void Rd(T& arg){arg=I();}
    template <typename T,typename...Types> void Rd(T& arg,Types&...args){arg=I(); Rd(args...);}
    void RA(int *p,int n) {F(i,1,n) *p=I(),++p;}
    int n,m,p,k,a[N],g[N],b[N];
    struct node{int s[4];}; 
    node operator+(node a,node b)
    {
        node ans; 
        F(i,0,3) ans.s[i]=(a.s[i]+b.s[i])%mod; 
        return ans;
    }
    class SegmentTree
    {
    public:
        node t[N<<2]; int a[N<<2];
        SegmentTree() {FK(t);}
        #define ls ix<<1
        #define rs ix<<1|1
        #define lson (ls),L,mid
        #define rson (rs),mid+1,R
        #define index int ix=1,int L=1,int R=n
        void up(int ix) {t[ix]=t[ls]+t[rs];}
        void Build(index) // 建树的时候初始化点权
        {
            if (L==R)
            {
                t[ix].s[0]=b[L];
                F(i,1,3) t[ix].s[i]=t[ix].s[i-1]*g[L]%mod;
                return;
            }
            int mid=(L+R)>>1;
            Build(lson); Build(rson); up(ix); 
        }
        void AddOne(int x,index) // 单线段树节点加
        {
            int x2=x*x%mod,x3=x2*x%mod;
            a[ix]+=x; a[ix]%=mod;
            t[ix].s[3]+=t[ix].s[0]*x3%mod+3*t[ix].s[1]*x2%mod+3*t[ix].s[2]*x%mod; t[ix].s[3]%=mod;
            t[ix].s[2]+=t[ix].s[0]*x2%mod+2*t[ix].s[1]*x%mod; t[ix].s[2]%=mod;
            t[ix].s[1]+=t[ix].s[0]*x%mod; t[ix].s[1]%=mod;
        }
        void PushDown(index) 
        {
            if (a[ix]) 
            {
                int mid=(L+R)>>1; 
                AddOne(a[ix],lson); AddOne(a[ix],rson); a[ix]=0;
            }
        }
        void Changeb(int pos,int val,index) // 单点改b
        {
            if (L==R) {t[ix].s[0]=val; F(i,1,3) t[ix].s[i]=t[ix].s[i-1]*(g[L]+a[ix])%mod; return;}
            int mid=(L+R)>>1;
            PushDown(ix,L,R);
            if (pos<=mid) Changeb(pos,val,lson);
            else          Changeb(pos,val,rson);
            up(ix);
        }
        void Add(int l,int r,int x,index) // g区间加
        {
            if (l<=L and R<=r) {AddOne(x,ix,L,R); return;}
            PushDown(ix,L,R);
            int mid=(L+R)>>1;
            if (r<=mid)     Add(l,r,x,lson);
            else if (l>mid) Add(l,r,x,rson);
            else Add(l,mid,x,lson),Add(mid+1,r,x,rson);
            up(ix);
        }
        int Query(int l,int r,int k,index) // 查询
        {
            if (l<=L and R<=r) return t[ix].s[k];
            PushDown(ix,L,R);
            int mid=(L+R)>>1;
            if (r<=mid)     return Query(l,r,k,lson);
            else if (l>mid) return Query(l,r,k,rson);
            return Query(l,mid,k,lson)+Query(mid+1,r,k,rson); 
        }
    }T;
    void Input()
    {
        Rd(n,m,p,k); RA(a+1,n); RA(b+1,n);
    }
    int pw[N];
    void Soviet()
    {
        pw[0]=1; F(i,1,n) pw[i]=pw[i-1]*p%mod,g[i]=(g[i-1]+pw[i]*a[i])%mod;
        // 把g求出来
        T.Build();
        F(i,1,m)
        {
            int o=I();
            if (o==1) 
            {
                int x=I(),y=I();
                int del=pw[x]*(y-a[x])%mod; del=(del%mod+mod)%mod; // 求增量,把修改操作变成加操作
                T.Add(x,n,del); a[x]=y; 
            }
            if (o==2)
            {
                int x=I(),y=I();
                T.Changeb(x,y); b[x]=y; 
            }
            if (o==3)
            {
                int x=I();
                printf("%lld\n",T.Query(1,x,k)%mod);
            }
        }
    }
    void IsMyWife()
    {
        Input();
        Soviet();
    }
}
#undef int //long long
int main()
{
    Flandre_Scarlet::IsMyWife();
    getchar();
    return 0;
}
```

---


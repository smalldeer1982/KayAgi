# 「Wdsr-1」人间之里

## 题目背景

- 这里是幻想乡中最多人类居住的地方。因为有许多妖怪也会光临的店，所以会有各种妖怪到访，不过都是些安份的妖怪，这是一个和平的地方（×1稗田家所在地，毫无疑问也在人类村落。

- 人类必要的生活用品，都能在这里买到。也有一些专门退治妖怪的人住在这，所以这里的生活是较安全的。

- 要说人类村落为什么没有被袭击，那就是妖怪的贤者在背后保护（×2幻想乡的人类灭绝的话，妖怪们也不好过。）。不外出的话，就不会遇上大难。

- 若外出途中遇到比自己强的妖怪（×3高概率的对方比自己强。），就恭恭敬敬地打招呼吧。 还有令人意外的是，有很多店会开到深夜，夜晚会变成妖怪专用店。妖怪多在夜晚活动，店也在那段时间兴旺。可以说妖怪才是很好的客人。

- 特别是卖酒的店，妖怪和人类同乐已成了日常一景。

$$\tag*{——摘自《东方求闻史纪》}$$

## 题目描述

虽然人间之里可以说是全幻想乡对于人类最安全的地方，但是异变发生时，还是可能会出现意外，所以要建立避难所。

人间之里可以抽象为一条坐标轴，其上有 $n$ 个点上建有房屋。这些房屋的坐标分别为 $x_1,x_2,...,x_n$，且在第 $i$ 座房屋中居住着 $v_i$ 位居民。

每次发生异变时，会有一段**坐标连续**的房屋受到影响，而此时便需要在某一坐标处建立避难所。一个避难所的"不便程度"为受影响的房屋中的**每一个居民**与避难所的距离之和。  

（举例来说，假设只有房屋 $i$ 受到了影响，则在 $z$ 处建立避难所的"不便程度"为 $v_i*|x_i-z|$ ） 

当然，坐落在幻想乡中人间之里的不可能一成不变，所以房屋的位置和居民的数量都可能会发生变化。

具体来说，你需要处理 $m$ 次询问或修改，每一次输入的格式如下：

- `1 l r`，表示询问 当**坐标**位于 $[l,r]$ 范围内的房屋受到异变影响时，在所有建立避难所的方案中，最小的"不便程度"是多少。

- `2 a b c`，表示将第 $a$ 座房屋的坐标修改为 $b$，其中居住的村民的数量变为 $c$ 。 

**注意：**
- 在 $1$ 操作中的"受到异变影响"均为假设，所以对之后的查询不产生作用。

- 在 $2$ 操作中发生变化的是第 $a$ 座房屋而不是坐标为 $a$ 的房屋。



## 说明/提示

**【样例解释】**

对于第一个询问，共有两座房屋受到影响，一处位于 $x=4$ 处，有 $3$ 位村民，一处位于 $x=7$ 处，有 $6$ 位村民。

避难所选在 $x=7$ 处时，"不便程度"为：

$$\left\vert 7 - 4 \right\vert \times 3 + \left\vert 7 - 7 \right\vert \times 6 = 9$$

可以证明 $9$ 是所有建立避难所的方案中"不便程度"的最小值。

--------------------

**【数据范围】**

- 对于 $100\%$ 的数据：
    
    $1 \le n,m \le 3 \times 10 ^ 5$。

    $1 \le a \le n$，$-10 ^ 9 \le l \le r  \le 10 ^ 9 \le n$，$-10 ^ 9 \le x_i,b \le 10 ^ 9$，$0 \le  v_i,c \le 10 ^ 3$。

- **详细的数据范围：**

    设 $mx$ 为所有输入的整数绝对值的最大值。

    测试点编号 | $n,m \le$  | $mx \le$ | 分值
    :-: | :-: | :-: | :-:
    $1$ | $100$ | $100$ | $10$
    $2$ | $8 \times 10 ^ 3$ | $8 \times 10 ^ 3$ | $15$
    $3$ | $8 \times 10 ^ 3$ | $10 ^ 9$ | $5$
    $4$ | $10 ^ 5$ | $10 ^ 5$ | $30$
    $5$ | $10 ^ 5$ | $10 ^ 9$ | $10$
    $6$ | $3 \times 10 ^ 5$ | $10 ^ 9$ | $30$


## 样例 #1

### 输入

```
10 10
-2 -3 -7 2 -6 7 -3 -5 4 -7 
0 2 2 0 4 6 2 4 3 3 
1 4 7
1 -5 7
1 -1 8
2 8 9 2
2 7 -3 5
2 7 4 3
2 2 -1 7
1 -9 -7
2 2 3 1
1 -1 0
```

### 输出

```
9
82
9
0
0```

# 题解

## 作者：Jsxts_ (赞：8)

树状数组写法，两只 $\log$ 跑到最优解。

这是一个类似[货仓选址](https://www.cnblogs.com/qbning/articles/15399332.html)的问题，对于每个询问，我们求出整个区间一共住着多少人 $s$，然后二分或倍增找到第 $\lfloor \frac{s}{2}\rfloor$ 个人住哪间房，选那个房子建避难所，注意要先离散化坐标。

那么怎么统计答案呢？

设避难所的位置为 $z$，则在 $z$ 前面的房屋的贡献是 $v_i\times(z-x_i)$，同理在 $z$ 后面的房屋的贡献是 $v_i\times(x_i-z)$。把括号展开得到总贡献为

$$\left(\sum_l^{z-1}v_i-\sum_{z+1}^rv_i\right)\times z+\left(-\sum_l^{z-1}v_ix_i+\sum_{z+1}^rv_ix_i\right)$$

所以我们只需要维护区间 $v_i$ 和 $v_i\times x_i$ 的和，单点修改，开两个树状数组即可。

代码很短，只有 60 多行。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int read() {
	int s = 0,f = 1;
	char ch = getchar();
	while (!isdigit(ch)) f = ch == '-' ? -1 : 1, ch = getchar();
	while (isdigit(ch)) s = s * 10 + ch - '0', ch = getchar();
	return s * f;
}
ll c[900010],c2[900010];//维护vi,vixi的和 
int x[300010],v[300010],h[1200010],n,m,tot;
void upd(int x,int s,int ss) {
	for (;x <= tot;x += (x & -x)) c[x] += s, c2[x] += 1ll * s * ss;
}
ll getsum(int x) {
	ll res = 0;
	for (;x;x -= (x & -x)) res += c[x];
	return res;
}
ll getsum2(int x) {
	ll res = 0;
	for (;x;x -= (x & -x)) res += c2[x];
	return res;
}
struct ask {
	int op,l,r,x;
}q[300010];
int main() {
	n = read(), m = read();
	for (int i = 1;i <= n;i ++ ) x[i] = read(), h[++tot] = x[i];
	for (int i = 1;i <= n;i ++ ) v[i] = read();
	for (int i = 1;i <= m;i ++ ) {//离线离散化 
		q[i].op = read(), q[i].l = read(), q[i].r = read();
		if (q[i].op == 2) q[i].x = read(), h[++tot] = q[i].r;
		else h[++tot] = q[i].l, h[++tot] = q[i].r;
	}
	sort(h+1,h+tot+1);
	tot = unique(h+1,h+tot+1)-h-1;
	for (int i = 1;i <= n;i ++ ) {
		x[i] = lower_bound(h+1,h+tot+1,x[i]) - h;
		upd(x[i],v[i],h[x[i]]);
	}
	for (int i = 1;i <= m;i ++ ) {
		if (q[i].op == 2) {
			q[i].r = lower_bound(h+1,h+tot+1,q[i].r) - h;
			int t = q[i].l;
			upd(x[t],-v[t],h[x[t]]);//直接单点修改 
			x[t] = q[i].r, v[t] = q[i].x;
			upd(x[t],v[t],h[x[t]]);
		}
		else {
			q[i].r = lower_bound(h+1,h+tot+1,q[i].r) - h;//离散 
			q[i].l = lower_bound(h+1,h+tot+1,q[i].l) - h;
			ll t = getsum(q[i].l-1),s = getsum(q[i].r) - t >> 1;
			int l = q[i].l - 1;
			for (int j = 1 << 19;j;j >>= 1)//倍增找到第s/2个人住的房子 
				l += (l + j <= q[i].r && getsum(l + j) - t <= s) * j;
			l ++;
			printf("%lld\n",(getsum(l) - t) * h[l] - getsum2(l) + getsum2(q[i].l-1) - (getsum(q[i].r) - getsum(l)) * h[l] + getsum2(q[i].r) - getsum2(l));
			//直接套式子
		}
	}
	return 0;
}
```

线段树二分好像是一个 $\log$，但我懒得写（

---

## 作者：AFewSuns (赞：3)

好像除了std没有其他线段树的题解，在此补一篇有代码的。

此篇题解打的是 $O(m\log^2n)$ 的，但是无卡常跑过去了……应该比一个 log 的好想一点。

### 题目大意

有 $n$ 个房子，每个房子在一个坐标位置 $pos_i$ 上，这个房子有 $v_i$ 个人。

每次操作，要么修改一个房子的位置和人数，要么询问一个区间 $[l,r]$ ，求选一点 $p$，使得位置在 $[l,r]$ 里面的屋子 $i$，$\sum{v_i \times |p-pos_i|}$ 最小。

### 题目分析

此题的主要瓶颈在于如何找 $p$。

**注意！以下的 $i$ 都是位置，不是房子编号！**

**为了方便表示，我们用类似的定义，定义 $v_i$ 为所有在 $i$ 位置上的人数和，$pos_i$ 为真正意义上的位置（因为要离散化）**

令 $sum=\displaystyle\sum_{i=l}^{r}{v_i}$，$suml=\displaystyle\sum_{i=l}^{p}{v_i}$，$sumr=\displaystyle\sum_{i=p+1}^{r}{v_i}$，

下面证明：我们要找的 $p$ 一定要使 $suml$ 与 $sumr$ 尽可能接近 $\frac{sum}{2}$。

假设我们目前找到的 $p$ 满足 $suml > sumr$（反之同理）.

那么将 $p$ 变到 $p+1$ 时，$p$ 左边（包括 $p$）的 $i$ 到现在的 $p+1$ 的距离，都加了 $1$，然后 $p$ 右边的都减了 $1$，若原先答案为 $ans$，那么新的答案就是 $ans+suml-sumr$，类似于换根 DP 的思想。

因为 $suml > sumr$，所以现在的 $ans$ 反而变大了，变得不优了。反过来，如果将 $k$ 变为 $k-1$，那么还有可能更优。所以为了得到更优的答案，会选择让 $k$ 减一。

这样不断操作的情况下，我们会发现 $suml$ 与 $sumr$ 都在不断接近 $\frac{sum}{2}$，最好情况就是 $suml=sumr$。

以上证毕。

这样的 $p$ 我们可以二分找，然后区间和用线段树维护。

找到了 $p$ 之后，剩下的事情就好办了。

回到式子：$\displaystyle\sum_{i=l}^{r}{v_i \times |p-pos_i|}$

拆开绝对值：

$$\displaystyle\sum_{i=l}^{r}{v_i \times |p-pos_i|}$$

$$=\displaystyle\sum_{i=l}^{p-1}{v_i \times (p-pos_i)}+\displaystyle\sum_{i=p+1}^{r}{v_i \times (pos_i-p)}$$

$$=\displaystyle\sum_{i=l}^{p-1}{(v_i \times p - v_i \times pos_i)}+\displaystyle\sum_{i=p+1}^{r}{(v_i \times pos_i - v_i \times p)}$$

$$=\displaystyle\sum_{i=l}^{p-1}{(v_i \times p)} - \displaystyle\sum_{i=l}^{p-1}{(v_i \times pos_i)} + \displaystyle\sum_{i=p+1}^{r}{(v_i \times pos_i)} - \displaystyle\sum_{i=p+1}^{r}{(v_i \times p)}$$

$$=p \times \displaystyle\sum_{i=l}^{p-1}{v_i} - \displaystyle\sum_{i=l}^{p-1}{(v_i \times pos_i)} + \displaystyle\sum_{i=p+1}^{r}{(v_i \times pos_i)} - p \times \displaystyle\sum_{i=p+1}^{r}{v_i}$$

然后发现只跟 $v_i$ 与 $pos_i$ 有关，用线段树维护 $\sum{v_i}$ 和 $\sum{v_i \times pos_i}$ 就行了。

**再次注意，上述变量与题面不同！！！为了方便表示，我们定义 $v_i$ 为所有在 $i$ 位置上的人数和，$pos_i$ 为真正意义上的位置（因为要离散化）**

然后是一些细节：

- 注意边界问题
- 二分出来的可能不是最优的 $p$（因为是二分，手动模拟一下就知道了，不同的判断标准求出来的可能不一样），但一定在附近。所以再求一下 $p-1$ 和 $p+1$ 的答案就行了
- $p$ 肯定要取有人的位置上，然而二分出来的位置不一定有人（包括边界），所以需要两个函数 $pre$ 和 $nxt$，找到前面的第一个**有人**的位置上，和后面的第一个**有人**的位置。这个直接二分实现
- 注意要离散化（当然可以动态开点）

时间复杂度二分一个 log，线段树一个 log，总体 $O(m\log^2n)$

代码有点丑，凑合着看吧。

可以借助代码理解。

### 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define fr(i,x,y) for(register ll i=(x);i<=(y);i++)
#define inf 8e18
#define LC x<<1
#define RC x<<1|1
using namespace std;
ll n,m,lsh[600060],cnt=0,tree[3000030],sum[3000030],ans;
struct node{
	ll pos,v;
}a[300030];
struct Node{
	ll opt,l,r,v;
}q[300030];
void pushup(ll x){
	tree[x]=tree[LC]+tree[RC];
	sum[x]=sum[LC]+sum[RC];
}
void mdf(ll x,ll l,ll r,ll pos,ll v){//普通的线段树
	if(l==r){
		tree[x]+=v;
		sum[x]+=lsh[l]*v;
		return;
	}
	ll mid=(l+r)>>1;
	if(pos<=mid) mdf(LC,l,mid,pos,v);
	else mdf(RC,mid+1,r,pos,v);
	pushup(x);
}
ll query(ll x,ll l,ll r,ll ql,ll qr){//查询vi的和 
	if(ql>qr) return 0;
	if(ql<=l&&r<=qr) return tree[x];
	ll mid=(l+r)>>1,res=0;
	if(ql<=mid) res+=query(LC,l,mid,ql,qr);
	if(mid<qr) res+=query(RC,mid+1,r,ql,qr);
	return res;
}
ll querysum(ll x,ll l,ll r,ll ql,ll qr){//查询vi*posi的和 
	if(ql>qr) return 0;
	if(ql<=l&&r<=qr) return sum[x];
	ll mid=(l+r)>>1,res=0;
	if(ql<=mid) res+=querysum(LC,l,mid,ql,qr);
	if(mid<qr) res+=querysum(RC,mid+1,r,ql,qr);
	return res;
}
ll find_pre(ll k){//找到前面第一个有人的坐标 
	if(query(1,1,cnt,k,k)) return k;
	ll l=1,r=k;
	while(l<r){
		ll mid=(l+r)>>1;
		if(query(1,1,cnt,mid,k)) l=mid+1;
		else r=mid;
	}
	return l-1;
}
ll find_nxt(ll k){//找到后面第一个有人的坐标 
	if(query(1,1,cnt,k,k)) return k;
	ll l=k,r=cnt;
	while(l<r){
		ll mid=(l+r)>>1;
		if(l==mid) mid++;
		if(query(1,1,cnt,k,mid)) r=mid-1;
		else l=mid;
	}
	return l+1;
}
void solve(ll l,ll r,ll p){//求出答案，式子在上面有详细介绍 
	ll res=0;
	res+=lsh[p]*query(1,1,cnt,l,p-1);
	res-=querysum(1,1,cnt,l,p-1);
	res+=querysum(1,1,cnt,p+1,r);
	res-=lsh[p]*query(1,1,cnt,p+1,r);
	ans=min(ans,res);
}
int main(){
	scanf("%lld %lld",&n,&m);
	fr(i,1,n){
		scanf("%lld",&a[i].pos);
		lsh[++cnt]=a[i].pos;
	}
	fr(i,1,n) scanf("%lld",&a[i].v);
	fr(i,1,m){//离线处理，离散化坐标 
		scanf("%lld %lld %lld",&q[i].opt,&q[i].l,&q[i].r);
		if(q[i].opt==2){
			lsh[++cnt]=q[i].r;
			scanf("%lld",&q[i].v);
		}
	}
	lsh[++cnt]=-inf;
	lsh[++cnt]=inf;//不重要的边界问题
	sort(lsh+1,lsh+cnt+1);
	cnt=unique(lsh+1,lsh+cnt+1)-lsh-1;
	fr(i,1,n) a[i].pos=lower_bound(lsh+1,lsh+cnt+1,a[i].pos)-lsh;
	fr(i,1,n) mdf(1,1,cnt,a[i].pos,a[i].v);//建线段树 
	mdf(1,1,cnt,1,1);
	mdf(1,1,cnt,cnt,1);//不重要的边界问题 
	fr(i,1,m){
		if(q[i].opt==1){
			ll ql=lower_bound(lsh+1,lsh+cnt+1,q[i].l)-lsh,qr=upper_bound(lsh+1,lsh+cnt+1,q[i].r)-lsh-1;
			ql=find_nxt(ql);
			qr=find_pre(qr);//将范围缩小到找到有人的位置 
			if(ql>qr){//如果没人，直接输出0 
				printf("0\n");
				continue;
			}
			ll l=ql,r=qr,p1,p2,p3,tmp=query(1,1,cnt,ql,qr);
			while(l<r){
				ll mid=(l+r)>>1;
				if(l==mid) mid++;
				if(query(1,1,cnt,ql,mid)<=(tmp+1)/2) l=mid;
				else r=mid-1;
			}
			p1=find_pre(l);//有可能二分到没人的位置，所以往前找
			p2=l+1;//p的后一个
			p3=p1-1;//p的前一个
			if(p2>qr) p2--;
			if(p3<ql) p3++;//防止越界
			ans=inf;
			solve(ql,qr,p1);
			solve(ql,qr,p2);
			solve(ql,qr,p3);//依次求出答案取最大值
			printf("%lld\n",ans);
		}
		else{
			ll u=q[i].l;
			mdf(1,1,cnt,a[u].pos,-a[u].v);
			a[u].pos=lower_bound(lsh+1,lsh+cnt+1,q[i].r)-lsh;
			a[u].v=q[i].v;
			mdf(1,1,cnt,a[u].pos,a[u].v);//直接修改
		}
	}
}
```

---

## 作者：chenxinyang2006 (赞：2)

- 测试点1

   这个很简单吧，就是枚举每个可能的避难所位置，然后去暴力计算代价，求最小值。
   
   避难所显然要放在区间内，放在区间外肯定是不优的。
   
   实际上也要放在整数点上，这个可能比较难以证明，不过稍微猜测一下应该还是可以知道的。
   
- 测试点2

	容易发现，这题要求的是一个序列上的的**区间**带权重心，单点修改

   那么求树的重心显然是有一个换根dp的做法，可以参考P1364的题解
   
   去枚举每个可能的重心位置，然后 $O(1)$ 转移到下一个就可以了
   
- 测试点3

   实际上，重心肯定是在有居民的点上，这样可以加快枚举的效率
   
- 测试点4

  你需要知道一个结论，当然，自己推导也可以：
  
  **删去树上带权重心后分裂出的子树权重小于总权重的一半**
   
   搬到本题的区间上，就是找一个区间上的点，使得它左边、右边的权重都小于总权重的一半
   
   这个可以用线段树维护 坐标 - 权值 这个信息，外面套个二分，里面区间求和判定
   
   这样就确定了重心点，设其为 $y$
    
   然后考虑一下怎么求贡献
   
   在重心右边的点 $i$，它的贡献是 $(x_i - y) \times v_i$
   
   这个可以考虑拆开计算，维护 $x_i \times v_i$ 之和以及 $x_i$ 之和
   
   那么贡献就是 $(\sum\limits_{i = y + 1} ^ r x_i \times v_i) - y \times (\sum\limits_{i = y + 1} ^ r v_i)$
   
   左边的点也是同理，它的贡献是 $(y - x_i) \times v_i$
   
   也就是 $y \times (\sum\limits_{i = l} ^ {y - 1} v_i) - (\sum\limits_{i = l} ^ {y - 1} x_i \times v_i)$
   
   修改就是一个单点修改
   
- 测试点5

   坐标的范围大了很多，需要用上动态开点线段树
   
   当然，离线然后离散化应该也可以，我懒得卡了
   
- 测试点6

  刚才的那个做法是两个 log 的，就会在这个数据范围下死掉
  
  然后我们来看一下条件是什么：
  
  设 $sum_{x,y}$ 表示 $x$ 点到 $y$ 点的权值之和。
  
  - 找到一个点 $y$，使得 $sum_{l,y - 1} \le \frac{sum_{l,r}}{2}$，且 $sum_{y + 1,r} \le \frac{sum_{l,r}}{2}$
  
  稍加思索，我们就可以知道 $sum_{l,y - 1}$ 一定是最大的和小于 $\frac{sum_{l,r}}{2}$，且左端点为 $l$ 的区间
  
  那么这个就可以用线段树内二分来做了
  
  这样复杂度就降到了一个 $\log$
  
- 关于出这题

  这道题是我在做了[幻想乡战略游戏](https://www.luogu.com.cn/problem/P3345)，了解到换根dp这个做法以后想出的idea
  
  一开始想的是能不能做到树上查询每个子树的重心，感觉不太可做（也可能是我太菜了）
  
  然后搬到了序列上，发现知道那个结论就可以轻松解决了
  
  这题实际上也就是一个权值线段树的套路题，可能考了一些线段树的常用操作吧（上次P6215也是这样的23333）
  
  下次肯定不会出线段树的题了，我保证 Wdoi 我的题不是线段树
  
  这题在比赛中也算是AC率相当高的题了，果然不该放在T4的，也许该改到T2？
  
  比赛中看到有人离散化后用两个log的做法跑过去了，我也懒得卡了。而且大多数人都用的线段树？我也不知道为什么。验题人30min就用平衡树AC了这题，应该也不难写

---

## 作者：Running_a_way (赞：1)

[cnblogs](https://www.cnblogs.com/Running-a-way/p/18455220)

很经典但是很好的题目。/qiang

标签：线段树。

> - 数轴上有一些关键点，**不同的关键点可能在同一坐标**。关键点的坐标均为整数。
> - 支持两种操作：
>   1. 删去 / 添加一些关键点。
>   2. 取一个点。使得它与 $[l, r]$ 范围内所有关键点的距离最小。求最小距离。
> -  $\text{关键点的坐标数}\le 3\times 10^5$，$\text{所有坐标的绝对值}\le 10^9$。
 
首先每个坐标上有多少个关键点是很好维护的。如果已经取了个点，如何计算答案？一个经典做法是把绝对值拆开。假设取的点坐标是 $x$，左边有 $a$ 个关键点，它们的坐标和为 $S_a$；右边有 $b$ 个关键点，坐标和为 $S_b$。则答案为 $(ax-S_a) + (S_b - bx)$。用线段树维护 *区间内关键点的个数* 与 *坐标和* 即可。

问题来到了如何找点 $x$。有一种比较感性的思考方式：随便取一个 $x$，我们将 $x$ 向左移 $\Delta x$ 且不越过关键点，那么距离增加了 $b\Delta x - a\Delta x = (b - a)\Delta x$。如果 $a > b$ 即左边的点较多时，$(b - a)\Delta x < 0$，则距离减少了。也就是说，当左边的点多时，向左移是优的；同理当右边的点较多时，向右移是优的。那么最终 $x$ 会停在区间内坐标从小到大第 $\frac{\text{点的个数}}{2}$ 个点的位置。求这个坐标可以线段树上二分。

用权值线段树维护即可。时间复杂度 $O(n\log n)$。我写的是动态开点线段树，获得了线段树写法的最优解。code: 

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

typedef long long ll;
const int N = 300010, eps = 1e9, V = 1e9;
int cnt, ro;
struct Seg {
    int ls, rs;
    ll c, v;
} T[N * 4 * 32];
int n, m; ll a[N], b[N];
#define ls(k) (T[k].ls)
#define rs(k) (T[k].rs)

inline int read() {
	int x = 0, f = 1;
	char c = getchar();
	while (!isdigit(c)) {if (c == '-') f = -1; c = getchar();}
	while (isdigit(c)) x = x * 10 + c - 48, c = getchar();
	return x * f;
}
inline void write(ll x) {
	if (x > 9) write(x / 10);
	putchar(x % 10 + 48);
}

void pushup(int k) {
    T[k].c = T[ls(k)].c + T[rs(k)].c;
    T[k].v = T[ls(k)].v + T[rs(k)].v;
}
void update(ll l, ll r, int &k, ll x, ll c) {
    if(!k) k = ++cnt;
    if(l == r) {
        T[k].c += c;
        T[k].v = x * T[k].c;
        return;
    }
    ll mid = (l + r) / 2;
    if(x <= mid) update(l, mid, ls(k), x, c);
    else update(mid + 1, r, rs(k), x, c);
    pushup(k);
}
ll getc(ll l, ll r, int k, ll L, ll R) {
    if(!k) return 0;
    if(L <= l && r <= R) return T[k].c;
    ll mid = (l + r) / 2, res = 0;
    if(L <= mid) res += getc(l, mid, ls(k), L, R);
    if(mid < R) res += getc(mid + 1, r, rs(k), L, R);
    return res;
}
ll getv(ll l, ll r, int k, ll L, ll R) {
    if(!k) return 0;
    if(L <= l && r <= R) return T[k].v;
    ll mid = (l + r) / 2, res = 0;
    if(L <= mid) res += getv(l, mid, ls(k), L, R);
    if(mid < R) res += getv(mid + 1, r, rs(k), L, R);
    return res;
}
ll find(ll l, ll r, int k, ll c) {
    if(l == r) return l;
    int mid = (l + r) / 2;
    if(c <= T[ls(k)].c) return find(l, mid, ls(k), c);
    else return find(mid + 1, r, rs(k), c - T[ls(k)].c);
}

int main() {
    // ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    n = read(), m = read();
    for (int i = 1; i <= n; i++) a[i] = read() + eps;
    for (int i = 1; i <= n; i++) {
        b[i] = read();
        update(0, 2e9, ro, a[i], b[i]);
    }
    while(m--) {
        int op = read();
        if(op == 2) {
            ll x = read(), y = read() + eps, z = read();
            update(0, 2e9, ro, a[x], -b[x]);
            a[x] = y, b[x] = z;
            update(0, 2e9, ro, a[x], b[x]);
        } else {
            ll l = read() + eps, r = read() + eps;
            ll mid = getc(0, 2e9, ro, 0, l - 1) + (getc(0, 2e9, ro, l, r) + 1) / 2;
            mid = find(0, 2e9, ro, mid);
            write(mid * getc(0, 2e9, ro, l, mid - 1) - getv(0, 2e9, ro, l, mid - 1) + getv(0, 2e9, ro, mid + 1, r) - mid * getc(0, 2e9, ro, mid + 1, r));
            puts("");
        }
    }
    return 0;
}
```

如有错误烦请您指出。

---

## 作者：wizardMarshall (赞：0)

## 思路

对每个操作 1（询问），假设我们已经找到了位置 $p$ 使得贡献最小，则总和式子 $\displaystyle \sum ^{r}_{i=l} v_i|i-p|$ 可以拆成 $i < p$ 与 $i>p$ 两部分（$i=p$ 的重叠了，没有贡献）：

$$\displaystyle \sum ^{p-1}_{i=l} v_i(p-x_i) + \sum ^{r}_{i=p + 1} v_i(x_i-p)$$

$$=\displaystyle p\sum ^{p-1}_{i=l} v_i-\sum ^{p-1}_{i=l} v_ix_i + \sum ^{r}_{i=p + 1} x_iv_i-p\sum ^{r}_{i=p + 1} v_i$$

这个式子就转换为了 $v_ix_i$ 和 $v_i$ 的区间和，可以直接用线段树维护。问题就在于 $p$ 的查找。

一个经典的结论就是 $p$ 取所有点从大到小排的中位数。证明可以看[这篇题解](https://www.luogu.com.cn/article/kytrq2zq)，这里不再赘述。

操作 2 就是单点修改。

由于坐标范围达到了 $10^9$ 级别，可以采用动态开点线段树或者先离散化。代码中采用的是第一种方法。

## 代码

最好用线段树上二分，复杂度 $O(n \log n)$。不然两只 $\log$ 不好卡。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 300005;
ll x[N];
ll v[N];
struct node{
	int ls, rs;
	ll sum1, sum2;
}tree[N << 5];
int E;
void change(int &x, ll l, ll r, ll id, ll v) {
	if (!x) {
		x = ++E;
		tree[x].ls = 0;tree[x].rs = 0;
		tree[x].sum1 = tree[x].sum2 = 0;
	}
	if (l == r) {
		tree[x].sum1 += v;
		tree[x].sum2 = 1ll * id * tree[x].sum1;
		return;
	}
	ll m = (l + r) / 2;
	if (id <= m) {
		change(tree[x].ls, l, m, id, v);
	}else {
		change(tree[x].rs, m + 1, r, id, v);
	}
	tree[x].sum1 = tree[tree[x].ls].sum1 + tree[tree[x].rs].sum1;
	tree[x].sum2 = tree[tree[x].ls].sum2 + tree[tree[x].rs].sum2;
	return;
}

pair <ll, ll> operator +(pair <ll, ll> a, pair <ll, ll> b) {
	return make_pair(a.first + b.first, a.second + b.second);
}
pair <ll, ll> ask(int x, ll l, ll r, ll L, ll R) {
	if (!x)return make_pair(0ll, 00ll);
	if (L <= l && r <= R) {
		return make_pair(tree[x].sum1, tree[x].sum2);
	}
	ll m = (l + r) / 2;
	pair <ll, ll> res = make_pair(0ll, 0ll);
	if (L <= m) {
		res = res + ask(tree[x].ls, l, m, L, R);
	}
	if (R > m) {
		res = res + ask(tree[x].rs, m + 1, r, L, R);
	}
	return res;
}
ll find(int x, ll l, ll r, ll k) {
	if (l == r) {
		return l;
	}int m = (l + r) / 2;
	if (tree[x].ls && tree[tree[x].ls].sum1 >= k) {
		return find(tree[x].ls, l, m, k);
	}
	return find(tree[x].rs, m + 1, r, k - tree[tree[x].ls].sum1);
}
signed main() {
	int n, q;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		scanf("%lld", &x[i]);
		x[i] += 1e9;
	}
	int m = 2e9;
	int head = 0;
	for (int i = 1; i <= n; i++) {
		scanf("%lld", &v[i]);
		change(head, 0, m, x[i], v[i]);
	}
	while (q--) {
		int op;
		scanf("%d", &op);
		if (op == 1) {
			ll l, r;
			scanf("%lld%lld", &l, &r);
			l += 1e9;r += 1e9;
			ll p = ask(head, 1, m, 0, l - 1).first + (ask(head, 1, m, l, r).first + 1) / 2;
			p = find(head, 1, m, p);
			pair <ll, ll> itl = make_pair(0ll, 0ll), itr = make_pair(0ll, 0ll);
			if (p != l) {
				itl = ask(head, 0, m, l, p - 1);
			}
			if (p != r) {
				itr = ask(head, 0, m, p + 1, r);
			}
			printf("%lld\n", p * itl.first - itl.second + itr.second - p * itr.first);
		}else {
			int a;
			ll b, c;
			scanf("%d%lld%lld", &a, &b, &c);
			b += 1e9;
			change(head, 0, m, x[a], -v[a]);
			x[a] = b;v[a] = c;
			change(head, 0, m, x[a], v[a]);
		}
	}
	return 0; 
}
```

---


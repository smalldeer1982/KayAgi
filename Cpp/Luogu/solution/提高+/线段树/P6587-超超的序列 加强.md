# 超超的序列 加强

## 题目背景

孙1超总是喜欢疯言疯语，有一天，他随口说出了一串序列，又想对某几个特定位置的值进行修改和求和。由于孙1超十分菜，所以他来找你帮助。

## 请不要抄题解。

## 题目描述

给定序列 $a$，并且给出两种操作：
- `1 x y v`：将所有 $a_i$ 的值加上 $v$，其中 $i\equiv y\pmod {2^x}$。
- `2 x y`：询问所有 $a_i$ 的和，其中 $i\equiv y\pmod {2^ x}$。

**本题强制在线。**




## 说明/提示

#### 样例解释
对于样例 1：

- 第一个操作 $op=2$，需要计算贡献的 $i$ 为 $1,5$，答案为 $7$。
- 第二个操作 $op=1$， 需要加上 $3$ 的 $i$ 为 $1,3,5$，将 $a_1,a_3,a_5$ 加上 $3$。
- 第三个操作 $op=2$， 需要计算贡献的 $i$ 为 $1,2,3,4,5$，答案为 $25$。

#### 数据范围
- 对于 $10\%$ 的数据，$1\le n,m \leq 10^3$。
- 对于 $70\%$ 的数据，每一个操作后面有一个换行。 
- 对于 $100\%$ 的数据，$1\le n,m \leq 2\times10^5$，$0 \leq a_i,y,v,op'<10^7$。
- 对于操作 1 和 2，$0\leq x \leq 20$ 且 $0 \le y < 2^x$。


## 样例 #1

### 输入

```
5 3
1 2 3 4 6
1 2 1
1 1 1 3
2 0 0```

### 输出

```
7
25```

# 题解

## 作者：一扶苏一 (赞：21)

## 【0/1 Trie】【P6587】 超超的序列

### Analysis

把下标看作一堆二进制串，建立一颗 01 Trie，在叶结点处维护以当前二进制串（以根节点到孩子的边为最低位，连接叶节点的边为最高位）的为下标的序列值，非叶节点维护子树和。不难发现对于一个在第 $m$ 层（根为第 $0$ 层），代表 $x$ 的节点，其信息就是所有对 $2^m$ 取模后值为 $x$ 的下标对应的序列值之和。查询时直接查询子树和，修改时在 Trie 上打标记即可。

啥，你说这和官方题解的 std 没啥区别？因为 01 Trie 和线段树本质上是相同的，显而易见这里把这个结构描述成 01 Trie 更加的自然。

### Code

```cpp
namespace Fusu {

const int maxn = 2100005;

int n, m;
int a[maxn];

struct Node {
  int sz;
  ll sum, tag;
  Node *trans[2];

  inline void maketag(const ll x) {
    sum += sz * x;
    tag += x;
  }
  inline void pushup() {
    sum = 0;
    for (auto u : trans) if (u) {
      sum += u->sum;
    }
  }
  inline void pushdown() {
    if (tag) {
      for (auto u : trans) if (u) u->maketag(tag);
      tag = 0;
    }
  }
};
Node Mem[maxn << 1], *pool = Mem;
Node *New(const int p, const int d) {
  int t = 1 << d;
  auto x = pool++;
  if (d == 21) {
    if (p <= n) {
      x->sum = a[p];
      if (p != 0) x->sz = 1;
    }
    return x;
  }
  x->trans[0] = New(p, d + 1);
  x->trans[1] = New(p | t, d + 1);
  x->pushup();
  x->sz = x->trans[0]->sz + x->trans[1]->sz;
  return x;
}

Node *stk[maxn];
int top = 0;
void Main() {
  qr(n); qr(m);
  qra(a + 1, n);
  auto rot = New(0, 0);
  for (ll op, x, y, z, ans = 0; m; --m) {
    qr(op);
    op = (op + ans) % 2 + 1;
    qr(x); qr(y);
    y &= (1 << x) - 1;
    if (op == 1) {
      qr(z);
      auto u = rot;
      for (int i = 0, t = 1 << i; i < x; t = 1 << ++i) {
        stk[++top] = u;
        int k = (y & t) ? 1 : 0;
        u->pushdown();
        u = u->trans[k];
      }
      u->maketag(z);
      while (top) stk[top--]->pushup();
    } else {
      auto u = rot;
      for (int i = 0, t = 1 << i; i < x; t = 1 << ++i) {
        int k = (y & t) ? 1 : 0;
        u->pushdown();
        u = u->trans[k];
      }
      qw(ans = u->sum, '\n');
    }
  }
}

} // namespace Fusu
```



---

## 作者：柳易辰 (赞：14)

## Part 1 前置知识
[P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)

[P2580 于是他错误的点名开始了](https://www.luogu.com.cn/problem/P2580)

不会的请学习 [LazyTag](https://oi-wiki.org//ds/seg/) 和 [01-Trie](https://oi-wiki.org/string/trie/)。这题用的数据结构既不是线段树也不是 01-Trie，而是一种比较综合的二叉树。

&nbsp;
## Part 2 题意转化
我们记 $\text{bin}(x)$ 为 $x$ 的二进制表示，则 $\text{bin}(1)=1,\ \text{bin}(10)=1010$。

但是这题求的操作集合是**二进制后缀**为某个 01 串的数的集合，所以我们记 $\text{rbin}(x)$ 为 $\text{bin}(x)$ 翻转 (Reverse Binary) 后的结果。则 $\text{rbin}(1)=1,\ \text{rbin}(10)=0101$。

**注意，此处不能省略前导 0。**

这时，操作集合转换为一个**公共前缀集合**。

举个例子，题目中的 $n=5,\ x=2,\ y=1$。

设 $z$ 是要操作的数，则 $z$ 满足的二进制末 $x$ 位为 $\text{bin}(y)$（不足补 0）。

前面写的一些东西在这里可以简化问题，即 $\text{rbin}(y)$ 是 $\text{rbin}(z)$ 的前缀，那么此题就简单了许多。

手动模拟可以得知，这个操作的数的下标集合为 $\set{1,5}$。

但是 $\text{rbin}(1)=1,\ \text{rbin}(y)=10$，10 不是 1 的前缀，但 1 仍然需要操作，这是因为 $\text{rbin}(z)$ 在后面补足足够的 0 之后，若 $\text{rbin}(y)$ 为 $\text{rbin}(z)$ 的前缀，那么 $z$ 也需要修改。这很显然，不用证明吧~

于是，我们在预处理时将 $\text{rbin}(x)$ 的长度补足为 $\log n$ 位（此处为 $20$），这样就可以不分情况的解决一个简单的前缀问题。

现在此题就是：有一些键为长度均为 $20$ 的 01 串的键值对，每次操作：

选定一些键的前缀为 $x$（此处 $x$ 也是长度为 $20$ 的 01 串）的键值对，将其值增加一个值或者查询值的和。

&nbsp;
## Part 3 样例模拟
有 5 个键值对：(为了便于理解，长度补足为 3 位)

$[100,1],[010,2],[110,3],[001,4],[101,6]$

输入 `2 2 1` (暂无离线)：

即查询键的前缀为 $[10]$ 的键值对的和，即 1 + 6 ，于是输出 `7`。

输入 `1 1 1 3`：

即修改键的前缀为 $[1]$ 的键值对的值，于是现在 5 个键值对为：

$[100,4],[010,2],[110,6],[001,4],[101,9]$

输入 `2 0 0`：

即查询**所有**键值对的和，输出 `25`。

画成二叉树是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/mpwznnuy.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/9igxeajl.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/8rk41k5z.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/r46q2h2x.png)

&nbsp;
## Part 4 复杂度
我们发现一个美妙的性质：

每次查询必定查的是一个节点上的值，一次修改也一定修改的是一个节点的祖先和它的所有孩子的值，这是接近于 01-Trie 的一点。

但是如果我们每次修改都修改到叶子节点，单此修改可能会被卡到 $O(n\log n)$，于是我们用线段树的 LazyTag 懒惰标记思想来优化。

时空复杂度均为 $O(n\log n)$。

&nbsp;
## Part 5 代码
```cpp
#include <cstdio>
#include <vector>
using namespace std;
struct Trie
{
	int c[2], f;
	long long s, v, t;
	Trie() { c[0] = c[1] = s = v = f = t = 0; }
} E;
vector<Trie> T;
int n, m; 
long long opt, LastAnswer, x, z;
#define l T[p].c[0]
#define r T[p].c[1]
#define Next T[p].c[((1 << depth) & y) > 0]
void insert(const int p, const int depth)
{
	if (depth > 20) return; // logn < 20
	T[p].v += x; ++T[p].s;
	if (!Next) 
	{
		Next = T.size();
		T.push_back(E); T.back().f = p;
	}
	insert(Next, depth + 1); 
}
void add(const int p, const long long u) { T[p].v += u; if (p) add(T[p].f, u); }
void change(const int p, const int depth)
{
	if (depth == x) { add(p, T[p].s * z); T[p].t += z; return; }
	if (!Next) return;
	change(Next, depth + 1);
}
long long query(const int p, const int depth)
{
	if (depth == x) return T[p].v;
	if (!Next) return 0;
	if (T[p].t) 
	{
		if (l) T[l].t += T[p].t, T[l].v += T[p].t * T[l].s;
		if (r) T[r].t += T[p].t, T[r].v += T[p].t * T[r].s;
		T[p].t = 0;
	}
	return query(Next, depth + 1);
}
int main()
{
	scanf("%d%d", &n, &m); T.push_back(E); 
	for (int y(1); y <= n; ++y) scanf("%lld", &x), insert(0, 0);
	while (m--)
	{
		scanf("%lld%lld%d", &opt, &x, &y);
		opt = ((opt + LastAnswer) & 1) + 1;
		if (opt & 1) scanf("%lld", &z), change(0, 0);
		else printf("%lld\n", LastAnswer = query(0, 0));
	} 
	return 0;
}
```
一些注意点：

这一句宏 `#define Next T[p].c[((1 << depth) & y) > 0]` 一定要加上 `> 0`，因为 `(1 << depth) & y` 是我们取 $\text{rbin}(y, dep)$ 的位运算写法，很显然其值大于 0，我们认为：
$$\text{rbin}(y,\ dep)=
\begin{cases}
0&(2^{dep}\text{ and }y)=0\\
1&(2^{dep}\text{ and }y)>0
\end{cases}
$$
如果不加 `> 0`，可能会数组越界。

有些变量要开 `long long`，当然可以宏定义。

&nbsp;
## Part 6 经验总结
总结一下我们做这道题的过程：原题是一道**非连续集合**的查询修改问题，于是我们把问题转化为了**树上单点修改**（及其祖先和所有孩子）问题，这是最重要的一步。

由于区间是 01 分的，我们想到 01-Trie，并用 LazyTag 将每次操作时间复杂度降至 $O(\log n)$。希望大家可以深刻理解这道题的做法。

---

## 作者：素质玩家孙1超 (赞：12)

题意：

给定序列 $a$，并且给出两种操作：
- `1 x y v`：将所有 $a_i$ 的值加上 $v$，其中 $i\equiv y\pmod {2^x}$。
- `2 x y`：询问所有 $a_i$ 的和，其中 $i\equiv y\pmod {2^ x}$。

强制在线

---

暴力~~有脑子就行~~

```cpp
while(m--)
{
	op=(R()+pre)%2+1;p=R();k=R();
	if(op==1) 
	{
		int v=R();
		p=1<<p;
		if(k==0) k+=p;
		for(int i=k;i<=n;i+=p) a[i]+=v;
	}
	else 
	{
		int res=0;p=1<<p;
		for(int i=k;i<=n;i+=p) res+=a[i];
		printf("%lld\n",pre=res);
	}
}
```

可以搞到10分和对拍

 + ~~出题人的蠢~~标算
 
 拿到题目，首先手玩$x=0$时的情况:$y=1$表示所有奇数的和，$y=0$,表示所有偶数的和

以下为了方便，设$x=i,y=j$情况下的下标集合为$Range_{i,j}$


再接下去，考虑$Range_{1,0}=4,8,12,16,20……$

$Range_{1,1}=5,9,13,17,21……$

$Range_{1,2}=6,10,14,18,22……$

$Range_{1,3}=7,11,15,19,23……$

### 仔细观察

是不是容易发现$Range_{1,0}$和$Range_{1,2}$里面都是偶数，换句话说，他们都被$Range_{0,0}$包含，且
$Range_{1,0}+Range_{1,2}=Range_{0,0}$

相同地$Range_{1,1}+Range_{1,3}=Range_{0,1}$

所以我们想到了思路：把原来的区间按照下标奇偶分成两个子区间，这两个子区间也如此划分，查询的时候就查询某个子区间的和就够了。我们选择用线段树来维护这些个区间，依照原来的区间加法和修改操作就好了。

当然查询和修改的细节与普通的线段树不同，具体可以见代码

 _最后别忘开long long_ 

std代码~~略丑~~

```cpp
#include<bits/stdc++.h>
#define ls (root<<1) 
#define rs (root<<1|1)
#define mid (l+r>>1)
#define min(a,b) (a<b?a:b)
using namespace std;
const int Maxn=2e6+5;
inline int R()
{
	char c;int sign=1,res=0;
	while((c=getchar())>'9'||c<'0') if(c=='-') sign=-1;res+=c-'0';
	while((c=getchar())>='0'&&c<='9') res=res*10+c-'0';
	return res*sign;	
}
#define int long long 
int a[Maxn],n,m,sum[Maxn*4],N=1,NN=0,ADD[Maxn*4],size[Maxn*4];
void add(int root,int val)
{
	sum[root]+=size[root]*val;
	ADD[root]+=val;
}
void pushdown(int root)
{
	if(ADD[root])
	{
		add(ls,ADD[root]);
		add(rs,ADD[root]);
		ADD[root]=0;
	}
}
void build(int root,int deep,int sur)
{
	if(deep==NN) 
	{
		sum[root]=a[sur];
		size[root]=(sur<=n);
		return;
	}
	build(ls,deep+1,sur);
	build(rs,deep+1,sur+(1<<deep));
	sum[root]=sum[ls]+sum[rs];
	size[root]=size[ls]+size[rs];
}
void modify(int root,int deep,int arr,int sur,int value)
{
	if(deep==arr&&sur!=0) return;
	pushdown(root);
	if(deep==arr) return add(root,value);
	if(sur&1) modify(rs,deep+1,arr,sur>>1,value);
	else  modify(ls,deep+1,arr,sur>>1,value);
	sum[root]=sum[ls]+sum[rs];
}
int query(int root,int deep,int arr,int sur)
{
	if(deep==arr&&sur!=0) return 0;
	pushdown(root);
	if(deep==arr) return sum[root];
	if(sur&1) return query(rs,deep+1,arr,sur>>1);
	else return query(ls,deep+1,arr,sur>>1);
}
signed main()
{
	n=R();m=R();
	while(N<=n) N<<=1,NN++; 
	for(int i=1;i<=n;i++) a[i]=R();
	build(1,0,1);
	int op,p,k,pre=0;
	while(m--)
	{
		op=(R()+pre)%2+1;p=R();k=R();
		if(op==1)//修改 
		{
			int v=R();
			if(k!=0)modify(1,0,min(NN,p),k-1,v);
			else modify(1,0,min(NN,p),(1<<(min(NN,p)))-1,v);
		}
		else if(k!=0)printf("%lld\n",pre=query(1,0,min(NN,p),k-1));
		else printf("%lld\n",pre=query(1,0,min(NN,p),(1<<(min(NN,p)))-1));
	}
}
```


---

## 作者：toolong114514 (赞：6)

# P6587 超超的序列 加强 题解
## 题目大意
[传送门](https://www.luogu.com.cn/problem/P6587)。
## 解题思路
看到**本题强制在线**之后，大部分同学的乱搞之心可以死了。

本题其实是让你按某种规律去做区间修改和区间求和，而这个规律显然是 $i\equiv y\pmod {2^x}$。

考虑研究 $i\equiv y\pmod {2^x}$ 的性质。

我们可以把 $i$ 和 $y$ 转成二进制来看。

随便举一组 $i,x,y$：$x=19(1011_2),y=3(11_2),x=2$。

此时，这一组 $i,x,y$ 满足 $i\equiv y\pmod {2^x}$ 的性质。

经观察可得，$i$ 和 $y$ 在二进制下的后 $2$ 位相同。

由二进制数字的性质可以得出，我们实际上是把所有下标 $i$ 的二进制表示中，后 $x$ 位与 $y$ 在二进制表示中的后 $x$ 位相同的 $a_i$ 进行修改。

如何高效地处理呢？

我们考虑 [0-1 trie](https://oi-wiki.org/string/trie/)（不知道的同学可以点蓝字去看看）。

上面所述满足条件的 $i$，其实组成了 0-1 trie 中根的深度为 $x$（假定根的深度为 0）的一颗子树，从根到达该子树的根的路径上，按顺序用边权值组成的 0-1 串与 $y$ 的二进制后 $x$ 位相同。

查询与修改均为在 0-1 trie 中的某棵子树的整体进行。

我们只需要在 0-1 trie 中引入懒标记的思想，就可以做到查询与修改的时间复杂度均为 $O(x)$ 了。

如果此时你仍然不知道代码该如何编写，那么请先阅读有关[线段树](https://oi-wiki.org/ds/seg/)的内容。

总的时间复杂度约为 $O(n\log{n})$。
## 参考代码
```cpp
#include<iostream>
using namespace std;
#define int long long
const int N=5e6+10;
struct node{
	int sum,laz,all;
	int son[3];
}trie[N];
int root,cnt;
void ins(int &pos,int num,int sb,int zyh){
	if(!pos) pos=++cnt;
	trie[pos].sum+=zyh;
	trie[pos].all++;
	if(num==31) return;
	if(sb&(1ll<<(num+1))) ins(trie[pos].son[1],num+1,sb,zyh);
	else ins(trie[pos].son[0],num+1,sb,zyh);
}
void push_down(int pos){
	if(trie[pos].son[0]){
		trie[trie[pos].son[0]].sum+=trie[pos].laz*trie[trie[pos].son[0]].all;
		trie[trie[pos].son[0]].laz+=trie[pos].laz;
	}
	if(trie[pos].son[1]){
		trie[trie[pos].son[1]].sum+=trie[pos].laz*trie[trie[pos].son[1]].all;
		trie[trie[pos].son[1]].laz+=trie[pos].laz;
	}
	trie[pos].laz=0;
}
void push_up(int pos){
	int lson=trie[pos].son[0],rson=trie[pos].son[1];
	trie[pos].sum=trie[lson].sum+trie[rson].sum;
}
void upd(int pos,int num,int hope,int sb,int yy){
	if(!pos) return;
	if(num==hope){
		trie[pos].sum+=trie[pos].all*yy;
		trie[pos].laz+=yy;
		return;
	}
	push_down(pos);
	if(sb&(1ll<<(num+1))) upd(trie[pos].son[1],num+1,hope,sb,yy);
	else upd(trie[pos].son[0],num+1,hope,sb,yy);
	push_up(pos);
}
int ask(int pos,int num,int hope,int sb){
	if(!pos) return 0;
	if(num==hope) return trie[pos].sum;
	push_down(pos);
	if(sb&(1ll<<(num+1))) return ask(trie[pos].son[1],num+1,hope,sb);
	else return ask(trie[pos].son[0],num+1,hope,sb);
}
int a,n,m,lastans;
signed main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a;
		ins(root,-1,i,a);
	}
	while(m--){
		int op,x,y,v;
		cin>>op>>x>>y;
		op=(op+lastans)%2+1;
		if(op==1){
			cin>>v;
			upd(root,-1,x-1,y%(1ll<<x),v);
		}else{
			lastans=ask(root,-1,x-1,y%(1ll<<x));
			cout<<lastans<<'\n';
		}
	}
	return 0;
}
```
[本代码可以通过评测。](https://www.luogu.com.cn/record/144124458)

Written by [toolong114514](https://www.luogu.com.cn/user/477821) on 2024/4/5.

---

## 作者：RedreamMer (赞：6)

[$\Large\texttt{P6587}$](https://www.luogu.com.cn/problem/P6587)

[$\small\texttt{In my cnBlogs}$](https://www.cnblogs.com/RedreamMer/p/13925197.html)

思维题 + 板子题

这道题目蛮有趣的，但坑有点多，在下面会陈述。

## 题意

不做赘述。

注意出题人十分恶心地没给 $x$,$y$,$n$ 的关系，请各位注意这点。

## 思路

看似很难维护，区间操作，但是我们可以利用 $\texttt{trie}$ 的特性来造一棵不同寻常的线段树。

对于序列上的数的位置 $i$ ，模 $2^x$ 后，留下 $x$ 位后缀，对比所有 $i$ 模$2^{x-1}$ 后留下的后缀，只是增加了第 $x$ 位（ $0$ 或 $1$ ）。

因此我们可以把序列按这样构造一棵线段树，每个节点由父亲节点延伸出来，两个子节点的后缀相同，唯一区别最高位是 $0$ 或 $1$。

？？？这不就是 $\texttt{trie}$ 吗 ？？？

所以，这道题目的本意就是让你建一棵**支持区间修改和查询**的  $\texttt{trie}$ ，按照线段树1的板子做就好了。

问题解决。

---

然后我WA了30+发

一定要注意三点：

+ 记得先将 $y$ 对 $x$ 取模再做

+ $y \mod 2^x > n$ 此时不做修改，并且询问返回0

+ $y \le n$ 并且 $2^x > n$ 此时返回 $a_y$

## 代码

还有一些细节在代码中

```cpp
#include <bits/stdc++.h>
using namespace std;

#define ls n << 1
#define rs n << 1 | 1
#define int long long
const int N = 5e7;
inline int read()
{
    register int s = 0;
    register bool neg = 0;
    register char c = getchar();
    for (; c < '0' || c > '9'; c = getchar())
        neg |= (c == '-');
    for (; c >= '0' && c <= '9'; s = s * 10 + (c ^ 48), c = getchar())
        ;
    return (neg ? -s : s);
}

int a,b,s[N+10],sum[N+10],lazy[N+10],t[N+10];

inline void up(int n) {
    sum[n]=sum[ls]+sum[rs];
    t[n]=t[ls]+t[rs];//区间长度
}

inline void down(int n) {
    if(!lazy[n]) return;
    if(t[ls]) sum[ls]+=t[ls]*lazy[n];//注意要判断儿子节点是否存在
    if(t[rs]) sum[rs]+=t[rs]*lazy[n];
    if(t[ls]) lazy[ls]+=lazy[n];
    if(t[rs]) lazy[rs]+=lazy[n];
    lazy[n]=0;
}

inline void insert(int n,int k,int p,int q) {
    if(!q) {
        t[n]=1;
        sum[n]+=p;
        return;
    }
    if(k&1ll) insert(rs,k>>1ll,p,q-1);
    else insert(ls,k>>1ll,p,q-1);
    up(n);
}

inline void change(int n,int k,int p,int q) {
    if(!q) {//注意这里，return的关键是q为0，而不是k为0，因为前导0是有意义的
        sum[n]+=p*t[n];
        lazy[n]+=p;
        return;
    }
    down(n);
    if(k&1ll) change(rs,k>>1ll,p,q-1);
    else change(ls,k>>1ll,p,q-1);
    up(n);
}

inline int query(int n,int k,int q) {
    if(!q) return sum[n];
    down(n);
    if(k&1ll) return query(rs,k>>1ll,q-1);
    else return query(ls,k>>1ll,q-1);
}

signed main()
{
    // freopen("in1.in", "r", stdin);
    a=read();
    b=read();
    int mx=ceil(log2(a));
    for(int i=1;i<=a;i++) s[i]=read(),insert(1,i,s[i],mx);
    int x,y,z,lst=0,opt,cnt=0;
    for(int i=1;i<=b;i++) {
        opt=(read()+lst)%2+1;
        if(opt==1) {
            x=read();
            y=read();
            z=read();
            y%=(1ll<<x);
            if(x<=mx) change(1,y,z,x);
            else if(y<=a) change(1,y,z,mx);
        }
        else {
            x=read();
            y=read();
            y%=(1ll<<x);
            if(x<=mx) printf("%lld\n",lst=query(1,y,x));
            else if(y<=a) printf("%lld\n",lst=query(1,y,mx));
            else printf("%lld\n",lst=0);
        }
    }
    return 0;
}
```

---

## 作者：zzzyyyyhhhhh (赞：5)

看到题解中全是用树做的，于是发一篇不需要任何算法的题解，是目前最短解。

约定：用 $cnt_{x,y}$ 表示序列中 $i\equiv y\pmod 2^x$ 的 $i$ 的个数。

直接考虑操作，考虑现在有一个询问 $x,y$ ，前面的一次操作为  $x_1,y_1,v_1$ 。

如果 $x_1\le x$ ,那么这次操作对这次询问的贡献是 $cnt_{x,y}\times v_1$ 。用 g 数组记录 $v_1$ 的和。

如果 $x_1\ge x$ 那么贡献是 $cnt_{x_1,y_1}\times v_1$ 。用 f 数组记录贡献的和。

总复杂度 $O((n+m)\log n)$。

还不懂的话看代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5+100;
typedef long long ll;
#define mod(X) ((1<<X)-1)
int n,m;
ll f[21][1<<20],g[21][1<<20];
int cnt[21][1<<20];
signed main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	int op,x,y;
	ll ans=0,z;
	for(int i=1;i<=n;i++)
	{
		cin>>x;
		for(int j=0;j<=20;j++)
		{
			f[j][i&mod(j)]+=x;
			cnt[j][i&mod(j)]++;
		}
	}
	while(m--)
	{
		cin>>op;
		op=((ans+op)&1)+1;
		if(op&1)
		{
			cin>>x>>y>>z;
			for(int i=x;i>=0;i--)
				f[i][y&mod(i)]+=z*cnt[x][y];			
			g[x][y]+=z;
		}
		else
		{
			cin>>x>>y;
			ans=f[x][y];
			for(int j=x-1;j>=0;j--)
				ans+=(ll)g[j][y&mod(j)]*cnt[x][y];
			cout<<ans<<'\n';
		}
	}
}
```

---

## 作者：Richard_Whr (赞：4)

提供一种既不使用 Trie 也不使用线段树的做法，仅使用了数组。

常数小且空间可以做到 $O(n)$。

总的想法是对于每一个 $x$ 维护一个长 $2^x$ 的数据结构。你可以看成将序列使用 $2^x$ 划成了若干块，将所有块内下标相同的压在一起。

注意到这样一个性质，就是如果比我的 $x$ 低位 $c$ 位执行了对 $y$ 的加法操作，那第 $x$ 层只会在更多地方加入，也就是形成了包含关系。

反之，如果比我的高位执行了加法操作，那我这边只有某些位置会加，虽然都是同一位置，但是和所在块的位置有关系。

考虑怎么维护这个东西，如果我们只打一个 $tag$：$tag_{x,i}$ 表示第 $x$ 层第 $i$ 个位置集体加的值。

发现我们可以通过求和所有 $y \le x,tag_{y,i \operatorname{and} (2^y-1)}$ 来得到低位部分的贡献。

乘上 $sz_{x,i}$ 即可，表示这一层这个位置有几个数。

但是高位却无法处理，因为往高位走的时候相当于一个分裂的过程，复杂度爆炸。

我们尝试在高位加的时候就提前算出对低位的贡献。

虽然说并不是低位的每个块都会加，但是至少位置是一样的，且加的总和相同，直接维护这个总和。

我们另开一个数组 $tag2_{x,i}$ 表示第 $x$ 层第 $i$ 个位置接受高位的加法总和。

每次执行加法操作的时候，令 $y<x,tag2_{y,i \operatorname{and} (2^y-1)}+c \times sz_{x,i}$。

发现现在整个体系已经完备，修改和查询都可以维护。

单次修改和查询都是 $\log n$，空间可以做到 $\sum\limits_{i=0}^{\log n}2^i=n$。

常数小，代码简单，理解略困难。为方便空间直接开了 $n \log n$。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+10,M=22;
int a[N];
int sum[M][N];
int sz[M][N];
int tag1[M][N],tag2[M][N];
int n,m;

void add(int x,int i,int c)
{
	tag1[x][i]+=c;
	int w=sz[x][i]*c;
	for(int v=x;v>=0;v--)
	{
		tag2[v][i&((1<<v)-1)]+=w;
	}
}

int query(int x,int i)
{
	int c=0;
	for(int v=x-1;v>=0;v--) c+=tag1[v][i&((1<<v)-1)];
	int w=sz[x][i]*c;
	return sum[x][i]+w+tag2[x][i];
}

signed main()
{
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	
	for(int i=1;i<=n;i++)
	{
		for(int v=0;v<M;v++)
		{
			sz[v][i&((1<<v)-1)]++;
			sum[v][i&((1<<v)-1)]+=a[i];
		}
	}
	
	int last=0;
	while(m--)
	{
		int op;
		cin>>op;
		op=(last+op)%2+1;
		if(op==1)
		{
			int x,y,z;
			cin>>x>>y>>z;
			if(y>n) continue;
			add(x,y,z);
		}
		else
		{
			int x,y;
			cin>>x>>y;
			if(y>n) last=0;
			else last=query(x,y);
			cout<<last<<"\n";
		}
	}
	
	return 0;
}
```

---

## 作者：doer_ (赞：3)

[更好的阅读体验](https://www.cnblogs.com/dream1024/p/14021790.html)

# 题目

[传送门](https://www.luogu.com.cn/problem/P6587)

# 思路

作为一道蓝题,这题并不难想,就是细节有点多



真的挺好的一道题,把线段树和trie很好地融合到一起

以样例为例,建一棵如下的01trie,其中,红色数字就是输入进来的a,根到该数字的路径形成的数字就是该数字下标的二进制表示(从低位到高位)

例如,4这个数字:根到4的路径为0->0->1,4的下标为(100)2(这个表示二进制),即4

![](https://img2020.cnblogs.com/blog/2206241/202011/2206241-20201122215833598-205560425.png)

观察每一个询问,

>  `2 x y`：询问所有 ai 的和，其中 i≡y(mod 2^x)。

**我们直接先令y%=2^x**

以`x=2,y=1`为例,求的就是所有的`a[i]`的和,其中i满足二进制下最后x位等于y,即最后两位为01,还是看图


![](https://cdn.luogu.com.cn/upload/image_hosting/3sdpzy2a.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

被圈起来的这棵子树的所有数字肯定都是要计算的(因为对应的i在二进制下必以01结尾),我们直接用自底向上的前缀和维护即可

特别地,"1"这个数字也要计算,这需要特判一下,这就是这道题麻烦的地方

修改操作同理

不觉得这很像线段树了吗?每一次的操作都是对一整个子树进行的,不同的是:有时候还会对根到这棵子树的路径上的某些点操作,但是这不影响大局

所以,我们考虑用懒标记优化,做法与线段树类似,这里不细讲,具体看代码



另外,值得注意的是:每一个红色的数字都是在树的"1"结点上的,也就是说,每一次修改或查询最多涉及到一个目标子树外的结点(按照上面`x=2,y=1`的例子,目标子树就是图中被圈起来的子树),这里仔细思考一下,不理解也没关系,这个不是很重要,我也是AC之后才意识到的,但是有助于加深对这道题的理解以及简化代码



**最后,一定要开long long,否则0分(亲测)**

# 代码(附对拍程序)

**注意:使用对拍的时候需要将强制在线关掉,见下:**

```cpp
		op = read();
		op = (op + lastans) % 2 + 1;
```

变为:

```cpp
		op = read();
//		op = (op + lastans) % 2 + 1;
```

**另外,std程序可以找一个标程,但建议自己写暴力(毕竟比赛没有标程)**

## 我的AC代码(tested.cpp)

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define nn 1000010
#define ll long long
using namespace std;
int read() {
	int re = 0;
	bool sig = false;
	char c = getchar();
	while(c < '0' || c > '9') {
		if(c == '-')
			sig = true;
		c = getchar(); 
	}
	while(c >= '0' && c <= '9')
		re = (re << 1) + (re << 3) + c - '0',
		c = getchar();
	return sig ? -re : re;
}
int trie[nn][3] , num[nn];
ll a[nn] , tag[nn] , dat[nn];
int n , m;
void build() {
	int top = 1;
	for(int i = 1 ; i <= n ; i++) {
		int tmp = i;
		int p = 1;
		while(tmp != 0) {
			if(trie[p][tmp & 1] == 0)
				trie[p][tmp & 1] = ++top;
			p = trie[p][tmp & 1];
			tmp >>= 1;
		}
		a[p] = dat[p] = read();
		num[p]++;
	}
	
}
void dfs(int p) {
	if(p == 0)return;
	dfs(trie[p][0]);
	dfs(trie[p][1]);
	dat[p] += dat[trie[p][0]] + dat[trie[p][1]];
	num[p] += num[trie[p][0]] + num[trie[p][1]];
	tag[p] = 0;
}
inline void spread(int p) {//懒标记下传
	if(p == 0) {
		tag[p] = 0;
		return;
	}
	if(tag[p] != 0) {
		tag[trie[p][0]] += tag[p];
		dat[trie[p][0]] += num[trie[p][0]] * tag[p];
		if(a[trie[p][0]] != -1)
			a[trie[p][0]] += tag[p];
		
		tag[trie[p][1]] += tag[p];
		dat[trie[p][1]] += num[trie[p][1]] * tag[p];
		if(a[trie[p][1]] != -1)
			a[trie[p][1]] += tag[p];
	}
	tag[p] = 0;
}
void change(int x , int y , ll v , int p) {//修改,使用递归的方式,有助于更新dat值
	if(x == 0) {
		if(a[p] != -1)
			a[p] += v;
		dat[p] += v * num[p];
		tag[p] += v;
		return;
	}
	
	spread(p);
	change(x - 1 , y >> 1 , v , trie[p][y & 1]);
	if(y == 0 && a[p] != -1) {
		a[p] += v;
	}
	dat[p] = dat[trie[p][0]] + dat[trie[p][1]];
	if(a[p] != -1)
		dat[p] += a[p];
}
int query() {//查询
	int x = read() , y = read();
	ll res = 0;
	int p = 1;
	y %= (1 << x);
	for(int i = 1 ; i <= x ; i++) {
		spread(p);
		if(y == 0)
			res += dat[p] - dat[trie[p][0]] - dat[trie[p][1]];
		p = trie[p][y & 1];
		y >>= 1;
	}
	res += dat[p];
	printf("%lld\n" , res);
	return res;
}
int main() {
	memset(a , -1 , sizeof(a));//值为-1代表该结点没有数字
	n = read();	m = read();
	build();
	dfs(1);
	ll lastans = 0;
	for(int i = 1 ; i <= m ; i++) {
		int op;
		op = read();
		op = (op + lastans) % 2 + 1;
		if(op == 1) {
			int x , y , v;
			x = read();	y = read();	v = read();
			change(x , y % (1 << x) , (ll)v , 1);
		}
		else
			lastans = query();
			
	}
	return 0;
} 
```



## 随机数据生成(random.cpp)

```cpp
#include <bits/stdc++.h>
using namespace std;
int random(int r , int l = 1) {
	if(l == r)return l;
	return (long long)rand() * rand() % (r - l) + l;
}
int main() {
	srand((unsigned) time(0));
	
	int n = 100 , m = 100;
	printf("%d %d\n" , n , m);
	for(int i = 1 ; i <= n ; i++)
		printf("%d " , random(20));
	putchar('\n');
	for(int i = 1 ; i <= m ; i++) {
		int op = rand() % 2 + 1;
		int tmp = log(n) / log(2);
		int x = random(tmp * 3 / 2 , tmp / 2) , y = random(1024) , v = random(1000);
		printf("%d " , op);
		if(op == 1)
			printf("%d %d %d\n" , x , y , v);
		else
			printf("%d %d\n" , x , y);
	}
	return 0;
}
```

## 对拍控制(compare.cpp)

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	while(true) {
		system("random.exe > input.txt");
		puts("random");
		
		system("tested.exe < input.txt > output1.txt");
		puts("tested");
		
		system("std.exe < input.txt > output2.txt");
		puts("std");
		
		if(system("fc output1.txt output2.txt")) {
			cout << "WA";
			system("start input.txt");
			return 0;
		}
	}
	return 0;
}

```

---

## 作者：Tmbcan (赞：2)

## [P6587 超超的序列 加强](https://www.luogu.com.cn/problem/P6587)
### 题目描述
给定一个序列 $a_N$，每次给出 $x$ 和 $y$。每次对所有满足 $i\equiv y\pmod{2^x}$ 的 $a_i$ 进行操作和查询。

### 思路
考虑用线段树维护。但是本题的难点在于，所有的操作都不是直接对区间的操作，我们要想办法把其变成对区间的操作。  

思考当前 $i$ 与 $x$ 和 $y$ 的关系：  
在二进制下，$i\bmod 2^x$ 可以看作把 $i$ 的后 $x$ 位留下，前面的位数直接不要了。那么如果 $i$ 与 $y$ 的后 $x$ 位相同，则 $i\equiv y\pmod{2^x}$。

所以，建树时我们可以钦定树边存在 0 和 1 的边权，那么一个叶子节点到根的链上所有边权拼在一起组成的二进制数，即为当前节点对应在原序列上的编号。  

具体地：  
令节点到右儿子的边权为 1，到左儿子的边权为 0。每次操作时从根节点开始，以左右儿子节点的选取，来代表当前节点对应在原序列上的位置 $i\bmod 2^x$ 的值。   
注意树的边权组成的二进制数代表当前位置 $i\bmod 2^x$ 的值（从根节点开始到当前节点），即 $i$ 的后缀。  

每次操作时，对所有与 $y$ 有相同 $x$ 位的后缀的节点进行修改，这些节点由于后缀相同，所以处于线段树的同一个区间中。考虑标记永久化，则只用对与 $y$ 有相同 $x$ 位后缀的最浅节点做修改即可。  
此时对序列的操作就变成了对树上一个区间的操作。代码只要模拟我们刚刚所说的过程即可。  

节点编号存在二进制关系用 zkw 线段树，码量十分可观。
### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<climits>
#include<cstdlib>
#include<ctime>
using namespace std;
typedef long long ll;
template <typename T>
inline void read(T&x){
	int w=0;x=0;
	char ch = getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') w=1;
		ch = getchar();
	}
	while(ch>='0'&&ch<='9'){
		x = (x<<1)+(x<<3)+(ch^48);
		ch = getchar();
	}
	if(w) x=-x;
}
template <typename T,typename...Args>
inline void read(T&t,Args&...args){
	read(t);read(args...);
} 
const int N = (1<<21)+10;//谨防越界
int n,T;
int P=1,DEP=0,siz[N];
ll tr[N],tag[N];
inline void update(int x,int y,int k){
	int l = 1;
	for(int dep=0;dep<x;++dep,y>>=1) l=l<<1|(y&1);
	tr[l] += 1ll*k*siz[l]; tag[l] += 1ll*k;//标记永久化
	for(l>>=1; l ;l>>=1) tr[l]=tr[l<<1]+tr[l<<1|1]+siz[l]*tag[l];//维护节点信息
}
inline ll query(int x,int y){
	int l = 1; ll res = 0;
	for(int dep=0;dep<x;++dep,y>>=1){
		res += tag[l];//标记永久化，所以要沿途累加标记值
		l = l<<1|(y&1);//模拟左右子树选取
	}
	res = res*siz[l]+tr[l];//节点真实值还要加上标记的值
	return res;
}
int main(){
	read(n,T);
	while(P<=(1<<19)+1) P<<=1,++DEP;//注意节点开到2^21
	for(int i=1,l=1;i<=n;++i){
    //对于序列上的每一个位置都判断其对应在哪个叶子节点
		for(int dep=0;dep<DEP;++dep) l=l<<1|((i>>dep)&1);
		read(tr[l]);siz[l] = 1;l = 1;
	}
	for(int i=(1<<DEP)-1;i;--i){
		siz[i] += siz[i<<1]+siz[i<<1|1];
		tr[i] = tr[i<<1]+tr[i<<1|1];
	}
	ll ans = 0;
	for(int i=1,opt,x,y,v;i<=T;++i){
		read(opt,x,y);opt=((ans+opt)&1)+1;//强制在线
		if(opt==1){
			read(v);
			update(x,y,v);
		}
		else printf("%lld\n",(ans = query(x,y)));
	}
	return 0;
}
```

---

## 作者：Jerrycyx (赞：1)

### 前言

我在尝试一种很新的线段树。

-----

### 解析

#### 转换题意

首先观察每次操作下标的特点：

> $i \equiv y\pmod {2^x}$

在题面中发现了形如 $2^x$ 的结构，很容易想到将 $i$ 二进制分解。那么对 $2^x$ 取模就相当于只保留 $i$ 的末 $x$ 位。因为【数据范围】中“$0 \le y < 2^x$”，所以这时再与 $y$ 判断同余相当于**选择了下标在二进制下末 $x$ 位为 $y$ 的数**。 

举例，当 $x=2$，$y=2=(10)_2$ 时，所选取的就是下面标红的数：

$$
1 = (\textcolor{gray}{00}01)_2 \\
\textcolor{red}{2} = (\textcolor{gray}{00}\textcolor{red}{10})_2 \\
3 = (\textcolor{gray}{00}11)_2 \\
4 = (\textcolor{gray}{01}00)_2 \\
5 = (\textcolor{gray}{01}01)_2 \\
\textcolor{red}{6} = (\textcolor{gray}{01}\textcolor{red}{10})_2 \\
7 = (\textcolor{gray}{01}11)_2 \\
8 = (\textcolor{gray}{10}00)_2 \\
9 = (\textcolor{gray}{10}01)_2
$$

#### 建树

在常规的线段树中，某个节点下所有子叶节点和这个公共祖先的纽带是它们的下标都在这个公共祖先代表的区间内。而每次操作也都是在区间意义下进行。

然而在这里可以看到，每次操作的下标并不是连续的，或者说不是常规数值意义上连续的，貌似不能用常规线段树维护。

但是，在二进制下它们共用同一个后缀，操作也是在同一个二进制后缀意义下进行。于是可以用这个作为节点间联系的纽带：

+ **同一个祖先下所有子节点共用一个后缀**；
+ 因为父节点比子节点范围更大，所以**父节点代表的后缀长度比子节点更短**；
+ **父节点走向子节点时，通过后缀中新扩展的一位**（子节点代表的后缀更长）**是 $0$ 或 $1$ 来决定左右子节点**。

有图有真相！

![](https://cdn.luogu.com.cn/upload/image_hosting/sw5sox01.png)

在上图中，线段树节点内的数字表示了其代表的后缀（`_` 表示空位）。左子节点在父节点后缀的基础上多了一个 $0$，右子节点多了一个 $1$。

右侧绿色数字有多重含义：即表示当前节点所处层数，又表示节点表示后缀的长度，还**表示查询和修改时对应的 $x$ 值**。

蓝色文字则表示叶节点对应的数组元素。

在建树过程中，为了保证树的形状和上图一模一样，区间长度是准确的 $2^k$ 以避免不必要的麻烦，可以直接建立一棵高度为 $20$，长度为 $2^{20}$（数据范围 $0 \le x \le 20$）的**满二叉树**。

因为下面的延迟标记部分需要获取区间内元素个数，所以还需要额外记录一下每个节点子树的大小（指后代叶节点的数量，下同）。将合法叶节点（所表示下标在 $[1,n]$ 内的，[我是若只](https://www.luogu.com.cn/discuss/1056622)）大小置为 $1$，空叶节点大小置为 $0$ 以消除它的影响，然后父节点的大小正常地用子节点大小相加即可。

附建树代码：

```cpp
const int L=20;
struct SegmentTree{
	int l,v,sz; //l表示所处层数，v表示对应后缀，sz为子叶节点数量（区间长度）
	long long dat,lazy; //dat为子树和，lazy为延迟标记
}tree[(1<<L+2)+5];
inline void update(int p)
{
	tree[p].dat=tree[p<<1].dat+tree[p<<1|1].dat;
	tree[p].sz=tree[p<<1].sz+tree[p<<1|1].sz;
	return;
}
void Build(int p,int l,int v)
{
	tree[p].l=l,tree[p].v=v;
	if(l==L) //到达最大层数，此时p为叶节点，后缀中不再有空位，v即为a对应的下标
	{
		if(1<=v&&v<=n)
		{
			tree[p].sz=1;
			tree[p].dat=a[v];
			tree[p].lazy=0;
		}
		return;
	}
	Build(p<<1,l+1,v),Build(p<<1|1,l+1,v|1<<l);
	update(p);
	return;
}
```

构建出这样一棵线段树后，各种操作就很清晰明了了。

#### 查询

查询操作在这样一棵树上异常的简单，因为在这棵线段树上每一段可能的长度和后缀都有对应的节点，**所以所查询的必然是一棵完整的子树，只需要找到这个子树的根节点（$l=x$ 且 $v=y$）再返回即可**，甚至不需要像普通线段树那样合并区间答案。

查询部分代码：

```cpp
long long Query(int p,int l,int v)
{
	if(tree[p].l==l) return tree[p].dat; //找到对应节点，这时tree[p].v==v
	spread(p); //下传延迟标记，具体过程在后面
	if(v>>tree[p].l&1) return Query(p<<1|1,l,v);
	else return Query(p<<1,l,v);
}
```


#### 修改

和查询一样，**每次修改的必定是一棵完整的子树**，但是由于这棵子树中所有节点都需要同步修改，所以我们还需要一个**延迟标记**。

标记下传代码：

```cpp
inline void spread(int p) //和一般线段树延迟标记下传几乎一模一样
{
	if(tree[p].lazy)
	{
		tree[p<<1].dat+=tree[p].lazy*tree[p<<1].sz;
		tree[p<<1|1].dat+=tree[p].lazy*tree[p<<1|1].sz;
		tree[p<<1].lazy+=tree[p].lazy;
		tree[p<<1|1].lazy+=tree[p].lazy;
		tree[p].lazy=0;
	}
	return;
}
```

修改部分代码：

```cpp
void Add(int p,int l,int v,long long d)
{
	if(tree[p].l==l) //找到对应节点，此时tree[p].v==v
	{
		tree[p].dat+=d*tree[p].sz;
		tree[p].lazy+=d;
		return;
	}
	spread(p);
	if(v>>tree[p].l&1) Add(p<<1|1,l,v,d);
	else Add(p<<1,l,v,d);
	update(p);
	return;
}
```

至此，线段树的建树、查询和修改都完成了。时间复杂度 $O(MX)$（$X$ 为 $x$ 的最大值，本题中为 $20$）。

----

### 代码

有几点注意事项：

+ 开 `long long`，这个应该不用多说；
+ 因为这道题有离线处理部分，所以只要有一个答案是错的，后面的查询和修改就全乱了，读入到的数据也不再符合数据范围。因此，这道题中 $\rm RE$ 一般来说等价于 $\rm WA$；
+ 因为线段树维护区间长度是固定的 $2^{20}$，所以线段树空间应该开成 $2^{20} \times 4$。

主函数及[完整代码](https://www.luogu.com.cn/record/201828287)（注释在前面的代码片段中）：

```cpp
#include<cstdio>
#define LL long long
using namespace std;

const int N=2e5+5,L=20;
int n,q,a[N];

struct SegmentTree{
	int l,v,sz;
	LL dat,lazy;
}tree[(1<<L+2)+5];
inline void update(int p)
{
	tree[p].dat=tree[p<<1].dat+tree[p<<1|1].dat;
	tree[p].sz=tree[p<<1].sz+tree[p<<1|1].sz;
	return;
}
void Build(int p,int l,int v)
{
	tree[p].l=l,tree[p].v=v;
	if(l==L)
	{
		if(1<=v&&v<=n)
		{
			tree[p].sz=1;
			tree[p].dat=a[v];
			tree[p].lazy=0;
		}
		return;
	}
	Build(p<<1,l+1,v),Build(p<<1|1,l+1,v|1<<l);
	update(p);
	return;
}
inline void spread(int p)
{
	if(tree[p].lazy)
	{
		tree[p<<1].dat+=tree[p].lazy*tree[p<<1].sz;
		tree[p<<1|1].dat+=tree[p].lazy*tree[p<<1|1].sz;
		tree[p<<1].lazy+=tree[p].lazy;
		tree[p<<1|1].lazy+=tree[p].lazy;
		tree[p].lazy=0;
	}
	return;
}
LL Query(int p,int l,int v)
{
	if(tree[p].l==l) return tree[p].dat;
	spread(p);
	if(v>>tree[p].l&1) return Query(p<<1|1,l,v);
	else return Query(p<<1,l,v);
}
void Add(int p,int l,int v,LL d)
{
	if(tree[p].l==l)
	{
		tree[p].dat+=d*tree[p].sz;
		tree[p].lazy+=d;
		return;
	}
	spread(p);
	if(v>>tree[p].l&1) Add(p<<1|1,l,v,d);
	else Add(p<<1,l,v,d);
	update(p);
	return;
}


int main()
{
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	Build(1,0,0);
	LL ans=0;
	for(int i=1;i<=q;i++)
	{
		int op; scanf("%d",&op);
		op=((op+ans)&1)+1;
		if(op==1)
		{
			int l,v,d; scanf("%d%d%d",&l,&v,&d);
			Add(1,l,v,d);
		}
		if(op==2)
		{
			int l,v; scanf("%d%d",&l,&v);
			ans=Query(1,l,v);
			printf("%lld\n",ans);
		}
	}
	return 0;
}
```

---

## 作者：Super_Cube (赞：1)

# Solution

我寻思着这题也不需要啥数据结构吧。

每次修改和查询都是基于 $i\equiv y\pmod {2^x}$，那相互之间是有很大关联的。举个例子，当 $x=3,y=5$ 时的修改，会对 $5,13,\cdots$ 等位置造成影响，它们是 $1,5,9,13,\cdots$（即 $i\equiv 1\pmod 4$）这些位置的子集，也是 $1,3,5,7,9,11,13,\cdots$ （即 $i\equiv 1\pmod 2$）这些位置的子集……。

设 $f_{i,j}$ 表示模 $2^i$ 为 $j$ 的位置造成的贡献，$c_{i,j}$ 表示 $1\sim n$ 中模 $2^i$ 为 $j$ 的位置个数。

先看修改。对 $\forall i\in[0,x]$，有 $f_{i,y\bmod 2^i}\gets v\cdot c_{x,y}$。对 $\forall i\in[x+1,20]$，有 $\forall j\bmod 2^i=y,f_{i,j}\gets v\cdot c_{i,j}$。

查询就直接是 $f_{x,y}$。

这就是暴力做法，复杂度不想计算，反正铁定超时。

下面是这样写的参考代码。

```cpp
#include<stdio.h>
long long f[21][200001];
int c[21][200001];
int n,m;
long long ans;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,x;i<=n;++i){
		scanf("%d",&x);
		for(int j=20;~j;--j)
			f[j][i&((1<<j)-1)]+=x,++c[j][i&((1<<j)-1)];
	}
	for(int op,x,y;m--;){
		scanf("%d%d%d",&op,&x,&y);
		op=ans+op+1&1;
		if(op==1){
			scanf("%d",&op);
			if(y>n)continue;
			for(int i=x;~i;--i)
				f[i][y&((1<<i)-1)]+=1ll*op*c[x][y];
			for(int i=x+1;i<=20;++i)
			    for(int j=(1<<i-x)-1;~j;--j)
    				if(((j<<x)|y)<=n)f[i][(j<<x)|y]+=1ll*op*c[i][(j<<x)|y];
		}else{
			if(y>n){
				puts("0");ans=0;
				continue;
			}
			ans=f[x][y];
			printf("%lld\n",ans);
		}
	}
	return 0;
}
```

问题出在修改与查询的复杂度极度不均衡，要想个办法来平衡两部分。

注意到修改中前半部分（往 $x$ 及其更低位的更新）复杂度是没有问题的，慢在后半部分。实质是在高位上对 $y$ 的超集进行更新，那么可以在当前位上打标记，在查询时把这部分贡献算上即可。

具体的，$f_{i,j}$ 改为 $i$ 及其低位的贡献，设 $g_{x,y}$ 表示对高位的标记。

修改：对 $\forall i\in[0,x]$，依然有 $f_{i,y\bmod 2^i}\gets v\cdot c_{x,y}$。多了 $g_{x,y}\gets v$ 这一步。

查询：先有 $f_{x,y}$ 的贡献，然后对于 $\forall i\in[0,x)$，会做出 $g_{i,y\bmod 2^i}\cdot c_{x,y}$ 的贡献。

# Code

```cpp
#include<stdio.h>
long long s1[21][200001],s2[21][200001];
int cnt[21][200001];
int n,m;
long long ans;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,x;i<=n;++i){
		scanf("%d",&x);
		for(int j=20;~j;--j)
			s1[j][i&((1<<j)-1)]+=x,++cnt[j][i&((1<<j)-1)];
	}
	for(int op,x,y;m--;){
		scanf("%d%d%d",&op,&x,&y);
		op=ans+op+1&1;
		if(op==1){
			scanf("%d",&op);
			if(y>n)continue;
			s2[x][y]+=op;
			for(int i=x;~i;--i)
				s1[i][y&((1<<i)-1)]+=1ll*op*cnt[x][y];
		}else{
			if(y>n){
				puts("0");ans=0;
				continue;
			}
			ans=s1[x][y];
			for(int i=x-1;~i;--i)
				ans+=s2[i][y&((1<<i)-1)]*cnt[x][y];
			printf("%lld\n",ans);
		}
	}
	return 0;
}
```

---

## 作者：HPXXZYY (赞：1)

$\color{blue}{\texttt{[Analysis]}}$

显然，除了操作序列并不连续之外，这道题就**线段树**的模板题。

在笔者有限的知识储备中，没有找到第二种数据结构能直接解决这道题目。所以我们还是考虑线段树。

问题的焦点：**如何使需要操作的序列变得连续**。

因为模数都是 $2$ 的次幂，我们猜想这道题的解法应该和**二进制**有关。

显然，如果 $u \equiv v \pmod {2^{x}}$，那么 $u$ 和 $v$ 的二进制的**最低** $x$ 位应该**完全相同**。

改造一下我们的线段树，分别赋予每个点向它的两个儿子的两条边 $0$ 或 $1$ 的边权。这样，从根节点开始到该节点，经过的所有边的边权倒序相连接，就标记二进制的最低若干位。

这句话一定是非常的不好理解，我们来看个图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/01ea0469b6d2477ab4d0a8be5b2829ed.png#pic_center)


> 对于图中标号为 $1$ 的节点：从根节点到它所有边上的边权倒序连接可以得到 $1$，因此该节点保存所有二进制**最低**一位为 $1$ 的节点的信息（即点权和），即在 $a$ 数组中下标为 $1,3,5,7,\cdots$ 的节点的信息。
> 
> 对于图中标号为 $2$ 的节点：从根节点到它所有边上的边权倒序连接可以得到 $100$，因此该节点保存所有二进制**最低**三位为 $100$ 的节点的信息（即点权和），即在 $a$ 数组中下标为 $4,12,20,28,\cdots$ 的节点的信息。
> 
> 对于图中标号为 $3$ 的节点：从根节点到它所有边上的边权倒序连接可以得到 $011$，因此该节点保存所有二进制**最低**三位为 $011$ 的节点的信息（即点权和），即在 $a$ 数组中下标为 $3,11,19,27,\cdots$ 的节点的信息。
> 
> 对于图中标号为 $4$ 的节点：从根节点到它所有边上的边权倒序连接可以得到 $01$，因此该节点保存所有二进制**最低**两位为 $01$ 的节点的信息（即点权和），即在 $a$ 数组中下标为 $1,5,9,13,\cdots$ 的节点的信息。

~~现在大家应该理解了吧……~~

于是，我们就把需要操作的序列变得连续，直接使用线段树即可。

$\color{blue}{\texttt{[Attention]}}$

实现时有几个地方需要注意：

1. 线段树的节点数一定要开满 $2^{21}$，因为按照该方案，我们最底层的节点需要保存 $0$ 到 $(2^{20}-1)$ 共 $2^{20}$ 个标号的信息，只要少一点，都会 RE。
2. 在线段树中有很多节点是无用的（但是我们不能弃去）。由于数组长度有限制，因此需要计算出每个节点下究竟有几个节点是应该被操作的。否则进行第一个操作将会导致 WA。
3. 如果想要剪枝，可以避免遍历那些所有节点都无用的子树。

$\color{blue}{\texttt{[code]}}$

```cpp
const int N=2e5+100;
const int M=(1<<20)+100;
typedef long long ll;

int a[N],n,m;ll lst;

ll val[M<<1],tag[M<<1];
int ls[M<<1],rs[M<<1],len[M<<1],rt,sgcnt;

inline void pushup(int o){
	val[o]=val[ls[o]]+val[rs[o]];
}
inline void pushdown(int o){
	ll Tag=tag[o];tag[o]=0;
	val[ls[o]]+=Tag*len[ls[o]];
	val[rs[o]]+=Tag*len[rs[o]];
	tag[ls[o]]+=Tag;
	tag[rs[o]]+=Tag;
}
void build(int &o,int l,int r,int x,int dep){
	o=++sgcnt;tag[o]=0;
	
	if (l==r){
		if (x&&(x<=n)){
			val[o]=a[x];
			len[o]=1;
		}//不是每个节点都会被操作
		else val[o]=len[o]=0;
		return;
	}
	
	int mid=(l+r)>>1;
	build(ls[o],l,mid,x,dep+1);
	build(rs[o],mid+1,r,x|(1<<dep),dep+1);
	len[o]=len[ls[o]]+len[rs[o]];//!!
	pushup(o);return;
}//注意都是从二进制低位到高位读取数据！
void modify(int o,int l,int r,int p,int v,int x,int dep){
	if (dep==p){
		val[o]+=1ll*v*len[o];//不能用 (r-l+1) 代替 len[o]
		tag[o]+=v;return;
	}
	
	if (tag[o]) pushdown(o);
	
	int mid=(l+r)>>1;
	if (!(x&(1<<dep)))
		modify(ls[o],l,mid,p,v,x,dep+1);
	else modify(rs[o],mid+1,r,p,v,x,dep+1);
	
	pushup(o);return;
}
ll query(int o,int l,int r,int p,int x,int dep){
	if (dep==p) return val[o];
	if (tag[o]) pushdown(o);
	int mid=(l+r)>>1;ll ans=0;
	if (!(x&(1<<dep))) ans=query(ls[o],l,mid,p,x,dep+1);
	else ans=query(rs[o],mid+1,r,p,x,dep+1);
	return ans;
}

int main(){
	n=read();m=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	
	build(rt,0,(1<<20)-1,0,0);//大量冗余，可以剪枝
	
	for(int i=1,opt,x,y;i<=m;i++){
		opt=read();x=read();y=read();
		
		opt=(lst+opt)%2+1;
		
		if (opt==1) modify(rt,0,(1<<20)-1,x,read(),y,0);
		else{
			lst=query(rt,0,(1<<20)-1,x,y,0);
			printf("%lld\n",lst);
		}
	}
	
	return 0;
}
```

---

## 作者：SamHJD (赞：0)

考虑这样一种二叉树形结构，第 $x$ 层的 $2^x-1$ 个点表示 $i\equiv y\pmod {2^x},y\in[0,2^x)$ 的 $a_i$ 的和，同时满足父节点代表的下标集合为两个子结点代表的下标集合的并集：

![](https://cdn.luogu.com.cn/upload/image_hosting/xwomf7i6.png)

计 $siz_{x,y}$ 表示满足 $i\equiv y\pmod {2^x}$ 的下标个数，$(x,y)$ 表示该点，则操作一可以分为将 $(x,y)$ 到根的每个点的值加 $siz_{x,y}\times v$ 和将 $(x,y)$ 的子树中的点 $(a,b)$ 加 $siz_{a,b}\times v$ 两部分。树的深度为 $\log n$ 级别，因此前者可直接暴力修改，后者在 $(x,y)$ 处打上 $v$ 的标记即可。

查询时先计算 $(x,y)$ 到根的标记和，乘 $siz(x,y)$  并加上该点的值输出。

```cpp
#include <bits/stdc++.h>
#define int long long
#define rep(i,k,n) for(int i=k;i<=n;++i)
#define per(i,n,k) for(int i=n;i>=k;--i)
using namespace std;
template<typename T>
inline void read(T &x){
	x=0;int f=1;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c-'0');
	x*=f;
}
const int N=2e6+10;
int n,m,a[N],lst,t[25][N],tag[25][N],siz[25][N],qp[25];
signed main(){
    read(n);read(m);
    qp[0]=1;rep(i,1,20) qp[i]=qp[i-1]*2;
    rep(i,1,n){
        read(a[i]);
        rep(j,0,20) t[j][i%qp[j]]+=a[i],siz[j][i%qp[j]]++;
    }    
    rep(i,1,m){
        int op;read(op);op=((op+lst)%2)+1;
        if(op==1){
            int x,y,v;read(x);read(y);read(v);
            tag[x][y]+=v;
            rep(j,0,x) t[j][y%qp[j]]+=siz[x][y]*v;
        }
        else{
            int x,y;read(x);read(y);
            int sum=0;
            rep(j,0,x-1) sum+=tag[j][y%qp[j]];
            printf("%lld\n",sum*siz[x][y]+t[x][y]);lst=sum*siz[x][y]+t[x][y];
        }
    }
	return 0;
}
```

---

## 作者：denominator (赞：0)

# 「P6587 超超的序列 加强」题解

## Part \#0 一个 ~~侮辱你智商~~ 的故事

本来有一个很长的故事，但是审核前 $\dfrac{1}{114514}\rm s$ 被删掉了，只留下了一句话：这题 **不用 01 Trie 可做**。

## Part \#1 原问题规约到区间加区间求和

我们想要求一个数列，对于所有 $x$，关于 $2^x$ 同余的位置都在一起。

比如说，$n=7$ 时，一个可行的排列顺序如下：

```plain
4 2 6 1 5 3 7
```

那么：

1. 若 $p \equiv 0 \pmod {2^0}$，则转换后 $p$ 处于 $[1,7]$ 中；
1. 若 $p \equiv 0 \pmod {2^1}$，则转换后 $p$ 处于 $[1,3]$ 中；
1. 若 $p \equiv 1 \pmod {2^1}$，则转换后 $p$ 处于 $[4,7]$ 中；
1. 若 $p \equiv 0 \pmod {2^2}$，则转换后 $p$ 处于 $[1,1]$ 中；
1. 若 $p \equiv 1 \pmod {2^2}$，则转换后 $p$ 处于 $[4,5]$ 中；
1. 若 $p \equiv 2 \pmod {2^2}$，则转换后 $p$ 处于 $[2,3]$ 中；
1. 若 $p \equiv 3 \pmod {2^2}$，则转换后 $p$ 处于 $[6,7]$ 中；
1. 若 $p \equiv 1 \pmod {2^3}$，则转换后 $p$ 处于 $[4,4]$ 中；
1. 若 $p \equiv 2 \pmod {2^3}$，则转换后 $p$ 处于 $[2,2]$ 中；
1. 若 $p \equiv 3 \pmod {2^3}$，则转换后 $p$ 处于 $[6,6]$ 中；
1. 若 $p \equiv 4 \pmod {2^3}$，则转换后 $p$ 处于 $[1,1]$ 中；
1. 若 $p \equiv 5 \pmod {2^3}$，则转换后 $p$ 处于 $[5,5]$ 中；
1. 若 $p \equiv 6 \pmod {2^3}$，则转换后 $p$ 处于 $[3,3]$ 中；
1. 若 $p \equiv 7 \pmod {2^3}$，则转换后 $p$ 处于 $[7,7]$ 中；

可以发现，除了这 14 中情况外，其他情况均没有数在 $[1,7]$ 范围内，所以这个排列给了我们一点希望。

仔细看看它是怎么生成的吧。下面是它生成的方式：

![](https://cdn.luogu.com.cn/upload/image_hosting/atn6mtcl.png)

_（图片使用 ${\rm Ti}k{\rm Z}$ 渲染，[source code](https://www.luogu.com.cn/paste/6sflq7fw)）_

定睛一看，呀这不是个倒着的 Trie 嘛。

但是我们可以通过两边 dfs 来求出每个索引的新位置如下：

第一遍，求出每个区间包含最底层元素（叶节点）大小，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/nuuouzv6.png)

_（本来是要用 ${\rm Ti}k{\rm Z}$ 再生成一遍的，但是我懒了，直接使用了画图）_

第二遍，根据所得的大小，将数放在指定的位置，并记录每一对 $(x, y)$ 的左右端点信息 $L_{x,y}$ 和 $R_{x,y}$。

比如说，因为

> 7. 若 $p \equiv 3 \pmod {2^2}$，则转换后 $p$ 处于 $[6,7]$ 中；

所以记录 $L_{2,3}=6$ 和 $R_{2,3}=7$。注意下面代码中的 `l[i][j]` 相当于 $L_{j,i}$，`r` 与 $R$ 同理~~（因为我习惯大编号放前面，即使我知道 cache 那套理论）~~。

代码在下面，时复 $\mathcal O(n\log n)-\mathcal O(\log n)$，喜提最裂解（其实并没有）：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1000010, LOGN = 100;
int n, q, h = 20, p[N], tot[N][LOGN], l[N][LOGN], r[N][LOGN];
ll a[N], lastans;
int dfs1 (int val, int x) {
	if (val > n) {
		return 0;
	}
	if (x == h) {
		return tot[val][x] = 1;
	}
	return tot[val][x] = dfs1 (val, x + 1) + dfs1 ((1 << x) | val, x + 1);
}
void dfs2 (int cl, int val, int x) {
	if (val > n) {
		return ;
	}
	l[val][x] = cl - 1;
	r[val][x] = cl + tot[val][x] - 2;
	if (tot[val][x] == 1) {
		p[val] = cl - 1;
		return ;
	}
	if (l[val][x] == 0) {
		l[val][x]++;
	}
	dfs2 (cl, val, x + 1);
	dfs2 (cl + tot[val][x + 1], (1 << x) | val, x + 1);
}
namespace segtree {
	ll val[N << 2], tag[N << 2];
	void pushdown (int p, int l, int r) {
		int mid = (l + r) >> 1;
		if (tag[p]) {
			tag[p << 1] += tag[p];
			tag[p << 1 | 1] += tag[p];
			val[p << 1] += tag[p] * (mid - l + 1);
			val[p << 1 | 1] += tag[p] * (r - mid);
			tag[p] = 0;
		}
	}
	void pushup (int p) {
		val[p] = val[p << 1] + val[p << 1 | 1];
	}
	void build (int p, int l, int r) {
		if (l == r) {
			val[p] = a[l];
			return ;
		}
		int mid = (l + r) >> 1;
		build (p << 1, l, mid);
		build (p << 1 | 1, mid + 1, r);
		pushup (p);
	}
	void modify (int p, int l, int r, int ql, int qr, ll qv) {
		if (ql <= l && r <= qr) {
			tag[p] += qv;
			val[p] += qv * (r - l + 1);
			return ;
		}
		pushdown (p, l, r);
		int mid = (l + r) >> 1;
		if (ql <= mid) {
			modify (p << 1, l, mid, ql, qr, qv);
		}
		if (qr > mid) {
			modify (p << 1 | 1, mid + 1, r, ql, qr, qv);
		}
		pushup (p);
	}
	ll query (int p, int l, int r, int ql, int qr) {
		if (ql <= l && r <= qr) {
			return val[p];
		}
		pushdown (p, l, r);
		int mid = (l + r) >> 1;
		ll ans = 0;
		if (ql <= mid) {
			ans += query (p << 1, l, mid, ql, qr);
		}
		if (qr > mid) {
			ans += query (p << 1 | 1, mid + 1, r, ql, qr);
		}
		return ans;
	}
}
int main () {
	scanf ("%d%d", &n, &q);
	dfs1 (0, 0);
	dfs2 (1, 0, 0);
	for (int i = 1; i <= n; i++) {
		int x;
		scanf ("%d", &x);
		a[p[i]] = x;
	}
	segtree::build (1, 1, n);
	while (q --> 0) {
		int op, x, y;
		ll v;
		scanf ("%d%d%d", &op, &x, &y);
		op = (op + lastans) % 2 + 1;
		if (op == 1) {
			scanf ("%lld", &v);
		}
		y %= (1 << x);
		int ql, qr;
		if (y > n || r[y][x] == 0) {
			if (y <= n && y >= 1) {
				ql = qr = p[y];
			} else {
				if (op == 2) {
					lastans = 0;
					puts ("0");
				}
				continue;
			}
		} else {
			ql = l[y][x];
			qr = r[y][x];
		}
		if (op == 1) {
			segtree::modify (1, 1, n, ql, qr, v);
		} else {
			lastans = segtree::query (1, 1, n, ql, qr);
			printf ("%lld\n", lastans);
		}
	}
	return 0;
}
```

其实，这东西还有一种生成方式。

| 按顺序排好的 $\bm{p_i}$ | $\bm{p_i}$ 的二进制形式 | $\bm{q_i}$ 的二进制形式 | 按要求排好的 $\bm{q_i}$ |
| :----------: | :----------: | :----------: | :----------: |
| 1 | 001 | 100 | 4 |
| 2 | 010 | 010 | 2 |
| 3 | 011 | 110 | 6 |
| 4 | 100 | 001 | 1 |
| 5 | 101 | 101 | 5 |
| 6 | 110 | 011 | 3 |
| 7 | 111 | 111 | 7 |

观察最后一列，正好是最开始的序列！！！

观察中间两列，正好是相反的！！！

但是，它却不一直成立。比如 $n=5$ 时，生成的是前五行（$4,2,6,1,5$），显然 $6$ 超出了范围，而 $3$ 不包含在内。

我们需要：
1. 找到一个最小的 $k$ 使 $n\leq 2^k-1$；
2. 将 $1\sim2^k-1$ 中每个数的二进制位反转，得到新数列，同时初步搞出 $L,R$ 数组；
3. 筛选数列中处于 $1\sim n$ 范围的数，并将 $L,R$ 数组调整；

没实现，所以没有代码。

---


# 『JROI-1』  向量

## 题目背景

前言：虽然 SCR 已经并入了 JROI，但作为 JROI 的负责人，我还是想要感谢一下 SCR 出题组的**无私**奉献。出于对出题人的敬意。我们不会在题目背景故事上做大的改动，只会添加**小部分上下衔接**的语句。

--------------

蒟蒻火锅正在煮，自然要打一盘游戏了。

小 L 是个喜欢打第五的初中生。这天他刚自学完了向量的基本运算，正在打第五时，他看着自己画出来的长短、方向各异的机关墙（他在玩疯眼），有了一个奇妙的想法。

## 题目描述

小 L 有 $n$ 个向量 $\overrightarrow{a_1},\overrightarrow{a_2}\ldots\overrightarrow{a_n}$，他希望你能够帮他回答下面两个问题。

+ 对于给定的 $l,r$，求出 

$$\sum\limits_{i=l}^{r-1}\sum\limits_{j=i+1}^{r}\overrightarrow{a_i}\cdot\overrightarrow{a_j}$$


+ 对于给定的 $l,r$，求出 

$$\sum\limits_{i=l}^{r-1}\sum\limits_{j=i+1}^{r}\overrightarrow{a_i}\oplus\overrightarrow{a_j}$$

随着时间的推移，这些向量也会不断发生变化，小 L 希望你在发生变化后仍然能给出答案。

## 说明/提示

#### 样例 1 解释

前两次操作后三个向量分别为 $(4,7),(4,5),(-2,4)$，之后询问结果为 $4 \times(-2)+5\times4=12$。

下一次操作后三个向量分别为 $(4,7),(12,15),(-2,4)$，询问结果为 $(4\times15-7\times12)+[4\times4-7\times(-2)]+[12\times4-15\times(-2)]=-24+30+78=84$

-----------
#### 数据规模与约定
**本题采用捆绑测试**。
+ Subtask 1 ( $20\%$ )：$n,m\leq 100$。
+ Subtask 2 ( $30\%$ )：没有操作五。
+ Subtask 3 ( $50\%$ )：无特殊要求。

对于 $100\%$ 的数据，$2\leq n\leq 10^5$，$1\leq m\leq 10^5$，**保证对于任意时刻的向量 $\overrightarrow{a_i}$，满足 $-1000\leq x_i,y_i\leq 1000$**。

-----------
#### 关于向量运算

对于向量 $\overrightarrow{a},\overrightarrow{b}$ 和常数 $\lambda$，假定 $\overrightarrow{a},\overrightarrow{b}$ 的坐标表示分别为 $(x_a,y_a),(x_b,y_b)$：

+ $\overrightarrow{a}+\overrightarrow{b}=(x_a+x_b,y_a+y_b)$  
+ $\overrightarrow{a}-\overrightarrow{b}=(x_a-x_b,y_a-y_b)$  
+ $\lambda\overrightarrow{a}=(\lambda x_a,\lambda y_a)$  
+ $\overrightarrow{a}\cdot\overrightarrow{b}=x_ax_b+y_ay_b$  
+ $\overrightarrow{a}\oplus\overrightarrow{b}=x_ay_b-x_by_a$  

## 样例 #1

### 输入

```
3 5
1 1
4 5
1 4
1 1 3 6
2 3 3 0
4 2 3
3 2 3
5 1 3```

### 输出

```
12
84```

# 题解

## 作者：littleKtian (赞：6)

### update on 6.1

增加了一种更简单的方法，感谢@oswin 在私信中为我提供灵感。

------------


### 完成这题你首先要知道的：

+ 线段树
+ 向量的基本运算

-----------------------

### Subtask 1：

直接暴力即可。

~~你看出题人多良心还给你20分暴力分。~~

-------------------

### Subtask 2：

因为向量的点乘（$\vec{a}\cdot\vec{b}$）满足下面两条性质：

+ 交换律 $\vec{a}\cdot\vec{b}=\vec{b}\cdot\vec{a}$
+ 分配律 $(\vec{a}+\vec{b})\cdot\vec{c}=\vec{a}\cdot\vec{c}+\vec{b}\cdot\vec{c}$

（上面两条可以自行拆开证明，不想证的可以自行百度）

记 $\vec{b_{i,j}}$ 为第 $i$ 个向量到第 $j$ 个向量之和。

所以 $\sum\limits_{i=l}^{r-1}\sum\limits_{j=i+1}^{r}\overrightarrow{a_i}\cdot\overrightarrow{a_j}=\dfrac{\overrightarrow{b_{l,r}}\cdot\overrightarrow{b_{l,r}}-\sum\limits_{i=l}^r\overrightarrow{a_i}\cdot\overrightarrow{a_i}}{2}$

于是就变成线段树裸题了（单点修改，区间查询）。

---------------------

### Subtask 3：

有了 Subtask 2 的经验，我们肯定会想用同样的方式解决 $\vec{a}\oplus\vec{b}$。

然而很不幸，它虽然满足分配律，但并不满足交换律（实际上 $\vec{a}\oplus\vec{b}=-\vec{b}\oplus\vec{a}$），所以并不能用同样的方式求得答案。

因为 $\oplus$ 运算满足分配律，所以

$\sum\limits_{i=l}^{r-1}\sum\limits_{j=i+1}^{r}\overrightarrow{a_i}\oplus\overrightarrow{a_j}=\sum\limits_{i=l}^r(\overrightarrow{b_{1,i-1}}-\overrightarrow{b_{1,l-1}})\oplus\overrightarrow{a_i}=\sum\limits_{i=l}^r\overrightarrow{b_{1,i-1}}\oplus\overrightarrow{a_i}-\overrightarrow{b_{1,l-1}}\oplus\overrightarrow{b_{l,r}}$

$\overrightarrow{b_{1,l-1}}\oplus\overrightarrow{b_{l,r}}$ 容易用线段树维护，$\overrightarrow{b_{1,i-1}}\oplus\overrightarrow{a_i}$ 可以在线段树单点修改的同时进行区间修改来维护。

时间复杂度 $O((n+m)\log n)$

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ls(w) w<<1
#define rs(w) (w<<1)^1
using namespace std;
struct xds{
	int l,r,len;
	ll x,y,f;
	//x,y分别表示区间内所有向量的x,y总和,f表示所有的x的平方和y的平方的总和
	ll qx,qy,xy,yx,bjx,bjy;
	//qx,qy分别表示区间内所有的前缀和之和
	//bjx和bjy为标记
	//因为直接维护叉积不好维护，所以将叉积分为两部分(变量xy和yx)维护，相减即可得到结果
};//看不懂定义的建议转到初始化函数辅助了解各变量用处
xds tree[400005];
ll x[100005],y[100005],qx[100005],qy[100005];
int n,m;
ll dr()
{
	ll xx=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')xx=(xx<<1)+(xx<<3)+ch-'0',ch=getchar();
	return xx*f;
}
void u(int w)//信息上传
{
	tree[w].x=tree[ls(w)].x+tree[rs(w)].x,tree[w].y=tree[ls(w)].y+tree[rs(w)].y,tree[w].f=tree[ls(w)].f+tree[rs(w)].f;
	tree[w].xy=tree[ls(w)].xy+tree[rs(w)].xy,tree[w].yx=tree[ls(w)].yx+tree[rs(w)].yx;
	tree[w].qx=tree[ls(w)].qx+tree[rs(w)].qx,tree[w].qy=tree[ls(w)].qy+tree[rs(w)].qy;
}
void d(int w)//标记下传
{//有亿点点压行但实际上一行内修改的东西都是类似的
	tree[ls(w)].xy+=tree[w].bjx*tree[ls(w)].y,tree[ls(w)].yx+=tree[w].bjy*tree[ls(w)].x,tree[rs(w)].xy+=tree[w].bjx*tree[rs(w)].y,tree[rs(w)].yx+=tree[w].bjy*tree[rs(w)].x;
	//xy和yx的修改需要借助x和y的具体数值
	tree[ls(w)].qx+=tree[w].bjx*tree[ls(w)].len,tree[ls(w)].qy+=tree[w].bjy*tree[ls(w)].len,tree[rs(w)].qx+=tree[w].bjx*tree[rs(w)].len,tree[rs(w)].qy+=tree[w].bjy*tree[rs(w)].len;
	tree[ls(w)].bjx+=tree[w].bjx,tree[ls(w)].bjy+=tree[w].bjy,tree[rs(w)].bjx+=tree[w].bjx,tree[rs(w)].bjy+=tree[w].bjy;
	tree[w].bjx=0,tree[w].bjy=0;
}
void csh(int w,int l,int r)//初始化
{//讲道理看这部分更容易理解各变量的用处
	tree[w].l=l,tree[w].r=r,tree[w].len=r-l+1;
	if(l==r)
	{
		tree[w].x=x[l],tree[w].y=y[l],tree[w].f=x[l]*x[l]+y[l]*y[l],tree[w].qx=qx[l-1],tree[w].qy=qy[l-1];
		tree[w].xy=qx[l-1]*y[l],tree[w].yx=qy[l-1]*x[l];
		return;
	}
	int mid=(l+r)>>1;
	csh(ls(w),l,mid),csh(rs(w),mid+1,r),u(w); 
}
void xg_1(int w,int xh,ll a,ll b)//单点修改
{
	if(tree[w].l==tree[w].r)
	{//维护qx和qy时为了进行单点修改时便于计算xy和yx
		tree[w].x+=a,tree[w].y+=b,tree[w].f=tree[w].x*tree[w].x+tree[w].y*tree[w].y;
		tree[w].xy+=tree[w].qx*b,tree[w].yx+=tree[w].qy*a;
		return;
	}
	d(w);
	int mid=(tree[w].l+tree[w].r)>>1;
	if(xh<=mid)xg_1(ls(w),xh,a,b);else xg_1(rs(w),xh,a,b);
	u(w);
}
void xg_2(int w,int l,int r,ll a,ll b)//区间修改
{
	if(l>r)return;
	if(l<=tree[w].l&&tree[w].r<=r)
	{
		tree[w].xy+=a*tree[w].y,tree[w].yx+=b*tree[w].x,tree[w].qx+=tree[w].len*a,tree[w].qy+=tree[w].len*b;
		tree[w].bjx+=a,tree[w].bjy+=b;
		return;
	}
	d(w);
	int mid=(tree[w].l+tree[w].r)>>1;
	if(l<=mid)xg_2(ls(w),l,r,a,b);
	if(mid<r)xg_2(rs(w),l,r,a,b);
	u(w);
}
ll cx_1(int w,int l,int r)//查区间x总和
{
	if(l>r)return 0;
	if(l<=tree[w].l&&tree[w].r<=r)return tree[w].x;
	d(w);
	int mid=(tree[w].l+tree[w].r)>>1;ll x=0;
	if(l<=mid)x+=cx_1(ls(w),l,r);
	if(mid<r)x+=cx_1(rs(w),l,r);
	return x;
}
ll cx_2(int w,int l,int r)//与cx_1类似，查y
{
	if(l>r)return 0;
	if(l<=tree[w].l&&tree[w].r<=r)return tree[w].y;
	d(w);
	int mid=(tree[w].l+tree[w].r)>>1;ll x=0;
	if(l<=mid)x+=cx_2(ls(w),l,r);
	if(mid<r)x+=cx_2(rs(w),l,r);
	return x;
}
ll cx_3(int w,int l,int r)//类似，查f
{
	if(l>r)return 0;
	if(l<=tree[w].l&&tree[w].r<=r)return tree[w].f;
	d(w);
	int mid=(tree[w].l+tree[w].r)>>1;ll x=0;
	if(l<=mid)x+=cx_3(ls(w),l,r);
	if(mid<r)x+=cx_3(rs(w),l,r);
	return x;
}
ll cx_4(int w,int l,int r)//类似，查xy-yx
{
	if(l>r)return 0;
	if(l<=tree[w].l&&tree[w].r<=r)return tree[w].xy-tree[w].yx;
	d(w);
	int mid=(tree[w].l+tree[w].r)>>1;ll x=0;
	if(l<=mid)x+=cx_4(ls(w),l,r);
	if(mid<r)x+=cx_4(rs(w),l,r);
	return x;
}
int main()
{
	n=dr(),m=dr();
	for(int i=1;i<=n;i++)x[i]=dr(),y[i]=dr(),qx[i]=qx[i-1]+x[i],qy[i]=qy[i-1]+y[i];
	csh(1,1,n);
	while(m--)
	{
		int opt=dr();
		if(opt==1)
		{
			int i=dr();ll a=dr(),b=dr();
			xg_1(1,i,a,b),xg_2(1,i+1,n,a,b),x[i]+=a,y[i]+=b;
		}
		if(opt==2)
		{
			int i=dr();ll a=dr(),b=dr();
			xg_1(1,i,-a,-b),xg_2(1,i+1,n,-a,-b),x[i]-=a,y[i]-=b;
		}
		if(opt==3)//因为直接乘不好维护，所以转化为加
		{
			int i=dr();ll a=dr(),c=x[i]*(a-1),d=y[i]*(a-1);
			xg_1(1,i,c,d),xg_2(1,i+1,n,c,d),x[i]+=c,y[i]+=d;
		}
		if(opt==4)
		{
			int l=dr(),r=dr();ll xx=cx_1(1,l,r),yy=cx_2(1,l,r);
			printf("%lld\n",(xx*xx+yy*yy-cx_3(1,l,r))>>1);
		}
		if(opt==5)
		{
			int l=dr(),r=dr();
			printf("%lld\n",cx_4(1,l,r)-cx_1(1,1,l-1)*cx_2(1,l,r)+cx_1(1,l,r)*cx_2(1,1,l-1));
		}
	}
}
```

------------
### update on 6.1

其实出题人第二种运算做麻烦了。

假设 $q$ 表示线段树当前节点 $\sum\limits_{i=l}^{r-1}\sum\limits_{j=i+1}^{r}\overrightarrow{a_i}\oplus\overrightarrow{a_j}$ 的结果，可以直接这样维护：

```cpp
tree[w].q=tree[ls(w)].q+tree[rs(w)].q+tree[ls(w)].x*tree[rs(w)].y-tree[rs(w)].x*tree[ls(w)].y
```

这条式子会更方便理解一些。

---

## 作者：HHZZLL (赞：4)

显然这题可以用线段树维护。

那么对于前 $3$ 个操作，即是单点修改，较为简单。

思考一下 $4,5$ 操作怎么做。也就是左右两儿子的信息怎么合并。

假设可以直接维护 $4,5$ 操作所要的答案，其实是可以维护的。

记为 $s_1,s_2$。

考虑现在左右儿子贡献为：

左区间对应 $[l,mid]$，右区间对应 $(mid,r]$。

操作 $4:$
$$
    \text{LSON}:\sum_{i=l}^{mid-1}\sum_{j=i+1}^{mid}\overrightarrow{a_i}\cdot\overrightarrow{a_j}=[x_l(x_{l+1}+x_{l+2}+\cdots+x_{mid-1}+x_{mid})+x_{l+1}(x_{l+2}+x_{l+3}+\cdots+x_{mid-1}+x_{mid})+\cdots+x_{mid-1}\times x_{mid}+x_{mid}\times 0]
    +
    [y_l(y_{l+1}+y_{l+2}+\cdots+y_{mid-1}+y_{mid})+y_{l+1}(y_{l+2}+y_{l+3}+\cdots+y_{mid-1}+y_{mid})+\cdots+y_{mid-1}\times y_{mid}+y_{mid}\times 0]
$$

$$
\text{RSON}:\sum_{i=mid+1}^{r-1}\sum_{j=i+1}^{r}\overrightarrow{a_i}\cdot\overrightarrow{a_j}=[x_{mid+1}(x_{mid+2}+x_{mid+3}+\cdots+x_{r-1}+x_r)+x_{mid+2}(x_{mid+3}+x_{mid+4}+\cdots+x_{r-1}+x_r)+\cdots+x_{r-1}\times x_{r}]+[y_{mid+1}(y_{mid+2}+y_{mid+3}+\cdots+y_{r-1}+y_r)+y_{mid+2}(y_{mid+3}+y_{mid+4}+\cdots+y_{r-1}+y_r)+\cdots+y_{r-1}\times y_{r}]
$$

当你合并他们时，是 $x$ 加它所对应的部分，$y$ 也同理。

所以我们考虑清楚一个那另一个也会了。这里我们考虑 $x$。

左儿子区间的点 $i$ 需要加 $x_i(x_{mid+1}+x_{mid+2}+\cdots+x_{r-1}+x_r)(i\in[l,mid])$，再根据乘法结合律，所以就是 $s_1 = s_{1_{RS}}+s_{1_{LS}} + \sum_{i=l}^{mid}x_i \times \sum_{i=mid+1}^r x_i$。

发现还需要用到区间 $x,y$ 和，顺便维护。

操作 $5:$
$$
    \text{LSON}:\sum\limits_{i=l}^{mid-1}\sum\limits_{j=i+1}^{mid}\overrightarrow{a_i}\oplus\overrightarrow{a_j}=[x_l(y_{l+1}+y_{l+2}+\cdots+y_{mid-1}+y_{mid})+x_{l+1}(y_{l+2}+y_{l+3}+\cdots+y_{mid-1}+y_{mid})+\cdots+x_{mid-1}\times y_{mid}+x_{mid}\times 0]+[-y_l(x_{l+1}+x_{l+2}+\cdots+x_{mid-1}+x_{mid})-y_{l+1}(x_{l+2}+x_{l+3}+\cdots+x_{mid-1}+x_{mid})-\cdots-y_{mid-1}\times x_{mid}-y_{mid}\times 0]
$$

$$
    \text{RSON}:\sum\limits_{i=mid+1}^{r-1}\sum\limits_{j=i+1}^{r}\overrightarrow{a_i}\oplus\overrightarrow{a_j}=[x_{mid+1}(y_{mid+2}+y_{mid+3}+\cdots+y_{r-1}+y_{r})+x_{mid+2}(y_{mid+3}+y_{mid+4}+\cdots+y_{r-1}+y_{r})+\cdots+x_{r-1}\times y_{r}]+[-y_{mid+1}(x_{mid+2}+x_{mid+3}+\cdots+x_{r-1}+x_{r})-y_{mid+2}(x_{mid+3}+x_{mid+4}+\cdots+x_{r-1}+x_{r})-\cdots-y_{r-1}\times x_{r}]
$$

由于前面已经维护了 $x,y$ 和。

这里记作 $sX,sY$。

对于 $x$，那么 $i$ 加上 $x_i(y_{mid+1}+y_{mid+2}+\cdots+y_{r-1}+y_{r})(i\in[l,mid])$，$y$ 也同理，只不过前面有负号。

所以，$s_2=s_{2_{RS}}+s_{2_{LS}}+sX_{LS}\times sY_{RS}-sY_{LS}\times sX_{RS}$。

现在我们就完成了合并。

在求解答案时，应是找到完全相等区间，再用上述步骤合并。

### AC CODE:
```cpp
#include <bits/stdc++.h>
#define int long long
namespace My {
    #define X first
    #define Y second
    #define vec vector
    #define p_b push_back
    #define rep(i, a, b) for(int i = a; i <= b; i++)
    #define lop(i, b, a) for(int i = b; i >= a; i--)
} using namespace My;
const int N = 1e5 + 5;
int n, m;
struct Vector {
	int x, y;
	Vector operator * (int lambda) {
		return {lambda * x, lambda * y};
	}
	friend Vector operator + (const Vector &a, const Vector &b) {
		return {a.x + b.x, a.y + b.y};
	}
	friend Vector operator - (const Vector &a, const Vector &b) {
		return {a.x - b.x, a.y - b.y};
	}
	friend int operator * (const Vector &a, const Vector &b) {
		return a.x * b.x + a.y * b.y;
	}
	friend int operator ^ (const Vector &a, const Vector &b) {
		return a.x * b.y - b.x * a.y;
	}
} c[N];
namespace SegmentTree {
#define ls k << 1
#define rs k << 1 | 1
	struct State {
		int l, r;
		int sX, sY;
		int sum1, sum2;
		bool operator ! () const {
			return !l && !r && !sX && !sY && !sum1 && !sum2;
		}
		friend State operator + (const State &Ls, const State &Rs) { // 合并
			State up;
			up.l = Ls.l, up.r = Rs.r;
			up.sX = Ls.sX + Rs.sX;
			up.sY = Ls.sY + Rs.sY;
			up.sum1 = Ls.sum1 + Rs.sum1 + Rs.sX * Ls.sX + Rs.sY * Ls.sY;
			up.sum2 = Ls.sum2 + Rs.sum2 + Rs.sY * Ls.sX - Rs.sX * Ls.sY;
			return up;
		}
	} tr[N << 2], ans;
	void pushup(int k) {
		tr[k] = tr[ls] + tr[rs];
	}
	void build(int k, int l, int r) {
		tr[k].l = l, tr[k].r = r;
		if(l == r) {
			tr[k].sX = c[l].x, tr[k].sY = c[l].y; // 一个单点是一个向量
			return;
		}
		build(ls, l, (l + r) / 2), build(rs, (l + r) / 2 + 1, r);
		pushup(k);
	}
#define l tr[k].l
#define r tr[k].r
#define mid (l + r) / 2
	void alter(int k, int p, Vector v, int op) {
		if(l == r && l == r) {
			c[l] = (op == -1 ? c[l] - v : c[l] + v);
			tr[k].sX += op * v.x, tr[k].sY += op * v.y;
			return;
		}
		p <= mid ? alter(ls, p, v, op) : alter(rs, p, v, op);
		pushup(k);
	}
	void cover(int k, int p, int lambda) {
		if(l == r && l == p) {
			c[l] = c[l] * lambda;
			tr[k].sX *= lambda, tr[k].sY *= lambda;
			return;
		}
		p <= mid ? cover(ls, p, lambda) : cover(rs, p, lambda);
		pushup(k);
	}
	void query(int k, int x, int y) {
		if(x == l && r == y) { // 完全相等区间
			if(!ans) ans = tr[k];
			else ans = ans + tr[k];
			return;
		}
		if(y <= mid) query(ls, x, y);
		else if(x > mid) query(rs, x, y);
		else query(ls, x, mid), query(rs, mid + 1, y);
	}
#undef l
#undef r
} using namespace SegmentTree;
signed main() {
	rd(n, m);
	rep(i, 1, n) c[i] = {rd(), rd()};
	build(1, 1, n);
	for(int op, i, x, y; m--;) {
		rd(op);
		if(op <= 2) {
			rd(i, x, y);
			alter(1, i, (Vector){x, y}, op == 1 ? 1 : -1);
		}
		else if(op == 3) {
			rd(i, x);
			cover(1, i, x);
		}
		else {
			rd(x, y), ans = {0, 0, 0, 0, 0, 0};
			query(1, x, y);
			wr(op == 4 ? ans.sum1 : ans.sum2, '\n');
		}
	}
    return 0;
}
```

---

## 作者：kbtyyds (赞：3)

# P6588 题解

建议在[博客](https://www.luogu.com.cn/blog/453059/solution-p6588)里食用：

[题目链接](https://www.luogu.com.cn/problem/P6588)

## 题目描述

小 L 有 $n$ 个向量 $\overrightarrow{a_1}, \overrightarrow{a_2}, \dots, \overrightarrow{a_n}$，他希望你能够帮他回答下面两个问题。

+ 对于给定的 $l,r$，求出 

$$\sum\limits_{i=l}^{r-1}\sum\limits_{j=i+1}^{r}\overrightarrow{a_i}\cdot\overrightarrow{a_j}$$


+ 对于给定的 $l,r$，求出 

$$\sum\limits_{i=l}^{r-1}\sum\limits_{j=i+1}^{r}\overrightarrow{a_i}\oplus\overrightarrow{a_j}$$


一共有下面五种操作。

1. 输入三个整数 $i,x,y(1\leq i\leq n)$，将 $\overrightarrow{a_i}$ 加上 $(x,y)$。
1. 输入三个整数 $i,x,y(1\leq i\leq n)$，将 $\overrightarrow{a_i}$ 减去 $(x,y)$。
1. 输入两个整数 $i,t(1\leq i\leq n)$，将 $\overrightarrow{a_i}$ 修改为 $t\overrightarrow{a_i}$。
1. 输入两个整数 $l,r(1\leq l<r\leq n)$，求 $\sum\limits_{i=l}^{r-1}\sum\limits_{j=i+1}^{r}\overrightarrow{a_i}\cdot\overrightarrow{a_j}$。
1. 输入两个整数 $l,r(1\leq l<r\leq n)$，求 $\sum\limits_{i=l}^{r-1}\sum\limits_{j=i+1}^{r}\overrightarrow{a_i}\oplus\overrightarrow{a_j}$。

---

## 1.分析

对于 1, 2, 3 操作，就是简单的单点修改，直接维护即可。

而对于 4, 5 操作，我们可以考虑推式子，看看一共要维护哪些信息：

## 2.推导

### 操作4：

记 $mid=\dfrac{l+r}{2}$，$cdots_{l,r}=\sum\limits_{i=l}^{r-1}\sum\limits_{j=i+1}^r\overrightarrow{a_i}\cdot\overrightarrow{a_j}$，那么：

$$\begin{aligned}cdots_{l,r}&=\sum_{i=l}^{r-1}\sum_{j=i+1}^r\overrightarrow{a_i}\cdot\overrightarrow{a_j}\\&=\sum_{i=l}^{mid}\left(\sum_{j=i+1}^r\overrightarrow{a_i}\cdot\overrightarrow{a_j}\right)+\sum_{i=mid+1}^{r-1}\left(\sum_{j=i+1}^r\overrightarrow{a_i}\cdot\overrightarrow{a_j}\right)\\&=\sum_{i=l}^{mid}\left(\sum_{j=i+1}^{mid}\overrightarrow{a_i}\cdot\overrightarrow{a_j}+\sum_{j=mid+1}^r\overrightarrow{a_i}\cdot\overrightarrow{a_j}\right)+\sum_{i=mid+1}^{r-1}\left(\sum_{j=i+1}^r\overrightarrow{a_i}\cdot\overrightarrow{a_j}\right)\\&=\left(\sum_{i=l}^{mid-1}\sum_{j=i+1}^{mid}\overrightarrow{a_i}\cdot\overrightarrow{a_j}\right)+\left(\sum_{i=l}^{mid}\sum_{j=mid+1}^r\overrightarrow{a_i}\cdot\overrightarrow{a_j}\right)+\left(\sum_{i=mid+1}^{r-1}\sum_{j=i+1}^r\overrightarrow{a_i}\cdot\overrightarrow{a_j}\right)\\&=cdots_{l,mid}+\left(\sum_{i=l}^{mid}\sum_{j=mid+1}^rx_ix_j+y_iy_j\right)+cdots_{mid+1,r}\\&=cdots_{l,mid}+cdots_{mid+1,r}+\left(\sum_{i=l}^{mid}x_i\right)\left(\sum_{j=mid+1}^rx_j\right)+\left(\sum_{i=l}^{mid}y_i\right)\left(\sum_{j=mid+1}^ry_j\right)\end{aligned}$$

我们看到式子里只需要再维护 $sx_{l,r}=\sum\limits_{i=l}^rx_i$ 以及 $sy_{l,r}=\sum\limits_{i=l}^ry_i$ 即区间 $x$ 的和、区间 $y$ 的和即可。

总结：$cdots_{l,r}=cdots_{l,mid}+cdots_{mid+1,r}+sx_{l,mid}\cdot sx_{mid+1,r}+sy_{l,mid}\cdot sy_{mid+1,r}$

### 操作5：

同样地推式子：

记 $mid=\dfrac{l+r}{2}$，$times_{l,r}=\sum\limits_{i=l}^{r-1}\sum\limits_{j=i+1}^r\overrightarrow{a_i}\oplus\overrightarrow{a_j}$，那么：

$$\begin{aligned}times_{l,r}&=\sum_{i=l}^{r-1}\sum_{j=i+1}^r\overrightarrow{a_i}\oplus\overrightarrow{a_j}\\&=\sum_{i=l}^{mid}\left(\sum_{j=i+1}^r\overrightarrow{a_i}\oplus\overrightarrow{a_j}\right)+\sum_{i=mid+1}^{r-1}\left(\sum_{j=i+1}^r\overrightarrow{a_i}\oplus\overrightarrow{a_j}\right)\\&=\sum_{i=l}^{mid}\left(\sum_{j=i+1}^{mid}\overrightarrow{a_i}\oplus\overrightarrow{a_j}+\sum_{j=mid+1}^r\overrightarrow{a_i}\oplus\overrightarrow{a_j}\right)+\sum_{i=mid+1}^{r-1}\left(\sum_{j=i+1}^r\overrightarrow{a_i}\oplus\overrightarrow{a_j}\right)\\&=\left(\sum_{i=l}^{mid-1}\sum_{j=i+1}^{mid}\overrightarrow{a_i}\oplus\overrightarrow{a_j}\right)+\left(\sum_{i=l}^{mid}\sum_{j=mid+1}^r\overrightarrow{a_i}\oplus\overrightarrow{a_j}\right)+\left(\sum_{i=mid+1}^{r-1}\sum_{j=i+1}^r\overrightarrow{a_i}\oplus\overrightarrow{a_j}\right)\\&=times_{l,mid}+\left(\sum_{i=l}^{mid}\sum_{j=mid+1}^rx_iy_j-x_jy_i\right)+times_{mid+1,r}\\&=times_{l,mid}+times_{mid+1,r}+\left(\sum_{i=l}^{mid}x_i\right)\left(\sum_{j=mid+1}^ry_j\right)-\left(\sum_{i=mid+1}^rx_i\right)\left(\sum_{j=l}^{mid}y_j\right)\end{aligned}$$

同样只需再维护区间 $x$ 的和、区间 $y$ 的和即可。

总结：$times_{l,r}=times_{l,mid}+times_{mid+1,r}+sx_{l,mid}\cdot sy_{mid+1,r}-sx_{mid+1,r}\cdot sy_{l,mid}$

## 3.实现

用线段树+结构体，即每个节点存储的信息：

```cpp
struct node
{
	int x;//区间横坐标之和
	int y;//区间纵坐标之和
	int cdots;
	int times;
};
```

用我们推导出的式子，实现 `merge` 操作（合并区间）。

```cpp
inline node merge(node l,node r)
{
	node res;
	res.x=l.x+r.x;
	res.y=l.y+r.y;
	res.cdots=l.cdots+r.cdots+l.x*r.x+l.y*r.y;//4的结论
	res.times=l.times+r.times+l.x*r.y-l.y*r.x;//5的结论
	return res;
}
```

以及区间查询：

```cpp
inline node ask(int o,int l,int r,int ql,int qr)
{
    if(ql<=l&&r<=qr) return t[o];
    int mid=(l+r)>>1;
    if(ql<=mid&&qr>mid) return merge(ask(ls,l,mid,ql,qr),ask(rs,mid+1,r,ql,qr));//分两段的情况
    if(ql<=mid) return ask(ls,l,mid,ql,qr);
    else return ask(rs,mid+1,r,ql,qr);
}
```

## 4.代码

（一定记住要 `long long` ！！！）

```cpp
#include<iostream>
#include<cstdio>
#define S 100010
#define int long long
using namespace std;
inline int read()
{
	int f=1,x=0;
	char c=getchar();
	while(c!='-'&&(c<'0'||c>'9')) c=getchar();
	while(c=='-') f=-f,c=getchar();
	while('0'<=c&&c<='9')  x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return f*x;
}
int n,m;
int x[S],y[S];
struct node
{
	int x,y,cdots,times;//维护的信息
};
inline node merge(node l,node r)
{
	node res;
	res.x=l.x+r.x;
	res.y=l.y+r.y;
	res.cdots=l.cdots+r.cdots+l.x*r.x+l.y*r.y;
	res.times=l.times+r.times+l.x*r.y-l.y*r.x;
   //直接运用结论
	return res;
}
struct seg
{
	#define ls o<<1
	#define rs o<<1|1
	node t[S<<2];
	inline void pushup(int o)
	{
		t[o]=merge(t[ls],t[rs]);
	}
	inline void build(int o,int l,int r)
	{
		if(l==r)
		{
			t[o].x=x[l];
			t[o].y=y[l];
			return;
		}
		int mid=(l+r)>>1;
		build(ls,l,mid);
		build(rs,mid+1,r);
		pushup(o);
	}
	inline void updadd(int o,int l,int r,int d,int x,int y)
	{
		if(l==r) {t[o].x+=x;t[o].y+=y;return;}
		int mid=(l+r)>>1;
		if(d<=mid) updadd(ls,l,mid,d,x,y);
		else updadd(rs,mid+1,r,d,x,y);
		pushup(o);
	}
	inline void updmin(int o,int l,int r,int d,int x,int y)
	{
		if(l==r) {t[o].x-=x;t[o].y-=y;return;}
		int mid=(l+r)>>1;
		if(d<=mid) updmin(ls,l,mid,d,x,y);
		else updmin(rs,mid+1,r,d,x,y);
		pushup(o);
	}
	inline void updmul(int o,int l,int r,int d,int k)
	{
		if(l==r) {t[o].x*=k;t[o].y*=k;return;}
		int mid=(l+r)>>1;
		if(d<=mid) updmul(ls,l,mid,d,k);
		else updmul(rs,mid+1,r,d,k);
		pushup(o);
	}
	inline node ask(int o,int l,int r,int ql,int qr)
	{
		if(ql<=l&&r<=qr) return t[o];
		int mid=(l+r)>>1;
		if(ql<=mid&&qr>mid) return merge(ask(ls,l,mid,ql,qr),ask(rs,mid+1,r,ql,qr));
		if(ql<=mid) return ask(ls,l,mid,ql,qr);
		else return ask(rs,mid+1,r,ql,qr);
	}
}c;
signed main()
{
	n=read();m=read();
	for(int i=1;i<=n;i++) x[i]=read(),y[i]=read();
	c.build(1,1,n);
	while(m--)
	{
		int op=read(),x,y,k;
		if(op==1||op==2||op==3) k=read();
		x=read();
		if(op!=3) y=read();//读入部分
		if(op==1) c.updadd(1,1,n,k,x,y);
		if(op==2) c.updmin(1,1,n,k,x,y);
		if(op==3) c.updmul(1,1,n,k,x);
		if(op==4||op==5)
		{
			node res=c.ask(1,1,n,x,y);
			if(op==4) printf("%lld",res.cdots);
			if(op==5) printf("%lld",res.times);
			printf("\n");
		}//查询部分
	}
	return 0;
}

```


---

## 作者：HPXXZYY (赞：0)

$\color{blue}{\texttt{[Analysis]}}$

前三个操作都是线段树的基本操作，重点考虑第四和第五个操作。

$\text{Operation 4}$

因为点乘具有**交换律**和**分配律**，所以：

$$\sum\limits_{i=l}^{r-1}\sum\limits_{j=i+1}^{r}\overrightarrow{a_{i}} \cdot \overrightarrow{a_{j}}=\dfrac{\left ( \overrightarrow{s_{l,r}} \right )^{2}-\sum\limits_{i=l}^{r} \left ( \overrightarrow{a_{i}} \right )^{2}}{2}$$

其中：

$$s_{l,r}=\sum\limits_{i=l}^{r} \overrightarrow{a_{i}}$$

相当于把所有的向量都相乘一次，减去自己乘自己，再除以 $2$（因为 $\overrightarrow{a}$ 和 $\overrightarrow{b}$ 会相乘两次）。

$\text{Operation 5}$

很遗憾，叉乘没有交换律，只有分配律。

我们另辟蹊径，记：

$$\text{Cross}_{l,r}=\sum\limits_{i=1}^{r-1} \sum\limits_{j=i+1}^{r} \overrightarrow{a_{i}} \oplus \overrightarrow{a_{j}}$$

$$\text{Sx}_{l,r}=\sum\limits_{i=l}^{r}x_{i}$$

即 $\text{Sx}_{l,r}$ 为向量 $\overrightarrow{a_{l \cdots r}}$ 的横坐标的和，$\text{Sy}_{l,r}$ 类似，为纵坐标的和。

取 $\forall \text{mid} \quad \texttt{s.t.} \quad l < \text{mid} < r$，则：

$$\text{Cross}_{l,r}=\text{Cross}_{l,\text{mid}}+\text{Cross}_{\text{mid}+1,r}+\text{Sx}_{l,\text{mid}} \times \text{Sy}_{\text{mid}+1,r}-\text{Sy}_{l,\text{mid}} \times \text{Sx}_{\text{mid}+1,r}$$

根据这条性质，我们就可以用线段树维护了。

$\color{blue}{\texttt{[code]}}$

```cpp
typedef long long ll;
const int N=1e5+100,M=N<<2;

ll x[M],y[M],xs[M],ys[M],Cross[M];

pair<ll,ll> add(pair<ll,ll> a,pair<ll,ll> b){
	return make_pair(a.first+b.first,a.second+b.second);
}

inline void maintain(int o){
	xs[o]=x[o]*x[o];
	ys[o]=y[o]*y[o];
}//maintain the leaves

pair<int,int> a[N];

inline void pushup(int o){
	x[o]=x[o<<1]+x[o<<1|1];
	y[o]=y[o<<1]+y[o<<1|1];
	xs[o]=xs[o<<1]+xs[o<<1|1];
	ys[o]=ys[o<<1]+ys[o<<1|1];
	Cross[o]=Cross[o<<1]+Cross[o<<1|1]+x[o<<1]*y[o<<1|1]-y[o<<1]*x[o<<1|1];
}
void build(int o,int l,int r){
	if (l==r){
		x[o]=a[l].first;
		y[o]=a[r].second;
		maintain(o);
		return;
	}
	int mid=(l+r)>>1;
	build(o<<1,l,mid);
	build(o<<1|1,mid+1,r);
	pushup(o);return;
}
void modify(int o,int l,int r,int p,int vx,int vy){
	if (l==r){
		x[o]+=vx;y[o]+=vy;
		maintain(o);
		return;
	}
	int mid=(l+r)>>1;
	if (p<=mid) modify(o<<1,l,mid,p,vx,vy);
	else modify(o<<1|1,mid+1,r,p,vx,vy);
	pushup(o);return;
}//add or minus （操作 1,2）
void modify(int o,int l,int r,int p,int v){
	if (l==r){
		x[o]*=v;y[o]*=v;
		maintain(o);
		return;
	}
	int mid=(l+r)>>1;
	if (p<=mid) modify(o<<1,l,mid,p,v);
	else modify(o<<1|1,mid+1,r,p,v);
	pushup(o);return;
}//times （操作 3）
pair<ll,ll> query(int o,int l,int r,int p,int q){
	if (p<=l&&r<=q) return make_pair(x[o],y[o]);
	int mid=(l+r)>>1;
	pair<ll,ll> ret=make_pair(0ll,0ll);
	if (p<=mid) ret=add(ret,query(o<<1,l,mid,p,q));
	if (mid<q) ret=add(ret,query(o<<1|1,mid+1,r,p,q));
	return ret;
}//the sum of ai （求和）
ll Query(int o,int l,int r,int p,int q){
	if (p<=l&&r<=q) return xs[o]+ys[o];
	int mid=(l+r)>>1;ll ans=0;
	if (p<=mid) ans+=Query(o<<1,l,mid,p,q);
	if (mid<q) ans+=Query(o<<1|1,mid+1,r,p,q);
	return ans;
}//the sum of ai dot ai （点乘）
pair<ll,pair<ll,ll> > QUERY(int o,int l,int r,int p,int q){
	if (p<=l&&r<=q) return make_pair(Cross[o],make_pair(x[o],y[o]));
	int mid=(l+r)>>1;
	pair<ll,pair<ll,ll> > L,R;
	L=make_pair(0ll,make_pair(0ll,0ll));
	R=make_pair(0ll,make_pair(0ll,0ll));
	if (p<=mid) L=QUERY(o<<1,l,mid,p,q);
	if (mid<q) R=QUERY(o<<1|1,mid+1,r,p,q);
	ll ans=L.first+R.first+L.second.first*R.second.second-L.second.second*R.second.first;
	return make_pair(ans,make_pair(L.second.first+R.second.first,L.second.second+R.second.second));
}//the sum of ai cross ai （叉乘）

int n,m;

int main(){
	n=read();m=read();
	for(int i=1;i<=n;i++){
		int u=read(),v=read();
		a[i]=make_pair(u,v);
	}
	
	build(1,1,n);
	
	for(int i=1,opt,l,r,vx,vy;i<=m;i++){
		opt=read();l=read();
		if (opt==1){
			vx=read();vy=read();
			modify(1,1,n,l,vx,vy);
		}
		else if (opt==2){
			vx=read();vy=read();
			modify(1,1,n,l,-vx,-vy);
		}
		else if (opt==3){
			vx=read();
			modify(1,1,n,l,vx);
		}
		else if (opt==4){
			r=read();
			pair<ll,ll> tmp=query(1,1,n,l,r);
			ll Minus=Query(1,1,n,l,r);
			printf("%lld\n",(tmp.first*tmp.first+tmp.second*tmp.second-Minus)/2);
		}//别忘了除以 2
		else{
			r=read();
			pair<ll,pair<ll,ll> > ans=QUERY(1,1,n,l,r);
			printf("%lld\n",ans.first);
		}
	}
	
	return 0;
}
```

---


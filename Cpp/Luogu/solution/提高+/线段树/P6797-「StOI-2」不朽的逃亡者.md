# 「StOI-2」不朽的逃亡者

## 题目描述

巴尔博亚要逃遁到不朽的事业——发现太平洋。

现在巴尔博亚在一个矩阵的 $(1,1)$ 位置，太平洋在 $(n,m)$ ， $(i,j)$ 位置的危险值为 $d_i$$_j$ 。他现在抓到了 $k$ 个印第安人，第 $i$ 个人对 $[ax_i,ay_i]  [bx_i,by_i]$ 的**范围**（ 以 $(ax_i,ay_i)$ 为左上角坐标，以 $(bx_i,by_i)$ 为右下角坐标的矩形 ）有了解，如果带上这个人，这一范围不会有危险。

由于时间紧迫，巴尔博亚走四联通方向，必须只走 $n+m-1$ 个位置到达太平洋。

现在巴尔博亚希望最多带上的人数不超过 $w$ ，同时使危险值之和最小，求最小值。

## 说明/提示

## 样例解释

选择第二人。

路径：`(1,1)->(2,1)->(3,1)->(4,1)->(4,2)->(4,3)->(4,4)`

危险值: 没有受到保护的 `(4,3)`与`(4,4)` ，为 $2+1=3$。

## 数据范围

#### 本题采用捆绑测试。
子任务 $1$（$10$ 分）：$1 \leq n,m,k,w \leq 4$。   
子任务 $2$（$20$ 分） : $1 \leq n,m,k,w \leq 20$。  
子任务 $3$（$20$ 分）：$1 \leq n,m,k,w \leq 50$。  
子任务 $4$（$20$ 分）：所有 $d_{i,j}$ 均相同。  
子任务 $5$（$30$ 分） : 无特殊性质。 

对于所有数据：$1\leq n,m,k \leq 200$，$1 \leq w \leq 100$，$0 \leq d_{i,j} \leq 10^8$，$1 \leq ax_i \leq bx_i \leq n$ ，$1\leq ay_i \leq by_i \leq m$ 。


注意：输入顺序与题目略有不同

## 样例 #1

### 输入

```
4 4 3 1
1 2 3 3
3 2 1 4
2 1 3 3
3 4 2 1
3 4 2 4
1 4 1 2
1 2 2 4```

### 输出

```
3```

# 题解

## 作者：_•́へ•́╬_ (赞：9)

和std不同。剪枝后的分层图最短路。

## 思路

点 $(o,i,j)$ 表示已经拿了 $o$ 个人，现在我位置在 $(i,j)$，还没计算 $(i,j)$ 位置的危险值，已经走过的路上的危险值之和。

酱紫转移：

- 不吃 $d_{ij}$，找一个包含 $(i,j)$ 的矩形 $[ax,bx,ay,by]$，即满足 $ax\leq i\leq bx,ay\leq j\leq by$，然后转移到 $(bx+1,k) | j\leq k\leq by$ 和 $(k,by+1) | i\leq k\leq bx$。
- 吃了 $d_{ij}$，转移到 $(i+1,j)$ 和 $(i,j+1)$。

## 剪枝

先来一个卡常小玩意：按 $o$ 从小到大进行转移，当前 $o$ 维护堆，$o+1$ 维护一个 `vector`，`++o` 时再用 `vector` 构建堆。

最关键的剪枝来喽：

根据 dij 的特殊性质，同一个 $o$ 的危险值是不降的。而通过矩形转移的时候不吃 $d$，也就是说在 $o$ 优的到 $o+1$ 也优。这是剪枝可行的前提。

那么对于每个矩形，记录一下已经更新过的 $(bx+1,k)$ 和 $(k,by+1)$，后面遇到更劣的时候就不更新了。我的做法是记了两个 $k$ 更新到的最小位置值。

## 复杂度分析

有 $nm(w+1)$ 个点。

有至多 $(n+m)k(w+1)$ 条边。

算上堆，复杂度 $\mathcal O(nmw+(n+m)kw\log(n+m)k)$。

## code

```cpp
#include<stdio.h>
#include<queue>
#include<string.h>
#define N 201
#define M 101
using namespace std;
inline char nc()
{
	static char buf[99999],*l,*r;
	return l==r&&(r=(l=buf)+fread(buf,1,99999,stdin),l==r)?EOF:*l++;
}
inline void read(int&x)
{
	char c=nc();for(;c<'0'||'9'<c;c=nc());
	for(x=0;'0'<=c&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=nc());
}
struct node
{
	int i,j;long long ans;
	inline node(){}
	inline node(const int&a,const int&b,const long long&c)
		{i=a;j=b;ans=c;}
	inline bool operator<(const node&kkk)const{return ans>kkk.ans;}
};
int n,m,p,w,ax[N],bx[N],ay[N],by[N],ux[M][N],uy[M][N],a[N][N];
priority_queue<node>q;vector<node>qwq[M];
long long minn=1ll<<60,ans[M][N][N];
main()
{
	read(n);read(m);read(p);read(w);if(w>p)w=p;
	for(int i=0;i<n;++i)for(int j=0;j<m;read(a[i][j++]));
	for(int i=0;i<p;++i)
	{
		read(ax[i]);read(bx[i]);read(ay[i]);read(by[i]);
		--ax[i];--bx[i];--ay[i];--by[i];
		for(int j=0;j<=w;++j)ux[j][i]=bx[i],uy[j][i]=by[i];
	}
	memset(ans,0x3f,sizeof(ans));
	ans[0][0][0]=0;qwq[0].emplace_back(0,0,0);
	for(int o=0;o<=w;++o)
	{
		q=priority_queue<node>(qwq[o].begin(),qwq[o].end());
		for(node i;q.size();)
		{
			i=q.top();q.pop();
			if(minn<=i.ans)break;
			if(i.i+i.j>=n+m-1){minn=i.ans;break;}
			if(i.i==n||i.j==m)continue;
			if(o<w)for(int j=0;j<p;++j)if(ax[j]<=i.i&&i.i<=bx[j])
				if(ay[j]<=i.j&&i.j<=by[j])
			{
				for(int k=i.i;k<=ux[o][j];++k)
					if(ans[o+1][k][by[j]+1]>i.ans)
						qwq[o+1].emplace_back(k,by[j]+1,
							ans[o+1][k][by[j]+1]=i.ans);
				if(i.i<=ux[o][j])ux[o][j]=i.i-1;
				for(int k=i.j;k<=uy[o][j];++k)
					if(ans[o+1][bx[j]+1][k]>i.ans)
						qwq[o+1].emplace_back(bx[j]+1,k,
							ans[o+1][bx[j]+1][k]=i.ans);
				if(i.j<=uy[o][j])uy[o][j]=i.j-1;
			}
			i.ans+=a[i.i][i.j];
			if(ans[o][i.i+1][i.j]>i.ans)
				q.emplace(i.i+1,i.j,ans[o][i.i+1][i.j]=i.ans);
			if(ans[o][i.i][i.j+1]>i.ans)
				q.emplace(i.i,i.j+1,ans[o][i.i][i.j+1]=i.ans);
		}
	}
	printf("%lld",minn);
}
```


---

## 作者：K0stlin (赞：8)

## 官方题解


数据结构优化dp。

个人感觉不难。

设 $dp值$ ( $f_{i,j,k}$ ) 为第 $i$ 行第 $j$ 列，用了 $k$ 个矩阵能走到 $(n,m)$ 最小的和。

易得：在一个矩阵（下图黑色矩阵）中的一个格子（下图三角格子），可以走到与该矩阵相邻的格子中横坐标与纵坐标都不小于该格子的格子（用圆圈格子表示）。

![](https://cdn.luogu.com.cn/upload/image_hosting/cs55ez6u.png)

在从 $(n,m)$ 每一行中每一列，用了 $k$ 个矩阵的枚举dp中：

对于用了 $0$ ~ $K$ 个矩阵，每行每列分别建1个优先队列，记 $dp值$ 与最远矩阵影响范围。

对于每个矩阵，建两个 $minn$ 数组，分别记当前在矩阵下侧的“圆圈格子”，与右侧的“圆圈格子”的 $dp值$ 中最小者，将这个值在 $dp$ 过程中分别在矩阵下侧时插入该列的优先队列与右侧时插入该行的优先队列，最远影响范围即矩阵上，左边界(如果超出这个边界就 $pop$ 掉)，用来表示用了当前这个矩阵。

比如上图矩阵下端第一个圆形格子，它可以影响到此格子之上，三角格上方格子之下该列的所有格子，这个范围的用了 $k+1$ 个矩阵的 $dp值$ 对这个格子用了 $k$ 个矩阵的 $dp值$ 取 $min$ 。

转移方程：
```
f[i][j][k]=a[i][j]+mn(f[i+1][j][k],f[i][j+1][k]);
f[i][j][k]=mn(f[i][j][k],mn(qx[i][k-1].top(),qy[j][k-1].top()));

//f[i][j][k]:dp值
//qx[i][k]:第i行已用了k个矩阵的优先队列，qy同理
```

然后就是~~比较简单的~~实现（跑不满 $O(n^3*log_2n)$（认为 $n,m,k$ 同阶），可能要轻微卡常）：

```cpp
#include <cstdio>
#include <queue>
#include <cstring>
#include <vector>
using namespace std; 
typedef long long ll;
const int N=205,W=105,K=205;
const ll oo=1ll<<60;
int n,m,w,kk,a[N][N],ax[K],ay[K],bx[K],by[K];
ll f[N][N][W],minn[K][W][3];
vector<ll> v1[N][N],v2[N][N];
struct node {
	int x;
	ll s;
	bool operator <(const node &w) const {
		if(s==w.s) return x<w.x;
		else return s>w.s;
	}
};
priority_queue<node> qy[N][W],qx[N][W];
inline int read() {
	int x=0,flag=0;char ch=getchar();
	while(ch<'0'||ch>'9'){flag|=(ch=='-');ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return flag?-x:x;
}
inline ll mx(ll x,ll y) {return x>y?x:y;}
inline ll mn(ll x,ll y) {return x<y?x:y;}
int main() {
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	n=read();m=read();kk=read();w=read();
	memset(minn,127,sizeof minn);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j) {
			a[i][j]=read();
			//for(int k=0;k<=w;++k)
			//	f[i][j][k]=oo; 
		}
	for(int i=1;i<=kk;++i) {
		ax[i]=read();bx[i]=read();ay[i]=read();by[i]=read();
		if(bx[i]==n&&by[i]==m) {
			for(int j=ax[i];j<=bx[i];++j)
				for(int k=0;k<=w;++k)
					qx[j][k].push((node){ay[i],0});
			for(int j=ay[i];j<=by[i];++j)
				for(int k=0;k<=w;++k)
					qy[j][k].push((node){ax[i],0});
		}
		for(int j=ax[i];j<=bx[i];++j)
			v1[j][by[i]+1].push_back(i);
		for(int j=ay[i];j<=by[i];++j)
			v2[bx[i]+1][j].push_back(i);
	}
	for(int i=n;i>=1;--i) {
		for(int j=m;j>=1;--j)
			for(int k=w;k>=0;--k) {
				if(i<n) 
					if(j<m) f[i][j][k]=a[i][j]+mn(f[i+1][j][k],f[i][j+1][k]);
					else f[i][j][k]=a[i][j]+f[i+1][j][k];
				else if(j<m) f[i][j][k]=a[i][j]+f[i][j+1][k];
				else f[i][j][k]=a[i][j];
				while(!qy[j][k-1].empty()&&i<qy[j][k-1].top().x) qy[j][k-1].pop();
				while(!qx[i][k-1].empty()&&j<qx[i][k-1].top().x) qx[i][k-1].pop();
				if(k) {
					if(!qy[j][k-1].empty()) f[i][j][k]=mn(f[i][j][k],qy[j][k-1].top().s);
					if(!qx[i][k-1].empty()) f[i][j][k]=mn(f[i][j][k],qx[i][k-1].top().s);
				}
				int len1=v1[i][j].size()-1;//注意一下两个循环中的if，提前pop出不需要的位置可以帮助卡常
				for(int s=0;s<=len1;++s) {
					minn[v1[i][j][s]][k][0]=mn(minn[v1[i][j][s]][k][0],f[i][j][k]);
					if(!qx[i][k].empty()&&ay[v1[i][j][s]]>=qx[i][k].top().x&&minn[v1[i][j][s]][k][0]>=qx[i][k].top().s) continue;
					qx[i][k].push((node){ay[v1[i][j][s]],minn[v1[i][j][s]][k][0]});
				}
				int len2=v2[i][j].size()-1;
				for(int s=0;s<=len2;++s) {
					minn[v2[i][j][s]][k][1]=mn(minn[v2[i][j][s]][k][1],f[i][j][k]);
					if(!qy[j][k].empty()&&ax[v2[i][j][s]]>=qy[j][k].top().x&&minn[v2[i][j][s]][k][1]>=qy[j][k].top().s) continue;
					qy[j][k].push((node){ax[v2[i][j][s]],minn[v2[i][j][s]][k][1]});
				}
				//printf("%d %d %d:%d\n",i,j,k,f[i][j][k]);
			}
	}
	ll ans=oo;
	for(int i=0;i<=w;++i)
		ans=mn(ans,f[1][1][i]);
	printf("%lld\n",ans);
	return 0;
}

```


-完-

PS：
-  一开始我这个睿智居然想用单调队列。。。

- 把 $k$ 调大可以卡线段树做法，但 $St$ $OI$ 坚持良心不毒瘤不卡算法，所以放过了线段树做法 （（（实际上也不好卡

- 本来的题目是使最大值最小，但由于各种原因改掉了，各位可以自行思考转移方程，如果有比较简单的二分做法可以与我私信探讨，谢谢

---


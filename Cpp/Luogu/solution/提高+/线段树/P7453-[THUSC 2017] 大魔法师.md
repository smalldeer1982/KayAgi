# [THUSC 2017] 大魔法师

## 题目描述

大魔法师小 L 制作了 $n$ 个魔力水晶球，每个水晶球有水、火、土三个属性的能量值。小 L 把这 $n$ 个水晶球在地上从前向后排成一行，然后开始今天的魔法表演。

我们用 $A_i,B_i,C_i$ 分别表示从前向后第 $i$ 个水晶球（下标从 $1$ 开始）的水、火、土的能量值。

小 L 计划施展 $m$ 次魔法。每次，他会选择一个区间 $[l,r]$，然后施展以下 $3$ 大类、$7$ 种魔法之一：

1. 魔力激发：令区间里每个水晶球中**特定属性**的能量爆发，从而使另一个**特定属性**的能量增强。具体来说，有以下三种可能的表现形式：

	- 火元素激发水元素能量：令 $A_i=A_i+B_i$。
	- 土元素激发火元素能量：令 $B_i=B_i+C_i$。
	- 水元素激发土元素能量：令 $C_i=C_i+A_i$。
	
    **需要注意的是，增强一种属性的能量并不会改变另一种属性的能量，例如 $A_i=A_i+B_i$ 并不会使 $B_i$ 增加或减少。**

2. 魔力增强：小 L 挥舞法杖，消耗自身 $v$ 点法力值，来改变区间里每个水晶球的**特定属性**的能量。具体来说，有以下三种可能的表现形式：

	- 火元素能量定值增强：令 $A_i=A_i+v$。
	- 水元素能量翻倍增强：令 $B_i=B_i\times v$。
	- 土元素能量吸收融合：令 $C_i=v$。
3. 魔力释放：小 L 将区间里所有水晶球的能量聚集在一起，融合成一个新的水晶球，然后送给场外观众。生成的水晶球每种属性的能量值等于区间内所有水晶球对应能量值的代数和。**需要注意的是，魔力释放的过程不会真正改变区间内水晶球的能量。**

值得一提的是，小 L 制造和融合的水晶球的原材料都是定制版的 OI 工厂水晶，所以这些水晶球有一个能量阈值 $998244353$。当水晶球中某种属性的能量值大于等于这个阈值时，能量值会自动对阈值取模，从而避免水晶球爆炸。

小 W 为小 L（唯一的）观众，围观了整个表演，并且收到了小 L 在表演中融合的每个水晶球。小 W 想知道，这些水晶球蕴涵的三种属性的能量值分别是多少。

## 说明/提示

$100\%$ 的数据，$n,m\le2.5\times 10^5,0\le A_i,B_i,C_i,v<998244353$

1. $10\%$ 的数据，$n\times m\le10^7$。
1. 另外 $10\%$ 的数据，每次魔法的区间均为 $[1,n]$。
1. 另外 $10\%$ 的数据，每次非询问魔法的影响区间均为 $[1,n]$，所有修改在询问之前。
1. 另外 $10\%$ 的数据，$\operatorname{opt}\in\{4,5,6,7\}$。
1. 另外 $15\%$ 的数据，$\operatorname{opt}\in\{1,2,7\}$。
  1. 另外 $15\%$ 的数据，$\operatorname{opt}\in\{1,2,3,5,7\}$。
1. 另外 $15\%$ 的数据，$n,m\le 10^5$。
1. 其他数据，无特殊约定。
#### 样例解释
以下展示每次施展魔法后，两个水晶球内的能量：
```
(2, 3, 3) (6, 6, 6)
(5, 3, 3) (12, 6, 6)
(8, 3, 3) (15, 6, 6)
(8, 3, 3) (15, 6, 6)
```

## 样例 #1

### 输入

```
2
2 3 3
6 6 6
4
7 1 2
1 1 2
4 1 2 3
7 1 2```

### 输出

```
8 9 9
23 9 9```

# 题解

## 作者：xixike (赞：17)

[更好的阅读体验](https://www.cnblogs.com/xixike/p/15712528.html)

## Description

[Luogu传送门](https://www.luogu.com.cn/problem/P7453)

## Solution

标签里就俩东西，没错就是他们了。

观察到 4，5，6 操作中需要用到一个常数 $v$，所以我们的矩阵得开到 `1 * 4`，存 [A, B, C, 1]。

至于转移的 6 个矩阵这里就不推了，比较基础（不会真的有人来做这道题了连矩阵都不会推吧）。

简单说下线段树上矩阵乘法的含义。

线段树上的每个节点都维护一个矩阵。

叶子节点就是每个矩阵本身。

其他的点就是所表示区间内的所有矩阵的对应位的和。

- 对于更新操作：

  跟普通的线段树一样，就是把一个数乘上一个数改成了一个矩阵乘上一个矩阵，lazy 标记什么的也都一样更新。

  > 注意：矩阵乘法没有交换律，可别瞎乘了。

- 对于询问：

  也跟普通的线段树是一样的。真的一点区别都没有。

但是本蒟蒻在一开始写的时候觉得有一点点无从下手，这里记录一下我的思考历程。

Q：这 6 个操作怎么用矩阵乘法维护啊？

A：这个简单，随便推推矩阵就好了，矩阵中是应该是 `v` 的地方先赋成 0，需要用的时候再给他赋上 `v`。

Q：那这 6 个矩阵我怎么存下来呢，执行操作的时候我该怎么调用数组呢？

A：不要怕麻烦！直接开 6 个 `4 * 4` 的数组就完了！调用的时候判断该用哪个用哪个。当然如果你觉得这种写法不够优美的话，也可以开三维数组，具体调用见代码吧。

Q：我线段树 `build` 的时候初值怎么赋呢？

A：初值就是输入的东西，对于每一个叶子节点把输入的数直接扔进去就好了。

Q：我需要用到线段树的哪些操作呢？

A：在线段树上矩阵乘法一般都只需要区间乘法，这题也不例外，所以我们只需要维护一个乘法的懒惰标记。在 $update$ 函数中，直接传一个矩阵变量即可。

再讲讲卡常：

1. **最为重要：** 矩阵乘法的最内层循环使用循环展开，加法取模改成减法。
2. 使用快读。
3. 不要开 $long \ long$，乘法的时候强制类型转换（不会真的有人全开 $long \ long$ 了吧）。
4. 如果你不怕麻烦的话，不要使用重载的乘法运算符，因为那样是 `4 * 4` 的两个矩阵相乘，而你只需要 `1 * 4` $\times$ `4 * 4`。

其实只要有第一条和第三条基本上就能卡过去了。

下面就是你们最想看到的代码了 $:)$

## Code

```cpp
#include <bits/stdc++.h>

using namespace std;

namespace IO{
    inline int read(){
        int x = 0;
        char ch = getchar();
        while(!isdigit(ch)) ch = getchar();
        while(isdigit(ch)) x = (x << 3) + (x << 1) + ch - '0', ch = getchar();
        return x;
    }

    template <typename T> inline void write(T x){
        if(x > 9) write(x / 10);
        putchar(x % 10 + '0');
    }
}
using namespace IO;

const int N = 3e5 + 10;
const int mod = 998244353;
int n, m;

inline int add(int x) {return x > mod ? x - mod : x;}

struct matrix{
    int num[4][4];

    matrix() {memset(num, 0, sizeof(num));}
    inline void clear() {memset(num, 0, sizeof(num));}
    inline void init() {num[0][0] = num[1][1] = num[2][2] = num[3][3] = 1;}

    matrix(const int a[][4]){
        for(int i = 0; i < 4; ++i)
            for(int j = 0; j < 4; ++j)
                num[i][j] = a[i][j];
    }

    matrix operator + (const matrix &b) const{
        matrix r;
        for(int i = 0; i < 4; ++i)
            for(int j = 0; j < 4; ++j)
                r.num[i][j] = (1ll * num[i][j] + b.num[i][j]) % mod;
        return r;
    }

    matrix operator * (const matrix &b) const{
        matrix r;
        for(int i = 0; i < 4; ++i)
            for(int j = 0; j < 4; ++j){
                    r.num[i][j] = add(r.num[i][j] + (1ll * num[i][0] * b.num[0][j]) % mod);
                    r.num[i][j] = add(r.num[i][j] + (1ll * num[i][1] * b.num[1][j]) % mod);
                    r.num[i][j] = add(r.num[i][j] + (1ll * num[i][2] * b.num[2][j]) % mod);
                    r.num[i][j] = add(r.num[i][j] + (1ll * num[i][3] * b.num[3][j]) % mod);
                }
        return r;
    }
}a[N], A[4], B[4];

#define ls rt << 1
#define rs rt << 1 | 1

matrix sum[N << 2], lazy[N << 2];

inline void pushup(int rt){
    sum[rt] = sum[ls] + sum[rs];
}

inline void pushdown(int rt){
    sum[ls] = sum[ls] * lazy[rt];
    sum[rs] = sum[rs] * lazy[rt];
    lazy[ls] = lazy[ls] * lazy[rt];
    lazy[rs] = lazy[rs] * lazy[rt];
    lazy[rt].clear(), lazy[rt].init();
}

inline void build(int l, int r, int rt){
    lazy[rt].init();
    if(l == r){
        sum[rt] = a[l];
        return;
    }
    int mid = (l + r) >> 1;
    build(l, mid, ls);
    build(mid + 1, r, rs);
    pushup(rt);
}

inline void update(int L, int R, matrix k, int l, int r, int rt){
    if(L <= l && r <= R){
        sum[rt] = sum[rt] * k;
        lazy[rt] = lazy[rt] * k;
        return;
    }
    pushdown(rt);
    int mid = (l + r) >> 1;
    if(L <= mid) update(L, R, k, l, mid, ls);
    if(R > mid) update(L, R, k, mid + 1, r, rs);
    pushup(rt);
}

inline matrix query(int L, int R, int l, int r, int rt){
    if(L <= l && r <= R) return sum[rt];
    pushdown(rt);
    int mid = (l + r) >> 1;
    matrix res;
    if(L <= mid) res = res + query(L, R, l, mid, ls);
    if(R > mid) res = res + query(L, R, mid + 1, r, rs);
    return res;
}

int main(){
    A[0].init(), A[1].init(), A[2].init(), B[0].init(), B[1].init(), B[2].init();
    A[0].num[1][0] = A[1].num[2][1] = A[2].num[0][2] = 1;
    B[2].num[2][2] = 0;
    n = read();
    for(int i = 1; i <= n; ++i)
        a[i].num[0][0] = read(), a[i].num[0][1] = read(), a[i].num[0][2] = read(), a[i].num[0][3] = 1;
    build(1, n, 1);
    m = read();
    while(m--){
        int op = read(), l = read(), r = read();
        if(op <= 3) update(l, r, A[op - 1], 1, n, 1);
        else if(op <= 6){
            B[0].num[3][0] = B[1].num[1][1] = B[2].num[3][2] = read();
            update(l, r, B[op - 4], 1, n, 1);
        }else{
            matrix ans = query(l, r, 1, n, 1);
            printf("%d %d %d\n", ans.num[0][0], ans.num[0][1], ans.num[0][2]);
        }
    }
    return 0;
}
```


$$
\_EOF\_
$$


---

## 作者：rsdbk_husky (赞：13)

[博客食用效果更佳](https://rsdbkhusky.github.io/2021/09/05/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%A5%97%E7%9F%A9%E9%98%B5%20&%20Luogu%20P7453%20%5BTHUSCH2017%5D%20%E5%A4%A7%E9%AD%94%E6%B3%95%E5%B8%88/)

[题目传送门](https://www.luogu.com.cn/problem/P7453)

本文分思路（线段树套矩阵的原理），卡常，代码三个部分，大家可以直接跳到自己想看的章节。

## 零. 前置知识

  ##### 1. [线段树](https://www.luogu.com.cn/problem/P3373)

  为什么我的链接指向的是线段树 2， 而不是 1？自然是因为本题中线段树含有区间乘的要求（虽然没了区间加），强烈建议要写这道题的同学先熟练写出这道题（我就是线段树没写对调了好长时间）。

  ##### 2. [矩阵运算](https://www.luogu.com.cn/problem/P3390)

  建议将矩阵进行封装并重载运算符，因为在本体的大码量下不重载个运算符写起来真的很难受。

## 一. 线段树套矩阵（思路）

  如果这题只要求我们维护一种元素，或是各种元素之间没有影响，那这就是个线段树的板题。关键是这几种元素会相互影响。

  但是我们发现，这些操作其实都可以通过矩阵乘法来实现。比如操作一（G 矩阵就是我代码中变量名为 G 的矩阵）：

![](https://figurebed-1306986731.file.myqcloud.com/blog/2021/09/05/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%A5%97%E7%9F%A9%E9%98%B5%20%26%20Luogu%20P7453%20%5BTHUSCH2017%5D%20%E5%A4%A7%E9%AD%94%E6%B3%95%E5%B8%88/1.png)

操作四：

![](https://figurebed-1306986731.file.myqcloud.com/blog/2021/09/05/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%A5%97%E7%9F%A9%E9%98%B5%20%26%20Luogu%20P7453%20%5BTHUSCH2017%5D%20%E5%A4%A7%E9%AD%94%E6%B3%95%E5%B8%88/2.png)

（其他操作的转移矩阵见“三. 代码”）

  线段树上的矩阵只需开 $1 \times 4$（而我开了 $4 \times 4$，不过也卡过去了），其中三列的上维护三种元素，另一列维护常数 $1$。

  转移矩阵需要开 $4 \times 4$。

  那么每个操作就是将一个区间上的所有矩阵乘上一个数矩阵，如果把一个矩阵看作一个数，那这就是线段树裸题，所以，把一个支持区间乘和求区间和的线段树的 ```mul``` 数组（乘法懒标记）和 ```sum``` 数组（区间和）的数据类型改为 $4 \times 4$ 矩阵或 $1 \times 4$ 向量，```mul[xxx] = 1``` 改为 ```mul[xxx] = I``` （```I```：单位矩阵）就行了。

## 二. 卡常

1. 不要使用 ```long long```，有溢出风险的地方用强制转换就好了。

2. 使用快读或：
  ```cpp
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cout.tie(nullptr);
  ```

3. 开 O2。

4. 使用 ```register```。

5. 如果还卡不过去，那就应该试试将线段树上的 $4 \times 4$ 矩阵换成 $1 \times 4$ 的向量。

## 三. 代码

```cpp
#include<cstdio>
#include<cstring>
#define re register
typedef long long ll;
const int MAXn = 2e5 + 5e4;
const int MAXmat = 4;
const int MOD = 998244353;

template <class T>
inline void read(T &a) {
	register char c;while (c = getchar(), (c < '0' || c > '9') && c != '-');register bool f = c == '-';register T x = f ? 0 : c - '0';while (c = getchar(), c >= '0' && c <= '9') {x = (x << 3) + (x << 1) + (c ^ 48);}a = f ? -x : x;
}

struct Mat {
	int mat[MAXmat][MAXmat];
	Mat() {
		memset(mat, 0, sizeof(mat));
	}
	Mat(int a[MAXmat][MAXmat]) {
		for (re int i = 0; i < MAXmat; ++i) {
			for (re int j = 0; j < MAXmat; ++j) {
				mat[i][j] = a[i][j];
			}
		}
	}
	inline void operator=(Mat x) {
		for (re int i = 0; i < MAXmat; ++i) {
			for (re int j = 0; j < MAXmat; ++j) {
				mat[i][j] = x.mat[i][j];
			}
		}
	}
	inline Mat operator+(Mat x) {
		Mat ans;
		for (int i = 0; i < MAXmat; ++i) {
			for (int j = 0; j < MAXmat; ++j) {
				ans.mat[i][j] = ((ll)mat[i][j] + x.mat[i][j]) % MOD;
			}	
		}
		return ans;
	}
	inline Mat operator*(Mat x) {
		Mat ans;
		for (re int i = 0; i < MAXmat; ++i) {
			for (re int k = 0; k < MAXmat; ++k) {
				int a = mat[i][k];
				for (re int j = 0; j < MAXmat; ++j) {
					ans.mat[i][j] = ((ll)a * x.mat[k][j] + ans.mat[i][j]) % MOD;
				}
			}
		}
		return ans;
	}
	inline Mat operator^(int x) {
		Mat ans, base;
		for (re int i = 0; i < MAXmat; ++i) {
			ans.mat[i][i] = 1;
		}
		for (re int i = 0; i < MAXmat; ++i) {
			for (re int j = 0; j < MAXmat; ++j) {
				base.mat[i][j] = mat[i][j];
			}
		}
		while (x) {
			if (x & 1) {
				ans = ans * base;
			}
			base = base * base;
			x >>= 1;
		}
		return ans;
	}
};
int I_[MAXmat][MAXmat] = {
	{1, 0, 0, 0},
	{0, 1, 0, 0},
	{0, 0, 1, 0},
	{0, 0, 0, 1},
};
Mat I(I_);

int le[MAXn * 4 + 10], ri[MAXn * 4 + 10];
Mat sum[MAXn * 4 + 10], mul[MAXn * 4 + 10];
inline void pushup(int id) {
	sum[id] = (sum[id << 1] + sum[(id << 1) + 1]);
}
inline void pushdown(int id) {
	sum[id << 1] = (sum[id << 1] * mul[id]);
	sum[(id << 1) + 1] = (sum[(id << 1) + 1] * mul[id]);
	mul[id << 1] = (mul[id << 1] * mul[id]);
	mul[(id << 1) + 1] = (mul[(id << 1) + 1] * mul[id]);
	mul[id] = I;
}
void BuildUseArr(int id, int l, int r, Mat *a) {
	le[id] = l;
	ri[id] = r;
	mul[id] = I;
	if (l == r) {
		sum[id] = a[l];
	} else {
		int mid = (l + r) >> 1;
		BuildUseArr(id << 1, l, mid, a);
		BuildUseArr((id << 1) + 1, mid + 1, r, a);
		pushup(id);
	}
}
void Mul(int id, int l, int r, Mat k) {
	if (le[id] >= l && ri[id] <= r) {
		mul[id] = (mul[id] * k);
		sum[id] = (sum[id] * k);
	} else {
		pushdown(id);		
		int mid = (le[id] + ri[id]) >> 1;
		if (l <= mid) Mul(id << 1, l, r, k);
		if (r > mid) Mul((id << 1) + 1, l, r, k);
		pushup(id);
	}
}
Mat Sum(int id, int l, int r) {
	if (le[id] >= l && ri[id] <= r) {
		return sum[id];
	} else {
		pushdown(id);
		int mid = (le[id] + ri[id]) >> 1;
		Mat ans;
		if (l <= mid) ans = Sum(id << 1, l, r);
		if (r > mid) ans = (ans + Sum((id << 1) + 1, l, r));
		return ans;
	}
}

int n, m;
Mat a[MAXn + 10], G;
int A_[MAXmat][MAXmat] = {
	{1, 0, 0, 0},
	{1, 1, 0, 0},
	{0, 0, 1, 0},
	{0, 0, 0, 1},
};
Mat A(A_);
int B_[MAXmat][MAXmat] = {
	{1, 0, 0, 0},
	{0, 1, 0, 0},
	{0, 1, 1, 0},
	{0, 0, 0, 1},
};
Mat B(B_);
int C_[MAXmat][MAXmat] = {
	{1, 0, 1, 0},
	{0, 1, 0, 0},
	{0, 0, 1, 0},
	{0, 0, 0, 1},
};
Mat C(C_);
int D_[MAXmat][MAXmat] = {
	{1, 0, 0, 0},
	{0, 1, 0, 0},
	{0, 0, 1, 0},
	{0, 0, 0, 1}, // [3][0] = v
};
Mat D(D_);
int E_[MAXmat][MAXmat] = {
	{1, 0, 0, 0},
	{0, 0, 0, 0},
	{0, 0, 1, 0},
	{0, 0, 0, 1}, // [1][1] = v
};
Mat E(E_);
int F_[MAXmat][MAXmat] = {
	{1, 0, 0, 0},
	{0, 1, 0, 0},
	{0, 0, 0, 0},
	{0, 0, 0, 1}, // [3][2] = v
};
Mat F(F_);
signed main() {
	read(n);
	for (re int i = 1; i <= n; ++i) {
		read(a[i].mat[0][0]), read(a[i].mat[0][1]), read(a[i].mat[0][2]);
		a[i].mat[0][3] = 1;
	}
	BuildUseArr(1, 1, n, a);
	read(m);
	for (re int i = 1, opt, l, r, v; i <= m; ++i) {
		read(opt);
		switch (opt) {
		case 1:
			read(l), read(r);
			Mul(1, l, r, A);
			break;
		case 2:
			read(l), read(r);
			Mul(1, l, r, B);
			break;
		case 3:
			read(l), read(r);
			Mul(1, l, r, C);
			break;
		case 4:
			read(l), read(r), read(v);
			D.mat[3][0] = v;
			Mul(1, l, r, D);
			break;
		case 5:
			read(l), read(r), read(v);
			E.mat[1][1] = v;
			Mul(1, l, r, E);
			break;
		case 6:
			read(l), read(r), read(v);
			F.mat[3][2] = v;
			Mul(1, l, r, F);
			break;
		case 7:
			read(l), read(r);
			G = Sum(1, l, r);
			printf("%d %d %d\n", G.mat[0][0], G.mat[0][1], G.mat[0][2]);
			break;
		}
	}
}

```

---

## 作者：cymrain07 (赞：9)

卡了一个小时常数后……  
用线段树维护数列。  
设线段树上每个区间是一个向量 $\begin{pmatrix}
 \sum A &\sum B  &\sum C  & len
\end{pmatrix}$，每个操作都可以看做乘一个矩阵。  
操作 $1$：

$$
\begin{pmatrix}
  1&  0&  0&0 \\
  1&  1&  0&0\\
  0&  0&  1&0\\
  0&  0&  0&1
\end{pmatrix}
$$

操作 $2$：

$$
\begin{pmatrix}
  1&  0&  0&0 \\
  0&  1&  0&0\\
  0&  1&  1&0\\
  0&  0&  0&1
\end{pmatrix}
$$

操作 $3$：

$$
\begin{pmatrix}
  1&  0&  1&0 \\
  0&  1&  0&0\\
  0&  0&  1&0\\
  0&  0&  0&1
\end{pmatrix}
$$

操作 $4$：

$$
\begin{pmatrix}
  1&  0&  0&0 \\
  0&  1&  0&0\\
  0&  0&  1&0\\
  v&  0&  0&1
\end{pmatrix}
$$

操作 $5$：

$$
\begin{pmatrix}
  1&  0&  0&0 \\
  0&  v&  0&0\\
  0&  0&  1&0\\
  0&  0&  0&1
\end{pmatrix}
$$

操作 $6$：

$$
\begin{pmatrix}
  1&  0&  0&0 \\
  0&  1&  0&0\\
  0&  0&  0&0\\
  0&  0&  v&1
\end{pmatrix}
$$

打一个懒标记，初始化为单位矩阵，操作一次就把矩阵乘到懒标记上。  
查询同普通线段树。  
乘法会爆 `int`，乘的时候要乘 `1ll`。  
注意本题极其卡常，洛谷要吸氧。

```cpp
#include <bits/stdc++.h>
#define mod 998244353
#define N 250005
using namespace std;
int n, a[N], b[N], c[N], m;
struct mat
{
    int a[4][4];
    mat(bool val = 1)
    {
        memset(a, 0, sizeof(a));
        if (val == 1)
            for (int i = 0; i < 4; i++)
                a[i][i] = 1;
    }
    mat operator*(const mat x) const
    {
        mat res = (0);
        for (int i = 0; i < 4; i++)
            for (int j = 0; j < 4; j++)
                for (int k = 0; k < 4; k++)
                    res.a[i][j] += 1ll * a[i][k] * x.a[k][j] % mod, res.a[i][j] %= mod;
        return res;
    }
};

struct vec
{
    int v[4];
    vec() { memset(v, 0, sizeof(v)); }
    vec(int a, int b, int c) { v[0] = a, v[1] = b, v[2] = c, v[3] = 1; }
    vec operator+(const vec x) const
    {
        vec res;
        res.v[0] = (v[0] + x.v[0]) % mod;
        res.v[1] = (v[1] + x.v[1]) % mod;
        res.v[2] = (v[2] + x.v[2]) % mod;
        res.v[3] = v[3] + x.v[3];
        return res;
    }
    vec operator*(mat y)
    {
        vec res;
        for (int j = 0; j < 4; j++)
            for (int k = 0; k < 4; k++)
                res.v[j] += (1ll * v[k] * y.a[k][j]) % mod, res.v[j] %= mod;
        return res;
    }
};
mat t1, t2, t3, t4, t5, t6;
void pre()
{
    t1.a[1][0] = t2.a[2][1] = t3.a[0][2] = 1;
    t6.a[2][2] = 0;
}

struct SegmentTree
{
#define root 1, 1, n
#define mid ((l + r) >> 1)
#define lpos pos << 1
#define rpos lpos | 1
#define lson lpos, l, mid
#define rson rpos, mid + 1, r
    vec tr[N << 2];
    mat tag[N << 2];
    void psu(int pos) { tr[pos] = tr[lpos] + tr[rpos]; }
    void bld(int pos, int l, int r)
    {
        if (l == r)
            return tr[pos] = vec(a[l], b[l], c[l]), void();
        bld(lson), bld(rson), psu(pos);
    }
    void ntg(int pos, mat t)
    {
        tag[pos] = tag[pos] * t;
        tr[pos] = tr[pos] * t;
    }
    void psd(int pos)
    {
        ntg(lpos, tag[pos]), ntg(rpos, tag[pos]), tag[pos] = mat();
    }
    void upd(int pos, int l, int r, int L, int R, mat t)
    {
        if (L <= l && r <= R)
            return ntg(pos, t), void();
        psd(pos);
        if (L <= mid)
            upd(lson, L, R, t);
        if (R > mid)
            upd(rson, L, R, t);
        psu(pos);
    }
    vec qry(int pos, int l, int r, int L, int R)
    {
        if (L <= l && r <= R)
            return tr[pos];
        psd(pos);
        if (R <= mid)
            return qry(lson, L, R);
        if (L > mid)
            return qry(rson, L, R);
        return qry(lson, L, R) + qry(rson, L, R);
    }
} T;
int main()
{
    pre();
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d%d%d", &a[i], &b[i], &c[i]);
    T.bld(root);
    scanf("%d", &m);
    while (m--)
    {
        int l, r, v, op;
        scanf("%d%d%d", &op, &l, &r);
        if (op == 1)
            T.upd(root, l, r, t1);
        else if (op == 2)
            T.upd(root, l, r, t2);
        else if (op == 3)
            T.upd(root, l, r, t3);
        else if (op == 7)
        {
            vec ans = T.qry(root, l, r);
            printf("%d %d %d\n", ans.v[0], ans.v[1], ans.v[2]);
        }
        else
        {
            scanf("%d", &v);
            if (op == 4)
                t4.a[3][0] = v, T.upd(root, l, r, t4);
            else if (op == 5)
                t5.a[1][1] = v, T.upd(root, l, r, t5);
            else if (op == 6)
                t6.a[3][2] = v, T.upd(root, l, r, t6);
        }
    }
    return 0;
}
```


---

## 作者：Priori_Incantatem (赞：5)

[题目链接](https://www.luogu.com.cn/problem/P7453)

感觉本题没有太多思维难度，纯DS

-----

大致思路把每个位置的三个属性看做一个 $1\times 4$ 的矩阵（第四个位置维护常数项），并用线段树维护区间矩阵和  
同时，我们计算出六种修改操作的转移矩阵，修改时直接将原矩阵乘上转移矩阵。由于矩阵满足结合律与分配率，所以可以将单点修改扩展为区间修改。

下面是分别六种操作的转移矩阵

1. $\begin{bmatrix} 1 \space 0 \space 0 \space 0 \\  1 \space 1 \space 0 \space 0  \\  0 \space 0 \space 1 \space 0  \\  0 \space 0 \space 0 \space 1 \end{bmatrix}$
2. $\begin{bmatrix} 1 \space 0 \space 0 \space 0 \\  0 \space 1 \space 0 \space 0  \\  0 \space 1 \space 1 \space 0  \\  0 \space 0 \space 0 \space 1 \end{bmatrix}$
3. $\begin{bmatrix} 1 \space 0 \space 1 \space 0 \\  0 \space 1 \space 0 \space 0  \\  0 \space 0 \space 1 \space 0  \\  0 \space 0 \space 0 \space 1 \end{bmatrix}$
4. $\begin{bmatrix} 1 \space 0 \space 0 \space 0 \\  0 \space 1 \space 0 \space 0  \\  0 \space 0 \space 1 \space 0  \\  v \space 0 \space 0 \space 1 \end{bmatrix}$
5. $\begin{bmatrix} 1 \space 0 \space 0 \space 0 \\  0 \space v \space 0 \space 0  \\  0 \space 0 \space 1 \space 0  \\  0 \space 0 \space 0 \space 1 \end{bmatrix}$
6. $\begin{bmatrix} 1 \space 0 \space 0 \space 0 \\  0 \space 1 \space 0 \space 0  \\  0 \space 0 \space 0 \space 0  \\  0 \space 0 \space v \space 1 \end{bmatrix}$

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
#pragma GCC optimize(2)
const int Maxn=2.5e5+10;
const int Maxm=Maxn<<2;
const int mod=998244353;
const int m=4;
struct mat{
	int d[6][6];
	bool operator ==(const mat &x)const
	{
		for(int i=1;i<=m;++i)
		for(int j=1;j<=m;++j)
		if(x.d[i][j]!=d[i][j])
		return 0;
		return 1;
	}
}f[Maxm],I;
struct ary{
	int d[6];
	bool operator ==(const ary &x)const
	{
		for(int i=1;i<=m;++i)
		if(x.d[i]!=d[i])
		return 0;
		return 1;
	}
}c[Maxm],a[Maxn];
int n,q;
inline int add_mod(int x,int y)
{
	int tmp=(x+y);
	if(tmp>=mod)tmp-=mod;
	return tmp;
}
inline int mul_mod(int x,int y)
{
	return (1ll*x*y)%mod;
}
inline void check_add(int &x,int y)
{
	x=add_mod(x,y);
}
inline void check_mul(int &x,int y)
{
	x=mul_mod(x,y);
}
mat mul(mat a,mat b)
{
	mat c;memset(c.d,0,sizeof(c.d));
	for(int i=1;i<=m;++i)
	for(int j=1;j<=m;++j)
	for(int k=1;k<=m;++k)
	check_add(c.d[i][j],mul_mod(a.d[i][k],b.d[k][j]));
	return c;
}
ary add(ary a,ary b)
{
	ary c;
	for(int i=1;i<=m;++i)
	c.d[i]=add_mod(a.d[i],b.d[i]);
	return c;
}
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0' || ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
inline void push_up(int k)
{
	c[k]=add(c[k<<1],c[k<<1|1]);
}
inline void upd(int k,mat v)
{
	f[k]=mul(f[k],v);
	ary t;memset(t.d,0,sizeof(t.d));
	for(int i=1;i<=m;++i)
	for(int j=1;j<=m;++j)
	check_add(t.d[i],mul_mod(c[k].d[j],v.d[j][i]));
	c[k]=t;
}
inline void push_down(int k)
{
	if(f[k]==I)return;
	upd(k<<1,f[k]);
	upd(k<<1|1,f[k]);
	f[k]=I;
}
void modify(int k,int l,int r,int x,int y,mat v)
{
	if(x<=l && r<=y)return upd(k,v);
	push_down(k);
	int mid=(l+r)>>1;
	if(x<=mid)modify(k<<1,l,mid,x,y,v);
	if(mid<y)modify(k<<1|1,mid+1,r,x,y,v);
	push_up(k);
}
ary query(int k,int l,int r,int x,int y)
{
	if(x<=l && r<=y)return c[k];
	push_down(k);
	int mid=(l+r)>>1;
	ary ret;memset(ret.d,0,sizeof(ret.d));
	if(x<=mid)ret=query(k<<1,l,mid,x,y);
	if(mid<y)ret=add(ret,query(k<<1|1,mid+1,r,x,y));
	return ret;
}
void build(int k,int l,int r)
{
	f[k]=I;
	// if(l==r)
	// {
	// 	c[k]=a[l];
	// 	printf("k = %d\n",k);
	// 	for(int i=1;i<=m;++i)
	// 	printf("%d ",c[k].d[i]);
	// 	putchar('\n');
	// }
	if(l==r){c[k]=a[l];return;}
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	push_up(k);
	// printf("k = %d\n",k);
	// for(int i=1;i<=m;++i)
	// printf("%d ",c[k].d[i]);
	// putchar('\n');
}
int main()
{
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
	n=read();
	memset(I.d,0,sizeof(I.d));
	for(int i=1;i<=m;++i)
	I.d[i][i]=1;
	for(int i=1;i<=n;++i)
	{
		a[i].d[1]=read();
		a[i].d[2]=read();
		a[i].d[3]=read();
		a[i].d[4]=1;
	}
	build(1,1,n);
	q=read();
	while(q--)
	{
		int opt=read(),l=read(),r=read();
		if(opt==7)
		{
			ary tmp=query(1,1,n,l,r);
			for(int i=1;i<m;++i)
			printf("%d ",tmp.d[i]);
			putchar('\n');continue;
		}
		mat t=I;
		if(opt==1)t.d[2][1]=1;
		if(opt==2)t.d[3][2]=1;
		if(opt==3)t.d[1][3]=1;
		if(opt==4)t.d[4][1]=read();
		if(opt==5)t.d[2][2]=read();
		if(opt==6)
		{
			t.d[3][3]=0;
			t.d[4][3]=read();
		}
		modify(1,1,n,l,r,t);
	}
	return 0;
}

```

---

## 作者：laplace_oo (赞：4)

# Soltion

一眼线段树套矩乘

操作有加常数的操作，所以我们需要在矩阵里加上一个 $1$。

最终的矩阵是长成了：

$$
	\begin{bmatrix}A,B,C,1\end{bmatrix}
$$

我们考虑操作

## 魔力激发

火元素激发水元素能量：$A_{i}=A_{i}+B_{i}$。

$$
	\begin{bmatrix}A,B,C,1\end{bmatrix} \times \begin{bmatrix} 
						1, 0, 0, 0 \\
						1, 1, 0, 0 \\
						0, 0, 1, 0 \\
						0, 0, 0, 1 \\
					 \end{bmatrix} = [A+B,B,C,1]
$$

土元素激发火元素能量：$B_{i}=B_{i}+C_{i}$。

$$
	\begin{bmatrix}A,B,C,1\end{bmatrix} \times \begin{bmatrix} 
						1, 0, 0, 0 \\
						0, 1, 0, 0 \\
						0, 1, 1, 0 \\
						0, 0, 0, 1 \\
					 \end{bmatrix} = [A,B+C,C,1]
$$

水元素激发土元素能量：$C_{i}=C_{i}+A_{i}$。

$$
	\begin{bmatrix}A,B,C,1\end{bmatrix} \times \begin{bmatrix} 
						1, 0, 1, 0 \\
						0, 1, 0, 0 \\
						0, 0, 1, 0 \\
						0, 0, 0, 1 \\
					 \end{bmatrix} = [A,B,C+A,1]
$$

## 魔力增强

火元素能量定值增强：$A_i=A_i+v$。

$$
	\begin{bmatrix}A,B,C,1\end{bmatrix} \times \begin{bmatrix} 
						1, 0, 0, 0 \\
						0, 1, 0, 0 \\
						0, 0, 1, 0 \\
						v, 0, 0, 1 \\
					 \end{bmatrix} = [A+v,B,C,1]
$$

水元素能量翻倍增强：$B_i=B_i\times v$

$$
	\begin{bmatrix}A,B,C,1\end{bmatrix} \times \begin{bmatrix} 
						1, 0, 0, 0 \\
						0, v, 0, 0 \\
						0, 0, 1, 0 \\
						0, 0, 0, 1 \\
					 \end{bmatrix} = [A,B*v,C,1]
$$

土元素能量吸收融合：$C_i=v$

$$
	\begin{bmatrix}A,B,C,1\end{bmatrix} \times \begin{bmatrix} 
						1, 0, 0, 0 \\
						0, 1, 0, 0 \\
						0, 0, 0, 0 \\
						0, 0, v, 1 \\
					 \end{bmatrix} = [A,B,v,1]
$$

对于这些操作，直接把转移矩阵当成线段树乘法里的要乘的数，然后下传即可。

## 魔力释放

对于魔力释放操作，我们可以直接用线段树把区间内的矩阵都加起来。这样是可以的，我们考虑对于第一类操作来说，通过加法分配律，我们可以证明他是可以区间操作的，第二类操作，我们考虑我们区间和的时候，我们同样的把矩阵最后的那个 $1$ 也加了起来，这样每次在一个区间内修改的时候，加的就是 $n$ 倍的 $v$，赋值的时候也是 $n$ 倍的 $v$。所以对于魔力释放是没有影响的。

但是我们注意要卡卡常数，这里提供三种办法：

1) 我们在矩阵乘的时候可以循环展开，或者直接写64个式子，或者我们跳过 `a[i][k]` 或者 `b[k][j]` 为 $0$ 的时候。

2) 我们考虑在标记下传时，如果此时 `tag` 时单位矩阵，我们没必要下传

3) 我们还是考虑标记下穿，因为叶子节点没有儿子，所以我们给叶子节点传标记的时候，只下传到值里，不下传到标记里。

这就是这个题的做法，都是基本的矩阵转移。我们可以参考下代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MOD=998244353;
const int N=3e5;
typedef struct Matrix
{
	int _[4][4];
	Matrix(int _e=1)
	{
		memset(_,0,sizeof(_));
		_[0][0]=_e,_[1][1]=_e;
		_[2][2]=_e,_[3][3]=_e;
	}
	int *operator[](int _i)
	{
		return _[_i];
	}
	friend Matrix operator+(Matrix a,Matrix b)
	{
		for(int i=0;i<4;++i)
		for(int j=0;j<4;++j)
			a[i][j]=(1ll*a[i][j]+b[i][j])%MOD;
		return a;
	}
	friend Matrix operator*(Matrix a,Matrix b)
	{
		Matrix c=Matrix(0);
		for(int i=0;i<4;++i)
		for(int k=0;k<4;++k)
		{
			if(!a[i][k])
				continue;
			for(int j=0;j<4;++j)
			{
				if(!b[k][j])
					continue;
				c[i][j]=(1ll*c[i][j]+1ll*a[i][k]*b[k][j]%MOD)%MOD;
			}
		}
		return c;
	}
	friend bool operator!=(Matrix a,Matrix b)
	{
		for(int i=0;i<4;++i)
		for(int j=0;j<4;++j)
			if(a[i][j]!=b[i][j])
				return 1;
		return 0;
	}
} Mat;
Mat mats[N];
typedef struct SegmentTree
{
	struct Node
	{
#define lc (p<<1)
#define rc ((p<<1)|1)
		int l,r;
		Mat val;
		Mat tag;
		int md()
		{
			return ((l+r)>>1);
		}
		int le()
		{
			return (r-l+1);
		}
		bool leaf()
		{
			return (l==r);
		}
	};
	Node t[N*4];
	SegmentTree(){}
	void up(int p)
	{
		t[p].val=t[lc].val+t[rc].val;
	}
	void dwd(int p)
	{
		if(t[p].tag!=Mat())
		{
			t[lc].val=t[lc].val*t[p].tag;
			t[rc].val=t[rc].val*t[p].tag;
			if(!t[lc].leaf())
				t[lc].tag=t[lc].tag*t[p].tag;
			if(!t[rc].leaf())
				t[rc].tag=t[rc].tag*t[p].tag;
			t[p].tag=Mat();
		}
	}
	void build(int l,int r,int p=1)
	{
		t[p].l=l,t[p].r=r;
		if(l==r)
		{
			t[p].val=mats[l];
			return;
		}
		build(l,t[p].md(),lc);
		build(t[p].md()+1,r,rc);
		up(p);
	}
	void mdf(int l,int r,Mat k,int p=1)
	{
		if(l<=t[p].l&&t[p].r<=r)
		{
			t[p].val=t[p].val*k;
			t[p].tag=t[p].tag*k;
			return;
		}
		dwd(p);
		if(l<=t[p].md())
			mdf(l,r,k,lc);
		if(r>t[p].md())
			mdf(l,r,k,rc);
		up(p);
	}
	Mat qry(int l,int r,int p=1)
	{
		if(l<=t[p].l&&t[p].r<=r)
			return t[p].val;
		dwd(p);
		Mat res=0;
		if(l<=t[p].md())
			res=res+qry(l,r,lc);
		if(r>t[p].md())
			res=res+qry(l,r,rc);
		up(p);
		return res;
	}
} Tree;
Tree t;
Mat tmp;
int n,m;
int main()
{
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		cin>>mats[i][0][0];
		cin>>mats[i][0][1];
		cin>>mats[i][0][2];
		mats[i][0][3]=1;
	}
	t.build(1,n);
	cin>>m;
	for(int i=1;i<=m;++i)
	{
		int opt,l,r;
		tmp=Mat();
		cin>>opt>>l>>r;
		if(opt<=6)
		{
			if(opt==1)tmp[1][0]=1;
			if(opt==2)tmp[2][1]=1;
			if(opt==3)tmp[0][2]=1;
			if(opt==4)cin>>tmp[3][0];
			if(opt==5)cin>>tmp[1][1];
			if(opt==6)cin>>tmp[3][2],tmp[2][2]=0;
			t.mdf(l,r,tmp);
		}
		else
		{
			tmp=t.qry(l,r);
			cout<<tmp[0][0]<<' '<<tmp[0][1]<<' '<<tmp[0][2]<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：iiiiiyang (赞：3)

# 【THUSCH2017】 大魔法师

[题目链接](https://www.luogu.com.cn/problem/P7453)

### 前言

线段树和矩阵乘法的板子拼接题，这个题题目本身思维难度不大，但是可以给我们提供许多平时写代码的底层优化技巧。

### 题目思路

首先回到题目，我们需要维护 $n$ 个魔法球，每个魔法球里面的内容有水火土三部分。第四到六个操作我们还需要维护一个系数 $x$，表示这个区域有多少个水晶球。这样的话我们建一棵线段树，在每个节点维护两个 $1 \times 4$ 的矩阵，一个是当前状态 $val$，另一个是懒惰标记 $tag$。

$$
\begin{bmatrix}
A_i \; B_i \; C_i \; x
\end{bmatrix}
$$

然后我们推一下转移矩阵：

操作一：

$$
\begin{bmatrix}
A_i \; B_i \; C_i \; x
\end{bmatrix}
\times
Base
=
\begin{bmatrix}
A_i + B_i \; B_i \; C_i \; x
\end{bmatrix}
$$
$$
Base
=
\begin{bmatrix}
1 \; 0 \; 0 \; 0 \\
1 \; 1 \; 0 \; 0 \\
0 \; 0 \; 1 \; 0 \\
0 \; 0 \; 0 \; 1 \\
\end{bmatrix}
$$

操作二：

$$
\begin{bmatrix}
A_i \; B_i \; C_i \; x
\end{bmatrix}
\times
Base
=
\begin{bmatrix}
A_i \; B_i+C_i \; C_i \; x
\end{bmatrix}
$$
$$
Base
=
\begin{bmatrix}
1 \; 0 \; 0 \; 0 \\
0 \; 1 \; 0 \; 0 \\
0 \; 1 \; 1 \; 0 \\
0 \; 0 \; 0 \; 1 \\
\end{bmatrix}
$$

操作三：

$$
\begin{bmatrix}
A_i \; B_i \; C_i \; x
\end{bmatrix}
\times
Base
=
\begin{bmatrix}
A_i \; B_i \; C_i+A_i \; x
\end{bmatrix}
$$
$$
Base
=
\begin{bmatrix}
1 \; 0 \; 1 \; 0 \\
0 \; 1 \; 0 \; 0 \\
0 \; 0 \; 1 \; 0 \\
0 \; 0 \; 0 \; 1 \\
\end{bmatrix}
$$

操作四：

$$
\begin{bmatrix}
A_i \; B_i \; C_i \; x
\end{bmatrix}
\times
Base
=
\begin{bmatrix}
A_i + v \; B_i \; C_i \; x
\end{bmatrix}
$$
$$
Base
=
\begin{bmatrix}
1 \; 0 \; 0 \; 0 \\
0 \; 1 \; 0 \; 0 \\
0 \; 0 \; 1 \; 0 \\
v \; 0 \; 0 \; 1 \\
\end{bmatrix}
$$

操作五：

$$
\begin{bmatrix}
A_i \; B_i \; C_i \; x
\end{bmatrix}
\times
Base
=
\begin{bmatrix}
A_i \; B_i \times v \; C_i \; x
\end{bmatrix}
$$
$$
Base
=
\begin{bmatrix}
1 \; 0 \; 0 \; 0 \\
0 \; v \; 0 \; 0 \\
0 \; 0 \; 1 \; 0 \\
0 \; 0 \; 0 \; 1 \\
\end{bmatrix}
$$

操作六：

$$
\begin{bmatrix}
A_i \; B_i \; C_i \; x
\end{bmatrix}
\times
Base
=
\begin{bmatrix}
A_i \; B_i \; v \; x
\end{bmatrix}
$$
$$
Base
=
\begin{bmatrix}
1 \; 0 \; 0 \; 0 \\
0 \; 1 \; 0 \; 0 \\
0 \; 0 \; 0 \; 0 \\
0 \; 0 \; v \; 1 \\
\end{bmatrix}
$$

对于每一个操作，我们只需要用线段树的区间乘法，只不过改成乘一个矩阵就好。

询问则是一个区间求和，把要求的区间里的矩阵加起来就好了。

### 技巧（正题）

这道题的具体做法其他题解可能讲的更为清晰，所以我来总结一些以后编程中应该尽量去使用的小技巧。

~~本题其实不卡常。~~

先上一张图：
![QQ图片20220823194004.png](https://s2.loli.net/2022/08/23/V2YWlxvE7RBf4D9.png)

那么我做了些什么呢？

~~不要在意全是 WA。~~

首先第一个是把矩阵下标从 $1 \sim 4$ 改到 $0 \sim 3$。~~但是实际上作用不大。~~

然后抛开矩阵乘法不看，如果只看线段树，那就是一个支持区间乘，区间求和的线段树板子。~~甚至比线段树二简单。~~但是为什么它跑的这么慢呢？就是因为每一个操作都是矩阵乘法，如果普通写是一个三重循环，而平常的线段树上传下传操作是 $O(1)$ 的，因此我们优化的地方就分成两部分，一个是加速它的矩阵操作，一个是减少它的操作次数。

对于前者，这个题是一个 $1 \times 4$ 和 $4 \times 4$ 的矩阵相乘，我们把最内层循环展开，这样就减少了循环次数。

普通的矩阵乘法：
```cpp
matrix operator * (const matrix& T) const
{
	matrix res;
	for(int i=1;i<=4;i++)
		for(int j=1;j<=4;j++)
			for(int k=1;k<=4;k++)
				res.a[i][j]=(res.a[i][j]+(1ll*a[i][k]*T.a[k][j])%mod)%mod;
	return res;
}
```
对于这个题的循环展开：
```cpp
matrix operator * (const matrix& T) const
{
	matrix res;
	for(int i=0;i<4;i++)
		for(int j=0;j<4;j++)
			res.a[i][j]=((((1ll*a[i][0]*T.a[0][j]%mod)+1ll*a[i][1]*T.a[1][j]%mod)%mod+1ll*a[i][2]*T.a[2][j]%mod)%mod+1ll*a[i][3]*T.a[3][j]%mod)%mod;
	return res;
}
```
对于后者，我们容易想到平时的线段树操作是在运行标记下传的时候，如果标记里面没有东西就不用运行了，这个题我们可以再额外维护一个变量 $lzy$，记录这个节点有没有标记，如果这个变量为 $0$ 就可以不用运行了。此外还可以多判断一个内容，就是如果已经到了叶子节点就不用往后传 $tag$ 了。

还要注意的一些小细节有 $tag$ 矩阵清零是要都设为单位矩阵 $I$，还有变量都设置为 `int` 就行，当有风险溢出时乘一个 `1ll` 就好了。

$Code$
```cpp
#include<bits/stdc++.h>
#define MAX 250010
#define ll long long
#define mod 998244353
using namespace std;

inline int read()
{
	int s=0,w=1;
	char c=getchar();
	while(!isdigit(c)) {if(c=='-') w=-1; c=getchar();}
	while(isdigit(c)) s=(s<<1)+(s<<3)+(c^48),c=getchar();
	return s*w;
}

int n,m;
int op,x,y;
int a[MAX][4];

struct matrix
{
	int a[4][4];
	inline matrix()
	{
		for(int i=0;i<4;i++)
			for(int j=0;j<4;j++)
				a[i][j]=0;
	}
	matrix operator * (const matrix& T) const
	{
		matrix res;
		for(int i=0;i<4;i++)
			for(int j=0;j<4;j++)
				res.a[i][j]=((((1ll*a[i][0]*T.a[0][j]%mod)+1ll*a[i][1]*T.a[1][j]%mod)%mod+1ll*a[i][2]*T.a[2][j]%mod)%mod+1ll*a[i][3]*T.a[3][j]%mod)%mod;
		return res;
	}
	matrix operator + (const matrix& T) const
	{
		matrix res;
		for(int i=0;i<4;i++)
			for(int j=0;j<4;j++)
				res.a[i][j]=(a[i][j]+T.a[i][j])%mod;
		return res;
	}
};

matrix I,A,B,C,D,E,F;
inline void init()
{
	for(int i=0;i<4;i++)
		for(int j=0;j<4;j++)
			if(i==j)
				I.a[i][j]=1;
			else
				I.a[i][j]=0;
	A.a[0][0]=A.a[1][1]=A.a[2][2]=A.a[3][3]=A.a[1][0]=1;
	B.a[0][0]=B.a[1][1]=B.a[2][2]=B.a[3][3]=B.a[2][1]=1;
	C.a[0][0]=C.a[1][1]=C.a[2][2]=C.a[3][3]=C.a[0][2]=1;
	D.a[0][0]=D.a[1][1]=D.a[2][2]=D.a[3][3]=1;
	E.a[0][0]=E.a[2][2]=E.a[3][3]=1;
	F.a[0][0]=F.a[1][1]=F.a[3][3]=1;
	return;
}

struct Segment_Tree
{
	int l,r,lzy;
	matrix val,tag;
}t[MAX<<2];
inline void pushup(int i)
{
	t[i].val.a[0][0]=(t[i<<1].val.a[0][0]+t[i<<1|1].val.a[0][0])%mod;
	t[i].val.a[0][1]=(t[i<<1].val.a[0][1]+t[i<<1|1].val.a[0][1])%mod;
	t[i].val.a[0][2]=(t[i<<1].val.a[0][2]+t[i<<1|1].val.a[0][2])%mod;
	t[i].val.a[0][3]=(t[i<<1].val.a[0][3]+t[i<<1|1].val.a[0][3])%mod;
	return;
}
inline void pushdown(int i)
{
	if(!t[i].lzy) return;
	t[i<<1].val=t[i<<1].val*t[i].tag;
	t[i<<1|1].val=t[i<<1|1].val*t[i].tag;
	t[i<<1].tag=t[i<<1].tag*t[i].tag;
	t[i<<1|1].tag=t[i<<1|1].tag*t[i].tag;
	t[i<<1].lzy=t[i<<1|1].lzy=1;
	t[i].tag=I,t[i].lzy=0;
	return;
}
void build(int i,int l,int r)
{
	t[i].l=l,t[i].r=r,t[i].tag=I;
	if(l==r)
	{
		t[i].val.a[0][0]=a[l][1]%mod;
		t[i].val.a[0][1]=a[l][2]%mod;
		t[i].val.a[0][2]=a[l][3]%mod;
		t[i].val.a[0][3]=1;
		return;
	}
	int mid=(l+r)>>1;
	build(i<<1,l,mid);
	build(i<<1|1,mid+1,r);
	pushup(i);
	return;
}
void change(int i,int l,int r,matrix k)
{
	if(t[i].l>=l&&t[i].r<=r)
	{
		t[i].val=t[i].val*k;
		t[i].tag=t[i].tag*k;
		t[i].lzy=1;
		return;
	}
	pushdown(i);
	int mid=(t[i].l+t[i].r)>>1;
	if(l<=mid) change(i<<1,l,r,k);
	if(r>mid) change(i<<1|1,l,r,k);
	pushup(i);
	return;
}
matrix query(int i,int l,int r)
{
	if(t[i].l>=l&&t[i].r<=r) return t[i].val;
	pushdown(i);
	int mid=(t[i].l+t[i].r)>>1;
	matrix ans;
	if(l<=mid) ans=ans+query(i<<1,l,r);
	if(r>mid) ans=ans+query(i<<1|1,l,r);
	return ans;
}

int main()
{
	init();
	n=read();
	for(int i=1;i<=n;i++)
		a[i][1]=read(),a[i][2]=read(),a[i][3]=read();
	build(1,1,n);
	m=read();
	for(int i=1;i<=m;i++)
	{
		op=read(),x=read(),y=read();
		switch(op)
		{
			case 1:change(1,x,y,A);break;
			case 2:change(1,x,y,B);break;
			case 3:change(1,x,y,C);break;
			case 4:D.a[3][0]=read();change(1,x,y,D);break;
			case 5:E.a[1][1]=read();change(1,x,y,E);break;
			case 6:F.a[3][2]=read();change(1,x,y,F);break;
			case 7:matrix ans=query(1,x,y);cout<<ans.a[0][0]<<" "<<ans.a[0][1]<<" "<<ans.a[0][2]<<endl;break;
		}
	}
	return (0-0);
} 
```

---

## 作者：Tommy_Keen (赞：3)

## tips

- 前置知识：**线段树** 和 **矩阵乘法**。

- 此题需要**卡常**，下面的代码**无法通过**此题。（会 TLE ，~~当然吸氧可过~~）

- 此题的代码实现比较难，~~如果你还没有做好心理准备，请**不要尝试**此题。~~

题意复杂，请[自行查看](https://www.luogu.com.cn/problem/P7453)。

## 思路

把每一个水晶球视为一个四元组 $(a_i,b_i,c_i,1)$ ，其中 $1$ 是方便做矩阵乘法修改而添加的常数项。

用**线段树**维护某个下标区间的 $a_i$ 和、 $b_i$ 和、 $c_i$ 和。

题目中的六种操作，均可以使用**矩阵乘法**表示。

$(1)$ $a_i=a_i+b_i$ ：
$\begin{bmatrix}1&1&0&0\\0&1&0&0\\0&0&1&0\\0&0&0&1\end{bmatrix}$

$(2)$ $b_i=b_i+c_i$ ：
$\begin{bmatrix}1&0&0&0\\0&1&1&0\\0&0&1&0\\0&0&0&1\end{bmatrix}$

$(3)$ $c_i=c_i+a_i$ ：
$\begin{bmatrix}1&0&0&0\\0&1&0&0\\1&0&1&0\\0&0&0&1\end{bmatrix}$

$(4)$ $a_i=a_i+v$ ：
$\begin{bmatrix}1&0&0&v\\0&1&0&0\\0&0&1&0\\0&0&0&1\end{bmatrix}$

$(5)$ $b_i=b_i * v$ ：
$\begin{bmatrix}1&0&0&0\\0&v&0&0\\0&0&1&0\\0&0&0&1\end{bmatrix}$

$(6)$ $c_i=v$ ：
$\begin{bmatrix}1&0&0&0\\0&1&0&0\\0&0&0&v\\0&0&0&1\end{bmatrix}$

注：下面的代码中把横纵坐标颠倒了，但意思相同。

由于矩阵乘法具有结合律和分配律，对一个区间的修改等同于对区间求和后再修改，如：

对区间 $[1,3]$ 上的 $a$ 而言， $a_1*G+a_2*G+a_3*G= (a_1+a_2+a_3)*G$ 

因此，在线段树上用懒标记记录**区间做过的修改对应的矩阵之积**。

查询时，再用区间和四元组乘上修改矩阵即可。

~~说的倒是轻巧。~~

## 代码

```cpp
/***********************
Editor: Tommy_Keen 
***********************/
#include <bits/stdc++.h>
#define int long long//中间的过程会爆int，如果您疯狂取模，会TLE 
using namespace std;
const int mod = 998244353;
const int N = 250010;
int n,m,ans[5][5];//此份代码二维数组的下标都是5，如果想要通过此题，需要令其为4 
struct Mat {
	int a[5][5];
	Mat() {
		memset(a,0,sizeof(a));
	}
	Mat operator * (const Mat &x) {
		Mat c;
		for(register int i = 1; i <= 4; ++i) {
			for(register int j = 1; j <= 4; ++j) {
				for(register int k = 1; k <= 4; ++k) {
					c.a[i][j] = c.a[i][j]+a[i][k]*x.a[k][j]%mod;
					c.a[i][j] -= (c.a[i][j]>=mod) ? mod : 0;//减少取模，卡常 
				}
			}
		}
		return c;
	}
} sum[N<<2],tag[N<<2],unit,tmp;//unit是单位矩阵 

void Unit() {
	for(register int i = 1; i <= 4; ++i) {
		for(register int j = 1; j <= 4; ++j) {
			if(i == j) unit.a[i][j] = 1;
			else unit.a[i][j] = 0;
		}
	}
}

int lc(int x) {
	return x<<1;
}
int rc(int x) {
	return x<<1|1;
}
void pushup(int u) {
	for(register int i = 1; i <= 4; ++i) {
		sum[u].a[1][i] = sum[lc(u)].a[1][i]+sum[rc(u)].a[1][i];
		sum[u].a[1][i] -= (sum[u].a[1][i] >= mod) ? mod : 0;
	}
}
void pushdown(int u) {
	bool flag = true;
	for(register int i = 1; i <= 4; ++i) {
		for(register int j = 1; j <= 4; ++j) {
			if(tag[u].a[i][j] != unit.a[i][j]) {
				flag = false;
				break;
			}
		}
	}
	if(flag) return;//如果tag[u]和单位矩阵相同，则不必转移，转了也没用 
	tag[lc(u)] = tag[lc(u)] * tag[u];
	tag[rc(u)] = tag[rc(u)] * tag[u];
	sum[lc(u)] = sum[lc(u)] * tag[u];
	sum[rc(u)] = sum[rc(u)] * tag[u];
	tag[u] = unit;//清空lazy tag 
}
void build(int u,int l,int r) {
	tag[u] = unit;//初始化lazy tag 
	if(l == r) {
		scanf("%lld",&sum[u].a[1][1]);
        scanf("%lld",&sum[u].a[1][2]);
        scanf("%lld",&sum[u].a[1][3]); 
        //少开点儿数组？ 
        sum[u].a[1][4] = 1;
	} else {
		int mid = (l+r)>>1;
		build(lc(u),l,mid);
		build(rc(u),mid+1,r);
		pushup(u);
	}
}
void modify(int u,int l,int r,int x,int y,Mat v) {
	if(x <= l && y >= r) {
		sum[u] = sum[u]*v;
		tag[u] = tag[u]*v;
		//因为是矩阵乘法，所以顺序不能颠倒！！！ 
    } else {
    	int mid = (l+r)>>1;
		pushdown(u);
    	if(x <= mid) modify(lc(u),l,mid,x,y,v);
    	if(y > mid) modify(rc(u),mid+1,r,x,y,v);
    	pushup(u);
	}
}
void query(int u,int l,int r,int x,int y) {
	if(x <= l && y >= r) {
		for (register int i = 1; i <= 3; i++) {//答案只需要前三个，所以少枚举一次，卡常(？) 
        	ans[1][i] = ans[1][i]+sum[u].a[1][i];
        	ans[1][i] -= (ans[1][i]>=mod) ? mod : 0;
		}
	} else {
		int mid = (l+r)>>1;
		pushdown(u);
		if(x <= mid) query(lc(u),l,mid,x,y);
		if(y > mid) query(rc(u),mid+1,r,x,y);
	}
}

signed main() {
	Unit();
	scanf("%lld",&n);
	build(1,1,n);
	scanf("%lld",&m);
	for(register int i = 1, opt, l, r, v; i <= m; ++i) {
		tmp = unit;
		scanf("%lld%lld%lld",&opt,&l,&r);
		if(opt == 1) {
			tmp.a[2][1] = 1;
			modify(1,1,n,l,r,tmp);
			continue;
		}
		if(opt == 2) {
			tmp.a[3][2] = 1;
			modify(1,1,n,l,r,tmp);
			continue;
		}
		if(opt == 3) {
			tmp.a[1][3] = 1;
			modify(1,1,n,l,r,tmp);
			continue;
		}
		if(opt == 4) {
			scanf("%lld",&v);
			tmp.a[4][1] = v;
			modify(1,1,n,l,r,tmp);
			continue;
		}
		if(opt == 5) {
			scanf("%lld",&v);
			tmp.a[2][2] = v;
			modify(1,1,n,l,r,tmp);
			continue;
		}
		if(opt == 6) {
			scanf("%lld",&v);
			tmp.a[3][3] = 0;
			tmp.a[4][3] = v;
			modify(1,1,n,l,r,tmp);
			continue;
		}
		if(opt == 7) {
			memset(ans,0,sizeof(ans));
			query(1,1,n,l,r);
			printf("%lld %lld %lld\n",ans[1][1],ans[1][2],ans[1][3]);
			continue;
		}
	}
	return 0;
}
```

---

## 作者：OrezTsim (赞：2)

从 OI - Wiki 上跑过来的。

首先看到区间操作，考虑线段树。

看到轮换式这样朴素线段树维护不了的东西，考虑矩阵乘法。

因为矩阵乘法具有结合律，所以线段树区间合并支持矩阵合并。

状态很好设，显然三个变量以及一个常数，$[A,B,C,x]$。

下面令其每个元素的位置分别为 $1,2,3,4$。

这题大致解法就出来了，下面考虑细节。

---

### $1$ 至 $3$ 操作如何解决

对于 $1$ 操作，有 $[A,B,C,x]\leftarrow[A+B,B,C,x]$。

考虑一个 $4\times4$ 的矩阵 $M$ 和原状态 $[A,B,C,x]$ 的关系。

对于第一列来说，第一列从上往下第 $i$ 个元素 $a_{i,1}$ 表示往目标状态的第一个位置添加 $a_{i,1}\times A$。

同理可推出 $B,C,x$ 的规律。

那么很显然，当前矩阵应该为

$\begin{bmatrix}1\space\space0\space\space0\space\space0\\1\space\space1\space\space0\space\space0\\0\space\space0\space\space1\space\space0\\0\space\space0\space\space0\space\space1\end{bmatrix}$

目标位置 $1$ 为 $1\times A+1\times B+0\times C+0\times x=A+B$。

即终止状态为 $[A+B,B,C,x]$。

同理可以推出 $2$ 操作和 $3$ 操作的矩阵。

$\begin{bmatrix}1\space\space0\space\space0\space\space0\\0\space\space1\space\space0\space\space0\\0\space\space1\space\space1\space\space0\\0\space\space0\space\space0\space\space1\end{bmatrix}$

$\begin{bmatrix}1\space\space0\space\space1\space\space0\\0\space\space1\space\space0\space\space0\\0\space\space0\space\space1\space\space0\\0\space\space0\space\space0\space\space1\end{bmatrix}$

---

### $4$ 至 $7$ 操作如何解决

同理，$4$ 操作为 $[A,B,C,x]\leftarrow[A+v,B,C,x]$。

考虑利用常数项 $x$。

特殊地，在线段树的叶子节点，$x=1$。

那么考虑 $[A,B,C,1]\leftarrow[A+v,B,C,1]$。

考虑在目标位置 $1$ 加入系数为 $v$ 的常数项 $1$。具体地，矩阵长这样。

$\begin{bmatrix}1\space\space0\space\space0\space\space0\\0\space\space1\space\space0\space\space0\\0\space\space0\space\space1\space\space0\\v\space\space0\space\space0\space\space1\end{bmatrix}$

那么目标位置 $1$ 为 $1\times A+0\times B+0\times C+v\times 1=A+v$，搞定。

对于 $5$ 操作，变为乘法，考虑把目标位置 $2$ 变为系数为 $v$ 的 $B$，矩阵长这样。

$\begin{bmatrix}1\space\space0\space\space0\space\space0\\0\space\space v\space\space0\space\space0\\0\space\space0\space\space1\space\space0\\0\space\space0\space\space0\space\space1\end{bmatrix}$

目标位置 $2$ 为 $0\times A+v\times B+0\times C+0\times 1=v\times B$。

同理有 $6$ 操作，直接把目标位置 $2$ 变为系数为 $v$ 的常数项 $1$。

$\begin{bmatrix}1\space\space0\space\space0\space\space0\\0\space\space 1\space\space0\space\space0\\0\space\space0\space\space0\space\space 0\\0\space\space0\space\space v\space\space1\end{bmatrix}$

目标位置 $3$ 为 $0\times A+0\times B+0\times C+v\times 1=v$。

另外线段树 pushup 时区间的长度（即操作自带的系数）为两个子区间的长度和而非 $1$。

考虑在 pushup 的时候更新常数项 $x=r-l+1$，即区间长度，作为区间全体操作的系数。

由于所有要维护的信息都是可以直接合并的，所以对于 $4$ 个元素 $[A,B,C,x]$ 直接在 pushup 时求和即可。

$7$ 询问操作直接求区间和即可，返回一个结构体并且输出。

---

### pushdown 怎么写

由于矩阵乘法具有结合律，所以在 pushdown 的时候可以直接把当前节点的懒标记乘进子结点的懒标记。

另外，初始化的时候记得将懒标记赋为单位矩阵，这样才满足初始时和一个序列做乘法不会错。

pushdown 完成后也要记得清空为单位矩阵。

---

另外，这题真的不卡常。

```cpp
#include <bits/stdc++.h>
#define int long long
#define ls ((rt) << 1)
#define rs ((rt) << 1 | 1)
using namespace std;

const int sz = 4, N = 2.5e5 + 10;
const int Mod = 998244353; int n, Q; bool ok[N << 2];

namespace fast_io {
  int it, ed, ot, t; char stk[20], bf[N + 50], ob[N + 50];
  #define gc (it == ed && (ed = (it = 0) + fread(bf, 1, N, stdin), it == ed))? EOF : bf[it++]
  template <typename T> inline void read(T &x) {
    x = 0; char ch = gc; int f = 1;
    for (; !isdigit(ch); ch = gc) if (ch == '-') f = -1;
    for (; isdigit(ch); ch = gc) x = x * 10 + (ch ^ 48); x *= f; return ;
  } template <typename T, typename ...Args>
  inline void read(T &x, Args &...args) { read(x), read(args...); }
  inline void fls() { fwrite(ob, 1, ot, stdout), ot = 0; }
  template <typename T> inline void write(T x, char opt) {
    while (x > 9) stk[++t] = 48 ^ (x % 10), x /= 10;
    for (ob[ot++] = 48 ^ x; t; ob[ot++] = stk[t--]);
    ob[ot++] = opt; if (ot > N) fls(); return ;
  }
} using fast_io::read; using fast_io::write;

struct Matrix {
  int v[sz][sz]; Matrix() { memset(v, 0, sizeof(v)); }
  inline void cl() { memset(v, 0, sizeof(v)); }
  inline void dl() { for (int i = 0; i < sz; ++i) v[i][i] = 1; }
  inline Matrix operator *(const Matrix &X) const {
    Matrix res; for (int i = 0; i < sz; ++i)
      for (int k = 0; k < sz; ++k) for (int j = 0; j < sz; ++j)
        res.v[i][j] = (res.v[i][j] + v[i][k] * X.v[k][j] % Mod) % Mod;
    return res;
  }
} ml[7], tag[N << 2];

struct Node {
  int st[sz]; Node() { fill(st, st + sz, 0); }
  inline void init(int a, int b, int c) {
    st[0] = a, st[1] = b, st[2] = c, st[3] = 1;
  } inline Node operator *(const Matrix &X) {
    Node res; for (int j = 0; j < sz; ++j)
      for (int i = 0; i < sz; ++i)
        res.st[i] = (res.st[i] + st[j] * X.v[j][i] % Mod) % Mod;
    return res;
  } inline Node operator +(const Node &X) const {
    Node res; for (int i = 0; i < sz; ++i)
      res.st[i] = (st[i] + X.st[i]) % Mod;
    return res;
  }
} t[N << 2];

inline void init() {
  for (int i = 1; i <= 6; ++i) {
    for (int j = 0; j < sz; ++j) ml[i].v[j][j] = 1;
    if (i == 1) ml[i].v[1][0] = 1;
    else if (i == 2) ml[i].v[2][1] = 1;
    else if (i == 3) ml[i].v[0][2] = 1;
  }
  return ;
}

inline void pushdown(int rt, int l, int r) {
  if (!ok[rt]) return ; ok[ls] = ok[rs] = ok[rt];
  t[ls] = t[ls] * tag[rt], t[rs] = t[rs] * tag[rt];
  tag[ls] = tag[ls] * tag[rt], tag[rs] = tag[rs] * tag[rt];
  ok[rt] = false; tag[rt].cl(), tag[rt].dl(); return ;
}

inline void build(int rt, int l, int r) {
  tag[rt].dl();
  if (l == r) {
    int a, b, c; read(a, b, c);
    t[rt].init(a, b, c); return ;
  }
  int mid = (l + r) >> 1;
  build(ls, l, mid), build(rs, mid + 1, r);
  t[rt] = t[ls] + t[rs]; return ;
}

inline void upd(int rt, int l, int r, int L, int R, int typ) {
  if (L <= l && r <= R) {
    t[rt] = t[rt] * ml[typ]; ok[rt] = true;
    tag[rt] = tag[rt] * ml[typ]; return ;
  }
  pushdown(rt, l, r); int mid = (l + r) >> 1;
  if (L <= mid) upd(ls, l, mid, L, R, typ); if (R > mid) upd(rs, mid + 1, r, L, R, typ);
  t[rt] = t[ls] + t[rs]; return ;
}

inline Node query(int rt, int l, int r, int L, int R) {
  if (L <= l && r <= R) return t[rt];
  pushdown(rt, l, r); int mid = (l + r) >> 1;
  int tar = 0; Node lef, rig;
  if (L <= mid) ++tar, lef = query(ls, l, mid, L, R);
  if (R > mid) tar += 2, rig = query(rs, mid + 1, r, L, R);
  if (tar == 1) return lef; if (tar == 2) return rig;
  return lef + rig;
}

inline void solve() {
  int op, l, r, vl; read(op, l, r);
  if (op <= 3) return upd(1, 1, n, l, r, op), void();
  if (op <= 6) {
    read(vl); if (op == 4) ml[op].v[3][0] = vl;
    else if (op == 5) ml[op].v[1][1] = vl;
    else ml[op].v[2][2] = 0, ml[op].v[3][2] = vl;
    return upd(1, 1, n, l, r, op), void();
  }
  Node tmp = query(1, 1, n, l, r);
  for (int i = 0; i < sz - 1; ++i) write(tmp.st[i], ' ');
  fast_io::ob[fast_io::ot++] = '\n';
  if (fast_io::ot > N) fast_io::fls(); return ;
}

signed main() {
  init(); read(n); build(1, 1, n);
  read(Q); while (Q--) solve();
  fast_io::fls(); return 0;
}
```

---

## 作者：dicrev (赞：2)

# P7453 [THUSCH2017] 大魔法师

~~又到了爷最爱的矩阵时间~~

首先这道题根据题意需要一个支持区间修改与区间查询的数据结构，没错就是线段树。确定了线段树后，我们发现这道题要求的水晶球由三个数据组成。本来我想的是对这三个数据分别打一个线段树，但问题是它们之间存在联系，如果分别打的话在区间修改的时候会非常麻烦。这时我就想到：既然这三个数据之间存在联系，那么我是否可以用矩阵刻划它们的关系呢？

一开始我想的是开 $1 \times 3$ 的矩阵存数据，开 $3 \times 3$ 的矩阵存状态，这种矩阵在面对除了状态 $4$ 以外的情况都很方便。

数据存储：$\begin{bmatrix}A&B&C\end{bmatrix}$

转移状况：

1：$\begin{bmatrix}1&0&0\\1&1&0\\0&0&1\end{bmatrix}$

2：$\begin{bmatrix}1&0&0\\0&1&0\\0&1&1\end{bmatrix}$

3：$\begin{bmatrix}1&0&1\\0&1&0\\0&0&1\end{bmatrix}$

写到 $4$ 的时候问题来了：在只开了三位的情况下 $+v$ 怎么表示呢？没法表示。当然解决方法也很简单：多加一位值为 $1$ 的存储位即可(由于矩阵和操作，这一位在线段树内标志着区间长度)。

数据存储：$\begin{bmatrix}A&B&C&1\end{bmatrix}$

转移状况：

1：$\begin{bmatrix}1&0&0&0\\1&1&0&0\\0&0&1&0\\0&0&0&1\end{bmatrix}$

2：$\begin{bmatrix}1&0&0&0\\0&1&0&0\\0&1&1&0\\0&0&0&1\end{bmatrix}$

3：$\begin{bmatrix}1&0&1&0\\0&1&0&0\\0&0&1&0\\0&0&0&1\end{bmatrix}$

4：$\begin{bmatrix}1&0&0&v\\0&1&0&0\\0&0&1&0\\0&0&0&1\end{bmatrix}$

5：$\begin{bmatrix}1&0&0&0\\0&v&0&0\\0&0&1&0\\0&0&0&1\end{bmatrix}$

6：$\begin{bmatrix}1&0&0&0\\0&1&0&0\\0&0&0&v\\0&0&0&1\end{bmatrix}$

在写的时候注意一点：线段树的 $lazy$ 值存储的是未转移状态而不是未转移数据，所以应该用 $3 \times 3$ 的数组存；

```cpp
//#pragma GCC optimize(1)
//#pragma GCC optimize(2)
//#pragma GCC optimize(3,"Ofast","inline")
//这几个是洛谷编译不给过的O(1)到O(3)优化，只能手动开O(2)
#include<iostream>
using namespace std;
const long long m=998244353ll;
long long cnt,n,OPT,L,R,V;//用大写是为了防止函数调用时冲突
inline long long read(){
    long long x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}//快读
inline void write(long long x){
	if(x>9) write(x/10);
	putchar(x%10+'0');
}//快写
struct jsjz{
	long long num[4];
	void csh(){
		num[0]=num[1]=num[2]=0;
		num[3]=1;
	}//初始化为A,B,C为0的情况
	void zero(){
		num[3]=num[0]=num[1]=num[2]=0;
	}//初始化为0矩阵
}sjq[250005],sc;//计算矩阵(存数据)
struct zyjz{
	long long num[4][4];
	void one(){
		num[0][0]=num[1][1]=num[2][2]=num[3][3]=1;
		num[0][1]=num[0][2]=num[0][3]=num[1][0]=num[1][2]=num[1][3]=num[2][0]=num[2][1]=num[2][3]=num[3][0]=num[3][1]=num[3][2]=0;
	}//初始化为单位矩阵(别问为什么用连等,问就卡常)
	void zero(){
		num[0][0]=num[1][1]=num[2][2]=num[3][3]=num[0][1]=num[0][2]=num[0][3]=num[1][0]=num[1][2]=num[1][3]=num[2][0]=num[2][1]=num[2][3]=num[3][0]=num[3][1]=num[3][2]=0;
	}//初始化为0矩阵(连等原因同上)
}zy,mljf[3],dw1;//转移矩阵(存状态)
inline zyjz operator *(zyjz a,zyjz b){
	zyjz x;
	x.zero();
	for(char i=0;i<4;i++){
		for(char j=0;j<4;j++){
			for(char p=0;p<4;p++){
				x.num[i][j]=(x.num[i][j]+(a.num[i][p]*b.num[p][j])%m)%m;
			}
		}
	}
	return x;
}//重载转移矩阵*转移矩阵
inline zyjz operator -(zyjz a,long long b){
	for(char i=0;i<4;i++){
		a.num[i][i]-=b;
	}
	return a;
}//重载转移矩阵-b个单位矩阵
inline jsjz operator *(jsjz a,zyjz b){
	jsjz out;
	out.zero();
	for(char i=0;i^4;i++){
		for(char j=0;j^4;j++){
			out.num[i]=(out.num[i]+(a.num[j]*b.num[j][i])%m)%m;
		}
	}
	return out;
}//重载计算矩阵*转移矩阵
inline jsjz operator +(jsjz a,jsjz b){
	jsjz out;
	out.num[3]=1;
	for(char i=0;i^4;i++){
		out.num[i]=(a.num[i]+b.num[i])%m;
	}
	return out;
}//重载计算矩阵+计算矩阵
bool operator !=(zyjz a,zyjz b){
	bool is=true;
	for(char i=0;is&&i^4;i++){
		for(char j=0;is&&j^4;j++){
			is=(!(a.num[i][j]^b.num[i][j]));
		}
	}
	return !is;
}//重载转移矩阵!=转移矩阵
inline zyjz zq(long long opt,long long v){
	zyjz out;
	out.one();
	if(!opt){
		out.num[3][0]=v;
	}
	else if(opt&1){
		out.num[1][1]=v;
	}
	else{
		out.num[2][2]=0;
		out.num[3][2]=v;
	}
	return out;
}//按4-6的情况给矩阵赋v
struct node{
	zyjz lazy;
	jsjz val;
	long long l,r,lc,rc;
}tree[1000005];//定义线段树节点
inline void build(long long now,long long l,long long r){
	long long mid=(l+r)>>1;
	tree[now].l=l;
	tree[now].r=r;
	tree[now].lazy=dw1;//懒标记初始化为单位矩阵
	if(l^r){//判断l,r是否相等
		tree[now].lc=++cnt;
		build(cnt,l,mid);
		tree[now].rc=++cnt;
		build(cnt,mid+1,r);
		tree[now].val=tree[tree[now].lc].val+tree[tree[now].rc].val;//初始化为两儿子的数据和
	}
	else{
		tree[now].val=sjq[l];//初始化为对应水晶球的数据
	}
}//建树
inline jsjz addd(zyjz a,long long now,long long l,long long r){
	jsjz re;//储存此次数据变化
	if(!(tree[now].l^tree[now].r)){
		re=tree[now].val;
		tree[now].val=tree[now].val*a;
		sjq[l]=tree[now].val;
		return re*(a-1);//注意此操作由于取模 可 能 会 使 矩 阵 出 现 负 数
	}//是否为“叶子”节点
	else if(!(l^tree[now].l||r^tree[now].r)){
		re=tree[now].val;
		tree[now].lazy=tree[now].lazy*a;
		tree[now].val=tree[now].val*a;
		return re*(a-1);//注意此操作由于取模 可 能 会 使 矩 阵 出 现 负 数
	}//是否与当前区间长一致
	long long mid=(tree[now].l+tree[now].r)>>1;
	if(tree[now].lazy!=dw1){
		addd(tree[now].lazy,tree[now].lc,tree[now].l,mid);
		addd(tree[now].lazy,tree[now].rc,mid+1,tree[now].r);
		tree[now].lazy=dw1;
	}//懒标记下放
	if(l>mid){
		re=addd(a,tree[now].rc,l,r);
		tree[now].val=tree[now].val+re;
	}
	else if(r<=mid){
		re=addd(a,tree[now].lc,l,r);
		tree[now].val=tree[now].val+re;
	}
	else{
		re=addd(a,tree[now].lc,l,mid)+addd(a,tree[now].rc,mid+1,r);
		tree[now].val=tree[now].val+re;
	}
	return re;
}//区间加
inline jsjz summ(long long now,long long l,long long r){
	if(!(l^tree[now].l||r^tree[now].r)){
		return tree[now].val;
	}//查询长度是否等于节点长
	long long mid=(tree[now].l+tree[now].r)>>1;
	jsjz re;
	if(tree[now].lazy!=dw1){
		addd(tree[now].lazy,tree[now].lc,tree[now].l,mid);
		addd(tree[now].lazy,tree[now].rc,mid+1,tree[now].r);
		tree[now].lazy=dw1;
	}//懒标记下放
	if(l>mid){
		re=summ(tree[now].rc,l,r);
	}
	else if(r<=mid){
		re=summ(tree[now].lc,l,r);
	}
	else{
		re=summ(tree[now].lc,l,mid)+summ(tree[now].rc,mid+1,r);
	}
	return re;
}//区间和
int main(){
	mljf[0].one();
	dw1=mljf[1]=mljf[2]=mljf[0];
	for(long long i=0;i^3;i++){
		mljf[i].num[(i+1)%3][i]=1;
	}//1-3状态转移矩阵初始化
	n=read();
	for(long long i=1;i<=n;i++){
		sjq[i].num[0]=read();
		sjq[i].num[1]=read();
		sjq[i].num[2]=read();
		sjq[i].num[3]=1;
	}//获取水晶球初始数据
	build(0,1,n);//建树
	n=read();
	for(long long arcaea=0;arcaea^n;arcaea++){
		OPT=read();
		L=read();
		R=read();
		if(OPT<4){
			addd(mljf[OPT-1],0,L,R);
		}
		else if(!(OPT^7)){
			sc=summ(0,L,R);
			while(sc.num[0]<0){
				sc.num[0]+=m;
			}//这里是处理上文提到的矩阵可能出现负数的问题
			write(sc.num[0]);
			putchar(' ');
			while(sc.num[1]<0){
				sc.num[1]+=m;
			}//也是
			write(sc.num[1]);
			putchar(' ');
			while(sc.num[2]<0){
				sc.num[2]+=m;
			}//还是
			write(sc.num[2]);
			putchar('\n');
		}
		else{
			V=read();
			addd(zq(OPT-4,V),0,L,R);
		}
	}
	return 0;
}
```


---

## 作者：DiruiXiao (赞：2)

## [P7453 [THUSCH2017] 大魔法师](https://www.luogu.com.cn/problem/P7453)

**【题意简述】**

请看题面自行理解。

**【解题思路】**

**本题卡常，请注意常数优化**

这道题其实时一道思维难度不算大但是码量惊人的数据结构毒瘤题。

观察操作，发现全是区查区改，显然的线段树维护。然而发现该题的运算、优先级错综复杂，手写上下传函数很可能写爆掉。

于是考虑矩阵线段树。矩阵线段树通过构造转移矩阵 $T$，使得节点间的上下传中 $tag$ 的改变可以通过与 $T$ 做矩阵乘法实现。又由于矩阵乘法不具有交换律，因此可以方便快捷的维护带运算优先级的问题。而最终答案则是由 $tag$ 矩阵和保存节点信息的矩阵相乘而来。

首先考虑构造 $V$ 向量，用于在树的节点中保存所维护的信息。

则显然 $V=\begin{bmatrix}S_A,S_B,S_C,L\end{bmatrix}$，其中 $L$ 表示该区间的长度，$S_A$ 表示该区间的 $A$ 的和，$S_B$，$S_C$ 同理。

考虑 $O$ 作为节点的 $tag$，则显然 $O$ 应该初始化为 $4\times4$ 的单位矩阵。

最后考虑对于每个操作构建出一个转移矩阵 $T_i$，然后对于每次修改都乘上转移矩阵即可。

在题解中已经有很多转移矩阵了，这里就不再赘述。

最后注意修改、上下传函数中乘的顺序即可。

```cpp
#include<bits/stdc++.h>
#define MOD 998244353
#define MAXN 250005
using namespace std;
template<typename T>
inline void read(T &x) {
	x = 0; char ch = getchar();
	T f = 1;
	while (ch < '0' || ch > '9') {
		ch == '-' ? f = -1 : 1;
		ch = getchar();
	}
	while (ch <= '9' && ch >= '0') {
		x = (x << 3) + (x << 1) + (ch ^ 48);
		ch = getchar();
	}
	x *= f;
}

template <typename item>
inline void print(item x) {
	int c[35], len = 0;
	if (x < 0) putchar('-'), x = -x;
	if (x == 0) { putchar('0'); return;}
	while (x) c[len++] = x % 10, x /= 10;
	while (len) putchar(c[--len] + '0');
}

struct Matrix{
	int a[4][4], h, w;
	inline void emp() {
		memset(a, 0, sizeof(a));
	}
	inline void clear() {
		memset(a, 0, sizeof(a));
		for (int i = 0; i < 4; ++i) a[i][i] = 1;	
	}
};

Matrix operator + (const Matrix &a, const Matrix &b) {
	Matrix ret; ret.h = 1, ret.w = 4;
	for (int i = 0; i < 4; ++i) {
		ret.a[0][i] = a.a[0][i] + b.a[0][i];
		ret.a[0][i] %= MOD;
	}
	return ret;
}

Matrix operator * (const Matrix &a, const Matrix &b) {
	Matrix ret; ret.emp();
	ret.h = a.h, ret.w = b.w;
	for (int i = 0; i < a.h; ++i) {
		for (int k = 0; k < a.w; ++k) {
			for (int j = 0; j < b.w; ++j) {
				ret.a[i][j] += (1ll * a.a[i][k] * b.a[k][j]) % MOD;
				ret.a[i][j] %= MOD;
			}
		}
	}
	return ret;
}

struct Node{
	int L, R;
	Matrix tag, val;
} tree[MAXN << 2];

Matrix magic[MAXN];

inline void pushup(int x) {
	tree[x].val = tree[x << 1].val + tree[x << 1 | 1].val;
}

inline void pushdown(int x) {
	tree[x << 1].tag = tree[x << 1].tag * tree[x].tag;
	tree[x << 1 | 1].tag = tree[x << 1 | 1].tag * tree[x].tag;
	tree[x << 1].val = tree[x << 1].val * tree[x].tag;
	tree[x << 1 | 1].val = tree[x << 1 | 1].val * tree[x].tag;
	tree[x].tag.clear();
}

inline void build(int x, int L, int R) {
	tree[x].L = L, tree[x].R = R;
	tree[x].tag.clear();
	tree[x].val.h = 1, tree[x].val.w = 4;
	tree[x].tag.h = tree[x].tag.w = 4;
	if (L == R) {
		tree[x].val = magic[L];
		return;
	}
	int mid = (L + R) >> 1;
	build(x << 1, L, mid);
	build(x << 1 | 1, mid + 1, R);
	pushup(x);
}

inline void change(int x, int L, int R, const Matrix &tag) {
	if (L <= tree[x].L && tree[x].R <= R) {
		tree[x].val = tree[x].val * tag;
		tree[x].tag = tree[x].tag * tag;
		return;
	}
	pushdown(x);
	int mid = (tree[x].L + tree[x].R) >> 1;
	if (L <= mid) change(x << 1, L, R, tag);
	if (R > mid) change(x << 1 | 1, L, R, tag);
	pushup(x);
}

inline Matrix query(int x, int L, int R) {
	if (L <= tree[x].L && tree[x].R <= R) {
		return tree[x].val;
	}
	pushdown(x);
	Matrix ans; ans.h = 1, ans.w = 4; ans.emp();
	int mid = (tree[x].L + tree[x].R) >> 1;
	if (L <= mid) ans = ans + query(x << 1, L, R);
	if (R > mid) ans = ans + query(x << 1 | 1, L, R);
	return ans;
}

Matrix OP[7];

int main() {
	int n; read(n);
	for (int i = 1; i <= n; ++i) {
		read(magic[i].a[0][0]), read(magic[i].a[0][1]), read(magic[i].a[0][2]);
		magic[i].a[0][3] = 1;
		magic[i].h = 1, magic[i].w = 4;
	}
	build(1, 1, n);
	int m; read(m);
	for (int i = 1; i <= 8; ++i) {
		OP[i].clear();
		OP[i].h = OP[i].w = 4;
	}
	OP[1].a[1][0] = 1;
	OP[2].a[2][1] = 1;
	OP[3].a[0][2] = 1;
	OP[6].a[2][2] = 0;
	while (m--) {
		int opt, l, r,v; read(opt), read(l), read(r);
		if (opt == 1) {
			change(1, l, r, OP[1]);
		} else if (opt == 2) {
			change(1, l, r, OP[2]);
		} else if (opt == 3) {
			change(1, l, r, OP[3]);
		} else if (opt == 4) {
			read(v);
			OP[4].a[3][0] = v;
			change(1, l, r, OP[4]);
		} else if (opt == 5) {
			read(v);
			OP[5].a[1][1] = v;
			change(1, l, r, OP[5]);
		} else if (opt == 6) {
			read(v);
			OP[6].a[3][2] = v;
			change(1, l, r, OP[6]);
		} else {
			Matrix ans = query(1, l, r);
			print(ans.a[0][0]), putchar(' '), print(ans.a[0][1]), putchar(' '), print(ans.a[0][2]), putchar('\n');
		}
	}
	return 0;
}
```



---

## 作者：Phartial (赞：0)

大魔法师（x

大卡常师（v

发现前 $6$ 种魔法可以用矩阵的方式表示，具体的，把第 $i$ 个水晶球的能量用一个向量 $\begin{bmatrix}A_i\\ B_i\\ C_i\\ 1\end{bmatrix}$，表示。有常量 $1$ 的原因是 火元素能量定值增强 和 土元素能量吸收融合 需要加上或赋值一个 $v$。

考虑怎么用矩阵表示 $6$ 种魔法：

火元素激发水元素能量：

$$
\begin{bmatrix}
1 & 1 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 0 & 1
\end{bmatrix}\begin{bmatrix}A_i\\ B_i\\ C_i\\ 1\end{bmatrix}=\begin{bmatrix}A_i+B_i\\ B_i\\ C_i\\ 1\end{bmatrix}
$$

土元素激发火元素能量：

$$
\begin{bmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 1 & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 0 & 1
\end{bmatrix}\begin{bmatrix}A_i\\ B_i\\ C_i\\ 1\end{bmatrix}=\begin{bmatrix}A_i\\ B_i+C_i\\ C_i\\ 1\end{bmatrix}
$$

水元素激发土元素能量：

$$
\begin{bmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
1 & 0 & 1 & 0\\
0 & 0 & 0 & 1
\end{bmatrix}\begin{bmatrix}A_i\\ B_i\\ C_i\\ 1\end{bmatrix}=\begin{bmatrix}A_i\\ B_i\\ C_i+A_i\\ 1\end{bmatrix}
$$

火元素能量定值增强：

$$
\begin{bmatrix}
1 & 0 & 0 & v\\
0 & 1 & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 0 & 1
\end{bmatrix}\begin{bmatrix}A_i\\ B_i\\ C_i\\ 1\end{bmatrix}=\begin{bmatrix}A_i+v\\ B_i\\ C_i\\ 1\end{bmatrix}
$$

水元素能量翻倍增强：

$$
\begin{bmatrix}
1 & 0 & 0 & 0\\
0 & v & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 0 & 1
\end{bmatrix}\begin{bmatrix}A_i\\ B_i\\ C_i\\ 1\end{bmatrix}=\begin{bmatrix}A_i\\ vB_i\\ C_i\\ 1\end{bmatrix}
$$

土元素能量吸收融合：

$$
\begin{bmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 0 & v\\
0 & 0 & 0 & 1
\end{bmatrix}\begin{bmatrix}A_i\\ B_i\\ C_i\\ 1\end{bmatrix}=\begin{bmatrix}A_i\\ B_i\\ v\\ 1\end{bmatrix}
$$

由于矩阵满足结合律，所以可以用线段树维护每个向量和区间向量和，卡亿卡常就好了（迫真


---

## 作者：Yansuan_HCl (赞：0)

前三个操作都是对 $\left( A_i, B_i, C_i\right)$ 的线性变换。操作四到六出现了 $+v$ 的操作，考虑经典套路：在行向量中维护一个 $1$, 这样就可以用矩阵乘法维护。

矩阵乘法满足结合律，所以可以上线段树。此时的操作就是区间乘、维护区间和。

**本题不卡常。**

记得乘法 `tag` 要设置成单位矩阵。

```cpp
// 这次只用了 15min 就打完了 
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const ll P = 998244353;
template <int N, int M>
struct Matrix {
	ll m[N][M];
	Matrix() { memset(m, 0, sizeof(m)); }
	ll* operator[] (int x) { return m[x - 1] - 1; }
	void one() {
		memset(m, 0, sizeof(m));
		for (int i = 1; i <= min(N, M); ++i)
			(*this)[i][i] = 1;
	}
	void clear() { memset(m, 0, sizeof(m)); }
};
template <int N, int M>
Matrix<N, M> operator + (Matrix<N, M> l, Matrix<N, M> r) {
	Matrix<N, M> m;
	for (int i = 1; i <= N; ++i)
		for (int j = 1; j <= M; ++j)
			m[i][j] = (l[i][j] + r[i][j]) % P;
	return m;
}
template <int N, int K, int M>
Matrix<N, M> operator * (Matrix<N, K>& l, Matrix<K, M>& r) {
	Matrix<N, M> m;
	for (int i = 1; i <= N; ++i)
		for (int j = 1; j <= M; ++j)
			for (int k = 1; k <= K; ++k)
				(m[i][j] += l[i][k] * r[k][j] % P) %= P;
	return m;
}

const int N = 250005;
#define mid ((l + r) >> 1)
#define LS (p << 1)
#define RS ((p << 1) | 1)
Matrix<1, 4> tr[N << 2];
Matrix<4, 4> tag[N << 2];

int n;
ll a[N], b[N], c[N];
void build(int p = 1, int l = 1, int r = n) {
	tag[p].one();
	if (l == r) {
		tr[p][1][1] = a[l];
		tr[p][1][2] = b[l];
		tr[p][1][3] = c[l];
		tr[p][1][4] = 1;
		return;
	}
	build(LS, l, mid);
	build(RS, mid + 1, r);
	tr[p] = tr[LS] + tr[RS];
}
void pushdown(int p) {
	tr[LS] = tr[LS] * tag[p];
	tr[RS] = tr[RS] * tag[p];
	tag[LS] = tag[LS] * tag[p];
	tag[RS] = tag[RS] * tag[p];
	tag[p].one();
}
void mul(int b, int e, Matrix<4, 4>& v, int p = 1, int l = 1, int r = n) {
	if (b <= l && e >= r) {
		tr[p] = tr[p] * v;
		tag[p] = tag[p] * v;
		return ;
	}
	pushdown(p);
	if (b <= mid) mul(b, e, v, LS, l, mid);
	if (e > mid) mul(b, e, v, RS, mid + 1, r);
	tr[p] = tr[LS] + tr[RS];
}
Matrix<1, 4> ans;
void query(int b, int e, int p = 1, int l = 1, int r = n) {
	if (b <= l && e >= r) { ans = ans + tr[p]; return; }
	pushdown(p);
	if (b <= mid) query(b, e, LS, l, mid);
	if (e > mid) query(b, e, RS, mid + 1, r);
}

int main() {	
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i) scanf("%lld%lld%lld", a + i, b + i, c + i);
	build();
	int q; scanf("%d", &q);
	while (q--) {
		int op, l, r, v; scanf("%d%d%d", &op, &l, &r);
		if (op >= 4 && op <= 6) scanf("%d", &v);
		Matrix<4, 4> trs; trs.one();
		switch (op) {
			case 1:
				trs[2][1] = 1; break;
			case 2:
				trs[3][2] = 1; break;
			case 3:
				trs[1][3] = 1; break;
			case 4:
				trs[4][1] = v; break;
			case 5:
				trs[2][2] = v; break;
			case 6:
				trs[3][3] = 0;
				trs[4][3] = v;
				break;
		}
		if (op <= 6) mul(l, r, trs);
		else {
			ans.clear();
			query(l, r);
			printf("%lld %lld %lld\n", ans[1][1], ans[1][2], ans[1][3]);
		}
	}
	return 0;
}
```

---

## 作者：MuYC (赞：0)

#### 废话（bushi

这道题目的难点在于要发现正解是矩阵乘法优化线段树。

这道题已经有了用 $4 \times 4$ 的矩阵维护懒标记的做法，这里带来 $3 \times 3$ 的矩阵维护懒标记做法，常数比维护 $4 \times 4$ 的矩阵的做法略小。

#### 题意

给定 $n$ 个三元组，第 $i$ 个三元组可以表示为 $(A_i,B_i,C_i)$

+ 操作 $1$ : 给定 $l,r$，区间 $[l,r]$ 内每一个三元组的 $A_i$ 变成 $A_i + B_i$

+ 操作 $2$ : 给定 $l,r$，区间 $[l,r]$ 内每一个三元组的 $B_i$ 变成 $B_i + C_i$

+ 操作 $3$ : 给定 $l,r$，$[l,r]$ 内每一个三元组的 $C_i$ 变成 $C_i + A_i$

+ 操作 $4$ : 给定 $l,r,v$，区间 $[l,r]$ 内每一个三元组的 $A_i$ 变成 $A_i + v$

+ 操作 $5$ : 给定 $l,r,v$，区间 $[l,r]$ 内每一个三元组的 $B_i$ 变成 $B_i * v$

+ 操作 $6$ : 给定 $l,r,v$，区间 $[l,r]$ 内每一个三元组的 $C_i$ 变成 $v$

+ 操作 $7$ : 给定 $l,r$，分别求区间 $\sum_{i = l}^{i = r}A_i$，$\sum_{i = l}^{i = r}B_i$，$\sum_{i = l}^{i = r}C_i$

#### 题解

这个题目的正解就是:矩阵乘法+[$luogu$线段树模板2](https://www.luogu.com.cn/problem/P3373)

为了防止 $markdown$ 炸开，决定放图片，可以到[我的博客](https://www.cnblogs.com/MYCui/p/13984440.html)里面看

![](https://cdn.luogu.com.cn/upload/image_hosting/3sbq21rj.png)


![](https://cdn.luogu.com.cn/upload/image_hosting/53tqsii2.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/700y2vbh.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/gtyv9fxb.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/q7t1lab2.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/8uzae9zy.png)

（上面的矩阵 $1 \times$ 矩阵某某需要交换一下顺序，不过这个影响不大，提出来一下！）

综上，就完成了六种修改操作。很简单的发现，这个东西用线段树比较好维护。

考虑如何下传标记。

这里发现一共要实现矩阵的乘法以及加法。

类似于线段树的模板二，也要支持序列的乘法以及加法。

将线段树模板二的序列乘法加法改为矩阵乘法加法即可。

下传：先乘后加

那么假设现在的答案矩阵为：$(x + lazadd) * lazmul$($lazadd$ 表示加法懒标记矩阵，$lazmul$ 表示乘法懒标记矩阵, $x$ 还没有传懒标记前的答案矩阵)

现在要乘以一个$t$,加上一个$k$，先将 $lazadd$ 以及 $lazmul$ 还有 $sum$ 都乘以矩阵 $t$ ，然后再将 $lazadd$ 还有 $sum$ 加上 矩阵 $k$ 即可。

实现起来有点麻烦，~~但是常数小啊~~。

### Code

代码很丑，仅供参考。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int MAXN = 250000 + 50,Mod = 998244353;
int n,Q;
int data[MAXN][3];
int mul1[3][3],mul2[3][3],mul3[3][3],mul5[3][3],mul6[3][3],Sum[3],M[3][3];

struct Node {
	int sum[3];
	int lazadd[3];
	int lazmul[3][3];
	int l , r ;
	void Clean()
	{
		for(int i = 0 ; i <= 2 ; i ++)
		{
			lazadd[i] = 0;
			for(int j = 0 ; j <= 2; j ++)
			lazmul[i][j] = 0;
			lazmul[i][i] = 1;
		}
		return ;
	}
	void ad(int Mul[3][3],int add[3])
	{
		int C[3][3] = {0};
		for(int i = 0 ; i <= 2 ; i ++)
		{
			for(int j = 0 ; j <= 2 ; j ++)
				for(int k = 0 ; k <= 2 ; k ++)
			C[i][j] += (lazmul[k][j] * Mul[i][k]) % Mod,C[i][j] %= Mod;
		}
		for(int i = 0 ; i <= 2 ; i ++)
			for(int j = 0 ; j <= 2 ; j ++)
			lazmul[i][j] = C[i][j],C[i][j] = 0;
		for(int i = 0 ; i <= 2 ; i ++)
		{
			for(int k = 0 ; k <= 2 ; k ++)
			C[i][0] += (Mul[i][k] * lazadd[k]) % Mod,C[i][0] %= Mod;
		}
		for(int i = 0 ; i <= 2 ; i ++)
			lazadd[i] = C[i][0],C[i][0] = 0,lazadd[i] += add[i],lazadd[i] %= Mod;
		for(int i = 0 ; i <= 2 ; i ++)
		{
			for(int k = 0 ; k <= 2 ; k ++)
			C[i][0] += (Mul[i][k] * sum[k]) % Mod,C[i][0] %= Mod;
		}
		for(int i = 0 ; i <= 2 ; i ++)
		sum[i] = C[i][0],sum[i] %= Mod,C[i][0] = 0,sum[i] += ((r - l + 1) * add[i]) % Mod,sum[i] %= Mod;
		return ;
	}
	
} T[MAXN * 4];

struct Output
{
	int A,B,C;
};

bool pd(int x)
{
	if(T[x].lazadd[0] || T[x].lazadd[1] || T[x].lazadd[2])return 1;
	for(int i = 0 ; i <= 2 ; i ++)
		for(int j = 0 ; j <= 2 ; j ++)
	if(M[i][j] != T[x].lazmul[i][j])return 1;
	return 0;
}

void pushdown(int x)
{
	if(pd(x) == 0) return;
	T[x << 1].ad(T[x].lazmul,T[x].lazadd);
	T[x << 1 | 1].ad(T[x].lazmul,T[x].lazadd);
	T[x].Clean();
	return ;
}
void build(int x,int l,int r)
{
	T[x].l = l , T[x].r = r;
	T[x].Clean();
	if(l == r)
	{
		T[x].sum[0] = data[l][0];T[x].sum[0] %= Mod;
		T[x].sum[1] = data[l][1];T[x].sum[1] %= Mod;
		T[x].sum[2] = data[l][2];T[x].sum[2] %= Mod;
		return ;
	}dianwo
	int mid = ( l + r ) >> 1;
	build(x << 1 , l , mid );
	build(x << 1 | 1 , mid + 1 , r);
	T[x].sum[0] = T[x << 1].sum[0] % Mod + T[x << 1 | 1].sum[0] % Mod;T[x].sum[0] %= Mod;
	T[x].sum[1] = T[x << 1].sum[1] % Mod + T[x << 1 | 1].sum[1] % Mod;T[x].sum[1] %= Mod;
	T[x].sum[2] = T[x << 1].sum[2] % Mod + T[x << 1 | 1].sum[2] % Mod;T[x].sum[2] %= Mod;
	return ;
}

void prepare()
{
	for(int i =  0 ; i <= 2 ; i ++)
	{
		for(int j = 0 ; j <= 2 ; j ++)
		mul1[i][j] = mul2[i][j] = mul3[i][j] = mul5[i][j] = mul6[i][j] = 0ll;
		mul1[i][i] = mul2[i][i] = mul3[i][i] = mul5[i][i] = mul6[i][i] = 1ll;
		M[i][i] = 1;
	}
	mul1[0][1] = 1ll;
	mul2[1][2] = 1ll;
	mul3[2][0] = 1ll;
	mul6[2][2] = 0ll;
	return ;
}

Output Add(Output A, Output B)
{
	A.A += B.A;A.A %= Mod;
	A.B += B.B;A.B %= Mod;
	A.C += B.C;A.C %= Mod;
	return A;
}

Output GetSum(int x,int l,int r)
{
	Output Ans;
	Ans.A = Ans.B = Ans.C = 0ll;
	if(T[x].l >= l && T[x].r <= r)
	{
		Ans.A = T[x].sum[0] % Mod;
		Ans.B = T[x].sum[1] % Mod;
		Ans.C = T[x].sum[2] % Mod;
		return Ans;
	}
	pushdown(x);
	int mid = (T[x].l + T[x].r) >> 1;
	if(l <= mid)Ans = Add(Ans,GetSum(x << 1 , l , r));
	if(r  > mid)Ans = Add(Ans,GetSum(x << 1 | 1 , l, r));
	Ans.A %= Mod;
	Ans.B %= Mod;
	Ans.C %= Mod;
	return Ans;
}

void change(int x,int l,int r,int op)
{
	if(T[x].l >= l && T[x].r <= r)
	{
		if(op == 1)T[x].ad(mul1,Sum);
		if(op == 2)T[x].ad(mul2,Sum);
		if(op == 3)T[x].ad(mul3,Sum);
		if(op == 4)T[x].ad(M,Sum);
		if(op == 5)T[x].ad(mul5,Sum);
		if(op == 6)T[x].ad(mul6,Sum);
		return ;
	}
	pushdown(x);
	int mid = (T[x].l + T[x].r) >> 1;
	if(l <= mid)change(x << 1 , l , r , op);
	if(r  > mid)change(x << 1 | 1 , l, r , op);
	T[x].sum[0] = T[x << 1].sum[0] % Mod + T[x << 1 | 1].sum[0] % Mod;T[x].sum[0] %= Mod;
	T[x].sum[1] = T[x << 1].sum[1] % Mod + T[x << 1 | 1].sum[1] % Mod;T[x].sum[1] %= Mod;
	T[x].sum[2] = T[x << 1].sum[2] % Mod + T[x << 1 | 1].sum[2] % Mod;T[x].sum[2] %= Mod;
	return ;
}

signed main()
{	
	cin >> n;
	for(int i = 1 ; i <= n ; i ++)
	{
		int A,B,C;
		cin >> A >> B >> C;
		data[i][0] = A;
		data[i][1] = B;
		data[i][2] = C;
	}
	build(1 , 1 , n);
	prepare();
	cin >> Q;
	for(int i = 1 ; i <= Q ; i ++)
	{
		int op,l,r,v;
		cin >> op >> l >> r ;
		if( 4ll <= op && op <= 6ll )cin >> v;
		if(op == 4)
			Sum[0] = v,Sum[1] = Sum[2] = 0ll;
		if(op == 6)
			Sum[0] = Sum[1] = 0ll ,Sum[2] = v;
		if(op == 5)mul5[1][1] = v;
		if(op <= 6)change(1 , l , r , op);
		if(op == 7)
		{
			Output Ans = GetSum(1 , l , r);
			cout << Ans.A % Mod;putchar(' ');
			cout << Ans.B % Mod;putchar(' ');
			cout << Ans.C % Mod;putchar('\n');
		}
		Sum[0] = Sum[1] = Sum[2] = 0ll;
	}
	return 0;
}
```

#### 后话：
下传标记后，一定要记住清空 懒标记矩阵 并且记得要给局部变量赋值！

时间复杂度O($27 * n * log_2(n)$)

所以还是写这个 $3*3$ 的矩阵的做法比较好。

---


# [传智杯 #3 决赛] 序列

## 题目背景

disangan233 正在数数，他希望你帮他记录数数的序列，并完成一些操作。

## 题目描述

你有一个长为 $n$ 的序列 $a$，现在要对其进行 $m$ 次操作。操作分为两种：

1. 给定两个整数 $l,r$，表示询问 $l$ 到 $r$ 的最大连续子段和。
2. 给定三个整数 $l,r,k$，表示将 $l$ 到 $r$ 的 $a_i$ 都按位或上一个 $k$。

对于所有数据，$n,m\leq 10^5$，$-2^{30}\leq a_i,k<2^{30}$，$1\leq l\leq r\leq n$。	 

注意：负数按照 32 位补码取按位或。

## 样例 #1

### 输入

```
15 15
512 -65 33554432 32 8194 13 16 2 67108872 131072 -8192 8194 16 2048 4096 
1 3 5
1 10 10
2 1 7 671367424
1 8 14
1 5 11
2 13 13 335579137
2 2 13 5376
1 2 5
2 5 6 8392768
1 1 2
2 2 14 201335872
2 1 14 0
1 11 12
1 8 12
1 4 9```

### 输出

```
33562658
131072
67242012
2081350441
2047680290
671367936
201340226
805489228
3373416393```

# 题解

## 作者：yzy1 (赞：11)

单根号锤了 std 的俩 $\log$！

考虑分块，把原序列分成 $\sqrt n$ 块。

对于 $1$ 操作是经典操作了。直接维护块内最大连续字段和、最大前缀和、最大后缀和。然后查询时拼接块处理，输出最大值即可。

对于 $2$ 操作，我们可以根据按位 $\rm or$ 运算的性质，由于一个数按位 $\rm or$ 上另一个数后，该数的 $\rm popcount$ 值一定会增大。最坏情况下，该数初始为 $0$，则最多进行 $32$ 次按位 $\rm or$ 操作后一定为 $-1$。此时再对 $-1$ 操作值都不会改变了。所以我们可以记录块内所有元素的按位 $\rm and$ 值。如果 $2$ 操作到某个整块时，该块内元素的按位 $\rm and$ 和 $x$ 满足 $x\operatorname{and} k = k$，则该操作可以忽略，直接 `continue` 掉这个块即可。

接下来是复杂度分析，考虑到一个块最多被有效操作 $32$ 次，共有 $\sqrt n$ 个块。故整块 $2$ 操作势能上界为 $O(\log V\sqrt n \times \sqrt n) = O(n\log V)$。综上，该算法时间复杂度为 $O(n\sqrt n + n \log V)$。实际表现要比 std 的 $O(n\log n \log V)$ 要优秀。

```cpp
void Up(int x) {
  int b = bl[x];
  yu[b] = -1, isum[b] = lsum[b] = rsum[b] = sum[b] = 0;
  rep (i, lbl[x], rbl[x])
    yu[b] &= a[i], sum[b] += a[i], up(lsum[b], sum[b]);
  ll s = 0;
  per (i, rbl[x], lbl[x])
    s += a[i], up(rsum[b], s);
  s = 0;
  rep (i, lbl[x], rbl[x])
    s += a[i], up(s, 0), up(isum[b], s);
}

void Init() {
  sz = sqrt(n);
  re (i, n)
    bl[i] = (i - 1) / sz + 1, lbl[i] = (bl[i] - 1) * sz + 1, rbl[i] = min(n, bl[i] * sz);
  ste(i, 1, n, sz) Up(i);
}

void Or(int l, int r, int x) {
  if (bl[l] == bl[r]) {
    rep (i, l, r)
      a[i] |= x;
    Up(l);
    return;
  }
  Or(l, rbl[l], x);
  ste(i, lbl[l] + sz, rbl[r] - sz, sz) {
    int b = bl[i];
    if ((yu[b] & x) != x) Or(lbl[i], rbl[i], x);
  }
  Or(lbl[r], r, x);
}

ll Ask(int l, int r) {
  ll ans = 0, s = 0, ss = 0;
  if (bl[l] == bl[r]) {
    rep (i, l, r)
      s += a[i], up(s, 0), up(ans, s);
    return ans;
  }
  rep (i, l, rbl[l])
    s += a[i], up(s, 0), up(ans, s);
  s = 0;
  per (i, rbl[l], l)
    s += a[i], up(ss, s);
  rep (b, bl[l] + 1, bl[r] - 1)
    up(ans, ss + lsum[b]), ss += sum[b], up(ss, rsum[b]), up(ans, ss), up(ans, isum[b]);
  s = 0;
  rep (i, lbl[r], r)
    s += a[i], up(s, 0), up(ans, s), ss += a[i], up(ans, ss);
  return ans;
}
```

---

## 作者：linch (赞：10)

## Tips
本题简单版为 [P4513](https://www.luogu.com.cn/problem/P4513)。如果您已经完成了那题，可以跳过第一部分。

时间有限，图画的不是特别规整，但还比较清晰，有助于理解。

## Solution
### Part I 信息维护
本题要求区间修改、区间查询，容易想到要使用线段树。但是线段树直接维护最大子段和不好维护，上传时会遇到困难。我们需要一些辅助信息。

可以尝试从 push_up 函数或分治的角度找出合并时需要的信息。假设我们已经维护出了两个子区间内的需要的信息，按下图讨论：

![](https://cdn.luogu.com.cn/upload/image_hosting/awu6b6ng.png)

分类讨论，若新子段和没有跨越两个子区间（即只在其中一个区间，如上图情况一，蓝色部分），则此时最大子段和为两区间的最大字段和的较大者。

若跨越了两个区间，此时由左区间后缀和右区间前缀拼接而成（如上图情况二，绿色部分）。既然要求最大，那么应该是左区间最大后缀 $suf_r$ 和右区间最大前缀 $pre_r$。

最终答案为上图两段蓝色和一段绿色中的最大值。可写出式子 $ans=\max\{ans_l,ans_r,suf_l+pre_r\}$。

在上述过程中，我们还使用到了最大前、后缀，也需要进行维护。

以最大前缀为例，如下图：
![](https://cdn.luogu.com.cn/upload/image_hosting/38trirj9.png)

分类讨论，可能只取左区间一部分，此时合并后最大前缀即为左区间最大前缀 $pre_l$。也有可能跨越了整个左区间，此时最大前缀为左区间和 $sum_l$ 加上右区间最大前缀 $pre_r$。可写出式子 $pre=\max\{pre_l,sum_l+pre_r\}$。

最大后缀同理。但是在过程中使用到了区间和，也需要维护一下。

至此我们完成了信息维护部分。

完成后 push_up 函数代码：
```cpp
void push_up(int id){
	sum[id]=sum[id<<1]+sum[id<<1|1];
	ans[id]=max({ans[id<<1],ans[id<<1|1],suf[id<<1]+pre[id<<1|1]});
	pre[id]=max(pre[id<<1],sum[id<<1]+pre[id<<1|1]);
	suf[id]=max(suf[id<<1|1],sum[id<<1|1]+suf[id<<1]);
}
```

---

### Part II 修改
按位或操作不太方便使用懒标记记录，那就无法直接进行区间修改，只能进行单点修改。

但是容易发现按位或有一些性质可以使用。

设 $f(x)$ 为 $x$ 中二进制位 $1$ 的个数。那么每次按位或后，$f(x)$ 只会增大或不变。由于 $-2^{30}\leq a_i,k<2^{30}$，那么这个数最多只有 $30$ 个二进制位。也就是说，最多只有 $30$ 次有效按位或操作（指对其有影响的操作）。

我们可以再维护一下每个区间的按位与和。当一个区间的按位与和值 $p$ 满足 $p \operatorname{and} k=k$ 时，$k$ 中所有为 $1$ 的二进制位在该区间的每一个数中均为 $1$，这样的操作对所有数都没有影响，就不需要递归到这个区间中。

我们已经完成了本题，总时间复杂度 $O(n\log n \log a)$，可以通过本题。

### Part III 总结
本题使用了无懒标记的单点修改线段树，需要维护区间和、区间最大前缀、区间最大后缀、区间最大子段和。

主要还是思维，在线段树题目中相对代码难度不高。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e6+10;
long long n,m,a[maxn],ans[maxn],pre[maxn],suf[maxn],sum[maxn],ad[maxn];
void push_up(int id){
	sum[id]=sum[id<<1]+sum[id<<1|1];
	ans[id]=max({ans[id<<1],ans[id<<1|1],suf[id<<1]+pre[id<<1|1]});
	pre[id]=max(pre[id<<1],sum[id<<1]+pre[id<<1|1]);
	suf[id]=max(suf[id<<1|1],sum[id<<1|1]+suf[id<<1]);
	ad[id]=ad[id<<1]&ad[id<<1|1];
}
void build(int l,int r,int id){
	if(l==r){
		ans[id]=pre[id]=suf[id]=max(0ll,a[l]);
		ad[id]=sum[id]=a[l];
		return;
	}
	int mid=l+r>>1;
	build(l,mid,id<<1);
	build(mid+1,r,id<<1|1);
	push_up(id);
}
void update(int l,int r,int s,int t,int id,long long num){
	if(s==t){
		ad[id]|=num;sum[id]|=num;
		ans[id]=pre[id]=suf[id]=max(0ll,sum[id]);
		return;
	}
	int mid=s+t>>1;
	if(l<=mid && ((ad[id<<1] & num) !=num)) update(l,r,s,mid,id<<1,num);
	if(r>mid && ((ad[id<<1|1] & num) !=num)) update(l,r,mid+1,t,id<<1|1,num);
	push_up(id);
}
struct node{
	long long a,p,s,sm;
};
node mg(node xx,node yy){
	node ret;
	ret.sm=xx.sm+yy.sm;
	ret.a=max({xx.a,yy.a,xx.s+yy.p});
	ret.p=max(xx.p,xx.sm+yy.p);
	ret.s=max(yy.s,yy.sm+xx.s);
	return ret;
}
node qry(int l,int r,int s,int t,int id){
	if(s>=l && t<=r){
		return {ans[id],pre[id],suf[id],sum[id]};
	}
	int mid=s+t>>1;
	if(l<=mid && r>mid) return mg(qry(l,r,s,mid,id<<1),qry(l,r,mid+1,t,id<<1|1));
	else if(l<=mid) return qry(l,r,s,mid,id<<1);
	else if(r>mid) return qry(l,r,mid+1,t,id<<1|1);
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	build(1,n,1);
	for(int i=1;i<=m;i++){
		long long op,x,y,z;
		cin>>op>>x>>y;
		if(op==1){
			cout<<qry(x,y,1,n,1).a<<"\n";
		}
		else{
			cin>>z;
			update(x,y,1,n,1,z);
		}
	}
	return 0;
}
```
[AC record](https://www.luogu.com.cn/record/194628982)

---

## 作者：Eleveslaine (赞：7)

前置知识：线段树询问最大连续子段和的模板 [P4513 小白逛公园 ](https://www.luogu.com.cn/problem/P4513)（本题最大子段可以不选）。

按位或不好修改，考虑暴力改。我们知道一个数或上另一个数只会变大或不变，如果一个区间改完还不变，我们当然就没有必要向这个区间递归。

对于每个区间维护**按位与**和 `andd`。以 `val` 为参数执行修改操作时，如果 `andd | val == andd`，那么就不再向这个区间递归。

由于一个数不断取或，最后只会变成 $(111...1)_2$ 的形式，而本题中一个数最多被有效操作 $\mathrm{popcount}(V)\le \log V$ 次，所以时间复杂度是 $O(n\log n\log V)$ 的（其中 $V$ 是值域）。主要是代码不好写，这里仅给出线段树部分的实现。

```cpp
#define int long long
namespace SegmentTree
{
	const int maxn=1e5+2;
	int n,num[maxn];
	struct ChronosCollapse
	{
		int l,r,lmax,rmax,maxsum,sum,andd;
	} a[maxn<<2];
	#define ls(k) (k<<1)
	#define rs(k) (k<<1|1)
	inline ChronosCollapse operator +(const ChronosCollapse &A,const ChronosCollapse &B)
	{
		return (ChronosCollapse)
		{
			A.l,
			B.r,
			max(A.lmax,A.sum+B.lmax),
			max(A.rmax+B.sum,B.rmax),
			max({A.sum+B.sum,A.rmax+B.lmax,A.rmax+B.sum,A.sum+B.lmax,A.maxsum,B.maxsum}),
			A.sum+B.sum,
			(A.andd&B.andd)
		};
	}
	inline void build(int k,int l,int r)
	{
		a[k].l=l,a[k].r=r;
		if(l==r)
		{
			a[k].lmax=a[k].rmax=a[k].maxsum=max(0ll,num[l]);
			a[k].sum=a[k].andd=num[l];
			return;
		}
		int mid=(l+r)>>1;
		build(ls(k),l,mid);
		build(rs(k),mid+1,r);
		a[k]=a[ls(k)]+a[rs(k)];
	}
	inline ChronosCollapse query(int k,int l,int r)
	{
		if(a[k].l==l && a[k].r==r)
			return a[k];
		int mid=(a[k].l+a[k].r)>>1;
		if(r<=mid)
			return query(ls(k),l,r);
		else if(l>mid)
			return query(rs(k),l,r);
		else
			return query(ls(k),l,mid)+query(rs(k),mid+1,r);
	}
	inline void modify(int k,int l,int r,int val)
	{
		if(a[k].l==a[k].r)
		{
			a[k].lmax=a[k].rmax=a[k].maxsum=max(0ll,a[k].sum|val);
			a[k].andd=(a[k].sum|val);
			a[k].sum|=val;
			return;
		}
		int mid=(a[k].l+a[k].r)>>1;
		if(r<=mid)
		{
			if((a[ls(k)].andd|val)!=a[ls(k)].andd)
				modify(ls(k),l,r,val);
		}
		else if(l>mid)
		{
			if((a[rs(k)].andd|val)!=a[rs(k)].andd)
				modify(rs(k),l,r,val);
		}
		else
		{
			if((a[ls(k)].andd|val)!=a[ls(k)].andd)
				modify(ls(k),l,mid,val);
			if((a[rs(k)].andd|val)!=a[rs(k)].andd)
				modify(rs(k),mid+1,r,val);
		}
		a[k]=a[ls(k)]+a[rs(k)];
	}
}
```

---

## 作者：lijinxian0403 (赞：5)

~~这么水的题目是谁写了一上午呀?~~  
## 前置知识
[线段树](http://oi-wiki.com/ds/seg/),[位运算](http://oi-wiki.com/math/bit/),[最大子段和](https://blog.csdn.net/weixin_44023658/article/details/105928520)(看概念就行了)
## 思路
- 两个操作
  - 求区间最大子段和
  - 区间按位或
- 首先无脑线段树，写个单点按位或，然后区间就直接暴力修改每一个点，然后要标记下放，最大子段和，没了
## 最大子段和
###### （如果知道怎么用线段树求最大子段和就跳过）

当 $1 \le l \le r \le n$ 时，我们知道 $\sum_{i = l}^{r}a_i$ 就是最大子段和。那么如果我们把线段树的每个状态改成一个结构题，包含区间和（sum），区间前缀最大值（begin_sum），区间后缀最大值（end_sum），以及区间最大子段和（answer），转移参考以下代码
```cpp
struct point {
	int begin_sum ,end_sum ,sum ,answer;
	point operator +(const point &tmp)const {
		return point{max(begin_sum ,sum + tmp.begin_sum) ,max(tmp.end_sum ,tmp.sum + end_sum) ,sum + tmp.sum ,max({answer ,tmp.answer ,end_sum + tmp.begin_sum})};
	}
}
```
解读一下就是  （有点抽象，一遍看不懂看第二遍）
1.   _本区间前缀最大值，等于左孩子前缀最大值**与**左孩子区间和**加上**右孩子前缀最大值**两者中的最大值**。_
2.   _本区间后缀最大值，等于右孩子后缀最大值**与**左孩子区间和**加上**右孩子前缀最大值**两者中的最大值**。_
3.   _本区间和，等于左孩子区间和**加上**右孩子和区间和_
4.   _本区间最大子段和，等于右孩子最大子段和**与**左孩子最大子段和，以及右孩子前缀最大值**加上**左孩子后缀和最大值，**三者中的最大值**。_  
#### 如果你学会了就看看[这个](https://www.luogu.com.cn/problem/P4513)
## 本题关键部分
首先 $x|y=z+\sum_{i=1}^{t}2^{w_i}(2^{w_i} \ge z)$，那么$x|y|z=x|y$，也就是可以不或，直接舍去。  
这样子就可以直接上暴力了，然后注意要用线段树将标记下放，有点抽象，但看完代码应该就懂了。
## 代码+注释
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read() {
	int x = 0 ,f = 1;
	char ch = getchar();
	while('0' > ch || ch > '9'){
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while('0' <= ch && ch <= '9') {
		x = (x << 1) + (x << 3) + (ch & 15);
		ch = getchar();
	}
	return x * f;
}
const int N = 1e5 + 5;
struct point {
	int begin_sum ,end_sum ,sum ,answer;
	point operator +(const point &tmp)const {
		return point{max(begin_sum ,sum + tmp.begin_sum) ,max(tmp.end_sum ,tmp.sum + end_sum) ,sum + tmp.sum ,max({answer ,tmp.answer ,end_sum + tmp.begin_sum})};
	}
}sum[4 * N];
int a[N] ,n ,q ,opx ,l ,r ,adp[4 * N];
void build(int s ,int t ,int p) {  //建树 
	if(s == t) {
		sum[p] = point{a[s] ,a[s] ,a[s] ,max(a[s] ,0ll)};
		return ;
	}
	int m = s + t >> 1;
	build(s ,m ,p * 2);
	build(m + 1 ,t ,p * 2 + 1);
	sum[p] = sum[p * 2] + sum[p * 2 + 1];
	return ;
}
void updata(int x ,int tmp ,int s ,int t ,int p) {  //单点修改 
	if(t < x || x < s) return ;
	if(s == t && t == x) {
		sum[p] = point{tmp ,tmp ,tmp ,max(tmp ,0ll)};
		return ;
	}
	int m = s + t >> 1;
	updata(x ,tmp ,s ,m ,p * 2);
	updata(x ,tmp ,m + 1 ,t ,p * 2 + 1);
	sum[p] = sum[p * 2] + sum[p * 2 + 1];
	return ;
}
void update(int k ,int l ,int r ,int s ,int t ,int p) {  //暴力修改+标记下放 
	if(t < l || r < s || ((adp[p] | k) == adp[p])) return ;
	if(l <= s && t <= r) {
		adp[p] |= k;
		for(int i = s;i <= t;++ i) {
			a[i] |= k;
			updata(i ,a[i] ,1 ,n ,1);
		}
		return ;
	}
	int m = s + t >> 1;
	adp[p * 2] |= adp[p];
	adp[p * 2 + 1] |= adp[p];
	update(k ,l ,r ,s ,m ,p * 2);
	update(k ,l ,r ,m + 1 ,t ,p * 2 + 1);
	sum[p] = sum[p * 2] + sum[p * 2 + 1];
	return ;
}
point query(int s ,int t ,int l ,int r ,int p) {  //查询 
	if(l <= s && t <= r) return sum[p];
	int m = s + t >> 1;
	if(r <= m) return query(s ,m ,l ,r ,p * 2);
	else if(m < l) return query(m + 1 ,t ,l ,r ,p * 2 + 1);
	else return query(s ,m ,l ,r ,p * 2) + query(m + 1 ,t ,l ,r ,p * 2 + 1);
}
signed main() {
	n = read();
	q = read();
	for(int i = 1;i <= n;++ i) a[i] = read();
	build(1 ,n ,1);
	while(q --) {
		opx = read(); l = read(); r = read();
		if(opx == 2)
			update(read() ,l ,r ,1 ,n ,1);
		else
			cout << query(1 ,n ,min(l ,r) ,max(l ,r) ,1).answer << '\n';  //最后一定是最大子段和 
	}
	return 0;
}
```

---

## 作者：YAOhc2012 (赞：3)

首先我们需要知道最大子段和怎么求。

我们定义一个结构体，里面存储 $[l,r]$ 区间的最大前缀和，最大后缀和，总和，最大子段和。

我们考虑两个区间 $[l,x]$ 与 $[x+1,r]$ 如何合并。

1. $[l,r]$ 的最大前缀和：

假设 $[l,u]$ 的前缀和最大。

- $u\le x$

显然让 $u$ 为 $[l,x]$ 最大前缀和的位置最优。

- $u>x$

那么最大前缀和就是 $[l,x]$ 的总和加上 $[x+1,r]$ 的最大前缀和。

两种答案取最大值即可。

2. $[l,r]$ 的最大后缀和：

同理，答案为 $[x+1,r]$ 的最大后缀和与 $[x+1,r]$ 的总和加 $[l,x]$ 的最大后缀和的最大值。

3. $[l,r]$ 的总和

就是两个区间总和相加。

4. $[l,r]$ 最大子段和

首先肯定是要在 $[l,x]$ 的最大子段和与 $[x+1,r]$ 的最大子段和取最大值。

然后如果 $[l,r]$ 的最大子段和跨越了这两个区间，那就是 $[l,x]$ 的最大后缀和加上 $[x+1,r]$ 的最大前缀和。
```cpp
struct node
{
	int q,h,maxn,sum;
	node operator +(const node &g)const
	{
		node ans;
		ans.q=max(q,sum+g.q);
		ans.h=max(g.h,g.sum+h);
		ans.sum=sum+g.sum;
		ans.maxn=max(max(maxn,g.maxn),h+g.q);
		return ans; 
	}
};
```

然后线段树单点修改区间求和即可（注意这个求和是重载的加运算符）。

至于 $[l,r]$ 的区间或上 $k$ 怎么办呢。

我们可以用 $cnt_x$ 表示编号为 $x$ 的区间已经或上了 $cnt_x$。

那么每次或 $k$，如果 $cnt_x$ 或 $k$ 已经等于 $cnt_x$ 了。那么每个数或 $k$ 相当于没变化。

我们可以暴力修改，这样，加上优化后，每个数最多被修改 $32$ 次。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=500005;
int n,m,u,v,op,tot=1;
signed k;
int sl[2*N],sr[2*N],cnt[2*N];
signed a[N];
struct node
{
	int q,h,maxn,sum;
	node operator +(const node &g)const
	{
		node ans;
		ans.q=max(q,sum+g.q);
		ans.h=max(g.h,g.sum+h);
		ans.sum=sum+g.sum;
		ans.maxn=max(max(maxn,g.maxn),h+g.q);
		return ans; 
	}
};
node sum[2*N];
void push_down(int x)
{
	cnt[sl[x]]|=cnt[x];
	cnt[sr[x]]|=cnt[x];
}
void push_up(int x)
{
	sum[x]=sum[sl[x]]+sum[sr[x]];
}
void build(int x,int l,int r)
{
	if(l==r)
	{
		sum[x].q=sum[x].h=sum[x].sum=a[l];
        sum[x].maxn=max(a[l],0);
		return;
	}
	int mid=(l+r)/2;
	sl[x]=++tot;
	sr[x]=++tot;
	build(sl[x],l,mid);
	build(sr[x],mid+1,r);
	push_up(x);
}
void updata(int x,int l,int r,int ql,int k)
{
	if(l==ql&&r==ql)
	{
		sum[x].q=sum[x].h=sum[x].sum=k;
        sum[x].maxn=max(k,0LL);
		return;
	}
	int mid=(l+r)/2;
	if(ql<=mid)updata(sl[x],l,mid,ql,k);
	else if(mid<ql)updata(sr[x],mid+1,r,ql,k);
	push_up(x);
}
void update(int x,int l,int r,int ql,int qr,signed k)
{
    if((cnt[x]|k)==cnt[x])return;
	if(l==ql&&r==qr)
	{
		cnt[x]|=k;
		for(int i=l;i<=r;i++)
		{
			a[i]|=k;
			updata(1,1,n,i,a[i]);
		}
		return;
	}
	push_down(x);
	int mid=(l+r)/2;
	if(qr<=mid)update(sl[x],l,mid,ql,qr,k);
	else if(mid<ql)update(sr[x],mid+1,r,ql,qr,k);
	else
	{
		update(sl[x],l,mid,ql,mid,k);
		update(sr[x],mid+1,r,mid+1,qr,k);
	}
	push_up(x);
}
node query(int x,int l,int r,int ql,int qr)
{
	if(l==ql&&r==qr)return sum[x];
	int mid=(l+r)/2;
	if(qr<=mid)return query(sl[x],l,mid,ql,qr);
	else if(mid<ql)return query(sr[x],mid+1,r,ql,qr);
	else return query(sl[x],l,mid,ql,mid)+query(sr[x],mid+1,r,mid+1,qr);
	push_up(x);
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	build(1,1,n);
	while(m--)
	{
		cin>>op>>u>>v;
		if(op==2)
		{
			cin>>k;
			update(1,1,n,u,v,k);
		}
		else 
		{
			cout<<query(1,1,n,u,v).maxn<<endl;	
		}
	}
	return 0;
}
```

---

## 作者：Dreamweaver (赞：3)

# Preface

感谢@[noip](/space/show?uid=3296)和@[lwxn15sb](/space/show?uid=375238)的帮助，让我这个被降智的萌新切掉了此题。

# Description

维护一个长为 $n$ 的序列 $a$，$m$ 次操作：

1. 询问区间最大子段和。

1. 区间按位或上给定的数 $k$。

$n,m\leq 10^5,-2^{30}\leq a_i,k<2^{30}$。
 
# Solution

1 操作是线段树经典操作了，如果不会的话可以先做一下[这个题](https://www.luogu.com.cn/problem/SP1043)，做法就是维护每个区间的前缀最大子段和，后缀最大子段和，最大子段和，区间和，然后向上更新。

2 操作，线段树维护位运算可以拆位，例如 [CF242E(拆位维护区间异或)](https://www.luogu.com.cn/problem/CF242E)，但是这样就不能维护1操作了。


------------

那咋办呢？

我们发现按位或有特殊的性质，一个数进行按位或运算只会变大（增加二进制中 $1$ 的个数），因为一次操作至少会增加一个 $1$，所以对于 $a_i$ $(-2^{30}\leq a_i<2^{30})$ 最多操作 $30$ 次就会变为 $-1$（二进制位全是 $1$），之后再进行或操作其值不变。

所以做法就是每次判断一个区间进行或操作所有数的值是否改变，若会改变，则继续递归左右儿子进行修改，否则直接回溯。

均摊时间复杂度 $O(n \log n\log a)$。

------------

怎么判断一个区间进行操作所有数的值是否改变呢？

利用位运算，有多种方法，这里只列举两种：

**法一**：

对于线段树每个节点记录一个 $opt$，若这个区间中所有数二进制第 $i$ 位都为 $1$，则 $opt$ 二进制第 $i$ 位为 $0$，否则是 $1$。

当区间或上 $x$ 时，若 ```(opt&x)!=0```,则这个区间中有数的值会改变，反之没有。

维护 $opt$：

建树时：对于值为 $val$ 的叶子节点，```opt=val^(-1)```。

更新时：```z[root].opt=z[root<<1].opt|z[root<<1|1].opt```。





**法二**（官方题解做法）：

直接维护区间与运算（```&```）的和 $h$，当区间或上 $x$ 时，若 ```(h|x)!=h```,则这个区间中有数的值会改变，反之没有。

维护的话像区间和一样维护就好了。

最后记得开 long long。

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define re register
#define maxn 100010
#define int long long
#define ls(x) x<<1
#define rs(x) x<<1|1
#define Orz cout<<"stO %王队% Orz"<<'\n';
int n,m;
int a[maxn];
struct node
{
	int l,r,opt,sum,lans,rans,ans;
	node(){l=r=opt=sum=lans=rans=ans=0;}
	#define l(x) z[x].l
	#define r(x) z[x].r
	#define t(x) z[x].opt
	#define s(x) z[x].sum
	#define la(x) z[x].lans
	#define ra(x) z[x].rans
	#define ans(x) z[x].ans
}z[maxn<<2];
void update(int root)
{
	if(l(root)==r(root))	return ;
	s(root)=s(ls(root))+s(rs(root));
	la(root)=max(la(ls(root)),s(ls(root))+la(rs(root)));
	ra(root)=max(ra(rs(root)),s(rs(root))+ra(ls(root)));
	ans(root)=max(max(ans(ls(root)),ans(rs(root))),ra(ls(root))+la(rs(root)));
	t(root)=t(ls(root))|t(rs(root));	
}
void build(int l,int r,int root)
{
	l(root)=l,r(root)=r;
	if(l==r)
	{
		la(root)=ra(root)=ans(root)=max(0ll,a[l]);
		s(root)=a[l];
		t(root)=a[l]^(-1);
		return ;
	}
	int mid=l+r>>1;
	build(l,mid,ls(root));
	build(mid+1,r,rs(root));
	update(root);
}
void modify(int root,int l,int r,int x)
{
	if(l<=l(root)&&r(root)<=r)
	{
		if(!(t(root)&x))	return ;
		if(l(root)==r(root))
		{
			a[l(root)]|=x;
			la(root)=ra(root)=ans(root)=max(0ll,a[l(root)]);
			s(root)=a[l(root)];
			t(root)=a[l(root)]^(-1);
			return ;
		}
		if(t(ls(root))&x)	modify(ls(root),l,r,x);
		if(t(rs(root))&x)	modify(rs(root),l,r,x);
		update(root);
		return ;
	}
	int mid=l(root)+r(root)>>1;
	if(l<=mid)	modify(ls(root),l,r,x);
	if(r>mid)	modify(rs(root),l,r,x);
	update(root);
}
node query(int root,int l,int r)
{
	if(l<=l(root)&&r(root)<=r)	return z[root];
	int mid=l(root)+r(root)>>1;
	if(l>mid)	return query(rs(root),l,r);
	else
	if(r<=mid)	return query(ls(root),l,r);
	else
	{
		node ans;
		ans.clear();
		node ll=query(ls(root),l,r),rr=query(rs(root),l,r);
		ans.sum=ll.sum+rr.sum;
		ans.lans=max(ll.lans,ll.sum+rr.lans);
		ans.rans=max(rr.rans,rr.sum+ll.rans);
		ans.ans=max(max(ll.ans,rr.ans),ll.rans+rr.lans);
		return ans;
	}
}
inline int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0'||ch>'9') {if(ch=='-')f=-1; ch=getchar();}
    while (ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0'; ch=getchar();}
    return x*f;
}
inline void wn(int x){if (x<0) {putchar('-');wn(-x);return;}if(x>=10)wn(x/10);putchar(x%10+'0');}
inline void wr(int x){wn(x);putchar('\n');}
inline void wi(int x){wn(x);putchar(' ');}
signed main()
{
	cin>>n>>m;
	for(re int i=1;i<=n;++i)	a[i]=read();
	build(1,n,1);
	while(m--)
	{
		int opt,l,r,x;
		opt=read(),l=read(),r=read();
		if(opt==1)
			wr(query(1,l,r).ans);
		else
		{
			int x=read();
			modify(1,l,r,x);
		}
	}
	return 0;
}
```


---

## 作者：wjl1100 (赞：3)

## [原题传送门](https://www.luogu.com.cn/problem/P7492)

~~一道很不错的分块练手题，做完以后感觉对分块的理解又加深了不少。~~

## 思路

为了维护最大连续子段和，我们需要维护这个区间的最大前缀和，最大后缀和和最大子段和。又因为按位或的性质，所以一个数在异或足够多遍后再异或，他的值不会发生变化，所以我们维护一个块内元素和，当一次操作结束以后元素和未发生变化，以后再处理到这个块时我们直接跳过即可。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define inf 1<<30
using namespace std;
const int maxn = 500010;
int l[maxn] , r[maxn] , pos[maxn] , sq[maxn] , sh[maxn] , s[maxn] , dp[maxn] , a[maxn] , o[maxn];
int n , t , m , tot , k;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void gengxin(int p) {
	s[p] = 0;
	t = -inf;
	dp[p] = -inf;
	sq[p] = -inf;
	for(int i = l[p]; i <= r[p]; i++) {
		if(i == l[p]) o[p] = a[i];
		else o[p] &= a[i];
		s[p] += a[i];
		sq[p] = max(sq[p] , s[p]);
		t = max(t + a[i] , a[i]);
		dp[p] = max(dp[p] , t);
	}
	sh[p] = t;
}
inline void update(int x , int y , int k){
	int p = pos[x] , q = pos[y];
	if(p == q) {
		for(int i = x; i <= y; i++) {
			a[i] |= k;
		}
		gengxin(p);
		return ;
	}
	for(int i = p + 1; i <= q - 1; i++) {
		if((o[i] & k) == k) {
			continue;
		}
		update(l[i] , r[i] , k);
	}
	update(x , r[p] , k);
	update(l[q] , y , k);
	return ;
}
inline int query(int x , int y){
	int p = pos[x] , q = pos[y] , ans = -inf , t = -inf;
	if(p == q){
		for(int i = x; i <= y; i++){
			t = max(t + a[i] , a[i]);
			ans = max(ans , t);
		}
		return ans;		
	}
	t = -inf;
	for(int i = x; i <= r[p]; i++){
		t = max(t + a[i] , a[i]);
		ans = max(ans , t);
	}
	for(int i = p + 1; i <= q - 1; i++){
		ans = max(ans , t + sq[i]);
		ans = max(ans , dp[i]);
		t = max(t + s[i] , sh[i]);
		ans = max(ans , t);
	}
	for(int i = l[q]; i <= y; i++){
		t = max(t + a[i] , a[i]);
		ans = max(ans , t);
	}
	return ans;
} 
signed main(){
	int x , y , opt;
	n = read();
	m = read();
	tot = sqrt(n);
	for(int i = 1; i <= n; i++) a[i] = read();
	for(int i = 1; i <= tot; i++){
		l[i] = tot * (i - 1) + 1; 
		r[i] = tot * i;
	}
	if(r[tot] < n){
		tot++;
		l[tot] = r[tot - 1] + 1; 
		r[tot] = n;
	}
	for(int i = 1; i <= tot; i++){
		for(int j = l[i]; j <= r[i]; j++) pos[j] = i;
		gengxin(i);
	}
	for(int i = 1; i <= m; i++){
		opt = read();
		x = read();
		y = read();
		if(opt == 1){
			if(x > y) swap(x , y);
			cout << max((int)0 , query(x , y)) << endl;
		}else if(opt == 2){
			k = read();
			update(x , y , k);
		}
	}
	return 0;
}
```

---

## 作者：YZren (赞：2)

# 分块 $+$ 位运算

[题目传送门（序列）](https://www.luogu.com.cn/problem/P7492)

[AC 记录](https://www.luogu.com.cn/record/195944882)

### 前置题目[小白逛公园](https://www.luogu.com.cn/problem/P4513)

## 思路

> 关于操作一，与小白逛公园差不多，只需维护每个块的最大字段和 $dp_i$，最大前缀和 $mq_i$，最大后缀和 $mh_i$，以及元素和 $sum_i$ 就好了。

---

> 关于操作二，我们可以发现我们可以根据按位 $\operatorname{or}$ 运算的性质，由于一个数按位 $\operatorname{or}$ 上另一个数后，该数的二进制下 $1$ 的个数一定会增大。最坏情况下，该数初始为 $0$，则最多进行 $32$ 次按位 $\operatorname{or}$ 操作后一定为 $−1$。此时再对 $−1$ 操作值都不会改变了。所以，我们可以记录块内所有元素的按位 $\operatorname{and}$ 值。如果二操作到某个整块时，该块内元素的按位 $\operatorname{and}$ 值为 $x$ 满足 $x \operatorname{and} k = k$，则该操作可以忽略，直接跳过执行这个块即可；如果不相等，则暴力处理处理即可。

## 修改操作

```cpp
inline void work(int x){
	int k=-inf;//初始化
	mq[x]=-inf;
	dp[x]=-inf;
	sum[x]=0;
	lazy[x]=a[l[x]];
	for(int j=l[x];j<=r[x];j++){
		sum[x]+=a[j];//算块的元素和
		mq[x]=max(mq[x],sum[x]);//算块的最大前缀和
		k=max(k+a[j],a[j]);
		dp[x]=max(dp[x],k);//算块的最大字段和
		lazy[x]&=a[j];
	}
	mh[x]=k;//算块的最大后缀和
}
inline void update(int x,int y,int v){
	int p=pos[x],q=pos[y];
	if(p==q){
		for(int i=x;i<=y;i++) a[i]|=v;
		work(p);//更新
		return ;
	}
	for(int i=p+1;i<=q-1;i++){
		if((lazy[i]&v)==v) continue;//|操作后结果不变，跳过执行这个块
		for(int j=l[i];j<=r[i];j++) a[j]|=v;//懒标记下传
		work(i);
	}
	update(x,r[p],v);
	update(l[q],y,v);
}
```

---

## 查询操作

```cpp
inline int query(int x,int y){
	if(x>y) swap(x,y);
	int p=pos[x],q=pos[y],ans=-inf;
	if(p==q){
		int t=-inf;
		for(int i=x;i<=y;i++){
			t=max(t+a[i],a[i]);
			ans=max(t,ans);
		}
		if(ans<0) return 0;
		return ans;
	}
	int t=-inf;
	for(int i=x;i<=r[p];i++){
		t=max(t+a[i],a[i]);
		ans=max(t,ans);
	}
	for(int i=p+1;i<=q-1;i++){
		ans=max(ans,t+mq[i]);
		ans=max(ans,dp[i]);
		t=max(t+sum[i],mh[i]);
		ans=max(ans,t);//整块更新答案
	}
	for(int i=l[q];i<=y;i++){
		t=max(t+a[i],a[i]);
		ans=max(ans,t);
	}
	if(ans<0) return 0;//可以不选数，取0为最大
	return ans;
}
```

这样一道分块好题就结束了。

## Code

---

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf 0x3f3f3f3f3f3f
#define N 500010
using namespace std;
int opt,n,m,l[N],r[N],sum[N],pos[N],mq[N],mh[N],dp[N],a[N],lazy[N];
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void work(int x){
	int k=-inf;
	mq[x]=-inf;
	dp[x]=-inf;
	sum[x]=0;
	lazy[x]=a[l[x]];
	for(int j=l[x];j<=r[x];j++){
		sum[x]+=a[j];
		mq[x]=max(mq[x],sum[x]);
		k=max(k+a[j],a[j]);
		dp[x]=max(dp[x],k);
		lazy[x]&=a[j];
	}
	mh[x]=k;
}
inline void update(int x,int y,int v){
	int p=pos[x],q=pos[y];
	if(p==q){
		for(int i=x;i<=y;i++) a[i]|=v;
		work(p);
		return ;
	}
	for(int i=p+1;i<=q-1;i++){
		if((lazy[i]&v)==v) continue;
		for(int j=l[i];j<=r[i];j++) a[j]|=v;
		work(i);
	}
	update(x,r[p],v);
	update(l[q],y,v);
}
inline int query(int x,int y){
	if(x>y) swap(x,y);
	int p=pos[x],q=pos[y],ans=-inf;
	if(p==q){
		int t=-inf;
		for(int i=x;i<=y;i++){
			t=max(t+a[i],a[i]);
			ans=max(t,ans);
		}
		if(ans<0) return 0;
		return ans;
	}
	int t=-inf;
	for(int i=x;i<=r[p];i++){
		t=max(t+a[i],a[i]);
		ans=max(t,ans);
	}
	for(int i=p+1;i<=q-1;i++){
		ans=max(ans,t+mq[i]);
		ans=max(ans,dp[i]);
		t=max(t+sum[i],mh[i]);
		ans=max(ans,t);
	}
	for(int i=l[q];i<=y;i++){
		t=max(t+a[i],a[i]);
		ans=max(ans,t);
	}
	if(ans<0) return 0;
	return ans;
}
signed main(){
	n=read(); m=read();
	int t=sqrt(n);
	for(int i=1;i<=t;i++){
		l[i]=(i-1)*t+1;
		r[i]=i*t;
	}
	r[t]=n;
	for(int i=1;i<=t;i++){
		for(int j=l[i];j<=r[i];j++){
			a[j]=read();
			pos[j]=i;
		}
		work(i);
	}
	while(m--){
		opt=read();
		int x=read(),y=read();
		if(opt==2){
			int v=read();
			update(x,y,v);
		}
		else cout<<query(x,y)<<endl;
	}
	return 0;
}
```

---

## 作者：NianFeng (赞：2)

**blog食用地址**：[广告](https://www.luogu.com.cn/blog/YuanFang-Nian/p7492-zhuan-zhi-bei-3-jue-sai-xu-lie-ti-xie-post)

***

# 0x01 题目分析

## 题意

给定长为 $n$ 的序列 $a$，对其**区间按位或**，或查询最大连续子段和。

## 思路

区间操作，最大连续子段和，一眼线段树/分块。由于最近专练线段树，（~~也快忘了分块，~~）本题解提供线段树做法。

最大连续子段和是相对比较简单的，在操作实现章节稍作讲解。那么，这里主要针对区间异或的操作进行解释。线段树维护区间修改的优势在于，其能将**相同的操作**打包成**懒标记**，从而降低时间复杂度。但是，对于区间的按位或，以及其他的**区间位运算操作**，懒标记已经不适用了。为什么？因为至少从10进制的角度看，每个叶子结点的加减不同，乘除无关，**操作不一样了呀**！（至少我是不会的 QAQ）

所以，我们的目光此时就应该放在**如何尽量减少单点更新次数**上面了。

那我们想想，什么时候更新是无用的呢？当然是这个数或上 $k$ 等于自己的时候呀。自然而然，一个区间内的操作无效，就是**区间所有的数按位或** $k$ **都等于自己**。

有了这条，我们就来想想如何判断按位或 $k$ 不变的情况。在按位或中，不改变前数的情况有三种：$1 | 1 = 1$、$1 | 0 = 1$ 和 $0 | 0 = 0$。当 $k$ 所对位数为 $0$ 时，不会产生任何影响，那么判断一个区间内的数是否会改变，只用统计**对于** $k$ **有** $1$ **的位置，每一个数相同位置上都为** $1$。

理论有了，如何实现呢？开一个长为 $30$ 的数组吗？那样可太复杂了。我们可以直接借助按位或的兄弟**按位与**！在按位与中，只有相同位置都为 $1$ 才会得到 $ 1$，所以**当区间某位置上不全为** $1$ **时，同位置上区间的按位与值一定为** $0$。如此一来，用区间按位与值和 $k$ 按位或，得出的值不变则继续更新无效，可以直接返回。

于是，思路就出来了：**维护区间按位与值和最大子段和，更新时能返回不再走，否则单点更新**。

# 0x02 操作实现

## 需要的操作

- 维护区间总和

- 维护区间左、右、总最大子段和

- 维护区间按位与值

- 区间按位或

- 查询子段和

## 实现

### 1.对于最大子段和的讲解

（~~大抵是有板子题的。~~）左子段的更新，在**左子树左子段**，和左子树**总和**加上**右子树左子段**中取最大值，这样可以**保证连续**，并且取了左边的最优解和保证连续下的右边最优解，都取最优可以**保证当前区间的解最优**。类似的，右子段的更新，在**右子树右子段**，和右子树**总和**加上**左子树右子段**中取最大值。

左右子段的最优解，看上去很鸡肋，没有考虑全，但是你会发现总子段的更新又依赖于这两个子段。首先，总子段取左右总子段最大值，然后**与左子树右子段加右子树左字段取最大值**。这样，在保证连续的情况下取到最优解。

作为总子段，为什么不用考虑左右子段？那是因为，在左右子树的总子段里，已经**包含了左右子段**。思考一下，从叶子结点向上走，如果最优解是左子段，则**总会有一些段的最优解就是连续区间**。这样在一步步上传的时候，就会保证囊括了左子段。右边同理。其实我之前也不是很理解这个，但是在画图模拟后就发现了其正确性。所以，**画图理解**很重要捏。（~~但我不想更新图库~~）

```cpp
struct TREE{                        //这里使用非储存线段树
    int pre,nxt,ans;                //左、右、总子段
    int sum,num;                    //sum维护总和，num维护按位与
}tree[N<<2];
TREE operator+(const TREE &x,const TREE &y){    //这个就是pushup，只是方便查询的返回
    TREE z;
    z.sum=x.sum+y.sum;
    z.num=x.num&y.num;
    z.pre=max(x.pre,x.sum+y.pre);
    z.nxt=max(y.nxt,y.sum+x.nxt);
    z.ans=max(max(x.ans,y.ans),x.nxt+y.pre);
    return z;
}
void build(int root,int l,int r){
    if(l==r){
        tree[root].pre=tree[root].nxt=
        tree[root].ans=max(0ll,a[l]);           //子段可以为空，取和0的更大值
        tree[root].sum=tree[root].num=a[r];
        return;
    }
    int mid=l+r>>1;
    build(leftroot,l,mid);
    build(rightroot,mid+1,r);
    tree[root]=tree[leftroot]+tree[rightroot];
}
TREE query(int root,int l,int r,int L,int R){   //查询子段
    if(L<=l&&r<=R){
        return tree[root];
    }
    int mid=l+r>>1;
    if(R<=mid) return query(leftroot,l,mid,L,R);//查询答案的返回和更新是差不多的
    else if(mid<L) return query(rightroot,mid+1,r,L,R);
    else return query(leftroot,l,mid,L,R)+query(rightroot,mid+1,r,L,R);
}
```

### 2.区间按位或

这个主要是判断什么时候可以直接返回。利用上面得出的结论，当 $k$ 对区间没有影响的时候结束更新。

```cpp
void update(int root,int l,int r,int L,int R,int k){
    if((tree[root].num&k)==k) return;           //按位与的值或上k不变，则直接返回
    if(l==r){
        tree[root].num|=k,tree[root].sum|=k;    //单点修改
        tree[root].pre=tree[root].nxt=
        tree[root].ans=max(0ll,tree[root].num);
        return;
    }
    int mid=l+r>>1;
    if(L<=mid) update(leftroot,l,mid,L,R,k);
    if(mid<R) update(rightroot,mid+1,r,L,R,k);
    tree[root]=tree[leftroot]+tree[rightroot];
}
```

# 0x03 总代码

比较好理解，就不加注释方便观赏了（

```cpp
#include <bits/stdc++.h>
#define int long long
#define leftroot root<<1
#define rightroot root<<1|1
using namespace std;
namespace io{
    inline int read(){
        int x=0;
        bool flag=true;
        char c=getchar();
        while(c<'0'||c>'9'){
            if(c=='-')
                flag=false;
            c=getchar();
        }
        while(c>='0'&&c<='9'){
            x=(x<<1)+(x<<3)+c-'0';
            c=getchar();
        }
        return (flag?x:~(x-1));
    }
}
using namespace io;
const int N=100100;
int n,m,a[N];
struct TREE{
    int pre,nxt,ans;
    int sum,num;
}tree[N<<2];
TREE operator+(const TREE &x,const TREE &y){
    TREE z;
    z.sum=x.sum+y.sum;
    z.num=x.num&y.num;
    z.pre=max(x.pre,x.sum+y.pre);
    z.nxt=max(y.nxt,y.sum+x.nxt);
    z.ans=max(max(x.ans,y.ans),x.nxt+y.pre);
    return z;
}
void build(int root,int l,int r){
    if(l==r){
        tree[root].pre=tree[root].nxt=
        tree[root].ans=max(0ll,a[l]);
        tree[root].sum=tree[root].num=a[r];
        return;
    }
    int mid=l+r>>1;
    build(leftroot,l,mid);
    build(rightroot,mid+1,r);
    tree[root]=tree[leftroot]+tree[rightroot];
}
TREE query(int root,int l,int r,int L,int R){
    if(L<=l&&r<=R){
        return tree[root];
    }
    int mid=l+r>>1;
    if(R<=mid) return query(leftroot,l,mid,L,R);
    else if(mid<L) return query(rightroot,mid+1,r,L,R);
    else return query(leftroot,l,mid,L,R)+query(rightroot,mid+1,r,L,R);
}
void update(int root,int l,int r,int L,int R,int k){
    if((tree[root].num&k)==k) return;
    if(l==r){
        tree[root].num|=k,tree[root].sum|=k;
        tree[root].pre=tree[root].nxt=
        tree[root].ans=max(0ll,tree[root].num);
        return;
    }
    int mid=l+r>>1;
    if(L<=mid) update(leftroot,l,mid,L,R,k);
    if(mid<R) update(rightroot,mid+1,r,L,R,k);
    tree[root]=tree[leftroot]+tree[rightroot];
}
signed main(){
    n=read(),m=read();
    for(int i=1;i<=n;i++) a[i]=read();
    build(1,1,n);
    int opt,l,r,k;
    for(int i=1;i<=m;i++){
        opt=read();
        switch(opt){
            case 1:
                l=read(),r=read();
                printf("%lld\n",query(1,1,n,l,r).ans);
                break;
            case 2:
                l=read(),r=read(),k=read();
                update(1,1,n,l,r,k);
                break;
        }
    }
    return 0;
}
```

# 0x04 总结与后话

这道题也算是给见（shi）识（ge）浅（cai）薄（bi）的我开了开眼界。

这种线段树维护位运算的题目我还是没咋做过，大佬 Dreamweaver 的[题解](https://www.luogu.com.cn/blog/2-SAT/ti-xie-p7492-post)里有讲到另一个类似题目。（~~但是我没 CF 账户用来刷 QAQ~~）我个人感觉，这道题除了**拆位**的技巧外，还融合了类似于区间更新最小值（吉司机线段树）的……**剪枝**技巧（吗），有效减少了不必要的更新。

感谢您的观看，有错误/不详细/不足之处欢迎指出！(>w<)

---

## 作者：StayAlone (赞：2)

## 思路

对于操作 1，可以套路地维护包括左端点的最大子段和、包括右端点的最大字段和、该区间的答案以及该区间的和。

对于操作 2，考虑维护每个区间的 $\operatorname{and}$ 和。若区间 $\operatorname{and}$ 和再 $\operatorname{and} k$ 等于 $k$，那么这个区间做此次操作无效。

而对于有效的操作，一定会在值的二进制下增加 $1$ 的数量，那么每个数最多被增加 $\log v$ 次，总共被修改 $n\log v$ 次，每次修改时间复杂度 $\mathcal O(\log n)$，则总时间复杂度为 $\mathcal O(n\log n\log v)$。

此题中可以不选数，也就是说答案要和 $0$ 取 $\max$。

效率不错。  

[AC code record](https://www.luogu.com.cn/record/101934965)

```cpp
int n, m;

struct setr {
	#define STZ MAXN << 2
	
	struct imf {
		int asum;
		ll lsum, rsum, csum, sum;
		
		il bool operator == (const imf &r) const {
			return asum == r.asum && lsum == r.lsum && rsum == r.rsum && csum == r.csum && sum == r.sum;
		}
		
		il imf operator + (const imf &y) const {
			if (imf{asum, lsum, rsum, csum, sum} == imf{INT_MIN, INT_MIN, INT_MIN, INT_MIN, INT_MIN}) return y;
			if (y == imf{INT_MIN, INT_MIN, INT_MIN, INT_MIN, INT_MIN}) return {asum, lsum, rsum, csum, sum};
			imf ans;
			ans.sum = sum + y.sum;
			ans.asum = asum & y.asum;
			ans.lsum = max(lsum, sum + y.lsum);
			ans.rsum = max(y.rsum, y.sum + rsum);
			ans.csum = max({csum, y.csum, rsum + y.lsum});
			return ans;
		}
	} t[STZ];
	
	il void build(int x, int l, int r) {
		if (l == r) return t[x].asum = t[x].lsum = t[x].rsum = t[x].csum = t[x].sum = read(), void();
		int mid = l + r >> 1;
		build(ls(x), l, mid); build(rs(x), mid + 1, r);
		pushup(x);
	}
	
	il void pushup(int x) {
		t[x] = t[ls(x)] + t[rs(x)];
	}
	
	il void upd(int x, int l, int r, int ql, int qr, int k) {
		if (l > qr || r < ql) return;
		if ((t[x].asum & k) == k) return;
		if (l == r) return t[x].asum |= k, t[x].lsum = t[x].rsum = t[x].csum = t[x].sum = t[x].asum, void();
		int mid = l + r >> 1;
		upd(ls(x), l, mid, ql, qr, k); upd(rs(x), mid + 1, r, ql, qr, k);
		pushup(x);
	}
	
	il imf query(int x, int l, int r, int ql, int qr) {
		if (l > qr || r < ql) return {INT_MIN, INT_MIN, INT_MIN, INT_MIN, INT_MIN};
		if (l >= ql && r <= qr) return t[x];
		int mid = l + r >> 1;
		return query(ls(x), l, mid, ql, qr) + query(rs(x), mid + 1, r, ql, qr);
	}
} T;

int main() {
	read(n, m); T.build(1, 1, n);
	int op, l, r;
	while (m--) {
		read(op, l, r);
		if (op == 1) printf("%lld\n", max(0ll, T.query(1, 1, n, l, r).csum));
		else T.upd(1, 1, n, l, r, read());
	}
	rout;
}
```

---

## 作者：lhz2022 (赞：1)

又一道线段树好题。

前置知识：线段树。

在做这题之前可以做：[小白逛公园](https://www.luogu.com.cn/problem/P4513)，[一道可以类比的题目](https://www.luogu.com.cn/problem/P4145)。

首先就是维护最大连续字段和。

```cpp
struct tree{
	int val,lmax,rmax,ans;
}tr[N<<2];
```

这里分别表示区间和，从左边开始的最大连续字段和，右边开始的最大连续字段和，最大连续字段和。

和 [小白逛公园](https://www.luogu.com.cn/problem/P4513) 同样的做法维护即可。

我们发现，当是单点修改时，操作似乎比较容易，但是当是一个区间时，好像不能很好的维护标记。

所以我们可以从操作的性质入手。

我们发现，按位或（设要按位或整数 $x$）时，如果 $x$ 的二进制中 $1$ 的位置在这个数的相应位置也是 $1$，那么相当于不发生操作。

而且，在所有的操作下来，序列中的数的每一位只可能不变或者从 $0$ 变为 $1$。

所以我们只需要把区间操作变成单点操作即可。

所以我们可以顺手维护这个区间所有数中共同的 $1$ 的位置（即按位与），参照 [P4145](https://www.luogu.com.cn/problem/P4145) 的方法，如果这个区间不需要改变，则可以直接返回。

由于一个数在最坏情况下，每一个二进制位改变一次，所以每个数最多被改 $O(\log V)$ 次，时间复杂度可以接受。

代码（最优解第二名）：

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
#define N 100007
#define int long long
#define INF 0x3f3f3f3f
int n,m,a[N];
struct tree{
	int val,lmax,rmax,ans,t;
}tr[N<<2];
inline int rd(){
	int ans=0,w=0;
	char ch=getchar();
	while (ch<'0'||ch>'9'){
		w|=ch=='-',ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();
	}
	return w?-ans:ans;
}
inline void wr(int x){
	if(x<0)
		putchar('-'),x=-x;
	if(x<=9){
		putchar(x+'0');
		return;
	}
	wr(x/10);
	putchar(x%10+'0');
}
inline void push_up(int rt){
	tr[rt].val=tr[rt<<1].val+tr[rt<<1|1].val;
	tr[rt].lmax=max(tr[rt<<1].lmax,tr[rt<<1|1].lmax+tr[rt<<1].val);
	tr[rt].rmax=max(tr[rt<<1|1].rmax,tr[rt<<1].rmax+tr[rt<<1|1].val);
	tr[rt].ans=max({tr[rt<<1].ans,tr[rt<<1|1].ans,tr[rt<<1].rmax+tr[rt<<1|1].lmax});
	tr[rt].t=tr[rt<<1].t&tr[rt<<1|1].t;
}

tree query(int rt,int l,int r,int ql,int qr){
	if(ql<=l&&qr>=r) return tr[rt];
	int mid=(l+r)>>1;
	if(qr<=mid)	return query(rt<<1,l,mid,ql,qr);
	if(ql>mid) return query((rt<<1)|1,mid+1,r,ql,qr);
	
	tree ls=query(rt<<1,l,mid,ql,qr),rs=query((rt<<1)|1,mid+1,r,ql,qr);
	tree t={ls.val+rs.val,max(ls.val+rs.lmax,ls.lmax),max(rs.val+ls.rmax,rs.rmax),max({ls.ans,rs.ans,ls.rmax+rs.lmax})};
	return t;
}

void update(int rt,int l,int r,int ul,int ur,int add){
	if((tr[rt].t|add)==tr[rt].t) return;
	if(l==r){
		tr[rt].val|=add;
		tr[rt].t|=add;
		tr[rt].lmax=tr[rt].val;
		tr[rt].rmax=tr[rt].val;
		tr[rt].ans=max(tr[rt].val,0ll);
		return;
	}
	int mid=(l+r)>>1;
	if(ul<=mid) update(rt<<1,l,mid,ul,ur,add);
	if(ur>mid) update((rt<<1)|1,mid+1,r,ul,ur,add);
	push_up(rt);
}


void build(int rt,int l,int r){
	if(l==r) tr[rt].ans=tr[rt].rmax=tr[rt].lmax=tr[rt].val=tr[rt].t=a[l];
	else{
		int mid=(l+r)>>1;
		build(rt<<1,l,mid);
		build(rt<<1|1,mid+1,r);
		push_up(rt);
	}
}

signed main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=rd(),m=rd();
	for(int i=1;i<=n;++i){
		a[i]=rd();
	}
	build(1,1,n);
	for(int i=1,x,y,z,t;i<=m;++i){
		x=rd(),y=rd(),z=rd();
		if(x==2){
			t=rd();
			update(1,1,n,y,z,t);
		}
		else{
			wr(query(1,1,n,y,z).ans),putchar('\n');
		}
	}
	return 0;
} 
```

---

## 作者：CodingFrog1 (赞：1)

## 思路：

### 如何处理最大子段和

这种~~勾石~~要求，咱们直接上~~骚~~操作：维护块中最大前缀和、块中最大后缀和、块中最大子段和、块总和。

形式化的，有

$qzh_i=\sum_{l_{pos_i}}^{j=1}a_j$

$mq_i=\max_{r_i}^{j=l_i}qzh_j$

$hzh_i=\sum_{r_{pos_i}}^{j=i}a_j$

$mh_i=\max_{r_i}^{j=l_i}hzh_j$

$dp_i=第$ $i$ $块中最大子段和（不想写）$

$sum_i=\sum_{r_i}^{j=l_i}a_j$

故：当全局最大子段和在一块中时，直接输此块最大子段和；否则输出首块后缀最大值 $+$ 中间块内元素和 $+$ 末块前缀最大值。
### 如何处理区间或
```Qht```：少或一点行不行？

```lyyq```：每一个元素最多被**有效**或 $30$ 次，现直接
先判断可否再或，然后或就或呗！

```Qht```：如何判断？

```lyyq```：（推了推眼镜）事先维护 $lazy_i=第$ $i$ $块中所有元素的与$，整块操作来了，再把区间或上的值与上 $lazy_i$，若不变，就无需再或啦！

**妙极！** 剩下的就暴力爆过即可。
## 码

细节见码。

```
#include<bits/stdc++.h>
#define int long long
#define inf 0x3f3f3f3f3f3f
#define N 500010
using namespace std;
int opt,n,m,l[1000],r[1000],sum[1000],pos[N],mq[1000],mh[1000],dp[1000],a[N],lazy[1000];
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void work(int x){//重处理或预处理 
	int k=-inf;
	mq[x]=-inf;
	dp[x]=-inf;
	sum[x]=0;
	lazy[x]=a[l[x]];
	for(int j=l[x];j<=r[x];j++){
		sum[x]+=a[j];
		mq[x]=max(mq[x],sum[x]);
		k=max(k+a[j],a[j]);
		dp[x]=max(dp[x],k);
		lazy[x]&=a[j];
	}
	mh[x]=k;
}
inline void update(int x,int y,int v){//区间或 
	int p=pos[x],q=pos[y];
	if(p==q){
		for(int i=x;i<=y;i++) a[i]|=v;
		work(p);
		return ;
	}
	for(int i=p+1;i<=q-1;i++){
		if((lazy[i]&v)==v) continue;//判断，此处要用到位运算的思想o 
		for(int j=l[i];j<=r[i];j++) a[j]|=v;
		work(i);//重处理 
	}
	update(x,r[p],v);
	update(l[q],y,v);
}
inline int query(int x,int y){//分讨查询 
	if(x>y) swap(x,y);
	int p=pos[x],q=pos[y],ans=-inf;
	if(p==q){
		int t=-inf;
		for(int i=x;i<=y;i++){//同块 
			t=max(t+a[i],a[i]);
			ans=max(t,ans);
		}
		if(ans<0) return 0;
		return ans;
	}
	//跨块 
	int t=-inf;
	for(int i=x;i<=r[p];i++){//左 
		t=max(t+a[i],a[i]);
		ans=max(t,ans);
	}
	for(int i=p+1;i<=q-1;i++){//中 
		ans=max(ans,t+mq[i]);
		ans=max(ans,dp[i]);
		t=max(t+sum[i],mh[i]);
		ans=max(ans,t);
	}
	for(int i=l[q];i<=y;i++){//右 
		t=max(t+a[i],a[i]);
		ans=max(ans,t);
	}
	if(ans<0) return 0;
	return ans;
}
signed main(){
	n=read(); m=read();
	int t=sqrt(n);
	for(int i=1;i<=t;i++){
		l[i]=(i-1)*t+1;
		r[i]=i*t;
	}
	r[t]=n;
	for(int i=1;i<=t;i++){
		for(int j=l[i];j<=r[i];j++){
			a[j]=read();
			pos[j]=i;
		}
		work(i);//预处理 
	}
	while(m--){
		opt=read();
		int x=read(),y=read();
		if(opt==2){
			int v=read();
			update(x,y,v);
		}
		else cout<<query(x,y)<<endl;
	}
	return 0;
}
```

---

## 作者：toolong114514 (赞：1)

# P7492 [传智杯 #3 决赛] 序列 题解
## 题目大意
没看题的先点这里：[题目传送门](https://www.luogu.com.cn/problem/P7492)
## 解题思路
在线段树中存储以下信息：
```cpp
struct node{
	int l,r,lmx,rmx,maxn,sum,info;
}tree[4*N];
```
其中，$l$ 是区间左端点的编号,$r$ 是区间右端点的编号，$lmx$ 是从区间内左端点起的最大子段和，$rmx$ 是从区间内右端点起的最大子段和，$maxn$ 是区间最大子段和，$sum$ 是区间和，$info$ 是区间按位与的总值。

### 查询操作
对与区间查询，有以下的代码，讲解已在注释中给出。
```cpp
node ask(int pos,int lft,int rgt){//考虑横跨左右的计算需要包含左右端最大子段和,所以返回结构体
	if(lft<=tree[pos].l&&tree[pos].r<=rgt) return tree[pos];//完全覆盖,直接返回
	if(rgt<=tree[pos*2].r) return ask(pos*2,lft,rgt);//查询区间只与左儿子区间相交
	else if(tree[pos*2+1].l<=lft) return ask(pos*2+1,lft,rgt);//同理
	else{
		node t1=ask(pos*2,lft,rgt),t2=ask(pos*2+1,lft,rgt),t3;//查询两个子区间的信息
		t3.sum=t1.sum+t2.sum;//算区间和
		t3.lmx=max(t1.lmx,t1.sum+t2.lmx);//计算左端最大子段和：左区间的左端最大子段和，左区间的和加有区间的左端最大子段和，两者取最大值
		t3.rmx=max(t2.rmx,t2.sum+t1.rmx);//同理
		t3.maxn=max(max(t1.maxn,t2.maxn),t1.rmx+t2.lmx);//计算区间最大子段和
		return t3;
	}
}
```
这样，我们完成了操作 $1$。
### 修改操作
一般地，对于线段树的区间修改操作，使用懒标记进行优化，否则时间复杂度会退化成 $O(n)$，没有意义。同时，懒标记的修改与下传显然要做到 $O(1)$。对于区间子段和的问题，进行区间或的修改无法在 $O(1)$ 的时间复杂度下完成。

算法的复杂度只能做到 $O(n^2)$ 了？在题目的时间限制和数据范围下无法完成？

考虑分析按位或运算的性质：对于 $a|b$，在 $b$ 的二进制下的一位上为 $1$，那么在 $a$ 的二进制下的同位要变成 $1$。显然，当 $a$ 的二进制下的同位本身就是 $1$ 时，这一位的或运算没有意义。

根据以上推论，我们可以有以下优化方案：

在修改时，若一个子区间的按位与总值按位或上要或上的这个数（设为$k$）还等于原值，说明这个 $k$ 的每一位对这个子区间的数的操作都无意义，没有必要进行下去。当操作递归至叶子节点时，计算出答案，并上传。
### 对如上修改方案的时间复杂度分析
对于线段树的每一个叶子节点，最多被或上 $32$ 次，而上文的修改操作可以被视为对区间内的每一个单点分别做一次修改，单次修改时间复杂度为 $O(\log{n})$。总的来说，此策略下的时间复杂度约为 $O(kn\log{n})(1\leqslant k\leqslant32)$，可以通过本题。 
### 注意事项
在本题中，子段可以取空，要在输出前和 $0$ 比较大小，输出较大的那个。
## 代码实现
```cpp
#include<iostream>
using namespace std;
#define int long long
const int N=1e5+10;
struct node{
	int l,r,lmx,rmx,maxn,sum,info;
}tree[4*N];
int a[N];
void push_up(int pos){
	tree[pos].maxn=max(max(tree[pos*2].maxn,tree[pos*2+1].maxn),tree[pos*2].rmx+tree[pos*2+1].lmx);
	tree[pos].lmx=max(tree[pos*2].lmx,tree[pos*2].sum+tree[pos*2+1].lmx);
	tree[pos].rmx=max(tree[pos*2+1].rmx,tree[pos*2+1].sum+tree[pos*2].rmx);
	tree[pos].info=tree[pos*2].info&tree[pos*2+1].info;
	tree[pos].sum=tree[pos*2].sum+tree[pos*2+1].sum;
}
void build(int pos,int lft,int rgt){
	tree[pos].l=lft;
	tree[pos].r=rgt;
	if(lft==rgt){
		tree[pos].maxn=tree[pos].lmx=tree[pos].rmx=tree[pos].sum=tree[pos].info=a[lft];
		return;
	}
	int mid=(lft+rgt)/2;
	build(pos*2,lft,mid);
	build(pos*2+1,mid+1,rgt);
	push_up(pos);
}
void upd(int pos,int lft,int rgt,int x){
	if(tree[pos].r<lft||rgt<tree[pos].l) return;
	if(tree[pos].l==tree[pos].r){
		tree[pos].maxn|=x;
		tree[pos].lmx|=x;
		tree[pos].rmx|=x;
		tree[pos].sum|=x;
		tree[pos].info|=x;
		return;
	}
	if(!((tree[pos*2].info|x)==tree[pos*2].info)) upd(pos*2,lft,rgt,x);
	if(!((tree[pos*2+1].info|x)==tree[pos*2+1].info)) upd(pos*2+1,lft,rgt,x);
	push_up(pos);
}
node ask(int pos,int lft,int rgt){
	if(lft<=tree[pos].l&&tree[pos].r<=rgt) return tree[pos];
	if(rgt<=tree[pos*2].r) return ask(pos*2,lft,rgt);
	else if(tree[pos*2+1].l<=lft) return ask(pos*2+1,lft,rgt);
	else{
		node t1=ask(pos*2,lft,rgt),t2=ask(pos*2+1,lft,rgt),t3;
		t3.sum=t1.sum+t2.sum;
		t3.lmx=max(t1.lmx,t1.sum+t2.lmx);
		t3.rmx=max(t2.rmx,t2.sum+t1.rmx);
		t3.maxn=max(0ll,max(max(t1.maxn,t2.maxn),t1.rmx+t2.lmx));
		return t3;
	}
}
int n,m;
signed main(){
	ios::sync_with_stdio(false); 
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	build(1,1,n);
	while(m--){
		int op,ll,rr,k;
		cin>>op>>ll>>rr;
		if(op==1) cout<<max(ask(1,ll,rr).maxn,0ll)<<endl;
		else{
			cin>>k;
			upd(1,ll,rr,k);
		}
	}
}
```
[本代码可以通过评测](https://www.luogu.com.cn/record/141727067)

**This is the end.** 

The solution was written in 2024/1/2.

---

## 作者：Autumn_Rain (赞：0)

更好的阅读体验[戳这里](https://www.luogu.com.cn/article/4kof01z7)。推荐先做[小白逛公园](https://www.luogu.com.cn/problem/P4513)然后跳过分割线部分。


---
### 维护最大子段和

1. 使用线段树维护最大子段和，在结构体里存入 $rmx,lmx,sum$ 分别维护含左端点的最大子段和，含右边端点的最大子段和和区间最大子段和。
2. 此时你的 pushup 函数应该改写成下面那样。

```cpp
void pushup(int u){
	t[u].w=t[u*2].w+t[u*2+1].w;//原来的维护区间和 
	t[u].lmx=max(t[u*2].lmx,t[u*2].w+t[u*2+1].lmx);
	//max(左子树含有点l的最大子段和,左子树区间和+右子树含有l的最大子段和)
	t[u].rmx=max(t[u*2+1].rmx,t[u*2+1].w+t[u*2].rmx);
	//max(右子树含有点r的最大子段和,右子树区间和+左子树含有r的最大子段和)
	t[u].sum=max(t[u*2].sum,t[u*2+1].sum);
	t[u].sum=max(t[u].sum,t[u*2].rmx+t[u*2+1].lmx);
	//max(左,右,左+右)
}
```
2. build 函数以及 upd 函数在到达叶子节点更新的地方要给这些变量赋值。
3. qry 函数要改成 node 形式维护，实现如下。

```cpp
node qry(int u,int L,int R,int l,int r){
	//原来的正常操作 
	if(l<=L&&R<=r)return t[u];
	int mid=(L+R)>>1;
	if(r<=mid)return qry(u*2,L,mid,l,r);
	else if(mid<l)return qry(u*2+1,mid+1,R,l,r);
	//维护变量 
	node t,t1,t2;
	t1=qry(u*2,L,mid,l,r);//左子树 
	t2=qry(u*2+1,mid+1,R,l,r);//右子树 
	//同pushup 
	t.lmx=max(t1.lmx,t1.w+t2.lmx);
	t.rmx=max(t2.rmx,t2.w+t1.rmx);
	t.sum=max(max(t1.sum,t2.sum),(t2.lmx+t1.rmx));
	return t;
}
```
但是由于这题最大子段和为负数时可以选择为空，所以更新时要和 $0$ 比较。

---

### 区间按位或

1. 按位或会越来越大，因为两者之间有一个为 $1$ 就更新为 $1$。若区间或上数还等于原值，不用再算。

|value(&)|  0|1|
|:-:|:-:|:-:|
|0|0|0|
|1|0|1|

|value(丨)|  0|1|
|:-:|:-:|:-:|
|0|0|1|
|1|1|1|


2. 发现最好情况是把这个数的每一位变成 $1$，这之后不管你怎么样也不会改变它的值。这个有效操作次数小于 $\log V$。

3. 添加一个变量 $tag$ 到结构体维护按位或，记得在你的 build 函数以及 upd 函数在到达叶子节点更新的地方要给这些变量赋值。qry 函数同上。

### code


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+10;
#define int long long
int n,m,a[N];
int op,x,y,k;
struct node{
	int sum,w,tag;
	int lmx,rmx;
}t[4*N];
void pushup(int u){
	t[u].w=t[u*2].w+t[u*2+1].w;
	t[u].lmx=max(t[u*2].lmx,t[u*2].w+t[u*2+1].lmx);
	t[u].rmx=max(t[u*2+1].rmx,t[u*2+1].w+t[u*2].rmx);
	t[u].tag=t[u*2].tag&t[u*2+1].tag;
	t[u].sum=max(t[u*2].sum,t[u*2+1].sum);
	t[u].sum=max(t[u].sum,t[u*2].rmx+t[u*2+1].lmx);
}
void build(int u,int l,int r){
	if(l==r){
		t[u].lmx=t[u].rmx=a[l];
		t[u].sum=t[u].w=a[l];
		t[u].tag=a[l];
		return;
	}
	int mid=(l+r)>>1;
	build(u*2,l,mid);
	build(u*2+1,mid+1,r);
	pushup(u);
}
void upd(int u,int L,int R,int l,int r,int x){
	if(R<l||r<L)return;
	if(L==R){
		t[u].w|=x;
		t[u].lmx|=x;t[u].rmx|=x;
		t[u].sum|=x;t[u].tag|=x;
		return;
	}
	int mid=(L+R)>>1;
	if((t[u*2].tag|x)!=t[u*2].tag)upd(u*2,L,mid,l,r,x);
	if((t[u*2+1].tag|x)!=t[u*2+1].tag)upd(u*2+1,mid+1,R,l,r,x);
	pushup(u);
}
node qry(int u,int L,int R,int l,int r){
	if(l<=L&&R<=r)return t[u];
	int mid=(L+R)>>1;
	if(r<=mid)return qry(u*2,L,mid,l,r);
	else if(mid+1<=l)return qry(u*2+1,mid+1,R,l,r);
	node t,t1,t2;
	t1=qry(u*2,L,mid,l,r);
	t2=qry(u*2+1,mid+1,R,l,r);
	t.lmx=max(t1.lmx,t1.w+t2.lmx);
	t.rmx=max(t2.rmx,t2.w+t1.rmx);
	t.sum=max(max(t1.sum,t2.sum),(t2.lmx+t1.rmx));
	t.sum=max(0ll,t.sum);
	return t;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	build(1,1,n);
	while(m--){
		cin>>op>>x>>y;
		if(op==1){
			if(x>y)swap(x,y);
			cout<<max(0ll,qry(1,1,n,x,y).sum)<<"\n";
		}
		else{
			cin>>k;
			upd(1,1,n,x,y,k);
		}
	}
	return 0;
} 
```

---

## 作者：Genius_Star (赞：0)

### 题意：

支持以下两个操作：

- 求区间 $[l,r]$ 的最大字段和。

- 将 $[l,r]$ 按位或上 $v$。

### 思路：

区间问题，当数据在 $10^6$ 以下时，肯定是要考虑一下分块的。

对于第 $x$ 个块，记 $S_x,And_x,Lm_x,Rm_x,Ans_x$ 分别表示整块和，整块按位与的值，最大前缀和，最大后缀和，最大连续子段和。

对于按位或来说，有一个很特殊的性质：

- 若 $x \operatorname{and} y = y$，那么 $x \operatorname{or} y = x$，即值不会变。

当对整块进行按位或上 $v$ 操作时，若 $And_x \operatorname{and} v \ne v$，那么直接暴力操作即可。

对于一个块有效的 $v$ 最多只有 $\log W$ 个，因为每次至少都会将 $And_x$ 二进制中的一位置为 $1$。

查询的时候一块一块顺次合并即可。

### 时间复杂度分析：

操作 $1$：

- 是 $O(1)$ 将块合并起来，复杂度为 $O(\sqrt{N})$。

操作 $2$：

- 每个块最多暴力跑 $\log W$ 次，均摊复杂度为 $O(\sqrt{N} \times \sqrt{N} \times \log W) = O(N \log W)$。

故总时间复杂度为 $O((N+Q) \sqrt{N} + N \log W)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
const ll N=1e5+10,M=sqrt(N)+10; 
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
int n,m,k,t,op,l,r,x;
int a[N],A[N];
int L[M],R[M],And[M];
ll s;
ll Ans[M],S[M],LM[M],RM[M];
inline void init(int x){
	S[x]=Ans[x]=LM[x]=RM[x]=0;
	for(int i=L[x];i<=R[x];i++){
		S[x]+=a[i];
		LM[x]=max(LM[x],S[x]);
		if(i==L[x])
		  And[x]=a[i];
		else
		  And[x]&=a[i];
	}
	s=0;
	for(int i=L[x];i<=R[x];i++){
		s=max(s+a[i],0ll);
		Ans[x]=max(Ans[x],s);
	}
	s=0;
	for(int i=R[x];i>=L[x];i--){
		s+=a[i];
		RM[x]=max(RM[x],s);
	}
}
inline void update(int l,int r,int v){
	int x=A[l],y=A[r];
	if(x==y){
		for(int i=l;i<=r;i++)
		  a[i]|=v;
		init(x);
	}
	else{
		update(l,R[x],v);
		update(L[y],r,v);
		for(int i=x+1;i<=y-1;i++){
			if((And[i]&v)==v)
			  continue;
			update(L[i],R[i],v);
		}
	}
}
inline ll query(int l,int r){
	s=0;
	int x=A[l],y=A[r];
	ll ans=0;
	if(x==y){
		for(int i=l;i<=r;i++){
			s=max(s+a[i],0ll);
			ans=max(ans,s);
		}
	}
	else{
		ll h=0;
		for(int i=l;i<=R[x];i++){
			s=max(s+a[i],0ll);
			ans=max(ans,s);
		}
		s=0;
		for(int i=R[x];i>=l;i--){
			s+=a[i];
			h=max(h,s);
		}
		for(int i=x+1;i<=y-1;i++){
			ans=max({ans,h+LM[i],Ans[i]});
			h=max(h+S[i],RM[i]);
		}
		s=0;
		for(int i=L[y];i<=r;i++){
			h+=a[i];
			s=max(s+a[i],0ll);
			ans=max({ans,s,h});
		}
	}
	return ans;
}
int main(){
	n=read(),m=read();
	k=sqrt(n),t=(n+k-1)/k;
	for(int i=1;i<=t;i++){
		L[i]=(i-1)*k+1;
		R[i]=i*k;
	}
	R[t]=n;
	for(int i=1;i<=n;i++){
		a[i]=read();
		A[i]=(i+k-1)/k;
	}
	for(int i=1;i<=t;i++)
	  init(i);
	while(m--){
		op=read(),l=read(),r=read();
		if(op==1){
			write(query(l,r));
			putchar('\n');
		}
		else{
			x=read();
			update(l,r,x);
		}
	}
	return 0;
}
```

---

## 作者：small_john (赞：0)

## 思路

首先讲一下最大子段和的解法。

我们需要维护 $4$ 个值：

1. $mx$：这段区间的最大子段和；
2. $lmx$：从区间左端点开始的最大子段和；
3. $rmx$：从区间右端点开始的最大子段和；
4. $s$：这个区间的和。

如何维护？考虑维护 $k$ 节点，左儿子为 $ls$，右儿子为 $rs$，那么有：$mx_k = \max\{mx_{ls},mx_{rs},rmx_{ls}+lmx_{rs}\},lmx_k = \max\{lmx_{ls},s_{ls}+lmx_{rs}\},rmx_k = \max\{rmx_{rs},rmx_{ls}+s_{rs}\},s_k = s_{ls}+s_{rs}$。

接下来考虑更改操作。

我们记一个 $as$ 表示这段区间的按位且和。如果 $as$ 或上操作数等于 $as$ 的话，就说明操作数的每一位 $1$ 在这个区间中的每个数都有，所以不用操作。

由于一个数或另一个数，不会变小，所以最后都会变为 $2^k-1$（即二进制位都为 $1$），而操作次数最多为 $\log V$（$V$ 为操作数中的最大值），所以时间复杂度为 $O(n\log n\log V)$，可以通过本题。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf INT_MAX
#define ls(x) x*2
#define rs(x) x*2+1
using namespace std;
const int N = 1e5+5;
int n,m,in[N];
struct node{
	int s,_s,lmx,rmx,mx;
}a[N*4];
bool eq(node x,node y)
{
	return x.lmx==y.lmx&&x.mx==y.mx&&x.rmx==y.rmx&&x._s==y._s&&x.s==y.s;
}
node add(node x,node y)
{
	if(eq(x,{-inf,-inf,-inf,-inf,-inf})) return y;
	if(eq(y,{-inf,-inf,-inf,-inf,-inf})) return x;
	node res;
	res.s = x.s+y.s;
	res._s = x._s&y._s;
	res.lmx = max(x.lmx,x.s+y.lmx);
	res.rmx = max(y.s+x.rmx,y.rmx);
	res.mx = max({x.mx,y.mx,x.rmx+y.lmx});
//	cout<<res.s<<' '<<res._s<<' '<<res.lmx<<' '<<res.rmx<<' '<<res.mx<<'\n';
	return res;
}
void up(int k)
{
	a[k] = add(a[ls(k)],a[rs(k)]); 
}
void build(int k,int l,int r)
{
	if(l==r)
	{
		a[k].s = a[k]._s = a[k].lmx = a[k].rmx = a[k].mx = in[l];
		return;
	}
	int mid = (l+r)/2;
	build(ls(k),l,mid);
	build(rs(k),mid+1,r);
	up(k);
}
void change(int k,int l,int r,int x,int y,int v)
{
	if(l>y||r<x) return;
	if((a[k]._s|v)==a[k]._s) return;
	if(l==r)
	{
		a[k]._s|=v,a[k].s = a[k].lmx = a[k].rmx = a[k].mx = a[k]._s;
		return;
	}
	int mid = (l+r)/2;
	change(ls(k),l,mid,x,y,v);
	change(rs(k),mid+1,r,x,y,v);
	up(k);
}
node get(int k,int l,int r,int x,int y)
{
	if(l>y||r<x) return {-inf,-inf,-inf,-inf,-inf};
	if(l>=x&&r<=y)
		return a[k];
	int mid = (l+r)/2;
	return add(get(ls(k),l,mid,x,y),get(rs(k),mid+1,r,x,y));
}
signed main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i = 1;i<=n;i++)
		cin>>in[i];
	build(1,1,n);
	while(m--)
	{
		int op,x,y,z;
		cin>>op>>x>>y;
		if(op==1)
			cout<<max(0ll,get(1,1,n,min(x,y),max(x,y)).mx)<<'\n';
		else cin>>z,change(1,1,n,x,y,z);
	}
	return 0;
}
```

---


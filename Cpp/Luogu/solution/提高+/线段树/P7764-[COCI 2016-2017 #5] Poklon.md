# [COCI 2016/2017 #5] Poklon

## 题目描述

给定一个包含 $N$ 个自然数的数组。

接着需要回答 $Q$ 次询问，每次询问输出区间 $[L,R]$ 内恰好出现两次的自然数的数量。

## 说明/提示

**【样例 1 解释】**

区间 $[1,3]$ 中只有 $1$ 恰好出现了两次。

**【数据规模与约定】**

对于 $40\%$ 的数据，$N,Q \le 5000$。

对于 $100\%$ 的数据，$1 \le N,Q \le 5 \times 10^5$，$1 \le L \le R \le N$，数组中的元素都是小于 $10^9$ 的自然数。

**【提示与说明】**

**题目译自 [COCI 2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #5](https://hsin.hr/coci/archive/2016_2017/contest5_tasks.pdf) _T5 Poklon_。**

**本题分值按 COCI 原题设置，满分 $140$。**

## 样例 #1

### 输入

```
5 1
1 2 1 1 1
1 3```

### 输出

```
1```

## 样例 #2

### 输入

```
5 2
1 1 1 1 1
2 4
2 3```

### 输出

```
0
1```

## 样例 #3

### 输入

```
5 2
1 1 2 2 3
1 1
1 5```

### 输出

```
0
2```

# 题解

## 作者：Grisses (赞：12)

[题目](https://www.luogu.com.cn/problem/P7764)

这道题可以用离线树状数组来做，我们先将每个询问存下来，排序后对其进行修改与求和。

对于修改时遇到的一个数，有 4 种情况。

1. 当这个数第一次出现。这时它还不能做出贡献，只需标记一下它出现过一次就行了。

2. 当这个数第二次出现。这时我们如果给这一位的贡献加 1，那就会多算一些，我们只能给它前一次出现的位置加 1，同时标记它出现了 2 次。

3. 当这个数第三次出现。同理，给上一次出现的位置的贡献加 1。但是，这样的话往前 2 位以前就会多出 1，这样，我们就需要将上上次出现的位置的贡献减掉 2。还有要记得标记它出现 3 次了。

4. 当这个数出现了 4 次级以上时。对于前两次出现的位置的处理同上，但是如果只这样也不行，还需将上上上次出现的位置的贡献归零，即加 1。

还有的一些细节在代码中讲解。

代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,b[500005];
struct Node{
	int a,b,c,x;//a表示上次出现的位置，b表示上上次出现的位置，c表示上上上次出现的位置，x表示出现了几次
};
map<int,Node>m;//Node结构体用来存储每一个值的出现次数及前几次出现的位置
int lowbit(int x){return x&-x;}//lowbit函数，求正整数的二进制状态下的最低位的1的权值
struct node{
	int l,r,id,ans;
	bool operator<(const node &t)const{//重载node结构体的“<”运算符
		return id<t.id;
	}
}a[500005];//存储询问
struct BIT{//树状数组
	int c[500005];//c是树状数组的节点
	void Add(int x,int y){//将x这个位置的贡献加y
		while(x<=n){
			c[x]+=y;
			x+=lowbit(x);
		}
	}
	int Getsum(int x){//求x以前的前缀和
		int ans=0;
		while(x){
			ans+=c[x];
			x-=lowbit(x);
		}
		return ans;
	}
	int Getsum(int l,int r){//区间查询
		return Getsum(r)-Getsum(l-1);
	}
}T;
bool cmp(const node a,const node b){
	return a.r<b.r;
}
int main()
{
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++)scanf("%d",&b[i]);//读入数据
	for(int i=1;i<=q;i++){
		scanf("%d%d",&a[i].l,&a[i].r);//读入询问
		a[i].id=i;
	}
	sort(a+1,a+q+1,cmp);//将询问排序
	int cnt=1;
	for(int i=1;i<=q;i++){
		for(;cnt<=a[i].r;cnt++){//对每个询问的右端点以前的未处理的所有元素进行处理操作
			if(m.count(b[cnt])==1){
				if(m[b[cnt]].x==1){//已有1次出现，即这是第2次出现
					T.Add(m[b[cnt]].a,1);
					m[b[cnt]].x++;//标记次数
					m[b[cnt]].b=m[b[cnt]].a;
					m[b[cnt]].a=cnt;
				}
				else if(m[b[cnt]].x==2){//已有2次出现，即这是第3次出现
					T.Add(m[b[cnt]].a,1);
					T.Add(m[b[cnt]].b,-2);
					m[b[cnt]].x++;//标记次数
					m[b[cnt]].c=m[b[cnt]].b;
					m[b[cnt]].b=m[b[cnt]].a;
					m[b[cnt]].a=cnt;
				}
				else{//出现次数大于等于4
					T.Add(m[b[cnt]].a,1);
					T.Add(m[b[cnt]].b,-2);
					T.Add(m[b[cnt]].c,1);
					m[b[cnt]].c=m[b[cnt]].b;
					m[b[cnt]].b=m[b[cnt]].a;
					m[b[cnt]].a=cnt;
					//因为出现的次数大于等于4了，所以不需要标记了。
				}
			}
			else{//以前还没出现过，即这是第1次出现
				m[b[cnt]].x++;//标记次数
				m[b[cnt]].a=cnt;
			}
		}
		a[i].ans=T.Getsum(a[i].l,a[i].r);
	}
	sort(a+1,a+q+1);
	for(int i=1;i<=q;i++){
		printf("%d\n",a[i].ans);
	}
	return 0;
}
```

---

## 作者：Noby_Glds (赞：8)

一道莫队大水题。

跟这道题难度差不多的板子题还有 [SP3267](https://www.luogu.com.cn/problem/SP3267)
[P3901](https://www.luogu.com.cn/problem/P3901)
[P2709](https://www.luogu.com.cn/problem/P2709) 等。

~~总之莫队水题满地跑。~~

[关于莫队的知识](https://baijiahao.baidu.com/s?id=1611364100257622493&wfr=spider&for=pc)

打好板子后，我们只要改这些地方。

因为题目要求恰好出现两次的自然数的数量，所以答案统计 $ans$ 要这么写。

**加入一个数字**：当加入这个数字前，这个数字的出现次数为 $1$，答案加一。

当加入这个数字前，这个数字的出现次数为 $2$，答案减一。

**减去一个数字**：当减去这个数字前，这个数字的出现次数为 $3$，答案加一。

当减去这个数字前，这个数字的出现次数为 $2$，答案减一。

这个结论很好推吧。

另外这题其实不需要离散化也能过（福利）。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct hhh{
	int l,r,id;
}q[500010];
int n,m,block,a[500010],sum[500010],ans,fans[500010];
bool cmp(hhh a,hhh b){return (a.r/block)==(b.r/block)?a.l<b.l:a.r<b.r;}
void add(int x){
	if(sum[a[x]]==1) ans++;
	if(sum[a[x]]==2) ans--;//改动1
	sum[a[x]]++;
}
void del(int x){
	if(sum[a[x]]==3) ans++;
	if(sum[a[x]]==2) ans--;//改动2
	sum[a[x]]--;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=m;i++){
		cin>>q[i].l>>q[i].r;
		q[i].id=i;
	}
	block=n/(sqrt(m*2/3));//玄学优化
	sort(q+1,q+m+1,cmp);
	int l=0,r=0;
	for(int i=1;i<=m;i++){
		int ql=q[i].l,qr=q[i].r;
		while(l<ql) del(l++);
		while(r>qr) del(r--);
		while(l>ql) add(--l);
		while(r<qr) add(++r);
		fans[q[i].id]=ans;
	}
	for(int i=1;i<=m;i++) cout<<fans[i]<<endl;
	return 0;
}
```


---

## 作者：OldVagrant (赞：6)

## 题意
[题意传送门](https://www.luogu.com.cn/problem/P7764)
## Solution
前置知识：[普通莫队](https://oi-wiki.org/misc/mo-algo/)。    
这是一道接近于莫队模板题的简单题，难度跟- [P2709 小B的询问](https://www.luogu.com.cn/problem/P2709)差不多，还没莫队模板题- [P1494 [国家集训队]小Z的袜子](https://www.luogu.com.cn/problem/P1494)难。   
首先看一眼数据范围，$1\leq a_i< 10^9$,需要对读入的数组离散化处理一下。然后对询问分块，按询问的左端点所在的块的编号从小到大排序，如果编号相同，则按编号的奇偶性对右端点排序，编号为奇数则右端点升序排序，否则降序排序。   
然后建一个 $vis$ 数组，统计离散化后的 $a$ 中每个数出现的次数，再建一个 $v$ 数组，记录一个数是否对答案有贡献，扩展（add）的时候就  $vis_{a_i}+=1$ ,如果 $vis_{a_i}=2$ 那么更新答案并且使 $v_{a_i}=1$,然后如果 $vis_{a_i}>2$ 并且 $v_{a_i}=1$，这说明它已经对答案有过贡献，但现在它对答案没有贡献了，那么 $v_{a_i}=0$, 同时更新答案，如果之前对答案就没有贡献，那么无需更改答案。  
删除(del) 也是基本一样的，把刚才的 $vis_{a_i}>2$ 换成 $vis_{a_i}<2$ 就好了，具体写法可以参考下面的代码。
## Code
自我感觉很能压行（并且自己还能看懂），~~但是教练认为我的码风很神奇~~。
```c
#include <bits/stdc++.h>
using namespace std;
#define ll int
#define rint register int
#define pc(x) putchar(x)
#define gc getchar
ll a[500001],b[500001],c[500001],fi[1000],se[1000],pos[500001],vis[500001],ans,d[500001];//b，c用于辅助离散化和去重，vis为统计数组。
bool v[500001];//标记数组。
inline ll read(){
	ll x=0;
	char ch=gc();
	while(!isdigit(ch)) ch=gc();
	while(isdigit(ch)) x=x*10+ch-48,ch=gc();
	return x;
}
inline void write(ll x){
	if(x>9) write(x/10);
	pc('0'+x%10);
}
struct query{
	ll l,r,id;
}q[500001];
inline bool cmp(query a,query b){
	if(pos[a.l]^pos[b.l]) return a.l<b.l;//如果所在的块不一样就按块的编号升序排，我这个写法是一样的，块的编号大了自然左端点也大了
	return (pos[a.l]&1)?a.r<b.r:a.r>b.r;//否则按奇偶性排序，块的编号为奇数则按右端点升序排，否则按右端点降序排
}//排序。
inline void add(ll col){
	++vis[col];//更新统计数组vis
	if(vis[col]==2) ++ans,v[col]=1;//如果出现次数恰好为2则更新答案，并在标记数组里把该数标记为1，代表这个数对答案已经有贡献
	if(vis[col]>2&&v[col]) --ans,v[col]=0;//之前有贡献并且出现次数大于2则清零，两个条件缺一不可。
}//扩展。
inline void del(ll col){
	--vis[col];
	if(vis[col]==2) ++ans,v[col]=1;
	if(vis[col]<2&&v[col]) --ans,v[col]=0;
}//删除，基本同扩展。
int main(){
	ll n=read(),m=read(),cnt=0,len=sqrt(n),num=n/len;//初始化块长，块数。
	for(rint i=1;i<=num;i++) fi[i]=se[i-1]+1,se[i]=se[i-1]+len;//初始化块的左右端点数组，fi为左端点数组，se为右端点数组。
	if(se[num]^n) ++num,fi[num]=se[num-1]+1,se[num]=n;//如果最后一个块的右端点没有到n，那么就要新开一个块，左端点为上一个块右端点的下一个位置，右端点就是n。
	for(rint i=1;i<=num;i++){
		ll li=fi[i],ri=se[i];
		for(rint j=li;j<=ri;j++) a[j]=read(),pos[j]=i,b[j]=a[j];//读入，初始化每个位置所在的块的编号（pos数组），同时复制一份原数组。
	}sort(b+1,b+n+1);//排序
	for(rint i=1;i<=n;i++) if(b[i]!=b[i-1]) c[++cnt]=b[i];//去重
	for(rint i=1;i<=n;i++) a[i]=lower_bound(c+1,c+cnt+1,a[i])-c;//离散化
	for(rint i=1;i<=m;i++) q[i].l=read(),q[i].r=read(),q[i].id=i;//读入询问
	sort(q+1,q+m+1,cmp);
	ll lal=q[1].l,lar=q[1].r;//lal为上一次询问的左端点，lar为上一次询问的右端点，因为第一个询问要暴力地去统计，所以直接初始化为第一个询问的左右端点
	for(rint i=lal;i<=lar;i++) add(a[i]);//统计
	d[q[1].id]=ans;//存下答案
	for(rint i=2;i<=m;i++){
		ll le=q[i].l,ri=q[i].r;
		while(lal>le) add(a[--lal]);//当前左端点小于上一次的左端点则扩展
		while(lar<ri) add(a[++lar]);//当前右端点大于上一次的右端点则扩展
		while(lal<le) del(a[lal++]);//当前左端点大于上一次的左端点则删除
		while(lar>ri) del(a[lar--]);//当前右端点小于上一次的右端点则删除
		d[q[i].id]=ans;//存答案
	}for(rint i=1;i<=m;i++) write(d[i]),pc('\n');//输出
	return 0;
}
```

---

## 作者：BFSDFS123 (赞：2)

本题跟[P1494](https://www.luogu.com.cn/problem/P1494)一样，都可以作为莫队的模板题来练习。

----

本题直接可以用莫队硬上。

转移的时候不用讲了，我主要是讲在转移时如何增加减少答案。

我们可以建一个桶，来存储每个数出现的次数。

- 增加答案时：

我们发现，题目是要求区间恰好出现两次的自然数的数量。如果加上这个数后，这个数出现了 2 次，那么直接增加答案。如果加上这个数后，这个数出现了 3 次，说明它是由 2 次转移过来的，就直接让答案减一。

- 减少答案时：

如果减去这个数后，这个数出现了 2 次，就直接增加答案；若出现了 1 次，说明它是由 2 次转移过来的，就直接让答案减一。

-----

顺便说一下，数组内每个数都十分大，而数组长度又与元素大小之差十分大，所以我们做之前还要注意离散化，避免桶炸掉。

----

下面是喜闻乐见的代码：

```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
//#define LL_inf 1145141919810
#define ull unsigned long long
#define ll long long
using namespace std;
const int Maxn=5e5+10;
int tong[Maxn];
int res=0;
void add(int x)
{ 
	tong[x]++;
//	cout<<"add\n x="<<x<<",tong[x]="<<tong[x]<<endl;
	if(tong[x]==2)
	{
		res++;
	}
	if(tong[x]==3)
	{
		res--;
	}
}
void del(int x)
{
	tong[x]--;
//	cout<<"del:\n x="<<x<<",tong[x]="<<tong[x]<<endl;
	if(tong[x]==2)
	{
		res++;
	}
	if(tong[x]==1)
	{
		res--;
	}
}
struct Query{
	int l,r;
	int id;
}Q[Maxn];
int ans[Maxn];
int block,belong[Maxn];
int n,q,Ar[Maxn];
bool cmp(Query a,Query b)
{
	if(belong[a.l]!=belong[b.l])
	{
		return belong[a.l]<belong[b.l];
	}
	if(belong[a.l]&1)
	{
		return a.r>b.r;
	}
	return a.r<b.r;
}
int Br[Maxn];
int main()
{
	scanf("%d%d",&n,&q);
	block=sqrt(n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&Ar[i]);
		belong[i]=(i-1)/block+1;
	}
	for(int i=1;i<=n;i++)
	{
		Br[i]=Ar[i];
	}
	sort(Br+1,Br+1+n);
	int newn=unique(Br+1,Br+1+n)-Br-1;
	for(int i=1;i<=n;i++)
	{
		Ar[i]=lower_bound(Br+1,Br+newn+1,Ar[i])-Br;
	}
//	puts("After lisanhua:");
//	for(int i=1;i<=n;i++)
//	{
//		printf("%d ",Ar[i]);
//	}
//	putchar('\n');
	for(int i=1;i<=q;i++)
	{
		int l,r;
		scanf("%d%d",&l,&r);
		Q[i].l=l,Q[i].r=r;
		Q[i].id=i;
	}
	sort(Q+1,Q+1+q,cmp);
	int l=1,r=0;
	for(int i=1;i<=q;i++)
	{
		while(Q[i].l<l)
		{
			add(Ar[--l]);
		}
		while(Q[i].l>l)
		{
			del(Ar[l++]);
		}
		while(Q[i].r<r)
		{
			del(Ar[r--]);
		}
		while(r<Q[i].r)
		{
			add(Ar[++r]);
		}
		ans[Q[i].id]=res;
	}
	for(int i=1;i<=q;i++)
	{
		printf("%d\n",ans[i]);
	}
	return 0;
}

```

坑点提醒：

- 莫队排序的时候要使用奇偶性排序，来减少常数（

谢谢大家观看

---

## 作者：Figo17 (赞：2)

# P7764 题解

机房大佬都随便过了这题，我却冥思苦想了半天。

## 题意

就是说对于每个区间 $[L,R]$，我们需要找到有多少数只出现两次。

## 分析

显然，我们肯定需要前缀和或区间和来进行优化。（或者用[莫队](https://oi-wiki.org/misc/mo-algo-intro/)）

（关于莫队算法，可以看看另一位大佬的题解）

## 40 分做法

可以用数组 $cs_{i,j}$ 来表示第 $i$ 位前的数字 $j$ 出现了多少次，再在查询时用 $O(n)$ 的时间复杂度枚举 $j$，答案直接由前缀和相减判定即可。总时间和空间复杂度均为 $O(n^2)$。

```
#include<bits/stdc++.h>
using namespace std;
struct node{
	int num;
	int i;
}a[5005];
int n,tot,Q,l,r,ans;
int aa[5005];
int cs[5005][5005];
bool cmp(node x,node y){return x.num<y.num;}
int main()
{
	cin>>n>>Q;
	for(int i=1;i<=n;i++) cin>>a[i].num,a[i].i=i;
	sort(a+1,a+n+1,cmp);
	aa[a[1].i]=1;tot=1;
	for(int i=2;i<=n;i++)
	{
		if(a[i].num!=a[i-1].num) tot++;
		aa[a[i].i]=tot;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=tot;j++)
			cs[i][j]=cs[i-1][j];
		cs[i][aa[i]]++;
	}
	while(Q--)
	{
		cin>>l>>r;ans=0;
		for(int i=1;i<=tot;i++)
			if(cs[r][i]-cs[l-1][i]==2) ans++;
		cout<<ans<<endl;
	}
	return 0;
}

```
## 满分算法

（这里讨论的是在一秒时限下的做法，用的是前缀和）

对于在线算法，想要直接计算难度是很大的（但可以考虑），因此我们选择一种离线算法。首先，我们对于每个询问 $q_i$，尝试把这些询问按左端点从小到大的顺序排好。然后，我们可以先处理出 $a_1$ 至 $a_n$ 内符合题意的自然数个数，再依次处理询问。对于每个询问，将它的左端点与前一个询问的左端点形成的区间中每个元素做删除处理，最后对当前询问的右端点求一次前缀和即可。

那么问题来了，这个前缀和到底该怎么维护？考虑对目前区间内的某个元素 $i$ 的下一个与它相同的元素处加 1，对下下个相同元素减 1，就能利用类似差分的思想维护一个最终答案的前缀数组。这里用的是树状数组。

特别注意，上述删除或添加操作必须对当前区间中首次出现的元素使用。

由于每个元素最多只会被遍历三次，整体时间复杂度为 $O(n\log n)$ 

```
#include<bits/stdc++.h>
using namespace std;

struct node{
	int l,r,i;
	int ans;
}q[500005];//询问 
struct node2{
	int i;
	int num;
}a[500005];//离散

int n,Q,tot,lstl;
int nxtpos[500005];//下一个相同数字的位置 
int tree[500005];//树状数组 
int pos[500005];//离散后数组 
int po[500005];//某数最后出现的位置 
bool p[500005];//某数是否是起点 

bool cmp(node x,node y){return x.l<y.l;}
bool cmp2(node2 x,node2 y){return x.num<y.num;}
bool cmp3(node x,node y){return x.i<y.i;}

int lowbit(int x){return x&-x;}
void add(int x,int y) {while(x<=n){tree[x]+=y;x+=lowbit(x);}}
int find(int x){int s=0;while(x>=1){s+=tree[x];x-=lowbit(x);} return s;}

void change(int x,int y)
{
	int j=nxtpos[x];
	add(j,y);
	add(nxtpos[j],-y);
}
int main()
{
	cin>>n>>Q;
	for(int i=1;i<=n;i++) cin>>a[i].num,a[i].i=i;
	for(int i=1;i<=Q;i++) cin>>q[i].l>>q[i].r,q[i].i=i;
	
	sort(a+1,a+n+1,cmp2);
	pos[a[1].i]=1;tot=1;po[1]=n+1;
	for(int i=2;i<=n;i++)
	{
		if(a[i].num!=a[i-1].num) tot++;
		pos[a[i].i]=tot;
		po[tot]=n+1;
	}//离散 

	nxtpos[n+1]=n+1;
	for(int i=n;i>=1;i--)
	{
		nxtpos[i]=po[pos[i]];
		po[pos[i]]=i;
	}//指针

	sort(q+1,q+Q+1,cmp);
	for(int i=1;i<=n;i++)
		if(po[pos[i]]==i)
		{p[i]=1;change(i,1);}
	lstl=1;
	for(int i=1;i<=Q;i++)
	{
		for(int j=lstl;j<q[i].l;j++)
		{
			if(!p[j]) continue;
			change(j,-1);
			int z=nxtpos[j];
			while(z<q[i].l) z=nxtpos[z];
			p[z]=1;
			change(z,1);
		}
		q[i].ans=find(q[i].r);
		lstl=q[i].l;
	}//计算 
	
	sort(q+1,q+Q+1,cmp3);
	for(int i=1;i<=Q;i++)
		cout<<q[i].ans<<endl; 
	return 0;
}

```

稍微改下输入输出就可以一秒内过了。

## 感谢观看！

---

## 作者：P2441M (赞：1)

## 题意

给定一个长度为 $n$ 的序列 $a$。$q$ 次询问 $l,r$，求出 $a[l,r]$ 中恰好出现两次的数的个数。$1\leq n,q\leq 5\times 10^5$，$0\leq a_i\leq 10^9$。

## 题解

唐题。

先 $\mathcal{O}(n\log{n})$ 离散化，值域变成 $[1,m]$。预处理 $pre_i$ 表示 $a_i$ 前面第一个与 $a_i$ 相同的数。

把询问离线，按右端点排序，然后扫描线。我们当然希望通过巧妙地打标记，使得查询标记数组 $b$ 的区间和 $[l,r]$ 恰好就是我们所需的答案。考虑在数 $a_i=v$ 第二次出现时计入贡献，那么我们打的标记应该形如

$$
\begin{matrix}
& pre_{pre_i} & pre_i & i \\
& -1 & +1 & 0
\end{matrix}
$$

因此每次遇到一个新的 $a_i$ 时，我们给 $b_{pre_i}$ 单点 $+1$，给 $b_{pre_{pre_i}}$ 单点 $-2$，给 $b_{pre_{pre_{pre_i}}}$ 单点 $+1$ 即可。

用 BIT 维护 $b$ 的单点加、区间和。时间复杂度 $\mathcal{O}(n\log{n})$。

## 代码
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

#define lowbit(x) ((x) & -(x))
#define chk_min(x, v) (x) = min((x), (v))
#define chk_max(x, v) (x) = max((x), (v))
typedef long long ll;
typedef pair<int, int> pii;
const int N = 5e5 + 5;

int n, q, ans[N], a[N], pre[N], pos[N];
int sz, d[N];
struct Query { int id, l, r; } qr[N];
bool cmp(Query a, Query b) { return a.r < b.r; }

struct BIT {
	int c[N];
	inline int query(int x) {
		int res = 0;
		for (; x; x -= lowbit(x)) res += c[x];
		return res;
	}
	inline int query(int l, int r) { return query(r) - query(l - 1); }
	inline void add(int x, int v) { for (; x <= n; x += lowbit(x)) c[x] += v; }
} ft;

int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n >> q;
    for (int i = 1; i <= n; ++i) cin >> a[i], d[i] = a[i];
    sort(d + 1, d + n + 1), sz = unique(d + 1, d + n + 1) - (d + 1);
    for (int i = 1; i <= n; ++i) {
    	a[i] = lower_bound(d + 1, d + sz + 1, a[i]) - d;
    	pre[i] = pos[a[i]], pos[a[i]] = i;
	}
	for (int i = 1, l, r; i <= q; ++i) cin >> l >> r, qr[i] = {i, l, r};
	sort(qr + 1, qr + q + 1, cmp);
	for (int i = 1, j = 1; i <= n; ++i) {
		if (pre[i]) ft.add(pre[i], 1);
		if (pre[pre[i]]) ft.add(pre[pre[i]], -2);
		if (pre[pre[pre[i]]]) ft.add(pre[pre[pre[i]]], 1);
		while (j <= q && qr[j].r == i) ans[qr[j].id] = ft.query(qr[j].l, qr[j].r), ++j;
	}
	for (int i = 1; i <= q; ++i) cout << ans[i] << '\n';
    return 0;
}
```

---

## 作者：vvauted (赞：1)

## Luogu P7764 题解
## Description
给出长为 $N$ 的正整数序列 $a$，每次指定区间 $[l,r]$ ，查询 $a_l$ 到 $a_r$ 中出现次数等于 $2$ 的数字个数
## Solution
朴素莫队（莫队不会看[这里](https://blog.csdn.net/weixin_45697774/article/details/110006549?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162782411116780357268716%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162782411116780357268716&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-110006549.first_rank_v2_pc_rank_v29&utm_term=%E8%8E%AB%E9%98%9F&spm=1018.2226.3001.4187)），将 $a$ 序列离散化后开桶储存当前状态，再维护出现次数为 $2$ 的数的个数 $ans$，在此给出插入删除操作的代码：

插入：桶内计数自增，对插入数出现次数进行分类讨论。
删除：桶内计数自减，对插入数出现次数进行分类讨论。
```cpp
void add(int x)
{
	int t=m[a[x]];
	blk[t]++;
	if(blk[t]==3) ans--;//现在为3，之前为2，2出现次数减少
	else if(blk[t]==2) ans++;//现在变为2，2出现次数增多 
}
void del(int x)
{
	int t=m[a[x]];
	blk[t]--;
	if(blk[t]==1) ans--;
	else if(blk[t]==2) ans++;//同上 
}
```

朴素莫队部分我就不详写了，与模板是一模一样的。

---

## 作者：VitrelosTia (赞：0)

先把答案变成**出现次数 $\ge 2$ 的颜色的个数**减去**出现次数大于等于 $\ge 3$ 的颜色的个数**。然后我们只需要解决**区间出现次数大于等于 $\ge k$ 的颜色的个数**这个问题即可。

考虑扫描线，把询问按 $r$ 排序，发现一个位置对答案有贡献的必要条件，是他前第 $k-1$ 次出现的位置 $\ge l$。为什么不是充要，因为一个颜色如果出现了 $> k$ 次，那 $k+1$ 及后面的位置都不应该算贡献。

这个时候我们想到可以减去前第 $k$ 次出现的位置 $\ge l$ 的贡献，这样当我们查询一个区间的答案时，有贡献的颜色肯定只在最后一个出现的位置的前第 $k-1$ 次出现的位置有贡献，只贡献一次，和我们的意图相符。

那这个题也就做完了吧，具体实现可以看一下代码。代码很短，跑得也很快，卡了一发常现在是[最优解](https://www.luogu.com.cn/record/list?pid=P7764&orderBy=1&status=&page=1)。

```cpp
const int N = 2e6 + 5;
int n, m, Q, a[N], p[N], lst[N], ans[N];
struct Query { int l, r, o; } q[N];
int c[N]; int qwq(int x) { return x & (-x); }
void update(int x, int k) { if (x > 0) for (; x <= n; x += qwq(x)) c[x] += k; }
int query(int x) { int a = 0; for (; x; x -= qwq(x)) a += c[x]; return a; }

signed main() {
    n = rd(), Q = rd();
    for (int i = 1; i <= n; i++) {
        a[i] = rd();
        lst[i] = p[a[i]];
        p[a[i]] = i;
    }
    for (int i = 1; i <= Q; i++) q[i].l = rd(), q[i].r = rd(), q[i].o = i;
    sort(q + 1, q + Q + 1, [](Query x, Query y) { return x.r < y.r; });
    for (int i = 1, j = 1; i <= n && j <= Q; i++) {
        update(lst[i], 1), update(lst[lst[i]], -1); // 大于等于 2
        update(lst[lst[i]], -1); update(lst[lst[lst[i]]], 1); // 大于等于 3（注意是负的贡献）
        for (; q[j].r == i && j <= Q; j++) ans[q[j].o] = query(q[j].r) - query(q[j].l - 1);
    }
    for (int i = 1; i <= Q; i++) wrln(ans[i]);
    return 0;
}
```

---

## 作者：BigJoker (赞：0)

# 0x00 前置

前置知识：莫队，离散化（这不板题？？？）

# 0x01 离散化

由于莫队需要打一个桶，但是由于数据 $10^9$ 过大因此我们需要离散化，使用库函数就好了

# 0x02 莫队

板子自己去看例题，讲一下细节，因为必须恰好出现两次，因此一次和三次都不行。

当删除时，删完后为二，答案加一，删完后为一，答案减一。

当添加时，添加后为二，答案加一，添加后为三，答案减一。

# 0x03 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
int n,m;
int len,a[N],id[N],ans[N],res,d[N];
struct Q{
	int l,r,k;
}q[N];
struct node{
	int id,val;
}b[N];
bool cmp(Q x,Q y){
	return id[x.l]==id[y.l]?x.r<y.r:id[x.l]<id[y.l];
}
bool x(node x,node y){
	return x.val<y.val;
}
void add(int p){
	d[p]++;
	if(d[p]==2) res++;
	if(d[p]==3) res--;
}
void sub(int p){
	d[p]--;
	if(d[p]==1) res--;
	if(d[p]==2) res++;
}
int main(){
	scanf("%d %d",&n,&m);
	len=sqrt(n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),b[i].val=a[i],b[i].id=i,id[i]=(i+1)/len;
	sort(b+1,b+1+n,x);
	int c[N];
	for(int i=1;i<=n;i++) c[i]=b[i].val;
	for(int i=1;i<=n;i++) a[b[i].id]=lower_bound(c+1,c+1+n,c[i])-c;
	for(int i=1;i<=m;i++) scanf("%d %d",&q[i].l,&q[i].r),q[i].k=i;
	sort(q+1,q+1+m,cmp);
	int l=1,r=0;
	for(int i=1;i<=m;i++){
		while(q[i].l<l) add(a[--l]);
		while(q[i].l>l) sub(a[l++]);
		while(q[i].r<r) sub(a[r--]);
		while(q[i].r>r) add(a[++r]);
		ans[q[i].k]=res;
	}
	for(int i=1;i<=m;i++) printf("%d\n",ans[i]);
	return 0;
} 
```

---


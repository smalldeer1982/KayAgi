# 「CGOI-1」丑国旅游

## 题目背景

丑国风景优美，是远近闻名的旅游胜地（并不）。来丑国旅游的人很多。

## 题目描述

丑国的一角排列着编号从 $1$ 到 $n$ 的 $n$ 个城市。当一个人在第 $i$ 个城市时，能且仅能走到第 $i+1$ 个城市。

第 $i$ 个城市中的人们最讨厌丑值为 $a_i$ 的人。当一个丑值为 $x$ 的人从第 $i$ 个城市走到第 $i+1$ 个城市时，他会获得 $|x-a_i|\times|x-a_{i+1}|$ 的舒适值。

现在有 $m$ 个人要来丑国旅游，第 $i$ 个人的丑值为 $x_i$，要从城市 $l_i$ 走到 $r_i$，问他得到的舒适值之和是多少。

**由于这个数可能很大，你需要求出对 $10^9+7$ 取模后的值**。

由于你不能预知到下一次旅游，我们会强制你在线。

**简化版题意：**

给出 $n$ 及 $n$ 个整数 $a_1,\,a_2,\,\dots,\,a_n$。

$m$ 次在线询问，每次询问给出 $x,\,l,\,r$，求 $\sum\limits_{i=l}^{r-1}|x-a_i|\times|x-a_{i+1}|$。

## 说明/提示

#### 样例说明：

对于第一次询问，从城 $1$ 走到城 $2$，获得舒适值为 $|1-1|\times|1-2|=0$；从城 $2$ 走到城 $3$，获得舒适值为 $|1-2|\times|1-3|=2$，故总舒适值为 $2$。

对于第二次询问，解密后的 $x,\,l,\,r$ 分别是 $4,3,5$。从城 $3$ 走到城 $4$，获得舒适值为 $|4-3|\times|4-4|=0$；从城 $4$ 走到城 $5$，舒适值为 $|4-4|\times|4-5|=0$，总舒适值为 $0$。

---

#### 数据范围：

**本题采用捆绑测试。**

| 编号 | 特殊限制 | 分值 |时限|
| :-: | :-: | :-: |:-:|
| Subtask0 | $n,\,m\le 10^4$ | 20pts |1s|
| Subtask1 | $a_i,\,x\le 10$ | 10pts |2s|
| Subtask2 | $a_i$ 单调递增 | 10pts |2s|
| Subtask3 | 无特殊限制 | 60pts |2s|

对于 $100\%$ 的数据，$1 \le n,\,m \le 3 \times 10^5$，$1 \le a_i,\,x_i \le 10^9$，$1 \le l_i < r_i \le n$。

## 样例 #1

### 输入

```
5 2
1 2 3 4 5
1 1 3
6 1 7```

### 输出

```
2
0```

# 题解

## 作者：阿丑 (赞：7)

[传送门](https://www.luogu.com.cn/problem/P7770)，~~是划水时口胡的一道大水题~~

#### 前置知识：

可持久化线段树。

#### 题意：

- 给出一个长度为 $n$ 的数列 $a_i$。

- $m$ 次在线询问，每次询问求出 $\sum\limits_{i=l}^{r-1}|x-a_i|\times|x-a_{i+1}|$。

- $n,m\le3\times10^5$。

为了简洁，设 $f_{x,i}=|x-a_i|\times|x-a_{i+1}|$。

#### 分析：

这题题面看起来就像线段树，但注意到对于每个 $x$，$f_{x,i}$ 都不相同，我们也开不下 $10^9$ 棵线段树，所以暂时并不行。（对于 $10\%$ 的 $x\le10$ 的数据，这一方法就非常可行）

不过离散化后，我们可能只需要开 $3\times10^5$ 棵树，这提示我们往可持久化线段树的方向思考。

根据绝对值的定义，有：

$$|x-a|=\begin{cases}x-a&x\ge a\\-x+a &x<a\end{cases}$$

那么：

$$f_{x,i}=\begin{cases}x^2-(a_i+a_{i+1})x+a_ia_{i+1}&x\ge\max(a_i,a_{i+1})\text{ 或 }x<\min(a_i,a_{i+1})\\-x^2+(a_i+a_{i+1})x-a_ia_{i+1}&\min(a_i,a_{i+1})\le x<\max(a_i,a_{i+1})\end{cases}$$

只要 $x$ 与 $a_i$，$a_{i+1}$ 的关系确定后，我们就可以选择上述式子来求出答案，而不需要确定 $x$ 的具体值。

具体地，假设 $f_{x,i}=bx^2+cx+d$，则有 $\sum f_{x,i}=x^2\sum b+x\sum c+\sum d$，可以用线段树维护 $\sum b$，$\sum c$ 和 $\sum d$，这样线段树就与 $x$ 的具体值无关了。

注意到当 $x$ 增大的过程中，$x$ 与 $a_i$ 的关系最多改变一次（从 $x\le a_i$ 到 $x>a_i$），并且总是当 $x$ 超过 $a_i$ 的时候，$f_{x,i}$，$f_{x,i-1}$ 会改变。因此对于每个 $a_i$ 建一棵线段树，并使用可持久化线段树维护这 $n$ 棵树。每次 $x$ 超过 $a_i$ 时，在上一棵树的基础上修改 $f_{x,i-1}$ 和 $f_{x,i}$，就可以解决问题了。

#### 思路：

1. 对每一个 $a_i$ 开一棵线段树，并使用可持久化线段树维护。

2. 对每个查询二分查找应该查询哪一棵线段树，直接查询即可。

---

技巧不多，直接上代码。

```cpp
#include <bits/stdc++.h>
#define rep(i, l, r) for(register int i=l; i<=r; ++i)
#define rrep(i, r, l) for(register int i=r; i>=l; --i)
#define lfor(i, x) for(int i=head[x]; i; i=nxt[i])
#define ll long long
using namespace std;
inline ll read() {
	ll ret=0, k=1; char c; do if((c=getchar())=='-') k=-1; while(c<'0' || c>'9');
	while(c>='0' && c<='9') ret=(ret<<1)+(ret<<3)+(c^48), c=getchar(); return k*ret;
}
const int mN=3e5+100, mS=42*mN, mod=1e9+7;
int n, m, a[mN];
int ork, rk[mN];
int oe, head[mN], ver[mN], nxt[mN];
inline void add(int x, int y) {nxt[++oe]=head[x], ver[oe]=y, head[x]=oe;}

namespace Segment_Tree {
#define lc tree[p].son[0]
#define rc tree[p].son[1]
	int on, rt[mN];
	struct node {int son[2]; int b, c, d;} tree[mS];	//b c d 就是题解中提到的三个系数 
	inline void push_up(int p) {
		tree[p].b=(tree[lc].b+tree[rc].b)%mod;
		tree[p].c=(tree[lc].c+tree[rc].c)%mod;
		tree[p].d=(tree[lc].d+tree[rc].d)%mod;
	}
	void build(int &p, int l, int r) {
		p=++on;
		if(l==r) {
			if(1<=l && l<=n) tree[p].b=1, tree[p].c=(-a[l]-a[l+1])%mod, tree[p].d=(ll) a[l]*a[l+1]%mod;
			else tree[p].b=tree[p].c=tree[p].d=0;
		} else build(lc, l, l+r>>1), build(rc, (l+r>>1)+1, r), push_up(p);
	}
	void modify(int lp, int &p, int l, int r, int i) {	//修改 f(x,i) 的式子 
		if(p==lp || !p) p=++on, tree[p]=tree[lp];
		if(l==r) tree[p].b=-tree[p].b, tree[p].c=-tree[p].c, tree[p].d=-tree[p].d;	//取相反数即可 
		else {
			if(i<=(l+r>>1)) modify(tree[lp].son[0], lc, l, l+r>>1, i);
			else modify(tree[lp].son[1], rc, (l+r>>1)+1, r, i);
			push_up(p);
		}
	}
	int query(int p, int l, int r, int x, int y, int z) {
		if(x<=l && r<=y) return ((ll) tree[p].b*z%mod*z+(ll) tree[p].c*z+tree[p].d)%mod;	//即求 bz^2+cz+d 
		return ((lc&&x<=(l+r>>1)?query(lc, l, l+r>>1, x, y, z):0)
		       +(rc&&(l+r>>1)<y?query(rc, (l+r>>1)+1, r, x, y, z):0))%mod;
	}
#undef lc
#undef rc
}
using namespace Segment_Tree;

pair <int, int> tmp[mN];
void getrk() {	//去重，写得有点丑（
	rep(i, 1, n) tmp[i]=make_pair(a[i], i);
	sort(tmp+1, tmp+n+1);
	rep(i, 1, n) {
		if(tmp[i].first!=tmp[i-1].first) ++ork;
		rk[ork]=tmp[i].first, add(ork, tmp[i].second);
	}
}
int main() {
	n=read(), m=read();
	rep(i, 1, n) a[i]=read();
	getrk(), build(rt[0], 0, n);
	rep(i, 1, ork) lfor(t, i) modify(rt[i-1], rt[i], 0, n, ver[t]-1), modify(rt[i-1], rt[i], 0, n, ver[t]);
	//f(x, ver[t]) 和 f(x, ver[t]-1) 在 a[ver[t]] 变化时均需修改
	//因为修改时不想特判 ver[t]==1，所以下标从 0 到 n
	int ans=0, x, l, r;
	while(m--) {
		x=read()^ans, l=read()^ans, r=read()^ans;
		printf("%d\n", ans=(query(rt[upper_bound(rk, rk+ork+1, x)-rk-1], 0, n, l, r-1, x)+mod)%mod);
		//upper_bound-rk-1 找第一个小于等于 x 的数 
	}
	return 0;
}
```

~~本人代码常数巨大，欢迎各路神仙吊打。~~

这里放上 [Push_Y](https://www.luogu.com.cn/user/135485) 的写法，以供参考。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
inline int gin(){
	int s=0,f=1;
	char c=getchar();
	while(c<'0' || c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		s=(s<<3)+(s<<1)+(c^48);
		c=getchar();
	}
	return s*f;
}

const int N=3e5+5,M=41,mod=1e9+7;
int n,m,idx,len;
int a[N],b[N],rt[N];
int lc[N*M],rc[N*M];
vector<int> pos[N];

struct node{
	int a,b,c;
	inline void qf(){a=-a,b=-b,c=-c;}
	inline int ans(int x){return (a*x%mod*x+b*x%mod+c+mod)%mod;}
}e[N*M];

inline int getid(int x){return lower_bound(b+1,b+len+1,x)-b;}

inline void pushup(int x){
	e[x].a=(e[lc[x]].a+e[rc[x]].a)%mod;
	e[x].b=(e[lc[x]].b+e[rc[x]].b)%mod;
	e[x].c=(e[lc[x]].c+e[rc[x]].c)%mod;
}

int build(int l,int r){
	int x=++idx;
	if(l==r){
		if(l!=0) e[x]=(node){1,(-a[l]-a[l+1])%mod,a[l]*a[l+1]%mod};
		return x;
	}
	int mid=l+r>>1;
	lc[x]=build(l,mid);
	rc[x]=build(mid+1,r);
	pushup(x);
	return x;
}

int upd(int x,int root,int l,int r,int v){
	if(x==root || !x) x=++idx,e[x]=e[root],lc[x]=lc[root],rc[x]=rc[root];
	if(l==r){
		e[x].qf();
		return x;
	}
	int mid=l+r>>1;
	if(v<=mid) lc[x]=upd(lc[x],lc[root],l,mid,v);
	else rc[x]=upd(rc[x],rc[root],mid+1,r,v);
	pushup(x);
	return x;
}

int query(int x,int l,int r,int L,int R,int X){
	if(L<=l && r<=R) return e[x].ans(X);
	int mid=l+r>>1,res=0;
	if(lc[x] && L<=mid) res+=query(lc[x],l,mid,L,R,X);
	if(rc[x] && mid<R ) res+=query(rc[x],mid+1,r,L,R,X);
	return res%mod;
}

signed main(){
	n=gin(),m=gin();
	for(int i=1;i<=n;i++)
		a[i]=b[i]=gin();
	sort(b+1,b+n+1);	
	len=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++)
		pos[getid(a[i])].push_back(i);
	rt[1]=build(0,n);
	for(int i=2;i<=len+1;i++)
		for(int j=0;j<pos[i-1].size();j++){
			int v=pos[i-1][j];
			rt[i]=upd(rt[i],rt[i-1],0,n,v-1);
			rt[i]=upd(rt[i],rt[i-1],0,n,v);
		}
	int last=0;
	while(m--){
		int x=gin()^last,l=gin()^last,r=gin()^last;
		last=(query(rt[lower_bound(b+1,b+len+1,x)-b],0,n,l,r-1,x)+mod)%mod;
		printf("%lld\n",last);
	}
	return 0;
}
```

---

## 作者：QinghongLi (赞：4)

# 题意
$$
 ans = \sum_{i = l}^{r-1} |x-a_i|\times|x-a_{i+1}|
$$
# 分析
当 $x$ 同时大于 $a_i$ 和 $a_{i+1}$，或者同时小于它们时，从 $a_i$ 到 $a_{i+1}$ 的舒适度为 $x^2-(a_i+a_{i+1})x+a_i\times a_{i+1}$，而如果 $x$ 夹在它们中间的话，舒适度为 $-x^2+(a_i+a_{i+1})x-a_i\times a_{i+1}$。

设每一项的系数分别为，$s_1$，$s_2$，$s_3$ 那么求和式就变成了 $ans=x^2\sum_{i = l}^{r-1}s_1+x\sum_{i = l}^{r-1}s_2+\sum_{i = l}^{r-1}s_3$。
# 线段树
显然，最开始时假设查询的数小于所有城市的 $a_i$，以**每个城市的之间的路**的 $s_1$，$s_2$，$s_3$，建立下标线段树。

对输入进行离线操作，然后每读取一组输入，更新比 $x$ 小的**所有**城市的前一条路和后一条路。

然后读题仔细的朋友已经发现，这题强制在线。
# 可持续线段树
虽然不能离线，可是思路已经有了，读取一组数据，更新比这组数据中比   $x$ 小的**所有**城市的前后两条路。

那我们提前处理不就好了，先将所有城市的 $a_i$ 按从小到大进行排序，然后用排序后的下标作为版本号，建立可持续线段树。

在每个版本对其原来序号的点的前后两条路进行更新，也就是 $s_1=-s_1$，$s_2=-s_3$，$s_3=-s_3$。

查询的时候，只需二分的找到比 $x$ 小的最大 $a_i$ 的版本号，查询其  $l$ 到 $r$ 内的和输出即可。

做到这一步你已经具备了 $10$ 分其它全部 mle 的潜质，别慌，具体的坑我会在注释里写出来。
# 代码
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#define lc(x) tr[x].next[0]
#define rc(x) tr[x].next[1]
#define N 300005
#define mod 1000000007
#define ll long long 
using namespace std;
int root[N],data[N],ide,c[N];
struct bb{
    int num,ai;
}b[N];//方便找到排序后原来的序号
bool cmp(struct bb a,struct bb b){
    return a.ai<b.ai;
}
struct node{
    int s1,s2,s3,next[2];
}tr[N*30];
void build(int l,int r,int &x){
    x=++ide;
    if(l==r){
        tr[x].s1=1;
        tr[x].s2=(-data[l]-data[l+1])%mod;
        tr[x].s3=((ll)data[l]*data[l+1])%mod;//这里注意(ll)的位置，千万先转化再取模
        return;
    }//假设x比每一个城市的值都小，作为初始版本
    int m=l+r>>1;
    build(l,m,lc(x));
    build(m+1,r,rc(x));
    tr[x].s1=(tr[lc(x)].s1+tr[rc(x)].s1)%mod;
    tr[x].s2=(tr[lc(x)].s2+tr[rc(x)].s2)%mod;
    tr[x].s3=(tr[lc(x)].s3+tr[rc(x)].s3)%mod;
    return;
}
void insert(int x,int &y,int l,int r,int p){
    if(!y || y==x){
        y=++ide;
        tr[y]=tr[x];
    }
    if(l==r){
        tr[y].s1=-tr[y].s1;
        tr[y].s2=-tr[y].s2;
        tr[y].s3=-tr[y].s3;
        return;
    }
    int m=l+r>>1;
    if(p>m)insert(rc(x),rc(y),m+1,r,p);
    else insert(lc(x),lc(y),l,m,p);
    tr[y].s1=(tr[lc(y)].s1+tr[rc(y)].s1)%mod;
    tr[y].s2=(tr[lc(y)].s2+tr[rc(y)].s2)%mod;
    tr[y].s3=(tr[lc(y)].s3+tr[rc(y)].s3)%mod;
    return;
}
int ans(int l,int r,int l1,int r1,int x,int p){
    if(l1<=l&&r1>=r)
        return ((ll)p*p%mod*tr[x].s1%mod+(ll)p*tr[x].s2%mod+tr[x].s3)%mod;
    int sum=0,m=l+r>>1;
    if(l1<=m)sum+=ans(l,m,l1,r1,lc(x),p);
    if(r1>m)sum=(sum+ans(m+1,r,l1,r1,rc(x),p))%mod;
    return sum;
}
int main()
{
    int n,m,p=-1;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        scanf("%d",&data[i]);
        b[i].num=i;
        b[i].ai=data[i];
    }
    build(1,n-1,root[0]);//以边建树，范围到n-1
    sort(b+1,b+n+1,cmp);
    for(int i=1;i<=n;i++){
        if(b[i].num!=n)
            insert(root[i-1],root[i],1,n-1,b[i].num);
        if(b[i].num!=1)
            insert(root[i-1],root[i],1,n-1,b[i].num-1);
        c[i]=b[i].ai;
    }//第一个和最后一个城市只有一条路，记得特判一下
    int x,l,r;
    for(int i=0;i<m;i++){
        scanf("%d%d%d",&x,&l,&r);
        if(p!=-1){
            x^=p;
            l^=p;
            r^=p;
        }
        printf("%d\n",p=(ans(1,n-1,l,r-1,root[upper_bound(c+1,c+n+1,x)-c-1],x)+mod)%mod);//最后结果可能是负数，不能直接取模
    }
    return 0;
}


```

---


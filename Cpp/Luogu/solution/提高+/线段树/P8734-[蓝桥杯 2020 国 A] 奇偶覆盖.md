# [蓝桥杯 2020 国 A] 奇偶覆盖

## 题目描述

在平面内有一些矩形，它们的两条边都平行于坐标轴。

我们称一个点被某个矩形覆盖，是指这个点在矩形的内部或者边界上。

请问，被奇数个矩形覆盖和被偶数 $(\geq 2)$ 个矩形覆盖的点的面积分别是多少?

## 说明/提示

对于 $20 \%$ 的评测用例, $1 \leq n \leq 10,0 \leq l_{i}<r_{i} \leq 100,0 \leq b_{i}<t_{i} \leq 100$ 。

对于 $40 \%$ 的评测用例, $1 \leq n \leq 1000,0 \leq l_{i}<r_{i} \leq 100,0 \leq b_{i}<t_{i} \leq 100$ 。

对于 $60 \%$ 的评测用例, $1 \leq n \leq 10000,0 \leq l_{i}<r_{i} \leq 1000,0 \leq b_{i}<t_{i} \leq 1000$ 。

对于 $80 \%$ 的评测用例, $1 \leq n \leq 10^5,0 \leq l_{i}<r_{i} \leq 10^5,0 \leq b_{i}<t_{i} \leq 10^5$。

对于所有评测用例, $1 \leq n \leq 10^5,0 \leq l_{i}<r_{i} \leq 10^{9}, 0 \leq b_{i}<t_{i} \leq 10^{9}$。 

蓝桥杯 2020 年国赛 A 组 I 题。

## 样例 #1

### 输入

```
3
1 1 3 3
2 2 4 4
3 3 5 5```

### 输出

```
8
2```

# 题解

## 作者：mayike (赞：26)

### [题目](https://www.luogu.com.cn/problem/P8734)

### 前言

------------

**本篇主要是对针对所有分别统计奇偶覆盖次数的题解作说明。**

$\texttt{upd：2025.3.7.}$

## 思路

和 [P5490](https://www.luogu.com.cn/problem/P5490) 的模版扫描线不同，在统计总长度时可以分成 $len1$ 和 $len2$ 分别记录奇偶次数的完全覆盖总长度。所以除区间修改外其余内容与模版扫描线大体相同。

对于线段树结合扫描线的区间修改，目前的几篇题解在奇偶处理时都没有一个较明确的推导，我自己的推导如下：

先给出一个图，方便操作（有点丑陋，见谅）:

![](https://cdn.luogu.com.cn/upload/image_hosting/6n8pigqg.png)

说明一下这个图为什么有些点重了，因为我是按边分的区间。

因为在区间修改时只要满足：

```cpp
if(l<=X[s]&&X[t]<=r){//l-r是当前扫到的线，X[s]-X[t]是一个区间
    d[p].cnt+=c;//只要可以完全覆盖就 return 即不会传到子树 
    pushup(p);
    return;
}
```

**结论说明**：这样的话，完全覆盖次数就不会传到子树。正常点说，就是图中的父节点的完全覆盖次数永远不可能传到子节点，但子节点的实际完全覆盖次数是父节点的完全覆盖次数加上子节点的完全覆盖次数。对于父节点的父节点我称爷爷节点与原父节点的子节点的关系，因为爷爷节点被完全覆盖也会把原父节点和子节点完全覆盖，大不了原父节点和子节点的奇偶同时加或同时减，所以不影响原父节点与子节点的传递（偶加减偶得偶，偶加减奇得奇，奇加减奇得偶）。

所以在区修时可得如下 $3$ 种情况：

对于没有被完全覆盖的情况，即 ``!d[p].cnt``：此时明显由左右子树转移。

```cpp
if(!d[p].cnt)//没有完全覆盖由左右子树转移 
    d[p].len1=d[p<<1].len1+d[(p<<1)|1].len1,
    d[p].len2=d[p<<1].len2+d[(p<<1)|1].len2;
```
设子节点奇偶总长为 $Llen1,Llen2$，目前即父节点奇偶总长为 $len1,len2$，则有：

对于父节点被奇数次完全覆盖的情况，即 ``d[p].cnt&1``。根据结论，有子节点目前实际偶数次完全覆盖是父节点完全覆盖次数加子节点偶数次完全覆盖次数等于奇数次完全覆盖，而实际奇覆盖是父节点完全覆盖次数加子节点奇数次完全覆盖次数等于偶数次完全覆盖。也就是说，子节点奇数次覆盖实际是偶数次覆盖，所以 $len2$ 由 $Llen1$ 转移；子节点偶数次覆盖实际是奇数次覆盖，所以 $len1$ 由 $Llen2$ 转移。对于转移，因为奇偶面积并之和为总面积并，**但由于 $Llen2$ 可能未传入偶数为 $0$ 的面积并，当且仅当被覆盖次数原始为 $0$ 但实际覆盖次数在祖先节点未下传**；而 $Llen1$ 为奇数覆盖其覆盖次数大于 $0$ 所以该有的值肯定是被更新过的，特殊的当祖先有偶数次覆盖可能是不会更新 $Llen1$，但不影响，因为加了偶数次仍是原来奇数覆盖的长度。所以，先算得 $len2$，再通过总长算出 $len1$。

```cpp
if(d[p].cnt&1)
    d[p].len2=d[p<<1].len1+d[(p<<1)|1].len1,//len2=Llen1
    d[p].len1=X[r]-X[l]-d[p].len2;//总长-len2
```

对于父节点被偶数次完全覆盖的情况，即 ``!(d[p].cnt&1)``，根据结论，可同理推导。

```cpp
//转移过程同奇数覆盖情况 
    d[p].len1=d[p<<1].len1+d[(p<<1)|1].len1,
    d[p].len2=X[r]-X[l]-d[p].len1;
```

点个免费的**赞**再走吧！

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
#define x1 X1
#define x2 X2
#define y1 Y1
#define y2 Y2
#define int long long
int n,m,X[N<<1];
struct sb{
	long long y,l,r,t;
}ld[N<<1];
struct ssb{
	long long l,r,cnt,len1,len2; 
}d[N<<2];
bool cmp(sb x,sb y){
	return x.y<y.y;
}
void js(int l,int r,int p){
	d[p]={l,r,0,0,0};
	if(l+1==r)return;
	int mid=(l+r)>>1;
	js(l,mid,p<<1),js(mid,r,(p<<1)|1);
}
void pushup(int p){
	int l=d[p].l,r=d[p].r;
	if(!d[p].cnt)
	    d[p].len1=d[p<<1].len1+d[(p<<1)|1].len1,
		d[p].len2=d[p<<1].len2+d[(p<<1)|1].len2;
	else if(d[p].cnt&1)
		d[p].len2=d[p<<1].len1+d[(p<<1)|1].len1,
		d[p].len1=X[r]-X[l]-d[p].len2;
	else
		d[p].len1=d[p<<1].len1+d[(p<<1)|1].len1,
		d[p].len2=X[r]-X[l]-d[p].len1;
}
void dsb(int c,int l,int r,int p){
	int s=d[p].l,t=d[p].r;
	if(r<=X[s]||X[t]<=l)return;
	if(l<=X[s]&&X[t]<=r){
		d[p].cnt+=c;
		pushup(p);
		return;
	}dsb(c,l,r,p<<1),dsb(c,l,r,(p<<1)|1);
	pushup(p);
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		int x1,x2,y1,y2;
		cin>>x1>>y1>>x2>>y2;
		X[(i<<1)-1]=x1,X[i<<1]=x2;
		ld[(i<<1)-1]={y1,x1,x2,1},ld[i<<1]={y2,x1,x2,-1};
	}n<<=1;
	sort(X+1,X+1+n),sort(ld+1,ld+1+n,cmp);
	m=unique(X+1,X+1+n)-X-1;
	js(1,m,1);
	long long ans1=0,ans2=0;
	for(int i=1;i<n;i++){
		dsb(ld[i].t,ld[i].l,ld[i].r,1);
		ans1+=d[1].len1*(ld[i+1].y-ld[i].y);
		ans2+=d[1].len2*(ld[i+1].y-ld[i].y);
	}cout<<ans1<<'\n'<<ans2;
	return 0;
}
```

---

## 作者：___w (赞：8)

### [P8734 奇偶覆盖](https://www.luogu.com.cn/problem/P8734)

扫描线模板的略微修改，不会扫描线的可以先过下面这题。
#### [P5490 【模板】扫描线](https://www.luogu.com.cn/problem/P5490)

#### 扫描线

扫描线通常用来求矩形所覆盖的面积或周长，主要运用到差分思想。把若干个不规则的矩形转换成若干个规则的矩形，从而更好的去求解问题。

扫描线需要区间修改和查询所有覆盖次数不为 $0$ 的长度和，所以离散化线段树应运而生，将时间复杂度大大降低。

![1](https://cdn.luogu.com.cn/upload/image_hosting/kunoa8bi.png)

对于本题，每个区间我们需要维护三个值，分别是 $s1$ 奇数次覆盖的总长度，$s2$ 偶数次覆盖的总长度，$cnt$ 改区间覆盖的次数，再分类讨论下奇偶性即可。

对于每个节点：

- 若没被覆盖，奇等于奇加奇，偶等于偶加偶。
- 若覆盖奇数次，偶等于奇加奇，奇等于区间长减偶。
- 若覆盖偶数次，奇等于奇加奇，偶等于区间长减奇。

特别地，若该节点为叶子节点，则默认叶子节点的左右子节点的 $s1$ 和 $s2$ 均为 $0$。

维护代码如下：

```cpp
void update(int p) {
	if (!t[p].cnt) {
		t[p].s1 = t[p<<1].s1+t[p<<1|1].s1;
		t[p].s2 = t[p<<1].s2+t[p<<1|1].s2;
		return;
	}
	if (t[p].cnt&1) {
		t[p].s2 = t[p<<1].s1+t[p<<1|1].s1;
		t[p].s1 = a[t[p].r+1]-a[t[p].l]-t[p].s2;
	}
	else {
		t[p].s1 = t[p<<1].s1+t[p<<1|1].s1;
		t[p].s2 = a[t[p].r+1]-a[t[p].l]-t[p].s1;
	}
}
```
有了维护 $s1$，$s2$ 接下来答案的统计就不难了。

```cpp
ans1 += t[1].s1*(e[i+1].y-e[i].y);
ans2 += t[1].s2*(e[i+1].y-e[i].y);
```
#### 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 2e5+5;
int n, tot, a[N<<2];
ll ans1, ans2;//注意开long long
struct edge {//扫描线的边
	int y, x1, x2, k;
} e[N];
struct tree {//线段树
	int l, r;
	ll s1, s2, cnt;
} t[N<<3];//注意开8倍空间，这样就不用特判叶子节点了
void update(int p) {//向上传递
	if (!t[p].cnt) {
		t[p].s1 = t[p<<1].s1+t[p<<1|1].s1;
		t[p].s2 = t[p<<1].s2+t[p<<1|1].s2;
		return;
	}
	if (t[p].cnt&1) {
		t[p].s2 = t[p<<1].s1+t[p<<1|1].s1;
		t[p].s1 = a[t[p].r+1]-a[t[p].l]-t[p].s2;
	}
	else {
		t[p].s1 = t[p<<1].s1+t[p<<1|1].s1;
		t[p].s2 = a[t[p].r+1]-a[t[p].l]-t[p].s1;
	}
}
void build(int p, int l, int r) {//建树
	t[p].l = l, t[p].r = r;
	if (l == r) return;
	int mid = (l+r)>>1;
	build(p<<1, l, mid);
	build(p<<1|1, mid+1, r);
}
void change(int p, int l, int r, int x) {//区间修改
	if (l <= t[p].l && t[p].r <= r) {//若该节点被区间覆盖
		t[p].cnt += x;
		update(p);
		return;
	}
	int mid = (t[p].l+t[p].r)>>1;
	if (l <= mid) change(p<<1, l, r, x);
	if (mid < r) change(p<<1|1, l, r, x);
	update(p);//向上传递
}
bool cmp(edge x, edge y) {return x.y < y.y;}
int val(int x) {return lower_bound(a+1, a+tot+1, x)-a;}
int main() {
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;
		e[(i<<1)-1] = (edge){y1, x1, x2, 1};
		e[i<<1] = (edge){y2, x1, x2, -1};
		a[(i<<1)-1] = x1, a[i<<1] = x2;
	}
	n <<= 1;
	sort(e+1, e+n+1, cmp);
	sort(a+1, a+n+1);
	tot = unique(a+1, a+n+1)-a-1;//需要离散化
	build(1, 1, tot);
	for (int i = 1; i <= n; ++i) {
		change(1, val(e[i].x1), val(e[i].x2)-1, e[i].k);
		ans1 += t[1].s1*(e[i+1].y-e[i].y);//统计
		ans2 += t[1].s2*(e[i+1].y-e[i].y);
	}
	cout << ans1 << endl << ans2;
	return 0;
}
```

---

## 作者：Flanksy (赞：5)

### 扫描线套线段树

2023/3/19：修正由 [SpC_](https://www.luogu.com.cn/user/363529) 指出的笔误。

------------

前置知识是扫描线，这里是[模板题](https://www.luogu.com.cn/problem/P5490)。

求矩形面积并的问题及其变种，解法一般是扫描线套线段树。

本文中的扫描线具体指求解矩形面积并问题的一种程序框架。

扫描线基本上是一个固定流程，用差分思想将二维问题压缩到一维，代价是需要在线解决问题。

本题的关键在于如何魔改线段树使其能够分别统计奇偶覆盖区间。对于其他类型的扫描线题目，这一般也适用——扫描线基本都是一样的流程，有时排序条件可能需要改变，比如等高度强制先加边再删边，但本题中不需要。

扫描线过程中的线段树一般为值域离散线段树，用于维护一段离散后的长度区间，通常采取**分层维护**的方法，不使用延迟标记。具体地：若某节点代表的一段区间未被完全覆盖，那么从其左右子树继承答案；若该区间被完全覆盖，那么计算左右子树答案对该节点的影响，然后更新该节点的答案。

这种线段树使用节点代表区间，一般离散后最右边的一个点不会被使用。

本题中具体解决方法为分开维护奇数覆盖长和偶数覆盖长，特殊处理叶子节点。

叶子节点：

- 如果未被覆盖，奇数覆盖长为 $0$，偶数覆盖长为 $0$。
- 如果被覆盖奇数次，奇数覆盖长为区间长，偶数覆盖长为 $0$。
- 如果被覆盖偶数次，奇数覆盖长为 $0$，偶数覆盖长为区间长。

非叶子节点：

- 如果未被覆盖，从左右儿子获得答案。
- 如果被覆盖奇数次，其偶数覆盖长为左右儿子的奇数覆盖长之和，奇数覆盖长为区间长减去偶数覆盖长。
- 如果被覆盖偶数次，其奇数覆盖长为左右儿子的奇数覆盖长之和，偶数覆盖长为区间长减去奇数覆盖长。

也可以开正常情况下 $2$ 倍大小的线段树，不用特殊处理叶子节点。注意一旦区间被覆盖，那么奇偶覆盖长之和就是区间长。

只需要建树和更新线段树，答案直接从根节点拿。

时间复杂度 $O(n \log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Segment{int l,r,w,w1,w2,len;}s[800001];
struct Line{int l,r,y,v;}a[200002];
int n,cnt,p[200001];
long long ans1,ans2;
void build(int u,int l,int r){
    s[u].l=l,s[u].r=r;
    s[u].len=p[r+1]-p[l];//维护区间[l,r+1]
    if(l==r) return;
    build(u*2,l,(l+r)/2);
    build(u*2+1,(l+r)/2+1,r);
}
void update(int u,int l,int r,int k){
    if(s[u].l>r||s[u].r<l) return;
    if(s[u].l>=l&&s[u].r<=r) s[u].w+=k;//更新权值 
    else update(u*2,l,r,k),update(u*2+1,l,r,k);
    if(s[u].l==s[u].r){//特判叶节点 
        if(!s[u].w) s[u].w1=s[u].w2=0;
        else if(s[u].w&1) s[u].w1=s[u].len,s[u].w2=0;
        else s[u].w1=0,s[u].w2=s[u].len;
    }
    else{//奇+奇=偶 
        if(!s[u].w) s[u].w1=s[u*2].w1+s[u*2+1].w1,s[u].w2=s[u*2].w2+s[u*2+1].w2;
        else if(s[u].w&1) s[u].w2=s[u*2].w1+s[u*2+1].w1,s[u].w1=s[u].len-s[u].w2;
        else s[u].w1=s[u*2].w1+s[u*2+1].w1,s[u].w2=s[u].len-s[u].w1;
    }
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        static int l,d,r,u;
        scanf("%d%d%d%d",&l,&d,&r,&u);
        a[++cnt]=Line{l,r,d,1},p[cnt]=l;
        a[++cnt]=Line{l,r,u,-1},p[cnt]=r;
    }
    sort(a+1,a+cnt+1,[](auto x,auto y){return x.y<y.y;});
    sort(p+1,p+cnt+1),cnt=unique(p+1,p+cnt+1)-p-1;
    build(1,1,cnt);
    for(int i=1;i<=n*2;i++){
        a[i].l=lower_bound(p+1,p+cnt+1,a[i].l)-p;
        a[i].r=lower_bound(p+1,p+cnt+1,a[i].r)-p;
        update(1,a[i].l,a[i].r-1,a[i].v);//注意边界
        ans1+=1ll*s[1].w1*(a[i+1].y-a[i].y);
        ans2+=1ll*s[1].w2*(a[i+1].y-a[i].y);
    }
    printf("%lld\n%lld\n",ans1,ans2);
    return 0;
}
```

---

## 作者：_maple_leaf_ (赞：3)

### [luoguP8734](https://www.luogu.com.cn/problem/P8734)

#### 前置芝士：[P5490【模板】扫描线](https://www.luogu.com.cn/problem/P5490 "不会的先写这题")
## 思路
首先，这题肯定是扫描线，然而题解区都是写的离散化线段树，我就来写一个动态开点的线段树。

接着，来分析一下题面，这题让我们分别求出被奇次覆盖的方格数与偶次覆盖的方格数，那么就要在模板扫描线的基础上，将区间覆盖数拆成区间奇次覆盖数与区间偶次覆盖数（不包括 $0$ 次覆盖），那么在 pushup 时就要改动一下。

```cpp
void push_up(int x,int l,int r){
	if(!tr[x].fg){//区间无覆盖标记：由左右儿子加来
		tr[x].j=tr[tr[x].l].j+tr[tr[x].r].j;
		tr[x].o=tr[tr[x].l].o+tr[tr[x].r].o;
		return ;
	}
	if(tr[x].fg&1){//区间标记为奇数：区间奇偶覆盖数互换
		tr[x].o=tr[tr[x].l].j+tr[tr[x].r].j;
		tr[x].j=r-l+1-tr[x].o;
	}
	else{//区间标记为偶数：区间奇偶覆盖数不变
		tr[x].j=tr[tr[x].l].j+tr[tr[x].r].j;
		tr[x].o=r-l+1-tr[x].j;
	}
}
```

剩下的就与正常扫描线一样了，具体见代码。

## code
```cpp
#include<bits/stdc++.h>
//#define int long long 别都开long long，不然MLE送给你
using namespace std;
inline int read(){
	char c=getchar();
	int ret=0,f=1;
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		ret=(ret<<3)+(ret<<1)+c-'0';
		c=getchar();
	}return ret*f;
}
inline void write(long long x,int op){//write要开long long，因为答案输出要long long
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10,0);
	putchar((char)(x%10+'0'));
	if(op){
		if(op>0)puts("");
		if(op<0)putchar(' ');
		if(op==0)puts("114514");
	}
}
const int N=1e7+10;
int n,tot,cnt=1,last;
long long ansj,anso;//答案超过了int范围，要开long long
struct node{
	int t,fg;
	int j,o;
	int l,r;
}tr[N];
struct Node{
	int x,y,_y,z;
}a[N];
bool cmp(Node x,Node y){
	return x.x<y.x;
}
void build(int l,int r,int x,int op){
	int id=++cnt;
	if(op==1)tr[x].l=cnt;
	else tr[x].r=cnt;
}
void push_up(int x,int l,int r){
	if(!tr[x].fg){//区间无覆盖标记：由左右儿子加来
		tr[x].j=tr[tr[x].l].j+tr[tr[x].r].j;
		tr[x].o=tr[tr[x].l].o+tr[tr[x].r].o;
		return ;
	}
	if(tr[x].fg&1){//区间标记为奇数：区间奇偶覆盖数互换
		tr[x].o=tr[tr[x].l].j+tr[tr[x].r].j;
		tr[x].j=r-l+1-tr[x].o;
	}
	else{//区间标记为偶数：区间奇偶覆盖数不变
		tr[x].j=tr[tr[x].l].j+tr[tr[x].r].j;
		tr[x].o=r-l+1-tr[x].j;
	}
}
void gx(int id,int l,int r,int x,int y,int v){
	if(x<=l&&r<=y){
		tr[id].fg+=v;//增加标记
		push_up(id,l,r);
		return ;
	}int mid=(l+r)>>1;
	if(x<=mid){
		if(!tr[id].l)build(l,mid,id,1);//动态开点
		gx(tr[id].l,l,mid,x,y,v);
	}
	if(mid<y){
		if(!tr[id].r)build(mid+1,r,id,2);//动态开点+1
		gx(tr[id].r,mid+1,r,x,y,v);
	}push_up(id,l,r);
}
signed main(){
	n=read();
	for(int i=1;i<=n;i++){
		int aa,bb,cc,dd;
		cin>>bb>>aa>>dd>>cc;
		a[++tot].x=aa;//记录扫描线
		a[tot].y=bb;
		a[tot]._y=dd;
		a[tot].z=1;
		a[++tot].x=cc;
		a[tot].y=bb;
		a[tot]._y=dd;
		a[tot].z=-1;
	}sort(a+1,a+1+tot,cmp);//排一下序
	gx(1,0,1000000000,a[1].y,a[1]._y-1,1),last=a[1].x;//更新上下界为0道1e9
	for(int i=2;i<=tot;i++){
		if(a[i].x!=last){
			ansj+=1ll*(a[i].x-last)*(tr[1].j);//应为a[i].x与last都为int，所以要*1ll
			anso+=1ll*(a[i].x-last)*(tr[1].o);//分别统计奇偶答案
			last=a[i].x;
		}
		gx(1,0,1000000000,a[i].y,a[i]._y-1,a[i].z); 
	}write(ansj,1),write(anso,0);
	return 0;
}//~*完结撒花*~

---

## 作者：chenyizhen (赞：2)

## 思路

不同于普通的的扫描线，本题让我们求奇次和偶次覆盖区间，仔细想一下我们不能直接算得是奇次还是偶次，**这就要求我们的线段树能够保存每一小块区间的奇偶长度**。

```cpp
struct segment_tree{
	int l,r;//表示区间范围
	int len1,len2,sum;//len1表示奇次，len2表示偶次
}
```

接下来我们考虑奇次和偶次的转换，完全覆盖父节点的区间一定覆盖子节点，而父节点的父节点（祖父节点）就不会影响子节点的 $len1$，$len2$。显然：**子节点的区间覆盖次数由且仅由自己和父节点决定**。

在区间修改时：

- 父节点没有被完全覆盖时，区间长度由左右儿子节点决定。

```cpp
if(!t[p].sum){
	t[p].len1=t[p<<1].len1+t[p<<1|1].len1;
	t[p].len2=t[p<<1].len2+t[p<<1|1].len2;
}
```

- 父节点被完全偶次覆盖时，父节点的真实奇次覆盖为子节点的奇次覆盖和，在通过区间总长减去奇次长度，即为偶次区间长度。

```cpp
if(!(t[p].sum&1)){
	t[p].len1=t[p<<1].len1+t[p<<1|1].len1;
	t[p].len2=X[t[p].r]-X[t[p].l]-t[p].len1;
}
```

- 父节点被奇数次完全覆盖时，父节点的真实偶次覆盖为左右儿子子节点奇次覆盖和，后通过区间总长求得奇次覆盖长度。

```cpp
else{
	t[p].len2=t[p<<1].len1+t[p<<1|1].len1;
	t[p].len1=X[t[p].r]-X[t[p].l]-t[p].len2;
}
```

---

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+5;
void read(int &a){
	char ch;int f=1,k=0;ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){k=k*10+ch-'0';ch=getchar();}
	a=k*f;
}
struct Line{
	int l,r,h;
	int mark;
}line[N<<1];
struct segment_tree{
	int l,r;
	int len1,len2,sum;
}t[N<<2];
int n,ans1,ans2,X[N<<1];
bool cmp(Line x,Line y){
	return x.h<y.h;
}

inline void build(int p,int l,int r){
	t[p].l=l,t[p].r=r;
	if(l+1==r) return ;
	int mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid,r);
}

inline void push_up(int p){
	if(!t[p].sum){
		t[p].len1=t[p<<1].len1+t[p<<1|1].len1;
		t[p].len2=t[p<<1].len2+t[p<<1|1].len2;
	}
	else if(!(t[p].sum&1)){
		t[p].len1=t[p<<1].len1+t[p<<1|1].len1;
		t[p].len2=X[t[p].r]-X[t[p].l]-t[p].len1;
	}
	else{
		t[p].len2=t[p<<1].len1+t[p<<1|1].len1;
		t[p].len1=X[t[p].r]-X[t[p].l]-t[p].len2;
	}
}

inline void modify(int p,int l,int r,int w){
	if(X[t[p].r]<=l||X[t[p].l]>=r) return ;
	if(l<=X[t[p].l]&&X[t[p].r]<=r){
		t[p].sum+=w;
		push_up(p);
		return ;
	}
	modify(p<<1,l,r,w);
	modify(p<<1|1,l,r,w);
	push_up(p);
}

signed main(){
	read(n);
	int xa,xb,ya,yb;
	for(int i=1;i<=n;i++){
		read(xa),read(ya),read(xb),read(yb);
		X[i*2-1]=xa,X[i*2]=xb;
		line[2*i-1]=(Line){xa,xb,ya,1};
		line[2*i]=(Line){xa,xb,yb,-1};
	}
	n<<=1;
	sort(line+1,line+1+n,cmp);
	sort(X+1,X+1+n);
	int tot=unique(X+1,X+1+n)-X-1;
	build(1,1,tot);
	for(int i=1;i<n;i++){
		modify(1,line[i].l,line[i].r,line[i].mark);
		ans1+=t[1].len1*(line[i+1].h-line[i].h);
		ans2+=t[1].len2*(line[i+1].h-line[i].h);	
	}
	cout<<ans1<<"\n"<<ans2;
	return 0;
}
```

**补**：注意本题`build(1,1,tot)`，而非 [P5490 【模板】扫描线 & 矩形面积并](https://www.luogu.com.cn/problem/P5490)中的`build(1,1,tot-1)`。~~我才不会告诉你是我不太明白~~分析一下：

|   题目  |         区间表示方式         | 有效区间数 |        参数        |
| :---: | :--------------------: | :---: | :--------------: |
| P5490 | 左闭右开 \[X \[l], X \[r]) | tot-1 | build(1,1,tot-1) |
| P8734 |  闭区间 \[X \[l], X \[r]] | tot-1 |  build(1,1,tot)  |

---
求管理大大通过！！！
到这里结束了，点个赞呗！

---

## 作者：赖今羿 (赞：2)

提供一种不费脑子的做法：

首先离散化、扫描线，问题变成维护区间加一减一、询问全局有多少正数是奇数、多少正数是偶数。

若去除“正数”的条件，这是很容易用一个标记下传的线段树维护的，区间分别维护 $0,1$ 个数、加法标记，一个区间加一或减一就 `swap(cnt0, cnt1)`。

但是有“正数”的条件，这时偶数的答案需要减去 $0$ 的数量，而“区间加一减一、询问全局 $0$ 的数量”就用原版扫描线线段树的方法来维护就行了！

所以我们维护两棵线段树，一棵标记下传，一棵不下传，分别维护奇偶数的数量、$0$ 的数量，修改时两棵线段树同步修改即可。

时间 $O(n\log n)$。

代码很可读：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 10;
struct Rec {
	int Lx, Ly, Rx, Ry;
} rec[N];
int n;

struct Operation {
	int L, R, x, add;
} Ops[N];
int optot;

int Ytot, Y[N];

namespace SegA {
	int len[N << 2], add[N << 2], zero[N << 2];
#define lc (u << 1)
#define rc ((u << 1) | 1)
#define mid ((l + r) >> 1)
	void up(int u) {
		if (add[u]) {
			zero[u] = 0;
		} else {
			zero[u] = zero[lc] + zero[rc];
		}
	}
	void build(int u, int l, int r) {
		len[u] = Y[r + 1] - Y[l];
		zero[u] = len[u];
		add[u] = 0;
		if (l == r) return;
		build(lc, l, mid), build(rc, mid + 1, r);
	}
	void upd(int u, int l, int r, int x, int y, int v) {
		if (y < l || r < x) return;
		if (x <= l && r <= y) {
			add[u] += v;
			if (add[u]) {
				zero[u] = 0;
			} else {
				if (l == r) zero[u] = len[u];
				else zero[u] = zero[lc] + zero[rc];
			}
			return;
		}
		upd(lc, l, mid, x, y, v), upd(rc, mid + 1, r, x, y, v), up(u);
	}
#undef lc
#undef rc
#undef mid
}
namespace SegB {
	int len[N << 2], add[N << 2], odd[N << 2], even[N << 2];
#define lc (u << 1)
#define rc ((u << 1) | 1)
#define mid ((l + r) >> 1)
	void up(int u) {
		odd[u] = odd[lc] + odd[rc];
		even[u] = even[lc] + even[rc];
	}
	void Add(int u) {
		add[u] ^= 1, swap(odd[u], even[u]);
	}
	void down(int u) {
		if (add[u]) Add(lc), Add(rc), add[u] ^= 1;
	}
	void build(int u, int l, int r) {
		len[u] = Y[r + 1] - Y[l], add[u] = 0, odd[u] = 0, even[u] = len[u];
		if (l == r) return;
		build(lc, l, mid), build(rc, mid + 1, r);
	}
	void upd(int u, int l, int r, int x, int y) {
		if (y < l || r < x) return;
		if (x <= l && r <= y) return Add(u);
		down(u), upd(lc, l, mid, x, y), upd(rc, mid + 1, r, x, y), up(u);
	}
#undef lc
#undef rc
#undef mid
}

int main() {
	ios::sync_with_stdio(false), cin.tie(nullptr);
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		cin >> rec[i].Lx >> rec[i].Ly >> rec[i].Rx >> rec[i].Ry;
		Y[++Ytot] = rec[i].Ly, Y[++Ytot] = rec[i].Ry;
		Ops[++optot] = (Operation){rec[i].Ly, rec[i].Ry, rec[i].Lx, 1};
		Ops[++optot] = (Operation){rec[i].Ly, rec[i].Ry, rec[i].Rx, -1};
	}
	sort(Y + 1, Y + Ytot + 1);
	Ytot = unique(Y + 1, Y + Ytot + 1) - Y - 1;
	auto GetY = [&](int y) {
		return lower_bound(Y + 1, Y + Ytot + 1, y) - Y;
	};
	sort(Ops + 1, Ops + optot + 1, [&](Operation u, Operation v) -> bool {
		return u.x == v.x ? u.add > v.add : u.x < v.x;
	});
	for (int i = 1; i <= optot; ++i) 
		Ops[i].L = GetY(Ops[i].L), Ops[i].R = GetY(Ops[i].R) - 1;
	--Ytot;
	SegA::build(1, 1, Ytot);
	SegB::build(1, 1, Ytot);
	ll Odd = 0, Even = 0;
	for (int i = 1; i <= optot; ++i) {
		SegA::upd(1, 1, Ytot, Ops[i].L, Ops[i].R, Ops[i].add);
		SegB::upd(1, 1, Ytot, Ops[i].L, Ops[i].R);
		if (Ops[i].x != Ops[i + 1].x && i != optot) {
			ll len = Ops[i + 1].x - Ops[i].x;
			Odd += len * SegB::odd[1];
			Even += len * (SegB::even[1] - SegA::zero[1]);
		}
	}
	cout << Odd << '\n' << Even << '\n';
	return 0;
}
```

---

## 作者：qwer6 (赞：0)

有一种挺无脑的做法。

我们考虑如果没有被覆盖的位置也算是被覆盖偶数次的话，这道题就十分好求了。

我们定义 $len_{odd}$，$len_{even}$ 分别表示为奇数的位置有多少个，为偶数的位置有多少个。

那么使用永久化标记处理，如果标记为偶数，那么对应相加即可，否则，交换一下就可以了。

具体的，可以这样表示：
$$
len_{p,odd}=len_{ls,odd}+len_{rs,odd}(tag_p\equiv 0 \pmod 2)  \\
len_{p,even}=len_{ls,even}+len_{rs,even}(tag_p\equiv 0 \pmod 2)  \\
len_{p,odd}=len_{ls,even}+len_{rs,even}(tag_p\equiv 1 \pmod 2)  \\
len_{p,even}=len_{ls,odd}+len_{rs,odd}(tag_p\equiv 1 \pmod 2)  \\
$$
但是没有覆盖的位置不算呢？

我们求出被覆盖奇数次的面积，和被覆盖的面积。

两个相减，就是被覆盖偶数次的面积了。

```c++
#include<bits/stdc++.h>
#define int long long
#define Nxt puts("")
#define Spa putchar(32)
#define Pline puts("______________________________")
namespace FastIO{
	inline int read(int &a){
		char c=getchar();
		int f=1;
		a=0;
		while(!isdigit(c)){
			if(c=='-')f=-1;
			c=getchar();
		}
		while(isdigit(c)){
			a=(a<<1)+(a<<3)+(c^48);
			c=getchar();
		}
		a*=f;
		return a;
	}
	inline void write(int x){
		if(x<0)putchar('-'),x=-x;
		std::stack<int>st;
		do{
		   st.push(x%10);
		   x/=10;
		}while(x);
		while(!st.empty())putchar(st.top()+'0'),st.pop();
		return ;
	}
	inline void tomax(int &a,int b){
		if(a<b)a=b;
		return ;
	}
	inline void tomin(int &a,int b){
		if(a>b)a=b;
		return ;
	}
}
using namespace FastIO;
using namespace std;
const int N=1e5+5;
int n,tot,ans1,ans2;
int tmp[N<<1];
struct Line{
	int l,r,y,tp;
	bool operator <(const Line &a)const{return y<a.y;}
}a[N<<1];
struct Segment_tree1{
	int c[N<<4],tag[N<<4],len[N<<4];
	#define ls p<<1
	#define rs p<<1|1
	#define mid (l+r>>1)
	void pushup(int p){
		if(tag[p])c[p]=len[p];
		else c[p]=c[ls]+c[rs];
	}
	void build(int p,int l,int r){
		tag[p]=c[p]=0;
		len[p]=tmp[r+1]-tmp[l];
		if(l==r)return ;
		build(ls,l,mid),build(rs,mid+1,r);
	}
	void change(int p,int l,int r,int L,int R,int v){
		if(L<=l&&r<=R){
			tag[p]+=v;
			pushup(p);
			return ;
		}
		if(mid>=L)change(ls,l,mid,L,R,v);
		if(mid<R)change(rs,mid+1,r,L,R,v);
		pushup(p);
	}
	#undef ls
	#undef rs
	#undef mid
}Set1;
struct Node{
	int len_odd,len_even;
};
struct Segment_tree2{
	Node c[N<<4];
	int tag[N<<4],len[N<<4];
	#define ls p<<1
	#define rs p<<1|1
	#define mid (l+r>>1)
	void pushup(int p){
		if(tag[p]&1){
			c[p].len_odd=c[ls].len_even+c[rs].len_even;
			c[p].len_even=c[ls].len_odd+c[rs].len_odd;
		}else{
			c[p].len_even=c[ls].len_even+c[rs].len_even;
			c[p].len_odd=c[ls].len_odd+c[rs].len_odd;
		}
	}
	void build(int p,int l,int r){
		tag[p]=0;
		c[p].len_even=len[p]=tmp[r+1]-tmp[l];
		if(l==r)return ;
		build(ls,l,mid),build(rs,mid+1,r);
	}
	void change(int p,int l,int r,int L,int R,int v){
		if(L<=l&&r<=R){
			tag[p]+=v;
			if(l==r){
				if(tag[p]&1)c[p].len_odd=len[p],c[p].len_even=0;
				else c[p].len_odd=0,c[p].len_even=len[p];
			}else pushup(p);
			return ;
		}
		if(mid>=L)change(ls,l,mid,L,R,v);
		if(mid<R)change(rs,mid+1,r,L,R,v);
		pushup(p);
	}
	#undef ls
	#undef rs
	#undef mid
}Set2;
signed main(){
	read(n);
	for(int i=1,x,xx,y,yy;i<=n;i++){
		read(x),read(y),read(xx),read(yy);
		a[i]={x,xx,y,1};
		a[i+n]={x,xx,yy,-1};
		tmp[i]=x,tmp[i+n]=xx;
	}
	sort(a+1,a+2*n+1);
//	for(int i=1;i<=2*n;i++)write(a[i].l),Spa,write(a[i].r),Spa,write(a[i].y),Nxt;
//	Pline;
	sort(tmp+1,tmp+2*n+1);
	tot=unique(tmp+1,tmp+2*n+1)-tmp-1;
	for(int i=1;i<=2*n;i++){
		a[i].l=lower_bound(tmp+1,tmp+tot+1,a[i].l)-tmp;
		a[i].r=lower_bound(tmp+1,tmp+tot+1,a[i].r)-tmp;
	}
	Set1.build(1,1,tot-1);
	for(int i=1;i<=2*n;i++){
		if(i!=1)ans1+=(a[i].y-a[i-1].y)*Set1.c[1];
		Set1.change(1,1,tot-1,a[i].l,a[i].r-1,a[i].tp);
	}
	Set2.build(1,1,tot-1);
	for(int i=1;i<=2*n;i++){
		if(i!=1)ans2+=(a[i].y-a[i-1].y)*Set2.c[1].len_odd;
		Set2.change(1,1,tot-1,a[i].l,a[i].r-1,a[i].tp);
	}
	write(ans2),Nxt,write(ans1-ans2),Nxt;
}
```

---

## 作者：内拉组里 (赞：0)

本题采用线段树维护实现扫描线解决。

扫描线不会可以先去写 [<font color=#3498DB>**P5490 【模板】扫描线 & 矩形面积并**</font> ](https://www.luogu.com.cn/problem/P5490)。

# Thoughts :

> 整体扫描线的框架基本不变。
>
> 对于这题，开两个数组 $ sum0 $ 和 $ sum1 $ 分别记录每个节点下被覆盖偶数次和奇数次的总长度。
>
> 注意这里被覆盖偶数次的线段不包含没有被覆盖的线段，
>
> 也就是 $ sum0_{rt} + sum1_{rt} \le len_{rt} $。
>
> 这里重点讲解 pushup 函数。
>
> 分类讨论懒惰标记 $ add_{rt} $。
>
> 1. $ add_{rt} = 0 $，简单的相加デス～
>
> 2. $ add_{rt} $ 为奇数，
>
>    此时 $ sum0_{rt} $ 一定是由左右子树中被覆盖奇数次的线段翻转得到，
>
>    故 $ sum0_{rt} = sum1_{ls} + sum1_{rs} $ 
>
>    又由于存在 $ add_{rt} \neq 0 $ 使得区间内不可能出现权值为负的节点，
>
>    易得 $ sum1_{rt} = len_{rt} - sum0_{rt} $。
>
> 3. $ add_{rt} $ 为偶数，
>
>    此时区间内任意一条线段被覆盖次数的奇偶性都不会被 $ add_{rt} $ 所影响，
>
>    但同样的，这能使原本未被覆盖的点被覆盖偶数次，
>
>    故只有 $ sum1 $ 中的信息能够直接传递，
>
>    而 $ sum0_{rt} = len_{rt} - sum1_{rt} $。

# Details :

> - 这里涉及到的线段及端点数比较多，建议开 $ 10 $ 倍空间以上。

# Analyses :

> 总时间复杂度 $ \Theta (N \log{N}) $ 
>
> 总空间复杂度 $ \Theta (kN) \ (k \ge 10) $ 

# Code :

```cpp
#include	<algorithm>
#include	<iostream>
#include	<vector>
#define		int		long long
using namespace std;
constexpr int maxn = 1e5+4;

int n;
vector<int> b;
struct seg
{
	int l, r, x, val;
	bool operator< (const seg s) const { return x < s.x; }
}sg[maxn << 1];
int add[maxn << 4];
int len[maxn << 4];
int sum0[maxn << 4];
int sum1[maxn << 4];

void pushup (int rt)
{
	if (add[rt] & 1)
	{
		sum0[rt] = sum1[rt << 1] + sum1[rt << 1 | 1];
		sum1[rt] = len[rt] - sum0[rt];
	}
	else if (add[rt])
	{
		sum1[rt] = sum1[rt << 1] + sum1[rt << 1 | 1];
		sum0[rt] = len[rt] - sum1[rt];
	}
	else
	{
		sum0[rt] = sum0[rt << 1] + sum0[rt << 1 | 1];
		sum1[rt] = sum1[rt << 1] + sum1[rt << 1 | 1];
	}
}

void build (int l, int r, int rt)
{
	len[rt] = b[r + 1] - b[l];
	if (l == r) return ;
	int mid = (l + r) >> 1;
	build (l, mid, rt << 1);
	build (mid + 1, r, rt << 1 | 1);
}

void update (int L, int R, int c, int l, int r, int rt)
{
	if (L <= l && r <= R)
	{
		add[rt] += c;
		pushup (rt);
		return ;
	}
	int mid = (l + r) >> 1;
	if (L <= mid) update (L, R, c, l, mid, rt << 1);
	if (mid < R) update (L, R, c, mid + 1, r, rt << 1 | 1);
	pushup (rt);
}

signed main (void)
{
	cin >> n;
	for (int x1, y1, x2, y2, i = 1; i <= n; i++)
	{
		cin >> x1 >> y1 >> x2 >> y2;
		sg[i] = {x1, x2, y1, 1};
		sg[n + i] = {x1, x2, y2, -1};
		b.push_back(x1);
		b.push_back(x2);
	}
	n <<= 1;
	b.push_back(0);
	sort (b.begin(), b.end());
	b.resize(unique (b.begin(), b.end()) - b.begin());
	sort (sg + 1, sg + n + 1);
	build (1, b.size() - 1, 1);
	for (int i = 1; i <= n; i++)
	{
		sg[i].l = lower_bound (b.begin(), b.end(), sg[i].l) - b.begin();
		sg[i].r = lower_bound (b.begin(), b.end(), sg[i].r) - b.begin();
	}
	int ans1 = 0;
	int ans2 = 0;
	for (int i = 1; i <= n; i++)
	{
		if (i > 1)
		{
			ans1 += (sg[i].x - sg[i - 1].x) * sum1[1];
			ans2 += (sg[i].x - sg[i - 1].x) * sum0[1];
		}
		update (sg[i].l, sg[i].r - 1, sg[i].val, 1, b.size() - 1, 1);
//		cout << ans1 << ' ' << ans2 << endl;
	}
	cout << ans1 << endl;
	cout << ans2 << endl;
	return 0;
}
```

---

## 作者：_Mortis_ (赞：0)

~~昨天刚学会扫描线，赶紧来写一篇题解~~

### 前置知识：扫描线

还不会扫描线的看[这题](https://www.luogu.com.cn/problem/P8734)，本题解不再讲述扫描线的实现。

### 题意

给出 $ n $ 个矩形，求被奇数次和被偶数次覆盖的面积。

### 思路

~~这题就是扫描线模板稍微改一改~~

和模板题不一样，这题需要维护两个区间长度（奇数次覆盖和偶数次覆盖）。

看到很多题解都这么做了，维护 $ len1 $ 和 $ len2 $，pushup 函数~~感觉好麻烦~~

我很懒，所以不想改动板子，所以想出来一个相对简单一些的做法：

模板里的总长度 $ len $ 不要扔掉，只需维护奇数次覆盖长度 $ len1 $，偶数次长度只需 $ len - len1 $ 即可。

现在考虑如何维护奇数次覆盖长度 $ len1 $。

分三种情况：

1.区间没被覆盖：左右儿子相加即可。

2.区间覆盖次数为奇数：奇 $ + $ 奇 $ = $ 偶，如果左右儿子有覆盖次数为奇数的，相加即为偶数，需要去掉。所以奇数次覆盖长度 $ = $ 区间总长 $ - $ 左右儿子奇数次覆盖长度。

3.区间覆盖次数为偶数：偶 $ + $ 奇 $ = $ 奇，还是左右儿子相加

上述所有操作在 pushup 函数内实现：

```cpp
void push_up(int p){
  //模板 
	if(T[p].cover)T[p].len=xx[T[p].r]-xx[T[p].l];
	else T[p].len=T[lch].len+T[rch].len;
  //奇数次覆盖长度
	if(T[p].cover&1)T[p].len1=xx[T[p].r]-xx[T[p].l]-(T[lch].len1+T[rch].len1);//第二种情况
	else T[p].len1=T[lch].len1+T[rch].len1;//第一种情况和第三种情况
}
```

### 完整代码：

~~拒绝抄袭代码，共创和谐洛谷~~

```cpp
#include<iostream>
#include<algorithm>
#define int long long
#define lch (p<<1)
#define rch (p<<1|1)
using namespace std;
const int N=1e5+10;
struct node{
	int l,r,len,len1,cover;
}T[N<<4];//空间开大些保险
struct Line{
	int lx,rx,y,inout;
	friend bool operator < (const Line &x,const Line &y){
		return x.y<y.y;
	}
}line[N<<1];
int n,m,xx[N<<1],ans,nx,ny,cnt,k,ans1;
char op;
void push_up(int p){
  //模板 
	if(T[p].cover)T[p].len=xx[T[p].r]-xx[T[p].l];
	else T[p].len=T[lch].len+T[rch].len;
  //奇数次覆盖长度
	if(T[p].cover&1)T[p].len1=xx[T[p].r]-xx[T[p].l]-(T[lch].len1+T[rch].len1);//第二种情况
	else T[p].len1=T[lch].len1+T[rch].len1;//第一种情况和第三种情况
}
void build(int p,int l,int r){
	T[p].l=l,T[p].r=r,T[p].len=T[p].cover=0;
	if(l+1==r)return;
	int mid=l+r>>1;
	build(lch,l,mid);
	build(rch,mid,r);
}
void update(int p,int l,int r,int v){
	if(T[p].r<=l||T[p].l>=r)return;
	if(T[p].l>=l&&T[p].r<=r){
		T[p].cover+=v;
		push_up(p);
		return;
	}
	update(lch,l,r,v);
	update(rch,l,r,v);
	push_up(p);
}
int f(int x){
	return lower_bound(xx+1,xx+m+1,x)-xx;
}
void make(int x1,int x2,int y1,int y2){
	line[++cnt]=(Line){x1,x2,y1,1};
	xx[cnt]=x1;
	line[++cnt]=(Line){x1,x2,y2,-1};
	xx[cnt]=x2;
}
signed main(){
	cin.tie(0)->sync_with_stdio(0);
	cin>>n;
	for(int x,x1,x2,y1,y2;n--;){
		cin>>x1>>y1>>x2>>y2;
		make(x1,x2,y1,y2);
	}
	sort(line+1,line+cnt+1);
	sort(xx+1,xx+cnt+1);
	m=unique(xx+1,xx+cnt+1)-xx-1;
	build(1,1,m);
	for(int i=1;i<=cnt;i++){
		ans+=T[1].len*(line[i].y-line[i-1].y);
		ans1+=T[1].len1*(line[i].y-line[i-1].y);
		update(1,f(line[i].lx),f(line[i].rx),line[i].inout);
	}
	cout<<ans1/*奇数次*/<<"\n"<<ans-ans1/*总面积减去奇数次面积*/<<"\n";
	return 0;
}//其他为扫描线模板，不再注释
```

[AC 记录](https://www.luogu.com.cn/record/172317488)

---

## 作者：CloudDreamLake (赞：0)

挺好一道题。

矩形覆盖问题，第一时间就想到了扫描线。

再分析题意，朴素的想法是建立一颗线段树，维护 $0$ / 奇 / 偶 ( $\geqslant2$ ) 分别的个数，但这其实不好转移（即 `add/del` 时，三类数的变化）

然后发现，只维护 奇 / 偶 的个数是好做的。
知道奇数的个数后，只需要用总面积相减就可以了，而总面积就是矩形面积并。

于是我们做两遍扫描线：
+ 维护 奇 / 偶 的个数。每次 `upd` 时打 `rev-tag`，具体来说，`rev-tag` 使 `cnt[u] = r - l + 1 - cnt[u]` 
+ 求取矩形面积并 [P5490 【模板】扫描线 & 矩形面积并](https://www.luogu.com.cn/problem/P5490)

下面贴出两颗线段树：
```cpp

// 奇偶统计
namespace Sgt1 {
    #define mid ((l + r) >> 1)
    void updrev(int& u, int l, int r) {
        if(!u) u = ++tot;
        tag[u] ^= 1;
        cnt[u] = (r - l + 1) - cnt[u];
    }
    void down(int u, int l, int r) {
        if(tag[u]) {
            updrev(chl[u][0], l, mid);
            updrev(chl[u][1], mid + 1, r);
            tag[u] = 0;
        }
    }
    void up(int u) {
        cnt[u] = cnt[chl[u][0]] + cnt[chl[u][1]];
    }
    void upd(int& u, int l, int r, int L, int R) {
        if(!u) u = ++tot;
        if(L <= l && r <= R) {
            updrev(u, l, r);
            return ;  
        }
        down(u, l, r);
        if(L <= mid) upd(chl[u][0], l, mid, L, R);
        if(R > mid) upd(chl[u][1], mid + 1, r, L, R);
        up(u);  
    }
    #undef mid
}

// 矩形面积并 -> - 奇 = 偶的面积
namespace Sgt2 {
    #define mid ((l + r) >> 1
    void up(int u, int l, int r) {
        if(tag[u]) cnt[u] = r - l + 1;
        else cnt[u] = cnt[chl[u][0]] + cnt[chl[u][1]];
    }
    void upd(int& u, int l, int r, int L, int R, int f) {
        if(!u) u = ++tot;
        if(L <= l && r <= R) {
            tag[u] += f;
            up(u, l, r);
            return ;  
        }
        if(L <= mid) upd(chl[u][0], l, mid, L, R, f);
        if(R > mid) upd(chl[u][1], mid + 1, r, L, R, f);
        up(u, l, r);  
    }
    #undef mid
}

```
考试时写的动态开点，卡空间是无法通过的。  
离散化就交给你们了~

---

## 作者：Mason123456 (赞：0)

矩形？面积？坐标系？扫描线！

### 思路

扫描线是干嘛的？

扫描线的本质，就是割补法中的“割”，利用一小个的规整矩形来算出矩形内的信息，其中，有面积，周长等。

扫描线中的线段树，让我们可以在 $\log$ 的时间复杂度内算出任意 $x$ 坐标是否被包括在一个矩形内。利用这个性质，我们可以快速知道扫描线内奇数矩形和偶数矩形所在的 $x$ 轴，也可以知道它们的面积。

它们的奇面积就是奇区间与 $x$ 坐标平行的线段长度 $\times h$，即扫描线高度之差，如图的绿色区域即为奇数边的区域，黄色区域就是偶数边的区域。我们需要**分别**维护**区间内被覆盖的偶数边和奇数边长度和**。

![](https://cdn.luogu.com.cn/upload/image_hosting/xcqx5vce.png)

### 实现

在模板中，我们用 $sum$ 表示区间被覆盖的长度，要分奇偶情况的话，就要开两个 $sum$，分别表示奇数覆盖长度，偶数覆盖长度。懒标记的定义和模板一样。

于是，变化最大的就是 `push_up` 函数了。

```cpp
int sum1[N], sum2[N];// 分别表示奇数区间长度和偶数区间长度
int laz[N];
int lhs[N], rhs[N];// 动态开点，分别表示 num 的左儿子和右儿子
void push_up (int num, int l, int r) {
	if(!laz[num]){// 如果 laz 没有更新，即区间太大
		sum1[num] = sum1[lhs[num]] + sum1[rhs[num]];// 区间和为左右两个子区间相加
		sum2[num] = sum2[lhs[num]] + sum2[rhs[num]];
	}
	if(laz[num] & 1){// 如果 laz 更新为奇数
		sum2[num] = sum1[lhs[num]] + sum1[rhs[num]];// 儿子的奇数区间和被更新到了父亲的偶数。
		sum1[num] = r - l + 1 - sum2[num];// 父亲的奇数和为区间长度减去偶数长度。
	}
	else if(laz[num]){
		sum1[num] = sum1[lhs[num]] + sum1[rhs[num]];// 奇数 + 偶数 = 奇数，**需要注意！！**
		sum2[num] = r - l + 1 - sum1[num];
	}
}
```

于是，答案就是 $sum_{root} \times (h_{i+1} - h_i)$。其中 $h_i$ 表示第 $i$ 条扫描线的高度。其中 $sum$ 应在代码中变为 `sum1` 或 `sum2`。

附言：不想离散化就去写动态开点！

完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 5e6 + 5;

struct node {
	ll l, r, h;
	int mark;
} a[N];

int n, cnt = 0, tot = 0, rt = 0;
int sum1[N], sum2[N];
int laz[N];
int lhs[N], rhs[N];
ll ans1 = 0, ans2 = 0;// 分别表示奇数，偶数的面积和 

bool cmp (node x, node y) {
	if(x.h != y.h)	return x.h < y.h;
	return x.mark > y.mark;
}

void push_up (int num, int l, int r) {
	if(!laz[num]){
		sum1[num] = sum1[lhs[num]] + sum1[rhs[num]];
		sum2[num] = sum2[lhs[num]] + sum2[rhs[num]];
	}
	if(laz[num] & 1){
		sum2[num] = sum1[lhs[num]] + sum1[rhs[num]];
		sum1[num] = r - l + 1 - sum2[num];
	}
	else if(laz[num]){
		sum1[num] = sum1[lhs[num]] + sum1[rhs[num]];
		sum2[num] = r - l + 1 - sum1[num];
	}
}

void upd (int &num, int L, int R, int l, int r, int v){
	if (!num)	num = ++tot;// 动态开点
	if (L > r || R < l)	return;
	if (l >= L && r <= R) {
		laz[num] += v;// 标记永久化
		push_up(num, l, r);
		return;
	}
	int mid = (l + r) >> 1;
	upd(lhs[num], L, R, l, mid, v);
	upd(rhs[num], L, R, mid + 1, r, v);
	push_up(num, l, r);
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	
	cin >> n;
	for (int i = 1; i <= n; i++) {
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;
		a[++cnt] = {x1, x2, y1, 1};// 参考扫描线板子
		a[++cnt] = {x1, x2, y2, -1};
	}
	sort(a + 1, a + cnt + 1, cmp);
	for (int i = 1; i < cnt; i++) {
		upd(rt, a[i].l, a[i].r-1, 0, 1e9, a[i].mark);
		ans1 += 1ll * sum1[rt] * (a[i + 1].h - a[i].h);// 分别更新奇数答案，偶数答案。
		ans2 += 1ll * sum2[rt] * (a[i + 1].h - a[i].h);
	}
	cout << ans1 << "\n";
	cout << ans2;
	return 0;
}
```

---

## 作者：Kazeno_Akina (赞：0)

[传送门](https://www.luogu.com.cn/problem/P8734)

题目大意：给出多个矩形，求被这些矩形覆盖了奇数次的点的面积和被覆盖了偶数次的点的面积。矩形数量 $\le 10^5$，坐标值域为 $[0,10^9]$ 内的整数。

~~怎么大家都在过程中维护偶数次面积的，不觉得很难维护吗~~

我就是那个觉得很难维护的人，所以提供一种略有不同的解法。

考虑这东西和矩形面积并非常像，所以考虑扫描线。但是扫描线板子只能解决最简单的矩形面积并，不能解决带有奇偶性分析的情况。

所以我们考虑怎么扩展扫描线里面的线段树功能。

由于线段树可以进行大部分区间操作，所以我们这里不妨采用区间取反来维护某一处点的奇偶性。具体实现可以理解为区间全体异或 $1$（此处一段区间可理解为一个 $01$ 串）。

但是发现一个性质，就是这时候我们不知道一个点显示被覆盖了偶数次时它有没有被覆盖过，换言之，我们不知道 $0$ 和其他偶数在这种情况下的区别。

于是考虑正难则反。容易发现被覆盖奇数次的面积+被覆盖偶数次的面积=矩形面积并，所以只需要做一次常规扫描线，一次奇数覆盖扫描线即可。而这两个操作没啥互斥成分所以你直接一起做就行了。

关于细节：

+ 请记得线段树每个端点维护的都是一段小的区间。

+ 由于一个矩形会被拆成两条线段，所以此处线段树空间要开到 $8 \times 10^5$ 左右。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5;
struct node{
    int l,r,mini,mincnt,len,tag1,tag2;
    long long sum;
};//其中 mini,mincnt,tag1 用于常规扫描线，len,sum,tag2 用于奇数覆盖扫描线
struct rect{int l,r,x,cnt;};
int n,tot,mem[N<<1];
node tr[N<<3];
rect pr[N<<1];
set<int> s;
long long ans1,ans2;
unordered_map<int,int> mp;
inline bool cmp(rect a,rect b){return a.x<b.x;}
void build(int p,int l,int r){
    tr[p].l=l,tr[p].r=r,tr[p].mini=tr[p].sum=0,tr[p].mincnt=tr[p].len=mem[tr[p].r+1]-mem[tr[p].l];
    if(l==r) return;
    int mid(l+r>>1);
    build(p<<1,l,mid),build(p<<1|1,mid+1,r);
}
inline void pushdown(int p){
    if(tr[p].tag1){
        tr[p<<1].mini+=tr[p].tag1,tr[p<<1|1].mini+=tr[p].tag1;
        tr[p<<1].tag1+=tr[p].tag1,tr[p<<1|1].tag1+=tr[p].tag1;
        tr[p].tag1=0;
    }
    if(tr[p].tag2){
        tr[p<<1].sum=tr[p<<1].len-tr[p<<1].sum;
        tr[p<<1|1].sum=tr[p<<1|1].len-tr[p<<1|1].sum;
        tr[p<<1].tag2^=1,tr[p<<1|1].tag2^=1;
        tr[p].tag2=0;
    }
}
inline void pushup(int p){
    if(tr[p<<1].mini<tr[p<<1|1].mini) tr[p].mini=tr[p<<1].mini,tr[p].mincnt=tr[p<<1].mincnt;
    else if(tr[p<<1].mini>tr[p<<1|1].mini) tr[p].mini=tr[p<<1|1].mini,tr[p].mincnt=tr[p<<1|1].mincnt;
    else tr[p].mini=tr[p<<1].mini,tr[p].mincnt=tr[p<<1].mincnt+tr[p<<1|1].mincnt;
    tr[p].sum=tr[p<<1].sum+tr[p<<1|1].sum;
}
void upd(int p,int l,int r,int idx){
    if(l<=tr[p].l&&tr[p].r<=r){
        tr[p].mini+=idx,tr[p].tag1+=idx;
        tr[p].sum=tr[p].len-tr[p].sum,tr[p].tag2^=1;
        return;
    }
    pushdown(p);
    int mid(tr[p].l+tr[p].r>>1);
    if(l<=mid) upd(p<<1,l,r,idx);
    if(mid<r) upd(p<<1|1,l,r,idx);
    pushup(p);
}
inline long long query(){return tr[1].mini?tr[1].len:(tr[1].len-tr[1].mincnt);}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin >> n;
    for(int i(0),l,b,r,t;i<n;++i){
        cin >> l >> b >> r >> t;
        pr[i<<1].l=pr[i<<1|1].l=b,pr[i<<1].r=pr[i<<1|1].r=t;
        pr[i<<1].cnt=1,pr[i<<1|1].cnt=-1;
        pr[i<<1].x=l,pr[i<<1|1].x=r;
        s.insert(b),s.insert(t);
    }
    sort(pr,pr+(n<<1),cmp);
    for(auto it(s.begin());it!=s.end();++it) mem[++tot]=(*it),mp[*it]=tot;
    mem[++tot]=mem[tot]+1,mp[mem[tot]]=tot;
    build(1,1,tot-1);
    for(int i(0);i<(n<<1);++i){
        if(i&&pr[i].x!=pr[i-1].x) ans1+=query()*(pr[i].x-pr[i-1].x),ans2+=tr[1].sum*(pr[i].x-pr[i-1].x);
        upd(1,mp[pr[i].l],mp[pr[i].r]-1,pr[i].cnt);
    }
    cout << ans2 << '\n' << ans1-ans2;
    return 0;
}
```

---

## 作者：zzxoier_acmer (赞：0)

# 题目解析：

本题，属于扫描线中比较简单的类型了，我们将扫描线的板子改一下，因为我们这道题问的是奇数个覆盖和偶数个覆盖，所以，我们要对每一组线段树维护五个变量，分别是 $l$ 是左端点，$r$ 为右端点，$sum$ 为计量有多少个矩形覆盖其上，$len1$ 为奇数个矩形覆盖的长度，$len2$ 为偶数个矩形覆盖的长度。

这时，我们发现其实不能直接用扫描线集体加 $1$ 或减 $1$ 的方式进行扫描，我们就要分类讨论。如果被奇数次的覆盖了，则 $len2$ 等于两颗子树的 $len1$ 之和，$len1$ 等于横坐标之差减去 $len2$ 的长度，也就是奇数区的偶等于奇加奇，奇等于区间长减偶。被偶数次覆盖则为奇等于奇加奇，偶等于区间长减奇。之于没有被覆盖，则奇等于奇加奇，偶等于偶加偶。

最后，再说一点，每次线段树更新时一定都是从左右子树得来的，不要写错两颗子树的下标变化式，这是大忌。

# 代码如下：

```

#include <bits/stdc++.h>
using namespace std;
#define int long long
struct node
{
    int x1, yy, x2, y2;
} p[4000009];
int n;
struct nnn
{
    int x1, x2, y, val;
} bian[4000009];
bool cmp(nnn a, nnn b)
{
    return a.y < b.y;
}
int res = 0;
int X[4000009];
struct Node
{
    int len1, len2, l, r, sum;
} tr[4000009];
void pushup(int k, int l, int r)
{
    // int l = tr[k].l, r = tr[k].r;
    if (tr[k].sum != 0)
    {
        if (tr[k].sum & 1)
        {
            tr[k].len2 = tr[k << 1].len1 + tr[k << 1 | 1].len1;
            tr[k].len1 = (X[r + 1] - X[l]) - tr[k].len2;
            // cout << "1tr[" << k << "]=" << tr[k].len1 << " and " << tr[k].len2 << endl;
        }
        else
        {
            tr[k].len1 = tr[k << 1].len1 + tr[k << 1 | 1].len1;
            tr[k].len2 = (X[r + 1] - X[l]) - tr[k].len1;
            // cout << "2tr[" << k << "]=" << tr[k].len1 << " and " << tr[k].len2 << endl;
        }
    }
    else
    {
        tr[k].len1 = tr[k << 1].len1 + tr[k << 1 | 1].len1;
        tr[k].len2 = tr[k << 1].len2 + tr[k << 1 | 1].len2;
        // cout << "3tr[" << k << "]=" << tr[k].len1 << " and " << tr[k].len2 << endl;
    }
}
void update(int k, int l, int r, int L, int R, int v)
{
    // if (L >= l && R <= r)
    // {
    //     tr[k].num += v;
    //     pushup(k);
    // }
    if (L <= l && R >= r)
    {
        tr[k].sum += v;
        pushup(k, l, r);
        return;
    }
    int mid = l + r >> 1;
    // int mid = floor((l + r) / 2);
    if (L <= mid)
    {
        update(k << 1, l, mid, L, R, v);
    }
    if (R > mid)
    {
        update(k << 1 | 1, mid + 1, r, L, R, v);
    }
    pushup(k, l, r);
}
int get(int x)
{
    // return lower_bound(X + 1, X + res + 1, x);
    // lower_bound(X + 1, X + res + 1, x) - X - 1;
    return lower_bound(X + 1, X + res + 1, x) - X;
}
signed main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> p[i].x1 >> p[i].yy >> p[i].x2 >> p[i].y2;
        bian[i * 2 - 1] = {p[i].x1, p[i].x2, p[i].yy, 1};
        bian[i * 2] = {p[i].x1, p[i].x2, p[i].y2, -1};
        X[++res] = p[i].x1;
        X[++res] = p[i].x2;
    }
    sort(X + 1, X + res + 1);
    res = unique(X + 1, X + res + 1) - X - 1;
    int ans1 = 0, ans2 = 0, ans = 0;
    sort(bian + 1, bian + 2 * n + 1, cmp);
    for (int i = 1; i < 2 * n; i++)
    {
        // update(get(bian[i].x1), get(bian[i].x2) - 1, bian[i].val, 1, res, 1);
        update(1, 1, res, get(bian[i].x1), get(bian[i].x2) - 1, bian[i].val);
        ans1 += tr[1].len1 * (bian[i + 1].y - bian[i].y);
        ans2 += tr[1].len2 * (bian[i + 1].y - bian[i].y);
        // cout << ans1 << ' ' << ans2 << endl;
    }
    cout << ans1 << '\n'
         << ans2 << endl;
    return 0;
}

```

---

## 作者：Eltaos_xingyu (赞：0)

### 题目描述

在平面内有一些矩形，它们的两条边都平行于坐标轴。

我们称一个点被某个矩形覆盖，是指这个点在矩形的内部或者边界上。

请问，被奇数个矩形覆盖和被偶数（$\leq2$）个矩形覆盖的点的面积分别是多少?

### 实现

显然这题是一道扫描线，不会扫描线的同学先去做[这道题](https://www.luogu.com.cn/problem/P5490)。本题解就不讲扫描线是如何实现的了。

由于要奇偶分开输出，我们的线段树就不能像下面的代码一样只维护一个区间长度了。

```cpp
void pushup(int now){
	if(tree[now].num){
		tree[now].len=x[tree[now].r+1]-x[tree[now].l];
	}
	else{
		tree[now].len=tree[now*2].len+tree[now*2+1].len;
	}
}
```

很显然，上面这份代码的 `len` 要被拆成两个，一个用来存奇数覆盖，一个用来存偶数覆盖。由于要保证奇加上偶的面积等于总面积并，我们需要修改原来的上推函数。

显然，这要分成 $3$ 种情况：

- 没有覆盖：奇偶都只需要从左右儿子加和就行了。

- 覆盖的矩形数为奇数：此时当前的奇数长度更多要依赖区间长度计算，于是先算偶数长度。根据偶等于奇（当前覆盖矩形数）加奇（左右儿子），偶数长度是左右儿子奇数长度之和。又由于满足奇偶加和为总面积并，所以奇数长度就等于区间长度减刚刚才算的偶数长度。

- 覆盖的矩形数为偶数：根据奇等于偶加奇，奇数长度是左右儿子奇数长度之和。同上面的分析，偶数长度是区间长度减刚刚算的奇数长度。

在扫描线的基础上这样修改完上推函数，这道题也就做完了。

提示：记得把空间开大一点！

AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int x[2000001];
struct segtree{
	int l;
	int r;
	long long len1,len2,num;
};
segtree tree[4000050];
struct defline{
	int xl,xr,y;
	long long num;
};
defline line[4000050];
bool cmp(defline a,defline b){
	return a.y<b.y;
}
void build(int l,int r,int now){
	tree[now].l=l,tree[now].r=r;
	tree[now].len1=0;
	tree[now].len2=0;
	tree[now].num=0;
	if(l==r)return;
	int mid=(l+r)/2;
	build(l,mid,now*2),build(mid+1,r,now*2+1);
	return;
}
void pushup(int now){
	if(tree[now].num==0){
		tree[now].len1=tree[now*2].len1+tree[now*2+1].len1;
		tree[now].len2=tree[now*2].len2+tree[now*2+1].len2;
	}
	else if(tree[now].num%2){
		tree[now].len2=tree[now*2].len1+tree[now*2+1].len1;
		tree[now].len1=x[tree[now].r+1]-x[tree[now].l]-tree[now].len2;
	}
	else{
		tree[now].len1=tree[now*2].len1+tree[now*2+1].len1;
		tree[now].len2=x[tree[now].r+1]-x[tree[now].l]-tree[now].len1;
	}
}
void update(int l,int r,int now,int num){
	if(x[tree[now].r+1]<=l||x[tree[now].l]>=r)return;
	if(x[tree[now].r+1]<=r&&x[tree[now].l]>=l){
		tree[now].num+=num;
		pushup(now);
		return;
	}
	update(l,r,now*2,num);
	update(l,r,now*2+1,num);
	pushup(now);
	return;
}
int main(){
	int n,xlt,xrt,yup,ydown;
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>xlt>>ydown>>xrt>>yup;
		x[i*2-1]=xlt;
		x[i*2]=xrt;
		line[i*2-1].xl=xlt;
		line[i*2-1].xr=xrt;
		line[i*2-1].y=ydown;
		line[i*2-1].num=1;
		line[i*2].xl=xlt;
		line[i*2].xr=xrt;
		line[i*2].y=yup;
		line[i*2].num=-1;
	}
	n*=2;
	sort(x+1,x+n+1);
	sort(line+1,line+n+1,cmp);
	int tot=unique(x+1,x+n+1)-x-1;
	build(1,tot-1,1);
	long long ans1=0,ans2=0;
	for(int i=1;i<n;i++){
		update(line[i].xl,line[i].xr,1,line[i].num);
		ans1+=tree[1].len1*(line[i+1].y-line[i].y);
		ans2+=tree[1].len2*(line[i+1].y-line[i].y);
	}
	cout<<ans1<<endl<<ans2<<endl;
    return 0;
}
```


---

## 作者：P_VICVIC_R (赞：0)

~~扫描线板子改改就能过~~

---

### 题意：

在平面内有一些矩形，它们的两条边都平行于坐标轴。

问被奇数个矩形覆盖和被偶数个矩形覆盖的点的面积分别是多少?

与板子的区别就在这道题要区分被奇数个矩形覆盖还是被偶数个矩形覆盖。

### 思路：

你会发现这道题的输入输出都可以用模板的……所以模板没做的先做[模板](https://www.luogu.com.cn/problem/P5490)吧。

区分奇偶肯定是用覆盖次数来区别~~（废话）~~，那么我们考虑将原本的 $\texttt{PushUp}$ 拆成两个部分。

这是原本的：

```c++
inline void PushUp(int rt){
	if(T[rt].sum)
		T[rt].Length=X[T[rt].r+1]-X[T[rt].l];
	else
		T[rt].Length=T[rt<<1].Length+T[rt<<1|1].Length;
}
```

对于代码中的无覆盖情况，一样就是上传就行。

对于有覆盖的我们分类讨论：

- 覆盖次数为奇数时，偶数的长度等于左右儿子的奇数长度相加（当前区间是奇数，加上左右儿子的奇数长度，奇数加奇数等于偶数），奇数的长度等于整体的长度减掉偶数的长度（总长度等于奇数长度加偶数长度）；
- 覆盖次数为偶数时，奇数的长度等于左右儿子的奇数长度相加（当前区间是偶数，加上左右儿子的奇数长度，偶数加奇数等于奇数），偶数的长度等于整体的长度减掉奇数的长度（总长度等于奇数长度加偶数长度）；

其他都与板子一样。

### code

只放 $\texttt{PushUp}$ 的部分，其他都与模板一样。

```c++
//sum:覆盖次数
//Le:奇数次的长度
//Lo:偶数次的长度
inline void PushUp(int rt){
    if(!T[rt].sum){
        T[rt].Le=T[rt<<1].Le+T[rt<<1|1].Le;
        T[rt].Lo=T[rt<<1].Lo+T[rt<<1|1].Lo;
    }
    else if(T[rt].sum&1){
        T[rt].Le=T[rt<<1].Lo+T[rt<<1|1].Lo;
        T[rt].Lo=X[T[rt].r+1]-X[T[rt].l]-T[rt].Le;
    }
    else{
        T[rt].Lo=T[rt<<1].Lo+T[rt<<1|1].Lo;
        T[rt].Le=X[T[rt].r+1]-X[T[rt].l]-T[rt].Lo;
    }
}
```

---


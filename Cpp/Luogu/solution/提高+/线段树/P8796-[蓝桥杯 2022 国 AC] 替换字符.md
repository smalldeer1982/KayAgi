# [蓝桥杯 2022 国 AC] 替换字符

## 题目描述

给定一个仅含小写英文字母的字符串 $s$，每次操作选择一个区间 $[l_i,r_i]$ 将 $s$ 的该区间中的所有字母 $x_i$ 全部替换成字母 $y_i$，问所有操作做完后，得到的字符串是什么。

## 说明/提示

**【评测用例规模与约定】**

- 对于 $40\%$ 的评测用例，$|s|, m \leq 5000$；
- 对于所有评测用例，$1 \leq |s|, m \leq 10^5$，$1 \leq l_i \leq r_i \leq |s|$，$x_i\neq y_i$，其中 $|s|$ 表示字符串 $s$ 的长度。

蓝桥杯 2022 国赛 A 组 H 题（C 组 J 题）。

## 样例 #1

### 输入

```
abcaaea
4
1 7 c e
3 3 e b
3 6 b e
1 4 a c```

### 输出

```
cbecaea
```

# 题解

## 作者：Usada_Pekora (赞：13)

注意到值域很小，直接对值域冲。

我们只需要维护，对于每个区间，每个字符被覆盖成了哪个别的字符即可，这个可以线段树解决。

具体地，对于每个节点维护一个长度 $26$ 的 lazytag 表示对于这个区间，每个字母分别被替换成了哪个字母，直接暴力下传即可。

标记下推大概是这样：

```cpp
for (int i = 0; i < 26; i++)
	lzy[ls][i] = lzy[p][lzy[ls][i]];
for (int i = 0; i < 26; i++)
	lzy[rs][i] = lzy[p][lzy[rs][i]];
for (int i = 0; i < 26; i++)
	lzy[p][i] = i;
```

复杂度 $O(m|\Sigma|\log n)$，其中 $|\Sigma|$ 是字符集大小 $26$。

然后就差不多结束了，具体可以看代码实现。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5, K = 26;
int lzy[N * 2][K], ls[N * 2], rs[N * 2], val[N * 2], idx, n, m;
char a[N];
inline int build(int l, int r) {
	int p = ++idx;
	for (int i = 0; i < K; i++)
		lzy[p][i] = i;
	if (l == r) {
		val[p] = a[l] - 'a';
		return p;
	}
	int mid = (l + r) >> 1;
	ls[p] = build(l, mid);
	rs[p] = build(mid + 1, r);
	return p;
}
inline void pushdown(int p) {
	for (int i = 0; i < K; i++)
		lzy[ls[p]][i] = lzy[p][lzy[ls[p]][i]];
	for (int i = 0; i < K; i++)
		lzy[rs[p]][i] = lzy[p][lzy[rs[p]][i]];
	for (int i = 0; i < K; i++)
		lzy[p][i] = i;
}
inline void modify(int p, int l, int r, int L, int R, int x, int y) {
	if (L <= l && r <= R) {
		for (int i = 0; i < K; i++)
			if (lzy[p][i] == x)
				lzy[p][i] = y;
		return;
	}
	pushdown(p);
	int mid = (l + r) >> 1;
	if (L <= mid)
		modify(ls[p], l, mid, L, R, x, y);
	if (R > mid)
		modify(rs[p], mid + 1, r, L, R, x, y);
}
inline void print(int p, int l, int r) {
	if (l == r) {
		printf("%c", lzy[p][val[p]] + 'a');
		return;
	}
	pushdown(p);
	int mid = (l + r) >> 1;
	print(ls[p], l, mid), print(rs[p], mid + 1, r);
}
signed main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	cin >> a + 1;
	n = strlen(a + 1);
	build(1, n);
	cin >> m;
	for (int i = 1; i <= m; i++) {
		int l, r;
		char x, y;
		cin >> l >> r >> x >> y;
		x = x - 'a', y = y - 'a';
		modify(1, 1, n, l, r, x, y);
	}
	print(1, 1, n);
	return 0;
}
```

---

## 作者：Xy_top (赞：8)

本来是奔着线段树合并来的，发现这题直接用线段树简单一些，写一篇线段树的题解。

注意！如果你线段树调不出来试试这个：
````
abcaaea
2
1 7 a e
1 7 a z
````
输出应该是 ``ebceeee``，如果你输出 ``zbczzez``，说明你的 ``pushdown`` 等出了问题，看我的题解。

题解：

因为字符的数量只有 $26$ 个，所以我们可以设定懒标记。

``mul[k][i]`` 表示的是标号为 $k$ 的小线段树内字符 $i$ 被改成了什么，当然这样太费空间，我们把 $i$ 减去 $97$ 省一些空间。

剩下的就是线段树板子，但这里的 ``pushdown`` 和一些其他的东西不太好写，我来说一下。

先来讲 ``update``，当前区间被修改区间完全覆盖时，该怎么处理？

设修改操作为将 $a$，$b$ 中的所有 $x$ 改成 $y$

如果我们仅仅 ``mul[k][x] = y``，这是显然不行的。假设 ``mul[k][x]`` 原来有值，值为 $z$，也就是说这个区间内之前所有的 $x$ 都被改成了 $z$，现在不可能把 $z$ 改回 $x$ 的，因为修改操作是把所有的 $x$ 变成 $y$。（说的不是很清楚，看不懂多看几遍）

那么应该怎么办呢？我们发现，如果 ``mul[k][a] = x``，那么就把 ``mul[k][a]`` 改成 $y$，这样就完成了。

再来看 ``pushdown``，这里有一个学线段树时的核心思想：越往下的标记一定是越早来的，好像网上没有人解释过，如果它是晚来的，那么会把上面的标记 ``pushdown`` 成最新的，和上面的就是一样早来的了。

否则一种情况，那就是先修改下面的，再修改上面的，这是比较自然的，显然下面的标记是早来的。

接着，就可以尝试写出 ``pushdown`` 了。

根据刚刚的推论，我们发现，当前的结点 $k$ 上的懒标记，一定比下面的 ``ls[k] rs[k]`` 来的都要晚，所以听它的。

其实也很简单，我们把 ``mul[k << 1][i]`` 改成 ``mul[k][mul[k << 1][i] ]`` 就行了，大家应该能理解吧。

改完之后还有个重点，把 ``mul[k][i]`` 改成 ``i``，这是标记清零。

那么就能试着写出代码了，时间复杂度 $O(n\log n)$，带一个 $26$ 的常数，有点紧但能过得去：

```cpp
#include <cstring>
#include <iostream>
using namespace std;
char s[100005];
int m, a, b;
char x, y;
int mul[400005][27];
void update (int l, int r, int k) {
	if (a <= l && b >= r) {
		for (int i = 1; i <= 26; i ++) if (mul[k][i] == x) mul[k][i] = y;
		return;
	}
	int mid = l + r >> 1;
	for (int i = 1; i <= 26; i ++) {
		mul[k << 1][i] = mul[k][mul[k << 1][i] ];
		mul[k << 1 | 1][i] = mul[k][mul[k << 1 | 1][i] ];
	}
	for (int i = 1; i <= 26; i ++) mul[k][i] = i;
	if (a <= mid) update (l, mid, k << 1);
	if (b > mid) update (mid + 1, r, k << 1 | 1);
}
void query (int l, int r, int k) {
	if (l == r) {
		cout << char (mul[k][s[l] - 96] + 96);
		return;
	}
	for (int i = 1; i <= 26; i ++) {
		mul[k << 1][i] = mul[k][mul[k << 1][i] ];
		mul[k << 1 | 1][i] = mul[k][mul[k << 1 | 1][i] ];
	}
	for (int i = 1; i <= 26; i ++) mul[k][i] = i;
	int mid = l + r >> 1;
	query (l, mid, k << 1);
	query (mid + 1, r, k << 1 | 1);
}
int main () {
	for (int i = 1; i <= 400000; i ++) for (int j = 1; j <= 26; j ++) mul[i][j] = j;
	scanf ("%s", s + 1);
	int len = strlen (s + 1);
	scanf ("%d", &m);
	for (int i = 1; i <= m; i ++) {
		scanf ("%d%d", &a, &b);
		cin >> x >> y;
		x -= 96; y -= 96;
		update (1, len, 1);
	}
	query (1, len, 1);
	return 0;
}
```


---

## 作者：Zvelig1205 (赞：6)

CF911G 的弱化版。

不能理解为什么 2022 了，蓝桥杯还在搬题。

## 暴力

一般来说，DS 的暴力都很好打，比如本题。

直接暴力扫要更改的区间。

~~然后就得到了 60pts 的好成绩。~~

```cpp
const int inf=1e5+7;
int n,m;
char s[inf];
int main()
{
	scanf("%s",s+1);
	n=strlen(s+1);m=re();
	while(m-->0)
	{
		int l=re(),r=re();
		char x[2]="",y[2]="";
		scanf("%s%s",x,y);
		for(int i=l;i<=r;i++)
			if(s[i]==x[0])s[i]=y[0];
	}
	for(int i=1;i<=n;i++)
		putchar(s[i]);
	return 0;
}
```

## 正解

对于区间问题，有两个十分常见的处理方式：

* 线段树
* 区间平衡树

由于这种奇怪的赋值操作类似于区间移动，所以我选择用 `Fhq_Treap`。

[如果你不会 Fhq_Treap。](https://www.cnblogs.com/Zvelig1205/p/16746809.html)

对每个字母建一棵 `Treap`，每次将需要移动的区间分裂出来，然后与目标树进行融合。

这里不能直接 `merge`，因为这样的两棵 `Treap` 并不满足 `merge` 的前提：保证 $x$ 树上所有节点的权值都不大于 $y$ 树。

所以只能启发式合并（即上边的“融合”）。

其实和[线段树合并](https://www.cnblogs.com/Zvelig1205/p/16666163.html)差不多：

* 当有节点不存在时，返回另一个节点。
* 否则，将小 `Treap` 按大 `Treap` 的当前节点值分裂，然后分别与大 `Treap` 的左右子树融合。

这样融合就不需要考虑两个 `Treap` 的相对大小关系了。

最后，遍历这 $26$ 棵 `Treap`，将相应的字符放到相应的位置上。

AC Code:

```cpp
const int inf=1e5+7;
char s[inf];
int n,m;
struct Fhq_Treap{
	int lc,rc;
	int siz,val;
	unsigned pri;
}T[inf<<5];
int cnt,rot[30],r1,r2,r3;
#include<random>
mt19937 rnd(51205);
int new_(int k)
{
	T[++cnt].pri=rnd();
	T[cnt].siz=1,T[cnt].val=k;
	return cnt;
}
int pushup(int i)
{
	T[i].siz=T[T[i].lc].siz+T[T[i].rc].siz+1;
	return i;
}
void split(int i,int k,int &x,int &y)
{
	if(!i){x=y=0;return;}
	if(T[i].val<=k)
		x=i,split(T[i].rc,k,T[i].rc,y);
	else y=i,split(T[i].lc,k,x,T[i].lc);
	pushup(i);
}
int merge(int x,int y)
{
	if(!x||!y)return x|y;
	if(T[x].pri<T[y].pri)
	{
		T[x].rc=merge(T[x].rc,y);
		return pushup(x);
	}
	else
	{
		T[y].lc=merge(x,T[y].lc);
		return pushup(y);
	}
}
int mix(int x,int y)
{
	if(!x||!y)return x|y;
	if(T[x].siz<T[y].siz)swap(x,y);
	int r1,r2;
	split(y,T[x].val,r1,r2);
	T[x].lc=mix(T[x].lc,r1);
	T[x].rc=mix(T[x].rc,r2);
	return x;
}
char ans_[inf];
void dfs(int now,int op)
{
	if(!now)return;
	dfs(T[now].lc,op);
	ans_[T[now].val]=op+'a';
	dfs(T[now].rc,op);
}
int main()
{
	scanf("%s",s+1);
	n=strlen(s+1),m=re();
	for(int i=1;i<=n;i++)
	{
		int ch=s[i]-'a';
		rot[ch]=merge(rot[ch],new_(i));
	}
	for(int i=1;i<=m;i++)
	{
		int l=re(),r=re();
		char xx[2]={},yy[2]={};
		scanf("%s%s",xx,yy);
		int x=xx[0]-'a',y=yy[0]-'a';
		if(x==y)continue;
		split(rot[x],l-1,r1,r2);
		split(r2,r,r2,r3);
		rot[x]=merge(r1,r3);
		rot[y]=mix(rot[y],r2);
	}
	for(int i=0;i<26;i++)
		dfs(rot[i],i);
	puts(ans_+1);
	return 0;
}
```

听说时间复杂度和线段树合并一样，不过我都不会 /kk。


---

## 作者：iiiiiyang (赞：4)

[逆天的阅读体验](https://www.cnblogs.com/LittleTwoawa/p/17170559.html)

[题目链接](https://www.luogu.com.cn/problem/P8796)

~~大家好，我非常喜欢暴力数据结构，所以我用分块过了这道题。~~

[[Ynoi2018]未来日记](https://www.luogu.com.cn/problem/P4119)的弱弱弱弱弱化板，考虑经典的分块加并查集维护颜色。

记 $id_{x,i}$ 表示第 $x$ 个块中颜色 $i$ 第一次出现的位置，$col_i$ 表示第 $i$ 个位置上的颜色，单次操作为 $x \leftarrow y$。

对于散块上的我们下放存的颜色暴力重构并查集。

对于整块上的我们分类讨论：
- 如果块里面有 $x$ 没有 $y$，直接跳过操作；
- 如果块里面有 $y$ 没有 $x$，进行 $id_{y,i} \leftarrow id_{x,i}$，$col_i \leftarrow y$；
- 如果块里面有 $x$ 有 $y$，直接并查集把 $x$ 并在 $y$ 的儿子里。

注意到一次操作整块内颜色数量最劣为不变，散块内最多增加一种新颜色，初始块内颜色数量不超过块长，因此时间复杂度为 $\mathcal O((n+m)\sqrt{n})$，其中 $m$ 是总颜色数量。

跑的比 $26$ 棵线段树快多了，一时分不清谁是暴力。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

inline int read()
{
	int s=0,w=1;
	char c=getchar();
	while(!isdigit(c)) {if(c=='-') w=-1; c=getchar();}
	while(isdigit(c)) s=(s<<1)+(s<<3)+(c^48),c=getchar();
	return s*w;
}

namespace LgxTpre
{
	static const int MAX=100010;
	static const int mod=998244353;
	static const int INF=4557430888798830399;
	
	int n,len;
	int l,r,x,y;
	char s[MAX],c1,c2;

	int fa[MAX];
	int find(int x)
	{
		if(fa[x]==x) return x;
		return fa[x]=find(fa[x]);
	}

	int blo;
	int L[MAX],R[MAX],pos[MAX];
	int id[MAX][30],col[MAX],a[MAX];
	inline void init()
	{
		scanf("%s",s+1); len=strlen(s+1);
		for(int i=1;i<=len;++i)
			a[i]=s[i]-'a'+1;
		blo=sqrt(len);
		for(int i=1;i<=blo;++i)
			L[i]=(i-1)*blo+1,R[i]=i*blo;
		if(R[blo]<len) ++blo,L[blo]=R[blo-1]+1,R[blo]=len;
		for(int i=1;i<=blo;++i)
			for(int j=L[i];j<=R[i];++j)
			{
				pos[j]=i;
				if(!id[i][a[j]]) id[i][a[j]]=j,col[id[i][a[j]]]=a[j];
				fa[j]=id[i][a[j]];
			}
		return;
	}
	inline void reset(int l,int r,int x,int y)
	{
		int now=pos[l];
		for(int i=L[now];i<=R[now];++i) a[i]=col[find(i)],id[now][a[i]]=0;
		for(int i=l;i<=r;++i) if(a[i]==x) a[i]=y;
		for(int i=L[now];i<=R[now];++i)
		{
			if(!id[now][a[i]]) id[now][a[i]]=i,col[id[now][a[i]]]=a[i];
			fa[i]=id[now][a[i]];
		}
		return;
	}
	inline void merge(int i,int x,int y)
	{
		if(!id[i][x]) return;
		if(!id[i][y]) return id[i][y]=id[i][x],id[i][x]=0,col[id[i][y]]=y,void();
		fa[id[i][x]]=id[i][y],id[i][x]=0;
		return;
	}
	inline void solve(int l,int r,int x,int y)
	{
		if(x==y) return;
		int lpos=pos[l],rpos=pos[r],con=0;
		if(lpos==rpos) 
		{
			for(int i=L[lpos];i<=R[lpos];++i)
				if(col[find(i)]==x)
					++con;
			if(con) reset(l,r,x,y);
			return;
		}
		con=0;
		for(int i=l;i<=R[lpos];++i) if(col[find(i)]==x) ++con;
		if(con) reset(l,R[lpos],x,y);
		con=0;
		for(int i=L[rpos];i<=r;++i) if(col[find(i)]==x) ++con;
		if(con) reset(L[rpos],r,x,y);
		for(int i=lpos+1;i<=rpos-1;++i) merge(i,x,y);
		return;
	}
		
	inline void lmy_forever()
	{
		init();
		n=read();
		for(int i=1;i<=n;++i)
		{
			l=read(),r=read(),scanf("%c %c",&c1,&c2);
			x=c1-'a'+1,y=c2-'a'+1;
			solve(l,r,x,y);
		}
		for(int i=1;i<=len;++i)
			putchar((char)(col[find(i)]+'a'-1));
		return;
	}
}

signed main()
{
	LgxTpre::lmy_forever();
	return (0-0);
}
```

---

## 作者：xingke233 (赞：4)

## 题目大意

给定一个仅含小写英文字母的字符串 $s$，每次操作选择一个区间 $[l_i,r_i]$ 将 $s$ 的该区间中的所有字母 $x_i$ 全部替换成字母 $y_i$，问所有操作做完后，得到的字符串是什么。


输入的第一行包含一个字符串 $s$。

第二行包含一个整数 $m$。

接下来 $m$ 行，每行包含 $4$ 个参数 $l_i,r_i,x_i,y_i$，相邻两个参数之间用一个空格分隔，其中 $l_i,r_i$ 为整数，$x_i, y_i$ 为小写字母。

$1 \leq |s|, m \leq 10^5$，$1 \leq l_i \leq r_i \leq |s|$，$x_i\neq y_i$，其中 $|s|$ 表示字符串 $s$ 的长度。


## 思路

因为不会线段树分裂合并只能用普通做法。

按照题目开 $26$ 棵权值线段树。

对于修改操作，我们遍历要修改的 $x$ 线段树。

如果当前区间全为 $x$ 那么直接在 $y$ 那颗树上修改并打上覆盖标记。

```cpp
    if(ll>=l&&rr<=r&&sum(x,p)==rr-ll+1){
        sum(y,p)=sum(x,p);
        sum(x,p)=0;
        chg(y,p)=1;chg(x,p)=0;
        return ;
    }
```

输出答案时，直接遍历 $26$ 棵线段树即可。

**注意线段树的空间**。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL int
#define Ld long double
#define sum(k,p) tree[k][p].sum
#define chg(k,p) tree[k][p].chg
const int N = 100005,M=100005;

LL m,l,r,n;
char ch[N],x,y;
struct Segment_tree{
    LL sum,chg;
}tree[26][N*4];

void build(LL p,LL l,LL r){
    for(int i=0;i<26;i++)chg(i,p)=-1;
    if(l==r){
        sum(ch[l]-'a',p)=1;
        return ;
    }
    LL mid=(l+r)>>1;
    build(p<<1,l,mid);
    build(p<<1|1,mid+1,r);
    for(int i=0;i<26;i++) sum(i,p)=sum(i,p<<1)+sum(i,p<<1|1);
    return ;
}

void pushdown(LL p,LL k,LL l,LL r,LL mid){
    if(chg(k,p)==-1) return ;
    sum(k,p<<1)=(mid-l+1)*chg(k,p);
    sum(k,p<<1|1)=(r-mid)*chg(k,p);
    chg(k,p<<1)=chg(k,p<<1|1)=chg(k,p);
    chg(k,p)=-1;
    return ;
}

void pushup(LL p,LL k){
    sum(k,p)=sum(k,p<<1)+sum(k,p<<1|1);
    return ;
}

void change(LL p,LL l,LL r,LL x,LL y,LL ll,LL rr){
    if(!sum(x,p)) return ;
    if(ll>=l&&rr<=r&&sum(x,p)==rr-ll+1){
        sum(y,p)=sum(x,p);
        sum(x,p)=0;
        chg(y,p)=1;chg(x,p)=0;
        return ;
    }
    LL mid=(ll+rr)>>1;
    pushdown(p,x,ll,rr,mid);
    pushdown(p,y,ll,rr,mid);
    if(l<=mid) change(p<<1,l,r,x,y,ll,mid);
    if(r>mid) change(p<<1|1,l,r,x,y,mid+1,rr);
    pushup(p,x);
    pushup(p,y);
    return ;
}

void out(LL p,LL l,LL r){
    if(l==r){
        for(int i=0;i<26;i++){
            if(sum(i,p)!=0){
                cout<<(char)(i+97);
                break;
            }
        }
        return ;
    }
    LL mid=(l+r)>>1;
    for(int i=0;i<26;i++) pushdown(p,i,l,r,mid);
    out(p<<1,l,mid);
    out(p<<1|1,mid+1,r);
    return ;
}

signed main(){
    cin>>ch+1;
    LL len=strlen(ch+1);
    build(1,1,len);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>l>>r>>x>>y;
        change(1,l,r,x-'a',y-'a',1,len);
    }
    out(1,1,len);
    return 0;
}
```


---

## 作者：Forg1weN (赞：2)

## 题意

给定一个仅含小写英文字母的字符串 $s$，每次操作选择一个区间 $[l_i,r_i]$ 将 $s$ 的该区间中的所有字母 $x_i$ 全部替换成字母 $y_i$，问所有操作做完后，得到的字符串是什么。

$1 \leq |s|, m \leq 10^5$，$1 \leq l_i \leq r_i \leq |s|$，$x_i\neq y_i$，其中 $|s|$ 表示字符串 $s$ 的长度。

## 思路

一个朴素的想法，将 $26$ 个字母每个字母开一棵树，然后出现了转化操作便将原树区间内存在的值，复制到目标树上。

考虑如何维护，将每一棵树的值提出来显然不行，于是考虑直接线段树合并上去，将一棵子树剥离，再拼接到另外一棵树的子树上，这是可行的。

剥离线段树后，相当于原来的父节点没有了这个子节点，直接赋 $0$ 即可。

那么，对于一个区间内指定的字母是否存在，按照板子应该是判断其是否为 $1$ ，还涉及一些子树大小上传操作，有点麻烦。这道题直接利用线段树合并动态开点的性质，判断节点是否存在会更加方便。

时间复杂度 $O((n+q)\log n)$，空间复杂度 $O(n\log n)$。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define mid (l+r)/2
const int maxn=1e7+10;
const int N=2e5+10;
int n,q,tot;
int root[120];
char s[N];
int lc[maxn],rc[maxn],ans[N];

void build(int &rt,int l,int r,int x) {
	if(!rt)rt=++tot;
	if(l==r)return;
	if(x<=mid)build(lc[rt],l,mid,x);
	else build(rc[rt],mid+1,r,x);
}
int merge(int u,int v) {
	if(!u||!v)return u|v;
	lc[u]=merge(lc[u],lc[v]);
	rc[u]=merge(rc[u],rc[v]);
	return u;
}
void update(int &now,int &pre,int l,int r,int x,int y) {
	if(!pre)return;
	if(x<=l&&r<=y) {
		now=merge(now,pre);
		pre=0;
		return;
	}
	if(!now)now=++tot;
	if(x<=mid)update(lc[now],lc[pre],l,mid,x,y);
	if(mid<y)update(rc[now],rc[pre],mid+1,r,x,y);
}
void query(int rt,int l,int r,int v) {
	if(!rt)return;
	if(l==r) {
		ans[l]=v;
		return;
	}
	query(lc[rt],l,mid,v);
	query(rc[rt],mid+1,r,v);
}
int main() {
	scanf("%s",s+1);
	n=strlen(s+1);
	for(int i=1,x;i<=n;i++) {
		x=s[i]-'a'+1;
		build(root[x],1,n,i);
	}	
	scanf("%d",&q);
	while(q--) {
		int l,r,x,y;
		scanf("%d%d%s",&l,&r,s);
		x=s[0]-'a'+1;
		scanf("%s",s);
		y=s[0]-'a'+1; 
		if(x==y)continue;
		update(root[y],root[x],1,n,l,r);
	}
	for(int i=1;i<=26;i++)
		query(root[i],1,n,i);
	for(int i=1;i<=n;i++)
		printf("%c",(char)(ans[i]+'a'-1)); 
	return 0;
} 
```





---

## 作者：small_john (赞：2)

## 前言

平衡树？线段树合并？不就一颗线段树解决吗？甚至还有一道[紫的双倍经验](/problem/CF911G)。

## 思路

看到这个字符串只有小写字母，那就对每一种字符开一个懒标记数组。在一个线段树的节点中，用 $tag_i$ 表示初始第 $i$ 个字母在这个区间内应该是什么。

很明显，开始的时候 $tag_i=i$，很容易写出建树代码：

```cpp
void build(int &k,int l,int r)
{
	if(!k) k = ++cnt;
	for(int i = 0;i<26;i++) t[k].tag[i] = i;
	if(l==r) return t[k].val = s[l]-'a',void();
	int mid = (l+r)/2;
	build(ls,l,mid),build(rs,mid+1,r);
}
```

接下来考虑懒标记下传，可以发现如果当前节点的左儿子的 $tag_{ls,i}=j$，那么在下传后 $tag_{ls,i}=tag_{k,tag_{ls,i}}$，右儿子同理。容易写出代码：

```cpp
void down(int k)
{
	for(int i = 0;i<26;i++)
		t[ls].tag[i] = t[k].tag[t[ls].tag[i]];
	for(int i = 0;i<26;i++)
		t[rs].tag[i] = t[k].tag[t[rs].tag[i]];
	for(int i = 0;i<26;i++)//最后一定要赋值成初始值，以便后面的标记下传
		t[k].tag[i] = i;
}
```

最后用线段树维护即可。

## 代码

```cpp
#include <bits/stdc++.h>
#define ls t[k].lson
#define rs t[k].rson
using namespace std;
const int N = 1e5+5;
struct node{
	int lson,rson,val,tag[26];
}t[N<<1];
int cnt,m,n;
string s;
void build(int &k,int l,int r)
{
	if(!k) k = ++cnt;
	for(int i = 0;i<26;i++) t[k].tag[i] = i;
	if(l==r) return t[k].val = s[l]-'a',void();
	int mid = (l+r)/2;
	build(ls,l,mid),build(rs,mid+1,r);
}
void down(int k)
{
	for(int i = 0;i<26;i++)
		t[ls].tag[i] = t[k].tag[t[ls].tag[i]];
	for(int i = 0;i<26;i++)
		t[rs].tag[i] = t[k].tag[t[rs].tag[i]];
	for(int i = 0;i<26;i++)//最后一定要赋值成初始值，以便后面的标记下传
		t[k].tag[i] = i;
}
void change(int k,int l,int r,int x,int y,int pre,int to)
{
	if(x<=l&&r<=y)
	{
		for(int i = 0;i<26;i++)
			if(t[k].tag[i]==pre)
				t[k].tag[i] = to;
		return;
	}
	down(k);
	int mid = (l+r)/2;
	if(x<=mid) change(ls,l,mid,x,y,pre,to);
	if(mid<y) change(rs,mid+1,r,x,y,pre,to);
}
void print(int k,int l,int r)
{
	if(l==r) return cout<<(char)(t[k].tag[t[k].val]+'a'),void();
	int mid = (l+r)/2;
	down(k);
	print(ls,l,mid),print(rs,mid+1,r);
}
int rt;
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>s>>m;
	n = s.size(),s = ' '+s;
	build(rt,1,n);
	while(m--)
	{
		int l,r;char x,y;
		cin>>l>>r>>x>>y;
		change(rt,1,n,l,r,x-'a',y-'a');
	}
	print(rt,1,n);
	return 0;
}
```

---

## 作者：AbsMatt (赞：2)

## [题目传送器](https://www.luogu.com.cn/problem/P8796)

# 题意
给定一个只有字符串 $s$ 和 一个数 $m$，每次操作将区间 $[l,r]$ 的所有 $x$ 都变成 $y$，求经过 $m$ 次操作后的字符串。

# 思路
本题使用的是**线段树**，因为本题有很明显的**区间修改操作**和**区间查询**，只要开 $26$ 个线段树来分别维护 a $\sim$ z 的个数，时间复杂度就是 $O(26 \times len \times \log_{2}len)$。
接下来我将 ~~详细~~ 介绍一下区间修改操作。

### 区间修改
如果将区间修改变成将区间内的每个点，那一次修改时间复杂度将是 $O(26 \times len \times \log_{2}n)$，共修改 $n$ 次后，时间复杂度就是 $O(26 \times len^2 \times \log_{2}len)$。

我们可以在遍历到一个全都要修改的区间时，给这个区间打上一个懒标记 tag ，然后就不再继续向下修改，而是直接回溯。在以后遍历到时，再将这个懒标记 tag 传递下去，一次时间复杂度就是 $O(\log_{2}len)$。
```cpp
inline void push_up(ll p,ll type)
{
    tr[type][p]=tr[type][p<<1]+tr[type][p<<1|1];
}
inline void push_up(ll p){
    for(int i=0;i<26;i++)   push_up(p,i);
}
inline void push_down(int p,int l,int r,int type)
{
    if(~tag[type][p]){
        int mid=(l+r)>>1;
        f1(p<<1,l,mid,tag[type][p],type);
        f1(p<<1|1,mid+1,r,tag[type][p],type);
        tag[type][p]=-1;
    }
}
inline void push_down(int p,int l,int r){
    for(int i=0;i<26;i++)   push_down(p,l,r,i);
}
void change(int p,int l,int r,int pl,int pr,int old,int now){
    if(tr[old][p]==0)    return;
    if(pl<=l&&pr>=r&&tr[old][p]==(r-l+1)){
        tr[now][p]=tr[old][p];
        tag[now][p]=1;
        tr[old][p]=tag[old][p]=0;
        return;
    }
    push_down(p,l,r);
    ll mid=(l+r)>>1;
    if(pl<=mid) change(p<<1,l,mid,pl,pr,old,now);
    if(pr>mid)  change(p<<1|1,mid+1,r,pl,pr,old,now);
    push_up(p);
}
```

在上面的代码基础上，再加上区间修改就可以了。

时间复杂度：

线段树区间查询：$O(\log_{2}len)$，执行 $n$ 次。

线段树区间修改：$O(\log_{2}len)$，执行 $n$ 次。

线段树建树：$O(len)$，执行 $1$ 次。

共计：$O(n \times \log_{2}len)$。

## AC Code
```cpp
#include<bits/stdc++.h>  // 开始
#define ll int
using namespace std;
const int maxn=1e5+10;
string s1;
int n,tr[27][maxn*4],tag[27][maxn*4],sum[27];
bool tag1[27][maxn*4];
inline void push_up(ll p,ll type)
{
    tr[type][p]=tr[type][p<<1]+tr[type][p<<1|1];
}
inline void push_up(ll p){
    for(int i=0;i<26;i++)   push_up(p,i);
}
inline void f1(ll p,ll l,ll r,ll k,ll type)
{
    tag[type][p]=k;
    tr[type][p]=k*(r-l+1);
}
inline void push_down(int p,int l,int r,int type)  // 下传 tag
{
    if(~tag[type][p]){
        int mid=(l+r)>>1;
        f1(p<<1,l,mid,tag[type][p],type);
        f1(p<<1|1,mid+1,r,tag[type][p],type);
        tag[type][p]=-1;
    }
}
inline void push_down(int p,int l,int r){
    for(int i=0;i<26;i++)   push_down(p,l,r,i);
}
// int query(int p,int l,int r,int pl,int pr,int type){
//     if(pl<=l&&pr>=r){
//         return tr[type][p];
//     }
//     int mid=(l+r)>>1,res=0;
//     if(pl<=mid) res=query(p<<1,l,mid,pl,pr,type);
//     if(pr>mid) res+=query(p<<1|1,mid+1,r,pl,pr,type);
//     return res;
// }
void change(int p,int l,int r,int pl,int pr,int old,int now){  // 区间修改
    if(tr[old][p]==0)    return;
    if(pl<=l&&pr>=r&&tr[old][p]==(r-l+1)){
        tr[now][p]=tr[old][p];
        tag[now][p]=1;
        tr[old][p]=tag[old][p]=0;
        return;
    }
    push_down(p,l,r);
    ll mid=(l+r)>>1;
    if(pl<=mid) change(p<<1,l,mid,pl,pr,old,now);
    if(pr>mid)  change(p<<1|1,mid+1,r,pl,pr,old,now);
    push_up(p);
}
void build(int p,int l,int r){  // 建图
    for(int i=0;i<26;i++)   tag[i][p]=-1;
    if(l==r){
        for(int i=0;i<26;i++){
            if(s1[l-1]==i+'a')  tr[i][p]=1;
        }
        return;
    }
    int mid=(l+r)>>1;
    build(p<<1,l,mid);
    build(p<<1|1,mid+1,r);
    for(int i=0;i<26;i++){
        tr[i][p]=tr[i][p<<1]+tr[i][p<<1|1];
    }
}
void out(int p,int l,int r){  // 输出（区间修改）
    // printf("%d %d\n",l,r);
    if(l==r){
        for(int i=0;i<26;i++){
            if(tr[i][p]){
                cout<<char(i+'a');
                break;
            }
        }
        // printf("!");
        return;
    }
    push_down(p,l,r);
    int mid=(l+r)>>1;
    out(p<<1,l,mid);
    out(p<<1|1,mid+1,r);
}
int main(){
    cin>>s1;
    int len=s1.length();
    scanf("%d",&n);
    build(1,1,len);  // 建图
    for(int i=1;i<=n;i++){
        int a,b;
        char x,y;
        scanf("%d%d %c %c",&a,&b,&x,&y);
        change(1,1,len,a,b,x-'a',y-'a');  // 区间修改
    }
    out(1,1,len);  // 区间查询
}
```

---

## 作者：This_Rrhar (赞：1)

记 $n=|s|$。

$n,m\le10^5$，且值域大小只有 $26$，明示分块。

考虑分块，块长取 $\sqrt n$，在每个块中维护一个值域上的并查集，使得 $s_i=s_{f_i}$。

用 $rt_{i,j}$ 表示第 $i$ 个块中第一个为 $j$ 的值的下标。首先思考整块如何操作：

- 如果 $rt_{i,y}=0$，表示这个块内没有值为 $y$ 的数，此时 $rt_{i,x}$ 会成为 $rt_{i,y}$，并且为了让 $rt_{i,x}$ 的儿子能够找到 $y$ 这个值，需要执行 $s_{rt_{i,x}}\gets y$。

- 否则直接把 $rt_{i,x}$ 作为 $rt_{i,y}$ 的儿子。

这样一个整块操作的时间复杂度是 $O(1)$ 的。

再来思考散块如何操作。注意到只有 $rt_{i,x}$ 和 $rt_{i,y}$ 及其子树会被更改，因此我们只需直接对 $s$ 进行修改，然后重构这两个子树即可。这样一个散块操作的时间是 $O(\sqrt n)$ 的。

因为整块修改至多有 $O(\sqrt n)$ 个，散块修改至多有 $2$ 个，所以 $m$ 个操作的时间复杂度是 $O(m\sqrt n)$ 的，空间复杂度是 $O(n)$。

代码如下，拿 [CF911G](https://www.luogu.com.cn/problem/CF911G) 的代码改的。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define _r return*this
#define _o &operator
namespace IO
{
	const int _S=1<<21;
	char b[_S],*p1=b,*p2=b,pb[_S],*pp=pb;
	void fl(){fwrite(pb,1,pp-pb,stdout),pp=pb;}
	struct input
	{
		char gc(){if(p1==p2)p2=(p1=b)+fread(b,1,_S,stdin);return p1==p2?' ':*p1++;}
		input _o>>(char&num){do num=gc();while(num==' '||num=='\n'||num=='\r'||num=='\t');_r;}
		template<typename T>input _o>>(T&x)
		{
			char c=gc();T f=1;
			for(x=0;!isdigit(c);)(c=='-'?f=-1:1),c=gc();
			while(isdigit(c))x=(x*10)+(c^48),c=gc();
			x*=f;_r;
		}
		input(){}
	}in;
	struct output
	{
		void pt(char num){*pp++=num;if(pp-pb==_S)fl();}
		output _o<<(char num){pt(num);_r;}
		template<typename T>output _o<<(T x)
		{
			if(!x){pt(48);_r;}
			if(x<0)pt('-'),x=-x;
			int s[64],t=0;
			while(x)s[++t]=x%10,x/=10;
			while(t)pt(s[t--]+48);
			_r;
		}
		output _o<<(const char*s){int num=0;while(s[num])pt(s[num++]);_r;}
		output(){}
	}out;
	struct fe{~fe(){fl();}}fls;
}
using IO::in;
using IO::out;
using ll=long long;

#define N 100050
#define M 30
#define LEN 318

ll n,m;

char a[N];

ll f[N],rt[LEN+1][M];
ll F(ll i){return i^f[i]?f[i]=F(f[i]):i;}
void merge(ll b,char x,char y)
{
	if(rt[b][y])f[rt[b][x]]=rt[b][y];
	else a[rt[b][y]=rt[b][x]]=y;
	rt[b][x]=0;
}

ll B,dis[N],L[LEN+1],R[LEN+1];
void blockial()
{
	B=n/LEN+!!(n%LEN);
	for(int i=1;i<=B;i++)
	{
		L[i]=R[i-1]+1,R[i]=min(R[i-1]+LEN,n);
		for(int j=L[i];j<=R[i];dis[j++]=i)
		{
			if(!rt[i][a[j]])f[j]=rt[i][a[j]]=j;
			else f[j]=rt[i][a[j]];
		}
	}
}

ll s[LEN+1],top;
void modify_point(ll b,ll l,ll r,char x,char y)
{
	rt[b][x]=rt[b][y]=top=0;
	for(int i=L[b];i<=R[b];i++)
	{
		a[i]=a[F(i)];
		if(a[i]==x||a[i]==y)s[++top]=i;
	}
	for(int i=l;i<=r;i++)if(a[i]==x)a[i]=y;
	for(int i=1;i<=top;i++)f[s[i]]=s[i];
	for(int i=1;i<=top;i++)
		if(!rt[b][a[s[i]]])rt[b][a[s[i]]]=s[i];
		else f[s[i]]=rt[b][a[s[i]]];
}
void modify(ll l,ll r,char x,char y)
{
	if(x==y)return;
	ll bl=dis[l],br=dis[r];
	if(bl==br)modify_point(bl,l,r,x,y);
	else
	{
		modify_point(bl,l,R[bl],x,y),modify_point(br,L[br],r,x,y);
		for(int i=bl+1;i<br;i++)if(rt[i][x])merge(i,x,y);
	}
}

ll l,r;
char x,y;
string st;

int main()
{
	ios::sync_with_stdio(false);
	cin>>st,n=st.size();
	for(int i=1;i<=n;i++)a[i]=st[i-1],f[i]=i;
	cin>>m,blockial();
	while(m--)cin>>l>>r>>x>>y,modify(l,r,x,y);
	for(int i=1;i<=n;i++)cout<<(a[i]=a[F(i)]);
}
```

---

## 作者：xiezheyuan (赞：1)

[也许有更好的阅读体验](https://www.cnblogs.com/zheyuanxie/p/p8796.html)

## 题面

给定一个仅含小写英文字母的字符串 $s$ 和 $m$ 次操作，每次操作选择一个区间 $[l_i,r_i]$ 将 $s$ 的该区间中的所有字母 $x_i$ 全部替换成字母 $y_i$，问所有操作做完后，得到的字符串是什么。

对于所有评测用例，$1 \leq |s|, m \leq 10^5$，$1 \leq l_i \leq r_i \leq |s|$，$x_i\neq y_i$，其中 $|s|$ 表示字符串 $s$ 的长度。

## 思路

首先我写了一个蹩脚的 FHQ-Treap，后来被我证伪了……

其实这道题是一个线段树合并 / 分裂 水题。

首先先按照 $s$ 的值域建出 $26$ 棵线段树。对于每一个 $s_i$，用第 $s_i$ 个线段树将第 $i$ 个元素修改为 $1$（也就是，存在）。

然后修改的时候直接将 $[l_i,r_i]$ 从第 $x_i$ 个线段树上分裂下来，合并到第 $y_i$ 个线段树上，也就可以了。

最后输出的时候暴力枚举值域，找到存在的输出即可。

时间复杂度 $O(m\log|s_i|)$。

另外本题有双倍经验 [Codeforces911G Mass Change Queries](https://codeforces.com/contest/911/problem/G)，代码就不放了，具体看 [Codeforces 提交记录](https://codeforces.com/contest/911/submission/179191072)。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define ls(i) (t[i].ls)
#define rs(i) (t[i].rs)
#define mid ((l+r)>>1)
using namespace std;

const int N = 1e5+5;
struct node{
	int ls,rs,v;
} t[N<<8];
int root[30],tot;

inline void newnode(int &i){
	if(!i)i=(++tot);
}

void update(int p,int v,int &i,int l,int r){
	newnode(i);
	if(l==r){
		t[i].v=v;
		return;
	}
	if(p<=mid){
		update(p,v,ls(i),l,mid);
	}
	else{
		update(p,v,rs(i),mid+1,r);
	}
}

int split(int ql,int qr,int &i,int l,int r){
	int p=0;
	newnode(p);
	if(ql<=l&&r<=qr){
		t[p]=t[i];
		i=0;
	}
	else{
		if(ql<=mid){
			ls(p)=split(ql,qr,ls(i),l,mid);
		}
		if(qr>mid){
			rs(p)=split(ql,qr,rs(i),mid+1,r);
		}
	}
	return p;
}

void merge(int &x,int &y){
	if(x==0||y==0){
		if(y)x=y;
		if(x)y=x;
		return;
	}
	t[x].v+=t[y].v;
	merge(ls(x),ls(y));
	merge(rs(x),rs(y));
}

int query(int p,int i,int l,int r){
	if(!i)return 0;
	if(l==r){
		return t[i].v;
	}
	if(p<=mid){
		return query(p,ls(i),l,mid);
	}
	else{
		return query(p,rs(i),mid+1,r);
	}
}

char s[N];
int n,m;

signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>(s+1);
	n=strlen(s+1);
	for(int i=1;i<=n;i++){
		update(i,1,root[s[i]-'a'],1,n);
	}
	cin>>m;
	while(m--){
		int li,ri,x,y;char xi,yi;
		cin>>li>>ri>>xi>>yi;
		x=xi-'a',y=yi-'a';
		int ytxy_ak_ioi = split(li,ri,root[x],1,n);
		merge(root[y],ytxy_ak_ioi);
	}
	for(int i=1;i<=n;i++){
		for(char j='a';j<='z';j++){
			if(query(i,root[j-'a'],1,n)>0){
				cout<<j;
				break;
			}
		}
	}
	return 0;
	return 0;
}
```

[AC Record](https://www.luogu.com.cn/record/92801951)


---

## 作者：Genshineer (赞：0)

# P8796 [蓝桥杯 2022 国 AC] 替换字符

考虑一个经典问题：

每次给定区间 $[l,r]$ 和 $x,y$，要求把区间内的所有 $x$ 改为 $y$。

先考虑没有给定 $l,r$ 即每次作用于整个序列怎么做。

不难想到，可以对着值域开一个链表，每次区间修改相当于把接在 $x$ 后的所有元素全部接在 $y$ 后面。时间复杂度 $O(1)$，非常理想。所以对于**整个块**的修改是好做的。

既然对整个块是好做的，那么就很容易想到分块了。

每个块内分别存储 $\Sigma$ 个链表，每个链表存当前字符对应哪些位置，整块的修改就解决了。对于散块修改显然可以直接暴力扫过要修改的字符 $x$ 对应的链表查询是否存在当前位置，如果存在对于对应位置直接修改就可以了。查找最坏为 $O(\sqrt{n})$，修改为 $O(1)$，可以通过本题。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e5 + 5, sqrm = 1e3;
int tot, t, n, m, pos[maxn];
struct lnk {
	int nxt, id;
} e[maxn << 1];
string s, ans;

struct data {
	int hd[30], l, r;

	inline void insert(int id, char c) {
		int u = c - 'a';
		e[++tot].nxt = this->hd[u];
		e[tot].id = id;
		this->hd[u] = tot;
	}

	inline void re(char a, char b) {
		int u = a - 'a', v = b - 'a';
		if (!this->hd[u])
			return;
		int i = this->hd[u];
		while (e[i].nxt)
			i = e[i].nxt;
		e[i].nxt = this->hd[v];
		this->hd[v] = this->hd[u];
		this->hd[u] = 0;
	}

	inline void change(int id, char x, char y) {
		int i = this->hd[x - 'a'], j = this->hd[x - 'a'];
		while (e[i].id != id and e[i].nxt)
			i = e[i].nxt;
		while (e[e[j].nxt].id != id and e[j].nxt)
			j = e[j].nxt;
		if (i == this->hd[x - 'a']) {
			this->hd[x - 'a'] = e[i].nxt;
			e[i].nxt = this->hd[y - 'a'];
			this->hd[y - 'a'] = i;
			return;
		}
		e[j].nxt = e[i].nxt;
		e[i].nxt = this->hd[y - 'a'];
		this->hd[y - 'a'] = i;
	}

	inline bool check(int id, char c) {
		int u = c - 'a';
		for (int p = this->hd[u]; p; p = e[p].nxt)
			if (e[p].id == id)
				return 1;
		return 0;
	}
} b[sqrm];

inline void build() {
	t = sqrt(n);
	for (int i = 1; i <= t; i++) {
		b[i].l = b[i - 1].r + 1;
		b[i].r = b[i].l + t - 1;
	}
	b[t].r = n;
	for (int i = 1; i <= t; i++) {
		for (int j = b[i].l; j <= b[i].r; j++) {
			pos[j] = i;
			b[i].insert(j, s[j]);
		}
	}
}

inline void modify(int l, int r, char x, char y) {
	int p = pos[l], q = pos[r];
	if (p == q) {
		for (int i = l; i <= r; i++)
			if (b[p].check(i, x))
				b[p].change(i, x, y);
	}
	else {
		for (int i = l; i <= b[p].r; i++)
			if (b[p].check(i, x))
				b[p].change(i, x, y);
		for (int i = p + 1; i < q; i++)
			b[i].re(x, y);
		for (int i = b[q].l; i <= r; i++)
			if (b[q].check(i, x))
				b[q].change(i, x, y);
	}
}

inline void getans() {
	for (int i = 1; i <= n; i++)
		ans += " ";
	for (int i = 1; i <= t; i++)
		for (int j = 0; j < 26; j++)
			for (int p = b[i].hd[j]; p; p = e[p].nxt)
				ans[e[p].id - 1] = j + 'a';
} 

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	
	string tmp;
	cin >> tmp;
	s = " ";
	for (int i = 1; i <= (int)tmp.size(); i++)
		s += tmp[i - 1];
	n = s.size() - 1;
	cin >> m;
	build();
	for (int i = 1; i <= m; i++) {
		int l, r;
		char x, y;
		cin >> l >> r >> x >> y;
		modify(l, r, x, y);
	}
	
	getans();
	
	cout << ans;
}
```



---

## 作者：黑影洞人 (赞：0)

题意:
>给你一个字符串，要求将一个区间内的指定字符替换成另一个字符，一次询问，输出修改 $n$ 次后的序列。

这道题有两种方法:
- 第一种就是在每个字符上都开一个动态开点权值线段树记录位置

- 第二种就是把 $26$ 个字母的位置都打成标记，在这里我选择第二种较简便的写法。

首先对于每个线段树的节点，搞一个字符数组 `tag[26]` , `tag[i]` 表示字母 `i+'a'` 应该改为字母 `tag[i]+'a'`，对于每次修改，执行 $26$ 次判断覆盖，总体时间复杂度是 $O(nC \log n),C=26$。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<iostream>
#define lc p<<1
#define rc p<<1|1
#define N 114514
using namespace std;
int n,m;
char ss[N];
struct Segment_tree{
	int l,r;
	char tag[26],val;
	void csh(){for(int i=0;i<26;i++)tag[i]=i;}
}s[N<<2];
void build(int p,int l,int r){
	s[p].l=l,s[p].r=r;
	s[p].csh();
	if(l==r)return void(s[p].val=ss[l]);
	build(lc,l,(l+r)/2);
	build(rc,(l+r)/2+1,r);
}
void pushdown(int p){
	for(int i=0;i<26;i++){
		s[lc].tag[i]=s[p].tag[s[lc].tag[i]];
		s[rc].tag[i]=s[p].tag[s[rc].tag[i]];
	}
	s[p].csh();
}
void change(int p,int l,int r,char a,char b){
	if(s[p].l>r||s[p].r<l)return;
	if(s[p].l>=l&&s[p].r<=r){
		for(int i=0;i<26;i++)if(s[p].tag[i]==a-'a')s[p].tag[i]=b-'a';
		return;
	}
	pushdown(p);
	change(lc,l,r,a,b);
	change(rc,l,r,a,b);
}
void print(int p){
	if(!s[p].l||!s[p].r)return;
	if(s[p].l==s[p].r)return void(putchar(s[p].tag[s[p].val-'a']+'a'));
	pushdown(p);
	print(lc);
	print(rc);
}
signed main(){
	scanf("%s",ss+1);
	n=strlen(ss+1);
	scanf("%d",&m);
	build(1,1,n);
	while(m--){
		int l,r;
		char a,b;
		cin>>l>>r>>a>>b;
		change(1,l,r,a,b);
	}
	print(1);
	return 0;
}



```


---

## 作者：_AyachiNene (赞：0)

# 思路：
分块做法。首先，定义 $tag_{i,j}$ 为第 $i$ 块内第 $j$ 种颜色会换成什么颜色。如果直接修改，那么颜色的关系会是一条链的关系，比如颜色 A 变为 颜色 B，颜色 B 变为颜色 C，相当于 A 变为了 C。那么就很难维护了。所以考虑每次修改前下传标记，代码很好实现。
```cpp
void update(int b)
{
	for(int i=bl[b];i<=br[b];i++)
		a[i]=tag[b][a[i]];
	for(int i=1;i<=26;i++)
		tag[b][i]=i;
}
```
之后就很好做了。对于整块来说直接修改就行了，对于散块来说，就要考虑时效的问题，每次修改散块时先下传一下标记就行了。
# Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int f=1,res=0;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){res=(res<<1)+(res<<3)+(c^48);c=getchar();}
	return res*f;
}
void write(int x)
{
    if(x<0){putchar('-');x=-x;}
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
string s;
int n,q;
int a[114514<<1];
int tag[450][114];
int siz,bl[1145],br[1145],belong[114514<<1],bnum;
void bld()
{
	siz=sqrt(n);
	bnum=ceil(1.0*n/siz);
	for(int i=1;i<=bnum;i++)
	{
		bl[i]=(i-1)*siz+1;
		br[i]=i*siz;
		for(int j=bl[i];j<=br[i];j++)
			belong[j]=i;
	}
	br[bnum]=n;
	for(int i=1;i<=bnum;i++)
		for(int j=1;j<=26;j++)
			tag[i][j]=j;
}
void update(int b)
{
	for(int i=bl[b];i<=br[b];i++)
		a[i]=tag[b][a[i]];
	for(int i=1;i<=26;i++)
		tag[b][i]=i;
}
void add(int l,int r,int x,int y)
{
	if(belong[l]==belong[r])
	{
		update(belong[l]);
		for(int i=l;i<=r;i++)
			if(a[i]==x)
				a[i]=y;
		return;
	}
	update(belong[l]);
	update(belong[r]);
	for(int i=l;i<=br[belong[l]];i++)
		if(a[i]==x)
			a[i]=y;
	for(int i=bl[belong[r]];i<=r;i++)
		if(a[i]==x)
			a[i]=y;
	for(int i=belong[l]+1;i<=belong[r]-1;i++)
		for(int j=1;j<=26;j++)
		{
			if(tag[i][j]==x)
				tag[i][j]=y;
		}
}
int main()
{
	cin>>s;
	n=s.size();
	s=' '+s;
	for(int i=1;i<=n;i++)
		a[i]=s[i]-'a'+1;
	q=read();
	bld();
	while(q--)
	{
		int l=read(),r=read();
		char x,y;
		cin>>x>>y;
		add(l,r,x-'a'+1,y-'a'+1);
	}
	for(int i=1;i<=bnum;i++)
		update(i);
	for(int i=1;i<=n;i++)
		cout<<char(a[i]+'a'-1);
}
```


---


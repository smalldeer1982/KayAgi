# [传智杯 #4 初赛] 小卡与落叶

## 题目背景

坐在飞驰的火车上，望着窗外泛黄的树叶，“又是一个冬天”，小卡心想。这是一个万物凋零的季节，一阵寒风刮过，树叶就被染黄了，再一阵寒风刮过，便是满地金黄。

百无聊赖之际，小卡发现，树叶变黄是有规律的，每一颗树，只有下面一半是黄的，上半部分都是绿的。小卡心想，该怎么统计黄色的叶子个数呢？

## 题目描述

给你一棵有 $n(1\le n\le 10^5)$ 个结点的有根树，根结点标号为 $1$，根节点的深度为 $1$，最开始整棵树的所有结点都是绿色的。

小卡有 $m(1\le m \le 10^5)$ 个操作。

操作一：把整棵树都染绿，之后让深度 $\ge x$ 的结点变黄。

操作二：询问一个结点 $x$ 的子树中有多少个黄色结点。

## 说明/提示

样例一中的树如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/5paln9hs.png)

第一次染色将 $4$ 和 $5$ 染为黄色，查询 $5,2,1$ 三个点的子树，答案分别为 $1,2,2$。

第二次染色将 $2,3,4,5$ 染为黄色，查询 $1,4,5,2$ 四个点的子树，答案分别为 $4,2,1,3$。

## 样例 #1

### 输入

```
5 9
1 2
1 3
2 4
4 5
1 3
2 5
2 2
2 1
1 2
2 1
2 4
2 5
2 2```

### 输出

```
1
2
2
4
2
1
3
```

# 题解

## 作者：whhsteven (赞：17)

询问即求 dfs 序在一段区间，深度在一段后缀的结点数量。

静态二维数点，经典的做法是主席树。不过本题中 dfs 序一维是区间，深度一维是前后缀，可以在数点时以深度为第一维，以 dfs 序为第二维。这样，将询问离线下来挂载到对应第一维前缀处，加点时按第一维有序，每次加入一个点时回答当前前缀处的询问，这只需要查询此时第二维的区间信息即可。时间复杂度 $O(n \log n)$，空间复杂度 $O(n)$。

---

## 作者：Nicrobot (赞：10)

前置知识：树链剖分（虽然不需要链操作，所以也不需要维护轻重边，只要按照 dfs 序就行，就算弱化吧 qwq）

---

注意到每个操作 $2$ 只和前面那个操作 $1$ 有关系。

因此我们可以把操作 $2$ 离线下来，按照**前面一个操作 $1$ 的染色的深度**排序。

开始时所有点为绿色。设当前为染色深度 $x$ 的操作，我们只需要：

- 继承染色深度为 $x+1$ 的树。
- 并且把每一个深度为 $x$ 的点都染上黄色。
- 对于深度为 $x$ 的询问，求其子树内的染色点个数。

当然先全部染黄再一层层取消也行的。

容易发现，将树按照 dfs 序变成序列后，第二个步骤即为单点修改，第三个即为区间求和，可以使用树状数组解决。（~~代码里我写的时候因为傻了写了个线段树~~）


特别地，对于刚刚开始还没有染色的询问，答案为 $0$，需要特判。

每个点都要一次染色，还需要进行 $m$ 次区间求和，因此复杂度为 $O((n+m) \log n)$。


[代码](https://www.luogu.com.cn/paste/z9t6qp0j)

---

## 作者：Usada_Pekora (赞：7)

为什么大家都在离线呢？来一发在线又不需要动脑的做法。

题意：给定两种操作，第一种操作是将所有深度 $\geq x$ 的点的点权设为 $1$，其它设为 $0$，第二种操作是询问 $x$ 的子树点权和。


注意到第二个操作的本质是：询问 $x$ 的子树内深度大于等于 $cx$ 的点的个数。其中 $cx$ 是上一次操作一设置的深度。

我们使用 DFS 序将其转化为一个序列上连续区间的问题，至于询问区间内大于等于某个数的值怎么做？可以选择离线树状数组，但是主席树显然更直接。

小坑点：一开始所有点权都是 $0$，所以你可以选择把 $cx$ 设为 $n+1$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5, LG = 19;
int n, m, ld[N], rd[N], idx;
int rt[N], ls[N * LG], rs[N * LG], sum[N * LG], tot;
vector<int> g[N];
inline int modify(int pre, int l, int r, int x, int k) {
	int p = ++tot;
	ls[p] = ls[pre], rs[p] = rs[pre], sum[p] = sum[pre] + k;
	if (l == r)
		return p;
	int mid = (l + r) >> 1;
	if (x <= mid)
		ls[p] = modify(ls[pre], l, mid, x, k);
	else
		rs[p] = modify(rs[pre], mid + 1, r, x, k);
	return p;
}
inline int query(int u, int v, int l, int r, int L, int R) {
	if (L <= l && r <= R)
		return sum[v] - sum[u];
	int mid = (l + r) >> 1, res = 0;
	if (L <= mid)
		res += query(ls[u], ls[v], l, mid, L, R);
	if (R > mid)
		res += query(rs[u], rs[v], mid + 1, r, L, R);
	return res;
}
inline void dfs(int u, int fr, int dep) {
	ld[u] = ++idx, rt[idx] = modify(rt[idx - 1], 1, n, dep, 1);
//	cerr << u << ' ' << dep << '\n';
	for (int v : g[u])
		if (v != fr)
			dfs(v, u, dep + 1);
	rd[u] = idx;
}
signed main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	cin >> n >> m;
	for (int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		g[u].emplace_back(v);
		g[v].emplace_back(u);
	}
	dfs(1, 0, 1);
	int curx = n + 1;
	for (int i = 1; i <= m; i++) {
		int op, x;
		cin >> op >> x;
		if (op == 1) {
			curx = x;
		} else {
			if (curx == n + 1)
				cout << "0\n";
			else 
				cout << query(rt[ld[x] - 1], rt[rd[x]], 1, n, curx, n) << '\n';
		}
	}
	return 0;
}

```

---

## 作者：Flanksy (赞：6)

### 树状数组

------------

题目给出的要求相当具体，很容易发现**每次查询的结果只与上次修改有关**。子树问题，考虑使用 dfs 序解决，这里是[模板题](https://loj.ac/p/144)。

**节点的子树在 dfs 序中必为连续的一段，且一定跟随在该节点之后。** 所以查询节点的子树等价于在 dfs 序中查询区间 $[$ 节点在 dfs 序中的下标，节点在 dfs 序中的下标 $+$ 节点的子树大小 $-1]$。

同时，由于每次询问的结果只与上次染色的深度有关，可以**将询问与其最近一次染色深度相关联，按照询问前最后一次染色操作的深度从大到小进行排序，每次查询时如果当前染色深度大于询问染色深度就对需要染色的节点进行染色**，染色即在 dfs 序中对节点进行标记。对于树状数组，单点修改每次需要染色的节点，将节点的权值从 $0$ 变成 $1$ 即可，每个节点至多会被染色一次。

由于 $n,m$ 同阶，总体时间复杂度 $O(n\log n)$。

```cpp
#include<algorithm>
#include<iostream>
#include<vector>
using namespace std;
struct Question{int i,x,dep;}q[100001];//d[x]:x在dfs序中的下标 z[x]:x的子树大小 
int n,m,a,b,cnt,las,maxd,c[100001],d[100001],z[100001],ans[100001];
vector<int> v[100001],u[100001];//u[x]:存储所有深度为x的节点在dfs序中的下标 
void dfs(int x,int f,int dep){
	d[x]=++cnt,u[dep].push_back(cnt);
	for(int i:v[x]) if(i!=f) dfs(i,x,dep+1);
	z[x]++,z[f]+=z[x],maxd=max(dep,maxd);//统计子树等价于z[x]=cnt-d[x]+1 
}
bool cmp(const Question &x,const Question &y){return x.dep>y.dep;}
void add(int x){while(x<=n) c[x]++,x+=x&-x;}
int sum(int x){int ret=0;while(x) ret+=c[x],x-=x&-x;return ret;}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n-1;i++){
		cin>>a>>b;
		v[a].push_back(b);
		v[b].push_back(a);
	}
	dfs(1,0,1),cnt=0;
	las=maxd+1;//未染色时钦定las为maxd+1 
	for(int i=1;i<=m;i++){
		cin>>a>>b;
		if(a==1) las=b;
		else q[++cnt]=Question{cnt,b,las};
	}
	sort(q+1,q+cnt+1,cmp);
	las=maxd;
	for(int i=1;i<=cnt;i++){
		while(las>=q[i].dep) for(int i:u[las--]) add(i);//标记深度为las的所有节点 
		ans[q[i].i]=sum(d[q[i].x]+z[q[i].x]-1)-sum(d[q[i].x]-1);
	}
	for(int i=1;i<=cnt;i++) cout<<ans[i]<<'\n';
	return 0;
}
```

本题困扰了笔者很久，在通过后发一篇题解纪念。

---

## 作者：hzx360 (赞：3)

前言：感谢管理员大大百忙中审核 MnZn 题解。


------------
化简题目：问一个子树内有多少个结点深度大于等于 $x$。

先把树的 dfs 序求出，一个子树的点就对应 dfs 序一段连续区间。注意到答案还与深度有关，所以考虑把结点的 dfs 序和深度变为一个二元组 $(x,y)$，$x$ 是其 dfs 序，$y$ 是其深度。

那么我们就将树上点抽象成一个二维平面上的点，问题转化为求平面内有多少二元组 $(x,y)$ 满足： $x\in [l,r]$ 且 $y\ge de_x$（其中区间 $[l,r]$ 对应子树 dfs 序所在区间，$de_x$ 是要大于等于的深度）。

这就转为了一个二维偏序的问题，可以用很多数据结构维护如：主席树，线段树，树状数组等。

我用的是类似**扫描线**加**树状数组**的做法。

具体而言就是将二元组按 $x$ 升序排序，用树状数组维护 $y$ 轴的点，然后按 $x$ 从小到大加入二元组，同时处理询问。

Tip：对扫描线不熟的可以画图模拟一波。


------------


#### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+100;
int n,m,ti,si[N],dfn[N],mx_de,ans[N];
struct node{int x,y;}a[N];
bool cmp(node A,node B){return A.x<B.x;}
struct question{int x,y,id,mul;}q[N];int cnt;
bool cmp_q(question A,question B){return A.x<B.x;}
int head[N],to[N],ne[N],tot;
void add(int x,int y){
	ne[++tot]=head[x];
	to[tot]=y;
	head[x]=tot;
}
void dfs(int u,int fa){
	dfn[u]=++ti,si[u]=1;
	a[u]=(node){ti,a[fa].y+1};
	mx_de=max(mx_de,a[u].y);
	for(int i=head[u];i;i=ne[i]){
		int v=to[i];
		if(v==fa) continue;
		dfs(v,u);
		si[u]+=si[v];
	}
}
int c[N];
int lowbit(int x){return x&(-x);}
void update(int x){for(;x<=mx_de;x+=lowbit(x))c[x]++;}
int sum(int x){int res=0;for(;x;x-=lowbit(x))res+=c[x];return res;}
int main(){
	cin>>n>>m;
	for(int i=1;i<n;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1,0);
	int pos=0,num=0;
	for(int i=1,op,x;i<=m;i++){
		cin>>op>>x;
		if(op==1) pos=x;
		else{
			if(!pos or pos>mx_de) ans[++num]=0;//这里很坑！注意这里的x可能比树上的最大深度mx_de还大！ 
			else{
				num++;
				q[++cnt]=(question){dfn[x]+si[x]-1,pos,num,1};//这个询问正贡献
				q[++cnt]=(question){dfn[x]-1,pos,num,-1};//这个负贡献
				
				//可以联想前缀和，区间和等于 Sum[r]-Sum[l-1]。Sum[r]就是正贡献，Sum[l-1]就是负贡献
			}
		}
	}
	sort(q+1,q+1+cnt,cmp_q);
	sort(a+1,a+1+n,cmp);
	int i=0,j=0;
	while(!q[j+1].x) j++;//把没用的询问pass掉
	for(int k=1;k<=n;k++){
		if(a[i+1].x==k) i++,update(a[i].y);
		while(q[j+1].x==k){
			j++;
			ans[q[j].id]+=q[j].mul*(sum(mx_de)-sum(q[j].y-1));
		}
	}
	for(int i=1;i<=num;i++) cout<<ans[i]<<endl;
}

---

## 作者：Dregen_Yor (赞：3)

个人认为是一道比较有新意的二维数点题。

# 思路

因为操作一是把整棵树都染绿，之后让深度 $\ge x$ 的结点变黄，不难发现黄色节点的个数随着 $x$ 的减小而增大。

我们考虑将所有询问离线处理，按 $x$ 的大小从大到小处理每个询问。

我们预处理出所有点的子树的大小，每个节点的 dfs 序以及每个深度对应哪些节点。

我们以 dfs 序为一维，以点的深度为一维，这样问题就转化成了一个经典的**二维数点**问题。

记录每个操作一之后，下个操作一之前的所有操作二的编号，在遍历到当前的操作一对应的深度时处理答案。

以 dfs 序建立线段树，在遍历每个深度时，将对应深度的所有点的 dfs 序对应的线段树加一（即之前没有染黄的点）。

对于每次操作二的询问，我们可以查询线段树中 $id_x$ 到 $id_x+siz_x-1$ 内节点的个数（即黄色节点的个数）。

这样处理的话，每个节点只会修改线段树一次，因为线段树的单点修改复杂度为 $\mathcal O(\log n)$，所以修改操作总的时间复杂度为 $\mathcal O(n\log n)$。

共有 $m$ 次查询，所以总的时间复杂度为 $\mathcal O((n+m)\log n)$。

# 代码

```cpp
#include<bits/stdc++.h>
#define N 100010
#define ls x<<1
#define rs x<<1|1
using namespace std;
int n,m,cnt,siz[N],tot,depm,ans[N],id[N];
vector<int> G[N],a[N],ask[N];
int q[N],sum[N<<2];
void dfs(int x,int fa,int dep){
    id[x]=++cnt;
    a[dep].push_back(cnt);
    siz[x]=1;
    depm=max(depm,dep);
    for(auto to:G[x]){
        if(to==fa){
            continue;
        }
        dfs(to,x,dep+1);
        siz[x]+=siz[to];
    }
}
void update(int x,int l,int r,int ad){
    if(l==r&&l==ad){
        sum[x]++;
        return;
    }
    int mid=(l+r)>>1;
    if(ad<=mid){
        update(ls,l,mid,ad);
    }
    else{
        update(rs,mid+1,r,ad);
    }
    sum[x]=sum[ls]+sum[rs];
}
int query(int x,int l,int r,int L,int R){
    if(l>=L&&r<=R){
        return sum[x];
    }
    int mid=(l+r)>>1,res=0;
    if(L<=mid){
        res+=query(ls,l,mid,L,R);
    }
    if(R>mid){
        res+=query(rs,mid+1,r,L,R);
    }
    return res;
}
signed main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<n;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        G[u].push_back(v);
        G[v].push_back(u);
    }
    dfs(1,1,1);
    int now=0;
    for(int i=1;i<=m;i++){
        int op;
        scanf("%d",&op);
        if(op==1){
            scanf("%d",&now);
        }
        else{
            ++tot;
            scanf("%d",&q[tot]);
            ask[now].push_back(tot);
        }
    }
    for(int i=depm;i;i--){
        for(auto j:a[i]){
            update(1,1,n,j);
        }
        for(auto j:ask[i]){
            int x=q[j];
            ans[j]=query(1,1,n,id[x],id[x]+siz[x]-1);
        }
    }
    for(int i=1;i<=tot;i++){
        printf("%d\n",ans[i]);
    }
    return 0;
}
```




---

## 作者：wcyQwQ (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P8844)

[可能更好的阅读体验](https://chenyu-w.github.io/2022/11/09/P8844%E5%B0%8F%E5%8D%A1%E4%B8%8E%E8%90%BD%E5%8F%B6/)

## 前言

提供一个不需要什么脑子，但是相对于难写的线段树合并做法。

#### 前置芝士

线段树合并。


## 分析

显然对于每个操作 $2$，对它有影响的只有上一个修改操作，所以我们可以把所有操作离线下来，对于每一个操作 $2$，记录一下它上一个操作 $1$ 的深度，然后问题就转化为了求 $u$ 子树中深度 $ \ge x$ 的点有几个。

然后就是线段树合并的经典套路，我们在每个点以深度为下标建立线段树，进行插入，再通过一次 dfs 向上并，假设我们现在计算的深度为 $x$，那么答案即为区间 $[x, n]$ 中的和。

## 代码

```c++
#include <bits/stdc++.h>
#define pii pair<int, int>

using namespace std;
const int N = 1e5 + 10, M = 1e7 + 10;
int h[N], e[N << 1], ne[N << 1], idx;
int dep[N];
struct node
{
    int lc, rc, sum;
} t[M];
int root[N], tot;
int n, m;
vector<pii> q[N];
int res[N];

inline int read()
{
    int x = 0, y = 1; char c = getchar();
    while (c < '0' || c > '9') {if (c == '-') y = -1; c = getchar();}
    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * y;
}

inline void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

inline void dfs1(int u, int p)
{
    dep[u] = dep[p] + 1;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int v = e[i];
        if (v == p) continue;
        dfs1(v, u);
    }
}

inline void pushup(int p)
{
    t[p].sum = t[t[p].lc].sum + t[t[p].rc].sum;
}

inline void insert(int &p, int l, int r, int x)
{
    if (!p) p = ++tot;
    if (l == r)
    {
        t[p].sum++;
        return;
    }
    int mid = (l + r) >> 1;
    if (x <= mid) insert(t[p].lc, l, mid, x);
    else insert(t[p].rc, mid + 1, r, x);
    pushup(p);
}

inline int merge(int &p, int &q, int l, int r)
{
    if (!p) return q;
    if (!q) return p;
    if (l == r)
    {
        t[p].sum += t[q].sum;
        return p;
    }
    int mid = (l + r) >> 1;
    t[p].lc = merge(t[p].lc, t[q].lc, l, mid);
    t[p].rc = merge(t[p].rc, t[q].rc, mid + 1, r);
    pushup(p);
    return p;
}

inline int query(int p, int l, int r, int L, int R)
{
    if (!p || l > R || r < L) return 0;
    if (L <= l && r <= R) return t[p].sum;
    int mid = (l + r) >> 1, res = 0;
    if (L <= mid) res += query(t[p].lc, l, mid, L, R);
    if (R > mid) res += query(t[p].rc, mid + 1, r, L, R);
    return res;
}

inline void dfs2(int u, int p)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        int v = e[i];
        if (v == p) continue;
        dfs2(v, u);
        merge(root[u], root[v], 1, n);
    }
    for (int i = 0; i < q[u].size(); i++)
        res[q[u][i].second] = query(root[u], 1, n, q[u][i].first, n);
}

int main()
{
    memset(h, -1, sizeof h);
    n = read(), m = read();
    for (int i = 1; i <= n - 1; i++)
    {
        int a = read(), b = read();
        add(a, b);
        add(b, a);
    }
    dfs1(1, 0);
    for (int i = 1; i <= n; i++) insert(root[i], 1, n, dep[i]);
    int last_dep = n + 1;
    int cnt = 0;
    for (int i = 1; i <= m; i++)
    {
        int op = read(), u = read();
        if (op == 1) last_dep = u;
        else q[u].push_back({last_dep, ++cnt});
    }
    dfs2(1, 0);
    for (int i = 1; i <= cnt; i++)
        printf("%d\n", res[i]);
    return 0;
}
```



---

## 作者：xiaoyang222 (赞：2)

### 前言

这里给两个完全不需要高级数据结构的做法。一个 $O(m \log n)$，一个 $O(n+m)$。

### 题解

#### 第一种做法

来自班上同学。

由于是染 $\ge x$ 的深度的所有点，所以只需要统计深度 $= x$ 的点的子树大小和就可以了。

但是这样每个点是 $O(nm)$ 的，显然不能过，菊花图即可卡爆。但是过了，且比我的 $O(n+m)$ 还跑得快。申请加强数据。

容易发现一点是：把树看成一层一层的，然后发现一个点的子树内同一高度的点都在类似一段里。然后可以通过对深搜序二分出左端点和右端点。显然可以做前缀和。

在线算法，时间复杂度 $O(m \log n)$。

代码放一个他的暴力。

```cpp
#include <bits/stdc++.h>

#define INF 0x3f3f3f3f
using namespace std;
const int N = 1e5 + 10;
int n, m, Dep;
int Size[N];
vector<int> g[N], td[N];
int ins[N], tot;
int dep[N];
void DFS(int now, int fa) {
    dep[now] = dep[fa] + 1;
    td[dep[now]].push_back(now);
    Size[now] = 1;
    ins[now] = ++tot;
    for (int to : g[now])
        if (to != fa)
            DFS(to, now), Size[now] += Size[to];
}
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i < n; ++i) {
        int x, y;
        cin >> x >> y;
        g[x].push_back(y);
        g[y].push_back(x);
    }
    DFS(1, 0);
    for (int i = 1; i <= m; ++i) {
        int op, x;
        cin >> op >> x;
        if (op == 1)
            Dep = x;
        else {
            if (Dep == 0) {
                cout << 0 << "\n";
                continue;
            }
            if (Dep <= dep[x])
                cout << Size[x] << "\n";
            else {
                int ans = 0;
                for (int j : td[Dep])
                    if (ins[j] < ins[x] + Size[x] && ins[x] <= ins[j])
                        ans += Size[j];
                cout << ans << "\n";
            }
        }
    }
    return 0;
}
```

#### 第二种做法

来自我。完全不用数据结构。

铺垫是借鉴第一种做法的开初思路，即“只统计 $= x$ 的点的子树大小和”。

把询问挂到树上，记录询问编号和 $x$。

可以想一下从根开始 dfs，当到这个点的询问，就记一下当前要求的 $x$ 这一位上的数是什么，子树所有点都遍历完后再看一下这个值，所以就得到了最终子树内的答案。

对于“这个值”，是之前遍历过的所有点中深度为当前下标的子树大小和。具体见下面代码。

离线算法，$O(n+m)$。

```cpp
#include <iostream>
#include <vector>
using namespace std;
const int N = 1e5 + 5;
vector<int> g[N];
vector<pair<int, int>> query[N];
int a1[N], b1[N];
int ans1[N], ans2[N], d[N], siz[N], sm[N], n, m;
void init(int u, int fa) {
    d[u] = d[fa] + 1;
    ++siz[u];
    for (int &v : g[u]) {
        if (v == fa)
            continue;
        init(v, u);
        siz[u] += siz[v];
    }
}
void dfs(int u, int fa) {
    for (auto &q : query[u]) {
        ans1[q.second] = sm[q.first];
    }
    sm[d[u]] += siz[u];
    for (int &v : g[u]) {
        if (v == fa)
            continue;
        dfs(v, u);
    }
    for (auto &q : query[u]) {
        if (d[u] >= q.first)
            ans2[q.second] = ans1[q.second] + siz[u];
        else
            ans2[q.second] = sm[q.first];
    }
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n >> m;
    for (int i = 1, u, v; i < n; ++i) {
        cin >> u >> v;
        g[u].emplace_back(v), g[v].emplace_back(u);
    }
    int w = n + 1, tot = 0;
    for (int i = 1, op, x; i <= m; ++i) {
        cin >> op >> x;
        if (op == 1)
            w = x;
        else
            a1[tot] = x, b1[tot] = w, query[x].emplace_back(w, ++tot);
    }
    init(1, 0);
    dfs(1, 0);
    for (int i = 1; i <= tot; ++i) {
        cout << ans2[i] - ans1[i] << "\n";
    }
    cout.flush();
    return 0;
}
```

---

## 作者：CQ_Bob (赞：2)

## 分析

乱搞题。

$1 \le n,m \le 10^5$ 的时候就可以考虑乱搞了。

发现每次操作 $1$ 都会把上一次的操作 $1$ 覆盖掉，那么第 $i$ 个询问时树的颜色情况就是由前 $1$ 个操作 $1$ 决定。也就是说这个询问的内容变成了：在 $x$ 为根的子树中，深度不小于 $x'$ 的节点数量。$x'$ 是该操作 $1$ 的 $x$。

求这玩意直接树上启发式合并。记录答案的时候用值域分块求一下和就行。复杂度 $O(m \sqrt{n})$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define re register
#define il inline
#define PII pair<int,int>
#define x first
#define y second

const int N=1e5+10;
int n,m;
int ne[N<<1],e[N<<1],h[N],idx;
int dep[N],mson[N],siz[N];
int in[N],out[N],dfsx[N],cnt;
int cnt_dep[N];
int sum[N],len;
vector<PII> Q[N];
int ans[N],qidx;

il void add(int a,int b){ne[++idx]=h[a],e[idx]=b,h[a]=idx;}
il int get(int x){return (x-1)/len+1;}
il void Add(int x){++cnt_dep[dep[x]],++sum[get(dep[x])];}
il void Del(int x){--cnt_dep[dep[x]],--sum[get(dep[x])];}
il void merge(int x,int flag){
	for(re int i=in[x];i<=out[x];++i)
		if(flag) Add(dfsx[i]);
		else Del(dfsx[i]);
	return ;
}
il int query(int x){
	int l=x,r=n,bl=get(x),br=get(n),ans=0;
	if(bl==br){
		for(re int i=l;i<=r;++i) ans+=cnt_dep[i];
		return ans;
	}
	for(re int i=l;i<=bl*len;++i) ans+=cnt_dep[i];
	for(re int bk=bl+1;bk<=br-1;++bk) ans+=sum[bk];
	for(re int i=(br-1)*len+1;i<=r;++i) ans+=cnt_dep[i];
	return ans;
}
il void dfs1(int now,int fa){
	dfsx[++cnt]=now,in[now]=cnt;
	dep[now]=dep[fa]+1,mson[now]=-1,siz[now]=1;
	int msiz=0;
	for(re int i=h[now];i;i=ne[i]){
		int j=e[i];if(j==fa) continue;
		dfs1(j,now),siz[now]+=siz[j];
		if(msiz<siz[j]) msiz=siz[j],mson[now]=j;	
	}
	out[now]=cnt;
	return ;
}
il void dfs2(int now,int fa,int flag){
	for(re int i=h[now];i;i=ne[i]){
		int j=e[i];if(j==fa||j==mson[now]) continue;
		dfs2(j,now,1);
	}
	if(mson[now]!=-1) dfs2(mson[now],now,0);
	for(re int i=h[now];i;i=ne[i]){
		int j=e[i];if(j==fa||j==mson[now]) continue;
		merge(j,1);
	}
	Add(now);
	for(re int j=0;j<Q[now].size();++j) ans[Q[now][j].x]=query(Q[now][j].y);
	if(flag) merge(now,0);
	return ;
}

il void solve(){
	cin>>n>>m;len=sqrt(n);
	for(re int i=1,a,b;i<n;++i) 
		cin>>a>>b,add(a,b),add(b,a);
	int min_y=n+1;
	for(re int i=1;i<=m;++i){
		int op,x;cin>>op>>x;
		if(op==1) min_y=x;
		else Q[x].push_back({++qidx,min_y});
	}
	dfs1(1,0),dfs2(1,0,0);
	for(re int i=1;i<=qidx;++i) cout<<ans[i]<<"\n";
}

signed main(){
	solve();
	return 0;
}
```


---

## 作者：_ANIG_ (赞：2)

看到子树统计，可以求出树的 dfs 序。这样就把子树上的统计转化成了区间的统计。

题中的操作可以转化一下。求一个子树有多少个深度不小于 $x$ 的节点。

一种朴素的方法就是开一个 $n^2$ 的数组，预处理每个节点的子树的每个深度的节点的个数。但是 $n$ 是 $10^5$ 级的，无法通过。可以使用分块优化。

$f_{i,j}$ 为 dfs 序在第 $i$ 块内，深度为 $j$ 的节点的数量。这样，对于一个子树对应的区间，完整块直接加上，零散块直接暴力求就行了。复杂度 $O((m+n)\sqrt n)$。

注意：区分真实的编号和 dfs 序，第一次修改操作前可能有查询操作。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=300,T=410;
int f[N+5][100005],idx,dfn[200005],sd[200005],n,m,bh[200005],st[N+5],ed[N+5],dep[200005],ss=100001,mk[200005],ys[100005];
vector<int>e[200005];
void dfs(int x){
	dfn[x]=++idx,mk[x]=1,ys[idx]=x;
	for(int i=0;i<e[x].size();i++)if(mk[e[x][i]]==0)dep[e[x][i]]=dep[x]+1,dfs(e[x][i]);
	sd[x]=idx;
}
int solve(int l,int r){
	int res=0;
	for(int i=l;i<=r;i++)res+=dep[ys[i]]>=ss;
	return res;
}
int Solve(int l,int r){
	int ll=bh[l]+1,rr=bh[r]-1,res=0;
	if(bh[l]==bh[r])return solve(l,r);
	for(int i=ll;i<=rr;i++)res+=f[i][ss];
	res+=solve(l,st[ll]-1)+solve(ed[rr]+1,r);
	return res;
}
int main(){
	cin>>n>>m;
	dep[1]=1;
	for(int i=1;i<n;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		e[x].push_back(y);
		e[y].push_back(x);
	}
	dfs(1);
	for(int i=1;i<=100000;i++)bh[i]=(i-1)/T+1;
	for(int i=1;i<=N;i++)st[i]=(i-1)*T+1,ed[i]=i*T;
	for(int i=1;i<=n;i++)f[bh[dfn[i]]][dep[i]]++;
	for(int i=1;i<=N;i++)for(int j=n;j>=1;j--)f[i][j]+=f[i][j+1];
	while(m--){
		int op,x;
		scanf("%d",&op);
		if(op==1)scanf("%d",&ss);
		else{
			scanf("%d",&x);
			printf("%d\n",Solve(dfn[x],sd[x]));
		}
	}
}
```


---

## 作者：happybob (赞：1)

先考虑暴力做法。

对于深度 $\geq x$ 的点变成黄色，相当于对于每一个深度为 $x$ 的点，将以它为根的子树中每个点都变成黄色。

但是显然深度为 $x$ 的结点的数量是 $O(n)$ 级别的，每次用线段树维护区间覆盖区间求和的理论复杂度上界是 $O(mn\log n)$ 的，显然复杂度不对。

但是我们仔细分析可得，操作一里有这么一句话：把整棵树都染绿。

显然每次操作和之前的操作和查询是无关的，对每次查询产生贡献的只有上一次修改操作，并且一次修改至下一次修改之间的所有查询都可以打乱顺序，因为查询不会影响树的数据。

考虑操作离线，对于每个查询操作找到上次的修改，然后将 
$dep$ 从 $1$ 枚举到 $n$，对所有深度等于 $dep$ 的结点线段树维护区间覆盖，覆盖完后查询所有以 $dep$ 为上一次修改的查询即可。

由于一棵树最多只有 $n$ 个结点，而区间覆盖最多只会进行 $n$ 次。由于 $n,m$ 同阶，所以总体复杂度 $O(n \log n)$。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <utility>
#include <vector>
using namespace std;

const int N = 1e5 + 5;

int n, m;

class SegmentTree
{
public:
	struct Node
	{
		int l, r, sum;
		int tag;
	}tr[N << 2];
	void pushup(int u)
	{
		tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
	}
	void pushdown(int u)
	{
		if (tr[u].tag != -1)
		{
			tr[u << 1].tag = tr[u].tag;
			tr[u << 1].sum = tr[u].tag * (tr[u << 1].r - tr[u << 1].l + 1);
			tr[u << 1 | 1].tag = tr[u].tag;
			tr[u << 1 | 1].sum = tr[u].tag * (tr[u << 1 | 1].r - tr[u << 1 | 1].l + 1);
			tr[u].tag = -1;
		}
	}
	void build(int u, int l, int r)
	{
		tr[u] = { l, r, 0, -1 };
		if (l == r) return;
		int mid = l + r >> 1;
		build(u << 1, l, mid);
		build(u << 1 | 1, mid + 1, r);
	}
	void update(int u, int l, int r, int c)
	{
		if (tr[u].l >= l and tr[u].r <= r)
		{
			tr[u].tag = c;
			tr[u].sum = c * (tr[u].r - tr[u].l + 1);
		}
		else
		{
			pushdown(u);
			int mid = tr[u].l + tr[u].r >> 1;
			if (l <= mid) update(u << 1, l, r, c);
			if (r > mid) update(u << 1 | 1, l, r, c);
			pushup(u);
		}
	}
	int query(int u, int l, int r)
	{
		if (tr[u].l >= l and tr[u].r <= r)
		{
			return tr[u].sum;
		}
		pushdown(u);
		int mid = tr[u].l + tr[u].r >> 1, sum = 0;
		if (l <= mid) sum = query(u << 1, l, r);
		if (r > mid) sum += query(u << 1 | 1, l, r);
		return sum;
	}
}f;

vector<int> G[N];
vector<pair<int, int> > p[N];
vector<int> DEP[N];
int sz[N], dep[N], ans[N], idx;
int id[N], idx2;

void dfs(int u, int fa)
{
	dep[u] = dep[fa] + 1;
	DEP[dep[u]].push_back(u);
	sz[u] = 1;
	id[u] = ++idx2;
	for (int i = 0; i < G[u].size(); i++)
	{
		int j = G[u][i];
		if (j != fa)
		{
			dfs(j, u);
			sz[u] += sz[j];
		}
	}
}

int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i < n; i++)
	{
		int u, v;
		scanf("%d%d", &u, &v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
	int last = 0;
	for (int i = 1; i <= m; i++)
	{
		int op, x;
		scanf("%d%d", &op, &x);
		if (op == 1)
		{
			last = x;
		}
		else
		{
			p[last].push_back(make_pair(x, ++idx));
		}
	}
	dfs(1, 0);
	f.build(1, 1, n);
	for (int i = 0; i <= n; i++)
	{
		if (p[i].size() == 0) continue;
		if (i == 0)
		{
			for (pair<int, int> j : p[i])
			{
				ans[j.second] = 0;
			}
		}
		else
		{
			f.update(1, 1, n, 0);
			for (int j : DEP[i])
			{
				//printf("%d %d\n", i, j);
				f.update(1, id[j], id[j] + sz[j] - 1, 1);
			}
			for (pair<int, int> j : p[i])
			{
				ans[j.second] = f.query(1, id[j.first], id[j.first] + sz[j.first] - 1);
			}
		}
	}
	for (int i = 1; i <= idx; i++)
	{
		printf("%d\n", ans[i]);
	}
	return 0;
}
```


---

## 作者：Xy_top (赞：0)

很容易想到线段树合并做法，因为一号操作会把前面的一号操作全部覆盖掉。

所以二号查询操作就变为：询问一个结点 $x$ 的子树中有多少点的深度大于等于 $p$，其中 $p$ 是最近一次一号操作的参数，如果没有则为无穷大。

然后离线存每个结点的询问，接着线段树合并 $O(n\log n)$ 做完了。

代码很长，但如果擅长线段树合并写它就是一小会儿的事儿。

```cpp
#include <vector>
#include <iostream>
using namespace std;
int n, m, cnt;
int x, y;
int fa[100005], ans[100005], dep[100005], row[100005];
int a[1700005], ls[1700005], rs[1700005];
vector <pair <int, int> > q[100005];
vector <int> G[100005];
int merge (int l, int r, int xk, int yk) {
	if ( (a[xk] && a[yk]) == 0) return a[xk] ? xk : yk;
	if (l == r) {
		a[xk] += a[yk];
		return xk;
	}
	int mid = l + r >> 1;
	ls[xk] = merge (l, mid, ls[xk], ls[yk]);
	rs[xk] = merge (mid + 1, r, rs[xk], rs[yk]);
	a[xk] = a[ls[xk] ] + a[rs[xk] ];
	return xk;
}
void update (int l, int r, int k, int x) {
	a[k] ++;
	if (l == r) return;
	int mid = l + r >> 1;
	if (x <= mid) {
		if (!ls[k]) ls[k] = ++ cnt;
		update (l, mid, ls[k], x);
	} else {
		if (!rs[k]) rs[k] = ++ cnt;
		update (mid + 1, r, rs[k], x);
	}
}
int query (int l, int r, int k, int x) {
	if (x >= r) return 0;
	if (x <= l) return a[k];
	int mid = l + r >> 1, res = 0;
	res += query (mid + 1, r, rs[k], x);
	if (x <= mid) res += query (l, mid, ls[k], x);
	return res;
}
void dfs (int x) {
	row[x] = ++ cnt;
	for (int i = 0; i < G[x].size (); i ++) {
		if (G[x][i] != fa[x]) {
			fa[G[x][i] ] = x;
			dep[G[x][i] ] = dep[x] + 1; 
			dfs (G[x][i]);
			row[x] = merge (1, n, row[x], row[G[x][i] ]);
		}
	}
	update (1, n, row[x], dep[x]);
	for (int i = 0; i < q[x].size (); i ++)
		ans[q[x][i].second] = query (1, n, row[x], q[x][i].first);
}
int main () {
	dep[1] = 1;
	cin >> n >> m;
	for (int i = 1; i < n; i ++) {
		cin >> x >> y;
		G[x].push_back (y);
		G[y].push_back (x);
	}
	int d = 100001, op, c = 0;
	for (int i = 1; i <= m; i ++) {
		cin >> op >> x;
		if (op == 1) d = x;
		else q[x].push_back (make_pair (d, ++ c) );
	}
	dfs (1);
	for (int i = 1; i <= c; i ++) cout << ans[i] << "\n";
	return 0;
}
```


---

## 作者：BFSDFS123 (赞：0)

思维不够，数据结构来凑。

查询子树内满足深度的条件的点数是一个比较经典的线段树合并 trick 了吧。

考虑将所有的查询操作离线下来。对于一个查询操作，因为每次操作最初会将全部树涂成绿色，所以当且仅当在它之前最后一个执行的修改操作会对它作出贡献。

离线下来的时候，每次存储这个查询操作前的那个修改操作。每个查询，只需要询问该子树内深度大于等于上一次修改操作的修改深度的节点个数即可。

线段树合并代码很短，但是别忘了最后要 ``pushup``。


```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
//#define LL_inf 1145141919810
#define ull unsigned long long
#define ll long long
using namespace std;
//#define int long long
const int Maxn=1e5+10;
int n,m;
int dep[Maxn];
int head[Maxn],tot;
struct Edge{
	int to;
	int nxt;
}E[Maxn<<1];
void addedge(int u,int v)
{
	tot++;
	E[tot].to=v;
	E[tot].nxt=head[u];
	head[u]=tot;
}
struct segtree{
	int lson,rson;
	int val;
}t[Maxn<<5];
int nodenum;
int newnode()
{
	return ++nodenum;
}
void pushup(int node)
{
	t[node].val=t[t[node].lson].val+t[t[node].rson].val;
}
void update(int &node,int l,int r,int pos)
{
	if(!node)
	{
		node=newnode();
	}
	if(l==r)
	{
		t[node].val++;
		return ;
	}
	int mid=(l+r)>>1;
	if(pos<=mid)
	{
		update(t[node].lson,l,mid,pos);
	}else{
		update(t[node].rson,mid+1,r,pos);
	}
	pushup(node);
}
int query(int node,int l,int r,int ql,int qr)
{
	if(ql>=qr) return 0;
	if(!node) return 0;
	if(ql<=l && r<=qr)
	{
		return t[node].val;
	}
	int mid=(l+r)>>1,sum=0;
	if(ql<=mid)
	{
		sum+=query(t[node].lson,l,mid,ql,qr);
	}
	if(qr>mid)
	{
		sum+=query(t[node].rson,mid+1,r,ql,qr);
	}
	return sum;
}
int root[Maxn];
void dfs(int u,int fa)
{
	dep[u]=dep[fa]+1;
	for(int i=head[u];i;i=E[i].nxt)
	{
		int v=E[i].to;
		if(v==fa) continue;
		dfs(v,u);
	}
}
int merge(int u,int v,int l,int r)
{
	if(!u || !v)
	{
		return u+v;
	}
	if(l==r)
	{
		t[u].val+=t[v].val;
		return u; 
	}
	int mid=(l+r)>>1;
	t[u].lson=merge(t[u].lson,t[v].lson,l,mid);
	t[u].rson=merge(t[u].rson,t[v].rson,mid+1,r);
	pushup(u);
	return u;
}
struct Queris{
	int id;
	int d;
};
vector<Queris> Q[Maxn];
int res[Maxn]; 
void dfs2(int u,int fa)
{
	update(root[u],1,n,dep[u]);
	for(int i=head[u];i;i=E[i].nxt)
	{
		int v=E[i].to;
		if(v==fa) continue;
		dfs2(v,u);
		root[u]=merge(root[u],root[v],1,n);
	}
	
	for(auto i:Q[u])
	{
		int id=i.id;
		int depth=i.d;
		res[id]=query(root[u],1,n,depth,n);
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		addedge(u,v);
		addedge(v,u);
	}
	dfs(1,0);
	int lst=n+1;
	memset(res,-1,sizeof(res));
	for(int i=1;i<=m;i++)
	{
		int opt;
		scanf("%d",&opt);
		if(opt==1)
		{
			int x;
			scanf("%d",&x);
			lst=x;
		}else{
			int x;
			scanf("%d",&x);
			Q[x].push_back((Queris){i,lst});
		}
	}
	
	dfs2(1,0);
	for(int i=1;i<=m;i++)
	{
		if(res[i]==-1) continue;
		printf("%d\n",res[i]);
	}
	return 0;
}

```

---

## 作者：Tx_Lcy (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8844)

这题真的有蓝吗？~~虽然当时我打传智杯的时候没有切出来~~，但是现在看来就是一个傻子题。

## 思路

容易的，我们发现，不同的 $1$ 操作的影响是重复覆盖滴，因此我们只需要记录最后一次 $1$ 操作干了什么就行了。

然后就是板子了，记 $la$ 表示上一个 $1$ 操作。先根据 $\verb!DFS!$ 序把树拍扁，对于每个节点记录 $minx_x$ 和 $maxx_x$ 表示它子树的 $\verb!DFS!$ 序覆盖范围，我们发现每次查询操作就是静态二维数点，求横坐标在 $minx_x$ 和 $maxx_x$ 之间，纵坐标在 $la$ 和 $10^5$ 之间的点数。

于是直接主席树无脑维护即可。当然你想离线树状数组也可以，跑的比主席树更快，~~不过出题人可以卡你强制在线~~。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int const N=1e5+10;
vector<int>a[N];
int cnt=1,root[N];
struct hjt_Tree{
    #define ls(x) (lc[x])
    #define rs(x) (rc[x])
    #define mid ((l+r)>>1)
    int lc[N*40],rc[N*40],c[N*40];
    inline int clone(int la){++cnt;ls(cnt)=ls(la);rs(cnt)=rs(la);c[cnt]=c[la];return cnt;}
    inline void update(int &rt,int la,int l,int r,int p){
        rt=clone(la);if (l==r){++c[rt];return;}
        if (p<=mid) update(ls(rt),ls(la),l,mid,p);
        else update(rs(rt),rs(la),mid+1,r,p);
        c[rt]=c[ls(rt)]+c[rs(rt)];
    }
    inline int query(int x,int l,int r,int ll,int rr){
        if (ll<=l && r<=rr) return c[x];
        int res=0;
        if (ll<=mid) res+=query(ls(x),l,mid,ll,rr);
        if (mid<rr) res+=query(rs(x),mid+1,r,ll,rr);
        return res;
    }
}T;//主席树板子部分
int minx[N],maxx[N],dep[N],chag[N],dfn[N],tot;
inline void dfs(int x,int fa){
    dfn[x]=minx[x]=maxx[x]=++tot;
    dep[x]=dep[fa]+1;chag[dfn[x]]=dep[x];
    for (auto v:a[x]) if (v^fa) dfs(v,x),minx[x]=min(minx[x],minx[v]),maxx[x]=max(maxx[x],maxx[v]);
}//根据 DFS 序把树拍扁
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    int n,m;cin>>n>>m;
    for (int i=1;i<n;++i){
        int u,v;cin>>u>>v;
        a[u].push_back(v);
        a[v].push_back(u);
    }
    root[0]=1;dfs(1,0);
    for (int i=1;i<=n;++i) T.update(root[i],root[i-1],1,100000,chag[i]);
    int la=0;
    while (m--){
        int opt,x;cin>>opt>>x;
        if (opt==1) la=x;
        else{
            if (!la) cout<<"0\n";
            else{
                cout<<T.query(root[maxx[x]],1,100000,la,100000)-
                      T.query(root[minx[x]-1],1,100000,la,100000)<<'\n';//直接无脑查询
            }
        }
    }
    return 0;
}
```

---

## 作者：AlicX (赞：0)

## Solution 

因为每次操作会将以前的操作覆盖，所以每次询问的答案只与离其最近的操作有关。

于是询问变成这样：每次询问以 $u$ 为根的子树内深度大于 $x$ 的点，而 $x$ 是已知的。因为 $u$ 的子树内的 `dfs` 序是一段连续的区间，不难做出以下变形：对于一段区间 $l \sim r$，找出其中深度大于等于 $x$ 的点的个数。然后就可以很轻易地想到二维数点，第一遍先找出区间 $1 \sim l-1$ 的深度大于等于 $x$ 的点的个数，第二遍再找出区间 $1 \sim r$ 的深度大于等于 $x$ 的点的个数，两数相减即可。

本题不用离散化或者其他东西，代码很好写：

```cpp
#include<bits/stdc++.h>
//#define int long long
#define x first
#define y second 
#define il inline 
#define db double
#define low(x) x&-x 
#define pb(x) push_back(x) 
#define debug() puts("-------")  
using namespace std;
typedef pair<int,int> pii;
typedef pair<int,pii> PII; 
const int N=1e5+10,INF=1e9+7;  
int n,m; 
int tr[N]; 
int ans[N]; 
int dep[N]; 
int h[N],idx=0; 
int mp[N],cnt=0; 
int in[N],out[N]; 
struct Node{
	int to,ne; 
}e[N<<1]; 
struct Mind{ 
	int u,x,id; 
	il bool operator<(Mind &Cyan)const{ 
		return in[u]<in[Cyan.u]; 
	} 
}q[N]; 
il int read(){ 
	int x=0,f=1; char c=getchar();
	while(c<'0'||c>'9'){ if(c=='-') f=-1; c=getchar(); }
	while(c>='0'&&c<='9'){ x=(x<<3)+(x<<1)+c-48; c=getchar(); }
	return x*f;
} 
il bool cmp(Mind a,Mind b){ 
	return out[a.u]<out[b.u]; 
} 
il void add(int u,int v){
	e[idx].to=v,e[idx].ne=h[u],h[u]=idx++; 
} 
il void dfs(int u,int fa){
	dep[u]=dep[fa]+1; 
	in[u]=++cnt; mp[cnt]=dep[u]; 
	for(int i=h[u];i!=-1;i=e[i].ne){
		int to=e[i].to; 
		if(to==fa) continue; 
		dfs(to,u); 
	} out[u]=cnt; 
} 
il void Add(int x){
	for(int i=x;i;i-=low(i)) tr[i]++; 
} 
il int query(int x){ 
	int res=0; 
	for(int i=x;i<=n;i+=low(i)) res+=tr[i]; 
	return res; 
} 
signed main(){ 
	memset(h,-1,sizeof h); 
	n=read(),m=read(); 
	for(int i=1,u,v;i<n;i++){ 
		u=read(),v=read(); 
		add(u,v),add(v,u); 
	} dfs(1,0); int num=0,lst=n+1;   
	for(int i=1;i<=m;i++){ 
		int opt=read(),x=read(); 
		if(opt==1) lst=x; 
		else num++,q[num]={x,lst,num};   
	} sort(q+1,q+num+1); int j=1; 
	for(int i=1;i<=num;i++){ 
		while(j<=n&&j<in[q[i].u]) Add(mp[j]),j++; 
		ans[q[i].id]-=query(q[i].x); 
	} sort(q+1,q+num+1,cmp); 
	j=1; memset(tr,0,sizeof tr); 
	for(int i=1;i<=num;i++){ 
		while(j<=n&&j<=out[q[i].u]) Add(mp[j]),j++; 
		ans[q[i].id]+=query(q[i].x);  
	} for(int i=1;i<=num;i++) printf("%d\n",ans[i]); 
	return 0;
} /* */ 
```

CSP2023 RP++。


---


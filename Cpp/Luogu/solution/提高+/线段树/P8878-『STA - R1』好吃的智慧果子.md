# 『STA - R1』好吃的智慧果子

## 题目背景

在上古时代，$-(2077^{-1}\ \ (mod=2035))$ 年，$\mathfrak{Morlin}$ 种下了一棵非常珍贵的$\colorbox{black}{\textcolor{red}{\textbf{智♂慧♂树♂}}}$，被 $\mathfrak{char\_phi}$ 看见了。

过了 $114810$ 年，树上结出了 $\colorbox{black}{\textcolor{blue}{\textbf{智♂慧♂果♂子♂}}}$。  
又过了 $1919514$ 年，果子成熟了，$\mathfrak{char\_phi}$ 非常馋。

$\mathfrak{char\_phi}$ 十分想吃果子，但是~~神机妙算的~~ $\mathfrak{Morlin}$ 早就知道 $\mathfrak{char\_phi}$ 想要吃他的果子，所以把每个果子都装进了密码箱。

现在，$\mathfrak{char\_phi}$ 把偷果子这项重任托付给了你。  

## 题目描述

**形式化题面**

维护一个序列 $\{a_n\}$，每次操作给五个非负整数 $l, r, k, p, c$，对于所有 $i\in[l,r]$，将 $a_i\gets (f_{a_i}^k+c)\bmod p$。

其中 $f$ 是 Fibonacci 数列，定义为：
$$f_n=\begin{cases}n&n\leqslant 1\\f_{n-1}+f_{n-2}&n>1\end{cases}$$
***

**原题面**

~~神机妙算的~~ $\mathfrak{Morlin}$ 早就知道 $\mathfrak{char\_phi}$ 很聪明，所以他会不定时改密码。

每个密码箱上有一个数字，组成了数列 $\{a_n\}$。

关于密码有 $m$ 次操作，每次操作给定五个整数 $l, r, k, p, c$，表示将满足 $l \leqslant i \leqslant r$ 将 $a_i$ 变成 $(f_{a_i}^k+c) \bmod p$（$f_i$ 代表斐波那契数列的第 $i$ 项；保证 $l \leqslant r$）。

$\mathfrak{char\_phi}$ 搞了一个记录器记录下了 $\mathfrak{Morlin}$ 的操作。现在，他把记录器给了你，希望你能在 $\mathfrak{Morlin}$ 操作完后搞出所有密码箱的密码。

## 说明/提示

**【数据范围】**

**本题采用捆绑测试。**

| Subtask | $\bm{n,m\leqslant}$ | 分值 | 特殊性质 |
| :--: | :--: | :--: | :--: |
| $1$ | $10^3$ | $10$ | 无 |
| $2$ | $10^5$ | $10$ | $p \leqslant 2$ |
| $3$ | $10^5$ | $20$ | $p \leqslant 3$ |
| $4$ | $10^5$ | $60$ | 无 |

对于 $100\%$ 的数据，$1 \leqslant n, m \leqslant 10^5$，$1 \leqslant a_i, p, k \leqslant 100$，$0 \leqslant c \leqslant 10^9$。

## 样例 #1

### 输入

```
6 2
1 1 4 5 1 4
2 4 2 100 3
3 5 1 97 5```

### 输出

```
1 4 52 44 6 4```

# 题解

## 作者：joke3579 (赞：6)

由于值域较小，考虑一个值域相关的算法。

对于每次操作，我们可以预先算出在该操作下每个 $i$ 会变成的数字 $f(i)$。可以发现 $f$ 是一个值域到自身的映射。映射的复合显然满足结合律，我们可以将区间进行 $f_i$ 映射作为信息，使用线段树维护。

预处理 $f_i^j \bmod p$，这样可以在读入时以 $O(V)$ 的复杂度计算映射，其中 $V$ 是值域，该题中为 $100$。   
随后以标记合并方式维护即可。标记合并的复杂度为 $O(V)$。

因此我们可以在 $O(Vn\log n)$ 的复杂度内在线处理所有操作。

采用分块可以获得复杂度 $O(n\sqrt{nV})$，在本题的表现更优秀些。

参考代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10, R = 105;
#define rep(i,s,t) for (register int i = (s), i##_ = (t) + 1; i < i##_; ++ i)
#define pre(i,s,t) for (register int i = (s), i##_ = (t) - 1; i > i##_; -- i)
int n, q, a[N], l, r, k, p, c, f[R][R][R];

struct permu {
	static const int len = 100;
	int p[R];
	permu() { iota(p, p + R, 0); }
	int operator[] (const int &i) const { return p[i]; }
	int &operator[] (const int &i) { return p[i]; }
	permu &operator *= (const permu &rhs) {
		for (int i = 0; i <= len; i++)
			p[i] = rhs[p[i]];
		return *this;
	}
	permu operator* (const permu &rhs) const {
		permu _(*this);
		return _ *= rhs;
	}
} id, per;

struct SMT {
	#define ls (p << 1)
	#define rs (p << 1 | 1)

	permu tr[N << 2];
	inline void ps_d(const int& p) {
		tr[ls] *= tr[p];
		tr[rs] *= tr[p];
		tr[p] = id;
	}
	void assign(int p, int l, int r, int L, int R, const permu& pr) {
		if (L <= l and r <= R) {
			tr[p] *= pr;
			return;
		} ps_d(p); int mid = l + r >> 1;
		if (L <= mid) assign(ls, l, mid, L, R, pr);
		if (mid < R) assign(rs, mid+1, r, L, R, pr);
	}
	void print(int p, int l, int r) {
		if (l == r) {
			printf("%d ", tr[p][a[l]]);
			return;
		} ps_d(p); int mid = l + r >> 1;
		print(ls, l, mid);
		print(rs, mid+1, r);
	}
	
	#undef rs
	#undef ls
} T;

int main() {
	cin >> n >> q;
	for (int i = 1; i <= n; i++) cin >> a[i];
    rep(i,2,100) rep(j,1,100) f[1][i][j] = 1;
    rep(i,2,100) rep(j,1,100) {
        f[i][j][1] = (f[i - 1][j][1] + f[i - 2][j][1]) % j;
        rep(k,2,100) f[i][j][k] = f[i][j][k - 1] * f[i][j][1] % j;
    }
	while (q--) {
		cin >> l >> r >> k >> p >> c;
        rep(i,0,100) per[i] = (f[i][p][k] + c) % p;
		T.assign(1, 1, n, l, r, per);
	}
	T.print(1, 1, n);
}
```

---

## 作者：Lgx_Q (赞：3)

题意：对长度 $n$ 的序列 $a$ 进行 $m$ 次修改。第 $i$ 次修改所有 $j∈[l_i,r_i]$，使得 $a_j=(f_{a_j}^{k_i}+c_i)\operatorname{mod}p_i$，输入中一次修改用一个五元组表示 $(l_i,r_i,k_i,p_i,c_i)$。

式子中 $f$ 序列是斐波那契数列，即

$f_1=f_2=1,f_i=f_{i-1}+f_{i-2}(3≤i)$

最终求出修改后的的序列 $a$。

其中 $1≤n,m≤10^6,1≤a_j,k_i,p_i≤100,1≤c_i≤10^9$

分析：

本题并不要求在修改的同时在线维护整个序列，因此考虑整体维护每个修改。

受到[这题](https://www.luogu.com.cn/problem/CF1743F)的启发，我们思考分离每个修改的区间的左右端点，排序，用数据结构维护整个修改序列。

对于第 $i$ 次修改，我们在 $l_i$ 位置记上一个“修改”标记，在 $r_i+1$ 位置记上一个“撤销”标记。

顺序枚举位置 $i=1...n$，双指针维护每个标记。建立线段树，维护 $1...m$ 的修改序列，维护当前位置 $i$ 受哪些修改的影响。

线段树则可以维护自动机。对于线段树的节点 $p$，设 $g(p,x)$ 为初始值为 $x$ 的数字，经过 $p$ 对应区间的修改后的值。

如果 $p$ 区间只包含一个修改，暴力计算显然会超时（不信的话自己动手算）。设 $res(i,j,k)$ 表示 $f_i^k\operatorname{mod}j$ 的值。则循环 $100$ 次即可计算一个修改的自动机。

线段树自下往上合并信息时也可以循环 $100$ 次计算自动机。

也就是说，一次 $\operatorname{modify}$ 时间复杂度为 $O(100\operatorname{log}m)$，枚举每个位置需要 $O(n)$，总时间复杂度为 $O(100n\operatorname{log}m)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=4e5+10;
int n,m,a[maxn],fib[maxn],l,r,k,p,c,len,g[maxn][102],res[105][105][105];
struct oper
{
	int x,v,k,p,c,id;
}q[maxn];
void getFib(int p)
{
	fib[1]=1%p;
	for(int i=2;i<=100;i++) fib[i]=(fib[i-1]+fib[i-2])%p;
}
bool cmp(oper a,oper b){return a.x<b.x;}
void modify(int p,int l,int r,oper op)
{
	if(l==r)
	{
		for(int i=0;i<=100;i++)
		{
			if(op.v) g[p][i]=(res[i][op.p][op.k]+op.c)%op.p;
			else g[p][i]=i;
		}
		return;
	}
	int mid=l+r>>1;
	if(op.id<=mid) modify(p<<1,l,mid,op);
	else modify(p<<1|1,mid+1,r,op);
	for(int i=0;i<=100;i++)
	{
		g[p][i]=g[p<<1|1][g[p<<1][i]];
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d%d%d",&l,&r,&k,&p,&c);
		q[++len]=(oper){l,1,k,p,c%p,i};
		q[++len]=(oper){r+1,0,0,0,0,i};
	}
	for(int i=0;i<=100;i++) //预处理 res 数组
	{
		for(int j=1;j<=100;j++)
		{
			getFib(j);
			res[i][j][1]=fib[i];
			for(int k=2;k<=100;k++)
			{
				res[i][j][k]=res[i][j][k-1]*res[i][j][1]%j;
			}
		}
	}
	sort(q+1,q+1+len,cmp);
	for(int i=1;i<=m;i++) //初始化，建树也行
	{
		modify(1,1,m,(oper){0,0,0,0,0,i});
	}
	for(int i=1,j=0;i<=n;i++)
	{
		while(j<len&&q[j+1].x==i)
		{
			++j;
			modify(1,1,m,q[j]);
		}
		printf("%d ",g[1][a[i]]);
	}
	return 0;
}
```

---

## 作者：鲤鱼江 (赞：0)

该题考虑到权值始终不大于 $100$，所以可以提前把映射数组在 $O(V)$ 的时间内预处理出来，在需要时进行 $O(1)$ 的转移。

值域是始终不变的且很小的值，这给了我们可乘之机，从此下手。

我们思考：这种映射关系是否是满足一些方便且优美的性质，然后发现满足**结合律**。理由是显然的，毕竟你经历两次该映射与经历这两次映射的复合明显是等价的。

分析此映射是否可以被线段树维护：首先其存在单位元，也封闭（值域 $100$ 且带模），又满足结合律，是一个货真价实的半群，而映射复合又可以 $O(V)$ 完成，完全符合线段树的使用条件。

总时间 $O(nV\log n)$，有点卡常。

```cpp
#include<bits/stdc++.h>

using namespace std;

namespace Fread {
	const int SIZE=1<<21;
	char buf[SIZE],*S,*T;
	inline char getchar() {
	    if(S==T){
	        T=(S=buf)+fread(buf,1,SIZE,stdin);
	        if(S==T)return '\n';
	    }
	    return *S++;
	}
}
namespace Fwrite {
	const int SIZE=1<<21;
	char buf[SIZE],*S=buf,*T=buf+SIZE;
	inline void flush(){
	    fwrite(buf,1,S-buf,stdout);
	    S=buf;
	}
	inline void putchar(char c){
	    *S++=c;
	    if(S==T)flush();
	}
	struct POPOSSIBLE{
	    ~POPOSSIBLE(){flush();}
	}ztr;
}
#define getchar Fread :: getchar
#define putchar Fwrite :: putchar
namespace Fastio{
	struct Reader{
	    template<typename T>
    	Reader& operator >> (T& x) {
        	char c=getchar();
        	while(c<'0'||c>'9'){
            	c=getchar();
        	}
        	x=0;
        	while(c>='0'&&c<='9'){
	            x=x*10+(c-'0');
	            c=getchar();
	        }
	        return *this;
    	}
	    Reader(){}
	}cin;
	struct Writer{
	    template<typename T>
	    Writer& operator << (T x) {
	        if(x==0){putchar('0');return *this;}
	        static int sta[45];
	        int top=0;
	        while(x){sta[++top]=x%10;x/=10;}
	        while(top){putchar(sta[top]+'0');--top;}
	        return *this;
    	}
    	Writer& operator << (char c) {putchar(c);return *this;}
    	Writer(){}
	}cout;
}
#define ls now<<1
#define rs now<<1|1
#define cin Fastio :: cin
#define cout Fastio :: cout

const int N=1e5+10;
struct Per{
	int v[101];
	int& operator [](const int &x){return v[x];}
	inline void init(){for(int i=0;i<=100;++i) v[i]=i;}
	void operator *=(const Per &t){for(int i=0;i<=100;++i) v[i]=t.v[v[i]];}
}tag[N<<2],v;
int lenth,tot,n,a[N],f[110],k,mod,c,m,flag[N<<2];
typedef long long ll;

inline int Mod(const int &x){return x>=mod?x-mod:x;}
inline int expow(ll x,int y){
	ll res=1;
	for(;y;y>>=1){if(y&1) res=(res*x)%mod;x=(x*x)%mod;}
	return res;
}

void pushdown(int now){
	if(!flag[now]) return ;
	tag[ls]*=tag[now];
	tag[rs]*=tag[now];
	tag[now].init();
	flag[ls]=flag[rs]=1;
	flag[now]=0;
}

void build(int now,int l,int r){
	tag[now].init();
	if(l==r) return ;
	int mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
}

void update(int now,int l,int r,int x,int y){
	if(x<=l&&r<=y){
		flag[now]=1;
		tag[now]*=v;
		return ;
	}
	int mid=(l+r)>>1;pushdown(now);
	if(mid>=x) update(ls,l,mid,x,y);
	if(mid<y) update(rs,mid+1,r,x,y);
}

void print(int now,int l,int r){
	if(l==r){
		cout<<tag[now][a[l]]<<' ';
		return ;
	}
	int mid=(l+r)>>1;pushdown(now);
	print(ls,l,mid);print(rs,mid+1,r);
}

int main(){
	cin>>n>>m;build(1,1,n);
	for(int i=1;i<=n;++i) cin>>a[i];
	for(int i=1,l,r;i<=m;++i){
		cin>>l>>r>>k>>mod>>c;
		c%=mod;
		for(int i=0;i<=100;++i){
			if(i<=1) f[i]=(mod==1?0:i);
			else f[i]=Mod(f[i-1]+f[i-2]);
			v[i]=Mod(expow(f[i],k)+c);
		}
		update(1,1,n,l,r);
	}
	print(1,1,n);
	return 0;
}
```

---

## 作者：Fzrcy (赞：0)

注意到 $1 \leqslant a_i, p, k \leqslant 100$，所以我们可以把一次操作改为一个值域为 $[1,100]$ 的映射 $S$，将 $a_i\gets S_{a_i}$，显然映射满足结合律，所以我们可以用线段树维护每个点的映射，最后计算答案即可。

我们可以 $O(V^3)$ 预处理出 $f_i^j\bmod p$ 的值，以便快速得到每一次操作代表的映射，总时间复杂度为 $O(V^3+nV\log n)$。

```cpp
// qwq
#include <bits/stdc++.h>
using namespace std;
constexpr int V=102;
struct dsu{
	int vt[V];
	dsu(){for(int i=0;i<=100;i++)vt[i]=i;}
	inline dsu operator + (dsu b){
		dsu r;
		for(int i=0;i<=100;i++)
			r.vt[i]=b.vt[vt[i]];
		return r;
	}
};
constexpr int N=1e5+6;
struct SGT{
	dsu t[N<<2];
	bool H[N<<2];
	inline void dw(int x){
		if(H[x]){
			t[x<<1]=t[x<<1]+t[x];
			t[x<<1|1]=t[x<<1|1]+t[x];
			H[x<<1]=H[x<<1|1]=1,H[x]=0;
			t[x]=dsu();
		}
	}
	void modify(int k,int l,int r,int x,int y,dsu v){
		if(l>=x&&r<=y){t[k]=t[k]+v;H[k]=1;return;}int mid=l+r>>1;dw(k);
		if(x<=mid)modify(k<<1,l,mid,x,y,v);
		if(y>mid)modify(k<<1|1,mid+1,r,x,y,v);
	}
	void out(int k,int l,int r,int *a){
		if(l==r){cout<<t[k].vt[a[l]]<<' ';return;}int mid=l+r>>1;dw(k);
		out(k<<1,l,mid,a),out(k<<1|1,mid+1,r,a);
	}
}tr;
int f[V][V][V],a[N],n,m;
int main(){
	for(int i=2;i<=100;i++)
		for(int j=1;j<=100;j++)
			f[1][i][j]=1%i;
	for(int i=2;i<=100;i++)for(int j=1;j<=100;j++){
		f[i][j][1]=(f[i-1][j][1]+f[i-2][j][1])%j;
		for(int k=2;k<=100;k++)f[i][j][k]=f[i][j][k-1]*f[i][j][1]%j;
	}
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=m;i++){
		int l,r,k,p,c;
		cin>>l>>r>>k>>p>>c;
		dsu s;
		for(int j=0;j<=100;j++)
			s.vt[j]=(f[j][p][k]+c)%p;
		tr.modify(1,1,n,l,r,s);
	}
	tr.out(1,1,n,a);
	return 0;
}
```



---


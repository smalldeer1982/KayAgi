# [ZJOI2010] 排列计数

## 题目描述

称一个 $1 \sim n$ 的排列 $p_1,p_2, \dots ,p_n$ 是 Magic 的，当且仅当  
$$\forall i \in [2,n],p_i > p_{\lfloor i/2 \rfloor}$$
计算 $1 \sim n$ 的排列中有多少是 Magic 的，答案可能很大，只能输出模 $m$ 以后的值。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 10^6$, $1\le m \le 10^9$，$m$ 是一个质数。


## 样例 #1

### 输入

```
20 23 ```

### 输出

```
16
```

# 题解

## 作者：xyz32768 (赞：44)

题意：求$1$到$n$的所有排列中，满足小根堆性质的排列的个数。

这里建立$DP$模型：$f[i]$表示$i$个不同的数的所有排列中满足小根堆性质的排列的个数。

对于转移，首先计算出$i$个节点的完全二叉树中，根节点的左子树包含的节点数$l$，右子树包含的节点数$r$。

首先，根节点的值必须为最小值。再考虑剩下的$i-1$个节点。很容易想到，可以在这$i-1$个节点中选出$l$个节点作为左子树，剩下的$r$个节点作为右子树。所以得出转移：

$f[i]=C_{i-1}^l*f[l]*f[r]$。

同时注意坑点(在BZOJ上)：$n$可以大于$p$，所以求组合数要用到$Lucas$定理。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 1e6 + 5;
int n, PYZ, f[N], fac[N], Log[N], inv[N];
int qpow(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = 1ll * res * a % PYZ;
        a = 1ll * a * a % PYZ;
        b >>= 1;
    }
    return res;
}
int C(int x, int y) {
    if (!y) return 1;
    int u = C(x / PYZ, y / PYZ), v = x % PYZ, w = y % PYZ, z;
    if (v < w) z = 0;
    else z = 1ll * (1ll * fac[v] * inv[w] % PYZ) * inv[v - w] % PYZ;
    return 1ll * u * z % PYZ;
}
int main() {
    int i, kx, l = 1, r = 1; n = read(); PYZ = read();
    fac[0] = 1; Log[0] = -1;
    for (i = 1; i <= n; i++) fac[i] = 1ll * fac[i - 1] * i % PYZ,
        Log[i] = Log[i >> 1] + 1;
    kx = min(PYZ - 1, n); inv[kx] = qpow(fac[kx], PYZ - 2);
    for (i = kx - 1; i >= 0; i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % PYZ;
    f[1] = f[2] = 1; f[3] = 2;
    for (i = 4; i <= n; i++) {
        if (i - (1 << Log[i]) + 1 <= (1 << Log[i] - 1)) l++;
        else r++;
        f[i] = 1ll * (1ll * C(i - 1, l) * f[l] % PYZ) * f[r] % PYZ;
    }
    printf("%d\n", f[n]);
    return 0;
}
```

---

## 作者：学委 (赞：30)

![](https://cdn.luogu.com.cn/upload/pic/53957.png)

“子 > 父”，就是个**小根堆**。

填入 1 ~ n 的排列，满足小根堆性质。

1号节点只能填最小数。

还剩 n - 1 个数分给左右子树。

**左右子树互不干扰。** 如果左子树的大小为 L，它就可以从 n - 1 个数中任意选择 L 个数字来填，剩下给右子树去填，**左子树和右子树各自满足小根堆性质就行了**。

方案总数为 **C(n - 1, L) × 左子树填满并满足小根堆性质的方案数 × 右子树填满并满足小根堆性质的方案数**。

左子树和右子树，它们是各自想办法的。

```cpp
void dfsA(long long u) {
  siz[u] = 1;
  for (int v = u * 2; v <= u * 2 + 1; ++v)
    if (v <= n)
      dfsA(v), siz[u] += siz[v];
}

long long dfsB(long long u) {
  if (u > n)
    return 1;
  return C(siz[u] - 1, siz[u * 2]) * dfsB(u * 2) % MOD * dfsB(u * 2 + 1) % MOD;
}
```


---

## 作者：撤云 (赞：27)

[$surprise$](https://www.cnblogs.com/hbxblog/p/10600559.html)

### $Solution$

其实我们可以发现这题等价于让你求：

用$1$~$n$的数组成一个完全二叉树使之满足小根堆性质的方案数


于是我们可以考虑$dp$

假设我们现在在$i$点,$i$的子节点个数为$s[i]$(包括自己)

则：

$dp[i]=C(s[i]-1,s[i*2])*f[i*2]*f[i*2+1]$

$ps:$
因为是二叉树所以$i*2$和$i*2+1$为$i$的两个儿子

这个式子很容易看懂吧。

在子节点中选一些填入左儿子,一些填入右儿子,右儿子和左儿子都要满足小根堆的性质

### $Code$

``` cpp
#include<bits/stdc++.h>
#define rg register
#define int long long
using namespace std;
int read() {
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return f*x;
}
int f[1000001],s[2000011],dp[2000011];
int ksm(int a,int b,int p){
    int ans=1;
    while(b){  
        if(b&1) ans=ans*a%p;  
        a=a*a%p,b>>=1;
    }
    return ans;
}
int c(int n,int m,int p){return f[n]*ksm(f[m]*f[n-m]%p,p-2,p)%p;}
int lucas(int n,int m,int p){ return m?c(n%p,m%p,p)*lucas(n/p,m/p,p)%p:1; }
main(){
    int p,n;
    cin>>n>>p,f[0]=1;
    for(int i=1;i<=n;i++) f[i]=f[i-1]*i%p;
    for(int i=1;i<=n;i++) s[i]=1;
    for(int i=n;i>=2;i--) s[i>>1]+=s[i];
    for(int i=n+1;i<=n*2+1;i++) dp[i]=1;
    for(int i=n;i>=1;i--)
        dp[i]=lucas(s[i]-1,s[i*2],p)%p*dp[i*2]%p*dp[i*2+1]%p;
    cout<<dp[1];
}
```

---

## 作者：NaCly_Fish (赞：8)

来瞎水一个理论时间复杂度 $\text O(\sqrt n \log n)$ 的做法（   
首先需要一种黑科技来求阶乘模大质数：[P5282](https://www.luogu.com.cn/problem/P5282)

对于一个完全二叉树，要求出 $u$ 节点的子树是一个堆的填数方案，容易得到答案为

$$(\text{siz}_u-1)!\frac{\text{ans}_{L}\text{ans}_R}{\text{siz}_L!\text{siz}_R!}$$
简单分类讨论一下可以得到，对于一个完全二叉树的两个子树，至少有一个是满二叉树。  

而对于满二叉树的答案是可以预处理的，只有 $\Theta(\log n)$ 种，这部分时间复杂度为 $\text O(\sqrt n \log n)$。

所以递归计算答案的话，只会执行 $\text O(\log n)$ 次，每次 $n$ 减半，时间复杂度 

$$T(n)=T(n/2)+\text O(\sqrt n \log n) = \text O(\sqrt n \log n)$$
所以最终的总时间复杂度也是这个。

核心代码如下：  
（其中 `fac` 和 `invfac` 分别是求阶乘和其逆元）
```cpp
int solve(int n){
    if(n<16) return table[n];
    int dep = 1;
    while((1<<dep)<=n) ++dep; 
    if((1<<dep)==n+1) return f[dep]; //预处理的深度为 dep 时满二叉树的答案
    int ans,ls,rs,rm = n-(1<<(dep-1))+1;
    ls = min(rm,1<<(dep-2))+(1<<(dep-2))-1;
    rs = n-ls-1;
    ans = (ll)invfac(ls)*invfac(rs)%p*solve(ls)%p*solve(rs)%p*fac(n-1)%p;
    return ans;
}
```

---

## 作者：硫代硫酸钠 (赞：8)

预备知识:

1. 对于素数p,$C(n,m)=C(n/p,m/p)\cdot C(n$%$p,m$%$p)$    $(\equiv p)$

2. 对于一个完全二叉树,如果父亲点权总是比儿子点权小,则构成了一个小根堆.

题目的意思就是有多少个大小为n的小根堆.

考虑动态规划:令 $dp[i]$ 表示有多少个大小为i的小根堆,

转移时考虑剩下的$i-1$个点中有$C(i-1,l)$个点能作为左子树,剩下的点作为右子树,即

$dp[i]=C(n-1,l)\cdot dp[l]\cdot dp[r]$.

组合数一看样例果断卢卡斯.

蒟蒻的代码

```cpp
#include<algorithm>
#include<cctype>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<map>
#include<queue>
#include<stack>
#include<vector>
#define siz 1000010
#define debug(x) cerr<<#x<<"="<<x
#define gc getchar()
#define db double
#define ll long long
#define rep(i,s,n) for (register int i=s;i<=n;i++)
#define drep(i,n,s) for (register int i=n;i>=s;i--)
#define il inline
using namespace std;

il ll r()
{
	char c; ll x,f=1;
	for (c=gc;!isdigit(c);c=gc) if (c=='-') f=-1; x=c-'0';
	for (c=gc;isdigit(c);c=gc) x=(x<<1)+(x<<3)+c-'0';
	return f*x;
}

ll n,p,fac[siz+10],fav[siz+10],vol[siz],dp[siz];
ll ksm(ll x,ll y)
{
	ll res=1;
	while (y)
	{
		if (y&1) res=(res*x)%p;
		x=(x*x)%p;
		y>>=1;
	}
	return res;
}

ll Lucas(int n,int m)
{
	if (m>n) return 0;
	if (n<p&&m<p) return (fac[n]*fav[n-m]%p*fav[m])%p;
	else return Lucas(n/p,m/p)*Lucas(n%p,m%p)%p;
}


int main()
{
	n=r(); p=r();
	int size=min(n,p-1);
	fac[0]=1; rep(i,1,size) fac[i]=(fac[i-1]*i)%p;
	fav[size]= ksm(fac[size],p-2); drep(i,size-1,0) fav[i]=(i+1)*fav[i+1]%p; 
	drep(i,n,1)
	{
		vol[i]=1; if (i*2<=n) vol[i]+=vol[i*2]; if (i*2+1<=n) vol[i]+=vol[i*2+1];
		if (i*2+1 <=n) dp[i]=(Lucas(vol[i]-1,vol[i*2])*dp[i*2])%p*dp[i*2+1]%p;
		else if (i*2<=n) dp[i]=dp[i*2]; 
		else dp[i]=1;
	} 
	printf("%lld\n",dp[1]);
	return 0;
}


```

---

## 作者：kczno1 (赞：5)

把小根堆看作一棵二叉树，


那么对于长度为n的排列，根必须是最小的，之后左儿子右儿子自然大于根了，


而且对于左子树和右子树，他们的大小是确定的了，那么就是一个子问题了，ans(l)\*ans(r)\*C(n-1,l)就是ans(n)。


dp一下就行了。


左子树的大小也是可以dp出来的。


upd:
(1)左子树大小有办法直接算。

就是先求出有多少层，

除去最下一层是完全二叉树，左子树大小就是n/2;

最下一层的话因为知道左边最多有多少个，对它取个min就可以了。

(2)算组合数因为模数有可能很小，所以要用lucas等方法。

(数据弱，直接算也不会错，所以之前没发现)

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=1000100;
typedef long long ll;
int n,p,i;
int f[N],le[N];bool is_le[N];
ll jie[N];
ll niv(ll x)
{
    ll ans=1;int y=p-2;
    while(y)
    {
        if(y&1) (ans*=x)%=p;
        (x*=x)%=p;y>>=1;
    }
    return ans;
}
int C(int y,int x)
{
    if(y<x) return 0;
    if(y<p) return jie[y]*niv(jie[x])%p*niv(jie[y-x])%p;
    return ll(C(y/p,x/p))*C(y%p,x%p)%p;
}
int F(int n)
{
    if(f[n]) return f[n];
    return f[n]=(ll)F(le[n])*F(n-1-le[n])%p*C(n-1,le[n])%p;
}

int main()
{
    //freopen("1.in","r",stdin);
    scanf("%d%d",&n,&p);
    f[1]=f[2]=1;
    is_le[2]=1;
    for(i=3;i<=n;++i) is_le[i]=is_le[i>>1];
    for(i=2;i<=n;++i) le[i]=le[i-1]+is_le[i];
    jie[0]=1;for(i=1;i<=n;++i) jie[i]=jie[i-1]*i%p;
    printf("%d\n",F(n));
}
```

---

## 作者：lytqwq (赞：4)

$$\large\forall i \in [2,n],p_i \gt p_{\lfloor i/2 \rfloor}$$

注意到对于现在的 $i$ 只有一个直接联系的条件来限制它的最小值。

画图看关系后发现这是一颗树，父节点比儿子节点小的树，而且 $root=1$ ，显然在 $root$ 处是最小值，要向   $root$ 的儿子分配剩下的数，注意到只要我们给儿子刚好足够的数量的数，这个儿子的子树就**可以**满足条件，而不在乎给的数的大小，**因为没有两个相同大小的数**，所以只是分配数的选择的问题。

注意到这是一颗二叉树，我们先 $dfs$ 求出每个节点子树中有几个节点，然后统计答案。

对于每个节点 $i$ ，分配给两个儿子 $son_1,son_2$ 的方案数是 
$$\large C_{\text{wide(son1)+wide(son2)}}^{\text{wide(son1)}}$$

其中 $wide$ 是子树大小。

因为我们只看给的数字的相对大小，所以我们对每个节点的考虑是独立的，把这些东西乘起来就完了。

代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000010;
int n,m,inv[N];
long long int ans=1;
int C(int x,int y){
	long long int res=1;
	for(int i=y+1;i<=x;i++){
		res*=i;
		res%=m;
	}
	for(int i=1;i<=x-y;i++){
		res*=inv[i];
		res%=m;
	}
	return res;
}
int ls(int x){
	return x<<1;
}
int rs(int x){
	return x<<1|1;
}
int w[N<<2];
void dfs(int x){
	if(x>n)return ;
	dfs(ls(x));
	dfs(rs(x));
	w[x]=w[ls(x)]+w[rs(x)]+1;
	ans*=C(w[x]-1,w[ls(x)]);
	ans%=m;
}
int main(){
	scanf("%d%d",&n,&m);
	inv[1]=1;
	for(int i=2;i<=1e6;i++){
		inv[i]=(long long int )inv[m%i]*(m-m/i)%m;
	}
	dfs(1);
	printf("%lld\n",ans);
}
```





---

## 作者：huangjunqi1 (赞：2)

可以看出排列是个小根堆

这道题显然是道树形DP

###若以i为根结点的左子树有n个节点，右子树有m个节点，则f[i]=f[i\*2]\*f[i\*2+1]\*c(n+m)(m)

本来是道很简单的题，但求组合数时就有点困难

有除法，想到逆元。用扩欧或费马小定理都可以（数据较弱）

但BZOJ上的这题数据有所加强，还可能整除k

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
typedef long long ll;
using namespace std;
ll sum[1000010],f[1000010],num[1000010],n,p;
int size[2000010];
ll exgcd(ll n,ll m,ll &x,ll &y)
{
    if (!m)
    {
        x=1,y=0;
        return n;
    }
    ll t=exgcd(m,n%m,x,y);
    ll tmp=x;
    x=y;
    y=tmp-(n/m)*y;
}
ll calc(int n,int m)
{
    ll x,y;
    int k1=num[n]-num[m]-num[n-m];
    if (k1) return 0;
    ll ans=exgcd((sum[m]*sum[n-m])%p,p,x,y);
    return (sum[n]*(x+p))%p;
}
int main()
{
    scanf("%lld%lld",&n,&p);
    sum[0]=1;
    memset(num,0,sizeof(num));
    for (int i=1;i<=n;i++)
    {
        int x=i;
        num[i]=num[i-1];
        while (x%p==0)
        {
            num[i]++;
            x/=p;
        }
        sum[i]=(sum[i-1]*(ll)x)%p;
    }
    for (int i=1;i<=n;i++)
        size[i]=1;
    for (int i=1;i<=n;i++)
        f[i]=1;
    f[1]=1;
    for (int i=n;i;i--)
    {
        size[i/2]+=size[i];
        if (i+i<=n&&size[i+i])
        {
            if (i+i+1>n||!size[i+i+1])
            {
                f[i]=(f[i]*f[i+i])%p;
            }
            else
            {
                f[i]=f[i]*(f[i+i]*(f[i+i+1]*calc(size[i+i]+size[i+i+1],size[i+i])%p)%p)%p;//最开始少去摸了一次，在BZOJ上WA了7次TT
            }
        }
    }
    printf("%lld\n",f[1]);
    return 0;
}
```

---

## 作者：raincity (赞：1)

[更好的阅读体验](https://blog.calvincheng1231.org.cn/default/165.html)

## 分析
题意转化：计算 $1\sim n$ 的排列中，有多少个满足小根堆性质，即 $p_i<\min\{p_{2i},p_{2i+1}\}$。

考虑 DP，设 $dp_i$ 表示 $1\sim i$ 的排列中，有多少个满足小根堆性质。

显然 $p_1=1$，剩下 $i-1$ 个数中，选 $l$ 个作为 $1$ 的左子树，$r$ 个作为 1 的右子树，则：

$$dp_i=dp_l\times dp_r\times\binom{i-1}{l}$$

$l$ 和 $r$ 可以在 DP 时递推得到。

题目保证 $m$ 为质数，但是没有保证 $m>n$，所以求组合数的时候要用 Lucas 定理。阶乘只需要预处理到 $\min\{n,m-1\}$ 即可。

时间复杂度 $O(\min\{n,m\}+n\log_m^n)$。

## 解决
代码：

```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 1000005;
int n, m, k, fac[N], inv[N], dp[N];
bool inLeft[N];

int C(int x, int y)
{
    if (x < y || y < 0)
        return 0;
    if (x <= k)
        return 1LL * fac[x] * inv[y] % m * inv[x - y] % m;
    return 1LL * C(x / m, y / m) * C(x % m, y % m) % m;
}

int power(int x, int y = m - 2, int p = m)
{
    int ans = 1, base = x;
    while (y)
    {
        if (y & 1)
            ans = 1LL * ans * base % p;
        base = 1LL * base * base % p, y >>= 1;
    }
    return ans;
}

void dfs(int cur)
{
    inLeft[cur] = true;
    if ((cur << 1) <= n)
        dfs(cur << 1);
    if ((cur << 1 | 1) <= n)
        dfs(cur << 1 | 1);
}

int main()
{
    cin >> n >> m;
    k = min(n, m - 1);
    fac[0] = 1;
    for (int i = 1; i <= k; i++)
        fac[i] = 1LL * fac[i - 1] * i % m;
    inv[k] = power(fac[k]);
    for (int i = k - 1; i >= 0; i--)
        inv[i] = 1LL * inv[i + 1] * (i + 1) % m;
    dp[0] = dp[1] = 1;
    if (n >= 2)
        dfs(2);
    for (int i = 2, l = 0, r = 0; i <= n; i++)
    {
        if (inLeft[i])
            l++;
        else
            r++;
        dp[i] = 1LL * dp[l] * dp[r] % m * C(i - 1, l) % m;
    }
    cout << dp[n] << endl;
    return 0;
}
```

---


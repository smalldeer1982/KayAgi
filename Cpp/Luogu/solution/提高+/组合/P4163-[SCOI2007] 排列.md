# [SCOI2007] 排列

## 题目描述

给一个数字串 $s$ 和正整数 $d$, 统计 $s$ 有多少种不同的排列能被 $d$ 整除（可以有前导 $0$）。例如 $123434$ 有 $90$ 种排列能被 $2$ 整除，其中末位为 $2$ 的有 $30$ 种，末位为 $4$ 的有  $60$ 种。

## 说明/提示

$100\%$ 的数据满足：$s$ 的长度不超过 $10$，$1\le d\le 1000$，$1\le T\le 15$。

在前三个例子中，排列分别有 $1,3,3628800$ 种，它们都是 $1$ 的倍数。

## 样例 #1

### 输入

```
7
000 1
001 1
1234567890 1
123434 2
1234 7
12345 17
12345678 29```

### 输出

```
1
3
3628800
90
3
6
1398
```

# 题解

## 作者：Monster_Qi (赞：37)

## 解题思路

　　首先我们发现这道题s的长度很小，所以考虑点暴力的做法，状压dp或搜索。本蒟蒻搜索永远调不对，所以就写了个状压dp。因为所有s里的数都要出现一次，并且最后的答案是要求整除，那么我们设$dp[S][k]$表示现在所选的状态集合为S，当前所选的数组成的数字对d取余后的值为k，这样就可以转移了。首先枚举所有的状态S，然后再枚举所有没有被选的数j，再枚举余数k即可转移。  
　　转移方程为：$dp[S|(1<<(j-1))][(k*10+a[j])\%d]+=dp[S][k]$;但是这样写是错误的，因为没有考虑重复的排列，比如说s为"001"，结果发现“010”这个状态会被算两次。。看到有大佬直接用数学方法去重orz，本蒟蒻不太会，就记了个临时数组$b[i]$，表示当前要填的数字i有没有被填过，这样就可以避免一个位置放相同元素的情况了，具体看代码。时间复杂度为$O(T*len*d*2^{len})$


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>

using namespace std;
const int MAXN = 11;

int T,d,a[MAXN],cnt,dp[1<<MAXN][1002];
bool b[MAXN];
char s[MAXN];

int main(){
	scanf("%d",&T);int len;
	while(T--){
		memset(dp,0,sizeof(dp));
		scanf("%s%d",s+1,&d);
		len=strlen(s+1);cnt=0;
		for(register int i=1;i<=len;i++) a[i]=s[i]-'0';//把所有数字存一下
		dp[0][0]=1;  //赋初值
		for(register int S=0;S<(1<<len)-1;S++){ //S表示当前所选的状态集合
			memset(b,0,sizeof(b));  //注意清零
			for(register int j=1;j<=len;j++)if(!(S&(1<<(j-1))) && !b[a[j]]){ //如果a[j]已经转移过就不能继续转移了,j表示遍历s中的各位数字。
				b[a[j]]=1;
				for(register int k=0;k<d;k++) //k表示对d取余后的数
					dp[S|(1<<(j-1))][(k*10+a[j])%d]+=dp[S][k];
			}
		}
		printf("%d\n",dp[(1<<len)-1][0]);
	}
	return 0;
}
```

---

## 作者：Sakurajima_Mai (赞：20)

首先呢，
这题 应该是个状压(反正我写的是状压)

我们设
$f[i][j]$表示状态为$i$余数$j$的方案

假设我们现在的状态为$i$ 

如果我们已经确定了前$i$位的话，那么再在后方枚举下一位添加的数j,则现在产生的数即为原来的$i*10+A[k]$

那进一步考虑的话，对现在的余数产生的影响即为余数      $(j*10 + A_k) % d$

所以我们依次枚举所有$i$的状态 , 再枚举所有余数$j$产生的方案就可以得到状态转移方程：

$f[ i | (1 << k) ][((j * 10 + A[k]) \% d]+=f[i][j]$

但我们会因此漏掉一种情况：
如果某个数字 $i$ 在排列中出现了 $Cnt[i]$ 次，那么最后的答案 $Ans$ 应该 $Ans /= (Cnt[i])!$


---

## 作者：传奇英雄 (赞：8)

### 今天来教大家如何减少常数 本人开O2最优解top1 116ms
这道题显然是状压DP。直接dfs记忆化搜索会常数很大。为了减小常数，我们不妨把0~1022的所有状态的信息预处理出来，就可以大大减小常数了。看见大家大多都跑了1s多，加上优化后可以快10倍。

还有一点：有些题解用了组合数判重，但是我们可以对于每一种状态，将已经选择的数标记为1，每次只能选择标记为0的数。这样就不用最后再处理重复了，也不用重复计算重复的数了，是一个小优化。

小常数代码如下：（并没有用什么优化指令）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int g=1050,h=1005;
int t,a[12],b[12],n,d[g][12],f[g][12],e[g],z[g];
int dp[g][h],d2[g],d3[g][h],s,p,u,v,w;
bool fl[12];
char ch;

int main()
{
	//freopen("in","r",stdin);
	scanf("%d\n",&t);
	for(int i=0;i<1023;i++)//预处理可以加入数的位置
	{
		for(int j=1,k=0;k<=10;j<<=1,k++)
			if(!(i&j))
			{
				d[i][++e[i]]=k;//0的位置，即可以选择的位置
				f[i][e[i]]=i^j;//选择后的状态
			}
		z[i]=11-e[i];//状态中1的个数
	}
	b[0]=1;
	while(t--)
	{
		n=0;
		while(scanf("%c",&ch))
		{
			if(ch==' ') break;
			a[n++]=int(ch)-48;
		}
		scanf("%d\n",&p);
		for(int i=1;i<10;i++)
			b[i]=b[i-1]*10%p;
		s=(1<<n)-1;
		memset(dp,0,sizeof(dp));
		dp[0][0]=1;
		for(int i=0;i<s;i++)//第一维：压缩后的状态
			for(int j=0;j<p;j++)//第二维：模p后的余数
			{
				memset(fl,0,sizeof(fl));//注意清空
				w=dp[i][j];
				if(w)
					for(int k=1;f[i][k]<=s;k++)
					{
						v=a[d[i][k]];//选择a[d[i][k]]
						if(!fl[v])
						{
							fl[v]=1;
							dp[f[i][k]][(j+v*b[z[i]])%p]+=w;
						}
					}
			}
		printf("%d\n",dp[s][0]);
	}
	return 0;
}
```


---

## 作者：jins3599 (赞：7)

状压经典题目。

设计方程$f(i,p)$代表当前选择的排列前几个个数的状态为$i$，对$d$取模等于$p$.

我们考虑如何转移？

显然，我们可以从剩下的没拿的元素中取出几个来拼接到这个串的后面进行计数。

用方程写出来就是：

$$f(i|(1<<(j-1)),(p*10+a[j])\%d)+=f(i,p)$$

但是我们可以发现，剩下的元素中可能有**重复元素**

于是我们只需要在选择剩下的元素时判断这个元素是否被选过即可，若没有被选过，那么就选，然后标记，否则不选。

然后我们依次枚举集合状态$i$，当前集合中哪些数没选$j$，和所有的模数$p$，进行转移即可。

复杂度$O(T*2^{len}*len*d)$

```cpp

#include <bits/stdc++.h>
#define int long long 

using namespace std;

const int N = 1e3;

int a[N];
int f[(1 << 10) + 5][N];
bool vis[N];

void Solve () {
	memset(f , 0 , sizeof(f));
	memset(a , 0 , sizeof(a));
	string s; 
	int d;
	cin >> s >> d;
	int n = s.size();
	for(int i = 1 ; i <= n ; ++ i) a[i] = s[i - 1] - '0';
	f[0][0] = 1;
	for(int i = 0 ; i < (1 << n) ; i ++) {
		memset(vis , 0 , sizeof(vis));
		
		for(int j = 1 ; j <= n ; j ++) {
			if(i & (1 << (j - 1))) continue;
			if(vis[a[j]]) continue;
			vis[a[j]] = 1;
			for(int k = 0 ; k < d ; k ++)
				f[i | (1 << (j - 1))][(k * 10 + a[j]) % d] += f[i][k];
		}
	}
	cout << f[(1 << n) - 1][0] << endl;
}

signed main () {
	int T;
	scanf("%lld" , &T);
	while(T --) Solve(); 
	return 0;
}
```

---

## 作者：斯德哥尔摩 (赞：6)

看到题目与数据范围，状态压缩没得说。。。

将每个数字标上一个序号。

设dp[i][j]表示选了几个数字且 mod d 的余数为j的方案数，i为01序列,即所选数字状态的压缩。

转移：dp[i][(l+k)%d]+=dp[i^(1<<j)][l]

      i为状态，j为当前需要处理的数字的序号，k为所选数字加上j号数字后对余数的影响，l为枚举的余数。

最后再用排列组合原理去重即可。

如果没有明白，看代码吧。。。

附代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
int n,d,S,ans,num[15],f[15],a[15],b[1<<10],c[15],dp[(1<<10)+1][1010];//S为全集，ans为答案，num为数字，f为阶乘，a为10的幂，b为每种状态选了多少个数字，c为计数数组，dp为状压DP数组
inline int read(){//读优
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
int sum(int x){//求状态x选了多少个数字
	int y=0;
	while(x){
		if(x&1)y++;
		x>>=1;
	}
	return y;
}
void make(){//初始构造阶乘，10的幂，状态的含义
	f[0]=a[0]=1;//从0开始。。。
	for(int i=1;i<=10;i++){
		f[i]=f[i-1]*i;
		a[i]=a[i-1]*10;
	}
	for(int i=0;i<(1<<10);i++)b[i]=sum(i);
}
void work(){//工作
	for(int i=1;i<S;i++)//枚举状态
	for(int j=0;j<n;j++)
	if((1<<j)&i){//判定合法
		int k=a[b[i]-1]%d*num[j+1]%d;//求加上j后的影响
		for(int l=0;l<d;l++)dp[i][(l+k)%d]+=dp[i^(1<<j)][l];//转移
	}
	ans=dp[(1<<n)-1][0];//记录答案
	for(int i=1;i<=n;i++)c[num[i]]++;
	for(int i=0;i<=9;i++)ans/=f[c[i]];//去重
	printf("%d\n",ans);//输出
}
void init(){//读入+预处理
	char ch[15];
	scanf("%s",ch);d=read();
	n=strlen(ch);
	for(int i=0;i<n;i++)num[i+1]=ch[i]-'0';//转化成数字
	memset(dp,0,sizeof(dp));
	memset(c,0,sizeof(c));//别忘了清空。。。
	S=1<<n;
	dp[0][0]=1;//初始化
}
int main(){//主函数So easy!
	make();
	int t=read();
	while(t--){
		init();
		work();
	}
	return 0;
}

```

---

## 作者：QMQMQM4 (赞：5)

# 提供两种解法

## case 1

使用STL中的next_permutation函数，对一个已经排好序的数组使用，可获得从小到大的全排列。

一般都和do while语句连用

具体实现见代码

```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

typedef long long ll;
const int maxn = 20;
int a[maxn];

int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		memset(a,0,sizeof(a));
		char s[maxn];
		memset(s,0,sizeof(s));
		int d;
		scanf("%s %d",s,&d);
		int n = strlen(s);
		for(int i = 0;i<n;++i)
			a[i+1] = s[i]-'0';
//这里先把数组转成int型
		sort(a+1,a+1+n);
		ll cnt = 0;
		do
		{
			ll ans = 0;
			for(int i = 1;i<=n;++i)
				ans = ans*10+a[i];
			if(ans%d == 0)
				cnt ++;
		}while(next_permutation(a+1,a+1+n));
//因为这个函数无解会返回false，所以直接放在while中
		printf("%d\n",cnt);
	}
	return 0;
}
```
## case 2

注意到T<=15,考虑状压dp。

建立数组dp[i][j]来维护两个状态

i表是当前已选用数字集合，j表示mod d后为j的方案数

其中集合用二进制来维护

注意去重，先求出没有重复数字的排列数，再除以每个数出现的次数的阶乘

状态转移方程见代码

```
#include<cstdio>
#include<cstring>
using namespace std;

typedef long long ll;
const int maxn = 1<<10;
char a[15];
int dp[maxn][1005],cnt[11];

int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		int n,d;
		scanf("%s %d",a,&d);
		n = strlen(a);
		for(int i = 0;i<n;++i)
			a[i] -= '0';
		memset(dp,0,sizeof(dp));
		dp[0][0] = 1;
		for(int i = 0;i<(1<<n);++i)
		{
			for(int j = 0;j<d;++j)
			{
				for(int k = 0;k<n;++k)
				{
					if(!(i&(1<<k)))
						dp[i|(1<<k)][(j*10+a[k])%d] += dp[i][j];
//状态转移，i枚举集合，j枚举余数，k枚举选的数字，注意是 += 号
				}
			}
		}
		ll ans = dp[(1<<n)-1][0];
		memset(cnt,0,sizeof(cnt));
		for(int i = 0;i<n;++i)
			cnt[a[i]]++;
		for(int i = 0;i<10;++i)
//处理阶乘
			for(int j = 2;j<=cnt[i];++j)
				ans /= j;
		printf("%lld\n",ans);
	}
	return 0;
}
```
~~case2来自夏令营老师讲解以及代码~~


























---

## 作者：lx_zjk (赞：2)

道题 还是比较水的 ~~至少我一遍推出了状态转移方程~~

有用$stl$水过去的 时间复杂度 $O(len! * T)$ 最大是$5 442 000$

不过稍微加强一下数据卡掉了

$f[s][i]$表示在状态$s$下模数为$i$的方案数

$f[s | (1 << i)][(j + a[i])$ % $d]$ $+= f[s][j]$

然后有一个地方要注意 如果一个数的排列为$t$种,每个数出为$cnt[i]$

那么不重复的即为 $t = t / (cnt[1]! * cnt[2]!  ... *cnt[9])$

# CODE
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int INF = 2139062143;

inline ll read() {
    ll f = 1, x = 0;char ch;
    do {ch = getchar();if (ch == '-')f = -1;} while (ch > '9' || ch < '0');
    do {x = x * 10 + ch - '0';ch = getchar();} while (ch >= '0' && ch <= '9');
    return f * x;
}

const int MAX_S = (1 << 11) - 1;

const int MAX_MOD = 1000 + 5;

const int MAX_N = 10 + 5;

int n, T, d, vis[MAX_MOD], bin[MAX_MOD], cnt[MAX_N], a[MAX_N], f[MAX_S][MAX_MOD];

char s[MAX_N];

inline int calc(int k) {
	if (k == 1 || k == 0) return 1;
	if (bin[k]) return bin[k];
 	return bin[k] = k * calc(k - 1);
}

int main() {
	T = read();
	while (T -- ) {
		scanf("%s", s); d = read();
		n = strlen(s);
		memset(cnt, 0, sizeof(cnt));
		for (int i = 0; i < n; i ++ ) {
			a[i] = s[i] - '0';
			cnt[a[i]] ++ ;
		}
		memset(f, 0, sizeof(f));
		f[0][0] = 1;
		for (int s = 0; s < (1 << n); s ++ ) {
			for (int i = 0; i < n; i ++ ) {
				if (s & (1 << i)) continue;
				for (int j = 0; j < d; j ++ ) {
					f[s | (1 << i)][(j * 10 + a[i]) % d] += f[s][j];
				}
			}
		}
		for (int i = 0; i < 10; i ++ ) {
			f[(1 << n) - 1][0] /= calc(cnt[i]);
		}
		cout << f[(1 << n) - 1][0] << endl;
	}
	return 0;
}


```

---

## 作者：元夕 (赞：1)

$\text{RT, 此题为状压dp练手题。}$

$ \text{简单考虑dp[i][j] 代表 状态i的余数为j，mei每次添入一位，而暂时不考虑相同数字它带来的重复，而最后在用最终答案除去重复排列即可}$
### 则答案为
$$ \frac{ans}{\prod\limits_{i = 0}^{9} cnt[i] !} $$
-----
由定义易知，$f[i \  \cup \{ x \} ][(j * 10 + x)\%mod] \ += f[i][j]$
### 代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1000;
int n, mod, a[maxn], d[maxn];
char c[maxn];
int f[maxn << 1][maxn];
//int fac(int r) {return r == 1 ? 1 : r * fac(r - 1);}
int main(){
	int t;
	cin >> t;
	while(t --) {
		scanf("%s%d", c + 1, &mod); n = strlen(c + 1);
		for(int i = 1;i <= n;i ++) a[i] = c[i] - '0';
		memset(f, 0, sizeof(f));
		f[0][0] = 1;
		for(int i = 0;i < (1 << n);i ++) {
			for(int j = 0;j < mod;j ++) {
				for(int k = 1;k <= n;k ++) {
					int num = k - 1;
					if(!(i & (1 << num))) {
						f[i | (1 << num)][(j * 10 + a[k]) % mod] += f[i][j];
					}
 				}
			}
		}
		
		int ans = f[(1 << n) - 1][0];
		memset(d, 0, sizeof(d));
		
		for(int i = 1;i <= n;i ++) d[a[i]] ++;
		for(int i = 0;i < 10;i ++) {
			for(int j = 2;j <= d[i];j ++) {
				ans /= j;			
			}
		}
		
		cout << ans << endl;
		
	}
	return 0;
} 
```

---

## 作者：ppp204 (赞：1)

> 做法: 状压DP

~~你们怎么都跑的那么快啊……~~

首先这道题装压挺好想到的，毕竟$len\le 10$

我们记录$dp[sta][now]$为当前已经用掉了状态为$sta$的数，此时此刻余数为$now$的方案数。

刷表法更新即可。

关键就在于接下来怎么判断重复的了……因为有一些数字是重复的，会导致相同的结果多次计算。

然后我们会发现其实这种情况好像并不难判断？（雾

首先我们先看，对于相同的数字，**它们之间的不同排列顺序是算同一种方案的**（~~怎么感觉我讲了废话~~）

既然都知道排列顺序不重要了，那么我们为什么不直接除以他们的排列方案数呢？(即3个数字都相同的话，答案$\div A^3_3$)

因为我们无论如何都会用到这些数字总的所有数字，而我们相同数字的排列顺序不重要，那么我们就**直接把所有重复的排列方案除去就好了**

其实就是把所有相同的元素个数记录下来……根据上面发现的性质，直接除以这些相同数字的排列方案数就好了……

#### Code:

~~丑的一批的代码~~

```cpp
#include<bits/stdc++.h>
#define re register
#define rep(i,a,b) for(re int i=a,i##end=b; i<=i##end; i++)
#define drep(i,a,b) for(re int i=a,i##end=b; i>=i##end; i--)
#define repp(i,a,b) for(re int i=a,i##end=b; i<i##end; i++)
#define drepp(i,a,b) for(re int i=a,i##end=b; i>i##end; i--)
#define Erep(i,x) for(int i=head[x]; i; i=Edge[i].nxt)
#define Srep(i,x) for(re int i=x,i##end=x; i; i=(i-1)&i##end)
#define For(i,a,b,c) for(re int i=a,i##end=b,i##step=c; i<=i##end; i+=i##step)
#define Dor(i,a,b,c) for(re int i=a,i##end=b,i##step=c; i>=i##end; i-=i##step)
#define Forr(i,a,b,c) for(re int i=a,i##end=b,i##step=c; i<i##end; i+=i##step)
#define Dorr(i,a,b,c) for(re int i=a,i##end=b,i##step=c; i>i##end; i-=i##step)
#define debug(x) cerr<<#x<<" = "<<x<<endl
#define fi first
#define se second
#define PII pair<int,int>
#define coint const int
#define ms(x,a) memset(x,a,sizeof x)
#define CM printf("%.2lfMB\n",(&S2-&S1)/1024./1024.0)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int uint;
using namespace std;
template<class T>inline T lowbit(const T &x) { return x&-x; }
template<class T>inline T Max(const T &x, const T &y) { return x>y?x:y; }
template<class T>inline T Min(const T &x, const T &y) { return x<y?x:y; }
template<class T>inline int ToMin(T &x, const T &y) { return x>y?x=y,1:0; }
template<class T>inline int ToMax(T &x, const T &y) { return x<y?x=y,1:0; }
template<class T>inline void Swap(T &x, T &y) { T tt=x; x=y; y=tt; return; }
template<class T>inline T Abs(const T &x) { return x>0?x:-x; }
template<class T>inline T rd(){
	static char ch;static bool neg;static T x;
	for(neg=0,ch=0; ch>'9'||ch<'0'; neg=(ch=='-'),ch=getchar());
	for(x=0; ch>='0'&&ch<='9'; x=(x<<1)+(x<<3)+(ch^'0'),ch=getchar());
	return neg?-x:x;
}

int dp[(1<<10)+5][1001];
ll fpow[15];
int n,d;
char str[11];

inline void Init(){//预处理
	fpow[0]=1;
	rep(i,1,10) fpow[i]=fpow[i-1]*10;
	return;
}

bool mark[15];

inline void solve(){
	scanf("%s %d",str+1,&d);
	int n=strlen(str+1),N=1<<n;
	ms(dp,0);
	dp[0][0]=1;
	repp(sta,0,N-1){
		repp(has,0,d){
			if(!dp[sta][has]) continue;
			rep(i,1,n){
				if(!(sta&(1<<i>>1))){
					dp[sta|(1<<i>>1)][(has*10+str[i]-'0')%d]+=dp[sta][has];
				}
			}
		}
	}
	int ans=dp[N-1][0];
	ms(mark,0);
	rep(i,1,n){
    //除去相同数字的全排列,这样能保证答案不重复
    //因为对于每种可行方案，肯定都统计进去了，直接除以排列的方案数即可
		if(!mark[i]){
			int tot=0;
			rep(j,1,n) if(str[i]==str[j])
				tot++,ans/=tot,mark[j]=1;
                // 这里直接除了，没把总个数算出来再算全排列方案数……
		}
	}
	printf("%d\n",ans);
	return;
}

int main(){
	int T=rd<int>();
	while(T--) solve();
	return 0;
}
```

---


# 「Wdsr-1」笨蛋结构

## 题目背景

众所周知，琪露诺是笨蛋。

## 题目描述

琪露诺希望维护一个长度为 $n$ 的整数序列 $a$，初始值都为 $0$。

现在琪露诺想要进行 $q$ 次操作，每次选择序列中的一段区间 $[s,s+l-1]$ 并给出两个数字 $w,k$，使对所有的 $i \in [1,l]$，$a_{s+i-1}$ 加上 $w\times i^k$ 。  

琪露诺不希望 $k$ 很大，因此她给出了一个整数 $m$，满足 $0\le k\le m$。

为了不让头脑简单的琪露诺感到困惑，你只需要输出 依次进行完所有操作后，序列中的每个数字对 $2^{64}$ 取模（即 $\text{unsigned long long}$ 自然溢出）后的结果即可。

为了帮助你更好的理解题意，这里给出一段伪代码：

$$\def\b#1{\textbf{ #1 }}\def\t#1{\text{ #1 }}\def\s{\quad}
\def\l{\underline{\kern{300pt}}\cr[-10pt]}
\def\r{\overline{\underline{\kern{300pt}}}}
\begin{aligned}
&\r\cr&\b{Algorithm:}\t{An easy structure}\cr[-13pt]&\l\cr
&\begin{aligned}
    \t{1.}&\b{input}n,m,q \cr
    \t{2.}&\b{for}i=1\b{to} q \b{do} \cr
    \t{3.}&\s\b{input} s,l,w,k \cr
    \t{4.}&\s\b{for} j=1 \b{to} l \b{do}\cr
    \t{5.}&\s\s a[s+j-1] \gets a[s+j-1]+w\times \t{pow}(j,k) \cr
    \t{6.}&\s\b{end}\cr
    \t{7.}&\b{end}\cr
    \t{8.}&\b{for} i=1 \b{to} n \b{do}\cr
    \t{9.}&\s\b{output} a[i]\cr
    \t{10.}&\b{end}\cr
    \end{aligned}\cr[-12pt]
&\r\end{aligned}
%Made by @离散小波变换° .
%You can find his contributions by searching "JoesSR".
$$
其中 $\rm pow(a,b)$ 的含义为 $a^b$。 

## 说明/提示

#### 样例一说明

生成的数据为：
```plain
10 0 5
7 1 1558211206 0
1 3 401324017 0
4 5 235225636 0
6 4 2137131141 0
1 2 3791175968 0
```
它的结果是：
```plain
4192499985 4192499985 401324017 235225636 235225636 2372356777 3930567983 2372356777 2137131141 0
```

---

#### 数据生成&数据输出

```cpp
typedef unsigned long long u64;
typedef unsigned int       u32;
u32 MT[624],idx;
void _init(u32 seed){
    MT[0]=seed; idx=0; for(int i=1;i<624;++i) 
    MT[i]=(0x6c078965*(MT[i-1]^((MT[i-1])>>30)+i));
}
void _gene(){
    for(int i=0;i<624;++i){
        int x=MT[i]&0x80000000+(MT[(i+1)%624]&0x7fffffff);
        MT[i]=MT[(i+397)%624]^(x>>1);
        if(x&2)MT[i]^=0x9908b0df;
    }
}
u32  _calc(){
    if(!idx) _gene(); int x=MT[idx];
    x^=x>>11,x^=(x<<7)&(0x9d2c5680);
    x^=(x<<15)&0xefc60000,x^=x>>18;
    idx=(idx+1)%624; return x;
}
u64 _get(){u64 ret=_calc()*_calc(); return ret;}
u64 _get(u64 _l,u64 _r){return _get()%(_r-_l+1ull)+_l;}
void input(int &_n,int &_m,int &_q,int *_S,int *_L,u64 *_W,int *_K){
    u32 seed; scanf("%d%d%d%u",&_n,&_m,&_q,&seed); _init(seed); int i=1;
    if(_n>100) for(;i<=_q/4;++i){
        int _a=_get(1,_n-100),_b=_get(_a+_m,_a+_m+1),_l=_b-_a+1,_k=_get(0,_m);
        u64 _w=_get(); _S[i]=_a,_L[i]=_l,_W[i]=_w,_K[i]=_k;
    }
    if(_n>100) for(;i<=_q/2;++i){
        int _a=_get(1,100),_b=_get(_n-100,_n),_l=_b-_a+1,_k=_get(0,_m);
        u64 _w=_get(); _S[i]=_a,_L[i]=_l,_W[i]=_w,_K[i]=_k;
    }
    for(;i<=_q;++i){
        int _a=_get(1,_n),_b=_get(1,_n); if(_a>_b) swap(_a,_b);
        int _l=_b-_a+1,_k=_get(0,_m); u64 _w=_get();
        _S[i]=_a,_L[i]=_l,_W[i]=_w,_K[i]=_k;
    }
}
void output(int n,u64 *R){
    u64 ret=n^_get(); for(int i=1;i<=n;i++) ret^=_get()+R[i];
    printf("%llu\n",ret);
}
```
其中，调用 `input()` 读入数据；调用 `output()` 输出数据。

**请勿在任何时候调用除了`input`和`output`外的函数，且这两个函数只能调用一次**。

--- 

#### 数据范围 

共 $20$ 个测试点，满足如下条件：

$$\def\arraystretch{1.5}\begin{array}{|c|c|c|c|}\hline
\textbf{编号} & n & m & q \\ \hline
[1,3] & \le 3\times 10^3 & =9 & \le 3\times 10^3 \\\hline
[4,5] & \le 3\times 10^5 & =0 & \le 3\times 10^5 \\\hline
[6,9] & \le 3\times 10^5 & =1 & \le 3\times 10^5 \\\hline
[10,13] & \le 3\times 10^5 & =2 & \le 3\times 10^5 \\\hline
[14,16] & \le 3\times 10^5 & =9 & \le 3\times 10^5 \\\hline
[17,20] & \le 5\times 10^5 & =9 & \le 1\times 10^6 \\\hline
\end{array}$$

其中，$[l,r]$ 表示编号为 $l,l+1,\cdots,r-1,r$ 的测试点。

对于 $100\%$ 的数据，满足 $1\le l_i \le l_i+s_i-1 \le n,0\le k_i\le m,0 \le w\le 2^{64}-1$。

## 样例 #1

### 输入

```
10 0 5 233
```

### 输出

```
6942214367
```

## 样例 #2

### 输入

```
1000 9 500 6666
```

### 输出

```
7636746723064426256```

# 题解

## 作者：耶梦加得 (赞：8)

**Why so fancy?**

根据套路，第 $i$ 次操作相当于对于 $[s_i, s_i + l_i)$ 加上一个多项式 $w_i(x-s_i+1)^{k_i}$

~~没了~~

用二项式定理~~不知道的左转百度百科~~展开，则我们相当于给这个区间里  的 $j$ 次项（$0 \le j \le k_i$）加上了某个相同（容易发现只和 $i$ 有关）的系数，直接差分即可。

最后用差分数组还原原数组，然后直接算多项式就行。

~~注：这里提到的多项式就是字面意思的多项式，暴力算即可，别被名字劝退了~~

code:
```cpp
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<queue>
#include<vector>
#define miu 1000007
using namespace std;
typedef unsigned long long u64;
typedef unsigned int       u32;
u32 MT[624],idx;
void _init(u32 seed){
    MT[0]=seed; idx=0; for(int i=1;i<624;++i) 
    MT[i]=(0x6c078965*(MT[i-1]^((MT[i-1])>>30)+i));
}
void _gene(){
    for(int i=0;i<624;++i){
        int x=MT[i]&0x80000000+(MT[(i+1)%624]&0x7fffffff);
        MT[i]=MT[(i+397)%624]^(x>>1);
        if(x&2)MT[i]^=0x9908b0df;
    }
}
u32  _calc(){
    if(!idx) _gene(); int x=MT[idx];
    x^=x>>11,x^=(x<<7)&(0x9d2c5680);
    x^=(x<<15)&0xefc60000,x^=x>>18;
    idx=(idx+1)%624; return x;
}
u64 _get(){u64 ret=_calc()*_calc(); return ret;}
u64 _get(u64 _l,u64 _r){return _get()%(_r-_l+1ull)+_l;}
void input(int &_n,int &_m,int &_q,int *_S,int *_L,u64 *_W,int *_K){
    u32 seed; scanf("%d%d%d%u",&_n,&_m,&_q,&seed); _init(seed); int i=1;
    if(_n>100) for(;i<=_q/4;++i){
        int _a=_get(1,_n-100),_b=_get(_a+_m,_a+_m+1),_l=_b-_a+1,_k=_get(0,_m);
        u64 _w=_get(); _S[i]=_a,_L[i]=_l,_W[i]=_w,_K[i]=_k;
    }
    if(_n>100) for(;i<=_q/2;++i){
        int _a=_get(1,100),_b=_get(_n-100,_n),_l=_b-_a+1,_k=_get(0,_m);
        u64 _w=_get(); _S[i]=_a,_L[i]=_l,_W[i]=_w,_K[i]=_k;
    }
    for(;i<=_q;++i){
        int _a=_get(1,_n),_b=_get(1,_n); if(_a>_b) swap(_a,_b);
        int _l=_b-_a+1,_k=_get(0,_m); u64 _w=_get();
        _S[i]=_a,_L[i]=_l,_W[i]=_w,_K[i]=_k;
    }
}
void output(int n,u64 *R){
    u64 ret=n^_get(); for(int i=1;i<=n;i++) ret^=_get()+R[i];
    printf("%llu\n",ret);
}
u64 C[17][17]; //组合数，其实你打表也行，反正就前10行
int n, m, q, s[miu], l[miu], k[miu];
u64 w[miu], r[miu], c[miu][17]; //c是系数（差分）矩阵
signed main() {
    input(n, m, q, s, l, w, k); 
    for(int i = 0; i <= m; ++i) {
        C[i][0] = 1ull;
        for(int j = 1; j <= i; ++j) C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
    }
    for(int i = 1; i <= q; ++i) {
        u64 a = w[i];
        for(int j = k[i]; j >= 0; --j) {
            c[s[i]][j] += a * C[k[i]][j];
            c[s[i] + l[i]][j] -= a * C[k[i]][j];
            a *= (1 - s[i]);
        }
    }
    for(int i = 1; i <= n; ++i) {
        u64 v = 1ull;
        for(int j = 0; j <= m; ++j) {
            c[i][j] += c[i - 1][j];
            r[i] += c[i][j] * v;
            v *= i;
        }
    } 
    output(n, r);
    return 0;
}

```


---

## 作者：IdnadRev (赞：1)

萌萌题。

一次操作就是给 $x\in[l,r]$ 位置加 $(x-l+1)^k=\sum_{i=0}^k{k\choose i}x^i(1-l)^{k-i}$

每个位置对于 $p\in[0,k]$ 都用差分维护一个 $x^p$ 上的系数就好了。

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000005,maxk=10;
typedef unsigned long long u64;
typedef unsigned int u32;
int n,m,q;
int s[maxn],l[maxn],k[maxn];
u64 w[maxn],C[maxk][maxk],a[maxn],sum[maxn][maxk];
u32 MT[624],idx;
void _init(u32 seed){
    MT[0]=seed; idx=0; for(int i=1;i<624;++i) 
    MT[i]=(0x6c078965*(MT[i-1]^((MT[i-1])>>30)+i));
}
void _gene(){
    for(int i=0;i<624;++i){
        int x=MT[i]&0x80000000+(MT[(i+1)%624]&0x7fffffff);
        MT[i]=MT[(i+397)%624]^(x>>1);
        if(x&2)MT[i]^=0x9908b0df;
    }
}
u32  _calc(){
    if(!idx) _gene(); int x=MT[idx];
    x^=x>>11,x^=(x<<7)&(0x9d2c5680);
    x^=(x<<15)&0xefc60000,x^=x>>18;
    idx=(idx+1)%624; return x;
}
u64 _get(){u64 ret=_calc()*_calc(); return ret;}
u64 _get(u64 _l,u64 _r){return _get()%(_r-_l+1ull)+_l;}
void input(int &_n,int &_m,int &_q,int *_S,int *_L,u64 *_W,int *_K){
    u32 seed; scanf("%d%d%d%u",&_n,&_m,&_q,&seed); _init(seed); int i=1;
    if(_n>100) for(;i<=_q/4;++i){
        int _a=_get(1,_n-100),_b=_get(_a+_m,_a+_m+1),_l=_b-_a+1,_k=_get(0,_m);
        u64 _w=_get(); _S[i]=_a,_L[i]=_l,_W[i]=_w,_K[i]=_k;
    }
    if(_n>100) for(;i<=_q/2;++i){
        int _a=_get(1,100),_b=_get(_n-100,_n),_l=_b-_a+1,_k=_get(0,_m);
        u64 _w=_get(); _S[i]=_a,_L[i]=_l,_W[i]=_w,_K[i]=_k;
    }
    for(;i<=_q;++i){
        int _a=_get(1,_n),_b=_get(1,_n); if(_a>_b) swap(_a,_b);
        int _l=_b-_a+1,_k=_get(0,_m); u64 _w=_get();
        _S[i]=_a,_L[i]=_l,_W[i]=_w,_K[i]=_k;
    }
}
void output(int n,u64 *R){
    u64 ret=n^_get(); for(int i=1;i<=n;i++) ret^=_get()+R[i];
    printf("%llu\n",ret);
}
int main() {
	for(int i=0; i<=9; i++) {
		C[i][0]=C[i][i]=1;
		for(int j=1; j<9; j++)
			C[i][j]=C[i-1][j-1]+C[i-1][j];
	}
	input(n,m,q,s,l,w,k);
	for(int i=1; i<=q; i++) {
		u64 mul=w[i],now;
		for(int j=0; j<=k[i]; j++)
			now=mul*C[k[i]][j],sum[s[i]][k[i]-j]+=now,sum[s[i]+l[i]][k[i]-j]-=now,mul*=(1-s[i]);
	}
	for(int i=1; i<=n; i++) {
		u64 mul=1;
		for(int j=0; j<=m; j++)
			sum[i][j]+=sum[i-1][j],a[i]+=mul*sum[i][j],mul*=i;
	}
	output(n,a);
	return 0;
}

```

---

## 作者：Mugino_Shizuri (赞：0)

做过的区间加多项式的最简单的题。

发现题目要求等价于对于位置 $i\in[s,s+l-1]$ 的权值加上 $w(i-s+1)^k$，如果把位置 $i$ 的答案看做一个多项式，下标看作自变量，则相当于区间加上 $w(x-s+1)^k$。

使用二项式定理展开：$w(x-s+1)^k=\sum\limits_{i=0}^k{k\choose i}x^i(1-s)^{k-i}$。提前预处理组合数，并用差分实现 $O(1)$ 区间加，最后一口气回答即可。

$O(qm+nm)$ 时间复杂度，可轻松通过。

```cpp
#include<bits/stdc++.h>

using namespace std;


typedef unsigned long long u64;
typedef unsigned int u32;
u32 MT[624],idx;
void _init(u32 seed){
    MT[0]=seed; idx=0; for(int i=1;i<624;++i) 
    MT[i]=(0x6c078965*(MT[i-1]^(((MT[i-1])>>30)+i)));
}
void _gene(){
    for(int i=0;i<624;++i){
        int x=MT[i]&(0x80000000+(MT[(i+1)%624]&0x7fffffff));
        MT[i]=MT[(i+397)%624]^(x>>1);
        if(x&2)MT[i]^=0x9908b0df;
    }
}
u32  _calc(){
    if(!idx) _gene(); int x=MT[idx];
    x^=x>>11,x^=(x<<7)&(0x9d2c5680);
    x^=(x<<15)&0xefc60000,x^=x>>18;
    idx=(idx+1)%624; return x;
}
u64 _get(){u64 ret=_calc()*_calc(); return ret;}
u64 _get(u64 _l,u64 _r){return _get()%(_r-_l+1ull)+_l;}
void input(int &_n,int &_m,int &_q,int *_S,int *_L,u64 *_W,int *_K){
    u32 seed; scanf("%d%d%d%u",&_n,&_m,&_q,&seed); _init(seed); int i=1;
    if(_n>100) for(;i<=_q/4;++i){
        int _a=_get(1,_n-100),_b=_get(_a+_m,_a+_m+1),_l=_b-_a+1,_k=_get(0,_m);
        u64 _w=_get(); _S[i]=_a,_L[i]=_l,_W[i]=_w,_K[i]=_k;
    }
    if(_n>100) for(;i<=_q/2;++i){
        int _a=_get(1,100),_b=_get(_n-100,_n),_l=_b-_a+1,_k=_get(0,_m);
        u64 _w=_get(); _S[i]=_a,_L[i]=_l,_W[i]=_w,_K[i]=_k;
    }
    for(;i<=_q;++i){
        int _a=_get(1,_n),_b=_get(1,_n); if(_a>_b) swap(_a,_b);
        int _l=_b-_a+1,_k=_get(0,_m); u64 _w=_get();
        _S[i]=_a,_L[i]=_l,_W[i]=_w,_K[i]=_k;
    }
}
void output(int n,u64 *R){
    u64 ret=n^_get(); for(int i=1;i<=n;i++) ret^=_get()+R[i];
    printf("%llu\n",ret);
}

const int N=1e6+10;
u64 C[18][18],a[10][N],r[N],w[N];
int n,m,s[N],len[N],k[N],q;

signed main(){
	input(n,m,q,s,len,w,k);
	C[0][0]=1;
	for(int i=1;i<=m;++i){
		C[i][0]=C[i][i]=1;
		for(int j=1;j<i;++j) C[i][j]=C[i-1][j]+C[i-1][j-1];
	}
	for(int i=1;i<=q;++i){
		u64 tmp=w[i];
		for(int j=k[i];~j;--j){
			a[j][s[i]]+=tmp*C[k[i]][j];
			a[j][s[i]+len[i]]-=tmp*C[k[i]][j];
			tmp*=(1-s[i]);
		}
	}
	for(int i=1;i<=n;++i){
		u64 tmp=1;
		for(int j=0;j<=m;++j){r[i]+=tmp*(a[j][i]+=a[j][i-1]);tmp*=i;}
	}
	output(n,r);
	return 0;
}
```

---


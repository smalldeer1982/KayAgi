# [NOIP2021] 数列

## 题目描述

给定整数 $n, m, k$，和一个长度为 $m + 1$ 的正整数数组 $v_0, v_1, \ldots, v_m$。

对于一个长度为 $n$，下标从 $1$ 开始且每个元素均不超过 $m$ 的非负整数序列 $\{a_i\}$，我们定义它的权值为 $v_{a_1} \times v_{a_2} \times \cdots \times v_{a_n}$。

当这样的序列 $\{a_i\}$ 满足整数 $S = 2^{a_1} + 2^{a_2} + \cdots + 2^{a_n}$ 的二进制表示中 $1$ 的个数不超过 $k$ 时，我们认为 $\{a_i\}$ 是一个合法序列。

计算所有合法序列 $\{a_i\}$ 的权值和对 $998244353$ 取模的结果。

## 说明/提示

**【样例解释 #1】**

由于 $k = 1$，而且由 $n \leq S \leq n \times 2^m$ 知道 $5 \leq S \leq 10$，合法的 $S$ 只有一种可能：$S = 8$，这要求 $a$ 中必须有 $2$ 个 $0$ 和 $3$ 个 $1$，于是有 $\binom{5}{2} = 10$ 种可能的序列，每种序列的贡献都是 $v_0^2 v_1^3 = 4$，权值和为 $10 \times 4 = 40$。

**【数据范围】**

对所有测试点保证 $1 \leq k \leq n \leq 30$，$0 \leq m \leq 100$，$1 \leq v_i < 998244353$。

|    测试点    |  $n$  |   $k$    |  $m$   |
| :----------: | :---: | :------: | :----: |
|  $1 \sim 4$  | $=8$  | $\leq n$ |  $=9$  |
|  $5 \sim 7$  | $=30$ | $\leq n$ |  $=7$  |
| $8 \sim 10$  | $=30$ | $\leq n$ | $=12$  |
| $11 \sim 13$ | $=30$ |   $=1$   | $=100$ |
| $14 \sim 15$ | $=5$  | $\leq n$ | $=50$  |
|     $16$     | $=15$ | $\leq n$ | $=100$ |
| $17 \sim 18$ | $=30$ | $\leq n$ | $=30$  |
| $19 \sim 20$ | $=30$ | $\leq n$ | $=100$ |

## 样例 #1

### 输入

```
5 1 1
2 1
```

### 输出

```
40
```

## 样例 #2

### 输入

```
见附件中的 sequence/sequence2.in```

### 输出

```
见附件中的 sequence/sequence2.ans```

# 题解

## 作者：SDqwq (赞：289)

[传送门](https://www.luogu.com.cn/problem/P7961)

## $\texttt{Description}$

题面很友好，略。

$\texttt{Data Range:}1\le k\le n\le30,0\le m\le100,1\le v_i<998244353$

## $\texttt{Solution}$

看到这种题容易想到 dp。

我们发现，$S$ 的二进制表示位中 $1$ 的数量会涉及进位的问题。由于进位是从低位向高位进行的，所以考虑在 $S$ 中从低位到高位按位 dp（最低位为第 $0$ 位）。

设计 dp 状态 $f(i,j,k,p)$ 表示：讨论了 $S$ 从低到高的前 $i$ 位，已经确定了 $j$ 个序列 $a$ 中的元素，$S$ 从低到高前 $i$ 位中有 $k$ 个 $1$，要向当前讨论位的下一位进位 $p$。

因为从上一个状态转移到 $f(i,j,k,p)$ 细节太多，所以考虑用 $f(i,j,k,p)$ 往后转移。

接下来讨论第 $i$ 位（位从 $0$ 开始编号）。假设序列 $a$ 中有 $t$ 个元素为 $i$，那么就相当于给 $S$ 的第 $i$ 位贡献了 $t$ 个 $1$，再加上上一位进过来的 $p$ 个 $1$，总共有 $t+p$ 个 $1$。

我们知道，当前位每两个 $1$ 可以向下一位进一个 $1$。所以 $(t+p)\bmod2$ 的结果即为全部进位后当前位是否为 $1$。同理，向下一位进的 $1$ 的个数即为 $\left\lfloor\frac{t+
p}{2}\right\rfloor$。

所以 $f(i,j,k,p)$ 往后转移的状态应该是

$$f(i+1,j+t,k+(t+p)\bmod2,\left\lfloor\frac{t+
p}{2}\right\rfloor)$$

由于乘积之和的形式满足乘法分配律，所以不难想到 $f(i,j,k,p)$ 对新状态的贡献应该是

$$f(i,j,k,p)\times v_i^t\times\binom{n-j}{t}$$

初始化 $f(0,0,0,0)=1$。

如何统计答案呢？对于 $i$ 这一维，由于 $a$ 中元素的范围是 $0\sim m$，所以 $S$ 只用看总共 $m+1$ 位，所以是 $m+1$。对于 $j$ 这一维，最终 $n$ 个元素都要确定，所以是 $n$。对于 $k$ 这一维，应该是在 $0\sim k$ 之间的（后面这个 $k$ 是输入的 $k$）。$p$ 这一维就随便了。

不过有一个小细节，就是在 $S$ 的第 $m$ 位有可能还要往后面进位，所以可以使用一个 $\mathrm{popcnt}(p)$ 的函数快速统计出进完位后第 $m$ 位往后的 $1$ 的个数，再加上 $k$ 这一维的数量，如果小于等于输入的 $k$，就可以统计进答案。

$\mathrm{popcnt}$ 函数很简单，就是一直 `res += x & 1, x >>= 1` 就行了，道理跟前面转移的时候是一样的。

注意还要预处理每个 $v$ 的幂次方结果以及组合数，代码过程中的取模问题等。

这道题还可以用滚动数组进行空间优化，~~不过我懒~~。

**时间复杂度：$\mathcal{O}(n^4m)$**

## $\texttt{Code}$

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
typedef long long ll;
const ll mod = 998244353;

ll ans, v[105], dp[105][35][35][16], pv[105][35];

ll C[35][35];
inline void init(int n) {
	for (int i = 0; i <= n; i++) C[i][0] = 1;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= i; j++) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
}

inline int popcnt(int n) {
	int res = 0;
	while (n) res += n & 1, n >>= 1;
	return res;
}

int main() {
	init(30);
	int n, m, K;
	scanf("%d %d %d", &n, &m, &K);
	for (int i = 0; i <= m; i++) {
		scanf("%lld", &v[i]);
		pv[i][0] = 1;
		for (int j = 1; j <= n; j++) pv[i][j] = pv[i][j - 1] * v[i] % mod;
	}
	dp[0][0][0][0] = 1;
	for (int i = 0; i <= m; i++)
		for (int j = 0; j <= n; j++)
			for (int k = 0; k <= K; k++)
				for (int p = 0; p <= n >> 1; p++)
					for (int t = 0; t <= n - j; t++) dp[i + 1][j + t][k + (t + p & 1)][t + p >> 1] = (dp[i + 1][j + t][k + (t + p & 1)][t + p >> 1] + dp[i][j][k][p] * pv[i][t] % mod * C[n - j][t] % mod) % mod;
	for (int k = 0; k <= K; k++)
		for (int p = 0; p <= n >> 1; p++)
			if (k + popcnt(p) <= K) ans = (ans + dp[m + 1][n][k][p]) % mod;
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：huayucaiji (赞：233)

## 前言&emo

关于我没有预处理组合数导致 $100->85$ 这件事。

一道遗恨千年的 NOIP2021 T2。

写这篇题解时还没出官方数据和成绩。如果因为这 $15pts$ 而名落孙山的话，真不知道该如何面对自己将来的 OI 生涯。

## 解题思路

我就按照我考场上的思考过程讲吧。

考虑 DP。（计数类不是组合数就是 DP 呀）

我们定义一个四维的状态 $f_{i,j,k,q}$ 表示已经填好了 $i$ 个数，考虑完了 $v_{1...j}$，此时 $S$ 二进制下有 $k$ 个 $1$，有 $q$ 个已经赋值了的 $a_i$ 取了 $j$，**且 $q\geq 1$ 时**的权值总和。

我们发现这个状态不是很好转移，因为我们无法通过 $q$ 转移 $k$。问题就在于，如何计算 $k$ 呢？

比如说我们现在取了 $x$ 个 $2^y$，那么若 $2^i \operatorname{\&} x>0$ 则等价于在二进制下 $S$ 的 $y+i$ 位上有一个 $1$ 的**贡献**，所以对 $k$ 的贡献为 $\operatorname{popcnt}(x)$。$\operatorname{popcnt} (x)$ 表示 $x$ 在二进制下 $1$ 的位数。也就是说，我们如果单考虑 $S$ 二进制下 $1$ 的个数，取 $x$ 个 $2^i$ 等价于取 $\lfloor \frac{x}{2^{j-i}}\rfloor$ 个 $2^j$。 也就是说，后几位的数对于前面可能会有影响，我们可以把状态改成这样：

四维的状态 $f_{i,j,k,q}$ 表示已经填好了 $i$ 个数，考虑完了 $v_{1...j}$，此时 $S$ 二进制下有 $k$ 个 $1$，若不考虑 $j$ 以后的数，**等价于**取了 $q$ 个 $j$，**且至少有一个是本身就取了 $j$**。

这个就很好转移了。我们有转移方程：

$$f_{i,j,k,q}=\sum\limits_{x=0}^{i} (C_i^x\cdot \sum\limits_{p=0}^{j-1} \sum\limits_{\lfloor tmp/2^{i-p}\rfloor+x=q}f_{i-x,p,k-\operatorname{popcnt}(q)+\operatorname{popcnt}(q-x)},tmp)$$

如何理解这个方程呢？ $x$ 表示有多少个数本身就取了 $j$，$p$ 是上一个本身被取的数字，由于我们要倒退上一个状态我们的 $k$ 就会改变。我们少了 $x$ 个数，不会对更低位上的 $1$ 产生影响，因此 $k'=k-\operatorname{popcnt}(q)+\operatorname{popcnt}(q-x)$。而 $tmp$ 就是 $p$ 这一位等价的个数。

我们容易发现，这个代码复杂度大约为 $O(n^5m^2)$。但是跑不满。其实严重跑不过，只有 $50pts$。

我们考虑优化，我们重新定义一下状态，如下:

四维的状态 $f_{i,j,k,q}$ 表示已经填好了 $i$ 个数，考虑完了 $v_{1...j}$，此时 $S$ 二进制下有 $k$ 个 $1$，若不考虑 $j$ 以后的数，**等价于**取了 $q$ 个 $j$，**且可以没有任何是本身就取了 $j$**。

这样，我们就可以不再枚举 $p$ 了。方程如下：

$$f_{i,j,k,q}=\sum\limits_{x=0}^{i} (C_i^x\cdot \sum\limits_{\lfloor tmp/2\rfloor+x=q}f_{i-x,j-1,k-\operatorname{popcnt}(q)+\operatorname{popcnt}(q-x)},tmp)$$

其中 $tmp$ 只有两种取值。这样，我们的复杂度就变成了 $O(2n^4m)$。

似乎能过？

考场上是这么想的。

实际上，不预处理 $\operatorname{popcnt}$ 和组合数会 TLE 三个点。

预处理一下就过了，遗恨千年啊。。。。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN=33,MAXM=100+10,MOD=998244353;

int n,m,k;
long long f[MAXN][MAXM][MAXN][MAXN];
bool vis[MAXN][MAXM][MAXN][MAXN];
long long pop[MAXM],jc[MAXM],v[MAXM],c[MAXN][MAXN];

long long qpow(long long x,int y) {
	long long ret=1;
	while(y) {
		if(y&1) {
			ret=ret*x%MOD;
		}
		y>>=1;
		x=x*x%MOD;
	}
	return ret;
}
long long inv(int x) {
	return qpow(x,MOD-2);
}

long long C(int n,int m) {
	return jc[n]*inv(jc[m])%MOD*inv(jc[n-m])%MOD;
}

long long dp(int i,int j,int k,int q) {
	if(k<0||i<0||j<0||q<0) {
		return 0ll;
	}
	if(vis[i][j][k][q]) {
		return f[i][j][k][q];
	}
	if(i==0) {
		if(q==0&&k==0) {
			return 1ll;
		}
		return 0ll;
	}
	if(j==0) {
		return 0ll;
	}
	if(q>i) {
		return 0ll;
	}
	long long ans[MAXN]={},sum=0;
	for(int x=0;x<=q;x++) {
		for(int t=(q-x)*2;t<(q-x+1)*2&&t<=i-x;t++) {
			ans[x]=(ans[x]+dp(i-x,j-1,k-pop[q]+pop[q-x],t))%MOD;
		}
	}
	for(int x=0;x<=q;x++) {
		ans[x]=ans[x]*c[i][x]%MOD;
		sum=(sum+ans[x]*qpow(v[j],x)%MOD)%MOD;
	}
	vis[i][j][k][q]=1;
	return f[i][j][k][q]=sum;
}

int pop_c(int x) {
	int ret=0;
	while(x) {
		if(x&1) {
			ret++;
		}
		x>>=1;
	}
	return ret;
}

int main() {
	
	cin>>n>>m>>k;
	m++;
	for(int i=1;i<=m;i++) {
		scanf("%lld",&v[i]);
	}
	jc[0]=1;
	for(int i=1;i<=n;i++) {
		pop[i]=pop_c(i);
		jc[i]=jc[i-1]*i%MOD;
	}
	for(int i=1;i<=n;i++) {
		for(int x=0;x<=i;x++) {
			c[i][x]=C(i,x);
		}
	}
	
	long long ans=0;
	for(int t=0;t<=k;t++) {
		for(int i=0;i<=n;i++) {
			ans=(ans+dp(n,m,t,i))%MOD;
		}
	}
	
	cout<<ans<<endl;
	
}
```

## 总结

这篇题解就写完啦！花了我 1.5h，都看到这里了，不给个赞吗qwq。

省选继续加油吧，还有逆转乾坤的机会！

---

## 作者：Ginger_he (赞：79)

# 题目描述
给定数列 $\left\{a_i\right\}$，满足 $\forall a_i\in\left\{x\in \mathbb{Z}|0≤x≤m\right\}$。若 $\sum_{i=1}^n2^{a_i}$的二进制中 $1$ 的个数不超过 $k$，则为一种方案。求 $\sum(\prod_{i=1}^nv_{a_i})$。
# 题解
## 20pts
直接枚举每个 $a_i$ 的取值，时间复杂度 $\Theta(m^n)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=998244353;
int n,m,k,v[105],a[105];
ll ans;
int count(ll x)
{
	int res=0;
	while(x)
	{
		x-=(-x&x);
		res++;
	}
	return res;
}
void dfs(int x,ll s,ll cnt)
{
	if(x>=n+1)
	{
		int tmp=count(s);
		if(tmp<=k)
			ans=(ans+cnt)%mod;
		return;
	}
	for(int i=0;i<=m;i++)
	{
		a[x]=i;
		dfs(x+1,s+(1<<i),cnt*v[i]%mod);
	}
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i=0;i<=m;i++)
		scanf("%d",&v[i]);
	dfs(1,0,1);
	printf("%lld\n",ans);
	return 0;
}
```
## 50pts
将爆搜改成记忆化即可，$f(x,s)$ 表示填到第 $x$ 个数，总和为 $s$ 时的权值，时间复杂度 $\Theta(n^2\times 2^m\times m)$
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=998244353;
int n,m,k,v[105],a[105];
ll f[35][120005];
int count(ll x)
{
	int res=0;
	while(x)
	{
		x-=(-x&x);
		res++;
	}
	return res;
}
ll dfs(int x,ll s)
{
	if(x>=n+1)
		return count(s)<=k;
	if(f[x][s]!=-1)
		return f[x][s];
	long long res=0;
	for(int i=0;i<=m;i++)
	{
		a[x]=i;
		res=(res+dfs(x+1,s+(1<<i))*v[i]%mod)%mod;
	}
	return f[x][s]=res;
}
int main()
{
	memset(f,-1,sizeof(f));
	scanf("%d%d%d",&n,&m,&k);
	for(int i=0;i<=m;i++)
		scanf("%d",&v[i]);
	printf("%lld\n",dfs(1,0));
	return 0;
}
```
## 100pts
考虑一种 dp，将所有相同指数的数一次性加入到 $S$ 中。不难想到，dp 应该从低位往高位枚举，因为低位的进位会影响高位，而高位则对低位无影响，满足 dp 的无后效性，时间复杂度 $\Theta(m\times n^4)$。  
则状态转移方程为：  
$dp(x,y,a,b)=\sum_{i=0}^{n-y}dp(x+1,y+i,a+((b+i)\mod2),\lfloor\dfrac{b+i}{2}\rfloor)\times v_x^i\times C_{n-y}^i$  
其中权值的幂和组合数均可预处理。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=998244353;
int n,m,k;
ll v[105],c[35][35],p[105][35],f[105][35][35][35];
int count(ll x)
{
	int res=0;
	while(x)
	{
		x-=(-x&x);
		res++;
	}
	return res;
}//统计x二进制中1的个数
ll dfs(int x,int y,int a,int b)
{
	if(y>=n)
		return a+count(b)<=k;//1的数量不超过k
	if(x>m)
		return 0;//序列不够n个数且不合法
	if(f[x][y][a][b]!=-1)
		return f[x][y][a][b];
	ll res=0;
	for(int i=0;i<=n-y;i++)
		res=(res+dfs(x+1,y+i,a+(b+i&1),b+i>>1)*p[x][i]%mod*c[n-y][i]%mod)%mod;
	//在剩下n-y个位置中放入i个2^x
	return f[x][y][a][b]=res;//记忆化
}//枚举到2^x，已用了y个数，a个低位1，b个高位1
int main()
{
	memset(f,-1,sizeof(f));
	scanf("%d%d%d",&n,&m,&k);
	for(int i=0;i<=m;i++)
		scanf("%d",&v[i]);
	for(int i=1;i<=n;i++)
	{
		c[i][0]=c[i][i]=1;
		for(int j=1;j<i;j++)
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
	}//组合数
	for(int i=0;i<=m;i++)
	{
		p[i][0]=1;
		for(int j=1;j<=n;j++)
			p[i][j]=p[i][j-1]*v[i]%mod;
	}//v[i]^j
	printf("%lld\n",dfs(0,0,0,0));
	return 0;
}
```

---

## 作者：YGB_XU (赞：33)

考场滚动数组位运算写错零分选手来写一篇题解~
~~QwQ还我100pts~~

首先，可以把问题转化为在 $2^0$ 到 $2^m$ 这 $m+1$ 个数中选 $n$ 个数，对应序列 $a$（可以重复选），要求这些数之和的 $S$ 二进制共有不大于 $k$ 位为 $1$。求所有情况每个所有对应 $v$ 之积的和（`mod 998244353`）。这样我们可以尝试进行**计数 dp**。

在本题中，我们发现有一个比较头疼的信息是需要 $S$ 二进制中 1 的个数，这个数不能轻易维护，因为可能有许多的来自低位的进位。所以我们可以从小到大考虑 $a$ 中的元素，即从 $0$ 到 $m$ 依次考虑。这样在处理当前位时，可以同时确定更低位中一共有几个 $1$，这个信息也可以加入状态中。

此外，从更低位可能进上来许多数，所以我们还需要记录从之前位进上来了多少数。当然，由于有选数总数的限制，也需要记录之前一共选了几个数。

综上，设计 `dp[i][j][k][num][p]` 表示 $2^p$ 选择了 $i$ 个，之前一共选了 $j$ 个数，更低位向第 $p$ 位进上来 $k$，截止到第 $p$ 位时共确定有 $num$ 位为 $1$ 时所有情况累积的和，此时将向第 $p+1$ 位进 $(i+k)/2$。显然其可以更新形如 `dp[x][i+j][(i+k)/2][num+(x+(i+k)/2)%2][p+1]` 的状态，其中 $x$ 在状态合法情况下任意。

所以额外开一个数组 `f[j][k][num][p]` 来记录截止到 $p-1$ 位共选了 $j$ 个数，其将向第 $p$ 位进 $k$，已确定有 $num$ 位为 $1$ 的所有情况之和。这样可以得到两个状态转移式：

$$dp[i][j][k][num][p]=f[j][k][num-(i+k)\%2][p]\times\binom{n-j}{i}\times v[p]^i$$

$$f[i+j][(i+k)/2][num][p+1]+=dp[i][j][k][num][p]$$

最后还有一个细节：在统计答案的时候，可能会有第 $m$ 位仍向上进位的情况，需要通过一个 popcnt 得到最终总共有几位是 $1$。

整个复杂度 $O(n^4m)$

于是可得代码：（未卡常）
```cpp
#include<bits/stdc++.h>
using namespace std;

const int NR=35,MR=105,MOD=998244353;
int N,M,K;
int v[MR],powv[MR][NR],dp[NR][NR][NR][NR][MR],f[NR][NR][NR][MR];
int fac[NR],inv[NR];

inline int qpow(int x,int k){
	if(k==0) return 1;
	int tmp=qpow(x,k>>1);
	tmp=1ll*tmp*tmp%MOD;
	if(k&1) tmp=1ll*tmp*x%MOD;
	return tmp;
}

inline void init(){//预处理组合数
	fac[0]=1;
	for(int i=1;i<=N;i++) fac[i]=1ll*fac[i-1]*i%MOD;
	inv[N]=qpow(fac[N],MOD-2);
	for(int i=N-1;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%MOD;
}

inline int C(int n,int m){//n中选m
	return 1ll*fac[n]*inv[m]%MOD*inv[n-m]%MOD;
}

inline int popcnt(int x){
	int ret=0;
	while(x){
		if(x&1) ret++;
		x>>=1;
	}
	return ret;
}

int main(){
	cin>>N>>M>>K;
	init();
	for(int i=0;i<=M;i++){
		cin>>v[i];
		powv[i][0]=1;
		for(int j=1;j<=N;j++) powv[i][j]=1ll*powv[i][j-1]*v[i]%MOD;
	}
	f[0][0][0][0]=1;
	for(int p=0;p<=M;p++){
		for(int i=0;i<=N;i++){
			for(int j=0;j<=N-i;j++){//选择总数的限制
				for(int k=0;k<=N;k++){
					for(int num=0;num<=K;num++){
						if(num-(i+k)%2<0) continue;
						dp[i][j][k][num][p]=1ll*f[j][k][num-(i+k)%2][p]*powv[p][i]%MOD*C(N-j,i)%MOD;
						f[i+j][(i+k)/2][num][p+1]+=dp[i][j][k][num][p];
						f[i+j][(i+k)/2][num][p+1]%=MOD;
					}
				}
			}
		}
	}
	int ans=0;
	for(int i=0;i<=N;i++){
		for(int k=0;k<=N;k++){
			for(int num=0;num<=K;num++){
				if(num+popcnt((i+k)/2)<=K) ans=(ans+dp[i][N-i][k][num][M])%MOD;
			}
		}
	}
	cout<<ans<<'\n';
	return 0;
}
```

在这里提供一些优化方式：

- 快读快写优化时间
- $m$ 那一维可以滚掉
- 较为快速地计算组合数（虽然这个本身复杂度就极小）

---

## 作者：Watware (赞：15)

# 废话
蒟蒻第一次考 $noip$ orz，只会这一题，实在是太菜了

# 题解
考虑一个状压 $dp$ ，注意到如果整个状态都存到一维会空间不够，而状态并不会影响到转移过程，在转移过程中只会在被小于的项更新，且只会在最后的统计答案中使用，于是想到可以边转移边 $popcnt$，另外由于数据较小，可以不用写 $O(log n)$ 的 $popcnt$ ,朴素算法即可（其实是我不会）

定义 $dp[i][j][k][l]$ 为考虑到数列 $a$ 中值小于等于 $i$ 的项；其中还有 $j$ 个的值没有确定 $/$ 值大于 $i$ ；$S$的二进制展开从 $2^i$ 位开始为 $k$，前面的二进制位有 $l$ 个1

转移很显然，考虑从前往后转移 $dp[i+1][j-u][(k>>1)+u][l+(k\&1)]+=dp[i][j][k][l]\cdot C_j^u\cdot v_{i+1}^u$

其中 $0\le i<m,0\le j,k,l<n,$ ，复杂度 $O(n^3km)$ 

丑陋代码：

```
#include <bits/stdc++.h>
using namespace std;

const long long p = 998244353;

long long dp[120][50][50][120], v[120], c[50][50];
int n, m, ik;

inline int cnt(int x)
{
	int res = 0;
	while (x)
	{
		if (x & 1)
			res++;
		x >>= 1;
	}
	return res;
}
long long qpow(long long x, int y)
{
	long long res = 1;
	while (y)
	{
		if (y & 1)
			res = res * x % p;
		x = x * x % p;
		y >>= 1;
	}
	return res;
}

int main()
{
	freopen("sequence.in", "r", stdin);
	freopen("sequence.out", "w", stdout);
	for (int i = 0; i < 50; i++)
		c[i][0] = c[i][i] = 1;
	for (int i = 1; i < 50; i++)
		for (int j = 1; j < i; j++)
			c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % p;
	scanf("%d%d%d", &n, &m, &ik);
	for (int i = 0; i <= m; i++)
		scanf("%lld", v + i);
	for (int i = 0; i <= n; i++)
		dp[0][i][n - i][0] = c[n][i] * qpow(v[0], n - i) % p;
	for (int i = 0; i < m; i++)
		for (int j = 0; j <= n; j++)
			for (int k = 0; k <= n; k++)
				for (int l = 0; l <= ik; l++)
					for (int u = 0; u <= j; u++)
						dp[i + 1][j - u][(k >> 1) + u][l + (k & 1)] = (dp[i + 1][j - u][(k >> 1) + u][l + (k & 1)] + dp[i][j][k][l] * c[j][u] % p * qpow(v[i + 1], u) % p) % p;
	long long ans = 0;
	for (int k = 0; k <= n; k++)
		for (int l = 0; l <= ik; l++)
			if (cnt(k) + l <= ik)
				ans = (ans + dp[m][0][k][l]) % p;
	printf("%lld", ans % p);
	return 0;
}
```

# 后记
考场上 $dp$ 数组还开大了……，开到了 $dp[120][50][50][120]$ ，踩线没有超时间复杂度，差点又惨遭爆0

---

## 作者：比利♂海灵顿 (赞：15)

# NOIP2021-数列

显然是个 DP 题，这个题 $O(n^3mk)$ 做法是不是垫底了啊。

## 状态设计

首先发现这个序列的元素的顺序不会影响权值和 $S$ 值，所以我们可以使序列为空，然后将值填入序列，计算对权值和 $S$ 的贡献，对这个过程进行 DP。

因为对于等于 $i - 1$ 的 $a$，它可以影响 $S$ 的第 $i$ 位及其后面的位，所以我们从小往大讨论 $a$ 的值。以它作为阶段从小往大考虑，可以避免后效性。

因为确定了小于 $i$ 的所有 $a$ 后，可以确定 $S$ 前 $i$ 位的情况，所以我们对于填完小于 $i$ 的值的状态只需要记录 $S$ 前 $i$ 位的 $1$ 的数量，可以忽略具体哪些位是 $1$。

当然，小于 $i$ 的 $a$ 对第 $i$ 位后面的位置是有影响的，所以我们记录一维状态表示当前的 $\lfloor \frac{S}{2^i} \rfloor$。

现在还有一个状态被忽略了，也就是当前序列已经有多少位置不是空位，这个状态让我们知道有多少空位可以赋值。

设计 $f_{i, j, k, l}$ 表示已经填了小于 $i$ 的所有 $a$ 值，总计 $j$ 个，$S$ 的前 $i$ 位有 $k$ 个 $1$，$\lfloor \frac{S}{2^i} \rfloor = l$。

## 转移

先写方程:

$$
f_{i, j, k, \lfloor\frac{x + y}2\rfloor} = \sum \binom{n - j + x}{x} f_{i - 1, j - x, k - (x + y) \bmod 2, y} \cdot a^{x}
$$

可以发现这里目标状态只枚举了 $i$，$j$，$k$ 三维，剩下一维是由转移所枚举的 $x$，$y$ 决定的。我不知道如何定义每个状态的转移复杂度，但是总复杂度一定是枚举的这五个变量的范围之积。

接下来解释这个转移，$x$ 枚举的是数字 $i$ 选择的数量，$y$ 枚举的是起始状态进位到 $i$ 的数字，所以可以当作是在 $x$ 的基础上，额外选择了 $y$ 个 $i$，但是不花费空位，也不消耗权值，仅对 $S$ 产生影响。

这样前面的二项式系数的意义就很显然了，我们起始状态有 $n - j + x$ 个空位，我们从中选择 $x$ 个填上 $i$ 的方案数就是 $\binom{n - j + x}{x}$。

$a^x$ 表示原来每个方案的基础上加 $x$ 个 $i$，都会使方案的权值乘 $a^x$。

$\lfloor\frac{x + y}2\rfloor$ 表示的是本次填入 $i - 1$ 对 $S$ 贡献的 $x2^{i - 1}$ 和原来已经存在的 $y2^{i - 1}$，它们的和除以 $2^i$ 的结果，也就是 $\lfloor \frac{S}{2^i} \rfloor$。

$(x + y) \And 1$ 的意义是填入和合并得到的 $i - 1$，对 $S$ 中前 $i$ 位 $1$ 的数量的贡献，显然，如果 $x + y$ 是奇数，就会使得 $S$ 的第 $i$ 位是 $1$。

## 代码

> 代码是考场代码增删注释得到的，所以码风保守。

为了防止变量名冲突，上面提到的 $x$，$y$ 在代码中分别写成 $jj$ 和 $ll$，题目中的 $k$ 用 $t$ 来代替。

为了防止数组越界，$f_{i}$ 表示第 $i - 1$ 个阶段的 DP 值，也就是填了数字 $i - 1$ 的 DP 值。因此需要在输入时把 $m$ 变成 $m + 1$。

```cpp
const unsigned long long Mod(998244353);
unsigned long long Ans(0), C[35][35], a[105][35];
unsigned f[105][35][35][35], Pop[105];
unsigned n, m, t;
unsigned A, B;
unsigned Cnt(0);
signed main() {
  n = RD(), m = RD() + 1, t = RD();
  for (unsigned i(1); i <= m; ++i) {
    a[i][0] = 1, a[i][1] = RD();
    for (unsigned j(2); j <= n; ++j)
      a[i][j] = a[i][j - 1] * a[i][1] % Mod;//预处理每个值有不同个数的权值 (也就是预处理 a 的幂)
  }
  for (unsigned i(1); i <= 102; ++i) Pop[i] = Pop[i >> 1] + (i & 1);//预处理 Popcount
  C[0][0] = 1;
  for (unsigned i(1); i <= n; ++i) {
    C[i][0] = 1;
    for (unsigned j(1); j <= n; ++j) {
      C[i][j] = C[i - 1][j] + C[i - 1][j - 1];//预处理二项式系数
      if(C[i][j] >= Mod) C[i][j] -= Mod;
    }
  }
  for (unsigned i(0); i <= m; ++i) f[i][0][0][0] = 1;//初始化
  for (unsigned i(1); i <= m; ++i) {
    for (unsigned j(1); j <= n; ++j) {
      for (unsigned k(0); k <= t; ++k) {
        for (unsigned jj(0); jj <= j; ++jj) {
          for (unsigned ll(0); ll <= n; ++ll) {
            if((ll + jj) & 1) {
              if(!k) continue;//防止越界
              f[i][j][k][(ll + jj) >> 1] = ((f[i][j][k][(ll + jj) >> 1] + (f[i - 1][j - jj][k - 1][ll] * C[n - j + jj][jj] % Mod) * a[i][jj]) % Mod);
            } else {
              f[i][j][k][(ll + jj) >> 1] = ((f[i][j][k][(ll + jj) >> 1] + (f[i - 1][j - jj][k][ll] * C[n - j + jj][jj] % Mod) * a[i][jj]) % Mod);
            }
          }
        }
      }
    } 
  }
  for (unsigned i(0); i <= t; ++i) {
    for (unsigned j(0); j <= n; ++j) {
      if(Pop[j] + i <= t) {//第 n 位后面的 1 的数量和前 n 位的 1 的数量和
        Ans += f[m][n][i][j];//统计答案
        if(Ans >= Mod) Ans -= Mod;
      }
    }
  }
  printf("%u\n", Ans);
  return 0;
}
```

---

## 作者：serene_analysis (赞：14)

原来考场上推了两个半小时的 DP 是对的，只是反推细节太多，回到家用正推十分钟切。差临门一脚，还是水平不够啊。

---

题意已经很清楚了，结合样例解释、答案取模、极小的数据范围，可以猜到这题和 DP 脱不了干系。

通常而言，对于这种含 $k$ 的形似 DP 的题目，可以尝试先去掉题面中的限制寻找思路。但因为部分分没有给这一档，并且似乎去掉限制后题目性质有了较大变化，故先不考虑去掉 $k$ 的限制。

稍加思考，我们发现一个合法序列的权值只和这个序列中每个数的**出现次数**有关，而和具体顺序无关，因此我们可以将序列排序，乘适当的组合系数后即可得到本质相同的序列的权值和。（这里的本质相同即指排序后各元素对应相同）

观察到题目中给的限制和二进制有关，联想到二进制的性质。如果我们按照**下标**从小到大选，那么先选的数可能进位影响到后选的数，但后选的数绝不可能影响到先选的数。也就是说，当第 $0$ 个数到第 $i$ 个数选的次数都已确定，那么当前序列的 $S$ 前 $i+1$ 位随之固定。这似乎体现了**无后效性**？与此同时，观察到先选的数对后选的数影响极为有限，能否把它也加入 DP 状态中呢？

结合以上几点，一个模糊的 DP 思路浮出水面。设 $tot_{i,j,l,T}$ 表示权值和，第一维 $i$ 记录当前选到了第 $i$ 个数，第二维 $j$ 记录从第 $0$ 个数到第 $i$ 个数总共选了 $j$ **次**，第三维 $l$ 记录直到现在 $S$ 的二进制表示下最低 $i+1$ 位出现的 $1$ 的个数，第四位 $T$ 记录直到现在 $S$ 的二进制表示下第 $i+2$ 位及以上的数表示的十进制数。

但是问题来了：如何转移？考场上我枚举的是 $i$，加入 $i-1$ 的贡献，但是写起来把情况考虑错了，导致爆零。一种更好的写法是枚举 $i$，计算其对 $i+1$ 的贡献。

那么枚举第 $i+1$ 个数选的次数 $t$，对于转移的答案接受方，其第一维必定是 $i+1$，第二维是 $j+t$。发现往右移动一位会导致 $T$ 的最低位丢失并被统计入 $l$，设 $T+t$ 的二进制最低位为 $p$，那么第三维是 $l+p$，第四维为 $\biggl \lfloor \dfrac{T+t}{2} \biggr \rfloor$。考虑权值的转移，由于第 $i+1$ 个数选了 $t$ 次，要乘一个 $(val_{i+1})^t$；由于这 $t$ 个 $i+1$ 要被分配到剩下的长为 $n-j$ 的序列中，那么还要再乘一个 $C(n-j,t)$ 计算顺序。

统计最终答案时直接枚举最终 $S$ 的二进制表示下 $1$ 的个数，再枚举最终的  $T$，将符合条件的加入答案即可。

那么这题就做完了，时间复杂度 $\Theta(mn^4)$。

具体可以见代码，个人习惯将 $n,m$ 交换，循环变量也略有不同。

```cpp
#include<algorithm>
#include<cstdio>
#include<vector>
const int maxn=1e2+5;
const int maxm=3e1+5;
const int mod=998244353;
int n,m,k;
int val[maxn];
int tot[maxn][maxm][maxm][maxm];
int po[maxn][maxm];
int lowbit(int x){return x&-x;}
int inv[maxn],fact[maxn],finv[maxn];
void init(){
	inv[0]=inv[1]=fact[0]=fact[1]=finv[0]=finv[1]=1;
	for(int i=2;i<=maxm-2;i++){
		inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
		fact[i]=1ll*fact[i-1]*i%mod;
		finv[i]=1ll*finv[i-1]*inv[i]%mod;
	}
	return;
}
int bigc(int x,int y){return 1ll*fact[x]*finv[y]%mod*finv[x-y]%mod;}
signed main(){
//	freopen("sequence.in","r",stdin);
//	freopen("sequence.out","w",stdout);
	init();
	scanf("%d%d%d",&m,&n,&k);
	for(int i=0;i<=n;i++){
		scanf("%d",val+i);
		po[i][0]=1;
		for(int j=1;j<=m;j++)po[i][j]=1ll*po[i][j-1]*val[i]%mod;
	}
	for(int j=0;j<=m;j++)tot[0][j][j&1][(j>>1)]=1ll*po[0][j]*bigc(m,j)%mod;
	for(int i=0;i<=n-1;i++)
		for(int j=0;j<=m;j++)
			for(int l=0;l<=m;l++)
				for(int nS=0;nS<=m;nS++)
					for(int nc=0;nc<=m-j;nc++){
						(tot[i+1][j+nc][l+((nc+nS)&1)][(nS+nc)/2]+=
							1ll*tot[i][j][l][nS]*bigc(m-j,nc)%mod*po[i+1][nc]%mod)%=mod;
//						if(1ll*tot[i][j][l][nS]*bigc(m-j,nc)%mod*po[i+1][nc]%mod)
//							printf("i=%d,j=%d,l=%d,nS=%d,nc=%d,tot[%d][%d][%d][%d]+=%lld\n",
//								i,j,l,nS,nc,i+1,j+nc,l+((nc+nS)&1),(nS+nc)/2,
//								1ll*tot[i][j][l][nS]*bigc(m-j,nc)%mod*po[i+1][nc]%mod);
					}
	int res=0;
	for(int nk=1;nk<=k;nk++){
		for(int nS=0;nS<=m;nS++){
			int ts=nS;
			int cou=0;
			while(lowbit(ts))cou++,ts-=lowbit(ts);
			if(nk<cou)continue;
//			printf("tot[n][m][%d][%d]=%d\n",nk-cou,nS,tot[n][m][nk-cou][nS]);
			(res+=tot[n][m][nk-cou][nS])%=mod;
		}
	}
	printf("%d",res);
	return 0;
}
/*
tot[i][j][l][S] means the total of:
in first i+1 elements, choose j times, have l '1' before, the influence is S.
Totally choose m, the len of the line is n.
5 1 1
2 1
*/
/*
8 9 4
934258593 150407625 187068439 162292791 219945760 512449588 803393963 983648121 484675481 412407699
*/
```

感谢您的阅读！

---

## 作者：冷笑叹秋萧 (赞：10)

## 题意
题面非常清楚，没有什么背景，略。
## Solution
观察题目，我们发现 $a[i]$ 的顺序不同对答案的贡献是相同的，所以我们考虑顺序放置 $a[i]$，然后利用组合数求出全部方案，于是这题就可以进行 DP。

以下我们规定关于位数的全是在二进制下讨论，二进制下最低位是第 0 位。

设 $f[i][j][k][l]$ 表示已经填完了前 $i$ 个数，当前进位进到的最高位是第 $j$ 位（也就是说之前的 $a[i]$ 最大填到 $j-1$ ，即整数 $S$ 最高在第 $j-1$ 位填了 1）,$a[i]$ 中填了 $k$ 个 $j$，已经有 $l$ 个位是1的合法序列的权值总贡献。

考虑转移，我们可以用已知的$f[i][j][k][l]$向其他状态转移，我们假设在 $a[i]$ 中填 $num$ 个 $j$，那么转移方程如下：

$f[i+num][j+1][(k+num)/2][l+(k+num)\bmod 2]+=f[i][j][k][l]\cdot v_{j}^{num}\cdot C_{i+num}^{num}$

其中 $i+num$ 表示填了这 $num$ 个数后一共填完了多少个 $a[i]$，$j+1$ 表示往下进了一位（就算没有进位也可以默认进了位，因为这是没有影响的），$(k+num)/2$ 表示向下一位进了几个1，$(k+num)\bmod 2$ 就是判断这个位的数是 1 还是 0，然后再乘上一个组合数。

最后答案即为 $\sum {f[n][m+1][k][l]} (count(k)+l≤K)$，其中 $count(k)$ 表示数字 $k$ 在二进制下有多少个位为 1，$K$ 是题目中输入的 $k$（其实就是处理最高位的进位）。

## CODE

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 35, M = 105;
const LL MO = 998244353;
int n, m, K;
LL v[M][N], f[N][M][N][N], C[N][N], ans;
int lowbit(int x) {
	return x & (-x);
}
int count(int x) {
	LL res = 0;
	for (; x; x -= lowbit(x)) ++res;
	return res;
}//统计一个数在二进制下有多少位是1
int main() {
	freopen("sequence.in", "r", stdin); freopen("sequence.out", "w", stdout);//文件输入输出
	C[0][0] = 1;
	for (int i = 1; i < N; ++i) {
		C[i][0] = 1;
		for (int j = 1; j <= i; ++j)
			C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MO;
	}//预处理组合数
	scanf("%d%d%d", &n, &m, &K);
	for (int i = 0; i <= m; ++i) {
		LL vv; scanf("%lld", &vv); v[i][0] = 1;
		for (int j = 1; j <= n; ++j) v[i][j] = v[i][j - 1] * vv % MO;
	}//预处理v[i]的幂
	f[0][0][0][0] = 1;
	for (int i = 0; i <= n; ++i)
		for (int j = 0; j <= m; ++j)
			for (int k = 0; k <= i / 2; ++k)
				for (int l = 0; l <= K; ++l)
					if (f[i][j][k][l])
						for (int num = 0; num <= n - i; ++num)
							f[i + num][j + 1][k + num >> 1][l + (k + num & 1)] = (f[i + num][j + 1][k + num >> 1][l + (k + num & 1)] + f[i][j][k][l] * v[j][num] % MO * C[i + num][num] % MO) % MO;//转移
	for (int k = 0; k <= n; ++k)
		for (int l = 0; l <= K; ++l)
			if (count(k) + l <= K) ans = (ans + f[n][m + 1][k][l]) % MO;//统计答案
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：2020kanade (赞：8)

人话版题意：给定一个长度为 $m$ 的数列（下标从 $0$ 起），让你选 $m$个数组成一个权值为所有选取的值的积的序列，这个序列“合法”当且仅当......（参照原题，把 $a_i$ 换成第 $i$ 个选择的数的下标），求所有合法序列的权值和对一个大质数取模的结果。

一般长这样的计数题不是数学就是DP，这道题显然是个DP状物。

什么？数位DP？那是啥！？反正笔者不会，就整了个比较制杖的写法。

以下是一些重要的结论与转化：

1. $n$ 个位置，有 $m$ 个待选数字，可以重复选。

2. 关于原题中的约束：把 $S$ 摆成二进制，很容易发现在 $S$ 的组成中，每选一个数，其下标对应的二进制位（从右向左为高，最低为 $0$ 位）上就会 $+1$。


由第一点，总结出一些特点：数字可以重复选，因此可以枚举某个数字选多少个，而每一个数字和选择该数字的个数（可以为 $0$ ，代表不选）可以看成一类物品以及这类物品中具体的某一个，符合分组背包的特点。因此，考虑套分组背包的转移，状态下设剩余空间和决策第多少种，转移时枚举某一种选哪一个，对应到这道题上就是当前数字选多少个。

由第二点，我们可以考虑对 $S$ 进行状压来进行二进制相关处理，但最坏情况下 $S$ 会很长，并且其中很大的一部分都不再进行修改了。因此，我们考虑其他的一些状态表示。

3. 每次选数最坏情况下只会影响包括这一位上的二进制的 $5$ 位。

至于为什么......如果对状压熟悉的话，很显然。如果看不出来的话，$2^5=32\gt 30$ ，之后请自行思考罢。

因此，对于二进制状态的表示，我们可以改成两维：一维代表当前决策的那一个数对应的二进制位置和前面的 $4$ 位（共 $5$ 位）的二进制状压，另一个表示其他信息——注意到这道题关心的是二进制表示中 $1$ 的个数，并且如果是背包的顺序转移，已经决策过的二进制低位不会再发生变化，因此这一维表示当前二进制位置的所有比它低的位中 $1$ 的个数，显然这个数不会超过 $n$ 。

因此，状态出来了：设 $dp_{i,j,k,l}$ 为当前决策的是第 $i$ 个数，剩余空间（还剩多少个位置没选）为 $j$ ， $k$ 与 $l$ 分别是前面说的部分状压和低位 $1$ 的个数时所有序列（不一定合法）的权值和。这里采用发送型转移，因为当前状态的前继难以枚举，但后继状态显然：枚举下一个数字选的个数 $s$ ，则当前状态可以转移到 $dp_{i+1,j-s,(k>>1)+s,(k\&1)+l}$ 。边界为 $i\in[0,m-1]$ (因为是发送型) , $j\in[0,n],s\le j$ （剩余空间不能为负） $ ,k \in [0,n] ,l \in [0,n]$ 。 

继续考虑转移：选择 $s$ 个当前数，因此要乘上 $v_{i+1}^s$ ，同时注意：我们设的状态是权值和，除了转移不能直接写等号之外，当前元素的所有排列都是等价的，因此要乘以所有排列的数量，这其实是一个组合问题（因为只考虑选没选），选了 $s$ 个的贡献为 $C_{j}^s$ （如果不懂，当前剩余空间为 $j$ ，要丢进去 $s$     个，相当于从 $j$ 个位置里选 $s$ 个位置，这也是为什么 $j$ 定义为“剩余空间”而不是“已用空间”，如果定义是后者则此处是 $C_{j+s}^s$ ，和上式等价）。

最终得到的总的DP方程就是把上面几个拼起来，计数的时候按照 $k$ 与 $l$ 可以直接推出 $popcount(S)$ （提示：需要实现$popcount()$） ，累加合法的即可。

初始状态请自行思考（提示：发送型转移的第一次转移依赖哪些状态）。时间复杂度 $\Theta (n^4m)$ ，注意到DP转移时如果 $l$ 超过了限制其后继状态一定不合法，无需枚举，可以剪枝剪到 $\Theta(n^3mk)$ 。

别忘了取模和 long long ，还有预处理组合数以及快速幂。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL md=998244353;
const int N=37,M=101;
int n,m,_k;
LL dp[M+2][N][N][N],ct[N][M+2][N][N],C[N<<1][N<<1],v[M+2],ans;
//dp[i+1][j-s][(k>>1)+s][(k&1)+l]+=dp[i][j][k][l]*v[i+1]^s*C[j][s]
inline void init_C(int _n)
{
	C[0][0]=1;
	for(int i=1;i<=_n+1;++i) for(int j=0;j<=i;++j) C[i][j]=((j)?(C[i-1][j]+C[i-1][j-1]+md)%md:1)%md;
}
inline int pc(int __k)
{
	int ans=0;while(__k) {if(__k&1) ++ans;__k>>=1;} return ans;
}
inline LL QP(LL a,LL b)
{
    LL ans=1;
    while(b) {if(b&1) ans=ans*a%md;a=a*a%md,b>>=1;}
    return ans%md;
}
inline LL qread()
{
	LL a=0,f=1;char ch=getchar();
	while(ch<'0' || ch>'9') {if(ch=='-') f*=-1;ch=getchar();}
	while(ch>='0' && ch<='9') {a=a*10+(ch-'0');ch=getchar();}
	return a*f;
}
inline void qwrite(LL x)
{
	LL cnt=0;char w[128];
	if(x<0) x*=-1,putchar('-');
	while(x) {w[cnt++]=(x%10)+'0';x/=10;}
	while(cnt--) putchar(w[cnt]);
}
int main()
{
	n=qread(),m=qread(),_k=qread();
	for(int i=0;i<=m;++i) v[i]=qread();
	init_C(n);
	for(int i=0;i<=n;++i) dp[0][n-i][i][0]=QP(v[0],i)*C[n][i];
	for(int i=0;i<m;++i)for(int j=0;j<=n;++j) for(int k=0;k<=n;++k) for(int l=0;l<=_k;++l)
		for(int s=0;s<=j;++s) dp[i+1][j-s][(k>>1)+s][(k&1)+l]=(dp[i+1][j-s][(k>>1)+s][(k&1)+l]+dp[i][j][k][l]%md*QP(v[i+1],s)%md*C[j][s]%md)%md;
	for(int k=0;k<=n;++k) for(int l=0;l<=_k;++l) if(pc(k)+l<=_k) ans=(ans+dp[m][0][k][l])%md;
	qwrite(ans);if(!ans) putchar(48);
	return 0;
}
```


---

## 作者：tommymio (赞：8)

### 题意

给出 $v_0\dots v_m$，定义一个值 $\in[0,m]$ 的序列 $\{a_n\}$，其权值为 $\prod v_{a_i}$

求满足 $S=\sum 2^{a_i}$ 二进制表示不超过 $k$ 个 $1$ 的所有序列权值和。

其中 $n\leq 30,m\leq 100,k\leq n$。

### 解法

首先，你可以想到多重排列，给出值 $i$ 出现了 $k_i$ 次，共有 $\frac{n!}{\prod k_i}$ 个序列与之对应。

注意到序列的权值和序列中每个元素的出现顺序无关，所以对于这样的一些序列其权值和可以写作
$$
\frac{n!}{\prod k_i!}\times v_i^{k_i}
$$
拆一下每项的贡献，就可以 $\text{DP}$

$$
n!\times \prod \frac{v_i^{k_i}}{k_i!}
$$

可以想到设 $f[i,j,k]$ 为已经考虑了值 $0\sim i$，当前的 $S=j$，分配了 $k$ 个位置的序列权值和除以 $n!$

$$
f[i,j,k]=\sum_x f[i-1,j-x\times 2^i,k-x]\times \frac{v_i^x}{x!}
$$

然后你发现这样一个事实，$S$ 可以被写成 $S=k_i\times 2^i$，这个时候 $S$ 相当于被很多个二进制数依次错位相加，对于已经考虑了值 $0\sim i$ 而言，二进制数 $S$ 的 $0\sim i-1$ 位已经不会再改变了，可以简单记录个数。而对于 $S$ 的 $i\sim m$ 位，直接记录。这个时候我们又发现，$S$ 错位加上的二进制数 $\in [0,n]$，其实只需记录下 $S$ 的 $i\sim i+4$ 位即可。

重新设计状态，设 $f[i,j,k,l]$ 为已经考虑了值 $0\sim i$，当前的 $S$ 的 $i\sim i+4$ 位二进制表示为 $j$，$S$ 的 $0\sim i-1$ 位中有 $k$ 个 $1$，已经分配了 $l$ 个位置的序列权值和除以 $n!$，由于填表法不好转移，这里我们使用刷表法
$$
f[i+1,\left\lfloor\frac{j}{2}\right\rfloor+x,k+(j\&1),l+x]=f[i,j,k,l]\times \frac{v_{i+1}^x}{x!}
$$
当然我考试的时候也写了填表法，左移然后枚举之前丢失的那一位是 $0/1$ 即可。

时间复杂度为 $O(n^4m)$。可以成功通过。

```cpp
//Debug 2h+, then I find I code the module number in a wrong way.
//Instead of 998244353,it's 99824353
#include<cstdio>
typedef long long ll;
const int mod=998244353;
int qwq[135];
ll fac[35],inv[35],v[105];
int f[105][35][35][35];
inline int read() {
	int x=0,f=1;char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
inline ll pow(ll x,ll p) {
	ll res=1;
	for(;p;p>>=1) {
		if(p&1) res=res*1ll*x%mod;
		x=x*1ll*x%mod;
	}
	return res;
}
int main() {
	int n=read(),m=read(),K=read();
	for(int i=1;i<=m+1;++i) v[i]=read();
	inv[0]=fac[0]=1;
	for(int i=1;i<=n;++i) inv[i]=pow(fac[i]=fac[i-1]*1ll*i%mod,mod-2);
	for(int i=0;i<=127;++i) {
		int tmp=0;
		for(int j=i;j;j-=j&(-j)) ++tmp;
		qwq[i]=tmp;
	}
	f[0][0][0][0]=1;
	for(int i=0;i<=m;++i) {
		for(int j=0;j<=n;++j) {
			for(int k=0;k<=K;++k) {
				for(int l=0;l<=n;++l) {
					for(int tt=0;l+tt<=n;++tt) {
						int nxt=(j>>1)+tt;
						f[i+1][nxt][k+(j&1)][l+tt]=(f[i+1][nxt][k+(j&1)][l+tt]+(f[i][j][k][l]*1ll*pow(v[i+1],tt)%mod*1ll*inv[tt]%mod))%mod;
					}
				}
			}
		}
	}
	ll ans=0;
	for(int j=0;j<=n;++j) {
		for(int k=0;k<=K;++k) {
			if(qwq[j]+k>K) continue;
			ans+=f[m+1][j][k][n];
			if(ans>=mod) ans-=mod;
		}
	}
	// printf("%lld\n",fac[n]);
	printf("%lld\n",ans*1ll*fac[n]%mod);
	return 0;
}
```

---

## 作者：mofianger (赞：7)

转化一下题意：

对于每一个合法的 $a$ 序列，可以看作对于一个二进制数在第 $a_x$ 位填入 $1$ ，要求最终的数 $1$ 的个数不超过 $k$ 。

考虑dp。

设计状态 $f[i][j][p][q]$ 表示前 $i$ 位填入了 $j$ 个 $1$ ，第 $i+1$ 位堆积了 $p$ 个 $1$ ，前 $i$ 位二进制下共有 $q$ 个$1$ 的答案。

转移如下：

$f[i][j][p][q]=f[i-1][j-d][a][b]\times val_i^d\times\binom{n-j+d}{d}$

$d$ 表示第 $i$ 位填入 $1$ 的个数。

$val_i^d$ 表示 $d$ 个 $a_x$ 取值为 $i$ 带来的贡献。

$\binom{n-j+d}{d}$ 表示 $a$ 序列的组合情况。

$a b$ 满足以下等式:

$\lfloor\frac{a+d}{2}\rfloor=p$

$b+[a+d \equiv1(mod\space 2)]=q$

共有两种情况，分别转移即可。

答案统计：

$ans = \sum f[m][n][i][0-(k-down(i))]$

其中 $down(i)$ 表示 $i$ 二进制表示下 $1$ 的个数。

时间复杂度 $O(n^4m)$ 可以通过本题。

```cpp
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

template<typename T>

inline void read(T &x)
{
	x = 0;
	bool tag = 0;
	char c = getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-') tag = 1;
		else tag = 0;
		c = getchar();
	}
	while(c>='0'&&c<='9') x = (x<<1) + (x<<3) + (c^48), c = getchar();
	if(tag) x = -x;
}

template<typename T>

void write(T x)
{
	if(x<0) putchar('-'), x = -x;
	if(x>9) write(x/10);
	putchar('0'+x%10);
}

const int N = 32, M = 102;

const int MOD = 998244353;

ll f[M][N][N][N];

ll v[M];

ll powv[M][N], c[N][N];

int n,m,k;

void pre()
{
	for(int i = 0;i<=m;i++)
	{
		powv[i][0] = 1;
		for(int j = 1;j<=n;j++)
		{
			powv[i][j] = powv[i][j-1] * v[i] % MOD;
		}
	}
	
	for(int i = 0;i<=n;i++)
	{
		c[i][0] = 1;
		for(int j = 1;j<=i;j++)
		{
			c[i][j] = (c[i-1][j-1] + c[i-1][j]) % MOD;
		}
	}
	
}

int down(int x) 
{
	int cnt = 0;
	while(x)
	{
		if(x&1) cnt++;
		x >>= 1;
	}
	return cnt;
}

int main()
{
	freopen("sequence.in","r",stdin);
	freopen("sequence.out","w",stdout);
	read(n), read(m), read(k);
	for(int i = 0;i<=m;i++) read(v[i]);
	pre();
	for(int j = 0;j<=n;j++)
	{
		f[0][j][j/2][j&1] = powv[0][j] * c[n][j] % MOD;
	}
	for(int i = 1;i<=m;i++)
	{
		for(int j = 0;j<=n;j++)
		{
			for(int p = 0;p<=j/2;p++)
			{
				for(int q = 0;q<=j;q++)
				{
					for(int d = 0;d<=j;d++)
					{
						int a = 2*p - d;
						int b = q - (a+d)%2;
						if(a>=0&&b>=0)	f[i][j][p][q] += f[i-1][j-d][a][b] * powv[i][d] % MOD * c[n-j+d][d] % MOD;
						f[i][j][p][q] %= MOD;
						a++;
						b = q - (a+d)%2;
						if(a>=0&&b>=0)	f[i][j][p][q] += f[i-1][j-d][a][b] * powv[i][d] % MOD * c[n-j+d][d] % MOD;
						f[i][j][p][q] %= MOD;
					}
				}
			}
		}
	}
	int ans = 0;
	for(int i = 0;i<=n;i++)
	{
		for(int j = k-down(i);j>=0;j--)
		{
			ans += f[m][n][i][j], ans %= MOD;
		}
	}
	write(ans);
	putchar('\n');
	fclose(stdin);
	fclose(stdout);
	return 0;
}

```



---

## 作者：FutaRimeWoawaSete (赞：5)

尝试一雪前耻，然后第一发胡了个要算可重集的问问问反正就又要滚两个问问问的前缀和的问问问东西。

仅使用了 1.5h 就一雪前耻，这是好事，放在 NOIP 还是打不到 T4 暴力，实在是太好了。

半年前我在 NOIP 折戟沉沙，半年后我再次在 NOIP 折戟沉沙。

------------------------------------------------------------

不难发现可以如果将序列的元素固定不难使用固定从小到大排序后放数数颜色段的方法 dp，然后就得边在状态里面设一个可重集排列要算的东西还要滚两个前缀和，比较复杂。

发现是顺序相关转化做复杂了，直接用组合数算位置的选择情况就可以正常 dp 了。

为了方便表达，题目中的 $k$ 采用 $K$ 表示。

具体的可以设 $dp_{i,j,k,l}$ 表示值域上前 $i$ 位已经确定，选了 $j$ 个位置，此时不算上向后进位的 $1$ 已经有了 $k$ 个 $1$，此时向后面的位一共进了 $l$ 个 $1$ 时的合法序列总权值和。

考虑转移的时候我们只需要枚举第 $i + 1$ 位被选择的个数即可转移。

转移方程，枚举被选择的个数 $p$，$delta$ 表示当前位是否是 $1$：

$dp_{i + 1,j + p,k+delta,\lfloor\frac{l+p}{2}\rfloor} \leftarrow dp_{i,j,k,l} \times C_{n - j}^p \times (a_{i + 1}) ^ p$

相当于是在剩下没被选择的位置里面的方案数再乘上选上这些数的贡献即时新的合法序列总权值和。

最后将符合题意的 dp 状态加入答案。

时间复杂度 $O(n ^ 4 m)$。

```cpp
/*
考虑 dp_{i,j,k,l} 表示现在选到了值域上的第 i 个数，一共选了 j 个位置，一共有 k 个 1（没算 l 的贡献），当前这一位被进了 l 个 1时的和
然后 dp 的时候用组合数辅助，需要枚举当前选了多少数……
*/
#include "bits/stdc++.h"
using namespace std;
#define int long long
#define bpt __builtin_popcount 
const int Len = 105 , mod = 998244353;
int n,m,K,a[Len],C[Len][Len];
int mul[Len][35];
int dp[105][35][35][35];
signed main()
{
	scanf("%lld %lld %lld",&n,&m,&K);
	for(int i = 1 ; i <= m + 2 ; i ++) 
	{
		if(i <= m + 1) scanf("%lld",&a[i]);
		else a[i] = 1;
		mul[i][0] = 1;
		for(int j = 1 ; j <= n ; j ++) mul[i][j] = mul[i][j - 1] * a[i] % mod;
	}
	C[0][0] = C[1][0] = C[1][1] = 1;
	for(int i = 2 ; i <= n ; i ++)
	{
		C[i][0] = 1;	
		for(int j = 1 ; j <= i ; j ++) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
	}
	dp[0][0][0][0] = 1;
	for(int i = 0 ; i <= m + 1 ; i ++)
	{
		for(int j = 0 ; j <= n ; j ++)
			for(int k = 0 ; k <= n ; k ++) 
				for(int l = 0 ; l <= n ; l ++)
				{
					//printf("%lld %lld %lld %lld %lld\n",i,j,k,l,dp[i][j][k][l]);	
					for(int p = 0 ; p <= n - j ; p ++)//枚举选的几个数 
					{
						int delta = (l + p) % 2;
						dp[i + 1][j + p][k + delta][(l + p) / 2] += dp[i][j][k][l] * C[n - j][p] % mod * mul[i + 1][p] % mod;
						dp[i + 1][j + p][k + delta][(l + p) / 2] %= mod;
					}
				}
	}
	//从 dp_m + 2,n,?,? get 答案
	long long ans = 0;
	for(int i = 0 ; i <= K ; i ++)
		for(int p = 0 ; p <= n ; p ++) if(bpt(p) + i <= K) ans = (ans + dp[m + 1][n][i][p]) % mod;
	printf("%lld\n",ans);		 
	return 0;
}
```

---

## 作者：Mistybranch (赞：4)

[传送门](https://www.luogu.com.cn/problem/P7961)

题目大概意思在题目描述里已经很清晰了，在这里不做过多解释。

首先一开始想的思路肯定是暴力 dfs，复杂度肯定是指数级的，看一眼数据范围 $n, k \leq 30, m \leq 100$ 只能得部分分。但是这道题的数据范围也够小，我们可以考虑状压（肯定没戏）或者**多维 dp**。

- 状态设定

	设 $f[nn][mm][kk][i]$ 表示已经确定 $nn$ 个 $a_i$ 确定为 $[0, mm)$ 的数，现在我们赋 $l$ 个 $a_i$ 为 $mm$（$l$ 枚举即可），现在 $[0, mm)$ 位的二进制用了 $k$ 个 1，并且第 $mm$ 位向高位进位为 $i$ 时的序列权值之和。

- 初始化

	$f[0][0][0][0] = 1$，也就是一个 $a_i$ 也没确定，现在要找 $l$ 个 $a_i$ 为 0，现在没有二进制用了 1，向高位无进位。
    
- 状态转移

	这道题的状态转移我是从小到大推的，因为这样更方便一点。
    
   首先我们要知道 $f[nn][mm][kk][i]$ 能推到哪个状态：首先因为后面又确定了 $l$ 个数，所以 $nn$ 会推到 $nn + l$，$mm$ 会推到 $mm + 1$，后面的两个不太确定，假设 $k$ 加了 $t1$，$i$ 变成了 $t2$。
   
  首先我们要计算 $t1$ 和 $t2$，因为我们现在只去考虑二进制下第 $mm$ 位是否为 1，所以 $t2$ 只需要看进位（这里的 $\dfrac{i}{2}$）加上当前第 $mm$ 位加了几即可。并且当且仅当如果 $t2$ 是奇数的话那么 $t1 = 1$ 并且 $t2 = t2 - 1$。

   下面就要考虑两个状态之间的关系了。我们知道我们赋了 $l$ 个数为 $mm$，对应的权值又乘了 ${v_{mm}}^{l}$，这里在枚举 $l$ 的过程中乘一下即可；又因为我们最后的 $a_i$ 是有顺序的而不是单纯的考虑 $a_i$ 的值的个数，也就是说我们在 $nn + l$ 个数组位置中选出 $l$ 个数组位置赋为 $mm$，所以我们的方法数又会对应的乘上 $\binom{l}{nn + l}$，这里组合数初始化一下就行，我的代码是考场代码，也就是[打表](https://www.luogu.com.cn/paste/klgu7vzq)做的，也可以用杨辉三角做法，[在此不再赘述](https://zuochunmei.blog.luogu.org/zu-ge-shuo-yong-yang-hui-san-jiao-za-qiu)。
   
   因此状态转移方程为：
   
$$f[nn + l][mm + 1][t1][t2] = f[nn + l][mm + 1][t1][t2] + {v_{mm}}^{l} \times \binom{l}{nn + l} \times f[nn][mm][kk][i]$$

```cpp
for (int m = 0; m <= _m; m++) {
	for (int n = 0; n <= _n; n++) {
   		for (int k = 0; k <= _k; k++) {
			for (int i = 0; i <= 200; i++) {
				if (!_f[n][m][k][i]) {
    				continue;
				}
				
				p = 1;
				
				for (int l = 0; l <= _n - n; l++) {
					if (l) {
    					p *= _v[m];
    					p %= 998244353;
    				}
					
    				t1 = 0;
    				t2 = i / 2 + l;
				
    				if (t2 & 1) {
    					t1 = 1;
    					t2--;
    				}
    				
    				_f[n + l][m + 1][k + t1][t2] += (((_c[n + l][l] * p) % 998244353) * _f[n][m][k][i]) % 998244353;
    				_f[n + l][m + 1][k + t1][t2] %= 998244353;
  				}
			}
   		}
   	}
}
```


- 结果处理

	我们最后的结果一定是已经确定 $n$ 个数是 $[0, m + 1)$ 的数，后面的位枚举然后判断序列是否合法即可。
    
```cpp
for (int k = 0; k <= _k; k++) {
	for (int i = 0; i <= 200; i++) {
		t1 = i;
		t2 = k;
		
		while (t1) {
			if (t1 & 1) {
  				t2++;
			}
			
			t1 >>= 1;
      }
	
		if (t2 <= _k) {
			_res += _f[_n][_m + 1][k][i];
			_res %= 998244353;
		}
	}
}
```

完整代码：

```cpp


#include <bits/stdc++.h>

using namespace std;

int _n, _m, _k;
long long _v[109], _f[39][109][39][209], _res;
long long _c[39][39];//省略打表

void ParseIn () {
	cin >> _n >> _m >> _k;
	
	for (int i = 0; i <= _m; i++) {
		cin >> _v[i];
	}
}

void Core () {
  	int t1, t2;
  	long long p;
  	
  	_f[0][0][0][0] = 1;
  	
  	for (int m = 0; m <= _m; m++) {
   		for (int n = 0; n <= _n; n++) {
    		for (int k = 0; k <= _k; k++) {
				for (int i = 0; i <= 200; i++) {
					if (!_f[n][m][k][i]) {
	    				continue;
					}
					
					p = 1;
					
					for (int l = 0; l <= _n - n; l++) {
						if (l) {
	    					p *= _v[m];
	    					p %= 998244353;
	    				}
						
	    				t1 = 0;
	    				t2 = i / 2 + l;
					
	    				if (t2 & 1) {
	    					t1 = 1;
	    					t2--;
	    				}
	    				
	    				_f[n + l][m + 1][k + t1][t2] += (((_c[n + l][l] * p) % 998244353) * _f[n][m][k][i]) % 998244353;
	    				_f[n + l][m + 1][k + t1][t2] %= 998244353;
	  				}
				}
      		}
    	}
  	}
	
  	for (int k = 0; k <= _k; k++) {
    	for (int i = 0; i <= 200; i++) {
      		t1 = i;
      		t2 = k;
			
      		while (t1) {
				if (t1 & 1) {
	  				t2++;
				}
				
				t1 >>= 1;
      		}
			
      		if (t2 <= _k) {
				_res += _f[_n][_m + 1][k][i];
				_res %= 998244353;
      		}
    	}
  	}
}

void WriteOut () {
 	cout << _res << endl;
}

int main () {
  	ParseIn();
  	Core();
  	WriteOut();
	
  	return 0;
}
```


---

## 作者：EnofTaiPeople (赞：3)

考场不会组合数，写了 50 分暴力状压，感谢 CCF 给了我一个一等。

昨天打 ABC243，F 题多一个"+"号没能场切，那是一道 期望组合计数 dp，让我想到了这题，就来写了一下，感叹四月前的困扰，如今半小时秒掉！

将状态设一下（肯定不是状压）：设 `f[i][j][k]` 表示用了 `i` 个数，组成的数有 `j` 位，向高位进位为 `k`。

使用插板补全法，若原来有 $p$ 个数，现在有 $p'$ 个数，将新增的数（新增的数相互等价）插入的总方案数为 $C_p^{p'}$

通过推导原来和现在的数字位数，可以得到状态转移方程：
```
q=l+((k+p-j)&1),r=(k+p-j)>>1;
f[p][q][r]=(f[p][q][r]+(g[j][l][k]*ml%M)*C(p,j))%M;
```
注意，最后统计答案时，需要加上进位数字的二进制位数，使用内置函数即可：
```
for(ml=j=0;j<=n;++j)
	for(k=0;k<=n;++k)
		if(j+__builtin_popcount(k)<=K)
			ml=(ml+f[n][j][k])%M;
```

---

## 作者：litim (赞：3)

## [NOIP2021] 数列

### 题意

给定整数 $n, m, k$ 和一个长度为 $m + 1$ 的正整数数组 $v_0, v_1, \ldots, v_m$ 。

定义一个**序列** $ \{a_n\} $ 的权值为 $\prod\limits_{i=1}^nv_{a_i}$ 。

求所有满足 $Popcount\left(\sum\limits_{i=1}^n2^{a_i}\right) \leq k$ 的序列 $ \{a_n\} $ 权值之和。

### 题解

#### 算法一

暴力枚举每一个 $a_i$ ，对于每一种可能的序列单独计算是否符合要求、计算权值，这样时间复杂度为 $O(m^n(logn+m))$ 。

期望得分 $20pts$ 。

#### 算法二

【样例解释 #1】启发我们将上面的枚举每一个位置的思路转换为考虑每一个 $\{a_n\}$ 中可能的取值的数量，再通过快速幂和组合数计算每一种方案的贡献。

此时枚举的复杂度就相当于将 $n$ 个相同的物品划分到 $m+1$ 个位置，为 $O(C_{m+n}^m)$ ，此时恰能通过第二类测试点。

期望得分 $35pts$ 。

由于此思路有助于进一步思考想出正解，所以放出部分此算法的关键代码。

```cpp
void solve(int pos,int tot,ll cnt,ll val) {
    // solve(0,n,0,1)
    // pos 表示当前枚举到哪一种取值
    // tot 表示剩余多少没有确定的数
    // cnt 最终判断序列是否合法
    // val 表示对于答案的贡献
    if(pos==m+1) {
        if(Popcnt(cnt)<=k) {
            if(tot==0) ans=(ans+val)%mod;
        }
        return;
    }
    for(int i=pos==m?tot:0;i<=tot;i++) {
        solve(pos+1,tot-i,cnt+(i<<pos),val*fp(v[pos],i)%mod*C[tot][i]%mod);
    }
}
```

#### 算法三

发现对于本题的状态空间只需用枚举到的位数 $pos$ ， $\{a_n\}$ 中已经确定了取值的数量 $tot$ ，序列合法判断值 $val$ 就可以覆盖。考虑使用动态规划。

如果你仔细考虑上面的思路就会发现序列合法判断值 $val$ 的取值范围实在是太大了，所以思路根本不成立——我们接下来要考虑优化的就是序列合法判断值 $val$ 。

设 $\{a_n\}$ 中取值在 $0$ 到 $i$ 之间的数构成的序列判断是否合法的值为 $val_i$ ，例如 $\{eg_n\}$ 包含 $2$ 个 $0$ 和 $3$ 个 $1$ ，其 $val_0=2\times2^0=2,val_1=2\times2^0+3\times2^1=8$

对于每一个已经确定 $0$ 到 $i$ 各数值取值数量的序列 $\{a_n\}$ ，发现最终判断它是否合法的值 $val_n$ 的第 $0$ 到 $i$ 位二进制位已经确定，所以可以将 $val_i$ 拆解为其 $0$ 到 $i$ 位二进制位所表示的数 $k_1$ 和其 $i+1$ 位以上二进制位所表示的数 $k_2$ 。

对于 $k_1$ ，最终计算 $Popcount(val_n)$ 时，只需用到 $Popcount(k_1)$ ；

而 $k_2$ 满足 $k_2=\left\lfloor\dfrac{val_i}{2^i}\right\rfloor\leq\left\lfloor\dfrac{n\sum^i_{j=0}2^j}{2^i}\right\rfloor\leq2\times{n}$ 。

所以只需用 $Popcount(k_1),k2$ 来表示 $val_i$ 即可，此时表示 $val_i$ 的空间复杂度为 $O(nm)$ 。

至此，动态规划所需的状态就已经很明确了：

 $f(i,j,k,l)$ 表示已经确定了序列 $\{a_n\}$ 中 $0$ 到 $i$ 各数值取值数量，此时已经确定了 $j$ 个数的取值， $k$ 和 $l$ 分别表示 $val_i$ 的 $i+1$ 以上的二进制位组成的数和 $val_i$ 的第 $0$ 到 $i$ 位二进制位中 $1$ 的个数。
 
利用算法二的思路，可以列出如下递推方程：

$f(i,j,k,l) \times v[i]^p \times C^p_{n-j} \rightarrow f(i+1,j+p,k/2+p,l+(k/2+p)\bmod2)$

其中箭头表示作为部分贡献， $/2$ 表示除以2向下取整。

本算法需要赋予满足 $i=0$ 的 $f(i,j,k,l)$ 初值以便进行递推，请各位读者自行思考如何赋予初值。

统计答案时需要统计已经确定了序列 $\{a_n\}$ 中 $0$ 到 $m$ 各数值取值数量共 $n$ 个的满足题目条件的各序列贡献之和，也需要读者自行思考如何统计。

这样下来，我们就可以通过使用一个空间复杂度 $O(n^2km)$  ，时间复杂度 $O(n^3km)$ 的算法通过本题了。

如果你已经思考完毕，可以参考如下代码验证你的想法。

```cpp
#include<cstdio>
#include<iostream>
#define il inline
#define gc getchar
using namespace std;
typedef long long ll;
il ll read() {
	ll x=0,sign=0;char ch=gc();
	for(;ch>'9'||ch<'0';ch=gc())sign=ch=='-';
	for(;ch<='9'&&ch>='0';ch=gc())x=(x<<3)+(x<<1)+ch-48;
	return sign?-x:x;
}
const int mod=998244353;
const int N=40;
const int M=1e2+10;
int n,m,d;
int v[M];
ll ans=0;
ll C[N][N];
ll f[M][N][N<<1][N];
il ll fastPow(ll base,ll x) {
	ll ret=1;
	while(x) {
		if(x&1) ret=ret*base%mod;
		base=base*base%mod;
		x>>=1;
	}
	return ret;
}
il ll Popcount(int x) {
    ll ret=0;
	while(x) {
		ret+=x&1;
        x>>=1;
	}
    return ret;
}
int main() {
	n=read(),m=read(),d=read();
	for(int i=0;i<=m;i++)
		v[i]=read();
	for(int i=0;i<=n;i++) C[i][0]=C[i][i]=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<i;j++)
			C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod; // 预处理组合数
	for(int i=0;i<=n;i++)
		f[0][i][i][i&1]=fastPow(v[0],i)*C[n][i]%mod; // i=0时的初值
	for(int i=0;i<m;i++)
		for(int j=0;j<=n;j++)
			for(int k=0;k<=n<<1;k++)
				for(int l=0;l<=d;l++)
					for(int p=0;j+p<=n;p++) {
						if(l+((k>>1+p)&1)>d) continue;
						f[i+1][j+p][(k>>1)+p][l+(((k>>1)+p)&1)]+=f[i][j][k][l]*fastPow(v[i+1],p)%mod*C[n-j][p]%mod;
						f[i+1][j+p][(k>>1)+p][l+(((k>>1)+p)&1)]%=mod; // 转移与取模
					}
	for(int i=0;i<=n<<1;i++)
		for(int j=0;j<=d-Popcount(i>>1);j++)
			ans=(ans+f[m][n][i][j])%mod; // 统计答案
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：OMG_wc (赞：3)

先不考虑序列里具体每个位置填哪些数，而是考虑每种数在序列中出现了多少次：

设 $x_i$ 为序列中值为 $i$ 的数的个数，即要满足 $x_0+x_1+x_2+\cdots +x_m=n$ 。

这个不定方程的一个非负整数解，即为一种不考虑具体位置的方案，如果要求真正的方案数，只需乘以对应的组合数即可。

具体来说，第一步是从 $n$ 个位置里选 $x_0$ 个，第二步是从 $n-x_0$ 个位置里选 $x_1$ 个，以此类推，方案数就会乘以 $C_{n}^{x_0}C_{n-x_0}^{x_1}C_{n-x_0-x_1}^{x_1}\cdots C_{x_m}^{x_m}$。

而这题每种方案的贡献是 $v_{a_{1}} \times v_{a_{2}} \times \cdots \times v_{a_{n}}$ ，也就是还要再乘以 $\prod\limits_{i=0}^{m} v_{i}^{x_i}$。

这样可以首先预处理组合数以及每个 $v_i$ 的幂次，然后写一个 DFS 爆搜把每个不定方程的解求出，然后检查 $1$ 的个数是否合法。

由隔板法可算出，时间复杂度 $O(C_{n+m}^m)$ ，可拿到 $45$ 分，代码如下：

 ```c++
 #include <bits/stdc++.h>
 using namespace std;
 typedef long long LL;
 const int INF = 0x3f3f3f3f;
 const LL mod = 998244353;
 const int N = 100005;
 
 LL ans, c[40][40], a[105][40];
 int n, m, K;
 void dfs(int u, int x, LL now, LL s) {
     if (u == m + 1) {
         if (x == 0 && __builtin_popcountll(s) <= K) ans = (ans + now) % mod;
         return;
     }
     for (int i = 0; i <= x; i++) {
         dfs(u + 1, x - i, now * c[x][i] % mod * a[u][i] % mod, s + ((LL)i << u));
     }
 }
 int main() {
     for (int i = 0; i <= 30; i++) {
         c[i][0] = 1;
         for (int j = 1; j <= i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
     }
     scanf("%d%d%d", &n, &m, &K);
     for (int i = 0; i <= m; i++) {
         int x;
         scanf("%d", &x);
         a[i][0] = 1;
         for (int j = 1; j <= n; j++) {
             a[i][j] = a[i][j - 1] * x % mod;
         }
     }
     dfs(0, n, 1, 0);
     printf("%lld\n", ans);
     return 0;
 }
 ```

注意到在从小到大枚举 $x_i$ 时候，可以把 $S=2^{a_{1}}+2^{a_{2}}+\cdots+2^{a_{n}}$ 分成两个部分：

- 前面 $0\sim i$ 位中一共出现了多少个 $1$  （不会超过 $n$）
- 当前有多少个数进位到第 $i+1$ 位  （不会超过 $n$）

之所以能这样分，是因为后面的所有 $x_{i+1},x_{i+2},\cdots,x_m $  都不会影响第一部分中 $1$ 的个数。

这样一来，总状态就从原来的 $S$ 缩小为 $n^2$ 个，我们就能开心地 DP 了。

基本思路和上面的搜索是一样的，只是对重复的状态只算一次。

设 $f[u][i][j][k]$ 表示考虑完 $\le u$ 的数的个数后，已经用了$i$ 个数，进位为 $j$，$0\sim u$ 位一共有 $k$ 个 $1$ 的总贡献。

转移很简单，枚举在剩下 $n-i$ 个数中用了 $x$ 个数，把 $f[u][i][j][k]$ 乘上 $C_{n-1}^xv_u^x$，加到 $f[u+1][i-x][\lfloor\frac{j+x}{2}\rfloor][k+(j+x)\bmod 2]$ 里。（进位和 $1$ 的个数的变化应该很好理解吧）

最后 DP 完把所有合法的贡献加起来就行了，时间复杂度 $O(n^4m)$，代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int INF = 0x3f3f3f3f;
const LL mod = 998244353;
const int N = 40;

LL c[N][N], a[105][N], f[105][N][N][N];

int main() {
    int n, m, K;
    for (int i = 0; i <= 30; i++) {
        c[i][0] = 1;
        for (int j = 1; j <= i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
    }
    scanf("%d%d%d", &n, &m, &K);
    for (int i = 0; i <= m; i++) {
        int x;
        scanf("%d", &x);
        a[i][0] = 1;
        for (int j = 1; j <= n; j++) {
            a[i][j] = a[i][j - 1] * x % mod;
        }
    };

    f[0][0][0][0] = 1;
    for (int u = 0; u <= m; u++) {
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i; j++) {
                for (int k = 0; k <= i; k++) {
                    for (int x = 0; x <= n - i; x++) {
                        f[u + 1][i + x][(j + x) / 2][k + (j + x) % 2] += f[u][i][j][k] * a[u][x] % mod * c[n - i][x] % mod;
                        f[u + 1][i + x][(j + x) / 2][k + (j + x) % 2] %= mod;
                    }
                }
            }
        }
    }
    LL ans = 0;
    for (int j = 0; j <= n; j++) {
        for (int k = 0; k <= n; k++) {
            if (__builtin_popcount(j) + k <= K) ans += f[m + 1][n][j][k];
        }
    }
    printf("%lld\n", ans % mod);
    return 0;
}
```

---

## 作者：WeLikeStudying (赞：3)

- 多写题解从我做起。
- 勿做斜杠青年从我做起。
- 希望作者不要爆零。

**题意**
- [题目链接](https://www.luogu.com.cn/problem/P7961)。
- 给定 $n,m,k$，和长度为 $m+1$ 的正整数数列 $v_0,v_1,v_2\cdots v_m$。
- 定义一个合法的序列是形如长度为 $n$ 的，每个数的值都是 $0$ 和 $m$ 间的非负整数的序列（可以重复的排列） $a_1,a_2,\cdots,a_n$，且满足 $S=2^{a_0}+2^{a_1}+\cdots+2^{a_n}$ 的二进制表示中 $1$ 的个数不超过 $k$，而且定义该合法序列的权值为 $v_{a_1}\times v_{a_2}\times\cdots\times v_{a_n}$。
- 求所有合法序列的权值和对 $998244353$ 取模的结果。

**暴力实现**
- 暴力实现的作用是对拍和保证自己理解该题目的题意。
- 对笔者这样的菜鸡很有效。
- 时间复杂度 $O((m+1)^n)$ 但可以过大样例。
- [暴力实现](https://www.luogu.com.cn/paste/o4lu3epa)。

**思路**
- 首先这个数列 $a_i$ 的顺序不是费严格递增的让人感到很恶心，由于其它限制都不考虑顺序，考虑用组合数学将它转化为一个无后效性的 DP。
- 然后有一个性质：让这题的状态数转变为多项式级别。
- 看起来状态数是 $n\times 2^n$ 的，但实际上枚举到 $v_i$ 的时候，$0$ 到 $i-1$ 位都不需要在意了，可以用一个数组保存它的个数，而 $\lfloor S/2^i\rfloor\le n$ 是显然的，所以可以再用一个数组保存。
- 看起来很好。
- 接下来是一个简单的组合数学问题：有 $a$ 个黑球，$b$ 个白球，排列总共有多少种可能，显然是 $C(a+b,a)$ 种。
- 于是我们设出状态 $f(i,A,a,g)$ 表示 $a_1,a_2,\cdots a_g$ 取值在 $0$ 到 $i$ 之间，其中 $S$ 的 $0$ 到 $i-1$ 位 1 的个数为 $a$，$\lfloor S/2^i\rfloor$ 值为 $A$ 的序列权值和。
- 有初始状态：
$$f(0,j,0,j)=v_0^j$$
- 枚举数列中 $v_{i+1}$ 的个数 $j$，有转移状态：
$$f(i,A,a,g)\times C(g+j,j)\times v_{i+1}^j\rightarrow f(i+1,\lfloor A/2\rfloor+j,a+(A\bmod 2),g+j)$$
- 其实我一开始还想岔了多开了一维，~~然后就爆空间。~~
- 预处理组合数和 $v_i$ 的幂的话，时间复杂度 $\Theta(mn^4)$，空间复杂度 $\Theta(mn^3)$，实现过关的话是不会出问题的。
- [代码实现](https://www.luogu.com.cn/paste/ynql0wr7)。
- 如果怕空间问题的还可以滚动数组消掉一维，空间复杂度 $\Theta(n^3+nm)$，实测时间复杂度有提升。
- [代码实现](https://www.luogu.com.cn/paste/ljdimwz2)。

**后话**
```cpp
__builtin_popcount()
```
- 这是个好东西，$\text{CCF}$ 忽然开禁了，~~不过笔者目前不太敢用~~。
- [关于NOI系列活动中编程语言使用限制的补充说明](https://www.noi.cn/xw/2021-09-01/735729.shtml)。
- 似乎有人认为这题 $n$ 开得太小容易让人想到暴力？笔者觉得 $m$ 的大小会让人打消这个念头。

---

## 作者：retep (赞：2)

## 题目简述

[ P7961 [NOIP2021] 数列](https://www.luogu.com.cn/problem/P7961)

求所有满足要求的长度为 $n$ 的序列 $a$ 的权值总和。
- 要求：$2^{a_1} + 2^{a_2} + \cdots + 2^{a_n}$ 的二进制表示中 $1$ 的个数不超过 $k$。
- 权值：$v_{a_1} \times v_{a_2} \times \cdots \times v_{a_n}$，因为序列 $v$ 的长度为 $m+1$，所以序列 $a$ 中所有数的取值小于等于 $m$，大于等于 $0$。


$1 \leq k \leq n \leq 30$，$0 \leq m \leq 100$，结果对 $998244353$ 取模。

## 题目分析

因为跟二进制扯上关系，并且整体的数据范围较小，所以考虑用状态压缩动态规划来求解。

先写最暴力的方法，直接把 $s$ 的值放在状态里。依次枚举序列 $a$ 的每个位置，每个位置有 $m+1$ 种选择。那么容易得到以下搜索：

```cpp
//now表示a中的位置，cnt是s中1的个数。因为s确定了cnt就确定了，所以不算一个状态，只是一个辅助变量。
ll dfs(int now,ll s,int cnt){ 
	if(now>n)return cnt<=k; //到头了，如果1的数量小于等于k，就是一种情况，否则不是。
	if(vst[now][s])return f[now][s]; //记忆化搜索
	vst[now][s]=true;
	ll res=0;
	for(int i=0;i<=m;i++){ //m+1种选择都试一试
		ll buf=s+(1ll<<i),count=0; //s加上2^a[now]
		for(ll j=buf;j;j-=j&-j)count++; //数一数新s的1的个数
		res=(res+dfs(now+1,buf,count)*v[i])%mod; //累加权值
	}
	return f[now][s]=res;
}
```
[这样](https://www.luogu.com.cn/record/75982540)就可以得 $50pts$ 了，~~已经是全国一等奖了~~，让我们继续改进算法。

整体的时间复杂度高很大程度上是因为状态 $s$，但因为要记录 $1$ 的个数，我们又不能将其省去，所以思考如何**化简**这个状态。

二进制中 $1$ 的个数是满足**无后效性**的，也就是说在某个位置一直加 $1$ 只会对后面的高位产生印象，对前面的低位是没有影响的（低位是前，高位是后，不是后效性的"后"）。

我们知道最多加 $n$ 次 $1$，因为序列 $a$ 的长度为 $n$。
所以 $s$ 不需要全部记录，**只需要记录会被影响的后几位**就可以了，因为只有这些位上 $1$ 的个数会发生变化。因为 $n$ 小于等于 $30$，所以 $s$ 开 $30$ 就足够了。每次算完把最低位去除，位置贡献出来记录新的最高位。

此时之前的虚假状态 $cnt$ 变成实体状态了，因为 $s$ 中省略的不变信息，低位的 $1$ 的个数，需要一个载体。最大值也是 $30$，也就是所有选择都不一样的时候有 $30$ 个 $1$。

有个问题，如果像之前一样依次枚举序列 $a$ 的 $n$ 个位置，每个位置 $m+1$ 种选择，就可能出现后面选的比前面小的可能，无后效性就被打破了。

所以需要用新的枚举方法，依次枚举 $m+1$ 种选择，然后再像背包问题一样枚举该选择的出现次数。这样只要从小到大枚举 $m+1$ 种选择就能满足后效性了。

又有个问题，题目中说的是如果序列 $a$ 的选择一样但顺序不同也算多种情况，但用上面的枚举方法就只算一种情况了。所以要乘上个组合数，表示这么多个位置中**选几个用来放当前选择**一共有多少种方法。组合数是可以预处理的。

最终得到了满分正解，~~可以进弱省省队了~~！

## code
```cpp
#include<bits/stdc++.h>
#define N 35
#define M 105
#define mod 998244353
#define ll long long
using namespace std;

ll n,m,k,v[M],f[M][N][N][N],c[N][N];
bool vst[M][N][N][N];

void init(){ //组合数初始化
	c[0][0]=1;
	for(int i=1;i<=n;i++)
		for(int j=0;j<=i;j++)
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;	
}

//分别表示第now个选择（第now个位置上的1），序列a剩余size个空位置，当前cnt个1
ll dfs(int now,int size,int cnt,int s){
	if(now>m)return size==n?cnt<=k:0; //选完了，满足要求并且序列a都填完了（可能没填完）
	
	if(vst[now][size][cnt][s])return f[now][size][cnt][s]; //记忆化
	vst[now][size][cnt][s]=true;
	
	int count1=0,count2=0,buf=s;
	while(buf)buf-=buf&-buf,count1++; //计算初始情况下的s中1的个数
	ll res=0,mul=1;
	for(int i=0;i+size<=n;i++){ //枚举当前选择在序列中的出现次数
		buf=s+i,count2=0; //得到新的s
		while(buf)buf-=buf&-buf,count2++; //计算新的s中1的个数
		res+=dfs(now+1,size+i,cnt-count1+count2,(s+i)/2)*mul%mod*c[i+size][i]%mod;
        	//除2就是去掉以后不会再变的最低位，把位置贡献出来记录以后可能会变的新的最高位。
		res%=mod; mul=mul*v[now]%mod;
	}
	return f[now][size][cnt][s]=res;
}

int main(){
	cin>>n>>m>>k;
	init();
	for(int i=0;i<=m;i++)cin>>v[i];
	cout<<dfs(0,0,0,0);
	return 0;
}
```



---

## 作者：Polaris_Australis_ (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P7961)

## 做法

这题属于是数位 dp 里比较好的题，也比较套路。

设 $dp[i][j][k][l]$ 表示处理到二进制第 $i$ 位，{$a_i$} 序列中有 $j$ 个元素目前有值，$0\sim i-1$ 位都进完位，在 $0\sim i-1$ 位中有 $k$ 个 $1$，第 $i$ 位目前有 $l$ 个 $1$ 的所有情况。

分析转移方程：从 $i-1$ 位转移，如果 $i-1$ 位有奇数个数还没有进位，则进位后 $1$ 的个数会多一个，否则不变，然后枚举往这个位置放多少个 $1$，转移即可，故转移方程为：

$$
dp[i][j+l][x+1][l+(y>>1)]+=dp[i-1][j][x][y]\times v[i]\times \tbinom{n-j}{l}
$$
$$
dp[i][j+l][x][l+(y>>1)]+=dp[i-1][j][x][y]\times v[i]\times \tbinom{n-j}{l}
$$

第一个转移方程 $y$ 是奇数，第二个 $y$ 是偶数。枚举转移就行了。

## 代码

```cpp
// Problem: P7961 [NOIP2021] 数列
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P7961
// Memory Limit: 512 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define int long long
#define mod 998244353
using namespace std;
namespace Std {
int n, m, k, v[110], dp[210][40][40][40], c[110][110];
int qp(int x, int y) {
  int cmp = 1;
  while (y) {
    if (y & 1) {
      cmp *= x;
      cmp %= mod;
    }
    x *= x;
    x %= mod;
    y >>= 1;
  }
  return cmp;
}
int main() {
  scanf("%lld%lld%lld", &n, &m, &k);
  for (int i = 0; i <= m; ++i) scanf("%lld", v + i);
  c[0][0] = 1;
  for (int i = 1; i <= n; ++i) {
    c[i][0] = 1;
    for (int j = 1; j <= n; ++j) c[i][j] = c[i - 1][j - 1] + c[i - 1][j];
  }
  dp[0][0][0][0] = 1;
  for (int i = 1; i <= n; ++i) dp[0][i][0][i] = qp(v[0], i) * c[n][i] % mod;
  for (int i = 1; i <= m; ++i) {
    for (int j = 0; j <= n; ++j) {
      for (int l = 0; j + l <= n; ++l) {
        for (int o = 0; o <= min(i - 1, k); ++o) {
          for (int p = 0; p <= j; ++p)
            if (p & 1)
              (dp[i][j + l][o + 1][(p >> 1) + l] +=
               (dp[i - 1][j][o][p] * qp(v[i], l) % mod * c[n - j][l] % mod)) %=
                  mod;
            else
              (dp[i][j + l][o][(p >> 1) + l] +=
               (dp[i - 1][j][o][p] * qp(v[i], l) % mod * c[n - j][l] % mod)) %=
                  mod;
        }
      }
    }
  }
  for (int i = m + 1; i <= m + 100; ++i) {
    for (int j = 0; j <= k; ++j) {
      for (int l = 0; l <= n; ++l) {
        if (l & 1)
          (dp[i][n][j + 1][l >> 1] += dp[i - 1][n][j][l]) %= mod;
        else
          (dp[i][n][j][l >> 1] += dp[i - 1][n][j][l]) %= mod;
      }
    }
  }
  int ans = 0;
  for (int i = 0; i <= k; ++i) (ans += dp[m + 100][n][i][0]) %= mod;
  printf("%lld\n", ans);
  return 0;
}
}  // namespace Std
#undef int
int main() { return Std::main(); }
```


---

## 作者：lzx2005 (赞：2)

大致题意：给定 $0\sim m$ 每个数的权值，从中选出一个长度为 $n$ 的序列 $a$，使得 $S=\sum\limits_{i=1}^{n}2^{a_i}$ 二进制表示下有不超过 $k$ 位是 $1$，每个数可选多次，每种选取方案得价值为所选的所有数的权值积，求所有合法选取方案的价值之和对 $998244353$ 取模的结果。

尝试设计一个 dp，考虑将要选择的数中相同的一次性加入数列中，用状态记录 $S$ 的二进制情况。不难发现，$\forall a_i<a_j$，$a_j$ 的选取情况与 $S$ 二进制表示下从低到高第 $0\sim a_i$ 位的取值没有影响，但 $a_i$ 的选择可能会导致进位而对 $S$ 二进制第 $a_j$ 位产生影响。所以从小到大加数，记录已选的数的个数，$S$ 中已经确定的位中有几个 $1$，并记录会向下一位进多少。

可得状态 $f(i,j,v,w)$ 表示从 $0\sim i$ 中选了 $j$ 个数，$S$ 中已经确定的位中有 $v$ 个 $1$，向下一位进 $w$ 的情况下，价值和为多少（此处的价值为已经选出的数的权值之积）。枚举每个数选取的个数 $u$，那么每次加数相当于从 $k-j$ 个位置中选出 $u$ 个放上数字，方案数为 $C_{k-j}^u$，可得转移
$$
f(i,j+u,v+(u+w)\bmod 2,\lfloor \frac{w+u}{2}\rfloor)\gets f(i,j,v,w)\times {v_i}^u\times C_{k-j}^u
$$
其中 $C_n^m$ 表示组合数。

答案即为 $\sum f(m,n,v,w)\times (v+\text{bitcount}(w)\le k)$，其中 $\text{bitcount}(w)$ 表示 $w$ 二进制表示下 $1$ 的个数。

使用递推预处理组合数，时间复杂度 $\mathcal O(n^4m)$；滚动数组优化，空间复杂度 $\mathcal O(n^3)$。

考场代码，其中上文的 $v$ 在代码中用 $k$ 表示：

```cpp
#include<bits/stdc++.h>
#define re register
#define ll long long
using namespace std;
inline int read()
{
	char c=getchar();int x=0,f=1;
	while(c>'9'||c<'0'){if(c=='-')f=-f;c=getchar();}
	while(c<='9'&&c>='0'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=35,M=110,mod=998244353;
int n,m,K;
ll f[N][N][N],g[N][N][N],v[M],powerv[M][N],C[N][N],ans;
inline void co()
{//复制上一层转移的结果进行滚动。
	for(re int i=0;i<=n;i++)
		for(re int j=0;j<=n;j++)
			for(re int k=0;k<=n;k++)
				g[i][j][k]=f[i][j][k],f[i][j][k]=0;
	return;
}
inline int getnum(int x)
{//计算bitcount
	int cnt=0;
	while(x)
	{
		if(x&1)cnt++;
		x>>=1;
	}
	return cnt;
}
int main()
{
	n=read(),m=read()+1,K=read();
	for(re int i=1;i<=m;i++)
	{
		powerv[i][0]=1;
		v[i]=read();
		for(re int j=1;j<=n;j++)
			powerv[i][j]=powerv[i][j-1]*v[i]%mod;
	}
	C[0][0]=1;
	for(re int i=1;i<=n;i++)
	{//预处理组合数
		C[i][0]=C[i-1][0];
		for(re int j=1;j<=i;j++)
			C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
	}
	f[0][0][0]=1;
	for(re int i=1;i<=m;i++)
	{
		co();
		for(re int j=0;j<=n;j++)	
			for(re int k=0;k<=j;k++)
				for(re int p=0;p<=j;p++)
					for(re int w=0;w+j<=n;w++)
						f[j+w][k+(w+p)%2][(w+p)/2]=(f[j+w][k+(w+p)%2][(w+p)/2]+powerv[i][w]*g[j][k][p]%mod*C[n-j][w]%mod)%mod;
		if(i==m)
		{//统计答案
			for(re int j=0;j<=n;j++)
				for(re int k=0;k<=n;k++)
					if(j+getnum(k)<=K)
						ans=(ans+f[n][j][k])%mod;
		}
	}
	cout<<ans<<endl;
	return 0;
}
```







---

## 作者：Elma_ (赞：2)

考场正解写挂喜提退役。

一看数据范围发现长得很像一个 dp。显然我们只关心序列 $a$ 中每种元素出现的次数，因此我们考虑按元素进行 dp，对于同种元素一起转移，转移的时候乘一个组合数即可（嗯就是多重集全排列计数）。

从低位到高位考虑 $S$ 当前位放多少个数，之前有多少个数、多少个 $1$，会发现当前位放的数可能对之后的位置有影响，因此可以多记一维表示当前状态的进位是多少，具体来说就是设 $f_{i,S,j,k}$ 表示放到第 $i$ 位，进位状态为 $S$，放了 $j$ 个数，有 $k$ 个 $1$ 的权值和，转移时枚举上一个放的位置，当前放多少个数，之前有多少个数、多少个 $1$，把进位状态合并一下即可。这样是 $O(m^2n^4)$ 的。

但我们发现因为这个进位状态最多是 $n$，那么最多只可能有 $\log_2n=4$ 个位置的进位可能对当前位置的进位状态产生影响。对于有影响的位置我们按照刚才的做法把进位状态合并，没有影响的位置直接用前缀和优化即可。组合数和每个 $v_i$ 的若干次方都可以预处理，时间复杂度 $O(mn^4)$。


------------

**Update**：看了一圈发现这个做法最垃圾了，时空复杂度和代码实现难度都劣于其他题解...这个做法的时间复杂度其实是 $O(mn^4 \log n)$，因为 $n$ 比较小所以可以近似看做常数？

```cpp
const int MN = 31, MM = 103, MK = 1 << 12, Mod = 998244353;

int qPow(int a, int b) {
	int res = 1;
	while (b) {
		if (b & 1) res = res * a % Mod;
		a = a * a % Mod, b >>= 1;
	}
	return res;
}

int Fac[MN], Inv[MN];
inline void init(int N) {
	Fac[0] = 1;
	for (int i = 1; i <= N; i++) Fac[i] = Fac[i - 1] * i % Mod;
	Inv[N] = qPow(Fac[N], Mod - 2);
	for (int i = N; i >= 1; i--) Inv[i - 1] = Inv[i] * i % Mod;
}
inline int C(int n, int m) {
	return Fac[n] * Inv[m] % Mod * Inv[n - m] % Mod;
}

int N, M, K, f[MM][MN][MN][MN], w[MK], A[MM], g[MM][MN][MN], P[MM][MN];

signed main(void) {
	N = read(), M = read() + 1, K = read(), init(N);
	for (int i = 1; i <= M; i++) A[i] = read();
	for (int i = 1; i < MK; i++) w[i] = w[i >> 1] + (i & 1); 
    for (int i = 1; i <= M; i++) {
        P[i][0] = 1;
        for (int k = 1; k <= N; k++) {
            P[i][k] = P[i][k - 1] * A[i] % Mod;
        }
    }
	for (int i = 1; i <= M; i++) {
		for (int k = 1; k <= N; k++) {
			f[i][k][k][w[k]] = P[i][k] * C(N, k) % Mod;
		}
		if (i >= 6) {
			for (int k = 1; k <= N; k++) {
				for (int p = k + 1; p <= N; p++) {
					for (int q = w[k] + 1; q <= N; q++) {
						f[i][k][p][q] = (f[i][k][p][q] + g[i - 5][p - k][q - w[k]] * P[i][k] % Mod * C(N - (p - k), k) % Mod) % Mod;
					}
				} 
			}
		}
		for (int j = max(i - 4, 1); j < i; j++) {
			for (int k = 1; k <= N; k++) {
				for (int S = 1; S <= N - k; S++) {
					int x = w[(k << (i - j)) + S], T = k + (S >> (i - j));
					for (int p = k + S; p <= N; p++) {
						for (int q = 0; q <= min(N - w[S], N - x); q++) {
							f[i][T][p][q + x] = (f[i][T][p][q + x] + f[j][S][p - k][q + w[S]] * P[i][k] % Mod * C(N - (p - k), k) % Mod) % Mod;
						}
					} 
				}
			}
		}
        for (int p = 1; p <= N; p++) {
            for (int q = 1; q <= N; q++) {
                g[i][p][q] = g[i - 1][p][q];
            }
        }
        for (int p = 1; p <= N; p++) {
            for (int q = 1; q <= N; q++) {
                for (int k = 1; k <= N; k++) {
                    g[i][p][q] = (g[i][p][q] + f[i][k][p][q]) % Mod;
                }
            }
        }
	}
	int Ans = 0;
	for (int i = 1; i <= M; i++) {
		for (int k = 1; k <= N; k++) {
			for (int q = 1; q <= K; q++) {
				Ans = (Ans + f[i][k][N][q]) % Mod;
			}
		}
	}
	printf("%lld\n", Ans);
	return 0;
}
```


---

## 作者：C6H14 (赞：1)

## 一点废话

[题目传送门](https://www.luogu.com.cn/problem/P7961)

[My blog](https://www.luogu.com.cn/blog/128433/#)

考场上自信敲完，考后一测发现答案统计顺序+没删调试直接爆大零

~~rnm，退钱！~~

不过我身边那么多大佬没想出来是没想到的……考前做过一道类似的题

## 思路

先看数据范围：$k \leqslant n \leqslant 30,m \leqslant 100$，状压会T飞，折半想不出来，贪心也不像，转图论……有点扯淡。

~~俗话说：你不会做的题很有可能就是dp~~，于是考虑非状压DP。

先不管 $\{ a_i \}$ 的有序问题，将它当做无序的做。

显然在下标为 $0$ 到 $i$ 的数中选完想要的后，后面无论怎么选都不会让 $S$ 二进制表示中后面的 $0$ 到 $i$ 位，也就是 $S \bmod 2^{i+1} $ 的值发生改变。

那么可以按下标的值划分阶段，将$S$ 已确定的1的个数作为状态转移。

定义状态 $f(i,j,l,r)$ 表示**在下标为 $0$ 到 $i$ 的 $v$ 中选了 $j$ 个数，$S$ 的 $0$ 到 $i$ 位中有 $l$ 个 $1$，向第 $i+1$ 位进位的值为 $r$** 的权值和。

初始状态即为 $f(0,j,j \bmod 2,\left \lfloor \dfrac{j}{2} \right \rfloor)=v^j_0$，答案为 $\sum \limits^{i+digit(j) \leqslant k}_{i=0,j=0} f(m,n,i,j)$，其中 $digit(j)$ 为 $j$ 在二进制下 $1$ 的个数。

状态转移方程好像不是很好写，那么就改成“我要到哪里去”。

考虑 $f(i,j,l,r)$ ，假如我们下一步选 $x$ 个 $v_{i+1}$，那么 $S$ 的第 $i+1$ 就是 $(x+l) \bmod 2$，进位是 $\left \lfloor \dfrac{x+l}{2} \right \rfloor$，权值和变成 $v^x_{i+1}f(i,j,l,r)$，转移到 $f(i+1,j+x,(x+l) \bmod 2,\left \lfloor \dfrac{x+l}{2} \right \rfloor)$ 上。

再考虑排列对其的影响，每次选了 $x$ 个相同的值，将权值除以 $x!$，然后将统计完的答案乘上 $n!$ 即可

## 代码

```cpp
const ll maxn=998244353;
void exgcd(ll a,ll b,ll &x,ll &y)
{
	if (b==0)
	{
		x=1,y=0;
		return;
	}
	exgcd(b,a%b,y,x);
	y-=(a/b)*x;
}
inline ll rev(ll x)
{
	ll ans,tmp;
	exgcd(x,maxn,ans,tmp);
	return (ans%maxn+maxn)%maxn;
}
ll n,m,q,v[125],f[125][35][35][35],s[205],ans,r[105],fact[105];
inline void READ()
{
	n=read(),m=read(),q=read();
	for (int i=0;i<=m;++i)
		v[i]=read();
}
inline void make_table()
{
	fact[0]=r[0]=1;
	for (ll i=1;i<=100;++i)
		fact[i]=fact[i-1]*i%maxn,r[i]=rev(fact[i]);
	for (int i=0;i<=200;++i)
	{
		int t=i;
		while (t)
		{
			if (t&1) ++s[i];
			t>>=1;
		}
	}
}
inline void do_it()
{
	for (ll i=0,j=1;i<=n;++i,j=j*v[0]%maxn)
		f[0][i][i&1][i/2]=j*r[i]%maxn;
	for (int i=0;i<m;++i)
		for (int j=0;j<=n;++j)
			for (int k=0;k<=q;++k)
				for (int l=0;l<=(j+1)>>1;++l)
					if (f[i][j][k][l])
						for (ll x=0,y=1;x+j<=n;++x,y=y*v[i+1]%maxn)
							f[i+1][j+x][k+((l+x)&1)][l+x>>1]=(f[i+1][j+x][k+((l+x)&1)][l+x>>1]+f[i][j][k][l]*y%maxn*r[x]%maxn)%maxn;
}
inline void count_ans()
{
	for (int i=0;i<=q;++i)
		for (int j=0;j<=(n+1)>>1;++j)
			if (i+s[j]<=q)
				ans=(ans+f[m][n][i][j])%maxn;
}
inline void print()
{
	for (int i=0;i<=m;++i)
		for (int j=0;j<=n;++j)
			for (int k=0;k<=j;++k)
				for (int l=0;l<=(j+1)>>1;++l)
					if (f[i][j][k][l])
						printf("%d %d %d %d:%lld\n",i,j,k,l,f[i][j][k][l]*fact[j]%maxn);
}
int main()
{
	freopen("sequence.in","r",stdin);
	freopen("sequence.out","w",stdout);
	READ();
	make_table();
	do_it();
	count_ans();
	print();
	printf("%lld",ans*fact[n]%maxn);
	return 0;
}
```


---

## 作者：Coros_Trusds (赞：1)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/15632869.html)

感觉这道题纯动态规划的边界等问题非常麻烦，所以这里采用记忆化搜索。

# 题目大意

给出 $n,m,k$ 及 $val_0\cdots val_m$，定义一个值 $\in [0,m]$ 的序列 $a$，其权值为 $\prod\limits_{i=1}^{n} val_{a_i}$

我们称 $S$ 满足条件当且仅当 $S=\sum\limits_{i=1}^{n} 2^{a_i}$ 的二进制表示中，$1$ 的个数小于等于 $k$。此时，也称序列 $a$ 为合法序列。

求所有合法序列 $a$ 的权值和 $\mod 998244353$ 的结果。

# 题目分析

令 $dfs(bit,now,x,y)$ 表示：

$S$ 从低到高二进制的 $bit$ 位中，用了序列 $a$ 的前 $now$ 个数，此时 $S$ 二进制下有 $x$ 个 $1$，上一位（第 $bit+1$ 位）进位为 $y$。

$mem[biw][now][x][y]$ 则储存答案。

于是，我们有：

$$mem[bit][now][x][y]=\sum\limits_{i=0}^{n-now}{mem[bit][now+i][x+(y+i)\%2][\left\lfloor\frac{y+i}{2}\right\rfloor])\times sum[bit][i]\times C_{now+i}^{i}}$$

其中 $C_{i}^{j}$ 表示组合数，$sum[i][j]$ 表示：

```cpp
for(register int i=0;i<=m;i++)
{
	sum[i][0]=1;
		
	for(register int j=1;j<=n;j++)
	{
		sum[i][j]=sum[i][j-1]*val[i]%mod;
	}
}
```

可以看到，$sum[i][j]$ 主要作用类似于前缀和，目的是简化计算。

----

边界部分：

当前转移到 $dfs(bit,now,x,y)$。

+ 若 $now=n$：

当 $x+getcnt(y)>k$ 时，返回 $0$。表示不需要继续转移了。

否则返回 $1$。

+ 若 $bit>m$ 则直接返回。

+ 若 $mem[bit][now][x][y]$ 有数则直接返回该数。

# 代码

不知道是不是你谷的 $\rm Key~Words$ 问题，放不上来。

详见博客内。

---

## 作者：I_am_Accepted (赞：0)

### Description

$\{a\}$ 为值域 $0,1,\dots,m$ 长度为 $n$ 的序列，其权值为

$$\prod\limits_{i=1}^nv_{a_i}$$

输出所有满足 $popcnt(\sum\limits_{i=1}^n2^{a_i})\leqslant k$ 的 $\{a\}$ 的权值和。

### Analysis

这题目看起来就令人头大 qwq。

发现枚举 $\{a\}$ 每一个位置的值不可行（因为条件是关于权值的 $popcnt$），转而枚举 $0,1,\dots,m$ 各在 $\{a\}$ 中出现的次数 $b_0,b_1,\dots,b_m$，对答案的贡献要再乘上可重排列数

$$\dfrac{n!}{b_0!b_1!\dots b_m!}$$

接下来只要枚举 $\{b\}$ 即可，~~暴搜~~ DP 即可。

状态 $dp_{i,j,k,l}$ 表示当前遍历了 $b_0\to b_i$，$(S>>i)=j$，$popcnt(S\&((1<<i)-1))=k$，$\sum\limits_{p=0}^ib_p=n-l$ 的权值和。

其中 $S=\sum\limits_{p=0}^ib_p2^p$。

咸鱼篇幅，转移见代码。

时间复杂度 $O(m\times n\times n\times n\times n)$，前四项分别对应 DP 中的每一维，最后转移 $O(n)$。

### Detail

代码实现中将可重排列数嵌入到 DP 中。

我写的记忆化搜索。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)
#define For(i,j,k) for(register int i=j;i<=k;i++)
#define Rof(i,j,k) for(register int i=j;i>=k;i--)
	const ll mod=998244353;
	inline ll pw(ll x,ll y){//快速幂
		ll r=1;
	    while(y){
	        if(y&1) r=r*x%mod;
	        x=x*x%mod;
	        y>>=1;
	    }
	    return r;
	}
	#define madd(a,b) {a=((a+b)%mod+mod)%mod;}
	#define inv(a) pw(a,mod-2)//逆元
#define N 33
#define M 110

int n,m,k;
ll dp[M][N][N][N];
bool vis[M][N][N][N];//记忆化
ll v[M][N];//{v_i}^j，为方便预处理
ll f[N],ivf[N];//f_i=i! ivf_i=inv(i!)
#define D dp[id][bit][had][lst]
#define V vis[id][bit][had][lst]
#define ppcnt __builtin_popcount
ll dfs(int id,int bit,int had,int lst){
	if(V) return D;
	V=1;
	if(had>k) return D=0;
	if(id==m+1){
		D=(!lst && had+ppcnt(bit)<=k);
		return D;
	}
	For(i,0,lst)
		madd(D,ivf[i]*v[id][i]%mod*dfs(id+1,(bit+i)>>1,had+((bit+i)&1),lst-i));
	return D;
}
void init(){
	f[0]=1;
	For(i,1,N-1)
		f[i]=f[i-1]*i%mod;
	ivf[N-1]=inv(f[N-1]);
	Rof(i,N-1,1)
		ivf[i-1]=ivf[i]*i%mod;
}
signed main(){
	IOS;
	init();
	cin>>n>>m>>k;
	For(i,0,m){
		v[i][0]=1; 
		cin>>v[i][1];
		For(j,2,N-1)
			v[i][j]=v[i][j-1]*v[i][1]%mod;
	}
	cout<<f[n]*dfs(0,0,0,n)%mod<<endl;
    return 0;
}
```

---


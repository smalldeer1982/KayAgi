# 【MX-X6-T5】 再生

## 题目背景

原题链接：<https://oier.team/problems/X6F>。

---

> _このまま$\\$
らったった$\\$
音に乗って$\\$
今きっと世界で僕だけだ$\\$
後ろ向きな歌を聴いて$\\$
少しだけ$\\$
前向きに生きていく_
>
>_—— [再生 - Nanatsukaze](https://music.163.com/#/song?id=2133659925)_

破碎的点依照破碎的规则进行重组，如此再生的一个结构将会是什么样的呢？

## 题目描述

现有一棵 $n$ 个点的有标号有根树，给定其长链剖分得到的 top 数组，请你输出有多少种不同的树可以在长链剖分之后得到该 top 数组。答案对 $20051131$（质数）取模。

具体来说，对于一棵树 $T$，对所有点 $u$ 定义其树高 $h_u$：

- 如果 $u$ 是叶子，则 $h_u=1$。
- 否则设 $u$ 的孩子集合为 $S_u$，则 $h_u=\max\limits_{v\in S_u}h_v + 1$。

给定数组 $t_{1\cdots n}$，你需要计算有多少种树满足：

- 对于根节点 $r$，满足 $t_r=r$。
- 对于每一个不是叶子的节点 $u$，存在恰好一个孩子 $v$ 满足 $h_v+1=h_u$ 并且 $t_v=t_u$，其他孩子满足 $t_v=v$。

模 $20051131$（质数）。

两棵树不同当且仅当它们的根不同或它们的边集不同。

**保证答案不为 $\bf 0$，但是不保证答案在模意义下不为 $\bf 0$。**

## 说明/提示

**【样例解释 #1】**

![](https://cdn.luogu.com.cn/upload/image_hosting/7np2ikvh.png)

仅有图中的两种树满足条件。

**【数据范围】**

对于所有数据，保证 $1\leq n\leq 5\times 10^5$，$1\leq t_i\leq i$，保证取模前答案不为 $0$。

**捆绑测试**，共 5 个 Subtask，具体限制如下所示：

- Subtask 1（11 pts）：$t_i=1$。
- Subtask 2（24 pts）：$n\leq 5$。
- Subtask 3（17 pts）：$n\leq 16$。
- Subtask 4（22 pts）：$n\leq 2\times 10^3$。
- Subtask 5（26 pts）：无特殊限制。

## 样例 #1

### 输入

```
5
1 1 1 4 4```

### 输出

```
2```

## 样例 #2

### 输入

```
16
1 2 1 4 1 4 1 4 9 1 1 12 1 1 12 1```

### 输出

```
7181107```

# 题解

## 作者：Register_int (赞：11)

考虑每一条长链，若长度为 $n$，则链内排列的方案为 $(n-1)!$。

接下来将长链并成树。若长度为 $x$ 的长链并在长度为 $y$ 的上，那么必定有 $x<y$。接上去的位置恰好有 $y-x$ 个，方案数为 $y-x$。

显然合并过程互不影响，枚举短的计算并到任意一条长链上的方案数，乘起来即可。用前缀和优化可做到 $O(n)$。

```cpp
#include <bits/stdc++.h> 

using namespace std;

typedef long long ll;

const int MAXN = 5e5 + 10;
const int mod = 20051131;

int n, cnt[MAXN]; ll ans = 1, sum;

int main() {
	scanf("%d", &n);
	for (int i = 1, x; i <= n; i++) scanf("%d", &x), cnt[x]++;
	sort(cnt + 1, cnt + n + 1, greater<int>());
	for (int i = 1; i <= n; i++) {
		if (!cnt[i]) break;
		for (int j = 1; j < cnt[i]; j++) ans = ans * j % mod;
		if (i > 1) ans = ans * (sum - (ll)(i - 1) * cnt[i]) % mod; sum += cnt[i];
	}
	printf("%lld", ans);
}
```

---

## 作者：EricWan (赞：3)

很简单的一个题，为啥要放后面？

首先，显然，答案只跟每一种长度的链有多少个有关。

最长的链是从根开始的，因此最长的链只有一个，我们特判掉。

对于一个长度为 $len$ 的链，除了头，其它的元素都是等价的，因此必然会对答案贡献 $(len-1)!$ 的乘贡献（我们提前维护阶乘）。

从次长链向短链依次枚举，对于一个新来的链，看到底能放在多少个节点下，容易发现，只有下面的链长大于等于新来的链长的才能插入这个新链，想要维护这个，因为点数有限，就可以瞎搞了，我喜欢树状数组，因此下面的代码中使用树状数组。然后我们就做完了。

代码：
```cpp
#include <bits/stdc++.h>
#define int long long
#define lowbit(x) ((x)&-(x))
#define mod 20051131
#define MAXN 10000005
using namespace std;
int n, k, t[MAXN], f[MAXN], ans;
map<int, int> mp;
vector<int> vec;
void update(int x) {
	while (x <= n) {
		t[x]++;
		x += lowbit(x);
	}
}
int query(int x) {
	int ans = 0;
	while (x) {
		ans += t[x];
		x ^= lowbit(x);
	}
	return ans;
}
signed main() {
	f[0] = 1;
	for (int i = 1; i <= 1000000; i++) {
		f[i] = f[i - 1] * i % mod;
	}
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> k;
		mp[k]++;
	}
	for (pair<int, int> i : mp) {
		vec.push_back(i.second);
	}
	sort(vec.begin(), vec.end());
	reverse(vec.begin(), vec.end());
	for (int i : vec) {
		if (ans == 0) {
			ans = f[i - 1];
			for (int j = 1; j <= i; j++) {
				update(j);
			}
			continue;
		}
		ans *= f[i - 1];
		ans %= mod;
		ans *= query(n) - query(i);
		ans %= mod;
		for (int j = 1; j <= i; j++) {
			update(j);
		}
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：luxiaomao (赞：2)

## [P11159](https://www.luogu.com.cn/problem/P11159) 排列组合题

赛时看到长链剖分吓一跳，因为我不会薯片剖分，然后仔细一看其实不难。

---

首先推一推发现：如果有一些点的 $t_i$ 相同，那么它们就在一条链上。带着这条性质，我们开始写题。

### Sub 1

所有的 $t_i = 1$，说明所有点都在一条链上，并且这条链的链头为 $1$，其他 $n-1$ 个点在链上任意排列，答案即为 $(n-1)!$。

别忘了开 `long long`，即可通过此部分。

### Sub 2 ~ 3

似乎可以用一种比较优雅的方式枚举出所有的树的形态，然后再行判断？蒟蒻赛时没有仔细考虑。

### Sub 4

我们先按 $t_i$ 不同分成若干组，也就是若干条链，我们要考虑如何将这些链拼接起来，再乘上链内部点的排列，即为答案。

为了保证长链剖分的性质，请看下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/uvw6h0v1.png)

那么显然只能短链拼在长链上，我们先把链按照长度降序排序。

如果长链长度为 $h_1$，短链长度为 $h_2$，显然短链可以接在长链上方的 $h_1-h_2$ 个节点上。

然后再枚举每条短链接在哪条长链上，答案累加起来，注意区分乘法原理和加法原理，我们可以得到以下代码：

（其中 `fac[i]` 表示阶乘。）

```cpp
for(int i = 1;i <= n;i++)
{
	int fa = top[i];
	a[fa].h++;
}
sort(a+1,a+1+n,cmp);
ans = fac[a[1].h-1];
for(int i = 2;a[i].h;i++)
{
	a[i].v = fac[a[i].h-1];
	int cnt = 0;
	for(int j = 1;j < i;j++)
	{
		cnt += a[j].h-a[i].h;
	}
	ans = ans * cnt % mod * a[i].v % mod;
}
printf("%lld\n",ans);
```

时间复杂度 $O(n^2)$，即可通过此部分。

### Sub 5

由代码得，每条链的 $cnt$（即这条链可以接在多少个点上）可以写作：

$$cnt_i = \sum\limits_{j = 1}^{i-1}h_j-h_i$$

这不是赤裸裸的前缀和嘛，于是就过了。

（其实不写结构体也行，赛时脑抽。）

```cpp
#include<bits/stdc++.h>
#define N 500005
#define int long long
using namespace std;

const int mod = 20051131;
int n,top[N],ans;
struct node
{
	int id,h,v;
}a[N];
bool cmp(node x,node y)
{
	return x.h > y.h;
}

int fac[N];
void init()
{
	fac[0] = 1;
	for(int i = 1;i <= n;i++)fac[i] = fac[i-1] * i % mod; 
}

signed main()
{
	scanf("%lld",&n);
	for(int i = 1;i <= n;i++)
	{
		scanf("%lld",&top[i]);
	}
	init();
	for(int i = 1;i <= n;i++)
	{
		int fa = top[i];
		a[fa].h++;
	}
	sort(a+1,a+1+n,cmp);
	ans = fac[a[1].h-1];
	int sum = a[1].h;
	for(int i = 2;a[i].h;i++)
	{
		a[i].v = fac[a[i].h-1];
		int cnt = sum-(i-1)*a[i].h%mod;
		ans = ans * cnt % mod * a[i].v % mod;
		sum += a[i].h;
	}
	printf("%lld\n",ans);
	return 0;
}
```

感谢阅读！

---

## 作者：_O_v_O_ (赞：1)

~~蛤我会做蓝色的组合了！？~~

设 $len_i$ 为 $top$ 数组中 $i$ 的出现次数，很显然 $len_i$ 为 $i$ 的链长。

先考虑长链内部，很显然非 $top$ 的可以任意重排，那么贡献就是 $(len_i-1)!$。

然后考虑长链之间，很显然假如有两条 $x,y$，很显然若 $x>y$，才有接上去的方法，有 $x-y$ 种。

那么我们不妨按链长 $len$ 降序排序，那么 $i$ 只能接到前面的去，那么方案就是 $\sum_{j=1}^{i-1} (len_j-len_i)=\sum_{j=1}^{i-1} len_j-(i-1)\times len_i$，前缀和即可。

为啥这是蓝，下位绿还差不多？？？？？？？？

---

## 作者：Scean_Tong (赞：1)

## P11159 【MX-X6-T5】 再生

### Problem
给你一棵树长链剖分完的链头 $t_i$，求有多少棵不同的树长链剖分完的也是这个。

### Solution
很好玩的数数题也不算难。

不管你学没学过树链剖分最起码都知道 $t_i$ 相同的在同一条链上，所以用桶简单维护就可以求出每条链的长度，对于一棵树如果想让它满足条件就一定要按链的长短从大到小排序然后短的往大的上面接，第一个送分 Subtask 很有启发，就是如果不考虑短的往大的上面接，就是树的形态为一条链时，链头是没有贡献的，所以对于一条长度为 $l$ 的链，它自己的贡献是 $(l-1)!$。

考虑别的贡献，将一条短的链往长的链上面接，排完序之后第 $i$ 长的链可以往前面 $i-1$ 长的链上面接，设第 $i$ 条链长度为 $l_i$，那么这条链的贡献就是 $\sum^{i-1}_{j=1}(l_j - l_i)$，把每条链的拼接贡献乘起来再乘上每条链单独的贡献即为答案，时间复杂度是 $O(n^2)$ 的，但是这玩意就一个 $\sum^{i-1}_{j=1}(l_j - l_i)$ 是瓶颈，随便用一种你喜欢的能维护前缀的东西维护即可，下面代码使用的是线段树，时间复杂度 $O(n \log n)$。


```cpp
#include <bits/stdc++.h>
#define int long long
constexpr int maxn = 5e5 + 7, L = 0, R = 1, mod = 20051131;
#define ls a[k].son[L]
#define rs a[k].son[R]
struct node{
	int son[2];
	int sum, tag;
}a[maxn << 2];
int n, m, v[maxn], root, t[maxn], fac[maxn];
inline void pushup(int k){
	a[k].sum = a[ls].sum + a[rs].sum;
}
int k, cnt;
inline void build(int &k, int l, int r){
	k = ++cnt;
	if(l == r){
		a[k].sum = v[l];
		return;
	}
	int mid = (l + r) >> 1;
	build(ls, l, mid);
	build(rs, mid + 1, r);
	pushup(k);
}
inline void addtag(int k, int l, int r, int val){
	a[k].sum += (r - l + 1) * val;
	a[k].tag += val;
}
inline void pushdown(int k, int l, int r){
	int mid = (l + r) >> 1;
	addtag(ls, l, mid, a[k].tag);
	addtag(rs, mid + 1, r, a[k].tag);
	a[k].tag = 0;
}
inline void update(int k, int l, int r, int ql, int qr, int val){
	if(ql == l && qr == r){
		addtag(k, l, r, val);
		return ;
	}
	int mid = (l + r) >> 1;
	pushdown(k, l, r);
	if(qr <= mid) update(ls, l, mid, ql, qr, val);
	else if(ql > mid) update(rs, mid + 1, r, ql, qr, val);
	else{
		update(ls, l, mid, ql, mid, val);
		update(rs, mid + 1, r, mid + 1, qr, val);
	}
	pushup(k);
}
inline int query(int k, int l, int r, int ql, int qr){
	if(ql == l && qr == r){
		return a[k].sum;
	}
	int mid = (l + r) >> 1;
	pushdown(k, l, r);
	if(qr <= mid) return query(ls, l, mid, ql, qr);
	else if(ql > mid) return query(rs, mid + 1, r, ql, qr);
	else return query(ls, l, mid, ql, mid) + query(rs, mid + 1, r, mid + 1, qr);
}
inline bool cmp(int a, int b){
	return a > b;
}
int32_t main(){
	std::cin.tie(nullptr) -> std::ios::sync_with_stdio(false);
	std::cin >> n;
	fac[0] = 1;
	for(int i = 1; i <= n; i++){
		fac[i] = fac[i - 1] * i % mod;
	}
	for(int i = 1; i <= n; i++){
		std::cin >> t[i];
		v[t[i]]++;
	}
	std::sort(v + 1, v + n + 1, cmp);
	m = 1;
	while(v[m + 1]){
		m++;
	}
	build(root, 1, n);
	int ans = 1;
	for(int i = 1; i <= m; i++){
		ans = ans * fac[query(root, 1, n, i, i) - 1] % mod;
		if(i > 1)ans = ans * (query(root, 1, n, 1, i - 1) - (i - 1) * query(root, 1, n, i, i)) % mod;
	}
	std::cout << ans << '\n';
	return 0;
}
```

---

## 作者：modfish_ (赞：1)

## 思路
显然每一条链上的节点有 $(cnt-1)!$ 中排列方法（其中 $cnt$ 是链的长度）。故答案先乘上 $\prod(cnt-1)!$。

对于两条链，显然只能是短的拼到长的上面去。考虑将链按长度排序，设第 $i$ 长的链长度为 $a_i$。

此时，对于第 $x$ 条链，它可以拼到前 $x-1$ 条链上，拼到第 $i$ 条链上的方案数为 $a_i-a_x$（因为不能比第 $i$ 条链的深度还深），所以共有 $\sum_{i=1}^{x-1}a_i-a_x$ 种。

所以答案是：

$$\prod_{i=1}^m(a_i-1)!\times \prod_{x=1}^m\sum_{i=1}^{x-1}(a_i-a_x)$$

可以 $O(n)$ 计算。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int maxn = 5e5 + 5, p = 20051131;

int t[maxn], cnt[maxn], m = 0;
ll a[maxn], fac[maxn];

int main(){
    int n;
    scanf("%d", &n);
    fac[0] = 1;
    for(int i = 1; i <= n; i ++){
        scanf("%d", &t[i]);
        cnt[t[i]] ++, fac[i] = fac[i - 1] * i % p;
    }
    for(int i = 1; i <= n; i ++) if(cnt[i]) a[++ m] = cnt[i];
    sort(a + 1, a + m + 1);
    ll ans = 1, sum = a[m];
    for(int i = m; i >= 1; i --){
        if(i < m) ans = ans * (sum + p - a[i] * (m - i) % p) % p, sum = (sum + a[i]) % p;
        ans = ans * fac[a[i] - 1] % p;
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：Dovish (赞：1)

## 题解

首先，考虑一条重链内部可以任意重排列，所以一条重链的答案就是 $(len-1)!$。

然后考虑链之间的连接方式：

1. 显然是长度小的链连向长度大的。

2. 对于一条长度为 $k$ 的链，要连到一条长度为 $m$ 的链上，总共有 $m-k$ 个位置可以选择。

于是答案就是:
$$
\prod_i(len_i-1)!\times \prod_{i}\sum_{len_j>len_i}(len_j-len_i)
$$

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define per(i,a,b) for(register int i=(a);i>=(b);--i)
#define edge(i,u) for(int i=head[u];i;i=e[i].next)
#define lc (u<<1)
#define rc (u<<1|1)
#define pii pair<int,int>
#define pdd pair<double,double>
#define mp(a,b) make_pair(a,b)
#define pb(a) push_back(a)
#define fst first
#define sed second
using namespace std;
const int N=5e5+10,M=1e6+10,inf=1e9,mod=20051131;
const double eps=1e-6;
struct modint{
......
};//取模类
modint qpow(modint a,int b){
	modint res=1;
	while(b)
	{
		if(b&1)res=res*a;
		a=a*a;
		b/=2;
	}
	return res;
}
int n;
modint cnt[N],sum[N],jc[N];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	jc[0]=1;
	rep(i,1,N-1)jc[i]=jc[i-1]*i;
	cin>>n;
	rep(i,1,n)
	{
		int u;
		cin>>u;
		cnt[u]+=1;
	}
	sort(cnt+1,cnt+n+1);
	rep(i,1,n)sum[i]=sum[i-1]+cnt[i];
	modint ans=1;
	rep(i,1,n-1)
	if(cnt[i].val!=0)
	{
		ans=ans*(modint(n)-sum[i]-modint(n-i)*cnt[i]);
	}
	rep(i,1,n)
	if(cnt[i].val!=0)ans=ans*jc[cnt[i].val-1];
	cout<<ans<<'\n';
}
```

---

## 作者：Lijiangjun4 (赞：0)

# P11159 题解
## 解题思路
[长链剖分](https://oi-wiki.org/graph/hld/#%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86)是一种把一棵树拆分成若干条链的方法。对于一棵树，将树上的点分成两类：**重子节点**和**轻子节点**。树的根节点为轻子节点，对于每个非叶子节点，其**最高的子树的根节点**为重子节点，其余的均为轻子节点。向重子节点连的边称为**重边**，向轻子节点连的边为**轻边**。首尾相连的重边称为**长链（注意这里的定义与 OI-Wiki 有所不同）**，把落单的点也看做长链，则整棵树被拆成若干条长链。如图（图来源于 OI-Wiki）:
![](https://cdn.luogu.com.cn/upload/image_hosting/826a9ogy.png)

回到题目。发现题目对高度的定义有点神奇，对于一个节点 $u$，由于 $h_u=\max\limits_{v \in s_u}h_v+1$，所以以 $v$ 作为根节点的子树就是 $u$ 的最高子树，即点 $v$ 为轻子节点，边 $(u,v)$ 为重边。又由于这样的 $u$，$v$ 满足 $t_u=t_v$，其余轻点满足 $t_{v'}=v'$，所以我们得到结论：**$t_i$ 表示节点 $i$ 所在长链的链首。**

现在，题目给出所有的长链，求这些长链能组成多少满足条件的树。定义 $a_i$ 表示第 $i$ 长的链的长度（用桶维护链长度后排序即可得到），由于链首是确定的，所以这条链上的点有 $A^{a_i-1}_{a_i-1}=(a_i-1)!$ 种排序方式。再考虑这条链能挂在哪些链的哪些点上。显然，长度 $a_i$ 的链只能挂在长度 $a_j>a_i$ 的链上，并且只能挂在这条链上的 $a_j-a_i$ 个点上，如图：
![](https://cdn.luogu.com.cn/upload/image_hosting/cu34br39.png)

所以，这个点一共能挂在 $\sum\limits_{j=1}^{i-1}a_j-a_i$ 个点上。

设有 $m$ 条链，运用乘法原理，我们得到这道题的答案为：
$$
\begin{aligned}
&\prod_{i=1}^{m}(a_i-1)!\times\prod_{i=1}^{m}\sum_{j=1}^{i-1}(a_j-a_i)\\
=&\prod_{i=1}^{m}(a_i-1)!\times\prod_{i=1}^{m}\left(\sum_{j=1}^{i-1}a_j-(i-1)a_i\right)
\end{aligned}
$$

其中 $\sum\limits_{j=1}^{i-1}a_j$ 可以前缀和得到，复杂度 $O(n)$。
## 完整代码
~~关于第一次我写了一遍线段树这件事~~

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
namespace io{
long long read()
{
	long long res=0,neg=1;
	char c='\0';
	while((c=getchar())<'0'||c>'9')
	{
		if(c=='-') neg=-1;
	}
	while(c>='0'&&c<='9')
	{
		res=(res<<1)+(res<<3)+c-'0';
		c=getchar();
	}
	return res*neg;
}
void uwrite(long long x)
{
	if(!x) return;
	uwrite(x/10);
	putchar(x%10+'0');
	return;
}
void write(long long x)
{
	if(x<0) putchar('-'),x=-x;
	if(x==0)
	{
		putchar('0');
		return;
	}
	uwrite(x);
	return;
}
void writel(long long x)
{
	write(x);
	putchar('\n');
}
void writes(long long x)
{
	write(x);
	putchar(' ');
}
}
using namespace io;
long long n,m,a[500005],fact[500005];
const int mod=20051131;
int sum[500005];
long long ans=1;
int main()
{
	n=read();
	fact[0]=1;
	for(int i=1;i<=n;i++)
	{
		int t=read();
		a[t]++;
		fact[i]=fact[i-1]*i%mod;
	}
	sort(a+1,a+n+1,[](int a,int b){return a>b;});
	for(m=1;a[m+1];m++);
	for(int i=1;i<=m;i++) sum[i]=(sum[i-1]+a[i])%mod;
	for(int i=1;i<=m;i++)
	{
		ans=ans*fact[a[i]-1]%mod;
	}
	for(int i=2;i<=m;i++)
	{
		ans=ans*(sum[i-1]-(i-1)*a[i])%mod;
	}
	writel(ans);
	return 0;
}

```
[AC 记录](https://www.luogu.com.cn/record/207336345)

---

## 作者：biyi_mouse (赞：0)

首先根据树链剖分 $top$ 的定义，所以给出 $top$ 相等的点一定在一条链上，其中 $top$ 等于本身的点就是链的最顶端。假设链的长度为 $k$，那链内部的排列方式就是 $(k - 1)!$。

所以问题相当于现在有很多个链，我们只需要考虑链和链的连接。容易发现对于两条长分别为 $x,y\ (x > y)$ 的链，一定是 $y$ 挂在 $x$ 上。同时为了保证重链一定是 $x$ 对应的链，那么 $y$ 就不能挂在链 $x$ 深度在 $x - y$ 以下的结点上，所以 $y$ 挂 $x$ 的方案为 $(x - y) !$。

那么我们可以按照链的长度排序，设有 $m$ 个链，$h_i$ 为链 $i$ 的长度，答案就应该是：

$$\prod_{i = 2}^{m} [(i-1)!\times \sum_{j = 1}^{i - 1}(h_j - h_i)] $$

不难发现可以预处理阶乘，同时前缀和优化掉内部的求和。

```cpp
const int N = 500010, Mod = 20051131;
LL n, top[N], h[N], s[N], fac[N]; 

int main() {   
    n = read();
    rep(i, 1, n) top[i] = read();
    
    rep(i, 1, n) h[top[i]] ++;
    sort(h + 1, h + 1 + n, [&](LL a, LL b) {
        return a > b;
    });
    fac[0] = 1;
    rep(i, 1, n) fac[i] = fac[i - 1] * i % Mod;
    
    LL ans = fac[h[1] - 1], S = h[1];
    for (int i = 2; i <= n && h[i]; i ++) {
        ans = ans * fac[h[i] - 1] % Mod * ((S - (i - 1) * h[i]) % Mod) % Mod;
        S += h[i];  
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：gyyyyx (赞：0)

首先考虑如何确定根，由于是长链剖分，根所在的链必定的最长链，那么 $\text{top}$ 数组中出现最多的数字 $u$ 便是根。

那 $top_i=u$ 的 $i$ 都在根所在的链上。

之后我们类比可以找到第二长链、第三长链……

显然某条链只能挂在比它长的链的节点上，同时还要满足挂上去之后不会使得出现一条更长的链。

设从长到短的每条链的长度为 $p_{1\sim m}$，对于两条链 $k_1,k_2$（$p_{k_1}<p_{k_2}$），$k_1$ 能挂在 $k_2$ 上的节点数有 $p_{k_2}-p_{k_1}$ 个。

那么第 $k$ 长链（$k>1$）可以挂的节点个数为：

$$\sum\limits_{i=1}^{k-1}p_i-(k-1)p_k$$

显然无论一条链上节点如何排列都不影响其它链的 $\text{top}$ 数组值，因此一条链可以有 $p_i!$ 种排列顺序。

因此答案为：

$$p_1!\cdot\prod\limits_{i=2}^mp_i!\cdot\Big(\sum\limits_{j=1}^{i-1}p_j-\big(i-1\big)p_i\Big)$$

利用前缀和和桶排可以优化到 $O(n)$。

代码：

```cpp
#include<bits/stdc++.h>
#define N 500005
#define mod 20051131
using namespace std;
int n,p[N],cnt[N],fac[N],ans;
int main(){
	scanf("%d",&n);
	for(int i(1);i<=n;++i)
	{int tp;scanf("%d",&tp);++p[tp];}
	for(int i(0);i<=n;++i) ++cnt[p[i]];
	for(int i(n),j(0);~i;--i)
		while(cnt[i]--) p[++j]=i;
	fac[0]=1;for(int i(1);i<p[1];++i) fac[i]=1ll*fac[i-1]*i%mod;
	ans=fac[p[1]-1];
	for(int i(2),s(p[1]);p[i];++i)
		ans=1ll*ans*fac[p[i]-1]%mod*(s-(i-1)*p[i])%mod,s+=p[i];
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：xiezheyuan (赞：0)

## 简要题意

有一个有根树，将其长链剖分后得到第 $i$ 个点的长链顶端为 $t_i$。保证 $t_i$ 总是唯一的。

给定 $t$，你需要求出有多少个有根树满足条件。保证至少存在一个这样的有根树。

$1\leq n\leq 5\times 10^5$。

## 思路

首先考虑给出的这个链顶序列确定了树的什么信息。

根据长链剖分的性质，它提供了我们树上的若干条链，并且连接这些链有一定的限制。

回到本题，不妨将提供的所有链从大到小排序，由于长链剖分的性质，我们一定是将长度小的链连接到长度大的链上。

首先长度最大的链一定是根节点所在的链，链上的点除了链顶外可以任意重排，这一部分贡献形如 $(x-1)!$。

然后考虑一般的链，我们记这是第 $k$ 长的链，第 $i$ 长的链长度为 $h_i$。

考虑到这个链也是可以任意重排的，所以它造成的贡献就是 $(h_k-1)!$。

然后考虑我们需要将这条链连接到之前的某一条链上，之前的链上并不是每个点都可以成为这条链的链顶的父节点，我们需要保证唯一长链的性质。

容易列出这样的式子：

$$
(h_k-1)\sum_{j=1}^{k-1}(h_j-h_k)
$$

直接计算，时间复杂度为 $O(n^2)$。可以用前缀和优化一下。

时间复杂度 $O(n\log n)$，精细的实现可以做到 $O(n)$。

## 代码

```cpp
#include <bits/stdc++.h>
//#define int long long
using namespace std;

const int N = 5e5 + 5;
int n, a[N], b[N], fact[N];

constexpr int mod = 20051131;
int Add(int x, int y){ return (x + y) >= mod ? (x + y - mod) : (x + y); }
int Sub(int x, int y){ return (x - y) < 0 ? (x - y + mod) : (x - y); }
int Mul(int x, int y){ return 1ll * x * y % mod; }

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin >> n;
    for(int i=1;i<=n;i++) cin >> a[i], b[a[i]]++;
    sort(b + 1, b + n + 1, greater<int>());
    fact[0] = 1;
    for(int i=1;i<=n;i++) fact[i] = Mul(fact[i - 1], i);
    int ans = 1, pre = 0;
    for(int i=1;i<=n;i++){
        if(!b[i]) break;
        ans = Mul(ans, Mul(fact[b[i] - 1], (i == 1) ? 1 : Sub(pre, Mul(b[i], i - 1))));
        pre = Add(pre, b[i]);
    }
    cout << ans << '\n';
    return 0;
}

// Written by xiezheyuan
```

---

## 作者：Mr_RoastFish (赞：0)

其他大佬的题解都写得非常好了，这里补充一个点：为什么要从最长链开始由长到短计算链合并成树的方案数。

其实推一推两个样例就出来了。

如果我们先拼短链，会较大概率出现两个链长度相同的情况（样例二中 $top_i$ 为 $2$ 和 $9$ 的点各一个）。这时候是没法将两个长度相同的链进行合并的，因为无论怎么合并都会破坏长链剖分的性质。而从最长的链开始合并，因为最长的链只会有一条（链顶为树根的那一条，样例一的解释图也很明确），保证了前两条链不会长度相同，第三条链的长度肯定小于第一、二条链的合并链长度，以此类推至最短链均成立，保证了合并链的正确性。

最后别忘了用前缀和优化时间复杂度就好。

---

## 作者：SuperCowHorse (赞：0)

很明显，对于所有 $t$ 值相等的节点 $i$，必定在同一条链上，其根为 $t_i$。设这条链上有 $n$ 个节点，那么容易确定，这条链有 $(n-1)!$ 种不同的排列顺序（根是确定的，其它可以按任意顺序排）。

这样，我们可以把问题转化成：把每一条链依次接到比它节点数多的任意一条链上，求方案数。

假设有两条链，一条长度为 $m$，一条长度为 $n$（$m<n$），则有 $(n-m)$ 种方案。（因为是长链剖分，要满足子树中剖出来的链最长）

至于维护，排序以后前缀和可以做到 $O(n)$ 求。

所以根据乘法原理，把上面两个答案乘起来即可。

（所以只有我会重链剖分还想了这么久吗）

Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=5e5+5;
const ll mod=20051131;
int n,a[maxn],m,b[maxn];ll fac[maxn],ans=1,sum;
vector<int>p[maxn];
inline bool cmp(int u,int v){return u>v;}
signed main(){
	scanf("%d",&n);fac[0]=1;
	for(int i=1;i<=n;++i){
		fac[i]=fac[i-1]*i%mod;
	}
	for(int i=1;i<=n;++i){
		scanf("%d",&a[i]);
		p[a[i]].push_back(i);
	}
	for(int i=1;i<=n;++i){
		int x=p[i].size();
		if(!x) continue;
		(ans*=fac[x-1])%=mod;//链的形态个数
		b[++m]=x;//计算每条链的节点个数
	}
	sort(b+1,b+1+m,cmp);
	for(int i=1;i<=m;++i){
		if(i==1){
			sum+=b[i];
			continue;
		}
		(ans*=1ll*(sum-b[i]*(i-1)))%=mod;//计算
		sum+=b[i];//前缀和
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：wwwwwza (赞：0)

对于一条长度为 $h$ 的链，其重组方案有 $(h-1)!$ 个。

对于两条长度为 $h_1,h_2(h_1>h_2)$ 的链，考虑将第二条链挂到第一条链上，为了满足长链剖分的性质，只能挂在第一条链的前 $h_1-h_2$ 个点上。

对于每条链，其都可以挂在长度大于这条链的链上。

设每条链的长度数组为 $h$，$h$ 从大到小排序，长度为 $tot$。

则 $ans=(h_1-1)!\times \prod\limits_{i=2}^{tot} ((h_i-1)!\times \sum\limits_{j=1}^{i-1}(h_i-h_j))$。

前缀和一下即可。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+10;
const int mod=20051131;
const int inf=0x3f3f3f3f;
int n,x,h[N],id[N],tot=0,fac[N],ans;
bool cmp(int p,int q){
	return p>q;
}
signed main(){
	cin >>n;
	fac[0]=1;
	for(int i=1;i<=n;i++){
		fac[i]=i*fac[i-1]%mod;
		cin >>x;
		if(!id[x])id[x]=++tot;
		h[id[x]]++;
	}
	sort(h+1,h+1+tot,cmp);
	ans=fac[h[1]-1];
	for(int i=2,sum=h[1];i<=tot;i++){
		ans=(ans*fac[h[i]-1]%mod)*(sum-(i-1)*h[i]%mod+mod)%mod;
		sum=(sum+h[i])%mod;
	}
	cout <<ans;
	return 0;
}

```

---

## 作者：w9095 (赞：0)

[P11159 【MX-X6-T5】再生](https://www.luogu.com.cn/problem/P11159)

简单数学题。

首先根不同肯定是在诈骗，最长的链的链顶就是树根。然后考虑一条长链内，除了链顶都可以随意排序，对于每条链，答案乘上链中元素数量减一的阶乘。

然后考虑把这些链提取出来，重新拼接成一棵树。注意到如果先拼短链再拼长链，长链会影响到短链，限制较多，而先拼长链再拼短链限制更容易满足，考虑先拼长链。

对于每一条拼过的链，为了满足其长链剖分性质，如果这条链的长度为 $siz[i]$，则长度为 $siz[j]$ 的新拼的链只能拼在较高的 $siz[i]-siz[j]$ 个位置中，否则会破坏长链剖分性质。不难发现对于每一条拼过的链都有这个限制，而我们已经拼上去的链的总长度是已知的，拼过的链的数量也是已知的，所以减去的总量也是已知的，两者做差就是这条链的拼接方案数，乘法原理贡献到答案里即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,a[600000],c[600000],s[600000],jc[600000],siz[600000],ans=1,cnt=0;
const long long mod=20051131;
int main()
{
	scanf("%lld",&n);
	jc[0]=1;
	for(int i=1;i<=n;i++)jc[i]=jc[i-1]*i%mod,siz[i]=0;
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]),siz[a[i]]++;
	for(int i=1;i<=n;i++)
	    {
	    	if(siz[i]==0)continue;
	    	c[++cnt]=siz[i],ans=ans*jc[siz[i]-1]%mod;
		}
	sort(c+1,c+cnt+1);
	for(int i=cnt;i>=1;i--)s[i]=s[i+1]+c[i];
	for(int i=1;i<=cnt-1;i++)ans=ans*(s[i]-(cnt-i+1)*c[i])%mod;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：NTT__int128 (赞：0)

# P11159 【MX-X6-T5】再生 题解
我们可以根据 $t$ 数组确定这棵树被剖成的每条链的节点数与链顶。假设有 $k$ 条链，第 $i$ 条链链顶为 $a_i$，长度为 $l_i$，则这条链内部的顺序有 $(l_i-1)!$。

现在考虑链与链之间的连边。假设现在我们有 $l_1\ge l_2\ge\cdots\ge l_k$，则第 $1$ 条链的链顶一定为树根，第 $2$ 条链有 $l_1-l_2$ 种放置方法，第 $3$ 条链有 $(l_1-l_3)+(l_2-l_3)$ 种放置方法，……，第 $i$ 条链有 $\sum\limits_{j=1}^{i-1}(l_j-l_i)=(\sum\limits_{j=1}^{i-1}l_j)-l_i\times(i-1)$ 种放置方法。

于是，总方案数为 $(\prod\limits_{i=1}^{k}(l_i-1)!)\times(\prod\limits_{i=2}^{k}((\sum\limits_{j=1}^{i-1}l_j)-l_i\times(i-1)))$。阶乘预处理。

时间复杂度：$\Theta(n)$。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+5,M=20051131;
int n,t[N],jc[N],cnt,c[N];
struct node{
	int a,l;
	bool operator<(const node&_)const{
		return l>_.l;
	}
}x[N];
signed main(){
	cin>>n;
	jc[0]=1;
	for(int i=1;i<=n;i++)jc[i]=(jc[i-1]*i)%M;
	for(int i=1;i<=n;i++)cin>>t[i],c[t[i]]++;
	for(int i=1;i<=n;i++)if(t[i]==i)cnt++,x[cnt].a=i,x[cnt].l=c[i];
	sort(x+1,x+cnt+1);
	int s=x[1].l,ans=jc[x[1].l-1];
	for(int i=2;i<=cnt;i++)ans=(((ans*jc[x[i].l-1])%M)*(s-x[i].l*(i-1)))%M,s+=x[i].l;
	cout<<ans;
	return 0;
}
```

---


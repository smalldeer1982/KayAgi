# [RMI 2021] 去 M / NoM

## 题目背景


译自 [9th Romanian Master of Informatics, RMI 2021](https://rmi.lbi.ro/rmi_2021/) D2T1。$\texttt{0.2s,0.5G}$。

## 题目描述


有 $N$ 个绿色的石子，标号 $1\sim N$。

有 $N$ 个灰色的石子，标号 $1\sim N$。

将 $2N$ 个石子任意排成一列，两个相邻石子的距离为 $1$。定义 $\mathrm{dist}(i)$ 为绿色的上面标有 $i$ 的石子与灰色的上面标有 $i$ 的石子的距离。

给定正整数 $M$。若存在 $1\le i\le N$，使得 $M\mid \mathrm{dist}(i)$，我们就说这样的排列方式是**不好的**（因为可能会导致 IDE 卡死）。否则我们就说这样的排列方式是**好的**。

求出好的排列方案数，对 $(10^9+7)$ 取模。

两种排列方案相同，当且仅当对应石子颜色和编号都相同。



## 说明/提示


对于 $100\%$ 的数据，保证 $1\le M\le N\le 2\, 000$。


| 子任务编号 | $N,M\le  $ |得分 |  
| :--: | :--: |  :--: |
| $ 1 $    | $ 5 $  | $9$ |
| $ 2 $    | $ 100 $  | $12$ |
| $ 3 $    | $ 300 $  | $13$ |
| $ 4 $    | $ 900 $  | $18$ |
| $ 5 $    | $ 2\, 000$  | $48$ |

## 样例 #1

### 输入

```
100 23```

### 输出

```
171243255```

## 样例 #2

### 输入

```
1 1```

### 输出

```
0```

## 样例 #3

### 输入

```
3 2```

### 输出

```
288```

## 样例 #4

### 输入

```
300 300```

### 输出

```
929890502```

# 题解

## 作者：_Ch1F4N_ (赞：3)

首先标号什么的最后再考虑，先只对无标号（但是区分颜色）方案算，等于说你要把 $[1,2 \times n]$ 对半染色再匹配。

对好方案算不太方便，考虑算所有坏方案，其实这个也不方便，但是我们可以容斥，不妨 $dp_i$ 表示至少有 $i$ 对距离为 $m$ 倍数的匹配的方案，所有坏方案就是 $\sum_i dp_i \times (-1)^{i+1}$。问题变成如何求解 $dp_i$。

要对距离为 $m$ 倍数的匹配相关计数，注意到距离为 $m$ 倍数时匹配的两个位置模 $m$ 同余并且不同余数间互不影响，对于每个余数求出 dp 数组后再合并的过程可以视作一个树上背包，不难发现其是 $O(n^2)$ 的。

最后的问题就是 $2 \times t$ 个数对半染色再两两匹配的方案数，先确定每种颜色的集合再确定匹配，可以得到方案数就是 ${{2 \times t} \choose t} \times t!$，预处理下组合数即可做到 $O(n^2)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod = 1e9+7;
const int maxn = 4e3+114;
int fac[maxn],inv[maxn];
int iv[maxn];
int qpow(int a,int b){
    if(b==0) return 1;
    if(b==1) return a;
    int res=qpow(a,b/2);
    res=res*res%mod;
    if(b%2==1) res=res*a%mod;
    return res;
}
int dp[maxn];//全局选取 j 对的方案
int C(int n,int m){
    if(n<m) return 0;
    return fac[n]*inv[m]%mod*inv[n-m]%mod;
}
int n,m,ans;
signed main(){
    fac[0]=inv[0]=1;
    for(int i=1;i<maxn;i++) fac[i]=fac[i-1]*i%mod,inv[i]=qpow(fac[i],mod-2);
    cin>>n>>m;
    n*=2;
    ans=C(n,n/2)*fac[n/2]%mod;
    if(n<=m){
        cout<<ans*fac[n/2]%mod<<'\n';
        return 0;
    }
    dp[0]=1;
    int sum=0;
    for(int p=0;p<m;p++){
        int cnt=(n-p)/m+(p==0?0:1);
        for(int i=sum;i>=0;i--){
             for(int j=1;j*2<=cnt;j++) dp[i+j]=(dp[i+j]+dp[i]*C(cnt,j*2)%mod*C(j*2,j)%mod*fac[j]%mod)%mod;
        }
        sum+=(cnt/2);
    }
    for(int j=1;j<=sum;j++){
        if(n-2*j!=0) dp[j]=dp[j]*C(n-2*j,(n-2*j)/2)%mod*fac[(n-2*j)/2]%mod;
        ans=(ans+dp[j]*(j%2==0?1:(mod-1))%mod)%mod;
    }
    cout<<ans*fac[n/2]%mod<<'\n';
    return 0;
}
```

---

## 作者：水星湖 (赞：1)

这个题显然要容斥，设 $f_i$ 表示钦定了 $i$ 对不合法的方案数，那么答案就是 $\sum_{i=0}^n (-1)^i f_i$。考虑 $f_i$ 怎么算，我们可以先选出来 $i$ 对满足 $M\mid \mathrm{dist}$ 的位置（不考虑颜色和标号），再乘上 $\binom{n}{i}i!2^i(2n-2i)!$（先选 $i$ 种颜色作为不合法的，顺序是 $i!$，又因为颜色不同算不同的所以再乘 $2^i$，剩下 $(2n-2i)$ 个位置任意）就是 $f_i$。现在我们只需要考虑算出从 $2n$ 个位置中选出 $i\in[0,n]$ 对的方案数，由于模 $m$ 不同的位置是互不影响的，可以独立出来，设模 $m$ 为 $k$ 的位置有 $x$ 个，则从这些位置中选出 $j$ 个不合法的方案数为 $\binom{x}{2j}(2j-1)!!=\frac{x!}{(x-2j)!2^jj!}$（选点方案数乘两两配对方案数），于是就可以背包 dp 求出了。

可以做到 $O(n \log n \log m)$。但是由于我不会多项式且不让 ai 题解，就把做法放[剪贴板](https://www.luogu.com.cn/paste/cqjz613o)了。

```cpp
#include <bits/stdc++.h>
using namespace std;

namespace z {

#define int long long
const int N = 4e3 + 5, mod = 1e9 + 7;
int n, m, f[N][N], c[N][N], fac[N], ifac[N], pw2[N], ipw2[N];
int qpow(int a, int b = mod - 2) {
    int res = 1;
    while(b) {
        if(b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}
void main() {

    ios::sync_with_stdio(false);
    cin.tie(nullptr);cout.tie(nullptr);
    cin >> n >> m; 
    ifac[0] = ifac[1] = fac[0] = fac[1] = 1; c[0][0] = 1;
    pw2[0] = ipw2[0] = 1;
    for(int i = 1; i <= 4000; i++) {
        pw2[i] = pw2[i - 1] * 2 % mod; ipw2[i] = qpow(pw2[i]);
        fac[i] = fac[i - 1] * i % mod; ifac[i] = qpow(fac[i]);
    }
    for(int i = 1; i <= 4000; i++) {
        c[i][0] = c[i][i] = 1; 
        for(int j = 1; j < i; j++)
            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
    }
    f[0][0] = 1;
    for(int i = 1; i <= m; i++) {
        int x = 1 + (2 * n - i) / m;
        for(int s = 0; s <= n; s++)
            for(int j = 0; j <= min(x / 2, s); j++) {
                f[i][s] = (f[i][s] + f[i - 1][s - j] * c[x][2 * j] % mod 
                * fac[2 * j] % mod * ipw2[j] % mod * ifac[j] % mod) % mod;
            }
    }
    for(int i = 0; i <= n; i++) 
        f[m][i] = f[m][i] * fac[2 * (n - i)] % mod * fac[i] 
        % mod * c[n][i] % mod * pw2[i] % mod;
    int ans = 0;
    for(int i = 0; i <= n; i++) 
        if(i & 1) ans = (ans - f[m][i] + mod) % mod; 
        else ans = (ans + f[m][i]) % mod;
    cout << ans << '\n'; 

}

#undef int

}


int main()
{
    z::main();
    return 0;
}
```

---

## 作者：wangyibo201026 (赞：1)

其实是 NOIP 前最后复习计数了,对吗?

## solution

首先把求好的转化为求不好的,这样我们可以对于每个 $i$ 求出 $f_i$ 表示至少有 $i$ 对可以距离被整除的对,然后我们可以根据容斥算出好的排列个数。

现在问题转化为了求 $f_i$,不难发现,对于模 $m$ 同余的位置,我们可以分成一组,一组中至少有 $i$ 对是好算的,而我们需要将 $m$ 组不同的余数答案合并起来。这是一个类似于树上背包合并的过程。

不过需要注意的是排列可能会算重,所以钦定完 $\frac{n}{2}$ 个位置后最后再计算剩余 $\frac{n}{2}$ 的位置填数的顺序。

## code

code:

```cpp
#include <bits/stdc++.h>
 
using namespace std;
 
#define int long long
#define fir first
#define sec second
#define mkp make_pair 
#define pb push_back
#define lep( i, l, r ) for ( int i = ( l ); i <= ( r ); ++ i )
#define rep( i, r, l ) for ( int i = ( r ); i >= ( l ); -- i )
 
typedef unsigned long long ull;
typedef long long ll;
typedef long double ld;
typedef pair < int, int > pii;
 
char _c; bool _f; template < class type > inline void read ( type &x ) {
	_f = 0, x = 0;
	while ( _c = getchar (), !isdigit ( _c ) ) if ( _c == '-' ) _f = 1;
	while ( isdigit ( _c ) ) x = x * 10 + _c - '0', _c = getchar (); if ( _f ) { x = -x; }
}
 
template < class type > inline void chkmin ( type &x, type y ) { x = ( x <= y ? x : y ); }
template < class type > inline void chkmax ( type &x, type y ) { x = ( x >= y ? x : y ); }

const int N = 4005;
const int mod = 1e9 + 7;

int n, m;
int f[N], fac[N], inv[N];

int fast_pow ( int a, int b ) {
  int res = 1;
  while ( b ) {
    if ( b & 1 ) {
      res = res * a;
      res %= mod;
    }
    b >>= 1;
    a = a * a;
    a %= mod;
  }
  return res;
}

int C ( int n, int m ) {
  if ( n < m ) {
    return 0;
  }
  return fac[n] * inv[n - m] % mod * inv[m] % mod;
}

void Solve () {
  cin >> n >> m;
  n <<= 1;
  fac[0] = inv[0] = 1;
  for ( int i = 1; i <= n; i ++ ) {
    fac[i] = fac[i - 1] * i % mod;
    inv[i] = fast_pow ( fac[i], mod - 2 );
  }
  if ( n <= m ) {
    cout << fac[n >> 1] * fac[n >> 1] % mod * C ( n, n >> 1 ) % mod;
    return ;
  }
  int sum = 0, ans = fac[n >> 1] * C ( n, n >> 1 ) % mod;
  f[0] = 1;
  for ( int i = 0; i < m; i ++ ) {
    int siz = ( n - i ) / m + !!i;
    for ( int j = sum; j >= 0; j -- ) {
      for ( int k = 1; k <= siz / 2; k ++ ) {
        f[j + k] += f[j] * C ( siz, 2 * k ) % mod * C ( 2 * k, k ) % mod * fac[k] % mod;
        f[j + k] %= mod;
      }
    }
    sum += siz / 2;
  }
  for ( int i = 1; i <= sum; i ++ ) {
    if ( i & 1 ) {
      ans -= f[i] * C ( n - 2 * i, ( n - 2 * i ) / 2 ) % mod * fac[( n - 2 * i ) / 2] % mod;
      ans %= mod;
    }
    else {
      ans += f[i] * C ( n - 2 * i, ( n - 2 * i ) / 2 ) % mod * fac[( n - 2 * i ) / 2] % mod;
      ans %= mod;
    }
  }
  cout << ( ans * fac[n >> 1] % mod + mod ) % mod;
}
 
signed main () {
#ifdef judge
  freopen ( "Code.in", "r", stdin );
  freopen ( "Code.out", "w", stdout );
  freopen ( "Code.err", "w", stderr );
#endif
  Solve ();
  return 0;
}
```

---

## 作者：苏联小渣 (赞：1)

考虑二项式反演，要求**恰好**有 $0$ 对数的距离是 $m$ 的倍数的方案，可以设 $f_i$ 表示**钦定**有 $i$ 对，剩下任意填的方案，那么答案就是 $\sum _{i=0}^n (-1)^i f_i$。

现在转化成了不合法的计数，那么我们按照模 $m$ 的余数分类，因为满足 $m\mid \text{dist}(i)$ 的 $i$ 所处的位置必定模 $m$ 同余。假设当前考虑到 $\bmod m=x,x=0,1,...,m-1$，有 $y$ 个位置 $\bmod m=x$，那么至多能匹配 $\lfloor \dfrac{y}{2}\rfloor$ 对。如果要匹配 $z$ 对，那么容易得到方案是 ${y \choose 2z} \times (2z)!$，分别表示选择 $2z$ 个位置和内部任意排序，不妨将其记为 $g(x,z)$。

那么我们能求出在一个同余类中匹配若干对的方案数，要求 $f$ 就可以通过背包得到了。对于一个同余类 $\bmod m=x$，假设匹配 $z$ 对，那么有转移 $f_{i+z} \gets {n-i \choose z} \times g(x,z) \times f_i$。最后要注意剩下的任意填，所以 $f_i \gets f_i \times (2(n-i))!$，再二项式反演回去即可。同余类总的大小是 $2n$，每次做背包，总的时间复杂度 $O(n^2)$。

### Code:

```c++
#include <bits/stdc++.h>
using namespace std;
int n, m, tot, ans, c[4010][4010], f[2010], jc[4010];
const int mo = 1e9 + 7;
int main(){
	scanf ("%d%d", &n, &m);
	c[0][0] = jc[0] = 1;
	for (int i=1; i<=2*n; i++){
		c[i][0] = 1;
		jc[i] = 1LL * jc[i-1] * i % mo;
		for (int j=1; j<=i; j++){
			c[i][j] = (c[i-1][j] + c[i-1][j-1]) % mo;
		}
	}
	f[0] = 1;
	for (int i=1; i<=m; i++){
		int S = (2*n) / m;
		if ((2*n) % m >= i) S ++;
		tot += S/2;
		for (int j=tot; j>=1; j--){
			for (int k=1; k<=min(j, S/2); k++){
				f[j] = (f[j] + 1LL * f[j-k] * c[n-(j-k)][k] % mo * c[S][k*2] % mo * jc[k*2] % mo) % mo;
			}
		}
	}
	for (int i=0; i<=n; i++){
		f[i] = 1LL * f[i] * jc[2*(n-i)] % mo;
		if (i % 2 == 0) ans = (ans + f[i]) % mo;
		else ans = (ans - f[i] + mo) % mo;
	}
	printf ("%d\n", ans);
	return 0;
}
```

---

## 作者：流水行船CCD (赞：1)

难点在于发现本题是容斥而非容斥本身。

## 思路

设 $f_i$ 表示钦定有 $i$ 对石子（其余石子任意）之间距离是 $M$ 的倍数的方案数，$g_i$ 表示恰好有 $i$ 对石子之间距离是 $M$ 的倍数的方案数。

通过二项式反演，我们只需求出 $f$ 数组，即可求出答案 $g_0$。

取模自然想到剩余类，发现石子之间距离是 $M$ 的倍数当且仅当该对石子位于同一模 $M$ 意义下的剩余类。考虑沿剩余类 dp。

设 $l_i$ 表示第 $i$ 个剩余类大小。$h_{i,j}$ 表示前 $i$ 个剩余类，放了 $j$ 对相同剩余类中的石子的方案数，转移可以去选择当前剩余类放置多少对石子进行计算，其中 $C$ 用于确定这 $k$ 对石子的颜色集合，$A$ 用于确定这 $k$ 对石子的位置：

$$
f_{i,j+k} = \sum_{j,k} f_{i-1,j} \times C_{n-j}^{k} \times A_{l_i}^{2k}
$$

显然有：$f_i = h_{i,j} (2n-2j)!$，即确定其他 $n-j$ 对无限制石子的放置方案。

提一下时间复杂度分析，发现一对 $(j,k)$ 会被枚举到当且仅当 $j$ 在 $<i$ 的剩余类中，$k$ 在 $i$ 的剩余类中，因此任意一对 $(j,k)$ 至多被枚举一次，$O(N^2)$。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;
namespace fast_IO {
#define ld cin
#define jyt cout
}
using namespace fast_IO;
#define REP(i, l, r) for (int i = l; i <= r; ++i)
#define PER(i, l, r) for (int i = l; i >= r; --i)
#define clean(name) memset(name, 0, sizeof(name))
#define memst(name, n) memset(name, 0, (n + 1) * sizeof(name[0]))
// #define int long long
constexpr int N = 2000 + 7;
constexpr int P = 1e9 + 7;
namespace JoKing {
    int n, m; ll f[N][N], fac[N << 1], inv[N << 1], Ans;
    inline long long qpow(long long x, long long y) {long long R = 1; for (; y; (x *= x) %= P, y >>= 1ll) if (y & 1ll) (R *= x) %= P; return R;}
    inline ll C(int x, int y) {return x < y ? 0 : fac[x] * inv[y] % P * inv[x - y] % P;}
    inline ll A(int x, int y) {return x < y ? 0 : fac[x] * inv[x - y] % P;}
    signed main() {
        ld >> n >> m, fac[0] = 1;
        if (m == 1) return jyt << '0' << '\n', 0;
        REP(i, 1, (n << 1)) fac[i] = fac[i - 1] * i % P;
        inv[n << 1] = qpow(fac[n << 1], P - 2);
        PER(i, (n << 1), 1) inv[i - 1] = inv[i] * i % P;
        int Accepted = 0; f[0][0] = 1;
        REP(i, 1, m) {
            int len = ((n << 1) - i) / m + 1, cnt = (len >> 1); Accepted += cnt;
            REP(j, 0, Accepted - cnt) REP(k, 0, cnt) (f[i][j + k] += f[i - 1][j] * A(len, k << 1) % P * C(n - j, k)) %= P;
        }
        REP(i, 0, n) (f[m][i] *= fac[(n << 1) - (i << 1)]) %= P;
        REP(i, 0, n) (Ans += 1ll * (i & 1 ? P - 1 : 1) * f[m][i]) %= P;
        jyt << Ans << '\n';
        return 0;
    }
}
signed main() {
#ifdef WYY
    freopen("files/code.in", "r", stdin);
    freopen("files/code.out", "w", stdout);
    freopen("files/code.err", "w", stderr);
#endif
     ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    JoKing::main(); return 0;
}
```

---

## 作者：Unnamed114514 (赞：1)

正难则反，考虑定义 $f_i$ 表示至少有 $i$ 对满足 $M\mid dist$，然后显然可以通过二项式答案。

这样相当于我们弱化了题目的限制，在满足这 $i$ 对放好的情况下，剩下的随便放，那么世纪方案数就是 $f_i(2n-2i)!$。

注意到题目的条件等价于两个位置模 $M$ 同余，那么我们设模 $M$ 为 $i$ 的位置有 $a_i$ 个（令 $a_M=a_0$ 便于处理），那么这个问题就变得很简单了：

我们定义 $dp_{i,j}$ 表示我们当前处理到了模 $M$ 为 $i$ 的组，目前一共有 $j$ 对，显然我们枚举这个组里面选了 $k$ 对，那么有转移：

$dp_{i,j}\gets\sum\limits_{k=0}^j dp_{i-1,j-k}A_{a_i}^{2k}C_{n-(j-k)}^k$

排列数是在这 $a_i$ 个里面选位置的方案，组合数是从剩下的 $n-(j-k)$ 中选 $k$ 个的方案。

显然 dp 可以滚动，接下来我们要证明的是时间复杂度。

显然 $k$ 有个上界是 $a_i$，然后 $a_i$ 有个显然的上界是 $\dfrac{N}{M}$。

那么我们可以估算时间复杂度的量级 $M\times\dfrac{N}{M}\times\dfrac{N}{M}=\dfrac{N^2}{M}=O(N^2)$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2005,mod=1e9+7;
int n,m,f[N],a[N],fac[N<<1],inv[N<<1];
int qpow(int a,int b){
	int s=1;
	while(b){
		if(b&1) s=s*a%mod;
		a=a*a%mod,b>>=1;
	}
	return s;
}
int A(int n,int m){ return fac[n]*inv[n-m]%mod; }
int C(int n,int m){ return fac[n]*inv[n-m]%mod*inv[m]%mod; }
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	fac[0]=1;
	for(int i=1;i<=(n<<1);++i) fac[i]=fac[i-1]*i%mod;
	inv[n<<1]=qpow(fac[n<<1],mod-2);
	for(int i=(n<<1)-1;~i;--i) inv[i]=inv[i+1]*(i+1)%mod;
	for(int i=1;i<=m;++i) a[i]=(2*n)/m+(i<=(2*n)%m);
	f[0]=1;
	for(int i=1;i<=m;++i) for(int j=n;~j;--j) for(int k=1;k<=min(j,a[i]/2);++k) f[j]=(f[j]+f[j-k]*A(a[i],2*k)%mod*C(n-(j-k),k))%mod;
	for(int i=0;i<=n;++i) f[i]=f[i]*fac[2*n-2*i]%mod;
	int ans=0,p=1;
	for(int i=0;i<=n;++i,p=p*(mod-1)%mod) ans=(ans+p*f[i]%mod)%mod;
	cout<<ans<<endl;
	return 0;
}
```

---


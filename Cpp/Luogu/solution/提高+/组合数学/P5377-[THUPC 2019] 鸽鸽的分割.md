# [THUPC 2019] 鸽鸽的分割

## 题目描述

牛牛有一块蛋糕，他想把蛋糕分给小朋友们。蛋糕一开始是圆形的，牛牛会在圆周上选择 $n$ 个不重合的点，将这几个点两两用线段连接。这些线段将会把蛋糕分成若干块。

现在，牛牛想知道，蛋糕**最多**会被分成多少块，请你告诉他答案。

## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/pic/58696.png)

##### 版权信息

来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。

## 样例 #1

### 输入

```
2
3
4```

### 输出

```
2
4
8```

# 题解

## 作者：Imagine (赞：59)

将整幅图看作平面图，套用欧拉公式：$F - E + V = 2 \Rightarrow F = E - V + 2$。

其中：

- 顶点数 $V = n + \binom{n}{4}$。
	- $n$：圆上原本的点的数量。
	- $\binom{n}{4}$：任意四个点形成的两条线段均会产生一个交点。
- 边数 $E = n + \binom{n}{2} + 2\binom{n}{4}$。
	- $n$：圆上原本的 $n$ 个点将圆分成了 $n$ 条弧。
   - $\binom{n}{2} + 2\binom{n}{4}$：每两个点之间存在一条线段。每一个交点会将相交的两条线段分成四部分，即增加两条线段。

因此，$F = n + \binom{n}{2} + 2\binom{n}{4} - n - \binom{n}{4} + 2 = 2 + \binom{n}{2} + \binom{n}{4}$。

注意到平面图包含无限面，而应该计算的是圆内的区域，因此答案应减 $1$。

故答案即为 $1 + \binom{n}{2} + \binom{n}{4}$。

时间复杂度 $O(1)$。

代码：

~~~cpp
#include<bits/stdc++.h>

using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);
  int n;
  while (cin >> n) {
    int binom2 = n * (n - 1) / 2;
    int binom4 = n * (n - 1) / 2 * (n - 2) / 3 * (n - 3) / 4;
    cout << (binom2 + binom4 + 1) << '\n';
  }
  return 0;
}
~~~

---

## 作者：米奇奇米 (赞：28)

## 哇！一眼找规律好题（逃
### 首先我们画几个圆，再画很多很多条线，发现：
| $n$ | $ans$ |
| -----------: | -----------: |
| $1$|  $1$|
| $2$|  $2$|
| $3$|  $4$|
| $4$|  $8$|
| $5$|  $16$|
| $6$|  $31$|
### 以上都是正常人靠画图能够得出来的，于是我们开始差分两两数字
### 首先求出两数之差：的出表格
| $n-(n-1)$ | $dx$ |
| -----------: | -----------: |
| $2-1$ |  $1$|
| $3-2$ |  $2$|
| $4-3$ |  $4$|
| $5-4$ |  $8$|
| $6-5$ |  $15$|

### 这样大概可以看出规律啦，我们再次差分两两数字，在得出两数之差的表格
| $n-(n-1)$ | $dx$ |
| -----------: | -----------: |
| $2-1$ | $1$ |
| $3-2$ | $2$ |
| $4-3$ | $4$ |
| $5-4$ | $7$ |
### 此时规律就显而易见啦，最后打出来的表格数字差为$1,2,3,4...$
### 于是就上各阶段打出来的表：
```cpp
const int f[]={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65};
const int ff[]={1,2,4,7,11,16,22,29,37,46,56,67,79,92,106,121,137,154,172,191,211,232,254,277,301,326,352,379,407,436,466,497,529,562,596,631,667,704,742,781,821,862,904,947,991,1036,1082,1129,1177,1226,1276,1327,1379,1432,1486,1541,1597,1654,1712,1771,1831,1892,1954,2017,2081};
const int res[]={1,2,4,8,15,26,42,64,93,130,176,232,299,378,470,576,697,834,988,1160,1351,1562,1794,2048,2325,2626,2952,3304,3683,4090,4526,4992,5489,6018,6580,7176,7807,8474,9178,9920,10701,11522,12384,13288,14235,15226,16262,17344,18473,19650,20876,22152,23479,24858,26290,27776,29317,30914,32568,34280,36051,37882,39774,41728,43745};
const int ans[]={1,2,4,8,16,31,57,99,163,256,386,562,794,1093,1471,1941,2517,3214,4048,5036,6196,7547,9109,10903,12951,15276,17902,20854,24158,27841,31931,36457,41449,46938,52956,59536,66712,74519,82993,92171,102091,112792,124314,136698,149986,164221,179447,195709,213053,231526,251176,272052,294204,317683,342541,368831,396607,425924,456838,489406,523686,559737,597619,637393,679121,722866,722866,722866,722866,722866};
```

### $ans[x-1]$就是最后的结果啦！



---

## 作者：qwaszx (赞：21)

这题不是组合数学经典例题吗...

设$h_n$是$n$个点的答案，那么考虑从$n-1$转移到$n$

![](https://cdn.luogu.com.cn/upload/image_hosting/vlifojyb.png)

考虑最下面那个点，首先它会把最下面那个弓形分成$n$份，比原来多了$n-1$个区域;然后对于原来$n-1$个点中的任意三个点，这三个点钟正中间的点可以和新点连接把这个三角形分成两份，这一部分新增的空间是$\binom{n-1}{3}$，所以我们得到

$$h_n=h_{n-1}+\binom{n-1}{3}+\binom{n-1}{1}$$

以及

$$h_1=1$$

所以展开递归式就得到

$$h_n=1+\sum_{i=1}^{n-1}\binom{i}{3}+\sum_{i=1}^{n-1}\binom{i}{1}=1+\binom{n}{4}+\binom{n}{2}$$

就$O(1)$做完了(

感觉这题的推式子难度也就蓝?

```cpp
#include<iostream>
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
    int n;
    while(scanf("%d",&n)==1)
    {
        printf("%d\n",1+n*(n-1)/2+n*(n-1)*(n-2)*(n-3)/24);
    }
}
```

---

## 作者：Tangent233 (赞：12)

蒟蒻没想到这么简单就AC了我第一个紫，我简单讲讲我事怎么找规律的（居然和题解都不一样www）。

我们就以$n=7$的情况举例吧。

我们先画一个**圆**，然后顺时针给每个点标上序号。

[![rzVfw4.png](https://s3.ax1x.com/2021/01/01/rzVfw4.png)](https://imgchr.com/i/rzVfw4)

我们先从1号点开始给别的点连线，表示切了一刀，然后计算这一刀给答案做的贡献，也就是切完这一刀后增加了多少块区域

[![rzZOg0.png](https://s3.ax1x.com/2021/01/01/rzZOg0.png)](https://imgchr.com/i/rzZOg0)

[![rzeuUH.png](https://s3.ax1x.com/2021/01/01/rzeuUH.png)](https://imgchr.com/i/rzeuUH)

（由于在图上做太过混乱，于是我整理到了表格上）

没啥感觉？那我们再从2号点开始给别的点连线吧。

[![rzea5j.png](https://s3.ax1x.com/2021/01/01/rzea5j.png)](https://imgchr.com/i/rzea5j)

[![rzefi9.png](https://s3.ax1x.com/2021/01/01/rzefi9.png)](https://imgchr.com/i/rzefi9)

老天，看看这等差数列。你是不是有些摸到门道了？我们再从三号点出发。

[![rznMct.png](https://s3.ax1x.com/2021/01/01/rznMct.png)](https://imgchr.com/i/rznMct)

[![rznmhd.png](https://s3.ax1x.com/2021/01/01/rznmhd.png)](https://imgchr.com/i/rznmhd)

看到这，我们或许有一个大胆的猜想。

从第$i$个点出发，到其他的点所连成的线对答案的贡献所组成的数列是一个首项为$1$,项数为$n-i$,公差为$i-1$的等差数列！

真的是这样的吗？我们可以把剩下的点都统计完……

[![rznR3R.png](https://s3.ax1x.com/2021/01/01/rznR3R.png)](https://imgchr.com/i/rznR3R)

看起来是这样的呢（至于为什么最后面再解释吧……）。我们知道这一点那么程序就不难写了吧？

```cpp
#include<bits/stdc++.h>
using namespace std;
int qh(int s,int e,int gc)
{
    int answ=0,tmp=1;
    for(int i=s;i<=e;i++)
    {
        answ+=tmp;
        tmp+=gc;
    }
    return answ;
}//超级暴力的做法
int ans(int n)
{
    int answer=0;
    for(int i=1;i<n;i++)
        answer+=qh(i+1,n,i-1);
    return answer;
}
int main()
{
    int n;
    while(cin>>n) cout<<ans(n)+1<<endl;//别忘了我们一直统计的都是对答案的贡献，最后还要加上本身圆的一个区域
    return 0;
}
```
好的，到这里就可以$100pts$到手啦！

规律的解释（为了让题解能过……）：

首先我们得先知道**一个线段增加划分区域的个数为它经过区域的个数**，这不难理解，你每经过一个区域都会把这个区域分为两半，自然会把划分区域+1.

那么解释这个规律的关键就在于每个线段它经过了多少个区域，也可以看作是**穿过线段数加1**（因为一个区域不相交的$n$条线段会划分出$n+1$个区域）

如果按照我们探究规律时连接线段的顺序的话，那么对于任意一条从$s$连接到$e$（$s<e$）的线段，有两种可能

- 要么$e=s+1$,也就是两个点相邻，此时经过线段数为$0$,穿过区域为$1$（这就是为什么首项为1）
- 要么$e>s+1$,那么我们设中间的点数为$k=e-s-1$.不难理解按照我们连接的顺序，此时中间的每个点已经和其他点连接了$s-1$条线段，于是经过线段数为$k*(s-1)$，穿过区域为$k*(s-1)+1$（这就是为什么公差为$i-1$)

那么为什么项数为$n-i$呢？因为我们按照顺序不重复连边的话，从$i$号点至多能连出$n-i$条边（联想一下无向图……）

若有什么解释不清楚的话可以在评论问，私信问都可以。

---

## 作者：Warriors_Cat (赞：7)

## 一个~~PJ都没参加的~~蒟蒻的题解

首先，我们先把前几个答案写出来：

点数 $1\quad2\quad3\quad4\quad5\quad6\quad7\quad8$

方案 $1\quad2\quad4\quad8\quad16\quad31\quad57\quad99$

~~好像有点没对齐qwq~~

似乎没有规律，于是，将方案无脑相邻两项进行作差：

$1\quad2\quad4\quad8\quad15\quad26\quad42$

还是没规律，那就继续吧：

$1\quad2\quad4\quad7\quad11\quad16$

怎么还没有，继续下去：

${\color{red}1\quad2\quad3\quad4\quad5}$

诶？怎么是等差数列？？

至此，规律已出，接下来就是按照规律打代码就行了。

（其实我也不知道这规律怎么证TOT）

-------------------------~~丑陋的分割线~~-------------------------

## Code:

```
#include<bits/stdc++.h>
using namespace std;
long long n, a[110], b[110], c[110], d[110];
void work(){
    a[0] = b[0] = c[0] = d[0] = 1;
    for(int i = 1; i <= 64; ++i){
        a[i] = i + 1;
        b[i] = b[i - 1] + a[i - 1];
        c[i] = c[i - 1] + b[i - 1];
        d[i] = d[i - 1] + c[i - 1];
    }//计算上述规律
    return;
}
int main(){
    ios::sync_with_stdio(false);
    work();
    while(cin >> n){
        if(!n){
            cout << 1 << '\n';
            continue;
        }//注意特判，本蒟蒻被坑过一次QAQ
        cout << d[n - 1] << '\n';
    }
    return 0;//完美结束
}
```
以上就是本蒟蒻的思路，如有不懂者，欢迎留言。

## End

---

## 作者：A_Đark_Horcrux (赞：6)

### 【~~正解~~1】oeis

---

首先手算出前几项:
```
1 2 4 8 16 31 57
```
[oeis](http://oeis.org/)这个网站包含了大量的数列以及通项公式，还有来历之类。于是将"1 2 4 8 16 31 57"这个数列放到[oeis](http://oeis.org/)上一查！

```
Maximal number of regions obtained by joining n points around a circle by straight lines:

1, 2, 4, 8, 16, 31, 57, 99, 163, 256, 386, 562, 794, 1093, 1471, 1941, 2517, 3214, 4048, 5036, 6196, 7547, 9109, 10903, 12951, 15276, 17902, 20854, 24158, 27841, 31931, 36457, 41449, 46938, 52956, 59536, 66712, 74519, 82993, 92171, 102091, 112792, 124314, 136698 
```
### ~~启示1：一定要善用工具。~~

$$$$

可惜它只给出了44位QWQ

当然，我们应该锻炼自己找规律的能力：

### 【~~正解~~2】找规律

---
a[i] $\quad\quad\quad\quad\space\space$：1，2，4，8，16，31，57，99……

每两项之间的差 ： 1，2，4，8，15，26，42……

每两项之间的差的差 ：1，2，4，7，11，16……

#### 每两项之间的差的差的差 ：1，2，3，4，5……

### ~~启示2：千万不要放弃深入地找规律。~~
$$$$
递推一下即可。

### 【~~正解~~3】玄学的通项公式
---
不知道大家有没有看过洋葱数学。有一集真人秀里就讲到了这个问题的通项公式:

$a(n)=\frac{n^{4}-6n^{3}+23n^{2}-18n^{2}+24}{24}$.

### ~~启示3：洋葱数学是好东西。~~
$$$$

带入即可。这是怎么推出来的，直到现在我都不知道。
$$$$
```cpp
#include<cstdio>//非常没必要的代码XD
int x,i;
int main(){
	while(scanf("%d",&x)==1) printf("%d\n",(x*x*x*x-6*x*x*x+23*x*x-18*x+24)/24);
	return 0;
}
```



---

## 作者：小菜鸟 (赞：3)

一道不算太难的题...不知道为什么膜你赛现场没几个人想出来。  

我们看到这题涉及到将平面分割，便~~胡思乱想~~大胆猜想可以使用欧拉公式：  

$$F=E-V+2$$  

其中$F$为平面被分割后的块数，$E$为平面图的边数，$V$为点数。  

考虑如何求出边数和点数。  

首先有一点显然正确：最优解必定不存在三线共点的情况，即任意交点不会有超过两条线经过。  

那么我们就可以方便地计算边数和点数：  

枚举每一道刀迹，计算与其他刀迹的交点个数，即穿过它的刀迹数。  

由于任意两点皆有连线，因此交点个数$x$为刀迹两侧点数的乘积。  

于是每条边产生了平面图上的$x$个点、$x+1$条边。  

然后由于交点会算两次，答案除以二。再加上圆本身被分割出的$n$个点、$n$条边。  

最后要把平面图外无限的一部分去掉，所以答案减一。  

代码是$NOIP-$的难度...  

```cpp
#include<cstdio>

int n,V,E;

int main()
{
    while(scanf("%d",&n)!=EOF)
    {
        V=E=0;
        for(int i=0;i<n;++i)
        {
        	for(int j=i+1;j<n;++j)
        	{
        		int cross=(j-i-1)*(n-j+i-1);
        		V+=cross;
        		E+=cross+1;
        	}
        }
        V=V/2+n;
        E+=n;
        printf("%d\n",E-V+1);
    }
}
```



---

## 作者：yin_sy (赞：3)

## **题目描述**

牛牛有一块蛋糕，他想把蛋糕分给小朋友们。蛋糕一开始是圆形的，牛牛会在圆周上选择 n 个不重合的点，将这几个点两两用线段连接。这些线段将会把蛋糕分成若干块。n<=64

现在，牛牛想知道，蛋糕**最多**会被分成多少块，请你告诉他答案。
	（原文题意就挺简洁的，就不简化了）

这题看起来就像是道数学题（找规律题），**但我太菜了**，找不到规律。

首先我们画几张图（六个点就可以了），就可以发现没有三条边交于同一位置的情况是最好的。

如果三条边交于同一点，稍微调整一下一条边的位置，就可以使三个边两两的交点在不同位置，这三个交点会围处一块，就多出一块。

所以说构造出的这些点应该要满足连出的线没有三条边交于同一位置，容易发现是能构造出来的~~主要因为我不会构造~~，接下讲的所有图形都是满足这个条件的。

**然而又因为我太菜了**，不会直接计算n个点的图形，假设已经构造出了i-1个点在环上构造出的连边，再加入第i个点，并与i-1个点都连边，枚举与原先i-1个点哪一个连边，假设这一条连边有x个交点（包括在圆上的），这一条边上任意两个相邻的交点会把原先的一块变成两块，也就是这一条连边会使圆多出x-1块，求x的方法也很容易，从第i个点沿圆环（任意方向）到连边的那个点，若其中经过了k（不计第i个点和连边的那个点），那从圆环的另一方向走会经过i-2-k个点，从这两种点中任意各取一个点，他们的连边肯定会与现在连的这条边有一个交点，又因为没有三条边交于同一点，所以x就是k*(i-2-k)+2，答案增加k*(i-2-k)+1，如果按照顺序连边的话，k就是从0到i-2。

注意一开始块数等于1（一整个圆就算一块）。

题目下面的题解我点开后不知道在哪看QaQ,所以我写的可能和其中的相似，也极有可能讲的没其中的好~~所以我就是想水一下贡献~~。

这个数据范围<=64不太懂为什么，时间复杂度可以达到O(n^2),可能本来出题人不是想这样做的QaQ。

代码十分简短。

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
int n,i,j;
long long ans;//其实用int就够了
int main(){
	while (scanf("%d",&n)==1){
		ans=1;
		for (i=2;i<=n;i++){
			for (j=0;j<=i-2;j++)
				ans+=(i-2-j)*(j)+1;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```


---


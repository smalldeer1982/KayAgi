# 串串题

## 题目描述

给定长度分别为 $n,m$ 的整数序列 $A,B$ 和常数 $W,d$，序列从 $1$ 开始标号，保证 $A_i,B_i \in [1,W]$。

容易发现，我们有 $\binom{W}{d}$ 种方案选择 $[1,W]$ 中的 $d$ 个互不相同的整数。

对于每一种选择的方案，我们删去 $A$ 中出现的对应的 $d$ 种整数，令此时序列 $B$ 在序列 $A$ 中的出现次数为这次选择方案的权值。

你需要求所有的选择方案的权值和，对 ${10}^9+7$ 取模。

若对题意有疑问，请阅读样例及样例解释。

注：$\binom{a}{b}$ 表示组合数，含义为在 $a$ 个物品中**无序**地选择出 $b$ 个物品的方案数。

**请注意：我们并不会删除序列 $\bm{B}$ 中出现的对应整数。**

## 说明/提示

**【样例解释】**

在样例的第一组数据中：

1. 如果我们选择删去 $A$ 中的字符 $1$，$A$ 将变为 $\{2\}$，此时 $B$ 在 $A$ 中的出现次数为 $0$。
1. 如果我们选择删去 $A$ 中的字符 $2$，$A$ 将变为 $\{1,1,1\}$，此时 $B$ 在 $A$ 中的出现次数为 $2$。
1. 如果我们选择删去 $A$ 中的字符 $3$，$A$ 将变为 $\{1,1,2,1\}$，此时 $B$ 在 $A$ 中的出现次数为 $1$。

因此，第一组数据的答案为 $0+2+1=3$。

**再次提醒：我们并不会删除序列 $\bm{B}$ 中出现的对应整数。**

---

**【数据范围】**

对于 $100\%$ 的数据，$1 \le n,m,W \le {10}^6$，$1 \le d, A_i, B_j \le W$，$1 \le T \le 5$。

**本题采用捆绑测试且开启子任务依赖！**

| 子任务 | $n \le$ | $m \le$ | $W \le$ | 特殊性质 | 分数 | 依赖 |
| - | - | - | - | - | - | - |
| 1 | $10$ | $10$ | $5$ | | $10$ | \ |
| 2 | $1000$ | $1000$ | $5$ | | $20$ | 子任务 1 |
| 3 |  | | | A | $15$ | \ |
| 4 |  | | | B | $25$ | \ |
| 5 | | | | | $30$ | 子任务 1、2、3、4 |

特殊性质 A：保证 $d=1$。

特殊性质 B：令 $c$ 表示仅在序列 $A$ 中出现，而不在序列 $B$ 中出现的数字总数。保证 $c \le 5$。

## 样例 #1

### 输入

```
2
4 2 3 1
1 1 2 1
1 1
8 3 4 1
1 2 3 1 2 3 1 2
1 2 1
```

### 输出

```
3
2
```

# 题解

## 作者：syzf2222 (赞：10)

首先注意到，我们不能删去 $B$ 中出现的任意数字，我们不妨称这些数是关键的数。

而且，删掉不关键的数一定不会使得某个已经匹配的位置无法匹配上，因此我们可以先删去所有不关键的数（称删完的序列为 $C$），找到所有有可能匹配上的位置，可以使用 KMP 算法。

接下来我们枚举每个 $B$ 在 $C$ 中出现的位置，这一定是 $C$ 中一个长度为 $m$ 的区间。可以发现，每个方案的出现次数和之和，等于每个区间可以匹配上的方案数之和。

假设这段区间对应到 $A$ 中是区间 $[l,r]$，那么我们需要把 $[l,r]$ 中所有不关键的数删去，若区间 $[l,r]$ 中有 $t$ 个不关键的数，不关键的数总数为 $T$，那么方案数是 ${T-t\choose d-t}$，意义是我们强制选择这 $t$ 个数，其余的数我们还要选择 $d-t$ 个。

那么我们就要统计所有这样的区间中不关键的数数量，由于这些区间左右端点递增，可以使用尺取法计算。

时间复杂度：$O(n)$。

---

## 作者：Demeanor_Roy (赞：7)

- [原题链接](https://www.luogu.com.cn/problem/P9149)。

------------

我们将 $1 \sim w$ 中在 B 序列出现过的元素称作**关键元素**。

显然，对于一个可能产生贡献的选择方案，关键元素均不能选。于是我们记非关键元素的数量为 $c$。

将 A 序列中的关键元素按下标顺次提出来，得到下标序列 $p$。我们不妨对 $p$ 的每个长为 $m$ 的子串计算贡献。

当前子串能够产生贡献，当且仅当它与 B 序列完全相同。这一点可以用 kmp 进行判定。接下来我们需要考虑的是贡献系数。

对于子串 $p_i,p_{i+1},\dots,p_{i+m-1}$，显然区间 $[p_i,p_{i+m-1}]$ 内的非关键元素均需要被删除。
记其数量为 $o$。则该子串的贡献为 ${c-o} \choose {d-o}$。至于 $o$ 的维护，可以用双指针加桶实现。时间复杂度线性。

一个细节是，如果你 kmp 的写法会访问到 $B_{m+1}$，记得清空这个位置。否则只能通过后两个 Subtask。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1e6+10,mod=1e9+7;
int T,n,m,c,w,d,o,L,ans,a[N],b[N],p[N];
int nx[N],cnt[N],fct[N],inv[N],finv[N];
bool vis[N];
inline int read()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x;
}
inline int C(int x,int y){return y<0||x<y?0:1ll*fct[x]*finv[y]%mod*finv[x-y]%mod;}
inline void clear()
{
	c=o=L=ans=0;a[n+1]=b[m+1]=0;
	for(int i=1;i<=w;i++) cnt[i]=vis[i]=0; 
}
int main()
{
	fct[0]=inv[0]=finv[0]=fct[1]=inv[1]=finv[1]=1;
	for(int i=2;i<N;i++)
	{
		fct[i]=1ll*fct[i-1]*i%mod;
		inv[i]=(mod-1ll*mod/i*inv[mod%i]%mod)%mod;
		finv[i]=1ll*finv[i-1]*inv[i]%mod;
	}
	T=read();
	while(T--)
	{
		n=read(),m=read(),w=read(),d=read();clear();
		for(int i=1;i<=n;i++) a[i]=read();
		for(int i=1;i<=m;i++) b[i]=read(),vis[b[i]]=true;
		for(int i=1;i<=w;i++) if(!vis[i]) ++c;
		for(int i=1;i<=n;i++) if(vis[a[i]]) p[++L]=i;
		for(int i=2,j=0;i<=m;i++)
		{
			while(j&&b[i]!=b[j+1]) j=nx[j];
			if(b[i]==b[j+1]) ++j;nx[i]=j;
		}
		for(int i=1,j=0,l=1,r=0;i<=L;i++)
		{
			while(r<p[i])
			{
				++r;
				if(vis[a[r]]) continue;
				++cnt[a[r]];if(cnt[a[r]]==1) ++o;
			}
			if(i>=m)
				while(l<p[i-m+1])
				{
					if(!vis[a[l]]) 
					{
						--cnt[a[l]];
						if(!cnt[a[l]]) --o;
					}
					l++;
				}
			while(j&&a[p[i]]!=b[j+1]) j=nx[j];
			if(a[p[i]]==b[j+1]) ++j;if(j==m) ans=(ans+C(c-o,d-o))%mod;
		}
		printf("%d\n",ans);	
	}
	return 0;
}
```


---

## 作者：离散小波变换° (赞：5)

感觉不如上一题有意思。

## 题解

容易发现，计算所有方案的贡献之和，可以转化为计算每个可能的匹配的位置，在所有方案下匹配上 $B$ 的次数之和。假定 $A$ 数组里，原来在 $[l,r]$ 位置的数字在删数之后变成了一个 $B$（$l$ 位置和 $r$ 位置上的数字没有被删）。

容易注意到两条关键性质：

- 在 $B$ 里面的元素一定不会被删除；
- 妨碍形成一个匹配的元素一定会被删除。换言之，在 $[l,r]$ 内出现的不在 $B$ 里面的元素一定会被删掉。

考虑枚举 $l$ 的值。一个 $l$ 是合法的，当且仅当在删除所有不在 $B$ 里的元素后，$[l,r]$ 区间剩下来的元素恰好是 $B$。那么可以先把所有不在 $B$ 里的元素都删掉，然后跑一下 $\text{KMP}$，就知道哪些 $l$ 是合法的了。顺便可以知道 $r$ 的值。

然后就是统计 $[l,r]$ 区间出现了**多少种**不在 $B$ 里的元素。记这个种类数为 $a$。同时我们记 $B$ 里面出现的元素种类数为 $b$。

那么，$[l,r]$ 里出现的不在 $B$ 里的元素肯定要被删掉，$B$ 里出现的元素肯定不能被删，剩下来的数字可删可不删。也就是说，我们要从剩下的这 $W-a-b$ 个数里选择 $d-a$ 个数字删掉。

所以这个位置 $l$ 对答案的贡献就是 $\dbinom{W-a-b}{d-a}$。计算所有 $l$ 的贡献之和即可。

$l$ 可以直接枚举。对于 $r$，容易发现随着 $l$ 的增长 $r$ 也是单调的。那么对 $a$ 的维护可以看成一个双指针，每次 $l$ 增大后维护 $r$ 的值，开一个桶存一下此时 $[l,r]$ 区间内每个元素出现的次数。这样做的复杂度是 $\mathcal O(n)$。

整个的时间复杂度容易做到 $\mathcal O(W+\sum n_i)$。但是我太懒了没写线性求逆元，写了个 $\mathcal O(W\log W+\sum n_i)$ 的代码。

## 参考代码 

```cpp
#include<bits/stdc++.h>
#define up(l, r, i) for(int i = l, END##i = r;i <= END##i;++ i)
#define dn(r, l, i) for(int i = r, END##i = l;i >= END##i;-- i)
using namespace std;
typedef long long i64;
const int INF = 2147483647;
const int MAXN= 1e6 + 3;
const int MOD = 1e9 + 7;
int P[MAXN], Q[MAXN], o = 1e6;
int power(int a, int b){
    int r = 1;
    while(b){
        if(b & 1)r = 1ll * r * a % MOD;
        b >>= 1, a = 1ll * a * a % MOD;
    }
    return r;
}
int choose(int a, int b){
    if(a < 0 || b < 0 || a - b < 0) return 0;
    return 1ll * P[a] * Q[b] % MOD * Q[a - b] % MOD;
}
int qread(){
    int w=1,c,ret;
    while((c = getchar()) >  '9' || c <  '0') w = (c == '-' ? -1 : 1); ret = c - '0';
    while((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + c - '0';
    return ret * w;
}
int n, m, w, d;
int A[MAXN], B[MAXN], C[MAXN], D[MAXN], N[MAXN], T[MAXN];
int X[MAXN], Y[MAXN];
int main(){
    P[0] = Q[0] = 1;
    up(1, o, i)
        P[i] = 1ll * P[i - 1] * i % MOD, Q[i] = power(P[i], MOD - 2);
    up(1, qread(), _){
        n = qread(), m = qread(), w = qread(), d = qread();
        int t = 0, val = 0, res = 0;
        up(1, n, i) A[i] = qread();
        up(1, m, i) B[i] = qread(), val += !X[B[i]], X[B[i]] = true;
        up(1, n, i) C[i] = D[i] = N[i] = T[i] = 0;
        up(1, n, i) if(X[A[i]]) C[++ t] = A[i], D[t] = i;
        N[1] = 0, A[n + 1] = B[m + 1] = 0;
        up(2, m, i){
            int p = N[i - 1];
            while(p != 0 && B[p + 1] != B[i])
                p = N[p];
            if(B[p + 1] == B[i]) N[i] = p + 1; else N[i] = 0;
        }
        up(1, t, i){
            int p = T[i - 1];
            while(p != 0 && B[p + 1] != C[i])
                p = N[p];
            if(B[p + 1] == C[i]) T[i] = p + 1; else T[i] = 0;
        }
        int l = 1, r = 0, ans = 0;
        up(1, t, i) if(T[i] == m){
            int y = D[i], x = D[i - m + 1];
            while(r < y){
                ++ r; if(!X[A[r]] && Y[A[r]] == 0) ++ ans;
                if(!X[A[r]]) Y[A[r]] ++;
            }
            while(l < x){
                if(!X[A[l]]) -- Y[A[l]];
                if(!X[A[l]] && Y[A[l]] == 0) -- ans; ++ l;
            }
            res = (res + choose(w - val - ans, d - ans)) % MOD;
        }
        up(1, m, i) X[B[i]] = 0;
        up(1, n, i) Y[A[i]] = 0;
        printf("%d\n", res);
    }
    return 0;
}
```

---

## 作者：柳易辰 (赞：2)

# P9149 串串题 题解
&nbsp;
## 思路
设所有 $B$ 中的数构成集合 $S$。显然，对于 $S$ 中的任意元素，它一定不能被删除，不然这种情况没有任何贡献。

那么我们倒着考虑，先让 $A$ 中只剩下属于 $S$ 的元素，将残余的 $A$ 记为 $C$。将 $B$ 与 $C$ 匹配，就可以得到 $C$ 的哪些区间与 $B$ 匹配了。匹配可以使用 KMP。知道了这些区间后，我们可以倒推出 $C$ 在 $A$ 中对应的区间。对于每个区间，离线后我们容易知道区间里有哪些数，哪些是不能删的，哪些是必须删的，容易算出这个区间的贡献。

监狱区间的左端点和右端点均严格递增，离线算区间中数的数量可以用双指针扫一遍。

&nbsp;
## 示例

手捏一组样例加上图来说明。
```
9 3 5 2
1 2 3 1 2 3 4 1 2
1 2 1
```

### Step 1
![](https://cdn.luogu.com.cn/upload/image_hosting/wv89errd.png)
记录 $B$ 中出现的数字，得到 $C$。

### Step 2
将 $B$ 与 $C$ 匹配。
![](https://cdn.luogu.com.cn/upload/image_hosting/a7r62g2j.png)
### Step 3
![](https://cdn.luogu.com.cn/upload/image_hosting/ompzv7k5.png)
将 $C$ 中匹配的区间对到 $A$ 上，计算贡献。

&nbsp;
## 代码
```cpp
#include <stdio.h>
const int _(1000002), p(1e9 + 7);
bool f[_]; // 数字 i 是否出现过
int a[_], b[_], c[_];
int e[_]; // C 中每个数在 A 中的下标
int KMP[_], fact[_] = {1};
int l[_], r[_]; // 区间
int s[_]; // 桶，双指针的时候用
int inv(int x) // 计算逆元
{
    int i(p - 2), y(1);
    while (i) { if (i & 1) y = (long long)x * y % p; x = (long long)x * x % p, i >>= 1; }
    return y;
}
int calc(const int n, const int m) // 计算组合数
{
    return m >= 0 && n >= m ? (long long)fact[n] * inv(fact[n - m]) % p * inv(fact[m]) % p : 0;
}
int main()
{
    for (int i(1); i < _; ++i) fact[i] = (long long)fact[i - 1] * i % p; // 预处理逆元
    int x; scanf("%d", &x); while (x--) {
        int n, m, w, d, g(0), q(0), u(0), v(0); scanf("%d%d%d%d", &n, &m, &w, &d);
        // g 为 C 数组大小，q 为区间数量
        for (int i(1); i <= n; ++i) scanf("%d", &a[i]);
        for (int i(1); i <= m; ++i) scanf("%d", &b[i]), f[b[i]] = true;
        for (int i(1); i <= n; ++i) if (f[a[i]]) c[++g] = a[i], e[g] = i; // 将 A 中的数放入 C
        for (int i(1); i <= w; ++i) if (f[i]) ++d; // B 中出现的数，可以将它先加到 d 上，不然后面会重复
        for (int i(2), j(0); i <= m; ++i) // KMP 预处理
        {
            while (j && b[i] != b[j + 1]) j = KMP[j];
            j += b[i] == b[j + 1]; KMP[i] = j;
        }
        for (int i(1), j(0); i <= g; ++i) // KMP 匹配
        {
            while (j && c[i] != b[j + 1]) j = KMP[j];
            if (j < m && c[i] == b[j + 1]) ++j;
            if (j == m) l[++q] = e[i - m + 1], r[q] = e[i]; // 记录区间
        }
        for (int i(1), j(1), k(1), t(0); i <= n && k <= q; ++i) { // i 为右指针，j 为左指针
            if (!s[a[i]]++) ++t; // t 表示区间 [i, j] 中出现的数的数量，移动左指针
            if (r[k] == i) {
                while (j < l[k]) if (!--s[a[j++]]) --t; // 移动右指针
                v = (calc(w - t, d - t) + v) % p; ++k;
                // w - t 意思是区间 [i, j] 里出现的数是否删除已经确定
                // d - t 意思是有些数是必删的，需要先减掉，注意到前面已经将 d 加过了 B 中的数的数量，所以这里是减 t
        }   } printf("%d\n", v);
        for (int i(1); i <= n; ++i) s[i] = 0;
        for (int i(1); i <= m; ++i) b[i] = 0;
        for (int i(1); i <= w; ++i) f[i] = false; // 清空
    } return 0;
}
```

---

## 作者：Mr_Az (赞：2)

## Question 问题 [P9149 串串题](https://www.luogu.com.cn/problem/P9149)

[更好的体验](https://www.luogu.com.cn/blog/Mr-Az/P9149)

## Describe 题目描述

给定长度分别为 $n,m$ 的整数序列 $A,B$ 和常数 $W,d$，序列从 $1$ 开始标号，保证 $A_i,B_i \in [1,W]$。

定义权值为我们删去 $A$ 中出现的对应的 $d$ 种整数，令此时序列 $B$ 在序列 $A$ 中的出现次数。

你需要求所有的选择方案的权值和，对 ${10}^9+7$ 取模。

**请注意：我们并不会删除序列 $\bm{B}$ 中出现的对应整数。**

## Analysis 分析

观察题目我们会发现在 B 序列中出现的数比较特殊，若我们在 A 中删去的整数未在 B 序列中出现过，那他对我们目前匹配上的地方并不会造成任何影响。

我们这里记 A 序列中在 B 出现过的整数为重要的数，相反则为不重要的数。

所以我们可以把重要的数单独提取出来，记为 C 序列。

我们需要在 C 序列中匹配 B 序列，可以考虑使用 KMP 算法。令 [l,r] 为一段合法区间。

接下来只需要在 C 序列中枚举 B 序列出现的地方，同时我们对应到原序列 A 中。那么，[l,r] 里出现的不重要的数肯定要被删掉，相反地，这段区间内重要的数是一定不能被删除的。

设 a 是 [l,r] 内不重要的数，b 是 B 序列中数的种类，则此次方案（这段区间）的权值或者说对答案的贡献为 $C\tbinom{w-a-b}{d-a}$。

之后只需要统计这些合法区间中不重要的数，然后计算相应的贡献。

记住取模。

## Code 代码
```cpp
请自行训练写代码能力，若十分需要，可以咨询本人。
```

---

## 作者：OrezTsim (赞：1)

调了半天，原因是在没有输入 $w$ 的情况下 $\text{resize}$ $w$ 大小的 $\text{vector}$。

---

很直观的做法是把 $a_{1 \cdots n}$ 中没有在 $b_{1 \cdots m}$ 中出现过的数删掉，生成 $c_{1 \cdots len}$。

记录一个 $g_{1 \cdots len}$ 表示每一个 $c$ 中的元素原来在 $a$ 中的位置。

那么 $c$ 中对于每一个长度为 $m$ 的区间 $[l,r]$，可以发现，如果要它与 $b$ 匹配，那么需要在 $a$ 数组中删掉满足 $i \in [g_l,g_r]$ 且没有在 $b$ 中出现过的数 $a_i$。令这些 $a_i$ 去重后个数为 $t$。

钦定这 $t$ 个数之后，发现这个区间外面的数随便删。

令 $v$ 表示在 $b$ 中没出现过的数的个数。

那么方案数显然就是在没出现的剩余 $v-t$ 个数中选择 $d-t$ 个数。

也就是 $\binom{v-t}{d-t}$，如此平移区间就可以计算啦。

```cpp
#include <bits/stdc++.h>
#define int long long
using ull = unsigned long long;
using namespace std;

const int N = 1e6 + 10, P = 1e9 + 7;
const ull bas = 998244853; ull pw[N], has[N];
int t, n, m, w, d, a[N], b[N];
int inv[N], fac[N], ifac[N];

inline void init() {
    inv[0] = inv[1] = fac[0] = fac[1] = ifac[0] = ifac[1] = 1;
    pw[0] = 1, pw[1] = bas;
    for (int i = 2; i <= 1e6; ++i) {
        inv[i] = inv[P % i] * (P - P / i) % P;
        fac[i] = fac[i - 1] * i % P, ifac[i] = ifac[i - 1] * inv[i] % P;
        pw[i] = pw[i - 1] * bas;
    }
    return ;
}

inline int C(int x, int y) {
    if (x < 0 || y < 0 || x < y) return 0;
    return fac[x] * ifac[y] % P * ifac[x - y] % P;
} inline ull query(int l, int r) {
    return has[r] - pw[r - l + 1] * has[l - 1];
}

inline void solve() {
    vector <int> g, cnt; vector <bool> vis;
    cin >> n >> m >> w >> d; ull H = 0;
    g.push_back(0), cnt.resize(w + 10), vis.resize(w + 10);
    for (int i = 1; i <= n; ++i) cin >> a[i];
    for (int i = 1; i <= m; ++i) {
        cin >> b[i], vis[b[i]] = true;
        H = H * bas + b[i];
    }
    for (int i = 1; i <= n; ++i) if (vis[a[i]]) g.push_back(i);
    int siz = 0, all = 0, res = 0, len = g.size() - 1;
    if (len < m) return cout << 0 << endl, void();
    for (int i = 1; i <= w; ++i) if (!vis[i]) ++all;
    for (int i = 1; i <= m; ++i) has[i] = has[i - 1] * bas + a[g[i]];
    for (int i = g[1]; i <= g[m]; ++i)
        if (!vis[a[i]]) if (++cnt[a[i]] == 1) ++siz;
    (res += (query(1, m) == H) * C(all - siz, d - siz)) %= P;
    for (int i = 2; i + m - 1 <= len; ++i) {
        for (int j = g[i - 1]; j < g[i]; ++j)
            if (!vis[a[j]]) if (!(--cnt[a[j]])) --siz;
        for (int j = g[i + m - 2] + 1; j <= g[i + m - 1]; ++j)
            if (!vis[a[j]]) if (++cnt[a[j]] == 1) ++siz;
        has[i + m - 1] = has[i + m - 2] * bas + a[g[i + m - 1]];
        (res += (query(i, i + m - 1) == H) * C(all - siz, d - siz)) %= P;
    }
    return cout << res << endl, void();
}

signed main() {
    ios_base::sync_with_stdio(false); cin.tie(0), cout.tie(0);
    init(); cin >> t; while (t--) solve(); return 0;
}
```

---

## 作者：leiaxiwo (赞：0)

# 题解：P9149 串串题
[传送门](https://www.luogu.com.cn/problem/P9149)
### 题目分析
参考了[**Demeanor_Roy**](https://www.luogu.com.cn/article/dv7lq7zz)的解法。

这是一道有意思的选择问题；

由题意得，$B$ 序列的任意一个元素都不可以删除。我们将 $1 \to w$ 中在 $B$ 序列出现过的元素称作**关键元素**。

显然，对于一个可能产生贡献的选择方案，关键元素均不能选。于是我们记**非关键元素**的数量为 $c$。

将 $A$ 序列中的关键元素按下标顺次提出来，得到下标序列 $p$。我们对 $p$ 的每个长为 $m$ 的子串计算贡献：
当前子串能够产生贡献，**当且仅当**它与  $B$ 序列**完全相同**。这一点可以用 kmp 进行判定。

对于子串 $p_i,p_{i+1},\dots,p_{i+m-1}$，显然区间 $[p_i,p_{i+m-1}]$ 内的**非关键元素**均需要被删除。记其数量为 $o$。那么该字段的贡献就是 ${c-o} \choose {d-o}$。

### 参考代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7,N=1e6+5;
int T,n,m,c;
int w,d,o,L,ans;
int a[N],b[N],p[N];
int nxt[N],cnt[N],fct[N],in[N],unin[N];
bool vis[N];
struct __KMP{
	inline int initialization(int x,int y){
        return y<0||x<y?0:1ll*fct[x]*unin[y]%mod*unin[x-y]%mod;
	    }
    inline void overloaded(){
	    c=o=L=ans=0;
	    a[n+1]=0;
	    b[m+1]=0;
	    for(int i=1;i<=w;i++){
		    cnt[i]=0;
		    vis[i]=0;
	    }  
    }
}liver_KMP;
signed main(){
	fct[0]=in[0]=unin[0]=fct[1]=in[1]=unin[1]=1;
	for(int i=2;i<N;i++){
		fct[i]=1ll*fct[i-1]*i%mod;
		in[i]=(mod-1ll*mod/i*in[mod%i]%mod)%mod;
		unin[i]=1ll*unin[i-1]*in[i]%mod;
	}
	scanf("%lld",&T);
	while(T--){
		scanf("%lld%lld%lld%lld",&n,&m,&w,&d);
		liver_KMP.overloaded();
		for(int i=1;i<=n;i++){
			scanf("%lld",&a[i]);
		} 
		for(int i=1;i<=m;i++){
			scanf("%lld",&b[i]);
			vis[b[i]]=true;
		} 
		for(int i=1;i<=w;i++){
			if(!vis[i]){
				++c;
			} 
		} 
		for(int i=1;i<=n;i++){
			if(vis[a[i]]){
				p[++L]=i;
			} 
		} 
		for(int i=2,j=0;i<=m;i++){
			while(j&&b[i]!=b[j+1]){
				j=nxt[j];
			} 
			if(b[i]==b[j+1]){
				++j;
				nxt[i]=j;
			} 
		}
		for(int i=1,j=0,l=1,r=0;i<=L;i++){
			while(r<p[i]){
				++r;
				if(vis[a[r]]){
					continue;
				} 
				++cnt[a[r]];
				if(cnt[a[r]]==1){
					++o;
				} 
			}
			if(i>=m)
				while(l<p[i-m+1]){
					if(!vis[a[l]]){
						--cnt[a[l]];
						if(!cnt[a[l]]){
							--o;
						} 
					}
					l++;
				}
			while(j&&a[p[i]]!=b[j+1]){
				j=nxt[j];
			} 
			if(a[p[i]]==b[j+1]){
				++j;
			} 
			if(j==m){
				ans=(ans+liver_KMP.initialization(c-o,d-o))%mod;
			} 
		}
		printf("%lld\n",ans);	
	}
	return 0;
}
```

### 参考文献
[Demeanor_Roy——P9149 题解（2023 激励计划评分 7）](https://www.luogu.com.cn/article/dv7lq7zz)

---

## 作者：sangshang (赞：0)

# Preface

来写篇 Z 函数的题解。

# Solution

首先，注意到两个很显然的结论。

- 只能选序列 $B$ 中没出现过的数字删去。否则就会出现 $B$ 中有这个数字，而 $A$ 中没有，此时不可能匹配上，贡献为零。

- 如果选取一些 $A$ 中有，但 $B$ 中没有的数字删去，那能匹配的位置的数量单调不降。因为这个数字只在 $A$ 中出现，所以当在 $A$ 中匹配到这个数字时，一定会失配。把这个数字去掉也许还能继续匹配下去。

根据以上结论，还可以想到：如果先考虑去掉哪些字符，再考虑对答案的贡献并不实际。但如果先考虑想让一个位置贡献，需要去掉哪些字符，在计算答案，就容易得多。

1. 不妨先将 $A$ 中所有只在 $A$ 中出现的字符去掉，得到一个新序列，不妨记为 $A'$。

2. 计算 Z 函数，注意是 $B$ 的前缀匹配 $A'_i$ 开始的前缀。

3. 对于一个可以从 $A'_i$ 与 $B$ 匹配的 $i$，即 $Z_i\ge |B|$，计算至少需要删去哪几种数字才能原串从 $A'_i$ 对应的位置与 $B$ 匹配上。具体的，设 $A'_i$ 在原串上是从 $S_i$ 匹配到 $T_i$。从 $S_i$ 到 $T_i$ 扫一遍，记录有多少种只在 $A$ 中出现的数字，记作 $cnt$。此时对答案贡献，相当于钦定这 $cnt$ 种数字必须删，剩下随便选几个不在 $B$ 中出现的数字删，有几种方案，即 $C_{W-cnt'-cnt}^{d-cnt}$，$cnt'$ 表示 $B$ 中有几种数字。

4. 注意到 $S_i$ 和 $T_i$ 都有单调性，所以用双指针维护即可。

时间复杂度 $O(n+m)$。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5,maxW=1e6+5,mod=1e9+7;
bool in_B[maxW];
int A[maxn],B[maxn],in_B_cnt,P[maxn],Z[maxn];
int num_cnt[maxn];
class A_node{
	public:
		int val,id;
		A_node(int val,int id):val(val),id(id) {}
		A_node() {}
};
A_node A_[maxn];
//注意这里的 P 才是题解中的 Z 函数。
inline void Get_Z_Box(int tot,int m){
	memset(Z,0,sizeof(Z));
	memset(P,0,sizeof(P));
	Z[1]=m;
	for(int i=1;i+1<=m&&B[i]==B[i+1];++i){
		++Z[2];
	}
	int maxx=2;
	for(int i=3;i<=m;++i){
		if(maxx+Z[maxx]-1>=i){
			int i_=i-maxx+1;
			if(i_+Z[i_]-1>=Z[maxx]){
				Z[i]=Z[maxx]-i_+1;
				for(int j=Z[i];i+j<=m&&B[i+j]==B[j+1];++j){
					++Z[i];
				}
			}
			else{
				Z[i]=Z[i_];
			}
		}
		else{
			for(int j=0;i+j<=m&&B[i+j]==B[j+1];++j){
				++Z[i];
			}
		}
		if(i+Z[i]>maxx+Z[maxx]){
			maxx=i;
		}
	}
	int limit=min(tot,m);
	for(int i=1;i<=limit&&A_[i].val==B[i];++i){
		++P[1];
	}
	for(int i=1;i+1<=tot&&i<=m&&A_[i+1].val==B[i];++i){
		++P[2];
	}
	maxx=2;
	for(int i=3;i<=tot;++i){
		if(maxx+P[maxx]-1>=i){
			int i_=i-maxx+1;
			if(Z[i_]+i_-1>=P[maxx]){
				P[i]=P[maxx]-i_+1;
				for(int j=P[i];i+j<=tot&&j+1<=m&&A_[i+j].val==B[j+1];++j){
					++P[i];
				}
			}
			else{
				P[i]=Z[i_];
			}
		}
		else{
			for(int j=0;i+j<=tot&&j+1<=m&&A_[i+j].val==B[j+1];++j){
				++P[i];
			}
		}
		if(i+P[i]>maxx+P[maxx]){
			maxx=i;
		}
	}
}
inline int quick_pow(int bas,int mi){
	int res=1;
	for(;mi;mi>>=1){
		if(mi&1){
			res=((long long)res*bas)%mod;
		}
		bas=((long long)bas*bas)%mod;
	}
	return res;
}
int jc[maxn];
inline int C(int n,int m){
	return ((((long long)jc[n]*quick_pow(jc[m],mod-2))%mod)*(long long)quick_pow(jc[n-m],mod-2))%mod;
}
int main(){
	int T;
	scanf("%d",&T);
	jc[0]=1;
	for(int i=1;i<=1000000;++i){
		jc[i]=((long long)jc[i-1]*i)%mod;
	}
	while(T--){
		int n,m,W,d;
		memset(in_B,0,sizeof(in_B));
		memset(num_cnt,0,sizeof(num_cnt));
		in_B_cnt=0;
		scanf("%d%d%d%d",&n,&m,&W,&d);
		for(int i=1;i<=n;++i){
			scanf("%d",&A[i]);
		}
		for(int i=1;i<=m;++i){
			scanf("%d",&B[i]);
			if(!in_B[B[i]]){
				++in_B_cnt;
			}
			in_B[B[i]]=true;
		}
		if(W-in_B_cnt<d){
			printf("0\n");
			continue;
		}
		int tot=0;
		for(int i=1;i<=n;++i){
			if(in_B[A[i]]){
				A_[++tot].val=A[i];
				A_[tot].id=i;
			}
		}
		Get_Z_Box(tot,m);
		int L=1,R=0,cnt=0;
		long long ans=0;
		for(int i=1;i<=tot;++i){
			if(P[i]>=m){
				while(R+1<=A_[i+m-1].id){
					++R;
					++num_cnt[A[R]];
					if(num_cnt[A[R]]==1&&!in_B[A[R]]){
						++cnt;
					}
				}
				while(L<A_[i].id){
					--num_cnt[A[L]];
					if(!num_cnt[A[L]]&&!in_B[A[L]]){
						--cnt;
					}
					++L;
				}
				if(cnt<=d){
					ans=(ans+(long long)C(W-in_B_cnt-cnt,d-cnt))%mod;
				}
			}
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---


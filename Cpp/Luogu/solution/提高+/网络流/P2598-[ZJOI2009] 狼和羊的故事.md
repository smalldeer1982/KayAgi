# [ZJOI2009] 狼和羊的故事

## 题目描述

“狼爱上羊啊爱的疯狂，谁让他们真爱了一场；狼爱上羊啊并不荒唐，他们说有爱就有方向……”Orez 听到这首歌，心想：狼和羊如此和谐，为什么不尝试羊狼合养呢？说干就干！

Orez 的羊狼圈可以看作一个 $n\times m$ 的矩阵格子，这个矩阵的边缘已经装上了篱笆。可是 Drake 很快发现狼再怎么也是狼，它们总是对羊垂涎三尺，那首歌只不过是一个动人的传说而已。所以 Orez 决定在羊狼圈中再加入一些篱笆，还是要将羊狼分开来养。

通过仔细观察，Orez 发现狼和羊都有属于自己领地，若狼和羊们不能呆在自己的领地，那它们就会变得非常暴躁，不利于他们的成长。

Orez 想要添加篱笆的尽可能的短。当然这个篱笆首先得保证不能改变狼羊的所属领地，再就是篱笆必须修筑完整，也就是说必须修建在单位格子的边界上并且不能只修建一部分。

## 说明/提示

对于 $10\%$ 的数据，$n, m \le 3$。  
对于 $30\%$ 的数据，$n, m \le 20$。  
对于 $100\%$ 的数据，$1 \le n, m \le 100$。

## 样例 #1

### 输入

```
2 2
2 2 
1 1 ```

### 输出

```
2
```

# 题解

## 作者：AubRain (赞：73)

其实这题根本没有其它题解说的那么复杂。

建图方式：

1、原点向所有狼连流量 $inf$ 的边

2、所有羊向汇点连流量 $inf$ 的边

3、所有点向四周连流量为 $1$ 的边。

然后下面就没了。

求出最小割就是答案，不用考虑题解说的什么 $0$ 的归属问题。

为什么是对的？

所有狼和羊之间的边都被割掉了，相当于修了栅栏，所以是对的。


~~死因：n,m写反调了一个小时~~

```cpp
#include<bits/stdc++.h>
#define N 100005
#define INF 1<<29
#define num(i,j) ((i-1)*m+j)
using namespace std;

inline void rd(int &X){
    X=0;int w=0;char ch=0;
    while(!isdigit(ch))w|=ch=='-',ch=getchar();
    while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    X=w?-X:X;
}

int n,m,s,t,ans,f,k;
int head[N],cnt=1,d[N];
struct nd{int nxt,to,v;}e[N<<1];
#define For(x) for(int y,i=head[x];(y=e[i].to);i=e[i].nxt)

void add(int x,int y,int w){
    e[++cnt]=(nd){head[x],y,w};head[x]=cnt;
    e[++cnt]=(nd){head[y],x,0};head[y]=cnt;
}
bool bfs()
{
    queue<int> q; q.push(s);
    memset(d,0,sizeof d); d[s]=1;
    while(!q.empty()){
        int x=q.front();q.pop();
        For(x) if(e[i].v&&!d[y]){
            q.push(y); d[y]=d[x]+1;
            if(y==t) return 1;
        }
    } return 0;
}

int dinic(int x,int flow)
{
    if(x==t) return flow; int re=flow;

    for(int y,i=head[x];(y=e[i].to)&&re;i=e[i].nxt)
        if(e[i].v&&d[y]==d[x]+1)
        {
            k=dinic(y,min(re,e[i].v));
            if(!k) d[y]=0;
            e[i].v-=k;e[i^1].v+=k;re-=k; 
        }
    return flow-re;
}
int a[105][105];
int mx[]={1,-1,0,0};
int my[]={0,0,1,-1};
void build()
{
    rd(n);rd(m);s=n*m+1;t=n*m+2;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            rd(a[i][j]);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(a[i][j]==1)
                add(s,num(i,j),INF);
            else if(a[i][j]==2)
                add(num(i,j),t,INF);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            for(int k=0;k<4;k++)	
            {
                int tx=i+mx[k];
                int ty=j+my[k];
                if(tx<=n and ty<=m and tx>=1 and ty>=1)
                    add(num(i,j),num(tx,ty),1);
            }
}
int main()
{
    build();
    while(bfs())
        while(f=dinic(s,INF))
            ans+=f;
    cout<<ans;
}
```

---

## 作者：PPL_ (赞：30)

# 前言

这是个人在**网络流-最大流(最小割)** 当中认为最有意思的题

本题解使用$ISAP$

# 题目

[洛谷](https://www.luogu.com.cn/problem/P2598)

# 正题

如果你学过网络流，那么你一定能做出这道题，跟着我一起来看看吧

这道题最重要是 **如何看出是最小割** 和 **怎么建图** ，至于最小割的事，让板子去跑就好了

## 1.如何看出是最小割

~~看题解~~

这里有几个不算提示的提示：

### (1)数据范围较小

$100\%$的数据$ n,m\le100$

### (2)两个势力(尽管有中立)

我们可以想到二分图->网络流

但这不是二分图

### ※(3)草稿纸

首先我们可以发现狼和羊的本质是相同的

即不管让$1$为羊或$2$为羊，对结果没有影响

我们先随手画一个图(红色为羊，绿色为狼(虽然反过来也行))：

![](https://cdn.luogu.com.cn/upload/image_hosting/02n1ufzl.png)

其中要修建栏杆的位置：

![](https://cdn.luogu.com.cn/upload/image_hosting/pwrvivio.png)

把羊和狼看成点，栏杆看成边

现在可以转化为：

![](https://cdn.luogu.com.cn/upload/image_hosting/4muvxfi5.png)

我们要做的就是从任何一只羊出发，不能走到任何一只狼

但这太凌乱了

我们根据经验，建两个超级点，分别与羊和狼连边

只需在砍去一些边之后，保证一个超级点无法走到另一个超级点就好了

所以现在长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/nhzbbvm6.png)

有没有很熟悉了

两个超级点分别为源点和汇点，狼和羊为点，栏杆为边

**最小割！**

至此，我们已经将问题转化为最小割了

## 2.如何建图

根据之前的经验，我们肯定要先将狼和羊连边

至于容量，当然是$1$，因为一个栏杆对应的就是一个单位花费

而源点和汇点向狼和羊连边的容量自然就是$INF$，一个极大值

但是中立的地方怎么处理呢？

如果不管中立地区(黑色)：

![](https://cdn.luogu.com.cn/upload/image_hosting/620t4n5u.png)

死得惨(指你的程序和羊)

羊现在可以根据路线 羊->中立地区->狼 准确的送到狼的嘴里

所以现在我们要保证无法从 **羊->中立地区->狼**

即 **源点->羊->中立地区->狼->汇点**

所以 羊与中立地区，中立地区与狼(注意顺序) 也要连边

那么中立地区自己要不要连边呢？

答案是要

如果不连，你可以得到$10pts$的高分

如果连上，恭喜你$AC$此题

为什么呢？ 因为我们如果把 中立地区->另一个中立地区 的边砍掉，那么羊依然不能根据路径 羊->中立地区->狼 送到狼嘴里

至于是砍这个路径优还是砍其他的路径优，那就不是我们考虑的问题了，那就是最小割了

## 3.小总结

其实整条路径是这样的：

**源点->羊->中立地区->中立地区->狼->汇点**

我们不能把源点和羊的边砍掉，也不能把狼和汇点的边砍掉，所以这些边的容量为极大值

我们只能任意砍掉其它的边，使得这条路径不通，而砍掉一条边的代价为$1$，所以这些边的容量为$1$

所以整个过程就是求最小割

我们要连的边有：

(1)源点 $-INF->$ 羊

(2)羊 $-1->$ 狼

(3)狼 $-INF->$ 汇点

(4)羊 $-1->$ 中立地区

(5)中立地区 $-1->$ 中立地区

(6)中立地区 $-1->$ 狼

# 代码

代码中$ID(n+1,1)$代表源点，$ID(n+1,2)$代表汇点

```cpp
//12252024832524
#include <cstdio>
#include <algorithm>
using namespace std; 

typedef long long LL;
const int MAXN = 100*100+5;
const int MAXM = 100*100*4+5;
const int INF = 0x3f3f3f3f;
int n,m,p,tot = 1,s,t;
int head[MAXN];
int d[MAXN];//距离标号
int vd[MAXN];//标号为i的节点个数
int a[105][105];
int dx[4] = {1,-1},dy[4] = {0,0,1,-1};
struct edge
{
	int v,w,nxt;
}e[MAXM << 2];

int Read()
{
	int x = 0,f = 1;char c = getchar();
	while(c > '9' || c < '0'){if(c == '-')f = -1;c = getchar();}
	while(c >= '0' && c <= '9'){x = (x*10) + (c^48);c = getchar();}
	return x * f;
}
void Put1(int x)
{
	if(x > 9) Put1(x/10);
	putchar(x%10^48);
}
void Put(int x)
{
	if(x < 0) putchar('-'),x = -x;
	Put1(x);
}
template <typename T>T Max(T x,T y){return x > y ? x : y;}
template <typename T>T Min(T x,T y){return x < y ? x : y;}
template <typename T>T Abs(T x){return x < 0 ? -x : x;}

void Add_Edge(int x,int y,int z)
{
	e[++tot].v = y;
	e[tot].w = z;
	e[tot].nxt = head[x];
	head[x] = tot;
}
int ID(int x,int y)
{
	return (x-1) * m + y;
}
int aug(int x,int ap)//ap = Augmented path增广路经
{
    if(x == t) return ap;
    int sum = 0,mind = n*m+1,t;
    for(int i = head[x]; i ;i = e[i].nxt)
    {
        if(e[i].w > 0)
        {
            if(d[x] == d[e[i].v]+1)
            {
                t = Min(ap - sum,e[i].w);
                t = aug(e[i].v,t);
                e[i].w -= t;
                e[i^1].w += t;
                sum += t;
                if(d[s] >= n*m+2) return sum;
                if(sum == ap) break;
            }
            if(d[e[i].v] < mind) mind = d[e[i].v];
        }
    }
    if(!sum)
    {
        vd[d[x]]--;
        if(!vd[d[x]]) d[s] = n*m+2;
        d[x] = mind + 1;
        vd[d[x]]++;
    }
    return sum;
} 
int ISAP(int S,int T)
{
    int ret = 0;
    s = S;t = T;
    vd[0] = n*m+2;
    while(d[s] < n*m+2) ret += aug(s,INF);
    return ret;
}
void cls()
{
	for(int i = n*m+2;i >= 0;-- i)
		vd[i] = d[i] = head[i] = 0;
	tot = 1;
}

signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	while(~scanf("%d",&n))
	{
		m = Read();
		for(int i = 1;i <= n;++ i)
			for(int j = 1;j <= m;++ j)
			{
				a[i][j] = Read();
				if(a[i][j] == 1)
				{
					Add_Edge(ID(n+1,1),ID(i,j),INF);
					Add_Edge(ID(i,j),ID(n+1,1),0);
				}
				else if(a[i][j] == 2)
				{
					Add_Edge(ID(i,j),ID(n+1,2),INF);
					Add_Edge(ID(n+1,2),ID(i,j),0);
				}
			}
		for(int i = 1;i <= n;++ i)
			for(int j = 1;j <= m;++ j)
				for(int k = 0;k < 4;++ k)
				{
					if(a[i][j] == 1 || !a[i][j])
					{
						int tox = i + dx[k],toy = j + dy[k];
						if(tox >= 1 && tox <= n && toy >= 1 && toy <= m)
						{
							if(a[tox][toy] == 1) continue;
							Add_Edge(ID(i,j),ID(tox,toy),1);
							Add_Edge(ID(tox,toy),ID(i,j),0);
						}
					}
				}
		Put(ISAP(ID(n+1,1),ID(n+1,2)));
		putchar('\n');
		cls();
	}
	return 0;
}
```

---

## 作者：天上一颗蛋 (赞：12)

## P2598 [ZJOI2009]狼和羊的故事

题目描述
“狼爱上羊啊爱的疯狂，谁让他们真爱了一场；狼爱上羊啊并不荒唐，他们说有爱就有方向．．．．．．” Orez听到这首歌，心想：狼和羊如此和谐，为什么不尝试羊狼合养呢？说干就干！ Orez的羊狼圈可以看作一个n*m个矩阵格子，这个矩阵的边缘已经装上了篱笆。可是Drake很快发现狼再怎么也是狼，它们总是对羊垂涎三尺，那首歌只不过是一个动人的传说而已。所以Orez决定在羊狼圈中再加入一些篱笆，还是要将羊狼分开来养。 通过仔细观察，Orez发现狼和羊都有属于自己领地，若狼和羊们不能呆在自己的领地，那它们就会变得非常暴躁，不利于他们的成长。 Orez想要添加篱笆的尽可能的短。当然这个篱笆首先得保证不能改变狼羊的所属领地，再就是篱笆必须修筑完整，也就是说必须修建在单位格子的边界上并且不能只修建一部分。

输入输出格式
输入格式：
文件的第一行包含两个整数n和m。接下来n行每行m个整数，1表示该格子属于狼的领地，2表示属于羊的领地，0表示该格子不是任何一只动物的领地。

输出格式：
文件中仅包含一个整数ans，代表篱笆的最短长度。

---

# 分析

要保证篱笆长最小而把狼和羊分开来，我们可以联想到**最小割**模型。一个图的最小割就是把图分为两个部分（源点及汇点不在同一部）的边权和。最小割可以用**最大流**算法求得。

# 建模

要说到网络流，重点就在于建模了，我们怎么把此网格图转换为最大流网络流呢？其实对于一个格子，我们可以把它看做与上下左右四个方向都有一条连边，而把这个格子抽象成一个点，如下图：

![](https://cdn.luogu.com.cn/upload/pic/18005.png)

依据题意和最大流的经验，我们可以连边了：（我以羊的一部作为源点，所以）源点连羊，狼连汇点，若相邻的点事狼，则连一条容量为1的边（他的模型意义是：把羊和狼分开【割】需要消耗“1”）

但是对于0怎么办呢？**这是本题的难点**

可以思索一下，若是把0全部归为狼或者羊吧，感觉又会有更优解（事实也是这样，因为狼和羊是等价的【把狼从羊中隔离开来等价于把羊从狼中隔离开来】，所以这样单方面划分是肯定不正确的），那么怎么办呢

**你可能不会，但你的最大流算法一定知道怎么做**

**我们这样连：源点---羊--（边A，c=1）--0--（边B, c=1）--狼---汇点**

试想一下，你的篱笆的作用是分割狼和羊，0这些格子要么被划分到狼的领地，要么被划分到羊的领地，若是划分到狼那边，你的算法会割开靠近羊的那条边 A ，要是划分到羊这边，他会自动割开靠近狼的边 B 。一定不存在一种割的方式，使 A 和 B 同时被割开，**因为你的算法知道，割一条就足以分开两点，不需要割第二条**。

 _所以，放手给程序去跑吧_ 
 
 # Code
 ```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
int RD(){
    int out = 0,flag = 1;char c = getchar();
    while(c < '0' || c >'9'){if(c == '-')flag = -1;c = getchar();}
    while(c >= '0' && c <= '9'){out = out * 10 + c - '0';c = getchar();}
    return flag * out;
    }
const int maxn = 100019,INF = 1e9;
int nume = 1;
int lenx,leny;
int map[190][190];
int mx[4] = {1,-1,0,0};
int my[4] = {0,0,1,-1};
int s,t,maxflow;
int head[maxn];
struct Node{
    int v,dis,nxt;
    }E[maxn << 2];
void add(int u,int v,int dis){
    E[++nume].nxt = head[u];
    E[nume].v = v;
    E[nume].dis = dis;
    head[u] = nume;
    }
int lev[maxn];
bool bfs(){
    queue<int>Q;
    memset(lev,0,sizeof(lev));
    Q.push(s);
    lev[s] = 1;
    while(!Q.empty()){
        int u = Q.front();
        Q.pop();
        for(int i = head[u];i;i = E[i].nxt){
            int v = E[i].v;
            if(E[i].dis && !lev[v]){
                lev[v] = lev[u] + 1;
                Q.push(v);
                if(v == t)return 1;
                }
            }
        }
    return 0;
    }
int Dinic(int u,int flow){
    if(u == t)return flow;
    int rest = flow,k;
    for(int i = head[u];i;i = E[i].nxt){
        int v = E[i].v;
        if(E[i].dis && lev[v] == lev[u] + 1 && rest){
            k = Dinic(v,min(rest,E[i].dis));
            if(!k)lev[v] = 0;
            E[i].dis -= k;
            E[i ^ 1].dis += k;
            rest -= k;
            }

        }
    return flow - rest;
    }
int getindex(int x,int y){
    return (x - 1) * leny + y;
    }
bool judge(int x,int y){
    if(x < 1 || x > lenx || y < 1 || y > leny)return 0;
    return 1;
    }
/*for(int i = 1;i <= lenx;i++){
        for(int j = 1;j <= leny;j++){
            
            }
        }*/
void build(){
    for(int i = 1;i <= lenx;i++){
        for(int j = 1;j <= leny;j++){
            if(map[i][j] == 2){
                add(s,getindex(i,j),INF);
                add(getindex(i,j),s,0);
                }
            else if(map[i][j] == 1){
                add(getindex(i,j),t,INF);
                add(t,getindex(i,j),0);
                }
            }
        }
    for(int i = 1;i <= lenx;i++){
        for(int j = 1;j <= leny;j++){
            if(map[i][j] == 2 || map[i][j] == 0){
                for(int k = 0;k < 4;k++){
                    int nx = i + mx[k],ny = j + my[k];
                    if(!judge(nx,ny))continue;
                    if(map[nx][ny] == 1 || map[nx][ny] == 0){
                        add(getindex(i,j),getindex(nx,ny),1);
                        add(getindex(nx,ny),getindex(i,j),0);
                        }
                    }
                }
            }
        }
    }
int main(){
    lenx = RD();leny = RD();
    for(int i = 1;i <= lenx;i++){
        for(int j = 1;j <= leny;j++){
            map[i][j] = RD();
            }
        }
    s = lenx * leny + 1,t = s + 1;
    build();
    int flow = 0;
    while(bfs())while(flow = Dinic(s,INF))maxflow += flow;
    printf("%d\n",maxflow);
    return 0;
    }
```

---

## 作者：Jayun (赞：5)

# 题目大意：

给定一个 $N\times M$ 的矩阵，矩阵上每一个点可能是狼、空地或者羊，你要在某些点的某几个边界方篱笆使得任意狼、羊不能互通。

# 正文：

由于每一个单位的篱笆把两个相邻的点分开，想到用最小割，原点向羊连一条无穷大的边，羊向空地和狼连一条边权为一的边，空地向其它空地和狼连边权为一的边，狼向汇点连一条无穷大的边。

如：

![](https://s1.ax1x.com/2020/08/16/dVU6cF.png)

# 代码：

```cpp
void Add(int x, int y, int w)
{
	e[++tot] = (edge){y, w, tot + 1, head[x]}; 
	head[x] = tot;
	e[++tot] = (edge){x, 0, tot - 1, head[y]}; 
	head[y] = tot; 
}

int dis[N * N];
queue <int> que;

bool bfs()
{
	while(!que.empty())que.pop();
	memset(dis, 60, sizeof(dis));
	dis[s] = 0;
	que.push(s);
	while(!que.empty())
	{
		int x = que.front();que.pop();
		for (int i = head[x]; i; i = e[i].next)
		{
			int y = e[i].y;
			if(dis[y] >= dis[x] + 1 && e[i].w)
			{
				dis[y] = dis[x] + 1;
				if(y == t) return 1;
				que.push(y);
			}
		}
	}
	return 0;
}

ll dfs(int x, ll f)
{
	if(x == t) return f;
	ll sum = 0;
	for (int i = head[x]; i; i = e[i].next)
	{
		int y = e[i].y;
		if(dis[y] == dis[x] + 1 && e[i].w)
		{
			ll f2 = dfs(y, min(e[i].w * 1ll, f - sum));
			if (!f2) dis[y] = -1;
            e[i].w -= f2; 
            e[e[i].op].w += f2;
            sum += f2;
            if (sum == f) break;
		}
	}
	return sum;
}

ll dinic()
{
	ll sum = 0;
	while(bfs()){sum += dfs(s, 1010580540);}
	return sum;
}

int main()
{
	scanf("%d%d", &n, &m);
	s = n * m + 1, t = n * m + 2; 
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
		{
			scanf ("%d", &a[i][j]);
			if(a[i][j] == 1)
			{
				Add(s, (i - 1) * m + j, 1010580540);
			} else
			if(a[i][j] == 2)
			{
				Add((i - 1) * m + j, t, 1010580540);
			}
		}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
		{
			if(a[i][j] == 1 || a[i][j] == 0)
				for (int k = 0; k < 4; k++)
				{
					int x = i + dx[k], y = j + dy[k];
					if(x <= 0 || x > n || y <= 0 || y > m)
						continue;
					if(a[x][y] == 2 || a[x][y] == 0)
						Add((i - 1) * m + j, (x - 1) * m + y, 1);
				}
		}
	printf("%lld", dinic());
	return 0;
}

```



---

## 作者：wxwoo (赞：4)

[$$\color{#0e90d2}\huge{\texttt{my blog}}$$](https://wxwoo.github.io/2019/03/13/solution-p2598/)

******

[原题目链接](https://www.luogu.org/problemnew/show/P2598)

将狼和羊分成两个部分：~~明显的~~最小割

根据*最大流最小割定理*，最大流=最小割，所以这题可以使用最大流算法求解

我们将每个格子看成一个点，然后如下建边：

> 1. 源点向狼的领地连流量为$inf$的边

> 1. 羊的领地向汇点连流量为$inf$的边

> 1. 每个格子向上下左右四个格子连流量为$1$的边

接下来我们思考这样建边的正确性

在最小割模型中，连一条流量为$inf$的边意为连一条不可割边（这套路很常见的）

那么这个图中的可割边就只有两个格子之间的边了

接下来我们考虑那些为$0$的格子

由于最小割的性质，狼和羊一定会被分成两部分，和为$0$的格子无关

代码如下

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int inf=1e9;
const int N=3e5+1;
struct edge
{
    int from,to,next,cap,flow;
}e[N];
int cnt,n,m,sour,sink,head[N],ans,q[N],l[N],p[N];
const int move[4][2]={{0,1},{0,-1},{1,0},{-1,0}};
inline int min(int i,int j)
{
    return i<j?i:j;
}
inline void add(int u,int v,int l)
{
    e[++cnt]=(edge){u,v,head[u],l,0};
    head[u]=cnt;
    e[++cnt]=(edge){v,u,head[v],0,0};
    head[v]=cnt;
}
inline bool find()
{
    memset(l,0,sizeof(l));
    int h=1,t=1;
    q[1]=sour;
    l[sour]=1;
    while(h<=t)
    {
        int x=q[h++];
        for(int i=head[x];i;i=e[i].next)
            if(!l[e[i].to]&&e[i].cap>e[i].flow)
            {
                q[++t]=e[i].to;
                l[e[i].to]=l[x]+1;
                if(e[i].to==sink)
                    return true;
            }
    }
    return false;
}
int dfs(int x,int now)
{
    if(x==sink||!now)
        return now;
    int t=now,detla;
    for(int i=head[x];i;i=e[i].next)
    {
        if(e[i].cap>e[i].flow&&l[e[i].to]==l[x]+1)
        {
            detla=dfs(e[i].to,min(t,e[i].cap-e[i].flow));
            if(!detla)
                l[e[i].to]=0;
            e[i].flow+=detla;
            e[((i-1)^1)+1].flow-=detla;
            t-=detla;
            if(t==0)
                break;
        }
    }
    return now-t;
}
inline void dinic()
{
    while(find())
        ans+=dfs(sour,inf);
}
inline void read(int &x)
{
    char ch;
    int f=1;
    x=0;
    do
    {
        if(ch=='-')
            f=-1;
        ch=getchar();
    }while(!('0'<=ch&&ch<='9'));
    do
    {
        x=(x<<3)+(x<<1)+ch-48;
        ch=getchar();
    }while('0'<=ch&&ch<='9');
    x*=f;
}
inline int get(int x,int y)
{
    return (x-1)*m+y;
}
int main()
{
    read(n);
    read(m);
    sour=0;
    sink=n*m+1;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            int t;
            read(t);
            if(t==2)
            	add(get(i,j),sink,inf);
            else if(t==1)
            	add(sour,get(i,j),inf);
            for(int k=0;k<4;k++)
            {
            	int x=i+move[k][0],y=j+move[k][1];
            	if(x<1||x>n||y<1||y>m)
            		continue;
            	add(get(i,j),get(x,y),1);
            }
        }
    }
    dinic();
    printf("%d",ans);
    return 0;
}

```

---

## 作者：ker_xyxyxyx_xxs (赞：2)

[P2598 [ZJOI2009]狼和羊的故事](https://www.luogu.com.cn/problem/P2598)

大致题意：狼和羊在矩阵里，需要将某些边分开使得他们不相邻。

最小割。非常套路，直接把两种动物分别对应到源点和汇点，让狼吃不到羊就是让源点与汇点不想通，考虑最小割解决。

连边：

1、源点向所有狼连一条边权为 $ \infty $ 的边

2、每只羊向汇点连一条边权为 $ \infty $ 的边

3、每个方格向周围吗，每个方格连一条边权为 $ 1 $ 的边。

最后利用最小割最大流定理求出最小割。

思考一下原理，在两个点之间建篱笆，自然就为 $ 1 $，至于向源点与汇点，前面有说。其实是一个很套路的题。

Code

```cpp
# include <iostream>
# include <cstdio>
# include <queue>
# include <cstring>
using namespace std;

const int N = 1e5 + 5;
const int M = 2e6 + 5;
const int maxn = 100 + 5;
const int inf = 0x3f3f3f3f;
int n , m;

typedef struct {
	int x , y , z , next;
} Edge;
Edge edge[M];
int E = 1 , elast[N];
int S , T;
void add(int x , int y , int z) {
	E ++;
	edge[E].x = x;
	edge[E].y = y;
	edge[E].z = z;
	edge[E].next = elast[x];
	elast[x] = E;
}
int x , y , z;
int a[maxn][maxn];
int dis[N] , cnt[N];
void bfs(int start) {
	queue<int> q;
	q.push(start);
	dis[start] = 0;
	cnt[S] = 1;
	while (!q.empty()) {
		int cur = q.front();
		q.pop();
		for (int i = elast[cur] ; i ; i = edge[i].next) {
			int v = edge[i].y;
			if (dis[v] != -1) continue;
			dis[v] = dis[cur] + 1;
			q.push(v);
			cnt[dis[v]] ++;
		}
	}
}
int cur[N];
int dfs(int u , int flow) {
	if (u == T) return flow;
	int temp , delta = 0;
	for (int i = cur[u] ; i ; i = edge[i].next) {
		cur[u] = i;
		int v = edge[i].y;
		if (edge[i].z > 0 && dis[u] == dis[v] + 1) {
			temp = dfs(v , min(flow - delta , edge[i].z));
			edge[i].z -= temp;
			edge[i ^ 1].z += temp;
			delta += temp;
			if (delta == flow) return delta;
		}
	}
	if (dis[S] >= T) return delta;
	cur[u] = elast[u];
	if (-- cnt[dis[u]] == 0) dis[S] = T;
	cnt[++ dis[u]] ++;
	return delta;
}
int Isap() {
	int Ans = 0;
	memset(cnt , 0 , sizeof cnt);
	memset(dis , -1 , sizeof dis);
	bfs(T);
	for (int i = 0 ; i <= T ; i ++) {
		cur[i] = elast[i];
	}
	while (dis[S] < T) Ans += dfs(S , inf);
	return Ans;
}
signed main() {
	cin >> n >> m;
	S = 0 , T = n * m + 1;
	for (int i = 1 ; i <= n ; i ++) {
		for (int j = 1 ; j <= m ; j ++) {
			scanf("%d" , &a[i][j]);
		}
	}
	for (int i = 1 ; i <= n ; i ++) {
		for (int j = 1 ; j <= m ; j ++) {
			if (i - 1 > 0) add((i - 1) * m + j , (i - 2) * m + j , 1) , add((i - 2) * m + j , (i - 1) * m + j , 0);
			if (i + 1 <= n) add((i - 1) * m + j , i * m + j , 1) , add(i * m + j , (i - 1) * m + j , 0);
			if (j - 1 > 0) add((i - 1) * m + j , (i - 1) * m + j - 1 , 1) , add((i - 1) * m + j - 1 , (i - 1) * m + j , 0);
			if (j + 1 <= m) add((i - 1) * m + j , (i - 1) * m + j + 1 , 1) , add((i - 1) * m + j + 1 , (i - 1) * m + j , 0);
			if (a[i][j] == 1) add(S , (i - 1) * m + j , inf) , add((i - 1) * m + j , S , 0);
			if (a[i][j] == 2) add((i - 1) * m + j , T , inf) , add(T , (i - 1) * m + j , 0);
		} 
	}
	printf("%d\n" , Isap());
	return 0;
}
```

---

## 作者：magolor (赞：2)

比较裸的最小割，但是在处理建图上要注意细节。

S为0，T为n\*m+1，所以每次当前弧优化都要从0到n\*m+1

快速计算坐标的方法：

#define P(x,y) (~-(x)\*m+(y))

~-a相当于(a-1)，define记得打括号，y不要减一，因为最小坐标是1，0为源点S


建图时S到狼连INF，羊到T连INF（都反过来当然也一样）

其他边判断，对于每个点只连出边不连入边，防止重复计算：

如果邻居是狼和或者自己是羊，就不连这条边，其他条件都要连（自己想一想为什么）

代码中a-b写在if中其实就是a!=b（慢慢理解一下）


就是这样了，下面是Dinic，（对楼下的SAP神犇表示敬畏）







    


        


```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 10000
#define MAXM 100000
#define INF 0x3f3f3f3f
#define P(x,y) (~-(x)*m+(y))
struct Edge
{
    int to,nex,c;
    Edge(){}
    Edge(int _to, int _nex, int _c):to(_to),nex(_nex),c(_c){}    
};
Edge e[MAXM+5];
int first[MAXN+5], cur[MAXN+5], q[MAXN+5], level[MAXN+5], tot, N, n, m, S, T;
int g[105][105];
int adj[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};
inline void Add(int a, int b, int c)
{
    if(a+1 && b+1)
    {
        e[tot] = Edge(b,first[a],c);
        first[a] = tot++;
        e[tot] = Edge(a,first[b],0);
        first[b] = tot++; 
    }
    return;
}
bool BFS()
{
    memset(level,0,sizeof(level));
    level[S] = 1, q[0] = S;
    for(register int head = 0, tail = 1, t, i; head != tail; )
        for(t = q[head], head = (head+1)%MAXN, i = first[t]; i+1; i = e[i].nex)
            if(!level[e[i].to] && e[i].c > 0)
            {
                level[e[i].to] = level[t]+1;
                q[tail] = e[i].to, tail = (tail+1)%MAXN;
                if(e[i].to == T)
                    return true;
            } 
    return false;
}
int DFS(int u, int f)
{
    if(u == T)
        return f;
    int tag = 0;
    for(int &i = cur[u], del; i+1; i = e[i].nex)
        if(level[e[i].to] == level[u]+1 && e[i].c > 0)
        {
            del = DFS(e[i].to,min(f-tag,e[i].c));
            e[i].c -= del, e[i^1].c += del, tag += del;
            if(tag == f)
                return tag;
        }
    return tag;
} 
inline int Dinic()
{
    int ans = 0;
    for(register int i; BFS(); ans += DFS(S,INF))
        for(i = 0; i <= N; i++)
            cur[i] = first[i];
    return ans;
}
int main()
{
    scanf("%d%d",&n,&m), memset(first,-1,sizeof(first)), S = 0, T = N = n*m+1;
    for(register int i = 1, j; i <= n; i++)
        for(j = 1; j <= m; j++)
            scanf("%d",g[i]+j);
    for(register int i = 1, j, k, p, np; i <= n; i++)
        for(j = 1; j <= m; j++)
        {
            p = P(i,j);
            if(g[i][j] == 1)
                Add(S,p,INF);
            if(g[i][j] == 2)
                Add(p,T,INF);
            for(k = 0; k < 4; k++)
            {
                if(i+adj[k][0] < 1 || i+adj[k][0] > n || j+adj[k][1] < 1 || j+adj[k][1] > m)
                    continue;
                np = P(i+adj[k][0],j+adj[k][1]);
                if(g[i+adj[k][0]][j+adj[k][1]]-1 && g[i][j]-2)
                    Add(p,np,1);
            }
        }
    printf("%d\n",Dinic());
     return 0;
}
```

---

## 作者：ListenSnow (赞：1)

[原题链接](https://www.luogu.com.cn/problem/P2598)

## 题意

给定一张 $n \times m$ 的网格图，每个点可能是狼的领地，也可能是羊的领地，或者两者皆不是。要求在一些点的边上建栅栏，使得所有狼的领地和羊的领地无法直接相连。求最小建的栅栏数。

#### 数据范围

$1 \leq n,m \leq 100$。

### 思路

注意到题目要求羊的领地和狼的领地不连通，又要代价最小，可以联系到网络流中的最小割模型。

首先，从源点向所有羊的领地连一条流量为 $+\infty$ 的边，从所有狼的领地向汇点连一条流量为 $+\infty$。这样可以保证在最小割中的割边不会与源点或者汇点相连，在本题中的含义就是不会在不存在的地方建栅栏。再从所有原图中的点向四周连一条流量为 $1$ 的点，表示如果在这两个点中建栅栏，代价为 $1$。

这样网络流模型就建好了。再根据最大流最小割定理，求出网络中的最大流就是本题的答案。

### code：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1e5+10;
const int M=2e5+10;
const int INF=0x3f3f3f3f;
int dx[4]={-1,1,0,0};
int dy[4]={0,0,-1,1};
int h[N],idx=1,q[N],d[N],s,t,cur[N],n,m;
struct edge{
	int v,w,nex;
}e[M];
void add(int u,int v,int w){e[++idx].v=v;e[idx].w=w;e[idx].nex=h[u];h[u]=idx;}
bool bfs()
{
	int hh=0,tt=-1;memset(d,-1,sizeof(d));d[s]=0,cur[s]=h[s];q[++tt]=s;
	while(hh<=tt)
	{
		int u=q[hh++];
		for(int i=h[u];i;i=e[i].nex)
		{
			int v=e[i].v;
			if(d[v]==-1&&e[i].w)
			{
				d[v]=d[u]+1;cur[v]=h[v];
				if(v==t) return true;
				q[++tt]=v;
			}
		} 
	} 
	return false;
}
int dfs(int u,int limit)
{
	if(u==t) return limit;
	int flow=0;
	for(int i=cur[u];i&&flow<limit;i=e[i].nex)
	{
		int v=e[i].v;cur[u]=i;
		if(d[v]==d[u]+1&&e[i].w)
		{
			int t=dfs(v,min(e[i].w,limit-flow));
			if(!t) d[v]=-1;flow+=t;e[i].w-=t,e[i^1].w+=t;
		}
	}
	return flow;
}
int dinic()
{
	int res=0,flow;
	while(bfs()) while(flow=dfs(s,INF)) res+=flow;
	return res;
}
int get(int i,int j){return (i-1)*m+j;}
int main()
{
	scanf("%d%d",&n,&m);s=0,t=n*m+1;
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=m;j++)
	    {
	    	int opt,u=get(i,j),v;scanf("%d",&opt);
	    	if(opt==1) add(s,u,INF),add(u,s,0);
			if(opt==2) add(u,t,INF),add(t,u,0);
			for(int k=0;k<4;k++)
			{
				int x=i+dx[k],y=j+dy[k];
				if(x<1||x>n||y<1||y>m) continue;
				v=get(x,y);add(u,v,1),add(v,u,0);
			}
		}
	printf("%d\n",dinic());
	return 0;
} 
```


---

## 作者：crescentic (赞：1)

[狼和羊的故事](https://www.luogu.com.cn/problem/P2598)

怎么说呢，这道题其实不难，只是题意有那么~~亿~~点点难理解。我最开始想复杂了，理解为了栅栏长度是格点的周长，那事情就复杂了。。。

**题目分析**：


- 首先，要明确的是：一个狼领地和羊领地之间只需建长度为 $1$ 的栅栏。确定**源点**为狼，**汇点**为羊，正常连边，注意边权为**极大值**，因为**不确定**一只狼会和几只羊相邻，所以直接来极大值；

因为要狼和羊之间不影响，意思就是说要源点和汇点之间**不联通**，就是明显的**最小割**啦。

- 然后，连相邻个点之间的边，如果该格点是羊，不会造成任何影响~~卑微~~，要考虑的是空地和狼的情况。如果两块都是狼，也不会产生影响（羊都没有吃个寂寞）。那么剩下的情况直接连边，边权为$1$，即修一次栅栏；

- 最后，最小割模板求出答案就好啦。


**完整代码**：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
#define rt register int
const int N = 1e4 + 10,M = 1e5 + 10,inf = 1e9;
struct node {
    int to,nex;
}e[M];
int n,m,s,t,top,ed,map[105][105],dep[N],head[N],cur[N],tot = 1,f[M],q[N],a[4][2] = {{0,1},{1,0},{-1,0},{0,-1}};
inline void add(int x,int y,int w) {
    e[++tot] = (node) {y,head[x]}, f[tot] = w, head[x] = tot;
    e[++tot] = (node) {x,head[y]}, head[y] = tot; 
}
inline bool bfs() {
    memset(dep,-1,sizeof(dep));
    dep[s] = 0, cur[s] = head[s], q[top = 1] = s; ed = 1;
    int now,ver;
    while(top <= ed) {
        now = q[top++];
        for(rt i = head[now]; i; i = e[i].nex) {
            ver = e[i].to;
            if(dep[ver] == -1 && f[i]) {
                dep[ver] = dep[now] + 1, cur[ver] = head[ver];
                if(ver == t) return 1;
                q[++ed] = ver;
            }
        }
    }
    return 0;
}
inline int find(int x,int limit) {
    if(x == t) return limit;
    int flow = 0, tmp, ver;
    for(rt i = head[x]; i && flow < limit; i = e[i].nex) {
        ver = e[i].to;
        if(dep[ver] == dep[x] + 1 && f[i]) {
            tmp = find(ver,min(limit - flow,f[i]));
            if(!tmp) dep[ver] = -1;
            f[i] -= tmp, f[i ^ 1] += tmp, flow += tmp; 
        }
    }
    return flow;
}
inline int dinic() {
    int res = 0, flow;
    while(bfs()) res += find(s,inf);
    return res;
}
inline void read(int &x) {
    x = 0;int ff = 1;
    char s = getchar();
    while(s < '0' || s > '9') {if(s == '-') ff = -1;s = getchar();}
    while(s <= '9' && s >= '0') {x = x * 10 + s - '0', s = getchar(); }
    x *= ff;
}
inline int pos(int x,int y) {
    return m * (x - 1) + y;
}
int main() {
    read(n), read(m);
    s = n * m + 1, t = s + 1;
    for(rt i = 1; i <= n; i ++) {
        for(rt j = 1; j <= m; j ++) {
            read(map[i][j]);
            if(map[i][j] == 1) add(s,pos(i,j),inf);//狼 
            if(map[i][j] == 2) add(pos(i,j),t,inf);//羊 
        }
    }
    int tx,ty;
    for(rt i = 1; i <= n; i ++) {
        for(rt j = 1; j <= m; j ++) {
            for(rt k = 0; k < 4; k ++) {//上下左右 
                tx = i + a[k][0], ty = j + a[k][1];
                if(tx < 1 || ty  < 1 || tx > n || ty > m || map[i][j] == 2) continue;//排除越界和羊的情况 
                if(map[i][j] != 1 || map[tx][ty] != 1) add(pos(i,j),pos(tx,ty),1);//排除两只都是狼的情况 
            }
        }
    }
    printf("%d",dinic());
    return 0;
} 
```

话说有没有人跟我一样，读完题面脑袋里就开始洗脑回放“狼爱上羊啊爱的疯狂……”啊雾~


---

## 作者：中国飞鱼 (赞：1)

###题目描述

“狼爱上羊啊爱的疯狂，谁让他们真爱了一场；狼爱上羊啊并不荒唐，他们说有爱就有方向．．．．．．” Orez听到这首歌，心想：狼和羊如此和谐，为什么不尝试羊狼合养呢？说干就干！ Orez的羊狼圈可以看作一个n\*m个矩阵格子，这个矩阵的边缘已经装上了篱笆。可是Drake很快发现狼再怎么也是狼，它们总是对羊垂涎三尺，那首歌只不过是一个动人的传说而已。所以Orez决定在羊狼圈中再加入一些篱笆，还是要将羊狼分开来养。 通过仔细观察，Orez发现狼和羊都有属于自己领地，若狼和羊们不能呆在自己的领地，那它们就会变得非常暴躁，不利于他们的成长。 Orez想要添加篱笆的尽可能的短。当然这个篱笆首先得保证不能改变狼羊的所属领地，再就是篱笆必须修筑完整，也就是说必须修建在单位格子的边界上并且不能只修建一部分。


###输入格式：

文件的第一行包含两个整数n和m。接下来n行每行m个整数，1表示该格子属于狼的领地，2表示属于羊的领地，0表示该格子不是任何一只动物的领地。


###输出格式：

文件中仅包含一个整数ans，代表篱笆的最短长度。


###说明

10%的数据 n，m≤3

30%的数据 n，m≤20

100%的数据 n，m≤100


---
>建图：1.源点s连狼(容量为inf),羊连汇点t(容量为inf);
2.除去狼为入点，羊为出点(保证流向)以及连边界的情况，把其他所有点和其相邻的点连起来(容量为1)

3.其余为Dinic模板

**注意：**点p(x,y)的编号为m\*(x-1)+y


```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
const int N=110,M=10010;
int n,m,s,t,cnt=1,Ans;//cnt记录边数，要从1开始
int a[N][N],last[M],dep[M],cur[M],A[4]={0,0,-1,1},B[4]={-1,1};//cur[]当前弧优化
struct edge{
    int to,next,w;//w为容量
}e[10*M];
void insert(int u,int v,int c)//连边
{
    e[++cnt]=(edge){v,last[u],c};last[u]=cnt;
    e[++cnt]=(edge){u,last[v],0};last[v]=cnt;
}
queue<int> Q;
bool bfs()
{
    while(!Q.empty())Q.pop();
    memset(dep,0,sizeof(dep));//dep[]为bfs深度
    dep[s]=1;
    Q.push(s);
    while(!Q.empty())
    {
        int now=Q.front();Q.pop();
        for(int i=last[now];i;i=e[i].next)
        {
            int v=e[i].to;
            if(!dep[v]&&e[i].w>0)dep[v]=dep[now]+1,Q.push(v);
        }
    }
    return dep[t]!=0;
}
int dfs(int now,int flow)
{
    if(now==t)return flow;
    for(int& i=cur[now];i;i=e[i].next)
    {
        int v=e[i].to;
        if(dep[v]==dep[now]+1&&e[i].w!=0)
        {
            int di=dfs(v,min(flow,e[i].w));
            if(di>0){e[i].w-=di;e[i^1].w+=di;return di;}
        }
    }
    return 0;
}
int main()
{
    scanf("%d%d",&n,&m);
    t=n*m+1;//源点s为0，汇点t为n*m+1
    for(int i=1;i<=n;i++)a[i][0]=-1,a[i][m+1]=-1;//处理边界
    for(int i=1;i<=m;i++)a[0][i]=-1,a[n+1][i]=-1;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            scanf("%d",&a[i][j]);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            if(a[i][j]==1)insert(s,m*(i-1)+j,1e9);
            if(a[i][j]==2){insert(m*(i-1)+j,t,1e9);continue;}
            for(int k=0;k<4;k++)//相邻点
            {
                int ll=i+A[k],cc=j+B[k];
                if(a[ll][cc]==-1||a[ll][cc]==1)continue;
                insert(m*(i-1)+j,m*(ll-1)+cc,1);
            }
        }
    while(bfs())//Dinic
    {
        for(int i=s;i<=t;i++)cur[i]=last[i];//当前弧初始化
        while(int d=dfs(s,1e9))Ans+=d;
    }
    printf("%d\n",Ans);
    return 0;
}
```

---

## 作者：arfa (赞：1)

当一个羊身边有狼时产生贡献,最多只有四周。

- 所有源点连狼,代表这些狼可以产生贡献。

- 所有地连四周,代表狼可以对一定地理位置的羊产生贡献。

- 所有羊连汇点,代表回收贡献。

```pascal
// luogu-judger-enable-o2
Uses math;

var
    value,reach,next,from:array[-1..210000] of longint;
    id,matrix:array[-1..101,-1..101] of longint;
    gap,dis,cnt:array[-1..810000] of longint;
    n,m,l,r,k,i,j,num,tot,sink,source,maxflow:longint;

procedure add(l,r,sum:longint);
begin
    inc(tot); from[tot]:=l; reach[tot]:=r; value[tot]:=sum; next[tot]:=cnt[l]; cnt[l]:=tot;
    inc(tot); from[tot]:=r; reach[tot]:=l; value[tot]:=8-8; next[tot]:=cnt[r]; cnt[r]:=tot;
end;

function Dfs(now,flow:longint):longint;
var i,k,mindis,ret:longint;
begin
    mindis:=n-1; ret:=flow;
    if now=sink then exit(flow);
    i:=cnt[now];
    while i<>-1 do
    begin
        if value[i]>0 then
        begin
            if dis[now]=dis[reach[i]]+1 then
            begin
                k:=Dfs(reach[i],min(ret,value[i]));
                dec(value[i],k);inc(value[i xor 1],k);
                dec(ret,k);
                if dis[source]>=n then exit(flow-ret);
                if ret=0 then break;
            end;
             mindis:=min(mindis,dis[reach[i]]);
        end;
        i:=next[i];
    end;
    if ret=flow then
    begin
        dec(gap[dis[now]]);
        if gap[dis[now]]=0 then dis[source]:=n;
        dis[now]:=mindis+1;
        inc(gap[dis[now]]);
    end;
    exit(flow-ret);
end;

begin
    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1); tot:=1;
    read(n,m); source:=1; sink:=n*m+2; num:=1;
    for i:=1 to n do for j:=1 to m do
    begin
    	inc(num); id[i,j]:=num;
    	read(matrix[i,j]);
    end;
    for i:=1 to n do for j:=1 to m do
    begin
    	if matrix[i,j]=1 then add(id[i,j],sink,maxlongint div 843);
    	if matrix[i,j]=2 then add(source,id[i,j],maxlongint div 843);
        if (i-1>0) then add(id[i,j],id[i-1,j],1);
        if (i+1<=n) then add(id[i,j],id[i+1,j],1);
    	if (j-1>0) then add(id[i,j],id[i,j-1],1);
    	if (j+1<=m) then add(id[i,j],id[i,j+1],1);
    end;
    n:=sink+1; gap[source]:=n;
    while dis[source]<n do inc(maxflow,Dfs(source,maxlongint));
    writeln(maxflow);
end.
```

---

## 作者：TonyYin (赞：0)

## 题意

给定一个 $n\times m$ 的矩阵，矩阵上每一个点可能是狼、羊或者空地。

你需要在格子的边界修建篱笆，使得任意两个狼与羊的格子不连通。

给一个格子的一条边界修建篱笆，那么篱笆总长度增加 $1$，求篱笆的最短长度。

$n, m\leq 100$.

## 分析

**这是最小割问题的常见模型。**

网络流可以用于解决矩阵上，通过限制边，与连通性相关的问题。

这道题，需要把狼和羊分开，所以想到：

- **源点向所有狼连容量为 $\inf$ 的边；**

- **所有羊向汇点连容量为 $\inf$ 的边；**

这样使狼和羊一定分别属于两个集合。

之后对矩阵上的限制进行模拟，**所有点向四周连容量为 $1$ 的边。**

这样断掉一条边，就等价于在矩阵中选一条边界拦住。

## 代码

```c++
#include <bits/stdc++.h>

using namespace std;
const int MAXN = 10008, MAXM = 1e7;
const int inf = 0x3f3f3f3f;
int n, m, S, T;
int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
int num[MAXN][MAXN];
int get_id(int x, int y) {
	return (x - 1) * m + y;
}
struct Edge{
	int to, val, nxt;
} edge[MAXM];
int head[MAXN], e_cnt = 1;
void add(int u, int v, int w) {
	edge[++e_cnt] = (Edge){v, w, head[u]};
	head[u] = e_cnt;
}
void add_edge(int u, int v, int w) {
	add(u, v, w); add(v, u, 0);
}
int lev[MAXN];
bool bfs() {
	memset(lev, -1, sizeof(lev)); lev[S] = 0;
	queue<int> q; q.push(S);
	while(!q.empty()) {
		int u = q.front(); q.pop();
		for(int i = head[u]; i; i = edge[i].nxt) {
			int v = edge[i].to, val = edge[i].val;
			if(lev[v] == -1 && val) {
				lev[v] = lev[u] + 1;
				q.push(v);
			}
		}
	}
	return (lev[T] != -1);
}
int dfs(int u, int flow) {
	if(u == T) return flow;
	int ret = 0;
	for(int i = head[u]; i; i = edge[i].nxt) {
		int v = edge[i].to, val = edge[i].val;
		if(lev[v] == lev[u] + 1 && val) {
			int tmp = dfs(v, min(flow, val));
			edge[i].val -= tmp;
			edge[i ^ 1].val += tmp;
			flow -= tmp;
			ret += tmp;
			if(flow == 0) break;
		}
	}
	if(ret == 0) lev[u] = -1;
	return ret;
}
int Dinic() {
	int ret = 0;
	while(bfs()) {
		ret += dfs(S, inf);
	}
	return ret;
}
int main() {
	scanf("%d%d", &n, &m);
	S = 0; T = n * m + 1;
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			scanf("%d", &num[i][j]);
			int id = get_id(i, j);
			if(num[i][j] == 1) add_edge(S, id, inf);
			if(num[i][j] == 2) add_edge(id, T, inf);
			for(int k = 0; k < 4; k++) {
				int nx = i + dir[k][0], ny = j + dir[k][1];
				if(nx < 1 || ny < 1 || nx > n || ny > m) continue;
				add_edge(id, get_id(nx, ny), 1);
			}
		}
	}
	cout << Dinic() << endl;
	return 0;
}
```



---

## 作者：raincity (赞：0)

## 分析
首先分析狼的吃羊路线：狼 $\to$ 空地 $\to$ 空地$\to\ldots$ - $\to$ 羊。那么我们切断其中任意一个环节即可。

套路地让超级源点 $s$ 向所有狼连边，羊向超级汇点 $t$ 连边，边权设为 $\inf$（不可以割掉这条边），然后连接狼 $\to$ 空地，空地 $\to$ 空地，狼 $\to$ 羊的边，容量为 1，将狼羊分成两半，求最小割，也就是最大流即可。Dinic 可过，EK 不知道。

## 解决
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>

using namespace std;

const int N = 10010, M = 200010, d[4][2] = {{0, -1}, {-1, 0}, {1, 0}, {0, 1}};
int n, m, mp[105][105], id[105][105];
int head[N], ver[M], nxt[M], edge[M], tot = -1;
int que[N], l, r;
int increase[N], dep[N], s, t, maxflow;

inline bool bfs() {
	memset(dep, 0, sizeof(dep)); 
    que[1] = s, l = r = 1, dep[s] = 1;
    while (l <= r) {
        int tmp = que[l++];
        for (register int i = head[tmp]; ~i; i = nxt[i])
            if (edge[i] && !dep[ver[i]]) {
                dep[ver[i]] = dep[tmp] + 1, que[++r] = ver[i];
                if (ver[i] == t)
                	return true;
            }
    }
    return false;
}

inline int dinic(int cur, int flow) {
	if (cur == t)
		return flow;
	int rest = flow;
	for (register int i = head[cur]; (~i) && rest; i = nxt[i])
		if (edge[i] && dep[ver[i]] == dep[cur] + 1) {
			int increase = dinic(ver[i], min(rest, edge[i]));
			if (increase == 0)
				dep[ver[i]] = 0;
			edge[i] -= increase, edge[i ^ 1] += increase, rest -= increase;
		}
	return flow - rest;
}

inline void Addedge(int x, int y, int z) { ver[++tot] = y, nxt[tot] = head[x], head[x] = tot, edge[tot] = z; }
inline void addedge(int x, int y, int z) { Addedge(x, y, z), Addedge(y, x, 0); }

int main() {
	scanf("%d%d", &n, &m);
	s = 0, t = n * m + 1;
	memset(head, -1, sizeof(head));
	for (register int i = 1; i <= n; i++)
		for (register int j = 1; j <= m; j++)
			scanf("%d", &mp[i][j]), id[i][j] = j == 1 ? id[i - 1][m] + 1 : id[i][j - 1] + 1;
	for (register int i = 1; i <= n; i++)
		for (register int j = 1; j <= m; j++) {
			if (mp[i][j] == 1)
				addedge(s, id[i][j], 0x3f3f3f3f);
			if (mp[i][j] == 2)
				addedge(id[i][j], t, 0x3f3f3f3f);
			for (int k = 0; k < 4; k++) {
				int x = i + d[k][0], y = j + d[k][1];
				if (x >= 1 && y >= 1 && x <= n && y <= m && ((mp[i][j] == 0 && mp[x][y] != 1) || (mp[i][j] == 1 && mp[x][y] != 1)))
				    addedge(id[i][j], id[x][y], 1);
			}
		}
	while (bfs()) maxflow += dinic(s, 0x3f3f3f3f);
	cout << maxflow << endl;
	return 0;
}

```

说句闲话，写题解的时候你谷换 Logo了（

---

## 作者：Illusory_dimes (赞：0)

### 题目大意
给定一个 $n\cdot m$ 的矩阵，矩阵上每一个点是 $1$ ， $2$ 或者 $0$ ，求将所有 $1$ 和 $2$ 分开所要挡上的最少边界数量。

$1\leq n,m\leq 100$

### solution
一共有三种初始情况，还有一种没用，所以就两种，“二分图”上最小割无疑了，左边一溜就定为初始为 $1$ 的位置，右边一溜就定为初始为 $2$ 的位置。

其实因为 $0$ 是没有用的，根本不用考虑它的感受。

直接，

1、源点向所有为 1 的点连流量 $\infty$ 的边。

2、所有为 2 的点向汇点连流量 $\infty$ 的边。

3、所有点向四周在矩阵内的点连流量为 $1$ 的边。

就好了！

为什么是对的呢？

因为如果是狼羊直接连边，那么这条边一定是不用另走弯路，所以一定会被割。

那么如果是有 $0$ 在中间呢，肯定会选择走最少的弯路，此时虽然会有许多冗余边，但不会对答案造成影响。

此时我跑了 [93ms](https://www.luogu.com.cn/record/47398777) 。

但会有很多冗余边可以去掉，一开始不知道怎么去掉，就先把输入与加边分开，没想到只跑了 [42ms](https://www.luogu.com.cn/record/47526240) 。（谁能告诉我是什么原理）

后来发现了 $1$ 和 $2$ 同类之间的边珂以去掉，但 $0$ 的不能去掉

为什么呢

举个例子

$1_1$ $1_2$ $1_3$ $1_4$

$0_1$ $0_2$ $0_3$ $0_4$

$0_5$ $0_6$ $0_7$ $0_8$

$2_1$ $2_2$ $2_3$ $2_4$

如果 0 同类之间的边也去掉后建出来的图是

![](https://cdn.luogu.com.cn/upload/image_hosting/g9eck5jv.png)

这样的

当 $1$ 和 $2$ 彻底分开就可能会出 bug

所以只有 $1$ 和 $2$ 同类之间的边珂以去掉

然后就只跑了 [39ms](https://www.luogu.com.cn/record/47526794) 。

虽然是运气好，但这个思考的过程也略微体现了一下本题一点不同的价值之处
```cpp
#include<bits/stdc++.h>
#define id(i,j) (i-1)*m+j
using namespace std;
typedef long long ll;
const int N=1e4+10,M=1e5+10;
const int INF=0x3f3f3f3f;
const int xx[]={0,0,1,-1},yy[]={1,-1,0,0};
int n,m,s,t,cur[N],gap[N],dep[N],q[N];
//cur[i]:当前弧优化,gap[i]:GAP优化 
int fst[N],nxt[M],to[M],val[M],tot=2;
int a[108][108];
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline void add(int u,int v,int w)
{
	nxt[tot]=fst[u];
	to[tot]=v,val[tot]=1ll*w;
	fst[u]=tot;++tot;
	nxt[tot]=fst[v];
	to[tot]=u,val[tot]=0;
	fst[v]=tot;++tot;
}
inline void bfs()
{
	for(int i=s;i<=t;++i)
	dep[i]=q[i]=gap[i]=0;
	int hd=0,tl=1;
	dep[t]=1,gap[1]=1;q[tl]=t;
	//这是从汇点开始
	while(hd<tl)
	{
		int u=q[++hd];
		for(int i=fst[u];i;i=nxt[i])
		{
			int v=to[i];
			if(!dep[v])
			{
				dep[v]=dep[u]+1;
				++gap[dep[v]];
				q[++tl]=v;
			}
		}
	}
}
ll dfs(int u,ll lim)
{
	if(u==t)return lim;
	int ans=0,tmp;
	for(int i=cur[u];i;i=nxt[i])
	{
		int v=to[i];
		cur[u]=i;
		if(dep[v]==dep[u]-1&&val[i])
		{
			tmp=dfs(v,min(lim,1ll*val[i]));
			val[i]-=tmp,lim-=tmp;
			ans+=tmp,val[i^1]+=tmp;
			if(!lim)break;
		}
	}
	if((!ans)||lim)
	{
		if(--gap[dep[u]]==0)dep[s]=n*m+3;
		++gap[++dep[u]];
	}
	return ans;
}
inline ll isap()
{
	ll ans=0;
	bfs();
	while(dep[s]<=n*m+2)
	{
		memcpy(cur,fst,sizeof(cur));
		ans+=dfs(s,INF);
	}
	return ans;
}
int main()
{
	n=read(),m=read(),s=0,t=n*m+1;
	for(int i=1;i<=n;++i)
	for(int j=1;j<=m;++j)
	{
		int p=read();a[i][j]=p;
	}
	for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)
	{
		int p=a[i][j];
		if(p==1)add(s,id(i,j),INF);
		if(p==2)add(id(i,j),t,INF);
		for(int k=0;k<4;++k)
		{
			int x=i+xx[k],y=j+yy[k];
			if(x<1||y<1||x>n||y>m||((p==1||p==2)&&a[x][y]==p))continue;
			add(id(x,y),id(i,j),1);
		}
	}
	printf("%d",isap());
	getchar();
	return 0;
}
```
只求能帮助到几个人罢。。

---

## 作者：Aftglw (赞：0)

### 题目大意

给定一个 $nm$ 的由 $(0,1,2)$ 组成的矩阵，要求在两个数之间建墙，使得任意两个 $1$ 和 $2$ 不连通（两个数相邻且之间无墙即为联通），求最少要建多少墙。

这道题可视作是要将 $1$ 和 $2$ 划分成两个集合，考虑最小割。

$s\longrightarrow\{(i,j)|mp_{i,j}==1\}$，容量 $+\infty$。

$t\longrightarrow\{(i,j)|mp_{i,j}==2\}$，容量 $+\infty$。

容量 $+\infty$ 是为了保证最终不会出现 $1$ 和 $2$ 在一个集合内的情况。

由于每个格子和上下左右四个格子相邻，所以将它和周围的格子连起来。

$(i,j)\longrightarrow(i+1,j)$，容量为 $1$。

$(i,j)\longrightarrow(i,j+1)$，容量为 $1$。

$(i,j)\longrightarrow(i-1,j)$，容量为 $1$。

$(i,j)\longrightarrow(i,j-1)$，容量为 $1$。

这样，跑最小割时，每割掉一条边，就相当于在这两个格子之间建一堵墙，代价 $++$ ，所以上面建图时容量为 $1$ 。

最终最小割即为答案。

### Code

```cpp
#include<bits/stdc++.h>
//#define int long long
#define pair pair<int,int>
using namespace std;
inline void end()
{
	puts("");
	system("pause");
}
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9') {if(c=='-') f=-1;c=getchar();}
	while (c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*f;
}
const int N=1e4+4,M=5e5+5;
int n,m,s,t,ans;
int first[N],nex[M],to[M],w[M],num=1;
inline void add(int u,int v,int val)
{
	nex[++num]=first[u];
	first[u]=num;
	to[num]=v;
	w[num]=val;
}
inline void Add(int u,int v,int val)
{
	add(u,v,val);
	add(v,u,0);
}
namespace ISAP
{
	int dep[N],gap[N],cur[N];
	void bfs()
	{
		memset(dep,-1,sizeof(dep));
		memset(gap,0,sizeof(gap));
		queue<int> q;
		q.push(t);
		dep[t]=0;gap[0]=1;
		while(!q.empty())
		{
			int u=q.front();q.pop();
			for(int i=first[u];i;i=nex[i])
			{
				int v=to[i];
				if(dep[v]!=-1) continue;
				dep[v]=dep[u]+1;
				gap[dep[v]]++;
				q.push(v);
			}
		}
	}
	inline int dfs(int u,int in)
	{
		if(u==t) return in;
		int out=0;
		for(int i=cur[u];i;i=nex[i])
		{
			cur[u]=i;
			int v=to[i];
			if(!w[i]||dep[v]!=dep[u]-1) continue;
			int res=dfs(v,min(w[i],in-out));
			w[i]-=res;
			w[i^1]+=res;
			out+=res;
			if(in==out) return out;
		}
		gap[dep[u]]--;
		if(!gap[dep[u]]) dep[s]=n*m+3;
		dep[u]++;
		gap[dep[u]]++;
		return out;
	}
	void work()
	{
		bfs();
		while(dep[s]<n*m+2)
		{
			memcpy(cur,first,sizeof(first));
			ans+=dfs(s,1e9);
		}
	}
}
int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};
inline int id(int x,int y){return (x-1)*m+y;}
int main()
{
	n=read(),m=read();
	s=0,t=n*m+1;
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=m;++j)
		{
			int x=read();
			if(x==1) Add(s,id(i,j),1e9);
			else if(x==2) Add(id(i,j),t,1e9);
			for(int k=0;k<4;++k)
			{
				int xx=i+dx[k],yy=j+dy[k];
				if(xx<1||yy<1||xx>n||yy>m) continue;
				Add(id(i,j),id(xx,yy),1);
			}
		}
	}
	ISAP::work();
	printf("%d",ans);
	//end();
	return 0;
}
```


---

## 作者：FutaRimeWoawaSete (赞：0)

爱情其实也是狼和羊的故事，听起来那么传奇，但总是充斥着荒唐，有时还没少男少女的纯情来得简单。

如果把狼领域和羊领域看成两个互不联系的点集的话，我们会自然而然想到最小割。     

现在我们假设 $S$ 是 $1$ 阵营， $T$ 是 $2$ 阵营。  

那么我们首先肯定要把 $S$ 向所有 $1$ 格子都连一条 $Inf$ 边， $T$ 向所有 $2$ 都连一条边。

现在我们肯定要向四面连边，但是怎么才能体现我们的分割呢？     

以 $1$ 为例，我们此时四面连容量为 $1$ 的边只有可能有 $3$ 种情况。

- 连边的格子也是 $1$，那么此时此刻这条边必然不会被删去，因为这属于无意义操作；   

- 连边的格子是 $0$ ，那么此时此刻这条边有可能会被删去，最后哪个点集拿到它就在哪里修栅栏呗；   

- 连边的格子是 $2$ ，那么此时此刻一定会被删去。   

所以说网络流分类讨论的其实就是连向 $0$ 的边的归属情况，我们只要找到最小怎么割 $0$ 边即可。     

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
const int Len = 100 * 100 * 5 + 10,Inf = 1e9;
int n,m,dep[Len],S,T,cur[Len],a[105][105],head[Len],cnt = 1,ans,sum;
struct node
{
	int next,to,w;
}edge[Len << 1];
void add(int from,int to,int w)
{
	edge[++ cnt].to = to;
	edge[cnt].w = w;
	edge[cnt].next = head[from];
	head[from] = cnt;
}
int BFS()
{
	queue<int> q;
	memset(dep , 0 , sizeof dep);
	q.push(S);dep[S] = 1;cur[S] = head[S];
	while(!q.empty())
	{
		int p = q.front() ; q.pop();
		for(int e = head[p] ; e ; e = edge[e].next)
		{
			int to = edge[e].to;
			if(!dep[to] && edge[e].w)
			{
				dep[to] = dep[p] + 1;
				cur[to] = head[to];
				if(to == T) return dep[T];
				q.push(to);
			}
		}
	}
	return 0;
}
int dfs(int u,int In)
{
	if(u == T) return In;
	int Out = 0;
	for(int e = cur[u] ; e && In > 0 ; e = edge[e].next)
	{
		cur[u] = e;
		int to = edge[e].to;
		if(edge[e].w && dep[to] == dep[u] + 1)
		{
			int res = dfs(to , min(In , edge[e].w));
			In -= res;
			Out += res;
			edge[e].w -= res;
			edge[e ^ 1].w += res;
		}
	}
	return (!Out) ? dep[u] = 0 : Out;
}
int Clone(int x,int y){return (x - 1) * m + y;}
int dx[8] = {0 , -1 , 0 , 0 , 1};
int dy[8] = {0 , 0 , -1 , 1 , 0};
bool judge(int x,int y){if(x < 1 || x > n || y < 1 || y > m) return false;return true;}
int main()
{
	scanf("%d %d",&n,&m);
	S = 0 , T = n * m + 1;
	for(int i = 1 ; i <= n ; i ++)
		for(int j = 1 ; j <= m ; j ++) scanf("%d",&a[i][j]);
	for(int i = 1 ; i <= n ; i ++)
		for(int j = 1 ; j <= m ; j ++)
		{
			if(a[i][j] == 1) add(S , Clone(i , j) , Inf) , add(Clone(i , j) , S , 0);
			else if(a[i][j] == 2) add(Clone(i , j) , T , Inf) , add(T , Clone(i , j) , 0);
			for(int k = 1 ; k <= 4 ; k ++)
			{
				int tx = i + dx[k] , ty = j + dy[k];
				if(!judge(tx , ty)) continue;
				add(Clone(i , j) , Clone(tx , ty) , 1) , add(Clone(tx ,  ty) , Clone(i , j) , 1);
			}
		}
	while(BFS()) ans += dfs(S , Inf);
	printf("%d\n",ans / 2);
	return 0;
}
```

---

## 作者：Star_Cried (赞：0)

 _才学的最大流最小割今天就来试试八_
 
 这篇题解谨献给像我一样懵懵懂懂的人XD
 
###  最大流最小割定理

网络中的最小割就是最大流

证明也比较简单（但我不会严谨的），感性理解一下，最大流一定有一些边是满的，我们把这些边割了它就流不成了。对于其他的边，要么不是必经之路，要么边权不比同一条流上的最大流的边小，所以~~得证~~

那么这道题的话其他前辈已经讲得很好了，即求法就是

1. 将所有狼连到原点，边权INF
1. 将所有羊连到汇点，边权INF
1. 将所有点的四周加边，边权为1

这是一个对偶图的思想，相当于组成了一个网络，在这个网络中，只要点与点之间有边相连就相当于之间没有栅栏，所以一开始是全部连接的。我们要做的，就是~~砌栅栏~~把一些边断掉，使狼和羊分离。因为所有狼和所有羊都连在原点和汇点，这就相当于求最小割了。

（不知道讲清楚没有）

前面两个大家应该都清楚，边权INF相当于没有影响只是把所有狼/羊连在一起罢了。第三步就是连边：因为修一个栅栏需要1，所以边权为1，简直和对偶图一模一样（本来就是一个思想）

所以这里建议没写过bzoj1001的人联系一下~

同样的，这里的难度就在于建边，建完求最大流就行了。

注意数组的大小。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cctype>
#include<utility>
#include<queue>
using namespace std;
inline int read()
{
	int w=0,x=0;char c=getchar();
	while(!isdigit(c))w|=c=='-',c=getchar();
	while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return w?-x:x;
}
namespace star
{
	const int maxn=100005,INF=0x3f3f3f3f;
	int n,m;
	int mapp[105][105];
	int ecnt=1,head[maxn],t[maxn<<1],nxt[maxn<<1],val[maxn<<1];
	inline void addedge(int from,int to, int dis)
	{
		t[++ecnt]=to;val[ecnt]=dis;nxt[ecnt]=head[from];head[from]=ecnt;
		t[++ecnt]=from;val[ecnt]=0;nxt[ecnt]=head[to];head[to]=ecnt;
	}
	int fx[]={0,1,0,-1},fy[]={1,0,-1,0};
	int cnt;
	int dep[maxn],start,end,cur[maxn];
	inline bool BFS()
	{
		queue<int> q;
		for(int i=1;i<=cnt;i++)dep[i]=-1,cur[i]=head[i];
		dep[start]=0;
		q.push(start);
		while(!q.empty())
		{
			int u=q.front();q.pop();
			for(int i=head[u];i;i=nxt[i])
				if(val[i] and dep[t[i]]==-1)
					dep[t[i]]=dep[u]+1,q.push(t[i]);
		}
		if(dep[end]==-1)return 0;
		return 1;
	}
	
	int DFS(int x,int flow)
	{
		if(x==end)return flow;
		int used=0;
		for(int i=cur[x];i;i=nxt[i])
		{
			cur[x]=i;
			int u=t[i];
			if(val[i] and dep[u]==dep[x]+1)
			{
				int w=DFS(u,min(val[i],flow-used));
				used+=w;
				val[i]-=w;
				val[i^1]+=w;
				if(used==flow)return flow;
			}
		}
		if(!used)dep[x]=-1;
		return used;
	}
	inline void build()
	{
		n=read(),m=read();
		cnt=0;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				mapp[i][j]=++cnt;
		start=++cnt,end=++cnt;
		for(int zp,i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				if((zp=read())==1)addedge(start,mapp[i][j],INF);
				else if(zp==2)addedge(mapp[i][j],end,INF);
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				for(int k=0;k<4;k++)
				{
					int xx=i+fx[k],yy=j+fy[k];
					if(xx<1 or xx>n or yy<1 or yy>m)continue;
					addedge(mapp[i][j],mapp[xx][yy],1);
				}
	}
	inline void work()
	{
		build();
		int ans=0;
		while(BFS())ans+=DFS(start,INF);
		printf("%d\n",ans);
	}
}
int main()
{
	star::work();
	return 0;
}
```


---

## 作者：TheShadow (赞：0)

# 闲扯

今天上课将网络流例题，难得的想出怎么建图的几个题之一。。

# 题面

[题面](luogu.org/problem/P2598)

# Solution

因为只有羊和狼两种生物，且不能分到同一个集合中，所以可以建立二分图。而我们要用最少的篱笆，将狼和羊分开，考虑最小割。

虚拟一个超级源点，连向所有是狼的格子，流量为 $INF$ ，表示这个边不能割。

虚拟一个超级汇点，将所有是羊的格子连向它，流量为 $INF$ ，理由同上。

然后对于每一个格子，向他的四周连一条流量为 $1$ 的边，表示在这两个格子之间修一个篱笆，费用为 $1$ 。

当然，如果相邻两个格子都是狼或者都是羊，就不用连了，因为没必要在这里修篱笆。

然后跑最小割，每条割边表示在这里修一个篱笆。

正确性：对于所有的狼、羊，都是连着源点、汇点的，流量为 $INF$ ，一定不会割这些边，而狼和羊、空格子连边代表篱笆，这个图的最小割集使得该图分为只含狼、只含羊的两个集合，也就满足了题意。

# Code

```c++
#include<bits/stdc++.h>
#define del(a,i) memset(a,i,sizeof(a))
#define ll long long
#define inl inline
#define il inl void
#define it inl int
#define ill inl ll
#define re register
#define ri re int
#define rl re ll
#define mid ((l+r)>>1)
#define lowbit(x) (x&(-x))
#define INF 0x3f3f3f3f
using namespace std;
template<class T>il read(T &x){
	int f=1;char k=getchar();x=0;
	for(;k>'9'||k<'0';k=getchar()) if(k=='-') f=-1;
	for(;k>='0'&&k<='9';k=getchar()) x=(x<<3)+(x<<1)+k-'0';
	x*=f;
}
template<class T>il print(T x){
	if(x/10) print(x/10);
	putchar(x%10+'0');
}
ll mul(ll a,ll b,ll mod){long double c=1.;return (a*b-(ll)(c*a*b/mod)*mod)%mod;}
it qpow(int x,int m,int mod){
	int res=1,bas=x%mod;
	while(m){
		if(m&1) res=(res*bas)%mod;
		bas=(bas*bas)%mod,m>>=1;
	}
	return res%mod;
}
const int MAXN = 105;
int n,m,s,t,val[MAXN][MAXN],cur[MAXN*MAXN],head[MAXN*MAXN],num_edge=-1,dis[MAXN*MAXN];
struct Edge{
	int next,to,w;
	Edge(){}
	Edge(int next,int to,int w):next(next),to(to),w(w){}
}edge[MAXN*MAXN*9];
il add_edge(int u,int v,int w){
	edge[++num_edge]=Edge(head[u],v,w),head[u]=num_edge;
	edge[++num_edge]=Edge(head[v],u,0),head[v]=num_edge;
}
inl bool BFS(int s,int t){
	del(dis,0),dis[s]=1;
	queue<int> q;q.push(s);
	while(!q.empty()){
		ri pos=q.front();q.pop();
		for(ri i=head[pos];i!=-1;i=edge[i].next)
			if(!dis[edge[i].to]&&edge[i].w>0){
				dis[edge[i].to]=dis[pos]+1;
				if(edge[i].to==t) return true;
				q.push(edge[i].to);
			}
	}
	return false;
}
it DFS(int now,int t,int flow){
	if(now==t) return flow;
	ri s=0,k;
	for(ri &i=cur[now];i!=-1;i=edge[i].next)
		if(dis[edge[i].to]==dis[now]+1&&edge[i].w>0){
			k=DFS(edge[i].to,t,min(flow-s,edge[i].w));
			s+=k,edge[i].w-=k,edge[i^1].w+=k;
			if(s==flow) break;
		}
	if(s==0) dis[now]=0;
	return s;
}
it Dinic(int s,int t){
	ri res=0;
	while(BFS(s,t)){
		memcpy(cur,head,sizeof(head));
		res+=DFS(s,t,INF);
	}
	return res;
}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n),read(m),del(head,-1),t=n*m+1;
	for(ri i=1;i<=n;++i)
		for(ri j=1;j<=m;++j)
			read(val[i][j]);
	for(ri i=1;i<=n;++i)
		for(ri j=1;j<=m;++j){
			if(val[i][j]==1) add_edge(s,(i-1)*m+j,INF);
			if(val[i][j]==2) add_edge((i-1)*m+j,t,INF);
			if(i!=1&&(val[i][j]!=val[i-1][j]||!val[i][j])) add_edge((i-1)*m+j,(i-2)*m+j,1);
			if(i!=n&&(val[i][j]!=val[i+1][j]||!val[i][j])) add_edge((i-1)*m+j,i*m+j,1);
			if(j!=1&&(val[i][j]!=val[i][j-1]||!val[i][j])) add_edge((i-1)*m+j,(i-1)*m+j-1,1);
			if(j!=m&&(val[i][j]!=val[i][j+1]||!val[i][j])) add_edge((i-1)*m+j,(i-1)*m+j+1,1);
		}
	printf("%d",Dinic(s,t));
	return 0;
}
```

# 总结

这应该是一个比较简单的最小割的题吧，建图比较明显，看到两种不同的东西，不能分在一起，可以往这方面联想一下。

---

## 作者：muller (赞：0)

其实这题就是一道简单的最小割

我们只要对于原图建一个源点，汇点

然后

源点向所有狼连流量 oo 的边

所有羊向汇点连流量 oo 的边

所有点向四周能到达连流量为 1 的边。

然后一边最小割即可

我写的是dinic

（其实就是最大流）

然后就瞬间A题

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
const int N = 50005, M = N << 4, inf = 1 << 30;
const int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};
int to[M], nxt[M], len[M], inv[M], fir[N], cur[N], lev[N], q[N], a[205][205];
int S, T, ecnt;
bool vis[N];
void ae(int u, int v, int w) {
    to[++ecnt] = v; nxt[ecnt] = fir[u]; len[ecnt] = w; inv[ecnt] = ecnt + 1; fir[u] = ecnt;
    to[++ecnt] = u; nxt[ecnt] = fir[v]; len[ecnt] = 0; inv[ecnt] = ecnt - 1; fir[v] = ecnt;
}
bool make_level() {
    int l, r, u, v, w, i;
    memset(vis, false, sizeof(vis));
    for (i = S; i <= T; ++i) cur[i] = fir[i];
    q[l = r = 1] = S; lev[S] = 1; vis[S] = true;
    while (l <= r) {
        u = q[l++];
        for (i = fir[u]; i; i = nxt[i]) {
            v = to[i]; w = len[i];
            if (w && !vis[v]) {
                lev[v] = lev[u] + 1;
                vis[q[++r] = v] = true;
            }
        }
    }
    return vis[T];
}
int dinic(int u, int lim) {
    if (u == T) return lim;
    int tmp, ret = 0, v, w, i;
    for (i = cur[u]; i; i = nxt[i]) {
        v = to[i]; w = len[i];
        if (w && lev[v] == lev[u] + 1) {
            tmp = dinic(v, min(w, lim));
            len[i] -= tmp; len[inv[i]] += tmp;
            ret += tmp; lim -= tmp;
            if (!lim) {cur[u] = i; return ret;}
        }
    }
    cur[u] = 0; return ret;
}
int main() {
    int n, m, i, j, k, x, y, ans = 0;
    scanf("%d%d", &n, &m);
    S = 0; T = n * m + 1;
    for (i = 1; i <= n; ++i)
        for (j = 1; j <= m; ++j) scanf("%d", &a[i][j]);
    for (i = 1; i <= n; ++i)
        for (j = 1; j <= m; ++j) {
            if (a[i][j] == 1) ae(S, (i - 1) * m + j, inf);
            if (a[i][j] == 2) ae((i - 1) * m + j, T, inf);
        }
    for (i = 1; i <= n; ++i)
        for (j = 1; j <= m; ++j)
            for (k = 0; k < 4; ++k) {
                x = i + dx[k]; y = j + dy[k];
                if (x > 0 && x <= n && y > 0 && y <= m) ae((i - 1) * m + j, (x - 1) * m + y, 1);
            }
    while (make_level()) ans += dinic(S, inf);
    printf("%d\n", ans);
    return 0;
}

```


---

## 作者：Newuser (赞：0)

//本蒟蒻博客的同步阅读：[Newuser小站！](http://www.newuser.top/2018/04/14/%e3%80%90zjoi2009%e7%8b%bc%e5%92%8c%e7%be%8a%e7%9a%84%e6%95%85%e4%ba%8b%e3%80%91%e6%9c%80%e5%a4%a7%e6%b5%81%e6%9c%80%e5%b0%8f%e5%89%b2/)

其实这是一道UVA1515的简化版，luogu传送门https://www.luogu.org/problemnew/show/UVA1515
翻译在这道题讨论区里面，原版本里面除了划分以外还有修改地盘操作，但稍加思索也并不难，看向本题。

这道题很显然的一道最大流最小割板子题。我们最后就是求将羊和狼割成两块的最小割，直接S连所有的羊，狼连所有的T，容量为inf，然后将羊与狼连接，容量为1就好啦！

值得斟酌的是里面的0.稍加思索之后，我们把0当做羊来连边，因为我们看羊的连边即是连向0和狼，而0的连边也是连向0和狼，但0不与S相连，容量这里都为1。

大致最后的图是 ：   S-》羊-》0-》狼-》T

搞定！

```cpp
//S->yang-0-> lang ->T	 
#include<bits/stdc++.h>
#define id(x,y) ((x-1)*m+y)
using namespace std;
const int inf=0x3f3f3f3f;
int n,m,S,T;
int dx[4]={0,0,-1,1};
int dy[4]={1,-1,0,0};
int tu[105][105];
int la[10005],nt[100005],en[100005],v[100005],owo=1;
void addedge(int a,int b,int c)
{
	en[++owo]=b; nt[owo]=la[a]; la[a]=owo; v[owo]=c;
}
int dis[10005],cnt[10005];
int sap(int x,int flow)
{
	if(x==T) return flow;
	int dlt=0,tmp;
	for(int it=la[x];it;it=nt[it])
	{
		if(v[it]&&dis[x]==dis[en[it]]+1)
		{
			tmp=sap(en[it],min(flow-dlt,v[it]));
			dlt+=tmp;
			v[it]-=tmp;
			v[it^1]+=tmp;
			if(dlt==flow||dis[S]>=n*m+2) return dlt;
		}
	}
	if(dis[S]>=n*m+2) return dlt;
	cnt[dis[x]]--;
	if(!cnt[dis[x]]) dis[S]=n*m+2;
	dis[x]++;
	cnt[dis[x]]++;
	return dlt;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&tu[i][j]);
	S=n*m+1; T=n*m+2;
	int nx,ny;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			if(tu[i][j]==2)
			{
				addedge( id(i,j) ,T, 0x3f3f3f3f );
				addedge( T,id(i,j), 0);
			}
			else 
			{
				if(tu[i][j]==1)
				{
				addedge( S,id(i,j) ,0x3f3f3f3f );
				addedge( id(i,j),S,0);
				} 
				for(int k=0;k<4;k++)
				{
					nx=i+dx[k]; ny=j+dy[k];
					if(nx>=1&&nx<=n&&ny>=1&&ny<=m) 
					{
						if(tu[nx][ny]==0||tu[nx][ny]==2)
						{
							addedge(id(i,j),id(nx,ny),1);
							addedge( id(nx,ny),id(i,j),0 );
						}
					}
				}
			}
		}
	int ans=0;
	while(dis[S]<n*m+2)
	{
		ans+=sap(S,0x3f3f3f3f);
	}
	printf("%d",ans);
}
```

---

## 作者：秋日私语 (赞：0)

更好的阅读体验点[这里](https://blog.csdn.net/A_Comme_Amour/article/details/79681087)
题目
-

[传送门](http://www.lydsy.com/JudgeOnline/problem.php?id=1412)

题解
-

这道题还挺简单的；要求割最小的边使狼和羊两个集合互不相交，一眼看出连边求最小割；
怎么建图呢？S向所有的羊，所有的狼向T，容量都是inf；在矩形中相邻的羊和狼连边，容量为1；
对于0的点怎么处理呢，我们把它默认为羊，羊向0, 0向狼连边即可容量均为1；
这么简单的题还没有1A,原来是我把0连向狼的边容量设为inf就WA了

代码
-

```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<queue>
using namespace std;
const int maxn=100000;
const int inf=1e9;

int n,m,mp[101][101],maxflow;
struct Edge{
	int next,to,dis;
}edge[maxn<<1];
int num_edge=-1,head[maxn],cur[maxn],deep[maxn];
int dx[5]={0,0,0,1,-1},
	dy[5]={0,1,-1,0,0};
 
void add_edge(int from,int to,int dis)
{
	edge[++num_edge].next=head[from];
	edge[num_edge].to=to;
	edge[num_edge].dis=dis;
	head[from]=num_edge;
}
void add(int x,int y,int z) {add_edge(x,y,z); add_edge(y,x,0);}
int id(int x,int y) {return (x-1)*m+y;}
queue <int> q;

bool bfs(int s,int t)
{
	memset(deep,0x7f,sizeof(deep));
	while (!q.empty()) q.pop();
	for (int i=0; i<=t; i++) cur[i]=head[i];
	deep[s]=0; q.push(s);
	while (!q.empty())
	{
		int now=q.front(); q.pop();
		for (int i=head[now]; i!=-1; i=edge[i].next)
		{
			int to=edge[i].to;
			if (deep[to]>inf && edge[i].dis){
				deep[to]=deep[now]+1;
				q.push(to);
				if (to==t) return 1;
			}
		}
	}
	return deep[t]<inf;
}

int dfs(int now,int t,int limit)
{
	if (now==t || !limit) return limit;
	int flow=0,f;
	for (int i=cur[now]; i!=-1; i=edge[i].next)
	{
		cur[now]=i; int to=edge[i].to;
		if (deep[to]==deep[now]+1 && (f=dfs(to,t,min(limit,edge[i].dis))))
		{
			flow+=f;
			limit-=f;
			edge[i].dis-=f;
			edge[i^1].dis+=f;
			if (!limit) break;
		}
	}
	return flow;
}

void Dinic(int s,int t)
{
	while (bfs(s,t)) 
		maxflow+=dfs(s,t,inf);
}
void build()
{
	for (int i=1; i<=n; i++)
		for (int j=1; j<=m; j++)
		{
			if (mp[i][j]==1 || mp[i][j]==0)
				for (int k=1; k<=4; k++)
				{
					int xx=i+dx[k]; int yy=j+dy[k];
					if (1<=xx && xx<=n && 1<=yy && yy<=m)
						if (mp[xx][yy]==2) add(id(i,j),id(xx,yy),1);
						else if (mp[xx][yy]==0) add(id(i,j),id(xx,yy),1);
				}
		}
}

int main()
{
	memset(head,-1,sizeof(head));
	scanf("%d%d",&n,&m);
	int S=0,T=n*m+1;
	for (int i=1; i<=n; i++)
		for (int j=1; j<=m; j++)
		{
			scanf("%d",&mp[i][j]);
			if (mp[i][j]==1) add(S,id(i,j),inf);
			else if (mp[i][j]==2) add(id(i,j),T,inf);
		}
	build();
//	for (int i=0; i<=num_edge; i++) printf("%d: %d %d %d\n",i,edge[i^1].to,edge[i].to,edge[i].dis);
	Dinic(S,T);
	printf("%d",maxflow);
	return 0;
}
```

---

## 作者：I_AM_HelloWord (赞：0)

ZJOI的题目，看题面应该是说把狼和羊隔开，那么是不是狼群应该在一个点集中，羊群在一个点集中？

建一个超源超汇，就是要求个最小割吧？

考虑一下0吧，我们规定一下S->狼->0->羊->T，建个图跑最大流，我打的是非递归式的ISAP（比dinic快一丢丢）

想具体了解ISAP的可以看看洛谷P3376我写的题解。放个链接吧：https://www.luogu.org/wiki/show?name=%E9%A2%98%E8%A7%A3+P3376


参考代码（十分规（luo）范（suo））：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
const int INF=0x3f3f3f3f;
const int N=110;
const int M=N*N*8;
struct Edge{
    int to,cap,next;
}e[M*2];
int dx[4]={0,1,0,-1};
int dy[4]={1,0,-1,0};
int a[M],cur[M],num[M],d[M],fa[M];
int b[N][N];
int n,tn,m,S,T,EdgeCnt=0;
queue<int> Q;
int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
bool inside(int x,int y){
    return x>0 && x<=tn && y>0 &&y<=m;
}
void addedge(int u,int v,int w){
    int &p=EdgeCnt;
    e[p].to=v;e[p].cap=w;e[p].next=a[u];
    a[u]=p++;
    e[p].to=u;e[p].cap=0;e[p].next=a[v];
    a[v]=p++;
}
void BFS(){
    for (int i=1;i<=n;i++)d[i]=n;
    Q.push(T);d[T]=0;
    while (!Q.empty()){
        int u=Q.front();Q.pop();
        for (int p=a[u];p!=-1;p=e[p].next){
            int v=e[p].to;
            if (e[p^1].cap && d[v]>d[u]+1){
                d[v]=d[u]+1;
                Q.push(v);
            }
        }
    }
}
int Augment(){
    int u=T,f=INF;
    while (u!=S){
        u=fa[u];
        f=min(f,e[cur[u]].cap);
    }
    u=T;
    while (u!=S){
        u=fa[u];
        e[cur[u]].cap-=f;
        e[cur[u]^1].cap+=f;
    }
    return f;
}
int MaxFlow(){
    memset(num,0,sizeof(num));
    BFS();
    for (int i=1;i<=n;i++)num[d[i]]++,cur[i]=a[i];
    int u=S,flow=0;
    while (d[S]<n){
        if (u==T){
            flow+=Augment();u=S;
        }
        bool done=false;
        for (int p=cur[u];p!=-1;p=e[p].next){
            int v=e[p].to;
            if (e[p].cap && d[u]==d[v]+1){
                done=true;cur[u]=p;fa[v]=u;u=v;
                break;
            }
        }
        if (!done){
            int m=n-1;
            for (int p=a[u];p!=-1;p=e[p].next){
                int v=e[p].to;
                if (e[p].cap)m=min(m,d[v]);
            }
            if (--num[d[u]]==0)break;
            num[d[u]=m+1]++;
            cur[u]=a[u];
            if (u!=S)u=fa[u];
        }
    }
    return flow;
}
int main(){
    memset(a,0xff,sizeof(a));
    tn=read();m=read();
    for (int i=1;i<=tn;i++)
        for (int j=1;j<=m;j++)
            b[i][j]=read();
    S=tn*m+1;T=tn*m+2;n=T;
    for (int i=1;i<=tn;i++)
        for (int j=1;j<=m;j++)
            if (b[i][j]==2){
                for (int k=0;k<4;k++){
                    int nx=i+dx[k],ny=j+dy[k];
                    if (inside(nx,ny) && b[nx][ny]<2)
                        addedge(m*(i-1)+j,m*(nx-1)+ny,1);
                }
                addedge(S,m*(i-1)+j,INF);
            }else if (!b[i][j]){
                for (int k=0;k<4;k++){
                    int nx=i+dx[k],ny=j+dy[k];
                    if (inside(nx,ny) && b[nx][ny]<2)
                        addedge(m*(i-1)+j,m*(nx-1)+ny,1);
                }
            }else addedge(m*(i-1)+j,T,INF);
    printf("%d",MaxFlow());
    return 0;
}
```

---


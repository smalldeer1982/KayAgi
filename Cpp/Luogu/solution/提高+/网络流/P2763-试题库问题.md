# 试题库问题

## 题目描述

问题描述：

假设一个试题库中有 $n$ 道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。现要从题库中抽取 $m$ 道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。

编程任务：

对于给定的组卷要求，计算满足要求的组卷方案。

## 说明/提示

$2\leq k \leq 20$，$k \leq n \leq 10^3$。

---

感谢 @PhoenixEclipse 提供 spj


## 样例 #1

### 输入

```
3 15
3 3 4
2 1 2
1 3
1 3
1 3
1 3
3 1 2 3
2 2 3
2 1 3
1 2
1 2
2 1 2
2 1 3
2 1 2
1 1
3 1 2 3```

### 输出

```
1: 1 6 8
2: 7 9 10
3: 2 3 4 5```

# 题解

## 作者：Ajwallet (赞：68)

更改内容：图片稍有改动

这里给大家提供一下题目大意和建模思想
# 题目大意
有$k$种类型和$n$个题目，每个题目会适应部分类型，`一种类型可能需要多种题，一道题可能多种类型都需要，但一道题只能满足一种类型`，现要求出满足出完所有类型的题目的方案
# 解题思路
网络流擅长于解决各种有要求的匹配，显然这道题是有条件的匹配，可以用最大流来解决。

首先建立超源点和超汇点，源点与试题相连，汇点与类型相连，对应试题与对应类型相连

现在我们来考虑边的容量

因为一道题只可以有一个，所以源点和试题的边的容量为1

同理一道题只能满足一种类型，所以试题和类型的边的容量也为1

而需要满足的类型是有多个的，所以类型与汇点的边的容量为所需类型的数量

如图![](https://cdn.luogu.com.cn/upload/pic/21711.png)

这时跑最大流即可

统计方案只需找到没有被割掉的边（可能有人不懂什么是被割掉，因为最大流=最小割）。然后输出其即可，需要注意的是，输出的不能是汇点

---

## 作者：Ajsoabk (赞：51)

# [P2763 试题库问题](https://www.luogu.org/problemnew/show/P2763)

题意有点不清

要注意每道题虽可以有多种类型，但却只能与一种类型相匹配

即最后输出时不能在不同种类型中出现同一道题

理解了题意后显然是要我们求某种题与类型之间的的匹配

而类型可以匹配多道题，而且要求某个类型只能匹配特定数量的题

故将类型（n+i）作为右部，与汇点t连容量为题目给出的匹配数量的边

求完最大流后这些边是否满流自然就意味着是否有解

题与类型之间也根据题的类型连边，每道题最多只能有1的贡献，故容量为1

再将源点s与各道题连边，求最大流

如上所述，若最大流不等于m则无解

若相等，则从1到k遍历所有右部点（类型），对每个右部点遍历邻接点，将所有值为1（这个别忘了），且指向左部的边指向的点输出即可

（喜欢就给个赞顶顶我吧）

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
const int N=1000+5,K=20+5;
const int inf=0x7fffffff;
template<class T>inline void read(T &num){
	char ch;
	while(!isdigit(ch=getchar()));
	num=ch-'0';
	while(isdigit(ch=getchar()))num=num*10+ch-'0';
}
int hea[N<<1],to[N*N<<1],nex[N*N<<1],val[N*N<<1],tot=1,n,k,dep[N<<1],s,t,m;

inline void add_edge(const int x,const int y,const int w){
	to[++tot]=y,nex[tot]=hea[x],hea[x]=tot,val[tot]=w;
}

inline void Add_edge(const int x,const int y,const int w){
//printf("%d --> %d ( %d )\n",x,y,w);
	add_edge(x,y,w);
	add_edge(y,x,0);
}

queue<int> que;
bool bfs(){
	memset(dep,0,sizeof(dep));
	dep[s]=1; 
	while(que.size())que.pop();
	que.push(s);
	int x;
	while(que.size()){
		x=que.front();que.pop();
		for(int i=hea[x];i;i=nex[i]){
			int y=to[i];
			if(val[i]&&!dep[y]){
				dep[y]=dep[x]+1;
				if(y==t)return true;
				que.push(y);
			}
		}
	}
	return false;
}

int dfs(const int x,const int flow){
//printf("dfs(%d,%d) %d\n",x,flow,x==t);
	if(x==t)return flow;
	int rest=flow,k;
	for(int i=hea[x];i&&rest;i=nex[i]){
		int y=to[i];
		if(val[i]&&dep[y]==dep[x]+1){
			k=dfs(y,min(rest,val[i]));
			if(k){
				val[i]-=k;
				val[i^1]+=k;
				rest-=k;
			}
			else dep[y]=0;
		}
	}
//printf("\t%d x=%d,return %d\n",x==s,x,flow-rest);
	return flow-rest;
}

int dinic(){
	int maxflow=0,flow;
	while(bfs())while(flow=dfs(s,inf))maxflow+=flow;
//printf("return %d\n",maxflow);
	return maxflow;
}

inline void print(const int x){
	for(int i=hea[x];i;i=nex[i]){
		int y=to[i];
//printf("\ny=%d\n",y);
		if(val[i]&&y<=n){
			printf(" %d",y);
		}
	}
}

int main(){
	read(k),read(n);
	s=n+k+1;
	t=s+1;
	for(int i=1,w;i<=k;++i){
		read(w);
		m+=w;
		Add_edge(n+i,t,w);
	}
	for(int i=1,b,h;i<=n;++i){
		Add_edge(s,i,1);
		read(h);
		for(int j=1;j<=h;++j){
			read(b);
			Add_edge(i,b+n,1);
		}
	}
	if(dinic()==m){
		for(int i=1;i<=k;++i){
			printf("%d:",i); 
			print(n+i);
			putchar('\n');
		}
	}
	else{
		printf("No Solution!\n");
	}
	return 0;
}
```

---

## 作者：⚡LZSY01_XZY⚡ (赞：21)

***
# [$\large\color{#F0F}\text{博客食用效果更佳}$](https://www.cnblogs.com/lzxzy-blog/p/10369235.html)
***
# 这题可以用网络流，但我用的是$\large\color{#f00}\text{匈牙利算法}$
---
# 进入正题

- 设第$k$个类型需要$need_k$个.将每个类型拆成$need_k$个点，用一个边集数组记录它拆成的点。
- 第$n$个试题有$p$个类型，分别将$n$与$p$拆成的点连边，这样便构成了一个二分图。
- 使用**匈牙利算法**计算最大匹配，若最大匹配小于$need$的总数，则无解。
- 输出时使用优先队列。

# OK了！！！
## code：
***
- 拆点：

```cpp
int main()
{
	for (int i=1;i<=k;i++)
	{
		need[i]=read();
		for (int j=1;j<=need[i];j++)Addedge(0,i,++cnt);
	}
}
```
***
- 将试题与类型连边：

```cpp
void dot(int u,int v)
{
	for (int k=head[v];k>0;k=set[k].nx)
		Addedge(u,set[k].v);
	return ;
}

int main()
{
	int p;
	for (int i=1;i<=n;i++)
	{
		p=read();
		for (int j=1;j<=p;j++)dot(i,read());
	}
}
```
***
- 匈牙利算法：
```cpp
bool dfs(int u)
{
	int v;
	for (int k=head[1][u];k>0;k=set[1][k].nx)
	{
		v=set[1][k].v;
		if (!vis[v])
		{
			vis[v]=true;
			if ((match[v]==-1)||dfs(match[v]))
			{
				match[v]=u;return true;
			}
		}
	}
	return false;
}
```
***
- 输出：
```cpp
priority_queue<int,vector<int>,greater<int> > Q;
int main()
{
	for (int i=1;i<=k;i++)
	{
		printf("%d: ",i);
		for (int j=head[0][i];j>0;j=set[0][j].nx)Q.push(match[set[0][j].v]);
		while (!Q.empty()){printf("%d ",Q.top());Q.pop();}
		printf("\n");
	}
}
```
***
- ##  总代码：

```cpp
#include <functional>
#include <cstdio>
#include <bitset>
#include <queue>
using namespace std;

int read()
{
	int x=0,f=1;char c=getchar();
	while (c<'0' || c>'9'){if (c=='-')f=-1;c=getchar();}
	while (c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-48;c=getchar();}
	return x*f;
}

const int MAXK=25;
const int MAXN=1010;
int n,k,cnt;

struct edge
{
	int v,nx;
}set[2][MAXN*MAXN];
int id[2];
int head[2][MAXN];
int need[MAXK],match[MAXN*MAXN];
bitset<MAXN> vis;
priority_queue<int,vector<int>,greater<int> > Q;

inline void Addedge(int loca,int u,int v)
{
	id[loca]++;set[loca][id[loca]].v=v;set[loca][id[loca]].nx=head[loca][u];
	head[loca][u]=id[loca];
}

inline void dot(int u,int v)
{
	for (int k=head[0][v];k>0;k=set[0][k].nx)
		Addedge(1,u,set[0][k].v);
	return ;
}

inline bool dfs(int u)
{
	int v;
	for (int k=head[1][u];k>0;k=set[1][k].nx)
	{
		v=set[1][k].v;
		if (!vis[v])
		{
			vis[v]=true;
			if ((match[v]==-1)||dfs(match[v]))
			{
				match[v]=u;return true;
			}
		}
	}
	return false;
}

int main()
{
	k=read();n=read();
	for (int i=1;i<=k;i++)
	{
		need[i]=read();
		for (int j=1;j<=need[i];j++)Addedge(0,i,++cnt);
	}
	int p;
	for (int i=1;i<=n;i++)
	{
		p=read();
		for (int j=1;j<=p;j++)dot(i,read());
	}
	int ans=0;
	for (int i=1;i<=cnt;i++)match[i]=-1;
	for (int i=1;i<=n;i++)
	{
		vis.reset();
		if (dfs(i))ans++;
	}
	if (ans<cnt)puts("No Solution!");
	else 
	{
		for (int i=1;i<=k;i++)
		{
			printf("%d: ",i);
			for (int j=head[0][i];j>0;j=set[0][j].nx)Q.push(match[set[0][j].v]);
			while (!Q.empty()){printf("%d ",Q.top());Q.pop();}
			printf("\n");
		}
	}
	return 0;
}
//丑代码
```
~~点赞吧~~

---

## 作者：nstk0513 (赞：16)

本题我使用了二分图匹配。（代码量比网络流小）

建图的方法如下：

左侧的点是题目类型，右侧的点是题目编号。将每一个左侧的题目类型点拆成很多个，这类题目要多少道题就拆成多少个。对于每一个题目类型拆分出来的所有点，都对右侧的题目连同样的边，属于此类型的题目就连边。

之后就可以直接二分图匹配了。

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <memory.h>
using namespace std;
const int MAXK=25,MAXN=1005;
struct Node
{
    int v;
    Node *next;
}*h[MAXN],pool[MAXN*MAXN];//邻接表结构体存图
int tot=0;
void addEdge(int u,int v)
{
    Node *p=&pool[++tot];
    p->v=v; p->next=h[u]; h[u]=p;//建图时建有向边
}
int k,n,num[MAXK],p,a,cnt,cnt2,ans,match[MAXN],tag[MAXN*MAXN];
/*num：每个类型的题目要多少道题
cnt：左侧点的总数
match：二分图匹配用的数组，记录每个点的匹配情况
tag：每个左侧点是由第几个题目类型拆出来的
*/
bool vis[MAXN*MAXN];//二分图匹配使用
vector<int> v[MAXK];//辅助建图
vector<int> res[MAXK];//记录答案
bool dfs(int u)//递归实现二分图匹配
{
    for(Node *p=h[u]; p; p=p->next)
    {
        if(!vis[p->v])
        {
            vis[p->v]=true;
            if(match[p->v]<0 || dfs(match[p->v]))
            {
                match[p->v]=u;
                return true;
            }
        }
    }
    return false;
}
int main()
{
    scanf("%d%d",&k,&n);
    for(int i=1; i<=k; i++)
    {
        scanf("%d",&num[i]);
        cnt+=num[i];//统计左侧点总数
    }
    for(int i=1; i<=n; i++)
    {
        scanf("%d",&p);
        for(int j=1; j<=p; j++)
        {
            scanf("%d",&a);
            v[a].push_back(i);//vector记录每个题目类型都有哪些题
        }
    }
    for(int i=1; i<=k; i++)
    {
        for(int j=1; j<=num[i]; j++)
        {
            cnt2++;//记录当前左侧点的编号
            tag[cnt2]=i;
            for(int K=0; K<v[i].size(); K++)//注意大小写
            {
                addEdge(cnt2,v[i][K]);
            }
        }
    }
    //二分图匹配
    memset(match,-1,sizeof(match));
    for(int i=1; i<=cnt; i++)
    {
        memset(vis,0,sizeof(vis));
        if(dfs(i)) ans++;
    }
    if(ans<cnt)
    {
        printf("No Solution!\n");//无解特判
        return 0;
    }
    for(int i=1; i<=n; i++)
    {
        res[tag[match[i]]].push_back(i);//存答案
    }
    for(int i=1; i<=k; i++)//做完了，输出
    {
        printf("%d:",i);
        for(int j=0; j<res[i].size(); j++) printf(" %d",res[i][j]);
        printf("\n");
    }
    return 0;
}
```

---

## 作者：beretty (赞：10)

## 这道题难度有点~~虚高~~

 #### ~~好久没写题解了~~ 
好像和圆桌问题很相似。（毕竟都是最大匹配）

大致就是设超级源点为0，然后将所有试卷中的试 题类型与超级源点相连，流量设为试卷中这类题的数目。

再将所有的题目与Ta们所属的类型连一条边，流量为1，再把这些题目与超级汇点（k+n+1）连起来.
然后跑一边最大流

如果结果与m(试卷中要求的题目数量)不相同，就输出No solution！

否则就循环所有的试题类型
如果这条边dis=0并且不连向0,就输出，但输出的时候要-k,因为建边的时候1~k是试题类型


然后放一下ZZ的代码。

```
#include<cstring>
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
const int M = 1005 ;
const int N = 25 ;
const int inf = 210000000 ;
inline int read(){
	char c=getchar(); int x=0,w=1;
	while(c>'9'||c<'0'){
		if(c=='-') w=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
	return x*w ;
}
struct E{
	int nex,to,dis;
}edge[M<<3];
int hea[M<<3],num;
inline void add_edge(int from,int to,int dis){
	edge[num].nex=hea[from]; edge[num].to=to;
	edge[num].dis=dis;  hea[from]=num++;
}
int n,k,d[M<<3],f[N],m,s,t;
bool bfs(){
	queue<int>q; q.push(s);
	memset(d,0,sizeof(d)); d[s]=1;
	while(!q.empty()){
		int u=q.front(); q.pop();
		for(int i=hea[u];~i;i=edge[i].nex){
			int v=edge[i].to;
			if(!d[v]&&edge[i].dis>0){
				q.push(v);
				d[v]=d[u]+1; 
			}
		}
	}
	return d[t] ;
}
int Dfs(int u,int dis){
	if(u==t||!dis) return dis;
	int sum =0 ;
    for(int i=hea[u];~i;i=edge[i].nex){
    	int v=edge[i].to;
    	if(d[v]==d[u]+1&&edge[i].dis>0){
    		int diss=Dfs(v,min(dis,edge[i].dis));
    		if(diss>0){
    			edge[i].dis-=diss; edge[i^1].dis+=diss;
    			sum+=diss; dis-=diss;
			    if(!dis) return sum;
			}
		}
	}
	return sum ;
}
int dinic(){
	int Ans=0;
	while(bfs()) Ans+=Dfs(s,inf);
	return Ans;
}
int main(){
	memset(hea,-1,sizeof(hea));
	k=read(); n=read() ; t=n+k+1 ;
	for(int i=1;i<=k;i++){
        f[i]=read();
		m+=f[i];
		add_edge(i,s,0);
		add_edge(s,i,f[i]);
	}
	for(int i=1,p;i<=n;i++){
	    p=read();
	    for(int j=1,r;j<=p;j++){
	    	r=read();
	    	add_edge(i+k,r,0);
	    	add_edge(r,i+k,1);
		}
	}
	for(int i=1;i<=n;i++){
		add_edge(t,i+k,0);
		add_edge(i+k,t,1);
	}
	if(dinic()==m){
		for(int i=1;i<=k;i++){
			printf("%d: ",i);
			for(int j=hea[i];~j;j=edge[j].nex)
			    if(edge[j].to>0&&!edge[j].dis)
			      printf("%d ",edge[j].to-k);
			printf("\n");
		}
	}
	else printf("No Solution!\n");
    return 0;
}
```

---

## 作者：VanillaYuzume (赞：7)

# 网络流24题---试题库问题

题目:[自己康](https://www.luogu.org/problem/P2763)

## 解法:求网络最大流
对于这一题,我们可以把k种不同的题目类型与源点相连 其每条管道的最大流量为该种题目所需的多少   
然后 读入n个题目 我们把这 n 个数与其对应的 p 种类型相连(流量为1)  
最后 把这n个数与汇点相连(流量为1)
直接在图中跑最大流即可

**代码酱 OVO↓**
```cpp
#include <bits/stdc++.h>
using namespace std;

#define N 1000000
#define v to[i] 
#define inf 0x7f7f7f7f

int n,m,k,s,t;
int type[N];
int dep[N],from[N],to[N],w[N],head[N],nex[N],ecnt;

void ae(int x,int y,int z){
    from[ecnt]=x;
    to[ecnt]=y;
    w[ecnt]=z;
    nex[ecnt]=head[x];
    head[x]=ecnt++;
}

bool bfs(){
    memset(dep,-1,sizeof(dep));
    queue<int> q;
    dep[s]=1; 
    q.push(s);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        for(int i=head[u];i!=-1;i=nex[i]){
            if(dep[v]==-1 and w[i]>0){
                dep[v]=dep[u]+1;
                q.push(v);
            }
        }
    }
    return dep[t]!=-1;
}

int dfs(int u,int low){
    if(u==t)
        return low;
    int ret=low;
    for(int i=head[u];i!=-1;i=nex[i]){
        if(dep[v]==dep[u]+1 and w[i]>0){
            int flow=dfs(v,min(ret,w[i]));
            if(flow>0){
                w[i]-=flow;
                w[i^i]+=flow;
            }
            ret-=flow;
            if(!ret)
                break;
        }
    }
    return low-ret;
}

int dinic(){
    int res=0;
    while(bfs()){
        res+=dfs(s,inf);
    }
    return res;
}

void pre(){
    scanf("%d%d",&k,&n);
    for(int i=1;i<=k;i++){
        scanf("%d",&type[i]);
        ae(s,i,type[i]);
        ae(i,s,0);
    }
    for(int i=1+k;i<=n+k;i++){
        ae(i,t,1);
        ae(t,i,0);
    }
    int tmp,x;
    for(int i=1;i<=n;i++){
        scanf("%d",&tmp);
        for(int j=1;j<=tmp;j++){
            scanf("%d",&x);
            ae(x,k+i,1);
            ae(k+i,x,0);
        }
    }
    //for(int i=1;i<=ecnt;i+=2)printf("from->%d to->%d w=%d\n",from[i],to[i],w[i]);
}

int main(){
    memset(head,-1,sizeof(head));
    s=0,t=10000;
    pre();
    int ans=dinic();
    //printf("%d\n",ans);
    //种类
    for(int u=1;u<=k;u++){
        printf("%d: ",u);
        for(int i=head[u];i!=-1;i=nex[i]){
            if(!w[i] and v!=s)
                printf("%d ",v-k);
        }
        printf("\n");
    }
    return 0;
}

```

---

## 作者：Ebola (赞：6)

# 首先，这是一道网络最大流的应用题

我们可以很容易的想到，应该要建立一个\*二分图\*

而图的左边是每道试题，右边则是试题类型

###### ~~偷偷地告诉大家，这道题没有No solution的情况~~

### 构图法如下：

1. 建立超级源，让它与每道试题连一条容量为1的边，容量为1很好的保证了每道题只能被选中一次

2. 建立超级汇，每种试题类型与它连一条容量为该种试题需求量的边，这样定义容量很好的保证了对每种试题的需求

3. 每道题与它所属的类型连一条容量为1的边

#### 这样，我们只需跑一遍最大流，就可以找到解决方案

跑完最大流之后，我们对所有边进行搜索，当搜索到一条从试题连向试题类型，且流量大于0的边时，我们就用结果数组将它存下来。具体存法参见下面代码中的result数组和cnt数组

##### 此外，由于这题数据比较小，EK算法应该是能A的，但我出于保险起见，还是用了Dinic。不会网络流的同学欢迎私信骚我！


    
    
    
    
    
    
```cpp
    #include<iostream>
    #include<cstdio>
    #include<cstring>
    #include<queue>
    #define INF 0x7fffffff
    using namespace std;
    struct Edge{int from,to,capa,flow,next;} e[2000000];
    int h[5000],d[5000],cur[5000];
    bool vis[5000];
    int cnt[25];
    int result[25][1010];
    int n,k,s,t;
    int sum=-1;
    void add_edge(int u,int v,int c)
    {
        sum++;
        e[sum].from=u;
        e[sum].to=v;
        e[sum].capa=c;
        e[sum].flow=0;
        e[sum].next=h[u];
        h[u]=sum;
    }
    int BFS()
    {
        memset(vis,0,sizeof(vis));
        d[s]=0;
        vis[s]=1;
        queue<int> q;
        q.push(s);
        while(!q.empty())
        {
            int o=q.front();
            for(int tmp=h[o];tmp!=-1;tmp=e[tmp].next)
            {
                if(e[tmp].capa>e[tmp].flow&&vis[e[tmp].to]==0)
                {
                    vis[e[tmp].to]=1;
                    d[e[tmp].to]=d[o]+1;
                    q.push(e[tmp].to);
                }
            }
            q.pop();
        }
        return vis[t];
    }
    int DFS(int u,int a)
    {
        if(u==t||a==0) return a;
        int flow=0,f;
        for(int& tmp=cur[u];tmp!=-1;tmp=e[tmp].next)
        {
            if(d[e[tmp].to]==d[u]+1)
            {
                f=DFS(e[tmp].to,min(a,e[tmp].capa-e[tmp].flow));
                if(f>0)
                {
                    flow+=f;
                    a-=f;
                    e[tmp].flow+=f;
                    e[tmp^1].flow-=f;
                    if(a==0) break;
                }
            }
        }
        return flow;
    }
    void Dinic()
    {
        int flow=0;
        while(BFS())
        {
            for(int i=s;i<=t;i++) cur[i]=h[i];
            flow+=DFS(s,INF);
        }
    }
    int main()
    {
        cin>>k>>n;
        s=0;
        t=k+n+1;
        for(int i=s;i<=t;i++) h[i]=-1;
        for(int i=1;i<=n;i++)
        {
            add_edge(s,i,1);
            add_edge(i,s,0);
        }
        int tmp,tmp2;
        for(int i=1;i<=k;i++)
        {
            scanf("%d",&tmp);
            add_edge(n+i,t,tmp);
            add_edge(t,n+i,0);
        }
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&tmp);
            for(int j=1;j<=tmp;j++)
            {
                scanf("%d",&tmp2);
                add_edge(i,n+tmp2,1);
                add_edge(n+tmp2,i,0);
            }
        }
        Dinic();
        memset(cnt,0,sizeof(cnt));
        //cout<<sum<<endl;
        for(int i=0;i<=sum;i++)
        {
            //if(e[i].flow<0) printf("from: %d   to: %d   \n",e[i].from,e[i].to);
            if(e[i].flow>0&&e[i].from>s&&e[i].from<=n&&e[i].to>n&&e[i].to<t)
            {
                cnt[e[i].to-n]++;
                result[e[i].to-n][cnt[e[i].to-n]]=e[i].from;
            }
        }
        for(int i=1;i<=k;i++)
        {
            printf("%d: ",i);
            for(int j=1;j<=cnt[i];j++)
                printf("%d ",result[i][j]);
            printf("\n");
        }
        return 0;
    }

```

---

## 作者：Illusory_dimes (赞：4)

## 试题库问题
### 题意

有k张试卷，每张上要求有 $a_i$ 道题，不能多，也不能少，多了会撑死，少了会饿死。

你有 $n$ 道题，每道题可给某些试卷（只能给其中一张），求满足题意的一种方案。

是不是敲好想。。

### solution

都清楚是网络流把。。就直接说了，

1.把题号连向该题可供试卷编号，权值为 $1$ ；

2.设一个超级源点，连向所有题号，权值为 $1$ ；

3.设一个超级汇点，由所有试卷编号连向其，权值为该试卷所需的题目量。

**目标乍现**

跑个最大流即可求出最大匹配量。

但是我们要干什么，判能否，写方案！

1.判能否：求出最大匹配量后，与试卷所需题目总数比较，如没有达到总数，说明没有满足方案，即可散花。。

2.写方案：找题连向试卷且是使用完了的边，直接输出题号，不虚.（因为有 SPJ 。。）

``` cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e3+10,M=4e4+2e3+48+10;
const int INF=0x3f3f3f3f;
int n,m,k,s,t,cur[N],gap[N],dep[N],q[N];
//cur[i]:当前弧优化,gap[i]:GAP优化 
int fst[N],nxt[M],to[M],val[M],tot=2;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline void add(int u,int v,int w)
{
	nxt[tot]=fst[u];
	to[tot]=v,val[tot]=1ll*w;
	fst[u]=tot;++tot;
	nxt[tot]=fst[v];
	to[tot]=u,val[tot]=0;
	fst[v]=tot;++tot;
}
inline void bfs()
{
	for(int i=1;i<=n;++i)
	dep[i]=q[i]=gap[i]=0;
	int hd=0,tl=1;
	dep[t]=1,gap[1]=1;q[tl]=t;
	//这是从汇点开始
	while(hd<tl)
	{
		int u=q[++hd];
		for(int i=fst[u];i;i=nxt[i])
		{
			int v=to[i];
			if(!dep[v])
			{
				dep[v]=dep[u]+1;
				++gap[dep[v]];
				q[++tl]=v;
			}
		}
	}
}
ll dfs(int u,ll lim)
{
	if(u==t)return lim;
	int ans=0,tmp;
	for(int i=cur[u];i;i=nxt[i])
	{
		int v=to[i];
		cur[u]=i;
		if(dep[v]==dep[u]-1&&val[i])
		{
			tmp=dfs(v,min(lim,1ll*val[i]));
			val[i]-=tmp,lim-=tmp;
			ans+=tmp,val[i^1]+=tmp;
			if(!lim)break;
		}
	}
	if((!ans)||lim)
	{
		if(--gap[dep[u]]==0)dep[s]=n+m+3;
		++gap[++dep[u]];
	}
	return ans;
}
inline ll isap()
{
	ll ans=0;
	bfs();
	while(dep[s]<=n+m+2)
	{
		memcpy(cur,fst,sizeof(cur));
		ans+=dfs(s,INF);
	}
	return ans;
}
int main()
{
	m=read(),n=read(),s=0,t=n+m+1;
	for(int i=1;i<=n;++i)add(s,i,1);
	for(int i=1;i<=m;++i)
	{
		int w=read();k+=w;
		add(i+n,t,w);
	}
	for(int i=1;i<=n;++i)
	{
		int p=read();
		for(int j=1;j<=p;++j)
		{
			int id=read();
			add(i,id+n,1);
		}
	}
	ll ans=isap();
	if(ans!=k)
	{
		puts("No Solution!");
		return 0;
	}
	else
	{
		for(int id=1;id<=m;++id)
		{
			printf("%d:",id);
			for(int i=fst[id+n];i;i=nxt[i])
			{
				int v=to[i];
				if(val[i]&&v<=n)
				printf(" %d",v);
			}
			printf("\n");
		}
	}
	return 0;
}

```
只求能帮助到几个人罢。。

---

## 作者：Constant (赞：2)

## 题意简述：

总共 $n$ 道题，题目分为 $k$ 个类型，对于每个类型 $i$ 都有一个题目数量的

限制，需要 $m$ 道题，选出的方案需要满足每个题目类型数量达到给定要求数

量，需要求出一个合法的题目方案。

## Solution：

网络流的题目主要靠建模，但分析建模思路和过程是比建模方法更重要的。

总的来谈，这是一个匹配问题，仔细分析，每种题目类型都有一个数量的限制，这

就与网络流中每条边的容量很相似，而问题中很明显的划分出了两类物品，一类是

题目，一类是题目类型，这就是一个自然的划分过程了，分析结束，于是可以考虑

使用网络流求解这个问题。

下面就是如何建图了，前面说到，问题划分为了两类点，故建立一个源点 $S$，由

该点 $S$ 向每道题连一条边，而题目只能为一道，于是该边容量为 $1$ 。

再考虑两种点之间的联系，每道题只能对应唯一的一种题目类型，所以每道题向自

己所属的题目类型连一条容量为 $1$ 的边。

最后就是通向汇点 $T$ 的问题了，每种类型 $i$ 需要 $a_i$ 道题，只需将每种

类型向汇点 $T$ 连一条容量为 $a_i$ 的边即可，下面是我的代码。

```cpp
#include<bits/stdc++.h>
#define M 1000000
using namespace std;
int k,n,m,S,T,first[M],nex[M],v[M],now[M],C,p;
int num=1,A,B;
int ans,w[M],dep[M];
int INF=999999999;
vector<int>vec[10000];
void Add(int s,int e,int cd)
{
	nex[++num]=first[s];
	first[s]=num;
	v[num]=e;
	w[num]=cd;
}
bool bfs(int s,int t)
{
	memset(dep,0,sizeof(dep));
	queue<int>q;
	dep[s]=1;
	q.push(s);
	now[s]=first[s];
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int i=first[x];i;i=nex[i])
		{
			if(w[i]>0&&dep[v[i]]==0) 
			{
				now[v[i]]=first[v[i]];
				dep[v[i]]=dep[x]+1;
				q.push(v[i]);
				if(v[i]==t) return 1; 
			}
		}
	} 
	return 0;
}
int dfs(int s,int t,int flow) 
{
	if(s==t||!flow) return flow;
	int b=0,mmin;
	for(int i=now[s];i;i=nex[i])
	{
		now[s]=i;
		if(dep[v[i]]==dep[s]+1&&w[i]>0)
		{
			mmin=dfs(v[i],t,min(flow,w[i]));
			w[i]-=mmin;
			w[i^1]+=mmin;
			b=b+mmin;
			flow-=mmin;
			if(!flow) break;
		}
	}
	return b;
}
int main()
{
    scanf("%d%d",&k,&n);
    S=2*n+1;T=2*n+2;
    for(int i=1;i<=k;i++)
    {
    	scanf("%d",&A);
    	Add(i+n,T,A);
    	Add(T,i+n,0);
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&p);
		Add(S,i,1);
		Add(i,S,0);
		for(int j=1;j<=p;j++)
		{
			scanf("%d",&A);
			Add(i,A+n,1);
			Add(A+n,i,0);
		}
	}
	while(bfs(S,T))
	{
		ans=ans+dfs(S,T,INF);
	}
	if(ans) 
	{
		for(int i=1;i<=n;i++)
		{
			for(int j=first[i];j;j=nex[j])
			{
				if(w[j]==0&&w[j^1]==1)
				{
					vec[v[j]-n].push_back(i);
				}
			} 
		}
		for(int i=1;i<=k;i++)
		{
		    printf("%d: ",i);
			for(vector<int>::iterator j=vec[i].begin();j!=vec[i].end();j++)
			{
				printf("%d ",(*j));
			}
			printf("\n");
		}
	}
	else cout<<"No Solution!";
    return 0;
}
```


---

## 作者：Shiroko (赞：2)

本题建模比较常规：

每道题选一次，所以源点连题，边权为 1 

每道题只能对一个类别作贡献，所以题连对应类别，边权为 1 

类别有要求大小，所以类别连汇点，边权为该类别需要的数量

这里不再赘述建模的细节。

**进入正题：**

## 论预流推进记录方案

 _预流推进真是个很玄学的东西_ 

~~众所周知，~~ 预流推进在推流的时候会更新一些点的高度，还会把一些点移出网络。同时，它推出一条边的流后会相应的更新反向边流的大小。


因此使用预流推进来寻找方案一般有两种方法：

1. 反向边上是否有流

2. 点是否在网络内

然而本题的~~奇特~~建模使得这两种基本的判定方式无法正常工作

通过判断边上的流来输出方案的话，样例输出就是这样：

```latex
1: 1 13 14
2: 9 10 11
3: 2 3 4 5 6 7 8 12 15
```

而通过判断点是否在网络中来输出就是这样：

```
1: 
2: 
3: 
```

~~就挺离谱的~~

**我猜测**，判断边上的流来输出方案之所以不可行是因为实际上有多种组合可以达到答案的要求，所以最后输出时相当于把所有答案组合起来输出了。

对应的，我们可以通过一个简单的方式来避免输出多余的点：添加一个计数数组来计算输出的点是否足够。

最后的代码实现如下： ~~（话说真的会有人写这题用 HLPP 吗）~~

```cpp
#include<bits/stdc++.h>
#define ite vector<Edge>::iterator
#define ith list<int>::iterator
using namespace std;

const int INF=INT_MAX;

int n,m,s,t,u,v,w,highest,now_height,tmp,N,ans,sum,k,use[100005];

struct Edge
{
	int next,targ,wght;
	Edge(int n,int t,int w): next(n),targ(t),wght(w) {}
};

queue<int>q;

list<int>h[100005];

vector<int>l,ph,gap,bs[100005];

vector<Edge>head[100005];

vector<list<int>::iterator>it;

void add(int u,int v,int w)
{
	head[u].push_back(Edge(head[v].size(),v,w));
	head[v].push_back(Edge(head[u].size()-1,u,0));
}

void relabel()
{
	gap.assign(n+5,0);
	ph.assign(n+5,n);
	ph[t]=0;
	q.push(t);
	while(!q.empty())
	{
		tmp=q.front();
		q.pop();
		for(ite i=head[tmp].begin();i!=head[tmp].end();i++)
			if(ph[i->targ]==n && head[i->targ][i->next].wght)
			{
				ph[i->targ]=ph[tmp]+1;
				gap[ph[i->targ]]++;
				q.push(i->targ);
			}
	}
	for(int i=s;i<=t;i++)
	{
		bs[i].clear();
		h[i].clear();
	}
	for(int i=s;i<=t;i++)
		if(ph[i]<n)
		{
			it[i]=h[ph[i]].insert(h[ph[i]].begin(),i);
			if(l[i])
				bs[ph[i]].push_back(i);
		}
	highest=now_height=ph[tmp];
}

void push(int u,Edge &e)
{
	int v=e.targ,df=min(l[u],e.wght);
	l[u]-=df;
	l[v]+=df;
	e.wght-=df;
	head[v][e.next].wght+=df;
	if(l[v] && l[v]==df)
		bs[ph[v]].push_back(v);
}

void push(int u)
{
	int new_height=n,u_height=ph[u];
	for(ite i=head[u].begin();i!=head[u].end();i++)
		if(i->wght)
		{
			if(ph[i->targ]==ph[u]-1)
			{
				push(u,*i);
				if(!l[u])
					return;
			}
			else
				new_height=min(new_height,ph[i->targ]+1);
		}
	if(gap[u_height]==1)
	{
		for(int i=u_height;i<=highest;i++)
			for(ith p=h[i].begin();p!=h[i].end();p++)
			{
				gap[ph[*p]]--;
				ph[*p]=n;
			}
		highest=u_height-1;
	}
	else
	{
		gap[u_height]--;
		it[u]=h[u_height].erase(it[u]);
		ph[u]=new_height;
		if(ph[u]==n)
			return;
		gap[ph[u]]++;
		it[u]=h[ph[u]].insert(h[ph[u]].begin(),u);
		highest=max(highest,now_height=new_height);
		bs[ph[u]].push_back(u);
	}
}

int HLPP()
{
	now_height=highest=0;
	ph.assign(n+5,0);
	ph[s]=n;
	it.resize(n+5);
	for(int i=s;i<=t;i++)
		if(i!=s)
			it[i]=h[ph[i]].insert(h[ph[i]].begin(),i);
	gap.assign(n+5,0);
	gap[0]=n-1;
	l.assign(n+5,0);
	l[s]=INF;
	l[t]=-INF;
	for(ite i=head[s].begin();i!=head[s].end();i++)
		push(s,*i);
	relabel();
	for(int i;now_height;)
	{
		if(bs[now_height].empty())
			now_height--;
		else
		{
			i=bs[now_height].back();
			bs[now_height].pop_back();
			push(i);
		}
	}
	return l[t]+INF;
}

int main()
{
	cin>>k>>n;
	s=0;
	t=n+k+1;
	for(int i=1;i<=k;i++)
	{
		cin>>tmp;
		sum+=tmp;
		add(i+n,t,tmp);
		use[i]=tmp;
	}
	for(int i=1;i<=n;i++)
	{
		cin>>m;
		add(s,i,1);
		for(int j=1;j<=m;j++)
		{
			cin>>tmp;
			add(i,tmp+n,1);
		}
	}
	N=n;
	n=t+1;
	ans=HLPP();
	if(ans!=sum)
	{
		cout<<"No Solution!";
		return 0;
	}
	n=N;
	for(int i=1;i<=k;i++)
	{
		cout<<i<<": ";
		for(ite p=head[i+n].begin();p!=head[i+n].end() && use[i];p++)
			if(p->targ>=1 && p->targ<=n && p->wght)
			{
				cout<<p->targ<<" ";
				use[i]--;
			}
		cout<<endl;
	}
}
```


---

## 作者：天上一颗蛋 (赞：2)

## P2763 试题库问题

题目描述

«问题描述：

假设一个试题库中有n道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。现要从题库中抽取m 道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。

«编程任务：

对于给定的组卷要求，计算满足要求的组卷方案。

输入输出格式

输入格式：
第1行有2个正整数k和n (2 <=k<= 20, k<=n<= 1000)

k 表示题库中试题类型总数，n 表示题库中试题总数。第2 行有k 个正整数，第i 个正整数表示要选出的类型i的题数。这k个数相加就是要选出的总题数m。接下来的n行给出了题库中每个试题的类型信息。每行的第1 个正整数p表明该题可以属于p类，接着的p个数是该题所属的类型号。

输出格式：
第i 行输出 “i：”后接类型i的题号。如果有多个满足要求的方案，只要输出1个方案。如果问题无解，则输出“No Solution!”。

---

搞懂了这题，会对最大流有一个更透彻的理解

# 分析

首先，这题是一个与**匹配**有关的题，遇到有关匹配的题，我们可以先联想网络流

为什么呢？因为**最大流的核心是限制**，而匹配类题目经常和限制有关（一道题只能选一次，这就是限制），所以我们使用最大流进行求解

这题需要求的是匹配方案，可能刚开始会比较难理解，那么我们先解决 此问题是否有解这个子问题先

# 是否有解？

怎么知道是否有解呢？我们知道，可以求最大匹配数，若比要求的匹配数小，则无解。这实际上是一个**二分图多重匹配问题**，可以用最大流求解：

建模思路： 源点连一部，容量为要求的匹配数，按匹配条件连接一部和二部，容量为INF，二部连汇点，容量为要求匹配数，最大流即可求出匹配数。画图即可很快得到证明。

此题中，一部为试题，容量都为1（限制每题只能用一次），二部为题类，容量为所需题目数

# 选哪些题？

知道了有解，我们怎么求解方案呢？

回想一下最大流（我用的是Dinic）的运行过程，联系所学，我们知道：最大流有一个**后悔机制**，即更新一条弧的剩余容量是，同事更新反向边的剩余容量，代码表现在这：

```cpp
int Dinic(int u,int flow){
    if(u == t)return flow;
    int rest = flow,k;
    for(int i = head[u];i;i = E[i].nxt){
        int v = E[i].v;
        if(E[i].dis && lev[v] == lev[u] + 1 && rest){
            k = Dinic(v,min(rest,E[i].dis));
            if(!k)lev[v] = 0;
            E[i].dis -= k;//这这这
            E[i ^ 1].dis += k;//还有这
            rest -= k;
            }
        }
    return flow - rest;
    }
```

我们可以利用这一点求方案

试想，如果试题库 $S$ 中有一题 $R$ ，那么最大流一定从这$R-->S$这条弧走过过，换言之，这条弧一定对最大流量有所贡献

既然正边有所贡献，那么依据后悔机制，其反边容量不就不为0了吗？

我们从试题库出发，遍历所有连$T$的反边（连向题目），若某边不为0，则被连的题目一定被此试题库选中

```cpp
    for(int u = 1 + numl;u <= numr + numl;u++){//所有试题库
        printf("%d:",u - numl);
        for(int i = head[u];i;i = E[i].nxt){
            int v = E[i].v;
            if(v == t)continue;//不能访问汇点
            if(E[i].dis == 1){//对最大流量有贡献
                printf("%d ",v);
                need[u - numl]--;
                if(!need[u - numl])break;//题目够了
                }
            }
        printf("\n");
        }
```

# AC代码

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
int RD(){
    int out = 0,flag = 1;char c = getchar();
    while(c < '0' || c >'9'){if(c == '-')flag = -1;c = getchar();}
    while(c >= '0' && c <= '9'){out = out * 10 + c - '0';c = getchar();}
    return flag * out;
    }
const int maxn = 10019,INF = 1e9;
int numr,numl,tot,nume = 1;
int need[maxn];
int s,t,maxflow;
int head[maxn];
struct Node{
    int v,dis,nxt;
    }E[maxn << 2];
void add(int u,int v,int dis){
    E[++nume].nxt = head[u];
    E[nume].v = v;
    E[nume].dis = dis;
    head[u] = nume;
    }
int lev[maxn];
bool bfs(){
    queue<int>Q;
    memset(lev,0,sizeof(lev));
    lev[s] = 1;
    Q.push(s);
    while(!Q.empty()){
        int u = Q.front();Q.pop();
        for(int i = head[u];i;i = E[i].nxt){
            int v = E[i].v;
            if(E[i].dis && !lev[v]){
                lev[v] = lev[u] + 1;
                if(v == t)return 1;
                Q.push(v);
                }
            }
        }
    return 0;
    }
int Dinic(int u,int flow){
    if(u == t)return flow;
    int rest = flow,k;
    for(int i = head[u];i;i = E[i].nxt){
        int v = E[i].v;
        if(E[i].dis && lev[v] == lev[u] + 1 && rest){
            k = Dinic(v,min(rest,E[i].dis));
            if(!k)lev[v] = 0;
            E[i].dis -= k;
            E[i ^ 1].dis += k;
            rest -= k;
            }
        }
    return flow - rest;
    }
int main(){
    numr = RD();numl = RD();//左部为题目。右部为题类，右部i为从numl + i
    s = numr + numl + 1,t = numr + numl + 2;
    int temp;
    for(int i = numl + 1;i <= numl + numr;i++){
        temp = RD();
        need[i - numl] = temp;
        tot += temp;
        add(i,t,temp);
        add(t,i,0);
        }
    int num;
    for(int i = 1;i <= numl;i++){
        num = RD();
        add(s,i,1);
        add(i,s,0);
        for(int j = 1;j <= num;j++){
            temp = RD();
            add(i,numl + temp,1);
            add(numl + temp,i,0);//建图
            }
        }
    int flow = 0;
    while(bfs()){
        while(flow = Dinic(s,INF))maxflow += flow;
        }
    if(maxflow < tot){
        printf("No Solution!\n");//判断是否有解
        return 0;
        }
    for(int u = 1 + numl;u <= numr + numl;u++){
        printf("%d:",u - numl);
        for(int i = head[u];i;i = E[i].nxt){
            int v = E[i].v;
            if(v == t)continue;//不能访问汇点
            if(E[i].dis == 1){//对最大流量有贡献
                printf("%d ",v);
                need[u - numl]--;
                if(!need[u - numl])break;//题目够了
                }
            }
        printf("\n");
        }
    return 0;
    }
```

---

## 作者：RemiliaScar1et (赞：1)

### 3.试题库问题

题目 [$link$](https://www.luogu.com.cn/problem/P2763)

如果我们把试题类型和试题都抽象为点，那么这个问题相当于在两个点集之间求匹配，点集内部不能有匹配关系。

具有点集可二分的特征，求某种匹配，我们可以考虑网络流。

**具体建图方法**：

建立超级源汇点 $S,T$

由 $S$ 向每个试题类型的点都连接一条容量为需选试题数的边(每个类型最多选这么多题)，再由每个试题向 $T$ 点连一条容量为 $1$ 的边(每个题只能选一次)。

按照对应关系在图中从类型向题连边。

建完图，我们发现**原问题中，每一种各类型选题数小于题面中给的需选试题数的选题方案，在这个图中都能找到对应的可行流与之对应**，且**流的值对应了选题总数量**。

所以我们可以放心大胆的求最大流。

**无解情况**：就是最大流的值小于与源点连接的所有边的容量和。

**寻找方案**：只需要遍历试题类型点，再遍历与它们相邻的边，若存在一条边满流，输出端点标号。由于我们是在残留网络中操作的，记得避开源点。

code(Dinic)
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=1e4,M=2e4+1e3,INF=1e8;
int head[N],ver[M],nxt[M],cc[M],tot=0;
void add(int x,int y,int c)
{
	ver[tot]=y; cc[tot]=c; nxt[tot]=head[x]; head[x]=tot++;
	ver[tot]=x; cc[tot]=0; nxt[tot]=head[y]; head[y]=tot++;
}
int q[N],d[N],cur[N];
int n,k,S,T;

bool bfs()
{
	int hh=0,tt=0;
	memset(d,-1,sizeof d);
	q[0]=S,d[S]=0,cur[S]=head[S];
	while(hh<=tt)
	{
		int x=q[hh++];
		for(int i=head[x];~i;i=nxt[i])
		{
			int y=ver[i];
			if(d[y]==-1 && cc[i])
			{
				d[y]=d[x]+1;
				cur[y]=head[y];
				if(y==T) return 1;
				q[++tt]=y;
			}
		}
	}
	return 0;
}

int find(int u,int lim)
{
	if(u==T) return lim;
	int flow=0;
	for(int i=cur[u];~i&&flow<lim;i=nxt[i])
	{
		cur[u]=i;
		int y=ver[i];
		if(d[y]==d[u]+1 && cc[i])
		{
			int tmp=find(y,min(cc[i],lim-flow));
			if(!tmp) d[y]=-1;
			cc[i]-=tmp;cc[i^1]+=tmp;flow+=tmp;
		}
	}
	return flow;
}

int dinic()
{
	int res=0,flow;
	while(bfs())
	{
		while(flow=find(S,INF)) res+=flow;
	}
	return res;
}

int main()
{
	memset(head,-1,sizeof head);
	scanf("%d%d",&k,&n);
	T=n+k+1,S=0;
	int sum=0;
	for(int i=1;i<=k;i++)
	{
		int x;
		scanf("%d",&x);
		add(S,i,x);
		sum+=x;
	}
	for(int i=1;i<=n;i++)
	{
		int p;
		add(k+i,T,1);
		scanf("%d",&p);
		for(int j=1;j<=p;j++)
		{
			int x;
			scanf("%d",&x);
			add(x,k+i,1);
		}
	}

	int ans=dinic();
	if(ans<sum) printf("No Solution!\n");
	else
	{
		for(int x=1;x<=k;x++)
		{
			printf("%d:",x);
			for(int i=head[x];~i;i=nxt[i])
				if(!cc[i] && ver[i]!=S) printf("%d ",ver[i]-k);
			printf("\n");
		}
	}
}
```

---

## 作者：11D_Beyonder (赞：1)

> 传送门 [$\looparrowright$](https://www.luogu.com.cn/problem/P2763)  

## 题目描述  
### 问题描述  
&emsp;&emsp;假设一个试题库中有 $n$ 道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。现要从题库中抽取 $m$ 道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。  
### 编程任务  
&emsp;&emsp;对于给定的组卷要求，计算满足要求的组卷方案。  
## 输入格式  
&emsp;&emsp;第一行有两个正整数 $k$ 和 $n$。$k$ 表示题库中试题类型总数，$n$ 表示题库中试题总数。  
&emsp;&emsp;第二行有 $k$ 个正整数，第 $i$ 个正整数表示要选出的类型 $i$ 的题数。这 $k$ 个数相加就是要选出的总题数 $m$。  
&emsp;&emsp;接下来的 $n$ 行给出了题库中每个试题的类型信息。每行的第一个正整数 $p$ 表明该题可以属于 $p$ 类，接着的 $p$ 个数是该题所属的类型号。  

## 输出格式  
&emsp;&emsp;输出共 $k$ 行，第 $i$ 行输出 ```i:``` 后接类型 $i$ 的题号。  
&emsp;&emsp;如果有多个满足要求的方案，只要输出一个方案。  
&emsp;&emsp;如果问题无解，则输出```No Solution!```。  

## 输入输出样例  
### 输入 \#1  
> 3 15  
> 3 3 4  
> 2 1 2  
> 1 3  
> 1 3  
> 1 3   
> 1 3  
> 3 1 2 3  
> 2 2 3  
> 2 1 3  
> 1 2  
> 1 2  
> 2 1 2  
> 2 1 3  
> 2 1 2  
> 1 1  
> 3 1 2 3  

## 输出 \#1  
> 1: 1 6 8  
> 2: 7 9 10  
> 3: 2 3 4 5  

## 说明/提示  
&emsp;&emsp;$2\leqslant k \leqslant 20$，$k \leqslant n \leqslant 10^3$。  
## 分析  
&emsp;&emsp;首先要明确一下题意，题目描述有一些不严谨。事实上，每道题虽可以属于多个类型，但却只能与一种类型相匹配，即最后输出时不能在不同种类型中出现同一道题。  
&emsp;&emsp;每个类型之间和每道题目直接都不会有内在联系，此题要求进行类型与题目的匹配：要求一个类型有多个题目，可以建立二分图多重匹配模型。首先规定节点编号，编号为 $1\sim n$ 的节点表示题目，编号为 $n+1\sim n+k$ 的节点表示类型。若题目 $i$ 属于类型 $j$，则建立一条 $i$ 到 $j+n$ 的边。  
&emsp;&emsp;网络流是解决二分图最常用也是较为高效的方法。设超级源点 $s$，编号为 $0$；超级汇点 $t$，编号为 $n+k+1$。接下来考虑如何设置各条边的容量，其核心是：**通过设置容量来保证网络流量具有实际意义**。令 $s$ 向 $1\sim n$ 的节点连边，容量为 $1$，题目节点和类型节点之间的边容量也设置为 $1$，这就意味着一道题目至多只会被使用一次。接着令 $n+1\sim n+k$ 的节点向 $t$ 连边，容量为各个类型需要的题目数量；这就意味着网络最大流一定不超过 $m$，并且，当最大流达到 $m$ 时，流入 $n+1\sim n+k$ 中任意节点的流量就等于该点表示的类型需要的题目数量。  
&emsp;&emsp;建图完成后，用 $\text{Dinic}$ 算法计算出最大流 $\mathrm{maxflow}$，若 $\text{maxflow}=m$，则存在匹配方案；否则，不存在。当存在匹配方案时，需要考虑匹配方案如何输出。我们注意到，$\text{Dinic}$ 算法建边时，会相应建立一条反向边，在残量网络上增广时，反向边的容量会被改变；反向边容量初始为 $0$，若反向边容量不为零，说明其对应的正向边对最大流有贡献。因此，不妨枚举由类型节点流向题目节点的反向边，若反向边指向一个题目节点，且其上的流量不为零，说明该题目与该类型匹配。   

## 代码   
```cpp
/******************************************************************
Copyright: 11D_Beyonder All Rights Reserved
Author: 11D_Beyonder
Problem ID: 洛谷 P2763
Date: 7/25/2020 
Description: Maximum Flow
*******************************************************************/
#include<cstring>
#include<iostream>
#include<queue>
#include<cstdio>
using namespace std;
const int N=1006;
const int inf=0x3f3f3f3f;
struct E
{
	int to;
	int cap;
	int Next;
}edge[N*N<<1];
int head[N],tot;
int s,t;//源点 汇点
int depth[N];//节点层次
int n,k,m;
void init();
inline void add_edge(int,int,int);
bool bfs();
int dfs(int x,int flow);
int Dinic();
int main()
{
	cin>>k>>n;
	init();
	int i,j;
	for(i=1;i<=k;i++)
	{
		int num;//每种类型的要求数量
		scanf("%d",&num);
		m+=num;
		add_edge(n+i,t,num);
	}
	for(i=1;i<=n;i++)
	{
		int p;
		scanf("%d",&p);
		while(p--)
		{
			int type;
			scanf("%d",&type);
			add_edge(i,type+n,1);
		}
	}
	for(i=1;i<=n;i++) add_edge(s,i,1);
	if(Dinic()==m)
	{
		//枚举类型
		for(i=1;i<=k;i++)
		{
			printf("%d: ",i);
			//访问类型指向题目的边
			for(j=head[i+n];~j;j=edge[j].Next)
			{
				if(edge[j].to>n||edge[j].to==s) continue;
				if(edge[j].cap) printf("%d ",edge[j].to);
			}
			putchar('\n');
		}
	}
	else puts("No Solution!");
	return 0;
}
void init()
{
	tot=1;
	s=0;
	t=n+k+1;
	memset(head,-1,sizeof(head));
}
inline void add_edge(int u,int v,int cap)
{
	tot++;
	edge[tot].to=v;
	edge[tot].cap=cap;
	edge[tot].Next=head[u];
	head[u]=tot;
	//建立反边
	tot++;
	edge[tot].to=u;
	edge[tot].cap=0;
	edge[tot].Next=head[v];
	head[v]=tot;
}
bool bfs()
{
	memset(depth,0,sizeof(depth));
	queue<int>q;
	q.push(s);
	depth[s]=1;
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(register int i=head[x];~i;i=edge[i].Next)
		{
			int y=edge[i].to;
			//残量网络上构建分层图
			if(edge[i].cap&&!depth[y])
			{
				q.push(y);
				depth[y]=depth[x]+1;
				if(y==t) return 1;//汇点可达
			}
		}
	}
	return 0;
}
int dfs(int x,int flow)//当前节点 当前流量
{
	//dfs 返回残量网络上可增广的流量
	if(x==t) return flow;
	int rest=flow;//rest 剩余流量
	int temp;
	for(register int i=head[x];~i&&rest;i=edge[i].Next)
	{
		int y=edge[i].to;
		if(edge[i].cap&&depth[y]==depth[x]+1)
		{
			temp=dfs(y,min(rest,edge[i].cap));
			if(!temp) depth[y]=0;//剪枝 去掉增广完毕的点
			edge[i].cap-=temp;
			edge[i^1].cap+=temp;
			rest-=temp;
		}
	}
	return flow-rest;
}
int Dinic()
{
	int maxflow=0;
	while(bfs()) maxflow+=dfs(s,inf);
	return maxflow;
}
···
```

---

## 作者：jun头吉吉 (赞：1)

## 题意
有$k$套试题与$n$道题目，每道题目可以属于 $p$ 类，每套试题需要若干道题，求能否有合法的组卷方案
## 题解
~~就是一个最大匹配的板子~~

显然，每套试题有数量上限，每道题目又只能用一次，还是要求最大的匹配，这让我们想到了什么？当然是**网络流**呀。

来考虑一下二分图匹配是怎么做的：

![](https://cdn.luogu.com.cn/upload/image_hosting/391bksxr.png)

1. 从源点$S$向所有左侧点连一条流量为$1$的边
1. 将能匹配的点连流量为$1$的边
1. 从右侧点向汇点$T$连一条流量为$1$的边

那么，这与本题唯一的区别就在于左侧点（试题）能否用多次。那么，我们只需要将第$1$步中流量改为试题数量就行了。

如果最终流量$=$总题数，那么就必定有解。那么我们只需要将从左侧点出发流量为$0$的边输出就可以了
## 代码
```cpp
 #pragma GCC optimize(3,"Ofast","inline")
#include<bits/stdc++.h>
namespace in{
	char buf[1<<21],*p1=buf,*p2=buf;
	inline int getc(){
	    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;
	}
	template <typename T>inline void read(T& t){
	    t=0;int f=0;char ch=getc();
	    while (!isdigit(ch)){
	        if(ch=='-')f = 1;
	        ch=getc();
	    }
	    while(isdigit(ch)){
   	    	t=t*10+ch-48;
   	    	ch = getc();
   		}
		if(f)t=-t;
	}
	template <typename T,typename... Args> inline void read(T& t, Args&... args){
	    read(t);read(args...);
	}
}
namespace out{
	char buffer[1<<21];
	int p1=-1;
	const int p2 = (1<<21)-1;
	inline void flush() {
		fwrite(buffer,1,p1+1,stdout),
		p1=-1;
	}
	inline void putc(const char &x) {
		if(p1==p2)flush();
		buffer[++p1]=x;
	}
	template <typename T>void write(T x) {
		static char buf[15];
		static int len=-1;
		if(x>=0){
			do{
    			buf[++len]=x%10+48,x/=10;
    		}while (x);
		}else{
    		putc('-');
			do {
    			buf[++len]=-(x%10)+48,x/=10;
			}while(x);
		}
		while (len>=0)
			putc(buf[len]),--len;
	}
}
using namespace std;
const int maxn=100010,maxe=100010*2;
struct Graph{
	struct node{
		int v,w,nxt;
	}e[maxe<<1];
	int head[maxn],cur[maxn],tot;
	int dis[maxn];
	int s,t;
	void init(int _s,int _t){s=_s,t=_t;tot=1;memset(head,0,sizeof head);}
	Graph(int _s=0,int _t=0){init(_s,_t);}
	void add(int u,int v,int w){
		//printf("%d %d %d\n",u,v,w);
		e[++tot]=(node){v,w,head[u]},head[u]=tot;
		e[++tot]=(node){u,0,head[v]},head[v]=tot;
	}
	#define v e[i].v
	inline bool bfs(){
		queue<int>q;
		memset(dis,0,sizeof dis);
		memcpy(cur,head,sizeof head);
		dis[s]=1;q.push(s);
		while(q.size()){
			int u=q.front();q.pop();
			for(int i=head[u];i;i=e[i].nxt)
				if(!dis[v]&&e[i].w){
					dis[v]=dis[u]+1,q.push(v);
					if(v==t)return true;
				}
		}
		return  false;
	}
	int dfs(int u,int flow){
		if(u==t)return flow;
		int rest=flow;
		for(int i=cur[u];i&&rest;i=e[i].nxt){
			if(dis[v]==dis[u]+1&&e[i].w){
				int tmp=dfs(v,min(rest,e[i].w));
				rest-=tmp,e[i].w-=tmp,e[i^1].w+=tmp;
			}
			cur[u]=i;
		}
		if(rest==0)dis[u]=-1;
		return flow-rest;
	}
	#undef v
	int dinic(){
		int ans=0;
		while(bfs())
			while(int sth=dfs(s,2e9))
				ans+=sth;
		return ans;
	}
}G;
int k,n,m,x; 
signed main(){
	//freopen("1.in","r",stdin);
	in::read(k,n);
	G.init(0,n+k+1);
	for(int i=1;i<=k;i++)
		in::read(x),m+=x,G.add(G.s,i,x);
	for(int i=1;i<=n;i++){
		int p;in::read(p);
		for(int j=1;j<=p;j++)
			in::read(x),G.add(x,i+k,1);
		G.add(i+k,G.t,1);
	}
	if(G.dinic()!=m){
		printf("No Solution!");
		return 0;
	}
	for(int i=1;i<=k;i++){
		printf("%d:",i);
		for(int j=G.head[i];j;j=G.e[j].nxt)
			if(G.e[j].v!=G.s&&G.e[j].w==0)
				printf("%d ",G.e[j].v-k);
		printf("\n");
	}
	out::flush();
	return 0;
}
```

---

## 作者：leozhang (赞：1)

这是我们遇到的第一个要求输出方案的问题

考虑建图然后用最大流思想：

首先由源点向每一道试题连边，容量为1

然后由每一种试题类型向汇点连边，容量为需求量

最后由每一道试题向可能属于的试题类型连边，容量为1

然后跑最大流，如果流量等于总需求量的话即证明合法（每一条到汇点的边流量都跑满才能使流量等于总需求量，这时一定是合法的）

接下来考虑在合法时如何输出方案

根据网络流的特征，我们可以发现如果某一道试题被归入了某一个类型，那么这道试题到这个类型的边就会跑上1的流量

而如果正向边跑上了1的流量，正向边的容量即变为0，而反向边的容量即成为1

所以我们仅需检验正向边容量为0/反向边容量为1任意一个条件，即可说明这道试题归属到了这个试题类型中

考虑到是按试题类型输出选择的试题编号，所以我们检验反向边更加简单一些

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <queue>
#include <stack>
using namespace std;
const int inf=0x3f3f3f3f;
struct Edge
{
    int next;
    int to;
    int val;
}edge[40005];
int head[1505];
int dis[1505];
int cur[1505];
int k,n;
int cnt=1;
int st,ed;
void init()
{
    memset(head,-1,sizeof(head));
    cnt=1;
}
void add(int l,int r,int w)
{
    edge[cnt].next=head[l];
    edge[cnt].to=r;
    edge[cnt].val=w;
    head[l]=cnt++;
}
bool bfs()
{
    memcpy(cur,head,sizeof(head));
    memset(dis,0,sizeof(dis));
    dis[st]=1;
    queue <int> M;
    M.push(st);
    while(!M.empty())
    {
        int u=M.front();
        M.pop();
        for(int i=head[u];i!=-1;i=edge[i].next)
        {
            int to=edge[i].to;
            if(!dis[to]&&edge[i].val)dis[to]=dis[u]+1,M.push(to);
        }
    }
    return dis[ed];
}
int ide(int x)
{
    return (x&1)?x+1:x-1;
}
int dfs(int x,int lim)
{
    if(x==ed)return lim;
    int ret=0;
    for(int i=head[x];i!=-1;i=edge[i].next)
    {
        int to=edge[i].to;
        if(edge[i].val&&dis[to]==dis[x]+1)
        {
            int temp=dfs(to,min(lim,edge[i].val));
            if(temp)
            {
                edge[i].val-=temp;
                edge[ide(i)].val+=temp;
                lim-=temp;
                ret+=temp;
                if(!lim)break;
            }
        }
        cur[x]=i;
    }
    return ret;
}
int dinic()
{
    int ret=0;
    while(bfs())ret+=dfs(st,inf);
    return ret;
}
int main()
{
    scanf("%d%d",&k,&n);
    init();
    st=k+n+1,ed=k+n+2;
    int s=0;
    for(int i=1;i<=k;i++)
    {
        int x;
        scanf("%d",&x);
        s+=x;
        add(i+n,ed,x);
        add(ed,i+n,0);
    }
    for(int i=1;i<=n;i++)
    {
        int num;
        scanf("%d",&num);
        for(int j=1;j<=num;j++)
        {
            int x;
            scanf("%d",&x);
            add(i,x+n,1);
            add(x+n,i,0);
        }
        add(st,i,1);
        add(i,st,0);
    }
    int t=dinic();
    if(t!=s)printf("No Solution!\n");
    else
    {
        for(int i=1;i<=k;i++)
        {
            printf("%d: ",i);
            for(int j=head[i+n];j!=-1;j=edge[j].next)
            {
                if(edge[j].to!=ed&&edge[j].val==1)printf("%d ",edge[j].to);
            }
            printf("\n");
        }
    }
    return 0;
}
```


---

## 作者：Ireliaღ (赞：1)

## 没有ISAP的题解，我来发一篇

### 题目大意

有很多题目和很多类型，每个题目可以对应多种类型，现在给出每种类型需要多少题目，输出方案  

### 前置知识：ISAP算法

可以看~~pica~~学长的[博客](https://www.cnblogs.com/ubospica/p/9974285.html)（哎?）

### 建图

一看，二分图匹配，于是我选择跑最大流较快的$ISAP$算法

(1) 首先把$0$当做超级源点，对从$1$到$n$每个题目建立容量为$1$的边

(2) 对于题目$i$如果可以属于$j$类型，那么从$i$到$n + j$建立容量为$1$的边

(3) 最后把$n + k + 1$当做超级汇点，对于类型$i$如果需要$x$道题，那么从$n + i$到$n + k + 1$建立容量为$x$的边，需要的总题数就是这些边的容量总和

$PS$:按照题目的输入顺序建图步骤应该是(1)(3)(2)

### 输出方案

以$0$为源点，$n + k + 1$为汇点跑$ISAP$最大流，如果最大流小于总题数，说明无法完成试卷安排，输出$No$ $Solution!$并结束程序。

遍历每个在$[n + 1, n + k]$的起点，遍历终点在$[1, n]$的边，也就是建图步骤(2)中建的反边，如果边权不为$0$，说明正边有流量，则选择了这组匹配，输出终点

### 代码

由于本人较懒，做网络流的题不愿意算最多需要多少条边，于是习惯采用指针动态开空间存图，$new$函数的速度较慢。但是由于加了当前弧优化的$ISAP$算法本身很快，即使是有耽误时间的$new$函数，也只跑了$30ms$，可见$ISAP$表现优异  

```cpp
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>

using std::queue;
using std::min;
using std::max;

const int MAXN = 1e4 + 5;
const int MAXK = 25;
const int INF = 0x3f3f3f3f;

int k, n;

struct Edge{
    int to, val;
    Edge *next, *opps;//需要记录反边指针
    Edge(int to, int val, Edge *next):to(to), val(val), next(next){};
};

Edge *head[MAXN + MAXK];

void AddEdge(int from, int to, int val) {
    head[from] = new Edge(to, val, head[from]);
    head[to] = new Edge(from, 0, head[to]);
    head[to]->opps = head[from]; head[from]->opps = head[to];
}

namespace ISAP{
    int dep[MAXN + MAXK], gap[MAXN + MAXK], maxflow = 0;
    int s, t;
    Edge *cur[MAXN + MAXK];

    void Bfs() {
        memset(dep, -1, sizeof(dep));
        memset(gap, 0, sizeof(gap));
        queue<int> q;
        dep[t] = 0; gap[0]++;
        q.push(t);
        int u, v;
        while (!q.empty()) {
            u = q.front(); q.pop();
            for (Edge *e = head[u]; e; e = e->next) {
                v = e->to;
                if (dep[v] != -1) continue;
                dep[v] = dep[u] + 1;
                gap[dep[v]]++;
                q.push(v);
            }
        }
    }

    int Dfs(int u, int flow) {
        if (u == t) {
            maxflow += flow;
            return flow;
        }
        int used = 0;
        for (Edge *&e = cur[u]; e; e = e->next) {//当前弧优化
            int v = e->to;
            if (e->val && dep[v] == dep[u] - 1) {
                int mi = Dfs(v, min(flow - used, e->val));
                if (mi) {
                    used += mi;
                    e->val -= mi;
                    e->opps->val += mi;
                }
                if (used == flow) return used;
            }
        }
        gap[dep[u]]--;
        if (gap[dep[u]] == 0) dep[s] = n + 1;
        dep[u]++;
        gap[dep[u]]++;
        cur[u] = head[u];//复原当前弧
        return used;
    }
    void Work() {
        for (int i = 0; i <= n + k + 1; i++) cur[i] = head[i];
        maxflow = 0;
        Bfs();
        while (dep[s] < n) Dfs(s, INF);
    }
    void OutPut() {
        for (int i = 1; i <= k; i++) {
            printf("%d: ", i);
            for (Edge *e = head[n + i]; e; e = e->next) {//遍历反边输出匹配
                int v = e->to;
                if (v >= 1 && v <= n && e->val) printf("%d ", v);
            }
            putchar('\n');
        }
    }
}

int main() {
    memset(head, 0, sizeof(head));
    scanf("%d %d", &k, &n);
    ISAP::s = 0; ISAP::t = n + k + 1;//记录超级源点汇点
    int m = 0;
    for (int i = 1; i <= n; i++) AddEdge(0, i, 1);//建图步骤(1)
    for (int i = 1, x; i <= k; i++) {//建图步骤(3)
        scanf("%d", &x);
        m += x;
        AddEdge(n + i, n + k + 1, x);
    }
    for (int i = 1, p; i <= n; i++) {//建图步骤(2)
        scanf("%d", &p);
        for (int j = 1, x; j <= p; j++) {
            scanf("%d", &x);
            AddEdge(i, n + x, 1);
        }
    }
    ISAP::Work();//跑最大流
    if (ISAP::maxflow < m) return printf("No Solution!") & 0;//压行（雾）+特判
    ISAP::OutPut();//输出方案
    return 0;
}
/*
3 15
3 3 4
2 1 2
1 3
1 3
1 3
1 3
3 1 2 3
2 2 3
2 1 3
1 2
1 2
2 1 2
2 1 3
2 1 2
1 1
3 1 2 3
*/
```

---

## 作者：ENESAMA (赞：1)

这波操作就令我很难受，日常各种写错
最恐怖的是最后的计数操作也就是辣个垃圾变量zongshu居然没有写
所以只能听取WA声一片
苟一苟最大流
```cpp
#include<bits/stdc++.h>
using namespace std;
int tot=1,kind[50005],head[50005],next[50005],to[50005];
int w[50005],shu,k,p,n,dis[50005],delta,m,zongshu;
bool pd[50005];
queue <int> que;
vector <int> sum[25];
void add(int x,int y,int z)
{
	to[++tot]=y;
	next[tot]=head[x];
	head[x]=tot;
	w[tot]=z;
	kind[tot]=x-1;
	to[++tot]=x;
	next[tot]=head[y];
	head[y]=tot;
	w[tot]=0;
}
bool bfs()
{
	memset(pd,0,sizeof(pd));
	memset(dis,0,sizeof(dis));
	que.push(1);
	pd[1]=1;
	while(!que.empty())
	{
		int x=que.front();
		que.pop();
		for(int i=head[x];i;i=next[i])
		{
			int y=to[i];
			if(!pd[y]&&w[i])
			{
				que.push(y);
				pd[y]=1;
				dis[to[i]]=dis[x]+1;
			}
		}
	}
	return pd[n+k+2];
}
int dinic(int x,int delta)
{
	if(x==n+k+2)
	return delta;
	int all=0;
	for(int i=head[x];i;i=next[i])
	{
		int y=to[i];
		if(dis[y]==dis[x]+1&&w[i])
		{
			int shu=dinic(y,min(delta,w[i]));
			w[i]-=shu;
			w[i^1]+=shu;
			delta-=shu;
			all+=shu;
		}
	}
	return all;
}
int main()
{
	cin>>k>>n;
	for(int i=1;i<=k;i++)
	{
		scanf("%d",&shu);
		m+=shu;
		add(1,i+1,shu);
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&p);
		for(int j=1;j<=p;j++)
		{
			scanf("%d",&shu);
			add(shu+1,i+k+1,1);
			zongshu++;
		}
	}
	for(int i=k+2;i<=k+n+1;i++)
		add(i,n+k+2,1);
	int ans=0;
	while(bfs())
	{
		ans+=dinic(1,m);
	}
	if(ans!=m)
	{
		printf("No Solution!");
	}
	else 
	{
		for(int i=k*2+2;i<=2*zongshu+2*k+1;i+=2)
			if(!w[i])
				sum[kind[i]].push_back(to[i]-k-1);
		for(int i=1;i<=k;i++)
		{
			printf("%d:",i);
			for(int j=0;j<sum[i].size();j++)
				printf(" %d",sum[i][j]);
			printf("\n");
		}
	}
	return 0;
}
```

---

## 作者：poorpool (赞：1)

倘若某个试题已经被选到某个类型里了，那么它就不可再被选进别的类型了。

所以，对于每个类型，我们将其与汇连边，权值是它的要求的题目数量。

对于每个题目，我们将源与其连边，权值是1，代表只能用一次。然后再将其与它所对应的所有类型连边。

倘若最大流小于m，则说明不能组卷。


输出路径我觉得还是比较好做的，对于每个类型，枚举它的每一条边，倘若边的另一头是试题，并且这条边上有流，则说明那个题是要选上的。（因为反向边）

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>
using namespace std;
struct Edge{
    int too, nxt, val;
}edge[50005];
int k, n, ss, tt, uu, vv, hea[2005], cnt, maxFlow, tot, lev[2005];
const int oo=0x3f3f3f3f;
queue<int> d;
void add_edge(int fro, int too, int val){
    edge[cnt].nxt = hea[fro];
    edge[cnt].too = too;
    edge[cnt].val = val;
    hea[fro] = cnt++;
}
void addEdge(int fro, int too, int val){
    add_edge(fro, too, val);
    add_edge(too, fro, 0);
}
bool bfs(){
    memset(lev, 0, sizeof(lev));
    d.push(ss);
    lev[ss] = 1;
    while(!d.empty()){
        int x=d.front();
        d.pop();
        for(int i=hea[x]; i!=-1; i=edge[i].nxt){
            int t=edge[i].too;
            if(!lev[t] && edge[i].val>0){
                d.push(t);
                lev[t] = lev[x] + 1;
            }
        }
    }
    return lev[tt]!=0;
}
int dfs(int x, int lim){
    if(x==tt)    return lim;
    int addFlow=0;
    for(int i=hea[x]; i!=-1 && addFlow<lim; i=edge[i].nxt){
        int t=edge[i].too;
        if(lev[t]==lev[x]+1 && edge[i].val>0){
            int tmp=dfs(t, min(lim-addFlow, edge[i].val));
            edge[i].val -= tmp;
            edge[i^1].val += tmp;
            addFlow += tmp;
        }
    }
    return addFlow;
}
void dinic(){
    while(bfs())    maxFlow += dfs(ss, oo);
}
int main(){
    memset(hea, -1, sizeof(hea));
    cin>>k>>n;
    ss = 0; tt = k + n + 1;
    for(int i=1; i<=k; i++){
        scanf("%d", &uu);
        addEdge(i+n, tt, uu);
        tot += uu;
    }
    for(int i=1; i<=n; i++){
        scanf("%d", &uu);
        for(int j=1; j<=uu; j++){
            scanf("%d", &vv);
            addEdge(i, vv+n, 1);
        }
        addEdge(ss, i, 1);//每题只能用一次
    }
    dinic();
    if(maxFlow<tot)    cout<<"No Solution!"<<endl;
    else
        for(int i=n+1; i<=n+k; i++){
            printf("%d: ", i-n);
            for(int j=hea[i]; j!=-1; j=edge[j].nxt){
                int t=edge[j].too;
                if(t<=n && edge[j].val)
                    printf("%d ", t);
            }
            printf("\n");
        }
    return 0;
}
```

---

## 作者：Booksnow (赞：0)

# 试题库问题

## 题目大意

给定 $k$ 个题目类型和 $n$ 个题目。每个题目会对应 $sign$ 个类型，但是最终每个题目只能归属于一种类型，且只能被选择一次。

给出对于每种类型的题目所需求的数量，求出一种方案使其成立。

## 分析

### 建图

此题如果去掉输出方案，其实就是一个**二分图匹配**网络流的模板题，很容易发现，可以把题目编号和题目类型分为二分图的两边，从而进行匹配。

具体建图过程如下：

- 建立一个**超级源点**和一个**超级汇点**，超级源点向表示题目的点各连接一条流量为 $1$ 的边，而表示题目类型的点向超级汇点同样个连接一条流量为 $1$ 的边。

- 对于每个题目匹配的每种类型，分别有每个题目连向其所匹配类型一条流量为 $1$ 的边。

如下图：

![](https://www.helloimg.com/images/2021/02/28/BwvEWK.md.png)

然后再跑一下最大流就行了。

### 输出

对于输出，很显然匹配的个数必须要等于每种类型需求的个数之和。

那么我们只需要从每种类型倒回去找到每条连接他且**流量为 $0$ 的边**，这就是我们要找的被选到的类型，然后再按照他的要求输出就行了。

## CODE

```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std; 
const int N=1e3+10;
int n,k,s,t;
inline int read()
{
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
int tot=-1,v[N*N],w[N*N],nex[N*N],first[2*N];
inline void Add(int x,int y,int z)
{
	nex[++tot]=first[x];
	first[x]=tot;
	v[tot]=y,w[tot]=z;
}
int head[2*N],deep[N]; 
inline bool BFS()
{
	memset(deep,-1,sizeof(deep));
	queue<int> q;
	q.push(s);
	deep[s]=0;
	while(!q.empty()){
		int now=q.front(); q.pop();
		for(register int i=first[now];i!=-1;i=nex[i]){
			int to=v[i];
			if(w[i]>0&&deep[to]==-1) deep[to]=deep[now]+1,q.push(to);
		}
	}
	return deep[t]!=-1; //如果还能有"流"到达终点 
}
inline int DFS(int S,int T,int flow)
{
	if(S==T) return flow;
	int res=0;
	for(register int& i=head[S];i!=-1;i=nex[i]){
		int to=v[i];
		if(deep[to]==deep[S]+1){ //只往下一层流动 
			int temp=DFS(to,T,min(flow,w[i])); //记录该路径可流向终点的值 
			//反悔操作，可以重新延目标点得到相同的流量返回源点 
			w[i]-=temp,w[i^1]+=temp;
			flow-=temp; //该节点当前流量减掉向该路径流走的流量 
			res+=temp; //该路径走通了，返回的答案加上到达终点的流量 
			if(!flow) return res;
		}
	}
	return res;
}
inline int dinic()
{
	int res=0;
	while(BFS()){
		memcpy(head,first,sizeof(first));
		res+=DFS(s,t,1e9);
	}
	return res;
}
signed main()
{
	memset(first,-1,sizeof(first));
	k=read(),n=read();
	int sum=0;
	s=0,t=n+k+1;
	//题号与超级源点 
	for(register int i=1;i<=n;i++) Add(s,i,1),Add(i,s,0);
	//类别与超级汇点 
	for(register int i=1;i<=k;i++) { int num=read(); Add(i+n,t,num),Add(t,i+n,0); sum+=num; } 
	for(register int i=1;i<=n;i++){
		int sign=read();
		for(register int j=1;j<=sign;j++){
			int x=read();
			Add(i,x+n,1),Add(x+n,i,0); //题号与类别连边 
		}
	}
	if(dinic()==sum){
		for(register int now=1;now<=k;now++){
			printf("%lld: ",now);
			for(register int i=first[now+n];i!=-1;i=nex[i])
				if(w[i]&&v[i]!=t) printf("%lld ",v[i]);
			printf("\n");
		}
	}
	else printf("No Solution!\n"); 
	return 0;
}
```


---

## 作者：老咸鱼了 (赞：0)

这题我们可以用最大流水过去，相信你在做这题之前应该知道什么是最大流（感觉也就蓝题的难度）
![](https://s2.ax1x.com/2019/09/17/nI1FYT.png)

建一个超级源点和一个汇点，保证每张试卷的流量到终点的流量都被消耗掉那么就能够确定能够满足题目要求的情况。
反之如果还有流量没有被消耗完，那么就无解。
题目要求的统计的哪些试卷是选哪些题我们只要计算哪些边的流量被消耗就行了。
下面附上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,S,T,cnt=1,deth[555555],head[555555],s,sum,ans;
int f[22][1111],num[22],m[22];
struct f{
	int to,next,dis;
}a[555555];
inline void add(int u,int v,int d)
{
	cnt++;
	a[cnt].to=v;
	a[cnt].next=head[u];
	a[cnt].dis=d;
	head[u]=cnt;
}
bool bfs()
{
	memset(deth,0,sizeof(deth));
	queue<int>q;
	q.push(S);
	deth[S]=1;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=a[i].next)
		{
			int t=a[i].to;
			if(!deth[t]&&a[i].dis)
			{
				q.push(t);
				deth[t]=deth[u]+1;
			}
		}
	}
	return deth[T];
}
int dfs(int u,int dist)
{
	if(u==T)
	return dist;
	int ret=0;
	for(int i=head[u];i;i=a[i].next)
	{
		if(ret==dist)
		return dist;
		int t=a[i].to;
		if(deth[t]==deth[u]+1&&a[i].dis)
		{
			int di=dfs(t,min(a[i].dis,dist));
			if(di>0)
			{
				ret+=di;
				a[i].dis-=di;
				a[i^1].dis+=di;
			}
		}
	}
	if(ret>0)
	deth[u]=0;
	return ret;
}
int main()
{
	scanf("%d%d",&k,&n);
	T=n+k+k+1;
	S=n+k+k;
	for(int i=1;i<=k;i++)
	{
		scanf("%d",&s);
		m[i]=s;
		sum+=s;
		add(i+n,T,s);
		add(T,i+n,0);
	}
	for(int i=1;i<=n;i++)
	{
		int t;
		scanf("%d",&t);
		add(S,i,1);
		add(i,S,0);
		for(int j=1;j<=t;j++)
		{
			int x;
			scanf("%d",&x);
			add(i,x+n,1);
			add(x+n,i,0);
		}
	}
	while(bfs())
	{
		while(int di=dfs(S,0x7fffffff))
		{
			ans+=di;
		}
	}
	if(ans!=sum)
	{
		cout<<"No Solution!";
	}
	else
	{
		for(int i=2;i<=cnt;i+=2)	
		{
			int t=a[i].to;
			if(a[i].dis==0&&t>n&&t<=n+k)
			{
				++num[t-n];
				f[t-n][num[t-n]]=a[i^1].to;
			}
		}
		for(int i=1;i<=k;i++)
		{
			printf("%d:",i);
			for(int j=1;j<=m[i];j++)
			{
				printf(" %d",f[i][j]);
			}
			printf("\n");
		}
	}
	return 0;	
}
```


---

## 作者：Xie_BR (赞：0)

这道题是典型的网络流，有点像是板子题，但是需要对增广路进行分析，然后才能找到符合条件的路径，在此，在此感谢spj！！！  
### 首先来分析一下思路：  
首先我们要思考的是如何建图，Xie_BR在这里提供自己的建图方案：  

1：因为没有起点和终点，所以我们需要自己设置起点&终点，及按照数据范围  为，设置不在所有点数之和的两个数值，作为起点&终点  
2：其次，再考虑如何建图。因为这道题的限制条件是每道题只能选择一次，并且每个种类的题目有数量限制，所以考虑到此，很容易想到用道路的流量来作为限制，及种类和题目相连：  

#### 题目连到种类的边权为1（每道题只能选择一次）  
#### 种类连到终点的边权为对应的第二行输入的量（每个类型的题目需要多少道）  
如此就可以很顺畅的跑一遍最大流了  
## BUT  
怎么求路径：  
因为我们建立增广路的时候会舍去边权为0的路径，所以如果某一条路径的正向边权为0，那么他就是我们要找的路径啦  
## 说了这么多，来上AC代码：  

```cpp
#include<bits/stdc++.h>
#define int long long
#define MK 20010
using namespace std;
int k,n,p,ei=1,h[MK];
int S=5000,T=5001;

struct node
{
	int next,to,v;
};
node e[MK];
int ans=0,dep[MK];

inline int add(int x,int y,int v)
{
	ei++;
	e[ei].next=h[x];
	e[ei].to=y;
	e[ei].v=v;
	h[x]=ei;
	return 0;
}

int bfs()
{
	queue<int>qu;
	memset(dep,0,sizeof(dep));
	dep[S]=1;
	qu.push(S);
	while(!qu.empty())
	{
		int f1=qu.front();
		qu.pop();
		for(int i=h[f1];i;i=e[i].next)
		{
			int to=e[i].to;
			if(dep[to]!=0||e[i].v==0)
			{
				continue;
			}
			qu.push(to);
			dep[to]=dep[f1]+1;
		}
	} 
	return dep[T]!=0;
}

int dfs(int from,int maxflow)
{
	if(from==T)
	{
		return maxflow;
	}
	int flow=0;
	for(int i=h[from];i;i=e[i].next)
	{
		int to=e[i].to;
		if(dep[to]!=dep[from]+1||e[i].v==0) 
		{
			continue;
		}
		int rst=dfs(to,min(maxflow-flow,e[i].v));
		if(rst==0) 
		{
			dep[to]=0;
		}
		e[i].v-=rst;
		e[i^1].v+=rst;
		flow+=rst;
		if(flow==maxflow) 
		{
			break;
		}
	}
	return flow;
}

int hehe[25][1010];
int ha[25];

signed main()
{
	scanf("%lld%lld",&k,&n);
	int i,j;
	for(i=1;i<=k;i++)
	{
		scanf("%lld",&ha[i]);
		add(i,T,ha[i]);
		add(T,i,0);
	}
	for(i=1;i<=n;i++)
	{
		int x;
		scanf("%lld",&p);
		for(j=1;j<=p;j++)
		{
			scanf("%lld",&x);
			add(i+k,x,1);
			add(x,i+k,0);
		}
	}
	for(i=1;i<=n;i++)
	{
		add(S,i+k,1);
		add(i+k,S,0);
	}
	while(bfs())
	{
		ans+=dfs(S,LLONG_MAX);
	} 
	if(ans==0) 
	{
		printf("No Solution!");
		return 0;
	}
	for(i=1;i<=k;i++)
	{
		int w=0;
		for(j=h[i];j;j=e[j].next)
		{
			int to=e[j].to;
			if(to==T) 
			{
				continue;
			}
			if(e[j].v!=0)
			{
				w++;
				hehe[i][w]=to;
			}
		}
	}
	for(i=1;i<=k;i++)
	{
		printf("%lld: ",i);
		for(j=1;j<=ha[i];j++)
		{
			printf("%lld ",hehe[i][j]-k);
		}
		printf("\n");
	}
	return 0;
}
```

嘻嘻，蒟蒻的想法可能比较肤浅，望大佬指教！

---

## 作者：nth_element (赞：0)

吐槽一下：蜜汁[UKE](https://www.luogu.org/record/22272395 )是什么玩意？！

***

## 题目分析：

1. 观察题面，`对于给定的组卷要求，计算满足要求的组卷方案`，可以发现这是一道明显的**有条件**的**二分图匹配**问题，于是考虑建模。

   - 建一个超级源点，一个超级汇点；源点与试题相连，汇点与类型相连。

   - 重点是**类型的题数**的建模。可以从感性来理解一下，其实这有一点限流的意思，每个类型只要求有这么多的题量，不能超出，于是考虑在类型与汇点相连的时候将容量设为类型的题数，在算最大流的时候将题量限制住，就能满足题面的要求了。(希望大家能明白我的意思 $QwQ$ )

   - 最后的图即为：超级源点与试题相连，容量为1；类型与对应的试题相连，容量为1；类型与超级汇点相连，容量为类型的题数。具体来说，超级源点 $S$ 为节点 $1$ ,试题为节点 $2—n+1$，类型为节点 $n+2—n+k+1$ 超级汇点 $T$ 为节点 $n+k+2$ 。 
2. 建模完成之后，考虑记录方案。
   - 因为 $Dinic$ 算法是通过 $Xor\;1$ 来完成正向边与反向边的转变的，故正向边的 $e[i].to$ 为路径终点，反向边的 $e[i\;Xor\;1].to$ 为路径起点， 所以可以通过枚举每一条边来找到相应的节点。
   - 又因为反向边的 $e[i\;Xor\;1].v$ 的初始化为0，当 $e[i\;Xor\;1].v\neq0$ 时，即代表这条边是最大流跑过的边，也相当于这条边被匹配了。 
   - 最后排除掉超级源点与超级汇点的情况。
3. 如果 $Dinic$ 跑一遍下来，ans(即最大流)依然为0，则本数据没有答案(即输出"No Solution!")。

***

## code(带详细注释):

```cpp
#include<bits/stdc++.h>
#define Maxn 4010
#define Maxm 10010
#define int long long 
using namespace std;
int k,n;
inline void read(int &x)
{
    int f=1;x=0;char s=getchar();
    while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
    while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
int S,T;
int ans=0,dep[Maxn];
struct edge
{
	int to,next,v;
}e[Maxm<<1];//一定注意要开两倍空间(正反两条边) 
int head[Maxn],ei=1;//一定注意这里的ei为奇数 
void add(int x,int y,int v)
{
	ei++;
	e[ei].to=y;
	e[ei].v=v;
	e[ei].next=head[x];
	head[x]=ei;
}
int bfs()
{
	queue<int>qu;
	memset(dep,0,sizeof(dep));
	dep[S]=1;
	qu.push(S);
	while(!qu.empty())
	{
		int fr=qu.front();
		qu.pop();
		for(int i=head[fr];i;i=e[i].next)
		{
			int to=e[i].to;
			if(dep[to]!=0||e[i].v==0) continue;
			qu.push(to);
			dep[to]=dep[fr]+1;
		}
	}
	return dep[T]!=0;
}
int dfs(int from,int maxflow)
{
	if(from==T) return maxflow;
	int flow=0;
	for(int i=head[from];i;i=e[i].next)
	{
		int to=e[i].to;
		if(dep[to]!=dep[from]+1||e[i].v==0) continue;
		int rst=dfs(to,min(maxflow-flow,e[i].v));
		if(rst==0) dep[to]=0;
		e[i].v-=rst;
		e[i^1].v+=rst;
		flow+=rst;
		if(flow==maxflow) break;
	}
	return flow;
}
void dinic()
{
	while(bfs())
	{
		ans+=dfs(S,LLONG_MAX);
	}
}
signed main()
{
	read(k),read(n);
	S=1,T=k+n+2;//超级源点与超级汇点 
	for(int i=1;i<=n;i++)
	{
		add(S,i+1,1);
		add(i+1,S,0);
		//超级源点与试题相连，容量为1 
	}
	for(int i=1,x;i<=k;i++)
	{
		read(x);
		add(i+n+1,T,x);
		add(T,i+n+1,0);
		//类型与超级汇点相连，容量为类型的题数 
	}
	for(int i=1,p;i<=n;i++)
	{
		read(p);
		for(int j=1,x;j<=p;j++)
		{
			read(x);
			add(i+1,x+n+1,1);
			add(x+n+1,i+1,0);
			//类型与对应的试题相连，容量为1
		}
	}
	dinic();//跑dinic 
	if(ans==0)//没有答案 
	{
		puts("No Solution!");
		return 0;
	} 
	for(int num=1;num<=k;num++)//枚举所有类型 
	{
		printf("%lld:",num);
		for(int i=2;i<=ei;i+=2)//枚举每一条边来找到相应的节点 
		{
			if(e[i].to!=S&&e[i].to!=T&&e[i^1].to!=S&&e[i^1].to!=T)//排除掉超级源点与超级汇点的情况
			{
				if(e[i^1].v!=0)//这条边已经被匹配了 
				{
					if(e[i].to-n-1==num)//判断是否为当前类型 
					{
						printf("%lld ",e[i^1].to-1);
					}
				}
			}
		}
		printf("\n");
	}
	return 0;
}
```

***

## 网络流注意事项：

> 1. 网络流关键在于建模，精髓也在建模。像本题一样的二分图匹配问题可采取我使用的建模方式：**最大匹配=最大流**。
> 2. 前向星的计数器初始化时，一定要为**奇数**。因为第n条边为正向边，第n+1条边为反向边，要实现  $e[i]$ 为正向边，$e[i\;Xor\;1]$ 为反向边，就要保证正向边的i为奇数，即计数器要初始化为奇数。
> 3. 前向星边数一定要**开两倍空间**，因为正向边一条，反向边一条。

***

不要脸的宣传一下[$\mathfrak {\color{Black}BLOG }$](https://www.cnblogs.com/nth-element/p/11313897.html)

---

## 作者：切格瓦·星 (赞：0)

这种题目最重要的还是建出一张正确的图，图一旦建对了就没什么难度可言了；

对于这个题目我们考虑：

1.每个题目只可以用一次，所以从源点向每个题目建一条边权为1的边，表示一个题目只可用一次。

2.题目分属不同的类型，所以我们可以从每个题目向该题所属的类型建一条权值为1的边。

3.总题目数由不同类型的题目共同组成，所以可从每个类型向汇点建一条权值为要选出的该类型的题数。

代码如下（其中有注释哦）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long inf=2147483647;
int n,k,p,s,t,sum,maxflow;
struct edge{
	int v,val,next;
}e[100000];
int chose[10000],dis[10000];
int cnt=1,head[100000];
void add(int u,int v,int val){
	e[++cnt].v=v;
	e[cnt].val=val;
	e[cnt].next=head[u];
	head[u]=cnt;
	e[++cnt].v=u;
	e[cnt].val=0;
	e[cnt].next=head[v];
	head[v]=cnt;
}
queue<int>q;
bool bfs(){
	memset(dis,-1,sizeof(dis));
	q.push(s);
	dis[s]=1;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=head[u];i;i=e[i].next){
			int v=e[i].v;
			if(dis[v]==-1&&e[i].val>0){
				dis[v]=dis[u]+1;
				q.push(v);
			}
		}
	}
	return dis[t]!=-1;
}
int dfs(int u,int flow){
	if(u==t) return flow;
	int res=0;
	for(int i=head[u];i;i=e[i].next){
		int v=e[i].v;
		if(dis[v]==dis[u]+1&&e[i].val){
			int fl=dfs(v,min(flow,e[i].val));
			if(fl){
				e[i].val-=fl;
				e[i^1].val+=fl;
				flow-=fl;
				res+=fl;
				if(flow==0)
				return res;
			}
		}
	}
	if(!res)
	dis[u]=-1;
	return res;
}//E-k和Dinic都可以 
int main(){
	scanf("%d %d",&k,&n);
	s=n+k+1;t=s+1;
	for(int i=1;i<=k;i++){
		scanf("%d",&chose[i]);
		sum+=chose[i];
	}
	for(int i=1;i<=n;i++){
		add(s,i,1);//从源点向题目建边 
		scanf("%d",&p);
		int a;
		for(int j=1;j<=p;j++){
			scanf("%d",&a);
			add(i,a+n,1);//从题目向题目类型建边 
		}
	}
	for(int i=1;i<=k;i++)
	add(i+n,t,chose[i]);//从题目类型向汇点建边 
	while(bfs())
	maxflow+=dfs(s,1<<29);
	//cout<<maxflow<<endl;这题目有鬼，我之前把这句话也输出了居然过了.... 
	if(maxflow==sum){
		for(int j=1;j<=k;j++){
			printf("%d: ",j);
			for(int i=1;i<=n;i++){
				for(int l=head[i];l;l=e[l].next){
					int v=e[l].v;
					if(v==j+n&&e[l].val==0){
						printf("%d ",i);
						break;
					}
				}
			}
			printf("\n");
		}
	}
	else 
	cout<<"No Solution!"<<endl;//这个也是不用的，本人亲测不加是可以过的... 
	return 0;
}
```


---

## 作者：little_sun (赞：0)

和LOJ #6004圆桌聚餐很像

建模：

1.从源点向每道试题$x_i$连一条容量为$1$的边

2.从每种类型$y_i$向汇点连一条容量为该类型需求数量的边

3.如果试题$x_i$属于类型$y_i$则从$x_i$向$y_i$连一条容量为$1$的边

然后跑裸的网络最大流，如果最大流$\not=$需求试题总数则无解

方案：

对于每种类型，它连出的所有满流量边即为该类型所对应的试题

```cpp
#include <bits/stdc++.h>

#define R register
#define ll long long
#define cmax(a, b) ((a < b) ? b : a)
#define cmin(a, b) ((a < b) ? a : b)
#define sum(a, b, mod) ((a + b) % mod)

const int MaxN = 2e4 + 10;
const int MaxM = 5e5 + 10;
const int inf = (1 << 30);

struct edge
{
    int to, next, cap;
};

edge e[MaxM];
int k, n, s = 20000, t = 20001, cnt = 1, ans;
int head[MaxN], dep[MaxN], cur[MaxN], a[MaxN];

inline void add(int u, int v, int c)
{
    ++cnt;
    e[cnt].to = v;
    e[cnt].next = head[u];
    e[cnt].cap = c;
    head[u] = cnt;
}

inline void add_edge(int u, int v, int c) { add(u, v, c), add(v, u, 0); }

inline int read()
{
    int x = 0;
    char ch = getchar();
    while (ch > '9' || ch < '0')
        ch = getchar();
    while (ch <= '9' && ch >= '0')
        x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    return x;
}

inline int bfs()
{
    memset(dep, 0, sizeof(dep));
    memcpy(cur, head, sizeof(head));
    std::queue<int> q;
    dep[s] = 1;
    q.push(s);
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        for (int i = head[u]; i; i = e[i].next)
        {
            int v = e[i].to, c = e[i].cap;
            if (dep[v] || !c)
                continue;
            dep[v] = dep[u] + 1;
            q.push(v);
        }
    }
    return dep[t];
}

inline int dinic(int u, int flow)
{
    if (u == t)
        return flow;
    int rest = flow;
    for (int i = cur[u]; i && (flow - rest < flow); i = e[i].next)
    {
        int v = e[i].to, c = e[i].cap;
        if (dep[v] != dep[u] + 1 || !c)
            continue;
        int k = dinic(v, cmin(rest, c));
        if (!k)
            dep[v] = dep[u] + 1;
        else
        {
            e[i].cap -= k;
            e[i ^ 1].cap += k;
            rest -= k;
        }
    }
    if (flow - rest < flow)
        dep[u] = -1;
    return flow - rest;
}

inline void solve()
{
    int now = 0;
    while (bfs())
        while ((now = dinic(s, inf)))
            ans += now;
}

int main()
{
    int tmp = 0;
    k = read(), n = read();
    for (int i = 1; i <= k; i++)
    {
        int x = read();
        add_edge(i, t, x);
        tmp += x;
    }
    for (int i = 1; i <= n; i++)
    {
        int p = read();
        add_edge(s, i + k, 1);
        for (int j = 1; j <= p; j++)
        {
            int x = read();
            add_edge(i + k, x, 1);
        }
    }
    solve();
    if (ans != tmp)
        return 0 * printf("No Solution!");
    for (int i = 1; i <= k; i++)
    {
        int t = head[i];
        printf("%d: ", i);
        while (t)
        {
            if (e[t].cap == 1)
                printf("%d ", e[t].to - k);
            t = e[t].next;
        }
        printf("\n");
    }
    return 0;
}
```



---

## 作者：不存在之人 (赞：0)

现在我们有N道题，K个类别。而同一道题有Pi个类别属性。我们被要求选出M道题并符合条件(每个类型选Ti道题)。

显然这是一道类似二分图匹配的题，每个题目对应一些类别，而我们要求最大的一个能满足M个匹配的方案。

所以直接简图，跑一遍最大流，如果最大流等于M，输出方案。

接下来是建图的问题，理所当然的，每道题只能选一次，所以从超级原点S，连一条1的边到每道题。

每道题只能并入一个类型中，所以从每道题连Pi条1的边到这道题所对应的类型。

因为第i个类型的题要选Ti道，所以从每个类型的点连一条为Ti 的边到超级汇点T(T=K+N+1)。

![](https://img-blog.csdn.net/20180718190124129?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RISVNfSVNfSFBR/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

(没有标出的边权值都为1，这个图和样例无关)

建完图后，直接跑网络流就好了。判断最大流是否等于题目数。

剩下的是要输出路径。

通常来说，网络流输出路径只需要找到残量为0的边跑DFS，设个bool数组判断是否走过就好了。

由于有SPJ，所以也没有什么限制，路径可以跑的很随意。
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int MAXN=2001;
const int INF=104859600;
struct edge
{
	int node,w,next;
}h[MAXN*10];
int Head[MAXN],Depth[MAXN],Stack[MAXN];
int k,n,m,p,tot=-1,x,y,kind,sum=0,s,t,top,ans=0;
bool visit[MAXN];
inline void add(int u,int v,int w)
{
	h[++tot].next=Head[u];
	h[tot].node=v;
	h[tot].w=w;
	Head[u]=tot;
}
inline bool bfs()
{
	int q[MAXN*10],head=1,tail=1;
	memset(Depth,0,sizeof(Depth));
	Depth[s]=1;
	q[head]=s;
	while(head<=tail)
	{
		int x=q[head++];
		for(register int i=Head[x];i!=-1;i=h[i].next)
		{
			int v=h[i].node;
			if(h[i].w>0&&Depth[v]==0)
			{
				Depth[v]=Depth[x]+1;
				q[++tail]=v;
			}
		}
	}
	return Depth[t];
}
inline int dfs(int x,int dist)
{ 
	if(x==t)
	   return dist;
	for(register int i=Head[x];i!=-1;i=h[i].next)
	{
		int v=h[i].node;
		if(h[i].w>0&&Depth[v]==Depth[x]+1)
		{
			int di=dfs(v,min(dist,h[i].w));
			if(di>0)
			{	
				h[i].w-=di;
				h[i^1].w+=di;
				return di;
			}
		}
	}
	return 0;
}
inline void run(int x)
{
	for(register int i=Head[x];i!=-1;i=h[i].next)
	{
		int v=h[i].node;
		if(h[i].w==0&&visit[v]==0)
		{
			Stack[++top]=v-k;
			visit[v]=1;
		}
	}
}
int main()
{
	memset(Head,-1,sizeof(Head));
	scanf("%d %d",&k,&n);
	s=0,t=n+k+1;
	for(register int i=1;i<=k;i++)
	{							
		scanf("%d",&kind);		 
		sum+=kind;
		add(s,i,kind);	
		add(i,s,0);
	}
	for(register int i=1;i<=n;i++)
	{
		add(i+k,t,1);
		add(t,i+k,0);
		scanf("%d",&p);
		for(register int j=1;j<=p;j++)
		{
			scanf("%d",&y);
			add(y,i+k,1);
			add(i+k,y,0);
		}	
	}
	while(bfs())
		ans+=dfs(s,INF);
	if(ans!=sum)
		puts("No Solution!");
	else
	{
		for(register int i=1;i<=k;i++)
		{	
			top=0;
			run(i);
			printf("%d: ",i);
			for(int j=top;j>=1;j--)
				printf("%d ",Stack[j]);
			puts("");
		}
	}	
	return 0;
}
```

---

## 作者：Isonan (赞：0)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P2763)

网络流水题。考虑每种题目数量为定值，且每道题只能对应一种题型，用二分图的方法建图：

1：从源点到每道题目连一条流为1的边；

2：从每道题目到其属于的题型建流为1的边；

3：从每种题型到汇点建流为（要求数量）的边。

然后跑一遍网络流就过了

代码：

```cpp
#include <cstdio>
#include <cstring>
#define min(X,Y) ((X)<(Y)?(X):(Y))

int head[4001],nxt[50001],b[50001],v[50001],k=1,n,K,tem,S,T;
int dis[4001],q[4001],h,t,p[4001],pre[4001],ans[4001];
void push(int s,int t,int val){
	nxt[++k]=head[s];
	head[s]=k;
	b[k]=t;
	v[k]=val;
}
void link(int s,int t,int val){
	push(s,t,val);
	push(t,s,0); 
}
bool bfs(){
	memset(dis,0,sizeof dis);
	dis[S]=1;
	h=t=0;
	q[++t]=S;
	while(h<=t){
		++h;
		for(int i=head[q[h]];i;i=nxt[i]){
			if(v[i]&&!dis[b[i]]){
				dis[b[i]]=dis[q[h]]+1;
				q[++t]=b[i];
				if(b[i]==T)return 1;
			}
		}
	}
	return 0;
}
int dfs(int x,int flow){
	if(x==T||!flow)return flow;
	int used=0;
	for(int i=p[x];i;i=nxt[i])
		if(v[i]&&dis[b[i]]==dis[x]+1){
			int w=dfs(b[i],min(flow-used,v[i]));
			v[i]-=w;
			v[i^1]+=w;
			used+=w;
			if(w)p[x]=i,ans[x]=b[i];
			if(used==flow)return flow;
		}
	if(!used)dis[x]=0;
	return used;
}
int main(){
	scanf("%d%d",&K,&n);
	S=0,T=n+K+1; 
	for(int i=1;i<=K;i++){
		scanf("%d",&tem);
		link(i+n,T,tem);
	}
	for(int i=1;i<=n;i++){
		scanf("%d",&tem);
		int x;
		for(int j=1;j<=tem;j++)scanf("%d",&x),link(i,x+n,1);
	}
	for(int i=1;i<=n;i++)link(S,i,1);
	while(bfs()){
		memcpy(p,head,sizeof p);
		dfs(S,0x7f7f7f7f);
	}
	for(int i=1;i<=K;i++){
		printf("%d: ",i);
		for(int j=1;j<=n;j++){
			if(ans[j]==i+n)printf("%d ",j);
		}
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：feather2016 (赞：0)

建图： 
这题一看就是网络流问题，然后就是怎么建图~ 
首先，我们自己选择两个点（一个源点：0， 一个汇点：k+n+1(下面再讲为什么)），然后对于源点（0）来说，要和每一道题目建立一条容量为1的边；对于每一种类型来说，都要与汇点（n+k+1）建立一条容量为所要选择此类型的题目数量的边；对于每一道题目来说，都要与这道题目所属类型建立一条容量为1的边。如此，图就建好了。（所有反向边我都没说，但是要建立） 
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <vector>
#include <queue>
#define INF 0x3f3f3f3f
using namespace std;
#define MAX 1400
struct edge
{
    int to, cap, rev;
    //终点，容量，反向边
};
vector<edge>G[MAX];//二维
int level[MAX];//bfs，对于每个节点来说给出一个层次，分层图
int iter[MAX];//优化，当前弧，在其之前的边已经没有用了
int a[1234], cost;//  对于第i种类型，要选择a[i]个题目  要选择的总题目数（a数组加和）
void add_edge(int from, int to, int cap)//建边
{
    struct edge a;
    a.to=to;
    a.cap = cap;
    a.rev = G[to].size();
    G[from].push_back(a);
    a.to = from;
    a.cap = 0;
    a.rev = G[from].size()-1;
    G[to].push_back(a);
}
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue<int>q;
    level[s] = 0;
    q.push(s);
    while(!q.empty())
    {
        int v = q.front();
        q.pop();
        for(int i=0; i<G[v].size(); i++)
        {
            edge &e = G[v][i];
            if(level[e.to]<0&&e.cap>0)
            {
                level[e.to] = level[v]+1;
                q.push(e.to);
            }
        }
    }
}
int dfs(int v, int t, int f)
{
    if(v==t)
        return f;
    for(int &i=iter[v]; i<G[v].size(); i++)
    {
        edge & e= G[v][i];
        if(level[e.to]>level[v]&&e.cap>0)
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d>0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t]<0)
            return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f=dfs(s, t, INF))>0)
        {
            flow += f;
            if(flow==cost)//每增加一道题目，就会减少1，所以只要判断流量==需要的题目数就找到了
                return flow;
        }
    }
}
int main()
{
    int k, n;
    scanf("%d %d", &k, &n);
    //k:类型    n:题数
    for(int i=0; i<n+k+2; i++)
    {
        G[i].clear();
    }
    for(int i=1; i<=k; i++)//每种类型所需要的题目数
    {
        scanf("%d", &a[i]);
        cost += a[i];//需要的总题目数
        add_edge(i+n, k+n+1, a[i]);//从类型到汇点，增加边容量为a[i]
    }
    for(int i=1; i<=n; i++)//对于每道题目
    {
        int p;
        scanf("%d", &p);//属于几个类型
        add_edge(0, i, 1);
        for(int kk=1; kk<=p; kk++)//分别是哪几个
        {
            int u;
            scanf("%d", &u);
            add_edge(i, u+n, 1);//建边
        }
    }
    int f = max_flow(0, n+k+1);//dinic 找流
    if(f!=cost)//只要不是和总题目数一样，就没有答案
    {
        printf("No Solution!\n");
    }
    else
    {
        for(int i=1;i<=k;i++)//每一种类型
        {
            printf("%d:", i);
            for(int j=0;j<G[n+i].size();j++)//观察他们的反向边，如果流量为1就说明这道题目符合
            {
                edge & e = G[n+i][j];
                if(e.cap==1)
                {
                    printf(" %d", e.to);
                }
            }
            printf("\n");
        }
    }
    return 0;
}
```

---

## 作者：zhaoyifan (赞：0)

要求每种类型达到一定的数量。

先都假设每个试题都选第一种，那么可能会有一些种类缺少

我们就需要调整。

试卷之间是没有联系的，但是最终他们的和一定，先假设有k个终点

单独来看一个试卷

要使它有效，它有且仅有一种类型，然而我们还需要对他进行调整，即

对每一个终点都进行连接，而他本身只能属于一种。

那么把这个点分割开来，分成的两个点满足使这个点只被使用一次

那么现在来看终点，根据我们的思路，调整需要满足不同终点的调整

显然最大流是难以实现的，

有没有一种方法实现呢？

那么需要建立一个最终汇点，流向汇点不能随便，必须是那些终点才可以

有了汇点怎么调整呢？限制最大流为数量！

```cpp
    #include<iostream>
    #include<cstdio>
    #include<cstring>
    #include<iomanip>
    #include<algorithm>
    #include<cmath>
    #include<queue>
    #define in(x) scanf("%d",&x)
    using namespace std;
    const int maxn=100007,pn=5007;
    queue<int>q;
    int k,n,cnt=1,s=0,t,nxt[maxn],to[maxn],w[maxn];
    int head[maxn],d[pn],ans=0,m=0,xia[pn],b[1007][1007];
    void add(int x,int y,int we)
    {
        nxt[++cnt]=head[x];head[x]=cnt;to[cnt]=y;w[cnt]=we;
        nxt[++cnt]=head[y];head[y]=cnt;to[cnt]=x;w[cnt]=0;
    }
    int bfs()
    {
        q.push(s);memset(d,0,sizeof(d));d[s]=1;
        while(q.size())
        {
            int x=q.front();q.pop();
            for(int i=head[x];i;i=nxt[i])
            {
                int u=to[i];
                if(d[u]||w[i]<=0) continue;
                d[u]=d[x]+1;q.push(u);
            }
        }
        return d[t];
    }
    int dfs(int x,int flow)
    {
        if(x==t) return flow;int r;
        for(int i=head[x];i;i=nxt[i])
        {
            int u=to[i];
            if(d[u]!=d[x]+1||w[i]<=0) continue;
            if(r=dfs(u,min(w[i],flow)))
            {    
                xia[x]=u;
                w[i]-=r;w[i^1]+=r;return r;
            }
        }
        return 0;
    }
    void dinic()
    {
        int p;
        while(bfs())
        {
            while(1)
            {
                p=dfs(s,1e9);
                if(!p) break;
                ans+=p;
            }
        }
    }
    int main()
    {
        in(k);in(n);t=n*2+k+3;
        for(int i=1;i<=k;++i) 
        {
            int x;in(x);m+=x;
            add(n*2+i,t,x);
        }
        for(int i=1;i<=n;++i)
        {
            add(s,i,1);add(i,i+n,1);
            int x;in(x);
            for(int j=1;j<=x;++j)
            {
                int y;in(y);
                add(i+n,n*2+y,1);
            }
        }
        dinic();
        if(ans<m) 
        {
            printf("No Solution!");return 0;
        }
        for(int i=1+n;i<=n*2;++i)
        {
            int o=xia[i]-n*2;
            if(o>0&&o<=k)
            b[o][++b[o][0]]=i-n;
        }
        for(int i=1;i<=k;++i)
        {
            printf("%d: ",i);
            for(int j=1;j<=b[i][0];++j)
            printf("%d ",b[i][j]);
            printf("\n");
        } 
        return 0;
}
```

---

## 作者：小强 (赞：0)

因为每个题最多选一次，那么把每个题和t（或s）点连一条容量为1的边，每个库和s点连一条容量为所需试题数目的边，跑最大流。如果最大流跑出来的最大流量刚好为所有试题数目总和，就代表有可行的方案，输出方案即可（好像就输出方案比较麻烦）。


需要注意的是因为网络流要双向连边，所以在输出时会输出s或t点，需要加上特判（已经好几次在这wa了）。


```cpp
include<cstdio>
include<iostream>
include<cstring>
include<queue>
using namespace std;

const int max_m = 22001; const int max_n = 1021;

int point[max_n],nxt[max_m],v[max_m],remain[max_m],val[max_n]; int deep[max_n],cur[max_n]; int n,k,s,t,tot,inf=1e9,x,maxn;

inline void clear() { memset(point,-1,sizeof(point)); memset(nxt,-1,sizeof(nxt)); tot=-1; }

inline void addedge(int x,int y,int val) { ++tot; nxt[tot]=point[x]; point[x]=tot; v[tot]=y; remain[tot]=val; ++tot; nxt[tot]=point[y]; point[y]=tot; v[tot]=x; remain[tot]=0; }

inline bool bfs(int s,int t) { memset(deep,0x7f,sizeof(deep));

for(int i=s; i<=t; ++i)
  cur[i]=point[i];

queue<int> q;
deep[s]=0;
q.push(s);

while(!q.empty())
{
    int now=q.front();q.pop();
    for(int i=point[now]; i!=-1; i=nxt[i])
      if(deep[v[i]]>inf && remain[i])
      {
          deep[v[i]]=deep[now]+1;
          q.push(v[i]);
      }
}

return deep[t]<inf;
}

inline int dfs(int now,int t,int limit) { if(!limit || now==t) return limit; int flow=0,f;

for(int i=cur[now]; i!=-1; i=nxt[i])
{
    cur[now]=i;
    if(deep[v[i]]==deep[now]+1 && (f=dfs(v[i],t,min(limit,remain[i]))))
    {
        flow+=f;
        limit-=f;
        remain[i]-=f;
        remain[i^1]+=f;
        if(!limit) break;
    }
}

return flow;
}

inline int dinic(int s,int t) { int ans=0;

while(bfs(s,t))
  ans+=dfs(s,t,inf);

return ans;
}

inline void output() { int ans=dinic(s,t); if(ans!=maxn) printf("No Solution!"); else { for(int i=1; i<=k; ++i) { printf("%d: ",i); for(int j=point[i]; j!=-1; j=nxt[j]) if(!remain[j] && v[j]!=s && v[j]!=t) printf("%d ",v[j]-k); printf("\n"); } } }

int main() { clear(); scanf("%d%d",&k,&n); s=0; t=n+k+1;

for(int i=1; i<=k; ++i)
{
    scanf("%d",&val[i]);
    maxn+=val[i];
    addedge(s,i,val[i]);
}

for(int i=1; i<=n; ++i)
  addedge(i+k,t,1);

for(int i=1; i<=n; ++i)
{
    int f;
    scanf("%d",&f);

    for(int j=1; j<=f; ++j)
    {
        scanf("%d",&x);//将连通的类型和试题连边 
        addedge(x,i+k,1);
    }
}

output();
return 0;
}
```

---


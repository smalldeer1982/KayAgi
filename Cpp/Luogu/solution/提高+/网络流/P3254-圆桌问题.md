# 圆桌问题

## 题目描述

有来自 $m$ 个不同单位的代表参加一次国际会议。第 $i$ 个单位派出了 $r_i$ 个代表。

会议的餐厅共有 $n$ 张餐桌，第 $i$ 张餐桌可容纳 $c_i$ 个代表就餐。

为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。请给出一个满足要求的代表就餐方案。

## 说明/提示

**【数据规模与约定】**

- 对于 $100\%$ 的数据，保证 $1 \leq m \leq 150$，$1 \leq n \leq 270$，$1 \leq r_i, c_i \leq 10^3$。

**【提示】**

- 请注意输入的第一行先读入 $m$ 再读入 $n$。

## 样例 #1

### 输入

```
4 5
4 5 3 5
3 5 2 6 4
```

### 输出

```
1
1 2 4 5
1 2 3 4 5
2 4 5
1 2 3 4 5
```

# 题解

## 作者：fastle (赞：39)

/\*
网络流的二分图匹配问题

可以直观的想到，二分图的左边是单位，右边是桌子

由于我们的特殊限制  每个单位只能在一个桌子坐一个人

所以我们就把每个单位向各个桌子连一道流量为1的边

由源点向每个单位连上 连上单位人数的边

由每个圆桌向汇点连上 圆桌人数的边

然后跑一下最大匹配  如果最大匹配数等于所有单位的人数和

那么就可以     完全安排  否则不能完全安排

这个题目的统计答案要比前两个好弄一点 枚举即可

\*/
    
    
    
    
    
    
    
```cpp
    #include<cstdio>
    #include<algorithm>
    #include<iostream>
    #include<cstring>
    #define INF 0x3e3e3e3e
    #include<queue>
    #define MAXN 100010
    using namespace std;
    struct Edge{
        int to;
        int nxt;
        int cup;
        int flow;
    }edge[MAXN << 1];
    int deep[MAXN];
    int head[MAXN];
    int cnt = 1,ans = 0;
    int n,m,s,t;
    queue<int>q; 
    int read()
    {
        int nm = 0,f = 1;
        char c = getchar();
        for(;!isdigit(c);c = getchar())if(c == '-')f = -1;
        for(;isdigit(c);c = getchar())nm = nm * 10 + c - '0';
        return nm * f;
    }
    void push(int vi,int vj,int wei)
    {
        cnt++;edge[cnt].to = vj;edge[cnt].cup = wei;edge[cnt].nxt = head[vi];head[vi] = cnt;
        cnt++;edge[cnt].to = vi;edge[cnt].nxt = head[vj];head[vj] = cnt;
    }
    bool bfs(int be,int ed)
    {
        while(!q.empty()) q.pop();
        memset(deep,0,sizeof(deep));
        deep[be] = 1;
        q.push(be);
        while(!q.empty())
        {
            int op = q.front();
            q.pop();
            for(int i = head[op]; i; i = edge[i].nxt)
            {
                int vj = edge[i].to;
                if(deep[vj] || edge[i].cup <= edge[i].flow)continue;
                deep[vj] = deep[op] + 1;
                q.push(vj);
                if(vj == ed)
                    return true;
            }
        }
        return false;
    }
    int dfs(int now,int ed,int flow)
    {
        if(flow == 0 || now == ed)return flow;
        int tot = 0,f;
        for(int i = head[now];i;i = edge[i].nxt)
        {
            int vj = edge[i].to;
            if(deep[vj] != deep[now] + 1)continue;
            int op = min(edge[i].cup - edge[i].flow,flow);
            if(f = dfs(vj,ed,op))
            {
                edge[i].flow += f;
                edge[i ^ 1].flow -= f;
                tot += f;
                flow -= f;
            }
            if(flow == 0)break;
        }
        if(tot == 0)deep[now] = 0;
        return tot;
    }
    void Dinic(int be,int ed)
    {
        while(bfs(be,ed))
            ans -= dfs(be,ed,INF);
    }
    int main()
    {
        n = read();m = read();s = n + m + 1;t = s + 1;
        for(int i = 1;i <= n;i++)
        {
            for(int j = 1;j <= m;j++)
            {
                push(i,j + n,1);
            }
        }
        for(int i = 1;i <= n;i++)
        {
            int op = read();
            push(s,i,op);
            ans += op;
        }
        for(int j = 1;j <= m;j++)
        {
            int op = read();
            push(j + n,t,op);
        }
        Dinic(s,t);
        if(ans == 0){
            printf("1\n");
            for(int i = 1;i <= n;i++)
            {
                for(int j = head[i];j;j = edge[j].nxt)
                {
                    int vj = edge[j].to;
                    if(vj != s && edge[j].flow)
                    {
                        printf("%d ",edge[j].to - n);
                    }
                }
                printf("\n");
            }
        }
        else{
            printf("0\n");
        }
        return 0;
}
```

---

## 作者：Dispwnl (赞：15)

我感觉这是我做的最轻松的网络流了。。。

很容易看出单位与桌的关系

把人看成流量

所以把源点与每个单位连边

容量为单位的人数

每张桌与汇点连边

容量为每张桌的容量

因为每个单位每有两个人坐一张桌

所以每个单位向每个桌连边

容量为1

跑最大流

看最大流答案是否=总人数

等输出1不等输出0

至于方案

遍历每个单位

看与它相连的点是否是张桌子并流满了

是就标记

最后遍历每个单位每个人循环输出就好了

不用拆点、不用弧优化、不用二分答案、不用xjb建图

这简直就是网络流中的一股清流啊

```cpp
# include<iostream>
# include<cstdio>
# include<cstring>
# include<queue>
using namespace std;
const int INF=1e8,maX=151,mAX=301,MAX=5000001,Max=10001,t=10000;
struct p{
    int x,y,dis;
}c[MAX];
int m,n,num,TOT,KING;
int h[Max],d[Max],r[maX];
bool use[mAX];
bool rou[maX][mAX];
void add(int x,int y,int dis)
{
    c[num].x=h[y];c[num].y=x;c[num].dis=0;h[y]=num++;
    c[num].x=h[x];c[num].y=y;c[num].dis=dis;h[x]=num++;
}
bool bfs()
{
    queue<int> qu;
    qu.push(0);
    memset(d,0,sizeof(d));
    d[0]=1;
    while(!qu.empty())
    {
        int tt=qu.front();
        qu.pop();
        for(int i=h[tt];i;i=c[i].x)
          if(c[i].dis&&!d[c[i].y])
          {
              d[c[i].y]=d[tt]+1;
              qu.push(c[i].y);
          }
    }
    return d[t];
}
int dfs(int x,int dix)
{
    if(x==t||!dix) return dix;
    int sum=0;
    for(int i=h[x];i;i=c[i].x)
      if(d[c[i].y]==d[x]+1&&c[i].dis)
      {
          int dis=dfs(c[i].y,min(c[i].dis,dix));
          if(dis)
          {
              sum+=dis;
              dix-=dis;
              c[i].dis-=dis;
              c[i^1].dis+=dis;
              if(!dix) break;
        }
      }
    if(!sum) d[x]=-1;
    return sum;
}
int dinic()
{
    int tot=0;
    while(bfs())
    tot+=dfs(0,INF);
    return tot;
}
int main()
{
    scanf("%d%d",&m,&n);
    for(int i=1;i<=m;i++)
      {
          scanf("%d",&r[i]);
          add(0,i,r[i]);
          for(int j=1;j<=n;j++)
            add(i,j+m,1);
          TOT+=r[i];
      }
    //add(0,s,TOT);
    //KING=num-1;
    for(int i=1;i<=n;i++)
      {
          int x;
          scanf("%d",&x);
          add(i+m,t,x);
      }
    if(dinic()==TOT) printf("1\n");
    else
    {
        printf("0");
        return 0;
    }
    for(int j=1;j<=m;j++)
      for(int i=h[j];i;i=c[i].x)
        if(c[i].y>=1+m&&c[i].y<=n+m&&!c[i].dis)
        rou[j][c[i].y-m]=1;
    for(int i=1;i<=m;i++)
      {
          memset(use,0,sizeof(use));
          for(int j=1;j<=r[i];j++)
            for(int k=1;k<=n;k++)
              if(!use[k]&&rou[i][k])
              {
                  use[k]=1;
                  printf("%d ",k);
                  break;
            }
        printf("\n");
      }
    return 0;
}
```

---

## 作者：望眼浮云 (赞：11)

~~网络流大水题~~

三步走：

1.建一个超级源点，向每个单位连一条为单位人数的边

2.每个单位向每个桌子连一条为1的边(同一个单位的人不能在同一个桌子上)

3.建一个超级汇点，每个桌子向汇点连一条为桌子容量的边

跑一遍最大流，如果最大流量等于所有单位人数之和，则存在解，否则无解。

那么怎么输出路径呢？

从每个单位出发的所有满流边指向的桌子就是该单位人员的安排情况

丑陋的代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
const int inf=1e9;
int n,m,x,y,z,s,t,ans,d[10005],sum;
struct node{
	int next,to,w;
}a[500000];
int cnt=1,head[10005],cur[10005];
int r[10000],c[10000],vis[10000];
queue <int> q;
void add(int x,int y,int dis)
{
	a[++cnt].next=head[x];
	a[cnt].to=y;
	a[cnt].w=dis;
	head[x]=cnt;
}
bool bfs(int s,int t) 
{
	memset(d,0x7f,sizeof(d));
	while(!q.empty()) q.pop();
	for(int i=0;i<=t;i++) cur[i]=head[i];
	d[s]=0;
	q.push(s);
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int i=head[u];i;i=a[i].next)
		{
			int v=a[i].to;
			if(d[v]>inf&&a[i].w) 
			{
				d[v]=d[u]+1;
				q.push(v);
			}
		}
	}
	if(d[t]<inf) return true;
	else return false;
}
int dfs(int now,int t,int limit)
{
	if(!limit||now==t) return limit;
	int flow=0,f;
	for(int i=cur[now];i;i=a[i].next)
	{
		cur[now]=i;
		int v=a[i].to;
		if(d[v]==d[now]+1&&(f=dfs(v,t,min(limit,a[i].w))))
		{
			flow+=f;
			limit-=f;
			a[i].w-=f;
			a[i^1].w+=f;
			if(!limit) break;
		}
	}
	return flow;
}
int main()
{
	scanf("%d%d",&m,&n);
	s=0;t=n+m+1;
	for(int i=1;i<=m;i++)
	{
	    scanf("%d",&r[i]);
	    sum+=r[i];
	    add(0,i,r[i]); //建一个超级源点，向每个单位连一条为单位人数的边
	    add(i,0,0);
	}
	for(int i=1;i<=n;i++)
	{
	    scanf("%d",&c[i]);
	    add(i+m,t,c[i]); //建一个超级汇点，每个桌子向汇点连一条为桌子容量的边
	    add(t,i+m,0);
	}
	for(int i=1;i<=m;i++)
	    for(int j=1;j<=n;j++)
	        add(i,j+m,1),add(j+m,i,0); //每个单位向每个桌子连一条为1的边
	while(bfs(s,t)) ans+=dfs(s,t,inf); //最大流模板不必多说了
	if(ans==sum) //答案等于总人数才有解
	{
	    printf("1\n");
	    for(int l=1;l<=m;++l) //寻找方案
        {
            for(int i=head[l];i;i=a[i].next)
            if(a[i].to>m&&a[i].to<=m+n&&!a[i].w)
                printf("%d ",a[i].to-m);
            printf("\n");
        }
	}
	else printf("0\n"); 
	return 0;
}
```

---

## 作者：philosopherchang (赞：7)

我也来发贪心。

把桌子大小和队伍大小从大到小排个序，然后一个一个的坐座位，最后在按照队伍编号再排回来。证明的话有人说不会，其实很简单，队伍越大越不容易满足，所以我们先让它满足，一个桌子一次只安一个人，满人的话就跳过那张桌子往后排，如果说在排座次的过程中，一直有一个人（也可能是多个）没地坐，也就是说一直到最后一张桌子还是满人，那么就可以巧妙地输出0了。

然后就是，蒟蒻不会vector，所以这是一个不用vector的题解，比[沛霖](https://www.luogu.org/space/show?uid=48455)dalao的代码量大，但我感觉应该更容易懂。

然后上代码
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,ll;
struct node{
	int num,wei,xy[1001],hao;//xy是每个人做的桌子编号
}a[1501];//我发现按着题目开数组最后一个点RE了，所以就大了点。
struct edge{//这个真的不是建边，是想不出结构体名称了。
	int num1,shu,wi;
}b[3001];
bool c[3001];//判断桌子是否坐满
int cmp(node x,node y)
{
	return x.num>y.num;
}
int cmp2(edge x,edge y)
{
	return x.num1>y.num1;
}
int cmp1(node x,node y)
{
	return x.wei<y.wei;
}
void dfs()
{
	for(int i=1;i<=m;i++)
	{
		int cnt=0;
		for(int j=1;j<=n;j++)
		{
			if(j==n&&c[j]==1)//如果扫到最后一张桌子发现桌子还是满的，就输出0，在void里没法直接输出，只能限定义一个ll变量。
			{
				ll=1;
				return ;
			}
			if(c[j]==0)
			{
				a[i].num--;//此队伍中还剩下的人数
				cnt++;
				a[i].xy[cnt]=b[j].wi;
				b[j].shu++;
				if(b[j].shu==b[j].num1)
				{
					c[j]=1;
				}
			}
			if(a[i].num==0)
			{
				a[i].hao=cnt;//记录下a[i].xy的长度，因为原来定义的num已经被我们减去了。
				break;
			}
		}
	}
	return ;
}
void print()
{
	sort(a+1,a+m+1,cmp1);
	cout<<1<<endl;
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=a[i].hao;j++)
		{
			cout<<a[i].xy[j]<<" ";
		}
		cout<<endl;
	}
}
int main()
{
	cin>>m>>n;
	for(int i=1;i<=m;i++)
	{
		cin>>a[i].num;
		a[i].wei=i;//wei是队伍编号
	}
	for(int i=1;i<=n;i++)
	{
		cin>>b[i].num1;
		b[i].wi=i;wi是桌子编号
	}
	sort(a+1,a+n+1,cmp);
	sort(b+1,b+n+1,cmp2);
	dfs();//实在想不出函数名了才起的dfs。
	if(ll==1)
	{
		cout<<0;
		return 0;
	}
	print();
	return 0;
}
```

---

## 作者：lolte (赞：6)

### 这是GD初二蒟蒻 $lolte$ 的题解

最近在学习二分图（匈牙利）以及网络流的算法，自然是要写24题的了。

本题不难想到将单位和桌子作为两边的点，进行二分图匹配 $||$ 网络流

### 具体建图方法如下：
1. 将源点与每个单位连一条流量为 此单位代表数 的边
2. 将每张桌子与汇点连一条流量为1的边
3. 将每个单位与每张桌子连一条流量为1的边

等于将每个单位的代表都换成了流量，

这样跑一遍网络流，就可以将每个单位安排完。

若可以安排，则根据每个单位是否对第 $i$ 张桌子有流量进行输出。

### 下面是代码
dinic 无o2 31ms
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int x=0,f=0;
    char ch=getchar();
    for (;ch<'0'||ch>'9';ch=getchar()) f^=(ch=='-');
    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';
    return f ? -x : x;
}
const int inf=2147483600,maxn=500,maxm=82000;
int n,m,head[maxn],cnt=1,dep[maxn],cur[maxn],s,t,dw[maxn],zz[maxn],all=0;
int q[maxn],l,r;
bool inq[maxn],vis;
struct node{
    int to,nxt,w;
}e[maxm];
inline void add(int u,int v,int w) {
    ++cnt;
    e[cnt].to=v;
    e[cnt].w=w;
    e[cnt].nxt=head[u];
    head[u]=cnt;
}
bool bfs() {
    memset(dep,0x3f,sizeof(dep));
    memset(inq,0,sizeof(inq));
    memcpy(cur,head,sizeof(head));
    l=1;r=0;
    inq[s]=1;q[++r]=s;dep[s]=0;
    while (l<=r) {
        int u=q[l++];
        inq[u]=0;
        for (int i=head[u];i;i=e[i].nxt) {
            int v=e[i].to;
            if (e[i].w&&dep[v]>dep[u]+1) {
                dep[v]=dep[u]+1;
                if (!inq[v]) {
                    inq[v]=1;
                    q[++r]=v;
                }
            }
        }
    }
    return dep[t]<10000;
}
int dfs(int u,int flow) {
    if (u==t) {
        all-=flow;
        vis=1;
        return flow;
    }
    int goflow=0,used=0;
    for (int &i=cur[u];i;i=e[i].nxt) {
        int v=e[i].to;
        if (e[i].w&&dep[v]==dep[u]+1) {
            goflow=dfs(v,min(flow,e[i].w));
            if (!goflow) continue;
            used+=goflow;
            e[i].w-=goflow;
            e[i^1].w+=goflow;
            if (used==flow) break;
        }
    }
    return used;
}
void dinic(){
    while (bfs()) {
        vis=1;
        while (vis) {
            vis=0;
            dfs(s,inf);
        }
    }
}
void go(int u) {
    for (int i=head[u];i;i=e[i].nxt) {
        int v=e[i].to;
        if (v!=s&& !e[i].w) printf("%d ",v-n); 
    }
    putchar('\n');
}
signed main(){
    n=read();
    m=read();
    s=n+m+1;
    t=n+m+2;
    for (int i=1;i<=n;++i) dw[i]=read();
    for (int i=1;i<=m;++i) zz[i]=read();
    for (int i=1;i<=n;++i) {
        all+=dw[i];
        add(s,i,dw[i]);
        add(i,s,0);
    }
    for (int i=1;i<=m;++i) {
        add(i+n,t,zz[i]);
        add(t,i+n,0);
    }
    for (int i=1;i<=n;++i) {
        for (int j=1;j<=m;++j) {
            add(i,j+n,1);
            add(j+n,i,0);
        }
    }
    dinic();
    if (all) {
        puts("0");
        return 0;
    }
    puts("1");
    for (int i=1;i<=n;++i) go(i);
    return 0;
}
```

$Wish$ $OIers RP++$

---

## 作者：Ireliaღ (赞：5)

## 二分图匹配，我用的指针版ISAP

~~二分图匹配ISAP效率极高，尤其是加了当前弧优化~~

### 建图

* 从超级源点向每一个单位连接容量为人数的边
* 从每一个圆桌向超级汇点连接容量为人数的边
* 从每一个单位向每一个圆桌连接容量为$1$的边

### 输出

* 如果总流量小于总人数，则无解
* 遍历每一个单位，对于起点为单位终点为圆桌剩余容量为$0$的边，输出终点即圆桌编号

### 代码

有$cur$优化的$ISAP$

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>

using std::queue;

const int MAXM = 155;
const int MAXN = 275;
const int INF = 0x3f3f3f3f;

struct Edge{
    int to, val;
    Edge *next, *ops;
    Edge (int to, int val, Edge *next): to(to), val(val), next(next) {ops = NULL;}
};

Edge *head[MAXN + MAXM];

void AddEdge(int from, int to, int val) {
    head[from] = new Edge(to, val, head[from]);
    head[to] = new Edge(from, 0, head[to]);
    head[from]->ops = head[to]; head[to]->ops = head[from];
}

int n, m, tot = 0;

namespace ISAP{
    int s, t, maxflow;
    int gap[MAXN + MAXM], dep[MAXN + MAXM];
    Edge *cur[MAXM + MAXN];

    void Bfs() {
        memset(dep, -1, sizeof(dep));
        memset(gap, 0, sizeof(gap));
        dep[t] = 0; gap[dep[t]]++;
        queue<int> q; q.push(t);
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (Edge *e = head[u]; e; e = e->next) {
                int v = e->to;
                if (dep[v] != -1) continue;
                dep[v] = dep[u] + 1; 
                gap[dep[v]]++;
                q.push(v);
            }
        }
    }

    int Dfs(int u, int flow) {
        if (u == t) {
            maxflow += flow;
            return flow;
        }
        int used = 0;
        for (Edge *&e = cur[u]; e; e = e->next) {
            int v = e->to;
            if (e->val && dep[v] == dep[u] - 1) {
                int mi = Dfs(v, std::min(e->val, flow - used));
                if (mi) {
                    used += mi;
                    e->val -= mi;
                    e->ops->val += mi;
                    if (used == flow) return used;
                }
            }
        }
        gap[dep[u]]--;
        cur[u] = head[u];
        if (gap[dep[u]] == 0) dep[s] = n + m + 2;
        dep[u]++;
        gap[dep[u]]++;
        return used;
    }

    void Work() {
        for (int i = 0; i <= n + m + 1; i++) cur[i] = head[i];
        maxflow = 0;
        Bfs();
        while (dep[s] < n + m + 1) Dfs(s, INF);
    }

    void Print() {
        if (maxflow != tot) {
            puts("0"); return;
        }
        puts("1");
        for (int i = 1; i <= m; i++) {
            for (Edge *e = head[i]; e; e = e->next) {
            int v = e->to;
                if (e->val == 0 && v > m && v <= n + m) printf("%d ", v - m);
            }
            puts("");
        }
        // printf("%d %d\n", maxflow, tot);
    }
}

int main() {
    memset(head, 0, sizeof(head));
    scanf("%d %d", &m, &n);
    ISAP::s = 0; ISAP::t = m + n + 1;
    for (int i = 1; i <= m; i++) {
        for (int j = m + 1; j <= n + m; j++) {
            AddEdge(i, j, 1);
        }
    }
    for (int i = 1, x; i <= m; i++) {
        scanf("%d", &x);
        AddEdge(0, i, x);
        tot += x;
    }
    for (int i = m + 1, x; i <= n + m; i++) {
        scanf("%d", &x);
        AddEdge(i, m + n + 1, x);
    }
    ISAP::Work();
    ISAP::Print();
    return 0;
}
/*
4 5
4 5 3 5
3 5 2 6 4
*/
```

---

## 作者：Lonely_NewYear (赞：3)

# 洛谷 P3254 题解

## 题目分析

这题需要用到[网络最大流](https://www.luogu.com.cn/problem/P3376)，不会的最好先去学习一下。

我们先回忆一下二分图匹配问题。二分图匹配问题可以建立一个超级源点连向所有左边的点，所有右边的点连向一个超级汇点，同时左边的点根据题目要求与右边的点连边，所有边的容量为 $1$。

再看本题。可以把题目中的单位看成二分图左边的点，圆桌看成二分图右边的点。

每个单位和每个圆桌连边（因为任何一个单位都可以派人去任何一个圆桌），容量为 $1$（因为每个单位只能派一个人到某个圆桌）。

再建立一个超级源点和每个单位连边，容量应为 $r_i$，因为这个单位只有这么多人。同理每个圆桌向超级汇点连边，容量应为 $c_i$，因为这个圆桌只能坐这么多人。

建完图后直接跑一遍最大流，记为 $ans$。

我们发现只有 $ans=\sum_{i=1}^{m}r_i$ 时才可能有方案（因为所有人都要去吃饭聊天，所以所有人都要“流”过去）。

这时我们可以先枚举每个单位，然后对当前单位枚举它的每个边（注意这里要判断一下一定是连向圆桌的边而不是连向源点的），如果这条边的参余容量为 $0$，也就代表这个单位中有一个人“流”去了这条边的终点代表的圆桌，那么就输出终点。

## 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
struct edge
{
	int to,val,next;
}g[100000];//网络流问题多建的边和点会很多，数组最好开大一点
int head[501],cnt=1,s,t;
int deep[501];//同上
void add(int u,int v,int w)//邻接表存图
{
	g[++cnt]=(edge){v,w,head[u]};
	head[u]=cnt;
}
bool bfs()
{
	queue<int> q;
	q.push(s);
	for(int i=0;i<=500;i++)
	{
		deep[i]=0;
	}
	deep[s]=1;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=g[i].next)
		{
			int v=g[i].to;
			if(g[i].val&&!deep[v])
			{
				deep[v]=deep[u]+1;
				q.push(v);
			}
		}
	}
	return deep[t];
}
int dfs(int u,int in)
{
	if(u==t)
	{
		return in;
	}
	int out=0;
	for(int i=head[u];i&&in;i=g[i].next)
	{
		int v=g[i].to;
		if(g[i].val&&deep[u]+1==deep[v])
		{
			int num=dfs(v,min(in,g[i].val));
			in-=num;
			out+=num;
			g[i].val-=num;
			g[i^1].val+=num;
		}
	}
	if(out==0)
	{
		deep[u]=-1;
	}
	return out;
}
int main()
{
	int n,m,sum=0;
	scanf("%d%d",&m,&n);
	s=0,t=m+n+1;
	for(int i=1;i<=m;i++)//源点连向单位
	{
		int w;
		scanf("%d",&w);
		add(s,i,w);
		add(i,s,0);
		sum+=w;//求人数总和
	}
	for(int i=1;i<=n;i++)//餐桌连向汇点
	{
		int w;
		scanf("%d",&w);
		add(i+m,t,w);//注意点的编号
		add(t,i+m,0);
	}
	for(int i=1;i<=m;i++)//源点连向餐桌
	{
		for(int j=1;j<=n;j++)
		{
			add(i,j+m,1);//注意点的编号
			add(j+m,i,0);
		}
	}
	int ans=0;
	while(bfs())//dinic求最大流
	{
		ans+=dfs(s,1e9);
	}
	if(ans!=sum)//无可行方案
	{
		printf("0");
		return 0;
	}
	printf("1\n");
	for(int i=1;i<=m;i++)
	{
		for(int j=head[i];j;j=g[j].next)
		{
			if(g[j].to!=s&&!g[j].val)//有人从这条边流了过去
			{
				printf("%d ",g[j].to-m);//注意点的编号
			}
		}
		printf("\n");
	}
	return 0;
}
```

谢谢观看！

---

## 作者：撤云 (赞：2)

[博客地址](https://www.cnblogs.com/hbxblog/p/9708323.html)
 
首先看题，题目要求满足条件的解，首先来考虑是否满足条件，我们不妨假设每个团队到每个桌子的流为1(自己在草稿纸上画一下)，在用两个强大的超级点，汇点和源点（这个名词知道吧，不知道可以回去学网络流，~~这都不知道，做什么这题~~）将源点和所有的团队相连，流为团队代表数，将桌子和汇点相连，流为桌子的最大上限  

那么为什么要这么连呢？因为题目说了每个团队至多一个人在一张餐桌上吃饭，所以设每个团队到每个桌子的流为1，这样保证了每个团队不会有两个或两个以上在同一张桌子吃饭，而因为每个团队的人不是无限的，有一个上限，所以讲他和源点相连，流为团队人数，这样就不会超出范围了，桌子同理  

再来看看如何输出方案
其实这很简单
然后枚举每一个团队，如果团队和桌子的边残余容量是0，就证明这里有一个方案


知道了这些以后接下来就是模板题了  

```cpp
#include<bits/stdc++.h>
#define rg register
using namespace std;
typedef long long ll;
inline int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9')  f= (c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9')  x=x*10+c-48,c=getchar();
    return f*x;
}
struct node{
    int to,next,v;
}a[100001];
int cnt,head[1000],dep[1001],s=1,t,cur[1001];
void add(int x,int y,int c){
    a[++cnt].to=y;
    a[cnt].next=head[x];
    a[cnt].v=c;
    head[x]=cnt;
}
queue<int> q;
int bfs(){
    memset(dep,0,sizeof(dep));
    q.push(s);
    dep[s]=1;
    while(!q.empty()){
        int now=q.front();
        q.pop();
        for(int i=head[now];i;i=a[i].next){
            int v=a[i].to;
            if(a[i].v&&!dep[v])
                dep[v]=dep[now]+1,q.push(v);
        }
    }
    if(!dep[t])
        return 0;
    return 1;
}
int dfs(int k,int list){
    if(k==t)
        return list;
    for(int & i=cur[k];i;i=a[i].next){
        int v=a[i].to;
        if(dep[v]==dep[k]+1&&a[i].v){
            int ans=dfs(v,min(list,a[i].v));
            if(!ans)
                continue;
            a[i].v-=ans;
            if(i%2)
                a[i+1].v+=ans;
            else
                a[i-1].v+=ans;
            return ans;
        }
    }
    return 0;
}
int sum;
int Dinic(){
    int ans=0,k;
    while(bfs()){
        for(int i=1;i<=t;i++)
            cur[i]=head[i];
        while((k=dfs(s,2147483647)))
            ans+=k;
    }
    return ans==sum?1:0;
}
int main(){
    int m=read(),n=read(),x,y;
    t=m+n+2;
    for(int i=1;i<=m;i++)
        x=read(),add(s,i+1,x),add(i+1,s,0),sum+=x;
    for(int i=1;i<=n;i++){
        x=read();
        for(int j=1;j<=m;j++)
            add(j+1,i+m+1,1),add(i+m+1,j+1,0);
        add(i+m+1,t,x),add(t,i+m+1,0);
    }
    int ans=Dinic();
    if(ans==0)
        printf("0"),exit(0);
    printf("1\n");
    for(int i=2;i<=m+1;i++,printf("\n"))
        for(int j=head[i];j;j=a[j].next){
            int v=a[j].to;
             if(!a[j].v&&v!=s)
                printf("%d ",v-m-1);
        }
    return 0;
}
```

---

## 作者：EternalEpic (赞：2)

今天WC讲了这道题，我就来详细说一下，也算是复习吧。

首先，题目中已经把点集帮你分成了两部分，代表集和餐桌集，说句人话就是给你了一个二分图匹配问题。

你只需要：

1. 求解最大匹配，看看是否有可行的就餐方案。

2. 将方案输出。

对于第一个问题，我们可以选择建立虚点 $S$ 和 $T$ 表示源点和汇点。对于每一个代表团，从源点向它建一条容量为人数的边；对于每一个餐桌，由它向汇点建一条容量为最多座数的边。然后从每一个代表团出发，向每一个不同的餐桌建一条容量为1的边，表示最多可以坐此代表团的一个人。然后对这张图跑最大流算法，通过最大流量与总人数比较来得知能否有合法方案。

对于第二个问题，我们可以看从代表团向餐桌建的边中，有哪些剩余容量为0，即表示已经用过了，输出就行。

最后千万不要搞错网络流建边的下标问题。

```cpp
const int INF = 1 << 29;
const int Maxn = 275, Maxm = 155;
int n, m, cnt = 1, r[Maxm], c[Maxn];

const int N = 425, M = 3e5 + 5;
int head[N], cur[N], ver[M], nxt[M], edge[M];
inline void AddEdge(int u, int v, int w) {
	ver[++cnt] = v, edge[cnt] = w, nxt[cnt] = head[u], head[u] = cnt;
	ver[++cnt] = u, edge[cnt] = 0, nxt[cnt] = head[v], head[v] = cnt;
}

int dis[N], maxflow, s, t, tot;
inline bool bfs(void) {
	Ms(dis, 0); dis[s] = 1;
	queue <int> q; q.push(s);
	while (!q.empty()) {
		int u = q.front(); q.pop();
		for (int i = head[u]; i; i = nxt[i]) {
			if (edge[i] && !dis[ver[i]]) {
				q.push(ver[i]);
				dis[ver[i]] = dis[u] + 1;
				if (ver[i] == t) return true;
			}
		}
	} return false;
}

inline int dinic(int u, int flow) {
	if (u == t) return flow;
	int rest = flow, k;
	for (int &i = cur[u]; i; i = nxt[i]) {
		if (edge[i] && dis[ver[i]] == dis[u] + 1) {
			k = dinic(ver[i], min(rest, edge[i]));
			if (!k) dis[ver[i]] = 0;
			edge[i] -= k; edge[i ^ 1] += k;
			rest -= k; if (rest == 0) break;
		}
	} return flow - rest;
}

signed main(void) {
	read(m), read(n); s = n + m + 1, t = n + m + 2;
	for (int i = 1; i <= m; i++) read(r[i]), AddEdge(s, i, r[i]), tot += r[i];
	for (int i = 1; i <= n; i++) read(c[i]), AddEdge(i + m, t, c[i]);
	for (int i = 1; i <= m; i++)
		for (int j = 1; j <= n; j++) AddEdge(i, m + j, 1);
	while (bfs()) {
		for (int i = 1; i <= n + m + 2; i++) cur[i] = head[i];
		maxflow += dinic(s, INF);
	}
	
	if (maxflow != tot) { puts("0"); return 0; }
	puts("1");
	for (int u = 1; u <= m; u++) {
		int p = 0;
		for (int i = head[u]; i; i = nxt[i]) {
			if (ver[i] == s || edge[i]) continue;
			p++; writeln(ver[i] - m, " \n"[p == r[u]]);
		}
	}
//	fwrite(pf, 1, o1 - pf, stdout);
	return 0;
}
```


---

## 作者：loceaner (赞：1)

感觉做起来很爽，理解题意之后建图跑就行了


## 思路

> 问题模型：二分图多重匹配
>
> 转化模型：网络最大流

大概是做过最简单的网络流题了……

其实就是一个二分图多重匹配的问题，一个单位可以匹配多个桌子，问题就是求能不能使这些单位的人都能入座且一个桌子上最多只有一个来自同一单位的人。

将源点 $S$ 与单位之间连流量为代表人数 $r_i$ 的边，顺便记录总人数 $tot$，将餐桌和汇点 $T$ 之间连流量为容纳人数 $c_i$ 的边，然后将每个单位与每个餐桌之间连流量为 $1$ 的边，这样就建好了图。

这张图是可以满足题目条件的，因为单位与桌子之间连了流量为 $1$ 的边，所以一个桌子上最多只有一个来自同一单位的人。

之后在这张图上跑最大流，看看在满足能不能容纳这 $tot$ 个人，如果最大流小于 $tot$，就说明没有可行方，如果最大流大于或等于 $tot$，那就说明可以，枚举每个单位，检查这个单位连着的边的流量是否为 $0$，为 $0$ 则表示走最大流的时候走了这条边，即能在这个餐桌上，输出即可，否则就不能。

具体的细节看一看代码。

## 代码

```cpp
/*
  Name: P3254 圆桌问题
  Author: Loceaner
  Date: 24/08/20 08:07
*/
#include <queue>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

const int A = 2e5 + 11;
const int B = 1e6 + 11;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;

inline int read() {
  char c = getchar();
  int x = 0, f = 1;
  for ( ; !isdigit(c); c = getchar()) if (c == '-') f = -1;
  for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
  return x * f;
}

int n, m, s, t, cnt = 1;
struct node { int to, nxt, val; } e[A];
int head[A], dep[A], inq[A], cur[A], r[A], c[A];

inline void add(int from, int to, int val) {
  e[++cnt].to = to;
  e[cnt].val = val;
  e[cnt].nxt = head[from];
  head[from] = cnt;
}

inline bool bfs() {
  queue <int> Q;
  for (int i = 1; i <= n + m + 2; i++) 
    cur[i] = head[i], inq[i] = 0, dep[i] = inf;
  dep[s] = 0, Q.push(s), inq[s] = 1;
  while (!Q.empty()) {
    int x = Q.front(); Q.pop(), inq[x] = 0;
    for (int i = head[x]; i; i = e[i].nxt) {
      int to = e[i].to;
      if (dep[to] > dep[x] + 1 && e[i].val) {
        dep[to] = dep[x] + 1;
        if (!inq[to]) Q.push(to), inq[to] = 1;
      }
    }
  }
  return dep[t] != inf;
}

int dfs(int x, int flow) {
  if (x == t) return flow;
  int tmp = 0;
  for (int i = cur[x]; i; i = e[i].nxt) {
    cur[x] = i;
    int to = e[i].to;
    if (dep[to] == dep[x] + 1 && e[i].val) {
      if (tmp = dfs(to, min(flow, e[i].val))) {
        e[i].val -= tmp, e[i ^ 1].val += tmp;
        return tmp;
      }
    }
  }
  return 0;
}

int main() {
  m = read(), n = read();
  int jump = n + m, tot = 0;
  s = jump + 1, t = jump + 2;
  for (int i = 1; i <= m; i++) 
    r[i] = read(), tot += r[i], 
    add(s, i, r[i]), add(i, s, 0);
  for (int i = 1; i <= n; i++) 
    c[i] = read(), add(i + m, t, c[i]), add(t, i + m, 0);
  for (int i = 1; i <= m; i++)
    for (int j = m + 1; j <= m + n; j++)
      add(i, j, 1), add(j, i, 0);
  int ans = 0, now = 0;
  while (bfs()) while (now = dfs(s, inf)) ans += now;
  if (ans < tot) return puts("0"), 0;
  puts("1");
  for (int i = 1; i <= m; i++) {
    for (int j = head[i]; j; j = e[j].nxt) 
      if (e[j].val == 0) cout << e[j].to - m << ' '; 
      //餐桌从m+1开始编号，所以要减m
    puts("");
  }
  return 0;
}
```

---

## 作者：BFqwq (赞：1)

## P3254 【圆桌问题】
相当经典的一个网络流题qaq

首先，由于每张桌子只能容纳每个单位的一个人，所以每张桌子向每个单位连一条流量为 $1$ 的边。

然后，第 $i$ 张桌子可以坐 $c_i$ 个人，所以从源点向这张桌子连一条流量为 $c_i$ 的边。

最后，第 $i$ 个单位有 $r_i$ 个人，所以从每个单位的点向汇点连一条流量为 $r_i$ 的边。

如果桌子 $i$ 到单位 $j$ 的边流量被使用，就代表这个桌子坐了该单位的人。

于是先跑一遍最大流，看看能不能让所有的人都上座（流量就代表上座人数）。

如果可以的话，再去寻找所有从桌子连向单位的边，如果这个边的剩余流量为 $0$，就代表这个桌子上坐了该单位的人。

```cpp
#include <bits/stdc++.h>
using namespace std; 
inline int read(){
	register int x=0;
	register bool f=0;
	register char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-48;
		c=getchar();
	}
	return f?-x:x;
}
void write(int x){
    if(x<0) putchar('-'), x=-x;
    if(x>=10) write(x/10);
    putchar('0'+x%10);
}
const int inf=1000007;
const int maxn=500;
struct Edge{
    int nxt,to,val;
}e[maxn*500];
int num=1,h[maxn*20],s,t,sum;
queue <int> q;
void add(int from,int to,int dis){
    e[++num].nxt=h[from];
    e[num].to=to;
    e[num].val=dis;
    h[from]=num;
}
int n,m,x,y,z,maxflow,dep[maxn*20];
bool bfs(int s,int t){
	memset(dep,0x3f,sizeof(dep));
	while(!q.empty()) q.pop();
    dep[s]=0;
    q.push(s);
    while(!q.empty()){
        int u=q.front();q.pop();
        for (int i=h[u];i;i=e[i].nxt){
        	int v=e[i].to;
            if(dep[v]>inf&&e[i].val){
                dep[v]=dep[u]+1;
                q.push(e[i].to);
            }
        }
    }
    if (dep[t]<inf) return true;
    return 0;
}
int dfs(int u,int t,int lim){
    if (!lim||u==t)return lim;
    int flow=0,f;
    for (int i=h[u];i;i=e[i].nxt){
        int v=e[i].to;
        int &w=e[i].val;
        if(dep[v]==dep[u]+1&&(f=dfs(v,t,min(lim,w)))){
            flow+=f;
            lim-=f;
            w-=f;
            e[i^1].val+=f;
            if(!lim) break;
        }
    }
    return flow;
}
void dinic(int s,int t){
    while(bfs(s,t)){
    	//cout<<maxflow;
		maxflow+=dfs(s,t,inf);
	}
}
int main(){
    m=read();n=read();
    for(int i=1;i<=n;i++){
    	for(int j=1;j<=m;j++)
    		add(i,j+1000,1),add(j+1000,i,0);
	} 
	s=2000,t=2001;
    for(int i=1;i<=m;i++){
		int a=read();
    	add(i+1000,t,a);
    	add(t,i+1000,0);
    	sum+=a;
	}
	for(int i=1;i<=n;i++){
		add(s,i,read());
		add(i,s,0);
	}
	dinic(s,t);
	if(sum!=maxflow) return write(0),0;
	puts("1");
	for(int i=1001;i<=m+1000;i++){
		for(int j=h[i];j;j=e[j].nxt){
			int v=e[j].to;
			int w=e[j].val;
			if(w==1&&v!=t) write(v),putchar(' ');
		}
		puts("");
	}
    return 0;
}
```


---

## 作者：VanillaYuzume (赞：1)

# 网络流24题---圆桌问题

题意:[自己康](https://www.luogu.org/problem/P3254)

## 解法:求网络最大流
对于这一题,我们可以把 公司连到超级源 其中管道的流量为公司的人数  
把桌子连到超级汇 其中管道的流量为桌子的容量  
然后再把人和每一张桌子都连在一起  
这样我们可以得到每个公司只会与一张桌子相连 即满足题意中要求的     
使每张桌子尽可能的坐满 且 满足一张桌为不同的公司
下面是样例中的图

![草图](https://cdn.luogu.com.cn/upload/image_hosting/pfmepqzk.png)

**代码酱 OVO↓**
```cpp
//圆桌问题 二分图多重匹配
#include <bits/stdc++.h>
using namespace std;

#define N 3000001
#define v to[i]
#define inf 0x7f7f7f7f

int n,m,s,t;
int sump,sumt;//人的总数 和 桌子的总容量
int dep[N],vis[N],company[N],table[N];
int head[N],to[N],from[N],nex[N],w[N],ecnt;

void ae(int x,int y,int z){
    from[ecnt]=x;
    to[ecnt]=y;
    w[ecnt]=z;
    nex[ecnt]=head[x];
    head[x]=ecnt++;
}

bool bfs(){
    memset(dep,-1,sizeof(dep));
    queue<int> q;
    dep[s]=1;
    q.push(s);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        for(int i=head[u];i!=-1;i=nex[i]){
            if(dep[v]==-1 and w[i]>0){
                dep[v]=dep[u]+1;
                q.push(v);
            }
        }
    }
    return dep[t]!=-1;
}

int dfs(int u,int low){
    if(u==t)
        return low;
    int ret=low;
    for(int i=head[u];i!=-1;i=nex[i]){
        if(dep[v]==dep[u]+1 and w[i]>0){
            int flow=dfs(v,min(ret,w[i]));
            if(flow>0){
                w[i]-=flow;
                w[i^1]+=flow;
            }
            ret-=flow;
            if(!ret)
                break;
        }
    }
    return low-ret;
}

int dinic(){
    int res=0;
    while(bfs()){
        res+=dfs(s,inf);
    }
    return res;
}

void pre(){
    scanf("%d%d",&n,&m);
    int t1,t2;
    s=0,t=10000;
    for(int i=1;i<=n;i++){
        scanf("%d",&company[i]);
        ae(s,i,company[i]);
        ae(i,s,0);
        sump+=company[i];//总人数
    }
    for(int i=1;i<=m;i++){
        scanf("%d",&table[i]);
        ae(i+n,t,table[i]);
        ae(t,n+i,0);
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            ae(i,j+n,1);
            ae(j+n,i,0);
        }
    }
}

int main(){
    memset(head,-1,sizeof(head)); 
    pre();
    int ans=dinic();
    if(ans==sump){
        printf("1\n");
        for(int u=1;u<=n;u++){
            for(int i=head[u];i!=-1;i=nex[i]){
                if(!w[i] and v!=s){
                    printf("%d ",v-n);
                }
            }
            printf("\n");
        }
        return 0;
    }
    else
        printf("0\n");
    //printf("%d\n",ans);
    return 0;
}
```

---

## 作者：leozhang (赞：1)

这是网络流24题里最简单的一道，我们从这里开始

虽然是网络流24题之一，但可以不用网络流...

本题采用贪心即可

有一个很显然的思想：在分配每一组时，我们都应当优先分配给当前可容纳人数更多的桌

证明：这样做显然能最大限度的保留可以用的桌，如果这样做都不合法，那么其他策略一定不合法

那么我们用个优先队列维护即可

```
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <queue>
#include <stack>
using namespace std;
struct node
{
    int num;
    int idd;
    friend bool operator < (node x,node y)
    {
        return x.num<y.num;
    }
}p[155],q[275];
priority_queue <node> M;
vector <int> v[155];
bool cmp(node x,node y)
{
    return x.num>y.num;
}
int n,m;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&p[i].num),p[i].idd=i;
    for(int i=1;i<=m;i++)scanf("%d",&q[i].num),q[i].idd=i,M.push(q[i]);
    sort(p+1,p+n+1);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=p[i].num;j++)
        {
            if(M.empty())
            {
                printf("0\n");
                return 0;
            }
            node u=M.top();
            M.pop();
            v[p[i].idd].push_back(u.idd);
            q[u.idd].num--;
        }
        for(int j=0;j<v[p[i].idd].size();j++)
        {
            if(q[v[p[i].idd][j]].num)M.push(q[v[p[i].idd][j]]);
        }
    }
    printf("1\n");
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<v[i].size();j++)printf("%d ",v[i][j]);
        printf("\n");
    }
    return 0;
}
```


---

## 作者：MelodyJiYang (赞：1)

圆桌问题从题目标签上是网络流24题，但是想了一下，再A掉之后又看了一题解，发现和我一样写贪心的童鞋好像没有与我思路相同的，所以我就来写个第一篇题解吧。
思路大致如下：
	1、	将数据按要求输入并存储下来。
	2、	对于每一个单位的每一个而言，每次都只坐没有同事，并且空座最多的桌子（桌子容量依次减少）。
	3、	将落座的人所坐的桌号用桶排序的方法记录下来。
	4、	所有单位处理完成后，按次序输出结果。
代码奉上，自取不谢。
```cpp
#include<cstdio>
#include<cstring>
//引入必要的头文件
using namespace std;
int danwei[200];
struct zhuo//创建一个用于存储桌子信息的结构体数组
{
	int shu;
	int wei;
}t[300];
int m,n;
int vis[300];//记录每张桌子上是否有本单位的人
int res[200][300];//答案数组
inline int dfs(int num,int i)//处理每个单位代表落座的函数
{
	if(num==0) return 1;//代表全都落座则返回
	int rong=0;
	int index=0;
	for(int j=1;j<=n;j++)//循环以找到桌子剩余座位的最大值
	{
		if(t[j].shu==t[j].wei || vis[j]) continue;//如果桌子坐满或者单位有人坐过就找下一张桌子
		if(rong<(t[j].wei-t[j].shu))//如果容量比最大容量大则更新最大容量和它的位置
		{
			rong=(t[j].wei-t[j].shu);
			index=j;
		}
	}
	if(index==0) return 0;//容量为空则说明无法坐下，题目不成立
	vis[index]=1;//落座，改变桌子的容量
	t[index].shu++;
	res[i][index]++;//记录答案，表示第i号单位的第index章桌子上有人
	int r=dfs(num-1,i);//看本单位下一个人能否落座
	return r;
}
inline void sc()//输出答案函数
{
	printf("1\n");
	for(int i=1;i<=m;i++)
	{
		int j=1;
		int num=0;
		for(;j<=n;j++)
		{
			if(res[i][j]==0) continue;//如果桌子上没人，就看下一张桌子
			printf("%d",j);//有人就打印桌子号
			if(++num!=danwei[i])printf(" ");
			else printf("\n");
		}
	}
}
inline int A()//伪主函数（提高效率使用，执行时从这里执行）
{
	scanf("%d %d",&m,&n);//输入m和n
	for(int i=1;i<=m;i++)//输入每个单位的人数
	{
		scanf("%d",&danwei[i]);
	}
	for(int i=1;i<=n;i++)//输入每张桌子的位置数
	{
		scanf("%d",&t[i].wei);
	}
	for(int i=1;i<=m;i++)//循环对于每一个单位人数去找座位
	{
		int r=dfs(danwei[i],i);//调用处理落座的函数
		if(r==0)//有人无法落座则不符合题目要求
		{
			printf("%d\n",r);
			return 0;
		}
		memset(vis,0,sizeof(vis));//对于每一次运行清空桌子的访问记录
	}
	sc();//调用输出函数
	return 0;//函数结尾
}
int B=A();//调用伪主函数
int main()//真的毫无内容的主函数
{
	return 0; //函数结尾
}

```

---

## 作者：违规用户名cVn1I&r! (赞：1)

圆桌问题，虽然在网络流24题里，可是并不需要跑网络流，只要贪心即可。
本人蒟蒻不会证明，证明略。。。。
对于这个题，只需要开二个结构体，一个存桌子的容量和当前已用空间，一个存单位人的数量与去向。
利用自带的sort将单位大小与桌子容量大小由大到小排序，因为越大的单位需要越多的桌子。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    int size;
    int now;
    int pre;//结构体储存排序前的位置，方便最后输出
}ta[1000];
struct edge{
    int cap;
    int go[5000];
    int pre;//结构体储存排序前的位置，方便最后输出
}uni[300];
bool cmp1(node a,node b)
{
    return a.size>b.size;
}
bool cmp2(edge a,edge b)
{
    return a.cap>b.cap;//由大到小排大小，容量
}
bool cmp3(edge a,edge b)
{
    return a.pre<b.pre;
}
int n,m;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>uni[i].cap;
        uni[i].pre=i;//记录位置
    }
    for(int i=1;i<=m;i++)
    {
        cin>>ta[i].size;
        ta[i].pre=i;//记录位置
    }	
    int k=1;
    sort(uni+1,uni+n+1,cmp2);
    sort(ta+1,ta+1+m,cmp1);//排序
    for(int i=1;i<=n;i++)//循环单位
    {
        int l=0;//当前单位可以满足的人数
        for(int j=1;l<uni[i].cap&&j<=m;j++)
        {
            
            if(ta[j].now==ta[j].size)
            continue;//桌子满了就往后找有空的
            uni[i].go[++l]=j;ta[j].now++;//记录去向，当前桌子坐的人数++		
        }
        if(l<uni[i].cap)//如果无法满足单位，退出
        {
            cout<<0;return 0;
        }
    }
    sort(uni+1,uni+n+1,cmp3);//以原先顺序排单位，方便输出
    cout<<1<<endl;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=uni[i].cap;j++)
        //从1-n输出单位去向
        cout<<ta[uni[i].go[j]].pre<<" ";//输出桌子原先位置
        cout<<endl;
    }
}
```


---

## 作者：BJpers2 (赞：1)

 ### 基本解法楼下都说的很清楚了，我这里提供一种给出可行解的方法

基于dinic,用to[ i ][ j ]表示i号单位是否有人坐在j号桌上

然后在dfs的过程中，如果这条边是由单位指向桌子，那就令to[u][v]=1;

相对的，如果是由桌子指向单位，就说明我们“反悔”让该单位的人坐这张桌子，因此要让to[v][u]=1(注意顺序不能反，这时候u才是桌子)。

最后O(MN)地扫一遍，若to[ i ][ j ]==1就输出
```cpp
#include<iostream>
#include<cstdio>
#define N 800
#define M 300300
#define INF 1000010000
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define REP(u) for(int i=hd[u],v=e[i].v,c=e[i].c;i;i=e[i].n,v=e[i].v,c=e[i].c)
using namespace std;
int n,k,c,u,num,goal,sum,s,t,to[N][N],l,r,q[M],dep[N];
struct edge{int n,v,c;}e[M];
int hd[N],fl=1;
void add(int u,int v,int c){e[++fl].v=v,e[fl].c=c,e[fl].n=hd[u],hd[u]=fl;} 
bool bfs(int s,int t){
	FOR(i,1,t) dep[i]=-1;
	l=r=1,q[r++]=s;
	while(l<r){
		u=q[l++];
		REP(u)
		    if(c>0 && dep[v]==-1)
		   	    dep[v]=dep[u]+1,q[r++]=v;	       
	}
	return dep[t]!=-1;
}
int dfs(int u,int exp){
	if(u==t) return exp;
	int flw=0,tmp=0;
	REP(u){
		if(dep[v]==dep[u]+1 && c>0){
			tmp=dfs(v,min(exp,c));
		    if(!tmp)continue;
		    if(u<=k && k<v) to[u][v-k]=1;
		    if(u>k && k>=v) to[v][u-k]=0;
		    flw+=tmp,exp-=tmp;
		    e[i].c-=tmp,e[i^1].c+=tmp;
		    if(!exp)break;
		}
	}
	return flw;
}
void dinic(int s,int t){while(bfs(s,t)) goal-=dfs(s,INF);}
int main(){
	scanf("%d%d",&k,&n),s=0,t=n+1+k;
	FOR(i,1,k) scanf("%d",&c),add(s,i,c),add(i,s,0),goal+=c;
	FOR(i,1,n) scanf("%d",&c),add(i+k,t,c),add(t,i+k,0);
	FOR(i,1,k)
	    FOR(j,k+1,k+n) add(i,j,1),add(j,i,0);
	dinic(s,t);
	if(goal) printf("0");
	else{
		printf("1\n");
		FOR(i,1,k){
			FOR(j,1,n)
			    if(to[i][j]==1) printf("%d ",j);
			printf("\n");
		}
	}
	return 0;
}
```

---

## 作者：7KByte (赞：1)

网络流24  


------------
做网络流的题目第一步就是找题目中的限制条件  
如这道题，有3个限制条件  
### 1.每张餐桌最多容纳$c_i$个人  
### 2.同一个单位的人不能坐在同一张餐桌  
### 3.每个单位$r_i$个人（其实这也是个限制条件，可以直接作用在网络流建模上）  


---------
### 我们建立初步模型，一个超级源点一个超级汇点，一些点表示单位，另一些点餐桌  
### 1.对于第一个限制条件，我们将每个餐桌向汇点连一条容量$c_i$的边，限制每张餐桌坐的人数
### 2.对于第三个限制条件，我们将源点向每个单位连一条容量$r_i$的边，限制每个单位人数
### 3.对于第二个限制条件，我们从每个单位出发，向每张餐桌连容量为1的边，限制一张餐桌上这个单位的人只能有一个  
### 如果最大流$=$总人数，说明可以坐下，如果第$i$个单位向第$j$个餐桌的边有流经过，说明第$i$个单位有1个人坐到了第$j$个餐桌上,最后直接暴力统计即可  


### 代码：  
```cpp
#include<bits/stdc++.h>
using namespace std;
struct edge{
	int to;
	int next;
	int data;
}e[2000000];
int h[10000],pop=1,m,n,r[300],c[300],s=9000,t=9010,ans=0;
void add(int x,int y,int z){
	pop++;
	e[pop].to=y;e[pop].data=z;
	e[pop].next=h[x];h[x]=pop;
	pop++;
	e[pop].to=x;e[pop].data=0;
	e[pop].next=h[y];h[y]=pop;
}
int d[10000];
bool bfs(){
	queue<int>q;
	q.push(s);
	memset(d,0,sizeof(d));
	d[s]=1;
	while(q.size()){
		int x=q.front(),y;q.pop();
		if(x==t)return true;
		for(int i=h[x];i;i=e[i].next){
			if(d[y=e[i].to]||!e[i].data)continue;
			d[y]=d[x]+1;
			q.push(y);
		}
	}
	return false;
}
int dfs(int p,int flow){
	if(p==t)return flow;
	int rest=flow;
	for(int i=h[p],y;i;i=e[i].next){
		if(e[i].data&&d[y=e[i].to]==d[p]+1){
			int k=dfs(y,min(rest,e[i].data));
			if(!k)d[y]=-1;
			rest-=k;
			e[i].data-=k;
			e[i^1].data+=k;
		}
	}
	return flow-rest;
}
int main()
{
	memset(h,0,sizeof(h));
	scanf("%d%d",&m,&n);
	int sum=0;
	for(int i=1;i<=m;i++){
	  scanf("%d",&r[i]);
	  add(s,i,r[i]);
	  sum+=r[i];
	}
	for(int i=1;i<=n;i++){
	  scanf("%d",&c[i]);
	  add(m+i,t,c[i]);
	}
	for(int i=1;i<=m;i++)
	  for(int j=1;j<=n;j++)
	    add(i,j+m,1);
	while(bfs())ans+=dfs(s,(1<<29));
	/*for(int i=h[s];i;i=e[i].next){
		printf("%d %d\n",e[i].to,e[i].data);
	}*/
	if(ans==sum){
	printf("1\n");
	for(int i=1;i<=m;i++){
		int pop=0,l[500];
		//cout<<r[i]<<endl;
	  for(int j=h[i];j;j=e[j].next){
	  	if(!e[j].data)pop++,l[pop]=e[j].to-m;
	    }
	  for(int j=pop;j>0;j--)
	    printf("%d ",l[j]);
	  printf("\n");
	  }
	}
	else printf("0\n");
	return 0;
}
```

---

## 作者：11D_Beyonder (赞：0)

> 传送门 [$\looparrowright$](https://www.luogu.com.cn/problem/P3254)  

## 题目描述  
&emsp;&emsp;有来自 $m$ 个不同单位的代表参加一次国际会议。第 $i$ 个单位派出了 $r_i$ 个代表。  
&emsp;&emsp;会议的餐厅共有 $n$ 张餐桌，第 $i$ 张餐桌可容纳 $c_i$ 个代表就餐。  
&emsp;&emsp;为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。请给出一个满足要求的代表就餐方案。  
## 输入格式  
&emsp;&emsp;输入的第一行是用空格隔开的两个整数，分别代表单位的个数 $m$ 和餐桌的个数 $n$。  
&emsp;&emsp;第二行有 $m$ 个用空格隔开的整数，第 $i$ 个整数代表第 $i$ 个单位的代表人数 $r_i$。  
&emsp;&emsp;第三行有 $n$ 个用空格隔开的整数，第 $i$ 个整数代表第 $i$ 张餐桌能容纳的人数 $c_i$。  
## 输出格式  
&emsp;&emsp;本题存在 **Special Judge**。  
&emsp;&emsp;请输出是否存在满足要求的就餐方案，若存在，请给出任意一种可行的方案。  
&emsp;&emsp;输出的第一行是一个非 $0$ 即 $1$ 的整数，若存在方案则输出 $1$，否则输出 $0$。  
&emsp;&emsp;若存在方案，则对于第 $2$ 到第 $(m + 1)$ 行，在第 $(i + 1)$ 行输出 $r_i$ 个整数，代表第 $i$ 个单位的代表就餐的餐桌编号。  
## 输入输出样例  
### 输入 #1  
> 4 5
> 4 5 3 5
> 3 5 2 6 4

### 输出 #1
> 1
> 1 2 4 5
> 1 2 3 4 5
> 2 4 5
> 1 2 3 4 5

## 说明/提示  
### 数据规模与约定  
&emsp;&emsp;对于 $100\%$ 的数据，保证 $1 \leqslant m \leqslant 150$，$1 \leqslant n \leqslant 270$，$1 \leqslant r_i, c_i \leqslant 10^3$。  
### 提示  
&emsp;&emsp;请注意输入的第一行先读入 $m$ 再读入 $n$。   
## 分析  
&emsp;&emsp;每个单位和每张餐桌各自都相互独立，只有单位的代表和餐桌会产生联系；要将 $m$ 个单位的代表分配到 $n$ 张餐桌上，显然可以转化为二分图多重匹配问题。    
&emsp;&emsp;二分图左部为表示单位的节点，编号为 $1\sim m$；右部为表示餐桌的节点，编号为 $m+1\sim m+n$。进一步，我们要将二分图多重匹配问题转化为网络最大流问题。设立超级源点 $s$，超级汇点 $t$。$s$ 向 $1\sim m$ 的节点连边，容量为各自单位的代表人数 $r_i$，现实意义是每个单位至多有 $r_i$ 个人能分到餐桌；$m+1\sim m+n$ 的节点向 $t$ 连边，容量为各个餐桌的容纳人数 $c_i$，现实意义是每个餐桌至多容纳 $c_i$ 人就餐；$1\sim m$ 各个点都向 $m+1\sim m+n$ 的节点连边，容量为 $1$，每个单位节点都会向 $n$ 个餐桌节点连边，总共建立 $mn$ 条边，通过限制容量为 $1$，就限制了每张餐桌不可有相同单位的人同时就餐的条件。由于通过节点之间建边，已经满足题目匹配条件：每个单位有 $r_i$ 个代表，每张餐桌至多容纳 $c_i$ 人，同一个单位的不同代表不能分配到同一张餐桌。因此，网络最大流至多等于代表的总人数。  
![洛谷 P3254.png](https://i.loli.net/2020/07/27/eyxOcmlu18LkzBJ.png) 
&emsp;&emsp;运行一次 $\text{Dinic}$ 算法，即可求得网络最大流 $maxflow$。若最大流小于代表总人数，则不存在合法的匹配方案。若 $maxflow$ 等于代表总人数，考虑输出匹配方案。由于单位节点和餐桌节点之间的连边容量至多为 $1$，因此边上只会存在零流和满流两种状态；若 $i$ 指向 $j$ 的边剩余容量为 $0$（$i,j\in\mathbb{N^\ast}$，且 $1\leqslant i\leqslant m$，$1\leqslant j-m\leqslant n$），说明该边满流，第 $i$ 个单位有一人被分配到 $j-m$ 号餐桌。因此，我们不妨枚举左部点的出边，若该边剩余容量为 $0$，则输出该边的入点。   
## 代码  
```cpp
/******************************************************************
Copyright: 11D_Beyonder All Rights Reserved
Author: 11D_Beyonder
Problem ID: 洛谷 P3254
Date: 7/27/2020 
Description: Maximum Flow
*******************************************************************/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int N=503;
const int inf=0x3f3f3f3f;
struct E
{
	int to;
	int cap;
	int Next=-1;
}edge[N*N<<1];
int head[N],tot;
int s,t;
int depth[N];
int m,n;//单位个数 餐桌个数
int in;
void init();
inline void add_edge(int,int,int);
bool bfs();
int dfs(int x,int flow);
int Dinic();
int main()
{
	int i,j;
	cin>>m>>n;
	init();
	//与超级源点连边
	for(i=1;i<=m;i++)
	{
		int r;
		scanf("%d",&r);
		add_edge(s,i,r);
		in+=r;//统计人数
	}
	//左右两部之间连边
	for(i=1;i<=m;i++)
	{
		for(j=1;j<=n;j++)
		{
			add_edge(i,j+m,1);
		}
	}
	//与超级汇点连边
	for(i=1;i<=n;i++)
	{
		int c;
		scanf("%d",&c);
		add_edge(i+m,t,c);
	}
	if(Dinic()==in)
	{
		puts("1");
		//枚举左部的单位
		for(i=1;i<=m;i++)
		{
			//访问右部节点
			for(j=head[i];~j;j=edge[j].Next)
			{
				if(!edge[j].cap)
				{
					printf("%d ",edge[j].to-m);
				}
			}
			putchar('\n');
		}
	}
	else puts("0");
	return 0;
}
void init()
{
	tot=1;
	memset(head,-1,sizeof(head));
	s=0;
	t=n+m+1;
}
inline void add_edge(int u,int v,int cap)
{
	tot++;
	edge[tot].to=v;
	edge[tot].cap=cap;
	edge[tot].Next=head[u];
	head[u]=tot;
	//建立反边
	tot++;
	edge[tot].to=u;
	edge[tot].cap=0;
	edge[tot].Next=head[v];
	head[v]=tot;
}
bool bfs()
{
	memset(depth,0,sizeof(depth));
	queue<int>q;
	q.push(s);
	depth[s]=1;
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(register int i=head[x];~i;i=edge[i].Next)
		{
			int y=edge[i].to;
			//残量网络上构建分层图
			if(edge[i].cap&&!depth[y])
			{
				q.push(y);
				depth[y]=depth[x]+1;
				if(y==t) return 1;//汇点可达
			}
		}
	}
	return 0;
}
int dfs(int x,int flow)//当前节点 当前流量
{
	//dfs 返回残量网络上可增广的流量
	if(x==t) return flow;
	int rest=flow;//rest 剩余流量
	int temp;
	for(register int i=head[x];~i&&rest;i=edge[i].Next)
	{
		int y=edge[i].to;
		if(edge[i].cap&&depth[y]==depth[x]+1)
		{
			temp=dfs(y,min(rest,edge[i].cap));
			if(!temp) depth[y]=0;//剪枝 去掉增广完毕的点
			edge[i].cap-=temp;
			edge[i^1].cap+=temp;
			rest-=temp;
		}
	}
	return flow-rest;
}
int Dinic()
{
	int maxflow=0;
	while(bfs()) maxflow+=dfs(s,inf);
	return maxflow;
}
```
## 后记  
&emsp;&emsp;边的数量 $tot$ 必须初始化为 $1$。  

---

## 作者：shenbear (赞：0)

### 题目描述：
有n个单位，每个单位ai人，有m张桌子，每张bi个人，求一种每桌没有两个同一单位人的方案

### 分析：
看到几百的范围，看到人与位置的限制，看到方案输出，这些都指向一个东西——网络流

### 建图：
1.我们知道，单位和桌不是一个东西，所以大胆分层2组

2.由于每张桌子每单位只能坐1个，单位与桌之间连一条1的边，表示1个人坐1张桌的1个位置

3.每个单位只能让ai个人去，所以从s连1条ai的边，保证不会多占

4.每张桌子只能坐bi个人，所以向t连1条bi的边，保证不会超

（下面a指单位，b指圆桌）

------------
以上都是相对简单的，我也就讲这么多了，实在不理解可以多写写二分图的最大流，比方说用dinic求二分图最大匹配

然后我们就可以，愉快的跑最大流了

等等，然后呢，最大流之后呢，我们要的是方案啊！！！

## 方案：
1.我们完成最大流之后可以得到一个残余网络，在残余网络上其实有很多信息。

2.我们考虑，在放置一个人的时候，在图上就是，从s到a到b到t，流了一条1的流，同时它的反向边有了流量，所以我们只要访问一下反向边的流量，就可以知道是否被安置在这了

### 无解：
当你兴高采烈的交了之后，你会发现：WA90，你成功遗忘了无解

对于无解，其实就是最大流小于人数和：

我们最大流的限制主要来自ab两端，最大流==b和时，说明最大流受b限制，即受位置限制，当最大流小于人数和时，我们可以这样理解：受圆桌影响，人最不下了，无解

------------
代码：
```cpp
#include <bits/stdc++.h>
#define ll long long
#define il inline
using namespace std;
const int N = 2e5+10;
int n,m;
struct edge
{
	int next,from,to,w;
}p[N];
int head[N],num;
il void ad(int x,int y,int w){p[++num]=edge{head[x],x,y,w};head[x]=num;}
il void add(int x,int y,int w){ad(x,y,w);ad(y,x,0);}
il int qfj(int x){return ((x-1)^1)+1;}
int dep[N];
int s,t,mxfl;
bool bfs()
{
	memset(dep,0,sizeof(dep));
	queue<int> q;
	q.push(s);
	dep[s]=1;
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int i=head[u];i;i=p[i].next)
		{
			int v=p[i].to;
			if(!dep[v]&&p[i].w)
			{
				dep[v]=dep[u]+1;
				q.push(v);
			}
		}
	}
	return dep[t];
}
int dfs(int u,int limit)
{
	if(u==t||!limit) return limit;
	int w,flow=0;
	for(int i=head[u];i;i=p[i].next)
	{
		int v=p[i].to;
		if(dep[v]==dep[u]+1&&(w=dfs(v,min(limit,p[i].w))))
		{
			flow+=w;
			p[i].w-=w;
			p[qfj(i)].w+=w;
			limit-=w;
			if(!limit) break;
		}
	}
	return flow;
}
int g[333][333],sm;
int main() 
{
	cin>>n>>m;
	s=0;t=n+m+1;
	for(int i=1;i<=n;i++)
	{
		int x;
		scanf("%d",&x);
		if(x>m)
		{
			puts("0");
			return 0;
		}
		add(s,i,x);
		sm+=x;
	}
	for(int i=1;i<=m;i++)
	{
		int x;
		scanf("%d",&x);
		add(i+n,t,x);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			add(i,j+n,1);
			g[i][j]=num; //记录反向边序号 
		}
	}
	while(bfs()) mxfl+=dfs(s,1e9);//dinic 
//	printf("%d\n",mxfl);
//	for(int i=1;i<=num;i+=2) printf("%d %d %d %d\n",i,p[i].from,p[i].to,p[i].w);
	if(mxfl<sm) //位置不够无解 
	{
		puts("0");
		return 0;
	}
	puts("1");
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
		//	printf("%d %d %d %d %d %d\n",i,j,g[i][j],p[g[i][j]].from,p[g[i][j]].to,p[g[i][j]].w);
			if(p[g[i][j]].w) printf("%d ",j); //反向边有容量，匹配 
		}
		puts("");
	}
	return 0;
}

```


---

## 作者：lemir3 (赞：0)

[*获得更好的阅读体验*](https://www.cnblogs.com/Lemir3/p/11157511.html)

「网络流 24 题」圆桌聚餐

[*题面*](https://www.luogu.org/problemnew/show/P3254)

呼呼呼.

先来分析下题意吧.

有$m$个单位,每个单位有$r_i$个人,有$n$张桌子,每张桌子坐$c_i$个人.

判断是否可以让每张桌子上的人都分属于不同的单位,可以的话然后输出任意一个组合方式.

这样的话大致思路就出来了,每个单位的$r_i$个人中,每个人都要分属到不同的桌子去.

也就是说可以画成这样的图:

![配图1.png](https://i.loli.net/2019/07/09/5d243aaf751db35397.png)

左集中的点可以连向右集中的所有点,但是有自身人数的限制.

这不就是个裸的二分图多重匹配了吗.

~~但是我不会二分图多重匹配.~~

于是用网络流来写.(~~抱紧我的网络流~~)

用一个超级源点,连向左集中的所有点,流量为$r_i$.意为通过左集中流经$i$点的流量不能超过$r_i$.

再把右集中的所有点连向超级汇点,流量为$c_i$.意为右集中流经$i$点的流量不能超过$c_i$.

然后把左集和右集的点全部连起来,流量为$1$.因为一张桌子不能坐$1$个以上的任意一个单位的人.

如果流满的话,就说明有解.即最大流等于所有单位的人数.

然后遍历左集中的点连向的所有边,如果边上的流量变为了$0$(因为在Dinic过程中会把流经边的流量转移到残量上),就说明经过了这条边,输出即可~~科技为了我~~.

#代码

```cpp

#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iomanip>
#include<queue>

#define ll long long
#define INF 2147483647
#define debug(x) printf("bebug:%lld\n",x)

using namespace std;

struct edge
{
    ll to,flow,next;
}e[1000010];

queue<ll>q;

ll size,m,n,start,end,cnt,ans;
ll head[1000010],dis[1000010],copy_[1000010];
bool flag[1000010];

inline void EdgeAdd(ll,ll,ll);
inline void Dinic();
inline bool bfs();
inline ll dfs(ll,ll);
inline void print(ll);

signed main(void)
{
    memset(head,-1,sizeof(head));
    scanf("%lld%lld",&m,&n);
    start=0;
    end=n+m+1;
    for(ll _=1;_<=m;_++)
    {
        ll a;
        scanf("%lld",&a);
        cnt+=a;
        EdgeAdd(start,_,a);
        EdgeAdd(_,start,0);
        for(ll __=1;__<=n;__++)
        {
            EdgeAdd(_,__+m,1);
            EdgeAdd(__+m,_,0);
        }
    }
    for(ll _=1;_<=n;_++)
    {
        ll table;
        scanf("%lld",&table);
        EdgeAdd(_+m,end,table);
        EdgeAdd(end,_+m,0);
    }
    Dinic();
    if(ans==cnt)
    {
        printf("1\n");
        for(ll _=1;_<=m;_++)
        {
            print(_);
            printf("\n");
        }
    }
    else
    {
        printf("0\n");
    }
return 0;
}

inline void EdgeAdd(ll from,ll to,ll flow)
{
    e[size].to=to;
    e[size].flow=flow;
    e[size].next=head[from];
    head[from]=size++;
}

inline void Dinic()
{
    while(bfs())
    {
        memcpy(copy_,head,sizeof(head));
        ans+=dfs(start,INF);
    }
}

inline bool bfs()
{
    memset(flag,false,sizeof(flag));
    memset(dis,0,sizeof(dis));
    q.push(start);
    flag[start]=true;
    while(q.empty()==false)
    {
        ll from=q.front();
        q.pop();
        for(ll _=head[from];_!=-1;_=e[_].next)
        {
            ll to=e[_].to;
            ll flow_=e[_].flow;
            if(flow_>0&&flag[to]==false)
            {
                dis[to]=dis[from]+1;
                flag[to]=true;
                q.push(to);
            }
        }
    }
return flag[end];
}

inline ll dfs(ll from,ll flow)
{
    if(from==end||flow==0)
    {
        return flow;
    }
    ll sum=0;
    for(ll &_=copy_[from];_!=-1;_=e[_].next)
    {
        ll to=e[_].to;
        ll flow_=e[_].flow;
        if(flow_>0&&dis[to]==dis[from]+1)
        {
            ll f=dfs(to,min(flow_,flow-sum));
            e[_].flow-=f;
            e[_^1].flow+=f;
            sum+=f;
            if(sum==flow)return sum;
        }
    }
return sum;
}

inline void print(ll from)
{
    for(ll _=head[from];_!=-1;_=e[_].next)
    {
        ll to=e[_].to;
        ll flow_=e[_].flow;
        if(flow_==0&&to>from)
        {
            printf("%lld ",to-m);//注意这里减去单位数,因为代表桌子的点的编号是在代表单位的点的编号后面的
        }
    }
}

```

---

## 作者：little_sun (赞：0)

建模：

1.从源点向每个单位$x_i$连边，容量是该单位的人数

2.从每张餐桌$y_i$向汇点连边，容量是该餐桌能容纳的人数

3.从每个单位$x_i$向每张餐桌$y_j$连边，容量为$1$

如果最大流量等于所有单位人数之和，则有解，否则无解。
 
方案：

对于每个单位$x_i$，该单位向$y$集合连出的所有满流量边即为该单位人员的安排情况（证明显然

**Code:**

```cpp
#include <bits/stdc++.h>

#define R register
#define ll long long
#define cmax(a, b) ((a < b) ? b : a)
#define cmin(a, b) ((a < b) ? a : b)
#define sum(a, b, mod) ((a + b) % mod)

const int MaxN = 2e4 + 10;
const int MaxM = 5e5 + 10;
const int inf = (1 << 30);

struct edge
{
    int to, next, cap;
};

edge e[MaxM];
int n, m, s = 20000, t = 20001, cnt = 1, ans;
int head[MaxN], dep[MaxN], cur[MaxN], a[MaxN];

inline void add(int u, int v, int c)
{
    ++cnt;
    e[cnt].to = v;
    e[cnt].next = head[u];
    e[cnt].cap = c;
    head[u] = cnt;
}

inline void add_edge(int u, int v, int c) { add(u, v, c), add(v, u, 0); }

inline int read()
{
    int x = 0;
    char ch = getchar();
    while (ch > '9' || ch < '0')
        ch = getchar();
    while (ch <= '9' && ch >= '0')
        x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    return x;
}

inline int bfs()
{
    memset(dep, 0, sizeof(dep));
    memcpy(cur, head, sizeof(head));
    std::queue<int> q;
    dep[s] = 1;
    q.push(s);
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        for (int i = head[u]; i; i = e[i].next)
        {
            int v = e[i].to, c = e[i].cap;
            if (dep[v] || !c)
                continue;
            dep[v] = dep[u] + 1;
            q.push(v);
        }
    }
    return dep[t];
}

inline int dinic(int u, int flow)
{
    if (u == t)
        return flow;
    int rest = flow;
    for (int i = cur[u]; i && (flow - rest < flow); i = e[i].next)
    {
        int v = e[i].to, c = e[i].cap;
        if (dep[v] != dep[u] + 1 || !c)
            continue;
        int k = dinic(v, cmin(rest, c));
        if (!k)
            dep[v] = dep[u] + 1;
        else
        {
            e[i].cap -= k;
            e[i ^ 1].cap += k;
            rest -= k;
        }
    }
    if (flow - rest < flow)
        dep[u] = -1;
    return flow - rest;
}

inline void solve()
{
    int now = 0;
    while (bfs())
        while ((now = dinic(s, inf)))
            ans += now;
}

int main()
{
    int x, tmp = 0;
    m = read(), n = read();
    for (int i = 1; i <= m; i++)
        x = read(), add_edge(s, i, x), tmp += x;
    for (int i = 1; i <= n; i++)
        x = read(), add_edge(i + m, t, x);
    for (int i = 1; i <= m; i++)
    {
        for (int j = 1; j <= n; j++)
            add_edge(i, j + m, 1);
    }
    solve();
    if (ans != tmp)
        return 0 * printf("0");
    printf("1\n");
    for (int i = 1; i <= m; i++)
    {
        int h = head[i];
        while (h)
        {
            if (!e[h].cap)
                printf("%d ", e[h].to - m);
            h = e[h].next;
        }
        puts("");
    }
    return 0;
}
```





---

## 作者：Ajsoabk (赞：0)

# [网络流问题-圆桌问题](https://www.luogu.org/problemnew/show/P3254)

求一个圆桌与代表之间的匹配

满足代表分配到每个圆桌的人只有一个

所以将代表与圆桌连容量为一的边

源与代表连容量为代表个数的边

圆桌与汇连容量为圆桌容量的边

位子可以空但人不能没地方坐

所以最大流是否等于总人数就代表问题是否有解

建图跑dinic

```cpp

#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
const int M=200;
const int N=300;
const int inf=0x7fffffff;
template<class T>inline void read(T &num){
	char ch;
	while(!isdigit(ch=getchar()));
	num=ch-'0';
	while(isdigit(ch=getchar()))num=num*10+ch-'0';
}

int hea[M+N],to[N*M<<1],nex[N*M<<1],val[N*M<<1],dep[N+M],tot=1,n,m,s,t;

inline void add_edge(const int x,const int  y,const int w){
	to[++tot]=y,nex[tot]=hea[x],hea[x]=tot,val[tot]=w;
}

inline void Add_edge(const int x,const int y,const int w){
//printf("%d --> %d(%d)\n",x,y,w);
	add_edge(x,y,w);
	add_edge(y,x,0);
}

queue<int> que;
bool bfs(){
//printf("!\n");
	memset(dep,0,sizeof(dep));
	dep[s]=1;
	while(que.size())que.pop();
	que.push(s);
	int x;
	while(que.size()){
		x=que.front();que.pop();
		for(int i=hea[x];i;i=nex[i]){
			int y=to[i];
			if(val[i]&&!dep[y]){
				dep[y]=dep[x]+1;
//printf("%d -> %d\n",x,y);
//if(y==t)printf("return true\n");
				if(y==t)return true;
				que.push(y);
			}
		}
	}
	return false;
}

int dfs(const int x,const int flow){
//printf("dfs(%d,%d)\n",x,flow);
	if(x==t)return flow;
	int rest=flow,k;
	for(int i=hea[x];i&&rest;i=nex[i]){
		int y=to[i];
		if(val[i]&&dep[y]==dep[x]+1){
			k=dfs(y,min(rest,val[i]));
			if(k){
				val[i]-=k;
				val[i^1]+=k;
				rest-=k;
			}
			else dep[y]=0;
		}
	}
//printf("return %d\n",flow-rest);
	return flow-rest;
}

int dinic(){
	int maxflow=0,flow;
	while(bfs())while(flow=dfs(s,inf))maxflow+=flow;
//printf("return maxflow=%d\n",maxflow);
	return maxflow;
}

int ans;
int main(){
	read(m),read(n);
	s=n+m+1,t=s+1;
	for(int i=1,w;i<=m;++i){
		read(w);
		ans+=w;
		Add_edge(s,i,w);
	}
	for(int i=1,w;i<=n;++i){
		read(w);
		Add_edge(i+m,t,w);
	}
	for(int i=1;i<=m;++i)for(int j=1;j<=n;++j)Add_edge(i,j+m,1);
	if(dinic()==ans){
		printf("1\n");
		for(int i=1;i<=m;++i){
			for(int j=hea[i];j;j=nex[j]){
				int y=to[j];
				if(y<=m+n&&!val[j])printf("%d ",y-m);
			}
			printf("\n");
		}
	}
	else{
		printf("0\n");
	}
	return 0;
}


```

---

## 作者：Jiang_zi_chuan (赞：0)

~~自从登陆了CSDN后，就再没用过洛谷~~

[CSDN文章传送门](https://blog.csdn.net/jzc20080511/article/details/86027314)

在看了N多为位大佬的代码后，~~我想屎~~

~~大家都发的很高端的题解，而我~~

我的思路：

# 【问题分析】

二分图多重匹配问题，可以用最大流解决。
# 【建模方法】

建立二分图，每个单位为X集合中的顶点，每个餐桌为Y集合中的顶点，增设附加源S和汇T。

1、从S向每个Xi顶点连接一条容量为该单位人数的有向边。
2、从每个Yi顶点向T连接一条容量为该餐桌容量的有向边。
3、X集合中每个顶点向Y集合中每个顶点连接一条容量为1的有向边。

求网络最大流，如果最大流量等于所有单位人数之和，则存在解，否则无解。对于每个单位，从X集合对应点出发的所有满流边指向的Y集合的顶点就是该单位人员的安排情况（一个可行解）。
# 【建模分析】

对于一个二分图，每个顶点可以有多个匹配顶点，称这类问题为二分图多重匹配问题。X，Y集合之间的边容量全部是1，保证两个点只能匹配一次（一个餐桌上只能有一个单位的一个人），源汇的连边限制了每个点匹配的个数。求出网络最大流，如果流量等于X集合所有点与S边容量之和，那么则说明X集合每个点都有完备的多重匹配。

# 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1005;
const int MAXM = 1005;
const int INF = 0x3f3f3f3f;
struct Edge1
{
	int from,to,cap,flow;
};
struct Dinic
{
	int n,m,s,t;
	vector<Edge1> edges;
	vector<int> G[MAXN];
	bool vis[MAXN];
	int d[MAXN];
	int cur[MAXN];
	void init(int n)
	{
		this -> n = n;
		for(int i = 0; i <= n + 1; i++){
			G[i].clear();
		}
		edges.clear();
	}
	void AddEdge(int from,int to,int cap)
	{
		edges.push_back((Edge1){from,to,cap,0});
		edges.push_back((Edge1){to,from,0,0});
		m = edges.size();
		G[from].push_back(m - 2);
		G[to].push_back(m - 1);
	}
	bool BFS()
	{
		memset(vis,0,sizeof(vis));
		queue<int> Q;
		Q.push(s);
		d[s] = 0;
		vis[s] = 1;
		while(!Q.empty()) {
			int x = Q.front();
			Q.pop();
			for(int i = 0; i < G[x].size(); i++) {
				Edge1& e = edges[G[x][i]];
				if(!vis[e.to] && e.cap > e.flow) {
					vis[e.to] = 1;
					d[e.to] = d[x] + 1;
					Q.push(e.to);
				}
			}
		}
		return vis[t];
	}
	int DFS(int x,int a)
	{
		if(x == t || a == 0) return a;
		int flow = 0,f;
		for(int& i = cur[x]; i < G[x].size(); i++) {
			Edge1& e = edges[G[x][i]];
			if(d[x] + 1 == d[e.to] && (f = DFS(e.to,min(a,e.cap - e.flow))) > 0) {
				e.flow += f;
				edges[G[x][i] ^ 1].flow -= f;
				flow += f;
				a -= f;
				if(a == 0) break;
			}
		}
		return flow;
	}
	int Maxflow(int s,int t) {
		this -> s = s,this -> t = t;
		int flow = 0;
		while(BFS()) {
			memset(cur,0,sizeof(cur));
			flow += DFS(s,INF);
		}
		return flow;
	}
}din;
vector<int> ans[MAXN];
int main(void)
{
    int m,n,temp;
    scanf("%d %d",&m,&n);
    int S = 0,T = n + m + 1;
    int sum = 0;
    din.init(n + m + 2);
    for(int i = 1; i <= m; i++) {
        scanf("%d",&temp);
        sum += temp;
        din.AddEdge(S,i,temp);
    }
    for(int i = 1; i <= m; i++) {
        for(int j = 1; j <= n; j++) {
            din.AddEdge(i,j + m,1);
        }
    }
    for(int i = 1; i <= n; i++) {
        scanf("%d",&temp);
        din.AddEdge(i + m,T,temp);
    }
    if(sum == din.Maxflow(S,T)) {
        printf("1\n");
        for(int i = 0; i < din.edges.size(); i++) {
            Edge1 e = din.edges[i];
            if(e.from != S && e.to != T && e.flow == 1) {
                ans[e.from].push_back(e.to - m);
            }
        }
        for(int i = 1; i <= m; i++) {
            for(int j = 0; j < ans[i].size(); j++) {
                printf("%d ",ans[i][j]);
            }
            printf("\n");
        }
    }
    else printf("0\n");
    return 0;
}
```

# 大家可以看看我的码风（好差劲的码风）


---

## 作者：Sym_Je (赞：0)

           P3254 圆桌问题  
   [P3254 圆桌问题]()     
   
   * 贪心      
   
   首先我们发现这道题完全可以贪心 , 因为我们肯定要先放人数最多的公司的人，因为只有这样，最后他才不会因为前面的某些小公司占领了过多的位置导致无法安排，所以我们肯定要先放人数最多的公司的，然后我们考虑，是把他们先放容量大的桌子，还是容量小的桌子，显然是先放大的 ，因为我们要使其尽量放的桌子多，所以我们就要减小对以后的影响，因为只有这样，留给后面的空余桌子数才会最多 。   
   
```
评测状态
Accepted  100
用时: 30ms / 内存: 924KB

#include<bits/stdc++.h>

using namespace std;

int n,m;

int fl[500];

struct node
{
    int rs,id;
}t[500];

struct node2
{
    int rs,id;
}tt[500];

bool cmp(node a,node b)
{
    return a.rs>b.rs;
}
bool cmp2(node2 a,node2 b)
{
    return a.rs>b.rs;
}

int maxx=-1;
int ans[500][500];
int in[500];

int main() 
{
    scanf("%d%d",&m,&n);
    for(int i=1;i<=m;++i) scanf("%d",&t[i].rs),t[i].id=i;
    for(int i=1;i<=n;++i) cin>>tt[i].rs,tt[i].id=i;
    sort(t+1,t+m+1,cmp);
    sort(tt+1,tt+n+1,cmp2);
    int f=0;
    for(int i=1;i<=m;++i)
    {
        for(int j=1;j<=n;++j)
        {
            if(tt[j].rs&&t[i].rs)
            {
                tt[j].rs--;
                t[i].rs--;
                ans[t[i].id][++in[t[i].id]]=tt[j].id;
            }
        }
        if(t[i].rs) f=1;
        if(f) break;
    }
    if(f)
    {
        printf("0\n");
        return 0;
    }
    else
    {
        cout<<"1"<<endl;
        for(int i=1;i<=m;++i)
        {
            for(int j=1;j<=in[i];++j)cout<<ans[i][j]<<" ";cout<<endl;
        }
    }
    return 0;
}

```    

* 网络流    

首先我们开始建图，因为我们每个公司只能在一个桌子上方一个人，所以我们必须从公司向该桌子连一条边权为1的边，
但为了方便我们统计答案，我是把公司拆成一个个单元，然后分别向每个桌子连边，然后跑最大流，最后只要看每个点向其裂开的点之间那条边走过就输出到达的点就好咯。   

```
评测状态
Accepted  100
用时: 44ms / 内存: 5944KB

// luogu-judger-enable-o2
// luogu-judger-enable-o2
//m 单位 n 餐桌    
#include<bits/stdc++.h>

using namespace std;

const int maxn=50001;
const int inf=2e8;
int n,m,s,t,num=1;
int head[maxn],dep[maxn],cur[maxn];
struct node
{
	int nt,to,dis;
}edge[maxn*20];

void add(int f,int t,int d)
{
	edge[++num].nt=head[f];
	edge[num].dis=d;
	edge[num].to=t;
	head[f]=num;
}

void ADD(int a,int b,int c)
{
	add(a,b,c);
	add(b,a,0);
}


int bfs()
{
	queue<int> q;
	memset(dep,0,sizeof(dep)); 
	dep[s]=1;
	q.push(s);
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=head[u];i!=-1;i=edge[i].nt)
		{
			int v=edge[i].to;
			if(dep[v]==0&&edge[i].dis)
			{
				dep[v]=dep[u]+1;
				q.push(v);
			}
		}
	}
	return dep[t]!=0;
}

int dfs(int u,int dist)
{
	if(u==t) return dist;
	for(int &i=cur[u];i!=-1;i=edge[i].nt)
	{
		int v=edge[i].to;
		if(dep[v]==dep[u]+1&&edge[i].dis)
		{
			int di=dfs(v,min(dist,edge[i].dis));
			if(di)
			{
				edge[i].dis-=di;
				edge[i^1].dis+=di;
				return di;
			}
		}
	}
	return 0;
}

int dinic()
{
	int ans=0;
	while(bfs())
	{
		for(int i=0;i<=t;++i)
		cur[i]=head[i]; 
		while(int di=dfs(s,inf))
			ans+=di;
	}
		
	return ans;
}

void print()
{	
	for(int i=1;i<=m;++i)
	{
		for(int j=head[i];j!=-1;j=edge[j].nt)
		{
			int v=edge[j].to;
			if(edge[j].dis) continue;
			if(v<=m||m>n+m+(i-1)*n) continue;
			cout<<(v-m-(i-1)*n)<<" "; 
		}cout<<"\n";
	} 
} 
vector<int>as[maxn];
void print2()
{
	for(int i=1;i<=n;i++)
     {
         int f=1;
        for(int j=head[i+m+n*m];~j;j=edge[j].nt)
         if(edge[j].to!=t&&edge[j].dis==1)
         {
            as[(edge[j].to-m-i)/n+1].push_back(i);         }
     }
     for(int i=1;i<=m;i++)
     {
       printf("%d",as[i][0]);
        for(int j=1;j<as[i].size();j++)
             printf(" %d",as[i][j]);
         printf("\n");
     }
}

int main() 
{
	memset(head,-1,sizeof(head));
	scanf("%d%d",&m,&n);
	t=m+n+m*n+1;
	int tot=0;
	for(int i=1;i<=m;++i)
	{
		int x;
		scanf("%d",&x);
		ADD(s,i,x);
		tot+=x;
	} 
	for(int i=1;i<=m;++i)
	{
		for(int j=1;j<=n;++j)
		{
			ADD(i,m+(i-1)*n+j,1);
			ADD(m+(i-1)*n+j,m+n*m+j,1);
		}
	}
	for(int i=1;i<=n;++i)
	{
		int x;scanf("%d",&x);
		ADD(m+n*m+i,t,x);
	}
	if(dinic()==tot)
	{
		cout<<"1"<<"\n";
		print();
	}
	else cout<<"0"<<"\n";
	return 0;
}



```

当然也可以直接来建边不用来割点，同样也可以过，只要从每个公司向桌子连大小为1的边就好咯 。 ```

```
评测状态
Accepted  100
用时: 36ms / 内存: 4884KB
//m 单位 n 桌子 

#include<bits/stdc++.h>

using namespace std;

const int maxn=50001;
const int inf=1e8;
int n,m,s,t;
int ri[maxn],ci[maxn];

int cur[maxn],head[maxn],dep[maxn],num=1;

struct node
{
	int nt,to,dis;
}edge[maxn*20];

void add(int f,int t,int d)
{
	edge[++num].nt=head[f];
	edge[num].to=t;
	edge[num].dis=d;
	head[f]=num;
}

void ADD(int a,int b,int c)
{
	add(a,b,c);
	add(b,a,0);
}

int bfs()
{
	queue<int> q;
	memset(dep,0,sizeof(dep));
	dep[s]=1;
	q.push(s);
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=head[u];i!=-1;i=edge[i].nt)
		{
			int v=edge[i].to;
			if(dep[v]==0&&edge[i].dis)
				dep[v]=dep[u]+1,q.push(v);
		}
	}
	return dep[t]!=0;
}

int dfs(int u,int dist)
{
	if(u==t) return dist;
	for(int &i=cur[u];~i;i=edge[i].nt)
	{
		int v=edge[i].to;
		if(dep[v]==dep[u]+1&&edge[i].dis)
		{
			int di=dfs(v,min(dist,edge[i].dis));
			if(di)
			{
				edge[i].dis-=di;
				edge[i^1].dis+=di;
				return di;
			}
		} 
	}
	return 0;
}

int dinic()
{
	int ss=0;
	while(bfs())
	{
		for(int i=0;i<=t;++i) cur[i]=head[i];
		while(int di=dfs(s,inf))
			ss+=di;
	}
	return ss;
}

void print()
{
	for(int i=1;i<=m;++i)
	{
		for(int j=head[i];~j;j=edge[j].nt)
		{
			int v=edge[j].to;
			if(v==s||s==t||edge[j].dis) continue ;
			cout<<v-m<<" ";
		}cout<<"\n";
	}
}

int main() 
{
	memset(head,-1,sizeof(head));
	
	int tot=0;
	scanf("%d%d",&m,&n);
	t=m+n+1;
	for(int i=1;i<=m;++i)
		scanf("%d",&ri[i]),tot+=ri[i],ADD(s,i,ri[i]);
	for(int i=1;i<=n;++i)
		scanf("%d",&ci[i]),ADD(i+m,t,ci[i]);
	for(int i=1;i<=m;++i)
		for(int j=1;j<=n;++j)
			ADD(i,m+j,1);
	if(dinic()==tot)
	{
		cout<<"1"<<"\n";
		print();
	}
	else
	{
		cout<<"0";
		return 0;
	}
}






---

## 作者：封禁用户 (赞：0)

## 终于过了，发篇题解庆祝一下

~~其实主要是因为被卡死了最后一个点来……~~

普度众生？

不存在的！只是想给大家JIO一下当前弧优化

如果大佬已经了解就请跳过蒟蒻的题解吧

这一题的建边并不难，$S$向单位建一个流量为$R_i$的边,每个单位向每个桌子建一条流量为1的边，桌子向$T$建一条流量为$C_i$的边就好啦

### 步入正题：

我们想一下，

如果有一个点出去了很多条边，那么在DFS中会有重复的遍历

出题人~~恶~~良心一点就会被卡的死死的

如何不被卡死！这是一个问题QAQ

~~不要跟我说卡常，我卡了半天也没卡进去~~

所以我们可以在分完层之后，跑完一次后就记录一下上一次跑的边

然后就可以优秀的跑过了

~~其实当前弧优化要修改的地方真的不多~~

上代码QAQ：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
int head[100005],num_edge=-1,n,m,s,t,tot;
struct Edge
{
    int next,to,dis;
}edge[100005];
void add(int from,int to,int dis)
{
    edge[++num_edge].next=head[from];
    edge[num_edge].to=to;
    edge[num_edge].dis=dis;
    head[from]=num_edge;
}
int d[10001],q[10001],cur[10001];
bool bfs()
{
    int hea=0,tai=1;
    memset(d,0,sizeof(d));
    d[s]=1;
    q[1]=s;
    do
    {
		hea++;
        int x=q[hea];
        for(register int i=head[x];i!=-1;i=edge[i].next)
        {
            int y=edge[i].to;
            if(!d[y]&&edge[i].dis>0)
            {
                d[y]=d[x]+1;
                q[++tai]=y;
            }
        }
    }while(hea<tai);
    if(!d[t]) return 0;
    else return 1;
}
int dfs(int pos,int last)
{
    if(pos==t) return last;
    for(register int i=cur[pos];i!=-1;i=edge[i].next)//当前弧优化QAQ
      if(d[edge[i].to]==d[pos]+1&&edge[i].dis)
      {
      	int data=dfs(edge[i].to,min(edge[i].dis,last));
      	if(data>0)
      	{
      		edge[i].dis-=data;
      		edge[i^1].dis+=data;
      		cur[pos]=i;//当前弧优化QAQ
      		return data;
        }
      }
    return 0;
}
inline int read()
{
    char ch='!';int z=1,num=0;
    while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
    if(ch=='-')z=-1,ch=getchar();
    while(ch<='9'&&ch>='0')num=(num<<3)+(num<<1)+ch-'0',ch=getchar();
    return z*num;
}
inline int Dinic()
{
    int ans=0;
    while(bfs())
    {
    	memcpy(cur,head,sizeof(cur));//当前弧优化QAQ
    	while(int data=dfs(s,0x3f3f3f3f))
          ans+=data;
	}
    return ans;
}
int main(){
    memset(head,-1,sizeof(head));
    n=read();
    m=read();
    s=0;
    t=n+m+1;
    for(register int i=1;i<=n;++i)
    {
    	int r;
    	r=read();
    	add(s,i,r);
    	add(i,s,0);
    	tot+=r;
	}
	for(register int i=1;i<=n;++i)
	  for(register int j=1;j<=m;++j)
	    add(i,j+n,1),add(j+n,i,0);
	for(register int i=1;i<=m;++i)
	{
		int c;
		c=read();
		add(i+n,t,c);
		add(t,i+n,0);
	}
    int maxflow=Dinic();
    if(maxflow!=tot){printf("0");return 0;}
	printf("1\n");
    for(register int i=1;i<=n;++i)
    {
        for(register int j=head[i];j;j=edge[j].next)
          if(edge[j].dis==0&&edge[j].to!=0) printf("%d ",edge[j].to-n);
        printf("\n");
    }
}
```

---

## 作者：Celebrate (赞：0)

算法：网络流（终于是网络流了）

既然是网络流，就讲一下构图

![构图](https://cdn.luogu.com.cn/upload/pic/27313.png)

图片可能有一些丑，就不要介意啦

首先是st向每一个单位，流量为代表的数量

然后是每一个单位向圆桌，流量为1（每个圆桌只能派一个代表）

最后是圆桌向ed，流量为圆桌能坐下的数

如果满足条件，就看一下边的流量来判断代表所在的圆桌

注：

单位的编号我1-m，圆桌的编号为m+1-m+n

代码：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
struct node
{
    int x,y,c,next,other;
}a[210000];
int len,last[510],st,ed;
void ins(int x,int y,int c)
{
    int k1,k2;
    len++;k1=len;
    a[len].x=x;a[len].y=y;a[len].c=c;
    a[len].next=last[x];last[x]=len;
    len++;k2=len;
    a[len].x=y;a[len].y=x;a[len].c=0;
    a[len].next=last[y];last[y]=len;
    a[k1].other=k2;
    a[k2].other=k1;
}
int list[510],head,tail,h[510];
bool bt_h()
{
    memset(h,0,sizeof(h));h[st]=1;
    list[1]=st;head=1;tail=2;
    while(head!=tail)
    {
        int x=list[head];
        for(int k=last[x];k;k=a[k].next)
        {
            int y=a[k].y;
            if(a[k].c>0 && h[y]==0)
            {
                h[y]=h[x]+1;
                list[tail++]=y;
            }
        }
        head++;
    }
    if(h[ed]>0)return true;
    else return false;
}
int mymin(int x,int y)
{
    return x<y?x:y;
}
int findflow(int x,int f)
{
    if(x==ed)return f;
    int s=0,t;
    for(int k=last[x];k;k=a[k].next)
    {
        int y=a[k].y;
        if(a[k].c>0 && h[y]==(h[x]+1) && s<f)
        {
            s+=(t=findflow(y,mymin(a[k].c,f-s)));
            a[k].c-=t;a[a[k].other].c+=t;
        }
    }
    if(s==0)h[x]=0;
    return s;
}//以上就是网络流，不多说 
int m,n;
int A[310],B[310];
int map[310];
int main()
{
	int s=0;
	scanf("%d%d",&m,&n);
	for(int i=1;i<=m;i++) scanf("%d",&A[i]),s+=A[i];//s记录人数 
	for(int i=1;i<=n;i++) scanf("%d",&B[i]);
	st=m+n+1;ed=st+1;//起点和终点 
	len=0;memset(last,0,sizeof(last));
	for(int i=1;i<=m;i++)//连接公司到圆桌 
		for(int j=n;j>=1;j--) 
			ins(i,j+m,1);
	for(int i=1;i<=m;i++) ins(st,i,A[i]);
	for(int i=1;i<=n;i++) ins(m+i,ed,B[i]);
	int ans=0;
	while(bt_h()==true) ans+=findflow(st,999999999);
	if(ans<s){printf("0\n");return 0;}
	printf("1\n");
	for(int x=1;x<=m;x++)
	{
		memset(map,0,sizeof(map));
		for(int k=last[x];k;k=a[k].next)
		{
			if(a[k].c==0)
			{
				map[++map[0]]=a[k].y-m;
			}
		}
		for(int i=1;i<map[0];i++) printf("%d ",map[i]);
		printf("%d\n",map[map[0]]);
	}
	return 0;
}
```

---

## 作者：Isonan (赞：0)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P3254)

我果然还是太蒟了。。。这道题都调了两三次才过。

网络流建图：

1.因为每个单位只能有r[i]位代表，所以从源点到每个单位建流为r[i]的边；

2.同一单位代表不能同桌就餐->每桌每单位最多只有一位代表

于是从每个单位到每桌建流为1的边；

3.从每桌到汇点建流为c[i]的边。

这样最大流就是最多可分配的代表人数，如果<总人数则无解

跑完dinic后枚举2中的道路查看流的大小是否为0，为0则表示被选，输出即可。

### **dinic bfs时必须写h<t！dinic bfs时必须写h<t！dinic bfs时必须写h<t！**

（因为写成h<=tTLE了很多次）

代码如下：
```cpp
#include <cstdio>
#include <cstring> 
#define min(X,Y) ((X)<(Y)?(X):(Y))

int head[100001],nxt[4000001],b[4000001],v[4000001],k=1;
int n,m,r[100001],c[100001];
int dis[100001],p[100001],S,T;
int h,t,q[100001],exp;
inline void push(int s,int t,int val){
	nxt[++k]=head[s];
	head[s]=k;
	b[k]=t;
	v[k]=val;
}
bool bfs(){
	memset(dis,0,sizeof dis);
	dis[S]=1;
	h=t=0;
	q[++t]=S;
	while(h<t){
		++h;
		for(register int i=head[q[h]];i;i=nxt[i])
			if(v[i]&&!dis[b[i]]){
				dis[b[i]]=dis[q[h]]+1;
				q[++t]=b[i];
				if(b[i]==T)return 1;
			}
	}
	return 0;
}
int dfs(int x,int flow){
	if(x==T||!flow)return flow;
	int used=0;
	for(register int i=p[x];i;i=nxt[i]){
		if(v[i]&&dis[b[i]]==dis[x]+1){
			int w=dfs(b[i],min(flow-used,v[i]));
			v[i]-=w;
			v[i^1]+=w;
			used+=w;
			if(w)p[x]=i;
			if(used==flow)return flow;
		}
	}
	if(!used)dis[x]=0;
	return used;
}
int main(){
	scanf("%d%d",&m,&n);
	S=0,T=n+m+1;
	for(register int i=1;i<=m;i++)scanf("%d",r+i),push(S,i,r[i]),push(i,S,0),exp+=r[i];
	for(register int i=1;i<=n;i++)scanf("%d",c+i),push(i+m,T,c[i]),push(T,i+m,0);
	for(register int i=1;i<=m;i++)
		for(register int j=1;j<=n;j++)
			push(i,j+m,1),push(j+m,i,0);
	int ans=0;
	while(bfs()){
		memcpy(p,head,sizeof p);
		ans+=dfs(S,0x7f7f7f7f);
	}
	if(ans<exp)printf("0");
	else{
		printf("1\n");
		for(register int i=1;i<=n;i++,putchar('\n'))
			for(register int j=head[i];j;j=nxt[j])
				if(!v[j]&&b[j]>m&&b[j]<T)printf("%d ",b[j]-m);
	}
	return 0;
}
```

---

## 作者：FREEH (赞：0)


### 【题目大意】

- 有n个单位，每一个单位有pi个人，有m张桌子，每张桌子可以坐ci个人。要求一个单位的人不能坐在同一张桌子。问满足条件的方案。

### 【解题思路】

- 构图：有n个点，表示有n个单位；有m个点，表示有m张桌子。源点和n个点的边容量是pi，表示第i个单位有pi个人；汇点和m个点的边容量是ci，表示第i张桌子可以坐ci个人。每一个单位都与每一张桌子有一条容量为1的边，表示每一个单位只有1个人去每一张桌子，这样一个单位的人就不会坐在同一张桌子了。
- 会不会出现“凭空出现”一个人的情况呢？
- 不会，因为源点和单位点的边的容量就是这个单位的人数，不可能多，反而如果少了，就证明有代表没饭吃，所以没有方案。
- 产生一个最大流的路径表示第i个单位的1个人，可以坐在桌子j，然后枚举每一个单位，和每一张桌子，如果单位和桌子的边残余容量是0，就证明这里有一个方案，输出方案。

### 【解题反思】
- 构图时要注意点的标号。

### 【参考程序】
```cpp
#include<cstdio>
#include<string.h>
#define min(a,b)(a<b?a:b)
#define oo 2147483647
struct EDGE{int next,t,c;}e[4000005];
int vis[1000005],head[1000005],peo[1000005],din[1000005],s,t,cur,n,m,sum;
int dfs(int now,int mi)
{
	if (vis[now]) return 0;
	vis[now]=true;
	if (now==t) return mi;
	int h=head[now];
	while (h!=-1)
	{
		int t=e[h].t;
		if (e[h].c)
		{
			int res=dfs(t,min(mi,e[h].c));
			if (res)
			{
				e[h].c-=res;
				e[h^1].c+=res;
				return res;
			}
		}
		h=e[h].next;
	}
	return 0;
}
void Init()
{
	s=0;t=m+n+1;
	memset(head,-1,sizeof(head));
	cur=-1;
}
void add(int a,int b,int c)
{
	cur++;
	e[cur].t=b;
	e[cur].next=head[a];
	e[cur].c=c;
	head[a]=cur;
}
int main()
{
	scanf("%d%d",&m,&n);
	for (int i=1;i<=m;i++)
	{
		scanf("%d",&peo[i]);
		sum+=peo[i];
	}
	for (int i=1;i<=n;i++)
		scanf("%d",&din[i]);
	Init();
	for (int i=1;i<=m;i++)
	{
		add(s,i,peo[i]);
		add(i,s,0);
		for (int j=m+1;j<=m+n;j++)
		{
			add(i,j,1);
			add(j,i,0);
		}
	}
	for (int j=m+1;j<=m+n;j++)
	{
		add(j,t,din[j-m]);
		add(t,j,0);
	}
	int ans=0;
	while (1)
	{
		memset(vis,0,sizeof(vis));
		int res=dfs(s,oo);
		if (res) ans+=res;else break;
	}
	if (ans==sum) printf("1\n");else printf("0\n");
	for (int i=1;i<=m;i++)
	{
		int h=head[i];
		while (h!=-1)
		{
			int to=e[h].t;
			if (e[h].c==0&&to!=s) printf("%d ",to-m);
			h=e[h].next;
		}
		printf("\n");
	}
	return 0;
}
```



---

## 作者：glassy (赞：0)

设每个单位的代表数量为 $W_i$，每张桌子的座位数量为 $T_i$。

二分图匹配问题，可以把每个单位拆成 $W_i$ 个点，把桌子拆成 $T_i$ 个点，然后用KM算法求二分图完美匹配。

但是如果利用网络流可以将一些点合并。

构图方式：
1. 附加源汇 $S$ 和 $T$ 
2. 从 $S$ 向每个单位连一条流量为 $W_i$ 的边。
3. 从每张桌子向 $T$ 连一条流量为 $T_i$ 的边。
4. 从每个单位向每张桌子连一条流量为 $1$ 的边

这样，每条可行流对应一个代表坐进一张桌子里，设最大流为 $f$，则当且仅当 $f=\sum W_i $ 时问题有解。

虽然说$Dinic$处理二分图的时间复杂度为 $Θ(\sqrt n\ m)$，但在这种图中，每次DFS只能流 $1$ 的增广路，然后又要重新BFS，遍历整张图。因此，在这种情况下，$Isap$能根据附近的点到汇点的距离，临时修改到汇点的距离，不用遍历整张图，虽然渐进时间复杂度没有改变，但效率却摆在眼前。

下面的代码采用了链式向前星，效率比向前星高，有关输出可行解的问题，可以在链式向前星中找那些边的流量被流完了。
```cpp
#include<bits/stdc++.h>
using namespace std;
class ISAP {
	static const int maxn=10010;
	static const int maxm=100100;
	static const int INF=0x7fffffff;
    int n,s,t,len;
    struct Edge{//链式向前星
    	int from,to,flow,next;
	};
    bool vis[maxn];
    int dis[maxn];
    int cur[maxn];
    int p[maxn];
    int num[maxn];
    inline bool rev_bfs(void){
        memset(vis,0,sizeof(vis));
        queue<int> q;
        q.push(t);
        dis[t]=0;
        vis[t]=1;
        while(!q.empty()){
            int x=q.front();
            q.pop();
            for(register int i=head[x];i;i=edges[i].next){
                Edge &e=edges[i^1];
                if(!vis[e.from]&&e.flow>0){
                    vis[e.from]=1;
                    dis[e.from]=dis[x]+1;
                    q.push(e.from);
                }
            }
        }
        return vis[s];
    }
    //增广
    inline int augment(){
        int x=t,mx=INF;
        while(x!=s){
            Edge &e=edges[p[x]];
            mx=min(mx,e.flow);
            x=e.from;
        }
        x=t;
        while(x!=s){
            edges[p[x]].flow-=mx;
            edges[p[x]^1].flow+=mx;
            x=edges[p[x]].from;
        }
        return mx;
    }
public:
    int head[maxn];
	Edge edges[maxm<<1];
    inline void clear(){
        memset(head,0,sizeof(head));
        len=1;
    }
    inline ISAP(void){
        memset(head,0,sizeof(head));
        len=1;
    }
    inline void ins(int from,int to,int flow,int rev=0){
        edges[++len]=((Edge){from,to,flow,head[from]});
        head[from]=len;
        edges[++len]=((Edge){to,from,rev,head[to]});
        head[to]=len;
    }
    inline int max_flow(int s,int t,int n){
        this->s=s,this->t=t,this->n=n;
        int flow=0;
        rev_bfs();
        memset(num,0,sizeof(num));
        for(int i=0; i<n; i++)
            num[dis[i]]++;
        int x=s;
        memcpy(cur,head,sizeof(cur));
        while(dis[s]<n){
            if(x==t){
                flow+=augment();
                x=s;
            }
            bool tf=false;
            //当前弧优化
            for(register int &i=cur[x];i;i=edges[i].next){
                Edge &e=edges[i];
                if(e.flow>0&&dis[x]==dis[e.to]+1){
                    tf=true;
                    p[e.to]=i;
                    x=e.to;
                    break;
                }
            }
            //改变到汇点的最短距离，也叫做Retreat
            if(!tf){
                int m=n-1;
                for(register int i=head[x];i;i=edges[i].next){
                    Edge &e=edges[i];
                    if(e.flow>0)
                        m=min(m,dis[e.to]);
                }
                //Gap优化
                if(--num[dis[x]]==0)
                    break;
                num[dis[x]=m+1]++;
                cur[x]=head[x];
                if(x!=s)
                    x=edges[p[x]].from;
            }
        }
        return flow;
    }
}solve;
//神级读入优化
inline char nc() {
    static char buf[1000000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;
}
inline int read(int &sum) {
    char ch=nc();
    sum=0;
    while(!(ch>='0'&&ch<='9'))
        ch=nc();
    while(ch>='0'&&ch<='9')
        sum=(sum<<3)+(sum<<1)+(ch^48),ch=nc();
    return sum;
}
int n,m,ss=0;
int main(void)
{
    solve.clear();
    read(n),read(m);
    int s=n+m+1,t=n+m+2;
    for(int i=1,x;i<=n;i++){
    	read(x);ss+=x;
    	solve.ins(s,i,x);
    }
    for(int i=1,x;i<=m;i++){
    	read(x);
    	solve.ins(i+n,t,x);
    }
    for(int i=1;i<=n;i++)
    	for(int j=1;j<=m;j++)
    		solve.ins(i,j+n,1);
    if(solve.max_flow(s,t,n+m+2)==ss){
    	printf("1\n");
    	for(int k=1;k<=n;k++){//输出可行解
    		for(int i=solve.head[k];i;i=solve.edges[i].next)
    			if(solve.edges[i].to!=s&&solve.edges[i].flow==0)
    				printf("%d ",solve.edges[i].to-n);
    		printf("\n");
    	}
    }else
    	printf("0\n");
    return 0;
}
```

---


# 骑士共存问题

## 题目描述

在一个 $n \times n$ 个方格的国际象棋棋盘上，马（骑士）可以攻击的棋盘方格如图所示。棋盘上某些方格设置了障碍，骑士不得进入。

![](https://cdn.luogu.com.cn/upload/pic/2669.png)

对于给定的 $n \times n$ 个方格的国际象棋棋盘和障碍标志，计算棋盘上最多可以放置多少个骑士，使得它们彼此互不攻击。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 200$，$0 \leq m \lt n^2$。

## 样例 #1

### 输入

```
3 2
1 1
3 3```

### 输出

```
5```

# 题解

## 作者：w4p3r (赞：100)

#### 前言：
做这道题前可以先去做方格取数问题，那道题跟这道题区别不大，但是我觉得那道题比这道题更简单一点。
#### 思路：
如果你已经做过了方格取数问题，那你会发现这道题所有点可以跟那道题一样分成两部分，而且分法一模一样，你可以自己画画图试试。

如果你没做过那道题，那也没事，我们先来看一个5x5的棋盘

| O | X | O | X | O |
| -----------: | -----------: | -----------: | -----------: | -----------: |
| X | O | X | O | X |
| O | X | O | X | O |
| X | O | X | O | X |
| O | X | O | X | O |


如果我们将所有点分成O和X两种点，我们可以发现同种点无法互相攻击，而且如果你自己画图的话可以发现所有的图都有这个规律。

那我们可以把所有点分成两个点集，分别为O点的点集和X的点集，然后在两个点集有某些点对无法全选。

####  做法：
~~按照常规套路~~，先创一个源点和汇点

让源点到所有O点（即横纵坐标加起来为奇数的点）连一条容量为$1$的边

让所有X点（即横纵坐标加起来为偶数的点）到汇点连一条容量为$1$的边


再对无法同时选择的O点和X点，让O点连一条到X点容量为$inf$的点

**当然，以上都是不考虑有障碍的点的**

最后跑最大流，设为最大流为x，输出$n*n-m-x$就好了

#### 证明：

为什么这样是正确的？

我们先简化模型，原题经我们分析相当于有一个二分图（**设这两个点集分别为X，Y**），我们要在这个二分图选出最多的点，使这些点中任意两个点之间没有边。

而我们要证明的即为，**选出最多的点数=原点数-网络最大流**

又**最大流最小割定理，网络最大流=将源点汇点分开最小割的容量**

所以我们将证明转换为了，**选出最多点数=原点数-最小割**

而我们知道，一个割就是将所有点分割成**S和T两个集合，其中s∈S，t∈T**

我们不妨假设**S∪X即是我们在X中选的点，T∪Y即是我们在Y中选的点**

**显而易见的，S∪Y即是我们在X中不选的点，T∪X即是我们在Y中不选的点**

那我们建inf的边意义即在**我们强制了不能同时选的两点必在同一个集合（即为一个不选一个选），因为如果它们不在同一个集合中，割的大小就超过了inf，肯定不会成为最小割**

而我们建1的边的意义即在**如果X中的点不在S中，或者Y中的点不在T中，就会损失一个点，而损失当然越小越好了**

所以可以得到**选出最多点数=原点数-最小割**,而又由最大流最小割定理，最小割=最大流，就可以跑最大流了。证毕。

**这也就是二分图的最大独立集**

本人只是一个提高370的菜鸡，证明可能~~严重~~稍微不大严谨，大家理解就好啦，~~就不要纠结我不会用数学语言证明了qwq~~。
#### 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#include<vector>
#include<stack>
#include<map>
#include<deque>
#define inf 0x7fffffff/2
#define eps 1e-6
#define N 100010
#define M 3000010
#define K 1010
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
inline ll read()
{
	char ch=getchar();
	ll s=0,w=1;
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
struct edge
{
	int next,to,fl;
}e[M<<1];
int n,m;
int head[N],cnt=1;
int depth[N];
int x[8]={1,1,-1,-1,2,2,-2,-2},y[8]={2,-2,2,-2,1,-1,1,-1}; 
//马可以往8个方向跑
int flag[K][K];
queue<int>Q;
int s,t;
inline void add_edge(int from,int to,int fl)
{
	e[++cnt].to=to;
	e[cnt].next=head[from];
	e[cnt].fl=fl;
	head[from]=cnt;
}//加边
inline int arr(int x,int y)
{
	return (x-1)*n+y;
}//坐标转换
inline int bfs()
{
	memset(depth,0,sizeof(depth));while(!Q.empty())Q.pop();
	Q.push(s);depth[s]=1;
	while(!Q.empty())
	{
		int x=Q.front();Q.pop();
		for(register int i=head[x];i;i=e[i].next)
		{
			if(e[i].fl>0&&!depth[e[i].to])
			{
				depth[e[i].to]=depth[x]+1;Q.push(e[i].to);
			}
		}
	}
	return depth[t];
}
int dfs(int now,int flow)
{
	if(now==t)return flow;
	int ret=0;
	for(register int i=head[now];i;i=e[i].next)
	{
		if(ret==flow)return flow;
		if(depth[e[i].to]==depth[now]+1&&e[i].fl>0)
		{
			int fl=dfs(e[i].to,min(flow,e[i].fl));
			if(fl>0)
			{
				ret+=fl;
				e[i].fl-=fl;
				e[i^1].fl+=fl;
			}
		}
	}
	if(!ret)depth[now]=0;
	return ret;
}
inline int Dinic()
{
	int sum=0;
	while(bfs())
	{
		int x=1;while(x){x=dfs(s,inf);sum+=x;}
	}
	return sum;
}//最大流
int main()
{
	n=read(),m=read();
	t=n*n+1;//有n*n个点
	for(register int i=1;i<=m;i++)
	{
		int x=read(),y=read();
		flag[x][y]=1;
	}
	for(register int i=1;i<=n;i++)
	{
		for(register int j=1;j<=n;j++)
		{
			if((i+j)&1)
			{
				if(!flag[i][j]){add_edge(s,arr(i,j),1),add_edge(arr(i,j),s,0);}//O点
			}
			else
			{
				if(!flag[i][j]){add_edge(arr(i,j),t,1),add_edge(t,arr(i,j),0);}//X点
			}
		}
	}
	for(register int i=1;i<=n;i++)
	{
		for(register int j=1;j<=n;j++)
		{
			if(((i+j)&1)==0)continue;
			for(register int k=0;k<8;k++)
			{
				int tox=i+x[k],toy=j+y[k];
				if(tox>=1&&tox<=n&&toy>=1&&toy<=n&&!flag[tox][toy])
				{
					add_edge(arr(i,j),arr(tox,toy),inf),add_edge(arr(tox,toy),arr(i,j),0);
                    //对于不能同时选的点建inf边
				}
			}
		}
	}
	int flow=Dinic();//求出最小割即最大流
	printf("%d\n",n*n-m-flow);//输出
	return 0;
}
```

#### 后记：

做了这道题我最大的启示就是马的路径居然可以和方格取数问题一样分成两类点，以后再遇到类似的棋盘中的问题时，要先看看棋盘中的点是否也能分成两种跑最大流。

如果你觉得我的题解写得还不错的话，希望你能给我点个赞。

如果你对我的题解有什么不懂的地方，或者我的题解写得有任何问题的话，可以私信我告知，我尽量将我的题解做到最好的程度。





---

## 作者：George1123 (赞：41)

[${\color{#88cc00}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.com.cn/blog/Wendigo/)

[P3355 【骑士共存问题】](https://www.luogu.com.cn/problem/P3355)

### 此题算法:网络流$+$最小割($=$最大流)

最大流是一种网络流问题。

不会**最小割-最大流**的请按[<1>](https://www.luogu.com.cn/problem/P3376)。

**开始讲题：**

先将图相邻**黑白染色(如下样例)**。

![hbls.jpg](https://i.loli.net/2019/12/24/KUOuPgmzjQV7aX1.jpg)

由于一只骑士能攻击到的骑士在与自己**异色**的格中。

所以有一种摆法是都摆白格子上或黑格子上。

再将**能放骑士的地方都放上**。

这么做可以把**扔掉骑士**化为**求最小割**问题。

可以把一条**互相攻击**的关系变为网络流路径，

求**最少**扔掉几个骑士，使得**网络最大流**为$0$。

就相当于求网络流图的**最小割**(最大流$=$最小割)。

由于一个骑士能与多个骑士互相攻击，所以可以**共用路径**。

**${\color{#88cc00}\text{连网络流图}}$：**

**1.源点$s$向每个白格子连流量为$1$的边。**

**2.每个白格子向能攻击到的黑格子连流量为∞的边。**

**3.每个黑格子向汇点$t$连流量为$1$的边。**

![hbls2.jpg](https://i.loli.net/2019/12/24/FGjKXPouT642Yks.jpg)

>注意，因为这图最大流求出的只是要扔几个骑士，所以答案为$n^2-m-maxflow$。

## 以下是代码$+$注释

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+10; //n方大小
const int M=2e6+10; //10n方大小
const int inf=1e8+10;
int n,m,s,t,ans;
struct edge{
	int adj,nex,fw;
}e[M];
int g[N],top=1;
void add(int x,int y,int z){
	e[++top]=(edge){y,g[x],z};
	g[x]=top;
}
//以下是最大流模板，每道题都一样
int dep[N],cur[N];
bool vis[N];
queue<int> Q;
bool bfs(){
	for(int i=1;i<=n;i++)
		vis[i]=0,cur[i]=g[i];
	Q.push(s),vis[s]=1,dep[s]=0;
	while(Q.size()){
		int x=Q.front(); Q.pop();
		for(int i=g[x];i;i=e[i].nex){
			int to=e[i].adj;
			if(!vis[to]&&e[i].fw){
				vis[to]=1;
				dep[to]=dep[x]+1;
				Q.push(to);
			}
		}
	}
	return vis[t];
}
int dfs(int x,int F){
	if(!F||x==t)
		return F;
	int flow=0,f;
	for(int i=cur[x];i;i=e[i].nex){
		int to=e[i].adj; cur[x]=i;
		if(dep[x]+1==dep[to]&&
		(f=dfs(to,min(F,e[i].fw)))>0){
			e[i].fw-=f;
			e[i^1].fw+=f;
			flow+=f,F-=f;
			if(!F) break;
		}
	}
	return flow;
}
int p(int x,int y){return (x-1)*n+y;} //给点编号
bool G[210][210]; //1表示障碍，0表示可放骑士
int tx[]={1,1,2,2,-1,-1,-2,-2};
int ty[]={-2,2,-1,1,-2,2,-1,1}; //攻击方向
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,x,y;i<=m;i++){
		scanf("%d%d",&x,&y);
		G[x][y]=1;
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			if(G[i][j]) continue;
			if((i+j)&1){ //白格子
				add(1,p(i,j)+1,1);
				add(p(i,j)+1,1,0);
				for(int k=0;k<8;k++){
					int xt=tx[k]+i,yt=ty[k]+j;
					if(xt<1||xt>n||yt<1||yt>n||G[xt][yt])
						continue;
					add(p(i,j)+1,p(xt,yt)+1,inf);
					add(p(xt,yt)+1,p(i,j)+1,0);
				}
			} else add(p(i,j)+1,n*n+2,1), //黑格子
				add(n*n+2,p(i,j)+1,0);
		}
	ans=n*n-m,s=1,n=t=n*n+2; //将ans初始化，将n变为网络流节点数
	while(bfs()) ans-=dfs(s,inf); //网络流模板
	printf("%d\n",ans);
	return 0;
}
```

图是用画图软件手画的。

**写题解不易，点个赞吧。**

谢谢大家! !






---

## 作者：Ajwallet (赞：20)

# 注意，建图的奇偶性极大程度会影响程序效率

~~虽然我也不知道为什么~~

其实这道题匈牙利也能过91+9=100分。。。

# 匈牙利算法
奇偶建图（如果不这样会TLE更多的点），所以我们把奇数的点放在左边，偶数的点放在右边，若能攻击到彼此，则将它们连边，再求一边匈牙利
# 最大流求法
在匈牙利算法建模的基础上在左右两侧分别加上源点和汇点，并将源点和所有的奇数点连边，汇点和所有的偶数点连边（容量都为1）

若能攻击到彼此，则将它们连边（容量为无穷大），再跑一遍最大流即可

# 匈牙利算法代码（91分）以偶数建图
```cpp
#include<cstdio>
#include<cstring>
#define N 202
#define M 20002
#define r(i,a,b) for(int i=a;i<=b;i++)
using namespace std;int n,m,ans,one,g[N][N],two,link[M],xq[M][2];
bool vis[M],ok[N][N];
const short dx[8]={1,1,-1,-1,2,2,-2,-2};
const short dy[8]={-2,2,-2,2,-1,1,-1,1};
int read()//输入流
{
    char c;int f=0,d=1;
    while((c=getchar())<48||c>57)if(c=='-')d=-1;f=(f<<3)+(f<<1)+c-48;
    while((c=getchar())>=48&&c<=57)f=(f<<3)+(f<<1)+c-48;
    return d*f;
}
bool check(int x,int y)//判断是否满足要求
{
    if(x<1||x>n||y<1||y>n) return false;
    if(ok[x][y]||vis[g[x][y]]) return false;
    return true;
}
bool find(int x)
{
    int k=0,q=0,x1,y1;
    r(i,0,7)//这里没有必要建邻接表，因为骑士顶多跳周围的八个点
    {
        x1=xq[x][0]+dx[i];
        y1=xq[x][1]+dy[i];//取下坐标
        if(check(x1,y1))//没有跳出去则进行
        {
            k=g[x1][y1];
            q=link[k];
            link[k]=x;
            vis[k]=true;
            if(!q||find(q)) return true;
            link[k]=q;
        }
    }
    return false;
}
int main()
{
    n=read();m=read();
    r(i,1,m) ok[read()][read()]=true;
    r(i,1,n)
     r(j,1,n)
      if(!ok[i][j])
       {
        if((i+j)&1)
         g[i][j]=++one;
        else
        {
            g[i][j]=++two;
            xq[two][0]=i;
            xq[two][1]=j;//奇偶建图
        }
       }
    ans=n*n-m;
    r(i,1,two)
    {
        memset(vis,0,sizeof(vis));
        if(find(i)) ans--;
    }
    printf("%d",ans);//输出
}
```
# 匈牙利算法代码（AC 以奇数建图）
说实话我也觉得很奇怪。。。
```cpp
#include<cstdio>
#include<cstring>
#define N 202
#define M 20002
#define r(i,a,b) for(int i=a;i<=b;i++)
using namespace std;int n,m,ans,one,g[N][N],two,link[M],xp[M],xq[M];
bool vis[M],ok[N][N];
const short dx[8]={1,1,-1,-1,2,2,-2,-2};
const short dy[8]={-2,2,-2,2,-1,1,-1,1};
int read()
{
    char c;int f=0,d=1;
    while((c=getchar())<48||c>57)if(c=='-')d=-1;f=(f<<3)+(f<<1)+c-48;
    while((c=getchar())>=48&&c<=57)f=(f<<3)+(f<<1)+c-48;
    return d*f;
}
bool find(int x)
{
    int k=0,q=0,x1,y1;
    r(i,0,7)
    {
        x1=xp[x]+dx[i];y1=xq[x]+dy[i];
        if(x1<1||y1<1||x1>n||y1>n) continue;
        k=g[x1][y1];
        if(vis[k]||ok[x1][y1]) continue;
        q=link[k];
        link[k]=x;
        vis[k]=true;
        if(!q||find(q)) return true;
        link[k]=q;
    }
    return false;
}
int main()
{
    n=read();m=read();
    r(i,1,m) ok[read()][read()]=true;
    r(i,1,n)
     r(j,1,n)
      if(!ok[i][j])
       {
        if(!((i+j)&1))
         g[i][j]=++two;
        else
        {
            g[i][j]=++one;
            xp[one]=i;
            xq[one]=j;
        }
       }
    ans=n*n-m;
    r(i,1,one)
    {
        memset(vis,0,sizeof(vis));
        if(find(i)) ans--;
    }
    printf("%d",ans);
}
```
# 最大流代码（用奇数建，否则会超时。。。）
```cpp
#include<cstring>
#include<cstdio>
#include<queue>
#define M 500001//这个一定要开得足够大
#define k(i,j) (i-1)*n+j//用这个表示每个点的标号
#define min(a,b) a<b?a:b
#define max(a,b) a>b?a:b
using namespace std;int id,f,n,m,d[M],l[M],s,t,sum,a;char c;
bool ok[201][201];
int read()
{
	char c;f=0;
	while(c=getchar(),c<=47||c>=58);f=(f<<3)+(f<<1)+c-48;
	while(c=getchar(),c>=48&&c<=57) f=(f<<3)+(f<<1)+c-48;
	return f;
}
struct node{int next,to,w;}e[M];int tot;
const short dx[8]={1,1,-1,-1,2,2,-2,-2};
const short dy[8]={2,-2,2,-2,1,-1,1,-1};//八个方向
void add(int u,int v,int w)//建边
{
	e[tot].to=v;e[tot].w=w;e[tot].next=l[u];l[u]=tot++;
	e[tot].to=u;e[tot].w=0;e[tot].next=l[v];l[v]=tot++;
	return;
}
bool bfs()//分层图建设
{
	memset(d,-1,sizeof(d));
	queue<int>q;
	q.push(s);d[s]=0;
	while(q.size())
	{
		int x=q.front();q.pop();
		for(int i=l[x];i!=-1;i=e[i].next)
		{
			int y=e[i].to;
			if(e[i].w&&d[y]==-1)
			{
				d[y]=d[x]+1;
				q.push(y);
				if(y==t) return true;
			}
		}
	}
	return false;
}
int dfs(int x,int flow)//寻找可行流
{
	if(x==t||!flow) return flow;
	int rest=0,f;
	for(int i=l[x];i!=-1;i=e[i].next)
	{
		int y=e[i].to;
		if(d[x]+1==d[y]&&e[i].w)
		{
			rest+=(f=dfs(y,min(flow-rest,e[i].w)));
            e[i].w-=f;e[i^1].w+=f;
		}
	}
	if(!rest) d[x]=-1;
	return rest;
}
int dinic()
{
	int r=0;
	while(bfs()) r+=dfs(s,1e9);//求最大流
	return r;//返回
}
int main()
{
	memset(l,-1,sizeof(l));
	n=read();m=read();s=0;t=n*n+1;sum=n*n-m;
	while(m--) ok[read()][read()]=true;
	for(int i=1;i<=n;i++)
	 for(int j=1;j<=n;j++)
	 {
	 	if(ok[i][j]) continue;//若有障碍则跳过
	  	if((i+j)&1)
	  	{
	  		add(s,k(i,j),1);//与源点相连
	  		for(int o=0;o<8;o++)
	    	{
	    		int nx=i+dx[o],ny=j+dy[o];
	   			if(nx<1||ny<1||nx>n||ny>n||ok[nx][ny]) continue;
	   			id=k(nx,ny);
	   			add(k(i,j),id,1e9);//能攻击到则连边，与匈牙利算法不同的是这里是奇数建边，其实无论奇数建还是偶数建都不会有什么影响
	    	}
		} else add(k(i,j),t,1);//连边
     }
	printf("%d",sum-dinic());//输出
}
```
# 后记
记得在学最大流的时候，老师跟我们说让我们用网络流去做最大匹配的题，当时我还有点不解，做了这道题后算是有了一个比较深入的了解吧。

----
网络流24题的其他题貌似也有许多可以用匈牙利算法做~~，不明白为什么会被评为省选/NOI-。。。~~

---

## 作者：Binwens (赞：12)

# **为什么是最大独立集？**
### ~~好吧确实是~~
详细说明:
本题显然不存在唯一一行对应唯一一列（車的放置）的关系，那么我们**将每个“日”字的对角线进行连接** 表示这两个端点无法共存。
## 原题转化为:**如何去掉最少的点，去掉所有的边**
等效于**点数-最小点覆盖**
## 那么引出:最大独立集=n-最小点覆盖
又由于（**Konig定理**）最小点覆盖=最大匹配数
那么 匈牙利算法，拿下不解释
~~最大流也不错~~
技巧:dxdy存移动 for循环解决。
注意判断出界，禁止放置就好。
上代码：
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;

const int N=500;
struct Edge{
    int to,nxt;
}edge[N*N*4];
int dx[9]={1,1,2,2,-1,-1,-2,-2};
int dy[9]={2,-2,1,-1,2,-2,1,-1};
int head[N*N],tot=1;
void add(int x,int y){
    edge[++tot].to=y;
    edge[tot].nxt=head[x];
    head[x]=tot;
}
int num[N][N];
int n,m,k;
bool vis[N*N];
int match[N*N];
inline int read(){
    int ans=0;char c;bool flag=true;
    for(;c<'0'||c>'9';c=getchar())if(c=='-')flag=false;
    for(;c>='0'&&c<='9';c=getchar())ans=ans*10+c-'0';
    return flag ? ans : -ans;
}
bool dfs(int u){
    for(int i=head[u];i;i=edge[i].nxt){
        int v=edge[i].to;
        if(!vis[v]){
            vis[v]=1;
            if(!match[v]||dfs(match[v])){
                match[v]=u;
                return true;
            }
        }
    }
    return false;
}
bool ban[N][N];
void LINK(int x,int y);
int main(){
    n=read();m=read();
    for(int i=1;i<=m;i++){
    	int x=read(),y=read();
    	ban[x][y]=true;
    }
    int cnt=0;
    for(int i=1;i<=n;i++)
       for(int j=1;j<=n;j++)
           num[i][j]=++cnt;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(ban[i][j])continue;
            else LINK(i,j);
        }
    }
    int ans=0;
    for(int i=1;i<=cnt;i++){
        memset(vis,0,sizeof(vis));
        if(dfs(i))ans++;
    }
    printf("%d",(n*n)-m-(ans/2));
    return 0;
}
void LINK(int x,int y){
    for(int i=0;i<8;i++){
        int nowx=x+dx[i],nowy=y+dy[i];
        if(nowx>0&&nowx<=n&&nowy>0&&nowy<=n&&!ban[nowx][nowy]){
            add(num[x][y],num[nowx][nowy]);
            add(num[nowx][nowy],num[x][y]);
        }
    }
}
/*
6 6 2
1 1
6 6
*/
```


---

## 作者：Smokey_Days (赞：7)

```cpp
#include<iostream>
#include<cstdio>
/*
lp3355 网络流24题-骑士共存问题
首先我们观察这道题。
暴力地状压DP或者之类的操作显然会MLE/TLE。
我们发现，横坐标和纵坐标相加的和的奇偶性相同的格子永远不可能互相攻击到。
故而我们考虑建一张二分图。将横纵坐标的和的奇偶性不同的格子分别放在左右边，然后在能相互攻击到的点之间连边。依据题意，不能相互攻击到，所以答案即是这张图的最大独立集。

二分图最大独立集应当如何求得？我们有一个定理：一张二分图的最大独立集的大小等同于顶点数它的最大匹配的数量。
我们考虑感性地证明这个定理。 
很容易可以发现，两个点不能被同时选取，当且仅当它们之间有连边。
又因为，有连边的两个点必然是属于二分图的两端的。
故而，如果有两个点不能被同时选取，它们必然可以构成一个匹配。
对于二分图上的最大匹配，所有没有被匹配的点都可以被选取。这非常的显然，因为没有被匹配到的点之间必然没有连边。如果有连边，那么就可以增加匹配，与最大匹配矛盾。
而，对于每一个匹配，都可以选取一组匹配中的一个点。这是因为，对于一些连通的匹配，它们有且仅有一个部分（左边或者右边）会和未匹配点连接。
这也是很显然的，因为如果不是这样的话，就存在一条新的增广路径，就可以得到更多的匹配了。
注意：坐标如何哈希成一个数字。 
*/

const int dx[8]={-2,-1,1,2,-2,-1,1,2};
const int dy[8]={1,2,2,1,-1,-2,-2,-1}; 

struct ee{
	int v;
	int nxt;
}e[160005];
int h[40005],et=0;

inline void add(int U,int V){
	e[++et]=(ee){V,h[U]};
	h[U]=et; 
}

bool vis[40005],mp[205][205];
int n=0,m=0,usd[40005];

inline int calc(int X,int Y){
	return (X-1)*n+Y;
//	注意坐标哈希成数字的方式。 
}

inline bool dfs(int X){
	for(int i=h[X];i;i=e[i].nxt){
		if(!vis[e[i].v]){
			vis[e[i].v]=1;
			if(!usd[e[i].v]||dfs(usd[e[i].v])){
				usd[e[i].v]=X;
				return 1;
			}
		}
	}
	return 0;
}
int st[40005],tp=0;
char out[205][205];
void init(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			mp[i][j]=0;
			usd[calc(i,j)]=0;
			out[i][j]='O';
		}
	}
	int x,y;
	for(int i=1;i<=m;++i){
		scanf("%d%d",&x,&y);
		mp[x][y]=1;
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
//			printf("[%d %d] ",i,j);
			if(mp[i][j]||((i+j)&1)){
//				注意不是每次跳2而是判奇偶性。 
				continue;
			}
			st[++tp]=calc(i,j);
			out[i][j]='@'; 
			//注意有障碍的不仅是结束点，还有出发点。 
			for(int k=0;k<8;++k){
				x=i+dx[k],y=j+dy[k];
				if(x<=0||y<=0||x>n||y>n||mp[x][y]){
					continue;
				}
				out[x][y]='X';
				add(calc(i,j),calc(x,y));
			}
		}
	}
//	for(int i=1;i<=n;++i){
//		for(int j=1;j<=n;++j){
//			putchar(out[i][j]);
//		}
//		puts("");
//	}
	int ans=n*n-m;
//	减去被挖掉的点 
	for(int i=1;i<=tp;++i){
		for(int j=1;j<=n*n;++j){
			vis[j]=0;
		}
		ans-=dfs(st[i]);
	}
	printf("%d\n",ans);
}

int main(){
	init();
	return 0;
} 
```

---

## 作者：Social_Zhao (赞：5)

首先看题面上的图：

![](https://cdn.luogu.com.cn/upload/pic/2669.png)

这张图告诉了我们几个信息：

1. 马的移动规则（其实谁都知道）
2. 仔细（？）观察可以发现，马所在的格子和它影响的格子颜色不同

因此我们对格子进行染色。深色的是左边，浅色的是右边。然后从左边点向可以影响到的点（一定在右边）连接边：

很明显，我们这里要求出一个最大的点集，其中任意两点不共边（就是相互之间无影响）。

即：二分图最大独立集

二分图的最大独立集 = 点数 - 最小点覆盖 = **点数 - 最大匹配数 = 点数 - 网络最大流**

所以$ans = n \times n - m - max\_flow$

代码（AC，368ms）：

```cpp
/**
 *   ┏┓　　　┏┓
 * ┏┛┻━━━┛┻┓
 * ┃　　　　　　　┃
 * ┃　　　━　　　┃
 * ┃　┳┛　┗┳　┃
 * ┃　　　　　　　┃
 * ┃　　　┻　　　┃
 * ┃　　　　　　　┃
 * ┗━┓　　　┏━┛
 *    ┃　　　┃
 *    ┃　　　┃
 *    ┃　　　┗━━━┓
 *    ┃　　　　　　　┣┓
 *    ┃　　　　　　　┏┛
 *    ┗┓┓┏━┳┓┏┛
 *      ┃┫┫　┃┫┫
 *      ┗┻┛　┗┻┛
 *        神兽保佑
 *        代码无BUG!
 */
#include<bits/stdc++.h>
using namespace std;

int get()
{
	int x = 0, f = 1; char c = getchar();
	while(!isdigit(c)) { if(c == '-') f = -1; c = getchar(); }
	while(isdigit(c)) { x = x * 10 + c - '0'; c = getchar(); }
	return x * f;
}

const int N = 200 * 200 + 5, E = N * 20, inf = 0x3f3f3f3f;
const int dx[8] = {1, 2, -1, -2, 1, 2, -1, -2};
const int dy[8] = {2, 1, -2, -1, -2, -1, 2, 1};
int lim[205][205];
int n, m, s, t;
struct Edge {
	int v, nxt, w;
} edge[E];
int head[N], id = 1;
int max_flow;
int d[N];

int ID(int x, int y) { return (x - 1) * n + y; }

void addedge(int u, int v, int w)
{
	edge[++id].v = v;
	edge[id].w = w;
	edge[id].nxt = head[u];
	head[u] = id;
}

void insedge(int u, int v, int w)
{
	addedge(u, v, w);
	addedge(v, u, 0);
}

bool bfs() {
	memset(d, 0, sizeof(d));
	queue<int>q;
	q.push(s);
	d[s] = 1;
	while(q.size()) {
		int u = q.front(); 
		q.pop();
		for(int i = head[u]; i; i = edge[i].nxt) {
			int v = edge[i].v, w = edge[i].w;
			if(d[v] || !w) continue;
			q.push(v);
			d[v] = d[u] + 1;
		}
	}
	return d[t];
}

int dfs(int u, int flow)
{
	if(u == t) return flow;
	int rest = 0;
	for(int i = head[u]; i && flow; i = edge[i].nxt) {
		int v = edge[i].v, w = edge[i].w;
		if(d[v] != d[u] + 1 || !w) continue;
		int k = dfs(v, min(flow, w));
		if(!k) d[v] = 0;
		edge[i].w -= k;
		edge[i ^ 1].w += k;
		flow -= k;
		rest += k;
	}
	return rest;
}

void dinic()
{
	int now = 0;
	while(bfs()) 
		while(now = dfs(s, inf)) max_flow += now;
}

int main()
{
	n = get(), m = get();
	s = n * n + 1, t = n * n + 2;
	for(int i = 1; i <= m; i++) {
		int x = get(), y = get();
		lim[x][y] = 1;
	}
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= n; j++) {
			if(lim[i][j]) continue;
			if((i + j) % 2) {
				insedge(s, ID(i, j), 1);
				//printf("%d %d %d\n", s, ID(i, j), 1);
				for(int k = 0; k < 8; k++) {
					int x = i + dx[k];
					int y = j + dy[k];
					if(x >= 1 && x <= n && y >= 1 && y <= n && (!lim[x][y])) {
						insedge(ID(i, j), ID(x, y), 1);
						//printf("%d %d %d\n", ID(i, j), ID(x, y), 1);
					}
				}
			}
			else {
				insedge(ID(i, j), t, 1);
				//printf("%d %d %d\n", ID(i, j), t, 1);
			}
		}
	}
	dinic();
	//printf("%d\n", max_flow);
	printf("%d", n * n - m - max_flow);
	return 0;
}

```



---

## 作者：attack (赞：5)

最大流与最小割之间的转换

最多放多少骑士==最少拿走多少

观察图片不难发现：黄色的不能攻击黄色的，红色同理

那么不难想到二分图匹配

这样就转化成了二分图最小定点覆盖

而二分图最小顶点覆盖==二分图最大匹配。证明可以看[这里](http://www.cnblogs.com/jianglangcaijin/p/6035945.html)

从S向红色连边（权重为1），从红色向能攻击到的黄色连边（权重为INF），从黄色向T连边（权重为1）

跑最大流


```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<cstring>
#include<queue>
#define AddEdge(x,y,z) add_edge(x,y,z),add_edge(y,x,0);
using namespace std;
const int MAXN=100001,INF=1e8+10;
inline char nc()
{
    static char buf[MAXN],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,MAXN,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    char c=nc();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=nc();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=nc();}
    return x*f;
}
int N,M,S,T;
struct node
{
    int u,v,flow,nxt;
}edge[MAXN*5];
int head[MAXN],cur[MAXN],num=0;
inline void add_edge(int x,int y,int z)
{
	edge[num].u=x;
    edge[num].v=y;
    edge[num].flow=z;
    edge[num].nxt=head[x];
    head[x]=num++;
}
int deep[MAXN];
inline bool BFS()
{
    memset(deep,0,sizeof(deep));
    deep[S]=1;
    queue<int>q;
    q.push(S);
    while(q.size()!=0)
    {
        int p=q.front();
        q.pop();
        for(int i=head[p];i!=-1;i=edge[i].nxt)
            if(!deep[edge[i].v]&&edge[i].flow)
            {
            	deep[edge[i].v]=deep[p]+1;q.push(edge[i].v);
                if(edge[i].v==T) return 1;
            }
    }
    return deep[T];
}
int DFS(int now,int nowflow)
{
    if(now==T||nowflow<=0)    return nowflow;
    int totflow=0;
    for(int &i=cur[now];i!=-1;i=edge[i].nxt) 
    {
        if(deep[edge[i].v]==deep[now]+1&&edge[i].flow)
        {
            int canflow=DFS(edge[i].v,min(nowflow,edge[i].flow));
            edge[i].flow-=canflow;edge[i^1].flow+=canflow;
            totflow+=canflow;
            nowflow-=canflow;
            if(nowflow<=0) break;
        }
    }
    return totflow;
}
int Dinic()
{
    int ans=0;
    while(BFS())
    {
        memcpy(cur,head,sizeof(head)); 
        ans+=DFS(S,INF);
    }
	return ans;    
}
int a[201][201],c[201][201];
int xx[15]={0,-1,-2,-2,-1,+1,+2,+2,+1};
int yy[15]={0,-2,-1,+1,+2,+2,+1,-1,-2};
int main()
{
    #ifdef WIN32
    freopen("a.in","r",stdin);
    #else
    #endif
    memset(head,-1,sizeof(head));
    N=read();M=read();S=0;T=N*N+1;
    for(int i=1;i<=M;i++)
    {
    	int x=read(),y=read();
    	c[x][y]=1;
	}
	for(int i=1;i<=N;i++)
		for(int j=1;j<=N;j++)
			a[i][j]=(i-1)*N+j;
	for(int i=1;i<=N;i++)
		for(int j=1;j<=N;j++)
		{
			if(c[i][j]) continue;
			if((i+j)%2) 
			{
				AddEdge(S,a[i][j],1);
				for(int k=1;k<=8;k++)
				{
					int wx=i+xx[k],wy=j+yy[k];
					if(wx>=1&&wx<=N&&wy>=1&&wy<=N)
						AddEdge(a[i][j],a[wx][wy],INF);
				}
			}
			else AddEdge(a[i][j],T,1);
		}
	printf("%d",N*N-M-Dinic());
	
    return  0;
}
```

---

## 作者：不存在之人 (赞：4)

## 思路：

**~~听说这题是最大流 / 最小割 （不会啊）~~**

**画个图可以知道，根据互相能到达的关系建图，不存在奇环，即这个图是二分图。**

**然后求不能互相攻击的骑士数量也就是求这张图的最大独立集。**

**所以答案就等于 节点数 - 障碍数 - 最大匹配数。**
```cpp
#include<cstdio>
#include<cstring>
#include<vector>
using namespace std;
#define maxn 200
#define read(x) scanf("%d",&x)
#define write(x) printf("%d",x);
const int m1[10]={0,1,2,2,1,-1,-2,-2,-1};
const int m2[10]={0,-2,-1,1,2,-2,-1,1,2};
int n,m;
int a[maxn+5][maxn+5];
int cant;
vector<int>g[maxn*maxn+5];
bool use[maxn*maxn+5];
int match[maxn*maxn+5];
void readin()
{
	read(n),read(m);
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		a[x][y]=true;
	}
}
int getid(int x,int y)
{
	return (x-1)*n+y;
}
void makeg()
{
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(a[i][j])
			{
				cant++;
				continue;
			}
			if((i+j)&1)
			{
				continue;
			}
			for(int k=1;k<=8;k++)
			{
				int x=i+m1[k],y=j+m2[k];
				if(x>n||y>n||x<=0||y<=0||a[x][y]) continue;
				g[getid(i,j)].push_back(getid(x,y));
			}
		}
	}
}
bool dfs(int x)
{
	for(int i=0;i<g[x].size();i++)
	{
		int y=g[x][i];
		if(use[y]) continue;
		use[y]=true;
		if(!match[y]||dfs(match[y]))
		{
			match[y]=x;
			return true;
		}
	}
	return false;
}
int slv()
{
	int s=0;
	for(int i=1;i<=n*n;i++)
	{
		memset(use,0,sizeof(use));
		s+=dfs(i);
	}
	return s;
}
int main()
{
	readin();
	makeg();
	write(n*n-cant-slv());
	return 0;
}
```

---

## 作者：苏幕寒 (赞：3)

呜呜呜，卡了三天总于过了；这道题是 P2774 方格取数问题的升级版；做法和 P2774 方格取数问题十分相似；
首先建边：

以横坐标+纵坐标是奇数的格子连一条边连向源点，
然后以横坐标+纵坐标是偶数的格子连一条边连向汇点；然后以横坐标+纵坐标是奇数的格子连一条边连向横坐标+纵坐标是偶数的格子；表示这两个格子不能共存；
接下来：
跑最大流就可以了，原理很多大佬都说过了，我就不多提了，对了，重点强调：记得要加上优化！！！
不然会有两个点TlE，
~~不要问我怎么知道的；~~

具体如何优化见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2000005;
int n,m,s,t;
struct edge{
	int v,nxt,val;
}e[N];
int head[N],cnt=1,cur[N];
int ans;
bool b[1005][1005];
int dis[N];
int dx[]={1,1,-1,-1,2,2,-2,-2};
int dy[]={2,-2,2,-2,1,-1,1,-1};
int Read()
{
	int ch=0;
	char w=getchar();
	while(w<'0'||w>'9') w=getchar();
	while(w>='0'&&w<='9'){
		ch=ch*10+w-'0';
		w=getchar();
	}
	return ch;
}
void add(int u,int v,int val){
	e[++cnt]=(edge){v,head[u],val};head[u]=cnt;
	e[++cnt]=(edge){u,head[v],0};head[v]=cnt;
}
bool bfs()
{
	queue<int>q;
	memset(dis,-1,sizeof(dis));
	dis[s]=1;q.push(s);
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int i=head[u];i;i=e[i].nxt)
		{
			int v=e[i].v;
			if(dis[v]==-1&&e[i].val)
			{
				q.push(v);
				dis[v]=dis[u]+1;
			}
		}
	}
	return dis[t]!=-1;
}
int dfs(int u,int flow)
{
	if(u==t) return flow;
	int res=0;
	for(int i=cur[u];i;i=e[i].nxt)
	{
		cur[u]=i;int v=e[i].v;//当前弧优化，看不懂的可以百度一下
		if(dis[v]==dis[u]+1&&e[i].val)
		{
			int fl=dfs(v,min(flow,e[i].val));
			if(fl)
			{
				flow-=fl;res+=fl;
				e[i].val-=fl;e[i^1].val+=fl;
				if(!flow) return res;
			}
		}
	}
	if(!res) dis[u]=-1;//小剪枝 
	return res;
}
int main()
{
	n=Read();m=Read();
	ans=n*n-m;//记得减掉障碍数
	s=n*n+1;t=s+1;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		x=Read();y=Read();
		b[x][y]=1;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(b[i][j]==1) continue;
			if((i+j)%2==1) add(s,(i-1)*n+j,1);
			if((i+j)%2==0) add((i-1)*n+j,t,1);
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if((i+j)%2==0) continue;
			if(b[i][j]==1) continue;
			for(int k=0;k<8;k++)
			{
				int xx=dx[k]+i;
				int yy=dy[k]+j;
				if(xx<1||xx>n||yy<1||yy>n||b[xx][yy]==1) continue;
				add((i-1)*n+j,(xx-1)*n+yy,1e9);
			}
		}
	}建边，见上文
	while(bfs()){
		memcpy(cur,head,sizeof(head));
		ans-=dfs(s,1<<29);	
	}//Dinic大法
	printf("%d",ans);
	return 0;
}
```
看我写的这么辛苦，不点个赞吗；


---

## 作者：钱逸凡 (赞：2)

# 很明显的最大流最小割定理
思路和方格取数问题类似：

### 1.黑白染色

### 2.按照约束关系建图，求最小割（最好使用效率高一点的最大流算法如：[Dinic+当前弧优化](https://www.luogu.org/blog/ONE-PIECE/wang-lao-liu-jiang-xie-zhi-dinic)/[isap/hlpp](https://www.luogu.org/blog/ONE-PIECE/jiu-ji-di-zui-tai-liu-suan-fa-isap-yu-hlpp)）

### 3.答案就是n*n-m-maxflow


------------

解释一下：

第一步~~**黑白染色是看见网格图就该想到的常规思路**~~，什么叫黑白染色：我们把图按照点的横纵坐标之和的奇偶性可以划分为黑格和白格，黑格连汇点，白格连源点。

### 什么时候该用黑白染色？

当不同奇偶性的点会相互影响而同奇偶性的点不会相互影响时就用黑白染色，如本题中在奇数点放骑士只会导致一些偶数点不能放骑士，而不会影响奇数点。

第二步建图：

按照约束关系，把给每个白格向会影响的黑格加一条边（因为刚才是白格连源点，所以要从白格向黑格加边）

求最大流（即最小割）

第三步：n*n-m是可以放置的总格子数，maxflow是最小割（至少要拿掉多少个骑士才能满足题意）


------------

## 代码：（我用的是Dinic加当前弧优化）
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int inf=1<<30;
inline int Read(){
    int x=0,f=1;
    char c=getchar();
    while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
    return x*f;
}
int n,m;
int top=1;
int head[41011];
int s,t;
struct Node{
	int v;
	int val;
	int next;
}node[720020];//每个点向源点或汇点连一条边，最多向周围8个点连边，所以最多200*200*(8+1)*2（反向边）=720000条边
inline void addedge(int u,int v,int val){
	node[++top].v=v;
	node[top].val=val;
	node[top].next=head[u];
	head[u]=top;
}
inline void add(int u,int v,int val){
	addedge(u,v,val);
	addedge(v,u,0);
}
int dep[41010];
int cur[41010];//当前弧 
bool bfs(){
	register int i;
	for(i=1;i<=t;i++)cur[i]=head[i],dep[i]=-1;
	dep[s]=0;
	queue<int>q;
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(i=head[u];i;i=node[i].next){
			int d=node[i].v;
			if(dep[d]==-1&&node[i].val){
				dep[d]=dep[u]+1;
				q.push(d);
			}
		}
	}
	return dep[t]!=-1;
}
int maxflow=0;
int dfs(int u,int flow){
	if(u==t){
		maxflow+=flow;
		return flow;
	}
	int used=0;
	for(int i=cur[u];i;i=node[i].next){
		cur[u]=i;
		int d=node[i].v;
		if(node[i].val&&dep[d]==dep[u]+1){
			int mi=dfs(d,min(flow-used,node[i].val));
			if(mi){
				node[i].val-=mi;
				node[i^1].val+=mi;
				used+=mi;
				if(used==flow)break;
			}
		}
	}
	return used;
}
int Dinic(){
	maxflow=0;
	while(bfs())dfs(s,inf);
	return maxflow;
}//求最小割 
int map[201][201];
int fx[8]={-2,-2,-1,-1,1,1,2,2};
int fy[8]={1,-1,2,-2,2,-2,1,-1};
int main(){
	int i,j,k;
	n=Read(),m=Read();
	int x,y;
	s=n*n+1,t=n*n+2;
	for(i=1;i<=m;i++)x=Read(),y=Read(),map[x][y]=1;
	for(i=1;i<=n;i++){
		for(j=1;j<=n;j++){
			if(map[i][j])continue;
			int now=(i-1)*n+j;
			if((i+j)&1){
				add(s,now,1);
				for(k=0;k<=7;k++){
					int dx=i+fx[k],dy=j+fy[k];
					if(dx<1||dy<1||dx>n||dy>n||map[dx][dy])continue;
					add(now,(dx-1)*n+dy,1);
				}
			}
			else add(now,t,1);
		}
	}
	printf("%d",n*n-m-Dinic());//能放的总数-最小割 
    return 0;
}
```
~~[水双倍经验](https://www.luogu.org/problemnew/show/P4304)~~

---

## 作者：Ireliaღ (赞：1)

**最大流=最小割**

ISAP+当前弧优化巨快

### 解题思路

不难看出，马能攻击到的点和它本身所在的点黑白颜色不同，所以我们考虑建立二分图进行匹配

### 建图

* 设$0$为原点，$n ^ 2 + 1$为汇点，把格子上的每一个点映射到$[1, n ^ 2]$

* 对于$\forall i \in black$，如果**$i$点没有障碍**，从$0$向$i$建立容量为$1$的边

* 对于$\forall j \in white$，如果**$j$点没有障碍**，从$j$向$n ^ 2 + 1$建立容量为$1$的边

* 对于$\forall i \in black$，从$i$向能攻击到的八个白点建立容量为$\infty$的边

然后跑最大流，用总格数-障碍数-最大流即可

### 代码

看有人发匈牙利和dinic的题解，说奇数建图和偶数建图有一种过不了，但是用ISAP两种都能过。
```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>

using namespace std;

const int MAXN = 205;
const int INF = 0x3f3f3f3f;
const int DIRX[8] = {-2, -1, 1, 2, 2, 1, -1, -2};
const int DIRY[8] = {-1, -2, -2, -1, 1, 2, 2, 1};

int n, m;
bool trap[MAXN][MAXN];

int ID(int x, int y) {
    return (x - 1) * n + y;
}

struct Edge{
    int to, val;
    Edge *next, *ops;
    Edge(int to, int val, Edge *next): to(to), val(val), next(next){}
};

Edge *head[MAXN * MAXN], *cur[MAXN * MAXN];

void AddEdge(int u, int v, int w) {
    head[u] = new Edge(v, w, head[u]);
    head[v] = new Edge(u, 0, head[v]);
    head[u]->ops = head[v]; head[v]->ops = head[u];
}

int dep[MAXN * MAXN], gap[MAXN * MAXN], s, t, res;

void Bfs() {
    memset(dep, -1, sizeof(dep));
    memset(gap, 0, sizeof(gap));
    dep[t] = 0; gap[0]++;
    queue<int> q; q.push(t);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (Edge *e = head[u]; e; e = e->next) {
            int v = e->to;
            if (dep[v] != -1) continue;
            q.push(v);
            dep[v] = dep[u] + 1;
            gap[dep[v]]++;
        }
    }
}

int Dfs(int u, int flow) {
    if (u == t) {
        res += flow;
        return flow;
    }
    int used = 0;
    for (Edge *&e = cur[u]; e; e = e->next) {
        int v = e->to;
        if (e->val && dep[v] == dep[u] - 1) {
            int mi = Dfs(v, min(e->val, flow - used));
            if (mi) {
                used += mi;
                e->val -= mi;
                e->ops->val += mi;
            }
            if (used == flow) return used;
        }
    }
    gap[dep[u]]--;
    cur[u] = head[u];
    if (gap[dep[u]] == 0) dep[s] = n * n + 3;
    dep[u]++;
    gap[dep[u]]++;
    return used;
}

void Work() {
    memcpy(cur, head, sizeof(head));
    res = 0;
    Bfs();
    while (dep[s] <= n * n + 2) Dfs(s, INF);
}

int main() {
    ios :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> n >> m;
    s = 0; t = n * n + 1;
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        trap[x][y] = true;
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if ((i + j) % 2 == 0) {
                if (!trap[i][j]) AddEdge(0, ID(i, j), 1);
                for (int k = 0; k < 8; k++) {
                    int x = i + DIRX[k], y = j + DIRY[k];
                    if (x < 1 || x > n || y < 1 || y > n) continue;
                    AddEdge(ID(i, j), ID(x, y), INF);
                }
            } else {
                if (!trap[i][j]) AddEdge(ID(i, j), n * n + 1, 1);
            }
        }
    }
    Work();
    cout << n * n - m - res << endl;
    return 0;
}
```

---

## 作者：Biscuit46 (赞：1)

## 前言
网络流24题怎么这么难做啊。

## Solution
考虑这是一个二分图，按照给出的图发现黄色不能攻击黄色，红色不能攻击红色。
然后就是一个裸的二分图求最小割，直接跑Dinic就好了，无脑实现。
```cpp
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#include<algorithm>
#include<queue>
#include<set>
#include<map>
#include<iostream>
using namespace std;
#define ll long long
#define re register
#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)
inline int gi(){
	int f=1,sum=0;char ch=getchar();
	while(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}
	return f*sum;
}
const int N=100010,M=300010,Inf=1e9+10;
int front[N],nxt[M<<1],s,t,cnt,to[M<<1],w[M<<1],dep[N],n,m,a[510][510],num[510][510],cur[N];
int wa[9]={0,1,1,2,2,-1,-1,-2,-2};
int lk[9]={0,2,-2,1,-1,2,-2,1,-1};
void Add(int u,int v,int val){
	to[cnt]=v;nxt[cnt]=front[u];front[u]=cnt;w[cnt++]=val;
}
bool bfs(){
	queue<int>Q;while(!Q.empty())Q.pop();memset(dep,0,sizeof(dep));
	Q.push(s);dep[s]=1;
	while(!Q.empty()){
		int u=Q.front();Q.pop();
		for(int i=front[u];i!=-1;i=nxt[i]){
			int v=to[i];
			if(!dep[v] && w[i]){
				dep[v]=dep[u]+1;Q.push(v);
			}
		}
	}
	return dep[t];
}
int dfs(int u,int Flow){
	if(u==t || !Flow)return Flow;
	for(int &i=cur[u];i!=-1;i=nxt[i]){
		int v=to[i];
		if(dep[v]==dep[u]+1 && w[i]){
			int di=dfs(v,min(Flow,w[i]));
			if(di){
				w[i]-=di;w[i^1]+=di;return di;
			}
			else dep[v]=0;
		}
	}
	return 0;
}
int Dinic(){
	int Flow=0;
	while(bfs()){
		for(int i=s;i<=t;i++)cur[i]=front[i];
		while(int d=dfs(s,Inf))Flow+=d;
	}
	return Flow;
}
int main(){
	n=gi();m=gi();s=0,t=n*n+1;memset(front,-1,sizeof(front));
	for(int i=1;i<=m;i++){
		int x=gi(),y=gi();
		a[x][y]=1;
	}
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)num[i][j]=(i-1)*n+j;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(!a[i][j]){
				int color=(i+j)%2;
				if(!color){//黄色
					Add(s,num[i][j],1);Add(num[i][j],s,0);
					for(int k=1;k<=8;k++){
						int x=i+wa[k],y=j+lk[k];
						if(x>0 && x<=n && y>0 && y<=n && !a[x][y]){
							Add(num[i][j],num[x][y],Inf);Add(num[x][y],num[i][j],0);
						}
					}
				}
				else{Add(num[i][j],t,1);Add(t,num[i][j],0);}
			}
	printf("%d\n",n*n-Dinic()-m);
	return 0;
}
```

## 后话
我这道题目用最小割过了之后有人问我，为什么你的Dinic这么优秀？
qwq当然我也不知道啊。

---

## 作者：Mark_ZZY (赞：1)

### 关于构图：

首先，这是一道最小割的题目（类似于方格取数问题）。

我们可以想到一个性质，最大和=全局和-舍弃和，而舍弃和=最小割=最大流。
![](https://cdn.luogu.com.cn/upload/pic/15206.png)

我们可以看到上面的那一幅图，就会有所启发。

当一个点(i,j)满足(i+j)mod 2=1时，为白色的点，否则为黑色的点。

那根这道题有什么关系呢，我们可以发现，对于第一步，我们可以从一个黑色的点跳去一个白色的点，或反之。而这些可以跳到的点所连的边都是要“割”掉的，有了这些边，我们就可以跳了。

构图：

1.首先，需要一个超级源点和汇点。

2.源点连向每一个黑色的点，流量为这个点的值；同理，每一个白色的点都连向汇点，流量为1。

3.每一个黑色的点都连向与它可以挑到的白色的点，流量为INF，这些边需要“割”掉一些。

最后就可以根据最小割=最大流这个定理&最大和=全局和-舍弃和求解了。


### 关于代码：
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#define INF 2147483647
using namespace std; 
queue<int> f;
	const int fx[8]={1,1,-1,-1,2,2,-2,-2};
	const int fy[8]={2,-2,2,-2,1,-1,1,-1};
	struct node{int x,y,z,next;} a[500000];
	int last[100000];
	int n,m,len=-1,ans=0,st,ed;
	bool bz[500][500];
void ins(int x,int y,int z)
{
	a[++len].x=x;a[len].y=y;a[len].z=z;a[len].next=last[x];last[x]=len;
}
int h[100000];
bool bfs()
{
	memset(h,0,sizeof(h));
	h[st]=1;
	f.push(st);
	while(!f.empty())
	{
		int x=f.front();
		for(int i=last[x];i>=0;i=a[i].next)
		{
			int y=a[i].y;
			if(a[i].z>0&&h[y]==0)
			{
				h[y]=h[x]+1;
				f.push(y);
			}
		}
		f.pop();
	}
	if(h[ed]) return true; else return false;
}
int dfs(int x,int f)
{
	int s=0,t;
	if(x==ed) return f;
	for(int i=last[x];i>=0;i=a[i].next)
	{
		int y=a[i].y;
		if(a[i].z>0&&h[y]==h[x]+1&&f>s)
		{
			s+=(t=(dfs(y,min(f-s,a[i].z))));
			a[i].z-=t;
			a[i^1].z+=t;
		}
	}
	if(!s) h[x]=0;
	return s;
}
int dinic()
{
	int sum=0;
	while(bfs())
		sum+=dfs(st,INF);
	return sum;
}
int main()
{
	int x,y,id;
	scanf("%d %d",&n,&m);
	ans=n*n-m;
	st=0,ed=n*n+1;
	memset(last,-1,sizeof(last));
	memset(bz,true,sizeof(bz));
	for(int i=1;i<=m;i++)
	{
		scanf("%d %d",&x,&y);
		bz[x][y]=false;
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			if(!bz[i][j]) continue;
			id=(i-1)*n+j;
			if((i+j)&1)
			{
				ins(st,id,1),ins(id,st,0);
				for(int k=0;k<=7;k++)
				{
					int t1=i+fx[k],t2=j+fy[k];
					if(t1<=0||t1>n||t2<=0||t2>n||!bz[t1][t2]) continue;
					ins(id,(t1-1)*n+t2,INF),ins((t1-1)*n+t2,id,0);
				}
			} else ins(id,ed,1),ins(ed,id,0);
		}
	printf("%d",ans-dinic());
}
```

---

## 作者：封禁用户 (赞：1)

#割~
因为每个骑士放置后，因他而不能放置的位置必定与他颜色不同，所以建立源点汇点，从源点向所有黑点连边，从白点向汇点连边，然后把每个黑点向能阻碍的点连边，最后求割，即为最多能放的骑士数。

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<queue>
using namespace std;
#define inf 999999999

int n,m,x,y,fi[40002],ne[500001],w[500001],v[500001],cnt,tot,ans,dis[40002];
int nx[9]={0,1,2,-1,-2,1,2,-1,-2},ny[9]={0,2,1,-2,-1,-2,-1,2,1},z;
bool b[201][201];

void add(int u,int vv,int val)
{
    w[++cnt]=vv;v[cnt]=val;ne[cnt]=fi[u];fi[u]=cnt;
    w[++cnt]=u;v[cnt]=0;ne[cnt]=fi[vv];fi[vv]=cnt;
}

bool bfs()
{
    queue<int> q;
    memset(dis,-1,sizeof(dis));
    q.push(0);dis[0]=0;
    while(!q.empty())
    {
        int k=q.front();q.pop();
        for(int i=fi[k];i;i=ne[i])
          if(v[i]>0 && dis[w[i]]<0)
          {
              dis[w[i]]=dis[k]+1;
              if(w[i]==tot) return 1;
              q.push(w[i]);
          }
    }
    return 0;
}

int findd(int u,int vv)
{
    if(u==tot) return vv;
    int kkz,now=0;
    for(int i=fi[u];i;i=ne[i])
      if(v[i]>0 && dis[w[i]]==dis[u]+1 && (kkz=findd(w[i],min(v[i],vv-now))))
      {
          v[i]-=kkz;v[i^1]+=kkz;now+=kkz;
          if(now==vv) return now;
      }
    if(!now) dis[u]=-1;
    return now;
}

int main()
{
    scanf("%d%d",&n,&m);cnt=1;tot=n*n+1;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&x,&y);b[x][y]=1;
    }
    for(int i=1;i<=n;i++)
      for(int j=1;j<=n;j++)
        if(!b[i][j])
        {
            int now=(i-1)*n+j;
            if(!((i+j)%2))
            {
                add(0,now,1);
                for(int k=1;k<=8;k++)
                  if(!b[i+nx[k]][j+ny[k]] && (i+nx[k])>0 && (i+nx[k])<=n && (j+ny[k])>0 && (j+ny[k])<=n)
                  {
                      int now1=(i+nx[k]-1)*n+j+ny[k];
                      add(now,now1,inf);
                  }
            }
            else add(now,tot,1);
        }
    while(bfs()) ans+=findd(0,inf);
    printf("%d\n",n*n-m-ans);
    return 0;
}
```

---

## 作者：Isonan (赞：0)

 原题传送门[>Here<](https://www.luogu.org/problemnew/show/P3355)
 
 我们首先观察发现，可以将图中的点分成奇数点和偶数点。也就是说，对于点(x,y)，依据(x+y)的奇偶性分成两个点集。这样可以保证每个点所能攻击到的点一定和它在不同的集合中。
 
 1.从源点到每个没有障碍的奇数点建1条流为1的边；
 
 2.从每个没有障碍的奇数点到其可以攻击且没有障碍的偶数点建1条流为inf的边；
 
 3.从每个没有障碍的偶数点到汇点建1条流为1的边。
 
 这样建图以后，每一条从源点到汇点的弧表示有两个点会相互攻击。计算出图的最小割ans，即 使源点到汇点不连通所要花费的最小代价，它的实际意义就是在所有没有障碍的点中**至少**需要删除多少个才能使得没有点可以相互攻击。
 
 于是答案就是n*n-m-ans.
 
 又因为最小割=最大流，所以建图后跑一边dinic即可。
 
 代码如下：
 
 ```cpp
// luogu-judger-enable-o2
#include <cstdio>
#include <cstring>
#define min(X,Y) ((X)<(Y)?(X):(Y)) 

int S,T,n,m,head[40010],nxt[2050001],b[2050001],v[2050001],k=1,x,y;
bool map[201][201];
int dis[40010],p[40010],h,t,q[40010];
char ch;
inline void push(int s,int t,int val){
	nxt[++k]=head[s];
	head[s]=k;
	b[k]=t;
	v[k]=val;
}
inline void link(int s,int t,int val){
	push(s,t,val);
	push(t,s,0);
}
bool bfs(){
	memset(dis,0,sizeof dis);
	dis[S]=1;
	h=t=0;
	q[++t]=S;
	while(h<t){
		h++;
		for(register int i=head[q[h]];i;i=nxt[i])
			if(v[i]&&!dis[b[i]]){
				dis[b[i]]=dis[q[h]]+1;
				q[++t]=b[i];
				if(b[i]==T)return 1;
			}
	}
	return 0;
}
int dfs(int x,int flow){
	if(x==T||!flow)return flow;
	int used=0;
	for(register int i=p[x];i;i=nxt[i])
		if(v[i]&&dis[b[i]]==dis[x]+1){
			int w=dfs(b[i],min(flow-used,v[i]));
			v[i]-=w;
			v[i^1]+=w;
			used+=w;
			if(w)p[x]=i;
			if(used==flow)return flow;
		}
	if(!used)dis[x]=0;
	return used;
}
void check(int a,int b,int c,int d){
	if(c<=0||d<=0)return;
	if(c>n||d>n)return;
	if(map[c][d])return;
	link((a-1)*n+b,(c-1)*n+d,0x7f7f7f7f);
}
void read(int &x){
	x=0;
	ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=((x<<3)+(x<<1))+ch-'0',ch=getchar();
}
int main(){
	read(n),read(m);
	for(register int i=1;i<=m;i++)read(x),read(y),map[x][y]=1;
	S=0,T=n*n+1;
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<=n;j++)
			if(!map[i][j]){
				if(((i+j)&1)==0){
					link(S,(i-1)*n+j,1);
					check(i,j,i+1,j-2);
					check(i,j,i-1,j+2);
					check(i,j,i+2,j-1);
					check(i,j,i-2,j+1);
					check(i,j,i+1,j+2);
					check(i,j,i-1,j-2);
					check(i,j,i-2,j-1);
					check(i,j,i+2,j+1);
				}
				else{
					link((i-1)*n+j,T,1);
				}
			}
	int ans=0;
	while(bfs()){
		memcpy(p,head,sizeof p);
		ans+=dfs(S,0x7f7f7f7f);
	}
	printf("%d",n*n-ans-m);
}
```

---


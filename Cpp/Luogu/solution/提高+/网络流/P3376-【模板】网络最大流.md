# 【模板】网络最大流

## 题目描述

如题，给出一个网络图，以及其源点和汇点，求出其网络最大流。


## 说明/提示

#### 样例输入输出 1 解释

 ![](https://cdn.luogu.com.cn/upload/pic/2262.png) 

题目中存在 $3$ 条路径：

- $4\to 2\to 3$，该路线可通过 $20$ 的流量。
- $4\to 3$，可通过 $20$ 的流量。
- $4\to 2\to 1\to 3$，可通过 $10$ 的流量（边 $4\to 2$ 之前已经耗费了 $20$ 的流量）。

故流量总计 $20+20+10=50$。输出 $50$。

---

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n\leq10$，$m\leq25$。
- 对于 $100\%$ 的数据，保证 $1 \leq n\leq200$，$1 \leq m\leq 5000$，$0 \leq w\lt 2^{31}$。


## 样例 #1

### 输入

```
4 5 4 3
4 2 30
4 3 20
2 3 20
2 1 30
1 3 30
```

### 输出

```
50
```

# 题解

## 作者：Eleven谦 (赞：382)

# 网络最大流

#### 目录

- 前言

- 双倍经验

- 网络流初步

- 网络最大流

- $EK$增广路算法

- $Dinic$算法

------------
#### 前言

这篇题解是当做学习记录写的，所以会对网络最大流这个概念进行讲解（$dalao$们可以忽略蒟蒻$orz$）

#### 双倍经验$Time$

1. [洛谷P3376 【模板】](https://www.luogu.com.cn/problem/P3376) （$Ek$算法 / $Dinic$算法）

2. [洛谷P2740 [USACO4.2]草地排水Drainage Ditches](https://www.luogu.com.cn/problem/P2740)

------------
#### 网络流初步

这里主要讨论一下网络流算法可能会涉及到的一些概念性问题

- 定义

对于任意一张**有向图**（也就是**网络**），其中有$N$个点、$M$条边以及源点$S$和汇点$T$

然后我们把$c(x,y)$称为边的**容量**

- 转换

为了通俗易懂，我们来结合生活实际理解上面网络的定义：

将有向图理解为我们城市的**水网**，有$N$户家庭、$M$条管道以及供水点$S$和汇合点$T$

是不是好理解一点？现在给出一张网络（图丑勿怪啊QAQ）：

![](https://img2020.cnblogs.com/blog/2055990/202007/2055990-20200709150110449-380364997.png)

$S->C->D->E->T$就是该网络的一个流，$2$这个流的流量

- 流函数

和上面的$c$差不多，我们把$f(x,y)$称为边的**流量**，则$f$称为网络的流函数，它满足三个条件：

1. $s(x,y)≤c(x,y)$

2. $f(x,y)=-f(y,x)$

3. $\forall$ $x$≠$S$，$x≠T$, $\sum_{(u,x)∈E }f(u,x)=\sum_{(x,v)∈E }f(x,v)$ 

这三个条件其实也是流函数的三大性质：

1. 容量限制：每条边的流量总不可能大于该边的容量的（不然水管就爆了）

2. 斜对称：正向边的流量=反向边的流量（反向边后面会具体讲）

3. 流量守恒：正向的所有流量和=反向的所有流量和（就是总量始终不变）

- 残量网络

在任意时刻，网络中所有节点以及剩余容量大于$0$的边构成的子图被称为**残量网络**

------------
#### 最大流

对于上面的网络，合法的流函数有很多，其中使得整个网络流量之和最大的流函数称为网络的**最大流**，此时的流量和被称为网络的**最大流量**

最大流能解决许多实际问题，比如：一条完整运输道路（含多条管道）的一次最大运输流量，还有**二分图**（蒟蒻还没学二分图，学了之后会更新的qwq）

下面就来介绍计算最大流的两种算法：$EK$增广路算法和$Dinic$算法

------------
#### $Edmonds-Karp$增广路算法

（为了简便，习惯称为$EK$算法）

- 首先来讲增广路是什么：

若一条从$S$到$T$的路径上所有边的剩余容量都大于0，则称这样的路径为一条**增广路**（剩余流量：$c(x,y)-f(x,y)$）

- 然后就是$EK$算法的核心思想啦：

如上，显然我们可以让一股流沿着增广路从$S$流到$T$，然后使网络的流量增大

$EK$算法的思想就是**不断用**BFS**寻找增广路并不断更新最大流量值，直到网络上不存在增广路为止**

- 再来讲理论实现过程：

在$BFS$寻找一条增广路时，我们只需要考虑**剩余流量不为$0$的边**，然后找到一条从$S$到$T$的路径，同时计算出路径上**各边剩余容量值的最小值$dis$**，则网络的最大流量就可以增加$dis$（**经过的正向边容量值全部减去$dis$，反向边全部加上$dis$**）

- **反向边**

插入讲解一下反向边这个概念，这是网络流中的一个重点

为什么要建反向边？

因为可能**一条边可以被包含于多条增广路径**，所以为了寻找所有的增广路经我们就要让这一条边有**多次被选择的机会**

而构建反向边则是这样一个机会，相当于给程序一个**反悔**的机会！

为什么是反悔？

因为我们在找到一个$dis$后，就会对每条边的容量进行减法操作，而**直接更改值就会影响到之后寻找另外的增广路**！

还不好理解？那我们举个~~通俗易懂的~~例子吧：

![](https://img2020.cnblogs.com/blog/2055990/202007/2055990-20200709161217956-287497289.png)

原本$A$到$B$的正边权是1、反边权是0，在第一次经过该边后（假设$dis$值为1），则正边权变为0，反边权变为1

当我们需要第二次经过该边时，我们就能够通过走反向边恢复这条边的原样（可能有点绕，大家好好理解一下）

以上都是我个人的理解，现在给出《算法竞赛进阶指南》上关于反向边的证明：

“**当一条边的流量$f(x,y)>0$时，根据斜对称性质，它的反向边流量$f(y,x)<0$，此时必定有$f(y,x)<c(y,x)$，所以$EK$算法除了遍历原图的正向边以外还要考虑遍历每条反向边**”

- **邻接表“成对存储”**

我们将正向边和反向边存在“2和3”、“4和5”、“6和7”····

为什么？

因为在更新边权的时候，我们就可以直接使用$xor 1$的方式，找到对应的正向边和反向边（奇数异或1相当于-1，偶数异或1相当于+1）

代码实现如下（整个更新边权的操作函数）：

```cpp
inline void update() {
    int x=t;
    while(x!=s) {
        int v=pre[x];
        e[v].val-=dis[t];
        e[v^1].val+=dis[t];
        x=e[v^1].to;
    }
    ans+=dis[t];
}
```

- 适用范围

**时间复杂度为$O(nm^2)$，一般能处理$10^3$~$10^4$规模的网络**

- 代码$Code$

（以本道模板题的代码为准，其他题可以将$longlong$换成$int$并且可以去掉处理重边操作）

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,s,t,u,v;
long long w,ans,dis[520010];
int tot=1,vis[520010],pre[520010],head[520010],flag[2510][2510];

struct node {
	int to,net;
	long long val;
} e[520010];

inline void add(int u,int v,long long w) {
	e[++tot].to=v;
	e[tot].val=w;
	e[tot].net=head[u];
	head[u]=tot;
	e[++tot].to=u;
	e[tot].val=0;
	e[tot].net=head[v];
	head[v]=tot;
}

inline int bfs() {  //bfs寻找增广路 
	for(register int i=1;i<=n;i++) vis[i]=0;
	queue<int> q;
	q.push(s);
	vis[s]=1;
	dis[s]=2005020600;
	while(!q.empty()) {
		int x=q.front();
		q.pop();
		for(register int i=head[x];i;i=e[i].net) {
			if(e[i].val==0) continue;  //我们只关心剩余流量>0的边 
			int v=e[i].to;
			if(vis[v]==1) continue;  //这一条增广路没有访问过 
			dis[v]=min(dis[x],e[i].val);
			pre[v]=i;  //记录前驱，方便修改边权 
			q.push(v);
			vis[v]=1;
			if(v==t) return 1;  //找到了一条增广路 
		}
	}
	return 0;
}

inline void update() {  //更新所经过边的正向边权以及反向边权 
	int x=t;
	while(x!=s) {
		int v=pre[x];
		e[v].val-=dis[t];
		e[v^1].val+=dis[t];
		x=e[v^1].to;
	}
	ans+=dis[t];   //累加每一条增广路经的最小流量值 
}

int main() {
	scanf("%d%d%d%d",&n,&m,&s,&t);
	for(register int i=1;i<=m;i++) {
		scanf("%d%d%lld",&u,&v,&w);
		if(flag[u][v]==0) {  //处理重边的操作（加上这个模板题就可以用Ek算法过了） 
			add(u,v,w);
			flag[u][v]=tot;
		}
		else {
			e[flag[u][v]-1].val+=w;
		}
	}
	while(bfs()!=0) {  //直到网络中不存在增广路 
		update();
	}
	printf("%lld",ans);
	return 0;
}
```

------------
#### $Dinic$算法

$EK$算法每次都可能会遍历整个残量网络，但只找出一条增广路

是不是有点不划算？能不能一次找多条增广路呢？

答案是可以的：$Dinic$算法

- 分层图&$DFS$

根据$BFS$宽度优先搜索，我们知道对于一个节点$x$，我们用$d[x]$来表示它的**层次**，即$S$到$x$最少需要经过的边数。在残量网络中，满足$d[y]=d[x]+1$的边$(x,y)$构成的子图被称为**分层图**（相信大家已经接触过了吧），而分层图很明显是一张有向无环图

为什么要建分层图？

讲这个原因之前， 我们还要知道一点：**$Dinic$算法还需要$DFS$**

现在再放上第一张图，我们来理解

![](https://img2020.cnblogs.com/blog/2055990/202007/2055990-20200709150110449-380364997.png)

根据层次的定义，我们可以得出：

```
第0层：S
第1层：A、C
第2层：B、D
第3层：E、T
```
在$DFS$中，从$S$开始，每次我们向下一层次随便找一个点，直到到达$T$，然后再一层一层回溯回去，继续找这一层的另外的点再往下搜索

这样就满足了我们同时求出多条增广路的需求！

- $Dinic$算法框架

1. 在残量网络上$BFS$求出节点的层次，构造分层图

2. 在分层图上$DFS$寻找增广路，在回溯时同时更新边权

- 适用范围

时间复杂度：$O(n^2m)$，一般能够处理$10^4$~$10^5$规模的网络

相较于$EK$算法，显然$Dinic$算法的效率更优也更快：虽然在稀疏图中区别不明显，但在稠密图中$Dinic$的优势便凸显出来了（所以$Dinic$算法用的更多）

此外，$Dinic$算法求解二分图最大匹配的时间复杂度为$O(m\sqrt{n})$

- 代码$Code$

这份代码是本模板题的AC代码，但是使用到了$Dinic$算法的两个优化：**当前弧优化+剪枝**

```cpp
#include <bits/stdc++.h>
using namespace std;
const long long inf=2005020600;
int n,m,s,t,u,v;
long long w,ans,dis[520010];
int tot=1,now[520010],head[520010]; 

struct node {
	int to,net;
	long long val;
} e[520010];

inline void add(int u,int v,long long w) {
	e[++tot].to=v;
	e[tot].val=w;
	e[tot].net=head[u];
	head[u]=tot;
	
	e[++tot].to=u;
	e[tot].val=0;
	e[tot].net=head[v];
	head[v]=tot;
}

inline int bfs() {  //在惨量网络中构造分层图 
	for(register int i=1;i<=n;i++) dis[i]=inf;
	queue<int> q;
	q.push(s);
	dis[s]=0;
	now[s]=head[s];
	while(!q.empty()) {
		int x=q.front();
		q.pop();
		for(register int i=head[x];i;i=e[i].net) {
			int v=e[i].to;
			if(e[i].val>0&&dis[v]==inf) {
				q.push(v);
				now[v]=head[v];
				dis[v]=dis[x]+1;
				if(v==t) return 1;
			}
		}
	}
	return 0;
}

inline int dfs(int x,long long sum) {  //sum是整条增广路对最大流的贡献
	if(x==t) return sum;
	long long k,res=0;  //k是当前最小的剩余容量 
	for(register int i=now[x];i&&sum;i=e[i].net) {
		now[x]=i;  //当前弧优化 
		int v=e[i].to;
		if(e[i].val>0&&(dis[v]==dis[x]+1)) {
			k=dfs(v,min(sum,e[i].val));
			if(k==0) dis[v]=inf;  //剪枝，去掉增广完毕的点 
			e[i].val-=k;
			e[i^1].val+=k;
			res+=k;  //res表示经过该点的所有流量和（相当于流出的总量） 
			sum-=k;  //sum表示经过该点的剩余流量 
		}
	}
	return res;
}

int main() {
	scanf("%d%d%d%d",&n,&m,&s,&t);
	for(register int i=1;i<=m;i++) {
		scanf("%d%d%lld",&u,&v,&w);
		add(u,v,w);
	}
	while(bfs()) {
		ans+=dfs(s,inf);  //流量守恒（流入=流出） 
	}
	printf("%lld",ans);
	return 0;
}
```

- **当前弧优化**

对于一个节点$x$，当它在$DFS$中走到了第$i$条弧时，前$i-1$条弧到汇点的流一定已经被流满而没有可行的路线了

那么当下一次再访问$x$节点时，前$i-1$条弧就没有任何意义了

所以我们可以在每次枚举节点$x$所连的弧时，改变枚举的起点，这样就可以删除起点以前的所有弧，来达到优化剪枝的效果

对应到代码中，就是$now$数组

------------
#### 后序

终于写完了....现在来特别感谢一些：@那一条变阻器 对于使用$EK$算法过掉本题的帮助  以及  @取什么名字  讲解$Dinic$算法的$DFS$部分内容

如果本篇题解有任何错误或您有任何不懂的地方，欢迎留言区评论，我会及时回复、更正，谢谢大家orz！

------------



---

## 作者：AC_love (赞：65)

## 说明

本文是截至目前为止中文互联网对 ``vector`` 实现最大流算法介绍最详细的博客，如果您是初学网络流的 ``vector`` 党因为网上对 ``vector`` 实现网络流的介绍太少而为难，不妨来看看我的方法。

由于网上已经有很多教程了，所以我对最大流算法的原理不会有特别清楚的介绍，本文着重介绍网上没有教程的如何用 ``vector`` 实现最大流。

------------

## vector 的局限性

网络流题目中，``vector`` 的局限性主要体现在于：难以实现快速找到反向边。

本文将详细讲解如何消除 ``vector`` 的这种局限性。

------------

## 解决方案

那么 ``vector`` 怎么找反向边呢？

我们知道，一条反向边的起点是 st，终点是 ed 的话，按照常规储存方法，我们是这样存图的：

```cpp
struct edge
{
	int ed, len;
}
vector <edge> e[N];
```

此时我们发现，如果想要找到反向边的话，必须要遍历一遍 ``e[ed]`` 数组，这样做的最坏复杂度是 $O(m)$ 的。

这样的话我们就会在原有的时间复杂度上乘上一个 $m$，让 EK 算法的复杂度变成 $O(nm^3)$，Dinic 的复杂度变成 $O(n^2m^2)$，本来人家效率就低，你这么一搞简直变本加厉。

那么我们如何快速找到反向边呢？

我们不难想到，如果我们记录下反向边的存储位置为 ``id``，那么我们寻找反向边的时候只需要访问 ``e[ed][id]`` 就可以了，大大节约了我们的时间。

那么这个 ``id`` 的值应该是多少呢？

显然，当我们新加入一条边之前，``e[ed]`` 数组里存的数的个数为 ``e[ed].size()``，它们的下标从 `0` 到 `e[ed].size() - 1`，那么新存进来的数的下标一定就是 ``e[ed].size()``，所以 ``id`` 直接设为 ``e[ed].size()`` 即可。

代码实现：

```cpp
struct edge	{int ed, len, id;};
vector <edge> e[N];
```

加边：

```cpp
	while (m -- )
	{
		int st, ed, len;
		scanf("%lld%lld%lld", &st, &ed, &len);
		int sti = e[st].size();
		int edi = e[ed].size();
		e[st].push_back((edge){ed, len, edi});
		e[ed].push_back((edge){st, 0, sti});
	}
```

## 关于 EK 算法的 pre 数组

我们知道在链前实现 EK 算法的时候我们通常会开一个 ``pre`` 数组记录当前这个点是走哪条边跳过来的，在 ``vector`` 实现时，显然你光记录走哪条边跳过来的用处不大，关键还要知道从哪个点跳过来的。

所以不妨再开一个 ``lst`` 数组记录你是从哪个点跳过来的，代码实现如下：

```cpp
int lst[N], pre[N], d[N];
bool vis[N];

bool bfs()
{
	memset(vis, false, sizeof vis);
	queue <int> q;
	q.push(S);
	vis[S] = true;
	d[S] = INF;
	while (!q.empty())
	{
		int t = q.front();
		q.pop();
		for (int i = 0; i < e[t].size(); i = i + 1)
		{
			int cur = e[t][i].ed;
			if (!vis[cur] && e[t][i].len)
			{
				vis[cur] = true;
				d[cur] = min(d[t], e[t][i].len);
				lst[cur] = t;
				// lst 记录当前这个点是从第几个点跳过来的
				pre[cur] = i;
				// pre 记录当前这个点是从第几条边跳过来的
				if (cur == T)
					return true;
				q.push(cur);
			}
		}
	}
	return false;
}
```

然后是 EK 算法修改正向边和反向边边权的部分：

```cpp
int EK()
{
	int r = 0;
	while (bfs())
	{
		r += d[T];
		for (int i = T; i != S; i = lst[i])
		{
			e[lst[i]][pre[i]].len -= d[T];
			// 从 lst[i] 沿着 pre[i] 跳到 i 的边是正向边
			e[i][e[lst[i]][pre[i]].id].len += d[T];
			// 从 i 沿着 e[lst[i]][pre[i]].id 跳回 lst[i] 的边是反向边
		}
	}
	return r;
}
```

这个大致就是 EK 算法如何用 ``vector`` 实现。

完整代码可以参考：[点我查看](https://www.luogu.com.cn/paste/j9g1noit)

------------

## vector 实现 Dinic 算法

我们都知道，Dinic 算法和 EK 的最大的不同点在于每次可以增广多条路，而同时增广多条路就需要一个 ``dfs``，这样的话其实我们只要实现了 ``dfs`` 的部分，其他就可以用和 EK 一样的方式实现了。

``dfs`` 的部分和链前的部分几乎是一样的，唯一不同的是当前弧优化怎么实现。

这是链式前向星的当前弧优化：

```cpp
	for (int i = cur[st]; ~i; i = nxt[i])
	{
		cur[st] = i;  // 当前弧优化
		……
	}
```

我们发现，其实就是需要记录当前没有流满的是到哪个点的路径，那么同理到 ``vector``，我们发现也只要记录当前到没有流满的点的第一条路径即可：

```cpp
	for (int i = cur[st]; i < e[st].size(); i = i + 1)
	{
		cur[st] = i;  // 当前弧优化
		……
	}
```

其实大抵都是一样的，只要解决了找反边的问题，``vector`` 是很容易实现网络流的。

因为 Dinic 算法比较常用，我把 ``vector`` 实现 Dinic 算法的完整代码直接贴在下面：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 10010, M = 200010, INF = 1e15;

struct edge
{
	int ed;
	int len;
	int id;
};

vector <edge> e[N];

int n, m, S, T;
int dep[N], cur[N];

bool bfs()
{
	memset(dep, -1, sizeof dep);
	queue <int> q;
	q.push(S);
	dep[S] = 0;
	while (!q.empty())
	{
		int t = q.front();
		q.pop();
		for (int i = 0; i < e[t].size(); i = i + 1)
		{
			int ed = e[t][i].ed;
			if (dep[ed] == -1 && e[t][i].len)
			{
				dep[ed] = dep[t] + 1;
				q.push(ed);
			}
		}
	}
	memset(cur, 0, sizeof(cur));
	return (dep[T] != -1);
}

int dfs(int st, int limit)
{
	if (st == T)
		return limit;
	for (int i = cur[st]; i < e[st].size(); i = i + 1)
	{
		cur[st] = i;  // 当前弧优化
		int ed = e[st][i].ed;
		if (dep[ed] == dep[st] + 1 && e[st][i].len)
		{
			int t = dfs(ed, min(e[st][i].len, limit));
			if (t)
			{
				e[st][i].len -= t;
				e[ed][e[st][i].id].len += t;
				return t;
			}
			else
				dep[ed] = -1;
		}
	}
	return 0;
}

int dinic()
{
	int r = 0, flow;
	while (bfs()) while (flow = dfs(S, INF)) r += flow;
	return r;
}

signed main()
{
	cin >> n >> m >> S >> T;
	while (m -- )
	{
		int st, ed, len;
		cin >> st >> ed >> len;
		int sti = e[st].size();
		int edi = e[ed].size();
		e[st].push_back((edge){ed, len, edi});
		e[ed].push_back((edge){st, 0, sti});
	}
	cout << dinic();

	return 0;
}
```

完美，撒花

✿✿ヽ(°▽°)ノ✿

---

## 作者：_Fontainebleau_ (赞：65)

~~月赛打不下去了，于是来写这题的题解以提高估值~~

竟然没有 $ISAP$ 的题解？ $ISAP$ 是我大约一年前接触到的，那个时候是自己对照着[这个博客](https://www.luogu.com.cn/blog/ONE-PIECE/jiu-ji-di-zui-tai-liu-suan-fa-isap-yu-hlpp)自学的，~~受益匪浅~~。

有些人可能就会问了既然有 $dinic$ 了，为何还要有 $ISAP$ ？ 因为 $ISAP$ 更快，一般情况下毒瘤出题人也都不太会卡 $ISAP$ 。具体情况可以参考 [离散小波变换°巨佬的博客](https://www.luogu.com.cn/blog/McHf/p4722-network-flows-HLPP)的文末有各大最大流算法的效率对比。因为博客 $markdown$ 崩了，故这里给出原文中的表格

| 序号 | $ Dinic $|$ FF $| $EK$ |终极 $HLPP$ | $ISAP$  |
| -----------: | -----------: |-----------: |-----------: |-----------: |-----------: 
 1 |0.625s | TLE | 0.171s |0.125s| 0.265s | 
 2 | 0.562s | TLE | 0.156s | 0.093s | 0.265s | 
 3 | 0.828s | TLE | 0.625s | 0.093s | 0.390s | |
  4 | 0.578s | TLE | 0.312s | 0.093s | 0.328s | |
 5 | 2.468s | 24.000s | 0.046s | 0.078s | 0.218s | |
 6 | 5.546s | TLE | 0.078s | 0.140s | 0.203s | |
 7 | 5.218s | 10.984s | 0.109s | 0.125s | 0.328s | |
  8 | 7.812s | 49.953s | 0.218s | 0.109s | 0.265s | |
   9 | 1.281s | TLE | 0.375s | 0.078s | 0.375s | |
  10 | 0.781s | TLE | 0.156s | 0.062s | 0.187s | |
 11 | 0.312s | TLE | 0.046s | 0.093s | 0.203s | |
 12 | 0.875s | TLE |2.703s | 0.078s | 0.328s | |
 13 | 0.703s | TLE | 0.156s | 0.156s | 0.203s | |
  14 | 0.500s | TLE |0.328s | 0.109s | 0.218s | |
  15 |0.296s |TLE | 0.171s | 0.109s | 0.296s | |
 16 | 0.562s | TLE | 0.234s | 0.125s | 0.296s | |
 17 | 4.687s | TLE | 0.140s | 0.093s | 0.343s | |
  18 | 2.921s | TLE | 0.031s | 0.156s | 0.296s | |
 19 | 2.359s | TLE | 0.040s | 0.078s | 0.312s | |
 20 | 4.656s | TLE | 0.078s | 0.062s | 0.390s | |
 21 | 0.500s | TLE | 0.312s | 0.093s | 0.218s | |
  22 |1.000s | TLE | 0.203s | 0.109s | 0.234s | |
   23 | 0.343s | TLE | 0.062s | 0.156s | 0.265s | |
 24 | 1.015s | TLE | 0.281s | 0.140s | 0.328s | 
 | 总用时 |46.428s|-| 7.037s|2.553s|6.754s|
 
 我们发现除去$HLPP$，$ISAP$ 吊打全场。
 
 下面就来听我讲解 $ISAP$ 。
 

------------
$\texttt{ISAP(Improved Shortest Augumenting Path)}$

在 $dinic$ 中，我们要跑许多遍 $bfs$ ，这就有可能导致算法效率不高。

于是 $ISAP$ 就这样出现了，它只需要跑一遍 $bfs$ !

大体运行过程如下：

$·\texttt{1.从t(汇点)到s（源点）跑bfs }$

$·\texttt{2.从s到t跑dfs}$

$·\texttt{3.重复操作2直到出现断层}$

可能看到这大家都有点懵，心中有许多问号，没关系，下面来介绍原理。

$ISAP$ 只跑一遍 $bfs$ 标记深度，然后每个点都会随着一次次 $dfs$ 而变高。

这样我们需要引进 $gap$ 数组， $gap[i]$ 表示高度为 $i$ 的点的个数。显而易见，当 $gap[i]=0$ 时会出现断层，也就是 $s$ 和 $t$ 不再联通，我们也就可以直接退出程序，停止寻找。

下面则是**重点**

我们从终点向起点跑完 $bfs$ 得到最初的高度。但是我们发现，此时还剩下一些流，那么我们将其高度提高，下一次遍历时，就可以把这个流推给其他边。

当然这个算法也可以当前弧优化，因为作者时间关系，后续更新。
先放出裸的 $ISAP$ (这个代码里的注释是我一年前写的，有些繁琐，还请原谅)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=2147483647;//inf:最大值 
int cnt=1,head[505];//cnt:第CNT条边head[i]:第i个点属于第几条边 
int n,m,s,t;//n个点m条边s:源点t:汇点 
inline int Read()
{
    int x=0;
    char c=getchar();
    while(c>'9'||c<'0')c=getchar();
    while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
    return x;
}
struct Node
{
    int v;//当前点 
    int next;//连接点 
    int val;//容量 
}node[100010];//node[i]:第i条边的情况 
inline void addedge(int u,int v,int val)
{
    node[++cnt].v=v;
    node[cnt].val=val;
    node[cnt].next=head[u];
    head[u]=cnt;
}
int dep[505],gap[505];//dep[i]表示节点i的深度，gap[i]表示深度为i的点的数量 
void bfs()//倒着搜 
{
    memset(dep,-1,sizeof(dep));//把深度变为-1(0会导致gap崩坏) 
    memset(gap,0,sizeof(gap));
    dep[t]=0;//汇点深度为0 
    gap[0]=1;//深度为0的点有1个 
    queue<int>q; 
    q.push(t);//t点入栈 
    while(!q.empty())
	{
        int u=q.front();
        q.pop();
        for(int i=head[u];i;i=node[i].next)//head[u]:u点所在的边,node[i].next:u点所在的边的下一个点，就这样遍历下去 
		{
            int v=node[i].v;//v为当前边的下一个点 
            if(dep[v]!=-1)	continue;//dep[v]!=-1相当于v点已被遍历||不管 
            q.push(v);
            dep[v]=dep[u]+1;//v点的深度比u点大1 
            gap[dep[v]]++;
        }//直到所有点都被遍历过 
    }
    return;
}//从t到s跑一遍bfs，标记深度
long long maxflow;
int dfs(int u,int flow)
{
    if(u==t)
	{
        maxflow+=flow;
        return flow;
    }
    int used=0;
    for(int i=head[u];i;i=node[i].next)//head[u]:u点所在的边,node[i].next:u点所在的边的下一个点，就这样遍历下去 
	{
        int d=node[i].v;
        if(node[i].val&&dep[d]+1==dep[u])//如果这条边的残量大于0,且没有断层 
		{
            int mi=dfs(d,min(node[i].val,flow-used));
            if(mi){
                node[i].val-=mi;
                node[i^1].val+=mi;
                used+=mi;
            }
            if(used==flow)return used;
        }
    }
    //如果已经到了这里，说明该点出去的所有点都已经流过了
    //并且从前面点传过来的流量还有剩余
    //则此时，要对该点更改dep
    //使得该点与该点出去的点分隔开
    --gap[dep[u]];
    if(gap[dep[u]]==0)dep[s]=n+1;//出现断层，无法到达t了
    dep[u]++;//层++ 
    gap[dep[u]]++;//层数对应个数++
    return used; 
}
long long ISAP()
{
    maxflow=0;
    bfs();
    while(dep[s]<n)	dfs(s,inf);//每走一遍增广路,s的层数会加1,如果一直没有出现断层,最多跑n-dep(刚bfs完时s的深度)条增广路共有n个点 
    return maxflow;
}
int main()
{
    n=Read(),m=Read(),s=Read(),t=Read();
    int u,v,w;
    for(int i=1;i<=m;i++)
	{
		u=Read();
		v=Read();
		w=Read();
		addedge(u,v,w);//正向边 
		addedge(v,u,0);//反向边 
	}  
    printf("%lld\n",ISAP());
    return 0;
}
```
### update 2020.8.9

$\texttt{ISAP の 当前弧优化}$

$\texttt{Attention:}$ 前文的代码是作者去年写的，后文当前弧优化的代码则是今天写的，故数组定义名称有所区别，并且由结构体存边改为数组存边，还请读者原谅。原先代码中的 $head$ 数组是这个下文的 $h$ 数组 $node[i].v$ 对应 $t[i]......$ 

具体原理和 $dinic$ 一样，随着 $dfs$ 而改变。我们每次找到一条边时，就把当前节点（$dfs$ 中的 $u$ ）对应的 $cur$ 修改为这条边的编号。那么下次遍历到 $u$ 点时，就直接从 $cur[u]$ 开始（也就是说从 $h[u]$ 到 $cur[u]$ 这一段直接不管）。

为什么这一定是正确的呢？

当我们 $dfs$ 时先被遍历的边必然已经增广或无法继续增广，这样的边什么用都没有，~~除了浪费程序运行时间~~，故下次再遍历当前节点时，就可以直接跳过没用的点边，这样可以节省一些时间。

![](https://s1.ax1x.com/2020/08/09/aTV5DK.png)

↑ $1.$ 当前弧优化 $2.$ 普通 $ISAP$

下面放出关键部分代码
```cpp
int dfs(int u,int flow)
{
	if(u==T)
	{
		maxflow+=flow;
		return flow;
	}
	int used=0;
	for(int p=cur[u];p;p=nxt[p])
	{
		cur[u]=p;//更新当前弧
		int v=t[p];
		if(val[p]&&dep[v]+1==dep[u])
		{
			int mi=dfs(v,min(flow-used,val[p]));
			if(mi)
			{
				val[p]-=mi;
				val[p^1]+=mi;
				used+=mi;
			}
			if(used==flow)	return used;
		} 
	}
	if(--gap[dep[u]]==0)	dep[s]=n+1;
	dep[u]++;
	gap[dep[u]]++;
	return used;
}
inline long long ISAP()
{
	maxflow=0;
	bfs();
	while(dep[s]<n)	memcpy(cur,h,sizeof(h)),dfs(s,INF);
	return maxflow;
}
```
❀完结撒花❀


---

## 作者：Shiroko (赞：18)

~~看着普通版没有预流推进就来水一发题解~~

~~如果觉得我讲的不好还请移步[这里](https://www.luogu.com.cn/problem/solution/P4722)~~

~~由于这是直接从[最大流 加强版 / 预流推进](https://www.luogu.com.cn/problem/P4722)的代码改过来的~~

~~所以加上了各种奇奇怪怪的优化~~

~~在正式开始之前再bb一句：~~

~~```auto``` yyds!~~

## 预流推进程序框架

### 预流推进主程序：

1. 重置点高度 （源点为n，其余为0）
	
    重置迭代器、点集
    
    重置gap数组
    
    重置超额流
    
    （源点超额流无限大，汇点无限小）

2. 从源点推流

3. 全局重贴标签

4. 遍历桶排数组并推流

	（桶排数组为原预流推进算法中使用的优先队列的改进，
    
    可以O(1)读取每个点）

### 全局重贴标签：

1. 重置点高

	（汇点为0，其余为n，即不再当前网络内）
    
    重置gap数组
    
2. 从汇点开始反向广搜

3. 重置桶排数组、点集

4. 把在网络中的点加入其高度对应的点集

	若有超额流就同时加入桶排数组
    
5. 设置最高高度与当前推流高度

### 推流函数：

1. 遍历当前点所有的边并且尽可能推流

	如果当前边所连接的点高度过低
    
    更新最低可行的高度

2. 如果当前高度下只有一个点

	（由于程序能够运行到这里，
    
    所以这意味着当前点无法推出所有超额流，
    
    因此所有比当前点高的点都无法再推流）
    
    将比当前高度高的所有点都移出网络
    
    更新最高高度
    
3. 如果当前高度下不止一个点

	更新当前点的新高度
    
    更新最高高度
    
    对当前点重新推流

以上是对对预流推进的算法框架的大致介绍

具体算法细节在代码中有进一步的注释

~~码风怪异 请勿在意~~

```cpp
#include<bits/stdc++.h>
#define int long long
//《关于加强版不卡longlong而普通版卡longlong的这件事》
using namespace std;

const int INF = 9223372036854775807;

int n, m, s, t, highest, now_height, tmp, u, v, w;

struct Edge
{
	int next, targ, wght;
    //next指向当前边对应的反向边 targ是当前边指向的目标点 wght是当前边的权值
	Edge(int N, int T, int W) :next(N), targ(T), wght(W) {}
};

vector<list<int>::iterator>it;//it[i]是对应h[i]的迭代器

vector<Edge>head[120005];//邻接表存边

vector<int>l, gap, ph, bs[1205];
//l是超额流 gap是优化用数组 ph是点的高度 bs是桶排数组

queue<int>q;

list<int>h[120005];
//h是一个高度所对应的点集

void add(int u, int v, int w)//正反存边
{
	head[u].push_back(Edge(head[v].size(), v, w));
	head[v].push_back(Edge(head[u].size() - 1, u, 0));
}

void relabel()//重贴标签(全局版本)
{
	ph.assign(n + 5, n);//初始化ph(每个点的高度),全部设为n
	gap.assign(n + 5, 0);//初始化gap(存每个高度有多少点)
	ph[t] = 0;//汇点高度设为0
	q.push(t);//汇点入队 反向搜索并初始化高度
	while (!q.empty())
	{
		tmp = q.front();
		q.pop();
		for (auto p = head[tmp].begin(); p != head[tmp].end(); p++)//遍历当前点的所有反向边
			if (ph[p->targ] == n && head[p->targ][p->next].wght)//如果目标点无高度且两者之间连接
			{
				gap[ph[p->targ] = ph[tmp] + 1]++;//重设目标点高为当前高度+1 并且gap数组++
				q.push(p->targ);//目标点入队
			}
	}
	for (int i = 1; i <= n; i++)//初始化
	{
		bs[i].clear();
		h[i].clear();
	}
	for (int i = 1; i <= n; i++)
		if (ph[i] < n)//如果当前点在网络中
		{
			it[i] = h[ph[i]].insert(h[ph[i]].begin(), i);//将当前点加入其高度所对应的点集,更新迭代器
			if (l[i])//如果当前点还有超额流
				bs[ph[i]].push_back(i);//加入推流用的桶数组
		}
	highest = (now_height = ph[tmp]);
    //设置最高高度和当前高度 这里的tmp是广搜中最后弹出的点 显然它的高度是最高的
}

void push(int u, Edge& e)//push子函数
{
	int v = e.targ, df = min(l[u], e.wght);
	e.wght -= df;//更新当前边上流的大小
	head[v][e.next].wght += df;//更新目标边上流的大小
	l[u] -= df;//当前点超额流减少
	l[v] += df;//目标点超额流增加
	if (l[v] && l[v] <= df)//如果当前点原先无超额流
		bs[ph[v]].push_back(v);//加入推流用桶数组
}

void push(int u)//对点u进行推流
{
	int new_height = n, u_height = ph[u];
	for (auto p = head[u].begin(); p != head[u].end(); p++)
		if (p->wght)//如果当前边还有余流
		{
			if (ph[u] == ph[p->targ] + 1)//如果高度能够流
			{
				push(u, *p);//推流
				if (l[u] <= 0)//如果当前点无超额流
					return;//直接结束
			}
			else//如果不能流
				new_height = min(new_height, ph[p->targ] + 1);//更新当前点的最低新高度
		}
    //代码如果能够执行完for循环到达if 就说明此时当前点无法推完所有流 必须更新点的高度
	if (gap[u_height] == 1)//如果没有与当前点的高度相同的点
	{
		for (int i = u_height; i <= highest; i++)//遍历高度比当前点高的点
			for (auto p = h[i].begin(); p != h[i].end(); p++)//弹掉所有点
			{
				gap[ph[*p]]--;//gap--
				ph[*p] = n;//把点移出网络
			}
		highest = u_height - 1;//更新最高高度为当前点高度-1
	}
	else//如果有
	{
		gap[u_height]--;//把当前点移出gap
		it[u] = h[u_height].erase(it[u]);//把当前点移出它对应的点集
		ph[u] = new_height;//更新当前点的高度
		if (new_height == n)//点可能被移出网络
			return;
		gap[new_height]++;//把当前点移回gap
		it[u] = h[new_height].insert(h[new_height].begin(), u);//把当前点移回它现在对应的点集
		highest = max(highest, now_height = new_height);//更新最高高度
		bs[new_height].push_back(u);//把当前点重新加入推流桶数组
	}
}

int HLPP()
{
	now_height = highest = 0;
	ph.assign(n + 5, 0);//重置点高
	ph[s] = n;//设源点高度为n
	it.resize(n + 5);//重置迭代器
	for (int i = 1; i <= n; i++)
		if (i != s)
			it[i] = h[ph[i]].insert(h[ph[i]].begin(), i);//把迭代器与点集对应
	gap.assign(n + 5, 0);//重置gap
	gap[0] = n - 1;//当前高度为0的有n-1个（即除源点之外的点）
	l.assign(n + 5, 0);//重置超额流
	l[s] = INF;//设源点有无限大的超额流
	l[t] = -INF;//保证汇点不会溢出
	for (auto p = head[s].begin(); p != head[s].end(); p++)//从源点开始推流
		push(s, *p);
	relabel();//全局重贴标签
	for (int i; now_height;)
	{
		if (bs[now_height].empty())//如果当前高度的所有点遍历完了就降到下一个高度
			now_height--;
		else
		{
			i = bs[now_height].back();//按顺序推流
			bs[now_height].pop_back();
			push(i);
		}
	}
	return l[t] + INF;//防溢出写法
}

signed main()
{
	cin >> n >> m >> s >> t;
	for (int i = 1; i <= m; i++)
	{
		cin >> u >> v >> w;
		add(u, v, w);
	}
	cout << HLPP();
}
```

本人对预流推进的理解全靠啃原题解的代码

所以对某些语句的实际意义解读可能有误

求dalao轻喷（

---

## 作者：pitiless0514 (赞：7)

### 前言
最近在学习网络流这些，于是切了此题，并打算写题解。当然，如果你像完整的学习一遍网络流，建议去[这里](https://www.bilibili.com/video/av21945401/)学习，讲的很好。然后，这是一份**Dinic**的题解。

### 网络流定义

-  定义$1$：

对于一个图$G = (V,E)$也就是有$V$个点，$E$条边组成的一个有向图，它的每条边$(u,v) \in E$都有一个权值，这个权值我们称其为容量$c(u,v)$，对于$(u,v) \not \in E$的容量$c(u,v) = 0$。

- 定义$2$：

对于每条边上，还可以有一个值为可以从这条边流过去的权值，记作净流$f(u,v)$。

- 容量限制：
$f(u,v) \leq c(u,v)$
       **一条边能流过去的量不会超过他的容量**。
       
    
    
       
       
 -  剩余流量：
 
 指一条边上$c(u,v)-f(u,v)$的值。
 
       
- 增广路：

若一条从$S$到$T$的路径上所有边的剩余容量都大于$0$，这样的路叫增广路。

 - 流守恒：
 
 除非$u=s$或 $u=t$，否则 $∑w∈V f(u,w)=0$一结点的净流是零，除了“制造”流的源点和“消耗”流的汇点。
 - 斜对称：
 
 $f(u,v)$ $= - f(v,u) $由 $u$到 $v$的净流必须是由 $v$到 $u$的净流的相反。
 - 残量网络:
 
 在**任意时刻**，网络中所有节点以及剩余容量大于$0$的边构成的子图被称为残量网络

 当然，其实你只需要把前五个知道了就行了。
###  Dinic算法
首先你需要知道$EK$算法，如果不知道去看[这篇博客](https://www.luogu.com.cn/blog/ONE-PIECE/wang-lao-liu-di-zong-jie)。

我们都知道，我们的$EK$算法是去找增广路然后计算的，但是$EK$算法每轮遍历整个残量网络，最终却只找出一条增广路，这样有点慢，而$Dinic$算法则是对EK算法的优化，**一次找多条增广路**。
那么怎么实现呢？
方法如下：
>- $BFS$求出每个节点的层次$d[x]$表示的为源点$S$到$X$这个点最少要用的边数，构造分层图
>- 在分层图上面去$DFS$寻找增广路，在回溯时更新剩余的容量。然后进行答案的统计就完了。
#### add和定义的代码
```cpp
int n,m,s,t,num=1,nex[N],first[N],v[N],flow[N],no[N];
//注意我是把num初始化为了1，因为我们在dfs中要用到反边，为了利用异或的成对变换性，则设num初始就为1.
void add(int from,int to,int V){
	nex[++num]=first[from];
	first[from]=num;
	v[num]=to;
	flow[num]=V;
}
```

#### BFS的代码
```cpp
bool bfs(int s,int t){//从s点到t点
	memset(dep,0,sizeof(dep));//首先初始化dep数组
	q[1]=s;//入队
	dep[s]=1;//初始化深度
	no[s]=first[s];//定义一个和first数组值一样的数组，后面dfs可以剪枝用
	int head=0,tail=1;
	while(head!=tail){
		int u=q[++head];
		for(int i=first[u];i;i=nex[i]){
			int to=v[i];
			if(flow[i] && !dep[to]){//如果当前的剩余流量不会0，且深度为0
				no[to]=first[to];
				dep[to] = dep[u] + 1;
				q[++tail] = to;
			}
		}
	}
	return dep[t]!=0;
}
```
#### DFS的代码
```cpp
int dfs(int now,int fl){
	if(now==aim) return fl;//到了就返回
	int f=0;
	for(int i=no[now];i&&fl;i=nex[i]){
		no[now]=i;//弧度优化
		int to=v[i];
		if(flow[i] && dep[to] == dep[now]+1){
			int x=dfs(to,min(fl,flow[i]));
			flow[i]-=x;
			flow[i^1]+=x;//反边加上x，反悔用
			fl-=x;
			f+=x; 
		}
	}
	if(!f) dep[now]=-2;//炸点优化，如果这里已经不行了，那后面都不行了，减去冗杂的搜索
	return f;
}
```
注意开始$fl$的值你要赋值无穷大，因为最后你到达时能留的是你路径上剩余流量最小的那么多流量。

### 后记
就完结了，然后见图中反边初始化为$0$，就不用说了吧，顺便说一句$Dinic$复杂度上界是$O(n^2m)$，但实际远远达不到这里，可以通过很多点的数据，然后而分图什么的应用就不提了，蒟蒻不会$qAq$

---

## 作者：langmouren (赞：6)

# vector 版网络流
## 前言
本篇题解参考了 AC_love 的文章和部分 CSDN 文章。

本文章主要介绍 vector 如何应用于网络流，基本概念介绍并不详细，建议阅读其他更详细的题解。
## 基本概念介绍
### 介绍

- 源点和汇点：一张图中特殊的两个点。
- 流量：边上的一个权值。
- 最大流：从源点到汇点，给每条边指定合适的流量 $f$，使得总流量最大。
- 残余流量：统计一次源点到汇点的流量之后剩下的流量。

我们发现，如果按照**贪心**的思路，一个边能选多少就选多少，有可能会在后续流量耗尽，导致不是最大流，所以我们引入了反边。

### 反边
反边的初始流量为 $0$，它的连接方向和正边相反且一一对应（一个正边一定对应一个反边），当正边消耗流量的时候，给反边加上对应流量。

搜索的时候走过反边，就会减少反边流量增加正边流量，起到类似“反悔”的效果，这样子就避免了普通贪心的不足。

### 判断是否还有残余流量
从源点开始 BFS，如果连向的点没有被访问过且还有流量就加入队列，最后判断汇点是否被访问过。

## 加边
vector 的难点是，其相对于链式前向星难以找到反边，所以我们应该为其找到一个 $id$ 进行标记，用什么来记录这个 $id$ 呢？答案是——数组大小！

我们约定 vector 数组 `vector<Node> v[MN]`。

可以发现，对于两个点 $a、b$，我们在从 $a$ 连向 $b$ 的时候存下 $b$ 的数组大小 $id$，再从 $b$ 连向 $a$，则 $b$ 连向 $a$ 这条边的下标就是 $id$，即 `v[b][v[a].id]` 就是 $b$ 到 $a$ 的边。

所以，我们可以写出 vector 加边的代码：

```cpp
void add(int a,int b,int k){
    int sza=v[a].size(),szb=v[b].size();
    v[a].push_back({b,k,szb});
    v[b].push_back({a,0,sza});
}
```

同时，我们也知道了，vector 的结构体中需要存储连向的边、流量、$id$ 三个内容。

## 增减流量
由上个板块可知，可以使用

```cpp
v[x][i].k-=tmp;
v[y][v[x][i].id].k+=tmp;
```

对一条边及其反边进行修改。

## 当前弧优化
vector 的下标从 $0$ 开始，我们可以将当前弧优化的数组 $cur$ 初始化为 $0$，在搜索的时候使用 `for(int i=cur[x];i<v[x].size();i++)`。

## 代码
请访问[洛谷剪切板](https://www.luogu.com.cn/paste/doi0588f)。

如果无法访问，也可以选择[洛谷保存站](https://www.luogu.me/paste/doi0588f)。

---

## 作者：Poetic_Rain (赞：6)


------------
## 网络流

那么做这道模板题之前还是先了解一下网络流到底是个什么吧（因为我也是个初学者，如果有讲错或者不清楚的地方可以评论或者在其他dalao的题解或是博客中学习）

对于一个**网络** $G=(V,E)$ 是一个**有向图**，每一条边有一个边圈 $c(x,y)$ 表示这条边的**容量**，你可以把它想象成一个下水道系统（？？？），每一条边都是一个管道，每个管道有自己允许流通的水的**最大值**。对于两个特殊节点， $S$ 和 $T$ （$S$ ≠ $T$），如果有 $S\in G$ 且 $T\in G$，称$S$为**源点**， $T$ 为**汇点**，所有水从 $S$ 流向 $T$

形如以下这个图：
![](https://img2020.cnblogs.com/blog/2055991/202007/2055991-20200709151012458-2121003297.png)

那么 $S->A->B->T$ 就是该网络的一个流，这个流的流量为2（该路径上的最小的容量）

那么对于这个流量，应该如何定义呢？我们引入一个流函数（摘自李煜东的《算法进阶》）

$f(x,y)$为定义在节点二元组（$x$∈$V$,$y$∈$V$）上的实数函数，满足：

1. $f(x,y)$ ≤ $c(x,y)$
2. $f(x,y)$ ＝ $-f(y,x)$
3. $\forall$ $x$≠$S$，$x≠T$, $\sum_{(u,x)∈E }f(u,x)=\sum_{(x,v)∈E }f(x,v)$

$f$称为该网络的流函数，对于$(x,y)$∈$E$,$f(x,y)$为边的流量，$c(x,y)-f(x,y)$为该边的剩余容量

这三条性质分别为**容量限制**，**斜对称**和**流量守恒**。其中流量守恒告诉我们只有源点和汇点才会存储流，其流入总量等于流出总量



------------

## 最大流

对于一个网络，有很多的流函数$f$都是合法的，那么使得整个网络的$\sum_{(S,v)∈E }f(S,v)$最大的流函数称为该网络的**最大流**，此时的流量为该网络的**最大流量**

那么求这个最大流，我会讲解 **Edmonds-Karp**增广路算法 和 **Dinic**算法，当然还有**ISAP**和**HLPP**等更加高效的算法，因为蒟蒻不太会，这里就不介绍，如果学会了会更新的

### **Edmonds-Karp**增广路算法

时间复杂度：$O(nm^2)$

先介绍一下**增广路**是个什么：对于 $S$ 到 $T$ 的一条路径，如果路径上各边的剩余容量大于0，则这一条路径就是一条增广路

那么仔细一想，如果当前网络中还存在着那么一条增广路，那么说明我的流量还可以更大（见增广路的定义和剩余容量的定义），那么EK算法的核心思想就是不断地寻找增广路，直到无法找出最广路之后，说明找出了网络中的最大流

那么注意在实现寻找增广路时，我们可以用广搜实现，这样就可以保证找到每一条增广路

在找到一条增广路时，路径上的容量应该减去这条增广路的流量，那么在处理这个东西之后就会影响到其它增广路，这个时候建反向边加上减去的流量，就可以起到一个反悔的作用

那么整个的模拟过程如下（从左往右看）：

![](https://img2020.cnblogs.com/blog/2055991/202007/2055991-20200709161656022-1126516460.png)

那么我们就可以写出来第一份程序了

```
#include<bits/stdc++.h>
using namespace std;
const int MAXN=50000;
const int INF=2147483649; //记得初始值写大点 
int n,m,s,t;
struct node{
	int net,to,w;
}e[MAXN];
int head[MAXN],tot=1;//注意这里是1，其实-1也行，看个人爱好 
void add(int x,int y,int z){
	e[++tot].net=head[x];
	e[tot].to=y;
	e[tot].w=z;
	head[x]=tot;
}
//领接表存边 
int ans;
int bian[MAXN],minn[MAXN]; //bian是用来记录路径的，minn表示增广路上各边的最小剩余容量 
bool v[MAXN];
bool bfs(){
	for(register int i=1;i<=n;i++) v[i]=false;
	queue<int>q;
	q.push(s);
	v[s]=true;
	minn[s]=INF;
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(register int i=head[x];i;i=e[i].net){
			if(e[i].w!=0){ //不为0才走 
				int y=e[i].to,z=e[i].w;
				if(v[y]==true) continue; //增广路走过就不管了 
				minn[y]=min(minn[x],z);  
				bian[y]=i;
				v[y]=true;
				q.push(y);
				if(y==t) return true; //可以到达汇点 
			}
		}
	}
	return false;
}
void update(){
	int x=t;
	while(x!=s){
		int i=bian[x];
		e[i].w-=minn[t]; //正向边-
		e[i^1].w+=minn[t]; //反向边+ 
		x=e[i^1].to;
	}
	//这个异或1其实非常的秒
	//因为之前在存储边的时候，是直接正向反向一起存
	//所有反向边=正向边+1
	//一个偶数异或1=偶数+1
	//一个奇数异或1=奇数-1 
	ans+=minn[t]; //更新答案 
}
int main(){
	scanf("%d%d%d%d",&n,&m,&s,&t);
	for(register int i=1;i<=m;i++){
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z); //有向边存储 
		add(y,x,0); //先存一个边权为0的反向边，有用 
	}
	while(bfs()==true) update(); //不断更新增广路 
	printf("%d",ans); //答案 
	return 0;
}
```

TLE的那两个点其实是因为有太多的重边，那么其实对于重边，我们只需要将重边累加，也可以AC的（@那一条变阻器，他用vector这么过的）

```
#include <bits/stdc++.h>
using namespace std;
int n,m,s,t,u,v;
int w,ans,dis[520010];
int tot=1,vis[520010],pre[520010],head[520010],flag[2510][2510];

struct node {
	int to,net;
	int val;
} e[520010];

inline void add(int u,int v,int w) {
	e[++tot].to=v;
	e[tot].val=w;
	e[tot].net=head[u];
	head[u]=tot;
	e[++tot].to=u;
	e[tot].val=0;
	e[tot].net=head[v];
	head[v]=tot;
}

inline int bfs() {
	for(register int i=1;i<=n;i++) vis[i]=0;
	queue<int> q;
	q.push(s);
	vis[s]=1;
	dis[s]=2005020600;
	while(!q.empty()) {
		int x=q.front();
		q.pop();
		for(register int i=head[x];i;i=e[i].net) {
			if(e[i].val==0) continue;
			int v=e[i].to;
			if(vis[v]==1) continue;
			dis[v]=min(dis[x],e[i].val);
			pre[v]=i;
			q.push(v);
			vis[v]=1;
			if(v==t) return 1;
		}
	}
	return 0;
}

inline void update() {
	int x=t;
	while(x!=s) {
		int v=pre[x];
		e[v].val-=dis[t];
		e[v^1].val+=dis[t];
		x=e[v^1].to;
	}
	ans+=dis[t];
}

int main() {
	scanf("%d%d%d%d",&n,&m,&s,&t);
	for(register int i=1;i<=m;i++) {
		scanf("%d%d%d",&u,&v,&w);
		if(flag[u][v]==0) {
			add(u,v,w);
			flag[u][v]=tot; //用一个数组记录这一条边 
		}
		else {
			e[flag[u][v]-1].val+=w; //累加重边 
		}
	}
	while(bfs()!=0) {
		update();
	}
	printf("%d",ans);
	return 0;
}

```

### **Dinic**算法

时间复杂度： $O(n^2m)$

相对于之前EK算法来说，在稀疏图中的表现其实是差不多的，但是在稠密图中就快很多了

讲Dinic之前，我们不妨再引入一个东西：**残量网络**。任意时刻，在网络中所有节点以及剩余容量大于0的边构成的子图叫做残量网络。在EK算法中，每轮BFS会遍历整个残量网络，但只更新一条增广路，这就浪费了很多时间，就需要用Dinic算法了

我们设一个 $d[x]$ 表示 $x$ 的层次，如果满足$d[y]=d[x]+1$ 的边$(x,y)$，则它是一个分层图，是一个有向无环图

为什么用Dinic会更优呢，我们先用BFS求出每一个节点的深度，在分层图上DFS只去寻找到下一层的边，每一次找出多条增广路，这样就会快很多

这其中还会涉及一个**当前弧优化**，就是在更新第$i$条边时，前面$i-1$条边到汇点的流已经流满并且没有路可以走了，可以不去更新，我们记录一下就可以了，不需要重新去跑之前的边

至于实现的方法，直接在代码中讲解好了：

```
#include<bits/stdc++.h>
using namespace std;
const int INF=2147483;
const int MAXN=50000;
int n,m,s,t;
struct node{
	int net,to;
	int w;
}e[MAXN];
int head[MAXN],tot;
void add(int x,int y,int z){
	e[++tot].net=head[x];
	e[tot].to=y;
	e[tot].w=z;
	head[x]=tot;
}
int de[MAXN]; //存储每一个点的层次 
int now[MAXN];//这个now可以暂时看为head的一个副本，所有值都一样 

bool bfs(){
	queue<int>q;
	for(register int i=1;i<=n;i++) de[i]=INF;
	q.push(s);
	de[s]=0;
	now[s]=head[s]; //充分发挥一个作为副本的作用 
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(register int i=head[x];i;i=e[i].net){
			int y=e[i].to,z=e[i].w;
			if(z!=0&&de[y]==INF){ //如果当前边可以走且还没找过 
				q.push(y);
				now[y]=head[y];
				de[y]=de[x]+1; //更新层次 
				if(y==t) return true;
			}
		}
	}
	return false;
	//其实和EK的BFS差不了多少的 
}

int dfs(int x,int liu){ 
	if(x==t) return liu; //直接返回 
	int k,ans=0; //k是当前最小的剩余容量，
	for(register int i=now[x];i&&liu;i=e[i].net){
		now[x]=i;//当前弧优化 
		int y=e[i].to;
		if(e[i].w!=0&&(de[y]==de[x]+1)){
			k=dfs(y,min(liu,e[i].w)); //比较出一条更小的 
			if(!k) de[y]=INF;   //剪枝，去掉增广后的点 
			e[i].w-=k;
			e[i^1].w+=k; //正向反向更新 
			ans+=k; //流出去的流量和 
			liu-=k; //剩余流量减少 
		}
	}
	return ans;
}
int main(){
	scanf("%d%d%d%d",&m,&n,&s,&t);
	tot=1;
	for(register int i=1;i<=m;i++){
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
		add(y,x,0);
	}
	int maxx=0; //最大流 
	while(bfs()) maxx+=dfs(s,INF);//记录答案 
	printf("%d",maxx);
	return 0;
}
```

感谢一下@那一条变阻器和@取什么名字 两个大佬的指点，当然还有其他题解（因为我最开始自己也不会编啊~~~）

---

## 作者：LEWISAK (赞：4)

### 基本定义

1. 定义名词“网络”为 $G=(V,E)$，其中 $V$ 是点集， $E$ 为边集。
2. 对于一条边 $u\to v$，$c(u,v)$ 为其容量，$f(u,v)$ 为其流量，**流量必须不大于容量**。
3. 对于 $G=(V,E)$，令 $s\in V$ 为其**源点**， $t\in V$ 为其**汇点**。
4. 特殊地，$s$ 无入度， $t$ 无出度。
5. 对于任意点 $u\in V$，定义其净流量为所有流入减所有流出。
6. **流守恒**：对于除了 $s$ 或 $t$ 的任意点，其净流量为 $0$。
7. 定义一个点的**剩余流量**为其容量减流量。
8. 定义剩余流量不为 $0$ 的边组成的图为**残留网络**。
9. 对于 $G=(V,E)$，其整张网络的流为源点流出的量。

## 最大流

### 定义

1. **增广路**：注意到只要残留网络中只要有一条 $s\to t$ 的路径，就可以对路径上的流量都增加而不违背流守恒与流量不大于容量的限制，这条路就叫增广路。

2. **反向边**：注意到如果我们单纯找到增广路就增广显然是一个伪的贪心，所以考虑让其能自然地反悔。

   我们令 $u\to v$ 的反向边 $v\to u$ 的 $f(v,u)=-f(u,v),c(v,u)=0$，于是正向边剩余流量的减少就是反向边流量的增加，反之亦然。

   不难发现**反向边的增广**就能**抵消正向边的操作**，并且**只要进行增广**，**图的流肯定会变大**，于是就可以通过反向边的思路求最大流。

这里挂一张 OIwiki 的图：

   ![img](https://oi-wiki.org/graph/flow/images/flow2.png)

### Dinic

Dinic 的本质是对暴力的优化。

#### 朴素 Dinic

考虑增广前对图按找到 $s$ 的距离进行分层，每次只增广最短的增广路。

具体地，通过 bfs 对图分层后用 dfs 找增广路。
```cpp
bool bfs(){
	for(int i=1;i<=n;i++){
		dep[i]=0;
	}
	while(!q.empty()) q.pop();
	q.push(s);
	dep[s]=1;
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=e[i].nxt){
			int v=e[i].to,w=e[i].w;
			if(w>0&&dep[v]==0){
				dep[v]=dep[x]+1;
				if(v==t){
					return 1;
				}
				q.push(v);
			}
		}
	}
	return 0;
} 
int dfs(int x,int flow){
	if(x==t) return flow;
	int rest=flow;
	for(int i=head[x];i;i=e[i].nxt){
		int v=e[i].to,w=e[i].w;
		if(w>0&&dep[v]==dep[x]+1){
			int t=dfs(v,min(rest,w));
			rest-=t;
			e[i].w-=t;
			e[i^1].w+=t;
		}
	}
	return flow-rest;
}
```
#### 完全体 Dinic

朴素 Dinic 确实强悍，但还是太暴力了，所以我们考虑进行优化。

##### 当前弧优化

这个最重要，能直接把复杂度降为 $O(n^2m)$，证明~~不会~~略。

注意到对节点 $u$ dfs 时我们肯定将当前边之前的边都增广到了极限，没有继续增广的价值，所以对于 dfs 到任意一条边后都将起点的 $head$ 更新到当前边。

##### 剩余流量判断

显然有：如果上一层节点传递的流量已经消耗完了，就不用再进行 dfs。

##### 无用节点删除

如果我们将一些流量传给下一层节点，但是下一层节点返回的流量为 0，意味着这个节点无法再进行增广，我们将它删除，这个正确性也挺显然的。

具体地，可以把其放到第 0 层。

```cpp
bool bfs(){
	for(int i=1;i<=n;i++){
		dep[i]=0;lead[i]=head[i];
	}
	while(!q.empty()) q.pop();
	q.push(s);
	dep[s]=1;
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=e[i].nxt){
			int v=e[i].to,w=e[i].w;
			if(w>0&&dep[v]==0){
				dep[v]=dep[x]+1;
				if(v==t){
					return 1;
				}
				q.push(v);
			}
		}
	}
	return 0;
} 
int dfs(int x,int flow){
	if(x==t) return flow;
	int rest=flow;
	for(int i=lead[x];i&&rest;i=e[i].nxt){
		lead[x]=i;
		int v=e[i].to,w=e[i].w;
		if(w>0&&dep[v]==dep[x]+1){
			int t=dfs(v,min(rest,w));
			if(!t) dep[v]=0;
			rest-=t;
			e[i].w-=t;
			e[i^1].w+=t;
		}
	}
	return flow-rest;
}
```
### ISAP

完全体 Dinic 确实强悍，但维护深度每次都重新 bfs 看起来还是太愚蠢了，考虑继续优化。

好吧其实 ISAP 的常数不见得比 Dinic 小。


##### 算法实现

* 只跑一遍从 $t$ 到 $s$ 的 bfs，显然这个虽然倒着了但是不影响正确性。

* 对于任意点，如果从上个点传来的流量它没有用完，那它显然是被榨干了，没有剩余价值了，我们将这个点的 $dep$ 加一，这样它就不会从上一个点再次转移过来了。
* 我们动态维护每一层的节点数，如果有一层没有节点，那么就结束算法。

* 如果 $dep_s>n$ 那么也结束算法，因为一共就 $n$ 个点。

##### 详细揭秘

因为只有 $dep$ 连续才能转移，所以我们的第一条增广路肯定是最短的。

当我们的一条增广路增广完后，我们想找一条比他更长的增广路，那么我们就要将当前点的 $dep$ 增加加到能到别的节点，也就是 $dep_x\leftarrow \min(dep_v)+1$，但有注意到**如果当前点都被榨干了**，**那它的儿子肯定也被榨干了**，所以它的儿子的 $dep$ 必然也已经增加了，所以只用让 $dep_x\leftarrow dep_x+1$ 即可。

```cpp
void bfs(){
	while(!q.empty()) q.pop();
	q.push(t);
	dep[t]=1;
	gap[1]++;
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=e[i].nxt){
			int v=e[i].to;
			if(!dep[v]){
				dep[v]=dep[x]+1;
				q.push(v);
				gap[dep[v]]++;
			}
		}
	}
}
int dfs(int x,int flow){
	if(x==t||flow==0) return flow;
	int rest=flow;
	for(int i=lead[x];i&&rest;i=e[i].nxt){
		lead[x]=i;
		int v=e[i].to,w=e[i].w;
		if(dep[x]==dep[v]+1&&w>0){
			int t=dfs(v,min(rest,w));
			rest-=t;
			e[i].w-=t;
			e[i^1].w+=t;
		}
	}
	if(rest){
		gap[dep[x]]--;
		if(!gap[dep[x]]){
			dep[s]=t+1;
		}
		dep[x]++;
		gap[dep[x]]++;
	}
	return flow-rest;
}
int ISAP(){
	int ans=0;
	memset(dep,0,sizeof(dep));
	memset(gap,0,sizeof(gap));
	bfs();
	while(dep[s]<=t){
		for(int i=1;i<=t;i++){
			lead[i]=head[i];
		}
		ans+=dfs(s,1e18);
	}
	return ans;
}
```

---

## 作者：XXh0919 (赞：3)

一个月没碰你谷，咕值都掉光了，写篇题解涨涨咕。

# 网络最大流

## 0. 前置芝士

### 网络流图

在一个没有自环的有向图 $G(V, E)$ 中：

- 有一个唯一的源点 $S$ （出发点）；

- 有一个唯一的汇点 $T$ （结束点）。

图中的每一条边都一个非负的权值，这个权值叫做容量 $c(u,v)$。满足上述条件的图 $G$ 称为**网络流图**，记为 $G(V,E,c)$。

可以把网络流图想象成，如果把每条边都看成一个管道，可以看成是水从源点 $S$ 出发经过这些管道，最终流向汇点 $T$，而每条管道有最大的容量。

### 容量网络和残量网络

**容量网络**是一个有向图，图的边 $(u,v)$ 是非负的权 $c(u,v)$，被称为容量。图中有一个被称为源的节点和一个被称为汇的节点。

实际通过每条边的流量被称为 $f(u,v)$。

**残量网络**是一个结构和容量网络相同的有向图，只不过边的权值为 $c(u,v)-f(u,v)$。

网络流图有三个重要的性质：
1. 流量不能超过容量，即 $f(u,v)\le c(u,v)$。
2. 图中任意两点的流量必须满足 $f(u,v)=-f(v,u)$。
3. 每个点的流入量等于流出量。

有了这些铺垫，那么就该进入正题了。

## 1. 最大流

我们将有最大流量的网络流称为最大流（顾名思义），并且最大流可能不止一个。

那么我们如何来求最大流呢？

首先容易想到的是贪心。每次贪心，我们都找到一条 $S$ 到 $T$ 的只经过 $f(e)<c(e)$ 的路径（$e$ 为路径上的任意一条边），并沿着该路径尽可能的增加 $c(e)$，直到没有这样的路径。

但很遗憾，这样做是错误的。

例如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/f55dkw5i.png)

用贪心的策略，我们会得到答案为 $10$ 的流，可是像下图这样做答案为 $11$。

![](https://cdn.luogu.com.cn/upload/image_hosting/az23ksaq.png)

此时我们需要普及一个新概念：增广路。如果我们在容量网络的残量网络上，找出一条从 $S$ 到 $T$ 的路径，并且路径上边权最小的那条边权值为正，那么我们就说找到了一条增广路。显然，可以让一股流沿着增广路径从 $S$ 流到 $T$，使网络的流量增大。

### Ford-Fulkerson 算法（FF 算法）

FF 算法的基本思想就是 **DFS** 寻找增广路径。

该算法在每次增广时先在残量网络上找到一条增广路，然后将这条路上每条边的边权减去增广路上边权最小的边的边权，再在该边的**反向边**上加上这个权值。

为什么要进行反向边的操作呢？

实际上，这是为了可以撤销这一次的增广路径，因为网络流并不能通过贪心解决（上面有图为证），所以这次的增广不一定是全局最优的。

FF 算法就是不断增广，直到没有增广路为止。可以证明，没有增广路的时候就找到了最大流，算法最坏是 $O(|E|\max f)$，$f$ 是最大流大小。（算法过程请自行模拟）

但显然这个算法有一个缺陷。例如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/2duojz6s.png)

当 $N=10^9$ 时，容易看出这张网络流图的最大流是 $f=2\times10^9$，而 FF 算法的最坏复杂度是 $O(|E|\max f)$，一放进去直接爆炸。

所以智慧的人类又发明了一种新算法。

### Edmonds-Karp 算法（EK 算法）
这个算法算是比较常用的。EK 算法是基于 FF 算法的方法，不断用 **BFS** 寻找增广路，直至网络上不存在增广路为止。

注意：在用邻接表存图的时候，一定、一定要“成对存储”，即：把网络的每条有向边及其反向边存在邻接表相邻下标位置上，也就是 $\{0,1\},\{2,3\}...$ 这样存。因为我们是通过异或来得到反向边的，只有这样才能满足两条边之间的关系，否则程序就会出错。

那么模板题用 EK 算法解决就是这样的：

```cpp
#include <bits/stdc++.h>
#define pi pair<int,int>
using namespace std;
const int N = 1e5 + 15, inf = 1e9;

int n, m, s, t;
int head[N], to[N],  nxt[N], idx;
long long val[N];
bool vis[N];
long long incf[N];//记录源点到该点的最大流量
int pre[N], mf;


void add (int u, int v, int w) {
	to[idx] = v;
	val[idx] = w;
	nxt[idx] = head[u];
	head[u] = idx ++;
}

bool bfs () {
	memset (vis, 0, sizeof vis);
	queue <int> q;
	q.push (s);
	vis[s] = 1;
	incf[s] = inf;//增广路上各边最小剩余容量
	while (!q.empty()) {
		int u = q.front();
		q.pop ();
		for (int i = head[u]; i != -1; i = nxt[i]) {
			if (val[i]) {
				int v = to[i];
				if (vis[v]) continue;
				vis[v] = 1;
				incf[v] = min (val[i], incf[u]);
				pre[v] = i;//记录 v 点的前面一条边的编号，便于下面找增广路
				q.push (v);
				if (v == t) return 1;//能够流到汇点
			}
		}
	}
	return 0;
}

void EK () {
	while (bfs ()) {
		int u = t;
		while (u != s) {//更新增广路
			int i = pre[u];
			val[i] -= incf[t];
			val[i ^ 1] += incf[t];//如上文所言
			u = to[i ^ 1];
		}
		mf += incf[t];//更新最大流
	}
}

int main() {
	memset (head, -1, sizeof head);
	scanf("%d%d%d%d", &n, &m, &s, &t);
	for (int i = 1; i <= m; ++ i) {
		int u, v;
		long long w;
		scanf ("%d%d%lld", &u, &v, &w);
		add (u, v, w);//初始时正向边容量为边权
		add (v, u, 0);//初始时反向边容量为 0
	}
	EK ();
	printf ("%lld\n", mf);
	return 0;
}
```
对于 EK 算法，每次沿着一条最短（边数最少）的增广路进行增广，可以证明 EK 算法的时间复杂度与边的容量无关，且增广路的条数不超过 $\frac{m(n+2)}{2}$ 条。EK 算法的理论时间复杂度为 $O(nm^2)$，但一般远达不到这么高。

但是科学家们仍然觉得不满足，他们认为这个算法还可以优化。于是又一种新算法诞生了。

### Dinic 算法

科学家们的理由是：EK 算法每轮 BFS 可能会遍历整个残量网络，但每次只找出一条增广路。是否可以一次寻找多个增广路呢？

我们可以在每一次 BFS 时对图进行分层：只使用 $V_e>0$ 的边 $e$（$V$ 指边权），求出 $S$ 到每个点 $i$ 的最短距离 $dis_i$。然后用所有满足 $V_e>0$ 且 $dis_i+1=dis_j$ 的边 $e=(i,j)$ 尽可能多的进行增广，接着在这些边构成的最短路图上增广即可（图上任意一条从 $S$ 到 $T$ 的路径均为最短路）。不断分层增广，直到分层时 $S$ 不能到达 $T$，说明已经找到了最大流。（算法过程请自行模拟）

但是这样仍然不是最优的。~~（有完没完！）~~ 人们又发现，在 DFS 过程中，对于一条边 $e=(i,j)$，如果已经不存在一条 $j$ 到 $T$ 的路径，路径上的所有 $V$ 与 $V_e$ 的最小值大于 $0$，则这条边已经不能再用于增广了，就相当于这条路已经废了。想一想，如果一条弧（就是一条边）在 DFS 后流量达到了容量限制，那么这次增广就不可能再通过这条弧了，我们之后的 DFS 过程中，如果还有遇到这个节点在查找允许弧的时候，就不用再查找这条弧了。这样可以省去大部分时间。

由于我们都是按照边表的顺序存储边的。因此，可以存储下以 $u$ 开头的节点的当前弧 $cur_u$，之后遇到 $u$ 直接从 $cur_u$ 这条弧之后开始寻找，而不必再从 $head_u$ 开始了。

那么这个题用 Dinic 算法就是这样的：

```cpp
#include <bits/stdc++.h>
#define pi pair<int,int>
#define itn int
#define fro for
using namespace std;
typedef long long ll;
const ll N = 1e6 + 15, inf = 1e9;

int n, m, s, t;
int f[2025][2025], id[2025][2025], cnt;
int head[N], to[N], nxt[N], idx;
ll val[N];
int dep[N];
int cur[N];

void add (int u, int v, int w) {
	to[idx] = v;
	val[idx] = w;
	nxt[idx] = head[u];
	head[u] = idx ++;
}

bool bfs () {//分层
	memset (dep, 0, sizeof dep);
	queue <int> q;
	q.push(s);
	dep[s] = 1;//源点层数为 1
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		for (int i = head[u]; i != -1; i = nxt[i]) {
			int v = to[i];
			if (!dep[v] && val[i]) {//有剩余容量且没访问过
				dep[v] = dep[u] + 1;
				q.push(v);
				if (v == t) return 1;
			}
		}
	}
	return 0;
}

ll dfs (int u, ll mf) {//mf 指从 u 流出的流量
	if (u == t) return mf;
	ll sum = 0;//共流过的流量
	for (int i = cur[u]; i != -1; i = nxt[i]) {
		cur[u] = i;//当前弧优化
		int v = to[i];
		if (dep[v] == dep[u] + 1 && val[i]) {
			ll f = dfs (v, min (val[i], mf));
			val[i] -= f;
			val[i ^ 1] += f;
			mf -= f;
			sum += f;
			if (mf == 0) break;//余量优化：剩余流量没了就不用搜了
		}
	}
	if (sum == 0) dep[u] = 0;//残支优化：当一共流过的流量为 0 时，说明这个点已经不会有贡献了
	return sum;
}

ll Dinic () {
	ll flow = 0;
	while (bfs ()) {
		memcpy (cur, head, sizeof head);//将 cur 初始化为每个点的第一条出边
		flow += dfs (s, inf);
	}
	return flow;
}

int main() {
	memset (head, -1, sizeof head);
	scanf ("%d%d%d%d", &n, &m, &s, &t);
	fro (int i = 1; i <= m; ++ i) {
		itn u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		add (u, v, w);
		add (v, u, 0);
	}
	printf ("%lld\n", Dinic ());
	return 0;
}
```
Dinic 算法的时间复杂度为 $O(n^2m)$，而实际应用中远远达不到这个上界，可以说是比较容易实现的效率很高的网络流算法之一。特别的，Dinic 算法求解二分图最大匹配的时间复杂度为 $O(m\sqrt n)$，实则表现更优秀。

但是 ~~（还来？）~~，人们觉得这还是慢了，于是又有了一个叫做最高标号预流推进算法（HLPP）的算法，详情见 [P4722 【模板】最大流 加强版 / 预流推进](https://www.luogu.com.cn/problem/P4722)，在此我就不细讲了。（毕竟码字真的是累啊）

码字不易，求个赞再走吧。

---

## 作者：Yuiu2233 (赞：3)

# 网络最大流

## 序言

本篇题解提供了如何想到正确算法的思维过程，只起引导思考作用。如果想要了解 Dinic 以及其他算法，不建议参阅本文。

如果你因为这是模板题而参阅题解，建议阅读完下文关于网络的相关概念之后**自行思考**如何写出这道题。在这过程中，如果想到某一部分而觉得有障碍，可以往下阅读，得到启发后建议继续思考。在阅读完文字题解后建议自行编写程序。当然，本文也提供了标程以供参考。

本文部分内容参考了 [oiwiki](https://oi-wiki.org/graph/flow/) 中关于网络流的介绍。感兴趣的选手可以自行参阅。

## 基本概念

对于初学者，本文提供了网络流的相关概念介绍。如果你已经有一定程度上的了解，请自行跳过该部分。

**网络**：一个特殊的有向图，一般用符号 $G$ 表示。通常记作 $G=(V,E)$，其中 $V$ 代表所有点的集合（简称点集），$E$ 代表所有有向边的集合（简称边集）。

**源点和汇点**：网络中存在两个特殊的点，分别是**源点**和**汇点**。源点无入度，可以理解成图的**起点**，记作 $s$。汇点无出度，可以理解成图的**终点**，记作 $t$。显然 $s \ne t$ 且 $s,t\in V$。

**容量**：对于一条边 $u \rightarrow v$，赋予一个特殊属性**容量**，记作 $c(u,v)$。我们可以将 $(u,v) \notin E$ 的容量设为 $c(u,v)=0$。

**流**：一个实值函数，给每条边 $(u,v)$ 赋予一个值，称作该边上的**流量**，记作 $f(u,v)$。同时，我们定义和有流量的边相连的点有**流入流量**和**流出流量**，分别指流入该节点的流量和流出该节点的流量。我们称一个点的流出流量减去流入流量为**净流**。对于一个点的净流，由定义可知 $f(u)= \sum _{x\in V} f(u,x)-f(x,u)$。

我们希望除了源点和汇点之外，其他点的净流为 $0$。容易发现流有以下几种性质：

- **流量守恒**：$\forall u \ne s \ \text{且}\ u\ne t,f(u)=0$；

- **容量限制**：$f(u,v) \le c(u,v)$；

- **斜对称**：$f(u,v)=-f(v,u)$；

**残量网络**：在任意时刻，$G$ 中所有节点和剩余容量大于 $0$ 的边构成的子图被称为残量网络，记作 $G_f=(V,E_f)$，其中 $E_f=\left \{ (u,v) \mid c(u,v) \neq 0 \right \}$。

## 最大流

我们称整张图的流量为源点的净流，即 $f(s)$，根据定义这也相当于 $-f(t)$。我们记作 $\lvert f(s) \rvert$。而给定一张网络求其最大的流量的问题就是网络最大流，我们称作**网络最大流问题**。

本文介绍 Edmonds-Karp 算法解决网络最大流问题。

## 思路

本部分引入 Edmonds-Karp 算法。

### 朴素做法：

我们思考这样一个问题，既然我们要找到网络最大流，并且这个最大流事实上无法超过所有边流量之和，那么我们穷举每一个答案，在图中跑一遍验证这个答案是否能达到，二分答案优化，一定能找到最大流。

观察数据规模，显然 TLE，需要优化。思考能否把这个问题简单化。

进一步思考，答案的贡献来自于从 $s$ 到 $t$ 的路径。每一条路径的流量取决于这条路径上的最小容量。那么如果有路径的最小容量大于 $0$，这条路径一定可以对答案产生贡献。我们称这样的路径为**增广路**。

如果我们在残量网络中不断地搜索增广路，每次更新残量网络和最大流，直到图上不存在增广路，此时我们达到的一定是最大值！

**吗？**

我们注意到，在这样的过程中会有先后顺序上的问题。因为多个增广路径可能共享同一条边，而我事先并不知晓哪一条增广路对答案的贡献更大。错误的路径选择可能导致局部最优，永远无法达到全局最大流。

以下的例子或许能帮你理解这一个过程：

![](https://cdn.luogu.com.cn/upload/image_hosting/ueir4jnv.png)

观察这张图片，其中 $s$ 和 $t$ 分别是源点和汇点，容易发现，最大流是 $6$。最大流流经 $s \rightarrow a \rightarrow t$ 和 $s \rightarrow b \rightarrow t$，流量都是 $3$。那如果按照我们刚刚的想法跑增广路可能会发生什么呢？

1. 第一次增广，选择路径 $s \rightarrow a \rightarrow b \rightarrow t$，此时最小容量为 $\min(3,1,3)=1$，那么我们更新容量。

   - $s \rightarrow a$ 剩余 $2$；
   - $a \rightarrow b$ 剩余 $0$，在残量网络中被删除；
   - $b \rightarrow t$ 剩余 $2$；
   - 总流量 $f\gets f+1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/d52fiefo.png)

2. 那么接下来的增广，我们只能选择路径 $s \rightarrow a \rightarrow t$ 和路径 $s \rightarrow b \rightarrow t$。最小的容量皆为 $2$。更新之后，我们得到没有增广路的残量网络，算法结束。

现在我们的得到的最大流 $f=1+2+2=5<6$。显然不是正确结果。这是因为我们先选择的 $a \rightarrow b$ 阻塞了更优的流分配方案。

看来我们的思路暂时不能解决这个顺序问题。但是往好处想，只要解决这个问题，那么可以证明这个过程一定能让我们解决这道题。所以我们只需要思考如何解决这个问题既可。

首先我们知道，我们的问题之一在于直接对原来的网络进行修改，这个过程覆盖了之前图上的信息，导致我们无法知道这个进程是不是整体最优的。所以我们必须保留原图中每条边上的容量信息。进一步思考，我们的核心错误在于无法保证顺序的最优性，那如果我们每一条可以尝试的增广路都退回到历史版本试一遍，比较哪一项更好，就能解决顺序问题，这是不是有点像**可持久化**？

记下每一张图，在时空上的开销是很大的。我们需要找到一种更为便捷的方法实现上述思路。

（如果读到这里你有些许思路，可以自行尝试编写程序。下文开始介绍 Edmonds-Karp 算法。）

### Edmonds-Karp 算法

通常简称为 EK 算法。

我们希望残量网络是能够“**反悔**” 的。为了能达到这一目的，我们在网络中引入**反向边**的概念，对于每一条边 $(u,v)$，我们建一条 $(v,u)$。

因为这条边实际上是不存在的，根据上文，我们这样说：

> 对于一条边 $u \rightarrow v$，赋予一个特殊属性**容量**，记作 $c(u,v)$。我们可以将 $(u,v) \notin E$ 的容量设为 $c(u,v)=0$。

我们将暂且将这些边的容量设为 $0$。当正向边流过流量时，反向边流量增加。这相当于记下了我们可以在这条边上退回流量。还是拿刚才的图举例：

![](https://cdn.luogu.com.cn/upload/image_hosting/ru8thauy.png)

为了简化，我们此处只画出了反向边构成的图。

在第一次增广之后（和上文相同），这张图变成：

![](https://cdn.luogu.com.cn/upload/image_hosting/j6be2n04.png)

如果这张图和此时的正向图叠加（为简化，图示只叠加了 $b \rightarrow a$ 这条边），我们有：

![](https://cdn.luogu.com.cn/upload/image_hosting/kt2onamb.png)

这张图里居然出现了一条新的增广路 $s \rightarrow b \rightarrow a \rightarrow t$！这条增广路的实际意义是利用 $b \rightarrow a$ 将流量从 $a \rightarrow b$ 退回给 $a$。我们得到的新图是：

![](https://cdn.luogu.com.cn/upload/image_hosting/6yzp83xh.png)

这张图和我们的原来的图不一样了。继续两次增广，我们可以得到最大流 $f=1+1+2+2=6$ 显然是正确的。

其中的核心步骤在于反向边的构建，请这样理解：反向边 $b \rightarrow a$ 的物理意义是 —— 允许将 $a \rightarrow b$ 的流量重新分配给 $a \rightarrow t$，同时释放 $s \rightarrow b$ 的容量直接连上 $t$。这样子我们就能用相对较小的时空开销解决网络最大流问题。

我们重新定义残量网络：**残量网络**包含以下边及其**残量容量** $c_f$：

- 对于原图中的每条边 $(u, v) \in E$，如果 $c(u, v) - f(u, v) > 0$，则 $E_f$ 包含边 $(u, v)$，且 $c_f(u, v) = c(u, v) - f(u, v)$。
- 对于原图中的每条边 $(u, v) \in E$，如果 $f(u, v) > 0$，则 $E_f$ 包含边 $(v, u)$，且 $c_f(v, u) = f(u, v)$。

(关键点：残量网络包含原边剩余容量的正向边和代表“反悔” 能力的反向边)。

如何证明反向边不会破坏我们原来的流量守恒性质？请注意，我们同时也说了：

> - **斜对称**：$f(u,v)=-f(v,u)$。

那么我们只需要再编写搜索模块就可以彻底解决这个问题了，因为增广路径长度一定是单调递增的，我们用 BFS 每次找最短路径就可以了。

现在我们可以直接写出 EK 算法的代码了。如果你完全看懂了上文，强烈建议自己写出代码。

---

这里有一个特殊的小技巧，因为我们希望通过正向边快速求得反向边的编号，来对反向边操作，我们一般用链式前向星来存图。

在链式前向星中，正向边和反向边是前后加入图中的，所以他们的编号只差 $1$，而我们知道对于编号 $2n$，有 $2n \oplus 1 = 2n+1$ 和 $(2n+1) \oplus 1 = 2n$。那么我们只需要从奇数开始编号就能通过这种方法迅速访问正向边和反向边。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+100;
int n,m,s,t;

struct Node{
	int v,w,nextt; //w表示容量
}graph[2*N]; //反向边需要开两倍空间

int cnt=1,head[N];

void add(int u,int v,int w){
	graph[++cnt].v=v;
	graph[cnt].w=w;
	graph[cnt].nextt=head[u];
	head[u]=cnt;
}

int vis[N];
struct Pr{
	int v,e; //v表示从源点到该点的上一个点，e表示从源点到该点的上一条边
}pre[N]; //用于记录增广路信息

bool bfs(){
	queue<int> q;
	memset(vis,0,sizeof(vis));
	memset(pre,-1,sizeof(pre));
	vis[s]=1;
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=graph[i].nextt){
			int v=graph[i].v;
			if(vis[v]) continue;
			if(graph[i].w==0) continue; //容量为0，无法通行
			pre[v].v=u; //记下增广路上所有的点
			pre[v].e=i; //记下增广路上所有的边
			if(v==t) return true;
			vis[v]=1;
			q.push(v);
		}
	}
	return false;
}

int EK(){
	int ans=0;
	while(bfs()){
		int minn=INT_MAX;
		for(int i=t;i!=s;i=pre[i].v)
			minn=min(minn,graph[pre[i].e].w); //minn记录下增广路上最多能流过的流量
		for(int i=t;i!=s;i=pre[i].v)
			graph[pre[i].e].w-=minn,
			graph[pre[i].e^1].w+=minn;
		ans+=minn;
	}
	return ans;
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	
	cin>>n>>m>>s>>t;
	for(int i=1,u,w,v;i<=m;i++){
		cin>>u>>v>>w;
		add(u,v,w);
		add(v,u,0); //建反向边
	}
	int ans=EK();
	cout<<ans;
	return 0;
}
```

上述算法每次 BFS 的时间复杂度是 $O(E)$，最坏情况下每次增广只消除一单位流量，最多进行 $O(VE)$ 次增广，所以 EK 算法的时间复杂度是 $O(VE^2)$，读者可自行参阅 [oiwiki](https://oi-wiki.org/graph/flow/max-flow/) 上的相关证明。这个复杂度足以通过本题，但在稠密图中表现不佳。本篇题解只起到引导思考作用，故不介绍其他算法，有兴趣的读者请参阅 Dinic 算法和 ISAP 算法。

---

## 作者：MoonCake2011 (赞：3)

此文摘自我自己写的[网络流与二分图详解](https://www.luogu.com.cn/article/kw6klidj)。

前几天，Libingyue2011 看到[此题](https://www.luogu.com.cn/problem/P1004)。

woc，两条路径，TMD 还不让多取。

于是大蒟蒻 Libingyue2011 不想写 dp 了，他觉得太难。

又从一本蓝色的书上得知，此题可以用费用流，还能把加强版也顺带切了。

于是，他就切了。

所以，这其实是个网络流详解。

## 关于网络与流的一些知识 

一个网络是一张有向图，每条边都有一个权值 $c$。

在网络中，有两个特殊节点，称为源点（$S$）与汇点（$T$）。

$c(x,y)$ 为 $(x,y)$ 边的容量。

定义函数 $f(x,y)$ 为边 $(x,y)$ 的流函数。

它满足如下性质。

1. 容量限制：$f(x,y)<c(x,y)$。
2. 斜对称：$f(x,y)=-f(y,x)$。
3. 流量守恒：对于点 $x$ 不等于 $S$ 且不等于 $T$，满足 $\sum_{(u,x)}f(u,x)=\sum_{(x,v)}f(x,v)$，其中 $(u,x)$ 与 $(x,v)$ 都是图上的边。

由于有斜对称性质，其实网络中，每条边会有反向边的。

$c(x,y)-f(x,y)$ 被称为一条边的剩余容量 $\text{rest}(i,j)$。

一个网络的流量是 $\sum_{(S,v)}f(S,v)$，其中 $(S,v)$ 为图上的边。

一个网络流好比运输自来水的管道，在源点不停产生水，汇点不停的贮存水，每个节点不贮存水，只运输水。

其中，一个网络中，合法的流函数 $f$ 有很多，让那个网络的流量（上面说的）最大的流函数就是最大流。

[最大流模板题](https://www.luogu.com.cn/problem/P3376)。

## Edmonds-Karp 增广路算法 

一条从 $S$ 到 $T$ 的每条边剩余容量都大于 $0$ 的路径。

可以多流 $\min\operatorname{rest}(x,y)$ 的流量，最大流可以加等于 $\min\operatorname{rest}(x,y)$，那路径上的所有边的 $\operatorname{rest}$ 需要减等于 $\min\operatorname{rest}(x,y)$。

其中 $(x,y)$ 在那条路径上。

有时我们有些边还需要支持其它边的流入，所以不一定要减满 $\min\operatorname{rest}(x,y)$。

难道要 `dfs`，变为指数级的吗？

聪慧的人想到一个办法，就是建反向边（退流操作）。

找到一条增广路，可以将反向边的剩余流量 $\operatorname{rest}(y,x)$ 的值加 $\min\operatorname{rest}(x,y)$。

这样就可以支持反悔，找到一条含反向边的增广路（更优的），就可以将正向边的剩余流量加回来。

且依旧满足**流量守恒**。

这样就可以抵消一些错误的增广路上的边。

这样不停增广，就能找到答案。（有反悔）

怎么找到增广路呢？

BFS，DFS，其实都行。

但是我写的是 BFS，~~因为下一个算法用 BFS 简单一点~~。

只要能找到增广路，就把增广路上的路径更新，直到没有增广路。

时间复杂度 $O(nm^2)$，oi-wiki 上可证。

但是在大多数网络上，它跑不太满。

所以一般此算法能处理 $10^3-10^4$ 规模的网络。

代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,s,t;
int head[10010],to[20010],nxt[20010],val[20010],tot=1;//这边 tot=1，使得反向边能用异或访问 
void add(int u,int v,int w){
	to[++tot]=v,val[tot]=w;
	nxt[tot]=head[u];
	head[u]=tot;
}
int maxflow,dis[10010],pre[10010];
bool vis[10010];
bool bfs(){
	queue<int>q;
	memset(vis,0,sizeof vis);
	vis[s]=1,dis[s]=1e18;
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=nxt[i]){
			if(vis[to[i]] || !val[i]) continue;//如果访问过或流不动就 continue 
			dis[to[i]]=min(dis[u],val[i]);//找出增广路 min 值 
			pre[to[i]]=i,vis[to[i]]=1;//为了找出增广路 
			q.push(to[i]);
			if(to[i]==t) return 1;//找到增广路了就直接 return 
		}
	}
	return 0;
}
void update(){//更新路径 
	int x=t;
	while(x!=s){
		int i=pre[x];
		val[i]-=dis[t];
		val[i^1]+=dis[t];//注意反向边，用异或访问  
		x=to[i^1];//反着走
	}
	maxflow+=dis[t];//最大流更新 
}
signed main() {
	cin>>n>>m>>s>>t;
	for(int i=1;i<=m;i++){
		int u,v,w;
		cin>>u>>v>>w;
		add(u,v,w),add(v,u,0);//反向边最开始不流 
	}
	while(bfs()) update();//只要有增广路，那就修改 
	cout<<maxflow;
	return 0;
}
```
## Dinic 算法

EK 算法一次 BFS 有可能遍历整个残量网络，但是只能找出一条增广路。

于是我们怎么用一个 BFS，找到多条增广路。

可以用 BFS 将图分层，用 DFS 在分层图（只能从 $u$ 层流向 $u+1$ 层）上去寻找增广路。

详细的，就是从源点 $S$，在分层图上向下 `dfs` 到 $T$。

回溯时像 EK 一样更新增广路，注意看一下这个点如果有多条增广路，能否承受那么大的流量。

### 当前弧优化

重点来了，这就是 Dinic 比 EK 快的原因。

首先，一个点 $u$ 会被多次遍历。

每次枚举 $u$ 的边时，只要流出的流量等于流进的流量，直接 `return`。

因为再更新就不满足**流量守恒**了。

所以我们第二次遍历到 $u$ 的时候，就不用遍历那些增广完毕的边了。

这是保证复杂度的一个优化。

接着，下一个问题。

那为什么要分层呢？

首先，分层图上的层数小于等于点数 $n$。

在 oi-wiki 上有证明，用以上的东西可以证明单次增广的时间复杂度为 $O(n)$（$n$ 为点数）。

总时间复杂度 $O(n^2m)$。

但是在大多数网络上，它跑不太满。

所以一般此算法能处理 $10^4-10^5$ 规模的网络。

**注意，不加当前弧会将时间复杂度降低至 EK**。

代码。
```cpp
//Dinic 算法  
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,s,t;
int head[10010],to[20010],nxt[20010],val[20010],tot=1;
void add(int u,int v,int w){
	to[++tot]=v,val[tot]=w;
	nxt[tot]=head[u];
	head[u]=tot;
}
int maxflow,dis[10010],now[10010];
bool vis[10010];
bool bfs(){
	queue<int>q;
	memset(vis,0,sizeof vis);
	vis[s]=1,dis[s]=0,now[s]=head[s];
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=nxt[i]){
			if(vis[to[i]] || !val[i]) continue;
			now[to[i]]=head[to[i]];//当前弧重置 
			dis[to[i]]=dis[u]+1,vis[to[i]]=1;
			q.push(to[i]);
			if(to[i]==t) return 1;
		}
	}
	return 0;
}
int dinic(int x,int flow){
	if(x==t) return flow;//到了汇点
	int rest=flow;//维护流出量（这是流入量）
	for(int i=now[x];i && rest;i=nxt[i]){//枚举，rest=0 时，不能再增广了
		now[x]=i;//当前弧优化 
		if(dis[to[i]]!=dis[x]+1 || !val[i]) continue;//不是分层边或者剩余容量为 0，不行
		int v=dinic(to[i],min(rest,val[i]));//增广
		if(!v) dis[to[i]]=0;//这条路不能再增广，剪枝 
		val[i]-=v,val[i^1]+=v;//更新 
		rest-=v;//更新 rest 
	}
	return flow-rest;
}
signed main() {
	cin>>n>>m>>s>>t;
	for(int i=1;i<=m;i++){
		int u,v,w;
		cin>>u>>v>>w;
		add(u,v,w),add(v,u,0);
	}
	int flow=0;
	while(bfs()) while(flow=dinic(s,1e18)) maxflow+=flow;
	cout<<maxflow;
	return 0;
}
```
[习题](https://www.luogu.com.cn/problem/P1343)。
## Dinic 优化 

[【模板】最大流 加强版 / 预流推进](https://www.luogu.com.cn/problem/P4722)。

预流推进是什么，我不道。

开始玄学优化。

### 优化 1，按位分段

Dinic 算法在流量差异大的时候跑的慢。

所以，可以将流量按二进制位分段。

将所有 $2^p \le x < 2^{p+1}$ 分为一组。

从大到小枚举组，去跑 Dinic。

将每次跑组跑完的边留下来，放到下一组接着跑。

这样时间复杂度能大大降低，变为 $O(nm\log C)$。

具体我不会证。

看代码。
```cpp
//Dinic 算法  
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,s,t;
int head[10010],to[240010],nxt[240010],val[240010],tot=1;
void add(int u,int v,int w){
	to[++tot]=v,val[tot]=w;
	nxt[tot]=head[u];
	head[u]=tot;
}
int maxflow,dis[10010],now[10010];
bool vis[10010];
bool bfs(){//BFS 分层 
	queue<int>q;//STL 队列 
	memset(vis,0,sizeof vis);
	vis[s]=1,dis[s]=0,now[s]=head[s];
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=nxt[i]){
			if(vis[to[i]] || !val[i]) continue;
			now[to[i]]=head[to[i]];
			dis[to[i]]=dis[u]+1,vis[to[i]]=1;
			q.push(to[i]);
			if(to[i]==t) return 1;//有增广路，直接 return
		}
	}
	return 0;
}
int dinic(int x,int flow){
	if(x==t) return flow;
	int rest=flow;
	for(int i=now[x];i && rest;i=nxt[i]){
		now[x]=i;//当前弧优化
		if(dis[to[i]]!=dis[x]+1 || !val[i]) continue;
		int v=dinic(to[i],min(rest,val[i]));
		if(!v) dis[to[i]]=0;
		val[i]-=v,val[i^1]+=v;
		rest-=v;
	}
	return flow-rest;
}
struct node{
	int u,v,w;
}e[120010];
signed main() {
	ios::sync_with_stdio(0);
	cin>>n>>m>>s>>t;
	for(int i=1;i<=m;i++) cin>>e[i].u>>e[i].v>>e[i].w;//存边
	for(int i=30;i>=0;i--){//枚举位
		int p=(1<<i);
		for(int j=1;j<=m;j++) if(e[j].w>=p && e[j].w<p*2) add(e[j].u,e[j].v,e[j].w),add(e[j].v,e[j].u,0);//枚举边并加入，注意反向边
		int flow=0;//跑 Dinic 并统计答案
		while(bfs()) while(flow=dinic(s,1e18)) maxflow+=flow;//不删边，留到下一组接着跑
	} 
	cout<<maxflow;
	return 0;
}
```

有 [68 pts](https://www.luogu.com.cn/record/169178727)。

### 优化 2，反向滞留

~~这我自己取的名字~~。

你看，上一个优化都可以先跑一部分的图。

那这也可以。

发现反向边有点影响效率（人家跑过来的，你跑回去）。

于是先不算反向边跑一边 Dinic，但计算反向边的权值。

跑完后，直接加上反向边，再跑一次 Dinic。

发现效率大大提升。

代码。
```cpp
//Dinic 算法  
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,s,t;
int head[10010],to[240010],nxt[240010],val[240010],tot=1;
vector<int>e[10010];
void add(int u,int v,int w){//注意 add 函数有变化
	to[++tot]=v,val[tot]=w;
	nxt[tot]=head[u];
	head[u]=tot;
	e[u].push_back(tot);//这里存的是要去跑 Dinic 的边 
	to[++tot]=u,val[tot]=0;
	nxt[tot]=head[v];
	head[v]=tot;//反向边先不参与 Dinic，但参与更新
}
int maxflow,dis[10010],now[10010];
bitset<10010>vis;
bool Flag=0;
int Q[10010],H,T;
inline bool bfs(){
	H=1,T=0;
	for(int i=1;i<=n;i++) vis[i]=0;
	vis[s]=1,dis[s]=0,now[s]=0;
	Q[++T]=s;
	while(H<=T){
		int u=Q[H++];
		for(int i=0;i<e[u].size();i++){
			if(vis[to[e[u][i]]] || !val[e[u][i]]) continue;
			now[to[e[u][i]]]=0;
			dis[to[e[u][i]]]=dis[u]+1,vis[to[e[u][i]]]=1;
			Q[++T]=to[e[u][i]];
			if(to[e[u][i]]==t) return 1;
		}
	}
	return 0; 
}
int dinic(int x,int flow){
	if(x==t) return flow;
	int rest=flow;
	for(int i=now[x];i<e[x].size() && rest;i++){
		now[x]=i;
		if(dis[to[e[x][i]]]!=dis[x]+1 || !val[e[x][i]]) continue;
		int v=dinic(to[e[x][i]],min(rest,val[e[x][i]]));
		if(!v) dis[to[e[x][i]]]=0;
		val[e[x][i]]-=v,val[e[x][i]^1]+=v;
		rest-=v;
	}
	return flow-rest;
}
struct node{
	int u,v,w;
}E[120010];
signed main() {
	ios::sync_with_stdio(0);
	cin>>n>>m>>s>>t;
	for(int i=1;i<=m;i++) cin>>E[i].u>>E[i].v>>E[i].w;
	for(int i=30;i>=0;i--){//下面与上面很不一样 
		int p=(1<<i);
		int kt=tot;
		for(int j=1;j<=m;j++)
			if(E[j].w>=p && E[j].w<p*2)
				add(E[j].u,E[j].v,E[j].w);//存边 
		int flow=0;//跑 Dinic 
		while(bfs()) while(flow=dinic(s,1e18)) maxflow+=flow;
		for(int j=1;j<=m;j++){//加反向边
			if(E[j].w>=p && E[j].w<p*2){
				kt+=2;
				e[E[j].v].push_back(kt);
			}
		}
		while(bfs()) while(flow=dinic(s,1e18)) maxflow+=flow;//再跑一次 
	} 
	cout<<maxflow;
	return 0;
}
```
有 [84 pts](https://www.luogu.com.cn/record/169372193)。

### 优化 3，对优化 1 的优化（压位优化）

将每次枚举一个二进制位变成三个二进制位，这样效率也许会高一些。

因为枚举次数会少，但是 Dinic 的值域增加。

所以效率因数据而定。

反正这样是过了。

代码。
```cpp
//Dinic 算法  
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,s,t;
int head[1210],to[240010],nxt[240010],val[240010],tot=1;
vector<int>e[1210];
void add(int u,int v,int w){
	to[++tot]=v,val[tot]=w;
	nxt[tot]=head[u];
	head[u]=tot;
	e[u].push_back(tot);
//	cout<<to[e[u][e[u].size()-1]]<<" "<<w<<"\n";
	to[++tot]=u,val[tot]=0;
	nxt[tot]=head[v];
	head[v]=tot;
}
int maxflow,dis[1210],now[1210];
bitset<1210>vis;
bool Flag=0;
int Q[1210],H,T;
inline bool bfs(){
	H=1,T=0;
	for(int i=1;i<=n;i++) vis[i]=0;
	vis[s]=1,dis[s]=0,now[s]=0;
	Q[++T]=s;
	while(H<=T){
		int u=Q[H++];
		for(int i=0;i<e[u].size();i++){
			if(vis[to[e[u][i]]] || !val[e[u][i]]) continue;
			now[to[e[u][i]]]=0;
			dis[to[e[u][i]]]=dis[u]+1,vis[to[e[u][i]]]=1;
			Q[++T]=to[e[u][i]];
			if(to[e[u][i]]==t) return 1;
		}
	}
	return 0; 
}
int dinic(int x,int flow){
	if(x==t) return flow;
	int rest=flow;
	for(int i=now[x];i<e[x].size() && rest;i++){
		now[x]=i;
		if(dis[to[e[x][i]]]!=dis[x]+1 || !val[e[x][i]]) continue;
		int v=dinic(to[e[x][i]],min(rest,val[e[x][i]]));
		if(!v) dis[to[e[x][i]]]=0;
		val[e[x][i]]-=v,val[e[x][i]^1]+=v;
		rest-=v;
	}
	return flow-rest;
}
struct node{
	int u,v,w;
}E[120010];
signed main() {
	ios::sync_with_stdio(0);
	cin>>n>>m>>s>>t;
	for(int i=1;i<=m;i++) cin>>E[i].u>>E[i].v>>E[i].w;
	for(int i=30;i>=0;i-=3){//3位一次枚举
		int p=(1<<i);
		int kt=tot;
		for(int j=1;j<=m;j++)
			if(E[j].w>=p && E[j].w<p*8)//3位一次枚举
				add(E[j].u,E[j].v,E[j].w);
		int flow=0;
		while(bfs()) while(flow=dinic(s,1e18)) maxflow+=flow;
		for(int j=1;j<=m;j++){
			if(E[j].w>=p && E[j].w<p*8){//3位一次枚举
				kt+=2;
				e[E[j].v].push_back(kt);
			}
		}
		while(bfs()) while(flow=dinic(s,1e18)) maxflow+=flow;
	} 
	cout<<maxflow;
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/169372645)。

时间复杂度玄学。

[我的题解](https://www.luogu.com.cn/article/1jmnl3oj)。

---

## 作者：chu_yh (赞：2)

Update：图炸了修了一下，要麻烦管理重审，十分抱歉。

**[博客](https://www.cnblogs.com/chu-yh/p/18974930)内容更丰富**。人生建议：把 $u$ 和 $v$ 看清楚！

## Part. 0：定义

其实没啥好讲的。理解为一个单向道路网，每条道都有个最大载重，要过这条道的货的重量不能超过这个最大载重（否则路会塌），给定一对起点和终点，最大流问题就是问最多可以从起点向终点运多少货物。

- **流量网络**：就是一张 $n$ 个点 $m$ 条边的**无向图**（单向道路网），每条从点 $u$ 到点 $v$ 的边有一个容量 $c(u,v)$（最大载重）。点集中入度为 $0$ 的点为源点 $s$（起点），出度为 $0$ 的点为汇点 $t$（终点），并且源点汇点都只有一个。
- **流**：理解为从这条道路上过的货物的重量。用 $f(u,v)$ 表示一条从点 $u$ 到点 $v$ 的边的流量。有以下性质（~~废话~~）：
    - 流量是不会大于容量的，即 $c(u,v) \ge f(u,v)$。
    - 进多少出多少，即进来的流量等于出来的流量。源点和汇点除外。
- 流量：从 $s$ 出发的流的和，当然也等于汇入 $t$ 点的流的和。
- **最大流量**：顾名思义，即最大的流量。类比最多能运的货重。
- 最大流：类比最优运货方案。
- **割**：将图中所有点分到两个点集中，其中 $s$ 和 $t$ 点不在同一个点集中，割表示所有连接两点所在点集不同的点的边的集合，割的容量就是割中所有边的容量之和。
- 最小割：容量最小的割。
- **残量**：容量和流量之差
- **残量网络**：任意时刻残量大于 $0$ 的边（还能再运货）构成的图。
- **增广路**：残量网络上的一条从源点 $s$ 到汇点 $t$ 的路径。

## Part. 1：最大流问题 —— Dinic 算法

最大流问题顾名思义就是求最大流（量）的问题。

### Edmonds–Karp 算法

核心思想：不断用 BFS 找增广路（当然是在残量网络上找了），并让答案和增广路上的每条边增加路径上每条边的残量容量最小值。

但是不能保证正确性。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/xil9audr.png)

若程序选择了 $s \to 1 \to 3 \to t$ 这条贡献仅为 $1$ 路径，那么最终算出的最大流就为 $9$。但容易发现，选择 $s \to 1\to 4 \to t$、$s \to 2 \to t$ 和 $s \to 2 \to 3 \to t$ 可以算出最大流为 $10$。

这时，我们用给每条边建一个反向边来实现“反悔”。每次给某条边加上流 $x$ 之后，给他反边的容也量加上 $x$，如果在后续我们走过了这条反边，相当于把原先走这条边加的流抵消掉了，叫做退流操作。如上面那个例子：我们即使走了 $s \to 1 \to 3 \to t$，也可以通过建的反边 $3 \to 1$，走过 $s \to 2 \to 3 \to 1 \to 4 \to t$ 把 $1 \to 3$ 退掉，如此一来，就等价于走 $s \to 1\to 4 \to t$ 和 $s \to 2 \to 3 \to t$。

最大流最小割定理：**最大流量等于最小割的容量**（因为割是从 $s$ 到 $t$ 的必经之路）。据此可知其正确性。

另外，Edmonds–Karp 算法的时间复杂度为 $O(nm^2)$。

### Dinic 算法

#### 思路

考虑在增广前先对图做 BFS 分层（就是按点到 $s$ 的最短距离分成一层一层的）。设点 $u$ 到 $s$ 的最短距离为 $dis_u$，只考虑连接点 $u,v$ 的满足 $dis_u+1=dis_v$ 且残量大于 $0$ 的边，用这些边找增广路。复杂度大概为 $O(n^2m)$。

具体的，Dinic 算法的流程如下。

1. BFS 分层。
1. DFS 出极大增广流 $f_b$。
1. $f \leftarrow f + f_b$。
1. 重复以上过程直到不存在从 $s$ 到 $t$ 的路径。

#### 当前弧优化

DFS 时，每遍历到一个点，我们会遍历它的部分出边。那么当下一次再访问该节点时，之前遍历过的出边到汇点的流一定已经被流满而没有可行的路线了，因而再次遍历它就没有任何意义了。所以我们可以在每次枚举该节点的出边时，改变枚举的起点，这样就可以忽略起点以前的所有出边，来达到优化剪枝的效果。据此，对于每个结点 $u$，我们可以维护的 $u$ 出边表中第一条还有必要尝试的出边。

#### 多路增广

多路增广是 Dinic 算法的一个常数优化：如果我们在层次图上找到了一条从 $s$ 到 $t$ 的增广路 $p$，则接下来我们未必需要重新从 $s$ 出发找下一条增广路，而可能从 $p$ 上最后一个仍有剩余容量的位置出发寻找一条岔路进行增广。考虑到其与回溯形式的一致性，这一优化在 DFS 的代码实现中也是自然的。

#### 参考代码

下面是 Dinic 算法解决 [P3376](https://www.luogu.com.cn/problem/P3376) 的代码。

一定要记得第 46 行判断 `e[i].c>0`！应该没人和我一样犯这么唐氏的错误吧。

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<climits>
#define min(A,B) ((A)<(B)?(A):(B))
using namespace std;
inline int read(){
	register int X=0; register char C=getchar();
	while(C<'0'||'9'<C) C=getchar();
	while('0'<=C&&C<='9'){X=(X<<3)+(X<<1)+(C^48);C=getchar();}
	return X;
}
const int N=202,M=1e4+2;
int n,m,s,t,head[N],tot=1,cur[N],dis[N];
long long ans;
struct edge{int to,Next;long long c;}e[M];

void adde(int u,int v,long long w){
	e[++tot]=(edge){v,head[u],w};
	head[u]=tot;
}

bool bfs(){
	queue<int> q;
	dis[s]=1;
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(register int i=head[u];i;i=e[i].Next){
			int v=e[i].to;
			if(e[i].c>0&&!dis[v]){
				dis[v]=dis[u]+1;
				q.push(v);
//				if(v==n) return true;
//				如果加上这句,一定要记得在每次BFS前清空队列!
			}
		}
	}
	return dis[t]!=0;
}

long long dfs(int u,long long f){//f - flow
	if(u==t||!f) return f;
	long long res=0;
	for(register int &i=cur[u];i;i=e[i].Next){
		int v=e[i].to;
		if(e[i].c>0&&dis[v]==dis[u]+1){//判断残量必不可少!
			long long x=dfs(v,min(e[i].c,f-res));
			e[i].c-=x,e[i^1].c+=x,res+=x;
			if(f==res) return res;
		}
	}
	return res;
}

int main(){
	n=read(),m=read(),s=read(),t=read();
	for(int i=1,u,v;i<=m;i++){
		u=read(),v=read();
		adde(u,v,(long long)read()),adde(v,u,0);
	}
	while(bfs()){
		for(int i=1;i<=n;i++) cur[i]=head[i];
		ans+=dfs(s,LLONG_MAX);
		memset(dis,0,sizeof(int)*(n+1));
	}
	printf("%lld",ans);
	return 0;
}
```

## Part. 2：最大流问题 —— ISAP 算法

### 算法流程

在 Dinic 算法中，我们每次求完增广路后都要跑 BFS 来分层，考虑更高效的 ISAP 算法。

ISAP 算法与 Dinic 的大体思路类似，先跑 BFS 对图上的点进行分层，不过与 Dinic 略有不同的是，我们选择在反图上，从 $t$ 点向 $s$ 点进行 BFS。执行完分层过程后，我们通过 DFS 来找增广路。增广的过程和 Dinic 类似，我们只选择比当前点层数少 $1$ 的点来增广，同时使用当前弧优化。

与 Dinic 不同的是，我们并不会重跑 BFS 来对图上的点重新分层，而是**在增广的过程中就完成重分层过程**。

具体来说，设 $u$ 号点的层为 $d_u$，当我们结束在 $u$ 号点的增广过程后，我们遍历残量网络上的所有点 $u$ 出边，找到层最小的出点 $v$，随后令 $d_u\gets d_v+1$。特别地，若残量网络上 $u$ 无出边，则 $d_u \gets n$。容易发现，当 $d_s\ge n$ 时，图上不存在增广路，此时即可终止算法。

### GAP 优化

我们记录层数为 $i$ 的点的数量 $a_i$，每当将一个点的层数从 $x$ 更新到 $y$ 时，同时更新 $a$ 数组的值，若在更新后 $a_x=0$，则意味着图上出现了断层，无法再找到增广路，此时可以直接终止算法（实现时直接将 $d_s$ 标为 $n$）。

---

###### 参考和引用

- [OI-Wiki](https://oi-wiki.org/graph/flow/max-flow)（尤其是 Part. 2，懒得再打一遍就直接摘抄了，因为加了不好看所以没加引用感到抱歉）。

---

## 作者：all_for_god (赞：2)

网络流是求网络最大流的算法，看似没什么用，实际上很多题目都可以通过建图转化为网络最大流问题。

# [P3376 【模板】网络最大流](https://www.luogu.com.cn/problem/P3376)

## 概念

“网络最大流问题” 本身是指从一个原点 $s$ 往外流水，这个原点本身有无穷多水可以流，有 $m$ 根双向管道连接 $n$ 个节点，每个节点都有一个最大流量，指的是这根水管最大可以承载的水流量。有一个汇点 $t$，问从原点向汇点流水的最大流量。

## 反向边

容易想到，如果现在图上还有路可以走，即还有一条路可以让水流到 $t$，我们将这种路称为增广路。那么将这条增广路流了一定不亏。但这样并不能保证最优，那么通过什么方法来保证我流了这条路后面还有办法反悔呢？这里有一种非常巧妙的方法。为每一条边建一条权值为零的反边。如果我们发现某条路不优，那么就可以流回去（毕竟流量可以随意分配）。我们对于这种路并不需要特殊处理，就像 dfs 的回溯一样，是对最优解的自发寻找。只需要每次流过一条边时，使其反边的流量加上这次的流量（因为正边会减少这次的流量）。

![1](https://cdn.luogu.com.cn/upload/image_hosting/h5j0sttj.png)

假设这是初始的状态。

![2](https://cdn.luogu.com.cn/upload/image_hosting/17wex2ha.png)

假设经过了一次增广（就是把某条增广路走满）后的图是这样的（这里的蓝色值是反边的流量）。这里如果没有反向边，那么程序就已经结束了（因为找不出增广路了）。但显然这并不是最优解。因此反向边的作用就凸显出来了。

![3](https://cdn.luogu.com.cn/upload/image_hosting/h9tv275s.png)

在有反向边的情况下，显然还有一条绿色的增广路。这时才真正意义上找到了最优解。观察最终状态，发现中间那条路实际上是没走的。因此，反边的作用就是对可能不优的方案进行“反悔” 操作。

## dinic 算法

综上，我们具体需要解决两个问题：

1. 找到是否有增广路。
2. 对增广路进行修改并统计答案。

对于是否有增广路的问题，可以直接用 bfs 来寻找。但是，在 bfs 的过程中，我们还需要建立分层图，即给每个点维护其到 $s$ 的最小边数。这里，还是以上图为例，给上图标上层数。

为什么要标上层数呢？因为如果我们发现原图有增广路，那么就可以从 $s$ 开始 dfs，依次算增广路。这里的图不是很好，如果有一个点最大流量比较大，那其就可以给很多与其相连的边分流量。如果没标层数，那这个边与其反边就可能反复互相流，造成极大的时间浪费。如果我们按照层数一层一层流，就可以保证每次都能靠近 $t$。同时，由于层数的限制，我们可以一次增广多条增广路。

但是，这里还是有些问题。相邻两个点 $u$、$v$ 间的层数差并不是 1，就可能造成无法增广的情况。事实上，这种情况是没有影响的。由于每次增广完后都会重新 bfs，重新计算层数，因此上述情况证明 $u$ 到 $v$ 这条路并不是到 $t$ 的最短路，就算这条路会在最终的答案中，也会在 $u$ 多次被增广后与 $v$ 层数相差一，即 $u$、$v$ 两个点在到 $t$ 的同一条相对短的路径上。

### 当前弧优化

这个算是比较好理解的一条优化。在同一次 dfs 中，对于其枚举的前几条边，其到 $t$ 的路径一定是被流满了的。如果再次 dfs 到这个点，那就不用考虑这前几个已经被流满了的点了。

### 几个小细节

1. 由于对于流了的每条边，我们都要对其反边加上其流量，因此这里考虑用链式前向星，点的编号从 1 开始，在加边的时候正反边一起相邻加，对于某边的反边，其编号就是边的编号异或 1。
2. 在 dfs 时，如果某个点无法流到 $t$，即流量为 0，就将其层数设为 $\infty$，让其不再被更新（注意改层数只是对于这一次 dfs 而言，对下一次没有影响）。
3. 注意每次 bfs 时将当前弧优化的数组以及层数初始化回去。

### 时间复杂度

注意到 dinic 每次分层，汇点的层数是单调递增的，因此增广的轮数是 $O(n)$ 的。
对于每一次增广，可以发现 dfs 找到一条增广路的时间不会超过 $O(n)$，而当前弧的状态数不会超过 $m$。

因此正常 dinic 的时间复杂度是 $O(n^2m)$ 的。
同时，一般而言 dinic 在 OI 中有点难卡满。有人说这东西随机的话甚至可以看做是线性的，也不知道是不是对的。

### 网络流在二分图中的应用

对于每个左边的点都向另一个点 $s$ 连一条权值为 0 的边，右边的点也都向 $t$ 连一条权值为 0 的边，中间的点照常连接，权值都为 1。跑出来的最大流就是最大匹配，正确性其实相对显然。时间复杂度 $O(\sqrt{n}m)$。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=5e5+10;
const ll inf=1e18+10;
ll n,m,s,t,head[N],tot=1,dep[N],now[N],ans=0;
//now->当前弧优化数组 tot从1开始 
struct node
{
	ll nxt,to;
 ll val;
}e[N];

void add(ll u,ll v,ll w)
{
	e[++tot].nxt=head[u];
	head[u]=tot;
	e[tot].to=v;
	e[tot].val=w;
}

bool bfs()
{
	for(ll i=1;i<=n;i++) dep[i]=inf;//记得初始化 
	queue <ll> q;
	q.push(s);dep[s]=1;
	now[s]=head[s];                //同样得初始化 
	while(!q.empty())//广搜 
	{
		ll u=q.front();q.pop();
		for(ll i=head[u];i;i=e[i].nxt)
		{
			ll v=e[i].to;
			if(e[i].val&&dep[v]==inf)
			{
				q.push(v);
				now[v]=head[v];
				dep[v]=dep[u]+1;
				if(v==t) return 1;
			}
		}
	}
	return 0;
}

ll dfs(ll u,ll sum)
{
	if(u==t) return sum;
	ll k=0,res=0;
	for(ll i=now[u];i;i=e[i].nxt)
	{
		now[u]=i;
		ll v=e[i].to;
		if(e[i].val&&dep[v]==dep[u]+1)
		{
			k=dfs(v,min(sum,e[i].val));//尽可能流最大流量 
			if(k==0) dep[v]=inf;       //流不到汇点 
			e[i].val-=k;e[i^1].val+=k;//其反边加 
			res+=k,sum-=k;
			if(!sum) break;
		}
	}
	return res;
}

int main()
{
	cin>>n>>m>>s>>t;
	for(int i=1,u,v,w;i<=m;i++)
	{
		cin>>u>>v>>w;
		add(u,v,w);add(v,u,0);//建权值为0的反向边 
	}
	while(bfs())
	{
		ans+=dfs(s,inf);//不断找增广路 
	}
	cout<<ans<<endl;
}
```

---


# [TJOI2013] 攻击装置

## 题目描述

给定一个 01 矩阵，其中你可以在 0 的位置放置攻击装置。每一个攻击装置 $(x,y)$ 都可以按照“日”字攻击其周围的 $8$ 个位置 $(x-1,y-2)$，$(x-2,y-1)$，$(x+1,y-2)$，$(x+2,y-1)$，$(x-1,y+2)$，$(x-2,y+1)$，$(x+1,y+2)$，$(x+2,y+1)$。

求在装置互不攻击的情况下，最多可以放置多少个装置。

## 说明/提示

对于 $30\%$ 的数据，保证 $N \le 50$。

对于 $100\%$ 的数据，保证 $N \le 200$。

## 样例 #1

### 输入

```
3
010
000
100```

### 输出

```
4```

# 题解

## 作者：zhangyuxing (赞：14)

这道题要用到匈牙利算法，如果不会的话请去[P3386](https://www.luogu.org/problemnew/solution/P3386)学习一下
____
1.这题首先要想到染色，就是把矩阵像棋盘一样黑白染色。代码实现考虑行列和奇偶性（向上一格不同色，向上二个同色；斜上方，也就是横一竖一同色）。

判断黑白代码如下:
```cpp
x+y&1//x是行，y是列
```

然后发现装置只能攻击不同色区域（这才是染色的目的：将矩阵转化为二分图）
___
2.建模转换

最后能放的装置数 = 初始没有放障碍的位置数 - 最后不能放装置的位置数

由于这是个二分图，所以显然有二分图最小顶点覆盖 = 二分图最大匹配。

转换为二分图最大匹配，匈牙利算法或网络流均可解决，这里介绍匈牙利算法。
___
3.算法过程

(1)读入的同时累加点的编号/计算无障碍点的个数/前向星连边

(2)判断行列和的奇偶性，如果为奇就跑一遍find函数。

(3)输出
___
4.算法细节

(1)读入矩阵用scanf，类型%1d就可以解决了。

(2)连边只需要向下边连，因为上面的已经读入了；还有连边时判一下边界。

___
5.代码(c++)

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
struct edge{int to,next;}e[400010];
bool book[40050],map[205][205];
int cnt,num[205][205],head[40050],match[40050];
int dir1[4]={1,2,2,1},dir2[4]={2,1,-1,-2};
void add(int x,int y)
{
    e[++cnt].next=head[x];
    e[cnt].to=y;
    head[x]=cnt;
}
bool dfs(int x)
{
    int y,i;
    for(i=head[x];i;i=e[i].next)
    {
    	y=e[i].to;
        if(book[y])continue;
        book[y]=1;
        if(!match[y]||dfs(match[y]))
        {
            match[y]=x;
            return 1;
        }
    }
    return 0;
}
int main()
{
    int n,sum=0,ans=0,tot=0,i,j,k;
    scanf("%d",&n);
    for(i=1;i<=n;++i)
    for(j=1;j<=n;++j)
    {
        scanf("%1d",&map[i][j]);
        num[i][j]=++tot;sum+=(!map[i][j]);
        if(!map[i][j])
        for(k=0;k<4;++k)
        if((i>dir1[k])&&(j>dir2[k])&&(j-dir2[k]<=n)&&(!map[i-dir1[k]][j-dir2[k]]))
        {
            add(num[i][j],num[i-dir1[k]][j-dir2[k]]);
            add(num[i-dir1[k]][j-dir2[k]],num[i][j]);
        }
    }
    for(i=1;i<=n;i++)
    for(j=1;j<=n;j++)
    if((i+j&1)&&!map[i][j])
    {
    	memset(book,0,sizeof(book));
        ans+=dfs(num[i][j]);
    }
    printf("%d",sum-ans);
    return 0;
}
```


---

## 作者：Heartlessly (赞：9)

## Description

给定一个大小为 $n \times n$ 的 $01$ 矩阵，其中你可以在 $0$ 的位置放置攻击装置。每一个攻击装置 $(x,y)$ 都可以按照“日”字攻击其周围的 $8$ 个位置。求在装置互不攻击的情况下，最多可以放置多少个装置。

$(1 \leq n \leq 200)$

## Solution

与 **网络流 24 题** 中的 **骑士共存问题** 几乎一样。

我们可以先将棋盘染色，得到

![VuqMYd.png](https://s2.ax1x.com/2019/05/29/VuqMYd.png)

对于格子 $(x,y)$，若 $x + y$ 是奇数，则该格子为白色，否则为黑色。

很容易发现，放在白（黑）色格子上的攻击装置只能攻击到黑（白）色格子。

那么显然这是一个二分图。

我们把白色格子和黑色格子分成两部分。

如果某个白色格子可以攻击到某个黑色格子，则在它们之间连一条边。

一条边所连接的两个格子只能取其中一个（否则会互相攻击），所以问题变为求这个二分图的 **最大独立集** 。

**最大独立集 = 总点数 - 最小点覆盖 = 总点数 - 最大匹配数**

至于不能放攻击装置的格子，我们不把它当做二分图中的点即可，最后答案要减去这些点。

所以用 $\rm dinic$ 跑一遍最小割（最大流）就能够得到答案了。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

template <class T>
inline void read(T &x) {
    x = 0;
    char c = getchar();
    bool f = 0;
    for (; !isdigit(c); c = getchar()) f ^= c == '-';
    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
    x = f ? -x : x;
}

inline void readDigit(bool &x) {
    x = 0;
    char c = getchar();
    for (; !isdigit(c); c = getchar());
    x = c ^ 48;
}

template <class T>
inline void write(T x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    T y = 1;
    int len = 1;
    for (; y <= x / 10; y *= 10) ++len;
    for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);
}

const int MAXP = 200, MAXN = 5e4, MAXM = 1e6, INF = 0x3f3f3f3f;
const int dx[8] = { 1, 2, -1, -2, -1, 2, 1, -2 };
const int dy[8] = { 2, 1, -2, -1, 2, -1, -2, 1 };
int n, tot = 1, sum, id[MAXP + 5][MAXP + 5], head[MAXN + 5];
int cur[MAXN + 5], depth[MAXN + 5];
bool f[MAXP + 5][MAXP + 5];
struct Edge {
    int next, to, dis;
} e[MAXM + 5];

inline void addEdge(int u, int v, int w) {
    e[++tot] = (Edge) { head[u], v, w };
    head[u] = tot;
}

inline void build(int x, int y) {
    for (int i = 0; i < 8; ++i) {
        int tx = x + dx[i], ty = y + dy[i];
        if (tx < 1 || ty < 1 || tx > n || ty > n || f[tx][ty]) continue;
        addEdge(id[x][y], id[tx][ty], INF), addEdge(id[tx][ty], id[x][y], 0);
        //如果 (x,y) 能攻击到点 (tx,ty)，则在它们之间连一条边 
    }
}

inline bool bfs(int s, int t) {//找增广路 
    for (int i = 0; i <= t; ++i) cur[i] = head[i];
    memset(depth, 0, sizeof (depth));
    queue<int> q;
    depth[s] = 1;
    q.push(s);
    for (; !q.empty(); ) {
        int u = q.front();
        q.pop();
        for (int v, w, i = head[u]; v = e[i].to, w = e[i].dis, i; i = e[i].next) {
            if (depth[v] || !w) continue;
            depth[v] = depth[u] + 1;
            if (v == t) return 1;
            q.push(v);
        }
    }
    return 0;
}

int dinic(int u, int t, int flow) {
    if (u == t) return flow;
    int rest = flow;
    for (int v, w, i = cur[u]; v = e[i].to, w = e[i].dis, i && rest; i = e[i].next) {
        cur[u] = i;//当前弧优化 
        if (depth[v] != depth[u] + 1 || !w) continue;
        int k = dinic(v, t, min(rest, w));
        if (!k) depth[v] = 0;
        else {
            e[i].dis -= k;
            e[i ^ 1].dis += k;
            rest -= k;
        }
    }
    return flow - rest;
}

inline int minCut(int s, int t) {//求最小割 
    int res = 0;
    for (; bfs(s, t); ) res += dinic(s, t, INF);
    return res;
}

int main() {
    read(n);
    int s = 0, t = n * n + 1;//超级源点 s 与 超级汇点 t 
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j) {
            readDigit(f[i][j]);
            sum += f[i][j];//不能放攻击装置的点的数量 
        }
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j) {
            id[i][j] = (i - 1) * n + j;//点的编号
            if (f[i][j]) continue;
            if ((i + j) & 1)//源点向白色格子连一条流量为 1 的边 
                addEdge(s, id[i][j], 1), addEdge(id[i][j], s, 0);
            else //黑色格子向汇点连一条流量为 1 的边 
                addEdge(id[i][j], t, 1), addEdge(t, id[i][j], 0);
        }
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            if ((i + j) & 1) build(i, j);//白色格子与黑色格子连边 
    write(n * n - sum - minCut(s, t));//最大独立集 
    putchar('\n');
    return 0;
}
```



---

## 作者：让风忽悠你 (赞：3)

## P4304 [TJOI2013]攻击装置

[原题](https://www.luogu.com.cn/problem/P4304)

## 题意
- 给出一个 01 矩阵，可以在 0 处放置攻击装置。

- 每个攻击装置以 “ 日 ” 字攻击周围，要求所有攻击装置互相攻击不到。

## 分析
可以把这个 01 矩阵当作一个黑白相间的棋盘

![](https://cdn.luogu.com.cn/upload/image_hosting/523gyu3z.png)

不难发现同颜色的点是无法互相攻击的。

所以可以把黑点和白点分为两个点集，这就转换为了求最大独立集。

最大独立集 = 总点数 - 最大匹配，考虑到这题还有些点不能走，所以还要减去不能走的点数。

## 做法
- 从黑色的点向超级源点连边，白色的点向超级汇点连边，流量都为 1。

- 每个黑点向能攻击到的白点连一条流量为 inf 的边

## 代码
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
#define N 1000005
#define M 4000005
#define inf 1e9
#define id(i,j) (i-1)*n+j//求出编号 

using namespace std;

int ax[8]={1,1,-1,-1,2,2,-2,-2},ay[8]={2,-2,2,-2,1,-1,1,-1};//走日字 
int n,m,s,t,tot=1,ans,sum,now,cn;
int dep[N],head[N],lnk[N];
bool map[1005][1005];
struct node{
	int next,to,val;
}e[M];

inline int read(){
    int x=0,k=1; char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')k=-1;c=getchar();}
    while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*k;
}

inline void add(int u,int v,int w){
	e[++tot].to=v;
	e[tot].val=w;
	e[tot].next=head[u];
	head[u]=tot;
	e[++tot].to=u;
	e[tot].val=0;
	e[tot].next=head[v];
	head[v]=tot;
}

inline int bfs(int s,int t){
	memset(dep,0,sizeof(dep));
	memcpy(lnk,head,sizeof(head));
	queue <int> q;
	q.push(s);
	dep[s]=1;
	int u,v;
	while(!q.empty()){
		u=q.front(); q.pop();
		for(int i=head[u];i;i=e[i].next){
			v=e[i].to;
			if(e[i].val && !dep[v]){
				dep[v]=dep[u]+1;
				q.push(v);
			}
		}
	}
	return dep[t];
}

int dfs(int u,int t,int into){
	if(u==t) return into;
	int out=0,res;
	int v;
	for(int i=lnk[u];i && out<into;i=e[i].next){
		v=e[i].to;
		if(e[i].val && dep[v]==dep[u]+1){
			res=dfs(v,t,min(e[i].val,into-out));
			if(res){
				e[i].val-=res;
				e[i^1].val+=res;
				out+=res;
			}
		}
	}
	if(out<into) dep[u]=-1;
	return out;
}

inline int dinic(int s,int t){
	int ans=0;
	while(bfs(s,t)){
		int x;
		while((x=dfs(s,t,inf))) ans+=x;
	}
	return ans;
} 

int main(){
	n=read();
	int u,v,w,x,y;
	s=0; t=n*n+1;
	sum=n*n;//总点数 
	char ch;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){	
			scanf(" %c",&ch);
			if(ch=='1'){
				cn++;//统计不能走的点数 
				map[i][j]=1;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(map[i][j]) continue;
			if((i+j)&1) add(s,id(i,j),1);//假设奇数点就是黑点 
			else add(id(i,j),t,1);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if((i+j)&1){
				for(int k=0;k<8;k++){
					x=i+ax[k]; y=j+ay[k];
					if(x<1 || x>n || y<1 || y>n || map[x][y]) continue;
					add(id(i,j),id(x,y),inf);
				}
			} 
		}
	}
	printf("%d",sum-cn-dinic(s,t));
	return 0;
}
```

---

## 作者：miao5 (赞：2)

~~这题应该算不上紫吧。~~

**题目大意：**

有一个01矩阵，你可以在0的位置放中国象棋中的一匹马，求在互不攻击的情况下最多能放多少匹马。

**思路：**

我们可以先抛开01矩阵的问题不管。

我们对图黑白染色后看这个马的走法。

我们不难发现如果一匹马在黑格中，那么它能攻击到的所有的点一定都是白点。如果一匹马在白格中同理。

这样我们就可以把这个图变成一个二分图。

把可以相互攻击的点之间连边，之后我们的问题就转变成求最大独立点集了。

而我们知道最大独立点集就等于总点数减最大匹配数。

之后这题就做完了。

更多细节在代码里。

**code:**

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=205;
int head[N*N*2],to[N*N*8],nxt[N*N*8],cnt=1,n,ans,tot=0;
int vis[N*N*2],cp[N*N*2];
int fx[9]={0,-1,-2,1,2,-1,-2,1,2};
int fy[9]={0,-2,-1,-2,-1,2,1,2,1};//控制方向数组。 
char s[N][N];
void add(int u,int v){
	to[cnt]=v;
	nxt[cnt]=head[u];
	head[u]=cnt++;
} 
bool dfs(int x){
	for(int i=head[x];i;i=nxt[i]){
		int v=to[i];
		if(vis[v]) continue;
		vis[v]=true;
		if(!cp[v]||dfs(cp[v])){
		    cp[v]=x;
	    	return true;
		}
	}
	return false;
}//匈牙利算法板子 
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>s[i]+1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(s[i][j]=='1'){
			    tot++;
			    continue;
			}//记录不能放马的点的个数。 
			for(int k=1;k<=8;k++){
				int x=i+fx[k],y=j+fy[k];
				if(s[x][y]=='1') continue; 
				if(x>=1&&x<=n&&y>=1&&y<=n&&(i+j)%2==0) add((i-1)*n+j,(x-1)*n+y+n*n);
				//在可以相互攻击的点之间连边。 
			} 
		}
	}
	for(int i=1;i<=n*n;i++){
		memset(vis,0,sizeof(vis));
		int k=dfs(i);
		ans+=k;//统计最大匹配数。 
	}
	printf("%d\n",n*n-tot-ans);//输出最大独立点集=总点数-最大匹配数。 
	return 0;
}
```


---

## 作者：ShineEternal (赞：2)

# 写在前面：
如想获取更佳阅读效果，请点击[这里](https://blog.csdn.net/kkkksc03/article/details/88624189),任何疑问欢迎私信作者！


# 题目链接：
https://www.luogu.org/problemnew/show/P4304
# 分析：
### 最大独立集

最大独立集=总点数-最大匹配数

独立集：点集，图中选一堆点，这堆点两两之间没有连边

最大独立集：尽可能多得选点，使得其满足独立集的性质

这是网络流二分图经典题目，值得练习
# 代码：

```cpp
#include<cstdio>
#include<utility>
#include<vector>
using namespace std;
int x[9]={0,-1,-2,1,2,-1,-2,1,2};
int y[9]={0,-2,-1,-2,-1,2,1,2,1};
struct ben
{
    int first,second;
};
vector<ben> v[205][205];
int a[205][205]; 
ben link[205][205];
int vis[205][205]; 
int t;
bool find(ben andd)
{
    int x=andd.first;
    int y=andd.second;
    for(int i=0;i<v[x][y].size();i++)
    {
        int p=v[x][y][i].first;
        int q=v[x][y][i].second;
        if(vis[p][q]!=t)
        {
            vis[p][q]=t;
            int ls=link[p][q].first;
            int ls2=link[p][q].second;
            if((ls==0&&ls2==0)||find(link[p][q]))
            {
                link[p][q].first=x;
                link[p][q].second=y;
                return 1; 
            }
        }
    }
    return 0;
}
int main()
{
    int n;
    scanf("%d",&n);
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            scanf("%1d",&a[i][j]);
            if(a[i][j]==0)
            ans++;
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            for(int k=1;k<=8;k++)
            {
                int xx=i+x[k];
                int yy=j+y[k];
                if(xx<=0||xx>n||yy<=0||yy>n)
                continue;
                ben tmp;
                tmp.first=xx;
                tmp.second=yy;
                if(a[xx][yy]==0)
                {
                    v[i][j].push_back(tmp);
                }
            }
        }
    }
    int cnt=0;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(a[i][j]==1)
            continue;
            t++;
            ben tmp;
            tmp.first=i;
            tmp.second=j;
            if(find(tmp))
            {
                cnt++;
            }
            //else
            //break;
        }
    }
    printf("%d\n",ans-cnt/2);
    return 0;
} 
```



---

## 作者：crescentic (赞：1)

纪念一下一遍过~

[题目链接](https://www.luogu.com.cn/problem/P4304)

**题目分析**：

大意：在给定位置限制的前提和攻击范围的前提下，求能放置的最多装置数。

将攻击范围更直观的表示出来，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/1q57l20q.png)

嗯。。。然而并没有神马用。

看题意将攻击坐标表示出来，肯定有用，尝试将横纵坐标的值加起来（为了方便，下文以**和**代替为横纵坐标之和）：

所以我们发现，**攻击坐标的和的奇偶性恰好与原坐标相反**，也就意味着**和的奇偶性相同的两个点必然不会相互攻击**，所以我们就可以利用源汇点将两种点区分开来。

那么建图方式就很显然了：

- 如果和为奇数，从源点向该节点建有向边，边权为$1$(题意求的是数量)；
- 反之，从该节点向汇点建有向边，边权为$1$;

再考虑八个方向的攻击：

因为相互攻击的点不能同时选，所以在两个点之间建有向边，边权为 $inf$。

边权为极大值的原因：根据网络流的特性，最小割不能在边权为极大值的边上，所以为了保证割边一定与源点或汇点相连，赋为极大值。

最后，就是模板求最小割了。

**完整代码**：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
#define rt register int
#define int long long
const int N = 4e4 + 10, M = 1e6 + 10, inf = 1e10;
struct node {
	int to,nex;
}e[M];
int n,s,t,top,ed,dep[N],head[N],cur[N],tot = 1,f[M],q[N],ans;
int a[8][2] = {{-1,-2},{-2,-1},{1,-2},{2,-1},{-1,2},{-2,1},{1,2},{2,1}};
char map[205][205];
inline void add(int x,int y,int w) {
	e[++tot] = (node) {y,head[x]}, f[tot] = w, head[x] = tot;
	e[++tot] = (node) {x,head[y]}, head[y] = tot; 
}
inline bool bfs() {
	memset(dep,-1,sizeof(dep));
	dep[s] = 0, cur[s] = head[s], q[top = 1] = s; ed = 1;
	int now,ver;
	while(top <= ed) {
		now = q[top++];
		for(rt i = head[now]; i; i = e[i].nex) {
			ver = e[i].to;
			if(dep[ver] == -1 && f[i]) {
				dep[ver] = dep[now] + 1, cur[ver] = head[ver];
				if(ver == t) return 1;
				q[++ed] = ver;
			}
		}
	}
	return 0;
}
inline int find(int x,int limit) {
	if(x == t) return limit;
	int flow = 0, tmp, ver;
	for(rt i = head[x]; i && flow < limit; i = e[i].nex) {
		ver = e[i].to;
		if(dep[ver] == dep[x] + 1 && f[i]) {
			tmp = find(ver,min(limit - flow,f[i]));
			if(!tmp) dep[ver] = -1;
			f[i] -= tmp, f[i ^ 1] += tmp, flow += tmp; 
		}
	}
	return flow;
}
inline int dinic() {
	int flow;
	while(bfs()) ans -= find(s,inf);
	return ans;
}
inline void read(int &x) {
	x = 0;
	char s = getchar();
	while(s < '0' || s > '9') s = getchar();
	while(s <= '9' && s >= '0') {x = x * 10 + s - '0', s = getchar(); }
}
inline int pos(int x,int y) {
	return n * (x - 1) + y;
} 
signed main() {
	read(n);
	s = n * n + 1, t = s + 1;
	int tx,ty;
	for(rt i = 1; i <= n; i ++) {
		scanf("%s",map[i] + 1);
		for(rt j = 1; j <= n; j ++) {
			if(map[i][j] == '1') continue;
			ans ++;
			if((i + j) & 1) {
				add(s,pos(i,j),1);
				for(rt k = 0; k < 8; k ++) {
					tx = i +a[k][0], ty = j +a[k][1];
					if(tx < 1 || ty < 1 || tx > n || ty > n || map[tx][ty] == '1') continue;//注意要判断该节点是否能放置装置 
					add(pos(i,j),pos(tx,ty),inf);
				}
			}
			else add(pos(i,j),t,1);
		}
	}
	printf("%d",dinic());
	return 0; 
}
```


---

## 作者：Link_Space (赞：1)

题目中有这样几个点：“最多的”“互相不攻击的”，那么只需要这两点我们其实就可以想到这道题是求一个这个图中的最大独立集，而最大独立集即是总点数减去最大匹配数，所以只需要用一个匈牙利把最大匹配数求出来，然后再用总点数减去最大匹配数，除此之外，我们还需要减去矩阵中所有1的数量，因为1的位置不可以放装置，所以不计入答案，以下是代码，不懂的同学可以看一看代码内注释。

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
typedef pair<int, int> PII;
int dx[8] = {1, -1, 1, -1, 2, -2, 2, -2};
int dy[8] = {2, -2, -2, 2, 1, -1, -1, 1};
bool vis[205][205];
bool aim[205][205];
int ans;
PII match[205][205];
int n, m;
bool already[205][205];
bool find(int x,int y)
{
    for (int i = 0; i < 8;i++)
    {
        int xx = x + dx[i];
        int yy = y + dy[i];
        if(xx<1||xx>n||yy<1||yy>n||vis[xx][yy]||aim[xx][yy])
            continue;//判断越界或者是该位置不可放
        aim[xx][yy]=1;
        if((match[xx][yy].first==0&&match[xx][yy].second==0)||find(match[xx][yy].first,match[xx][yy].second))//如果当前这个点还没有配对，或者与这个点配对的点可以重新配对
        {
            match[xx][yy] = {x, y};
            return true;//将两个点匹配，满足条件返回true
        }
    }
    return false;
}
int main()
{
    int cnt=0;
    scanf("%d", &n);
    for (int i = 1; i <= n;i++)
    {
        for (int j = 1; j <= n;j++)
        {
            char a;
            cin >> a;
            if(a=='1')
                vis[i][j] = 1;
        }
    }//只有0的地方才可以放，将1的地方标记起来
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            if (!vis[i][j] && ((i + j) & 1))//建二分图时按照行数+列数的奇偶性二分
            {
                memset(aim, 0, sizeof aim);
                if (find(i, j))
                    ans++;//求最大匹配数
            }
            else if (!already[i][j] && vis[i][j])
                cnt++, already[i][j] = 1;//算出所有1的数量
        }
    }
    printf("%d\n", n*n-cnt-ans);//最大独立集点数=总点数-最大匹配数-1的个数
}
```


---

## 作者：lolte (赞：1)

### 这是GD初二蒟蒻 $lolte$ 的题解

在暴刷网络流24题的时候，一位dalao跟我说：

> 有一道双倍经验题，就是这道什么攻击装置

然后我就过来这了。

[P3355 骑士共存问题(双倍经验)](https://www.luogu.org/problemnew/show/P3355)

---

### 题意：
- 在一个 $n*n$ 的棋盘中，有些可以放，有些不能放。求最多能放多少物品使得它们各自不在“日”字形的位置上。

### 转换：

- 将每个能放的点进行黑白染色，不难发现若各自会互相攻击，则它们必定不同色。显然，这是个二分图。

- 最后能放装置数 $=$ 初始能放位置数 $-$ 最后不能放装置的位置数

- 则由于这是个二分图，所以显然这是个二分图最小顶点覆盖 $=$ 二分图最大匹配。

- 二分图或者网络流解决即可。

我用了网络流：

- 则让可放置的异色点连边（容量为1），再让一色的点与源点相连（容量为1），另一色的点向汇点连边（容量为1），之后跑一遍网络流即可。

### code

dinic 99ms 无O2

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int x=0,f=0;
    char ch=getchar();
    for (;ch<'0'||ch>'9';ch=getchar()) f^=(ch=='-');
    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';
    return f ? -x : x;
}
const int inf=2147483600,maxn=40100,mov[8][2]={{1,2},{-1,2},{1,-2},{-1,-2},{2,1},{-2,1},{2,-1},{-2,-1}};
int n,m,dep[maxn],cur[maxn],head[maxn];
int maxflow=0,q[maxn*10],l,r,cnt=1,s,t;
bool mp[210][210],inq[maxn],vis;
struct node{
    int to,nxt,w;
}e[600000];
inline void add(int u,int v,int w) {
    ++cnt;
    e[cnt].to=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt;
    ++cnt;
    e[cnt].to=u; e[cnt].w=0; e[cnt].nxt=head[v]; head[v]=cnt;
}
bool bfs(){
    memset(dep,0x3f,sizeof(dep));
    memset(inq,0,sizeof(inq));
    memcpy(cur,head,sizeof(head));
    l=1;r=0;
    q[++r]=s; inq[s]=1; dep[s]=0;
    while (l<=r) {
        int u=q[l++];
        inq[u]=0;
        for (int i=head[u];i;i=e[i].nxt) {
            int v=e[i].to;
            if (e[i].w && dep[v]>dep[u]+1) {
                dep[v]=dep[u]+1;
                if (!inq[v]) {
                    inq[v]=1;
                    q[++r]=v;
                }
            }
        }
    }
    return dep[t]<9999999;
}
int dfs(int u,int flow){
    if (u==t) {
        maxflow+=flow;
        vis=1;
        return flow;
    }
    int goflow=0,used=0;
    for (int &i=cur[u];i;i=e[i].nxt) {
        int v=e[i].to;
        if (e[i].w && dep[v]==dep[u]+1) {
            goflow=dfs(v,min(flow-used,e[i].w));
            if (!goflow) continue;
            e[i].w-=goflow;
            e[i^1].w+=goflow;
            used+=goflow;
            if (used==flow) break;
        }
    }
    return used;
}
void dinic(){
    while (bfs()) {
        vis=1;
        while (vis) {
            vis=0;
            dfs(s,inf);
        }
    } 
}
int main(){
    n=read();
    s=n*n+5;
    t=s+1;
    for (int i=1;i<=n;++i) {
    	for (int j=1;j<=n;++j) {
    		scanf("%1d",&mp[i][j]);
    		if (mp[i][j]) ++m;
    	}
    }
    for (int i=1;i<=n;++i) {
        for(int j=1;j<=n;++j) {
            int pos=(i-1)*n+j;
            if (mp[i][j]) continue;
            if ((i+j)&1) {
                add(pos,t,1);
                continue;
            }
            add(s,pos,1);
            for (int k=0;k<8;++k) {
                int nx=i+mov[k][0],ny=j+mov[k][1];
                if (nx<1||ny<1||nx>n||ny>n||mp[nx][ny]) continue;
                add(pos,(nx-1)*n+ny,1);
            }
        }
    }
    dinic();
    printf("%d\n",n*n-maxflow-m);
    return 0;
}
```

---

## 作者：SWWWWWWWWWind (赞：1)

二分图染色之后的最大点独立集
先黑白点染色
S向黑点都连流量为1的边
白点都向黑点连流量为1的边
然后如果两个点，分别为黑点和白点，并且可以互相攻击，那么他们之间连边
最大点独立集=点数-最大匹配
最大匹配用dinic最大流实现
```
#include<iostream>
#include<algorithm>
#include<math.h>
#include<stdio.h>
#include<queue>
#include<string.h>
using namespace std;
const int S=40001,T=40002;
const int dx[23]={0,-2,-1,+1,+2,-2,-1,+1,+2};
const int dy[23]={0,-1,-2,-2,-1,+1,+2,+2,+1};
int head[500003],to[3000003],nxt[3000003],w[3000003],tot;
char mp[303][303];
int d[50005];
int n;
inline void add(int x,int y,int z){
	to[tot]=y,w[tot]=z,nxt[tot]=head[x],head[x]=tot++;
	to[tot]=x,w[tot]=0,nxt[tot]=head[y],head[y]=tot++;
}
bool bfs(){
	memset(d,0,sizeof(d));
	d[S]=1;
	queue<int>q;
	q.push(S);
	while(!q.empty()){
		int now=q.front();
		q.pop();
		for(int i=head[now];i!=-1;i=nxt[i]){
			if(d[to[i]]==0&&w[i]){
				d[to[i]]=d[now]+1;
				q.push(to[i]);
			}
		}
	}
	return d[T]!=0;
}
int dfs(int x,int flow){
	if(x==T){
		return flow;
	}
	int res=flow;
	for(int i=head[x];i!=-1;i=nxt[i]){
		if(d[to[i]]==d[x]+1&&w[i]){
			int mx=dfs(to[i],min(res,w[i]));
			res-=mx,w[i]-=mx,w[i^1]+=mx;
			if(!res){
				return flow;
			}
		}
	}
	return flow-res;
}
inline int dinic(){
	int ans=0;
	while(bfs()){
		ans+=dfs(S,999999);
	}
	return ans;
}
int main(){
	memset(head,-1,sizeof(head));
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>mp[i][j];
			if(mp[i][j]=='1'){
				continue;
			}
			if((i+j)%2==1){
				add(S,(i-1)*n+j,1);
			}else{
				add((i-1)*n+j,T,1);
			}
		}
	}
	int sum=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(mp[i][j]=='0'){
				sum++;
				if((i+j)%2==1){
					for(int k=1;k<=8;k++){
						int x=i+dx[k],y=j+dy[k];
						if(x>=1&&x<=n&&y>=1&&y<=n&&mp[x][y]=='0'){
							add((i-1)*n+j,(x-1)*n+y,1);
						}
					}
				}
			}
		}
	}
	cout<<sum-dinic()<<endl;
	return 0;
}
/*

in:
3
010
000
100

*/
```

---

## 作者：永不复行 (赞：1)

|2	1	2	1	2	1	2	1	2|
| -----------------------------: |
|1	2	1	2	1	2	1	2	1|
|2	1	2	1	2	1	2	1	2|
|1	2	1	2	1	2	1	2	1|
|2	1	2	1	2	1	2	1	2|
|1	2	1	2	1	2	1	2	1|
|2	1	2	1	2	1	2	1	2|
|1	2	1	2	1	2	1	2	1|
|2	1	2	1	2	1	2	1	2|

观察一下，发现满足

2点与1点恰为互相之间可攻击的点
所以只跑1点（（i^j）&1）

建边时只向上建可以省一些事，因为上方都被读入过

剩下就代码了


```
//p4303
#include<bits/stdc++.h>
```
```
using namespace std;
struct nw
{
	int t,n;
}nx[40050<<3];
const int d1[4]={1,2,2,1},d2[4]={2,1,-1,-2};
bool vis[40050];
int get_map[205][205],id[205][205],tot,cnt,h[40050],f[40050],n,m;
int read()
{
	char c;
	c=getchar();
	while(c>'9'||c<'0')
		c=getchar();
	return c-'0';
}
void add(int u,int v)
{
	nx[++cnt].n=h[u];
	nx[cnt].t=v;
	h[u]=cnt;
}
bool dfs(int x)
{
	for(int i=h[x];i;i=nx[i].n)
	{
		if(vis[nx[i].t])continue;
		vis[nx[i].t]=1;
		if(!f[nx[i].t]||dfs(f[nx[i].t]))
		{
			f[nx[i].t]=x;
			return 1;
		}
	}
	return 0;
}
int sum,ans;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			get_map[i][j]=read();
			id[i][j]=++tot;
			sum+=(1-get_map[i][j]);
			if(!get_map[i][j])for(int x=0;x<4;x++)
				if((i>d1[x])&&(j>d2[x])&&(j-d2[x]<=m)&&(!get_map[i-d1[x]][j-d2[x]]))
				{
					add(id[i][j],id[i-d1[x]][j-d2[x]]);
					add(id[i-d1[x]][j-d2[x]],id[i][j]);
				}
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		if((i^j)&1&&!get_map[i][j])
		{
			for(int ii=1;ii<=n*m;ii++)vis[ii]=0;
			ans+=dfs(id[i][j]);
		}
	printf("%d\n",sum-ans);
}
```


---

## 作者：大菜鸡fks (赞：1)

十分裸的最大独立集。匈牙利即可。每次数组不能清空，打时间戳

```cpp
#include<cstdio>
using namespace std;
const int N=205,M=400005;
int T,n,cnt,a[N][N];
int dx[4]={1,1,2,2},dy[4]={2,-2,1,-1};
char s[N];
inline void init(){
	scanf("%d",&n);
	for (int i=1;i<=n;i++){
		scanf("%s",s+1);
		for (int j=1;j<=n;j++){
			if (s[j]=='0') a[i][j]=++cnt;
				else a[i][j]=0;
		}
	}
}
struct edge{
	int link,next;
}e[M];
int tot,link[N*N],vis[N*N],head[N*N];
inline void add_edge(int u,int v){
	e[++tot]=(edge){v,head[u]}; head[u]=tot;
}
inline void insert(int u,int v){
	add_edge(u,v);
	add_edge(v,u); 
}
bool find(int u){
	for (int i=head[u];i;i=e[i].next){
		int v=e[i].link;
		if (vis[v]!=T){
			vis[v]=T;
			if (find(link[v])||!link[v]){
				link[v]=u;
				return 1;
			}
		}
	}
	return 0;
}
inline void solve(){
	for (int i=1;i<=n;i++){
		for (int j=1;j<=n;j++){
			if (a[i][j]){
				for (int k=0;k<4;k++){
					int x=i+dx[k],y=j+dy[k];
					if (x<1||x>n||y<1||y>n) continue;
					if (a[x][y]) insert(a[i][j],a[x][y]);
				}
			}
		}
	}
	int ans=0;
	for (int i=1;i<=cnt;i++){
		T++;
		if (find(i)){
			ans++;
		}
	}
	printf("%d\n",cnt-ans/2);
}
int main(){
	init(); 
	solve();
	return 0;
} 
```

---

## 作者：Reaepita (赞：1)

二分图匹配

求最大独立集

最大独立集=顶点数-最大匹配数

因为A匹配了B，B就会匹配A

所以最后的最大匹配数需要除以2

最后用匈牙利算法就可以过了

注意要用链式前向星

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
#define g(i,j) (i-1)*n+j
const int maxn=200*200+10,maxl=200000*10+10;
int dx[10]={0,-1,-2,1,2,-1,-2,1,2};  
int dy[10]={0,-2,-1,-2,-1,2,1,2,1};  
int vis[maxn],n,m,lin[maxn],head[maxn],cnt=0;
char a[210][210];
struct data
{
	int v,next;
}e[maxl];
void add(int u,int v)
{
	e[++cnt]=(data){v,head[u]};
	head[u]=cnt;
}
bool find(int u)
{
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].v;
		if(!vis[v])
		{
			vis[v]=1;
			if(lin[v]==-1||find(lin[v]))
			{
				lin[v]=u;
				return true;
			}
		}
	}
	return false;
}
int main()
{
	memset(lin,-1,sizeof(lin));
	int ans=0,sum=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		getchar();
		for(int j=1;j<=n;j++)
		a[i][j]=getchar();
	}
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	if(a[i][j]=='0')
	for(int k=1;k<=8;k++){
		int x=i+dx[k],y=j+dy[k];  
        if(x<1||x>n||y<1||y>n||a[x][y]=='1')continue;  
        add(g(i,j),g(x,y));  
	}
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	if(a[i][j]=='0'){
		sum++;
		memset(vis,0,sizeof(vis));
		if(find(g(i,j)))ans++;
	}
	printf("%d\n",sum-ans/2);
}
```

---

## 作者：Night_Bringer (赞：0)

[博客园食用更佳](https://www.luogu.com.cn/problem/P4304)。
# 题目简述
$n$ 行 $n$ 列的矩阵中，若该点为 $0$ ，则可以安放装置 $(x,y)$ ，若装置会攻击$(x-1,y-2)$ ， $(x-2,y-1)$ ， $(x+1,y-2)$ ， $(x+2,y-1)$ ， $(x-1,y+2)$ ， $(x-2,y+1)$ ， $(x+1,y+2)$ ， $(x+2,y+1)$ 这八个位置的装置。求最多可以放多少装置。
# 思路
最开始时，没啥思路，将一个装置在一张图中表示出来，攻击范围如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201222201256561.png?x-oss-,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZhY2VfdGhlX0JsYXN0,size_16,color_FFFFFF,t_70)

绿色点为蓝色点能够攻击到的点。可以发现很像国际象棋的棋盘，进一步做如下染色：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201222201633140.png?x-oss-,type_sYXN0,size_16,color_FFFFFF,t_70)

这样对比两张图，可以发现，白色点可以能够攻击到的点全都是黑色点，黑色点可以能够攻击到的点全都是白色点。白色点与白色点、黑色点与黑色点之间不会有联系。

这样的两个同一集合内的点互不关联，且有两个集合的问题不难转换成二分图来求解。其中，不妨设白色点为左部点，黑色点为右部点，构建一张二分图。

求解的问题是最大的互不攻击的装置，即可以转换为二分图的最大独立集问题。而最大独立集的点数等于二分图中所有点的个数减去最大匹配的边数，进而用网络最大流来求解。
# C++代码
```cpp
#include <queue>
#include <cstdio>
#include <vector>
#include <cstring>
using namespace std;
#define INF 0x3f3f3f3f
#define Min(a, b) ((a) < (b) ? (a) : (b))
void Quick_Read(int &N) {
	N = 0;
	int op = 1;
	char c = getchar();
	while(c < '0' || c > '9') {
		if(c == '-')
			op = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9') {
		N = (N << 1) + (N << 3) + (c ^ 48);
		c = getchar();
	}
	N *= op;
}
void Read_OneNumber(int &N) {
	N = 0;
	char c = getchar();
	while(c < '0' || c > '9')
		c = getchar();
	N = c ^ 48;
}
const int MAXN = 2e2 + 5;
const int MAXM = 4e4 + 5;
const int MAXK = 10;
int color[MAXN][MAXN];
int addx[MAXK] = {0, -1, -2, 1, 2, -1, -2, 1, 2};
int addy[MAXK] = {0, -2, -1, -2, -1, 2, 1, 2, 1};
int n, Sum;
struct Node {
	int to, val, rev;
	Node() {}
	Node(int T, int V, int R) {
		to = T;
		val = V;
		rev = R; 
	} 
};
vector<Node> v[MAXM];
queue<int> q;
int be[MAXM], de[MAXM];
int s, t;
bool Bfs_Dinic() {//将残量网络分层
	while(!q.empty())
		q.pop();
	memset(de, 0, sizeof(de));
	q.push(s);
	de[s] = 1;
	be[s] = 0;
	while(!q.empty()) {
		int now = q.front(); q.pop();
		int SIZ = v[now].size();
		for(int i = 0; i < SIZ; i++) {
			int next = v[now][i].to;
			if(!de[next] && v[now][i].val) {
				be[next] = 0;
				de[next] = de[now] + 1;
				q.push(next);
				if(next == t)
					return true;
			}
		}
	}
	return false;//找不到增广路
}
int Dfs_Dinic(int now, int flow) {//在残量网络中寻找增广路并增广
	if(now == t || !flow)
		return flow;
	int surp = flow;
	int SIZ = v[now].size();
	for(int i = be[now]; i < SIZ && surp; i++) {
		be[now] = i;//弧优化
		int next = v[now][i].to;
		if(v[now][i].val && de[next] == de[now] + 1) {
			int maxnow = Dfs_Dinic(next, Min(surp, v[now][i].val));
			if(!maxnow)
				de[next] = -1;
			v[now][i].val -= maxnow;
			v[next][v[now][i].rev].val += maxnow;
			surp -= maxnow;
		}
	}
	return flow - surp;
}
int Dinic() {//最大流
	int res = 0, flow;
	while(Bfs_Dinic())
		while(flow = Dfs_Dinic(s, INF))
			res += flow;
	return res;
}
int Serial_Number(int i, int j) {//求该点的边号，勉强算个hash
	return (i - 1) * n + j;
}
void Read() {
	Quick_Read(n);
	s = 0; t = n * n + 1;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= n; j++) {
			Read_OneNumber(color[i][j]);
			Sum += !color[i][j];
		}
	for(int i = 1; i <= n; i++)//构建二分图
		for(int j = 1; j <= n; j++) {
			if(color[i][j] || !((i + j) & 1))
				continue;
			int now = Serial_Number(i, j);
			for(int k = 1; k <= 8; k++) {
				if(i + addx[k] < 1 || i + addx[k] > n || j + addy[k] < 1 || j + addy[k] > n)
					continue;
				int next = Serial_Number(i + addx[k], j + addy[k]);
				if(color[i][j])
					continue;
				int id1 = v[now].size();
				int id2 = v[next].size();
				v[now].push_back(Node(next, 1, id2));
				v[next].push_back(Node(now, 0, id1));
			}
		}
	for(int i = 1; i <= n; i++)//构建网络
		for(int j = 1; j <= n; j++) {
			if(color[i][j])
				continue;
			int now = Serial_Number(i, j);
			int idn = v[now].size();
			if((i + j) & 1) {
				int ids = v[s].size();
				v[s].push_back(Node(now, 1, idn));
				v[now].push_back(Node(s, 0, ids));
			}
			else {
				int idt = v[t].size();
				v[now].push_back(Node(t, 1, idt));
				v[t].push_back(Node(now, 0, idn));
			}
		}
}
void Write() {
	printf("%d", Sum - Dinic());//二分图最大独立集
}
int main() {
	Read();
	Write();
	return 0;
}
```

---

## 作者：_121017_ (赞：0)

其实就是一道二分图的题，仔细看一下题目：**求在装置互不攻击的情况下**，**最多可以放置多少个装置**。

我们可以画个图：

---

| $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ |
| $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ |
| $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ |
| $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ |
| $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ |
| $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ |
| $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ |
| $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ |
| $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ |

---
于是我们可以看到，标 $0$ 的点只能被标 $1$ 的点攻击到，标 $1$ 的点只能被标 $0$ 的点攻击到，于是我们就可以把原图拆成一个二分图。

## 注意！！！
如果 $a$ 点可以攻击到 $b$ 点，那么 $b$ 点也可以攻击到 $a$ 点，所以建边的时候要建双向边。
# code：
```cpp
#include<bits/stdc++.h>
#define MAX_N 1000005
using namespace std;
int n,m,e,cnt,sum,to[MAX_N],next[MAX_N],head[MAX_N],match[MAX_N],vis[MAX_N],o[MAX_N],ans;
int dx[8]={-2,-2,-1,-1,2,2,1,1};
int dy[8]={1,-1,2,-2,1,-1,2,-2};
void add(int u,int v){//邻接链表存图
	cnt++;
	to[cnt]=v;
	next[cnt]=head[u];
	head[u]=cnt;
}
bool dfs(int u,int tag){//匈牙利（增广路）算法跑二分图最大覆盖
	if(vis[u]==tag){
		return 0;
	}
	vis[u]=tag;
	for(int i=head[u];i;i=next[i]){
		if(!match[to[i]]||dfs(match[to[i]],tag)){
			match[to[i]]=u;
			return 1;
		}
	}
	return 0;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			char x;
			cin>>x;
			if(x=='0'){
				o[(i-1)*n+j]=1;//把地图压成一维
				sum++;//因为题目要求二分图最大独立集，所以要记录下点数。
			}else{
				o[(i-1)*n+j]=0;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(o[(i-1)*n+j]){
				for(int k=0;k<8;k++){
					int u=i+dx[k],v=j+dy[k];
					if(u>=1&&v>=1&&u<=n&&v<=n&&o[(u-1)*n+v]){//如果当前点和法，即当前点在地图内且当前点可以放置攻击装置
						add((i-1)*n+j,(u-1)*n+v);
						add((u-1)*n+v,(i-1)*n+j);
                        //则建双向边
					}
				}
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(dfs((i-1)*n+j,(i-1)*n+j)&&i+j&1){//如果当前点找到了增广路，且为左部点
				ans++;//二分图最大覆盖+1
			}
		}
	}
	cout<<sum-ans;//二分图最大独立集=顶点数-二分图最大覆盖
	return 0;
}
```


---

## 作者：louhao088 (赞：0)

## 题解
看到题我惊呆了，这不是P3355 骑士共存问题，又可以拿双倍经验了。


这道题是一个二分图水题。

以样例为例，我们可以这样理解


|1|X|1|
|---|---|---|
|0|1|0|
|X|0|1|

由于我们发现从0能攻击到的点只有1；
而从1只能攻击到0

我们只要对能攻击到的点做最大流，用总的减去即可


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000005,Max=0x3f3f3f3f;
inline int read()
{
	char ch=getchar();int x=0;bool f=0;
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=1;
	for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	if(f==1)x=-x;return x;
}
queue<int>q;
struct edge
{
	int v,w,nex;
}e[maxn];
int head[maxn],cnt=1,cur[maxn],dis[maxn],x,y,n,m,a,b,ans=0,k,p,Q,m1,m2,c,d,f[maxn],tag[maxn],to[maxn],tot=0;
char flag[505][505];
void add(int u,int v,int w){e[++cnt].v=v,e[cnt].w=w,e[cnt].nex=head[u],head[u]=cnt;e[++cnt].v=u,e[cnt].w=0,e[cnt].nex=head[v],head[v]=cnt;};
bool bfs()
{
	memset(dis,0x3f,sizeof dis);
	while(!q.empty())q.pop();
	q.push(x),dis[x]=0;cur[x]=head[x];
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int i=head[u];i;i=e[i].nex)
		{ 
			int v=e[i].v; //cout<<v<<"A"<<endl;
			if(e[i].w&&dis[v]==Max)
			{
				
				q.push(v),cur[v]=head[v];
				dis[v]=dis[u]+1;
				if(v==y)return 1;
			}	
		} 
	}
	return 0;
}
int dfs(int u,int sum)
{
	//cout<<u<<" "<<sum<<endl; 
	if(u==y)return sum;
	int www=0;
	for(int i=cur[u];i&&sum;i=e[i].nex)
	{
		cur[u]=i;int v=e[i].v;
		if((dis[v]==dis[u]+1)&&e[i].w)
		{
			int k=dfs(v,min(sum,e[i].w));
			if(k==0)dis[v]=Max;
			else
			{
				to[u]=v;
				if(u!=y)tag[v-n]=1;
				e[i].w-=k,e[i^1].w+=k,sum-=k;www+=k;
			}
		}
	}
	return www;
}
int main()
{
	n=read();
	x=50005,y=50007;
	for(int i=1;i<=n;i++)
		gets(flag[i]+1);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{	
			if(flag[i][j]=='1'){
				tot++;continue;
			}
			if((i+j)%2==0)
			{
				add(x,i*n+j,1);
				if(i>=3&&j>=2)add(i*n+j,(i-2)*n+j-1,1);
				if(i>=3&&j<=n-1)add(i*n+j,(i-2)*n+j+1,1);
				if(i>=2&&j>=3)add(i*n+j,(i-1)*n+j-2,1);
				if(i>=2&&j<=n-2)add(i*n+j,(i-1)*n+j+2,1);
				if(i<=n-2&&j>=2)add(i*n+j,(i+2)*n+j-1,1);
				if(i<=n-2&&j<=n-1)add(i*n+j,(i+2)*n+j+1,1);
				if(i<=n-1&&j>=3)add(i*n+j,(i+1)*n+j-2,1);
				if(i<=n-1&&j<=n-2)add(i*n+j,(i+1)*n+j+2,1);
			}
			if((i+j)%2==1)add(i*n+j,y,1);
		}
	while(bfs())ans+=dfs(x,Max);
	cout<<n*n-tot-ans;
	return 0;
}
```




---

## 作者：vocaloid (赞：0)

网络流经典的互不攻击问题，这道题明显非常没有诚意，连攻击方式都没有变，和骑士共存问题一毛一样……

有诚意的题见：[`P5030 长脖子鹿放置`](https://www.luogu.org/problemnew/show/P5030)

然后再回来讲这道题怎么做，首先这道题的建模方式依然是格子常用的黑白染色建边，对每个$i+j=1\ (mod\ 2)$的点，从超级源连过来，并从它向能攻击的格子连一条边，再从其他的点连向超级汇，当然，不能放置攻击装置的点就不要连了，直接$continue$掉，最后跑一遍$Dinic$求出**不能放装置**的点的个数，用总点数减去不能放装置的点即可（数字为$1$的点也不能放装置）

见代码

```cpp
#include<bits/stdc++.h>
#define inf 2147400000
using namespace std;
queue <int> q;
int cnt=1,fst[50005],nxt[1000005],to[1000005],w[1000005],fr[1000005],cur[50005];
int n,m,S,T,dep[50005];
int dx[]={0,-2,-1,1,2,-2,-1,1,2},dy[]={0,-1,-2,-2,-1,1,2,2,1};
void AddEdge(int u,int v,int c)
{
    to[++cnt]=v;
    fr[cnt]=u;
    nxt[cnt]=fst[u];
    fst[u]=cnt;
    w[cnt]=c;
}
bool Bfs()
{
    memset(dep,0,sizeof(dep));
    q.push(S);
    dep[S]=1;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(int i=fst[u];i;i=nxt[i])
        {
            int v=to[i];
            if(!dep[v] && w[i])
            {
                dep[v]=dep[u]+1;
                q.push(v);
            }
        }
    }
    return dep[T];
}
int Dfs(int u,int flow)
{
    if(u==T || !flow) return flow;
    int used=0;
    for(int i=cur[u];i;i=nxt[i])
    {
        cur[u]=i;
        int v=to[i];
        if(dep[v]==dep[u]+1 && w[i])
        {
            int fl=Dfs(v,min(flow,w[i]));
            if(fl)
            {
                used+=fl;
                flow-=fl;
                w[i]-=fl;
                w[i^1]+=fl;
                if(!flow) break;
            }
        }
    }
    return used;
}
int Dinic()
{
    int sum=0;
    while(Bfs())
    {
        memcpy(cur,fst,sizeof(fst));
        sum+=Dfs(S,inf);
    }
    return sum;
}
int main()
{
    int sum=0;
    scanf("%d",&n);
    S=0;
    T=n*n+1;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            char ch;
            cin>>ch;
            if(ch=='1') continue;
            int id=(i-1)*n+j;
            sum++;
            if((i+j)&1)
            {
                AddEdge(S,id,1);
                AddEdge(id,S,0);
                for(int k=1;k<=8;k++)
                {
                    int nx=i+dx[k],ny=j+dy[k];
                    if(nx<1 || nx>n || ny<1 || ny>n) continue;
                    AddEdge(id,(nx-1)*n+ny,1);
                    AddEdge((nx-1)*n+ny,id,0);
                }
            }
            else
            {
                AddEdge(id,T,1);
                AddEdge(T,id,0);
            }
        }
    }
    int ans=sum-Dinic();
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Albedo (赞：0)

# Preface

这道题好像暴力二分图匹配都能过呀，为什么有紫题难度。

# Description

我认为题目说的够清楚了。

# Method

首先我们可以发现，题目中的条件可以转化为一个选了，另外几个不能选，看到这里，你是不是想到了2-SAT，但很可惜，他要求的是最多可以放几个装置，我们把题目要求转化，就是最少能有几个互不影响的不能在一起的点的集合，这就是匹配，所以需要用二分图匹配。

### 二分图建图

这个应该很简单，首先我们根据题目要求把一个点与不能和他相邻的点连边，之后黑白染色即可。

### 二分图匹配

这个就显得很套路了，对于一个点，如果他是 $ 0 $ ，那么做二分图匹配，否则直接 $ +1 $ ，因为他一定不能选。

# Code

```c++
#include<bits/stdc++.h>
using namespace std;
const int di[8][2]={{-1,-2},{-2,-1},{1,-2},{2,-1},{-1,2},{-2,1},{1,2},{2,1}};
inline int read()			
{
  int x=0,f=1;char ch=getchar();
  while(!isdigit(ch)&&ch!='-')ch=getchar();
  if(ch=='-')f=-1,ch=getchar();
  while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
  return x*f;
}
bool uu[100000],exist[100000],visit[100000],edge[300][300];
int ok[1000][1000],e3[200000],e4[200000],e1[200000],e2[200000],a[200000],b[200000],d[200000],match[200000];
int xx,yy,k,xu,yu,xv,yv,ans3,ans4,ans2,ans1,sum,j,cnt,n,m,x,y,i,ans,color[100000];
string s;
void add(int x,int y)
{
	cnt++;a[cnt]=y;b[cnt]=d[x];d[x]=cnt;
}
bool check(int x)
{
	int i;
	for (i=d[x];i;i=b[i])
	    if (visit[a[i]]==false)
	         {
	         	visit[a[i]]=true;
	         	if ((match[a[i]]==0)||(check(match[a[i]])))
	         	     {
	         	     	match[a[i]]=x;
	         	     	return true;
					  }
			 }
	return false;
}
void sc(int x,int y)
{
	if (color[x]!=0) return;
	color[x]=y;
	int i;
	for (i=d[x];i;i=b[i])
	     sc(a[i],3-y);
}
int main()
{
	cin>>n;
    for (i=1;i<=n;i++)
         {
         	cin>>s;
         	for (j=1;j<=n;j++)
         	     ok[i][j]=(s[j-1]-'0');
		 }
	for (i=1;i<=n;i++)
	   for (j=1;j<=n;j++)
	       if (ok[i][j]==0)
	           {
	           	x=(i-1)*n+j;
	           	   for (k=0;k<8;k++)
	           	       {
	           	       	xx=i+di[k][0];yy=j+di[k][1];
	           	       	if ((xx>=1)&(xx<=n)&(yy>=1)&(yy<=n))
	           	       	      if (ok[xx][yy]==0)
	           	       	          {
	           	       	          y=(xx-1)*n+yy;
								  add(x,y);	
										}
						  }
			   }
	/*for (i=1;i<=n;i++)
	    for (j=1;j<=n;j++)
	       if ((edge[i][j]==false))
	        if (i!=j)
	           {
	           	if ((e1[i]==e3[i])&(e1[j]==e3[j])) continue;
	           	if ((e2[i]==e4[i])&(e2[j]==e4[j])) continue;
	           	if (e1[i]==e3[i])
	           	     {
	           	     	if ((e1[i]>=e1[j])&(e1[i]<=e3[j]))
	           	     	   if ((e2[i]<=e2[j])&(e4[i]>=e2[j]))
	           	     	         {
	           	     	         	add(i,j);add(j,i);exist[i]=true;exist[j]=true;
	           	     	         	edge[i][j]=true;edge[j][i]=true;
									 }
						}
			   }*/
	/*for (i=1;i<=n;i++) 
	    {
		if (exist[i]==false) 
		     {
			 sum++;continue;
		     }
		ans1=0;ans2=0;
	    if (color[i]==0) sc(i,1);
		ans3=max(ans1,ans2);
	    ans+=ans3;
	    }*/
	for (i=1;i<=n*n;i++)
	  if (ok[(i-1)/n+1][(i-1)%n+1]==0)
	     if (color[i]==0)
	        sc(i,1);
    int LGCZ=0;
	for (i=1;i<=n*n;i++)
	  if (ok[(i-1)/n+1][(i-1)%n+1]==0)
	     {
	     if (color[i]==1)
	     {
	     	for (j=1;j<=n*n;j++) visit[j]=false;
	     	if (check(i)) ans++;
	      }
	    }
	else LGCZ++;
	printf("%d\n",n*n-ans-LGCZ);
	return 0;
}
```



---


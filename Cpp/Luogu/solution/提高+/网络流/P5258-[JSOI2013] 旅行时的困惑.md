# [JSOI2013] 旅行时的困惑

## 题目描述

Waldives 有 $N$ 个小岛。目前的交通系统中包含 $N-1$ 条快艇专线，每条快艇专线连接两个岛。这 $N-1$ 条快艇专线恰好形成了一棵树。

由于特殊的原因，所有 $N-1$ 条快艇专线都是单向的。这导致了很多岛屿之间
不能相互到达。因此，Waldives 政府希望新建一些公交线路，使得建设完毕后，任意两个小岛都可以互相到达。为了节约开支，政府希望建设最少的公交线路。 

同时，出于规划考虑，每一条公交线路都有如下的要求：
> 1、每一条交通线路包含若干条连续的快艇专线，你可以认为一条公交线路
对应树上的一条路径，而其所包含的若干快艇专线则对应树上被这条路
径所覆盖的树边（也就是之前已经存在的某个快艇专线）；
>
> 2、显然一条交通线路只能覆盖树上任意一条边至多一次；
>
> 3、公交线路中所包含的每一个快艇专线都是有方向的，并且与其所覆盖的
树边的方向相反；
>
>4、不同的公交线路可以覆盖树上相同的点或者相同的边。

Waldives 的 $N$ 个岛屿分别从 $0$ 到 $N-1$ 编号。现在给出 Waldives 已有的快艇专线信息，请计算最少所需要新建的交通线路的数量。

## 说明/提示

$1~\leq~N~\leq~10^5$

## 样例 #1

### 输入

```
4
0 1
1 2
1 3```

### 输出

```
2```

# 题解

## 作者：yangchenxiao (赞：4)

考虑上下界网络流

题目很明显的限制：任意两个岛可以互达，则需要建出一棵双向边的树，即每条边至少反方向经过一次，于是按照套路流量限制为 $[1,inf]$

由于线路可以从每个点开始，可以有任意多条，于是从源点向每个点连一条 $[0,inf]$ 的边

类似的，可以在任意一个点结束，每个点向汇点连一条 $[0,inf]$ 的边

于是图就建好啦，再来一遍有源汇上下界最小流的板子就可以解决这道题了

虽然点数是 $10^5$ 挺大的，但是边特别稀疏，网络流可以水过去


代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+15;
const int maxm=2e6+5;
const int inf=0x3f3f3f3f;
int n,m,S,T,num,s,t,x,y,cur[maxn],hd[maxn],cnt,dis[maxn],deg[maxn],tot;
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-')f=-1;
		ch=getchar();	
	}
	while(isdigit(ch)){
		x=x*10+ch-48;
		ch=getchar();	
	}
	return x*f;
}
struct Edge{
	int nxt,to,val;	
}edge[maxm];
void add(int u,int v,int w){
	edge[++cnt].nxt=hd[u];
	edge[cnt].to=v;
	edge[cnt].val=w;
	hd[u]=cnt;
	return ;
}
void make(int u,int v,int down,int up){
	deg[u]-=down;
	deg[v]+=down;
	add(u,v,up-down);
	add(v,u,0);
	return ;
}
bool bfs(){
	memset(dis,0,sizeof dis);
	queue<int>q;
	q.push(S);
	cur[S]=hd[S];
	dis[S]=1;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=hd[u];i;i=edge[i].nxt){
			int v=edge[i].to;
			if((!dis[v])&&edge[i].val){
				dis[v]=dis[u]+1;
				cur[v]=hd[v];
				if(v==T)return true;
				q.push(v);	
			}
		}
	}
	return false;
}
int dfs(int u,int limit){
	if(u==T)return limit;
	int flow=0;
	for(int i=cur[u];i&&flow<limit;i=edge[i].nxt){
		int v=edge[i].to;
		cur[u]=i;
		if(dis[v]==dis[u]+1&&edge[i].val){
			int ww=dfs(v,min(edge[i].val,limit-flow));
			if(!ww)dis[v]=0;
			edge[i].val-=ww;
			edge[i^1].val+=ww;
			flow+=ww;
		}
	}
	return flow;
}
int dinic(){
	int r=0,flow=0;
	while(bfs()){
		while(flow=dfs(S,inf)){
			r+=flow;	
		}
	}
	return r;
}
int main(){
	n=read();
	s=0;
	t=n+1;
	S=n+2;
	T=n+3;
	cnt=1;
	for(int i=1;i<=n-1;i++){
		x=read()+1;
		y=read()+1;
		make(y,x,1,inf);
	}
	for(int i=1;i<=n;i++){
		make(s,i,0,inf);
		make(i,t,0,inf);	
	}
	for(int i=0;i<=n+1;i++){
		if(deg[i]>0){
			make(S,i,0,deg[i]);
		}
		else make(i,T,deg[i],0);
	}
	make(t,s,0,inf);
	dinic();
	int ans=edge[cnt].val;
	S=t;
	T=s;
	edge[cnt].val=edge[cnt^1].val=0;
	cout<<ans-dinic();
	return 0;
}
```


---

## 作者：Thunder_S (赞：3)

[不一样的阅读体验](https://www.cnblogs.com/Livingston/p/15368258.html)

## Solution

可以证明，如果一条公交线路可以在子树内建成，就不会在往子树外走。

> 简单的证明：如果当前子树内有可以连的线路，如果往外走，要么与当前连边数一致，要么多连，答案不会更优。

因此考虑贪心。设 $a_i$ 和 $b_i$ 表示父亲要走过来多少和要往父亲走多少。

对于当前节点 $x$，它的子节点 $son$ 只有 $a_i$ 和 $b_i$ 中的一个可以传递到 $x$，那么另一个就可以记录答案。

另外，对于节点 $x$，优先让其在内部建线路，剩余的再传递上去。

## Code

```cpp
#include<cstdio>
#include<algorithm>
#define N 100005
using namespace std;
struct ndoe
{
	int to,next,head,fx;
}tree[N<<1];
int n,x,y,ans,tot,a[N],b[N];
void add(int x,int y,int opt)
{
	tree[++tot].to=y;
	tree[tot].fx=opt;
	tree[tot].next=tree[x].head;
	tree[x].head=tot;
}
void dfs(int x,int fa)
{
	for (int i=tree[x].head;i;i=tree[i].next)
	{
		int v=tree[i].to;
		if (v==fa) continue;
		dfs(v,x);
		if (tree[i].fx)//看能传递哪一部分，另外一部分计入答案
		{
			ans+=a[v];
			b[x]+=max(b[v],1);
		}
		else
		{
			ans+=b[v];
			a[x]+=max(a[v],1);
		}
	}
	int t=min(a[x],b[x]);
	a[x]-=t;b[x]-=t;ans+=t;//优先在内部连边
}
int main()
{
	scanf("%d",&n);
	for (int i=1;i<n;++i)
	{
		scanf("%d%d",&x,&y);
		add(x+1,y+1,1);add(y+1,x+1,0);
	}
	dfs(1,0);
	printf("%d\n",ans+max(a[1],b[1]));
	return 0;
}
```



---

## 作者：MoonCake2011 (赞：1)

$10^5$，非常稀疏的图，可以尝试 Dinic 网络流。

因为每条边都要被线路覆盖一次，所以考虑上下界网络流建边下界为 $1$，上界为无限大。

然后因为线路可以从任意点开始和结束，于是考虑建超级源点和汇点，超级源点向每个点，每个点向超级汇点都连一条下界为 $0$，上界为无限大的边。

直接跑上下界最小流就做完了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,s,t,S,T;
int head[100010],to[1000010],nxt[1000010],val[1000010],tot=1;
void add(int u,int v,int w){
	to[++tot]=v,val[tot]=w;
	nxt[tot]=head[u];
	head[u]=tot;
}
int maxflow,dis[100010],now[100010];
bool vis[100010];
bool bfs(){
	queue<int>q;
	memset(vis,0,sizeof vis);
	vis[s]=1,dis[s]=0,now[s]=head[s];
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=nxt[i]){
			if(vis[to[i]] || !val[i]) continue;
			now[to[i]]=head[to[i]];
			dis[to[i]]=dis[u]+1,vis[to[i]]=1;
			q.push(to[i]);
			if(to[i]==t) return 1;
		}
	}
	return 0;
}
int dinic(int x,int flow){
	if(x==t) return flow;
	int rest=flow;
	for(int i=now[x];i && rest;i=nxt[i]){
		now[x]=i;
		if(dis[to[i]]!=dis[x]+1 || !val[i]) continue;
		int v=dinic(to[i],min(rest,val[i]));
		if(!v) dis[to[i]]=0;
		val[i]-=v,val[i^1]+=v;
		rest-=v;
	}
	return flow-rest;
}
int V[100010],_val[1000010];
signed main() {
	cin>>n;
	S=0,T=n+1; 
	s=n+2,t=n+3;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		u++,v++;
		add(u,v,1e16-1),add(v,u,0);
		V[v]++,V[u]--;
	}
	for(int i=1;i<=n;i++) add(S,i,1e16),add(i,S,0),add(i,T,1e16),add(T,i,0);
	int sum=0;
	for(int i=0;i<=n+1;i++) if(V[i]>0) add(s,i,V[i]),add(i,s,V[i]),sum+=V[i];else if(V[i]<0) add(i,t,-V[i]),add(t,i,-V[i]);
	add(T,S,1e15),add(S,T,0);
	int flow=0;
	while(bfs()) while(flow=dinic(s,1e18)) maxflow+=flow;
	if(maxflow<sum) cout<<"A clever xzy~~~";
	else{
		for(int i=1;i<=tot;i++) _val[i]=val[i];
		s=T,t=S;
		int ans=val[tot];
		val[tot]=val[tot^1]=0;
		maxflow=0;
		while(bfs()) while(flow=dinic(s,1e18)) maxflow+=flow;
		cout<<ans-maxflow<<" ";
	}
	return 0;
}
```

---

## 作者：zsq259 (赞：1)


## 题解 JSOI2013 旅行时的困惑

### 题面

[luogu5258](https://www.luogu.com.cn/problem/P5258)

### 解析

考虑贪心..

随便钦定一个根.设 $d[x]=1/0$ 表示原来的路径是 $fa->x$ 还是 $x->fa$

然后设 $s[x][0/1]$ 表示 $\sum\limits_{fa[k]=x}[d[k]=0/1]$,简单来说就是满足 $d[k]=0/1$,$k$ 是 $x$ 儿子的数量.

考虑两条路径 $k1->x,x->k2$,$k1,k2$ 为 $x$ 儿子.

贪心地想一想,肯定要修一条 $k2->k1$ 的公路.

于是子树内要修的公路数就是 $\min(s[x][0],s[x][1])$.

然后如果 $x$ 是根节点那就要把剩下的路修掉,否则就传给它的爸爸,

反正一个点或一条边都可以被经过多次.

但是这是较多的路方向与 $x$ 到 $fa$ 的方向相同的情况,

如果较多的路的方向与 $x$ 到 $fa$ 的方向相反,那就必须要在$x$ 的子树内解决.

### code

```cpp
#include <iostream>
#include <stdio.h>
#include <cstring>
#define ll long long
#define filein(a) freopen(a".cpp","r",stdin)
#define fileout(a) freopen(a".cpp","w",stdout);
using namespace std;

inline int read(){
	int sum=0,f=1;char c=getchar();
	while((c<'0'||c>'9')&&c!=EOF){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9'&&c!=EOF){sum=sum*10+c-'0';c=getchar();}
	return sum*f;
}

const int N=100005;
struct edge{int to,next,f;}e[N<<1];
int n,d[N],g[N],ans;
int head[N],cnt=0;

inline void add(int x,int y,int f){
	e[++cnt]=(edge){head[x],y,f};head[x]=cnt;	
}

inline void dfs(int x,int fa){
	int s[2]={0};
	for(int i=head[x];i;i=e[i].to){
		int k=e[i].next;
		if(k==fa) continue;
		d[k]=e[i].f;dfs(k,x);
		s[d[k]]+=g[k];
	}
	ans+=min(s[0],s[1]);
	if(x==1) ans+=max(s[0],s[1])-min(s[0],s[1]);
	else if(s[d[x]]>s[d[x]^1]) g[x]=s[d[x]]-s[d[x]^1];
	else if(s[d[x]]<s[d[x]^1]) ans+=s[d[x]^1]-s[d[x]];
	g[x]=max(g[x],1);
}

int main(){
	n=read();
	for(int i=1;i<n;i++){
		int x=read()+1,y=read()+1;
		add(x,y,1);add(y,x,0);
	}
	dfs(1,0);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Chenyichen0420 (赞：0)

## 思路分析

只要你的图够稀疏，$10^5$ 我照样跑！

非常板的一个上下界网络流。每个反边至少走一次，所以每个反边下界为 $1$。每一个点都可以作为起点或终点，所以每个点都有源汇点的无限流。

建模完毕，跑一个上下界最小流即可。代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
constexpr int inf = 1e12;
int n, m, s, t, rd[200005], sm, ans, lv[200005], ys, yt, tr[200005], tc[200005];
struct ULBNF {
	struct node { int p, f, v; }tmp; //强制兼容费用流了，先不管吧
	vector<node>e; vector<int>h[200005];
	inline void ins(int l, int r, int f, int v) {
		h[l].emplace_back(e.size());
		tmp.p = r; tmp.f = f; tmp.v = v;
		e.emplace_back(tmp);
		h[r].emplace_back(e.size());
		tmp.p = l; tmp.f = 0; tmp.v = -v;
		e.emplace_back(tmp);
	}
	inline void dellast(int l, int r) {
		h[l].pop_back(); e.pop_back();
		h[r].pop_back(); e.pop_back();
	}
	inline void del(int p) { h[p].clear(); }
	int d[200005]; bool vis[200005];
	inline bool bfs() {
		memset(vis, 0, sizeof vis);
		vis[s] = d[s] = 1;
		queue<int>q; q.push(s);
		while (q.size()) {
			int tp = q.front();q.pop();
			for (int i = 0;i != h[tp].size();++i) {
				node& sp = e[h[tp][i]];
				if (!vis[sp.p] && sp.f)
					d[sp.p] = d[tp] + 1,
					vis[sp.p] = 1, q.push(sp.p);
			}
		}
		return vis[t];
	}
	int cur[200005];
	inline int dfs(int p, int a) {
		if (p == t || a == 0)  return a; int ret = 0, f;
		for (int& i = cur[p]; i != h[p].size(); ++i) {
			node& sp = e[h[p][i]];
			if (d[sp.p] == d[p] + 1 && (f = dfs(sp.p, min(a, sp.f))) > 0) {
				sp.f -= f; e[h[p][i] ^ 1].f += f;
				ret += f; if ((a -= f) == 0) break;
			}
		}
		return ret;
	}
	inline bool dneflow(int sm) {
		ans = 0;
		while (bfs())
			fill(cur, cur + n + 4, 0),
			ans += dfs(s, 1e15);
		return ans != sm;
	}
	inline int maxflow() {
		while (bfs())
			fill(cur, cur + n + 4, 0),
			ans += dfs(s, 1e15);
		return ans;
	}
	inline int minflow() {
		while (bfs())
			fill(cur, cur + n + 4, 0),
			ans -= dfs(s, 1e15);
		return ans;
	}
}net; //upper-lower bound network flow
signed main() {
	ios::sync_with_stdio(0); cin >> n;
	ys = n + 1; yt = n + 2; s = n + 3; t = n + 4;
	for (int i = 1, l, r;i != n;++i)
		cin >> r >> l, l++, r++,
		net.ins(l, r, inf, 0),
		rd[l]--, rd[r]++;
	for (int i = 1;i <= n;++i) net.ins(ys, i, inf, 0);
	for (int i = 1;i <= n;++i) net.ins(i, yt, inf, 0);
	for (int i = 1;i <= yt;++i)
		if (rd[i] > 0) sm += rd[i], net.ins(s, i, rd[i], 0);
		else if (rd[i]) net.ins(i, t, -rd[i], 0);
	net.ins(yt, ys, 1e15, 0); net.dneflow(sm);
	ans = net.e.back().f;
	net.dellast(yt, ys); t = ys, s = yt;
	cout << net.minflow() << endl;
}
```

---

## 作者：tony0530 (赞：0)

# 题解

上下界网络流，一道模板题。

由于线路可以从每个点开始，可以有任意多条，于是从源点向每个点连一条 $[0,\inf]$ 的边，从每个点向汇点连一条 $[0,\inf]$ 的边,最后跑源汇上下界最小流的板子就可以了。

边很少，时间复杂度是正确的。

# 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;
const int M = 2e6 + 10;
const int inf = 0x3f3f3f3f;

int n, m, S, T;
int num, s, t, x, y;
int cur[N], hd[N], cnt, dis[N], deg[N], tot;

struct Edge
{
	int nxt, to, val;	
}edge[M];

void add(int u, int v, int w)
{
	edge[ ++ cnt].nxt = hd[u], edge[cnt].to = v, edge[cnt].val = w, hd[u] = cnt;
	return;
}

void make(int u, int v, int down, int up)
{
	deg[u] -= down, deg[v] += down, add(u, v, up - down), add(v, u, 0);
	return ;
}

bool bfs()
{
	memset(dis, 0, sizeof dis);
	queue<int>q;
	q.push(S);
	cur[S] = hd[S];
	dis[S] = 1;
	while(!q.empty())
	{
		int u = q.front();
		q.pop();
		for(int i = hd[u] ; i ; i = edge[i].nxt)
		{
			int v = edge[i].to;
			if((!dis[v]) && edge[i].val)
			{
				dis[v] = dis[u] + 1;
				cur[v] = hd[v];
				if(v == T)return true;
				q.push(v);	
			}
		}
	}
	return false;
}
int dfs(int u,int limit)
{
	if(u == T) return limit;
	int flow = 0;
	for(int i = cur[u] ; i && flow < limit ; i = edge[i].nxt)
	{
		int v = edge[i].to;
		cur[u] = i;
		if(dis[v] == dis[u] + 1 && edge[i].val)
		{
			int ww = dfs(v, min(edge[i].val, limit - flow));
			if(ww == 0) dis[v] = 0;
			edge[i].val -= ww;
			edge[i ^ 1].val += ww;
			flow += ww;
		}
	}
	return flow;
}

int dinic()
{
	int r = 0, flow = 0;
	while(bfs())
		while(flow = dfs(S, inf))
			r += flow;	
	return r;
}
int main(){
	cin >> n;
	s = 0, t = n + 1, S = n + 2, T = n + 3, cnt = 1;
	for(int i = 1 ; i <= n - 1 ; i ++ )
	{
		int x, y;
		cin >> x >> y;
		x ++ , y ++ ;
		make(y, x, 1, inf);
	}
	for(int i = 1 ; i <= n ; i ++ )
	{
		make(s, i, 0, inf);
		make(i, t, 0, inf);	
	}
	for(int i = 0 ; i <= n + 1 ; i ++ )
	{
		if(deg[i] > 0) make(S, i, 0, deg[i]);
		else make(i, T, deg[i], 0);
	}
	make(t, s, 0, inf);
	dinic();
	int ans = edge[cnt].val;
	S = t, T = s;
	edge[cnt].val = edge[cnt ^ 1].val = 0;
	cout << ans - dinic();
	return 0;
}
```

---

## 作者：liugh_ (赞：0)

## [[JSOI2013] 旅行时的困惑](https://www.luogu.com.cn/problem/P5258)

> 给定一棵 $n$ 个点的有向树。定义一次操作为：在原树上选一条简单路径，对于路径上的每一条边，向树中加入这条边的反边。现要使得树上任意两点互相可达，求最少操作次数。注意在不同操作中选的路径可以同时包含原树上相同的点或边。
> 
> $n\le 10^5$。

首先对于一棵无向树，两个点之间有且仅有一条简单路径。而对于有向树中的一条边 $(u,v)$，一定有 $u$ 可达 $v$ 而 $v$ 不可达 $u$。于是有一个结论：每一条边的反边必须被添加才能使得整棵树上的点两两可达。问题转化为**将原树所有边反向**后，选取最少的路径使得每条边都被**至少一条**路径覆盖。想到什么？上下界最小流！

从 $S$ 向每个点、从每个点向 $T$ 都连流量为 $[0,\infty]$ 的边。原树上所有边取反后，给一个流量 $[1,\infty]$。直接跑上下界最小流即可，基础操作详见 [OI-Wiki](https://oi-wiki.org/graph/flow/bound/)。但是这么做需要跑两次 dinic，而上下界最小流其实可以转化为上下界最小费用可行流，具体地，给 $T$ 到 $S$ 的边一个费用 $1$，其余所有边费用为 $0$，这样限制了费用最小，同时费用和流量在数值上相等。这样我们只用跑一次 dinic，代码细节较少，常数可能会小一点？而且由于边非常稀疏，不用卡常实际也能跑得很快，最大点 $74\operatorname{ms}$，目前最优解第一页。

```cpp
#include<iostream>
#include<algorithm>
#include<list>
#ifdef ONLINE_JUDGE
#define getchar() (p_==q_&&(q_=(p_=b_)+fread(b_,1,s_,stdin),p_==q_)?-1:*p_++)
#define putchar(x_) ((r_-o_<s_)?(*r_++=x_):(flush(),r_=o_,*r_++=x_))
#endif
#define inline inline __attribute__((__always_inline__))
#define flush() (fwrite(o_,r_-o_,1,stdout),fflush(stdout),0)
using namespace std;constexpr int s_=1<<20;char b_[s_],o_[s_],*p_=b_,*q_=b_,*r_=o_;template<class T_>inline bool fr(T_&x_){x_=0;char c_=0,f_=0;do{if(c_=='-')f_=1;if((c_=getchar())==-1)return 0;}while(c_<48||c_>57);do {x_=x_*10+c_-48;if((c_=getchar())==-1)break;}while(c_>47&&c_<58);if(f_)x_=-x_;return 1;}template<class T_>inline void fw(T_ x_){char d_[40],l_=-1;if(x_<0)x_=-x_,putchar('-');do d_[++l_]=x_%10+48;while(x_/=10);do putchar(d_[l_]);while(~--l_);}

constexpr int maxn=1e5+5,maxm=4e5+5,inf=0x3f3f3f3f;

int n,m,S,T,SSS,TTT;
struct _ln{int u,v,d,c,w;}ln[maxm];

struct _eg{int pre,v,c,w;}eg[maxm*2];int ei=1,eh[maxn],cur[maxn];
inline void ea(int u,int v,int c,int w){eg[++ei]={eh[u],v,c,w};eh[u]=ei;}
#define ef(u,v,c,w) (ea(u,v,c,w),ea(v,u,0,-(w)))

int dis[maxn];bool vis[maxn];
inline bool spfa(int s,int t){
    fill(dis,dis+TTT+1,inf);fill(vis,vis+TTT+1,0);list<int> q;
    dis[s]=0,q.push_back(s);
    while(q.size()){
        int u=q.front();
        q.pop_front();
        vis[u]=0;
        for(int e=eh[u];e;e=eg[e].pre){
            auto &[_,v,c,w]=eg[e];
            if(c>0&&dis[u]+w<dis[v])
                dis[v]=dis[u]+w,q.push_back(v);
        }
    }
    return dis[t]!=inf;
}
int out[maxn],in[maxn];
int dfs(int u,int fl,int t){
    if(u==t)return fl;int sum=0;
    vis[u]=1;
    for(int e=cur[u];e;cur[u]=e=eg[e].pre){
        auto &[_,v,c,w]=eg[e];
        if(vis[v])continue;
        if(c>0&&dis[u]+w==dis[v]){
            int can=dfs(v,min(c,fl),t);
            if(can==0){dis[v]=inf;continue;}
            eg[e].c-=can,eg[e^1].c+=can;
            fl-=can,sum+=can;
            if(!fl)break;
        }
    }
    vis[u]=0;
    return sum;
}
inline void dinic(int s,int t){
    while(spfa(s,t)){
        fill(vis,vis+TTT+1,0);
        copy(eh,eh+TTT+1,cur);
        dfs(s,inf,t);
    }
}

signed main(){
    fr(n),S=n+1,T=n+2,SSS=n+3,TTT=n+4;
    for(int i=2;i<=n;i++){
        int u,v;fr(u),fr(v);
        u++,v++;
        ln[++m]={v,u,1,inf,0};
    }
    for(int i=1;i<=n;i++)ln[++m]={S,i,0,inf,0};
    for(int i=1;i<=n;i++)ln[++m]={i,T,0,inf,0};
    for(int i=1;i<=m;i++){
        auto &[u,v,d,c,w]=ln[i];
        out[u]+=d;
        in[v]+=d;
        ef(u,v,c-d,w);
    }
    for(int i=1;i<=T;i++){
        if(in[i]>out[i]){
            ef(SSS,i,in[i]-out[i],0);
        }else if(in[i]<out[i]){
            ef(i,TTT,out[i]-in[i],0);
        }
    }
    ef(T,S,inf,1);
    dinic(SSS,TTT);
    fw(eg[ei].c); // T到S的反边的流量
    exit(flush());
}
```

---


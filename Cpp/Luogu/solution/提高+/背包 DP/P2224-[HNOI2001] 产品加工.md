# [HNOI2001] 产品加工

## 题目描述

某加工厂有 A、B 两台机器，来加工的产品可以由其中任何一台机器完成，或者两台机器共同完成。由于受到机器性能和产品特性的限制，不同的机器加工同一产品所需的时间会不同，若同时由两台机器共同进行加工，所完成任务又会不同。

某一天，加工厂接到  $n$ 个产品加工的任务，每个任务的工作量不尽一样。

你的任务就是：已知每个任务在 A 机器上加工所需的时间  $t_1$，B 机器上加工所需的时间  $t_2$ 及由两台机器共同加工所需的时间  $t_3$，请你合理安排任务的调度顺序，使完成所有  $n$ 个任务的总时间最少。

## 说明/提示

对于所有数据，有  $1\le n\le 6\times 10^3$， $0\le t_1,t_2,t_3\le 5$。

## 样例 #1

### 输入

```
5                            
2 1 0
0 5 0
2 4 1
0 0 3
2 1 1
```

### 输出

```
9```

# 题解

## 作者：wjyyy (赞：54)

安利[个人博客](http://www.wjyyy.top/633.html)

像这种**进程DP**我是第一次见，不过只要把所有状态列出来，想做还是有好办法的。

我们首先看到，这个题同时维护**两个甚至是三个**进程，实在是不好想。我也是第一次看到有把数组下标当作最优状态求答案的，DP题见的应该还是越多越好。

我们试着用f[i][j]来维护当前加工第i个物品，A机器用时为j时B机器的最短用时。①我们不用担心排序问题，②也不用担心同时做会耽误某个空档的时间。①因为我们把这个模型当作一个**背包**，只管加入工件，不管添加顺序（背包不也是这样么）。②同时做的后效性问题：因为这里做的时候不用排序，所以我们把所有加入背包的**同时进行的进程**提到最前面去。

看这样一组数据：
```
3
5 0 0
0 2 0
0 0 3
```

我们模拟这个过程，是这样的（分别编号为工件1,2,3）
![这是一张图片](http://www.wjyyy.top/wp-content/uploads/2018/06/201806291516.png)

因为我们用的是背包，所以等价于下面这样：**（贪心的思想）**
![这是另一张图片](http://www.wjyyy.top/wp-content/uploads/2018/06/201806291519.png)

所以在没有顺序的时候，直接按背包做。我们的状态转移方程就是这样，不过状态只能单点转移而不是像背包那样只要比c[i]大都能转移：

   $f[][]=∞ \ \ f[0][0]=0$
   
   $f[i][j]=\min{\{ f[i-1][j]+t2[i],f[i-1][j-t1[i]],f[i-1][j-t3[i]]+t3[i]\}}$

   因为这个题数据范围达到$5×6000^2=1.8\times 10^8$，超出1亿次，并且空间也会超128M，因此我们要优化枚举下界，并滚掉第一维。滚动比较好做，只要保存好转移t2时的状态，和背包相同。

   枚举下界的调整：我们可以看出，因为状态是非严格单调递增的，所以我们如果发现对$∀i∈[0,k],f[i]=∞$，那么k以下的状态已经作废了，不会再被用到。此时我们的枚举下界down就可以调整到k了，并且每次做完检验是否可以继续更新。

   同时要记得在输入的时候记录上界$(up+=\max {\{t1[i],t2[i],t3[i]}\})$，并记得每次置为∞防止用到过时状态（尤其是做t2时可能会碰到两层前的状态）。

---

## 作者：一只书虫仔 (赞：18)

#### Description

> 有 $n$ 个任务，第 $i$ 个任务可以给 A 机器做，用时 $t_1[i]$；给 B 机器做，用时 $t_2[i]$；给 A 机器和 B 机器同时做，用时 $t_3[i]$；求最小用时。当对应 $t[i]=0$ 时，代表不能给这个机器或这两个机器做。

#### Solution

首先考虑暴力 dp，设 bool 数组 $f_{i,j_1,j_2}$ 为执行第 $i$ 个任务时，A 机器已经连续做了 $j_1$ 个时间，B 机器已经连续做了 $j_2$ 个时间，是否存在这么一个节点。

可以从题目中对应的三个方面转移过来：

- 交给 A 机器做：$f_{i-1,j1-t_1[i],j2}$；
- 交给 B 机器做：$f_{i-1,j_1,j_2-t_2[i]}$；
- 交给 A 机器和 B 机器一块做：$f_{i-1,j_1-t_3[i],j_2-t_3[i]}$。

初始化先不考虑了，这种方法肯定超时，已经飙到 $\mathcal O(n^3)$ 了，还带个常数。

因此我们考虑降维，设 $f_{i,j}$ 为执行第 $i$ 个任务时，A 机器已经连续做了 $j$ 个时间，求 B 机器最少连续做了多少个时间。

还可以从三个方面转移过来：

- 交给 A 机器做：$f_{i-1,j-t_1[i]}$；
- 交给 B 机器做：$f_{i-1,j}+t_2[i]$；
- 交给 A 机器和 B 机器一块做：$f_{i-1,j-t_3[i]}+t_3[i]$。

$f_{i,j}$ 就直接从这三个方面取个最小值即可，初值要都设为 $\infty$，除了 $f_{0,0}=0$，最终答案为 $\min\limits_{i=1}^{up}\{\max\{i,f_{n,i}\}\}$。

问题是上面这个程序可能会 TLE 接着 MLE，我们要考虑优化。

优化 MLE：滚存，因为状态方程只从 $i-1$ 转移过来，并且 $j$ 只会从小于等于他的一个数转移过来，因此像 01 背包一样倒着存成一维数组即可。

优化 TLE：上面这个枚举上限 $up$ 如果是 $5 \times n$ 就会坏掉，我们可以在枚举 $i \in [1,n]$ 中考虑 $up \leftarrow up+\max\{t_1[i],t_3[i]\}$，然后直接枚举 $up$ 即可，即设我们枚举到了第 $i$ 个任务，上限应为：

$$up=\sum\limits_{k=1}^i \max\{t_1[k],t_3[k]\}$$

具体细节比较多，放一下代码。

#### Code

```cpp
memset(dp, 0x3f, sizeof(dp));
dp[0] = 0;
for (int i = 1; i <= n; i++) {
	up += max(t1[i], t3[i]);
	for (int j = up; j >= 0; j--) {
		int p = 0x3f3f3f3f;
		if (j >= t1[i]) p = dp[j - t1[i]];
		int q = dp[j] + t2[i];
		int r = 0x3f3f3f3f;
		if (j >= t3[i]) r = dp[j - t3[i]] + t3[i];
		if (t1[i] == 0) p = 0x3f3f3f3f;
		if (t2[i] == 0) q = 0x3f3f3f3f;
		if (t3[i] == 0) r = 0x3f3f3f3f;
		dp[j] = MIN(p, q, r);
	}
}
```

---

## 作者：7KByte (赞：11)

以答案为状态。

$f[i][j]$表示处理前$i$个任务，第一台机器耗时为$j$时第二台机器的最小耗时。

显然答案为$\min\{\max\{\ f[n][i]\ ,\ i\ \}\ \}$。

观察一下可以得到转移方程$f[i][j]=\min\{f[i-1][j]+t_2,f[i-1][j-t_1],f[i-1][j-z]+z\}$。

初值为$f[0][0]=0$。我们发现$f[i]$的转移只与$f[i-1]$有关，这样就可以滚动数组。


```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define pre(i,a,b) for(int i=a;i>=b;i--)
#define N 30005
using namespace std;
int n,f[2][N];
int main(){
	scanf("%d",&n);
	memset(f,0x3f,sizeof(f));
	f[0][0]=0;
	int s=0;
	rep(op,1,n){
		int cur=op&1;
		int pre=cur^1;
		memset(f[cur],0x3f,sizeof(f[cur]));
		int x,y,z;scanf("%d%d%d",&x,&y,&z);
		s+=max(x,max(y,z));
		rep(i,0,s){
			if(y)f[cur][i]=min(f[cur][i],f[pre][i]+y);
			if(x&&i>=x)f[cur][i]=min(f[cur][i],f[pre][i-x]);
			if(z&&i>=z)f[cur][i]=min(f[cur][i],f[pre][i-z]+z);
		}
	}
	int ans=0x7fffffff;
	rep(i,0,s)ans=min(ans,max(i,f[n&1][i]));
	printf("%d\n",ans);
	return 0;
} 
```

---

## 作者：colin_lord (赞：7)

### 思路
  此道DP题状态比较难确定，既有A的时间，又有B的时间，所以就考虑将两个状态合二为一（很奇怪吧多写点DP就不奇怪了）；
  
 f(i , j)表示加工到第i件商品A机器用时为j时B机器的最短用时。
    
### 优化
咱直接把第一维删了具体见代码，利用一个新的数去存这件商品的最优解（可以算优化了一点空间吧）。
 
 普遍的状态转移方程(tmp储存当前状态，f(j)是上一个状态）
 
    tmp = min(f(j-a) , f(j) + b ，f(j-c) + c);
    f(j) = tmp;
    
这样可以在空间上极大程度优化（而且不容易写错！相信我！）

然后找答案的话先用up记录一下上界就是每个物品加工需要的最长时间。

然后从0开始枚举就好了（本来我是存了一个下界的，没想到还跑的更慢了……干脆就改成0了）
   ```
     for(int i = 0;i <= up;i ++) s = min(s , max(i  ,f[i]));
```
    
### 代码实现
    
```c

#include<bits/stdc++.h>

using namespace std;
const int N = 30010 , inf = 0x3f3f3f3f;
int f[N]; 
int n , s = inf , up;

//手打个快读 ， 优化一下时间 
int rd()
{
	int al = 0 ,  f = 1;char b = getchar();
    while(!isdigit(b)){if(b == '-') f = -1;b = getchar();}
    while(isdigit(b)){al = al * 10 + b - '0';b = getchar();}return al * f;
}

int main()
{
	n = rd();
	for(int i = 1;i <= n;i ++){
		int a = rd() , b = rd() , c = rd();
		up += max(a , max(b , c));
		for(int j = up ;j >= 0;j --){
			int tmp = inf;
			if(a && j - a >= 0)  tmp = min(tmp , f[j - a]);
			if(b) tmp = min(tmp , f[j] + b);
			if(c && j - c >= 0) tmp = min(tmp , f[j - c] + c);
			f[j] = tmp;
		}
	}
	for(int i = 0;i <= up;i ++) s = min(s , max(i  ,f[i]));
	cout << s;
}
```

解法大致都这样，实现的方式因人而异吧。（希望能过）


---

## 作者：Isprime (赞：4)

一道挺有意思的 dp 题。

大致看一下题面就可以知道是背包，但这个背包有点不太一样，我们得分别考虑每个机器的用时。

那我们可以把机器的用时也作为状态，即 $f_{i,j}$ 表示完成前 $i$ 个任务且机器一耗时 $j$ 的情况下机器二的耗时。显然转移需要分三种情况讨论，机器一做或机器二做或一起做，而对于每种情况就是个很简单的 01 背包。转移方程 $f_{i,j}=\min\{f_{i-1,j-t1_i},f_{i-1,j}+t2_i,f_{i-1,j-t3_i}+t3_i\}$.

但这样子做的话需要把数组开到 $f[6\times10^3][3\times10^4]$，似乎要爆空间。仔细观察方程就会发现 $f_{i,x}$ 只和 $f_{i-1,x}$ 有关，所以可以滚动数组略去第一维，然后转移的时候倒序循环（防止一个任务被做多次，具体为啥可以去看看 01 背包教程）。

转移的时候记得要判断一下能不能这样做（即时间是否等于零）。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
inline int read() {
	int res=0,f=1; char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1; ch=getchar();}
	while(ch>='0'&&ch<='9') {res=res*10+ch-'0'; ch=getchar();}
	return res*f;
}
const int MAXN=6005;
const int INF=998244353;
int n,sum,last,now;
int t1[MAXN],t2[MAXN],t3[MAXN];
int f[MAXN*5];
signed main() {
 	for(register int i=1;i<=MAXN*5;++i)
 		f[i]=INF;
 	f[0]=0;
	n=read();
	for(register int i=1;i<=n;i++) {
		t1[i]=read(); t2[i]=read(); t3[i]=read();
		sum+=max(t1[i],max(t2[i],t3[i]));
		for(register int j=sum;j>=0;--j) {
			int a=INF,b=INF,c=INF;
			if(t1[i]&&j>=t1[i]) a=f[j-t1[i]];
			if(t3[i]&&j>=t3[i]) c=f[j-t3[i]]+t3[i];
			if(t2[i]) b=f[j]+t2[i];
			f[j]=min(min(a,b),c);
		}
 	}
 	int mx=INF;
 	for(register int i=0;i<=sum;++i)
 		mx=min(mx,max(i,f[i]));
 	printf("%d\n",mx);
	return 0;
}
```

---

## 作者：NewJeanss (赞：4)

# 毒瘤题目
### 1. DP方程

这一题有三个参数，A机器用的时间，B机器用的时间，和第几个物品。

那么三个参数怎么处理呢？首先，一维的数组一定不够，那有人就想要不开三维数组？也不行。第一，超空间，第二，如果三个下标表示三个参数，那数组保存的空间就浪费了。

所以，我们想到用二维数组。

**用dp[i][j]表示第i个物品，A机器用j时间时，B机器用的时间**

所有DP题都是三部曲：表示状态，初始化，转移方程。一旦我们表示好了状态，就开始想转移方程。初始化，因为有Min，所以初始化inf，dp[0][0]=0

```cpp
//借鉴wjyyy大佬的方程：
if(a&&j-a>=0) //用A机器
  dp[i][j]=min(dp[i][j],dp[i-1][j-a]);
if(b)//用B机器
  dp[i][j]=min(dp[i][j],dp[i-1][j]+b);
if(c&&j-c>=0)//用A，B同时加工
  dp[i][j]=min(dp[i][j],dp[i-1][j-c]+c);
```

### 2. 优化

第一，可以发现第i个物品的状态只和第i-1个物品的状态有关，所以可以用**滚动数组**或者背包的思想(逆序)转化到一维。我采用更好理解的滚动数组。

第二，枚举j（使用时间）时的边界不用从0枚举到30000（5*6000）。

首先，在转移完后，如果前k个状态的值都是默认的无限大，意味着这几个状态在下一个物品转移是也无法用到，所以可以调整枚举下限。

其次，枚举的上限就是前i个物品，每个物品最大的时间之和记为sum。因为这样前i个物品所用时间一定不会超过sum。

第三，也是最重要的（我被这个坑了一个上午）。首先要用scanf。其次，**一定要开O2优化！！**

### 3. 代码和细节

```cpp
#include <bits/stdc++.h>
#define maxn 6005
#define inf 0x3f3f3f3f
using namespace std;
int a,b,c,dp[2][30150],sum;
int main()
{
	int n,ans,start,i,j;
	while(scanf("%d",&n)==1)//scanf成功输入几个数返回几
	{               //不加有风险
		sum=0;//初始化
		for(i=1,dp[0][0]=0,start=0;i<=n;i++)//start前边界
		{
			scanf("%d%d%d",&a,&b,&c);
			sum+=max(a,max(b,c));//后边界
			memset(dp[i&1],0x3f,sizeof(dp[i&1]));//i&1=i%1，相当于0,1交替
                        //每次执行前赋值无穷大，防止这一次的状态用到更之前的状态。
                        //比如之前是1，这一次算出来5,6,7，最小的应该是5,但不初始化无限大，结果就是之前算出来的1
			for(j=start;j<=sum;j++)
			{
				if(a&&j-a>=0) 
					dp[i&1][j]=min(dp[i&1][j],dp[(i-1)&1][j-a]);
				if(b) 
					dp[i&1][j]=min(dp[i&1][j],dp[(i-1)&1][j]+b);
				if(c&&j-c>=0)
					dp[i&1][j]=min(dp[i&1][j],dp[(i-1)&1][j-c]+c);
			}
			for(j=start;j<=sum;j++)//扩大前边界
			{
				if(dp[i&1][j]==inf) start++;
				else break;
			}
		}
		ans=0x3f3f3f3f;
		for(i=0;i<=sum;i++)//答案，A和B用时更长的那个
			ans=min(ans,max(dp[n&1][i],i));
		printf("%d\n",ans);
	}
	return 0;
}
```





---

## 作者：leozhang (赞：3)

比较简单的背包dp，设计状态f[i][j]表示到了前i个物品，第一台机器加工时间为j，第二台机器加工所用的最小时间，然后背包转移即可

本题卡空间，需要滚动数组优化

本题卡时间，稍微卡下常就行

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <queue>
#include <stack>
#define uint unsigned int
using namespace std;
uint dp[2][60005];
uint n;
uint v1[6005],v2[6005],v3[6005];
inline uint read()
{
	uint f=1,x=0;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
uint min(uint x,uint y)
{
	return x<y?x:y;
}
uint max(uint x,uint y)
{
	return x>y?x:y; 
} 
int main()
{
	n=read();
	int s1=0;
	int s2=0;
	for(int i=1;i<=n;i++)
	{
		v1[i]=read(),v2[i]=read(),v3[i]=read();
		s1+=v1[i]+v3[i];
		s2+=v1[i]+v3[i];
	}
	if(s1<=s2)
	{
		memset(dp,0x3f,sizeof(dp));
		if(v1[1])
		{
			dp[0][v1[1]]=0;
		}
		if(v2[1])
		{
			dp[0][0]=v2[1];
		}
		if(v3[1])
		{
			dp[0][v3[1]]=min(dp[0][v3[1]],v3[1]);
		}
		int now=1,past=0;
		for(int i=2;i<=n;i++)
		{
			memset(dp[now],0x3f,sizeof(dp[now]));
			for(int j=0;j<=s1;j++)
			{
				if(j>=v1[i]&&v1[i])
				{
					dp[now][j]=min(dp[now][j],dp[past][j-v1[i]]);
				}
				if(j>=v3[i]&&v3[i])
				{
					dp[now][j]=min(dp[now][j],dp[past][j-v3[i]]+v3[i]);
				}
				if(v2[i])
				{
					dp[now][j]=min(dp[now][j],dp[past][j]+v2[i]);
				}
			}
			swap(now,past);
		}
		uint ans=0x3f3f3f3f;	
		for(int i=0;i<=s1;i++)
		{
			ans=min(ans,max(i,dp[past][i]));
		}
		printf("%u\n",ans);
		return 0;
	}else
	{
		memset(dp,0x3f,sizeof(dp));
		if(v1[1])
		{
			dp[0][0]=v1[1];
		}
		if(v2[1])
		{
			dp[0][v2[1]]=0;
		}
		if(v3[1])
		{
			dp[0][v3[1]]=min(dp[0][v3[1]],v3[1]);
		}
		int now=1,past=0;
		for(int i=2;i<=n;i++)
		{
			memset(dp[now],0x3f,sizeof(dp[now]));
			for(int j=0;j<=s2;j++)
			{
				if(j>=v1[i]&&v1[i])
				{
					dp[now][j]=min(dp[now][j],dp[past][j]+v1[i]);
				}
				if(j>=v3[i]&&v3[i])
				{
					dp[now][j]=min(dp[now][j],dp[past][j-v3[i]]+v3[i]);
				}
				if(v2[i])
				{
					dp[now][j]=min(dp[now][j],dp[past][j-v2[i]]);
				}
			}
			swap(now,past);
		}
		uint ans=0x3f3f3f3f;	
		for(int i=0;i<=s2;i++)
		{
			ans=min(ans,max(i,dp[past][i]));
		}
		printf("%u\n",ans);
		return 0;
	}
}

```


---

## 作者：johnsmith0x3f (赞：2)

## 0x01

考虑 **DP**，朴素的想法是设 $f(i, j, k)$ 表示加工了前 $i$ 个产品，在 $A$ 和 $B$ 两台机器上花的时间分别为 $j$ 和 $k$ 时是否存在合法方案，然后讨论第 $i$ 个产品的加工方案进行转移。

但这种做法的时间复杂度是 $O(5n^3)$，显然 **TLE**。自然地，我们想到优化 **DP**。

注意到 $f$ 的取值只有 $0$ 和 $1$，仍有优化的空间，于是想到设 $f(i, j)$ 表示加工了前 $i$ 个产品，在 $A$ 机器上花的时间为 $j$ 时，在 $B$ 机器上花的时间的最小值。

时空复杂度均为 $O(5n^2)$，对于空间，考虑滚动数组或倒序枚举转移；对于时间，由于算法常数较小，理论上可以过。

## 0x02

然而提交后我们发现 `TLE on test 7`，考虑进一步优化时间。

注意到 $j$ 的上界为 $\sum_{k=1}^i \max\{ t_{1, k}, t_{2, k}, t_{3, k} \}$，而不用每次都枚举到 $5n$。

又注意到随着 $i$ 增大，花费的总时间是单调不降的，那么若有 $f(i, x) = \inf \ (x \in [0, k] )$，则 $f(i+1, j)$ 中 $j$ 的下界为 $k+1$。

最后，转移时的 `if` 运算可以改成三目运算符，效率更高，详见[这篇博客](https://blog.csdn.net/dby73/article/details/103206805)。

## 0x03 Code

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int read(){
	int x = 0, f = 1; char c = getchar();
	while(isdigit(c)^1) f &= (c!=45), c = getchar();
	while(isdigit(c)) x = (x<<1) + (x<<3) + (c^48), c = getchar();
	return f ? x : -x;
}

const int inf = 0x3f3f3f3f;
int n, ans = inf, sum, down, f[2][30005];

int main(){
#ifndef ONLINE_JUDGE
	freopen("test.in", "r", stdin);
#endif
	n = read(), memset(f, 0x3f, sizeof(f)), f[0][0] = 0;
	for(int i=1, x, y, z, las=0, now=1; i<=n; ++i, las^=1, now^=1){
		x = read(), y = read(), z = read(), sum += max(max(x, y), z), memset(f[now], 0x3f, sizeof(f[now]));
		for(int j=down; j<=sum; ++j)
			f[now][j] = min(min(min(f[now][j], y?(f[las][j]+y):inf), (x && j>=x)?f[las][j-x]:inf), (z && j>=z)?(f[las][j-z]+z):inf);
		while(f[now][down]>=inf) ++down;
	}
	for(int i=0; i<=sum; ++i) ans = min(ans, max(f[n&1][i], i));
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：xMinh (赞：2)

#常数优越系列

这题我活活卡过去的……但是代码比正解好理解一些

一道背包题，利用滚动数组压维

因为每一次都要选一种产品

所以要避免选了两边的，不选中间的的情况

就比如说选第三个产品的时候，不能用第一个产品的状态进行转移

所以每次要用memset清零上一维滚动数组

但是似乎很耗时……这题用的max和min好像挺多？？

手写一下，呀，卡过了，第七个点956ms

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define rint register int
#define ini inline int
using namespace std;
int n,m,ans=1000000007,a[6001],b[6001],c[6001],f[2][30001],now,pre;
ini max(int x,int y)
{
    if (x>y) return x;return y;
}
ini min(int x,int y)
{
    if (x<y) return x;return y;
}
int main()
{
    scanf("%d",&n);
    memset(f,127,sizeof(f));
    f[1][0]=0;pre=1;
    for (rint i=1;i<=n;i++)
    { 
                scanf("%d%d%d",&a[i],&b[i],&c[i]);
        now=pre^1;
        m+=max(a[i],c[i]);
        for (rint j=m;j>=0;j--)
        {
            if (b[i]!=0) f[now][j]=f[pre][j]+b[i];
            if (j>=a[i] && a[i]!=0) f[now][j]=min(f[now][j],f[pre][j-a[i]]+a[i]);
            if (j>=c[i] && c[i]!=0) f[now][j]=min(f[now][j],f[pre][j-c[i]]+2*c[i]);
        }
        memset(f[pre],127,sizeof(f[pre]));
        pre^=1;
    }
    for (rint i=m;i>=0;i--) ans=min(ans,max(i,f[now][i]-i));
    printf("%d",ans);
}
```

---

## 作者：attack (赞：2)

一道非常妙的dp

刚开始确实一点思路都没有，本来想的是$f[i][3]$分别表示用A,B,C完成的最早时间，但是很明显转移的时候会出错

正解用了非常神奇的一种dp方法

考虑到只有两种机器

$f[i]$表示的是当完成当前所有任务且A机器用了$i$时间时，B机器用的最小的时间

也就是我们可以去枚举A机器完成任务的时间

这样的话，对于一个物品来说，

如果是被$A$完成，那么$f[i]=min(f[i-timeA],f[i]$

如果是被$B$完成，那么$f[i]+=timeB$

如果是被$C$完成，那么$f[i]=min(f[i-timeC]+C,f[i]$

这样最后使得最大值最小就可以了


```
#include<cstring>
#include<cstdio>
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#define min(a,b) (a<b?a:b)
#define max(a,b) (a<b?b:a)
char buf[1<<21],*p1=buf,*p2=buf;
//#define int long long 
using namespace std;
const int MAXN=5*6001,INF=1e9+10;
inline int read() {
	char c=getchar();int x=0,f=1;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
int f[MAXN];
int main() {
	#ifdef WIN32
	freopen("a.in","r",stdin);
	#endif
	memset(f,0xf,sizeof(f));
	f[0]=0;
	int N=read(),limit=0;
	for(register int i=1;i<=N;i++) {
		int A=read(),B=read(),C=read();
		A = A==0?INF:A;
		B = B==0?INF:B;
		C = C==0?INF:C;
		limit+=min(A,min(B,C));	
		for(register int j=limit;j>=0;j--) {
			B==INF?f[j]=B:f[j]+=B;
			if(j>=A) f[j]=min(f[j-A],f[j]);
			if(j>=C) f[j]=min(f[j-C]+C,f[j]);
		}		
	}
	int ans=INF;
	for(int i=0;i<=limit;i++) ans=min(ans,max(i,f[i]));
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Code_星云 (赞：1)

考虑最优情况如下图

![](https://cdn.luogu.com.cn/upload/image_hosting/qnudueot.png?x-oss-process=image/resize,m_lfit,h_1000,w_1000)

事实上，如果我们将物件重排（将一起做的放前面），答案不会劣化，并且该状态若存在一定能够被计算到。这样做的优点在于能将 A 和 B 机器的物件制作区间是连续的。

![](https://cdn.luogu.com.cn/upload/image_hosting/67qv0xgq.png?x-oss-process=image/resize,m_lfit,h_1000,w_1000)

此时，问题就变为了双限制背包，可以用 [P2340](https://www.luogu.com.cn/problem/P2340) 的方法做，即用 $dp_{i,j}$ 表示对于前 $i$ 个物品，机器 A 用了 $j$ 个时间去做时，B 机器所用时间的最小值。此时转移方程很简单，然后要用滚动数组。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N = 6005;
const int M = 30010;
int n, t[M][3], maxn = 0, ans = 0x3f3f3f3f, dp[M];

int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; i ++){
		scanf("%d %d %d", &t[i][1], &t[i][2], &t[i][3]);
		maxn += max(t[i][1], t[i][3]);
	}
	memset(dp, 0x3f, sizeof dp);
	dp[0] = 0;
	for(int i = 1; i <= n; i ++)
	    for(int j = maxn; j >= 0; j --){
	    	int tmp = dp[j];
	    	dp[j] = 0x3f3f3f3f;
	    	if(t[i][2] > 0) dp[j] = tmp + t[i][2];
	    	if(j >= t[i][1] && t[i][1] > 0) dp[j] = min(dp[j], dp[j - t[i][1]]);
	    	if(j >= t[i][3] && t[i][3] > 0) dp[j] = min(dp[j], dp[j - t[i][3]] + t[i][3]);
		}
	for(int i = 0; i <= maxn; i ++) ans = min(ans, max(i, dp[i]));
	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：Φρανκ (赞：1)

题意：给定 $n$ 个物品和两机器，求用机器加工物品的最短耗时。

核心思想：DP

解：

由于题目并未给定加工的顺序，可以把所有共同加工的任务排到一起以规避等待造成的影响。这样，DP 时就无需考虑顺序了。

设 $f(i)$ 为机器 A 加工 $i$ 时间时机器 B 最少加工的时间，则对于每个物品有三种转移：

1. 予 A 加工，有 $f(i)=f(i-t_1)$；
2. 予 B 加工，有 $f(i)=f(i)+t_2$；
3. 共同加工，有 $f(i)=f(i-t_3)+t_3$。

对每个物品对每个值比较三者最小值即可。注意处理的方向应该与状态转移方向相反（从小到大转移，从大到小处理）以保证每个物品仅被计算一次。对于无法加工的情况，将其赋值为极大值 $30001$（因为结果显然小于该值）。

注意要将 DP 数组除第 $0$ 项外初始化为极大值 $30001$。

代码：
```
#include <bits/stdc++.h>
using namespace std;
int n, t[4], sum, a[30001], res=30001;
int main()
{
	ios::sync_with_stdio(false);
	memset(a+1, 30001, sizeof(a+1));//初始化
	cin>>n;
	for(int i=1; i<=n; i++)
	{
		cin>>t[1]>>t[2]>>t[3];
		for(int j=1; j<=3; j++)
			if(t[j]==0)
				t[j]=30001;//变更0
		for(int j=30000; j>=0; j--)
		{
			a[j]+=t[2];
			if(j>=t[1])
				a[j]=min(a[j], a[j-t[1]]);
			if(j>=t[3])
				a[j]=min(a[j], a[j-t[3]]+t[3]);
		}//状态转移
	}
	for(int i=0; i<=30000; i++)
		res=min(res, max(i, a[i]));
	cout<<res;//输出
	return 0;
}
```


---

## 作者：glorious_dream (赞：1)

### 题目描述：

某工厂有两台机器，来加工的产品可以给任意一个机器加工或者两个机器一起加工，给出 $t1$，$t2$，$t3$ 表示每一种情况的加工时间，若为 $0$ 则代表不能用这个机器加工，求出最小用时。

### 算法分析：

个人觉得，应该挺毒瘤的吧，自己没有想出来。

我们设 $f[i][j]$ 表示加工前 $i$ 个物品，第一台机器用时为 $j$ 时第二个机器的最短用时。

由于要求最小值，所以一开始先把 $f$ 数组赋值为最大值，同时 $f[0][0] = 0$。

先来考虑转移方程。

若 $t1 \neq 0$，$f[i][j] = \min(f[i-1][j-t1])$，相当于这个物品让第一个机器来加工。

若 $t2 \neq 0$，$f[i][j] = \min(f[i-1][j]+t2)$，相当于这个物品让第二个机器来加工。

若 $t3 \neq 0$，$f[i][j] = \min(f[i-1][j-t3]+t3)$，相当于这个物品让两个机器同时加工。

但显然，无论是空间还是时间都炸了。我们需要考虑如何进行优化。

先来看空间，由于 $f[i][]$ 只和 $f[i-1][ ]$ 有关，可以用滚动数组把第一维优化掉。这样空间复杂度可以通过。

来看时间复杂度。由于当前枚举的上界只有可能是 $s + \max(t1,t2,t3)$，$s$ 表示前一个物品的上界，所以我们可以记录下来循环的上界，就不用一直循环到最大值了。

然后是下界。如果位置 $k$ 前面的 $f$ 数组都是最大值，说明后面的转移也不会用到 $k$ 前面的数了，所以下界可以为 $k$。

这时就能把这道题通过了。

### 总代码：

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
#define re register
#define drep(a,b,c) for(re int a(b) ; a>=(c) ; --a)
#define rep(a,b,c) 	for(re int a(b) ; a<=(c) ; ++a)
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch == '-') f=-1 ; ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
const int M = 3e4+10;
const int inf = 0x3f3f3f3f;
int n,maxn,minn;
int f[2][M];
signed main(){
	n=read();
	memset(f,0x3f,sizeof(f));
	f[0][0] = 0;
	int pre = 1;
	rep(i,1,n){
		int t1=read(),t2=read(),t3=read();
		maxn += max(max(t1,t2),t3); //上界 
		memset(f[i&1],0x3f,sizeof(f[i&1])); //每一次都要清成最大值，防止上一次对本次操作的影响 
		for(re int j(minn) ; j<=maxn ; ++j){
			if(t1 && j>=t1) f[i&1][j] = min(f[i&1][j],f[(i-1)&1][j-t1]);
			if(t2) f[i&1][j] = min(f[i&1][j],f[(i-1)&1][j]+t2);
			if(t3 && j>=t3) f[i&1][j] = min(f[i&1][j],f[(i-1)&1][j-t3]+t3); //三个转移 
		}
		rep(j,minn,maxn){
			if(f[i&1][j] == inf) minn++; //下界 
			else break;
		}
	}
	int ans = inf;
	rep(i,minn,maxn) ans = min(ans,max(i,f[n&1][i])); //统计答案 
	printf("%d\n",ans);
	return 0;
}

```


---

## 作者：strange757 (赞：1)

首先考虑dp状态设计，$dp[i][j]$表示选到第i个任务A机器花费时间 $j$ 时B机器花费的最小时间。那么状态转移方程就不难得出。

$dp[i][j] = min(dp[i-1][j-t1], dp[i-1][j] + t2, dp[i-1][j-t3] + t3)$

推出方程之后还要注意边界条件,这个比较麻烦（主要是用了滚动数组，如果不用滚动数组可以去掉一些判定条件），首先dp数组全部初始化为极大值，然后定义一个 $sum$, $sum += \max (t1, t3)$ 每次 $j$ 从 $sum$ 到 $0$ 循环， 还要另外定义一个 $last$ ，$last = sum$ 用来清除滚动数组，值得注意的是，初始化时要严格把  $f[0][0-max(t1, t3)]$ 赋值为零，如果多赋值可能会在以后的更新中产生影响，少赋值同样的道理。

转移写的比较长，因为把判定条件一块写进去了。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N = 6e3 + 5;
int n, t1, t2, t3, sum, last; 
int f[2][N * 5], ans = 1e9; 
int main(){
	scanf("%d", &n);
	memset(f, 0x3f, sizeof(f));
	for(int i = 1;i <= n; i++){
		scanf("%d%d%d", &t1, &t2, &t3);
		if(i == 1){
			for(int j = 0 ; j <= max(t1, t3); j++) f[0][j] = 0;
		}
		last = sum;
		sum += max(t1, t3);
		for(int j = sum; j >= 0; j--){
			f[i&1][j] = min((t1&& j>=t1)?f[(i - 1)&1][j - t1]:1e9, min(t2?(f[(i - 1)&1][j] + t2):1e9, (t3 && j >=t3)?(f[(i - 1)&1][j - t3] + t3):1e9));
			if(i == n) ans = min(ans, max(f[i&1][j], j));
		}
		for(int j = 0; j <= last; j++){//清除滚动数组
			f[(i - 1)&1][j] = 0;
		}
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：_lfxxx_ (赞：1)

### 题意：
初始 $T_1=T_2=0$。

有 $n$ 组 $t_1,t_2,t_3$，你需要从这三个数中选一个数（如果为 $0$ 表示不能选，保证不全为 $0$）。

- 如果选 $t_1$，$T_1\gets T_1+t_1$。
- 如果选 $t_2$，$T_2\gets T_2+t_2$。
- 如果选 $t_3$，$T_1\gets T_1+t_3$，$T_2\gets T_2+t_3$。

找到一种选择方案，使 $\max\{T_1,T_2\}$ 最小，输出最小值。
#### 数据范围：
$1\le n\le 6×10^3,0\le t_1,t_2,t_3\le5$。
### 思路：
首先一个很明显的 $O(3^n)$ 的爆搜，这里就不说这个方法了，稳 T。

这道题容易想到背包，用 $f_{i,j,k}$ 表示前 $i$ 个产品中有无 A 机器生产 $j$ 个，B 机器生产 $k$ 个的情况。状态转移方程是这样的：（用 $1$ 表示存在，$0$ 表示不存在）
$$f_{i,j,k}=\max\{f_{i,j,k},f_{i-1,j-t_1,k},f_{i-1,j,k-t_2},f_{i-1.j-t_3,k-t_3}\}$$
~~其实有 1 就可以转移，由于想不到好的书写方式，只能用 max~~

这个很好理解，就按题面讲的方法转移就行了，但时间复杂度为 $O(n^3t^2)$（$nt$ 的值域，所以是 $n^2t^2$ 的转移）空间复杂度为 $O(n^3t^2)$（后面两维均是 $nt$），空间与时间均会爆炸，考虑优化。

一个显然的优化就是第一维可以滚掉。

再思考慢在哪里。

不难看出，有很多状态是转移不了的，就像如果有了 $f_{i,3,3}$，$f_{i,3,5}$ 就转不出去了，因为它的这个方案没有 $f_{i,3,3}$ 优。

于是我们就可以只用记 A 机器的所有情况，B 机器的我们只用记 A 机器的所有情况下 B 机器的**最优**时间。这里可以用 $f_i$ 表示 A 机器生产 $i$ 个，B 机器生产最少的个数。（这里把 A 和 B 反过来也可以）此时状态转移方程为
$$f_i=\min\{f_i,f_{i-t_1},f_i+t_2,f_{i-t_3}+t_3\}$$
时间复杂度为 $O(n^2t)$，空间复杂度为 $O(nt)$。

这时候，还是会 T，需要加一个上界优化，每次不从 $nt$ 开始，而是当前最大的值，详情见代码。
### 代码：
```cpp
int n,t1,t2,t3,ans,s=0;
read(n);
while(n--){
	read(t1),read(t2),read(t3);
	s+=max({t1,t2,t3});//上界优化，s 为上界（C++11 新特性）
	for(int i=s;i>=0;--i){
		ans=1e9;//设个极大的数为初值，其实答案是不会超过 30000。
		if(t1&&t1<=i)
			ans=min(ans,f[i-t1]);
		if(t2)
			ans=min(ans,f[i]+t2);
		if(t3&&t3<=i)
			ans=min(ans,f[i-t3]+t3);
		f[i]=ans;
	}
}
for(int i=0;i<=s;++i)
	ans=min(ans,max(f[i],i));//统计每种情况的用时
writeln(ans);
```

---

## 作者：fysbb (赞：1)

这一题设f[i]为使用A机器加工了i分钟时，使用B机器加工耗时的最小值。

f[i]初始赋值为maxint，f[0]=0

对于每件物品，有三个选择，使用A机器耗时a分钟，使用B机器耗时b分钟，使用A，B一起加工耗时c分钟。则状态转移方程为：
```pas
   f[i]=f[i]+b,b<>0
   
   f[i]=maxint,b=0(不要真的赋值为maxint,赋值为一个很大的数就行，不然计算时可能会爆）
   
   f[i]=min(f[i],f[i-a]),i>=a且a<>0
   
   f[i]=min(f[i],f[i-c]+c),i>=c且c<>0
```
此时，需要考虑i的范围，如果对每一件物品都
```pas
                   for i:=5*n downto 0 do
```
这样进行状态扩展，总共要循环5n^2次，对于本题数据肯定会超时。

其实，当我们处理第k件物品时，能够影响到的状态只有

                       f[j],0<=j<=5*k
                       
因为处理k件物品，最多就花费5*k分钟。

因此，在处理第k件物品是状态扩展为：
```pas
                   for i:=5*k downto 0 do
```
这样便可有效减少循环次数，确保不会超时。

```pas

var
   f:array[0..30050]of longint;
   n,i,a,b,c,j,sum,ans:longint;

function max(a,b:longint):longint;
begin
  if a>b then exit(a) else exit(b);
end;

function min(a,b:longint):longint;
begin
  if a<b then exit(a) else exit(b);
end;

begin
assign(input,'pro.in');reset(input);
assign(output,'pro.out');rewrite(output);
  read(n);
  for i:=1 to 30050 do f[i]:=100000000;
  f[0]:=0;
  sum:=0;
  for i:=1 to n do begin
    read(a,b,c);
    if a=0 then a:=100000000;
    if b=0 then b:=100000000;
    if c=0 then c:=100000000;
    for j:=5*i downto 0 do begin
      if b<>100000000 then f[j]:=f[j]+b else f[j]:=100000000;
      if j>=a then f[j]:=min(f[j],f[j-a]);
      if j>=c then f[j]:=min(f[j],f[j-c]+c);
    end;
  end;
  ans:=maxint;
  for i:=0 to 5*n do ans:=min(ans,max(i,f[i]));
  writeln(ans);
end.

```

---

## 作者：M_seа (赞：1)


dp:
首先想到二维dp

f[i][j]

表示前i件产品，第一个机器用时j，第二个机器用时f[i][j]

所以转移方程就出来了：f[i][j] = min(f[i-1][j]+t2, f[i-1][j-t1], f[i-1][j-t3]+t3)

二维当然会爆空间啦

所以可以滚掉i


[代码戳这](http://blog.csdn.net/qq_36288976/article/details/78229610)


---

## 作者：AzureHair (赞：0)

个人认为这道题真的很难想，因为状态变量比较鬼畜，想了三天也没有想出来，最终还是在大佬指点下才做出来。

首先容易想到的是暴力的做法 $f_{i,j,k}$ 表示前 $i$ 个任务 A 做了 $j$ 时间 B 任务做了 $k$ 时间是否成立。也容易发现时间空间全面爆炸，于是有了优化版的奇怪做法。

设 $f_{i,j}$ 表示前 $i$ 个产品，A 做了 $j$ 分钟， B最少做多少时间，于是你就可以写出鬼畜的转移方程外加鬼畜的滚动数组优化：

```cpp
f[now][j]=min(f[now][j],f[pre][j]+t2[i]);
f[now][j]=min(f[now][j],f[pre][j-t1[i]]);
f[now][j]=min(f[now][j],f[pre][j-t3[i]]+t3[i]);
```

然后再注意一车的细节这道题就结束了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,t1[6010],t2[6010],t3[6010],f[2][30010],cnt=0;
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>t1[i]>>t2[i]>>t3[i];
		if(t1[i]==0) t1[i]=0x3f;
		if(t2[i]==0) t2[i]=0x3f;
		if(t3[i]==0) t3[i]=0x3f;
	}
	memset(f,0x3f,sizeof(f));
	f[0][0]=0;
	for(int i=1;i<=n;i++)
	{
		int now=i&1;//滚动数组 
		int pre=now^1;
		memset(f[now],0x3f,sizeof(f[now]));
		int mmax=0;
		if(t1[i]!=0x3f) mmax=max(mmax,t1[i]);//修改最长时间 
		if(t2[i]!=0x3f) mmax=max(mmax,t2[i]);
		if(t3[i]!=0x3f) mmax=max(mmax,t3[i]);
		cnt+=mmax;
		for(int j=0;j<=cnt;j++)
		{
			if(t2[i]!=0x3f)
			{
				f[now][j]=min(f[now][j],f[pre][j]+t2[i]);//鬼畜转移，记得判范围 
			}
			if(t1[i]!=0x3f&&j>=t1[i])
			{
				f[now][j]=min(f[now][j],f[pre][j-t1[i]]);
			}
			if(t3[i]!=0x3f&&j>=t3[i])
			{
				f[now][j]=min(f[now][j],f[pre][j-t3[i]]+t3[i]);
			}
		}
	}
	
	int ans=0x3f3f3f3f;
	for(int i=0;i<=cnt;i++)
	{
		ans=min(ans,max(i,f[n&1][i]));//查找答案，别忘了i 
	}
	cout<<ans<<endl;//愉快AC 
	return 0;
}
```


---

## 作者：wangyibo201026 (赞：0)

## Solution

不难看出是个 DP。

设 $f_{i, j, k}$ 为前 $i$ 个任务，A 已经做了 $j$ 单位时间，B 已经做了 $k$ 单位时间，是否可行。

总体来说，状态转移方程并不难推：

$$f_{i, j, k} = \min(f_{i - 1, j - t1_i, k}, f_{i - 1, j, k - t2_i}, f_{i - 1, j - t3_i, k - t3_i})$$

然后就是时间爆炸，空间爆炸。

考虑优化空间：

将第三维状态存入 DP 里，变成，前 $i$ 个任务，A 做了 $j$ 个单位时间时，B 最少做了几个单位时间。

那么变成：

$$f_{i, j} = \min(f_{i - 1, j - t1_i}, f_{i - 1, j} + t2_i, f_{i - 1, j - t3_i} + t3_i)$$

然后滚动数组一下就做完了。

考虑时间，$O(5 \times n^2)$ 过不去，考虑现在枚举到 $i$，那么 $j$ 的最大值是否是 $5 \times n$？不是的，其实它最大是 $5 \times i$！所以就可以优化时间了，就可以过了。其实不难发现这个上界其实远没有 $5 \times i$ 这么大，其实是 $\sum\limits_{t = 1}^{i}\max(t1_t, t3_t)$，因为第二维状态只与 $t1$ 和 $t3$ 有关（你猜总次数最大是多少，$9\times 10^7$ 多一点点）。

## Code

Code：

```cpp
#include <bits/stdc++.h>

using namespace std;

#define double long double
#define int long long

#define fir first
#define sec second
#define lep( i, l, r ) for ( int i = ( l ); i <= ( r ); i ++ )
#define rep( i, r, l ) for ( int i = ( r ); i >= ( l ); i -- )
#define gep( i, x ) for ( int i = head[( x )]; i; i = edges[i].next)

char _c; bool _f; template < class T > inline void read ( T &x ) {
	_f = 0, x = 0;
	while ( _c = getchar (), !isdigit (_c) ){
		if ( _c == '-' ) { _f = 1; }
	}
	while ( isdigit (_c) ){
		x = x * 10 + _c - '0', _c = getchar ();
		if (_f) { x = -x; }
	}
}

const int N = 6e3 + 5;
const int INF = 0x3f3f3f3f3f3f3f3f;

int n, m, ans = INF;
int t1[N], t2[N], t3[N], f[5 * N];

signed main () {
	cin >> n;
	lep ( i, 1, n ) {
		cin >> t1[i] >> t2[i] >> t3[i];
	}
	memset ( f, 0x3f, sizeof ( f ) );  //初始没有运转
	f[0] = 0; // 初始状态
	lep ( i, 1, n ) {
		m += max ( t1[i], t3[i] );  //加上
		rep ( j, m, 0 ) {
			int tmp = INF;
			if ( j >= t1[i] && t1[i] ) {  //这里不能等于 0，否则就不工作了
				tmp = min ( tmp, f[j - t1[i]] );
			}
			if ( t2[i] ) {
				tmp = min ( tmp, f[j] + t2[i] );
			}
			if ( j >= t3[i] && t3[i] ) {
				tmp = min ( tmp, f[j - t3[i]] + t3[i] );
			}
			f[j] = tmp;
		}
	}
	lep ( i, 0, m ) {
		ans = min ( ans, max ( f[i], i ) );
	}
	cout << ans;
	return 0;
}
```

---

## 作者：zplqwq (赞：0)

一道很有趣的 dp 题。

这道题是以答案为下标来设定状态，在这种生产问题这个套路还是挺常见的，需要积累一下。

我们令 $f_{i,j}$ 为前 $i$ 个任务 $A$ 机器花了$j$ 时间的时候，$B$ 机器花费的时间最少是多少。

所以答案就是 $\min\{\max\{i,f_{n,i}\}\}$ 。我们对于每一个时间 $i$ 所需要的总时间就是做完前 $n$ 个任务 $B$ 花费的时间和 $A$ 花费的时间的最大值。由于我们枚举的 $i$ 就是 $A$ 花费的时间，所以只需与 $f_{n,i}$ 取最大值即可。

转移可以考虑从三个方向转移过来，对于当前任务，我们分别考虑是 $A$ 做，$B$ 做，还是 $A$ 和 $B$ 一起做。

即可以推出转移方程。

$$f_{i,j}=\max\left\{\begin{array}{l}f_{i-1,j-t1_i}\\
f_{i-1,j}+t2_i\\
f_{i-1,j-t3_i}+t3_i
\end{array}\right.
$$


我们发现这样的空间开销是很大的，因为我们既要记录是哪个任务还要记录时间。

我们发现对于第 $i$ 个任务只能从 $i-1$ 这个任务转移过来，所以可以滚动数组。

还有一个关于枚举的时间的优化。不难发现，对于当前任务 $i$ 的时间 $j$，$j$ 一定不会超过前 $i-1$ 个任务所花的时间的最大值。

即 $j\le \sum{\max(t1_i,t2_i,t3_i)}$ 。

细节不算多，但注意数组开大点，因为时间的大小比较玄学。

```cpp

#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=3e4+10;
int t1[N],t2[N],t3[N];
int n;
int dp[10][N];
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>t1[i]>>t2[i]>>t3[i];
	}
	int sum=0;
	memset(dp,0x3f,sizeof(dp));
	dp[0][0]=0;
	for(int i=1;i<=n;i++)
	{
		sum+=max(t1[i],t3[i]);
		memset(dp[i&1],0x3f,sizeof(dp[i&1]));
		for(int j=0;j<=sum;j++)
		{
			if(t2[i]!=0) dp[i&1][j]=min(dp[(i&1)^1][j]+t2[i],dp[i&1][j]);
			if(t1[i]!=0 and j-t1[i]>=0) dp[i&1][j]=min(dp[i&1][j],dp[(i&1)^1][j-t1[i]]);
			if(t3[i]!=0 and j-t3[i]>=0) dp[i&1][j]=min(dp[i&1][j],dp[(i&1)^1][j-t3[i]]+t3[i]);
		}
	}
	int ans=0x7fffffff;
	for(int i=0;i<=sum;i++)
	{
		ans=min(ans,max(i,dp[n&1][i]));
	}
	cout<<ans;
	return 0;
}
```



---

## 作者：Chthologist7507 (赞：0)

这是一道神奇的**进程 DP**，状态较难确定~~根据其他题解可知要以答案为状态~~

### 一、分析状态：

先看看有哪些状态：

- 执行第 $i$ 个任务
- A 机器做的时间 $j$
- B 机器做的时间 $k$

没了

### 二、设计最简单的 DP 方案

考虑一个 naive 的暴力：

设三维 bool 数组 $dp[i][j][k]$ 表示执行第 $i$ 个任务时，A 已经做了 $j$ 时，B 已经做了 $k$ 时的状态是否存在

初始时除了 $dp[0][0][0]=1$，其他都是 0

显然有
$$dp[i][j][k]=dp[i-1][j-t_1[i]\ ][k]\operatorname{or}dp[i-1][j][k-t_2[i]\ ]\operatorname{or}dp[i-1][j-t_3[i]\ ][k-t_3[i]\ ]$$

其中 $dp[i-1][j-t_1[i]\ ][k]$ 表示单独交给 A，$dp[i-1][j][k-t_2[i]\ ]$ 表示单独交给 B，$dp[i-1][j-t_3][k-t_3[i]\ ]$ 表示 AB 合作

复杂度已经 $\Theta(n^3)$ 了，妥妥的 TMLE

### 三、降维优化

对上述 naive 暴力进行优化

大胆改造：$dp[i][j]=k$，即执行第 $i$ 个任务时，A 已经做了 $j$ 时，B 做的最小时间 $k$

一个很显然的贪心：A、B 都应当连续做，这样总时间才最短

初始值：

因为要求最小值，所以 $dp[][]\leftarrow + \infty$，又因为当执行第 0 个任务，A 做了 0 时，B 最小做 0 时，所以有 $dp[0][0]\leftarrow 0$

状态转移方程：$dp[i][j]=\min\{dp[i-1][j-t_1[i]\ ],dp[i-1][j]+t_2[i],dp[i-1][j-t_3[i]\ ]+t_3[i]\}$

三项分别表示单独交给 A，单独交给 B，AB 合作，注意考虑是否能取到的问题，三项能取到的条件分别为 $t_1[i]\not=0,j>t_1[i]$，$t_2[i]\not=0$，$t_3[i]\not=0,j>t_3[i]$

最终答案即 $\min\limits_{i=1}^{maxt}\{\max\{i,dp[n][i]\}\}$

其中 $maxt=\sum\limits_{i=1}^n\max\{t_1[i],t_2[i],t_3[i]\}$

### 四、时空优化

这样依然会 MLE，考虑使用滚动数组

因为 $dp[i][]$ 仅由 $dp[i-1][]$ 推得，所以可以压掉这一维

原式即为 $dp[i\operatorname{and}1][j]=\min\{dp[i\operatorname{and}1\operatorname{xor}1][j-t_1[i]\ ],dp[i\operatorname{and}1\operatorname{xor}1][j]+t_2[i],dp[i\operatorname{and}1\operatorname{xor}1][j-t_3[i]\ ]+t_3[i]\}$，仍需考虑是否能取到

直接吃掉一维，但注意 $dp$ 数组的第二维最大值得开到 $n\times t$，即 $3\times10^4$

细节比较多，所以...

### 五、代码

```cpp
#include <bits/stdc++.h>
#define inl inline
#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;++i)
#define pre(i,a,b) for(int i=(a),i##end=(b);i>=i##end;--i)
#define min(x,y) (x<y?x:y)
#define max(x,y) (x>y?x:y)
using namespace std;
const int N=3e4+10;//注意数组大小
int dp[2][N],ans=0x3f3f3f3f,maxt;
signed main(void){
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    int n;cin>>n;
    memset(dp,0x3f,sizeof(dp));//初始化
    dp[0][0]=0;
    rep(i,1,n){
        memset(dp[i&1],0x3f,sizeof(dp[i&1]));//注意这里要再初始化一次！
        int x,y,z;cin>>x>>y>>z;maxt+=max(x,max(y,z));//省掉一个数组了
        rep(j,0,maxt){
            if(y)dp[i&1][j]=min(dp[i&1][j],dp[i&1^1][j]+y);
            if(x&&j>=x)dp[i&1][j]=min(dp[i&1][j],dp[i&1^1][j-x]);
            if(z&&j>=z)dp[i&1][j]=min(dp[i&1][j],dp[i&1^1][j-z]+z);//状态转移方程
        }
    }
    rep(i,0,maxt)ans=min(ans,max(i,dp[n&1][i]));
    cout<<ans;
}
```

### 六、总结

一道相当有趣且毒瘤的 DP 题，实现的思路非常诡异，而且还卡空间卡时（这里补充一句：**如果开 O2 还没过的大常数选手可以考虑手写 $\max,\min$ 函数以便卡常**），需要运用滚动数组来进行空间优化

---

## 作者：Coros_Trusds (赞：0)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/15778672.html)

清新 $\rm DP$ 题。

# 题目大意

有 $n$ 个任务，第 $i$ 个任务可以给 A 机器做，用时 $t_1[i]$；给 B 机器做，用时 $t_2[i]$；给 A 机器和 B 机器同时做，用时 $t_3[i]$。

求最小用时。

**当对应 $t[i]=0$ 时，代表不能给这个机器或这两个机器做。**

# 题目分析

令 $dp[i][j][k]$ 表示完成了前 $i$ 个任务，第一台机器耗时为 $j$，另一台耗时为 $k$，此时的最小总用时。

最终答案即为 $\min\{dp[n][j][k]\}$。

先不论时间，即便用上滚动数组优化，空间复杂度也已经炸成花了，我们考虑一个巧妙的优化：

令 $dp[i][j]$ 表示完成了前 $i$ 个 任务，第一台机器耗时为 $j$ 时第二台机器的最小耗时。

直接将 【第二台机器耗时】 这个东西干掉了！（

本题中状态转移方程并非重点，但还是摆上来：

$dp[i][j]=\min\{dp[i-1][j]+t2[i],dp[i-1][j-t1[i]],dp[i-1][j-t3[i]]+t3[i]\}$

仍然是可以滚动优化的。

时间复杂度 $\mathcal{O}(nk)$，空间复杂度 $\mathcal{O}(ns)$。

$s$ 是 $t1,t2,t3$ 的取值范围，$k$ 为 $\sum_{i=1}^n \max\{t1[i],t2[i],t3[i]\}$ 故 $k$ 最大为 $6\times 10^3\times5=3\times 10^4$。

可以通过本题。

# 代码

```cpp
//2022/1/8

const int INF=0x3f3f3f3f;

const int ma1=6005,ma2=30005;

int t1[ma1],t2[ma1],t3[ma1];

int dp[2][ma2];

int n;

int main(void)
{
	n=read();
	
	mst(dp,0x3f);
	
	dp[0][0]=0;
	
	for(register int i=1;i<=n;i++)
	{
		t1[i]=read(),t2[i]=read(),t3[i]=read();
	}
	
	int sum(0);
	
	for(register int i=1;i<=n;i++)
	{
		mst(dp[i&1],0x3f);
		 
		sum+=max({t1[i],t2[i],t3[i]});
		
		for(register int j=0;j<=sum;j++)
		{	
			if(t2[i]!=0) 
			{
				dp[i&1][j]=min(dp[i&1][j],dp[i&1^1][j]+t2[i]);
			}
			
			if(t1[i]!=0 && j>=t1[i]) 
			{
				dp[i&1][j]=min(dp[i&1][j],dp[i&1^1][j-t1[i]]);
			}
			
			if(t3[i]!=0 && j>=t3[i]) 
			{
				dp[i&1][j]=min(dp[i&1][j],dp[i&1^1][j-t3[i]]+t3[i]);
			}
		}
	}
	
	int ans=INF;
	
	for(register int i=0;i<=sum;i++)
	{
		ans=min(ans,max(i,dp[n&1][i]));
	}
	
	printf("%d\n",ans);
	
	return 0;
}
```

---

## 作者：TulipeNoire (赞：0)

仔细阅读本题，我们发现，我们不能定义 $dp[i][j]$ 为加工前 $i$ 个货物的最小时间，原因有二。

其一：开不下（对应滚动优化）。

其二：题目求的是在A机器和B机器加工所用时间的最大值，所以如果这样定义，不能具体到在两个机器加工所用的时间从而进行状态转移。

所以我们定义 $dp$ 的值为在B机器加工所用时间。即 $dp[j]$ 表示在A机器上加工时间为 $i$ ，在B机器上加工时间的最小值。

那么大致框架为:

$i:1->n$

$j:30000->0$
    
$\dots$


很明显， $dp[j]$ 的值就会有 $3$ 种情况，但需要判断每种情况是否可行（即值不为 $0$）。

答案就是 $\min\limits_{i=0}^{30000}\{\max(i,dp[i])\}$

即使这样，还是有可能TLE，怎么办呢？我进行了一个小小的优化。容易发现每一次循环 $i$ 都是从 $30000$ 开始，实际上完全不必要。 我们就用一个小小的变量 $f$ 统计有A机器加工时间的和，每次从 $f$ 开始枚举。

这样**不用开O2**，但是948ms 。。。只要能过就好。

上代码：

```cpp
#include<bits/stdc++.h>
#define min(i,j) (i<j?i:j)
#define max(i,j) (i<j?j:i)
using namespace std;
int n,a[6005][4],dp[30005],ans=1e9,f;
int main() {
    scanf("%d",&n);
    for (int i=1;i<=n;i++) {
        for (int j=1;j<=3;j++) {
            scanf("%d",&a[i][j]);
        }
    }
    memset(dp,127,sizeof(dp));
    dp[0]=0;
    for (int i=1;i<=n;i++) {
        f+=max(a[i][1],a[i][3]);
        for (int j=f;j>=0;j--) {
            int k=dp[j];
            dp[j]=1e9;
            if (j-a[i][1]>=0&&a[i][1]) dp[j]=min(dp[j],dp[j-a[i][1]]);
            if (a[i][2]) dp[j]=min(dp[j],k+a[i][2]);
            if (j-a[i][3]>=0&&a[i][3]) dp[j]=min(dp[j],dp[j-a[i][3]]+a[i][3]);
        }
    }
    for (int i=0;i<=f;i++) {
        ans=min(ans,max(i,dp[i]));
    }
    printf("%d",ans);
    return 0;
} 
```

---

## 作者：Exber (赞：0)

## 题意
- #### 有一些任务，两台机器 $A$ 和 $B$。
- #### 一个任务可以由 $A$ 做，或者由 $B$ 做，又或者两台机器一起做。注意，“一起做”不一定要两台机器都空闲（可以理解成机器 $C$ 在做）。
- #### 有一些任务无法由其中一台机器做或者无法一起做。
- #### 求做完所有任务的最短时间

## 做法
一道比较简单的**背包 DP** 问题。

我们用 $dp_{i,j}$ 来表示前 $i$ 个任务，$A$ 做 $j$ 时间的情况下 $B$ 用的最少时间。

转移方程就是:（$t1_i$、$t2_i$和$t3_i$含义与题目所述一致）

$dp_{i,j}=\left\{\begin{array}{ll}
min(dp_{i-1,j-t1_i})&t1_i\urcorner0\\
min(dp_{i-1,j}+t2_i)&t2_i\urcorner0\\
min(dp_{i-1,j-t3_i}+t3_i&t3_i\urcorner0
\end{array}\right.$

不过，还有一个棘手的问题，就是 $j$ 的上界。其实很好解决，只要每次输入都把上界加上 $\max(t1_i,t2_i,t3_i)$ 就行了。

由于只用用到当前的 $t1$、$t2$和$t3$ 所以可以边读入边 DP，不用存。

另外，本题卡空间和卡常，需要**加快读**、**开 O2**，DP 数组**需要滚动**，还需要确定一个 $j$ 的下界，求法在代码里给出。

不开 O2 的话有一个点卡在了 1.10 S……

## AC 代码
```cpp
#include <cstdio>
#include <cstring>

int n,inf=0x3f3f3f3f,dp[2][30005];
int l,r; // 下界、上界 
int t1,t2,t3;

inline int read() // 快读 
{
	int f=1,x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
		{
			f=1;
		}
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}

inline int mmin(int x,int y) // 自己写 max 和 min 
{
	return x<y?x:y;
}

inline int mmax(int x,int y) // 自己写 max 和 min
{
	return x>y?x:y;
}

int main()
{
	n=read();
	// 初始化 
	l=0;
	r=0;
	dp[0][0]=0;
	for(int i=1;i<=n;i++)
	{
		t1=read();
		t2=read();
		t3=read();
		r+=mmax(t1,mmax(t2,t3)); // 更改上界 
		memset(dp[i&1],0x3f,sizeof(dp[i&1])); // i&1 相当于 i%2，更快 
		for(int j=l;j<=r;j++) // DP 
		{
			// 状态转移 
			if(t1&&j>=t1) 
			{
				dp[i&1][j]=mmin(dp[i&1][j],dp[(i-1)&1][j-t1]);
			}
			if(t2)
			{
				dp[i&1][j]=mmin(dp[i&1][j],dp[(i-1)&1][j]+t2);
			}
			if(t3&&j>=t3)
			{
				dp[i&1][j]=mmin(dp[i&1][j],dp[(i-1)&1][j-t3]+t3);
			}
		}
		for(int j=l;j<=r;j++) // 确定下界 
		{
			if(dp[i&1][j]==inf) // 这个方案不存在，以后 DP 也不需要它了，抛弃 
			{
				l++;
			}
			else
			{
				break;
			}
		}
	}
	int ans=inf; // 求解答案 
	for(int i=l;i<=r;i++)
	{
		ans=mmin(ans,mmax(i,dp[n&1][i])); // 因为是同时做，所以取 max 
	}
	printf("%d\n",ans);
	return 0;
}
```

---


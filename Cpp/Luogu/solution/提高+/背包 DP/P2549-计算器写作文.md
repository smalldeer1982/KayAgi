# 计算器写作文

## 题目描述

众所周知，计算器可以拿来干很多它本不应该干的事情，比如弹琴。

小A发现了一个计算器的隐藏功能——写英语作文。

他在计算器上按一些数字，这些然后旋转 $180$ 度就是作文。

每个数字对应一两个字母

 ![](https://cdn.luogu.com.cn/upload/pic/1738.png) 



小 A 准备了一个单词表，选择其中的一些单词，按照一个顺序组成作文。这个作文是可以用计算器按出来的。比如单词表给 `ODD`、`EGG`，作文写成 `ODDEGG` 的话，那么要在计算器上按出 `993000`，这篇作文的得分就是 $993000$。

单词表的单词不能重复使用。如果单词表出现了多个一样的单词，每个单词最多都可以各使用一次。单词不可以被截断。

小 A 希望自己写出的作文得分最高。当然这个计算器是有位数限制，作文长度不能超过显示位数。

计算器不能显示前导零，但是你可以添加小数点。比如作文写成 `EGGODD` 的话，就得按出 $0.00993$，这个就是作文的得分，当然这得分太小了。


## 说明/提示



对于 $40\%$ 的数据，$D \leq 20,N \leq 10$。

对于 $100\%$ 的数据，$D \leq 200,N \leq 10000$，单词长度 $\leq 32$。

## 样例 #1

### 输入

```
7
4
EGG
ODD
LOBE
LIBE```

### 输出

```
9933817```

# 题解

## 作者：kkksc03 (赞：30)

简述：将一堆数字按照某些顺序排列，在限定答案的长度下数字最大。

首先先将这堆数字按按字典序排序。

然后dp;

贪心是错误的，因为你可能没法把位数填满。

对于前i个数字，长度为j的最大值,

f[i,j+s[i].length]=max(f[i-1,j+s[i].length],f[i-1,j]+s[i]);

f和s都是字符串类型，max是比较字典序大小。

请使用循环数组。


然而只能80分。

why？
如果全是0开头的数字呢？

贪心吧。只要能位数不够，就加进去。没关系的。反正有个小数点。


---

## 作者：星王桐 (赞：14)

主体：01背包+排序
看没有c++党的题解，支持一下。
状态转移方程楼下kkk已经讲得很清楚了
但我认为没必要用循环数组
献上本蒟蒻的代码
```cpp
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <valarray>
using namespace std;
int n,m;
string ans;
#define N 10010
//f,v,都是string 
string f[300];
int map[300];
string v[N];
int ni[N];
bool cmp(string a,string b) 
{
	string x=a+b,y=b+a;
	return x<y;
}
void init()//打表 
{  
	map['I']=1;map['D']=0;map['O']=0;map['q']=6;
    map['G']=9;map['Z']=2;map['E']=3;map['h']=4;
	map['S']=5;map['L']=7;map['B']=8;
}
string maxs(string a,string b) 
{
	int na=a.size(),nb=b.size();
	if (na==0)//特殊情况 
	return b;
	if (nb==0)
	return a;
	if (a[0]!='0'&&b[0]!='0')
	{
		if (na!=nb)//先判位数 
		return na>nb?a:b;
		return a>b?a:b;
	}
	return a>b?a:b;
}
int main()
{
	ios::sync_with_stdio(false); 
	cin>>m>>n;
    init();
    int i,j;
    for (i=1;i<=n;i++)
    {  
		string s;
		cin>>s;
        for (j=s.size()-1;j>=0;j--)
        v[i]+=(map[s[j]]+'0');//转换后放入v[i] 
    }
    sort(v+1,v+n+1,cmp);
    for (i=1;i<=n;i++)
    ni[i]=v[i].size();
    for (i=n;i>=1;i--)//01背包 
    for (j=m;j>=ni[i];j--)
    f[j]=maxs(f[j],f[j-ni[i]]+v[i]);//状态转移方程 
    if (f[m][0]!='0')//判断前导0
    cout<<f[m];
	else
	{
		cout<<"0.";//这里不知为何不能用printf,我用就80分 
		for (i=1;i<f[m].size();i++)
		cout<<f[m][i];
	}
    return 0;
}

```

---

## 作者：凯特琳 (赞：10)

简述：这是一道字符串01背包！

贪心是错误的，因为kkk解释过了

请不要使用循环数组，因为kkk说要用循环数组。

方程：

for i:=n downto 1 do

for j:=vm downto w[i] do

f[j]:=max(f[j],f[j-w[i]]+v[i]);

就是模板01背包代码，对吧。

不过这里的v{价值}存的是转换完的数串

w{体积}存的是数串的长度

然而这样做可能只有20-30分。

Why？
因为这不是一道裸的01背包。可以看到：我们先转移的i物品一定是在后转移的i+1物品的前面，就是说串i+1一定是加在了串i的后面某个位置（如果能加的话）。

所以显然也有可能是i+1这个串出现在i这个串的前面，所以显然现在是有后效性的（我们在考虑j串的时候还要考虑前面1..j-1个串的情况）

啊哈！感觉是不是想要转搜索了？


kaitelin说：NO！

Why？
去除后效性即可，如何去除？排序也！

设a，b两串，先a后b，则得到ab；先b后a，则得到ba

如果说ab>ba那么先放a一定比先放b要优，于是按照这个关键字进行快排

如果不懂这个关键字什么意思，请看程序快排部分。


然而只能80分。

why？
要是全是0开头的数字呢？因为kkk说80分是因为全是前导0，所以不是因为这个问题

其实，是存在全是前导0这种情况的。然而，我们的80分并不是因为这个。

不要贪心！因为kkk说要用贪心！

用了背包还要贪心？怎么可能？

那么问题在于我们的max函数了

如果你这样写：if aa>bb then exit(aa)  else exit(bb);

那么真的是80分。


那么小讲一下pascal里面关于 字符串比较的问题：

给出两个串a，b ，系统是不看长度的，只比较第一个不一样的字符

也就是说：9>1000000;110>109;

那么我们看有前导0的情况。额。用系统的比较字符串的方法 完全正确！

那么我们看没有前导0的情况。额，显然位数大的串一定大于位数小的串吧。。那么读者知道怎么写max函数了吧？

于是AC了。。


kkk弱爆了。

贴上代码：










```cpp
var biao:array['A'..'z']of char;
var f:array[0..200]of ansistring;
var v:array[1..10000]of ansistring;
var w:array[1..10000]of longint;
var i,j,m,n,vm:longint;
var cc:ansistring;
procedure qsort(l,r:longint);//排序
var i,j,temp2:longint;
var temp,mid:ansistring;
begin
i:=l;
j:=r;
mid:=v[(l+r) div 2];
while i<j do
begin
while v[i]+mid<mid+v[i] do inc(i);//这个就是先放mid要优。
while v[j]+mid>mid+v[j] do dec(j);//这个就是先放j要优
if i<=j then
begin
temp:=v[i];
v[i]:=v[j];
v[j]:=temp;
temp2:=w[i];
w[i]:=w[j];
w[j]:=temp2;
inc(i);
dec(j);
end;
end;
if l<j then qsort(l,j);
if i<r then qsort(i,r);
end;
function max(aa,bb:ansistring):ansistring;//本题精髓的max函数
begin
if (length(aa)=0)or(length(bb)=0) then//如果某串长度是0，请直接比较了
begin
if aa>bb then exit(aa)
else exit(bb);
end;
if (aa[1]<>'0')and(bb[1]<>'0') then//两串都不为空，且两串都没有前导0
begin
if length(aa)>length(bb) then exit(aa);//长度长的为大
if length(bb)>length(aa) then exit(bb);
if aa>bb then exit(aa)//长度一样的话，就让系统比较去吧
else exit(bb);
end;
if aa>bb then exit(aa)//最后一种情况：两串非空，两串都有前导0，也交给系统
else exit(bb);
end;
begin
readln(vm);
readln(n);
biao['O']:='0';//表
biao['D']:='0';
biao['G']:='9';
biao['B']:='8';
biao['L']:='7';
biao['q']:='6';
biao['S']:='5';
biao['s']:='5';
biao['h']:='4';
biao['E']:='3';
biao['Z']:='2';
biao['z']:='2';
biao['I']:='1';
for i:=1 to n do
begin
readln(cc);
for j:=length(cc) downto 1 do
v[i]:=v[i]+biao[cc[j]];
w[i]:=length(cc);
end;
qsort(1,n);
for i:=n downto 1 do
for j:=vm downto w[i] do
f[j]:=max(f[j],f[j-w[i]]+v[i]);
if f[vm][1]<>'0' then writeln(f[vm])
else
begin
write('0.');
for i:=2 to length(f[vm])do
write(f[vm][i]);
end;
end.
```
没什么好说的了。。。

其实童鞋们可以看一下  烹调方案那个题。也是要排序


---

## 作者：rsjw (赞：4)

观察题目，很容易转换题目:

给定 $n$ 个只含数字的字符串，要求拼接其中的一些，使位数不超过 $d$ ，**可以加小数点**，问拼接后的数字最大是多少？

我们很容易想到 $01$ 背包，用 $F_{i,j}$ 表示前 $i$ 个数字拼接后位数是 $j$ ，但存在一个问题:

怎么推我们的转移方程呢?

$$F_{i,j}=max\{F_{i-1,j-s_i.len}+s_i,F_{i-1,j}\}$$

在上式中，加号 $+$ 代表两个字符串拼接。

但是这样有一个问题,怎么保证方程式没有后效性呢?

根据贪心的思想，很容易想到按字典序排序。

但是这样不对。因为 $kkk$ 说要按字典序排序。

举个栗子说明吧：

$$a=\texttt{123},b=\texttt{1}$$

字典序排序后的结果是这样的: $b$ 在 $a$ 之前

但 $1231>1123$，

所以不对。

根据我们判断的原则，我们可以这样写 $cmp$ 函数:

```cpp
inline bool cmp2(const string &a,const string &b) {
    return (a+b)>(b+a);
}
```
所以这个问题解决了。

从 $F_{n,0}$ 到 $F_{n,d}$ 取最大值即可。

注意:取最大值时要优先比较位数。

但这样只能得到 $80pts$ 。

因为还有全是前导零的情况。这样怎么办呢？

这在把 $f$ 数组按照字典序排序即可。

代码如下：

```cpp
#include <cstdio>
#include <cstring>
#include <string>
#include <algorithm>

using namespace std;
char tmp[35],mp[35];
string b[10001],f[201];
int lb,tmp0,tmp1;
bool Tmax(const string &a,const string &b) {
	tmp0=tmp1=0;
	while(a[tmp0]=='0') tmp0++;
	while(b[tmp1]=='0') tmp1++;
	if(a.length()-tmp0!=b.length()-tmp1) return a.length()-tmp0<b.length()-tmp1;
	return a<b;
}
bool cmp(const string &a,const string &b) {
	return (a+b)>(b+a);
}
int main() {
	//freopen("2.in","r",stdin);
	int d,n,i,j;
	scanf("%d%d",&d,&n);
	mp['O'-'A']=mp['D'-'A']='0',mp['I'-'A']='1',mp['Z'-'A']='2',mp['E'-'A']='3',mp['H'-'A']='4',mp['S'-'A']='5',mp['Q'-'A']='6',mp['L'-'A']='7',mp['B'-'A']='8',mp['G'-'A']='9';
	for(i=1; i<=n; i++) {
		scanf("%s",tmp);
		int l=strlen(tmp)-1;
		if(tmp[l]!='O'&&tmp[l]!='D') lb++;
		for(j=l; j>-1; j--)
			if(tmp[j]>='a'&&tmp[j]<='z') b[i]+=mp[tmp[j]-'a'];
			else b[i]+=mp[tmp[j]-'A'];
	}
	sort(b+1,b+n+1,cmp);
	for(i=1; i<=n; i++)
		for(j=d; j>=b[i].length(); j--)
			if(Tmax(f[j],f[j-b[i].length()]+b[i])) f[j]=f[j-b[i].length()]+b[i];
	string maxn=f[0];
	for(j=1; j<=d; j++) if(Tmax(maxn,f[j])) maxn=f[j];

	if(maxn[0]=='0') {
		printf("0.");
		string maxn=f[0];
		for(j=1; j<=d; j++) if(f[j]>maxn) maxn=f[j];
		for(int i=1; i<maxn.length(); i++) printf("%c",maxn[i]);
	} else printf("%s\n",maxn.c_str());
	return 0;
}
```


---

## 作者：Chthologist7507 (赞：1)

## 一、转化题意

给定 $n$ 个大数，拼接其中一些，位数不超过 $d$，可以加小数点（不算位数），求位数的最大值

显然如果不是全都有前导 0，不需要加小数点

## 二、为什么是 $01$ 背包？

在 $N$ 个字符串取出若干个放在长度为 $D$ 的“背包”里，每个数字的长度为 $l_1,l_2...l_n$，与之相对应的价值为 $d_1,d_2...d_n$。

显然是符合定义的

于是可以写出方程 $dp_j=\max\{dp_j,dp_{j-L_i}+d_i\}$

## 三、细节处理

可以注意到 $dp$ 和 $d$ 数组均是字符串，不妨将 $+$ 定义为字符串的拼接，为保证无后效性，显然可以将 $d$ 数组排序

3k 说要按字典序排序，但是这似乎不对

这里需要分类讨论：

1. 存在不含前导 0 的字符串

这种情况很简单，$cmp$ 函数直接写 $a+b>b+a$ 就行，注意重载 $>$ 运算符

注意它与字典序排序是不同的，例如字典序排序中 $"1">"12"$，但是实际上 $112<121$，并不是最优解

2. 不存在不含前导 0 的字符串

这种情况就是基本的字典序排序

然后就完了，输出 $dp[m]$ 即可

## 四、代码实现

我自己是用结构体封装重载运算符的，看上去比较舒服，至少 dp 式子拿来就用

```cpp
#include <bits/stdc++.h>
#define inl inline
#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;++i)
#define pre(i,a,b) for(int i=(a),i##end=(b);i>=i##end;--i)
using namespace std;
map<char,int>mp;bool pd;//pd 表示是否全部含有前导 0,1 表示存在不含前导 0 的
struct Node{
    int d[210],l;//d 数组就是上文的 d 数组，l 表示 d 数组的长度
    inl Node operator+(const Node b)const{
        Node c;
        rep(i,1,l)c.d[i]=d[i];rep(i,1,b.l)c.d[i+l]=b.d[i];
        c.l=l+b.l;
        return c;
    }//+ 重载为字符串拼接
    inl bool operator>(const Node b)const{
        if(pd){
            if(l!=b.l)return l>b.l;
            rep(i,1,l)if(d[i]!=b.d[i])return d[i]>b.d[i];
            return 0;
        }
        int len=min(l,b.l);
        rep(i,1,len)if(d[i]!=b.d[i])return d[i]>b.d[i];
        return l>b.l;
    }//重载了 > 号
}a[10010],dp[210];
inl Node max(Node a,Node b){return a>b?a:b;}//重载 max，因为 C++ 中的 max 是基于 < 号的，也是为了卡卡常
inl bool cmp(Node a,Node b){
    if(pd)return (a+b)>(b+a);//1. 存在不含前导 0 的字符串
    int len=min(a.l,b.l);
    rep(i,1,len)if(a.d[i]!=b.d[i])return a.d[i]>b.d[i];
    return a.l>b.l;//2. 不存在不含前导 0 的字符串
}
signed main(void){
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    mp['O']=0,mp['D']=0,mp['G']=9,mp['B']=8,mp['L']=7,mp['q']=6,mp['S']=5,mp['h']=4,mp['E']=3,mp['Z']=2,mp['I']=1;//由题中的图可以得到这样一张表
    int m,n;cin>>m>>n;
    rep(i,1,n){
        string s;cin>>s;
        reverse(s.begin(),s.end());
        a[i].l=s.size();
        rep(j,0,a[i].l-1)a[i].d[j+1]=mp[s[j]];//字母字符串倒序再映射为数字字符串
        if(a[i].d[1]>0)pd=1;
    }
    sort(a+1,a+n+1,cmp);
    rep(i,1,n)pre(j,m,a[i].l)dp[j]=max(dp[j],dp[j-a[i].l]+a[i]);//可爱的 dp
    cout<<dp[m].d[1];
    if(!pd)cout<<'.';
    rep(i,2,dp[m].l)cout<<dp[m].d[i];
}
```

---

## 作者：cunzai_zsy0531 (赞：1)

### P2549 计算器写作文 题解 by zsy

------------

[题目链接](https://www.luogu.com.cn/problem/P2549)

我们首先考虑把两个单词合起来的运算定义为 $+$，那么如果 $A+B>B+A$，无论怎么合并，我们都一定会把 $A$ 放在 $B$ 的前面。

于是我们可以通过这样一个判定方法将所有的单词排序，然后跑背包。即设 $f_{i,j}$ 表示前 $i$ 个单词，长度为 $j$ 时能够得到的最大值。那么有：

$$f_{i,j}=\max(f_{i-1,j},f_{i-1,j-a_i.len}+a_i )$$

注意这里的 $+$ 就是上面我们定义的 $+$，与此同时，$\max$ 运算也需要特殊比较，方法是这样：
```cpp
bool operator >(const Big &A)const{
	if(len!=A.len) return len>A.len;
	for(int i=1;i<=len;++i)
             if(d[i]!=A.d[i]) return d[i]>A.d[i];
  	return 0;
}
```
就比较像高精度里边的比较大小。

但是这样的话并不能通过所有的数据，为什么呢？

我们发现，这个做法在个位为 $0$ 时不成立，因为小数的大小比较不比较长度，只比较每一位。也就是说我们需要判断，是不是所有的单词都以 $0$ 开头。这时候我们前面的排序也需要按照这种新方式，然后同样跑一个背包。$\max$运算的比较方法变成了：
```cpp
bool operator <(const Big &A)const{
	int tmp=min(len,A.len);
	for(int i=1;i<=tmp;++i)
		if(d[i]!=A.d[i]) return d[i]<A.d[i];
	return len<A.len;
}
```
这样我们就可以通过这道题。

这个题的单词，我是通过 $struct$ 定义了大整数类型来存储的。这样做有很大的优势，因为可以通过 $operator$ 重载运算符，使代码非常简洁。建议大家尝试。

总结一下思考这类题的方式：首先把 $dp$ 方程设出来，发现是一个背包，背包 $dp$ 需要考虑顺序问题，它无法处理顺序可能不同的选择。所以我们根据两个单词合并的大小得到了顺序，可以跑背包了。然后我们发现 $0$ 开头所组成的小数，因为判定大小的方法不同而需要重新处理。最终我们综合以上想法可以通过此题。

最后放上 $AC$ 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<map>
#include<algorithm>
using namespace std;
const int N=200+13,M=10000+13;
struct Big{//使用了struct自定义类型存储，优势明显
	int d[N],len;
	Big(){memset(d,0,sizeof d);len=0;}//初始化
	Big operator +(const Big &A)const{
		Big Ans;
		for(int i=1;i<=len;++i) Ans.d[i]=d[i];
		for(int i=1;i<=A.len;++i) Ans.d[i+len]=A.d[i];
		Ans.len=len+A.len;
		return Ans;
	}
	bool operator >(const Big &A)const{//第一种比较方式
		if(len!=A.len) return len>A.len;
		for(int i=1;i<=len;++i)
			if(d[i]!=A.d[i]) return d[i]>A.d[i];
		return 0;
	}
	bool operator <(const Big &A)const{//第二种，整数位为0时的比较方式
		int tmp=min(len,A.len);
		for(int i=1;i<=tmp;++i)
			if(d[i]!=A.d[i]) return d[i]<A.d[i];
		return len<A.len;
	}
}a[M],f[N];
ostream &operator <<(ostream &output,Big A){//并不非常常见的重载输出
	if(A.d[1]==0){
		output<<"0.";
		for(int i=2;i<=A.len;++i) output<<A.d[i];
	}
	else for(int i=1;i<=A.len;++i) output<<A.d[i];
	output<<endl;return output;
}
int n,m;
map<char,int> ms;
inline void init(){
	ms['O']=ms['D']=0,ms['G']=9,ms['B']=8,ms['L']=7,
	ms['q']=6,ms['S']=5,ms['h']=4,ms['E']=3,ms['Z']=2,ms['I']=1;
}
inline bool cmp1(Big A,Big B){return (A+B)>(B+A);}
inline bool cmp2(Big A,Big B){
	int tmp=min(A.len,B.len);
	for(int i=1;i<=tmp;++i)
		if(A.d[i]!=B.d[i]) return A.d[i]>B.d[i];
	return A.len>B.len;
}
inline void solve1(){
	sort(a+1,a+n+1,cmp1);
	for(int i=1;i<=n;++i)
	for(int j=m;j>=a[i].len;--j){
		Big Tmp=f[j-a[i].len]+a[i];
		if(Tmp>f[j]) f[j]=Tmp;
	}
	cout<<f[m];
}
inline void solve2(){
	sort(a+1,a+n+1,cmp2);
	for(int i=1;i<=n;++i){
		for(int j=m;j>=a[i].len;--j){
			Big Tmp=f[j-a[i].len]+a[i];
			if(f[j]<Tmp) f[j]=Tmp;
		}
	}
	cout<<f[m];
}
int main(){
	init();//预处理字母与数字的对应关系，用map比较容易实现
	scanf("%d%d",&m,&n);
	for(int i=1;i<=n;++i){
		char s[40];
		scanf("%s",s+1);
		int l=strlen(s+1);
		a[i].len=l;
		for(int j=l;j>=1;--j) a[i].d[l-j+1]=ms[s[j]];
	}
	bool state=0;
	for(int i=1;i<=n;++i)
		if(a[i].d[1]>0){state=1;break;}
	if(state) solve1();//需要不同的大小判断，所以分两种不同的方式解决
	else solve2();
	return 0;
}
```


---

## 作者：_Only_this (赞：1)

### P2549 计算器写作文 题解

------------

这题是集训讲 dp 时偶然刷到的一道老题（题解里怎么全是内涵 kkk 的），其他大佬都秒切了，就我一直卡着......

题目简化：将一堆数拼起来，总长度不大于 $D$，使拼起来的数尽可能大。

这个题虽然是 dp，但我认为思想上最核心的部分是贪心，先将预处理好的数字串排个序，使其满足无后效性才能进行 dp。

至于如何排序，比较两个数字串两种拼接的结果按字典序排一个大小就行了，因为在前在后不会影响总长度，所以直接按字典序排即可。

然后就是 01 背包，但 $\max$ 函数得自己写写。

最后别忘了处理有前导零的情况。

下面上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e4+5;
const int maxm = 2e2+5;
int m,n;
string s[maxn],t[maxn],dp[maxm];
inline char C(char x){
	if(x=='O' || x=='D')
		return '0';
	if(x=='G')
		return '9';
	if(x=='B')
		return '8';
	if(x=='L')
		return '7';
	if(x=='q')
		return '6';
	if(x=='S')
		return '5';
	if(x=='h')
		return '4';
	if(x=='E')
		return '3';
	if(x=='Z')
		return '2';
	return '1';
}
inline bool Cmp(string s,string t){
	return s+t>t+s;
}
inline string Max(string s,string t){
	string ss=s,tt=t;
	int now=-1;
	while(s[++now]=='0')
		s.erase(0,1);
	now=-1;
	while(t[++now]=='0')
		t.erase(0,1);
	int l1=s.size(),l2=t.size();
	if(l1>l2)
		return ss;
	if(l2>l1)
		return tt;
	if(s>t)
		return ss;
	if(t>=s)
		return tt;
}
int main(){
	
//	cout<<Max("0003","009")<<endl;
//	return 0;
	
	scanf("%d%d",&m,&n);
	for(int i=1;i<=n;i++)
		cin>>t[i];
	for(int i=1;i<=n;i++){
		reverse(t[i].begin(),t[i].end());
		for(int j=0;j<t[i].size();j++)
			s[i]+=C(t[i][j]);
	}
	sort(s+1,s+n+1,Cmp);
	
//	for(int i=1;i<=n;i++)
//		cout<<s[i]<<endl;
//	return 0;
	
	for(int i=1;i<=n;i++)
		for(int j=m;j>=s[i].size();j--)
			dp[j]=Max(dp[j],dp[j-s[i].size()]+s[i]);
	string ans;
	for(int i=0;i<=m;i++)
		ans=Max(ans,dp[i]);
	
//	for(int i=1;i<=m;i++)
//		cout<<dp[i]<<endl;
//	return 0;
	
	if(ans[0]=='0'){
		ans.erase();
		for(int i=0;i<=m;i++)
			ans=max(ans,dp[i]);
		printf("%s","0.");
		for(int i=1;i<ans.size();i++)
			printf("%c",ans[i]);
	}
	else
		cout<<ans<<endl;
	return 0;
}
```


---

## 作者：hanzhongtlx (赞：0)

容易发现是一道类似背包的问题。  

和背包唯一不同的是选择顺序对答案有影响，不难知道任何时候最优选择顺序都是一定的（能造成最大贡献的放前面），所以按照两字符串拼接后的大小排序即可。  

字符串的数字还原与比较较为恶心，所以要精细一些，具体实现方式大概是： 

```
int tran(char c)
{
	int x;
	if(c=='O'||c=='D') x=0;
	else if(c=='G') x=9;
	else if(c=='B') x=8;
	else if(c=='L') x=7;
	else if(c=='q') x=6;
	else if(c=='S') x=5;
	else if(c=='h') x=4;
	else if(c=='E') x=3;
	else if(c=='Z') x=2;
	else if(c=='I') x=1;
	return x;
}

bool cmp(string s,string t)
{
	int l=s.size();
	for(int i=l-1;i>=0;i--)
	{
		int op=tran(s[i]),rt=tran(t[i]);
		if(op>rt) return 1;
		else if(op<rt) return 0;
	}
	return 0;
}
```  

然后进行 $dp$ ，这里就不在赘述了。  

但是，有一个坑点： 

对于小于 $1$ 的答案，并不一定字符越长越大，所以需要特判一下，对于其他的，按要求输出即可，具体的操作方式请看代码： 

```
#include"iostream"
#include"cstdio"
#include"cstring"
#include"algorithm"
using namespace std;

#define read(x) scanf("%d",&x)

string dp[205],maxn;
int vis[205];
int D,n;
char c[35],e[205];
string s[10005];
int len[10005];
int flag=0;

int tran(char c)
{
	int x;
	if(c=='O'||c=='D') x=0;
	else if(c=='G') x=9;
	else if(c=='B') x=8;
	else if(c=='L') x=7;
	else if(c=='q') x=6;
	else if(c=='S') x=5;
	else if(c=='h') x=4;
	else if(c=='E') x=3;
	else if(c=='Z') x=2;
	else if(c=='I') x=1;
	return x;
}

bool cmp(string s,string t)
{
	int l=s.size();
	for(int i=l-1;i>=0;i--)
	{
		int op=tran(s[i]),rt=tran(t[i]);
		if(op>rt) return 1;
		else if(op<rt) return 0;
	}
	return 0;
}

bool cmppp(string a,string b)
{
	int lena=a.size(),lenb=b.size();
	for(int i=lena-1;i>=0;i--)
	{
		int op=tran(a[i]),rt=tran(b[i-lena+lenb]);
		if(op>rt) return 1;
		else if(op<rt) return 0;
	}
	return 0;
}

bool cmpp(string a,string b)
{
	if(cmp(a+b,b+a)) return 1;
	else return 0;
}

int main()
{
	read(D),read(n);
	for(int i=1;i<=n;i++) scanf("%s",c),s[i]=c;
	sort(s+1,s+n+1,cmpp);
	for(int i=1;i<=n;i++) len[i]=s[i].size();
	for(int i=1;i<=D;i++)
	{
		for(int j=0;j<i;j++) e[j]='O';
		dp[i]=e;
	}
	vis[0]=1;
	for(int i=1;i<=n;i++)
	{
		for(int j=D-len[i];j>=0;j--)
		{
			if(!vis[j]) continue;
			vis[j+len[i]]=1;
			string o=dp[j],t=s[i],ans;
			if(o=="") ans=s[i];
			else
			{
				string ss=o+t,tt=t+o;
				if(cmp(ss,tt)) ans=ss;
				else ans=tt;	
			}
			if(cmp(ans,dp[j+len[i]])) dp[j+len[i]]=ans;
		}
	}
	int k;
	for(k=D;k>=0;k--) if(vis[k]) break;
	if(dp[k][k-1]=='O'||dp[k][k-1]=='D')//特判小数
	{
		if(k==1) return puts("0"),0;
		string ans=dp[k];
		int lenn=k;
		for(int i=k;i>=1;i--)
		{
			if(cmppp(dp[i],ans)) ans=dp[i],lenn=i;
		}
		printf("0.");
		for(int i=lenn-2;i>=0;i--) printf("%d",tran(ans[i]));
		puts("");
	}
	else
	{
		for(int i=k-1;i>=0;i--) printf("%d",tran(dp[k][i]));
		puts("");
	}
	return 0;
}
```

---


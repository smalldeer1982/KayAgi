# [TJOI2013] 黄金矿工

## 题目描述

小 A 最近迷上了在上课时玩《黄金矿工》这款游戏。为了避免被老师发现，他必须小心翼翼，因此他总是输。

在输掉自己所有的金币后，他向你求助。每个黄金可以看做一个点（没有体积）。现在给出你 $N$ 个黄金的坐标，挖到它们所需要的时间以及它们的价值。有些黄金在同一条直线上，这时候你必须按顺序挖。你可以瞬间把钩子转到任意角度。

小 A 一开始在坐标 $(0,0)$，请你帮助小 A 算出在时间 $T$ 内他最多可以得到多少价值的金子。

## 说明/提示

- 对于 $30\%$ 的数据，$0<T\le 4\times 10^3$；
- 对于 $100\%$ 的数据，$1\le N\le 200$，$0<T\le 4\times 10^4$。

保证 $0\le|x|\le 200$，$0<y≤200$，$0<t\le 200$，$0\le v\le 200$。

## 样例 #1

### 输入

```
3 10
1 1 1 1
2 2 2 2
1 3 15 9```

### 输出

```
3```

## 样例 #2

### 输入

```
3 10
1 1 13 1
2 2 2 2
1 3 4 7```

### 输出

```
7```

# 题解

## 作者：AlexZhang (赞：18)

这题还行吧，就难度而言emmm，其实这题首先用到了笛卡尔坐标系求斜率，看看是不是一条线上的（上过初中的都知道），然后呢在下面的金子肯定是被后挖到的，那么挖这块金子的前提，就是必须得把上面的都挖完，那么很明显这就是一个依赖性的背包问题了，相关题目详见noip2006金明的预算方案。。。。emmm，直接上代码吧
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
struct edge{
    int x,y,t,v;
    double b;
}e[2005];
bool cmp(edge x,edge y){
    if(x.b==y.b) return x.y<y.y;
    return x.b<y.b;
}
int n,T,cnt,js[2005];int v[2005][2005],t[2005][2005],f[40005];
int main(){
    memset(js,0,sizeof(js));
    scanf("%d%d",&n,&T);
    for(int i=1;i<=n;i++){
        scanf("%d%d%d%d",&e[i].x,&e[i].y,&e[i].t,&e[i].v);
        e[i].b=e[i].y*1.0/(e[i].x*1.0);
    }
    sort(e+1,e+1+n,cmp);
    for(int i=1;i<=n;i++){
        if(e[i].b!=e[i-1].b||i==1)
            ++cnt;
        if(js[cnt]==0){
            v[cnt][++js[cnt]]=e[i].v;
            t[cnt][js[cnt]]=e[i].t;
        }
        else{
            ++js[cnt];
            v[cnt][js[cnt]]=v[cnt][js[cnt]-1]+e[i].v,t[cnt][js[cnt]]=t[cnt][js[cnt]-1]+e[i].t;
        } 
    }
    for(int i=1;i<=cnt;i++)
        for(int j=T;j>=t[i][1];j--){
            int maxn=f[j];
            for(int k=1;k<=js[i];k++){
                if(j>=t[i][k])
                    maxn=max(maxn,f[j-t[i][k]]+v[i][k]);
            }
            f[j]=maxn;
        }
    //for(int i=1;i<=cnt;i++)
    //	for(int j=1;j<=js[i];j++)
    //		printf("%d %d %d %d \n",i,j,t[i][j],v[i][j]);
    printf("%d",f[T]);
    return 0;
}
```
求审核大大给过，毕竟暂时只有我这么一篇题解

哪里不理解可以问我

距离NOIp2018还有99天，共勉！

---

## 作者：老彩笔 (赞：7)

看到楼上的dalao们都用了二维背包，我来发个一维的吧。

简单说下思路：

先把矿物根据斜率(公式x1*y2==x2*y1)分成几组，用vector存起来

然后根据纵坐标的大小排个序

最后就是简单的01背包了

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()//快读; 
{
	char ch=getchar();int x=0,f=1;
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10-48+ch;ch=getchar();}
	return x*f;
}
const int maxn=40005;
int n,T;
vector<int>a[maxn];//vector用来存同一条直线上的矿物； 
int x[maxn],y[maxn],w[maxn],t[maxn],f[maxn];//x存横坐标,y存纵坐标,w存价值,t存时间,f是01背包; 
struct D
{
	int a ,b; 
 } d[maxn];
bool chk[maxn];//判断这个矿物是否标记过; 
bool cmp(D a,D b)//排序; 
{
	return abs(a.b)<abs(b.b);
}
int main()
{
	n=read(),T=read();
	for(int i=1;i<=n;i++)
	{
		x[i]=read(),y[i]=read(),t[i]=read();w[i]=read();
	}
	for(int i=1;i<=n;i++)//枚举每个点; 
	{
		for(int j=1;j<=n;j++)
		{
			//判断斜率相等用x1*y2==x2*y1; 
			if(i!=j&&x[i]*y[j]==x[j]*y[i]&&!chk[i])//如果在同一条直线且没被标记过; 
			{
				a[i].push_back(j);//同一条直线的矿物放在一起; 
				chk[j]=1;//标记 
			}
		
		}
	}
	for(int i=1;i<=n;i++)if(!chk[i])a[i].push_back(i);//记得把自己也放进去; 
	for(int i=1;i<=n;i++)
	{
		if(!chk[i])
		{
			int len=a[i].size();
			if(len)
			{
				for(int j=0;j<len;j++)//用d来存数; 
				{
					d[j].a=a[i][j];
					d[j].b=y[a[i][j]];
				}
				sort(d,d+len,cmp);//排序; 
				for(int j=0;j<len;j++)
				{
					a[i][j]=d[j].a;//排完序后在放回去; 
				}
			}
		}
	}
	for(int i=1;i<=n;i++)
	for(int j=T;j>=0;j--)//01背包倒着找; 
	{
		if(!chk[i])//被标记过就不枚举; 
		{
			int len=a[i].size(),sum=0,t1=0;
				for(int k=0;k<len;k++)//把在同一条直线上的价值和时间加和; 
				{
					sum+=w[a[i][k]];
					t1+=t[a[i][k]];
				}
				for(int k=len-1;k>=0;k--)//遍历同一直线的每一个矿物 ;
				{
					if(j>=t1)
					{
						f[j]=max(f[j],f[j-t1]+sum);//01背包; 
					}
					t1-=t[a[i][k]]; 
					sum-=w[a[i][k]];
				}
			}
	}
	cout<<f[T]<<'\n';
	return 0;
}
```


---

## 作者：斯德哥尔摩 (赞：6)

[P3961 [TJOI2013]黄金矿工](https://www.luogu.org/problemnew/show/P3961)

这其实是一道我们的考试题。。。~~（出题人竟然考原题太无耻了！）~~

反正我在考场上花了$10min$把$T2$正解写完，再花$20min$把$T3$暴力写完，就开始写这个灰常坑的$T1$。。。

然后我发现当我把正解$YY$完，代码还没写完的时候，已经$2h30min$又过去了。。。

首先说一下思路：

我们发现这其实是个有限制条件的背包问题。

也就是说，如果$i,j$两个点到原点斜率相等，即：$\frac{y_i}{x_i}==\frac{y_j}{x_j}$，并且$|x_i|<|x_j|$，那么必须先取$i$，然后才可以选择取不取$j$；否则一定不能取$j$。

我的想法就是对于这些限制，建图。

从$x$最小的连到满足上述条件的最近的一个点，一直到最后一个点。

然后把所有的联通块$dfs$出来，每个联通块内都从第一个点到最后一个点做一次前缀和。

然后我们有了许多联通块，并且把有限制条件的背包转化成了分组背包，每组只能选一个物品。

这不就很好做了嘛。。。

但是那个建图很麻烦。。。

由于$n<=200$，所以直接暴力。。。

还有的细节可以看看代码。

附代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#define MAXN 210
#define MAXT 80010
#define eps (1e-15)
using namespace std;
int n,m;
int t[MAXN],v[MAXN],dp[MAXT];
struct Point{//点
	int x,y,t,v,id;
}point[MAXN];
int c=1,top=0,head[MAXN],indegree[MAXN];
struct Edge{//图
	int next,to;
}a[MAXN*MAXN];
inline int read(){//读入优化
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
inline bool cmp1(const Point &p,const Point &q){//按横纵坐标排序
	if(p.x==q.x)return p.y<q.y;
	return p.x<q.x;
}
inline bool cmp2(const Point &p,const Point &q){//按联通块编号排序
	if(p.id==q.id)return abs(p.x)<abs(q.x);//记得有这句。。。
	return p.id<q.id;
}
inline void add_edge(int x,int y){//连单向边
	indegree[y]++;//入度，用于判断联通块的根
	a[c].to=y;a[c].next=head[x];head[x]=c++;
}
inline double slope(double x,double y){//某点到原点的斜率
	if(x==0)return 0.00;
	return (double)y/x;
}
void build(){//建图
	//分成三段来考虑建图：y轴左侧，y轴上，y轴右侧
    //这三段互不影响，可以画个图感性理解一下。。。
	int boundary=1,last;//每一段的起止点
	while(point[boundary].x<0)boundary++;
	for(int i=boundary-1;i>=1;i--)//暴力对y轴左侧建图，记得是倒着搜
	for(int j=i-1;j>=1;j--){
		if(i==j)return;
		if(fabs(slope(point[i].x,point[i].y)-slope(point[j].x,point[j].y))<eps){
			point[j].v+=point[i].v;point[j].t+=point[i].t;
			add_edge(i,j);
			break;//只加最近的点
		}
	}
	last=boundary;
	while(point[boundary].x==0)boundary++;//对y轴上的建图
	for(int i=last+1;i<boundary;i++){point[i].v+=point[i-1].v;point[i].t+=point[i-1].t;}
	last=boundary;
	for(int i=last;i<=n;i++)//对y轴右侧的建图
	for(int j=i+1;j<=n;j++){
		if(i==j)return;
		if(fabs(slope(point[i].x,point[i].y)-slope(point[j].x,point[j].y))<eps){
			point[j].v+=point[i].v;point[j].t+=point[i].t;
			add_edge(i,j);
			break;//同样只加最近的点
		}
	}
}
void dfs(int rt){//dfs求联通块
	for(int i=head[rt];i;i=a[i].next){
		int will=a[i].to;
		point[will].id=point[rt].id;//直接把联通块的编号弄成相等
		dfs(will);
	}
}
void work(){//开始dp
	for(int i=1;i<=n;i++){v[i]=point[i].v;t[i]=point[i].t;}//为了方便。。。
	for(int i=1;i<=n;i++){
		int l=i,r=i;//每个联通块的左右区间
		while(point[r+1].id==point[l].id)r++;//直接搜
		for(int k=m;k>=t[l];k--){//对每个容量大小dp一次
			int s=dp[k];
            /*
            由于这个块内只能选一个，那么也就是说，只有一个最大值是我们要dp出来的
            所以我们的滚动数组就不能边dp边滚动了
            而是要最后滚动一次，中间过程用个变量记一下最大值就好
            */
			for(int j=l;j<=r;j++)if(k>=t[j])s=max(s,dp[k-t[j]]+v[j]);
			dp[k]=s;//最后滚动
		}
		i=r;//记得直接跳。。。
	}
	printf("%d\n",dp[m]);//输出
}
void init(){//预处理
	n=read();m=read();
	for(int i=1;i<=n;i++){
		point[i].x=read();point[i].y=read();
		point[i].t=read();point[i].v=read();
	}
	sort(point+1,point+n+1,cmp1);//先按横纵坐标排个序
	build();//建图
	for(int i=1;i<=n;i++)//求联通块
	if(!indegree[i]){
		point[i].id=i;
		dfs(i);
	}
	sort(point+1,point+n+1,cmp2);//把每个联通块弄到一段连续的序列中
}
int main(){//主函数So easy!
	init();
	work();
	return 0;
}

```

---

## 作者：YanLei (赞：2)

~~看他们的题解，感觉自己的细节处理更加有优势~~

## 思路

1.首先容易想到这题是有依赖的背包，我们需要处理分组的问题。

2.那么怎么处理分组**最方便**？斜率处理？有实数不方便，这里我们使用**线性组合**的知识来处理：

- 假设给你个坐标为 $(x,y)$ 的点，我们怎么看是否有斜率和他一样的点是否存在呢？很简单，我们只要处理是否存在 $(\frac{x}{(x,y)},\frac{y}{(x,y)})$的组别即可。注意分母表示两个数的最大公因数。

- 我们处理所有的组别，最后按照**距离原点坐标排序**。由于距离一定是正数，我们只要按照**距离远点距离的平方排序**即可，排序结果表明前一个拿完才能拿后一个物品。

- 然后我们对他们的花费和价值进行**修改**，$\color{red}把有依赖的背包转换成分组背包$

## 核心代码

```c
/*
 _            __   __          _          _
| |           \ \ / /         | |        (_)
| |__  _   _   \ V /__ _ _ __ | |     ___ _
| '_ \| | | |   \ // _` | '_ \| |    / _ \ |
| |_) | |_| |   | | (_| | | | | |___|  __/ |
|_.__/ \__, |   \_/\__,_|_| |_\_____/\___|_|
        __/ |
       |___/
*/
int dp[40050];

struct node{
    int x,y;
    int w,v;
    int d;
    bool operator < (const node &ND)const{
        return d < ND.d;
    }
};
int cal(int x,int y){
    return x * x + y * y;
}
vector<node>BG[MAX];
int ct;
map<int,map<int,int> >M;
int main()
{
    int N,V;
    cin >> N >> V;
    for(int i = 1;i <= N;++i){
        int x,y,t,vv;cin >> x >> y >> t >> vv;
        int gcd = __gcd(x,y);
        int tx = x / gcd;
        int ty = y / gcd;
        if(!M[tx][ty])
            M[tx][ty] = ++ct;
        BG[M[tx][ty]].push_back({x,y,t,vv,cal(x,y)});
    }
    for(int i = 1;i <= ct;++i){
        sort(BG[i].begin(),BG[i].end());
        for(int j = 1;j < BG[i].size();++j){
            BG[i][j].w += BG[i][j-1].w;
            BG[i][j].v += BG[i][j-1].v;
        }
    for(int i = 1;i <= ct;++i){
        for(int k = V;k >= 0;--k){
            for(int j = 0;j < BG[i].size();++j){
                if(k - BG[i][j].w < 0)break;
                dp[k] = max(dp[k],dp[k-BG[i][j].w]+BG[i][j].v);
            }
        }
    }
    cout << dp[V];
    return 0;
}

```

---

## 作者：a2920353120 (赞：2)

~~模拟退火万岁~~
## 什么？这是个背包题？
### ~~背包题当然不用背包写呀~~

这道题被我拿来当模拟退火的练习题，在反复调试以后成功通过
想学模拟退火算法的小伙伴们可以拿这道题练手

具体思路

**贪心加暴力**

首先，我们的暴力思路是把**价值 / 时间**即 **单位时间价值大的放前面优先选择**

用map一个小模拟，因为他要求

一条直线上的点只有 __前面的点选过__ 才能选

所以我们用一个**第一维是double（精度足够)第二维是int的map**

#### 拿来存储  _这条直线上的_ **第一个点的x坐标(y也可以)**

让后在用一个 $map<double, bool>$ 存储这条直线上的第 $１$个点是否被选过

#### 这样暴力时 判断  若这是第一个点那么标记选过 如果不是那么 若第一个点被选过则选，没选过则不选

让后就是模拟退火随机更换两个点的位置并顺次选择

如果这个排列比原先的答案大  那么 保存

否则 如果 一个概率 我们允许这个地方不是最优解，而向最优解靠近

具体模拟退火的原理请参考

# [这位大佬的blog](https://blog.csdn.net/weixin_42398658/article/details/84031235)

以下是ac代码
（可以改火和每次降温跑得更快)


```cpp
#include<bits/stdc++.h>
#define rap(i, j, k) for(int i = j; i <= k; i++)
#define db double
#define ll long long
using namespace std;

const int N = 10000 + 10;
map<db, int> MAP;
struct node {
	double ck;
	int x, y;
	int v, w;
	friend bool operator < (const node &A, const node &B) {
		return A.w * B.v > A.v * B.w;
	}//单位时间获得价值大的优先 
}a[N];
ll ans, n, m;

ll DP() {
	map<db, bool> mp;//这条直线第一个点是否选过的map 
	ll lans = 0, lcnt = 0;
	rap(i, 1, n) {
		if(lcnt + a[i].v > m) continue;//如果不能选则跳过 
		if(!mp[a[i].ck]) 
		  if(MAP[a[i].ck] != a[i].x) continue;//如果不是第一个点且第一个点没选过，跳过 
		  else mp[a[i].ck] = true;
		lans += a[i].w;
		lcnt += a[i].v;
	}
	
	return lans;
}


#define T 190
#define eps 1e-7
#define Delta 0.975

void SA() {//快乐的模拟退火 
	db t = T;
	while(t > eps) {
		int x = 0, y = 0;
		while(x == y) x = rand() % n + 1, y = rand() % n + 1;
		swap(a[x], a[y]);
		int now = DP();
		int dE = ans - now;
		if(dE <= 0) ans = now;
		else if( exp(dE / t) > (db) rand() / (db) RAND_MAX) ;
		else swap(a[x], a[y]);
		t *= Delta;
	}
	return ;
}

#undef T
#undef eps
#undef Delta


#define In(x) scanf("%lld", &x)
#define Out(x) printf("%lld", x)
int main() {
	srand(time(NULL));//随机数初始化 
	In(n);In(m);
	rap(i, 1, n) {
		ll x, y;
		In(x);In(y);In(a[i].v);In(a[i].w);
		a[i].x = x;a[i].y = y;
		a[i].ck = db(y) / db(x);//存储这个点所在直线的斜率 
		//记录直线第一个点  
		if(!MAP[a[i].ck]) MAP[a[i].ck] = x;
		else MAP[a[i].ck] = min(MAP[a[i].ck], int(x));
	}
	//排序，单位时间获得价值大的优先 
	sort(a + 1, a + n + 1);
	rap(i, 1, 15) SA();
	Out(ans);
	return 0;
}
#undef In
#undef Out

```

## ~~再次高呼模拟退火万岁~~

---

## 作者：RainFestival (赞：2)

背包………………

枚举一定会超时

先存储几个方向

然后把每个方向的金子找出来

再选择情况

最后用有树形背包解决

注意x=0的特判（我不会用下面几位大佬的方法）

要看代码吗？？？

这是dp的
  for i:=1 to p do
    for j:=m downto 0 do
      for k:=1 to c[i] do
        if bb[j+b[i,k].w]<bb[j]+b[i,k].v then
          bb[j+b[i,k].w]:=bb[j]+b[i,k].v;


```pascal
type
  aaaaa=record
    x,y,v,w:longint;
  end;
  gold=record
    v,w,x,y:longint;
  end;
  arr=array[0..105] of gold;
var
  a,d:array[0..105] of aaaaa;
  c:array[0..10005] of longint;
  b:array[0..10005] of arr;
  i,j,n,m,p,k,kk:longint;
  f:boolean;
  bb:array[0..200005] of longint;
  t:gold;
begin
  readln(n,m);
  for i:=1 to n do
    readln(a[i].x,a[i].y,a[i].w,a[i].v);
  for i:=1 to n do
    begin
      f:=false;
      if a[i].x=0 then //判断x是否为零，不然会除零（蒟蒻不会用其他办法解决，求原谅）
        begin
          if kk=0 then
            begin
              inc(p);
              inc(c[p]);
              kk:=p;
              b[p,1].v:=a[i].v;
              b[p,1].w:=a[i].w;
              d[p].x:=-1;
              d[p].y:=1;
            end
                  else
            begin
              inc(c[kk]);
              b[p,c[kk]].v:=a[i].v;
              b[p,c[kk]].w:=a[i].w;
              d[p].x:=-1;
              d[p].y:=1;
            end;
          continue; 
        end;
      for j:=1 to p do
        if (a[i].y/d[j].y)=(a[i].x/d[j].x) then
          begin
            inc(c[j]);
            b[j,c[j]].v:=a[i].v;
            b[j,c[j]].w:=a[i].w;
            b[j,c[j]].x:=a[i].x;
            b[j,c[j]].y:=a[i].y;
            f:=true;
            break;
          end;
      if not f then
        begin
          inc(p);
          inc(c[p]);
          b[p,1].v:=a[i].v;
          b[p,1].w:=a[i].w;
          b[j,1].x:=a[i].x;
          b[j,1].y:=a[i].y;
          d[p].x:=a[i].x;
          d[p].y:=a[i].y;
        end;
    end;
  for i:=1 to p do
    for j:=1 to c[i] do
      for k:=j+1 to c[i] do
        if b[i,j].x>b[i,k].x then
          begin
            t:=b[i,j];
            b[i,j]:=b[i,k];
            b[i,k]:=t;
          end;
  for i:=1 to p do
    for j:=1 to c[i] do
      begin
        b[i,j].v:=b[i,j-1].v+b[i,j].v;
        b[i,j].w:=b[i,j-1].w+b[i,j].w;
      end;
  for i:=1 to p do
    for j:=m downto 0 do
      for k:=1 to c[i] do
        if bb[j+b[i,k].w]<bb[j]+b[i,k].v then
          bb[j+b[i,k].w]:=bb[j]+b[i,k].v;
  writeln(bb[m]);
end.


```

福利：树形背包4等级

Level 1：金明的预算方案 绿

level 2：黄金矿工 蓝

level 3：选课 蓝

level 4：软件安装 紫

[评测记录](https://www.luogu.org/recordnew/show/14908025)

---

## 作者：Zwaire (赞：1)

# P3961黄金矿工

## [Link](https://www.luogu.com.cn/problem/P3961)

## 题目描述：

给你一个笛卡尔坐标系，在上面分布着许多的点，每一个点有一个时间和价值，你需要在给定的时间内选取一些点，使得你取得的价值最大。但是在一条直线上的点必须按照一定的顺序挖，一个点被选之前保证在一条直线上它之前的点被选。



## 题目分析：

看到这个题，第一眼想到这是一个有依赖的背包问题。（有依赖的背包问题详见 [金明的预算方案](https://www.luogu.com.cn/problem/P1064)）

具体考虑我们接下来该怎么做，既然题目里面要求要按照一定的顺序选点，那么我们对于这条直线后面的点，他前面的点肯定会被选上，那么我们转换一下，其实就是相当于这个点可以“缩点”，**把这一条直线上的点重新赋值，重新规定它的时间和价值**，这样我们在把 **每一条直线看成一组**，对于每一组，我只能选择其中的一个点，然后分组背包求解就好了。

## 细节：

本人在实现这道题的时候花了很长时间，一直没有好的实现方法（~~因为我太菜~~），最后我对 STL 下手了。

$\bullet$ 对于每一条直线，我们可以用它的斜率表示，即 $\frac{y}{x}$ 来表示，但是，我们对于斜率并不是整数，所以我就用 map 把斜率映射成整数，问题就变得可解了。

$\bullet$ 其次对于相同的斜率，我用了一个 set 维护斜率的集合，查看是否出现过。

具体的标注在代码里（~~感觉自己写的好丑，勿喷~~）

```c++
int n, T, tot;
int tim[N], g[N], lsh[N], val[N][N], w[N][N], f[40010];
set<double> k;
map<double , int > m;

struct node
{
    int x, y, t, v;
}to[N][N];

bool cmp(node a, node b) {return a.x < b.x;}

int main()
{
    n = re(), T = re();
    for(int i = 1; i <= n; ++i)
    {
        int x = re(), y = re(), t = re(), v = re();      
        double kt = (double)y / (double)x; //kt表示直线的斜率
        if(k.find(kt) == k.end()) m[kt] = ++tot, k.insert(kt); //查看是否出现过，是否有新的斜率出现
        to[m[kt]][++tim[m[kt]]].x = x, to[m[kt]][tim[m[kt]]].y = y; //tim是用来记对应斜率的点数
        to[m[kt]][tim[m[kt]]].t = t, to[m[kt]][tim[m[kt]]].v = v; //to是用来记点的信息
        lsh[i] = m[kt]; //lsh类似于离散化，对于相同的斜率去重
    }
    sort(1 + lsh, lsh + 1 + n);
    int cnt = unique(lsh + 1, lsh + 1 + n) - lsh - 1; //离散化
    for(int i = 1; i <= cnt; ++i)
    {
        sort(1 + to[lsh[i]], to[lsh[i]] + 1 + tim[lsh[i]], cmp);
    } //对于每一个直线的内部排一下序，保证正确性
    
    for(int i = 1; i <= cnt; ++i)
    {
        for(int j = 1; j <= tim[lsh[i]]; ++j)
        {
            val[i][j] = val[i][j - 1] + to[lsh[i]][j].v; //重新分组，“缩点”的过程
            w[i][j] = w[i][j - 1] + to[lsh[i]][j].t;
        }
    }
    
    for(int i = 1; i <= cnt; ++i)
        for(int j = T; j >= 0; --j)
            for(int k = 1; k <= tim[lsh[i]]; ++k)
                if(j >= w[i][k])
                    f[j] = max(f[j], f[j - w[i][k]] + val[i][k]); //分组背包板子
    printf("%d\n", f[T]);
    getchar();
}
```

不得不说，STL 吸氧后是真的快，本人目前居最优解第二 (21.8.9)。



---

## 作者：zmxqs (赞：1)

## [My Blog](https://fangxizheng.blog.luogu.org/)

看到这道题，不难想到是有依赖的背包吧

正解：分组+DP

+ 可以根据每个点的$y / x $ 相同的值放在一组（就是斜率嘛）

+ 然后再把每一组的数据进行排序

+ 最后直接跑动归

+ 可以用前缀和来优化动归，速度更快

#### 有人担心用斜率会WA

这里$| x,y|$的大小严格$\leq 200$，所以误差会很小，所以是OK的啦

几个注意点

Tip1：sort

+ 排序可以使用稳定排序，好像更快

+ 有能力的巨佬可以手写堆排或者快排，STL快排是真的慢

Tip2：cmp函数

+ 注意$x,y=0$的情况，可能会RE

+ 需要注意的是做除法之前要强制转换成实数类型（不然变成整数就会WA）



```cpp

#include<bits/stdc++.h>
using namespace std;
long long n,m;
struct node{
	int x,y,t,v;
};
node a[1050];
map<double,int> Mp;
int qt[1050][1050],qc[1050][1050];
vector<node> g[1050];
int dp[100100];
bool cmp(node x,node y) {
	return abs(x.y)<abs(y.y);
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i) {
		scanf("%d%d%d%d",&a[i].x,&a[i].y,&a[i].t,&a[i].v);
	}
	int cnt=0;
	for(int i=1;i<=n;++i) {
		double t=a[i].y*1.0/a[i].x;
		if(Mp[t]==0) {
			cnt++;
			Mp[t]=cnt;
			g[cnt].push_back(a[i]);
		}
		else {
			g[Mp[t]].push_back(a[i]);
		}
	}
	for(int i=1;i<=cnt;++i) {
		stable_sort(g[i].begin(),g[i].end(),cmp);
		for(int j=0;j<g[i].size();++j) {
			qt[i][j]=qt[i][j-1]+g[i][j].t;
			qc[i][j]=qc[i][j-1]+g[i][j].v;
		}
	}
	for(int i=1;i<=cnt;++i) {
		for(int j=m;j>=1;--j) {
			for(int k=0;k<g[i].size();++k) {
				if(qt[i][k]<=j) {
					dp[j]=max(dp[j-qt[i][k]]+qc[i][k],dp[j]);
				}
			}
		}
	}
	printf("%d",dp[m]);
	return 0;
}

```

题解写的常数因子可能会很大（最菜题解，没有之一）

分组的话，能不用 map 就不用 map（STL容器速度一个比一个慢，优秀的时间复杂度往往遮盖了它大常数的缺点）

By SteveFang



---

## 作者：mydiplomacy (赞：1)

我的思路是：

首先，将所有$n$个金子分为若干组，使得在一个组内所有金子都在一条直线上。可以证明，分组方案一定存在，且不同组的选取互不影响。在组内，我们将所有金子按照$x$坐标排序，于是在一个组内，要选后面的金子必须选其前面的所有金子。

设共有$tot$个组，第$i$组的大小为$cnt[i]$。我们定义$g[i][j]$，其中$g$是一个结构体变量，里面包含$w$、$t$两个变量，代表对于第$i$组，选前$j$个金子，需要的时间$t$以及价值$w$。$g$可以递推求得：

$g[i][j].t=g[i][j-1].t+a[k].t,$

$g[i][j].w=g[i][j-1].w+w[k].w,$其中$k$是第$i$组第$j$个金子。

特别地，我们定义$g[i][0]$代表在第$i$组中不取任何金子。

有了$g$以后，我们就可以有一个整体的状态$d[i][j]$，代表取只能在$i$组中取、花时间为$j$，可以获得的最大价值。我们可以利用$g$来求$d$，状态转移方程是：

$d[i][j]=max${$d[i-1][j-g[i][k].t]+g[i][k].w$}，其中满足$k<=cnt[i]$。于是问题得解。

在代码实现中，只需要将$a$整体排一遍序即可，这是因为，如果一个金子在组内排在前面，它在整体排序时也一定在前面。另外，注意在$d$数组中$dp$时，需要注意只有在$j-g[i][k].t>=0$时才能转移。以及在$dp$时不要忘了考虑$g[i][0]$，因为可以整个不取一组。



---

## 作者：Celebrate (赞：1)

如果在同一条直线上要先选第一个，那不就可以连接成一条链，几条链连起来不就是树形dp吗

于是我果断开始打树形dp，其实这也没有问题

但是树形dp打到一半，发现根本就不需要树形dp，因为只有更节点才有多个子树

其他的最多只有一个孩子，于是我就把这些子树变成一条链

每一条链用一个一维数组来存，并记录一下这条链中到达第i个的时间花费和价值，再用dp一次解决吧

下面解释一下如何判断是否在一条直线上

我记得有一个关于直线的公式  y = k x + b

然而这里是从原点出发所以没有b 也就是  y = k x 

其中k是斜率，如果斜率相同就是在同一条直线上（都是整数点所以不考虑精度问题）

k = y / x ， 于是我们把每一个坐标的k取出来，并且排序一下，就可以很轻松的找出来啦

参考代码（可以加很多优化）

```cpp
// luogu-judger-enable-o2
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
 
using namespace std ;
 
const int N = 2e2 + 10 ;
 
struct node {
    int x , y , t , v ;
    double k ;
} a[N] ; int n , T ;
inline bool cmp ( node n1 , node n2 ) {
    if ( n1.k != n2.k ) return n1.k < n2.k ;
    return n1.y < n2.y ; 
}
 
int tot , g[N][N][2] ;
int dp[N*N] ; 
//g[][][0] 表示 时间
//g[][][1] 表示 价值 
int main() {
    cin >> n >> T ;
    for ( int i = 1 ; i <= n ; i ++ ) {
        cin >> a[i].x >> a[i].y >> a[i].t >> a[i].v ;
        a[i].k = double( a[i].y ) / a[i].x ;
    }
    sort ( a + 1 , a + n + 1 , cmp ) ;
    tot = 1 ; g[1][1][0] = a[1].t ; 
    g[1][1][1] = a[1].v ; g[1][0][0] = 1 ;
    for ( int i = 2 ; i <= n ; i ++ ) {
        if ( a[i].k != a[i-1].k ) {
            tot ++ ; g[tot][1][0] = a[i].t ;
            g[tot][1][1] = a[i].v ; g[tot][0][0] = 1 ;
            continue ;
        }
        int tt = ++ g[tot][0][0] ;
        g[tot][tt][0] = g[tot][tt-1][0] + a[i].t ;
        g[tot][tt][1] = g[tot][tt-1][1] + a[i].v ;
    }
    for ( int i = 1 ; i <= tot ; i ++ ) 
        for ( int j = T ; j >= 0 ; j -- ) 
            for ( int k = 1 ; k <= g[i][0][0] ; k ++ ) {
                if ( j >= g[i][k][0] ) dp[j] = max ( dp[j] , dp[j-g[i][k][0]] + g[i][k][1] ) ;
                else break ;
            }
    cout << dp[T] << endl ; return 0 ;
}

```

---

## 作者：疯疯芸 (赞：0)

细心读题后你会发现这是一道有依赖的背包问题

处在过原点(~~题中没有提到小A再原点~~)的同一条直线上的点必须先将近的挖走

我们可以用

**斜率**来判断这些点是否在一条直线上(笛卡尔坐标系求斜率),因为x,y为整数,因此不必考虑精度问题

判断了是否在同一直线,那又如何确定他们的依赖关系?

在草稿上画个图,你会发现,因为y>=0,处在过原点同一直线上的点,**y越小,越靠近小A**.由此我们可以定义排序的优先级,排序后处理依赖关系

此时问题就和[P2014 选课](https://www.luogu.org/problemnew/show/P2014)~~十分~~类似,不过容量由课的门数转为时间

欣喜不已的我赶紧建了棵树,泛化背包,完全无视T<=4e4,自信交一波......30分,剩下7个点全TLE

~~30分的代码也敢贴出来丢人现眼,脸皮真*~~
```cpp
#include<cstdio>//30分
#include<algorithm>
#include<cstring>
using namespace std;
const int maxt=4e4+10,maxn=210;
struct ffy
{
    double x,y,z;
    int t,p;
    bool operator<(const ffy &a)
    const
    {
        if(z<a.z) return true;
        if(z>a.z) return false;
        if(y<a.y) return true;
        return false;
    }
}e[maxn];
struct fy{int from,to,next;}q[maxn*maxn];
int n,T,head[maxn],num,he,hh;
int f[maxn][maxt];
void add(int a,int b){q[++num]=(fy){a,b,head[a]};head[a]=num;}
void dfs(int a,int b)
{
    for(int i=he+1;i<=he+e[a].t;i++)
    {
        if(i>T) return;
        f[b][i]=hh;
    }
    hh+=e[a].p;he+=e[a].t;
    if(head[a])
    dfs(q[head[a]].to,b);
}
int main()
{
    scanf("%d%d",&n,&T);
    for(int i=1;i<=n;i++)
    {
        scanf("%lf%lf%d%d",&e[i].x,&e[i].y,&e[i].t,&e[i].p);
        e[i].z=e[i].y/e[i].x;
    }
    sort(e+1,e+n+1);int bb=-1;
    for(int i=1;i<=n;i++)
    {
        if(bb!=e[i].z)
        {
            add(0,i);
            bb=e[i].y;
        }
        else add(i-1,i);
    }
    for(int i=head[0];i;i=q[i].next)
    {
        int b=q[i].to;he=0,hh=0;
        dfs(b,b);
        if(he<T) for(int j=he;j<=T;j++)f[b][j]=hh;
        for(int j=T;j>=0;j--)for(int k=0;k<=j;k++)//T方,时间复杂度炸掉
        f[0][j]=max(f[0][j],f[0][j-k]+f[b][k]);
    }
    printf("%d\n",f[0][T]);
    return 0;
}
```

orz 开始优化时间

再仔细观察数据你会发现我们可以将每条直线上的点分成一个组,每组取任意个点的时间和利益是确定的,并且每组只能取一次,这样,问题又变成了一个分组背包([P1757 通天之分组背包](https://www.luogu.org/problemnew/show/P1757))

AC代码(其实可以优化的地方很多,~~但我太懒了~~)

```cpp
#include<cstdio>//AC
#include<algorithm>
#include<cstring>
using namespace std;
const int maxt=4e4+10,maxn=210;
struct ffy
{
	double x,y,z;
	int t,p;
	bool operator<(const ffy &a)//重载运算符
	const
	{
		if(z<a.z) return true;
		if(z>a.z) return false;
		if(y<a.y) return true;
		return false;
	}
}e[maxn];
struct fy{int from,to,next;}q[maxn*maxn];
int n,T,head[maxn],num,he,hh,son[maxn];
int f[maxn][maxn],g[maxn][maxn],ff[maxt];
//f[i][j]表示组i中选j件的利益
//g[i][j]表示组i中选j件的时间
//ff[i]表示i时间的最大利益
void add(int a,int b){q[++num]=(fy){a,b,head[a]};head[a]=num;}
void dfs(int a,int b,int c)//处理每组的时间和利益
{
	hh+=e[a].p;he+=e[a].t;
	f[b][c]=hh;
	g[b][c]=he;
	if(head[a]) dfs(q[head[a]].to,b,c+1);
	return;
}
int main()
{
	scanf("%d%d",&n,&T);
	for(int i=1;i<=n;i++)
	{
		scanf("%lf%lf%d%d",&e[i].x,&e[i].y,&e[i].t,&e[i].p);
		e[i].z=e[i].y/e[i].x;
	}
	sort(e+1,e+n+1);int bb=-1,w=0;
	for(int i=1;i<=n;i++)
	{
		if(bb!=e[i].z){w=i;add(0,i);bb=e[i].y;son[w]=1;}
		else{add(i-1,i);son[w]++;}
        //完全没必要加边,dfs干的事可以直接在这里干完,还能省下一些空间
        //主要是懒,不想改
	}
	for(int i=head[0];i;i=q[i].next)
	{
		int b=q[i].to;he=0,hh=0;dfs(b,b,1);
		for(int j=T;j>=0;j--)for(int k=0;k<=son[b];k++)
		if(j>=g[b][k])ff[j]=max(ff[j],ff[j-g[b][k]]+f[b][k]);
		else break;
	}
	printf("%d\n",ff[T]);
	return 0;
}
```

代码丑的可怕,**dalao**勿喷

~~话说我这么懒,为何要写这么多?~~

---


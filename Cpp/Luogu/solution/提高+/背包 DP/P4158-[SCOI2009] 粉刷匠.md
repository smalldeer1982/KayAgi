# [SCOI2009] 粉刷匠

## 题目描述

windy 有 $N$ 条木板需要被粉刷。 每条木板被分为 $M$ 个格子。 每个格子要被刷成红色或蓝色。

windy 每次粉刷，只能选择一条木板上一段连续的格子，然后涂上一种颜色。 每个格子最多只能被粉刷一次。

如果 windy 只能粉刷 $T$ 次，他最多能正确粉刷多少格子？

一个格子如果未被粉刷或者被粉刷错颜色，就算错误粉刷。



## 说明/提示

$30\%$ 的数据，满足 $1 \le N,M \le 10,0 \le T \le 100$ 。

$100\%$ 的数据，满足 $1 \le N,M \le 50,0 \le T \le 2500$ 

## 样例 #1

### 输入

```
3 6 3
111111
000000
001100```

### 输出

```
16```

# 题解

## 作者：7wwwwth (赞：146)

明显是一个dp

 

定义一个 f[i][j]的数组来表示前i条木板粉刷j次的情况下能正确粉刷的最大格子数

定义一个g[i][j][k]来表示第i条木板上粉刷j次涂了前k个格子的情况下能正确粉刷的最大格子数

用sum数组来记录蓝色格子数 某个区间的格子数减去蓝色格子数就是粉色格子数（用前缀和来记录）

要是求最大的格子数 那么就要求一个m使得 
```cpp
  f[i][j]=max(f[i][j],f[i-1][j-k]+g[i][k][m])
```

用一个区间来想

接下来就是求g[i][j][k]态转移方程了还是很好想的

前q个格子粉刷正确加上下一步粉刷正确的粉色格子多还是蓝色格子多

有
```cpp
g[i][j][k]=max(g[i][j][k],g[i][j-1][q]+max(sum[i][k]-sum[i][q],k-q-sum[i][k]+sum[i][q]));
```

其中sum[i][k]-sum[i][q]蓝色格子

k-q-sum[i][k]+sum[i][q]该段的粉色格子

最后看看粉刷多少次时有最大的f[i][j]记作ans；

愉快地输出吧！
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
int f[51][2550],sum[51][2550];
int g[51][2550][51];
int n,m,t;
char s[150];

int main(){
	cin>>n>>m>>t;
	for(int i=1;i<=n;i++){
		cin>>s;
		sum[i][0]=0;
		for(int j=1;j<=m;j++){
			if(s[j-1]=='1') sum[i][j]=sum[i][j-1]+1;
			else sum[i][j]=sum[i][j-1];
		}
	}
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	for(int k=1;k<=m;k++)
	for(int q=j-1;q<k;q++){
		g[i][j][k]=max(g[i][j][k],g[i][j-1][q]+max(sum[i][k]-sum[i][q],k-q-sum[i][k]+sum[i][q]));
	}
	for(int i=1;i<=n;i++)
	for(int j=1;j<=t;j++)
	for(int k=0;k<=min(j,m);k++){
	f[i][j]=max(f[i][j],f[i-1][j-k]+g[i][k][m]); }
	int ans=0;
	for(int i=1;i<=t;i++) ans=max(ans,f[n][i]);
	cout<<ans;
	
}
```

---

## 作者：Monster_Qi (赞：25)

本蒟蒻不会什么太高深的做法，就猛写了一发毒瘤dp，莫名其妙过了

dp[i][j][k][0/1/2]表示第i行第j列一共粉刷了k次，0/1/2分别表示当前格子没有涂色/涂了错的颜色/涂了对的颜色， 然后我们考虑逐格转移：

当j=1也就是出于每行的第一个位置时，我们要考虑上一行的最后一个位置， 即

	dp[i][j][k][0]=max(dp[i-1][m][k][1],max(dp[i-1][m][k][2],dp[i-1][m][k][0]));

	dp[i][j][k][1]=max(dp[i-1][m][k-1][2],max(dp[i-1][m][k-1][1],dp[i-1][m][k-1][0]));

	dp[i][j][k][2]=max(dp[i-1][m][k-1][2],max(dp[i-1][m][k-1][1],dp[i-1][m][k-1][0]))+1;
其余位置要考虑这个格子颜色是否和前一个格子的颜色相等，如果相等，就有

	dp[i][j][k][2]=dp[i][j-1][k][2]+1;
可以直接接上

	dp[i][j][k][1]=max(dp[i][j-1][k][1],dp[i][j-1][k-1][0]);
前面涂错或不涂

 	dp[i][j][k][0]=max(dp[i][j-1][k][0],dp[i][j-1][k][1]);
 前面涂错或不涂
如果不相等,

    dp[i][j][k][2]=max(dp[i][j-1][k-1][2],max(dp[i][j-1][k][1],dp[i][j-1][k-1][0]))+1;
    前面可能有三种情况

    dp[i][j][k][1]=max(dp[i][j-1][k][2],dp[i][j-1][k-1][0]);
    涂对或不涂       

    dp[i][j][k][0]=max(dp[i][j-1][k][0],dp[i][j-1][k][2]);
    涂对或不涂
可以用滚动数组压掉第一维，这样空间复杂度是O(nT),时间复杂度是O(nmT)，还是可以过的


### 代码

```
#include<bits/stdc++.h>

using namespace std;
const int MAXN = 55;

int n,m,t,dp[3][MAXN][2505][3]; 
bool col[MAXN][MAXN];

int main(){
    scanf("%d%d%d",&n,&m,&t);
    for(register int i=1;i<=n;i++){
        char c[MAXN];
        scanf("%s",c+1);
        for(register int j=1;j<=m;j++)
            col[i][j]=c[j]-'0';
    }
    for(register int i=1;i<=n;i++)
    for(register int j=1;j<=m;j++)
    for(register int k=1;k<=t;k++){
        if(j==1){
            dp[i&1][j][k][0]=max(dp[(i-1)&1][m][k][1],dp[(i-1)&1][m][k][0]);
            dp[i&1][j][k][0]=max(dp[i&1][j][k][0],dp[(i-1)&1][m][k][2]);
            dp[i&1][j][k][1]=max(dp[(i-1)&1][m][k-1][1],dp[(i-1)&1][m][k-1][0]);
            dp[i&1][j][k][1]=max(dp[i&1][j][k][1],dp[(i-1)&1][m][k-1][2]);
            dp[i&1][j][k][2]=max(dp[(i-1)&1][m][k-1][1],dp[(i-1)&1][m][k-1][0])+1;
            dp[i&1][j][k][2]=max(dp[i&1][j][k][2],dp[(i-1)&1][m][k-1][2]+1);
        } 
        else{
            if(col[i][j]==col[i][j-1]){
                dp[i&1][j][k][2]=dp[i&1][j-1][k][2]+1;
                dp[i&1][j][k][1]=max(dp[i&1][j-1][k][1],dp[i&1][j-1][k-1][0]);
                dp[i&1][j][k][0]=max(dp[i&1][j-1][k][0],dp[i&1][j-1][k][1]);
            }
            else{
                dp[i&1][j][k][2]=max(dp[i&1][j-1][k][1],dp[i&1][j-1][k-1][0])+1;
                dp[i&1][j][k][2]=max(dp[i&1][j-1][k-1][2]+1,dp[i&1][j][k][2]);
                dp[i&1][j][k][1]=max(dp[i&1][j-1][k][2],dp[i&1][j-1][k-1][0]);
                dp[i&1][j][k][0]=max(dp[i&1][j-1][k][0],dp[i&1][j-1][k][2]);
            }   
        }       
//      cout<<dp[i][j][k][0]<<" "<<dp[i][j][k][1]<<" ";
//      cout<<dp[i][j][k][2]<<endl;
    }
    printf("%d",max(max(dp[n&1][m][t][0],dp[n&1][m][t][1]),dp[n&1][m][t][2]));
    return 0;
}
```

最后安利一波本蒟蒻的博客：(https://blog.csdn.net/qq_40448823)

---

## 作者：白色星期一 (赞：15)

### 这是一篇比较水的蓝名题解，写出~~假紫题~~有点高兴
我的总体思路就是两遍DP，第一个是在每一条木板上进行动归，第二个是在木条间进行动归。

#### 第一遍——在一个木条上的动归

数组dp[i][j][k]来储存在每一行中第i个格子在粉刷j次时的最优情况，k表示粉刷j次时用的颜色。对于每一个格子我们有三种决策。
1. 直接从前一个格子刷过来，则有转移方程：
```cpp
dp[i][j][color[i]]=dp[i-1][j][color[i]]+1;
dp[i][j][!color[i]]=dp[i-1][j][!color[i]];
```
2. 从此格开始涂新的一段，颜色与此格相同，则有转移方程：
```cpp
dp[i][j][color[i]]=max(dp[i][j][color[i]],max(dp[i-1][j-1][0],dp[i-1][j-1][1])+1);
```
3. 从此格开始涂新的一段，颜色与此格不同，则有转移方程：
```cpp
dp[i][j][!color[i]]=max(dp[i][j][!color[i]],max(dp[i-1][j-1][0],dp[i-1][j-1][1]));
```

这样以来，每一行动归完成后，数组dp[lenth][p][0]或dp[lenth][p][1]中便保存了这一条木板粉刷p段的最优解。

#### 第二遍——在木条间的动归

这个比较简单了，直接贴转移方程：
```cpp
ans[i]=max(ans[i],ans[i-j]+max(dp[lenth][j][0],dp[lenth][j][1]));
```
注意这里i要倒叙循环，j在0至min(lenth,i)间循环。

**最后ans[all]便保存了全局最优解，输出即AC！！**

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 51
#define M 2510
using namespace std;
int num,lenth,all,color[N],dp[N][N][2],ans[M];
int main()
{
	scanf("%d%d%d",&num,&lenth,&all);
	for(register int n=1;n<=num;n++)
	{
		for(register int i=1;i<=lenth;i++)
			scanf("%1d",&color[i]);
		memset(dp,0,sizeof(dp));
		for(register int i=1;i<=lenth;i++)
			for(register int j=1;j<=i;j++)
			{
				dp[i][j][color[i]]=dp[i-1][j][color[i]]+1;
				dp[i][j][!color[i]]=dp[i-1][j][!color[i]];
				int tmax=max(dp[i-1][j-1][0],dp[i-1][j-1][1]);
				dp[i][j][color[i]]=max(dp[i][j][color[i]],tmax+1);
				dp[i][j][!color[i]]=max(dp[i][j][!color[i]],tmax);
			}
		for(register int i=all;i>=1;i--)
			for(register int j=0;j<=min(lenth,i);j++)
				ans[i]=max(ans[i],ans[i-j]+max(dp[lenth][j][0],dp[lenth][j][1]));
	}
	printf("%d",ans[all]);
	return 0;
}

```

---

## 作者：kal0rona (赞：13)

这道题就是一个比较显然的背包 DP。我的做法是这样的：

- 处理出每个木板的块（连续的串）
- 处理出每一个木板染色的背包，也就是设置$dp[id][i][j][0/1]$为第$id$块木板到第$i$块染了$j$次色、第$i$个是否染色的最大正确染色数。
- 最后合并这些染色数，用一个$\Theta(n^3)$的合并方法即可。

木板染色的背包方程式比较显然，见processIt(int)函数理解一下就行了。

```cpp
// P4158.cpp
#include <bits/stdc++.h>
#define pr pair<int, int>

using namespace std;

const int MAX_N = 2550;

int n, m, T, dp[55][55][55][2], dp2[MAX_N];
vector<pr> blocks[110];
char opt[55][55];

void processIt(int id)
{
    for (int i = 1, siz = blocks[id].size(); i <= siz; i++)
        for (int j = siz; j >= 1; j--)
        {
            dp[id][i][j][0] = max(dp[id][i - 1][j][0], dp[id][i - 1][j][1]);
            dp[id][i][j][1] = max(dp[id][i - 1][j - 1][0], dp[id][i - 1][j - 1][1]) + blocks[id][i - 1].second - blocks[id][i - 1].first + 1;
            if (i >= 2)
                dp[id][i][j][1] = max(dp[id][i][j][1], dp[id][i - 2][j][1] + blocks[id][i - 1].second - blocks[id][i - 1].first + 1);
        }
}

int main()
{
    scanf("%d%d%d", &n, &m, &T);
    for (int i = 1; i <= n; i++)
        scanf("%s", opt[i] + 1);
    for (int i = 1; i <= n; i++)
        // preprocess;
        for (int j = 1, last = 1; j <= m + 1; j++)
            if (opt[i][j] == opt[i][last])
                continue;
            else
                blocks[i].push_back(make_pair(last, j - 1)), last = j;
    for (int i = 1; i <= n; i++)
        processIt(i);
    for (int i = 1; i <= n; i++)
        for (int pack = T; pack >= 0; pack--)
            for (int subpack = 0, siz = blocks[i].size(); subpack <= min(pack, siz); subpack++)
                dp2[pack] = max(dp2[pack], dp2[pack - subpack] + max(dp[i][siz][subpack][0], dp[i][siz][subpack][1]));
    printf("%d", dp2[T]);
    return 0;
}
```


---

## 作者：elijahqi (赞：9)

http://www.elijahqi.win/2018/01/14/bzoj1296-scoi2009%e7%b2%89%e5%88%b7%e5%8c%a0/

http://blog.csdn.net/elijahqi/article/details/79055898

Description


windy有 N 条木板需要被粉刷。 每条木板被分为 M 个格子。 每个格子要被刷成红色或蓝色。 windy每次粉刷，只能选择一条木板上一段连续的格子，然后涂上一种颜色。 每个格子最多只能被粉刷一次。 如果windy只能粉刷 T 次，他最多能正确粉刷多少格子？ 一个格子如果未被粉刷或者被粉刷错颜色，就算错误粉刷。

Input

输入文件paint.in第一行包含三个整数，N M T。 接下来有N行，每行一个长度为M的字符串，'0'表示红色，'1'表示蓝色。

Output

输出文件paint.out包含一个整数，最多能正确粉刷的格子数。

Sample Input

3 6 3
111111
000000
001100
Sample Output

16
HINT

30%的数据，满足 1 <= N,M <= 10 ； 0 <= T <= 100 。 100%的数据，满足 1 <= N,M <= 50 ； 0 <= T <= 2500 。


dp套dp  首先用dp处理每行我涂多少次可以可以涂对的数量 设f[i][j]表示前i个涂j次涂对的最多数量是多少那么在做的时候 可以这样来看 每次枚举中间做到哪里了f[i][j]=max(f[i][j],f[z][j-1]+黑色or白色的数量) 然后n^3进行dp 处理完这个可以看作是一个分组背包 就是行与行之间任选 但是行内只可以选一个  那就设dp[i][j]表示前i个刷j次的最大收益 那么每次针对这个i去枚举我在第i次这里刷了多少次 然后求max即可 注意下枚举的边界

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 55
using namespace std;
int f[N][N],dp[N][N*N],n,m,t,s[N];char s1[N];
int main(){
    freopen("bzoj1296.in","r",stdin);
    scanf("%d%d%d",&n,&m,&t);
    for (int i=1;i<=n;++i){
        scanf("%s",s1+1);memset(f,0,sizeof(f));
        for (int j=1;j<=m;++j) s[j]=s[j-1]+(s1[j]=='1');
        for (int j=1;j<=m;++j){
            for (int k=1;k<=m;++k){
                for (int z=0;z<j;++z){
                    int dis=s[j]-s[z];
                    f[j][k]=max(f[j][k],f[z][k-1]+max(dis,j-dis-z));
                }
            }
        }
        for (int j=1;j<=t;++j){
            int top=min(j,m);
            for (int k=1;k<=top;++k){
                dp[i][j]=max(dp[i][j],dp[i-1][j-k]+f[m][k]);
            }
        }
    }int ans=0;
    for (int i=1;i<=t;++i) ans=max(ans,dp[n][i]);printf("%d\n",ans);
    return 0;
}



```

---

## 作者：crashed (赞：7)

# 题目
&emsp;&emsp;[点这里](https://www.luogu.com.cn/problem/P4158)看题目。  
# 分析
&emsp;&emsp;首先可以考虑一个比较粗糙的大 DP ：  
&emsp;&emsp;$f(i,j)$：前$i$行，刷$j$次，最多能刷的正确格子数。  
&emsp;&emsp;转移是一个背包：  
$$f(i,j)=\max_{1\le k\le m}\{f(i-1,j-k)+con(i,k)\}$$  
&emsp;&emsp;其中$con(i,k)$表示第$i$行刷$k$次最多能刷的正确格子数。  
&emsp;&emsp;我们发现，由于$con$是按行独立的，因此对于每行我们可以再做一次 DP 处理出$con$。  
&emsp;&emsp;对于第$i$行，我们有如下的 DP ：  
&emsp;&emsp;$g(j,k)$：前$j$个格子刷$k$次最多能刷的正确格子数。  
&emsp;&emsp;设$mx(j,k)$为第$i$行刷一次区间$[j,k]$最多能刷的正确格子数，也就是区间内数量最多的颜色的数量。  
&emsp;&emsp;转移显然：   
$$g(j,k)=\max_{0\le l< j}\{g(l,k-1)+mx(l+1,j)\}$$  
&emsp;&emsp;内层 DP 一次$O(m^3)$，做$n$次就是$O(nm^3)$；外层 DP $O(nmT)$。总时间$O(nm^3+nmT)$。  
# 代码
```cpp
#include <cstdio>

const int INF = 0x3f3f3f3f;
const int MAXN = 55, MAXM = 55, MAXT = 2505;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b;
}

int g[MAXM][MAXM], f[MAXT];
int col[MAXN][MAXM];
int N, M, T;

int main()
{
	read( N ), read( M ), read( T );
	for( int i = 1 ; i <= N ; i ++ )
		for( int j = 1 ; j <= M ; j ++ )
			scanf( "%1d", &col[i][j] );
	for( int i = 1 ; i <= T ; i ++ ) f[i] = -INF;
	for( int i = 1 ; i <= M ; i ++ ) g[0][i] = -INF;
	for( int i = 1 ; i <= N ; i ++ )
	{
		for( int j = 1 ; j <= M ; j ++ )
			for( int k = 1 ; k <= j ; k ++ )
			{
				g[j][k] = -INF; int cnt[2] = {};
				for( int l = j - 1 ; ~ l ; l -- )
					cnt[col[i][l + 1]] ++, g[j][k] = MAX( g[j][k], g[l][k - 1] + MAX( cnt[0], cnt[1] ) );
			}
		for( int j = T ; j ; j -- )
			for( int k = 1 ; k <= M && k <= j ; k ++ )
				f[j] = MAX( f[j], f[j - k] + g[M][k] );
	}
	write( f[T] ), putchar( '\n' );
	return 0;
}
```

---

## 作者：生而为人 (赞：7)

题目描述
windy有 N 条木板需要被粉刷。 每条木板被分为 M 个格子。 每个格子要被刷成红色或蓝色。

windy每次粉刷，只能选择一条木板上一段连续的格子，然后涂上一种颜色。 每个格子最多只能被粉刷一次。

如果windy只能粉刷 T 次，他最多能正确粉刷多少格子？

一个格子如果未被粉刷或者被粉刷错颜色，就算错误粉刷。

输入格式
第一行包含三个整数，N M T。

接下来有N行，每行一个长度为M的字符串，'0'表示红色，'1'表示蓝色。

输出格式
包含一个整数，最多能正确粉刷的格子数。

我们可以先对每条木板进行一次DP，
DP[K][i][j] 表示 在第K个木板上 从1决策到第i个用了j次粉刷的最大次数
之后 转移时枚举中间断点，为h，则原式=max（dp[k][h][j-1]+(该区间的红色和蓝色取max)）；
之后一个分组背包 K为组数，j为代价，存的值为val进行转移。
代码：
```c
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,t,ans=-1e8;
int qian[55][55][2];
int f[55][55][55];
int g[55][2505];
int main()
{
	cin>>n>>m>>t;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
		qian[i][j][1]=qian[i][j-1][1];
		qian[i][j][0]=qian[i][j-1][0];
		char y;
		cin>>y;
		int x=0;
		if(y=='1')
		x=1;
		else
		x=0;
		qian[i][j][x]+=1;
	}
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	for(int k=1;k<=m;k++)
	for(int h=0;h<j;h++)
	f[i][j][k]=max(f[i][j][k],f[i][h][k-1]+max((qian[i][j][0]-qian[i][h][0]),(qian[i][j][1]-qian[i][h][1])));
	for(int i=1;i<=n;i++)
	for(int j=t;j>=0;j--)
	for(int k=1;k<=min(j,m);k++)
	g[i][j]=max(g[i][j],g[i-1][j-k]+f[i][m][k]);
	cout<<g[n][t];
}
```


---

## 作者：一中益达 (赞：6)

# 记忆化搜索+背包+贪心
##### ~~竟然没人写？~~
## 核心思想  ~~~~乱搞~~~~
搜索都会写，但主要是怎么剪枝。

我们发现行与行之间并没有什么关系。

考虑对每行进行搜索，搜出在这行粉刷次数为j的最大正确数

我们先来看这么一个序列:

00100100

第一个剪枝是最容易想到的也是最有效的

这个序列中，枚举搜索起始点不会从第2、5、8开始（小贪心）

也就是说--如果一段序列都是0或都是1，只有第一个点有用。

所以我们用一个useless数组表示这个数是否值得一搜。

第二个剪枝也是贪心。

还是刚才那个序列：

00100100

假设我们从第一个点开刷

枚举粉刷终点，显然不会是1，4，6（因为后面还有0）

所以我们再用一个数组nxt[ ][ ][ ]表示 一个点的可能粉刷终点。

判定条件——在一行中，这个点是i，对（i，m+1）进行枚举（设为j）。

如果这个点不‘useless’并且j和i对应的数值不同 就把它加上。

剩下的也都一样了  背包

```cpp
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<cstring>
using namespace std;
int n,m,k;
int a[61][61];
bool useless[61][61];
int nxt[61][61][61];
int top[61][61];
int dp[61][61][61];

int dpx[61][2601];
int sum[61][61];
void dfs(int row,int now,int tim,int nowans)
{
	if(dp[row][now][tim]>=nowans) return;
	dp[row][now][tim]=nowans;
	for(int i=1;i<=top[row][now];i++)
	{
		int sumx=sum[row][nxt[row][now][i]-1]-sum[row][now-1];
		if(!a[row][now]) sumx=nxt[row][now][i]-now-sumx;
		dfs(row,nxt[row][now][i],tim+1,nowans+sumx);
	}
}
int ans;
int main()
{
	memset(dp,-1,sizeof(dp));
	scanf("%d %d %d",&n,&m,&k);
	for(int i=1;i<=n;i++)
	{
		a[i][0]=-1;
		a[i][m+1]=-1;
	}
	getchar();
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			char ch=getchar();
			a[i][j]=ch-48;
			if(a[i][j]==a[i][j-1]) useless[i][j]=true;
			sum[i][j]=sum[i][j-1]+a[i][j];
		}
		if(i!=n) getchar();
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(useless[i][j]) continue;
			for(int h=j+1;h<=m+1;h++)
			{
				if(useless[i][h]) continue;
				if(a[i][j]!=a[i][h])
				{
					nxt[i][j][++top[i][j]]=h;
				}
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(useless[i][j]) continue;
			dfs(i,j,0,0);
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int T=m*i;T>=0;T--)
		{
			for(int j=0;j<=min(T,m);j++)
			{
				dpx[i][T]=max(dpx[i][T],dpx[i-1][T-j]+dp[i][m+1][j]);
			}
		}
	}
	for(int i=0;i<=k;i++)
	{
		ans=max(ans,dpx[n][i]);
	}
	printf("%d",ans);
	return 0;
}
```
~~数据水，竟然只跑了136ms~~

https://www.luogu.com.cn/record/28349084



---

## 作者：ミク (赞：6)

这道题明明可以很短的代码AC的，但是我为了缩短时间用了一个毒瘤方法，于是就走上了WaWaWa的道路。

我们可以先正确粉刷所有格子，记需要粉刷now次，之后再来取消粉刷某些格子。取消粉刷中间的一段格子，就是将这段格子左边一段格子的左端点和这段格子的右端点作为一次粉刷，这样now应该减2，也就是说省去了两次粉刷。而取消粉刷边上的一段格子，now只该减1，所以说应该把两个「边上的一段〈取消粉刷后代价最小的格子〉」拿来和一个「中间的一段〈取消粉刷后代价最小的格子〉」比较，哪边代价更小就取消粉刷哪边。而如果now<T了就应该停止取消粉刷输出结果了。

不得不吐槽这道题的数据太水。。。提交第一遍80分，发现无数错误、改了无数次才AC。结果AC之后还发现一个错误。如果还存在错误请指出。
~~大佬请无视蒟蒻代码的丑像~~
```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,t,now,ans;
char a[55][55];
struct sd{int x,y,v;bool flag;}w[55][505];
int cnt[55];
int main()
{
    scanf("%d%d%d",&n,&m,&t);ans=n*m;
    for(int i=1;i<=n;++i) {scanf("%s",a[i]);for(int j=m;j>=1;--j) a[i][j]=a[i][j-1];}
    if(t<=n) {
        int cc[55];
        memset(cc,0,sizeof(cc));
        for(int i=1;i<=n;++i)
        {
            int a1=0;
            for(int j=1;j<=m;++j) if(a[i][j]=='1') a1++;
            cc[i]=a1>m-a1?a1:m-a1;
        }
        sort(cc+1,cc+1+n);ans=0;
        for(int i=n;i>=n-t+1;--i)
        ans+=cc[i];printf("%d",ans);return 0;
    }
    for(int i=1;i<=n;++i)
    {
        a[i][0]='3';a[i][m+1]='4';int k=2;
        for(int j=1;j<=m+1;++j)
        {
            if(a[i][j]!=a[i][j-1])
			{
				if(k<=j-1) {w[i][++cnt[i]].x=k;w[i][cnt[i]].y=j-1;w[i][cnt[i]].v=j-k;}
				k=j;continue;
			}
        }
    }
    for(int i=1;i<=n;++i) now+=cnt[i];
    while(now>t)
    {
        int aa=0x7fffffff/2,X,Y;
        for(int i=1;i<=n;++i)
        {
            int kn=m+1;
            for(int j=1;j<=cnt[i];++j) if(!w[i][j].flag){kn=j;break;}
			if(kn==m+1) goto abC;
            if(w[i][kn].v-(w[i][kn].y-w[i][kn].x+1-w[i][kn].v)<aa&&
			(!w[i][kn].flag)&&w[i][kn].y!=m)
			{aa=w[i][kn].v-(w[i][kn].y-w[i][kn].x+1-w[i][kn].v);X=i;Y=kn;}
            abC:;
            kn=0;
			for(int j=cnt[i];j>=1;--j) if(!w[i][j].flag) {kn=j;break;}
			if(!kn) continue;
            if(w[i][kn].v-(w[i][kn].y-w[i][kn].x+1-w[i][kn].v)<aa&&
			(!w[i][kn].flag)&&w[i][kn].x!=1)
			{aa=w[i][kn].v-(w[i][kn].y-w[i][kn].x+1-w[i][kn].v);X=i;Y=kn;}
        }
        int ab=0x7fffffff/2,Xx,Yy;
        for(int i=1;i<=n;++i)
        {
            int kn=m+1;
            for(int j=1;j<=cnt[i];++j) if(!w[i][j].flag) {kn=j;break;}
			if(kn==m+1) goto KM;
            if((!(X==i&&w[X][Y].x==w[i][kn].y+1))&&(X!=i||Y!=1)&&
			ab>w[i][kn].v-(w[i][kn].y-w[i][kn].x+1-w[i][kn].v)&&
			(!w[i][kn].flag)&&w[i][kn].y!=m)
			{ab=w[i][kn].v-(w[i][kn].y-w[i][kn].x+1-w[i][kn].v);Xx=i;Yy=kn;}
            KM:;
			kn=0;
			for(int j=cnt[i];j>=1;--j) if(!w[i][j].flag){kn=j;break;}
			if(!kn) continue;
            if((!(X==i&&w[X][Y].y==w[i][kn].x-1))&&(X!=i||Y!=kn)&&
			ab>w[i][kn].v-(w[i][kn].y-w[i][kn].x+1-w[i][kn].v)&&
			(!w[i][kn].flag)&&w[i][kn].x!=1)
			{ab=w[i][kn].v-(w[i][kn].y-w[i][kn].x+1-w[i][kn].v);Xx=i;Yy=kn;}
        }
        int ac=0x7fffffff,XX,YY;
        for(int i=1;i<=n;++i)
        {
            int ll,rr;
            for(int j=1;j<cnt[i];++j) if(!w[i][j].flag) {ll=j;break;}
            for(int j=cnt[i];j>=1;--j) if(!w[i][j].flag) {rr=j;break;}
            for(int j=ll+1;j<=rr-1;++j) {
                if(w[i][j].flag) continue;
                if(ac>w[i][j].v-(w[i][j].y-w[i][j].x+1-w[i][j].v))
				{ac=w[i][j].v-(w[i][j].y-w[i][j].x+1-w[i][j].v);XX=i;YY=j;}
            }
        }
        if(now-t==1)
        {
            --now;
            if(aa<ac)
            {
                if(Y!=1)
                {
                    for(int i=Y-1;i>=1;--i) if(!w[X][i].flag)
					{w[X][i].flag=true;w[X][Y].v=w[X][Y].y-w[X][Y].x+1-w[X][Y].v+w[X][i].v;
					w[X][Y].x=w[X][i].x;break;}
                    ans-=aa;
                }
                else{
                    for(int i=2;i<=cnt[X];++i) if(!w[X][i].flag)
					{w[X][i].flag=true;w[X][1].v=w[X][1].y-w[X][1].x+1-w[X][1].v+w[X][i].v;
					w[X][1].y=w[X][i].y;break;}
                    ans-=aa;
                }
            }
            else goto loop;
        }
        else {
            now-=2;
            if(aa+ab<ac)
            {
                if(Y!=1)
                {
                    for(int i=Y-1;i>=1;--i) if(!w[X][i].flag)
					{w[X][i].flag=true;w[X][Y].v=w[X][Y].y-w[X][Y].x+1-w[X][Y].v+w[X][i].v;
					w[X][Y].x=w[X][i].x;break;}
                    ans-=aa;
                }
                else{
                    for(int i=2;i<=cnt[X];++i) if(!w[X][i].flag)
					{w[X][i].flag=true;w[X][1].v=w[X][1].y-w[X][1].x+1-w[X][1].v+w[X][i].v;
					w[X][1].y=w[X][i].y;break;}
                    ans-=aa;
                }
                if(Yy!=1)
                {
                    for(int i=Yy-1;i>=1;--i) if(!w[Xx][i].flag)
					{w[Xx][i].flag=true;
					w[Xx][Yy].v=w[Xx][Yy].y-w[Xx][Yy].x+1-w[Xx][Yy].v+w[Xx][i].v;
					w[Xx][Yy].x=w[Xx][i].x;break;}
                    ans-=ab;
                }
                else{
                    for(int i=2;i<=cnt[Xx];++i) if(!w[Xx][i].flag)
					{w[Xx][i].flag=true;
					w[Xx][1].v=w[Xx][1].y-w[Xx][1].x+1-w[Xx][1].v+w[Xx][i].v;
					w[Xx][1].y=w[Xx][i].y;break;}
                    ans-=ab;
                }
            }
            else{
                loop:;
                w[XX][YY].flag=true;int rmb;
                for(int i=YY+1;i<=m;++i) if(!w[XX][i].flag) {rmb=i;break;}
                w[XX][rmb].flag=true;
                for(int i=YY-1;i>=1;--i) if(!w[XX][i].flag)
				{w[XX][i].v+=w[XX][rmb].v+(w[XX][YY].y-w[XX][YY].x+1-w[XX][YY].v);
				w[XX][i].y=w[XX][rmb].y;break;}
                ans-=ac;
            }
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：x_faraway_x (赞：4)

楼上题解貌似有点玄？那我来写个更玄的（雾

我们先不管列，考虑每一行，很容易想到设f[i][j]表示**当前这一行**前i个数涂j次色所能正确涂色的最多格子数

再枚举一个k(j≤k≤i)，考虑当前第k个格子到第i个格子的情况

我们要分情况讨论：

1. 第i个格子必须正确的刷，那么意味着k~i所刷的颜色必须是与i相同的颜色。我们用sum来表示k~i中与i颜色相同的格子个数，那么就可以递推：

    F[i][j]=max{F[k-1][j-1]+sum}(j≤k≤i)

2. 第i个格子错误地刷，那么意味着k~i所刷的颜色必须是与i相反的颜色（总共只有两种颜色嘻嘻嘻），仍然用sum可以递推：

    F[i][j]=max{F[k-1][j-1]+i-k+1-sum}(j≤k≤i)

以上两个取最大值即可。

但是，这道题到这里当然还没有做完——还有列没考虑呢！

其实很简单，我们记g[i][j]表示第i行涂j次色最多能正确涂的格子数，而题目说最多能涂t次色，是不是很容易想到背包问题！

至此就结束了，当然也有不少小的细节就见程序吧（解释上面应该差不多了，故代码就不注释了）

```cpp
#include<cstdio>
#include<cstring>
#define MAX(x,y) (x>y?x:y)
#define MIN(x,y) (x<y?x:y)
const int N=55,T=2505;
int n,m,t;
int b[N][N],f[N][T],mx[N],g[N][T],dp[T];
int main()
{
    scanf("%d%d%d",&n,&m,&t);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            scanf("%1d",&b[i][j]);
            if(j==1||b[i][j]!=b[i][j-1]) mx[i]++;
        }
    for(int l=1;l<=n;l++)
    {
        memset(f,0,sizeof(f));
        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=mx[l];j++)
            {
                int r=0;
                for(int k=i;k>=j;k--)
                {
                    if(b[l][k]==b[l][i]) r++;
                    f[i][j]=MAX(f[i][j],f[k-1][j-1]+r);
                    f[i][j]=MAX(f[i][j],f[k-1][j-1]+i-k+1-r);
                }
                g[l][j]=MAX(g[l][j],f[i][j]);
            }
        }
    }
    for(int i=1;i<=n;i++)
        for(int j=t;j>=1;j--)
            for(int k=1;k<=MIN(j,mx[i]);k++)
                dp[j]=MAX(dp[j],dp[j-k]+g[i][k]);
    printf("%d",dp[t]);
}
```

---

## 作者：假装思考 (赞：3)


【分析】

	       第一眼的想法是DP+背包，先处理出每个板子刷各种次数最多刷的格子数，然后当分组背包做。但是瓶颈就在于预处理，因为可以错误粉刷。
	       考虑对于每一块板子，用Opt[i][j][1/0]表示刷到第i位全刷，刷了j次，且第i位刷的是蓝/红色的最多正确刷的格子数。考虑转移：
		Opt[i][j][0]=max(Opt[i-1][j][0]+(A[i]==0),Opt[i-1][j-1][1]+(A[i]==0));
	       另一个类似，然后。。。就切掉了。。。不敢相信。。。
           
【代码】
```
	#include<bits/stdc++.h>
	#define LL long long
	#define ULL unsigned long long
	using namespace std;
	int N,M,T,Cnt;
	char c;
	int A[51],Opt[51][51][2],G[51][51];
	int DP[51][2501];
	void DP1(){
		memset(Opt,0,sizeof(Opt));
		for(int i=1;i<=M;++i)
			for(int j=1;j<=min(M,T);++j){
				Opt[i][j][0]=max(Opt[i-1][j][0],Opt[i-1][j-1][1])+(A[i]==0);
				Opt[i][j][1]=max(Opt[i-1][j][1],Opt[i-1][j-1][0])+(A[i]==1);
			}
		for(int i=1;i<=min(M,T);++i)
			G[Cnt][i]=max(Opt[M][i][0],Opt[M][i][1]);
	}
	int main(){
		scanf("%d%d%d",&N,&M,&T);
		for(int i=1;i<=N;++i){
			++Cnt;
			for(int j=1;j<=M;++j){
				cin>>c;
				A[j]=c-'0';
			}
			DP1();
		}
		for(int i=1;i<=N;++i)
			for(int j=1;j<=T;++j){
				DP[i][j]=DP[i-1][j];
				for(int k=1;k<=j&&k<=min(M,T);++k)
					DP[i][j]=max(DP[i][j],DP[i-1][j-k]+G[i][k]);
			}
		printf("%d\n",DP[N][T]);
		return 0;
	}
```


---

## 作者：asuldb (赞：3)

这好像是个暴力?

但是跑的挺快的

我们设$dp[i][j][k]$表示在第$i$行我们最远染到的位置是$j$，这一行上一共染了$k$次最多能染对多少个格子

理性分析一下啊，每一行最多也就染$m$次，这样就能把这一行格子全部都染对

所以这个空间复杂度是$nm^2$的

之后考虑一下转移

显然这就是一个非常经典的断点$dp$了，转移为

$$dp[i][j][k]=max(dp[i][p][k-1]+max(s_0[p+1,j],s_1[p+1,j]))$$

$s_0[p+1,j]$表示这个区间内有几个$0$，后面那个也就是我们能够正确覆盖的格子数量

最后用分组背包合并大案就好了

代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define max(a,b) ((a)>(b)?(a):(b))
#define re register
int dp[51][51][51]; 
int pre[51][51][2];
char S[51][51];
int f[2501];
int n,m,T;
int main()
{
    scanf("%d%d%d",&n,&m,&T);
    for(re int i=1;i<=n;i++)
    {
        scanf("%s",S[i]+1);
        for(re int j=1;j<=m;j++)
        if(S[i][j]=='1') pre[i][j][1]=pre[i][j-1][1]+1,pre[i][j][0]=pre[i][j-1][0];
            else pre[i][j][1]=pre[i][j-1][1],pre[i][j][0]=pre[i][j-1][0]+1;
    }
    for(re int i=1;i<=n;i++)
        for(re int j=1;j<=m;j++)
            for(re int k=1;k<=j;k++)
                for(re int p=0;p<j;p++)
                    dp[i][j][k]=max(dp[i][j][k],dp[i][p][k-1]+max(pre[i][j][0]-pre[i][p][0],pre[i][j][1]-pre[i][p][1]));
    for(re int i=1;i<=n;i++)
        for(re int j=T;j>=0;j--)
            for(re int k=0;k<=m;k++)
                if(j-k>=0) f[j]=max(f[j],f[j-k]+dp[i][m][k]);
    printf("%d\n",f[T]);
    return 0;
}

```

---

## 作者：Night_Aurora (赞：3)

很显而易见的一个动态规划

设DPN[a][t][u]代表第a个木板在t之前刷u次最多合格的格子个数

那么DPN[a][t][u]=max(MaxSum(a,i,t)+DPN[a][i-1][u-1])

其中MaxSum是在i到t区间里两个颜色中最多的那个个数

这样求出DPN的复杂度是N^4

求出后简化成Mp[a][u]，代表第a个木板刷u次最多个数

然后在设DPM[a][t]表示前a个木板共t次操作的最多正确块

这个通过Mp可以求出

DPM[a][t]=max(DPM[a-1][t-u]+Mp[a][u])

复杂度是mn^2，和DPN复杂度差不多

那么DPM[N][T]就是答案






```cpp
#include <stdio.h>
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) (a>b?b:a)
#define S1(a,f,t) (Sum[a][t]-Sum[a][f-1])
#define S0(a,f,t) (t-(f)+1-S1(a,f,t))
int N,M,T;
char DPN[60][60][60];
int DPM[60][2510];
char Mxp[60][60];
int ReadChar()
{
    char c=getchar();
    while(c<'0'||c>'9')
        c=getchar();
    return c-'0';
}
char Sum[60][60];
void Input()
{
    scanf("%d %d %d",&N,&M,&T);
    int wia,wib;
    for(wia=1;wia<=N;++wia)
        for(wib=1;wib<=M;++wib)
            Sum[wia][wib]=Sum[wia][wib-1]+ReadChar();
    if(T>N*M)
        T=N*M;
}
void DPA()
{
    int ww,wu,wt,wf;
    for(ww=1;ww<=N;++ww)
        for(wu=1;wu<=M;++wu)
            for(wt=1;wt<=M;++wt)
                if(Sum[ww][wt]-Sum[ww][wt-1])
                    for(wf=wt-1;wf>=0;--wf)
                        DPN[ww][wt][wu]=max(DPN[ww][wt][wu],DPN[ww][wf][wu-1]+S1(ww,wf+1,wt));
                else
                    for(wf=wt-1;wf>=0;--wf)
                        DPN[ww][wt][wu]=max(DPN[ww][wt][wu],DPN[ww][wf][wu-1]+S0(ww,wf+1,wt));
    for(ww=1;ww<=N;++ww)
        for(wu=1;wu<=M;++wu)
            for(wt=1;wt<=M;++wt)
                Mxp[ww][wu]=max(Mxp[ww][wu],DPN[ww][wt][wu]);
    for(wu=1;wu<=T;++wu)
        for(ww=1;ww<=N;++ww)
            for(wt=0;wt<=min(M,wu);++wt)
                DPM[ww][wu]=max(DPM[ww][wu],DPM[ww-1][wu-wt]+Mxp[ww][wt]);
}
int main()
{
    Input();
    DPA();
    printf("%d\n",DPM[N][T]);
    return 0;
}
```

---

## 作者：Plus_Ultra (赞：1)

一. 前言：

乍一看这题挺好做，但是坑点还是挺多的，在卡了无数个30分后终于A了，原因见代码处.

二. 解法：

1. 我们先考虑只有一条模板的情况.

   - 如果只有一条木板，那么设 g [ i ] [ j ] 表示前i个格子刷j次的最多正确格子.

   - 那么很显然 g[ i ] [ j ] = max { g[ k ] [ j - 1 ] + w(k + 1, i) }(k < i).

   - w(x, y)为第 x 到第 y 个格子的最多同色格子数，我们把这一段区间内的蓝色和红色格子取个 max 即可，可用前缀和实现，具体见代码.

2. 我们再来考虑有多个木板的情况.

   - 如果有多条木板，我们设 f[ i ][ j ]表示前 i 条木板刷 j 次的最大答案.

   - 则 f[ i ][ j ] = max { f[i - 1][ k ] + g[ i ][ m ][ j - k ] }(k <= j).

下面上代码（我知道各位大佬也不需要代码）：

```
#include<iostream>
 
#define N 60
#define K 2510

using namespace std;

int n,m,T,sum[N][N],ans;
int g[N][N][K],f[N][K];
char c[N];

int main()
{
	cin>>n>>m>>T;
	for(int i=1;i<=n;i++) 
	{
		cin>>c+1;//预处理蓝色格子的前缀和 
		for(int j=1;j<=m;j++)
			sum[i][j]=sum[i][j-1]+(c[j]=='1');
	}
	
	for(int l=1;l<=n;l++)//处理g数组 
	{
	  for(int i=1;i<=m;i++)//枚举粉刷到第几个格子 
		for(int j=1;j<=T&&j<=m;j++)//j<=T会TLE，要判断一下 
		{
			for(int k=0;k<i;k++)//上一次粉刷到哪里 
			{
				int w=sum[l][i]-sum[l][k];//k+1~i之间出现了多少蓝色格子
				//那么这段区间内红色格子的数目就是i-k-w. 
				g[l][i][j]=max(g[l][i][j],g[l][k][j-1]+max(w,i-k-w));//更新
			}
				
		}
	}
	
	for(int i=1;i<=n;i++)//枚举行数 
	{
		for(int j=1;j<=T;j++)//枚举次数 
			for(int k=0;k<=j;k++)//k<=min(j,m)当然不行，有可能遍历不到所有情况，我卡了好多次30分 
			f[i][j]=max(f[i][j],f[i-1][k]+g[i][m][j-k]);//更新 
	}
	
	cout<<f[n][T]<<endl;//这里不需要一个一个比较了 
	
	return 0;
}
```

去掉空行后30多行，也是比较短了.

### [ _Plus Ultra!!!_ ](https://www.luogu.org/blog/OnePunchManGO/)

---

## 作者：Akaina (赞：1)

dp题。dp方程较难推，有两个dp值，包含了从局部到整体的解题思路

当只有一条木板时，

设g[i][j][k]表示第i个木板前j个格子刷k次的最大值

则g[i][j][k]=max{g[i][t][k-1]+w(t+1,j)}(t<j)

w(x,y)表示第x个到第y个格子的最多同色格子数（前缀和）

有多条木板时，
设f[i][j]表示前i个木板刷j次的最大答案

则f[i][j]=max{f[i-1][k]+g[i][m][j-k]}（k<=j）

代码如下：
```
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int n,m,t;
int a[55][55];
int s1[55][55]={},s2[55][55]={};//s1:0 s2:1
int f[55][2550];
int g[55][55][55];
int wid(int i,int x,int y)
{
    return max(s1[i][y]-s1[i][x-1],s2[i][y]-s2[i][x-1]);
}
int tim;
int main()
{
    ios::sync_with_stdio(0);
    cin>>n>>m>>tim;
    for(int i=1;i<=n;i++)
    {
        string str;cin>>str;
        for(int j=1;j<=str.size();j++)
        {
            if(str[j-1]=='0')a[i][j]=0;
            else a[i][j]=1;
            if(a[i][j]==0)s1[i][j]=s1[i][j-1]+1,s2[i][j]=s2[i][j-1];else s1[i][j]=s1[i][j-1],s2[i][j]=s2[i][j-1]+1;
        }
    }
    for(int i=1;i<=n;i++)//第i个木板
    for(int j=1;j<=m;j++)//前j个格子
    for(int k=1;k<=j;k++)//刷了k次
    for(int t=0;t<j;t++)//前t个格子
    {
        g[i][j][k]=max(g[i][j][k],g[i][t][k-1]+wid(i,t+1,j));
    }
    for(int i=1;i<=n;i++)
    for(int j=1;j<=tim;j++)
    for(int k=0;k<=j;k++)
    {
        int cnt=0;
        if(j-k>=m)cnt=m;else cnt=g[i][m][j-k];
        f[i][j]=max(f[i-1][k]+cnt,f[i][j]);
    }
    cout<<f[n][tim]<<endl;
    return 0;
}

---

## 作者：lizbaka (赞：1)

## [广告](https://www.cnblogs.com/lizbaka/p/10417671.html)

# Solution
蒟蒻看到这题想了$n$多种~~完全不正确的~~处理方法，如果是在考场上估计已经光速凉凉了$QAQ$

---

对于每一行，我们可以把它分成若干个颜色不同的连续段（对应若干次颜色不同的粉刷），从左到右考虑

注意到题目：
>一个格子如果未被粉刷或者被粉刷错颜色，就算错误粉刷。

意思就是**不刷白不刷**

如果是颜色不对，多刷这一格不会比不刷差，就不需要考虑不刷的情况

所以我们有：

状态：设$dp_{i,j,k,0/1}$表示当前枚举到第$i$行，第$j$个格子，已经涂了$k$次（分成了$k$段），当前格子涂的颜色是$0/1$

方程：
$$dp_{i,j,k,x}=max(dp_{i,j-1,k,x},dp_{i,j-1,k-1,x\space xor\space 1})+[x=color_{i,j}]$$

(方括号是艾弗森括号，当其中的条件为真时值为$1$，否则为$0$)

这个转移应该很好理解吧

---
处理完每一行之后，$max(dp_{i,m,k,0},dp_{i,m,k,1})$即为第$i$行分配$k$次粉刷次数所能正确粉刷的最大格子数

这样，每一行作为一组，原问题就转化为一个分组背包问题，在此不再赘述

# Code
代码中所用的字母与上述转移方程略有不同，请注意辨别
```cpp
#include <cstdio>
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cmath>
#define maxn 55
#define maxm 55
#define maxt 2505
using namespace std;
typedef long long ll;

template <typename T> void read(T &t)
{
	t=0;int f=0;char c=getchar();
	while(!isdigit(c)){f|=c=='-';c=getchar();}
	while(isdigit(c)){t=t*10+c-'0';c=getchar();}
	if(f)t=-t;
}

int n,m,t;
int col[maxn][maxm];
int dp[maxn][maxm][maxm][2],tdp[maxt];

int main()
{
	read(n),read(m),read(t);
	for(register int i=1;i<=n;++i)
	{
		char c[maxm];
		scanf("%s",c+1);
		for(register int j=1;j<=m;++j)
			col[i][j]=c[j]-'0';
	}
	for(register int li=1;li<=n;++li)
		for(register int i=1;i<=m;++i)
			for(register int k=1;k<=min(t,m);++k)
				for(register int x=0;x<=1;++x)
					dp[li][i][k][x]=max(dp[li][i-1][k][x],dp[li][i-1][k-1][x^1])+(x==col[li][i]);
	for(register int i=1;i<=n;++i)
		for(register int j=t;j>=0;--j)
			for(register int k=1;k<=min(j,m);++k)
				tdp[j]=max(tdp[j],tdp[j-k]+max(dp[i][m][k][0],dp[i][m][k][1]));
	printf("%d",tdp[t]);
	return 0;
}
```

---

## 作者：Brioche (赞：1)

# [SCOI2009]粉刷匠
### [BLOG](https://www.cnblogs.com/terribleterrible/p/9879111.html)

### ![[SCOI2009]粉刷匠](https://www.luogu.org/problemnew/show/P4158)

很直接的思路,简单好写.

分别对每块木板做区间dp,设$g[i][j]$表示前i个格子,刷恰好j次,并且第i格是合法的最多合法的格子数.从前往后枚举断点来转移就好了.

这样处理再出来$g[i][j]$每一块木板i刷j次的最大合法格子数.

最后再背包合并每块木板的答案,用$dp[i][j]$表示前i块木板,一共恰好刷了k次的最大合法格子数,用刷表法暴力背包合并就好了.

很详细的注释.
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define maxn 55
using namespace std;
int n,m,T,ans,sum[maxn],dp[maxn][maxn*maxn];
int f[maxn][maxn],g[maxn][maxn];
char s[maxn];
//分别对每块木板区间dp
//再用背包来合并
int main()
{
	cin>>n>>m>>T;
	for(int i=1;i<=n;i++)
	{
		scanf("%s",s+1);
		memset(g,0x8f,sizeof(g));
		g[0][0]=0;
		for(int j=1;j<=m;j++)sum[j]=sum[j-1]+(s[j]=='1');//蓝色的前缀和
		//g[j][k]当前木板表示前j个格子,刷k次的最多合法的格子数,并且j是合法的格子
		for(int j=1;j<=m;j++)
			for(int k=1;k<=j;k++)
				for(int l=0;l<j;l++)
				{
					if(s[j]=='1')g[j][k]=max(g[j][k],g[l][k-1]+sum[j]-sum[l]);
					else g[j][k]=max(g[j][k],g[l][k-1]+j-l-sum[j]+sum[l]);
				}
		//f[j][k]表示第i块木板,恰好刷k次的最多合法格子数
		for(int j=0;j<=m;j++)
			for(int k=0;k<=j;k++)
				f[i][k]=max(f[i][k],g[j][k]);
	}
	//dp[i][j]表示前i个块木板,恰好刷j次的最多的合法格子数
	for(int i=1;i<=n;i++)
		for(int j=0;j<=T&&j<=i*m-m;j++)
			for(int k=0;k<=m;k++)
				dp[i][j+k]=max(dp[i][j+k],dp[i-1][j]+f[i][k]);
	for(int i=0;i<=T;i++)ans=max(ans,dp[n][i]);
	cout<<ans<<endl;
	return 0;
}

```




---

## 作者：Victorique (赞：1)

这个题乍一看觉得挺简单的，事实上却完全不是。首先，这个题看上去无脑直接刷就可以然而因为刷的次数远远大于木板的个数所以不行，然后开始考虑DP，自己一开始是这么想的，如果用f[t][i][j]表示刷t次时，前i块板子刷到第j个最大值是多少，然后前缀和优化了一小下，勉强打出了二逼DP，然后90，之后从网上科普了一下，发现这样如果有一种中间有一整块不用涂的木板，那么就会崩掉。如讨论里的那一个90，是同一个错因。

之后换用了思路，首先还是前缀和对0和1的计算，然后算出对于第i块木板，涂到第j格子时，涂了k次能有的最大的价值，然后再用一个数组储存第i块木板涂j次的最优解，f表示前i块，涂j次的最优解，不难得出结果。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#define re register
#define ll long long
using namespace std;
int f[55][2501],t,r,n,m ,c[101][101][2],v[101][101],ans,g[101][101][101];
string s;
int main()
{
    cin>>n>>m>>t;
    for(re int i=1;i<=n;i++)
    {
        cin>>s;
        for(re int j=1;j<=m;j++)
        {
            c[i][j][1]=c[i][j-1][1];
            c[i][j][0]=c[i][j-1][0];
            c[i][j][s[j-1]-'0']++;//前缀和的计算。
        }
    }
    for(re int i=1;i<=n;i++)
     for(re int j=1;j<=m;j++)
      for(re int k=1;k<=m;k++)
       for(re int l=0;l<j;l++)
       {
           g[i][j][k]=max(g[i][j][k],g[i][l][k-1]+max(c[i][j][0]-c[i][l][0],c[i][j][1]-c[i][l][1]));//以这个数组储存第i块j格子涂k次的最大值。
       }
    for(re int i=1;i<=n;i++)
     for(re int j=1;j<=m;j++)
      for(re int k=1;k<=m;k++)
      {
          v[i][j]=max(v[i][j],g[i][k][j]);//这个数组储存第i块j次的。。
      }
    for(re int i=1;i<=n;i++)
     for(re int j=1;j<=t;j++)
      for(re int k=0;k<=j;k++)
    f[i][j]=max(f[i][j],f[i-1][j-k]+v[i][k]);//dp数组求解。
    cout<<f[n][t];
}
/* 
5 8 4
11100111
11100111
01010101
11100111
11111111
*/
```

---

## 作者：_蒟蒻__ (赞：1)

这种类型的题……硬要取个名字的话，就叫分组序列DP吧（口胡勿信，手动滑稽）

其实思路前面的几位大佬也讲到了，那本蒟蒻就~~提炼一下模型~~
啰嗦啰嗦吧。

------------

序列dp常用套路：dp[i][j][0/1/2/3……]表示前i个什么东西中选了j个，其中第j个的状态为0/1/2/3……。这里又多了一个组别（木板），怎么办呢，再加上一维，考虑一下不同组别间的处理，剩下的就是一样的了。

知道大佬们懒得看上面，直接放代码

蒟蒻还是刚装C++的萌新，望大佬斧正。

```cpp
#include<iostream>
using namespace std;
int dp[51][51][2510][3];
int a[51][51]; char s[51];
int n,m,t;
int main()
{
	ios::sync_with_stdio(false);
	cin>>n>>m>>t;
	for(int i=1;i<=n;i++)
	{
		cin>>(s+1);
		for(int j=1;j<=m;j++)
			a[i][j]=s[j]-'0';
	}
	
	for(int i=1;i<=n;i++)// 前i块木板(组别) 
	{
		for(int k=1;k<=t;k++) // 边界处理第一块格子 
		{
			dp[i][1][k][0]=max(max(dp[i-1][m][k-1][0],dp[i-1][m][k-1][1]),dp[i-1][m][k-1][2])+(a[i][1]==0); 
			dp[i][1][k][1]=max(max(dp[i-1][m][k-1][0],dp[i-1][m][k-1][1]),dp[i-1][m][k-1][2])+(a[i][1]==1);
			dp[i][1][k][2]=max(max(dp[i-1][m][k][0],dp[i-1][m][k][1]),dp[i-1][m][k][2]);
		}
		for(int j=2;j<=m;j++) // 该木板前j个格子(开始序列dp) 
		for(int k=1;k<=t;k++) // 到这里一共用了k次机会 
		{
			// 哇，转移方程好长!(当然大佬们并不觉得)其实写起来思路异常清晰。
			dp[i][j][k][0]=max(max(dp[i][j-1][k][0],dp[i][j-1][k-1][1]),dp[i][j-1][k-1][2])+(a[i][j]==0);
			dp[i][j][k][1]=max(max(dp[i][j-1][k-1][0],dp[i][j-1][k][1]),dp[i][j-1][k-1][2])+(a[i][j]==1);
			dp[i][j][k][2]=max(max(dp[i][j-1][k][0],dp[i][j-1][k][1]),dp[i][j-1][k][2]);
		}
	}
	
	cout<<max(max(dp[n][m][t][0],dp[n][m][t][1]),dp[n][m][t][2]); // 其实这个地方应该枚举t的，因为有时候t多用了还不如不用优。但是这样的数据不好构造，所以偷个懒qwq。
	return ~~(0-0);
} 
```


---

## 作者：Adove (赞：1)

线性DP预处理+分组背包

首先设`dp[i][j][0/1]`表示该木板前`i`个格刷了`j`次且最后一次颜色为`0/1`的最大正确数

做下`0/1`的前缀和然后转移状态

`dp[i][j][k]=max(dp[l][j][k],dp[l][j-1][k^1])+lis[i][k]-lis[l][k]`

然后对每个木板跑分组背包就可以了

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MAXN=55;
const int MAXT=2505;

int n,m,T;
int cnt[MAXN][2];
int dp[MAXN][MAXN][2];
int f[MAXT];

int main()
{
	scanf("%d%d%d",&n,&m,&T);
	for(int i=1;i<=n;++i){
		memset(cnt,0,sizeof(cnt));bool b;
		for(int j=1;j<=m;++j){
			scanf("%1d",&b);
			cnt[j][b]=cnt[j-1][b]+1;
			cnt[j][b^1]=cnt[j-1][b^1];
		}for(int j=1;j<=m;++j){
			for(int k=0;k<j;++k){
				for(int l=1;l<=j;++l){
					for(int o=0;o<2;++o){
						dp[j][l][o]=max(dp[k][l][o],dp[k][l-1][o^1])+cnt[j][o]-cnt[k][o];
					}
				}
			}
		}for(int j=T;j;--j){
			for(int k=1;k<=min(m,j);++k){
				f[j]=max(f[j],f[j-k]+max(dp[m][k][0],dp[m][k][1]));
			}
		}
	}printf("%d\n",f[T]);
	return 0;
}
```



---

## 作者：月·无笙 (赞：0)

 这是蒟蒻的第一篇题解~（主要是这题太毒瘤给蒟蒻印象很深）

 **下面正式进入主题**：



------------

 声明：
         
         f[i][j]表示前i块木板，j次粉刷的最多正确格子数
         b[i][x]表示第i块木板，刷x次最多正确格子数
         d[i][j]表示当前木板已经处理到第i个格子，考虑第j次粉刷是从k（1<=k<=i-1）刷到i的最多格子数
     //这是一道资源分配类DP


------------

预处理+转移：

对于b[ ][ ]和d[ ][ ],我们将它们一起处理。

对于第i块木板，当前处理到第j个格子，现在是第k次粉刷。

枚举上一次粉刷结束的位置，即是从哪刷到j的，记为位置l (1<=l<=j)

另记一个变量r，表示从l到j中与j颜色相同的格子数

 那么，**d[j][k]=max{d[j][k],max{d[l-1][j-1]+r,d[l-1][j-1]+j-l+1-r}}**

 **为什么要分 r 和 j-l+1-r 两种情况呢？** 因为格子可能是红色也可能是蓝色

处理完d[ ][ ],b[ ][ ]的转移方程就很显然了。

 **b[i][x]=d[m][x]**;

其中，i表示第i块木板，x表示刷了x次，m如题目所示。

下面处理f[ ][ ].

 显然，**f[i][j]=max{f[i-1][j-x]+b[i][x]}**

表示第i块木板刷x次得到的最多格子数（其实是一个小小的背包DP）

**下面上代码**：

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<iostream>
#include<cstring>
using namespace std;
const int N=55;
const int T=2505;
int n,m,t;
int b[N][T],d[N][T],f[N][T];
char a[N][N];
int ans;
int main()
{
	scanf("%d%d%d",&n,&m,&t);
	for(int i=1;i<=n;i++)
	cin>>(a[i]+1);
	for(int i=1;i<=n;i++)
	{
		memset(d,0,sizeof(d));
		for(int j=1;j<=m;j++)
		{
			for(int k=1;k<=t;k++)
			{
				int r=0;
				for(int l=j;l>=1;l--)
				{
					r+=(a[i][j]==a[i][l]);
					d[j][k]=max(d[l-1][k-1]+r,d[j][k]);
					d[j][k]=max(d[j][k],d[l-1][k-1]+j-l+1-r);
				}
			}
		}
		for(int k=1;k<=t;k++)
		    b[i][k]=d[m][k];
	}
	for(int i=1;i<=n;i++)
	   for(int j=t;j>=0;j--)
	      for(int x=0;x<=j;x++)
	   f[i][j]=max(f[i][j],f[i-1][j-x]+b[i][x]);
	for(int i=1;i<=n;i++)
	ans=max(ans,f[i][t]);
	printf("%d\n",ans);
	return 0;
}
```

**But,你会发现这样会T一个点，那么我们考虑怎么优化。**

设to[i] 表示第i块木板最多刷多少次。（因为不可能每块木板真的都刷了t次）

对于每块木板，枚举位置j,

 if（a[i][j]!=a[i][j-1])//a为题目所给的字符串

      to[i]++;//如果颜色不相同，就累加

因为如果颜色相同，就可以一次性刷掉。

 **下面是AC代码**

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<iostream>
#include<cstring>
using namespace std;
const int N=55;
const int T=2505;
int n,m,t;
int b[N][T],d[N][T],f[N][T];
char a[N][N];
int to[N];
int ans;
int main()
{
	scanf("%d%d%d",&n,&m,&t);
	for(int i=1;i<=n;i++)
	{
	  cin>>(a[i]+1);
	  for(int j=1;j<=m;j++)
	  if(a[i][j]!=a[i][j-1]) to[i]++;
    }
	for(int i=1;i<=n;i++)
	{
		memset(d,0,sizeof(d));
		for(int j=1;j<=m;j++)
		{
			for(int k=1;k<=min(to[i],j);k++)
			{
				int r=0;
				for(int l=j;l>=1;l--)
				{
					r+=(a[i][j]==a[i][l]);
					d[j][k]=max(d[l-1][k-1]+r,d[j][k]);
					d[j][k]=max(d[j][k],d[l-1][k-1]+j-l+1-r);
				}
			}
		}
		for(int k=1;k<=t;k++)
		    b[i][k]=d[m][k];
	}
	for(int i=1;i<=n;i++)
	   for(int j=t;j>=0;j--)
	      for(int x=min(to[i],j);x>=0;x--)
	   f[i][j]=max(f[i][j],f[i-1][j-x]+b[i][x]);
	for(int i=1;i<=n;i++)
	ans=max(ans,f[i][t]);
	printf("%d\n",ans);
	return 0;
}
```


---


# [JSOI2016] 最佳团体

## 题目描述

JSOI 信息学代表队一共有 $N$ 名候选人，这些候选人从 $1$ 到 $N$ 编号。方便起见，JYY 的编号是 $0$ 号。每个候选人都由一位编号比他小的候选人$R_i$ 推荐。如果 $R_i = 0$​，则说明这个候选人是 JYY 自己看上的。

为了保证团队的和谐，JYY 需要保证，如果招募了候选人 $i$，那么候选人 $R_i$ 也一定需要在团队中。当然了，JYY 自己总是在团队里的。每一个候选人都有一个战斗值 $P_i$ ，也有一个招募费用 $S_i$ 。JYY 希望招募 $K$ 个候选人（JYY 自己不算），组成一个性价比最高的团队。也就是，这 $K$ 个被 JYY 选择的候选人的总战斗值与总招募费用的比值最大。


## 说明/提示

对于100%的数据满足$1≤K≤N≤2500$,$0<S_i,P_i≤10^4$ , 
$0$ $≤$ $R_i$ $<$ $i$

## 样例 #1

### 输入

```
1 2
1000 1 0
1 1000 1```

### 输出

```
0.001```

# 题解

## 作者：YLWang (赞：27)

树上背包的复杂度是$O(n^2)$的。

首先可以看出这是一道分数规划的题，二分答案$mid$操作一波就变成了了以下这道题：

给定一棵根为$0$的树。每个点点权为$P_i-mid *S_i$，选定一个点就必须选其所有祖先节点。问能否取$k$个节点使得取出的点点权大于零。

不防设$dp[u][j]$表示当前根为$u$，取$j$个节点所带来的收益最大值。

则有两种情况：

- 1.$u$不取。则这棵树一个都不能取。$dp[u][0] = 0$

- 2.$u$取。枚举子树，设子树的根为$v$。枚举当前已合并的所有子树取的总个数$j$以及该子树内取的个数$k$。有$dp[u][j] = max(dp[u][j], dp[u][j-k] + dp[v][k]);$注意因为$u$取，所以必须强制跳过状态$dp[u][0]$，即$j$与$j-k$均不为$0$.

关于时间复杂度网上有一篇[讲稿](https://www.cnblogs.com/liu-runda/p/6399224.html)
十分不错，引用一段：

- ... 因为每次合并一棵子树时付出的代价是”已经合并的兄弟子树的大小之和”*”正在合并的这棵子树的大小”,实质上是树上每对节点在LCA处贡献时间复杂度 ...

所以是$n^2$的。

代码如下：
```
#pragma GCC optimize(3)
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#define ll long long
#define reaD() read()
#define pb push_back
#define mst(a,b) memset(a,b,sizeof(a))
#define foR(i, k, j) for(register int i = (k); i >= (j); i--)
#define For(i, k, j) for(register int i = (k); i <= (j); i++)
#define DEBUG printf("Running on Line %d in Function %s\n",__LINE__,__FUNCTION__)
using namespace std;
inline void ckmax(int &a, int b) {a = max(a, b);}
inline void ckmin(int &a, int b) {a = min(a, b);}
inline int read()
{
    int num=0,flag=1;char c=' ';
    for(;c>'9'||c<'0';c=getchar()) if(c=='-') flag = -1;
    for(;c>='0'&&c<='9';num=(num<<1)+(num<<3)+c-48,c=getchar());
    return num*flag;
}
#define MAXN 2505
struct Edge {
	int v, nxt; 
}e[MAXN<<1];
int lst[MAXN], tot, n, m;
inline void addedge(int u, int v) {
	e[++tot] = (Edge) {v, lst[u]};
	lst[u] = tot;
}
double U[MAXN], V[MAXN];
double a[MAXN], dp[MAXN][MAXN];
double tmp[MAXN];
int siz[MAXN];
inline void dfs(int u, int fa) {
	dp[u][1] = a[u]; siz[u] = 1;
	for(int i = lst[u]; i; i = e[i].nxt) {
		int v = e[i].v;
		if(v != fa) {
			dfs(v, u);
			siz[u] += siz[v];
			for(int j = min(siz[u], m+1); j >= 1; j--)
				For(k, 0, min(siz[v], j-1))
					dp[u][j] = max(dp[u][j], dp[u][j-k] + dp[v][k]);
		}
	}
}
inline bool check(double mid) {
	a[0] = 0;
	For(i, 1, n) a[i] = U[i]-mid*V[i];
	For(i, 0, n) 
		For(j, 1, m+1) dp[i][j] = -1e9;
	dfs(0, -1);
	return dp[0][m+1] >= 0;
}
signed main()
{
//	freopen("snakes.in", "r", stdin);
//	freopen("snakes.out", "w", stdout);
	cin >> m >> n;
	For(i, 1, n) {
		V[i] = read(), U[i] = read();
		addedge(read(), i);
	}
	double l = 0, r = 10000;
	while(l < r - 1e-4) {
		double mid = (l+r)/2;
		if(check(mid)) l = mid;
		else r = mid;
	}
	printf("%.3lf\n", l);
    return 0;
}


```

---

## 作者：D2T1 (赞：20)

# 题解 P4322


## 前置：分数规划

参考：<https://oi-wiki.org/misc/frac-programming/>

分数规划用来求一个分式的极值：给出 $a_i,b_i$，求一组 $w_i\in\{0,1\}$ 使 $\displaystyle\frac{\sum_{i=1}^n a_iw_i}{\sum_{i=1}^n b_iw_i}$ 最小化或最大化，再加上一些奇怪的限制。

### 二分求解

最大值：二分一个答案 $mid$，则：

$$
\displaystyle\frac{\sum_{i=1}^n a_iw_i}{\sum_{i=1}^n b_iw_i}>mid
\\
\implies\sum_{i=1}^n a_iw_i - mid \times\sum_{i=1}^n b_iw_i>0
\\
\implies\sum_{i=1}^nw_i(a_i-mid \times b_i) > 0
$$

之后求 $\sum_{i=1}^nw_i(a_i-mid \times b_i)$ 的最大值就行了。（比 $0$ 大则 $mid$ 可行）

最小值同理，求求 $\sum_{i=1}^nw_i(a_i-mid \times b_i)$ 的最小值。

### 例题

> 给出 $a_i,b_i$，求一组 $w_i\in\{0,1\}$ 使 $\displaystyle\frac{\sum_{i=1}^n a_iw_i}{\sum_{i=1}^n b_iw_i}$ 最大化。

把 $w_i(a_i-mid \times b_i)$ 作为第 $i$ 个物品的权值，选择所有 $>0$ 的物品。

```cpp
const int N = 1e5 + 10;
const double eps = 1e-6;
int n; double a[N], b[N];

bool check(double mid){
	double res = 0;
	for(int i = 1; i <= n; ++ i)
		if(a[i] - mid * b[i] > 0) s += a[i] - mid * b[i];
	return s > 0;
}
double solve(){
	double l = 0, r = 1e9;
	while(l + eps < r){
		double mid = (l + r) / 2;
		if(check(mid)) l = mid; else r = mid;
	}
	return l;
}
```

------------

## 前置：树形依赖背包

### $O(n^2m)$ 解

状态 $F[x,t]$：在以 $x$ 为根的子树中选 $t$ 个物品的最大收益。

技巧：如有多个节点为根，新建超级根 $0$。

转移方程：$F[x,t]=\max\limits_{\sum_{i=1}^p~c_i=t-1} \bigg\{\displaystyle\sum\limits_{i=1}^pF[y_i,c_i]\bigg\}+Wei_x$

```cpp
const int N = 310;
int n, m, Wei[N], dp[N][N];//总物品数、选择物品数、物品重量、DP数组
vector<int> Edge[N];//图
void dfs(int x){
	dp[x][0] = 0;
	for(int i = 0; i < Edge[x].size(); ++ i){
		int y = Edge[x][i];
		dfs(y);
		for(int t = m; t >= 0; -- t)//当前背包体积
			for(int j = 0; j <= t; ++ j)//组内物品
				dp[x][t] = max(dp[x][t], dp[x][t-j] + dp[y][j]);
	}
	if(x)//超级根 0 不用占物品数
		for(int t = m; t > 0; -- t)
			dp[x][t] = dp[x][t-1] + Wei[x];
	return ;
}
```

### $O(n+nm)$ 解

把节点重新编号，使得每棵子树的编号最大的节点为它的根。使用后序遍历解决。

```cpp
void dfs(int x){
	siz[x] = 1;
	for(int i = 0; i < g[x].size(); ++ i){
		int y = g[x][i]; dfs(y);
		siz[x] += siz[y];
	}
	pos[++cnt] = x;//pos[x]为新编号 x 的节点在原来的编号
}
```

然后按着编号顺序 dp 即可。dp 到一个节点，其子节点已经都被 dp 过了。

```cpp
for(int i = 1; i <= cnt; ++ i)
		for(int j = 1; j <= k; ++ j)
			f[i][j] = max(f[i-1][j-1]+val[pos[i]], f[i-siz[pos[i]]][j]);
```

------------

## 正文

### JSOI2016]最佳团体

> 给你一棵树，每个节点有 $a_i,b_i$，选择 $k$ 个节点使得 $\displaystyle\frac{\sum_{i=1}^k a_i}{\sum_{i=1}^k b_i}$ 最大化。要求此 $k$ 个节点组成一棵树，且根节点为 $0$，边方向与原树相同。
>
> $1\leq n,k \leq 2500$

转化为 01 分数规划。令 $a_i-mid\times b_i$ 为每个点权值，跑树形背包即可。

这里可以使用预处理时间戳的树形背包，复杂度做到 $O(nk\log val)$。

```cpp
const int N = 2510;
int k, n, siz[N], pos[N], cnt;
double f[N][N], val[N];
pair<int, int> p[N];
vector<int> g[N]; 

void dfs(int x){
	siz[x] = 1;
	for(int i = 0; i < g[x].size(); ++ i){
		int y = g[x][i]; dfs(y);
		siz[x] += siz[y];
	}
	pos[cnt] = x;
}
bool check(double mid){
	for(int i = 0; i <= cnt; ++ i)
		for(int j = 1; j <= k; ++ j) f[i][j] = -1e9;
	for(int i = 1; i <= n; ++ i)
		val[i] = (double) p[i].first - mid * p[i].second;
	for(int i = 1; i <= cnt; ++ i)
		for(int j = 1; j <= k; ++ j)
			f[i][j] = max(f[i-1][j-1]+val[pos[i]], f[i-siz[pos[i]]][j]);
	return f[cnt][k] > 0;//用cnt，不能用n（因为n不包括节点0）
}
double solve(){
	dfs(0); ++ k;
	double l = 0, r = 1e5;
	while(l + 1e-5 <= r){
		double mid = (l + r) / 2;
		if(check(mid)) l = mid; else r = mid;
	}
	return l;
}
```



---

## 作者：jpwang (赞：17)

居然没人写题解?!
看到分数的形式容易想到二分答案变成判定性问题
若$mid<\frac{\sum a_i}{\sum b_i}$，等价于$\sum a_i-mid\sum b_i>0$，此时mid小于所求的答案

那么可以把mid套进柿子里做树形dp求最大值，设f[i,j]表示以i为根的子树中选了j个的最大贡献，转移的时候强制让i选自己转移就能保证所选结果是合法的（具体可以看代码）

需要注意数组的大小，开太大容易T
#Code
---
```cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>
#define rep(i,st,ed) for (int i=st;i<=ed;++i)
#define fill(x,t) memset(x,t,sizeof(x))

const double EPS=1e-4;
const int N=2505;
const int E=5005;

struct edge {int x,y,next;} e[E];

double f[N][N],tmp[N],v[N];
int size[N],a[N],b[N];
int ls[N],edCnt;

void add_edge(int x,int y) {
	e[++edCnt]=(edge) {x,y,ls[x]}; ls[x]=edCnt;
	e[++edCnt]=(edge) {y,x,ls[y]}; ls[y]=edCnt;
}

void dfs(int now,int fa) {
	size[now]=1; f[now][0]=0; f[now][1]=v[now];
	for (int i=ls[now];i;i=e[i].next) {
		if (e[i].y==fa) continue;
		dfs(e[i].y,now);
		rep(j,1,size[now]+size[e[i].y]) tmp[j]=f[0][N-1];
		rep(j,1,size[now]) rep(k,0,size[e[i].y]) {
			tmp[j+k]=std:: max(tmp[j+k],f[now][j]+f[e[i].y][k]);
		}
		size[now]+=size[e[i].y];
		rep(j,1,size[now]) f[now][j]=tmp[j];
	}
}

int main(void) {
	int n,m; scanf("%d%d",&m,&n);
	rep(i,1,n) {
		int fa; scanf("%d%d%d",&b[i],&a[i],&fa);
		add_edge(fa,i);
	}
	double l,r;
	for (l=0,r=10000;r-l>=EPS;) {
		double mid=(l+r)*0.5;
		fill(f,0xc2);
		rep(i,1,n) v[i]=(double)a[i]-mid*(double)b[i];
		dfs(0,0);
		if (f[0][m+1]>0) l=mid;
		else r=mid;
	}
	printf("%.3lf\n", l);
	return 0;
}
```

---

## 作者：Great_Influence (赞：10)

提供一种比较简单的dp方式。

首先，问题所求的明显是一种带除法最优化问题，可以利用分数规划规避除法。那么就剩下了树形依赖背包了。

明显可以直接在树上做背包，暴力是$O(n^3)$的。接下来可以考虑在树上优化，或者转成$dfs$序列并在上面$dp$。

具体来说，转移有:

$Chkmax(dp[i+1][j+1],dp[i][j])$

$Chkmax(dp[nx[i]][j],dp[i][j])$

其中$nx[i]$表示下一棵子树的$dfn$，$Chkmax(a,b)$表示$a=a>b?a:b$。

这样就是$O(n^2)$的了。加上分数规划，总时间复杂度为$O(n^2log ans)$。

代码:

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define For(i,a,b) for(i=(a),i<=(b);++i)
#define Forward(i,a,b) for(i=(a),i>=(b);--i)
#define Chkmax(a,b) a=a>b?a:b
template<typename T>inline void read(T &x)
{
	T f=1;x=0;char c;
	for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=x*10+(c^48);
	x*=f;
}
using namespace std;
void file()
{
#ifndef ONLINE_JUDGE
	freopen("luogu4322.in","r",stdin);
	freopen("luogu4322.out","w",stdout);
#endif
}

const int MAXN=2517;

static int n,m,s[MAXN],p[MAXN];

static vector<int>ed[MAXN];

inline void init()
{
	read(m);read(n);++n;
	static int x;
	Rep(i,2,n)read(s[i]),read(p[i]),read(x),++x,ed[x].push_back(i);
}

static double dp[MAXN][MAXN],w[MAXN];

const double eps=1e-5;

static int dfn[MAXN],nx[MAXN],e=0;

void dfs(int u){dfn[u]=++e;for(int v:ed[u])dfs(v);nx[dfn[u]]=e+1;}

inline bool Judge(double num)
{
	Rep(i,2,n)w[dfn[i]]=1.*p[i]-num*s[i];
	w[0]=0;
	Rep(i,2,n+1)Rep(j,0,m+1)dp[i][j]=-1e12;
	Rep(i,1,n)
	{
		Rep(j,0,m+1)if(dp[i][j]>-1e9)
		{
			Chkmax(dp[i+1][j+1],(dp[i][j]+w[i]));
			Chkmax(dp[nx[i]][j],dp[i][j]);
		}
	}
	return dp[n+1][m+1]>1e-5;
}

inline void solve()
{
	Rep(i,1,m+1)dp[1][i]=-1e12;dp[1][0]=0;
	dfs(1);
	static double l=0.0,r=1e5,mid;
	while(r-l>eps)
	{
		mid=(l+r)/2;
		if(Judge(mid))l=mid;
		else r=mid;
	}
	printf("%.3lf\n",l);
}

int main()
{
	file();
	init();
	solve();
	return 0;
}
```

---

## 作者：Jμdge (赞：8)

本题将要采用树形背包、二分等~~duliu~~操作

干说也说不清楚,主要就是管好dp的神奇转移,详情见代码

```cpp
#include<cstdio>
#define eps 1e-5
#define db double
#define rint register int
#define min(a,b) ((a)<(b)?(a):(b)) 
using namespace std;
const int M=2520;
const int inf=1e18;
int m,n,pat,tim;
db s[M],p[M],d[M],dp[M][M];
int f[M],head[M],dfn[M],las[M];  //f [i] 指向 i 的父亲 , dfn [i] 表示节点 i 的入度时间戳 , las [i] 表示入度时间戳为 i 的节点的出度时间戳 
struct Edge{ int to,next; }e[M<<1];
void add(rint u,rint v) { e[++pat]=(Edge){v,head[u]},head[u]=pat; }
void dfs(rint u) {
	dfn[u]=tim++;  //tim++ 使得 las[dfn[u]] 指向的是下一个节点的入度时间戳 
	for(rint i=head[u]; i; i=e[i].next)
		dfs(e[i].to);
	las[dfn[u]]=tim;
}
inline db check(db mid){
	for(rint i=1; i<=n; ++i)  //计算每个节点的(时间戳形态的)权值 
		d[dfn[i]]=p[i]-mid*s[i];
	for(rint i=1; i<=n+1; ++i)  //除节点 0 以外的节点全部赋 -inf 
		for(rint j=0; j<=m+1; ++j)
			dp[i][j]=-inf;
	for(rint i=0; i<=n; i++)  //枚举时间戳为 i 的节点 
		for(rint j=0; j<=min(i,m+1); ++j) {  //枚举选择的人数 j  
			if(dp[i][j]+d[i]>dp[i+1][j+1]) dp[i+1][j+1]=dp[i][j]+d[i]; //更优状态的转移(可能赋给子树内的节点也可能赋值给紧跟着的一棵子树的节点) 
			if(dp[i][j]>dp[las[i]][j]) dp[las[i]][j]=dp[i][j]; //las[i] 指向节点 i 后的不包含于 i 的子树内的节点 
		}
	return dp[n+1][m+1];
}
int main() {
	scanf("%d%d",&m,&n);
	for(rint i=1; i<=n; i++)
		scanf("%lf%lf%d",s+i,p+i,f+i),add(f[i],i);
	dfs(0);  //深搜建树 
	db l=0.0,r=10000.0;
	while(l+eps<=r) {  //二分答案 
		db mid=(l+r)/2.0;
		if(check(mid)>=eps) l=mid;
		else r=mid;
	}
	printf("%.3lf\n",l);
	return 0;
}
```

---

## 作者：小又又 (赞：7)

**首先是一些想法：**

1. 首先看到了平均值，肯定会出现分数，我们想到了分数规划

1. 由于我们无法直接从一个状态的最大平均值直接推出另一个状态的平均值，所以我们不能直接dp，想到二分转化问题

#### solution

假设最后的答案是$mid$，那么我选中的$k$个物品一定满足$\dfrac{\sum\limits_{i=1}^k p_i}{\sum\limits_{i=1}^k s_i}\geq mid$

式子变形为：$\sum\limits_{i=1}^k (p_i-mid\times s_i)\geq 0$，显然这是个存在性命题，只需要最大值满足这个式子就可以了

求上面这个式子的最大值就可以dp求了：把$p_i-mid\times s_i$看作是价值，求一个树上背包

状态设计：$dp_{i,j}$表示选第$i$个物品，在以$i$为根的子树里选$j$个物品的最大价值，因为不选$i$，子树也不能选，价值为0无意义

状态转移方程：$dp_{i,j} = max(dp_{i,j},dp_{to,j-k}+dp_{x,k})$，枚举$n$个点,$m$个物品，$m$个断点，复杂度$O(n^2m)$,不太行的样子

#### 优化

还有一种$nm$树上背包的东西，我们把点重新编号，使根节点为子树中编号最大的点

状态设计：$dp_{i,j}$表示在前$i$个点里选$j$个点的最大价值

状态转移方程：$dp_{i,j} = max(dp_{i-1,j-1}+val_{pos_i},dp_{i-siz[pos[i]],j})$

#### code
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>
using namespace std;
int read(){
	int x = 1,a = 0;char ch = getchar();
	while (ch < '0'||ch > '9'){if (ch == '-') x = -1;ch = getchar();}
	while (ch >= '0'&&ch <= '9'){a = a*10+ch-'0';ch = getchar();}
	return x*a;
}
const int maxn = 3000,inf = 1e9+7;
int n,k;
struct node{
	int to,nxt;
}ed[maxn];
int head[maxn],tot;
void add(int u,int to){
	ed[++tot].to = to;
	ed[tot].nxt = head[u];
	head[u] = tot;
}
int siz[maxn],dfn[maxn],pos[maxn],cnt;
void dfs(int x){
	siz[x] = 1;
	for (int i = head[x];i;i = ed[i].nxt){
		int to = ed[i].to;
		dfs(to);
		siz[x] += siz[to];
	}
	dfn[x] = ++cnt,pos[cnt] = x;
}
double val[maxn],f[maxn][maxn];
int p[maxn],s[maxn];
bool check(double x){
	for (int i = 0;i <= cnt;i++)
		for (int j = 1;j <= k;j++)
			f[i][j]=-inf;
	for (int i = 1;i <= n;i++)
		val[i] = (double)p[i]-x*s[i];
	for (int i = 1;i <= cnt;i++){
		for (int j = 1;j <= k;j++){
			f[i][j] = max(f[i-1][j-1]+val[pos[i]],f[i-siz[pos[i]]][j]);
		}
	}
	return f[cnt][k]>0;
}
int main(){
	k = read()+1,n = read();
	for (int i = 1;i <= n;i++){
		s[i] = read(),p[i] = read();
		int x = read();
		add(x,i);
	} 
	dfs(0);
	double l = 0,r = 100000,eps = 1e-4;
	while (r-l >= eps){
		double mid=(l+r)/2;
		if (check(mid)) l=mid;
		else r=mid;
	}
	printf("%.3lf\n",l);
	return 0;
}
```


---

## 作者：chenxia25 (赞：5)

考虑二分 $x$，那么就是看是否有包含 $0$ 的大小为 $m+1$ 的连通块的 $p-xs$ 和为正。

这个有一个很自然的 DP：$dp_{i,j}$ 表示子树 $i$ 内选 $j$ 个的最大和。然后对于每个点扫描一下儿子，对每个儿子用类似卷积和背包的方式更新一下 DP 数组。这玩意被某沙雕称为「树的卷积」，和 SAO 那题一样，复杂度是平方的。

![](https://s3.ax1x.com/2021/02/02/ymODeg.png)

去年某天晚上绞劲脑汁，最终终于归纳证出来了这玩意的复杂度。现在一看，这 tm 不随便证？第二眼，哦，假了。只是不知道为啥所有人 & 题解都认为这个平方复杂度非常自然？希望神仙们在评论区解释一下。

那么总复杂度就是平方对数。

---

## 作者：Guess00 (赞：3)

### 思路$:$二分$+$树形$\text{DP}$

二分枚举答案，$check$比较$mid<\dfrac{\sum p_i}{\sum s_i},$将式子变成$\sum(p_i-mid*s_i)>0$。

令$v_i=p_i-mid*s_i,$于是就要求$\sum v_i$的最大值。

令$f_{i,j}$表示以$i$为根的子树中选$j$个点和最大。

二分前先预处理dfs序和子树大小$size_i$(dp中要用)。

因为要让$f_{i,j},$就是让$f_{son_i,j-1}+v_i$最大，就要找$i$的孩子中少选一个点的最大值。但明显对于每一个点枚举孩子肯定会超时，所以要用一些方法改进状态转移。

状态转移$:f_{i,j}=\max(f_{i,j},f_{i+1,j-1}+v_i)\quad$①

$\qquad\quad\;\;\; f_{i,j}=\max(f_{i,j},f_{i+size_{dfn_i},j-1}+v_i)\quad$②

$\qquad\quad\;\;\; f_{i,j}=\max(f_{i,j},f_{i+size_{dfn_i},j})\quad$③

$\qquad\quad\;\;\;(i$从叶子到树根枚举dfs序，从大到小$)$

①式是从自己的第一个孩子中获得值；②式是选自己但没有选自己的孩子，剩下$j-1$个从自己的兄弟处选；③式是在选$j$个的情况下比较自己和自己的兄弟，这样最大值就可以传到父亲的第一个孩子，确保①式中父亲只从第一个孩子中取值能取到最大值。

$\mathbb{CODE:}$
```cpp
#include <bits/stdc++.h>
using std::vector;
const int MAXN=2505;
const double eps=1e-4;
const int inf=0x3f3f3f3f;
int n,k,i,j,x,cnt,s[MAXN],p[MAXN],dfn[MAXN],size[MAXN];
double v[MAXN],f[MAXN][MAXN];
vector<int> G[MAXN];
inline double max(double x,double y){return x>y?x:y;}
inline void read(int &x)    //快读
{
	short negative=1;
    x=0;
    char c=getchar();
    while(c<'0' || c>'9')
    {
    	if(c=='-')
			negative=-1;
		c=getchar();
	}
    while(c>='0' && c<='9')
        x=(x<<3)+(x<<1)+(c^48),c=getchar();
    x*=negative;
}
inline void dfs(int u,int f)
{
	dfn[++cnt]=u;
	size[u]=1;
	for (int i=0;i<G[u].size();i++)
	{
		int v=G[u][i];
		if (v==f)
			continue;
		dfs(v,u);
		size[u]+=size[v];
	}
}
inline bool check(double x)
{
	for (i=1;i<=n+2;i++)
		for (j=1;j<=k+1;j++)
			f[i][j]=-inf;
	for (i=1;i<=n;i++)
		v[i]=(double)p[i]-x*s[i];
	for (i=n+1;i>=1;i--)   //dp
		for (j=1;j<=k+1;j++)
		{
			f[i][j]=max(f[i][j],f[i+1][j-1]+v[dfn[i]]);
			f[i][j]=max(f[i][j],f[i+size[dfn[i]]][j-1]+v[dfn[i]]);
			f[i][j]=max(f[i][j],f[i+size[dfn[i]]][j]);
		}
	return f[1][k+1]>0;
}
signed main(void)
{
	read(k),read(n);
	for (i=1;i<=n;i++)
	{
		read(s[i]),read(p[i]),read(x);
		G[x].push_back(i);
		G[i].push_back(x);   //邻接向量存图 
	}
	dfs(0,0);    //dfs计算dfs序和子树大小 
	double l=0,r=1e+8,mid;
	while (r-l>eps)   //二分 
	{
		mid=(l+r)/2;
		if (check(mid))
			l=mid;
		else
			r=mid;
	}
	printf("%.3lf",l);
	return 0;
}
```

---

## 作者：小元勋 (赞：3)


## 简化题意：

- 给定一棵$n$个点的树，每个点有一个$P_{i}$和$S_{i}$

- 需要选出$k$个点，如果$u$被选中，那么$u$的$fa$也必须得选

- 最大化$\frac{\sum{P_{i}}}{\sum{S_{i}}}$，$k,n<=2500$

## 分析：
- 要使$\frac{\sum{P_{i}}}{\sum{S_{i}}}$最大，是分数规划。我们二分一个$mid$,那么：

$$\frac{\sum{P_{i}}}{\sum{S_{i}}}>=mid$$


真正的最大值大于等于$mid$，移项

$$\sum{(P_{i}-S_{i}*mid)}>=0$$

贪心的选择使$\sum{(P_{i}-S_{i}*mid)}$最大，如果大于等于$0$，$l=mid$，否则$r=mid$

- 考虑如何求得最大的$\sum{(P_{i}-S_{i}*mid)}?$

- 每次二分之后，每个点的点权相当于变成了$P_{u}-S_{u}*mid$

- 定义$f[u][i][0/1]$表示在以$u$为根的紫薯中,选$i$个点，$u$号根节点选或不选的最大点权和

- 边界：
$f[u][i][0/1]=-INF,f[u][0][0]=0,f[u][1][1]=w[u]$

- 状态转移：

$$f[u][i][0]=max(f[u][i][0],f[u][i-j][0]+f[v][j][0])$$

$$f[u][i][1]=max(f[u][i][1],f[u][i-j][1]+max(f[v][j][0],f[v][j][1]))$$

- 最后看$f[0][k+1][0/1]$是否大于等于$0$,注意是$k+1$。相信聪明的读者知道这一点。

- 时间复杂度$O(n^{2}log(r))$

## Code:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 2550
#define eps 1e-4
#define INF 1000000000

int sze[maxn],m,n,cnt = 0,head[maxn];
double w[maxn],f[maxn][maxn][3];
struct node {
	int s,p;
}a[maxn];
struct edge {
	int v,nxt;
}e[maxn];

inline int read_() {
	int x_=0,f_=1;char c_=getchar();
	while(c_<'0'||c_>'9') {if(c_=='-') f_=-1;c_=getchar();}
	while(c_>='0'&&c_<='9') {x_=(x_<<1)+(x_<<3)+c_-'0';c_=getchar();}
	return x_*f_;
}

inline void add_(int u,int v) {
	e[++cnt].v = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}

void dfs_(int u,int fa) {
	f[u][0][0] = 0;
	f[u][1][1] = w[u];
	sze[u] = 1;
	int AKIOI,AKNOI;
	for(int i=head[u];~i;i=e[i].nxt) {
		int v = e[i].v;
		dfs_(v,u);
		sze[u] += sze[v];
		AKIOI = min(m+1,sze[u]);
		for(int j=AKIOI;j>=1;--j) {
			AKNOI = min(j,sze[v]);
			for(int k=1;k<=AKNOI;++k) {
				f[u][j][1] = max(f[u][j][1],f[u][j-k][1]+max(f[v][k][0],f[v][k][1]));
				f[u][j][0] = max(f[u][j][0],f[u][j-k][0]+f[v][k][0]);
			}
		}
 	}
}

inline bool work_(double x) {
	for(int i=1;i<=n;++i) {
		w[i] = (double) a[i].p - (double) a[i].s * x;
	}
	for(int i=0;i<=n;++i) {
		for(int j=0;j<=n;++j) {
			f[i][j][0] = f[i][j][1] = -INF;
		}
	} 
	dfs_(0,-1);
	if(f[0][m+1][0]>=0||f[0][m+1][1]>=0) return true;
	return false;
}

void readda_() {
	memset(head,-1,sizeof(head));
	m = read_();n = read_();	
	int x;double r = 10000;
	for(int i=1;i<=n;++i) {
		a[i].s = read_();
		a[i].p = read_();
		x = read_();
		add_(x,i);
	}
	double l = 0,mid;
	while(r-l>eps) {
		mid = (l+r) / 2;
		if(work_(mid)) l = mid;
		else r = mid;
	} 
	printf("%.3lf",l);
}

int main() {
//	freopen("a.txt","r",stdin);
	readda_();
	return 0;
}
```


---

## 作者：Flash_Man (赞：2)

# P4322 最佳团体

## 解题思路

可以看出人的依赖关系构成一棵树。此题求的是一个分数的最值，很容易想到分数规划。

记最优方案选取的点构成的集合为 $A$，对于一个可行的答案 $\rm ans$（不一定最优），一定满足：
$$
\mathrm{ans}\le \frac{\sum_{i\in A}P_i}{\sum_{i\in A}S_i}
$$
稍微变形一下，可以得到：
$$
\sum_{i\in A}(P_i-\mathrm{ans}\times S_i)\ge0
$$
二分 $\mathrm{ans}$ 的值，把节点 $i$ 的权值设置为 $P_i-\mathrm{ans}\times S_i$，再用树形 DP 判断 $\mathrm{ans}$ 的可行性即可。注意要用类似树形背包的方法转移，这样每次树形 DP 的复杂度就是 $\Theta(n^2)$ 的。

## 代码

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>

using std::vector;
using std::max;

const double eps = 1e-4;
const double inf = 1e9;
const int maxn = 2500 + 10;

int n, k;
int w[maxn], v[maxn];

vector<int> son[maxn];
int siz[maxn];
int cnt = 0, dfn[maxn];
double val[maxn];
double f[maxn][maxn];
double l = 0, r = 0;

inline void dfs(int u) {
    siz[u] = 1;
    if (u)
        dfn[++cnt] = u;
    for (int v : son[u]) {
        dfs(v);
        siz[u] += siz[v];
    }
}

int main() {
    scanf("%d%d", &k, &n);
    for (int i = 1; i <= n; i++) {
        int fa;
        scanf("%d%d%d", &w[i], &v[i], &fa);
        son[fa].push_back(i);
        r = max(r, 1.0 * v[i] / w[i]);
    }
    dfs(0);
    while (r - l > eps) {
        double mid = (l + r) / 2.0;
        for (int i = 1; i <= n; i++)
            val[i] = 1.0 * v[i] - mid * w[i];
        for (int i = 1; i <= n + 1; i++)
            for (int j = 1; j <= k; j++)
                f[i][j] = -inf;
        for (int i = n; i >= 1; i--)
            for (int j = 1; j <= k; j++)
                f[i][j] = max(f[i + 1][j - 1] + val[dfn[i]], f[i + siz[dfn[i]]][j]);
        if (f[1][k] >= 0)
            l = mid;
        else
            r = mid;
    }
    printf("%.3lf", l);
    return 0;
}
```

---

## 作者：Find_Yourself (赞：2)

[P4322 [JSOI2016]最佳团体](https://www.luogu.com.cn/problem/P4322)

分数规划+树形背包。

可以根据推荐关系建出一颗树，然后如果选了一点，则该点到根上的所有点都必须选。

二分 $mid$，定义每个结点的权值，然后判断选 $k+1$ 个节点的最大值是否大于 $0$。

设 $f_{i,j}$ 为当前节点 $i$，在其子树内选了 $j$ 个节点，最大点权和为多少。

转移方程为 $f_{u,j}=\max(f_{u,j},f_{u,j-t}+f_{v,t})$。

初始化为 $f_{u,0}=0$，$f_{u,1}=val_u$，其余皆为 $-inf$。

然后我们发现这个 DP 的复杂度貌似是 $O(n^3)$。

但将各种限制条件加上后就变成了 $O(n^2)$。本人很菜，没法证明。

所以最终复杂度为 $O(n^2 \log n)$。

#### code:

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef double db;
const int N = 2500 + 5;
const db eps = 1e-5, inf = LLONG_MAX >> 1;
int k, n, fa[N], siz[N];
db s[N], p[N], val[N], f[N][N];
vector<int> adj[N];
void dfs(int u) {
	siz[u] = 1; f[u][1] = val[u];
	for (int i = 0; i < adj[u].size(); ++i) {
		int v = adj[u][i]; if (v == fa[u]) continue;
		dfs(v); siz[u] += siz[v];
		for (int j = min(k + 1, siz[u]); j > 1; --j) {
			for (int k = 0; k <= min(siz[v], j - 1); ++k) {
				f[u][j] = max(f[u][j], f[u][j - k] + f[v][k]);
			}
		}
	}
}
bool check(db mid) {
	for (int i = 0; i <= n; ++i) val[i] = p[i] - mid * s[i];
	for (int i = 0; i <= n; ++i) for (int j = 1; j <= k + 1; ++j) f[i][j] = -inf;
	dfs(0);
	return f[0][k + 1] > 0; 
}
int main() {
	cin >> k >> n;
	for (int i = 1; i <= n; ++i) {
		scanf("%lf%lf%d", &s[i], &p[i], &fa[i]);
		adj[fa[i]].push_back(i);
	}
	double l = 0, r = 1000;
	while (r - l > eps) {
		db mid = (l + r) / 2;
		if (check(mid)) l = mid;
		else r = mid;
	}
	printf("%.3lf\n", l);
	return 0;
}
```


---

## 作者：derta (赞：1)

## 引子：序列上的 01 分数规划

> 给定两个序列 $p_1,p_2,\cdots,p_n$，$q_1,q_2,\cdots,q_n$。试求
> $$\frac{\sum_{i=1}^{n}a_ip_i}{\sum_{i=1}^{n}a_iq_i}$$
> 的最大值，要求有 $k$ 个 $a_i$ 为 $1$，其余都为 $0$。

设

$$\max\left\{\frac{\sum_{i=1}^{n}a_ip_i}{\sum_{i=1}^{n}a_iq_i}\right\} \leq r$$

那么有

$$\max\left\{\sum_{i=1}^{n}a_i(p_i-rq_i)\right\} \leq 0$$

这显然能 $O(n \log n)$ 判定，二分找最小 $r$ 即可。

## 正题

同理地，本题也可以二分 $r$，对于每个 $r$，令点 $i$ 的权值 $w_i=P_i-rS_i$，就将问题转化为了有依赖性的背包问题。

下文约定 $\text{size}(i)$ 表示以 $i$ 为根的子树的大小，$\text{son}(i,j)$ 表示 $i$ 的第 $j$ 个孩子，$\text{soncnt}(i)$ 表示 $i$ 的孩子个数。

设 $f_{i,j,k}$ 为 $i$ 的子树中只考虑前 $j$ 个孩子时恰选 $k$ 个人（包含 $i$）的最大权值和，那么

$$f_{i,j,k}=\max_{0\leqslant t\leqslant k-1}\{f_{\text{son}(i,j),\text{soncnt}(\text{son}(i,j)),t}+f_{i,j-1,k-t}\}$$

边界：$f_{i,0,1}=w_i$，其余均为 $- \infty$。

不难发现这样时间复杂度是 $O(NK^2)$ 的。

考虑优化。容易发现有如下限制：

- $1 \leqslant j \leqslant\text{soncnt}(i)$。
- $1 < k \leqslant \min\left(\sum_{l=1}^{j}\text{size}(\text{son}(i,l)),K+1\right)$。
- $0 \leqslant t \leqslant \min(k-1,\text{size}(\text{son}(i,j)))$。

这看起来只能优化常数，但它事实上可以将时间复杂度降为 $O(NK)$。

设 $T(i)$ 为处理 $i$ 的子树的时间复杂度，$t(i)$ 为将 $T(\text{son}(i,l))$ 合并成 $T(i)$ 的时间复杂度。我们有：
$$
\begin{aligned}
T(i)&=t(i)+\sum_{j=1}^{\text{soncnt}(i)}T(\text{son}(i,j)) \\
t(i)&=\sum_{j=1}^{\text{soncnt}(i)}\ \ \sum_{k=1}^{\min\left(K+1,\sum_{l=1}^{j}\text{size}(\text{son}(i,l))\right)}\min(k-1,\text{size}(\text{son}(i,j))) \\
&\leq \sum_{j=1}^{\text{soncnt}(i)}\ \ \sum_{k=1}^{K+1}\text{size}(\text{son}(i,j)) \\
&=(K+1)\sum_{j=1}^{\text{soncnt}(i)}\text{size}(\text{son}(i,j)) \\
&=O(K\cdot\text{size}(i))
\end{aligned}
$$
对 $i$ 使用数学归纳法。
- 若 $i$ 是叶子节点，显然有 $T(i)=1=O(K \cdot \text{size}(i))$。
- 反之
   - 假设 $i$ 的所有孩子 $l$ 均满足 $T(l)=O(K\cdot\text{size}(l))$
   - 则
     $$
     \begin{aligned}
     T(i)&=t(i)+\sum_{j=1}^{\text{soncnt}(i)}T(\text{son}(i,j)) \\
     &=O(K\cdot \text{size}(i))+\sum_{j=1}^{\text{soncnt}(i)}O(K\cdot\text{size}(\text{son}(i,j))) \\
     &=O(K\cdot\text{size}(i))
     \end{aligned}
     $$
故优化后的树形背包时间复杂度为 $O(NK)$。

倒序枚举 $k$，就能滚掉第二维了，空间复杂度 $O(NK)$，时间复杂度 $O(NK \log \textit{ans})$。

```cpp
/*
max{sum(atk)/sum(cost)} <= k
max{sum(atk - cost*k)} <= 0
二分找最小k
*/
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstring>
#include <cstdlib>
typedef long long LL;
const int MAXN = 2505;
std::vector<int> G[MAXN];
LL f[MAXN][MAXN], w[MAXN];
int n, k, size[MAXN], atk[MAXN], cost[MAXN];

void DP(int x) {
	size[x] = 1;
	f[x][1] = w[x];
	for(int i = 0; i < (int)G[x].size(); ++i) {
		int v = G[x][i];
		DP(v);
		size[x] += size[v];
		for(int i = size[x] - size[v] + 1; i <= size[x]; ++i)
			f[x][i] = -1145141919810LL;
		for(int j = std::min(k + 1, size[x]); j > 1; --j)
			for(int k = 0; k <= std::min(size[v], j - 1); ++k)
				f[x][j] = std::max(f[x][j], f[v][k] + f[x][j - k]);
	}
}

bool check(int x) {
	for(int i = 1; i <= n; ++i)
		w[i] = 10000LL*atk[i] - 1LL*x*cost[i];
	DP(0);
	if(f[0][k + 1] == 0) {
		printf("%.3lf", x/10000.0);
		exit(0);
	}
	if(f[0][k + 1] <= 0)
		return true;
	return false;
}

int main() {
	scanf("%d%d", &k, &n);
	for(int i = 1; i <= n; ++i) {
		int r;
		scanf("%d%d%d", &cost[i], &atk[i], &r);
		G[r].push_back(i);
	}
	int l = 0, r = 100000000;
	while(l <= r) {
		int mid = (l + r) >> 1;
		if(check(mid))
			r = mid - 1;
		else
			l = mid + 1;
	}
	printf("%.3lf", (r + 0.0005)/10000.0); // 注意这里，答案在 (r,l) 中（在 check 中排除了答案为 l 的情况）
	return 0;
}
```

---

## 作者：破忆 (赞：1)

## 【题意】

$n$ 个点构成一片森林，每个点有属性 $P_i,S_i$，从中选出 $k$ 个点，若选某个点则必选其父节点，求 $\max \frac{\sum P_i}{\sum S_i}$。

## 【分析】

很明显要用**分数规划**确定答案并判断可行性。

$\frac{\sum P_i}{\sum S_i}\geqslant C \iff \sum(P_i-S_i\cdot C) \geqslant 0$。

二分答案 $C$，将 $P_i-S_i\cdot C$ 作为 $i$ 的价值进行判断。

判断是否可行，跑树上背包即可。

$f_{x,i}$ 表示以 $x$ 为根的子树的最大收益。

$f_{x,i}=\max(f_{y,t}+f_{x,i-t})$。

因为选子必选父，所以初值和循环的起终点要对 $f_{x,1}$ 特别处理。

## 【算法】

分数规划+树形DP

## 【代码】

```cpp
#include<bits/stdc++.h>
#define DB double
using namespace std;
const int maxn=2505,maxe=maxn*2;
const DB eps=1e-6,INF=1e18;
int n,k;
DB S[maxn],P[maxn];
DB f[maxn][maxn];
struct edge{
	int to,nxt;
}e[maxn];
int tot,lnk[maxn];
void add_e(int x,int y){
	e[++tot]=(edge){y,lnk[x]};
	lnk[x]=tot;
}
char gc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
#define getchar gc
int read(){
    int ret=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
    while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
    return ret*f;
}
int siz[maxn];
void DFS0(int x){
	siz[x]=1;
	for(int j=lnk[x];j;j=e[j].nxt){
		int y=e[j].to;
		DFS0(y);
		siz[x]+=siz[y];
	}
}
void DFS(int x,DB w){
	f[x][0]=0;
	for(int i=1;i<=k;i++) f[x][i]=-INF;
	f[x][1]=P[x]-S[x]*w;
	for(int j=lnk[x];j;j=e[j].nxt){
		int y=e[j].to;
		DFS(y,w);
		for(int i=min(k,siz[x]);i>=2;i--)
		for(int t=1,et=min(i-1,siz[y]);t<=et;t++) f[x][i]=max(f[x][i],f[x][i-t]+f[y][t]);
	}
}
bool check(DB w){
	f[0][0]=0;
	for(int i=1;i<=k;i++) f[0][i]=-INF;
	for(int j=lnk[0];j;j=e[j].nxt){
		int y=e[j].to;
		DFS(y,w);
		for(int i=min(k,siz[0]);i;i--)
		for(int t=1,et=min(i,siz[y]);t<=et;t++) f[0][i]=max(f[0][i],f[0][i-t]+f[y][t]);
	}
	return f[0][k]>=0;
}
int main(){
 	freopen("P4322.in","r",stdin);
 	freopen("P4322.out","w",stdout);
	k=read(),n=read();
	for(int i=1,f;i<=n;i++){
		S[i]=read(),P[i]=read();
		f=read(),add_e(f,i);
	}
	DFS0(0);
	DB L=0,R=1e4,mid;
	while(R-L>=eps){
		mid=(L+R)/2;
		if(check(mid)) L=mid;
		else R=mid;
	}
	printf("%.3lf\n",mid);
	return 0;
}
```


---

## 作者：jacky567 (赞：1)

题意就是选一个大小为$k$的连通块，使得这个连通块的总战斗值与总招募费用的比值最大

因为要求的是最大值，所以可以采用二分答案（**实数二分！实数二分！实数二分！**），所以只需要考虑如何检验这个性价比是否可达到

这个检验就是一个树形DP，我们用$f_{i,j}$表示根为i的子树中选$j$个人的相当于最高性价比减去二分的性价比的量（因为为了避免精度差，计算的不是两个数真正的差，而是01分数规划后的结果），递推的部分就是一个常规的树形DP的递推了

值得注意的是，最后的答案是$f_{0,k+1}$，不是$f_{0,k}$

附上代码：
```cpp
#include<algorithm>
#include<cstdio>
using namespace std;
int n,k,tot,s[2510],p[2510],r[2510],head[2510],nxt[2510],to[2510],size[2510];
double L,R=1e4,mid,eps=1e-5,f[2510][2510],F[2510];
void add(int x)
{
	nxt[++tot]=head[r[x]],head[r[x]]=tot,to[tot]=x;
}
void dfs(int x)
{
    size[x]=1,f[x][1]=p[x]-s[x]*mid;
    for(int i=head[x];i;i=nxt[i]){
        dfs(to[i]);
        for(int j=1;j<=size[x]+size[to[i]];j++) F[j]=-1e9;
        for(int j=1;j<=size[x];j++) for(int k=0;k<=size[to[i]];k++) F[j+k]=max(F[j+k],f[x][j]+f[to[i]][k]);
        for(int j=1;j<=size[x]+size[to[i]];j++) f[x][j]=F[j];
        size[x]+=size[to[i]];
    }
}
int pd()
{
    for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) f[i][j]=-1e9;
    dfs(0);
    return f[0][k+1]<=0;
}
int main()
{
    scanf("%d%d",&k,&n);
    for(int i=1;i<=n;i++) scanf("%d%d%d",&s[i],&p[i],&r[i]),add(i);
    while(L+eps<R){
        mid=(L+R)/2.0;
        if(pd()) R=mid;
        else L=mid+eps;
    }
    printf("%.3lf",L);
}
```

---

## 作者：CNF_Acceptance (赞：1)

思路：看到这种求一个比值的题，很容易能想到01分数规划（其实就是二分） $+$ 树上 $\mathrm{DP}$

题目要我们求的是 $\dfrac{\sum{p_i}}{\sum{s_i}}$ 的最大值

我们设 $mid$ 为正确答案，要使 $\dfrac{\sum{p_i}}{\sum{s_i}}$ 的值最大，则有：

$$\dfrac{\sum{p_i}}{\sum{s_i}} \leqslant mid$$

移项整合得到：
$$mid \cdot \sum{s_i}- \sum{p_i} \geqslant \mathrm{0}$$

用二分来求 $mid$ 的值，若 $check(mid)$ 成立，则 $l=mid$ 。

##### 但是如何做 $check$ ？

将题目转换成一棵树，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/4duhww4w.png)

对于每一个点 $i$ ，因为要求的是 $\dfrac{\sum{p_i}}{\sum{s_i}}$ ，所以将它的值 $d[i]$ 转换成 $p[i]-s[i] \times mid$ 。

再从 $0$ 号点开始用 $dfs$ 来 $DP$ 。

用 $dp[i][j]$ 表示在以 $i$ 为根的子树中选出 $j$ 个点的最大性价比，最终得出的结果为 $dp[0][k+1]$ （注意这里是 $k+1$ ，因为要加上 $0$ 号点）。

##### 那么状态转移方程是什么呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/kl8aii8g.png)

对于如图的一棵树，以结点 $2$ 为例，
想要求 $dp[2][j]$ ，它的值取决于它的子树 $4$，$5$，$6$ 的 $dp$ 的值。

所以 $2$ 的 $dp$ 值为它的每棵子树的一部分的性价比最大值，这 “一部分” 由枚举解决。

所以得出方程：

$$dp[u][j]=\max(dp[u][j],dp[v][k]+dp[u][j-k])$$

时间复杂度为 $O(n^2)$ 具体怎么算可以参考网上的博客。

代码如下：

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
using namespace std;
#define cmax(a,b) a=a>b?a:b
inline int read(){
	int x=0,f=1;
	char c=getchar();
	while(!isdigit(c)&&c!='-') c=getchar();
	if(c=='-') f=-1;
	while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*f;
}
const int N=2502;
struct edge{
	int to,next;
}e[N<<1];
const float ex=1e-4;
int tot,k,n,h[N],sz[N];
float dp[N][N],d[N],p[N],s[N];
inline void add(int x,int y){
	e[++tot]=(edge){y,h[x]};
	h[x]=tot;
}
void dfs(int x,int fa){
	sz[x]=1,dp[x][1]=d[x];
	for(register int i=h[x];i;i=e[i].next){
		int y=e[i].to;
		if(y==fa) continue;
		dfs(y,x);
		sz[x]+=sz[y];
		for(register int j=min(k+1,sz[x]);j;j--){
			int minn=min(j-1,sz[x]);
			for(register int z=1;z<=minn;z++){
				cmax(dp[x][j],dp[y][z]+dp[x][j-z]);
			}
		}
	}
}
inline bool check(float m){
	for(register int i=1;i<=n;i++){
		d[i]=p[i]-s[i]*m;
	}
	for(register int i=0;i<=n;i++){
		for(register int j=1;j<=k+1;j++){
			dp[i][j]=-2147483647;
		}
	}
	dfs(0,-1);
	return dp[0][k+1]>=0;
}
int main(){
	cin>>k>>n;
	float l=0,r=0;
	for(register int i=1;i<=n;i++){
		s[i]=read(),p[i]=read();
		cmax(r,p[i]); 
		add(read(),i);
	}
	while(r-l>ex){
		float mid=(l+r)/2;
		if(check(mid)){
			l=mid;
		}else{
			r=mid;
		}
	}
	printf("%.3f",l);
	return 0;
}
```


---

## 作者：luckydrawbox (赞：0)

[$\text{Link}$](https://www.luogu.com.cn/problem/P4322)

看到题解区里都是大片大片的树形 $\text{DP}$，这里给出一个不用琢磨复杂度是 $O(n^2)$ 还是 $O(n^3)$ 的 $\text{dfs}$ 序做法。

## 题意

给定一个 $n+1$ 个节点的以 $0$ 为根的树，树上的每个节点都有其价值 $P_i$ 和费用 $S_i$。在树上选择 $k+1$ 个节点，在满足任意一个节点如果被选择了，那么其父亲也一定要被选择的条件下，求性价比最高的一个选点方案。

## 分析

求性价比最高有一个经典套路：$01$ 分数规划，这部分其他题解讲的已经很清楚了，这篇题解讲着重讲解 $\text{check}$ 的部分，即如何选出 $k+1$ 个点使其点权和最大。

显然，选完 $k+1$ 个点后，选择的点就构成了另一棵树，而所有未选择的点构成了一片森林。选择的点构成的树的形态是变化多样的，而未选择的点构成的那些树却遵循原树的性质，正难则反，于是我们可以把问题转化为在符合题意的前提下从 $n+1$ 个点中剔除 $n-k$ 个节点，使剔除的点权和最小的情况下的点权和。

每次剔除点，我们剔除的连通块必然是一棵树，所以只要知道其根节点即可，考虑用 $\text{dfs}$ 序来转化问题，在 $\text{dfs}$ 进入某个节点的时候记录次该节点，退出时也记录一次，将两次的 $\text{dfs}$ 序分别记为 $st_x,ed_x$，这样一个节点对应的区间就是以该节点为根的子树，同时可以发现，剔除的两棵子树所对应的区间是没有相交部分的，因此树上的问题就可以转化为序列上的选择区间问题。

设 $sz_i$ 表示以节点 $i$ 为根的子树的大小， $re_i$ 表示 $ed_x=i$ 的节点的编号，若不存在则为 $0$，再设 $f_{u,j}$ 表示最后一次剔除的子树根节点为 $u$，总共剔除了 $j$ 个节点的最小点权和，那么有：

$$f_{u,j}=\min_{ed_v< st_{u}}\{f_{v,j-sz_u}\}+\frac{1}{2}\sum_{i=st_u}^{ed_u}w_{re_i}$$

转移是按照 $ed_u$ 从小到大转移的，$w_i$ 那部分可以直接用前缀和处理，但是我们直接枚举 $v$ 的话复杂度仍然高达 $O(n^3)$，于是考虑优化，发现 $\min$ 那部分的第二维都一样，于是可以开一个数组 $s_j$ 记录 $\min\{f_{v,j}\}$，但不满足 $\min$ 的前置条件，由于 $n$ 很小，所以我们干脆再开一维，记 $s_{i,j}$ 为 $\min_{ed_v<=i}\{f_{v,j-sz_u}\}$，那么就有：

$$f_{u,j}=s_{st_u,j-sz_u}+\frac{1}{2}\sum_{i=st_u}^{ed_u}w_{re_i}$$

$$s_{i,j}=\begin{cases}\min\{s_{i-1,j},f_{re_i,j}\}&re_i>0\\s_{i-1,j}&re_i=0\end{cases}$$

于是最终时间复杂度降到 $O(n^2)$，但本人代码由于常数过大，要开 $\text{O2}$ 才能过。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
long long read(){
	long long x=0,f=1;char ch=getchar();
	while(!isdigit(ch))
	{if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void write(long long x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
const int N=2505;
int k,n;
int head[N],ver[N],nxt[N],tot;
int c[N],v[N];
int st[N],ed[N],num,re[N<<1],sz[N];
double w[N],f[N][N],sum,s[N<<1][N],d[N<<1];
void add(int x,int y){
	ver[++tot]=y;nxt[tot]=head[x];head[x]=tot;
}
void dfs(int x){
	sz[x]=1;
	st[x]=++num;
	for(register int i=head[x];i;i=nxt[i]){
		int y=ver[i];
		dfs(y);sz[x]+=sz[y];
	}
	ed[x]=++num;re[num]=x;
}
bool check(double x){
	sum=0;
	for(register int i=1;i<=n;i++){
		w[i]=v[i]-c[i]*x;
		d[st[i]]=d[ed[i]]=w[i]/2.0;
		sum+=w[i];
		s[0][i]=1e9;
		for(register int j=1;j<=n-k;j++)
			f[i][j]=1e9;
	}
	for(register int i=1;i<=2*n;i++)
		d[i]+=d[i-1];
	s[0][0]=0;
	double ans=1e9;
	for(register int i=1,x;i<=2*n;i++){
		for(register int j=0;j<=n-k;j++)
			s[i][j]=s[i-1][j];
		if(re[i]){//0是不会被踢除的，当然实际上只是作者懒
			x=re[i];
			f[x][sz[x]]=d[i]-d[st[x]-1];
			s[i][sz[x]]=min(s[i][sz[x]],f[x][sz[x]]);
			for(register int j=sz[x]+1;j<=n-k;j++){
				f[x][j]=min(f[x][j],s[st[x]][j-sz[x]]+d[i]-d[st[x]-1]);
				s[i][j]=min(s[i][j],f[x][j]);
			}
			ans=min(ans,f[re[i]][n-k]);
		}
	}
	return sum-ans>=0;
}
int main(){
	k=read();n=read();
	for(int i=1,fa;i<=n;i++){
		c[i]=read();v[i]=read();
		fa=read();
		add(fa,i);
	}
	n++;k++;
	dfs(0);
	double l=0,r=10000.0;
	for(register int i=1;i<=25;i++){
		double mid=(l+r)/2.0;
		if(check(mid))
			l=mid;
		else r=mid;
	}
	printf("%.3lf\n",l);
	return 0;
}
```

---

## 作者：creation_hy (赞：0)

树形dp + 二分答案水题。

这题和 P3705 比较像，这种形式一眼二分答案。

设答案为 $C$，很显然：

$\dfrac{\sum p}{\sum s}=C$

稍微推一下：

$\sum p=C\sum s$

$\sum p-C\sum s=0$

由于 $s_i$ 都是正数，很显然，对于 $K\le C$，有：

$\sum p-K\sum s\ge0$

二分答案，如果这个式子成立，那么答案大于等于当前二分值。

怎么求呢？树上背包就可以了。

将每个点的权值设成 $p_i-Ks_i$，如果选 $m$ 个点的最大值 $\ge0$，返回 `true`。

另外，注意 JYY 也要算一个人，所以要把 $m$ 加一。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2505;
const double eps = 1e-5;
int n, m, head[N], to[N], nxt[N], etot;
int a[N], b[N], sz[N];
double f[N][N], val[N];
inline void link(int u, int v)
{
    to[etot] = v;
    nxt[etot] = head[u];
    head[u] = etot++;
}
inline void dfs(int x)
{
    f[x][1] = val[x];
    sz[x] = 1;
    for (int i = head[x]; ~i; i = nxt[i])
    {
        dfs(to[i]);
        sz[x] += sz[to[i]];
        for (int j = sz[x]; j; j--)
            for (int k = 0; k < j; k++)
                f[x][j] = max(f[x][j], f[x][j - k] + f[to[i]][k]);
    }
}
inline bool check(double x)
{
    for (int i = 1; i <= n; i++)
        val[i] = a[i] - x * b[i];
    for (int i = 0; i <= n; i++)
        for (int j = 0; j <= m; j++)
            f[i][j] = -1e18;
    dfs(0);
    return f[0][m] >= 0;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    memset(head, -1, sizeof(head));
    cin >> m >> n;
    m++;
    for (int i = 1, x; i <= n; i++)
    {
        cin >> b[i] >> a[i] >> x;
        link(x, i);
    }
    double l = 0, r = 1e9;
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid))
            l = mid;
        else
            r = mid;
    }
    cout << fixed << showpoint << setprecision(3) << l;
    return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：0)

考虑 0/1 分数规划后，问题转化成了每个点有一个点权，将树割成两部分使得和根联通的一边的所有点的点权和最大。              

为了体现“割”的性质，刚开始选所有点，然后考虑扔点。

考虑令 $dp_{x,y,0/1}$ 表示 $x$ 点的子树内扔去 $y$ 个点扔去的总最小值，且此时不保留/保留 $x$ 节点。 

当不保留时就直接令 $dp_{x,siz_x,0} = sum_x$ 即可，其中 $sum_x$ 表示子树内的点权和，因为此时整棵子树必然不选。          

当保留时做树背包，枚举背包容量 $i,j$ 两维使得任意的 $dp_{x,i,1}$ 从 $dp_{son,j,0/1}$ 处转移。

观察。我们发现我们可以通过限制枚举时的子树大小不超过当前按顺序加入的子树的总大小来使得时间复杂度可以做成任意两点在 lca 处贡献一次，将单次判断答案合法的时间复杂度降到了 $O(n ^ 2)$。

最后总的时间复杂度 $O(n ^ 2 \log n)$。

```cpp
/*
通过 0/1 分数规划，现在需要求一个与根联通的最大树簇。 
定义 dp_i,0/1 表示扔/不扔的最小值 
*/
#include "bits/stdc++.h"
using namespace std;
const int Len = 2505;
const double eps = 1e-4 , Inf = 2e8;
int n,K,head[Len],cnt,S[Len],P[Len],siz[Len];
double dp[Len][Len][2],b,All,sum[Len];
struct node
{
	int next,to;
}edge[Len << 1];
void add(int from,int to)
{
	edge[++ cnt].to = to;
	edge[cnt].next = head[from];
	head[from] = cnt;
}
void dfs(int x,int f)
{
	siz[x] = 1;
	All += P[x] - S[x] * b;
	sum[x] = P[x] - S[x] * b;
	for(int e = head[x] ; e ; e = edge[e].next)
	{
		int to = edge[e].to;
		if(to == f) continue;
		dfs(to , x);
		siz[x] += siz[to];
		sum[x] += sum[to];
	}
	for(int i = 0 ; i <= siz[x] ; i ++) dp[x][i][0] = dp[x][i][1] = Inf;
	dp[x][siz[x]][0] = sum[x];
	dp[x][0][1] = 0;
	int SIZ = 0;
	for(int e = head[x] ; e ; e = edge[e].next)
	{
		int to = edge[e].to;
		if(to == f) continue;
		SIZ += siz[to];
		for(int i = SIZ ; i >= 1 ; i --)
			for(int j = 0 ; j <= min(i , siz[to]) ; j ++) dp[x][i][1] = min(dp[x][i][1] , dp[x][i - j][1] + min(dp[to][j][0] , dp[to][j][1])); 
	}
}
bool check(double mid)
{
	b = mid;All = 0;
	dfs(1 , 0);
	return (All - dp[1][n - K][1]) >= eps;
}
int main()
{
	scanf("%d %d",&K,&n);
	for(int i = 1 ; i <= n ; i ++) 
	{
		int s,p,r;scanf("%d %d %d",&s,&p,&r);
		S[i + 1] = s , P[i + 1] = p;
		add(r + 1 , i + 1);
	}	
	double l = 0 , r = 2500 * 10000;
	while(l + eps < r)
	{
		double mid = (l + r) / 2;
		if(check(mid)) l = mid;
		else r = mid;
	}
	printf("%.3lf\n",l);
	return 0;
}
```

---

## 作者：WeLikeStudying (赞：0)

**题意**
- [链接](https://www.luogu.com.cn/problem/P4322)。
- 给一棵 $n+1$ 个点的有根树，每个点有权值 $a_i$ 和 $b_i$，要求选出一个大小为 $k+1$ 的包含根的连通子图，最大化：
$$\frac{\sum a_i}{\sum b_i}$$
- $n,k\le 2500$。

**分析**
- 主要的问题就是分式的性质不好：甚至无法一个最优化问题拆成两个。
- 一个很妙的方法是[二分](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/post-sai-xiang-er-fen-da-an)，然后变成判定问题：
$$\frac{\sum a_i}{\sum b_i}\ge W$$
$$\sum a_i-b_iW\ge 0$$
- 实际上变成了一个整式的最优化问题。
- 变成这样就好拆分了。
- 接下来问题变成了简单的[这个](https://www.luogu.com.cn/problem/P2014)，我记得我在某个题解上讲过这个的复杂度是对的，表述如下：

```latex
- 考虑到理论上是 $O(n^3)$ 的做法跑得奇快，考虑复杂度是不是假了。
- 最复杂的情况也就 n 门课程，去掉 m 考虑归纳证明。
- 对于叶节点 u，复杂度显然可以看做 $O(\operatorname{size}^2(u))$
- 对于非叶节点 u ，若已经证明它的子树 $v_1,v_2,v_3,\dots v_k$ 时间复杂度都是 $\operatorname{size}^2$ 级别，其总和显然不超过 $\operatorname{size}^2(u)$ ($x^2+y^2\leq(x+y)^2$)级别，而其 01 背包过程总和显然也不超过 $\operatorname{size}^2(u)$ 级别 ($x+x+y\leq2(x+y)$) 
- 故该树上背包时间复杂度 $O(n^2)$ 得证。
```
- 所以这道题的复杂度应该是 $O(n^2\log W)$，$W$ 可以理解为你要的精度的倒数。
- 实现的细节大概就是你并不需要写一个深度优先搜索，而是可以倒着 $\text{DP}$ 来隐式地满足父子关系。
- [代码实现](https://www.luogu.com.cn/paste/bb39i4q2)。

---

## 作者：几何之舞丶 (赞：0)

### 这里提供一种对于分数规划类问题的优化思路

简单看了看其他题解,应该是没有使用这种优化的.

此题常数略大,有一些卡常.

此题基本的01分数规划+树形背包的思路我这里就不再赘述了.

主要讲一下如何优化.

首先是O(n^2)的树形背包部分,这部分没有什么好的通用的优化思路.

然后我们考虑二分的过程.

因为涉及精度问题,根据整数二分的思路,我们会在一个极小区间内反复二分多次,因而会增多很多次的二分过程.

但是我们的答案是离散的,所以我们的二分过程实际上是做了很多的无用功.

让我们重新考虑分数规划的过程,我们通过二分比率,然后check

我们树形背包跑出来的比率是否大于0,然后来检验比率是否合理.

也就是说,如果一个比率可行,那么这个比率一定可以作为我们答案的一个下界,也就是说,我们原先的

	if(check(mid))l=mid
    
    可以改为
    
    if(check(mid))l=比率;
    
 这样显然是正确的,因为我们算出来的比率必然是答案的一个下界.
 
 这样,在区间较小的时候,可以减少很多次dp过程.
 
至于计算比率是多大,我们可以再开一个sum,一个g数组记录取出来的分子和分母是多大.

二分过程代码:

```cpp
    while(r-l>=exp)
    {
        db mid =(l+r)/2.0;
        if(check(mid))l=sum[0][m]/g[0][m];
        else r=mid;
        //cout<<l<<" "<<r<<endl;
    }
```


dp过程:

```cpp
I void work(int now ,int fa)
{   dp[now][1]=f[now];sum[now][1]=a[now];g[now][1]=b[now];
    for(int i=head[now];i;i=edge[i].next){
        int v=edge[i].v;
        if(v==fa)continue;
        work(v,now);
        for(int j=min(m,size[now]);j>=0;j--)
            for(int k=0;k<=j;k++)
                if(dp[now][j-k]+dp[v][k]>dp[now][j])
                dp[now][j]=max(dp[now][j],dp[now][j-k]+dp[v][k]),sum[now][j]=sum[now][j-k]+sum[v][k],g[now][j]=g[now][j-k]+g[v][k];
    }
    return;
}
```
求过,谢谢=0=



---

## 作者：HPXXZYY (赞：0)

> 二分是个神奇的算法，它能让你难以维护的数据突然变得十分容易维护……



$\color{blue}{\texttt{[Problem]}}$

- 有一个有 $N+1$ 个点的树，每个节点有两个值：$p_{i},s_{i}(1 \leq i \leq N)$。
- 你需要选 $t+1$ 个点，如果一个点选了，则其父亲必须要选。
- 一个选择方案集合 $T$ 的总价值为：

  $$\dfrac{\sum\limits_{i \in T} p_i}{\sum\limits_{i \in T} s_i}$$

- 求总价值的最大值。$1 \leq t \leq N \leq 2500,1 \leq p_i,s_i \leq 1 \times 10^4(1 \leq i \leq N),\texttt{Father}(i)<i$。节点从 $0$ 编号到 $N$。

------------------------------------

$\color{blue}{\texttt{[Solution]}}$

是不是感觉总价值的那个式子特别难维护？

我们可以记 $\texttt{mid}$ 表示总价值大于等于 $\texttt{mid}$。我们发现 $\texttt{mid}$ 越大，越难以满足，所以我们可以二分答案。

改写一个总价值那个式子：

$$
\begin{aligned}
\dfrac{\sum\limits_{i \in T} p_i}{\sum\limits_{i \in T}s_i} &\geq \texttt{mid}\\
\sum\limits_{i \in T} p_i &\geq \texttt{mid} \times \sum \limits_{i \in T}s_i\\
\sum\limits_{i \in T} p_i - \texttt{mid} \times \sum \limits_{i \in T} s_i & \geq 0\\
\sum\limits_{i \in T} \left (p_i - \texttt{mid} \times s_i \right ) & \geq 0
\end{aligned}
$$

改每个点的价值为 $p_i -\texttt{mid} \times s_i$，原题被转化为了一个树上 dp 的问题。只要最后的总价值 $\geq 0$，代表 $\texttt{mid}$ 是一个可行答案。

如何树上 dp？很简单，记 $f_{i,j}$ 表示在 $i$ 的子树中选 $j$ 个点时的最大总价值，原题被转化为了一个树上背包问题，可以用类似 `选课` 一题的方法解决。

转移方程等看看代码就可以明白了。

----------------------------


$\color{blue}{\texttt{[code]}}$

```cpp
struct edge{//链式前向星 
	int next,to;//的模板 
}e[2510];int h[2510],tot;
inline void add(int a,int b){
	e[++tot]=(edge){h[a],b};h[a]=tot;
}
double p[2510],s[2510],w[2510];
double f[2510][2510];//dp用数组 
int n,t,sze[2510];double l,r,mid;
inline void dp(int u){
	f[u][1]=w[u];sze[u]=1;//init
	for(int i=h[u];i;i=e[i].next){
		register int to=e[i].to;
		dp(to);//先递归计算儿子值 
		sze[u]+=sze[to];//子树大小 
		for(int k=min(sze[u],t+1);k>=1;k--)
			for(int l=0;l<=min(sze[to],k-1);l++)
				f[u][k]=max(f[u][k],f[u][k-l]+f[to][l]);
//				该状态转移方程的含义是：在u当前加入的所有儿子中，to这个子树选l个点，其它儿子所对应的子树共选k-l个点时的最大总价值
//				注意就像01背包一样,k必须是倒序的
	}//我们依次加入所有的子树，然后进行转移
}
const int inf=0x3f3f3f3f;
inline bool check(double mid){
	for(int i=1;i<=n;i++)
		w[i]=p[i]-mid*s[i];
	w[0]=0;//计算每个人贡献 
	for(int i=0;i<=n;i++)
		for(int j=1;j<=t+1;j++)
			f[i][j]=-inf;
	dp(0);//从根开始进行dp 
	return f[0][t+1]>=0;
}
const double eps=1e-4;
int main(){
	t=read();n=read();
	for(int i=1;i<=n;i++){
		s[i]=read();p[i]=read();
		add(read(),i);//建图 
	}
	l=0.0;r=10000.0;
	while (l+eps<r){
		mid=(l+r)/2.0;
		if (check(mid)) l=mid;
		else r=mid;
	}
	printf("%.3lf",l);
	return 0;
}
```

---

## 作者：UnyieldingTrilobite (赞：0)

思路：这种题肯定上来看见 `比值最大` 基本想都不想就是谔分答案鸭。

谔分完之后就成功的转化成了求 `最大收益` 的问题了。（这部分要是不会的话建议重学相关知识）

然后我们观察到必须要是取了一个点就必须取父亲让人很不爽，想想怎么消掉？

（珂以参考一下春节十二响的套路）

**边dfs变处理（此处为按照dfs序DP）。**

DP状态差不多就自然定义了， $dp_{i,j}$ 表示 $i$ 号点子树内共选 $j$ 个点的最大收益。

（容易发现当 $j\neq 0$ 的时候 $i$ 号点必选，很自然地化解掉了父亲必选的限制。）

注意边界情况。


这个思路复杂度我也不会证明......听说是平方级别的。

反正我直接上是 $80$ 分了。（人傻自带大常数）

那怎么办？

我们需要一个这种题的常用优化策略。

~~O2~~

~~对吸口氧就能过了。~~

最后上代码（模拟赛考场代码求轻喷）：

```cpp
#include<bits/stdc++.h>
#define max(_i,_j) (_i>_j?_i:_j)
#define min(_i,_j) (_i<_j?_i:_j)
const int N=2509;
struct edge{
	int to,nxt;
}e[N];
int hd[N],tot;
inline void add(const int&u,const int&v){
	e[++tot]=(edge){v,hd[u]},hd[u]=tot;
}
int n,k,r[N],sz[N];
double sum[N];
double s[N],p[N];
double dp[N][N];
int dfs(const int&x){
	sz[x]=1;
	for(int i=hd[x];i;i=e[i].nxt)sz[x]+=dfs(e[i].to);
	return sz[x];
}
void calc(const int&x){
	sum[x]=p[x];
	for(int i=hd[x];i;i=e[i].nxt)calc(e[i].to),sum[x]+=sum[e[i].to];
	for(int i=1;i<=k;++i)dp[x][i]=-1e9;
	for(int i=hd[x];i;i=e[i].nxt){
		int v=e[i].to;
		for(int j=min(k,sz[x]);j;--j){
			for(int w=min(j,sz[v]);w;--w){
				dp[x][j]=max(dp[x][j],dp[x][j-w]+dp[v][w]);
				//cout<<x<<' '<<j<<' '<<fixed<<setprecision(3)<<dp[x][j]<<endl;
			}
		}
	}if(sz[x]<=k)dp[x][sz[x]]=sum[x]-p[x];
	for(int i=k+1;i;--i)dp[x][i]=dp[x][i-1]+p[x];
//	for(int i=1;i<=k;++i)cout<<x<<' '<<i<<' '<<fixed<<setprecision(3)<<dp[x][i]<<endl;
}
bool ok(const double&mid){
	for(int i=1;i<=n;++i)p[i]-=s[i]*mid;
	calc(0);
	for(int i=1;i<=n;++i)p[i]+=s[i]*mid;
	//cout<<dp[0][k+1]<<endl;
	return dp[0][k+1]>=0;
}
int main(){
	freopen("tree.in","r",stdin);
	freopen("tree.out","w",stdout);
	scanf("%d%d",&k,&n);
	for(int i=1;i<=n;++i)scanf("%lf%lf%d",s+i,p+i,r+i),add(r[i],i);
	dfs(0);
	double L=0,R=1e4,ans=0;
	while(R-L>=1e-4){
		double mid=(L+R)/2;
		//cout<<fixed<<setprecision(3)<<mid<<endl<<"________________________________________"<<endl;
		if(ok(mid))L=ans=mid;
		else R=mid;
	}
	printf("%.3lf\n",ans);
	return 0;
}
```

---


# 【MX-S6-T2】「KDOI-11」飞船

## 题目背景

原题链接：<https://oier.team/problems/S6B>。

## 题目描述

巡造了一个很牛的飞船，巡为了测试她的飞船，造了一条无限远的从起点出发的射线作为跑道。在跑道上有 $n$ 个加油站，第 $i$ 个在距离起点 $p_i$ 的位置，巡可以在这里花费 $t_i$ 的时间加编号为 $x_i$ 的燃油，**同一个加油站的油不能加两次**，**保证 $\boldsymbol{1\leq x_i\leq 4}$ 且 $\boldsymbol{x_i}$ 为整数**。

巡的飞船牛在两个点：

- 这个飞船油量消耗极低，在本题中可以忽略不计。也就是，**我们不考虑油消耗殆尽的情况。**
- 如果给飞船加编号为 $x$ 的燃油，**飞船的速度会从 $v$ 提升为 $v\times x$**。需要注意的是，**燃油的效果能叠加**。

现在，巡给出了 $q$ 次询问。每次巡会将终点设在跑道上距离起点 $y_i$ 的位置，从起点出发，将飞船速度设定为 $1$ 单位每时间，途径的每个加油站可以自由选择是否加油。你需要告诉巡每次至少需要多少时间才能到达终点（即 $y_i$）。

## 说明/提示

**【样例解释 #1】**

- 对询问 $y_1=1$，不加油，需要时间为 $1$。
- 对询问 $y_2=4$，不加油，需要时间为 $4$。
- 对询问 $y_3=10$，在位于起点 $3$ 单位距离的加油站 $2$ 加 $2$ 号燃油，速度提升为 $2$，需要时间为 $3+1+\frac{10-3}{2}=7.5$。

**【样例 #2】**

见附件中的 `ship/ship2.in` 与 `ship/ship2.ans`。

该组样例满足测试点 $1\sim 3$ 的约束条件。

**【样例 #3】**

见附件中的 `ship/ship3.in` 与 `ship/ship3.ans`。

该组样例满足测试点 $5\sim 7$ 的约束条件。

**【样例 #4】**

见附件中的 `ship/ship4.in` 与 `ship/ship4.ans`。

该组样例满足测试点 $18\sim 20$ 的约束条件。

**【数据范围】**


对于所有测试数据，保证：$1\leq n\leq 10^5$，$1\leq q\leq10^5$，$1\leq p_1<p_2<\dots<p_n\leq 10^9$，$1\leq t_i\leq10^9$，$1\leq x_i\leq4$，$1\leq y_i\leq 10^9$。

| 测试点编号  | $n\leq$ | $q\leq$ |   $x_i\in $   | $p_i,y_i\leq $ |
| :---------: | :-----: | :-----: | :-----------: | :------------: |
|  $1\sim 3$  |  $10$   |  $10$   | $\{1,2,3,4\}$ |     $10^9$     |
|     $4$     | $10^5$  | $10^5$  |    $\{1\}$    |     $10^9$     |
|  $5\sim 7$  |  $100$  |  $100$  | $\{1,2,3,4\}$ |     $1000$     |
|  $8\sim 9$  | $10^5$  | $10^5$  |   $\{1,2\}$   |     $10^9$     |
| $10\sim 13$ | $10^5$  | $10^5$  |  $\{1,2,4\}$  |     $10^9$     |
| $14\sim 17$ | $10^5$  |  $10$   | $\{1,2,3,4\}$ |     $10^9$     |
| $18\sim 20$ | $10^5$  | $10^5$  | $\{1,2,3,4\}$ |     $10^9$     |



## 样例 #1

### 输入

```
4 4
1 1 1
3 1 2
8 5 2
10 100 3
1 4 10 1000```

### 输出

```
1
4
7.5
194.5
```

# 题解

## 作者：cff_0102 (赞：13)

刚开始看出来应该可以用 dp 了，但是因为某些原因没想到速度是可以放到状态里面的。

首先考虑 $x\in\{1,2\}$ 的情况，容易发现在每一个时刻飞船的速度都是 $2$ 的整数次幂。因此，在 $10^9$ 范围内的可能的速度实际上很少。既然这样，就可以把速度的幂次放到 dp 的状态里。设 $dp_{i,j}$ 表示到达第 $i$ 个加油站且速度为 $2^j$ 时最少需要的时间。对于每个加油站，可以选择加或者不加，计算出对应时间再取最小值即可。

注意到全部数据范围的 $x\in\{1,2,3,4\}$，所以只需要增加一维表示速度中有 $3$ 的几次幂即可。用同样的方式转移，注意不要数组越界就行了。

但是这题空间卡的比较紧，即使用 `double` 也有 MLE 的可能，最好是把询问离线下来，再用滚动数组优化一下 dp，在 dp 过程中直接计算出所有询问的答案，就不需要把所有 dp 值存下来了。

既然都用滚动数组优化了，也不用担心空间的问题了，不如用精度更高的 `long double`。

具体可以见代码注释。

```cpp
#include<bits/stdc++.h>
#define int long long
#define double long double
using namespace std;
const int N=1e5+5;
int pp[N],tt[N],xx[N];
double dp[2][32][21];
double p2[35],p3[25];
double ans[N];
pair<int,int>qu[N];
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	p2[0]=p3[0]=1;//预处理出 2 和 3 的幂次
	for(int i=1;i<=32;i++)p2[i]=p2[i-1]*2;
	for(int i=1;i<=23;i++)p3[i]=p3[i-1]*3;
	int n,q;cin>>n>>q;
	for(int i=1;i<=n;i++){
		cin>>pp[i]>>tt[i]>>xx[i];
	}
	for(int i=0;i<=1;i++)for(int j=0;j<=31;j++)for(int k=0;k<=20;k++)dp[i][j][k]=1e18;
	dp[0][0][0]=0;//注意初始化
	for(int i=1;i<=q;i++){
		cin>>qu[i].first;qu[i].second=i;
	}
	sort(qu+1,qu+1+q);
	int ppp=1;
	for(int i=1;i<=n;i++){
		double p=pp[i],t=tt[i],lp=pp[i-1];
		int x=xx[i];
		while(ppp<=q&&qu[ppp].first<p){//处理现在需要解决的所有询问（等一下这些要用到的 dp 值就滚走了）
			double an=1e18;
			for(int j=0;j<=31;j++){
				for(int k=0;k<=20;k++){
					an=min(an,dp[0][j][k]+(qu[ppp].first-lp)/p2[j]/p3[k]);//路程 / 速度 = 时间
				}
			}
			ans[qu[ppp].second]=an;
			ppp++;
		}
		for(int j=31;j>=0;j--){
			for(int k=20;k>=0;k--){
				dp[1][j][k]=dp[0][j][k]+(p-lp)/p2[j]/p3[k];//路程 / 速度 = 时间
			}
		}
		for(int j=31;j>=0;j--){
			for(int k=20;k>=0;k--){//注意这里的转移顺序
				switch(x){
					case 1:
						break;//x=1，不用管
					case 2:
						if(j>0)dp[1][j][k]=min(dp[1][j][k],dp[1][j-1][k]+t);
						break;//x=2，如果在这里加了油，那么原来的速度应该是 2^(j-1)*3^k
					case 3:
						if(k>0)dp[1][j][k]=min(dp[1][j][k],dp[1][j][k-1]+t);
						break;//x=3，如果在这里加了油，那么原来的速度应该是 2^j*3^(k-1)
					case 4:
						if(j>1)dp[1][j][k]=min(dp[1][j][k],dp[1][j-2][k]+t);
						break;//x=4，如果在这里加了油，那么原来的速度应该是 2^(j-2)*3^k
				} 
			}
		}
		for(int j=31;j>=0;j--){
			for(int k=20;k>=0;k--){
				dp[0][j][k]=dp[1][j][k];
			}
		}
	}
	while(ppp<=q){//最后一个加油站右边的询问别忘了处理
		double an=1e18;
		for(int j=0;j<=31;j++){
			for(int k=0;k<=20;k++){
				an=min(an,dp[0][j][k]+(qu[ppp].first-pp[n])/p2[j]/p3[k]);
			}
		}
		ans[qu[ppp].second]=an;
		ppp++;
	}
	cout<<fixed<<setprecision(10);
	for(int i=1;i<=q;i++)cout<<ans[i]<<"\n";
	return 0;
}
```

要注意询问总数是 $q$ 不是 $n$，排序的时候别用成 `sort(qu+1,qu+1+n)` 了，这样会挂成 $45$ 分，别问我怎么知道的。

---

## 作者：Laisira (赞：11)

### 思路
连着两道小签题，梦熊真好心。

一个显然的暴力：

记 $f_{i,j}$ 表示到第 $i$ 个加油站的位置速度为 $j$ 的最小时间，有：

$$
f_{i,j} = \min(f_{i-1,j}+\frac{p_{i}-p_{i-1}}{j},f_{i-1,\frac{j}{x_i}}+\frac{x_i(p_{i}-p_{i-1})}{j}+t_i)
$$

然后在每个询问点上暴力取最小值，由于路程最大值（$y_{max}$）不超过 $10^9$，加油时间大于等于 $1$，所以速度不大于 $y_{max}$，乘的次数不大于 $\lceil\log y_{max}\rceil$，时间复杂度 $O(n\lceil\log y_{max}\rceil+nm)$。

不难发现瓶颈在统计答案，又 $x_{i}$ 只有四种情况（其中一种没用，一种可以被分解成 $2\times 2$），不妨记 $2$ 和 $3$ 分别被乘了几次，询问离线当成 $x_i = 1$ 去跑，时间复杂度 $O(n\lceil\log^2 y_{max}\rceil)$。

状态转移与上面大体一致。

UPDATE：少了个 $t_i$。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long 
#define double long double 
#define m2 30
#define m3 25
using namespace std;
double f[2][m2][m3];
int fac[2][31];
struct node {
	int op,p,t,x;
	bool operator<(const node&is) {
		return p == is.p?op < is.op:p < is.p;
	}
} t[1000005];
double ans[100005];
double get(double x,double y) {
	return (double)x/y;
}
const double inf = 1e14;
const int INF = 1e13;
signed main()
{
//	freopen("ship4.in","r",stdin);
//	freopen("ship.out","w",stdout);
	int n,q,tot = 0;
	cin>>n>>q;
	for(int i=1;i<=n;i++) {
		int x,y,z;
		cin>>x>>y>>z;
		if(z == 1)continue;
		t[++tot] = {0,x,y,z};
	} 
	
	for(int i=1;i<=q;i++) {
		int x;
		cin>>x;
		t[++tot] = {i,x,0,1};
	} 
	
	sort(t+1,t+1+tot);
	
	for(int i=0;i<m2;i++)
		for(int j=0;j<m3;j++) {
			f[0][i][j] = inf;
			f[1][i][j] = inf;
		}
	f[0][0][0] = 0;
	
	fac[0][0] = fac[1][0] = 1;
	for(int i=1;i<m2;i++)
		fac[0][i] = fac[0][i-1]*2;
	for(int i=1;i<m3;i++)
		fac[1][i] = fac[1][i-1]*3;
	
	int res2 = 0,res3 = 0;
	
	for(int i=1;i<=tot;i++) {
		for(int j=0;j<=res2;j++) {
			for(int k=0;k<=res3;k++) {
				__int128 cnt = (__int128)fac[0][j]*fac[1][k]*t[i].x;
				if(cnt >= INF)break;
				f[(i&1)][j][k] = min(f[(i&1)][j][k],f[(i&1)^1][j][k]+get(t[i].p-t[i-1].p,fac[0][j]*fac[1][k]));
				if(t[i].x == 1)f[(i&1)][j][k] = f[(i&1)^1][j][k]+get(t[i].p-t[i-1].p,fac[0][j]*fac[1][k]);
				if(t[i].x == 2)f[(i&1)][j+1][k] = min(f[(i&1)^1][j+1][k]+get(t[i].p-t[i-1].p,fac[0][j+1]*fac[1][k]),f[(i&1)^1][j][k]+get(t[i].p-t[i-1].p,fac[0][j]*fac[1][k])+t[i].t);
				if(t[i].x == 3)f[(i&1)][j][k+1] = min(f[(i&1)^1][j][k+1]+get(t[i].p-t[i-1].p,fac[0][j]*fac[1][k+1]),f[(i&1)^1][j][k]+get(t[i].p-t[i-1].p,fac[0][j]*fac[1][k])+t[i].t);
				if(t[i].x == 4)f[(i&1)][j+2][k] = min(f[(i&1)^1][j+2][k]+get(t[i].p-t[i-1].p,fac[0][j+2]*fac[1][k]),f[(i&1)^1][j][k]+get(t[i].p-t[i-1].p,fac[0][j]*fac[1][k])+t[i].t);
			}
		}
		if(t[i].x == 2)res2 ++;
		if(t[i].x == 3)res3 ++;
		if(t[i].x == 4)res2 += 2;
		if(res2 > m2-1)res2 = m2-1;
		if(res3 > m3-1)res3 = m3-1;
		if(t[i].op) {
			double res = inf;
			for(int j=0;j<=res2;j++)
				for(int k=0;k<=res3;k++)
					res = min(res,f[(i&1)][j][k]);
			ans[t[i].op] = res;
		}
		for(int j=0;j<=res2;j++)
			for(int k=0;k<=res3;k++)
				f[(i&1)^1][j][k] = inf;
	} 
	for(int i=1;i<=q;i++)printf("%.7Lf\n",ans[i]);
	return 0;
 } 
```

---

## 作者：chenly8128 (赞：6)

### 基本思路

- 注意 $1 \leq x \leq 4$。所以飞船速度仅含有因子 $2$ 和 $3$。
- 注意到飞船飞行的总距离在 $10^9$ 以内。所以如果飞船某一刻的速度超过了 $10^9$ 那么它接下来无论如何加速，飞行都只需要少于 $1$ 秒的时间，由于加油至少需要额外的 $1$ 秒，加油肯定不够优，所以没有继续加油的意义。速度不会超过 $4 \times 10^9$。

综上所述，**飞船的速度为不超过 $4 \times 10^9$ 的仅含有因子 $2$ 和 $3$ 的正整数**。

然而满足这样条件的仅有 $m = 347$ 个不同速度值。

所以可以计算到达每个点，且加速到每个不同速度所需的时间。总计算量为 $O(nm)$ 大约为 $34700000$ 卡一卡常数，递推一下就可以了。

### 实现

令 $dp_{i,j}$ 表示到达第 $i$ 个节点，此时速度为 $j$ 所需的时间。
$$dp_{i,j} = \min(dp_{i-1,j}+(p_i-p_{i-1})/j,dp_{i-1,j/x} + t + (p_i-p_{i-1})/(j/x))$$
其中第二个部分要求 $x$ 整除 $j$。

由于 $j$ 很大，但是总的可能性数很少，所以我使用离散化实现。

### 代码
总时间复杂度 $O(nm+qm)$，空间复杂度 $O(nm)$。其中 $m = 347$。
```cpp

// Author: chenly8128
// Created: 2024-11-17 09:23:21

#include <bits/stdc++.h>
#include <bits/extc++.h>
#define int long long
using namespace std;
using namespace __gnu_pbds;
inline int read(void) {
	int res = 0;bool flag = true;char c = getchar();
	while (c < '0' || c > '9') {flag ^= (c == '-');c = getchar();}
	while (c >= '0' && c <= '9') {res = (res << 3) + (res << 1) + (c ^ 48);c = getchar();}
	return flag ? res : -res;
}
const int MAXN = 1e5+10;
const int MAXV = 347;
const double INF = 0x3f3f3f3f;
gp_hash_table <int,int> m;
int p[MAXN];
int n,q,len = 0,t,x;
double dp[MAXN][MAXV];
int tmp[MAXV];
signed main (void) {
	m.clear();n = read();q = read();
	for (int i = 1;i <= 4e9;i <<= 1)
		for (int j = i;j <= 4e9;j *= 3) {
			m[j] = len;
			tmp[len++] = j;
		}
	for (int i = 0;i <= n;i++) {
		for (int t = 0;t < MAXV;t++)
			dp[i][t] = INF;
	}
	dp[0][m[1]] = 0;
	for (int i = 1;i <= n;i++) {
		p[i] = read();t = read();x = read();
		dp[i][m[1]] = p[i];
		for (int j = 0;j < MAXV;j++) {
			double h = (p[i]-p[i-1])/(double)tmp[j];
			dp[i][j] = min(dp[i][j],dp[i-1][j]+h);
			if (x > 1 && dp[i-1][j] < INF && tmp[j] <= (4e9/x)) {
				int y = m[tmp[j]*x];
				dp[i][y]=min(dp[i][y],dp[i-1][j]+t+h);
			}
		}
	}
	while (q--) {
		x = read();
		int i = lower_bound(p+1,p+1+n,x)-p-1;
		if (i == 0) printf ("%lld\n",x);
		else {
			double ans = INF;
			for (int j = 0;j < MAXV;j++)
				ans = min(ans,dp[i][j]+(x-p[i])/(double)tmp[j]);
			printf ("%.7lf\n",ans);
		}
	}
	return 0;
}
```
最后吐个槽，我赛时这题提交了 3 次。最后一次代码是正确的，根据提交记录的的确确是 100 pts。结果赛后一看排行榜，这一题只有 85 pts。糟心。

---

## 作者：ThisIsLu (赞：5)

看到题目，不难想到朴素 dp：

令 $dp_{i,j}$ 表示到达第 $i$ 个加油站，最终速度为 $j$ 的最小时间。

转移：

$$dp_{i+1,jx_{i+1}}\gets\min\set{dp_{i+1,jx_{i+1}},dp_{i,j}+\dfrac{p_{i+1}-p_i}{j}+t_{i+1}}$$

$$dp_{i+1,j}\gets\min\set{dp_{i+1,j},dp_{i,j}+\dfrac{p_{i+1}-p_i}{j}}$$

但是可能的速度太多了，所以此 dp 是指数级的。

我们注意到，当速度过大时，时间耗费近似为 $0$。

而题目中有这么一句话：

- 本题使用**自定义校验器**检验你的答案是否正确，你只需要保证你的答案与标准答案相对或绝对误差不超过 $10^{-6}$ 即可。即如果对每个询问，假设你的答案为 $x$，而标准答案为 $y$，都有 $\frac{\lvert x-y\rvert}{\max(1,\lvert y\rvert)}\leq 10^{-6}$，则你的答案被认为是正确的。

所以，如果速度为 $v$，则可能的最大耗时为 $\dfrac{10^9}{v}$，若 $\dfrac{10^9}{v} < 10^{-6}$ 即 $v > 10^{15}$ 时，我们就不用管它了。

而 $10^{15}$ 内可达的所有速度数量为 $824$ 个，题目开了 3.00s 时限，可以通过。

但我们还要一个状态来表示速度过快，所以一共有 $825n$ 个状态。

具体实现上，如果使用 umap 或 map 来存储状态，会爆空间或时间，所以要对这 $824$ 个数编号。

对于查询，二分出距离最远且在 $0\sim y$ 之间的加油站，枚举每种速度即可。

最后请注意不要用 `float`，精度不够；也不要用 `long double`，会快乐的 MLE。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int s[32]={0,50,99,146,192,236,278,319,358,396,432,466,499,530,560,588,615,640,663,685,705,724,741,756,770,782,793,802,810,816,820,823},a[32]={50,49,47,46,44,42,41,39,38,36,34,33,31,30,28,27,25,23,22,20,19,17,15,14,12,11,9,8,6,4,3,1};
long long powb[32]={1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,14348907,43046721,129140163,387420489,1162261467,3486784401,10460353203,31381059609,94143178827,282429536481,847288609443,2541865828329,7625597484987,22876792454961,68630377364883,205891132094649,617673396283947};
int n,q;
const int N=1e5;
int p[N+5],t[N+5],x[N+5];
double dp[N+5][825];
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    int tmp;
    cin>>tmp>>q;
    for(int i=1;i<=tmp;i++){
        int pi,ti,xi;
        cin>>pi>>ti>>xi;
        if(xi==1) continue;
        p[++n]=pi;
        t[n]=ti;
        x[n]=xi;
    }
    for(int i=1;i<825;i++) dp[0][i]=1e18;
    for(int i=0;i<n;i++){
        dp[i+1][824]=dp[i][824];
        for(int j=31;j>=0;j--){
            for(int k=a[j]-1;k>=0;k--){
                int pos;
                if(x[i+1]==2) pos=(k==a[j]-1?824:s[j]+k+1);
                else if(x[i+1]==3) pos=(j==31?824:s[j+1]+k);
                else pos=(k>=a[j]-2?824:s[j]+k+2);
                dp[i+1][pos]=min(dp[i+1][pos],dp[i][s[j]+k]+(double)(p[i+1]-p[i])/(powb[j]<<k)+t[i+1]);
                dp[i+1][s[j]+k]=dp[i][s[j]+k]+(double)(p[i+1]-p[i])/(powb[j]<<k);
            }
        }
    }
    for(int i=1;i<=q;i++){
        int y;
        cin>>y;
        int pos=upper_bound(p+1,p+n+1,y)-p-1;
        double ans=dp[pos][824];
        for(int j=31;j>=0;j--){
            for(int k=0;k<a[j];k++){
                ans=min(ans,dp[pos][s[j]+k]+(double)(y-p[pos])/(powb[j]<<k));
            }
        }
        cout<<fixed<<setprecision(9)<<ans<<"\n";
    }
    return 0;
}
```

---

## 作者：GI录像机 (赞：4)

## 思路

考虑 dp。把加油站按 $p_i$ 排序。假如我们知道了当前飞船的位置和加的每种油数量，我们就不关心它之前到底怎么干的了。

但是油的数量是 $O(n)$ 级别的。发现加 $1$ 是没有用的，直接舍去。而 $2$ 最多只会加 $30$ 次，因为加油的花费最少是 $1$，而加 $30$ 次后速度为 $2^{30}>10^9$，$1$ 时间以内就能跑完。

$3,4$ 同理。但是这样仍然过不去，于是把 $4$ 看作 $2^2$。现在我们就有了 $dp_{l,i,j}$ 表示在加油站 $l$ 处，加了 $i$ 次 $2$ 号油，$j$ 次 $3$ 号油的最小花费，有转移：

```cpp
dp[l][i][j] = dp[l - 1][i][j] + (p[l] - p[l - 1]) / gi[i][j];
if(x[l] == 2 && i)dp[l][i][j] = min(dp[l][i][j], dp[l - 1][i - 1][j] + (p[l] - p[l - 1]) / gi[i - 1][j] + t[l]);
else if(x[l] == 3 && j)dp[l][i][j] = min(dp[l][i][j], dp[l - 1][i][j - 1] + (p[l] - p[l - 1]) / gi[i][j - 1] + t[l]);
else if(x[l] == 4 && i >= 2)dp[l][i][j] = min(dp[l][i][j], dp[l - 1][i - 2][j] + (p[l] - p[l - 1]) / gi[i - 2][j] + t[l]);
```

询问时，只需二分 $y$ 之前的第一个加油站计算即可。

注意不要开 long double，否则你会获得 MLE 30pts 的超高分。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	int x = 0, f = 1;
	char c = getchar();
	while(c > '9' || c < '0') {
		if(c == '-')f = -f;
		c = getchar();
	}
	while(c <= '9' && c >= '0') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}
void write(int x) {
	if(x < 0) {
		putchar('-');
		x = -x;
	} if(x > 9)write(x / 10);
	putchar((x % 10) + '0');
}
const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7;
int n, q, p[N], t[N], x[N];
double dp[N][31][20], gi[31][20];
signed main() {
	//freopen("ship.in", "r", stdin);
	//freopen("ship.out", "w", stdout);
	n = read(), q = read();
	gi[0][0] = 1;
	for(int i = 0; i <= 30; i++) {
		for(int j = 0; j <= 19; j++) {
			if(!j && !i)continue;
			if(i)gi[i][j] = gi[i - 1][j] * 2;
			else gi[i][j] = gi[i][j - 1] * 3;
			if(gi[i][j] < 0 || gi[i][j] > 4e9)gi[i][j] = -1;
		}
	}
	for(int l = 1; l <= n; l++) {
		p[l] = read(), t[l] = read(), x[l] = read();
		for(int i = 0; i <= 30; i++)
			for(int j = 0; j <= 19; j++)
				dp[l][i][j] = INF;
	}
	for(int i = 0; i <= 30; i++)
		for(int j = 0; j <= 19; j++)
			dp[0][i][j] = INF;
	dp[0][0][0] = 0;
	for(int l = 1; l <= n; l++)
		for(int i = 0; i <= 30; i++)
			for(int j = 0; j <= 19; j++) {
				if(gi[i][j] == -1)continue;
				dp[l][i][j] = dp[l - 1][i][j] + (p[l] - p[l - 1]) / gi[i][j];
				if(x[l] == 2 && i)dp[l][i][j] = min(dp[l][i][j], dp[l - 1][i - 1][j] + (p[l] - p[l - 1]) / gi[i - 1][j] + t[l]);
				else if(x[l] == 3 && j)dp[l][i][j] = min(dp[l][i][j], dp[l - 1][i][j - 1] + (p[l] - p[l - 1]) / gi[i][j - 1] + t[l]);
				else if(x[l] == 4 && i >= 2)dp[l][i][j] = min(dp[l][i][j], dp[l - 1][i - 2][j] + (p[l] - p[l - 1]) / gi[i - 2][j] + t[l]);
			}
	while(q--) {
		int y = read(), idx = lower_bound(p + 1, p + n + 1, y) - p - 1;
		double res = INF;
		for(int i = 0; i <= 30; i++)
			for(int j = 0; j <= 19; j++)
				if(gi[i][j] != -1)
					res = min(res, dp[idx][i][j] + (y - p[idx]) / gi[i][j]);
		printf("%.7lf\n", res);
	}
	return 0;
}

```

---

## 作者：shuqiang (赞：3)

这是一个简单的 dp 题。

注意到 $1 \le x_i \le 4$，所以可以设 $f_{i,j,k}$ 表示到第 $i$ 个加油站，当前速度为 $2^j \times 3^k$ 时至少要花多少时间，加了油转移方程为 $f_{i,j,k}=\min(f_{i,j,k},f_{i-1,j-u,k-v}+(p_i-p_j)\div(2^j \times 3^k)+t_i)$，其中
- 当 $x_i=2$ 时 $u=1,v=0$。
- 当 $x_i=3$ 时 $u=0,v=1$。
- 当 $x_i=4$ 时 $u=2,v=0$。

没有加油的转移方程是 $f_{i,j,k}=\min(f_{i,j,k},f_{i-1,j,k}+(p_i-p_j)\div(2^j \times 3^k)+t_i)$

但是每一个加油站只能加一次油，所以我们还需要设 $g_{i,j,k}$ 表示到第 $i$ 个加油站，当前速度为 $2^j \times 3^k$ 的状态是否存在。

回答问题可以二分这个位置左边的加油站，然后再加上剩余的路程除以速度，取最小值。

设 $V$ 为 $p_i$ 的值域，时间复杂度 $\mathcal{O}((n+q) \log V^2+q\log n)$，可以通过。

注意不要开 `long double`，会爆内存。

代码：
```cpp
#include<iostream>
#include<algorithm>
#include<iomanip>

using namespace std;
typedef long long ll;

const int N = 1e5 + 1; const ll mx = 6e9;
int n, q, p[N], t[N], x[N], y, m2[31], m3[19];
bool g[N][31][19];
double f[N][31][19], ans;

int main(){
	cin >> n >> q;
	for(int i = 1; i <= n; i++){
		cin >> p[i] >> t[i] >> x[i];
	}
	m2[0] = m3[0] = 1;
	for(int i = 1; i < 19; i++) m2[i] = m2[i-1] * 2, m3[i] = m3[i-1] * 3;
	for(int i = 19; i < 31; i++) m2[i] = m2[i-1] * 2;
	g[0][0][0] = 1;
	for(int i = 1; i < N; i++){
		for(int j = 0; j < 31; j++){
			for(int k = 0; k < 19; k++){
				f[i][j][k] = 1e9;
			}
		}
	}
	for(int i = 1; i <= n; i++){
		int n1, n2;
		if(x[i] == 1) n1 = n2 = 0;
		else if(x[i] == 2) n1 = 1, n2 = 0;
		else if(x[i] == 3) n1 = 0, n2 = 1;
		else n1 = 2, n2 = 0;
		for(int w1 = 0; w1 < 31; w1++){
			for(int w2 = 0; w2 < 19; w2++){
				if((ll)m2[w1] * m3[w2] > mx) continue;
				if(n1 <= w1 && n2 <= w2 && g[i-1][w1-n1][w2-n2]){
					f[i][w1][w2] = min(f[i-1][w1-n1][w2-n2] + (p[i] - p[i-1]) * 1.0 / ((ll)m2[w1-n1] * m3[w2-n2]) + t[i], f[i][w1][w2]);
					g[i][w1][w2] = 1;
				}
				if(g[i-1][w1][w2]){
					f[i][w1][w2] = min(f[i-1][w1][w2] + (p[i] - p[i-1]) * 1.0 / ((ll)m2[w1] * m3[w2]), f[i][w1][w2]);
					g[i][w1][w2] = 1;
				}
			}
		}
	}
	while(q--){
		cin >> y;
		int fd = upper_bound(p, p + n + 1, y) - p - 1;
		ans = 1e9;
		for(int w1 = 0; w1 < 31; w1++){
			for(int w2 = 0; w2 < 19; w2++){
				if((ll)m2[w1] * m3[w2] > mx) continue;
				if(g[fd][w1][w2]){
					ans = min(ans, f[fd][w1][w2] + (y - p[fd]) * 1.0 / ((ll)m2[w1] * m3[w2]));
				}
			}
		}
		cout << fixed << setprecision(8) << ans << '\n'; //避免用科学计数法输出。 
	}
	return 0;
}
```

然后你就会发现：
![](https://cdn.luogu.com.cn/upload/image_hosting/p6r6qt0a.png)

这是因为数组开得太大了，观察到转移方程只跟 $i$ 和 $i-1$ 有关，所以我们可以用滚动数组的方法，先把问题离线并排序，记录它原来的地方，然后在 dp 的过程中记录这些问题的答案，最后按照它原来的地方排序输出，注意 dp 前要清空。

AC 代码：

```cpp
#include<iostream>
#include<algorithm>
#include<iomanip>

using namespace std;
typedef long long ll;

const int N = 1e5 + 1; const ll mx = 6e9;
int n, q, p[N], t[N], x[N], m2[31], m3[19];
bool g[2][31][19];
double f[2][31][19], ans;

struct Y{
	int y, id; double ans;
	
	bool operator < (const Y & o) const{
		return y < o.y;
	}
} y[N];

bool cmp(Y xx, Y yy){
	return xx.id < yy.id;
}

void clearfg(int x){
	for(int j = 0; j < 31; j++){
		for(int k = 0; k < 19; k++){
			f[x][j][k] = 1e9; g[x][j][k] = 0;
		}
	}
}

int main(){
	cin >> n >> q;
	for(int i = 1; i <= n; i++){
		cin >> p[i] >> t[i] >> x[i];
	}
	m2[0] = m3[0] = 1;
	for(int i = 1; i < 19; i++) m2[i] = m2[i-1] * 2, m3[i] = m3[i-1] * 3;
	for(int i = 19; i < 31; i++) m2[i] = m2[i-1] * 2;
	g[0][0][0] = 1;
	for(int i = 0; i < q; i++){
		cin >> y[i].y;
		y[i].id = i;
	}
	sort(y, y + q);
	int idx = 0;
	for(int i = 1; i <= n; i++){
		int n1, n2;
		if(x[i] == 1) n1 = n2 = 0;
		else if(x[i] == 2) n1 = 1, n2 = 0;
		else if(x[i] == 3) n1 = 0, n2 = 1;
		else n1 = 2, n2 = 0;
		clearfg(i&1);
		for(int w1 = 0; w1 < 31; w1++){
			for(int w2 = 0; w2 < 19; w2++){
				if((ll)m2[w1] * m3[w2] > mx) continue;
				if(n1 <= w1 && n2 <= w2 && g[i&1^1][w1-n1][w2-n2]){
					f[i&1][w1][w2] = min(f[i&1^1][w1-n1][w2-n2] + (p[i] - p[i-1]) * 1.0 / ((ll)m2[w1-n1] * m3[w2-n2]) + t[i], f[i&1][w1][w2]);
					g[i&1][w1][w2] = 1;
				}
				if(g[i&1^1][w1][w2]){
					f[i&1][w1][w2] = min(f[i&1^1][w1][w2] + (p[i] - p[i-1]) * 1.0 / ((ll)m2[w1] * m3[w2]), f[i&1][w1][w2]);
					g[i&1][w1][w2] = 1;
				}
			}
		}
		while(((y[idx].y >= p[i] && y[idx].y < p[i+1]) || i == n) && idx < q){
			ans = 1e9;
			for(int w1 = 0; w1 < 31; w1++){
				for(int w2 = 0; w2 < 19; w2++){
					if((ll)m2[w1] * m3[w2] > mx) continue;
					if(g[i&1][w1][w2]){
						ans = min(ans, f[i&1][w1][w2] + (y[idx].y - p[i]) * 1.0 / ((ll)m2[w1] * m3[w2]));
					}
				}
			}
			y[idx++].ans = ans;
		}
	}
	sort(y, y + q, cmp);
	for(int i = 0; i < q; i++){
		cout << fixed << setprecision(8) << y[i].ans << '\n';
	}
	return 0;
}

```

---

## 作者：刘梓轩2010 (赞：3)

[题传](https://www.luogu.com.cn/problem/P11290)

## 题意

有一艘飞船，在一条射线上飞行，初始速度为 $0$，共有 $n$ 个加油站，分别在 $p_i$ 的位置上，每加一次油花费 $t_i$ 的时间，飞船的速度乘上油的类型 $x_i$，可以选择加或者不加，飞行不消耗油，$q$ 次询问，每次给出一个位置 $y_i$，让你回答从起点到 $y_i$ 的最短时间。

$1 \le n \le 10^5$，$1 \le q \le 10^5$，$p_i \le 10^9$，$t_i \le 10^9$，$1 \le x_i \le 4$，$1 \le y_i \le 10^9$。

## 思路

首先注意到精度要求 $10^{-6}$，而询问最多到 $10^9$，因此，速度大于 $10^{15}$ 是没有意义的，输出 $0$ 即可。

然后我们发现，$x_i$ 的值域很小，只有 $4$，只包含 $2$ 和 $3$ 两个质因子，在 $10^{15}$ 下，分别只有 $50$ 和 $32$ 次方，于是我们可以用质因子记录下来到每个加油站达到某个的速度的最短时间，设 $f_{i,j,k}$ 表示到了 $i$ 这个点，速度为 $2^j \times 3^k$ 的最短时间，设 $s2$ 表示当前点的 $x_i$ 质因子 $2$ 的个数，$s3$ 表示质因子 $3$ 的个数，那么达到这个速度要么是在之间的加油站已经达到了，要么是新加的油，转移方程即为 $f_{i,j,k}=\min{f_{i-1,j,k}+(p_i-p_{i-1})/(2^j \times 3^k),f_{i,j-s2,k-s3}+(p_i-p_{i-1})/(2^{j-s2} \times 3^{k-s3})+t_i}$。
需要注意边界和初始值。注意要预处理出来乘方。

把 $f$ 预处理完之后，现在我们来处理询问，对于每次询问，我们可以找到它前一个加油站（位置严格小于它），枚举到那一个加油站的速度，计算出最短时间。

但是还没完，如果你精心计算，你会发现 $f$ 数组的空间巨大，我们可以将询问离线下来，排序，这样就可以压掉第一维的位置，空间完全可以接受。

令 $2$ 的最大次幂为 $V$，$3$ 的最大次幂为 $B$，时间复杂度即为 $O(VBn+m)$，完全可以接受。

可结合代码食用。

## Code
```c++
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
#define fi first
#define se second
using namespace std;
const int N=1e5+10;
const int inf=0x3f3f3f3f3f3f3f3f;
const double eps=1e-6;
struct Node
{
	int p,t,x;
}sta[N];
int n,q;
pair<int,int> qry[N];
double f[50][32];
double ans[N];
double mi2[50],mi3[32];
signed main()
{
//	freopen("ship.in","r",stdin);
//	freopen("ship.out","w",stdout);
	cin.tie(0);
	cout.tie(0);
	ios::sync_with_stdio(false);
	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>sta[i].p>>sta[i].t>>sta[i].x;
	mi2[0]=mi3[0]=1;
	for(int i=1;i<=49;i++) mi2[i]=mi2[i-1]*2;
	for(int i=1;i<=31;i++) mi3[i]=mi3[i-1]*3;
	for(int i=1;i<=q;i++)
	{
		cin>>qry[i].fi;
		qry[i].se=i;
	}
	sort(qry+1,qry+q+1);
	int pos=1;
	for(int i=49;i>=0;i--)
	{
		for(int j=31;j>=0;j--)
		{
			f[i][j]=1e10;
		}
	}
	f[0][0]=0;
	sta[0]={0,0,0};
	for(int i=1;i<=q;i++)
	{
		while(pos<=n&&sta[pos].p<qry[i].fi)
		{
			int s1=0,s2=0;
			if(sta[pos].x==2) s1=1;
			if(sta[pos].x==3) s2=1;
			if(sta[pos].x==4) s1=2;
			for(int j=49;j>=0;j--)
			{
				for(int k=31;k>=0;k--)
				{
					f[j][k]=f[j][k]+1.0*(sta[pos].p-sta[pos-1].p)/mi2[j]/mi3[k];
					if(j-s1<0||k-s2<0||f[j-s1][k-s2]==1e10) continue;
					f[j][k]=min(f[j][k],f[j-s1][k-s2]+sta[pos].t+1.0*(sta[pos].p-sta[pos-1].p)/mi2[j-s1]/mi3[k-s2]);
				}
			}
			pos++;
		}
		double cnt=1e10;
		for(int j=49;j>=0;j--)
		{
			for(int k=31;k>=0;k--)
			{
				if(f[j][k]==1e10) continue;
				cnt=min(cnt,f[j][k]+1.0*(qry[i].fi-sta[pos-1].p)/mi2[j]/mi3[k]);
			}
		}
		ans[qry[i].se]=cnt;
	}
	for(int i=1;i<=q;i++) cout<<fixed<<setprecision(9)<<ans[i]<<endl;
	return 0;
}
```

---

## 作者：Jadonyzx (赞：2)

这是绿？感觉蓝。

首先由于本题要求精度范围内求值，那么大力猜想速度取值集合极小，不妨打表，发现对于 $10^9$ 的范围，速度取值约有 $900$ 种，考场打的标具体值忘了。

显然的背包问题，套上一个哈希映射转移，细节很多。

考虑到会超空间，因此可以滚动数组优化，那么又有一个问题，如何实现呢？

先对查询离线处理，二分查找查出其具体前一个加油站位置，根据位置大小排序后升序访问查询，若当前最左边的加油站 $dp$ 数组未转移，则转移到当前位置。

然后就因为以下原因考场爆到 $85$ 分：

1. 开了 long long。

2. 要特判 $x_i=1$ 的转移。

3. 整数读入用快读，而不能关闭同步流。

代码：


```cpp
#include<bits/stdc++.h>
#define maxn 100001
using namespace std;
namespace IO{
	inline int read(){
		int x=0,f=1;
		char ch=getchar();
		while(ch<'0'||ch>'9'){
			if(ch=='-')f=-1;
			ch=getchar();
		}
		while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
		return x*f;
	}
	inline void write(int x){
		if(x<0){putchar('-');x=-x;}
		if(x>=10)write(x/10);
		putchar(x%10+'0');return;
	}
}
using namespace IO;
int n,q,p[maxn],t[maxn],x[maxn];
long long mul2[100],mul3[100],mul4[100],tong[940];
int tot=0;
unordered_map<int,bool>Vis;
const int dt=2,inf=1e9;
double dp[2][940];
bool vis[maxn][940];
struct Query{int y,id,res;}query[maxn];
double ans[maxn];int lst=0;
inline bool cmp(Query aaa,Query bbb){return aaa.y<bbb.y;}
inline int lwb(int i){return lower_bound(tong+1,tong+1+tot,i)-(tong);}
inline void zhuanyi(int r){
	for(int i=lst;i<r;++i){
		int pre=i&1;
		int nxt=pre^1;
		for(int j=1;j<=tot;++j)dp[nxt][j]=1e9;
		if(x[i]==1){
			for(int j=1;j<=tot;++j){
				if(!vis[i][j])continue;
				dp[nxt][j]=dp[pre][j]+(p[i+1]-p[i])*1.00/tong[j];
				vis[i+1][j]=1;
			}
			continue;
		}
		for(int j=1;j<=tot;++j){
			if(!vis[i][j])continue;
			if(Vis[tong[j]*x[i]]){
				dp[nxt][lwb(tong[j]*x[i])]=min(dp[nxt][lwb(tong[j]*x[i])],dp[pre][j]+t[i]+(p[i+1]-p[i])*1.00/(tong[j]*x[i]));
				vis[i+1][lwb(tong[j]*x[i])]=1;
			}
			dp[nxt][j]=min(dp[nxt][j],dp[pre][j]+(p[i+1]-p[i])*1.00/tong[j]);
			vis[i+1][j]=1;
		}
	}
	lst=r;return;
}
signed main(){
// 	freopen("ship.in","r",stdin);
// 	freopen("ship.out","w",stdout);
	n=read();q=read();
	for(register int i=1;i<=n;++i){
		p[i]=read();
		t[i]=read();
		x[i]=read();
	}
	for(register int i=1;i<=q;++i){
		query[i].y=read();
		query[i].id=i;
		int L=1,R=n,mid,id=0;
		while(L<=R){
			mid=(L+R)/2;
			if(p[mid]<=query[i].y){
				id=mid;
				L=mid+1;
			}
			else R=mid-1;
		}
		query[i].res=id;
	}
	sort(query+1,query+1+q,cmp);
	mul2[0]=mul3[0]=mul4[0]=1;
	for(register int i=1;i<=49+dt;++i){
		if(i<=24+dt)mul4[i]=mul4[i-1]*4;
		if(i<=31+dt)mul3[i]=mul3[i-1]*3;
		mul2[i]=mul2[i-1]*2;
	}
	for(register int x=0;x<=24+dt;++x){
		for(register int y=0;y<=31+dt;++y){
			if(mul4[x]*mul3[y]>inf*1e6)break;
			for(register int z=0;z<=49+dt;++z){
				if(mul4[x]*mul3[y]*mul2[z]>inf*1e6)break;
				if(!Vis[mul4[x]*mul3[y]*mul2[z]]){
					Vis[mul4[x]*mul3[y]*mul2[z]]=1;
					tong[++tot]=mul4[x]*mul3[y]*mul2[z];
				}
			}
		}
	}
	p[0]=0;
	sort(tong+1,tong+1+tot);
	for(register int j=1;j<=tot;++j)dp[0][j]=1e9;
	vis[0][1]=1;dp[0][1]=0;
	for(register int i=1;i<=q;++i){
		if(query[i].res>lst)zhuanyi(query[i].res);
		lst=max(lst,query[i].res);
		double ANS=query[i].y;
		for(register int j=1;j<=tot;++j){
			if(!vis[query[i].res][j])continue;
			ANS=min(ANS,dp[query[i].res&1][j]+((double)query[i].y-p[query[i].res])*1.00/tong[j]);
		}
		for(register int j=1;j<=tot;++j){
			if(!vis[query[i].res][j])continue;
			ANS=min(ANS,dp[query[i].res&1][j]+t[query[i].res]+((double)query[i].y-p[query[i].res])*1.00/(tong[j]*x[query[i].res]));
		}
		ans[query[i].id]=ANS;
	}
	for(register int i=1;i<=q;++i)cout<<fixed<<setprecision(7)<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：Wf_yjqd (赞：2)

dp 状物。

首先先想到两维状态分别表示当前位置、当前速度，维护最短时间。

显然当前位置可以只记录加油站，对于每个询问再同理转移一次。

容易注意到编号为 $1$ 的油加了一定更劣，所以可以认为每次速度至少乘 $2$。而当速度数值上超过路程时，剩余路程所需时间不超过 $1$ 个单位，这时再加油一定不优。

所以最多加油 $30$ 次编号为 $2$ 的油，$19$ 次编号为 $3$ 的油。把编号为 $4$ 的油视为两个单位编号为 $2$ 的油，再用加油次数表示出速度，可以得到约 $n\log^2 V$ 量级的状态数。

只需要双指针统计询问的答案就可以省去 $n$ 倍的空间，所以不用担心开不下。

写出转移式子并简单移项发现可以使两侧互不相干，所以更新只需记录前缀最小值。

$\operatorname{O}((n+q)\log^2 V)$。

---


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
const int maxn=1e5+26,mx2=31,mx3=20,mx=1e9+26;
const ll mxx=1e17+26;
namespace Ai_I{
    inline int read(){
        int x=0,f=1;
        char c=getchar();
        while(c<'0'||c>'9'){
            if(c=='-')
                f=-1;
            c=getchar();
        }
        while(c>='0'&&c<='9'){
            x=x*10+c-'0';
            c=getchar();
        }
        return x*f;
    }
}
using namespace Ai_I;
int n,q,y[maxn],p[maxn];
db mn[mx2][mx3],ans[maxn];
ll pw[mx2][mx3];
bool vis[mx2][mx3];
struct Gas{
    int p,t,x;
}g[maxn];
inline void Solve(int x){
    ans[x]=mxx;
    for(int k=0;k<mx2;k++)
        for(int l=0;l<mx3&&!vis[k][l];l++)
            ans[x]=min(ans[x],mn[k][l]+db(y[x])/pw[k][l]);
    return ;
}
int main(){
    n=read();q=read();
    pw[0][0]=1;
    for(int i=1;i<mx2;i++)
        pw[i][0]=pw[i-1][0]*2;
    for(int i=0;i<mx2-1;i++)
        for(int j=1;j<mx3;j++){
            pw[i][j]=pw[i][j-1]*3;
            if(pw[i][j]>mx){
                while(j+1<mx3)
                    vis[i][++j]=1;
                break;
            }
        }
    for(int j=1;j<mx3;j++)
        vis[mx2-1][j]=1;
    for(int i=1;i<=n;i++)
        g[i]={read(),read(),read()};
    for(int i=1;i<=q;i++){
        y[i]=read();p[i]=i;
    }
    sort(p+1,p+q+1,[](int xy,int zb){
        return y[xy]<y[zb];
    });
    for(int k=0;k<mx2;k++)
        for(int l=0;l<mx3&&!vis[k][l];l++)
            mn[k][l]=mxx;
    mn[0][0]=0;
    int j=1;
    for(int i=1,dk,dl;i<=n&&j<=q;i++){
        while(j<=q&&y[p[j]]<=g[i].p)
            Solve(p[j++]);
        if(g[i].x==1)
            continue;
        dk=(g[i].x&1)?0:(g[i].x==2?1:2);
        dl=g[i].x&1;
        for(int k=mx2-1;k>=dk;k--)
            for(int l=mx3-1;l>=dl;l--)
                if(!vis[k][l])
                    mn[k][l]=min(mn[k][l],mn[k-dk][l-dl]+db(g[i].p)/pw[k-dk][l-dl]+g[i].t-db(g[i].p)/pw[k][l]);
    }
    while(j<=q)
        Solve(p[j++]);
    for(int i=1;i<=q;i++)
        printf("%.8lf\n",ans[i]);
    return 0;
}
```

---

## 作者：2huk (赞：2)

显然 $x_i=1$ 的加油站不可能使用。因为速度没变，而且还多浪费了 $t_i$ 的时间。

而且注意到同一种 $x$ 的加油站最多只会使用 $\log_x V$ 次。比如已经使用了 $40$ 次 $x_i=2$ 的加油站了，也就是说此时你的速度至少是 $2^{40}$。而此时距离终点最多 $10^9$，也就是不需要 $1$ 秒就能到达。但是再使用一次 $x_i=2$ 的加油站所花的时间 $t_i \ge 1$，一定不优。

所以考虑 DP。设 $f(i, a, b, c)$ 表示到达第 $i$ 个加油站，且已经用了 $a$ 个 $x=2$，$b$ 个 $x=3$，$c$ 个 $x=4$ 的加油站，最小花费时间是多少。这个状态存在的前提是 $2^a \times 3^b \times 4^c \le 10^9$。算一下这样的 $(a, b, c)$ 的数量 $\le 2000$。

转移极易。对于计算答案，找到终点 $y$ 前的最后一个加油站 $x$，枚举此时的 $(a, b, c)$ 即可。

好对啊好对啊。时间复杂度 $\mathcal O(n \log_2 V \log_3 V \log_4V)$。洛谷神机 2s 跑 $2 \times 10^8$ 稳啦。

但注意到 $2 \times 10^8$ 个 `float`/`double` 空间开不下。考虑滚动数组。这样询问就必须离线了。

```cpp
#include "bits/stdc++.h"

using namespace std;

#define int long long

const int N = 1e5 + 10;

int n, q;
double f[2][2000];

struct Node {
  int t, p, x;
}a[N];

int cnt;

double calc(int x, int y, int z) {
  double res = 1;
  while (x -- ) res *= 2;
  while (y -- ) res *= 3;
  while (z -- ) res *= 4;
  return res;
}

void chkmin(double &x, double y) {
  x = x < y ? x : y;
}

vector<int> Q, QQ, id;
double res[N];

struct IJK {
	int j, k, t, val;
};
vector<IJK> S;
int di[100][100][100];

signed main() {
	cnt = 0;
	for (int i = 0; i < 35; ++ i )
		for (int j = 0; j < 25; ++ j )
			for (int t = 0; t < 20; ++ t )
				if (calc(i, j, t) <= 2e9) {
					di[i][j][t] = S.size();
					S.push_back({i, j, t, (int)calc(i, j, t)});
				}
	
  cin >> n >> q;
  for (int i = 1; i <= n; ++ i ) {
    int t, p, x;
    cin >> p >> t >> x;
    if (x != 1) a[ ++ cnt] = {t, p, x};
  }
  n = cnt;
  
  for (int i = 0; i < q; ++ i ) {
  	int y;
  	cin >> y;
  	Q.push_back(y);
  	id.push_back(i);
  	QQ.push_back(y);
  	res[i] = 1e20;
  }
  
  sort(id.begin(), id.end(),
  	[&](int x, int y) {
  		return Q[x] < Q[y];
  	});
  sort(QQ.begin(), QQ.end());
	
  for (int i = 0; i < 2; ++ i )
    for (int j = 0; j < 2000; ++ j )
			f[i][j] = 1e20;

  f[0][0] = 0;
  a[n + 1].p = 2e9;
  
  for (int i = 0; i < q; ++ i ) {
  	res[i] = Q[i];
  }
  
  for (int i = 1; i <= n; ++ i ) {
  	int L = lower_bound(QQ.begin(), QQ.end(), a[i].p) - QQ.begin();
  	int R = lower_bound(QQ.begin(), QQ.end(), a[i + 1].p) - QQ.begin() - 1;
  	
  	for (auto e : S) {
  		int j = e.j, k = e.k, t = e.t;
      // 这个是否加速
      f[i & 1][di[j][k][t]] = f[i - 1 & 1][di[j][k][t]] + 1.0 * (a[i].p - a[i - 1].p) / e.val;
      if (j && a[i].x == 2) {
        chkmin(f[i & 1][di[j][k][t]], f[i - 1 & 1][di[j - 1][k][t]] + a[i].t + (a[i].p - a[i - 1].p) * 2.0 / e.val);
      }
      if (k && a[i].x == 3) {
        chkmin(f[i & 1][di[j][k][t]], f[i - 1 & 1][di[j][k - 1][t]] + a[i].t + (a[i].p - a[i - 1].p) * 3.0 / e.val);
      }
      if (t && a[i].x == 4) {
        chkmin(f[i & 1][di[j][k][t]], f[i - 1 & 1][di[j][k][t - 1]] + a[i].t + (a[i].p - a[i - 1].p) * 4.0 / e.val);
      }
    
	    for (int u = L; u <= R; ++ u )
	    	chkmin(res[id[u]], f[i & 1][di[j][k][t]] + 1.0 * (QQ[u] - a[i].p) / e.val);
    }
  }

  for (int i = 0; i < q; ++ i ) {
  	cout << fixed << setprecision(7) << res[i] << '\n';
  }

  return 0;
}
```

---

## 作者：harmis_yz (赞：1)

## 分析

记我们选的加油站的下标序列为 $a$，其中 $a_1=0$，那么有代价为：$\sum\limits_{i=2}^{|a|} t_{a_i}+\frac{p_{a_i}-p_{a_{i-1}}}{\prod\limits_{j=1}^{i-1}x_{a_j}}+\frac{y-p_{a_{|a|}}}{\prod\limits_{j=1}^{|a|}x_{a_j}}$。我们把式子化简一下，会发现是：$(\sum\limits_{i-1}^{|a|}t_{a_i}+\frac{(x_{a_i}-1)p_{a_i}}{\prod\limits_{j=1}^{i}x_{a_j}})+\frac{y}{\prod\limits_{j=1}^{|a|}x_{a_j}}$。不难发现，当 $\prod\limits_{j=1}^{|a|}x_{a_j}$ 一定时，只需要满足前面的式子的值最小就行了。

注意到精度只有 $10^{-6}$，也就是说，当 $\prod\limits_{j=1}^{|a|}x_{a_j}$ 大到某个值时，再大是对答案没有贡献的。粗略算一下大概为 $10^{15}$。因为 $x_i=1$ 的加油站没用，所以最终可能的值的数量等于用 $2,3,4$ 乘起来得到的值 $\le 10^{15}$ 的数量。暴力搜索可以得到是 $824$ 个（算了 $1$ 这个值）。所以就可以直接跑背包解决了。时间复杂度 $O(na)$，$a=824$。

## 代码

```cpp
il void solve(){
	dfs(1),sort(v.begin(),v.end()),vis.clear();
	int len=(int)(v.size());
	for(re int i=0;i<len;++i) f[i]=1000000000000000.0,vis[v[i]]=i;
	f[0]=0.0;
	n=rd,q=rd;
	for(re int i=1;i<=n;++i) cin>>p[i]>>t[i]>>x[i];
	for(re int i=1;i<=q;++i) cin>>Q[i].y,Q[i].id=i;
	sort(Q+1,Q+q+1),p[n+1]=1e18;
	for(re int i=1,j=1;i<=n+1;++i){
		while(j<=q&&Q[j].y<p[i]){
			double Min=1000000000000000.0;
			for(re int k=0;k<len;++k){
				Min=min(Min,f[k]+(double)(Q[j].y*1.0/v[k]));	
			}
			ans[Q[j].id]=Min;
			++j;
		}
		if(i<=n&&x[i]>1){
			for(re int k=len-1;k>=1;--k){
				if((int)v[k]%(int)x[i]==0) f[k]=min(f[k],f[vis[v[k]/x[i]]]+(double)((x[i]-1)*p[i]*1.0/v[k])+t[i]);
			}
		}
	}
	for(re int i=1;i<=q;++i) printf("%.10lf\n",ans[i]);
    return ;
}
```

---

## 作者：szh_AK_all (赞：1)

### 分析
考虑到对于每个加油站，飞船要么加油要么不加油，所以可以联想到背包。一个直观的想法是设 $f_i$ 表示到达第 $i$ 个加油站所需的最短时间，但是从第 $i-1$ 个加油站转移到第 $i$ 个加油站时，我们发现飞船的速度是很重要的，所以更有前途的想法是，设 $f_{i,j}$ 表示到达第 $i$ 个加油站，且到达第 $i$ 个加油站时速度恰好为 $j$ 的最短时间。

转移分为两种。若当前在第 $i$ 个加油站加油，那么在第 $i-1$ 个加油站时速度为 $\frac{j}{x_i}$，并且此时应该满足 $j$ 是 $x_i$ 的倍数，所需的时间为 $f_{i-1,\frac{j}{x_i}}+\frac{p_i-p_{i-1}}{\frac{j}{x_i}}+t_i$。若当前不在第 $i$ 个加油站加油，那么在第 $i-1$ 个加油站时速度也为 $j$，所需的时间为 $f_{i-1,j}+\frac{p_i-p_{i-1}}{j}$。

由于速度的上限可以很大，所以我们单纯的这样转移是很浪费的。考虑到我们的答案与标准答案的误差只需在 $10^{-6}$ 以内，而路程最大为 $10^9$，所以当飞船的速度超过 $10^{15}$，我们便不需要过多考虑了。也就是说，我们 dp 状态中的 $j$ 最大不超过 $10^{15}$。

此时你会发现这个状态还是很浪费。考虑到这个 $j$ 是由若干 $2$ 和 $3$ 的乘积组在一起的，然后爆搜一下发现，这样的 $j$ 只有 $824$ 个！

接下来就好办了，哈希出每个合法的速度，然后稍微改一改转移就行了。

对于每次询问的 $y$，我们可以二分出距离 $y$ 最近的加油站 $x$，然后枚举速度 $j$，找出最小的 $f_{x,j}+\frac{y-p_x}{j}$ 即可。

但是此时你还会发现空间炸了，由于每个 $f_{i,j}$ 只与前面的 $f_{i-1,k}$ 有关，所以可以进行滚动数组优化。

但是滚动完之后，如何处理询问？可以离线的将每个询问存下来，每次处理完第 $i$ 个加油站的 $f$ 值后，更新所有与第 $i$ 个加油站有关的询问即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

struct node {
	int p, t, x;
} s[100005];
int y[100005];
double f[3][1505];
unordered_map<long long, int>qq;
int cnt;
long long a[150005];
vector<int>g[100005];
double an[100005];

void dfs(long long x) {
	if (x > 1e15)
		return;
	if (qq[x])
		return;
	qq[x] = ++cnt;
	a[cnt] = x;
	dfs(x * 2);
	dfs(x * 3);
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	dfs(1);
	int n, q;
	cin >> n >> q;
	for (int i = 1; i <= n; i++)
		cin >> s[i].p >> s[i].t >> s[i].x;
	for (int i = 0; i <= 1; i++)
		for (int j = 0; j <= 850; j++)
			f[i][j] = 1000000000;
	for (int i = 1; i <= q; i++) {
		cin >> y[i];
		int l = 1, r = n, ans = 0;
		while (l <= r) {
			int mid = (l + r) / 2;
			if (s[mid].p <= y[i]) {
				ans = mid;
				l = mid + 1;
			} else
				r = mid - 1;
		}
		g[ans].push_back(i);
	}
	f[0][1] = 0;
	for (int k : g[0])
		an[k] = y[k];
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= cnt; j++) {
			int su = a[j];
			if (su % s[i].x == 0 && s[i].x > 1)
				f[i & 1][j] = min(f[i & 1][j], f[(i - 1) & 1][qq[su / s[i].x]] + (s[i].p - s[i - 1].p) * 1.0 /
				                  (su / s[i].x) + s[i].t);
			f[i & 1][j] = min(f[i & 1][j], f[(i - 1) & 1][j] + (s[i].p - s[i - 1].p) * 1.0 / su);
		}
		for (int k : g[i]) {
			an[k] = 1000000000;
			for (int j = 1; j <= cnt; j++)
				an[k] = min(an[k], f[i & 1][j] + (y[k] - s[i].p) * 1.0 / a[j]);
		}
		for (int j = 1; j <= cnt; j++)
			f[(i - 1) & 1][j] = 1000000000;
	}
	for (int i = 1; i <= q; i++)
		cout << setprecision(8) << fixed << an[i] << "\n";
}
```

---

## 作者：gcx12012 (赞：1)

### 前言
典中典。
### Solution
显然速度达到一定大小的时候再往上加一定不优，由 $t=\frac{x}{v}$ 即可得出。

我们可以设个上限值，然后在上限值范围内进行 dp。

但是我们发现 $v$ 的取值还是有点大，注意到题目中的加粗字 $1\le x\le 4$，这说明组成 $v$ 的质因数只有 2 和 3。

于是我们可以设 $f_{i,j,k}$ 为经过前 $i$ 个加油站，当前 $v=2^j\times 3^k$ 时的最小时间，转移方程比较显然就不写了。

然后就做完了，时间复杂度为 $O(n \log^2 V)$，如果害怕空间爆掉可以写个滚动数组。
### Code

```cpp
#include<bits/stdc++.h>
#include<cmath>
#define ll long long
#define lll __int128
#define ull unsigned long long
#define N 100010
#define For(i,a,b) for(int i=a;i<=b;++i)
#define Rof(i,a,b) for(int i=a;i>=b;--i)
#define ls x<<1
#define rs x<<1|1
#define lson ls,l,mid
#define rson rs,mid+1,r 
#define pb push_back
#define mk make_pair
#define pque priority_queue
#define pii pair<int,int>

using namespace std;
bool st;
const double inf=1e12;
double f[2][35][35];
struct node{
    int x,t,num;
}a[N];
struct ask{
    int t,bh;
}b[N];
double ans[N];
int n,q;
bool ed;

ll read(){
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}


int main()
{
	//fprintf(stderr,"%.2lf",(double)(&ed-&st)/1024/1024);
	//freopen("ship.in","r",stdin);
	//freopen("ship.out","w",stdout);
	n=read(),q=read();
    For(i,1,n) a[i].x=read(),a[i].t=read(),a[i].num=read();
    For(i,1,q) b[i].t=read(),b[i].bh=i;
    sort(b+1,b+q+1,[&](ask x,ask y){return x.t<y.t;});
    For(i,0,1){
        For(j,0,34){
            For(k,0,34){
                f[i][j][k]=inf;
            }
        }
    }
    f[0][0][0]=0;
    int now=0;
    For(i,1,q){
        while(now<n && a[now+1].x<=b[i].t){
            int op=now&1;
            double now1=1;
            For(j,0,34){
                double now2=now1;
                For(k,0,34){
                    if(now2>inf) break;
                    f[op^1][j][k]=f[op][j][k]+(double)(a[now+1].x-a[now].x)*1.0/now2;
                    now2*=3;
                }
                now1*=2;
            }
            int p1=0,p2=0;
            if(a[now+1].num==2) p1=1;
            else if(a[now+1].num==3) p2=1;
            else if(a[now+1].num==4) p1=2;    
            now1=1;
            For(j,0,34-p1){
                double now2=now1;
                For(k,0,34-p2){
                    if(now2>inf) break;
                    f[op^1][j+p1][k+p2]=min(f[op^1][j+p1][k+p2],f[op][j][k]+(double)(a[now+1].x-a[now].x)*1.0/now2+(double)a[now+1].t);
                    now2*=3;
                }
                now1*=2;
            }
            now++;
        }
        double now1=1,nowans=inf;
        For(j,0,34){
            double now2=now1;
            For(k,0,34){
                if(now2>inf) break;
                nowans=min(nowans,f[now&1][j][k]+(double)(b[i].t-a[now].x)*1.0/now2);
                now2*=3;
            }
            now1*=2;
        }
        ans[b[i].bh]=nowans;
    }
    For(i,1,q) printf("%.10lf\n",ans[i]);
	return 0;
}
/*

*/
```

---

## 作者：sansesantongshun (赞：1)

这题我赛时没想出正解，在赛后才明白怎么做。

首先通过推导公式，发现该题无法贪心。

然后我想到一个 dp，以第几个加油站为第一维，以速度为第二维，可以轻松通过速度转移状态。但是这样 dp 会使速度达到指数级别，简直爆炸。

赛后我反应过来，虽然速度的值域看似达到指数级，但速度的个数远远没有达到这种数量。为什么呢？

首先我们发现速度值域根本没有这么大，因为如果速度过大，会导致加速减少的时间很少，而在加油上浪费了更多的时间，不是最优解。而加速减少的时间至少为 $1$，即速度值域上界则为 $p$ 的值域上界。

但这样也 AC 不了。我们继续推导发现燃油编号为 $1$ 可以忽略不计，为 $4$ 可以拆成两个 $2$，所以速度一定是 $2$ 的非负整数次方乘上 $3$ 的非负整数次方。

这样 dp 就很好转移了。第一维表示第几个加油站，第二维表示 $2$ 的指数，第三维则表示 $3$ 的指数，然后通过加油站转移状态即可。查询时，首先找到最后一个小于等于目标节点的加油站（可以使用二分），然后从这个加油站的每个状态转移出答案，并取最小值即可。

这样我们就得到了一个 $O(n\log^2 n)$ 的算法。由于空间耗用较大，考虑使用滚动数组优化 dp，且把询问离线下来升序排序，边转移边处理询问，这会把空间优化至线性，还会意外地使时间得到优化。

AC 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005][3],x,y,z,num=1,g2[5]={0,0,1,0,2},g3[5]={0,0,0,1,0};
long long p2[30],p3[19];
double c[30][19],d[30][19],aans,ans[100005];
struct node
{
	int id,x;
} b[100005];
bool operator<(node x,node y)
{
	return x.x<y.x;
}
int main()
{
	cin>>n>>m;
	for (int i=1;i<=n;++i)
	scanf("%d%d%d",&a[i][0],&a[i][1],&a[i][2]);
	a[n+1][0]=0x7fffffff;
	for (int i=1;i<=m;++i)
	{
		b[i].id=i;
		scanf("%d",&b[i].x);
	}
	sort(b+1,b+m+1);//离线处理
	p2[0]=1;
	p3[0]=1;
	for (int i=1;i<=29;++i)
	p2[i]=p2[i-1]<<1;
	for (int i=1;i<=18;++i)
	p3[i]=3*p3[i-1];//预处理2、3的幂次方
	for (int i=0;i<=29;++i)
	for (int j=0;j<=18 && p2[i]*p3[j]<=1000000000;++j)
	c[i][j]=1e18;
	c[0][0]=0;//预处理
	for (int i=1;i<=n;++i)
	{
		x=a[i][0];
		y=a[i][1];
		z=a[i][2];
		memcpy(d,c,sizeof(c));//滚动数组
		for (int j=0;j<=29;++j)
		for (int k=0;k<=18 && p2[j]*p3[k]<=1000000000;++k)
		{
			c[j][k]=d[j][k]+(double)(x-a[i-1][0])/(p2[j]*p3[k]);
			if (j>=g2[z] && k>=g3[z])
			c[j][k]=min(c[j][k],d[j-g2[z]][k-g3[z]]+(double)(x-a[i-1][0])/(p2[j-g2[z]]*p3[k-g3[z]])+y);
		}//转移速度
		for (num;num<=m && b[num].x<=a[i+1][0];++num)
		{
			aans=1e18;
			for (int j=0;j<=29;++j)
			for (int k=0;k<=18 && p2[j]*p3[k]<=1000000000;++k)
			aans=min(aans,c[j][k]+(double)(b[num].x-x)/(p2[j]*p3[k]));
			ans[b[num].id]=aans;
		}//处理询问
	}
	for (int i=1;i<=m;++i)
	printf("%.9lf\n",ans[i]);//使用printf以减小误差
}
```

---

## 作者：Hoks (赞：1)

## 前言
有点唐了，这题写了好久。
## 思路分析
看到这个题面感觉很分段函数啊。

感受下这个答案应该就是一个分段函数的形式，但是看看这个方向很不可做。

感性理解一下，前面加油可能耗更多时间，但是对于一个距离很远的地方也就会更优。

那这就启发我们把询问离线，按照坐标从小到大回答。

接着就是处理决策的问题了。

每个加油站都有不同的决策，感觉很难做？

那就去观察性质。

直接看数据范围，发现加油至少要 $1$ 秒，而距离最远也就只有 $10^9$。

也就是当我们的速度 $\ge10^9$ 时加油就没有意义了，加油严格更劣。

然后我们来算下 $10^9$ 内可能得到的速度数量。

粗略估计而言是 $\log_210^9\times\log_310^9\thickapprox564$，实际而言这两个幂次不能同时取到最大值，随便打个表数下可以发现只有 $306$ 种。

这就启发我们对每种速度去做了。

实际而言，每种速度只需要保留一个到达这个速度的时间和位置即可。

因为对于同一种速度，我们取两种不同的位置和时间画出图像，就是两条斜率相同的斜线，这显然是单调的。

所以我们把询问离线下来按照升序枚举询问/加油站，然后用所有的速度算一下到达这个点的最小时间，再尝试加油转移新的速度就行了。

可能还是代码好理解一点。
## 代码

```cpp
#include<bits/stdc++.h>
#define ls (p<<1)
#define rs (ls|1)
#define mid ((l+r)>>1)
#define get(x) (lower_bound(a+1,a+1+cur,x)-a)
#define int long long
using namespace std;
const int N=2e5+10,V=315,M=35,INF=1e9,mod=998244353;bool qwq;
int n,m,cur,tot,a[N],p[N],t[N],tp[N],c[N];
tuple<int,int,int>b[V];int mp[M][M],id[N];vector<int>ask[N];
pair<double,int>q[V],qq[V];double ans[N],tt[N];bool awa;
namespace Fast_IO
{
    static char buf[1000000],*paa=buf,*pd=buf,out[10000000];int length=0;
    #define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
    inline int read()
    {
        int x(0),t(1);char fc(getchar());
        while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
        while(isdigit(fc)) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
        return x*t;
    }
    inline void flush(){fwrite(out,1,length,stdout);length=0;}
    inline void put(char c){if(length==9999999) flush();out[length++]=c;}
    inline void put(string s){for(char c:s) put(c);}
    inline void print(int x)
    {
        if(x<0) put('-'),x=-x;
        if(x>9) print(x/10);
        put(x%10+'0');
    }
    inline bool chk(char c) { return !(c>='a'&&c<='z'||c>='A'&&c<='Z'||c>='0'&&c<='9'||c=='|'||c=='-'); }
    inline bool ck(char c) { return c!='\n'&&c!='\r'&&c!=-1&&c!=' '; }
    inline void rd(char s[],int&n)
    {
        s[++n]=getchar();
        while(chk(s[n])) s[n]=getchar();
        while(ck(s[n])) s[++n]=getchar();
        n--;
    }
}
using namespace Fast_IO;
inline void prework()
{
    long long lim=1000000000,op=1,s;
    for(int i=0;i<31&&op<lim;i++,op*=2)
    {
        s=op;
        for(int j=0;j<M&&s<lim;j++,s*=3)
            mp[i][j]=++tot,b[tot]={s,i,j};
    }
}
inline double calc(int x,int i){return max(0ll,x-q[i].second)*1.0/get<0>(b[i])+q[i].first;}
inline void solve()
{
    n=read();m=read();for(int i=1;i<=n;i++) a[i]=p[i]=read(),t[i]=read(),tp[i]=read();
    cur=n;for(int i=1;i<=m;i++) c[i]=a[++cur]=read();
    sort(a+1,a+1+cur);cur=unique(a+1,a+1+cur)-a-1;
    for(int i=1;i<=n;i++) id[get(p[i])]=i;
    for(int i=1;i<=m;i++) ask[get(c[i])].emplace_back(i);
    for(int i=2;i<=tot;i++) q[i]={INF,0};q[1]={0,0};
    for(int i=1;i<=cur;i++)
    {
        tt[i]=INF;for(int j=1;j<=tot;j++) tt[i]=min(tt[i],calc(a[i],j));
        for(auto x:ask[i]) ans[x]=tt[i];if(!id[i]) continue;
        for(int j=1;j<=tot;j++)
        {
            auto [v,l,r]=b[j];if(tp[id[i]]==2) l++;
            if(tp[id[i]]==3) r++;if(tp[id[i]]==4) l++,l++;
            int to=mp[l][r];if(!to) continue;
            if(calc(a[i],to)>calc(a[i],j)+t[id[i]])
                qq[to]={calc(a[i],j)+t[id[i]],a[i]};
        }for(int j=1;j<=tot;j++) if(qq[j].second) q[j]=qq[j],qq[j]={0,0};
    }for(int i=1;i<=m;i++) printf("%.9lf\n",ans[i]);
}
signed main()
{
    // system("fc print2.ans 1.out");
    // freopen("print3.in","r",stdin);
    // freopen("1.out","w",stdout);
    int T=1;prework();
    // cout<<(&awa-&qwq)/1024.0/1024.0;
    // T=read();
    while(T--) solve();
    genshin:;flush();return 0;
}
```

---

## 作者：liuziqin (赞：0)

## 思路

核心思想：背包 dp。

考虑对于一段距离 $p_i-p_j$ ，设当前速度为 $v$，若在 $p_j$ 出加油更优，仅当 $\frac{(p_i-p_j)}{vx_j}+t_j\le\frac{p_i-p_j}{v}$，由于 $1\le p_i\le10^9$，$1\le t_i\le 10^9$，因此当 $v\ge10^9$ 时，加油一定不优，因此如果加油更优，$v$ 一定 $\le 10^9$。因此 $x_i\ge 2$ 的情况可以直接枚举，而 $x_i=1$ 的情况一定不优。

我们设 $f_{i,t1,t2,t3}$ 表示枚举到第 $i$ 位，2 的数量为 $t1$，3 的数量为 $t2$，4 的数量为 $t3$ 所需的最短时间。

由于 $4=2^2$，因此我们可以把第四维优化掉。

接下来考虑如何转移。

首先， 
$$
f_{i,t1,t2}=f_{j,t1,t2}+\frac{p_i-p_j} {2^{t1}3^{t2}}
$$

若 $x_i=2$，则
$$
f_{i,t1,t2}=f_{j,t1-1,t2}+\frac{p_i-p_j}{2^{t1-1}3^{t2}}+t_i
$$

若 $x_i=3$，则 
$$
f_{i,t1,t2}=f_{j,t1,t2-1}+\frac{p_i-p_j}{2^{t1}3^{t2-1}}+t_i
$$

若 $x_i=4$，则 
$$
f_{i,t1,t2}=f_{j,t1-2,t2}+\frac{(p_i-p_j)}{2^{t1-2}3^{t2}}+t_i
$$

然而，这还是不能 A 掉这题，因为转移时 $n^2$ 级别的，因此考虑优化。

我们记 $val(i,j)=2^i\times 3^j$，因此对于第一个式子，我们以下形式表示：

$$
f_{i,t1,t2}=\max(f_{j,t1,t2}+\frac{(p_i-p_j)}{val(t1,t2)})\\\\
=\max(f_{j,t1,t2}-\frac{p_j}{val(t1,t2)})+\frac{p_i}{val(t1,t2)}
$$
对于其它式子我们也都能用类似的方法进行化简，因此只需对 $\max(f_j-\frac{p_j}{val(t1,t2)})$ 做一遍前缀和优化即可。
## Code

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
const double INF=1e9;
double t[N];
int x[N],p[N],tot=0;
vector<vector<double> >g[N];
double calc[65][40];
signed main(){
	int n,q;
	cin>>n>>q;
	calc[0][0]=1;
	for(int i=0;i<=30;i++)
	for(int j=0;j<=20;j++){
		if(!i&&!j)continue;
		if(i)calc[i][j]=calc[i-1][j]*2;
		if(j)calc[i][j]=calc[i][j-1]*3;
		if(calc[i][j]>INF)break;//这就代表目前值已经没有意义
	}
	for(int i=1;i<=n;i++){
		int a,b,c;
		cin>>a>>b>>c;
		if(c==1)continue;
		p[++tot]=a;
		t[tot]=b;
		x[tot]=c;//去掉x[i]=1的无意义情况
	}
	n=tot;
	int sum1=0,sum2=0;
	for(int i=0;i<=n;i++){
		g[i].resize(30);
		for(int j=0;j<=30;j++)
		for(int k=0;k<=20;k++){
			if(calc[j][k]>INF)break;
			g[i][j].push_back(INF);
		}//vector减少无意义的空间浪费
	}
	g[0][0][0]=0;//dp初始化
	for(int i=1;i<=n;i++){
		if(x[i]==2)sum1++;
		if(x[i]==3)sum2++;
		if(x[i]==4)sum1+=2;
		sum1=min(sum1,30);
		sum2=min(sum2,20);
		for(int t1=0;t1<=sum1;t1++)
		for(int t2=0;t2<=sum2;t2++){
			double v0=calc[t1][t2];
			if(v0>INF||!v0)break;
			g[i][t1][t2]=min(g[i][t1][t2],g[i-1][t1][t2]+(double)p[i]/v0);
			int t1c=t1,t2c=t2;
			if(x[i]==2)t1c--,v0/=2;
			if(x[i]==3)t2c--,v0/=3;
			if(x[i]==4)t1c-=2,v0/=4;
			if(t1c<0||t2c<0)continue;
			g[i][t1][t2]=min(g[i][t1][t2],g[i-1][t1c][t2c]+(double)p[i]/v0+t[i]);//dp转移
		}
		for(int t1=0;t1<=sum1;t1++)
		for(int t2=0;t2<=sum2;t2++){
			if(calc[t1][t2]>INF)break;
			g[i][t1][t2]=min(g[i-1][t1][t2],g[i][t1][t2]-(double)p[i]/calc[t1][t2]);//前缀和优化
		}
	}
	while(q--){
		double y;
		cin>>y;
		double ans=y;
		int i=(upper_bound(p+1,p+n+1,y))-p-1;
		for(int t1=0;t1<=sum1;t1++)
		for(int t2=0;t2<=sum2;t2++){
			if(calc[t1][t2]>INF)break;
			ans=min(ans,g[i][t1][t2]+y/calc[t1][t2]);
		}//查询
		printf("%.8lf\n",ans);//输出
	}
}
```

---

## 作者：fujiayu (赞：0)

# P11290 飞船
---
## 思路：

观察到此题为“求最大值或最小值”类问题，猜测做法为二分或 $DP$。

经推测可得此题不具有明显贪心性质（指即使选择当前加油站会使在之后不选择其他加油站的情况下总时间变长，答案中也可能含有当前加油站），贪心做法不存在或较难思考，所以选择 $DP$。

观察题目，发现变量共有 $3$ 个，分别为位置 $p$，速度 $v$，时间 $t$，由于最终要求的是时间，所以设 $f_{i,j}$ 为走到 $i$，速度为 $j$ 的最短时间，考虑优化。

由于需要用到的位置只有 $n$ 个加油站，把 $i$ 优化为走到加油站 $i$。

注意到速度只能是 $2^x\times3^y$ 的形式且 $\le 10^9$，把 $j$ 拆成 $x,y$，表示当前的速度为 $2^x\times3^y$。

**核心优化：**$y\le10^9$，而初始速度为 $1$，所以速度不会超过 $3\times10^9$，这样一定不优，因为加油最少也要消耗 $1$ 秒，而当速度超过 $3\times10^9$ 时需要的时间不足 $\frac{1}{3}$ 秒，即使 $\times$ 的是最高的 $4$，按原速也只需要不到 $\frac{1}{3}$ 秒，所以 $2^x\times3^y\le3\times10^9$，由于加油站位置等原因只需要把 $x,y$ 开到 $30,19$ 即可。

优化后状态 $f_{i,x,y}$ 表示走到第 $i$ 个加油站，速度为 $2^x\times3^y$ 的最短时间。

考虑状态转移方程，每个加油站有选和不选两种状态，所以：

$$
res=
\begin{cases}
f_{i-1,x-1,y}+t_{i-1}& (x_{i-1}=2) \\
f_{i-1,x,y-1}+t_{i-1}& (x_{i-1}=3) \\
f_{i-1,x-2,y}+t_{i-1}& (x_{i-1}=4)
\end{cases}
$$
$$
f_{i,x,y}=\min(f_{i-1,x,y},res)+(p_i-p_{i-1})\div(2^x\times3^y)
$$

其中 $res$ 表示选择加油站 $i-1$ 的状态，根据 $x_{i-1}$ 分类讨论速度。

$f_{i-1,x,y}$ 表示不选择加油站 $i-1$ 的状态，速度不变。

最后加上速度为 $2^x\times3^y$ 时从 $p_{i-1}$ 走到 $p_i$ 的时间 $(p_i-p_{i-1})\div(2^x\times3^y)$。

初始值为 $f_{0,0,0}=0$。

再额外加入一个加油站 $a_{n+1}=(1e10,0,1)$，以免越界。

询问时，输入距离 $y$，先二分查找出第一个位置 $>y$ 的加油站 $pp$，表示终点在 $pp-1\sim pp$ 上，取 $\min(f_{pp,i,j}-(p_{pp}-y)\div(2^i\times3^j)$。

## 代码：

不能开 `long double`，否则会 `MLE`。

```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
#define int long long

const int N = 100010;
const int M2=31, M3=20;

int n, q;
double p[N];
int t[N], v[N];
int p2[N], p3[N];
double y, fs[N][31][20];

signed main()
{
	//freopen("ship.in", "r", stdin);
	//freopen("ship.out", "w", stdout);
	for(int i=0; i<N; i++)
		for(int x=0; x<31; x++)
			for(int y=0; y<20; y++)
				fs[i][x][y] = 1e9;
	p2[0] = p3[0] = 1;
	cin >> n >> q;
	for(int i=1; i<=n; i++)
		cin >> p[i] >> t[i] >> v[i];
	p[n+1] = 1e10, t[n+1] = 0, v[n+1] = 1;
	for(int i=1; i<35; i++)
		p2[i] = p2[i-1] * 2, p3[i] = p3[i-1] * 3;
	fs[0][0][0] = 0;
	for(int i=1; i<=n+1; i++)
	{
		for(int x=0; x<M2; x++)
		{
			for(int y=0; y<M3; y++)
			{
				double res = 1e9;
				if(v[i-1] == 2 && x >= 1) res = fs[i-1][x-1][y] + t[i-1];
				if(v[i-1] == 3 && y >= 1) res = fs[i-1][x][y-1] + t[i-1];
				if(v[i-1] == 4 && x >= 2) res = fs[i-1][x-2][y] + t[i-1];
				fs[i][x][y] = min(fs[i-1][x][y], res) + (p[i] - p[i-1]) * 1.0 / (p2[x] * p3[y]);
			}
		}
	}
	//cout << f2[5][2] << '\n';
	while(q --)
	{
		cin >> y;
		int pp = upper_bound(p+1, p+n+1, y) - p;
		double res = 1e9;
		for(int i=0; i<M2; i++)
			for(int j=0; p2[i] * p3[j]<=y*3; j++)
				res = min(res, fs[pp][i][j] - (p[pp] - y) / (p2[i] * p3[j]));
		printf("%.8lf\n", res);
	}
	return 0;
}
```

---

## 作者：sbno333 (赞：0)

拿上来发现 $x$ 很小，不会用？发现一档数据是 $x\in\{1,2,4\}$，考虑到这时速度为二的幂，如果在速度 $10^9$ 使加油，至少话费一时间，还不如直接过去，所以速度只有 $\log V$ 种，考虑满分数据范围，此时也只是 $\log^2 V$ 种速度，发现可以 DP，但是肯定要离散化，考虑离线处理询问把加油站和询问混在一起，然后 DP，状态分别是位置和速度，维护最小时间，滚动数组，然后不考虑加油容易转移，然后在按照速度从大到小进行加油转移，自己到自己转移，类似一维空间的背包，也容易推出，最后每个位置在所有速度中选时间最小的，在跑一遍询问输出即可。

大样例得出精度不足，考虑分数记录，发现除以的速度最小公倍数最大只有 $2^{30}\times3^{20}$，所以直接分母用这个，计算时只考虑分子，这样除以容易转变为乘，注意 $t$ 要乘上分母，这里最后答案上线会爆，所以用 __int128，最后再除以分母，虽然时间会变慢，但精度却增加了，甚至可以做取模。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int s[409];
int inn;
unordered_map<int,int> bh;
struct st{
	__int128 p,t,x;
}a[200009];
bool cmp(st a1,st a2){
	return a1.p<a2.p;
}
__int128 dp[409][2];
map<int,double> ans;
int m;
int qq[200009];
__int128 cs;
signed main(){
	int g;
	g=1;
	cs=1;
	for(int i=1;i<=30;i++){
		cs*=2;
	}
	for(int i=1;i<=20;i++){
		cs*=3;
	}
	for(int i=0;i<=30;i++){
		int z;
		z=1;
		for(int j=0;j<=30;j++){
			if(z*g<=1000000000){
				s[++inn]=z*g;
			}else{
				break;
			}
			z*=3;
		}
		g*=2;
	}
	sort(s+1,s+1+inn);
	for(int i=1;i<=inn;i++){
		s[i]=cs/s[i];
		bh[s[i]]=i;
	}
	int n,q;
	cin>>n>>q;
	for(int i=1;i<=n;i++){
		int x,y,z;
		cin>>x>>y>>z;
		a[i].p=x,a[i].t=y,a[i].x=z;
	}
	m=n;
	for(int i=1;i<=q;i++){
		int x;
		cin>>x;
		qq[i]=x;
		a[++m]={x,0,1};
	}
	sort(a+1,a+1+m,cmp);
	__int128 inf;
	inf=1;
	for(int j=1;j<=120;j++){
		inf*=2;
	}
	for(int i=1;i<=inn;i++){
		dp[i][0]=inf;
	}
	dp[1][0]=0;
	for(int i=0;i<m;i++){
		bool z;
		z=(i&1);
		bool g;
		g=!z;
		for(int i=1;i<=inn;i++){
			dp[i][g]=inf;
		}
		for(int j=1;j<=inn;j++){
			if(dp[j][z]!=inf)
			dp[j][g]=min(dp[j][g],dp[j][z]+(a[i+1].p-a[i].p)*s[j]);
		}
		for(int j=inn;j>=1;j--){
			int u;
			u=bh[s[j]/a[i+1].x];
			if(u&&dp[j][g]!=inf&&s[j]%a[i+1].x==0)
				dp[u][g]=min(dp[u][g],dp[j][g]+a[i+1].t*cs);
		}
		__int128 an;
		an=inf;
		for(int j=1;j<=inn;j++){
			an=min(an,dp[j][g]); 
		}
		double zz;
		zz=an;
		zz/=(int)cs;
		ans[a[i+1].p]=zz;
	}
	for(int i=1;i<=q;i++){
		printf("%.15lf\n",ans[qq[i]]);
	}
	return 0;
}
```

第一次用手机写题解。

---

## 作者：_fairytale_ (赞：0)

>我侧头痴痴注视着你茫然的眼睛
>
>就如谎言一般绚丽像天青色一样澄净
>
>它们是否也会轻阖哀伤湿漉漉地恳求时间暂停
>
>——请让这夏天暂停

去掉 $x=1$ 的加油站之后，每次速度至少翻倍，翻倍 
$\log$ 次之后再翻倍省的时间还没有加油的时间多，所以翻倍次数很少。简单计算得 $\times 2$ 只有约 $30$ 次，$\times 3$ 只有约 $20$ 次，把 $\times 4$ 看成两次 $\times 2$，可能的速度取值只有约 $600$ 种。

设 $f_{i,a,b}$ 表示考虑了前 $i$ 个加油站，当前速度变为 $2^a3^b$ 所需最小时间，DP 即可。

```cpp
#include<bits/stdc++.h>
bool Mst;
#define emp emplace_back
#define rep(x,qwq,qaq) for(int x=(qwq);x<=(qaq);++x)
#define per(x,qwq,qaq) for(int x=(qwq);x>=(qaq);--x)
#define fsp(x) fixed<<setprecision(x)
using namespace std;
template<class _T>
void ckmin(_T &x,_T y){
	x=min(x,y);
}
#define maxn 101000
int n,q;
struct gs{
	int p,t,x;
}g[maxn];
#define db double
db f[2][36][26];//2^a3^b
db pw[36][26];
const int A=30,B=20;
struct Querys{
	int id,y;
}Qry[maxn];
vector<Querys>Q[maxn];
db ans[maxn];
bool Med;
signed main() {
	cerr<<(&Mst-&Med)/1024.0/1024.0<<" MB\n";
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	pw[0][0]=1;
	rep(i,0,A){
		if(i!=0)pw[i][0]=pw[i-1][0]*2;
		rep(j,1,B){
			pw[i][j]=pw[i][j-1]*3;
		}
	}
	cin>>n>>q;
	rep(i,1,n){
		cin>>g[i].p>>g[i].t>>g[i].x;
		if(g[i].x==1)--i,--n;
	}
	rep(i,1,q){
		cin>>Qry[i].y;
		Qry[i].id=i;
	}
	sort(Qry+1,Qry+q+1,[](const Querys&x,const Querys&y){
		return x.y<y.y; 
	});
	rep(i,1,q)ans[i]=(db)1e18;
	rep(i,1,q){
		int l=1,r=n,res=0;
		int mid=(l+r)/2;
		while(l<=r){
			if(g[mid].p<=Qry[i].y){
				res=mid;
				l=mid+1;
			}
			else r=mid-1;
		}
		if(res==0)ans[Qry[i].id]=Qry[i].y;
		else Q[res].emp(Qry[i]);	
	}
	int op=1;
	rep(i,1,n)rep(a,0,A)rep(b,0,B)f[0][a][b]=f[1][a][b]=(db)1e18;
    f[op^1][0][0]=0;
	rep(i,1,n){
		int dA=0,dB=0;
		if(g[i].x==2)dA=1;
    	else if(g[i].x==3)dB=1;
		else dA=2;
		rep(a,0,A){
			rep(b,0,B){
				ckmin(f[op][a+dA][b+dB],f[op^1][a][b]+(db)(g[i].p-g[i-1].p)/pw[a][b]+g[i].t);
				ckmin(f[op][a][b],f[op^1][a][b]+(db)(g[i].p-g[i-1].p)/pw[a][b]);
			}
		} 
	    for(Querys t:Q[i])rep(a,0,A)rep(b,0,B)ckmin(ans[t.id],f[op][a][b]+(t.y-g[i].p)/pw[a][b]);
		op^=1;
		rep(a,0,A)rep(b,0,B)f[op][a][b]=(db)1e18;
	}
	rep(i,1,q)cout<<fsp(18)<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：Redshift_Shine (赞：0)

## 闲话

当我往代码的某个位置加上了一个 `=` 号后，我的代码的内存占用缩小至了原来的 $\frac{1}{2^n}$。我并没有开玩笑。同时，运行效率也提高了不知道多少倍，因为没加等号的程序运行第 $3$ 个样例时需要占用 10G+ 的内存，而我的电脑是撑不住的，所以我把它 Ctrl-C 了，不知道实际运行时间。而加了等号之后，所有样例运行时间都未超过 $200$ 毫秒。

## 题解

考虑如下算法：

假设目前走到了位置 $x$。从位置 $0$ 到位置 $x$ 有若干种可能的方案，其中每种方案可以使用二元组 $(t,v)$ 表示。其中，$t$ 代表走到这个位置的总用时，而 $v$ 代表目前行进 $1$ 个单位长度所用的时间。

我们称一个二元组集合 $S$ 是**精悍**的，当且仅当该集合内任意两个相异二元组 $(t,v)$ 和 $(t',v')$ 不满足 $t\le t'\land v\le v'$。

定义一次**清理**为将一个二元组集合 $S$ 转换为它的一个**精悍**的子集 $S'$，并且在其中 $t$ 的最小值尽可能小的前提下 $|S'|$ 尽可能大。

定义一次**距离为 $x$ 的步进**为将一个二元组集合 $S$ 内的每个元素 $(t,v)$ 转换为 $(t+xv,v)$。

定义一次**参数为 $(t',x')$ 的可能加油**为设集合 $S'$ 为集合 $S$ 的**一对一映射** $(t,v)\to (t+t',\frac{v}{x'})$，令 $S\leftarrow S\cup S'$。

将**可能加油**和**询问**统称为**事件**。

初始时，令 $S$ 为 $\{(0,1),(10^9,0)\}$。第一个元素为初始状态，第二个元素为不加油的边界条件。

接下来，将询问与加油站放在一起排序，令新的位置数组为 $p'$，大小为 $(n+m)$。令 $p'_0=0$，则依次对于第 $i$ 个事件，执行一次距离为 $(p'_i-p'_{i-1})$ 的步进，**并进行清理**。接下来，若该事件为询问，则答案为 $S$ 中所有元素中最小的 $t$ 值。否则执行一次参数为 $(t_i,x_i)$ 的可能加油，**并进行清理**。

我无法分析上述做法的准确时间复杂度，但上述方法确实可以通过此题。

## 代码

```c++
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <list>
using namespace std;
const int N = 2e5 + 10, inf = 1e9;
using ld = long double;
const ld eps = 1e-7;
template <typename _Tp> inline void read(_Tp &x)
{
    char ch;
    while (ch = getchar(), !isdigit(ch))
        ;
    x = (ch ^ 48);
    while (ch = getchar(), isdigit(ch))
        x = (x << 3) + (x << 1) + (ch ^ 48);
}
template <typename _Tp, typename... _Args> inline void read(_Tp &x, _Args &...args)
{
    read(x);
    read(args...);
}
struct st
{
    ld ctm, spd;
    bool operator<(const st &x) const
    {
        if (ctm != x.ctm)
            return ctm > x.ctm;
        return spd < x.spd;
    }
};
struct evrt
{
    int p, t, x;
    bool operator<(const evrt &tx) const
    {
        if (p != tx.p)
            return p < tx.p;
        if (t != tx.t)
            return t < tx.t;
        return x < tx.x;
    }
} evnt[N];
list<st> curwk, buf;
int n, m, cur;
ld res[N];
void clr()
{
    curwk.sort();
    for (auto &i : curwk)
    {
        while (buf.size() and buf.back().spd >= i.spd)
            buf.pop_back();
        buf.emplace_back(i);
    }
    curwk.swap(buf);
    buf.clear();
}
void frwd(int x)
{
    cur += x;
    for (auto &i : curwk)
    {
        i.ctm += i.spd * x;
    }
    clr();
}
void charge(evrt a)
{
    // if (a.x == 1)
    //     return;
    int tmp = curwk.size();
    auto it = curwk.begin();
    for (int i = 0; i < tmp; i++)
    {
        curwk.emplace_back(st{it->ctm + a.t, it->spd / a.x});
        if (curwk.back().spd * (inf - cur) < eps)
            curwk.back().spd = 0;
        it++;
    }
    clr();
}
int main()
{
    freopen("ship.in", "r", stdin);
    freopen("ship.out", "w", stdout);
    read(n, m);
    curwk.emplace_back(st{0, 1});
    curwk.emplace_back(st{1e9, 0});
    for (int i = 1; i <= n; i++)
    {
        read(evnt[i].p, evnt[i].t, evnt[i].x);
    }
    for (int i = 1; i <= m; i++)
    {
        read(evnt[i + n].p);
        evnt[i + n].t = -1;
        evnt[i + n].x = i;
    }
    sort(evnt + 1, evnt + n + m + 1);
    for (int i = 1; i <= n + m; i++)
    {
        if (cur != evnt[i].p)
            frwd(evnt[i].p - cur);
        if (~evnt[i].t)
        {
            charge(evnt[i]);
            continue;
        }
        res[evnt[i].x] = curwk.back().ctm;
    }
    for (int i = 1; i <= m; i++)
    {
        printf("%.7Lf\n", res[i]);
    }
}
```

---

## 作者：ydzr00000 (赞：0)

### 题意

$n$ 个加油站顺次排在一条直线上，令起点为位置 $0$，第 $i$ 个加油站的位置为 $p_i$，在第 $i$ 个加油站提供种类为 $x_i$ 的油，如果选择在这个加油站加油，则花费 $t_i$ 的加油时间，让当前飞船的速度乘上 $x_i$。

一个加油站只能加一次油。

给出 $q$ 个询问，每个询问给出 $y_i$，表示询问初始速度为 $1$，从起点到位置 $y_i$ 的最小花费时间。

$n,q\leq 10^5, p_i, y_i,t_i \leq 10^9, 1\leq x_i\leq 4$。

### 题解

首先思考一个问题：每一个正整数都可能作为速度吗？

- 由于 $1\leq x_i\leq 4$，所以速度一定可以被表示成 $2^p3^q$ 的形式，其中 $p,q$ 均为非负整数。
- 由于 $t_i\ge 1$，所以当速度大于 $10^9$ 的时候，加一次油的时间就高于冲到终点的时间了，故速度在超过 $10^9$ 的时候不会选择加油。

考虑以上两条限制，实际上的速度种类数不多，手动计算总共有大约 $350$ 种，数量记为 $C$，可以接受。

考虑 DP，设 $f_{i,(p,q)}$ 表示到达了第 $i$ 个加油站，当前速度为 $2^p3^q$，所花费的最小时间（不带下标的为指数，带下标的为加油站位置）。

初始值肯定是 $f_{0,(0,0)} = 0$，其余为正无穷。 

对于每一个 $f_{i,(p,q)}$，考虑转移：

- 要么不在此加油，保持先前的原速，时间为 $f_{i-1,(p,q)} + \dfrac{(p_i - p_{i-1})}{2^p3^q}$。
- 要么在此加油，设 $2^u3^v= x_i$，则从先前时的速度转移，时间为 $f_{i-1,(p-u,q-v)} + \dfrac{(p_i - p_{i-1})}{2^{p-u}3^{q-v}} + t_i$，注意此时要求 $p\ge u, q\ge v$。

做完这个 DP 后，考虑每一组询问，先二分出位置 $y_i$ 所在的位置在哪两个加油站之间，假设小于位置 $y_i$ 的编号最大的加油站的编号为 $k$，则枚举速度状态 $(p,q)$ 并用 $f_{k,(p,q)} + \dfrac{(y - p_k)}{2^p3^q}$ 更新答案即可，时间复杂度为 $\mathcal{O}((n+q)C + q\log_2 n)$。

如果需要进一步优化空间，则离线询问，那么 DP 数组可以滚动，时间复杂度变为 $\mathcal{O}((n+q)C)$。

### 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=1e9+3;
double ls[340],dp[340];
int idx[35][25],tot=0;
struct info{
    int p,q;
    long long spd;
}g[1001];
inline void init()
{
    long long m=1;
    for(int i=0;i<=30;i++)
    {
        long long x=m;
        for(int j=0;j<=19;j++)
        {
            idx[i][j]=(++tot);
            g[tot]={i,j,x};
            if(x>=1e9)
                break;
            x*=3;
        }
        m*=2;
    }
}
struct station{
    int p,t,x;
}a[100002];
struct query{
    int p,id;
}b[100002];
double ans[100001];
int main(){
    init();

    int n,q;
    scanf("%d %d",&n,&q);
    for(int i=1;i<=n;i++)
        scanf("%d %d %d",&a[i].p,&a[i].t,&a[i].x);
    a[n+1]={inf,inf,1};
    for(int i=1;i<=q;i++)
    {
        scanf("%d",&b[i].p);
        b[i].id=i;
    }
    sort(b+1,b+q+1,[&](const query &x,const query &y){
        return x.p<y.p;
    });
    for(int i=1;i<=tot;i++)
        dp[i]=ls[i]=1.00*inf*inf;
    dp[1]=ls[1]=0;
    for(int i=0,j=1;i<=n;i++)
    {
        while(j<=q&&b[j].p<=a[i+1].p)
        {
            double res=1e9;
            for(int k=1;k<=tot;k++)
            {
                double cost=dp[k]+(b[j].p-a[i].p)*1.00/g[k].spd;
                res=min(res,cost);
            }
            ans[b[j].id]=res;
            j++;
        }
        int mp=0,mq=0;
        if(a[i+1].x==2)
            mp=1;
        else if(a[i+1].x==3)
            mq=1;
        else if(a[i+1].x==4)
            mp=2;
        for(int k=1;k<=tot;k++)
        {
            double X=ls[k]+(a[i+1].p-a[i].p)*1.00/g[k].spd;
            dp[k]=X;
            int p=g[k].p,q=g[k].q;
            if(p<mp||q<mq)
                continue;
            int las=idx[p-mp][q-mq];
            double Y=ls[las]+(a[i+1].p-a[i].p)*1.00/g[las].spd+a[i+1].t;
            dp[k]=min(dp[k],Y);
        }
        for(int k=1;k<=tot;k++)
            ls[k]=dp[k];
    }
    for(int i=1;i<=q;i++)
        printf("%.12lf\n",ans[i]);
    
    return 0;
}
```

---

## 作者：forever_nope (赞：0)

设 $f(i,x,y)$ 表示从 $i$ 个加油站离开时速度为 $2^x3^y$ 的最小时间。

记 $d_i=p_i-p_{i-1}$ 表示两个加油站之间的距离。

记 $w(d,x,y)=\dfrac{d}{2^x3^y}$ 表示 $x,y$ 速度下走 $d$ 的时间。

转移易得：

$$
f(i,x,y)=\min\begin{cases}
f(i-1,x,y)+w(d_i,x,y)\\
f(i-1,x',y')+w(d_i,x',y')+t_i
\end{cases}
$$

其中 $x',y'$ 表示除去 $i$ 的加速后的速度，即加速前的速度。

注意到 $t_i\ge1$，当前的速度比跑道总长还大就可以直接跑过去。

飞船的速度只是 $10^9$ 级别的，因此第二维只需要记到 $30,19$ 就可以了。

时间复杂度 $\mathcal O(n\log^2 p)$，假定 $n,q$ 同阶、$p,y$ 同阶。结束了。

```cpp
constexpr int N = 1e5 + 10;
constexpr double INF = 1e9;

int n, q;

int X, Y;

struct node {
	int t, x, y;
} a[N];

int pos[N], del[N];

int d2[31], d3[20];

double dp[N][31][20];

double calc(int t) {
	int i = upper_bound(pos + 1, pos + n + 1, t) - pos - 1;
	double ans = t;
	for (int x = 0; x <= X; ++x)
		for (int y = 0; y <= Y; ++y)
			ans = min(ans, dp[i][x][y] + (double)(t - pos[i]) / (d2[x] * d3[y]));
	return ans;
}

void Main() {
	cin >> n >> q;
	for (int i = 1; i <= n; ++i) {
		int val;
		cin >> pos[i] >> a[i].t >> val;
		if (val == 1) {
			--n, --i;
			continue;
		}
		del[i] = pos[i] - pos[i - 1];
		a[i].x = (val % 2 == 0) * (val / 2);
		a[i].y = (val % 3 == 0);
		X += a[i].x, Y += a[i].y;
	}

	X = min(X, 30);
	Y = min(Y, 19);

	d2[0] = d3[0] = 1;
	for (int i = 1; i <= X; ++i)
		d2[i] = d2[i - 1] * 2;
	for (int i = 1; i <= Y; ++i)
		d3[i] = d3[i - 1] * 3;
	
	for (int i = 0; i <= n; ++i)
		for (int x = 0; x <= X; ++x)
			for (int y = 0; y <= Y; ++y)
				dp[i][x][y] = 1e9;

	dp[0][0][0] = 0;
	for (int i = 1; i <= n; ++i)
		for (int x = 0; x <= X; ++x)
			for (int y = 0; y <= Y; ++y) {
				dp[i][x][y] = min(INF, dp[i - 1][x][y] + (double)del[i] / (d2[x] * d3[y]));
				if (x >= a[i].x && y >= a[i].y)
					dp[i][x][y] = min(dp[i][x][y], dp[i - 1][x - a[i].x][y - a[i].y] + (double)del[i] / (d2[x - a[i].x] * d3[y - a[i].y]) + a[i].t);
			}

	while (q--) {
		int x;
		cin >> x;
		printf("%.20lf\n", calc(x));
	}
	return;
}
```

注意：

+ `float` 可能会被卡精度。

+ 数组如果开大了会 MLE / RE 在 MXOJ 会爆零。

+ 记忆化搜索可能会被卡常。

---


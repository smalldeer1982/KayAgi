# 「ZYZ 2025」自然数序列

## 题目描述

给定长度为 $n$ 的**正整数**序列 $a$，有 $q$ 次询问。对于每次询问，给出 $l,r,k$ 和 $k$ 个限制条件，求有多少个长度为 $n$ 的**自然数**序列 $b$ 满足 $l\le\sum\limits_{i=1}^na_ib_i\le r$ 且满足这 $k$ 个限制条件，对 $998244353$ 取模。

对于每个限制条件，给出 $x,y$，要求 $b_x=y$。

我们称两个长度为 $n$ 的序列 $b,b'$ 是不同的，当且仅当存在不超过 $n$ 的正整数 $i$ 满足 $b_i\not=b_i'$。

## 说明/提示

**【样例解释】**

对于第一次询问，有以下 $4$ 个序列 $b$ 符合条件：$\{0,0,0,2\},\{0,1,0,0\},\{5,0,0,1\},\{10,0,0,0\}$。

序列 $\{3,0,1,1\}$ 不符合条件，因为不满足限制 $b_3=0$；序列 $\{1,1,1,1\}$ 不符合条件，因为不满足 $\sum\limits_{i=1}^na_ib_i=10$。

**【数据范围】**

**本题采用捆绑测试。**

|子任务编号|特殊性质|分值|
|:-:|:-:|:-:|
|$0$|$n,l,r,q\le8$|$10$|
|$1$|$n,l,r,q\le100$|$15$|
|$2$|$k=1$ 且 $l=r$|$25$|
|$3$|$l=r$|$25$|
|$4$|无|$25$|

对于所有的测试数据，保证：$0\le l,r,y\le5\times10^3$，$1\le n,a_i\le 5\times10^3$，$1\le q\le 5\times 10^4$，$0\le k\le8$，$1\le x\le n$。对于一次询问，保证每一条限制的 $x$ 互不相同。

## 样例 #1

### 输入

```
4 3
1 10 2 5
10 10 1
3 0
900 910 1
4 2
0 1000 2
2 1
1 5```

### 输出

```
4
223516
48906```

# 题解

## 作者：Abczzzzz (赞：7)

这个东西由于固定的是 $a$，所以我们显然可以把 $b$ 当作一个系数用生成函数去理解这个东西，背包即可解决只有 $a$ 的情况。

然后看到 $k$ 很小，我们先把这些确定的 $\sum ab$ 从询问的区间 $l,r$ 里面减掉。

下面的部分发现不能有给定的这 $k$ 个出现，考虑容斥。这个是容易的，于是我们得到了 $\mathcal O(NV+Q2^kk)$ 的做法。

---

## 作者：block_in_mc (赞：3)

首先对问题进行转化，令 $b_x=y$ 可以转化为先将 $l,r$ 都减去 $y\times a_x$，并要求 $b_x=0$。

现在考虑 $l=r$ 时如何解决，不妨令 $s=l=r$。

事实上，如果忽略 $b_x=0$ 的限制，这个问题等价于一个完全背包：有 $n$ 个物品，重量分别为 $a_1,a_2,\cdots,a_n$，求出填满容量为 $s$ 的背包的方案数。我们可以先跑一遍完全背包，算出 $s=1,2,\cdots,5000$ 时的答案。

假如现在只有一条 $b_x=0$ 的限制，考虑如何满足：我们不妨用总方案数减去 $b_x\not=0$ 的方案数得到答案，而 $b_x\not=0$ 的方案数实际上就是：先选择一个物品 $x$，再将剩下的 $s-a_x$ 的空间用任意物品填满的方案数，即为 $dp_{s-a_x}$。

类似地，考虑如何满足多个 $b_x=0$ 的限制：

首先，我们可以求出满足多个 $b_x\not=0$ 的方案数，这实际上就是先将这几个物品各选一个，再将剩下的 $s-\sum a_x$ 的空间用任意物品填满的方案数，即为 $dp_{s-\sum a_x}$。需要注意的是，如果下标小于 $0$，则我们认为其值为 $0$。

接下来可以进行容斥。以需要保证 $b_{x_1}=b_{x_2}=0$ 为例，答案即为 $dp_s-dp_{s-a_{x_1}}-dp_{s-a_{x_2}}+dp_{s-a_{x_1}-a_{x_2}}$。

当 $l\not=r$ 时，可以发现对于每一个 $s$，容斥的对应项恰好为一段连续区间，可以使用前缀和解决。

总时间复杂度 $O(ns+2^kq)$。

AC 代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int P = 998244353;
int n, q, l, r, k, op, x, y, a[6000], dp[6000];
void add(int &x, int y) { x += y; if (x >= P) x -= P; }
void mns(int &x, int y) { x -= y; if (x < 0) x += P; }
int query(int l, int r) {
	return ((r >= 0 ? dp[r] : 0) - (l - 1 >= 0 ? dp[l - 1] : 0) + P) % P;
}
int main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin >> n >> q;
	dp[0] = 1;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		for (int j = a[i]; j <= 5000; j++)
			add(dp[j], dp[j - a[i]]);
	}
	for (int i = 1; i <= 5000; i++)
		add(dp[i], dp[i - 1]);
	while (q--) {
		vector<int> v;
		cin >> l >> r >> k;
		for (int i = 1; i <= k; i++) {
			cin >> x >> y; 
			v.push_back(a[x]);
			l -= a[x] * y, r -= a[x] * y;
		}
		if (r < 0) {
			cout << 0 << '\n';
			continue;
		}
		if (l < 0) l = 0;
		int m = v.size(), ans = 0;
		for (int i = 0; i < (1 << m); i++) {
			int sum = 0;
			for (int j = 0; j < m; j++) {
				if ((i >> j) & 1) {
					add(sum, v[j]);
				}
			}
			if (__builtin_popcount(i) % 2 == 0) 
				add(ans, query(l - sum, r - sum));
			else
				mns(ans, query(l - sum, r - sum));
		}
		cout << ans << '\n';
	}
	return 0;
}
```

---

## 作者：wuming_z (赞：2)

![](https://cdn.luogu.com.cn/upload/image_hosting/2q3ip0x1.png)
~~减时间就能卡掉暴力吗？有点意思。~~  
很容易可以发现这道题可以转换成完全背包问题，对于每一个 $b_i$ 其实就是对应 $a_i$ 取的个数，求 $l,r$ 之间合法个数就是有多少种取的方案，我们直接预处理取到每个数的方案数，然后在 dp 上暴力取消每次询问的这 $k$ 个物品，固定取的个数可以直接让 $l,r$  数轴上左移，大大减小 $r$ 的范围。  
时间复杂度 $O(kqr + nr)$。  
[AC 记录。](https://www.luogu.com.cn/record/225746554)
```cpp
#define mod 998244353ll
inline void qm(int& x) {
	x = (x + mod) % mod;
}
int n, q;
int a[10001];
int dp[10001];
int lss[10001];
int dp2[10001];
signed main() {
	n = read(), q = read();
	for (int i = 1; i <= n; i++) {
		a[i] = read();
	}
	dp[0] = 1;
	for (int i = 1; i <= n; i++) {
		for (int j = a[i]; j <= 5000; j++) {
			dp[j] += dp[j - a[i]];
			qm(dp[j]);
		}
	}
	while (q--) {
		int l = read(), r = read(), k = read();
		memcpy(dp2, dp, sizeof(int) * (r + 1));
		int lsx[10], lsy[10];
		for (int i = 1; i <= k; ++i) {
			lsx[i] = read(), lsy[i] = read();
			r -= a[lsx[i]] * lsy[i];
			l -= a[lsx[i]] * lsy[i];
		}
		for (int i = 1; i <= k; ++i) {
			for (int j = r; j >= a[lsx[i]]; --j)dp2[j] -= dp2[j - a[lsx[i]]], qm(dp2[j]);
		}
		int ans = 0;
		for (int i = max(l, 0); i <= r; i++) {
			ans += dp2[i];
			qm(ans);
		}writeln(ans);
	}
	return 0;
}
```

---

## 作者：Aurie (赞：1)

# 「ZYZ 2025」自然数序列【题解】
如果每次询问都没有给出任何限制条件，即 $k=0$。则原问题相当于一个完全背包：有 $n$ 种物品，每种物品不限量，第 $i$ 种重量为 $a_i$，问恰好填满容量为 $s\in[0,5000]$ 的背包的方案数。

现在考虑上限制条件，假如现在只有一条限制即 $k=1$ 且 $l=r$（记 $l=r=s$），对于 $b_x=y$ 的条件，可以让 $s$ 减去 $a_x\times y$ 将其转化为 $b_x=0$ 的条件。此时可以用总方案数减去 $b_x\not=0$ 的方案数，计算 $b_x\not=0$ 的方案数时，可以先在总容量 $s$ 内强制钦定选择一个 $x$，然后其它随便选，因此方案数为 $dp_{s-a_x}$。综上 $b_x=0$ 的方案数为 $dp_s-dp_{s-a_x}$。

考虑如何解决 $l=r=s$，但 $k>1$ 时的情况，先转化成 $b_x=0$ 的情况，然后依然用总方案数减去存在一个 $x$ 使得 $b_x\not=0$ 的不合法方案数，总方案数直接使用完全背包求出即可。“存在一个 $x$ 使得 $b_x\not=0$ 的不合法方案数”是一个存在性命题，存在性命题是一种并集，可以使用容斥原理求。例如 $k=2$ 时，给出的两种物品应都不存在，有一种存在就不合法，其方案数为：存在第一种物品的方案数 $+$ 存在第二种物品的方案数 $-$ 两种物品同时存在的方案数。其中“存在第一种物品的方案数 $+$ 存在第二种物品的方案数”直接套用上一段的求法即可。“两种物品同时存在的方案数”的求法也类似，只需要先钦定两个都选了一个，剩下随便选即可，即为 $dp_{s-a_1-a_2}$。

在考虑 $l\not=r$ 的情况。可以发现，对于任意 $s\in[l,r]$ 对它们进行的操作都一模一样。可以利用前缀和以及加法的交换律、结合律将它们同时操作！~~（难道这就是传说中的并行计算？）~~

最终时间复杂度 $O(nr+q2^k)$。

## std 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int P = 998244353;
int n, q, l, r, k, op, x, y, a[6000], dp[6000];
void add(int &x, int y) { x += y; if (x >= P) x -= P; }
void mns(int &x, int y) { x -= y; if (x < 0) x += P; }
int query(int l, int r) {
	return ((r >= 0 ? dp[r] : 0) - (l - 1 >= 0 ? dp[l - 1] : 0) + P) % P;
}
int main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin >> n >> q;
	dp[0] = 1;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		for (int j = a[i]; j <= 5000; j++)
			add(dp[j], dp[j - a[i]]);
	}
	for (int i = 1; i <= 5000; i++)
		add(dp[i], dp[i - 1]);
	while (q--) {
		vector<int> v;
		cin >> l >> r >> k;
		for (int i = 1; i <= k; i++) {
			cin >> x >> y; 
			v.push_back(a[x]);
			l -= a[x] * y, r -= a[x] * y;
		}
		if (r < 0) {
			cout << 0 << '\n';
			continue;
		}
		if (l < 0) l = 0;
		int m = v.size(), ans = 0;
		for (int i = 0; i < (1 << m); i++) {
			int sum = 0;
			for (int j = 0; j < m; j++) {
				if ((i >> j) & 1) {
					add(sum, v[j]);
				}
			}
			if (__builtin_popcount(i) % 2 == 0) 
				add(ans, query(l - sum, r - sum));
			else
				mns(ans, query(l - sum, r - sum));
		}
		cout << ans << '\n';
	}
	return 0;
}
```

---

## 作者：Bonely_Muffin (赞：1)

### ~~Make Generate Function Great Again~~

这是一篇生成函数爆解的题解。（建议先了解生成函数）

事实上，本题在描述一个完全背包，其中第 $i$ 个物品体积为 $a_i$。每次询问都规定其中 $k(k \leq 8)$ 个物品的选择数量。

考虑先 dp，$f_i$ 表示体积为 $i$ 的物品选择的方案数。设 $F(z)$ 是它的生成函数。那么显然有：
$$F(z) = \sum_{i=1}^nf_i = \prod_{i=1}^n\frac{1}{1-z^{a_i}}$$

考虑给出 k 条限制后的生成函数 $F'(z)$：
$$F'(z) = F(z)\cdot\prod_{(x,y)} z^{ya_{x}}(1-z^{a_{x}})$$

也就是把各个存在限制的位置 $x$，对乘积的贡献从 $\frac{1}{1-z^{a_x}}$ 改为 $z^{ya_x}$。

那么有 75 分做法（其实理论应该只有 25）：把生成函数 $F(z)$ dp 出来后，$O(r)$ 地乘上后面的式子得到 $F'(z)$，再对 $F'(z)$ 中的 $[l,r]$ 部分系数求和。

这样的时间复杂度是 $O(n^2 + qkn)$，~~qkn 极限 2e9 怎么可能过~~。

不妨记 $F'(z) = F(z)C(z)$，也就是后面的一坨乘积记作 $C(z)$。我们发现 $C(z)$ 最多只有 $2^k\leq256$ 项。所以预处理 $F(z)$ 前缀和并把 $C(z)$ 暴力算出来，最后就能算贡献了。

时间复杂度 $O(n^2 + 2^kq)$。

~~膜拜hxf大佬！~~

---

## 作者：Kedit2007 (赞：0)

# P13349 题解

题面见[原题链接](https://www.luogu.com.cn/problem/P13349)。这篇题解尝试解释的是时间复杂度 $O(n\max{r}+q\cdot 2^k)$ 的做法。

## 思路

### 简化题目

这道题目特点在于存在限制，我们可以暂时忽略限这些限制，尝试解决这样一个简化后的问题：

> 给定长度为 $n$ 的**正整数**序列 $a$，有 $q$ 次询问。对于每次询问，给出 $l,r$，求有多少个长度为 $n$ 的**自然数**序列 $b$ 满足 $l\le\sum\limits_{i=1}^na_ib_i\le r$，对 $998244353$ 取模。

可以发现，这类似于完全背包问题，只不过，背包大小不是固定的一个数值，而是一个区间。

注意到，我们用典型的 DP 方式处理背包大小为 $r$ 的完全背包问题时，实际上整个 DP 数组同时求得了背包为 $1$ ~ $r$ 的所有答案。这样，每次询问时，我们便可以直接对 DP 数组的一个区间求和来得到答案。

由于 DP 数组不变，可以预处理 DP 数组的前缀和加快计算。

这里贴出简化问题的[参考代码](https://www.luogu.com.cn/paste/zbb2qjyp)。

接下来我们引入限制条件。

### 当 $k = 1$ 时

$k = 1$时，限制条件规定了一个 $b_i$，一个直接的想法是计算扣除 $a_i \times b_i$ 后的 $l, r$，记作 $l', r'$，然后去除 $a_i$ 以 $l', r'$ 为目标进行 DP。但由于每次查询的限制可能不同，如果每次都进行一次单独的 DP，那么时间复杂度是 $O(qn\max r)$，不能接受。

我们发现每次都需要完整地进行一遍 DP 是复杂度过高的主要原因。那么我们可以换一个角度，先将所有数字全都纳入，然后扣除限制条件中的数字；换句话说，在完成背包 DP 后，“拿出”一件物品。

具体地说，将“放入”一件物品前的 DP 数组用 $dp$ 表示，将“放入”一件物品后的 DP 数组用 $DP$ 表示，那么“放入”一件物品的 DP 公式是 $DP_i = dp_i + DP_{i - a_x}$。“拿出”一件物品就是在已知 $DP$ 的情况下倒推出 $dp$。将上面的 DP 公式移项，得到 $dp_i = DP_i - DP_{i - a_x}$，这便是“拿出”一件物品的转移方程。

进一步地，由于

$$\sum_{i = l'}^{r'}{dp_i} = \sum_{i = l'}^{r'}{DP_i} - \sum_{i = l' - a_x}^{r' - a_x}{DP_i}$$

我们可以利用前缀和以 $O(1)$ 的时间处理出等式右边的两个求和，这样便能以 $O(1)$ 的时间完成一次查询。

### 当 $k > 1$ 时

一个自然的思路是直接套用 $k = 1$ 的公式，例如尝试计算

$$
\sum_{i = l'}^{r'}{DP_i} - \sum_{j = 1}^{k}{\sum_{i = l' - a_j}^{r' - a_j}{DP_i}}
$$

但是这样并不能得到正确的结果。为什么呢？以 $k = 2$ 为例，用到 $a_1$ 的所有情况构成的集合记为 $A_1$，用到 $a_2$ 的所有情况构成的集合记为 $A_2$，那么我们希望扣除的是 $|A_1 \cup A_2|$。根据容斥原理， $|A_1 \cup A_2| = |A_1| + |A_2| - |A_1 \cap A_2|$，我们还需要计算 $|A_1 \cap A_2|$，即同时拿掉 $a_1$ 和 $a_2$，所以 $k = 2$ 时的公式应当是

$$
\sum_{i = l'}^{r'}{DP_i} - \sum_{i = l' - a_1}^{r' - a_1}{DP_i} - \sum_{i = l' - a_2}^{r' - a_2}{DP_i} + \sum_{i = l' - (a_1 + a_2)}^{r' - (a_1 + a_2)}{DP_i}
$$

最后，我们只需要根据容斥原理推广到一般情况。记 $A = {a_1, a_2, \cdots, a_k}$，则答案为

$$
\sum_{S \subseteq A}{(-1)^{|S|}\sum_{i = l' - s}^{r' - s}{DP_i}}
$$

其中

$$
s = \sum_{a \in S}{a}
$$

枚举 $A$ 的子集时间复杂度为 $O(2^k)$，这也是每次查询的复杂度。加上预处理 DP 数组前缀和，算法总体时间复杂度 $O(n\max r+ q\cdot 2^k)$。

结尾附上 [AC 记录连接](https://www.luogu.com.cn/record/226049054)。

---

## 作者：CleverSea (赞：0)

# P13349 完全背包题解

### 题意简述

给定长度为 $n$ 的**正整数**序列 $a$，进行 $q$ 次询问。每次询问给定 $l, r, k$ 和 $k$ 个限制条件，求满足 $l \leq \sum_{i=1}^{n} a_i b_i \leq r$ 和所有限制条件的**自然数**序列 $b$ 的数量。结果对 $998244353$ 取模。

### 思路

一道背包 DP 题，核心是计算在 $k$ 个位置固定的前提下，序列 $b$ 的加权和落在 $[l, r]$ 的方案数。我们可以 DP 预处理全局背包，再通过退背包处理 $k$ 个限制条件，最后计算区间和。定义 $g_s$ 为完全背包计算所有物品任意取值时，加权和为 $s$ 的方案数，转移为 $g_j=(g_j+g_{j-a_i}) \bmod 998244353$，其中 $a_i$ 为物品重量。

#### 对于每个询问：

1. 根据 $k$ 个限制条件，累加固定位置的贡献 $s = \sum a_x \cdot y$。若 $s > r$，则直接输出 $0$。

2. 自由部分需满足 $[\max(0, l-s), r-s]$，若区间无效则直接输出 $0$。

3. 将固定位置对应的物品从全局背包中移除（按重量降序进行逆背包操作）。

4. 最后，在 $[\max(0, l-s), r-s]$ 区间内累加方案数。

具体详见代码注释。

### 特别注意

本题时限改为 500ms 后此代码有点卡常，开 O2、关同步流、`endl` 改 `'\n'` 之后多试两次能过（亲测）（数据最强的点跑到了 498ms，如果卡不过可以手写快读快写）。

### Code
###### 码风良好，放心食用！
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 5000;         // 背包最大值
const int MOD = 998244353;
int n, q;
int a[5005];
int g[5005];                // 全局背包数组

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin >> n >> q;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    // 初始化全局背包：完全背包DP
    memset(g, 0, sizeof(g)); // 清空背包数组
    g[0] = 1;                // 加权和为 0 的方案数为 1（全取 0）
    for (int i = 0; i < n; i++) {
        int av = a[i];       // 当前物品重量
        // 完全背包状态转移
        for (int j = av; j <= N; j++) {
            g[j] = (g[j] + g[j - av]) % MOD; // 累加方案数
        }
    }
    // 处理每组询问
    while (q--) {
        long long l, r;      // 区间边界
        int k;               // 限制条件数量
        cin >> l >> r >> k;
        int fv[8];           // 存储固定物品的重量
        int fc = 0;          // 固定物品计数器
        long long s = 0;     // 固定部分的总贡献

        // 处理k个限制条件
        for (int i = 0; i < k; i++) {
            int x, y;
            cin >> x >> y;
            x--;             // 转换为0-indexed
            // 累加固定位置的贡献：a[x] * y
            s += (long long)a[x] * y;
            fv[fc++] = a[x]; // 存储物品重量
        }

        // 固定部分已超过r，无解
        if (s > r) {
            cout << 0 << '\n';
            continue;
        }

        // 计算自由部分需满足的区间[Lp, Rp]
        long long Lp = l - s;
        long long Rp = r - s;
        // 处理Lp下界（非负）
        if (Lp < 0) Lp = 0;
        // 区间无效的情况
        if (Rp < 0 || Lp > Rp) {
            cout << 0 << '\n';
            continue;
        }

        int h[N + 1];                   // 临时背包数组
        memcpy(h, g, sizeof(int) * (N + 1)); // 复制全局背包到临时数组
        sort(fv, fv + fc, greater<int>()); // 按重量降序排序（优化内存访问）

        // 退背包：移除固定物品
        for (int i = 0; i < fc; i++) {
            int av = fv[i]; // 当前物品重量
            // 逆序更新背包（完全背包逆操作）
            for (int j = N; j >= av; j--) {
                h[j] -= h[j - av];       // 移除当前物品的贡献
                if (h[j] < 0) h[j] += MOD; // 处理负数取模
            }
        }

        // 计算自由部分在[Lp, Rp]的方案数
        int ans = 0;
        // 遍历区间（注意j不超过N）
        for (int j = Lp; j <= Rp && j <= N; j++) {
            ans = (ans + h[j]) % MOD; // 累加方案数（可以加个前缀和优化，但是不加也勉强）
        }
        cout << ans << '\n';
    }
    return 0;
}
```

---

## 作者：sbno333 (赞：0)

并不好的一个题，像是强行弄出来的题。

先放复杂度，$O(nV+2^kq)$。

注意到 $l=r$ 分数很多，我们先做 $l=r$，并认为正解和它差不多。

我们考虑一次询问 $k=0$ 的情况。

我们显然可以 DP。

$dp_{i,j}$ 表示前 $i$ 个数，总共拿到和为 $j$ 的方案数。

不好的转移是 $dp_{i,j}=\sum_{b=0}^{\lfloor\frac{j}{b}\rfloor} dp_{i-1,j-b\times a_i}$。

调和级数和组合数能优化到 $O(nV\log V)$。

不过其实我们可以观察式子，然后有 $dp_{i,j}=dp_{i-1,j}+dp_{i,j-a_i}$。

时间复杂度 $O(nV)$。

接着考虑有 $k$ 的情况。

我们把 $dp_{n,0\sim V}$ 这个序列单独拿出来。

根据上面的式子可以倒退 $dp_{n-1,0\sim V}$。

不过其实顺序不重要，所以这个可以用来处理去掉一个 $a_i$。

我们考虑如果 $b_i$ 确定，其实就是去掉这个 $a_i$，然后 $l$ 和 $r$ 同时减去这里的贡献。

不过 $O(qV)$ 太慢，不接受。

我们考虑当 $l=r$ 的时候只关心 $dp_{n,l}$ 有用。

我们让 $dp_{n,l}$ 减去 $dp_{n,l-a_i}$ 即可。

考虑当 $k$ 较大怎么做。

类似的，我们倒着考虑，考虑减完这个 $a_i$ 后减去上一个要减去的 $a_j$。

我们从关心 $dp_{n,l}$ 和 $dp_{n,l-a_i}$ 变成了关心 $dp_{n,l-a_j}$，$dp_{n,l-a_i-a_j}$，$dp_{n,l}$ 和 $dp_{n,l-a_i}$。

若把 $dp_{n,0\sim V}$ 视为多项式 $F(x)=\sum_{i=0}^V dp_{n,i}x^i$。

我们每次去除 $a_i$ 就是乘上 $1-x^{-a_i}$。

最后查询某一个位置。

我们可以轻松算出这个位置需要最初哪些位置，复杂度为 $2^k$。

考虑 $l\not=r$。

前缀和优化一下。

然后我们需要的位置相当于若干区间，直接做就行。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
int dp[2][5009];
int a[1000009];
int n,q;
int k;
struct dxs{
	int cs[1009];
	int xs[1009];
	int inn;
}f;
signed main(){
	cin>>n>>q;
	dp[0][0]=1;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<=5000;j++){
			dp[i&1][j]=dp[!(i&1)][j]+(j>=a[i]?dp[(i&1)][j-a[i]]:0ll);
			dp[i&1][j]%=mod;
		}
	}
	
	for(int i=0;i<=5000;i++){
		dp[0][i]=dp[(n)&1][i];
	}
	for(int i=1;i<=5000;i++){
		dp[0][i]+=dp[0][i-1];
		dp[0][i]%=mod;
	}
	while(q--){
		int l,r;
		cin>>l>>r>>k;
		f.inn=1;
		f.cs[1]=0;
		f.xs[1]=1;
		for(int i=1;i<=k;i++){
			int x,y;
			cin>>x>>y;
			l-=y*a[x];
			r-=y*a[x];
			x=a[x];
			int g;
			g=f.inn;
			for(int j=1;j<=g;j++){
				f.cs[++f.inn]=f.cs[j]+x;
				f.xs[f.inn]=-f.xs[j];
			}
		}
		int ans;
		ans=0;
		for(int i=1;i<=f.inn;i++){
			int ll,rr;
			ll=l-f.cs[i];
			rr=r-f.cs[i];
			if(rr<0){
				continue;
			}
			ans+=(f.xs[i]+mod)%mod*dp[0][rr]%mod;
			ans%=mod;
			ll--;
			if(ll<0){
				continue;
			}
			ans-=(f.xs[i]+mod)%mod*dp[0][ll]%mod;
			ans+=mod;
			ans%=mod;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

---


# [CQOI2017] 小Q的棋盘

## 题目描述

小 Q 正在设计一种棋类游戏。

在小 Q 设计的游戏中，棋子可以放在棋盘上的格点中。某些格点之间有连线，棋子只能在有连线的格点之间移动。整个棋盘上共有 $V$ 个格点，编号为 $0,1,2,\cdots, V- 1$，它们是连通的，也就是说棋子从任意格点出发，总能到达所有的格点。小 Q 在设计棋盘时，还保证棋子从一个格点移动到另外任一格点的路径是唯一的。

小 Q 现在想知道，当棋子从格点 $0$ 出发，移动 $N$ 步最多能经过多少格点。格点可以重复经过多次，但不重复计数。


## 说明/提示

【输入输出样例 1 说明】

从格点 $0$ 出发移动 $2$ 步。经过 $0, 1, 2$ 这 $3$ 个格点。

【输入输出样例 2 说明】

一种可行的移动路径为 $0 \to 1 \to 3 \to 5 \to 3 \to 7$，经过 $0, 1, 3, 5, 7$ 这 $5$ 个格点。

【数据规模与约定】

对于 $100\%$ 的测试点，$1\le N,V ≤ 100$，$0 ≤a_i,b_i< V$。


## 样例 #1

### 输入

```
5 2
1 0
2 1
3 2
4 3```

### 输出

```
3```

## 样例 #2

### 输入

```
9 5
0 1
0 2
2 6
4 2
8 1
1 3
3 7
3 5```

### 输出

```
5```

# 题解

## 作者：冒泡ioa (赞：65)

> [安利下自己的博客](http://bubbleioa.top/archives/613)
> [题目链接](https://www.luogu.org/problemnew/show/P3698)

---

首先这是一颗树。

这一题我们用贪心的方法来解决，首先来看看样例：

![](http://bubbleioa.top/wp-content/uploads/2018/12/P3698-1.png)

样例1很不友好，不如不给，显然我们可以经过3个点。

![](http://bubbleioa.top/wp-content/uploads/2018/12/P3698-2.png)

我们可以从样例2发现我们的贪心策略。

为了实现经过的点最多的这一条件，我们希望每次走一步都多走一个点，如果我们选择最长链的话，在链上每走一步就多走了一个点，如果走不完最长链，那答案就是步数+1，而如果走完最长链还有剩余步数的话，每两步可以多访问一个节点。



**为什么剩余步数每两步可以多访问一个节点？**

对于没有全访问的情况（如果这种方法求出来的值大于总数，则输出总数），最长链上肯定存在一条边连着一个没有访问的节点 ，当走到这里的时候，可以花两步去访问再回来。

**为什么最长链是最优的？**

~~显然~~，因为如果我们不走最长链的话，我们走任意其他的链对答案的贡献都没有最长链大，虽然剩下的剩余步数多，但是根据上面的推论，每两个剩余步数才有一个贡献，因此最长链是最优的。



讲得已经比较清楚了，有些细节没有提到，建议先自己写一遍再看代码！！



## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 103;
int Nt[MAXN<<1],Head[MAXN<<1],to[MAXN<<1],tot;
bool used[MAXN];
int n,m;
int mx=0;

void add(int a,int b){
	Nt[++tot]=Head[a];
	to[tot]=b;
	Head[a]=tot;
}	

void dfs(int pos,int dep){//最长链可以用深搜跑最大深度得到
	used[pos]=1;
    mx=max(mx,dep);
	for(int i=Head[pos];i;i=Nt[i]){
		int y=to[i];
		if(used[y])continue;
		dfs(y,dep+1);
	}
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++){
		int a,b;
		scanf("%d%d",&a,&b);
		add(a,b);add(b,a);
	}
	dfs(0,1);
	if(m<=mx-1)printf("%d\n",m+1);//如果走不完最长链，那答案就是步数+1
	else printf("%d\n",min(n,mx+(m-mx+1)/2));
	return 0;
}
```



---

## 作者：XZYQvQ (赞：24)

# 题解

//我的第一个树型dp？（可能以前打过树型dp然而我并不知道那是树型dp）

很明显是棵树！

暴力不能过！

所以树型dp（然而很奇怪，贪心可以AC！那俩位打贪心の神犇说可以证明，然而我不会！）。


首先我们得知道这个东西：

对于一个节点，我们选中一个它的儿子节点。对于这种选法，我们有三种走的方法：

1. 向儿子节点的方向一条路走到黑，不返回到当前节点。

2. 向儿子节点的方向走一圈回来。

3. 向儿子节点的方向走一圈回来且再向另一个方向一条路走到黑，不会来。


简要地说就是：

1. ↙
2. ⟲
3. ⟲↘


走法1和2不会返回到当前节点，当然也就没法回到当前节点的父亲节点。

所以我们分两个数组存状态：

$f0[i][j]$表示当前到了节点$i$，还可以走$j$步时**不需要**回到节点$i$时最多可以访问的节点数。

$f1[i][j]$表示当前到了节点$i$，还可以走$j$步时**需要**回到节点$i$时最多可以访问的节点数。


具体：

对于$dfs(u)$，我们枚举子节点为i，再从n（最多可以走的步数）到1枚举当前剩余步数为j，再从1到j枚举下一步的剩余步数k。

对于走法1，需要满足$j-k>0$，然后：$f[0][u][j]=max(f[0][u][j],f[0][*i][k]+f[1][u][j-k-1])$

对于走法2，需要满足$j-k>=2$，然后：$f[1][u][j]=max(f[1][u][j],f[1][*i][k]+f[1][u][j-k-2])$

对于走法3，需要满足$j-k>=2$，然后：$f[0][u][j]=max(f[0][u][j],f[1][*i][k]+f[0][u][j-k-2])$


为什么走法1和走法2要加一个$f[1][u][j-k-1]$或$f[1][u][j-k-2]$呢？

因为我们可以先从别的地方绕一圈回来，再执行走法1、走法2。


还有，枚举j的时候一定要从大到小，原因就像01背包，要从大的到小的更新，不然状态之间会互相影响，然后wa（考试的时候脑子抽了就写错了这里，掉了50分）。


其他具体看代码吧！


```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename tp>void in(tp & dig)
{
    char c=getchar();dig=0;
    while(!isdigit(c))c=getchar();
    while(isdigit(c))dig=dig*10+c-'0',c=getchar();
}
int v,n,f[2][105][105],fa[105];
list<int> g[105];
void initdfs(int u)
{
    for(list<int>::iterator i=g[u].begin();i!=g[u].end();i++)
        if(*i!=fa[u])
            fa[*i]=u,initdfs(*i);
}
void dfs(int u)
{
    f[0][u][0]=f[1][u][0]=1;
    for(list<int>::iterator i=g[u].begin();i!=g[u].end();i++)
        if(*i!=fa[u])
        {
            dfs(*i);
            for(int j=n;j>0;j--)
                for(int k=0;k<j;k++)
                {
                    if(j-k>=2)
                    {
                        f[1][u][j]=max(f[1][u][j],f[1][*i][k]+f[1][u][j-k-2]);
                        f[0][u][j]=max(f[0][u][j],f[1][*i][k]+f[0][u][j-k-2]);
                    }
                    f[0][u][j]=max(f[0][u][j],f[0][*i][k]+f[1][u][j-k-1]);
                }
        }
    for(int i=1;i<=n;i++)
        f[0][u][i]=max(f[0][u][i],f[0][u][i-1]),
        f[1][u][i]=max(f[1][u][i],f[1][u][i-1]);
}
int main()
{
    in(v),in(n);
    for(int i=1,a,b;i<v;i++)in(a),in(b),g[a].push_back(b),g[b].push_back(a);
    initdfs(0),dfs(0),printf("%d\n",f[0][0][n]);
    return 0;
}
```

---

## 作者：BzhH (赞：15)

看到这道题，很容易想到是一道树型DP，那么该如何做？

首先我们可以先这样定义状态，$f_{i,j}$表示以$i$为根节点,向下走$j$步最多能经过多少点,但很明显,只是这样是不行的,所以我们再加一维,第三维为0表示不会到根节点,第三维为1表示需要回到根节点,那么就可以得出状态转移方程

$\begin{cases}f_{i,j,0}=max(f_{i,j-t,0}+f_{v,t-2,1},f_{i,j-t,1}+f_{v,t-1,0})\\f_{i,j,1}=max(f_{i,j-t,1}+f_{v,t-2,1})\end{cases}$

(其中$i$表示父节点,$j$表示一共走了多少步,$v$表示儿子节点,$t$表示儿子节点向下走多少步)

注意到这里面为什么要减一个1或2,因为向下走如果要回来,那么就还需要经过2次父亲与儿子之间的边,如果不会来,就只需要经过一次.

那么代码就很容易得出

```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int n, k;
int head[205], ver[205], net[205], tot, f[205][205][2];

void add(int a,int b)
{
    net[++tot] = head[a];
    head[a] = tot;
    ver[tot] = b;
}

void dfs(int u,int fa)
{
    f[u][0][0] = f[u][0][1] = 1;
    for (int i = head[u]; i; i = net[i])
    {
        int v = ver[i];
        if(v == fa)
            continue;
        dfs(v, u);
        for (int j = k; j >= 0; j--)
        {
            for (int t = 0; t <= j; t++)
            {
                f[u][j][0] = max(f[u][j][0], max(f[u][j - t][0] + f[v][t - 2][1], f[u][j - t][1] + f[v][t - 1][0]));
                f[u][j][1] = max(f[u][j][1], f[u][j - t][1] + f[v][t - 2][1]);
            }
        }
    }
}

int main()
{
    scanf("%d%d", &n, &k);
    for (int i = 1; i < n; i++)
    {
        int u, v;
        scanf("%d%d", &u, &v);
        add(u + 1, v + 1), add(v + 1, u + 1);
    }
    dfs(1, -1);
    int ans = 0;
    for (int i = 0; i <= k; i++)
        ans = max(ans, f[1][i][0]);
    printf("%d", ans);
}
```


---

## 作者：UnnamedOrange (赞：10)

设 $f_{i, j}$ 表示在 $i$ 所在子树中走 $j$ 步时能够最多能够走到多少个点。

发现这么一个事情：如果往下走要回来，假设走 $k$ 步，只要结点够，那么一定能够访问到 $\frac {k} {2}$ 个结点。对于一个结点，我们枚举一个它的子结点和一个在子结点中走的步数，得到可以不返回时的访问数 $f_{to}$，再加上走剩下的子树且一定返回的访问数 $\frac {i - j - [\mathrm{is~root}]} {2}$，取最大值便是答案。

---

## 作者：BDFCL (赞：9)

**Solution-1**

首先观察题目的关键词：树，走$n$步，最大化经过点数，$N,V\leq 100$，很容易想到这是一个树形$dp$的题目

我们设$f(u, i)$表示当前走到节点$u$，走了$i$步所能达到的最大点数，那么我们有两种可能性：

* 从$u$的子树中绕几个圈圈后回来
* 在$u$的子树中绕几个圈圈后在向某一个子树一路走到死

所以我们多记一维$0/1$表示是否回头（回头为$1$，不回头为$0$）

对于$f(u, i, 1)$，显然只能从$f(v, i, 1)$转移过来，其中$v\in Son_u$，这个转移同树形背包类似，即将$u$的每个儿子的$dp$值看作一些物品，其中对于每个$v\in Son_u$，$f(v, i)$必只能选一个，即为分组背包。然后每个$dp$值$f(v, i)$为的代价为$i+2$（$+2$是因为要从$Edge(u, v)$要走两次），价值为$f(v, i)$，对其做分组背包即可

对于$f(u, i, 0)$，我们发现当我们枚举$u$的儿子$v$的时候，有三种可能：

* 在$v$处一路走到死
* 在$v$前某一个点一路走到死
* 在$v$后某一个点一路走到死

显然第$3$种可能可以被第$1$、$2$种可能覆盖（当枚举到后面的儿子的时候），因而我们只要考虑前两种就行了

对于第一种，相当于要从上一个没有一路走到死的状态转移过来，即为：
$$
f (u, i, 0) = \max \{ f(u, i-k-1, 1) + f(v, k, 0)\}
$$
对于第二种，要从上一个已经一路走到死的状态转移过来，即为：
$$
f(u, i, 0) = \max \{f(u, i-k-2,0) + f(v, k, 1)\}
$$
所以总的方程式为：
$$
f(u, i, 0) = \max {\begin {cases} \max (\{ f(u, i-k-1, 1) + f(v, k, 0)\}, \\ \max \{f(u, i-k-2,0) + f(v, k, 1)\} \\ \end {cases} }
$$
$$
f (u, i, 1) = \max \{ f(v, i-k-2, 1) + f(v, k, 1) \}
$$
时间复杂度看似是$O(N^4)$的但其实是$O(N^3)$，因为每个$dp$状态最多只被用了$N$次

**Code-1**

(这里由于习惯将题目中的$V$改为了$n$变量，将题目中的$N$改为了$m$变量)

```c++
#include <bits/stdc++.h>

#define N (int) 105

using namespace std;
int input () {
    int x = 0, f = 0;
    char c = getchar ();
    while (c < '0' || c > '9') f = c == '-', c = getchar ();
    while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + (c ^ 48), c = getchar ();
    return f ? - x : x;
}

int n, m;
struct Edge {
    int v, nxt;
} edge[N<<1];
int fst[N], ecnt;
void add_edge (int u, int v) {
    edge[ecnt].v = v, edge[ecnt].nxt = fst[u], fst[u] = ecnt ++;
}
void init_e () {
    memset (fst, -1, sizeof (fst));
}

int dp[N][N][2];
void dfs (int u, int f) {
    for (int e = fst[u]; e != -1; e = edge[e].nxt) {
        int v = edge[e].v;
        if (v == f) continue;
        dfs (v, u);
    }

    dp[u][0][1] = dp[u][0][0] = 1;
    for (int e = fst[u]; e != -1; e = edge[e].nxt) {
        int v = edge[e].v;
        if (v == f) continue;
        for (int i = m; i >= 1; i --) {
            for (int j = 0; j < i; j ++) {
                if (i-j-2 >= 0) {
                    dp[u][i][1] = max (dp[u][i][1], dp[u][i-j-2][1] + dp[v][j][1]);
                    dp[u][i][0] = max (dp[u][i][0], dp[u][i-j-2][0] + dp[v][j][1]);
                }
                dp[u][i][0] = max (dp[u][i][0], dp[u][i-j-1][1] + dp[v][j][0]);
            }
        }
    }
}

int main () {
    init_e ();
    
    n = input (), m = input ();
    for (int i = 1; i < n; i ++) {
        int u = input (), v = input ();
        u ++, v ++;
        add_edge (u, v);
        add_edge (v, u);
    }

    dfs (1, 0);

    int ans = 0;
    for (int i = 1; i <= m; i ++) ans = max (ans, max (dp[1][i][0], dp[1][i][1]));
    cout << ans << endl;

    return 0;
}
```

**Solution-2**

*（我看了题解才发现可以贪心，而且复杂度更优，看来还是我tcl T_T）*

好多题解都提到了贪心的做法，其实如果说$n$出到$1e5+$这个样子的话会更为明显一点

还是参照我们之前的分析，我们发现路径一定是绕几个圈圈后再一路走到死，我们设绕圈圈到达的点数为$A$，最后一路走到死到达的点数为$B$，那么我们所走的步数为$A \times 2 + B$，显然当$B$最长时是最优的，所以我们找到最长的链然后就可以直接求出答案。这里许多题解都说的很清楚了，就不再赘述，这里给出较为简略的证明：

我们设最后的一路走到死的那条路径上的点数为$L$，则所能走到的点数为$Ans = \min \{V, L+\frac {N-(L-1)}{2}\} = \min \{V, \frac {N+L+1}{2}\}$

显然$Ans$关于$L$单调递增

时间复杂度（如果没估错的话）：$O(N)$

**Code-2**

咕咕咕



---

## 作者：Lates (赞：5)

树形dp题单怎么会有这题（

看了半天终于懂了。

---

考虑贪心

显然第一次走从根的最长链最优，记最长链长度为 $l$。

- 当 $N\le l$ 时，这时答案即为可走的步数 +1 （根节点）

- 当 $N>l$ 时，这时答案就是 $l+$ 剩下可以到达的不同点的个数。

我们发现，访问一个点要用 2 步，即为一去一回。

对于我们的最长链，我们肯定是到最后不会回到原来的点，即是访问完剩下可以走的点然后走最长链（或者是在最长链中顺便走剩下的点）。

对于样例 2，假设这里的最长链就是 $0->1->3->5$

那么这里的访问顺序应该是 $0->1->3->7->3->5$ (即为在最长链没访问完的时候顺便把剩下的搞掉)

于是答案就是 $min(V,l+\dfrac{N-(l-1)}{2})$，这里 $N-(l-1)$ 就是走完最长链剩下的步数。由于我们算的式子的值有可能大于 $V$，于是我们取两个的最小值。

代码很简单了，看懂了应该都能写出来（

---

## 作者：王小宇 (赞：5)

### 刚开始还觉得是个DP，旁边的同学也往DP方面思考，但觉得转移方程不好推。

### 对面的学长说这个题是个贪心，那就照着贪心来做吧。

## 首先，我们想要经过的点最多，并且少用点步数，就应该先沿着一条链往下走，如果走到底步数还没用完的话，肯定就会再转到另一条链上往下走。这个就类似于DFS了。

## 我们来考虑一下，如果这一条链走到最后一点之后，它还剩下没用的步数，那么它应该是从这个链的最后一个节点返回到根节点后继续去别的链上搜。这个时候，它还能（剩下总步数-这条链的节点数+1）个步数。而这个时候它还要返回根节点，所以要白白耗费掉（剩下总步数-这条链的节点数+1）/2个步数。那么最终还能剩下（剩下总步数-这条链的节点数+1）/2个闲置的步数。如果，这个闲置的步数+当前链的节点数还要比总的节点数大，那么就只能输出节点数了，否则就输出它俩的和。

### 有点绕，但如果画一个图，就容易理解多了，仔细想想。

我用的邻接表来存图。

### 明白思路之后，看代码，有注释

```cpp
#include<iostream>
#include<algorithm>
#include<string.h>
#include<math.h>
#include<cstdio>
#include<queue>
using namespace std;
struct kkk{
    int next,to;
}edge[201];//用邻接表来存图
int head[101];
bool visited[101];
int nodenum,stepnum,now,ans,maxstep;
void search(int u,int father,int step,int ansnow)//u代表当前节点，father代表当前节点的父节点，step代表当前已经用的步数，ansnow代表当前已经访问过的节点个数
{
    int i,v;
    if (step>stepnum) return;//如果当前步数比总的步数还要大就return
    ans=max(ans,ansnow);//更新能访问的最大节点个数
    maxstep=max(step,maxstep);//更新用的最多的步数，一会输出的时候判断要用到
    visited[u]=true;//把当前节点设置为已访问过
    for (i=head[u];i;i=edge[i].next)//枚举每一条与当前节点相连接的边
    {
        v=edge[i].to;//v是当前边通向的那个点
        if (v==father) continue;//如果v点是u点的父亲就continue，否则会卡住
        if (visited[v]==false) search(v,u,step+1,ansnow+1);//如果v点还没有访问过，就继续search，当前点就变成了v点，它的父节点也就成了u点，当前用的步数要+1，当前访问过的节点个数也要+1
    }
}
void add(int a,int b)//存图
{
    now++;
    edge[now].to=b;
    edge[now].next=head[a];
    head[a]=now;
}
int main()
{
    int i,a,b,left;
    memset(visited,0,sizeof(visited));
    scanf("%d%d",&nodenum,&stepnum);//读入总的节点数和总的步数
    for (i=1;i<=nodenum-1;i++)
    {
        scanf("%d%d",&a,&b);
        add(a,b);
        add(b,a);//注意，这个题建的是双向边
    }
    search(0,0,0,1);//开始按照贪心来搜索
    if (maxstep==stepnum) printf("%d\n",ans);//如果用的最大步数等于总的步数，则证明所有步数正好用完，就按照ans原样输出
    else//否则，就代表走到这一条链的最后一个节点的时候还剩下了可用的步数，那么就应该转到另一个条链上去
    {
        left=stepnum-ans+1;//left是从根节点走到当前链最后一个节点后还剩下的步数
        if ((ans+left/2)>=nodenum) printf("%d\n",nodenum);//如果这一条链上的节点数+从这条链的最后一个点返回根节点后剩下的步数要比总的节点数大，那么就只能输出总的节点数。
        else printf("%d\n",ans+left/2);//否则就输出这条链上的节点数+还能最后再走的步数（节点数）
    }
    return 0;
}
```
## 这道题还是挺。。。有点坑的，比较容易往DP方面想，但是那样的话比较难推出来动态转移方程。

## 如果能想到是贪心，就相对来说容易很多了。

### 个人感觉还是挺好的一道题的


---

## 作者：Aw顿顿 (赞：4)

考虑一个贪心策略，并简单证明一下贪心。

题意等价于：

> 对于一棵树，从指定的根节点出发走 $n$ 步一共能遍历多少个节点。

走 $n$ 步在不重复遍历的情况下至多遍历 $\min(v,n+1)$ 个节点，其中一个节点是根节点。那么考虑随意走一条长度为 $l$ 的链，分类讨论：

- 若 $l\ge n$，则恰好能够用完所有的步数，一共遍历 $n+1$，此时是最优的。
- 若 $l<n$，则我们在遍历这条链的途中一定能够找到某一个岔路，使得我们可以分支出去遍历回来。

走岔路再遍历回来每个点需要经过两边，也就是说一共能遍历 $\left\lceil\frac{n-l}{2}\right\rceil$ 个点。

此时总共 $n$ 步能够遍历的点是 $l+\left\lceil\frac{n-l}{2}\right\rceil$，设步数为 $f(l)$ 再次分类讨论得到：

$$f(l)=\begin{cases}\frac{n+l}{2}&(n-l)\equiv 0\pmod 2\\\frac{n+l+1}{2}&(n-l)\equiv 1\pmod 2\end{cases}$$

他们显然都是关于 $l$ 的增函数（求导考虑符号，或者直接目测），所以贪心策略就是选择尽可能大的 $l$。因此题目等价转化为求最长链。而最长链的长度可以用 DFS 求取。

对于答案：

- 如果 $l>n$，那么输出 $n+1$ 即可。
- 反之，考虑岔路贡献：
	- 若总步数可以遍历所有点，输出 $v$。
    - 否则输出 $l+\left\lceil\frac{n-l}{2}\right\rceil$。

考虑到整型除法自动向下取整，那么你加一之后进行除法即可，代码实现如下：

```cpp
#include<bits/stdc++.h>
#define N 205
using namespace std;
struct edge{
	int v,nxt;
}e[N];
bool vis[N];
int h[N],cnt,V,n,mx;
void add(int u,int v){
	e[++cnt].nxt=h[u];
	e[cnt].v=v;h[u]=cnt;
}void dfs(int x,int dep){
	vis[x]=1;mx=max(mx,dep);
	for(int i=h[x];i;i=e[i].nxt){
		int v=e[i].v;
		if(!vis[v])dfs(v,dep+1);
	}
}signed main(){
	scanf("%d%d",&V,&n);
	for(int i=1;i<V;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);add(v,u);
	}dfs(0,1);
	if(mx>n)printf("%d\n",n+1);
	else printf("%d\n",min(V,mx+((n-mx+1)>>1)));
	return 0;
}
```





---

## 作者：Rockdu (赞：3)

楼下dalao观察的性质真的十分巧妙

蒟蒻的我根本没有想到这些性质

既然大家的做法都这么优雅，那么我来写一个莽夫做法吧

考虑处理树上路径的一种套路

我们记f(u,j)表示从u往子树中走j步回到u的最多经过点数
记g(u,j)表示从u往子树中走j步不一定回到u的最多经过点数
考虑f(u,j)可以用所有儿子的f数组合并而来，合并过程类似背包。

但是g(u,j)怎么计算呢？

发现如果不一定回到u的话我们的路径一定长成这个样子：在一些子树中(包括空子树)绕了回来，并且在这些子树之外的某棵子树走了下去。

假设最后从v走了下去。由于不可以从v绕一圈再从v走下去，我们需要得到除了v子树以外，其他子树合并后的f数组。

考虑对每一层dp数组做前缀和、后缀和操作。

具体的来说，我们把儿子合并到根的子问题看成一个序列问题，把儿子依次排布看成序列。那么我们如果对于每一个i预处理出它前缀合并成的f数组和后缀合并成的f数组，就可以把刨开v子树转化成合并一个前缀和一个后缀。这道题就可以通过了。
```
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn = 205;
struct edge {
    int v, next;
} e[maxn << 1];
int head[maxn], cnt;
void adde(const int &u, const int &v) {
    e[++cnt] = (edge) {v, head[u]};
    head[u] = cnt;
}
int n, k, u, v, f[maxn][maxn];
int Lf[maxn][maxn], Rf[maxn][maxn], g[maxn][maxn];
int L[maxn], R[maxn], lst[maxn], tmp[maxn][maxn];
void merge(int a[maxn], int b[maxn]) {
	for(register int j = k; j >= 2; --j) {
        for(register int l = j - 2; l >= 0; --l)
            a[j] = max(a[j], a[j - l - 2] + b[l]);
    }
}
void DPpref(int u) {
	int now = lst[u];
	if(now == -1) return;
	while(~L[now]) merge(Rf[L[now]], Rf[now]), now = L[now];
	while(~R[now]) merge(Lf[R[now]], Lf[now]), now = R[now];
}
void DPF(int u, int p) {
	int last = -1;
    for(register int i = head[u]; i; i = e[i].next) {
        int v = e[i].v;
        if(v == p) continue;
        if(~last) 
			lst[u] = v, L[v] = last, R[last] = v;
        last = v, DPF(v, u);
        merge(f[u], f[v]);
        memcpy(Rf[v], f[v], sizeof(f[v]));
        memcpy(Lf[v], f[v], sizeof(f[v]));
    }
    DPpref(u);
    for(register int j = k; j >= 0; --j)
        if(f[u][j]) ++f[u][j];
    f[u][0] = 1;
}

void DPG(int u, int p) {
	for(register int i = head[u]; i; i = e[i].next) {
		int v = e[i].v;
		if(v == p) continue;
		DPG(v, u);
		if(~L[v]) merge(tmp[v], Lf[L[v]]);
		if(~R[v]) merge(tmp[v], Rf[R[v]]);
		for(register int j = k; j >= 1; --j) {
	        for(register int l = j - 1; l >= 0; --l)
	            tmp[v][j] = max(tmp[v][j], tmp[v][j - l - 1] + g[v][l]);
	        g[u][j] = max(g[u][j], tmp[v][j]);
	    }
	}
	for(register int j = k; j >= 0; --j)
        if(g[u][j]) ++g[u][j];
	g[u][0] = 1;
}

int main() {
	memset(L, -1, sizeof(L));
	memset(R, -1, sizeof(R));
	memset(lst, -1, sizeof(lst));
    scanf("%d%d", &n, &k);
    for(register int i = 1; i < n; ++i)
        scanf("%d%d", &u, &v), adde(u, v), adde(v, u);
    DPF(0, -1); 
    DPG(0, -1);
    printf("%d", g[0][k]);
    return 0;
}
```

---

## 作者：kouylan (赞：1)

## 题解 P3698 【[CQOI2017]小Q的棋盘】

### 【题意】
给你一棵大小为$n$的树，问从$0$节点出发，在$m$步以内最多能经过多少节点。

### 【分析】
这道题当然是用贪心做最简单啦！

贪心的想，我们要尽量避免重复经过同一个节点（或同一条边），所以我们要挑长的路径走。第一次，我们先从根节点走最长的路径（设此长度为$mx$）。接下来，我们分两种情况讨论。

1. **当$mx>m$时**，就代表走不完最长的路径，那么答案就是$m+1$（加上根节点$0$）

1. **反之**，就代表走完了最长的路径之后，还有步数剩余。那此时，我们到一个节点就需要$2$步（一去一回），注意此时是上取整。

下面是AC代码。
```cpp
/*
luogu P3698
*/
#include <bits/stdc++.h>
using namespace std;

int n,m;
int mx;
int ee,h[105],nex[105<<1],to[105<<1];

void addedge(int x,int y)
{
	nex[++ee] = h[x];
	to[ee] = y;
	h[x] = ee;
}

void dfs(int x,int pre,int dep)
{
	mx = max(mx,dep);
	for(int i=h[x];i;i=nex[i])
		if(to[i]!=pre)
			dfs(to[i],x,dep+1);
}

int main()
{
	cin>>n>>m;
	for(int i=1,x,y;i<n&&cin>>x>>y;i++)
	{
		x++;
		y++;
		addedge(x,y);
		addedge(y,x);
	}
	dfs(1,0,1);
	if(mx>m)
		cout<<m+1<<endl;
	else
		cout<<min(mx+(m-mx+1)/2,n)<<endl;
	
	return 0;
}
```

祝大家AC愉快！

---

## 作者：TonyYin (赞：0)

## 题意

给定一棵 $n$ 个节点的有根树，定义一次移动为：从当前所在节点移动到一个相邻节点。问从根节点出发，移动 $k$ 次后，最多经过多少个不同的节点。

每个节点可以被重复经过，但只计算一次。

$n\leq 100$.

## 分析

这道题可以用树形 DP 来做，这里只提供时间复杂度更优的**贪心**做法。

首先很容易想到，我们要尽可能保证每一次移动都到达一个新的节点，所以要先向深度最深的节点走。

如果走的过程中，$k$ 次移动机会就用完了，答案即为 $k$.

若否，我们要耗费尽可能少的移动次数，来到达一个新的节点。可以发现，在走完最长链之后，**每到一个新节点都只需要 $2$ 步**。

![Snipaste_2021-05-12_16-34-24.png](https://cdn.tonyyin.top/2021/05/12/4793df5361e84.png)

如上图所示。先选择最长链 $1\to 2\to 5\to 9\to 12$. 此时如果要再添加点，只需要找一个**与任意一个被选节点相邻**的节点即可。

比如选择了点 $4$，那路径就变成：$1\to 2\to 4\to 2\to 5\to 9\to 12$.

由于每次新选的点，都与一个路径中的点相邻，所以只要在路径中插入两步，一定可以走到这个新的节点。

因此，在选完最长链之后，剩余的步数**每两步都可以走到一个新的节点**。

形式化地，设这棵树的节点个数为 $n$，最长链长度为 $l$，可用步数为 $k$，可以这样表示出答案：

- 若 $k\leq l - 1$，步数只够在最长链上移动，则答案为 $k$.
- 若 $k > l - 1$，走完最长链之后有剩余步数，则答案为：

$$
\max
\left\{
\begin{array}{lr}
l + \left\lfloor{\frac{k-l+1}{2}}\right\rfloor\\
n
\end{array}
\right.
$$

这里注意，如果步数足够多，也最多只能走完所有点，此时答案为 $n$.

时间复杂度为 $\mathcal{O}(n)$.

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 108;
int n, k;
struct Edge{
    int to, nxt;
}edge[MAXN << 1];
int head[MAXN], e_cnt = 0;
void add(int u, int v) {
    edge[++e_cnt].to = v;
    edge[e_cnt].nxt = head[u];
    head[u] = e_cnt;
}
int deepest = 1;//最长链的长度
void dfs(int x, int fa, int dep) {
    deepest = max(deepest, dep);
    for(int i = head[x]; i; i = edge[i].nxt) {
        int v = edge[i].to; if(v == fa) continue;
        dfs(v, x, dep + 1);
    }
}
int main() {
    scanf("%d%d", &n, &k);
    for(int i = 1; i < n; i++) {
        int a, b; scanf("%d%d", &a, &b); a++, b++;
        add(a, b); add(b, a);
    }
    dfs(1, 0, 1);
    if(deepest >= k + 1) cout << k + 1 << endl;
    else cout << min(deepest + (k - deepest + 1) / 2, n);
    return 0;
}
```

---

## 作者：lgswdn_SA (赞：0)

这道题应该比较偏贪心吧。

首先，不走回头路一定是最好的选择（不浪费每一步）。我们考虑最多怎么样才能不走回头路。很显然，走**最长链**。

如果最长链大小比 $n$ 大，那么铁打的走最长链，输出 $n$。

如果最长链大小比 $n$ 小，我们还要走最长链吗？既然最终的答案是 $n-$冤枉路，那么冤枉路肯定越少越好，所以当然要走最长链以减少冤枉路（但不一定是一开始就走最长链）。

所以我们可以把这棵树想象成一个最长链上长了几个枝头。（自行想象一个这样的树干）

对于多出来的部分，由于最终一定要回归到最长链上的点，所以必须返回。也就是说，每到达一个新的点，就需要多走 $2$ 步（去一步，回一步）。

设最长链大小为 $k$，那么最终答案就是 $k+(n+1-k)/2$。 

建议大家写代码还是节点用 $n$，我因为 $n,v$ 没有搞清楚 WA 了好几发。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=109;

struct edge {int to,nxt;}e[N*2]; int hd[N],tot;
void add(int u,int v)  {e[++tot]=(edge){v,hd[u]};hd[u]=tot;}

int h[N],mx;
void dfs(int u,int fa) {
	for(int i=hd[u],v;i;i=e[i].nxt) {
		if((v=e[i].to)==fa) continue;
		dfs(v,u);
		h[u]=max(h[u],h[v]+1);
	}
	h[u]=max(h[u],1);
}

int main() {
	int vv,n; scanf("%d%d",&vv,&n);
	for(int i=1,u,v;i<vv;i++)
		scanf("%d%d",&u,&v), add(u+1,v+1), add(v+1,u+1);
	dfs(1,0);
	printf("%d",(h[1]>n+1)?n+1:min(vv,h[1]+(n+1-h[1])/2));
	return 0;
}
```

---

## 作者：nofind (赞：0)

题意：https://www.luogu.org/problem/P3698

考虑贪心

为了不回头浪费步数,我们会尽量走一条链,于是求出最长链深度$d$,如果$m<=d$,直接输出$m+1$,如果$m>d$,那么我们在走最长链前或者过程中会走一些短链,但我们最后还要走回最长链上继续走,于是短链要走两边,答案为$d+(m-d+1)/2$

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=110;
int n,m,cnt,maxx;
int head[maxn],dep[maxn];
struct edge{int to,nxt;}e[maxn<<1];
inline void add(int u,int v){e[++cnt].nxt=head[u];head[u]=cnt;e[cnt].to=v;}
inline void dfs(int x,int fa)
{
	dep[x]=dep[fa]+1;
	for(int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].to;
		if(y==fa)continue;
		dfs(y,x);
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++)
	{
		int u,v;scanf("%d%d",&u,&v);u++,v++;
		add(u,v),add(v,u);
	}
	dfs(1,0);
	for(int i=1;i<=n;i++)maxx=max(maxx,dep[i]);
	if(m<=maxx)printf("%d",m+1);
	else printf("%d",min(n,maxx+(m-maxx+1)/2));
	return 0;
}
```


---

## 作者：Robert (赞：0)

容易发现，先走以0为起点的最长链是最优的
走完以0为起点的最长链后，剩下的节点，每个都需要两步来“经过”（可以在纸上画画）
这样就成就了一个特别好理解的贪心算法

（代码太长，勿喷）

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
#define re return
#define MM 110
struct edge{int v,nex;}e1[MM<<1];int elen=0,head[MM];
inline void adde(int u,int v){
	e1[++elen].v=v;e1[elen].nex=head[u];head[u]=elen;
}//以上是前向星存图 
int n,m,dep[MM];
inline void dfs1(int u){
	for(int ee=head[u];ee;ee=e1[ee].nex){
		int v=e1[ee].v;
		if(dep[v])continue;
		dep[v]=dep[u]+1;
		dfs1(v);
	}
} 
int main(){
	scanf("%d%d",&n,&m);
	int x,y;
	for(int i=1;i<n;++i){
		scanf("%d%d",&x,&y);
		++x;++y;//不喜欢0-n-1的我 
		adde(x,y);adde(y,x);
	}
	dep[1]=1;//0处深度设为1 
	dfs1(1);//寻找最深点（其实可以优化） 
	int d=1;
	for(int i=2;i<=n;++i)if(dep[i]>dep[d])d=i;
	d=dep[d];//找到最深点的深度（以0为起点的最长链长度） 
	++m;//步数加1，因为0-1走了一步，却经过了两个格点 
	if(m<=d){
		printf("%d\n",min(m,d));//步数不够最长链长的情况 
		return 0;
	}
	m-=d;
	int ans=d;
	int res=n-d;//剩下不在 最长链上的点的数量 
	if(res==0){
		printf("%d\n",ans);//没有点那d就是答案了 
		return 0;
	}
	if(m&1){
		++m;//m如果为奇数，那就一去不复返吧，跟偶数没什么区别 
	}
	ans+=min(m/2,res);//关键一步：剩下的点每走一个需要两步 
	printf("%d\n",ans);
	re 0;
}
```

---


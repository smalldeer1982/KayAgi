# 小夫

## 题目背景

![](bilibili:BV19w411k7WT)

## 题目描述

给定一个长为 $n$ 的整数序列 $a$，有 $m$ 次询问：

* ```l r```：求 $l\le x<y<z\le r,a_x:a_y:a_z=4:2:3$ 的三元组 $(x,y,z)$ 的个数。

## 说明/提示

对于所有测试数据，保证：$1\le n,m,a_i\le2\times10^5$，$1\le l\le r\le n$。

| Subtask | 限制 | 分值 |
| :----------: | :----------: | :----------: |
| $0$ | $n,m\le10^2$ | $5$ |
| $1$ | $n,m\le10^4$ | $10$ |
| $2$ | $2\le a_i\le 4$ | $20$ |
| $3$ | - | $65$ |

## 样例 #1

### 输入

```
10 5
4 4 2 3 2 3 3 4 2 3
1 5
3 7
1 10
5 10
4 8```

### 输出

```
2
0
17
1
0```

# 题解

## 作者：dyc2022 (赞：7)

只能说是非常套路的题目吧。赛时最后半小时入场，可能不到 $15$ 分钟切掉。

$4:2:3$ 不大好做，先考虑数区间中 $2:1$ 的数对有多少个。

这个是很经典的，考虑进行莫队，开个桶数区间中每一个数字出现多少次，每在开头插入一个 $a_k$，若 $a_k$ 为偶数，则将答案加上其产生的贡献即 $\frac{a_k}{2}$ 出现次数；从末尾插入一个 $a_k$，同理将贡献加上 $2 \times a_k$ 的出现次数。删除同理。

可以用同样的方法求出 $2:3$ 的数对有多少个。

那么做到这里我们就会了。我们可以维护对于每个数字开头、结尾的 $2:1$ 与 $2:3$ 数对数量，然后每从开头插入一个数字 $a_k$，产生的贡献就是以 $\frac{a_k}{2}$ 为开头的 $2:3$ 数对数量；每从结尾插入一个 $a_k$，产生的贡献就是以 $\frac{2a_k}{3}$ 为结尾的 $2:1$ 数对数量。

那么我们就使用普通莫队完成了这一道题，复杂度 $O(m \sqrt n)$。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
#define N 800006
using namespace std;
int n,m,a[N],B,bel[N],outp[N];
int cnt[N],c42h[N],c42t[N],c23h[N],c23t[N],c423h[N],c423t[N],ans;
struct Node{int l,r,id;}q[N];
void addh(int k)
{
    if(a[k]%4==0)c423h[a[k]]+=c23h[a[k]/2],c423t[a[k]/4*3]+=c23h[a[k]/2],ans+=c23h[a[k]/2];
    if(a[k]%2==0)c42h[a[k]]+=cnt[a[k]/2],c42t[a[k]/2]+=cnt[a[k]/2];
    if(a[k]%2==0)c23h[a[k]]+=cnt[a[k]/2*3],c23t[a[k]/2*3]+=cnt[a[k]/2*3];
    cnt[a[k]]++;
}
void addt(int k)
{
    if(a[k]%3==0)c423t[a[k]]+=c42t[a[k]/3*2],c423h[a[k]/3*4]+=c42t[a[k]/3*2],ans+=c42t[a[k]/3*2];
    if(a[k]%1==0)c42t[a[k]]+=cnt[a[k]*2],c42h[a[k]*2]+=cnt[a[k]*2];
    if(a[k]%3==0)c23t[a[k]]+=cnt[a[k]/3*2],c23h[a[k]/3*2]+=cnt[a[k]/3*2];
    cnt[a[k]]++;
}
void delh(int k)
{
    cnt[a[k]]--;
    if(a[k]%2==0)c42h[a[k]]-=cnt[a[k]/2],c42t[a[k]/2]-=cnt[a[k]/2];
    if(a[k]%2==0)c23h[a[k]]-=cnt[a[k]/2*3],c23t[a[k]/2*3]-=cnt[a[k]/2*3];
    if(a[k]%4==0)c423h[a[k]]-=c23h[a[k]/2],c423t[a[k]/4*3]-=c23h[a[k]/2],ans-=c23h[a[k]/2];
}
void delt(int k)
{
    cnt[a[k]]--;
    if(a[k]%1==0)c42t[a[k]]-=cnt[a[k]*2],c42h[a[k]*2]-=cnt[a[k]*2];
    if(a[k]%3==0)c23t[a[k]]-=cnt[a[k]/3*2],c23h[a[k]/3*2]-=cnt[a[k]/3*2];
    if(a[k]%3==0)c423t[a[k]]-=c42t[a[k]/3*2],c423h[a[k]/3*4]-=c42t[a[k]/3*2],ans-=c42t[a[k]/3*2];
}
main()
{
    scanf("%lld%lld",&n,&m),B=pow(n,0.5);
    for(int i=1;i<=n;i++)scanf("%lld",&a[i]),bel[i]=i/B+1;
    for(int i=1;i<=m;i++)scanf("%lld%lld",&q[i].l,&q[i].r),q[i].id=i;
    sort(q+1,q+1+m,[](Node x,Node y){
         return (bel[x.l]^bel[y.l])?x.l<y.l:((bel[x.l]&1)?x.r<y.r:x.r>y.r);
    });
    for(int i=1,l=1,r=0;i<=m;i++)
    {
        int L=q[i].l,R=q[i].r,id=q[i].id;
        while(r<R)addt(++r);
        while(r>R)delt(r--);
        while(l<L)delh(l++);
        while(l>L)addh(--l);
        outp[id]=ans;
    }
    for(int i=1;i<=m;i++)printf("%lld\n",outp[i]);
    return 0;
}
```

---

## 作者：Kingna (赞：5)

考虑莫队如何更新左右端点移动后的答案。

用 $cnt1_{x}$ 存储当前 $[L,R]$ 的 $(2x,3x)$ 数对的数量，用 $cnt2_{x}$ 存储当前 $[L,R]$ 的 $(4x,2x)$ 数对的数量。

当左端点往左移时，如果左端点是 $4x$，那我们只需要看右边有多少形如 $(2x,3x)$ 的数对，那么答案只需要加上 $cnt1_{x}$ 即可。移动左端点时，还需要更新 $(2x,3x)$ 数对数量和 $(4x,2x)$ 数对数量。

当右端点往右移时，如果右端点是 $3x$，那我们只需要看左边有多少形如 $(4x,2x)$ 的数对，那么答案只需要加上 $cnt2_{x}$ 即可。移动右端点时，还需要更新 $(2x,3x)$ 数对数量和 $(4x,2x)$ 数对数量。

其余两种移动同理。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define PII pair<int, int>
#define _for(i, a, b) for (int i = (a); i <= (b); i++)
#define _pfor(i, a, b) for (int i = (a); i >= (b); i--)
#define int long long

const int N = 8e5 + 5, mod = 998244353;

int n, m, a[N], res[N], cnt23[N], cnt42[N], cnt[N];

struct edge {
	int l, r, id;
}ed[N];

bool cmp(edge x, edge y) {
	if (x.l / 500 != y.l / 500) return x.l / 500 < y.l / 500;
	return x.r < y.r;
}


signed main() {
	cin >> n >> m;
	_for(i, 1, n) scanf("%lld", &a[i]);
	_for(i, 1, m) scanf("%lld%lld", &ed[i].l, &ed[i].r), ed[i].id = i;
	sort(ed + 1, ed + m + 1, cmp);
	int L = 1, R = 0;
	_for(i, 1, m) {
		res[ed[i].id] = res[ed[i - 1].id];
		while (L > ed[i].l) {
			L--;
			if (a[L] % 4 == 0) res[ed[i].id] += cnt23[a[L] / 4]; // 统计右边(2x,3x) 
			if (a[L] % 4 == 0) cnt42[a[L] / 4] += cnt[a[L] / 2];     // 更新数对数量 
			if (a[L] % 2 == 0) cnt23[a[L] / 2] += cnt[a[L] / 2 * 3]; // 更新数对数量 
			cnt[a[L]]++;
		}
		while (R < ed[i].r) {
			R++;
			if (a[R] % 3 == 0) res[ed[i].id] += cnt42[a[R] / 3];
			if (a[R] % 2 == 0) cnt42[a[R] / 2] += cnt[a[R] * 2];
			if (a[R] % 3 == 0) cnt23[a[R] / 3] += cnt[a[R] / 3 * 2];
			cnt[a[R]]++;
		}
		while (L < ed[i].l) {
			cnt[a[L]]--;
			if (a[L] % 2 == 0) cnt23[a[L] / 2] -= cnt[a[L] / 2 * 3];
			if (a[L] % 4 == 0) cnt42[a[L] / 4] -= cnt[a[L] / 2];
			if (a[L] % 4 == 0) res[ed[i].id] -= cnt23[a[L] / 4];
			L++;
		}
		while (R > ed[i].r) {
			cnt[a[R]]--;
			if (a[R] % 3 == 0) cnt23[a[R] / 3] -= cnt[a[R] / 3 * 2];
			if (a[R] % 2 == 0) cnt42[a[R] / 2] -= cnt[a[R] * 2]; 
			if (a[R] % 3 == 0) res[ed[i].id] -= cnt42[a[R] / 3];
			R--;
		}
	} 
	_for(i, 1, m) cout << res[i] << '\n';
}
```

---

## 作者：_Yonder_ (赞：3)

考虑回滚莫队。

对于子任务 $1$ 应该有提醒这题的全局的 dp 做法，这个 dp 其实就是维护了一个桶。

我们假设 $x:y:z=4:2:3$。

对于右指针移动，这其实就是正向跑 dp。

对于左指针移动，我们需要求出右边的 $(y,z),(z)$ 这两种贡献，这里我们需要在右指针移动时储存，左指针移动时做处理，同时左指针移动也会产生和右指针移动一样的贡献，这个也要储存。

---

## 作者：yuruilin2026 (赞：3)

## 一些闲话：
一道有点难的思维水题，但还是两分钟切了。\
同机房的大佬 [Hootime](https://www.luogu.com.cn/user/1275540) 如此说道。\
前置知识：莫队。\
参考：[_zuoqingyuan](https://www.luogu.com.cn/user/731650) 大佬的[题解](https://www.luogu.com.cn/article/k9iq87yx)。\
侵删。
## 解题思路：
设 $cnt_p$ 表示 $p$ 在本次询问区间的出现次数。\
$cnt1_p$ 表示本次询问区间中，满足 $i < j$ 且 $a_i:a_j=4:2$ 且 $a_j=p$ 的数对个数。\
$cnt2_i$ 表示本次询问区间中，满足 $i < j$ 且 $a_i:a_j=2:3$ 且 $a_i=p$ 的数对个数。
### 考虑在左边增加数 $x$ 对 $answer$ 的贡献：
$cnt_x = cnt_x + 1$。\
应该不用解释吧。

若 $x \bmod 4 = 0$，则 $x$ 可以作为 $4:2$ 数对的开头。注意，在这里 $x=a_i$。\
又因为 $a_j = a_i \div 2$，所以 $a_j=\frac{x}{2}$。\
然后就能得出：$cnt1_\frac{x}{2} = cnt1_\frac{x}{2} + cnt_\frac{x}{2}$。\
至于为什么是 $cnt_\frac{x}{2}$，因为加入了一个 $x$ 后每一个 $\frac{x}{2}$ 都能增加一个匹配，一共  $cnt_\frac{x}{2}$ 个。

若 $x \bmod 2 = 0$，则 $x$ 可以作为 $2:3$ 数对的开头。注意，在这里 $x=a_i$。\
又因为 $a_j = a_i \times 3 \div 2$，所以 $a_j=\frac{3x}{2}$。\
然后就能得出：$cnt2_x = cnt2_x + cnt_\frac{3x}{2}$。\
这个式子基本上同理。

若 $x \bmod 4 = 0$，则 $x$ 可以作为 $4:2:3$ 数对的开头。\
$answer = answer+cnt2_\frac{x}{2}$。

### 考虑在右边增加数 $x$ 对 $answer$ 的贡献：
$cnt_x = cnt_x + 1$。

若 $x \bmod 2 = 0$，则 $x$ 可以作为 $4:2$ 数对的结尾。注意，在这里 $x=a_j$。\
又因为 $a_i = a_j \times 2$，然后就能得出：\
$cnt1_x = cnt_{2x} + cnt1_x$。

若 $x \bmod 3 = 0$，则 $x$ 可以作为 $2:3$ 数对的结尾。注意，在这里 $x=a_j$。\
又因为 $a_i = a_j \times 2 \div 3$，所以 $a_j=\frac{2x}{3}$。\
然后就能得出：$cnt2_\frac{2x}{3} = cnt2_\frac{2x}{3} + cnt_\frac{2x}{3}$。\
这个式子基本上同理。

若 $x \bmod 4 = 0$，则 $answer = answer+cnt1_\frac{2x}{3}$。

减去数同理，见代码：

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[514514],m,qfr,L = 1,R = 0,cnt[514514],answer,ans[514514],cnt1[514514],cnt2[514514],maxx;
struct ppp{
	long long l;
	long long r;
	long long t;
}q[514514];
inline bool cmp(ppp xx,ppp yy){
	if(xx.l / qfr == yy.l / qfr){
		if(xx.l / qfr & 1) return xx.r < yy.r;
		return xx.r > yy.r;
	}
	return xx.l < yy.l;
}
void left_add(long long x){
	++cnt[a[x]];
	if(a[x] % 4 == 0) cnt1[a[x]/2] += cnt[a[x]/2];
	if(a[x] % 2 == 0) cnt2[a[x]] += cnt[a[x]/2*3];
	if(a[x] % 4 == 0) answer += cnt2[a[x]/2];
}
void left_del(long long x){
	--cnt[a[x]];
	if(a[x] % 4 == 0) cnt1[a[x]/2] -= cnt[a[x]/2];
	if(a[x] % 2 == 0) cnt2[a[x]] -= cnt[a[x]/2*3];
	if(a[x] % 4 == 0) answer -= cnt2[a[x]/2];
}
void right_add(long long x){
	++cnt[a[x]];
	if(a[x] % 2 == 0) cnt1[a[x]] += cnt[a[x]*2];
	if(a[x] % 3 == 0) cnt2[a[x]/3*2] += cnt[a[x]/3*2];
	if(a[x] % 3 == 0) answer += cnt1[a[x]/3*2];
}
void right_del(long long x){
	--cnt[a[x]];
	if(a[x] % 2 == 0) cnt1[a[x]] -= cnt[a[x]*2];
	if(a[x] % 3 == 0) cnt2[a[x]/3*2] -= cnt[a[x]/3*2];
	if(a[x] % 3 == 0) answer -= cnt1[a[x]/3*2];
}
int main(){
    cin.tie(0),cout.tie(0);
	cin >> n >> m;
	qfr = sqrt(n);
	for(long long i = 1;i <= n;++i) cin >> a[i];
	for(long long i = 1;i <= m;++i) cin >> q[i].l >> q[i].r;
	for(long long i = 1;i <= m;++i) q[i].t = i;
	sort(q+1,q+m+1,cmp);
	for(long long i = 1;i <= m;++i){
		while(L < q[i].l) left_del(L++);
		while(R < q[i].r) right_add(++R);
		while(R > q[i].r) right_del(R--);
		while(L > q[i].l) left_add(--L);
		ans[q[i].t] = answer;
	}
	for(long long i = 1;i <= m;++i) cout << ans[i] << "\n";
    return 0;
}
```

---

## 作者：_zuoqingyuan (赞：3)

严格简单于 T2。

前置知识：普通莫队。

# 思路分析

$n\le 2\times 10^5$，可以离线，显然使用莫队。

容易发现莫队左右指针左右移动产生的贡献各不相同，为了方便，我们写四个函数。

假设 $cnt_x$ 表示当前区间内 $x$ 的出现次数。

假设 $cnt1_x$ 表示当前区间内满足 $i<j,a_i:a_j=4:2,a_j=x$ 的数对 $(x,y)$ 个数。这类数对称为一类数对。

假设 $cnt2_x$ 表示当前区间内满足 $i<j,a_i:a_j=2:3,a_i=x$ 的数对 $(x,y)$ 个数。这类数对称为二类数对。

假设 $ans$ 为当前区间 $[l,r]$ 内符合题意的三元组个数。

- 从左边界 $l$ 加入一个 $x$。

考虑对 $cnt,cnt1,cnt2,ans$ 的贡献。

1. $cnt_x\gets cnt_x+1$

2. 若 $x$ 可以被 $4$ 整除，则 $x$ 可以作为一个一类数对的开头，则这些一类数对的结尾为 $\frac{x}{2}$，即 $cnt1_{\frac{x}{2}}\gets cnt1_{\frac{x}{2}}+cnt_{\frac{x}{2}}$

3. 若 $x$ 可以被 $2$ 整除，则 $x$ 可以作为一个二类数对的开头，则这些一类数对的结尾为 $\frac{3x}{2}$，即 $cnt2_x\gets cnt2_x+cnt_{\frac{3x}{2}}$

4. 若 $x$ 可以被 $4$ 整除，则 $x$ 作为一个题目中合法数对的开头，则它的下一个元素即为 $\frac{x}{2}$，令 $ans\gets ans+cnt2_{\frac{x}{2}}$

剩下三种情况分别是左边界删掉一个数，右边界加入一个数，右边界删去一个数，对着这个东西分类讨论即可，注意特判越界。


```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;
const int N=2e5+10;
typedef long long ll;
ll n,m,a[N],t,l=1,r=0,ql,qr,cnt1[N],cnt2[N],cnt[N],ans,res[N];
struct node{
	ll l,r;
	int idx;
}b[N];
inline void read(ll &a){
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	a=f*x;return;
}
bool cmp(node a,node b){
	return (a.l/t)^(b.l/t)?a.l<b.l:((a.l/t)&1?(a.r<b.r):(a.r>b.r));
}
inline void addl(ll x){
    cnt[a[x]]++;
    if(a[x]%4==0)cnt1[a[x]/2]+=cnt[a[x]/2];
    if(a[x]%2==0&&a[x]/2*3<N)cnt2[a[x]]+=cnt[a[x]/2*3];
    if(a[x]%4==0)ans+=cnt2[a[x]/2];
}
inline void delr(ll x){
    cnt[a[x]]--;
    if(a[x]%2==0&&a[x]*2<N)cnt1[a[x]]-=cnt[a[x]*2];
    if(a[x]%3==0)cnt2[a[x]/3*2]-=cnt[a[x]/3*2];
    if(a[x]%3==0)ans-=cnt1[a[x]/3*2];
}
inline void dell(ll x){
    cnt[a[x]]--;
    if(a[x]%4==0)cnt1[a[x]/2]-=cnt[a[x]/2];
    if(a[x]%2==0&&a[x]/2*3<N)cnt2[a[x]]-=cnt[a[x]/2*3];
    if(a[x]%4==0)ans-=cnt2[a[x]/2];
}
inline void addr(ll x){
    cnt[a[x]]++;
    if(a[x]%2==0&&a[x]*2<N)cnt1[a[x]]+=cnt[a[x]*2];
    if(a[x]%3==0)cnt2[a[x]/3*2]+=cnt[a[x]/3*2];
    if(a[x]%3==0)ans+=cnt1[a[x]/3*2];
}
int main(){
	read(n),read(m);t=sqrt(n);
	for(int i=1;i<=n;i++)read(a[i]);
	for(int i=1;i<=m;i++)read(b[i].l),read(b[i].r),b[i].idx=i;
	sort(b+1,b+1+m,cmp);
	for(int i=1;i<=m;i++){
		ql=b[i].l,qr=b[i].r;
		while(l<ql)dell(l++);
		while(l>ql)addl(--l);
		while(r>qr)delr(r--);
		while(r<qr)addr(++r);
        res[b[i].idx]=ans;
	}
	for(int i=1;i<=m;i++){
		printf("%lld\n",res[i]);
	}
	return 0;
} 
```

时间复杂度 $O(n\sqrt n)$。

如有错误，请指出。

---

## 作者：__cstdio__cpp (赞：2)

考虑每一个 $a_y$ 位置对答案的贡献：

令 $cnt_{x,i}$ 表示前 $i$ 个数中 $x$ 出现的次数，$p1_{x,i}$ 为下标小于 $i$ 的第一个 $x$ 的下标。

假设询问区间为 $[L,R]$，令 $y=i$, $a_i=2p$ ，则 $a_i$ 对答案的贡献为 $( cnt_{4p,p1_{4p,i}} -cnt_{4p,p1_{4p,L}})(cnt_{3p,p1_{3p,R}}-cnt_{3p,p1_{3p,i}})$ ,
展开可得:
$cnt_{4p,p1_{4p,i}}cnt_{3p,p1_{3p,R}}-cnt_{3p,p1_{3p,i}}cnt_{4p,p1_{4p,i}}-cnt_{4p,p1_{4p,L}}cnt_{3p,p1_{3p,R}}+cnt_{4p,p1_{4p,L}}cnt_{3p,p1_{3p,i}}$ 。

对于区间范围内左侧没有 $a_x$ ,或右侧没有 $a_z$ 的 $a_i$，它们对答案没有贡献，直接去掉即可。假设去掉部分 $a_i$ 后剩下了 $num$ 个。

于是询问的答案 $Ans= cnt_{3p,p1_{3p,R}}\sum _ {i=L}^R cnt_{4p,p1_{4p,i}}-\sum _ {i=L}^R cnt_{3p,p1_{3p,i}}cnt_{4p,p1_{4p,i}}-num*cnt_{4p,p1_{4p,L}}cnt_{3p,p1_{3p,R}}+cnt_{4p,p1_{4p,L}} \sum _ {i=L}^R cnt_{3p,p1_{3p,i}}$ 。

其中 $cnt_{x,i}$ ， $\sum _ {i=L}^R cnt_{4p,p1_{4p,i}}$ ， $\sum _ {i=L}^R cnt_{3p,p1_{3p,i}}cnt_{4p,p1_{4p,i}}$ ， $\sum _ {i=L}^R cnt_{3p,p1_{3p,i}}$ 均可以使用前缀和维护, $num$ 可以在每次询问时二分求出。本题值域在 $2 \times 10^5$ 范围内，可以开 vector 数组直接存而无需离散化。

均摊下来，时间复杂度 $O(n+m logn)$ ，空间复杂度 $O(n)$。

这样就做完了，并不需要莫队之类的数据结构。

---

## 作者：Walrus (赞：2)

观察到值域 $1\leq a_i \leq 2\times 10^5$ 并且 $n,q$ 与值域同阶，考虑将问题离线下来莫队，但是发现一个问题，当我们移动一个区间时，会产生两种情况。

莫队的四种移动方式两两分为一组，有：

- $[l,r]\to [l+1,r]$ 和 $[l,r]\to[l-1,r]$
- $[l,r]\to [l,r+1]$ 和 $[l,r]\to[l,r-1]$

发现上述两种方式移动区间分别是计算 $(4k,2k,3k)$ 中 $4k$ 的贡献和 $3k$ 的贡献，简单来说，第一种情况，当移动了左端点，则移动的指针可能会作为 $(4k,2k,3k)$ 中 $4k$ 产生贡献，另一种情况同理，那么我们分别写出两种情况的 $add$ 和 $del$，分别维护 $(4k,2k)$ 和 $(2k,3k)$ 出现的次数即可。

```cpp
#include <bits/stdc++.h>
#define FASTIO ios::sync_with_stdio(0), cin.tie(nullptr), cout.tie(nullptr);
#define rep(i, j, k) for(int i = j; i <= k; ++i)
#define pre(i, j, k) for(int i = j; i >= k; --i)
#define pb push_back
#define PII pair<int, int>
#define fi first
#define se second
#define int long long
using namespace std;

const int N = 1e6 + 5;

int n, q, ret, len, cnt, a[N], c[N], ans[N], cntr[N], cntl[N];

struct Query {
	int l, r, id;
	bool operator < (const Query &a) const {
		return l / len == a.l / len ? ((l / len) & 1 ? r < a.r : r > a.r) : l < a.l;
	}
#define l(p) t[p].l
#define r(p) t[p].r
#define id(p) t[p].id
} t[N];

/*
10 5
4 4 2 3 2 3 3 4 2 3
1 5
3 7
1 10
5 10
4 8
*/

void add_l(int x) {
	++c[x];
	if(x % 4 == 0) cnt += cntl[x / 4];
	if (x % 4 == 0) cntr[x / 4] += c[x / 2];
	if (x % 2 == 0) cntl[x / 2] += c[x / 2 * 3];
}

void add_r(int x) {
	++c[x];
	if (x % 3 == 0) cnt += cntr[x / 3];
	if (x % 2 == 0) cntr[x / 2] += c[x * 2];
	if (x % 3 == 0) cntl[x / 3] += c[x / 3 * 2];
}

void del_l(int x) {
	if (x % 2 == 0) cntl[x / 2] -= c[x / 2 * 3];
	if (x % 4 == 0) cntr[x / 4] -= c[x / 2];
	if (x % 4 == 0) cnt -= cntl[x / 4];
	--c[x];
}

void del_r(int x) {
	if (x % 3 == 0) cntl[x / 3] -= c[x / 3 * 2];
	if (x % 2 == 0) cntr[x / 2] -= c[x * 2];
	if (x % 3 == 0) cnt -= cntr[x / 3];
	--c[x];
}

void sol() {
	cin >> n >> q;
	len = pow(n, 0.5);
	rep(i, 1, n) cin >> a[i];
	rep(i, 1, q) cin >> l(i) >> r(i), id(i) = i;
	sort(t + 1, t + 1 + q);
	int l = 1, r = 0;
	rep(i, 1, q) {
		while(l > l(i)) add_l(a[--l]);
		while(r < r(i)) add_r(a[++r]);
		while(l < l(i)) del_l(a[l++]);
		while(r > r(i)) del_r(a[r--]);
		ans[id(i)] = cnt;
	}
	rep(i, 1, q) cout << ans[i] << '\n';
}

signed main() {
	FASTIO

	int _;
	_ = 1;
	while(_--) sol();
	return 0;
}
```

---

## 作者：fzitb7912 (赞：2)

是不是被秒完了啊。

## 分析

考虑暴力。

像这种奶龙很容易就能想到莫队吧。注意到删除有点难搞，那就考虑不删除的情况。对于左指针移动，我们搞一下 $x=l,y=l,z=l$ 时的和。对于右指针移动同理。开几个桶维护就行了，因为这是不删除，所以回滚就做完了。时间复杂度 $O(n\sqrt{n})$。

## 代码

```cpp
const int N=2e5+10;
int n,m,a[N],len;
struct Query{
	int l,r,id;
	il bool operator<(const Query&b)const{
		if(id(l)!=id(b.l)) return l<b.l;
		return r<b.r;
	}
}q[N];
int ans[N],sum;
int cnt1_[N],cnt2_[N];
int cnt3_[N],cnt4_[N];
int cnt1[N],cnt2[N],cnt[N];
int cnt3[N],cnt4[N];

il void solve(){
	n=rd,m=rd,len=sqrt(n);
	for(re int i=1;i<=n;++i) a[i]=rd;
	for(re int i=1;i<=m;++i) q[i]={rd,rd,i};
	int l=1,r=0,B=0;
	sort(q+1,q+m+1);
	for(re int i=1;i<=m;++i){
		if(id(q[i].l)==id(q[i].r)){
			int s=0;
			for(re int j=q[i].l;j<=q[i].r;++j){
				if(a[j]%2==0) cnt2_[a[j]]+=cnt1_[a[j]/2*4];
				if(a[j]%3==0) s+=cnt2_[a[j]/3*2];
				++cnt1_[a[j]];		
			}
			ans[q[i].id]=s;
			for(re int j=q[i].l;j<=q[i].r;++j)
				cnt1_[a[j]]=cnt2_[a[j]]=0;
			continue;		
		}
		if(id(q[i].l)!=B){
			sum=0,B=id(q[i].l);
			l=min(n,B*len)+1,r=l-1;
			for(re int j=0;j<N;++j) cnt[j]=cnt1[j]=cnt2[j]=cnt3[j]=cnt4[j]=0;
		}
		while(r<q[i].r){
			++r;
			if(a[r]%3==0) sum+=cnt2[a[r]/3*2];
			if(a[r]%3==0) cnt4[a[r]/3*2]+=cnt[a[r]/3*2];
			if(a[r]%2==0) cnt2[a[r]]+=cnt1[a[r]/2*4];
			++cnt1[a[r]],++cnt3[a[r]],++cnt[a[r]];
		}
		int l_=l,s=0;
		while(l_>q[i].l){
			--l_;
			if(a[l_]%4==0) s+=(cnt4_[a[l_]/4*2]+cnt4[a[l_]/4*2]);
			if(a[l_]%2==0) cnt4_[a[l_]]+=(cnt3_[a[l_]/2*3]+cnt3[a[l_]/2*3]);
			++cnt3_[a[l_]];
		}
		ans[q[i].id]=sum+s;
		while(l_<l){
			cnt4_[a[l_]]=cnt3_[a[l_]]=0;
			++l_;
		}
	}
	for(re int i=1;i<=m;++i) printf("%lld\n",ans[i]);
    return ;
}
```

---

## 作者：JoyLosingK (赞：1)

首先这题允许离线，那么我们考虑莫队算法。

看到值域只有 $2 \times 10^5$，果断维护一个桶 $t$，其中 $t_i$ 表示数 $i$ 在当前区间中的出现次数。

但是有一个问题，题目中要求的三元组必须满足 $x<y<z$，而我们的桶是不讲顺序的，这样写只能拿到 $5pts$，该怎么办呢？

既然一个桶不行，那我们就开更多的桶不就行了吗？

设 $s23_i$ 表示当前区间中 $x<y$ 且 $a_x=2i,a_y=3i$ 的二元组 $(x,y)$ 的个数。

设 $s42_i$ 表示当前区间中 $x<y$ 且 $a_x=4i,a_y=2i$ 的二元组 $(x,y)$ 的个数。

于是就可以很容易的统计答案了，具体过程如下：

-  当区间向左扩张时：

若 $a_l$ 是 $4$ 的倍数，记 $m=a_l\div4$，那么 $a_l$ 显然与 $s23_m$ 中的二元组构成了题目中要求的三元组，于是将当前答案加上 $s23_m$。同时这个 $a_l$ 可以与当前区间中的 $2m$ 构成 $s42_m$ 要求的二元组，于是给 $s42_m$ 加上当前区间中 $2m$ 的个数，也就是 $t_{2m}$。

若 $a_l$ 是 $2$ 的倍数，记 $m=a_l\div2$，这个 $a_l$ 可以与当前区间中的 $3m$ 构成 $s23_m$ 要求的二元组，于是给 $s23_m$ 加上当前区间中 $3m$ 的个数，也就是 $t_{3m}$。

-  当区间向左收缩时：

若 $a_l$ 是 $4$ 的倍数，记 $m=a_l\div4$，那么 $a_l$ 显然与 $s23_m$ 中的二元组构成了题目中要求的三元组，于是将当前答案减去 $s23_m$。同时这个 $a_l$ 可以与当前区间中的 $2m$ 构成 $s42_m$ 要求的二元组，于是给 $s42_m$ 减去当前区间中 $2m$ 的个数，也就是 $t_{2m}$。

若 $a_l$ 是 $2$ 的倍数，记 $m=a_l\div2$，这个 $a_l$ 可以与当前区间中的 $3m$ 构成 $s23_m$ 要求的二元组，于是给 $s23_m$ 减去当前区间中 $3m$ 的个数，也就是 $t_{3m}$。

-  当区间向右扩张时：

若 $a_l$ 是 $3$ 的倍数，记 $m=a_l\div3$，那么 $a_l$ 显然与 $s42_m$ 中的二元组构成了题目中要求的三元组，于是将当前答案加上 $s42_m$。同时这个 $a_l$ 可以与当前区间中的 $2m$ 构成 $s23_m$ 要求的二元组，于是给 $s23_m$ 加上当前区间中 $2m$ 的个数，也就是 $t_{2m}$。

若 $a_l$ 是 $2$ 的倍数，记 $m=a_l\div2$，这个 $a_l$ 可以与当前区间中的 $4m$ 构成 $s42_m$ 要求的二元组，于是给 $s42_m$ 加上当前区间中 $4m$ 的个数，也就是 $t_{4m}$。

-  当区间向右收缩时：

若 $a_l$ 是 $3$ 的倍数，记 $m=a_l\div3$，那么 $a_l$ 显然与 $s42_m$ 中的二元组构成了题目中要求的三元组，于是将当前答案减去 $s42_m$。同时这个 $a_l$ 可以与当前区间中的 $2m$ 构成 $s23_m$ 要求的二元组，于是给 $s23_m$ 减去当前区间中 $2m$ 的个数，也就是 $t_{2m}$。

若 $a_l$ 是 $2$ 的倍数，记 $m=a_l\div2$，这个 $a_l$ 可以与当前区间中的 $4m$ 构成 $s42_m$ 要求的二元组，于是给 $s42_m$ 减去当前区间中 $4m$ 的个数，也就是 $t_{4m}$。

于是就做完了，每次扩张或收缩都可以 $O(1)$ 完成，总时间复杂度为 $O(m\sqrt n)$。

代码常数巨大，仅供参考：


```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define endl '\n'
const int N = 2e5 + 5;
int n, m, a[N], key, sl(1), sr, ql, qr, s23[N], s42[N], t[N], pos[N];
ll ans[N], res; //要开 long long,不然只有 80 pts.
struct note {
	int l, r, id;
} q[N];
inline bool cmp(note a, note b) { //奇偶排序
	if (pos[a.l] != pos[b.l]) return pos[a.l] < pos[b.l];
	if (pos[a.l] & 1) return a.r < b.r;
	return a.r > b.r;
}
inline int read() {
	int x = 0, f = 1;
	char ch = getchar();
	for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1;
	for (; isdigit(ch); ch = getchar()) x = (x << 3) + (x << 1) + ch - '0';
	return x * f;
}
int main() {
	ios::sync_with_stdio(0);
	cout.tie(0);
	cin.tie(0);
	n = read(), m = read();
	key = n / sqrt(m * 2 / 3);
	for (int i = 1; i <= n; i++) a[i] = read(), pos[i] = (i - 1) / key + 1;
	for (int i = 1; i <= m; i++)
		q[i].l = read(), q[i].r = read(), q[i].id = i;
	sort(q + 1, q + m + 1, cmp); //将询问排序
	for (int i = 1; i <= m; i++) {
		ql = q[i].l, qr = q[i].r;
		while (sl > ql) { //向左扩张
			sl--, t[a[sl]]++;
			if (a[sl] % 4 == 0) res += s23[a[sl] / 4], s42[a[sl] / 4] += t[a[sl] / 2];
			if (a[sl] % 2 == 0) s23[a[sl] / 2] += t[a[sl] / 2 * 3];
		}
		while (sl < ql) { //向左收缩
			t[a[sl]]--;
			if (a[sl] % 4 == 0) res -= s23[a[sl] / 4], s42[a[sl] / 4] -= t[a[sl] / 2];
			if (a[sl] % 2 == 0) s23[a[sl] / 2] -= t[a[sl] / 2 * 3];
			sl++;
		}
		while (sr < qr) { //向右扩张
			sr++, t[a[sr]]++;
			if (a[sr] % 3 == 0) res += s42[a[sr] / 3], s23[a[sr] / 3] += t[a[sr] / 3 * 2];
			if (a[sr] % 2 == 0) s42[a[sr] / 2] += t[a[sr] * 2];
		}
		while (sr > qr) { //向右收缩
			t[a[sr]]--;
			if (a[sr] % 3 == 0) res -= s42[a[sr] / 3], s23[a[sr] / 3] -= t[a[sr] / 3 * 2];
			if (a[sr] % 2 == 0) s42[a[sr] / 2] -= t[a[sr] * 2];
			sr--;
		}
		ans[q[i].id] = res; //记录答案
	}
	for (int i = 1; i <= m; i++) cout << ans[i] << endl;
	return 0;
}
```

---

## 作者：diqiuyi (赞：1)

口胡一个不用莫队的做法，不保证能通过，有错误欢迎指出。

下文默认 $a_i,n,q$ 同阶。

考虑根号分治。

根据基本不等式有 $\dfrac{ab}{a+b}\le\dfrac{\sqrt{ab}}{2}$，对于每一个数，我们考虑把它按照 $cnt_{4x}\times cnt_{3x}$ 与 $n$ 的大小关系分成两类。

若 $cnt_{4x}\times cnt_{3x}\le n$，考虑枚举左端点和右端点，就可以得到 $cnt_{4x}\times cnt_{3x}$ 个点对。易证这样的点对的数量是 $O(n\sqrt{n})$ 的。把询问离线下来后用分块维护二维数点即可 $O(n\sqrt{n})$ 统计这部分的答案。

若 $cnt_{4x}\times cnt_{3x}>n$，那么这样的 $x$ 只有 $O(\sqrt{n})$ 种。对每个这样的 $x$，在 $2x,3x,4x$ 出现的每个位置维护前缀 ```4 42 3 23 423``` 的个数。容易用这几个信息算出对答案的贡献。但是我们需要知道每个数 $\le l-1,r$ 的第一次出现的位置。显然可以轻易求出这个东西。这部分时间复杂度为 $O(n\sqrt{n})$，空间复杂度也为 $O(n\sqrt{n})$，需要卡空间（所以没有在每个位置都做前缀和而是只维护位置）。

总的时间复杂度为 $O(n\sqrt{n})$，空间复杂度为 $O(n\sqrt{n})$，需要离线，但是如果在线做二维数点可以有 $O(n\sqrt{n}\log n)$ 的在线做法。

---

## 作者：tuget (赞：1)

~~感觉没有紫。~~

观察一下比例式，发现还需要按照一定位置顺序，容易想到莫队。

先考虑加点，其实只需要想到一个合法三元组满足 $\frac{a_i}{4}=\frac{a_j}{2}=\frac{a_k}{3}=w$。在莫队过程中在位置 $w$ 上存下一个数分别作为 $i,j,k$ 时的方案数。考虑向右扩展时的情况，定义 $num4$ 为可以作为 $i$ 的方案数，$nump2$ 表示向右扩展时当前位置作为 $j$ 构成合法二元组 $(i,j)$ 的数量，当遇到一个合法的 $a_k$ 时，更新答案 $ans=ans+nump2_{\frac{a_k}{3}}$。定义 $numl2$ 表示向左扩展时当前位置作为 $j$ 构成合法二元组 $(j,k)$ 的数量，而在向右扩展时，同时会更新到 $numl2$，所以还要维护一个，$num$ 用来存目前为止，可以作为 $j$ 的位置的数量，这样在每次更新 $ans$ 时，同时令 $numl2_{\frac{a_k}{3}}=numl2_{\frac{a_k}{3}}+num_{\frac{a_k}{3}}$，向左扩展同理。删点只需要把所有加的操作改为减的操作即可。

代码不建议像我这么写，只是这样思路更加清晰。

~~~
int n,m,len,a[maxn],num1[maxn],num3[maxn],num4[maxn],num[maxn];
ll ans[maxn],sum,nump2[maxn],numl2[maxn];
struct ques
{
	int l,r,id;
	bool operator<(const ques &b)const{
		if(l/len!=b.l/len)return l<b.l;
		return (l/len&1)?r>b.r:r<b.r;
	}
}q[maxn];
void addr(int x,int w)
{
	x=a[x];
	if(x%3==0)sum+=nump2[x/3]*w,num3[x/3]+=w,numl2[x/3]+=w*num[x/3];
	if(x%2==0)nump2[x/2]+=num4[x/2]*w,num[x/2]+=w;
	if(x%4==0)num4[x/4]+=w;
}
void addl(int x,int w)
{
	x=a[x];
	if(x%4==0)sum+=numl2[x/4]*w,num4[x/4]+=w,nump2[x/4]+=w*num[x/4];
	if(x%2==0)numl2[x/2]+=num3[x/2]*w,num[x/2]+=w;
	if(x%3==0)num3[x/3]+=w;
}
int main()
{
	int i,l,r;
	n=read(),m=read(),len=n/sqrt(m);
	for(i=1;i<=n;++i)a[i]=read();
	for(i=1;i<=m;++i)q[i]={read(),read(),i};
	sort(q+1,q+m+1);
	for(i=l=1,r=0;i<=m;++i)
	{
		while(l>q[i].l)addl(--l,1);
		while(r<q[i].r)addr(++r,1);
		while(l<q[i].l)addl(l++,-1);
		while(r>q[i].r)addr(r--,-1);
		ans[q[i].id]=sum;
	}
	for(i=1;i<=m;++i)printf("%lld\n",ans[i]);
	return 0;
}
~~~

---

## 作者：冷却心 (赞：1)

题面极其简洁，在此不重复题意。

莫队板子。

考虑对区间维护几个桶：

- 为 $4$ 的倍数的桶，下标对应原数除以 $4$。
- 为 $2$ 的倍数的桶，下标对应原数除以 $2$。
- 为 $3$ 的倍数的桶，下标对应原数除以 $3$。
- 已经确定三元组前两个数的桶（即 $4$ 的倍数和 $2$ 的倍数），下标对应第一个数除以 $4$ 或者第二个数除以 $2$。
- 已经确定三元组后两个数的桶（即 $2$ 的倍数和 $3$ 的倍数），下标对应第二个数除以 $2$ 或者第三个数除以 $3$。

以及记录答案 $S$。

考虑移动左端点的时候会怎么变化，记当前加入区间的数为 $x$（如果是弹出区间则加变为减即可），那么：

- 如果 $x$ 是 $4$ 或 $2$ 或 $3$ 的倍数，对应的桶计数加一。
- 如果 $x$ 是 $4$ 的倍数，那么可以与区间内 $2$ 的倍数组成 $4:2$，对应的桶计数，并且可以与区间内组成 $2:3$ 的数对合成三元组统计入答案。
- 如果 $x$ 是 $2$ 的倍数，那么可以与区间内 $3$ 的倍数组成 $2:3$，对应的桶计数。

移动右端点同理，但是不平凡的计数是针对 $4:2$ 的 $2$ 以及 $2:3$ 的 $3$ 统计。详见代码。


```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 2e5 + 10;
int n, Q, A[N], T;
struct Qry { int x, y, id; } qry[N];
bool cmp(Qry a, Qry b) {
	return (a.x / T != b.x / T ? a.x / T < b.x / T : ((a.x / T) & 1 ? a.y < b.y : a.y > b.y));
}
LL Ans[N], cur, cnt4[N], cnt2[N], cnt3[N], cnt42[N], cnt23[N];
void Addl(LL x) {
	if (x % 4 == 0) cnt4[x / 4] ++, cnt42[x / 4] += cnt2[x / 4], cur += cnt23[x / 4];
	if (x % 2 == 0) cnt2[x / 2] ++, cnt23[x / 2] += cnt3[x / 2];
	if (x % 3 == 0) cnt3[x / 3] ++;
}
void Dell(LL x) {
	if (x % 4 == 0) cnt4[x / 4] --, cnt42[x / 4] -= cnt2[x / 4], cur -= cnt23[x / 4];
	if (x % 2 == 0) cnt2[x / 2] --, cnt23[x / 2] -= cnt3[x / 2];
	if (x % 3 == 0) cnt3[x / 3] --;
}
void Addr(LL x) {
	if (x % 4 == 0) cnt4[x / 4] ++;
	if (x % 2 == 0) cnt2[x / 2] ++, cnt42[x / 2] += cnt4[x / 2];
	if (x % 3 == 0) cnt3[x / 3] ++, cnt23[x / 3] += cnt2[x / 3], cur += cnt42[x / 3];
}
void Delr(LL x) {
	if (x % 4 == 0) cnt4[x / 4] --;
	if (x % 2 == 0) cnt2[x / 2] --, cnt42[x / 2] -= cnt4[x / 2];
	if (x % 3 == 0) cnt3[x / 3] --, cnt23[x / 3] -= cnt2[x / 3], cur -= cnt42[x / 3];
}
int main() {
	freopen(".in", "r", stdin); freopen(".out", "w", stdout);
	ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin >> n >> Q; T = sqrt(n); for (int i = 1; i <= n; i ++) cin >> A[i];
	for (int i = 1; i <= Q; qry[i].id = i, i ++) cin >> qry[i].x >> qry[i].y;
	sort(qry + 1, qry + 1 + Q, cmp);
	for (int i = 1, l = 1, r = 0; i <= Q; i ++) {
		while (l > qry[i].x) Addl(A[-- l]);
		while (r < qry[i].y) Addr(A[++ r]);
		while (l < qry[i].x) Dell(A[l ++]);
		while (r > qry[i].y) Delr(A[r --]);
		Ans[qry[i].id] = cur;
	} for (int i = 1; i <= Q; i ++) cout << Ans[i] << "\n";
	return 0;
}
```

---

## 作者：Redshift_Shine (赞：1)

应该是极少数的我能够独立做出的紫题之一。

$n,a_i\le 2\times 10^5$，且拓展左右边界时可以立即计算答案变更，故考虑使用莫队。

使用桶数组记录目前各个可被 $2,3,4$ 整除的数的数量，并记录题目要求的 4-2-3 元组中 4-2 部分以及 2-3 部分的出现次数。转移细节见代码。

时间复杂度 $O(n\sqrt n+q\log q)$。

```c++
// #define Redshift_Debug
#ifdef Redshift_Debug
#define debug(...) fprintf(stderr, __VA_ARGS__)
#include <chrono>
#else
#define debug(...)
#endif
#include <algorithm>
#include <cctype>
#include <cmath>
#include <cstdio>
using namespace std;
const int N = 2e5 + 10;
using ll = long long;
int n, m, cl = 1, cr, blks, a[N], buc2[N], buc3[N], buc4[N], prtn[N];
ll res, buc42[N], buc23[N], ret[N];
template <typename _Tp> inline void read(_Tp &x)
{
	static char ch;
	while (ch = getchar(), !isdigit(ch))
		;
	x = (ch ^ 48);
	while (ch = getchar(), isdigit(ch))
		x = (x << 3) + (x << 1) + (ch ^ 48);
}
template <typename _Tp, typename... _Args> inline void read(_Tp &x, _Args &...args)
{
	read(x);
	read(args...);
}
struct st
{
	int l, r, id;
	bool operator<(const st &x) const
	{
		if (prtn[l] != prtn[x.l])
			return prtn[l] < prtn[x.l];
		if (prtn[l] & 1)
			return r > x.r;
		return r < x.r;
	}
} qry[N];
void proc(int l, int r)
{
	static int tmp = 0;
	while (cr < r)
	{
		cr++;
		tmp = a[cr];
		if (!(tmp % 3))
			res += buc42[tmp / 3], buc3[tmp / 3]++, buc23[tmp / 3] += buc2[tmp / 3];
		if (!(tmp & 1))
			buc42[tmp >> 1] += buc4[tmp >> 1], buc2[tmp >> 1]++;
		if (!(tmp & 3))
			buc4[tmp >> 2]++;
	}
	while (cl > l)
	{
		cl--;
		tmp = a[cl];
		if (!(tmp & 3))
			res += buc23[tmp >> 2], buc4[tmp >> 2]++, buc42[tmp >> 2] += buc2[tmp >> 2];
		if (!(tmp & 1))
			buc23[tmp >> 1] += buc3[tmp >> 1], buc2[tmp >> 1]++;
		if (!(tmp % 3))
			buc3[tmp / 3]++;
	}
	while (cr > r)
	{
		tmp = a[cr];
		if (!(tmp & 3))
			buc4[tmp >> 2]--;
		if (!(tmp & 1))
			buc42[tmp >> 1] -= buc4[tmp >> 1], buc2[tmp >> 1]--;
		if (!(tmp % 3))
			res -= buc42[tmp / 3], buc3[tmp / 3]--, buc23[tmp / 3] -= buc2[tmp / 3];
		cr--;
	}
	while (cl < l)
	{
		tmp = a[cl];
		if (!(tmp % 3))
			buc3[tmp / 3]--;
		if (!(tmp & 1))
			buc23[tmp >> 1] -= buc3[tmp >> 1], buc2[tmp >> 1]--;
		if (!(tmp & 3))
			res -= buc23[tmp >> 2], buc4[tmp >> 2]--, buc42[tmp >> 2] -= buc2[tmp >> 2];
		cl++;
	}
}
void run()
{
	read(n, m);
	blks = sqrt(n);
	for (int i = 1; i <= n; i++)
		scanf("%d", a + i);
	for (int i = 1, j = 1; i <= n; i++, j = (j == blks ? 1 : j + 1))
	{
		prtn[i] = prtn[i - 1] + (j == blks);
	}
	for (int i = 1; i <= m; i++)
	{
		read(qry[i].l, qry[i].r);
		qry[i].id = i;
	}
	sort(qry + 1, qry + m + 1);
	for (int i = 1; i <= m; i++)
	{
		// printf("%d\n", qry[i].id);
		proc(qry[i].l, qry[i].r);
		ret[qry[i].id] = res;
	}
	for (int i = 1; i <= m; i++)
		printf("%lld\n", ret[i]);
}
int main()
{
#ifdef Redshift_Debug
	auto st = chrono::high_resolution_clock::now();
#endif
	run();
#ifdef Redshift_Debug
	auto ed = chrono::high_resolution_clock::now();
	fprintf(stderr, "%.9lf\n", (ed - st).count() / 1e9);
#endif
}
```

---

## 作者：无名之雾 (赞：0)

不理解为什么回滚莫队。感觉就是莫队板子。

## solution

求一段区间内比值为 $4:2:3$ 的三元组数量。感觉不太能 $\mathrm{polylog}$。而且可以离线，果断考虑莫队。

套路化的我们令 $a_x=4k,a_y=2k,a_z=3k$。

同时我们还发现 $x<y<z$ 所以我们不妨考虑开两个数组 $cnt43,cnt23$ 分别去统计。

具体的，我们去维护每一种 $k$ 的权值出现次数与形如 $(4k,3k),(2k,3k)$ 的个数。

考虑指针如何移动。

1. 右端点扩长时：

- 如果 $a_l$ 是 $2$ 的倍数则令 $cnt42_{\frac{2}{3}a_l}$ 加上 $cnt_{2a_l}$。
  
- 如果 $a_l$ 是 $3$ 的倍数则令 $cnt23_{\frac{4}{3}a_l}$ 加上 $cnt_{\frac{2}{3}a_l}$。 

收缩同理。

1. 左端点收缩时：

- 如果 $a_r$ 是 $4$ 的倍数则令 $cnt42_{\frac{3}{4}a_r}$ 加上 $cnt_{\frac{1}{2}a_r}$。

- 如果 $a_r$ 是 $2$ 的倍数则令 $cnt23_{2a_r}$ 加上 $cnt_{\frac{3}{2}a_r}$。

扩张同理。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read(){
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
inline void write(int x){
    if(x==0){putchar('0');return;}
    int len=0,k1=x,c[10005];
    if(k1<0)k1=-k1,putchar('-');
    while(k1)c[len++]=k1%10+'0',k1/=10;
    while(len--)putchar(c[len]);
}
const int N=1e6+5;
int a[N],cnt[N],pos[N],cnt23[N],cnt42[N],ans[N];
struct ask{
    int l,r,id;
    bool operator <(const ask &x)const{
        if(pos[l]!=pos[x.l])return pos[l]<pos[x.l];
        if(pos[l]&1)return r<x.r;return r>x.r;
    }
}q[N];
struct sqrt{
    int ans=0;
    void l_del(int x){
        cnt[a[x]]--;ans-=cnt23[a[x]];
        if(a[x]%4==0)cnt42[a[x]/4*3]-=cnt[a[x]/2];
        if(a[x]%2==0)cnt23[a[x]*2]-=cnt[a[x]/2*3];
    }
    void l_add(int x){
        cnt[a[x]]++;ans+=cnt23[a[x]];
        if(a[x]%4==0)cnt42[a[x]/4*3]+=cnt[a[x]/2];
        if(a[x]%2==0)cnt23[a[x]*2]+=cnt[a[x]/2*3];
    }
    void r_del(int x){
        cnt[a[x]]--;ans-=cnt42[a[x]];
        if(a[x]%2==0)cnt42[a[x]/2*3]-=cnt[a[x]*2];
        if(a[x]%3==0)cnt23[a[x]/3*4]-=cnt[a[x]/3*2];
    }  
    void r_add(int x){
        cnt[a[x]]++;ans+=cnt42[a[x]];
        if(a[x]%2==0)cnt42[a[x]/2*3]+=cnt[a[x]*2];
        if(a[x]%3==0)cnt23[a[x]/3*4]+=cnt[a[x]/3*2];
    }
}ds;
signed main(){
    int n=read(),m=read(),b=sqrt(n),l=1,r=0;
    for(int i=1;i<=n;i++)a[i]=read(),pos[i]=(i-1)/b+1;
    for(int i=1;i<=m;i++)q[i]={read(),read(),i};sort(q+1,q+m+1);
    for(int i=1;i<=m;i++){
        while(l<q[i].l)ds.l_del(l++);
        while(l>q[i].l)ds.l_add(--l);
        while(r>q[i].r)ds.r_del(r--);
        while(r<q[i].r)ds.r_add(++r);
        ans[q[i].id]=ds.ans;
    }
    for(int i=1;i<=m;i++)cout<<ans[i]<<"\n";
    return 0;
}
```

---

## 作者：262620zzj (赞：0)

莫队模板题。

我们维护几个桶即可。$cnt(x)$ 表示 $[l,r]$ 内有几个 $x$，$cnt23(x)$ 表示有多少个可以以 $x$ 作为 $4$ 的二元组 $(y,z)$，同理，$cnt42(x)$ 表示有多少个可以以 $x$ 作为 $3$ 的二元组。

指针移动时，用 $cnt23,cnt42$ 更新答案，用普通的桶更新 $cnt23,cnt42$ 即可。

复杂度是 $O(n\sqrt{n})$，由于常数很小，可以通过。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read(){
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
inline void write(int x){
    if(x==0){putchar('0');return;}
    int len=0,k1=x,c[10005];
    if(k1<0)k1=-k1,putchar('-');
    while(k1)c[len++]=k1%10+'0',k1/=10;
    while(len--)putchar(c[len]);
}
const int N=1e6+5;
int a[N],cnt[N],pos[N],cnt23[N],cnt42[N],ans[N];
struct ask{
    int l,r,id;
    bool operator <(const ask &x)const{
        if(pos[l]!=pos[x.l])return pos[l]<pos[x.l];
        if(pos[l]&1)return r<x.r;return r>x.r;
    }
}q[N];
struct sqrt{
    int ans=0;
    void l_del(int x){
        cnt[a[x]]--;ans-=cnt23[a[x]];
        if(a[x]%4==0)cnt42[a[x]/4*3]-=cnt[a[x]/2];
        if(a[x]%2==0)cnt23[a[x]*2]-=cnt[a[x]/2*3];
    }
    void l_add(int x){
        cnt[a[x]]++;ans+=cnt23[a[x]];
        if(a[x]%4==0)cnt42[a[x]/4*3]+=cnt[a[x]/2];
        if(a[x]%2==0)cnt23[a[x]*2]+=cnt[a[x]/2*3];
    }
    void r_del(int x){
        cnt[a[x]]--;ans-=cnt42[a[x]];
        if(a[x]%2==0)cnt42[a[x]/2*3]-=cnt[a[x]*2];
        if(a[x]%3==0)cnt23[a[x]/3*4]-=cnt[a[x]/3*2];
    }  
    void r_add(int x){
        cnt[a[x]]++;ans+=cnt42[a[x]];
        if(a[x]%2==0)cnt42[a[x]/2*3]+=cnt[a[x]*2];
        if(a[x]%3==0)cnt23[a[x]/3*4]+=cnt[a[x]/3*2];
    }
}ds;
signed main(){
    int n=read(),m=read(),b=sqrt(n),l=1,r=0;
    for(int i=1;i<=n;i++)a[i]=read(),pos[i]=(i-1)/b+1;
    for(int i=1;i<=m;i++)q[i]={read(),read(),i};sort(q+1,q+m+1);
    for(int i=1;i<=m;i++){
        while(l>q[i].l)ds.l_add(--l);
        while(r<q[i].r)ds.r_add(++r);
        while(r>q[i].r)ds.r_del(r--);
        while(l<q[i].l)ds.l_del(l++);
        ans[q[i].id]=ds.ans;
    }
    for(int i=1;i<=m;i++)cout<<ans[i]<<"\n";
    return 0;
}
```

---

## 作者：wangif424 (赞：0)

## sub0

无脑暴力 `5pts`。

## sub1

考虑在固定一个端点时，可以移动另一个端点，并更新答案。

对询问离线按左端点排序可以做到 $O(n^2)$。

~~我竟然没有立即判断出这是莫队~~。

## sub all

不难发现上述过程能莫队做到 $O(n\sqrt n)$，这里再详细说一下如何更新答案。

开三个数组 $v_{1,i},v_{2,i},v_{3,i}$ 分别表示当前区间中，$i$ 出现次数、$i:0.5i$ 出现次数、$i:1.5i$ 出现次数。

以左端点加入点 $x$ 时为例。先更新 $v_1$，再在 $v_1$ 中查询 $0.5x,0.75x$ 的出现次数以更新 $v_2,v_3$。最后查询 $0.5x:0.75x$ 的出现次数更新答案。

局部代码如下：
```cpp
while(l>v[i].l){
  l--;
  v1[a[l]]++;
  if(a[l]%2==0){
    v2[a[l]]+=v1[a[l]/2];
    v3[a[l]]+=v1[a[l]/2*3];
    res+=v3[a[l]/2];
  }
}
```

## AC 代码

```cpp
#include <bits/stdc++.h>
#define R(x) x = read()
#define int long long
#define double long double
#define pii pair<int,int>
#define iax INT_MAX
#define iin INT_MIN
#define lax LLONG_MAX
#define lin LLONG_MIN
#define sqrt sqrtl
bool Mbe;
using namespace std;
char pbuf[1<<20], *pp=pbuf;
inline void push(const char &c){(pp-pbuf==1<<20)?fwrite(pbuf,1,1<<20,stdout),pp=pbuf,*pp++=c:*pp++=c;}
class io {public:~io() {fwrite(pbuf, 1, pp - pbuf, stdout);}} _;
inline void write(int x) {
	x<0&&(push('-'),x=-x);
	static int sta[60]={},top=0;
	do{sta[top++]=x%10,x/=10;}while(x);
	while(top)push(sta[--top]^'0');
}
#ifndef LOCAL
	char buf[1<<23],*p1=buf,*p2=buf;
	#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
inline int read() {
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){ch=='-'&&(f=-1);ch=getchar();}
    while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
    return x*f;
}
constexpr int N=4e5+100;
int n,m,a[N];
int v1[N],v2[N],v3[N],res;
//v2[i]:i,i/2    v3[i]:i,i*1.5
struct ak{
	int l,r,id;
}v[N];
int ans[N];
int b;
bool Med;
signed main(){
#ifndef LOCAL
#else
	cerr << (&Med-&Mbe)/1024.0/1024 << "MB\n";
#endif
	R(n);R(m);
	for(int i=1;i<=n;i++)R(a[i]);
	for(int i=1;i<=m;i++){
		R(v[i].l);R(v[i].r);
		v[i].id=i;
	}
	b=sqrt(n);
	sort(v+1,v+1+m,[](ak x,ak y){
		return x.l/b==y.l/b?x.r<y.r:x.l<y.l;	
	});
	int l=1,r=1;
	v1[a[1]]=1;
	for(int i=1;i<=m;i++){
		while(l>v[i].l){
			l--;
			v1[a[l]]++;
			if(a[l]%2==0){
				v2[a[l]]+=v1[a[l]/2];
				v3[a[l]]+=v1[a[l]/2*3];
				res+=v3[a[l]/2];
			}
		}
		while(r<v[i].r){
			r++;
			v1[a[r]]++;
			v2[a[r]*2]+=v1[a[r]*2];
			if(a[r]%3==0){
				v3[a[r]/3*2]+=v1[a[r]/3*2];
				res+=v2[a[r]/3*4];
			}
		}
		while(l<v[i].l){
			v1[a[l]]--;
			if(a[l]%2==0){
				v2[a[l]]-=v1[a[l]/2];
				v3[a[l]]-=v1[a[l]/2*3];
				res-=v3[a[l]/2];
			}
			l++;
		}
		while(r>v[i].r){
			v1[a[r]]--;
			v2[a[r]*2]-=v1[a[r]*2];
			if(a[r]%3==0){
				v3[a[r]/3*2]-=v1[a[r]/3*2];
				res-=v2[a[r]/3*4];
			}
			r--;
		}
		ans[v[i].id]=res;
	}
	for(int i=1;i<=m;i++){
		write(ans[i]),push('\n');
	}
    return 0;
}
```

---


# [国家集训队] 小 Z 的袜子

## 题目描述

upd on 2020.6.10 ：更新了时限。

作为一个生活散漫的人，小 Z 每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小 Z 再也无法忍受这恼人的找袜子过程，于是他决定听天由命……

具体来说，小 Z 把这 $N$ 只袜子从 $1$ 到 $N$ 编号，然后从编号 $L$ 到 $R$ 的袜子中随机选出两只来穿。尽管小 Z 并不在意两只袜子是不是完整的一双，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。

你的任务便是告诉小 Z，他有多大的概率抽到两只颜色相同的袜子。当然，小 Z 希望这个概率尽量高，所以他可能会询问多个 $(L,R)$ 以方便自己选择。

**然而数据中有 $L=R$ 的情况，请特判这种情况，输出`0/1`。**


## 说明/提示

$30\%$ 的数据中，$N,M\leq 5000$；

$60\%$ 的数据中，$N,M \leq 25000$；

$100\%$ 的数据中，$N,M \leq 50000$，$1 \leq L \leq R \leq N$，$C_i \leq N$。


## 样例 #1

### 输入

```
6 4
1 2 3 3 3 2
2 6
1 3
3 5
1 6```

### 输出

```
2/5
0/1
1/1
4/15```

# 题解

## 作者：communist (赞：136)

对于L,R的询问。

设其中颜色为x,y,z的袜子的个数为a,b,c...

那么答案即为
$(a*(a-1)/2+b*(b-1)/2+c*(c-1)/2....)/((R-L+1)*(R-L)/2)$

化简得:
$(a^2+b^2+c^2+...x^2-(a+b+c+d+.....))/((R-L+1)*(R-L))$

即：
$(a^2+b^2+c^2+...x^2-(R-L+1))/((R-L+1)*(R-L))$

我们需要解决的一个问题

求一个区间内每种颜色数目的平方和。

上代码
```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
typedef long long LL;
const int maxn=50005;
int n,m,pos[maxn],c[maxn];
LL s[maxn],ans;
struct data{
    int l,r,id;
    LL a,b;
}a[maxn];
bool cmp(const data&a,const data&b)
{
    if(pos[a.l]==pos[b.l])
		return a.r<b.r;
    return a.l<b.l;
}
bool cmp_id(const data&a,const data&b)
{
    return a.id<b.id;
}
void update(int p,int add)
{
    ans-=s[c[p]]*s[c[p]];
    s[c[p]]+=add;
    ans+=s[c[p]]*s[c[p]];
}
void solve()
{
    for(int i=1,l=1,r=0;i<=m;i++)
	{
        for(;r<a[i].r;r++)
			update(r+1,1);
        for(;r>a[i].r;r--)
			update(r,-1);
        for(;l<a[i].l;l++)
			update(l,-1);
        for(;l>a[i].l;l--)
			update(l-1,1);
        if(a[i].l==a[i].r)
		{
            a[i].a=0;
			a[i].b=1;
            continue;
        }
        a[i].a=ans-(a[i].r-a[i].l+1);
        a[i].b=(a[i].r-a[i].l+1)*1LL*(a[i].r-a[i].l);
        LL g=__gcd(a[i].a,a[i].b);
        a[i].a/=g;
		a[i].b/=g;
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
		scanf("%d",&c[i]);
    int block=sqrt(n);
    for(int i=1;i<=n;i++)
		pos[i]=(i-1)/block+1;
    for(int i=1;i<=m;i++)
	{
        scanf("%d%d",&a[i].l,&a[i].r);
        a[i].id=i;
    }
    sort(a+1,a+m+1,cmp);
    solve();
    sort(a+1,a+m+1,cmp_id);
    for(int i=1;i<=m;i++)
        printf("%lld/%lld\n",a[i].a,a[i].b);
    return 0;
}
```

---

## 作者：qwaszx (赞：84)

qwq代码没注释被打回来了一次

加注释.jpg

qwq刚学的莫队打了rk1

莫队：莫涛队长发明的算法，尊称莫队

其实就是优化的暴力

普通莫队只兹磁询问不支持修改，是离线的

莫队的思想

如果可以通过区间[l,r]快速转移到[l-1,r][l+1,r][l,r-1][l,r+1],那么可以用O(x*|l1-l2|+|r1-r2|)的时间完成转移,[l2,r2]是[l1,r1]的后一次询问,x是[l,r]转到相邻区间的复杂度

我们让这个值最小，就是求曼哈顿距离最小生成树

但那个东西很鬼畜

可以用分块加上一定规则来排序

以左端点所在块的编号为第一关键字排序，右端点的值作为第二关键字排序

最坏复杂度和上面的曼哈顿距离最小生成树是一样的

这个样子做的复杂度是O(nsqrt(m))的

~~证明我不会~~

块的大小可以取n/sqrt(m*2/3)),比较快————lxl

可以分奇偶排序，如果块序号为奇就升序排r，否则降序，具体见代码

如果分块你不会的话可以去看[这里](http://hzwer.com/8053.html)

接下来分析这个题

在区间[l,r]取到相同袜子的方案数是![](http://latex.codecogs.com/gif.latex?%5Csum_%7Bx%20%5Cin%5Bl%2Cr%5D%20%7D%5Cbinom%7Bcnt%5Bx%5D%7D%7B2%7D),其中cnt[x]是颜色x的数量

区间[l,r]随便取一对的方案数是![](http://latex.codecogs.com/gif.latex?%5Cbinom%7Br-l&plus;1%7D%7B2%7D)

把两个相除，展开以后就得到![](http://latex.codecogs.com/gif.latex?%5Cfrac%7B%5Csum_%7Bx%5Cin%5Bl%2Cr%5D%7Dcnt%5Bx%5D%5E%7B2%7D-%5Csum_%7Bx%5Cin%5Bl%2Cr%5D%7Dcnt%5Bx%5D%7D%7Blen%28len-1%29%7D),len=r-l+1

因为所有颜色数量之和等于len,所以只需要维护cnt[x]的平方和即可

但线段树没法做，因为每个区间是独立的，cnt[x]无法统计，用莫队

考虑转移的时候如果加入元素x,那么cnt[x]变成cnt[x]+1,对答案的贡献为2cnt[x]+1

删除同理

于是写出add和pop,其中x表示某个位置的颜色

void add(int x){tot+=(cnt[x]<<1)|1,cnt[x]++;}

void pop(tot+=1-(cnt[x]<<1),cnt[x]--;}

然后写转移

设l和r为上次处理的区间，q[i].l和q[i].r为这次询问区间,第一次直接从l到r进行add即可

while(l<q[i].l)pop(a[l++]);

while(l>q[i].l)add(a[--l]);

while(r<q[i].r)add(a[++r]);

while(r>q[i].r)pop(a[r--]);

然后特判l=r的情况，求一下gcd就好，可以用自带gcd

放152ms蛇皮卡常代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;//少加载几个库可以省空间，打rk可以用
struct hh
{
	int l,r,id;//存每个询问的l,r和排序前的位置
	long long len;//区间大小
}b[60000];
int a[60000],bl[60000],n,m,blo,num[60000];
long long ans1[60000],ans2[60000],tot;
//常用卡常技巧:inline把函数展开减少调用，register把变量放到CPU寄存器
//还有快读和快写都是不用说的，以及位运算代替普通运算
//但最重要的是降低你算法的复杂度，比如fft板子的rk1用基4-fft虐rk2一百ms
//当然不是我，我就是不相信为什么那么快就把人家的代码粘过来并开了O2(逃
//但我可是这题的rk1啊踩了chenzhe大爷16ms的（逃
inline bool cmp(const hh &a,const hh &b)//排序的规则
{
	if(bl[a.l]<bl[b.l])return 1;
	if(bl[a.l]>bl[b.l])return 0;
	if(bl[a.l]&1)return a.r<b.r;//按奇偶块分别排，减少块切换所用代价
	return a.r>b.r;
//return bl[a.l]^bl[b.l]?bl[a.l]<bl[b.l]:bl[a.l]&1?a.r<b.r:b.r>b.r;
}
inline char gc()//用fread把读入加速到极致，具体我也不懂，背板子就好
{
	static char BB[1000000],*S=BB,*T=BB;
	return S==T&&(T=(S=BB)+fread(BB,1,1000000,stdin),S==T)?EOF:*S++;
}
inline int getin()//getchar换成fread的快读
{
	register int x=0;register char ch=gc();
	while(ch<48)ch=gc();
	while(ch>=48)x=x*10+(ch^48),ch=gc();
	return x;
}
inline void add(int x){tot+=((num[x]<<1)|1),num[x]++;}//添加操作
//(num[x]<<1)|1就是num[x]*2+1,因为<<1之后二进制最后一位为0，可以按位或
inline void rem(int x){tot+=1-(num[x]<<1),num[x]--;}//删除操作
int wt[30];//快写所用数组
inline void putout(long long x)
{
	if(!x){putchar(48);return;}//putchar要比普通输出快，不知道有没有像fread一样的东西
	register int l=0;          
	while(x)wt[++l]=x%10,x/=10;
	while(l)putchar(wt[l--]+48);
    //可以写递归版，如下:
    //if(x>9)putout(x/10);putchar(x%10+48);效率差不多
}
int main()
{
	n=getin(),m=getin();
	register int blo=n/sqrt((m>>1)/3);//blo块大,根据lxl所说这样能快10%
	for(register int i=1;i<=n;i++)a[i]=getin();
	for(register int i=1;i<=m;i++)b[i].l=getin(),b[i].r=getin(),b[i].len=b[i].r-b[i].l+1,b[i].id=i,ans2[i]=1,bl[i]=(i-1)/blo+1;
	sort(b+1,b+m+1,cmp);//排序
	register int l=b[1].l,r=b[1].r;
	for(register int i=l;i<=r;i++)add(a[i]);//先把l[1]-r[1]加进去
	register long long fz,fm,g;
	if(tot!=b[1].len)//防爆，就是l==r,不然你过不了样例，下同
	{
		fz=tot-b[1].len,fm=b[1].len*(b[1].len-1),g=__gcd(fz,fm);
		ans1[b[1].id]=fz/g,ans2[b[1].id]=fm/g;//约分
        //貌似开O2的话自带的gcd比手写能快一点
	}
	for(register int i=2;i<=m;i++)
	{
		while(l<b[i].l)rem(a[l++]);//l小了就删
		while(l>b[i].l)add(a[--l]);//l大了就加
		while(r>b[i].r)rem(a[r--]);//r大了就删
		while(r<b[i].r)add(a[++r]);//r小了就加
		if(b[i].len!=tot)
		{
			fz=tot-b[i].len,fm=b[i].len*(b[i].len-1);
			g=__gcd(fz,fm),ans1[b[i].id]=fz/g,ans2[b[i].id]=fm/g;
		}
	}
    //当然你也可以不开ans1和ans2，但那样要重新排序回来
	for(register int i=1;i<=m;i++)putout(ans1[i]),putchar('/'),putout(ans2[i]),putchar(10);
}
```
想要更多的莫队技巧?@noip老师手把手教你变毒瘤

---

## 作者：夏色祭 (赞：68)

感觉莫队的题都差不多。


## 莫队

如果是按照顺序膜拟每一个询问，那么就是我们暴力算出第一个询问的答案，然后通过前一个询问的区间求出后一个询问的区间的答案，就是把多出来的地方删掉，少的地方加上去。


我们计前一个询问的区间为$[l_{i-1},r_{i-1}]$,现在要求的区间是$[l_{i},r_{i}]$，那么根据上述算法时间复杂度应该是$|l_{i-1}-l_{i}|+|r_{i-1}-r_{i}|$


那么莫队就是对这些询问进行重构，使得$|l_{i-1}-l_{i}|+|r_{i-1}-r_{i}|$的和尽可能小，所以莫队是个离线算法。


## 怎么重构？


考虑分块的思想，先根据询问的l所在块的编号排序，然后如果所在块编号相同，则按r排序。


## 复杂度证明？


楼下讲了。。。所以我就懒得讲了。。。


### 小技巧


如果l所在块的编号为奇数则按r升序排序，偶数则按r降序排序。


知道莫队的话，对于此题，难点就到了如何求概率。

取到两只同颜色的袜子的方案数:$\sum_{i=1}^{N} cnt[i]*(cnt[i]-1)(cnt[i]>=2)$(cnt[i]表示颜色为i的袜子有几只)

取的总方案数：(r-l+1)*(r-l)

```
//by zykykyk
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<string>
#include<set>
#include<vector>
#include<map>
#define For(i,x,y) for (int i=(x);i<=(y);i++)
#define Dow(i,x,y) for (int i=(x);i>=(y);i--)
#define cross(i,k) for (int i=first[k];i;i=last[i])
#define il inline
#define vd void
#define ll long long
#define N 50010
using namespace std;
il int read(){
    int x=0;int ch=getchar(),f=1;
    while (!isdigit(ch)&&(ch!='-')&&(ch!=EOF)) ch=getchar();
    if (ch=='-'){f=-1;ch=getchar();}
    while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
    return x*f;
}
struct query{
    ll l,r,id;
}ask[N];
struct answer{
    ll x,y;
}ans[N],now;
int n,m,l,r,len,id[N],c[N];
ll cnt[N];
il bool cmp(query x,query y){
    if (id[x.l]==id[y.l]){
        if (id[x.l]&1==1) return x.r<y.r;
        else return x.r>y.r;	
    }
    else return id[x.l]<id[y.l];
}
il ll gcd(ll x,ll y){return !y?x:gcd(y,x%y);}
il vd Divgcd(ll x,ll y,int id){
    if (!x) x=0,y=1;
    else {
        ll Gcd=gcd(x,y);
        x/=Gcd,y/=Gcd;
    }
    ans[id].x=x,ans[id].y=y;
}
il vd add(int x){
    cnt[x]++;
    if (cnt[x]>1) now.x=now.x+cnt[x]*(cnt[x]-1)-(cnt[x]-1)*(cnt[x]-2);
}
il vd del(int x){
    cnt[x]--;
    if (cnt[x]>0) now.x=now.x+cnt[x]*(cnt[x]-1)-(cnt[x]+1)*cnt[x];
}
int main(){
    n=read(),m=read();
    len=sqrt(n);
    For(i,1,n) c[i]=read(),id[i]=(i-1)/len+1;
    For(i,1,m){
        ask[i].l=read(),ask[i].r=read(),ask[i].id=i;
    } 
    sort(ask+1,ask+1+m,cmp);
    For(i,ask[1].l,ask[1].r) add(c[i]);
    now.y=(ask[1].r-ask[1].l+1)*(ask[1].r-ask[1].l);
    Divgcd(now.x,now.y,ask[1].id);
    l=ask[1].l,r=ask[1].r;
    For(i,2,m){
        while (l<ask[i].l) del(c[l++]);
        while (l>ask[i].l) add(c[--l]);
        while (r<ask[i].r) add(c[++r]);
        while (r>ask[i].r) del(c[r--]);
        now.y=(ask[i].r-ask[i].l+1)*(ask[i].r-ask[i].l);
        Divgcd(now.x,now.y,ask[i].id);
    }
    For(i,1,m) printf("%lld/%lld\n",ans[i].x,ans[i].y);
}
```

---

## 作者：Rainy_chen (赞：41)

这里介绍一个zyb爷爷给我讲的在线做法，复杂度是和莫队相同的 $O(n\sqrt n)$。

我们考虑一下答案该怎么计算，令 $ans$ 表示有多少对 $(i,j), i\not=j$ 满足 $C_i=C_j$。  

之后显而易见的，答案就是 $ans \div \text A_{r-l+1}^2$。

于是我们只需要考虑怎么快速计算出 $ans$。  

首先对序列分块，之后我们将所有的 $(i,j)$ 分成三类：
- $i, j$ 在同一块
- $i, j$ 都在散点中
- $i, j$ 一个在块内，一个在散点中  

对于第一类的 $(i,j)$，我们有一个十分经典的套路，只需令 $f(a,b)$ 表示从 $a$ 到 $b$ 这 $b-a+1$ 个块的答案即可。之后可以很暴力的从 $f(a,b-1)$ 计算出 $f(a,b)$ 的值，这一部分的复杂度是 $O(n\sqrt n)$。  

虽然应该没有人不会这个暴力计算的方式，但是还是提一下。  

我们维护当前所有颜色的出现次数，用 $cnt_i$ 来表示当前 $i$ 颜色出现了几次。

从块 $b$ 的开头暴力扫到块 $b$ 的结尾，当扫描到一个颜色 $C$ 时，我们发现答案中颜色 $C$ 的贡献会从 $\text A_{cnt_C}^2$ 变成 $\text A_{cnt_C+1}^2$。简单推一下式子就会发现只需令答案加上 $2\times cnt_C$ 即可。

对于第二类的 $(i,j)$，考虑到散点个数不会超过 $2\sqrt n$，我们直接按照类似于第一类 $(i,j)$ 计算时方法计算出这 $2\sqrt n$ 个数的贡献加到答案里。

对于第三类的 $(i,j)$，我们依然尝试枚举散点中的每一个颜色，当我们枚举到一个颜色 $C$ 时，容易发现这个颜色会对答案产生 $2\times \text{整块中颜色C的出现次数}$ 的贡献。  

显然，直接维护从块 $a$ 到块 $b$ 中颜色 $i$ 的出现次数会导致空间复杂度达到 $O(n^2)$。但是我们发现出现次数这种信息是可减的，于是维护 $g(a,i)$ 表示前 $a$ 个块中颜色 $i$ 的出现次数，然后就可以 $O(1)$ 计算出颜色 $C$ 对答案的贡献了。  

至此，我们得到了一个需要 $O(n\sqrt n)$ 的时间复杂度进行预处理，需要 $O(m\sqrt n)$ 的时间复杂度来处理所有询问的在线算法。  

*我分块写的不多，代码很丑qwq*
```cpp
#include<bits/stdc++.h>

using namespace std;
typedef long long int_t;

#ifdef ONLINE_JUDGE
    #define getchar getch 
#endif

char getch(){
    static char B[100000], *s, *t;
    return (s == t) && (t = (s = B) + fread(B, 1, 100000, stdin)), s == t ? EOF : *s++;
}

int_t read(){
    int_t x=0, w=1; char C=0;
    while(!isdigit(C)) {C = getchar(); if(C == '-') w = -1;}
    while(isdigit(C)) x = x * 10 + C - '0', C = getchar();
    return x * w;
}

int_t gcd(int_t a,int_t b){return b?gcd(b,a%b):a;}

int_t C[50010], lp[300], rp[300], bel[50010], ans[300][300], tmp[50010], cnt[300][50010];

int main() {
    int_t n = read(), m = read(), siz = sqrt(n), ks = 0;
    for(int_t i=1;i<=n;i++) C[i] = read(), bel[i] = (i-1) / siz + 1, rp[bel[i]] = max(rp[bel[i]], i), ks = bel[i];
    for(int_t i=1;i<=ks;i++) lp[i] = rp[i-1] + 1;
    for(int_t i=1;i<=ks;i++) {
        for(int_t j=i,tans=0;j<=ks;j++) {
            for(int_t k=lp[j];k<=rp[j];k++) tans += 2 * (++tmp[C[k]]) - 2;
            ans[i][j] = tans;
        }
        for(int_t j=1;j<=n;j++) cnt[i][j] = cnt[i-1][j], tmp[j] = 0;
        for(int_t j=lp[i];j<=rp[i];j++) cnt[i][C[j]] ++;
    }
    while(m--) {
        int_t l = read(), r = read(), zkl = bel[l] + (l != lp[bel[l]]), zkr = bel[r] - (r != rp[bel[r]]), sdl = lp[zkl] - 1, sdr = rp[zkr] + 1, tans = ans[zkl][zkr];
        if(l == r) {puts("0/1"); continue;}
        if(bel[l] >= bel[r] - 1) {
            tans = 0;
            for(int_t i=l;i<=r;i++) tans += 2 * (++tmp[C[i]]) - 2;
            for(int_t i=l;i<=r;i++) tmp[C[i]] = 0;
        } else {
            for(int_t i=l;i<=sdl;i++) tans += 2 * (++tmp[C[i]] + cnt[zkr][C[i]] - cnt[zkl - 1][C[i]]) - 2;
            for(int_t i=sdr;i<=r;i++) tans += 2 * (++tmp[C[i]] + cnt[zkr][C[i]] - cnt[zkl - 1][C[i]]) - 2;
            for(int_t i=l;i<=sdl;i++) tmp[C[i]] = 0;
            for(int_t i=sdr;i<=r;i++) tmp[C[i]] = 0;
        }
        int_t fm = (r - l + 1) * (r - l), d = gcd(tans, fm);
        printf("%lld/%lld\n", tans / d, fm / d);
    }
}
```

---

## 作者：wangyitong (赞：36)


莫队算法用于处理一些只有询问不用修改的区间问题，这时候我们就有疑问了，区间问题？线段树啊，这不是很好嘛。但是有些情况下，线段树的复杂度我们也接受不了；

比如：给出m个询问[L,R],求区间内出现次数大于等于3的个数？

用线段树的话我们还是要暴力合并左右儿子：

这样就不能直接o（1）从左右儿子转移到父亲，甚至是o(左儿子长度+右儿子长度)

这样用线段树就凉了。

由于只有查询，不用修改，那我们可以尝试离线处理；

如果我们知道了区间[L,R]，那么我们只需要把a[R+1]的出现次数更新，就能更新[L,R+1]的答案；

这样好像我们也能更新[L+1,R],[L-1,R],[L,R-1]；

叮~

您的莫队算法已上线：

莫队算法相对于线段树有更优秀的复杂度：

我们已知区间[L,R],求[L',R']的话，只需要一步步转移，是O(|L-L'|+|R-R'|)

如果我们把每一个区间看成一个二维平面的坐标，那么每次询问的复杂度就是两个点的曼哈顿距离；

我们知道连接n个点的最优策略是一个树，那么我们操作的复杂度就是树上点的曼哈顿距离之和；

最优复杂度就是曼哈顿距离最小生成树；

这样打肯定会特别麻烦，转移的时候还要处理分支情况，还要化为坐标，建边；

那我们还有别的方法在代码量少的情况下又能保证我们的复杂度呢？（不知道你们，反正我是因为懒……）

尝试分块：以左端点为第一关键字，右端点为第二关键字；

分块相同时，右端点递增是O(N)的，分块共有O(sqrt(N))个，复杂度为O(N1.5 )

分块转移时，右端点最多变化N，分块共有O(sqrt(N))个，复杂度为O(N1.5)

分块相同时，左端点最多变化sqrt(N) ，分块转移时，左端点最多变化2sqrt(N)，共有N个询问，复杂度为O(N1.5)
（来自学长的芝士[SiriusRen](https://www.cnblogs.com/SiriusRen/p/6910362.html)）

其实分块的作用就是加速而已，好像也没啥用；

做几道题?

1、[小B的询问（传送门）](https://www.luogu.org/problemnew/show/P2709)

```cpp

题目描述

小B有一个序列，包含N个1~K之间的整数。他一共有M个询问，每个询问给定一个区间[L..R]，求Sigma(c(i)^2)的值,其中i的值从1到K，其中c(i)表示数字i在[L..R]中的重复次数。小B请你帮助他回答询问。
输入输出格式
输入格式：

第一行，三个整数N、M、K。

第二行，N个整数，表示小B的序列。

接下来的M行，每行两个整数L、R。

输出格式：

M行，每行一个整数，其中第i行的整数表示第i个询问的答案。

输入输出样例
输入样例#1： 复制

6 4 3
1 3 2 1 1 3
1 4
2 6
3 5
5 6

输出样例#1： 复制

6
9
5
2

说明

对于全部的数据，1<=N、M、K<=50000

```
直接上莫队，裸题；
记得分块，这样会快很多；

用一个t数组记录当前每个数字出现次数即可，然后每次增加一个点即增加2*t[i]+1;（减小也一样）

但是边界条件要考虑，从区间外向区间里更新时，先更新当前点再++或--；而从区间内部向外部更新就要先++或--；

蒟蒻的码风比较奇特↓

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
int b[50050],t[50050];
long long ans[50050];
int n,m,k,len;
long long temp;
struct node
{
	int l;
	int r;
	int id;
	int d;
}a[50500];
inline bool cmp(node a,node b)
{
	if(a.id==b.id)
		return a.r<b.r;
	else 
		return a.id<b.id;
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	len=sqrt(n);
	for(int i=1;i<=n;i++)
		scanf("%d",&b[i]);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&a[i].l,&a[i].r);
		a[i].id=(a[i].l+len-1)/len;
		a[i].d=i;
	}
 	sort(a+1,a+m+1,cmp);
 	int l=a[1].l;
 	int r=a[1].l-1;
 	for(int i=1;i<=m;i++)
 	{
 		while(l<a[i].l) temp-=2*--t[b[l++]]+1;
 		while(l>a[i].l) temp+=2*++t[b[--l]]-1;
 		while(r>a[i].r) temp-=2*--t[b[r--]]+1;
 		while(r<a[i].r) temp+=2*++t[b[++r]]-1;
 		ans[a[i].d]=temp;
	}
	for(int i=1;i<=m;i++)
		printf("%lld\n",ans[i]);
	return 0; 
 } 
```

2、[小z的袜子（传送门）](https://www.luogu.org/problemnew/show/P1494)


```cpp

题目描述

作为一个生活散漫的人，小Z每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命……

具体来说，小Z把这N只袜子从1到N编号，然后从编号L到R(L 尽管小Z并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。

你的任务便是告诉小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个(L,R)以方便自己选择。

然而数据中有L=R的情况，请特判这种情况，输出0/1。
输入输出格式
输入格式：

输入文件第一行包含两个正整数N和M。N为袜子的数量，M为小Z所提的询问的数量。接下来一行包含N个正整数Ci，其中Ci表示第i只袜子的颜色，相同的颜色用相同的数字表示。再接下来M行，每行两个正整数L，R表示一个询问。

输出格式：

包含M行，对于每个询问在一行中输出分数A/B表示从该询问的区间[L,R]中随机抽出两只袜子颜色相同的概率。若该概率为0则输出0/1，否则输出的A/B必须为最简分数。（详见样例）

输入输出样例
输入样例#1： 复制

6 4
1 2 3 3 3 2
2 6
1 3
3 5
1 6

输出样例#1： 复制

2/5
0/1
1/1
4/15

说明

30%的数据中 N,M ≤ 5000；

60%的数据中 N,M ≤ 25000；

100%的数据中 N,M ≤ 50000，1 ≤ L < R ≤ N，Ci ≤ N。

```

这个题一看没啥思路啊，概率题emm……，为啥我想到了生物……；
那我们先写写式子？
设 a,b,c……为每种颜色出现的次数；
答案是：

**(a∗(a−1)/2+b∗(b−1)/2+c∗(c−1)/2....)/((R−L+1)∗(R−L)/2)**

化简一下:

***(a^2+b^2+c^2+……-(a+b+c+……))/(R-L+1)*(R-L)**

那么就是

***(a^2+b^2+c^2+……-(R-L+1))/(R-L+1)*(R-L)**

我们愉快的这个题变成了上一个题；
不一样的地方就是统计答案时，不能用一个数组了，要再开一个结构体，一个存分子，一个存分母；再化简，特判，long long
就差不多了；

很稳

代码就不放了，根据上一个可以自己写出来；

I hope this blog can help you ;









---

## 作者：Iang_ (赞：34)

# 莫队！！  
这道题可以用绝妙的莫队（~~优美的暴力~~）解决QAQ  
s[i]表示区间内第i种颜色的数量   
很容易推出这一种袜子的贡献为   
（s[i]*(s[i]-1)/2）,最后再累加答案就好了。      
话不多说，下面附上AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct line
{
	int l,r,num;
} q[50010];
int n,m,k,a[50010],ans[50010],l=1,r,sum,s[50010],size,id[50010];
//这位置的颜色，第i个询问的答案，当前的左右端点，当前的总贡献，一个块的长度，这个位置是在第几块 
long long l1[50010],r1[50010];
bool cmp(line x,line y)
{
	if(id[x.r]==id[y.r])return x.l<y.l;
	else return x.r<y.r;
}
int main()
{
	scanf("%d%d",&n,&m);
	size=n/sqrt(m*2/3);//网上大佬说这样快（我也不知道为什么QAQ） 
	for(int i=1; i<=n; i++)
		scanf("%d",&a[i]),id[i]=(i-1)/size+1;
	for(int i=1; i<=m; i++)
		scanf("%d%d",&q[i].l,&q[i].r),q[i].num=i,l1[i]=q[i].l,r1[i]=q[i].r;
	sort(q+1,q+m+1,cmp);
	for(int i=1; i<=m; i++)
	{
		while(l<q[i].l)sum-=s[a[l]]*(s[a[l]]-1)/2,s[a[l]]--,sum+=s[a[l]]*(s[a[l]]-1)/2,l++;
		while(l>q[i].l)l--,sum-=s[a[l]]*(s[a[l]]-1)/2,s[a[l]]++,sum+=s[a[l]]*(s[a[l]]-1)/2;
		while(r<q[i].r)r++,sum-=s[a[r]]*(s[a[r]]-1)/2,s[a[r]]++,sum+=s[a[r]]*(s[a[r]]-1)/2;
		while(r>q[i].r)sum-=s[a[r]]*(s[a[r]]-1)/2,s[a[r]]--,sum+=s[a[r]]*(s[a[r]]-1)/2,r--;
		ans[q[i].num]=sum;
	}
	for(int i=1,x; i<=m; i++)
	{
		x=__gcd((long long)ans[i],(long long)(r1[i]-l1[i]+1)*(r1[i]-l1[i])/2);
		//约分成最简分数 
		if(l1[i]==r1[i])printf("0/1\n");
		else printf("%d/%lld\n",ans[i]/x,(long long)((r1[i]-l1[i]+1)*(r1[i]-l1[i])/2)/x);
	}
	return 0;//完美地结束！！ 
}
```


---

## 作者：fmx0219 (赞：20)

# 题目分析

## 首先我们看一个简化的问题

给定一个序列，以及多组询问，针对每组询问，回答该区间有多少方案选出两个值相同的元素（不能调换左右）。

在上面的问题中，假设有n个值相同的元素，那方案数肯定是n*(n-1)/2,所以每个元素对答案贡献为在它之前的元素个数；

## 那我们回到之前的问题

题目中说可以调换左右，但因为所有的的袜子可以调换左右，所以就等价与上面的问题，我们只要把所有的选出的相同袜子的方案数除以所有的方案数。

附代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t;
int a[500005];
struct node
{
    int l,r;
    int pos;
}e[500005];
inline bool cmp(node a,node b)
{
    return (a.r/t)==(b.r/t)?a.l<b.l:a.r<b.r;//排序; 
}
long long ans[500005],cnt[500005];//不开long long一场空; 
long long sum[500005];
long long k=0;
inline void sk(int x)
{
	k+=cnt[a[x]];
    cnt[a[x]]++;
}
inline void hk(int x)
{
    cnt[a[x]]--;
	if(cnt[a[x]]!=0) k-=cnt[a[x]];
}
int f[500005];
int main()
{
	scanf("%d%d",&n,&m);
    for(register int i=1;i<=n;i++) scanf("%d",&a[i]);
    t=n/sqrt(m*2/3);
    for(register int i=1;i<=m;i++)
    {
        scanf("%d%d",&e[i].l,&e[i].r);
        e[i].pos=i;
    }
    sort(e+1,e+m+1,cmp);
    int l=1,r=0;
    for(register int i=1;i<=m;i++)
    {
        while(l<e[i].l) hk(l++); 
        while(l>e[i].l) sk(--l);
        while(r<e[i].r) sk(++r);
        while(r>e[i].r) hk(r--);
        long long d=e[i].r-e[i].l+1;
        if(e[i].l==e[i].r) f[e[i].pos]=1;
        ans[e[i].pos]=k;
        sum[e[i].pos]=d*(d-1)/2;
    }
    for(register int i=1;i<=m;i++)
    {
    	long long d=__gcd(ans[i],sum[i]);
    	if(f[i]==1) printf("0/1\n");//特判，就因为这个我交了好几发. 
    	else printf("%lld/%lld\n",ans[i]/d,sum[i]/d);
    }
    return 0;
}
```


---

## 作者：vegetabird (赞：16)

这道题其实可以直接用分块做。

把所有的袜子按顺序分成$k$块，然后离线求出$f[i][j]$，表示第$i$块到第$j$块的所有合法选择方式的总数。$f[i][j]$可以由$f[i][j-1]$推导得到：计算第$j$块中每一种颜色$c$在第$i$块到第$j-1$块的出现次数$t0$以及在第$i$块到第$j$块的出现次数$t1$，则：

$f[i][j]=f[i][j-1]+\sum\limits_{c}(\frac{t1(t1-1)-t0(t0-1)}{2})$

每一次转移的复杂度可以是$\Omega(\sqrt{n}log(n))$，也可以优化到$\Omega(\sqrt{n})$(详见程序写法)，这样预处理的总复杂度是$\Omega(n\sqrt{n})$。

对于每一次询问，我们在预处理的基础上，将头尾剩余的袜子按照上文中转移的方法处理，但这里我~~们~~(应该是我太菜了)无法将其复杂度优化为$\Omega(\sqrt{n})$，只能痛苦地忍受$\Omega(\sqrt{n}log(n))$的复杂度QAQ。这样总复杂度就是$\Omega(n\sqrt{n}log(n))$。(能过就行。。。)

代码：(不开$O2$全站倒数第一984ms卡着过，开了后就稳了许多)

``` cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
long long gcd(const int &a,const int &b){
    if(!b)return a;
    return gcd(b,a%b);
}
int n,m;
int a[60010];
int cnt[60010],*pos[60010];
int data[1000010],*ptr=data;
long long f[250][250];
int blocksize;
long long s[60010];
bool vis[60010],vis2[60010];
long long ans;
int calc(const int &lb,const int &rb,const int &c){
    if(pos[c][1]>rb||pos[c][cnt[c]]<lb||lb>rb)return 0;
    int left=1,right=cnt[c]+1,mid,rr;
    while(left+1<right){
        mid=(left+right)>>1;
        if(pos[c][mid]<=rb){
            left=mid;
        }else{
            right=mid;
        }
    }
    rr=left;
    left=0,right=cnt[c];
    while(left+1<right){
        mid=(left+right)>>1;
        if(pos[c][mid]>=lb){
            right=mid;
        }else{
            left=mid;
        }
    }
    return rr-right+1;
}
int main(){
    int i,j,k,l,r,x,y;
    long long tmp;
    scanf("%d%d",&n,&m);
    blocksize=sqrt(n);
    for(i=1;i<=n;++i){
        scanf("%d",a+i);
        ++cnt[a[i]];
    }
    for(i=1;i<=n;++i){
        pos[i]=ptr;
        ptr=pos[i]+cnt[i]+1;
    }
    for(i=1;i<=n;++i){
        *++pos[a[i]]=i;
    }
    for(i=1;i<=n;++i){
        pos[i]-=cnt[i];
    }
    for(i=1;(i-1)*blocksize<n;++i){
        for(j=i;(j-1)*blocksize<n;++j){
            f[i][j]=f[i][j-1];
            for(k=(j-1)*blocksize+1;k<=j*blocksize;++k){
                if(!vis2[a[k]]){
                    vis2[a[k]]=true;
                    f[i][j]-=s[a[k]]*(s[a[k]]-1)/2;
                }
                ++s[a[k]];
            }
            for(k=(j-1)*blocksize+1;k<=j*blocksize;++k){
                if(!vis[a[k]]){
                    vis[a[k]]=true;
                    f[i][j]+=s[a[k]]*(s[a[k]]-1)/2;
                }
            }
            for(k=(j-1)*blocksize+1;k<=j*blocksize;++k){
                vis[a[k]]=vis2[a[k]]=false;
            }
        }
        memset(s,0,sizeof(s));
    }
    while(m--){
        scanf("%d%d",&l,&r);
        if(l==r){
            printf("0/1\n");
            continue;
        }
        x=(l+blocksize-2)/blocksize+1,y=r/blocksize;
        ans=f[x][y];
        for(i=l;i<=min((x-1)*blocksize,r);++i){
            if(!vis[a[i]]){
                vis[a[i]]=true;
                tmp=calc((x-1)*blocksize+1,y*blocksize,a[i]);
                ans-=tmp*(tmp-1)/2;
                tmp=calc(l,r,a[i]);
                ans+=tmp*(tmp-1)/2;
            }
        }
        for(i=y*blocksize+1;i<=r;++i){
            if(!vis[a[i]]){
                vis[a[i]]=true;
                tmp=calc((x-1)*blocksize+1,y*blocksize,a[i]);
                ans-=tmp*(tmp-1)/2;
                tmp=calc(l,r,a[i]);
                ans+=tmp*(tmp-1)/2;
            }
        }
        for(i=l;i<=min((x-1)*blocksize,r);++i){
            vis[a[i]]=false;
        }
        for(i=y*blocksize+1;i<=r;++i){
            vis[a[i]]=false;
        }
        tmp=gcd(ans,1ll*(r-l+1)*(r-l)/2);
        printf("%lld/%lld\n",ans/tmp,1ll*(r-l+1)*(r-l)/2/tmp);
    }
}
```

---

## 作者：Hzao (赞：12)

看了一下题解里的大佬，好像都用的莫队或者分块维护平方和...

其实用不着维护平方和。

从头开始说吧。

### 求什么
对于每个询问$q$（$q$包含$q.l,q.r$），我们要求出任取两个袜子颜色相同的概率。假设在区间$[l,r]$取到颜色为$i$的袜子的概率为$P(l,r,i)$，那么要求的就是$\sum_{i=1} ^{n} P(q.l,q.r,i)$。
### 怎么求
那么对于任意的$L,R,i$,如何计算$P(L,R,i)$？假设在$[L,R]$内$i$袜子的个数为$n_i$，根据数学知识，要取到两只$i$，首先要取第一只$i$颜色的袜子。因为有$n_i$只袜子都是$i$颜色的，所以取第一只$i$袜子的方案数为$n_i$。然后再取第二只$i$颜色的袜子。由于已经取了1只$i$颜色的袜子，就只剩下$i-1$只可选了。这样的排列数有$n*(n-1)$个。

计算概率时有顺序用排列，无顺序用组合，因为我们只关心两只袜子是否颜色相同，所以这道题中选袜子的顺序是没有影响的。而刚刚计算的只是排列数，每种组合方式被计算了2次（选第1,3只白袜和选第3,1只白袜是一样的）。所以要除以2。
即选到两只$i$颜色的袜子的方案数$n_i(n_i-1)/2.$

在$[L,R]$内，有$R-L+1$只袜子，在这其中选择两只，方案总数为$C_{R-L+1}^2$。（~~都在刷国家集训队的题目了，你应该知道组合数吧....~~ ）

所以$P(L,R,i)=n_i*(n_i-1)/2 C_{R-L+1}^2 .$

答案如前所述，为$\sum_{i=1} ^{n} P(q.l,q.r,i)$
### 怎么优化
1.分块。

如果直接对每个询问区间暴力维护$n_i$，$O(m* k n)$级别的复杂度很显然过不了。（$k$是一个常数。~~其实我不太会分析复杂度所以欢迎dalao指正~~）

以样例为例，(~~话说这个样例不会被敏感词拦截吗~~)

6 4

1 2 3 3 3 2

2 6

1 3

3 5

1 6

![样例图解](https://img.hzao.top/data/题解-1.jpg)

我们发现一些询问都和其它某（几）个询问有重叠部分。那其实，我们可以把有重叠部分的询问分组，先处理每组的第一个询问，然后处理与上一个询问不同的部分。

于是我们可以先按照左端点的大小排序，然后把排序后的队列分成几个小块（一般大小取$\sqrt{m}$）。然后再在每个块内以右端点大小排序。我们就可以以块为单位处理。

虽然左端点的单调性在第二次排序的时候打乱了，但是第一次排序保证了同一个块内相邻两个左端点的变化在$\sqrt{n}$内。第二排序可以保证右端点只有加操作，没有减操作。

2.统计

前面有些大佬提到了维护平方和的办法。但是其实我认为有更好的办法（每次修改三行代码变为一行）。
进入每一个块内处理的时候，我们先暴力求出第一组询问的区间内，每个袜子的个数，存在数组$num$里。然后在前一个询问的基础上，对$num$修改。
根据前面的推导，对每个询问$q$,我们要求的是


$\sum_{i=1}^{n}P(q.l,q.r,i)=num_i*(num_i-1)/2 C_{q.r-q.l+1}^2 .$

(C右上角的2不是平方的意思...)


可以看出，同一个询问的分母都是确定的。所以我们现在关心如何通过修改$num$来快速得到分子。


**重点来了**，假设原来的$num_i=x$。

假如我们要对$num_i$执行增加1的操作，那么实际上跟$i$有关的那一部分的分子的变化为：
增加后-增加前=$(x+1)x-x(x-1)=2x.$所以我们直接加上原来$x$的两倍即可。

假如我们要对$num_i$执行减小1的操作，那么实际上$i$这一部分分子的变化为：

减少后-减少前= $ (x-1)(x-2)-x(x-1)=-2(x-1)$，所以我们直接减去减少后的$num_i$的两倍即可。

于是以前的更改代码为：（以增加为例）
```cpp
{

    tot-=num[i]* num[i];
    num[i]++;
    tot+=num[i]* num[i]; 
}
```

现在只需要：
```cpp
{
	tot+=2* num[i]++;
}
```

但是....分母不是还有一个2么，直接约分不就行了...

于是乘以2可以直接省略，得到：
```cpp
{
	tot+=num[i]++;
}
```

[不开O2 363ms](https://www.luogu.org/recordnew/show/19232022)

[开O2 191ms](https://www.luogu.org/recordnew/show/19232190)

可还行。



细节见代码：

```cpp

#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using std::sort;
const int maxn=50000;
struct que
{
	int l,r,id;
}q[maxn+5];
struct blk
{
	int l,r;
}b[333];
int col[maxn+5],num[maxn+5],ans1[maxn+5],ans2[maxn+5],c[maxn+5][3];
//依次保存 颜色，上文中的num数组，分子，分母，组合数
int n,m,bs,bn,tot;
//bs为每个块的大小 bn为块的个数
//排序后可以一边分块一边计算
inline void read(int &x){//快读
	x=0;
	char c;
	do{
		c=getchar();
	}
	while(c<'0'||c>'9');
	do{
		x=x*10+c-'0';
		c=getchar();
	}
	while(c>='0'&&c<='9');
}
inline int min(int a,int b){
	return a<b?a:b;
}
inline int gcd(int a,int b){
	return b?gcd(b,a%b):a;
}
inline bool cmpl(que a,que b){//以l排序
	return a.l<b.l;
}
inline bool cmpr(que a,que b){//以r排序
	return a.r<b.r;
}
inline void pre(){//计算组合数
	c[1][0]=c[1][1]=1;
	for(register int i=2,j;i<=n;++i){
		c[i][0]=1;
		for(j=1;j<=2;++j){
			c[i][j]=c[i-1][j-1]+c[i-1][j];
		}
	}
}
int main(){
	read(n);
	read(m);
	pre();
	for(register int i=1;i<=n;++i){
		read(col[i]);
	}
	for(register int i=1;i<=m;++i){
		read(q[i].l);
		read(q[i].r);
		q[i].id=i;
	}
	bs=sqrt(m);
	sort(q+1,q+1+m,cmpl);
    //整体按l排序，保证每个块内左端点的变化不会太大
	for(register int i=1,g;i<=m;i+=bs){
    //i为每个块的左边界
		b[++bn].l=i;
		b[bn].r=min(i+bs-1,m);
		sort(q+i,q+b[bn].r+1,cmpr);//块内按右端点排序 以免右边反复无用增减 					
        memset(num,0,sizeof(num));
		tot=0;//分子
        //先处理这个块里的第一个询问
		for(register int j=q[b[bn].l].l;j<=q[b[bn].l].r;++j){
			tot+=num[col[j]]++;
		}
		ans1[q[b[bn].l].id]=tot;
		ans2[q[b[bn].l].id]=c[q[b[bn].l].r-q[b[bn].l].l+1][2];
        //分母无需再乘以二，因为分子计算的时候省略了二
		if(ans1[q[b[bn].l].id]==0)ans2[q[b[bn].l].id]=1;
		else {
			 	g=gcd(tot,ans2[q[b[bn].l].id]);
			 	ans1[q[b[bn].l].id]/=g;
			 	ans2[q[b[bn].l].id]/=g;
		 }
         
         //在前面的基础上，处理块内其他询问
		for(register int k,j=b[bn].l+1;j<=b[bn].r;++j){
			 if(q[j-1].l<q[j].l){//处理这一次询问少了的部分（复原）
				 for(k=q[j-1].l;k<q[j].l;++k){
				 	tot-=--num[col[k]];
                    //注意运算符在前（根据推导，这里使用减少后的值）
				 }
			 }
			 else {
			 	for(k=q[j].l;k<q[j-1].l;++k){//处理这一次询问多出来的部分
			 		tot+=num[col[k]]++;
                    //注意运算符在后（根据推导，这里使用增加前的值）
			 	}
			 }
             
			 for(k=q[j-1].r+1;k<=q[j].r;++k){//处理这个询问后面多出来的部分
			 	tot+=num[col[k]]++;
			 }
			 ans1[q[j].id]=tot;
			 ans2[q[j].id]=c[q[j].r-q[j].l+1][2];
			 if(ans1[q[j].id]==0)ans2[q[j].id]=1;
			 else {
			 	g=gcd(tot,ans2[q[j].id]);
			 	ans1[q[j].id]/=g;
			 	ans2[q[j].id]/=g;
			 }
		}
	}
	for(register int i=1;i<=m;++i){
		printf("%d/%d\n",ans1[i],ans2[i]);
	}
	// system("pause");
	return 0;
}
```
[祝AC..](https://blog.hzao.top) (突然发现这篇题解的文字刚好233行)

---

## 作者：oyblxzd (赞：7)

感觉其他大佬的题解都写了一堆高级的算式，本蒟蒻看着头大啊……

其他的东西各位大佬已经阐明。我这里主要讲一下关于指针移动时，抽中两只同色的组合答案sum的更新。

在减少或增加某一种颜色的数量时，该颜色组合的情况会改变。而本蒟蒻想到了小学学习的**握手问题**，或**数线段问题**![是不是很辣鸡](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1566483413648&di=c4cb5408666fab3f6c4cefbab5945a12&imgtype=0&src=http%3A%2F%2Ffiles.eduuu.com%2Fimg%2F2017%2F08%2F03%2F141553_5982bf9939dab.jpg)~~是不是很辣鸡~~

对于4个数（袜子颜色）：6 6 6 6，它们两两的组合有3+2+1=6种。![](https://cdn.luogu.com.cn/upload/pic/74118.png)

当增加一个相同颜色6时，组合数量增加了4种，成为10种
![](https://cdn.luogu.com.cn/upload/pic/74120.png)

当减少一个相同颜色6时，组合数量减少了3种，成为3种
![](https://cdn.luogu.com.cn/upload/pic/74124.png)

### 所以当增加一种颜色的数量时，组合数统计答案sum加上该颜色原有的数量。即
```c
void add(ll x)
{
	sum+=cnt[num[x]];
	++cnt[num[x]];
}
```

### 减少一种颜色的数量时，统计答案sum减去该颜色原有数量减一（先执行减一操作）。即
```c
void del(ll x)
{
	--cnt[num[x]];
	sum-=cnt[num[x]];
}
```
其他的部分参照普通莫队

### ~~辣鸡却易懂的~~代码：

```c
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll maxn=50005;
ll n,m,len,sum;
ll num[maxn],be[maxn],cnt[maxn],tot[maxn];

struct node
{
	ll l,r,id;
}q[maxn],ans[maxn];

bool cmp(node a,node b)
{
	return be[a.l]==be[b.l] ? a.r<b.r : be[a.l]<be[b.l];
}

void add(ll x)
{
	sum+=cnt[num[x]];
	++cnt[num[x]];
}

void del(ll x)
{
	--cnt[num[x]];
	sum-=cnt[num[x]];
}

ll gcd(ll x,ll y)
{
	return y==0 ? x : gcd(y,x%y);
}

int main()
{
	//freopen("input.txt","r",stdin);
	//freopen("output.txt","w",stdout);
	scanf("%lld%lld",&n,&m);
	len=sqrt(n);
	for(ll i=1;i<=n;i++)
	{
		scanf("%lld",&num[i]);
		be[i]=(i-1)/len+1;
	}
	for(ll i=1;i<=m;i++)
	{
		scanf("%lld%lld",&q[i].l,&q[i].r);
		q[i].id=i;
	}
	sort(q+1,q+m+1,cmp);
	ll l=1,r=0;
	for(ll i=1;i<=m;i++)
	{
		ll ql=q[i].l,qr=q[i].r;
		while(l<ql) del(l++);
		while(l>ql) add(--l);
		while(r<qr) add(++r);
		while(r>qr) del(r--);
		ll div=((qr-ql+1)*(qr-ql+1)-(qr-ql+1))/2,fac=1;
		if(sum) fac=gcd(sum,div);
		else div=1;
		ans[q[i].id].l=sum/fac,ans[q[i].id].r=div/fac;
	}
	for(ll i=1;i<=m;i++) printf("%lld/%lld\n",ans[i].l,ans[i].r);
	return 0;
 } 
```
## 感谢观看

---

## 作者：shuiyuhan (赞：6)

这是蒟蒻第一次做集训队的题，终于把它切了......

这题似乎没有pascal的题解哦~我来水一发

感觉这是一道神奇的莫队啊

Q：什么是莫队

A:莫队是前集训队莫涛队长发明的一种算法，用来处理许多区间问题，本质上就是暴力的优化，~~(又称优雅的暴力)~~其基本思想是分块(有关分块请baidu）,是一个离线算法

而这道题是对于初学者来说比较良心的题。

题目大意：给一列袜子的颜色，求区间[l,r]内随机选两个袜子的概率

题目分析：对某个区间[l,r],它的概率是(c[i]*c[i-1]/2)/((r-l+1)*(r-l)/2)(1<=i<=n),其中c[i]表示在[l,r]内颜色i的出现次数。

可发现如果c[i]加1，那么ans加原来的c[i]，反之，ans减当前的c[i]
所以用桶维护c数组

代码(里面有注释)
```pascal
var
  n,k,m,l,r,j,p,t,xx,ans:int64;
  i:longint;
  a,x,y,c,b,f,f1:array[0..500005] of longint;
  procedure sort(l,r:longint);//库里自带的快排
做了些小改动。(这点p真的比不上c++的STL)
      var
         i,j,xx,yy,yyy:longint;
      begin
         i:=l;
         j:=r;
         xx:=x[(l+r) div 2];
         yy:=y[(l+r) div 2];
         repeat
           if i div p=j div p then//判断i，j是否在同一块内
           begin
           while (x[i]<xx) do
            inc(i);
           while (xx<x[j]) do
            dec(j);
           if not(i>j) then//别忘记交换3个而不是1个数组
             begin
                yyy:=x[i];
                x[i]:=x[j];
                x[j]:=yyy;
                yyy:=y[i];
                y[i]:=y[j];
                y[j]:=yyy;
                yyy:=c[i];
                c[i]:=c[j];
                c[j]:=yyy;
                inc(i);
                j:=j-1;
             end;
           end else
           begin
             while (y[i]<yy) do
            inc(i);
           while (yy<y[j]) do
            dec(j);
           if not(i>j) then
             begin
                yyy:=x[i];
                x[i]:=x[j];
                x[j]:=yyy;
                yyy:=y[i];
                y[i]:=y[j];
                y[j]:=yyy;
                yyy:=c[i];
                c[i]:=c[j];
                c[j]:=yyy;
                inc(i);
                j:=j-1;
             end;
           end;
         until i>j;
         if l<j then
           sort(l,j);
         if i<r then
           sort(i,r);
      end;
  function gcd(x,y:longint):longint;
  begin
    if x mod y=0 then exit(y);
    exit(gcd(y,x mod y));
  end;
begin
  readln(n,m);
  p:=trunc(sqrt(n));//把序列分成sqrt(n)块
  for i:=1 to n do read(a[i]);
  for i:=1 to m do
  begin
    readln(x[i],y[i]);
    c[i]:=i;//莫队作为离线算法，当然要保存每个询问啦
  end;
  sort(1,m);
  l:=1;
  r:=1;
  ans:=0;
  fillchar(b,sizeof(b),0);
  inc(b[a[1]]);
  for i:=1 to m do//莫队基本思想(本人喜欢while)
  begin
    while l>x[i] do begin dec(l); ans:=ans+b[a[l]];  inc(b[a[l]]);end;
    while r<y[i] do begin inc(r);  ans:=ans+b[a[r]]; inc(b[a[r]]);end;
    while l<x[i] do begin dec(b[a[l]]); ans:=ans-b[a[l]]; inc(l); end;
    while r>y[i] do begin dec(b[a[r]]); ans:=ans-b[a[r]]; dec(r); end//如果c[i]加1，那么ans加原来的c[i]，反之，ans减当前的c[i]
    f[c[i]]:=ans;
    f1[c[i]]:=r-l+1;//f1表示(r-l+1)的值
  end;
  for i:=1 to m do
  begin
    if f[i]=0 then writeln('0/1');//别忘了题目的特殊情况
    if f[i]<>0 then
    begin
      t:=f1[i];
      xx:=gcd(f[i],t*(t-1)>>1);//题目要求gcd
      writeln(f[i] div xx,'/',t*(t-1) div xx>>1);//经实测>>和<<要快于div和*
    end;
  end;
end.
``` 






---

## 作者：Manjusaka丶梦寒 (赞：6)

[博客提供更好的阅读体验](https://www.cnblogs.com/rmy020718/p/9439859.html)

这算的上是不带修改的莫队里边比较经典，也比较难的一道题了。

L=R的情况就不过多考虑了。

首先明确概率的计算方式，设总数为sum，其中数字a有C[a]种，那么a的几率就为C[a]/sum*(C[a]-1)/(sum-1).

要求化简为最简分数，那么我们可以先让所有数的几率都以sum*(sum-1)为底。

那么我们现在只需要计算每种数字的 种类数*(种类数-1) 就可以了。

这题基本思想和 小B的询问 差不多，新加入或删除的数字，在答案中减去过去的贡献，加上现在所含的贡献。

例如：

序列中现已找到C[a]个a数，那么现在a这一类数对于答案的贡献为C[a]*(C[a]-1).

那么如果再次加入一个a，那么则需要减掉C[a]*(C[a]-1)，加上C[a]*(C[a]+1),这个式子化简以下的话可以当做加上2*C[a],删除同理。

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#define N int(5e4+2)
#define M int(5e4+2)
#define LL long long
using namespace std;
struct ahah{
    LL L,R,p,f;
}ask[N];
struct haha{
    LL math_numerator,math_denominator;    //分子,分母。 
}ans[N];
LL answer,n,m,q,a[N],cnt[N],k,_;
LL gcd(LL a,LL b){  return !b?a:gcd(b,a%b); }
bool comp(ahah a,ahah b){ return a.L/k==b.L/k?a.R<b.R:a.L<b.L; }
void remove(LL pos){ if(--cnt[a[pos]]>0)answer+=(-2)*(cnt[a[pos]]);}
void add(LL pos){ if(++cnt[a[pos]]>1)answer+=2*(cnt[a[pos]]-1); }
void work(LL x,LL y,LL p)
{
    if(!x)ans[p].math_numerator=0,ans[p].math_denominator=1;
    else 
    {
        LL k=gcd(x,y);
        ans[p].math_numerator=x/k;
        ans[p].math_denominator=y/k;
    }
}
int main()
{
    scanf("%lld%lld",&n,&q);
    k=sqrt(n); 
    for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
    for(int i=1;i<=q;i++)scanf("%lld%lld",&ask[i].L,&ask[i].R),ask[i].p=i;
    sort(ask+1,ask+1+q,comp);
    LL curl=0,curr=0;    //注意这里定义long long 不然下边会可能爆 
    for(int i=1;i<=q;i++)
    {
        LL L=ask[i].L,R=ask[i].R;
        if(L==R)
        {
            ans[ask[i].p].math_numerator=0;
            ans[ask[i].p].math_denominator=1;
            continue;
        }
        while(curl<L)remove(curl++);
        while(curl>L)add(--curl);
        while(curr<R)add(++curr);
        while(curr>R)remove(curr--);
        work(answer,(R-L+1)*(R-L),ask[i].p);    // <---- 
    }
    for(int i=1;i<=q;i++)printf("%lld/%lld\n",ans[i].math_numerator,ans[i].math_denominator);
}
```

---

## 作者：孑彧 (赞：5)

# P1494 小Z的袜子 解题报告

### 题意描述

作为一个生活散漫的人，小Z每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命……

具体来说，小Z把这N只袜子从1到N编号，然后从编号L到R(L 尽管小Z并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。

你的任务便是告诉小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个(L,R)以方便自己选择。

**然而数据中有L=R的情况，请特判这种情况，输出0/1。**

### 思路

我们先思考这么一个问题，如果当前总共有$n$只袜子，第$i$种颜色有$a_i$只，总共有$k$种颜色，那么我们随便抽两只的概率就是
$$
\frac{\sum_{i=1}^{k}\frac{a_i\times (a_i-1)}{2}}{\frac{n\times(n-1)}{2}}
$$
然后我们将这个式子化简后可以得到
$$
\frac{\sum_{i=1}^{k}a_i^2-\sum_{i=1}^{k}a_i}{n\times(n-1)}
$$
又因为
$$
\sum_{i=1}^{k}a_i=n
$$
所以上式即为
$$
\frac{\sum_{i=1}^{k}a_i^2-n}{n\times(n-1)}
$$
接下来我们将这个问题放到一个区间上去考虑

假设我们现在要求的是$[l,r]$区间内的问题，当前袜子总数为$r-l+1$,式子变为
$$
\frac{\sum_{i=1}^{k}a_i^2-(r-l+1)}{(r-l+1)\times(r-l)}
$$
我们只需要维护这个区间内每种颜色的袜子所出现次数的平方和就好了

接下来就是一个莫队的裸题了

可以去看看[这道题](https://hybjzzq.blog.luogu.org/p2709-xiao-b-di-xun-wen-xie-ti-bao-gao)

也是要维护一个出现次数的平方和

然后就可以愉快的用莫队水掉了

但是一定要注意要特判$l=r$的时候和概率为$0$的时候

要不然就会WA前9个点

### 代码

```c++
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#define LL long long
#define maxn 55000
using namespace std;
LL c[maxn],cnt[maxn],ans;
LL n,m,k,len;
LL num[maxn],sum[maxn];
inline LL gcd(LL a,LL b){
	while(a^=b^=a^=b%=a);
	return b;
}
inline LL read(){
	LL x=0,t=1;
    char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-'){t=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
    return x*t;
}
inline void write(LL x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9){
		write(x/10);
	}
	putchar(x%10+'0');
}
struct Query{
	LL l,r,in,id;
	inline bool operator < (const Query &a)const{
		if(!(in^a.in)){
			return (in&1)?r<a.r:r>a.r;
		}
		return in<a.in;
	}
}q[maxn];//奇偶性优化
inline void ins(LL x){
	ans-=cnt[c[x]]*cnt[c[x]];
	cnt[c[x]]++;
	ans+=cnt[c[x]]*cnt[c[x]];
}
inline void del(LL x){
	ans-=cnt[c[x]]*cnt[c[x]];
	cnt[c[x]]--;
	ans+=cnt[c[x]]*cnt[c[x]];
} 
int main(){
	n=read();
	m=read();
	len=sqrt(n);//这个长度不一定是最优的，可能有其他更优的分块方案
	for(LL i=1;i<=n;++i){
		c[i]=read();
	//	cout<<i<<endl;
	}
	LL x,y;
	for(LL i=1;i<=m;++i){
		x=read();
		y=read();
		q[i].l=x;
		q[i].r=y;
		q[i].in=(x-1)/len+1;
		q[i].id=i;
	//	cout<<i<<endl;
	}
	sort(q+1,q+1+m);
	LL l=1,r=0;
	for(LL i=1;i<=m;++i){
		x=q[i].l;
		y=q[i].r;
		if(x==y){
			num[q[i].id]=0;
			sum[q[i].id]=1;
			continue;
		}
		while(l<x)del(l),++l;
		while(l>x)ins(l-1),--l;
		while(r<y)ins(r+1),++r;
		while(r>y)del(r),--r;
		if(ans==y-x+1){
			num[q[i].id]=0;
			sum[q[i].id]=1;
			continue;
		}
		num[q[i].id]=ans-(y-x+1);
		sum[q[i].id]=(y-x+1)*(y-x);
		LL g=gcd(sum[q[i].id],num[q[i].id]);//约分
		num[q[i].id]/=g;
		sum[q[i].id]/=g;
	}
	for(LL i=1;i<=m;++i){
		printf("%lld/%lld",num[i],sum[i]);
		printf("\n");
	}
	return 0;
}
```



---

## 作者：hsfzLZH1 (赞：4)

## 题目大意

给定一个长度为 $n$ 的数组 $c_i$ ，$m$ 次询问，每次询问给出区间 $[l,r]$ ，求

$\sum_{c=1}^n (\sum_{i=l}^r [c_i=c])\times ((\sum_{i=l}^r [c_i=c])-1)$

的值。

$n,m,c_i\le 50000,1\le l,r\le 50000$

## 解题思路

据说要用莫队，莫队是什么啊QWQ

考虑暴力做法，我们维护一个数组 $cnt[i]=\sum_{i=l}^r [c_i=i]$ ，所求的答案即为 $ans=\sum_{i=1}^n cnt[i]\times (cnt[i]-1)$ ，我们遍历 $c_{[l,r]}$ 的所有值，维护对应的 $cnt$ 值，只要我们同时正确维护 $ans$ 的值，这就是所求答案。但是这样的时间复杂度是 $O(nm)$ 的，需要使用一种 **对询问进行分块** 的方法进行优化。

首先我们将询问离线，按照左端点 $l$ 从小到大排序，然后将其按照某种方法分成若干段。这里我们假设将第一次排序后的询问分成 $l$ 的取值范围分别在 $[1,siz],[siz+1,2siz],...,[x\times siz+1,n]$ 的若干段。

对于每一段，我们在其内部按右端点 $r$ 排序，排序后我们将其中的第一个询问暴力处理，统计出 $cnt$ 数组，对于之后的询问，在其上一个询问的 $cnt$ 数组基础上进行小调整，也是暴力处理左右边不同的地方，在维护 $cnt$ 数组的同时维护 $ans$ 的值，从而求出对于每个询问的答案。

时间复杂度分析。排序预处理是 $O(n\log_2 n)$ 的。我们将所有询问分成了至多 $\frac n {siz}$ 段，在每一段中我们用 $O(n)$ 的时间复杂度处理了第一个询问，之后的小调整，左端点的变化范围始终在 $O(siz)$ 内，所有询问的左端点调整范围的总时间复杂度为 $O(q\times siz)$ ，右端点由于排序是单调递增的，单段总的时间复杂度也是 $O(n)$ 的。所以整个算法的时间复杂度是 $O(n\log_2 n+\frac {n^2} {siz}+q\times siz)$ 的，鉴于 $n,q$ 同阶，当 $siz=\sqrt n$ 时，时间复杂度最优，为 $O(n\sqrt n)$ 。

## 代码展示

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cstdlib>
#define int long long
using namespace std;
const int maxn=50010;
int gcd(int x,int y){return (x%y)?gcd(y,x%y):y;}
int n,m,a[maxn],cnt[maxn],tot,siz,l,r,blk,ans1[maxn],ans2[maxn],t;
struct query
{
	int id,l,r;
}q[maxn];
bool cmp1(query x,query y){return x.l<y.l;}
bool cmp2(query x,query y){return x.r<y.r;}
main()
{
	scanf("%lld%lld",&n,&m);siz=(int)sqrt((double)n)+1;
	for(int i=1;i<=n;i++)scanf("%lld",a+i);
	for(int i=1;i<=m;i++)
	{
		scanf("%lld%lld",&q[i].l,&q[i].r);
		q[i].id=i;
		ans2[i]=(q[i].r-q[i].l+1)*(q[i].r-q[i].l);
	}
	sort(q+1,q+m+1,cmp1);
	l=1;r=0;blk=1;
	while(l!=n+1)
	{
		if(r==n||(q[r+1].l>blk*siz))
		{
			if(l<=r)
			{
				tot=0;
				for(int i=1;i<=n;i++)cnt[i]=0;
				sort(q+l,q+r+1,cmp2);
				for(int i=l;i<=r;i++)
				{
					if(i==l)for(int j=q[i].l;j<=q[i].r;j++)tot-=cnt[a[j]]*(cnt[a[j]]-1),cnt[a[j]]++,tot+=cnt[a[j]]*(cnt[a[j]]-1);
					else
					{
						for(int j=q[i-1].r+1;j<=q[i].r;j++)tot-=cnt[a[j]]*(cnt[a[j]]-1),cnt[a[j]]++,tot+=cnt[a[j]]*(cnt[a[j]]-1);
						if(q[i-1].l<q[i].l)for(int j=q[i-1].l;j<=q[i].l-1;j++)tot-=cnt[a[j]]*(cnt[a[j]]-1),cnt[a[j]]--,tot+=cnt[a[j]]*(cnt[a[j]]-1);
						else for(int j=q[i].l;j<=q[i-1].l-1;j++)tot-=cnt[a[j]]*(cnt[a[j]]-1),cnt[a[j]]++,tot+=cnt[a[j]]*(cnt[a[j]]-1);
					}
					ans1[q[i].id]=tot;
				}
			}
			l=r+1;blk++;
		}
		else r++;
	}
	for(int i=1;i<=m;i++)
	{
		if(!ans1[i])printf("0/1\n");
		else{t=gcd(ans1[i],ans2[i]);printf("%lld/%lld\n",ans1[i]/t,ans2[i]/t);}
	}
	return 0;
}
```


---

## 作者：Chester1011 (赞：3)

作为一个生活散漫的人，本蒟蒻每天早上都要耗费很久从一堆令人崩溃的入门题中找出一个有能力写的。终于有一天，本蒟蒻再也无法忍受这恼人的找题过程，于是他决定发布题解……                       ——背景请无视


本蒟蒻接受了标签的馈赠，选择了**莫队**来AC此题。

### 众所周知，莫队是一种~~玄学毒瘤暴力骗分~~区间操作算法……

算了，不废话了，切入正题，本题就是求区间内能互相匹配的颜色相同的袜子的数量，所以就可以用莫队~~暴力而又不失优雅~~的水过这题了。

在枚举左右区间时，每遇见一只颜色~~花里胡哨~~的袜子时，只要加上或减去之前枚举的相同颜色的袜子的数量就好了，因为这只袜子可以和之前所有的袜子进行配对。而分母大家应该都想的出来，设区间袜子总数为X，分母就为X(X-1)/2，然后分子分母同时除以它们的最大公约数就是答案了。
# 话不多说，手起，码落：
```cpp
#include<bits/stdc++.h>
#define belongto(x) ((x-1)/q+1)//求编号为x的袜子所在块
using namespace std;
struct mode
{
	int l,r,i,FZ;
	long long FM;
} e[500005];
int n,m,k,a[500005],l=1,r,cnt[500005],q,fz;
bool cmp(mode a,mode b)
{
	return belongto(a.l)==belongto(b.l)?a.r>b.r:belongto(a.l)<belongto(b.l);
	//按左区间边界所在块进行排序，如果相同则按右区间从大到小进行排序 
}
void add(int x)
{
	int p=++cnt[a[x]];
	fz+=p-1;
}
void delet(int x)
{
	int p=--cnt[a[x]];
	fz-=p;
}
bool cmb(mode a,mode b)
{
	return a.i<b.i;
}
int main()
{
	scanf("%d%d",&n,&m);
	q=n/sqrt(n*2/3);//大佬说这样快，本蒟蒻也不知道为啥QWQ 
	for(int i=1; i<=n; i++)scanf("%d",&a[i]);
	for(int i=1; i<=m; i++)scanf("%d%d",&e[i].l,&e[i].r),e[i].i=i;
	sort(e+1,e+m+1,cmp);
	for(int i=1; i<=m; i++)
	{
		while(r<e[i].r)add(++r);
		while(r>e[i].r)delet(r--);
		while(l<e[i].l)delet(l++);
		while(l>e[i].l)add(--l);
		//莫队标准操作 
		e[i].fz=fz;
		long long mid=e[i].r-e[i].l+1;
		e[i].fm=mid*(mid-1)/2;
	}
	sort(e+1,e+m+1,cmb);
	for(int i=1;i<=m;i++)
	{
		if(e[i].fz==0)printf("0/1\n");
		else 
		{
			int GCD=__gcd((long long)e[i].fz,e[i].fm);
			printf("%d/%lld\n",e[i].fz/GCD,e[i].fm/GCD);
		}
	}
	return 0;
}
```


---

## 作者：George1123 (赞：3)

[${\color{orange}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/wzc-wwwwd/)

[P1494 【小Z的袜子】传送门](https://www.luogu.org/problem/P1494)

### 此题算法:普通莫队

区间移动公式:

因为每种袜子有$n+1$只时比只有$n$只时

由于这只新袜子也可以与之前每一只匹配

所以会多出$cnt[typ]$种匹配方法

少掉一只袜子也同理
```cpp
void add(int typ){
	res+=(cnt[typ]++);
} void del(int typ){
	res-=(--cnt[typ]);
}
```
每个询问的答案可分为两点，分子和分母

分子等于当前答案$res$,

分母为询问的$\frac{(L-R)\times (L-R+1)}{2}$

但是国家集训队的题少不了坑人点

$n\leq 50000$ 分母正好爆$int$

所以分子分母必须开个$long$ $long$

```cpp

#include <bits/stdc++.h>
using namespace std;
#define maxn 1000000
#define ong long long
ong gcd(ong x,ong y){
	if(x==0) return y;
	return gcd(y%x,x);
} //化简分数
struct Mo{
	int l,r,D;
	ong ans,fm;
	void print(){
		if(ans==0||l==r){
			printf("0/1\n");
			return;
			//特判
		} int gc=gcd(ans,fm);
		printf("%lld/%lld\n",
		ans/gc,fm/gc);
	}
} query[maxn+10];
int a[maxn+10],b[maxn+10];
int n,m,L,R,sqr,tot;
int cas[maxn+10],cnt[maxn+10];
ong res;
bool CmpMo(const Mo &x,const Mo &y){
	if(cas[x.l]!=cas[y.l])
		return cas[x.l]<cas[y.l];
	if(cas[x.l]&1) return x.r<y.r;
	return y.r<x.r; 
	//值得一试的奇偶优化
} bool CmpFd(const Mo &x,const Mo &y){
	return x.D<y.D;
} int find(int x){
	int lf=1,rf=tot,mid;
	while(lf<=rf){
		mid=lf+rf>>1;
		if(b[mid]==x)
			return mid;
		if(b[mid]<x)
			lf=mid+1;
		else rf=mid-1;
	}
} //离散化必备函数
void add(int typ){
	res+=(cnt[typ]++);
} void del(int typ){
	res-=(--cnt[typ]);
} //重点区间移动，大部分莫队题改这里就都过了
int main(){
	scanf("%d%d",&n,&m);
	sqr=(int)sqrt(n);
	for(int i=1;i<=n;i++){
		scanf("%d",a+i);
		b[i]=a[i];
		cas[i]=(i-1)/sqr+1;
	} sort(b+1,b+n+1);
	tot=unique(b+1,b+n+1)-b-1;//离散化
	for(int i=1;i<=m;i++){
		scanf("%d%d",
		&query[i].l,
		&query[i].r);
		query[i].D=i;
	} sort(query+1,query+m+1,CmpMo);
	L=query[1].l; R=query[1].r;
	for(int i=L;i<=R;i++) add(a[i]);
	query[1].ans=res;
	query[1].fm=1LL*(R-L)*(R-L+1)/2;
	//计算分子、分母
	for(int i=2;i<=m;i++){
		while(L>query[i].l)
			add(a[--L]);
		while(L<query[i].l)
			del(a[L++]);
		while(R<query[i].r)
			add(a[++R]);
		while(R>query[i].r)
			del(a[R--]);
		query[i].ans=res;
		query[i].fm=1LL*(R-L)*(R-L+1)/2;
		//计算分子、分母
	} sort(query+1,query+m+1,CmpFd);
	for(int i=1;i<=m;i++)
		query[i].print();
	return 0;
}
```

谢谢大家 ! !





---

## 作者：Gypsophila (赞：3)

### Description

$m$ 个询问，每次给出一个区间，求从这个区间中取出两个数使得它们同色的概率。

$n,m,a_i \leq 50000$

### Solution

莫队模板题

最后的概率是 选的颜色相同的方案数 / 区间长度 * (区间长度 - 1)，显然，只需要维护方案数。

问题化为知道 $[l,r]$ 的情况下，如何快速算出 $[l \pm 1, r], [l, r \pm 1]$ 的方案数

如果加入一个数 $x$，则方案数增加了 $cnt_x * (cnt_x+1) - cnt_x * (cnt_x-1) = 2 * cnt_x $ 

如果删除一个数 $x$，则方案数减少了 $cnt_x * (cnt_x - 1) - (cnt_x - 1) * (cnt_x - 2) = 2 * (cnt_x-1)$

其中 $cnt_x$ 表示 $x$ 出现的次数。然后就做完了（

注意特判 $l = r$（

### Code 

[看代码戳这里](https://www.cnblogs.com/acfunction/p/10161536.html )

---

## 作者：MatrixGroup (赞：3)

题意：有长度为 $N$ 的序列 $A$，$M$ 次询问在 $[L,R]$ 中随机选两个**不在同一位置**的数值相等的概率。

$N,M,A_i\le 5\times10^4$，时限 200ms。

解法：以下假设 $N,M$ 同阶。

显然只需要计算区间内有多少**对**相等的值。

考虑根号分治。考虑对出现次数的多少分类讨论。

- $A_i$ 出现了至少 $\sqrt N$ 次。这样的**值** $A_i$ 最多有 $\sqrt N$ 个。对于每个这样的值，维护它的前缀和数组，每次询问对于每个这样的值查询其出现次数 $c$，将 $\dfrac{c(c-1)}{2}$ 累加到答案中即可。复杂度 $O(N\sqrt N)$。
- $A_i$ 出现了不到 $\sqrt N$ 次。这样的相等**对**数 $(A_L,A_R)$ 不超过 $N\sqrt N$。我们将询问按照 $R$ 排序，遍历到 $R$ 时将所有的 $L$ 的权值加 $1$。这样，询问 $[L,R]$ 的权值就是 $[L,R]$ 内所有数权值的和。长度为 $N$ 的数组，$O(N\sqrt N)$ 次单点修改，$O(N)$ 次区间和，可以使用分块维护。复杂度 $O(N\sqrt N)$。

综上，复杂度 $O(N\sqrt N)$。

主要代码：

```cpp
const int N=244;
struct fenwick{
	int a[50005];
	int s[N];
	void add(int id)
	{
		++a[id];
		++s[(id-1)/N];
	}
	int sum(int id)
	{
		int v=0;
		rep(j,id/N)
		{
			v+=s[j];
		}
		rep(j,id%N)
		{
			v+=a[id-j];
		}
		return v;
	}
};
fenwick tree;
int main()
{
	cin>>n>>m;
	rep1(i,n)
	{
		cin>>v[i];pos[v[i]].pb(i);
	}
	rep1(i,50000)
	{
		if(pos[i].size()>=N)
		{
			fl[i]=1;special.pb(i);
		}
		else fl[i]=0;
	}
	rep(i,special.size()) sp_sum[0].pb(0);
	rep1(i,n)
	{
		rep(j,special.size())
		{
			sp_sum[i].pb(sp_sum[i-1][j]+(v[i]==special[j]));
		}
	}
	rep1(i,m)
	{
		cin>>l[i]>>r[i];ids[r[i]].pb(i);
	}
	rep1(i,n)
	{
		if(!fl[v[i]])
		{
			rep(j,pos[v[i]].size())
			{
				int x=pos[v[i]][j];
				if(x<i)
				{
					tree.add(x);
				}
			}
		}
		ll t=tree.sum(i);
		rep(j,ids[i].size())
		{
			int x=ids[i][j];
			int L=l[x];
			a[x]=t-tree.sum(L-1);
			rep(k,special.size())
			{
				ll t=sp_sum[i][k]-sp_sum[L-1][k];
				a[x]+=t*(t-1)/2;
			}
			b[x]=(i-L+1ll)*(i-L)/2;
			if(b[x]==0) b[x]=1;
			else
			{
				ll d=mygcd(a[x],b[x]);
				a[x]/=d;b[x]/=d;
			}
		}
	}
	rep1(i,m) cout<<a[i]<<'/'<<b[i]<<endl;
	return 0;
}

---

## 作者：MloVtry (赞：3)

莫队模板题


统计一个每种个数就完了

唯一的稍微有点难的地方就是组合数统计个数？

代码
    
        
        
```cpp
#define ll long long
#include<algorithm>
#include<iostream>
#include<cstdio>
#define N 100010
#include<cmath>
using namespace std;
struct node
{
    ll id,l,r,z,m;
}ask[N];
ll num[200010],n,block;
ll a[N],q,tot;
bool comp(node aa,node bb)
{
    if(aa.l/block==bb.l/block)
    {
        return aa.r<bb.r;
    }
    return aa.l/block<bb.l/block;
}
bool cmp(node aa,node bb)
{
    return aa.id<bb.id;
}
void add(ll nu)
{
    ll pa=num[nu];
    num[nu]++;
    ll no=num[nu];
    tot-=pa*(pa-1)/2;
    tot+=no*(no-1)/2;
}
void pop(ll nu)
{
    ll pa=num[nu];
    num[nu]--;
    ll no=num[nu];
    tot-=pa*(pa-1)/2;
    tot+=no*(no-1)/2;
}
ll gcd(ll a,ll b)
{
    return b==0?a:gcd(b,a%b);
}
int main()
{
    scanf("%lld",&n);
    scanf("%lld",&q);
    block=sqrt(n);
    for(ll i=1;i<=n;++i) scanf("%lld",&a[i]);
    for(ll i=1;i<=q;++i)
    {
        scanf("%lld%lld",&ask[i].l,&ask[i].r);
        ask[i].id=i;
    }
    sort(ask+1,ask+q+1,comp);
    for(ll i=ask[1].l;i<=ask[1].r;++i) add(a[i]);
    ask[1].z=tot;
    ll s=(ask[1].r-ask[1].l+1);
    ask[1].m=s*(s-1)/2;
    if(ask[1].z==0) ask[1].m=1;
    else 
    {
        ll it=gcd(ask[1].z,ask[1].m);
        ask[1].z/=it;
        ask[1].m/=it;
    }
    ll L=ask[1].l,R=ask[1].r;
    for(ll i=2;i<=q;++i)
    {
        while(R<ask[i].r) add(a[++R]);
        while(R>ask[i].r) pop(a[R--]);
        while(L>ask[i].l) add(a[--L]);
        while(L<ask[i].l) pop(a[L++]);
        ask[i].z=tot;
        ll s=(R-L+1);
        ask[i].m=s*(s-1)/2;
        if(ask[i].z==0) ask[i].m=1;
        else 
        {
            ll it=gcd(ask[i].z,ask[i].m);
            ask[i].z/=it;
            ask[i].m/=it;
        }
    }
    sort(ask+1,ask+q+1,cmp);
    for(ll i=1;i<=q;++i)
    printf("%lld/%lld\n",ask[i].z,ask[i].m);
    return 0;
}
```

---

## 作者：Agakiss (赞：2)

### Description
[[国家集训队]小Z的袜子](https://www.luogu.org/problem/P1494)
### Solution
又水了一道莫队题（练练手感）

对于询问，以左端点的块为第一关键字，右端点为第二关键字排序

用一个cnt数组储存从l到r这段区间中的各个颜色的数量

通过不断加减维护$\sum^{m}_{i=1} \frac{cnt[color_i]*(cnt[color_i]-1)}{2}$

和$\frac{(q[i].len)\ast (q[i].len-1)}{2}$除一个gcd就可以了
### Code
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
#define ll long long
#define MAXN 500005
struct rec {
	ll l, r, num, base, x, y;
} q[MAXN];
ll n, m, BASE, l, r, ans;
ll c[MAXN], cnt[MAXN];
inline ll read() {
	ll s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}
inline bool cmp1(rec x, rec y) {
	return (x.base == y.base) ? x.r < y.r : x.base < y.base;
}
inline bool cmp2(rec x, rec y) {
	return x.num < y.num;
}
ll gcd(ll x, ll y) {
	return !y ? x : gcd(y, x % y); 
} 
int main() {
	n = read(), m = read();
	BASE = sqrt(n);
	for (register ll i = 1; i <= n; i++)
		c[i] = read();
	for (register ll i = 1; i <= m; i++)
		q[i].l = read(), q[i].r = read(), q[i].num = i, q[i].base = q[i].l / BASE;
	sort(q + 1, q + m + 1, cmp1);
	//cnt[0] = 1;
	l = 1, r = 1, cnt[c[1]]++;
	for (register ll i = 1; i <= m; i++) {
		while (r < q[i].r) {
			r++;
			ans -= cnt[c[r]] * (cnt[c[r]] - 1);
			cnt[c[r]]++;
			ans += cnt[c[r]] * (cnt[c[r]] - 1);
		}
		while (r > q[i].r) {
			ans -= cnt[c[r]] * (cnt[c[r]] - 1);
			cnt[c[r]]--;
			ans += cnt[c[r]] * (cnt[c[r]] - 1);
			r--;
		}
		while (l < q[i].l) {
			ans -= cnt[c[l]] * (cnt[c[l]] - 1);
			cnt[c[l]]--;
			ans += cnt[c[l]] * (cnt[c[l]] - 1);
			l++;
		}
		while (l > q[i].l) {
			l--;
			ans -= cnt[c[l]] * (cnt[c[l]] - 1);
			cnt[c[l]]++;
			ans += cnt[c[l]] * (cnt[c[l]] - 1);
		}
		q[i].x = ans;
		q[i].y = (q[i].r - q[i].l + 1) * (q[i].r - q[i].l);
	}
	sort(q + 1, q + m + 1, cmp2);
	for (register ll i = 1; i <= m; i++)
		if (q[i].l == q[i].r) cout << 0 << "/" << 1 << endl;
		else
			cout << q[i].x / gcd(q[i].x, q[i].y) << "/" << q[i].y / gcd(q[i].x, q[i].y) << endl;
	return 0;
}
```

---

## 作者：lemir3 (赞：2)

[*获得更好的阅读体验*](https://www.lemir3.red/2019/08/01/%E5%A1%94%E5%90%89%E5%B0%94%E4%B9%8C%E6%8B%89%E5%B0%94%E6%9C%BA%E8%BD%A6%E8%BD%A6%E8%BE%86%E5%8E%82P1494-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-%E5%B0%8FZ%E7%9A%84%E8%A2%9C%E5%AD%90%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/)

[*题面*](https://www.luogu.org/problem/P1494)

很容易看出来是莫队的题.

## 题目分析

给出$n$个数和$m$个区间,要求统计任意取出区间内的两个数相等的概率.

概率很好算,只要求出区间内每个数字出现的次数,用次数来求出能取出的方案数,以及整个区间能够取得方案数就可以了.

题目要求通分,用欧几里得算法求$gcd$就可以了.

函数如下:

```cpp
inline lxl gcd(lxl x,lxl y)
{
	return y?gcd(y,x%y):x;
}
```

然后同志们再来考虑如何使用莫队进行统计.

因为是在区间内取出两个数,设某个数字出现的次数为$a$,能够取出的方案数为$b$,根据乘法原理,我们可以得出如下式子:

>$b_1=a\*(a-1)/2$

在删去一个数时,$a$要减上$1$,式子变为:

>$b_2=(a-1)\*(a-2)/2$

展开,可以得出:

>$b_2=b_1-(a-1)$

同理,在加上一个数时,可以得到:

>$b_2=b_1+a$

所以我们就可以写出莫队的转移函数了:

```cpp
inline void delete_(lxl id)
{
	tot[num[id]]--;
	if(tot[num[id]]>0)
	{
		cnt=cnt-tot[num[id]];
	}
}

inline void add(lxl id)
{
	tot[num[id]]++;
	if(tot[num[id]]>1)
	{
		cnt=cnt+(tot[num[id]]-1);
	}
}
```

其他内容也就是一个寻常的莫队了.

## 代码

```cpp
#include "cstdio"
#include "cstring"
#include "algorithm"
#include "cmath"
#include "iostream"

#define lxl long long
#define debug(x) printf("debug:%lld\n",x)

using namespace std;

lxl n,m,len,CurL,CurR,cnt;
lxl tot[500010],num[500010],ans[500010],QLen[500010];

struct QUERY
{
	lxl l,r,id;
}q[50010];

inline bool cmp(QUERY d1,QUERY d2)
{
	return (d1.l/len==d2.l/len)?d1.r<d2.r:d1.l<d2.l;
}

inline lxl clac(lxl);
inline void delete_(lxl);
inline void add(lxl);
inline lxl gcd(lxl,lxl);

signed main(void)
{
//	freopen("testdata.in","r",stdin);
//	freopen("test.out","w",stdout);
	scanf("%lld%lld",&n,&m);
	len=n/sqrt(m*2/3);
	for(lxl _=1;_<=n;_++)
	{
		scanf("%lld",num+_);
	}
	for(lxl _=1;_<=m;_++)
	{
		lxl l,r;
		scanf("%lld%lld",&l,&r);
		QLen[_]=r-l+1;
		q[_].l=l;
		q[_].r=r;
		q[_].id=_;
//		debug(QLen[_]);
	}
	sort(q+1,q+1+m,cmp);
/*	for(lxl _=1;_<=m;_++)
	{
		debug(q[_].id);
	}*/
	CurL=CurR=q[1].l;
	tot[num[CurL]]++;
	for(lxl _=1;_<=m;_++)
	{
		lxl l=q[_].l;
		lxl r=q[_].r;
		lxl IDQuery=q[_].id;
		while(CurL<l)
		{
			delete_(CurL++);
//			debug(CurL);
//			debug(cnt);
		}
		while(CurL>l)
		{
			add(--CurL);
//			debug(CurL);
//			debug(cnt);
		}
		while(CurR<r)
		{
			add(++CurR);
//			debug(CurR);
//			debug(cnt);
		}
		while(CurR>r)
		{
			delete_(CurR--);
//			debug(CurR);
//			debug(cnt);
		}
		ans[IDQuery]=cnt;
	}
	for(lxl _=1;_<=m;_++)
	{
		if(ans[_]==0||QLen[_]==1)
		{
			printf("0/1\n");
			continue;
		}
		lxl len_=QLen[_]*(QLen[_]-1)/2;
		lxl gcd_=gcd(ans[_],len_);
		printf("%lld/%lld\n",ans[_]/gcd_,len_/gcd_);
	}
return 0;
}

/*
inline lxl clac(lxl id)
{
	if(tot[num[id]]==0||tot[num[id]]==1)
	{
		return 0;
	}
return tot[num[id]]*(tot[num[id]]-1)/2;
}
*/

inline void delete_(lxl id)
{
	tot[num[id]]--;
	if(tot[num[id]]>0)
	{
		cnt=cnt-tot[num[id]];
	}
}

inline void add(lxl id)
{
	tot[num[id]]++;
	if(tot[num[id]]>1)
	{
		cnt=cnt+(tot[num[id]]-1);
	}
}

inline lxl gcd(lxl x,lxl y)
{
	return y?gcd(y,x%y):x;
}
```

---

## 作者：Isonan (赞：2)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P1494)

考虑在区间[l,r]中颜色为i的袜子总共有$x_i$只，那么两次都取到i的概率为$$\frac{x_i}{r-l+1}*\frac{x_i-1}{r-l}$$

$$=\frac{x_i^2-x_i}{(r-l+1)*(r-l)}$$

当这段区间中总共有C种颜色时，总概率即为

$$\frac{\sum_{i=1}^{C} x_i^2-\sum_{i=1}^{C} x_i}{(r-l+1)*(r-l)}$$

后面那个$\sum$很明显就是区间中所有袜子的数量和，也就是$r-l+1$

所以需要我们维护的就只有区间每种袜子数量的平方和。

至于用什么算法。。来刷这题的应该都知道吧，就不说了。

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
#define min(X,Y) ((X)<(Y)?(X):(Y))

long long pos[200010],n,m,count[200010],num[200010],block;
long long bl,br,bmid,ans1[200010],ans2[200001],nowans;
long long gcd(long long a,long long b){
	if(!b)return a;
	return gcd(b,a%b);
}
struct point{
    long long l,r,orig;
}q[200010];
bool cmp(point a,point b){return pos[a.l]==pos[b.l] ? a.r<b.r : pos[a.l]<pos[b.l];}
void add(int ind){
	nowans+=count[ind]<<1;
	nowans++;
    count[ind]++;
}
void del(int ind){
	nowans-=count[ind]<<1;
	nowans++;
    count[ind]--;
}
int main(){
    scanf("%d%d",&n,&m);
    block = (int)sqrt(n);
    for(register int i=1;i<=n;i++){
        pos[i]=(i-1)/block+1;
        scanf("%d",num+i);
    }
    for(register int i=1;i<=m;i++)scanf("%lld%lld",&q[i].l,&q[i].r),q[i].orig=i;
    std::sort(q+1,q+m+1,cmp);
    for(register int i=q[1].l;i<=q[1].r;i++)add(num[i]);
    ans1[q[1].orig]=nowans-(q[1].r-q[1].l+1);
    ans2[q[1].orig]=(q[1].r-q[1].l+1)*(q[1].r-q[1].l);
    if(ans1[q[1].orig]==0)ans2[q[1].orig]=1;
    else{
		long long tem=gcd(ans1[q[1].orig],ans2[q[1].orig]);
	    ans1[q[1].orig]/=tem;
	    ans2[q[1].orig]/=tem;
	}
    for(register int i=2;i<=m;i++){
        if(q[i-1].l<q[i].l)for(int j=q[i-1].l;j<q[i].l;j++)del(num[j]);
        else for(int j=q[i].l;j<q[i-1].l;j++)add(num[j]); 
        if(q[i-1].r<q[i].r)for(int j=q[i-1].r+1;j<=q[i].r;j++)add(num[j]);
        else for(int j=q[i].r+1;j<=q[i-1].r;j++)del(num[j]); 
        ans1[q[i].orig]=nowans-(q[i].r-q[i].l+1);
        ans2[q[i].orig]=(q[i].r-q[i].l+1)*(q[i].r-q[i].l);
        if(ans1[q[i].orig]==0)ans2[q[i].orig]=1;
        else{
		    long long tem=gcd(ans1[q[i].orig],ans2[q[i].orig]);
		    ans1[q[i].orig]/=tem;
		    ans2[q[i].orig]/=tem;
		}
    }
    for(register int i=1;i<=m;i++)printf("%lld/%lld\n",ans1[i],ans2[i]);
}
```

---

## 作者：shadowice1984 (赞：2)

这里以这道经典的莫队题目为例，讲解一下莫队算法

### 莫队算法

看起来很玄的莫队算法，其实是优化过的暴力，思路和常见的暴力-分块算法很像--当答案不具有可合并性时，我们最大化各个暴力之间的公共部分，从而做到了n^3/2的可接受复杂度


那么莫队算法适用于什么情形呢？//离线就不说了好吧


一句话：当你可以O(1)或者O(logn)的插入和删除一个点时，莫队算法就可以用了


要讲解莫队的原理的话不妨这样想一想


假设我们知道一个询问区间(l,r)的答案，而我们又想知道(l1,r1)的答案，


并且我们还可以O(1)的得出(l**-1**,r)或(l**+1**,r)或(l,r**+1**)或(l,r**-1**)的答案，


想必此时直接暴力把l加或者减成l1，r加或者减成r1就可以了吧


其实是一个递推的思想在，由一个区间加点删点变化到另一个区间


如果给了m个这样的询问的话，向刚才那样暴力做，极限是n^2的，显然不可接受，所以在这个算法刚提出的时候，是求了一个曼哈顿距离最小生成树，然后按照这棵树的dfs序遍历，就可以做到n^(3/2)的复杂度


然而搞了半天和分块复杂度同阶，我们为什么要这么麻烦。。。


直接分块不就好咯


所以现在通用的办法是，把这个询问分成根号N块，每一个块内，左端点保证在(k\*根号N,(k+1)\*根号N]以内，而在每一块内，又按照右端点排序，在每一个块内，按照上述做法暴力做


那么我们发现，对于一个块来讲，左端点跳来跳去，最大变化是N

所以单次操作左端点变化代价为O(根号N),对于一个块，右端点总代价最坏是O(N)对于每一个点，右端点变化均摊代价也是O(根号N)

所以总代价为O(N^(3/2))

### 本题题解

上面对于莫队算法的讲解已经较为明白了


(看不懂再找别的博客看吧TAT)


那么我们唯一要考虑的就是对这道题如何进行递推


其实概率就是同色组合数/所有组合数


所有组合数(N)\*(N-1)/2


考虑同色组合数，设当前区间同色组合数为N，now\[i]表示在当前区间里的，值为i的元素个数


现在添加一个值为j的元素，则同色组合数增加到N+now\[j]


现在删除一个值为j的元素，则同色组合数增加到N-now\[j]-1


应该很好想吧……不会自己举几个栗子？


然后直接按照莫队算法流程递推就好啦~


上代码~


```C
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cmath>
using namespace std;
typedef long long ll;//记得开 long long！！！！ 
inline ll gcd(ll a,ll b){if(a<b)swap(a,b);while(b){ll c=a%b;a=b;b=c;}return a;}
ll a[50010];int n;int m;
struct query//询问结构体 
{
    int t;ll l;ll r;
    friend bool operator <(query a,query b){return a.r<b.r;}
};vector <query> v[300];
long long ans1[50010];long long ans2[50010];
int bs;int bn;//块数，块的大小 
ll now[50010];//维护当前区间内每个值的出现次数 
int main()
{
    scanf("%d%d",&n,&m);bs=sqrt(n)+1;bn=(n+bs-1)/bs;
    for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
    for(int i=1;i<=m;i++)
    {
        query q;q.t=i;scanf("%lld%lld",&q.l,&q.r);
        if(q.l==q.r){ans2[i]=1;continue;}//特判 
        ans2[i]=((q.r-q.l)*(q.r-q.l+1))/2;
        v[q.l/bs+1].push_back(q);//这里用一个vector维护每一个块 
    }
    for(int i=1;i<=bn;i++)
    {sort(v[i].begin(),v[i].end());}//排序 
    int nowl=1;int nowr=1;ll nowans=0;now[a[1]]=1;//设定初始区间值 
    for(int i=1;i<=bn;i++)
    {
        vector <query>::iterator it;
        for(it=v[i].begin();it!=v[i].end();++it)
        {
            query nowq=*it;
            if(nowr<nowq.r)//然后分情况讨论就好了 
            {
                for(int i=nowr+1;i<=nowq.r;i++)//向右加点 
                {nowans+=now[a[i]];now[a[i]]++;}
            }
            else
            {
                for(int i=nowr;i>nowq.r;i--)//向左删点 
                {now[a[i]]--;nowans-=now[a[i]];}
            }
            nowr=nowq.r;
            if(nowl<nowq.l)
            {
                for(int i=nowl;i<nowq.l;i++)//向右删点 
                {now[a[i]]--;nowans-=now[a[i]];}
            }
            else 
            {
                for(int i=nowl-1;i>=nowq.l;i--)//向右加点 
                {nowans+=now[a[i]];now[a[i]]++;}
            }
            nowl=nowq.l;
            ans1[nowq.t]=nowans;//更新答案 
        }
    }
    for(int i=1;i<=m;i++)//输出答案记得约分 
    {
        if(ans1[i]==0){printf("0/1\n");continue;}
        ll div=gcd(ans1[i],ans2[i]);
        printf("%lld/%lld\n",ans1[i]/div,ans2[i]/div);
    }
    return 0;//拜拜程序~ 
}

```




---

## 作者：杨铠远 (赞：2)

#### 莫队就是套板子
# 但这道题还可以用一种不同的方法维护ans
假设我们当前询问到了区间$[l,r]$，
颜色为$i$的袜子有$t[i]$只，
那么$ans=\sum^{n}_{i=1}t[i]*(t[i]-1)/2$

为什么呢
~~显然啊~~有$x$只当前颜色的袜子
每只袜子可以和另外$x-1$只袜子配对
再除以二排除a对b，b对a的情况

那么
小z赢的概率为$ans/C(r-l+1,2)$
因为总概率为$r-l+1$只袜子中任意拿两只
所以 一个 $/$就可以了
```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;
const int N=50005;
struct pp{
	int l,r,pos,id;
	long long a,b;
}a[N];
int n,m,sq,curL,curR,sum;
int col[N],t[N];
long long c[N][3];
bool cmp(pp x,pp y)
{
	if(x.pos==y.pos)
	{
		return x.r<y.r;
	} 
	return x.l<y.l;
}
bool cmpp(pp x,pp y)
{
	return x.id<y.id;
}
inline void del(int x)
{
	sum-=(t[col[x]]-1);
	t[col[x]]--;
}
inline void add(int x)
{	
	sum+=t[col[x]];//根据上文x*(x-1)/2的公式 (x+1)*x/2-x*(x-1)/2  提出公因式 得x
	t[col[x]]++;
}
inline void uim()//预处理出组合数 
{
	for(int i=0;i<=N/2+N/2;i++)
	for(int j=0;j<=2;j++)
	if(!j||i==j)
	c[i][j]=1;
	else 
	c[i][j]=c[i-1][j-1]+c[i-1][j];
	return;
}
int main()
{
	ios::sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	cin>>col[i];
	sq=sqrt(n);
	for(int i=1;i<=m;i++)
	{
		cin>>a[i].l>>a[i].r;
		a[i].pos=(a[i].l-1)/sq+1;//分块 
		a[i].id=i;
	}
	uim();
	sort(a+1,a+1+m,cmp);
	curL=1;
	for(int i=1;i<=m;i++)
	{
		int l=a[i].l;
		int r=a[i].r;
		while(curL<l)del(curL++);
		while(curL>l)add(--curL);
		while(curR<r)add(++curR);
		while(curR>r)del(curR--);
		if(a[i].l==a[i].r)
		{
			a[i].a=0;
			a[i].b=1;
			continue;
		}
		a[i].a=sum;
		a[i].b=c[a[i].r-a[i].l+1][2];
		long long gg=__gcd(a[i].a,a[i].b);
		a[i].a/=gg;
		a[i].b/=gg;
	}
	sort(a+1,a+1+m,cmpp);
	for(int i=1;i<=m;i++)
	{
		printf("%lld/%lld\n",a[i].a,a[i].b);
	}
	return 0;
}
```
完结散花
~~这么水的题我调了三个小时 菜是原罪~~

求过~

---

## 作者：hahaha1215 (赞：2)



------------

#### ----普通莫队


------------

### 首先 
清楚概率怎么求

假设我们要求从区间l到r中拿出一对袜子的概率

sum[i]为第i种袜子在l到r中的数量



$$\frac{\sum_{i=l}^{r} {[sum[i] \times (sum[i]-1)]}}{ (r-l+1) \times {(r-l)}}\qquad$$

转化一下可以得到

$$\frac{\sum_{i=l}^{r} {sum[i]^{2}}-(r-l+1)}{ (r-l+1)\times {(r-l)}}\qquad$$

### 普通莫队是一种离线算法 并且充分利用上一个得到的答案来求得当前询问的答案


怎么由上一个答案来得到当前的答案呢？

设

$$ans=\sum_{i=l}^{r} {sum[i]^{2}}$$

即分母的一部分（减去（r-l+1）即可得到分母）

现在要求[l+1,r]这个区间的答案 

若第l只袜子的编号为x 则只有sum[x]减少了1 

更新ans的操作如下：

ans-=sum[x]*sum[x];

sum[x]-=1;

ans+=sum[x]*sum[x]

即：减去从前对答案的贡献 加上现在的贡献

求[l-1,r],[l,r-1],[l,r+1]的做法类比可得 

整理一下可以得到change函数

```
//x为新增加或减少的点
//若为新增加的点 如l指针左移和r指针右移 则w=1
//反之 w=-1
/*例子：求[l-1,r] change(l,-1)
       求[l,r+1] change(r+1,1) ……*/
change(int x,int w)
{
	ans-=sum[x]*sum[x];sum[x]+=w;ans+=sum[x]*sum[x];
}
```

为了使l和r指针尽可能少的移动（优化时间）

我们需要给所有的问题的l和r排序 构造cmp函数

### 要用分块

将整个长度为n的序列分为sqrt(n)块

cmp为：若l与r在同一块中 则按照l从小到大排序 
      否则 按照r从小到大排序
      
这样l指针每次最多跳2*(n/sqrt(n))次

最后求gcd 即可

还要记得l==r的特判


#### 一种优秀的gcd求法

```
//普通gcd
int gcd(int x,int y)
{
  return y==0?x:gcd(y,x%y);
}

```
其实可以看成是把x赋值为x%y 再调换x,y的位置 求gcd（x,y）

假设我们要调换a,b的值
```
//普通做法：
int tmp;tmp=a;a=b;b=tmp;

//其实可以利用位运算  异或
x^=y;y^=x;x^=y;

/*  第一步：x=x^y
    第二步：y=y^(x^y) 由于y^y=0 所以 y=x
    第三步：x=(x^y)^x 同理可得 x=y
*/

```
可以得到gcd函数

```
ll gcd(ll a,ll b)
{
  while(b^=a^=b^=a%=b);return a;
}

//从右至左运算 


```
#### 分析over

#### code

```

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#define ll long long
#define yes(i,a,b) for(register int i=a;i<=b;i++)
#define M 50010
using namespace std;
int n,m,tot,len;
ll ans,f_ans[M][2],sum[M];
int c[M],be[M];
struct node {int l,r,id;} q[M];
bool cmp(node x,node y)
{
  if(be[x.l]==be[y.l]) return x.r<y.r;
  return x.l<y.l;
}
void change(int x,int w)
{
  ans-=(ll)(sum[c[x]]*sum[c[x]]);sum[c[x]]+=w;ans+=(ll)(sum[c[x]]*sum[c[x]]);
}
ll gcd(ll a,ll b)
{
  while(b^=a^=b^=a%=b);return a;
}
int main()
{
  //freopen("1.in","r",stdin);
  //freopen("1.out","w",stdout);
  scanf("%d%d",&n,&m);
  len=sqrt(n);
  yes(i,1,n) scanf("%d",&c[i]),be[i]=i/len+1;
  yes(i,1,m) scanf("%d%d",&q[i].l,&q[i].r),q[i].id=i;
  sort(q+1,q+m+1,cmp);
  int l=1,r=0;
  yes(i,1,m)
    {
      while(l<q[i].l) change(l,-1),l++;
      while(l>q[i].l) change(l-1,1),l--;
      while(r<q[i].r) change(r+1,1),r++;
      while(r>q[i].r) change(r,-1),r--;
      ll ans1,ans2;
      ans1=ans-(ll)(q[i].r-q[i].l+1);ans2=(ll)(q[i].r-q[i].l+1)*(q[i].r-q[i].l);
      if(ans1==0) ans2=1;
      else
    {
      ll g=gcd(ans2,ans1);
      ans1/=g;ans2/=g;
    }
      f_ans[q[i].id][0]=ans1;f_ans[q[i].id][1]=ans2;
    }
  yes(i,1,m) printf("%lld/%lld\n",f_ans[i][0],f_ans[i][1]);
  return 0;
}


```





---

## 作者：Kelin (赞：2)

## [题意](https://blog.csdn.net/BeNoble_/article/details/79764397)

给你一个序列,每次询问一个区间任取两个数权值的概率

---

## 题解

设当前区间$[l,r]$中某种数$c$的个数是$cnt_c$,$num_i$表示$i$位置代表的数

那么答案就是

$$\frac1{{len\choose2}}\sum_c{cnt_c\choose2}=\frac1{{len\choose2}}\sum_c\sum_{i=1}^{cnt_c}i-1$$

记录当前的答案$Now=\sum_c\sum_{i=1}^{cnt_c}i-1$

假设我们知道$[l,r]$的答案,考虑怎么算出$[l,r+1]$的答案

点$r+1$(设$c=num_{r+1}$)只会让$cnt_c$加$1$,分析一下发现他的贡献是$(cnt_c+1)-1=cnt_c$可以$O(1)$算出

其他几种情况也是类似,所以我们就可以用莫队来写了

~~下面是毒瘤卡常代码~~

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
template<class T>inline void sd(T&x){
    char c;T y=1;while(c=gc(),(c<48||57<c)&&c!=-1)if(c==45)y=-1;x=c-48;
    while(c=gc(),47<c&&c<58)x=x*10+c-48;x*=y;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
template<class T>inline void we(T x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]=' ';
}
const int N=5e4+5;
typedef int arr[N];
typedef unsigned ui;
struct qry{
    int l,r,id,b;
    bool operator<(const qry x)const{return b==x.b?b&1?r<x.r:r>x.r:b<x.b;}
}a[N];
struct Ans{ui x,y;}ans[N];
int n,m,Sz;arr c,cnt;ui Now;
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    sd(n),sd(m);Sz=sqrt(n);
    fp(i,1,n)sd(c[i]);
    fp(i,1,m)sd(a[i].l),sd(a[i].r),a[i].id=i,a[i].b=a[i].l/Sz;
    sort(a+1,a+m+1);
    int L=a[1].l,R=a[1].l-1,g;ui s;
    fp(i,1,m){
        int x=a[i].l,y=a[i].r,id=a[i].id;
        while(L>x)Now+=cnt[c[--L]]++;
        while(R<y)Now+=cnt[c[++R]]++;
        while(L<x)Now-=--cnt[c[L++]];
        while(R>y)Now-=--cnt[c[R--]];
        Now?ans[id].x=Now/(g=__gcd(Now,s=(ui)(y-x+1)*(y-x)>>1)),
            ans[id].y=s/g
        :(ans[id].x=0,ans[id].y=1);
    }
    fp(i,1,m)we(ans[i].x),sr[C]='/',we(ans[i].y),sr[C]='\n';
return Ot(),0;
}
```

---

## 作者：Baihua (赞：1)

### [题解] P1494 : [2009国家集训队]小Z的袜子(hose)

莫队，~~卡常数~~

---

[题目地址](https://www.luogu.org/problemnew/show/P1494)

* 思路

  * 设$\text{Vis[i]}$为元素$\text{i}$在区间$\text{[L,R]}$的出现次数

  * 考虑区间$\text{[L,R]}$和元素$\text{i}$，首次取出的概率为$\frac{Vis[i]}{R-L+1}$，再次取出的概率是$\frac{Vis[i]-1}{R-L}$

  * 对于区间$\text{[L,R]}$，答案为$\sum_{i=1}^{N}{\frac{Vis[i](Vis[i]-1)}{(R-L)*(R-L+1)}}$。

  * 这样，每次给变$\text{[L,R]}$，分子的变化可以通过对前、后两项的值做差得到：

    * 设X=Vis[i],有：

    $$
    (X+1)X-(X)(X-1)=2X
    $$

* Code

  ```c++
    #include <stdio.h>
    #include <string.h>
    #include <algorithm>
    #define GC getchar()
    #define Clean(X,K) memset(X,K,sizeof(X))
    using namespace std ;
    int Qread () {
        int X = 0 ;
        char C = GC ;
        while (C > '9' || C < '0') C = GC ;
        while (C >='0' && C <='9') {
            X = X * 10 + C - '0' ;
            C = GC ;
        }
        return X ;
    }
    long long GCD(long long M, long long N) {
        while (N != 0) {
            long long T = M % N;
            M = N;
            N = T;
        }
        return M;
    }
    const int Maxn = 50005 ;
    int N , M , A[Maxn] , Vis[Maxn]  ;
    long long Ans[Maxn] , Sum[Maxn];
    struct Node {
        int Left , Right  , Place;
    };
    Node Q[Maxn] ;
    bool Cmp (const Node &X , const Node &Y) {
        if (X.Left != Y.Left ) return X.Left < Y.Left ;
        if (X.Left & 1) return X.Right < Y.Right ;
        else return X.Right > Y.Right ;
    }
    bool Cmp2 (const Node &X , const Node &Y) {
        return X.Place < Y.Place ;
    }
    void Qwrite(int X) {
        if(X > 9) Qwrite(X / 10);
        putchar(X % 10 + '0');
    }
     
    int main () {
    //  freopen ("P1494.in" , "r" , stdin) ;
    //  freopen ("P1494.out", "w" , stdout) ;
        N = Qread () , M = Qread ();
        for (int i = 1 ; i <= N; ++ i) A[i] = Qread () ;
        for (int i = 1 ; i <= M; ++ i) Q[i].Left = Qread () , Q[i].Right = Qread () , Q[i].Place = i ;;
        sort (Q + 1 , Q + 1 + M , Cmp) ;
        Clean (Vis , 0) ;
        int L , R ;
        long long Now = 0 ;
        L = R = Q[1].Left ;
        Vis[A[L]] = 1 ;
        for (int i = 1 ; i <= M; ++ i) {
            while (L < Q[i].Left ) {
                -- Vis[A[L]] ;
                Now -= (Vis[A[L]] << 1) ;
                ++ L ;
            }
    //      cout << L <<' '<<R <<' '<<Now<<endl;
            while (R < Q[i].Right ) {
                ++ R ;
                Now += (Vis[A[R]] << 1) ;
                ++ Vis[A[R]] ;
            }
    //      cout << L <<' '<<R <<' '<<Now<<endl;
            while (R > Q[i].Right ) {
                -- Vis[A[R]] ;
                Now -= (Vis[A[R]] << 1) ;
                -- R ;
            }
    //      cout << L <<' '<<R <<' '<<Now<<endl;
            Ans[Q[i].Place] = Now , Sum[Q[i].Place ] = ((long long)Q[i].Right - Q[i].Left ) * (Q[i].Right - Q[i].Left + 1) ;
        }
        std :: sort (Q + 1 , Q + 1 + M , Cmp2) ;
        for (int i = 1 ; i <= M; ++ i) {
            if (Q[i].Left == Q[i].Right ) printf ("0/1\n") ;
            else {
                int K = GCD (Ans[i] , Sum[i]) ;
                Ans[i] /= K , Sum[i] /= K ;
                printf ("%lld/%lld\n" , Ans[i] , Sum[i]) ;
            }
        }
        fclose (stdin) , fclose (stdout) ;
        return 0 ;
    }
                               
  ```

**Thanks!**

---

## 作者：szr666 (赞：1)

我这里推荐一下[我的博客](https://www.luogu.org/blog/szr666--blog/)

在博客里观看更美观哦~

[题目](https://www.luogu.org/problemnew/show/P1494)
------------


------------

华丽的分割线
# 解析
此题使用暴力分块的玄学莫队

首先对于区间[l,r],概率分母为(r-l+1)*(r-l)

分子为∑i=l->r  num[i]*(num[i]-1) (num[i]>=2)

其中num[i]表示i在区间[l,r]的出现次数

求出分子分母的最大公约数，约分即可。

当分子为0或l==r是特判为0/1

#### 重点讲莫队

一种暴力做法是对于上一问的l,r,将其左右移动到这一问的l,r

在上一问ans及num数组的基础下，将ans减有变动的数i对应的贡献

离开区间的数num[i]--,新加入的数num[i]++，

再让ans加新的数i对应的贡献(num[i]*(num[i]-1))

复杂度为O(nm),会超时

考虑离线做法，将长度为n的序列分成根号n个块，

每个块长度为根号n，将每个区间的l所在块的编号记录下来

以l所在块的编号为第一关键字，r为第二关键字对询问排序

按排序后的顺序重复以上暴力，神奇的事就出现了

右端点在一个块内枚举为O(n),有根号n个块,总复杂度O(n^1.5)

左端点在一个块内为O(根号n),不在一个块内为O(2*根号n)

有m次询问，总复杂度O(m*根号n)

两者的复杂度为O(n^1.5)

# 代码

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
using namespace std;
const int N=200000;
void read(int &x)
{
    int f=1;
    x=0;
    char c;
    c=getchar();
    while((c<'0'||c>'9')&&c!='-')
    {
        c=getchar();
    }
    if(c=='-')
    {
        f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9')
    {
        x=(x<<3)+(x<<1)+(c^48);
        c=getchar();
    }
    x=x*f;
}
void read(ll &x)
{
    ll f=1;
    x=0;
    char c;
    c=getchar();
    while((c<'0'||c>'9')&&c!='-')
    {
        c=getchar();
    }
    if(c=='-')
    {
        f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9')
    {
        x=(x<<3)+(x<<1)+(c^48);
        c=getchar();
    }
    x=x*f;
}
ll a[N];
ll num[N];
struct node
{
    int l;
    int r;
    int id;
    int pos;
    bool operator <(const node now) const;
};
bool node::operator <(const node now) const
{
    return pos==now.pos ? r<now.r : pos<now.pos;
}
node que[N];
struct data
{
    ll up;
    ll dowm;
};
data Ans[N];
inline ll power(ll a)
{
    return a*(a-1);
}
ll gcd(ll a,ll b)
{
    if(b==0)
    {
        return a;
    }
    else
    {
        return gcd(b,a%b);
    }
}
void charge(ll &a,ll &b)
{
    ll g;
    g=gcd(a,b);
    a/=g;
    b/=g;
    return;
}
int main()
{
    int n,m,i,size;
    read(n);
    read(m);
    size=(int)sqrt(n);
    for(i=1;i<=n;i++)
    {
        read(a[i]);
    }
    for(i=1;i<=m;i++)
    {
        read(que[i].l);
        read(que[i].r);
        que[i].id=i;
        que[i].pos=(que[i].l-1)/size+1;
    }
    sort(que+1,que+1+m);
    int l,r;
    ll ans;
    l=1;
    r=0;
    ans=0;
    for(i=1;i<=m;i++)
    {
        while(l>que[i].l)
        {
            l--;
            ans-=power(num[a[l]]);
            num[a[l]]++;
            ans+=power(num[a[l]]);
        }
        while(l<que[i].l)
        {
            ans-=power(num[a[l]]);
            num[a[l]]--;
            ans+=power(num[a[l]]);
            l++;
        }
        while(r<que[i].r)
        {
            r++;
            ans-=power(num[a[r]]);
            num[a[r]]++;
            ans+=power(num[a[r]]);
        }
        while(r>que[i].r)
        {
            ans-=power(num[a[r]]);
            num[a[r]]--;
            ans+=power(num[a[r]]);
            r--;
        }
        if(que[i].l==que[i].r||ans==0)
        {
            Ans[que[i].id].up=0;
            Ans[que[i].id].dowm=1;
        }
        else
        {
            Ans[que[i].id].up=ans;
            Ans[que[i].id].dowm=power(que[i].r-que[i].l+1);
            charge(Ans[que[i].id].up,Ans[que[i].id].dowm);
        }
    }
    for(i=1;i<=m;i++)
    {
        printf("%lld/%lld\n",Ans[i].up,Ans[i].dowm);
    }
}
```

---

## 作者：Yukhoi (赞：1)

## 题目描述

给定一个长度为 n 的数列和 m 个询问，每次询问一个 [ l，r ] 区间，求在区间中随机抽取到两个相同数的概率。

## 数据范围

n，m $\leq$ 50000，1 $\leq$ l $\leq$ r $\leq$ n，数列中的数 c $\leq$ n。

## 特殊情况

l = r，此时应特判。

## 输入输出格式
### 输入格式

第一行 n，m，含义如题；

第二行给出数列；

接下来 m 行，给出询问。

### 输出格式

输出 m 行**最简分数**，对应 m 个询问的回答。

## 思路：显然是莫队

关于莫队，楼下已有解释，实在还是不懂请自行询问[度娘](https://www.baidu.com)。

好吧我还是扔一个[莫队](https://baijiahao.baidu.com/s?id=1611364100257622493&wfr=spider&for=pc)超链接吧……

Orz……下面开始本蒟蒻的~~鱼唇~~思路……

很显然，用莫队只能直接统计出区间中各个数出现的次数 cnt，求概率什么的还是要处理过的。

那么我们先假定当前区间为 [ l，r ]，如果我们只考虑当前数为 x，出现了 cnt[ x ] 次，则数的总个数（区间长度）为

$$y = r - l + 1$$

抽出两个数的可能的事件数量

$$pos\_sum=C_{y}^{2}=\frac{y\times(y-1)}{2}=\frac{(r-l+1)\times(r-l)}{2}$$

抽出两个 x 的可能的事件数量

$$pos\_dbx=C_{cnt[x]}^{2}=\frac{cnt[x]\times(cnt[x]-1)}{2}$$

而抽出两个 x 的概率

$$pos\_x=\frac{pos\_dbx}{pos\_sum}=\frac{cnt[x]\times(cnt[x]-1)}{(r-l+1)\times(r-l)}$$

当然要记得化成最简分数。那么在区间中抽到两个相同数的概率显然是

$$pos=\sum_{i=1}^{n}\frac{cnt[i]^2-cnt[i]}{(r-l+1)\times(r-l)}=\frac{\sum_{i=1}^{n}cnt[i]^2-cnt[i]}{(r-l+1)\times(r-l)}$$

同时在区间 [ l，r ] 我们有

$$\sum_{i=1}^{n}cnt[i]=r-l+1$$

证明从略，则抽到两个相同数的概率为

$$pos=\frac{\sum_{i=1}^{n}cnt[i]^2-(r-l+1)}{(r-l+1)\times(r-l)}$$

而这时候，我们用**莫队**求出的 cnt 数组也就有了用武之地啦！也就是说，我们只要用莫队 _**维护各个数出现次数的平方和**_ 就好了，而由于数列中的数都满足小于等于 n ，我们甚至都不需要**离散化**！！！

下面上代码 ~~（未压行请放心食用）~~ 已打水印，严禁抄袭！！！

```cpp
#include <bits/stdc++.h>
using namespace std;
#define mkpr make_pair

typedef long long LL;
typedef pair<LL, LL> pall;
const int Maxn = 50005;

inline char Getchar()
{
	static char buf[35], *p1 = buf, *p2 = buf;
	return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 35, stdin), p1 == p2) ? EOF : *p1++;
}

inline int read()
{
	register int QwQ = 0, QAQ = 0;
	register char TAT = Getchar();
	while (!isdigit(TAT)) QwQ |= (TAT == '-'), TAT = Getchar();
	while (isdigit(TAT)) QAQ = (QAQ << 1) + (QAQ << 3) + (TAT ^ 48), TAT = Getchar();
	return QwQ ? -QAQ : QAQ;
}

template<class T_T>void write(T_T QAQ)
{
	if (!QAQ) {puts("0"); return;}
	register int QwQ = 0;
	register char TAT[20];
	if (QAQ < 0) putchar('-'), QAQ = -QAQ;
	while (QAQ) TAT[++QwQ] = (QAQ % 10) + 48, QAQ /= 10;
	while (QwQ) putchar(TAT[QwQ--]);
	putchar('\n');
}
//不可描述的读优输优模板……

struct node
{
	int l, r, id;
}qry[Maxn];
int n, m, c[Maxn], blk, cnt[Maxn], bl[Maxn];
LL pls;
pall ans[Maxn];

bool cmp(const node a, const node b)
{
	if (bl[a.l] != bl[b.l]) return a.l < b.l;
	else if (bl[a.l] & 1) return a.r < b.r;
	else return a.r > b.r;
	//小技巧，奇偶性优化排序
}

inline void update(int x, int flg)
{
	pls -= cnt[c[x]] * cnt[c[x]];
	cnt[c[x]] += flg;
	pls += cnt[c[x]] * cnt[c[x]];
	//莫队维护平方和 pls 的过程
}

inline void gcd(pall &x)
{
	LL a = x.second, b = x.first, tmp;
	while (b)
	{
		tmp =  a % b;
		a = b;
		b = tmp;
	}
	x.first /= a;
	x.second /= a;
	//由于要求最简分数，那么除以gcd就可以了
}

int main()
{
	n = read(), m = read();
	blk = sqrt(n);
	for (int i = 1; i <= n; ++i)
		c[i] = read(), bl[i] = (i - 1) / blk + 1;
	for (int i = 1; i <= m; ++i)
		qry[i].l = read(), qry[i].r = read(), qry[i].id = i;
	sort(qry + 1, qry + m + 1, cmp);
	register int nl = 1, nr = 0;
	for (int i = 1; i <= m; ++i)
	{
		register int l = qry[i].l, r = qry[i].r, id = qry[i].id;
		while (nl < l) update(nl++, -1);
		while (nl > l) update(--nl, 1);
		while (nr < r) update(++nr, 1);
		while (nr > r) update(nr--, -1);
		//莫队主体
		if (l == r)
		{
			ans[id].first = 0, ans[id].second = 1;
			continue;
		} //特殊情况的判断
		ans[id].second = 1ll * (r - l) * (r - l + 1);
		ans[id].first = pls - (r - l + 1);
		//按照公式进行处理，ans.first 是分子，ans.second 是分母
		gcd(ans[id]);//化成最简分数
	}
	for (int i = 1; i <= m; ++i)
		printf("%lld/%lld\n", ans[i].first, ans[i].second);
	return 0;
} // Coded By Yukhoi
```

---

## 作者：G_A_TS (赞：1)

在某题解的基础上解释一下  
fk和FK数组是[分块](https://www.cnblogs.com/cn-suqingnian/p/9302143.html)优化  
看完[这篇](https://www.luogu.org/blog/codesonic/Mosalgorithm)咕咕日报  您就可以对基础莫队比较了解了  
代码很简单，主要是gcd居然有函数(手动致远星++)  

------------
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,col[50010],ans,L=1,R,s[50010],FK[50010];
struct node
{
	ll l;//左 
	ll r;//右 
	ll place;//原位置 
	ll numerator;//分子 
	ll denominator;//分母 
}Q[50010];//question
ll update(ll x,ll fh)
{
	ans-=s[col[x]]*s[col[x]];
	s[col[x]]+=fh;
	ans+=s[col[x]]*s[col[x]];
}
int cmp(node a,node b)
{
	if(FK[a.l]!=FK[b.l])
		return a.l<b.l;
	return a.r<b.r;
}
int Cmp(node a,node b)
{
	return a.place<b.place;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>col[i];
	}
	int fk=sqrt(n);
	for(int i=1;i<=m;i++)
	{
		cin>>Q[i].l>>Q[i].r;
		Q[i].place=i;
	}
	for(int i=1;i<=n;i++)
	{
		FK[i]=(i-1)/fk+1;
	}
	sort(Q+1,Q+m+1,cmp);
	for(int i=1;i<=m;i++)
	{
		for(;R<Q[i].r;R++)
		{
			update(R+1,1);
		}
        for(;R>Q[i].r;R--)
        {
        	update(R,-1);
        }
        for(;L<Q[i].l;L++)
        {
        	update(L,-1);
        }
        for(;L>Q[i].l;L--)
        {
        	update(L-1,1);
        }
        if(Q[i].l==Q[i].r)
        {
            Q[i].numerator=0;
            Q[i].denominator=1;
            continue;
        }
        Q[i].numerator=ans-(Q[i].r-Q[i].l+1);
        Q[i].denominator=(Q[i].r-Q[i].l+1)*(Q[i].r-Q[i].l);
        ll tmp=__gcd(Q[i].numerator,Q[i].denominator);
        Q[i].numerator/=tmp;
        Q[i].denominator/=tmp;
	}
	sort(Q+1,Q+m+1,Cmp);
	for(int i=1;i<=m;i++)
	{
		cout<<Q[i].numerator<<"/"<<Q[i].denominator<<endl;
	}
}
```

---

## 作者：Honor誉 (赞：1)

## 基本莫队

众所周知，这道小Z的袜子是一道莫队算法的模板题。~~其实莫队的题都差不多~~。

相信大家都学过莫队算法，~~没学过都自己学去~~，那我就简单说下思路。

我们输入完询问后，直接排一遍序，从l=1，r=0，开始左右端点按要求进行跳动。

而一个点对答案的贡献又是什么呢。

我们知道，n只同色袜子能凑成n*(n-1)双袜子。

那么答案就是（a色袜子的数量*（a色袜子的数量-1）+（b色袜子的数量*（b色袜子的数量-1）...

那每删除一种颜色的袜子中的一只对答案的影响就是
```cpp
void gaijian(int x)
{
    ans-=(sum[a[x]])*(sum[a[x]]-1);
    sum[a[x]]--;
    ans+=(sum[a[x]])*(sum[a[x]]-1);
}
```
同理，每删除一种颜色的袜子中的一只对答案的影响就是
```cpp
void gaijia(int x)
{
    ans-=(sum[a[x]])*(sum[a[x]]-1);
    sum[a[x]]++;
    ans+=(sum[a[x]])*(sum[a[x]]-1);
}
```
那么我们可以得到如下程序：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct data
{
    long long x,y,id,ans1,ans2;
}c[50001];
long long b[50001],ans,sum[50001],a[50001],n,m,gg,l=1,r,d;
bool cmp(data a,data bb)
{
    if(b[a.x]==b[bb.x])
    {
        return a.y<bb.y;
    }
    return a.x<bb.x;
}
bool cmp1(data a,data bb)
{
    return a.id<bb.id;
}
void gaijia(int x)//减少
{
    ans-=(sum[a[x]])*(sum[a[x]]-1);
    sum[a[x]]++;
    ans+=(sum[a[x]])*(sum[a[x]]-1);
}
void gaijian(int x)//增加
{
    ans-=(sum[a[x]])*(sum[a[x]]-1);
    sum[a[x]]--;
    ans+=(sum[a[x]])*(sum[a[x]]-1);
}
long long gcd(long long a,long long b)
{
    if(b==0)
    {
        return a;
    }
    return gcd(b,a%b);
}
int main()
{
    scanf("%lld%lld",&n,&m);
    gg=sqrt(n);
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);
        b[i]=(i-1)/gg+1;
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%lld%lld",&c[i].x,&c[i].y);
        c[i].id=i;
    }
    sort(c+1,c+m+1,cmp);
    for(int i=1;i<=m;i++)
    {
        if(c[i].x==c[i].y)
        {
            c[i].ans1=0;
            c[i].ans2=1;
            continue;
        }
        while(l>c[i].x)
        {
            gaijia(l-1);
            l--;
        }
        while(l<c[i].x)
        {
            gaijian(l);
            l++;
        }
        while(r>c[i].y)
        {
            gaijian(r);
            r--;
        }
        while(r<c[i].y)
        {
            gaijia(r+1);
            r++;
        }
        c[i].ans1=ans;
        c[i].ans2=(r-l+1)*(r-l);
        d=gcd(c[i].ans1,c[i].ans2);
        c[i].ans1/=d;
        c[i].ans2/=d;
    }
    sort(c+1,c+m+1,cmp1);
    for(int i=1;i<=m;i++)
    {
        printf("%lld/%lld\n",c[i].ans1,c[i].ans2);
    }
    return 0;
}
```
答案要最简分数！！！

---

## 作者：Taduro (赞：1)

全网都在用的莫队例题： [Z爷的袜子](https://www.luogu.org/problemnew/show/P1494)

很显然，一个区间$[l,r]$的答案为$ans$的话。

$$ans={\frac{\sum_{i=1}^{M}{sum[i]\times(sum[i]-1)}}{(r-l+1)\times(r-l)}}$$

$M$ 表示颜色个数，$sum[i]$ 表示 $[l,r]$ 中颜色 $i$ 的个数。

显而易见的是，如果我们知道区间$[l,r-1]$的答案是$ans1$，要求区间$[l,r]$的答案$ans$的话。

$$ans=ans1-(sum[a[r]-1])^2 +sum[a[r]]^2$$

$a[r]$表示第$r$个袜子的颜色。这个式子可以继续展开，不过这里并不需要。

这样我们就可以将$l$和$r$两个指针反复移动来得到答案。

显然这个做法效率低下，这是莫队上场了，我们将序列分块。对所有询问进行双关键字排序，如果$l$在同块，就按$r$排序，否则按$l$排序，之后一个一个询问不断移动指针求解。

### 时间复杂度分析：

设块的大小为$blo$，考虑最坏情况。

先看$l$，在一个块的询问中，$l$最多从前一个块最后一个询问（位于前一个块头）到本块第一个询问（位于本块块尾）再回到本块最后一个询问（位于本块块头）。这样每个点最多要移动 $3\times blo$次，一共是$3\times n\times blo$ 次 。

再看$r$，在一个块的询问中，$r$最多从前一个快最后一个询问（在$n$）到本块第一个询问（在本块块头）到本块最后一个询问（在$n$）。要移动 $2\times n$次，一共是 $\frac{2\times n^2}{blo}$ 次。

这样我们发现，莫队的最坏复杂度是 $O(3\times n\times blo+\frac{2\times n^2}{blo})$ ，就是 $O(n\times blo+\frac{n^2}{blo})$，根据均值不等式得， $ blo=\sqrt{n}$时最优。

### 普通分块板子：

~~由于蜜汁爆范围，我全开了long long~~

```c++
#include<cmath>
#include<cstdio>
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;
struct node{
	ll l,r,h;
}q[50001];
ll a[50001],l,r,m;
ll bl[50001],blo,n;
ll sum[50001],num[50001],fm[50001],ans;
inline ll gcd(ll a,ll b){return !b?a:gcd(b,a%b);}
inline bool cmp(node c,node d){return bl[c.l]==bl[d.l]?c.r<d.r:c.l<d.l;}
inline void add(ll x,ll y){
	if (y<0){
		ans-=sum[a[x]]*(sum[a[x]]-1);
		ans+=(sum[a[x]]-1)*(sum[a[x]]-2);
		sum[a[x]]--;
	}
	else{
		ans-=sum[a[x]]*(sum[a[x]]-1);
		ans+=(sum[a[x]]+1)*sum[a[x]];
		sum[a[x]]++;
	}
}
int main(){
	scanf("%lld%lld",&n,&m); blo=sqrt(n);
	for (int i=1; i<=n; i++){
		scanf("%lld",&a[i]);
		bl[i]=(i-1)/blo+1;
	}
	for (int i=1; i<=m; i++){
		scanf("%lld%lld",&q[i].l,&q[i].r);
		q[i].h=i;
	}
	sort(q+1,q+m+1,cmp);
	l=q[1].l; r=l; while (r<=q[1].r) add(r,1),r++;
	r--; fm[q[1].h]=(q[1].r-l+1)*(q[1].r-l); if (!ans) fm[q[1].h]=1;
	else{ll g=gcd(ans,fm[q[1].h]);num[q[1].h]=ans/g; fm[q[1].h]/=g;}
	for (ll i=2; i<=m; i++){
		while (l<q[i].l) add(l,-1),l++;
		while (l>q[i].l) l--,add(l,1);
		while (r<q[i].r) r++,add(r,1);
		while (r>q[i].r) add(r,-1),r--;
		if (!ans){fm[q[i].h]=1;continue;}
		fm[q[i].h]=(q[i].r-q[i].l+1)*(q[i].r-q[i].l);
		ll g=gcd(ans,fm[q[i].h]);
		num[q[i].h]=ans/g; fm[q[i].h]/=g;
	}
	for (int i=1; i<=m; i++) printf("%lld/%lld\n",num[i],fm[i]);
	return 0;
}
```

---

## 作者：Shikita (赞：1)

# 又是一道莫队的题目，但是有一些注意点
首先，这道题有~~很多~~特判的条件，比如说l==r，比如说贡献为0，比如说贡献为1等等
其次，这道题目要开long long

然后我讲一下贡献的增加值
![](https://i.loli.net/2018/09/29/5baf6a2dcfffa.png)
可以看出，如果多了一只袜子，那么它和其他所有袜子都可以组成一双，贡献就是加上之前的袜子总数，其实也就是一个等差数列
贡献=(加入之前的袜子总数)
```
if((++cnt[a[x]])>=2) asn+=cnt[a[x]]-1;
```
反之，减少一只袜子也是一样
```
if((--cnt[a[x]])>=1) asn-=cnt[a[x]];
```
好吧，接下来蒟蒻我就贴代码吧
```
#include<bits/stdc++.h>
#define int long long //骚一手
using namespace std;
int n,m,t,L,R;
int asn;
int cnt[50005],a[50005];
struct node{int l,r,id;}q[50005];//询问数组
struct nod{int x,y;}ans[50005];//答案数组
inline int read()
{
    int x=0;
    char c=getchar();
    bool flag=0;
    while(c<'0'||c>'9') {if(c=='-')flag=1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x+(x<<2)<<1)+ c-'0';c=getchar();}
    return flag?-x:x;
}
bool cmp(node x,node y)
{
	return (x.l/t)==(y.l/t)?x.r<y.r:x.l<y.l;
}//分块排序询问
void in(int x)
{
	if((++cnt[a[x]])>=2) asn+=cnt[a[x]]-1;
}
void out(int x)
{
	if((--cnt[a[x]])>=1) asn-=cnt[a[x]];
}//加入和删除操作
int gcd(int x,int y) 
{
	if(y==0) return x;
	return  gcd(y,x%y);
}//标准GCD
signed main()
{
	n=read(),m=read();
	t=sqrt(n);
	for(int i=1;i<=n;++i) a[i]=read();
	for(int i=1;i<=m;++i) q[i].l=read(),q[i].r=read(),q[i].id=i;
	sort(q+1,q+1+m,cmp);
	for(int i=1;i<=m;++i)
	{
		int l=q[i].l,r=q[i].r;
		if(l==r)
		{
			ans[q[i].id].x=0,ans[q[i].id].y=1;
			continue;
		}//特判1
		while(L<l) out(L++);
		while(L>l) in(--L);
		while(R<r) in(++R);
		while(R>r) out(R--);//标准莫队
		if(asn==0)
		{
			ans[q[i].id].x=0,ans[q[i].id].y=1;
			continue;
		}//特判
		if(asn==1)
		{
			ans[q[i].id].x=1,ans[q[i].id].y=(r-l+1)*(r-l)/2;
			continue;
		}//特判
		int len=(r-l+1)*(r-l)/2;
		int ccg=gcd(asn,len);
		if(ccg==1) ans[q[i].id].x=asn,ans[q[i].id].y=len;//特判
		else ans[q[i].id].x=asn/ccg,ans[q[i].id].y=len/ccg;
	}
	for(int i=1;i<=m;++i) 
	cout<<ans[i].x<<"/"<<ans[i].y<<endl;
}
```
如果对于莫队不是很了解，建议先去做P3901，P2709

对了，P1972好像卡莫队

如果可以，那么P1903是修改莫队，可以去做一下

谢谢观看

---

## 作者：arfa (赞：1)

> ### 莫队

话说这国家集训队的题目应该是老题,比较水。

其它大佬已经说出了需要求出的东西:

$\frac{(num[1]^2+num[2]^2+num[3]^2...num[n]^2-(R-L+1))}{(R-L+1)*(R-L)}$的最简单形态。其中$num[i]$表示一个数字的出现次数。

而我们只需要求出$num[1]^2+num[2]^2+num[3]^2...num[n]^2$。莫队可以实现每一个数字的出现次数,然后每次统计答案的时候注意一下。记得答案要最简模式,所以要用$GCD$,注意$l=r$的情况。

最后告诉大家一个好东西,在用莫队时,一个块的数量最好是$\frac{N}{15}$~$\frac{N}{20}$。如果只是单纯的打$\sqrt{N}$,你可能会超时。对于$Pascal$选手,这两个的差别将近$1s$。

> ### $Code$

```pascal
// luogu-judger-enable-o2
var
    node_num,i,j,n,m,l,r:longint;
    num:array[-1..510000] of int64;
    id,left,right,recf:array[-1..510000] of int64;
    bucket:array[-1..1010007] of int64;
    ans:array[1..2,-1..510000] of int64;
    p,k,sum:int64;

procedure Sort(l,r:longint);
var
    i,j,s,t:longint;
begin
    i:=l; j:=r; s:=(l+r) div 2;
    repeat
        while ((recf[i]<recf[s])or((recf[i]=recf[s])and(right[i]<right[s]))) do inc(i);
        while ((recf[j]>recf[s])or((recf[j]=recf[s])and(right[j]>right[s]))) do dec(j);
        if i<=j then
        begin
            t:=recf[i];  recf[i]:=recf[j];   recf[j]:=t;
            t:=id[i];    id[i]:=id[j];       id[j]:=t;
            t:=left[i];  left[i]:=left[j];   left[j]:=t;
            t:=right[i]; right[i]:=right[j]; right[j]:=t;
            inc(i); dec(j);
         end;
    until i>=j;
    if i<r then Sort(i,r);
    if j>l then Sort(l,j);
end;

function Locate(node:longint):longint;
begin
    if node mod node_num=0 then
        exit(node div node_num);
    exit(node div node_num+1);
end;


procedure Ready;
begin
    read(n,m);
    node_num:=n div 17;
    for i:=1 to n do read(num[i]);
    for i:=1 to m do
    begin id[i]:=i; read(left[i],right[i]); recf[i]:=Locate(left[i]); end;

    Sort(1,m);
end;

procedure add(x:longint); 
begin
    dec(sum,bucket[x]*bucket[x]);
    inc(bucket[x]);
    inc(sum,bucket[x]*bucket[x]);
end;

procedure dim(x:longint);
begin
    dec(sum,bucket[x]*bucket[x]);
    dec(bucket[x]);
    inc(sum,bucket[x]*bucket[x]);
end;

function gcd(a_,b_:int64):int64;
var
    a,b,c:int64;
begin
    a:=a_;
    b:=b_;
    repeat
        c:=a mod b;
        a:=b;
        b:=c;
    until b=0;
    exit(a);
end;

begin
    Ready;
    l:=1;
    r:=0;
    for i:=1 to m do
    begin
        while r<right[i] do begin  inc(r); add(num[r]); end;
        while r>right[i] do begin dim(num[r]); dec(r); end;
        while l<left[i] do begin dim(num[l]); inc(l); end;
        while l>left[i] do begin dec(l); add(num[l]); end;
        if left[i]=right[i] then
        begin
            ans[1,id[i]]:=0;
            ans[2,id[i]]:=1;
        end
        else
        begin
            p:=(right[i]-left[i]+1)*(right[i]-left[i]);
            k:=gcd((sum-(right[i]-left[i]+1)),p);
            ans[1,id[i]]:=(sum-(right[i]-left[i]+1)) div k;
            ans[2,id[i]]:=p div k;
        end;
    end;

    for i:=1 to m do
        writeln(ans[1,i],'/',ans[2,i]);
end.
```



---


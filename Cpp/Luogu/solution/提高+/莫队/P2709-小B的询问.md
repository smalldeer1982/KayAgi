# 小B的询问

## 题目描述

小B 有一个长为 $n$ 的整数序列 $a$，值域为 $[1,k]$。  
他一共有 $m$ 个询问，每个询问给定一个区间 $[l,r]$，求：  
$$\sum\limits_{i=1}^k c_i^2$$

其中 $c_i$ 表示数字 $i$ 在 $[l,r]$ 中的出现次数。  
小B请你帮助他回答询问。


## 说明/提示

【数据范围】   
对于 $100\%$ 的数据，$1\le n,m,k \le 5\times 10^4$。


## 样例 #1

### 输入

```
6 4 3
1 3 2 1 1 3
1 4
2 6
3 5
5 6```

### 输出

```
6
9
5
2```

# 题解

## 作者：vectorwyx (赞：149)

upd on 2023.4.19：修缮 $\LaTeX$，同时补充了复杂度证明。

**多次区间查询、不强制在线、$O(n\sqrt{n})$ 能过**。

很显然：这就是**莫队**。以下视 $n,m$ 同阶。

## 一.什么是莫队

莫队其实就是一种优雅的暴力，它十分~~玄学~~巧妙地将**分块和暴力**结合在了一起，主要用来处理**离线区间查询**等问题。

由于莫队算法是由莫涛队长提出的，因此我们称这种算法为莫队。

## 二.莫队的思想

其实很简单：**通过挪动区间的方式按某种顺序离线处理区间查询操作**。

有三个关键词：挪动区间、按某种顺序、离线处理。

### 1.挪动区间

比如说第一次查询的区间是 $[1,3]$，第二次查询的区间是 $[4,6]$。

那我们直接把 $1$ 挪成 $4$，$3$ 挪成 $6$，然后在挪动的过程中修改我们的答案。

写成代码就是这样：

```cpp
//ans1是上一次查询的左端点，ans2是上一次查询的右端点
//lef是当前查询的左端点，rig是当前查询的右端点
while(ans1>lef) ans1--,add(a[ans1]);//add是扩展函数
while(ans2<rig) ans2++,add(a[ans2]);
while(ans1<lef) del(a[ans1]),ans1++;//del是删除函数
while(ans2>rig) del(a[ans2]),ans2--;
```

add 函数和 del 函数：

```cpp
//b是桶，统计每个数出现次数
inline void add(int x){
	c+=2*b[x]+1;
    //b[x]+1对于平方和c的影响（小学数学）
	b[x]++;
}
inline void del(int x){
	c-=2*b[x]-1;//同上
	b[x]--;
}
```

### 2.按某种顺序

最严格的顺序应该是把每次区间求一个曼哈顿距离最小生成树。

但完全没必要（~~毕竟暴力~~）。

这时候分块就派上了用场~

把 $[1,n]$ 均匀分成 $\sqrt{n}$ 块。

我们**先把这些区间按照左端点 $l$ 所在的块从左往右排序**。

**再把 $l$ 所在块相同的区间按 $r$ 从小到大排序**。

可以证明用这种方法最终挪动次数是 $O(n\sqrt n)$ 级别，而且是此类问题下能做到的最优量级，证明详见 [link](https://www.luogu.com.cn/blog/wyxawa/post-xue-xi-bi-ji-mu-dui-jin-jie)。

当然还有其它方式，但这样简单啊（逃）。

于是就有了这样的代码：

```cpp
int block=sqrt(n);
inline bool cmp(node x,node y){
	if((x.l-1)/block==(y.l-1)/block) return x.r<y.r;
	return x.l/block<y.l/block;
}
……
sort(modui+1,modui+1+m,cmp);//modui就是莫队
```

### 3.离线处理

由于莫队是先把询问的区间存储起来再统一处理，当然是离线算法 qwq。

最后把每次询问对应的答案用数组存储起来就好啦。


------------

## 三.莫队的实现

用一个结构体数组存储查询的区间以及下标。

再开一个数组记录答案，一个桶，当然还有原数组（~~废话~~）。

在转移时还要维护答案（~~不然你怎么记录~~）。

```cpp
long long ans[maxn];//ans记录答案
int a[maxn],b[maxn];//a是原数组，b是桶
struct node{
	int l,r,id;//l是左端点，r是右端点，id是下标
}modui[maxn];
```


------------

OK，这就是普通莫队。

话不多说，直接放代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#define maxn 50001
#define ll long long
#define fo(x,y) for(register int i=x;i<=y;++i)
using namespace std;
ll ans[maxn],c; //注意longlong哦
int a[maxn],b[maxn],n,m,k,block;
struct node{
	int l,r,id;
}modui[maxn];

inline bool cmp(node x,node y){//上文有解释
	if((x.l-1)/block==(y.l-1)/block) return x.r<y.r;
	return x.l/block<y.l/block;
}

inline int read(){//快读，不多说
	int x=0,fh=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') fh=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	return x*fh;
}
inline void add(int x){//上文都解释过了
	c+=2*b[x]+1;//维护答案
	b[x]++;
}
inline void del(int x){
	c-=2*b[x]-1;//维护答案
	b[x]--;
}
int main(){
	int lef,rig,ans1=1,ans2=0;
    //ans1:上次的左端点 ans2:上次的右端点 
	n=read(),m=read(),k=read();
	block=sqrt(n);
	fo(1,n){
		a[i]=read();
	}
	fo(1,m){
		modui[i].l=read();
		modui[i].r=read();
		modui[i].id=i;
	}
	sort(modui+1,modui+1+m,cmp);
	fo(1,m){
		lef=modui[i].l,rig=modui[i].r;
        //挪动操作：
		while(ans1>lef) ans1--,add(a[ans1]);
		while(ans2<rig) ans2++,add(a[ans2]);
		while(ans1<lef) del(a[ans1]),ans1++;
		while(ans2>rig) del(a[ans2]),ans2--;
		ans[modui[i].id]=c;//存储答案
	}
	fo(1,m) printf("%lld\n",ans[i]);
	return 0;
}

```

点个赞再走吧 qwq。

---

## 作者：zcysky (赞：76)

非常naive的莫队

莫队算法到底是啥呢？

对于这题和大多数莫队题而言，可以离线处理区间的询问

当然莫队也可以带修改

不过这又是另一种操作了，虽然核心差不多。

莫队算法要满足的必要条件是我必须O(1)移动相邻区间

否则复杂度很是爆炸。

我们考虑用两个指针维护我们要找的区间

很显然我们移动的越少

跑得就越快是吧？

所以我们把询问抽象成点

就是要求曼哈顿距离的最小生成树。

这个直接跑普通最小生成树算法很爆炸

一般人就都是分块求的。

莫队其实就这么点东西……

```cpp
#include<bits/stdc++.h>
#define N 50005
#define ll long long
using namespace std;
struct Query{
    int l,r,id,pos;
    bool operator <(const Query &x)const{if(pos==x.pos)return r<x.r;
    else return pos<x.pos;}
}a[N];
int b[N],n,m,K;ll cnt[N],Ans[N];
inline int read(){
    int f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return x*f;
}
int main(){
    n=read();m=read();K=read();
    int size=(int)sqrt(n);
    for(int i=1;i<=n;i++)b[i]=read();
    for(int i=1;i<=m;i++){
        a[i].l=read();a[i].r=read();a[i].id=i;
        a[i].pos=(a[i].l-1)/size+1;
    }
    sort(a+1,a+m+1);
    int l=1,r=0;ll ans=0;
    for(int i=1;i<=m;i++){
        while(l>a[i].l)l--,cnt[b[l]]++,ans+=2*cnt[b[l]]-1;
        while(r<a[i].r)r++,cnt[b[r]]++,ans+=2*cnt[b[r]]-1;
        while(l<a[i].l)cnt[b[l]]--,ans-=2*cnt[b[l]]+1,l++;
        while(r>a[i].r)cnt[b[r]]--,ans-=2*cnt[b[r]]+1,r--;
        Ans[a[i].id]=ans;
    }
    for(int i=1;i<=m;i++)printf("%lld\n",Ans[i]);
    return 0;
}
```

---

## 作者：一只小兵 (赞：41)

## 题面分析
对区间中数的出现次数进行离线查询,是一道莫队的模板题


------------
## 普通莫队

### 莫队
莫队算法是由莫涛发明的算法，所以称为莫队算法。主要用来处理离线的区间问题，如区间和。


------------
### 莫队算法能解决的情况
1. 离线询问.例如[P4168](https://www.luogu.org/problem/P4168)就不能用带修莫队
2. 对于每次加入区间的操作的复杂度都是O(1)的.如查找区间众数就是删除一个数的复杂度不是O(1)的.(使用回滚莫队其实也是将区间移动降为复杂为O(1)，这里不做讨论)


------------
### 算法过程

1. 对于多段区间的询问,先将询问离线存储下来,然后再从左到右扫一遍,在过程中维护一段区间,就可以得到每个寻问的答案.
2. 但暴力扫肯定不行，所以在扫的过程中,需要对 l 进行排序,以求能够在移动次数最少的情况下,得到所有希望求出的区间.
3. 首先对每个区间进行分块操作,再将左端点在一起的区间询问放在一起进行处理,对于每个块处理一遍,那么就可以得到所有询问的答案.
__________
### 还是用图来展示一下过程
#### 预处理

![最初的区间与询问](https://cdn.luogu.com.cn/upload/pic/70087.png)
![分块](https://cdn.luogu.com.cn/upload/pic/70089.png) 

然后对问题进行排序

![排序后的问题](https://cdn.luogu.com.cn/upload/pic/70094.png) ~~因为太懒了,区间长度都一样~~

#### 开始莫队

![开始莫队](https://cdn.luogu.com.cn/upload/pic/70097.png) 初始化左右指针

![到达第一个位置](https://cdn.luogu.com.cn/upload/pic/70100.png)移动右端点到第一个位置,这时满足了第一个区间

     移动左端点                                         到达第二个位置

![移动左端点](https://cdn.luogu.com.cn/upload/pic/70103.png) ![到达第二个位置](https://cdn.luogu.com.cn/upload/pic/70106.png) 


后面类推,就不一一说明了

![到达三个位置](https://cdn.luogu.com.cn/upload/pic/70108.png)![到达第四个位置](https://cdn.luogu.com.cn/upload/pic/70112.png)

最终状态

![最终](https://cdn.luogu.com.cn/upload/pic/70113.png)

### 复杂度证明
 对于区间进行分块那么可以得到$\sqrt{n}$个块,那么对于就存在于$\sqrt{n}$个区间,而每次对于每个区间块中的$l$ ,$r$的最坏情况是对于每个块都遍历到序列的最右端,共$n$个点.每次移动指针复杂度为$O(1)$,所以整个算法的复杂度为$O(n\sqrt{n})$
 
 ## 代码思路
 1. 对于问题的离线化分块处理
 ```cpp
struct question{
  int l,r,num;//表示从l到r 和 第num个问题
  bool operator<(const question p1) const {//对于一个问题进行排序处理,将l的块在前的放在一起,再按r为第二关键字排序
  if(i[this->l] != i[p1.l]) return this->l < p1.l;
  else if(i[this->l]&1){//这里有一个小技巧,将r按照奇数顺序,偶数逆序排序
		  return this->r < p1.r;
      }
		else return this->r > p1.r;
	}
}q[maxn];
```
关于小技巧的说明:对于两个区间交替的过程中,$r$如果先回来,那么部分点就会被扫两次,那么对于$r$一正一逆的排序,就可以避免重复的情况
```cpp
//可能有人不太喜欢结构体函数,这里在写一份cmp的排序. 
struct question{
      int l,r,num;
}; 
bool cmp(question p1, question p2){
      if(i[p1.l] != i[p2.l]) return i[p1.l] < i[p2.l];
      if(p1.l % 2 == 0) return p1.r > p2.r;
      return p1.r < p2.r; 
}
```


2. 目标区间指针的移动(莫队核心)

```cpp
for(int t = 2; t <= m ; t++){
	for(; l_now < q[t].l ; l_now++) {//将l指针(绿色)向右移动
		ans -= (cnt[a[l_now]]*cnt[a[l_now]]);//将一个点移出区间
		cnt[a[l_now]]--;
		ans += (cnt[a[l_now]]*cnt[a[l_now]]);
	}
	for(++r_now;r_now <= q[t].r ; r_now++){//将r指针(红色)向右移动
		ans -= (cnt[a[r_now]]*cnt[a[r_now]]);//将一个点加入区间
		cnt[a[r_now]]++;
		ans += (cnt[a[r_now]]*cnt[a[r_now]]);
	}
	for(--l_now ; l_now >= q[t].l ; l_now--){//将l指针向左移动
		ans -= (cnt[a[l_now]]*cnt[a[l_now]]);//将一个点移出区间
		cnt[a[l_now]]++;
		ans += (cnt[a[l_now]]*cnt[a[l_now]]);
	}
	for(--r_now; r_now > q[t].r ; r_now--){//将r指针向左移动
		ans -= (cnt[a[r_now]]*cnt[a[r_now]]);//将一个点移出区间
		cnt[a[r_now]]--;
		ans += (cnt[a[r_now]]*cnt[a[r_now]]);
	}
	pri[q[t].num] = ans;l_now=q[t].l;r_now=q[t].r;//将移过的指针复原
}
```
#### 注意：
    要将最终答案按顺序进行存储

## 最后附上AC代码
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;
const int maxn = 50017;
int a[maxn],i[maxn],l_now,r_now,cnt[maxn];//a储存原序列,i储存位置所在块,l_now,r_now分别是当前目标区间,cnt表示出现次数 
long long ans,pri[maxn];
struct question{
	int l,r,num;//表示从l到r 和 第num个问题
	bool operator<(const question p1) const {//对于一个问题进行排序处理,将l的块在前的放在一起,再按r为第二关键字排序
	if(i[this->l] != i[p1.l]) return this->l < p1.l;
	else if(i[this->l]&1){//这里有一个小技巧,将r按照奇数顺序,偶数逆序排序
			return this->r < p1.r;
		}
		else return this->r > p1.r;
	}
}q[maxn];
int main(){
	int n,m,k,q_m;
	scanf("%d%d%d",&n,&m,&k);
	q_m = sqrt(m);
	for(int t = 1 ; t <= n ; t++){
		scanf("%d",&a[t]);
		i[t] = (t-1)/q_m+1;//找到t位置所在的块
	}
	for(int t = 1 ; t <= m ; t++){
		scanf("%d%d",&q[t].l,&q[t].r);
		q[t].num=t;
	}
	sort(q+1,q+1+m);//对进行问题排序 
	for(int t = q[1].l ; t <= q[1].r ; t++){//先暴力求出第一个问题的答案 
		ans -= (cnt[a[t]]*cnt[a[t]]);
		cnt[a[t]]++;
		ans += (cnt[a[t]]*cnt[a[t]]);
	}
	l_now = q[1].l;r_now = q[1].r;pri[q[1].num] = ans;//当前的节点 
	for(int t = 2; t <= m ; t++){
		for(; l_now < q[t].l ; l_now++) {//将l指针(绿色)向右移动
			ans -= (cnt[a[l_now]]*cnt[a[l_now]]);//将一个点移出区间
			cnt[a[l_now]]--;
			ans += (cnt[a[l_now]]*cnt[a[l_now]]);
		}
		for(++r_now;r_now <= q[t].r ; r_now++){//将r指针(红色)向右移动
			ans -= (cnt[a[r_now]]*cnt[a[r_now]]);//将一个点加入区间
			cnt[a[r_now]]++;
			ans += (cnt[a[r_now]]*cnt[a[r_now]]);
		}
		for(--l_now ; l_now >= q[t].l ; l_now--){//将l指针向左移动
			ans -= (cnt[a[l_now]]*cnt[a[l_now]]);//将一个点移出区间
			cnt[a[l_now]]++;
			ans += (cnt[a[l_now]]*cnt[a[l_now]]);
		}
		for(--r_now; r_now > q[t].r ; r_now--){//将r指针向左移动
			ans -= (cnt[a[r_now]]*cnt[a[r_now]]);//将一个点移出区间
			cnt[a[r_now]]--;
			ans += (cnt[a[r_now]]*cnt[a[r_now]]);
		}
		pri[q[t].num] = ans;l_now=q[t].l;r_now=q[t].r;//将移过的指针复原
	}	
	for(int t = 1 ; t <= m ; t++)
		printf("%lld\n",pri[t]);
	return 0;
}
```


---

## 作者：shuiyuhan (赞：25)

题目描述见此处：传送门https://www.luogu.org/problemnew/show/P2709
我交了n遍才过，所以评测记录几乎被我占了1页，求
管理大大不要怪我......
-------------------------------------分割线
解题思路：

此题第一眼：数据结构; 第二眼：暴力O*(n^3); 第三遍(线段树TLE);

最后一眼：莫队似乎可以做哦。

于是我们考虑听y大所说的莫涛队长发明的算法——莫队。

我们还是从暴力写起：

第一遍，无序，让l和r乱跳，时间O(n^2q)爆TLE！

第二遍，排序后莫队，让l有序，r乱跳，时间O(NQ*LG(N)) 还是TLE！

第三遍，考虑分块优化，如果快排时的左端点i和右端点j在同一区间内，即i div sqrt(n)=j div sqrt(n)

那么i，j在同一区间，直接以y数组排序为第一关键字排序即可。

否则以x数组为第一关键字排序。（具体见代码）

我来发个p的题解，也算是为p党做个小贡献。

(现在用p的人真得不多了)
``` pascal
var
  n,k,m,l,r,j,i,p:longint;
  ans:int64;
  a,x,y,c,b,f:array[0..500005] of longint;
procedure sort(l,r:longint);//库里自带的快排
做了些小改动。(这点p真的比不上c++的STL)
      var
         i,j,xx,yy,yyy:longint;
      begin
         i:=l;
         j:=r;
         xx:=x[(l+r) div 2];
         yy:=y[(l+r) div 2];//多关键字排序
         repeat
           if i div p=j div p then//判断i，j是否在同一块内
           begin
           while (x[i]<xx) do
            inc(i);
           while (xx<x[j]) do
            dec(j);
           if not(i>j) then//别忘记交换3个而不是1个数组
             begin
                yyy:=x[i];
                x[i]:=x[j];
                x[j]:=yyy;
                yyy:=y[i];
                y[i]:=y[j];
                y[j]:=yyy;
                yyy:=c[i];
                c[i]:=c[j];
                c[j]:=yyy;
                inc(i);
                j:=j-1;
             end;
           end else
           begin//这部分作用同上
             while (y[i]<yy) do
            inc(i);
           while (yy<y[j]) do
            dec(j);
           if not(i>j) then
             begin
                yyy:=x[i];
                x[i]:=x[j];
                x[j]:=yyy;
                yyy:=y[i];
                y[i]:=y[j];
                y[j]:=yyy;
                yyy:=c[i];
                c[i]:=c[j];
                c[j]:=yyy;
                inc(i);
                j:=j-1;
             end;
           end;
         until i>j;
         if l<j then
           sort(l,j);
         if i<r then
           sort(i,r);
      end;
begin
  readln(n,m,k);
  p:=trunc(sqrt(n));//把序列分成sqrt(n)块
  for i:=1 to n do read(a[i]);
  for i:=1 to m do
  begin
    readln(x[i],y[i]);//莫队作为离线算法，当然要保存每个询问啦
    c[i]:=i;//c[i]表示当前读入的是第i个数
  end;
  sort(1,m);
  l:=1;
  r:=0;
  ans:=0;
  fillchar(b,sizeof(b),0);
  for i:=1 to m do//莫队基本思想(本人喜欢while)
  begin
    while l>x[i] do begin dec(l); inc(b[a[l]]); ans:=ans+(2*b[a[l]]-1); end;
    while r<y[i] do begin inc(r); inc(b[a[r]]); ans:=ans+(2*b[a[r]]-1); end;
    while l<x[i] do begin dec(b[a[l]]); ans:=ans-(2*b[a[l]]+1); inc(l); end;
    while r>y[i] do begin dec(b[a[r]]); ans:=ans-(2*b[a[r]]+1); dec(r); end;
    f[c[i]]:=ans;//用f数组记录读进来时第1-n个答案
  end;
  for i:=1 to m do writeln(f[i]);
end.
```

---

## 作者：fyfy (赞：18)

#### 这题没人用分块吧？
好像分块比较麻烦，但是我太弱了，不会莫队，就打了一个比较巧妙的分块。
#### 1.build函数。
还是像普通分块一样的写，只是我们需要预处理两个数组。


------------
f[i][j]表示从开始到第i块，颜色为j的颜色有多少个（前缀和）。这个东西很好处理。
```
for (int i=1;i<=num;i++) {
	for (int j=1;j<=n;j++)
	f[i][a[j]]=f[i-1][a[j]];
	for (int j=l[i];j<=r[i];j++)
	f[i][a[j]]++;
}
```

------------
s[i][j]表示第i块，到第j块的贡献。换句话说，就是第i块到第j块之间的答案。也比较好处理。假设现在已经处理到了s[i][j-1],那么s[i][j]中的颜色k，每出现一次，就用一个tmp[j]数组自加，最后假设s[i][j-1]中颜色k出现次数为x，那么x=f[j-1][k]-f[i-1][k],s[i][j]中颜色k出现次数就是x+tmp[k].那么我们就让s[i][j]+=2*(x+tmp[k])+1;为什么呢？例如tmp[k]=1时，（x+1）^（x+1）-x^2=2×X+1。还要注意一个问题，tmp数组要清零，当然不能单纯地使用memset（会超时），而是重复一次上面的循环，将它清零。
```
for (int i=1;i<=num;i++)
	for (int j=i;j<=num;j++) {
		s[i][j]=s[i][j-1];
		for (int k=l[j];k<=r[j];k++) {
			int p=f[j-1][a[k]]-f[i-1][a[k]];
			s[i][j]+=2*(p+tmp[a[k]])+1;
			tmp[a[k]]++;
		}
		for (int k=l[j];k<=r[j];k++)
		tmp[a[k]]=0;
	}
```


------------
#### 2.总的代码就是下面这样，很好理解：
```
#include <bits/stdc++.h>
using namespace std;

const int N=50010,S=250;
int n,m,q,a[N],s[S][S];
int f[S][N],block,num;
int belong[N],l[S],r[S],tmp[N];

void build()
{
	block=sqrt(n);
	num=n/block;
	if (n%block) num++;
	for (int i=1;i<=num;i++)
	l[i]=(i-1)*block+1,r[i]=i*block;
	r[num]=n;
	for (int i=1;i<=n;i++)
	belong[i]=(i-1)/block+1;
	for (int i=1;i<=num;i++) {
		for (int j=1;j<=n;j++)
		f[i][a[j]]=f[i-1][a[j]];
		for (int j=l[i];j<=r[i];j++)
		f[i][a[j]]++;
	}
	for (int i=1;i<=num;i++)
	for (int j=i;j<=num;j++) {
		s[i][j]=s[i][j-1];
		for (int k=l[j];k<=r[j];k++) {
			int p=f[j-1][a[k]]-f[i-1][a[k]];
			s[i][j]+=2*(p+tmp[a[k]])+1;
			tmp[a[k]]++;
		}
		for (int k=l[j];k<=r[j];k++)
		tmp[a[k]]=0;
	}
}

long long ask(int ls,int rs)
{
	long long ans=0;
	if (belong[ls]==belong[rs]) {
		for (int i=ls;i<=rs;i++) {
			ans+=2*tmp[a[i]]+1;
			tmp[a[i]]++;
		}
		for (int i=ls;i<=rs;i++) tmp[a[i]]=0;
		return ans;
	}
	for (int i=ls;i<=r[belong[ls]];i++) {
		int p=f[belong[rs]-1][a[i]]-f[belong[ls]][a[i]];
		ans+=2*(p+tmp[a[i]])+1;
		tmp[a[i]]++;
	}
	for (int i=l[belong[rs]];i<=rs;i++) {
		int p=f[belong[rs]-1][a[i]]-f[belong[ls]][a[i]];
		ans+=2*(p+tmp[a[i]])+1;
		tmp[a[i]]++;
	}
	for (int i=ls;i<=r[belong[ls]];i++) tmp[a[i]]=0;
	for (int i=l[belong[rs]];i<=rs;i++) tmp[a[i]]=0;
	if (belong[ls]+1==belong[rs]) return ans;
	return ans+s[belong[ls]+1][belong[rs]-1];
}

int main()
{
	ios::sync_with_stdio(0);
	cin>>n>>m>>q;
	for (int i=1;i<=n;i++)
	cin>>a[i];
	build();
	while (m--) {
		int ls,rs;
		cin>>ls>>rs;
		cout<<ask(ls,rs)<<endl;
	}
	return 0;
}
```

---

## 作者：孑彧 (赞：12)

# P2709 小B的询问 解题报告

### 题目描述

小B有一个序列，包含N个1~K之间的整数。他一共有M个询问，每个询问给定一个区间[L..R]，求$\sum c_i^2$的值,其中i的值从1到K，其中c(i)表示数字i在[L..R]中的重复次数。小B请你帮助他回答询问。

### 思路

这是一道明显的莫队裸题

想学莫队的同学可以看一下[这位大佬的博客](https://wwwcnblogs.com/WAMonster/p/10118934.html)

我自己的博客连接以后再补上

简而言之的说，莫队就是一个通过对询问进行排序，然后通过左右端点的移动来维护区间信息的**离线算法**

所以说一些强制在线的题目是无法用莫队做的

然后莫队还有很多的扩展，像是带修莫队，回滚莫队等等

所以莫队有什么用呢？

想一想线段树和树状数组

他们一个只能维护满足区间可加性的信息，另一个只能维护满足区间可减性的信息

假如说维护的东西既不可加又不可减呢？（像是这道题

莫队算法应运而生

这道题就很适合用莫队维护（不像HH的项链竟然会卡莫队

然后只要在移动左右端点的时候顺手维护一下当前的总和就好了！

### 代码

```c++
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#define maxn 1100000
using namespace std;
int c[maxn],cnt[maxn],ans;
int n,m,k,len;
int num[maxn];
inline int read(){
	register int x=0,t=1;
      register char ch=getchar();
      while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
      if(ch=='-'){t=-1;ch=getchar();}
      while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
      return x*t;
}
inline void write(int x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9){
		write(x/10);
	}
	putchar(x%10+'0');
}
struct Query{
	int l,r,in,id;
	inline bool operator < (const Query &a)const{
		if(!(in^a.in)){
			return (in&1)?r<a.r:r>a.r;
		}
		return in<a.in;
	}
}q[maxn];
inline void ins(int x){
	ans-=cnt[c[x]]*cnt[c[x]];
	cnt[c[x]]++;
	ans+=cnt[c[x]]*cnt[c[x]];
}
inline void del(int x){
	ans-=cnt[c[x]]*cnt[c[x]];
	cnt[c[x]]--;
	ans+=cnt[c[x]]*cnt[c[x]];
} 
int main(){
	n=read();
	m=read();
	k=read();
	len=sqrt(n);
	for(register int i=1;i<=n;++i){
		c[i]=read();
	}
	int x,y;
	for(register int i=1;i<=m;++i){
		x=read();
		y=read();
		q[i].l=x;
		q[i].r=y;
		q[i].in=(x-1)/len+1;
		q[i].id=i;
	}
	sort(q+1,q+1+m);
	int l=1,r=0;
	for(register int i=1;i<=m;++i){
		x=q[i].l;
		y=q[i].r;
		while(l<x)del(l),++l;
		while(l>x)ins(l-1),--l;
		while(r<y)ins(r+1),++r;
		while(r>y)del(r),--r;
		num[q[i].id]=ans;
	}
	for(register int i=1;i<=m;++i){
		write(num[i]);
		printf("\n");
	}
	return 0;
}
```





---

## 作者：Baihua (赞：11)

### [题解]洛谷P2709 小B的询问

[地址](https://www.luogu.org/problemnew/show/P2709)

是一道莫队模板题。

---

* 分析

  * 设$\text{vis[i]}$表示元素$\text{i}$出现的次数
  * 当一个元素进入莫队时，它对答案的贡献增加。有 
  $\delta Ans=(X+1)^2-X^2=2X+1$
  * 注意莫队中得到的答案是乱序的。需要一个辅助数组实现顺序输出。

* 注意事项

  * 利用奇偶优化可以提高效率。具体来说，在排序中：
    * 两个元素$\text{X,Y}$有$X.Left≠Y.left$，以$\text{Left}$为第一关键字。
    * 否则讨论$\text{Left}$的奇偶性，分别对$\text{Right}$正序或倒序
  * 使用$\text{O2}$优化

* Code

  ```c++
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <math.h>
  #define Clean(X,K) memset(X,K,sizeof(X))
  #define GC getchar()
  #include <algorithm>
  using namespace std ;
  const int Maxn = 50005 ;
  int Qread () {
  	int X = 0 , F = 1;
  	char C = GC ;
  	while (C > '9' || C < '0') {
  		if (C == '-') F = -1 ;
  		C = GC ;
  	}
  	while (C >='0' && C <='9') {
  		X = X * 10 + C - '0' ;
  		C = GC ;
  	}
  	return X *F ;
  }
  int L = 1 , R = 1 , Ans[Maxn] , N , K , M , A[Maxn] , Vis[Maxn] , Now = 1;
  struct Node {
  	int Left , Right , Place;
  };
  Node B[Maxn] ;
  bool Cmp (const Node &X , const Node &Y) {
  	if (X.Left != Y.Left ) return X.Left < Y.Left ;
  	if (X.Left & 1) return X.Right  < Y.Right  ;
  	return X.Right > Y.Right ;
  }
  int main () {
  //	freopen ("P2709.in" , "r" , stdin) ;
  	N = Qread () , M = Qread () , K = Qread () ;
  	for (int i = 1 ; i <= N; ++ i) A[i] = Qread () ;
  	for (int i = 1 ; i <= M; ++ i) B[i].Left = Qread () , B[i].Right = Qread () , B[i].Place = i;
  	std :: sort (B + 1 , B + 1 + M , Cmp) ;
  	Clean (Vis , 0) ;
  	Vis[A[1]] = 1 ;
  	for (int i = 1 ; i <= M; ++ i) {
  		while (B[i].Left > L) {
  			-- Vis[A[L]] ;
  			Now -= (Vis[A[L]] << 1) + 1;
  			++ L ;
  		}
  		while (B[i].Right > R) {
  			++ R ;
  			Now += (Vis[A[R]] << 1) + 1;
  			++ Vis[A[R]] ;
  		}
  		while (B[i].Right < R) {
  			-- Vis[A[R]] ;
  			Now -= (Vis[A[R]] << 1) + 1;
  			-- R ;
  		}
  		Ans[B[i].Place ] = Now ;
  	}
  	for (int i = 1 ; i <= M; ++ i) printf ("%d\n" , Ans[i]) ;
  	fclose (stdin) , fclose (stdout) ;
  	return 0 ;
  }
  ```

  #### Thanks！

---

## 作者：Manjusaka丶梦寒 (赞：7)

推荐博客：https://www.cnblogs.com/rmy020718/p/9439729.html

无修改的莫队几乎没有什么太高深的套路，比较模板吧，大多都是在那两个函数上动手脚。

这题询问每一种数字数量的平方和，那么我们在左移或右移的时候记录一下就好了，当每一种数字的种类数加1或减1的时候，我们需要减去以前这个数对答案的影响，加上现在对答案的影响。

假设原来数字a的种类数为k，如今又加入一个a，那么先ans-=k^2,然后ans+=(k+1)^2.,删除同理。

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#define N int(5e5+2)
#define M int(2e5+2)
using namespace std;
struct ahah{
    int L,R,p,f;
}ask[N];
int answer,n,m,q,a[N],cnt[N],ans[N],k;
bool cmp(ahah a,ahah b){ return a.p<b.p; }
bool comp(ahah a,ahah b){ return a.L/k==b.L/k?a.R<b.R:a.L<b.L; }
void remove(int pos)
{
    answer-=cnt[a[pos]]*cnt[a[pos]],--cnt[a[pos]],answer+=cnt[a[pos]]*cnt[a[pos]]; 
}
void add(int pos)
{
    answer-=cnt[a[pos]]*cnt[a[pos]],++cnt[a[pos]],answer+=cnt[a[pos]]*cnt[a[pos]]; 
}
int main()
{
    scanf("%d%d%d",&n,&q,&m);
    k=sqrt(n);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1;i<=q;i++)scanf("%d%d",&ask[i].L,&ask[i].R),ask[i].p=i;
    sort(ask+1,ask+1+q,comp);
    int curl=1,curr=0;
    for(int i=1;i<=q;i++)
    {
        int L=ask[i].L,R=ask[i].R;
        while(curl<L)remove(curl++);
        while(curl>L)add(--curl);
        while(curr<R)add(++curr);
        while(curr>R)remove(curr--);
        ans[ask[i].p]=answer;
    }
    for(int i=1;i<=q;i++)printf("%d\n",ans[i]-1);    //here很神,发现不改比样例都大1 
}
```

---

## 作者：Honor誉 (赞：5)

这题其实是一个非常模板的无修改的莫队。

说下思路：

我们可以拿一个mp数组记录在一个区间内各种颜色出现的个数，然后就是跑一遍普通莫队。（加减时要注意平方）。

l记得要从1开始。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct data
{
    int x,y,id,ans;
}a[50010];
int gg,n,m,k,c[50010],b[50010],mp[50010],l=1,r,ans;
bool operator < (data a,data b)
{
    if(c[a.x]==c[b.x])
    {
        return a.y<b.y;
    }
    return a.x<b.x;
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    gg=pow(n,0.54);//据说是最快的分块方式
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&b[i]);
        c[i]=(i-1)/gg+1;
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&a[i].x,&a[i].y);
        a[i].id=i;
    }
    sort(a+1,a+m+1);
    for(int i=1;i<=m;i++)//处理（平方）
    {
        while(l<a[i].x)
        {
            ans-=mp[b[l]]*mp[b[l]];
            mp[b[l]]--;
            ans+=mp[b[l]]*mp[b[l]];
            l++;
        }
        while(l>a[i].x)
        {
            l--;
            ans-=mp[b[l]]*mp[b[l]];
            mp[b[l]]++;
            ans+=mp[b[l]]*mp[b[l]];
        }
        while(r>a[i].y)
        {
            ans-=mp[b[r]]*mp[b[r]];
            mp[b[r]]--;
            ans+=mp[b[r]]*mp[b[r]];
            r--;
        }
        while(r<a[i].y)
        {
            r++;
            ans-=mp[b[r]]*mp[b[r]];
            mp[b[r]]++;
            ans+=mp[b[r]]*mp[b[r]];
        }
        a[a[i].id].ans=ans;//按id来给答案
    }
    for(int i=1;i<=m;i++)//输出
    {
        printf("%d\n",a[i].ans);
    }
    return 0;
}
```

---

## 作者：Drinkwater (赞：5)

没有题解赶快发一波

莫队算法

这题很裸，如果不懂得看这篇博客<http://blog.csdn.net/wt\_cnyali/article/details/54897102>

推广一下，简单来说，莫队算法就是对讯问分块这类的，用两个指针来处理，下面是代码

/*************************************************************************

    > Author: Drinkwater-cnyali
    > Created Time: 2017/3/28 19:48:43
************************************************************************/
















```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long LL;
#define REP(i, a, b) for(register int i = (a), i##_end_ = (b); i <= i##_end_; ++ i)
#define DREP(i, a, b) for(register int i = (a), i##_end_ = (b); i >= i##_end_; -- i)
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define mem(a, b) memset((a), b, sizeof(a))
template<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }
template<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }
int read()
{
    int sum = 0, fg = 1; char c = getchar();
    while(c < '0' || c > '9') { if (c == '-') fg = -1; c = getchar(); }
    while(c >= '0' && c <= '9') { sum = sum * 10 + c - '0'; c = getchar(); }
    return sum * fg;
}
const int maxn = 100000;
const int inf = 0x3f3f3f3f;
int num;
struct Block
{
    int L,R,id;
    bool operator < (const Block &u)const
    {
        return (L / num) == (u.L / num) ? R < u.R : L < u.L;
    }
}B[maxn];
int n,m,k,a[maxn],cnt[maxn],ans,res[maxn];
void add(int pos)
{
    ans += (cnt[a[pos]]++)<<1|1;
}
void remove(int pos)
{
    ans -= (--cnt[a[pos]])<<1|1;
}
void Captainmo()
{
    int l = 1,r = 0;
    REP(i,1,m)
    {
        int L = B[i].L,R = B[i].R;
        while(l < L)remove(l++);
        while(l > L)add(--l);
        while(r > R)remove(r--);
        while(r < R)add(++r);
        res[B[i].id] = ans;
    }
}
int main()
{
    n = read(), m = read(), k = read();
    REP(i,1,n)a[i] = read();
    REP(i,1,m)
    {
        B[i].L = read(), B[i].R = read();
        B[i].id = i;
    }
    num = 250;
    sort(B+1,B+1+m);
    Captainmo();
    REP(i,1,m)printf("%d\n",res[i]);
    return 0;
}
```

---

## 作者：Kwork (赞：5)

二分。首先按照结束时间升序排序，然后二分结束时间小于区间的左顶点的第一个值的位置，同理按照开始时间排序，然后二分，最后我们可以通过这样来知道于查询区间有交际的反应个数


---

## 作者：yangrunze (赞：3)

在这篇题解里，我们将要认识一位新朋友——**莫队算法**

一听这名字，是不是感觉非常高大上呢？其实呀，莫队算法它并没有那么神秘，它的核心思想其实是我们最喜欢的——**暴力**！不光是暴力，还是**非常的暴力**

那莫队算法到底是怎么暴力的呢？？？它非常适用于**区间**有关的问题！它的思想就是：我们算出一个答案之后，**通过移动左右端点，来制造出新的答案**

也就是说，我们的核心代码是这样的：

```cpp
ansl=1,ansr=0;//ansl,ansr记录上次的答案，一开始这样赋初值是为了防止数组越界
for(register int i=1;i<=m;i++){
        int left,right;//left,right就是这次的询问  
        cin>>left>>right;
	//接下来的4个while循环就是把ansl和ansr移动到l和r上，并对答案c进行相应修改，要注意先移动ans还是先修改 
      	while(ansl>left)
	ansl--,ins(a[ansl]); //为了不加大括号，中间用逗号隔开，没有编译错误
	while(ansr<right)
    	ansr++,ins(a[ansr]);
	while(ansl<left)
	del(a[ansl]),ansl++;//ins是插入操作，del是删除操作，这俩函数怎么写一会讲（特别简单）
	while(ansr>right)
	del(a[ansr]),ansr--;
	cout<<c<<endl;
	}
```

这个思路是不是很妙呢？但是只是这样还不够，还有一个致命的弱点，是什么呢？？？请看下面的栗子：

|  |  |
| :----------: | :----------: |
| 第1次询问 |50，50  |
|  第2次询问|1，10000  |
| 第3次询问 |250，360  |
| 第4次询问 | 9998，9999 |
| ...... |......  |

要是数据真的弄成这样，每次移动的跨度太大了，那岂不是要累死ansl和ansr这俩“搬运工”？这时，同学们也许发现了：有好多都是**移过去，再移回来**的。这样的话就浪费了很多时间。

那怎么办？有了！我们把所有询问都**存起来，排个序，先处理移动跨度小的**就行啦！顺便一提，像这种**需要把询问先存起来再处理的算法**，叫**离线算法**，莫队就是离线算法之一

好，说干就干~咱们怎么排呢，**按左端点排**？？？

|  |  |
| :----------: | :----------: |
| 第1次询问 |1，2  |
|  第2次询问|2，10000  |
| 第3次询问 |3，4  |
| 第4次询问 | 6，233333 |
| ...... |......  |

这确实是按照左端点排的，但是.....你懂得

不过我们通过这个错误示范可以看出，**好多左端点差的都不大，可以放一块**。所以我们又想到了一个新操作：那就是**分块**！

分块是啥？千万不要懵，顾名思义，就是把**数组分成好几块，相同块都排在一起**

到底分成几块呢？？？悄悄告诉你：最好**分成**$\sqrt{n}$**块就好啦**

why？？？先给大家抛出一个很常见的不等式：**基本不等式**

$$a+b \geq 2 \sqrt{ab}(a>0,b>0)$$

为啥这个式子成立呢？

$$(a-b)^2 \geq 0$$
$$(a+b)^2-4ab\geq 0$$
$$(a+b)^2\geq 4ab$$
$$a+b\geq 2\sqrt{ab}$$

所以这个式子肯定是成立的~并且呢，它还有一个神奇性质：**当且仅当a=b时，等号成立**

再回来看这个分块，**假设要分成 $b$ 块，那每块就有 $\frac{n}{b}$ 个数**，我们肯定要让它们的和小一些！或许数学好的同志们应该知道了：这不就是**基本不等式求最值**的典型题目嘛！不知道是啥？没关系：

$$b+\frac{n}{b} \geq 2 \sqrt{b\times\frac{n}{b}}$$

$$b+\frac{n}{b} \geq 2 \sqrt{n}$$

并且，取等号（最小值）时：

$$b=\frac{n}{b}$$
$$b^2=n$$
$$b=\sqrt{n}$$

所以分块最好要这么分嘛....有了这个思路，我们就可以把排序的cmp函数写出来了

```cpp
struct question{//用来存储提问
	int start,end,id;  //提问的区间以及编号
}modui[50005];
int a[50005];
int block;//分成几块（就是根号n）
inline bool cmp(question x,question y){  //cmp函数
	if(x.start/block==y.start/block)  //如果左端点在同一个块里
	return x.end<y.end;//按右端点排
	else return x.start/block<y.start/block;//否则按左端点所在的块排
}
```
最后的最后，就是插入和删除的函数怎么写了，由于这个题是跟**出现次数**有关的，所以我们要用类似桶排序的方法，统计一下出现的次数，建立一个桶排序用的数组b以及答案c来统计。

那么问题来了，当x的出现次数变化时，c会怎么变呢？？？

不难发现：对于平方数列：
$$1,4,9,16,25,......$$

它们每两项的差是：
$$1,3,5,7,9......$$

所以这整个就是一个奇数的序列嘛，数量$x$每加$1$，答案$c$就加$2x+1$，同理，$x$每减$1$，$c$就减$2x-1$

所以函数就写出来了：
```cpp
inline void ins(int x){//插入
	c+=b[x]*2+1;
	b[x]++;
}
inline void del(int x){//删除
	c-=b[x]*2-1;
	b[x]--;
}
```
最后完整代码就不难写了吧，拿着刚才的东西七拼八凑一番就能拼出来：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
typedef long long ll;
inline ll read(){
	char c=getchar();
	ll f=1,x=0;
	while(c<'0'||c>'9'){
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+(c^'0');
		c=getchar();
	}
	return x*f;
}
struct question{
	int start,end,id;
}modui[50005];
ll ans[50005];
int a[50005],b[50005];
int n,m,k,block,c;
inline bool cmp(question x,question y){
	if(x.start/block==y.start/block)
	return x.end<y.end;
	else return x.start/block<y.start/block;
}
inline void ins(int x){
	c+=b[x]*2+1;
	b[x]++;
}
inline void del(int x){
	c-=b[x]*2-1;
	b[x]--;
}
int main(){
	n=read(),m=read(),k=read();
	block=(int)sqrt(n);
	for(register int i=1;i<=n;i++)
		a[i]=read();
	for(register int i=1;i<=m;i++){
		modui[i].start=read();	
		modui[i].end=read();
		modui[i].id=i;
	}
	sort(modui+1,modui+1+m,cmp);
	int ansl=1,ansr=0,left,right;
	for(register int i=1;i<=m;i++){
		left=modui[i].start;
		right=modui[i].end;
		while(ansl>left)
		ansl--,ins(a[ansl]);
		while(ansr<right)
		ansr++,ins(a[ansr]);
		while(ansl<left)
		del(a[ansl]),ansl++;
		while(ansr>right)
		del(a[ansr]),ansr--;
		ans[modui[i].id]=c;
	}
	for(register int i=1;i<=m;i++)
	printf("%d\n",ans[i]);
	return 0;
}
```
### The  End

---

## 作者：cirnovsky (赞：3)

# 0x00

```cpp
// 我把这题当做莫队模板应该没问题吧...
```

# 0x01

考虑这样一个问题：

对于一个序列$A_1,A_2,\cdots,A_n$，有如下询问

形如$S\ \ l\ \ r$的命令表示对区间$[l,r]$求和，并输出

形如$Q\ \ l\ \ r$表示$\cdots$

本题不强制在线

对于这样的静态问题，我们可以考虑用莫队来解决。据说莫队支持修改~~但我太弱不会~~

现在你有区间$[3,5]$的和，可以求$[3,6]$的区间和吗？显然，将$[3,5]$的区间和加上$A_6$即可。类似的，求$[2,4]$的区间和，我们只需减去$A_5$即可。

可以结合下图感知一下

![spfa.png](https://i.loli.net/2020/01/05/b63tfzYDl7VwdXC.png)

![spfa.png](https://i.loli.net/2020/01/05/uAa95JElrb7kCxQ.png)

# 0x02

好，接下来我们想一下如何维护这种询问之间的关系。

很容易想到排序，首先我们对询问的左端点进行排序。再把整个`询问`序列分为$\sqrt{n}$块，每块以内再按右端点排序。

所以我们可以得出以下结论：

-	莫队就是对于一系列的询问，通过排序减小询问的之间的差距，然后以计算贡献的方法离线的得出答案

# 0x03

来一道简单的例题

### 小B的询问

小B 有一个长为 $n$ 的整数序列 $a$，值域为 $[1,k]$。  
他一共有 $m$ 个询问，每个询问给定一个区间 $[l,r]$，求：  


其中 $c_i$ 表示数字 $i$ 在 $[l,r]$ 中的出现次数。  
小B请你帮助他回答询问

----

这道题让我们求

$$\sum\limits_{i=1}^k c_i^2$$

开一个桶，计算每个数出现的次数，所以我们可以由此计算答案的贡献，就可以写出以下的代码

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
#include <cmath>

using namespace std;

const int SIZE = 5e4 + 5;
struct QueryNode {
	int l, r;
	int id; // 储存询问的顺序，方便输出
} Q[SIZE];
int a[SIZE], n, m, k, pos[SIZE];
int cnt[SIZE], ans[SIZE], res;

// a:原序列
// pos:每个位置所处的块
// cnt:桶
// ans:询问的答案
// res:每次调整所得到的贡献

inline void add(int x) { cnt[a[x]]++, res += cnt[a[x]] * cnt[a[x]] - (cnt[a[x]] - 1) * (cnt[a[x]] - 1); }

inline void del(int x) { cnt[a[x]]--, res -= (cnt[a[x]] + 1) * (cnt[a[x]] + 1) - cnt[a[x]] * cnt[a[x]]; }

signed main() {
	scanf("%d %d %d", &n, &m, &k);
	int block = sqrt(n);
	for (int i = 1; i <= n; ++i) scanf("%d", &a[i]), pos[i] = i / block;
	for (int i = 1; i <= m; ++i) scanf("%d %d", &Q[i].l, &Q[i].r), Q[i].id = i;
	sort(Q + 1, Q + 1 + m, [](QueryNode x, QueryNode y) { return pos[x.l] ^ pos[y.l] ? pos[x.l] < pos[y.l] : x.r < y.r; });
	int l = 1, r = 0;
	for (int i = 1; i <= m; ++i) {
		while (l > Q[i].l) add(--l); // 这四句都是在对当前的区间对于询问的区间进行调整
		while (r < Q[i].r) add(++r); // 这三句都是在对当前的区间对于询问的区间进行调整
		while (l < Q[i].l) del(l++); // 这二句都是在对当前的区间对于询问的区间进行调整
		while (r > Q[i].r) del(r--); // 这一句都是在对当前的区间对于询问的区间进行调整
		ans[Q[i].id] = res;
	}
	for (int i = 1; i <= m; ++i) printf("%d\n", ans[i]);
	return 0;
}
```

# 0x04

其实莫队是有套路的，基本上莫队的题都是这样的:

```cpp
	for (int i = 1; i <= m; ++i) {
		while (l > Q[i].l) add(--l);
		while (r < Q[i].r) add(++r);
		while (l < Q[i].l) del(l++);
		while (r > Q[i].r) del(r--);
		ans[Q[i].id] = res;
	}
```

我们只需考虑$add$函数以及$del$函数即可

---

## 作者：gyh20 (赞：3)

# 莫队模版

用cnt[i]保存在当前查找的u到v的区间中i出现的次数，由完全平方公式

#### （a+1)^2=a^2+2a+1

得i每增加1答案就增加2i+1

####  (a-1)^2=a^2-2a+1

得i每减少1答案就减少2i-1

其它的东西和普通莫队没有区别，只是注意i，cnt[i],ans的变化顺序，还需要自己好好思考。

代码如下：
```c
#pragma GCC optimize(200000)
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
struct jyt {
	long long  l,r,p;
} a[500005];

long long  read() {
	char v=getchar();
	long long  s=0;
	while(v<'0'||v>'9')v=getchar();
	while(v>='0'&&v<='9') {
		s=(s<<3)+(s<<1)+v-'0';
		v=getchar();
	}
	return s;
}
long long  n,m,k,b,c,d,w[50005],u,v,t,cnt[50005],o,ans[50005],ans1;
bool cmp(jyt x,jyt y) {//jyt大佬
	return x.l/m==y.l/m?x.r<y.r:x.l<y.l;
}
int main() {
//	freopen("c.in","r",stdin);
//	freopen("c.out","w",stdout);
	n=read();
	k=read();
	o=read();
	m=ceil(sqrt(n));
	for(long long  i=1; i<=n; ++i)w[i]=read();
	for(long long  i=1; i<=k; i++) {
		a[i].l=read();
		a[i].r=read();
		a[i].p=i;
	}
	sort(a+1,a+k+1,cmp);
	u=1;
	v=1;
	ans1=0;
	cnt[w[1]]=1;
	for(long long  i=1; i<=k; i++) {

		while(v<a[i].r) {
			v++;
			cnt[w[v]]++;
			
			ans1+=2*cnt[w[v]]-1;

		}
		while(u>a[i].l) {
			u--;
			cnt[w[u]]++;
	
			ans1+=2*cnt[w[u]]-1;
		}
		while(u<a[i].l) {
			cnt[w[u]]--;
			ans1-=2*cnt[w[u]]+1;//因为cnt[w[u]]已经减了，所以这里减2*cnt[w[u]]+1
		
			u++;
		}
		while(v>a[i].r) {
			cnt[w[v]]--;
            ans1-=2*cnt[w[v]]+1;
	        v--;
		}
		
ans[a[i].p]=ans1;
	}

	for(long long  i=1; i<=k; i++)printf("%lld\n",ans[i]+1);
}
```


---

## 作者：Thomasguo666 (赞：2)

# 莫队板子题
## 什么是莫队
首先这道题，一种~~暴力~~优雅的思想是：维护两个指针$l,r$，每次一步步把这两个指针移动到当前要查询的序列。（具体怎么移动先不讲）

然后我们发现，具体有两种操作方式

- 每次都从0开始移动
	
	这样会做很多无用功，显然不行

- 每次都从上一个要查询的序列移动

	这样不确定的因素太多，时间炸不炸完全取决于回答问题的顺序。

	那么也就是说，需要找到一种合适的回答问题的顺序：

	1. 在线：按照题目所给的顺序

	这样题目可以让你从区间开头，移动到区间结尾，再动回来，显然不行。

	2. 离线：按照左端点/右端点排个序
    	
    这样l（或r）逐步往右，r（或l）乱动，也不行
        
    3. 离线：分块
    
    按左端点所在块排序，块内按右端点排序。
    
    这样l和r大多都是在块内动，复杂度得到了一定的保障。
    这就是莫队了。
    
具体到怎么移动，看代码：
```
void add(ll x) //l向左动/r向右动，此时显然是增加了一个元素
{
	ret+=2*++cnt[a[x]]+1;//(x+1)^2==x^2+2x+1=x^2+2(x+1)-1
}
```
```
void del(ll x)//l向右动/r向左动，此时显然是减少了一个元素
{
	ret-=2*--cnt[a[x]]+1;//(x-1)^2=x^2-[2(x-1)+1]
}
```
最终代码：

```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll a[50005],cnt[50005],t,len;
struct q
{
	int l,r,num;
	bool operator < (const q &rhs)
	{
		return l/len==rhs.l/len?r<rhs.r:l<rhs.l;
	}
} qs[50005];
ll ans[50005],ret,l=1,r;
void del(ll x)
{
	ret-=2*--cnt[a[x]]+1;
}
void add(ll x)
{
	ret+=2*++cnt[a[x]]-1;
}
int main()
{
	int n,m,k;
	cin>>n>>m>>k;
	t=sqrt(n);
	len=n/t;
	for (int i=1;i<=n;i++) cin>>a[i];
	for (int i=1;i<=m;i++) cin>>qs[i].l>>qs[i].r,qs[i].num=i;
	sort(qs+1,qs+m+1);
	for (int i=1;i<=m;i++) 
	{
		while (l<qs[i].l) del(l++);
		while (l>qs[i].l) add(--l);
		while (r<qs[i].r) add(++r);
		while (r>qs[i].r) del(r--);
		ans[qs[i].num]=ret;
	}
	for (int i=1;i<=m;i++) cout<<ans[i]<<endl;
	return 0;
}
```

---

## 作者：R·Buffoon (赞：2)

**莫队裸题**

初学莫队，拿来练手
***
刚开始看的时候一脸懵逼，Sigma(c(i)^2)是什么鬼？想了想，原来是$\Sigma_{i=1}^{k}c_{i}^2$，晕

对于一个数，它之前的出现次数为$x$，则它再次出现的贡献为

$(x+1)^2-x^2=2*x+1$

当它出现在区间时，加上它的贡献，反之则减

**Code:**

~~~cpp
#include<bits/stdc++.h>
#define RI register int
#define LL long long
using namespace std;

int in()
{
	int aa=0;char cc=getchar();
	for(;!isdigit(cc);cc=getchar());
	for(;isdigit(cc);cc=getchar())aa=(aa<<1)+(aa<<3)+(cc&15);
	return aa;
}

const int N=50005;

int n,m,k;
int l,r,ql,qr;
int sum,size;
int a[N],cnt[N],be[N];
LL ans[N],now;//答案可能会炸int，开long long

struct H
{
	int l,r,id,be;
}q[N];

inline int cmp(H x,H y)
{
	return (x.be!=y.be)?x.be<y.be:((x.be&1)?x.r<y.r:x.r>y.r);
}

int main()
{
	n=in(),m=in(),k=in();
	for(RI i=1;i<=n;++i) a[i]=in();
	size=sqrt(n);
	for(RI i=1;i<=m;++i) q[i].l=in(),q[i].r=in(),q[i].id=i,q[i].be=q[i].l/size;
	
	sort(q+1,q+1+m,cmp);
	
	l=q[1].l,r=q[1].l-1,now=0;//l,r的取值可以减少一些时间（也就一点点，大概1e-INF（逃））
	for(RI i=1;i<=m;++i)
	{
		ql=q[i].l,qr=q[i].r;
		while(l<ql) now-=(--cnt[a[l++]]<<1)+1;
		while(l>ql) now+=(++cnt[a[--l]]<<1)-1;
		while(r<qr) now+=(++cnt[a[++r]]<<1)-1;
		while(r>qr) now-=(--cnt[a[r--]]<<1)+1;
		ans[q[i].id]=now;
	}
	
	for(RI i=1;i<=m;++i) printf("%lld\n",ans[i]);
	
	return 0;
}
~~~
莫队的核心应该就是排序了，而排序的核心自然就是$cmp$喽，这里用了三目，用$if$就是
~~~cpp
if(x.be!=y.be) return x.be<y.be;
else if(x.be&1) return x.r<y.r;
else return x.r>y.r;
~~~
就是说如果不属于同一区块，按区块升序排序；同一区块的话，如果是奇数区块，按右端点升序排序，反之降序排序

关于这个按区块奇偶性排序，它的原理是
>右指针跳完奇数块往回跳时在同一个方向能顺路把偶数块跳完，然后跳完这个偶数块又能顺带把下一个奇数块跳完。

不理解？没事，会用就行（~~我其实也不大懂~~）。

至于这段代码
~~~cpp
while(l<ql) now-=(--cnt[a[l++]]<<1)+1;
while(l>ql) now+=(++cnt[a[--l]]<<1)-1;
while(r<qr) now+=(++cnt[a[++r]]<<1)-1;
while(r>qr) now-=(--cnt[a[r--]]<<1)+1;
~~~
把它展开就是
~~~cpp
while(l>ql)l--,cnt[b[l]]++,ans+=2*cnt[b[l]]-1;
while(r<qr)r++,cnt[b[r]]++,ans+=2*cnt[b[r]]-1;
while(l<ql)cnt[b[l]]--,ans-=2*cnt[b[l]]+1,l++;
while(r>qr)cnt[b[r]]--,ans-=2*cnt[b[r]]+1,r--;
~~~
（白羽~~鸡~~zcy的码）

似乎合起来写可以降低常数？

关于莫队的学习，可以看看这篇[博客](https://www.cnblogs.com/WAMonster/p/10118934.html)，我也是靠这篇入门的（background是~~老司机~~珂朵莉哦）

---

## 作者：cmk666 (赞：1)

## 0、前言

首先……

这么明显的莫队题……

真的难吗？？？

---
# 题解 P2709 【小B的询问】

---
## 1、莫队是啥？

不多赘述，自行百度【[传送门](https://www.baidu.com/s?ie=utf-8&f=3&rsv_bp=1&rsv_idx=1&tn=baidu&wd=莫队&rsv_pq=afa31fd30005c0dc&rsv_t=ab79EAraQnR5mWUJF%2FEqH%2Bjnp1%2FLBtM0IkxRSCP9OcQt2fSNQt0Dt3%2Ba5vM&rqlang=cn&rsv_enter=1&rsv_dl=ts_0&rsv_sug3=6&rsv_sug1=6&rsv_sug7=101&rsv_sug2=1&prefixsug=modui&rsp=0&inputT=3104&rsv_sug4=3778&rsv_sug=1)】。

当然，你也可以看其他的题解。

简单来说，莫队就是求很多个区间和的**离线**算法，用到了**分块**和**排序**的想法，时间复杂度为$O(n\sqrt{\smash{n}})$，远远超过朴素算法的$O(nm)$。

## 2、关键处理

我们找一下某数平方的规律：
> $1^2=1$

> $2^2=4$

> $3^2=9$

> $4^2=16$

> $\cdots\cdots$

它们的差分别是：
> $4-1=3=2\times2-1$

> $9-4=5=3\times2-1$

> $16-9=7=4\times2-1$

> $\cdots\cdots$

**规律已经很明显了：$n^2-(n-1)^2=2\times n-1$**

利用这个规律写出核心代码：
```cpp
while ( l < ql ) nw -= 2 * ( ct[a[l++]]-- ) - 1;
while ( l > ql ) nw += 2 * ( ++ct[a[--l]] ) - 1;
while ( r < qr ) nw += 2 * ( ++ct[a[++r]] ) - 1;
while ( r > qr ) nw -= 2 * ( ct[a[r--]]-- ) - 1;
//注意优先级和思路
```
## 3、AC代码
```cpp
//评测设置：C++11 开启O2
#pragma GCC optimize(1)
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#define reg register //以上为优化
#include<bits/stdc++.h>
int a[1000001], ct[1000001], bl[1000001], an[1000001];
struct __ST
{
    int l, r, id;
}   q[1000001];
bool cmp(reg __ST __a, reg __ST __b) //比较函数
{
    return ( bl[__a.l] != bl[__b.l] ) ? bl[__a.l] < bl[__b.l] : ( ( bl[__a.l] % 2 ) ? __a.r < __b.r : __a.r > __b.r );
/*
按块排序，如果块相同按照左端点排序，如果左端点相同按右端点排序。

小小的优化：
对于左端点在同一奇数块的区间，右端点按升序排列，反之降序。
它的主要原理是：
右指针跳完奇数块往回跳时在同一个方向能顺路把偶数块跳完，
然后跳完这个偶数块又能顺带把下一个奇数块跳完。
*/
}
inline int read()  //快读
{
    reg int X = 0;
    reg short Y = 1;
    static char C = getchar();
    while ( ( C < '0' || C > '9' ) && C != '-' ) C = getchar();
    if ( C == '-' )
    {
        Y = -1;
        C = getchar();
    }
    while ( C >= '0' && C <= '9' )
    {
        X = ( X << 3 ) + ( X << 1 ) + ( C ^ 48 );
        C = getchar();
    }
    return X * Y;
} 
inline void write(reg int X)  //快写
{
    if ( X < 0 )
    {
        putchar('-');
        write(-X);
    }
    else
    {
        if ( X > 9 ) write(X / 10);
        putchar(X % 10 | 48);
    }
}
int main()
{
    reg int n, m, k, sz, bn, nw = 0, l = 1, r = 0, ql, qr;
    //读入N,M,K(其实K没有用)
    n = read();
    m = read();
    k = read();
    //分块开始
    sz = sqrt(n);
    bn = ceil((double)n / sz);
    for ( reg int i = 1 ; i <= bn ; i++ ) 
        for ( reg int j = ( i - 1 ) * sz + 1 ; j <= i * sz ; j++ ) bl[j] = i;
    //分块完成
    //读入小B的序列
    for ( reg int i = 1 ; i <= n ; i++ ) a[i] = read(); 
    //读入询问
    for ( reg int i = 1 ; i <= m ; i++ )
    {
        q[i].l = read();
        q[i].r = read();
        q[i].id = i;
    }
    std::sort(q + 1, q + m + 1, cmp); //排序
    for ( reg int i = 1 ; i <= m ; i++ )
    {
        ql = q[i].l;
        qr = q[i].r;
        //核心代码开始
        while ( l < ql ) nw -= 2 * ( ct[a[l++]]-- ) - 1;
        while ( l > ql ) nw += 2 * ( ++ct[a[--l]] ) - 1;
        while ( r < qr ) nw += 2 * ( ++ct[a[++r]] ) - 1;
        while ( r > qr ) nw -= 2 * ( ct[a[r--]]-- ) - 1;
        //核心代码结束
        an[q[i].id] = nw; //更新答案
    }
    //写答案
    for ( reg int i = 1; i <= m; i++ )
    {
        write(an[i]);
        putchar('\n');
    }
    return 0;
}
```
## 4、总结

0) 理解后食用更佳！

1) 这题中的k是木有用的（*~~会有警告，别管他~~*）。

2) 代码中加了~~很少很少~~中等数量的优化。

3) 评测信息：【[传送门](https://www.luogu.com.cn/record/28194727)】（你也可以看下面）
![评测图片](https://cdn.luogu.com.cn/upload/image_hosting/4o6jcom3.png)

可以看到时间在$23\thicksim31ms$之间，空间在$9.12\thicksim11.27MB$之间，~~十分~~还算完美。
 
4) 既然你都看完了，那么$\cdots\cdots$
# 给个赞再走呗！

---

## 作者：寒鸽儿 (赞：1)

[博客食用效果更佳](https://www.luogu.org/blog/oldherd/solution-P2709)  
关于莫队算法的简介：  
这是一种优化的暴力算法。我们按开头分块将区间排序，暴力地移动指针求解。每一块的大小可以为√n，也可以为n / (m * 2/3)  
莫队算法适用于能够O(1)维护删除一个点和增加一个点的题目内，复杂度为O(n√n + m√n)  
初始化将l = 1, r = 0.这样在它们移动到排序后的询问序列过程中的中间段分别被添加和删除各一次，正好抵消。  
```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>

using namespace std;

const int maxn = 50010, maxm = 50010;
int a[maxn], pos[maxn], c[maxn], ans;
struct query{
	int l, r, id, ans;
	bool operator < (const query &o) const { return pos[l] == pos[o.l] ? r < o.r : pos[l] < pos[o.l]; }
}q[maxm];

inline void add(int p) {
	ans -= c[a[p]] * c[a[p]]; c[a[p]]++; ans += c[a[p]] * c[a[p]];
}

inline void del(int p) {
	ans -= c[a[p]] * c[a[p]]; c[a[p]]--; ans += c[a[p]] * c[a[p]];
}

inline bool cmp1(query x, query y) {
	return x.id < y.id;	
}

int main() {
	int n, m, k;
	ans = 0;
	scanf("%d %d %d", &n, &m, &k);
	int block = (int)( n / (sqrt((double)m * 2 / 3)));
	for(int i = 1; i <= n; i++) scanf("%d", a+i);
	for(int i = 1; i <= n; i++) pos[i] = i / block;
	for(int i = 1; i <= m; i++) scanf("%d %d", &q[i].l, &q[i].r), q[i].id = i;
	sort(q+1, q+m+1);
	int l = 1, r = 0;
	for(int i = 1; i <= m; i++) {
		while(l < q[i].l) del(l++);
		while(l > q[i].l) add(--l);
		while(r < q[i].r) add(++r);
		while(r > q[i].r) del(r--);
		q[i].ans = ans;
	}
	sort(q+1, q+m+1, cmp1);
	for(int i = 1; i <= m; i++) printf("%d\n", q[i].ans);
	return 0;	
}
```  

---

## 作者：cirnovsky (赞：1)

# 0x01

考虑这样一个问题：

对于一个序列$A_1,A_2,\cdots,A_n$，有如下询问

形如$S\ \ l\ \ r$的命令表示对区间$[l,r]$求和，并输出

形如$Q\ \ l\ \ r$表示$\cdots$

本题不强制在线

对于这样的静态问题，我们可以考虑用莫队来解决。据说莫队支持修改~~但我太弱不会~~

现在你有区间$[3,5]$的和，可以求$[3,6]$的区间和吗？显然，将$[3,5]$的区间和加上$A_6$即可。类似的，求$[2,4]$的区间和，我们只需减去$A_5$即可。

可以结合下图感知一下

![spfa.png](https://i.loli.net/2020/01/05/b63tfzYDl7VwdXC.png)

![spfa.png](https://i.loli.net/2020/01/05/uAa95JElrb7kCxQ.png)

# 0x02

好，接下来我们想一下如何维护这种询问之间的关系。

很容易想到排序，首先我们对询问的左端点进行排序。再把整个`询问`序列分为$\sqrt{n}$块，每块以内再按右端点排序。

所以我们可以得出以下结论：

-	莫队就是对于一系列的询问，通过排序减小询问的之间的差距，然后以计算贡献的方法离线的得出答案

# 0x03

来一道简单的例题

### 小B的询问

小B 有一个长为 $n$ 的整数序列 $a$，值域为 $[1,k]$。  
他一共有 $m$ 个询问，每个询问给定一个区间 $[l,r]$，求：  


其中 $c_i$ 表示数字 $i$ 在 $[l,r]$ 中的出现次数。  
小B请你帮助他回答询问

----

这道题让我们求

$$\sum\limits_{i=1}^k c_i^2$$

开一个桶，计算每个数出现的次数，所以我们可以由此计算答案的贡献，就可以写出以下的代码

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
#include <cmath>

using namespace std;

const int SIZE = 5e4 + 5;
struct QueryNode {
	int l, r;
	int id; // 储存询问的顺序，方便输出
} Q[SIZE];
int a[SIZE], n, m, k, pos[SIZE];
int cnt[SIZE], ans[SIZE], res;

// a:原序列
// pos:每个位置所处的块
// cnt:桶
// ans:询问的答案
// res:每次调整所得到的贡献

inline void add(int x) { cnt[a[x]]++, res += cnt[a[x]] * cnt[a[x]] - (cnt[a[x]] - 1) * (cnt[a[x]] - 1); }

inline void del(int x) { cnt[a[x]]--, res -= (cnt[a[x]] + 1) * (cnt[a[x]] + 1) - cnt[a[x]] * cnt[a[x]]; }

signed main() {
	scanf("%d %d %d", &n, &m, &k);
	int block = sqrt(n);
	for (int i = 1; i <= n; ++i) scanf("%d", &a[i]), pos[i] = i / block;
	for (int i = 1; i <= m; ++i) scanf("%d %d", &Q[i].l, &Q[i].r), Q[i].id = i;
	sort(Q + 1, Q + 1 + m, [](QueryNode x, QueryNode y) { return pos[x.l] ^ pos[y.l] ? pos[x.l] < pos[y.l] : x.r < y.r; });
	int l = 1, r = 0;
	for (int i = 1; i <= m; ++i) {
		while (l > Q[i].l) add(--l); // 这四句都是在对当前的区间对于询问的区间进行调整
		while (r < Q[i].r) add(++r); // 这三句都是在对当前的区间对于询问的区间进行调整
		while (l < Q[i].l) del(l++); // 这二句都是在对当前的区间对于询问的区间进行调整
		while (r > Q[i].r) del(r--); // 这一句都是在对当前的区间对于询问的区间进行调整
		ans[Q[i].id] = res;
	}
	for (int i = 1; i <= m; ++i) printf("%d\n", ans[i]);
	return 0;
}
```

# 0x04

其实莫队是有套路的，基本上莫队的题都是这样的:

```cpp
	for (int i = 1; i <= m; ++i) {
		while (l > Q[i].l) add(--l);
		while (r < Q[i].r) add(++r);
		while (l < Q[i].l) del(l++);
		while (r > Q[i].r) del(r--);
		ans[Q[i].id] = res;
	}
```

我们只需考虑$add$函数以及$del$函数即可

---

## 作者：Santiego (赞：1)

### 思路

只要能想出$O(1)$的方式转移$[l,r]$，莫队就不难了。此题求区间$\sum_{i=1}^kcnt[i]^2$，那我们就$O(1)$更新就好了，先减去原来的贡献，更新`cnt[]`再加上现在的贡献，这样就更新完了。

如加入点`x`的更新：
```cpp
sum-=my_sqr(cnt[a[x]]);
++cnt[a[x]];
sum+=my_sqr(cnt[a[x]]);	
```


注意：莫队**小心初始化**，直接`l=0,r=0`等可能会炸。

### 例码

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
#define MAXN 50005
using namespace std;
int n,m,k,a[MAXN],block;
int cnt[MAXN],sum,ans[MAXN];
struct nod{
	int l,r,bid,qid;
} q[MAXN];
inline bool cmp(nod a, nod b){
	return ((a.bid^b.bid)?(a.l<b.l):((a.bid&1)?a.r<b.r:a.r>b.r));
}
inline int my_sqr(int x){
	return x*x;
}
inline int read(){
	char ch=getchar();int s=0;
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s;
}
inline void add(int x){
	sum-=my_sqr(cnt[a[x]]);
	++cnt[a[x]];
	sum+=my_sqr(cnt[a[x]]);
}
inline void del(int x){
	sum-=my_sqr(cnt[a[x]]);
	--cnt[a[x]];
	sum+=my_sqr(cnt[a[x]]);	
}
int main()
{
	n=read(),m=read(),k=read();
	block=n/sqrt(m*2/3);
	for(int i=1;i<=n;++i) a[i]=read();
	for(int i=1;i<=m;++i){
		q[i].l=read(), q[i].r=read();
		q[i].qid=i;
		q[i].bid=q[i].l/block;
	}
	sort(q+1, q+1+m, cmp);
	int l=1,r=1;
	sum=1;cnt[a[1]]=1;
	for(int i=1;i<=m;++i){
		int ql=q[i].l,qr=q[i].r;
		while(l<ql) del(l++);
		while(l>ql) add(--l);
		while(r<qr) add(++r);
		while(r>qr) del(r--);
		ans[q[i].qid]=sum;
	}
	for(int i=1;i<=m;++i) printf("%d\n", ans[i]);
	return 0;
}
```



---

## 作者：Nukxx (赞：0)

莫队模板题！

虽然说莫队最经典的题目还要数论文题[小Z的袜子](https://www.luogu.org/problemnew/show/P1494) 

但本蒟蒻觉得那道题转移有点恶心......

相比之下这道题更裸更易上手：

莫队的基本思想，就是假定我得到了一个询问区间[l,r]的答案，那么我可以在极短（通常是O(1)）的时间复杂度内得到[l+1,r]的答案——于是对于区间查询类的题目，我可以一次性读完所有询问之后来回转移，得到每一个区间的答案。

为了防止复杂度报表，莫队在排序时用了分块思想，具体证明和讲解可以去看大米饼的博客QwQ讲的我觉得是非常好啦。

下面是代码+注释：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int N=100010;

struct que{//用来存询问的结构体
    int l,r,id;//询问的左右端点 id表示是第几个询问
    ll res;//当前询问的答案
}q[N];

int n,m,k;

ll b[N],col[N],sum[N],ans,l,r,blo;
//b：分块数组 blo：分块大小
//col[i]:序列中第i个位置的数 
//sum[i]:col为i的数的总数

inline ll cal(ll x){return x*x;}
//用来计算平方

inline bool cmp(que x,que y){return b[x.l]==b[y.l]?x.r<y.r:x.l<y.l;}
//莫队精髓之一

inline bool cmp_id(que x,que y){return x.id<y.id;}
//就是排序用来输出答案的.....

inline void forza(int x,int w)
{
    ans-=cal(sum[col[x]]);//先将这个位置数的原来sum的平方减去
    sum[col[x]]+=w;//sum改变
    ans+=cal(sum[col[x]]);//然后加上新的sum
}
//莫队精髓二：转移
//排序和转移要好好揣摩
inline void init(){
    scanf("%d%d%d",&n,&m,&k);
    blo=(int)sqrt(n);
    for(register int i=1;i<=n;++i)
    {
        scanf("%lld",&col[i]);
        b[i]=(i-1)/blo+1;
    }
    for(register int i=1;i<=m;++i)
    {
        scanf("%d%d",&q[i].l,&q[i].r);
        q[i].id=i;
    }
    sort(q+1,q+m+1,cmp);
}//这都没啥 

inline void solve()
{
    l=1,r=0;//莫队精髓三：两个小指针来回跳，表示当前ans维护的区间左右端点
    //至于为什么初始化l=1，r=0，自己可以画画图揣摩一下——如果l从0开始，转移的时候会把sum[col[0]]这个不存在的数误认为存在
    for(register int i=1;i<=m;++i)
    {
        while(r<q[i].r)forza(r+1,1),r++;//如果当前区间右端点没到询问右端点，把r不停右移，并更新答案，下同
        while(r>q[i].r)forza(r,-1),r--;
        while(l<q[i].l)forza(l,-1),l++;
        while(l>q[i].l)forza(l-1,1),l--;
        q[i].res=ans;
    }
}

inline void output()
{
    sort(q+1,q+m+1,cmp_id);
    for(register int i=1;i<=m;++i)
    printf("%lld\n",q[i].res);
}//排序后输出

int main()
{
    init();
    solve();
    output();
    return 0;//简洁的主程序QwQ
}
```

---

## 作者：arfa (赞：0)

> ### 莫队

这里不讲莫队的思路,各路大神已经讲清楚了。我们讲一下如何~~卡常~~。

> ### $Status\ 1$

把正常的莫队交上去,[记录](https://www.luogu.org/record/show?rid=9715355)。

单个点$1784ms$。

> ### $Status\ 2$

把每一次询问的右边界$right[i]$从小到大改为从打到小,快了了一点。注意要把数组开小点。

$1522ms$。

> ### $Status\ 3$

如果分为$trunc(sqrt(n))$块不好,然后分别试着分为$n/6$和$n/10$块。

$1178ms/795ms$。

我们可以发现当$div$在这个时候时,越大,越快。[记录](https://www.luogu.org/record/show?rid=9715714)。

> ### $Status\ 4$

分别来看一下$/20$和$/30$的状态:

$533ms/618ms$ [记录](https://www.luogu.org/record/show?rid=9716214),整体没有$/10$的优越。

> ### $Status\ 5$

综合以上,我们$/15$。

得出[记录](https://www.luogu.org/recordnew/lists?pid=P2709)。

> ### $Code$

```pascal
// luogu-judger-enable-o2
var
    node_num,i,j,n,m,l,r,sum,k:longint;
    num:array[-1..51000] of longint;
    id,left,right,recf,ans:array[-1..51000] of longint;
        bucket:array[-1..51000] of longint;

procedure Sort(l,r:longint);
var
    i,j,s,t:longint;
begin
    i:=l; j:=r; s:=(l+r) div 2;
    repeat
        while ((recf[i]<recf[s])or((recf[i]=recf[s])and(right[i]>right[s]))) do inc(i);
        while ((recf[j]>recf[s])or((recf[j]=recf[s])and(right[j]<right[s]))) do dec(j);
        if i<=j then
        begin
            t:=recf[i];  recf[i]:=recf[j];   recf[j]:=t;
            t:=id[i];    id[i]:=id[j];       id[j]:=t;
            t:=left[i];  left[i]:=left[j];   left[j]:=t;
            t:=right[i]; right[i]:=right[j]; right[j]:=t;
            inc(i); dec(j);
         end;
    until i>=j;
    if i<r then Sort(i,r);
    if j>l then Sort(l,j);
end;

function Locate(node:longint):longint;
begin
    if node mod node_num=0 then
        exit(node div node_num);
    exit(node div node_num+1);
end;

procedure Ready;
begin
    read(n,m,k);
    node_num:=n div 15;
    for i:=1 to n do read(num[i]);
    for i:=1 to m do
    begin id[i]:=i; read(left[i],right[i]); recf[i]:=Locate(left[i]); end;

    Sort(1,m);
end;

procedure add(x:longint);
begin
    inc(bucket[x]);
    inc(sum,bucket[x]*2-1);
end;

procedure dim(x:longint);
begin
    dec(bucket[x]);
    dec(sum,bucket[x]*2+1);
end;

begin
    Ready;
    l:=1;
    r:=0;
    for i:=1 to m do
    begin
        while r<right[i] do begin  inc(r); add(num[r]); end;
        while r>right[i] do begin dim(num[r]); dec(r); end;
        while l<left[i] do begin dim(num[l]); inc(l); end;
        while l>left[i] do begin dec(l); add(num[l]); end;
        ans[id[i]]:=sum;
    end;

    for i:=1 to m do
        writeln(ans[i]);
end.

```




---

## 作者：汪锦程 (赞：0)

### 这道题用莫队算法（楼下已经说的很清楚了）

# 注意，这里说一个方便实用高效的莫队卡常技巧！

------------

大家在排序时大多数是这样的：


```cpp
bool operator<(const Q x)const{
    if(be[l]!=be[x.l])
        return l<x.l;
    return r<x.r;
}
```

而事实上我们可以换成下面的方法：


```cpp
bool operator<(const Q x)const{
    if(be[l]!=be[x.l])
        return l<x.l;
    if(be[l]&1)  //相当于 be[l]%2==1
        return r<x.r;
    return r>x.r;
}
```

这样一来，大约省掉1/4的常数。

因为当l移动到另外一个分块时，r的移动会非常明显。修改后这种情况会好很多。具体可以自己理解一下。

#### 看到好多人没写就来普及一下，请各位dalao勿喷。


---


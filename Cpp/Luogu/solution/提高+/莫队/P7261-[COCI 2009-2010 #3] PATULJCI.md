# [COCI 2009/2010 #3] PATULJCI

## 题目描述

白雪公主和 $n$ 个小矮人在森林里，当 $n$ 个小矮人在挖矿时，白雪公主在玩电脑。

每天早上，小矮人排成长长的队伍，去矿山挖矿。白雪公主在他们身边跑来跑去，拍下照片上传到她最喜欢的 App 上。

小矮人进入矿区后，白雪公主回到自己的房子里，翻看图片，挑选漂亮的图片。每个小矮人都有一顶彩色的帽子，有 $c$ 种不同的颜色。如果一张照片上有一半以上的帽子是同一种颜色，那就是漂亮的。换句话说，如果图片上有 $k$ 个小矮人，如果大于 $\dfrac{k}{2}$ 个小矮人有相同颜色的帽子，那就是漂亮的图片。

请求出第 $m$ 张图是否漂亮，如果漂亮，以什么颜色为主。

## 说明/提示

#### 数据规模及约定

- 对于 $30\%$ 的数据，$1 \le m < 10$，$3 \le n \le 3 \cdot 10^5$，$1 \le c \le 10^4$，$1 \le a \le b \le n$。
- 对于另外 $30\%$ 的数据，$1 \le m \le 10^4$，$3 \le n \le 3 \cdot 10^5$，$1 \le c < 10$，$1 \le a \le b \le n$。
- 对于 $100\%$ 的数据，$1 \le m \le 10^4$，$3 \le n \le 3 \cdot 10^5$，$1 \le c \le 10^4$，$1 \le a \le b \le n$。

#### 说明
翻译自 [COCI 2009-2010 #3 T5 PATULJCI](https://hsin.hr/coci/archive/2009_2010/contest3_tasks.pdf)，满分 120，每个测试点 12 分，共 10 个测试点。

## 样例 #1

### 输入

```
10 3
1 2 1 2 1 2 3 2 3 3
8
1 2
1 3
1 4
1 5
2 5
2 6
6 9
7 10
```

### 输出

```
no
yes 1
no
yes 1
no
yes 2
no
yes 3
```

# 题解

## 作者：iMya_nlgau (赞：17)

因为这是一道黄题，所以不用主席树或者莫队这些算法。

我们对每种颜色开一个 vector 存下该颜色出现位置的下标，这样给定一个区间 $[l,r]$ 和一个颜色 $c$ 我们就可以在 vector 里二分求出 $[l,r]$ 中 $c$ 出现的次数，具体地，`v[c]` 表示颜色 $c$ 下标的 vector，那么
```cpp
upper_bound(v[c].begin(),v[c].end(),r)-lower_bound(v[c].begin(),v[c].end(),l);
```
就是 $[l,r]$ 中 $c$ 出现的次数。

然后再考虑，如果一个颜色 $c$ 在长度为 $k$ 的区间里出现了超过 $\dfrac{k}{2}$ 次，那么我们在这个区间里随机 $t$ 次，每次随机一个位置，遇不到 $c$ 的概率小于 $\dfrac{1}{2^t}$，当 $t$ 取 $50$ 的时候这个概率大约是 $10^{-15}$，可以认为不可能发生。

所以对于每个询问 $[l,r]$，我们在 $[l,r]$ 中随机 $t$ 次，再判断每次随机到的颜色出现次数是否大于 $\dfrac{r-l+1}{2}$ 即可。

时间复杂度 $O(mt\log n)$，$t$ 为随机次数。$t$ 取 $20$ 的话我的代码是目前最优解。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cctype>
#include<vector>
#include<cstdlib>
#include<ctime>
using namespace std;

inline int read(){
	int x=0; char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) x=x*10+(c^'0'),c=getchar();
	return x;
}

const int maxn=3e5+10;
const int maxm=1e4+10;

int n,c,m,a[maxn];
vector<int> v[maxm];

inline int query(int l,int r){
	for(int t=1;t<=50;t++){
		int p=l+rand()%(r-l+1);
		int res=upper_bound(v[a[p]].begin(),v[a[p]].end(),r)
			-lower_bound(v[a[p]].begin(),v[a[p]].end(),l);
		if(res>(r-l+1)/2) return a[p];
	}
	return -1;
}

int main(){
	srand((unsigned)time(NULL));
	
	n=read(),c=read();
	for(int i=1;i<=n;i++)
		a[i]=read(),v[a[i]].push_back(i);

	for(int i=1;i<=c;i++) v[i].push_back(n+1);
	
	m=read();
	while(m--){
		int l=read(),r=read();
		int ans=query(l,r);
		if(~ans) printf("yes %d\n",ans);
		else puts("no");
	}
	
	return 0;
}
```

---

## 作者：ShwStone (赞：8)

# PATULJCI
Update on 2022/02/19 ：卡常大师的题解已被兔爷撤下，希望大家杜绝学术造假的不正之风；添加了部分思路。
## 一种无需回滚的莫队写法
首先看到题就可以想到莫队。最朴素的写法就是维护莫队区间中每一种颜色的出现次数，同时维护莫队区间中的最大值。然后你会发现：莫队区间缩小的时候没法维护。  
考试的时候就卡在这里了，然后写了一个线段树维护的带 $\log$ 莫队，不出意外地 $T$ 了。考完才知道是随机化二分，教练说回滚莫队也可以做，不过本蒟蒻不会，只好仔细端详了数据范围，然后发现 $O(mc)$ 的方法是可以过的，所以很容易想到暴力的莫队——用一个数组维护区间中每一种颜色的出现次数，但是不同步维护最大值，每次移动到目标区间之后再暴力扫一下每一种颜色，求出最大值。  
理论上1e8比较悬，但是常数小，跑得也挺快。啥优化都没加，[一个点300ms](https://www.luogu.com.cn/record/69607228) 。试了一下吸氧，总时间跑到了700ms。  
代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxc = 1e4 + 5, maxn = 3e5 + 5, maxm = 1e4 + 5;

struct node {
	int l, r;
	int id;
};

node quary[maxm];
int book[maxc], color[maxn], belong[maxn], anss[maxm];
int n, m, c, sqrtn;

bool compare(node a, node b) {
	return belong[a.l] != belong[b.l] ? belong[a.l] < belong[b.l] : (belong[a.l] & 1 ? a.r < b.r : a.r > b.r);
}

int main() {
	scanf("%d %d", &n, &c);
	sqrtn = pow(n, 0.5);
	for (int i = 1; i <= n; i++) {
		scanf("%d", color + i);
		belong[i] = i / sqrtn;
	}
	scanf("%d", &m);
	for (int i = 1; i <= m; i++) {
		scanf("%d %d", &quary[i].l, &quary[i].r);
		quary[i].id = i;
	}
	sort(quary + 1, quary + m + 1, compare);
	int l = 1, r = 0, maxi;
	for (int i = 1; i <= m; i++) {
		node q = quary[i];
		while (r < q.r) {
			r++;
			book[color[r]]++;
		}
		while (l > q.l) {
			l--;
			book[color[l]]++;
		}
		while (r > q.r) {
			book[color[r]]--;
			r--;
		}
		while (l < q.l) {
			book[color[l]]--;
			l++;
		}
		int maxid = 0;
		for (int j = 1; j <= c; j++) {
			if (book[j] > book[maxid]) maxid = j;
		}
		if (book[maxid] > (r - l + 1) >> 1) {
			anss[q.id] = maxid;
		}
		else anss[q.id] = -1;
	}
	for (int i = 1; i <= m; i++) {
		if (anss[i] == -1) printf("no\n");
		else printf("yes %d\n", anss[i]);
	}
	return 0;
}
```

---

## 作者：lemondinosaur (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P7261)

---
考虑 $O(mn)$ 的暴力不开O2很容易TLE

正解是用权值线段树记录一个区间出现多少个数，

如果开 $n$ 棵权值线段树就会超时，考虑用主席树实现

然后一个区间出现次数过半的众数当且仅当

左区间或右区间数字出现次数过半。

若左区间总出现次数过半，则右区间一定不可能产生贡献；

若右区间总出现次数过半，则左区间一定不可能产生贡献；

如果答案存在，那么这样在主席树上将答案区间缩小一定能找到答案

---
```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>
#define rr register
using namespace std;
const int N=300101;
inline signed iut(){
    rr int ans=0,f=1; rr char c=getchar();
    while (!isdigit(c)) f=(c=='-')?-f:f,c=getchar();
    while (isdigit(c)) ans=(ans<<3)+(ans<<1)+(c^48),c=getchar();
    return ans*f;
}
struct Chair{
    int w[N<<5],ls[N<<5],rs[N<<5],cnt;
    inline void build(int &rt,int l,int r){
        w[rt=++cnt]=0; rr int mid=(l+r)>>1;
        if (l<r) build(ls[rt],l,mid),build(rs[rt],mid+1,r); 
    }
    inline void update(int &rt,int l,int r,int k){
        rr int trt=++cnt,mid=(l+r)>>1;
        ls[trt]=ls[rt],rs[trt]=rs[rt],w[trt]=w[rt]+1,rt=trt;
        if (l==r) return;
        k<=mid?update(ls[trt],l,mid,k):update(rs[trt],mid+1,r,k);
    }
    inline signed query(int L,int R,int l,int r,int k){
    	if (l==r) return l;
    	rr int mid=(l+r)>>1;
    	if (w[ls[R]]-w[ls[L]]>k){
		    rr int ans=query(ls[L],ls[R],l,mid,k);
		    if (~ans) return ans;
	    }
    	if (w[rs[R]]-w[rs[L]]>k){
		    rr int ans=query(rs[L],rs[R],mid+1,r,k);
		    if (~ans) return ans;
	    }
		return 0;
    } 
}Tre;
int rt[N],n,m,k,a[N];
signed main(){
    n=iut(); k=iut();  Tre.cnt=0;
    for (rr int i=1;i<=n;++i) a[i]=iut();
    Tre.build(rt[0],1,k);
    for (rr int i=1;i<=n;++i)
        Tre.update(rt[i]=rt[i-1],1,k,a[i]);
    m=iut();
    for (rr int i=1;i<=m;++i){
        rr int l=iut(),r=iut(),z=(r-l+1)>>1;
        rr int t=Tre.query(rt[l-1],rt[r],1,k,z);
        if (t) printf("yes %d\n",t);
            else printf("no\n");
    }
    return 0;
}
```

---

## 作者：_Fontainebleau_ (赞：5)

## 题意

- 给定一个长度为 $n$ 的序列 $a$，$a$ 中每个元素小于等于 $c$。以及 $m$ 个询问。每次询问区间 $[l,r]$ 出现次数大于 $\dfrac{r-l+1}2$ 的数。若没有输出 $\texttt{no}$；否则输出 $\texttt{yes}$ 和这个数。

- $1\le{n}\le{3\times10^5}$，$1\le{m}\le10^4$，$1\le{c}\le10^4$。

## 做法

考虑到这题还没有根号的做法，我就来讲一讲莫队。

考试的时候知道是主席树裸题，但是打了一下发现主席树不会？于是就去想莫队。结果降智了，什么都想不起来。

回归到这道题，显然如果用普通莫队来做，我们发现 `add` 操作时很容易实现的，但是 `del` 操作却需要很高的时间复杂度。于是我们很自然的有两种做法：回滚莫队，数据结构套莫队。

### 回滚莫队

其实没有什么特别难的。比模板题还模板，具体看代码吧。

### 部分代码

```cpp
//Calc

inline int Calc(int l,int r)
{
	for(int i=l;i<=r;i++)	app[a[i]]=0;
	for(int i=l;i<=r;i++)
	{
		app[a[i]]++;
		if(app[a[i]]<<1>(r-l+1))	return a[i];
	}
	return -1;
}

// 莫队部分

for(int i=1,j=1;j<=bl[n];j++)
{
	int k=min(n,blo*j),l=k+1,r=k,res=0,tmp,tot=0;
	while(bl[q[i].l]==j)
	{
		if(bl[q[i].r]==j){ans[q[i].id]=Calc(q[i].l,q[i].r),i++;continue;}
		while(r<q[i].r)
		{
			r++;cnt[a[r]]++;
			if(cnt[a[r]]>cnt[res])	res=a[r];
		}
		tmp=res;
		while(l>q[i].l)
		{
			l--;cnt[a[l]]++;
			if(cnt[a[l]]>cnt[res])	res=a[l];
		}
		ans[q[i].id]=res;
		if(cnt[res]<=(r-l+1)/2)	ans[q[i].id]=-1;
		while(l<=k)	cnt[a[l]]--,l++;
		res=tmp,i++;
	}
	memset(cnt,0,sizeof(cnt));
}
```
### 分块+莫队

考场上没有想到怎么打分块，所以写了一个线段树，被 $O(nm)$ 吊着打。我们注意到莫队有 $O(m\sqrt{n})$ 次指针移动/单点修改，$O(m)$ 次查询。所以可以想到用一个单点 $O(1)$，查询 $O(\sqrt{c})$ 的数据结构来平衡，这就是 **分块**。

其实，仔细想一想这一题的分块，有两个思路。

第一个思路是，既然要我求出现次数大于一半的数，那么它肯定是当前出现次数最多的，也就是 $O(1)$ 单点修改，$O(\sqrt{n})$ 查询 $\max$，用权值分块维护出现次数，但是，这样貌似没法求出这个数是什么。所以我们换一个思路。

注意到，**如果一个数出现次数大于一半，那么没有别的数出现次数大于一半！**
也就是说，我们只需要一个普通的分块，用一个 `tag` 维护块内元素和。相同的结论，如果一个块内元素出现次数大于一半，那么别的块内元素出现次数就不可能大于一半。所以至多会遍历一个块内元素。从而 $O(\sqrt{c})$ 的复杂度得到保证。

代码写起来比回滚莫队还短，开了 O2 比回滚莫队还快？

### 部分代码

```cpp
struct block{
	int blo,tg[202],vl[10004],bl[10004];
	inline void init(){blo=sqrt(c);for(int i=1;i<=c;i++)bl[i]=(i-1)/blo+1;}
	inline void modify(int pos,int val){tg[bl[pos]]+=val,vl[pos]+=val;}
	inline int query(int l)
	{
		for(int i=1;i<=bl[c];i++)
			if(tg[i]<<1>l)
				for(int j=(i-1)*blo+1;j<=min(c,i*blo);j++)
					if(vl[j]<<1>l)	return j;
		return -1;
	}
}FK;
```



------------
要注意的是，询问的是区间 $[l,r]$ 出现次数大于 $\dfrac{r-l+1}2$ 的数，$\dfrac{r-l+1}2$ 没有向下取整，所以判断时不要写成 `>(r-l+1)/2`！


---

## 作者：CmsMartin (赞：5)

[更好的阅读体验](http://www.cmsblog.top/archives/coci2009-20103patuljci?token=4aedae1db4f9498cb511d1060dd9bd46)

## 题目描述

[题目传送门](https://www.luogu.com.cn/problem/P7261)

## 思路

**由于我特别喜欢暴力数据结构，于是我就用分块 AC 了这道题。**

显然我们可以按照 $\sqrt n$ 为一块，将颜色分块，对每一块统计出每种颜色的数量，对于每一次询问，我们对完整块 $O(c)$ 累加，块外元素暴力累加。最后扫一遍结果得出答案。时间复杂度 $O(cm\sqrt n)$

但是按照 $\sqrt n$ 分块实测会 TLE（[记录](https://www.luogu.com.cn/record/69635648)），所以我们使用分块的黑科技，以 $\frac{n}{\log_2n}$ 分块，实测吸氧后跑得飞快（[记录](https://www.luogu.com.cn/record/69636103)） ，时间复杂度 $O(cm\log n)$ 。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Color {
    int ToT[30010];
};

Color Mp[650];
int ToT[30010];
int N , C , K , M , l , r;
int Num[300010];

void Query(int l , int r) {
    memset(ToT , 0 , sizeof ToT);
    for(int i = l; i <= r; ) {
        if(i % K == 1 && i + K <= r) {
            for(int p = 1; p <= C; p++) {
                ToT[p] += Mp[i / K + 1].ToT[p];
            }
            i += K;
        }
        else if(i % K == 1) {
            for(int j = i; j <= r; j++) {
                ToT[Num[j]]++;
            }
            break;
        }
        else if(i % K != 1) {
            while(i % K != 1) {
                ToT[Num[i]]++;
                i++;
                if(i > r) break;
            }
        }
    }
    for(int i = 1; i <= C; i++) {
        if(ToT[i] > ((double)(r - l + 1) / (double)2)) {
            cout << "yes " << i << endl;
            return;
        }
    }
    cout << "no" << endl;
}

int main() {
    ios::sync_with_stdio(false);
    cin >> N >> C;
    for(int i = 1; i <= N; i++) cin >> Num[i];
    K = N / log2(N);
    for(int i = 1 , tot = 1; i + K <= N; i += K , tot++) {
        for(int l = i; l <= N && l <= i + K - 1; l++) {
            Mp[tot].ToT[Num[l]]++;
        }
    }
    cin >> M;
    for(int i = 1; i <= M; i++) {
        cin >> l >> r;
        Query(l , r);
    }
    return 0;
}
```

---

## 作者：MrCR7 (赞：5)

这是一道黄题，挺经典的，暴力有一个点没过去，怎么办？

没关系，我们有 O2！

[记录](https://www.luogu.com.cn/record/68649108)
。

这是一道大模拟，思路： 读入（我加了快读），然后 $m$ 次不断地算，如果成立就输出 $\texttt{yes}$，否则输出 $\texttt{no}$，最后清空数组。

这道题的大致思路就出来啦！

上你们最喜欢的代码。

```cpp
#include<stdio.h>
#include<string.h>
int a[300003],c[10003];//定义数组，a为输入的小矮人帽子颜色，c在后面要使用。
void in(int &x){//快读。
	char c=getchar(),f=1;
	while ((c<'0'||c>'9')&&c!='-') c=getchar();
	if (c=='-'){
	   f=-1,
	   c=getchar();
	}
	for (x=0;c>='0'&&c<='9';c=getchar())x=x*10+c-'0';
	x*=f;
}
int main(){
	int n,color;//如题意。
	memset(a,0,sizeof(a));//先把数组清空。
	memset(c,0,sizeof(c));
	in(n),in(color);
	for(int i=1;i<=n;i++) in(a[i]);
	int m;
	in(m);
	while(m--){
		int l,r,people;//l代表a，r代表b，为左右两个端点。
		in(l),in(r);
		people=r-l+1;
		people/=2;//这是一半的人数，先处理好，后面使用。
		for(;l<=r;l++){
			c[a[l]]++;//处理每个颜色，是一个桶的思路。
		}
		int max=0,j=0;
		for(int i=1;i<=color;i++){
			if(c[i]>max) max=c[i],j=i;//记录最大值和颜色。
		}
		if(max>people){//如果符合条件。
			printf("yes %d\n",j);//输出按照题意。
		}
		else{
			printf("no\n");
		}
		memset(c,0,sizeof(c));//清空桶数组。
	}
	return 0;//完结撒花qwq~
}
```
审核的管理员大大辛苦啦。

如果您觉得我的题解还不错，留个赞再走嘛。

---

## 作者：lmrttx (赞：5)

不会权值线段树？不会主席树？

没事我们有O2！

暴力的做法复杂度为$O(nm)$，就是说每次询问用桶记录下每个颜色的出现次数，注意要枚举每个颜色时判断是否大于二分之一，而不是全部枚举完再枚举一遍桶。记得清空桶。

开个O2，暴力过去。

代码加了防抄袭。

```cpp
P7261

#include<bits/stdc++.h>
using namespace std;
int c[300001],t[20000],n,C,m;
void work(int l,int r){
	for(int i=l;i<=r;i++){
		++t[c[i]];
		if(t[c[i]]>((r-l+1)/2)){
			printf("yes %d\n",c[i]);return;
		}
	}
	puts("no");
}
int mai(){
	scnf("%d%d",&n,&C);
	for(int i=1;i<=n;i++)scanf("%d",&c[i]);
	scanf("%d",&m);
	for(int i=1,a,b;i<=m;i++){
		scanf("%d%d",&a,&b);
		work(a,b);
		memset(t,0,sizeof(t));
	} 
	retur 0;
}
```

谢谢阅读。

---

## 作者：BitByBit (赞：3)

用 $\Theta(nm)$ 暴力水过去太没素质了，于是我们用 $\Theta((m+n) \sqrt n)$ 的~~暴力~~分块。
# 题意
求区间众数的数量是否大于区间长度的一半，如果是，求众数是什么。
# 算法
首先想到用 $n$ 个 vector $V$ 记录相同的值出现的位置，令第 $i$ 个位置的值是 $Val_i$，则在 $V_{Val_i}$ 中压入 $i$，并令 $Rank_i$ 为 $i$ 在 $V_{Val_i}$ 里的位置。这样就可以 $\Theta(1)$ 求出第 $i$ 个位置后第 $j$ 个和 $Val_i$ 相等的数的位置是:
$$
V_{Val_i,Rank_i+j}
$$
现在可以每次找一个数，判断后面第 $(r-l+1)/2$ 个值相等的数还在不在 $[l,r]$ 里面。这样单次复杂度是 $\Theta(n)$ 的。

但是其实不需要判断每个数，可以先预处理一下，于是想到**分块**。


把序列分成 $\sqrt n$ 个块，记录两个数组：
* $Cnt_{i,j}$ 表示第 $i$ 块到第 $j$ 块间，众数出现的数量；
* $Mode_{i,j}$ 表示第 $i$ 块到第 $j$ 块之间的众数是什么。

这两个数组都可以 $\Theta(n^\frac{3}{2})$ 求出。

然后就可以预处理出整块的众数，只要判断旁边的散块就可以了。

时间复杂度 $\Theta(n \sqrt n + m \sqrt n)$，可以通过。
# 程序
卡了一点点常，用 basic string 代替 vector。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define fi first
#define se second
#define endl '\n'
#define uint unsigned int
#define ull unsigned long long
#define inf 0x3f3f3f3f
#define ninf 0xcfcfcfcf
#define infll 0x3f3f3f3f3f3f3f3f
#define ninfll 0xcfcfcfcfcfcfcfcf
#define start_multitest\
	int test_cnt;\
	cin>>test_cnt;\
	for(int test_case=1;test_case<=test_cnt;test_case++)\
	{
#define end_multitest\
	}
#define N 300010
#define B 600
int n,m,ans;
int Val[N],Temp[N],Rank[N],Blk[N],L[B],R[B],Cnt[B][B],Mode[B][B],T[N];
basic_string<int>V[N];
int main()
{
	//freopen("f.in","r",stdin);
	//freopen("f.out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>Val[i];
	for(int i=1;i<=n;i++)
	{
		V[Val[i]].push_back(i);
		Rank[i]=V[Val[i]].size()-1;
	}
	int len=sqrt(n);
	for(int i=1;i<=len;i++)Blk[i]=1;
	for(int i=len+1;i<=n;i++)Blk[i]=Blk[i-len]+1;
	L[1]=1;R[1]=len;
	for(int i=2;i<=Blk[n];i++)
	{
		L[i]=L[i-1]+len;
		R[i]=R[i-1]+len;
	}
	R[Blk[n]]=n;
	for(int i=1;i<=Blk[n];i++)
	{
		for(int j=i;j<=Blk[n];j++)
		{
			Cnt[i][j]=Cnt[i][j-1];
			Mode[i][j]=Mode[i][j-1];
			for(int k=L[j];k<=R[j];k++)
				if(++T[Val[k]]>Cnt[i][j])
				{
					Cnt[i][j]=T[Val[k]];
					Mode[i][j]=Val[k];
				}
		}
		memset(T,0,sizeof(T));
	}
	cin>>m;
	while(m--)
	{
		int l,r;
		cin>>l>>r;
		int res=0,pos=0,len=r-l+1>>1;
		if(Blk[r]-Blk[l]<=1)
		{
			for(int i=l;i<=r;i++)
				if(++T[Val[i]]>len)
				{
					for(int j=l;j<=i;j++)T[Val[j]]=0;
					cout<<"yes "<<Val[i]<<endl;
					goto END;
				}
			for(int i=l;i<=r;i++)T[Val[i]]=0;
			cout<<"no\n";
			goto END;
		}
		if(Cnt[Blk[l]+1][Blk[r]-1]>r-l+1>>1)
		{
			cout<<"yes "<<Mode[Blk[l]+1][Blk[r]-1]<<endl;
			goto END;
		}
		for(int i=l;i<=R[Blk[l]];i++)
			if(Rank[i]+len<V[Val[i]].size()&&V[Val[i]][Rank[i]+len]<=r)
			{
				cout<<"yes "<<Val[i]<<endl;
				goto END;
			}
		for(int i=L[Blk[r]];i<=r;i++)
			if(Rank[i]-len>=0&&V[Val[i]][Rank[i]-len]>=l)
			{
				cout<<"yes "<<Val[i]<<endl;
				goto END;
			}
		cout<<"no\n";
		END:;
	}
	return 0;
}
```

---

## 作者：ケロシ (赞：1)

题解里为什么都是什么莫队和分块（恼

题目中的这个东西叫做绝对众数，即在可重集中出现次数超过集合大小一半的数。

若一个可重集存在绝对众数，则可以用摩尔投票算法找出解。

简单讲一下尔投票算法，存储两个信息，当前的元素 $x$ 和计数器 $c$，初始 $c=0$。

接下来加入一个元素 $a$，分情况讨论：

- 若 $c=0$，则将当前元素 $x$ 设为 $a$。
- 若 $a=x$，也就是加入相同元素，那么 $c$ 加一。
- 反之，若 $a \ne x$，也就是加入不同元素，那么 $c$ 减一。

```cpp
int x = 0, c = 0;
FOR(i, 1, n) {
	if(c == 0) x = a[i];
	if(a[i] == x) c ++;
	else c --;
}
```

不难发现这个算法可以在存在绝对众数时找出绝对众数，即为最后的 $x$。

然后这个东西构成交换半群，简单来说就是把 $(x,c)$ 作为一个信息，可以和别的信息 $(x',c')$ 合并，并且有交换律和结合律。

```cpp
Node & operator += (Node A) {
	if(x == A.x) c += A.c;
	else if(A.c > c) x = A.x, c = A.c - c;
	else c -= A.c;
	return * this;
}
```

所以直接使用线段树维护，然后再检测一下找出的元素是否是区间的绝对众数即可，两部分均为 $O(m \log n)$，时间复杂度 $O(n+m\log n)$。

```cpp
const int N = 3e5 + 5;
int n, m, q, a[N];
vector<int> e[N];
struct Node { // 摩尔投票信息
	int x, c;
	Node & operator += (Node A) {
		if(x == A.x) c += A.c;
		else if(A.c > c) x = A.x, c = A.c - c;
		else c -= A.c;
		return * this;
	}
	Node operator + (Node A) {
		A += * this;
		return A;
	}
};
struct SgT {
	int le[N << 2], ri[N << 2];
	Node F[N << 2];
	void pushup(int u) {
		F[u] = F[u << 1] + F[u << 1 | 1];
	}
	void build(int u, int l, int r) {
		le[u] = l, ri[u] = r;
		if(l == r) {
			F[u] = {a[l], 1};
			return;
		}
		int mid = l + r >> 1;
		build(u << 1, l, mid);
		build(u << 1 | 1, mid + 1, r);
		pushup(u);
	}
	Node query(int u, int l, int r) {
		if(l <= le[u] && ri[u] <= r) {
			return F[u];
		}
		int mid = le[u] + ri[u] >> 1;
		if(r <= mid) return query(u << 1, l, r);
		if(mid < l) return query(u << 1 | 1, l, r);
		return query(u << 1, l, r) + query(u << 1 | 1, l, r);
	}
} t;
int query(int r, int x) {
	return lower_bound(begin(e[x]), end(e[x]), r + 1) - begin(e[x]);
}
int query(int l, int r, int x) {
	return query(r, x) - query(l - 1, x);
}
void solve() {
	cin >> n >> m;
	FOR(i, 1, n) cin >> a[i];
	FOR(i, 1, n) e[a[i]].push_back(i);
	t.build(1, 1, n);
	cin >> q;
	REP(_, q) {
		int l, r;
		cin >> l >> r;
		auto h = t.query(1, l, r);
		if(query(l, r, h.x) > (r - l + 1) / 2) 
			cout << "yes " << h.x << endl;
		else cout << "no" << endl;
	}
}
```

---

## 作者：gmb7291234 (赞：1)

#### 前置芝士 莫队 线段树。
## 思路
因为~~标签里有莫队~~询问次数小于 $10^4$，所以想到莫队，再用线段树做到单点修改，区间查询最大值。发现 T 了。

看看莫队有哪些优化：奇偶性排序。这一重大发现使时间减少 $\frac{1}{2}$，但还不够。

我们再次看向题目，发现线段树单点修改是两倍常数，所以我们直接找到叶子节点的位置往上面更新，时间就卡进一秒了。

注意，莫队的块长是 $\frac{n}{\sqrt{m}} $。

## code


```cpp
#include<bits/stdc++.h>
#define ls (x<<1)
#define rs (x<<1|1)
#define mid ((l+r)>>1)
#define lson ls,l,mid
#define rson rs,mid+1,r
#define pii pair<int,int>
using namespace std;
struct node{int l,r,id;}e[10005];
int n,c,m,a[1000005],t[10005],t1[10005],rt[1000005],tr[1000005],id[1000005],o;
inline bool cmp(node a,node b){
	if(a.l/o==b.l/o){
		if(((a.l/o)&1)==1)return a.r<b.r;
		else return a.r>b.r;
	}else return a.l<b.l;
}
inline void cha(int x,int u){
	x=rt[x];
	tr[x]+=u;
	while(x){
		x>>=1;
		if(tr[ls]<tr[rs])id[x]=id[rs],tr[x]=tr[rs];
		else id[x]=id[ls],tr[x]=tr[ls];
	}
}
inline pii query(){return {tr[1],id[1]};}
inline void build(int x,int l,int r){
	if(l==r){
		id[x]=l;
		rt[l]=x;
		return;
	}
	build(lson);
	build(rson);
	id[x]=l;
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>c;
	for(int i=1;i<=n;i++)cin>>a[i];
	build(1,1,c);
	cin>>m;o=n/sqrt(m);
	for(int i=1;i<=m;i++)cin>>e[i].l>>e[i].r,e[i].id=i;
	sort(e+1,e+m+1,cmp);
	for(int i=1,l=1,r=0;i<=m;i++){
		while(l<e[i].l)cha(a[l++],-1);
		while(l>e[i].l)cha(a[--l],1);
		while(r<e[i].r)cha(a[++r],1);
		while(r>e[i].r)cha(a[r--],-1);
		pii p=query();
		t[e[i].id]=(p.first>(r-l+1)/2);t1[e[i].id]=p.second;
	}
	for(int i=1;i<=m;i++)if(t[i])cout<<"yes "<<t1[i]<<"\n";else cout<<"no\n";
	return 0;
}
```

---

## 作者：渡鸦2007 (赞：1)

# 思路
我们发现， $1≤c≤10^4$ 。所以此题每次询问时，我们可以开桶存下图片颜色，然后一旦有超过一半的颜色就直接输出。时间复杂度 $O(mn)$ ，开启 $O2$优化可以[通过本题](https://www.luogu.com.cn/record/45370809)。
# 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
int p[300010];//颜色
int t[12345];//桶
inline int read()//快读
{
	register int ans=0;
	char ch;
	while(1)
	{
		ch=getchar();
		if (ch>='0'&&ch<='9')
		{
			break;
		}
	}
	while(1)
	{
		ans=ans*10+ch-'0';
		ch=getchar();
		if (ch<'0'||ch>'9')
		{
			break;
		}
	}
	return ans;
} 
inline void solve(int b,int e)//起止点
{
	for (register int i=b;i<=e;++i)
	{
		++t[ p[i] ];
		if ( t[ p[i] ]>( (e-b+1)>>1) )//超过一半，输出
		{
			printf("yes %d\n",p[i]);
			return;
		}
	}
	printf("no\n");
}

int main()
{
	int n,c;
	//scanf("%d%d",&n,&c);
	n=read();
	c=read();
	for (register int i=1;i<=n;++i)
	{
		//scanf("%d",&p[i]);
		p[i]=read();
	}
	int m;
	scanf("%d",&m);
	for (register int i=1;i<=m;++i)
	{
		int b,e;
		//scanf("%d%d",&b,&e);
		b=read(),e=read();
		solve(b,e);
		memset(t,0,sizeof(t));
		/*for (register int j=1;j<=c;++j)
		{
			t[j]=0;
		}*/
	}
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```

---

## 作者：Little_Deer_Peach (赞：0)

题意已经够简洁了不再赘述。

思路：[双倍经验](https://www.luogu.com.cn/problem/P3567)。两道题相差不大，空间小了一点，但是问题不大，直接上主席树。

那么怎么求大于一半的数呢？我们可以在查询的时候处理。将当前区间分成左右两部分，如果一部分的数字数量超过一半，那么就往那一部分继续寻找。因为如果有一部分的数字数量大于一半，那么那一部分就有可能有超过一半的数字，另一部分一定没有超过一半的数字。

代码：
```cpp
inline int query(int x,int lx,int l,int r,int pos){
	if(l==r)return l;//找到了
	int mid=l+r>>1;
	int v=val[ls[lx]]-val[ls[x]];//左边数字数量
	v*=2;
	if(v>pos)return query(ls[x],ls[lx],l,mid,pos);//左边数字数量超过一半
	v=val[rs[lx]]-val[rs[x]];//右边数字数量
	v*=2;
	if(v>pos)return query(rs[x],rs[lx],mid+1,r,pos);//右边数量超过一半
	return 0;//没有一边超过一半
}
```

然后接下来就肯定会做了，代码就不放了，会的都会。

[记录](https://www.luogu.com.cn/record/223920489)。

---

## 作者：zhangbo1000 (赞：0)

~~蒟蒻依旧想写丰富的开头，可是没有能力。~~

update 2024.3.21 重新提交以去除旧博客分类。

update 2024.1.20

1. 去除了错误的算法描述，重构了对根号分治的分析。

1. 微调了代码。

update 2024.1.1 ：
1. 微调了讲解和代码，因为此题块长取 $2000$ 虽然实际运行快但复杂度不正确，可以被 hack。
1. 修改了复杂度说明，因为查询区间大小的上界应为 $2$ 倍块长。

[题目传送门](https://www.luogu.com.cn/problem/P7261)

[加强版及双倍经验](https://www.luogu.com.cn/problem/P7261)

MnZn 做完题发现自己的做法（根号分治）与其他人（至少已有题解）不同，于是有了这篇。

对于这道题，先考虑暴力，发现有两种做法：（这两种暴力的顺序只是为了接下来的讨论。）

1. 开桶暴力统计 $[l,r]$ 区间内每种数出现次数，再暴力扫统计答案。

1. 给每个数维护出现次数前缀和，这样就能 $\Theta(1)$ 统计一个数在区间内的出现次数，再暴力扫一遍所有数，统计答案。

可以看出，前一种慢主要是因为区间太长，后一种慢主要是因为统计的数太多。

那么我们可以根号分治平衡复杂度，在区间较短时直接用第一种暴力，区间长时则**可能**成为答案的在整个数列内出现次数较多，因此需要维护出现次数前缀和的数也就少了，可以第 $2$ 种暴力。具体来说，令块长（临界?）为 $b$：

* 当 $r-l+1\le 2b$ 时，第一种暴力的最坏复杂度为 $\Theta(b)$。

* 当 $r-l+1>2b$ 时，则出现次数超过 $\frac{r-l+1}{2}$ 的数至少出现了 $b$ 次，这样的数最多只有 $\frac{n}{b}$ 个，第二种暴力最坏 $\Theta(\frac{n}{b})$。

因此总复杂度为 $\Theta(n\times(b+\frac{n}{b}))$。

从数学角度来说，有基本不等式可知 $2b+\frac{n}{b} \ge 2\sqrt{2b\times\frac{n}{b}}=2\sqrt{2n}$。因此当 $b=\sqrt{2n}$ 时达到最好复杂度 $\Theta(n\sqrt{n})$。

但实际实现中，我们发现这个算法的空间复杂度为 $\Theta(n\times \frac{n}{b})=\Theta(\frac{n^2}{b})$，因此也可将 $b$ 稍微开大来防止爆内存。（这道题中 $n\le 3\times 10^5$，我用了 $b=1000$）。

代码：（码风炸裂）

```cpp#include<iostream>
#include<cstdio>
#include<cstring>
#include<bitset>
#include<vector>
#include<map>
using namespace std;
#define M 100001
#define N 300001
#define B 1000
int s[N/B+1][N],p[N/B];
int q[10001],a[N];
bool jc[10001];
int c[10001];
inline void read(int& x){
	static char c;
	while((c=getchar())<'0');
	x=c^'0';
	while((c=getchar())>='0')x=(x<<3)+(x<<1)+(c^'0');
}
int main(){
	int n,m,uke;
	read(n);
	read(uke);
	int top=0;
	for(int i=1;i<=n;i++){
		read(a[i]);
		c[a[i]]++;
	}
	for(int i=1;i<=uke;i++){
		if(c[i]>=B)p[++top]=i;
	}
	for(int i=1;i<=top;i++){
		for(int j=1;j<=n;j++){
			s[i][j]=s[i][j-1]+(a[j]==p[i]?1:0);
		}
	}
	int l,r;
	read(m);
	for(int ttt=0;ttt<m;ttt++){
		bool flag=0;
		read(l);
		read(r);
		if(r-l+1<=(B*2)){
			for(int i=l;i<=r;i++){
				q[a[i]]++;
			}
			for(int i=l;i<=r;i++){
				if((q[a[i]]<<1)>(r-l+1))printf("yes %d\n",a[i]),flag=1;
				q[a[i]]=0;
			}
			if(!flag)printf("no\n");
		}
		else{
			for(int i=1;i<=top;i++){
				if(((s[i][r]-s[i][l-1])<<1)>(r-l+1)){
					printf("yes %d\n",p[i]);
					flag=1;
					break;
				}
			}
			if(!flag)printf("no\n");
		}
	}
	return 0;
}
```

---


# [蓝桥杯 2022 国 A] 三角序列

## 题目背景

感谢 [Lotuses](https://www.luogu.com.cn/user/414231) 提供的数据

## 题目描述

给定 $n$ 组成对的数 $a_i, b_i$，每组数表示一个 $a_i$ 行 $a_i$ 列的如图所示的三角形：

![](https://cdn.luogu.com.cn/upload/image_hosting/hp3n8ozb.png)

其中 $b_i$ 为 $0$ 时左边较低，为 $1$ 时右边较低。

将每组数对应的三角按数的顺序从左到右拼接起来。

现给出 $m$ 组询问 $l_i, r_i, v_i$，对每组询问求最低高度 $h_i$ 使得 $l_i$ 到 $r_i$ 列之间的高度在 $h_i$ 以内的 $o$ 的数量大于等于 $v_i$。

## 说明/提示

**【样例说明】**

第一个询问对应的范围如图所示

![](https://cdn.luogu.com.cn/upload/image_hosting/iu9yky3i.png)

**【评测用例规模与约定】**

- 对于 $30\%$ 的评测用例，$1 \leq n, m, a_i \leq 500$；
- 对于 $50\%$ 的评测用例，$1 \leq n, m, a_i \leq 5000$；
- 对于所有评测用例，$1 \leq n, m \leq 2\times10^5$，$1 \leq a_i \leq 10^6$，$0 \leq b_i \leq 1$，$1 \leq l_i \leq r_i \leq \sum a_i$，$1 \leq v_i \leq 10^{18}$。

蓝桥杯 2022 国赛 A 组 I 题。

## 样例 #1

### 输入

```
6 6
3 0
4 0
2 1
3 1
5 0
1 1
3 9 12
3 9 13
3 4 4
14 16 7
9 15 12
1 18 42```

### 输出

```
2
3
3
3
3
-1```

# 题解

## 作者：zzxLLL (赞：6)


upd on 2023/10/22：修正了柿子。

很显然要二分 $h$，那么问题就是快速处理中间高度小于 $h$ 的圆圈个数。

可以把一个区间分成三部分：

左端点所在三角形 $L$，右端点所在三角形 $R$，中间的三角形 $L+1 \sim R-1$。

然后分类讨论：

- $L = R$ 时:

说明左右端点在同个三角形内，我们可以快速计算高度小于 $h$ 的圆圈个数。

```cpp
int calc(int i, int l, int r, int h) {
    int v1, v2;
    if (b[i] == 0) v1 = l, v2 = r;
    if (b[i] == 1) v1 = a[i] - r + 1, v2 = a[i] - l + 1;

    if (h <= v1) return h * (r - l + 1);
    if (h > v2)  return (v2 + v1) * (r - l + 1) / 2;
    return (v2 - h) * h + (h + v1) * (h - v1 + 1) / 2;
}
```


- $L \neq R$ 时:

比较麻烦，左右两边可以通过 `calc` 函数快速计算，问题在于中间的完整三角形。

直接计算符合条件的圆圈个数比较难，我们可以用总个数-不符合条件的个数。

设中间完整三角形**高度大于h**的高度为 $h_1, h_2, \cdots, h_k$，那么不符合条件圆圈个数等于：

$\begin{aligned} & \frac{1}{2} \sum\limits_{i = 1}^k (h_i - h) (h_i - h + 1) \\&= \frac{1}{2} \sum\limits_{i = 1}^k (h_i^2 - 2h_ih + h^2 + h_i - h) \end{aligned}$ 

设 $S_1= \sum_{i=1}^{k}h_i , S_2= \sum_{i=1}^{k}h_i^{2}$，

那么原式 $= \frac{1}{2}[S_2 - (2h - 1)S_1 + (h^2 - h)k]$。

显然可以主席树维护，快速查询 $S_1 , S_2 , k$，进而计算出符合条件的圆圈个数。


```cpp
#include<cmath>
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
const int M = 1e6 + 10;
const int inf = 1000000;

int L[M], R[M];
int pre[M], cnt_pre[M], a[M], b[M], n, m;

int calc(int i, int l, int r, int h) {
    int v1, v2;
    if (b[i] == 0) v1 = l, v2 = r;
    if (b[i] == 1) v1 = a[i] - r + 1, v2 = a[i] - l + 1;

    if (h <= v1) return h * (r - l + 1);
    if (h > v2)  return (v2 + v1) * (r - l + 1) / 2;
    return (v2 - h) * h + (h + v1) * (h - v1 + 1) / 2;
}

struct PersistentTree {
    int lc, rc, sum, sqs, cnt;
    //sum[k,k]=k sqs[k,k]=k*k cnt[k,k]=1
}tr[M << 3];
int rt[M], cntv;
void pushup(int k) {
    tr[k].sum = tr[tr[k].lc].sum + tr[tr[k].rc].sum;
    tr[k].sqs = tr[tr[k].lc].sqs + tr[tr[k].rc].sqs;
    tr[k].cnt = tr[tr[k].lc].cnt + tr[tr[k].rc].cnt;
}
void update(int &k, int pre, int l, int r, int pos, int h) {
    tr[k = ++cntv] = tr[pre];
    if (l == r) {
        tr[k].sum += h;
        tr[k].sqs += h * h;
        tr[k].cnt += 1;
        return;
    }
    int mid = (l + r) >> 1;
    if (pos <= mid) update(tr[k].lc, tr[pre].lc, l, mid, pos, h);
    else update(tr[k].rc, tr[pre].rc, mid + 1, r, pos, h);
    pushup(k);
}
int query_sum(int k, int pre, int L, int R, int l, int r) {
    if (L <= l and r <= R) return tr[k].sum - tr[pre].sum;
    int mid = (l + r) >> 1, ans = 0;
    if (L <= mid) ans += query_sum(tr[k].lc, tr[pre].lc, L, R, l, mid);
    if (R > mid)  ans += query_sum(tr[k].rc, tr[pre].rc, L, R, mid + 1, r);
    return ans;
}
int query_sqs(int k, int pre, int L, int R, int l, int r) {
    if (L <= l and r <= R) return tr[k].sqs - tr[pre].sqs;
    int mid = (l + r) >> 1, ans = 0;
    if (L <= mid) ans += query_sqs(tr[k].lc, tr[pre].lc, L, R, l, mid);
    if (R > mid)  ans += query_sqs(tr[k].rc, tr[pre].rc, L, R, mid + 1, r);
    return ans;
}
int query_cnt(int k, int pre, int L, int R, int l, int r) {
    if (L <= l and r <= R) return tr[k].cnt - tr[pre].cnt;
    int mid = (l + r) >> 1, ans = 0;
    if (L <= mid) ans += query_cnt(tr[k].lc, tr[pre].lc, L, R, l, mid);
    if (R > mid)  ans += query_cnt(tr[k].rc, tr[pre].rc, L, R, mid + 1, r);
    return ans;
}

signed main() {
    scanf("%lld%lld", &n, &m);
    for (int i = 1; i <= n; i++) {
        scanf("%lld%lld", &a[i], &b[i]);
        update(rt[i], rt[i - 1], 1, inf, a[i], a[i]);
        pre[i] = pre[i - 1] + a[i];
        cnt_pre[i] = cnt_pre[i - 1] + a[i] * (a[i] + 1) / 2;
        L[i] = pre[i - 1] + 1, R[i] = pre[i];
    }
    for (int i = 1, l, r, v; i <= m; i++) {
        scanf("%lld%lld%lld", &l, &r, &v);
        int ll = lower_bound(pre + 1, pre + 1 + n, l) - pre;
        int rr = lower_bound(pre + 1, pre + 1 + n, r) - pre;

        int lb = 1, rb = inf, ans = -1;
        while (lb <= rb) {
            int mid = (lb + rb) >> 1;
            int res;
            if (ll == rr) res = calc(ll, l - L[ll] + 1, r - L[ll] + 1, mid);
            else {
                int tmp_sum = query_sum(rt[rr - 1], rt[ll], mid, inf, 1, inf) - query_sum(rt[rr - 1], rt[ll], mid, mid, 1, inf);//S1
                int tmp_sqs = query_sqs(rt[rr - 1], rt[ll], mid, inf, 1, inf) - query_sqs(rt[rr - 1], rt[ll], mid, mid, 1, inf);//S2
                int tmp_cnt = query_cnt(rt[rr - 1], rt[ll], mid, inf, 1, inf) - query_cnt(rt[rr - 1], rt[ll], mid, mid, 1, inf);//k
                res = (tmp_sqs - 2 * tmp_sum * mid + tmp_cnt * mid * mid + tmp_sum - tmp_cnt * mid) / 2;
                res = cnt_pre[rr - 1] - cnt_pre[ll] - res;
                res += calc(ll, l - L[ll] + 1, R[ll] - L[ll] + 1, mid) + calc(rr, 1, r - L[rr] + 1, mid);
            }
            if (res >= v) ans = mid, rb = mid - 1;
            else lb = mid + 1;
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```

---

## 作者：mrozhx (赞：3)

### 这道题很有意思，题目提供了离散化信息而让我们统计原信息。

首先，看到 “最小的 $h_i$”，显然可以二分答案。

接下来，考虑如何快速查询区间内高度小于 $h_i$ 的点。我们先粗略地想一个做法，这是一个区间和问题，可以用线段树维护。

然后，我们发现问题在于直接维护（暴力建树）的话，复杂度差不多是 $O(\sum a_i \times \log(n))$ 级别。那么考虑通过维护三角形的信息得到点的信息，而三角形和区间的关系有两种，需要分类处理。

#### 第一种情况：三角形包含了一个区间

规定 $pos_i$ 为第 $i$ 个三角形最左边的点的下标， $d_i$ 为三角形边长。现在计算第 $i$ 个三角形区间 $[l,r]$ 中高度不大于 $h$ 的点数。

![](https://cdn.luogu.com.cn/upload/image_hosting/g1zumk9h.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

（图中紫色和青色线对应相等）

我们可以将三角形沿蓝线分为一个梯形和矩形。假设这个三角形有恰好 $h$ 个点的一列为 $mid$ （我将其归入梯形）。需要注意的是，$mid$ 可能不在询问区间内，也就是说矩形和梯形不一定都存在，需要特判。

那么梯形中的点数为 $(l - pos_i + 1 + h) \times (mid - l + 1) / 2$ ，矩形中的点数为 $(r - mid) \times h$。

这种情况只会在询问区间被一个三角形完全包含，或者询问区间的两端出现。每次询问找到这样的三角形暴力算即可。

#### 第二种情况：区间包含了一个三角形

![](https://cdn.luogu.com.cn/upload/image_hosting/2ct055x7.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这种情况比较简单，对于 $d \le h$ 的三角形就是全部点，其余的直接用整个三角形减去最上方的三角形即可。

那么点数即为$(1 + d) \times d / 2$ 或 $(1 + d) \times d / 2 - (1 + d - h) \times (d - h) / 2 $。

这种情况出现的次数很多，因此需要优化它的求解。将上面第二个式子化简，得到 $(h + h ^ 2 + 2 \times d \times h) / 2$ 。这启示我们维护三角形个数，高度以及总点数。

因为需要对 $d$ 进行分类讨论，所以要以 $d$ 为下标建主席树并以三角形编号为下标维护上述三个量。

理论上的总复杂度是 $O(n \times \log^2(n))$。

#### 常数爆炸的 AC 代码

```
#include<iostream>
#include<algorithm>
#define ll long long
#define fst(a,b,c) for(int a = (b);a <= (c);a++)
#define fr first
#define sc second
using namespace std;
const int N = 2e5 + 10; bool check = 0;
int n,m;
ll pos[N];
int h[N],d[N],hh[N],n_,ord[N];
struct Node{
	int l,r,c;
	ll v1,v2;
}t[N * 20]; int Rt[N],num;
inline ll read(){
	char in = getchar(); ll x = 0;
	while(!isdigit(in)) in = getchar();
	while(isdigit(in)) x = x * 10 + (in ^ 48),in = getchar();
	return x;
}
inline bool cmp(int a,int b){return h[a] < h[b];}
inline ll cal(int id,ll l,ll r,int h_){
	ll mid,cut,ans = 0;
//	if(check) printf("cal(%lld,%lld,%lld,%lld)\n",id,l,r,h_);
	if(!d[id]){
		//右靠三角形 
		mid = pos[id] + h_ - 1;
		//刚好碰到高度的标 
//		if(check) printf("mid = %lld\n",mid);
		if(mid >= l){
			cut = min(r,mid);
			ans += 1ll * ((l - pos[id] + 1) + (cut - pos[id] + 1)) * 
			(cut - l + 1) / 2;
			//左半部分是等差数列 
		}
		if(mid < r){
			cut = max(l - 1,mid);
			ans += 1ll * (r - cut) * h_;
			//右半部分矩形 
		}
	}
	else{
		mid = pos[id + 1] - h_;
//		if(check) printf("mid = %lld\n",mid);
		if(mid <= r){
			cut = max(l,mid);
			ans += 1ll * ((pos[id + 1] - r) + (pos[id + 1] - cut)) * 
			(r - cut + 1) / 2;
		}
		if(mid > l){
			cut = min(r + 1,mid);
			ans += 1ll * (cut - l) * h_;
		}
	}
//	if(check) printf("ans = %lld\n",ans);
	return ans;
}
inline void up(int rt){
	t[rt].c = t[t[rt].l].c + t[t[rt].r].c;
	t[rt].v1 = t[t[rt].l].v1 + t[t[rt].r].v1;
	t[rt].v2 = t[t[rt].l].v2 + t[t[rt].r].v2;
}
inline void upd(int k,int x,int &rt,int L = 1,int R = n){
	int rt_ = ++num; t[rt_] = t[rt]; rt = rt_;
	if(L == R){t[rt].c += 1; t[rt].v1 += x; t[rt].v2 += 1ll * (1 + x) * x / 2; return;}
	int mid = (L + R) >> 1;
	(k <= mid) ? upd(k,x,t[rt].l,L,mid) : upd(k,x,t[rt].r,mid + 1,R);
	up(rt);
	return;
}
inline pair<int,pair<ll,ll> > operator + (pair<int,pair<ll,ll> > a,pair<int,pair<ll,ll> > b){
	return {a.fr + b.fr,{a.sc.fr + b.sc.fr,a.sc.sc + b.sc.sc}};
}
inline pair<int,pair<ll,ll> > qry(int l,int r,int rt_,int rt,int L = 1,int R = n){
	if(l <= L && R <= r) return {t[rt].c - t[rt_].c,{t[rt].v1 - t[rt_].v1,t[rt].v2 - t[rt_].v2}};
	int mid = (L + R) >> 1;
	if(r <= mid) return qry(l,r,t[rt_].l,t[rt].l,L,mid);
	else if(l > mid) return qry(l,r,t[rt_].r,t[rt].r,mid + 1,R);
	else return qry(l,r,t[rt_].l,t[rt].l,L,mid) + qry(l,r,t[rt_].r,t[rt].r,mid + 1,R);
}
signed main(){
//	freopen("in.txt","r",stdin);
//	freopen("out.txt","w",stdout);
	ll l1,r1,v,l2,r2,l,r,mid;
	n = read(),m = read();
	pos[0] = 1;
	fst(i,1,n){
		pos[i] = pos[i - 1] + h[i - 1];
		h[i] = hh[i] = read(),d[i] = read();
		ord[i] = i;
	}
	pos[0] = 0;
//	printf("%lld\n",cal(1,1,3,10));
	pos[n + 1] = pos[n] + h[n];
	sort(hh + 1,hh + n + 1);
	n_ = unique(hh + 1,hh + n + 1) - hh - 1;
	//离散高度 
//	if(check){printf("h:: "); fst(i,1,n_) printf("%lld ",hh[i]); puts("");}
	sort(ord + 1,ord + n + 1,cmp);
//	if(check) fst(i,1,n) printf("id = %lld pos = %lld h = %lld\n",ord[i],pos[ord[i]],h[ord[i]]);
	int id = 0;
	fst(i,1,n){
		int now = ord[i],pre = ord[i - 1];
		if(h[now] != h[pre]) id++,Rt[id] = Rt[id - 1];
		upd(now,h[now],Rt[id]);
	}
	//用高度作为时间戳，横坐标作为下标建主席树 
	ll tmp,ans;
	pair<int,pair<ll,ll> > tmp_;
	fst(i,1,m){
		ans = -1;
		l1 = read(),r1 = read(),v = read();
//		if(check) if(i != 4) continue;
		l2 = upper_bound(pos + 1,pos + n + 2,l1) - pos - 1;
		r2 = upper_bound(pos + 1,pos + n + 2,r1) - pos - 1;
		//左右端点所在三角形下标 
//		if(check) printf("qry[%lld,%lld] [%lld,%lld]\n",l1,r1,l2,r2);
		l = 1; r = hh[n_] + 1;
		while(l <= r){
			tmp = 0;
			mid = (l + r) >> 1;
			//二分答案 
//			if(check) printf("mmmmmmmmmmmmmmmmmmmmid = %lld\n",mid);
			if(l2 == r2) tmp = cal(l2,l1,r1,mid);
			else{
				if(r2 > l2 + 1){
//					if(check) printf("[%lld,%lld]\n",pos[l2 + 1],pos[r2] - 1);
					id = upper_bound(hh + 1,hh + n_ + 1,mid) - hh - 1;
					tmp_ = qry(l2 + 1,r2 - 1,Rt[id],Rt[n_]);
//					if(check) printf("{%lld,{%lld,%lld}}\n",tmp_.fr,tmp_.sc.fr,tmp_.sc.sc);
					tmp += 1ll * tmp_.sc.fr * mid;
					tmp += 1ll * tmp_.fr * (mid - mid * mid) / 2;
//					if(check) printf("tmp = %lld\n",tmp);
					tmp_ = qry(l2 + 1,r2 - 1,Rt[0],Rt[id]);
					tmp += tmp_.sc.sc;
//					if(check) printf("tmp = %lld\n",tmp);
				}
				tmp += cal(l2,l1,pos[l2 + 1] - 1,mid);
				tmp += cal(r2,pos[r2],r1,mid);
//				if(check) printf("%lld\n",tmp);
			}
			if(tmp >= v) ans = mid,r = mid - 1;
			else l = mid + 1;
		}
//		if(check) printf("aaaaaaaaaaaaaaaaans = ");
		printf("%lld\n",ans);
	}
	return 0;
}
//1 1 1 -2 1 1 1 -2 -1 2 -1 -1 0 1 1 1 1
//区间最大值及数量，前缀和 
```


---

## 作者：chzhh_111 (赞：2)

~~本来是想做一道分块题的，结果是用可持久化线段树做的。~~

首先我们一步步来解析题目：

对于一段区间内，显然，$o$ 的数量是随着高度单调递增的，故可以用二分解决**求最低高度 $h$**。

题目当中所给的序列并不是最终序列，并且这个序列的长度是 $\textstyle \sum_{i=1}^{n} a_{i}$，这个长度很明显，如果直接开数组是装不下的。那么我们现在就要考虑去用更加高效的方法。

我们可以发现这两个端点一定都在一个三角形中，由于这个三角形的底和高是一样长的，所以我们考虑用一个 $high$ 数组去存前缀和，再利用二分去把这两个端点所在的三角形的编号求出来。那么我们就成功把原本需要细分到三角形的每一列每一行的操作，给它转化成三角形之间的操作。

现在我们记 $L$ 为左端点所在的三角形编号，$R$ 为右端点所在的三角形的编号，则 $L$ 和 $R$ 中间的三角形（不包括 $L$ 和 $R$），就可以直接求（下面用 $H$ 来表示此时此刻所讨论的三角形的高，用 $h$ 来表示此时此刻二分答案的高）：

- 若 $H \le h$，则这个三角形的贡献为 $\frac{H \times (H + 1)}{2}$。

- 若 $H > h$，则这个三角形的贡献为 $\frac{h \times (h + 1)}{2} + h \times (H - h)$。

我们就可以用可持久化线段树来维护这个东西。可持久化线段树要维护三个东西：$sum$ 表示 $o$ 总数；$cnt$ 表示三角形个数；$len$ 表示三角形高度总和。（以下用小三角形表示高度小于等于 $h$ 的三角形，用大三角形表示高度大于 $h$ 的三角形）那么中间那一段的贡献就是所有小三角形的 $sum$ 加上所有大三角形的 $cnt$ 乘以一个高度为 $h$ 的三角形的 $sum$，再加上所有大三角形的 $len$ 减去其 $cnt$ 乘以 $h$ 的积的差再乘以 $h$ 的积。

代码实现：

```cpp
if(L<R)
{
	sum+=querysum(root[L],root[R],1,maxn,1,h);
	if(h<maxn)
	{
		int cnt=querycnt(root[L],root[R],1,maxn,h+1,maxn);
		sum+=cnt*f(h);
		sum+=(querylen(root[L],root[R],1,maxn,h+1,maxn)-cnt*h)*h;
	}
}
//maxn 为最大的 H。
//f(x) = x*(x+1)/2。
```

那么接下来就是得考虑左右两个端点所处的三角形的贡献，接下来以左端点所在的三角形举例（用 $f(x)$ 表示 $\textstyle \sum_{i=1}^{n} i$，用 $ln$ 来表示左端点在这个三角形从左往右数第几个）：

- 若左端点所处的三角形的 $b$ 为 $0$：

  - 如果 $H \le h$，对答案不产生影响，为 $f(H) - f(ln-1)$。
  - 如果 $ln < h \le H$，则答案要在原来的基础上将所有大于 $h$ 的数变成了 $h$，为 $f(h-1) - f(ln-1) + h \times (H-h+1)$。
  - 如果 $h \le ln$，则所有数都变成了 $h$，为 $h \times (H-ln+1)$。

- 若左端点所处的三角形的 $b$ 为 $1$：

  - 可以发现，只有 $h < N-ln+1$ 的情况下，才能改变答案，为 $f(H-ln+1) - f(H-ln+1-h)$。

剩下的同理。

现在还要看一下左右两个端点处于相同一个三角形的情况，则可以用左边端点所贡献的值减去右边端点所贡献的值，这样子就是这两个端点之间的值（减的时候，不要把端点忽略掉了）。

代码实现：

```cpp
if(s[l].t) sum+=f(s[l].h-ln+1)-(h<s[l].h-ln+1?f(s[l].h-ln+1-h):0);
else
{
	if(h>=s[l].h) sum+=f(s[l].h)-f(ln-1);
	else if(h>ln) sum+=f(h-1)-f(ln-1)+h*(s[l].h-h+1);
	else sum+=h*(s[l].h-ln+1);
}
if(l!=r)
{
	if(s[r].t)
	{
		if(h>=s[r].h) sum+=f(s[r].h)-f(s[r].h-rn);
		else if(h>s[r].h-rn+1) sum+=f(h-1)-f(s[r].h-rn)+h*(s[r].h-h+1);
		else sum+=h*rn;
	}
	else sum+=f(rn)-(h<rn?f(rn-h):0);
}
else
{
	if(s[r].t) sum-=f(s[r].h-rn)-(h<s[r].h-rn?f(s[r].h-rn-h):0);
	else
	{
		if(h>=s[r].h) sum-=f(s[r].h)-f(rn);
		else if(h>rn+1) sum-=f(h-1)-f(rn)+h*(s[r].h-h+1);
		else sum-=h*(s[r].h-rn); 
	}
}
// s 是用来表示三角形的。
```

以上实现的时间复杂度应该是 $O(n \log^2(n))$。

总代码实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define lc(x) tr[x].lson
#define rc(x) tr[x].rson
#define sum(x) tr[x].sum
#define cnt(x) tr[x].cnt
#define len(x) tr[x].len
const int N=2e5+1,A=1e6+1;
int n,m,high[N],maxn;
int lr,root[N],tot;
struct three{
	int h,t;
}s[N];
struct tree{
	int lson,rson,sum,cnt,len;
}tr[A<<5];
int f(int x) {return x*(x+1)/2;} 
int find(int x)
{
	int l=1,r=n;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(high[mid]<x) l=mid+1;
		  else r=mid-1;
	}
	return l;
}
//-------------------------------------------------------
void build(int k,int l,int r)
{
	if(l==r) return;
	int mid=(l+r)>>1;
	lc(k)=++tot;
	build(lc(k),l,mid);
	rc(k)=++tot;
	build(rc(k),mid+1,r);
}
void insert(int k1,int k2,int l,int r,int x)
{
	sum(k1)=sum(k2)+f(x);
	len(k1)=len(k2)+x;
	cnt(k1)=cnt(k2)+1;
	if(l==r) return;
	int mid=(l+r)>>1;
	if(x<=mid)
	{
		rc(k1)=rc(k2);
		lc(k1)=++tot;
		insert(lc(k1),lc(k2),l,mid,x);
	}
	else
	{
		lc(k1)=lc(k2);
		rc(k1)=++tot;
		insert(rc(k1),rc(k2),mid+1,r,x);
	}
}
int querysum(int k1,int k2,int l,int r,int x,int y)
{
	if(x<=l&&r<=y) return sum(k2)-sum(k1);
	int mid=(l+r)>>1,sum=0;
	if(x<=mid) sum+=querysum(lc(k1),lc(k2),l,mid,x,y);
	if(y>mid) sum+=querysum(rc(k1),rc(k2),mid+1,r,x,y);
	return sum;
}
int querycnt(int k1,int k2,int l,int r,int x,int y)
{
	if(x<=l&&r<=y) return cnt(k2)-cnt(k1);
	int mid=(l+r)>>1,cnt=0;
	if(x<=mid) cnt+=querycnt(lc(k1),lc(k2),l,mid,x,y);
	if(y>mid) cnt+=querycnt(rc(k1),rc(k2),mid+1,r,x,y);
	return cnt;
}
int querylen(int k1,int k2,int l,int r,int x,int y)
{
	if(x<=l&&r<=y) return len(k2)-len(k1);
	int mid=(l+r)>>1,len=0;
	if(x<=mid) len+=querylen(lc(k1),lc(k2),l,mid,x,y);
	if(y>mid) len+=querylen(rc(k1),rc(k2),mid+1,r,x,y);
	return len;
}
//-----------------------------------------可持久化线段树。 
bool solve(int h,int v,int l,int r,int ln,int rn)
{
	int L=l,R=r-1,sum=0;
	//--------------------------------------------------------------------------
	if(L<R)
	{
		sum+=querysum(root[L],root[R],1,maxn,1,h);
		if(h<maxn)
		{
			int cnt=querycnt(root[L],root[R],1,maxn,h+1,maxn);
			sum+=cnt*f(h);
			sum+=(querylen(root[L],root[R],1,maxn,h+1,maxn)-cnt*h)*h;
		}
	}
	//-----------------------------------------统计中间那一段三角形所产生的贡献。  
	//----------------------------------------------------------------------------
	if(s[l].t) sum+=f(s[l].h-ln+1)-(h<s[l].h-ln+1?f(s[l].h-ln+1-h):0);
	else
	{
		if(h>=s[l].h) sum+=f(s[l].h)-f(ln-1);
		else if(h>ln) sum+=f(h-1)-f(ln-1)+h*(s[l].h-h+1);
		else sum+=h*(s[l].h-ln+1);
	}
	if(l!=r)
	{
		if(s[r].t)
		{
			if(h>=s[r].h) sum+=f(s[r].h)-f(s[r].h-rn);
			else if(h>s[r].h-rn+1) sum+=f(h-1)-f(s[r].h-rn)+h*(s[r].h-h+1);
			else sum+=h*rn;
		}
		else sum+=f(rn)-(h<rn?f(rn-h):0);
	}
	else
	{
		if(s[r].t) sum-=f(s[r].h-rn)-(h<s[r].h-rn?f(s[r].h-rn-h):0);
		else
		{
			if(h>=s[r].h) sum-=f(s[r].h)-f(rn);
			else if(h>rn+1) sum-=f(h-1)-f(rn)+h*(s[r].h-h+1);
			else sum-=h*(s[r].h-rn); 
		}
	}
	//-----------------------------------------统计左右两端点所在的三角形产生的贡献。 
	return sum>=v;
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)
	{
		int a,b;
		scanf("%lld%lld",&a,&b);
		s[i]=(three){a,b};
		high[i]=high[i-1]+a;
		maxn=max(maxn,a);
	}
	root[lr]=++tot;
	build(root[0],1,maxn);
	for(int i=1;i<=n;i++)
	{
		root[++lr]=++tot;
		insert(root[lr],root[lr-1],1,maxn,s[i].h);
	}
	for(int i=1;i<=m;i++)
	{
		int l,r,v;
		scanf("%lld%lld%lld",&l,&r,&v);
		int lnode=find(l),rnode=find(r);
		l-=high[lnode-1],r-=high[rnode-1];
		int L=1,R=maxn;
		while(L<=R)
		{
			int mid=(L+R)>>1;
			if(solve(mid,v,lnode,rnode,l,r)) R=mid-1;
			  else L=mid+1;
		}
		printf("%lld\n",L<=maxn?L:-1);
	}
	return 0;
}
```

---


# [蓝桥杯 2023 国 A] 树上的路径

## 题目描述

给定一棵包含 $n$ 个结点的树，树的每条边的长度均为 $1$。求这棵树的所有长度在 $L\sim R$ 之间的路径的长度之和。两条路径经过的边集完全相同时视作同一条路径。

也就是求 $\sum\limits_{i=1}^n{\sum\limits_{j=i+1}^{n}{dis(i,j)\cdot[L \le dis(i,j) \le R]}}$，其中 $dis(i,j)$ 表示结点 $i$ 和结点 $j$ 之间的距离，$[C]$ 表示条件 $C$ 满足时取 $1$，不满足时取 $0$。

## 说明/提示

**【评测用例规模与约定】**

对于 $40\%$ 的评测用例，$n\le 2000$；  
对于所有评测用例，$1\le L\le R\le n\le 10^6$，$1\le F_i\le i$。

## 样例 #1

### 输入

```
4 2 3
1
1
3
```

### 输出

```
7```

# 题解

## 作者：KobeBeanBryantCox (赞：4)

# P10421 [蓝桥杯 2023 国 A] 树上的路径 题解

[题目传送门](https://www.luogu.com.cn/problem/P10421)。

居然没有题解？

本题解为 $O(n\log^2n)$，拜谢 $O(n\log n)$ 大佬（不知道存不存在单 $\log$ 的做法，存在的话麻烦告知我）。

## 题意

给一棵树，求 $\sum\limits_{i=1}^n{\sum\limits_{j=i+1}^{n}{dis(i,j)\cdot[L \le dis(i,j) \le R]}}$。

## 思路

看到题首先想到了[这个题：Tree](https://www.luogu.com.cn/problem/P4178)。

我们在普通[点分治](https://www.luogu.com.cn/problem/P3806)的过程中，有一种写法是用一个桶维护深度出现的次数。

在 Tree 这个题中，我们可以把桶改成值域树状数组，修改时 $+1$，查询前缀和即可。

本题中，我们需要在修改树状数组时加上深度，而不是加上 $1$，这样就维护出了当前根到儿子的子树中所有节点的深度前缀和。

由于点分治每一层是解决经过根节点的路径，我们在遍历的时候还需要在前面深度前缀和的基础上，加上【当前点到根节点的长度】乘上【前面子树中长度符合长度限制的点的个数】，贡献进答案中。

所以要开两个树状数组，第一个修改时加深度，第二个修改时加 $1$。

## AC 代码

```cpp
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
#define int long long
int in()
{
	int k=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar();
	return k*f;
}
void out(int x)
{
	if(x<0)putchar('-'),x=-x;
	if(x<10)putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
const int N=1e6+10;
vector<int>e[N];
int maxp[N],siz[N];
int root;
bool vis[N];
void get_root(int u,int fa,int tot)
{
	siz[u]=1,maxp[u]=0;
	for(int v:e[u])
	{
		if(v==fa||vis[v])continue;
		get_root(v,u,tot);
		siz[u]+=siz[v],maxp[u]=max(maxp[u],siz[v]);
	}
	maxp[u]=max(maxp[u],tot-siz[u]);
	if(!root||maxp[u]<maxp[root])root=u;
}
int stk[N],tot=0;
void dfs(int u,int fa,int d)
{
	stk[++tot]=d;
	for(int v:e[u])
	{
		if(vis[v]||v==fa)continue;
		dfs(v,u,d+1);
	}
}
int n,l,r,ans=0;
struct bit
{
	int c[N];
	void add(int x,int v){for(x++;x<=n+1;x+=x&-x)c[x]+=v;}
	int ask(int x){int ss=0;for(x++;x;x-=x&-x)ss+=c[x];return ss;}
	int ask(int l,int r){return ask(r)-ask(l-1);}
}T,num;
void work(int u)
{
	num.add(0,1),tot=0;int i=1;
	for(int v:e[u])
	{
		if(vis[v])continue;
		dfs(v,u,1);
		for(int j=i;j<=tot;j++)
		{
			int ll=max(0ll,l-stk[j]),rr=r-stk[j];
			if(rr<0)continue;
			ans+=T.ask(ll,rr)+num.ask(ll,rr)*stk[j];
		}
		for(;i<=tot;i++)T.add(stk[i],stk[i]),num.add(stk[i],1);
	}
	for(;tot;tot--)T.add(stk[tot],-stk[tot]),num.add(stk[tot],-1);
	num.add(0,-1);
}
void solve(int u)
{
	vis[u]=true,work(u);
	for(int v:e[u])
	{
		if(vis[v])continue;
		root=0,get_root(v,0,siz[u]);
		solve(root);
	}
}
int divid()
{
	memset(vis,0,sizeof(vis));
	ans=root=0,maxp[0]=n,get_root(1,0,n);
	solve(root);
	return ans;
}
signed main()
{
	n=in(),l=in(),r=in();
	for(int i=2;i<=n;i++)
	{
		int u=in();
		e[u].push_back(i),e[i].push_back(u);
	}
	out(divid());
	return 0;
}
```

有点卡常，注意一下常数。

注意：十年 oi 一场空，不开 long long 见祖宗！

---

## 作者：ShanLing (赞：1)

萌新刚学点分治，正好碰到这一题可以交题解。
# 思路
设 $sum_{l,r}$ 表示树上长度在 $l\sim r$ 之间的路径长度之和，则答案为 $sum_{L,R}$，可表示为 $sum_{1,R}-sum_{1,L-1}$。则题意变为求树上长度不超过 $k$ 的路径长度之和。

很容易想到点分治。对于当前选定的根，将他子树上所有点到他的距离存下来并排序，对排完序的数组做前缀和以求区间和。再用类似双指针（实际似乎是单指针？）的方法求 $\leq k$ 的路径的长度和。

但直接这么做答案是错的。如下图所示，当选定 A 为根时，这个做法会将路径 AB 和路径 AC 合并（如红线所示），而路径 BAC 不合法。

![](https://cdn.luogu.com.cn/upload/image_hosting/jxhe1vj6.png)

发现不合法的路径的两端点都在同一棵子树上，因此我们可以利用容斥的思想，先分别求出每棵子树内部点产生的贡献（他们都是非法的），将总贡献减去这些贡献就是答案。

对每棵子树上的点都要排一次序。使用一般的排序方法，总时间复杂度 $O(n log^2 n)$。需要排序的元素为路径长度，最长不超过树高，可以使用桶排序，将时间复杂度优化到 $O(n log n)$。

实现有点复杂，具体请看代码：
```
#include <bits/stdc++.h>
using namespace std;
#define N 1000005
#define ll long long
//答案会超过int范围

int n,L,R,vis[N],dis[N],sz[N],mx[N],tot,root,book[N];
ll sum[N],ans;
vector<int> a[N];
vector<int> q1,q2;

void bsort(vector<int> &q)//手写的桶排序
{
    int maxv=0;
    for(int i=0;i<q.size();i++)
    {
        book[q[i]]++;
        if(q[i]>maxv)
            maxv=q[i];
    }

    int j=0;
    for(int i=0;i<=maxv;i++)
        while(book[i])
        {
            q[j++]=i;
            book[i]--;
        }
}

void getG(int x,int fa)//找重心
{
    mx[x]=0;
    sz[x]=1;

    for(int i=0;i<a[x].size();i++)
    {
        int y=a[x][i];
        if(y==fa || vis[y])
            continue;
        
        getG(y,x);
        sz[x]+=sz[y];
        mx[x]=max(mx[x],sz[y]);
    }

    mx[x]=max(mx[x],tot-sz[x]);
    if(mx[x]<mx[root])
        root=x;
}

void getdis(int x,int fa)//算距离
{
    q1.push_back(dis[x]);

    for(int i=0;i<a[x].size();i++)
    {
        int y=a[x][i];
        if(y==fa || vis[y])
            continue;

        dis[y]=dis[x]+1;
        getdis(y,x);
    }
}

ll add(vector<int> &q,const int k)//双（单）指针求贡献
{
    ll now=0;

    int r=q.size()-1;
    for(int j=0;j<q.size();j++)//对于序列每一项，求能和他合并的区间[j,r]
    {
        while(r>=0 && q[j]+q[r]>k)
            r--;

        if(r<=j)
            break;
        now+=sum[r]-sum[j]+1ll*q[j]*(r-j);//不要忘记加上q[j]
    }

    return now;
}

void _count(int x)//对每个根统计
{
    q2.clear();
    q2.push_back(0);//加上0表示根到某个点的路径

    for(int i=0;i<a[x].size();i++)
    {
        int y=a[x][i];
        if(vis[y])
            continue;

        dis[y]=1;
        q1.clear();
        getdis(y,x);

        bsort(q1);//这里也可以直接用sort，不会慢很多
        for(int j=0;j<q1.size();j++)//前缀和
        {
            sum[j]=q1[j];
            if(j)
                sum[j]+=sum[j-1];
        }

        ans-=add(q1,R)-add(q1,L-1);//减去同一棵子树上的贡献
        for(int j=0;j<q1.size();j++)
            q2.push_back(q1[j]);
    }

    bsort(q2);
    for(int j=0;j<q2.size();j++)
    {
        sum[j]=q2[j];
        if(j)
            sum[j]+=sum[j-1];
    }

    ans+=add(q2,R)-add(q2,L-1);//总贡献
}

void solve(int x)
{
    vis[x]=1;
    _count(x);

    for(int i=0;i<a[x].size();i++)
    {
        int y=a[x][i];
        if(vis[y])
            continue;
        
        tot=sz[y];
        root=0;
         getG(y,x);
         solve(root);
    }
}

int main( void )
{
    scanf("%d%d%d",&n,&L,&R);
    for(int i=2;i<=n;i++)
    {
        int x;
        scanf("%d",&x);
        a[x].push_back(i);
        a[i].push_back(x);
    }

    mx[0]=1e9;
    tot=n;
    getG(1,0);
    solve(root);

    printf("%lld",ans);

    return 0;
}
```

---

## 作者：CQ_Bab (赞：1)

# 前言
冲中考停了两个月竞赛，康复训练题目，所以写得比较史也是成功收获最劣解，但是思路还是没问题的。
# 思路
首先我们发现这是一颗树还是求树上关于路径的问题，直接考虑点分治（[不会的话去学一下吧](https://www.luogu.com.cn/problem/P3806)），我们发现我们对于点分治遍历到一条长度为 $x$ 的路径那么另一条路径的长度需要在 $l-x\sim r-x$ 之间所以我们需要一个支持单点修改区间求和的数据结构，直接上树状数组即可。

时间复杂度 $O(n\times \log^2(n))$。
# 代码
细节见代码。
```cpp
#include <bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#include <ext/rope>
using namespace __gnu_pbds;
using namespace std;
#define pb push_back
#define rep(i,x,y) for(register int i=x;i<=y;i++)
#define rep1(i,x,y) for(register int i=x;i>=y;--i)
#define ll long long
#define fire signed
#define il inline
template<class T> il void print(T x) {
	if(x<0) printf("-"),x=-x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
template<class T> il void in(T &x) {
    x = 0; char ch = getchar();
    int f = 1;
    while (ch < '0' || ch > '9') {if(ch=='-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar(); }
    x *= f;
}
int T=1;
const int N=2e6+10;
ll tr[N];
int cnt[N];
vector<int>v[N];
int n;
int l,r,mx[N],rt,sum;
int lowbit(int x) {
	return x&-x;
}
void add(int x,int k) {
	x++;
	for(;x<=n+1;x+=lowbit(x)) tr[x]+=1ll*k,cnt[x]++;
}
ll Ans(int x){
	if(x<0) return false;
	x++;
	ll res=0;
	for(;x;x-=lowbit(x)) res+=tr[x];
	return res;
}
int Ans1(int x) {
	if(x<0) return false;
	x++;
	int res=0;
	for(;x;x-=lowbit(x)) res+=cnt[x];
	return res;
}
int vis[N],siz[N];
void frt(int x,int fa) {
	siz[x]=1;
	mx[x]=1;
	for(auto to:v[x]) {
		if(to==fa||vis[to]) continue;
		frt(to,x);
		mx[x]=max(mx[x],siz[to]);
		siz[x]+=siz[to];
	}
	mx[x]=max(mx[x],sum-siz[x]);
	if(mx[x]<mx[rt]) rt=x;
}
void clear(int x) {
	x++;
	for(;x<=n+1;x+=lowbit(x)) tr[x]=cnt[x]=false;
}
int dis[N];
vector<int>arr;
void dfs1(int x,int fa) {
	arr.pb(dis[x]);
	for(auto to:v[x]) {
		if(to==fa||vis[to]) continue;
		dis[to]=dis[x]+1;
		dfs1(to,x);
	}
}
ll res;
void dfs2(int x,int fa) {
	siz[x]=1;
	for(auto to:v[x]) {
		if(to==fa||vis[to]) continue;
		dfs2(to,x);
		siz[x]+=siz[to];
	}
}
void dfs(int x,int fa) {
	vis[x]=1;
	vector<int>ad;
	ad.pb(0);
	add(0,0);
	for(auto to:v[x]) {
		if(to==fa||vis[to]) continue;
		arr.clear();
		dis[to]=1;
		dfs1(to,x);
		for(auto to1:arr) {
			if(r-to1<0) continue;
			int cc=Ans1(r-to1)-Ans1(l-to1-1);
			res+=1ll*cc*to1;
			res+=Ans(r-to1)-Ans(l-to1-1);
		}
		for(auto to1:arr) {
			if(to1>r) continue;
			ad.pb(to1);
			add(to1,to1);
		}
	}
	for(auto to:ad) clear(to);
	dfs2(x,0);
	for(auto to:v[x]) {
		if(to==fa||vis[to]) continue;
		rt=false;
		sum=siz[to];
		frt(to,x);
		dfs(rt,x);
	}
}
void solve() {
	in(n),in(l),in(r);
	rep(i,2,n) {
		int x;
		in(x);
		v[x].pb(i);
		v[i].pb(x);
	}
	rt=0;
	sum=n;
	mx[rt]=1e9;
	frt(1,0);
	dfs(rt,0);
	printf("%lld\n",res);
}
fire main() {
	while(T--) {
		solve();
	}
	return false;
}
```

---

## 作者：Doqe (赞：1)

几乎是长链剖分的练习题，该题解中算法的时间复杂度是 $O(n)$。

我们考虑如下子问题（实际上可以不考虑，这样是为了描述方便）：

$$\sum_{1\le i<j\le n}\text{dis}(i,j)[\text{dis}(i,j)\ge R]$$

这里选择 $\ge R$ 还是 $\le R$ 对后面长链剖分的修改的影响巨大。

我们的长链剖分内部要维护形如：$\sum [dep_u\ge x]dep_u$ 和 $\sum [dep_u]$ 这两类东西。为了方便描述我们称 $\sum [dep_u=x]dep_u$ 和 $\sum [dep_u=x]$ 为信息，实际维护的东西叫做信息的后缀和。考虑如下两种情况：

1. 遍历完 $u$ 长儿子之后，要在长儿子的长链（不包括长儿子祖先，下文出现的“$x$ 的长链”均为此意）开头添加 $u$ 的信息，因为是后缀和，可以 $O(1)$ 更新。

2. 对于合并，因为是后缀和，所以修改前 $l$ 个信息，这些信息的后缀和（也就是我们保存的内容）只有前 $l$ 个可能变化。

现在问题在如何计算答案。为了方便描述，这里使用 $\sum [dep_u\ge x]z_u$ 来同时表示 $\sum [dep_u\ge x]dep_u$ 和 $\sum [dep_u]$ 这两类东西，其他出现 $z_i$ 的情况可以类比。
1. 遍历完 $u$ 长儿子之后，添加 $u$。此时我们需要  $\sum [dep_i\ge dep_u+R]z_i$。
2. $v$ 合并到 $u$。考虑 $v$ 所在的长链中 $\sum [dep_i=t]z_i$。这部分和 $u$ 中的长链 $\sum[dep_i\ge R-1-i]z_i$ 可以用来计算贡献（求 $v$ 长链中 $dep_i=t$，$u$ 长链中 $dep_j\ge R-1-i$ 的 $i,j$ 贡献）。把这一些贡献加起来的结果是不重不漏的。

这样我们能把所有贡献计算清楚。实际写的时候存在若干因实现而异的细节，例如 $R-1-i\le 0$ 等。

[代码提交记录](https://www.luogu.com.cn/record/220607787)

---

## 作者：IC0CI (赞：0)

## 题面分析

跟[板子](https://www.luogu.com.cn/problem/P3806)差不多，本题要求 $\sum\limits_{i=1}^n{\sum\limits_{j=i+1}^{n}{dis(i,j)\cdot[L \le dis(i,j) \le R]}}$。

到每个点之后计算的时候先把子树中的点按深度排个序，双指针跑两遍分别找出 $dis_u + dis_v \leq R$ 和 $dis_u + dis_v \leq L - 1$ 的点对 $(u,v)$，减一下就出答案了。

### 关于具体实现

排序后的深度序列，对其先求一次前缀和方便计算双指针中间一段的贡献和。

分别对 $R$ 和 $L - 1$ 求一次，用 $R$ 算出来的减去 $L - 1$ 算出来的就是要求的贡献。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

int rd()//快读

const int N = 1e6 + 5;
int n,L,R,rt;
vector<int> adj[N];

int siz[N],mx[N],dis[N];
bool vis[N];

void getrt(int u,int fa,int sum)
{
    siz[u] = 1,mx[u] = 0;
    for(auto v : adj[u])
    {
        if(v == fa || vis[v]) continue;
        getrt(v,u,sum);
        siz[u] += siz[v];
        mx[u] = max(mx[u],siz[v]);
    }
    mx[u] = max(mx[u],sum - mx[u]);
    if(mx[u] <= mx[rt]) rt = u;
}

vector<int> vec;

void getdis(int u,int fa)
{
    vec.push_back(dis[u]);
    for(auto v : adj[u])
    {
        if(v == fa || vis[v]) continue;
        dis[v] = dis[u] + 1;
        getdis(v,u);
    }
}

int s[N];

int clac(int u,int w)
{
    vec.clear();
    vec.push_back(0);
    dis[u] = w;
    getdis(u,0);
    sort(vec.begin(),vec.end());
    for(int i = 1;i < vec.size();i++) s[i] = s[i - 1] + vec[i];
    int l = 1,r = vec.size() - 1;
    int ans = 0;
    while(l <= r)
    {
        while(l <= r && vec[l] + vec[r] > R) r--;
        if(l > r) break;
        ans += s[r] - s[l] + vec[l] * (r - l);
        l++;
    }
    l = 1,r = vec.size() - 1;
    while(l <= r)
    {
        while(l <= r && vec[l] + vec[r] > L - 1) r--;
        if(l > r) break;
        ans -= s[r] - s[l] + vec[l] * (r - l);
        l++;
    }
    return ans;
}

int ans,maxs;

void solve(int u)
{
    vis[u] = 1;
    ans += clac(u,0);
    for(auto v : adj[u])
    {
        if(vis[v]) continue;
        ans -= clac(v,1);
        mx[rt = 0] = n;
        getrt(v,u,siz[v]);
        solve(rt);
    }
}

signed main()
{
    n = rd(),L = rd(),R = rd();
    for(int i = 2;i <= n;i++)
    {
        int x = rd();
        adj[x].push_back(i);
        adj[i].push_back(x);
    }
    mx[0] = n;
    getrt(1,0,n);
    solve(rt);
    cout << ans;
    return 0;
}
```

---

## 作者：TangBin0524 (赞：0)

---
几乎是点分治的模板题，该题解中算法的时间复杂度是 $O(n\log n)$ 的。  
点分治的过程建议去做模板题。  
本题中，点分治中的```calc()```是算法时间复杂度的瓶颈。本篇题解采用用容斥原理来去除重复的答案。  
与别的题解不同，将时间复杂度从 $O(n\log^2 n)$ 优化至 $O(n\log n)$ 的方法是：
- 1. 用桶排序将排序降至 $O(n)$
- 2. 用双指针求排好序以后的数组中路径长度和在 $[L,R]$ 之间的路径。

具体的做法如下：
在```calc```函数中先桶排序出```tmp```数组，即到当前子树到重心的距离数组。然后进行两轮双指针求答案。预处理出```tmp```数组的前缀和```suf```。第一轮统计```tmp[i]+tmp[j]<=R```的路径和：对于每个```l```，通过双指针求出```tmp[l]+tmp[r]<=R```的最大的```r```，那么此时从```l+1```至```R```均可与```l```配对。即
$$
\sum_{k=l+1}^{r}(tmp[l]+tmp[k])=(r-l)tmp[l]+suf[r]-suf[l]
$$
将这些加到贡献中。  
同理，第二轮统计```tmp[i]+tmp[j]<=L-1```的路径和，这一轮统计的贡献是负的。通过两轮统计就求出了路径长度和在 $[L,R]$ 之间的路径和。详情见代码：
```cpp
#include<bits/stdc++.h>
#include <cstdlib>
using namespace std;
typedef long long ll;
inline int read()
{
	int x=0;char ch;
	while((ch=getchar())<'0'||ch>'9');
	for(;ch>='0'&&ch<='9';ch=getchar())
		x=(x<<1)+(x<<3)+(ch^48);
	return x;
}
void write(int x)
{
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
const int N=1e6+5;
struct edge
{
	int v,nxt;
}e[N<<1];
int E,head[N];
inline void add(int u,int v)
{
	e[++E]={v,head[u]};
	head[u]=E;
}
int n,L,R,maxs[N],siz[N],k,rt,tot,dis[N],tmp[N],vis[N],buc[N],maxn;
ll ans,ansl,suf[N];
inline void getroot(int u,int f)
{
	siz[u]=1;maxs[u]=0;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==f||vis[v])continue;
		getroot(v,u);
		siz[u]+=siz[v];
		maxs[u]=max(maxs[u],siz[v]);
	}
	maxs[u]=max(tot-siz[u],maxs[u]);
	if(maxs[u]<maxs[rt])rt=u;
}
inline void getdis(int u,int f)
{
	buc[dis[u]]++;
	if(dis[u]>maxn)maxn=dis[u];
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(vis[v]||v==f)continue;
		dis[v]=dis[u]+1;
		getdis(v,u);
	}
}
inline ll calc(int u,int w)
{
	tmp[0]=0,maxn=0;dis[u]=w;getdis(u,0);
	for(int i=w;i<=maxn;i++)
		if(buc[i])
		{
			while(buc[i]--)
				tmp[++tmp[0]]=i;
			buc[i]=0;
		}
//	for(int i=1;i<=maxn;i++)cout<<buc[i]<<' ';
//	cout<<endl;
	for(int i=1;i<=tmp[0];i++)
		suf[i]=suf[i-1]+tmp[i];
	int l=1,r=tmp[0];
	ll ans=0;
	while(l<=r)//第一轮统计<=R的
	{
		while(l<=r&&tmp[l]+tmp[r]>R)--r;
		if(l>r)break;
		ans+=suf[r]-suf[l]+1ll*tmp[l]*(r-l);
		l++;
	}
	l=1,r=tmp[0];
	while(l<=r)//第二轮统计<=L-1的
	{
		while(l<=r&&tmp[l]+tmp[r]>L-1)--r;
		if(l>r)break;
		ans-=suf[r]-suf[l]+1ll*tmp[l]*(r-l);
		l++;
	}
	return ans;
}
void solve(int u)
{
	vis[u]=1;ans+=calc(u,0);
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(vis[v])continue;
		ans-=calc(v,1);
		maxs[rt=0]=n;tot=siz[v];
		getroot(v,u);
		solve(rt);
	}
}
int main()
{
	n=read();L=read();R=read();
	for(int i=2;i<=n;i++)
	{
		int x=read();
		add(i,x);add(x,i);
	}
	tot=maxs[rt=0]=n;
	getroot(1,0);
	solve(rt);
	cout<<ans<<endl;
	return 0;
}
```
最后要注意开```long long```。我的代码加上快读之后，目前耗时 17.93s 是次优解，占用的内存是最优解的一半，最优解似乎写的是一个树剖+树状数组的，常数应该比我的小多了。

---

## 作者：Lele_Programmer (赞：0)

# P10421 题解

好久没写点分治了，找了这道题当做模板题复习一遍吧。

## 思路

假设确定了一个点 $u$，我们可以把路径分成以下几类：

1. 简单路径经过点 $u$ 且 $u$ 不是其中一端。
2. 简单路径的一端位于 $u$。
3. 简单路径不经过点 $u$。

这三类答案加起来就是最终答案，发现第三种又可以找到另一个点 $u'$ 再次进行分治。

对于 $u$ 的每一个子树，我们求出子树中每一个点到 $u$ 的距离 $d$，把这些序列 $d$ 合并成一个序列 $arr$，求序列 $arr$ 中任意两数之和 $\le k$ 的答案数，也就是路径长度 $\le k$ 的答案数量，可以通过排序和双指针 $\mathcal{O}(n \log n)$ 求出。

发现求出的答案包括了以上的第一种和不合法的第三种，即简单路径不经过点 $u$ 但求的实际路径走到了点 $u$ 并绕回去，这个需要减掉，那么对于每一个子树的序列 $d$，同样这样求一次，求得的答案就是不合法的方案，减去即可。

对于第二种情况，在枚举每一个 $d$ 的时候统计以下即可。

每一次的 $n$ 为所用到的树的大小，我们只需要每一次分治的时候能把 $n$ 减半，那么时间复杂度可以做到 $\mathcal{O}(n \log^2 n)$，显然每一次取出树的重心作为点 $u$。

以上是点分治大概思路，这道题要统计的内容有所不同，多了一个下界限制，这一步很简单，分别求出不超过 $R$ 的答案以及不超过 $L-1$ 的答案，二者相间即可，而且本题的合法路径还要乘上其长度，只需简单修改代码中的细节即可，这里不做过多说明。

## 代码

```cpp
#define _graph(i,u) for (int i=h[u];~i;i=ne[i])
#define _rep(i,a,b) for (int i=(a);i<=(b);++i)

const int N=1000005;
const int M=2000005;

int n,L,R;
int e[M],ne[M],h[N],tot;
bool flag[N];
int d[N],arr[N],pre[N];

void add(int a,int b) {
    e[tot]=b,ne[tot]=h[a],h[a]=tot++;
}

int gsz(int u,int fa) {
    if (flag[u]) return 0;
    int sz=1;
    _graph(i,u) if (e[i]!=fa) sz+=gsz(e[i],u);
    return sz;
}

int gce(int u,int fa,int sz,int& ce) {
    if (flag[u]) return 0;
    int mx=0,s=1;
    _graph(i,u) if (e[i]!=fa) {
        int k=gce(e[i],u,sz,ce);
        s+=k;
        mx=max(mx,k);
    }
    mx=max(mx,sz-s);
    if (mx<=sz/2) ce=u;
    return s;
}

void gdis(int u,int fa,int dis,int& cnt) {
    if (flag[u]) return;
    d[++cnt]=dis;
    _graph(i,u) if (e[i]!=fa) gdis(e[i],u,dis+1,cnt);
}

int calc(int* arr,int n,int k) {
    int ans=0;
    sort(arr+1,arr+1+n);
    _rep(i,1,n) pre[i]=pre[i-1]+arr[i];
    int l=0,r=n;
    while (r>=1) {
        while (l+1<=r && arr[l+1]+arr[r]<=k) ++l;
        l=min(l,r-1);
        ans+=pre[l]+l*arr[r];
        r--;
    }
    return ans;
}

int solve(int u,int k) {
    if (flag[u]) return 0;
    gce(u,0,gsz(u,0),u);
    flag[u]=true;
    int ans=0,n=0;
    _graph(i,u) {
        int m=0; gdis(e[i],u,1,m);
        ans-=calc(d,m,k);
        _rep(j,1,m) {
            if (d[j]<=k) ans+=d[j];
            arr[++n]=d[j];
        }
    }
    ans+=calc(arr,n,k);
    _graph(i,u) ans+=solve(e[i],k);
    return ans;
}

i32 main() {
    memset(h,-1,sizeof(h));
    read(n),read(L),read(R);
    _rep(i,2,n) {
        int p;
        read(p);
        add(p,i),add(i,p);
    }
    int ansl=solve(1,L-1);
    memset(flag,0,sizeof(flag));
    int ansr=solve(1,R);
    write(ansr-ansl);
    return 0;
}
```

---


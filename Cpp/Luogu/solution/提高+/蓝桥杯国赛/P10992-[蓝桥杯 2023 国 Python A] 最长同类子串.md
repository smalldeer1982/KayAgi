# [蓝桥杯 2023 国 Python A] 最长同类子串

## 题目描述

对于两个等长的字符串 $A, B$，如果对于任意 $i, j$，都有 $A_i = A_j$ 和 $B_i = B_j$
同时满足或同时不满足，那么我们称 $A, B$ 是一对同类串。例如，`aabab` 和 `xxkxk` 是一对同类串，而 `abcde` 和  `abcdd` 则不是。

给定 $S, T$，找出一个尽可能大的 $k$ 使得 $S, T$ 分别含有一个长度为 $k$ 的子
串 $S', T'$，且 $S',T'$ 是同类串。


## 说明/提示

对于 $40\%$ 的评测用例，$|S |, |T| \le 500$；

对于 $50\%$ 的评测用例，$|S |, |T| \le 2000$；

对于所有评测用例，$1 \le |S |, |T| \le 10^5$，$S, T$ 中仅包含小写英文字母。


## 样例 #1

### 输入

```
aaaba
yxyy
```

### 输出

```
3
```

# 题解

## 作者：_ChongYun_ (赞：6)

### Solution

「同类串」的定义为对于两个等长的字符串 $s$ 和 $t$，所有位置上的字符都互相对应。目标是找出一个尽可能大的 $k$ 使得 $s, t$ 分别含有一个长度为 $k$ 的子串 $s', t'$，且 $s',t'$ 是「同类串」。

直接进行字符串哈希很难做。注意到答案 $k$ 具有单调性，我们可以进行二分答案将该问题转化为判断性问题。 

从「同类串」的定义出发，**所有字符出现位置相互对应**和**所有位置上的字符互相对应**显然是等价的。

那我们不妨从字符出现的位置入手。

进一步地，两个为一组「同类串」的字符串里的**所有字符上一次出现的位置一定相同**。

故存下每一个位置上一个出现该位置上的字符的位置，判断两个字符串中是否存在长度固定的区间里所有字符上一次出现的位置相同。

使用哈希维护一个滑动窗口，每次滑动单位长度 $1$ 的长度。设当前的固定长度为 $k$，滑动到的左端点为 $i$。可以提前预处理出字符上一次出现的位置、下一次出现该字符的位置，以做到 $\mathcal{O}(1)$ 地从上一个 $[i-1,i+k-2]$ 的窗口滑动到 $[i,i+k-1]$ 的窗口。

故判断函数可以 $\mathcal{O}(n)$ 解决。总时间复杂度为 $\mathcal{O}(n\log^2 n)$。

### Code


```cpp
/* 云云珂爱 */
#include<bits/stdc++.h>
#define int long long
#define ull unsigned long long
using namespace std;
int n,m;
string S,T;
ull base=1e5+3,qpow[100005];
ull lstS[205],lstT[205];
ull nowS[100005],nowT[100005];
ull nxtS[100005],nxtT[100005];
ull HashS[100005],HashT[100005];
map<ull,int> vis;
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	return x*f;
}
bool check(int x){
	vis.clear();
	memset(lstS,0,sizeof(lstS));
	memset(lstT,0,sizeof(lstT));
	for(int i=1;i<=n;i++) nxtS[i]=-1;
	for(int i=1;i<=m;i++) nxtT[i]=-1;
	for(int i=1;i<=n;i++) nowS[i]=max(n,m)+1;
	for(int i=1;i<=m;i++) nowT[i]=max(n,m)+1;
	for(int i=1;i<=n;i++){
		if(lstS[S[i]]) nxtS[lstS[S[i]]]=i,nowS[i]=i-lstS[S[i]];
		lstS[S[i]]=i;  
	}
	for(int i=1;i<=m;i++){
		if(lstT[T[i]]) nxtT[lstT[T[i]]]=i,nowT[i]=i-lstT[T[i]];
		lstT[T[i]]=i; 
	}
	ull now=0;
	for(int i=1;i<=x;i++) now=now*base+nowS[i];
	vis[now]=1;
	for(int i=2;i+x-1<=n;i++){
		now-=nowS[i-1]*qpow[x-1];
		now=now*base+nowS[i+x-1];
		if(nxtS[i-1]){
			int qwq=i+x-1-nxtS[i-1];
			if(nxtS[i-1]<=i+x-1){
				now-=nowS[nxtS[i-1]]*qpow[qwq];
				nowS[nxtS[i-1]]=max(n,m)+1;
				now+=nowS[nxtS[i-1]]*qpow[qwq];
			}
			else if(nxtS[i-1]<=n) nowS[nxtS[i-1]]=max(n,m)+1;
		}
		vis[now]=1;
	}
	now=0;
	for(int i=1;i<=x;i++) now=now*base+nowT[i];
	if(vis[now]) return 1;
	for(int i=2;i+x-1<=m;i++){
		now-=nowT[i-1]*qpow[x-1];
		now=now*base+nowT[i+x-1];
		if(nxtT[i-1]){
			int qwq=i+x-1-nxtT[i-1];
			if(nxtT[i-1]<=i+x-1){
				now-=nowT[nxtT[i-1]]*qpow[qwq];
				nowT[nxtT[i-1]]=max(n,m)+1;
				now+=nowT[nxtT[i-1]]*qpow[qwq];
			}
			else if(nxtT[i-1]<=m) nowT[nxtT[i-1]]=max(n,m)+1;
		}
		if(vis[now]) return 1;
	}
	return 0;
}
signed main(){
	cin>>S>>T;
	n=S.size(); m=T.size();
	S=" "+S; T=" "+T;
	qpow[0]=1;
	for(int i=1;i<=n;i++) qpow[i]=qpow[i-1]*base;
	int l=1,r=min(n,m),mid,ans;
	while(l<=r){
		mid=(l+r)>>1;
		if(check(mid)){
			l=mid+1;
			ans=mid;
		} 
		else r=mid-1;
	} 
	printf("%lld\n",ans);
	return 0;
}
```

2025.2.8 upd：忘记`map`的 $\log$ 了，总时间复杂度更正为 $O(n\log^2n)$。

---

## 作者：2022dyx (赞：3)

要求最大值，肯定要先二分答案。下面考虑 check 的过程，也就是如何判断同类串。如果我们能够找到一个哈希函数，使得同类串的值一定相同，非同类串的值大概率不同，那就可以直接把对应长度的全部子序列的哈希值扔到容器里判出现次数了。

对于判断字符串相同一类的问题，初见是一个字符串哈希，但对于这道题来说，由于我们不关心具体的字符是什么，而只关心相同字符出现的位置，因此最传统的那种哈希肯定是不适用的。为了验证出现位置，我们对于每一个数，将它上一次出现的位置当作权值做多项式哈希，这样就能达到我们的目的了。

剩下的细节就在代码里了。

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
constexpr int L = 1e9;
constexpr int N = 1e5 + 5;
constexpr int base = 233;
int nxt[N], pre[N], lst[30];
unsigned int pw[N];
string s, t;
unordered_map <int, int> mp;
void calc(string str, int x, int y) {
    pw[0] = 1;
    for (int i = 1; i < str.length(); ++i) pw[i] = pw[i - 1] * base;
    for (int i = 0; i < 26; ++i) lst[i] = -1;
    for (int i = 0; i < str.length(); ++i) {
        int op = str[i] - 'a';
        if (lst[op] == -1) { lst[op] = i, pre[i] = -1; continue; }
        pre[i] = lst[op], nxt[lst[op]] = i;
        lst[op] = i;
    }
    for (int i = 0; i < 26; ++i) if (lst[i] != -1) nxt[lst[i]] = str.length();
    unsigned int now = 0;
    for (int i = 0; i < x; ++i) if (pre[i] != -1) now += (i - pre[i]) * pw[x - i - 1];
    mp[now] += y;
    for  (int i = 0, j = x; j < str.length(); ++i, ++j) {
        if (nxt[i] < j) now -= (nxt[i] - i) * pw[j - nxt[i] - 1];
        now *= base;
        if (pre[j] > i) now += (j - pre[j]);
        mp[now] += y;
    }
}
bool check(int x) {
    mp.clear();
    calc(s, x, 1), calc(t, x, L);
    for (auto i : mp) if (i.second / L && i.second % L) return true;
    return false;
}
signed main() {
    cin.tie(0) -> sync_with_stdio(false); 
    cin >> s >> t;
    int l = 1, r = min(s.length(), t.length());
    while(l <= r) {
        int mid = (l + r) >> 1;
        if (check(mid)) l = mid + 1;
        else r = mid - 1;
    }
    cout << r;
}

```

---

## 作者：无名之雾 (赞：2)

zky 在 xyd 讲哈希的时候给的题目。

## solution

这里给出一个比较不聪明的做法。

自然的想到将 $S$ 中每个字符的出现位置的集合的哈希值算出来。

然后二分 $k$。

以一个滑动窗口的样式在 $T$ 上滑动。算出这个长度为 $k$ 的窗口上每个字符出现位置的集合的哈希值。

比较时，我们记录一个滑动窗口距离端点的位置，按照你的哈希函数 $f$ 还原即可。

复杂度 $(nv\log n)$，期中 $v$ 为字符集大小。

代码写得太丑不放了。

为什么大家的做法都比我精妙！

---

## 作者：COsm0s (赞：2)

对于“同类串”的定义，我们可以将他简化成：

在两个串 $s,t$ 中，如果相同的字母所出现的位置一致，则可视为同类。

比如在 `aabbcca` 和 `xxyyzzx` 中，

`a` 出现的位置为 `0 1 6`，`b` 为 `2 3`，`c` 为 `4 5`；

`x` 出现的位置为 `0 1 6`，`y` 为 `2 3`，`z` 为 `4 5`。

所有相同的字母所出现的位置可以一一对应，则这两个串同类。

回到题目，我们很容易看出答案可以二分得出。

所以二分 $k$ 之后，我们只需要判断 $s,t$ 中所有长度为 $k$ 的子串是否能匹配“同类”即可。

根据刚才的简化结论，发现可以将这些子串中**所有字母的出现的相对其在串中的前一个位置记录下来**。

还是以 `aabbcca` 为例，`a` 出现的位置为 `0 1 6`，`b` 为 `2 3`，`c` 为 `4 5`；

那么每个字母的相对其前一个位置可以视作：`a` 出现的位置为 `0 1 5`，`b` 为 `0 1`，`c` 为 `0 1`。

相当于一个**差分**。

将这些相对位置记录下来后，我们发现，只要两串中所有字母的相对其前一个位置可以一一对应，就可以算作“同类”。

这一部分显然可以用序列哈希和集合哈希搞定，简单来说就是把每个字母的相对位置用序列哈希压成一个数，再将各个字母的哈希值哈希起来判断。

而枚举长度为 $k$ 的子串时，我们需要对于每个字母采用双指针维护**当前子串中**的相对位置。

简单来说就是维护出在当前长度为 $k$ 的区间里的当前字母出现过的位置。

```cpp
while (pos[j] + 1 < (int)p[j].size() && p[j][pos[j] + 1] <= i + k - 1) pos[j] ++;
while (st[j] + 1 < (int)p[j].size() && p[j][st[j]] < i) st[j] ++;
```
类似于上述代码，其中 $p_j$ 表示 $j$ 字母在整个串中出现过的位置，而 $st_j,pos_j$ 即当前区间出现过的 $j$ 的双指针。

这样复杂度就是 $\Theta(n\log n)$ 了。


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define pb emplace_back
#define ull unsigned long long
const int N = 1e5 + 5, base = 1e9 + 7, mod = 1e9 + 9;
const long long inf = 0x3f3f3f3f3f3f3f3f;
char s[N], t[N];
int n, ans, hs1[30][N], hs2[30][N], pw[N];
int pos1[N], pos2[N], st1[N], st2[N], m;
vector<int> p1[30], p2[30];
int get1(int l, int r, int i) {
	if(l > r) return 0;
	return hs1[i][r] - 1ll * hs1[i][l - 1] * pw[r - l + 1];
}
int get2(int l, int r, int i) {
	if(l > r) return 0;
	return hs2[i][r] - 1ll * hs2[i][l - 1] * pw[r - l + 1];
}
bool check(int k) {
	unordered_map<ull, bool> mp;
	for (int i = 0; i < 26; i ++) st1[i] = st2[i] = 0, pos1[i] = pos2[i] = -1;
	for (int i = 1; i <= m - k + 1; i ++) {
		vector<int> o2;
		for (int j = 0; j < 26; j ++) {
			while (pos2[j] + 1 < (int)p2[j].size() && p2[j][pos2[j] + 1] <= i + k - 1) pos2[j] ++;
			while (st2[j] + 1 < (int)p2[j].size() && p2[j][st2[j]] < i) st2[j] ++;
			if(st2[j] < pos2[j]) o2.pb((1ll * get2(st2[j] + 1, pos2[j], j) * base + (i + k - p2[j][pos2[j]])));
  			//双指针+序列哈希
		}
      	sort(o2.begin(), o2.end());
		ull sum2 = 0;
		for (int e : o2) sum2 = sum2 * mod + e;
		mp[sum2] = 1;
  		//集合哈希
	}
	for (int i = 1; i <= n - k + 1; i ++) {
		vector<int> o1;
		for (int j = 0; j < 26; j ++) {
			while (pos1[j] + 1 < (int)p1[j].size() && p1[j][pos1[j] + 1] <= i + k - 1) pos1[j] ++;
			while (st1[j] + 1 < (int)p1[j].size() && p1[j][st1[j]] < i) st1[j] ++;
			if(st1[j] < pos1[j]) o1.pb((1ll * get1(st1[j] + 1, pos1[j], j) * base + (i + k - p1[j][pos1[j]])));
		}
      	sort(o1.begin(), o1.end());
		ull sum1 = 0;
		for (int e : o1) sum1 = sum1 * mod + e;
		if(mp.count(sum1)) return 1;
	}
	return 0;
}
void Solve() {
	cin >> (s + 1) >> (t + 1);
	n = strlen(s + 1), m = strlen(t + 1), pw[0] = 1;
	for (int i = 1; i <= n; i ++)
		p1[s[i] - 97].pb(i);
	for (int i = 1; i <= m; i ++)
		p2[t[i] - 97].pb(i);
	for (int i = 1; i <= max(n, m); i ++)
		pw[i] = 1ll * pw[i - 1] * base;
	for (int i = 0; i < 26; i ++) {
		for (int j = 0; j < (int)p1[i].size() - 1; j ++) {
			hs1[i][j + 1] = (1ll * hs1[i][j] * base + p1[i][j + 1] - p1[i][j]);
		}
		for (int j = 0; j < (int)p2[i].size() - 1; j ++) {
			hs2[i][j + 1] = (1ll * hs2[i][j] * base + p2[i][j + 1] - p2[i][j]);
		}
	}
  //记录相对位置
	int l = 1, r = min(n, m), ans = 1;
	while (l <= r) {
		int mid = l + r >> 1;
		if (check(mid)) l = mid + 1, ans = mid;
		else r = mid - 1;
	}
	printf("%lld\n", ans);
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	int T = 1;
//	cin >> T;
	while (T --) {
		Solve();
	}
	return 0;
}
```

---


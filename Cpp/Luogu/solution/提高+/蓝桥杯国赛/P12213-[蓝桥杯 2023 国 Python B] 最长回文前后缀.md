# [蓝桥杯 2023 国 Python B] 最长回文前后缀

## 题目描述

给定一个字符串 $S$，请找出 $S$ 的一个前缀和后缀，使得它们拼接后是一个回文串。请输出这个串的最长长度。

## 说明/提示

### 样例说明

选择前缀 $\tt{aababa}$ 和后缀 $\tt{a}$ 可以得到 $\tt{aababaa}$。

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例， $|S| \leq 300$；
- 对于 $60\%$ 的评测用例， $|S| \leq 3000$；
- 对于所有评测用例， $1 \leq |S| \leq 10^5$。

## 样例 #1

### 输入

```
aababa```

### 输出

```
7```

# 题解

## 作者：Wxb2010 (赞：8)

## 前言

[题目传送门](https://www.luogu.com.cn/problem/P12213)

前置知识： manacher 算法 [模板题](https://www.luogu.com.cn/problem/P3805)

推荐练习：[P4555 最长双回文串](https://www.luogu.com.cn/problem/P4555) 

参考资料：[推荐练习的某篇题解](https://www.luogu.com.cn/article/mvf7v02q)

## 题目描述

给定一个字符串 S，请找出 S 的一个前缀和后缀，使得它们拼接后是一个回文串。请输出这个串的最长长度。

## 分析

先令  $n= |S|$ 

拿到这个题目看数据范围，第一眼可能想到  $O(n\log n)$ 的哈希做法，但前缀和后缀拼接似乎并不好写哈希。

所以我们先考虑把后缀转化一下，尝试令 T 为 S 翻转之后的字符串。

我们可以观察到：拼接之后的回文串将会由两部分组成，

第一部分是 S 与 T 串的公共前缀（可以为空），

第二部分是 S **或** T 串接在这个前缀之后的一个回文串（可以为空）。

对于第一部分，可以从前向后枚举，暴力匹配。

那么我们需要做的就是预处理出两串的每个前缀之后的最长回文串。

我们参考[参考资料](https://www.luogu.com.cn/article/mvf7v02q)的做法，对每个字符串跑一遍 manacher ,

在此过程中，我们就可以求出以每个字符（在扩展之后的字符串中）为左端点的 **最长饱和回文串** 的长度，

然后再从前向后刷一遍，求出对应的 **最长回文串** 的长度，

最后就是愉快的暴力匹配，统计答案。

此题中有一些细节要处理好，写在注释中了。

## code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rei register int
#define N 100005

char a[N],b[N],h1[N<<1],h2[N<<1];//h 是展开数组 
int n,len,p1[N<<1],p2[N<<1],l1[N<<1],l2[N<<1];//p 是半径数组，l 存储最长回文串长度 

void ch(char *x,char *y)//扩展 
{
	rei k=0;y[k++]='$',y[k++]='#';
	for(rei i=0;i<n;i++) y[k++]=x[i],y[k++]='#';
	y[len=k]='&';
}

void manacher(char *op,int *r,int *l) 
{
	int mr=0,c;
	for(rei i=1;i<len;i++)
	{
		if(i<mr) r[i]=min(r[2*c-i],mr-i);
		else r[i]=1;
		while(op[i+r[i]]==op[i-r[i]]) r[i]++;
		if(i+r[i]-1>mr) mr=i+r[i]-1,c=i;
		l[i-r[i]+1]=max(l[i-r[i]+1],r[i]-1);//求出以该点为左端点的最长饱和回文串 
	}
	for(rei i=3;i<len;i+=2) l[i]=max(l[i-2]-2,l[i]);
	//求出以该点为左端点的最长回文串（含饱和回文串与不饱和回文串） 
}

int main()
{
	scanf("%s",a);n=strlen(a);
	int ans=0;
	for(rei i=0;i<n;i++) b[i]=a[n-i-1]; 
	ch(a,h1),manacher(h1,p1,l1);
	ch(b,h2),manacher(h2,p2,l2); 
	for(rei i=2;i<=len;i+=2)
	{
		ans=max(max(i-2+l1[i-1],i-2+l2[i-1]),ans);
		//注意细节处理，l数组只考虑 # 字符，匹配字符只考虑原串字符
		//此时是当前位置还 没有被匹配上 的答案 
		if(h1[i]!=h2[i]) break;
	}
	printf("%d",ans);
	return 0;
} 
```
## 时间复杂度分析

manacher 算法是  $O(n)$ 的，暴力匹配是 $O(n)$ 的，每一步查询是  $O(1)$ 的，总的复杂度就是 $O(n)$ 的。

当然，也可以用哈希加二分写，时间复杂度就是 $O(n\log n)$ 的。

---

## 作者：fengzhaoyu (赞：5)

~~来一发 c++ 版的 hash 加 manacher。~~
## 题意
给一个字符串，求它前缀和后缀拼起来的字符串是回文字符串最大长度。
## 思路
看了题解区有只用 manacher 的做法，但原因不好证（~~看不懂思密达~~）。

我们知道，manacher 中回文串都是有中点的（即使长为偶数中间也有插点），而答案是由前后缀构成的，那说明中点也只会在搜索的前后缀中，所以我们可以遍历中点来寻找答案。

先讨论中点在前缀的情况。

设遍历到的中点为 $i$。既然答案是回文串，那以 $i$ 点为中点的子串也一定是回文串，这样我们可以先在原串中求出以 $i$ 为中点的最大回文串（$RL_i$）。再看它距离开头差了哪些字符，因为要是前缀，我就必须把差的补上。此时我就要去看看后面是否存在一个后缀与前面差的相等，使得拼好的字符串回文，如果没有，那这种情况不存在。而断判前后缀相不相等，是 hash 所擅长的。

遍历中点在后缀时也同理。

最后取所有合法答案的最大值即可。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ull unsigned long long
const int N=2e5+15;
ull h1[N],h2[N];
int p[N],d=1331;
void manacher_and_hash(string y)
{
	string s="%#";
	for(int i=0;i<y.size();i++)
	{
		s+=y[i];
		s+="#";
	}
	int maxright=0,pos=0;
	int len=s.size();
	for(int i=1;i<len;i++)
	{
		p[i]=maxright>i?min(maxright-i,p[pos*2-i]):1;
		while(s[p[i]+i]==s[i-p[i]]) p[i]++;
		if(p[i]+i>maxright)
		{
			maxright=i+p[i];
			pos=i;
		}
	}
	for(int i=1;i<len;i++)
	{
		h1[i]=h1[i-1]*d+(ull)(s[i]-'#');
//		cout<<h1[i]<<endl;
	}
	for(int i=len-1;i>=1;i--)
	{
		h2[i]=h2[i+1]*d+(ull)(s[i]-'#');
	}	
	int ans=0;
	for(int i=1;i<len;i++)//中点在前缀的情况
	{
		int k=i-p[i];
		if(h1[k]==h2[len-k])ans=max(ans,p[i]-1+k);//此处最好手推一下，不然可能会有错
	}
	for(int i=len-1;i>=1;i--)//后缀
	{
		int k=i+p[i];
		if(h2[k]==h1[len-k]) ans=max(ans,p[i]-1+(len-k));
	}
	printf("%d\n",ans);
}
int main()
{
	string s;
	cin>>s;
	manacher_and_hash(s);
	return 0;
}
```

---

## 作者：gghack_Nythix (赞：1)

## 前言：

我字符串还是太垃圾了，写了挺久的。

## 分析：

首先你可以发现，你可以找出一段前缀和一段后缀，满足他们拼在一起是回文串，且前缀当左半边，后缀当右半边。具体而言：设你找到了 $[1,p_1]$ 和 $[p_2,n]$ （ $n$ 为字符串长度，且这两个区间长度相等 ），则 $\forall k\in[0,p_1-1] $，有 $s_{1+k}=s_{n-k}$。

但这样还不够，我们考虑将找出来的前缀和后缀放在左右两端，中间显然可以再加入一个回文串，由于题目要求，这个回文串必须是以 $p_1+1$ 为左端点，或者以 $p_2-1$ 为右端点的（对应拓展前后缀的情况）。

那这个回文串是好找的，用哈希判定一下就行了，然后就做完了。

```cpp
# include <iostream>
# include <algorithm>
# define int unsigned long long 
using namespace std ; 
constexpr int bit = 1145141919 , N = 3e5 + 5 ; 
string s , s2 , s3 ;
int ha[N] , res , rha[N] , n ; 
int ksm ( int a , int b ) { int z = 1 ; while ( b ) { if ( b & 1LL ) z = ( z * a ) ; a = ( a * a ) , b >>= 1 ;  } return z ;  }
int gpre ( int l , int r ) { return ha[r] - ha[l - 1] * ksm ( bit , r - l + 1 ) ; } 
int gsuf ( int l , int r ) { return rha[l] - rha[r + 1] * ksm ( bit , r - l + 1 ) ; }
int calclft ( int x ) {
	int z = 0 ;
	for ( int i = x + 1;i <= n;++i ) {
		int ll = i - ( x + 1 ) + 1 ; 
		if ( ll & 1 ) {
			int mid = ( x + 1 + i ) >> 1 ; 
			if ( gpre ( x + 1 , mid ) == gsuf ( mid , i ) ) z = max ( z , ll ) ; 
		}
		else {
			int mid1 = ( x + 1 + i ) >> 1 , mid2 = ( x + 1 + i + 1 ) >> 1 ; 
			if ( gpre ( x + 1 , mid1 ) == gsuf ( mid2 , i ) ) z = max ( z , ll ) ; 
		} 
	}
	return z ; 
}
int calcrgt ( int x ) {
	int z = 0 ;
	for ( int i = x - 1;i >= 1;--i ) {
		int ll = ( x - 1 ) - i + 1 ; 
		if ( ll & 1 ) {
			int mid = ( x - 1 + i ) >> 1 ; 
			if ( gpre ( i , mid ) == gsuf ( mid , x - 1 ) ) z = max ( z , ll ) ; 
		}
		else {
			int mid1 = ( x - 1 + i ) >> 1 , mid2 = ( x - 1 + i + 1 ) >> 1 ; 
			if ( gpre ( i , mid1 ) == gsuf ( mid2 , x - 1 ) ) z = max ( z , ll ) ; 
		} 
	}
	return z ; 
}
signed main () {
	cin >> s , n = s.size() , s = ' ' + s ;
	for ( int i = 1;i <= n;++i ) ha[i] = ha[i - 1] * bit + ( s[i] - 'a' ) ;
	for ( int i = n;i >= 1;--i ) rha[i] = rha[i + 1] * bit + ( s[i] - 'a' ) ; 
	int lp = 1 , rp = n ; 	
	while ( lp <= n && rp >= 1 && s[lp] == s[rp] ) ++ lp , -- rp ; 
	-- lp , ++ rp ;
	return cout << ( lp << 1 ) + max ( calclft ( lp ) , calcrgt ( rp ) ) , 0 ;
}	
```

---

## 作者：gmb7291234 (赞：1)

~~模板题~~

首先，我们发现选的回文串一定是形如 $x,y,y,y,x,x,x$ 的形式（$x$ 表示选，$y$ 表示不选）。

那么我们一定会选形如 $a,b,y,y,y,b,a$ 的数（$a,b$ 为常数，$y$ 为没有定定选不选的数）。

所以第一步贪心的选最大的 $x$，满足 $1-x$ 和 $y-n$ 两部分拼起来为回文串。

然后，我们只能选左端点为 $x+1$ 和右端点为 $y-1$ 的最长的回文字符串，这样贪心便得出了最优解。

对了，还要特判字符串本身为回文字符串的情况，因为在这种情况下，第一步无法执行。

### code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,b[100005],b1[100005],ha[100005],ha1[100005];
char s[100005];
const int p=1000000007;
int ats(int l,int r){return (ha[r]-ha[l-1]+p)*b1[l-1]%p;}
int ats1(int l,int r){return (ha1[r]-ha1[l-1]+p)*b1[l-1]%p;}
int as1(int x){
	int o=0;
	for(int i=x;i<=n;i++){
		if(ats(x,i)==ats1(n-i+1,n-x+1))o=i-x+1;
	}
	return o;
}
int as2(int x){
	int o=0;
	for(int i=x;i>=1;i--){
		if(ats(i,x)==ats1(n-x+1,n-i+1))o=x-i+1;
	}
	return o;
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	b[0]=b1[0]=1;b[1]=131;b1[1]=190839696;
	for(int i=2;i<=100000;i++){
		b[i]=b[i-1]*b[1]%p;
		b1[i]=b1[i-1]*b1[1]%p;
	}
	cin>>(s+1);n=strlen(s+1);
	for(int i=1;i<=n;i++)ha[i]=(ha[i-1]+b[i]*(s[i]-'a'))%p;
	reverse(s+1,s+n+1);
	for(int i=1;i<=n;i++)ha1[i]=(ha1[i-1]+b[i]*(s[i]-'a'))%p;
	reverse(s+1,s+n+1);
	int l=1,r=n;
	while(s[l]==s[r]&&l<=n&&r>=1){
		l++;r--;
	}
	if(l==n+1){
		cout<<n*2;
		return 0;
	}
	cout<<l*2-2+max(as1(l),as2(r));
	return 0;
}
```

---

## 作者：yr409892525 (赞：1)

### [P12213 [蓝桥杯 2023 国 Python B] 最长回文前后缀](https://www.luogu.com.cn/problem/P12213)
不妨把后缀翻折到前缀，由于回文，所以相等，所以剩下的子串单独回文。           

可以先预处理出原字符串的最长相同前后缀。                 

所以答案前缀会被分成两个部分。
1. 一个部分在最长相同前后缀内
2. 一个部分为回文串，可以使用数组统计。           

答案为 $2\times (1) + (2)$。
```cpp
#include<bits/stdc++.h>

using namespace std;

const int kMaxN = 2e7 + 5;

int n, _n, l[kMaxN], ans, x, L[kMaxN], R[kMaxN];
string _s, s;

void Add() {
	n = 2 * _n + 1;
	for (int i = 0; i < n; i++) {
		s += i & 1 ? _s[i / 2] : '#';
	}
}

void Manacher() {
	for (int i, j = 0, k = 0; k < n; k++) {
		if (k < j) {
			if (k + l[2 * i - k] < j) {
				l[k] = l[2 * i - k];
				continue; 
			}
		} else {
			j = k;
		}
		for (i = k; j < n && j <= 2 * i && s[j] == s[2 * i - j]; j++) {}
		l[k] = j - i;
	}
}

int main() {
	cin >> _s;
	_n = _s.size();
	for (;_s[x] == _s[_n - x - 1] && x < _n; x++) {}
	Add();
	Manacher();
	for (int i = 0; i < n; i++) {
		L[i - l[i] + 2] = max(L[i - l[i] + 2], l[i] - 1);
		R[i + l[i]] = max(R[i + l[i]], l[i] - 1);
	}
	for (int i = 3; i <= n; i += 2) {
		L[i] = max(L[i], L[i - 2] - 2);
	}
	for (int i = n; i >= 1; i -= 2) {
		R[i] = max(R[i], R[i + 2] - 2);
	}
	for (int i = 0; i <= 2 * x; i += 2) {
		ans = max(ans, i + max(L[i + 1], R[n - i])); 
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Programmeryhl (赞：1)

### 前言

前置知识：[Manacher 求回文串](https://www.luogu.com.cn/problem/P3805)

### 题意简介

给定一个字符串 $S$，求取其前后缀拼接后能形成的最大回文串长度。

### 思路

由于我们并不想对后缀进行操作，故将 $S$ 翻转为 $S'$，答案显然由两部分构成：

- $S$ 与 $S'$ 的最长公共前缀（将 $S'$ 翻转回去这将分别作为答案的左右两端）。

- 对 $S$ 和 $S'$ 分别求接在最长公共前缀后的最长回文串，取其较大者（直接作为答案的中间部分）。

### 求解方法

第一部分的答案可以暴力枚举计算，对于第二部分，Manacher 可以求解 $arr_i$，即以位置 $i$ 为中心的最大回文串半径，此时 $i-arr_i+1$ 就是该回文串的左端点，若该左端点刚好是第一部分所求出前缀的下一个位置则可以用于更新第二部分的答案。

时间复杂度 $O(n)$。

### Code

```c++
#include<iostream>
#include<algorithm>
#define IOS ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
using namespace std;
const int N=1e5+5;
string str1,str2;
int Calc(string tmp)
{
    int n=tmp.length(),L=0,R=-1,arr[N<<2]={0},maxx=0;
    char S[N<<2];
    tmp=" "+tmp,S[0]='&';
    for(int i=1;i<=n;i++)
        S[(i<<1)-1]=tmp[i],S[i<<1]='&';
    for(int i=0;i<=(n<<1);i++)
    {
        if(i<=R) arr[i]=min(arr[L+R-i],R-i);
        while(i-arr[i]>=0&&i+arr[i]<=(n<<1)&&S[i-arr[i]]==S[i+arr[i]]) arr[i]++;
        if(i+arr[i]-1>R) L=i-arr[i]+1,R=i+arr[i]-1;
    }
    //上面是Manacher的板子
    for(int i=0;i<=(n<<1);i++)
        if(i-arr[i]+1==0) maxx=max(maxx,arr[i]-1);
    return maxx;
}
int main()
{
    IOS;
    cin>>str1;
    str2=str1;
    reverse(str2.begin(),str2.end());//翻转字符串
    int pre=-1;//求解最长公共前缀
    while(pre+1<str1.length()&&str1[pre+1]==str2[pre+1]) pre++;
    //通过substr截取最长公共前缀的下一位至末端，这一段才是第二部分答案的可用部分
    cout<<((pre+1)<<1)+max(Calc(str1.substr(pre+1,str1.length()-pre-1)),Calc(str2.substr(pre+1,str2.length()-pre-1)))<<'\n';
    return 0;
}
```

---

## 作者：dsj2012 (赞：1)

# 题意
在一个字符串中取一个前缀和后缀，将取出来的字符串拼接之后新的字符串要是一个回文串。问：这个回文串的长度最长是多少。
## 思路
我们将整个拼接出来的回文串分成两个部分，一个是在字符串中取的后缀与和这个后缀匹配的一个前缀，一个就是剩下的中间部分。

为什么这样分呢？因为，当我们选择一个后缀的时候，这个后缀如果不能与相同长度的前缀匹配那么拼接的回文串也就不会匹配。

然后，中间的部分肯定是与前缀相连的，因为只能取一个前缀和一个后缀。所以中间部分只能是顺带着取得，那么为了让答案尽可能大，我们就要让顺带着的部分尽可能长。

那么，怎么判断可不可以带呢？因为回文串的左右部分确定了，且左右部分的长度相同，那么中间部分就一定是回文串才能保证最后的字符串是回文的。

因此我们就是在找到前后缀之后，在前后缀的后边求一个最长回文串，记住要与前缀相连。但是，这对吗？

根据原本的思考剩下的部分是不是要在前缀之后找，但是为什么不能是后缀之后找呢？为什么一定是与前缀相连呢？从后缀找一个回文串也是可行的啊。毕竟只要相连就可以了。

这个时候我就有一个偷懒的地方了，因为是一个回文串所以前后看都是一样的，那么我们就可以将整个字符串倒过来后在求一边原本的方法。
## code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,maxn;
string s,str;
int p[31000007];
void check(string s){
	str = "^";
	for(int i = 1 ; i <= n ; i ++){
		str += '#';
		str += s[i];
	}
	str += '#';
	str += '@';
	m = n * 2 + 1;
}
void manache(){
	int R = 0;
	int mid = 0,ans = 0;
//	cout << str << endl;
	for(int i = 1 ; i <= m ; i ++){
		if(i < R){
			p[i] = min(p[2 * mid - i] , R - i);
		}else{
			p[i] = 1;
		}  
		while(str[i + p[i]] == str[i - p[i]]){
			p[i] ++;
		}
		if(i + p[i] > R){
			R = i + p[i];
			mid = i;
		}
	}
}
void init(string s){
	string d = "";
	for(int i = s.size() - 1 ; i >= 0 ; i --){
		d += s[i];
	}
//	cout << s << "  " << d << endl;
	string dd = "";
	for(int i = 0 ; i < s.size() ; i ++){
		if(s[i] == d[i]){
			dd += s[i];
		}else{
			break;
		}
	} 
	string xx = "";
	for(int i = dd.size() ; i < s.size() ; i ++){
		xx += s[i];
	}
	n = xx.size();
 	xx = " " + xx;
	check(xx);
	manache();
	int ans = 0;	
//	cout << str << "\n";
	for(int i = 1 ; i <= m ; i ++){
//		cout << i << " " << p[i] << "\n";
		if(p[i] >= i){
			int x = dd.size();
			ans = max(ans , p[i] - 1);
		}
	} 
	int x = dd.size();
	maxn = max(maxn , ans + x * 2);
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin >> s;
	string d = "";
	for(int i = s.size() - 1 ; i >= 0 ; i --){
		d += s[i];
	}
	init(s);
	init(d);
	cout << maxn;
	return 0;
}
```

---

## 作者：_Chronostatis_ (赞：1)

## 题意
给定一个字符串，要求选择一个前缀和一个后缀，使得将前缀和后缀按顺序拼接后得到的最大回文串长度。

## 思路
核心算法：[Manacher](https://oi-wiki.org/string/manacher/).

首先，看到回文串，就要想起回文串的性质：翻转后和原串一样。正好要求选择前缀和后缀，所以可以将原串 $s$ 复制一遍，然后翻转得到 $t$。

此时，发现选择出来的答案其实是 $s$ 和 $t$ 的最长公共前缀 $c$ 加上 $s$ 和 $t$ 去掉 $c$ 后以开头字符为左边界的最长回文串。让我们拿 $s = \texttt{ababaa}$ 来举例：

![](https://cdn.luogu.com.cn/upload/image_hosting/g1z01hq0.png)

此时答案为 $\texttt{a.....a}$（`.`表示未知字符）

然后，在 $s - c$ 和 $t - c$ 中，选取以首字符为起点的最长回文子串 $l$。在这个数据中，$l = \texttt{ababa}$。

最终，答案为 $ans = \texttt{aababaa}$。

看完这段思路后，你可能会发问：$s - c$ 和 $t - c$ 中最大的答案可能被拆开。即答案一部分在 $s - c$，另一部分在 $t - c$。但是，注意到回文的性质：翻转后和原串一样。所以，如果被拆开了，那么被拆开的答案一定被 $c$ 包含，也就是不会有这种情况。

快速求解回文串长度使用 Manacher 算法。

## 代码
```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;

const int MAXN = 1e5 + 10;

template<size_t N> struct Manacher {
	string s;
	int d[N << 1], len;
	Manacher(const string &S) { // Manacher
		s = "#";
		for (char c : S) {
			s += c, s += '#';
		}
		len = s.size();
		for (int i = 0, l = 1, r = -1; i < len; i++) {
		  int k = i > r ? 1 : min(d[l + r - i], r - i + 1);
		  for (; i - k >= 0 && i + k < len && s[i - k] == s[i + k]; k++);
		  d[i] = --k;
		  if (i + k > r) {
		    l = i - k, r = i + k;
		  }
		}
	}
	int get() {
		int ans = 0;
		for (int i = 1; i < len; i++) {
			if ((d[i] - i >> 1) >= 0) ans = max(ans, d[i]); // 求以首字符为起点的最长回文串长度
		}
		return ans;
	}
};

string s;

int main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> s;
  string t = s;
  reverse(t.begin(), t.end());
  int n = s.size(), pos = 0;
  for (; pos < n && s[pos] == t[pos]; pos++); // 求解 c 长度
  string _s, _t;
  for (int i = pos; i < n; i++) {
  	_s += s[i], _t += t[i];
	}
  Manacher<MAXN> M1(_s), M2(_t); // 求解最长回文串长度
  cout << (pos << 1) + max(M1.get(), M2.get());
  return 0;
}
```

---

## 作者：Ericnoi (赞：1)

# P12213 题解

[题目传送门](https://www.luogu.com.cn/problem/P12213)

# 分析 

在这一题中，我们要善用目标条件，即“拼出来的字符串是回文串”这一点。而不能仅仅试图转化成模板。

我们来看下面一幅图：

![](https://cdn.luogu.com.cn/upload/image_hosting/6dcf2qik.png)

上面的是原字符串，下面的是拼出来的回文串。我们称之为字符串甲和字符串乙。

显然，字符串甲的前五个字符和字符串乙的前五个字符相同，字符串甲的后两个字符和字符串乙的后两个字符相同。

注意到，由于字符串乙是回文串，所以后两个字符和前两个字符是相反的。

所以，字符串甲的前两个字符和后两个字符也是相反的。而这也是选择方案的第一个组成部分，**一对相反的前后缀**。可以用哈希处理。

注意到还有第二个组成部分，即橙色部分。注意到因为红色的全同关系，所以橙色也有全同关系。而由于黄色对称轴的存在，甲乙字符串的橙色部分都是回文串。这部分用马拉车算法处理就行了，详见 [P4555](https://www.luogu.com.cn/problem/P4555) 的处理方法。

橙色部分也有可能跟着蓝色部分，亦然同理。

最后，枚举蓝色部分长度，取最大长度即可。

~~如果觉得讲得清楚就点个赞吧。~~

# Code

既然禁止使用C++，那我就给一份 python代码吧：

```python
import sys

def extend(s):
    res = []
    for c in s:
        res.append('#')
        res.append(c)
    res.append('#')
    return ''.join(res)

def manacher(s):
    ex = extend(s)
    c, r, n = 0, 0, len(ex)
    p = [0] * n
    for i in range(n):
        if r > i:
            len_val = min(p[2 * c - i], r - i)
        else:
            len_val = 1
        while i + len_val < n and i - len_val >= 0 and ex[i + len_val] == ex[i - len_val]:
            len_val += 1
        if i + len_val > r:
            r = i + len_val
            c = i
        p[i] = len_val
    return p

class HashString:
    _base_pow_dict = {}
    def __init__(self, s, base=131):
        self.base = base
        self.n = len(s)
        self.hash_arr = []
        if base not in HashString._base_pow_dict:
            HashString._base_pow_dict[base] = []
        base_pow_list = HashString._base_pow_dict[base]
        
        now = 0
        for i, char in enumerate(s):
            now = now * base + ord(char)
            self.hash_arr.append(now)
            if len(base_pow_list) < i + 1:
                while len(base_pow_list) <= i:
                    if len(base_pow_list) == 0:
                        last = 1
                    else:
                        last = base_pow_list[-1]
                    base_pow_list.append(last * base)
        self.base_pow_list = base_pow_list

    def get_hash(self, l, r=None):
        if r is None:
            r = self.n - 1
        if l == 0:
            return self.hash_arr[r]
        else:
            return self.hash_arr[r] - self.hash_arr[l-1] * self.base_pow_list[r - l]

def solve(s):
    n = len(s)
    t = s[::-1]
    hs = HashString(s)
    ht = HashString(t)
    p_arr = manacher(s)
    m = len(p_arr)
    r_arr = [0] * m
    l_arr = [0] * m
    j = m - 1
    for i in range(m-1, -1, -1):
        while j >= i - p_arr[i] + 1:
            r_arr[j] = i - j
            j -= 2
            if j < 0:
                break  
    j = 0
    for i in range(m):
        while j <= i + p_arr[i] - 1:
            if j >= m:
                break
            l_arr[j] = j - i
            j += 2
            
    ans = max(r_arr[0], l_arr[m-1])
    for len_val in range(1, n+1):
        if hs.get_hash(0, len_val-1) != ht.get_hash(0, len_val-1):
            continue
        idx1 = len_val * 2
        idx2 = m - len_val * 2 - 1
        ans = max(ans, len_val * 2 + r_arr[idx1])
        ans = max(ans, len_val * 2 + l_arr[idx2])
    return ans

def main():
    s = sys.stdin.readline().strip()
    print(solve(s))

if __name__ == '__main__':
    main()
```

---

## 作者：zhangxiaoyu008 (赞：0)

[题目传送门](/problem/P12213)

[$\mathtt{My \ Blog}$——题解：P12213 [蓝桥杯 2023 国 Python B] 最长回文前后缀](/article/19bp7mw9)

题目要求找出 $S$ 的一个前缀和后缀，使得它们拼接后是一个回文串，比如 $\tt{abbabba}$，我们发现可以用前缀 $\tt{abba}$ 和后缀 $\tt{bba}$，或前缀 $\tt{abbab}$ 和后缀 $\tt{ba}$ 得到回文串（etc.），观察一下？

好像 $\tt{abba}$ 可以拆成 $\tt{abb}$ 和 $\tt{a}$ 的形式，$\tt{abbab}$ 可以拆成 $\tt{ab}$ 和 $\tt{bab}$，也就是另一个字符串翻转和一个回文串？

是的！因为把回文串拆成两部分，一定会变成一个字符串和这个字符串翻转的结果加上一个回文串！（读者自证，只需枚举断点讨论即可）。

然后，枚举一个点 $i$，如果和 $S$ 中对称的字符不相同就退出，否则就是用从 $S$ 开头到 $i$ 这段长的两倍（因为后缀的长度也要算进去）+从 $i + 1$ 开始的回文串的最长长度来更新答案即可。

而又可以用 $\tt{Manacher}$ 来求出以任意一个点作为回文串的左端点，最长的回文串长度（不会的做[这道题](/problem/P4555)）。

## Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
int p[N], l[N];
char s[N], t[N];
void Manacher(char *s, int n) {
	int mid = 0, pos = 1;
	for(int i = 1; i <= n; i ++) {
		if(pos > i) p[i] = min(p[2 * mid - i], pos - i);
		else p[i] = 1;
		while(s[i + p[i]] == s[i - p[i]]) p[i] ++;
		if(i + p[i] > pos) pos = i + p[i], mid = i;
		l[i - p[i] + 1] = max(l[i - p[i] + 1], p[i]);
	}
}
int main()
{
	scanf("%s", s);
	int n = strlen(s);
	for(int i = 0; i < n; i ++) {
		t[i + 1 << 1] = s[i];
		t[i + 1 << 1 | 1] = '#'; 
	}
	t[1] = '#', t[0] = '?';
	int m = n << 1 | 1;
	Manacher(t, m);
	for(int i = 2; i <= m; i ++) l[i] = max(l[i], l[i - 1] - 1);
	for(int i = 2; i <= m; i ++)
		if(!(i & 1))
			l[(i >> 1) - 1] = l[i];
	int res = 0;
	for(int i = 0; i < n; i ++)
		if(s[i] != s[n - i - 1]) break;
		else res = max(res, (i + 1 << 1) + l[i + 1]);
	printf("%d\n", res);
	return 0;
}
```

然后就喜提 $\tt{WA}$ $\tt{35pts}$!

哦，还有一种情况，聪明的你肯定发现了为什么上面写的只需枚举断点讨论即可，因为有可能断点在回文串的左边！

所以再求出以任意一个点作为回文串的右端点，最长的回文串长度，就 $\tt{AC}$ 了。

## Code:
```cpp
#include <bits/stdc++.h>
using namespace std;‍‌
const int N = 2e5 + 10;‍‌
int p[N], l[N], r[N];‍‌
char s[N], t[N];‍‌
void Manacher(char *s, int n) {‍‌
	int mid = 0, pos = 1;‍‌
	for(int i = 1;‍‌ i <= n;‍‌ i ++) {‍‌
		if(pos > i) p[i] = min(p[2 * mid - i], pos - i);‍‌
		else p[i] = 1;‍‌
		while(s[i + p[i]] == s[i - p[i]]) p[i] ++;‍‌
		if(i + p[i] > pos) pos = i + p[i], mid = i;‍‌
		l[i - p[i] + 1] = max(l[i - p[i] + 1], p[i]);‍‌
		r[i + p[i] - 1] = max(r[i + p[i] - 1], p[i]);‍‌
	}‍‌
}‍‌
int main(‍‌)
{‍‌
	scanf("%s", s);‍‌
	int n = strlen(s);‍‌
	for(int i = 0;‍‌ i < n;‍‌ i ++) {‍‌
		t[i + 1 << 1] = s[i];‍‌
		t[i + 1 << 1 | 1] = '#';‍‌ 
	}‍‌
	t[1] = '#', t[0] = '?';‍‌
	int m = n << 1 | 1;‍‌
	Manacher(t, m);‍‌
	for(int i = 2;‍‌ i <= m;‍‌ i ++) l[i] = max(l[i], l[i - 1] - 1);‍‌
	for(int i = m - 1;‍‌ i;‍‌ i --) r[i] = max(r[i], r[i + 1] - 1);‍‌
	for(int i = 2;‍‌ i <= m;‍‌ i ++)
		if(!(i & 1))
			l[(i >> 1) - 1] = l[i], r[(i >> 1) - 1] = r[i];‍‌
	int res = max(l[0], r[n - 1]);‍‌
	for(int i = 0;‍‌ i < n;‍‌ i ++)
		if(s[i] != s[n - i - 1]) break;‍‌
		else {‍‌
            int t = 0;‍‌
            if(n - 2 - i >= 0) t = r[n - 2 - i];‍‌
            if(i + 1 < n) t = max(t, l[i + 1]);‍‌
            res = max(res, (i + 1 << 1) + t);‍‌
        }‍‌
	printf("%d\n", res);‍‌
	return 0;‍‌
}‍‌
```

---


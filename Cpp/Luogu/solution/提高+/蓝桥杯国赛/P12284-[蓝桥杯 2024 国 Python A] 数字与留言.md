# [蓝桥杯 2024 国 Python A] 数字与留言

## 题目描述

在一个阳光明媚的上午，小蓝走进了数学教室。他的目光很快被黑板上两个孤零零的数字 $x, y$ 吸引。数学老师总爱出些奇妙的谜题，今天显然也不例外。老师留言称，这两个数字暗含着一层不同寻常的心意，要想揭开这份心意的神秘面纱，就必须在 $1 \sim x$ 之间找到三个不同的正整数，使得这三个数的和除以 $2024$ 的余数值为 $y$，且这三个数的各个数位都不得包含数字 $2$ 和 $4$。

现在，请你帮助小蓝，求出有多少种不同的满足条件的三个数的组合。由于这个答案可能很大，你只需要输出答案对 $10^9 + 7$ 取余后的结果即可。

注意，如果通过改变三个正整数的顺序可以得到相同的组合，则这样的组合也被视为同一种。例如，对于 $x = 10, y = 9$，无论是 $1 + 3 + 5$ 还是 $5 + 3 + 1$，都只算作一种。

## 说明/提示

### 样例说明

满足条件的组合仅有一组：$(1, 3, 5)$。

### 评测用例规模与约定

- 对于 $10\%$ 的评测用例，$1 \leq x \leq 700$，$0 \leq y \leq 2023$。
- 对于 $30\%$ 的评测用例，$1 \leq x \leq 10^5$，$0 \leq y \leq 2023$。
- 对于所有评测用例，$1 \leq x \leq 10^{12}$，$0 \leq y \leq 2023$。

## 样例 #1

### 输入

```
10 9```

### 输出

```
1```

# 题解

## 作者：fush (赞：4)

除数不大，如果可以得到每个余数的数量，我们可以直接枚举两个余数，来统计最后的答案。

我们考虑 DP，$dp_{i,0/1,j}$ 表示考虑到第 $i$ 位，是否顶到 $x$，余数为 $j$ 的数量。

我们可以像数位 DP 一样，枚举每一位上的数字，以及上一位的余数就好了，记得去除 $0$。

最后统计答案的时候，三个数的余数是可以相同的，需要分类讨论。

```c++
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define FL(a,b,c) for(int a=(b),a##end=(c);a<=a##end;++a)
#define FR(a,b,c) for(int a=(b),a##end=(c);a>=a##end;--a)
#define lowbit(x) ((x)&-(x))
#define eb emplace_back
#define SZ(x) (int)((x).size())
#define int long long
#define vt vector
#define ar(x) array<int,x>
#define PII pair<int, int>
#define max(a, b)({auto f7r=(a);auto j3h=(b);f7r<j3h?j3h:f7r;})
#define cmax(a, b)({auto j3h=(b);(j3h>a)&&(a=j3h);})
#define min(a, b)({auto f7r=(a);auto j3h=(b);f7r>j3h?j3h:f7r;})
#define cmin(a, b)({auto j3h=(b);(j3h<a)&&(a=j3h);})
constexpr int N = 1e6 + 10, M = 2034, mod = 1e9 + 7;
int a[M], dp[20][2][M], lim[20], len;
int qpow(int a, int b = mod - 2, int ans = 1){
	for(;b;(a *= a) %= mod, b >>= 1)if(b & 1)(ans *= a) %= mod;
	return ans;
}
int32_t main(){
	cin.tie(0)->sync_with_stdio(0);
	int x, y, t, ans = 0, inv2 = qpow(2), inv6 = qpow(6);
	cin >> x >> y, t = x;
	while(t)lim[++len] = t % 10, t /= 10;

	dp[len + 1][1][0] = 1;
	FR(i, len, 1)  FL(j, 0, 2023)  FL(li, 0, 1)
		FL(k, 0, (t = (li ? lim[i] : 9)))  if(k != 2 && k != 4)
			(dp[i][li && (k == t)][(j * 10 + k) % 2024] += dp[i + 1][li][j]) %= mod;

	FL(i, 0, 2023)a[i] = dp[1][0][i] + dp[1][1][i];
	(a[0] += mod - 1) %= mod; //去除 0

#define C2(x) (x * (x - 1) % mod * inv2 % mod)
#define C3(x) (x * (x - 2) % mod * (x - 1) % mod * inv6 % mod)

	FL(i, 0, 2023)FL(j, i, 2023){
		int k = (y - (i + j) % 2024 + 2024) % 2024, z = ans;
		if(k < i || k < j)continue;
		if(i == j)
			if(j == k)ans += C3(a[i]);
			else ans += C2(a[i]) * a[k] % mod;
		else if(j == k)ans += C2(a[j]) * a[i] % mod;
		else if(i == k)ans += C2(a[i]) * a[j] % mod;
		else ans += a[i] * a[j] % mod * a[k] % mod;
		ans %= mod;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：LostKeyToReach (赞：2)

我们先做一下数位 dp，令 $f_{i, j, k}$ 表示前 $i$ 位构成的数字对 $2024$ 取模的结果为 $j$，是否贴紧数位限制的方案数，注意特判一下当前构造的数位数值是否不是 $2$ 和 $4$ 即可，最终对于每个模 $2024$ 余数为 $j$ 的数的方案为 $a_j = f_{l, j, 0} + f_{l, j, 1}$，$l$ 是数字长度。

接下来考虑如何统计答案。枚举前两个数模 $2024$ 的余数 $i, j$，直接计算出最后一个数模 $2024$ 的余数 $k$（注意，我们这里假定 $i \le j \le k$，这并不影响答案计数），然后乘法原理一下就行了。注意特判 $i = j = k, i = j, j = k$ 这三种情况。

时间复杂度 $O(V^2 + \log x\log V)$。

参考代码：

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <bits/stdc++.h>
#define int long long
using ll = long long;
using ull = unsigned long long;
using pii = std::pair<int, int>;
template<typename T> using vec = std::vector<T>;
using vi = vec<int>; using vvi = vec<vi>;
template<typename T> using min_heap = std::priority_queue<T, vec<T>, std::greater<T>>;
template<typename T> using max_heap = std::priority_queue<T>;
#define fr first
#define se second
#define all(x) (x).begin(),(x).end()
#define sz(x) ((int)(x).size())
#define For(i, a, b) for(int i = (a); i <= (b); ++i)
#define Rof(i, a, b) for(int i = (a); i >= (b); --i)
#define Loop(i, a, b, s) for(int i = (a); \
    ((s) > 0) ? (i <= (b)) : (i >= (b)); i += (s))
template<typename T> T chkmax(T& x, T y) { return (x < y) ? (x = y, y) : x; }
template<typename T> T chkmin(T& x, T y) { return (x > y) ? (x = y, y) : x; }
#if defined(ENABLE_FASTIO)
#else
struct FastIO {
    FastIO() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr), std::cout << std::fixed; }
} fio;
#endif
const int mod = 1e9 + 7;
inline void inc(int& x, int y) {
    if ((x += y) >= mod)
        x -= mod;
}
int32_t main() {
    int x, y;
    std::cin >> x >> y;
    int t = x;
    vi d;
    while (t > 0)
        d.emplace_back(t % 10),
        t /= 10;
    std::reverse(all(d));
    int l = sz(d);
    vec<vvi> dp(l + 1, vvi(2024, vi(2, 0)));
    dp[0][0][1] = 1;
    For(i, 0, l - 1) For(j, 0, 2023) For(t, 0, 1) {
        int lim = (t ? d[i] : 9);
        For(k, 0, lim) {
            if (k != 2 && k != 4) {
                inc(dp[i + 1][(j * 10 + k) % 2024][t && k == lim], dp[i][j][t]);
            }
        }
    }
#define f2(x) (x) * ((x) - 1) % mod * ((mod + 1) / 2) % mod 
#define f3(x) (x) * ((x) - 1) % mod * ((x) - 2) % mod * ((mod + 1) / 6) % mod
    For(i, 0, 2023) inc(dp[l][i][0], dp[l][i][1]);
    inc(dp[l][0][0], mod - 1);
    int ans = 0;
    For(i, 0, 2023) For(j, i, 2023) {
        int k = (y % 2024 - (i + j) % 2024 + 2024) % 2024;
        if (k < j) continue;
        if (i == j && j == k)
            inc(ans, f3(dp[l][i][0]));
        else if (i == j && j != k)
            inc(ans, f2(dp[l][i][0]) * dp[l][k][0] % mod);
        else if (i < j && j == k)
            inc(ans, f2(dp[l][j][0]) * dp[l][i][0] % mod);
        else if (i < j && j < k)
            inc(ans, dp[l][i][0] * dp[l][j][0] % mod * dp[l][k][0] % mod);
    }
    std::cout << ans << "\n";
    return 0;
}
```

---

## 作者：hxuwna (赞：1)

首先，$x \leq 10^{12}$，显然直接 $n^3$ 暴力会 T。注意到要求在 $1\sim x$ 之间找三个数，于是考虑数位 dp。

$dp_{i,j,k} $ 表示最高位第 $i$ 位为 $j$ 且余数为 $k$ 的数的数量。显然有以下转移式（暂时不考虑各数位不包含 2 和 4）。
$$
dp_{i,j,\left ((k+10^i \times j \right ) \bmod 2024 )}=\sum_{d=0}^{9} dp_{i-1,d,k}
$$
各数位不包含 2 和 4 只需要当 $j=2$ 或 $j=4$ 或 $d=2$ 或 $d=4$ 的时候 continue 就行了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
constexpr int mod=1e9+7;
int x,y,dp[15][12][2025],sum[2025],num[15],tot,f[15];
int ksm(int a,int b){
	int res=1;
	while(b){
		if(b&1) res=res*a%mod;
		a=a*a%mod,b>>=1;
	}
	return res;
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0);
	dp[0][0][0]=1;int inv2=ksm(2,mod-2),inv6=ksm(6,mod-2);
	for(int i=1,add=1;i<=13;i++,add=add*10%2024){
		f[i]=add;
		for(int j=0;j<=9;j++){
			if(j==2||j==4) continue;
			for(int k=0;k<=9;k++){
				if(k==2||k==4) continue;
				for(int d=0;d<=2023;d++){
					if(!dp[i-1][k][d]) continue;
					int ne=(d+j*add)%2024;
					dp[i][j][ne]=(dp[i][j][ne]+dp[i-1][k][d])%mod;
				}
			}
		}
	}
	cin>>x>>y;
	while(x){
		num[++tot]=x%10;
		x/=10;
	}
	int ssum=0;
	for(int i=tot;i>=1;i--){
		for(int k=0;k<=num[i];k++){
			if(i!=1&&k==num[i]) break;
			for(int j=0;j<=2023;j++) sum[(j+ssum)%2024]=(sum[(j+ssum)%2024]+dp[i][k][j])%mod;
		}
		ssum=(ssum+num[i]*f[i])%2024;
		if(num[i]==2||num[i]==4) break;
	}
	sum[0]--;
	int a,b,c,ans=0;
	for(int i=0;i<=2023;i++){
		a=sum[i];sum[i]--;
		for(int j=i;j<=2023;j++){
			b=sum[j];
			sum[j]--;
			int k=(y-i-j+4048)%2024;
			if(k>=j){
				c=sum[k];int la=ans;
				if(i==j&&j==k) ans=(ans+a*b%mod*c%mod*inv6%mod)%mod;
				else if(i==j) ans=(ans+a*b%mod*inv2%mod*c)%mod;
				else if(i==k) ans=(ans+a*c%mod*inv2%mod*b)%mod;
				else if(j==k) ans=(ans+b*c%mod*inv2%mod*a)%mod;
				else ans=(ans+a*b%mod*c)%mod;
			}
			sum[j]++;
		}
		sum[i]++;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：chatoudp (赞：0)

先数位 DP，求出从 $1$ 到 $x$ 中不含 $2,4$ 数位的数中对 $2024$ 取模的结果为 $k$ 的数有多少个，然后再枚举 $3$ 个数中其中 $2$ 个的取余结果，计算出第 $3$ 个，再计算 $ans$ 即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long x,y,ans,c[15][2025],a[15],tot;
long long mod=1e9+7;
long long Pow(long long x,long long y){
    long long rt=1;
    while(y){
        if(y&1) rt=rt*x%2024;
        x=x*x%2024;
        y/=2;
    }
    return rt;
}
long long DP(long long M,bool f,int T,bool f2){
    if(!T){c[0][M]=1; return 1;}
    if(c[T][M]!=-1&&!f&&!f2) return c[T][M];
    long long rt=0;
    int g=(f?a[T]:9);
    for(int i=0;i<=g;i++) if(i!=2&&i!=4&&(T!=1||i==M&&(i||!f2)))
        rt+=DP((M-(long long)i*Pow(10,T-1)%2024+2024)%2024,f&(i==g),T-1,f2&!i),c[T][M]%=mod;
    if(!f&&!f2||T==tot) c[T][M]=rt;
    return rt;
}
long long ksm(long long x,long long y){
    long long rt=1;
    while(y){
        if(y&1) rt=rt*x%mod;
        x=x*x%mod;
        y/=2;
    }
    return rt;
}
int main(){
    scanf("%lld%lld",&x,&y);
    long long p=x;
    while(p){
        a[++tot]=p%10;
        p/=10;
    }
    for(int i=0;i<=tot;i++) for(int j=0;j<2024;j++) c[i][j]=-1;
    for(int i=0;i<2024;i++) DP(i,1,tot,1);
    for(long long i=0;i<2024;i++)
        for(long long j=0;j<2024;j++){
            long long k=(y-i-j+4048)%2024;
            if(i==j&&j==k) ans=(ans+c[tot][i]*(c[tot][i]-1)%mod*(c[tot][i]-2)%mod)%mod;
            else if(i==j) ans=(ans+c[tot][i]*(c[tot][i]-1)%mod*c[tot][k]%mod)%mod;
            else if(i==k) ans=(ans+c[tot][i]*(c[tot][i]-1)%mod*c[tot][j]%mod)%mod;
            else if(j==k) ans=(ans+c[tot][j]*(c[tot][j]-1)%mod*c[tot][i]%mod)%mod;
            else ans=(ans+c[tot][i]*c[tot][j]%mod*c[tot][k]%mod)%mod;
        }
    printf("%lld",ans*ksm(6,mod-2)%mod);
    return 0;
}

```

---


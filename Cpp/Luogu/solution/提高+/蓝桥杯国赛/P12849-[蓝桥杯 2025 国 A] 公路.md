# [蓝桥杯 2025 国 A] 公路

## 题目描述

小蓝居住的国家有 $n$ 座城市，城市与城市之间由 $n-1$ 条公路连接，而且任意两个城市都可以通过公路互相到达。

这个国家的公路由几个公司共同修建，如果小蓝希望通过某条公路，就必须持有修建这条公路的公司的通行证，但只要申请一次通行证，就可以在每一条这个公司修建的公路上通行。

小蓝经常要在不同城市之间旅行，每次他要从一个城市到另一个不同的城市，都需要根据需要通过的公路申请相应的通行证。具体来说，如果小蓝的路线经过了一条或者更多条 A 公司修建的公路，小蓝就需要申请一次 A 公司的通行证。

现在小蓝希望知道，对于这 $n \times (n-1)$ 种不同的情况，他需要申请通行证的次数总共是多少。

## 说明/提示

**【样例说明】**

下表给出了每种情况需要申请的通行证数量，总和为 16。

|  | 1 | 2 | 3 | 4 |
| --- | --- | --- | --- | --- |
| 1 | / | 1 | 1 | 1 |
| 2 | 1 | / | 1 | 2 |
| 3 | 1 | 1 | / | 2 |
| 4 | 1 | 2 | 2 | / |

**【评测用例规模与约定】**

对于 30% 的评测用例，$1 \leq n \leq 300$；

对于另外 20% 的评测用例，$u_i = i$，$v_i = i + 1$；

对于另外 20% 的评测用例，$u_i = 1$，$v_i = i + 1$；

对于 80% 的评测用例，$1 \leq n \leq 50000$；

对于所有评测用例，$1 \leq w_i, u_i, v_i \leq n \leq 500000$。

## 样例 #1

### 输入

```
4
1 2 1
1 3 1
1 4 2```

### 输出

```
16```

# 题解

## 作者：naroanah (赞：6)

每种通行证视为一种颜色，所求的答案就是树上所有路径的颜色数之和。

对每一种颜色分开考虑，发现断掉某种颜色的边会使树分为若干个连通块，直接正面计算答案是不容易的，可以反过来考虑。对于当前的颜色，总路径数就是 $n\times (n-1)$，不经过当前颜色的路径数是 $\sum_i \limits (siz_i \times (siz_i - 1))$，其中 $siz_i$ 为连通块大小。减去这部分，得到的就是当前颜色对答案的贡献。

考虑在 dfs 过程中动态维护每种颜色的连通块大小。

具体而言，访问到某种颜色的边时，先临时存储当前的连通块大小，然后将连通块大小更新为该子树大小，递归下去处理。

回溯时，将子树中连通块的贡献计入答案，并将子树大小更新为最初临时存储的连通块大小减去子树大小。

```cpp
#include<bits/stdc++.h>
#define rep(i, l, r) for(int i = (l); i <= (r); i++)
#define req(i, r, l) for(int i = (r); i >= (l); i--)
#define testcase int T; cin >> T; while(T--) solve();
#define ll long long
#define ull unsigned long long
#define pii pair<int, int>
#define vi vector<int>
#define vii vector<pii>
#define fi first
#define se second
#define all(x) begin(x), end(x)
using namespace std;
constexpr int N = 5e5 + 10, inf = 0x3f3f3f3f, INF = 0x7f7f7f7f, mod = 998244353;
constexpr double eps = 1e-9;
template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}
int n, siz[N], block[N], cnt;
ll ans;
struct edge {int ed, v;};
vector<edge> e[N];
void dfs1(int x, int fa) {
    siz[x] = 1;
    for(auto [ed, v] : e[x]) if(ed != fa) dfs1(ed, x), siz[x] += siz[ed];
}
void dfs2(int x, int fa) {
    for(auto [ed, v] : e[x]) {
        if(ed == fa) continue;
        int now = block[v];
        block[v] = siz[ed];
        dfs2(ed, x);
        ans += (ll)block[v] * (block[v] - 1);
        block[v] = now - siz[ed];
    }
}
signed main() {
    ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    cin >> n;
    rep(i, 2, n) {
        int u, v, w; cin >> u >> v >> w;
        e[u].push_back({v, w});
        e[v].push_back({u, w});
        if(!block[w]) block[w] = n, cnt++;
    }
    dfs1(1, 0); dfs2(1, 0);
    rep(i, 1, n) if(block[i]) ans += (ll)block[i] * (block[i] - 1);
    cerr << ans << "\n";
    cout << (ll)cnt * n * (n - 1) - ans << "\n";
    return 0;
}
```

---

## 作者：WorldMachine (赞：2)

抽象扭曲魔怔做法。

对每种颜色分别计算答案，考虑断开所有该种颜色的边，那么共有 $n(n-1)-\sum\limits_{S}|S|(|S|-1)$ 条路径上有该颜色，其中 $S$ 为剩下的每个连通块。

于是现在问题变成了颜色 $i$ 有生效区间 $[1,i-1]\cup[i+1,n]$，维护每个连通块的 $|S|(|S|-1)$ 之和，使用线段树分治+并查集即可，复杂度为 $\mathcal O(n\log^2 n)$。

擦着过的。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
#define IOSIZE (1 << 20)
char buf[IOSIZE], *p1 = buf, *p2 = buf;
#define gc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, IOSIZE, stdin), p1 == p2) ? EOF : *p1++)
il int read() { int x = 0; char c = 0; while (c < '0' || c > '9') c = gc(); while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = gc(); return x; }
typedef long long ll;
const int N = 5e5 + 5;
int n, u[N], v[N], fa[N], siz[N], top, stk[N]; ll C[N], ans, cur;
basic_string<int> t[N << 2];
il int get(int x) { return x == fa[x] ? x : get(fa[x]); }
il void merge(int x, int y) {
	if ((x = get(x)) == (y = get(y))) return;
	if (siz[x] > siz[y]) swap(x, y);
	cur -= C[siz[x]], cur -= C[siz[y]];
	fa[x] = y, siz[y] += siz[x], cur += C[siz[y]];
	stk[++top] = x;
}
il void upd(int p, int l, int r, int L, int R, int x) {
	if (L <= l && r <= R) return t[p] += x, void();
	int mid = l + r >> 1;
	if (L <= mid) upd(p << 1, l, mid, L, R, x);
	if (R > mid) upd(p << 1 | 1, mid + 1, r, L, R, x);
}
il void roll(int t) {
	while (top > t) {
		int x = stk[top--], y = fa[x];
		cur -= C[siz[y]], fa[x] = x, siz[y] -= siz[x];
		cur += C[siz[x]], cur += C[siz[y]];
	}
}
il void solve(int p, int l, int r) {
	int tot = top;
	for (int i = 0, s = t[p].size(); i < s; i++) merge(u[t[p][i]], v[t[p][i]]);
	if (l == r) ans -= cur;
	else {
		int mid = l + r >> 1;
		solve(p << 1, l, mid), solve(p << 1 | 1, mid + 1, r);
	}
	roll(tot);
}
int main() {
	n = read();
	for (int i = 1, w; i < n; i++) {
		u[i] = read(), v[i] = read(), w = read();
		if (w > 1) upd(1, 1, n, 1, w - 1, i);
		if (w < n) upd(1, 1, n, w + 1, n, i);
	}
	for (int i = 1; i <= n; i++) fa[i] = i, siz[i] = 1, C[i] = (ll)i * (i - 1);
	ans = C[n] * n, solve(1, 1, n), cout << ans;
}
```

---

## 作者：hater (赞：1)

直接正面计算答案。

对于每一个点，考虑到 dfn 序比它小（也就是之前 dfs 到的点）所有路径的答案，很显然把每个颜色拆出来做会更简单。

对于每一种颜色，动态维护 cnt 数组。

当 dfs 进入一个子树时，那么从这个子树出来的路径，必然会经过当前边，那么对于这个颜色而言，它的 cnt 就是之前遍历过点的个数。

当 dfs 从一个子树出来时，那么从后面的点进入这个子树必然会经过当前边，再加上之前刚进入这个子树时的 cnt（两者无影响不重叠），简单加法即可。

每次只是动态修改数组的一个位置的值，那么用一个 sum 统计 cnt 数组的和即可。


```cpp
#include <bits/stdc++.h> 
#define fp( i , x , y ) for( int i=(x); i<=(y); ++i ) 
#define fq( i , x , y ) for( int i=(y); i>=(x); --i ) 
#define ll long long 
using namespace std ; 
const int N = 5e5+10 ; 
int cnt[N] , n , tot , sz[N] ;
ll ans , sum ; 
vector <int> v[N] , e[N] ; 
void add( int x , int y , int z ) { 
  v[x].push_back(y) ; e[x].push_back(z) ; 
} 
void dfs( int x , int fa ) { 
  int y , z ; 
  sz[x] = 1 ; tot ++ ; 
  ans += sum ; 
  fp( i , 1 , v[x].size() ) { 
    y = v[x][i-1] ; z = e[x][i-1] ; 
    if( y == fa ) continue ; 
    int tp = cnt[z] ; 
    sum -= cnt[z] ; cnt[z] = tot ; sum += cnt[z] ; 
    dfs( y , x ) ; 
    sz[x] += sz[y] ; 
    sum -= cnt[z] ; cnt[z] = tp + sz[y] ; sum += cnt[z] ; 
  } 
}  
signed main() { 
  ios::sync_with_stdio(false) ; 
  cin.tie(0) ; 
  cin >> n ; 
  int x , y , z ; 
  fp( i , 1 , n-1 ) { 
    cin >> x >> y >> z ; 
    add( x , y , z ) ; 
    add( y , x , z ) ; 
  } 
  dfs( 1 , 0 ) ; 
  cout << 2 * ans << '\n' ; 
} 
```
虽然是蓝题，但是 cf 上就 2000 分，一个 dfs 就做完了，神奇吧。

---

## 作者：LargeRice16pro (赞：1)

做法百花齐放的题目。

本题最简单的做法应该是 $O(n)$ 的断边容斥算贡献。

下面介绍一下无脑力大砖飞做法（并适当拓展到原题 [P2664 树上游戏](https://www.luogu.com.cn/problem/P2664) 做法）：

### 做法一：dsu on tree

我们知道，dsu on tree 解决树上路径问题时，是将树上每一条路径在 LCA 处合并。

我们还知道，区间数颜色问题不容易被直接解决（[P1972 HH的项链](https://www.luogu.com.cn/problem/P1972)），所以和“HH的项链”类似地，路径上的每一种颜色，我们只考虑最靠右出现的那一次。

#### 贡献 1.

具体而言，dsu on tree 暴力遍历轻子树时，我们将遍历的过程视作从左向右的过程，那么对于当前遍历到的节点 $x$，其向父节点的边权 $col_x$，我们就在此时统计其贡献。

同时，遍历到 $x$ 子树时，$col_x$ 这条边仍会被统计，所以这里 $col_x$ 的贡献实际上是 $sum\times sz_x$（$sz_x$ 表示 $x$ 的子树大小，$sum$ 表示遍历过的节点数量）。

那么理所当然地，当在 $x$ 子树中再次遍历到和 $col_x$ 相同的边权时，就不需要考虑它的贡献了（包括后续的贡献 2. 和贡献 3.）。

#### 贡献 2.

因为 dsu on tree 的路径合并实际上是有方向的，向左合并，所以贡献 1. 只是向左的贡献。我们还需要考虑向右的贡献。

![](https://cdn.luogu.com.cn/upload/image_hosting/megzk8wh.png)

如上图，遍历轻子树到 $3$ 这个点时，合并路径 $2-1-3$，贡献 1. 只考虑了 $col_3$，没有考虑 $col_2$。

所以贡献 2. 就是左边向右的贡献。

这部分和贡献 1. 类似，在左边遍历过的子树中，我们只记录自 LCA 向下边权第一次出现的位置，其贡献是 $sz_{x'}$，再减去 $col_x$ 这条边的重复部分，所以贡献 2. 就是 $(\sum sz_{x'}-\sum sz_{x'}[col_{x'}=col_x])\times sz_x$。

还要再注意一点：遍历轻子树的根（轻儿子）时，左侧的 $col_{x'}$ 就被算过了，所以后续考虑轻子树中的其它点 $col_x$ 的贡献 1. 时，实际还要再减去 $\sum sz_{x'}[col_{x'}=col_x]$ 的重复部分，也就是 $(sum-sz_{x'}[col_{x'}=col_x])\times sz_x$。

#### 贡献 3.

这部分是 LCA 到 $x$，不被合并的路径的贡献。

对于重子树，是 LCA 向后代的贡献，对于轻子树，是后代向 LCA 的贡献。

轻子树是容易的，贡献是：$sz_x$。

重子树相对复杂一点，需要在回溯时，重置 $col_x$ 的贡献。

例如：

![](https://cdn.luogu.com.cn/upload/image_hosting/iptxcdja.png)

回溯 $col_2$ 时，LCA 向重子树的边权 $1$ 第一次出现的位置不再是 $col_3$ 和 $col_4$，而是 $col_2$，那么要减去 $sz_3$ 和 $sz_4$，再加上 $sz_2$。

那么 LCA 向重子树的贡献就是累计是 $\sum sz_{x'}$。

最后因为题目同一条路径还要算两次，所以总答案再乘 $2$。

时间复杂度：$O(n\log n)$。

code:
```
const int N = 5e5 + 10;
struct node {
    int v, w;
};
vector<node> p[N];
void add(int u, int v, int w) { p[u].push_back({v, w}); }
int fa[N], sz[N], son[N], up[N];
void dfs(int x, int y, int z) {
    fa[x] = y;
    up[x] = z;
    sz[x] = 1;
    for (auto u : p[x]) {
        if (u.v == y)
            continue;
        dfs(u.v, x, u.w);
        sz[x] += sz[u.v];
        if (sz[son[x]] < sz[u.v])
            son[x] = u.v;
    }
}
ll ans, tag, num[N];
stack<int> q;
bool vis[N], st[N];
void dfs1(int x, ll sum, bool y) {
    if (!st[up[x]]) {
        st[up[x]] = 1;
        ans += (sum - y * num[up[x]]) * sz[x];    // 自己的贡献
        ans += (tag - num[up[x]]) * sz[x] * (!y); // 左边的贡献
        ans += sz[x];                             // 轻子树到 LCA 的贡献
        for (auto u : p[x]) {
            if (u.v == fa[x])
                continue;
            dfs1(u.v, sum, 1);
        }
        st[up[x]] = 0;
    } else {
        for (auto u : p[x]) {
            if (u.v == fa[x])
                continue;
            dfs1(u.v, sum, 1);
        }
    }
}
void dfs2(int x) {
    if (!st[up[x]]) {
        st[up[x]] = 1;
        tag += sz[x];
        num[up[x]] += sz[x];
        q.push(x);
        for (auto u : p[x]) {
            if (u.v == fa[x])
                continue;
            dfs2(u.v);
        }
        st[up[x]] = 0;
    } else {
        for (auto u : p[x]) {
            if (u.v == fa[x])
                continue;
            dfs2(u.v);
        }
    }
}
void dfs(int x, bool y) {
    for (auto u : p[x]) {
        if (u.v == fa[x] || u.v == son[x])
            continue;
        dfs(u.v, 0);
    }
    if (son[x]) {
        dfs(son[x], 1);
    }
    ll sum = sz[son[x]];
    ans += tag; // LCA 到重子树的贡献
    for (auto u : p[x]) {
        if (u.v == fa[x] || u.v == son[x])
            continue;
        dfs1(u.v, sum, 0);
        dfs2(u.v);
        sum += sz[u.v];
    }
    if (y) {
        tag = tag - num[up[x]] + sz[x];
        num[up[x]] = sz[x];
        q.push(x);
    }
    if (!y) {
        while (q.size()) {
            auto now = q.top();
            q.pop();
            tag = num[up[now]] = 0;
        }
    }
}
dfs(1, 0, 0);
dfs(1, 1);
```

### 做法二：点分治

感谢这题让我领悟到了点分治相对 dsu on tree 的唯二优势。

点分治和 dsu on tree 在统计答案上的区别是点分治将答案在重心处合并，而 dsu on tree 在 LCA 处合并，所以使用点分治解决该题，使用和 dsu on tree 完全相同的贡献维护方式即可，仅仅只是改变遍历方式而已。

原题“树上游戏”和这题的核心区别是“树上游戏”要求以每一个点为端点的答案，而本题只要求总答案。（对于点权和边权的区别在这里不是重点，仅是处理的对象不同）

容易发现本题是“树上游戏”的严格弱化版，本题最容易的断边容斥贡献做法无法解决“树上游戏”。

而且可以发现 dsu on tree 也无法解决“树上游戏”。

事实上 dsu on tree 不能解决“树上游戏”的原因在前文已经被提到：dsu on tree 的路径合并是有方向的，只能从右向左合并。

那么就无法对于每个点计算其所有路径（也就是只能保证所有路径被其中一个端点考虑）。

尽管可以先遍历完所有轻子树，然后对于每一棵轻子树，先减去它自己的贡献，再遍历，这样就可以计算每个轻子树节点为端点的所有路径答案。

但是 dsu on tree 的时间复杂度保证基于保留重子树，限制了重子树的节点不能通过上述方式得到答案。

而点分治不同，点分治基于重心分治结构，天然保证了每个节点可以考虑其为端点的所有路径。

每一次重心分治结构贡献独立计算，令 $ctr_x$ 表示 $x$ 的贡献。

遍历子树维护信息和上文中 dsu on tree 相同，计算答案时：
- $ctr_x=ctr_{fa}$，$col_x$ 不是重心向下第一次出现。
- $ctr_x=ctr_{fa}+sum'-\sum sz_{x'}[col_{x'}=col_x]$，其中 $sum'$ 表示其它子树大小之和，$col_x$ 是重心向下第一次出现。

可解决“树上游戏”，将点权逻辑修改成边权后可解决本题。

时间复杂度：$O(n\log n)$。

code:

```
// 点分治板子
int get_size(int x, int fa) {
    if (vis[x])
        return 0;
    int res = 1;
    for (auto u : p[x]) {
        if (u == fa)
            continue;
        res += get_size(u, x);
    }
    return res;
}
int get_wc(int x, int fa, int tot, int &wc) {
    if (vis[x])
        return 0;
    int sum = 1, maxs = 0, t;
    for (auto u : p[x]) {
        if (u == fa)
            continue;
        t = get_wc(u, x, tot, wc);
        maxs = max(maxs, t);
        sum += t;
    }
    maxs = max(maxs, tot - sum);
    if (maxs <= tot / 2)
        wc = x;
    return sum;
}
void dfs0(int x, int fa) {
    if (vis[x]) {
        sz[x] = 0;
        return;
    }
    sz[x] = 1;
    for (auto u : p[x]) {
        if (u == fa)
            continue;
        dfs0(u, x);
        sz[x] += sz[u];
    }
}
bool st[N];
stack<int> q, Q;
// 加上 x 子树的信息
void dfs1(int x, int fa, int &sum) {
    if (vis[x])
        return;
    if (!st[col[x]]) {
        st[col[x]] = 1;
        sum += sz[x];
        num[col[x]] += sz[x];
        q.push(x);
        for (auto u : p[x]) {
            if (u == fa)
                continue;
            dfs1(u, x, sum);
        }
        st[col[x]] = 0;
    } else {
        for (auto u : p[x]) {
            if (u == fa)
                continue;
            dfs1(u, x, sum);
        }
    }
}
// 减去 x 子树的信息
void dfs2(int x, int fa, int &res) {
    if (vis[x])
        return;
    if (!st[col[x]]) {
        st[col[x]] = 1;
        res += sz[x];
        num[col[x]] -= sz[x];
        Q.push(x);
        for (auto u : p[x]) {
            if (u == fa)
                continue;
            dfs2(u, x, res);
        }
        st[col[x]] = 0;
    } else {
        for (auto u : p[x]) {
            if (u == fa)
                continue;
            dfs2(u, x, res);
        }
    }
}
// 维护贡献
void dfs3(int x, int fa, int y) {
    if (vis[x])
        return;
    if (!st[col[x]]) {
        st[col[x]] = 1;
        ctr[x] = ctr[fa] + y - num[col[x]];
        for (auto u : p[x]) {
            if (u == fa)
                continue;
            dfs3(u, x, y);
        }
        st[col[x]] = 0;
    } else {
        ctr[x] = ctr[fa];
        for (auto u : p[x]) {
            if (u == fa)
                continue;
            dfs3(u, x, y);
        }
    }
    ans[x] += ctr[x];
    ctr[x] = 0;
}
int n;
void calc(int x) {
    if (vis[x])
        return;
    get_wc(x, 0, get_size(x, 0), x);
    dfs0(x, 0);
    vis[x] = 1;
    int sum = sz[x];
    st[col[x]] = 1;

    int tot = 1;
    for (auto u : p[x]) {
        if (!vis[u]) {
            tot += sz[u];
            dfs1(u, x, sum);
        }
    }
    ans[x] += sum;
    for (auto u : p[x]) {
        if (!vis[u]) {
            int res = sz[u];
            dfs2(u, x, res);
            ctr[x] = sum - res;
            dfs3(u, x, tot - sz[u]);
            while (Q.size()) {
                auto now = Q.top();
                Q.pop();
                num[col[now]] += sz[now];
            }
        }
    }
    st[col[x]] = 0;
    while (q.size()) {
        auto now = q.top();
        q.pop();
        num[col[now]] = 0;
    }
    for (auto u : p[x])
        calc(u);
}
```

---


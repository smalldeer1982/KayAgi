# [蓝桥杯 2016 国 AC] 碱基

## 题目描述

生物学家正在对 $n$ 个物种进行研究。

其中第 $i$ 个物种的 DNA 序列为 $s[i]$，其中的第 $j$ 个碱基为 $s[i][j],$ 碱基一定是 `A`,`G`,`C`,`T` 之一。

生物学家想找到这些生物中一部分生物的一些共性，他们现在关注那些至少在 $m$ 个生物中出现的长度为 $k$ 的连续碱基序列。准确的说，科学家关心的序列用 $2m$ 元组 $(i_1,p_1,i_2,p_2 \cdots ,i_m,p_m)$ 表示，

满足：

$$1 \le i_1<i_2< \cdots <i_m \le n$$

且对于所有 $q(0 \le q<k)$，

$$s[i_1][p_1+q]=s[i_2][p_2+q]= \cdots =s[i_m][p_m+q]$$

现在给定所有生物的 DNA 序列，请告诉科学家有多少的 $2m$ 元组是需要关注的。如果两个 $2m$ 元组有任何一个位置不同，则认为是不同的元组。

## 说明/提示

### 数据规模与约定

对于 $20\%$ 的数据，$k \le 5,$ 所有字符串总长 $L$ 满足 $L \le 100$。

对于 $30\%$ 的数据，$L \le 10000$。

对于 $60\%$ 的数据，$L \le 30000$。

对于 $100\%$ 的数据，$n \le 5,m \le 5,1 \le k \le L \le 10^5$。

保证所有 DNA 序列不为空且只会包含`A`,`G`,`C`,`T` 四种字母。

时限 1 秒, 256M。蓝桥杯 2016 年第七届国赛

## 样例 #1

### 输入

```
3 2 2
ATC
TCG
ACG```

### 输出

```
2```

## 样例 #2

### 输入

```
4 3 3
AAA
AAAA
AAA
AAA```

### 输出

```
7```

# 题解

## 作者：wangkelin123 (赞：9)

看到题解里有很多都是爆搜的，但是这并没有什么技术含量。这里我发一个 DP 题解。
## 题目
这个题面写的很绕，但其实就想表达：有多少个连续子串满足长度为 $k$，并且有 $m$ 个字符串都包括此子串。
## 解法
哈希必不可少，运用前缀和的方法（可参照[这题](https://www.luogu.com.cn/problem/P6739)）算出每个字符串中长度为 $k$ 的不同连续子串的数量 $p_{i,tot_i}$，以及每种连续字串的个数 $cnt_{i,H}$。

接下来便是 DP 环节。$f_{i,j,H}$ 表示以 $i$ 为结尾（必选 $i$），选了 $j$ 个，哈希值为 $H$ 的子串的选择方案有多少种。

第一重循环当然是遍历字符串，下一重就是遍历此字符串中长度为 $k$ 的子串的哈希值 $H$（前面处理过），初始值 $f_{i,1,H}\gets cnt_{i,H}$。接着遍历选的个数（最大值为 $m$），最后一重循环遍历 $lst$，范围为 $1\le lst<i$。

DP 的方法即为把所有的 $lst$ 的方案数乘 $cnt_{i,H}$ 后加起来，也就是：
$$ f_{i,j,H}=\sum _ {lst = 1} ^ {i-1} f_{lst,j-1,H}\times cnt_{i,H}$$
最后把所有的 $f_{i,m,H}$ 加起来（可以在 DP 中 $j$ 的循环内操作）即为答案。

设所有长度为 $k$ 的哈希最大值（自然溢出后）为 $H$，
则时间复杂度为 $O(n^2m\log H)$。

注意**取模**！
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const ll N=1e5+5,base=131,mod=1e9+7;
int n,m,k;
ll ans;
ull pre[N],h[10][N],p[10][N],tot[10];
string s;
map<ull,ll>cnt[10],f[10][10];//f[i][j][H]表示前i个串（以i为结尾），选了j个，哈希值为H的数量 
map<ull,bool>vis;
ull Hash(int l,int r,int i){
	return h[i][r]-h[i][l-1]*pre[r-l+1];
	//123456789 4567->1234567-123*10^4
}
int main(){
	cin>>n>>m>>k; 
	pre[0]=1;
	for(int i=1;i<=1e5;i++) pre[i]=pre[i-1]*base;
	for(int i=1;i<=n;i++){
		cin>>s;
		for(int j=1;j<=s.size();j++) h[i][j]=h[i][j-1]*base+(s[j-1]-'A'+1);
		vis.clear();
		for(int j=1;j+k-1<=s.size();j++){
			ull H=Hash(j,j+k-1,i);
			cnt[i][H]++;
			if(!vis[H]){
				p[i][++tot[i]]=H;
				vis[H]=true;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int q=1;q<=tot[i];q++){
			ull H=p[i][q];
			f[i][1][H]=cnt[i][H];
			for(int j=1;j<=m;j++){
				for(int lst=1;lst<i;lst++){
					f[i][j][H]=(f[i][j][H]+f[lst][j-1][H]*cnt[i][H]%mod)%mod;
				}
				if(j==m) ans=(ans+f[i][j][H])%mod;
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：251Sec (赞：4)

这题为啥是蓝题啊，感觉只有黄。

$n \le 5$，我们直接爆搜选哪 $m$ 个生物。然后对于这些生物我们哈希所有长度为 $k$ 的子串，存入哈希表。这样对于每一个哈希值可以求出它在这些生物中各出现了多少次，乘起来即可。

我实现写的比较垃圾，复杂度 $O(n2^nL)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int bas = 256, mod1 = 1e9 + 7, mod2 = 1e9 + 9;
int n, m, k;
int l[6];
string s[6];
int has1[6][100005], pw1[100005], has2[6][100005], pw2[100005];
int GetHas1(int i, int l, int r) {
    return ((has1[i][r] - 1ll * has1[i][l - 1] * pw1[r - l + 1] % mod1) + mod1) % mod1;
}
int GetHas2(int i, int l, int r) {
    return ((has2[i][r] - 1ll * has2[i][l - 1] * pw2[r - l + 1] % mod2) + mod2) % mod2;
}
int Val(char c) {
    if (c == 'A') return 1;
    if (c == 'T') return 2;
    if (c == 'G') return 3;
    return 4;
}
int PopCnt(int x) {
    int res = 0;
    for (; x; x &= x - 1) res++;
    return res;
}
ll ans;
unordered_map<ll, array<int, 5>> f;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i++) cin >> s[i], l[i] = s[i].length(), s[i] = '$' + s[i];
    pw1[0] = pw2[0] = 1;
    for (int i = 1; i <= 100000; i++) {
        pw1[i] = 1ll * pw1[i - 1] * bas % mod1;
        pw2[i] = 1ll * pw2[i - 1] * bas % mod2;
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= l[i]; j++) {
            has1[i][j] = (1ll * has1[i][j - 1] * bas % mod1 + Val(s[i][j])) % mod1;
            has2[i][j] = (1ll * has2[i][j - 1] * bas % mod2 + Val(s[i][j])) % mod2;
        }
        for (int j = 1; j <= l[i] - k + 1; j++) {
            f[1ll * GetHas1(i, j, j + k - 1) * mod2 + GetHas2(i, j, j + k - 1)][i - 1]++;
        }
    }
    for (auto i : f) {
        auto w = i.second;
        for (int j = 0; j < 32; j++) {
            if (PopCnt(j) != m) continue;
            int cnt = 1;
            for (int k = 0; k < 5; k++) {
                if (j >> k & 1) cnt = 1ll * cnt * w[k] % mod1;
            }
            ans = (ans + cnt) % mod1;
        }
    }
    cout << ans << '\n';
    return 0;
}
```

---

## 作者：5k_sync_closer (赞：4)

题解一血 & 最优解。

枚举相同子串的内容 $i$，设 $f_o$ 表示从 $o$ 个串中各选一个 $i$ 的方案数，

则对 $j\in[1,n]$，有转移 $f_o\gets f_o+f_{o-1}\times c_{j,i}$，其中 $c_{j,i}$ 表示 $j$ 串中 $i$ 的出现次数。

容易发现答案为 $\sum\limits_i f_m$，即每个 $i$ 对应的 $f_m$ 之和。

哈希处理 $c_{j,i}$ 和 $i$ 的取值范围，$i$ 只能取 $n$ 个串的所有长度为 $k$ 的子串。

时间复杂度 $O(nmL)$。

```cpp
#include <cstdio>
#include <cstring>
#include <ext/pb_ds/hash_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#define M 1000000007
int n, m, k, l;
char s[100050];
unsigned long long z, q, f[6], p[100050], h[100050];
__gnu_pbds::gp_hash_table<unsigned long long, int> r, c[5];
int main()
{
    for (int i = p[0] = f[0] = 1; i <= 1e5; ++i)
        p[i] = p[i - 1] * 233;
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 0; i < n; ++i)
    {
        scanf("%s", s + 1);
        l = strlen(s + 1);
        for (int j = 1; j <= l; ++j)
            h[j] = h[j - 1] * 233 + s[j];
        for (int j = k; j <= l; ++j)
            ++r[z = h[j] - h[j - k] * p[k]], ++c[i][z];
    }
    for (auto [i, _] : r)
    {
        for (int j = 1; j <= m; ++j)
            f[j] = 0;
        for (int j = 0; j < n; ++j)
            for (int o = m; o; --o)
                f[o] = (f[o] + f[o - 1] * c[j][i]) % M;
        q = (q + f[m]) % M;
    }
    printf("%llu", q);
    return 0;
}
```


---

## 作者：zhaocs123456 (赞：1)

## 思路
易知当 $n<m$ 时，一定无解，特判过掉。  
先暴力枚举每个长度为 $m$ 的子串，记录有多少个 DNA 序列中含有这个子串，每个 DNA 序列中含有多少个这个子串，用 set 去重，unordered_map 记录。  
再枚举每个去重后的子串，若含有这个子串的 DNA 序列个数 $ < m$，跳过，否则利用乘法原理计算二元组个数，用 $ans$ 求和，在每次求和后取模。  
~~我太蒟了，乘法原理打的多重循环。~~
## 代码

```cpp
#include<bits/stdc++.h>
#define inf 0x7fffffff
#define mod 1000000007
#define ll long long
#define M 500010
#define N 100010
#define quickly ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)
using namespace std;;
ll ans,n,m,s;
string ss[7],s1;
ll si;
unordered_map<string,ll> sl,sp[7];
set<string> sset;
int main(){
	quickly;
	cin >>n>>m>>s;
	if(n<m) {
		cout<<0<<endl;
		return 0;
	}
	for(int i=1;i<=n;i++){
		cin >>ss[i];
		si=ss[i].size();
		for(int j=0;j<=si-s;j++){
			s1=ss[i].substr(j,s);
			sset.insert(s1);
			if(!sp[i][s1]) sl[s1]++;
			sp[i][s1]++;
		}
	}
	while(!sset.empty()){
		s1=*sset.begin();
		sset.erase(s1);
		if(sl[s1]<m) continue;
		if(m==1){
			for(int i=1;i<=n;i++)
				ans+=sp[i][s1],ans=ans%mod;;
		}else if(m==2){
			for(int i1=1;i1<=n;i1++){
				if(!sp[i1][s1]) continue;
				for(int i2=i1+1;i2<=n;i2++){
					ans+=sp[i1][s1]*sp[i2][s1],ans=ans%mod;;
				}
			}
		}else if(m==3){
			for(int i1=1;i1<=n;i1++){
				if(!sp[i1][s1]) continue;
				for(int i2=i1+1;i2<=n;i2++){
					if(!sp[i2][s1]) continue;
					for(int i3=i2+1;i3<=n;i3++){
						ans+=sp[i1][s1]*sp[i2][s1]*sp[i3][s1];
						ans=ans%mod;
					}
				}
			}
		}else if(m==4){
			for(int i1=1;i1<=n;i1++){
				if(!sp[i1][s1]) continue;
				for(int i2=i1+1;i2<=n;i2++){
					if(!sp[i2][s1]) continue;
					for(int i3=i2+1;i3<=n;i3++){
						if(!sp[i3][s1]) continue;
						for(int i4=i3+1;i4<=n;i4++){
							ans+=sp[i1][s1]*sp[i2][s1]*sp[i3][s1]*sp[i4][s1];
							ans=ans%mod;
						}
					}
				}
			}
		}else {
			for(int i1=1;i1<=n;i1++){
				if(!sp[i1][s1]) continue;
				for(int i2=i1+1;i2<=n;i2++){
					if(!sp[i2][s1]) continue;
					for(int i3=i2+1;i3<=n;i3++){
						if(!sp[i3][s1]) continue;
						for(int i4=i3+1;i4<=n;i4++){
							if(!sp[i4][s1]) continue;
							for(int i5=i4+1;i5<=n;i5++){
								ans+=sp[i1][s1]*sp[i2][s1]*sp[i3][s1]*sp[i4][s1]*sp[i5][s1];
								ans=ans%mod;
							}
						}
					}
				}
			}
		}
	}
	cout<<ans<<endl;
	
	return 0;
}
```

---

## 作者：GXZJQ (赞：0)

# P8643 [蓝桥杯 2016 国 AC] 碱基 题解

[题目链接](https://www.luogu.com.cn/problem/P8643)

## 思路分析

考查字符串哈希/标准库容器的使用。

首先，看到数据范围：$n,m \le 5$，果断选择暴搜。对于本题，其本质就是让我们从 $n$ 个字符串中选出 $m$ 个，使得这 $m$ 个字符串拥有相同的子串，求选法的方案数。

每次处理输入的字符串，先截取其所有长度为 $k$ 的字符串 $t$，记录 $t$ 的出现信息。最后枚举所有出现过的子串 $o$，如果有不少于 $m$ 个字符串以 $o$ 作为子串，则使用乘法原理枚举选取方案，累加答案即可。


## 参考代码

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
using namespace __gnu_cxx;
using namespace __gnu_pbds;
using namespace std;
const int N = 5 + 1;
const int mod = 1e9 + 7;
int n, m, k;
long long ans, res;
string s;
vector<int> vec;
// vis[s]表示 s 是否出现过为某个字符串的长度为 k 的子串 
unordered_set<string> vis;
// cnt[i][s] 表示第 i 个字符串中每个长度为 k 的子串 s 的个数
gp_hash_table<string, int> cnt[N]; 

// 原理：乘法原理求方案数
// x: 当前选到了 vec 中的哪个数
// num: 已经选了几个数
// mul: 当前选了的数的乘积 
void DFS(int x, int num, long long mul) {
	if (num == m) {
        res = (res + mul) % mod; 
        return;
    }
	if (x == vec.size()) return;
	DFS(x + 1, num, mul);
	DFS(x + 1, num + 1, mul * vec[x] % mod);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
	cin >> n >> m >> k;
	for(int i = 1; i <= n; i++) {
		cin >> s;
		for(int j = 0; j <= s.length() - k; j++) {
			string sn = s.substr(j, k); // 截取字符串 
			cnt[i][sn]++;
			vis.insert(sn);
		}
	}
	for(auto idx : vis) {
		vec.clear();
		for(int i = 1; i <= n; i++) {
			string tmp = idx;
			int num = cnt[i][tmp]; // 第 i 个字符串中子串 tmp 的个数 
			if (num) vec.push_back(num);
		}
		if(vec.size() >= m) {
			res = 0;
			DFS(0, 0, 1);
			ans = (ans + res) % mod;
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：BLuemoon_ (赞：0)

[link](https://www.luogu.com.cn/problem/P8643)

看题的第一步，看数据范围，一眼 $n,m \le 5$，那不直接往死里爆搜。

枚举选的 $m$ 个生物，然后在哈希表里存入长为 $k$ 的所有子串。求出每一个哈希值在这些生物中各出现了多少次，全部相乘就是答案。

复杂度 $2^nnL$，可以通过，哈希直接用 `unordered_map` 实现即可，代码就不放了。~~因为我太菜了~~

---

## 作者：qwqszxc45rtnhy678ikj (赞：0)

[题面](https://www.luogu.com.cn/problem/P8643)

这道题的思路其实就和题面给的一样。用哈希处理就可以了。

哈希取模的话，就和题面给的 $1000000007$ 一样就行。

具体的：

1. 处理出每个串的前缀哈希值
2. 通过前缀哈希值处理出每个长度为 $k$ 的子串的哈希值
3. 把这些子串的哈希值塞进所属生物对应的 map（也可以是自己写的哈希表）
4. 对于每个可能的子串，枚举是哪 $m$ 个串出现了它
5. 把在这 $m$ 个串中的出现次数乘起来得到答案

记得取模。你永远可以相信哈希。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,m,k,e,qwq,wl,pw[100010],d[100010],l[100010],r[6][100010],len[6],c[200],mod=1000000007,ans;
char s[100010];
unordered_map<int,int>mp[100010],dr;
long long qpow(long long x,long long p){
    long long ans=1;
    while(p){
    	if(p&1)ans=ans*x%mod;
    	x=x*x%mod;
    	p>>=1;
	}
    return ans;
}
int main(){
	cin>>n>>m>>k;
	pw[0]=1;
    for(int i=1;i<=100000;i++)pw[i]=pw[i-1]*5%mod;
    d[100000]=qpow(pw[100000],mod-2);
    for(int i=99999;i>=0;i--)d[i]=d[i+1]*5%mod;
	c['A']=1,c['G']=2,c['C']=3,c['T']=4;
	for(int i=1;i<=n;i++){
		scanf("%s",s+1);
		len[i]=strlen(s+1);
		for(int j=1;j<=len[i];j++)r[i][j]=(r[i][j-1]+c[s[j]]*pw[j-1]%mod)%mod;
		for(int j=1;j<=len[i]-k+1;j++){
			qwq=(r[i][j+k-1]-r[i][j-1]+mod)%mod*d[j-1]%mod;
            if(!dr[qwq]){
                dr[qwq]=1;
                l[++wl]=qwq;
            }
            mp[i][qwq]++;
		}
	}
	e=pow(2,n);
	for(int i=1;i<=wl;i++)
		for(int j=0;j<e;j++){
			if(__builtin_popcount(j)!=m)continue;
			long long e=1;
			for(int c=1;c<=n;c++)
				if(j&(1<<(c-1)))
					e=e*mp[c][l[i]]%mod;
			ans=(ans+e)%mod;
		}
	cout<<ans<<endl;
	return 0;
}
```


---


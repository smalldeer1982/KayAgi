# [蓝桥杯 2018 国 B] 矩阵求和

## 题目描述

经过重重笔试面试的考验，小明成功进入 Macrohard 公司工作。

今天小明的任务是填满这么一张表：

表有 $n$ 行 $n$ 列，行和列的编号都从 $1$ 算起。

其中第 $i$ 行第 $j$ 个元素的值是 $\gcd(i, j)$ 的平方，$\gcd$ 表示最大公约数，以下是这个表的前四行的前四列：

```
1  1  1  1
1  4  1  4
1  1  9  1
1  4  1 16
```

小明突然冒出一个奇怪的想法，他想知道这张表中所有元素的和。
由于表过于庞大，他希望借助计算机的力量。


## 说明/提示

对于 $30\%$ 的数据，$n\le 1000$。

存在 $10\%$ 的数据，$n = 10^5$。

对于 $60\%$ 的数据，$n\le 10^6$。

对于 $100\%$ 的数据，$n\le 10^7$。


## 样例 #1

### 输入

```
4```

### 输出

```
48```

# 题解

## 作者：modfish_ (赞：14)

今天模拟赛居然手推出来了，庆贺一下。

## 思路
简单来说，题目要求：

$$\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)^2$$

将其进行简单转化：

$$
\begin{aligned}
&\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)^2\\
&=\sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^n[\gcd(i,j)=k]\times k^2\\
&=\sum_{k=1}^nk^2\times\sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)=k]\\
\end{aligned}
$$

后面的式子并不好求，因为其求值部分涉及到一个变量 $k$，我们宁愿这个 $k$ 存在于求和的区间中，所以：

$$
\begin{aligned}
&\sum_{k=1}^nk^2\times\sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)=k]\\
&=\sum_{k=1}^nk^2\times\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{k}\rfloor}[\gcd(i,j)=1]\\
\end{aligned}
$$

上面两式为何等价呢？若 $\gcd(i,j)=1$，则 $\gcd(ki,kj)=k$,所以将上式右边的 $i,j$ 乘上 $k$ 后，恰好等价于上式左边的 $i,j$。

现在我们的问题转换为求出 $\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{k}\rfloor}[\gcd(i,j)=1]$。容易发现，$\gcd(i,j)=1$ 与欧拉函数的定义有着一定关系。我们可以考虑将其转换为欧拉函数：

$$
\begin{aligned}
&\sum_{k=1}^nk^2\times\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{k}\rfloor}[\gcd(i,j)=1]\\
&=\sum_{k=1}^nk^2\times(2\times\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{i}[\gcd(i,j)=1]-1)\\
&=\sum_{k=1}^nk^2\times(2\times\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\varphi(i)-1)\\
\end{aligned}
$$

现在我们只要求出欧拉函数及其前缀和即可。

## 欧拉函数
定义：$\varphi(n)$ 为欧拉函数，表示小于等于 $n$ 的数中，与 $n$ 互质的数的个数。形式化地：

$$\varphi(n)=\sum_{i=1}^n[\gcd(i,j)=1]$$

要用到的性质：

欧拉函数是积性函数。形式化地，对于 $\gcd(a,b)=1$，有 $\varphi(ab)=\varphi(a)\varphi(b)$。

设 $n=p_1^{\alpha_1}p_2^{\alpha_2}\dots p_m^{\alpha_m}$，其中 $p_1,p_2,\dots,p_m$ 为互不相等的质数，则：

$$\varphi(n)=n(1-\frac{1}{p_1})(1-\frac{1}{p_2})\dots(1-\frac{1}{p_m})$$

对于质数 $p$，$\varphi(p)=p-1$。

考虑使用欧拉筛线性筛取欧拉函数。

若筛到的 $i$ 是质数，则直接令 $\varphi(i)=i-1$。

利用 $i$ 去筛其它数。令 $p_j$ 表示枚举的质数。

若 $i\bmod p_j\neq 0$，此时 $\gcd(i,p_j)=1$，由欧拉函数的积性，$\varphi(i\times p_j)=\varphi(i)\times \varphi(p_j)$。

若 $i\bmod p_j=0$，此时 $i$ 的质因数分解中必定含有 $p_j$。设 $i=q_1^{\beta_1}q_2^{\beta_2}\dots q_t^{\beta_t}\times p_j^{\gamma}(\forall 1\leq h\leq m,q_h\neq p_j)$，则：

$$
\varphi(i\times p_j)=p_j\times i\times(1-\frac{1}{q_1})(1-\frac{1}{q_2})\dots(1-\frac{1}{q_t})\times(1-\frac{1}{p_j})=p_j\times\varphi(i)
$$

这样我们就可以线性筛出欧拉函数了。

```cpp
void prime(int m){
	ntp[1] = 1;
	phi[1] = 1;
	for(int i = 2; i <= m; i ++){
		if(!ntp[i]){
			pr[++ cnt] = i;
			phi[i] = i - 1;
		}
		for(int j = 1; i * pr[j] <= m && j <= cnt; j ++){
			ntp[i * pr[j]] = 1;
			if(i % pr[j] == 0){
				phi[i * pr[j]] = phi[i] * pr[j];
				break;
			}else phi[i * pr[j]] = phi[i] * phi[pr[j]];
		}
	}
}
```

然后就很简单了，做一个前缀和，然后代入求和式，答案就出来了。时间复杂度 $O(n)$。

## 代码
```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int maxn = 1e7 + 5, mod = 1e9 + 7;

int pr[maxn], ntp[maxn], phi[maxn], cnt = 0;
ll phs[maxn];

void prime(int m){
	ntp[1] = 1;
	phi[1] = 1;
	for(int i = 2; i <= m; i ++){
		if(!ntp[i]){
			pr[++ cnt] = i;
			phi[i] = i - 1;
		}
		for(int j = 1; i * pr[j] <= m && j <= cnt; j ++){
			ntp[i * pr[j]] = 1;
			if(i % pr[j] == 0){
				phi[i * pr[j]] = phi[i] * pr[j];
				break;
			}else phi[i * pr[j]] = phi[i] * phi[pr[j]];
		}
	}
}

int main(){
	int n;
	scanf("%d", &n);
	prime(n);
	for(int i = 1; i <= n; i ++) phs[i] = (phs[i - 1] + phi[i]) % mod;
	ll ans = 0;
	for(ll i = 1; i <= n; i ++) ans = (ans + i * i * (2 * phs[n / i] - 1) % mod) % mod;
	printf("%lld", ans);
	return 0;
}
```


---

## 作者：AKPC (赞：13)

~~我写个题解怎么说像 AI 的，逆天。~~

动态规划和容斥。

在做本题之前，我们可以先考虑下面这个式子 $\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)$。

显然，因为 $1\leq\gcd(i,j)\leq\min(i,j)$，所以 $\gcd$ 的值域在 $[1,n]$ 范围内且 $\gcd$ 的结果是整数（显然），也就是总共只有 $n$ 个可能值。

可以考虑每个值 $x$ 在矩阵中出现次数，即 $\sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)==x]$。

的值，如果不考虑算重，理论上 $x$ 会出现 $\lfloor\frac{n}{x}\rfloor^2$ 次，但是形如 $kx(k\geq 2,k\in \text{N}^*)$ 的数的出现会把 $x$ 的位置占掉，这样算显然是不对的。

那么，只要做个容斥把原来的答案减去所有形如 $kx(k\geq 2,k\in \text{N}^*)$ 的数的答案即可得出 $x$ 的最终答案。

因为要做容斥，可以考虑倒序枚举，令 $f_x$ 是 $x$ 在矩阵中出现次数，可以得出转移方程 $f_x=\lfloor\frac{n}{x}\rfloor^2-\sum_{i=2,ix\leq n}f_{ix}$。

那么我们讨论的式子答案为 $\sum_{i=1}^nif_i$，再看本题，答案直接套用，为 $\sum_{i=1}^ni^2f_i$。

关于复杂度，对于一个 $x$，形如 $kx(k\geq 2,k\in \text{N}^*)$ 的数字个数为 $\lfloor\frac{n}{x}\rfloor-1$，那么总复杂度为 $\Theta(\sum_{i=1}^n\lfloor\frac{n}{i}\rfloor-n)$，约为 $\Theta(\sum_{i=1}^n\lfloor\frac{n}{i}\rfloor)$，拿数论分块的代码跑一下 $\sum_{i=1}^{10^7}\lfloor\frac{10^7}{i}\rfloor=162725364$，时间限制有两秒，所以理论常数小是可以过的。

下面是代码主要部分：

```cpp
for (int i=n;i>=1;i--){
	f[i]=(n/i)*(n/i);
	for (int j=2*i;j<=n;j+=i) f[i]-=f[j];
	ans+=f[i]*i%mod*i%mod,ans%=mod;
}
```


---

## 作者：wxzzzz (赞：12)

### 思路

$$\begin{aligned}
&\sum_{i=1}^n\sum_{j=1}^n \gcd(i,j)^2\\
&=\sum_{k=1}^n k^2\sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)=k]\\
\end{aligned}$$

令 $f_k=\displaystyle\sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)=k]$，考虑递推。

这是 $1\le i,j\le 4$ 时 $\gcd(i,j)$ 的表：

| $i,j$ | $i=1$ | $i=2$ | $i=3$ | $i=4$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $j=1$ | $1$ | $1$ | $1$ | $1$ |
| $j=2$ | $1$ | $2$ | $1$ | $2$ |
| $j=3$ | $1$ | $1$ | $3$ | $1$ |
| $j=4$ | $1$ | $2$ | $1$ | $4$ |

举个例子，$4$ 作为任意 $i,j$ 的公因数出现了四次，但在 $i=4,j=4$ 时，$2$ 的倍数 $4$ 是最大公因数，因此 $2$ 的出现次数减少了 $1$。

因此，$k$ 作为 $\gcd(i,j)$ 的出现次比它作为 $i,j$ 公因数的次数少了其所有倍数作为 $\gcd(i,j)$ 的数量。

其中，$k$ 作为 $i,j$ 公因数的次数为 ${\lfloor\dfrac{n}{i}\rfloor}^2$，$k$ 所有倍数作为 $\gcd(i,j)$ 的数量为 $\displaystyle\sum_{l=1}^n[k|l,l>k]f_l$。

故有：

$$f_i={\lfloor\frac{n}{i}\rfloor}^2-\sum_{l=1}^n[i|j,j>i]f_j$$

时间复杂度 $O(n\ln n)$。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, ans, f[10000005];
long long mod(long long x) {
    return x % 1000000007;
}
int main() {
    cin >> n;

    for (long long i = n; i >= 1; i--) {
        f[i] = mod((n / i) * (n / i));

        for (long long j = i * 2; j <= n; j += i)
            f[i] = mod(f[i] - f[j] + 1000000007);

        ans = mod(ans + mod(i * i) * f[i]);
    }

    cout << ans;
    return 0;
}
```

---

## 作者：tbdsh (赞：10)

# 题意简述
[题目传送门](//www.luogu.com.cn/problem/p8670)

[更好的阅读体验](//www.luogu.com.cn/blog/tianbiandeshenghuo/solution-8670)

给定 $n(1\le n\le 10^7)$，求 $\sum\limits^n_{i=1}\sum\limits^n_{j=1}\gcd(i,j)^2 \bmod (10^9+7)$。

# 分析
首先可以用 $O(n^2)$ 的时间复杂度打出一个 $\gcd(i,j)^2$ 的表：
![](https://cdn.luogu.com.cn/upload/image_hosting/nlr40bn7.png)

我们想要求出 $\sum\limits^n_{i=1}\sum\limits^n_{j=1}\gcd(i,j)^2$，那么就是求 $C_{\gcd(i,j)^2} \times \gcd(i,j)^2$，其中，$C_{\gcd(i,j)^2}$ 指 $\gcd(i,j)^2$ 在上述 $n\times n$ 的矩阵中的出现次数。

同时可以发现，$\gcd(i,j)^2$ 与 $\gcd(i,j)$ 一一对应，且如果序列中位置 $(i,j)$ 的值是 $\gcd(i,j)$，那么应该有 $C_{\gcd(i,j)}=C_{\gcd(i,j)^2}$。所以下文中我们用 $C_{\gcd(i,j)}$ 代替 $C_{\gcd(i,j)^2}$ 。

我们联想一下：在一个 $4\times 4$ 的矩阵中，$\gcd(2,2)^2=4$ 应该在这四个位置中出现：$(2,2),(2,4),(4,2),(4,4)$。但是，位置 $(4,4)$ 的值 $\gcd(4,4)^2=16$ 占掉了 $\gcd(2,2)^2=4$ 的位置。所以 $\gcd(2,2)^2$ 的出现次数应该是 $4-C_{\gcd(4,4)}=3$。

进一步的，我们可以发现：如果位置 $(i,j)$ 的值为 $x=\gcd(i,j)$，那么所有值为 $kx(k\ge 2)$ 的位置都会占用 $x$ 的位置。

那么，在不考虑占用的情况下，令 $x=\gcd(i,j)$，$C_{x}=(\left\lfloor \dfrac{n}{x}\right\rfloor)^2$。由于存在占用，那么 $C_{x}\gets C_x-\sum\limits^{\lceil \frac{n}{x} \rceil}_ {k=2}C_{kx}$。

可以注意到，此时我们需要的遍历顺序是 $n\sim 1$。

最终答案就是 $\sum\limits^n_{i=1}C_i\times i^2\bmod(10^9+7)$。

时间复杂度：$O(n\ln n)$。

空间复杂度：$O(n)$。

# Code
```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;
const int Mod = 1e9 + 7, MAXN = 1e7 + 5;
int cnt[MAXN];
signed main(){
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int n, ans = 0;
  cin >> n;
  for (int i = n; i >= 1; i--){
    cnt[i] = (n - n % i) / i * (n - n % i) / i;
    for (int j = 2; i * j <= n; j++){
      cnt[i] -= cnt[i * j];
    }
    (ans += i * i % Mod * (cnt[i] % Mod)) %= Mod;
  }
  cout << ans;
  return 0;
}
```

---

## 作者：fengziyi (赞：6)

### 前置芝士 / 题目

-  $\gcd$ 的性质
-  欧拉函数 $\varphi$ 及其性质

前置题目：[P2398](https://www.luogu.com.cn/problem/P2398) GCD SUM。

### 思路

简要题意：求  

$$ \sum_{i=1}^{n} \sum_{j=1}^{n} \gcd(i,j)^2 $$  

首先枚举暴力，肯定 T 飞，期望得分 [30pts](https://www.luogu.com.cn/record/106794470)。

```cpp
// #include <algorithm>
for (reg int i = 1; i <= n; ++i)
    ans = (ans + (i * i) % mod) % mod;
for (reg int i = 2; i <= n; ++i)
    for (reg int j = 1; j <= i - 1; ++j)
        ans += 2 * __gcd(i, j) * __gcd(i, j);
```

不会用莫比乌斯反演，乱搞一下。  
类似的带 $\gcd$ 的结论：

$$
\begin{aligned}

\sum_{i=1}^{n} \sum_{j=1}^{n} f\left(\gcd(i,j)\right) 

&=\sum_{d=1}^{n} d \sum_{i=1}^{n} \sum_{j=1}^{n} [f \left( \gcd(i, j) \right)=d] \\

&=\sum_{d=1}^{n} f\left(d\right) \sum_{i=1}^{n} \sum_{j=1}^{n} [\gcd(i, j)=d] \\

&=\sum_{d=1}^{n} f\left(d\right) \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{d} \rfloor} [\gcd(i, j)=1]

\end{aligned}
$$


$[\gcd(i,j)=1]$ 不就是两者互质么，那么来个欧拉函数解决问题。  

参考 [P2158](https://www.luogu.com.cn/problem/P2158) [SDOI2008] 仪仗队，排除掉重复计算。

$$
\begin{aligned}

\sum_{d=1}^{n} f\left(d\right) \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{d} \rfloor} [\gcd(i, j)=1]

&=\sum_{d=1}^{n} f\left(d\right) \left( 2 \times \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \varphi\left(n\right)-1 \right)

\end{aligned}

$$

有了这个结论就可以愉快的刷[多倍经验](https://www.luogu.com.cn/paste/kyn1fe72)了。

### 贴个代码

```cpp
inline void Euler(i64 n)
{
	phi[1] = 1;
    for (reg int i = 2; i <= n; ++i)
    {
        if (!prime[i]) prime[++prime[0]] = i, phi[i] = i - 1;
        for (reg int j = 1; j <= prime[0] && i * prime[j] <= n; ++j)
        {
            prime[i * prime[j]] = 1;
            if (!(i % prime[j])) { 
            	 phi[i * prime[j]] = phi[i] * prime[j]; break; }
            else phi[i * prime[j]] = phi[i] * phi[prime[j]];
        }
    }
    for (reg int i = 1; i <= n; ++i)
    	phisum[i] = phisum[i - 1] + phi[i];
}

int main()
{
	Euler(n);
	for (reg i64 i = 1; i <= n; ++i)
	    ans = (ans + ((i * i) % mod) * ((phisum[n / i] * 2 - 1) % mod) % mod) % mod;
}
```

---

## 作者：iyaang (赞：5)

[没人看的阅读体验](https://www.cnblogs.com/LittleTwoawa/p/16876709.html)

[题目链接](https://www.luogu.com.cn/problem/P8670)

求：
$$
\sum_{i=1}^{n} \sum_{j=1}^{n} \gcd(i,j)^2
$$

直接大力推式子：
$$
\begin{matrix}
\sum_{d=1}^{n} d \sum_{i=1}^{n} \sum_{j=1}^{n} [\gcd(i,j)^2 == d] \\
\sum_{d=1}^{n} d^2 \sum_{i=1}^{n} \sum_{j=1}^{n} [\gcd(i,j) == d] \\
\sum_{d=1}^{n} d^2 \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{d} \rfloor} [\gcd(i,j) == 1] \\
\end{matrix}
$$

莫反：
$$
\sum_{d=1}^{n} d^2 \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \mu(i) {\lfloor \frac{n}{d \times i} \rfloor}^2
$$

预处理 $\mu$ 的前缀和，整除分块即可。

$Code$
```
//sum是前缀和
Mobius(MAX-10);
n=read();
for(int d=1;d<=n;++d)
{
	int res=0;
	int N=n/d;
	for(int l=1,r;l<=N;l=r+1)
	{
		r=N/(N/l);
		res+=(sum[r]-sum[l-1])*(N/l)*(N/l); res%=m;
	}
	ans+=res*d*d; ans%=m;
}
cout<<(ans+m)%m;
```

但是一看跑出了 $4s$，尽管可以通过，但是效率是远远不够的，实际上这个题的思路远没有这么复杂。

考虑这个式子：
$$
\sum_{d=1}^{n} d^2 \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{d} \rfloor} [\gcd(i,j) == 1]
$$

从定义上理解，后面的两个求和实则是在求 $1 \sim \lfloor \frac{n}{d} \rfloor$ 这个范围内互质的数对的个数，也就是这个范围上欧拉函数的和。由于 $(i,j)$ 和 $(j,i)$ 算两对，所以计算欧拉函数前缀和时还要乘二。类似的题目有[[SDOI2008] 仪仗队](https://www.luogu.com.cn/problem/P2158)。 

这样式子就被化成了：
$$
\sum_{d=1}^{n} 2 \times d^2 \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \phi(i) 
$$

预处理出前缀和即可 $O(n)$ 计算。

$Code$
```
//sum是前缀和
n=read();
Phi(n);
for(int i=2;i<=n;++i)
	sum[i]=(sum[i-1]+phi[i]*2)%mod;
for(int i=1;i<=n;++i)
	ans=(ans+(sum[n/i]*i*i)%mod)%mod;
cout<<(ans+mod)%mod;
```

---

## 作者：reclusive (赞：4)

[my blog](https://www.cnblogs.com/reclusive2007/p/17722370.html)

# 题目描述

$$\sum_{i=1}^n \sum_{j=1}^n \gcd(i,j)^2$$

# 具体思路

## solution 1

显然可以每次枚举 $\gcd(i,j)$ 的取值。

$$\sum_{k=1}^n k^2 \sum_{i=1}^n \sum_{j=1}^n [\gcd(i,j)=k]$$

令 $i=\lfloor \frac{i}{k} \rfloor$，$j=\lfloor \frac{j}{k} \rfloor$。

$$\sum_{k=1}^n k^2 \sum_{i=1}^{\lfloor \frac{n}{k} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{k} \rfloor} [\gcd(i,j)=1]$$

$$\sum_{k=1}^n k^2 \sum_{i=1}^{\lfloor \frac{n}{k} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{k} \rfloor} \varepsilon(\gcd(i,j))$$

然后进行莫比乌斯反演。

$$\sum_{k=1}^n k^2 \sum_{i=1}^{\lfloor \frac{n}{k} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{k} \rfloor} \sum_{d \mid \gcd(i,j)} \mu(d)$$

$$\sum_{k=1}^n k^2 \sum_{i=1}^{\lfloor \frac{n}{k} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{k} \rfloor} \sum_{d \mid i,d \mid j} \mu(d)$$

交换求和顺序，由于先枚举 $i,j$ 再枚举 $d$，此时 $d$ 是 $i,j$ 的约数，因此反过来先枚举 $d$ 再枚举 $i,j$，此时 $i,j$ 就是 $d$ 的倍数。而 $1 \sim \lfloor \frac{n}{k} \rfloor$ 里面 $d$ 的倍数有 $\lfloor \frac{n}{kd} \rfloor$ 个。

$$\sum_{k=1}^n k^2 \sum_{d=1}^{\lfloor \frac{n}{k} \rfloor} \mu(d) \sum_{i=1}^{\lfloor \frac{n}{kd} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{kd} \rfloor} 1$$

$$\sum_{k=1}^n k^2 \sum_{d=1}^{\lfloor \frac{n}{k} \rfloor} \mu(d) \lfloor \frac{n}{kd} \rfloor \lfloor \frac{n}{kd} \rfloor$$

令：

$$f(n)=\sum_{d=1}^n \mu(d) \lfloor \frac{n}{d} \rfloor \lfloor \frac{n}{d} \rfloor$$

有：

$$\sum_{k=1}^n k^2 f(\lfloor \frac{n}{k} \rfloor)$$

显然 $f(n)$ 可以数论分块解决，而最后的式子也可以数论分块解决，即数论分块套数论分块。

## 时间复杂度

$$O(\sum_{i=1}^{\sqrt n} \sqrt \frac{n}{i})=O(\sqrt n\int_0^{\sqrt n} i^{-\frac{1}{2}})=O(n^{\frac{3}{4}})$$

这个复杂度跑 1e7 还是挺轻松的，但是不知道为什么题解区其他人竟然跑成了 $O(n \ln n)$。

## 注意

平方和公式：

$$\sum_{i=1}^n i^2=\frac{n \times (n+1) \times (2n+1)}{6}$$

由于答案很大，因此要记得及时取模，不然会 WA。

同时数论分块的时候，用平方和公式要记得乘 $6$ 的逆元。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=1e7;
const int mod=1e9+7;
int v[N+5],prime[N+5],pr;
int mu[N+5];LL sum[N+5];
LL qpow(LL a,LL b){
	LL ans=1%mod;a%=mod;
	while(b){
		if(b&1)ans=ans*a%mod;
		a=a*a%mod;b>>=1;
	}
	return ans;
}
void init(int n){
	memset(v,0,sizeof(v));pr=0;
	mu[1]=1;
	for(int i=2;i<=n;i++){
		if(!v[i]){
			prime[++pr]=i;
			mu[i]=-1;
		}
		for(int j=1;j<=pr&&i*prime[j]<=n;j++){
			v[i*prime[j]]=1;
			if(i%prime[j]==0){
				mu[i*prime[j]]=0;
				break;
			}
			mu[i*prime[j]]=-mu[i];
		}
	}
	for(int i=1;i<=n;i++){
		sum[i]=(sum[i-1]+mu[i])%mod;
	}
}
LL block(LL n){
	LL ans=0;
	for(LL l=1,r=0;l<=n;l=r+1){
		r=n/(n/l);
		ans=(ans+(sum[r]-sum[l-1])%mod*(n/l)%mod*(n/l)%mod+mod)%mod; 
	}
	return ans;
}
LL f(LL n){
	return n*(n+1)%mod*(2*n+1)%mod*qpow(6,mod-2)%mod;
}
LL calc(LL n){
	LL ans=0;
	for(LL l=1,r=0;l<=n;l=r+1){
		r=n/(n/l);
		ans=(ans+(f(r)-f(l-1))%mod*block(n/l)%mod+mod)%mod;
	}
	return ans;
}
int main(){
	LL n;scanf("%lld",&n);
	init(n);
	printf("%lld\n",calc(n));
	return 0;
}
```

## solution2

我们回到这个式子：

$$\sum_{k=1}^n k^2 \sum_{i=1}^{\lfloor \frac{n}{k} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{k} \rfloor} [\gcd(i,j)=1]$$

我们考虑：

$$\sum_{i=1}^{n} \sum_{j=1}^{n} [\gcd(i,j)=1]$$

我们运用数形结合的思想，把这个东西看作是平面上有 $n^2$ 个点，然后让你求这些点中横坐标与纵坐标互质的点的个数，这东西不是 [P2158 [SDOI2008] 仪仗队](https://www.luogu.com.cn/problem/P2158 "P2158 [SDOI2008] 仪仗队") 吗？

![](https://cdn.luogu.com.cn/upload/image_hosting/6eryff5d.png?x-oss-process=image)

这个时候我们使用几何直观，沿着对角线把这些点分成两部分。

![](https://cdn.luogu.com.cn/upload/image_hosting/813ktxc5.png?x-oss-process=image)

那么式子就变成了：

$$\sum_{i=1}^{n} \sum_{j=1}^{i} [\gcd(i,j)=1]$$

显然另一部分是对称的，同时要减去算了两遍的 $(1,1)$，即：

$$2 \times \sum_{i=1}^{n} \sum_{j=1}^{i} [\gcd(i,j)=1]-1$$

根据欧拉函数的定义，有：

$$2 \times \sum_{i=1}^n \varphi(i)-1$$

把这个式子带回去，有：

$$\sum_{k=1}^n k^2 \times (2 \times \sum_{i=1}^{\lfloor \frac{n}{k} \rfloor} \varphi(i)-1)$$

令：

$$f(n)=2 \times \sum_{i=1}^n \varphi(i)$$

有：

$$\sum_{k=1}^n k^2 (f(\lfloor \frac{n}{k} \rfloor)-1)$$

显然可以数论分块做。

## 时间复杂度

只用跑一次数论分块，时间复杂度为：$O(\sqrt n)$。

不过题解区又是让我很迷的做法，竟然不用数论分块而是用暴力 $O(n)$。

## 注意

平方和公式：

$$\sum_{i=1}^n i^2=\frac{n \times (n+1) \times (2n+1)}{6}$$

由于答案很大，因此要记得及时取模，不然会 WA。

同时数论分块的时候，用平方和公式要记得乘 $6$ 的逆元。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=1e7;
const int mod=1e9+7;
int v[N+5],prime[N+5],pr;
int phi[N+5];LL sum[N+5];
LL qpow(LL a,LL b){
	LL ans=1%mod;a%=mod;
	while(b){
		if(b&1)ans=ans*a%mod;
		a=a*a%mod;b>>=1;
	}
	return ans;
}
void init(int n){
    memset(v,0,sizeof(v));pr=0;
    phi[1]=1;
    for(int i=2;i<=n;i++){
        if(!v[i]){
            prime[++pr]=i;
            phi[i]=i-1;
        }
        for(int j=1;j<=pr&&i*prime[j]<=n;j++){
            v[i*prime[j]]=1;
            if(i%prime[j]==0){
                phi[i*prime[j]]=phi[i]*prime[j];
                break;
            }
            phi[i*prime[j]]=phi[i]*(prime[j]-1);
        }
    }
    for(int i=1;i<=n;i++){
    	sum[i]=(sum[i-1]+phi[i])%mod;
	}
	for(int i=1;i<=n;i++){
		sum[i]=sum[i]*2%mod;
	}
}
LL f(LL n){
	return n*(n+1)%mod*(2*n+1)%mod*qpow(6,mod-2)%mod;
}
LL block(LL n){
	LL ans=0;
	for(LL l=1,r=0;l<=n;l=r+1){
		r=n/(n/l);
		ans=(ans+(f(r)-f(l-1))%mod*(sum[n/l]-1)+mod)%mod;
	}
	return ans;
}
int main(){
	LL n;scanf("%lld",&n);
	init(n);
	printf("%lld",block(n));
	return 0;
}
```

---

## 作者：zzx0102 (赞：4)

考虑枚举 $\gcd$ 的贡献，于是可得：

$$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}\gcd(i,j)^2$$

$$=\sum\limits_{k=1}^{n}k^2\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}[\gcd(i,j)=k]$$


令 $m=\lfloor \dfrac{n}{k}\rfloor$，即求：

$$\sum\limits_{k=1}^{n}k^2\sum\limits_{i=1}^{m}\sum\limits_{j=1}^{m}[\gcd(i,j)=1]$$

那么现在求的是这个式子：

$$\sum\limits_{i=1}^{m}\sum\limits_{j=1}^{m}[\gcd(i,j)=1]$$

就是要求一个范围内互质的数对的个数。

考虑看一下仪仗队那题，线性筛出 $\varphi$。

式子转化为：

$$\sum\limits_{k=1}^{n}k^2(2\phi(i)-1)$$

这里 $\phi(i)$ 表示 $\sum\limits_{i=1}^n \varphi(i)$。

在 $\varphi(i)$ 上做个前缀和即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int P = 1e9 + 7;
const int N = 10000010; int phi[N], p[N], n, cnt; bool f[N];
void init() {
	f[1] = phi[1] = 1;
	for(int i = 2; i <= n; i++) {
		if(!f[i]) {p[++cnt] = i; phi[i] = i - 1;}
		for(int j = 1; i * p[j] <= n; j++) {
			int k = i * p[j]; f[k] = 1;
			if(i % p[j] == 0) {phi[k] = phi[i] * p[j]; break;}
			phi[k] = phi[i] * (p[j] - 1);
		}
	}
	for(int i = 1; i <= n; i++) phi[i] += phi[i - 1], phi[i] %= P;
}
int main() {
	cin >> n; init(); long long ans = 0;
	for(int i = 1; i <= n; i++) ans += 1ll * i * i % P * (2 * phi[n / i] - 1), ans %= P;
	cout << ans;
	return 0;
}
```

---

## 作者：Kreado (赞：1)

[P8670 [蓝桥杯 2018 国 B] 矩阵求和](https://www.luogu.com.cn/problem/P8670)：

同样一道水题，首先要求

$$\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)^2$$

$$\sum_{k=1}^n\sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)=k]k^2$$

前面的可以反演，首先同除 $k$，照常反演可以得到

$$\sum_{k=1}^n k^2\sum_{d=1}^{\lfloor \frac{n}{k} \rfloor}\mu(d)\lfloor \frac{n}{kd}\rfloor^2$$

这时候暴力理论也能过，时间复杂度 $O(n\ln n)$。

回到上式。

$$\sum_{k=1}^nk^2\sum_{i=1}^{\lfloor \frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor \frac{n}{k}\rfloor}[\gcd(i,j)=1]$$

答案就是

$$\sum_{i=1}^n i^2(2\phi(\frac{n}{i})-1)$$

记 $\phi(x)=\sum_{i=1}^x \varphi(i)$。

然后暴力求。

---

## 作者：Frictional (赞：0)

## 题意
给定一个 $n$，求 $\sum\limits_{i=1}^n \sum\limits_{j=1}^n \gcd(i,j)$。
## 解法
我们来看看这个式子。我们可以去枚举先求 $gcd$ 为 $d$ 的二元组的数量再乘上 $d^2$ 即可。设最大公约数为 $d$，那么，我们给这个和式中的 $i,j$ 同时除掉 $d$。就能得到式子 $\sum\limits_{i=1}^{\frac{n}{d}} \sum\limits_{j=1}^{\frac{n}{d}} [\gcd(i,j)=1]$。我们变换一下这个式子就能得到  $\sum\limits_{i=1}^{\frac{n}{d}} (2\times \sum\limits_{j=1}^{i-1} [\gcd(i,j)=1]-1)$ 减一是因为 $(1,1)$ 会算两次。显然里面这个式子就等于 $\phi(i)$，所以式子就变成了 $\sum\limits_{i=1}^{\frac{n}{d}} (2\times \phi(i)-1)$。然后用线性筛预处理出 $\phi(i)$，再求出前缀和即可。
## Code

```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
#define db double
#define U unsigned
#define P pair<int,int>
#define int long long
#define pb push_back
#define MP make_pair
#define all(x) x.begin(),x.end()
#define CLR(i,a) memset(i,a,sizeof(i))
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define ROF(i,a,b) for(int i=a;i>=b;i--)
#define debug(x) cerr<<#x<<'='<<x<<endl
#define MIN(a,b) ((a)<(b)?(a):(b))
#define MAX(a,b) ((a)>(b)?(a):(b))
#define gc getchar()
#define pc putchar
using namespace std;
inline int rd(){
    int x=0,f=1;
    char ch=gc;
    while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=gc;}
    while(ch>='0' && ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=gc;
    return x*f;
}
inline void wr(int x){
    if(x<0) x=-x;
    if(x>9) wr(x/10);
    pc((x%10)^48);
}
const int N=1e7+5;
bool st[N];
int k;
int primes[N];
int phi[N];
int sum[N];
void Prime(int x){
    phi[1]=1,phi[2]=1,phi[3]=2;
	for(int i=2;i<=x;i++){
		if(!st[i]){
            st[i]=1;
            primes[++k]=i;
            phi[i]=i-1;
        }
		for(int j=1;primes[j]*i<=x;j++){
			st[i*primes[j]]=1;
			if(i%primes[j]==0){
                phi[i*primes[j]]=phi[i]*primes[j];
                break;
            }
            phi[i*primes[j]]=phi[i]*phi[primes[j]];  
		}
	}
}
int n;
int ans;
const int mod=1e9+7;
signed main(){
    n=rd();
    Prime(N);
    FOR(i,1,n) sum[i]=sum[i-1]+phi[i];
    FOR(i,1,n){
        ans=(ans+((sum[n/i]*2-1)%mod*i%mod*i%mod)%mod)%mod;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：hikariyo_ (赞：0)

第一次从零推出数学题，写个题解纪念一下。

## 题意

对 $n<10^7$ 求值：

$$
\sum_{i=1}^n\sum_{j=1}^n\Big(\gcd(i,j)\Big)^2
$$

答案对 $10^9+7$ 取模。

## 思路

发现具有对称性，设 $S(n)=\sum_{i=1}^n i^2$，原式可化为：

$$
2\sum_{i=1}^n\sum_{j\le i}\Big(\gcd(i,j)\Big)^2-S(n)
$$

对于每一个 $i$，枚举 $d=\gcd(i,j)$，于是 $\gcd(\frac{i}{d},\frac{j}{d}) = 1$，所以原式等价于：

$$
2\sum_{i=1}^n\sum_{d|i}d^2\varphi(\frac{i}{d})-S(n)=2\sum_{i=1}^n\sum_{d|i}(\frac{i}{d})^2\varphi(d)-S(n)
$$

对于每一个 $\varphi(d)$，它们贡献给了 $i=d,2d,\dots,\lfloor\frac{n}{d}\rfloor d$，所以 $\varphi(d)$ 的贡献是 $S(\lfloor\frac{n}{d}\rfloor)$，所以原式等价于：

$$
2\sum_{d=1}^n \varphi(d)S(\lfloor\frac{n}{d}\rfloor) - S(n)
$$

众所周知 $S(n)=\frac{n(n+1)(2n+1)}{6}$，所以复杂度在于求欧拉函数，线性筛做到 $O(n)$ 就可以通过此题目了。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 10000010, P = 1e9+7;
int phi[N], primes[N], cntp;
bitset<N> st;

void init(int n) {
    phi[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!st[i]) primes[cntp++] = i, phi[i] = i-1;
        for (int j = 0; primes[j] <= n/i; j++) {
            st[i*primes[j]] = 1;
            if (i % primes[j]) phi[i*primes[j]] = phi[i] * phi[primes[j]];
            else {
                phi[i*primes[j]] = phi[i] * primes[j];
                break;
            }
        }
    }
}

int S(int n) {
    return 1ll * n * (n+1) % P * (2 * n + 1) % P * 166666668ll % P;
}

int Solve(int n) {
    int res = 0;
    init(n);
    for (int i = 1; i <= n; i++) res = (res + 1ll * S(n / i) * phi[i]) % P;
    res = (((2ll * res - S(n)) % P) + P) % P;
    return res;
}

int main() {
    int n;
    cin >> n;
    cout << Solve(n) << endl;
    return 0;
}
```

---

## 作者：Robin_kool (赞：0)

简单讲，题目求 $ans=\sum_{i=1}^n \sum_{j=1}^n \gcd(i,j)^2$。

$$\begin{aligned}
ans&=\sum_{i=1}^n \sum_{j=1}^n \gcd(i,j)^2 \\
&=\sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^n [\gcd(i,j)=k] \times k^2 \\
&=\sum_{k=1}^n k^2 \times \sum_{i=1}^n\sum_{j=1}^n [\gcd(i,j)=k] \\
&=\sum_{k=1}^n k^2 \times \sum_{i=1}^{\lfloor \frac{n}{k} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{k} \rfloor} [\gcd(i,j)=1]
\end{aligned}
$$

因为 $\gcd(ki,kj)=k$ 当且仅当 $\gcd(i,j)=1$ 的情况下。

发现 $\gcd(i,j)=1$ 的性质有点像欧拉函数:

假设 $n$ 分解质因数为 $n=p_1^{q_1}.....$

设 $p$ 去重后的序列为 $P$ 那么 $\varphi(n)=n\times\prod(1-\frac{1}{P_i})$。

然后继续化简原式子，得到

$$\sum_{k=1}^n k^2 \times (2 \times \sum_{i=1}^n \varphi(i) - 1)$$

前缀和处理一下 $\varphi(i)$ 即可。

---

## 作者：hzoi_Shadow (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8670)

# 前置知识

[欧拉函数](https://oi-wiki.org/math/number-theory/euler-totient/)

# 解法

欧拉反演，简单地推下式子即可。

$\begin{aligned}\sum\limits_{i=1}^{n} \sum\limits_{j=1}^{n} \gcd(i,j)^{2} &=\sum\limits_{i=1}^{n} \sum\limits_{j=1}^{n} \sum\limits_{d=1}^{n}d^{2} [\gcd(i,j)=d] \\ &=\sum\limits_{i=1}^{n} \sum\limits_{j=1}^{n} \sum\limits_{d=1}^{n}d^{2} [\gcd(\dfrac{i}{d},\dfrac{j}{d})=1] \\ &=\sum\limits_{d=1}^{n}d^{2} \sum\limits_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor} \sum\limits_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor} [\gcd(i,j)=1] \\ &=\sum\limits_{d=1}^{n}d^{2} (-1+2 \sum\limits_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor} \varphi(i)) \end{aligned}$

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
ll phi[10000001],prime[10000001],sum[10000001],len=0;
bool vis[10000001];
void euler(ll n)
{
	memset(vis,0,sizeof(vis));
	phi[1]=1;
	for(ll i=2;i<=n;i++)
	{
		if(vis[i]==false)
		{
			len++;
			prime[len]=i;
			phi[i]=i-1;
		}
		for(ll j=1;j<=len&&i*prime[j]<=n;j++)
		{
			vis[i*prime[j]]=true;
			if(i%prime[j]==0)
			{
				phi[i*prime[j]]=phi[i]*prime[j];
				break;
			}
			else
			{
				phi[i*prime[j]]=phi[i]*(prime[j]-1);
			}
		}
	}
}
int main()
{
	ll n,ans=0,i,p=1000000007;
	cin>>n;
	euler(n);
	for(i=1;i<=n;i++)
	{
		sum[i]=sum[i-1]+phi[i];
	}
	for(i=1;i<=n;i++)
	{
		ans=(ans+(i*i%p)*((2*sum[n/i]%p-1+p)%p)%p)%p;
	}
	cout<<ans<<endl;
	return 0;
}
```

# 后记

多倍经验：P2398

---

## 作者：KohaD_SEGA (赞：0)

出题人非常良心，没有狠狠卡我们的时限（给了 2s）。既然如此，那么我们就可以毫不客气地用一些比较慢速的方法解决这个问题。

这个题目要求的就是 $\sum\limits_{i=1}^n\sum\limits_{j=1}^n\ \gcd(i,j)^2$。

这个值根据莫比乌斯反演依葫芦画瓢式的变换，可以很容易进行以下计算：

$$\begin{aligned} &\ \ \ \ \ \sum\limits_{i=1}^n\sum\limits_{j=1}^n\ \gcd(i,j)^2  \\ &= \sum\limits_{g=1}^ng^2\sum\limits_{1\leqslant i,j
\leqslant n}[\gcd(i,j)=g] \\ &=\sum\limits_{g=1}^ng^2\sum\limits_{1\leqslant i,j
\leqslant [\frac{n}{g}]}[\gcd(i,j)=1] \\ &=\sum\limits_{g=1}^ng^2\sum\limits_{e=1}^{[\frac{n}{g}]}\mu(e)\big[\dfrac{n}{g}\big]^2\end{aligned}$$

然后用前缀和和数论分块做即可。

**要点：** 建议不要临时使用 $\sum n^2=\dfrac{n(n+1)(2n+1)}{6}$ 计算平方前缀和。因为 $n\leqslant 10^7$，这个平方和超过了 $10^{19}$ 也就是 unsigned long long 范围以上。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const ll MOD=1000000007;
ll Mu[10000001];
ll Prime[2000000];
ll vis[10000001];
ll sq[10000001];
inline void CalSq(ll n)
{
	for(ll i=1;i<=n;i++)
	{
		sq[i]=(sq[i-1]+i*i)%MOD;
	}
}
void CalMu(ll n)
{
	Mu[1]=1;
	ll tot=0;
	for(ll i=2;i<=n;i++)
	{
		if(!vis[i])
		{
			Prime[++tot]=i;
			Mu[i]=-1;
		}
		for(ll j=1;j<=tot && i*Prime[j]<=n;j++)
		{
			vis[i*Prime[j]]=1;
			if(i%Prime[j]==0)	break;
			Mu[i*Prime[j]]=-Mu[i];
		}
	}
	for(ll i=2;i<=n;i++)	Mu[i]+=Mu[i-1];
}
inline ll solve(ll m)
{
	ll ans=0;
	for(ll l=1,r;l<=m;l=r+1)
	{
		r=m/(1LL*m/l);
		ans+=(Mu[r]-Mu[l-1])*(1LL*m/l)*(1LL*m/l);
		ans=(ans%MOD+MOD)%MOD;
	}
	return (ans%MOD+MOD)%MOD;
}
int main()
{
	ll n;
	cin>>n;
	CalMu(n);
	CalSq(n);
	ll ans=0;
	for(ll l=1,r;l<=n;l=r+1)
	{
		r=n/(1LL*n/l);
		ans+=(sq[r]-sq[l-1])*solve(n/l);
		ans=(ans%MOD+MOD)%MOD;
	}
	cout<<ans<<endl;	
}
```

---

## 作者：meyi (赞：0)

题目要求的东西即 

$$\sum\limits_{i=1}^n \sum\limits_{j=1}^n \gcd(i,j)^2$$

直接开始推式子，套路性地设 $\gcd(i,j)=d$，则答案为 

$$\sum\limits_{d=1}^n d^2\sum\limits_{i=1}^n \sum\limits_{j=1}^n [\gcd(i,j)=d]$$

$$=\sum\limits_{d=1}^n d^2\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor} \sum\limits_{j=1}^{\lfloor\frac{n}{d}\rfloor} [\gcd(i,j)=1]$$

$$=\sum\limits_{d=1}^n d^2\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor} \varphi(i)$$

于是整除分块套求 $\varphi$ 的前缀和即可，笔者选择了使用杜教筛解决本题，时间复杂度 $O(n^\frac{2}{3})$，可以很简单地优化到 $O(\frac{n^\frac{2}{3}}{\log n})$，但在此处不再赘述。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
//#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops")
#define ALL(v) v.begin(),v.end()
#define For(i,_) for(int i=0,i##end=_;i<i##end;++i) // [0,_)
#define FOR(i,_,__) for(int i=_,i##end=__;i<i##end;++i) // [_,__)
#define Rep(i,_) for(int i=(_)-1;i>=0;--i) // [0,_)
#define REP(i,_,__) for(int i=(__)-1,i##end=_;i>=i##end;--i) // [_,__)
typedef long long ll;
typedef __int128 ull;
#define V vector
#define pb push_back
#define pf push_front
#define qb pop_back
#define qf pop_front
#define eb emplace_back
typedef pair<int,int> pii;
typedef pair<ll,int> pli;
#define fi first
#define se second
const int dir[4][2]={{-1,0},{0,1},{1,0},{0,-1}},inf=0x3f3f3f3f,mod=1e9+7,inv6=166666668;
const ll infl=0x3f3f3f3f3f3f3f3fll;
template<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,1:0;}
template<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,1:0;}
int init=[](){return cin.tie(nullptr)->sync_with_stdio(false),0;}();
struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
        // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
template<class T1,class T2>
inline V<T1> pre1d(const V<T2> &v,const function<T1(T1,T2)> &f=[](const T1 &x,const T2 &y){return x+y;}){
    V<T1>ret(v.size());
    For(i,v.size())ret[i]=f((i?ret[i-1]:T1()),v[i]);
    return ret;
}
struct phi_table{
	int n;
	V<int>phi,pri;
	inline phi_table(int n_=0){n=n_,init();}
	inline void init(){
        if(n<1)return;
		V<int>(n+1).swap(phi),V<int>().swap(pri);
		phi[1]=1;
		FOR(i,2,n+1){
			if(!phi[i])phi[i]=i-1,pri.pb(i);
			for(int j:pri){
				if(1ll*i*j>n)break;
				if(i%j==0){
					phi[i*j]=phi[i]*j;
					break;
				}
				phi[i*j]=phi[i]*(j-1);
			}
		}
	}
	inline int get(int k){return k<1?0:phi[k];}
};
template<class T,class container>
T du_sieve(T n,const V<T> &pre_f,const function<T(T)> &pre_g,const function<T(T)> &pre_fg,container &h){
	if(n<pre_f.size())return pre_f[n];
	auto it=h.emplace(n,0);
	T &x=it.fi->se;
	if(it.se){
		T pre=pre_g(1);
		x=pre_fg(n);
		for(T i=2;i<=n;++i){
			T div=n/i,j=n/div,cur=pre_g(j);
			x-=(cur-pre)*du_sieve(div,pre_f,pre_g,pre_fg,h);
			i=j,pre=cur;
		}
	}
	return x;
}
int main(){
	int t_case=1;
//	scanf("%d",&t_case);
	while(t_case--){
		ll n;
		scanf("%lld",&n);
		unordered_map<ull,ull,custom_hash>h_phi;
		ll m=cbrt(n)*cbrt(n);
		V<ull>pre_phi=pre1d<ull>(phi_table(m).phi);
		function<ull(ull)>pre_I=[&](ull k){return k;},pre_id=[&](ull k){return k*(k+1)>>1;};
		ull ans=0;
		for(ull l=1;l<=n;){
			ull div=n/l,r=n/div;
			ans+=(r*(r+1)*(2*r+1)-(l-1)*l*(2*l-1))%mod*du_sieve(div,pre_phi,pre_I,pre_id,h_phi)%mod;
			if(ans<0)ans+=mod;
			l=r+1;
		}
		printf("%lld\n",ll((ans*2-n*ull(n+1)*(2*n+1))%mod+mod)*inv6%mod);
	}
	return 0;
}
/*
sum i=1~n sum j=1~n gcd^2(i,j)
sum d=1~n d^2 sum i=1~n sum j=1~n [gcd(i,j)=d]
sum d=1~n d^2 sum i=1~n/d sum j=1~n/d [gcd(i,j)=1]
sum d=1~n d^2 sum i=1~n/d phi(i)
*/
```

---

## 作者：tmlrock (赞：0)

题目：求 $\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)$ 的值。
## 推式子
$$\sum_{i=1}^n\sum_{j=1}^n\gcd\left(i,j\right)^2$$
$$=\sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^nk^2\times\left[\gcd(i,j)==k\right]$$
$$=\sum_{k=1}^nk^2\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)$$
$$=\sum_{k=1}^nk^2\left(2\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\varphi(i)-1\right)$$

代入杜教筛公式。
$$=\sum_{k=1}^nk^2\left(n^2+n-\sum_{i=2}^n S\left(\lfloor\dfrac{n}{i}\rfloor\right)\right)$$
## 实现
先用欧拉筛筛出前 $K$ 个，再求。
复杂度 $\Theta\left(K+\dfrac{n}{\sqrt{K}}\right) = \Theta(n^{\frac{2}{3}})$.


代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod = 1000000007;
unordered_map<int, int>mp;
int K = 10000;
int s[500010];
inline int S(int x) {
	if (x <= K)return s[x];//预处理
	if (mp.find(x) != mp.end())return mp[x];//记忆化
	int j = 0;
	int ans = 1ll * (x) * (x + 1) / 2;
	for (int i = 2; i <= x; i = j + 1) {
		j = x / (x / i);//数论分块
		ans -= (j - i + 1) * S(x / i);//个数*每个的值
	}
	return mp[x] = (ans % mod);
}
int primes[500010];
int cnt;
bool st[500010];
inline void init() {
	//欧拉筛求欧拉函数
	s[1] = 1;
	for (int i = 2; i <= K; i++) {
		if (!st[i]) {
			primes[cnt++] = i;
			s[i] = i - 1; //质数前面所有数都互质
		}
		for (int j = 0; primes[j] <= K / i; j++) {
			int t = primes[j] * i;
			st[t] = true;
			if (i % primes[j] == 0) {
				s[t] = primes[j] * s[i];
				break;
			}
			s[t] = s[i] * (primes[j] - 1);
		}
	}
	for (int i = 1; i <= K; i++)
		s[i] += s[i - 1], s[i] %= mod;
}
signed main() {
	int n;
	cin >> n;
	init();
	int ans = 0;
	for (int i = 1; i <= n; ++i)ans = (ans + ((i * i) % mod * ( (S(n / i) << 1) % mod - 1 )) % mod) % mod;//公式
	cout << ans;
	return 0;
}

```

---


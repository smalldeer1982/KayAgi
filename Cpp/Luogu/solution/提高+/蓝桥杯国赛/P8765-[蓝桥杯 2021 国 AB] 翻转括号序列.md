# [蓝桥杯 2021 国 AB] 翻转括号序列

## 题目描述

给定一个长度为 $n$ 的括号序列，要求支持两种操作:

1. 将 $\left[L_{i}, R_{i}\right]$ 区间内（序列中的第 $L_{i}$ 个字符到第 $R_{i}$ 个字符）的括号全部翻转(左括号变成右括号，右括号变成左括号)。

2. 求出以 $L_{i}$ 为左端点时，最长的合法括号序列对应的 $R_{i}$ （即找出最大的 $R_{i}$ 使 $\left[L_{i}, R_{i}\right]$ 是一个合法括号序列）。

## 说明/提示

对于 $20 \%$ 的评测用例，$n, m \leq 5000$;

对于 $40 \%$ 的评测用例，$n, m \leq 30000$;

对于 $60 \%$ 的评测用例，$n, m \leq 100000$;

对于所有评测用例，$1 \leq n \leq 10^{6}, 1 \leq m \leq 2 \times 10^{5}$ 。 

蓝桥杯 2021 国赛 A 组 H 题（B 组 I 题）。

## 样例 #1

### 输入

```
7 5
((())()
2 3
2 2
1 3 5
2 3
2 1```

### 输出

```
4
7
0
0```

# 题解

## 作者：Wf_yjqd (赞：8)

比较基础的线段树板子。

------------

若用 $1$ 表示左括号，$-1$ 表示右括号，求原串的前缀和 $sum_i$，考虑 $[l,r]$ 为合法括号序列的条件:

1.$sum_{l-1}=sum_r$。

2.对于任意 $i$ 满足 $l\le i\le r$，有 $sum_{l-1}\le sum_i$。

考虑式二可以用区间最小值维护，且满足单调性，于是想到线段树 $+$ 二分。

满足式二以后，只要找到解集中最右一个满足式一的即可。

如果 $sum_{l-1}\le sum_i<sum_{l-1}+1$ 且 $sum_i\in\mathbb{Z}$，则 $sum_{l-1}=sum_i$。

因此式一也满足单调性，这样先在 $x$ 向右二分式二，再在式二最大取值向左二分式一，就可以处理询问了。

那么，如何处理修改操作呢？

考虑如果要把一个区间 $[l,r]$ 取反，完全可以分成 $[1,l-1]$ 和 $[1,r]$ 分别取反。

这样就可以分成两个左端点为 $1$ 的区间，于是可以用上面的前缀和维护了。

具体来说，将 $[1,x]$ 取反的代价为：

$sum_i(1\le i\le x)$ 全取相反数，$sum_i(x+1\le i\le n)$ 全加上 $-sum_x\times 2$。

前者影响了最小值，所以再维护一个最大值，每次先交换最大和最小值再取反。

后者中，单点查询 $sum_x$，然后用懒惰标记处理区间加就行。

总体复杂度 $\operatorname{O}(m\times\log n)$。

------------

码量还行吧（可能线段树本身长），基本就板子。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+84;
const int maxt=5e6+84;
int n,m,op,x,y,ans,slast,qzh[maxn];
char s[maxn];
struct Point{
    int l,r,miin,maax,lazy_swap,lazy_add;
};
struct Tree{
    Point T[maxt];
    inline void pushup(int x){
        T[x].maax=max(T[x<<1].maax,T[x<<1|1].maax);
        T[x].miin=min(T[x<<1].miin,T[x<<1|1].miin);
        return ;
    }
    inline void swp(int x){
        swap(T[x].maax,T[x].miin);
        T[x].maax*=-1;
        T[x].miin*=-1;
        T[x].lazy_add*=-1;
        T[x].lazy_swap^=1;
        return ;
    }
    inline void addd(int x,int val){
        T[x].miin+=val;
        T[x].maax+=val;
        T[x].lazy_add+=val;
        return ;
    }
    inline void pushdown(int x){
        if(T[x].lazy_swap){
            swp(x<<1);
            swp(x<<1|1);
            T[x].lazy_swap=0;
        }
        if(T[x].lazy_add){
            addd(x<<1,T[x].lazy_add);
            addd(x<<1|1,T[x].lazy_add);
            T[x].lazy_add=0;
        }
        return ;
    }
    inline void init(int id,int l,int r){
        T[id].l=l;
        T[id].r=r;
        if(l==r){
            T[id].maax=T[id].miin=qzh[l];
            return ;
        }
        int mid=l+r>>1;
        init(id<<1,l,mid);
        init(id<<1|1,mid+1,r);
        pushup(id);
        return ;
    }
    inline void add(int id,int l,int r,int val){
        if(l<=T[id].l&&T[id].r<=r){
            addd(id,val);
            return ;
        }
        pushdown(id);
        int mid=T[id].l+T[id].r>>1;
        if(l<=mid)
            add(id<<1,l,r,val);
        if(mid<r)
            add(id<<1|1,l,r,val);
        pushup(id);
        return ;
    }
    inline void swapp(int id,int l,int r){
        if(l<=T[id].l&&T[id].r<=r){
            swp(id);
            return ;
        }
        pushdown(id);
        int mid=T[id].l+T[id].r>>1;
        if(l<=mid)
            swapp(id<<1,l,r);
        if(mid<r)
            swapp(id<<1|1,l,r);
        pushup(id);
        return ;
    }
    inline int query_p(int id,int pos){
        if(!pos)
            return 0;
        if(T[id].l==T[id].r)
            return T[id].maax;
        pushdown(id);
        int mid=T[id].l+T[id].r>>1;
        if(pos<=mid)
            return query_p(id<<1,pos);
        return query_p(id<<1|1,pos);
    }
    inline void modify(int x){
        if(!x)
            return ;
        if(x<n)
            add(1,x+1,n,-query_p(1,x)*2);
        swapp(1,1,x);
        return ;
    }
    inline int bsy(int id,int x,int val){
        if(T[id].l==T[id].r)
            return T[id].l;
        pushdown(id);
        int anss=n+1,mid=T[id].l+T[id].r>>1;
        if(T[id<<1].miin<val&&x<=mid)
            anss=bsy(id<<1,x,val);
        if(anss!=n+1)
            return anss;
        if(T[id<<1|1].miin<val)
            anss=bsy(id<<1|1,x,val);
        return anss;
    }
    inline int bsz(int id,int x,int val){
        if(T[id].l==T[id].r)
            return T[id].l;
        pushdown(id);
        int anss=-168,mid=T[id].l+T[id].r>>1;
        if(T[id<<1|1].miin<val&&x>mid)
            anss=bsz(id<<1|1,x,val);
        if(anss>0)
            return anss;
        if(T[id].miin<val)
            anss=bsz(id<<1,x,val);
        return anss;
    }
    inline int anser(int x){
        slast=query_p(1,x-1);
        ans=bsz(1,bsy(1,x,slast)-1,slast+1);
        return ans>x?ans:0;
   }
}Sherry;
inline int mp(char c){
    return c=='('?1:-1;
}
int main(){
    scanf("%d%d",&n,&m);
    scanf("%s",s+1);
    for(int i=1;i<=n;i++)
        qzh[i]=qzh[i-1]+mp(s[i]);
    Sherry.init(1,1,n);
    while(m--){
        scanf("%d%d",&op,&x);
        if(op==2){
            printf("%d Sherry\n",Sherry.anser(x));
            continue;
        }
        scanf("%d",&y);
        Sherry.modify(y);
        Sherry.modify(x-1);
    }
    return 0;
}
```


---

## 作者：Ristear (赞：5)

## 题意描述
给定一个长度为 $n$ 的括号序列和 $m$ 次操作。

- 给定 $L$ 和 $R$，将 $[L,R]$ 区间内的括号翻转。
- 给定 $L$ 找到最大的 $R$ 使得 $[L,R]$ 区间是一个合法括号序列。 

## 题意转化
将所有左括号设为 $1$，右括号设为$-1$，那么就可以使转化操作。

- 将 $[L,R]$ 区间的数都变成其相反数。
- 找到最大的 $R$，使得 $\sum_{i=L}^R a[i] = 0$，且对于任意的 $k \in [L,R]$ 满足 $\sum_{i=L}^k a[i] \ge 0$。

## 题解
我们用线段树维护三个值:

- 和
- 最小前缀和
- 最大前缀和

对于操作一：

- 我们将区间乘 $-1$，交换最大前缀和与最小前缀和。

对于操作二：

- 由于我们在固定左端点 $L$ 以后，最小前缀和是单调不增的，所以我们可以二分找到最右端的**大于** $0$ 的最小前缀和的位置。接下来往前找，找到第一个满足 $\sum_{i=L}^R a[i] = 0$ 的点。

建树时将叶子节点记录的值都设为该点的括号对应的字符，然后合并，**合并右节点时要注意加上左节点的和**。

## 参考代码
~~~ cpp
#include <bits/stdc++.h>

using namespace std;

int n,m;
int a[1000010];
struct node {int x,maxn,minn,la;}t[4000010];

//上传更新
void pushup(int x)
{
	t[x].x=t[2*x].x+t[2*x+1].x;
	t[x].maxn=max(t[2*x].maxn,t[2*x+1].maxn+t[2*x].x);
	t[x].minn=min(t[2*x].minn,t[2*x+1].minn+t[2*x].x);
	return ;
}

//下放懒标记
void getlazy(int x)
{
	t[x].la++;
	t[x].x*=-1;
	t[x].maxn*=-1;
	t[x].minn*=-1;
	swap(t[x].maxn,t[x].minn);
	return ;
}

void pushdown(int x)
{
	t[x].la%=2;
	if(t[x].la) 
	{
		getlazy(2*x);
		getlazy(2*x+1);
		t[x].la=0;
	}
	return ;
}

//建树
void build(int x,int l,int r)
{
	if(l==r)
	{
		t[x]=(node){a[l],a[l],a[l],0};
		return ;
	}
	int mid=(l+r)>>1;
	build(2*x,l,mid);
	build(2*x+1,mid+1,r);
	pushup(x);
	return ;
}

void update(int x,int l,int r,int ll,int rr)
{
	if(ll<=l&&rr>=r) {getlazy(x);return ;}
	pushdown(x);
	int mid=(l+r)>>1;
	if(ll<=mid) {update(2*x,l,mid,ll,rr);}
	if(rr>mid) {update(2*x+1,mid+1,r,ll,rr);}
	pushup(x);
	return ;
}

//求区间和
int query_sum(int x,int l,int r,int ll,int rr)
{
	if(ll<=l&&rr>=r) {return t[x].x;}
	pushdown(x);
	int mid=(l+r)>>1,res=0;
	if(ll<=mid) {res+=query_sum(2*x,l,mid,ll,rr);}
	if(rr>mid) {res+=query_sum(2*x+1,mid+1,r,ll,rr);}
	return res;
}

//求区间最小前缀和
int query_min(int x,int l,int r,int ll,int rr,int sum)
{
	if(ll<=l&&rr>=r) {return t[x].minn+sum;}
	pushdown(x);
	int mid=(l+r)>>1,res=1e9;
	if(ll<=mid) {res=min(res,query_min(2*x,l,mid,ll,rr,sum));sum+=query_sum(2*x,l,mid,ll,rr);}
	if(rr>mid) {res=min(res,query_min(2*x+1,mid+1,r,ll,rr,sum));}
	return res;
}

bool check(int x,int y) {return ((query_min(1,1,n,x,y,0)>=0)?(true):(false));}

void solve(int L)
{
	if(query_sum(1,1,n,L,L)==-1) {cout<<"0\n";return ;}
	int l=L,r=n;
	while(l<r)
	{
		int mid=(l+r+1)>>1;
		if(check(L,mid)) {l=mid;}
		else {r=mid-1;}
	}
	int S=query_sum(1,1,n,L,l);
	if(query_min(1,1,n,L,l,0)!=0) {cout<<"0\n";return ;}
	while(S) {l-=S;S=query_sum(1,1,n,L,l);}
//这一步可以减少时间复杂度，减少枚举次数
	cout<<l<<'\n';
	return ;
}

signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		char x;cin>>x;
		a[i]=((x=='(')?(1):(-1));
	}
	build(1,1,n);
	for(int i=1;i<=m;i++)
	{
		int op;cin>>op;
		if(op==1) 
		{
			int l,r;cin>>l>>r;
			update(1,1,n,l,r);
		}
		else
		{
			int l;cin>>l;
			solve(l);
		}
	}
	return 0;
}
~~~

---

## 作者：zhouyuhang (赞：5)

**合法括号序列** 可以被等价地描述为：

- 序列中左括号与右括号数量相等。
- 序列的任意前缀中，左括号数量不小于右括号数量。

更易接受的叙述是：如果将左括号赋值为 $1$，右括号赋值为 $-1$，则序列的和与最小前缀和均为 $0$。

注意到，序列的最小前缀和在 $l$ 固定时关于 $r$ 单调不增。由此可以考虑线段树上二分。

具体而言，建立线段树，并在每个结点维护：

- 和
- 最小前缀和
- 所有最小前缀和对应端点中最靠右者

查询时，在线段树上二分，如果最小前缀和已经小于 $0$，则考虑向左走；否则继续向右走。由于 $l$ 与二分所得端点（记为 $r'$）所构成区间最小前缀和恰好为 $0$，答案即为 $[l,r']$ 所有最小前缀和对应端点中最靠右者。

考虑如何修改。不难发现，翻转操作本质上是给区间乘了一个 $-1$。额外维护最大前缀和，最大前缀和端点最靠右者即可。

复杂度 $\mathcal O(n\log n)$。使用更加简明的 $\mathcal O(n\log^2n)$ 实现同样可以通过。

---

## 作者：zhangchengqi666 (赞：3)

## 说在前面
作为一道线段树题，对于我这种刚学线段树的萌新非常不友好……

前置芝士：懒标记下传、前缀和、线段树上二分。

## 题目分析
好了，让我们进入正题。

首先，看到第一个询问，反转序列，实质上就是将线段树的一个区间乘上 $-1$。如果让线段树的一个区间表示为 $[1, 1, -1, 1, -1]$，则反转后的区间为 $[-1, -1, 1, -1, 1]$。

对于第一个询问，维护乘法标记即可。

对于第二个询问，在给定左端点的情况下，要求最长合法序列的右端点。考虑合法括号序列的性质：

1. 左括号数量等于右括号数量。
2. 前缀序列中，左括号数量一定大于等于右括号。

想想看，为什么？

假设有以下括号序列：$\texttt{)(())(}$。

它是合法的吗？

显然不是。原因是：一个合法序列中，**左括号一定出现于右括号之前**。

所以，我们用 $1$ 表示左括号，用 $-1$ 表示右括号，则问题转化为：在给定左端点的情况下，求最大的 $r$，使得序列满足以下性质：

1. $$\sum_{i = l}^{r} a_i = 0$$

其中 $a_i$ 是用数字表示的括号序列的第 $i$ 位。

2. 对于任意的 $i \in [l, r]$，满足：

$$\sum_{j=l}^{i} a_i \ge 0$$

我们还可以得知，在给定左端点的情况下，合法括号序列的前缀和**单调不增**。

因此，考虑线段树上二分。如果这个节点的所有前缀和小于 $0$，则往左走，否则往右走。

那我们如何快速得知一个节点的所有前缀和呢？维护区间最小。因为如果最小值都大于等于 $0$，那其他值肯定也大于等于零。

别忘了，这题还有区间乘 $-1$ 的操作，所以在乘完之后，最小值会变为最大值，额外维护一个区间前缀和最大值，修改时交换最小和最大即可。

在确定了前缀和满足的 $r$ 之后，从 $r$ 开始往 $l$ 扫描，找到前缀和为零的 $r$ 即为答案。

## 注意事项

我们这题维护的一直都是前缀和，所以在上传信息、查询最小值时记得加上左儿子的区间和。

## 完整代码

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int N = 1000000 + 5;

struct node {
	int l, r, mn, mx, sum, tag;
} tree[N * 4];

int a[N];

int n, m;

string x;

void pushup(int x) {
	tree[x].sum = tree[x << 1].sum + tree[x << 1 | 1].sum;
	tree[x].mn = min(tree[x << 1].mn, tree[x << 1 | 1].mn + tree[x << 1].sum);
	tree[x].mx = max(tree[x << 1].mx, tree[x << 1 | 1].mx + tree[x << 1].sum);
}

void build(int u, int l, int r) {
	tree[u].l = l;
	tree[u].r = r;
	tree[u].tag = 1;
	int mid = l + r >> 1;
	if (l == r) {
		tree[u].mx = tree[u].mn = tree[u].sum = a[l];
		return;
	}
	build(u << 1, l, mid);
	build(u << 1 | 1, mid + 1, r);
	pushup(u);
}

void pushdown(int x) {
	int L = x << 1;
	int R = x << 1 | 1;
	if (tree[x].tag != 1) {
		tree[L].sum *= -1;
		tree[L].tag *= -1;
		tree[L].mn *= -1;
		tree[L].mx *= -1;
		swap(tree[L].mx, tree[L].mn);
		tree[R].sum *= -1; 
		tree[R].tag *= -1;
		tree[R].mn *= -1;
		tree[R].mx *= -1;
		swap(tree[R].mx, tree[R].mn);
		tree[x].tag = 1;
	}
}

void change(int u, int l, int r) {
	if (l <= tree[u].l && tree[u].r <= r) {
		tree[u].tag *= -1;
		tree[u].sum *= -1;
		tree[u].mn *= -1;
		tree[u].mx *= -1;
		swap(tree[u].mx, tree[u].mn);
		return;
	}
	int mid = tree[u].l + tree[u].r >> 1;
	pushdown(u);
	if (mid >= l) {
		change(u << 1, l, r);
	}
	if (mid < r) {
		change(u << 1 | 1, l, r);
	}
	pushup(u);
}

int solve(int u, int l, int r) {
	if (l <= tree[u].l && tree[u].r <= r) {
		return tree[u].sum;
	}
	int mid = tree[u].l + tree[u].r >> 1;
	int ans = 0;
	pushdown(u);
	if (mid >= l) {
		ans += solve(u << 1, l, r);
	}
	if (mid < r) {
		ans += solve(u << 1 | 1, l, r);
	}
	return ans;
}

int ask(int u, int l, int r, int sum) {
	if (l <= tree[u].l && tree[u].r <= r) {
		return tree[u].mn + sum;
	}
	int mid = tree[u].l + tree[u].r >> 1;
	pushdown(u);
	int a = 0x3f3f3f3f, b = 0x3f3f3f3f;
	if (mid >= l) {
		a = ask(u << 1, l, r, sum);
		sum += solve(u << 1, l, r);
	}
	if (mid < r) {
		b = ask(u << 1 | 1, l, r, sum);
	}
	return min(a, b);
}

int query(int l, int r) {
	int dl = l, dr = r, ans = 0x3f3f3f3f;
	while (dl <= dr) {
		int mid = dl + dr >> 1;
		if (ask(1, l, mid, 0) >= 0) {
			ans = mid;
			dl = mid + 1;
		} else {
			dr = mid - 1;
		}
	}
	if (ans == 0x3f3f3f3f) {
		return 0;
	} 
	int i = ans;
	while (i >= l) {
		if (solve(1, l, i) == 0) {
			return i;
		}
		i -= solve(1, l, i);
	}
	return 0;
}

signed main() {
	cin >> n >> m;
	cin >> x;
	for (int i = 0; i < x.size(); i++) {
		if (x[i] == '(') {
			a[i + 1] = 1;
		} else {
			a[i + 1] = -1;
		}
	}
	build(1, 1, n);
	for (int i = 1; i <= m; i++) {
		int opt, l, r;
		cin >> opt >> l;
		if (opt == 1) {
			cin >> r;
			change(1, l, r);
		} else {
			cout << query(l, n) << endl;
		}
	}
	return 0;
}
```
## 说在后面

写题解不易，望点赞。

---

## 作者：meiyunxi (赞：0)

# P8765 [蓝桥杯 2021 国 AB] 翻转括号序列题解

[题目传送门](https://www.luogu.com.cn/problem/P8765)

先告诉大家，这道题就是用的线段树。

为了方便统计前缀和，我们将左括号赋值为 $1$，右括号赋值为 $-1$，$he[]$ 表示前缀和。

首先考虑操作 2：

在 $[l, r]$ 的区间内，满足括号匹配的要求当且仅当满足以下条件：

1. $he[r] - he[l - 1] = 0$，表示 $l$ 到 $r$ 区间内，左括号与右括号数量相等。
2. 满足任意 $i（1 \le i \le r)$，$ 0 \le he[ i ] - he[l - 1]$，表示 $l$ 到 $i$ 区间内，左括号的数量始终大于等于右括号。

对于 2.，我们可以在线段树中记录 $l$ 到 $r$ 的和的最小值。这样，在 2. 时，我们只需要查询 $l$ 到 $r$ 区间内的最小值是否大于等于零，可判断 2. 是否成立。

可是时间复杂度太高了，考虑优化。

在最小值中，小值是有单调性的，们可以使用二分查找。

![](https://cdn.luogu.com.cn/upload/image_hosting/t119dpmj.png)

如图，线段树二分的时候，能分出这种情况（当然也有出题人故意卡你的情况）。

而上图在二分最小值时，后的 ans 将停留在 $3$ 的位置，是 $r = 6$ 时是可行的，所以不对。我们在二分时，一个值需要加上左边所有的 $he$，加上了后，就会如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/tm3rls38.png)

举个例子：如果我们要查询 $4$ 到 $6$ 之间的最小值，需要将 $4$ 到 $6$ 的每个值加上 $1$ 到 $3$ 的和。

在这样改了之后，pushup 就也需要改了，如下：
```cpp
void pushup(int x) {
	tree[x].he = tree[x * 2].he + tree[x * 2 + 1].he;
	tree[x].mn = min(tree[x * 2].mn, tree[x * 2 + 1].mn + tree[x * 2].he);
	tree[x].mx = max(tree[x * 2].mx, tree[x * 2 + 1].mx + tree[x * 2].he);
}
```

在上传最小值和最大值时，右子树的最小值（最大值）应当先加上左子树的和，再和左子树的最小值（最大值）取 $\min(max)$。

好，现在 2. 要求已经可通过二分解决了，所以最后的 ans 就会在 $l$ 到 $r$ 区间内。接下来考虑 1.。

我们的目标是让 $l$ 到 $ans$ 的区间内左括号的数量等于右括号的数量，然而每一个括号都只会产生 $1$ 的贡献。设 $l$ 到 $r$ 的区间内 $he$ 为 $x$，那么在 $r - x$ 到 $r$ 区间内，一定都不会产生 $ans$。所以直接跳过这段区间就行了。直到 $l$ 到 $r$ 的 $he = 0$。

操作2已经顺利的完成了，接下来考虑操作 1。

因为我们是将左括号赋值为 $1$，右括号赋值为 $-1$，所以我们可以直接乘以 $-1$，即可让左括号变为右括号，右括号变为左括号。注意：为了统计最小值，我们可以记录一个最大值，这样乘完 $-1$ 后，最小值变为最大值，最大值变为最小值，非常的方便。

下传懒标记就不用我多说了吧。

### 接下来是大家期待的 AC 代码

```cpp
#include <bits/stdc++.h>
#pragma GCC optsize(2)
#define int long long
#define endl '\n'
using namespace std;

struct node {
	int l, r;
	int he;
	int lbj;
	int mx, mn;
} tree[4000005];
int n, m;
int a[1000005];

void pushup(int x) {
	tree[x].he = tree[x * 2].he + tree[x * 2 + 1].he;
	tree[x].mn = min(tree[x * 2].mn, tree[x * 2 + 1].mn + tree[x * 2].he);
	tree[x].mx = max(tree[x * 2].mx, tree[x * 2 + 1].mx + tree[x * 2].he);
}

void pushdown(int x) {
	if (tree[x].lbj != 1) {
		tree[x * 2].he *= -1;
		tree[x * 2].lbj *= -1;
		tree[x * 2].mn *= -1;
		tree[x * 2].mx *= -1;
		swap(tree[x * 2].mn, tree[x * 2].mx);
		tree[x * 2 + 1].he *= -1;
		tree[x * 2 + 1].lbj *= -1;
		tree[x * 2 + 1].mn *= -1;
		tree[x * 2 + 1].mx *= -1;
		swap(tree[x * 2 + 1].mn, tree[x * 2 + 1].mx);
		tree[x].lbj = 1;
	}
	return;
}

void build(int u, int l, int r) {
	tree[u].l = l, tree[u].r = r, tree[u].lbj = 1;
	int mid = l + r >> 1;
	if (l == r) {
		tree[u].mx = tree[u].mn = tree[u].he = a[l];
		return;
	}
	build(u * 2, l, mid);
	build(u * 2 + 1, mid + 1, r);
	pushup(u);
}

void xg(int v, int l, int r) {
	if (tree[v].l >= l && tree[v].r <= r) {
		tree[v].lbj *= -1;
		tree[v].he *= -1;
		tree[v].mn *= -1;
		tree[v].mx *= -1;
		swap(tree[v].mx, tree[v].mn);
		return;
	}
	pushdown(v);
	int mid = tree[v].l + tree[v].r >> 1;
	if (l <= mid)
		xg(v * 2, l, r);
	if (r > mid)
		xg(v * 2 + 1, l, r);
	pushup(v);
	return;
}

int cxhe(int v, int l, int r) {
	if (tree[v].l >= l && tree[v].r <= r)
		return tree[v].he;
	pushdown(v);
	int ans = 0;
	int mid = tree[v].l + tree[v].r >> 1;
	if (l <= mid)
		ans += cxhe(v * 2, l, r);
	if (r > mid)
		ans += cxhe(v * 2 + 1, l, r);
	pushup(v);
	return ans;
}

int cxmn(int v, int l, int r, int sum) {
	if (tree[v].l >= l && tree[v].r <= r)
		return tree[v].mn + sum;
	pushdown(v);
	int ans = 1145141919810;
	int mid = tree[v].l + tree[v].r >> 1;
	if (l <= mid) {
		ans = min(cxmn(v * 2, l, r, sum), ans);
		sum += cxhe(v * 2, l, r);
	}
	if (mid < r) {
		ans = min(cxmn(v * 2 + 1, l, r, sum), ans);
	}
	return ans;
}


int cx(int x) {
	int l = x, r = n, ans = 1145141919810;
	while (l <= r) {
		int mid = r + l >> 1;
		int xxs = cxmn(1, x, mid, 0);
		if (xxs >= 0)
			l = mid + 1, ans = mid;
		else
			r = mid - 1;
	}
	int aans = 1145141919810;
	while (x <= ans && ans != 1145141919810) {
		int xx = cxhe(1, x, ans);
		if (xx == 0) {
			aans = ans;
			break;
		}
		ans -= xx;
	}
	return (aans == 1145141919810 ? 0 : aans);
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	string k;
	cin >> k;
	for (int i = 0; i < k.size(); i++) {
		a[i + 1] = ((k[i]=='(')?1:-1);
	}
	build(1, 1, n);
	while (m--) {
		int op, x, y;
		cin >> op >> x;
		if (op == 1) {
			cin >> y;
			xg(1, x, y);
		} else {
			cout << cx(x) << endl;
		}
	}
	return 0;
}
```

---


# [蓝桥杯 2021 国 AB] 异或三角

## 题目描述

给定 $T$ 个数 $n_{1}, n_{2}, \cdots, n_{T}$, 对每个 $n_{i}$ 请求出有多少组 $a, b, c$ 满足:

1. $1 \leq a, b, c \leq n_{i}$;

2. $a \oplus b \oplus c=0$ ，其中 $\oplus$ 表示二进制按位异或;

3. 长度为 $a, b, c$ 的三条边能组成一个三角形。

## 说明/提示

对于 $10 \%$ 的评测用例, $T=1,1 \leq n_{i} \leq 200$; 对于 $20 \%$ 的评测用例, $T=1,1 \leq n_{i} \leq 2000$ ；

对于 $50 \%$ 的评测用例, $T=1,1 \leq n_{i} \leq 2^{20}$;

对于 $60 \%$ 的评测用例, $1 \leq T \leq 100000,1 \leq n_{i} \leq 2^{20}$;

对于所有评测用例, $1 \leq T \leq 100000,1 \leq n_{i} \leq 2^{30}$ 。 

蓝桥杯 2021 国赛 A 组 I 题（B 组 J 题）。

## 样例 #1

### 输入

```
2
6
114514```

### 输出

```
6
11223848130```

# 题解

## 作者：chroneZ (赞：18)

考虑数位 dp。下文记 $x_i$ 表示 $x$ 在二进制意义下的第 $i$ 位。

考虑枚举 $a$ 作为最大值，则原题可以视作求满足一些限制的有序数对 $(a, b, c)$ 的数量。

- 对于限制 $a > b$，等价于从高位向低位均有 $b_i = a_i$，直到首次出现 $(a_i, b_i) = (1, 0)$
- 对于 $a > c$ 同上。
- 对于限制 $a < b + c$，由原限制 2 可知 $a = b \oplus c$，$b \oplus c < b + c$ 当且仅当 $\exists (b_i, c_i) = (1, 1)$。
- 对于限制 $a = b \oplus c$，在转移过程中只考虑 $(a_i, b_i, c_i) = (0, 1, 1), (0, 0, 0), (1, 0, 1), (1, 1, 0)$ 四种可能情形即可。

只有满足所有限制的数对会对答案产生贡献。我们用一个二进制数压缩前三个限制的当前状态，记忆化搜索实现 dp，具体细节见代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
constexpr int N = 32;

int a[N]; i64 f[N][8][2];
i64 dfs(int cur, int state, bool fulc){
	if(cur < 0) return state == 7;	// 同时满足所有限制
	if(~f[cur][state][fulc]) return f[cur][state][fulc];
	int dig = fulc ? a[cur] : 1; i64 res = 0;
	for(int k = 0; k <= dig; k++){
		if(k == 0){
			int b = state & 1, c = state >> 1 & 1;
			res += dfs(cur - 1, state, fulc && (k == dig)); // (a_i, b_i, c_i) = (0, 0, 0)
			if(b == 1 && c == 1) res += dfs(cur - 1, state | 4, fulc && (k == dig)); // (a_i, b_i, c_i) = (0, 1, 1)
		}
		if(k == 1){
			res += dfs(cur - 1, state | 1, fulc && (k == dig)); // (a_i, b_i, c_i) = (1, 0, 1)
			res += dfs(cur - 1, state | 2, fulc && (k == dig)); // (a_i, b_i, c_i) = (1, 1, 0)
		}
	}
	return f[cur][state][fulc] = res;
}
void solve(){
	memset(f, -1, sizeof f);
	int n; cin >> n;
	int L = -1;
	while(n) a[++L] = n % 2, n /= 2;
	cout << dfs(L, 0, 1) * 3 << "\n";
}
int main(){
	ios::sync_with_stdio(false); 
	cin.tie(nullptr); cout.tie(nullptr);
	int T = 1;
	cin >> T;
	while(T--)
		solve();
}
```



---

## 作者：DengDuck (赞：5)

似乎还是不能清楚的想出来，思维短板太严重。

首先可以证明 $a,b,c$ 互不相等，原因是边长不可以为 $0$，我们假定 $a=b$，那么 $a\oplus b\oplus c=0$ 的条件是 $c=0$，所以不行。

因此我们可以自由假定 $a$ 是最大值，然后答案再乘上三，因为每种三角形的排列都恰好三种。

然后我们考虑三角形合法性的判定，已知最大值是 $a$，所以条件为 $a<b+c$，转化得 $b\oplus c<b+c$，我们都知道 $b\oplus c\leq b+c$ 是定理，所以只需要保证不相等，那就是进位导致的，所以我们要保证 $b,c$ 存在某一位都是 $1$。

然后数位 DP 就很简单了。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define LF long double
#define pLL pair<LL,LL>
#define pb push_back
//#define fir first
//#define sec second
using namespace std;
//const LL inf;
const LL N=60;
//const LF eps;
//const LL P;
LL T,n,b[N],tot,f[N+5][2][2][2][2];
LL dfs(LL x,LL lim,LL limb,LL limc,LL hav)
{
	if(x==0)return hav;
	if(f[x][lim][limb][limc][hav]!=-1)return f[x][lim][limb][limc][hav];
	LL ans=0;
	for(LL i=0;i<=1;i++)
	for(LL j=0;j<=1;j++)	
	for(LL k=0;k<=1;k++)	
	{
		if(i+j+k!=0&&i+j+k!=2)continue;
		if(lim&&i>b[x])break;
		if(limb&&j>i)break;
		if(limc&&k>i)break;
		ans+=dfs(x-1,lim&&(i==b[x]),limb&&(j==i),limc&&(k==i),hav||(j+k==2));
	}
	return f[x][lim][limb][limc][hav]=ans;
}
LL work(LL x)
{
	tot=0;
	LL ans=0;
	while(x)
	{
		b[++tot]=x%2,x/=2;
	}
	memset(f,-1,sizeof(f));
	return dfs(tot,1,1,1,0)*3ll;
}
int main()
{
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%lld",&n);
		printf("%lld\n",work(n));		
	}

	return 0;
}
//RP++
```

---

## 作者：hxuwna (赞：3)

首先注意到数据范围非常大，所以考虑数位 $dp$。先尝试构造，分析性质。  

首先为了满足性质三，我们先保证 $a<b<c$，所以需要满足 $ a+b>c $。  

再看性质二，我们就从高到低枚举二进制位，于是每位上就有 $(000)$、$(011)$、$(101)$、$(110)$ 这四种三元组情况。  

你就会发现只有 $(110)$ 这种情况会满足性质三，而为了满足 $a<b<c$，我们就会发现只有这种情况能同时满足所有条件：
$$......(000)$$
$$(011)$$
$$......(000,011)$$
$$(101)$$
$$......(000,011,101)$$
$$(110)$$
$$......(000,011,101,110)$$
其中 $...$ 表示可以填任意数量的三元组情况，后面的三元组表示可以填哪些，单独的表示只能填这一个。  
所以我们就把正在构造的一个三元组分为了七种阶段，最后用数位 $dp$ 维护某个阶段的三元组的构造方案数。  
# 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,dp[7][45];
int tw[45],tot,cnt[7];
signed main(){
	ios::sync_with_stdio(0),cin.tie(0);
	dp[5][0]=1,dp[6][0]=4;
	for(int i=1;i<=30;i++){
		dp[0][i]=dp[0][i-1]+dp[1][i-1];
		dp[1][i]=(dp[2][i-1]+dp[3][i-1]);
		dp[2][i]=(dp[2][i-1]+dp[3][i-1])*2;
		dp[3][i]=(dp[4][i-1]+dp[5][i-1]);
		dp[4][i]=(dp[4][i-1]+dp[5][i-1])*3;
		dp[5][i]=dp[6][i-1];
		dp[6][i]=dp[6][i-1]*4;
	}
	int t;cin>>t; 
	while(t--){
		cin>>n;tot=-1;
		int x=n;
		while(x){
			tw[++tot]=x&1;
			x>>=1;
		}
		memset(cnt,0,sizeof(cnt));
		cnt[0]=1;int ans=0;
		for(int i=tot;i>=0;i--){
			if(tw[i]){
				if(i) ans=ans+cnt[0]*(dp[0][i-1]+dp[1][i-1]);
				if(i) ans=ans+cnt[1]*(dp[2][i-1]+dp[3][i-1]);
				if(i) ans=ans+cnt[2]*(dp[2][i-1]+dp[3][i-1]);
				if(i) ans=ans+cnt[3]*(dp[4][i-1]+dp[5][i-1]);
				if(i) ans=ans+cnt[4]*(dp[4][i-1]+dp[5][i-1]);
				if(i) ans=ans+(cnt[5]+cnt[6]+cnt[3]+cnt[4]+cnt[5]+cnt[6])*dp[6][i-1];
				else ans+=cnt[5]+cnt[6]+cnt[3]+cnt[4]+cnt[5]+cnt[6];
				cnt[6]=(cnt[5]+cnt[6])*2;
				cnt[5]=0;
				cnt[4]=(cnt[3]+cnt[4])*2;
				cnt[3]=cnt[1]+cnt[2];
				cnt[2]=cnt[1]+cnt[2];
				cnt[1]=cnt[0];
				cnt[0]=0;
			}else{
				cnt[6]=(cnt[5]+cnt[6])*2;
				cnt[5]=cnt[3]+cnt[4];
				cnt[4]=cnt[3]+cnt[4];
				cnt[3]=0;
				cnt[2]=cnt[1]+cnt[2];
				cnt[1]=0;
				cnt[0]=cnt[0];
			}//暴力分讨
			if(i==0) ans+=cnt[5]+cnt[6];
		}
		cout<<ans*6<<"\n";
	}
	return 0;
}
```
题外话，没想到我还能拿[最优解](https://www.luogu.com.cn/record/224992910)。

---

## 作者：Astraios (赞：3)

改了三次求审核大大放过 qwq

# 题解

[题目传送门](https://www.luogu.com.cn/problem/P8766)

本题是一道数位动态规划题目。

题目并没有规定 $a,b,c$ 相对大小，我们在枚举的时候先令 $a > b$ 和 $a > c$，这样的最后答案就需要乘 $3$。

然后考虑对题目的限制条件进行转化，转化为以下 $4$ 个条件。

1. 等价于从高位到低位，第一次出现不同时，$a$ 的这一位为 $1$，$b$ 的这一位为 $0$。
2. $a > c$ 同理。
3. 能构成三角形，即 $a < b + c$，我们又有 $a \oplus b \oplus c = 0$，即 $a = b \oplus c$，所以要满足 $b \oplus c < b + c$，那么就必须存在一位 $b,c$ 都为 $1$。
4. 对于 $a \oplus b \oplus c = 0$，只需要在枚举的时候只枚举全为 $0$ 和两个 $1$ 一个 $0$ 的情况。

条件是否满足可以用状压的思想来表示，枚举完后判断一下是不是状态为 $7$。

dfs 代码如下

```
int dfs(int pos,bool limit,int sta)
{
	if(!pos) return sta==7;
	if(dp[pos][limit][sta]!=-1) return dp[pos][limit][sta];
	int up=limit?num[pos]:1;
	int ans=0;
	ans+=dfs(pos-1,limit&&0==up,sta);
	if((sta&1)&&(sta>>1&1)) ans+=dfs(pos-1,limit&&0==up,sta|4);
	if(up) ans+=dfs(pos-1,limit,sta|1),ans+=dfs(pos-1,limit,sta|2);
	return dp[pos][limit][sta]=ans;
}
```

特别提醒：

$limit$ 要放在状态里，否则会超时。

对于一般的数位 dp 来说，变量 $limit$ 加不加到状态里都是没有太大的影响的，因为每一位顶到最高位只会被枚举一次。

但是对于这个题而言，相同的 $a$ 是会被枚举多次的，因为你的 $b,c$ 可能会是不同的，所以说必须把 $limit$ 加到状态里。

总代码如下

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int num[1005],ans[1005];
int dp[35][2][8];
int n,a;
#define mod 1000000007
int dfs(int pos,bool limit,int sta)
{
	if(!pos) return sta==7;
	if(dp[pos][limit][sta]!=-1) return dp[pos][limit][sta];
	int up=limit?num[pos]:1;
	int ans=0;
	ans+=dfs(pos-1,limit&&0==up,sta);
	if((sta&1)&&(sta>>1&1)) ans+=dfs(pos-1,limit&&0==up,sta|4);
	if(up) ans+=dfs(pos-1,limit,sta|1),ans+=dfs(pos-1,limit,sta|2);
	return dp[pos][limit][sta]=ans;
}
int work(int x)
{
	int len=0;
	while(x)
	{
		num[++len]=x%2;
		x/=2;
	}
	return dfs(len,1,0);
}
signed main()
{
	cin>>n;
	while(n--)
	{
		memset(dp,-1,sizeof(dp));
		cin>>a;
		cout<<work(a)*3<<endl;
	}
	return 0;
}
```

完结撒花～～～

---

## 作者：wjl1100 (赞：3)

## [原题传送门](https://www.luogu.com.cn/problem/P8766)

## 思路

我们先假设 $a>b>c$，由 $a \oplus b \oplus c=0$ 我们可得 $a=b \oplus c$。又因 $a$，$b$，$c$ 可构成三角形，所以 $a<b+c$，联系 $a=b \oplus c$，所以 $b \oplus c<b+c$，那么 $b$ 和 $c$ 在二进制下一定有一位都为 $1$。所以我们运用状压的思想，将 $a>b$，$b > c$ 以及 $b$ 和 $c$ 在二进制下一定有一位都为 $1$ 化作三种状态判断即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf 0x7f7f7f7f
#define mod 1000000007
using namespace std;
const int maxn = 1e6 + 100;
inline int read() {
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int T , dp[60][2][10] , a[60] , n , pos;
inline int dfs(int nows , int zt , bool flag) {
	if(!nows) return zt == 7;
	if(dp[nows][flag][zt] != -1) return dp[nows][flag][zt];
	int maxx = flag ? a[nows] : 1 , tmp = 0;
	if(maxx >= 0) tmp += dfs(nows - 1 , zt , (flag && a[nows] == 0));
	if(maxx >= 0 && (zt & 1) && (zt >> 1 & 1)) tmp += dfs(nows - 1 , zt | 4 , (flag && a[nows] == 0));
	if(maxx == 1) {
		tmp += dfs(nows - 1 , zt | 2 , (flag && a[nows] == 1));
		tmp += dfs(nows - 1 , zt | 1 , (flag && a[nows] == 1));
	}
	dp[nows][flag][zt] = tmp;
	return tmp;
}
inline int work(int x) {
	pos = 0;
	while(x) {
		a[++pos] = x & 1;
		x >>= 1;
	}
	return dfs(pos , 0 , 1) * 3;
}
inline void solve() {
	memset(dp , -1 , sizeof(dp));
	n = read();
	cout << work(n) << endl;
}
signed main(){
	T = read();
	while(T--) solve();
	return 0;
} 
```

## 注意事项：

这里的 $dp$ 数组一定要开三维，把当前位是否有限制加进去，不然会 T 飞。

---

## 作者：YZren (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8766)

~~一道有难度的数位 DP，感觉比一些紫题还难。~~
# 思路

- 可以发现 $a,b,c$ 没有顺序，所以令 $a>b$ 并且 $a>c$ 最后答案乘三即可。
- 引用状压的思想，用二进制表示状态，其中令 $1$ 表示 $a>b$ 然后 $10$ 表示 $a>c$ 接着 $100$ 表示 $a,b,c$ 构成三角形。
- 其中关于证明 $a,b,c$ 是否可以构成三角形，理由如下：根据三角形性质得 $a<b + c$ 其中 $a$ 是最大的，所以 $a=b \oplus c$ 即 $b \oplus c=b + c$ 易证 $b,c$ 的二进制数至少有一位同为一，所以只要 $b,c$ 至少有一位同为一就是三角形。

# Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define f(i,j,k) for(int i=j;i<=k;i++)
#define F(i,j,k) for(int i=j;i>=k;i--)
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x){
	if(x<0) {x=~(x-1); putchar('-');}
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int T=read(),dp[2][40][8],loc[40],cnt;
inline int dfs(int pos,int vis,int st){
	if(!pos) return st==7;
	if(dp[vis][pos][st]!=-1) return dp[vis][pos][st];
	int nex=vis?loc[pos]:1,res=0;
	res+=dfs(pos-1,vis&&nex==0,st);
	if((st&1)&&(st>>1&1)) res+=dfs(pos-1,vis&&nex==0,st|4);
	if(nex==1) res+=dfs(pos-1,vis,st|1)+dfs(pos-1,vis,st|2);
	return dp[vis][pos][st]=res;
}
inline void get(){
	int x=read(); cnt=0; memset(dp,-1,sizeof(dp));
	while(x) loc[++cnt]=x&1,x>>=1;
	write(dfs(cnt,1,0)*3); puts("");
}
inline void work(){while(T--) get();}
signed main(){work();return !!!!!("YZren");}
```

---

## 作者：Rich1 (赞：1)

## 复述一下题意
给定 $T(T \le 10^5)$ 个 $n(n \le 2^{30})$，求有多少组 $a, b, c$ 满足

- $1 \le a, b, c \le n$；
- $a \oplus b \oplus c = 0$；
- 能构成三角形。

## 思路
~~很明显~~我们得从 $a, b, c$ 中假设一个作为三角形的最长边。

我假设 $a < b + c$ ①，即 $a$ 是最长边。

对于第二个限制条件，可以推出 $a = b \oplus c$ ②，将 ② 代入 ① 得：$b \oplus c < b + c$。因为 $b \oplus c \le b + c$，当且仅当 $b$ & $c = 0$ 时取到等号。

那么我们要做到 $b$ & $c \neq 0$。

综上：
- $a > b$
- $a > c$
- $a = b \oplus c < b + c$

说到处理二进制位，最后求方案数，考虑数位 dp。(没学过推荐你去 [P2657](https://www.luogu.com.cn/problem/P2657) [P2602](https://www.luogu.com.cn/problem/P2602) [P6218](https://www.luogu.com.cn/problem/P6218)）

我们可以这样理解：$a$ 的**任务**是小于 $b + c$，即 $b$ & $c \neq 0$，也就是让 $b$ 和 $c$ 存在一个第 $i$ 位都是 1。$b$ 的**任务**是小于 $a$ ，$c$ 的**任务**也是小于 $a$。我们只要保证 $a \oplus b \oplus c = 0$，那么如果三个任务都完成了，是不是就对答案有贡献了？

## 构思代码

我们的~~大法师~~ dfs 就要维护处理到哪一位（从最高位开始）了，$a, b, c$ 有没有完成任务，有没有数位约束。

然后我们想想 $a$ 的这个 bit 填 0 和 1 的情况：

- $a$ 这一位填 0：
  
  -  $b, c$ 这一位也都填 0：~~很明显~~三个继承上次的状态。
  -  $b, c$ 这一位也都填 1：$a$ 是完成任务了。但如果是因为这一位 $a$ 填 0，$b, c$ 这里填 1，使得 $a \le b$ 或 $a \le c$ 呢（因为你是从最高位开始枚举的）？那可不行。所以必须：
      ```cpp
      if(b 和 c 都完成了小于 a 的任务)
         a 完成任务，递归下一层。
      ```
- $a$ 这一位填 1：
  
  - $b$ 这一位填 0，$c$ 这一位填 1：$b$ 完成了小于 $a$ 的任务。
  - $b$ 这一位填 1，$c$ 这一位填 0：$c$ 完成了小于 $a$ 的任务。

核心代码完成了。

因为我只讨论了 $a < b + c$，还有 $b < a + c$，$c < a + b$ 呢！所以得出来的答案要 $\times 3$。

> 用 $a, b, c$ 组成的有序数对不是有 $(a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)$ 6 种吗？为什么只 $\times 3$？

这是因为我们讨论 $a < b + c$ 就相当于同时讨论了 $(a, b, c), (a, c, b)$ 两种情况，我们只限定了 $a$ 是它们三个中最大的哦。

虚假的 Code：
```cpp
//[蓝桥杯 2021 国 AB] 异或三角
#include <bits/stdc++.h>
using std::cin;
using std::cout;
using std::ios;
using ll = long long;
#define Mem(a, b) memset(a, b, sizeof a)
const int MAXN = 40;
int t, n;
int num[MAXN];
ll dp[MAXN][2][2][2];
ll Dfs(int pos, bool a, bool b, bool c, bool limit) {
    if(pos == 0) return a && b && c;
    if(!limit && dp[pos][a][b][c] != -1)
        return dp[pos][a][b][c];
    int up = limit ? num[pos] : 1;
    ll res = 0;
    for(int i = 0; i <= up; ++i) {
        if(i == 0) {
            res += Dfs(pos - 1, a, b, c, limit && (i == up));
            if(b && c) res += Dfs(pos - 1, true, b, c, limit && (i == up));
        }
        if(i == 1) {
            res += Dfs(pos - 1, a, true, c, limit && (i == up));
            res += Dfs(pos - 1, a, b, true, limit && (i == up));
        }
    }
    return !limit ? dp[pos][a][b][c] = res : res;
}
int main() {
    ios::sync_with_stdio(false), cin.tie(nullptr);
    cin >> t;
    while(t--) {
        cin >> n;
        Mem(dp, -1);
        int len = 0;
        for(; n; n >>= 1)  num[++len] = (n & 1);
        cout << Dfs(len, false, false, false, true) * 3 << '\n';
    }
    return 0;
}
```
（数位约束和前导 0 我**~~暂时~~**习惯不写在 dp 状态里）

~~你猜我为啥一点注释都没写，因为这篇代码虽然正确性没问题，但是会 T ！！！~~

然后找了半天原因，发现数位约束的 `limit` 要放在 dp 状态里面。因为上一篇用的是 dp[pos][a][b][c]，当不处于数位约束状态时才会启用记忆化。但是二进制很容易受到数位约束，容易卡成爆搜。而接下来的 dp[pos][a][b][c][limit]，不管是否存在数位约束，都会进行记忆化操作。很明显效率高很多。

大家做数位 dp 的时候就把判断数位约束和前导 0 ~~一股脑~~塞进记忆化数组即可，空间 4 倍可以承受的。

说句题外话，大家写任何模板的时候一定要估计好自己算法的性能啊！包括但不限于能不能记忆化，潜在的拷贝，函数调用的开销，还有初始化。

~~我现在习惯把数位约束和前导 0 写在 dp 状态里~~

## Code
```c++
//[蓝桥杯 2021 国 AB] 异或三角
#include <bits/stdc++.h>
using std::cin; // 别把 std 全引进来了
using std::cout; // 用啥 using 啥，避免 y1 y0 size 之类的直接让你考场上爆 0
// 尤其是 y0，windows 下没问题，linux 下 CE，我就是因为这个痛失 one hundred
using std::ios;
using ll = long long;
#define Mem(a, b) memset(a, b, sizeof a)
const int MAXN = 40;
int t, n;
int num[MAXN]; // 将 n 拆开后的数组
ll dp[MAXN][2][2][2][2]; // 记忆化数组
ll Dfs(int pos, bool a, bool b, bool c, bool limit) { // 维护处理到哪一位了，a, b, c有没有完成任务，数位约束
    if(pos == 0) return a && b && c;
    if(dp[pos][a][b][c][limit] != -1) return dp[pos][a][b][c][limit];
    int up = limit ? num[pos] : 1; // 把上限算出来
    ll res = 0;
    for(int i = 0; i <= up; ++i) { // 枚举 a 这一位填什么
        if(i == 0) { // 填 0
            res += Dfs(pos - 1, a, b, c, limit && (i == up)); // 继承上次的状态
            if(b && c) // 确定 b, c 都比 a 小了
                res += Dfs(pos - 1, true, b, c, limit && (i == up)); // b, c 这一位才都填 1
        }
        if(i == 1) { // 填 1
            res += Dfs(pos - 1, a, true, c, limit && (i == up)); // b 这一位为 0，c 为 1
            res += Dfs(pos - 1, a, b, true, limit && (i == up)); // b 这一位为 1，c 为 0
        }
    }
    return dp[pos][a][b][c][limit] = res;
}
int main() {
    ios::sync_with_stdio(false), cin.tie(nullptr);
    cin >> t;
    while(t--) {
        cin >> n;
        Mem(dp, -1); // 多测不清空，亲人两行泪
        // 每 dfs 一次都要清空啊！！！因为每一次的 num[pos] 不一样，导致枚举的数位不一样
        int len = 0;
        for(; n; n >>= 1) // 拆位
            num[++len] = (n & 1);
        cout << Dfs(len, false, false, false, true) * 3 << '\n';
        // 刚开始都没完成任务；第一个数肯定是受到约束的噻，所以打上一个 limit
    }
    return 0;
}
```

---

## 作者：ask_silently (赞：1)

## [原题传送门](https://www.luogu.com.cn/problem/P8766)


---

# 思路分析

根据 ~~题单标签~~ 数据范围以及按位异或运算就知道数位 DP 绝对准。

分析题目所给条件：

第一个条件给出了 $a,b,c \le n$，即给出**上限与枚举的范围**。

第二个条件给出了 $a \oplus b \oplus c=0$。我们知道只有当前位相同的二进制数字异或才是 $0$，所以由此得知每一位只有两种情况，即**当前位 $a,b,c$ 都选 $0$，或 $a,b,c$ 中，任意两个数选择 $1$**，将此操作记为操作二。同时又因为三个数字每个都需要选择一次 $1$，所以需要有两次操作二。所以 $a,b,c$ 中有两数首位 $1$ 的位置不同，另外一数则在两数只有一个 $1$ 的基础上有两个 $1$。所以**三数互不相同**。

第三个条件给出 $a,b,c$ 能构成三角形。由三角形的性质**得任意两数之和大于第三数**。由于我们不知道哪一个数最大，不妨设 $a>b>c$，则 $b+c>a$。考虑第二个条件中说的两种情况，当前位三位数都选 $0$ 的时候，$b+c=a$。如果 $a,b$ 或 $a,c$ 选择 $1$ 的话，同样 $b+c=a$。所以**必须存在一次 $b,c$ 选择 $1$ 而 $a$ 选择 $0$**，这次操作也必须在选择 $a,b$ 与 $a,c$ 的操作后，保证 $a>b>c$。同样的，选择 $a,c$ 操作也必须要在选择 $a,b$ 操作后面，保证 $b>c$。

所以我们对于每一位就可以得到四种状态：

- $a,b,c$ 在之前包括现在的二进制位都选 $0$。
- $a,b$ 选过了 $1$。
- $a,b$ 和 $a,c$ 选过了 $1$。
- $a,b$ 和 $a,c$ 与 $b,c$ 都选过 $1$。

此时，我们用过了第二个与第三个条件，第一个条件又该怎么用呢？

我们发现对于 $a$ 来说，**若之前的二进制位选择的数字与 $n$ 相等的话，若 $n$ 的当前位为 $0$，则当前位 $a$ 不能选 $1$**，否则就比 $n$ 大了。所以我们可以将 $dp$ 增加一维，分两种情况：

- $a$ 在之前都与 $n$ 相等。
- $a$ 在之前有一次 $a<n$。

所以我们就可以得到 $dp$ 的状态，$dp_{i,j,k}$ 表示在第 $i$ 位二进制位；$a$ 的状态为 $j$，$j=1$ 的时候代表 $a=n$，$j=2$ 的时候代表 $a<n$；$k$ 代表四种状态。

状态转移方程在代码注释里啦。

因为我们考虑的是 $a<b<c$，所以**最后答案应该乘上 $a,b,c$ 的全排列个数**即 $6$。

所以最后的答案就是：

$$(f_{idx,0,4}+f_{idx,1,4}) \times 6$$

注意加吐槽：三步运算符优先级真低，用的时候一定要加括号，因为这个问题调了我一个半小时。

# AcCode


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N=35;

int T,n;

int f[N][5][10],now[N];
//一维为当前位数
//二维为 a 是否为 n  （1 为是  2 为不是） 
//三维为当前选择状态
//1：abc 以前及现在都选择的是 0
//2：ab 已经选择了 1   第一次只能 ab 选 1
//3：ab ac 已经选择了 1   第二次只能 ab ac 选 1
//4：ab ac bc 已经选择了 1  需要有一次 bc 选 1 

inline int read(){
	int t=0,f=1;
	register char c=getchar();
	while (c<48||c>57) f=(c=='-')?(-1):(f),c=getchar();
	while (c>=48&&c<=57)t=(t<<1)+(t<<3)+(c^48),c=getchar();
	return f*t;
}

void solve(){
	memset(f,0,sizeof(f));
	memset(now,0,sizeof(now));
	int idx=0;
	while(n){
		now[++idx]=n&1;
		n>>=1;
	}
	f[idx+1][1][1]=1;
	for(int i=idx;i>=1;i--){
		f[i][1][1]=(now[i]==1)?(0):(f[i+1][1][1]); 
		//若 a=n 时： 
		//当 n 的当前位为 1 时，a 当前位也只能选 1，f[i][1][1]就是 0 了
		//当 n 的当前位为 0 时，a 当前位也只能选 1，f[i][1][1]就从前一个状态转移 
		f[i][1][2]=(now[i]==1)?(f[i+1][1][2]+f[i+1][1][1]):(f[i+1][1][2]); 
		//此时 a 一定选过了 1
		//当 n 的当前位为 1 时,两种状态都只能选 ab 
		//当 n 的当前位为 0 时,只能用 f[i+1][1][2] 的状态选择 000 
		f[i][1][3]=(now[i]==1)?(f[i+1][1][2]+f[i+1][1][3]*2):(f[i+1][1][3]);
		//当 n 的当前位为 1 时,f[i+1][1][2]能选 ac,f[i-1][i][3]可以选 ab,ac 
		//当 n 的当前位为 0 时,只能用 f[i+1][1][3] 的状态选择 000
		f[i][1][4]=(now[i]==1)?(f[i+1][1][4]*2):(f[i+1][1][4]*2+f[i+1][1][3]);
		//当 n 的当前位为 1 时,f[i+1][1][3]不能选 bc,只能用f[i+1][i][4]选 ab,ac 
		//当 n 的当前位为 0 时,可以用 f[i+1][1][3] 的状态选择 bc
		//也可以用f[i+1][1][4]选择 bc,000
		f[i][0][1]=1;
		//直接转移就行 
		f[i][0][2]=((now[i]==1)?(f[i+1][1][2]):(0))+f[i+1][0][1]+f[i+1][0][2]*2;
		//如果 n 的当前值为 1,我们可以直接从f[i+1][1][2]转移
		//因为f[i][0]<n, 所以当前位只能填 0
		//然后就可以从f[i+1][0][1]转移,选 ab
		//也可以从f[i+1][0][2]转移,选 ab,000
		//因为f[i+1][0] 一定比 n 小,所以即使 n 的当前位为 1,我们也可以选择 1
		//不用担心选完之后比 n 大或等于 n 
		f[i][0][3]=((now[i]==1)?(f[i+1][1][3]):(0))+f[i+1][0][2]+f[i+1][0][3]*3;
		f[i][0][4]=((now[i]==1)?(f[i+1][1][4]*2+f[i+1][1][3]):(0))+f[i+1][0][3]+f[i+1][0][4]*4; 
		//如果当前位为 1
		//那么要想小于 n,只需要在f[i+1][1][4]的基础上选 000,bc
		//或在f[i+1][1][3]的基础上选 bc 
	}
	cout<<f[1][1][4]*6+f[1][0][4]*6<<endl;
}

signed main(){
	T=read();
	while(T--){
		n=read();
		solve();
	}
	return 0;
}

```

---

## 作者：meyi (赞：0)

不妨设 $a,b\le c = a\oplus b \le n$，那么能构成三角形等价于 $a\oplus b<a+b$，考虑到异或相当于二进制下的不进位加法，则其又等价于 $a\ \&\  b\ne 0$，其中 $\&$ 表示按位与。

考虑数位 dp 求出答案，则需要考虑的条件有三个：

- $a,b\le c$

发现唯一不合法的情况是 $a,b$ 在某一位上均为 $1$ 且 $a$ 或 $b$ 之前的位都和 $c$ 相等，使用两个 `bool` 分别记录 $a$ 和 $b$ 是否已经存在一位比 $c$ 小即可。

- $c\le n$

经典的数位 dp 求上限，使用一个 `bool` 记录 $c$ 是否已经存在一位比 $n$ 小，若其值为 `false` 则 $a$ 和 $b$ 当前位必须填一样的数。

- $a\ \&\  b\ne 0$

最容易判断的条件，只需要使用一个 `bool` 记录 $a$ 和 $b$ 是否在至少一位上均为 $1$ 即可。

注意到答案是有序三元组，而我们求出的是 $(*,*,c)$，可以变换成 $(*,c,*)$ 和 $(c,*,*)$，故答案需要乘上一个常数 $3$。

时间复杂度 $O(T\log n\times 2^S)$，其中 $S$ 为记录信息的变量数，在笔者的实现中为 $4$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
//#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops")
#define ALL(v) v.begin(),v.end()
#define For(i,_) for(int i=0,i##end=_;i<i##end;++i) // [0,_)
#define FOR(i,_,__) for(int i=_,i##end=__;i<i##end;++i) // [_,__)
#define Rep(i,_) for(int i=(_)-1;i>=0;--i) // [0,_)
#define REP(i,_,__) for(int i=(__)-1,i##end=_;i>=i##end;--i) // [_,__)
typedef long long ll;
typedef unsigned long long ull;
#define V vector
#define pb push_back
#define pf push_front
#define qb pop_back
#define qf pop_front
#define eb emplace_back
typedef pair<int,int> pii;
typedef pair<ll,int> pli;
#define fi first
#define se second
const int dir[4][2]={{-1,0},{0,1},{1,0},{0,-1}},inf=0x3f3f3f3f,mod=1e9+7;
const ll infl=0x3f3f3f3f3f3f3f3fll;
template<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,1:0;}
template<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,1:0;}
int init=[](){return cin.tie(nullptr)->sync_with_stdio(false),0;}();
ll ans[30][2][2][2][2];
int main(){
	int t_case=1;
	scanf("%d",&t_case);
	while(t_case--){
		int n;
		scanf("%d",&n);
		V<int>d;
		for(int m=n;m;m>>=1)d.pb(m&1);
		reverse(ALL(d));
		memset(ans,-1,d.size()<<7);
		function<ll(int,bool,bool,bool,bool)>dfs=[&](int p,bool f,bool la,bool lb,bool tc)->ll{
			if(p==d.size())return f&&la&&lb;
			ll &x=ans[p][f][la][lb][tc];
			if(~x)return x;
			x=0;
			for(int i:{0,1})for(int j:{0,1})if(!tc||(i^j)<=d[p]){
				if((!la||!lb)&&i&&j)continue;
				x+=dfs(p+1,f||(i&&j),la||i<j,lb||j<i,tc&&(i^j)==d[p]);
			}
			return x;
		};
		printf("%lld\n",dfs(0,0,0,0,1)*3);
	}
	return 0;
}
/*
a,b,c<=n
a^b=c<a+b

sum a=1~n sum b=1~n [max(a,b)<=(a^b)<=n && (a&b)]
*/
```

---


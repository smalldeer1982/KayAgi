# [蓝桥杯 2025 省 A 第二场] 交互

## 题目描述

小蓝正在做一道交互题。有一个未知的下标从 $1$ 到 $m$ 的数组 $a$，小蓝每次可以进行一次询问 $(l, r, p, q)$，然后交互程序会返回 $ans$ 满足 $\min\limits_{l \leq x \leq r} a[x] - \max\limits_{p \leq y \leq q} a[y] \geq ans$。但小蓝很快就发现，因为 $ans$ 并不是精确的值，所以他永远也无法得到实际的数组元素的值。

给定小蓝的几次询问和交互程序的返回值，请你帮他求出 $\max\limits_{1 \leq x \leq m} a[x] - \min\limits_{1 \leq y \leq m} a[y]$ 的可能的最小值。

## 说明/提示

### 样例说明

- 对于样例 $1$，$a_1 - a_2 \geq 2$，$\min(a_1, a_2) - \max(a_3, a_4) \geq 2$。所以 $a_1 - a_3 \geq 4$，所以 $a_i$ 之间差值的最大值不会小于 $4$。
- 对于样例 $2$，$a_1 - a_2 \geq 1$，$a_2 - a_1 \geq 1$，这种情况显然是无解的。

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$m \leq 300$；
- 对于所有评测用例，$1 \leq n \leq 500$，$1 \leq m \leq 10000$，$-100000 \leq ans_i \leq 100000$，$1 \leq l_i, r_i, p_i, q_i \leq m$，$0 \leq q_i - p_i < 100$，$0 \leq r_i - l_i < 100$。

## 样例 #1

### 输入

```
2 4
1 1 2 2 2
1 2 3 4 2
```

### 输出

```
4```

## 样例 #2

### 输入

```
2 2
1 1 2 2 1
2 2 1 1 1```

### 输出

```
No Solution```

# 题解

## 作者：jinfanhao (赞：1)

这题从标签中便可以看出是差分约束。\
但是差分约束都有一个不等式方程组，怎么得来呢？\
从文中可知 $\min\limits_{l \leq x \leq r} a_{x} - \max\limits_{p \leq y \leq q} a_{y} \geq ans$。\
我们可以对其两边同时取相反数，但是要记得变号，别跑成最长路了。$\max\limits_{p \leq y \leq q} a_{y} - \min\limits_{l \leq x \leq r} a_{x}\leq - ans$。\
然后移项把 $\min\limits_{l \leq x \leq r} a_{x}$ 移到右边去，便有 $\max\limits_{p \leq y \leq q} a_{y} \leq \min\limits_{l \leq x \leq r} a_{x} - ans$。\
这便是差分约束的约束条件。\
然后，因为他们是两个区间，所以便有 $(q-p+1)\times(r-l+1)$，但是很明显空间与时间双重方面不允许我们这样做，所以便可以建立一个虚拟源点使两个区间之间汇聚在一个点上，相当于中转点，这样就只需要 $q - p + 1 + r - l + 1$ 条边，快上不少。\
但是，万一出现了几个区间互相不连通的情况怎么办呢？\
可以考虑超级源点，把每个点都与超级源点连一条单向边，起点设为超级源点。\
最后，算结果时只要取前 $n$ 个的最小值与最大之就好了，因为排在后面的是虚拟源点。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+1,INF=1e15,M=1e7;
int n,m,opt,u,v,dist[N],in[N],cnt,maxx=LONG_LONG_MIN,minx=LONG_LONG_MAX;
bool ok[N];
struct edge{
	int v,w;
};
vector<edge> g[N];
bool spfa(){
	queue<int> q;
	for(int i=1; i<=n+m; ++i){
		dist[i]=INF;
	}
	ok[0]=true;
	q.push(0);
	dist[0]=0;
	while(q.size()){
		++cnt;
		if(cnt==M)return true;
		int now=q.front();
		ok[now]=false;
		q.pop();
		for(int i=0; i<g[now].size(); ++i){
			int v=g[now][i].v,w=g[now][i].w;
			if(dist[now]+w<dist[v]){
				dist[v]=dist[now]+w;
				if(!ok[v]){
					ok[v]=true;
					++in[v];
					if(in[v]>=n+m)return true;
					q.push(v);
				}
			}
		}
	}
	return false;
}
signed main(){
    scanf("%lld%lld",&m,&n);
    for(int i=1; i<=m; ++i){
    	int l,r,p,q,ans; 
        scanf("%lld%lld%lld%lld%lld",&l,&r,&p,&q,&ans);
        for(int j=l; j<=r; ++j)g[j].push_back({n+i,0}); 
        for(int j=p; j<=q; ++j)g[n+i].push_back({j,-ans}); 
    }
    for(int i=1; i<=n; ++i)g[0].push_back({i,0});
    if(spfa())printf("No Solution");	
    else{
		for(int i=1; i<=n; ++i){
			maxx=max(maxx,dist[i]);
			minx=min(minx,dist[i]);
		}
		printf("%lld",maxx-minx);
	}
    return 0;
}
```

---

## 作者：Yangxixuan (赞：1)

题目传送门：[传送门](https://www.luogu.com.cn/problem/P12348)

阅读前置知识：差分约束

## 思路
题目中给我们的形式是 $\min\limits_{l\le x\le r}-\max\limits_{p\le x\le q}\ge ans$，我们将这一形式移项，就可以得到 $\max\limits_{p\le x\le q}\le\min\limits_{l\le x\le r}-ans$，满足差分约束的基本形式。

即从 $\min\limits_{l\le x\le r}$ 向 $\max\limits_{p\le x\le q}$ 连一条长度为 $-ans$ 的边。

区间向区间连边，可以暴力把区间 $[l,r]$ 和区间 $[p,q]$ 内的每一个点都互相连边，连边的复杂度为 $O((r-l+1)\times (q-p+1))$，总时间复杂度为 $O(nm(r-l+1)\times (q-p+1))$ 在这道题的数据下是过不了的。~~本蒟蒻一开始就用的这种写法，结果——TLE~~。

因此考虑怎么优化，区间向区间连边不好连，我们就可以将其转化为区间向点连边，由此可以想到分层图的思想。在每次连边的时候，我们建设一个中点 $k$，先将区间 $[l,r]$ 与中点 $k$ 连接权值为 $-ans$ 的边，再将中点 $k$ 与区间 $[p,q]$ 连接权值为 $0$ 的边。这样总复杂度就会缩小至 $O(nm(r-l+1+q-p+1))$，差不多就可以过了。
## code
```cpp
#include <cstdio>
#include <iostream>
#include <queue>
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x*f;
} //快读
const int MAXN=3e6+5;
int n,m,head[MAXN],tot=0,cnt[MAXN],dis[MAXN],maxx,minn;
struct Edge{
	int to,next,w;
}e[MAXN]; //链式前向星存图
inline void add(int u,int v,int w){
	e[++tot].to=v;
	e[tot].w=w;
	e[tot].next=head[u];
	head[u]=tot;
}
bool spfa(){
	queue<int> q;
	for(int i=1;i<=n+m;i++){
		q.push(i);
		cnt[i]++;
	}
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=e[i].next){
			int v=e[i].to,w=e[i].w;
			if(dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;
				q.push(v);
				cnt[v]++;
				if(cnt[v]>m+n) return false;
			}
		}
	}
	return true;
}
int main(){
	m=read(),n=read();
	for(int i=1;i<=m;i++){
		int l=read(),r=read(),p=read(),q=read(),w=read();
		for(int j=l;j<=r;j++) add(j,n+i,-w);
		for(int j=p;j<=q;j++) add(n+i,j,0); //加边
	}
	if(spfa()){
		maxx=dis[1],minn=dis[1];
		for(int i=2;i<=n+m;i++){
			maxx=max(maxx,dis[i]);
			minn=min(minn,dis[i]);
		}
		printf("%d",maxx-minn);
	}
	else printf("No Solution");
	return 0;
}
```

---

## 作者：koukilee (赞：1)

阅读前置知识点：差分约束。

思路：

我们将 $\min\limits_{l \leq x \leq r} a[x] - \max\limits_{p \leq y \leq q} a[y] \geq ans$ 的限制移下项。

变成了 $\max \limits_{p\le y\le q}\le \min \limits_{l\le x\le r} -\ ans$。这是差分约束的标准形式。

表示 $\min \limits_{l\le x\le r}$ 向 $\max \limits_{p\le y\le q}$ 连一条长度为 $-ans$ 的边。

但是区间向区间连边不太好实现，我们考虑能不能拆开？

因为一个区间的**最小值**减去 $ans$ 大于另一个区间的**最大值**，那么易证这个区间的每一个值减去 $ans$ 都会大于另一个区间的每一个值。

所以可以直接将 $[l, r]$ 中的点向 $[p, q]$ 连长度为 $-a$ 的边，以 $O((r - l + 1)\times (q - p + 1))$ 的复杂度暴力连边。

最后跑差分约束，同时跑一个最短路。

这里因为 $0\le r - l, q - p\le 100$。所以建造的边数最大为 $O(n\times 100^2)$ 的。

总复杂度按理来说是 $O(mn\times 100^2)$ 的。

因为是差分约束，所以这个题不会卡 spfa。并且这样暴力连边还跑的意外的快，被卡之前只用了 200ms 不到（。

****

但是看到这个连边方式？是不是想到了[这个](https://www.luogu.com.cn/problem/P6348)？

没错，就是标准的线段树优化建图！

把第二维放在树上，那么建边的复杂度变成 $O(\log(r - l + 1) \log (q - p + 1))$。

在被卡之前最大点跑了 30ms 左右（（。

理论上复杂度达到了 $O(100mn)$，但是非常遗憾的是会多出 $2\times m\log m$ 个线段树上的点，所以就不能过。

我们采用一种**虚点**的做法，将 $[l, r]$ 中的点连入一个虚点，虚点连入 $[p,q]$ 中的点。

这样我们也只需要连 $(r - l + 1) + (q - p + 1)$ 级别的边，只需要额外新增 $m$ 个点，常数更小。

总复杂度就能过，比较极限。

```c++
i64 n, m, dis[MAXN], d[MAXN], ans;
bool vis[MAXN];
std::vector <std::pair <i64, i64> > G[MAXN];
std::queue <i64> p;

inline i64 spfa () noexcept {
	__builtin_memset (dis, 0x3f, sizeof (dis));
	for (i32 i = 1; i <= n + m; i++)
		G[0].push_back ({i, 0});
	
	p.push (0), vis[0] = 1, dis[0] = 0;
	
	while (!p.empty ()) {
		i64 nex = p.front (); p.pop ();
		vis[nex] = 0; ans = std::min (ans, dis[nex]);
		
		for (auto it : G[nex]) {
			if (dis[nex] + it.second < dis[it.first]) {
				dis[it.first] = dis[nex] + it.second;
				
				if (!vis[it.first]) {
					vis[it.first] = 1; p.push (it.first), d[it.first] ++;
					if (d[it.first] > n )
						return 1;
				}
			}
		}
	}
	
	return 0;
}

int main() noexcept	{
	read (m, n); 

	for (i32 i = 1; i <= m; i++) {
		i64 p, q, L, R, a; read (L, R, p, q, a);
		for (i32 j = L; j <= R; j++)
			G[j].push_back ({i + n, -a});
		for (i32 j = p; j <= q; j++)
			G[i + n].push_back ({j, -a});
	}
	
	if (spfa ()) puts ("No Solution");
	else put (-ans / 2); /*贡献计算了两次，记得除二*/
    fwrite(obuf,p3-obuf,1,stdout);
    return 0;
}
```

---

## 作者：Little_Cart (赞：1)

### 前言

无内鬼，来点差分约束。

### 思路

一眼差分约束（或者流），但是流好像不太行，那还是差分约束吧。

注意到 $\min\limits_{l \leq x \leq r} a[x] - \max\limits_{p \leq y \leq q} a[y] \geq ans$ 可以转换为 $\max \limits_{p\le y\le q} a[y] \le \min \limits_{l\le x\le r} a[x] - ans$，这个形式简直就是差分约束板子。

直接暴力将 $[l,r]$ 中的点向 $[p,q]$ 连长度为 $-ans$ 的边的话，边数是 $O(n\times (r-l+1)\times(q-p+1))$ 复杂度的，又因为 $0\le r-l,q-p\le 100$，所以边数是 $O(n\times 100^2)$ 复杂度的，总复杂度达到 $O(mn\times 100^2)$，不太能过。

注意到我们可以在每次连边时建立一个中继点，先将 $[l,r]$ 中的点向这个中继点连长度为 $-ans$ 的边，再将这个中继点向 $[p,q]$ 连长度为 $0$ 的边，边数会缩小至 $O(n\times (r-l+1+q-p+1))$ 复杂度，即 $O(n\times 200)$，总复杂度为 $O(mn\times 200)$，又因为不太能跑的很满，所以可以过。

### 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int,int>
#define fi first
#define se second
#define mkp make_pair
const int N=300024;
int t,n,m,tot;
vector<PII> e[N];
int dis[N],cnt[N];
queue<int> q;
bool spfa(){
    while(!q.empty()){
        q.pop();
    }
    for(int i=1;i<=n+m;i++){
        q.push(i);
    }
    while(!q.empty()){
        tot++;
        int u=q.front();
        q.pop();
        if(cnt[u]>=m+n+2||tot>10000000){
            return 0;
        }
        cnt[u]++;
        for(PII tp:e[u]){
            int v=tp.fi,w=tp.se;
            if(dis[u]+w<dis[v]){
                dis[v]=dis[u]+w;
                q.push(v);
            }
        }
    }
    return 1;
}
signed main(){
    cin>>m>>n;
    for(int i=1;i<=m;i++){
        int l,r,x,y,w;
        cin>>l>>r>>x>>y>>w;
        for(int j=l;j<=r;j++){
        	e[j].push_back(mkp(n+i,-w));
		}
		for(int j=x;j<=y;j++){
        	e[n+i].push_back(mkp(j,0));
		}
    }
    if(spfa()){
    	int mx=dis[1],mn=dis[1];
    	for(int i=2;i<=n+m;i++){
    		mx=max(mx,dis[i]);
    		mn=min(mn,dis[i]);
		}
		cout<<mx-mn;
    }
    else{
        cout<<"No Solution";
    }
}
```

---

## 作者：Sunset_afterglow (赞：0)

我们班的首 A，写篇 Tj 纪念一下，这题我认为建虚点应该是过不了的，毕竟时间复杂度是 $O((n + m)((r-l+1)m))$，也就是 $2.9\times10^{10}$，居然过了，一点都不卡，所以我也不想优化了。
# 思路
我们观察一下式子 $\min_{l\le x\le r}a_x - \max_{p \le y \le q} a_y\ge ans$，想必大家一定是看完了标签吧，[差分约束](https://www.luogu.com.cn/problem/P5960)，感觉如果你刚学就不会来做这题，如果你学过，那你就一眼秒了，我们可以发现这是一个板子，区间与区间连边，经典的线段树优化建图，如果你想认真学习线段树优化建图的话就去看别的题解吧，我不会讲，也可以说是我太菜了，不想写。

这里发现如果 $\min_{l\le x\le r}a_x - \max_{p \le y \le q} a_y\ge ans$，那么 $[l ,r]$ 中的所有数都比 $[p ,q]$ 中的数大 $ans$ 以上，我们可以每次连边建一个虚点 $d$，设其值为 $k$，则 $\forall l\le x\le r \cap p\le y\le q,k - a_x \le -ans \cap a_y - k\le 0$，也就是 `add(x ,d ,-ans),add(k ,y ,0)`，我们可以直接暴力枚举 $x ,y$，然后将虚点直接建到原序列后面，跑一遍 SPFA，求最短路，此时的 $dist$ 就是 $a$ 的值，没有什么细节我就直接放代码了，硬要说就是判负环时最大更新数其实是 $n + m - 1$。
# 代码
## 链式前向星实现
[链式前向星实现](https://www.luogu.com.cn/record/229346431)，最慢的点是 1.90ms，代码如下
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read() {
	int x = 0 ,f = 1;
	char ch = getchar();
	while('0' > ch || ch > '9') {
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while('0' <= ch && ch <= '9') {
		x = (x << 3) + (x << 1) + (ch & 15);
		ch = getchar();
	}
	return x * f;
}
const int N = 5e4 + 5;
int n ,m;
bool flag[N];
queue<int>que;
int dist[N] ,cnt[N] ,head[4 * N] ,cntt;
struct edge {
	int to;
	int next;
	int dis;
}edge[4 * N];
inline void add(int x ,int y ,int z) {
	edge[++ cntt].to = y;
	edge[cntt].dis = z;
	edge[cntt].next = head[x];
	head[x] = cntt;
  return ;
}
void Spfa() {
  memset(dist ,0x3f ,sizeof dist);
	memset(flag ,0 ,sizeof flag);
  memset(cnt ,0 ,sizeof cnt);
	for(int i = 1;i <= n + m;++ i)
		add(0 ,i ,0);
	while(!que.empty())que.pop();
	que.push(0);
	dist[0] = 0;
	while(!que.empty()){
		int u = que.front();
		flag[u] = 0;
		que.pop();
   for(int xt = head[u];xt;xt = edge[xt].next) {
      pair<int ,int> i = make_pair(edge[xt].to ,edge[xt].dis);
			if(dist[i.first] > dist[u] + i.second) {
				dist[i.first] = dist[u] + i.second;
        cnt[i.first] = cnt[u] + 1;
        if(cnt[i.first] >= n + m) {
          cout << "No Solution";
          return ;
        }
				if(!flag[i.first]) {
					flag[i.first] = true;
					que.push(i.first);
				}
			}
		}
	}
  int answer = LLONG_MAX ,maxx = LLONG_MIN ,minn = LLONG_MAX;
	for(int i = 1;i <= m;++ i) {
    maxx = max(maxx ,dist[i]);
    minn = min(minn ,dist[n + i]);
  }
  cout << maxx - minn;
	return ;
}
signed main() {
  m = read() ,n = read();
  for(int i = 1 ,u ,v ,l ,r ,w;i <= m;++ i) {
    u = read() ,v = read() ,l = read() ,r = read() ,w = read();
    for(int j =  u;j <= v;++ j) add(j ,n + i ,-w);
    for(int j =  l;j <= r;++ j) add(n + i ,j ,0);
  }
  Spfa();
  return 0;
}
```

## 邻接表实现
[邻接表实现](https://www.luogu.com.cn/record/229346962)，最慢的点 1.09ms，代码如下。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read() {
	int x = 0 ,f = 1;
	char ch = getchar();
	while('0' > ch || ch > '9') {
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while('0' <= ch && ch <= '9') {
		x = (x << 3) + (x << 1) + (ch & 15);
		ch = getchar();
	}
	return x * f;
}
const int N = 5e4 + 5;
int n ,m;
bool flag[N];
queue<int>que;
int dist[N] ,cnt[N];
vector<pair<int ,int> >vt[2 * N];
void Spfa() {
  memset(dist ,0x3f ,sizeof dist);
	memset(flag ,0 ,sizeof flag);
  memset(cnt ,0 ,sizeof cnt);
	for(int i = 1;i <= n + m;++ i)
		vt[0].push_back(make_pair(i ,0));
	while(!que.empty())que.pop();
	que.push(0);
	dist[0] = 0;
	while(!que.empty()){
		int u = que.front();
		flag[u] = 0;
		que.pop();
		for(auto i: vt[u]) {
			if(dist[i.first] > dist[u] + i.second) {
				dist[i.first] = dist[u] + i.second;
        cnt[i.first] = cnt[u] + 1;
        if(cnt[i.first] >= n + m + 1) {
          cout << "No Solution";
          return ;
        }
				if(!flag[i.first]) {
					flag[i.first] = true;
					que.push(i.first);
				}
			}
		}
	}
  int answer = LLONG_MAX ,maxx = LLONG_MIN ,minn = LLONG_MAX;
	for(int i = 1;i <= n;++ i) {
    maxx = max(maxx ,dist[i]);
    minn = min(minn ,dist[i]);
  }
  cout << maxx - minn;
	return ;
}
signed main() {
  m = read() ,n = read();
  for(int i = 1 ,u ,v ,l ,r ,w;i <= m;++ i) {
    u = read() ,v = read() ,l = read() ,r = read() ,w = read();
    for(int j =  u;j <= v;++ j) vt[j].push_back(make_pair(n + i ,-w));
    for(int j =  l;j <= r;++ j) vt[n + i].push_back(make_pair(j ,0));
  }
  Spfa();
  return 0;
}
```

---

## 作者：stripe_python (赞：0)

本题解摘自[差分约束复习笔记](https://www.luogu.com.cn/article/9azadz0v)。

首先差分约束系统的标准形式为 $x_i-x_j \le c$，题里给的约束长的就很像标准形式。考虑一下有什么性质。既然 $\min_{l\le x\le r} a_x-\max_{p \le y \le q} a_y \ge ans$，那么对于一个更大的 $a_x$ 和一个更小的 $a_y$，显然 $a_x-a_y \ge ans$。所以一个自然的想法是直接枚举区间中的点一一连边。可以获得 [90pts](https://www.luogu.com.cn/record/219627043) 的高分。

这样的边数有 $O(nk^2)$ 条，其中 $n\le500, k\le100$。我们借鉴一下线段树优化建图中区间往区间连边的思想，建立一个虚点，用 $[l,r]$ 往虚点连边，在从虚点往 $[p,q]$ 连边，边数就被压缩到了 $O(nk)$ 级别。

用不等式解释的话，设虚点为 $h$，则对于约束 $\min_{l\le x\le r} a_x-\max_{p \le y \le q} a_y \ge ans$，则拆成 $a_h-\min_{l\le x\le r} a_x \ge ans$ 和 $\max_{p \le y \le q} a_y-a_h \ge 0$，容易证明这两种约束是等价的。

最后本题即使虚点建边，最坏复杂度也有 $O(nmk)$，只能用 SLF+LLL 优化的版本才能过。

```cpp
template <class T, int N>
class SDC {
private:
	int tot = 0, head[N];
	struct Edge {
		int next, to; T dis;
	} edge[N * 3];
	inline void add_edge(int u, int v, const T& w) {
		edge[++tot].next = head[u], edge[tot].to = v, edge[tot].dis = w, head[u] = tot;
	}
	deque<int> q;
	T dis[N]; int cnt[N]; bool vis[N];
public:
	void clear() {
		q.clear();
		tot = 0, memset(head, 0, sizeof(head)), memset(edge, 0, sizeof(edge));
		memset(cnt, 0, sizeof(cnt)), memset(vis, 0, sizeof(vis));
		fill(dis, dis + N, -numeric_limits<T>::max() / 2);
	}
	SDC() {clear();}
	T operator[](int idx) const {return dis[idx];}
	
	void add_le(int a, int b, const T& c) {add_edge(a, b, -c);}  // x[a] - x[b] <= c
	void add_ge(int a, int b, const T& c) {add_edge(b, a, c);}  // x[a] - x[b] >= c
	void add_eq(int a, int b, const T& c) {add_le(a, b, c), add_ge(a, b, c);}  // x[a] - x[b] == c
	void add_eq(int a, int b) {add_edge(a, b, 0), add_edge(b, a, 0);}  // x[a] == x[b]
	
	bool solve(int n) {
		for (int i = 0; i <= n; i++) add_edge(n + 1, i, 0);
		dis[n + 1] = 0, vis[n + 1] = true, cnt[n + 1] = 1, q.emplace_back(n + 1);
		long long num = 1, sum = 0;
		while (!q.empty()) {
			int u = q.front(); 
			while (num * dis[u] < sum) q.pop_front(), q.emplace_back(u), u = q.front();
			q.pop_front(), vis[u] = 0, num--, sum -= dis[u];
			if (++cnt[u] > n + 1) return false;
			for (int j = head[u]; j != 0; j = edge[j].next) {
				int v = edge[j].to; T w = edge[j].dis;
				if (dis[v] < dis[u] + w) {
					dis[v] = dis[u] + w;
					if (vis[v]) continue;
					vis[v] = 1, num++, sum += dis[v];
					if (!q.empty() && dis[v] > dis[q.front()]) q.emplace_front(v);
					else q.emplace_back(v);
				}
			}
		}
		return true;
	}
};

SDC<int, N> sdc;
int n, m, l1, r1, l2, r2, x;

void _main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> l1 >> r1 >> l2 >> r2 >> x;
		for (int j = l1; j <= r1; j++) sdc.add_ge(m + i, j, x);
		for (int j = l2; j <= r2; j++) sdc.add_ge(j, m + i, 0);
	}
	if (!sdc.solve(m + n)) return cout << "No Solution", void();
	int mx = sdc[1], mn = sdc[1];
	for (int i = 1; i <= m + n; i++) mx = max(mx, sdc[i]), mn = min(mn, sdc[i]);
	cout << mx - mn;
}
```

---


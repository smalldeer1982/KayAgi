# [蓝桥杯 2020 省 A2] 荒岛探测

## 题目描述

科学家小蓝来到了一个荒岛, 准备对这个荒岛进行探测考察。

小蓝使用了一个超声定位设备来对自己进行定位。为了使用这个设备，小蓝需要在不同的点分别安装一个固定的发射器和一个固定的接收器。小蓝手中还有一个移动设备。定位设备需要从发射器发射一个信号到移动设备, 移动设备收到后马上转发，最后由接收器接收，根据这些设备之间传递的时间差就能计算出移动设备距离发射器和接收器的两个距离，从而实现定位。

小蓝在两个位置已经安装了发射器和接收器, 其中发射器安装在坐标 $\left(x_{A},y_{A}\right)$，接收器安装在坐标 $\left(x_{B},y_{B}\right)$ 。小蓝的发射器和接收器可能在岛上，也可能不在岛上。

小蓝的定位设备设计有些缺陷, 当发射器到移动设备的距离加上移动设备 到接收器的距离之和大于 $L$ 时, 定位设备工作不正常。当和小于等于 $L$ 时，定位设备工作正常。为了安全，小蓝只在定位设备工作正常的区域探测考察。

已知荒岛是一个三角形, 三个顶点的坐标分别为 $\left(x_{1}, y_{1}\right)$，$\left(x_{2},y_{2}\right)$，$\left(x_{3},y_{3}\right)$。

请计算，小蓝在荒岛上可以探测到的面积有多大。

## 说明/提示

**【样例说明】**

荒岛的形状和定位设备工作正常的区域如下图所示, 蓝色的三角形表示荒岛, 红色的曲线围成的区域为定位设备工作正常的区域。

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_30_7ff7a90fd65c5962b43dg-14.jpg)

当输出为 $39.98、39.99$ 或 $40.00$ 时可以得分。

**【评测用例规模与约定】**

对于所有评测用例, 保证发射器的两个坐标不同, $-1000 \leq x_{A}, y_{A}, x_{B}, y_{B} \leq$ $1000,-1000 \leq x_{1}, y_{1}, x_{2}, y_{2}, x_{3}, y_{3} \leq 1000,-1000 \leq L \leq 1000$ 。 

蓝桥杯 2020 第二轮省赛 A 组 I 题。

## 样例 #1

### 输入

```
10 6 4 12 12
0 2 13 2 13 15
```

### 输出

```
39.99
```

# 题解

## 作者：CChord (赞：2)

### 题意

求一个椭圆与一个三角形相交部分的面积。

### 整体思路

1. 几何变换，简化椭圆方程。

2. 数值积分，将交集区域的面积近似为多个小矩形的面积之和。

### 几何变换

考虑将椭圆标准化为 $\dfrac{x^2}{a^2}+\dfrac{y^2}{b^2}=1$ 的形式，分为两步：平移、旋转。

1. 平移：很简单，先求出新的原点坐标，即 A、B 中点坐标，将所有点减去该点坐标即可。

2. 旋转：希望将 A 点旋转到 $x$ 轴负半轴作为左焦点，B 点旋转到 $x$ 轴正半轴作为右焦点。

计算逆时针旋转的角度 $\theta$，用 $2\pi$ 减去 OB 所在角度即可。

接着，利用旋转矩阵：

$$
R(\theta)=\begin{bmatrix}
 \cos\theta & -\sin\theta\\
 \sin\theta & \cos\theta
\end{bmatrix}
$$

对每个点作旋转变换即可。

$$
\begin{bmatrix}
 x'\\
 y'
\end{bmatrix}
=\begin{bmatrix}
 \cos\theta & -\sin\theta\\
 \sin\theta & \cos\theta
\end{bmatrix}
\begin{bmatrix}
 x\\
 y
\end{bmatrix}=
\begin{bmatrix}
 x\cos\theta - y\sin\theta\\
 x\sin\theta+y\cos\theta
\end{bmatrix}
$$

### 数值积分

将交集区域的面积近似为多个小矩形的面积之和，对于每个 $x$ 值 $(-a\le x\le a)$，需要求出竖直线与椭圆相交的区间和与三角形相交的区间，取两个区间的交，作为小矩形的高。

1. 与椭圆相交的区间为 $\left[-b\sqrt{1-\dfrac{x^2}{b^2}}, b\sqrt{1-\dfrac{x^2}{b^2}}\right]$。
2. 与三角形相交的区间，可以用如下方式求得：
   * 若三个顶点分布在竖直线左右两侧，那么有相交，否则无相交。
   * 有相交时，不妨假设左侧有一点，右侧有两点，那么竖直线与三角形交于左侧一点与右侧两点的两条连线上，分别计算交点即可。

### 精度问题

$dx$ 的取值，过小容易 TLE，过大容易出现精度问题。估计一下时间复杂度，每个小矩形 $O(1)$，一共计算 $\dfrac{L}{dx}$ 次，$L$ 为 $10^{3}$ 量级，取 $dx=10^{-4}$，整体约 $10^7$ 量级，在时限内且保证精度。

### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr double PI = 3.14159265358979323;

void solve(){
    double xA, yA, xB, yB, L; cin >> xA >> yA >> xB >> yB >> L;
    vector<double>tx(3), ty(3);
    for(int i = 0; i < 3; i++) cin >> tx[i] >> ty[i]; 

    // 整体平移
    double xO = (xA + xB) / 2, yO = (yA + yB) / 2;
    auto translate = [&](double &x, double &y){ x -= xO, y -= yO; };
    translate(xA, yA);
    translate(xB, yB);
 	for(int i = 0; i < 3; i++) translate(tx[i], ty[i]);

    // 获取旋转角 theta
    double xOB = atan2(yB, xB);
    if(xOB < 0) xOB += 2 * PI;
    double theta = 2 * PI - xOB;

    // 整体旋转
	// cout << theta / PI * 180;
	auto rotate = [&](double &x, double &y){
		auto u = x, v = y;
		x = u * cos(theta) - v * sin(theta);
		y = u * sin(theta) + v * cos(theta);
	};
	rotate(xA, yA);
	rotate(xB, yB);
 	for(int i = 0; i < 3; i++) rotate(tx[i], ty[i]);

	// 椭圆半长轴a, 半短轴b
	double a = L / 2, b = sqrt(a * a - xA * xA);

	// 获取直线与三角形相交的区间
	auto get_seg = [&](double x) -> pair<double, double>{
		vector<pair<double, double>>l, r;
		for(int i = 0; i < 3; i++){
			if(tx[i] < x) l.emplace_back(tx[i], ty[i]);
			else r.emplace_back(tx[i], ty[i]);
		}
		if(l.size() && r.size()){
			if(l.size() == 2) swap(l, r);
			double segl = l[0].second + (r[0].second - l[0].second) * (x - l[0].first) / (r[0].first - l[0].first);
			double segh = l[0].second + (r[1].second - l[0].second) * (x - l[0].first) / (r[1].first - l[0].first);
			if(segl > segh) swap(segl, segh);
			return {segl, segh};
		}
		return {0, 0};
	};

	double res = 0;
	constexpr double dx = 0.0001; 
	// 开始积分
	for(double x = -a; x <= a; x += dx){
		double y = b * sqrt(1 - x * x / a / a);
		auto [l, r] = get_seg(x);
		double low = max(l, -y), high = min(r, y); 
		res += max(.0, high - low) * dx;
	}

	cout << fixed << setprecision(2);
	cout << res;
}

signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    solve();
    return 0;
}
```

---

## 作者：yanxu_cn (赞：1)

本题在蓝题中属于中等偏下难度水平，但是对于代码实现能力的要求比较高（大概要有个大模拟的水平，至少从 LOC 来说）。不过计算几何都这样就是说。不过蓝桥杯出计算几何的蓝题挺少见的。

## 题意简析
求一个三角形和一个椭圆的相交部分的面积，这个挺显然的。
## 思路

三角形和椭圆的相交部分，一看就是一个很奇怪的形状，用面积公式肯定是做不来了，所以想到微积分。

我们容易想到用与 $y$ 轴平行的线去割这个形状。但是如果直接割，容易发现椭圆方程并不是很好解，因为有两个二次根式之和，稍微随便乱处理一下直接整出一个四次方程来，虽然没有说不能解吧，但还是挺麻烦的。

所以我们先将坐标系平移一下，使得椭圆圆心为原点，再旋转使得长轴落在横轴上面。我们还要顺手处理一下三角形的角度问题，用三角函数算一下即可，甚至用不着调用 math 库里面的 `sin`、`acos` 这些函数徒增用时。

坐标转换的代码：
```cpp
double halfl=l/2.0,halfd=dab/2.0;
double b=sqrt(poww2(halfl)-poww2(halfd));
double sinth=(yb-ya)/dab,costh=(xb-xa)/dab;

Point O{(xa + xb)/2.0,(ya + yb)/2.0};
Point triangle[3]={{x1,y1},{x2,y2},{x3,y3}};

// 坐标变换
for(int i=0;i<3;++i)
{
	double dx=triangle[i].x-O.x;
	double dy=triangle[i].y-O.y;
	triangle[i].x=dx*costh+dy*sinth;
	triangle[i].y=-dx*sinth+dy*costh;
}
```
然后就是愉快的积分啦。

积分的预处理阶段。

```cpp
double cnt=.0;
const double step=.001;
const double start=-halfl,end=halfl;
```

计算椭圆的交点经过变换已经大幅度地简化了。

```cpp
// 计算椭圆 y 范围
double x_ratio=px/halfl;
if (x_ratio*x_ratio>1.0)continue;
double y_e=b*sqrt(1.0-x_ratio*x_ratio);
double elli_ymin=-y_e,elli_ymax=y_e;
```

计算三角形的步骤相比就比较麻烦了，需要特判一些东西比如割线与三角形一边重合了的情况，避免出现 NaN 的麻烦情况。

第一步，除了一些重合之类的情况，收集交点：
```cpp
#include<vector>
const pair<int, int> nl[] = { {0,1}, {1,2}, {2,0} };
// 收集三角形交点
vector<Point> cross;
for (auto& ln : nl)
{
	Point p1=triangle[ln.first],p2=triangle[ln.second];
	
	// 处理垂直线段
	if(eq(p1.x, p2.x)&&eq(p1.x,px))
	{
		cross.push_back(p1);
		cross.push_back(p2);
		continue;
	}
	
	// 处理端点恰好在px的情况
	if(eq(p1.x,px))cross.push_back(p1);
	if(eq(p2.x,px))cross.push_back(p2);
	
	// 处理跨px的线段
	bool s1=p1.x<px-eps,s2=p2.x<px-eps;
	if (s1==s2) continue;
	Point p=linecross(p1, p2, px);
	cross.push_back(p);
}
```
然后去重并处理：

```cpp
// 去重交点
vector<Point>unique_cross;
for (auto&p:cross)
{
	bool exist=false;
	for(auto&up:unique_cross)
		if(eq(p.x,up.x)&&eq(p.y, up.y)){exist=true;break; }
	if(!exist)unique_cross.push_back(p);
}

if(unique_cross.empty())continue;

// 计算三角形Y范围
vector<double>ys;
for(auto&p:unique_cross)ys.push_back(p.y);
double tri_ymin=*min_element(ys.begin(),ys.end());
double tri_ymax=*max_element(ys.begin(),ys.end());
```
最后计算重叠区域：
```cpp
// 计算重叠区域
double lower=max(tri_ymin,elli_ymin);
double upper=min(tri_ymax,elli_ymax);
if(upper>lower+eps)
	cnt+=step*(upper-lower);
```
## 完整代码纯享
```cpp
#include <bits/stdc++.h>
using namespace std;
#define poww2(x) ((x)*(x))
const double eps = 1e-8;

struct Point { double x, y; };
const pair<int, int> nl[] = { {0,1}, {1,2}, {2,0} };

inline bool eq(double a, double b) {return fabs(a-b)<eps; } // 浮点相等判断

inline Point linecross(Point p1, Point p2,double k)
{
	return {k,(p1.y*(p2.x-k)+p2.y*(k-p1.x))/(p2.x-p1.x)};
}

int main()
{
	int xa,ya,xb,yb,l,x1,y1,x2,y2,x3,y3;
	cin>>xa>>ya>>xb>>yb>>l>>x1>>y1>>x2>>y2>>x3>>y3;

	double dab=sqrt(poww2(xb-xa)+poww2(yb-ya));
	if(dab>l){cout<<"0.00\n";return 0;}

	double halfl=l/2.0,halfd=dab/2.0;
	double b=sqrt(poww2(halfl)-poww2(halfd));
	double sinth=(yb-ya)/dab,costh=(xb-xa)/dab;

	Point O{(xa + xb)/2.0,(ya + yb)/2.0};
	Point triangle[3]={{x1,y1},{x2,y2},{x3,y3}};

	// 坐标变换
	for(int i=0;i<3;++i)
	{
		double dx=triangle[i].x-O.x;
		double dy=triangle[i].y-O.y;
		triangle[i].x=dx*costh+dy*sinth;
		triangle[i].y=-dx*sinth+dy*costh;
	}

	double cnt=.0;
	const double step=.001;
	const double start=-halfl,end=halfl;

	for(double i=start;i<=end+eps;i+=step)
	{
		// 处理浮点误差
		double px=i;
		if(px>end)px=end;
		if(px<start)px=start;

		// 计算椭圆Y范围
		double x_ratio=px/halfl;
		if (x_ratio*x_ratio>1.0)continue;
		double y_e=b*sqrt(1.0-x_ratio*x_ratio);
		double elli_ymin=-y_e,elli_ymax=y_e;

		// 收集三角形交点
		vector<Point> cross;
		for (auto& ln : nl)
		{
			Point p1=triangle[ln.first],p2=triangle[ln.second];
			
			// 处理垂直线段
			if(eq(p1.x, p2.x)&&eq(p1.x,px))
			{
				cross.push_back(p1);
				cross.push_back(p2);
				continue;
			}
			
			// 处理端点恰好在px的情况
			if(eq(p1.x,px))cross.push_back(p1);
			if(eq(p2.x,px))cross.push_back(p2);
			
			// 处理跨px的线段
			bool s1=p1.x<px-eps,s2=p2.x<px-eps;
			if (s1==s2) continue;
			Point p=linecross(p1, p2, px);
			cross.push_back(p);
		}

		// 去重交点
		vector<Point>unique_cross;
		for (auto&p:cross)
		{
			bool exist=false;
			for(auto&up:unique_cross)
				if(eq(p.x,up.x)&&eq(p.y, up.y)){exist=true;break; }
			if(!exist)unique_cross.push_back(p);
		}

		if(unique_cross.empty())continue;

		// 计算三角形Y范围
		vector<double>ys;
		for(auto&p:unique_cross)ys.push_back(p.y);
		double tri_ymin=*min_element(ys.begin(),ys.end());
		double tri_ymax=*max_element(ys.begin(),ys.end());

		// 计算重叠区域
		double lower=max(tri_ymin,elli_ymin);
		double upper=min(tri_ymax,elli_ymax);
		if(upper>lower+eps)
			cnt+=step*(upper-lower);
	}

	cout<<fixed<<setprecision(2)<<cnt;
	return 0;
}
```

---


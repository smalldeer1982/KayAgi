# [蓝桥杯 2021 省 AB] 括号序列

## 题目描述

给定一个括号序列，要求尽可能少地添加若干括号使得括号序列变得合法，当添加完成后，会产生不同的添加结果，请问有多少种本质不同的添加结果。两个结果是本质不同的是指存在某个位置一个结果是左括号，而另一个是右括号。

例如，对于括号序列 `((()`，只需要添加两个括号就能让其合法，有以下几种不同的添加结果：`()()()` 、`()(())`、`(())()`、`(()())` 和 `((()))`。

## 说明/提示

对于 $40 \%$ 的评测用例，$|s| \leq 200$。

对于所有评测用例，$1 \leq|s| \leq 5000$。 

蓝桥杯 2021 第一轮省赛 A 组 I 题（B 组 J 题）。

## 样例 #1

### 输入

```
((()```

### 输出

```
5```

# 题解

## 作者：CoderXL (赞：14)

### P8745 括号序列

#### 思路

这题关键点在于——什么是**本质不同**的添加结果。

首先注意，对于一个未匹配的括号序列 `())(()(()`，删掉所有已经配对的括号，一定会得到 `)((` 这样的序列。左边全是右括号，右边全是左括号。因此我们需要在左侧适当添加左括号，右侧添加右括号，才能使其合法。

接下来先着重关注左半边的情况。

----

不妨这么想：把合法的括号序列按照右括号 `)` 分隔开，形成几个子串。每个字串都只包含若干个左括号 `(`。例如

`()()()` 拆分成 `(` `(` `(`

`()(())` 拆分成 `(` `((` ` ` 

`(())()` 拆分成 `((` ` ` `(`

`(()())` 拆分成 `((` `(` ` `

`((()))` 拆分成 `(((` ` ` ` `

因此**本质不同**意味着划分方式不同，而我们求的其实是合法的划分方式。

因此，对于一个未匹配的括号序列 `()))`，我们尝试在每两个右括号 `)` 之间加入若干左括号 `(`，使其合法。

具体地，设 $dp[i][j]$ 表示在第 $i$ 个右括号之前，总共新加了 $j$ 个左括号。同时为了保证合法，规定 $num[i]\le j\le cnt$ 。其中 $num[i]$ 表示 $i$ 及其之前未匹配的右括号总数，故 $j$ 至少大于等于 $num[i]$；$cnt$ 表示整个串内的右括号数，比 $cnt$ 还大的 $j$ 必然是没有意义的，只会浪费复杂度。

转移枚举上一个右括号之前新加了多少左括号： 

$$
dp[i][j]=\sum_{k=num[i-1]}^{j} dp[i-1][k]
$$

复杂度 $\mathcal{O(n^3)}$：

```cpp
for(int i=1;i<=cnt;i++)
{
    for(int j=num[i];j<=cnt;j++)
    {
        for(int k=num[i-1];k<=j;k++)
        {
            dp[i][j]+=dp[i-1][k];
            dp[i][j]%=Mod;
        }
    }
}
```

**优化很简单，对每个 $i$ 做一次前缀和即可。达到 $\mathcal{O(n^3)}$。**

----

对于右半边，只需要把整个串前后翻转，做一次镜像，再做一遍就行。

然后把两半边的方案数乘起来得到总方案数。

----

#### 代码

```cpp
//
//  main.cpp
//  P8745
//
//  Created by Leo Xia on 2023/11/9.
//

#include <bits/stdc++.h>
typedef long long ll;
const int N=5010,Mod=1000000007;
using namespace std;
string s;
ll dp[N][N];
int num[N],cnt;
ll L,R;
ll solve()
{
    int lcnt,rcnt;
    lcnt=rcnt=0;
    memset(num,0,sizeof(num));
    memset(dp,0,sizeof(dp));
    cnt=0;
    for(int i=0;i<s.length();i++)
    {
        if(s[i]=='(')lcnt++;
        else
        {
            rcnt++;
            if(lcnt){rcnt--;lcnt--;}
            num[++cnt]=rcnt;
        }
    }
    dp[0][0]=1;
    for(int i=1;i<=cnt;i++)
    {
        for(int j=num[i-1];j<=cnt;j++)
        {
            dp[i-1][j]+=dp[i-1][j-1];
            dp[i-1][j]%=Mod;
        }
        for(int j=num[i];j<=cnt;j++)
        {
            dp[i][j]+=(dp[i-1][j]-dp[i-1][num[i-1]-1])%Mod+Mod;
            dp[i][j]%=Mod;
        }
    }
    return dp[cnt][num[cnt]];
}
void rev()
{
    string tmp;
    tmp.clear();
    for(int i=s.length()-1;i>=0;i--)
        tmp.push_back(s[i]=='('?')':'(');
    s=tmp;
}
int main()
{
    //freopen
    ios::sync_with_stdio(0);
    cin>>s;
    L=solve()%Mod;
    rev();
    R=solve()%Mod;
    cout<<L*R%Mod;
    return 0;
}

```




---

## 作者：hzx360 (赞：13)

**前言**：感谢审核大大百忙中审核 MnZn 题解（原本是通过了的，改了一点细节，麻烦审核大大通过一下 QAQ）。

update1：step 3 中求和式子 $k$ 的上界为应该是 $j$（感谢 @youdu666_ 的修正）。

update2：被 hack 了，原因是 ans1 或 ans2 为 0 时要特判（已修改）。

------------

闲话：昨天模拟赛题，大佬 [yywlp](https://www.luogu.com.cn/user/422328) 写了此题第一份题解 [QAQ](https://www.luogu.com.cn/blog/yywlp/solution-p8745)。

但我觉得写得不够详细，一些地方没有证明，故再发一篇。

------------
### Step 1
做这题首先要知道一个合法序列要满足什么条件。
若我们设**左括号**的值为 $1$，**右括号**为 $-1$，从左到右扫描序列将权值一个个加起来，则对于一个合法的序列在相加的过程中都满足**和**大于等于 $0$，并且所有加完后等于 $0$。
### Step 2
使其变为合法序列有可能要加右括号或左括号，或者两个都要加。

左往右加左括号，从右往左加右括号，可以发现存在一个**分割位置**，使得其**左边全部都是添加左括号的，右边都是添加加右括号的**。

这点非常重要，这可以说明**左右括号的添加互不影响**。

如何证明？

考虑从左往右添加左括号，我们要清楚左括号的作用就维持从左到右扫描过程中的**和**大于等于 $0$。那我们再考虑在添加的**左括号**左边加上一个**右括号**，贪心地想，要求最少添加量，一个右括号消耗一个左括号，这不是给我添堵吗？这右括号放左边，白白浪费一个左括号。

所以由贪心即可以证明存在这么个分割位置。

接着证左右括号的添加互不影响：

![](https://cdn.luogu.com.cn/upload/image_hosting/sfac20ju.png)

所以就算我们独立加左括号和右括号也会满足最后的**和**等于 $0$，两种括号添加互不影响。

### Step 3
那我们就算出加左括号的方案数和右括号的方案数，两个乘起来就行了。还有一点：由于左右括号添加规则一样，所以可以先求左括号的方案，再将原序列翻转，再求右括号的方案。

求方案数用 DP。

先求出每个右括号左侧至少要有多少左括号才能保证从左往右扫描**和**大于等于 $0$，用 $add$ 数组储存。

定义 $dp_{i,j}$ 表示第 $i$ 个右括号前至少有 $j$ 个左括号。以右括号为隔板，考虑有 $k$ 个左括号在第 $i-1$ 个右括号左侧，两隔板间全是左括号，其数量不影响求值，故转移方程为：
$$dp_{i,j}=\sum_{k=add_{i-1}}^{j}dp_{i-1,k}$$

**Tip**：这个 $k$ 的下界就是上一个右括号至少需要的左括号数 $add_{i-1}$，上界是目前原序列中右括号数量 $j$。

复杂度为 $O(n^3)$ 明显太高，用一个数组维护前缀和即可，最终复杂度为 $O(n^2)$。

### 代码:
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=5e3+100,mod=1e9+7;
char s[N],t[N];
int n,dp[N][N],sum[N],add[N];//dp[i][j]第i个右括号前有j个左括号 
void deal(){
    memset(dp,0,sizeof(dp));
    memset(add,0,sizeof(add));
    for(int i=1;i<=n;i++) t[i]=(s[n-i+1]==')'?'(':')');
    for(int i=1;i<=n;i++) s[i]=t[i]; 
}
int work(){
    int lcnt=0,rcnt=0,num=0;
    for(int i=1;i<=n;i++){
        if(s[i]=='(') lcnt++;
        else{
            rcnt++;
            if(lcnt) lcnt--,rcnt--;
            add[++num]=rcnt; 
        }
    }
    for(int j=add[1];j<=num;j++) dp[1][j]=1,sum[j]=(sum[j-1]+dp[1][j]);
    for(int i=2;i<=num;i++){
        for(int j=add[i];j<=num;j++) dp[i][j]=(sum[j]-sum[add[i-1]-1]+mod)%mod;
        for(int j=0;j<add[i];j++) sum[j]=0;
        for(int j=add[i];j<=num;j++) sum[j]=(sum[j-1]+dp[i][j]);
    }
    return dp[num][add[num]];
}
signed main(){
    scanf("%s",s+1);
    n=strlen(s+1);
    int ans1=work();
    deal();
    int ans2=work();
    if(!ans1) cout<<ans2%mod;
    else if(!ans2) cout<<ans1%mod;
    else cout<<ans1*ans2%mod;
} 
```
完结撒花 QAQ。

---

## 作者：sz_yangwangbo (赞：7)

# 思路
当我们第一次阅读完题目，发现像是暴力啊、递归啊什么的都不好用的时候，就要想到这是动态规划题了。

这道题和常见的动态规划题的难点一样：建立动态转移方程。分析完题目类型之后，可以从数据范围 $s\le5000$ 粗略地推出来我们的 dp 应该是个二维数组。

简要分析题目，不难看出补充左括号 $\text($ 和补充右括号 $\text)$ 的规则一致，无非是从左往右添加和从右往左添加的区别，所以笔者这里偷了点懒，按照正常顺序计算出左括号添加的方案数后，将字符串的顺序以及左右括号反转，按照同一套规则找出了有括号的添加方案数。不难推出我们所需要的答案就是左括号方案数 $\times$ 右括号方案数 $\bmod\ Mod$ 的值。

下面是笔者建立的动态转移方程：

`dp[i][j] = dp[i][j-1]+dp[i-1][j]; `

$i$：需要添加的第 $i$ 个左括号

$j$：在第 $j$ 个右括号的左侧

然后是建立这个动态转移方程的思路：

从左向右遍历，如果出现 $\text($，将临时存储的 $t$ 值 $+1$(初始是 $0$)，遇到 $\text)$ 则 $-1$，当 $t<0$ 时，我们就知道我们需要补一个 $\text($ 了。当然，在 $t<0$ 的情况下遇到 $\text($ 的时候要将 $t$ 清零再 $+1$(可以有多种方式实现这种效果，比如 $t=0$ 的时候不再减小 $t$ 的值)。

因为我们以 $\text)$ 为隔板，隔板间 $\text($ 的数量其实不会影响到我们的排列组合，所以笔者使用了 $arr$ 数组来存储每个需要补括号的位置及它的右侧一共有多少个 $\text)$，这里也有多种方式可以实现。

当我们尝试去计算第 $i$ 个 $\text($ 放在第 $j$ 个 $\text)$ 左边有多少种可行方法时，会发现一共只有两种方案：一种是添加在第 $j$ 个位置，其方案数等同于第 $i-1$ 个 $\text($ 添加在同一位置的方案数，也就是 $dp_{i-1,j}$；另一种是不选择在第 $j$ 个位置添加任何 $\text($，其方案数等同于在上一个位置安放 $\text($ 的方案数，也就是 $dp_{i,j-1}$。
# 代码
```cpp
#include <iostream>
#include <cstring>
using namespace std;
const long long Mod = 1000000007;
const int M = 5005;
long long dp[M][M];
int arr[M];
long long function(string s){
  memset(dp,0,sizeof(dp));      //初始化数组的函数,来自<cstring>或<string.h>库
  memset(arr,0,sizeof(arr));
  long long ans=0;
  int all,p=0;
  for(int i=0,t=0;i<s.length();i++){
    if(s[i]==')'){
      if(--t<0)p++;
      arr[p]++;
    }else if(t++<0)t=1;
  }
  dp[0][1] = 1,all = arr[0];
  for(int i=1;i<=p;i++){
    all += arr[i];
    for(int j=1;j<=all-arr[i]+1;j++){
      dp[i][j] = (dp[i][j-1]+dp[i-1][j]) % Mod;
    }
  }
  for(int i=1;i<=all-arr[p]+1;i++)ans = (ans+dp[p][i]) % Mod;
  return ans;
}
string fstr(string s){      //反转
  string t;
  for(int i=s.length()-1;i>=0;i--)t+= s[i]=='(' ? ')':'(';
  return t;
}
int main(){
  string s;
  cin>> s;
  cout<< (function(s) * function(fstr(s)))%Mod;
  return 0;
}
```

---

## 作者：lIlIIIlllllIIIIll (赞：3)

### 分析
先考虑最少要添加几个括号。\
对给定的序列 $s$ 做一个括号匹配：从左到右遍历序列 $s$，左括号无条件入栈，遇到右括号则出栈。可以发现一个序列是非法的当且仅当：

1. 遇到右括号栈内没有左括号。
2. 栈内剩下多余左括号没有右括号与之匹配。

也就是说栈内所剩下的，从左往右，先是多余的右括号，再是多余的左括号。我们在剩下的右括号之前，左括号之后添加括号，就可以使得序列合法。\
\
为解释方便，考虑栈内只剩下左括号的情况，因为如果有剩下右括号，我们可以将那一部分做镜像处理，是一样的。这时我们需要在序列 $s$ 内左括号之后填入右括号，例如一组样例是：
```
((())(()(
```
我们一共需要填入 $3$ 个右括号，在**不同**左括号之后填入**不同**数量的右括号是**不同**的，也就是说，我们可以填在：
```
(_(_(_))(_(_)(_
```
这些位置（下划线处）。\
对于第 $i$ 个左括号和第 $i+1$ 个左括号之间，假设它们在 $s$ 的下标为 $p_i$ 和 $p_{i+1}$，这时它们之间有右括号 $p_{i+1}-p_i-1$个，第 $i$ 个左括号之前左右括号差为 $dif_i$，则这个空最多只能填 $dif_i-(p_{i+1}-p_i-1)$，我们设这个数是 $d_i$，第 $i$ 个空可以填 $1,2,3,...,d_i$个右括号。考虑生成函数多项式：
$$
\begin{cases}
P_0(x)=1 \\
P_i(x)=P_{i-1}(x)(1+x+x^2+...+x^{d_i})
\end{cases}
$$
设系数 $f_{i,j}$ 表示多项式 $P_i(x)$ 中对应 $x^j$ 的系数，本题中的意义就是前 $i$ 个空填入了 $j$ 个空格的方案数，并且前面提到 $j\le d_i$的，展开多项式，考虑 $x^j$ 的一项：
$$
\begin{aligned}
f_{i,j}x^j&=x^jf_{i-1,0}+x^{j-1}f_{i-1,1}x+...+f_{i-1,j}x^j \\
&=\sum_{k=0}^jf_{i-1,k}x^j \\
&=(f_{i,j-1}+f_{i-1,j})x^j
\end{aligned}
$$
这样我们得到了一个非常漂亮的递推式：
$$
f_{i,j}=f_{i,j-1}+f_{i-1,j}
$$
注意初始化 $f_{i,0}=1$ ，因为 $0$ 次项系数永远是 $1$ 。不用担心 $P_{i-1}(x)$ 的次数不足 $j$ 的情况，因为 $f_{i,j}$ 可以是 $0$。\
把序列 $s$ 按照匹配的情况分成两段，对其中一段做镜像处理，应用乘法原理答案为两段的答案相乘。\
这样时间复杂度为 $O(n^2)$。
### 代码
```c++
#include<bits/stdc++.h>
#define N 5010
#define MOD 1000000007
using namespace std;
typedef long long LL;
LL f[N][N];
string s;
string r1,r2;
int t[N];
LL dp(string r)
{
	int l=r.length();
	if(!l) return 1;
	int i,j,n=0;
	int d[N]={0},cl=0,cr=0;
	for(i=0;i<l;++i)
	{
		cl+=(r[i]=='('),cr+=(r[i]==')');
		if(r[i]=='(')
		{
			j=i+1;
			while(r[j]!='('&&j<l) ++j;
			d[++n]=cl-cr-j+i+1;
		} 
	}
	memset(f,0,sizeof f);
	for(i=0;i<=n;++i) f[i][0]=1;
	for(i=1;i<=n;++i)
		for(j=1;j<=d[i];++j)
			f[i][j]=(f[i][j-1]+f[i-1][j])%MOD;
	return f[n][d[n]]%MOD;
} 
void rev(string &r,int L,int R)
{
	int i;
	for(i=R;i>=L;--i) r+="()"[s[i]=='('];
}
int main()
{
	cin>>s;
	int l=s.length(),i,j,k=0;
	for(i=0;i<l;++i)
	{
		if(k&&s[t[k-1]]=='('&&s[i]==')') --k;
		else t[k++]=i;
	} 
	if(s[t[k-1]]==')') rev(r1,0,l-1);
	else for(i=0;i<k;++i)
	{
		if(s[t[i]]=='(') 
		{
			for(j=t[i];j<l;++j) r2+=s[j];
			rev(r1,0,t[i]-1);
			break;
		}
	}
	
	LL ans=dp(r1)*dp(r2)%MOD;
	cout<<ans;
	return 0;
}
```

---

## 作者：hxuwna (赞：1)

首先注意到一个括号序列一定能划分为以多余的 $)$ 结尾的一段和剩下的不含多余 $)$ 的另一段。

而显然本质不同的方案反转后依旧本质不同，所以把前一段反转后就有了两端只含多余 $($ 的括号序列。

我们设 $dp[i][j]$ 为第 $i$ 为还剩 $j$ 个 $($ 的方案数，我们考虑在一个字符后添加 $)$。

显然如果在右括号后添加右括号会导致算重（因为右括号的前面也可以添加右括号，在前面添和在后面添本质相同），所以我们可以得到两个转移式（$cnt$ 表示枚举到当前位多余的 $($）。
$$dp[i][j]=\sum_{k=j-1}^{cnt-1} dp[i-1][k]$$
$$dp[i][j]=dp[i-1][j+1]$$
这两个式子分别表示 $s[i]=($ 和 $s[i]=)$ 时的式子，最后加上一些细节处理。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
constexpr int N=5e3+5,mod=1e9+7;
int n,n1,cnt,dp[N][N],ne,ans=1;
string s,s1,s2;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>s;n=s.size();
	s=" "+s;
	for(int i=1;i<=n;i++){
		if(s[i]=='(') cnt++;
		else cnt--;
		if(cnt<0) ne=i,cnt=0;
	}
	for(int i=1;i<=ne;i++) s1+=s[i];
	for(int i=ne+1;i<=n;i++) s2+=s[i];
	if(s1.size()) reverse(s1.begin(),s1.end());
	if(s1.size()){
		n1=s1.size();s1=" "+s1;
		dp[0][0]=1;cnt=0;
		for(int i=1;i<=n1;i++){
			if(s1[i]==')'){
				int sum=0;cnt++;
				for(int j=cnt;j>=0;j--){
					if(j) sum=(sum+dp[i-1][j-1])%mod;
					dp[i][j]=sum;
				}
			}else{
				cnt--;
				for(int j=0;j<=cnt;j++) dp[i][j]=dp[i-1][j+1];
			}
		}
		ans*=dp[n1][0];
	}
	for(int i=1;i<=n1;i++) for(int j=0;j<=n1;j++) dp[i][j]=0;
	if(s2.size()){
		n1=s2.size();s2=" "+s2;
		s1=s2;
		dp[0][0]=1;cnt=0;
		for(int i=1;i<=n1;i++){
			if(s1[i]==')'){
				int sum=0;cnt++;
				for(int j=cnt;j>=0;j--){
					if(j) sum=(sum+dp[i-1][j-1])%mod;
					dp[i][j]=sum;
				}
			}else{
				cnt--;
				for(int j=0;j<=cnt;j++) dp[i][j]=dp[i-1][j+1];
			}
		}
		ans*=dp[n1][0];
	}
	ans%=mod;
	cout<<ans;
	return 0;
}
```

---

## 作者：Ice09 (赞：1)

[题目](https://www.luogu.com.cn/problem/P8745)

这道题一开始数据有误，但后来经管理员的修改，成功修复了数据。

看到已经有人发了题解了，那么我就发一篇滚动数组优化的吧。

Update：2025.6.5 发现自己 2 年前有篇题解没过，对其进行 $\KaTeX$ 的修改。

## 思路

这道题经过思考后认为是 DP。

既然是 DP，我们该怎么做呢？

我们把问题分成 $2$ 步：

1. 当需要添加左括号
1. 当需要添加右括号

经过思考我们可以发现：只要做一种情况就行。因为，假如当我们考虑好了添加左括号的方案数。考虑右括号时，只需将整个括号序列反转一下，在反转了的括号序列中，判断添加左括号的方案数，即为原括号序列的添加右括号的方案数。

那么求出添加左括号的方案数和添加右括号的方案数，能求出总方案数吗？是可以的。很显然，我们添加左括号，是不影响我们添加右括号的。所以总方案数就等于，添加左括号的方案数和添加右括号的方案数的乘积。

如果一个序列想要符合要求，那么它必须满足，左括号和右括号数目相等，并且在任意位置上，左括号数量大于等于右括号数量。

我们可以定义：$dp_{i,j}$ 为考虑完前 $i$ 个，左括号比右括号多 $j$ 个时，添加左括号的方案数（$j$ 一定为正）。

我们只考虑，第 $i$ 个括号时右括号时，才在它前面，添加左括号。因为如果在左括号前添加左括号，与在离这个左括号最近的的右括号添加括号是无异的，这样可以避免算重复的方案数（如下图）。

![](https://cdn.luogu.com.cn/upload/image_hosting/jy8sf9ys.png)

遍历到下标为 $i$ 的位置时，有两种情况：

#### 第 $i$ 个括号为左括号时

此时不能插入括号的，那么 $dp_{i,j}$ 应为什么？它可以由什么推过来？应有 $dp_{i,j} = dp_{i - 1, j - 1}$。因为第 $i$ 个括号为左括号，算上这个左括号，前 $i$ 个左括号的数量，是比前 $i-1$ 个多一个的。因此，前 $i$ 个位置时的左括号比右括号多的数量，是比前 $i - 1$ 个位置时的左括号比右括号多的数量多 $1$ 个的。

#### 第 $i$ 个括号为右括号时

此时 $dp_{i,j} =dp_{i-1,j+1}+dp_{i-1,j}+dp_{i-1,j-1}+...+dp_{i-1, 0}$。$dp_{i-1,j+1}$ 是不在第 $i$ 和第 $i-1$ 放左括号，假如原来左括号就比右括号多 $j+1$ 个，算上第 $i$ 个是右括号，那么左括号就比右括号多出了 $j$ 个。$dp_{i-1,j}$ 是在第 $i$ 和第 $i-1$ 放 $1$ 个左括号，原来左括号就比右括号多 $j$ 个，算上第 $i$ 个是右括号，那么左括号就比右括号多出了 $j-1$ 个，然后我们就可以添加上 $1$ 个左括号，这样 $dp_{i-1,j}$ 就可以推出 $dp_{i, j}$ 在第 $i$ 和第 $i-1$ 放 $1$ 个左括号的方案数。后面的 $dp_{i-1, j-1}+...+dp_{i-1,0}$ 就同理，分别就是放 $2$ 个，放 $3$ 个，以此类推。

那么此时部分代码如下：

```
dp[0][0]=0;
for(int i=1;i<=n;i++)
{
    ...
    if(s[i]==')')//第i个是右括号
    {
        for(int j=0;j<=n;j++)
        {
        	for(int k=-1;k<=j;k++)//k=-1时j-k=j+1，所以写k=-1
        	dp[i][j]+=dp[i-1][j-k];
		}
    }
}
```

你会发现此时，时间复杂度为 $O(n^3)$，此题 $n$ 是 $5000$ 级别的，时间复杂度爆了。

于是考虑优化，其实 $dp_{i-1,j}+dp_{i-1,j-1}+...+dp_{i-1,0}=dp_{i,j-1}$，所以 $dp_{i,j}$ 就等于 $dp_{i-1,j+1}+dp_{i,j-1}$。

所以最终总结如下：

$dp_{i,j} = \begin{cases}
   dp_{i-1,j-1} &\text{if } s_i=\texttt{(}\\
   dp_{i-1,j+1}+dp_{i,j-1} &\text{if } s_i=\texttt{)}
   \end{cases}$

还有一件事~，当 $j=0$，$j-1=-1$，显然会 RE，所以我们先手动算好 $dp_{i,0}$ 的情况，按照没优化时公式的算。


## 滚动数组优化

因为宇宙射线原因，这题一开始空间限制只开了 $128$ MB（后来改了），但也能做。

当我们写好代码时，发现代码递推时，数组第一维下标只用到了 $i$ 和 $i-1$，所以我们可以滚动数组优化，只存数组的第 $i$ 行和第 $i-1$ 行。但此时要只注意：

- $dp_{0,0}$ 不能初始化为零，因为它会用到很多次。

那么代码就如下：

```
#include<bits/stdc++.h>
using namespace std;
const int N=5003,mod=1e9+7;
int n;
char s[N];
long long dp[3][N];
long long cal()
{
    memset(dp,0,sizeof dp);
    for(int i=1;i<=n;i++)
    {
        if(s[i]=='(') 
        {
            dp[i%2][0]=0;
            for(int j=1;j<=n;j++)
            {
                if(i-1==0&&j-1==0)
                dp[i%2][j]=1;
                else 
                dp[i%2][j]=dp[(i-1)%2][j-1]%mod;
            }
        }
        else
        {
            if(i==1)
            {
                dp[i%2][0]=(1+dp[(i-1)%2][1])%mod;
            }
            else
            dp[i%2][0]=(dp[(i-1)%2][0]+dp[(i-1)%2][1])%mod;
            for(int j=1;j<=n;j++)
                dp[i%2][j]=(dp[(i-1)%2][j+1]+dp[i%2][j-1])%mod;
        }
    } 
    int k=n%2;
    for(int i=0;i<=n;i++)
    if(dp[k][i]) return dp[k][i]%mod;
}
int main()
{
    scanf("%s",s+1);
    n=strlen(s+1);
    long long ans1=cal();
    reverse(s+1,s+n+1);
    for(int i=1;i<=n;i++)
        if(s[i]=='(') s[i]=')';
        else s[i]='(';
    long long ans2=cal();
    printf("%lld",ans1*ans2%mod);
    return 0; 
}
```

---

## 作者：AgOH (赞：0)

因为尽可能添加少的括号，所以添加的左、右括号不会出现如同 `()` 的形式，所以左括号与右括号添加的位置方案是相互独立的，不会相互影响。故总的方案数等于左括号的方案数 $\times$ 右括号的方案数。继续转换成只需要添加左括号：当需要添加右括号时将整个括号序列对称翻转，就转化为只需要添加左括号了

若以右括号为分割点将整个序列进行分割，因为分割后的子串中均为左括号，添加任意数目的左括号方案数均为一种，那么此时我们仅需考虑添加不同数量的左括号的方案数即可。采用 DP：

设 $n$ 为右括号数，$x$ 为共需添加多少个左括号，$b$ 代表当前至少需添加多少个左括号

* 状态设计：$\mathtt{dp}_{i,j}$ 代表只考虑前 $i$ 个右括号，需要添加 $j$ 个左括号的方案数
* 初始状态：$\mathtt{dp}_{1,?}=1$
* 结果状态：$\mathtt{dp}_{n,x}$
* 状态转移：$$\mathtt{dp}_{i,j}=\sum_{k=b}^{x}\mathtt{dp}_{i-1,k}$$

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int mod = 1e9+7;
auto calc(string_view s)
{
    int l=0, r=0, cnt=0, x=0;
    vector lb = {1};
    for(char c : s)
    {
        if(c==40) l++, cnt++;
        else lb.push_back(max(++r-l,0)), cnt--;
        if(cnt<0) x++, cnt++;
    }
    int n = lb.size()-1;
    vector dp(n+2, vector<ll>(x+2));
    vector pre(n+2, vector<ll>(x+2));
    for(int i=lb[1];i<=x;i++) dp[1][i]=1, pre[1][i]=i-lb[1]+1;
    for(int i=2;i<=n;i++)
    {
        for(int j=lb[i];j<=x;j++)
        {
            dp[i][j] = pre[i-1][j];
            pre[i][j] = dp[i][j];
            if(j) pre[i][j] = (pre[i][j]+pre[i][j-1])%mod;
        }
    }
    return max(1LL, dp[n][x]);
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    string s;
    cin>>s;
    auto ans = calc(s);
    ranges::reverse(s);
    ranges::transform(s, s.begin(), [](char c) -> char { return c^1; });
    cout<<ans*calc(s)%mod<<'\n';
    return 0;
}
```

---


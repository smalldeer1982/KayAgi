# [蓝桥杯 2021 省 AB2] 国际象棋

## 题目描述

众所周知， “八皇后” 问题是求解在国际象棋棋盘上摆放 $8$ 个皇后，使得两两之间互不攻击的方案数。已经学习了很多算法的小蓝觉得 “八皇后” 问题太简单了，意犹末尽。作为一个国际象棋迷，他想研究在 $N \times M$ 的棋盘上，摆放 $K$ 个马，使得两两之间互不攻击有多少种摆放方案。由于方案数可能很大，只需计算答案除以 $1000000007$ (即 $\left.10^{9}+7\right)$ 的余数。

如下图所示，国际象棋中的马摆放在棋盘的方格内，走 “日” 字, 位于 $(x, y)$ 格的马（第 $x$ 行第 $y$ 列）可以攻击 $(x+1, y+2),(x+1, y-2),(x-1, y+2),(x-1, y-2),(x+2, y+1),(x+2, y-1),(x-2, y+1),(x-2, y-1)$ 共 $8$ 个 格子。

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_68f9131d5c14c1f27e68g-12.jpg)


## 说明/提示

对于 $5 \%$ 的评测用例, $K=1$;

对于另外 $10 \%$ 的评测用例, $K=2$;

对于另外 $10 \%$ 的评测用例, $N=1$;

对于另外 $20 \%$ 的评测用例, $N, M \leq 6, K \leq 5$;

对于另外 $25 \%$ 的评测用例, $N \leq 3, M \leq 20 ， K \leq 12$;

对于所有评测用例, $1 \leq N \leq 6,1 \leq M \leq 100,1 \leq K \leq 20$。 

蓝桥杯 2021 第二轮省赛 A 组 I 题（B 组 J 题）。

## 样例 #1

### 输入

```
1 2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
4 4 3```

### 输出

```
276```

## 样例 #3

### 输入

```
3 20 12```

### 输出

```
914051446```

# 题解

## 作者：lottle1212 (赞：16)

# [原题传送门](https://www.luogu.com.cn/problem/P8756)

## Part 0

这是一道状态压缩 $\text{DP}$。

在尝试此题之前，建议大家先去完成 [P1896 [SCOI2005] 互不侵犯](https://www.luogu.com.cn/problem/P1896)，与此题类似，可以让大家对状态压缩 $\text{DP}$ 有一个初步的了解，也为此题作铺垫。

注：这篇题解并不会非常详细地去讲解状态压缩的原理，只是在 [P1896](https://www.luogu.com.cn/problem/P1896) 的基础上来解决此题。

## Part 1

这一题中，需要我们求在 $N \times M (1 \leq N \leq 6, 1 \leq M \leq 100)$ 的棋盘上摆 $K (1  \leq K \leq 20)$ 个马的方案数。由于 $N$ 不超过 $6$，我们先枚举每一列的 $2 ^ N$ 个放马方案，用 $1$ 表示放马， $0$ 表示不放，并统计每一个放法中 $1$ 的个数（也就是马的个数）。到此为止，做法与 [P1896](https://www.luogu.com.cn/problem/P1896) 完全相同。

接下来就是转移状态了。[P1896](https://www.luogu.com.cn/problem/P1896) 中只需考虑前一行的状态，所以用 **位置**、**方案**、**个数** 来表示答案。而本题需要考虑前两行的状态，需要多加一维，以 **位置**、**前列方案**、**本列方案**、**个数** 来表示答案。

然后通过五层循环 **位置**、**本列方案**、**个数**、**前列方案**、**前前列方案** 来进行状态转移。注意：这里要判断三行中会不会有马互相攻击。最后别忘把答案对 $10^9 + 7$ 取模。

**AC Code**

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod = 1e9 + 7;
const int mxn = 100, mxm = 1 <<6;
const int N = mxn + 10, M = mxm + 10;
int n, m, K, num[M], dp[N][M][M][30], ans;
int get_val(int x) {
	int sum = 0;
	while(x) sum += x & 1, x >>= 1;
	return sum;
} // 求出马的个数
signed main() {
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin >> n >> m >> K;
	for(int i = 0; i ^ (1 << n); ++ i) num[i] = get_val(i), dp[1][0][i][num[i]] = 1; // 预处理马的个数
	for(int i = 2; i <= m; ++ i) // 列
		for(int j = 0; j ^ (1 << n); ++ j) // 本列状态
			for(int h = num[j]; h <= K; ++ h) // 马的个数
				for(int k = 0; k ^ (1 << n); ++ k) // 前前列状态
					for(int l = 0; l ^ (1 << n); ++ l) // 前列状态
						if(! ((j & (k << 1)) || (j & (k >> 1)) || (j & (l << 2)) || (j & (l >> 2)) || (l & (k << 2)) || (l & (k >> 2)))) // 判断条件是否满足
							dp[i][l][j][h] = (dp[i][l][j][h] + dp[i - 1][k][l][h - num[j]]) % mod; //进行转移
	for(int i = 0; i ^ (1 << n); ++ i)
		for(int j = 0; j ^ (1 << n); ++ j)
			ans = (ans + dp[m][i][j][K]) % mod;
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：gesong1234 (赞：7)

题目传送门：[P8756 [蓝桥杯 2021 省 AB2] 国际象棋](https://www.luogu.com.cn/problem/P8756)。
# 思路
这道题由于 $1 \le N \le 6$ 所以我们可以把每一列的状态用 $0$ 或 $1$ 表示，没放马或放马，于是我们就想到了**状态压缩 dp**。

**状态设计**:

$x$ 为这一列的情况，$y$ 为上一列的情况，$z$ 为上上列的情况，$get(x)$ 表示 $x$ 状态中马的个数，$f_{i,j,x,y} $ 表示第 $i$ 列放了 $j$ 个马且当前列的情况为 $x$ ，上一列为 $y$ 的方案数。

**状态初始化**：

$f_{0,0,0,0}=1$ 一开始就有一种情况。

**求马的个数**：

其实就是求二进制中 $1$ 的个数，随便怎么写都可以。
```cpp
int get(int x){
	int ans=0;
	while(x) ans++,x&=x-1;
	return ans;
}
```

**判断是否互相攻击**：

1. 这一列与上一列判断： 

```
*    *
2    *
*    *
*    1
*    *
2    *
*    *
```

如上图，标记为 $1$ 的是马的位置，标记为 $2$ 的是它的攻击范围，所以只要通过左移两位和右移两位来判断是否互相攻击。

所以判断方法为：

```cpp
if (x&(y<<2)||x&(y>>2)) continue;
```
2. 这一列与上上列判断：

```
*    *    *
*    *    *
2    *    *
*    *    1
2    *    *
*    *    *
*    *    *
```
如图，标记为 $1$ 的是马的位置，标记为 $2$ 的是它的攻击范围，所以只要通过左移一位和右移一位来判断是否互相攻击。

所以判断的方法为：
```cpp
if (x&(z<<1)||x&(z>>1)) continue;
```

**方程转移**：

首先我们需要枚举 $j$ ,范围就是 $get(x)+get(y)+get(z)$ 一直到 $K$。方程的转移就可以轻松写出来了，就是加上，上一列去掉这一列马的个数即 $f_{i-1,j-get(x),y,z}$。

所以最后的方程就是 $f_{i,j,x,y}=f_{i,j,x,y}+f_{i-1,j-get(x),y,z}$。

所以最后的答案为所有状态的总和，即：$ans=ans+f_{m,k,i,j}$。$i$ 和 $j$ 是所有状态。

**总体思路**：

先每一列枚举，再枚举这一列状态，上一列状态，判断是否互相攻击，之后再枚举上上列的状态，判断是否互相攻击，最后转移即可。

最后一定要记住**题目要取模**。
# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1000000007;
int f[101][21][1<<6][1<<6];
int get(int x){
	int ans=0;
	while(x) ans++,x&=x-1;
	return ans;
}
main(){
	int n,m,k;
	cin>>n>>m>>k;
	f[0][0][0][0]=1;
	for (int i=1;i<=m;i++)//枚举每一列
		for (int x=0;x<(1<<n);x++)//枚举这一列
			for (int y=0;y<(1<<n);y++){//枚举上一列
				if (x&(y<<2)||x&(y>>2)) continue;
				for (int z=0;z<(1<<n);z++){//枚举上上列
					if (y&(z<<2)||y&(z>>2)) continue;
					if (x&(z<<1)||x&(z>>1)) continue;
					int t=get(x)+get(y)+get(z);
					for (int j=t;j<=k;j++)//方程转移
						f[i][j][x][y]=(f[i][j][x][y]+f[i-1][j-get(x)][y][z])%mod;
				}
			}
	int ans=0;
	for (int i=0;i<(1<<n);i++)
		for (int j=0;j<(1<<n);j++)
			ans+=f[m][k][i][j],ans%=mod;
	cout <<ans;
    return 0;
}

```


---

## 作者：Stone_Xz (赞：5)

## [题目传送门](https://www.luogu.com.cn/problem/P8756)

 - 做这一题之前，可以先去尝试 [P1896 [SCOI2005] 互不侵犯](https://www.luogu.com.cn/problem/P1896)、[P2704 [NOI2001] 炮兵阵地](https://www.luogu.com.cn/problem/P2704)，能更好的掌握状压 DP ，理解本题。

## 题意

> 一个 $n$ 行 $m$ 列的棋盘，在上面摆放 $k$ 个棋子，对于每一个棋子，设它的位置在 $x$ 行 $y$ 列，如果 $(x+1, y+2),(x+1, y-2),(x-1, y+2),(x-1, y-2),(x+2, y+1),(x+2, y-1),(x-2, y+1),(x-2, y-1)$ 八个位置都没有其他棋子，则这个棋子摆放合法。求摆放方案数。

## 分析：状压 DP

 -  状态：$dp[i][j][p][o]$ 表示前 $i$ 行，第 $i$ 行的摆放状态为 $j$，第 $i - 1$ 行的状态为 $p$，且摆了 $o$ 
个马的方案数。

 -  答案：枚举第 $n$ 行和第 $n - 1$ 行的所有摆放状态并累加。

```cpp
for(int i = 0; i < (1 << m); i++)           
	for(int j = 0; j < (1 << m); j++)     
		ans = (ans + dp[n][i][j][k]) % mod;
```

 - 状态转移：

1. 枚举所有状态，并判断状态是否合法。上一行和上上行会影响当前行，要枚举。

```
枚举当前行
	枚举当前行状态
		枚举上一行状态
			枚举上上行状态
				枚举马的数量
					if(状态合法)
						dp累加前一行方案数
```

2. 接下来，只要解决状态是否合法的问题。做题时必须明确，我们想确定一个位置摆上马是否合法，不会被更后面还没枚举到的地方影响，只有前面的地方的情况会影响到当前位置是否合法，而这前面的情况是通过枚举得到的。

3. 通过观察题目给出的图，我们注意到一个位置会被前面四个位置影响，如果这四个位置摆了马，那么当前位置将不能摆，因为如果摆了，将可以攻击到别的马：

![](https://cdn.luogu.com.cn/upload/image_hosting/n8d7tl9v.png)

4. 设当前行状态为 $j$，上一行状态为 $p$，上上行状态为 $x$，我们对于上图的四个位置逐一进行考虑：

①、④：

将 $p$ 右移/左移 两位，令 $j$ 中的每个位置与对应的 ①/④ 对齐，如果此时有两个马对齐，说明有某个马在另一个马的 ①/④ 处，不合法。判断 $j$ 和 $p$ 中是否有两个 $1$ 的位置对齐，可以用 “&” 运算。在代码中为：

```
if((j & (p << 2)) != 0 || (j & (p >> 2)) != 0) 
	不合法，continue;
```

②、③：

同理，将 $x$ 右移/左移一位，令 $j$ 中的每个位置与对应的位置 ②/③ 对齐，如果 $x$ 与 $j$ 有两个 $1$ 的位置对齐，不合法。

```
if((j & (x << 1)) != 0 || (j & (x >> 1)) != 0) 
	不合法，continue;
```

所以，完整的状态转移方程就出来了：

```cpp
for(int i = 1; i <= n; i++)                     // 当前行 
	{
		for(int j = 0; j < (1 << m); j++)           // 当前行摆放状态 
		{
			int cnt = __builtin_popcount(j);        // 当前行马的个数， __builtin_popcount(j)可以求 j 二进制下的 1的个数 
			for(int p = 0; p < (1 << m); p++)       // 上一行摆放状态 
			{
				if((j & (p << 2)) || (j & (p >> 2))) 
					continue;
				for(int x = 0; x < (1 << m); x++)   //  上上行摆放状态
				{
					if((j & (x << 1)) || (j & (x >> 1)))
						continue;
					for(int o = cnt; o <= k; o++)
						dp[i][j][p][o] = (dp[i][j][p][o] + dp[i - 1][p][x][o - cnt]) % mod;
				}
			}
		}
	}
```

 - 初始状态：$dp[0][0][0][0] = 1;$
 
## 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 101, mod = 1e9 + 7;
int n, m, k, ans, dp[N][1 << 6][1 << 6][25];

int main()
{
	cin >> n >> m >> k;
	swap(n, m);
	dp[0][0][0][0] = 1;
	for(int i = 1; i <= n; i++)                     // 当前行 
	{
		for(int j = 0; j < (1 << m); j++)           // 当前行摆放状态 
		{
			int cnt = __builtin_popcount(j);        // 当前行马的个数， __builtin_popcount(j)可以求 j 二进制下的 1的个数 
			for(int p = 0; p < (1 << m); p++)       // 上一行摆放状态 
			{
				if((j & (p << 2)) || (j & (p >> 2))) 
					continue;
				for(int x = 0; x < (1 << m); x++)   //  上上行摆放状态
				{
					if((j & (x << 1)) || (j & (x >> 1)))
						continue;
					for(int o = cnt; o <= k; o++)
						dp[i][j][p][o] = (dp[i][j][p][o] + dp[i - 1][p][x][o - cnt]) % mod;
				}
			}
		}
	}
	for(int i = 0; i < (1 << m); i++)                // 第 n 行摆放状态
		for(int j = 0; j < (1 << m); j++)            // 第 n - 1 行摆放状态 
			ans = (ans + dp[n][i][j][k]) % mod;
	cout << ans; 
	return 0;
}
```

---

## 作者：OIerGuo (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P8756)

~~美好的一年从水题解开始。~~

根据数据范围可知，这是一道状压 DP。

建议大家先尝试 [P2704 [NOI2001] 炮兵阵地](https://www.luogu.com.cn/problem/P2704)，与本题类似。

## 题意

在 $N\times M$ 的棋盘上，摆放 $K$ 个马，求出使得两两之间互不攻击有多少种摆放方案。

## 思路

由于 $1\le N\le 6$，我们考虑状压枚举每一列的放置方案，二进制位为 $1$ 表示放马，$0$ 表示不放，统计每一种放法中 $1$ 的个数（也就是马的个数）。

接下来分析一下 dp 数组的设置：[P2704](https://www.luogu.com.cn/problem/P2704) 仅需要考虑当前位置、前一列枚举方案、本列枚举方案，所以设三维数组，但本题还需要考虑马的个数，因此需要再加一维来表示答案，可得 $dp_{i,j,k,l}$ 表示当前枚举到了第 $i$ 行，这一列状态为 $j$，上一列状态为 $k$，共有 $l$ 颗棋子。

接着五层循环枚举当前枚举到了第几行，这一列状态，上一列状态，上上列状态，前 $i-1$ 列总共放了多少个棋子来转移。这里要判断状态是否合法，也就是马是否会相互攻击。

最后把最后一列棋子个数为 $k$ 的答案相加输出即可。

## 注意事项

- 不要把 $N$ 和 $M$ 搞反。

- 一定要取模 $10^{9}+7$。

## 示例代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int dp[102][(1<<6)+5][(1<<6)+5][25],cnt[(1<<6)+5];
const int MOD=1000000007;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int n,m,K;
	cin>>n>>m>>K;
	dp[0][0][0][0]=1;
	for(int i=0;i<(1<<n);++i){//预处理
		int a=i;
		while(a){
			if(a&1) ++cnt[i];
			a>>=1;
		}
	}
	for(int i=1;i<=m;++i){
		for(int j=0;j<(1<<n);++j){//这一列 
			for(int k=0;k<(1<<n);++k){//上一列 
				if((!(j&(k<<2)))&&(!(j&(k>>2)))){
					for(int l=0;l<(1<<n);++l){//上上列 
						if((!(j&(l<<1)))&&(!(j&(l>>1)))){
							for(int mm=0;mm+cnt[j]<=K;++mm){//前i-1列总共放了多少个棋子
								dp[i][j][k][mm+cnt[j]]=(dp[i][j][k][mm+cnt[j]]+dp[i-1][k][l][mm])%MOD;
							}
						}
					}
				}
			}
		}
	}int sum=0;
	for(int i=0;i<(1<<n);++i){//第m列的状态 
		for(int j=0;j<(1<<n);++j){//第m-1列的状态 
			sum=(sum+dp[m][i][j][K])%MOD;
		}
	}cout<<sum<<endl;
    return 0;
}
```

---

## 作者：dyc2022 (赞：3)

考虑使用状压 dp。

设 $dp_{i,S1,S2,j}$ 表示只考虑前 $i$ 行，第 $i$ 行的状态为 $S1$，第 $i-1$ 行状态为 $S2$，且前 $i$ 行共有 $k$ 个马的方案总数。

其中用一个二进制数来表示每一行的状态。

那么基本流程如下。

1. 枚举行数 $i$。
2. 枚举第 $i$ 行的状态 $S1$。
3. 枚举第 $i-1$ 行的状态 $S2$。
4. 枚举第 $i-2$ 行的状态 $S3$。
5. 枚举前 $i$ 行的马总数 $j$。显然前 $i$ 行的马总数一定不小于 $i$、$i-1$、$i-2$ 行的马的数量总和，因此 $\text{popcnt}(S1)+\text{popcnt}(S2)+\text{popcnt}(S3) \le j \le k$。
6. 转移。在第 $i$ 行分配 $\text{popcnt}(S1)$ 个马之后，要在前 $i-1$ 行分配 $j-\text{popcnt}(S1)$ 个马。

完整代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 8
#define geti(x,i) ((x>>(i-1))&1)
using namespace std;
int dp[128][1<<N][1<<N][25],n,m,k,ans;
int popcnt(int x){
	int ans2=0;
	while(x)ans2++,x&=x-1;
	return ans2;
}
bool judge(int a,int b,int c){
	if(a&(b<<2)||a&(b>>2))return 0;
	if(a&(c<<1)||a&(c>>1))return 0;
	if(b&(c<<2)||b&(c>>2))return 0;
	return 1;
}
main(){
	scanf("%lld%lld%lld",&n,&m,&k);
	if(n<m)swap(n,m);
	dp[0][0][0][0]=1;
	for(int i=1;i<=n;i++){
		for(int S1=0;S1<(1<<m);S1++){
			for(int S2=0;S2<(1<<m);S2++){
				for(int S3=0;S3<(1<<m);S3++){
					if(judge(S1,S2,S3)){
						int cnt=popcnt(S1)+popcnt(S2)+popcnt(S3);
						for(int j=cnt;j<=k;j++){
							dp[i][S1][S2][j]+=dp[i-1][S2][S3][j-popcnt(S1)];
							dp[i][S1][S2][j]%=(int)(1e9+7);
						}
					}
				}
			}
		}
	}
	for(int S1=0;S1<(1<<m);S1++){
		for(int S2=0;S2<(1<<m);S2++){
			ans=(ans+dp[n][S1][S2][k])%(int)(1e9+7);
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：kevin1616 (赞：2)

### 审题
要在一个 $n\times m$ 棋盘上放 $K$ 个马，每两只马不可以互相攻击到。其中每只马可以攻击到走“日”字可以走到的位置。求摆放方案数对 $10^9 + 7$ 取模的结果。
***
### 方法
【暴力】可以枚举每个放马的位置，然后求可行性。此时就会发现时间复杂度很大很大，故该做法不可以通过本题。

【状态压缩 DP】当我们发现最短路无法通过本题时，发现本题的 $n$ 非常小，就可以枚举当前列、上一列中马的摆放情况，同时还需枚举当前列和已经摆放的马的个数。时间复杂度 $O(m\times K\times2^{n})$，是可以通过本题的。
***
### 思路
`dp[i][j][k][l]` 表示当前为第 $i$ 列时，当前列、上一列中马的摆放情况为二进制下的 $j$ 和 $l$，在之前的行里已经摆放了 $k$ 个马时的摆放方案。

首先可以发现马可以跳到上一行左移或右移 $2$ 位的地方。所以 $j$ 和 $l$ 不可以在间隔两位的位置都出现马，即：

```cpp
if(j & (l << 2)) != 0 && (j & (l >> 2)) != 0) continue;
```

其次，我们需要由一个状态来转移到这个状态。很好想到由上一行时的状态转移过来。即：

```cpp
dp[i][j][k][l] = (dp[i][j][k][l] + dp[i - 1][l][k - siz(j)][x]) % MOD;
```

其中 `siz(j)` 是求 $j$ 当中的 $1$ 状态的个数，这是我自己定义的一个函数，当然也有一个 STL 的函数可以求这个东西。这一行代码的意思是：当前状态由在上一列中，由上一列和上上列在二进制下的状态为 $j_0$ 和 $l_0$ 时摆放了 $k_0$ 只马的状态转移得到。由于需要转移，所以当没有当前列时，马的数量需要照样减少，即 $j_0=l$ 且 $l_0=k-siz(j)$。

初始的数值只需要定义在状态最开始的时候，即所有状态都为零的时候。此时应该只有一种可能，即不放马，初始值定为 $1$。

最后的答案就在将当前列和上一列枚举后寻找最终答案。即：

```cpp
for(int i = 0;i < (1 << n);i++){
    for(int j = 0;j < (1 << n);j++) ans = (ans + dp[m][i][K][j]) % MOD;
}
```
***
### 代码
```cpp
#include<bits/stdc++.h>
const int MOD = 1e9 + 7; //模数
using namespace std;
int n,m,K;
int dp[105][(1 << 6)][25][(1 << 6)];
int ans;
int siz(int x){ //二进制数内1的个数
    int cnt = 0;
    while(x){
        if(x & 1) cnt++;
        x >>= 1;
    }
    return cnt;
}
int main(){
    cin >> n >> m >> K;
    dp[0][0][0][0] = 1; //初始化
    for(int i = 1;i <= m;i++){ //当前列
        for(int j = 0;j < (1 << n);j++){ //当前列的放马情况
            for(int k = siz(j);k <= K;k++){ //之前放马的个数
                for(int l = 0;l < (1 << n);l++){ //上一列的放马情况
                    if((j & (l << 2)) == 0 && (j & (l >> 2)) == 0){ //是否移动两格后合法
                        for(int x = 0;x < (1 << n);x++){ //上上列的放马情况
                            if((j & (x << 1)) == 0 && (j & (x >> 1)) == 0){ //是否移动一格后合法
                                dp[i][j][k][l] = (dp[i][j][k][l] + dp[i - 1][l][k - siz(j)][x]) % MOD; //转移方程
                            }
                        }
                    }
                }
            }
        }
    }
    for(int i = 0;i < (1 << n);i++){ //求答案
        for(int j = 0;j < (1 << n);j++) ans = (ans + dp[m][i][K][j]) % MOD;
    }
    cout << ans;
    return 0;
}
```
不抄题解，从我做起！

---

## 作者：Weekoder (赞：2)

### 思路

看到题目描述和数据范围，基本上可以确定是一道状压 DP 题，而且要压列。

首先，我们预处理每个二进制状态 $1$ 的个数 $num_i$。我们可以用 STL 里的函数：`__builtin_popcount(i)` 来获取 $i$ 在二进制下 $1$ 的个数。

状态压缩 DP 第 $1$ 步，设计状态。由于我们要压列，第一维为列数，表示到了第 $i$ 列。第二维为第 $i$ 列的状态。但是，马的攻击范围涉及到了两行，所以我们还要再加一维，表示第 $i-1$ 行的状态。最后，我们还需要一维记录当前选了多少个马。一共 $4$ 维，状态为 $dp_{i,j,k,h}$。

状态压缩 DP 第 $1.5$ 步，初始状态。一个比较方便的方法是：虚拟第 $0$ 行，第 $0$ 行和 $-1$ 行的状态都是 $0$，没有放置任何马，所以第四维也是 $0$。这确实是一种方案，所以有 $dp_{0,0,0,0}=1$。

状态压缩 DP 第 $2$ 步，状态转移。从小问题枚举到大问题，我们先枚举列数 $m$。接着，就是枚举三个状态：当前行，上一行，上上行。再枚举选择的马的数量：至少选 $num_j$ 个（$j$ 为当前行状态)，至多选 $k$ 个（为了避免变量名冲突，我在代码里写的是 $p$）。现在判断状态是否冲突：我们用位移后按位与一下来判断。如果结果是 $0$，就代表不冲突。对于上一行 $k$，不能在左边 $2$ 格或右边 $2$ 格放马。像这样：`!((j & (k << 2)) || (j & (k >> 2)))`。而上上行则不能在左边 $1$ 格或右边 $1$ 格放马，判断方法类似。如果符合条件，就转移。

那么，状态转移方程是什么呢？其实状态压缩 DP 的状态和转移都很工整：这道题是一道 DP 计数题，那么我们就要在原先的基础上加上一个数并取模。这个数是多少呢？其实就是从上一行转移而来的状态，我们要填写这个状态的四个维度。第一维，由于是上一行，肯定是 $i-1$。第二维，就是上一行的状态 $k$。第三维，是上一行的上一行的状态，刚好就是枚举的 $x$。第四维，由于我们枚举到要选 $h$ 个马，而这一行又有 $num_j$ 个马，所以上一个状态是 $h-num_j$。总结一下，状态转移方程为：

$$
dp_{i,j,k,h}=(dp_{i,j,k,h}+dp_{i-1,k,x,h-num_j})\bmod(10^9+7)
$$

状态压缩 DP 第 $3$ 步，获取答案。由于第一维的 $m$ 和第四维的 $p$ 已经确定了，我们只需要枚举两个状态，求和即可。

完整代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 6, Mod = 1e9 + 7;

int n, m, p, dp[105][1 << N][1 << N][25], num[1 << N];

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> n >> m >> p;
	for (int i = 0; i < (1 << n); i++)
		num[i] = __builtin_popcount(i);
	dp[0][0][0][0] = 1;
	for (int i = 1; i <= m; i++)
		for (int j = 0; j < (1 << n); j++) // 当前行 
			for (int k = 0; k < (1 << n); k++) // 上一行
				for (int x = 0; x < (1 << n); x++) // 上上行 
					for (int h = num[j]; h <= p; h++) // 选马的数量
						if (!((j & (k << 2)) || (j & (k >> 2)) || (j & (x << 1)) || (j & (x >> 1)))) 
							dp[i][j][k][h] = (dp[i][j][k][h] + dp[i - 1][k][x][h - num[j]]) % Mod;
	int ans = 0;
	for (int j = 0; j < (1 << n); j++)
		for (int k = 0; k < (1 << n); k++)
			ans = (ans + dp[m][j][k][p]) % Mod;
	cout << ans;
	return 0;
}
```

---

## 作者：mysterys (赞：1)

# 前言
状态压缩好题，建议先做完 [P1896互不侵犯](https://www.luogu.com.cn/problem/P1896) 再来做这道题。
# 思路
1. 发现 $n$ 很小，加上是经典的棋盘摆放问题，考虑状态压缩 dp。
1. 注意到 $1 \leq N \leq 6，1 \leq M \leq 100 $ 所以可以将 $n$ 与 $m$ 交换，方便枚举行。
1. **注意需要取模**
# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define endl '\n'
const int M=(1<<6)+10;
const int MOD=1e9+7;
int s[M],n,m,K,cnt;
int f[105][25][M][M];
inline int get(int x){//返回二进制中1的个数。
	int t=0;
	while(x>0){
		++t;
		x-=(x&(-x));
	}
	return t;
}
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cout.tie(nullptr);
	cin>>n>>m>>K;swap(n,m);
	int up=(1<<m)-1;//上界
	for(int i=0;i<=up;i++){
		s[i]=get(i);
		f[1][s[i]][i][0]=1;
	}
	for(int t=2;t<=n;t++){
		for(int i=0;i<=K;i++){
			for(int j=0;j<=up;j++){
				if(s[j]>i) continue;
				for(int k=0;k<=up;k++){
					if(s[j]+s[k]>i||((j<<2)&k)||((j>>2)&k)) continue;
					for(int k1=0;k1<=up;k1++)
					{
						if(s[k]+s[k1]>i-s[j]) continue;
						if(((k<<2)&k1)||((k>>2)&k1)) continue;
						if(((j<<1)&k1)||((j>>1)&k1)) continue;
						f[t][i][j][k]=(f[t][i][j][k]+f[t-1][i-s[j]][k][k1])%MOD;
					}
				}
			}
		}
	}
	int ans=0;
	for(int i=0;i<=up;i++)for(int j=0;j<=up;j++)
		ans=(ans+f[n][K][i][j])%MOD;
	cout<<ans%MOD;
	return 0;
}
```

---

## 作者：Flaw_Owl (赞：1)

# 题目定性

典型的状压 DP 应用，我把它称之为棋子问题：在给定的地图上放置棋子，但棋子间有互相制约的条件，求解一系列问题。

**针对地图**，有时候会限制只有某些地块可以放。只需用 $1$ 和 $0$ 来表示地块是否可以放置，在计算答案的时候直接加上地块的值即可。

**针对棋子**，其制约方式五花八门，但不外乎可以总结为：

```cpp
if((S & (S << x)) == 0 || (S & (S >> x)) == 0)
```

其中，$S$ 表示当前行的状态，$x$ 表示某一行与该行发生“重叠”需要的距离。在本题中，对于任意一个马，它的上一行状态若向左或向右移动 $2$ 格，在该列上两个棋子就会发生“重叠”，被认定是不合法的放置。

**针对问题**，可以是询问最多放置多少颗棋子；也可以是询问放置给定颗棋子的前提下，最多有多少种方案。

建议先完成：

[P2704 炮兵阵地](https://www.luogu.com.cn/problem/P2704)：适合入门的棋子问题。棋子的制约条件横跨两行，可以先熟悉状压 DP 的公式写法。

[P1896 互不侵犯](https://www.luogu.com.cn/problem/P1896)：和本题一样都是询问多少种方案，但棋子的制约条件只有一行，可以先熟悉如何解决方案数量类问题。

本题可以认为是上述两种问题的综合。

# 棋子问题的公式解法

完成上面两道题后，我们可以总结出这类问题的公式解。但只能完成一些最基础的问题，细节仍需打磨。

## 设计 DP 状态

DP 中必然有一维用来存储当前枚举到第几行。接下来观察棋子的制约条件，跨度有几行就要设计几维状态存储。最后是看询问，如果询问的是解决方案，则还要增加一维用来存储目前用了多少颗棋子。

在本题中，马最远可以打到它前面两行的目标，同时又询问了方案数量，可以设计为 `dp[i][x][y][k]`。表示枚举到第 $i$ 行，第 $i$ 行的状态为 $x$，第 $i-1$ 行的状态为 $y$，且用了 $k$ 颗棋子的状态下所用的方案数。

## 状态转移方程

两种问题的状态转移方程都由上一行转移而来。

放置数量问题可以抽象为：

$$f(这一行) = \max \{f(上一行) + 上一行新放的\}$$

方案数量问题可以抽象为：

$$f(这一行) += f(上一行)$$

值得注意的是，在方案数量问题中对于当前使用数量 $k$ 的转移比较有趣，直接枚举 $k$，如果超过了当前状态所放置的士兵量就视为有效，加入转移。具体实现可以看下面的代码。

## 初始化函数

其中会用到两个数组：

1. `sta[i]` 表示编号为 $i$ 的状态表示
2. `cnt[i]` 表示状态 $i$ 使用的棋子数目

```cpp
// 针对地图限制的题型时，下文的 while 需要用 for 来匹配地图是否可以部署棋子。这里 n 并没有用到，笔者只是习惯性加上。
int init_line(int n) 
{
    int M = 0;
    for (int i = 0; i < (1 << m); i++)
    {
        int tot = 0, s = i;
        while (s)
        {
            if (s & 1)
                tot++;
            s >>= 1;
        }
        cnt[i] = tot;
        sta[M++] = i;
    }
    return M;
}
```

## 主函数

这个过程可以概括为：

1. 额外处理第 $0$ 行。
2. 枚举第 $i$ 行的状态。
3. 枚举第 $i-1$ 行的状态。
4. 判断是否合法。
5. ……如果限制条件更多，则继续循环下去。
6. 枚举 $k$，动态转移。
7. 整理答案。

# AC 代码

部分变量命名可能与上文不同。

```cpp
#include <iostream>
#include <cctype>
#include <string.h>

using namespace std;

// 快读
int read()
{
    int x = 0, f = 1;
    char ch = 0;
    while (!isdigit(ch))
    {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (isdigit(ch))
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}

const int maxN = (1 << 6) + 5;
const int mod = 1e9 + 7;

int n, m, K;

int dp[105][maxN][maxN][maxN];
int sta[maxN]; // 表示
int cnt[maxN];

int init_line(int n)
{
    int M = 0;
    for (int i = 0; i < (1 << m); i++)
    {
        int tot = 0, s = i;
        while (s)
        {
            if (s & 1)
                tot++;
            s >>= 1;
        }
        cnt[i] = tot;
        sta[M++] = i;
    }
    return M;
}

int main()
{
    m = read();
    n = read();
    K = read();
    int M = init_line(n);
    dp[0][0][0][0] = 1;
    for (int j = 0; j < M; j++)
        dp[0][j][0][cnt[sta[j]]] = 1;
    for (int i = 1; i < n; i++)
        for (int j = 0; j < M; j++)     // 第 i 行
            for (int k = 0; k < M; k++) // 第 i-1 行
            {
                if ((sta[j] & (sta[k] << 2)) || (sta[j] & (sta[k] >> 2)))
                    continue;
                for (int p = 0; p < M; p++)
                {
                    if ((sta[k]) & (sta[p] << 2) || (sta[k]) & (sta[p] >> 2))
                        continue;
                    if ((sta[j] & (sta[p] >> 1)) || (sta[j] & (sta[p] << 1)))
                        continue;
                    for (int q = 0; q <= K; q++)
                        if (q >= cnt[sta[j]])
                        {
                            dp[i][j][k][q] = (dp[i][j][k][q] + dp[i - 1][k][p][q - cnt[sta[j]]]) % mod;
                        }
                }
            }

    long long ans = 0;
    for (int i = 0; i < M; i++)
        for (int j = 0; j < M; j++)
            ans = (ans + dp[n - 1][i][j][K]) % mod;
    printf("%lld\n", ans);
}
```

---

## 作者：xiaoyang111 (赞：1)

### 前言

[题面。](https://www.luogu.com.cn/problem/P8756)

[可能更好的阅读体验。](https://www.luogu.com.cn/blog/xiaoyang111/p8756-lan-qiao-bei-2021-xing-ab2-guo-ji-xiang-qi-ti-xie)

### 分析

看题上的图，我们可以知道，这个马被攻击到只和上两列相关。

我们看 $N$ 和 $M$ 的范围，就知道是状压 dp 题。由于 $N$ 太小了，$M$ 太大了，可以知道我们要压列。状态如果此位有马，就为 1，否则为 0，把这些用二进制弄起来，就是一个数，这就是这一列的状态，这就是状态压缩的思想。

怎么设计 dp 数组的状态定义呢？

显然，dp 数组是四维的，``dp[i][a][b][k]`` 为放到第 $i$ 列，第 $i-1$ 列的状态是 $a$，第 $i-2$ 的状态是 $b$，放完第 $i$ 列已经放了 $k$ 个马，方案数是 ``dp[i][a][b][k]``。

这里要注意，边界是 ``dp[0][0][0][0]=1``。

那么，我们怎么判断有没有攻击到呢？

设第 $i$ 列的状态是 $c$，第 $i-1$ 列的状态是 $b$，第 $i-2$ 列的状态为 $a$，那么如果满足 ``(c&(b<<2))==0 && (c&(b>>2))==0 && (c&(a<<1))==0 && (c&(a<<1))==0`` 的时候就不会被攻击，就可以加转移方程了。

如何理解不会攻击的式子？

首先看第 $i$ 列和第 $i-1$ 列，自然就可以理解第 $i$ 列和第 $i-2$ 列自然就可以理解。

假如摆的形式是这样的，0 为空，1 为马：

```
0 0 1      第 i-1 列
1 0 0      第 i 列
```

这个时候如果直接算比较困难，我们可以直接左移 $2$ 位对齐，如果有两个重在一起了，就说明可以攻击到，如果没对齐就说明攻击不到。右移也是一样的。

最后，要记得模数。

### 代码

知道了这些，就可以写代码了。

```cpp
#include <iostream>
#include <vector>
using namespace std;
const int MOD=1e9+7;
int main(){
	int n,m,k;
	cin >> n >> m >> k;
	vector<vector<vector<vector<int>>>> dp(m+1,//m列 
			vector<vector<vector<int>>>(1<<n,//这里就表示的是2^n状压的状态数 
					vector<vector<int>>(1<<n,//这里就表示的是2^n状压的状态数 
							vector<int>(k+1/*这里要+1*/,0))));
	auto count=[&n](int num){//算这列放了多少马 
		int ans=0;
		for (int i=0;i<n;++i){
			ans+=(num>>i)&1;
		}
		return ans;
	};
	dp[0][0][0][0]=1;//边界 
	for (int i=1;i<=m;++i){
		for (int a=0;a<(1<<n);++a){
			for (int b=0;b<(1<<n);++b){
				if (a&(b<<2) || a&(b>>2)){//为了小剪枝写成这样 
					continue;
				}
				for (int c=0;c<1<<n;++c){
					if (c&(b<<2) || c&(b>>2) || c&(a<<1) || c&(a>>1)){//为了小剪枝写成这样 
						continue;
					}
					int t=count(c);
					for (int u=t;u<=k;++u){
						dp[i][b][c][u]=(dp[i][b][c][u]+
										dp[i-1][a][b][u-t])%MOD;
					}
				}
			}
		}
	}
	int sm=0;
	for (int i=0;i<1<<n;++i){//把所有的状态的方案数加起来 
		for (int j=0;j<1<<n;++j){
			sm=(sm+dp[m][i][j][k])%MOD;
		}
	}
	cout<<sm<<endl;
	return 0;
} 
```

### 结语

感谢您能看到这里，建议做 [P1896](https://www.luogu.com.cn/problem/P1896) 这道题练习一下。

---

## 作者：ccjjxx (赞：1)

## P8756 [蓝桥杯 2021 省 AB2] 国际象棋 题解

纪念第一道完全自己写出来的状压。

我们观察到每行的每个状态都与上一行和上上一行有关，并且题目要求计算总共摆 $K$ 个马的方案数，因此本题就像是[互不侵犯](https://www.luogu.com.cn/problem/P1896)和[炮兵阵地](https://www.luogu.com.cn/problem/P2704)的结合体。

定义状态 $dp[i][s1][s2][j]$ 表示当前第 $i$ 行，本行状态为 $s1$，上行状态为 $s2$，已经摆了 $j$ 个马，可以得到状态转移方程：
$$
dp[i][s1][s2][j]+=dp[i-1][s2][s3][j-cnt[s1]]
$$
其中 $cnt[s]$ 表示状态 $s$ 含有的 $1$ 的个数。

由**炮兵阵地**那道题我们可以知道第一行和第二行需要预处理，因为特殊。
```cpp
for(int i=0;i<(1<<n);i++) dp[1][i][0][cnt[i]]=1;
for(int s1=0;s1<(1<<n);s1++)
{
	for(int s2=0;s2<(1<<n);s2++)
	{
		if((s1&(s2<<2))|(s1&(s2>>2))) continue;
		for(int j=0;j<=k;j++)
		{
			if(j-cnt[s1]>=0)
				dp[2][s1][s2][j]+=(dp[1][s2][0][j-cnt[s1]]); 
		}
	}
}
```
在转移时我们要注意判断是否合法，按照题目中给出的图去做就好了。

这里给出一个思考题：

判合法时需要看上一行状态 $s2$ 和上上一行状态 $s3$，并且和 $s1$ 取与（具体请看代码），那么，**为什么不能、也不需要 $s2$ 和 $s3$ 比较？**

答案是这样的：如果 $s2$ 和 $s3$ 比较了，就会使得一部分你要用到的 $dp[i-1][...][...][...]$ 被干掉，即是会把原本合法的状态判非法。

~~我就是这个思考了半个小时~~。

在代码的最后，统计第 $m$ 行的所有方案之和即可。

以及，**别别别忘了取模！**

完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
const int mod=1e9+7;
int cnt[(1<<6)+1];
int dp[101][(1<<6)+1][(1<<6)+1][21];
inline int lowbit(int x)
{
	return x&-x;
}
int main()
{
	cin>>n>>m>>k;
	for(int s=0;s<(1<<n);s++)
	{
		for(int tmp=s;tmp;tmp-=lowbit(tmp))//计算 cnt 数组，lowbit 每次会找到这个数最低一个 1。
		++cnt[s];
	}
	for(int i=0;i<(1<<n);i++) dp[1][i][0][cnt[i]]=1;//第一行处理
	if(m>1){//防止被卡
	for(int s1=0;s1<(1<<n);s1++)
	{
		for(int s2=0;s2<(1<<n);s2++)
		{
			if((s1&(s2<<2))|(s1&(s2>>2))) continue;
			for(int j=0;j<=k;j++)
			{
				if(j-cnt[s1]>=0)
				dp[2][s1][s2][j]+=(dp[1][s2][0][j-cnt[s1]]);//第二行处理
			}
		}
	}
	if(m>2){//防止被卡
	for(int i=3;i<=m;i++)
	{
		for(int s1=0;s1<(1<<n);s1++)
		{
			for(int s2=0;s2<(1<<n);s2++)
			{
				if((s1&(s2<<2))|(s1&(s2>>2))) continue;//判断上一行是否合法。
				for(int s3=0;s3<(1<<n);s3++)
				{
				//	if((s2&(s3<<1))|(s2&(s3>>1)))continue; 这里就是上面说的那个思考题，删掉注释只有 5 分。
					if((s1&(s3<<1))|(s1&(s3>>1))) continue;//判断上上一行是否合法。
					for(int j=0;j<=k;j++)
					{
						if(j-cnt[s1]>=0)//防止 RE。
						dp[i][s1][s2][j]+=(dp[i-1][s2][s3][j-cnt[s1]]);
						dp[i][s1][s2][j]%=mod;
					}
				}
			}
		}
	}
	}}
	long long ans=0;
	for(int s1=0;s1<(1<<n);s1++)
	{
		for(int s2=0;s2<(1<<n);s2++)
		{
			if((s1&(s2<<2))|(s1&(s2>>2))) continue;
			ans+=dp[m][s1][s2][k];
			ans%=mod;
		}
	}
	cout<<ans;
}
```
也可以加一个滚动数组优化时空，能减少 30MB 空间和 200ms 时间。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
const int mod=1e9+7;
int cnt[(1<<6)+1];
int dp[2][(1<<6)+1][(1<<6)+1][21];
int r=0;
inline int lowbit(int x)
{
	return x&-x;
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(register int s=0;s<(1<<n);s++)
	{
		for(int tmp=s;tmp;tmp-=lowbit(tmp))
		++cnt[s];
	}
	for(register int i=0;i<(1<<n);i++) dp[0][i][0][cnt[i]]=1;
	for(register int s1=0;s1<(1<<n);s1++)
	{
		for(register int s2=0;s2<(1<<n);s2++)
		{
			if((s1&(s2<<2))|(s1&(s2>>2))) continue;
			for(register int j=0;j<=k;j++)
			{
				if(j-cnt[s1]>=0)
				dp[1][s1][s2][j]+=(dp[0][s2][0][j-cnt[s1]]); 
			}
		}
	}
	r=1;
	for(register int i=3;i<=m;i++)
	{
		r^=1;
		memset(dp[r],0,sizeof(dp[r]));
		//因为在转移时状态覆盖的不完全，因此不初始化会有可能带上之前的状态。 
		for(register int s1=0;s1<(1<<n);s1++)
		{
			for(register int s2=0;s2<(1<<n);s2++)
			{
				if((s1&(s2<<2))|(s1&(s2>>2))) continue;
				for(register int s3=0;s3<(1<<n);s3++)
				{
				//	if((s2&(s3<<1))|(s2&(s3>>1)))continue;
					if((s1&(s3<<1))|(s1&(s3>>1))) continue;
					for(register int j=0;j<=k;j++)
					{
						if(j-cnt[s1]>=0)
						dp[r][s1][s2][j]+=(dp[r^1][s2][s3][j-cnt[s1]]);
						dp[r][s1][s2][j]%=mod;
					}
				}
			}
		}
	}
	long long ans=0;
	for(register int s1=0;s1<(1<<n);s1++)
	{
		for(register int s2=0;s2<(1<<n);s2++)
		{
			if((s1&(s2<<2))|(s1&(s2>>2))) continue;
			ans+=dp[r][s1][s2][k];
			ans%=mod;
		}
	}
	cout<<ans;
}
```

---

## 作者：_qingshu_ (赞：1)

# 题意：

给定一个 $n \times m$ 的棋盘，求按照国际象棋规则放置 $k$ 匹马有多少种方案？

# 思路解析：

看到 $1 \le n \le 6$，考虑状压 DP。

因为本题需要考虑前前列的状态和总共放置了多少个？所以构建一个四维 DP。

我们定义 $dp[a][b][c][d]$ 为给状态下的方案数，其中 $a$ 表示在第几列，$b$ 表示总共放置了多少个马，$c$ 表示当前列的状态，$d$ 表示前列状态。

# 状态转移:

在本题中状态转移方程并不复杂，就不在这里现推了，如果不理解的可以手模一下。

```cpp
dp[i][d][j][q]=dp[i][d][j][q]+dp[i-1][d-x][q][p]
```

其中 $i$ 是遍历到第几行，$d$ 是总共放置了多少马，$j$ 是当前列状态，$q$ 是前一列状态，$p$ 是前前列状态。$x$ 是当前状态中有多少个 $1$。

# code:

```cpp
#include<bits/stdc++.h>
#define mod 1000000007
using namespace std;
int n,m,k;
long long dp[110][21][1<<7][1<<7];
//当前列，总共摆放了多少马，本列状态，前列状态的方案数
int num[1<<7];
int getnum(int x){
	int res=0;
	while(x!=0){
		res+=x&1;
		x>>=1;
	}
	return res;
} 
long long ans;
int main(){
	cin>>n>>m>>k;
	for(int i=0;i<(1<<n);i++){
		num[i]=getnum(i);
		dp[1][num[i]][i][0]=1;
	}
	for(int i=2;i<=m;i++){//第几列 
		for(int j=0;j<(1<<n);j++){//当前列状态 
			for(int d=getnum(j);d<=k;d++){//总共摆放了多少个？ 
				for(int q=0;q<(1<<n);q++){//前一列状态 
					for(int p=0;p<(1<<n);p++){//前前列状态 
						int x=num[j];
						if(!(j&(q>>2))&&!(j&(q<<2))&&!(j&(p>>1))&&!(j&(p<<1))){
							dp[i][d][j][q]+=dp[i-1][d-x][q][p];
							dp[i][d][j][q]%=mod;
						}
					}
				}
			}
		}
	}
	for(int i=0;i<(1<<n);i++){
		for(int j=0;j<(1<<n);j++){
			ans+=dp[m][k][i][j];
			ans%=mod;
		}
	}
	cout<<ans;
} 
```

update:

23.12.13：修改了中文与英文之间缺少空格。

23.12.14：修改了公示内使用代码语言。

23.12.18：修改了 $1$ 没有使用 $\LaTeX$ 的问题。

23.12.18：修改了公式为代码格式。

---

## 作者：Strelitzia_ (赞：1)

## 题目大意

八皇后问题，不过这里的皇后是马，走日字。求方案数。

------------
## 思路

状态压缩。注意到 $n$ 很小，我们就压缩每一列的状态，用 $1$ 表示有马，否则没有。

由于前两行的状态都会影响到这一列的状态（前两列的马都可以吃到这一列的马），所以我们在统计方案数时要记录前两行的状态。

我们用 $f_{i,s_1,s_2,k}$ 表示当前考虑的是第 $i$ 行，这一行的状态是 $s_1$，上一行的状态是 $s_2$，当前一共放了 $k$ 个马。我们发现我们并不能直接得知与当前 $s_1,s_2$ 相匹配的 $k$，但题目中给定的 $k$ 很小，同样可以枚举。于是我们有如下转移方程：

$$f_{i,s_1,s_2,k+\text{cnt}(s_1)}=f_{i,s_1,s_2,k+\text{cnt}(s_1)}+f_{i-1,s_2,s_3,k}$$

其中，$k$ 是上文提到的枚举的 $k$，$\text{cnt}(s_1)$ 表示 $s_1$ 这个状态中马的数量，$s_1,s_2,s_3$ 是合法的连续三行的状态。

如何判断这三个状态合不合法呢？马可以调到上一列的向左向右分别两行的位置或调到上上列的向左向右分别两行的位置，所以我们把 $s_2$ 左移、右移两位，$s_1$ 左移、右移一位判断即可。具体如下：

```cpp
bool pd(int s1, int s2, int s3) {
	return (s1 & (s2 << 2) || s1 & (s2 >> 2) || s1 & (s3 << 1) || s1 & (s3 >> 1) || s2 & (s3 << 2) || s2 & (s3 >> 2));
}
```

在第一列，由于马无法攻击同一列的马，所以怎么放都是合法的，特判即可。在最后统计答案时对所有合法的 $s_1,s_2$ 都要累计。

总复杂度 $O(mk2^{3n})$，可过。可以将每个状态的马的数量先记录下来节省时间。

代码如下：

```cpp
#define Strelitzia_H 0
int n, m, k, f[101][1 << 6][1 << 6][21], cnt[1 << 6], ans;
bool pd(int s1, int s2, int s3) {
	return (s1 & (s2 << 2) || s1 & (s2 >> 2) || s1 & (s3 << 1) || s1 & (s3 >> 1) || s2 & (s3 << 2) || s2 & (s3 >> 2));
}
int getcnt(int nows) {
	int nowcnt = 0;
	while (nows) nowcnt += (nows & 1), nows >>= 1;
	return nowcnt;
}
signed main() {
	n = read(), m = read(), k = read();
	for (int i = 0; i < (1 << n); i++) cnt[i] = getcnt(i);
	for (int i = 0; i < (1 << n); i++) if (cnt[i] <= k) f[1][i][0][cnt[i]] = 1;
	for (int s1 = 0; s1 < (1 << n); s1++) for (int s2 = 0; s2 < (1 << n); s2++)
			if (!pd(s1, s2, 0) && cnt[s1] + cnt[s2] <= k)
				f[2][s1][s2][cnt[s1] + cnt[s2]] = (f[2][s1][s2][cnt[s1] + cnt[s2]] + f[1][s2][0][cnt[s2]]) % mod3;
	for (int i = 3; i <= m; i++)
		for (int s1 = 0; s1 < (1 << n); s1++)
			for (int s2 = 0; s2 < (1 << n); s2++)
				for (int s3 = 0; s3 < (1 << n); s3++) {
					if (pd(s1, s2, s3) || cnt[s1] + cnt[s2] + cnt[s3] > k) continue;
					for (int nowk = cnt[s2] + cnt[s3]; nowk + cnt[s1] <= k; nowk++)
						f[i][s1][s2][nowk + cnt[s1]] = (f[i][s1][s2][nowk + cnt[s1]] + f[i - 1][s2][s3][nowk]) % mod3;
				}
	for (int s1 = 0; s1 < (1 << n); s1++) for (int s2 = 0; s2 < (1 << n); s2++)
			ans = (ans + f[m][s1][s2][k]) % mod3;
	return printf("%lld", ans), Strelitzia_H;
}
```

---

## 作者：_WRYYY_ (赞：0)

[博客观看获取更佳体验](https://www.cnblogs.com/wryyy-233/p/18091279)

设计状态什么的就不讲了，这里是对其它题解的优化。

怎么优化呢，我们可以知道的是我们只要明确了当前行的状态，上一行的可选集就是知道的，如果我们明确了当前行以及上一行的状态，那么上上行的可选集就是知道的，于是我们就可以使用二进制子集枚举来写，这样就减去了全部不合法的枝叶，我们可以保证遍历到的三行的状态都是合法的。

当然要这样写就需要先预处理出某一个状态会攻击到的状态，也不难。

最后加上滚动数组并且不用 ``ll`` 就可以喜提最优解（204ms）。

```cpp
#include <bits/stdc++.h>
#include <bits/extc++.h>
#define ll long long
#define ull unsigned long long
#define m_p make_pair
#define m_t make_tuple
#define inf (0x7f7f7f7f)
#define N 300010
using namespace std;
using namespace __gnu_pbds;
const ll MOD = 1e9 + 7;
int atk[100][2], bitc[100];
int dp[2][80][80][30];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	int n, m, K, rn, x1, x2, con, num, nw = 0;
	cin >> n >> m >> K;
	rn = 1 << n;
	--rn;
	for (int ic = 1; ic <= rn; ic++)
		for (int j = 0; j < n; j++)
			if ((1 << j) & ic)
			{
				++bitc[ic];
				x1 = j - 1;
				x2 = j + 1;
				if (x1 >= 0)
					atk[ic][1] |= (1 << x1);
				if (x2 < n)
					atk[ic][1] |= (1 << x2);
				--x1;
				++x2;
				if (x1 >= 0)
					atk[ic][0] |= (1 << x1);
				if (x2 < n)
					atk[ic][0] |= (1 << x2);
			}
	dp[0][0][0][0] = 1;
	int bc1, bc2;
	for (int i = 1; i <= m; i++)
	{
		nw ^= 1;
		memset(dp[nw], 0, sizeof dp[nw]);
		for (int c3 = 0; c3 <= rn; c3++)
		{
			bc2 = rn ^ atk[c3][0];
			num = bitc[c3];
			for (int c2 = bc2;; c2 = (c2 - 1) & bc2)
			{
				bc1 = rn ^ (atk[c3][1] | atk[c2][0]);
				for (int c1 = bc1;; c1 = (c1 - 1) & bc1)
				{
					for (int k = K; k >= num; k--)
						dp[nw][c3][c2][k] = (1ll*dp[nw][c3][c2][k] + 1ll*dp[nw ^ 1][c2][c1][k - num]) % MOD;
					if (!c1)
						break;
				}
				if (!c2)
					break;
			}
		}
	}
	int ans = 0;
	for (int i = 0; i <= rn; i++)
		for (int j = 0; j <= rn; j++)
			ans = (1ll*ans + 1ll*dp[nw][i][j][K]) % MOD;
	cout << ans;
	return 0;
}
```

---

## 作者：__Star_Sky (赞：0)

## Description

给定一个 $n\times m$ 的棋盘，求在这个棋盘上放 $k$  个马的方案数。这里的马是国际象棋的马。

其中 $n\le6,m\le100,k\le20$。

## Solution
注意到 $n$ 的范围只有 $6$，显然可以状态压缩动态规划。我们用一个二进制数 $x$ 表示第 $i$ 行的状态，$x$ 的从左到右第 $j$ 位为 $1$ 表示在第 $i$ 行第 $j$ 列放了马，为 $0$ 表示不放。可是 $m$ 的范围达到了 $100$，每一行的状态数高达 $2^{100}$ 种，显然不能这样压缩状态，但是按列来压缩状态又过于繁琐。注意到在 $n\times m$ 的棋盘上的方案数和在 $m\times n$ 的棋盘上的方案数是相等的，所以可以先将 $n,m$ 互换。这样一来每一行的状态就只有 $2^6$ 种了。

假设我们当前 dp 到第 $t$ 行，第 $t$ 行某个位置能不能放马和第 $t-1$ 和 $t-2$ 行的状态都有关。第 $t$ 行能放的马的数量和前面 $t-1$ 行已经放的马的数量有关。于是就可以设计出状态了：设 $f_{t,i,j,k}$ 表示当前在第 $t$ 行，前 $t$ 行总共放置了 $i$ 个马，第 $t$ 行状态为 $j$，第 $t-1$ 行状态为 $k$ 时的总方案数。设 $g(x)$ 表示 $x$ 的二进制表示中 $1$ 的个数。状态转移方程：
$$f_{t,i,j,k}=\sum\limits_{k_1=0}^{2^m-1}f_{t-1,i-g(j),k,k_1}$$

那么如何判断某两个状态之间能否转移呢？首先显然有第 $i,i-1,i-2$ 行放的马的总数不超过前 $i$ 行放的马的总数。其次，需要满足每一行之间马和马不能互相攻击。

具体而言，可以这样写：
```
bool check(int i,int j,int k,int k1)
{
	if(g(j)+g(k)+g(k1)>i) return false;
	if((j<<1)&k1) return false;//第t行和第t-2行
	if((j>>1)&k1) return false;//第t行和第t-2行
	if((j>>2)&k) return false;//第t行和第t-1行
	if((j<<2)&k) return false;//第t行和第t-1行
	if((k>>2)&k1) return false;//第t-1行和第t-2行
	if((k<<2)&k1) return false;//第t-1行和第t-2行
	return true;
}

```
这几条判断语句根据题目中给出的国际象棋马的走法很好理解，这里就不赘述了。要注意这里的 $j,k,k_1$ 我们都是站在二进制的角度去看的。最终的答案就是:
$$\sum\limits_{i=0}^{2^m-1}\sum\limits_{j=0}^{2^m-1}f_{n,k,i,j}$$

由于对于不合法的状态，方案数一定为为 $0$，因此最后统计答案时直接相加即可。

时间复杂度 $O(2^{3n}mk)$，但由于有很多不合法状态，所以实际远远达不到这个数。

## Code
```
#include<bits/stdc++.h>
#define lowbit(x) x&-x
using namespace std;
const int N=101,MAXK=21,M=1<<6;
const int mod=1e9+7;
int f[N][MAXK][M][M],g[M];
int pop_cnt(int x)
{
	int res=0;
	while(x) res++,x-=lowbit(x);
	return res;
}
int main()
{
	int n,m,K;
	scanf("%d%d%d",&n,&m,&K);
	swap(n,m);
	for(int i=0;i<=(1<<m)-1;i++) g[i]=pop_cnt(i);
	for(int i=0;i<=(1<<m)-1;i++) f[1][g[i]][i][0]=1;
	for(int t=2;t<=n;t++)
	{
		for(int i=0;i<=K;i++)
		{
			for(int j=0;j<=(1<<m)-1;j++)
			{
				if(g[j]>i) continue;
				for(int k=0;k<=(1<<m)-1;k++)
				{
					if(g[j]+g[k]>i||((j<<2)&k)||((j>>2)&k)) continue;
					for(int k1=0;k1<=(1<<m)-1;k1++)
					{
						if(g[k]+g[k1]>i-g[j]) continue;
						if(((k<<2)&k1)||((k>>2)&k1)) continue;
						if(((j<<1)&k1)||((j>>1)&k1)) continue;
						f[t][i][j][k]=(f[t][i][j][k]+f[t-1][i-g[j]][k][k1])%mod;
					}
				}
			}
		}
	}
	int ans=0;
	for(int i=0;i<=(1<<m)-1;i++) for(int j=0;j<=(1<<m)-1;j++) ans=(ans+f[n][K][i][j])%mod;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Suite_No1_G (赞：0)

题目大意：

在 $n$ 行 $m$ 列的棋盘上放 $k$ 个马，使得他们两两之间互补攻击。求方案数，对 $10^9 + 7$ 取模。

分析：

观察数据范围，$N ≤ 6$，$M ≤ 100$，所以可以考虑状态压缩 dp。

$N$ 的数据范围很小，所以可以将 $N$ 进行状压，然后递推 $M$ 列。

设 $dp_i,_j,_k,_l$ 表示考虑到第 $i$ 列，第 $i$ 列的状态为 $j$ ，第 $i - 1$ 行的状态为 $k$，共放了 $l$ 个马。

转移第 $i$ 行时，发现还需要枚举第 $i - 2$ 行的状态，所以需要判断第 $i$ 行，第 $i - 1$ 行，第 $i - 2$ 行之间是否合法。

最后，答案为 $dp_{m-1},_i,_j,_k$，$i$ 和 $j$ 是枚举的最后一行和倒数第二行的状态。记得判断这两行是否合法。

code：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

//dp[i][j][k][l]表示第i行，第i行状态为j，第i-1行状态为k，放了l个马 
const int maxn=110,maxm=8;
int dp[maxn][1<<maxm][1<<maxm][25];
int pc[maxn];
const int mod=1e9+7;

signed main(){
	int n,m,k;
	scanf("%lld%lld%lld",&n,&m,&k);
	for (int i=0;i<(1<<n);i++){
		for (int j=0;j<n;j++){
			if ((i&(1<<j))) pc[i]++;
		}
	}
	
	for (int N=0;N<(1<<n);N++){
		dp[0][N][0][pc[N]]++;
	}
	for (int N=0;N<(1<<n);N++){
		for (int L=0;L<(1<<n);L++){
			if (N&(L<<2)||N&(L>>2)) continue;
			dp[1][N][L][pc[N]+pc[L]]++;
		}
	}
	
	for (int i=2;i<m;i++){
		for (int N=0;N<(1<<n);N++){
			for (int L=0;L<(1<<n);L++){
				if (N&(L<<2)||N&(L>>2)) continue;
				
				for (int vis=pc[N];vis<=k;vis++){
					for (int F=0;F<(1<<n);F++){
						if (L&(F<<2)||L&(F>>2)) continue;
						if (N&(F<<1)||N&(F>>1)) continue;
						
						dp[i][N][L][vis]=(dp[i][N][L][vis]+dp[i-1][L][F][vis-pc[N]])%mod;
					}
				}
			}
		}
	}
	
	int ans=0;
	for (int N=0;N<(1<<n);N++){
		for (int L=0;L<(1<<n);L++){
			if (N&(L<<2)||N&(L>>2)) continue;
			
			ans=(ans+dp[m-1][N][L][k])%mod; 
		}
	}
	
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：Yashajin_Ai (赞：0)

### 思路
第一眼想到动态规划，可以发现这道题数据十分小，考虑使用状态压缩。

$f_{i,a,b,k}$ 数组 $i$ 为第多少行，$a$ 为第 $i-1$ 行的状态，第 $i$ 行中状态为 $b$ 的方案数，最终方案数是 $f_{m,i,j,k}$ 的和。

对于这道题我们在循环的时候注意要判断，$a$ 与 $b$ 的状态是否冲突了，没有就再一次判断 $i$ 的状态是否与 $a$ 和 $b$ 的状态同时冲突，没有就计算可以摆放的棋子数。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MOD=1e9+7;
int n,m,k;
int ans;
int f[101][1<<6][1<<6][21];
//f[i][a][b][k] 第i-1行状态为a，第i行状态为b，此时有k个棋子的方案数
int count(int x){
    int res=0;
    while(x){
        res++;
        x-=x&-x;
    }
    return res;
}
int main(){
    cin>>n>>m>>k;
    f[0][0][0][0]=1;
    for(int i=1;i<=m;i++){
        for(int a=0;a<1<<n;a++){
            for(int b=0;b<1<<n;b++){
                if(a&(b<<2)||b&(a<<2)) continue;
                for(int c=0;c<1<<n;c++){
                    //判断第i行是否与前两行冲突
                    if(c&(a<<1)||a&(c<<1)) continue;
                    if(c&(b<<2)||b&(c<<2)) continue;
                    //计算第i行有多少个棋子
                    int t=count(c);
                    for(int j=t;j<=k;++j){
                        f[i][b][c][j]=(f[i][b][c][j]+f[i-1][a][b][j-t])%MOD;
                    }
                }
            }
        }
    }
 
    for(int i=0;i<1<<n;i++){
        for(int j=0;j<1<<n;j++){
            ans=(ans+f[m][i][j][k])%MOD;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

---


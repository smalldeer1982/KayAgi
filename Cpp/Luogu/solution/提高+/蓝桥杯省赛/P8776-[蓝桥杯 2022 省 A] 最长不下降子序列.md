# [蓝桥杯 2022 省 A] 最长不下降子序列

## 题目描述

给定一个长度为 $N$ 的整数序列：$A_{1}, A_{2}, \cdots, A_{N}$。现在你有一次机会，将其中连续的 $K$ 个数修改成任意一个相同值。请你计算如何修改可以使修改后的数列的最长不下降子序列最长，请输出这个最长的长度。

最长不下降子序列是指序列中的一个子序列，子序列中的每个数不小于在它之前的数。

## 说明/提示

对于 $20 \%$ 的评测用例, $1 \leq K \leq N \leq 100$;

对于 $30 \%$ 的评测用例, $1 \leq K \leq N \leq 1000$; 

对于 $50 \%$ 的评测用例, $1 \leq K \leq N \leq 10000$;

对于所有评测用例, $1 \leq K \leq N \leq 10^{5}, 1 \leq A_{i} \leq 10^{6}$ 。 

蓝桥杯 2022 省赛 A 组 G 题。

## 样例 #1

### 输入

```
5 1
1 4 2 8 5```

### 输出

```
4```

# 题解

## 作者：Demeanor_Roy (赞：15)

[原题链接](https://www.luogu.com.cn/problem/P8776)

不错的题，这里提供一个树状数组写法。


------------

首先对于序列每一个位置，求出 $L_i,R_i$ 分别表示以 $i$ 位置为结尾，为开始的最长不下降子序列，求法就是正着做一遍朴素的最长不下降子序列，反着做一遍最长不上升子序列，注意用 $n \log n$ 做法。


接着考虑拼接。

首先我们可以得出一个结论：改变 $k$ 个数一定比改变更少的数优秀。这很显然，因为我们可以把改成和原来相同也看作改变。

那接下来就好做了，我们对每一个位置 $i$ ，贪心地考虑它前面 $k$ 个数被改成与它相同，那只需要找一个 $j$ 属于 $[1,i-k-1]$ ，使得 $val_j \leq val_i$ 且 $L_j$ 最大，然后用 $L_j + k + R_i$ 更新答案就行了。

温馨提示：因为要用三个树状数组，最好把树状数组写成类更方便。

update on 11.19: 之前有一点没有说清楚，其实这个做法隐含了一个贪心，那就是如果改变 $[L,R]$ 这 $k$ 个数，我们只考虑其去配合以 $R+1$ 为左端点的最长不降序列，因为就算它配合以更后面的数 $x$ 为左端点的最长不降序列有更优答案，那它也不会比枚举改变 $[x-k,x-1]$ 这 $k$ 个数时去配合 $x$ 更优，因为那时 $L_j$ 选择更广。所以改变 $[L,R]$ 这 $k$ 个数时，自然是改变成 $val_{R+1}$ 更优。

update on 11.25: 代码有一点小锅，已修。

update on 2025.5.12: 代码又有一点小锅，已修。

下附代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+10;
int n,k,ans,val[N],L[N],R[N];
vector<int> vec;
struct BIT
{
	int C[N];
	inline void add(int x,int y){for(;x<=n+1;x+=x&-x)	C[x]=max(C[x],y);}
	inline int query(int x)
	{
		int ans=0;
		for(;x;x-=x&-x)	ans=max(ans,C[x]);
		return ans;
	}
}le,re,s;
int main()
{
	scanf("%d%d",&n,&k);
	val[0]=1;val[n+1]=n+1;
	for(int i=1;i<=n;i++)	scanf("%d",&val[i]);
	for(int i=1;i<=n;i++)	vec.push_back(val[i]);
	sort(vec.begin(),vec.end());
	vec.erase(unique(vec.begin(),vec.end()),vec.end());
	for(int i=1;i<=n;i++)	val[i]=lower_bound(vec.begin(),vec.end(),val[i])-vec.begin()+1;
	for(int i=1;i<=n;i++)
	{
		L[i]=le.query(val[i])+1;
		le.add(val[i],L[i]);
	}
	for(int i=n;i>=1;i--)
	{
		R[i]=re.query(n-val[i]+1)+1;
		re.add(n-val[i]+1,R[i]);
	}
	for(int i=k+1;i<=n+1;i++)
	{
		s.add(val[i-k-1],L[i-k-1]);
		ans=max(ans,s.query(val[i])+k+R[i]);
	}	
	printf("%d",ans);
	return 0;	
} 
```

完结撒花~

---

## 作者：Bulyly (赞：8)

### 前言
正愁着找不到题练树状数组这不就来了吗？

------------
### 解析
- 这是一道好写且好想的题，核心是用 $O(n\log n)$ 的算法来求最长不下降子序列，所以二分或者树状数组等都是可以的，这里我写的是树状数组。~~这样就不涉及区间 LIS 等其他东西就没必要用线段树了~~

- 首先正着做一遍朴素的最长不下降子序列得到 $f[i]$ 表示以 $ i $ 为结尾的最长不下降子序列，同理，再反着求一遍最长不上升子序列得到 $g[i]$ 表示以 $ i $ 为开始的最长不上升子序列。

- 接着就是思考如何合并，首先我们很容易发现改变的数越多解一定是更优的，假如你将前 $i$ 个数修改，得到的答案一定不会少于修改前 $ i - 1 $ 数。

- 这样的话就可以采取贪心策略，将位置 $ i $ 的前 $ k $ 个数都改成与其相同的值然后再去找一个位置  $ i  - k  - 1 $ 之前的位置 $ j $ 能与其拼接且 $f[j]$ 最大，再加上 $g[i]$，最后打擂取一个 $\max$。

update on 11.24：感谢 Halcyflict 提供的 hack 数据。之前的考虑存在一种漏洞，那就是无论如何都无法修改到最后一个点，那需要怎么做呢，在数组末尾在加上一个最大值即可，这样既不会影响答案，也能保证修改到原来最后一个数。注意，数组已经被离散化过所以添加的数应为不同数个数 $+1$。
- code：
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define RT register
#define N 100010
using namespace std;
int n,k,m,ans;
int a[N],s[N],f[N],tr[N],g[N];
inline int qmax(int x)
{
    int ans(0);
    for(;x;x-=x&-x)  ans=max(ans,tr[x]);
    return ans;
}
inline void add(int x,int y){for(;x<=n;x+=x&-x)  tr[x]=max(tr[x],y);}
int main()
{
    memset(tr,0,sizeof(tr));
    scanf("%d%d",&n,&k);
    for(RT int i=1;i<=n;i++)  scanf("%d",&a[i]),s[i]=a[i];
    sort(s+1,s+n+1);
    m=unique(s+1,s+n+1)-s-1;
    for(RT int i=1;i<=n;i++)  a[i]=lower_bound(s+1,s+m+1,a[i])-s;//离散化
    for(RT int i=1;i<=n;i++)    f[i]=qmax(a[i])+1,add(a[i],f[i]);
    memset(tr,0,sizeof(tr));
    for(RT int i=n;i>=1;i--)    g[i]=qmax(n-a[i]+1)+1,add(n-a[i]+1,g[i]);
    memset(tr,0,sizeof(tr));
    a[n+1]=m+1;
    for(RT int i=k+2;i<=n+1;i++)
    {
        add(a[i-k-1],f[i-k-1]),ans=max(ans,k+g[i]+qmax(a[i]));
    }
    if(k>=n-1)  ans=max(ans,n);//很重要
    printf("%d\n",ans);
    return 0;//perfect ending !
}
```

完结撒花~

---

## 作者：Usada_Pekora (赞：7)

现在数据有点水，翻了一下几乎全是非正解的直接 LIS 做法。

这边介绍一下正解。

首先若 $k$ 等于零，我们直接做一遍 LIS 即可，这个用二分或者树状数组都是可以维护的。

二分做法大家应该都很熟悉，树状数组做法简单介绍一下，因为后面要用。

朴素的 LIS 做法是对于每个 $f_i$，枚举一个在它前面且 $a_j\leq a_i$ 的 $f_j$ 转移过来，这个过程放到一段数轴上可以看成：每个 $a_i$ 对应一个 DP 值，我们每次从数轴 $\leq a_i$ 的位置找一个最大的 DP 值转移到 $a_i$。

```cpp
for (int i = 1; i <= n; i++) 
	for (int j = 1; j <= a[i]; j++)
		f[a[i]] = max(f[a[i]], f[j] + 1);
```

注意到这个过程可以用一个支持前缀查询，单点修改的数据结构维护，采用树状数组是一个不错的选择。

回到本题。

最优解一定是在已有的 LIS 上拼接的，因为反过来想，能在当前 $k$ 个数上接一段 LIS 肯定是最好的。

所以我们考虑在两个 LIS 中间接 $k$ 个数怎么维护（在前面接或者后面接是容易做的）。

这个过程应该是这样的：

![111](https://cdn.luogu.com.cn/upload/image_hosting/aap552y1.png)

令 $f_i$ 表示 $i$ 结尾的前缀 LIS 长度，$g_{i}$ 表示第一个数大于等于 $i$ 的 LIS 长度。

则答案可以表示为 $f_i+k+g_{a_i}$，因为将这 $k$ 个数设置为 $a_i$ 是更好的，更大的值并不能接更多的数。注意 $g_{a_i}$ 根据给定限制，至少要从 $i+k+1$ 的位置开始往后。

维护 $n$ 个树状数组是 naive 的，可以倒序枚举解除这个限制，即对于每个 $i+k+1$ 的位置去处理 $f_i$。

最后代码如下，需要注意的是代码里的 $g_i$ 并非上面的 $g_i$，而是表示 $i$ 开头的 LIS。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5, M = 1e6;
int n, k, a[N], f[N], g[N], c[M + 5];
inline void modify(int x, int k, int op) {
	op && (x = M - x + 1);
	while (x <= M) {
		c[x] = max(c[x], k);
		x += (x & -x);
	}
}
inline int query(int x, int op) {
	op && (x = M - x + 1);
	int res = 0;
	while (x) {
		res = max(res, c[x]);
		x -= (x & -x);
	}
	return res;
}
signed main() {
	cin.tie(NULL)->sync_with_stdio(false);
	cin >> n >> k;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	int ans = k;
	for (int i = 1; i <= n; i++) {
		f[i] = query(a[i], 0) + 1;
		modify(a[i], f[i], 0);
		ans = max(ans, f[i]);
	}
	memset(c, 0, sizeof c);
	for (int i = n; i >= 1; i--) {
		g[i] = query(a[i], 1) + 1;
		modify(a[i], g[i], 1);
		ans = max(ans, g[i]);
		int pos = i - k - 1;
		if (pos >= 1)
			ans = max(ans, f[pos] + k + query(a[pos], 1)); 
	}
	for (int i = 1; i + k <= n; i++)
		ans = max(ans, f[i] + k);
	for (int i = k + 1; i <= n; i++)
		ans = max(ans, g[i] + k);
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：水星湖 (赞：5)

正常的最长不下降子序列显然可以使用动态规划求解。
设 $f_i$ 表示前 $i$ 个数中，以第 $i$ 个数结尾的最长不下降子序列长度，不妨设 $f_0 = 0$, $a_0 = 0$。
则状态转移为：

$$
f_i = 1 + \max_{0 \le j < i \land a_j \le a_i} f_j
$$

使用树状数组（BIT）可以将复杂度优化到 $O(n \log V)$。

---

现在考虑加入一次修改操作。
仿照之前的状态定义，设：

* $f_{i,0}$：前 $i$ 个数中，未使用过修改，以第 $i$ 个数结尾的最长不下降子序列长度。
* $f_{i,1}$：前 $i$ 个数中，使用过修改，以第 $i$ 个数结尾的最长不下降子序列长度。

同样可以得到以下状态转移方程：

$$
f_{i,0} = 1 + \max_{0 \le j < i \land a_j \le a_i} f_{j,0}
$$

$$
f_{i,1} = 1 + \max_{0 \le j < i \land a_j \le a_i} f_{j,1}
$$

此外，还需要考虑直接从未修改状态转移：

$$
f_{i,1} = \max\left(1 + k + \max_{0 \le j < i - k \land a_j \le a_i} f_{j,0}, \, k + f_{i-k,0} \right)
$$

以上转移可以用三个 BIT 优化到 $O(n \log V)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

namespace z {

const int N = 1e6 + 5;
int f[N][2], a[N], n, k, ans;
struct BIT {
    int c[N];
    void upd(int x, int v) {
        for(; x < N; x += x & -x) c[x] = max(c[x], v);
    }
    int qry(int x) {
        int res = 0;
        for(; x; x -= x & -x) res = max(res, c[x]);
        return res;
    }
} b1, b2, b3;
void main() {

    ios::sync_with_stdio(false);
    cin.tie(nullptr);cout.tie(nullptr);
    cin >> n >> k;
    for(int i = 1; i <= n; i++) cin >> a[i];
    for(int i = 1; i <= n; i++) {
        f[i][0] = b1.qry(a[i]) + 1;
        f[i][1] = b2.qry(a[i]) + 1;
        b1.upd(a[i], f[i][0]);
        f[i][1] = max(f[i][1], b3.qry(a[i]) + k + 1);
        if(i - k > 0) b3.upd(a[i - k], f[i - k][0]);
        if(i - k >= 0 && a[i - k] <= a[i]) f[i][1] = max(f[i - k][0] + k, f[i][1]);
        b2.upd(a[i], f[i][1]);
        ans = max({ans, f[i][0], f[i][1]});
    }
    cout << ans << '\n';
}

#undef int

}


int main()
{
    z::main();
    return 0;
}
```

---

## 作者：hzx360 (赞：5)

前言：感谢审核大大百忙中审核 MnZn 题解。


------------
来一发线段树题解。

### Step 1
先把以这个位置为开头的**最长不下降子序列**和以这个位置为结尾的**最长不下降子序列**求出来，用 $dp1$ 和 $dp2$ 数组储存。这个过程用线段树优化。
```
void DP(){
	build(1,1,mx);//mx为最大的a[i]值
	for(int i=1;i<=n;i++) dp1[i]=query(1,1,a[i])+1,update(1,a[i],dp1[i]);//以i为结尾的最长不降子序列
	build(1,1,mx);
	for(int i=n;i>=1;i--) dp2[i]=query(1,a[i],mx)+1,update(1,a[i],dp2[i]);//以i为开头的最长不降子序列
}
```
------------

### Step 2
根据题目要求，很容易想到最后的答案是前面一段**不下降子序列**，加这 $K$ 个相同的数，再加后面一段**不下降子序列**，三段合在一起的序列。

其中这 $K$ 个数的值**改为**前面一段不下降子序列**最后一个位置**的值就一定可以满足单调不降。
![](https://cdn.luogu.com.cn/upload/image_hosting/dtfv0jov.png)
既然这 $K$ 个数和前面一段序列末尾的值相同的，那前面与后面一段序列合起来必然也是**不下降子序列**。

$K$ 是定值，那我们只用找到一组 $(i,j)$ ，使得 $dp_i+K+dp_j$ 最大即可，这个最大值就是答案（$i$ 代表前一段的末尾位置，$j$ 代表后一段的开头位置）。

**Tip**：其中 $j \geq i+K+1$ ，因为两段序列之间最少隔了 $K$ 个数；同时还要满足 $A_i \le A_j$，因为要满足单调不降。

------------
### Step 3
对于一个 $i$，后一段序列开头 $j$ 能选到的区间就是 $[i+K+1,n]$。$i$ 每往后移动 $1$，$j$ 能选到的左端点就往后移动 $1$，联想到求最长不下降子序列中线段树的作用，这可以理解为将最左边的位置删掉。

总的来说就是一边求最大值，一边从线段树里删数。

看看代码就秒懂了：
```
void work(){
	build(1,1,mx);
	for(int i=1+k+1;i<=n;i++) update(1,a[i],dp2[i]);
	for(int i=1;i<=n-k;i++){
		ans=max(ans,dp1[i]+query(1,a[i],mx));
		if(i+k+1<=n) update(1,a[i+k+1],0);
	}
}
```
还有一点值得注意的是：由于 $A_i$ 可能相等，线段树的 update 操作不能只是简单地将值改成 $0$，要记录这个值出现的次数，当次数为 $0$ 时这个值才是真正地删去了。

------------

完整代码：[code](https://www.luogu.com.cn/paste/9nzvhu97)

总结：这其实就是道简单的动态规划加线段树题 QAQ。


---

## 作者：zjinze (赞：4)

#### 前言

模拟赛考到了这道题，但是我看错题了，于是我就重新写了这道题。

#### 思路：

对于这种最长不下降子序列，我们可以用树状数组维护转移时的最值，使时间复杂度降到 $O(n  \log n)$。我们可以正着和反着都做一遍最长不下降子序列。我们令 $dp_i$ 表示从第一个数到第 $i$ 个数的最长不下降子序列，$f_i$ 表示从第 $i$ 个数到最后一个数的最长不下降子序列。我们注意到题目说的是可以修改连续的 $k$ 个数，这时用贪心的角度，转换成拼接问题。
则答案为 $\max (dp_i + f_i + k - 1)$，这里要减 $1$ 是因为 $dp_i$ 和 $f_i$ 都会把 $a_i$ 给算进去。但是我们还要把答案和 $n$ 取个最小值，以保证答案的正确性。这里我并没有离散化，其他见代码。

#### code:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define lowbit(x) x&-x 
const int N=1e6+7;
const int M=1e6+7;
int n,a[N],k,dp[N],f[N],tree[M],ans=0;
void update(int x,int val){
	for(int i=x;i<M;i+=lowbit(i)){
		tree[i]=max(tree[i],val);
	}
	return ;
}
int query(int x){
	int ans=0;
	for(int i=x;i>=1;i-=lowbit(i)){
		ans=max(ans,tree[i]);
	}
	return ans;
}
signed main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		dp[i]=f[i]=1;
	}
	for(int i=0;i<M;i++)tree[i]=1;
	dp[1]=f[n]=1;
	for(int i=2;i<=n;i++){
		dp[i]=query(a[i]);
		update(a[i],dp[i]+1);
	} 
	for(int i=0;i<M;i++)tree[i]=1;
	for(int i=n-1;i>=1;i--){
		f[i]=query(M-a[i]);
		update(M-a[i],f[i]+1);
	}
	for(int i=1;i<=n;i++){
		ans=max(ans,dp[i]+f[i]+k-1);
	}
	cout<<min(ans,n)<<"\n";
	return 0;
}
````

---

## 作者：zzxLLL (赞：4)

不会树状数组做法，所以写了主席树。

---

设 $f_i$ 为以 $a_i$ 为结尾的最长不降子序列长度，$g_i$ 为以 $a_i$ 开头的最长不降子序列长度。二者容易在 $O(n \log n)$ 的时间内完成。

然后一个显然的结论是，最终答案一定存在一个位置 $l$，将答案序列分成三段：

- 以 $a_{l - 1}$ 为结尾的最长不降子序列。

- $k$ 个 $a_{l - 1}$。

- 在 $[l + k, n]$ 中的一个 $\ge a_{l - 1}$ 的数为开头的最长不降子序列。

形式化的说，就是 $\max\limits_{1 \le l \le n - k + 1} (f_{l - 1} + k + \max\limits_{l + k \le r \le n \land a_r \ge a_{l - 1}} g_r)$。

看括号里面的 $\max$，事实上是一个二维数点的形式，但是因为是后缀查询所以可以用主席树。按照从 $n$ 到 $1$ 的顺序将 $(a_i, g_i)$ 插入到主席树里面即可。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
const int M=1e5+10,V=1e6;

int n,k,a[M];

int rt[M],cntp;
struct node{int lc,rc,mx;}tr[V*21];
#define lc(k) tr[k].lc
#define rc(k) tr[k].rc
void pushup(int k){
	tr[k].mx=std::max(tr[lc(k)].mx,tr[rc(k)].mx);
}
void ins(int &k,int pre,int l,int r,int p,int v){
	tr[k=++cntp]=tr[pre];
	if(l==r) return tr[k].mx=std::max(tr[k].mx,v),void();
	int mid=(l+r)>>1;
	if(p<=mid) ins(lc(k),lc(pre),l,mid,p,v);
	else ins(rc(k),rc(pre),mid+1,r,p,v);
	pushup(k);
}
int qry(int k,int L,int R,int l,int r){
	if(!k) return 0;
	if(L<=l&&r<=R) return tr[k].mx;
	int mid=(l+r)>>1;
	if(R<=mid) return qry(lc(k),L,R,l,mid);
	else if(L>mid) return qry(rc(k),L,R,mid+1,r);
	else return std::max(qry(lc(k),L,R,l,mid),qry(rc(k),L,R,mid+1,r));
}

int f[M],g[M];

struct BIT{
	int c[V+10];
	void mdf(int p,int v){
		for(;p<=V;p+=p&-p)
			c[p]=std::max(c[p],v);
	}
	int qry(int x){
		int res=0;
		for(;x;x-=x&-x)
			res=std::max(res,c[x]);
		return res;
	}
}t;

int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
		t.mdf(a[i],f[i]=t.qry(a[i])+1);
	for(int i=n;i>=1;i--){
		g[i]=qry(rt[i+1],a[i],V,1,V)+1;
		ins(rt[i],rt[i+1],1,V,a[i],g[i]);
	}
	
	int ans=0;
	for(int i=1;i<=n-k+1;i++){
		int now=f[i-1]+k+qry(rt[i+k],a[i-1],V,1,V);
		ans=std::max(ans,now);
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：I_AM_CIMOTA (赞：3)

思路非常清晰的一道题目。

首先，大家都知道一个序列的最长不下降子序列的求法，那就是记 $f(i)$ 表示以第 $i$ 个元素结尾的最长不下降子序列长度，用树状数组优化转移。

现在，你有一次机会使 $K$ 个连续元素修改为某一个相同的值。这其实等价于有一个不下降子序列 $\{x_1,x_2,\cdots,x_m\}$，如果存在 $x_{i+1}-x_i>k$，那么就可以用 $m+K$ 更新答案（因为可以将 $x_i$ 与 $x_{i+1}$ 之间的任意 $K$ 个数修改为 $A_{x_i}$）。

于是做法就很显然了，我们可以钦定某个元素为修改的 $K$ 个元素后的第一个元素。记 $F(i)$ 表示以序列第 $i$ 个元素结尾的，前一个选中的位置距离 $i$ 至少为 $K+1$ 的最长不下降子序列长度。再记 $g(i)$ 为以序列的第 $i$ 个元素为开头的最长不下降子序列长度。这两个都可以用树状数组优化转移。

求出 $F$ 和 $g$ 后，枚举钦定的位置，用 $F(i)+g(i)-1+K$ 更新答案。

时间 $O(n\log n)$，实现起来很简单：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=1e6+5,UP=1e6;
int n,k,ans,a[N],f[N],g[N],F[N],t[N];

void upd(int x,int v){for(;x<=UP;x+=x&(-x))t[x]=max(t[x],v);}

int qry(int x){
	int res=0;
	for(;x;x-=x&(-x))res=max(res,t[x]);
	return res;
}

int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=n;i++){
		f[i]=qry(a[i])+1;
		upd(a[i],f[i]);
	}
	memset(t,0,sizeof t);
	for(int i=k+1;i<=n;i++){
		F[i]=qry(a[i])+1;
		upd(a[i-k],f[i-k]);
	}
	memset(t,0,sizeof t);
	for(int i=n;i>=1;i--){
		g[i]=qry(UP-a[i]+1)+1;
		upd(UP-a[i]+1,g[i]);
	}
	for(int i=1;i<=n;i++)ans=max(ans,f[i]);
	for(int i=k+1;i<=n;i++)ans=max(ans,F[i]+g[i]-1+k);
	printf("%d\n",ans);
	return 0;
} 
```

---

## 作者：_JF_ (赞：3)

[P8776 [蓝桥杯 2022 省 A] 最长不下降子序列 ](https://www.luogu.com.cn/problem/P8776)

原来是自己的代码能力差。

注意题目要求的是**最长不下降子序列**，别搞成了最长上升子序列。

首先对于一般的求解最长不下降子序列是套路的，直接权值线段树优化动态规划即可。

假设枚举到了 $i$，发现答案是由三部分组成，一部分是以 $i$ 为末尾的 $dp_i$，一部分是 $[i+1,i+k]$ 的 $k$ 个数，一部分是 $[i+k+1,n]$ 某一个位置的 $j$ 表示以 $j$ 为首的最长不下降子序列 $dp1_j$。

求解 $dp1_j$ 是容易的，对着序列倒着做就行。 

我们贪心的期望 $[i+1,i+k]$ 进行更换操作，且这些位置都变成 $a_i$，因为这样留给后面能取的位置就更多了些，这样做显然是不劣的。

那相当于剩下就是要在线段树 $[a_i,V]$ 区间里面找到最大的 $dp_i$ 值，线段树即可。

前后算起来是三个线段树，但是发现可以合并起来写。

代码能力差到极点，唐。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =3e6+10;
int n,k,d[N],d1[N],a[N],V=1000000;
struct node{
	int num,ans;
}F[N],L[N];
int Query(int l,int r,int s,int t,int p){
	if(l>r)	return 0;
	if(l<=s&&t<=r)	{return d1[p];}
	int mid=(s+t)>>1,ans=0;
	if(l<=mid)	ans=max(ans,Query(l,r,s,mid,p<<1));
	if(r>mid)	ans=max(ans,Query(l,r,mid+1,t,p<<1|1));
	return ans;
}
void update1(int l,int r,int s,int t,int p,int ch){
	if(l<=s&&t<=r)	{d1[p]=max(d1[p],ch);return ;}
	int mid=(s+t)>>1;
	if(l<=mid)	update1(l,r,s,mid,p<<1,ch);
	if(r>mid)	update1(l,r,mid+1,t,p<<1|1,ch);
	d1[p]=max(d1[p<<1],d1[p<<1|1]);
}
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)	cin>>a[i];
	for(int i=1;i<=n;i++){
		int now=Query(1,a[i],1,V,1);
		update1(a[i],a[i],1,V,1,now+1);
		F[i].ans=now+1;
	}
	memset(d1,0,sizeof(d1));
	for(int i=n;i>=1;i--){
		int now=Query(a[i],V,1,V,1);
		update1(a[i],a[i],1,V,1,now+1);
		L[i].ans=now+1;
	}
	memset(d1,0,sizeof(d1));
	int ans=0;
	for(int i=n;i-k>=1;i--){
		int now=i-k;
		ans=max(ans,F[now].ans+k+Query(a[now],V,1,V,1));
		update1(a[i],a[i],1,V,1,L[i].ans);
	}
	for(int i=1;i+k-1<=n;i++)	ans=max(ans,F[i-1].ans+k);
	for(int i=k+1;i<=n;i++)	ans=max(ans,L[i].ans+k);
	cout<<ans<<endl;
	return 0;
}
/*
9 4 
2 2 3 4 5 1 1 1 1
*/

```

---

## 作者：s4CRIF1CbUbbL3AtIAly (赞：3)

## 题意

求将序列中 $k$ 个连续的数都修改为同一个值后能达到的最长不降子序列。

## 题解

首先求出 $L_i$ 表示以 $a_i$ 为结尾的最长不降子序列，$R_i$ 表示以 $a_i$ 为开头的最长不降子序列。

这时答案一定是 $L_{x}$ 接上中间 $k$ 个数再接上 $R_{y}$。

画在坐标系上，观察图像能够发现，$R_y$ 和 $L_x$ 恰好挨着中间 $k$ 个数肯定是不劣的，进一步会有中间 $k$ 个数直接等于 $a_y$ 是最优的。

因此直接用树状数组计算出 $L_i$ 与 $R_i$，再枚举修改的是中间哪 $k$ 个数即可。

---

## 作者：__3E24AC7002AD9292__ (赞：2)

这是一篇乱搞做法的题解。

前置：[LIS](/problem/AT_chokudai_S001_h) 的 $\Theta(n\log n)$ 做法，随机化（只需要掌握随机数），`clock()` 计时函数。

首先你可以考虑把不覆盖的情况下求单调不降序列的代码写出来，和 LIS 几乎完全相同。

其次可以推一推覆盖的一些性质：

1. 由于单调不降序列相邻两数可以相等，所以覆盖后这个区间 $[l,r]$ 某个值包含的单调不降子序列 $S$，则一定有 $S\cup\{a_l,a_{l+1},\dots,a_r\}$ 按照 $a$ 中的出现顺序排列后单调不降。
2. 在赋值的时候，假设区间 $l,r$ 赋值为 $d$，假设赋值后由这个区间构成的最长不降子序列为 $S=\{a_{c_1},a_{c_2},\dots,a_{c_t},a_l,a_{l+1},\dots,a_r,\dots\}$，则 $d$ 取 $a_{c_t}$ 最佳。

其实在得到第二个性质的时候可以发现我们并不用考虑 $d$ 的取值，则又有：

3. 赋值 $k$ 长度的区间一定比 $\forall i<k$ 长度要好。

这样我们就得到了暴力做法，假设赋值区间为 $[l,r]$，那么根据第三个性质，$r$ 取 $l+k-1$ 一定最佳。

根据第二个性质，我们直接不考虑 $[l,l+k-1]$ 区间，即在求 LIS 的时候跳过这个区间求 LIS 的长度 $w$。在最后需要把区间添加进前面求的 LIS，即 LIS 的长度直接增加 $k$，这样最后对于 $[l,l+k-1]$ 区间，覆盖后的 LIS 长度即为 $w+k$，我们记 $\text{getr}(l)=w+k$。

最后枚举每个可能的 $l$，取每个 $\text{getr}(l)$ 的最大值即可，即求得 $\displaystyle\max_{l=1}^{n-k+1}\text{getr}(l)$ 为最终答案。

时间复杂度高达 $(n-k+1)\times(n-k)\times\log(n-k)$，约为 $\Theta(n^2\log n)$，可以拿 $30$ 分，[code](/paste/rxp81gwr)（这边 $\text{getr}$ 传了两个参数，其实跟传一个没区别）。

但是你可以考虑每次随机一个 $l$，求对应的 $\text{getr}(l)$ 并取最大值，随机到快要 TLE 为止。

这里判断 TLE 珂以使用 `clock()` 函数来得到程序运行的时刻总和（顺带一提 `Sleep` 函数并不包含在这个总和，但是在 OI 中可以不管），使用 `CLOCKS_PER_SEC` 获得程序 $1$ 秒运行的时刻总和（也可以直接写 $1000$）。

当然可以用一个 `bool` 数组（这里使用了 `bitset`，用法类似）来去掉被重复搜索的 $l$ 增加随机化精确度，也不浪费运行时间。

最后这个[代码](/paste/gxo4i2xt)就写完了，交了几发发现这个随机化是很准的，感兴趣的大佬可以来证明一下为什么随机化正确的概率这么高。

---

## 作者：_wzb_ (赞：1)

**[P8776 [蓝桥杯 2022 省 A] 最长不下降子序列](https://www.luogu.com.cn/problem/P8776)**

**前置芝士**：树状数组（不清楚的去问问度娘）。

**题目大意**：求修改 $k$ 个数之后的最长不下降子序列。

**思路**：用 $dp_i$ 表示从第 $1$ 个到第 $i$ 个数的最长不下降子序列，用 $pd_i$ 表示从第 $1$ 个数到第 $n$ 个数的最长不下降子序列，要维护一个区间的最大值可以用什么？没错就是树状数组，用树状数组维护当前区间的最长不下降子序列，因为可以修改连续的 $k$ 个数。所以我们可以利用这 $k$ 个数让 $dp_i$ 和 $pd_i$ 连接起来。不清楚的可以看看图片，我们可以得出结果是 $\max(dp_i+k+pd_i-1,ans)$。



**如图：**

![](https://cdn.luogu.com.cn/upload/image_hosting/fdiu5pcv.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

~~（有点抽象但是已经认真画了）~~

**代码如下:**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int n,a[N],k,dp[N],pd[N],t[N],ans=0;
int lowbit(int x)//树状数组 
{
	return x&(-x);//lowbit不过多解释不知道的可以去度娘看看 
}
void up(int x,int v);//维护x节点的最大值 修改x的值 
int q(int x);//维护最长不下降子序列 
signed main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		dp[i]=1;
		pd[i]=1;//初始化 
	}
	for(int i=0;i<N;i++)t[i]=1;
	dp[1]=1;
	pd[n]=1;
	for(int i=2;i<=n;i++)//求从1到i的最长不下降子序列 
	{
		dp[i]=q(a[i]);//找前缀最大值 
		up(a[i],dp[i]+1);//更新树状数组 
	} 

	for(int i=0;i<N;i++)t[i]=1;//初始化 
	for(int i=n-1;i>=1;i--)//求从i到n的最长不下降子序列 
	{
		pd[i]=q(N-a[i]);//因为要从右向左找 但是树状数组的逻辑默认是从小到大维护值的所以要取反 
		up(N-a[i],pd[i]+1);//更新树状数组 
	}
	for(int i=1;i<=n;i++)
	{
		ans=max(ans,dp[i]+k+pd[i]-1);//枚举节点找最优 
	}
	cout<<min(ans,n)<<"\n";
	return 0;
}
int q(int x)//
{
	int ans=0;//初始化最大值为0 
	while(x>0)//从x开始向下遍历 
	{
		ans=max(ans,t[x]);//更新当前区间的最大值 
		x-=lowbit(x);//移动到左边的节点 
	}
	return ans;
}
void up(int x,int v)//维护x节点的最大值 
{
	while(x<=N)//从位置x开始，向上更新树状数组
	{
		t[x]=max(t[x],v);// 更新当前节点为最大值
		x+=lowbit(x);// 移动到父节点 
	}
	return ;
}
```

---

## 作者：Firsry (赞：1)

# P8776 \[蓝桥杯 2022 省 A] 最长不下降子序列

本蒟蒻接触 OI 半年以来的第一篇题解，不会树状数组，只好使用朴素的拼接计算的方式了。

这是对变量名以及缩写的解释：

- $\operatorname{LNDS}$：最长不降子序列。（Longest Not Decrease Sequence）
- $\operatorname{LNIS}$：最长不升子序列。（Longest Not Increase Sequence）
- $a$：原数组。
- $flen_{len}$：保存某一长度的最长…… 子序列的末尾值。
- $fend_i$：保存以某数为结尾的最长…… 子序列的长度。
- $fbegin_i$：保存以某数为开头的最长…… 子序列的长度。

### Part\_1 dp 正确性证明

显然肯定要去赋值。对于原数组的 $\operatorname{LNDS}$ 进行子段赋值的操作，我们只需要考虑在哪两个 $\operatorname{LNDS}$ 节点之间，并不用考虑它们之间的精确位置，所以可以特殊性地认为所选子段均在靠右的节点的正左边，为拼接操作做准备。

（如下图，两种方案对答案并没有实质性的影响，# 表示被选。表示没有 \[] 表示被赋值。）

```
..#.....#...[....]...#...#
..#.....#......[....]#...#
```

### Part\_2 dp 策略的分析

提取出一般的状态是这样的：

```
....#..[....]#.... （具体个数不定）
        i    j
```

我们确定子段的最后一个下标为 $i$，子段后的 $\operatorname{LNDS}$ 节点为 $i$。

那么当前情况的 $\operatorname{LNDS}$ 长度应该是 $[0,i)$ 且最大值不超过 $a_j$ 的 $\operatorname{LNDS}$ 长度 $+$ 子段长度 $k + fbegin_j$。

处理完之后 $i,j$ 指针向前遍历，窗口向前滑，我们要把 $i$ 纳入左半边 $\operatorname{LNDS}$ 的考虑。

**也就是说 query 的是 $j$ 位置，而 insert 的是 $i$ 位置的内容**。

### Part\_3 dp 策略的实现

在最初找 $a$ 的 $\operatorname{LNDS}$ 的时候用的方法是二分，找的是 $[0,len)$ 上不超过 $a_i$ 的位置，我们找最大值不超过 $a_j$ 的在 $[0,i)$ 上的 $\operatorname{LNDS}$ 长度用的是相同的方法（默认会 $O(n \log n)$ 的 $\operatorname{LIS}$ 等）。

$fbegin_j$ 该怎么找？老的套路很方便的可以找到 $fend_j$，所以我们的方式是倒过来看，从结尾开始，截止到 $j$ 的 $\operatorname{LNDS}$ 即可。

更多详细内容在代码的注释部分。

```c++
#include<bits/stdc++.h>

using namespace std;

int n, k;
vector<int> a, fend, flen, fbegin;
// 本人非常喜欢用 STL :)

int binSearchNotIncrease(int len, int val) {
	int l = 0, r = len - 1, mid, ans = -1;
	// 如果返回值为 -1 则证明没有找到 fend[mid] < val
	while (l <= r) {
		mid = (l + r) >> 1;
		if (fend[mid] < val) ans = mid, r = mid - 1;
		else l = mid + 1;
	}
	return ans;
	// 经典二分 fend[r]<val fend[l]>=val
	// ans = mid => ans更新为目前找到的小于并且最接近val的位置
}
int binSearchNotDecrease(int len, int val) {
	int l = 0, r = len - 1, mid, ans = -1;
	while (l <= r) {
		mid = (l + r) >> 1;
		if (fend[mid] > val) ans = mid, r = mid - 1;
		else l = mid + 1;
	}
	return ans;
}
// 同上 请自行类比理解
void in() {
	scanf("%d%d", &n, &k), a.resize(n + 1);
	fend.resize(n + 1), flen.resize(n + 1), fbegin.resize(n + 1);
	for (int i = 0; i < n; ++i)
		scanf("%d", &a[i]);
	return;
}
// 本人喜欢用 vector<> 各位 int[] 大佬见谅
void calculateLNIS() {
	int len = 0;
	for (int i = n - 1; i >= 0; --i) {
		int find_ = binSearchNotIncrease(len, a[i]);
		if (find_ == -1)
			fend[len++] = a[i], fbegin[i] = len;
		// 没有找到 => a[i]小于等于最后一个 => len++, 以 i 为开始的长度为len
		else
			fend[find_] = a[i], fbegin[i] = find_ + 1;
		// 由于下标从 0 开始，所以为 find_ + 1
		// 找到了 => 更新 fend[find_] 为 a[i], 原理与 LIS替换 相同，看不懂自行补课
	}
	return;
}
void solve() {
	calculateLNIS();
	// 首先计算逆序的 LNIS 准备好
	int len = 0, ans = 0;
	for (int i = 0, j = k, find_; j < n; ++i, ++j) {
		find_ = binSearchNotDecrease(len, a[j]);
		// 先找 i 左边(len维护) 比 <=a[j] 的 LNDS 长度，这个是查询的 j
		ans = max(ans, (find_ == -1 ? len : find_) + fbegin[j] + k);
		// find_ == -1 => 没有找到比 a[j] 更大的 => len 维护的左半边 LNDS长度 即为左半边长度
		// 当前结果 ans 与 左半边+右半边+子段长度 求 max
		find_ = binSearchNotDecrease(len, a[i]);
		if (find_ == -1)
			fend[len++] = a[i];
		else
			fend[find_] = a[i];
		// 经典 insert(i)
	}
	ans = max(ans, len + k);
	// 由于是从 LNDS 节点开始考虑的，所以还要注意一种结尾的情况
	cout << ans;
	return;
}

int main() {
	in();
	solve();
	return 0;
}
```

---

## 作者：Quidrem (赞：0)

这题其实就是求最长不降子序列的强化题，使用一般的方法仍然可做。

### UPD

11.24 更新了 $\KaTeX$。

### 题意

在序列中将 $k$ 个连续的数改成同一个值，使最长不降子序列最长。

### 思路

首先改掉的这 $k$ 个数就是一个不降序列。当选择了最优的改数的方案（记为将 $l,r$ 区间都改为 $x$），我们可以考虑在 $1,2,\cdots l-1$ 中求出末值不大于 $x$ 的最长不降序列（长度记为 $y$），和 $r+1,r+2,\cdots n$ 中初值不小于 $x$ 的最长不降序列（长度记为 $z$），显然 $k+y+z$ 就是答案。

直接求出最优修改方案是很难的，那么我们可以考虑枚举所有的 $n-k+1$ 种修改方案，并统计其最大值。通过“求最长不降序列”这一问题我们可以知道，对于每一种修改方案的贡献是可以在 $O(\log n)$ 的时间内完成的。

定 $f_i$ 表示不经过修改，从 $1$ 到 $i$ 的以 $a_i$ 结尾的最长不降子序列，$g_i$ 表示经过修改。对于 $f_i$，就是简单的求最长不降序列即可。而对于 $g_i$，我们需要考虑两种情况：

1. 将 $i-k$ 到 $i-1$ 修改为 $a_i$，事实上此时的问题就是在 $1$ 到 $i-k$ 上求 $f$ 的值，当然我们所说的第 $i-k$ 项的值为 $a_i$ 而非他原本的值；

2. 在 $g_1,g_2,\cdots g_{i-1}$ 上搜索为 $g_i$ 做出贡献的最大结果（换句话讲就是在 $g$ 上执行与求 $f$ 一样的操作），此时的意义则是修改了 $1$ 到 $i-2$ 之间的一段长度为 $k$ 的区间。

通过上面的讨论可知我们需要定义三个数组分别对应 $f$ 的一种计算和 $g$ 的两种计算，并写出三份除了变量名意外完全相同的二分代码。

### 代码

```
#include<bits/stdc++.h>

#define inf 0x3f3f3f3f
#define N 100010
using namespace std;

int n,k,a[N],ans,mx,pos;
int f[N],g[N],x,y;

int st1[N],h1,st2[N],h2,st3[N],h3;
int bs1(int x){//三段二分
	int l=0,r=h1,mid;
	while(l<r){
		mid=(l+r+1)>>1;
		if(st1[mid]>x)r=mid-1;
		else l=mid;
	}
	return r;
}
int bs2(int x){
	int l=0,r=h2,mid;
	while(l<r){
		mid=(l+r+1)>>1;
		if(st2[mid]>x)r=mid-1;
		else l=mid;
	}
	return r;
}
int bs3(int x){
	int l=0,r=h3,mid;
	while(l<r){
		mid=(l+r+1)>>1;
		if(st3[mid]>x)r=mid-1;
		else l=mid;
	}
	return r;
}
signed main(){
	n=read(),ans=k=read();//k<=n，所以答案至少为 k
	for(int i=1;i<=n;i++)a[i]=read();
    
	for(int i=1;i<=k;i++){
		f[i]=bs1(a[i])+1;
		if(f[i]>h1)st1[++h1]=a[i];
		else if(st1[f[i]]>a[i])st1[f[i]]=a[i];
		g[i]=i;
	}
	h3=k;
	for(int i=k+1;i<=n;i++){
		f[i]=bs1(a[i])+1;
		if(f[i]>h1)st1[++h1]=a[i];
		else if(st1[f[i]]>a[i])st1[f[i]]=a[i];
        
		x=bs2(a[i])+k+1;
		if(f[i-k]>h2)st2[++h2]=a[i-k];
		else if(st2[f[i-k]]>a[i-k])st2[f[i-k]]=a[i-k];
        
		y=bs3(a[i])+1;
        
		g[i]=max(x,y);
		if(g[i]>h3)st3[++h3]=a[i];
		else if(st3[g[i]]>a[i])st3[g[i]]=a[i];
        
		ans=max(ans,g[i]);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：WaTleZero_pt (赞：0)

很棒的一道树状数组题目。

个人评价：$\texttt{data structures,dp,*2200}$

### 思路分析

我们可以将问题进行转化。我们可以枚举断点 $x$，将 $a$ 中 $x+1 \sim x+k$ 的所有数赋值为 $a_{x}$，则答案可以由三部分相加得到，即（$1 \sim x$ 中包含点 $x$ 的最长不下降子序列长度）$+k+$（$(x+k) \sim n$ 中以大于等于 $a_{x}$ 的数开始的最长不下降子序列长度）。

这个问题就很好解决了。我们先正着跑最长不下降子序列，然后再倒着跑最长不上升子序列的时候，用树状数组维护答案中的第三部分的结果即可。

### AC Code

令人惊讶的是，这题代码并不长。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
const int MX=1000000;
struct BIT{
	int val[MX+5];
	int lowbit(int x){return x&-x;}
	void update(int x,int y){
		for(;x<=MX;x+=lowbit(x))
			val[x]=max(val[x],y);
	}
	int query(int x){
		int res=0;
		for(;x;x-=lowbit(x)) res=max(res,val[x]);
		return res;
	}
}b1,b2;
int lis[100010];
int a[100010];
int x[100010];
int ati(int x){return -x+1000001;}
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		x[i]=b1.query(a[i])+1;
		b1.update(a[i],x[i]);
	}
	int ans=0;
	for(int i=n;i>=k;i--){
		ans=max(ans,x[i-k]+k+b2.query(ati(a[i-k])));
		b2.update(ati(a[i]),b2.query(ati(a[i]))+1);
	}
	printf("%d",ans);
}
```

---


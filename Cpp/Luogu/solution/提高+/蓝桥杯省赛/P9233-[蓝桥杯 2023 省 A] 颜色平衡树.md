# [蓝桥杯 2023 省 A] 颜色平衡树

## 题目描述

给定一棵树，结点由 $1$ 至 $n$ 编号，其中结点 $1$ 是树根。树的每个点有一个颜色 $C_i$。

如果一棵树中存在的每种颜色的结点个数都相同，则我们称它是一棵颜色平衡树。

求出这棵树中有多少个子树是颜色平衡树。

## 说明/提示

#### 【样例说明】

编号为 $1,3,5,6$ 的 $4$ 个结点对应的子树为颜色平衡树。

#### 【评测用例规模与约定】

对于 $30 \%$ 的评测用例，$n \leq 200$，$C_i \leq 200$；

对于 $60 \%$ 的评测用例，$n \leq 5000$，$C_i \leq 5000$；

对于所有评测用例，$1 \leq n \leq 2\times 10 ^ 5$，$1 \leq C_i \leq 2\times 10 ^ 5$，$0 \leq F_i<i$。

## 样例 #1

### 输入

```
6
2 0
2 1
1 2
3 3
3 4
1 4```

### 输出

```
4```

# 题解

## 作者：rui_er (赞：18)

看到树上数颜色，想到树上启发式合并（dsu on tree）。

这题几乎就是树上启发式合并板子了，感觉讲一下算法的原理比较好。

暴力解法显然是对每棵子树 dfs 一遍，求出子树大小 $\operatorname{size}$、子树颜色出现次数的桶 $\operatorname{cnt}$，以及颜色出现次数的出现次数的桶 $\operatorname{ccnt}$，判断 $\operatorname{cnt}(C_u)\times\operatorname{ccnt}(\operatorname{cnt}(C_u))\stackrel{?}{=}\operatorname{size}(u)$ 即可判断这棵子树是不是颜色平衡树。时间复杂度 $O(n^2)$。

注意到很多棵子树之间是包含关系。例如一条链的时候，明明可以只 dfs 一遍就能统计完答案。能不能利用这一点优化复杂度呢？

想到启发式合并。我们进行重链剖分，求出每个节点的重儿子 $\operatorname{son}$，于是希望每个节点 $u$ 能够从 $\operatorname{son}(u)$ 处继承 $\operatorname{cnt}$ 和 $\operatorname{ccnt}$ 的信息。如果你不会重链剖分也无所谓，重儿子的定义是子树大小最大的儿子，轻儿子的定义是除了重儿子以外的所有儿子，重边的定义是该节点与重儿子之间的边，轻边的定义是该节点与轻儿子之间的边。

定义 $\operatorname{add}(u,\Delta)$ 表示将 $u$ 子树的节点以 $\Delta$ 的贡献加入到 $\operatorname{cnt}$ 和 $\operatorname{ccnt}$ 中，其中 $\Delta=\pm 1$。于是有算法流程 $\operatorname{calc}(u,save)$，其中 $u$ 是当前递归到的节点，$save$ 是一个是否保存当前贡献的开关，一会会用到：

1. 对于所有轻儿子 $v$，递归 $\operatorname{calc}(v,\textrm{false})$，也就是递归求出轻儿子子树的答案，并擦除这棵子树的贡献。
1. 如果有重儿子，递归 $\operatorname{calc}(\operatorname{son}(u),\textrm{true})$，也就是递归求出重儿子子树的答案，并保留这棵子树的贡献。
1. 将当前节点 $u$ 贡献到 $\operatorname{cnt}$ 和 $\operatorname{ccnt}$ 中。
1. 对于所有轻儿子 $v$，调用 $\operatorname{add}(v,+1)$，将轻儿子子树贡献计入。此时 $\operatorname{cnt}$ 和 $\operatorname{ccnt}$ 中的信息是 $u$ 子树的。
1. 统计 $u$ 子树的答案。
1. 如果 $save=\textrm{false}$，调用 $\operatorname{add}(v,-1)$ 擦除贡献。

算法正确性是显然的。由重儿子的定义，容易证明：根节点到任意节点路径上的轻边不超过 $O(\log n)$ 条。

一个点会被暴力统计贡献，只有在 $\operatorname{calc}$ 搜到这个点，或者搜到这个点的某个作为轻儿子的祖先时才会发生。于是每个点被暴力到的次数为 $O(\log n)$，总复杂度为 $O(n\log n)$。

```cpp
// Problem: P9233 [蓝桥杯 2023 省 A] 颜色平衡树
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P9233
// Memory Limit: 256 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

//By: OIer rui_er
#include <bits/stdc++.h>
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define debug(format...) fprintf(stderr, format)
#define fileIO(s) do{freopen(s".in","r",stdin);freopen(s".out","w",stdout);}while(false)
#define likely(exp) __builtin_expect(!!(exp), 1)
#define unlikely(exp) __builtin_expect(!!(exp), 0)
using namespace std;
typedef long long ll;

mt19937 rnd(std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::system_clock::now().time_since_epoch()).count());
int randint(int L, int R) {
	uniform_int_distribution<int> dist(L, R);
	return dist(rnd);
}

template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}

const int N = 2e5+5;

int n, c[N], f[N], sz[N], son[N], cnt[N], ccnt[N], ans;
vector<int> e[N];

void dfs(int u) {
	sz[u] = 1;
	for(int v : e[u]) {
		dfs(v);
		sz[u] += sz[v];
		if(sz[v] > sz[son[u]]) son[u] = v;
	}
}

void add(int u, int dt) {
	--ccnt[cnt[c[u]]];
	cnt[c[u]] += dt;
	++ccnt[cnt[c[u]]];
	for(int v : e[u]) add(v, dt);
}

void calc(int u, bool save) {
	for(int v : e[u]) if(v != son[u]) calc(v, false);
	if(son[u]) calc(son[u], true);
	--ccnt[cnt[c[u]]];
	++cnt[c[u]];
	++ccnt[cnt[c[u]]];
	for(int v : e[u]) if(v != son[u]) add(v, 1);
	if(cnt[c[u]] * ccnt[cnt[c[u]]] == sz[u]) ++ans;
	if(!save) add(u, -1);
}

int main() {
	scanf("%d", &n);
	rep(i, 1, n) {
		scanf("%d%d", &c[i], &f[i]);
		if(f[i]) e[f[i]].push_back(i);
	}
	dfs(1);
	calc(1, true);
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：scallion (赞：14)

### 题意
给定一棵树，求有多少棵子树：出现过的颜色出现次数均相等。 

$n\leq2\times{10}^5$

### 做法

yt 说：“要用树上启发式合并。”于是这题我们就用了树上启发式合并。

一看子树颜色就感觉很板，然后颜色出现次数均相等就需要记录 $\min$ 和 $\max$ ，判断是否相等即可。而记录 $\min$ $\max$ 只需要开两个桶，每次加点删点的时候更新。

然后这题唯一有一点细节是：我们维护的是出现过的最小值，即不会等于 0。那么我们在对一种颜色进行 $add$ 的时候，它可能在此前没有出现，然后变成新的最小值。

时间复杂度 $O(n\log n)$ 。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,num_edge,ans,mi,ma;
struct Edge{
	int to,next;
}e[400010];
int head[200010];
int a[200010];
int siz[200010];
int son[200010];
int t[2][200010];
void add_edge(int from,int to){
	e[++num_edge].to=to;
	e[num_edge].next=head[from];
	head[from]=num_edge;
}
void add(int x){
	t[1][t[0][x]]--;
	t[0][x]++;
	t[1][t[0][x]]++;
	if(t[0][x]<mi) mi=t[0][x];
	if(t[0][x]>ma) ma=t[0][x];
	if(!t[1][mi]) mi++;
}
void del(int x){
	t[1][t[0][x]]--;
	t[0][x]--;
	t[1][t[0][x]]++;
	if(t[0][x]&&t[0][x]<mi) mi=t[0][x];
	if(!t[1][ma]) ma--;
}
void dfs0(int u){
	int v;
	siz[u]=1;
	for(int i=head[u];i;i=e[i].next){
		v=e[i].to;
		dfs0(v);
		if(siz[v]>siz[son[u]]) son[u]=v;
		siz[u]+=siz[v];
	}
}
void dfs1(int u,int ty){
	int v;
	if(!ty) del(a[u]);
	else add(a[u]);
	for(int i=head[u];i;i=e[i].next){
		v=e[i].to;
		dfs1(v,ty);
	}
}
void dfs2(int u){
	int v;
	for(int i=head[u];i;i=e[i].next){
		v=e[i].to;
		if(v==son[u]) continue;
		dfs2(v);
		dfs1(v,0);
	}
	if(son[u]) dfs2(son[u]);
	for(int i=head[u];i;i=e[i].next){
		v=e[i].to;
		if(v==son[u]) continue;
		dfs1(v,1);
	}
	add(a[u]);
	if(mi==ma) ans++;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1,x;i<=n;i++){
		cin>>a[i]>>x;
		add_edge(x,i);
	}
	dfs0(1);
	mi=1;
	dfs2(1);
	cout<<ans;
	return 0;
}

---

## 作者：FFTotoro (赞：7)

本题可以使用**莫队**思想。

对于树上每个结点，按照 dfs 序打上时间戳。然后每一个点的子树里的答案就可以转化为一个区间里的答案，可以使用莫队。

莫队中的 `add` 和 `del` 函数可以使用**多重**集合维护，集合中的元素是目前所有出现的颜色**出现的次数**。具体地，`add` 函数加入一个结点时，把它的颜色原来出现的次数从集合中删除，它的颜色出现的次数 $+1$，然后把现在的这个次数放入集合；`del` 函数也是类似的。一个区间解决完后，如果集合中最小的数与最大的数相等，就说明这个结点为根的子树是“颜色平衡树”，答案加上 $1$ 即可。

需要注意的是，如果把块长设置为 $\sqrt{n}$，那么将会 TLE。考虑使用常数块长，经测试，块长为 $6000$ 时可以通过本题。

放代码：

```cpp
#pragma GCC target("avx,avx2") // 指令集优化
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
int f[200001],c[200001],l[200001],t[200001],m[200001],o;
vector<int> g[200001];
vector<pii> q;
multiset<int> w; // 使用 STL 多重集合 multiset
inline int read(){
  int x=0; char c=getchar();
  while(!isdigit(c))c=getchar();
  while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=getchar();
  return x;
} // 快速读入，用于卡常
void add(int x){
  if(t[c[x]])w.erase(w.find(t[c[x]]));
  w.emplace(++t[c[x]]);
}
void del(int x){
  w.erase(w.find(t[c[x]]));
  if(--t[c[x]])w.emplace(t[c[x]]);
}
void dfs(int u){
  m[l[u]=++o]=u;
  for(int i:g[u])dfs(i);
  q.emplace_back(l[u],o); // 该结点管辖的区间
}
int main(){
  int n=read(),s=0,L=1,R=0,sq=6000;
  for(int i=1;i<=n;i++)
    c[i]=read(),g[f[i]=read()].emplace_back(i);
  dfs(1); // 预处理
  sort(q.begin(),q.end(),[&](pii a,pii b){
    if(a.first/sq!=b.first/sq)return a.first<b.first;
    return a.first/sq&1?a.second>b.second:a.second<b.second;
    }); // 奇偶性排序
  for(auto [l,r]:q){
    while(L>l)add(m[--L]);
    while(R<r)add(m[++R]);
    while(L<l)del(m[L++]);
    while(R>r)del(m[R--]);
    s+=*w.begin()==*prev(w.end());
  } // 莫队算法
  printf("%d\n",s);
  return 0;
}
```

---

## 作者：bochibochi (赞：3)

这道题可以用树上启发式合并解决。直接使用启发式合并维护子树中每种颜色出现的次数，然后开一个桶 $t_i$，记录有多少种颜色出现了 $i$ 次。设当前节点为 $p$，颜色为 $c$，每次只需要判断 $c\times t_c$ 是否等于 $siz_p$ 即可。

时间复杂度 $\mathrm O(n\log n)$

```cpp
#include<iostream>
#include<vector>
using namespace std;
const int maxn = 2000005;
int c[maxn], p[maxn], cnt[maxn], t[maxn];
int son[maxn], siz[maxn];
vector<int> ch[maxn];
void build(int x)
{
    siz[x] = 1;
    for(auto q: ch[x])
    {
        build(q);
        siz[x] += siz[q];
        if(siz[q] > siz[son[x]]) son[x] = q;
    }
}
void add(int x)
{
    t[cnt[c[x]]]--;
    cnt[c[x]]++;
    t[cnt[c[x]]]++;
    for(auto q: ch[x])
    {
        add(q);
    }
}
void rem(int x)
{
    t[cnt[c[x]]]--;
    cnt[c[x]]--;
    t[cnt[c[x]]]++;
    for(auto q: ch[x])
    {
        rem(q);
    }
}
int ans = 0;
void dfs(int x, int f)
{
    for(auto q: ch[x])
    {
        if(q != son[x])
        dfs(q, 0);
    }
    if(son[x])
    dfs(son[x], 1);
    t[cnt[c[x]]]--;
    cnt[c[x]]++;
    t[cnt[c[x]]]++;
    for(auto q: ch[x])
    {
        if(q != son[x])
        add(q);
    }
    if(cnt[c[x]]*t[cnt[c[x]]] == siz[x]) ans++;
    if(!f) rem(x);
}
int read()
{
    int n = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar(); }
    while(c >= '0' && c <= '9') n = n*10+(c^48), c = getchar();
    return n*f;
}
int main()
{
    int n;
    n = read();
    for(int i = 1; i <= n; i++)
    {
        c[i] = read();
        p[i] = read();
        ch[p[i]].emplace_back(i);
    }
    build(1);
    dfs(1, 1);
    cout << ans;
    return 0;
}
```

---

## 作者：piano_pei (赞：2)

### [题目传送门](https://www.luogu.com.cn/problem/P9233)

### 思路

先考虑暴力。显然对每颗子树做一遍 dfs 判定，如何判定？可以把 $C_i$ 装到桶 $\alpha_i$ 里，设 $\beta_i$ 表示有多少个 $\alpha_j$ 为 $i$，$typ$ 表示元素种类，$siz_i$ 表示以 $i$ 为根的子树的大小。显然我们只需判定 $typ|siz_u$ 且 $\beta_{siz_u/typ}=typ$ 即可。上述的数组插入 / 删除一个数均能 $O(1)$ 维护，时间复杂度 $O(n^2)$。

使用 dsu on tree 优化。我们不期望重儿子的子树遍历多次，因为它的节点数最多，损耗的时间最大。于是我们可以把每次重儿子遍历后的状态都保存不动，然后遍历非重儿子的子树，储存计算完后再删掉。因为轻边边数为 $\log n$ 条，所以总复杂度为 $O(n\log n)$。

### Code

以下设 $a=C$，$b=\alpha$，$c=\beta$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
#define pb push_back
const int N = 2e5 + 10;
vector<int> g[N];
int a[N], b[N], c[N], typ, ans, n;
int dp[N], siz[N], son[N], dfn[N], rdfn[N], dfscnt;
il void add(int x)
{
	c[b[x]]--, c[++b[x]]++;
	if(b[x] == 1) typ++;
}
il void del(int x)
{
	c[b[x]]--, c[--b[x]]++;
	if(!b[x]) typ--; 
}
il void dfs1(int u)
{
	dfn[u] = dp[u] = ++dfscnt;
	rdfn[dfscnt] = u;
	siz[u] = 1;
	son[u] = -1;
	for(auto &v : g[u])
	{
		dfs1(v);
		if(son[u] == -1 || siz[v] > siz[son[u]])
			son[u] = v;
		siz[u] += siz[v];
		dp[u] = max(dp[u], dp[v]);
	}
}
il void dfs2(int u, bool tag)
{
	for(auto &v : g[u])
		if(v != son[u])
			dfs2(v, 0);
	if(son[u] != -1)
		dfs2(son[u], 1);
	for(auto &v : g[u])
	{
		if(v != son[u])
		{
			for(int i = dfn[v];i <= dp[v];++i)
				add(a[rdfn[i]]);
		}
	}
	add(a[u]);
	if(siz[u] % typ == 0 && c[siz[u] / typ] == typ)
		ans++;
	if(!tag)
	{
		for(int i = dfn[u];i <= dp[u];++i)
			del(a[rdfn[i]]);
	}
}
int main()
{
	cin >> n;
	for(int i = 1;i <= n;++i)
	{
		int x;
		scanf("%d%d", &a[i], &x);
		if(!x) continue;
		g[x].pb(i);
	}
	c[0] = n;
	dfs1(1);
	dfs2(1, 0);
	cout << ans;
	return 0;
}
```

---

## 作者：Genius_Star (赞：2)

### 思路：
### 1. 树上莫队：

树上莫队 = 莫队 + 深搜序。

建树后求 dfs 序，每个子树对应的 dfs 区间就是一个询问区间，将询问区间排序后套用莫队。

维护当前颜色 $i$ 出现的次数 $now_{i}$、出现次数为 $i$ 的颜色种类数 $freq_i$。

任取区间内出现的一种颜色 $x$，若 $now_x \times freq_{now_x}$ 等于区间长度则合法，否则不合法。

时间复杂度为 $O(n \sqrt n)$。

#### 2. 启发式合并：

可以维护相同的东西，只是套了个启发式合并的壳。

重儿子直接继承当前维护的信息，把轻儿子维护的信息往重儿子上合并。

由于每个点至多出现在 $\log$ 个轻儿子所在的子树里，复杂度 $O(n \log n)$。
### 完整代码（树上莫队）：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e5+10;
int n,m,c[N],f,in[N],out[N],tot,id[N],pos[N],sz;
int now[N],freq[N],ans;
map<int,int>vis;
vector<int>e[N];
struct node{
	int l,r;
}q[N];
void add(int col,int v){
	freq[now[col]]--;
	now[col]+=v;
	freq[now[col]]++;
}
bool operator<(node a,node b){
	if(pos[a.l]==pos[b.l]){
		if(pos[a.l]&1)
		  return a.r>b.r;
		else 
		  return a.r<b.r;
	}
	return a.l<b.l;
}
void dfs(int u){
	in[u]=++tot;
	id[tot]=u;
	for(auto &v:e[u])
	  dfs(v);
	out[u]=tot;
	q[++m]={in[u],out[u]};
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d%d",&c[i],&f);
		if(!vis.count(c[i])){
			vis[c[i]]=1;
			freq[0]++;
		}
		if(i>1)
		  e[f].push_back(i);
	}
	dfs(1);
	sz=(int)sqrt(n);
	for(int i=1;i<=n;++i)
	  pos[i]=1+(i-1)/sz;
	sort(q+1,q+n+1);
	int l=1,r=1;
	add(c[1],1);
	for(int i=1;i<=n;++i){
		for(;r<q[i].r;r++)
		  add(c[id[r+1]],1);
		for(;r>q[i].r;r--)
		  add(c[id[r]],-1);
		for(;l<q[i].l;l++)
		  add(c[id[l]],-1);
		for(;l>q[i].l;l--)
		  add(c[id[l-1]],1);
		int col=c[id[l]],cnt=now[col],f=freq[cnt];
		if(f*cnt==r-l+1)
		  ans++;
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：BaiBaiShaFeng (赞：1)

## 题意

> 给你一颗节点数为 $n$ 的树，每个点有一个颜色，询问有多少节点满足它子树中各个颜色节点数相等。

我们还需要 $O(n\log n)$ 左右的算法。

## 分析

询问子树上的统计问题，我们可以使用树上启发式合并，这个题还是很套路的。

如何快速判断各个颜色数相等？我们记录一下总共出现的颜色数和每个节点数的颜色数量就行，这两个在树上启发式合并过程中维护就行，很简单，最后询问的时候我们利用所询问节点的颜色判断即可。

算是板子，具体实现看一下代码便懂了。

## 代码


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int MN=5e5+515;
struct Node{
    int nxt, to;
}node[MN];
int head[MN], tottt;
inline void insert(int u, int v){
    node[++tottt].to=v;
    node[tottt].nxt=head[u];
    head[u]=tottt;
    return;
}
int cntid[MN];//统计节点数量为i的颜色个数
int col[MN], tmp[MN];//存颜色的
int cntcol[MN], totcol;//统计一共有多少种颜色
void Add(int c){
    if(cntcol[c]==0) totcol++;
    cntcol[c]++;
    cntid[cntcol[c]-1]--;
    cntid[cntcol[c]]++;
}
void Del(int c){
    if(cntcol[c]==1) totcol--;
    cntcol[c]--;
    cntid[cntcol[c]+1]--;
    cntid[cntcol[c]]++;    
}
int Getsub(int u){
    int c=tmp[u];
    if(totcol==cntid[cntcol[c]]) return true;
    return false;
}
int depth[MN], fa[MN], siz[MN], son[MN], l[MN], r[MN];
int dfn_cnt;
void dfs1(int u, int father){
    fa[u]=father; depth[father]=depth[u]-1; siz[u]=1;
    l[u]=++dfn_cnt; col[dfn_cnt]=tmp[u];
    for(int i=head[u];i;i=node[i].nxt){
        int v=node[i].to;
        if(v==father) continue;
        dfs1(v,u);
        siz[u]+=siz[v];
        if(siz[son[u]]<siz[v]) son[u]=v;
    }
    r[u]=dfn_cnt;
}
int ans=0;
void dfs(int u, int father, bool keep){
    for(int i=head[u];i;i=node[i].nxt){
        int v=node[i].to;
        if(v==father||v==son[u]) continue;
        dfs(v,u,false);
    }
    if(son[u]) dfs(son[u],u,true);
    for(int i=head[u];i;i=node[i].nxt){
        int v=node[i].to;
        if(v==son[u]||v==father) continue;
        for(int j=l[v]; j<=r[v]; ++j){
            Add(col[j]);
        }
    }
    Add(tmp[u]);
    ans+=Getsub(u);
    if(!keep){
        for(int i=l[u]; i<=r[u]; ++i) Del(col[i]);
    }
}
int n;
signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); cin>>n;
    for(int i=1,c,father; i<=n; ++i){
        cin>>c>>father; tmp[i]=c;
        if(father) insert(i,father),insert(father,i);
    }
    dfs1(1,1);
    dfs(1,1,false);
    cout<<ans<<'\n';
    return 0;
}
```

---

## 作者：zzx0102 (赞：1)

这题可以莫队。

我们记第 $i$ 个节点的 dfn 序为 $D_i$，子树大小为 $sz_i$，由于一棵树的子树在 dfs 序上是一个连续段，所以 $i$ 的子树的所有节点都在 $[D_i,D_i+sz_i)$ 上。

接下来就比较简单了，莫队在 dfs 序上移动左右端点，可以考虑对于每种颜色的出现次数开个桶，然后维护每种颜色出现次数的种类数就可以了。

转移时稍微有点复杂，但是只要想明白了就能写出来。

复杂度 $O(m\sqrt n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 200010; int a[N], n, q, k;
struct Query {int id, l, r, k;} Q[N]; int in[N];
bool cmp(Query a, Query b) {return (in[a.l] != in[b.l]) ? (in[a.l] < in[b.l]) : ((in[a.l] & 1) ? a.r < b.r : a.r > b.r);}
vector<int> e[N]; int sz[N], D[N], d[N], tot;
void dfs(int u, int fa) {
//	cout << "u = " << u << ' ' << fa << ' ' << tot << '\n';
	sz[u] = 1; D[++tot] = u; d[u] = tot;
	for(int v: e[u]) {
		if(v == fa) continue;
		dfs(v, u); sz[u] += sz[v];
	}
}
int g[N], G[N], base, L[N], R[N], B, to[N], cnt[N], now;
void Add(int x) {
	if(g[x]) {
		cnt[g[x]]--;
		if(!cnt[g[x]]) now--;
	}
	g[x]++;
	if(!cnt[g[x]]) now++;
	cnt[g[x]]++;
}
void Del(int x) {
	cnt[g[x]]--;
	if(!cnt[g[x]]) now--;
	g[x]--;
	if(g[x]) {
		if(!cnt[g[x]]) now++;
		cnt[g[x]]++;
	}
}
int b[N];
int main() {
	ios::sync_with_stdio(0); cin >> n;
	for(int i = 1; i <= n; i++) {
		int f; cin >> a[i] >> f;
//		cout << i + 1 << ' ' << f << '\n';
		if(i > 1) e[f].push_back(i); e[i].push_back(f);
	}
	dfs(1, 0); base = sqrt(n); for(int i = 1; i <= n; i++) in[i] = (i + base - 1) / base; int ans = 0;
	for(int i = 1; i <= n; i++) Q[i].l = d[i], Q[i].r = d[i] + sz[i] - 1, Q[i].id = i; int l = 1, r = 0; sort(Q + 1, Q + 1 + n, cmp);
	for(int i = 1; i <= n; i++) {
		while(r < Q[i].r) Add(a[D[++r]]);
		while(l > Q[i].l) Add(a[D[--l]]);
		while(r > Q[i].r) Del(a[D[r--]]);
		while(l < Q[i].l) Del(a[D[l++]]);
		if(now == 1) ans++;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Tomwsc (赞：1)

# P9233 [蓝桥杯 2023 省 A] 颜色平衡树 题解

## 思路

算法标签里说要用树上启发式合并，所以考虑用 dsu on tree。

我们可以使用一个桶来记录每个颜色出现的次数，然后实时维护所有颜色出现次数的最大值 $maxn$。那怎样判断每个颜色的出现次数是否相等呢？设有 $cnt$ 个颜色的出现次数为 $maxn$，$sx_u$ 表示子树 $u$ 的大小，则显然有当 $cnt\times maxn = sz_u$ 时有子树 $u$ 为颜色平衡树。

每次删除轻儿子状态时只需要把其对应的颜色在桶中删减然后令 $maxn\leftarrow 0$，$cnt\leftarrow 0$ 即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define inf (1ll << 62)
#define pb push_back
#define mp make_pair
#define PII pair<int , int>
#define fi first
#define se second
using namespace std;
const int MAXN = 2e5 + 10;
int n , maxn , cnt;
vector<int>c(MAXN) , sz(MAXN) , son(MAXN) , ans(MAXN) , tot(MAXN) , G[MAXN];

void dfs1(int u , int fa) {
	sz[u] = 1;
	for(auto v : G[u]) {
		if(v == fa) continue;
		dfs1(v , u);
		sz[u] += sz[v];
		if(sz[son[u]] < sz[v]) {
			son[u] = v;
		}
	}
	return;
}

void add(int u , int fa , int p) {
	tot[c[u]] ++;
	if(tot[c[u]] > maxn) {
		maxn = tot[c[u]];
		cnt = 1;
	} else if(maxn == tot[c[u]]) {
		cnt ++;
	}
	for(auto v : G[u]) {
		if(v == fa || v == p) continue;
		add(v , u , p);
	}
	return;
}

void del(int u , int fa) {
	tot[c[u]] --;
	for(auto v : G[u]) {
		if(v == fa) continue;
		del(v , u);
	}
	return;
}

void dfs2(int u , int fa) {
	for(auto v : G[u]) {
		if(v == fa || v == son[u]) continue;
		dfs2(v , u);
		del(v , u);
		maxn = cnt = 0;
	}
	if(son[u]) dfs2(son[u] , u);
	add(u , fa , son[u]);
	ans[u] = ((cnt * maxn) == sz[u]);
	return;
}

inline void solve() {
	cin >> n;
	for(int i = 1;i <= n;i ++) {
		int fa;
		cin >> c[i] >> fa;
		if(i == 1) continue;
		G[fa].pb(i);
		G[i].pb(fa);
	}
	dfs1(1 , 0);
	dfs2(1 , 0);
	int cnt = 0;
	for(int i = 1;i <= n;i ++) {
		cnt += ans[i];
	}
	cout << cnt << "\n";
	return;
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int t = 1;
	while(t --) {
		solve();
	}
	return 0;
}
```

---

## 作者：SudoXue (赞：1)

[更好的阅读体验](https://www.cnblogs.com/xueruhao/p/18965361)

本题要求统计一棵根树中有多少棵子树满足“出现过的每种颜色次数全部相等”。朴素地为每个结点开哈希表统计其整棵子树颜色分布复杂度会达到 $O(n^2)$，显然无法通过规模上限 $n\le 2\times10^{5}$。关键在于如何把子树统计做成一次性、且只在必要位置增减。

先对整棵树做一次 DFS 获得 Euler 序，用数组 $\text{od}[1\ldots n]$ 记录节点在序中的出现顺序，并得到每个结点的子树区间 $[st[u],\,ed[u]]$。随后用 DSU on Tree 自顶向下遍历：处理完一条重链后，把轻儿子的小计全部并入这条重链对应的桶里，保证同一层级的插入总在“重”集合上完成，从而做到每个结点的贡献只在其所在重链被完整保留一次，其他场合被马上清空，整体复杂度 $O(n)$。

计数时维护两张整型全局数组：$\text{cnt}[c]$ 表示当前处理的子树内颜色 $c$ 的出现次数，$\text{frq}[k]$ 表示“出现恰好 $k$ 次的颜色种数”。再用整数 $\text{dif}$ 记录当前不同出现次数的种类数，即满足 $\text{frq}[k]>0$ 的 $k$ 的个数。插入或删除一个节点时，先把旧次数 $o=\text{cnt}[c]$ 在 $\text{frq}$ 中减一；若该次数消失则 $\text{dif}$ 减一。然后更新新次数 $o\pm1$，若该次数此前为空则 $\text{dif}$ 加一。这样每一步均为 $O(1)$。

长链遍历到某结点 $u$ 时，它的整棵子树统计已就绪。若 $\text{dif}=1$，说明此时所有出现次数都相同，子树 $u$ 即为颜色平衡树，答案自增。遍历结束后若当前子树不是重链保留下来的那一条，则将整个区间 $[st[u],\,ed[u]]$ 反向删除，恢复计数器，保证轻子树不会污染兄弟分支。

时间复杂度 $O(n)$。

[link](https://www.luogu.com.cn/record/222275176)

---

## 作者：hzx360 (赞：1)

**前言**：感谢审核大大百忙中审核 MnZn 题解。


------------


看到有关颜色统计的问题第一反应就是**莫队**（蒟蒻只会根号算法）。

深搜遍历树，以结点时间戳为下标，以其颜色为值，得到一个序列，然后就是正常的莫队了。

唯一需要改的地方就是莫队的 update，这里有几种方法：

1. 维护区间颜色出现次数的最大和最小值，若两个值相等那么颜色平衡。考虑到莫队每次都是单点更新，颜色出现次数每次只会加 $1$ 或减 $1$，所以可以用链表维护颜色从小到大的出现次数。

部分代码：
```
//s[0].ne=m+1,s[m+1].pre=0,t[m+1]=INF;(m是颜色的最大值)
void update(int x,int ad){
	if(ad==1){
		t[x]++;
		if(t[x]==1){
			s[x].ne=s[0].ne,s[x].pre=0;
			s[s[0].ne].pre=x,s[0].ne=x;
		}
		else{
			if(t[x]>t[s[x].ne]){
				int p=s[x].pre,q=s[s[x].ne].ne;
				s[p].ne=s[x].ne;
				s[s[x].ne].pre=p,s[s[x].ne].ne=x;
				s[q].pre=x;
				s[x].pre=s[x].ne,s[x].ne=q;
			}
		}
	}
	else{
		t[x]--;
		if(!t[x]) s[0].ne=s[x].ne;
		else{
			if(t[x]<t[s[x].pre]){
				int p=s[s[x].pre].pre,q=s[x].ne;
				s[p].ne=x;
				s[s[x].pre].pre=x,s[s[x].pre].ne=q;
				s[q].pre=s[x].pre;
				s[x].ne=s[x].pre,s[x].pre=p;
			}
		}
	}
}
```


------------

2. 维护有多少不同的颜色出现次数，假如一个颜色出现了 $a$ 次，另一个出现了 $b$，还有一个颜色也出现了 $b$ 次，那么就有 $2$ 种不同的出现次数。若颜色平衡则：不同的颜色出现次数必须为 $1$。

部分代码：
```
int t[N],show[N],res;
void update(int x,int ad){
	if(ad==1){
		if(t[x]){
			show[t[x]]--;
			if(!show[t[x]]) res--;
		}
		t[x]++;
		show[t[x]]++;
		if(show[t[x]]==1) res++;
	}
	else{
		show[t[x]]--;
		if(!show[t[x]]) res--;
		t[x]--;
		if(t[x]){
			show[t[x]]++;
			if(show[t[x]]==1) res++;
		}
	}
}
```


------------

3.维护有多少个出现次数为 $i$ 的颜色，用 $show_i$ 表示。若处理完一段区间。取区间内一个颜色 $c$，若 $show_{t_c} \times t_c$ 等于区间长度 $len$ ，则该区间颜色平衡（其中 $t_i$ 是颜色 $c$ 出现的次数）。这个很好证明。

部分代码：
```
int t[N],show[N],res;
void update(int x,int ad){
	if(ad==1){
		if(t[x]) show[t[x]]--;
		t[x]++;
		show[t[x]]++;
	}
	else{
		show[t[x]]--;
		t[x]--;
		if(t[x]) show[t[x]]++;
	}
}
```


------------

我用的是第二种，这里是完整代码：

[code](https://www.luogu.com.cn/paste/165d8128)

完结撒花 QAQ。


---

## 作者：elbissoPtImaerD (赞：1)

子树，发现每个节点的答案是其子树的叠加。

考虑静态链分治。

每种颜色的结点个数都相同这个约束很丑，将它转化一下：等价于这颗树中有出现的数字的出现次数的最大值等于最小值。

那最大值和最小值如何维护？

由于每次更改只会让某个数的出现次数 $\pm1$，考虑维护：$f_i$ 表示颜色为 $i$ 的数出现了几次，$g_i$ 表示满足 $f_j=i$ 的 $j$ 的个数。

这样就能做了。

[$\color{green}{\checkmark}$](https://www.luogu.com.cn/record/110194226)。

```cpp
const int N=2e5+3;
int n,a[N],son[N],sz[N],f[N],g[N],res[2]={1,0},ans;
//res_0: min, res_1: max
struct wt
{
	wt*nxt;
	int v;
}E[N],*hd[N],*ind=E+1;
il void E_add(re int u,re int v){return *++ind={hd[u],v},hd[u]=ind,void();}
#define G_auto(i,u,v) for(re wt*i=hd[u];i&&(v=i->v);i=i->nxt)
void dfs_1(re int u)
{
	sz[u]=1;
	re int v;
	G_auto(i,u,v) dfs_1(v),sz[v]>sz[son[u]]&&(son[u]=v),sz[u]+=sz[v];
	return;
}
#define cmax(x,y) ((x)<(y)&&((x)=(y)))
#define cmin(x,y) ((x)>(y)&&((x)=(y)))
il void Add(re int x){return --g[f[x]],++g[++f[x]],cmax(res[1],f[x]),f[x]==1&&(res[0]=1),!g[res[0]]&&(++res[0]),void();}
il void Del(re int x){return --g[f[x]],++g[--f[x]],f[x]&&(cmin(res[0],f[x])),!g[res[1]]&&(--res[1]),void();}
void dfs_M(re int u,re bool tag)
{
	tag?Add(a[u]):Del(a[u]);
	re int v;
	G_auto(i,u,v) dfs_M(v,tag);
	return;
}
void dfs_2(re int u)
{
	re int v;
	G_auto(i,u,v) v^son[u]&&(dfs_2(v),dfs_M(v,false),7);
	son[u]&&(dfs_2(son[u]),7),Add(a[u]);
	G_auto(i,u,v) v^son[u]&&(dfs_M(v,true),7);
	ans+=res[0]==res[1];
	return;
}
void Solve()
{
	rd(n);
	for(re int i=1,x;i<=n;++i) rd(a[i]),rd(x),E_add(x,i);
	dfs_1(1),dfs_2(1),prt(ans,'\n');
	return;
}
```

---

## 作者：L0vely_NaiL0ng (赞：1)

我们考虑莫队，将子树询问离线下来变成 $n$ 个区间询问。

在下文，我将数组中**同一数值**的元素称为**一种元素**。

下文注意区分 $cnt$ 与 $tot$，**一种元素**和**一个元素**。

用 $cnt$ 数组维护颜色的出现次数，那么如果一个询问有贡献，当且仅当 $cnt$ 数组中所有非零元素都一样，于是我们再维护 $cnt$ 数组中有**多少种互不相同**的元素即可，用 $res$ 记录，那么当 $res$ 等于 $1$ 时，全局答案加一。

具体而言，我们用 $tot$ 维护当前 $cnt$ 中**每种元素**的出现次数，如果 $tot$ 中**某一个元素**从 $0$ 变为 $1$（相当于 $cnt$ 中多了**一种元素**），将 $res$ 加一。反之，如果 $tot$ 中**某一个元素**从 $1$ 变为 $0$（相当于 $cnt$ 少了**一种元素**），将 $res$ 减一。

复杂度 $O(n \sqrt{n})$，实测非常快，相较于有一篇题解用莫队和平衡树维护的 $n \sqrt{n} \log n$ 做法好很多，也不用卡常。

我的代码实现基本按照我讲的写的，其中记得特判 $cnt$ 中元素为 $0$ 的情况，如果还有不懂可以反复研读一下前面的内容，有问题可以私信联系或者博客评论。


```
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
int n, a[N], cnt[N], tot[N], res, siz[N], ans, m, pos[N], t, dfn[N], num, id[N];
vector<int> e[N];
struct node {
	int l, r;
} q[N];
bool cmp(node i, node j) {
	if (pos[i.l] == pos[j.l]) {
		if (pos[i.l] & 1) return i.r < j.r;
		return i.r > j.r;
	}
	return i.l < j.l;
}
void dfs(int x) {
	siz[x] = 1; dfn[x] = ++num; id[num] = x;
	for (int y : e[x]) {
		dfs(y); siz[x] += siz[y];
	}
	q[++t] = {dfn[x], dfn[x] + siz[x] - 1};
}
void add(int x) {
	if (cnt[a[x]]) {
		tot[cnt[a[x]]]--;
		if (!tot[cnt[a[x]]]) res--;	
	}
	cnt[a[x]]++;
	tot[cnt[a[x]]]++;
	if (tot[cnt[a[x]]] == 1) res++;
}
void del(int x) {
	tot[cnt[a[x]]]--;
	if (!tot[cnt[a[x]]]) res--;
	cnt[a[x]]--;
	if (cnt[a[x]]) {
		tot[cnt[a[x]]]++;
		if (tot[cnt[a[x]]] == 1) res++;		
	}
}
int main() {
	cin >> n; m = sqrt(n);
	for (int i = 1; i <= n; i++) {
		pos[i] = (i - 1) / m + 1;
		int x; cin >> a[i] >> x;
		e[x].push_back(i);
	}
	dfs(1);
	sort(q + 1, q + n + 1, cmp);
	for (int l = 1, r = 0, i = 1; i <= n; i++) {
		while (l > q[i].l) add(id[--l]);
		while (r < q[i].r) add(id[++r]);
		while (l < q[i].l) del(id[l++]);
		while (r > q[i].r) del(id[r--]);
		ans += (res == 1);
	}
	cout << ans;
	return 0;
}
```

---

## 作者：4BboIkm7h (赞：0)

虽然这题的标签里面只有树上启发式合并，但是对于这样的颜色计数问题，莫队也同样可以做的。

## 分析
题中所说“子树中的每种颜色的结点个数都相同”其实可以翻译为：**“颜色的出现次数”的种类数为 $1$**。通俗来说，如果我们把“一种颜色的出现次数”也看成另一种颜色 $C'$，那么只需要这种颜色 $C'$ 的种类数为 $1$，就代表“子树中的颜色只有这一种出现次数”的意思，当然也就是“子树中的每种颜色的结点个数都相同”的意思了。

干讲可能有点抽象，我们结合题中给的样例来看：

|节点编号|$1$|$2$|$3$|$4$|$5$|$6$|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|颜色|$2$|$2$|$1$|$3$|$3$|$1$|

对于整棵树，也就是以 $1$ 为根的子树中，颜色 $1,2,3$ 均出现了两次，那么“颜色的出现次数”就只有一种，所以这是一棵颜色平衡树。

而对于以 $4$ 为根的子树，它包含节点 $4,5,6$，其中颜色 $1$ 出现 $1$ 次，颜色 $3$ 出现 $2$ 次，那么“颜色的出现次数”就有两种，所以这不是一棵颜色平衡树。

|节点编号|$1$|$2$|$3$|$4$|$5$|$6$|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|子树中“颜色的出现次数”的种类数|$1$|$2$|$1$|$2$|$1$|$1$|

同理得出，编号为 $1,3,5,6$ 的 $4$ 个结点对应的子树，“颜色的出现次数”的种类数为 $1$，所以它们都是颜色平衡树。

这样，代码就很好写了。先 $\text{dfs}$ 一遍，把子树查询转化为 $\text{dfs}$ 序上的区间查询。开两个桶，`cnt[i]` 记录颜色 $i$ 的出现次数，`ccnt[i]` 记录“颜色出现次数为 $i$ ”的出现次数，然后把莫队的板子套上去就可以了。需要注意一下 `add` 和 `del` 函数中的一些细节。

时间复杂度：$O(n\sqrt n)$。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
inline int read(){
    int x = 0, neg = 1;
    char c = getchar();
    while(!isdigit(c)){
        if(c == '-') neg = -1;
        c = getchar();
    }
    while(isdigit(c)){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * neg;
}
int n, m, B, root, col[N], a[N], cnt[N], ccnt[N], ans, sum;
struct edge{
    int nex, to;
} e[N << 1];
int tot, head[N], siz[N], dfn[N], idx;
void add(int u, int v){
	e[++tot] = {head[u], v};
	head[u] = tot;
}
void dfs(int u, int f){
	siz[u] = 1;
    dfn[u] = ++idx;
    a[idx] = col[u];
	for(int i = head[u]; i; i = e[i].nex){
		int v = e[i].to;
		if(v == f) continue;
		dfs(v, u);
		siz[u] += siz[v];
	}
}
struct dat{
	int l, r;
	bool operator < (const dat &A) const{
		if(l / B != A.l / B) return l < A.l;
		if((l / B) & 1) return r < A.r;
		else return r > A.r;
	}
} q[N];
void add(int x){
    if(cnt[x]){
        ccnt[cnt[x]]--;
        if(!ccnt[cnt[x]]) sum--;
    }
    cnt[x]++;
    if(!ccnt[cnt[x]]) sum++;
    ccnt[cnt[x]]++;
}
void del(int x){
    ccnt[cnt[x]]--;
    if(!ccnt[cnt[x]]) sum--;
    cnt[x]--;
    if(cnt[x]){
        if(!ccnt[cnt[x]]) sum++;
        ccnt[cnt[x]]++;
    }
}
int main(){
    n = read();
    B = (int)sqrt(n);
    for(int i = 1; i <= n; i++){
        col[i] = read();
        int f = read();
        if(!f){
            root = i;
            continue;
        }
        add(f, i), add(i, f);
    }
    dfs(root, 0);
    for(int i = 1; i <= n; i++) q[i] = {dfn[i], dfn[i] + siz[i] - 1};
    sort(q + 1, q + n + 1);
    int l = 1, r = 0;
    for(int i = 1; i <= n; i++){
        while(l > q[i].l) add(a[--l]);
        while(r < q[i].r) add(a[++r]);
        while(l < q[i].l) del(a[l++]);
        while(r > q[i].r) del(a[r--]);
        if(sum == 1) ans++;
    }
    printf("%d", ans);
    return 0;
}
```

---

## 作者：lzt415 (赞：0)

# P9233 颜色平衡树
从树上启发式合并找到的题，所以就讲讲树上启发式合并这个做法吧。
## meaning
给定一棵树，求有多少棵子树，满足出现过的颜色出现次数均相等。
## solve
此处默认了解过树上启发式合并。

这个题目一看就很板，实际上这就是个模板题。我们需要记录颜色出现次数均相等，直接记录每种颜色出现次数显然不大可能，但我们换个思路，话说每种颜色出现次数均相等，不就意味着出现的最多次数等于出现的最少次数吗？所以我们只需记录出现颜色次数的 $min$ 值和 $max$ 值，判断是否相等即可。

至于怎么记录，开两个数组即可，一个是记录颜色个数，一个是记录权值出现次数。

可能有些细节实现需要注意，具体细节看代码，大致思路就到这里。
## code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+10;
struct node{
	int next,to;
}e[N];
int n,cnt,ans,imax,imin;
int head[N],siz[N],son[N],col[N],num1[N],num2[N];
void add(int u,int v)
{
	e[++cnt]={head[u],v};
	head[u]=cnt;
}
void add(int x)
{
	num2[num1[x]]--;
	num1[x]++;
	num2[num1[x]]++;
	if(num1[x]<imin) imin=num1[x];
	if(num1[x]>imax) imax=num1[x];
	if(!num2[imin]) imin++;
}
void del(int x)
{
	num2[num1[x]]--;
	num1[x]--;
	num2[num1[x]]++;
	if(num1[x]&&num1[x]<imin) imin=num1[x];
	if(!num2[imax]) imax--;
}
void dfs1(int u)
{
	siz[u]=1;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		dfs1(v);
		if(siz[v]>siz[son[u]]) son[u]=v;
		siz[u]+=siz[v];
	}
}
void dfs2(int u,int sign)//绝对没有人像我一样傻呵呵地以为sign=0可以不递归吧
{                        //真服了自己当时神奇的脑回路，忍不住记一下，笑死
	if(sign) add(col[u]);
	else del(col[u]);
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		dfs2(v,sign);
	}
}
void dfs3(int u)
{
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(v==son[u]) continue;
		dfs3(v);
		dfs2(v,0);
	}
	if(son[u]) dfs3(son[u]);//勿忘
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(v==son[u]) continue;
		dfs2(v,1);
	}
	add(col[u]);//勿忘
	if(imin==imax) ans++;
}
int main()
{
	cin>>n;
	for(int i=1,fa;i<=n;i++)
	{
		cin>>col[i]>>fa;
		add(fa,i);
	}
	dfs1(1);
	imin=1;//勿忘
	dfs3(1);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：xuanfeng101 (赞：0)

## 前言
算是一道**树上启发式合并**模板题。
## 题解
首先**树上启发式合并**就起源于树上数颜色类问题，所以对启发式合并有所了解的人不难想到可以用此算法。

树上启发式合并本质上是一种对于**暴力的优化算法**。对于此题，我们考虑暴力维护所以子树的所有颜色，很显然时间复杂度为 $O(n ^ 2)$ 不能通过此题。而分析其中原因就是我们可能对于**子树中的深度较深的某些节点**最多会算 $O(n)$ 次，导致复杂度爆炸。如果我们能控制每个节点计算次数为 $O(\log n)$ 次，那么整体的复杂度就可以接受。

于是就诞生了一种基于**重链剖分**的算法，也就是先求出所有节点的重儿子。对于**重儿子的子树**的贡献我们最后算且保留，对于**轻儿子**的**子树贡献**我们先算并且不保留。当重儿子算完之后再遍历一遍，统计答案而**不记录贡献**。由于**重链剖分**的天然特征，轻儿子的节点个数**小于等于子树大小的一半**，所以每个包含该节点的根节点的子树大小是**指数型增长**，也就有了前面所说 $O(\log n)$ 的计算次数的性质。

解决了大体框架，我们考虑具体怎么计算。我们可以维护两个信息 $sum$ 和 $mx$ 表示**该子树中不同颜色的个数**和**出现次数最多颜色的节点个数**，那么当一个子树所有颜色个数相同时就必然有 $sz_u = sum \cdot mx$，那么每次判断即可。不过需要注意的是，每次**第一遍访问轻儿子回溯**时要清空 $sum$ 和 $mx$。
## 时间复杂度
$O (n \log n)$
## Code
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 10;
int n, c[N];
int e[N], ne[N], h[N], idx;
int son[N], sz[N], cnt[N], flag;
int mx, sum, ans, w[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs1(int u)
{
    sz[u] = 1;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        dfs1(j);
        sz[u] += sz[j];
        if (sz[j] > sz[son[u]]) son[u] = j;
    }
}

void add_tree(int u, int son)
{
    if (!cnt[w[u]]) sum ++ ;
    mx = max(mx, ++ cnt[w[u]]);
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (j == son) continue;
        add_tree(j, son);
    }
}

void del(int u)
{
    cnt[w[u]] -- ;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        del(j);
    }
}

void dfs2(int u, bool op)
{
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (j == son[u]) continue;
        dfs2(j, 0);
    }
    if (son[u]) dfs2(son[u], 1);
    add_tree(u, son[u]);
    if (sum * mx == sz[u]) ans ++ ;
    if (op) return;
    del(u);
    sum = mx = 0;
}

signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    memset(h, -1, sizeof h);
    cin >> n;;
    for (int i = 1; i <= n; i ++ )
    {
        int x;
        cin >> w[i] >> x;
        if (x) add(x, i);
    }
    dfs1(1);
    dfs2(1, 1);
    cout << ans;
    return 0;
}
```

---


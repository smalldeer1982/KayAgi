# [蓝桥杯青少年组国赛 2023] 数学实验

## 题目背景

本题原题为：[P3147 [USACO16OPEN] 262144 P](https://www.luogu.com.cn/problem/P3147)。

## 题目描述

老师在黑板上写出了一个正整数数列，让所有同学都来做一个数学实验，要求如下:  
1. 这组数总共不超过 $500000$ 个，每个数的大小范围在 $1 \sim 80$ 之间；  
2. 要从这组数中找出两个相邻且相同的数，删掉其中一个数，剩下的一个数加 $1$（例如: 两个相邻的 $6$，变成一个 $7$）；  
3. 重复执行第 $2$ 步；  
4. 当操作无法继续进行时，实验结束，此时，实验结果就是这组数里面最大的数。  

注意: 不同的实验方案得到的最大数不同。  

现在给定了一个正整数数列，请你编写程序计算出能够得到的实验结果最大是多少。

例如：当 $N=6$，这个正整数数列是 $1$、$2$、$2$、$2$、$3$、$4$ 时，得到最大数的方法如下：先将后面两个 $2$ 变成一个 $3$ ，然后 $3$ 和 $3$ 变成 $4$，最后 $4$ 和 $4$ 变成 $5$。可以证明，没有其它更好的方案，故输出 $5$。

## 样例 #1

### 输入

```
6
1 2 2 2 3 4```

### 输出

```
5```

# 题解

## 作者：Yi_chen123 (赞：2)

## 思路

区间 DP 好题。  
先把三要素给理出来吧。

### 状态

我们令 $dp_{i,j}$ 代表从索引 $i$ 出发，能够合成出 $j$ 的最优结束索引 $+1$。（如果合成不出来，则 $dp_{i,j} = 0$。）

### 边界

我们假设 $a$ 是程序中输入进去的数组，那么很明显 $dp_{i, a_i} = i + 1$。因为从 $i$ 出发已经不需要再合成 $a_i$。

### 转移

略有些烧脑了哦。  
我们使用倍增思想，考虑 $dp_{i,j}$ 如何转移。  
根据题意我们可以得知，要想合成出 $j$，我们需要两个 $j-1$ 进行合成，或者某个地方本身就有 $j$（就是动态规划边界）。  
所以，我们从 $i$ 出发，要先合成出一个 $j-1$，因此我们需要知道 $dp_{i, j-1}$，然后，我们再从 $dp_{i, j-1}$ 位置出发，找到第二个 $j-1$。最终合并即可。  
故动态转移方程如下：
$$
\large dp_{i,j} = dp_{dp_{i, j-1}, j-1}
$$
（**注**：此处的 $\LaTeX$ 使用了 `\large` 字号，是由于出现了嵌套的下角标，为了使公式更加清晰故使用。）

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int ar[510005];
int dp[510005][100];
int main(){
    int n; cin >> n;
    for(int i = 1; i <= n; ++i){
    	cin >> ar[i];
        dp[i][ar[i]] = i + 1;
	}
	int ans = 0;
	for(int j = 2; j <= 98; ++j){
		for(int i = 1; i <= n; ++i){
            if(!dp[i][j]) dp[i][j] = dp[dp[i][j - 1]][j - 1];
            if(dp[i][j]) ans = j; //如果可以合成，才记录到答案中
		}
	}
	cout << ans << endl;
	return 0;
}
```

对了，给大家注明一下此处的 $98$ 是什么：如果真的出现了 $5 \times 10^5 \approx 2^{18}$ 个数，并且每个数都是 $80$，那么最大也只可能合成 $18 + 80 = 98$，因此仅循环遍历至 $98$。

**三倍经验：**   
- [P3146 [USACO16OPEN] 248 G](https://www.luogu.com.cn/problem/P3146)
- [P3147 [USACO16OPEN] 262144 P](https://www.luogu.com.cn/problem/P3147)

---

## 作者：RainySoul (赞：1)

这个题第一眼看上去像一个比较典的区间 $\text{dp}$，正当你思考它为什么是蓝题的时候你看到 $N \le 500000$ 直接炸毛。

考虑优化状态设计，你在脑海里模拟了一下两个 $1$ 拼出一个 $2$，两个 $2$ 拼出一个 $3$，感觉它非常倍增。就像是 $2^0+2^0=2^1,2^1+2^1=2^2$ 这样。

回忆倍增是怎么做的，就是设 $dp_{i,j}$ 表示 $i$ 后面 $2^j$ 个数的和之类的东西，然后利用 $dp_{i,j-1}$ 更新 $dp_{i,j}$ 这样的对吧。模仿倍增，设计状态：$dp_{i,j}$ 表示以 $i$ 为左端点合出 $j$ 时的右端点。

状态设计完转移方程就及其简单了（为了看得清就不用 $\LaTeX$ 了）：

$$dp[i][j]=dp[dp[i][j-1]+1][j-1]$$

注意当 $dp_{i,j-1}$ 没有值的时候你肯定是不能用它转移的，当 $dp_{i,j}$ 有值的时候你肯定没必要再做一遍了。转移显然需要先枚举 $j$。

#### 为什么 $j$ 的上界是 $99$？

严格地来说我应该写 $98$ 的，因为 $80+\log_2 500000 \approx98.931568569$，所以就算 $500000$ 个数全都是 $80$，最多也只能合到 $98$。但是你不觉得 [**99**](https://baike.baidu.com/item/99/1010419) 非常地具有美感吗？开大一点并不影响，因为合不到。如果我说上界是 $114514$ 也是同理（不过开不下）。

最后是初值的问题相信大家都会。

AC code：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=500010;
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=x*10+c-'0';
        c=getchar();
    }
    return x*f;
}
int n,a[N],dp[N][110],ans;
int main(){
    n=read();
    for(int i=1;i<=n;i++)a[i]=read();
    for(int i=1;i<=n;i++)dp[i][a[i]]=i;
    for(int j=1;j<=99;j++){
        for(int i=1;i<=n;i++){
            if(dp[i][j]==0&&dp[i][j-1]!=0)dp[i][j]=dp[dp[i][j-1]+1][j-1];
            if(dp[i][j]!=0)ans=j;
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/B4280#ide)

### 前言
这道题要求我们对一个数列进行操作，每次合并两个相邻且相同的数，将其替换为一个更大的数，直到无法继续操作为止。我们需要找到能够得到最大数的合并方案。

## 思路
这道题可以采用动态规划来解决，我们定义 $dp[i][j]$ 表示从位置 $i$ 开始能够合并出数值 $j$ 的最远位置，初始时每个数字本身就是一个可能的合并结果。通过遍历数组，对于每个位置 $i$ 和数值 $j$，如果存在相邻区间可以合并出相同的j值，就能进一步合并得到  $j+1$。这种方法通过记录每个数值能够延伸的最远位置，有效地减少了重复计算，最终所有可能合并出的最大值中的最大者即为答案。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int an = 500000;
const int av = 80;
int main() {
    int N;
    cin >> N;
    vector<int> nums(N);
    for (int i = 0; i < N; ++i) {
        cin >> nums[i];
    }
    vector<vector<int>> dp(N, vector<int>(av + 2, -1));
    int ar = 0;
    for (int i = 0; i < N; ++i) {
        dp[i][nums[i]] = i + 1;
        ar = max(ar, nums[i]);
    }
    for (int j = 1; j <= av; ++j) {
        for (int i = 0; i < N; ++i) {
            if (dp[i][j] != -1 && dp[i][j] < N) {
                if (dp[dp[i][j]][j] != -1) {
                    dp[i][j + 1] = dp[dp[i][j]][j];
                    ar = max(ar, j + 1);
                }
            }
        }
    }
    cout << ar << endl;
    return 0;
}
```

---

## 作者：DashZhanghanxu (赞：1)

# 解析
动态规划做法。

注：该代码仅限于本题可过，原题因为内存限制会有两个点超内存限制。

每个 $dp$ 数组中的元素都代表一个区间，$v$ 代表当前合并后可能可以得到的值。

先初始化 $dp$ 数组（每个数字本身就是一个自己到自己区间，所以记得判断最大值是否要更新），然后我们可以枚举每个区间是否可以合并（即 $[k+1,j]$ 也是 $v$），存在，就将其合并，并且更新当前最大值。
# CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[500001];
unordered_map<int,int>dp[302];
signed main(){
    ios::sync_with_stdio(0),cin.tie(0);
    int n,mx=0;
	cin>>n;
    for(int i=0;i<n;cin>>a[i],mx=max(mx,a[i]),i++);//nothing here
    
    for(int i=0;i<n;dp[a[i]][i]=i,i++);//nothing here
    
    for(int v=1;v<300;v++)
        for(auto&p:dp[v])
            if(dp[v].count(p.second+1))
                dp[v+1][p.first]=dp[v][p.second+1],mx=max(mx,v+1);
    cout<<mx;
}    
```

---

## 作者：Chaser_of_light (赞：0)

### 思路
本题优化：**倍增思想**。  
其实这题与原题没有区别，~~但是原题代码交到本题会过不了~~。    
#### 题意：  
  1. 给定一个序列，长度最多到 $5\times10^5$。
  2. 我们需要进行若干次操作使序列中相邻两个一样的数合成为一个比其大一的数，直到无法合成为止。
  3. 求一种方案使合成后序列中的最大数最大化，输出该数。
#### 分析：
我们想到了区间 DP，但鉴于其~~优秀~~ $O(n^3)$ 的复杂度和 $5\times10^5$ 的数据量我们决定~~放弃~~优化这个算法。  
如何优化？我们想到题目的独特：“找出两个相邻且相同的数，删掉其中一个数，剩下的一个数加 $1$。”这非常像~~就是~~ 2048。于是我们设出了状态：$f_{i,j}$ 表示第 $i$ 个数合成了数字 $j$ 后能够向右拓展的最右端点，即这个数字合成完后的最右端点。有点难理解但自己画画图就想明白了。  
状态转移方程就为：
$$
f_{i,j}=f_{f_{i,j-1},j-1}
$$
显然就是将两个 $j-1$ 合并。  
只要枚举到 $98$，因为 $5\times10^5$ 个 $80$ 最多合成 $98$。  
边界就是初始序列决定。  
详见代码。
### Code
````cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,ans;
int f[1000005][105],a[1000005];
signed main(){
    scanf("%lld",&n);
    for (int i=1;i<=n;i++){
        scanf("%lld",&a[i]);
        f[i][a[i]]=i+1;
    }
    for (int j=2;j<=98;j++)
        for (int i=1;i<=n;i++){
            if (f[i][j]==0) f[i][j]=f[f[i][j-1]][j-1];
            if (f[i][j]>0) ans=j;
        }
    printf("%lld\n",ans);
    return 0;
}
`````
复杂度 $O(dn)(d=98)$。  
很多时候要从**复杂度**开始考虑使用的算法。

---

## 作者：封禁用户 (赞：0)

双倍经验 [P3147](https://www.luogu.com.cn/problem/P3147)。

### 思路

这道题是区间 DP。

我们使用 $f[i][j]$ 表示以 $j$ 为左端点，第一个能得到数字 $i$ 的右端点的右边位置。首先初始化对于第 $k$ 个数字 $a_k$，$f[a_k][k]=k+1$。

那么想要得到 $i$，我们就需要两个 $i-1$ 进行操作。

由此我们可以得出，以 $j$ 为左端点，第一个能得到数字 $i$ 的右端点的右边位置可以这样求出：

$$f[i][j]=f[i-1][f[i-1][j]]$$

$f[i-1][f[i-1][j]]$ 是什么意思呢？

很明显 $f[i-1][j]$ 是以 $j$ 为左端点，第一个能得到数字 $i-1$ 的右端点的右边位置。

那么只需要从这个位置开始再得到一个 $i-1$，就可以得到 $i$ 了。

能得到的最大的 $i$ 就是答案。

如果 $500000$ 个数字全都是 $80$，那么最大能得到数字 $98$。因此 $i$ 至少需要从 $2$ 枚举到 $98$。

这里我们枚举到 $100$。

### 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[101][500005];
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        int t;
        cin>>t;
        dp[t][i]=i+1;
    }
    int x;
    for(int i=2;i<=100;i++){
        for(int j=1;j<=n;j++){
            if(!dp[i][j]){
                dp[i][j]=dp[i-1][dp[i-1][j]];
            }
            if(dp[i][j])x=i;
        }
    }
    cout<<x;
}
```

---


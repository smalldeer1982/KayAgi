# [蓝桥杯青少年组国赛 2023] 月球疏散行动

## 题目背景

本题原题：[P5017 [NOIP 2018 普及组] 摆渡车](https://www.luogu.com.cn/problem/P5017)

## 题目描述

为了避免太阳爆发引起的灾难，人类决定给地球装上发动机，最终逃离太阳系。原计划要带着月球一起走，结果月球行星发动机发生灾难性故障，必须炸毁月球。为此，在月球上的工作人员都要疏散回地球。

月球基地有一艘太空穿梭机可以用来疏散工作人员。但是人们分散在各处，必须前往基地集合，他们到达基地的时间不等。穿梭机可以将抵达基地等待登机的工作人员先送回地球，然后再返回基地疏散下一批工作人员。

总共有 $N$ 名工作人员需要疏散，太空穿梭机从月球到地球往返一次花时间 $M$ 小时，第 $i$ 个人抵达基地等待登机的时刻为 $T_i$。

指挥官希望所有工作人员在基地等待的时间总和最小，而且他可以任意安排穿梭机的起飞时间，假定穿梭机足够大，可以装下所有工作人员，在不计登机和下机时间等因素的情况下，最小的等候时间总和是多少？

例如：$N=5$，$M=4$，1 号~5 号工作人员到达基地的时刻依次为 11、3、3、5、10，穿梭机可以在 3 时出发，先送 2 号、3 号工作人员去地球，然后于 7 时返回月球基地；此时，4 号工作人员已于 5 时到达基地，等候了 2 小时。这时让穿梭机马上送走他，然后于 11 时从地球返回基地；此时，5 号工作人员已于 10 时到达基地，等候了 1 小时；而 1 号工作人员刚好于 11 时到达基地，等候 0 小时；穿梭机于 11 时将两人送走，即完成全部疏散任务。总的等候时间 $=$ 4 号工作人员等候时间 $+$ 5 号工作人员等候时间 $=2+1=3$ 小时。无法再找到有更小等候时间总和的方案。

## 样例 #1

### 输入

```
5 4
11 3 3 5 10```

### 输出

```
3```

# 题解

## 作者：YZren (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/B4281)

# 思路

- 此题与[摆渡车](https://www.luogu.com.cn/problem/P5017)一模一样，很容易想到一个 DP 方程 $dp_i=\min\limits_{j=1}^{i-m} (dp_j+sum_i-sum_j)$ 其中 $dp_i$ 表示前 $i$ 时刻到达的所有学生等待的最小时间。

- 很明显直接做肯定超时，所以需要优化。

- 首先进行前缀和优化，由于 $sum_i$ 不好直接处理，所以分为 $tim_i$ 表示前 $i$ 时刻到达的总人数和 $s_i$ 表示前 $i$ 时刻所有学生到达的总时间，那么 $sum_i-sum_j=(tim_i-tim_j)\times i-s_i+s_j$ 这就可以优化 DP 方程。

- 这样还是会超时，注意到 DP 方程为 $dp_i=\min\limits_{j=1}^{i-m}(-tim_j\times i+s_j+dp_j)+tim_i\times i-s_i$ 很明显可以使用斜率优化，维护下凸壳即可。

- 推一下斜率方程，先令 $k<j<i-m+1$ 并且从 $j$ 转移更优，则 $-tim_j\times i+s_j-dp_j<-tim_k\times i+s_k+dp_k$ 化简可得，先令 $G_i=s_i+dp_i$ 那么 $i>\frac{G_j-G_k}{tim_j-tim_k}$ 就是斜率方程了。

- 有了斜率方程，我们就可以用单调队列优化了，不会的可以先学一下斜率优化。

# Code


```cpp
#include<bits/stdc++.h>
#define endl "\n"
#define f(i,j,k) for(int i=j;i<=k;i++)
#define F(i,j,k) for(int i=j;i>=k;i--)
using namespace std;
const int maxn=4e6+10;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x){
	if(x<0) {x=~(x-1); putchar('-');}
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int n=read(),m=read(),tim[maxn],dp[maxn],ans,s[maxn],que[maxn],L=1,R,u,maxx;
inline double slop(int k,int j){
	int up=dp[j]+s[j]-dp[k]-s[k];
	if(tim[j]==tim[k]) return (double)up/1e-9;
	else return (double)(up/(tim[j]-tim[k]));
}
inline void work(){ 
	f(i,1,n) u=read(),tim[u]++,s[u]+=u,maxx=max(maxx,u);
	maxx+=m-1; f(i,1,maxx) tim[i]+=tim[i-1],s[i]+=s[i-1];
	f(i,1,maxx){
		if(i>=m){
			while(L<R&&slop(que[R-1],que[R])>=slop(que[R],i-m)) R--;
			que[++R]=i-m;
		}
		while(L<R&&slop(que[L],que[L+1])<=i) L++;
		dp[i]=tim[i]*i-s[i];
		if(L<=R) dp[i]=min(dp[i],dp[que[L]]+(tim[i]-tim[que[L]])*i-s[i]+s[que[L]]);
	}
	ans=dp[maxx-m+1]; f(i,maxx-m+1,maxx) ans=min(ans,dp[i]);
	write(ans);
}
signed main(){work();return !!!!!("YZren");}
```

---

## 作者：TJB_LHY (赞：2)

#### 一些闲话

[原题传送门](https://www.luogu.com.cn/problem/B4281)、[双倍经验](https://www.luogu.com.cn/problem/P5017)，这两题不是一模一样的吗？甚至输入输出都没改？？？

### 形象化题意

给定两个正整数 $n$ 和 $m$，以及一个长度为 $n$ 的数组 $a$，$a_i$ 为数轴上一点。请在数轴上求出若干个节点，使得 $a_i$ 到后面第一个节点的距离和最少

# 思路

一道~~明显~~的 dp 题。我们设 $dp_i$ 表示第 $i$ 个时刻最少的距离和。我们若设 $j$ 为上个节点的位置，显然需要 $0 \le j \le i-m$（$j=0$ 表示 $i$ 是第一个节点），此时 $dp_i= \min _{j=0}^{i-m}(dp_j+\sum_{k=1}^n(i-a_k) \times [j < a_k \le i])$。为了方便计算，我们设 $c_i$ 为时刻 $i$ 前所有点的时间的前缀和，$s_i$ 为时刻 $i$ 前点的个数。化简状态转移方程为 $dp_i= \min _{j=0}^{i-m}(dp_j+(s_i-s_j)\times i-(c_i-c_j))$。此时如果暴力转移，复杂度为 $O(\max(a_i)^2)$。~~成功拿下 50 pts。~~

```cpp
#include <bits/stdc++.h>
#define ll long long
#define U unsigned
#define ss size()
using namespace std;
ll n,m,t,s[4100005],c[4100005],maxn,minn,dp[4100005];
int main() {
	cin.tie(0)->sync_with_stdio(0);
    cin>>n>>m;
    for(ll i=1;i<=n;i++){
        cin>>t;
        s[t]++;
        c[t]+=t;
        maxn=max(maxn,t);
    }//输入
    n=maxn+m;//往返还要时间
    for(ll i=1;i<n;i++){
        s[i]+=s[i-1];
        c[i]+=c[i-1];
    }//计算前缀和
    memset(dp,0x3f,sizeof dp);
    for(int i=0;i<m;i++)dp[i]=i*s[i]-c[i];//不能从前面转移
    minn=1e12;
    for(ll i=m;i<n;i++){
        for(ll j=0;j<=i-m;j++)dp[i]=min(dp[i],dp[j]+(s[i]-s[j])*i-(c[i]-c[j]));//暴力转移
        if(i>=maxn)minn=min(minn,dp[i]);//记录
    }
    cout<<minn;//输出
	return 0;
}
```

如何优化呢？我们再次化简状态转移方程，得到 $dp_i= \min _{j=0}^{i-m}(dp_j+s_i\times i-s_j\times i-c_i+c_j)$。观察式子，仅有 $s_j\times i$ 一项同时与 $i$、$j$ 相关。考虑斜率优化：设 $j_0$ 为最优状态的 $j$，变形状态转移方程为 $dp_{j_0}+c_{j_0}=(dp_i-s_i\times i+c_i)+s_{j_0}\times i$（此处式子变化较大，建议自己推一下）。这是不是很像一次函数 $y=k\times x+b$？！令 $y=dp_{j_0}+c_{j_0}$，$x=s_{j_0}$，$k=i$，$b=dp_i-s_i\times i+c_i$，所以当 $i$ 增大时，斜率 $k$ 也增大，则若截距 $b$ 最小时，$dp_i$ 最小。用单调队列维护凹壳就可以 $O(1)$ 转移了！所有总复杂度为 $O(n)$。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define U unsigned
#define ss size()
using namespace std;
ll n,m,t,s[4100005],c[4100005],maxn,minn,dp[4100005],j,X,Y,K,B;
struct node{
    ll x,y,i;
};
deque<node>q;//记录凹壳
double cross(node a,node b){
    if(a.x==b.x)return (a.y-b.y)/(1e-9);
    return (a.y-b.y)*1.0/(a.x-b.x);
}//求斜率
int main() {
	cin.tie(0)->sync_with_stdio(0);
    cin>>n>>m;
    for(ll i=1;i<=n;i++){
        cin>>t;
        s[t]++;
        c[t]+=t;
        maxn=max(maxn,t);
    }//输入
    n=maxn+m;//往返还要时间
    for(ll i=1;i<n;i++){
        s[i]+=s[i-1];
        c[i]+=c[i-1];
    }//计算前缀和
    memset(dp,0x3f,sizeof dp);
    for(int i=0;i<m;i++)dp[i]=i*s[i]-c[i];//不能从前面转移
    minn=1e12;
    for(ll i=m;i<n;i++){
        j=i-m;
        X=s[j];
        Y=dp[j]+c[j];
        while(q.ss>=2 && cross((node){X,Y,j},q[q.ss-1])<=cross(q[q.ss-1],q[q.ss-2]))q.pop_back();//出现凸壳，不断删除末节点直到凸壳消失
        q.push_back((node){X,Y,j});//插入新节点
        while(q.ss>=2 && cross(q[1],q[0])<=i)q.pop_front();//斜率过小，无用点删除
        j=q[0].i;
        dp[i]=dp[j]+(s[i]-s[j])*i-(c[i]-c[j]);//更新
        if(i>=maxn)minn=min(minn,dp[i]);//记录
    }
    cout<<minn;//输出
	return 0;
}
```

#### 后话

这篇题解写的很详细，~~真的累死本蒟蒻了~~。

---


# 点和线

## 题目描述

平面上有一些点，你可以用直线将两点连接起来。那么有多少种方法可以把这些点连续地连起来，使得任何两个线都不交叉。

显然，三个点只有一种方法。四个点最多只有 $3$ 种方法。写一个程序计算方法总数。


## 说明/提示

最多只有 $10$  个点。

- 必须从一个点出发，途径所有点回到起点的路径才会被统计。

- 两个方案不相同当且仅当围成的简单多边形不同。

## 样例 #1

### 输入

```
100 -10
-200 0
45 7
0 0
```

### 输出

```
3
```

# 题解

## 作者：b6e0_ (赞：11)

[题](https://www.luogu.com.cn/problem/P1153)

题面的一个坑点是**线段除端点外**无交点而不是直线。

看到这 $10$ 的数据范围，明显复杂度带有 $n!$。可以全排列做，但是为了方便剪枝，采用搜索。

枚举到一个排列 $p$，将 $p_i$ 与 $p_{i+1}$（$p_n$ 与 $p_1$）之间连线，主要任务就是判断任意两条线段之间是否有交点。

对于线段 $AB$ 与 $CD$，它们之间有交点的充要条件是点 $C$ 和 $D$ 在直线 $AB$ 的两侧且点 $A$ 和 $B$ 在直线 $CD$ 的两侧。

考虑向量叉乘。若 $\vec a\times\vec b>0$，那么 $\vec b$ 在 $\vec a$ 的逆时针方向；若叉积小于 $0$，那么 $\vec b$ 在 $\vec a$ 的顺时针方向。于是，判断点 $C$ 和 $D$ 是否在直线 $AB$ 的两侧，就是判断 $\overrightarrow{AB}\times\overrightarrow{AC}$ 和 $\overrightarrow{AB}\times\overrightarrow{AD}$ 是否同号。如果同号，那么在同侧；如果异号，那么在两侧。题目保证了任意三点不共线，所以叉积为 $0$ 的情况不可能出现。判断点 $A$ 和 $B$ 在直线 $CD$ 的两侧同理。时间复杂度 $\mathcal O(n!n^2)$，这个其实跑不满。代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct point
{
	double X,Y;
}a[15];
int p[15],n,ans;//p为选择的下标
bool cho[15];//cho表示是否已经选择
inline double cross(point x,point y)//叉积，这里向量也用point表示了，懒得开一个新的struct
{
	return x.X*y.Y-x.Y*y.X;
}
inline bool intersection(point x1,point y1,point x2,point y2)//判断是否有交点，有交点返回true
{
	double abc=cross((point){y1.X-x1.X,y1.Y-x1.Y},(point){x2.X-x1.X,x2.Y-x1.Y});
	double abd=cross((point){y1.X-x1.X,y1.Y-x1.Y},(point){y2.X-x1.X,y2.Y-x1.Y});
	if((abc>0&&abd>0)||(abc<0&&abd<0))
		return false;
	swap(x1,x2);
	swap(y1,y2);
	abc=cross((point){y1.X-x1.X,y1.Y-x1.Y},(point){x2.X-x1.X,x2.Y-x1.Y});
	abd=cross((point){y1.X-x1.X,y1.Y-x1.Y},(point){y2.X-x1.X,y2.Y-x1.Y});
	return ((abc>0&&abd<0)||(abc<0&&abd>0));
}
void dfs(int d)
{
	if(d>n)
	{
		int i;
		for(i=2;i<n-1;i++)
			if(intersection(a[p[n]],a[p[1]],a[p[i]],a[p[i+1]]))
				break;//第一个与最后一个连成的线段与其他是否有交点也要判断
		if(i==n-1)
			ans++;
		return;
	}
	for(int i=1;i<=n;i++)
		if(!cho[i])
		{
			int j;
			p[d]=i;
			for(j=1;j<d-2;j++)
				if(intersection(a[p[d-1]],a[p[d]],a[p[j]],a[p[j+1]]))
					break;
			if(j>=d-2)
			{
				cho[i]=true;
				dfs(d+1);
				cho[i]=false;
			}
		}
}
int main()
{
	do
	{
		n++;
		cin>>a[n].X>>a[n].Y;
	}while(a[n].X!=0||a[n].Y!=0);
	dfs(1);
	cout<<ans/n/2;//一个多边形按照顺时针顺序有n个排列表示，逆时针也有n个，所以要除以2n
	return 0;
}
```

---

## 作者：一水清浅 (赞：10)

这道题有很多方法，可以用凸包来做，也可以用深搜来做~~（因为数据实在是小的可怜）~~

### 前两篇题解用的深搜，搜索中有一个重要的内容就是判断两线段有没有交点的问题，这个其实不难

### 最简单易懂的方法就是：
线段的两端既然都知道了，轻轻松松就能算出两条线段所在直线的解析式，解析式求出来之后求两直线的交点，再和两条已知线段的端点进行比较，看是不是在端点限定的区间内就行了，这个方法代码简单，运算简便，简直有点简单的不像话，具体代码我就不贴了

### 现在来一发思维缜密的高大上的方法：向量叉乘
**问题**：给出两条线段，问两线段是否相交？

**向量叉乘（行列式计算）**：向量a（x1，y1），向量b（x2，y2）：
![啦啦啦](https://cdn.luogu.com.cn/upload/pic/54458.png)

首先我们要明白一个定理：向量a×向量b（×为向量叉乘），若结果小于0，表示向量b在向量a的顺时针方向；若结果大于0，表示向量b在向量a的逆时针方向；若等于0，表示向量a与向量b平行。（顺逆时针是指两向量平移至起点相连，从某个方向旋转到另一个向量小于180度）。如下图：

![啦啦啦](https://cdn.luogu.com.cn/upload/pic/54459.png)

在上图中，OA×OB = 2 > 0， OB在OA的逆时针方向；OA×OC = -2 < 0,OC在OA的顺势针方向。即叉乘结果大于0，后一个在前一个的逆时针方向；小于零，后一个在前一个的顺时针方向。

 
**那如何来判断两线段是否相交呢？**

假设有两条线段AB，CD，若AB，CD相交，我们可以确定：

1.线段AB与CD所在的直线相交，即点A和点B分别在直线CD的两边；

2.线段CD与AB所在的直线相交，即点C和点D分别在直线AB的两边；

上面两个条件同时满足是两线段相交的充要条件，所以我们只需要证明点A和点B分别在直线CD的两边，点C和点D分别在直线AB的两边，这样便可以证明线段AB与CD相交了。

 

那判断两线段是否相交与一开始提到的向量叉乘定理有什么关系呢？有，我们可以通过叉乘来证明上面说的充要条件。看下图：

![啦啦啦](https://cdn.luogu.com.cn/upload/pic/54460.png)

在上图中，线段AB与线段CD相交，于是我们可以得到两个向量AC，AD，C和D分别在AB的两边，向量AC在向量AB的逆势针方向，AB×AC > 0；向量AD在向量AB的顺势针方向，AB×AD < 0，两叉乘结果异号。

这样，方法就出来了：如果线段CD的两个端点C和D，与另一条线段的一个端点（A或B，只能是其中一个）连成的向量，与向量AB做叉乘，若结果异号，表示C和D分别在直线AB的两边，若结果同号，则表示CD两点都在AB的一边，则肯定不相交。

当然，不能只证明C，D在直线AB的两边，还要用相同的方法证明A，B在直线CD的两边，两者同时满足才是线段相交的充要条件。

 

不过，线段相交还有一些特殊情况：

1.只有1点相交，如下图：

![啦啦啦](https://cdn.luogu.com.cn/upload/pic/54461.png)

上图中，线段AB与CD相交于C点，按照之前介绍的方法，我们可以连成两向量AD和AC，这时候，我们发现，AC与AB共线，AB×AC = 0；而AB×AD < 0；两者并不异号，可实际上仍然相交。所以当出现两叉乘结果中，有一方为0，也可以看成点CD在直线AB的两边。

 

2.两条线段重合，如下图：

![啦啦啦](https://cdn.luogu.com.cn/upload/pic/54462.png)

在上图中，线段AB与线段CD重合，重合部分为CB，这种重合的情况要特殊判断：

首先，我们给没条线段的两个端点排序，大小判断方法如下：横坐标大的点更大，横坐标相同，纵坐标大的点更大。

排好序后，每条线段中，小的点当起点，大的当终点。我们计算向量AB×向量CD，若结果为0，表示线段AB平行CD，平行才有了重合的可能；但平行也分共线和不共线，只有共线才有可能重合，看下图：

![啦啦啦](https://cdn.luogu.com.cn/upload/pic/54463.png)

上图中，第一种情况不共线，第二种情况共线。那如何来判断是否共线呢？

我们可以在两条线段中各取一点，用这两点组成的向量与其中一条线段进行叉乘，结果若为0，就表示两线段共线，如下图：

![啦啦啦](https://cdn.luogu.com.cn/upload/pic/54872.png)

我们取向量BC，若BC×CD = 0，表示两点共线，即是第二种情况，否则就是第一种情况。第一种情况肯定不相交。猴子为什么不喜欢平行线？因为他们没有相交。。。（尬）

然然然然然而，即使他们共线，却还是不一定重合，就如上图中第二种情况。这时候，之前给点排序的妙处就体现出来了：

若一条线段AB与另一条线段CD共线，且线段AB的起点小于等于线段CD的起点，但线段AB的终点（注意是终点）大于等于线段CD的起点（注意是起点），或者交换一下顺序，CD的起点小于AB的起点......只要满足其中一个，就表示有重合部分。

# 但是：洛谷的数据很水，这里面的特殊情况一个都没有

## 因此，会用叉乘判断就能过这一题了

话不多说，晒出你们最爱的代码：
~~（我是个萌新，啥高端操作都不会，代码看两眼你就懂了）~~

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

struct point{
	double x,y;
}po[5],map[11];
point a,b,c,d;

int n=1,ans;
int path[11];
bool vis[11];
bool disallow[11][11][11][11];

inline int compare(point a,point b)
{
	if(a.x<b.x||a.x==b.x&&a.y<b.y)  return -1;
	else if(a.x==b.x&&a.y==b.y) return 0;
	else return 1;
}

inline bool cmp(point a,point b)
{
	if(a.x!=b.x) return a.x<b.x;
	else return a.y<b.y;
}

inline double compute(double x1,double y1,double x2,double y2)
{
	return x1*y2-x2*y1;
}

bool judge(point a,point b,point c,point d)
{
	po[1]=a;po[2]=b;
	po[3]=c;po[4]=d;
	sort(po+1,po+3,cmp);
	sort(po+3,po+5,cmp);
	
	if(compute(po[1].x-po[2].x,po[1].y-po[2].y,po[3].x-po[4].x,po[3].y-po[4].y)==0) //两线段平行 
	{
		if(compute(po[1].x-po[2].x,po[1].y-po[2].y,po[1].x-po[3].x,po[1].y-po[3].y)==0) //两线段共线 
		{
			if(compare(po[1],po[3])<=0&&compare(po[2],po[3])>=0)  //第一条起点小于第二条起点，第一条终点大于第二条起点 
			  return true;
			else if(compare(po[3],po[1])<=0&&compare(po[4],po[1])>=0) //第二条起点小于第一条起点，第二条终点大于第一条起点
			  return true;
			else return false;
		}
		else return false;
	}
	else if(compute(po[1].x-po[2].x,po[1].y-po[2].y,po[3].x-po[4].x,po[3].y-po[4].y)!=0) //两线段不平行 
	{
		double num1,num2,num3,num4;
		num1=compute(po[1].x-po[2].x,po[1].y-po[2].y,po[1].x-po[3].x,po[1].y-po[3].y);//判断第一条线的两端点 
		num2=compute(po[1].x-po[2].x,po[1].y-po[2].y,po[1].x-po[4].x,po[1].y-po[4].y);//在第二条线的两边 
		num3=compute(po[1].x-po[3].x,po[1].y-po[3].y,po[3].x-po[4].x,po[3].y-po[4].y);//判断第二条线的两端点 
		num4=compute(po[2].x-po[3].x,po[2].y-po[3].y,po[3].x-po[4].x,po[3].y-po[4].y);//在第一条线的两边 
		if(num1*num2<=0&&num3*num4<0||num1*num2<0&&num3*num4<=0) //等于0表示一条线段的某一端点在另一条线段上
		  return true;
		else return false;
	}
	else return false;
}

void dfs(int step,int now)
{
	if(step==n+1) {
	ans++;
//	
//	for(int i=0;i<=step;i++)
//	  printf("%d ",path[i]);
//	  printf("\n");
//
	return;}
	if(step==n) vis[1]=false;
	for(int i=1;i<=n;i++)
	{
		if(vis[i]) continue;
		bool flag=true;
		for(int j=0;j<step-2&&flag;j++)
		  if(disallow[path[j]][path[j+1]][now][i]) flag=false;
		if(flag)
		{
			path[step]=i;
			vis[i]=true;
			dfs(step+1,i);
			vis[i]=false;
		}
		vis[1]=true;
	}
}

void ready()
{
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=n;j++)
	    for(int p=1;p<=n;p++)
	      for(int q=1;q<=n;q++)
	      	if(judge(map[i],map[j],map[p],map[q])) disallow[i][j][p][q]=true;
}

int main ()
{
	while(scanf("%lf%lf",&map[n].x,&map[n].y))
	{
		if(map[n].x!=0||map[n].y!=0) n++;
		else break;
	}
	path[0]=1;
	vis[1]=true;
	ready();
	dfs(1,1);
	printf("%d\n",ans/2);
	return 0;
}
```
这题目蛮好的，和直接求两线段有无交点还是有一点点不一样滴：这道题有公共端点不视为有交点，即有公共端点是可以连起来的。细心的读者一定想到了，如果单纯考虑两个线段有没有交点的话这个情况是算作有交点的。~~没错我当时考虑到了，然后我改了1个多小时才发现这题有公共端点是允许的/泪奔~~

最后附上参考：
[特务依昂 判断两条线段是否相交—（向量叉乘）](https://www.cnblogs.com/tuyang1129/p/9390376.html)

感谢您的阅读！^_^

---

## 作者：H_D_NULL (赞：5)

### 暴搜出奇迹
---
#### 不要去想什么高深的算法了，也不要去推奇奇怪怪的数学公式，先想想计算机的发明是为了什么吧。
---
#### 解：

本题的搜索方式不难想到，即每次枚举一点与当前点连线，然后判断这条是否与已连的线相交。所以本题的唯一难点是判断线段相交。

这里需要运用**向量叉积**。 [<baidu>](https://baike.baidu.com/item/%E5%90%91%E9%87%8F%E7%A7%AF/4601007?fr=aladdin)

简单来说：两个向量$a$和$b$的向量积是一个向量，记作$a × b$，其模等于由$a$和$b$作成的平行四边形的面积，方向与平行四边形所在平面平面垂直，当站在这个方向观察时，$a$逆时针转过一个小于$π$的角到达$b$的方向。这个方向也可以用物理上的右手螺旋定则判断：右手四指弯向由$a$转到$b$的方向（转过的角小于$π$），拇指指向的就是向量积的方向：从被乘数抓向乘数。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/k61ag30w.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
  
设向量$P$=$(x1,y1)$，$Q$=$(x2,y2)$，则向量a与向量b的叉积仍是一个向量，也可把叉积定义为一个矩阵行列式：

![](https://cdn.luogu.com.cn/upload/image_hosting/d087zyot.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这时，结合定义，可得：

①$P × Q>0$；则$P$在$Q$的顺时针方向；

②$P × Q<0$；则$P$在$Q$的逆时针方向；

③$P × Q=0$；则$P$与$Q$共线，但可能同向也可能反向；
                           
#### 对于本题
两条线段$AB$、$CD$，相交的充要条件是：$A$、$B$在直线$CD$的异侧且$C$、$D$在直线$AB$的异侧。也就是说从$AC$到$AD$的方向与从$BC$到$BD$的方向不同，从$CA$到$CB$的方向与从$DA$到$DB$的方向也不同。这样就可以通过矢量的叉积来判断两线段是否相交：$(AC × AD)*(BC × BD)<0$ 且 $(CA × CB)*(DA × DB)<0$ （具体实现见代码AddCross函数）

#### 完
---
*Talk is cheap, show me the code*

```cpp
#include<bits/stdc++.h>
#define re register
#define mn 15
using namespace std;

int n=1;
int ans;

struct dr{
	double x,y;
} q[mn];

int v[mn]; //保存已选路径
bool vis[mn];

inline double Cross(dr a,dr b,dr c){
	return (a.x-c.x)*(b.y-c.y)-(a.y-c.y)*(b.x-c.x);
}

inline bool AC(dr a,dr b,dr c,dr d){
	return (Cross(c,d,a)*Cross(c,d,b)<0&&Cross(a,b,c)*Cross(a,b,d)<0);
}

inline bool Judge(int num,int b){
	for(re int i=2;i<num-1;i++){
		if(AC(q[v[i-1]],q[v[i]],q[v[num-1]],q[b])) return false;
	}
	return true;
}

void Dfs(int num){
	if(num==n+1){
		if(Judge(num,1)) ans++;
		return;
	}
	for(re int i=2;i<=n;i++){
		if(!vis[i]&&Judge(num,i)){
			vis[i]=1;
			v[num]=i;
			Dfs(num+1);
			vis[i]=0;
		}
	}
}

int main(){
	while(true){
		scanf("%lf %lf",&q[n].x,&q[n].y);
		if(q[n].x||q[n].y) n++;
		else break;
	}
	v[1]=1;
	Dfs(2);
	printf("%d",ans/2); //正序和倒序算一种情况
	return 0;
}
```


---

## 作者：YoungLove (赞：4)

其实就是搜索啊，开心地搜就好，搜的过程中判断一下当前的线是否与之前的线相交就好，从1出发，最后回到1。

由于数据很小 10！可过

[Youngsc](https://youngscc.github.io/)


## 代码如下


```cpp

# include <algorithm>
# include <iostream>
# include <cstring>
# include <cstdio>
# include <vector>
# include <queue>
# include <cmath>
# define R register
# define LL long long
# define db double

using namespace std;

int n,x[12],y[12],d[12],ans;
bool ok[12][12][12][12],v[12];

template <typename T> void in(R T &a){
    R char c = getchar();R T x=0,f=1;
    while(!isdigit(c)) {if(c == '-') f=-1; c=getchar();}
    while(isdigit(c)) x=(x<<1)+(x<<3)+c-'0',c = getchar();
    a=x*f;
}

inline void maxx(R int &a,const int b){a>b? 0:a=b;}
inline void minn(R int &a,const int b){a<b? 0:a=b;}

inline bool check(R int a,R int b,R int p,R int q){
    if(a == p||b == p||a == q||b == q) return 1;
    if(x[a] == x[b]) return (x[p]-x[a])*(x[q]-x[a])>=0.0;
    else{
        R db k=1.0*(y[a]-y[b])/(1.0*(x[a]-x[b]));
        R db c=1.0*y[a]-x[a]*k;
        return (k*x[p]+c-1.0*y[p])*(k*x[q]+c-1.0*y[q])>=0.0;
    }
}

inline void dfs(R int now,R int last){
    // printf("%d ",now);
    if(now == n+1){
        ans++;
        return;
    }
    if(now == n) v[1] = 0;//最后一下连回1
    for(R int i=1; i<=n; ++i)
    {
        if(v[i]) continue;
        // if(now == 4) printf("%d ",i);
        R bool flag = 1;
        for(R int j=0; j<now-1&&flag; ++j)
        {
            if(!ok[d[j]][d[j+1]][last][i]) flag = 0;
        }
        if(flag) d[now]=i,v[i]=1,dfs(now+1,i),v[i] = 0;
    }
    v[1] = 1;
}

int main(){
    n=1;
    while(scanf("%d %d",&x[n],&y[n]) != EOF) n++;
    n--;
    for(R int i=1; i<=n; ++i)
        for(R int j=i+1; j<=n; ++j)
            for(R int p=1; p<=n; ++p)
                for(R int q=p+1; q<=n; ++q)
                {
                    if(i==p&&j==q) continue;
                    ok[i][j][p][q] = ok[j][i][p][q] = ok[i][j][q][p] = ok[j][i][q][p] = (check(i,j,p,q)||check(p,q,i,j));//预处理一下
                }
    d[0] = 1;
    v[1] = 1; dfs(1,1);
    printf("%d\n",ans>>1);//顺逆时针会被统计两次，因此最后要除二。
}


```

(减少代码复制，共创美好洛谷)


---

## 作者：Bai_R_X (赞：2)

## 思路
首先因为 $n\le10$，所以我们可以 $O(n!)$ 进行全排列，然后最后对于每条线进行 $O(n^2)$ 的判断相交，总体复杂度为 $O(n!n^2)$，极限通过。

如何判断相交，考虑计算几何。

如果一条线段的两端在另一条线段线段的两侧，那么这两条线段相交，读者珂以自行验证。然后根据叉积的正负性，有这条线段两个端点与另一端点产生的两个叉积正负相反，即叉积之积为负数。判断只要判断叉积之积为负数即可。
## 代码
计算几何模板来自《算法竞赛》第八章。

---
答案输出时要除去 $2n$。因为首先对于一个连线方案，它可以左右移动，例如对于连线顺序为 $[1,2,3,4]$，它珂以变为 $[4,1,2,3]$ 等，共有 $n$ 种，出去。另外还有相反的情况，例如对于连线顺序为 $[1,2,3,4]$，它珂以变为 $[4,3,2,1]$，除去 $2$。
```cpp
#include<bits/stdc++.h>
//#define int long long
//开ll会慢TLE
using namespace std;
int sgn(double x)
{
	if(fabs(x)<1e-6)return 0;
	return x<0?-1:1;
}
struct Point
{
	double x,y;
	Point(double X=0,double Y=0):x(X),y(Y){}
	Point operator+(Point B){return Point(x+B.x,y+B.y);}
	Point operator-(Point B){return Point(x-B.x,y-B.y);}
	Point operator*(double k){return Point(x*k,y*k);}
	Point operator/(double k){return Point(x/k,y/k);}
};
typedef Point Vector;
double Cross(Vector A,Vector B){return A.x*B.y-A.y*B.x;}
double Dot(Vector A,Vector B){return A.x*B.x+A.y*B.y;}
struct Line
{
	Point p1,p2;
	Line(Point P1,Point P2):p1(P1),p2(P2){}
};
typedef Line Segment;
bool Cross_segment(Point a,Point b,Point c,Point d)
{
	double c1=Cross(b-a,c-a),c2=Cross(b-a,d-a),d1=Cross(d-c,a-c),d2=Cross(d-c,b-c);
	return sgn(c1)*sgn(c2)<0&&sgn(d1)*sgn(d2)<0;
}
int n,cnt,x[15],i,j;
Point p[15];
bool vis[15];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	{
		int x,y;
		while(cin>>x>>y)p[++n]=Point(x,y);
	}
	for(i=0;i<n;i++)x[i]=i+1;
	vector<Segment> v;
	do
	{
		bool f=1;
		for(i=0;i<n;i++)
		{
			for(j=0;j<i;j++)
			{
				if(Cross_segment(p[x[i]],p[x[(i+1)%n]],p[x[j]],p[x[(j+1)%n]]))
				{
					f=0;
					break;
				}
			}
			if(!f)break;
		}
		cnt+=f;
    }while(next_permutation(x,x+n));
	cout<<cnt/n/2;
	return 0;
}
```

---

## 作者：2022linzhiyi (赞：1)

[题目描述](https://www.luogu.com.cn/problem/P1153)

注意题面中有一个问题（应该是），是用线段将两点连接而不是直线。

这道题点的数量较少，最多只有 $10$ 个点，很容易想到可以生成出每个排列然后判断是否合法，生成全排列可以使用搜索或者直接调用 next_permutaion 函数。

然后就是判断是否有两条线段相交。对于线段 $AB$ 和线段 $CD$，当且仅当 $A$ 和 $B$ 两点分别在 $CD$ 两端且 $C$ 和 $D$ 分别在线段 $AB$ 两端时两线段相交。

可以使用向量叉积。若 $\vec{a} \times \vec{b} > 0$，那么 $\vec{a}$ 就在 $\vec{b}$ 的逆时针方向，否则就在顺时针方向。具体而言，对于线段 $AB$ 和 $CD$，只需要判断 $\overrightarrow{AB} \times \overrightarrow{AC}$，$\overrightarrow{AB} \times \overrightarrow{AD}$，$\overrightarrow{CD} \times \overrightarrow{CA}$，$\overrightarrow{CD} \times \overrightarrow{CB}$ 的符号即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct point {
	int x,y;
}p[15];
point operator - (point a,point b) {return (point){a.x-b.x,a.y-b.y};}
int n,s[15],ans;
int sign(int x) {
	if (x == 0) return 0;
	return x/abs(x);
}
int cross(point a,point b) {
	return a.x*b.y-b.x*a.y;
}
bool intersection(point a1,point a2,point b1,point b2) {
	double c1=cross(a2-a1,b1-a1), c2=cross(a2-a1,b2-a1);
	double c3=cross(b2-b1,a2-b1), c4=cross(b2-b1,a1-b1);
	return sign(c1)*sign(c2) < 0 && sign(c3)*sign(c4) < 0;
}
int main()
{
	while (cin >> p[n].x >> p[n].y) n ++;
	for (int i=0;i<n;i++) s[i]=i;
	do {
		bool flag=0;
		for (int i=0;i<n;i++) {
			for (int j=0;j<i;j++) {
				if (intersection(p[s[i]],p[s[(i == n-1 ? 0 : i+1)]],p[s[j]],p[s[j+1]])) {
					flag=1;
					break;
				}
			}
			if (flag) break;
		}
		if (!flag) ans ++;
	} while (next_permutation(s,s+n));
	cout << ans/n/2; // 去重
	return 0;
}

```

---

## 作者：steven张 (赞：1)

第一次写题解ww

也是下午刚参考了lrj大神的蓝书，跑过来写的这个题

读完题之后，直觉告诉我们，这就是一道搜索题，并且n非常小，怎么搜都行

先选定一个节点，然后这里我用pa（i）r结构体记录我们从起点开始连的线段，数目是cnt个，注意，par结构体的线段有顺序性，从p1到p2，这里在dfs的时候方便找结点

这样通过调用segproperintersection函数（输入两个线段的端点，利用叉积判断线段相交）可以判断新线段是否和之前的线段是否有交点。

```cpp
#include<bits/stdc++.h>
using namespace std;
const double eps=1e-10;
const double maxn=15;
struct point
{
    double x,y;
    point(double x=0,double y=0):x(x),y(y){}
}a[maxn];
struct par
{
    point p1,p2;
    par(point p1=point(0,0),point p2=point(0,0)):p1(p1),p2(p2){}
}tmp[maxn];
bool flag[maxn];
int ans,cnt,n=1;
typedef point vec;
vec operator-(point a,point b){return vec(a.x-b.x,a.y-b.y);}
int dcmp(double x){return fabs(x)<eps?0:(x<0?-1:1);}
double cross(vec a,vec b){return a.x*b.y-a.y*b.x;} 
bool segproperintersection(point a1,point a2,point b1,point b2)
{
    double c1=cross(a2-a1,b1-a1),c2=cross(a2-a1,b2-a1),c3=cross(b2-b1,a1-b1),c4=cross(b2-b1,a2-b1);
    return dcmp(c1)*dcmp(c2)<0&&dcmp(c3)*dcmp(c4)<0;
}
//以上写法在蓝书中有详细解释
void dfs(int step)
{
    if(step==n)
    {
        tmp[++cnt]=par(tmp[cnt-1].p2,tmp[1].p1);
        bool t=0;
        for(int i=1;i<cnt;i++)
            t|=segproperintersection(tmp[i].p1,tmp[i].p2,tmp[cnt].p1,tmp[cnt].p2);
        if(!t)
            ans++;
        cnt--;
        return;
    }
    for(int i=1;i<=n;i++)
    {
        if(!flag[i])
        {
            tmp[++cnt]=par(tmp[cnt-1].p2,a[i]);
            flag[i]=1;
            bool t=0;
            for(int j=1;j<cnt;j++)
                t|=segproperintersection(tmp[j].p1,tmp[j].p2,tmp[cnt].p1,tmp[cnt].p2);
            if(!t)
                dfs(step+1);
            cnt--;
            flag[i]=0;
        }
    }
}
int main()
{
    while(scanf("%lf%lf",&a[n].x,&a[n].y)!=EOF&&(a[n].x||a[n].y))
        n++;
    tmp[cnt]=par(point(1e9,1e9),a[1]);//这里构造一个虚拟结点，确定开始结点a[1]
    flag[1]=1;
    dfs(1);
    printf("%d",ans/2);
}
```

---

## 作者：scp020 (赞：0)

# P1153 点和线 题解

快乐搜索身体棒棒。

## 解法

最多有 $10$ 个点，所以考虑阶乘复杂度的搜索。

枚举这些点的排列 $p$，令 $p_i$ 与 $p_{i+1}$ 相连，且 $p_1$ 与 $p_n$ 相连，最后判断这 $n$ 条线段是否有交点。

判断任意两个线段 $AB$ 与 $CD$ 是否有交点的方法如下。

### 快速排斥实验

分别以 $AB$ 和 $CD$ 为对角线做水平竖直的两个矩形。如果两个矩形没有相交部分，那两线段不可能相交，我们称为未通过快速排斥实验。否则我们称为通过快速排斥实验。如图。

![图](https://cdn.luogu.com.cn/upload/image_hosting/zhxud7ha.png)

### 跨立实验

当两线段通过快速排斥实验后，则进行跨立实验。跨立实验即为：验证点 $C,D$ 是否在直线 $AB$ 的两侧同时点 $A,B$ 是否在直线 $CD$ 的两侧。

根据向量叉乘的几何意义，$\overrightarrow{AB} \times \overrightarrow{AC}$ 为正代表点 $C$ 在直线 $AB$ 的逆时针方向，为 $0$ 代表点 $C$ 在直线 $AB$ 上，为负代表点 $C$ 在直线 $AB$ 的顺时针方向。

如果 $\overrightarrow{AB} \times \overrightarrow{AC}$ 和 $\overrightarrow{AB} \times \overrightarrow{AD}$ 正负性不同，$\overrightarrow{CD} \times \overrightarrow{CA}$ 和 $\overrightarrow{CD} \times \overrightarrow{CB}$ 正负性不同，我们称为通过跨立实验。

如果两线段通过了快速排斥实验和跨立实验，则我们认为两线段相交。

### 为什么要有快速排斥实验

好多人读到了这里，感觉跨立实验足以应付线段相交，为什么还要有快速排斥实验呢？

其实这并不是在减少计算过程，而是保证正确性。如图。

![图](https://cdn.luogu.com.cn/upload/image_hosting/deckgmqs.png)

两线段会通过跨立实验，如果不进行快速排斥实验，那我们就会错误的认为两线段相交。

```cpp
#include<bits/stdc++.h>
namespace fast_IO
{
    /**
     * 没啥用的东西
    */
};
using namespace fast_IO;
struct point
{
    int x,y;
    point(){x=y=0x3f3f3f3f;}
    point(int x,int y){this->x=x,this->y=y;}
    inline point operator-(const point &rhs) const{return point(x-rhs.x,y-rhs.y);}
    inline int operator*(const point &rhs) const{return x*rhs.y-y*rhs.x;}
};
inline int sgn(int x){return x==0?0:(x>0?1:-1);}
struct seg
{
    point s,t;
    inline seg(){}
    inline seg(point s,point t){this->s=s,this->t=t;}
    inline friend bool cross_seg(const seg &lhs,const seg &rhs)
    {
        return std::max(lhs.s.x,lhs.t.x)>=std::min(rhs.s.x,rhs.t.x) && 
        std::max(lhs.s.y,lhs.t.y)>=std::min(rhs.s.y,rhs.t.y) && 
        std::max(rhs.s.x,rhs.t.x)>=std::min(lhs.s.x,lhs.t.x) && 
        std::max(rhs.s.y,rhs.t.y)>=std::min(lhs.s.y,lhs.t.y) && 
        sgn((rhs.s-lhs.s)*(lhs.t-lhs.s))*sgn((rhs.t-lhs.s)*(lhs.t-lhs.s))<0 && 
        sgn((lhs.s-rhs.s)*(rhs.t-rhs.s))*sgn((lhs.t-rhs.s)*(rhs.t-rhs.s))<0;
    }
};
int n,ans,vis[20];
seg v[20];
point a[20];
inline void dfs(int pos,int dep)
{
    if(dep>n)
    {
        for(int i=1;i<=n;i++) for(int j=i+1;j<=n;j++) if(cross_seg(v[i],v[j])) return;
        ans++;
        return;
    }
    for(int i=1;i<=n;i++)
        if(!vis[i] && i!=1 || dep==n && i==1) vis[i]=1,v[dep]=(seg){a[pos],a[i]},dfs(i,dep+1),vis[i]=0;
}
int main()
{
    while(1)
    {
        n++,in>>a[n].x>>a[n].y;
        if(a[n].x==0 && a[n].y==0) break;
    }
    dfs(1,1),out<<ans/2;
    fwrite(Ouf,1,p3-Ouf,stdout),fflush(stdout);
    return 0;
}
```

---


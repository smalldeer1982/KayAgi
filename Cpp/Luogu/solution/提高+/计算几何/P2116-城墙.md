# 城墙

## 题目描述

有一次，一个贪婪的国王命令他的骑士在他的城堡外修建一堵围墙，要求围墙离城堡的最近距离不能少于 $L$。

城堡是一个 $n$ 边形，国王非常吝啬，不愿意多花建一米的围墙，多建的话他会杀掉负责修建的骑士。

请你帮助这个倒霉的骑士，帮他求出最少需要修建多长的围墙。

## 说明/提示

#### 数据规模与约定
- 对于 $100\%$ 的数据，保证 $3\le n\le1000$，$1\le L\le1000$，$-10^4\leq x_i,y_i\leq 10^4$。

## 样例 #1

### 输入

```
9 100
200 400
300 400
300 300
400 300
400 400
500 400
500 200
350 200
200 200```

### 输出

```
1628```

# 题解

## 作者：Grisses (赞：6)

[题面](https://www.luogu.com.cn/problem/P2116)

对于一堆平面上的点，如果要用一个一个多边形框住的话，周长最小的无疑是凸包了（这很好证明，三角形的任意两边之和大于第三边，所以凸的会优于凹的）。要距离所有城池至少 $L$，再加一段弧就行了，不难发现，所有的弧的圆心角都是多边形的外角，对于一个凸多边形，外角和为 $360^{\circ}$。即一个圆。

![](https://cdn.luogu.com.cn/upload/image_hosting/lomqusqh.png)

所有答案是凸包的周长加上半径为 $L$ 的圆的周长。

代码：
```cpp
  #include<bits/stdc++.h>
  #define db double
  using namespace std;
  int n,L,top=0;//投票表示栈顶
  db p=3.14159265358979323846;//求圆的周长需要Pi
  struct node{//存储点
      db x,y;
      node(){}
      node(int a,int b){x=a,y=b;}
      bool operator<(const node &t)const{//重载小于（最左最下的一个点）
          return y<t.y||(y==t.y&&x<t.x);
      }
      node operator-(const node &t)const{//重载减
          return node(x-t.x,y-t.y);
      }
  }a[200005],s[200005];//s是栈
  db ans,_x,_y;
  int CPr(node A,node B){
      return A.x*B.y-A.y*B.x;//向量叉积
  }
  db len(node A,node B){return sqrt(1.0*(A.x-B.x)*(A.x-B.x)+1.0*(A.y-B.y)*(A.y-B.y));}//求距离
  bool cmp(node A,node B){//以最左最下的点为极点，建立极坐标系，按极角从小到大排序，如果极角相同则按距离从小到大排序
      _x=CPr(A-a[1],B-a[1]);
      if(_x>0)return 1;
      if(_x==0)return len(A,a[1])<len(B,a[1]);
      return 0;
  }
  int main()
  {
      scanf("%d%d",&n,&L);
      for(int i=1;i<=n;i++)scanf("%lf%lf",&a[i].x,&a[i].y);
      sort(a+1,a+n+1);
      sort(a+2,a+n+1,cmp);
      s[++top]=a[1];
      s[++top]=a[2];
      for(int i=3;i<=n;i++){
          while(top>2&&CPr(s[top]-s[top-1],a[i]-s[top-1])<=0)top--;
          s[++top]=a[i];
      }//求凸包
      for(int i=1;i<=top;i++)ans+=len(s[i],s[i%top+1]);//求周长
      ans+=p*L*2;//加上圆的周长
      printf("%.0lf",ans);//输出
      return 0;
  }
```

---

## 作者：Heartlessly (赞：6)

## Description

给定 $n$ 个点，求出最短的包围所有点的轮廓且满足任意点到轮廓的距离不小于给定的 $L$ 。

$(3 \leq n \leq 10^3,1 \leq L \leq 10^3,-10^4 \leq x_i,y_i \leq 10^4)$

## Solution

所有点到轮廓的距离都 $\geq L$，显然取等于时是最优的。

因此轮廓一定由若干线段和圆弧构成。

![VNDe3t.png](https://s2.ax1x.com/2019/06/05/VNDe3t.png)

而所有的线段都可以由点与点之间的连线平移得到，而且点围成的图形一定是一个凸多边形（凹多边形显然不优，比如图中的 $GH + HF > GF$）。也就是说线段的长度和就是凸包的长度。

那圆弧的长度呢？我们可以大胆猜想圆弧的总长刚好是一个圆周。

**证明：**

以图中底部的圆为例。

$\because IB$ 和 $CJ$ 分别是 $\odot A$ 和 $\odot D$，$\odot A$ 和 $\odot E$ 的外公切线，$AD \parallel IB,AE \parallel CJ$

$\therefore \angle DAB = \angle EAC = \angle ABI = \angle ACJ = 90^\circ$

$\therefore \angle DAE$ 与 $\angle BAC$ 互补

$\because$ $\angle DAE$ 与它的外角互补

$\therefore \angle BAC$ 等于 $\angle DAE$ 的外角

同理，每个圆弧所对的圆心角都是凸多边形的一个外角，而凸多边形的外角和为 $360^\circ$，因此圆弧的总长即是半径为 $L$ 的圆的周长。

凸包长度加上圆弧总长即是答案。时间复杂度为 $O(n \log n)$ 。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

template <class T>
inline void read(T &x) {
    x = 0;
    char c = getchar();
    bool f = 0;
    for (; !isdigit(c); c = getchar()) f ^= c == '-';
    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
    x = f ? -x : x;
}

template <class T>
inline void write(T x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    T y = 1;
    int len = 1;
    for (; y <= x / 10; y *= 10) ++len;
    for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);
}

const int MAXN = 1e3;
const double PI = acos(-1);
int n, l, top, tag;
double ans;
struct Vector {
    double x, y;
    
    inline friend bool operator<(Vector a, Vector b) {
        return a.x == b.x ? a.y < b.y : a.x < b.x;
    }
    inline friend Vector operator-(Vector a, Vector b) {
        return (Vector) { a.x - b.x, a.y - b.y };
    }
} a[MAXN + 5], sta[MAXN + 5];

inline double dist(Vector a, Vector b) {//两点的直线距离 
    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

inline double cross(Vector a, Vector b) {//叉积 
    return a.x * b.y - a.y * b.x;
}

inline void getConvexHull(Vector *a, int n) {//求凸包长度 
    top = ans = 0;
    sort(a + 1, a + n + 1);
    for (int i = 1; i <= n; ++i) {
        for (; top > 1 && cross(sta[top] - sta[top - 1], a[i] - sta[top]) <= 0; --top);
        sta[++top] = a[i];
    }
    tag = top;
    for (int i = n - 1; i; --i) {
        for (; top > tag && cross(sta[top] - sta[top - 1], a[i] - sta[top]) <= 0; --top);
        sta[++top] = a[i];
    }
    for (int i = 1; i < top; ++i) ans += dist(sta[i], sta[i + 1]);
}

int main() {
    read(n), read(l);
    for (int i = 1; i <= n; ++i) scanf("%lf %lf", &a[i].x, &a[i].y);
    getConvexHull(a, n);
    ans += 2 * PI * l;//加上圆弧总长 
    printf("%.0lf\n", ans);
    return 0;
}
```



---

## 作者：waaadreamer (赞：2)

刚刚看到这道题的时候好吓人，又是计算几何，难度还是省选+NOI-的……其实很水啦

首先会发现，我们根本就不需要原图输入的那个多边形，我们只要计算那个多边形的凸包再进行计算就行了（凸包复杂度O(nlogn)）。

然后呢，在凸包的每个顶点都画一个半径为L的圆，并且把每条边都向外面平移L，这样得到图形的最外圈其实就是最小的答案啦，因为最外面一圈可以保证每个点到城堡（凸包）的最近距离都为L。其实注意到画弧的那一部分中所有弧的边长加起来就是2πL，所有凸包边向外平移的总长度其实就是原凸包的周长。

因此答案=凸包周长+2πL，凸包周长扫一遍就行，总复杂度O(nlogn)。

最后注意一下精度啦（题目中π输的有点长，纯属无聊，别见怪哈……）


```cpp
###<code>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <string.h>
#include <vector>
#include <math.h>
#include <queue>
#include <set>
#include <functional>
#include <time.h>
using namespace std;
const double PI = 3.1415926535897932384, INF = 1E10, EPS = 1E-10;
struct Point{double x, y;} po[1005], hull[1005];
inline bool cmp(const Point &p1, const Point &p2){
    if(p1.x == p2.x) return p1.y < p2.y;
    return p1.x < p2.x;
}
inline double slope(const Point &p1, const Point &p2){
    if(fabs(p1.x - p2.x) <= EPS) return INF;
    return (p1.y - p2.y) / (p1.x - p2.x);
}
inline double dist(const Point &p1, const Point &p2){
    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
}
int main(){
    int n, m, ta = 0;
    scanf("%d%d", &n, &m);
    for(int i = 0; i < n; i++) scanf("%lf%lf", &po[i].x, &po[i].y);
    sort(po, po + n, cmp);
    for(int i = 0; i < n; i++){
        while(ta > 1 && slope(hull[ta - 2], hull[ta - 1]) < slope(hull[ta - 1], po[i]) + EPS) ta--;
        hull[ta++] = po[i];
    }
    for(int i = n - 2, t = ta; i >= 0; i--){
        while(ta > t && slope(hull[ta - 2], hull[ta - 1]) < slope(hull[ta - 1], po[i]) + EPS) ta--;
        hull[ta++] = po[i];
    }
    double res = 0;
    for(int i = 0; i < ta - 1; i++) res += dist(hull[i], hull[i + 1]);
    printf("%.0lf", res + PI * 2 * m);
    return 0;
}
###</code>
```

---

## 作者：Chenyichen0420 (赞：1)

## 思路分析

障眼法，和[信用卡凸包](https://www.luogu.com.cn/problem/P3829)本质相同，甚至还更良心一点。

我们考虑一下凸包上的两个城堡之间的墙的形状：

![](https://cdn.luogu.com.cn/upload/image_hosting/qheclc2h.png)

其实我们注意到，最后的形状无非就是将城堡本身的凸包的那些线段向外平移 $L$ 的长度，然后再使用圆弧围起来剩余的部分。

那么，直线的部分我们会求，圆弧的部分呢？

首先，因为你维护的是凸包，因此其形状一定是一个凸多边形。这也就意味着其外角和就是 $2\pi$。

我们再观察一个角：

![](https://cdn.luogu.com.cn/upload/image_hosting/n384qkla.png)

显然，$\angle DAE$ 就是所谓的外角，而 $\angle CAB$ 就是圆弧所对角。二者显然是相等的。

因此，这些圆心角之和就是 $2\pi$。

所以最终的答案就是城堡凸包的周长加上一个半径为 $L$ 的圆的周长。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
//#define int long long
#define double long double
int n, st[1000005], pt, l; double ans;
struct vecor {
	double x, y;
	vecor(const double& xi = 0, const double& yi = 0) :x(xi), y(yi) {}
	friend vecor operator+(const vecor& l, const vecor& r) {
		return vecor(l.x + r.x, l.y + r.y);
	}
	friend vecor operator-(const vecor& l, const vecor& r) {
		return vecor(l.x - r.x, l.y - r.y);
	}
	friend vecor operator*(const vecor& l, const double& r) {
		return vecor(l.x * r, l.y * r);
	}
	friend vecor operator/(const vecor& l, const double& r) {
		return vecor(l.x / r, l.y / r);
	}
	friend double operator*(const vecor& l, const vecor& r) {
		return l.x * r.y - l.y * r.x;
	}//叉乘
	friend double operator^(const vecor& l, const vecor& r) {
		return l.x * r.x + l.y * r.y;
	}//点乘
	inline double operator()() {
		return sqrt(x * x + y * y);
	}
	inline double operator()(int) {
		return atan2(y, x);
	}
	friend bool operator<(const vecor& l, const vecor& r) {
		return l.x != r.x ? l.x < r.x: l.y < r.y;
	}
}p[1000005];
inline double slope(const vecor& l, const vecor& r) {
	return l.x != r.x ? (l.y - r.y) / (l.x - r.x) : 1e20;
}
inline double dis(const vecor& l, const vecor& r) {
	return sqrt((l.x - r.x) * (l.x - r.x) + (l.y - r.y) * (l.y - r.y));
}
signed main() {
	ios::sync_with_stdio(0);
	cin >> n >> l;
	for (int i = 1; i <= n; ++i) cin >> p[i].x >> p[i].y;
	sort(p + 1, p + n + 1);
	for (int i = 1; i <= n; ++i) {
		while (pt > 1 && slope(p[i], p[st[pt - 1]]) < slope(p[st[pt]], p[st[pt - 1]])) pt--;
		st[++pt] = i;
	}
	for (int i = 1; i < pt; ++i) ans += dis(p[st[i]], p[st[i + 1]]); pt = 0;
	for (int i = n; i > 0; i--) {
		while (pt > 1 && slope(p[i], p[st[pt - 1]]) < slope(p[st[pt]], p[st[pt - 1]])) pt--;
		st[++pt] = i;
	}
	for (int i = 1; i < pt; ++i) ans += dis(p[st[i]], p[st[i + 1]]);
	ans += acos(-1.0) * l * 2; printf("%.0Lf\n", ans);
}
//私は猫です
```

---

## 作者：Emp7iness (赞：1)

Update on 2022.8.12：将代码中的 `dis` 函数换成了 `std::hypot`，`l*6.2831853` 换成了 `std::numbers::pi*l*2`（需要 `<numbers>` 头文件且需要 `C++20`）

## 前置知识：二维凸包

[二维凸包模板传送门](https://www.luogu.com.cn/problem/P2742)

[OI Wiki](https://oi-wiki.org/geometry/convex-hull/)

凸包的定义：在平面上能包含所有给定点的最小凸多边形叫做凸包。

求凸包的算法一般有两种，分别是 Andrew 算法和 Graham 算法，这里只介绍 Graham 算法。

Graham 算法的原理就是维护一个点集，通过扫描所有点向点集中不断添加更优的点和删除“凹”点最终形成凸包（因为如果一个凹多边形符合要求，那么必有一个凸多边形在周长上优于它，不然为什么不叫凹包）。

### 算法步骤

首先需要对点集排序。

Graham 算法快的一个很重要的原因就是因为预先进行了排序，所以可以减少扫描次数。

我们选择一个 $y$ 值最小的点（这里记为 $P_1$），将剩余点按照极角的大小排序（这里记为 $P_2$ - $P_5$）

![](https://cdn.luogu.com.cn/upload/image_hosting/arbcuh04.png)

我们按照排序的顺序，依次连接每一个点，如果发现当前点 $p[i]$ 与前两个点 $p[i-1]$ 与 $p[i-2]$ 形成了一个“凹壳”，那么点 $p[i-1]$ 就肯定不在凸包的点集当中。

下面是图解：

![](https://cdn.luogu.com.cn/upload/image_hosting/3fjgvkha.png)

首先连接 $P_1P_2$ 和 $P_2P_3$ ，暂时没有发现问题。

![](https://cdn.luogu.com.cn/upload/image_hosting/1p40zsug.png)

连接 $P_3P_4$ ，依然没有发现问题。

![](https://cdn.luogu.com.cn/upload/image_hosting/nsni3brs.png)

连接 $P_4P_5$ ，问题来了，$P_3P_4P_5$ 组成了一个“凹壳”，这样我们就应该把 $P_4$ 踢出去，直接连接 $P_3P_5$ 。

![](https://cdn.luogu.com.cn/upload/image_hosting/he6qm0wg.png)

踢出 $P_4$ ，连接 $P_3P_5$ 和 $P_5P_1$ ，凸包就求出来了。

回到本题。

[P2116 城墙](https://www.luogu.com.cn/problem/P2116)

题目要求最近距离不小于 $L$	,还要求周长最小值，那肯定恰好等于 $L$ 是最优的。

![](https://cdn.luogu.com.cn/upload/image_hosting/a7wq4ipu.png)

按照题意画出图，可以发现要求的就是多边形外面围的这一圈，由若干圆弧和线段组成。

易得 $P_1P_4IH$ 为矩形，所以 $IH=P_1P_4$ ，所以这一圈中的线段长度之和就是多边形周长。

怎么求多边形周长？可以用凸包求解，将给定点丢进凸包板子里就行了。

至于圆弧的总长度，猜想它就是一个圆的周长，也就是 $2 \pi L$ 。

证明：易得在 $\odot P_1$ 上的圆弧所对的圆心角与 $\angle P_2P_4P_1$ 互补。

同理，每个圆弧所对的圆心角都与多边形的一个内角互补。

因为凸多边形的外角和为 $360^{\circ}$ ，所以所有圆弧所对的圆心角之和为 $360^{\circ}$ ，所以所有圆弧的长度之和就是一个圆的周长。

最终答案即为凸包周长 $+ 2 \pi L$ 。

双倍经验 [UVA1303 Wall](https://www.luogu.com.cn/problem/UVA1303)
（注意细节，有多组数据，而且要输出两个换行，而且最后一组数据要少输出一个换行）

## 代码

```cpp
#include<iostream>
#include<algorithm>
#include<numbers>
#include<cmath>
using namespace std;
int n,l,t=1;
double ans;
struct point
{
	double x,y;
}p[1005],s[1005];
double check(point a1,point a2,point b1,point b2)
{
	return (a1.x-a2.x)*(b1.y-b2.y)-(a1.y-a2.y)*(b1.x-b2.x);
}
bool cmp(point a,point b)
{
	double k=check(a,p[1],b,p[1]);
	if(k>0||(k==0&&hypot(a.x-p[1].x,a.y-p[1].y)<hypot(b.x-p[1].x,b.y-p[1].y)))	return 1;
	return 0;
}
int main()
{
	cin>>n>>l;
	for(int i=1;i<=n;i++)
	{
		cin>>p[i].x>>p[i].y;
		if(p[i].y<p[1].y)	swap(p[i],p[1]);
	}
	sort(p+2,p+n+1,cmp);
	s[1]=p[1];
	for(int i=2;i<=n;i++)
	{
		if(p[i-1].x==p[i].x&&p[i-1].y==p[i].y)	continue;
		while(t>1&&check(s[t],s[t-1],p[i],s[t])<0)	t--;
		s[++t]=p[i];
	}
	s[t+1]=p[1];
	for(int i=1;i<=t;i++)	ans+=hypot(s[i].x-s[i+1].x,s[i].y-s[i+1].y);
	cout<<round(ans+numbers::pi*l*2);
	return 0;
}
```


---

## 作者：Yaha (赞：1)

### 二维凸包

借用一下Heartlessly大佬的图

![](https://s2.ax1x.com/2019/06/05/VNDe3t.png)

一个很直观的想法就是，既然题目要求每处离城堡的距离大于等于 $L$ ，那我们就处处距离为 $L$ 。这一定比某个地方莫名其妙凸出来一坨要优。但是难道题目就是让你求一遍原多边形周长吗？

Of course not.

来看能不能更优。观察上图中那一块凹进去的部分，根据三角形三边关系可以知道，上方平滑的那条一定比下面两条之和更优。已经不能更优了。我们再来考虑怎样求这个图形的周长。

对于那些平滑的直线，容易发现，长度和就是凸包周长。再看旁边的圆弧。例如点 $A$ 处，圆弧角度 $∠BAC+$ 多边形内角 $∠DAE+$ 两个直角 $=360°$ ,所以圆弧角度数值上等于该点外角。凸多边形外角和 $360°$ ，所以所有圆弧的角度加起来为 $360°$ 。

所以答案就是 凸包周长 $+2πL$

双倍经验：[UVA 1303](https://www.luogu.com.cn/problem/UVA1303)

代码：

```cpp
#include<bits/stdc++.h>

#define D double
#define x first
#define y second

using namespace std;

const int amou=1100;
const D eps=1e-8,PI=acos(-1);
typedef pair<D,D>PDD;

int n,L;
PDD p[amou];
int top,stac[amou];
bool we[amou];

PDD operator-(PDD a,PDD b){
	return {a.x-b.x,a.y-b.y};
}

D cross(PDD a,PDD b){
	return a.x*b.y-a.y*b.x;
}

D area(PDD a,PDD b,PDD c){
	return cross(b-a,c-a);
}

D get_dist(PDD a,PDD b){
	D X=a.x-b.x,Y=a.y-b.y;
	return sqrt(X*X+Y*Y);
}

D get_convex(){
	sort(p+1,p+n+1);
	for(int i=1;i<=n;i++)
	{
		while(top>=2&&area(p[stac[top-1]],p[stac[top]],p[i])>=0)
		{
			if(area(p[stac[top-1]],p[stac[top]],p[i])>0)
				we[stac[top]]=0;
			top--;
		}
		stac[++top]=i;
		we[i]=1;
	}
	we[1]=0;
	for(int i=n;i>=1;i--)
	{
		if(we[i]) continue;
		while(top>=2&&area(p[stac[top-1]],p[stac[top]],p[i])>=0)
			top--;
		stac[++top]=i;
	}
	D as=0;
	for(int i=1;i<top;i++)
		as+=get_dist(p[stac[i]],p[stac[i+1]]);
	return as;
}

int main(){
	scanf("%d%d",&n,&L);
	for(int i=1;i<=n;i++)
		scanf("%lf%lf",&p[i].x,&p[i].y);
	D as=get_convex()+2*PI*L;
	printf("%.lf",as);
	
	return 0;
}
```


---

## 作者：斯德哥尔摩 (赞：1)

楼上几位都用的水平序求凸包，我用的是极角序。

极角序好敲些，只要扫一遍即可，但是由于两次排序，当然没有水平序快啦。

首先，应该可以看出来肯定要求凸包，然后向外扩大$L$。

凸包很好求，极角序/水平序乱搞。。。

那将凸包扩大怎么做？

画个图发现所有在凸包上的点向外扩大的圆弧会形成一个整圆，半径为$L$。

而其他的边长不变。

于是答案就是凸包周长$+2\pi L$。

注：这题还卡极角序的排序函数，要小心。。。

附代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#define MAXN 1010
#define PI (acos(-1))
#define eps (1e-8)
using namespace std;
int n,m,len;
int xx,yy;
struct Point{
    double x,y;
}a[MAXN],stack[MAXN];
inline int read(){
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
inline bool cmp_one(const Point &p,const Point &q){
    if(p.y==q.y)return p.x<q.x;
    return p.y<q.y;
}
inline bool cmp_two(const Point &p,const Point &q){
    double x=atan2(p.y-yy,p.x-xx),y=atan2(q.y-yy,q.x-xx);
    if(x==y){
    	if(p.y==q.y)return p.x<q.x;
    	return p.y<q.y;
    }
    return x<y;
}
inline double cross(const Point p,const Point q,const Point r){
	return (p.x-r.x)*(q.y-r.y)-(q.x-r.x)*(p.y-r.y);
}
inline double dis(const Point p,const Point q){
    return sqrt((p.x-q.x)*(p.x-q.x)+(p.y-q.y)*(p.y-q.y));
}
void solve(){
	sort(a+1,a+n+1,cmp_one);
	xx=a[1].x;yy=a[1].y;
	stack[1]=a[1];
	sort(a+1,a+n+1,cmp_two);
	stack[2]=a[2];
	int top=2;
	for(int i=3;i<=n;i++){
		while(top>=2&&cross(stack[top],a[i],stack[top-1])<=0.00)top--;
		stack[++top]=a[i];
	}
	len=top;
}
void work(){
    double ans=PI*m*2.00;
    for(int i=1;i<len;i++)ans+=dis(stack[i],stack[i+1]);
    ans+=dis(stack[1],stack[len]);
    printf("%.0f\n",ans);
}
void init(){
    n=read();m=read();
    for(int i=1;i<=n;i++){a[i].x=read();a[i].y=read();}
    solve();
}
int main(){
    init();
    work();
    return 0;
}

```

---

## 作者：ivyjiao (赞：0)

根据凸包的性质，对于一些平面上的点，用一个多边形框住，周长最小的是凸包。所以我们先把凸包求出来，然后无视掉剩下的城堡。

不难发现，要求距离所有城池至少 $L$ 的城墙长度，还需要加一段弧，画个图就能得到，所有的弧的圆心角都是凸包对应角的外角，因为对于任意一个凸多边形（显然凸包是凸多边形），外角和为 $360$ 度，所以要加上的弧长是一个半径为 $L$ 的圆的周长。

注意一个点：$\pi$ 要取到 $3.14159$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+1;
int n,m,s[N],l;
double ans;
struct node{
    double x,y;
}a[N];
int angel(node a,node b,node c){
    return (a.y-b.y)*(b.x-c.x)-(a.x-b.x)*(b.y-c.y);
}
double dis(node a,node b){
    return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));
}
bool cmp(node a,node b){
    if(a.x==b.x) return a.y<b.y;
    return a.x<b.x;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i].x>>a[i].y;
    sort(a+1,a+1+n,cmp);
    s[1]=1,s[2]=2;
    l=2;
    for(int i=3;i<=n;i++){
        while(l>1&&angel(a[i],a[s[l]],a[s[l-1]])<=0) l--;
        s[++l]=i;
    }
    for(int i=1;i<l;i++) ans+=dis(a[s[i]],a[s[i+1]]);
    s[1]=1,s[2]=2;
    l=2;
    for(int i=3;i<=n;i++){
        while(l>1&&angel(a[i],a[s[l]],a[s[l-1]])>=0) l--;
        s[++l]=i;
    }
    for(int i=1;i<l;i++) ans+=dis(a[s[i]],a[s[i+1]]);
    printf("%.0f",ans+3.14159*m*2);
}
```

---

## 作者：HYdroKomide (赞：0)

## 题意：

给定一些点，求一条围住所有点且距离所有点距离不小于 $L$ 的围墙长度。

## 思路：

首先，能够围住所有点的最短围墙即为这些点所组成的凸包。这是凸包定义的一部分，证明起来也很容易：如果有任何大于 $180\degree$ 的角度出现，利用三角形两点之和大于第三边可知，直接连上对应的两个点一定更短。

因为有墙的距离与点距离不小于 $L$ 这一条件，对于每一个凸包上的顶点都一定有一个 $L$ 为半径、该顶点外角为夹角的一段圆弧。由凸多边形外角和为 $180\degree$ 可得，最终所有圆弧对围墙长度的贡献就是一个圆周，即 $2\pi L$。

剩下的就是平面凸包模板题，使用 Andrew 算法即可，个人认为更容易想且可用范围更大（相同的思想可以在一些斜率优化 dp 中求下凸包）。

简单回顾一下 Andrew 算法。其总体思想就是将上下凸壳分开来求，对于每一个凸壳，其连线斜率必然单调。以从左到右的顺序扫描，开个栈维护单调性即可做到带排序 $O(n\log n)$ 时间复杂度。

先从左到右依次入栈，找到有与栈顶的斜率比次栈顶小，即可弹出栈顶。简单来说，对于以下的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/vbs8ji1u.png)

如图我们先让 $A$、$B$ 依次进栈，发现次栈顶 $AC$ 斜率比栈顶 $BC$ 斜率还小，我们让 $B$ 速速出栈。从头遍历到尾，然后把栈里的相邻元素距离加入答案。

上凸壳反着做一遍一模一样的即可。

注意，为防止三点共线或斜率为无穷的情况，需要提前对所有节点的坐标做微小扰动，**随机加或减一个极小值**。

## 程序如下：

```cpp
#include<cstdio>
#include<algorithm>
#include<random>
#include<stack>
#include<cmath>
using namespace std;
const int N=1e5+5;
const double eps=1e-9,PI=3.1415926;
int n,top;
double r,ans;
struct NODE{double x,y;}a[N],st[N];
mt19937 rnd(19491001);
double disturb(){
	int rn=rnd();
	return (double)rn/2e9*eps;
}
bool cmp(NODE x,NODE y){return x.x<y.x;}
double getk(NODE x,NODE y){return (x.y-y.y)/(x.x-y.x);}//计算斜率
double getdis(NODE x,NODE y){return sqrt((x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y));}
int main(){
	scanf("%d%lf",&n,&r);
	for(int i=1;i<=n;i++)scanf("%lf%lf",&a[i].x,&a[i].y),a[i].x+=disturb(),a[i].y+=disturb();
	sort(a+1,a+n+1,cmp);//按照横坐标从小到大排序
	st[++top]=a[1];//先入栈最左侧的元素
	for(int i=2;i<=n;i++){
		while(top>1&&getk(a[i],st[top-1])+eps<getk(a[i],st[top]))top--;//弹出之前要先保证栈内元素多于一个，不能把第一个元素弹出了
		st[++top]=a[i];
	}
	for(int i=1;i<top;i++)ans+=getdis(st[i],st[i+1]);
	top=0;
	st[++top]=a[n];
	for(int i=n-1;i>=1;i--){
		while(top>1&&getk(a[i],st[top-1])+eps<getk(a[i],st[top]))top--;
		st[++top]=a[i];
	}//反着做一遍一样的，单独计算答案
	for(int i=1;i<top;i++)ans+=getdis(st[i],st[i+1]);
	printf("%.0lf\n",ans+2*PI*r);
	return 0;
}
```

## THE END

---

## 作者：MoonCake2011 (赞：0)

简单题，首先，因为最短。

所以围墙长这样，因为作者太懒，所以借一下同学 cyc 的图。

![](https://cdn.luogu.com.cn/upload/image_hosting/qheclc2h.png)

所以，再由上图，非圆周部分可以直接收缩到内部。

那直线边就是那些点的凸包。

再计算剩余部分。

可以发现直径对对垂直。

所以每个两虚线所成角之和加上两个垂直就等于多边形角的个数个周角减去多边形内角和。

所以设多边形角数为 $x$，每个两虚线所成角之和为 $\alpha$。

可以写成下列公式

$$\alpha+180\degree x=360\degree x-180\degree (x-2)$$

$$\alpha=360\degree$$

所以剩余部分是整个圆周。

也就是 $2\pi l$。

那就简单了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
double l;
#define PI 3.1415926
struct node{
	double x,y;
}a[100010];
bool operator < (node x,node y){
	return x.x<y.x;
}
int st[200010],top;
inline double dist(double x,double y,double x2,double y2){
	return sqrt((x-x2)*(x-x2)+(y-y2)*(y-y2));
}
int main() {
	cin>>n>>l;
	for(int i=1;i<=n;i++) cin>>a[i].x>>a[i].y;
	sort(a+1,a+n+1);
	assert(n>=3);
	st[++top]=1,st[++top]=2;
	for(int i=3;i<=n;i++){
		while(top>1 && (a[i].y-a[st[top]].y)*(a[st[top]].x-a[st[top-1]].x)<=(a[st[top]].y-a[st[top-1]].y)*(a[i].x-a[st[top]].x))
			top--;
		st[++top]=i;
	}
	st[++top]=n-1;
	for(int i=n-2;i>=1;i--){
		while(top>1 && (a[i].y-a[st[top]].y)*(a[st[top]].x-a[st[top-1]].x)<=(a[st[top]].y-a[st[top-1]].y)*(a[i].x-a[st[top]].x))
			top--;
		st[++top]=i;
	}
	double ans=0;
	st[++top]=st[1];
//	for(int i=1;i<=top;i++) cout<<st[i]<<" ";
	for(int i=2;i<=top;i++) ans+=dist(a[st[i-1]].x,a[st[i-1]].y,a[st[i]].x,a[st[i]].y);
	printf("%.0f",ans+2*PI*l);
	return 0;
}
```

---

## 作者：Imiya (赞：0)

若城堡为一个凸多边形，那么考虑紧贴下限修城墙，显然在非拐角处，城墙在对应边外截距为 $L$ 的平行线上，因为矩形，所以其长度等于对应边。拐角处，城墙在以对应点为圆心，半径为 $L$ 的圆上。

如下图，这段城墙所对的圆心角 
$$\angle EBG=2\pi-\angle EBA-\angle GBC-\angle ABC$$
$$=2\pi-\frac\pi 2-\frac\pi 2-\angle ABC$$
$$=\pi-\angle ABC$$

所以弧 $EG$ 等于 $L\times(\pi-\angle ABC)$
![](https://cdn.luogu.com.cn/upload/image_hosting/sm0f6isb.png)

这是城堡为凸多边形时的计算，若它不是凸多边形，因为两点之间线段最短，所以我们不会考虑凹下去的点，那么显然答案就是求出城堡的凸包再按上面的方法所求的结果。

发现精度还可以更好。设求出来的凸包是 $n$ 边形，圆弧所对圆心角之和为 $\alpha$，显然有 $n\pi-(n-2)\pi=\alpha=2\pi$，所以城墙的圆弧部分的长度和为 $2\pi L$，也就是是圆的周长。

代码
```cpp
#include<iostream>
#include<cmath>
using namespace std;
const int N=1010;
struct vector_t{
    double x,y;
    inline double dis(){return sqrt(x*x+y*y);}
    vector_t operator+(const vector_t&b)const
    {return (vector_t){x+b.x,y+b.y};}
    vector_t operator-(const vector_t&b)const
    {return (vector_t){x-b.x,y-b.y};}
    friend vector_t operator^(const vector_t a,const double b)
    {return (vector_t){a.x*b,a.y*b};}
    friend vector_t operator^(const double b,const vector_t a)
    {return (vector_t){a.x*b,a.y*b};}
    double operator*(const vector_t&b)const
    {return x*b.x+y*b.y;}
    double operator&(const vector_t&b)const
    {return x*b.y-y*b.x;}
}a[N];
const double pi=3.141592653589793;
int n;
inline bool cmp(const vector_t&x,const vector_t&y)
{return x.x==y.x?x.y<y.y:x.x<y.x;}
vector_t stk1[N],stk2[N];
int top1,top2;
void andrue(){
    sort(a+1,a+n+1,cmp);
    stk1[++top1]=a[1];
    stk2[++top2]=a[1];
    for(int i=2;i<=n;i++){
        while(top1>1&&((stk1[top1]-stk1[top1-1])&(a[i]-stk1[top1]))>=0)top1--;
        stk1[++top1]=a[i];
        while(top2>1&&((stk2[top2]-stk2[top2-1])&(a[i]-stk2[top2]))<=0)top2--;
        stk2[++top2]=a[i];
    }
}
double l,ans;
void init(){
    cin>>n>>l;
    for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].y;
}
int main(){
//    freopen("read.in","r",stdin);
    init();
    andrue();
    n=0;
    for(int i=2;i<=top1;i++)a[++n]=stk1[i];
    for(int i=top2-1;i;i--)a[++n]=stk2[i];
    for(int i=1;i<n;i++)ans+=(a[i]-a[i+1]).dis();
    ans+=(a[1]-a[n]).dis();
    printf("%.0lf",ans+2*pi*l);
    return 0;
}
```

---

## 作者：Fa_Nanf1204 (赞：0)

### 分析：
首先可以看出这是一道凸包的变形，关键在于围墙离城堡的最近距离不能少于 $L$ 的这一限制。

那么考虑以每个点为圆心，作一个半径为 $L$ 的圆，那么城墙一定不能进入圆内，那么又要求围墙长度尽可能的小，所以总长度就是以凸包上的点为圆心的圆的切线长加上一段段的圆弧长。

切线长就是凸包的周长，圆弧的总弧度可以像证明多边形外角和一样证明永远是 $2\pi$，所以最后的答案就是凸包周长加上一个整圆的周长。
### Code:

```cpp
//Andrew
#include<bits/stdc++.h>
#define D double
#define N 100005 
#define M_PI 3.14159265358979323846
using namespace std;
int n;
struct node{
	D x,y;
}e[N];
D dis(node u,node v){
	return sqrt((u.x-v.x)*(u.x-v.x)+(u.y-v.y)*(u.y-v.y));
}
D cj(node a1,node a2,node b1,node b2){//a1a2->*b1b2->
	return (a2.x-a1.x)*(b2.y-b1.y)-(a2.y-a1.y)*(b2.x-b1.x);
}
bool cmp(node x,node y){
	return x.x<y.x or (x.x==y.x and x.y<y.y);
}
node down[N],up[N];
int cnt1=0,cnt2=0;
D ans=0;
int L;
int main(){
	//freopen("1.txt","r",stdin);
	cin>>n>>L;
	for(int i=1;i<=n;i++){
		cin>>e[i].x>>e[i].y;
	}
	sort(e+1,e+n+1,cmp);
	down[++cnt1]=e[1];
	down[++cnt1]=e[2];
	for(int i=3;i<=n;i++){
		while(cnt1>=2 and cj(down[cnt1-1],down[cnt1],down[cnt1],e[i])<=0) cnt1--;
		down[++cnt1]=e[i];
	}
	up[++cnt2]=e[n];
	up[++cnt2]=e[n-1];
	for(int i=n-2;i>=1;i--){
		while(cnt2>=2 and cj(up[cnt2-1],up[cnt2],up[cnt2],e[i])<=0) cnt2--;
		up[++cnt2]=e[i];
	}
	for(int i=1;i<=cnt1-1;i++){
		ans+=dis(down[i],down[i+1]);
	}
	for(int i=1;i<=cnt2-1;i++){
		ans+=dis(up[i],up[i+1]);
	}
	printf("%.0lf",ans+M_PI*2*L);
	return 0;
} 
```

---

## 作者：Great_Influence (赞：0)

总的来说和楼上做法一样，只是凸包的求法还有不同的做法。

我选用的是单调栈维护凸包。先按x坐标（第二优先y坐标）排序，然后从左向右扫，判断叉积是否小于等于0（大于等于也可以），然后保证栈中的点均满足这一要求，即可得到上（下）凸壳。然后在从右往左扫，维护相同性质的单调栈，即可得到另一半凸壳。因为排序是$O(n\log_2n)$的，所以时间复杂度为$O(n\log_2n)$。

代码：

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
using namespace std;
template<typename T>inline void read(T &x)
{
	T s=0,f=1;char k=getchar();
	while(!isdigit(k)&&(k^'-'))k=getchar();
	if(!isdigit(k)){f=-1;k=getchar();}
	while(isdigit(k)){s=s*10+(k^48);k=getchar();}
	x=s*f;
}
void file()
{
	#ifndef ONLINE_JUDGE
		freopen("test.in","r",stdin);
		freopen("test.out","w",stdout);
	#endif
}
#define Chkmax(a,b) a=a>(b)?a:(b)
#define Chkmin(a,b) a=a<(b)?a:(b)
const int MAXN=1017;
static int n,l;
static struct node
{
	int x,y;
	friend bool operator<(node a,node b)
	{return a.x^b.x?a.x<b.x:a.y<b.y;}
}p[MAXN];
static int que[MAXN],top,use[MAXN];
static double ans;
#define sq(a) ((a)*(a))
inline void init()
{
	read(n);read(l);ans=l*2*acos(-1);
	Rep(i,1,n)read(p[i].x),read(p[i].y);
	sort(p+1,p+n+1);
	Rep(i,1,n)
	{
		for(;top>1&&
(p[i].x-p[que[top]].x)
*(p[que[top]].y-p[que[top-1]].y)
-(p[i].y-p[que[top]].y)
*(p[que[top]].x-p[que[top-1]].x)<=0;--top);
		que[++top]=i;
	}
	Rep(i,1,top-1)
ans+=sqrt(sq(p[que[i]].x-p[que[i+1]].x)
		+sq(p[que[i]].y-p[que[i+1]].y));
	Rep(i,1,top)use[que[i]]=true;
	que[1]=que[top];top=1;
	use[1]=0;
	Repe(i,que[1]-1,1)if(!use[i])
	{
		for(;top>1&&
(p[i].x-p[que[top]].x)
*(p[que[top]].y-p[que[top-1]].y)
-(p[i].y-p[que[top]].y)
*(p[que[top]].x-p[que[top-1]].x)<=0;--top);
		que[++top]=i;
	}
	que[++top]=1;
	Rep(i,1,top-1)
ans+=sqrt(sq(p[que[i]].x-p[que[i+1]].x)
		+sq(p[que[i]].y-p[que[i+1]].y));
	printf("%.0lf\n",ans);
}
inline void solve()
{
}
int main()
{
	file();
	init();
	solve();
	return 0;
}
```

---


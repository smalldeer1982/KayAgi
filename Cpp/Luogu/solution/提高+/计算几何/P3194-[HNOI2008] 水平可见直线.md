# [HNOI2008] 水平可见直线

## 题目描述

在 $x-y$ 直角坐标平面上有 $n$ 条直线 $L_1,L_2,…L_n$，若在 $y$ 值为正无穷大处往下看，能见到 $L_i$ 的某个子线段，则称 $L_i$ 为可见的，否则 $L_i$ 为被覆盖的。
例如，对于直线:
$L_1:y=x$;
$L_2:y=-x$;
$L_3:y=0$;
则 $L_1$ 和 $L_2$ 是可见的，$L_3$ 是被覆盖的。给出 $n$ 条直线，表示成 $y=Ax+B$ 的形式($|A|,|B| \le 500000$)，且 $n$ 条直线两两不重合，求出所有可见的直线。

## 样例 #1

### 输入

```
3
-1 0
1 0
0 0```

### 输出

```
1 2```

# 题解

## 作者：p_b_p_b (赞：30)

本题最好的一篇题解的图片似乎咕咕咕了，那我来补一篇吧，顺便发个计算几何板子。

首先你画画图，发现一个性质：从上往下看能看到的图像一定是一个下凸的图像，像这样：

![](https://cdn.luogu.com.cn/upload/pic/49553.png)

至于为什么嘛……画下图就出来了。

再观察一下：从左往右，斜率递增。

那么做法就很明显了：

· 直线以斜率为第一关键字，截距为第二关键字排序；

· 维护一个单调栈记录当前能看见的直线编号；

· 每次加入一条直线就把栈顶被覆盖的直线丢掉（用直线交点判一下就好了）。

· 输出答案。

我的代码巨长无比，因为有其他计算几何的模板。推荐一个挺好的学习笔记：https://www.cnblogs.com/candy99/p/6360536.html 。Candy?太神仙了。（然而那里面的线段相交似乎挂了）

代码：

```cpp
#include<bits/stdc++.h>
namespace my_std{
	using namespace std;
	#define pii pair<int,int>
	#define fir first
	#define sec second
	#define MP make_pair
	#define rep(i,x,y) for (int i=(x);i<=(y);i++)
	#define drep(i,x,y) for (int i=(x);i>=(y);i--)
	#define go(x) for (int i=head[x];i;i=edge[i].nxt)
	#define sz 50505
	typedef long long ll;
	template<typename T>
	inline void read(T& t)
	{
		t=0;char f=0,ch=getchar();
		double d=0.1;
		while(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();
		while(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();
		if(ch=='.')
		{
			ch=getchar();
			while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();
		}
		t=(f?-t:t);
	}
	template<typename T,typename... Args>
	inline void read(T& t,Args&... args){read(t); read(args...);}
	void file()
	{
		#ifndef ONLINE_JUDGE
		freopen("a.txt","r",stdin);
		#endif
	}
//	inline ll mul(ll a,ll b){ll d=(ll)(a*(double)b/mod+0.5);ll ret=a*b-d*mod;if (ret<0) ret+=mod;return ret;}
}
using namespace my_std;

#define I inline
typedef double db;
const db eps=1e-8;
I int dcmp(db x){return fabs(x)<=eps?0:(x>0?1:-1);}
struct Vector
{
	db x,y;
	Vector(db xx=0,db yy=0){x=xx,y=yy;}
	I const Vector operator + (const Vector &a) const {return Vector(x+a.x,y+a.y);}
	I const Vector operator - (const Vector &a) const {return Vector(x-a.x,y-a.y);}
	I const Vector operator * (const db &a) const {return Vector(x*a,y*a);}
	I const Vector operator / (const db &a) const {return Vector(x/a,y/a);}
	I const bool operator < (const Vector &a) const {return dcmp(x-a.x)==0?dcmp(y-a.y)<0:dcmp(x-a.x)<0;}
	I const bool operator == (const Vector &a) const {return dcmp(x-a.x)==0&&dcmp(y-a.y)==0;}
	I const bool operator != (const Vector &a) const {return dcmp(x-a.x)!=0||dcmp(y-a.y)!=0;}
};
typedef Vector Point;
I Vector Normal(Vector a){return Vector(-a.y,a.x);} // counterclockwise
I db Dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}
I db Cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}
I db Len(Vector a){return sqrt(Dot(a,a));}
I db Len2(Vector a){return Dot(a,a);}
I db Angle(Vector a,Vector b){return acos(Dot(a,b)/Len(a)/Len(b));}
I Vector Rotate(Vector a,db rad){return Vector(cos(rad)*a.x-sin(rad)*a.y,sin(rad)*a.x+cos(rad)*a.y);}
struct Line
{
	Point a,b; // a->b
	Line(){}
	Line(Point aa,Point bb){a=aa,b=bb;}
};
I db DisL(Point p,Line l){Vector u=p-l.a,v=l.b-l.a;return fabs(Cross(u,v))/Len(v);} // dist to line
I db DisS(Point p,Point a,Point b) // dist to segment
{
	if (a==b) return Len(p-a);
	Vector v1=b-a,v2=p-a,v3=p-b;
	if (dcmp(Dot(v1,v2))<0) return Len(v2);
	if (dcmp(Dot(v1,v3))>0) return Len(v3);
	return fabs(Cross(v1,v2))/Len(v1);
}
I bool OnLeft(Point p,Line l){return dcmp(Cross(p-l.a,l.b-l.a))<=0;}
I bool OnLine(Point p,Line l){return dcmp(Cross(p-l.a,l.a-l.b))==0;}
I bool OnSeg(Point p,Point a,Point b){return dcmp(Cross(p-a,a-b))==0&&dcmp(Cross(p-a,p-b))<0&&p!=a&&p!=b;}
I Point LI(Line l1,Line l2) // line intersection
{
	Vector v=l1.a-l2.a,v1=l1.b-l1.a,v2=l2.b-l2.a;
	db t=Cross(v,v2)/Cross(v2,v1);
	return l1.a+v1*t;
}
I bool LSI(Line l,Point a,Point b) // line-seg intersection
{
	Vector v=l.b-l.a,v1=a-l.a,v2=b-l.a;
	return dcmp(Cross(v,v1))!=dcmp(Cross(v,v2));
}
I bool SSI(Point a1,Point b1,Point a2,Point b2) /*seg-seg intersection*/ {Line l1(a1,b1),l2(a2,b2);return LSI(l1,a2,b2)&&LSI(l2,a1,b1);}
I Point Circumcenter(Point a,Point b,Point c) // wai xin
{
	Point p=(a+b)/2,q=(a+c)/2;
	Vector u=Normal(b-a),v=Normal(c-a);
	if (!dcmp(Len(a-b)+Len(a-c)-Len(b-c))) return (b+c)/2;
	if (!dcmp(Len(a-b)+Len(b-c)-Len(a-c))) return (a+c)/2;
	if (!dcmp(Len(a-c)+Len(b-c)-Len(a-b))) return (a+b)/2;
	return LI(Line(p,p+u),Line(q,q+v));
}
I Point Barycenter(Point a,Point b,Point c) /*zhong xin*/ {return (a+b+c)/3;}
I bool PolarCmp(Point a,Point b){db c=Cross(a,b);return dcmp(c)==0?a.x<b.x:dcmp(c)>0;}
db PolygonArea(Point *p,int n)
{
	db ret=0;
	rep(i,2,n-1) ret+=Cross(p[i]-p[1],p[i+1]-p[1]);
	return fabs(ret/2);
}
int InPolygon(Point *poly,int n,Point p) // 1:in 0:out -1:on
{
	int ret=0;
	rep(i,1,n)
	{
		int j=i%n+1;
		if (OnSeg(p,poly[i],poly[j])||p==poly[i]||p==poly[j]) return -1;
		if (poly[i].y==poly[j].y) continue;
		int tmp=(poly[i].y>poly[j].y?i:j);
		if (p.y==poly[tmp].y&&p.x<poly[tmp].x) { ret^=1; continue; }
		tmp=(poly[i].y<poly[j].y?i:j);
		if (p.y==poly[tmp].y&&p.x<poly[tmp].x) continue;
		if (SSI(p,p+Vector(1e18,0),poly[i],poly[j])) ret^=1;
	}
	return ret;
}
bool IsConvex(Point *poly,int n)
{
	int now=0,last=0;
	rep(i,1,n)
	{
		int j=i+1,k=i+2;j>n?j-=n:0;k>n?k-=n:0;
		now=dcmp(Cross(poly[k]-poly[j],poly[j]-poly[i]));
		if (now*last<0) return 0;
		last=now;
	}
	return 1;
}
int GetConvex(Point *p,int n,Point *ret) // return the size of the convex
{
	sort(p+1,p+n+1);n=unique(p+1,p+n+1)-p-1;
	int m=0;
	rep(i,1,n)
	{
		while (m>1&&dcmp(Cross(ret[m]-ret[m-1],p[i]-ret[m-1]))<=0) --m;
		ret[++m]=p[i];
	}
	int _m=m;
	drep(i,n-1,1)
	{
		while (m>_m&&dcmp(Cross(ret[m]-ret[m-1],p[i]-ret[m-1]))<=0) --m;
		ret[++m]=p[i];
	}
	if (n>1) --m;
	return m;
}
db RotatingCalipers(Point *p,int n)
{
	db ret=0;
	if (n==1) return ret;
	if (n==2) return Len(p[1]-p[2]);
	int now=1;Point _=p[n+1];p[n+1]=p[1];
	rep(i,1,n)
	{
		while (dcmp(DisL(p[now],Line(p[i],p[i+1]))-DisL(p[now+1],Line(p[i],p[i+1])))<0) now=now%n+1;
		ret=max(ret,max(Len(p[now]-p[i]),Len(p[now]-p[i+1])));
	}
	p[n+1]=_;
	return ret;
}
db MinCircleCover(Point *p,int n,Point &O) // return the minimum radius
{
	O=p[1];db r=0;
	rep(i,2,n) if (dcmp(r-Len(p[i]-O))<0)
	{
		O=p[i],r=0;
		rep(j,1,i-1) if (dcmp(r-Len(p[j]-O))<0)
		{
			O=(p[i]+p[j])/2,r=Len(O-p[j]);
			rep(k,1,j-1) if (dcmp(r-Len(p[k]-O))<0)
			{
				O=Circumcenter(p[i],p[j],p[k]);
				r=Len(O-p[k]);
			}
		}
	}
	return r;
}

int n;
struct hh{db k,b;int id;}a[sz];
inline bool cmp(const hh &x,const hh &y){return x.k==y.k?x.b>y.b:x.k<y.k;}
Line aa[sz];
int top,s[sz];

int main()
{
	file();
	db x,y;
	read(n);
	rep(i,1,n) read(x,y),a[i]=(hh){x,y,i};
	sort(a+1,a+n+1,cmp);
	rep(i,1,n) aa[i].a=Point(0,a[i].b),aa[i].b=Point(1,a[i].k+a[i].b);
	s[top=1]=1;
	rep(i,2,n) if (a[i].k!=a[i-1].k)
	{
		while (top>1&&dcmp(LI(aa[s[top]],aa[s[top-1]]).x-LI(aa[s[top-1]],aa[i]).x)>=0) --top;
		s[++top]=i;
	}
	rep(i,1,top) s[i]=a[s[i]].id;
	sort(s+1,s+top+1);
	rep(i,1,top) printf("%d ",s[i]);
}
```

---

## 作者：LiRewriter (赞：22)

题意乍一看不是很明确...所以首先解释一下题干。

![](http://ozz4vkmqm.bkt.clouddn.com/18-1-18/26057792.jpg)

如上图，蓝色的是各式各样的直线，而我们要求的就是最上面的这一部分包含哪些直线。

就相当于求一个分段函数函数的极值。并且，我们称这些部分的集合为凸壳。

我们一点一点来思考。首先介绍一下单调栈的概念：

如果有一个栈，支持不断弹出以维护单调性，那么就称这个栈叫做单调栈。对单调性的维护方法是因题而异的。由于每个元素至多进入一次，所以其复杂度是$O(n)$的。

我们首先按照斜率从小到大的顺序排序。然后再以此为基准进行下面的思考。至于为什么这样做，下面再来分析。

思考一下就可以想象到，斜率最小和最大的应该是保留的，因为这是最边上的两段凸壳。

![](http://ozz4vkmqm.bkt.clouddn.com/18-1-18/2095888.jpg)

首先来看两条线的情况，结果就是红色的一段。显然，两条线都在凸壳内，我们定义交点是$P$点。将这两条线段加入栈中，由于斜率排过序，我们将紫色的称为1，蓝色的称为2。

然后这时加入一条线，同样由于斜率排过序，所以结果应该是两条绿线之一：

![](http://ozz4vkmqm.bkt.clouddn.com/18-1-18/15306555.jpg)

上面的绿线与2的交点在$P$的左边，并且观察可以得到，这条绿线取代了刚才的2号线。所以我们弹出2号，加入3号，栈的情况是{1, 3}

下面的绿线与2的交点在$P$的右边，那么中间就有一段凸壳并没有被取代，所以我们不弹出，然后加入3号，栈的情况是{1, 2, 3}。

如果斜率的符号发生改变，结果应该是相似的：

![](http://ozz4vkmqm.bkt.clouddn.com/18-1-18/71083775.jpg)

保留与否观察交点位置即可。

好像看出了些规律：如果一条线进入之后与上一条线的交点在上一个交点的左边，那么就弹出上一条线；在右边则保留。至于不巧一样的情况，画一个图就可以明白应该是弹出上一条线。

这个弹出和比较的过程应该一直持续到交点产生在右边为止。

至于判断交点，直接联立方程比较横坐标即可。

最后的问题是斜率相同，截距不同的情况。同样画个图yy一下：

![](http://ozz4vkmqm.bkt.clouddn.com/18-1-18/33832719.jpg)

如果一组直线斜率相同，并且作为凸壳的一段，那么一定取截距最大的一段，因为会把下面的都遮住。

实现上我们可以从大到小排序，只保留第一条，然后把剩下的都跳过就好辣

代码和楼下Tgotp大佬的差不多~~（其实是我参考的有点多）~~所以就不贴了


---

## 作者：Tgotp (赞：13)

类型：半平面交

注意：初始情况下 应直接压入；

实现：直接手推 y 相同时 x的情况，进行更新（建议自己过手推一遍）。

算法：排序和单调栈


c++代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<queue>
using namespace std;
const int N = 5e4 + 5;
int s[N],top,n,ans[N];
inline void read(int&x)
{
    x = 0;char c;int sign = 1;
    do{ c = getchar(); if(c == '-') sign = -1; }while(c < '0' || c>'9');
    do{ x = x*10 + c -'0';c = getchar(); }while(c <= '9' && c >= '0');
    x *= sign;
}
struct str{
    int a,b,id;
}a[N];
const bool cmp(str a,str b){ if(a.a != b.a)return a.a >b.a;else return a.b >b.b; }
const bool cmop(int a,int b){ return a < b; }
double sol(int i,int j){ return (double)(a[i].b - a[j].b)/(double)(a[j].a - a[i].a); }
int main()
{
    read(n);
    for(int i = 1;i <= n;i++)
    {
        read(a[i].a);read(a[i].b);
        a[i].id = i;
    }
    sort(a+1,a+1+n,cmp);
    for(int i = 1;i <= n;i++)
    {
        if(a[i].a == a[i-1].a && i != 1) continue;
        while(top > 1 && sol(s[top],i) >= sol(s[top],s[top - 1])) top--;
        s[++top] = i;
        ans[top] = a[i].id;
    }
    sort(ans,ans + top + 1,cmop);
    for(int i = 1;i <= top;i++) printf("%d ",ans[i]);
    return 0;
}
推广blog： <http://tgotp.science>
```

---

## 作者：Social_Zhao (赞：12)

给一个不是半平面交的做法（

首先去重，斜率相同的只有截距较大者可见，因此下面的讨论中斜率各不相同。

假设有三条直线 $l_1, l_2, l_3$，考虑如果 $l_2$ 被遮挡，这三条直线应满足什么条件。

若 $l_2$ 是三者中斜率最大或者最小的，显然其不会被遮挡，所以我们不妨设 $A_1 < A_2 < A_3$。如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/a3nhgx28.png)

可以发现，记 $l_1 \cap l_3 = P(x_0, y_0)$，如果 $A_1x_0 + B_1 \geq A_2 x_0 + B_2$，则 $l_2$ 被遮挡，否则 $l_2$ 不被 $l_1$ 和 $l_3$ 遮挡。

接下来搞一波式子：

$$
A_1x_0 + B_1 = A_3x_0 + B_3 \Rightarrow x_0 = \frac{B_3 - B_1}{A_1 - A_3}
$$

$$
A_1\frac{B_3 - B_1}{A_1 - A_3} + B_1 \geq A_2\frac{B_3 - B_1}{A_1 - A_3} + B_2 \Rightarrow \color{red}{\frac{B_3 - B_1}{A_3 - A_1} \geq \frac{B_2 - B_1}{A_2 - A_1}}
$$

于是我们得到了这个红色的式子，记 $P_i=(A_i, B_i)$，那么上面的式子可以理解为：若 $P_1$ 到 $P_3$ 的斜率大于 $P_1$ 到 $P_2$ 的斜率，那么 $l_2$ 被遮挡。如图所示，下图中 $l_2$ 会被遮挡。

![](https://cdn.luogu.com.cn/upload/image_hosting/mqeu413d.png)

因此可见的直线应满足其对应的点 $P_i$ 在点集 $\{P_i\}$ 构成的上凸壳上。跑 Andrew 算法就可以了

~~实际上凸包和半平面交本身就是对偶问题所以这和半平面交其实是同一种做法。~~

```cpp
#include<bits/stdc++.h>
using namespace std;

int get() {
	int x = 0, f = 1; char c = getchar();
	while(!isdigit(c)) { if(c == '-') f = -1; c = getchar(); }
	while(isdigit(c)) { x = x * 10 + c - '0'; c = getchar(); }
	return x * f;
}

const int N = 5e4 + 5;
const double eps = 1e-8;
int n, top;
struct Vector {
	long long x, y;
	int id;
	Vector(long long a = 0, long long b = 0, long long c = 0) { x = a, y = b, id = c; }
	Vector operator +(Vector b) const { return Vector(x + b.x, y + b.y); }
	Vector operator -() const { return Vector(-x, -y); }
	Vector operator -(Vector b) { return *this + (-b); }
	double operator &(Vector b) { return x * b.y - y * b.x; }
} p[N], bin[N];

int main() {
	n = get();
	for(int i = 1; i <= n; i++) {
		double x, y;
		scanf("%lf%lf", &x, &y);
		p[i] = Vector(x, y, i);
	}
	sort(p + 1, p + 1 + n, [](Vector a, Vector b){ return a.x == b.x? a.y > b.y : a.x < b.x; });
	bin[1] = p[1], top = 1;
	for(int i = 2; i <= n; i++) {
		if(p[i].x == p[i - 1].x) continue;
		while(top > 1 && ((bin[top] - bin[top - 1]) & (p[i] - bin[top])) >= 0) --top;
		bin[++top] = p[i];
	}
	sort(bin + 1, bin + 1 + top, [](Vector a, Vector b){ return a.id < b.id; });
	for(int i = 1; i <= top; i++) 
		printf("%d ", bin[i].id);
	return 0;
}
```

---

## 作者：linaonao (赞：9)

### 思路
通过画图可知，题中的水平可见直线所形成的的图像是下凸壳，所以我们可以**以斜率为第一关键字**，**截距为第二关键字**排序，用一个栈来维护当前能看见的直线编号，**每次加入一条直线就把栈顶被覆盖的直线弹出**。
![](https://cdn.luogu.com.cn/upload/image_hosting/j7oh778k.png)     对于覆盖的线段可以用交点判断。（下图中$a$,$b$交点在$b$,$c$ 左侧，故可判断$b$被覆盖）
![](https://cdn.luogu.com.cn/upload/image_hosting/0imz6z5l.png)
### 代码
~~~ cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,ans[N],s[N],top;
struct node{
	int a,b,id;
}a[N];
bool cmp(node x,node y){
	if(x.a!=y.a) return x.a>y.a;//先按斜率再按截距排序 
	else return x.b>y.b;
}
double calc(int i,int j){//计算交点 
	return ((1.0*(a[i].b-a[j].b))/(a[j].a-a[i].a));
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		scanf("%d %d",&a[i].a,&a[i].b);a[i].id=i;
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		if(a[i].a==a[i-1].a&&i>1) continue;
		while(top>1&&calc(s[top],i)>=calc(s[top],s[top-1])) top--;//若当前交点在上一个交点左边,则上一条直线被覆盖,弹出栈 
		s[++top]=i;
		ans[top]=a[i].id;
	}
	sort(ans+1,ans+top+1);
	for(int i=1;i<=top;i++) printf("%d ",ans[i]);
	return 0;
}
~~~

---

## 作者：zjjws (赞：4)

这道题可以不用离线，也就是不用将直线按斜率和截距排序再做。

[强制在线版本](https://www.luogu.com.cn/problem/U145228)

这个题被万老爷 D 了，毕竟强制在线了也是板题。

我认为本身对于凸包入门的同学，还有我这种蒟蒻，做这题会对凸包的理解更深刻。

可以在 [我的解题报告](https://www.cnblogs.com/zjjws/p/13769602.html) 的 T4 找到强制在线的做法。

其实并没有什么区别，你只需把直线当做一个二元组塞到 set 里，然后每次考虑是否需要将斜率排名在自己左右的直线弹出即可。

至于判定方式，就是看交点，你可以从代数意义上去理解，也可以从图像去理解。我个人喜欢代数意义。

代码的话解题报告那个链接里也有。

---

## 作者：Lskkkno1 (赞：4)

[Luogu](https://www.luogu.com.cn/problem/P3194)

### 题目描述

给定若干条直线 (都是 $y = Ax + B$ 的形式)

求从上往下看所有可以看到的直线，从小往大输出编号

$N \le 50000$，$|A|,|B| \le 500000$

### 正解

从上往下看，若干条直线构成的**半平面交**的部分才是可见的

听说直接做半平面交可以 $O(nlogn)$ 做，~~但是我不会~~

$y = kx + b$，对于一个 $x$，只有最大的那一个 $y$ 才可以被看到

换一种形式看这条直线 : $-kx + y = b$

由于 $-k$ 和 $b$ 是固定的，所以可以先把它看成一个**定点** $(-k, b)$

对于每一个 $x$，我们要求最大的 $y$

把 $x$ 看作是**斜率**，则 $y$ 就是 $y$ 轴上的**截距**

发现对于所有的定点 $(-k, b)$ ，只有在(上)凸包的点是有用的

(伪)证明 : 想象一条斜率为 $x$ 的直线从上往下去靠，靠到第一个点时 $y$ 轴截距最大，这个靠到第一个点肯定是凸包上的点

那直接对点集 $(-k, b)$ 求上凸包就完了

$\color {DeepSkyBlue} {Code}$

我这份代码在 bzoj 上过了，但在 luogu 上过不了，~~窝佛了~~

```cpp
/*
	从上往下看, 若干条直线构成的半平面交的部分是可见的
	y = kx + b
	转化成对偶问题, 求上凸包, 只有凸包上的点才是可见的
	-kx + y = b
	相当于对于不同的 x, 要求最大的 y
*/
#include <bits/stdc++.h>
#define N 50005

using namespace std;

typedef long long LL;

int n;
int stk[N];
bool vis[N];

struct vec {
	LL x, y;
	vec (int _x = 0, int _y = 0) { x = _x, y = _y; }
	vec operator + (const vec &t) const { return vec(x + t.x, y + t.y); }
	vec operator - (const vec &t) const { return vec(x - t.x, y - t.y); }
	bool operator < (const vec &rhs) const {
		return x == rhs.x ? y < rhs.y : x < rhs.x;
	}
}a[N];

map<vec, int> id;

inline LL crop(const vec &u, const vec &v) { // 叉积
	return u.x * v.y - v.x * u.y;
}

int main() {
	scanf("%d", &n);
	for(int i = 1, x, y; i <= n; ++i) {
		scanf("%d%d", &x, &y);
		a[i] = vec(-x, y);
		id[a[i]] = i;
	}
	
	sort(a + 1, a + n + 1, less<vec>());
	
	int top = 0;
	for(int i = 1; i <= n; ++i) {
		while(top >= 2 && crop(a[i] - a[stk[top - 1]], a[stk[top]] - a[stk[top - 1]]) <= 0)
			--top;
		stk[++top] = i;
	}
	
	for(int i = 1; i <= top; ++i)
		vis[id[a[stk[i]]]] = true;
	for(int i = 1; i <= n; ++i)
		if(vis[i])
			printf("%d ", i);
	putchar('\n');
	return 0;
}
```



---

## 作者：McGrady (赞：4)

可以发现最后就是一个下凸的形状。首先按照斜率排序，按顺序加入一个单调栈，画图可以发现，如果当前加入的直线与栈顶直线交点在前一个交点的左边，则栈顶元素出栈。这样就是O(n)了。

pascal代码：

```cpp
program lines(input,output);
var
  a,b,c,z:array[0..50050]of longint;
  d:array[0..50050]of double;
  ans:array[0..50050]of boolean;
  n,m,i,j:longint;
procedure sort(q,h:longint);
var
  i,j,xa,xb,t:longint;
begin
   i:=q;j:=h;xa:=a[(i+j)>>1];xb:=b[(i+j)>>1];
   repeat
     while (a[i]<xa) or (a[i]=xa) and (b[i]>xb) do inc(i);
     while (xa<a[j]) or (xa=a[j]) and (xb>b[j]) do dec(j);
     if i<=j then
        begin
           t:=a[i];a[i]:=a[j];a[j]:=t;
           t:=b[i];b[i]:=b[j];b[j]:=t;
           t:=c[i];c[i]:=c[j];c[j]:=t;
           inc(i);dec(j);
        end;
   until i>j;
   if j>q then sort(q,j);
   if i<h then sort(i,h);
end;
function claris(x,y:longint):double;
begin
   exit((b[y]-b[x])/(a[x]-a[y]));
end;
begin
   //assign(input,'lines.in');assign(output,'lines.out');reset(input);rewrite(output);
   readln(n);
   for i:=1 to n do begin readln(a[i],b[i]);c[i]:=i; end;
   sort(1,n);
   m:=1;
   for i:=2 to n do if a[i]<>a[i-1] then begin inc(m);a[m]:=a[i];b[m]:=b[i];c[m]:=c[i] end;
   z[1]:=1;z[2]:=2;d[2]:=claris(1,2);j:=2;
   for i:=3 to m do
      begin
         while (claris(i,z[j])<=d[j]) and (j>1) do dec(j);
         inc(j);z[j]:=i;d[j]:=claris(z[j],z[j-1]);
      end;
   fillchar(ans,sizeof(ans),false);
   for i:=1 to j do ans[c[z[i]]]:=true;
   for i:=1 to n do if ans[i] then write(i,' ');
   //close(input);close(output);
end.
```

---

## 作者：Yaha (赞：2)

### 半平面交

每一条直线都看作从左指向右的向量，如果我们把每个向量的下方部分都扔掉，最后会得到一个轮廓，这个轮廓的上方没有直线，且这个轮廓的每个部分都是由这些直线组成的。这时候，在这个轮廓上面的直线都能被看到。

细节：题目中的描述不仅是为了让你理解题意，同时也提醒你，如果一条线只有一个点在这个轮廓上，这条直线是不计入答案的。这一点在写半平面交的时候注意就可以了。

跑一遍半平面交，再求出哪些直线在上面，即为答案。

代码：

```cpp
#include<bits/stdc++.h>

#define D double
#define x first
#define y second

using namespace std;

const int amou=5e4+90;
const D eps=1e-12;
typedef pair<D,D> PDD;

int n;
struct Line{
	PDD st,ed;
	int id;//程序要求输出编号，而半平面交会把线按角度排序从而打乱编号，所以需要最开始记录
}line[amou];
int q[amou];
bool we[amou];

PDD operator-(PDD a,PDD b){
	return {a.x-b.x,a.y-b.y};
}

D cross(PDD a,PDD b){
	return a.x*b.y-a.y*b.x;
}

int dcmp(D a,D b){
	if(fabs(a-b)<eps) return 0;
	if(a<b) return -1;
	return 1;
}

D area(PDD a,PDD b,PDD c){
	return cross(b-a,c-a);
}

D get_angle(Line a){
	return atan2(a.ed.y-a.st.y,a.ed.x-a.st.x);
}

bool cmp(Line a,Line b){
	D A=get_angle(a),B=get_angle(b);
	if(!dcmp(A,B)) return area(a.st,a.ed,b.st)<0;
	return A<B;
}

PDD get_line_intersection_point(PDD s1,PDD v,PDD s2,PDD w){
	PDD u=s1-s2;
	D t=cross(w,u)/cross(v,w);
	return {s1.x+v.x*t,s1.y+v.y*t};
}

PDD get_line_intersection_line(Line a,Line b){
	return get_line_intersection_point(a.st,a.ed-a.st,b.st,b.ed-b.st);
}

bool on_right(Line a,Line b,Line c){
	PDD t=get_line_intersection_line(b,c);
	return area(a.st,a.ed,t)<=0;
}

void half_plane_intersection(){
	sort(line+1,line+n+1,cmp);
	int head=0,tail=-1;
	for(int i=1;i<=n;i++)
	{
		if(i>1&&!dcmp(get_angle(line[i]),get_angle(line[i-1]))) continue;
		while(head+1<=tail&&on_right(line[i],line[q[tail]],line[q[tail-1]])) tail--;
		while(head+1<=tail&&on_right(line[i],line[q[head]],line[q[head+1]])) head++;
		q[++tail]=i;
	}
//	printf("%d ",tail-head+1);
//	while(head+1<tail&&on_right(line[q[head]],line[q[tail-1]],line[q[tail]])) tail--;
//	while(head+1<tail&&on_right(line[q[tail]],line[q[head]],line[q[head+1]])) head++;
	//注释掉的这几行是在半平面交板子中的，但由于这题的图形特殊性，并不存在首尾相接的情况，故这部分可以不要，但加上不会错
	for(int i=head;i<=tail;i++) we[line[q[i]].id]=1;
	for(int i=1;i<=n;i++) if(we[i]) printf("%d ",i);
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		D a,b;
		scanf("%lf%lf",&a,&b);
		line[i]={{0,b},{1,a+b},i};//一条直线上随便取的两个点，你当然也可以取x=2,3,......
	}
	half_plane_intersection();
	
	return 0;
}
```


---

## 作者：__Star_Sky (赞：1)

## Description
在平面直角坐标系中给定若干条直线，问在 $y$ 值为正无穷处往下看有多少条直线可见。当能看见一条直线的某个子线段时我们称一条直线可见，否则称这条直线被覆盖。

## Solution
从最简单的情况开始考虑。若只有两条直线，那么其中一条直线不可见当且仅当两条直线的斜率相同并且截距不同。此时截距较小的那条直线不可见。在以后的讨论中，我们只需要讨论斜率不同的情况就可以了。

考虑三条直线的情况。设三条直线为 $l_1,l_2,l_3$。我们用 $k$ 来表示斜率，不妨设三条直线的斜率 $k_1<k_2<k_3$。显然斜率最小的直线 $l_1$ 和斜率最大的直线 $l_3$ 都不可能被覆盖，只有 $l_2$ 可能被 $l_1$ 和 $l_3$ 覆盖。

那么什么时候 $l_2$ 会被覆盖呢？我们画个图看看。
![](https://cdn.luogu.com.cn/upload/image_hosting/4c5aszsv.png)
在情况 1 当中，$l_2$ 被 $l_1$ 和 $l_3$ 覆盖，此时 $l_2$ 在 $l_1$ 和 $l_3$ 的交点 $P$ 的下方。在情况 1 中，$l_2$ 没有 和 $l_3$ 覆盖，$l_2$ 在 $P$ 的上方。于是，我们只需要判断 $l_2$ 和 $P$ 的位置关系就可以了。

判断点和直线的位置关系？这一听就是向量干的事。将在 $l_2$ 上随便取两个点 $A,B$，将 $l_2$ 看作向量 $\overrightarrow{AB}$ ，用 $\overrightarrow{AP}$ 和 $\overrightarrow{AB}$ 的叉积判断一下即可。

在实现的时候，我们可以先将所有直线以斜率为第一关键字，以截距为第二关键字排序。之后我们依次扫描每一条直线，并将直线存入一个栈中。每一次插入直线之前用 while 循环判断一下栈顶的直线是否被当前直线和栈顶下面的那条直线覆盖，如果被覆盖则将其弹出。

考虑为什么这样做是正确的。设从栈顶往下的三条直线依次是 $l_3,l_2,l_1$，当前准备插入的直线是 $l_4$。画一画图很容易发现，若 $l_4$ 和 $l_1$ 能覆盖 $l_2$，那么 $l_4$ 和 $l_2$ 一定能够覆盖 $l_3$，否则 $l_2$ 就不应该出现在栈中，因为它已经被 $l_1$ 和 $l_3$ 覆盖了。也就是说，不会出现在栈中的位置靠下的直线原本应当被弹出，但因为在栈中的位置靠上的直线没有被弹出而没有被弹出的情况。正确性得证。
## Code
```
#include<bits/stdc++.h>
using namespace std;
const int N=5e4+10;
const int INF=0x3f3f3f3f;
struct Line{
	int k,b,id;
}a[N],sta[N];
struct Point{
	double x,y;
};
int top;
bool cmp(Line l1,Line l2) {return l1.k==l2.k?l1.b>l2.b:l1.k<l2.k;}
Point calc(Line l1,Line l2) {return {1.0*(l2.b-l1.b)/(l1.k-l2.k),1.0*l1.k*(l2.b-l1.b)/(l1.k-l2.k)+l1.b};}
Point get_point(int x,Line l) {return {1.0*x,1.0*((l.k)*x+(l.b))};}
double cross(Point a,Point b,Point c) {return (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&a[i].k,&a[i].b);
		a[i].id=i;
	}
	sort(a+1,a+n+1,cmp);
	a[0].k=INF;
	for(int i=1;i<=n;i++)
	{
		if(a[i].k==a[i-1].k) continue;
		while(top>1&&cross(get_point(0,sta[top]),get_point(1,sta[top]),calc(a[i],sta[top-1]))>=0) top--;
		sta[++top]=a[i];
	}
	sort(sta+1,sta+top+1,[](Line l1,Line l2){return l1.id<l2.id;});
	for(int i=1;i<=top;i++) printf("%d ",sta[i].id);
	return 0;
}
```

---

## 作者：Michvior_AC (赞：1)

# 水平可见直线 题解

## 题意

~~这道题，如果没看标签，我绝对想不到它居然是道凸包题。~~

大致题意是：在二维直角坐标系上，给 $n$ 条直线的斜率和截距，问你从在这个坐标系 $y$ 轴方向无穷远处，能看到多少条直线，从小到大输出其标号。

## 思路

我们从直线被覆盖的斜率和截距之间的关系入手，画了两个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/rzkhkcvw.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/t6rngjze.png)

我们从中不难发现以下结论：

1. 它确实是一个凸包；

2. 斜率相同时，截距大的会把小的覆盖掉（斜率一样,排名靠后的看不见）；

3. 截距相同时，斜率大的会更优（或者理解为更不容易被其他线覆盖）。

所以我们可以：

1. 先按斜率为第一关键字，截距为第二关键字对直线进行排序；

2. 然后维护一个单调栈来存可以看见的直线的编号 $(id)$，每次有新的直线加进来时，就用这条直线和栈顶直线的交点是不是在栈顶直线和上一条直线交点的左边来判断是否需要弹出之前的直线。（如在第一个图中，绿线和蓝线的交点在蓝线和红线交点的右边，故蓝线没有被覆盖，不用弹出，若交点在右侧，则弹出栈顶直线）；

3. 输出答案。

$Code:$

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 50005;

int n, top;
int s[N], ans[N];
struct node
{
    int x, y, id;
} p[N];

int read() {
    int x = 0, f = 1; char ch = getchar();
    while (ch < '0' || ch > '9') 
    	{if (ch == '-') f = -1; ch = getchar();}
    while (ch >= '0' && ch <= '9')
        x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();
    return x * f;
}

bool cmp(node a, node b)
{
    if (a.x != b.x) //第一关键字为斜率
    {
        return a.x > b.x;
    }
    else //第二关键字为截距
        return a.y > b.y;
}

double jiaodot(int a, int b) //计算交点
{
    return ((1.0 * (p[a].y - p[b].y)) / (p[b].x - p[a].x));
}

int main()
{
    n=read();
    for (int i = 1; i <= n; i++)
    {
        p[i].x=read();
        p[i].y=read();
        p[i].id = i;
    }
    sort(p + 1, p + n + 1, cmp);
    for (int i = 1; i <= n; i++)
    {
        if (p[i].x == p[i - 1].x and i > 1)
            continue;
        while (top > 1 and jiaodot(s[top], i) >= jiaodot(s[top], s[top - 1]))
            top--;
        s[++top] = i;//当前直线入栈。
        ans[top] = p[i].id; //记录答案。
    }
    sort(ans + 1, ans + top + 1);//将ans从小到大排一下序
    for (int i = 1; i <= top; i++)
    {
        printf("%d ", ans[i]);
    }
    return 0;
}
```

---

## 作者：xh39 (赞：1)

前置基础:一次函数。向(矢)量。 

发现,能被看到的函数是 $y=max\{a[i]x+b[i]\}$。这一定是单峰开口向上的函数。 

模仿求凸包的思路。首先将按照斜率从小到大排序。

有一个性质:斜率小的被挡住,那么斜率大的更会被挡住。

证明:建议自己画几条直线,可参照下图,右边 $3$ 条直线会被挡住。目前还未被挡住的部分,一定构成一个单峰且开口向上的分段函数,而挡住一定是挡住斜率最大的一段。

![](https://cdn.luogu.com.cn/upload/image_hosting/w94pvvz7.png)

然后依次入栈。如果栈顶直线被当前直线挡住,则出栈。然后一直到不被挡住,然后将当前直线入栈。为方便,栈内所有元素仅记录编号。

判断一个直线会不会被挡住:判断与前一条直线的交点是否被挡住即可。因为  $x$ 较大的时候斜率大的直线会更占优势,那么这条直线会被挡住。而 $x$ 较小时斜率小的会更占优势。

如下图,绿色的直线与红色直线的交点在左边。当 $x$ 比交点的x轴大的时候,绿线会被红线挡住,而 $x$ 比交点x轴小的时候,又会被黑线挡住。所以整条直线都会被挡住。

![](https://cdn.luogu.com.cn/upload/image_hosting/h1an0z0z.png)

求交点:有两条直线。$y_{0}=a_{0}x+b_{0},y_{2}=a_{1}x+b_{1}$。相交意味着$x,y$都相同。则可列出方程:$a_{0}x+b_{0}=a_{1}x+b_{1}$。整理得$(a_{0}-a_{1})x=b_{1}-b_{0}$。当 $a_0!=a_1$  时,直接得 $x=\frac{b_{1}-b_{0}}{a_{0}-a_{1}}$。

当 $a_{0}=a_{1}$ 时,特判即可。$a_{0}=a_{1}$意味着两直线平行。那么 $b$ 小的直线就会被挡住。露出来的只有$b$大的。

如何判一个点是否在一条直线的左边。取两个点,一个点的 $x$ 小于此点的 x轴,一个点大于此点的 x轴。注意别取太小太大,否则会精度误差。

![](https://cdn.luogu.com.cn/upload/image_hosting/qwkt6gaq.png)
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
struct zuobiao{
	double x,y;
	friend zuobiao operator +(const zuobiao &s1,const zuobiao &s2){
		zuobiao t;
		t.x=s1.x+s2.x;
		t.y=s1.y+s2.y;
		return t;
	}
	friend zuobiao operator -(const zuobiao &s1,const zuobiao &s2){
		zuobiao t;
		t.x=s1.x-s2.x;
		t.y=s1.y-s2.y;
		return t;
	}
	friend double operator *(const zuobiao &s1,const zuobiao &s2){
		return s1.x*s2.y-s1.y*s2.x;
	}
};
struct zhixian{
	int id,a,b;
}_[1000005];
struct rule{
	bool operator()(const zhixian &s1,const zhixian &s2){
		return s1.a<s2.a||s1.a==s2.a&&s1.b>s2.b; //注意斜率相同按与y轴的交点排序。
	}
};
#define eps 0.0000003
int s[1000005],top=0;
bool kkksc03[1000005];
int main(){
	int n,i;
	cin>>n;
	for(i=0;i<n;i++){
		cin>>_[i].a>>_[i].b;
		_[i].id=i;
	}
	sort(_,_+n,rule());
	for(i=0;i<n;i++){
		if(i&&_[i].a==_[i-1].a){
			continue;
		}
		while(top>=2){
			zuobiao jiao;
			jiao.x=(_[i].b-_[s[top-1]].b)*1.0/(_[s[top-1]].a-_[i].a);
			jiao.y=_[s[top-1]].a*jiao.x+_[s[top-1]].b;
			zuobiao mininf,maxinf;
			mininf.x=-999999.9; //注意不能取太大。否则造成误差。
			mininf.y=_[s[top-2]].a*mininf.x+_[s[top-2]].b;
			maxinf.x=999999.9;
			maxinf.y=_[s[top-2]].a*maxinf.x+_[s[top-2]].b;
			if((mininf-maxinf)*(mininf-jiao)<eps){ //小于或等于。因为观察样例发现只能看到一个点也算被挡住。
				top--;
			}else{
				break;
			}
		}
		s[top++]=i;
	}
	for(i=0;i<top;i++){
		kkksc03[_[s[i]].id]=1; //还原原来的编号。
	}
	for(i=0;i<n;i++){
		if(kkksc03[i]){
			cout<<i+1<<" ";
		}
	}
	return 0;
}
```

---

## 作者：Chenyichen0420 (赞：0)

## 思路分析

静态凸壳维护板子题。

我们注意到相同的斜率的直线一定只有截距最高的那条直线可能被看到，因此我们假定所有直线的斜率不同。

我们观察到在一个向下凸的凸壳中，直线的斜率从左向右依次递增。这启示我们在按照斜率排完序后使用单调栈维护整个凸壳，并通过交点等方式排除掉末尾的不合法线段。

思路就是这样。代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct vecor {
	double x, y; int id; vecor(double xi = 0, double yi = 0) :x(xi), y(yi), id(0) {}
	friend istream& operator>>(istream& l, vecor& r) { return l >> r.x >> r.y; }
	inline bool operator<(const vecor& r) const { return x != r.x ? x < r.x : y < r.y; }
}l[50005], s[50005];
int n, sc, m;
inline vecor inter(const vecor& l, const vecor& r) {
	double x = (r.y - l.y) / (l.x - r.x);
	return vecor(x, l.x * x + l.y);
}
signed main() {
	ios::sync_with_stdio(0); cin >> n;
	for (int i = 1; i <= n; ++i) cin >> l[i], l[i].id = i;
	sort(l + 1, l + n + 1); l[n + 1].x = 11451419;
	for (int i = 1; i <= n; ++i) 
		if (l[i].x != l[i + 1].x) l[++m] = l[i];
	n = m;
	for (int i = 1; i <= n; ++i) {
		while (sc > 1 && inter(l[i], s[sc - 1]).x >= inter(l[i], s[sc]).x) sc--;
		s[++sc] = l[i];
	}
	sort(s + 1, s + sc + 1, [&](const vecor& l, const vecor& r) {return l.id < r.id; });
	for (int i = 1; i <= sc; ++i) cout << s[i].id << " ";
}
```

---

## 作者：PigNotFound (赞：0)

首先，所有可见的直线都是半平面交要用到的直线。形状为一个下凸壳。如图中，蓝，绿，红三条直线构成半平面交。可以看到的直线就是蓝，绿，红三条直线。

![](https://cdn.luogu.com.cn/upload/image_hosting/cj2ejvov.png)

所以求出半平面交就可以了。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const ll Pig = 5e5 + 10;

ll k[Pig], b[Pig], id[Pig]; 

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    vector<ll> st;
    ll n;
    cin >> n;
    for (ll i = 0; i < n; i++) {
    	cin >> k[i] >> b[i];
    	id[i] = i;
	}
	sort(id, id + n, [](ll x, ll y){return (k[x] == k[y]) ? (b[x] > b[y]) : (k[x] < k[y]);});
	for (ll i = 0; i < n; i++) {
		if (i and k[id[i]] == k[id[i - 1]])
			continue;
		//cout << id[i] + 1 << "\n";
		while (st.size() >= 2 and ((b[id[i]] - b[st[st.size() - 1]]) * (k[st[st.size() - 2]] - k[st[st.size() - 1]])) <= 
								  ((b[st[st.size() - 2]] - b[st[st.size() - 1]]) * (k[id[i]] - k[st[st.size() - 1]])))
			st.pop_back();
		st.emplace_back(id[i]);
		/*for (ll i : st)
			cout << i + 1 << " ";
		cout << "\n";*/
	}
	//while (st.size() >= 2 and (ld(b[st[0]] - b[st[st.size() - 2]]) / ld(k[st[st.size() - 2]] - k[st[0]]) * k[st[0]] + b[st[0]]) >= (ld(b[st.back()] - b[st[st.size() - 2]]) / ld(k[st[st.size() - 2]] - k[st.back()]) * k[st.back()] + b[st.back()]))
	//	st.pop_back();
	sort(st.begin(), st.end());
	for (ll i : st)
		cout << i + 1 << " ";
    return 0;
}
/*
4
3 1
2 -1
-5 -3
1 3
*/
/*
2
0 1
0 2
*/
``
```

---

## 作者：NTT__int128 (赞：0)

# P3194 [HNOI2008] 水平可见直线 题解
首先，我们发现，最终的答案的直线的斜率从左到右是递增的，考虑按斜率从小到大排序。

然后，用一个栈记录答案。

考虑如何判断一条直线是否不可见。

对于三条直线 $l_1:y=k_1x+b_1,l_2:y=k_2x+b_2,l_3:y=k_3x+b_3$，假设 $k_1>k_2>k_3$，则当 $l_1\cap l_2$ 在 $l_2\cap l_3$ 的左边时，$l_2$ 不可见。

时间复杂度：$\Theta(n\log n)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
using db=double;
const int N=5e4+5;
int n,st[N],tp,a[N],cnt;
struct node{
	int k,b,id;
	bool operator<(const node&a)const{
		return (k!=a.k?k<a.k:b>a.b);/*先按斜率从小到大排序，斜率相同的再按常数从大到小排序*/
	}
}l[N];
db inter(int x,int y){/*计算交点（intersection的简写）*/
	return 1.0*(l[x].b-l[y].b)/(l[y].k-l[x].k);
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>l[i].k>>l[i].b,l[i].id=i;
	sort(l+1,l+n+1);
	for(int i=1;i<=n;i++){
		if(i>1&&l[i].k==l[i-1].k)/*斜率相同，跳过（因为按常数从大到小排过序了）*/
			continue;
		while(tp>1&&inter(st[tp],i)<=inter(st[tp],st[tp-1]))
			tp--;
		st[++tp]=i;/*压入栈中*/
	}
	while(tp)
		a[++cnt]=l[st[tp--]].id;
	sort(a+1,a+cnt+1);
	for(int i=1;i<=cnt;i++)/*输出答案*/
		cout<<a[i]<<' ';
	return 0;
}
```

---

## 作者：2021changqing52 (赞：0)

# 思路：
先对直线排序，先按一次项从大到小排，再按常数项从大到小排，最后用单调栈，逐个压入，每次把栈顶被遮住的直线弹出再入栈。记得对序号从小到大排序再输出。

注意平行的情况，后面的就直接不入栈，因为会被前一个遮住。
# Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e4+5;
int s[N],m,n,p[N];
struct f{
  int a,b,i;
}a[N];//i表示在原来顺序中的位置
bool cmp(f a,f b){
  if(a.a!=b.a)return a.a>b.a;
  else return a.b>b.b;
}//比较函数
double l(int i,int j){
  return 1.0*(a[i].b-a[j].b)/(a[j].a-a[i].a);
}//斜率
int main(){
	cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i].a>>a[i].b;
        a[i].i=i;
    }
	sort(a+1,a+1+n,cmp);
    for(int i=1;i<=n;i++){//单调栈
        if(a[i].a==a[i-1].a&&i!=1)continue;//平行时，前面的在后面的上方
        while(m>1&&l(s[m],i)>=l(s[m],s[m-1]))m--;//弹出
        s[++m]=i,p[m]=a[i].i;//进栈
    }
	sort(p,p+m+1);
    for(int i=1;i<=m;i++)cout<<p[i]<<" ";
}
```


---

## 作者：SAMSHAWCRAFT (赞：0)

NMOI 之前赶紧学一下子计算几何，这个题明明在[计算几何 - 从入门到跳楼](https://www.luogu.com.cn/training/16408#problems)题单里面但是好像没多少人写的样子。

关键词：凸包。

原题面比较形式化，我们直观地理解一下，就是有若干直线，求出在上面露出来的所有直线的编号。我们在 Geogebra 上随便画一画图，看看有什么规律：

![](https://cdn.luogu.com.cn/upload/image_hosting/1xdi06zt.png)

蓝色的直线都是要求的直线，直线的标号在图上直线最左侧有标注，直线 $f,g,h$ 都露了出来，而 $i,j$ 没有（图片如果看不清楚请右键在新标签页中打开图片）。

容易发现，对于平行的两条直线，$b$ 小者会被 $b$ 大者完全遮住，如 $g,i$ 这一对直线，两者平行，而直线 $g$ 完全遮住了 $i$；而对于不平行的直线，我们可以分析一下直线 $f,g,h$、$f,h,i$、$f,h,j$ 这三组直线。我们会发现因为 $f,h$ 的交点位于 $g$ 下方，并且 $g$ 的斜率介于 $f,h$ 之间，所以 $g$ 就不会被 $f,h$ 完全遮住，而 $f,h$ 的交点位于 $i$ 上，交点位于 $j$ 上方，并且 $i,j$ 的斜率都介于 $f,h$ 之间，因而 $i,j$ 都被 $f,h$ 完全遮住。

分析到这里，如果在考场上就可以直接猜结论了，但是我们平时做题还是证明一下比较好。如果一条直线没被另外两个直线遮住的话，只要存在一个点同时在这两个直线上方就行了。下面是一个高中生尽可能严谨的证明。

已知：有三条直线 $l_1:y=k_1x+b_1,l_2:y=k_2x+b_2,l_3:y=k_3x+b_3,k_1<k_2<k_3$，记$Q(x_Q,y_Q)=l_1\cap l_3$。

求证：$\exist P(x_P,y_P)\in l_2,k_1x_P+b_1<y_P\land k_3x_P+b_3<y_P$ 的充分必要条件是 $\frac{b_3-b_1}{k_3-k_1}<\frac{b_2-b_1}{k_2-k_1}\land \frac{b_3-b_1}{k_3-k_1}>\frac{b_2-b_3}{k_2-k_3}$。

证明：记 $F(x)=(k_2-k_1)x+(b_2-b_1)(x\in(-\infty,x_Q])$，因为 $k_2>k_1$ 所以 $F(x)_{\max}=F(x_Q)$，即 $x_P=x_Q$ 时，$y_P-(k_1x_P+b_1)$ 最大；同理 $x_P=x_Q$ 时，$y_P-(k_3x_P+b_3)$ 最大。若 $x_P=x_Q$ 时 $y_P-y_Q>0$，则 $\exist P_0(x_Q,k_2x_Q+b_2),k_2x_Q+b_2>y_Q$ ，所以 $\exist P(x_P,y_P)\in l_2,k_1x_P+b_1<y_P\land k_3x_P+b_3<y_P$ 的充分条件是 $x_P=x_Q$ 时 $y_P-y_Q>0$。

若存在异于 $P_0(x_Q,k_2x_Q+b_2)$ 的一点 $P(x_P,k_2x_P+b_2)$ 在 $l_1,l_3$ 的上方，则 $(k_2y_P+b_2)-(k_1y_P+b_1)>0\land(k_2y_P+b_2)-(k_3y_P+b_3)>0$，所以 $k_2x_Q+b_2-y_Q>0$，所以 $\exist P(x_P,y_P)\in l_2,k_1x_P+b_1<y_P\land k_3x_P+b_3<y_P$ 的必要条件是 $x_P=x_Q$ 时 $y_P-y_Q>0$。

因此证明原命题等价于证明 $x_P=x_Q$ 时 $y_P-y_Q>0$ 的充分必要条件是 $\frac{b_3-b_1}{k_3-k_1}<\frac{b_2-b_1}{k_2-k_1}\land \frac{b_3-b_1}{k_3-k_1}>\frac{b_2-b_3}{k_2-k_3}$。下证此命题：$k_1x_Q+b_1=k_3x_Q+b_3\Leftrightarrow x_Q=\frac{b_3-b_1}{k_3-k_1}$，$\frac{b_3-b_1}{k_3-k_1}<\frac{b_2-b_1}{k_2-k_1}\Leftrightarrow k_1\frac{b_3-b_1}{k_3-k_1}+b_1< k_2\frac{b_3-b_1}{k_3-k_1}+b_2\Leftrightarrow k_1x_Q+b_1< k_2x_Q+b_2$ ；同理 $\frac{b_3-b_1}{k_3-k_1}>\frac{b_2-b_1}{k_2-k_1}\Leftrightarrow k_3x_Q+b_3> k_2x_Q+b_2$。命题证毕。

由此，我们确定了三条直线 $l_1:y=k_1x+b_1,l_2:y=k_2x+b_2,l_3:y=k_3x+b_3,k_1<k_2<k_3$ 均可以露出的充分必要条件是 $\frac{b_3-b_1}{k_3-k_1}<\frac{b_2-b_1}{k_2-k_1}\land \frac{b_3-b_1}{k_3-k_1}>\frac{b_2-b_3}{k_2-k_3}$。

我们简记这三条直线为 $(k_1,b_1),(k_2,b_2),(k_3,b_3)$，则这三个有序数对对应的点组成了一个上凸包，本题转化为求上凸包的问题，跑一次 Andrew 算法即可。

另附：[提交记录](https://www.luogu.com.cn/record/74964677)，想要完整代码可以找我。

---

## 作者：约修亚_RK (赞：0)

我不知道凸包是什么玩意儿，我也没有用栈，反正这题我写的好像是二分...

具体来说，按第一关键字斜率升序，第二关键字截距降序排序。

第一条直线(a)和最后一条直线(b)显然是可见的嘛。

然后算出它们的交点(x1,y1)，再从(a,b)范围内 -- 因为斜率显然在这个范围内 -- 查找在x1时y最大的一条直线(c)，这个也可见。

分别把a和c，c和b拖出来重复如上操作，然后就没有然后了。


[cpp]
/\* P3194

\* Au: SJoshua

\*/





```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
struct info {
    int id, a, b;
    bool operator < (const info &p) const {
        return a == p.a ? b > p.b : a < p.a;
    }
} line[50001];
int n;
bool enable[50001];
void search(int x, int y) {
    if (y - x < 2) {
        return;
    }
    double px = (double)(line[y].b - line[x].b) / (line[x].a - line[y].a);
    double py = line[x].a * px + line[x].b;
    int top = x;
    for (int i = x+1; i < y; i++) {
        double ty = line[i].a * px + line[i].b;
        if (py < ty) {
            py = ty;
            top = i;
        }
    }
    if (top != x) {
        enable[line[top].id] = true;
        search(x, top);
        search(top, y);
    }
}
int main(void) {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        line[i].id = i;
        scanf("%d %d", &line[i].a, &line[i].b);
    }
    sort(line+1, line+n+1);    
    enable[line[1].id] = enable[line[n].id] = true;
    search(1, n);
    for (int i = 1; i <= n; i++) {
        if (enable[i]) {
            printf("%d ", i);
        }
    }
    return 0;
}
```
[/cpp]



---


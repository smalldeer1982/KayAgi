# [HAOI2014] 穿越封锁线

## 题目描述

某敌占区是一个封闭的多边形，用相邻的顶点集合 $P_1(x_1,y_1)$，$P_2(x_2,y_2)$，$\cdots$，$P_n(x_n,y_n)$ 表示。

我方侦察员 ZDM-007 要穿越敌占区的封锁线，为了安全起见，ZDM-007 行走的路线垂直于 X 坐标轴，从南向北穿越。

现在已知侦察员 ZDM-007 所处的位置，你能算出他在穿越封锁线时，其路线在敌占区内的总长度？

![](https://cdn.luogu.com.cn/upload/pic/5207.png)


## 说明/提示

【约束条件】

$3\le n\le 50,0\le x_i,y_i\le1000,0\le X \le1000,-100\le Y < 0$。

## 样例 #1

### 输入

```
7 
0 1 
2 0
4 1
2 2 
4 3 
2 4 
0 3 
3 -1```

### 输出

```
2```

## 样例 #2

### 输入

```
4
10 100
10 0
100 0
100 100
100 -80```

### 输出

```
0```

# 题解

## 作者：Tracy_Loght (赞：3)

又有又改了改，可以放心食用了，滑稽。

发现有些的方有些绕，请遇见了记得提醒我一下。

简单数学题，前置知识：一次函数，~~电脑~~。

## 思路：

**注：侦察员位置的纵坐标的那一列统称为目标列。**

先注意到什么，目标列是不变的，封锁区也是不变的，所以我们大可以开一个数组，只记录下目标列与封锁区上的点。

注意精度。

主要思路就上面的了。

---

一步步开始算，首先如何判断目标列与封锁区边的交点有什么。

肯定一次函数啊，但是不好玩的是目标列可能与封锁区的边重合。

得了，先算一次函数吧，不会的看这里：[度娘](https://baike.baidu.com/item/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/1653577#:~:text=%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0%E6%98%AF%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E4%B8%80%E7%A7%8D%EF%BC%8C%E4%B8%80%E8%88%AC%E5%BD%A2%E5%A6%82y%3Dkx%2Bb%EF%BC%88k%EF%BC%8Cb%E6%98%AF%E5%B8%B8%E6%95%B0%EF%BC%8Ck%E2%89%A00%EF%BC%89%EF%BC%8C%E5%85%B6%E4%B8%ADx%E6%98%AF%20%E8%87%AA%E5%8F%98%E9%87%8F%20%EF%BC%8Cy%E6%98%AF%E5%9B%A0%E5%8F%98%E9%87%8F%E3%80%82%20%E7%89%B9%E5%88%AB%E5%9C%B0%EF%BC%8C%E5%BD%93b%3D0%E6%97%B6%EF%BC%8Cy%3Dkx%EF%BC%88k%E4%B8%BA%E5%B8%B8%E6%95%B0%EF%BC%8Ck%E2%89%A00%EF%BC%89%EF%BC%8Cy%E5%8F%AB%E5%81%9Ax%E7%9A%84,%E6%AD%A3%E6%AF%94%E4%BE%8B%E5%87%BD%E6%95%B0%20%EF%BC%88direct%20proportion%20function%EF%BC%89%E3%80%82)。

```cpp
int RFT(double x,double y,double x_,double y_,double m)//已知的两个点，m为目标列
{
	double k=0,b=1,k_=0,b_=1;
	double x1=x,y1=y;
	k=x*x_;y=y*x_;b=b*x_;
	k_=x_*x;y_=y_*x;b_=b_*x;
	b=(y_-y)/(b_-b);k=(y1-b)/x1;
	return k*m+b;
}
```
**(假设只考虑有斜率的情况)。**

然后具体一点，判断目标列上所有的点**是否**在封锁区内。

这个很好想，从最后一个与目标点的交点来看，它以前的到前一个与目标点的交点中一定要计算，然后一段不计算，一段计算，一段计算，一段不计算。

---

呃の解释不对头。

再解释一下，对于一个多边形，将其切片一下，然后转过来：

![](https://cdn.luogu.com.cn/upload/image_hosting/epcmokt1.png)

再对着每一个交点一看，从上到下编号，答案就是：

$$
\sum_{i = 1}^\frac{n}{2}\ A_{2i}-A_{2i-1}
$$

## 代码：
```cpp
#include<bits/stdc++.h>
#define ft __float128   //我曾经一度怀疑过精度的问题
#define ld long double
using namespace std;
ft kl[10001],jl;
int ans,n,l,r;
struct {
	int x,y;
} o[51]; //储存每一个点
ft RFT(ft x,ft y,ft x_,ft y_,ft m) {   //已知的两个点的坐标，m 为目标列
	if(x>x_)swap(x,x_),swap(y,y_);     //在调用这个函数时，请保证这两点构成的直线经过直线 y=m
	if(y==y_) return y;
	else if(x==0) { //特判斜率 0 的情况
		ft k=0,b=1; //但是感觉没用 
		if(x_==0) return 0;
		else {
			b=y;
			k=(y_-b)/x_;
			return k*m+b;
		}
	} else {     //正常算
		ft k=0,b=1,k_=0,b_=1,x1=x,y1=y;//计算交点 
		k=x*x_; y=y*x_; b=b*x_;
		
		k_=x_*x; y_=y_*x; b_=b_*x;
		b=(y_-y)/(b_-b);
		k=(y1-b)/x1;
		return k*m+b;
	}
}
int main() {
	ios::sync_with_stdio(0);
	std::cin.tie(0);
	std::cout.tie(0);
	cin>>n;
	for(int i=1; i<=n; i++) cin>>o[i].x>>o[i].y;
	cin>>l>>r;
	o[0].x=o[n].x;//因为这个是一个多边形，要在首尾连边
	o[0].y=o[n].y;
	for(int i=1; i<=n; i++) {
		int il=min(o[i-1].x,o[i].x);
		int xr=max(o[i].x,o[i-1].x);
		if(o[i-1].x==l&&o[i].x!=l) kl[++ans]=o[i-1].y;   //对于每一种情况分点判断
		else if(o[i-1].x!=l&&o[i].x==l) kl[++ans]=o[i].y;
		else if(il<l&&l<xr) {
			ft as=RFT(o[i-1].x,o[i-1].y,o[i].x,o[i].y,l);
			kl[++ans]=as;
		}
	}
	std::sort(kl+1,kl+ans+1);
	for(int i=2; i<=ans+1; i+=2) { //计算在封锁区内的值
		if(kl[i]!=0) jl=jl+kl[i]-kl[i-1];
		//注意为空的情况，怎么来的就不知道了，太久了忘了 
	}
	int daan=jl/1;//朴素的去小数方式 
	cout<<daan;
	return 0;
}
```
点个赞呗。

[过了哩](https://www.luogu.com.cn/record/164132389)，自认为非常好理解，但是代码不好写。

---


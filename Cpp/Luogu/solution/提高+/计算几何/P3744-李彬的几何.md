# 李彬的几何

## 题目背景

李彬有一个凸多边形(不知道什么是凸多边形的同学可以查百度百科)P。


## 题目描述

P 有 n 个顶点p1,p2 ,p3 ,…,pn 。顶点 pi在 2 维平面上的坐标为( xi,yi )。这些顶点是按照顺时针顺序给出的。

李彬可以指定一个实数 D，然后将每个顶点最多移动 D 个单位距离。现在李彬想知道，如果他想使这个凸多边形不再是凸多边形，那么 D 的最小值是多少。


## 说明/提示

对于 100%的数据，4<=n<=1000 ,-10^9<=xi,yi<=10^9。


## 样例 #1

### 输入

```
4
0 0
0 1
1 1
1 0
```

### 输出

```
0.3535533906
```

## 样例 #2

### 输入

```
6
5 0
10 0
12 -4
10 -8
5 -8
3 -4```

### 输出

```
1.0000000000
```

# 题解

## 作者：Richard1211 (赞：10)

~~这题这其实是一个几何问题~~
## 前置知识
你需要知道什么是[凸多边形](https://baike.baidu.com/item/%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2)和[凹多边形](https://baike.baidu.com/item/%E5%87%B9%E5%A4%9A%E8%BE%B9%E5%BD%A2)

你还需要知道求三角形面积的**海伦公式**：已知一个一般三角形的三边 $a$,$b$,$c$ 然后令 $p=(a+b+c)/2$，则三角形的面积
$$s=\sqrt{p(p-a)(p-b)(p-c)}$$


------------

**海伦公式**的证明：

设三角形的三边 $a$,$b$,$c$ 的对角分别为 $A$,$B$,$C$ 则根据余弦定理有

$$\cos(C) = \frac{a^2+b^2-c^2}{2ab}$$
从而有
$$\sin(C) = \sqrt{1-\cos^2(C)} = \frac{ \sqrt{-a^4 -b^4 -c^4 +2a^2b^2 +2b^2c^2 +2c^2a^2} }{2ab}$$
因此三角形的面积 $S$ 为

$$\begin{aligned}
 &\; \; \; \; \;  S_{triangel} \\
 &=  \frac{1}{2}ab \sin(C) \\
 &= \frac{1}{4}\sqrt{-a^4 -b^4 -c^4 +2a^2b^2 +2b^2c^2 +2c^2a^2} \\
 &= \frac{1}{4}\sqrt{(2ab)^2-(a^2+b^2-c^2)^2} \\
 &= \frac{1}{4}\sqrt{(2ab+a^2+b^2-c^2)(2ab-a^2-b^2+c^2)} \\
 &= \frac{1}{4}\sqrt{[(a+b)^2-c^2)][c^2-(a-b)^2]} \\
 &= \frac{1}{4}\sqrt{(a+b+c)(a+b-c)(a-b+c)(-a+b+c)} \\
 &= \frac{1}{4}\sqrt{2p(2p-2a)(2p-2b)(2p-2c)} \\
 &= \sqrt\frac{1}{16}\sqrt{16p(p-a)(p-b)(p-c)} \\
 &= \sqrt{p(p-a)(p-b)(p-c)}
\end{aligned}$$
其中 $p=(a+b+c)/2$

------------

最后你要知道**勾股定理**~~（这个应该没人不知道吧）~~

给你一个直角三角形，以及直角三角形的两条直角边 $a$,$b$ 和斜边 $c$ 则 $a$,$b$,$c$ 一定满足
$$a^2+b^2=c^2$$
## 解题思路
我们不难想到，让一个凸多边形变成不是凸多边形，其实就是让一个凸多边形变成凹四边形，具体怎么转换呢？我们不妨看一张图

![](https://cdn.luogu.com.cn/upload/image_hosting/v0wgondp.png?x-oss-process=image/resize,m_lfit,h_170,w_225) 

可以看出，让凸四边形变成凹四边形的方法就是把其中一个顶点的旁边两个点固定，然后把这个顶点移动一定的距离，而题目让我们求的距离就是这个顶点移动的距离的最小值 $d$，怎么求呢？

想要让 $d$ 最小，其实只要在每一个顶点都求一次移动这个顶点所需最小的  $d$ ，然后把各个 $d$ 中间最小的取出来就是答案，现在我们就只需要思考怎么求移动一个顶点的 $d$ 即可。

不妨设我们要移动的顶点是 $A$，发现想要 $d$ 最小其实只需要把凸多边形变成一个 $∠A$ 刚好等于180°的内角即可，我们还知道，直线外一点到直线的距离最小的是垂线段，于是又可以得到下面这张图的移动方式

![](https://cdn.luogu.com.cn/upload/image_hosting/lnv08i5s.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

此时图中的 $d$ 就是移动 $A$ 点时使凸多边形变成凹多边形所需移动的最小距离。

接下来我们看看怎么算 $d$

首先题目已经告诉了我们每个点的坐标，于是我们就可以用两点之间的距离公式
$$dis(A,B)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$$

(其中 $x_1$,$y_1$ 是 $A$ 的横纵坐标,$x_2$,$y_2$ 是 $B$ 的横纵坐标)

来计算边 $AB$,$BE$,$AE$ 的长度


------------

先来证明一下两点之间的距离公式，首先我们选择平面上的任意两个点  $A(x_1,y_1)$ 和 $B(x_2,y_2)$

![](https://cdn.luogu.com.cn/upload/image_hosting/m2yvkh17.png)

然后我们可以做几条辅助线，如下图
![](https://cdn.luogu.com.cn/upload/image_hosting/t7wov5fi.png)

我们做出一个直角三角形，然后根据给定的坐标可以算出两条直角边的长度是$|x_1-x_2|$ 和 $|y_1-y_2|$

然后我们要求的是红色边的长度，我们就可以使用勾股定理

$$dis(A,B)^2=|x_1-x_2|^2+|y_1-y_2|^2$$

进一步化简即可得到

$$dis(A,B)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$$

![](https://cdn.luogu.com.cn/upload/image_hosting/39okip38.png)

------------

然后我们使用三角形的面积公式
$$S_{triangel}ABE=\frac{d\times BE}{2}$$
进一步变形我们得到
$$d=\frac{2S_{triangel}ABE}{BE}$$
我们令 $p=(AB+BE+AE)/2$ 然后使用海伦公式可以得到
$$d=\frac{2\sqrt{p(p-AB)(p-BE)(p-AE)}}{BE}$$
而且题目说我们不仅仅只能移动一个点，可以移动多个，只要范围都在 $d$ 以内，于是我们可以进一步得到更小的 $d_{min}$ 如下图

![](https://cdn.luogu.com.cn/upload/image_hosting/7soe9gk5.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

我们可以看到，在最优的情况下，$d_{min}$ 可以缩小到原来的一半，于是我们可以得到最终的答案

$$d=\frac{\sqrt{p(p-AB)(p-BE)(p-AE)}}{BE}$$

接下来的步骤就简单了，照着公式写代码即可，但还要注意一些细节，比如这题在算两点之间的距离 $dis(A,B)$ 时有用到平方，会爆 **int**，所以要开 **long long** ，而且有小数要用 **double** ~~（这个应该没人会错吧）~~，这样写出来的代码就没问题了。

还有一些注释可以见代码。
#  _Code_ 
```cpp
#include <bits/stdc++.h>
using namespace std;
template<class T>T Min(register T a,register T b){
	return a<b?a:b;
}
template<class T>T Max(register T a,register T b){
	return a>b?a:b;
}
template<class T>T Abs(register T a){
	return a>0?a:-a;
}
template<class T>void Swap(register T &a,register T &b){
	T t=a;
	a=b;
	b=t;
}
//更快的min,max,abs,swap
const long long N=100100;
long long X[N],Y[N];
double dis(long long x,long long y){
    return sqrtl((X[x]-X[y])*(X[x]-X[y])+(Y[x]-Y[y])*(Y[x]-Y[y]));//算平面上两个点的距离
}
double Dis(long long x,long long y,long long z){//算把Y点移动d距离变成凹多边形时d的最小值
    double dx=dis(x,y);
    double dy=dis(y,z);
    double dz=dis(z,x);
    double p=(dx+dy+dz)/2.0;//半周长p
    double s=sqrtl(p*(p-dx)*(p-dy)*(p-dz));
    return s*1.0/dz/**2.0*/;//由于题目说每个点都能移动d,所以可以进一步缩短一半,原来推出来的公式中的*2就和/2抵掉了,所以就不用*2了
}
int main(){
    long long n;
    scanf("%lld",&n);
    for(long long i=1;i<=n;i++){
        scanf("%lld%lld",&X[i],&Y[i]);
    }
    double ans=Min(Dis(n,1,2),Dis(n-1,n,1));
    for(long long i=2;i<=n-1;i++){
        ans=Min(ans,Dis(i-1,i,i+1));
    }
    printf("%.10lf\n",ans);
	return 0;
}
```
于是这题就做完了。

~~另外，安利一下[蒟蒻的博客](https://www.luogu.com.cn/blog/RichardAkIOI/)~~

~~求管理员大大通过qwq~~

---

## 作者：silverxz (赞：6)

内啥。。既然现在还没有题解（其实是没有多少提交），我就先发一个。。

首先，看见这个题，身为蒟蒻的我第一想法是**枚举**。枚举出任意三个点A, B, C，那么很显然，**当点B移动到直线AC另一侧时，这个多边形凹进去了。**（我不是为了迷信起名叫AC的，真的不是！你们要相信我！）

那么这种情况的答案D是多少呢？想让B移动到AC的另一侧，那么它至少要移动的距离，应该是点B到直线AC的距离。可是答案并不是这个距离，而是应该除以二！为什么呢？因为由题意可知，每个点都可以移动不超过D的距离。那么，我只要让直线AC（即点A和点C）向B方向移动，而B向直线AC方向移动，才能得到最小的D，也就是**B到AC距离的二分之一**。

那么问题就转化成了枚举A，B，C，计算出B到AC的距离，最小的那个距离再除以二，就是最终的答案。

注意，为什么这样是正确的呢？毕竟由题意，每个点都是可以动的，而我们的计算却把其它点的移动忽略了。这是因为，不论其它点如何移动，都不会对我们现在枚举的三个点产生影响。而这样会不会造成漏解呢？并不会，因为其它点的移动情况我们会在其它地方枚举到。

那么接下来就是实现了。然而我们尴尬地发现：我们并不能做到枚举三个点——会迎来我们最讨厌的——TLE，这可能意味着我们需要更改算法。不过幸运的是，我们并不需要对思路进行什么修改（要不然前面我不就白说了。。），而是对枚举进行一定的优化——一个小**贪心**——就可以。

**对于一个点B，我们只需要枚举与它相邻的两个点作为A和C就可以！**

这又是为什么呢？我们很容易通过反证法得知：不存在其他直线，比直线AC到点B的距离更短。不熟悉反证法也没有关系，我们可以对图进行观察得到这一结论。

这就大大减少了我们的工作量，接下来我们就要找到和点B相邻的点。然后，我们幸运地发现：我们不必自己寻找了。这是因为出题人的良心——它的点是按照顺时针给的。我们可以把每个点存储在一个结构体数组里，然后直接按顺序枚举，因为下标为i的点，它相邻的点是i-1和i+1。

于是我们可以看到：TLE的风险不存在了。因为我们只需要枚举A，B，C中任意一个点即可，复杂度成功将至O（n）！（‘！’号只是感叹，请不要将其理解为阶乘）

最后的关键就是如何求点到直线的距离。我个人是求出叉积再除以边长——相当于平行四边形面积除以底。方法来源于刘汝佳蓝书。

AC代码如下（亲测0ms，毕竟O（n）复杂度）

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>

#define INF 1000000000.0

using namespace std;

struct Point {
    double x, y;  //横纵坐标
    Point (double x = 0, double y = 0) : x(x), y(y) {}
};
Point point[1010];

Point operator - (Point x, Point y) {
    return Point(x.x-y.x, x.y-y.y);
}

double Cross (Point x, Point y) {
    return fabs(x.x*y.y - x.y*y.x);
}

double Len (Point x, Point y) {
    return sqrt((x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y));
}

double solve (int i) {     //计算点到直线距离，i即A，i+1即B，i+2即C
    Point x1 = point[i]-point[i+2];
    Point x2 = point[i]-point[i+1];
    return Cross(x1, x2)/Len(x1, Point(0, 0));
}

int main () {
    int n;
    double ans = INF;
    scanf ("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf ("%lf %lf", &point[i].x, &point[i].y);
    }
    point[n] = point[0];     //由于要枚举下标n-1，所以把n和n+1也填上，避免取模
    point[n+1] = point[1];
    for (int i = 0; i < n; i++) {   //枚举点A
        ans = min(ans, solve (i));
        //printf ("%.10lf\n", ans/2);  用于调试的代码
    }
    printf ("%.10lf\n", ans/2);
    return 0;
}
```

---

## 作者：RAY091016 (赞：5)

### 1. 题意解释

给出一个凸多边形各点的坐标，求移动若干个点使此凸多边形变成非凸多边形的最小移动距离。

### 2. 思路

~~这是一道很水的数学题。~~

我们知道，在凸多边形中，每个顶点与另外两个顶点相连（显然，不知道的重学初等几何）。

而根据凸多边形的定义，这三点显然是不共线的。

所以假如我们让这三点共线，这个多边形即不再是凸多边形。

为方便，我们记两边的两点分别为 $A$ 和 $B$，记与 $A$ 和 $B$ 都相连的点为 $C$。

我们的目标也就是把 $C$ 移动到线段 $AB$ 上。

容易知道，我们过 $C$ 作 $AB$ 的垂线 $CH$ 与 $AB$ 相交与点 $H$，则 $CH$ 是移动的最小距离。

$AB$ 的长度可以根据两点间距离公式求出，而我们知道 $S_{ABC}=\dfrac{AB\times CH}{2}$，所以求出 $S_{ABC}$ 即可。

海伦公式、秦九韶公式、割补法、行列式法随你选，爱用哪个用哪个。

求出 $CH$ 后，仍然不是最终的答案。

由于我们可以不止移动一个点，我们可以让 $AB$ 整体向上移动 $\dfrac{CH}{2}$ 的距离，$C$ 点也移动 $\dfrac{CH}{2}$ 的距离，则 $C$ 点仍落在 $AB$ 上。

因此最终答案为 $\dfrac{CH}{2}$ 的最小值。

由于题目保证点按照顺时针顺序给出，因此处理并不难，在此不多赘述。

### 3. 代码实现

记得多开几个 double。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct data{
	double x,y;
}a[1010];
double ans=1e9;
double calc(int p,int q,int j){
	return abs(a[p].x*a[q].y+a[q].x*a[j].y+a[j].x*a[p].y-a[p].x*a[j].y-a[q].x*a[p].y-a[j].x*a[q].y)/2;
}
double dist(int p,int q){
	return sqrt((a[p].x-a[q].x)*(a[p].x-a[q].x)+(a[p].y-a[q].y)*(a[p].y-a[q].y));
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].x>>a[i].y;
	}
	a[n+1].x=a[1].x,a[n+1].y=a[1].y;
	a[0].x=a[n].x,a[0].y=a[n].y;
	for(int i=1;i<=n;i++){
		double S=calc(i-1,i,i+1);
		double l=dist(i-1,i+1);
		double d=S/l;
		ans=min(ans,d);
	}
	cout<<ans;
    return 0;
}
```

---

## 作者：_Diu_ (赞：3)

这一题我们可以先了解一下关于题目中的一些概念

$dalao$可以直接跳过

## 凸多边形与凹多边形

凸多边形：就是指一个多边形的每一个内角都小于$180$度的的多边形

凹多边形：就是指至少有一个内角大于$180$度的多边形

好了，接着回归一下题目

让一个凸多边形变成一个凹多边形，让我们看看到底是怎么变得

## 转换过程

![](https://cdn.luogu.com.cn/upload/image_hosting/d4mcsmpo.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

我们随便取一点，固定两个邻点，把这个点网多边形内部拖

这样的话我们~~美丽的~~多边形就完成了一次转变

而这里的一点是可以更换的，所对应的移动距离就是题目中要求的d值

接下来问题来了，怎样使$d$值最小呢？

众所周知，垂线段最短，也就是一点到相邻两点所连成直线的距离

怎么求点到直线的距离呢？

好吧，我也不会，所以只能用笨的方法了

也就是求出由这个点和两个邻点所组成的三角形的高，~~但容易理解啊~~

我们可以先用勾股定理求出三边之长

再用海伦公式求面积

顺便科普下

## 海伦公式


$p=(a+b+c)/2$

$s=\sqrt{p*(p-a)(p-b)(p-c))}$

其中$a,b,c$分别表示三条边的长，而$p$表示周长的一半，$s$表示面积


最后用面积和对应边之长求高

但是这一题是每一个点都可以移动d的距离

所以不仅是目标点可以向中间移动，那么两个邻点也是可以向外移动的

![](https://cdn.luogu.com.cn/upload/image_hosting/29faav50.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

(有点不包尊)

#### 所以最后算出来的距离要除以2

又因为实际上这样是还差一点点就是凹多边形，但是本体为$SJ$，可以有一点误差，所以这里处理不处理问题不大

细节上还是有很多问题的，比如精度问题还有**一定要开longlong**

上代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1010;
int n,x[N],y[N];
double ans;
double dis(int a,int b){
	return sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));//两点距离 
}
double getting(int u,int v,int w){//uv是邻点，w是目标点 
	double xx=dis(u,v);
	double yy=dis(v,w);
	double zz=dis(u,w);
	double p=(xx+yy+zz)/2.0;//海伦公式 
	double s=sqrt((p-xx)*(p-yy)*(p-zz)*p);//海伦公式利用三边求面积 
	return (double)s*1.0/xx;//这里本来要*2，但因为后面还要除回去，所以这里没做处理 
}
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&x[i],&y[i]);
	}
	ans=min(getting(n,2,1),getting(1,n-1,n));
	for(int i=2;i<n;i++)ans=min(ans,getting(i-1,i+1,i));
	printf("%.10lf",ans);
}
```

### 拿下！！！

---

## 作者：mr_pete_000 (赞：3)

# 一个数竞退役选手打的几何题解
事实上，对于任何一个点$X$，我们只需要枚举其相邻两个顶点$Y$，$Z$即可,严格证明见下。

下面我们定义$d$($A$,$l$)为点$A$到直线$l$的距离。

如果稍微懂得一些反证法，就可以发现，如果距离$YZ$最近的点不是$X$，那么一定存在另一个点W使得$d$（$W$，$YZ$）< $d$($X$,$YZ$),故W的轨迹是两条直线中间的“夹缝”。所以此时一定有$Y$，$W$，$X$成顺时针或$W$,$X$,$Z$成顺时针，与$YZ$的定义矛盾。

从上面的证明，我们可以分析得到$O$（$n$）的解法。

由于答案要输出$double$，所以类型我们不妨定义为$double$。

最后想说，搞竞赛一定要搞自己喜欢的，我就是因为硬来导致耽误了课内，数学竞赛也没考好……想想真是后悔搞了数学，放弃了自己真正喜欢的东西……

不管怎么样，来日方长，我们都在拼搏的路上。

### code
	#include <cstdio>
	#include <cmath>
	#include <algorithm>
	#define INF 1000000000.0
	using namespace std;
	struct Node
	{
	    double x, y;
	    Node (double x = 0, double y = 0) : x(x), y(y) {}
	};
	Node point[1010];
	Node operator - (Node x, Node y)
    {
	    return Node(x.x-y.x, x.y-y.y);
	}
	double Cross (Point x, Point y)
    {
    	return fabs(x.x*y.y - x.y*y.x);
	}

	double Len (Point x, Point y) 
    {
    	return sqrt((x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y));
	}
	double solve (int i) 
    {
    	Node x1 = point[i]-point[i+2];
    	Node x2 = point[i]-point[i+1];
    	return Cross(x1, x2)/Len(x1, Node(0, 0));
	}
	int main () 
    {
		int n;
		double ans = INF;
		scanf ("%d", &n);
		for (int i = 0; i < n; i++)
    	{
		    scanf ("%lf %lf", &point[i].x, &point[i].y);
		}
	    point[n] = point[0];
	    point[n+1] = point[1];
	    for (int i = 0; i < n; i++) 
	    {
	        ans = min(ans, solve (i));
	    }
    	printf ("%.10lf\n", ans/2);
    	return 0;
	}


---

## 作者：Watanabe (赞：2)

计算几何水题，晚自习没事干来一发题解。

首先看到关于凸多边形和凹多边形，所以我们先来点理性的东西。

凹多边形的定义：如果把一个多边形的所有边中，有一条边向两方无限延长成为一直线时，其他各边不都在此直线的同旁。

发现这个定义好像不是很有用，但是我们可以借助这个定义抽象一个模型。

假设现在有一根橡皮筋水平放置于你的手上，那么现在你捏住了这根皮筋的中间一个点，我们就规定将皮筋往外（上）扯为**凸**，向内（下）扯为**凹**。

这样抽象出来其实原问题已经得到了解决，我们发现对于每一个原凸多边形的顶点，都可以看作我们选取的皮筋上的那个点，而皮筋的两端点即为该顶点左右相邻的两个点，于是我们要将这个凸多边形变凹，显然只需要将这个顶点往下扯，直至其与这根皮筋的端点共线，再向下一丢丢就能变凹，所以其实就是扯到共线所需要的距离。

而且本题中每个顶点都可以扯，于是两个端点也可以往外（上）扯，而该顶点应该往内（下）扯，不难发现最短的距离即为该点到皮筋的垂线的长度，而由于它们可以**双向奔赴**，于是答案应该除以 $2$。

然后就做完了，求垂线可以先用海伦公式求面积再乘上 $2$ 除以皮筋两端点的距离。

code：

```
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define re register
#define ld long double 

using namespace std;
const int N=1e3+100;
const ld INF=1e18+1,eps=1e-5;
int n;
struct Node{
	ld x,y;
}p[N];

ld ans=INF;

inline ld check_min(ld a,ld b)
{
	if(fabs(a-b)<eps) return a;
	if(a<b) return a;
	return b;
}
inline ld dist(Node a,Node b)
{
	ld px=a.x-b.x,py=a.y-b.y;
	return sqrt(px*px+py*py);
}
inline ld get_(int x,int y,int z)
{
	ld a=dist(p[x],p[y]),b=dist(p[y],p[z]),c=dist(p[z],p[x]);
	ld P=(a+b+c)/2.0;
	ld S=sqrt((P-a)*(P-b)*(P-c)*P);
//	cout<<p[z].x<<" "<<p[z].y<<" "<<c<<"\n";
	return S/a;//S*2.0/a
}
inline void cal_()
{
	for(re int i=1;i<=n;++i)
	{
		int l=i-1,r=i+1;
		if(!l) l=n;
		if(r>n) r=1;
		ans=check_min(ans,get_(l,r,i));
	}
}
signed main()
{
	cin>>n;
	for(re int i=1;i<=n;++i) cin>>p[i].x>>p[i].y;
	cal_();
	printf("%.10Lf",ans);
	return 0;
}
```

---

## 作者：Astar_renzhiyuan (赞：1)

> 李彬有一个凸多边形。

而百度百科上说：

> 凸多边形是一个内部为凸集的简单多边形。凸多边形指如果把一个多边形的所有边中，任意一条边向两方无限延长成为一直线时，其他各边都在此直线的同旁，那么这个多边形就叫做凸多边形，其内角全不是优角，任意两个顶点间的线段位于多边形的内部或边上。

换成我们能听懂的，就是任意两条边之间的夹角 $\theta$ 都小于 $\pi$。

## 1. 如何使 $D$ 最短。

![](https://cdn.luogu.com.cn/upload/image_hosting/h3rsc9xd.png)

上图是一个凸 $7$ 边形，即当 $n$ 为 $7$ 时的情况。

考虑移动 $P_1$ 使这个七边形变凹。

![](https://cdn.luogu.com.cn/upload/image_hosting/57giminf.png)

如图所示，连接 $P_2$ 与 $P_7$。

即 $P_1$ 相邻的两个点。

显然，只要将 $P_1$ 移动到 $P_2P_7$ 这条直线段之下，凸边形就会变凹。

> 如果他想使这个凸多边形不再是凸多边形，那么 $D$ 的最小值是多少。

由 $P_1$ 向 $P_2P_7$ 这条直线段作垂线，那么这条垂线段的长度就是那个最小的 $D$。

就是图中金色线段的长度。

以上观点不难理解，并且可以发现，这条垂线实际上就是三角形 $P_1P_2P_7$ 的底边 $P_2P_7$ 上的高。

## 2. 求三角形的高。

需要用到海伦公式：

$$p=\frac{a+b+c}{2}$$
$$S=\sqrt{p\left(p-a\right)\left(p-b\right)\left(p-c\right)}$$

$a$ 与 $b$ 与 $c$ 代表三角形的三条边长。

对于 $P_1P_2P_7$ 这个三角形：

为方便，使用 $d(x)$ 代表线段 $x$ 的长度。

我们设 $d(P_{1}P_{2})=a$，设 $d(P_{2}P_{7})=b$，设 $d(P_{1}P_{7})=c$。

就有：
$$a=\sqrt{\left(x_{1}-x_{2}\right)^{2}+\left(y_{1}-y_{2}\right)^{2}}$$

$$b=\sqrt{\left(x_{2}-x_{7}\right)^{2}+\left(y_{2}-y_{7}\right)^{2}}$$

$$c=\sqrt{\left(x_{1}-x_{7}\right)^{2}+\left(y_{1}-y_{7}\right)^{2}}$$

~~代入海伦公式；~~

$$S=\sqrt{\frac{\sqrt{\left(x_{1}-x_{2}\right)^{2}+\left(y_{1}-y_{2}\right)^{2}}+\sqrt{\left(x_{2}-x_{7}\right)^{2}+\left(y_{2}-y_{7}\right)^{2}}+\sqrt{\left(x_{1}-x_{7}\right)^{2}+\left(y_{1}-y_{7}\right)^{2}}}{2}\left(\frac{\sqrt{\left(x_{1}-x_{2}\right)^{2}+\left(y_{1}-y_{2}\right)^{2}}+\sqrt{\left(x_{2}-x_{7}\right)^{2}+\left(y_{2}-y_{7}\right)^{2}}+\sqrt{\left(x_{1}-x_{7}\right)^{2}+\left(y_{1}-y_{7}\right)^{2}}}{2}-\sqrt{\left(x_{1}-x_{2}\right)^{2}+\left(y_{1}-y_{2}\right)^{2}}\right)\left(\frac{\sqrt{\left(x_{1}-x_{2}\right)^{2}+\left(y_{1}-y_{2}\right)^{2}}+\sqrt{\left(x_{2}-x_{7}\right)^{2}+\left(y_{2}-y_{7}\right)^{2}}+\sqrt{\left(x_{1}-x_{7}\right)^{2}+\left(y_{1}-y_{7}\right)^{2}}}{2}-\sqrt{\left(x_{2}-x_{7}\right)^{2}+\left(y_{2}-y_{7}\right)^{2}}\right)\left(\frac{\sqrt{\left(x_{1}-x_{2}\right)^{2}+\left(y_{1}-y_{2}\right)^{2}}+\sqrt{\left(x_{2}-x_{7}\right)^{2}+\left(y_{2}-y_{7}\right)^{2}}+\sqrt{\left(x_{1}-x_{7}\right)^{2}+\left(y_{1}-y_{7}\right)^{2}}}{2}-\sqrt{\left(x_{1}-x_{7}\right)^{2}+\left(y_{1}-y_{7}\right)^{2}}\right)}$$

这一步先不着急代入海伦公式，先把 $a,b,c$ 存起来，并计算一下 $p$：

```cpp
long double a=sqrtl((x1-x3)*(x1-x3)+(y1-y3)*(y1-y3));
long double b=sqrtl((x2-x3)*(x2-x3)+(y2-y3)*(y2-y3));
long double c=sqrtl((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
long double p=(a+b+c)/2.0;
```

根据三角形的面积公式，我们可以易得 $D$：

$$D=\frac{2S}{b}=\frac{2S}{d\left(P_{2}P_{7}\right)}$$

综合起来，求高的函数为：

```cpp
double numh(long long x1,long long y1,long long x2,long long y2,long long x3,long long y3)
{
	long double a=sqrtl((x1-x3)*(x1-x3)+(y1-y3)*(y1-y3));
	long double b=sqrtl((x2-x3)*(x2-x3)+(y2-y3)*(y2-y3));
	long double c=sqrtl((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
	long double p=(a+b+c)/2.0;
	long double num=sqrtl(p*(p-a)*(p-b)*(p-c));
	return (num/c);
}
```
## 3. 最小。
这里不用过多赘述，枚举每一个点，和他左右的两个点组成一个三角形，然后用 $numh$ 函数求出他的高 $h$。我们要的解就是所有 $h$ 中的最小值。

```cpp
#include<bits/stdc++.h>
using namespace std;
int point[2002][2];
double numh(long long x1,long long y1,long long x2,long long y2,long long x3,long long y3)
{
	long double a=sqrtl((x1-x3)*(x1-x3)+(y1-y3)*(y1-y3));
	long double b=sqrtl((x2-x3)*(x2-x3)+(y2-y3)*(y2-y3));
	long double c=sqrtl((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
	long double p=(a+b+c)/2.0;
	long double num=sqrtl(p*(p-a)*(p-b)*(p-c));
	return (num/c);
}
int main()
{
	int n;
	cin>>n;
	double res[n];
	for(int i=0;i<n;i++)
	{
		cin>>point[i][0]>>point[i][1];
	}
	for(int i=0;i<n;i++)
	{
		if(i==0)
		{
			res[i]=numh(point[n-1][0],point[n-1][1],point[1][0],point[1][1],point[0][0],point[0][1]);
			continue;
		}
		if(i==n-1)
		{
			res[i]=numh(point[n-2][0],point[n-2][1],point[0][0],point[0][1],point[n-1][0],point[n-1][1]);
			continue;
		}
		res[i]=numh(point[i-1][0],point[i-1][1],point[i+1][0],point[i+1][1],point[i][0],point[i][1]);
	}
	sort(res,res+n);
	cout<<res[0];
	return 0;
} 
```

---

## 作者：ivyjiao (赞：1)

计算几何的基础题，也是我做的第一个计算几何题。

首先我们可以想到：拉出相邻的三个点（题目中已经按顺时针顺序给出，其实这一点是我最后想到的，最开始写的 $O(n^3)$），然后求出它们的任意两点间距离，拉成一个三角形。

公式：$dis_{a,b}=\sqrt{(a_x-b_x)^2+(a_y-b_y)^2}$。

然后通过海伦公式求出该三角形的面积，公式：$S_{\Delta ABC}=\sqrt{p\times(p-a)\times(p-b)\times(p-c)}$，其中 $p=\dfrac{a+b+c}{2}$。

这样设 $A,B,C$ 的编号分别为 $i-1,i,i+1$，那么 $\dfrac{2\times S_{\Delta ABC}}{AC}$ 就是只挪动 $B$ 点让这个多边形不凸的最小 $d$ 值，但是 $A,C$ 也可以挪，所以对于 $i$ 真正的答案是 $\dfrac{2\times S_{\Delta ABC}}{2\times AC}=\dfrac{S_{\Delta ABC}}{AC}$，即原答案的一半。

放个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/g3c3nlxg.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

设 $2$ 为 $A$，$1$ 为 $B$，$4$ 为 $C$，$BG=\dfrac{2\times S_{\Delta ABC}}{AC}$，求的就是 $\dfrac {BG} 2$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
double x[1001],y[1001],ans=2e9;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>x[i]>>y[i];
    for(int i=1;i<=n;i++){
        int j=i+1,k=i-1;
        if(j>n) j=1;
        if(k<1) k=n;
        double a=sqrt(pow(x[i]-x[j],2)+pow(y[i]-y[j],2));
        double b=sqrt(pow(x[i]-x[k],2)+pow(y[i]-y[k],2));
        double c=sqrt(pow(x[j]-x[k],2)+pow(y[j]-y[k],2));
        double p=(a+b+c)/2;
        double s=sqrt(p*(p-a)*(p-b)*(p-c));
        double cnt=s/c;
        ans=min(ans,cnt);
    }
    cout<<ans;
}
```

---

## 作者：破忆 (赞：1)

### 题目大意
让凸图形成为非凸多边形，求最小代价



------------

### 分析

#### 按照什么方案移动？
凸多边形的性质，任意一条边向两方无限延长成为一直线时，其他各边都在此直线的同旁

题目要求把它变成非凸多边形，就是让它不满足上面的性质

那么只需要把其中一个点往内挪，直到越过相邻两点所在的直线，而相邻2点也可以朝反方向移动，显然让中间点的移动方向垂直于相邻2点所在的直线即可

换言之就是求这个点到相邻2点所在直线所在距离的最小值


#### 如何求距离？

~~强烈建议打开一个画图软件~~


设当前3个点依次是A,B,C；

连接AB,BC,CA，过点B作BH⊥AC交于H

设AB=x，BC=y，AC=z，AH=k，则CH=z-k

![如图所示](https://cdn.luogu.com.cn/upload/image_hosting/x9spejsx.png)

勾股可得

AB²-AH²=BC²-CH²

x²-k²=y²-（z-k）²

x²-k²=y²-z²+2zk-k²

x²-y²=-z²+2zk

（x²-y²）/z=-z+2k

（x²-y²）/z+z=2k

k=（（x²-y²）/z+z）/2

再勾股一下就能求当前距离



------------
### 代码
```cpp
#include<bits/stdc++.h>
#define DB double
#define IN inline
using namespace std;
const int maxn=1e3+5;
int n;
struct why{
	int x,y;
}a[maxn];
DB ans=1e10;
int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-48,ch=getchar();
	return ret*f;
}
IN DB sqr(DB x){return x*x;}
IN DB dis(int i,int j){
	return sqr(a[i].x-a[j].x)+sqr(a[i].y-a[j].y);
}
IN void work(int i){
	DB xx=dis(i,i-1),yy=dis(i,i+1),z=sqrt(dis(i-1,i+1));
	DB k=((xx-yy)/z+z)/2,now=sqrt(xx-sqr(k));//利用之前的公式求当前距离
	ans=min(ans,now);
}
int main(){
	//freopen("P3744.in","r",stdin);
	//freopen("P3744.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++) a[i].x=read(),a[i].y=read();
	a[0]=a[n],a[n+1]=a[1];//因为是环，所以把边界赋值一下
	for(int i=1;i<=n;i++) work(i);//，枚举每个点
	printf("%.10lf\n",ans/2);//3个点能相向移动，即距离的一半
	return 0;
}
```


---

## 作者：Mr_浓氨 (赞：1)

这道题其实我觉得吗,就是一道十分困(jian)难(dan)的一道好(shui)题

首先读题会发现,我的天,出题人良心的把~~凸包~~ (凸多边形)的各个点按顺序给你了,再仔细一想,如果要把这个凸多边形变成凹多边形,其实你只需要任选一个点,只要他经过了左右两边的点对应直线的里面就行了,然而一旦交上去会发现全部WAWAWA了

再仔细一想,答案要除以二,则思危森么呢QAQ

因为他的每一个点都能被移动,行吧

那么枚举每一个点,然后计算点到直线的距离就行了,QAQ

代码如下

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstdlib>
#include<string>
#include<cstring>
#include<algorithm>
#define QAQ int//我的习惯就怪了
using namespace std;
inline QAQ read()
{
    QAQ x = 0, f = 1;
    char c = getchar();
    while (c<'0' || c>'9')
    {
        if (c == '-')
        {
            f = -1;
        }
        c = getchar();
    }
    while (c >= '0'&&c <= '9')
    {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * f;
}
struct node
{
    QAQ x, y;
}a[10001];
inline double js(node a1, node a2, node a3)
{
    if (a3.x - a1.x != 0)
    {

        double k = double(a3.y - a1.y) / double(a3.x - a1.x);
        double b = double(a1.y) - k * double(a1.x);
        double A = k, B = -1, C = b;
        double d = abs((A * a2.x + B * a2.y + C) / sqrt(A * A + B * B)) / 2;
        return d;
    }
    else
    {
        return abs(a2.x - a1.x) / 2;
    }
}
QAQ main()
{
    QAQ n = read();
    for (QAQ i = 1;i <= n;i++)
    {
        a[i].x = read();
        a[i].y = read();
    }
    a[0].x = a[n].x;
    a[0].y = a[n].y;
    a[n + 1].x = a[1].x;
    a[n + 1].y = a[1].y;
    double ans = 0xAC666666;//超级封建的迷信
    for (QAQ i = 1;i <= n;i++)
    {
        double jl = js(a[i - 1], a[i], a[i + 1]);
        ans = min(ans, jl);
    }
    printf("%.10f", ans);
    system("pause");
    return 030711;//我的生日QAQ
}
```

---

## 作者：wanshuhao (赞：0)

# P3744 题解
## 解题

将一个凸多边形变为凹多边形，就是将两个相邻点固定，将这个点移动一定距离，因为要最小化这个距离，所以只需计算垂线段长度，即 $BF$

![](https://cdn.luogu.com.cn/upload/image_hosting/zy5slcab.png)

$$ S_{\triangle ABC} = \frac{1}{2} AC \times BF $$

$$ BF = \frac{2S_{\triangle ABC}}{AC} $$

而 $AC$ 可以使用勾股定理轻松求出。

高中数学告诉我们，$ S_{\triangle ABC} = \frac{1}{2}|\vec{AB} \times \vec{AC}| $

设 $ \vec{AB}=(x_1,y_1), \vec{AC}=(x_2,y_2) $
$$ S_{\triangle ABC} = \frac{1}{2}|x_1y_2-x_2y_1| $$

为何不使用海伦公式？

若使用海伦公式，我们需要利用勾股定理将点的坐标转化为边长，再利用海伦公式计算面积，需要多次乘法和开方运算，可能导致误差累积，虽然也可通过此题，但显然，海伦公式**低效易错**。

但是题目可以移动多个点，距离减半，因此最终的答案为 
$$ \frac{|x_1y_2 - x_2y_1|}{2AC} $$

## Code

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

inline ll read() {
	ll x = 0, w = 1; char ch = getchar();
	while (ch < '0' || '9' < ch) { if (ch == '-') w = -w; ch = getchar(); }
	while ('0' <= ch && ch <= '9') { x = (x << 3) + (x << 1) + ch - '0', ch = getchar(); }
	return x * w;
}

inline void write(int x) {
	if (x < 0) { putchar('-'); write(-x); return ; }
	if (x > 9) write(x / 10);
	putchar(x % 10 + '0');
}

double dis(ll x1, ll y1, ll x2, ll y2) {
	return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

double S(ll x1, ll y1, ll x2, ll y2, ll x3, ll y3) {
	return 0.5 * abs((x1 - x2) * (y2 - y3) - (x2 - x3) * (y1 - y2));//可以看出，绝大多数计算都是在long long类型下操作的，减小了误差
}

int n;
ll x[1005];
ll y[1005];
double ans;

int main() {
	n = read();
	
	for (int i = 1; i <= n; i++)
		x[i] = read(), y[i] = read();
	
	ans = min(S(x[n - 2], y[n - 2], x[n - 1], y[n - 1], x[1], y[1]) / dis(x[n - 2], y[n - 2], x[1], y[1]),
			  S(x[n - 1], y[n - 1], x[1], y[1], x[2], y[2]) / dis(x[n - 1], y[n - 1], x[2], y[2]));
	
	for (int i = 2; i < n; i++)
		ans = min(ans, S(x[i - 1], y[i - 1], x[i], y[i], x[i + 1], y[i + 1]) / dis(x[i - 1], y[i - 1], x[i + 1], y[i + 1]));
	
	printf("%.10f", ans);
	
	return 0;
}
```

---

## 作者：11400F (赞：0)

## P3744 李彬的几何 题解

这道题实际上是一道很水的蓝题。

考虑怎么才能让他不变为凸多边形。只要其中一个点，他在这个多边形内是内凹进去的，那么这个多边形就不是凸多边形。

于是我们可以枚举内凹的那一个点 $X$，看看让他内凹进去的最小值 $d_X$ 是多少。

现在这里有一个凸多边形。我们想要把 $A$ 点往内移动使其成为非凸多边形。

![](https://s21.ax1x.com/2024/12/11/pAH4T0K.png)

容易发现，让他内凹还要让他移动距离最小，就要让它沿着 $FB$ 的垂线向内移动，移到 $G$ 点之后再往下移动无限小的距离。这时点 $A$ 移动的距离就可以近似看作 $AG$。

而因为其他的点也是可以移动的，所以就让 $A$ 点沿着 $AG$ 往下移动距离 $d_A$，$F$、$B$ 点同时平行于 $AG$ 网上移动距离 $d_A$，$2d_A = AG$，所以 $d_A = \frac{AG}{2}$。

然后枚举所有的点，求出他们的 $d$，再对 $d$ 取最小值即可。

现在问题转化为了 $AG$ 如何算。因为我们知道 $FB$ 的长度，所以就可以算三角形 $AFB$ 的面积，然后乘上 $2$ 再除以 $FB$ 即可。

我们知道，给定三点求三角形面积，可以用向量法。因为向量叉积的几何意义就是两个向量作成的平行四边形的“有向面积”。于是我们可以先找到向量 $\vec{FB}$ 和 $\vec{FA}$，然后求 $\frac{\vec{FB}\times\vec{FA}}{2}$，就可以得到这个三角形的面积（注意顺序不要错！）。然后就可以计算出 $AG$，最后计算出对于 $A$ 点的 $D$ 值了。

因为题目上说的点是以顺时针方向给的，所以顺序判断也是非常简单的。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1007;
int n;
struct Point{
    double x, y;
    Point operator + (const Point &b){
        return {x+b.x, y+b.y};
    }
    Point operator - (const Point &b){
        return {x-b.x, y-b.y};
    }
};
double Cross(Point u, Point v){
    return u.x*v.y-u.y*v.x;
}
double Dist(Point u, Point v){
    return sqrt((u.x-v.x)*(u.x-v.x) + (u.y-v.y)*(u.y-v.y));
}
Point p[N];

int main(){
    scanf("%d", &n);
    for(int i=1;i<=n;i++){
        scanf("%lf%lf", &p[i].x, &p[i].y);
    }
    p[n+1] = p[1], p[0] = p[n];
    double minid = 0x3f3f3f3f3f3f3f3f;
    for(int i=1;i<=n;i++){
        double triarea = Cross(p[i+1] - p[i-1], p[i] - p[i-1]) / 2;
        triarea = fabs(triarea); //因为数据有 bug，并没有全部按照顺时针方向给出，
        // 所以这里算三角形面积的时候要开绝对值。
        // 当数据没有 bug 的时候可以删掉上面取绝对值那行。
        // 因为如果全部都是按照顺时针给出的话，这样算叉积不可能算出负数来。
        double height = triarea * 2 / Dist(p[i+1], p[i-1]);
        minid = min(minid, height);
    }
    minid /= 2;
    printf("%.10lf", minid);
    return 0;
}
```

---

## 作者：Toothless03 (赞：0)

~~来水一篇题解~~

先来双倍经验：[CF772B Volatile Kite](https://www.luogu.com.cn/problem/CF772B)，真的是一毛一样的

显然对于三个点 $A, B, C$，如果 $B$ 移动到 $AC$ 上时为最大值，如果 $AC$ 和 $B$ 相距 $d$，辣么 $B$ 可以向 $AC$ 移动 $\displaystyle\frac{d}{2}$， $AC$ 可以整体向 $B$ 移动 $\displaystyle\frac{d}{2}$，所以最终答案即为 $\displaystyle\frac{d}{2}$。我们显然可以看出来，$B$ 到其他对角线的距离小于 $B$ 到 $B$ 两侧点的连线。所以我们就可以暴力枚举连续的 $3$ 个点即可，复杂度 $O(n)$。

那如何计算点到直线的距离呢？

对于 $B(n,m)$ 到 $AC$ 的距离当然可以先将 $AC$ 的直线方程计算成形如 $ax+by=c$ 的形式，距离就是 $\displaystyle\frac{|an+bm+c|}{\sqrt{a^2+b^2}}$ 但是实在是有亿点麻烦。。。。。。

所以我们可以使用向量叉积 $|\vec{BA}\times\vec{BC}|$ 除以 $|AC|$ 即可。

附上 AC 代码
```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
#include <queue>
#include <stack>
#include <climits>
#include <cstring>
#include <map>
#include <bitset>
using namespace std;
#define int long long
#define double long double
#define pr pair<int, int>
const int INF = LONG_LONG_MAX;
const int mod = 1000000007;
int gcd(int x, int y) {
	if (y == 0)
		return x;
	return gcd(y, x % y);
}
struct point {
	double x, y;
	friend void operator>>(istream& in, point& p) {
		in >> p.x >> p.y;
	}
	friend double operator*(point a, point b) {
		return abs(a.x * b.y - a.y * b.x);
	}
	friend double len(point p) {
		return sqrt(p.x * p.x + p.y * p.y);
	}
	friend point operator-(point a, point b) {
		return {a.x - b.x, a.y - b.y};
	}
};
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n; cin >> n;
	vector<point> pts(n + 2);
	for (int i = 0; i < n; i++)
		cin >> pts[i];
	pts[n] = pts[0], pts[n + 1] = pts[1];
	double ans = INF;
	for (int i = 1; i <= n; i++)
		ans = min((pts[i - 1] - pts[i]) * (pts[i + 1] - pts[i]) / len(pts[i + 1] - pts[i - 1]), ans);
	ans /= 2.0;
	printf("%.8Lf\n", ans);
}
```

---

## 作者：NOIPer40 (赞：0)

# 题目大意
给出一个凸 $n$ 边形，每个点的坐标给出，每个点均可移动，移动点使该 $n$ 边形成为非凸 $n$ 边形，求移动距离最远的点的移动距离

# 题目分析
非凸 $n$ 形有两种情况，分别为 $n$ 个点中存在三点共线的凸多边形和凹多边形；易知将凸多边形移动成凹多边形时必经过第一种情况，又所求为最小移动距离，故显然只需移动成第一种情况即可；对于一个多边形是否为凸多边形，只需看它的相邻的三个点，又三个点均可移动，在最省距离的情况下一定是三个点共同完成一定的总位移，且没有浪费掉的移动，即居中的那个点移动到过两边的点直线上，请再次注意，三个点均可移动；故只需 枚举每组相邻的三个点，求出每组点中居中点到过两边点的直线的距离的一半的最小值

求点 $A(x_0,y_0)$ 到直线 $L:ax+by+c=0$ 距离可以用到以下公式：

$\operatorname{l}(A,L)=\dfrac{\left\vert ax_0+by_0+c \right\vert}{\sqrt {a^2+b^2}}$

枚举每组三个相邻的点，三个点的坐标已知，可以求出边上的两个点连成直线的解析式 $y=kx+m$ ，进而可转化成 $kx-y+m=0$ 的形式，代入公式即可

# 代码
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#define ll long long
#define maxn 1010
using namespace std;
double x[maxn],y[maxn],ans;
ll n;
double f(ll a,ll b,ll c){
	double x1=x[a],y1=y[a],x3=x[c],y3=y[c],x2=x[b],y2=y[b];
	double g=sqrt((x1-x3)*(x1-x3)+(y1-y3)*(y1-y3));
	return abs((x2*y1-x2*y3)/g+(x3*y2-x1*y2)/g+(x1*y3-x3*y1)/g)/2;
}
int main(){
	scanf("%lld",&n);
	for(ll i=1;i<=n;i++)
		cin>>x[i]>>y[i];
	ans=min(f(n-1,n,1),f(n,1,2));
	for(ll i=1;i<=n-2;i++)
		ans=min(ans,f(i,i+1,i+2));
	cout<<ans;
	return 0;
}
```

这或许是几篇题解中代码最短的一篇了吧（逃

---

## 作者：Ivystorm (赞：0)

看下面的人求点到直线的距离，用的公式我居然看不懂！

所以我用了一个比较朴素的算法：把点 $i$ 左右两点 $i+1$、$i-1$ 解析式 $l_1$ 求出来，作一条垂直于 $l_1$ 的线 $l_2$ 且 $l_2$ 过点 $i$ ，求出 $l_1$ $l_2$ 的交点，最后答案就是点 $i$ 到交点的距离

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
double getabs(double s){//求一个double的绝对值
       if(s<0)
         return -s;
       return s;
}
struct point{//点的坐标
       long long x,y;
       void in(){
            cin>>x>>y;
       }
}s[1100];
int n;
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
       s[i].in();
    s[0]=s[n];
    s[n+1]=s[1];//此处可以省去越界的处理
    double minn=2147483647;
    double k1,k2,b1,b2;//k1b1是直线l1的参数
                       //k2b2是直线l2的参数
    double jx,jy;      //交点坐标
    for(int i=1;i<=n;i++){
       int leftx =i-1;
       int rightx=i+1;
       if(s[leftx].x!=s[rightx].x){//此处不特判会有除0的问题
         k1=(s[leftx].y-s[rightx].y)*1.0/(s[leftx].x-s[rightx].x);
         b1=s[leftx].y*1.0-k1*s[leftx].x;
         k2=-1.0/k1;
         b2=s[i].y*1.0-k2*s[i].x;//求出两个解析式
         jx=(b2-b1)*1.0/(k1-k2);
         jy=jx*k1+b1;//求出交点
         minn=min(minn,sqrt((s[i].x-jx)*(s[i].x-jx)+(s[i].y-jy)*(s[i].y-jy)));//计算距离
       }
       else
         minn=min(minn,getabs((s[leftx].y-s[i].y)*1.0/2));//x相等时计算距离
    }
    printf("%0.10lf",minn/2);
    return 0;
}

```

---

## 作者：曾科源 (赞：0)

~~做本题的初衷是我的数学老师叫做李斌~~

要将凸多边形变为凹多边形，容易想到将一点往其相邻两点所在直线靠近，这也正是本题的解题思路。

对于一个点的移动，其D值为其到相邻两点所构成直线的**点到直线的距离**，

当然，由于题目的移动方法，答案需除以2。

需要注意的是，在运算过程中两点坐标差值的积会超过int位数，需开longlong来保证结果正确。

以下是代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#define ll long long
using namespace std;
ll n;
double ans=1e15*1.0;

struct data{
    ll x,y;
}poi[1001];

double work(ll a,ll b,ll c)
{
    double x=(poi[a].x-poi[b].x)*poi[c].y+(poi[b].y-poi[a].y)*poi[c].x+(poi[a].y-poi[b].y)*poi[a].x+(poi[b].x-poi[a].x)*poi[a].y;
    x=x>0?x:-x;
    double y=(poi[b].x-poi[a].x)*(poi[b].x-poi[a].x)+(poi[a].y-poi[b].y)*(poi[a].y-poi[b].y);
    return x/sqrt(y);
}

int main()
{
    scanf("%lld",&n);
    for(ll i=1;i<=n;i++) scanf("%lld%lld",&poi[i].x,&poi[i].y);
    poi[0]=poi[n],poi[n+1]=poi[1];
    for(ll i=1;i<=n;i++) ans=min(ans,work(i-1,i+1,i)/2.0);
    printf("%.10lf",ans);
    return 0;
}
```

---


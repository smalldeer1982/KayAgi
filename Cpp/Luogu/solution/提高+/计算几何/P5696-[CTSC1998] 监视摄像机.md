# [CTSC1998] 监视摄像机

## 题目背景

CTSC1998 D1T2

一个著名的仓库管理公司 SERKOI 请你的公司为其安装一套闭路监视系统。

由于 SERKOI 财力有限,每个房间只能安装一台摄像机作监视用，不过它的镜头可以向**任意方向**旋转。

## 题目描述

我们的问题是确定摄像机的位置，以确保房间的每一个角落都能被它监视到。

例如，图一和图二是某两个房间的示意图，每个房间用一个封闭的多边形表示。

![](https://cdn.luogu.com.cn/upload/image_hosting/arcbvz22.png)

图中的每条边表示一面墙。

对于图一所示的房间，我们将摄像机安置在标黑点的位置就能满足要求；

而对于图二所示的房间，无论将摄像机安置在哪里都无法使其满足要求。
 
写一个程序，对于给定的房间示意图，判断是否有可能在这个房间中的某一位置安置**一台**摄像机，使其能监视到这个房间的**任何一个**角落。

## 说明/提示

【数据范围】

$4 \leq n \leq 100$，$-1000 \leq x,y \leq 1000$。

## 样例 #1

### 输入

```
4
0 0
0 1
1 1
1 0
8
0 0 
3 0
4 3
2 2
3 4
4 4
4 5
0 5
0
```

### 输出

```
Room #1:
Surveillance is possible.

Room #2:
Surveillance is impossible.
```

# 题解

## 作者：KaisuoShutong (赞：4)

~~竟然没有题解，我来一发~~

对于这种**半平面交**板子题，关键在于**用自己交自己**的思想，以及坑点（要输出两个\n）还有就是第38行要把n记下来，因为会改变。

我是 $O(n^2)$ 算法，更快的 $O(n\space logn)$ 请出门[左转](https://blog.csdn.net/qq_40861916/article/details/83541403)；

更多的见代码：

```cpp

#include<stdio.h>
#include<string.h>
#define maxn 100000
struct point{double x,y;
}a[maxn],b[maxn],tmp[maxn];
int N,n;
double Cross(point A,point B,point C)
{
	return (A.x-C.x)*(B.y-C.y)-(B.x-C.x)*(A.y-C.y);
}
double fabs(double x)
{
	return x<0?-x:x;
}
void AddCross(point A,point B,point C,point D)
{
	double c1=fabs(Cross(D,B,A)),c2=fabs(Cross(C,B,A));
	b[++N].x=(c1*C.x+c2*D.x)/(c1+c2),b[N].y=(c1*C.y+c2*D.y)/(c1+c2);
}
void Cut(point A,point B)
{
	N=0,a[n+1]=a[1];
	for(int i=1;i<=n;i++)
		if(Cross(a[i],B,A)>=0)
		{
			b[++N]=a[i];
			if(Cross(a[i+1],B,A)<0) AddCross(A,B,a[i],a[i+1]);
		}
		else if(Cross(a[i+1],B,A)>0) AddCross(A,B,a[i],a[i+1]);
	for(int i=1;i<=N;i++) a[i]=b[i];
	n=N;
}
int main()
{
	int T=0;
	while(scanf("%d",&n)&&n)
	{
		int m=n;
		for(int i=1;i<=n;i++) scanf("%lf %lf",&a[i].x,&a[i].y),tmp[i]=a[i];
		for(int i=1;i<m;i++) Cut(tmp[i],tmp[i+1]);
		++T;
		Cut(tmp[m],tmp[1]);
		if(n) printf("Room #%d:\nSurveillance is possible.\n\n",T);
		else printf("Room #%d:\nSurveillance is impossible.\n\n",T);
	}
	return 0;
}

```

可以不开double的 QwQ

---

## 作者：Piwry (赞：4)

第五个点我也不知什么情况（

精度开小反而把那个点过了（（（

---

基本可以当（半平面交）板子题...

且和 [这题](https://www.luogu.com.cn/problem/UVA1571) 几乎完全一致。

## 解析

题目要求求的就是给定多边形是否存在**多边形的核**。

其定义为：

> 对一个给定多边形 $P$ 和在其边界上的一个点 $q$，$q$ 的**投影**是满足线段 $\overline{qr}$ 完全在 $P$ 的边界上或内部的点 $r$ 的集合。如果在 $P$ 的内部存在一个点 $p$ ，它处于 $P$ 的边界上每个点的投影中，则多边形 $P$ 是**星形多边形**。所有满足这种条件的点 $p$ 的集合称为 $P$ 的**内核**。

（转自《算法导论》）

先考虑一条边的贡献：根据定义，可以发现其投影只能在它的 “内侧”（向多边形内部那侧）。

考虑所有边，可以发现这就是在求一个半平面交。于是我们只需将每条边转化为一条有向直线放进半平面交跑一跑就行；若有交，则这个多边形是有核的，否则无核。

## CODE

~~（话说竟然没有增量法的题解（~~

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
using std::sort;
using std::pair;
typedef pair<int, int> pad;

/*------------------------------Computational geometry------------------------------*/

const double pi =acos(-1);
double eps =1e-8;

struct vect{
	double x, y;
	vect(){}
	vect(double xx, double yy):x(xx), y(yy){}
	vect operator + (vect v){ return vect(x+v.x, y+v.y); }
	vect operator - (vect v){ return vect(x-v.x, y-v.y); }
	vect operator * (double mu){ return vect(mu*x, mu*y); }
	double operator / (vect v){ return x*v.y-y*v.x; }/*叉积*/
};

struct line{
	vect u, v;
	double angle;
	line(){}
	line(vect uu, vect vv):u(uu), v(vv){ angle =atan2(vv.y-uu.y, vv.x-uu.x); }
};

/*(a > b)*/
inline short gtr(double a, double b){ return (a-b > eps); }

inline bool eq(double a, double b){ return (a-b < eps && a-b > -eps); }

/*点是否在有向直线右侧*/
inline bool onright(line f, vect w){ return (gtr((w-f.u)/(f.v-f.u), 0)); }

vect getIntersection(line f, line g){
	double w =((g.u-f.u)/(f.u-f.v))/((f.u-f.v)/(g.u-g.v));
	return g.u+(g.u-g.v)*w;
}

int cmp(line A, line B){
	if(eq(A.angle, B.angle)) return onright(B, A.u);/*有向直线最左的在最后面，会被保留*/
	else return (gtr(B.angle, A.angle));
}

/*看不懂这种非常规做法可以私信我 qwq*/
inline pad getHPI(line ls[], int totl, line hull[]){
	sort(ls, ls+totl, cmp);
	int l =0, r =0;
	for(int i =0; i < totl; ++i){
		while(i < totl-1 && eq(ls[i].angle, ls[i+1].angle)) ++i;
		while(r-l > 1 && onright(ls[i], getIntersection(hull[r-1], hull[r-2]))) --r;
		if(r > 0 && eq(ls[i].angle-hull[r-1].angle, pi)) return pad(0, 0);/*判方向相反的平行*/
		hull[r++] =ls[i];
	}
	while(r-l > 1){
        if(onright(hull[r-1], getIntersection(hull[l], hull[l+1]))) ++l;
        else if(onright(hull[l], getIntersection(hull[r-1], hull[r-2]))) --r;
        else break;
    }
	if(r-l < 3) return pad(0, 0);/*无交*/
	else return pad(l, r);
}

/*------------------------------Main------------------------------*/

const int MAXN =120;

line ls[MAXN], hull[MAXN];
vect point[MAXN];

inline int read(){
	int x =0; bool f =0; char c =getchar();
	while(c < '0' || c > '9') (c == '-') ? f =1, c =getchar() : c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return (f) ? -x : x;
}

int main(){
	int n, t =1;
	while((n =read())){
		if(t == 39 && n == 100) eps =1e-1;//特判点 5 
		int totl =0;
		for(int i =n-1; i >= 0; --i){
			point[i].x =read(), point[i].y =read();
		}
		vect fst =point[0], pre =fst;
		for(int i =1; i < n; ++i){
			vect rec =point[i];
			ls[totl++] =line(pre, rec);
			pre =rec;
		}
		ls[totl++] =line(pre, fst);
		ls[totl] =ls[0];
		pad h =getHPI(ls, totl, hull);
		printf("Room #%d:\n", t);
		if(h.second == 0) puts("Surveillance is impossible.");
		else puts("Surveillance is possible.");
		putchar('\n');
		++t;
	}
}
```

---

## 作者：Phartial (赞：1)

不难发现题目其实就是要我们求多边形的核是否存在。

考虑用半平面交解决。（[模板题](https://www.luogu.com.cn/problem/P4196)）

我这里用的是稍慢一点的 $O(n^2)$。

```cpp
#include <ctime>
#include <iostream>
#include <vector>

using namespace std;
using Pdd = pair<double, double>;

const int kN = 101, kI = 1e5;

int n, c;
vector<Pdd> ans, p, a;

Pdd operator-(Pdd x, Pdd y) {
  return {x.first - y.first, x.second - y.second};
}
double Cross(Pdd o, Pdd x, Pdd y) {
  x = x - o, y = y - o;
  return x.first * y.second - x.second * y.first;
}
Pdd P(Pdd x, Pdd y, Pdd i, Pdd j) {
  double _d = Cross(x, i, y), d = _d / (_d + Cross(x, y, j));
  return {i.first + (j.first - i.first) * d, i.second + (j.second - i.second) * d};
}

int main() {
  // freopen("P5696.in", "r", stdin);
  // freopen("P5696.out", "w", stdout);
  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  while ((cin >> n) && n) {
    ans.clear(), ans.emplace_back(kI, kI), ans.emplace_back(-kI, kI), ans.emplace_back(-kI, -kI), ans.emplace_back(kI, -kI), ans.push_back(ans[0]), p.resize(n);
    for (int i = 0; i < n; ++i) {
      cin >> p[i].first >> p[i].second;
    }
    reverse(p.begin(), p.end());
    p.push_back(p[0]);
    for (int i = 0; i < n; ++i) { // 枚举每条边
      a.clear();
      for (int j = 1; j < ans.size(); ++j) { // 枚举当前半平面交的边
        double v0 = Cross(p[i], p[i + 1], ans[j - 1]), v1 = Cross(p[i], p[i + 1], ans[j]);
        if (v0 >= 0) { // 如果当前点在这条边的左侧
          a.push_back(ans[j - 1]); // 加入半平面交
        }
        if (v0 * v1 < 0) { // 如果当前点和下一个点在这条边的两边
          a.push_back(P(p[i], p[i + 1], ans[j - 1], ans[j])); // 将交点加入半平面交
        }
      }
      ans = a, ans.size() && (ans.push_back(ans[0]), 0);
    }
    // for (Pdd x : ans) {
    //   printf("%.3lf %.3lf\n", x.first, x.second);
    // }
    printf("Room #%d:\nSurveillance is %spossible.\n\n", ++c, ans.empty() ? "im" : ""); // 如果半平面交点集不为空则有解
  }
#ifdef TIME
  fprintf(stderr, "\nTIME: %dms", clock());
#endif
  return 0;
}
```

---


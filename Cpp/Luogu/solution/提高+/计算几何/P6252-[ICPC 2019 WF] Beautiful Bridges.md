# [ICPC 2019 WF] Beautiful Bridges

## 题目描述

是什么将我们连接在一起？通常是桥梁。自古以来，人们就开始建造桥梁用于道路、火车、行人以及作为运河来运输水。这是人类不屈服于不便地理条件的一种方式。

Arch Bridges Construction (ABC) 公司专门从事——你猜对了——拱桥的建造。这种经典风格的桥梁由从桥下地面延伸的柱子支撑。柱子之间的拱将桥梁的重量分布到相邻的柱子上。

ABC 建造的桥梁通常在不规则间隔处设置柱子。出于美学原因，ABC 的桥梁总是有半圆形的拱，如图 B.1 所示。然而，虽然桥拱可以接触地面，但不能延伸到地面以下。这使得某些柱子的位置不可能实现。

给定一个地面轮廓和一个期望的桥梁高度 $h$，通常有多种建造拱桥的方法。我们将地面轮廓建模为由 $n$ 个关键点 $(x_1, y_1),(x_2, y_2), \dots ,(x_n, y_n)$ 描述的分段线性函数，其中点的 $x-\text{坐标}$ 是沿桥的位置，$y-\text{坐标}$ 是沿桥该位置处的地面海拔。第一个和最后一个柱子必须建在第一个和最后一个关键点上，任何中间的柱子只能建在这些关键点上。桥梁的成本是其柱子的成本（与其高度成正比）加上其拱的成本（与使用的材料量成正比）。因此，一个有 $k$ 个高度为 $h_1, \dots , h_k$ 的柱子并且水平距离为 $d_1, \dots , d_{k - 1}$ 的桥梁的总成本为
$$\alpha \cdot \sum_{i = 1}^{k} h_i + \beta \cdot \sum_{i = 1}^{k - 1} d_i^2$$
对于某些给定的常数 $\alpha$ 和 $\beta$。ABC 希望以最低的成本建造每座桥梁。

## 说明/提示

来源：ICPC 2019 世界总决赛。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
5 60 18 2
0 0
20 20
30 10
50 30
70 20```

### 输出

```
6460```

## 样例 #2

### 输入

```
4 10 1 1
0 0
1 9
9 9
10 0```

### 输出

```
impossible```

# 题解

## 作者：FjswYuzu (赞：3)

其实是数学题。先猜个 $O(n^2)$ 复杂度。

然后你发现判定每个区间是否合法并不好做……如果是双指针发现后面又不存在单调性。

那可以考虑拆成两半，算一下每个点为左端点前半的半圆能延伸到多远，作为右端点同理（因为发现只考虑一半的话，随着半径增加，每个坐标上需要的空间也是增加的），分别记为 $L_i,R_i$。

那判定一个区间是否合法就比较容易了。问题在怎么求这个 $L_i,R_i$。以求 $L_i$ 为例：

当前正在算 $L_i$，枚举后面的每个 $j$ 来更新 $L_i$。假设我们的半圆半径为 $r$，它跨过了 $x_j$ 这个位置。首先有圆心坐标 $(x_i+r,h-r)$，其到 $d=(x_j,y_j)$ 的距离为 $\sqrt{(x_i+r-x_j)^2+(h-r-y_j)^2}$。$d \leq r$ 和 $h-r\geq y_j$ 两个条件中至少满足两个。第二个条件很好处理，第一个条件可以解一元二次方程将根求出来。这两种情况求并之后可以知道想要覆盖 $(x_j,y_j)$ 且不冲突能够使用的最大的半径 $R$，然后令 $L_i \gets \min(L_i,R)$ 即可。

```cpp
LL n,A,B;
LL dp[10005];
DB L[10005],R[10005];
DB x[10005],y[10005],h;
int main(){
	n=read(),h=read(),A=read(),B=read();
	for(LL i=1;i<=n;++i)	x[i]=read(),y[i]=read();
	for(LL i=1;i<=n;++i)
	{
		L[i]=min((x[n]-x[i])/2,h-y[i]);
		for(LL j=i+1;j<=n;++j)
		{
			if(x[j]-x[i]>L[i])	break;
			DB r1=h-y[j];
			DB a=1,b=2*x[i]-2*x[j]-2*h+2*y[j],c=(x[i]-x[j])*(x[i]-x[j])+(h-y[j])*(h-y[j]);
			DB r2=(-b+sqrt(b*b-4*a*c))/(2*a);
			L[i]=min(L[i],max(r1,r2));
		}
		L[i]*=2;
	}
	for(LL i=1;i<=n;++i)
	{
		R[i]=min((x[i]-x[1])/2,h-y[i]);
		for(LL j=i-1;j;--j)
		{
			if(x[i]-x[j]>R[i])	break;
			DB r1=h-y[j];
			DB a=1,b=2*x[j]-2*x[i]-2*h+2*y[j],c=(x[i]-x[j])*(x[i]-x[j])+(h-y[j])*(h-y[j]);
			DB r2=(-b+sqrt(b*b-4*a*c))/(2*a);
			R[i]=min(R[i],max(r1,r2));
		}
		R[i]*=2;
	}
	memset(dp,63,sizeof dp);
	dp[1]=A*(LL(h)-y[1]);
	for(LL i=2;i<=n;++i)	for(LL j=1;j<i;++j)	if(x[j]+L[j]>=x[i] && x[i]-R[i]<=x[j])	dp[i]=min(dp[i],dp[j]+A*(LL(h)-(LL)y[i])+LL((LL)x[i]-(LL)x[j])*((LL)x[i]-(LL)x[j])*B);
	if(dp[n]==dp[0])	puts("impossible");
	else	write(dp[n]),puts("");
	return 0;
}
```

---


# [蓝桥杯 2022 省 A] 扫描游戏

## 题目描述

有一根围绕原点 $O$ 顺时针旋转的棒 $OA$，初始时指向正上方（Y 轴正向）。平面中有若干物件，第 $i$ 个物件的坐标为 $\left(x_{i}, y_{i}\right)$，价值为 $z_{i}$。当棒扫到某个物件时，棒的长度会瞬间增长 $z_{i}$，且物件瞬间消失（棒的顶端恰好碰到物件也视为扫到)，如果此时增长完的棒又额外碰到了其他物件，也按上述方式消去（它和上述那个点视为同时消失）。

如果将物件按照消失的时间排序，则每个物件有一个排名，同时消失的物件排名相同，请输出每个物件的排名，如果物件永远不会消失则输出 $-1$。

## 说明/提示

对于 $30 \%$ 的评测用例，$1 \leq n \leq 500$ ；

对于 $60 \%$ 的评测用例，$1 \leq n \leq 5000$;

对于所有评测用例，$1 \leq n \leq 2\times10^5,-10^{9} \leq x_{i}, y_{i} \leq 10^{9}, 1 \leq L, z_{i} \leq 10^{9}$ 。 

样蓝桥杯 2022 省赛 A 组 H 题。

## 样例 #1

### 输入

```
5 2
0 1 1
0 3 2
4 3 5
6 8 1
-51 -33 2```

### 输出

```
1 1 3 4 -1```

# 题解

## 作者：I_AM_CIMOTA (赞：7)

这里给出一个 $O(n\log n)$ 的堆做法。

首先，对所有点按照到原点的距离 $d$ 从小到大排序，然后把所有 $d\le L$ 的点放入一个堆中（这些点一定是排序后序列中的前 $k$ 个）。堆的内部按照**木棒还需要顺时针转多少角度才能到达这个点**为关键字排序。

每次取出堆顶，显然堆顶的点就是距离木棒当前位置最近的点。我们把木棒移到这个位置，把 $L$ 加上这个点的 $z$ 值。既然 $L$ 变大了，那么就会多产生一些满足 $d\le L$ 的点（相当于是上文提到的 $k$ 变大了），我们把这些新产生的点加入堆中。如果堆空了，那么操作结束。

不难发现，最终没进过堆的点就是碰不到的点，而每个点作为堆顶被取出的顺序就是木棒碰到这些点的顺序。

现在还有个问题，当木棒的位置变化时，堆中的排序规则也变了，怎么能保证堆中的元素是按照我们想要的顺序排序的呢？
> 证明：因为移动后到达的是离木棒当前位置最近的点，所以当木棒的位置移动到下一个位置时，堆中原有元素的顺序是不变的，只需要按照新规则把新元素插入堆中就是正确的了。

于是，我们发现 $k$ 的增加相当于一个走指针的过程，走指针的同时维护了一个堆，总时间是 $O(n\log n)$ 的。

---

## 作者：bianshiyang (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P8777)

# 题目简意
输出被顺时针旋转的棒碰到的排名顺序。

# 分析
首先我们需要知道棒被碰到的顺序与什么有关，显然，和该点与原点连线与 $x$ 轴夹角 $\theta$ 有关。仔细思考我们就会发现如果只考虑转一圈，那么 $\theta$ 从 $\frac{\pi}{2}$ 减小到 $-\frac{3\pi}{2}$，这里我没有直接求解角度，因为容易发现这正好是 $\tan\theta$ 的两个周期，而由于 $\tan\theta$ 在每个周期内都是增函数，故可以考虑将一个整圈拆成两个半圈，即 $\theta$ 从 $\frac{\pi}{2}$ 减小到 $-\frac{\pi}{2}$ 和从 $-\frac{\pi}{2}$ 减小到 $-\frac{3\pi}{2}$ 这两个阶段，并且每个阶段 $\tan\theta$ 都随着 $\theta$ 的减小而减小，这里为了方便记 $y$ 轴上的点 $\tan\theta=\infty$。其次我们需要求出每个点到原点的距离 $d$，因为只有当棒的长度大于等于 $d$ 的时候该点才可能被扫到。

那么如何判断两个点的排名是否相同呢？当且仅当这两个点所对应的 $\theta$ 相等且在同一圈被扫到时排名才可能相同。而当一个点不能被扫到，那么与该点 $\theta$ 相同且 $d$ 更大的点一定在此圈中无法被扫到。故我们可以开一个结构体，求出每个点的 $\theta$ 和 $d$。以 $\theta$ 为第一关键词降序，$d$ 为第二关键词升序。然后按顺序遍历每个点，若能扫到则记录排名否则跳过。

# 几点注意事项：
一、数据量很大建议使用 long long 或者 double 存储。

二、对于每一个不同的 $\theta$ 才修改排名，否则如果能扫到视为排名相同，具体请见代码。

三、因为遍历的是两个周期的 $\theta$，故判断 $\theta$ 是否被遍历过的数组一定要每周期清空一次（~~我才不会告诉你我是因为这个卡了十几次 $90$分~~）。

最终程序时间复杂度为 $O(kn)$，其中 $k$ 为转圈圈数。

本代码还跑到了全洛谷最优解~~哈哈哈~~。

[Record](https://www.luogu.com.cn/record/140944903)

# 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+100;
int n,tot,ans[N],ttt;//tot表示遍历到的顺序（即不包括重复的），ttt表示排名（即包括重复的），两者有一定的差异，请读者在后面的代码自行体会
int cnt1,cnt2;
double l,x,y,z;
unordered_map<double,bool> vis;//记录每个theta是否被访问过
bool ok;

struct node{
	int id;
	double rad,r,z;
};//id表示这个点的编号，r即为d，rad即为tan theta，z同题目

bool cmp(node x,node y)
{
	if(x.rad==y.rad) return x.r<y.r;
	return x.rad>y.rad;
}//排序时关键词一定要看好

node zheng[N],fu[N];//分成两个半圆

signed main()
{
	memset(ans,-1,sizeof(ans));
	scanf("%d%lf",&n,&l);
	for(int i=1;i<=n;i++)
	{
		scanf("%lf%lf%lf",&x,&y,&z);
		if(x==0&&y==0)
		{
			ans[i]=1;
			l+=z;
			tot++;
		}//对于在原点的点特判
		if(x==0)//特判y轴
		{
			if(y>0)
			{
				zheng[++cnt1].id=i;
				zheng[cnt1].r=(double)sqrt(x*x+y*y);
				zheng[cnt1].rad=1e20;//赋为无穷大
				zheng[cnt1].z=(double)z;
			}
			else
			{
				fu[++cnt2].id=i;
				fu[cnt2].r=(double)sqrt(x*x+y*y);
				fu[cnt2].rad=1e20;
				fu[cnt2].z=(double)z;
			}
		}
		else if(x>0)
		{
			zheng[++cnt1].id=i;
			zheng[cnt1].r=(double)sqrt(x*x+y*y);
			zheng[cnt1].rad=(double)y/x;
			zheng[cnt1].z=(double)z;
		}
		else
		{
			fu[++cnt2].id=i;
			fu[cnt2].r=(double)sqrt(x*x+y*y);
			fu[cnt2].rad=(double)y/x;
			fu[cnt2].z=(double)z;
		}
	}
	sort(zheng+1,zheng+cnt1+1,cmp);
	sort(fu+1,fu+cnt2+1,cmp);
	while(1)//模拟转圈过程
	{
		ok=0;
		vis.clear();
		for(int i=1;i<=cnt1;i++)
		{
			if(ans[zheng[i].id]!=-1) continue;//已经遍历过
			if(l<zheng[i].r) continue;//扫不到
			if(!vis[zheng[i].rad])
			{
				vis[zheng[i].rad]=1;
				ttt=tot+1;//新的theta才更新排名
			}
			ans[zheng[i].id]=ttt;
			l+=zheng[i].z;
			tot++;
			ok=1;
		}
		vis.clear();//这个真的真的真的真的很重要！！！
		for(int i=1;i<=cnt2;i++)//同上
		{
			if(ans[fu[i].id]!=-1) continue;
			if(l<fu[i].r) continue;
			if(!vis[fu[i].rad])
			{
				vis[fu[i].rad]=1;
				ttt=tot+1;
			}
			ans[fu[i].id]=ttt;
			l+=fu[i].z;
			tot++;
			ok=1;
		}
		if(ok==0) break;//没有任何点被修改则跳出循环
	}
	for(int i=1;i<=n;i++) printf("%d ",ans[i]);
	printf("\n");
	return 0;
}
```
一件有趣的事：之前不小心把其中的一个 $cnt1$ 写成 $cnt2$ 了，居然也是 $90$ 分。~~数据水啦！~~

---

## 作者：Ultraman_King (赞：1)

## 数学变换

原题中定义的角度和旋转（从 $y$ 轴为正方向，顺时针旋转）与传统的极坐标（从 $x$ 轴正方向，逆时针旋转）不同，需要做一些变换将其转变为传统极坐标方便处理。简单画个图就能知道，只需要将坐标系顺时针旋转 $90\degree$，再沿着新的 $x$ 轴（即旋转后的原 $y$ 轴）上下对称翻转即可：

![坐标变换](https://cdn.luogu.com.cn/upload/image_hosting/ejo3g3qe.png)

变换后坐标系已经符合传统极坐标的规则了。容易知道，假如原坐标系的点为 $(x,y)$，则它在变换后的新坐标系中的坐标为 $(y,x)$。使用复平面可以简单证明这个结论：设原复平面上有点 $z=x+\text i\;\!y$，顺时针旋转 $90\degree$ 相当于乘以 $-\text i$，上下翻转相当于求共轭复数。于是新复平面上的点为：
$$ z'=\overline{z\cdot(-\text i)}=\overline{(x+\text i\;\!y)\cdot(-\text i)}=\overline{y-\text i\;\!x}=y+\text i\;\!x $$

即新坐标系中点的坐标为 $(y,x)$。

于是，可以规定点 $(x,y)$ 的极角为以 $x$ 轴正向为 $0$，逆时针旋转的角度：第一象限 $\displaystyle \Big[ 0,\frac{\pi}{2} \Big)$、第二象限 $\displaystyle \Big[ \frac{\pi}{2},\pi \Big)$、第三象限 $\displaystyle \Big[ \pi,\frac{3\pi}{2} \Big)$、第四象限 $\displaystyle \Big[ \frac{3\pi}{2},2\pi \Big)$。可以使用 C++ 的 `std::atan2(y, x)` 函数来计算，第一、二象限的结果完全相同，函数返回 $[0, \pi)$；但是第三、四象限该函数会返回 $[-\pi,0)$，只需要简单将该结果加上 $2\pi$ 即可。

## 算法概述

将所有的点 $(x,y)$ 按照距离原点的长度 $x^2+y^2$ 从小到大排序后，使用**极角最小堆**来查询与棒子夹角最小的点。即：每次当棒子从 $L$ 伸长到 $L'$ 后，把所有 $ L^2 < x^2+y^2 \leq L'^2$ 的点都加入到**极角最小堆**中去，由于点已经按照从小到大的顺序排序了，所以只需要维护一个当前指针 `st`，循环 `while (st->Dist <= L * L) { AddToHeap(*st); ++st; }`，`st` 指针从头到尾至多扫描一遍，最多扫描 $\mathcal{O}(n)$ 次。

在将某个点 $(x,y)$ 按其极角 $\theta$ 添加到**极角最小堆**时需要考虑当前棒子的极角 $\phi$。

如果点位于棒子尚未扫描到的区域，即 $\theta \geq \phi$ 时，可以直接加入最小堆。

相反，如果点位于棒子已经扫描过的区域（$\theta < \phi$），则不能将它直接添加到最小堆里去，因为这时 $\theta$ 一定小于堆中的所有元素，而显然它不应该现在被访问到，而是应该等待棒子完全扫过一圈后再被访问。

此时需要准备一个 `std::vector` 用于保存所有应该在“下一圈”被访问的极角点，当 $\theta < \phi$ 时，就推入这个 `std::vector` 中。这样就保证了**极角最小堆**始终表示**位于棒子尚未刷过的区域中极角最小的点**。每次当**极角最小堆**为空时，将“下一圈” `std::vector` 中的元素全部推入**极角最小堆**即可。

综上，每个点至多进出 `std::vector` 一次，再至多进出最小堆一次，时间复杂度 $$\mathcal{O}(\log n)$$。

【举例】假设现在有如下三个点：$(2,2)$、$(0,3)$、$(-1,-1)$，则其极角分别为 $45\degree$、$90\degree$、$225\degree$；若棒子的极角 $\phi = 60\degree$、长度 $L=10$。按照算法描述，就需要把 $(0,3)$ 和 $(-1,-1)$ 推入**极角最小堆**，因为这两个点是棒子之后会刷到的区域，而 $(2,2)$ 就需要加入“下一圈” `std::vector` 中去。此时，最小堆中仅有这两个点，那下一个被棒子刷到的点将是 $(0,3)$，满足要求。

时间复杂度：$\mathcal{O}(n \log n)$、空间复杂度：$\mathcal{O}(n)$。

## 实现

直接使用 `std::priority_queue`，但需要重载相应的 `operator<` 使其按照“最小堆”比较。

```
#include <algorithm>
#include <cmath>
#include <iostream>
#include <numbers>
#include <queue>
#include <tuple>
#include <vector>

using namespace std;

// 将原坐标对调 (x,y) ↦ (y,x) 即能得到传统的与x轴的逆时针夹角

typedef long long i64;

struct Pt
{
	int Z, I;
	i64 Dist;
	double Deg;

	Pt(int x, int y, int z, int i)
		: Z{z}, I{i}, Dist{static_cast<i64>(x) * x + static_cast<i64>(y) * y}, Deg{atan2(y, x)}
	{
		if (Deg < 0) Deg += 2 * numbers::pi;
	}

	// 用于按长度从小到大的 std::sort
	bool operator<(const Pt &p2) const { return Dist < p2.Dist; }
};

typedef tuple<double, const Pt*> DegPt;
// 用于按角度的最小堆 std::priority_queue
bool operator<(const DegPt &d1, const DegPt &d2) { return get<0>(d1) > get<0>(d2); }

// 长度虽然可能超 2^63，但是在超过之前 pts 一定已经全部被加入到最小堆了，溢出的 L 不会造成副作用
i64 L;
double curDeg = 0;
vector<Pt> pts;
vector<int> seqs;
priority_queue<DegPt> degPts;
vector<DegPt> nxtDegPts;

// 将所有当前尚未加入最小堆的长度不超过 L 的点添加到最小堆
void RefreshDegPts()
{
	static auto st = pts.cbegin();
	for (auto L2 = L * L; st != pts.cend() && st->Dist <= L2; ++st)
		if (st->Deg >= curDeg) degPts.emplace(st->Deg, &(*st));
		else nxtDegPts.emplace_back(st->Deg, &(*st));
}

// 访问点，更新序列号，以及长度
void PickPt(int i, int z, double deg)
{
	static int curSeq = 1, nxtSeq = 1;
	if (deg != curDeg)
		curSeq = nxtSeq, curDeg = deg;
	seqs[i] = curSeq;
	++nxtSeq;
	L += z;
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);

	int n;
	cin >> n >> L;

	// 初始化所有点与序列答案，特殊处理 (0,0) 点
	seqs = vector<int>(n, -1);
	pts.reserve(n);
	for (int i = 0; i < n; ++i)
	{
		int x, y, z;
		cin >> x >> y >> z;
		if (x == 0 && y == 0) PickPt(i, z, 0);
		else pts.push_back({y, x, z, i});
	}

	// 将所有点按距离从小到大排序
	sort(pts.begin(), pts.end());

	do
	{
		// 从最小堆拿出最先刷到的点，更新序列答案并增加 L 长度
		for (RefreshDegPts(); !degPts.empty(); RefreshDegPts())
		{
			auto [_, pt] = degPts.top(); degPts.pop();
			PickPt(pt->I, pt->Z, pt->Deg);
		}
		// 将下一轮需要刷的点全部移动复制到最小堆
		degPts = priority_queue<DegPt>{std::less<DegPt>{}, move(nxtDegPts)};
	} while (!degPts.empty());

	for (auto s : seqs)
		cout << s << ' ';
	cout << endl;
	return 0;
}
```

---

## 作者：StarRain3 (赞：1)

#### 解题思路
思路上不算很难，但是码量有点大的一道计算几何。首先肯定要极角排序，按照棒旋转的方向对这些点进行排序。

排完以后，维护一颗线段树，这颗线段树维护的信息是点到原点的距离的平方的最小值。

要这颗线段树有什么用呢？

记棒当前的长度为 $len$，棒当前划到的点为 $last$。


那么棒想划到下一个点的话，就要在最后一个位置的后面一个开始，这些点里找到从左至右，指区间的左右，第一个到原点的距离的平方小于等于 $len2$。的点，如果不存在这样的点，那么就在开始到最后一个点中。

这些点里试着找到从左至右第一个到原点的距离的平方小于等于 $len2$ 的点，相当于在新的一圈里找，如果还是不存在这样的点，那说明再也找不到能划到的点了，就可以退出死循环了这个模型即每次返回 $q_l$ 和 $q_r$。

这段区间里从左至右第一个小于等于 $val$ 的元素的下标，不存在就返回 $−1$。

也比较常用的板子。
```
int search(int id, int l, int r, int ql, int qr, __int128 val)

{
    if (l == ql && r == qr)
    {
        if (seg[id].minv > val) 
            return -1;
        else
        {
            if (l == r)
                return l;
            int mid = l + r >> 1;
            if (seg[id << 1].minv <= val) 
                return search(id << 1, l, mid, ql, mid, val);
            else 
                return search(id << 1 | 1, mid + 1, r, mid + 1, qr, val);
        }
        return seg[id].minv;
    }
    int mid = l + r >> 1;
    if (qr <= mid)
        return search(id << 1, l, mid, ql, qr, val);
    else if (ql > mid)
        return search(id << 1 | 1, mid + 1, r, ql, qr, val);
    else
    {
        int pos = search(id << 1, l, mid, ql, mid, val);
        if (pos == -1)
            return search(id << 1 | 1, mid + 1, r, mid + 1, qr, val);
        else
            return pos;
    }
}
```
然后对于每一个扫过的点，我们把它到原点的距离的平方单点修改成无穷大即可，等价于它消失了，由于数据很大，要开快读与高精度。


#### 部分代码

主函数部分就是输入输出了，要想要完整代码同学私信。

```
void build(int id, int l, int r)
{
    if (l == r)
        seg[id].minv = a[l].x * a[l].x + a[l].y * a[l].y;
    else
    {
        int mid = l + r >> 1;
        build(id << 1, l, mid);
        build(id << 1 | 1, mid + 1, r);
        pushup(id);
    }
}
void change(int id, int l, int r, int pos, __int128 val)
{
    if (l == r)
        seg[id].minv = val;
    else
    {
        int mid = l + r >> 1;
        if (pos <= mid)
            change(id << 1, l, mid, pos, val);
        else
            change(id << 1 | 1, mid + 1, r, pos, val);
        pushup(id);
    }
}
int search(int id, int l, int r, int ql, int qr, __int128 val) 
{
    if (l == ql && r == qr) 
    {
        if (seg[id].minv > val) 
            return -1;
        else
        {
            if (l == r)
                return l;
            int mid = l + r >> 1;
            if (seg[id << 1].minv <= val) 
                return search(id << 1, l, mid, ql, mid, val);
            else 
                return search(id << 1 | 1, mid + 1, r, mid + 1, qr, val);
        }
        return seg[id].minv;
    }
    int mid = l + r >> 1;
    if (qr <= mid)
        return search(id << 1, l, mid, ql, qr, val);
    else if (ql > mid)
        return search(id << 1 | 1, mid + 1, r, ql, qr, val);
    else
    {
        int pos = search(id << 1, l, mid, ql, mid, val);
        if (pos == -1)
            return search(id << 1 | 1, mid + 1, r, mid + 1, qr, val);
        else
            return pos;
    }
}



---

## 作者：int_4096 (赞：0)

[传送门](https://www.luogu.com.cn/problem/P8777)
### 题意简述
输出被顺时针旋转的棒碰到点的排名顺序，其中棒碰到点后会瞬间增长。


---

### 暴力
还是一道很有趣的题。先从暴力入手。  
考虑它扫过的顺序，可以排序扫。

很明显按顺序扫一、四、三、二象限，然后扫斜率更大的，在斜率相同的时候先扫距离更近的。  
因为斜率也就对应着和 $y$ 轴的夹角大小，而先扫距离更近的是显然的吧。
```cpp
struct point {
	ll x, y, z;
	int pos, id; // pos表示所在象限 当然是顺时针编号的
	inline ll dis() {
		return x * x + y * y; // 避免使用double
	}
	bool operator < (point& rhs) {
		if(pos != rhs.pos) return pos < rhs.pos; //象限
		bool k = y * rhs.x == rhs.y * x; // 斜率
		if(!k) return y * rhs.x > rhs.y * x; // 也避免使用double
		return dis() < rhs.dis(); // 距离
	}
};
```


---

### 优化
这是一个朴素的 $O(n^2)$ 暴力，因为一轮遍历 $n$ 个点可能只扫到 $1$ 个。  
然后我们考虑优化这个暴力，发现时间主要花在找到下一个能扫到的点上。我们想快速的找到这个点，于是我们对**排过序的点**维护一棵线段树，记录一段区间内**距离原点最小的距离**，然后在线段树上二分**最靠左**（也就是最先扫到的）的能扫的点即可。  
实现时可以将所有线段树上映射的区间都取出来，找到能扫到的最靠左的，再在上面二分。
### code:
```cpp
#include <cstdio>
#include <algorithm>
typedef long long ll;
const int N = 200005;
ll n;
__int128 L;
struct point {
	ll x, y, z;
	int pos, id;
	inline ll dis() {
		return x * x + y * y;
	}
	bool operator < (point& rhs) {
		if(pos != rhs.pos) return pos < rhs.pos;
		if(y * rhs.x != rhs.y * x) return y * rhs.x > rhs.y * x;
		return dis() < rhs.dis();
	}
};
point p[N];
int ans[N];
ll tsL;
#define ls(u) (u << 1)
#define rs(u) ((u << 1) | 1)
const __int128 INF = 1e30;
__int128 mn[N << 2];
void maintain(int u) {
	mn[u] = std::min(mn[ls(u)], mn[rs(u)]);
}
void build(int u, int s, int t) {
	if(s == t) {
		mn[u] = p[s].dis();
		return ;
	}
	int mid = (s + t) >> 1;
	build(ls(u), s, mid);
	build(rs(u), mid + 1, t);
	maintain(u);
}
struct Seg {
	int u, s, t;
};
Seg stk[2000];
int pstk; 
void query(int u, int l, int r, int s, int t) {
	if(l <= s && t <= r) {
		stk[++pstk] = {u, s, t}; // 拿出所有的区间
		return ;
	}
	int mid = (s + t) >> 1;
	if(l <= mid) query(ls(u), l, r, s, mid);
	if(r > mid) query(rs(u), l, r, mid + 1, t);
}
int binSearch(int u, int s, int t) { // 二分
	if(s == t) {
		mn[u] = INF; // 删除
		while(1) {
			u >>= 1;
			if(u == 0) break;
			maintain(u); // 向上更新
		}
		return s;
	}
	int mid = (s + t) >> 1;
	int ans = -1;
	if(mn[ls(u)] <= L * L) ans = binSearch(ls(u), s, mid); // 优先往左走
	else if(mn[rs(u)] <= L * L) ans = binSearch(rs(u), mid + 1, t);
	return ans;
}
bool is_same_k(point a, point b) {
	return a.pos == b.pos ? a.y * b.x == b.y * a.x: 0; // 注意判断象限，一三象限可以斜率相同
}
int cnt, gcnt;
bool is_lst = 0;
point lst = {0, 0, 0, 0, 0};
bool get(int& pos) { // 当前扫到 pos 个，求下一个
	pstk = 0;
	query(1, pos + 1, n, 1, n); // 查线段树
	for(int i = 1; i <= pstk; i++) {
		Seg& c = stk[i];
		if(mn[c.u] <= L * L) { // 这个区间里有
			int u = binSearch(c.u, c.s, c.t);
			L += p[u].z;
			if(is_lst) {
				if(is_same_k(p[u], lst)) // 判是否与上一个斜率相同
					ans[p[u].id] = cnt, gcnt++;
				else cnt = ++gcnt, ans[p[u].id] = cnt;
				lst = p[u];
			} else {
				ans[p[u].id] = (gcnt = cnt = 1);
				is_lst = 1;
				lst = p[u];
			}
			pos = u;
			return 1;
		}
	}
	return 0;
}
int main() {
	//qwq
	scanf("%lld%lld", &n, &tsL);
	L = tsL;
	for(int i = 1, x, y, z; i <= n; i++) {
		scanf("%d%d%d", &x, &y, &z);
		int pos = 0;
		if(x >= 0 && y >= 0) pos = 1;
		if(x >= 0 && y <= 0) pos = 2;
		if(x <= 0 && y <= 0) pos = 3;
		if(x <= 0 && y >= 0) pos = 4;
		if(x == 0 && y == 0) pos = -1; // 特判 (0, 0)
		p[i] = {x, y, z, pos, i};
	}
	std::sort(p + 1, p + 1 + n);
	build(1, 1, n);
	int cur_pos = 0;
	while(1) {
		if(cur_pos == n) cur_pos = 0; // 之后没有可以查的跳回开头
		if(!get(cur_pos)) { // 找不到
			cur_pos = 0; // 同理跳回开头
			if(!get(cur_pos)) // 还找不到就不可能找到了
				break;
		}
	}
	for(int i = 1; i <= n; i++)
		printf("%d%c", ans[i] ? ans[i] : -1, " \n"[i == n]);
	return 0;
}
```

---

### 补充：
因为 $L$ 可能达到 $10^{14}$ 量级，再平方就直接炸 `long long` 了，所以需要开 `__int128`。  
这道题竟然认为 $(0, 0)$ 一开始就扫到，所以特判 `pos = -1`。

---


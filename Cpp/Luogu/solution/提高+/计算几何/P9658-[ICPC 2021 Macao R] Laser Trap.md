# [ICPC 2021 Macao R] Laser Trap

## 题目描述

最近，BaoBao 正在玩著名的游戏 $Elden Ring$。这是一款开放世界游戏，你可以控制角色在各个地方旅行。然而，你的角色也可能会进入陷阱，你需要想办法逃脱。现在，BaoBao 的角色被困在一个有致命激光的二维平面上。平面上有 $n$ 个激光发生器（每个可以看作一个点），它们之间的每一对都会发射激光束（因此总共有 $\frac{n(n-1)}{2}$ 条激光束）。这些激光束从发生器点开始并在发生器点结束，不会延伸到无限远。

从点 $(0,0)$ 开始，BaoBao 想要逃到点 $(10^{10^{10^{10^{10}}}}, 10^{10^{10^{10^{10}}}})$，而不触碰任何激光束或发生器。为了做到这一点，BaoBao 可以请求她的朋友 DreamGrid 移除任意数量的激光发生器，以及从这些发生器开始或结束的任何激光束。输出为逃脱所需移除的最小激光发生器数量。

注意，BaoBao 不需要沿特定方向移动以逃脱。如果有必要，她的逃生路线甚至可以是曲线。

## 说明/提示

第二个和第三个样例测试用例如下所示。实心点和线代表剩余的激光发生器和光束，而空心点和虚线代表被移除的激光发生器和光束。箭头是逃生路线。

![](https://cdn.luogu.com.cn/upload/image_hosting/b0sz7cm0.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/dwcsdmj6.png)

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
3
2
1 0
2 0
3
1 0
0 1
-1 -1
5
2 -1
1 2
-1 2
-2 -1
0 -2```

### 输出

```
0
1
2```

# 题解

## 作者：SDLTF_凌亭风 (赞：1)

我超！计算几何！

先进行一次极角排序，然后用双指针找最小删除量即可。

注意，如果你使用化环为链，空间记得**开两倍**，否则喜提 RE。

```cpp
cin >> n;
for(int i = 1; i <= n; ++ i) cin >> pts[i].x >> pts[i].y;
sort(pts + 1, pts + 1 + n);
for(int i = 1; i <= n; ++ i) pts[i + n] = pts[i]; // 化环为链
for(int i = 1; i <= n;) {
    for(int j = i + 1; j <= n; ++ j) if (!(pts[i] == pts[j])) break;
    nxt[i] = j, nxt[n + i] = n + j;
    i = j;
}
int res = n;
for (int i = 1, j = 1; i <= n; i = nxt[i]) { // 双指针
    while (j < n + i && (i == j || check(pts[i], pts[j]))) j = nxt[j];
    res = (j == n + i) ? 0 : min(res, j - nxt[i]);
}
cout << res << '\n';
```

---

## 作者：ccg12345 (赞：0)

并没有场切本题，于是赛后来写篇题解。

## 题意简化

二维平面中有若干个激光光源，光源之间两两连线形成一道激光，一个人 $(0, 0)$ 处，问至少删掉几个激光光源才能时这个人不被激光困住。

## 思路

计算几何！！！

本题可以先化环为链：

```
for(int i = n + 1; i <= 2 * n; i++) 
	pt[i] = pt[i - n];
```

然后将所有光源进行极角排序，这里简单介绍一下极角排序：

在平面内取一个定点 O，称为极点，过点 O 引一条射线 $x$，称为极轴，再选定一个长度单位和角度的正方向（大部分时候取逆时针方向）。

对于平面内任何一点 M，用 $ρ$ 表示线段 OM 的长度（也可用 $r$ 表示），$θ$ 表示从 $x$ 到 OM 的角度，那么 $ρ$ 就称为点 M 的极径，$θ$ 称为点 M 的极角，有序数对 $(ρ,θ)$ 就叫点M的极坐标。

给定平面上的一些点，把它们按照一个选定的中心点排成顺（逆）时针，称为极角排序。

这里要注意的是极角排序有两种方法，即 cmath 库中的 atan2 函数与叉积，由于本蒟蒻怕被卡精度就选择了后者。

起点和终点逆时针角度相差不超过 $π$ 的点都可以全选，那么我们用双指针方法就可以简单地在 $O(n)$ 内求解。

虽然思路大家已经知道了，但是代码写起来还是有很多坑点的，比如空间要开 $2$ 倍（可能只是我太菜了）。

[代码](https://www.luogu.com.cn/paste/253c7aiq) and [评测记录](https://www.luogu.com.cn/record/126786136)。


---

## 作者：封禁用户 (赞：0)

这题其实是一道计算几何的题目。

我的队友一看到这题就切了。。

思路：

这题可以不用双链表，可以用一个函数，不错是 ```atan2l``` 函数，这个函数的主要作用是计算两个坐标点之间的夹角，范围是 $-π$ 到 $π$（$-180\sim 180$ 度）。

之后进行排序，再判断当前激光发生器与起点之间的夹角范围内存在其他激光发生器，就行了。

代码：

```
	while(t--) {
		cin>>n;
		rep(i,1,n) {
			int u,v;
			cin>>u>>v;
			a[i] = atan2l(1.0*v,1.0*u);
		}
		sort(a+1,a+1+n);
		rep(i,1,n) a[i+n]=a[i]+2*pi;
		int j=1,minn=1e9;
		rep(i,1,n) {
			while(j<=(n<<1) and a[j]-a[i]<pi) j++;
			minn=min(minn,j-i-1);
		}
		cout<<minn<<'\n';
	}
```

---


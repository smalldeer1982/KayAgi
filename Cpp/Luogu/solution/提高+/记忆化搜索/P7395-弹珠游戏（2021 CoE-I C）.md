# 弹珠游戏（2021 CoE-I C）

## 题目描述

$\operatorname{Alice}$ 对弹珠游戏已经有些厌烦了，她经常在电脑上玩这个游戏。她之所以感到厌烦是因为在这个游戏上她已经是专家级别，她总是能够和电脑打成平手。$\operatorname{Bob}$ 为 $\operatorname{Alice}$ 创造了一款新的电脑游戏。以下是这款两人电脑游戏的规则：

（1）游戏在如下图所示的菱形棋盘上进行；

![](https://cdn.luogu.com.cn/upload/image_hosting/qw7lsky0.png)

（2）两名玩家轮流放置弹珠，可以在横向、纵向、$45$ 度斜线、$135$ 度斜线方向未放置弹珠的位置**连续放置 $1$ 至 $3$ 颗弹珠**，玩家在可以放置弹珠的情况下，必须至少放置 $1$ 颗弹珠。以下是合法的单次放置操作的示例（黑色圆点表示放置了弹珠，白色圆点表示未放置弹珠，进行该次操作前棋盘为空）：

![](https://cdn.luogu.com.cn/upload/image_hosting/v38tajmr.png)

以下是非法的单次放置操作的示例（黑色圆点表示放置了弹珠，白色圆点表示未放置弹珠，进行该次操作前棋盘为空）：

![](https://cdn.luogu.com.cn/upload/image_hosting/mldg0cs0.png)

非法原因的解释：（$a$）三颗弹珠不在同一条斜线（或者垂直线）上；（$b$）两颗弹珠之间相隔一个空位；（$c$）三颗弹珠不在同一条斜线上；（$d$）三颗弹珠不在同一条斜线（或者垂直线）上；（$e$）一次性放置了 $4$ 颗弹珠；（$f$）三颗弹珠不在同一条水平线（或者垂直线、或者斜线）上。

（3）如果某位玩家无法再继续放置弹珠，则该名玩家输掉游戏，另外一名玩家获胜。

$\operatorname{Alice}$ 总是第一个进行游戏，而且经常是和 $\operatorname{Bob}$ 玩这个游戏，$\operatorname{Bob}$ 在进行若干游戏操作后可能会离开，将游戏交由电脑代理，电脑总是按照最优策略放置弹珠。
给定 $\operatorname{Bob}$ 离开后的游戏状态，你的任务是确定 $\operatorname{Alice}$ 是否可能在对阵电脑时获得胜利。

## 说明/提示

#### 样例说明

第一组数据，$\operatorname{Alice}$ 可以选择在棋盘左下角的斜线方向所剩下的 $3$ 个空余位置一次性连续放置 $3$ 颗弹珠，使得后续电脑无法再放置弹珠，因此 $\operatorname{Alice}$ 能够获胜。

第二组数据，$\operatorname{Alice}$ 可以选择沿着第四行剩下的 $3$ 个空余位置一次性连续放置 $3$ 颗弹珠，使得后续电脑无法再放置弹珠，因此 $\operatorname{Alice}$ 能够获胜。

第三组数据，棋盘剩下倒数第二列两个连续的空余位置，$\operatorname{Alice}$ 可以一次放置 $2$ 颗弹珠，使得后续电脑无法放置弹珠，因此 $\operatorname{Alice}$ 会获胜。

第四组数据，类似于第二组测试数据，棋盘剩下第三行两个连续的空余位置，因此 $\operatorname{Alice}$ 会获胜。

第五组数据，棋盘只剩下两个不连续的空余位置，由于 $\operatorname{Alice}$ 一次只能选择一个空余位置放置 $1$ 颗弹珠，因此不管 $\operatorname{Alice}$ 如何操作，电脑总能一次性将剩下的棋盘使用弹珠填满，使得 $\operatorname{Alice}$ 无法再继续放置弹珠，因此 $\operatorname{Alice}$ 会输掉比赛。

第六组数据，$\operatorname{Alice}$ 可以选择在棋盘右上角斜线方向的中间两个空余位置放置 $2$ 颗弹珠，使得棋盘状态转化为样例输入的第五组数据，因此 $\operatorname{Alice}$ 会赢得比赛。


------------

#### 数据范围

对于 $10\%$ 的数据，$0 \lt T \leq 10$。

对于 $60\%$ 的数据，$0 \lt T \leq 10^3$。

对于 $80\%$ 的数据，$0 \lt T \leq 10^5$。

对于 $100\%$ 的数据，$0 \lt T \leq 10^6$。


------------

#### 提示

本题输入量较大，请使用合适的读入方式。

## 样例 #1

### 输入

```
6

   *
  * *
 * * *
* * * *
 . * *
  . *
   .

   *
  * *
 * * *
. . . *
 * * *
  * *
   *

   *
  * *
 * * .
* * * *
 * * .
  * *
   *

   *
  * *
 . . *
* * * *
 * * *
  * *
   *

   .
  * *
 * * *
* * * .
 * * *
  * *
   *

   .
  * .
 * * .
* * * .
 * * *
  * *
   *```

### 输出

```
Possible.
Possible.
Possible.
Possible.
Impossible.
Possible.```

# 题解

## 作者：cmll02 (赞：6)

一共就 $65536$ 种不同状态，我直接状态压缩再打表！

棋盘斜的比较难受，转 $45\degree$ 就行了。

走棋还是横竖斜都可以。

首先写个 dfs 来出表：（注意记忆化）

预处理 $65535$ 是必败态，然后就有了如下：

```cpp
#include <stdio.h>
#include <string.h>
struct state{
	int a[4][4];
	state operator=(state b)
	{
		memcpy(a,b.a,sizeof(int)*16);
	}
	int operator()()
	{
		int num=0;
		int p=1;
		for(int i=3;~i;i--)
			for(int j=3;~j;j--)
				num+=p*a[i][j],p<<=1;
		return num;
	}
};
int mmr[1<<16+5];
int dir[4][2]={1,0,0,1,1,1,1,-1};
#define s x.a
int cnt=0;
void dfs(state x)
{
	if(mmr[x()]!=-1)return;
	mmr[x()]=0;
	cnt++;
	//printf("%d\n",x());
	for(int i=0;i<4;i++)
	{
		for(int j=0;j<4;j++)
		{
			if(x.a[i][j])continue;
			x.a[i][j]=1;
			dfs(x);
			if(mmr[x()]==0)
			{
				x.a[i][j]=0;
				mmr[x()]=1;
			}
			x.a[i][j]=0;
			for(int d=0;d<4;d++)
			{
				state p=x;
				p.a[i][j]=1;
				int ii=i,jj=j;
				for(int iii=0;iii<2;iii++)
				{
					ii+=dir[d][0],jj+=dir[d][1];
					if(x.a[ii][jj]||ii<0||jj<0||ii>3||jj>3)break;
					p.a[ii][jj]=1;
					dfs(p);
					if(mmr[p()]==0)
					{
						mmr[x()]=1;
					}
				}
			}
		}
	}
}
#undef s
int main()
{
	memset(mmr,-1,sizeof(mmr));
	mmr[65535]=0;
	state s;
	memset(s.a,0,sizeof(int)*16);
	dfs(s);
	freopen("ChuLeWoYiWaiDeSuoYouRenDouAKIOI.orz","w",stdout);
	for(int i=0;i<65536;i++)printf("%d",mmr[i]);
}
```

然后就出现了一个表。

直接扔到字符串里一交。

![我不能 AKIOI](https://cdn.luogu.com.cn/upload/image_hosting/w13tvst6.png)

然后一看，这个表有 $65536$ 个 `0` 或 `1`，太占代码空间。

于是随便三个数二进制压缩一下：（这里我在原来的文件后面加了两个 $0$）

```cpp
#include <stdio.h>
int main()
{
	freopen("ChuLeWoYiWaiDeSuoYouRenDouAKIOI.orz","r",stdin);
	freopen("ChuLeWoYiWaiDeSuoYouRenDouAKIOI.sto","w",stdout);
	for(int i=0;i<65538/3;i++)
	{
		int aaaa=getchar()-48;
		int aa=getchar()-48;
		int a=getchar()-48;
		printf("%d",aaaa*4+aa*2+a);
	}
}
```

然后就能交了。最终代码：

```cpp
#include <stdio.h>
char c[]="之前生成的表，由于太大我没放下来。";
int cc=0;
inline int w(int x)
{
	char c=getchar();
	while(c!='*'&&c!='.')c=getchar();
	if(c=='*')cc+=(1<<x);
}//状态压缩
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		cc=0;
		w(3);
		w(2);
		w(7);
		w(1);
		w(6);
		w(11);
		w(0);
		w(5);
		w(10);
		w(15);
		w(4);
		w(9);
		w(14);
		w(8);
		w(13);
		w(12);
		int qaq=(c[cc/3]-48)>>(2-cc%3);
		qaq&=1;
		if(qaq)puts("Possible.");
		else puts("Impossible.");
	}
}
```

---

## 作者：metaphysis (赞：5)

[题目链接](https://www.luogu.com.cn/problem/T154240?contestId=40766)

本题是一道博弈论的题目，需要确定给定的某个状态是必胜态还是必败态，可以使用递归加备忘的方式予以确定。

初看似乎给定的棋盘和放置方式难以处理，实际上，只需将棋盘逆时针（或顺时针）旋转45度，所得到的就是一个水平方向的棋盘，在水平方向的棋盘上处理就容易得多了。在读入数据时对棋盘进行一个简单的位置映射即可。

为了便于解题，将棋盘的状态转换为一个二进制数。方法：放置弹珠的位置对应的二进制位为 $1$，未放置弹珠的位置对应的二进制位为 $0$。容易知道，当棋盘放满弹珠时，对于 $\operatorname{Alice}$ 来说是必败态，即 `dp[(1 << 16) - 1] = 0;`。接着通过递归来确定当前状态所对应的整数 $x$ 是必胜态还是必败态。

如果棋盘的某个位置为空，那么从此位置开始向右、向下、向右下三个方向逐次检查，是否能连续放置 $1$ 颗、$2$ 颗、$3$ 颗弹珠，如果能够放置，则将对应的二进制位置为 $1$。对于状态 $x$ 的所有后继状态来说，如果有至少一个后继状态 $y$ 是必败态，那么表明当前状态 $x$ 是必胜态，即 `dp[x] = 1;`。如果检查所有的后继状态均为必胜态，那么当前状态 $x$ 为必败态，即 `dp[x] = 0;`。

应用备忘技巧可以避免重复解决子问题，提高程序效率，否则很容易超时。

由于输入较多，需要应用快读以提高输入效率。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int LENGTH = (1 << 20);

inline int nextChar()
{
    static char buffer[LENGTH], *p = buffer, *end = buffer;
    if (p == end) {
        if ((end = buffer + fread(buffer, 1, LENGTH, stdin)) == buffer) return EOF;
        p = buffer;
    }
    return *p++;
}

inline bool nextInt(int &x)
{
    static char negative = 0, c = nextChar();
    negative = 0, x = 0;
    while ((c < '0' || c > '9') && c != '-')
    { if (c == EOF) return false; c = nextChar(); }
    if (c == '-') { negative = 1; c = nextChar(); }
    do x = (x << 3) + (x << 1) + c - '0'; while ((c = nextChar()) >= '0');
    if (negative) x = -x;
    return true;
}

int cache[1 << 16], offset[4][2] = {{0, 1}, {1, 0}, {1, 1}, {1, -1}};

int dfs(int x)
{
    if (~cache[x]) return cache[x];
    for (int i = 0; i < 16; i++)
    {
        if (x & (1 << i)) continue;
        int r = i / 4, c = i % 4;
        for (int j = 0; j < 4; j++)
        {
            int bit = 0;
            for (int k = 0; k < 3; k++)
            {
                int rr = r + offset[j][0] * k, cc = c + offset[j][1] * k;
                if (rr < 0 || rr > 3 || cc < 0 || cc > 3) break;
                if (x & (1 << (rr * 4 + cc))) break;
                bit |= (1 << (rr * 4 + cc));
                if (!dfs(x ^ bit)) return cache[x] = 1;
            }
        }
    }
    return cache[x] = 0;
}

int matrix[16] = {0, 4, 1, 8, 5, 2, 12, 9, 6, 3, 13, 10, 7, 14, 11, 15};

int main(int argc, char *argv[])
{
    cin.tie(0), cout.tie(0), ios::sync_with_stdio(false);

    memset(cache, -1, sizeof(cache));
    cache[(1 << 16) - 1] = 0;
    
    int cases;
    nextInt(cases);
    for (int cs = 1; cs <= cases; cs++)
    {
        int mask = 0, cnt = 0;
        char character;
        while (cnt < 16)
        {
            character = nextChar();
            if (character == '*' || character == '.')
            {
                if (character == '*')
                    mask |= (1 << matrix[cnt]);
                cnt++;
            }
        }
        cout << (dfs(mask) ? "Possible." : "Impossible.") << '\n';
    }

    return 0;
}
```

---

## 作者：youngk (赞：3)

（这个做法在赛事的时候会TLE,需要打表才能过，但是赛后直接提交可以通过）

显然这是一个博弈论的题目，比较无脑的想法就是计算他的sg函数，显然这只有16个点，只考虑$2^{16}$个状态，可以考虑把他旋转45°，这样比较好处理。

显然根据sg函数的算法，是其所有子状态的MEX，难点在于怎么枚举其所有的子状态。

计算方法首先不妨将每个点都枚举，分布向上向下向，向左向右，两个斜对角扩散。其实向上向下就是在$+4,-4$，向左向右是在$+1,-1$，两个斜对角是左上到右下是$+5,-5$，左下到右上是$+3,-3$。在预处理出每个的边界（不能超过边界，同时不能连续超过两个，预处理的表可以先转成2维的，再转回一维的计算sg函数的值）

具体实现过程可以看代码

```pascal
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define maxn 16
int dx[] = {
        0, 4, 1, 8, 5, 2, 12, 9, 6, 3, 13, 10, 7, 14, 11, 15
};
int sg[1 << maxn];
int _l[6][maxn], _r[6][maxn];
int getsg(int x);
void f(int x, int k, int i, unordered_set<int> &s) {
    int l = i, r = i, L = _l[k][i], R = _r[k][i];
    while (l - k >= 0 && ((x >> (l - k)) & 1) == 0 && l > L) { l -= k; }
    while (r + k < maxn && ((x >> (r + k)) & 1) == 0 && r < R) { r += k; }
    for (int j = l; j <= i; j += k) {
        for (int kk = i; kk <= min(r, l + 2 * k); kk += k) {
            int X = x;
            for (int o = j; o <= kk; o += k)X ^= (1 << o);
            s.insert(getsg(X));
        }
    }
}
int getsg(int x) {
    if (~sg[x])return sg[x];
    unordered_set<int> s;
    for (int i = 0; i < maxn; i++) {
        if (((x >> i) & 1) == 0) {
            f(x, 1, i, s);
            f(x, 4, i, s);
            f(x, 3, i, s);
            f(x, 5, i, s);
        }
    }
    for (int i = 0;; i++) {
        if (s.count(i) == 0)return sg[x] = i;
    }
}
void pre() {
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            int cnt = 0, li = i, ri = i, lj = j, rj = j;
            while (lj > 0 && cnt < 2) { lj--, cnt++; }
            cnt = 0;
            while (rj < 3 && cnt < 2) { rj++, cnt++; }
            _l[1][i * 4 + j] = li * 4 + lj, _r[1][i * 4 + j] = ri * 4 + rj;
        }
    }
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            int cnt = 0, li = i, ri = i, lj = j, rj = j;
            while (li > 0 && cnt < 2) { li--, cnt++; }
            cnt = 0;
            while (ri < 3 && cnt < 2) { ri++, cnt++; }
            _l[4][i * 4 + j] = li * 4 + lj, _r[4][i * 4 + j] = ri * 4 + rj;
        }
    }
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            int cnt = 0, li = i, ri = i, lj = j, rj = j;
            while (li > 0 && lj < 3 && cnt < 2) { lj--, lj++, cnt++; }
            cnt = 0;
            while (ri < 3 && rj > 0 && cnt < 2) { ri++, rj--, cnt++; }
            _l[3][i * 4 + j] = li * 4 + lj, _r[3][i * 4 + j] = ri * 4 + rj;
        }
    }
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            int cnt = 0, li = i, ri = i, lj = j, rj = j;
            while (li > 0 && lj > 0 && cnt < 2) { lj--, lj--, cnt++; }
            cnt = 0;
            while (ri < 3 && rj < 3 && cnt < 2) { ri++, rj++, cnt++; }
            _l[5][i * 4 + j] = li * 4 + lj, _r[5][i * 4 + j] = ri * 4 + rj;
        }
    }
}
int t, x;
char ch;
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    pre();
    memset(sg, -1, sizeof(sg));
    sg[(1 << maxn) - 1] = 0;
    cin >> t;
    while (t--) {
        x = 0;
        for (int i : dx) {
            cin >> ch;
            if (ch == '*')x ^= (1 << i);
        }
        if (getsg(x) == 0) {
            cout << "Impossible." << endl;
        } else {
            cout << "Possible." << endl;
        }
    }
    return 0;
}
```


---

## 作者：cirnovsky (赞：2)

## Description

[Link](https://www.luogu.com.cn/problem/P7395).

- 游戏在 $4\times4$ 的菱形棋盘上进行；

- 两名玩家轮流放置弹珠，可以在横向、纵向、$45$ 度斜线、$135$ 度斜线方向未放置弹珠的位置**连续放置 $1$ 至 $3$ 颗弹珠**，玩家在可以放置弹珠的情况下，必须至少放置 $1$ 颗弹珠。

- 如果某位玩家无法再继续放置弹珠，则该名玩家输掉游戏，另外一名玩家获胜。

## Solution

虽然是套路，但毕竟是之前没做过的套路，写篇题解记一下。

首先我们可以直接考虑状压，棋盘编号见图：

![](https://cdn.luogu.com.cn/upload/image_hosting/kbssujap.png)

然后你打个表出来，表示所有能走的情况（状压），比如我要放棋子在 $1-5-9$ 上面，就是 $(100010001)_{2}$。

因为是用 C++ 输出的形式手打的 $82$ 种情况表，所以 generator 就不附了。

然后你打个 DP，设 $f_{S}$ 为当前棋盘状态为 $S$（$S$ 的第 $i$ 为 $1$ 表示这个格子被占据，反之亦然）是先手必胜还是先手必输或者不知道（分别对应数字 $1/0/-1$）。

初始状态为 $\forall i\in[0,2^{n}-1),f_{i}=-1$；$f_{2^{n}-1}=0$。

然后你记搜一下，把所有状态搜出来。

然后就回答询问即可，只是不太清楚为什么要搞这么多字符读入卡 IO，明明多不多组都一样。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n=7,m[8]={1,2,3,4,3,2,1},id,f[(1<<16)+10];
char s[10];
const int upper=(1<<16);
const int ID[10][10]={{0},{4,1},{8,5,2},{12,9,6,3},{13,10,7},{14,11},{15}};
const int walking[90]={1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,17,3,18,272,48,34,6,288,36,4352,768,544,96,68,12,4608,576,72,12288,8704,1536,1088,192,9216,1152,24576,17408,3072,2176,18432,49152,34816,33,528,66,8448,1056,132,16896,2112,33792,136,273,7,1057,4368,16912,112,546,2114,14,292,1792,8736,224,33824,1092,4672,584,28672,3584,17472,2184,9344,57344,34944};
inline int unionset(int x,int y){return x|y;}
inline int intersection(int x,int y){return x&y;}
inline bool emptyset(int x){return x==0;}
void dfs(int board)
{
	if(~f[board])	return;
	for(int i=0;i<82;++i)
	{
		if(emptyset(intersection(board,walking[i])))
		{
			int newset=unionset(board,walking[i]);
			dfs(newset);
			if(f[newset]==0)
			{
				f[board]=1;
				return;
			}
		}
	}
	f[board]=0;
}
inline char fgc()
{
	static char buf[1<<17],*p=buf,*q=buf;
	return p==q&&(q=buf+fread(p=buf,1,1<<17,stdin),p==q)?EOF:*p++;
}
inline char fgop()
{
	char res=0;
	while((res^'*')&&(res^'.'))	res=fgc();
	return res;
}
inline void read(int &x)
{
	x=0;
	char c=fgc();
	while(isdigit(c)==0)	c=fgc();
	while(isdigit(c))	x=(x<<3)+(x<<1)+(c^'0'),c=fgc();
}
int main()
{
	read(t);
	memset(f,-1,sizeof(f));
	f[upper-1]=0;
	for(int i=0;i^upper;++i)
	{
		if(f[i]==-1)	dfs(i);
	}
	while(t--)
	{
		int board=0;
		for(int i=0;i<n;++i)
		{
			for(int j=0;j<m[i];++j)	board+=(fgop()=='*')?(1<<ID[i][j]):0;
		}
		printf(f[board]?"Possible.":"Impossible.");
		printf("\n");
	}
	return 0;
}
```

---


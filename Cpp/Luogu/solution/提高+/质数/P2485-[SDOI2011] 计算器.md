# [SDOI2011] 计算器

## 题目背景

2024-8-11 update: 新增一组 hack。

## 题目描述

你被要求设计一个计算器完成以下三项任务：

1. 给定 $y,z,p$，计算 $y^z \bmod p$ 的值；
2. 给定 $y,z,p$，计算满足 $xy \equiv z \pmod p$ 的最小非负整数 $x$；
3. 给定 $y,z,p$，计算满足 $y^x \equiv z \pmod p$ 的最小非负整数 $x$。

为了拿到奖品，全力以赴吧！


## 说明/提示

测试点共分为三类，各类测试点占总测试点的比例如下：

| $K=$ | 测试点占比 |
| :--: | :--------: |
| $1$  |   $20\%$   |
| $2$  |   $35\%$   |
| $3$  |   $45\%$   |

所有数据均满足：$1 \leq y,z,p \leq 10^9$，$p$ 是质数，$1 \leq T \leq 10$。

## 样例 #1

### 输入

```
3 1
2 1 3
2 2 3
2 3 3
```

### 输出

```
2
1
2
```

## 样例 #2

### 输入

```
3 2
2 1 3
2 2 3
2 3 3
```

### 输出

```
2
1
0
```

## 样例 #3

### 输入

```
4 3
2 1 3
2 2 3
2 3 3
2 4 3
```

### 输出

```
0
1
Orz, I cannot find x!
0
```

# 题解

## 作者：追梦_Chen (赞：6)

**## 这题考察的是对同余已经拓展欧几里得定理的理解和运用，顺带一个模板快速幂**
# 前置姿势
1.快速幂

2.拓展欧几里得定理

3.baby_step_giant_step算法求高次同余方程


------------

# 对于1号操作，我们用快速幂直接求解

```cpp
long long pow_mod(long long a,long long b,long long p){
	long long ans=1;
	while(b){
		if(b&1){
			ans=(long long)ans*a%p;
		}
		a=(long long)a*a%p;
		b=b/2;
	}
	return ans;
}
```

# 对于2号操作，就是一个拓展欧几里得定理的运用

```cpp
long long exgcd(long long a,long long b,long long &x1,long long &y2){
	if(b==0){
		x1=1,y2=0;
		return a;
	}
	long long d=exgcd(b,a%b,x1,y2);
	long long z=x1;x1=y2;y2=z-y2*(a/b);
	return d;
}
特别注意，根据提议要求，我们要先判断z%gcd(y,p)是否为0，若不为0，则说明z不能整除gcd(y,p)，不满足裴蜀定理，方程误解
```

# 对于3号操作，，其实就是高次同余方程求解，我们可以用baby_step_giant_step算法


```cpp
long long baby_step_giant_step(long long a,long long b,long long p){
	map<long ,long>hash;
	hash.clear();
	b%=p;
	int t=(int)sqrt(p)+1;
	for(int j=0;j<t;j++){
		int val=(long long)b*pow_mod(a,j,p)%p;
		hash[val]=j;
	}
	a=pow_mod(a,t,p);
	if(a==0){
		if(b==0){
			return 1;
		}else{
			return -1;
		}
	}
	for(int i=0;i<=t;i++){
		int val=pow_mod(a,i,p);
		int j=hash.find(val)==hash.end()?-1:hash[val];
		if(j>=0&&i*t-j>=0){
			return i*t-j;
		}
	}
	return -1;//无解时返回-1
}
```

##### ##### ###### 嗯！前置姿势准备好了，我们就可以直接贴代码了！

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <map>
using namespace std;
long long pow_mod(long long a,long long b,long long p){
	long long ans=1;
	while(b){
		if(b&1){
			ans=(long long)ans*a%p;
		}
		a=(long long)a*a%p;
		b=b/2;
	}
	return ans;
}//快速幂求解 
long long exgcd(long long a,long long b,long long &x1,long long &y2){
	if(b==0){
		x1=1,y2=0;  
		return a; 
	}
	long long d=exgcd(b,a%b,x1,y2);
	long long z=x1;x1=y2;y2=z-y2*(a/b);
	return d;
}//拓展欧几里得算法 
long long baby_step_giant_step(long long a,long long b,long long p){
	map<long ,long>hash;
	hash.clear();
	b%=p;
	int t=(int)sqrt(p)+1;
	for(int j=0;j<t;j++){
		int val=(long long)b*pow_mod(a,j,p)%p;
		hash[val]=j;
	}
	a=pow_mod(a,t,p);
	if(a==0){
		if(b==0){
			return 1;
		}else{
			return -1;
		}
	}
	for(int i=0;i<=t;i++){
		int val=pow_mod(a,i,p);
		int j=hash.find(val)==hash.end()?-1:hash[val];
		if(j>=0&&i*t-j>=0){
			return i*t-j;
		}
	}
	return -1;
}//求高次同余方程 
int main(){
	long long t,k,z,y,p;
	scanf("%lld %lld",&t,&k);  //注意要开long long 类型，否则会溢出 
	while(t--){
		if(k==1){
			scanf("%lld%lld%lld",&y,&z,&p);
			printf("%lld\n",pow_mod(y,z,p));
		}else if(k==2){
			scanf("%lld%lld%lld",&y,&z,&p);
			long long x=0,yy=0,gcd=0;
			gcd=exgcd(y,p,x,yy);	
			if(z%gcd==0){
				long long tmp=p/gcd;
				x=(((x*z)/gcd)%tmp+tmp)%tmp;  //对x进行处理 
				printf("%lld\n",x);
			}else{
				printf("Orz, I cannot find x!\n");
			}	
		}else if(k==3){
			scanf("%lld%lld%lld",&y,&z,&p);
			long long ans=baby_step_giant_step(y,z,p);
			if(ans==-1){  //方程无解 
				printf("Orz, I cannot find x!\n");
			}else{
				printf("%lld\n",ans);
			}
		}
	}
	return 0;
}
```




---

## 作者：似水年华 (赞：6)

##算法分析

很明显的数论问题。

对于第一种操作，就是简单的快速幂取模运算。

对于第二种操作，扩展欧几里得算法的典型应用。

对于第三种操作，求的是离散对数，需要用到BabyStepGiantStep算法。

##参考程序

```cpp
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <cmath>
#include <cstring>
#include <map>
#define M 100000
#define mul_mod(a,b,c) (((a%c)*(b%c))%c)
using namespace std;
typedef long long LL;
/*FUNCTION*/
LL ksm(LL a,LL k,LL p)
{
    //(a^k)%p;
    if (k==0)
        return 1;
    if (k%2==0)
    {
        LL temp=ksm(a,k/2,p);
        return (temp*temp)%p;
    }
    else
    {
        LL temp=ksm(a,k/2,p);
        return ((temp*temp)%p*(a%p))%p;
    }

}
void gcd(LL a,LL b,LL *d,LL *xx,LL *yy)
{
    //ax+by=gcd(a,b);
    if (b==0)
    {
        *d=a;
        *xx=1;
        *yy=0;
    }
    else
    {
        gcd(b,a%b,d,yy,xx);
        *yy-=*xx*(a/b);
    }
}
LL base_gcd(LL a,LL b)
{
    while (b!=0)
    {
        LL temp=a;
        a=b;
        b=temp%b;
    }
    return a;
}
LL inverse(LL a,LL n)
{
    //To calculate the inverse of a in the mod of P
    //This is used for prime P
    //return ksm(a,p-2,p);
    LL d,x,y;
    gcd(a,n,&d,&x,&y);
    return d==1?(x+n)%n:-1;
}
LL log_mod(LL a,LL b,LL n)
{
    LL m,v,e=1,i;
    m= (LL) sqrt(n+0.5);
    v=inverse(ksm(a,m,n),n);
    map<int,int> x;
    x[1]=0;
    for (i=1;i<m;i++)
    {
        e=mul_mod(e,a,n);
        if(!x.count(e))
            x[e]=i;
    }
    for (i=0;i<m;i++)
    {
        if (x.count(b))
            return i*m+x[b];
        b=mul_mod(b,v,n);
    }
    return -1;
}
void slove1(LL y,LL z,LL p)
{
    cout<<ksm(y,z,p)<<endl;
}
void slove2(LL a,LL b,LL p)
{
    LL e=base_gcd(a,p);
    if (b%e!=0)
    {
        cout<<"Orz, I cannot find x!"<<endl;
        return;
    }
    a=a/e;b=b/e;p=p/e;
    LL x=mul_mod(inverse(a,p),b,p);
    cout<<x<<endl;
}
void slove3(LL y,LL z,LL p)
{
    z=z%p;
    LL ans=log_mod(y,z,p);
    if(ans==-1)
        cout<<"Orz, I cannot find x!"<<endl;
    else
        cout<<ans<<endl;
}
int main()
{
    LL y,z,p,t;
    int kind;
    int i;
    cin>>t>>kind;
    for (i=1;i<=t;i++)
    {
        cin>>y>>z>>p;
        if (kind==1)
            slove1(y,z,p);
        if (kind==2)
            slove2(y,z%p,p);
        if (kind==3)
            slove3(y,z,p);
    }
    return 0;
}
```

---

## 作者：VenusM1nT (赞：4)

前两问都不难，这个$BSGS$还是比较难的……

我从隔壁的模板题复制的代码，所以写的是$ExBSGS$，比较冗长，虽然泛用性会更高，但是这题没有$P$点用……

对于第一问，直接套快速幂就行，$BSGS$要用到，就顺手解决了

对于第二问，扩欧求解，套费马小定理，数论渣表示一脸懵

对于第三问，$BSGS$硬上就行……

代码比较丑，凑合着看吧……

主程序还是挺简洁的$233$

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
map <ll,ll> m;
ll QuickPow(ll x,ll y,ll p)
{
	ll sum=1;
	while(y)
	{
		if(y&1) sum=sum*x%p;
		x=x*x%p;
		y>>=1;
	}
	return sum%p;
}
ll Gcd(ll x,ll y)
{
	return !x ? y : Gcd(y%x,x);
}
ll ExGCD(ll a,ll b,ll &x,ll &y)
{
	if(!b)
	{
		x=1;
		y=0;
		return a;
	}
	ll g=ExGCD(b,a%b,x,y);
	ll t=x;
	x=y;
	y=t-y*(a/b);
	return g;
}
ll BSGS(ll a,ll b,ll p,ll d)
{
	m.clear();
	b%=p;
	ll t=sqrt(p)+1,now=b,sum=d;
	for(int i=1;i<=t;i++)
	{
		now=now*a%p;
		m[now]=i;
	}
	now=QuickPow(a,t,p);
	for(int i=1;i<=t;i++)
	{
		sum=sum*now%p;
		if(m.count(sum)) return t*i-m[sum];
	}
	return -1;
}
int ExBSGS(int a,int b,int p)
{
	if(p==1) return 0;
	a%=p;
	b%=p;
	if(b==1) return 0;
	if(a==0)
	{
		if(b==0) return 1;
		return -1;
	}
	ll sum=1,tot=0;
	for(ll i=Gcd(a,p);i!=1;i=Gcd(a,p))
	{
		if(b%i) return -1;
		b/=i;
		p/=i;
		sum=sum*(a/i)%p;
		tot++;
		if(b==sum) return tot;
	}
	a%=p;
	ll cnt=BSGS(a,b,p,sum);
	if(cnt==-1) return -1;
	else return cnt+tot;
}
void Solve1()
{
	ll a,b,p;
	scanf("%lld %lld %lld",&a,&b,&p);
	printf("%lld\n",QuickPow(a,b,p));
}
void Solve2()
{
	ll a,b,p,x,y;
	scanf("%lld %lld %lld",&a,&b,&p);
	ll gcd=ExGCD(a,p,x,y);
	if(!(b%gcd))
	{
		ll t=p/gcd;
		x=(((x*b)/gcd)%t+t)%t;
		printf("%lld\n",x);
	}
	else printf("Orz, I cannot find x!\n");
}
void Solve3()
{
	ll a,b,p;
	scanf("%lld %lld %lld",&a,&b,&p);
	ll ans=ExBSGS(a,b,p);
	if(ans==-1) printf("Orz, I cannot find x!\n");
	else printf("%lld\n",ans);
}
int main()
{
	int Time,opt;
	scanf("%d %d",&Time,&opt);
	while(Time--)
	{
		if(opt==1) Solve1();
		else if(opt==2) Solve2();
		else if(opt==3) Solve3();
	}
	return 0;
}
```

---

## 作者：dread (赞：1)

- 这道题算是比较综合的一道数论的题目。
- 输入1时可以直接用快速幂解决 ~~（别告诉我你连快速幂都不会）~~
下面就是代码:

```cpp
ll quickmul(ll a, ll b, ll mod) {//快速乘 
	ll re = 0;
	while(b) {
		if(b & 1)	re += a;
		re %= mod;
		b >>= 1;
		a += a;
		a %= mod;
	}
	return re;
}

ll quickpow(ll a, ll b, ll mod) {//快速幂 
	ll re = 1;
	while(b) {
		if(b & 1)	re = quickmul(re, a, mod);
		re %= mod;
		b >>= 1;
		a = quickmul(a, a, mod);
		a %= mod;
	}
	return re;
}

```


- 输入2时用一个扩展gcd解决：把$x*y ≡ z\mod p$转换成$xy + kp = z$	就可以解决了。
下面是代码：
```cpp
ll exgcd(ll a, ll b, ll &x, ll &y) {
	if(b == 0) {
		x = 1;
		y = 0;
		return a;
	}
	ll d = exgcd(b, a % b, x, y);
	ll z = x;
	x = y;
	y = z - (a / b) * y;
	return d;
}
```

- 输入3时就变成了一个离散对数问题，但是这道题的p是质数不用考虑合数的算法，主要思想是分块:
设$x = A*\sqrt{p} + B$
$a^ {A*\sqrt{p} + B}≡b\mod p$
$a^ A*\sqrt{p}≡b * a^ {-B}\mod p$
求出$A,B$就能算出$x$
复杂度为O($\sqrt{p}$)；
最后上整个程序：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

int t, type;
ll a, b, p;
map<ll, ll> mp;

ll read() {
	ll s = 0, f = 1;
	char ch;
	for(; ch < '0' || ch > '9'; ch = getchar()) if(ch == '-') f = -1;
	for(; ch >= '0' && ch <= '9'; ch = getchar()) s = (s << 1)+(s << 3) + ch - '0';
	return s * f;
}

ll quickmul(ll a, ll b, ll mod) {
	ll re = 0;
	while(b) {
		if(b & 1)	re += a;
		re %= mod;
		b >>= 1;
		a += a;
		a %= mod;
	}
	return re;
}

ll quickpow(ll a, ll b, ll mod) {
	ll re = 1;
	while(b) {
		if(b & 1)	re = quickmul(re, a, mod);
		re %= mod;
		b >>= 1;
		a = quickmul(a, a, mod);
		a %= mod;
	}
	return re;
}

ll exgcd(ll a, ll b, ll &x, ll &y) {
	if(b == 0) {
		x = 1;
		y = 0;
		return a;
	}
	ll d = exgcd(b, a % b, x, y);
	ll z = x;
	x = y;
	y = z - (a / b) * y;
	return d;
}

ll gcd(ll xx, ll yy) {
	return !yy ? xx : gcd(yy, xx % yy);
}

int main() {
	freopen ("calc.in", "r", stdin);
	freopen ("calc.out", "w", stdout);
	scanf("%d%d", &t, &type);
	while(t--) {
		ll x, y;
		a = read();
		b = read();
		p = read();
		if(type == 1) {
			printf("%lld\n", quickpow(a, b, p));
		}
		if(type == 2) {
			ll d = exgcd(a, p, x, y);
			if(b % d)	puts("Orz, I cannot find x!");
			else {
				ll temp = p / d;
				while(x < 0)	x += temp;
				printf("%lld\n", ((x * b / d) % temp + temp) % temp); 
			}
		}
		if(type == 3) {
			bool flag = 0;
			if(b % gcd(a, p)) {
				puts("Orz, I cannot find x!");
				continue;
			}
			a %= p;
			b %= p;
			mp.clear();
			int m = ceil(sqrt(p));
			for(int i = 0; i < m; ++i, b = quickmul(b, a, p))	mp[b] = i;
			for(int i = 1, j = a = quickpow(a, m, p); i <= m ; ++i, j = quickmul(j, a, p)) {
				if(mp.count(j) && i * m >= mp[j]) {
					flag = 1;
					printf("%lld\n", i * m - mp[j]);
					break;
				}	
			}
			if(!flag)	puts("Orz, I cannot find x!");
		}
	}
	return 0;
}
```

---

## 作者：ZORO (赞：0)

# 题意：


操作一：快速幂

操作二：$Exgcd$

操作三：$BSGS$

至于$BSGS$是什么怎么写，关于这方面的题解已经烂大街了

安利一下我的$BSGS$博客[传送门](https://www.cnblogs.com/Liuz8848/p/11373392.html)

为了让这篇题解突出特色~~其实是为了通过~~，这篇博客主要针对$BSGS$的特判讲。相信很多人写$BSGS$模板都会拿到$75pts$的好成绩。如果把鼠标放到$WA$上面会发现希望你输出$'0'$。

仔细看不对，发现其实是期望你输出$O$，也就是无解的情况。
其实你只要加上“如果$gcd(y,p)!=1$则无解”的特判，那么你就$AC$了。

# $Solution$
**这道题有三个特判，注意顺序**

首先你可以将左右两边$a%c,b%c$，这样性质不会改变

$BSGS$的前提是$a^x\equiv b(mod\ c),gcd(a,c)==1$

这道题保证了$p$是质数，但是并没有提到给出的$y< p$，所以当且仅当$y$是$p$的倍数时，$BSGS$无解。这时候经过取模操作，$a=0$，直接求$gcd$若不等于$1$则无解就可以了

有人说扩展$BSGS$不是可以解决吗，（没有学过的可以看我上面的博客~~厚颜无耻~~），但是你考虑一个数的倍数多少次方模另一个数还是$0$

哎？发现问题了，那$0$的情况怎么办

**对了，实际上这道题有一个$bug$，就是$0^0$**

**为什么这么说呢，在正常情况下$0^0$是无意义的，但在取模运算下有可能取模后变成了$0$，所以$0^0$是有意义的，需要特判**

1.我们先分两种情况考虑，$a$本来就是$0$或者$a$本来不是$0$，若$a$本来就是$0$则只有$b=1$时有解，$x_min=1$，但因为这道题保证$a\geq1$所以只用考虑第二种情况

2.$a$取模后是$0$，这说明$a$在取模前是$c$的倍数，再考虑$b$。

3.当$b$是$0$时，显然$a^x(x!=0)$取模后一定是$0$，所以取最小值$1$输出即可。

4.当$b$是$1$时，只有$a^0$取模后是$1$,这时$0^0$有意义是因为未取模前是成立的。

这两种情况外，方程无解
--
综上，这道题在判无解前要考虑这两种特殊情况

按照以下顺序特判

**特判1：if(a==0&&b==0) return 1;**

**特判2：if(b==1) return 0;**(任何数的0次方都是1，0除外)

因为这道题保证不为$0$，而且要求输出最小解，所以直接返回$0$

**特判3:if(gcd(a,b)！=1)return -1;**

你们的$75pts$

--------------
最后提供一组$Hack$数据

1 3

3 3 3

$Code$
--
```
#include<cstdio>
#include<iostream>
#include<cstring>
#include<map>
#include<cmath>
#define ll long long 
#define re register
#define MOD 76543
using namespace std;
int T,aa,bb,cc,K;
int top,hs[MOD],id[MOD],head[MOD],next[MOD];
ll x,y;
map<int,int> a;
void insert(int x, int y)
{
    int k = x%MOD;
    hs[top] = x, id[top] = y, next[top] = head[k], head[k] = top++;
}
int find(int x)
{
    int k = x%MOD;
    for(int i = head[k]; i != -1; i = next[i])
        if(hs[i] == x)
            return id[i];
    return -1;
}

ll quickPow(ll a,ll b,ll mod)
{
	ll ans=1;
	while(b)
	{
		if(b&1)
		ans=(ans*a)%mod;
		a=(a*a)%mod;
		b>>=1;
	}
	return ans%mod;
}
ll exgcd(ll a,ll b)
{
	if(!b)
	{
		x=1,y=0;
		return a;
	}
	ll t2= exgcd(b,a%b);
	ll t=x;
	x=y;
	y=t-a/b*y;
	return t2;
}

int gcd(int a,int b)
{
	return b==0?a:gcd(b,a%b);
}
ll BSGS(ll a,ll b,ll c)
{
	a%=c,b%=c;//一定别忘了取模    1
	if(a==0&&b==0) return 1;//最小整数解 2
	if(b == 1)
        return 0; // 3
	if(gcd(a,c)!=1) return -1;// 4 因为题目保证是质数，不互质的话一定是倍数关系，扩展大步小步也无解
    memset(head, -1, sizeof(head));//数组不清空，爆零两行泪 
    top = 1;

    int m = sqrt(c*1.0), j;
    long long x = 1, p = 1;
    for(int i = 0; i < m; ++i, p = p*a%c)
        insert(p*b%c, i);//存的是(a^j*b, j)
    
    for(long long i = m; ;i += m)//此时p为a^m 
    {
        if( (j = find(x = x*p%c)) != -1 )
            return i-j;  //a^(ms-j)=b(mod c)
        if(i > c)
            break;
    }
    return -1;
}


int main()
{
	scanf("%d%d",&T,&K);
	while(T--)
	{
		scanf("%d%d%d",&aa,&bb,&cc);
		if(K==1)
		{
			printf("%lld\n",quickPow(aa,bb,cc));
		}
		else if(K==2)
		{
			ll tmp=exgcd(aa,cc);
			x=(x%cc+cc)%cc;
			if(bb%tmp)
			{
				printf("Orz, I cannot find x!\n");
				continue;
			}
			x=x*(bb/tmp)%cc;
			printf("%lld\n",x);
		}
		else if(K==3)
		{
            ll ans=BSGS(aa,bb,cc);
            //
            if(ans!=-1 )
			{
				ans=(ans%cc+cc)%cc;
				printf("%lld\n",ans);
			}
            else
			 printf("Orz, I cannot find x!\n");
        }
	}

	
	return 0;
} 
```

---

## 作者：PPXppx (赞：0)

题目描述

你被要求设计一个计算器完成以下三项任务：

1、给定y、z、p,计算y^z mod p 的值；

2、给定y、z、p,计算满足x*y ≡z(mod p)的最小非负整数x；

3、给定y、z、p，计算满足y^x ≡z(mod p)的最小非负整数x。

为了拿到奖品，全力以赴吧！

输入输出格式

输入格式：

输入文件calc.in 包含多组数据。

第一行包含两个正整数T、K，分别表示数据组数和询问类型（对于一个测试点内的所有数据，询问类型相同）。

以下T行每行包含三个正整数y、z、p，描述一个询问。

输出格式：

输出文件calc.out 包括T 行.

对于每个询问，输出一行答案。

对于询问类型2 和3，如果不存在满足条件的，则输出“Orz, I cannot find x!”。

---
分析：

就是一道数论三合一吧，三个类型之间没有联系，都是单独的一个算法；

类型一：普普通通的快速幂模板

类型二：扩展欧几里得算法求解同余方程组的模板

类型三：高次同余方程，BSGS算法模板

三道模板，证毕；


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll a,b,p,d;
void solve1(){//快速幂模板，非递归实现
    ll ret=1;
    while(b){
    	if(b%2==1) ret=ret*a%p;
    	a=a*a%p;
    	b=b/2;
    }
    printf("%lld\n",ret);
}
ll gcd(ll a,ll b){//最大公约数模板
    if(b==0) return a;
    return gcd(b,a%b);
}
void exgcd(ll a,ll b,ll &x,ll &y){
    if(b==0){d=a;x=1;y=0;return;}
    exeuclid(b,a%b,x,y);
    ll t=x;x=y;y=t-a/b*y;
}//扩展欧几里得算法模板
void solve2(){//扩展欧几里得算法求解同余方程组模板
    ll x,y;
    exgcd(a,p,x,y);
    if(b%d!=0){
    	printf("Orz, I cannot find x! \n");
    	return;
    }
    printf("%lld\n",(x*(b/d)%(p/d)+(p/d))%(p/d));
}
map <ll,ll> Map;//map容器
void solve3(){//BSGS模板
    ll tmp,i,j,t,x,y,m;
    Map.clear();//清空操作
    t=0;a=a%p;
    m=ceil(sqrt(p));
    tmp=1;Map[1]=m+1;　　//一系列初始化操作
    for(j=1;j<=m;j++){//将a^b%p存入map
    	tmp=tmp*a%p;
    	if(!Map[tmp]) Map[tmp]=j;
    }
    t=1;
    for(i=0;i<=m;i++){
    	exgcd(t,p,x,y);
    	t=t*tmp%p;
    	if(b%d!=0) continue;
    	j=Map[(x*(b/d)%(p/d)+(p/d))%(p/d)];
    	if(j){
        	if(j==m+1) j=0;
        	printf("%lld\n",i*m+j);
        	return;
    	}
	}
    printf("Orz, I cannot find x! \n");
}
int main(){
    int T,k;
    scanf("%d%d",&T,&k);//T组数据，k询问类型
    while(T--){
    scanf("%lld%lld%lld",&a,&b,&p);
    if(k==1) solve1();//计算y^z mod p 的值
    if(k==2) solve2();//计算满足xy ≡z(mod p)的最小非负整数x
    if(k==3) solve3();计算满足y^x ≡z(mod p)的最小非负整数x
    }
    return 0;
}


```

---

## 作者：little_sun (赞：0)

# 题解 P2485 【[SDOI2011]计算器】

第一问快速幂不讲了

第二问要你求的是$$x*y \equiv z \mod p$$
即 $$x*y-k*p=z$$
即 $$y*x+p*(-k)=z$$
就转换为$exgcd$的标准形式了（这个相信大家都会吧）

第三问BSGS模板题

有兴趣可以看P4195 exBSGS模板（我的bsgs参考了第二篇题解）

注意$b$有可能大于$p$，所以要膜一下
```cpp
#include <bits/stdc++.h>
#define ll long long
#define int ll
std::unordered_map<int, int> h;
int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
inline int mul(int a, int b, int p)
{
    ll ret = 0;
    while(b)
    {
        if (b & 1)
            ret = (ret + a) % p;
        a = (a + a) % p;
        b >>= 1;
    }
    return ret;
}
void exgcd(int a, int b, int &x, int &y)
{
    if (b == 0)
    {
        x = 1, y = 0;
        return;
    }
    exgcd(b, a % b, x, y);
    int t = x;
    x = y, y = t - (a / b) * y;
}
int solve1(int a, int b, int p)
{
    ll ret = 1;
    while (b)
    {
        if (b & 1)
            ret = mul(ret, a, p);
        a = mul(a, a, p);
        b >>= 1;
    }
    return ret;
}

int solve2(int a, int b, int p)
{
    int x = 0, y = 0;
    int g = gcd(a, p);
    if (b % g)
        return -1;
    exgcd(a, p, x, y);
    x *= (b / g);
    x = (x % p + p) % p;
    return x;
}
int solve3(int a, int b, int p)
{
    if (b == 1)
        return 0;
    int cnt = 0, d, k = 1;
    while ((d = gcd(a, p)) ^ 1)
    {
        if (b % d)
            return -1;
        b /= d, p /= d, ++cnt;
        k = mul(k, a / d, p);
        if (k == b)
            return cnt;
    }
    int t = sqrt(p) + 1, tmp = 1;
    h.clear();
    for (int i = 0; i < t; i++)
    {
        h[mul(tmp, b, p)] = i;
        tmp = mul(tmp, a, p);
    }
    k = mul(k, tmp, p);
    for (int i = 1; i <= t; i++)
    {
        if (h.find(k) != h.end())
            return i * t - h[k] + cnt;
        k = mul(k, tmp, p);
    }
    return -1;
}
signed main()
{
    int T, op;
    scanf("%lld%lld", &T, &op);
    while (T--)
    {
        int a, b, p;
        scanf("%lld%lld%lld", &a, &b, &p);
        
        if (op == 1)
            printf("%lld\n", solve1(a, b, p));
        if (op == 2)
        {
            b %= p;
            int ans = solve2(a, b, p);
            if (ans == -1)
                printf("Orz, I cannot find x!\n");
            else
                printf("%lld\n", ans);
        }
        if (op == 3)
        {
            b %= p;//注意这个！
            int ans = solve3(a, b, p);
            if (ans == -1)
                printf("Orz, I cannot find x!\n");
            else
                printf("%lld\n", ans);
        }
    }
    return 0;
}
```

---

## 作者：2018LZY (赞：0)

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
typedef long long ll;

//1
ll power_mod(ll a,ll b,ll c)
{
	ll ans=1%c;a%=c;
	while(b>0)
	{
		if(b&1)ans=ans*a%c;
		a=a*a%c;b=b>>1;
	}
	return ans;
}

//2
ll d;
void exgcd(ll a,ll b,ll &x,ll &y)
{
	if(!a)
	{
		d=b;x=0;y=1;
		return;
	}
	exgcd(b%a,a,y,x);
	x-=b/a*y;
}

//3
const int mod=70001;
int hash[mod],e[mod],next[mod],len,v[mod],ts;
void add(int x,int ex)
{
	int k=x%mod;
	if(v[k]==ts)
	{
		while(1)
		{
			if(hash[k]==x){e[k]=ex;return;}
			if(next[k]==-1)break;
			k=next[k];
		}
		while(v[len]==ts)++len;
		next[k]=len;k=len++;
	}
	hash[k]=x;e[k]=ex;next[k]=-1;v[k]=ts;
}
int find_exp(int x)
{
	int k=x%mod;
	if(v[k]!=ts)return -1;
	while(~k)
	{
		if(hash[k]==x)return e[k];
		k=next[k];
	}
	return -1;
}
ll gcd(ll a,ll b){return !a?b:gcd(b%a,a);}
ll BSGS(ll a,ll b,ll c)
{
	if(b==1||c==1)return 0;
	len=0;++ts;
	ll D=1,tot=0,t=1;
	while((d=gcd(a,c))>1)
	{
		if(b%d)return -1;
		D=D*a/d%c;b/=d;c/=d;
		++tot;
		if(D==b)return tot;
	}
	int m=ceil(sqrt(c));
	for(int i=0;i<m;i++)
	{
		add(t*b%c,i);
		t=t*a%c;
	}
	D=D*t%c;
	for(int i=1;i<=m;i++)
	{
		int j=find_exp(D);
		if(~j)return i*m-j+tot;
		D=D*t%c;
	}
	return -1;
}
int main()
{
	int t,op,a,b,c,k;ll x,y;
	while(~scanf("%d%d",&t,&op))
	{
		switch(op){
			case 1:
				while(t--)
				{
					scanf("%d%d%d",&a,&b,&c);
					printf("%lld\n",power_mod(a,b,c));
				}
				continue;
			case 2:
				while(t--)
				{
					scanf("%d%d%d",&a,&k,&b);k%=b;
					exgcd(a,b,x,y);
					if(k%d)puts("Orz, I cannot find x!");
					else
					{
						x*=k/d;
						y=b/d;
						x=(x%y+y)%y;
						printf("%lld\n",x);
					}
				}
				continue;
			case 3:
				while(t--)
				{
					scanf("%d%d%d",&a,&b,&c);b%=c;
					x=BSGS(a,b,c);
					if(~x)printf("%lld\n",x);
					else puts("Orz, I cannot find x!");
				}
				continue;
		}
	}
	return 0;
}
```


---


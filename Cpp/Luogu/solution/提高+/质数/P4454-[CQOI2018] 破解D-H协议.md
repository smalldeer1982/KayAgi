# [CQOI2018] 破解D-H协议

## 题目背景

Diffie-Hellman 密钥交换协议是一种简单有效的密钥交换方法。它可以让通讯双方在没有事先约定**密钥**的情况下，通过**不安全**（可能被窃听）**的信道**确定一个**安全的密钥** $K$，用于加密之后的通讯内容。

## 题目描述

假定通讯双方名为 Alice 和 Bob，协议的工作过程描述如下（其中 $\bmod$ 表示取模运算）：

1. 协议规定一个**固定的**质数 $P$，以及模 $P$ 的一个原根 $g$。**$\boldsymbol P$ 和 $\boldsymbol g$ 的数值都是公开的，无需保密。**

2. Alice 生成一个随机数 $a$，并计算 $A=g^a\bmod P$，将 $A$ 通过不安全信道发送给 Bob。

3. Bob 生成一个随机数 $b$，并计算 $B=g^b\bmod P$，将 $B$ 通过不安全信道发送给 Alice。

4. Bob 根据收到的 $A$ 计算出**密钥** $K=A^b \bmod P$，而 Alice 根据收到的 $B$ 计算出 $K=B^a\bmod P$。

5. 双方得到了相同的 $K$，即 $g^{ab} \bmod P$。$K$ 即之后通讯的加密密钥。

可见，这个过程中可能被窃听的只有 $A,B$，而 $a,b,K$ 是保密的。并且根据 $A,B,P,g$ 这 $4$ 个数，不能轻易计算出 $K$，因此 $K$ 可以作为一个安全的密钥。

当然安全是相对的，该协议的安全性取决于数值的大小，通常 $a,b,P$ 都选取数百位以上的大整数以避免被破解。然而如果 Alice 和 Bob 编程时偷懒，为了避免实现大数运算，选择的数值都小于 $2^{31}$，那么破解他们的密钥就比较容易了。

$T$ 次给定窃听得到的 $A,B$，你需要尝试破解出**密钥** $K$。


## 说明/提示

对于 $30\%$ 的数据，$2\le A,B,P\le 1000$；

对于 $100\%$ 的数据，$2\le A,B<P<2^{31}，2\le g<20，1\le n\le 20$。

$\text{Statement fixed by @Starrykiller.}$

## 样例 #1

### 输入

```
3 31
3
27 16
21 3
9 26```

### 输出

```
4
21
25```

# 题解

## 作者：Leonid (赞：10)

# P4454 [CQOI2018]破解 D-H 协议 题解

不要看这道题**题目长**而且是**紫题**就放弃，只要**读懂题目**就不难了。

## 题目大意
给定质数 $P$，和模 $P$ 意义下的数 $g$，和一个正整数 $n$。

接下来给出 $n$ 组数据 每组数据一行两个整数 $A$ 和 $B$，其中 $A=g^a\ mod\ P$，$B=g^b\ mod\ P$，求 $g^{ab}\ mod\ P$ 的值。

这是一道的求高次同余方程的题，看似是要求两个方程，其实思考一下就可以发现只要算出一个方程就可以了。因为两条式子获得的是一样的 $K$，所以我们只需要用 **BSGS** 算法求其中一个方程的解，然后用快速幂输出就可以了。

[BSGS 模板题](https://www.luogu.com.cn/problem/P3846)

##  _**My code**_ 
 
 ```cpp
#include<cstdio>
#include<cmath>
#include<map>

using namespace std;

#define ll long long //好习惯

ll g,p,n,A,B,qwq; //qwq表示其中一个方程的解
map<ll,ll>k; //hash表

ll qpow(ll a,ll b,ll p){
	ll e=1;
	while(b){
		if(b&1)e=e*a%p;
		b>>=1;
		a=a*a%p;
	}
	return e%p;
} //快速幂模板

ll BSGS(ll a,ll b,ll p){
	k.clear(); //hash表初始化
	ll m=ceil(sqrt(p)),ans;
	for(ll i=0;i<=m;i++){
		if(!i){
			ans=b%p;
			k[ans]=i;
			continue;
		}
		ans=(ans*a)%p;
		k[ans]=i;
	}
	ll t=qpow(a,m,p);
	ans=1;
	for(ll i=1;i<=m;i++){
		ans=(ans*t)%p;
		if(k[ans]){
			ll o=i*m-k[ans];
			return (o%p+p)%p; //返回答案
		}
	}
	return -1;
} // BSGS模板

int main(){
	scanf("%lld %lld",&g,&p);
	scanf("%lld",&n);
	while(n--){
		scanf("%lld %lld",&A,&B);
		qwq=BSGS(g,A,p);
		printf("%lld\n",qpow(B,qwq,p)); // 输出答案
	}
	return 0;
}
```

---

## 作者：LeavingZzz (赞：7)

# $\mathsf{Solution\text{ }For\text{ }P4454}$
$\large\mathcal{By\text{ }ShadderLeave}$  

实际上，这题本质并不难，只是需要把题目读懂......  
## Description
形式化描述：  
给定一个质数 $P$ ，以及模 $P$ 意义下的一个原根 $g$  
接下来给定若干组整数 $A,B$，其中 $A=g^x \bmod{P}$,$B=g^y\bmod P$，求出 $g^{xy}\text{ }\bmod{P}$ 旳值  
## Solution
那么这里可以看出，已知的量有 $A,B,g,P$。其中 $g,P$ 不变而 $A,B$ 有若干组，对于每一组 $A,B$ 我们都有两个待求的量 $x,y$.那么第一级解法就有了：对于每一组 $A,B$ 求出对应的 $x,y$，直接计算$g^{xy}\text{ }\bmod{P}$ 旳值  

但是仔细想想就会发现只用求一个就可以了，因为 $A,B$ 已知，求出一个（这里假设求出了 $x$）,便可以直接拿着 $B$ 来计算 $B^x$，这两种做法在模 $P$ 意义下是等价的。  

分析van了之后再把题目的形式化描述更加具体一点(有利于解题思路的清晰化)  
给定一个质数 $P$ ，以及模 $P$ 意义下的一个原根 $g$  
接下来给定若干组整数 $A,B$，其中 $A=g^x \bmod{P}$,$B=g^y\bmod P$，求出同余方程 $g^x\equiv A\pmod{P}$ 的解 $x$，然后计算 $B^x\bmod{P}$ 的值  

高次同余方程，模数与底数互质，用 $\mathsf{BSGS}$ 来解出指数  
[关于$\mathsf{BSGS}$ 的讲解](https://www.luogu.com.cn/blog/ShadderLeave/5days-equiv-from-beginner-to-killer)  

然后因为是多组数据  
原来的同余方程是 $g^x\equiv A\pmod{P}$ ,设 $x=i\times \sqrt{P}-j$  
化为 
$$\dfrac{g^{i\times\sqrt{P}}}{g^j\times A}\equiv 1\pmod{P}$$  
为了效率，因为这里的 $A$ 是多组数据，是变动的，而 $P,g$ 是在一开始就给出的，所以不能再预处理分母，我们预处理分子即可  

注意这里的 $i,j$ 的范围：$i\in \left( 0,ceil(\sqrt{P}) \right]$，$j\in \left[ 0,ceil(\sqrt{P}) \right)$  

总结步骤：  
1. 预处理分子部分，即 $g^{i\times\sqrt{P}}$,其中 $i\in \left( 0,ceil(\sqrt{P}) \right]$  
2. 对于每一组 $A,B$，枚举 $A\times g^j$ ,其中 $j\in \left[ 0,ceil(\sqrt{P}) \right)$，在哈希表中查询是否有对应的值存储，若有，得到 $\boxed{ans=\texttt{哈希表中存储的幂指数}-j}$  
3. 快速幂求出每一组中 $B^{ans}\bmod{P}$ 的值，输出  

## $\mathsf{Code:}$  
```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
typedef long long LL;
LL A,B,C;
struct Hash_table{//手写哈希真的快很多
	static const LL MOD=1999997;
	LL Hash[MOD],V[MOD],stk[MOD],top;
	//Hash_table() {memset(Hash,-1,sizeof(Hash));}
	inline void Insert(LL val,LL mi)
	{
		LL h=val%MOD;
		while(Hash[h]&&Hash[h]!=val) h++;
		Hash[h]=val;V[h]=mi;
		stk[++top]=h;
		return ;
	}
	inline LL find(LL val)
	{
		LL h=val%MOD;
		while(Hash[h]&&Hash[h]!=val) h++;
		return Hash[h]==val?V[h]:-1;
	}
}H;
inline LL fast_pow(LL b,LL k)
{
	LL s=1;
	while(k)
	{
		if(k&1) s=(s*b)%C;
		b=(b*b)%C;
		k>>=1;
	}
	return s;
}
LL N;
int main()
{
	scanf("%lld%lld",&A,&C);
	LL sqrtm=ceil(sqrt(C));
	LL ti=fast_pow(A,sqrtm);
	LL t=ti;
	for(LL i=1;i<=sqrtm;i++)//预处理分子，注意范围
	{
		H.Insert(t,i*sqrtm);
		t=t*ti%C;
	}
	scanf("%lld",&N);
	LL x,y,ans;
	for(int i=1;i<=N;i++)
	{
		scanf("%lld%lld",&x,&y);
		t=x;
		for(int j=0;j<sqrtm;j++)//枚举分母，注意范围
		{
			if((ans=H.find(t))!=-1)
			{
				ans-=j;
				printf("%lld\n",fast_pow(y,ans));
				break;
			}
			t=t*A%C;
		}
	}
	return 0;
}
```
有任何不懂欢迎私信这个蒟蒻  

$\huge\mathcal{The\text{ }End}$  
谢谢管理大大审核^_^

---

## 作者：MY（一名蒟蒻） (赞：6)

[P4454 [CQOI2018]破解D-H协议](https://www.luogu.com.cn/problem/P4454)

题目本质是求解高次同余方程，复杂度允许，使用 BSGS 算法。

[模板 P3846](https://www.luogu.com.cn/problem/P3846)

[我的 BSGS 算法学习笔记](https://www.luogu.com.cn/blog/nizhuan/bsgs-xue-xi-bi-ji)

题目中也提到，双方获得的是相同的 $K$ ，所以只要对其中一组方程求解，然后快速幂输出答案即可。

注意每次跑 BSGS 要清空。

## Code

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <map>

using namespace std;

inline int qpow(int x,int y,int p)
{
	int res=1;
	while(y)
	{
		if(y&1) res=1ll*res*x%p;
		y>>=1; x=1ll*x*x%p;
	}
	return res;
}

map <int,int> _hash;
inline int BSGS(int a,int b,int p)
{
	b%=p; _hash.clear();
	int t=ceil(sqrt(p)),val=1;
	for(int i=0;i<t;i++)
	{
		_hash[1ll*b*val%p]=i;
		val=1ll*val*a%p;
	}
	a=val; val=1;
	
	if(!a) return !b? 1:-1;
	for(int i=0,j;i<=t;i++)
	{
		j=_hash.find(val) == _hash.end()? -1:_hash[val];
		if(~j && i*t-j >= 0) return i*t-j;
		val=1ll*val*a%p;
	}
	return -1;
}

int main()
{
//	freopen("work.in","r",stdin); freopen("work.out","w",stdout);
	int g,p,n,A,B,a;
	scanf("%d%d%d",&g,&p,&n);
	while(n--)
	{
		scanf("%d%d",&A,&B);
		a=BSGS(g,A,p);
		printf("%d\n",qpow(B,a,p));
	}
//	fclose(stdin); fclose(stdout);
	return 0;
}
```

**一些 BSGS 的题：**

- [P2485 [SDOI2011]计算器](https://www.luogu.com.cn/problem/P2485)
- [P3306 [SDOI2013] 随机数生成器](https://www.luogu.com.cn/problem/P3306)
- [P4884 多少个1？](https://www.luogu.com.cn/problem/P4884)
- [P4861 按钮](https://www.luogu.com.cn/problem/P4861) [题解](https://www.luogu.com.cn/blog/nizhuan/solution-p4861)

## $\text{Thank you for your reading !}$

---

## 作者：revenger (赞：3)

题目大意：给定质数$P$及其原根$g$，每组询问给出$A=g^a\mod P$,$B=g^b\mod P$,求$g^{ab}\mod P$。

对于给出的数$A,B$,我们只要求出$g^a \mod P=A$的$a$值，然后再求$B^a=(g^b)^a=g^{ab}$就可以了。

根据质数原根的性质，对于$a$取$1$到$P-1$的不同值，$g^a$可以对应取到$1$到$P-1$的所有不同值,所以我们可以枚举$1$到$P-1$的不同值,如果有一个$a$使得$g^a \mod P=A$,那这个就是我们要求的$a$。

但是这样显然太慢，所以我们使用一种更快的算法——bsgs算法(又名北上广深算法/拔山盖世算法)

我们取一个参数m,将原式改写为$g^{im-j}\equiv A(\mod P)$

移项可得$g^{im}\equiv Ag^j(\mod P)$

此处我们令$1\leq i\leq \frac{P}{m}$,$0\leq j<m$,$im-j$可以取到$1$到$P-1$的不同值，然后对于每一个$i$我们预处理出$g^{im}\mod P$的值，存进一个map，然后枚举$j$的值，查看map中有没有$Ag^j\mod P$的值，如果有的话，返回$a=im-j$

可以看出上述算法预处理复杂度O($\frac{PlogP}{m}$),单次询问复杂度O($mlogP$),取$m=\sqrt{P}$时达到最优复杂度O($\sqrt{P}logP+20\sqrt{P}logP$)=O($\sqrt{P}logP$)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
#include<cmath>
using namespace std;
typedef long long ll;
ll g,p,a,b,m;
int n; 
map<ll,int> t;
ll quickpow(ll x,ll t)
{
	ll ans=1;
	for(;t;t>>=1,x=x*x%p)
	if(t&1) ans=ans*x%p;
	return ans;
}
ll calc(int x)
{
	ll nowx=x;
	if(t[nowx]) return t[nowx];
	for(int i=1;i<m;i++)
	{
		nowx=nowx*g%p;
		if(t[nowx]) return t[nowx]-i;
	}
}
void init()
{
	m=sqrt(p)+1;
	ll powx=quickpow(g,m);
	ll nowx=1;
	for(int i=1;i<=m;i++)
	{
		nowx=nowx*powx%p;
		t[nowx]=i*m; 
	}
}
int main()
{
	scanf("%lld%lld",&g,&p);
	init();
	scanf("%d",&n);
	while(n--)
	{
		scanf("%lld%lld",&a,&b);
		printf("%lld\n",quickpow(b,calc(a)));
	}
}
```

---

## 作者：eee_hoho (赞：2)

怎么没有人写$\text{Ex\_BSGS}$啊，$g$和$p$不一定互质吧QAQ

首先看到题，然后写出方程

$$A\equiv g^a\ (mod\ P),B\equiv g^b\ (mod\ P)$$
$$K\equiv A^b\ (mod\ P),K\equiv B^a\ (mod\ P)$$

第一个行的式子很熟悉啊QAQ，$g$和$p$不互质，就是$\text{Ex\_BSGS}$了

求出$A$之后带到下面的式子**快速幂**就完了

接下来说下$\text{Ex\_BSGS}$算法的流程，具体的可以看这篇[文章](https://www.luogu.org/blog/sdlang/solution-p4195)QAQ

就拿第一行左边的$A\equiv g^a\ (mod\ P)$来说了

设$G=gcd(g,P)$，如果$G>1$，就对$A/G,P/G,g/G$

式子变成了$g^{a-1}\times \frac{g}{G}\equiv\frac{A}{G}\ (mod\ \frac{P}{G})$

而如果$G\nmid A$并且$A\ne-1$，方程无解（此题没有无解的情况）

这样子一直到$G=1$，再把$\frac{g}{G}$移到右边，然后就可以用$BSGS$算法求解了

$BSGS$算法是用来求解形如$A^x\equiv B\ (mod\ P)$，其中$A,P$互质，的最小正整数解$x$

就拿刚刚的字母写了

设$M=\left \lfloor \sqrt P \right \rfloor,x=iM-j,1\le i,j\le M$

带到方程中$A^{iM-j}\equiv B\ (mod\ P)$

化一下得到$(A^M)^i\equiv B\times A^j\ (mod\ P)$

然后对$B\times A^j$哈希一下就做完了

**Code**
``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <map>
#include <cmath>
#define int long long
using namespace std;
int A,B,p,g,n,a,b,K;
map <int,int> f;
int gcd(int a,int b)     //最大公约数
{
	if (!b)return a;
	return gcd(b,a%b);
}
int mypow(int a,int x,int p)   //快速幂
{
	int s=1;
	while (x)
	{
		if (x&1)s=s*a%p;
		a=a*a%p;
		x>>=1;
	}
	return s;
}
int exgcd(int a,int b,int &x,int &y)  //扩欧求逆元
{
	if (!b)x=1,y=0;
	else
	{
		exgcd(b,a%b,x,y);
		int t=x;
		x=y;
		y=t-a/b*y;
	}
}
int inv(int a,int b)   //逆元
{
	int x,y;
	exgcd(a,b,x,y);
	return (x%b+b)%b;
}
int bsgs(int a,int b,int p)
{
	f.clear();
	int m=ceil(sqrt(p));
	for (int i=1;i<=m;i++)
	{
		b=b*a%p;
		f[b]=i;
	}
	b=1;
	int tmp=mypow(a,m,p);
	for (int i=1;i<=m;i++)
	{
		b=b*tmp%p;
		if (f[b])return (i*m-f[b]+p)%p;
	}
}
int exbsgs(int a,int b,int p)
{
	if (b==1||p==1)return 0;
	int g=gcd(a,p),k=0,na=1;
	while (g!=1)
	{
		k++;b/=g;p/=g;na=na*(a/g)%p;
		if (na==b)return k;
		g=gcd(a,p);
	}
	return bsgs(a,b*inv(na,p)%p,p)+k;
}
signed main()
{
	cin>>g>>p>>n;
	g%=p;
	for (int i=1;i<=n;i++)
	{
		cin>>A>>B;
		A%=p;
		B%=p;
		b=exbsgs(g,B,p);
		a=mypow(A,b,p);
		cout<<a<<endl;
	}
	return 0;
}
```

---

## 作者：accomplishment (赞：1)

[传送门](https://www.luogu.com.cn/problem/P4454)

这道题主要考察的是**对题目的理解**与 **BSGS 的使用**。

## 什么是 BSGS？

BSGS 是用来解决高次同余方程**模数是质数**的一种算法。

### 高次同余方程

已知整数 $a, b, p$，其中 $p$ 为质数，求最小的非负整数 $x$，使得 $a^x \equiv b \pmod{p}$。

因为 $p$ 是质数，根据费马小定理，$a^{p-1} \equiv 1 \pmod{p}$。又知道 $a^0 \equiv 1 \pmod{p}$，所以幂有长度不超过 $p$ 的循环节。暴力枚举 $x < p$ 即可。

但是如果 $p$ 达到了 $10^9$ 级别怎么办？

### 引入 BSGS

**BSGS = Baby Steps Giant Steps**，可以音译为北上广深，拔山盖世（你也可以音译为爆杀高三），只要见到别不认识就行。

BSGS 算法的思想是 meet in the middle，时间复杂度 $O(\sqrt{p})$。

设 $x = im - j$（$x$ 相当于被除数，$m$ 相当于除数，$i$ 相当于商，$j$ 相当于负余数），其中 $m = \left\lceil \sqrt{p} \right\rceil$，这样原式变为 $a^{im-j} \equiv b \pmod{p}$，可以进一步变形得到：

$$(a^m)^i \equiv b \cdot a^j \pmod{p}$$

$j$ 的取值范围是 $[0, m)$，可以直接枚举等号右边，把 $(b \cdot a^j, j)$ 加入哈希表（可以用 `unordered_map` 实现）。如果有相同的 $\text{key}$，用新的代替旧的 $\text{key}$（这样的 $j$ 更大，可以保证 $im - j$ 更小）。

$i$ 的取值范围是 $[1, m]$，可以直接枚举等号左边，到哈希表中去找是否有相同的值。找到的第一个相等的 $i$，对应的 $im - j$ 就是最小的 $x$。

### 本题解法

这题说了一大堆，其实一半都没用，这道题的意思就是求出 $A = g^a \bmod P$ 的 $a$，然后求出 $K = B^a \bmod P$ 的 $K$ 或者 求出 $B = g^b \bmod P$ 的 $b$，然后求出 $K = A^b \bmod P$ 的 $K$。

那么我们可以用 BSGS 求出 $a$ 或 $b$，然后快速幂求出 $K$。

[代码](https://www.luogu.com.cn/paste/6eb16vo4)

> 附：我的[学习笔记](https://www.luogu.com.cn/blog/accomplishmentblog/BSGS-and-exBSGS)

---

## 作者：Cuiyi_SAI (赞：1)

## 解题思路

尽管原根对此题的解答毫无影响，但是我们还是有个概念比较好。

>对于指数同余方程 $a^x\equiv 1\pmod m$ ，我们将它的最小正数解 $x$ 记为 $\delta(a)$，即 $\delta(a)=x$

>根据欧拉定理，若 $a,m$ 互质，则定有 $a^{\varphi(m)}\equiv 1\pmod m$，若有 $\delta(a)=\varphi(m)$，则称 $a$ 为 $m$ 的原根

有了数学概念，我们再来分析题意：

给出 $g,p,A,B$，有 $g^a\equiv A\pmod p,g^b\equiv B\pmod p$，求 $g^{ab}\bmod p$

显然，就是要我们求解两个指数同余方程 $g^a\equiv A\pmod p,g^b\equiv B\pmod p$，然后利用快速幂求 $g^{ab}\bmod p$，由于 $p$ 为质数，因此可以直接用 $\mathbf{BSGS}$ 解决。（不懂 $\mathbf{BSGS}$ 的同学戳[这篇blog](https://www.luogu.com.cn/blog/hsh20090304/baby-step-giant-step-chu-bu)）

但是考虑 $a,b$ 都可以超过 $10^9$，因此在快速幂求解 $g^{ab}$ 时 $ab$ 可能会爆 $long~long$，但是我不想打 $int128$，此时有没有什么解决办法呢？

不难想到欧拉定理 $a^{\varphi(m)}\equiv 1\pmod m$，根据它我们可以得到余数的循环节，也就有了欧拉定理的推论 $a^{b\bmod \varphi(m)}\equiv a^b\pmod m$，于是我们就可以将指数 $ab$ 对 $\varphi(p)=p-1$ 取模，来控制指数的大小，就可以愉快AC此题。

```
#include <bits/stdc++.h>
#define int long long
using namespace std;
int g,p,n,A,B,a,b;
int ksm(int a,int b,int mod)
{
	int sum=1;
	while(b)
	{
		if(b&1) sum=(sum*(a%mod))%mod;
		a=(a%mod*(a%mod))%mod;
		b>>=1;
	}
	return sum%mod;
}
int BSGS(int a,int b,int p)
{
	unordered_map<int,int> vis;
	int t=sqrt(p)+1,mi=1;
	for(int i=1;i<=t;i++)
	{
		mi=(mi*(a%p))%p;
		vis[((b%p)*mi)%p]=i;
	}
	a=mi;
	if(!a) return b%p==0?1:-1;
	mi=1;
	for(int i=1;i<=t;i++)
	{
		mi=((a%p)*mi)%p;
		unordered_map<int,int>::iterator it;
		it=vis.find(mi);
		if(it!=vis.end())
		{
			if(i*t-(it->second)>=0) return i*t-(it->second);
		}
	}
}
signed main()
{ 
  ios::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);
  cin>>g>>p>>n;
  while(n)
  {
  	n--;
  	cin>>A>>B;
  	a=BSGS(g,A,p);
  	b=BSGS(g,B,p);
  	cout<<ksm(g,(a%(p-1)*(b%(p-1)))%(p-1),p)<<'\n';
  }
  return 0;	
} 
```



---

## 作者：ThreeBlueOneBrown (赞：1)

- 前置芝士

$\left(t^a\right)^b=t^{ab}$，BSGS 算法。

- 题目大意

这道题给出了 $g^a\mod p,g^b\mod p$，要我们求 $g^{ab}\mod p$。

- 思路

我们会发现 $g^{ab}\mod p=\left(g^a\right)^b\mod p=\left(g^a\mod p\right)^b\mod p$。

所以我们只要求出 $b$ 就可以直接快速幂求出答案了。

而我们再整理一下这些条件：给出 $g^b\mod p$，求 $b$。

而这就是 BSGS 能解决的问题，所以写个 BSGS 就很轻松解决了。

- 代码

变量定义：

```cpp
int g,p,a,b,n;//输入的数 
map<int,int> mp;//BSGS 的 map
int qp(int ds,int zs)//快速幂,ds^zs mod p
{
	int ans=1;
	while(zs)
    {
	    if(zs&1)ans=ans*ds%p;
        ds=ds*ds%p,zs>>=1;
    }
	return ans;
}
```

主要代码：

```
int lim=(int)(sqrt(p)+1),tem=qp(g,lim),ans=1;//lim 上限,tem 底数
for(int i=1;i<=lim;i++)mp[ans=ans*tem%p]=i*lim;//预处理 map
//下面是每一组数据的代码
for(int i=0;i<lim;i++)
{
	if(mp[a]!=0){cout<<qp(b,mp[a]-i)<<endl;break;}//如果这个数被处理过，输出快速幂答案
	a=a*g%p;//这样不用每次都调用 qp 函数，输出调用一次即可
}
```

---

## 作者：autoint (赞：1)

# 先谈一下BSGS算法[（传送门）](https://blog.csdn.net/zzkksunboy/article/details/73162229)
但是上面这位的程序实现比较繁琐，看下面这位的。
## clover_hxy这样说
```cpp
bsgs算法，又称大小步算法（某大神称拔山盖世算法）。

主要用来解决   A^x=B(mod C)(C是质数)，都是整数，已知A、B、C求x。（poj 2417 Discrete Logging）

具体步骤如下：

先把x=i*m-j，其中m=ceil(sqrt(C))，（ceil是向上取整）。

这样原式就变为A^(i*m-j)=B(mod C)，

再变为A^j×B=A^(m*i) (mod C)。

枚举j(范围0-m),将A^j×B存入hash表

枚举i(范围1-m),从hash表中寻找第一个满足A^j×B=A^(m*i) (mod C)。

此时x=i*m-j即为所求。

在网上看到的其他题解大多用的是x=i*m+j，也可以做，只是会牵扯的求逆元，所以比较麻烦。使x=i*m-j就可以轻松避免这个问题了。

那么肯定有人会有疑问为何只计算到m=ceil(sqrt(C))就可以确定答案呢？

x=i*m-j  也就是x 的最大值不会超过p,那超过p的怎么办 ？

有一个公式  a^(k mod p-1)=a^k (mod p)     这个公式的推导需要用到费马小定理

k mod p-1可以看做 k-m（p-1）  ,原式可化成  a^k/(a^(p-1))^m=a^k (mod p)   

根据费马小定理 a^(p-1)=1  (mod p) 其中p为质数 ，a,p 互质，可得a^k/1^m=a^k  (mod p)   a^k=a^k (mod p) 得证。
```
# 分析此题
### 实际上就是求 g^a = A (mod p) 中的a，于是顺利套出模板
### 注意，能少用pow我们就少用，尽量减少常数。本来就用了map，到时候被卡常就尴尬了
### 这题就等于模板题，没有什么特殊的需要处理
# 代码
```cpp
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<ctime>
#include<iostream>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<stack>
#include<queue>
#include<map>
#include<set>
#include<algorithm>
//#pragma GCC optimize(2)
using namespace std;
typedef long long ll;
const int INF=0x7fffffff;
template<class T> inline T read(T&x){
    T data=0;
	int w=1;
    char ch=getchar();
    while(ch!='-'&&!isdigit(ch))
        ch=getchar();
    if(ch=='-')
        w=-1,ch=getchar();
    while(isdigit(ch))
        data=10*data+ch-'0',ch=getchar();
    return x=data*w;
}
ll g,p,bl,A,B;
map <ll,ll> mp;

int pow1(ll x,ll k){
	ll ans=1;
	while(k>0)
	{
		if(k&1)
			ans=(ans*x)%p;
		x=(x*x)%p;
		k>>=1;
	}
	return ans;
}

void init()
{
	bl=ceil(sqrt(p));
	ll cur=pow1(g,bl),ans=cur;
	mp[ans]=bl;
	for(ll i=2;i<=bl;++i)
	{
		ans=(ans*cur)%p;
		mp[ans]=i*bl;
	}
}

ll BSGS(ll x)
{
	ll j=0,cur=1;
	for(;j<=bl;++j)
	{
		if(mp[(cur*A)%p])
			return mp[(cur*A)%p]-j;
		cur=(cur*g)%p;
	}
}

int main()
{
//  freopen(".in","r",stdin);
//  freopen(".out","w",stdout);
	read(g);
	read(p);
	init();
	ll n;
	read(n);
	while(n--)
	{
		read(A);
		read(B);
		printf("%lld\n",pow1(B,BSGS(A)));
	}
//  fclose(stdin);
//  fclose(stdout);
    return 0;
}

```

---

## 作者：Eason_AC (赞：1)

## Content
已知有这样的一些数 $A,B,a,b,g,P$，其中满足 $A=g^a\mod P,B=g^b\mod p,K=A^b\mod p=B^a\mod p$。现给定 $P,g$，再给定 $n$ 组 $A,B$，求出每组对应的 $K$。

**数据范围：$2\leqslant A,B<P<2^{31},2\leqslant g<20,1\leqslant n\leqslant20$。**

## Solution
这道题目乍一看上去没什么头绪，但仔细一想就不难发现出这样的两个同余方程：

$$\begin{cases}g^a\equiv A\pmod P\\g^b\equiv B\pmod P\end{cases}$$

因此，取其中的任意一个同余方程求解即可。

这里就需要引用到一个知识点：$\texttt{BSGS}$ 算法。

$\texttt{BSGS}$ 算法可以用来快速求出形如 $a^x\equiv b\pmod p$ 的方程。具体操作如下：

设 $x=it-j$，其中 $t=\left\lceil\sqrt{p}\right\rceil,i\in[0,t],j\in[0,t-1]$。这么一来，方程就变成了 $a^{it-j}\equiv b\pmod p$。将左边中的 $a^{-j}$ 移到右边去就变成了 $a^{it}\equiv b\times a^j\pmod p$。那么这样就简单了。

我们先枚举 $j\in[0,t-1]$，计算出各个时候 $b\times a^j$ 的值并存入一个 $\texttt{hash}$ 表里面，然后再枚举 $i$，计算出 $a^{it}$ 的值，再看是否有匹配的值就可以了。

由上面我们可以明显的推出，这个算法的复杂度是 $O(t)=O(\sqrt{p})$，可以通过 $p<2^{31}$ 时的数据。

注意以下几点：

1. 当 $a=b=0$ 的时候，$x=1$，因为在目前阶段，我们默认 $0^0$，即 $0$ 的 $0$ 次方没有意义。
2. 当 $a=0$ 且 $b\neq0$ 的时候，$x$ 无解。

那么在这个题目中，我们既可以将 $g^a\equiv A\pmod P$ 中的 $a$ 求出来，然后求 $K$，也可以将 $g^b\equiv B\pmod P$ 中的 $b$ 求出来，也可以算出 $K$。

注意，这题目中的 $\texttt{hash}$ 表要用``unordered_map``存储而不是``map``！为什么？

引用 $\texttt{Konjacq}$ 巨佬的原话所述，``unordered_map``的内部实现是``hash``表，而``map``的内部实现是平衡树。因此在这里如果使用``map``会超时 $6$ 个点，而使用``unordered_map``会大大避免这样的可能性。

看题解里面发现还有手写哈希的……我也只能说佩服了。

## Code
```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <map>
#include <unordered_map>
using namespace std;

typedef long long ll;

unordered_map<ll, ll> cjytql;
ll p, g, t;

ll quickpow(ll a, ll b, ll p) {			//快速求出a^b%p 
	ll res = 1ll;
	a %= p;
	for(; b; b >>= 1, a = a * a % p)
		if(b & 1ll)	res = res * a % p;
	return res;
}
ll bsgs(ll a, ll b, ll p) {				//求出a^x=（同余于）b(mod p)的最小的x 
	cjytql.clear();
	b %= p;
	ll t = (ll)sqrt(p) + 1;
	for(ll j = 0; j < t; ++j) {
		ll val = b * quickpow(a, j, p) % p;
		cjytql[val] = j;
	}
	a = quickpow(a, t, p);
	if(!a)	return !b ? 1 : -1;
	for(ll i = 0; i <= t; ++i) {
		ll val = quickpow(a, i, p) % p;
		int j = cjytql.find(val) == cjytql.end() ? -1 : cjytql[val];
		if(j >= 0 && i * t - j >= 0)	return i * t - j;
	}
	return -1;
}
inline ll read() {
	ll f = 1ll, x = 0ll;
	char c = getchar();
	while(c < '0' || c > '9') {
		if(c == '-')	f = -1ll;
		c = getchar();
	}
	while(c >= '0' && c <= '9') {
		x = x * 10ll + c - '0';
		c = getchar();
	}
	return x * f;
}

int main() {
	g = read(), p = read(), t = read();
	while(t--) {
		ll A = read(), B = read();
		ll a = bsgs(g, A, p);
		printf("%lld\n", quickpow(B, a, p));
	}
	return 0;
}
```

---

## 作者：Randyhoads (赞：1)

[my blog](http://www.cnblogs.com/wlzs1432/p/8877514.html)
BSGS算法(Baby Step Giant Step)，即大步小步算法，用于求解这样的问题

yx≡ z(mod p) 的最小整数解，前提条件 （y,p）=1。

 此时先计算出m = sqrt(p)

然后另 x = im+j,此时有i,j<m

移项有 ymi ≡z*y-j,因为有逆元，不爽

重新另x = im-j,这样移项是就能不去算逆元了

这时有 ymi ≡ z*yj .

这时只用枚举


参考代码（用的是CQOI2018 破解D-H协议中写的BSGS）
```cpp

inline int BSGS(int y,int z)
{
    ma.clear();
    ll m= sqrt(p)+1;
    ll cj = z;
    for(int i=0;i<m;i++)
    {
        ma[cj] = i;
        cj = cj*y%p;
    }
    ll now = Pow(y,m);
    cj = 1;
    for(int i=1;i<=m+1;i++)
    {
        cj = cj*now%p;
        if(ma.count(cj))
        {
            return i*m-ma[cj];
        }
    }
}
```
对于这道题，可以先解出a的值，然后快速幂求出B^a次方即可

---

## 作者：BzhH (赞：0)

题面比较长,但其实就是一道板子题

根据题意, $g^a\equiv A(mod~p),g^b\equiv B(mod~p)$,可以直接通过BSGS求出 $a,b$ 的值,然后直接用快速幂算出来即可

关于[BSGS](https://www.cnblogs.com/A2484337545/p/14691688.html),可以看看我的博客

代码
```
#include<iostream>
#include<cmath>
#include<unordered_map>
using namespace std;
typedef long long ll;

int ksm(int a, int b, int p)
{
    int res = 1;
    while (b)
    {
        if (b & 1)
            res = (ll)res * a % p;
        a = (ll)a * a % p;
        b >>= 1;
    }
    return res;
}

int BSGS(int a, int b, int p)
{
    if (1 % p == b % p)
        return 0;
    unordered_map<int, int> hash;
    int k = sqrt(p) + 1;
    for (int i = 0, j = b % p; i < k; i++, j = (ll)j * a % p)
        hash[j] = i;
    int ak = ksm(a, k, p);
    for (int i = 1, j = ak; i <= k; i++, j = (ll)j * ak % p)
        if (hash.count(j))
            return i * k - hash[j];
    return -1;
}

int main()
{
    int g, p;
    scanf("%d%d", &g, &p);
    int n;
    scanf("%d", &n);
    while (n--)
    {
        int A, B;
        scanf("%d%d", &A, &B);
        int a = BSGS(g, A, p);
        int b = BSGS(g, B, p);
        printf("%d\n", ksm(g, (ll)a * b % (p - 1), p));
    }
    return 0;
}
```

---

## 作者：stansxt (赞：0)

# 前言
- 完全就是一道$BSGS$模板啊，感觉紫色高了点啊$QwQ$
# 思路
- 思路都一样（$exBSGS$那位大佬不算），这里给一个二分的$code$吧。完全不会$BSGS$的话也可以看看我写的$P3846$的题解，只不过那题是一个$BSGS$ ，这题要搞$n$次，没啥本质区别。[题解 P3846 【 [TJOI2007]可爱的质数】](https://www.luogu.com.cn/blog/stansxt/solution-p3846)
- $BSGS$的思想就是把1到$p$分成$\sqrt{p}$段，然后每次查询想办法把复杂度降到$O(1)$或者$O(log_2n)$.
- 预处理出$g$到$g^{\sqrt{p}}$并排好序，每次查询$g^{i\times\sqrt{p}+1}$到$g^{(i+1)\times\sqrt{p}}$中是否有与A同余的，有就返回该指数（也就是$a$），并输出$B^{a}$。
- 具体查询操作就是在预处理出的排好序的数组中二分，看有没有等于$A\times(g^{i\times\sqrt{p}}$模$p$意义下的逆元$)$的。
- 还有点细节，大家看代码吧，个人认为代码还是挺清晰易懂$QwQ$。
# 代码
```
//P4454 [CQOI2018]破解D-H协议
//submit 4
//By sxt on 2020.8.19 
#include<bits/stdc++.h>
#define rg register int
#define il inline
#define in read()
#define _num(x) (x >= '0' && x <= '9')
#define Mem(x) memset(x, 0, sizeof(x)) 
#define mid (l+r>>1)
#define el else if
#define lowbit(x) (x&(-x))
#define int long long
using namespace std;
const int N = 1<<16;
il int read(){
	int x=0,f=1;
	char ch=getchar();
	while(!_num(ch)){
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(_num(ch)){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}
char f[10];
int pcnt;
il void pint(int x){
	pcnt = 0;
	if(x == 0) putchar('0');
	while(x){
		f[++pcnt] = x % 10 + '0';
		x /= 10;
	}
	while(pcnt) putchar(f[pcnt--]);
	putchar('\n');
}
int P, n, a, b, g, sq;
struct node{
	int id, num;
};
node x[N];
bool operator<(const node &x, const node &y){
	return x.num < y.num;
}
il int qpow(int x, int y){
	rg res = 1;
	while(y){
		if(y & 1) res = res * x % P;
		x = x * x % P;
		y >>= 1;
	}
	return res;
}
il int check(int num){
	rg l = 1, r = sq;
	while(l < r){
		if(num > x[mid].num) l = mid + 1;
		el(num < x[mid].num) r = mid - 1;
		else return x[mid].id;
	}
	if(x[l].num == num) return x[l].id;
	if(x[r].num == num) return x[r].id;
	return 0;
}
il int BSGS(int p){
	rg ls = 1, now, jsq = qpow(g, sq);
	for(rg i = 0; i < sq; ++ i, ls = ls * jsq % P){
		now = qpow(ls, P-2);
		now = now * p % P;
		now = check(now);
		if(now) return now + i * sq;
	}
}
signed main()
{
	g = in, P = in, n = in;
	sq = ceil(sqrt(P));
	x[0] = (node){0, 1};
	for(rg i = 1; i <= sq; ++ i) x[i] = (node){i, x[i-1].num * g % P};
	sort(x+1, x+sq+1);
	while(n--){
		a = in, b = in;
		printf("%d\n", qpow(b, BSGS(a)));
	}
	return 0;
}
```
---

$$THE\space ·\space END$$

---


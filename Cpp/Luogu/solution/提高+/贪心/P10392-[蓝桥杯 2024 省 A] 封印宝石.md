# [蓝桥杯 2024 省 A] 封印宝石

## 题目描述

在一次探险中，勇者小蓝发现了 $n$ 颗闪烁着奇异光芒的宝石，每颗宝石都蕴含着魔法能量，分别记作 $a_1, a_2,\cdots, a_n$。小蓝计划用 $n$ 个特制的魔法盒子来封
印这些宝石，防止其魔法能量被滥用。  
封印宝石会消耗小蓝的体力，具体地，将第 $i$ 颗宝石放入第 $j$ 个盒子会消耗小蓝 $i - j$ 点体力（注：需满足 $j ≤ i$ 才能将第 $i$ 颗宝石放入第 $j$ 个盒子进行有效的封印）。小蓝也可以选择将魔法盒留空，以保存体力供后续使用。  
此外，为了避免魔力相冲，每个盒子最多存放一颗宝石（每个宝石也只能放进一个盒子），且任意两个相邻盒子不能存放魔力值相同的宝石，相邻的盒子允许同时为空。  
小蓝初始的体力值为 $k$。在不超出体力限制的条件下，小蓝希望找出一种宝石的放置方法，使得宝石的魔力值在这 $n$ 个盒子中的排列顺序具有最大的字典序（注：未放置宝石的盒子在此序列中记为 $-1$）。  
作为勇者小蓝的追随者，请你帮他找出这一放置宝石的方法。  

**字典序的解释**： 在本题中，字典序的大小是按照宝石的魔力值进行比较的。对于两个长度同为 $L$ 的魔力值序列 $a$ 和 $b$，如果存在一个位置 $i$，使得 $a_j = b_j$ 对所有 $1 ≤ j < i$ 成立，但是 $a_i < b_i$，则序列 $a$ 在字典序上小于序列 $b$。  
反之，如果 $a_i > b_i$，则序列 $a$ 在字典序上大于序列 $b$。如果不存在这样的 $i$，则序列 $a$ 和序列 $b$ 的字典序相等。

## 说明/提示

在开始放置宝石之前，体力为 $3$，宝石在盒子中的排列为 $[-1, -1, -1]$。  
1. 将第 $2$ 个宝石放进第 $1$ 个盒子，得到 $[3, -1, -1]$，体力剩余 $2$。
2. 将第 $3$ 个宝石放进第 $2$ 个盒子，得到 $[3, 2, -1]$，体力剩余 $1$。  

最后宝石在盒子中的排列为 $[3, 2, −1]$。显然，没有比这更优的放置方法。

对于 $20\%$ 的评测用例，$1 ≤ n ≤ 5 × 10^3 ，0 ≤ k ≤ 3 × 10^6 ，1 ≤ a_i ≤ 10^5$。  
对于所有评测用例，$1 ≤ n ≤ 10^5 ，0 ≤ k ≤ 10^9 ，1 ≤ a_i ≤ 10^9$。

## 样例 #1

### 输入

```
3 3
1 3 2```

### 输出

```
3 2 -1```

# 题解

## 作者：C20193620 (赞：9)

## 题目：第十五届蓝桥杯大学 A 组省赛压轴题

**题意：将 $n$ 个数放在 $n$ 个位置上，每个数只能放在它自己之前的位置上，且离自己多远就花费多少代价，可以有没放的数，给出最大代价，要求最后放的数排成的字典序最大。**

字典序最大带来的就必定是贪心，必须每次都把能放最大的一个值放到前面，同时为了节省体力，需要选相同的这个最大值最前面的一个。

对于当前位置 $i$，需要求 $i$ 到 $i+k$ 也就是当前体力能到达的最大且最靠前的一个数，可以用线段树来找这个值。同时，题目要求不能连续放一样的数，也就是说最大值有时候放不进去，我们需要放严格次大值，因此同时维护严格次大值，线段树可以实现。最后，在每次放入后要把放入的删掉。

这道题的修改和维护其实挺简单的，但是注意次大值的一些特殊情况和别忘了位置要最靠前。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[1000005],ans[1000005];
bool f[1000005];
struct node
{
	int id,val;
	node(){val=id=0;}
}Zero;
bool operator<(node x,node y)
{
	if(x.val==y.val)
		return x.id>y.id;
	return x.val<y.val;
}y
bool operator==(node x,node y)
{
	return x.val==y.val;
}
struct Tree
{
	int l,r;
	node mx1,mx2;
	Tree(){mx1.val=mx1.id=0,mx2.val=mx2.id=0;}
}t[1000005];
node a1[4];
inline void Pushup(int i)
{
	a1[0]=t[i*2].mx1,a1[1]=t[i*2].mx2,a1[2]=t[i*2+1].mx1,a1[3]=t[i*2+1].mx2;
	sort(a1,a1+4);
	t[i].mx1=a1[3];
	for(int j=2;j>=0;j--)
		if(a1[j].val!=a1[j+1].val)
		{
			t[i].mx2=a1[j];
			break;
		}
}
inline void Build(int i,int l,int r)
{
	if(l==r)
	{
		t[i].mx1.val=a[l],t[i].mx1.id=l,t[i].l=l,t[i].r=r;
		return;
	}
	int mid=(l+r)/2;
	Build(i*2,l,mid);
	Build(i*2+1,mid+1,r);
	Pushup(i);
}
node m1,m2;
inline node Max1(int i,int l,int r,int l1,int r1)
{
	if(l1<=l&&r1>=r)
	{
		a1[0]=t[i].mx1,a1[1]=t[i].mx2,a1[2]=m1,a1[3]=m2;
		sort(a1,a1+4);
		m1=a1[3];
		for(int j=2;j>=0;j--)
			if(a1[j].val!=a1[j+1].val)
			{
				m2=a1[j];
				break;
			}
		return t[i].mx1;
	}
	if(l1>r||r1<l)
		return Zero;
	int mid=(l+r)/2;
	return max(Max1(i*2,l,mid,l1,r1),Max1(i*2+1,mid+1,r,l1,r1));
}
inline void Modify(int i,int l,int r,int x1)
{
	if(l>x1||r<x1)
		return;
	if(l==x1&&r==x1)
	{
		t[i].mx1=t[i].mx2=Zero;
		return;
	}
	int mid=(l+r)/2;
	Modify(i*2,l,mid,x1);
	Modify(i*2+1,mid+1,r,x1);
	Pushup(i);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	Build(1,1,n);
	for(int i=1;i<=n;i++)
	{
		m1=m2=Zero;
		Max1(1,1,n,i,min(i+m,n));
		if(m1.val==ans[i-1])
		{
			if(m2.val)
			{
				ans[i]=m2.val;
				Modify(1,1,n,m2.id);
				m-=m2.id-i;
			}
		}
		if(m1.val!=ans[i-1]&&m1.val)
		{
			ans[i]=m1.val;
			Modify(1,1,n,m1.id);
			m-=m1.id-i;
		}
	}
	for(int i=1;i<=n;i++)
		printf("%d ",ans[i]?ans[i]:-1);
	return 0;
}
```

---

## 作者：DarthVictor (赞：2)

# 总体思路

总的过程就是从左向右在每个位置（盒子）上填数（魔力值）。

## 1. 正常填数

假设我们正在填位置 $i$ 上面的数，由于要字典序尽量大，所以我们需要找位置 $[i,k+i]$ （体力值限制）范围内最大的数；对于数值相同的数，我们应该优先考虑更靠左的，因为随着从左向右填数，更靠左的数会更先无法使用，我们不能让它浪费。

所以我们现在需要干的事情就很明显了：维护一个线段树，用于快速查询一段位置内最大的且更靠左的数。每次填数时就查一下，把最大数取出来填上去，然后把该位置上的数置为 $-1$ 表示已经被取用了（置为 $-1$ 还有一个好处是题目要求空置的话也是写 $-1$ ，所以无数可用时直接把查出来的 $-1$ 放上去就行了，很省事，不需要别的特殊处理），同时修改剩余体力值。

## 2. 解决相同数字不能相邻的条件

线段树部分很简单，然而这个题还有一个很讨人嫌的条件：不能和前一个数相同。因此我们现在就需要考虑如果查出来的最大数和前面相同该怎么办了。我的第一想法是把所有相同的最大数全取出来，记一下位置，等填完次大数再全都放回去。然而这样的话时间复杂度就假了，比如所有数全都是一样的你不就炸了吗。

仔细思考一下，这个方法的问题在于我把取出来的数又放回去了，导致不能保证每个数被操作的次数。那么我就需要想办法不把这些已经被取出来的最大数放回去，而是进行一些别的保留操作。最后想出来的方法是维护一个队列，把这些最大数全都扔进去，之后每次填数时先查看队首的元素能否使用（是否在 $[i,k+i]$ 内？是否和前数相同？），可以的话就直接使用，否则还是正常进行线段树查数。这样就可以保证每个数最多只被取用一次，复杂度就对了。

一些具体实现细节见代码及相关注释。

# 代码
```cpp
#include<bits/stdc++.h>
#define re register
#define lch (rt<<1)
#define rch (rt<<1|1)
#define mid (l+r>>1)
using namespace std;
const int maxn=1e5+3;
int n,k,all[maxn],ans[maxn];
queue<pair<int,int> > q;
pair<int,int> tree[maxn<<2]; //第一维是数值，第二维是位置
pair<int,int> merge(pair<int,int> a,pair<int,int> b){ //用于比较出较大的且更靠左的数
    if(a.first==b.first) return a.second<b.second?a:b;
    else return a.first>b.first?a:b;
}
void build(int rt,int l,int r){ //建树
    if(l==r) return tree[rt]=make_pair(all[l],l),void();
    build(lch,l,mid);
    build(rch,mid+1,r);
    tree[rt]=merge(tree[lch],tree[rch]);
}
void modify(int rt,int l,int r,int loc,int w){ //修改线段树某个位置的值
    if(l==r) return all[l]=w,tree[rt]=make_pair(all[l],l),void();
    if(loc<=mid) modify(lch,l,mid,loc,w);
    else modify(rch,mid+1,r,loc,w);
    tree[rt]=merge(tree[lch],tree[rch]);
}
pair<int,int> query(int rt,int l,int r,int s,int t){ //查询[s,t]内最大的数
    if(s<=l&&t>=r) return tree[rt];
    else if(t<=mid) return query(lch,l,mid,s,t);
    else if(s>=mid+1) return query(rch,mid+1,r,s,t);
    else return merge(query(lch,l,mid,s,t),query(rch,mid+1,r,s,t));
}
int main(){
    cin>>n>>k;
    for(re int i=1;i<=n;i++) cin>>all[i];
    build(1,1,n);
    for(re int i=1;i<=n;i++){
        while(!q.empty()&&q.front().second<i) q.pop();
        //若队首的数不可用则进行线段树查询
        if(q.empty()||i==1||q.front().first==ans[i-1]||q.front().second>k+i){
            pair<int,int> tmp=query(1,1,n,i,k+i);
            //把所有和前数相同的最大数全都拿出来进队
            //注意一个细节：两个-1可以相邻，这里不特判掉会出问题
            while(tmp.first==ans[i-1]&&tmp.first!=-1){
                q.push(tmp);
                modify(1,1,n,tmp.second,-1);
                tmp=query(1,1,n,i,k+i);
            }
            ans[i]=tmp.first;
            modify(1,1,n,tmp.second,-1);
            k-=tmp.second-i;
        }
        //若队首的数可用则直接取用
        else{
            pair<int,int> tmp=q.front();
            q.pop();
            ans[i]=tmp.first;
            k-=tmp.second-i;
        }
    }
    for(re int i=1;i<=n;i++) cout<<ans[i]<<" ";
    return 0;
}
```

---

## 作者：liuchuliang666 (赞：0)

显然这是一道贪心题。

考虑从左至右顺着填数，假设填到了 $i$，为了使字典序尽可能大，我们记 $k$ 为剩余体力值，那么能拿的范围就是 $[i, \min(i + k, n)]$，每次取最大的（附带一下对应位置），如果前面放了就取严格次大，然后把原来的对应位置清空（赋值 $-1$）。

那么考虑用数据结构加速该过程，显然可以用线段树，我们考虑每个节点开两个 `pair` 存最大和严格次大的 $(val, -pos)$ 就行，$pos$ 取符号是为了比大小时优先取靠前的。

那么就完事了，献上丑陋的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#ifdef ONLINE_JUDGE
#define debug(...)
#else
#define debug(...) fprintf(stderr, ##__VA_ARGS__)
#endif
#define endl '\n'
#define eb emplace_back
#define ep emplace
#define fi first
#define se second
#define rep(i, l, r, ...) for (int i = (l), i##e = (r), ##__VA_ARGS__; i <= i##e; ++i)
#define per(i, r, l, ...) for (int i = (r), i##e = (l), ##__VA_ARGS__; i >= i##e; --i)
#define mst(x, val, len) memset(x, val, sizeof((x)[0]) * (int(len) + 1))
#define mcp(from, to, len) memcpy(to, from, sizeof((to)[0]) * (int(len) + 1))
#define Mst(x, val) memset(x, val, sizeof(x))
#define Mcp(from, to) memcpy(to, from, sizeof(from))
#define mid (((l) + (r)) >> 1)
#define ls ((x) << 1)
#define rs ((x) << 1 | 1)
#define lson ls, l, mid
#define rson rs, mid + 1, r
#define pbds __gnu_pbds
#define int int64_t
#define i128 __int128
#define vi vector<int>
#define pii pair<int, int>
#define vpii vector<pii>
#define Add(a, b) ((a) = (((a) + (b)) % mod + mod) % mod)
#define Mul(a, b) ((a) = (((a) * (b)) % mod + mod) % mod)
#define add(a, b) (((a) += (b)) >= mod ? (a) -= mod : (a))
#define mul(a, b) (((a) *= (b)) %= mod)
constexpr int MAXN = 1e5 + 10, inf = 1e9, mod = 998244353, MAXV = MAXN << 2;
template <typename T> inline void chkmx(T &a, const T b) { a = a < b ? b : a; }
template <typename T> inline void chkmn(T &a, const T b) { a = a > b ? b : a; }
int lowbit(int x) { return x & (-x); }
int qpow(int a, int b)
{
    static int res;
    for (res = 1; b; b >>= 1, mul(a, a)) ((b & 1) && mul(res, a));
    return res;
}
int inv(int x) { return qpow(x, mod - 2); }
bool MST;
int n, k, a[MAXN];
struct node
{
    pii mx, smx; // (val, -pos)
} tr[MAXV];
node operator+(const node &lhs, const node &rhs)
{
    vpii vec{lhs.mx, lhs.smx, rhs.mx, rhs.smx};
    sort(vec.begin(), vec.end(), greater<>());
    node res{vec.front(), {-1, 0}};
    rep(i, 1, 3) if (vec[i].fi != vec[0].fi)
    {
        res.smx = vec[i];
        break;
    }
    return res;
}
void build(int x, int l, int r)
{
    if (l == r) return cin >> tr[x].mx.fi, tr[x].mx.se = -l, tr[x].smx = {-1, 0}, void();
    build(lson), build(rson), tr[x] = tr[ls] + tr[rs];
}
void update(int x, int l, int r, int p)
{
    if (l == r) return tr[x].mx.fi = -1, void();
    if (p <= mid)
        update(lson, p);
    else
        update(rson, p);
    tr[x] = tr[ls] + tr[rs];
}
node query(int x, int l, int r, int pl, int pr)
{
    if (pl <= l && r <= pr) return tr[x];
    if (pr <= mid) return query(lson, pl, pr);
    if (mid < pl) return query(rson, pl, pr);
    return query(lson, pl, pr) + query(rson, pl, pr);
}
bool MED;
signed main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    debug("Memory Used: %.2lf Mib.\n", (&MST - &MED) / 1024. / 1024.);
    cin >> n >> k, build(1, 1, n), mst(a, -1, n);
    rep(i, 1, n)
    {
        node res = query(1, 1, n, i, min(i + k, n));
        if (a[i - 1] != res.mx.fi)
        {
            if (!~res.mx.fi) continue;
            a[i] = res.mx.fi;
            k -= -res.mx.se - i;
            update(1, 1, n, -res.mx.se);
        }
        else
        {
            if (!~res.smx.fi) continue;
            a[i] = res.smx.fi;
            k -= -res.smx.se - i;
            update(1, 1, n, -res.smx.se);
        }
    }
    rep(i, 1, n) cout << a[i] << " ";
    return 0;
}
```

---

## 作者：IC0CI (赞：0)

# 题面分析

先不考虑限制条件。

对于位置 $i$ 可以取到的点有 $[i,i + k]$ 内任意数。

要求字典序最大意味着我们可以贪心地取 $[i,i + k]$ 中最靠近 $i$ 最大值，这里贪心易证（若在 $i$ 处选择第二大的数则形成的序列字典序一定小，若取较远的最大值则 $i+1$ 处选择的范围较选较近的时更小）。

于是直接线段树维护 $[i,i + k]$ 的最大值，每次选择最大值后再线段树中单点修改去掉该点。

考虑限制条件：且任意两个相邻盒子不能存放魔力值相同的宝石。

限制条件意味着有时候取不了最大值，要取严格次大值，因此再维护严格次大值即可。

## 关于具体实现

在维护最大值和严格次大值的时候注意优先选择下标靠前即距离 $i$ 更近的。

在选择 $-1$ 即不选时注意不需要消耗体力。

## Code

复杂度 $\mathcal{O}(n \log_2{n})$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pii pair<int,int>

int rd()
{
    int x = 0,w = 1;
    char ch = 0;
    while(ch < '0' || ch > '9')
    {
        if(ch == '-') w = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9')
    {
        x = x * 10 + (ch - '0');
        ch = getchar();
    }
    return x * w;
}

const int N = 1e5 + 5;
int n,k;
int a[N],ans;

#define ls (p << 1)
#define rs (ls | 1)
#define mid ((pl + pr) >> 1)

struct node
{
    pii mx,semx;
}t[N << 2];

node merge(node l,node r)
{
    pii tmp[4] = {l.mx,l.semx,r.mx,r.semx};
    sort(tmp,tmp + 4,[](const pii &a,const pii &b) { return a.first == b.first ? a.second < b.second : a.first > b.first; });
    pii mx = tmp[0];
    pii semx = {-1,0};
    for(int i = 1;i < 3;i++)
    {
        if(tmp[i].first < mx.first)
        {
            semx = tmp[i];
            break;
        }
    }
    return {mx,semx};
}

void pu(int p) { t[p] = merge(t[ls],t[rs]); }

void build(int p,int pl,int pr)
{
    if(pl == pr) return (void)(t[p] = {{a[pl],pl},{-1,0}});
    build(ls,pl,mid);
    build(rs,mid + 1,pr);
    pu(p);
}

void upd(int p,int pl,int pr,int lr,int d)
{
    if(pl == pr) return (void)(t[p] = {{d,pl},{-1,0}});
    if(lr <= mid) upd(ls,pl,mid,lr,d);
    else upd(rs,mid + 1,pr,lr,d);
    pu(p);
}

node qry(int p,int pl,int pr,int l,int r)
{
    if(l <= pl && pr <= r) return t[p];
    if(r <= mid) return qry(ls,pl,mid,l,r);
    if(l > mid) return qry(rs,mid + 1,pr,l,r);
    return merge(qry(ls,pl,mid,l,r),qry(rs,mid + 1,pr,l,r));
}

signed main()
{
    n = rd(),k = rd();
    for(int i = 1;i <= n;i++) a[i] = rd();
    build(1,1,n);
    for(int i = 1;i <= n;i++)
    {
        node res = qry(1,1,n,i,min(i + k,n));
        if(res.mx.first != ans)
        {
            ans = res.mx.first;
            if(res.mx.first != -1)
            {
                upd(1,1,n,res.mx.second,-1);
                k -= res.mx.second - i;
            }
        }
        else
        {
            ans = res.semx.first;
            if(res.semx.first != -1)
            {
                upd(1,1,n,res.semx.second,-1);
                k -= res.semx.second - i;
            }
        }
        cout << ans << ' ';
    }
    return 0;
}
```

---


# 排除干扰

## 题目背景

其实，莲子有所不知的是，梅莉早在几周前就瞒着她一个人去探险，至今未归。得知了此事的莲子后悔万分。

为了找到失踪的梅莉，莲子独自前去梅莉家寻找线索，但她翻箱倒柜却仍一无所获。

“该怎么办啊！要是能排除干扰，找到有用的线索就好了。对了，那就以梅莉的视角想想吧！”

## 题目描述

**这是一道交互题。**

为了同时从两者的角度思考，莲子在内心构想了一场博弈，而主角则仍是小 R 与小 M，规则如下：

小 R 和小 M 初始均有 $m$ 张牌，牌共有 $n$ 类，编号为 $1$ 到 $n$。**保证她们初始拥有每类牌至少一张**。她们可以互相看见手牌。

小 R 和小 M 轮流弃牌，**其中小 R 为先手**。每回合她们都要丢弃恰好一张牌。当她们均把牌弃到只剩一张时，假设小 R 的牌为 $u$，小 M 的牌为 $v$，那么小 R 获得的分数为 $a_{u,v}$，小 M 获得的分数为 $-a_{u,v}$。她们都希望自己的得分尽可能高。

现在，你需要和交互库模拟一局游戏，若 $c=0$，你将扮演小 R；若 $c=1$，你将扮演小 M。你取得的分数至少需要达到双方均以最优策略决策时所得到的分数。

## 说明/提示

### 样例解释

#### 样例 \#1

你将扮演小 R（先手）游玩。假设你丢弃一张 $1$ 类牌，对手丢弃一张 $2$ 类牌，最终你的得分即为 $1$。可以证明，得分 $1$ 即为最优得分。

注意到该样例同时符合特殊性质 $\mathbf{B}$ 和 $\mathbf{C}$。
#### 样例 \#2

你将扮演小 R（先手）游玩。可以证明，最终小 R 的得分 $3$ 即为最优得分。

注意到该样例符合特殊性质 $\mathbf{A}$。
#### 样例 \#3

你将扮演小 M（后手）游玩。可以证明，最终小 M 的得分 $1$ 即为最优得分。

### 数据范围

**本题采用捆绑测试。**

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|}\hline
\textbf{Subtask} & \textbf{\textsf{分值}} & \bm{n\le} & \bm{m\le} & \textbf{\textsf{特殊性质}}&\textbf{Subtask \textsf{依赖}}\cr\hline
1 & 20 & 5 & 5 & - &-\cr\hline
2 & 15 & 10^3 & 10^4 & \mathbf{A}&- \cr\hline
3 & 20 & 10^3 & 10^4 & \mathbf{B}&- \cr\hline
4 & 20 & 10^3 & 10^3 & \mathbf C&-  \cr\hline
5 & 25 & 10^3 & 10^4 & -&1,2,3,4  \cr\hline
\end{array}
$$

特殊性质 $\mathbf{A}$：保证 $a_{i,j}=i+j$。\
特殊性质 $\mathbf{B}$：保证 $a$ 中只出现 $0$ 和 $1$。\
特殊性质 $\mathbf{C}$：保证每人初始拥有每类牌恰好一张。

对于所有数据满足：$1\le n\le 10^3$，$1\le m\le 10^4$，$0\le |a_{i,j}|\le 10^8$，$1\le R_i,M_i \le m$ 且 $\sum R_i = \sum M_i = m$。保证交互库进行的操作均合法。

## 样例 #1

### 输入

```
2 2 0
1 0
1 1
1 1
1 1

2
0```

### 输出

```





1```

## 样例 #2

### 输入

```
2 2 0
2 3
3 4
1 1
1 1

2
0```

### 输出

```





1
```

## 样例 #3

### 输入

```
2 3 1
1 -2
-1 2
1 2
2 1
1

2

0
```

### 输出

```






1

2```

# 题解

## 作者：Graphcity (赞：11)

游戏是这样的，先手只需要留住一张牌，而后手需要考虑的事情就多了。

---

首先考虑特殊性质 B。有结论：**如果存在全为 1 的行，那么先手必胜，否则后手必胜**。

我们在 $a$ 这个矩阵上考虑问题。一个 $r_i$ 对应一行，如果 $r_i=0$ 代表删去这一行；一个 $m_i$ 对应一列，如果 $m_i=0$ 代表删去这一列。所以如果有一行全为 1，那么先手只需要保证最后留下来的是这一行即可，其它随便操作。

接下来我们证明不存在全为 1 的行时，后手必胜。考虑如下策略：当后手操作时，如果存在一个 $m_i>1$，那么就抽掉这一张卡牌，直到所有 $m_i$ 均等于一为止。那么在接下来的每一轮，当后手进行操作时，总有剩下的行数小于列数。

根据抽屉原理，我们在每一行里面任意标记一个 0 的位置，那么至少存在一列没有被标记。我们把没有被标记的列删去即可，仍然可以变成不存在全 1 行的情况。如此操作下去，最后剩下的一个位置一定是 0。

考虑一般情况，我们可以二分 $mid$，将 $\ge mid$ 的赋值为 1，$<mid$ 的赋值为 0，那么如果存在全 1 行则代表答案 $\ge mid$。实际操作中，所有行的最小值里面，最大的那一个就是答案。

直接按上述方法模拟即可做到 $O(nm)$。

[**Code**](https://www.luogu.com.cn/paste/gyi3hccj)

---

## 作者：佬头 (赞：5)

## Description
简单来说就是，给定一个矩阵 $A$，先手每删除一行，后手就得删除一列，直至最后仅剩一个数。若你是先手，则应尽量让该数大；否则应尽量让该数小。你的答案**至少**需要达到双方**均用最优策略**（下文简称“最优情况”）时的结果。

## Solution
注意：此题只要求**优于等于**最优情况时的结果，并不需要求出最优解。（不用实时求最小值了，具体往下看）

首先无论先手还是后手，都应先让自己每类牌**仅剩下一张**，因为多余的确实没用。
-	**先手**控制行数，因此只要考虑行的性质即可。为了使结果越大，应抬高下限，不断将现有的数中**最小值最小**的那一行删除。

	记每行最小值为 $minn_i$，在最优情况下，结果应是 $\max \{minn_i\}$。因此不管后手如何，保留最小值最大的那一行即可。
-	**后手**控制列数，为了使结果越小，一个思路就是**绝对不能动每一行的最小值**（若一行有多个，仅取其中一个作为**最重要**的，其他不考虑），不然就有可能辅助先手抬高下限。因此应不断将没有 $minn_i$ 的一列删除。

	在先手删除一行后，$minn_i$ 的个数（即行数）就小于了列数，则至少有一列满足条件。

代码时间复杂度 $\mathcal O(nm)$。
## Code
```cpp
#include <iostream>
using namespace std;
const int N = 1003;
int n, m, c, a[N][N], minn[N], cnt[N], vec[N], front, back, rm[N], mm[N], p = 1;
int read(){
	int x = 0;
	bool tf = 1;
	char a = getchar();
	while(a < '0' || '9' < a) a == '-'? tf = 0: 0, a = getchar();
	while('0' <= a && a <= '9') x = (x << 1) + (x << 3) + (a ^ 48), a = getchar();
	return tf? x: -x;
}
void write(int x){
	if(x > 9) write(x / 10);
	putchar(x % 10 | 48);
}
int main(){
	n = read(), m = read(), c = read();
	for(int i = 1; i <= n; ++ i){
		minn[i] = 1;
		for(int j = 1; j <= n; ++ j){
			a[i][j] = read();
			if(a[i][minn[i]] > a[i][j]) minn[i] = j;
		}
	}
	for(int i = 1; i <= n; ++ i) rm[i] = read();
	for(int i = 1; i <= n; ++ i) mm[i] = read();
	if(c){ //小M
		for(int i = 1; i <= n; ++ i) ++ cnt[minn[i]];
		for(int i = 1; i <= n; ++ i) if(!cnt[i]) vec[++ back] = i;
		for(int i = 2; i <= m; ++ i){
			int rival = read();
			if(!-- rm[rival] && !-- cnt[minn[rival]]) vec[++ back] = minn[rival];
			while(p <= n)
				if(mm[p] -- > 1){
					write(p), putchar('\n');
					break;
				}
				else ++ p;
			if(p > n) write(vec[++ front]), putchar('\n');
			fflush(stdout);
		}
		return 0;
	} //小R
	for(int i = 2; i <= n; ++ i) if(a[i][minn[i]] > a[p][minn[p]]) p = i;
	for(int i = 1; i <= n; ++ i) while(rm[i] -- > (i == p)) write(i), putchar('\n');
	return 0;
}
```

---

## 作者：chen_zhe (赞：5)

$a_{i,j}$ 只能为 $0$ 或 $1$ 的点很有启发性，因为如果我们做出了这一部分分，那么整道题就可以用二分的方式解决（虽然正解完全不需要二分，原因之后讲）。并且这道题保证每个人拥有每类牌至少一张，所以两人的最优策略一定是先把每类牌弃到恰好有一张，我们不妨先考虑每人恰有每类牌各一张的 case。

容易发现小 M 有着整场游戏的主导权，因为小 R 先弃牌。我们不妨以小 M 的视角思考游戏。

我们把小 R 手里的牌编号为 $1$ 到 $n$，小 M 手里的牌编号为 $n+1$ 到 $2n$，然后把它们试做节点，那么就可以把 $a_{i,j}$ 为 $0$ 视做 $i$ 和 $j+n$ 之间有一条边，这样弃牌就变成了删点。小 M 希望最终留下来的两点之间有边，所以如果有边那么小 M 赢，否则小 R 赢。

如果 $1$ 到 $n$ 中有一个点和 $n+1$ 到 $2n$ 中所有的点间都没边，那么小 R 只要保留这个点就赢了。否则对于 $1$ 到 $n$ 中的每个点，它一定有到某些 $n+1$ 到 $2n$ 的点的边。我们让点 $i$（$1\le i\le n$）对应某个点 $e_i$（$n+1\le e_i\le 2n$），然后连边 $i\to e_i$，在小 R 删点后，小 M 只需要选择一个度数为 $0$ 的点删掉即可。容易证明这样的点一定存在。很显然，最后留下的两点之间一定有边。所以对于其余的情况，小 M 必胜。

我们不妨整理一下结论，然后关注更加一般的情况，即 $a_{i,j}$ 为任意值。我们发现我们需要二分出一个值 $x$，满足 $x$ 最小，而且矩阵 $a$ 的每行都有至少一个数小于等于 $x$。$x$ 即为两人最终的游戏结果。容易发现这个数即为所有行的 $\min$ 的 $\max$，所以根本无需二分。

那么接下来是一些实现上的问题，实现小 R 的策略是容易的，但是实现小 M 的策略则有些困难，因为小 R 不一定总会使用最优策略，这让我们需要考虑种类重复的牌。不过我们仍然可以使用完全一样的方法，对于小 R 的每张种类为 $i$ 的牌，都建一个连向 $e_i$ 的点，然后你只需要把每类牌都删到只剩一张后使用上述策略即可。

---

## 作者：是青白呀 (赞：3)

无论是小 M 还是小 R，都可以先弃掉所有重复的牌，这样一定不劣。下面只考虑每人手中有每张牌恰好一张的情况。

此时，考虑整个过程等价于：先手每次删掉矩阵的某一行，后手每次删掉矩阵的某一列，最终的得分就是剩下的那个数。先手可以独立地锁定最后剩下来的那个数在哪一行，后手可以独立地锁定最后生下来的那个数在哪一列。假设第 $i$ 行的最小值为 $minn_i$，其所在的位置为第 $pos_i$ 列，所有行上最小值的位置集合为 $S$（若一行上有多个最小值，我们**只认为其中的某一个是该行的最小值**），显然有 $|S|=n$。

首先，先手一定能使最终的得分取到不小于 $\max minn_i$ 的值，只需要锁定该值所在的那一行，依次删除其它行即可。

其次，后手一定能使最终剩下的数的位置在 $S$ 集合内。具体地，我们维护 $cntp_i$ 表示第 $i$ 列当前还剩下多少个数是对应行的最小值，也即在 $S$ 中。假设当前该后手操作第 $i$ 次，则此时剩余的列数为 $n-i+1$；而先手已经操作了 $i$ 次，剩余行数为 $n-i$，因此 $\sum cntp_i=n-i<n-i+1$，故必定存在某一列 $x$ 使得 $cntp_x=0$。我们考虑每次删除列 $x$，则 $S$ 集合中的数只会被先手删除 $n-1$ 次，而后手不会删除，故最终剩下的那个数一定在 $S$ 集合中。

因此，在最优策略下，剩下的那个值一定是位置在 $S$ 集合中的、不小于 $\max minn_i$ 的值，也即 $\max minn_i$。

根据上文所述策略，不难构造出对应方案。总时间复杂度 $O(nm)$。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) (x<<1)
#define rs(x) ((x<<1)|1)
#define mp make_pair
#define sec second
#define fir first
#define pii pair<int,int>
#define lowbit(i) i&-i
using namespace std;
typedef long long ll;
const int N=1005,M=105,inf=1e9+7,mo=1e9+7;
void read(int &p){
	int x=0,w=1;
	char ch=0;
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int n,m,c;
int a[N][N];
int cntn[2][N];
queue<int>q;
int pos[N],cntp[N];
int main(){
	read(n),read(m),read(c);
	rep(i,1,n){
		rep(j,1,n)
		    read(a[i][j]);
	}
	rep(j,0,1){
		rep(i,1,n)
		    read(cntn[j][i]);
	}
	if(c==0){
		int targ=0,maxn=-inf;
		rep(i,1,n){
			int minn=inf;
			rep(j,1,n)
			    minn=min(minn,a[i][j]);
			if(maxn<minn)maxn=minn,targ=i;
		}
		rep(i,1,n){
			rep(j,1,cntn[0][i]-(i==targ)){
				printf("%d\n",i);
				fflush(stdout);
				int op;
				read(op);
			}
		}
	}
	else{
		rep(i,1,n){
			rep(j,1,n)
				if(!pos[i]||a[i][pos[i]]>a[i][j])pos[i]=j;
		}
		rep(i,1,n)
		    cntp[pos[i]]++;
		rep(i,1,n){
			rep(j,1,cntn[1][i]-1){
				int op;
				read(op),cntn[0][op]--;
				if(!cntn[0][op])cntp[pos[op]]--;
				printf("%d\n",i),fflush(stdout);
			}
		}
		rep(i,1,n-1){
			int op;
			read(op),cntn[0][op]--;
			if(!cntn[0][op])cntp[pos[op]]--;
			rep(j,1,n){
				if(cntp[j]==0){
					printf("%d\n",j),fflush(stdout),cntp[j]=-1;
					break;
				}
			}
		}
	}
	int res;
	read(res);
	return 0;
}
```

---

## 作者：yywlp (赞：3)

中档题，第一次做这种类型的题，挺有意思，但不算难。

我们可以直接考虑双方都采取最优策略时的方案，然后严格按照这个方案来取一定不劣于最优方案。

这里先观察游戏的性质，根据最后的得分方式可以发现，玩家弃一张牌相当于丢失在矩阵上一行或一列的**控制权**（小 R 丢失**行**的控制权，小 M 丢失**列**的控制权）并且小 R 要最后留的数最大，小 M 要最后留的数最小。

那么真正的博弈应该开始于双方每个类型的卡都剩一张的时候（因为前面的弃牌双方肯定都不会让自己丢失矩阵控制权），所以我们相当于直接考虑 $n=m$ 的情况。

如果直接观察不好发现结论可以看看数据较小的时候，比如说 $n=2$。

这时候小 R 先取，假如他随便弃一行，那小 M 肯定会弃掉数字更大的那一列，所以小 R 为了最后的数字最大，他会弃掉最小值更小的那一行。

好像有点感觉，看看更大的时候怎么办，根据上一个弃法，小 R 应该弃最小值最小的那一行，那现在小 M 该怎么办？不难发现，现在只有 $n-1$ 行，但是有 $n$ 列。同时，每一行有一个最小值，那么总共有 $n-1$ 个最小值，也就是说至少有一列没有最小值，小 M 弃这几列中的一列一定不劣于弃有最小值的列。

这里弃法已经完备了，总结一下就是小 R 会弃最小值最小的那一行，小 M 会弃没有最小值的列。

那我们开 $n$ 个线段树维护每一行的最小值和对应的列，如果第 $i$ 列被弃了则将每一行的线段树的第 $i$ 个位置改为 $\infty$ 就行，接下来按照上述方案模拟就行。

时间复杂度 $\mathcal O(mn\log n)$。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+10,M=1e4+10;
int n,m,c;
int a[N][N];
int x[M],y[M];
struct TR{
#define lc k<<1
#define rc k<<1|1
#define mid ((l+r)>>1)
	int tr[M<<1],id[M<<1];
	void pushup(int k){
		if(tr[lc]<tr[rc])tr[k]=tr[lc],id[k]=id[lc];
		if(tr[rc]<tr[lc])tr[k]=tr[rc],id[k]=id[rc];
	}
	void update(int k,int l,int r,int x,int v){
		if(l==r)tr[k]=v,id[k]=mid;
		else{
			if(x<=mid)update(lc,l,mid,x,v);
			else update(rc,mid+1,r,x,v);
			pushup(k);
		}
	}
}T[N];
bool pd[N];
signed main(){
	cin>>n>>m>>c;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			scanf("%d",&a[i][j]);
			T[i].update(1,1,n,j,a[i][j]);
		}
	}
	vector<int>xr,xm;
	for(int i=1;i<=n;i++){
		cin>>x[i];
		for(int j=2;j<=x[i];j++)xr.push_back(i);
	}
	for(int i=1;i<=n;i++){
		cin>>y[i];
		for(int j=2;j<=y[i];j++)xm.push_back(i);
	}
	if(c==0){
		for(int i=1;i<m;i++){
			if(!xr.empty()){
				auto it=xr.begin();
				cout<<*it<<endl;
				x[*it]--;
				xr.erase(it);
				fflush(stdout);
			}else{
				int minn=1e9,id=0;
				for(int j=1;j<=n;j++){
					if(x[j]==0)continue;
					int nm=T[j].tr[1];
					if(nm<minn){
						minn=nm;
						id=j;
					}
				}
				x[id]--;
				cout<<id<<endl;
				fflush(stdout);
			}
			int op;cin>>op;
			y[op]--;
			if(y[op]==0){
				for(int j=1;j<=n;j++){
					T[j].update(1,1,n,op,1e9);
				}
			}
		}
		int ans;cin>>ans;
	}else{
		for(int i=1;i<m;i++){
			int op;cin>>op;
			x[op]--;
			if(!xm.empty()){
				auto it=xm.begin();
				cout<<*it<<endl;
				y[*it]--;
				xm.erase(it);
				fflush(stdout);
			}else{
				memset(pd,0,sizeof pd);
				for(int j=1;j<=n;j++){
					if(x[j]==0)continue;
					int nm=T[j].id[1];
					pd[nm]=true;
				}
				int id=0;
				for(int j=1;j<=n;j++){
					if(!y[j])continue;
					if(!pd[j]){
						id=j;
						continue;
					}
				}
				cout<<id<<endl;
				y[id]--;
				fflush(stdout);
			}
		}
		int ans;cin>>ans;
	}
	return 0;
}

---


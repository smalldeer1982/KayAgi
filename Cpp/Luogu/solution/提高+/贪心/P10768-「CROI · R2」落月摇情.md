# 「CROI · R2」落月摇情

## 题目背景


>昨夜闲潭梦落花，\
可怜春半不还家。\
>江水流春去欲尽，\
江潭落月复西斜。
>
>斜月沉沉藏海雾，\
碣石潇湘无限路。\
>不知乘月几人归，\
落月摇情满江树。


## 题目描述

小烟是住在月亮上的仙女。为了和人间保持联系，小烟在江边种了一棵树。每当月光透过枝叶洒在江面上，形成特定的图案时，小烟就能与那个人产生心灵感应。为了让形成的图案更加美观，小烟用魔法让树的枝条互相交错成他喜欢的样子。你可以认为这棵树是一个**有 $n$ 个节点、$m$ 条边且无重边、无自环的无向连通图**。

某次小烟出差回到月亮上，发现这棵树上所有的枝条都被破坏了。为了快速恢复和人间的联系，小烟需要施加魔法将 $n$ 个节点重新连接起来。施加魔法生成一条边的代价与这条边对月光投影的影响程度有关。由于小烟忘记了原本树的形态，所以她希望花费最小的代价将这棵树恢复到任意一个可能的原先形态。也就是说，她需要这 $n$ 个节点之间形成一张有 $m$ 条边且无重边、无自环的无向连通图。

考虑到你不是仙女，很难计算每条边对投影的影响程度，善良的小烟给出了一个简单的计算方法：给你每个点的影响程度 $a_i$，则用魔法生成一条边 $(u,v)$ 的代价为 $a_u\times a_v$。请你帮小烟找到一组花费代价最小的施加魔法的方案。

**形式化地**，给出 $n$ 个点，每个点有点权 $a_i$，你需要构造一张有 $m$ 条边，且无重边、无自环的无向图，使得这 $n$ 个点连通。设边 $(u,v)$ 的权值为 $a_u\times a_v$，你需要最小化图中所有边的权值和。

## 说明/提示

**【Special Judge】**

本题采用 Special Judge。只要你输出的图满足无重边、无自环且连通，同时其边权和与你输出的答案一致且输出的答案与标准答案一致，你就可以通过对应的测试点。

需要注意的是，请确保你的输出符合输出格式中的要求，否则你得到的结果可能不确定。

本题开启子任务依赖。你可以得到一个子任务对应的分数，当且仅当你通过了当前子任务，同时你也通过了当前子任务依赖的所有子任务。具体的依赖情况见“数据范围”部分的表格。

**【数据范围】**

对于所有数据，满足 $1\leq n\leq 10^6$，$n-1\leq m\leq \min(10^6,\frac{n(n-1)}{2})$，$0\leq |a_i|\leq 10^6$。

本题开启捆绑测试、开启子任务依赖。

|  子任务编号  | $n \le$ | $m \le$ | 特殊性质 | 分值 |子任务依赖|
| :----------: | :-----: | :--------------: | :------------: | :-----: | :-----: |
|$1$ |$7$ | $21$ | 无 |$10$| 无 |
| $2$ | $16$ |  $120$ | 无 |$15$| $1$ |
|  $3$  | $1000$ | $3\times 10^5$| 无 |$15$|$1,2$|
| $4$ | $2\times 10^5$ | $3\times 10^5$ | 保证 $a_i$ 为非负整数 |$15$|无|
| $5$ | $2\times 10^5$ | $3\times 10^5$ | 保证 $m=n-1$ |$10$|无|
| $6$ | $2\times 10^5$ | $3\times 10^5$ |  无  | $15$|$1,2,3$|
| $7$ | $10^6$ | $10^6$ |  无  | $20$|$1,2,3,6$|

**【样例解释】**

- 对于样例一，构造出的图如下图所示。边权和为 $2+-2+-4+-3+-6=-13$。该样例的构图方式是唯一的。

   ![](https://cdn.luogu.com.cn/upload/image_hosting/nd1clogk.png)

- 对于样例二，构造出的图如下图所示。边权和为 $-3+-6+-12+-15+0=-36$。该样例还存在其它正确的构图方式，比如你可以把边 $(5,6)$ 改为边 $(5,3)$。
  
   ![](https://cdn.luogu.com.cn/upload/image_hosting/6fm944rj.png)

## 样例 #1

### 输入

```
4 5
1 2 -2 -3```

### 输出

```
-13
1 2
1 3
1 4
2 3
2 4```

## 样例 #2

### 输入

```
6 5
1 2 4 5 0 -3```

### 输出

```
-36
1 6
2 6
3 6
4 6
5 6```

# 题解

## 作者：FanMingxuan (赞：21)

# P10768（贪心+分类讨论+多路归并优先队列）

## 题目大意：
给你 $n$ 个点，每个点有点权。

这 $n$ 个点构成一张完全图，每条边的边权定义为两端点权值之积，你需要在这张图中取 $m$ 条边，使得整张图连通，最小化边权之和。
## 前置知识：多路归并优先队列

如果一个问题是由多种选择构成，并且要查询最优解，次优解等等，每种选择有多个决策，最终答案为所有决策取最小值获得，暴力将所有可能扔进优先队列会 TLE/MLE，这时候如果每种选择的决策是由单调性的那么就可以使用多路归并优先队列去优化决策。

例如：

![](https://cdn.luogu.com.cn/upload/image_hosting/yl89nlev.png)

如图所示，我们要求其中的前 $k$ 大的数，我们发现，如果某一行前面的数没有被选择，那么后面的必然不会被选。那么我们可以先把第一列的四个数放入优先队列并注明来源，每次取出队头，并将其后面的决策放入优先队列，直至选出 $k$ 个。


## 思路分析：
要求图连通，并且让选取边权和最小。

这是一类套路性的问题，我们可以**先求出最小生成树，然后把非树边贪心的从小到大加入**。这时候我们观察特殊数据点，有一类数据是 $m = n - 1$ 的，很显然，这道题考察点之一就是如何构建这张图的最小生成树。所以先考虑如何构建最小生成树。

注意到 $n \le 1 \times 10^6$，并且是一张完全图，常见的最小生成树算法如 Kruskal，Prim 都无法应对。

### Part1. 求解最小生成树

我们发现，这道题的边权比较特殊，定义为两端点的点权之**积**，那么我们可以从这里入手，我们可以先对所有点进行一次排序。

考虑对所有数的正负分类讨论：

+ 若所有数均为正数：如 **1 2 3 4 5 6**，不难看出，只需要让除 **1** 以外的所有点向 **1** 连一条边即可，即向点权最小的点连边。

+ 若所有数均为负数：如 **-6 -5 -4 -3 -2 -1**，也不难看出，只需要让除 **-1** 以外的所有点向 **-1** 连一条边即可，即向点权最大的点连边。

+ 若序列中既有正数，又有负数：如 **-2 -1 0 1 2 3**，因为异号两个数相乘一定是最优的，那么对于其中的负数 **-2 -1** ，我们将其向最大的正数 **3** 连一条边，而对于非负数 **0 1 2 3** 我们将其向最小的负数 **-2** 连一条边，我们发现 **-2** 到 **3** 的边我们连了两次，实际编写程序时连接一次即可。

至此，我们通过分类讨论写出了最小生成树，由于有排序，此时复杂度为 $O(n \log n)$，瓶颈在排序。

### Part2. 加入剩余非树边
获得最小生成树后，我们只需要把剩余的 $m - (n - 1)$ 条非树边贪心的加入即可，但是我们不能把剩下的边一次性全部存入优先队列然后取前 $m - (n - 1)$ 条。

这时候我们想到**多路归并优先队列**，我们维护一个小根堆，对每个点都放入最小乘积，每次取出队头，然后把他的下一个决策放进去，若下一个决策和自己重合或者超出范围就直接丢弃，直至达成目标。

我们发现，若某个数是正数，他的决策位置必然是从小到大递增的。反之，如果是负数，他的决策位置必然是从大到小递减的。

时间复杂度 $O(m \log n)$。

### Part3. 剩余问题
+ 我们需要判断一下重边，当我们每加入一条边，我们需要存一下这条边是否被选取，防止重复选择。我们可以使用把 $u$,$v$ 作为一个状态，并把状态存入 unordered_map 即可。

+ 本题卡常，注意代码实现。

+ 不妨设 $n$,$m$ 同阶，总时间复杂度为 $O(n \log n)$。

## 代码实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 3000005; 

struct node{
	long long w; //点权 
	int id; //便于排序后找到原位置 
}a[N];

namespace Graph{
	struct edge{
		int u;
		int v;
	}e[N];
	int cur = 0;
	
	void addedge(int u,int v){
		e[++ cur].u = u;
		e[cur].v = v;
	}
	
	void print(){
		for(int i = 1;i <= cur;++ i){
			printf("%d %d\n",e[i].u,e[i].v);
		}
	}
} //链式前向星 

struct data{
	long long w; //代价 
	int first; //从哪个点出发 
	int current; //当前决策位置 
	int delta; //表示下一个决策的方向 
	
	friend bool operator<(const data& A,const data& B){
		return A.w > B.w; //优先队列维护小根堆 
	}
}; 

int main(){
	int n,m;
	scanf("%d %d",&n,&m);
	for(int i = 1;i <= n;++ i){
		scanf("%lld",&a[i].w);
		a[i].id = i;
	}
	long long ans = 0;
	sort(a + 1,a + n + 1,[](const node& A,const node& B) -> bool const { return A.w < B.w; }); //先排序 
	
	unordered_map<unsigned long long,bool> used; //某条边是否已经选取 
	//这里存边规则为：
	//设小编号为 u，大编号为 v，那么就给 (u << 32) | v 这一状态打上标记 
	if(a[1].w < 0 && a[n].w > 0){ //有正有负 
		for(int i = 2;i < n;++ i){
			if(a[i].w < 0){ //负连最大 
				ans += a[i].w * a[n].w;
				Graph::addedge(a[i].id,a[n].id);
				int u = min(i,n);//小连大 
				int v = max(i,n);
				used[((unsigned long long)u << 32) | v] = true;
			}
			else{ //正连最小 
				ans += a[i].w * a[1].w;
				Graph::addedge(a[i].id,a[1].id);
				int u = min(i,1);//小连大 
				int v = max(i,1);
				used[((unsigned long long)u << 32) | v] = true;
			}
		}
		//最后只处理一次两端连边 
		ans += a[1].w * a[n].w;
		Graph::addedge(a[1].id,a[n].id);
		int u = min(1,n);
		int v = max(1,n);
		used[((unsigned long long)u << 32) | v] = true;
	}
	else if(a[1].w >= 0){ //全正 
		for(int i = 2;i <= n;++ i){ //全连最小 
			ans += a[i].w * a[1].w;
			Graph::addedge(a[i].id,a[1].id);
			int u = min(i,1);//小连大 
			int v = max(i,1);
			used[((unsigned long long)u << 32) | v] = true;
		}
	}
	else{ //全负 
		for(int i = 1;i < n;++ i){ //全连最大 
			ans += a[i].w * a[n].w;
			Graph::addedge(a[i].id,a[n].id);
			int u = min(i,n);//小连大 
			int v = max(i,n);
			used[((unsigned long long)u << 32) | v] = true;
		}
	}
	m -= (n - 1); //计算还需要补充几条边 
	priority_queue<data> q;
	for(int i = 1;i <= n;++ i){
		if(a[i].w > 0 && i != n) q.push({a[i].w * a[i + 1].w,i,i + 1,1}); //{代价，出发点，最优决策，下一个决策的方向}
		else{
			if(i == n) q.push({a[i].w * a[n - 1].w,i,n - 1,-1}); //特判一下最后一个点，最优决策不能和自己重合 
			else q.push({a[i].w * a[n].w,i,n,-1});
		}
	}
	while(m){
		data p = q.top();
		q.pop();
		long long w = p.w;
		int u = p.first;
		int v = p.current;
		int d = p.delta;
		int uu = min(u,v); //小连大 
		int vv = max(u,v);
		if(!used[((unsigned long long)uu << 32) | vv]){ //如果这条边未被使用就加入 
			used[((unsigned long long)uu << 32) | vv] = true;
			Graph::addedge(a[u].id,a[v].id);
			ans += w;
			m --; //补充上了一条 
		}
		if(d == 1){ //如果下一个决策向右 
			if(v == n) continue; //下一个决策会超出范围 直接丢弃 
			if(v + 1 == u) v ++; //下一个决策和自己重叠 再向右移动一个 
		}
		else{ //如果下一个决策向左 
			if(v == 1) continue; //下一个决策会超出范围 直接丢弃 
			if(v - 1 == u) v --; //下一个决策和自己重叠 再向左移动一个 
		}
		if(d == 1 && v == n) continue; //下一个决策会超出范围 直接丢弃 
		if(d == -1 && v == 1) continue; //同上 
		q.push({a[u].w * a[v + d].w,u,v + d,d}); //加入下一个决策 
	}
	printf("%lld\n",ans);
	Graph::print(); //打印构建的图 
	return 0;
}
```
## 后记：

细节有点多，需要仔细实现。

~~不知是哪个蒟蒻赛时没实现完，赛后 20 分钟直接 AC。~~

完结撒花！

---

## 作者：OIer_ACMer (赞：13)

# 题目解析：

本题很明显我们要对数组进行排序，学因为根据我们在小学学过的知识，**一个很小的负数和一个很大的正数相乘是可以得到一个很小数的**，所以我们一开始就将每个数来进行预处理，如果这个数比 $0$ 大，那么就将它的匹配数对设为最小的数，否则是选最大的数。

之后我们可以定义一个数组 $cur$。这个数组的目的是为了记录此时我们匹配到的是哪一个数。毕竟我们在之后不一定只会跟着一个数相匹配，还有很多其他的数。所以当我们在进行其他的匹配的时候，我们就每次更新 $cur_i$ 的值。

之后要注意的是我们在记录每个点跟另外一个点是否匹配的时候，注意时间复杂度，否则会像我一样不断的超时。

代码就不放了，毕竟思路清楚了，就是一道模拟题。

---

## 作者：Leo_SZ (赞：10)

首先，应当发现，这道题分成了两个部分。第一部分求最小生成树，第二部分在最小生成树的基础上，添加 $m-n+1$ 条边，且总权值尽可能小。

## 求最小生成树

参考 Prim 的思路，假如已经求出了若干个点的最小生成树。根据贪心，如果当前点的权值是负数，那么这个点应当连向权值最大的点；如果当前点的权值非负，那么这个点应当连向权值最小的点。

我们对所有的点按照权值排序后，那么除了结点 $1$ 和结点 $n$，其他所有的点都应当连向 $1$ 或 $n$。

```cpp
for(int i=1; i<=n; i++){
	(a[i].val >= 0) ? add_e(1, i) : add_e(i, n);
}
```

## 添加剩余的边

注意到，对于一个负数，与下标越大的数相乘，结果越小。

![](https://cdn.luogu.com.cn/upload/image_hosting/2c2h3vu0.png)

同样的，对于一个正数，与下标越大的数相乘，结果越大。

因此，我们用一个 $cur$ 数组，$cur_i$ 表示点 $i$ 考虑到了哪一个点。在把 $i$ 和 $cur_i$ 加入答案中之前，我们不用考虑 $i$ 和别的点相连。

所以我们可以将所有正在被考虑的边放进一个堆中。堆中边的总数不会超过 $n$。

每当我们从堆中取出一条边时，我们就将 $cur_i$ 往下挪一个，然后将新的边加入堆中。

默认 $n$ 和 $m$ 同级，则时间复杂度 $O(n\log{n})$。

## 实现上的细节

为了去重，以及避免自环，我想到了用 `std::map` 来标记两点之间是否连边。但是被卡常成 80pts 了。换成 `gp_hash_table` 就能轻松通过。

AC 代码：
```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define LL long long
#define Maxn 1000006
using namespace std;
int n,m;
struct node{
	int idx,val;
}a[Maxn];
LL ans;
int cur[Maxn];
priority_queue<pair<LL,int> > q;
__gnu_pbds::gp_hash_table<int,bool> mp[Maxn];
bool add_e(int x, int y){
	if(mp[x][y]){ return 0; }
	mp[x][y] = mp[y][x] = 1;
	ans += 1ll * a[x].val * a[y].val;
	return 1;
}
bool cmp(node x, node y){ return x.val < y.val; }
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++){ scanf("%d",&a[i].val); a[i].idx = i; }
	sort(a+1, a+n+1, cmp);
	
	for(int i=1; i<=n; i++){
		mp[i][i] = 1; // 标记自己与自己连过边，防止自环。
		cur[i] = (a[i].val >= 0) ? 1 : n;
	}
	for(int i=1; i<=n; i++){
		(a[i].val >= 0) ? add_e(1, i) : add_e(i, n);
	}
	
	for(int i=1; i<=n; i++){
		if(a[i].val >= 0){
			while(cur[i] <= n && mp[i][cur[i]]){
				cur[i]++;
			}
			if(cur[i] <= n){
				q.emplace(-1ll * a[cur[i]].val * a[i].val, i);
			}
		} else {
			while(cur[i] >= 1 && mp[i][cur[i]]){
				cur[i]--;
			}
			if(cur[i] >= 1){
				q.emplace(-1ll * a[cur[i]].val * a[i].val, i);
			}
		}
	}
	
	m -= n-1;
	int x;
	while(m){
		x = q.top().second;
//		cerr<<"("<<q.top().first<<")\n";
		q.pop();
		m -= add_e(x, cur[x]);
		if(a[x].val >= 0){
			while(cur[x] <= n && mp[x][cur[x]]){
				cur[x]++;
			}
			if(cur[x] <= n){
				q.emplace(-1ll * a[cur[x]].val * a[x].val, x);
			}
		} else {
			while(cur[x] >= 1 && mp[x][cur[x]]){
				cur[x]--;
			}
			if(cur[x] >= 1){
				q.emplace(-1ll * a[cur[x]].val * a[x].val, x);
			}
		}
	}
	
	printf("%lld\n", ans);
	for(int i=1; i<=n; i++){
		for(pair<int,int> j : mp[i])if(j.first>i && j.second){
			printf("%d %d\n", a[i].idx, a[j.first].idx);
		}
	}
	return 0;
}

```

---

## 作者：是青白呀 (赞：10)

本题最大的限制在于要求图连通。因此我们可以从连通性出发找到一些解题思路。

## Sub 2

首先，一个直接的考虑是动态维护连通块，每次选边并往外部扩展。设 $dp_{s,i}$ 表示当前在连通块内的点的集合为 $s$，已经选了 $i$ 条边的最小边权和。每次转移时枚举连通块内向外连出去的边即可。朴素转移可以做到 $O(2^nn^2m)$，若预处理某个点向某个集合连若干条边的边权最小值，可以做到 $O(2^nnm)$。

## Sub 3

我们考虑另外一个走向。这个问题类似于一个最小生成树问题，只不过我们需要在树的基础上多加 $m-n+1$ 条非树边。考虑一个类似 Kruskal 的过程：对于图上的每条边，我们按权值从小往大排序，然后依次遍历每一条边，对树边和非树边分别维护。若该边可以插入生成树中，则将其插入生成树中，尽量将非树边的名额留出来；否则若还可以新增非树边，则将其作为一条非树边插入；否则这条边会被扔掉。该做法的复杂度瓶颈在对边排序，时间复杂度为 $O(n^2\log n)$。

## Sub 7

一个显然的观察是 Sub 3 做法中，插入生成树的边恰好是完全图的一个最小生成树；而后只需要将所有剩余的边从小到大地加入即可。我们分两个步骤考虑：

1. 首先考虑这个完全图的最小生成树是什么。你发现对于一个权值为正的点，它在完全图上连出去的权值最小的边是连向权值最小的那个点的；对于一个权值为负的点，它在完全图上连出去的权值最大的边是连向权值最大的那个点的。而你如果把这 $n$ 条边拿出来，并去掉其中重复的或连成自环的边，恰好会剩下 $n-1$ 条边，并构成一棵树。由于每个点连出去的边都取到了可能的权值最小值，因此这棵树一定是原图的最小生成树。你就不难在 $O(n\log n)$ 的时间复杂度内求出原图的最小生成树了。
   
2. 接下来考虑非树边的部分。你显然不可能把所有非树边都拿出来排序。我们仍然把点按照权值从小到大排序，不难发现对于一个正权点，它连出去的边的权值是单调递增的；对于一个负权点，它连出去的边的权值是单调递减的。因此，一条边 $(u,v)$ 被加入非树边集合的必要条件是 $u$ 连出去的所有边中，向 $v$ 的所有前缀点（若 $a_u<0$，则是一段后缀）连的边均已被加入非树边集合。于是用堆维护多路归并即可。注意到 $(u,v)$ 会同时在 $(u,v-1)$ 和 $(u-1,v)$ 加入非树边集合时被归并到，需要用一些方式去重。时间复杂度 $O(m\log m)$。
   
   此部分也可以考虑二分解决。二分最大边权 $k$，对每一个点从小往大枚举边权不超过 $k$ 的边，每次枚举到 $m-n+1$ 条就返回 true，即可在每次 check $O(m)$ 的复杂度下找到数量恰好不小于 $m-n+1$ 的权值 $mid$。然后再遍历一遍每个点，先将所有边权小于 $mid$ 的边加入，再用边权等于 $mid$ 的边把 $m$ 条填满即可。复杂度 $O(m\log V)$。

不妨设 $n,m$ 同阶，则最终时间复杂度 $O(n\log n)$。可以通过此题。

---

## 作者：Chancylaser (赞：9)

## $\mathcal{Preface}$

1. 此做法为[是青白呀](https://www.luogu.com.cn/user/359270)题解中提到的二分做法的详细讲解。

2. 经作者测试，此做法不需要卡常，请放心食用。

3. 以下将最大数据的 $n,m$ 视为同阶。

## $\mathcal{Solution} $

形式化题面题目已经给出，故此处不再重复。

### 引子

观察数据范围，很容易想到前三个 sub 的暴力做法。具体的，我们可以将完全图先按照 kruskal 那种方式存起来。为了保证图连通，我们应先用 kruskal 求出完全图的最小生成树，然后再尽量添加除树边外的尽量小的边。时间复杂度 $\mathcal{O(n^2\log n)}$，瓶颈为对这些边的排序。

[参考代码](https://www.luogu.com.cn/record/176605885)。

### 正解

显然，为了通过所有数据，我们并不能像引子那样求最小生成树，需要找到更快的方法。

相对于一般的求最小生成树的题目，此题的边集是完全图。那么可以想到将每个点的权值排序。我们设排完序后的点权序列是 $b$。当然，排序后每个值所对应原序列的编号也要记下来，因为最后要输出每一条边。

我们设一个点的编号是 $i$。
1. 若 $b_i < 0$，那么与它相连的最小的边另一个端点编号一定是 $n$。

2. 若 $b_i > 0$，那么与它相连的最小的边另一个端点编号一定是 $1$。

3. 若 $b_i = 0$，那么与它相连的所有边权值都会是 $0$，那么我们将这一类归为上两类其中之一即可，下面的讲解以及代码我都归入了第一类。

-----------------------------------------

很显然，如果对于每个 $i\in[1,n]$，我们都像上面一样连边，会多出来一条边。考虑多出来的那条边会有哪些情况。

1. $b_1 > 0$，即所有点权大于零，那么 $i=1$ 时会连自环。

2. $b_n \le 0$，即所有点权小于等于零，那么 $i=n$ 时会连自环。

3. $b_1 \le 0,b_n>0$，此时 $1\leftrightarrow  n$ 这条双向边会连两次。

那么，将这条边去掉，其余 $n-1$ 条便为树边。

----------------------------------

接下来我们应添加剩下 $m-n+1$ 条非树边。注意，这些边的边权并不一定比树边的边权大，因为树边是为了图连通而迫不得已连接的。

根据上面找最小生成树的思路，我们发现，如果一个点的点权小于零，那么我们对他连边一定是连排完序后的序列后缀所对应的点，反之如果一个点的点权大于零，则是连序列前缀所对应的点。这样才能保证最后的图边权之和最小。

------------------------------------

对于二分敏感的同学很快就能反应过来：唉？二分最后的图中的最大边权，最后判断所有能连的边是否大于等于 $m$ 不就行了吗？

然后需要注意一些细节，假设最后二分到的最大边权为 $val$，那么小于 $val$ 的边显然都可以加上去了，但是等于 $val$ 的边需要一条一条加，防止最后的边大于 $m$。

----------------------------

大概思路确实是这样，对自己能力自信的同学可以看到这里，去写写试试。我在这里说一些坑点及技巧，以便大家不被浪费时间。

1. 注意二分左边界必须设到负无穷**而不是树边的最大值**，如上面所说：非树边的边权并不一定比树边的边权大，因为树边是为了图连通而迫不得已连接的。因为我们二分的目的是添加非树边，默认树边已经连完了。

2. 添加边时，先添加树边，保证图连通。然后再添加小于 $val$（意义如上）的边，最后添加等于 $val$ 的边。时刻注意添加的边不要重了（因为是无向图）。

3. 写二分的 $check$ 时，设目前二分的最大边权为 $mid$，我们只计算除树边的边，最后边权小于等于 $mid$ 的边的数量 $sum\ge 2*m-2*(n-1)$ 即可。乘二的原因是计数时将重边加上比较好算，最后与目标值（即 $2*m-2*(n-1)$）的二倍比较即可。

时间复杂度瓶颈在于二分，设输入的点权最大值为 $s$，则计算得时间复杂度为 $\mathcal{O(n \log s)}$。

具体实现请看代码。


```cpp
#include<bits/stdc++.h>
#define int long long
#define PII pair<int,int>
using namespace std;
typedef long long LL;
const int N=1e6+5,INF=1e12;

int n,m;

struct qwq{
	int pos,sum;
}a[N];

bool cmp(const qwq &x,const qwq &y){
	return x.sum<y.sum;
}
int pos[N];

bool check(int mid){
	int sum=0;
	for(int i=1;i<=n;i++){
		if(a[i].sum<=0){
			int mx=n;
			for(int j=mx;j>=1;j--){
				if(a[i].sum * a[j].sum > mid) break;
				if(i==j || pos[i]==j || pos[j]==i) continue;
				sum++;
			}
		}
		else{
			int mx=1;
			for(int j=mx;j<=n;j++){
				if(a[i].sum * a[j].sum > mid) break;
				if(i==j || pos[i]==j || pos[j]==i) continue;
				sum++;				
			}
		}
		if(sum>=2*m-2*(n-1)) return 1;
	}
//	cout<<sum<<"\n";
	return 0;
}

int ans1[N],ans2[N],tot;
vector<PII> vec;
signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i].sum);
		a[i].pos=i;
	}
	sort(a+1,a+n+1,cmp);

	for(int i=1;i<=n;i++){
		if(a[i].sum<=0) pos[i]=n;
		else pos[i]=1;
	}
	if(pos[1]==1) pos[1]=-1;
	else if(pos[n]==n) pos[n]=-1;
	else if(pos[1]==n && pos[n]==1) pos[1]=-1;
	
	int mx=-INF;
	for(int i=1;i<=n;i++){
		if(pos[i]==-1) continue;
		mx=max(mx,a[i].sum*a[pos[i]].sum);
	}
	
	int l=-INF, r=INF, ans=mx;
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid)){
			ans=mid;
			r=mid-1;
		}
		else l=mid+1;
	}
	
//	cout<<"ANS: "<<ans<<" "<<"\n";
//	check(ans);
//	cout<<"mx: "<<mx<<"\n";
	
	int zans=0;
	for(int i=1;i<=n;i++)
		if(~pos[i]){
			zans+=a[i].sum*a[pos[i]].sum;
			ans1[++tot]=a[i].pos;
			ans2[tot]=a[pos[i]].pos;
		}
	
	int sum=m-n+1;
	for(int i=1;i<=n;i++){
		if(!sum) break;
		if(a[i].sum<=0){
			for(int j=n;j>=1;j--){
				if(!sum) break;
				int nw=a[i].sum*a[j].sum;
				if(nw>ans) break;
				if(i>=j) continue;
				if(pos[i]==j || pos[j]==i) continue;
				else{
					if(nw==ans)
						vec.push_back({i,j});
					else{
						zans+=nw;
						ans1[++tot]=a[i].pos;
						ans2[tot]=a[j].pos;
						sum--;
					}
				}
			}
		}
		else{
			for(int j=1;j<=n;j++){
				if(!sum) break;
				int nw=a[i].sum*a[j].sum;
				if(nw>ans) break;
				if(i>=j) continue;
				if(pos[i]==j || pos[j]==i) continue;
				else{
					if(nw==ans)
						vec.push_back({i,j});
					else{
						zans+=nw;
						ans1[++tot]=a[i].pos;
						ans2[tot]=a[j].pos;
						sum--;
					}
				}
			}
		}
	}	
	
	for(auto i:vec){
		if(!sum) break;
		sum--;
		int l=i.first, r=i.second;
		zans+=a[l].sum * a[r].sum;
		ans1[++tot]=a[l].pos;
		ans2[tot]=a[r].pos;
	}
	
	printf("%lld\n",zans);
	for(int i=1;i<=tot;i++)
		printf("%lld %lld\n",ans1[i],ans2[i]);
	return 0;
}
```

---

## 作者：ykzzldz (赞：4)

#### Part1：$n\le1000$（$40$ 分）

显然，这一部分可以对每两个点之间暴力连边，先跑一遍最小生成树，然后将剩下没选的边从小到达加入直到满足条件。

#### Part2：$m=n-1$（$10$ 分）

这一部分要求我们构建一棵树，所以每个点有且仅有一条边与之相连。此时我们发现对于一个权值为正的点，需将其与权值最小的点相连，对于一个权值为负的点，将其与权值最大的点相连，正确性显然。

上面两个部分的代码在这里贴一下，希望可以帮助大家调试。

[代码](https://www.luogu.com.cn/paste/gpijc7cs)

#### Part3：正解（$100$ 分）

开始讲正解了，首先，我们肯定是先跑一遍 Part2 的做法，求出最小生成树，这之后，我们的选边便没有限制了。由于是从小到大选边，自然想到二分来求出选的最大边的边权，那么现在的难点便变为如何 check。

考虑对于每个点，计算其对答案的贡献（也就是与其他点所连边小于二分的值的点的个数）。对于一个权值为正的点，其与一个更小的数相连肯定是更优的，权值为负的点，其与更大的数相连更优，于是我们想到二分来快速求出每个点的贡献。当然，这里也可以使用双指针将 $O(n\log^2 n)$ 优化到 $O(n\log n)$，不过由于题目没卡，所以我就没写。

当二分出一个答案 mid 后，我们输出方案的时候也需要注意一些细节：先将所有最小生成树上的边和边权小于 mid 的边选上，最后再加上边权等于 mid 的边即可。

总体来说，这题的细节比较多，特别是几个二分的边界需要特别注意一下。最后，特别感谢一下出题人@[是青白呀](https://www.luogu.com.cn/user/359270)~~在我调不出来的时候~~给了一组数据，拜谢。

本来不想贴代码的，但由于不是很好写，就给一下吧。但希望大家可以在看完题解后自己自主将代码写完后在对着题解 debug，不要一上来就看题解的代码。

[代码](https://www.luogu.com.cn/paste/hjllkwn8)

---

## 作者：Link_Cut_Y (赞：4)

赛时没写完，这里提供一句话思路。

首先前三个 sub 默认大家都拿到了。我们考虑原图的最小生成树是什么样子的。如果手搓几组数据，可以发现，在点权全正的时候，所有点都会连向点权最小的那个点。如果有负的点权，那么所有正权点连向负权最小点，所有负权点连向正权最大点。这样构成原图的最小生成树。这一点很容易贪心地得到。

我们按照上述方法建出最小生成树，然后考虑非树边。答案显然具有单调性，我们二分最小生成树中边权的最大值，转化为判定问题。

判定是平凡的。对于每个点，可以二分找到 $\le \dfrac{mid}{a_i}$ 的点数（如果是负权点不等号方向变一下）。你也可以发现，如果点权单调，那么 $\le \dfrac{mid}{a_i}$ 的点数也是单调的，所以也可以双指针。

复杂度视实现为 $O(n \log n)$ 或者 $O(n \log ^ 2 n)$。

---

## 作者：Y2y7m (赞：1)

抽象，打月赛的时候交错代码了，以为做法假了，就扔了打征去了，结果交错代码了。

符合被 UNR 打爆后吃不下午饭但到了下午的时候很饿的我的精神状态。

这题先把所有点分成负点权点集和非负点权点集。

显然连边优先连负的最小的和正的最大的，这样边权最小。我们先建出一颗生成树，这是容易的，只要既有负点权点又有非负点权点，我们就用负点权点中点权最小的和所有非负点权点连边，然后再用非负点权点中点权最大的点连接负点权集中除负点权最小的那个点外的所有点即可，然后跑广搜，先跑负点和非负点之间的连边广搜，在同时跑非负点之间和负点之间的广搜即可。

如果非负点集和负点集中有一个是空的，如果是负点集为空，则选择非负点集中点权最小的点和其余点连边，然后跑广搜。非负点集为空类似。

具体可看实现：

```cpp
#include <bits/stdc++.h>

using namespace std;
#define int long long
#define pii pair<int,int>
#define fi first
#define se second
#define mp make_pair
const int maxn=1e6+10;
int n,m;
pii a[maxn],b[maxn];
int c1,c2;
vector<pii> ans;
int sum;
void print()
{
	for(pii x:ans) cout<<x.fi<<" "<<x.se<<endl;
}
struct node
{
	int i,j,f,w;
	bool operator < (const node &x) const
	{
		return w>x.w;
	}
};
priority_queue<node> q;
void bfs(int rst)
{
	while(!q.empty())
	{
		if(rst==0)
		{
			cout<<sum<<endl;
			print();
			return ;
		}
		node t=q.top();
		q.pop();
		rst--;
		sum+=t.w;
		ans.push_back(mp(a[t.i].se,a[t.j].se));
		if(t.j+1<=c1) q.push({t.i,t.j+1,t.f,a[t.i].fi*a[t.j+1].fi});
		if(t.i+2<=c1&&t.j==t.i+1) q.push({t.i+1,t.j+1,t.f,a[t.i+1].fi*a[t.j+1].fi});
	}
	cout<<sum<<endl;
	print();
}
void sol1()
{
	for(int i=2;i<=n;i++) sum+=a[1].fi*a[i].fi,ans.push_back(mp(a[1].se,a[i].se)); 
	q.push({2,3,0,a[2].fi*a[3].fi});
	bfs(m-(n-1));
}
signed main()
{
	ios::sync_with_stdio(false);
	cin>>n>>m;
	int x;
	for(int i=1;i<=n;i++)
	{
		cin>>x;
		if(x>=0) a[++c1]=mp(x,i);
		else b[++c2]=mp(x,i);
	}
	sort(a+1,a+1+c1,greater<pii>());
	sort(b+1,b+1+c2);
	if(c2==n)
	{
		for(int i=1;i<=n;i++) a[i]=b[n-i+1];
		c1=n;
		sol1();
		return 0;
	}
	if(c1==n)
	{
		reverse(a+1,a+1+n);
		sol1();
		return 0;
	}
	for(int i=1;i<=c1;i++) sum+=b[1].fi*a[i].fi,ans.push_back(mp(b[1].se,a[i].se));
	for(int i=2;i<=c2;i++) sum+=a[1].fi*b[i].fi,ans.push_back(mp(a[1].se,b[i].se));
	int rst=m-(n-1);
	if(rst==0)
	{
		cout<<sum<<endl;
		print();
		return 0;
	}
	q.push({2,2,0,a[2].fi*b[2].fi});
	while(!q.empty())
	{
		if(rst==0)
		{
			cout<<sum<<endl;
			print();
			return 0;
		}
		node t=q.top();
		q.pop();
		if(t.i>c1||t.j>c2) continue;
		rst--;
		sum+=t.w;
		ans.push_back(mp(a[t.i].se,b[t.j].se));
		if(t.j<=c2) q.push({t.i,t.j+1,0,a[t.i].fi*b[t.j+1].fi});
		if(t.j==2&&t.i<c1) q.push({t.i+1,2,0,a[t.i+1].fi*b[2].fi});
	}
	if(rst==0)
	{
		cout<<sum<<endl;
		print();
		return 0;
	}
	reverse(a+1,a+1+c1);
	reverse(b+1,b+1+c2);
	q.push({1,2,0,a[1].fi*a[2].fi});
	q.push({1,2,1,b[1].fi*b[2].fi});
	while(!q.empty())
	{
		if(rst==0)
		{
			cout<<sum<<endl;
			print();
			return 0;
		}
		node t=q.top();
		q.pop();
		if(t.f==0)
		{
			if(t.j>c1) continue;
			sum+=t.w;
			rst--;
			ans.push_back(mp(a[t.i].se,a[t.j].se));
			if(t.j+1<=c1) q.push({t.i,t.j+1,t.f,a[t.i].fi*a[t.j+1].fi});
			if(t.i+2<=c1&&t.j==t.i+1) q.push({t.i+1,t.j+1,t.f,a[t.i+1].fi*a[t.j+1].fi});
		}
		else
		{
			if(t.j>c2) continue;
			sum+=t.w;
			rst--;
			ans.push_back(mp(b[t.i].se,b[t.j].se));
			if(t.j+1<=c2) q.push({t.i,t.j+1,t.f,b[t.i].fi*b[t.j+1].fi});
			if(t.i+2<=c2&&t.j==t.i+1) q.push({t.i+1,t.j+1,t.f,b[t.i+1].fi*b[t.j+1].fi});			
		}
	}
	cout<<sum<<endl;
	print();
	return 0;
}
```

---

## 作者：vanueber (赞：0)

# 题目大意

构造一个边权和最小 $n$ 个点 $m$ 条边的无向连通图，其中任意 $u,v$ 间存在一条边权为 $a_u\times a_v$ 的边。

# 题目分析

先考虑满足构造出的图的连通性，可以按照构造图的一般方式：先构造一棵树，再任意添加 $m-n+1$ 条边。

对于此题，为满足权值和最小，先构造出一棵**最小生成树**，再添加 $m-n+1$ 条权值最小且不在最小生成树上的边就是最终答案。
# 构造最小生成树

现将所有点按点权排序，为每个节点选择一个连边的对象，由于题目中有负权边，可以分情况讨论。

1. 都是负数，都连向最大的点。
2. 都是正数，都连向最小的点。
3. 有正有负，正的连负数最小，负的连正数最大。

特别地，对于 $0$ 归到连最大的一类
，防止出现连成自环的情况。

# 多路归并优先队列

保证了最终图的连通性后，就要取出剩下的 $m-n+1$ 条边了，这种总方案很多但对于一个固定的 $i$ 其决策满足单调性的问题可以使用多路归并优先队列解决。

具体地，我们使用一个优先队列维护决策集合，一开始，现将对于每个点的最优决策加入堆中。

![](https://cdn.luogu.com.cn/upload/image_hosting/1nam42ho.png)

如上图就代表了对于每个点的单调性决策集合，我们取出边权最小的决策，如果这条边没有被使用过就更新答案，并且将指针向后移动一个，将对于该点的次优决策加入优先队列。

![](https://cdn.luogu.com.cn/upload/image_hosting/kg0xrz1g.png)

就这样重复 $m-n+1$ 次就构造出了题目要求的图，注意此时仍要分正负性进行讨论。

# Code


```cpp
#include <bits/stdc++.h>
#define int long long
#define umap unordered_map
#define vint vector<int>
#define ll long long
#define pii pair<int,int>
#define all(x) x.begin(),x.end()
#define ull unsigned long long
#define uint unsigned int
#define rg register
#define il inline
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define sqr(x) ((x)*(x))
using namespace std;
const int INF=0x3f3f3f3f;
inline int read()
{
    int w=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        w=(w<<1)+(w<<3)+(ch^48);
        ch=getchar();
    }
    return w*f;
}
inline void write(int x)
{
    if(x<0)
    {
        putchar('-');
        x=-x;
    }
    if(x>9) write(x/10);
    putchar(x%10+'0');
}

const int N=1e6+10,M=1e6+10;
int n,m;
struct vertex
{
    int a,id;
    bool operator <(const vertex &b)const
    {
        return a<b.a;
    }
}ver[N];
int res=0;
unordered_map<int,int> book;
int to(pii a)
{
    return a.first|(a.second<<32);
}
pii my_mp(int x,int y)
{
    return make_pair(min(x,y),max(x,y));
}
vint G[N];
void print()
{
    for(int u=1;u<=n;++u)
    {
        for(int v:G[u]) printf("%lld %lld\n",u,v);
    }
}
struct node
{
    vertex now;//现在的信息
    int id,p,len;//id u的标号 p v的标号 len 长度
    node(vertex now={0,0},int id=0,int p=0,int len=INF):now(now),id(id),p(p),len(len){}
    bool operator <(const node &b)const
    {
        return len>b.len;
    }
};
priority_queue<node> Q;
signed main()
{
    #ifndef ONLINE_JUDGE
    //freopen("in.txt","r",stdin);
    #endif
    cin>>n>>m;
    for(int i=1;i<=n;++i) ver[i].a=read(),ver[i].id=i;
    sort(ver+1,ver+n+1);
    if(ver[n].a<0)
    {
        for(int i=1;i<n;++i)
        {
            res+=ver[i].a*ver[n].a;
            G[ver[i].id].push_back(ver[n].id);
            book[to(my_mp(i,n))]=1;
        }
    }
    else if(ver[1].a>0)
    {
        for(int i=2;i<=n;++i)
        {
            res+=ver[i].a*ver[1].a;
            G[ver[i].id].push_back(ver[1].id);
            book[to(my_mp(1,i))];
        } 
    }
    else
    {
        // cout<<1<<endl;
        for(int i=1;i<n;++i)
        {
            // cout<<ver[i].a;
            if(ver[i].a<0)
            {
                // cout<<" "<<ver[n].a<<endl;
                res+=ver[i].a*ver[n].a;
                G[ver[i].id].push_back(ver[n].id);
                book[to(my_mp(i,n))]=1;
            }
            else if(ver[i].a>0)
            {
                res+=ver[i].a*ver[1].a;
                G[ver[i].id].push_back(ver[1].id);
                book[to(my_mp(1,i))]=1;
            }
            else
            {
                res+=ver[i].a*ver[n].a;
                G[ver[i].id].push_back(ver[n].id);
                book[to(my_mp(i,n))]=1;
            }
        }
    }
    if(m==n-1)
    {
        cout<<res<<endl;
        print();
        return 0;
    }
    int need=m-(n-1);
    for(int i=1;i<=n;++i)
    {
        if(ver[i].a>0)
        {
            Q.push(node(ver[i],i,1,ver[i].a*ver[1].a));
        }
        else if(ver[i].a<0)
        {
            Q.push(node(ver[i],i,n,ver[i].a*ver[n].a));
        }
        else
        {
            Q.push(node(ver[i],i,n,ver[i].a*ver[n].a));
        }
    }
    while(need)
    {
        auto temp=Q.top();
        Q.pop();
        int u=temp.id,v=temp.p,w=temp.len;
        // if(u==v) continue;
        if(book.find(to(my_mp(u,v)))!=book.end()||u==v)
        {
            if(temp.now.a>0)
            {
                ++v;
                if(v==n+1) continue;
                Q.push(node(temp.now,u,v,temp.now.a*ver[v].a));
            }
            else if(temp.now.a<0)
            {
                --v;
                if(v==0) continue;
                Q.push(node(temp.now,u,v,temp.now.a*ver[v].a));
            }
            else
            {
                --v;
                if(v==0) continue;
                Q.push(node(temp.now,u,v,temp.now.a*ver[v].a));
            }
            continue;
        }
        --need;
        res+=w;
        G[ver[u].id].push_back(ver[v].id);
        book[to(my_mp(u,v))]=1;
        if(temp.now.a>0)
        {
            ++v;
            if(v==n+1) continue;
            Q.push(node(temp.now,u,v,temp.now.a*ver[v].a));
        }
        else if(temp.now.a<0)
        {
            --v;
            if(v==0) continue;
            Q.push(node(temp.now,u,v,temp.now.a*ver[v].a));
        }
        else
        {
            --v;
            if(v==0) continue;
            Q.push(node(temp.now,u,v,temp.now.a*ver[v].a));
        }
    }
    cout<<res<<endl;
    print();
    #ifndef ONLINE_JUDGE
    fprintf(stderr,"%f\n",1.0*clock()/CLOCKS_PER_SEC);
    #endif
    return 0;
}
```

> $\text{Trick}$：判断一条边有没有被用过可以不用 `map<pair<int,int>,bool>`，可以将 `i|(j<<32)` 压入哈希表中做到 $\Theta(1)$ 时间的判断。

~~不会只有我不知道这个 trick 吧。~~

---

## 作者：qsn123 (赞：0)

## p10768 落月摇情


[题目链接](https://www.luogu.com.cn/problem/P10768)

好题，~~如果不卡常就更好了~~。

NOIP 之前写题解，RP++，也祝大家都能 RP++。

很自然地，我们将本题分为两（但实际上是四）部分解决：

#### STEP 1：求最小生成树

---

首先，题中规定最后的无向图要联通且无重边无自环，所以要尽可能先通过连接负权边来构建初始的最小生成树来保证全图联通。

注意到边权只由其端点的点权决定，故对于一个正数点权的点，将其与当前最小点权的点联通一定更优，而负权点则应连接当前最大的点。此处要注意不要出现重边，即把最小点和最大点连接两次的情况，以及排序时维护好每个点初始的下标。

---

#### STEP 2：连接非树边

---

此时应剩下 $m-n+1$ 条非树边没有连接。由于全图已经联通，我们不需要再考虑连通性的问题，因此此时尽可能连接边权更小的边。

对于非树边，我们仍然应该先从负权边连起，即应先尽可能将正权点与负权点联通。此时可以进行特判，如果连完所有负权边仍不能满足题意则直接联通所有负权边，反之则需要对决策进行排序。

首先，易知对于一个正权点 $A$，与其连接的负权点 $B$ 越小，则形成的边的边权一定更小。而对于一个负权点 $A$，则与其连接的正权点 $B$ 越大越好。因此，我们对正数降序排序，对负数升序排序。    

假设我们当前选择了一条边 $(A_i,B_j)$，若其为当前的最小边，则确保比其大的边中，最小的就是  $(A_{i+1},B_{j})$ 和 $(A_i,b_{j+1})$。

因此，我们将每一个新扩展出的可能的决策 $(A_i,B_j)$ 都插入一个堆中，每次选取最小边权的边扩展即可，初始边则为次大正权点与次小负权点之间产生。

最后，若所有负权边均已被选择而仍不够 $m$ 条边，则要从正权边中尽可能选小者，此时需要将正权点中尽可能小的互相连接，负权点中尽可能大的互相连接，此时将正权点和负权点中的决策都放入同一个堆中一起扩展即可。注意一个细节：当出现了一个决策为 $(A_i,A_{i+1})$ 时，特判，以防止将形如 $(A_i,A_{i+1})$ 的错误决策放入堆中，影响正确答案。

此处要注意一个很重要的点：用这种方式扩展边，可能会导致一条边被扩展多次。所以需要使用 map 等方式存储下已被扩展的边，以防止扩展到重边。

---

#### STEP3：卡常

---

你说得对，但是这种做法的常数还是蛮大的，所以你需要卡常才能 AC，否则 80pts。

以下是本人用到的一些卡常方法：

1. 使用快读和快写，尤其是快写，在本题需要输出方案的情况下对于速度的提升极大。

2. 使用 unordered_map 替代 map，可以减小一些常数。

3. 函数开 inline。

4. 第一步的树边无需判重，也不用插入 map，因为它们不可能在后续的扫描中被扩展到。同理，如果你连接了所有的负权边，那么它们也不用判重或插入 map。

---

#### STEP4：代码部分

---

本人马蜂并不怎么良好，见谅。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000050;
struct nb{
	long long num;
	int id;
};
inline bool cmq(nb x,nb y)
{
	if(x.num==y.num)return x.id<y.id;
	return x.num<y.num;
}
nb a[N]={0};
struct qp{
	long long num;
	int i,j;
	int op;
};
inline bool operator <(const qp &x,const qp &y)
{
	return x.num>y.num;
}
priority_queue<qp>q;
vector<nb>s[10];
int ans[N][2]={0};
unordered_map<unsigned long long,bool>mp;
inline long long read(){
	long long x=0,f=1;
	char ch=getchar_unlocked();
	while(!isdigit(ch)){
		if(ch=='-') 
			f=-1;
		ch=getchar_unlocked();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar_unlocked();
	}
	return x*f;
}
void write(long long x) 
{
	if(x<0) 
	{
		putchar('-');
		x=-x;
	}
	if(x>=10)
		write(x/10);
	putchar(x%10+'0');
}
int main()
{
	long long n,m,tt=0;
	long long cnt=0;
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	{
		a[i].num=read();
		a[i].id=i;
	}
	if(n==1)
	{
		cout<<0;
		return 0;
	}
	sort(a+1,a+n+1,cmq);
	int mn=a[1].id,mx=a[n].id;
	for(int i=2;i<n;i++)
	{
		tt++;
		ans[tt][1]=a[i].id;
		if(a[i].num>=0)
		{
			cnt+=a[i].num*a[1].num;
			ans[tt][2]=mn;
			s[1].push_back(a[i]);
		}
		else
		{
			cnt+=a[i].num*a[n].num;
			ans[tt][2]=mx;
			s[2].push_back(a[i]);
		}
	}
	tt++;
	ans[tt][1]=a[1].id;
	ans[tt][2]=a[n].id;
	cnt+=a[1].num*a[n].num;
	reverse(s[1].begin(),s[1].end());
	if(s[1].size()&&s[2].size())
	{
		qp x;
		x.i=x.j=0;
		x.num=s[1][0].num*s[2][0].num;
		x.op=0;
		q.push(x);
		while(q.size()&&tt<m)
		{
			x=q.top();
			q.pop();
			if(mp.find(((unsigned long long)s[1][x.i].id<<32)|s[2][x.j].id)!=mp.end())continue;
			qp y=x,z=x;
			if(y.i+1<s[1].size())
			{
				y.i++;
				y.num=s[1][y.i].num*s[2][y.j].num;
				q.push(y);
			}
			if(z.j+1<s[2].size())
			{
				z.j++;
				z.num=s[1][z.i].num*s[2][z.j].num;
				q.push(z);
			}
			tt++;
			ans[tt][1]=s[1][x.i].id;
			ans[tt][2]=s[2][x.j].id;
			cnt+=s[1][x.i].num*s[2][x.j].num;
			mp[((unsigned long long)s[1][x.i].id<<32)|s[2][x.j].id]=1;
			mp[((unsigned long long)s[2][x.j].id<<32)|s[1][x.i].id]=1;
		}
	}
	reverse(s[1].begin(),s[1].end());
	reverse(s[2].begin(),s[2].end());
	if(a[1].num<0)s[2].push_back(a[1]);
	if(a[n].num>=0)s[1].push_back(a[n]);
	qp x;
	x.i=0,x.j=1;
	if(s[1].size()>1)
	{
		x.num=s[1][0].num*s[1][1].num;
		x.op=1;
		q.push(x);
	}
	if(s[2].size()>1)
	{
		x.num=s[2][0].num*s[2][1].num;
		x.op=2;
		q.push(x);
	}
	while(q.size()&&tt<m)
	{
		x=q.top();
		q.pop();
		if(mp.find(((unsigned long long)s[x.op][x.i].id<<32)|s[x.op][x.j].id)!=mp.end())continue;
		qp y=x,z=x;
		if(y.i+1<s[y.op].size()&&y.i+1<y.j)
		{
			y.i++;
			y.num=s[y.op][y.i].num*s[y.op][y.j].num;
			q.push(y);
		}
		if(z.j+1<s[z.op].size())
		{
			z.j++;
			z.num=s[z.op][z.i].num*s[z.op][z.j].num;
			q.push(z);
		}
		tt++;
		ans[tt][1]=s[x.op][x.i].id;
		ans[tt][2]=s[x.op][x.j].id;
		cnt+=s[x.op][x.i].num*s[x.op][x.j].num;
		mp[((unsigned long long)s[x.op][x.i].id<<32)|s[x.op][x.j].id]=1;
		mp[((unsigned long long)s[x.op][x.j].id<<32)|s[x.op][x.i].id]=1;
	}
	write(cnt);
	printf("\n");
	for(int i=1;i<=tt;i++)
	{
		write(ans[i][1]);
		printf(" ");
		write(ans[i][2]);
		printf("\n");
	}
	return 0;
}
```

[提交记录](https://www.luogu.com.cn/record/183982990)

**祝大家 NOIP RP++！！！**

---


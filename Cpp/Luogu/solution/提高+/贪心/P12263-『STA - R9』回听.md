# 『STA - R9』回听

## 题目描述

给定一个长为 $n$ 的序列 $a$，定义回听操作如下：

> 定义一次回听操作为，任意选择一个 $x\in [1,n]$，然后进行任意次（可以是 $0$ 次）如下操作：
>
> - $a_x \leftarrow \max\{a_x-1,0\}$，选择一个 $j\in[1,x)$，交换 $a_x,a_j$ 并令 $x \leftarrow j$。
>
> 定义 $b_i$ 为进行一次回听后 $a_i$ 的最小值。
>
> 注意此处回听操作不会实际影响序列 $a$ 的值。可以认为操作之后 $a$ 会恢复到操作之前的状态。

序列会进行 $m$ 次修改操作，每次给定 $l,r,v$，使 $a_l$ 到 $a_r$ 中的每个数增加 $v$。每次修改后你需要输出进行一次回听操作后本质不同的 $b_i$ 共有多少个（$b_i$ 与 $b_j$ 本质不同当且仅当 $b_i \ne b_j$）。

**注意：修改操作间相互影响，回听操作间相互独立。**

## 说明/提示



**【操作解释】**

对于序列 $\{3,8,2,4,7\}$，对它进行回听操作的过程如下：

若选择 $x=5$，进行 $3$ 次操作，选择的 $j$ 分别为 $4,2,1$，那么整个序列会这样变化：
- $\{3,8,2,4,7\}$
- $\{3,8,2,6,4\}$
- $\{3,5,2,8,4\}$
- $\{4,3,2,8,4\}$

**【样例 $1$ 解释】**

修改操作后序列 $a$ 变为 $\{  2,3,3\}$。

当 $i=1$ 时，选择 $x=3$，进行 $2$ 次操作，$j$ 分别选择 $2,1$，得到 $b_i=a_3-1-1=1$。

当 $i=2$ 时，选择 $x=2$，进行 $1$ 次操作，选择 $j =1$，得到 $b_i=a_1=2$。

当 $i=3$ 时，选择 $x=3$，进行 $1$ 次操作，选择 $j =1$，得到 $b_i=a_1=2$。

综上，序列 $b$ 为 $\{  1,2,2\}$，故答案为 $2$。

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 0（10 pts）：$1\le n,m \le 10$。
- Subtask 1（15 pts）：$1\le n,m \le 10^5$，$l\ge 2$，$a_1=1$，$\forall i\in[2,n],\,a_i>i$。
- Subtask 2（15 pts）：$1\le n,m \le 1000$。
- Subtask 3（30 pts）：$1\le n,m \le 10^5$。
- Subtask 4（30 pts）：无特殊限制。

对于所有测试数据，保证 $1\le n,m\le 5\times10^5$，$1\le a_i,v\le 10^6$，$1\le l\le r\le n$。

**本题输入输出量较大，建议使用较快的 IO 方式。**

## 样例 #1

### 输入

```
3 1
2 2 2
2 3 1```

### 输出

```
2```

## 样例 #2

### 输入

```
4 3
6 5 6 6
3 3 1
1 3 2
4 4 5```

### 输出

```
3
4
2
```

# 题解

## 作者：chenzefan (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P12263)

## 前言
本人在比赛时没有想到这题要用线段树，连暴力都没打，就宣告退出了 ~~（主要是比较懒）~~，现在细细想来，才发现我有多愚蠢。
## 本题涉及知识
**线段树模板**，没什么多说的，不懂的点[这里](https://www.cnblogs.com/silentEAG/p/10808978.html)。
## 思路分析
**如果已经明白的大佬，可以自行跳过。**

看了题目后，发现 $b_i$ 随着 $i$ 的增，始终单调不降，所以我们只需要知道 $b_i$ 的最小值 $\min $ 是多少即可解决问题。

要让 $x$ 的位置的值尽可能小，我们就要用两个线段树分别维护 $a_x$ 和 $a_x-x+1$，于是就有了下面的代码。

线段树做法，时间复杂度 $ O(q \times \log n)$。

**注意：本题要开 `long long`**。

## 代码部分（内含注释）
~~蒟蒻马蜂丑陋，大佬勿喷。~~
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
//以下的 p<<1 是 p*2 ，表示左孩子； p<<1|1 是 p*2+1 ，表示右孩子； 
const int N=5e5+5;//题目给的空间
int n,q,a[N];
struct node{
	int l,r,lazy,minn; 
}tree1[4*N],tree2[4*N];//正常开*4的空间~ 
void pushdown1(int p){//处理 tree1 
	if(tree1[p].lazy==0) return ;
	tree1[p<<1].lazy+=tree1[p].lazy;
	tree1[p<<1|1].lazy+=tree1[p].lazy;
	tree1[p<<1].minn+=tree1[p].lazy;
	tree1[p<<1|1].minn+=tree1[p].lazy;
	tree1[p].lazy=0;
} 
void pushdown2(int p){//处理 tree2
	if(tree2[p].lazy==0) return ;
	tree2[p<<1].lazy+=tree2[p].lazy;
	tree2[p<<1|1].lazy+=tree2[p].lazy;
	tree2[p<<1].minn+=tree2[p].lazy;
	tree2[p<<1|1].minn+=tree2[p].lazy;
	tree2[p].lazy=0;
} 
void build1(int p,int l,int r){//处理 tree1 
	tree1[p]={l,r,0,a[l]};//初始化
	if(l==r) return ;
	int mid=l+r>>1;
	//二分建树 
	build1(p<<1,l,mid);build1(p<<1|1,mid+1,r);
	tree1[p].minn=min(tree1[p<<1].minn,tree1[p<<1|1].minn);//更新 p 节点的信息 minn 
} 
void build2(int p,int l,int r){//处理 tree2
	tree2[p]={l,r,0,a[l]-l+1};//初始化 
	if(l==r) return ; 
	int mid=l+r>>1;
	//二分建树
	build2(p<<1,l,mid);build2(p<<1|1,mid+1,r);
	tree2[p].minn=min(tree2[p<<1].minn,tree2[p<<1|1].minn);//更新 p 节点的信息 minn 
} 
void update1(int p,int x,int y,int k){//处理 tree1 
	int l=tree1[p].l;
	int r=tree1[p].r;
	if(x<=l&&r<=y){
		tree1[p].lazy+=k;
		tree1[p].minn+=k;
		return ;
	}pushdown1(p);//处理懒标记 
	int mid=l+r>>1;
	if(x<=mid) update1(p<<1,x,y,k);
	if(y>mid) update1(p<<1|1,x,y,k);
	tree1[p].minn=min(tree1[p<<1].minn,tree1[p<<1|1].minn);//更新 p 节点的信息 minn 
}
void update2(int p,int x,int y,int k){//处理 tree2 
	int l=tree2[p].l;
	int r=tree2[p].r;
	if(x<=l&&r<=y){
		tree2[p].lazy+=k;
		tree2[p].minn+=k;
		return ;
	}pushdown2(p);//处理懒标记 
	int mid=l+r>>1;
	if(x<=mid) update2(p<<1,x,y,k);
	if(y>mid) update2(p<<1|1,x,y,k);
	tree2[p].minn=min(tree2[p<<1].minn,tree2[p<<1|1].minn);//更新 p 节点的信息 minn 
}
signed main(){
	scanf("%lld%lld",&n,&q);
	for(int i=1;i<=n;i++) scanf("%lld",a+i);
	//经典建树函数
	build1(1,1,n);build2(1,1,n);
	while(q--){
		int l,r,v;
		scanf("%lld%lld%lld",&l,&r,&v);
		//经典更新函数 
		update1(1,l,r,v);update2(1,l,r,v);
		printf("%lld\n",tree1[1].minn-max(tree2[1].minn,0ll)+1);
	}
	return 0;
}
```

## 后附
不要抄袭代码！！不要直接复制！！

先清晰思路，再进行借鉴！！

**若有笔误，请指出，感谢**。

---

## 作者：Lysea (赞：6)

## Subtask 0&2

我们先考虑选每个位置为 $x$ 时 $a_i$ 的最小值：

- 若 $x\le i$，则最小值为 $\min\{a_x,a_i\}$（直接交换 $a_x$ 与 $a_i$）。

- 若 $x>i$，则最小值为 $\min\{\max\{a_x-x+i,0\},a_i\}$（根据贪心，每次只跟前面一个数交换，一共换了 $x-i$ 次）。

由此得到：

$$ b _ i =\max\{ \min \{ \min _ {j = 1} ^ i \{ a _ j \}, i + \min _ {j = i + 1} ^ n \{ a _ j - j \} \} ,0\}$$

先不考虑 $0$ 的情况，令 $ d _ i =\min \{ \min \limits_ {j = 1} ^ i \{ a _ j \}, i + \min \limits_ {j = i + 1} ^ n \{ a _ j - j \} \} $。

使用线段树求出每一个 $d_i$，再进行去重即可得到答案，时间复杂度 $O(Tn\log n)$。

[Code.](https://www.luogu.com.cn/paste/pv7ac20s)

## Subtask 1

容易发现此性质下所有 $b_i$ 相同，直接输出 $1$ 即可。

## Subtask 3

观察这个式子，可以发现随着 $i$ 变大，$\min \limits_ {j = 1} ^ i \{ a _ j \}$ 是单调不增的，而 $i + \min \limits_ {j = i + 1} ^ n \{ a _ j - j \}$ 是单调不减的，所以 $d_i$ 是个开口向下的单峰函数，类似于[冰火战士](https://www.luogu.com.cn/problem/P6619)，这启发我们去进一步研究它的单调性。

定义 $s_i=\min \limits_ {j = 1} ^ i \{ a _ j \}$，$c_i=\min\limits _ {j = i } ^ n \{ a _ j - j \}$，显然 $d_i$ 要么为 $s_i$，要么为 $i+c_{i+1}$，就此进行讨论：

$(I)$：如果 $d_i = s_i$，那么必定有 $d_{i+1}= \min\{s_i,a_{i+1}\}$。

假设 $d_{i+1}=a_{i+1}$，那么需要满足以下两个条件：

- $a_{i+1} \le s_i$

- $a_{i+1} -1 \ge d_i=s_i$

整理得：

$s_i+1 \le a_{i+1} \le s_i$

所以 $d_{i+1}=a_{i+1}$ 不成立，所以 $d_{i+1}=s_i=d_i$。

由此我们得出结论，若 $d_i = s_i$，则 $d_i=d_{i+1}$。

因此 $d_i$ 其实是个单调不减的函数，之前提到所谓单调不增的部分其实本质是保持在一个值不变。

$(II)$：如果 $d_i = i+c_{i+1} \neq s_i$，那么 $d_{i+1}=\min\{s_{i+1},i+1+c_{i+2}\}$。

若 $d_{i+1}=i+1+c_{i+2}$，则由 $i+1+c_{i+2}>i+c_{i+1}$ 可推出 $d_{i+1}>d_i$，也就是 $d_i \ne d_{i+1}$。

否则 $d_{i+1}=s_{i+1}$，也就等价于 $i$ 为整个函数的转折点。容易发现已经没必要讨论了，因为无论此时 $d_i$ 是否等于 $d_{i+1}$，我们都可以明确这个函数的特征，那就是：

**存在一个 $i\in[1,n)$，使得 $d_1,d_2,...,d_i$ 互不相同，同时使 $d_{i+1},d_{i+2},...,d_n$ 两两相同。**

此时我们再考虑 $0$ 的情况，那么 $d$ 序列的负数前缀会全部变为 $0$。

因此，我们只需要二分找到第一个 $d_i\le 0$ 的位置 $l$，再找到第一个 $d_i = d_{i+1}$ 的位置 $r$，$r-l+1$ 即为最后答案。

二分时单次算 $d_i$ 使用线段树分段维护最小值即可，时间复杂度 $O(T\log^2n)$。

[Code.](https://www.luogu.com.cn/paste/l9ppxg76)

## Subtask 4

考虑线段树上二分优化至单 $\log$。

令节点 $p$ 对应的区间为 $[l,r]$，我们需要维护以下几个值：

- $le_p$ 表示 $a_l$。

- $mi_p$ 表示 $\min\limits_{i=l}^r\{a_i\}$。

- $mn_p$ 表示 $\min\limits_{i=l}^r\{a_i-i\}$。

- $ms_p$ 表示 $\min\limits_{i=l+1}^r\{a_i-i\}$。

令 $ls$，$rs$ 表示 $p$ 节点的左右区间，$mid$ 表示左区间右端点，$L$ 表示 $\min\limits_{i=1}^{l-1}\{a_i\}$，$R$ 表示 $\min\limits_{i=r+1}^{n}\{a_i-i\}$。

若 $\min\{\min\{ L,mi_{ls} \} ,mid + \min\{ R,mn_{rs} \}\}\ge0$，则说明最靠右的 $d_i<0$ 的位置位于左区间中，反之位于右区间。

若 $\min\{\min\{ L,mi_{ls} \} ,mid + \min\{ R,mn_{rs} \}\}=\min\{\min\{ L,mi_{ls},le_{rs} \} ,mid + 1+\min\{ R,ms_{rs} \}\}$，则说明最靠右的 $d_i=d_{i+1}$ 的位置位于左区间中，反之位于右区间。

其中 $L$ 和 $R$ 都是可以做到动态维护的，这样就可以实现线段树上二分了，时间复杂度 $O(T\log n)$。

[Code.](https://www.luogu.com.cn/paste/u880cv0h)

---

## 作者：MPLN (赞：5)

upd 4/21：修改笔误（$a_j$ 写成 $a_i$ 了），感谢指正。

upd 4/22：补充一些证明。

---



实际上的赛中最易题。

本题不难，可以帮助像我这样的萌新加深对线段树写法的记忆。

## 思路

贪心地，要 $b_i$ 尽可能小。首先显然所有 $a_j$ 都可以通过某种方式换到位置 $i$。若右边的 $a_j$ 过来最好一格一格挪动来实现尽可能多的 -1，而若左边的 $a_j$ 过来只能直接通过交换一次换过来，所以：

$$
b_i=\max(0,\min(\min_{1\le j\le i}a_j,\min_{i<j\le n}(a_j-j+i)))
$$

观察式子，容易得到随 $i$ 增大，$b_i$ 单调不减。

此时似乎仍然难以下手。但是有一条关键性质：$b_{i+1}-b_i\le 1$，换句话说，$i$ 每增大 1 时 $b_i$ 只可能增大 0 或 1。为了保证严谨性，接下来我会进行简单的证明：

进行对比：

$$
b_i=\max(0,\min(\min_{1\le j\le i}a_j,a_{i+1}-1,\min_{i+1<j\le n}(a_j-j+i)))
$$

$$
b_{i+1}=\max(0,\min(\min_{1\le j\le i}a_j,a_{i+1},\min_{i+1<j\le n}(a_j-j+i+1)))
$$

对于外层 $\min$ 中的三项，第一项前后不变，第二项增加 1，第三项内比较的所有项增加 1。因此，增量最多为1。

所以题目所求的 $b_i$ 不同数量就是 $b_n-b_1+1$。

对于 $b_1$：

$$
b_1=\min_{1\le j\le n}(a_j-j+1)
$$

对于 $b_n$：

$$
b_n=\min_{1\le j\le n}a_j
$$

两个支持区间增减的线段树维护即可。

## Code

时间复杂度 $O(n\operatorname{log}n+m\operatorname{log}n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, a[500010];
struct node { 
    int l, r;
    long long mn, laz; 
}t[500010 << 2][2];
void pushup(int p, int z) {
    t[p][z].mn = min(t[p * 2][z].mn, t[p * 2 + 1][z].mn);
}
void pushdown(int p, int z) {
    t[p * 2][z].laz += t[p][z].laz;
    t[p * 2 + 1][z].laz += t[p][z].laz;
    t[p * 2][z].mn += t[p][z].laz;
    t[p * 2 + 1][z].mn += t[p][z].laz;
    t[p][z].laz = 0;
}
void build(int p, int l, int r, int z) {
    t[p][z].l = l, t[p][z].r = r, t[p][z].laz = 0;
    if (l == r) {
        if (!z) t[p][z].mn = a[l];
        else t[p][z].mn = a[l] - l + 1;
        return;
    }
    int mid = l + r >> 1;
    build(p * 2, l, mid, z);
    build(p * 2 + 1, mid + 1, r, z);
    pushup(p, z);
}
void add(int p, int l, int r, int k, int z) {
    int pl = t[p][z].l, pr = t[p][z].r;
    if (l <= pl && pr <= r) {
        t[p][z].laz += k, t[p][z].mn += k;
        return;
    }
    pushdown(p, z);
    int mid = pl + pr >> 1;
    if (l <= mid) add(p * 2, l, r, k, z);
    if (r > mid) add(p * 2 + 1, l, r, k, z);
    pushup(p, z);
}
int main() {
    scanf("%d%d", & n, & m);
    for (int i = 1; i <= n; i++) 
        scanf("%d", & a[i]);
    build(1, 1, n, 0);
    build(1, 1, n, 1);
    while (m--) {
        int x, y, z;
        scanf("%d%d%d", & x, & y, & z);
        add(1, x, y, z, 0);
        add(1, x, y, z, 1);
        long long b1 = max(0LL, t[1][1].mn);
        long long bn = max(0LL, t[1][0].mn);
        printf("%lld\n", bn - b1 + 1);
    }
    return 0;
}
```

---

## 作者：ykzzldz (赞：2)

首先只有最小值能对答案产生贡献，考虑能有多少个不同的最小值。我们发现序列 $b$ 一定是一段区间，而 $b$ 的最大值即为原序列的最小值，我们只需要求出 $b$ 最小能是多少即可。

我们考虑让 $x$ 位置的数最小，那么我们一定会将其对每个位置都进行操作，将其变为 $a_x-x+1$，于是我们只需要使用线段树维护这个东西即可。答案即为 $\min \{a_i\}-\min \{a_j-j+1\}+1$，代码十分好写。

---

## 作者：qwqerty (赞：1)

# 解题思路
一次回听操作有两种选择方式：
- 选择一个在 $i$ 左边的 $j$，然后操作一次。这个操作的耗费是 $a_j$ 的。
- 选择一个在 $i$ 右边的 $j$，然后从右往左依次操作 $x-i$ 次。这个操作的耗费是 $a_j-(j-i)$ 的。

所以 $b_i=\min\{\min\limits_{1\le j\le i}\{a_j\}\min\limits_{i < j\le n}\{a_j-(j-i)\}\}$。  
可以把这个 $i$ 视作一个断点，从 $b_i$ 到 $b_{i+1}$ 就相当于把这个断点向右移动了一位。  
右边这一块是加了 $1$ 的，再来看左边这一块。对于 $1\le j\le n$ 的部分是不变的。重点来看这个 $a_{i+1}$，它从右边移动到了左边，从 $a_{i+1}-1$ 变成了 $a_{i+1}$，也增加了 $1$。  
所以从 $b_i$ 至 $b_{i+1}$ 要么不变，要么增加 $1$。所以最终的答案为 $b_n-b_1+1=\min\limits_{1\le i\le n}\{a_i\}-\min\limits_{1\le i\le n}\{a_i-i-1\}+1$。
# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 5e5;
int n, q;
int a[N + 5], tree1[(N + 5) * 4], tree2[(N + 5) * 4], lzytag1[(N + 5) * 4], lzytag2[(N + 5) * 4];
int ls(int x) {
	return x << 1;
}
int rs(int x) {
	return x << 1 | 1;
}
void pushup1(int x) {
	tree1[x] = min(tree1[ls(x)], tree1[rs(x)]);
}
void pushup2(int x) {
	tree2[x] = min(tree2[ls(x)], tree2[rs(x)]);
}
void build(int x, int xl, int xr) {
	if (xl == xr) {
		tree1[x] = a[xl], tree2[x] = a[xl] - xl + 1;
		return;
	}
	int mid = (xl + xr) / 2;
	build(ls(x), xl, mid);
	build(rs(x), mid + 1, xr);
	pushup1(x);
	pushup2(x);
}
void addtag1(int x, int xl, int xr, int val) {
	lzytag1[x] += val;
	tree1[x] += val;
}
void addtag2(int x, int xl, int xr, int val) {
	lzytag2[x] += val;
	tree2[x] += val;
}
void pushdown1(int x, int xl, int xr) {
	int mid = (xl + xr) / 2;
	addtag1(ls(x), xl, mid, lzytag1[x]);
	addtag1(rs(x), mid + 1, xr, lzytag1[x]);
	lzytag1[x] = 0;
}
void pushdown2(int x, int xl, int xr) {
	int mid = (xl + xr) / 2;
	addtag2(ls(x), xl, mid, lzytag2[x]);
	addtag2(rs(x), mid + 1, xr, lzytag2[x]);
	lzytag2[x] = 0;
}
void update1(int l, int r, int x, int xl, int xr, int val) {
	if (l <= xl && xr <= r) {
		addtag1(x, xl, xr, val);
		return ;
	}
	pushdown1(x, xl, xr);
	int mid = (xl + xr) / 2;
	if (l <= mid) update1(l, r, ls(x), xl, mid, val);
	if (r > mid) update1(l, r, rs(x), mid + 1, xr, val);
	pushup1(x);
}
void update2(int l, int r, int x, int xl, int xr, int val) {
	if (l <= xl && xr <= r) {
		addtag2(x, xl, xr, val);
		return ;
	}
	pushdown2(x, xl, xr);
	int mid = (xl + xr) / 2;
	if (l <= mid) update2(l, r, ls(x), xl, mid, val);
	if (r > mid) update2(l, r, rs(x), mid + 1, xr, val);
	pushup2(x);
}
signed main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin >> n >> q;
	for (int i = 1; i <= n; i++) cin >> a[i];
	build(1, 1, n);
	while (q--) {
		int l, r, v;
		cin >> l >> r >> v;
		update1(l, r, 1, 1, n, v);
		update2(l, r, 1, 1, n, v);
		cout << tree1[1] - max(tree2[1], 0ll) + 1 << "\n";
	}
	return 0;
}
```

---

## 作者：XZhuRen (赞：1)

线段树模板，发现单点答案 $b_i$ 即 $\min(\min_{j\le i}\{a_j\},\min_{j>i}\{\max(a_j-j+i,0)\})$。

一眼值域连续，转化求最值。

最大值为 $b_n$，最小值为 $b_1$，直接问 $b_n=\min_{j\in [1,n]}\{a_j\},b_1=\max(0,\max_{j\in [1,n]}\{a_j-1\})$，$b_n-b_1+1$ 即为答案。

鲜花：缺个括号没发现交了两次，题解审核辛苦了。

---

## 作者：OrinLoong (赞：0)

## LGP12263 [STAOI R9] 回听 学习笔记
[Luogu Link](https://www.luogu.com.cn/problem/P12263)

### 题意简述
给定一个长为 $n$ 的数组 $A$。

定义“回听”操作为：选择一系列 $n$ 以内的下标，记该下标集合为 $S$。令所有 $a_{s_i}$ 去到 $s_{i+1}$ 位置。特别的，令 $a_{s_{|S|}}$ 去到 $s_1$ 位置并减掉 $|S|-1$（但不能减到 $0$ 以下）。

定义 $b_i$ 为一次回听操作后 $a_i$ 可能产生的最小值。

有 $m$ 次对 $A$ 的区间加修改。在每次修改后回答有多少种 $b_i$ 取值。

$n,m\le 5\times 10^5$。$V$ 经过区间加后会到达 `long long` 范围。

### 做法解析
手玩，你发现：$b_i$ 要么是 $j\in[1,i]$ 内最小的 $a_j$，要么是对于 $j\in(i,n]$ 最小的 $a_i-(j-i)$。如果你只是想单点求 $b_i$，两个区间加区间最小值的线段树就能搞定。

但是“本质不同的 $b_i$”又要怎么搞？这东西复杂度看着就很不简单啊，除非……

除非“本质不同”是个幌子。你分析一下这个东西。你发现，$b_i$ 随 $i$ 增加单调不降，并且相邻 $b_i$ 间差值最多为 $1$。这意味着你求出 $b_1$ 和 $b_n$ 之后，本质不同的 $b_i$ 种数就是 $b_n-b_1+1$。

为什么呢？这是因为随着 $i$ 每增加 $1$，你发现来源于 $(i,n]$ 的那部分答案就会随之增加 $1$，而来源于 $[1,i]$ 的那部分答案不变。

好说完了。

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
using namespace obasic;
const int MaxN=5e5+5;
const lolo Inf=1e18;
int N,M,A[MaxN],D[MaxN],X,Y,Z;
struct SegTree{
    lolo mn[MaxN<<2],tag[MaxN<<2];
    int ls(int u){return u<<1;}
    int rs(int u){return (u<<1)|1;}
    void pushup(int u){mn[u]=min(mn[ls(u)],mn[rs(u)]);}
    void build(int u,int cl,int cr,int x[]){
        if(cl==cr){mn[u]=x[cl];return;}int cmid=(cl+cr)>>1;
        build(ls(u),cl,cmid,x),build(rs(u),cmid+1,cr,x),pushup(u);
    }
    void maketag(int u,lolo x){mn[u]+=x,tag[u]+=x;}
    void pushdown(int u){if(tag[u])maketag(ls(u),tag[u]),maketag(rs(u),tag[u]),tag[u]=0;}
    void update(int u,int cl,int cr,int dl,int dr,lolo x){
        if(dl<=cl&&cr<=dr){maketag(u,x);return;}
        int cmid=(cl+cr)>>1;pushdown(u);
        if(dl<=cmid)update(ls(u),cl,cmid,dl,dr,x);
        if(dr>cmid)update(rs(u),cmid+1,cr,dl,dr,x);
        pushup(u);
    }
    lolo getmin(int u,int cl,int cr,int dl,int dr){
        if(dl<=cl&&cr<=dr)return mn[u];
        int cmid=(cl+cr)>>1;lolo res=Inf;pushdown(u);
        if(dl<=cmid)minner(res,getmin(ls(u),cl,cmid,dl,dr));
        if(dr>cmid)minner(res,getmin(rs(u),cmid+1,cr,dl,dr));
        return res;
    }
}SgT1,SgT2;
int solve(int p){return min(SgT1.getmin(1,1,N,1,p),max((SgT2.getmin(1,1,N,p,N)+p),0ll));}
int main(){
    readis(N,M);
    for(int i=1;i<=N;i++)readi(A[i]),D[i]=A[i]-i;
    SgT1.build(1,1,N,A),SgT2.build(1,1,N,D);
    for(int i=1;i<=M;i++){
        readis(X,Y,Z);
        SgT1.update(1,1,N,X,Y,Z);
        SgT2.update(1,1,N,X,Y,Z);
        writil(solve(N)-solve(1)+1);
    }
    return 0;
}
```

---

## 作者：fish_love_cat (赞：0)

倒闭了，这么水没写出来。

---

首先观察题目发现：

$$b_i=\min(\min^i_{j=1}a_j,\min_{j=i+1}^n \max(a_j-j+i,0))$$

然后前后两个柿子显然可以用两棵线段树维护出来。

暴力统计 $b_i$ 容易做到 $O(nm \log n)$，不使用线段树直接做然后去重不用 `set` 可以做到 $O(nm)$。

但这显然过不了，结合特殊性质也只有 $40\text{pts}$，我赛时就想到这然后炸了。

容易发现后面的一个柿子每往前一个会少一，于是当前面的最小值跑到后面时 $b_i$ 至多减少一个。

如果跑到后面的没有贡献，那么原先的最小值也是减少一个。

于是发现神秘性质，$b_i$ 单调不降且相邻的 $b_i$ 最多差一！

于是对于区间，求出 $b_l$ 与 $b_r$ 即可。这样就能做到 $O(q\log n)$ 了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define ll long long
const int maxn=1e6+10;
ll a[maxn],w[maxn<<2],z[maxn<<2];//存储，树，懒标记
void pushup(const int u){w[u]=min(w[u<<1],w[(u<<1)+1]);}//合并（满足结合律！）
void build(const int u,int l,int r){//建树
    if(l==r){w[u]=a[l]; return;}
    int mid=(l+r)>>1;
    build(u<<1,l,mid),build((u<<1)+1,mid+1,r),pushup(u);
}
bool inrg(int l,int r,int l2,int r2){return (l2<=l)&&(r<=r2);}//包含？
bool outrg(int l,int r,int l2,int r2){return (l>r2)||(r<l2);}//无交集？
void mktag(int u,int l,ll x){z[u]+=x,w[u]+=x;}//更改
void pushdown(int u,int l,int r){//更新儿子
    int mid=(l+r)>>1;
    mktag(u<<1,mid-l+1,z[u]),mktag((u<<1)+1,r-mid,z[u]),z[u]=0;
}
void update(int u,int l,int r,int l2,int r2,ll x){//二分修改
    if(inrg(l,r,l2,r2)) mktag(u,r-l+1,x);
    else if(!outrg(l,r,l2,r2)){
        int mid=(l+r)>>1;
        pushdown(u,l,r),update(u<<1,l,mid,l2,r2,x),update((u<<1)+1,mid+1,r,l2,r2,x),pushup(u);
    }
}
ll query(int u,int l,int r,int l2,int r2){//记和
    if(inrg(l,r,l2,r2)) return w[u];
    if(!outrg(l,r,l2,r2)){
        int mid=(l+r)>>1; pushdown(u,l,r);
        return min(query(u<<1,l,mid,l2,r2),query((u<<1)+1,mid+1,r,l2,r2));
    }
    return 1e9;
}
int read(){
    int sum=0,fish=1;
    char c=getchar_unlocked();
    while((c<'0'||c>'9')&&c!='-')c=getchar_unlocked();
    if(c=='-')fish=-1,c=getchar_unlocked();
    while(c>='0'&&c<='9')sum=sum*10+(c-'0'),c=getchar_unlocked();
    return sum*fish;
}
void print(int x){
    if(x<0)putchar('-'),x=-x;
    if(x<10)putchar(x+'0');
    else print(x/10),putchar(x%10+'0');
}
signed main(){
    int n=read(),m=read();
    for(int i=1;i<=n;i++)
        a[i]=read();
    for(int i=n+1;i<=n+n;i++)
        a[i]=a[i-n]-(i-n-1);
    int N=n;
    n*=2;
    build(1,1,n);
    while(m--){
        int l=read(),r=read(),x=read();
        update(1,1,n,l,r,x);
        update(1,1,n,l+N,r+N,x);
        int i=1;
        int L=max(0ll,min(query(1,1,n,1,i),query(1,1,n,N+i+1,n)+i-1));
        i=N;
        int R=max(0ll,min(query(1,1,n,1,i),query(1,1,n,N+i+1,n)+i-1));
        print(R-L+1),puts("");
    }
    return 0;
}
```

这么好的题没写出来，失败的人生。

---

## 作者：xiao7_Mr_10_ (赞：0)

## 前言

我有一个朋友（这当然不是话术），他和我分享了这道题，然后我看了一下做出来了，就写了这篇题解。还有[这篇文章](https://www.luogu.com.cn/article/pi7pcsb8)也是和他有关。

## 解题思路

首先，我们需要分析一下 $b_i$ 的取值。

不难发现所谓回听操作可以分成两种情况考虑：

- 令操作中 $x=i$，然后找到 $i$ 前面一个数 $a_j$ 做一次交换，让 $b_i$ 能取到 $a_j$。

- 令操作中 $x>i$，形象来说就是让 $a_x$ 通过一次次与 $x-1$ 交换跑到 $i$，每次都需要将其 $-1$，使得 $b_i$ 能取到 $a_j-j+i$。

所以我们有：

$b_i=\max(0,\min(\min\limits_{1 \le j \le i}a_j,\min\limits_{i+1 \le j \le n}(a_j-j+i)))$。

至此，我们可以通过 $O(n)$ 的复杂度预处理，然后每次 $O(n)$ 的求出序列 $b$。

然而，通过分析 $b$ 数组的求法发现：$b$ 单调不降，并且 $b_i - b_{i-1} \le 1$。

我们可以通过简单的对比来进行证明：

$b_i=\max(0,\min(\min\limits_{1 \le j \le i}a_j，a_{i+1}-1,\min\limits_{i+2 \le j \le n}(a_j-j+i)))$。

$b_{i+1}=\max(0,\min(\min\limits_{1 \le j \le i}a_j，a_{i+1},\min\limits_{i+2 \le j \le n}(a_j-j+i+1)))$。

这是我参考其他题解的式子，因为没有更简单的表达了。我们发现每一项最多 $+1$，所以 $b_{i+1}$ 至多 $+1$。

也可以感性理解一下，每次移动会使得区间 $[i+1,n]$ 可取的数 $+1$，所以 $b$ 单调递增且增量最多为 $1$。

所以我们就只需要维护 $b_1$ 与 $b_n$ 的值，答案即为 $b_n - b_1 +1$。

而它们的式子都可以通过简单分析化简，线段树支持维护区间加求最小值即可。

$b_1=\min\limits_{1\le i \le n}(a_i-i+1)$。

$b_n=\min\limits_{1 \le i \le n}a_i$。

时间复杂度 $O((n+m)\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+5;
int n,m,a[N],b[N],l,r,k;
struct tree{
	int c[N<<2],tag[N<<2];
	void updata(int x){
		c[x]=min(c[x<<1],c[x<<1|1]);
	}
	void build(int x,int l,int r){
		if(l==r){
			c[x]=b[l];
			return;
		}int mid=(l+r)>>1;
		build(x<<1,l,mid),build(x<<1|1,mid+1,r);updata(x);
	}void pushdown(int x,int y){
		c[x]+=y,tag[x]+=y;
	}void down(int x){
		pushdown(x<<1,tag[x]),pushdown(x<<1|1,tag[x]),tag[x]=0;
	}
	void change(int x,int l,int r,int s,int t,int k){
		if(l>=s&&r<=t){
			pushdown(x,k);
			return;
		}int mid=(l+r)>>1;down(x);
		if(s<=mid)change(x<<1,l,mid,s,t,k);
		if(t>mid)change(x<<1|1,mid+1,r,s,t,k);updata(x);
	}
}f,g;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin >> n >> m;
	for(int i = 1;i <= n;i++)cin >> a[i],b[i]=a[i]-i+1;
	f.build(1,1,n);
	for(int i = 1;i <= n;i++)b[i]=a[i];g.build(1,1,n);
	for(int i = 1;i <= m;i++){
		cin >> l >> r >> k;
		f.change(1,1,n,l,r,k),g.change(1,1,n,l,r,k);
		l=max(0ll,f.c[1]),r=max(0ll,g.c[1]);
		cout << r-l+1 << "\n";
	}	
	return 0;
}
 
```

---

## 作者：ELECTRODE_kaf (赞：0)

考虑对于一个 $b_i$，它右侧的数与它交换会减少，所以它由它左侧的 $a_j$ 贡献 $a_j$，右侧的 $a_j$ 最多贡献 $a_j-(j-i)=a_j-j+i$。即 $b_i=\max(0,\min_{k=1}^ia_k,\min_{k=i+1}^na_k-k+i)$。所以 $b_i$ 单调不减。若继续观察 $b_i$ 的增速可以发现，$b_{i+1}$ 若选择与 $b_i$ 相同的 $a_k$ 则 $b_{i+1}=b_i+1$，所以相邻的 $b_i$ 最多相差 $1$。所以所求不同 $b_i$ 的种数即为 $b_n-b_1+1$。代入上式得到 $b_1=\max(0,\min_{k=1}^na_k-k+1),b_n=\min a_k$，用两个线段树分别维护这两个值即可。

```cpp
const ll N=5e5+10;
ll n,q,a[N],sgtr1[N*4],sgtr2[N*4],tg1[N*4],tg2[N*4];

ll ls(ll p){
	return p*2; 
} 

ll rs(ll p){
	return p*2+1; 
}

void pushup(ll p){
	sgtr1[p]=min(sgtr1[ls(p)],sgtr1[rs(p)]);
	sgtr2[p]=min(sgtr2[ls(p)],sgtr2[rs(p)]);
}

void pushdown(ll p){
	if(tg1[p]){
		sgtr1[ls(p)]+=tg1[p];
		sgtr1[rs(p)]+=tg1[p];
		tg1[ls(p)]+=tg1[p];
		tg1[rs(p)]+=tg1[p];
		tg1[p]=0;
	}
	
	if(tg2[p]){
		sgtr2[ls(p)]+=tg2[p];
		sgtr2[rs(p)]+=tg2[p];
		tg2[ls(p)]+=tg2[p];
		tg2[rs(p)]+=tg2[p];
		tg2[p]=0;
	}
}

void build(ll p,ll l,ll r){
	if(l==r){
		sgtr1[p]=a[l]-l+1;
		sgtr2[p]=a[l];
		return;
	}
	
	ll mid=(l+r)/2;
	build(ls(p),l,mid);
	build(rs(p),mid+1,r);
	pushup(p);
}

void upd(ll p,ll l,ll r,ll ql,ll qr,ll v){
	if(l>qr or r<ql) return;
	
	if(ql<=l and r<=qr) {
		sgtr1[p]+=v;
		sgtr2[p]+=v;
		tg1[p]+=v;
		tg2[p]+=v;
		return;
	}
	
	pushdown(p);
	ll mid=(l+r)/2;
	upd(ls(p),l,mid,ql,qr,v);
	upd(rs(p),mid+1,r,ql,qr,v);
	pushup(p);
}

int main(){
	sync_off;
	cin>>n>>q;
	
	rep(i,1,n) cin>>a[i];
	
	build(1,1,n);
	
	count(q){
		ll l,r,v;
		cin>>l>>r>>v;
		upd(1,1,n,l,r,v);
		cout<<max(0ll,sgtr2[1])-max(0ll,sgtr1[1])+1<<'\n';
	}
}
```

---

## 作者：Miraclaze (赞：0)

算是比较简单的一道线段树题。
## 分析
不难想到选择的 $a_i$ 在进行回想操作后，如果仍然大于原数组中的最小值，那么显然就不产生贡献的。因此接下来只关注能够通过回想操作，使得 $a_i$ 的数值小于原数组中最小值的 $a_i$。

这样便能得到一个区间，即 $[\min_{i = 1}^{n}\{a_i - i\},\min_{i = 1}^{n}\{a_i\}]$，显然在这个区间上所有值都是可以取得的（即题目的条件 $a_i = max(a_i - 1,0)$ ），那么接下来就是如何去找到这最小值。

## code
处理区间上的最小值而且需要在线不难想到线段树，那么维护两个线段树，一个处理 $a_i - i$，一个处理 $a_i - i$，然后就做完了。
```cpp
#include<bits/stdc++.h>
using i64 = long long;
const i64 inf = 1e18;
const int N = 5e5 + 10;
struct Tree{
    int l , r;
    i64 lz , mn;
};
std::array<i64 , N> a;
struct SegmentTree{
    std::vector<Tree> tr;
    SegmentTree(int n) : tr(4 << std::__lg(n)) {}

    void build(int i , int l , int r , bool flag){
        tr[i].l = l , tr[i].r = r;
        if(l == r){
            tr[i].mn = a[l] + (flag ? -l : 0);
            tr[i].lz = 0;
            return ;
        }
        
        int mid = (l + r) >> 1;
        build(i << 1 , l , mid , flag);
        build(i << 1 | 1 , mid + 1 , r , flag);

        tr[i].mn = std::min(tr[i << 1].mn , tr[i << 1 | 1].mn);
        tr[i].lz = tr[i << 1].lz + tr[i << 1 | 1].lz;
        return ;
    }

    void pushdown(int i){
        tr[i << 1].mn = tr[i << 1].mn + tr[i].lz;
        tr[i << 1 | 1].mn = tr[i << 1 | 1].mn + tr[i].lz;
        tr[i << 1].lz += tr[i].lz;
        tr[i << 1 | 1].lz += tr[i].lz;
        tr[i].lz = 0;
    }

    void update(int i , int l , int r , int L , int R , int x){
        if(L > r || l > R){
            return ;
        }

        if(L <= l && r <= R){
            tr[i].mn += x;
            tr[i].lz += x;
            return ;
        }

        pushdown(i);

        int mid = (l + r) >> 1;
        update(i << 1 , l , mid , L , R , x);
        update(i << 1 | 1 , mid + 1 , r , L , R , x);

        tr[i].mn = std::min(tr[i << 1].mn , tr[i << 1 | 1].mn);
        return ;
    }

    i64 quiry(int i , int l , int r , int L , int R){
        if(L > r || l > R){
            return inf;
        }

        
        if(L <= l && r <= R){
            return tr[i].mn;
        }

        pushdown(i);

        int mid = (l + r) >> 1;
        i64 res = inf;
        res = std::min(res , quiry(i << 1 , l , mid , L , R));
        res = std::min(res , quiry(i << 1 | 1 , mid + 1 , r , L , R));

        return res;
    }
};
int main(){
    std::ios::sync_with_stdio(0);
    std::cin.tie(nullptr);

    int n , m;
    std::cin >> n >> m;

    std::vector<SegmentTree> ST(2 , n);
    for(int i = 1; i <= n; i++){
        std::cin >> a[i];
    }
    
    //std::cerr << 1 << '\n';

    ST[0].build(1 , 1 , n , 0);
    ST[1].build(1 , 1 , n , 1);

    
    for(int i = 0; i < m; i++){
        int l , r , v;
        std::cin >> l >> r >> v;
        ST[0].update(1 , 1 , n , l , r , v);
        ST[1].update(1 , 1 , n , l , r , v);

        std::cout << ST[0].quiry(1 , 1 , n , 1 , n) - std::max(ST[1].quiry(1 , 1 , n , 1 , n) + 1LL , 0LL) + 1 << '\n';
    }

    return 0;
}

```

---

## 作者：sbno333 (赞：0)

做起来比较享受（不考虑写代码）的简单思维题。

我们先考虑 $b_i$ 怎么算。

考虑贪心，首先第一次回听在 $i$ 前面相当于没回听，如果在 $i$ 上就是 $\min_{j=1}^i a_j$ 最好。

在后面的话假设开始在 $p$ 上，由于我们被迫追踪 $p$，因此为了最小就要多操作，那就是一直前移，最后为 $a_p-p+i$。

可以分成两个部分，答案就是 $\min_{j=1}^i a_j$ 和 $\min_{p=i}^n a_p-p+i$ 的最小值，当然在 $i$ 这个位置上都是相等的，因此可以选择一部分去掉这个边界，方便代码的书写。

这时候就是 $40$ 分。

当然，我们要找到更多的性质。

对于每一个 $i$，什么时候前者，什么时候取后者。

当 $i$ 从前往后时，前者越来越小，后者越来越大，因此存在边界，边界前面取后者，后面取前者。

线段树二分即可找到。

但是同一个部分还是分不了，怎么办呢？

考虑当取后者的时候有 $\min_{j=1}^i a_j>\min_{p=i}^n a_p-p+i$。

在边界时显然选取了一个 $p$。

考虑往前走，由于上面的不等式，发现前面新发现的永远不如最开始的，所以总选一个。

这时候 $b_i$ 从边界往前每扫一个就减去 $1$，所以这个部分就处理完了。

考虑另一个部分。

$\min_{j=1}^i a_j\le\min_{p=i}^n a_p-p+i$。

还是最开始选了个 $j$，往后面扫的时候发现还是找到新的也没有 $j$ 好，此时没有减法，所以只贡献 $1$，当然也可能不贡献。

于是代码就出炉了。

略一卡常即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[500009];
#define endl "\n"
struct st{
	int l,r;
	int lm,rm;
	int laz;
}f[2000009];
inline void pushdown(int t){
	if(f[t].l==f[t].r){
		f[t].laz=0;
		return;
	}
	f[(t<<1)].laz+=f[t].laz;
	f[(t<<1)].lm+=f[t].laz;
	f[(t<<1)].rm+=f[t].laz;
	f[((t<<1)|1)].laz+=f[t].laz;
	f[((t<<1)|1)].lm+=f[t].laz;
	f[((t<<1)|1)].rm+=f[t].laz;
	f[t].laz=0;
}
inline void pushup(int t){
	pushdown(t);
	if(f[t].l==f[t].r){
		return;
	}
	f[t].lm=min(f[(t<<1)].lm,f[((t<<1)|1)].lm);
	f[t].rm=min(f[(t<<1)].rm,f[((t<<1)|1)].rm);
}
int n,m;
inline void build(int t,int l,int r){
	f[t].l=l,f[t].r=r;
	if(l==r){
		f[t].lm=a[l];
		f[t].rm=a[l]-l+1;
		return;
	}
	int mid;
	mid=l+r;
	mid>>=1;
	build((t<<1),l,mid);
	build(((t<<1)|1),mid+1,r);
	pushup(t);
}
inline void pls(int t,int l,int r,int k){
	pushdown(t);
	if(f[t].l==l&&f[t].r==r){
		f[t].lm+=k,f[t].rm+=k;
		f[t].laz+=k;
		return;
	}
	int mid;
	mid=f[t].l+f[t].r;
	mid>>=1;
	if(r<=mid){
		pls((t<<1),l,r,k);
	}else if(l>mid){
		pls(((t<<1)|1),l,r,k);
	}else{
		pls((t<<1),l,mid,k),pls(((t<<1)|1),mid+1,r,k);
	}
	pushup(t);
}
inline int m1(int t,int x){
	pushdown(t);
	if(f[t].r==x){
		return f[t].lm;
	}
	int mid;
	mid=f[t].l+f[t].r;
	mid>>=1;
	if(x<=mid){
		return m1((t<<1),x);
	}else{
		return min(f[(t<<1)].lm,m1(((t<<1)|1),x));
	}
}
inline int m2(int t,int x){
	pushdown(t);
	if(f[t].l==x){
		return f[t].rm;
	}
	int mid;
	mid=f[t].l+f[t].r;
	mid>>=1;
	if(x<=mid){
		return min(f[((t<<1)|1)].rm,m2((t<<1),x));
	}else{
		return m2(((t<<1)|1),x);
	}
}
inline int ef(int t,int lx,int rx){
	pushdown(t);
	if(f[t].l==f[t].r){
		return f[t].l;
	}
	int mid;
	mid=f[t].l+f[t].r;
	mid>>=1;
	mid++;
	int x,y;
	x=min(f[(t<<1)].lm,lx);
	y=min(rx,f[((t<<1)|1)].rm)+mid-1;
	if(x>y){
		return ef(((t<<1)|1),min(lx,f[(t<<1)].lm),rx);
	}else{
		return ef((t<<1),lx,min(rx,f[((t<<1)|1)].rm));
	}
}
inline void _main(){
	int ll,rr,vv;
	cin>>ll>>rr>>vv;
	pls(1,ll,rr,vv);
	int x,y;
	x=m1(1,n-1);
	y=m2(1,n)+n-1;
	int ans;
	ans=0;
	if(x<=y){
		ans++;
	}
	x=1e16;
	y=m2(1,1);
	if(x<=y){
		cout<<ans<<endl;
		return;
	}
	int l;
	l=ef(1,1e16,1e16);
	x=m1(1,l-1);
	y=m2(1,l)+l-1;
	if(y==m1(1,n)){
		ans=0;
	}
	int g;
	g=y;
	x=1e16;
	y=m2(1,1);
	y=max(y,0ll);
	ans+=g-y+1;
	cout<<ans<<endl;
}
signed main(){
	std::ios::sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	build(1,1,n);
	while(m--){
		_main();
	}
	return 0;
}
```

---

## 作者：modfish_ (赞：0)

## 思路
经过简单的思考，可以得出 $b_i$ 的求解方法：

$$b_i=\min(\min_{j=1}^ia_i,\min_{j=i+1}^n\max(a_i-j+i,0))$$

也就是把前面的某个数换过来，或者把后面的某个数一步一步移过来。

不妨定义 $c_j$ 满足：

$$c_j=\begin{cases}a_j,& j\in [1,i]\\ a_j-j+i,& j\in [i+1,n]\end{cases}$$

则 $b_i=\max(\min c_j,0)$。观察 $i$ 从 $1$ 到 $n$ 的过程中，$c_j$ 的变化：

令 $d_j=a_j-j$。不难发现：$i=1$ 时，$c_j$ 就是 $d_j$ 全局加 $1$；$i=2$ 时，$c_j$ 在 $i=1$ 的基础上，又对其后缀 $[2,n]$ 加上 $1$；$i=3$ 时，又对后缀 $[3,n]$ 加上 $1$；……。也就是说，从 $i=t-1$ 转移到 $i=t$，只需要对 $c_j$ 的后缀 $[t,n]$ 加上 $1$ 即可。

再经过思考，设当前 $c_j$ 的最小值为 $c_k$，那么如果 $i<k$，$b_{i+1}$ 与 $b_i$ 不同。否则，$b_{i+1}$ 与 $b_i$ 相同。换句话说，对于任意 $i<k$，都有 $b_i<b_{i+1}$；而对于任意 $i\ge k$，都有 $b_i=b_k$（因为后缀加只会让后面的数变得越来越大，而永远无法影响 $c_k$）。我们只要求出第一个满足 $i\ge k$ 的 $i$ 即可。

设初始时 $d_j$ 的最小值为 $d_k$，考虑这样一个问题：某个位置 $c_p$（$p\le k$）何时才能大于等于 $c_k$ 呢？

当 $i\le p$ 时，$c_p$ 与 $c_k$ 都是被一起加 $1$ 的，差不会变，所以不必考虑。

当 $p<i\le k$ 时，$c_p$ 始终是 $c_p=d_p+p$，而 $c_k$ 发生变化：$c_k=d_k+i$。故当 $c_p=c_k$ 时，有 $d_p+p=d_k+i$，即：$i=d_p+p-d_k=a_p-(a_k-k)$。

所以当 $i=a_p-(a_k-k)$ 时，$c_p$ 可能成为新的最小值，在此之后，$b_i$ 不会发生变化。

要找到第一个满足上述条件的，也就是 $i=R=\min_{p=1}^ka_p-(a_k-k)$，非常容易，一棵线段树即可。

不过要注意，$b_i$ 还要和 $0$ 取 $\max$，所以还得先找何时 $\min c_j$ 第一次非负，记这个时刻为 $i=L$，显然有 $L=\max(-d_k,1)=\max(k-a_k,1)$。

最终答案即为 $\max(R-L+1,1)$。时间复杂度为 $O(q\log n)$。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int maxn = 5e5 + 5;

ll a[maxn];

namespace seg{
#define l(x) (x << 1)
#define r(x) (x << 1 | 1)
ll mn1[maxn << 2], mn2[maxn << 2], mni[maxn << 2], tag[maxn << 2];
void up(int x){
    mn1[x] = min(mn1[l(x)], mn1[r(x)]);
    if(mn2[l(x)] < mn2[r(x)]) mni[x] = mni[l(x)], mn2[x] = mn2[l(x)];
    else mni[x] = mni[r(x)], mn2[x] = mn2[r(x)];
}
void down(int x){
    mn1[l(x)] += tag[x], mn1[r(x)] += tag[x];
    mn2[l(x)] += tag[x], mn2[r(x)] += tag[x];
    tag[l(x)] += tag[x], tag[r(x)] += tag[x];
    tag[x] = 0;
}
void build(int x, int l, int r){
    if(l == r){
        mn1[x] = a[l], mn2[x] = a[l] - l, mni[x] = l;
        return;
    }
    int mid = l + r >> 1;
    build(l(x), l, mid), build(r(x), mid + 1, r);
    up(x);
}
void update(int x, int l, int r, int ql, int qr, ll v){
    if(ql <= l && r <= qr){
        mn1[x] += v, mn2[x] += v, tag[x] += v;
        return;
    }
    down(x);
    int mid = l + r >> 1;
    if(ql <= mid) update(l(x), l, mid, ql, qr, v);
    if(qr > mid) update(r(x), mid + 1, r, ql, qr, v);
    up(x);
}
ll query(int x, int l, int r, int ql, int qr){
    if(ql <= l && r <= qr) return mn1[x];
    down(x);
    int mid = l + r >> 1;
    ll res = 1e9;
    if(ql <= mid) res = min(res, query(l(x), l, mid, ql, qr));
    if(qr > mid) res = min(res, query(r(x), mid + 1, r, ql, qr));
    return res;
}}

int main(){
    int n, q;
    scanf("%d %d", &n, &q);
    for(int i = 1; i <= n; i ++) scanf("%lld", &a[i]);
    seg::build(1, 1, n);
    while(q --){
        int l, r;
        ll v;
        scanf("%d %d %lld", &l, &r, &v);
        seg::update(1, 1, n, l, r, v);
        int L = max(-seg::mn2[1], 1ll), R = seg::query(1, 1, n, 1, seg::mni[1]) - seg::mn2[1];
        printf("%d\n", max(R - L + 1, 1));
    }
    return 0;
}
```

---


# 「FAOI-R9」决战黎明

## 题目背景

牢光是一个很会发明小游戏的人。

清风喜欢和明月玩棋。有一天，他玩了一款牢光发明的《智棋之决战黎明》，因为游戏的趣味而欲罢不能，可惜明月太聪明了，他总是被明月虐。于是，他决定把这个问题推给你让你帮他研究。

## 题目描述

一些概念的定义如下：

* 战线：棋子按照玩家给定的顺序排列的轨道，**棋子一旦落入战线，即必须在这个战线上行动**。

* 棋子等级：玩家给棋子赋予的等级，会且只会因为「对战」的结果产生变化。**初始时这个等级必须为正整数。**

* 对战：对于两个棋子的对战，当棋子等级相等时，两个棋子均被消除；当两个棋子等级不等时，等级大的棋子等级减少 $ 1 $，等级小的棋子被消除。在一次对战中，显然至少会消除掉 $ 1 $ 个棋子。

游戏流程如下：

* 初始时双方游戏积分均为 $ 0 $。

* **准备阶段**：双方玩家规定本方的棋子数量，每个棋子的棋子等级、所属战线和出场顺序。**注意可以在某条战线上不放置任何棋子。**

* **对战阶段**：对于每条战线，进行如下流程（注意这里「在场棋子」指**本条战线上**未被消除的棋子）：

  * 如果两方均没有在场的棋子，则这个战线的流程结束。

  * 如果一方已经没有在场的棋子，则另一方获得与在场棋子的等级之和相等的游戏积分，这个战线的流程结束。
  
  * 如果双方均有在场的棋子，则两方在场的出场顺序最靠前的棋子进行一次「对战」。

* **结算阶段**：当所有战线的流程结束后，两个玩家的游戏积分则为本次游戏的结果。

在本局游戏中，有 $ n $ 个战线。

明月已经完成了自己的准备阶段，但是清风在自己未完成准备时偷偷看到了明月的全部 $ n $ 个战线的准备方案。

请你帮助清风设计一种准备方案，使得清风的所有棋子的初始等级均为正整数且和不超过 $ m $，且游戏结束后明月的游戏积分最少，你只需要输出这个最少的积分量即可。

因为清风很爱玩，所以你总共要对于 $ T $ 轮各自独立的游戏给出答案。

## 说明/提示

**【样例 1 解释】**

对于第一组数据，一种方案是清风派出初始等级为 $ 2 $ 的棋子一枚。

对战流程如下：

* 清风在场棋子等级分别为 $ \{2\} $，明月在场棋子等级分别为 $ \{1,1\} $，等级为 $ 2 $ 的清风棋子和等级为 $ 1 $ 的明月棋子对战，明月棋子被消除，清风棋子等级降为 $ 1 $。

* 清风在场棋子等级分别为 $ \{1\} $，明月在场棋子等级分别为 $ \{1\} $，双方均派出等级为 $ 1 $ 的棋子出战，均被消除。

* 双方均已无棋子，该条战线不影响双方积分。

因此，该种方案明月的积分为 $ 0 $。

**【数据规模与约定】**

**本题采用捆绑测试。**

对于每个测试点：

* $ 1 \le T \le 5 $；

* $ \bm{1 \le n \le 2} $，$ 1 \le l_i \le 10^5 $；

* $ 0 \le m \le 10^{18} $，明月的棋子等级均为正整数且不超过 $ 10^9 $。

| 子任务编号 | $ n $ | $ l_i $ | $ m $ | 明月棋子等级上限 | 分值 |
|:-:|:-:|:-:|:-:|:-:|:-:|
| $ 1 $ | $ =1 $ | $ \le 5 $ | $ \le 10 $ | $ \le 5 $ | $ 8 $ |
| $ 2 $ | $ =1 $ | $ \le 300 $ | $ \le 300 $ | $ \le 5 $ | $ 16 $ |
| $ 3 $ | $ =1 $ | - | - | $ =1 $ | $ 4 $ |
| $ 4 $ | $ =1 $ | - | - | - | $ 24 $ |
| $ 5 $ | $ =2 $ | - | $ =0 $ | - | $ 4 $ |
| $ 6 $ | $ =2 $ | $ \le 300 $ | - | - | $ 8 $ |
| $ 7 $ | $ =2 $ | $ \le 5000 $ | - | - | $ 12 $ |
| $ 8 $ | $ =2 $ | - | - | - | $ 24 $ |

## 样例 #1

### 输入

```
5 1
2
2 1 1
2
3 1 1 1
3
4 4 3 2 1
7
5 4 3 6 2 1
101
10 10 100 10 100 10 10 10 100 10 10```

### 输出

```
0
1
7
6
260```

## 样例 #2

### 输入

```
3 2
10
1 7
3 1 5 1
14
8 4 3 2 1 4 3 2 1
8 4 3 2 1 4 3 2 1
13
5 4 3 8 7 1
6 3 5 4 3 2 1```

### 输出

```
4
9
14```

# 题解

## 作者：船酱魔王 (赞：6)

## 分析

正解策略：两条战线每条一个大棋子打掉（抵消或击败）尽可能多的敌方棋子，然后若干个 $ 1 $ 级棋子上来对拼消耗剩余的敌方棋子。

考虑问题的模式：每条战线必然是能先打到某个敌方棋子然后打不下去了，只能尽可能去对拼这个敌方棋子。

> 结论 1：如果已经打不掉这个敌方棋子，那么放若干个 $ 1 $ 级棋子一定最优。

证明是显然的，这个敌方棋子等级消耗的量为放我方棋子的个数，显然越多越好。

> 结论 2：如果 $ a $ 级和 $ b $ 级我方棋子某条战线上被先后连续放出，且 $ b > 1 $，那么两个棋子合并一定不劣。

如果棋子 $ b $ 没有将某个敌方棋子打掉，那么显然 $ b $ 为 $ 1 $ 级棋子更优。

如果棋子 $ b $ 将某个或某些棋子打掉了，那么显然 $ a+b $ 也能将那个或那些棋子打掉，且打完后剩下的棋子必然不少。

> 结论 3：如果能多打一个敌方棋子，就多打一个，而用这些我方棋子预算去拆分成若干个 $ 1 $ 级对拼消耗一定不优。

打掉这个棋子多花费的预算显然不超过这个棋子的等级，而对拼消耗显然是预算等于敌方棋子的被消耗等级，显然前者不劣。

所以，递推出打掉到每个敌方棋子的最小我方棋子等级，二分每个第一战线敌方棋子攻打位置情况下第二战线最多打到哪里，再计入剩下的我方棋子等级即可。

## 标程

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1e5 + 5;
int T, n;
long long m;
int l[3];
int g[3][N];
int dp[3][N];
long long f[3][N];
int main() {
	scanf("%d%d", &T, &n);
	for(int ti = 1; ti <= T; ti++) {
		scanf("%lld", &m);
		long long o = 0;
		for(int i = 1; i <= n; i++) {
			scanf("%d", &l[i]);
			for(int j = 1; j <= l[i]; j++) scanf("%d", &g[i][j]), o += g[i][j];
		}
		for(int i = 1; i <= n; i++) {
			for(int j = 1; j <= l[i]; j++) {
				if(g[i][j - 1] + j - 2 == dp[i][j - 1]) dp[i][j] = max(dp[i][j - 1] + 1, g[i][j] + j - 1);
				else dp[i][j] = max(dp[i][j - 1], g[i][j] + j - 1);
				f[i][j] = f[i][j - 1] + g[i][j];
			}
		}
		for(int i = 1; i <= n; i++) {
			for(int j = 1; j <= l[i]; j++) {
				if(dp[i][j] >= g[i][j] + j && j < l[i]) f[i][j]++;
			}
		}
		long long ans = 0;
		for(int j = 0; j <= l[1]; j++) {
			int lf, r, mid;
			if(dp[1][j] > m) break;
			lf = 0;
			r = l[2] + 1;
			while(lf + 1 < r) {
				mid = (lf + r) >> 1;
				if(dp[1][j] + dp[2][mid] <= m) lf = mid;
				else r = mid;
			}
			ans = max(m - dp[1][j] - dp[2][lf] + f[1][j] + f[2][lf], ans);
		}
		printf("%lld\n", max(0ll, o - ans));
	}
	return 0;
}
```

---

## 作者：yanbinmu (赞：2)

## P12398 「FAOI-R9」决战黎明 题解

### 分析
我们可以将其弱化，先考虑只有一条战线的时候。对此，我们有两个比较显然的规律：

1. 当我们有两个棋子时，用一个等级为两者之和的棋子会更好。
2. 当我们定然无法击败某一个棋子时，我们用很多个等级为 1 的棋子去消耗它是最好的。

基于这两条，我们可以总结出一个大致的流程：先用一个等级很高的棋子一路过关斩将，然后剩下的所有等级拆成一个个等级为 1 的棋子。

为了实现这个，我们可以记录 $b_i$ 表示对于某个棋子，我们要用一个等级为多少的棋子从头开始，一路打到这里。然后一直遍历，直到这个值比 $m$ 更大。然后取前面所有 $b_i$ 中的最大值，剩下的全部变成 1。

然后我们考虑两条战线时，我们应该怎么做。

这其实就是一个资源分配的问题，我们可以给某一条战线分配足够他打到某个点的等级，剩下的等级分配给另一条战线。枚举一条战线上的点，然后二分出另一条战线可以打到哪里即可。

需要注意的是，可能还会剩余一定分数，我们要将这部分考虑进去。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int N = 2e5 + 5;

int T, n;

int m;

int l[3];

int a[3][N];

int sum[3][N];

int c[3][N];

void solve() {
    cin >> m;
    for(int i = 1;i <= n;i ++ ) {
        cin >> l[i];
        for(int j = 1;j <= l[i];j ++ ) {
            cin >> a[i][j];
        }
    }
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= l[i]; j++) {
            if(a[i][j - 1] + j - 2 == c[i][j - 1]) c[i][j] = max(c[i][j - 1] + 1, a[i][j] + j - 1);
            else c[i][j] = max(c[i][j - 1], a[i][j] + j - 1);
            sum[i][j] = sum[i][j - 1] + a[i][j];
        }
    }
    for(int i = 1;i <= n;i ++ ) {
        for(int j = 1;j < l[i];j ++ ) {
            if(c[i][j] > a[i][j] + j - 1) sum[i][j] ++ ;
        }
    }

    int Sum[3];

    Sum[1] = sum[1][l[1]];
    Sum[2] = sum[2][l[2]];

    // cout << T << ": " << Sum[1] << "\n";
    // cout << 114;
    int ans = 0;
    for(int j = 0;j <= l[1];j ++ ) {
        if(c[1][j] > m) break;
        int L = 1, R = l[2], f = 0;
        while(L <= R) {
            int mid = L + R >> 1;
            if(c[2][mid] <= m - c[1][j]) L = mid + 1, f = mid;
            else R = mid - 1;
        }
        ans = max(ans, sum[1][j] + sum[2][f] + (m - c[1][j] - c[2][f]));
    }
    cout << max(Sum[1] + Sum[2] - ans, 0ll) << "\n";
}

signed main() {
    // int T, n;
    cin >> T >> n;
    while(T -- ) {
        solve();
    }
    return 0;
}
```

---

## 作者：MPLN (赞：2)

~~某个天才做题第 n 次没开 long long ，赛时调一个多小时才发现然后 T4 来不及打暴力。~~

## 思路

对于某条战线，我们要干掉前 $k$ 个棋子，容易发现最优方案就是派一个高等级棋子直接一个个干掉前 $k$ 个棋子。因为一个棋子如果死掉至少损失 $m$ 个等级中 $1$ 等级，而棋子继续向前也只会损失 $1$ 等级，一定不劣。

假设是可能打过前 $k$ 个的，接下来就是这个等级应该选择多高了。发现当其打到第 $i$ 个棋子时自己的等级至少为 $a_i+i$（$a_i$ 是第 $i$ 个敌方棋子等级），因为前面有战损 $i-1$ 个等级。但是当 $i=k$ 时要特殊判断，因为我们只是要干掉前 $k$ 个棋子，和最后一个同归于尽也行。

同时，这个要干掉前 $k$ 个对方棋子的棋子等级要尽可能低，因为如果有冗余，再打后面的棋子被干掉了就会损耗太多。

综上，这个“超级攻击型”棋子等级应该为：

$$
\max(\max_{1\le i<k}(a_i+i),a_k+k-1)
$$

可以预处理这个，然后二分判断这条战线最多干掉几个棋子，最后对面还能拿多少分可以再预处理后缀和得到。

干完棋子之后，还剩下些等级没用，不能浪费，就一个等级一个等级削下一个干不掉的敌人的等级。

去掉预处理，我们用二分 $O(\operatorname{log}l)$ 解决了一条战线的问题，即当 $n=1$，拿到 52pts。

$n=2$ 也不难，预处理两条战线，然后套一层枚举：战线 1 干掉几个棋子，内部再二分求出最多干掉战线 2 几个棋子。最后用剩下的等级一个个干不掉的敌人的等级。
  
进一步优化，两个战线干掉几个棋子需要的等级都是单调的，改成双指针，可以去掉 $\operatorname{log}$。

总时间复杂度 $O(\sum l)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t, n, len[3], m, a[3][100010], premx[5][100010], suf[3][100010];
bool lft[3][100010];
signed main() {
    scanf("%lld%lld", &t, &n);
    while (t--) {
        scanf("%lld", &m);
        memset(lft, 0, sizeof(lft));
        for (int i = 1; i <= n; i++) {
            scanf("%lld", &len[i]);
            for (int j = 1; j <= len[i]; j++) {
                scanf("%lld", &a[i][j]);
            }
        }
        suf[1][len[1]+1] = suf[2][len[2]+1] = 0;
        int ans = 1e18;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= len[i]; j++) {
                premx[i + n][j] = max(premx[i + n][j - 1], a[i][j] + j);
                premx[i][j] = max(premx[i + n][j - 1], a[i][j] + j - 1);
                if (premx[i + n][j - 1] > a[i][j] + j - 1 && j != len[i]) lft[i][j] = 1;
            }
        for (int i = 1; i <= n; i++)
            for (int j = len[i]; j >= 1; j--)
                suf[i][j] = suf[i][j + 1] + a[i][j];
        for (int i = 0, l = len[2]; i <= len[1]; i++) {
            if (m < premx[1][i]) break;
            while(m - premx[1][i] - premx[2][l] < 0) l--;
            ans = min(ans, max(0LL,
                suf[1][i + 1] + suf[2][l + 1] -
                (m - premx[1][i] - premx[2][l]) -
                lft[1][i] - lft[2][l]
            ));
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```
理论上复杂度比 std 低，但是不知道为啥跑得不快（100ms）。

---

## 作者：shuqiang (赞：0)

### $n=1$ 做法

我们来分析一下题目，考虑求消灭前几个棋子的最小消耗等级和，首先，当一个棋子比另一个棋子的等级高 $1$，那么它自身的等级只会减 $1$，而可以消耗对方的血量多的棋子，所以我们最佳做法就是先放一个等级高的棋子，然后剩下没超出限制的就全部放等级为 $1$ 的来消耗对方的棋子。

### $n=2$ 做法

这个其实就在 $n=1$ 的基础上加一个双指针，然后每次考虑在第一个战线的前 $i$ 个棋子被消灭的情况下可以消灭的最远的棋子，最后剩下的一直放等级为 $1$ 的即可。

```cpp
#include<iostream>

using namespace std;
typedef long long ll;

const int N = 1e5 + 10;
int t, n, l1, l2, a[N], b[N], mx1[N], mx2[N];
ll s1[N], s2[N], m, ans; 

int main(){
	cin >> t >> n;
	while(t--){
		cin >> m >> l1; ans = 0;
		for(int i = 1; i <= l1; i++) cin >> a[i];
		s1[l1+1] = 0;
		for(int i = l1; i >= 1; i--){
			s1[i] = s1[i+1] + a[i];
		}
		for(int i = 1; i <= l1; i++){
			mx1[i] = max(mx1[i-1], a[i] + i);
		}
		if(n == 1){
			for(int i = 1; i <= l1; i++){
				if(mx1[i] > m){
					if(a[i] + i == m+1) ans = s1[i+1];
					else if(i > 1) ans = s1[i] - (m - mx1[i-1] + 1);
					else ans = s1[i] - m;
					break;
				}
			}
			cout << ans << '\n';
		}
		else{
			cin >> l2;
			for(int i = 1; i <= l2; i++) cin >> b[i];
			s2[l2+1] = 0;
			for(int i = l2; i >= 1; i--){
				s2[i] = s2[i+1] + b[i];
			}
			for(int i = 1; i <= l2; i++){
				mx2[i] = max(mx2[i-1], b[i] + i);
			}
			int j = l2;
			ans = 1e18; ll x1 = 0, x2 = 0, x3 = 0;
			for(int i = 0; i <= l1; i++){
				if(i == 0) x1 = 0;
				else x1 = max(mx1[i-1], a[i] + i - 1);
				while(j > 0 && max(mx2[j-1], b[j] + j - 1) > m-x1) j--;
				if(j == 0) x2 = 0;
				else x2 = max(mx2[j-1], b[j] + j - 1);
				if(m < x1+x2) break; x3 = 0;
				if(i != 0 && a[i] + i - 1 < mx1[i-1] && i < l1) x3--;
				if(j != 0 && b[j] + j - 1 < mx2[j-1] && j < l2) x3--;
				ans = min(ans, max(s1[i+1] + s2[j+1] - (m-x1-x2) + x3, 0ll));
			}
			cout << ans << '\n';
		}
	}
	return 0;
}
```

---


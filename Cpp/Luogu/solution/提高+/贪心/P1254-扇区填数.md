# 扇区填数

## 题目描述

有一个圆，当输入一个整数
 $n\ (1≤n≤8)$ 后，它被分成 $n$ 个扇区，请你为每一扇区选择一个正整数。

向各个扇区放入数之后，你可以从单个扇区中选出—个数，也可以从相邻的两个或多个扇区中各选一个数，相加后形成一个新的数，请使用这些整数形成一个连续的整数序列：$1,2,3,\cdots,i$，你的任务是使 $i$ 尽可能地大。


## 样例 #1

### 输入

```
1```

### 输出

```
1
1
```

# 题解

## 作者：xzyxzy (赞：18)

有一个必须要知道的结论：

$$ans=n*(n-1)+1$$
虽然我不知道怎么证明（等我知道了我再来更新题解）

Upd7.17：这个式子并不是正确的，比如n=7就不对，但是这是答案的极限，我们从大到小枚举答案然后想方设法构造方案，于是发现在这道题的测试点（n=2,3,4,5,6,8）上我们都可以在答案取到极限时成功构造出相应的方案

但是这个式子的含义是**每个数在一种方案中有且仅有一种表示方法**

计算有两种方式：

1.枚举一个分割线有n条，另一个分割线有n-1条，共n*(n-1)/2种方案，每种方案会产生两个数，然后加上全部算一起的一种方案

2.除开全部一起的方案，枚举扇区长度有n-1种，每种长度可以产生n个数，共n*(n-1)+1

所以知道了这个结论之后就很好做了，爆搜每一位是啥

注意这里n的范围是8（题面有误）

~~n=8我本机0.97s洛谷跑不过，所以打个表就好啦~~

感谢star_city、zykykyk两位大爷的帮助！

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
using namespace std;
int n,A[20],s,ans,tot,B[20],tt;
int v[23],tong[60],out[60][10];
inline void Check(int id)
{
	if(n>4&&(!v[2]||(!v[3]&&!v[4])||(!v[5]&&!v[6]&&!v[7]&&!v[8]))) return;
	register int i,l,r,u;
	for(i=n+1;i<=n<<1;++i) A[i]=A[i-n];
	for(i=1;i<=n<<1;++i) B[i]=B[i-1]+A[i];
	for(l=1;l<=n;++l)
		for(r=l,u=l+n-1;r<=u;++r)
			tong[B[r]-B[l-1]]=id;
	for(i=1;i<=ans;++i)
		if(tong[i]!=id) return;tot++;
	for(i=1;i<=n;i++) out[tot][i]=A[i];
}
void DFS(int x)
{
	if(x>n) {if(s==ans) Check(++tt);return;}
	for(int i=1;i<=22;++i)
		if(!v[i])
		{
			A[x]=i;v[i]=1;s+=i;
			if(s<=ans) DFS(x+1);
			v[i]=0;s-=i;
		}
}
void work1();
int main()
{
	cin>>n;A[1]=1;s=1;
	printf("%d\n",ans=n*(n-1)+1);
	if(n==8)work1();DFS(2);
	for(int i=1;i<=tot;i++,puts(""))
		for(int j=1;j<=n;j++)
			printf("%d ",out[i][j]);
}
void work1()
{
	printf("1 2 10 19 4 7 9 5\n1 3 5 11 2 12 17 6\n");
	printf("1 3 8 2 16 7 15 5\n1 4 2 10 18 3 11 8\n");
	printf("1 4 22 7 3 6 2 12\n1 5 9 7 4 19 10 2\n");
	printf("1 5 15 7 16 2 8 3\n1 6 12 4 21 3 2 8\n");
	printf("1 6 17 12 2 11 5 3\n1 8 2 3 21 4 12 6\n");
	printf("1 8 11 3 18 10 2 4\n1 12 2 6 3 7 22 4\n");
	exit(0);
}

```

---

## 作者：旋转卡壳 (赞：8)

**题意：**
一共有n个数围成一圈，我们可以通过选取一段连续的数，并算出它们的和来得出一个数。 要求我们合理安排每个位置上的数分别是什么来使得我们能算出最长的1,2,3,……数列

首先我们可以考虑一共有多少不同的取连续区间的方案

很明显就是组合数C(n,2) 就是n(n-1)/2 形象地理解就是先选取一条分界线 再选取另一条分界线 再去重 同样是这个答案

而每一组分界线能得出两个数 再加上一整圈 所以答案就是n(n-1)+1

但可能这不是最终答案 只能说是答案不超过这个数 因为有可能不同的区间加出的数是一样的 所以我们要暴力枚举看能不能满足

很明显 对于枚举的ans

1、第一位数一定是1

2、所有数加起来一定要等于ans

又因为n最大是8(数据问题？) ans最大是57

所以直接暴力 算就完事了

大概就是dfs选数+dp枚举区间长度看能加出什么数+桶记录剪枝

感觉每啥技术含量 黑题算不上 每心情懒得打代码了 直接%%%别的题解 QAQ

---

## 作者：_louhc (赞：7)

为什么都要打表啊qwq  
分明不用的嘛qwq  
该剪的枝最上面那位老兄都剪了。（相信大家都懂，这里不多说了）  
这里提出一些小优化。  
1. ~~Ofast~~
2. 不要用bits/stdc++.h(我也不知道为什么会变快)
3. short代替int(因为short只有两位,理论上来说会变快)
4. char代替bool(bool据说很慢,没有整型快)
5. 直接输出结果,不用存下来最后一起输出
6. 不用使用前缀和,直接加即可。(减法比加法慢)
7. 这里只要输入一个数,用fread快读反而会变慢
8. 多加register,要快多啦
9. s + i > ans时直接退出,能少几次循环qwq
10. check中根据逻辑运算规则可以转换一下,少几次运算
11. 三元运算符比if快
12. 不多说了.反正就是能少几次运算就少几次运算

千万别小看常数的力量  
（另外一道卡常数题）同样的复杂度，时间大常数的跑了20+s,小常数的只要跑1.5s-  
然后这题即使不打表,也能轻松跑过n=8的测试点啦（500ms+）

```cpp
#include<cstdio>
#include<cctype>
#include<ctime>
#include<cmath>
#include<iostream>
#include<cstring>
#pragma GCC optimize("Ofast")
#define u32 unsigned
#define i64 long long
#define u64 unsigned long long
#define f80 long double
#define rgt register
using namespace std;

clock_t __t_bg, __t_ed;

short N, NN, ans, u, s(1);
short a[100];
char ok[100], g[100];

bool check(){
	if( N > 4 && ( !g[2] || !( g[3] || g[4] ) || !( g[5] || g[6] || g[7] || g[8] ) ) ) return 0;
	memset( ok, 0, ans + 1 );
	for ( rgt short i = 1; i < N; ++i ) a[i + N] = a[i];
	for ( rgt short i = 1; i <= N; ++i )
		for ( rgt short j = 1, s(0); j <= N; ++j )
			ok[s += a[i + j]] = 1;
	for ( rgt short i = 1; i <= ans; ++i ) if ( !ok[i] ) return 0;
	return 1;
}

void DFS( rgt short x ){
	if ( x > N ){
		if ( ans == s && check() ){
			for ( rgt short i = 1; i <= N; ++i ) printf( "%d ", a[i] );
			putchar('\n');
		} return;
	} rgt short t(s++);
	for ( rgt short i = 1; i <= u && s <= ans; ++i, ++s )
		!g[i] ? a[x] = i, g[i] = 1, DFS(x + 1), g[i] = 0 : 0;
	s = t;
}

signed main(){
	__t_bg = clock();
	cin >> N, NN = N << 1;
	printf( "%d\n", ans = N * ( N - 1 ) + 1 ), u = ans < 22 ? ans : 22;
	a[1] = 1, DFS(2);
	__t_ed = clock(), fprintf( stderr, "time: %.5lfs\n", double( __t_ed - __t_bg ) / CLOCKS_PER_SEC );
	return 0;
}

```

---

## 作者：帝千秋丶梦尘 (赞：5)

# ~~# 蒟蒻又来啦~~

[没看过题的先康康（总会有不看题目先看题解的童鞋的）](https://www.luogu.com.cn/problem/P1254)

这是一次%你赛中老师出到过的题目，然后————~~打表真香~~

不！不能打表！~~好学生~~不能打表

哦，对，我好像不是好学生，so，比赛时我最终放弃爆搜程序打表

只要你是个oier，就知道爆搜骗分（懂得都懂）

然后看到n<=8.....

# 巧了

这还真就是道~~电风扇~~（dfs）之题

其实只要对dfs有~~亿~~(一)点点熟，就会写这道题了

so，up代码（注释都在，放心食用）：

```
#include<bits/stdc++.h>//坏习惯，不过————管它呢
using namespace std;
int n,ans,a[101],v[129],vis[129],sum[101],temp=1;
inline bool pd()//这一段我用的是前缀和来判断（不会吧不会吧，不会有人不知道前缀和吧）
{
	memset(vis,0,sizeof(vis));//清空好习惯
	sum[1]=1;
	for(register int i(2);i<=n;++i)
	{
		sum[i]=sum[i-1]+a[i];
	}
	for(register int i(1);i<n-1;++i)
	{
		sum[n+i]=sum[n+i-1]+a[i];
	}
	for(register int i(1);i<=n;++i)
	{
		vis[sum[i]]=1;
	}
	for(register int i(1);i<=n;++i)
	{
		for(register int j(1);j<=i-1;++j)
		{
			vis[sum[i]-sum[j]]=1;
		}
	}
	for(register int i(1);i<n-1;++i)
	{
		for(register int j(i+1);j<n;++j)
		{
			vis[sum[n+i]-sum[j]]=1;
		}
	}
	for(register int i(1);i<=ans;++i)
	{
		if(!vis[i])
		{
			return false;
		}
	}
	return true;
}
inline void dfs(int x,int s)
{
	if(s>ans)
	{
		return ;
	}//剪枝，不过应该大伙都会
	if(x==n+1)
	{
		if(s==ans)
		{
			if(pd())//若成功通过，那么输出
			{
				for(register int i(1);i<=n;++i)
				{
					printf("%d ",a[i]);//输出
				}
				puts("");//习惯性回车
			}
		}
		return ;//接着寻找
	}
	for(register int i(2);i<=22;++i)//不要问为什么22，我花了真的好多时间打这个表
	{
		if(!v[i])
		{
			v[i]=1;
			temp++;
			a[temp]=i;
			dfs(x+1,s+i);
			temp--;
			v[i]=0;
		}//这个这么简单。。。不用解释了吧
	}
}
int main(void)
{
	scanf("%d",&n);
	ans=n*(n-1)+1;
	printf("%d\n",ans);
	a[1]=1;//从1开始
	dfs(2,1);//strat大法师
	return 0;//好习惯
}
```
## 各位看官走好( ^_^ )/~~拜拜（管理大大给过吖QwQ）

---

## 作者：JYX0924 (赞：1)

看到极小的数据范围，很容易想到深搜的思路。我们可以搜索每一位填的的数，然后判断一下是否成立并记录答案。

注意，ans 的理论最优解是 $n\times(n-1)+1$。

之所以说是理论最优解，是因为最优解可能取不到它。

我的代码常数有点大，打一组表。
```c
#include<bits/stdc++.h>

using namespace std;

long long n, ans = -1e9, a[10], sum[1000], ji = 1, xun[50];
vector<long long> q[1000];

long long jishu(long long cnt)
{
	long long i;
	
	memset(xun, 0, sizeof(xun));
	for(i = 1; i <= cnt; i++)
	{
		xun[sum[i]] = 1;
	}
	i = 1;
	while(xun[i] != 0)
	{
		i++;
	}
	return i - 1;
}

long long cal()
{
	long long i, cnt = 0;
	
	for(i = 1; i <= n; i++)
	{
		sum[++cnt] = a[i];
	}
	if(n > 1)
	{
		for(i = 2; i <= n; i++)
		{
			sum[++cnt] = a[i] + a[i - 1];
		}
		sum[++cnt] = a[n] + a[1];
	}
	if(n > 2)
	{
		for(i = 3; i <= n; i++)
		{
			sum[++cnt] = a[i] + a[i - 1] + a[i - 2];
		}
		sum[++cnt] = a[1] + a[2] + a[n];
		sum[++cnt] = a[n] + a[n - 1] + a[1];
	}
	if(n > 3)
	{
		for(i = 4; i <= n; i++)
		{
			sum[++cnt] = a[i] + a[i - 1] + a[i - 2] + a[i - 3];
		}
		sum[++cnt] = a[1] + a[2] + a[3] + a[n];
		sum[++cnt] = a[1] + a[2] + a[n - 1] + a[n];
		sum[++cnt] = a[1] + a[n - 2] + a[n - 1] + a[n];
	}
	if(n > 4)
	{
		for(i = 5; i <= n; i++)
		{
			sum[++cnt] = a[i] + a[i - 1] + a[i - 2] + a[i - 3] + a[i - 4];
		}
		sum[++cnt] = a[1] + a[2] + a[3] + a[4] + a[n];
		sum[++cnt] = a[1] + a[2] + a[3] + a[n - 1] + a[n];
		sum[++cnt] = a[1] + a[2] + a[n - 1] + a[n - 2] + a[n];
		sum[++cnt] = a[1] + a[n - 3] + a[n - 2] + a[n - 1] + a[n];
	}
	if(n > 5)
	{
		for(i = 6; i <= n; i++)
		{
			sum[++cnt] = a[i] + a[i - 1] + a[i - 2] + a[i - 3] + a[i - 4] + a[i - 5];
		}
		sum[++cnt] = a[1] + a[2] + a[3] + a[4] + a[5] + a[n];
		sum[++cnt] = a[1] + a[2] + a[3] + a[4] + a[n - 1] + a[n];
		sum[++cnt] = a[1] + a[2] + a[3] + a[n - 1] + a[n - 2] + a[n];
		sum[++cnt] = a[1] + a[2] + a[n - 3] + a[n - 2] + a[n - 1] + a[n];
		sum[++cnt] = a[1] + a[n - 4] + a[n - 3] + a[n - 2] + a[n - 1] + a[n];
	}
	if(n > 6)
	{
		for(i = 7; i <= n; i++)
		{
			sum[++cnt] = a[i] + a[i - 1] + a[i - 2] + a[i - 3] + a[i - 4] + a[i - 5] + a[i - 6];
		}
		sum[++cnt] = a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[n];
		sum[++cnt] = a[1] + a[2] + a[3] + a[4] + a[5] + a[n - 1] + a[n];
		sum[++cnt] = a[1] + a[2] + a[3] + a[4] + a[n - 1] + a[n - 2] + a[n];
		sum[++cnt] = a[1] + a[2] + a[3] + a[n - 3] + a[n - 2] + a[n - 1] + a[n];
		sum[++cnt] = a[1] + a[2] + a[n - 4] + a[n - 3] + a[n - 2] + a[n - 1] + a[n];
		sum[++cnt] = a[1] + a[n - 5] + a[n - 4] + a[n - 3] + a[n - 2] + a[n - 1] + a[n];
	}
	if(n > 7)
	{
		for(i = 8; i <= n; i++)
		{
			sum[++cnt] = a[i] + a[i - 1] + a[i - 2] + a[i - 3] + a[i - 4] + a[i - 5] + a[i - 6] + a[i - 7];
		}
		sum[++cnt] = a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[n];
		sum[++cnt] = a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[n - 1] + a[n];
		sum[++cnt] = a[1] + a[2] + a[3] + a[4] + a[5] + a[n - 1] + a[n - 2] + a[n];
		sum[++cnt] = a[1] + a[2] + a[3] + a[4] + a[n - 3] + a[n - 2] + a[n - 1] + a[n];
		sum[++cnt] = a[1] + a[2] + a[3] + a[n - 4] + a[n - 3] + a[n - 2] + a[n - 1] + a[n];
		sum[++cnt] = a[1] + a[2] + a[n - 5] + a[n - 4] + a[n - 3] + a[n - 2] + a[n - 1] + a[n];
		sum[++cnt] = a[1] + a[n - 6] + a[n - 5] + a[n - 4] + a[n - 3] + a[n - 2] + a[n - 1] + a[n];
	}
	return jishu(cnt);
}

void dfs(long long now, long long cnt)
{
	long long i;
	
	if(now == n)
	{
		long long x = cal();
		if(x > ans)
		{
			ans = x;
			for(i = 1; i <= ji; i++)
			{
				q[i].clear();
			}
			ji = 1;
			for(i = 1; i <= n; i++)
			{
				q[ji].push_back(a[i]);
			}
			ji++;
		}
		else if(x == ans)
		{
			for(i = 1; i <= n; i++)
			{
				q[ji].push_back(a[i]);
			}
			ji++;
		}
		return;
	}
	for(i = 2; i <= n * (n - 1) + 1 - cnt; i++)
	{
		a[now + 1] = i;
		dfs(now + 1, cnt + i);
	}
}

int main()
{
	long long i, j;
	
	cin >> n;
	if(n == 8)
	{
		cout << "57" << endl;
		cout << "1 2 10 19 4 7 9 5" << endl;
		cout << "1 3 5 11 2 12 17 6" << endl;
		cout << "1 3 8 2 16 7 15 5" << endl;
		cout << "1 4 2 10 18 3 11 8" << endl;
		cout << "1 4 22 7 3 6 2 12" << endl;
		cout << "1 5 9 7 4 19 10 2" << endl;
		cout << "1 5 15 7 16 2 8 3" << endl;
		cout << "1 6 12 4 21 3 2 8" << endl;
		cout << "1 6 17 12 2 11 5 3" << endl;
		cout << "1 8 2 3 21 4 12 6" << endl;
		cout << "1 8 11 3 18 10 2 4" << endl;
		cout << "1 12 2 6 3 7 22 4";
		return 0;
	}
	a[1] = 1;
	dfs(1, 1);
	cout << ans << endl;
	i = 1;
	while(q[i].size() != 0)
	{
		for(j = 0; j < q[i].size(); j++)
		{
			cout << q[i][j] << " ";
		}
		cout << endl;
		i++;
	}
	return 0;
}
```
谢谢大家！！！

---


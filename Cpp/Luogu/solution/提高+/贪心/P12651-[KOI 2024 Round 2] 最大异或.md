# [KOI 2024 Round 2] 最大异或

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

在一个字符串中，选择一个或多个连续位置的字符，并保持其顺序排列后得到的字符串，称为该字符串的子字符串。  
例如，$\tt{001}$ 是字符串 $X = \tt{10011}$ 的子字符串，但不是字符串 $Y = \tt{10101}$ 的子字符串。

两个非负整数 $A$ 和 $B$ 的异或（XOR）$A \oplus B$ 定义如下：

- 从二进制的角度来看，若 $A$ 的第 $2^k$ 位与 $B$ 的第 $2^k$ 位不同，则 $A \oplus B$ 的第 $2^k$ 位为 1；若相同，则该位为 0。（其中 $k \ge 0$）
- 例如，$12 \oplus 10$ 的计算如下：  
  $12 = 1100_2$，$10 = 1010_2$，因此  
  $1100_2 \oplus 1010_2 = 0110_2 = 6$

给定一个仅由 0 和 1 组成、长度为 $N$ 的字符串 $S$。  
你需要计算从 $S$ 的子字符串 $s_1$ 和 $s_2$ 中可以构造出的 $g(s_1, s_2)$ 的最大值。函数 $g(s_1, s_2)$ 定义如下：

- 对于 $S$ 的子字符串 $s$，$f(s)$ 表示将 $s$ 视为二进制数后对应的十进制数值。例如，若 $s = 11010$，则 $f(s) = 26$。
- $g(s_1, s_2) = f(s_1) \oplus f(s_2)$

此处 $s_1$ 和 $s_2$ 不需要不同。换句话说，$s_1$ 和 $s_2$ 可以在 $S$ 中部分重叠，甚至可以是完全相同的字符串。

给定一个仅由 0 和 1 组成的字符串 $S$，请编写一个程序来计算可能的 $g(s_1, s_2)$ 的最大值。

## 说明/提示

**样例 1 说明**

在第一个测试用例中，将 $s_1 = 010$，$s_2 = 01$，可以得到 $g(s_1, s_2) = 11_2$。  
尽管也可以写作 $011_2$，但因为不能有无意义的前导 0，因此应输出 11，而不是 011。

在第四个测试用例中，将 $s_1 = 11111$，$s_2 = 1$，可以得到 $g(s_1, s_2) = 11110_2$。

**约束条件**

- 所有给定数均为整数。
- $1 \le T \le 100$
- $2 \le N \le 10^7$
- 所有测试用例中 $N$ 的总和 $\le 10^7$
- $S$ 是一个由 0 和 1 组成、长度为 $N$ 的字符串。

**子问题**

1. （17 分）$N \le 30$，所有测试用例中 $N$ 的总和 $\le 300$  
2. （20 分）$N \le 200$，所有测试用例中 $N$ 的总和 $\le 2000$  
3. （13 分）$N \le 3000$，所有测试用例中 $N$ 的总和 $\le 30000$  
4. （12 分）$N \le 2 \times 10^5$，所有测试用例中 $N$ 的总和 $\le 2 \times 10^6$  
5. （38 分）无额外约束条件

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
4
3
010
5
10101
5
00100
5
11111```

### 输出

```
11
11111
110
11110```

## 样例 #2

### 输入

```
4
2
00
2
01
2
10
2
11```

### 输出

```
0
1
11
10```

# 题解

## 作者：fish_love_cat (赞：5)

在写这题的时候突然意识到下划线都比我的代码来的可读（

---

容易发现 $S$ 的任意子串都不会超过 $S$，所以其中一个参与异或的数字必然是 $S$。

然后容易发现最大化异或出来的值等价于使前面的位尽可能大，所以可以不管后面的令前面的 $0$ 变成 $1$，并保持住前面原有的 $1$。

我们找到第一个 $0$，从前面连续的 $1$ 中选一个下来开始异或即可。

此时容易做到 $O(n^2)$，过不了。

但是我们发现大量的 $1$ 放下来可能会对后面造成冲突，于是从前面剪一段与当前连续 $0$ 长度相同的放过来异或即可。

这样就可以 $O(n)$ 了。

于是我们瞬秒了这一题？？？

实现上有些细节和特判，具体看代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
void solve(){
    int n;
    string s;
    cin>>n>>s;
    string flc;
    s=" "+s;
    bool flag=0;
    bool galf=0;
    for(int i=1;i<=n;i++){
        if(!(s[i]=='0'&&flc.size()==0))
        flc+=s[i],galf|=s[i]=='0';
        flag|=s[i]=='0';
    }
    if(!flag){
        for(int i=1;i<n;i++)putchar('1');
        puts("0");
        return;
    }
    if(!galf){
        if(!flc.size())flc="0";
        cout<<flc<<'\n';
        return;
    }
    flc=" "+flc;
    swap(flc,s);
    n=s.size()-1;
    int x=-1;
    for(int i=1;i<=n&&x==-1;i++)
    if(s[i]=='0')x=i-1;
    else cout<<"1";
    int qwq=x+1;
    int y=-1;
    for(int i=qwq;i<=n&&s[i]!='1';i++)y=i;
    if(x<=y-x)y=x+x;
    y-=x;x-=y;x++;
    for(int i=0;i+qwq<=n;i++)
    cout<<((s[i+qwq]+s[i+x])&1);
    cout<<"\n";
}
int main(){
    int t;
    cin>>t;
    while(t--)solve();
    return 0;
}
// 「为什么……为什么啊……」

// 激动的情绪立刻就干涸了。
// 吼声中断，变成轻微的呜咽。
// 大粒泪珠从眼角盈出，滴滴答答地落在腿上，裙摆留下湿痕。

// Nygglatho Astartus
```

---

## 作者：Reilher_lover (赞：2)

经典题，详细介绍每一档部分分的思路（我的思路）。

下文用 $s_{l\sim r}$ 表示 $s$ 的第 $l$ 到 $r$ 个字符构成的子串。

# 题意简述

给定一个长为 $n$ 的 $01$ 字符串 $s$，找出字符串的两个子串 $t_1,t_2$，使 $t_1,t_2$ 在二进制异或下的异或和最大，输出这个最大异或和的二进制形式。

# 思路分析

## $n\le 30$

显然是暴力枚举 $t_1,t_2$ 的左右边界，可以预处理出 $d_{i,j}$ 表示字符串 $s_{i\sim j}$ 转化为十进制对应的数字，预处理时间复杂度 $O(n^3)$。

枚举四个左右边界，用预处理的 $d_{i,j}$ 快速计算 $t_1,t_2$ 的异或和，找最优答案最后输出。

时间复杂度 $O(Tn^4)$，预计得分 $17$ 分。

## $n\le 300$

$O(n^4)$ 的做法显然过不了，不妨转变思考方向，寻找贪心策略。下文假设 $t_1$ 的长度大于 $t_2$ 的长度。

有一个经典的套路：**最大化二进制异或和，我们首先希望最大化异或和的位数，然后让和中第一个 $0$ 的位置尽可能靠后**。

因为 $t_1$ 的长度更大，所以 $t_1$ 的长度决定最后异或和的长度，不妨直接取 $t_1$ 为 $s_{l\sim n}$（$l$ 为 $s$ 中第一个 $1$ 出现的位置），这样一定可以最大化位数，然后我们 $O(n^2)$ 枚举 $t_2$ 的左右边界，$O(n)$ 来计算答案。

时间复杂度 $O(Tn^3)$，期望得分 $37$ 分。

## $n\le 2000$

$O(n^3)$ 的做法显然过不了，不妨顺着上一步的贪心思路，继续优化。

现在已经最大化位数了，接着需要使第一个 $0$ 的位置尽可能靠后。假设 $s$ 中 $l$ 后第一个 $0$ 的位置为 $p$，那么最优答案一定是使的在 $t_1$ 中前缀的 $1$ 都不变的情况下，使得 $t_1$ 的第一个 $0$ 被异或成 $1$ 。

思考一下取那些子串为 $t_2$ 可能变成最优决策？因为异或运算是向右对齐后逐位去算，所以要找到长度为 $n-p+1$，第一个数字为 $1$ 的子串，容易发现可以取到的字符串只有 $s_{l,l+n-p},s_{l+1,l+n-p+1},\dots,s_{p-1,n-1}$，这样的子串个数是 $O(n)$ 的，还是 $O(n)$ 计算答案。

时间复杂度 $O(Tn^2)$，期望得分 $50$ 分。

## $n\le 2\times 10^5$

不太理解这一档分存在的意义？

尝试取优化 $O(n)$ 的计算过程，对于两个可能成为最优子串的决策 $t',t''$，我们只需要通过比较这两个子串第一个不同的位置就可以知道那个更优了，可以通过字符串 Hash 加二分找的这个位置，然后一一取最优决策。

时间复杂度 $O(Tn\log n)$，期望得分 $62$ 分。

## $n\le 10^7$

正解。

回到最开始的贪心思路上，使第一个 $0$ 的位置尽可能靠后。我们找到从 $p$ 开始连续的 $0$ 的个数 $c$。

观察可能成为最优决策的子串，发现它们的不同在于前缀为 $1$ 个 $1$，前缀为 $2$ 个 $1$。直至前缀为 $p-l$ 个 $1$，我们可以用这个性质快速找出最优答案。

- $c\le p-l$：直接取前缀有 $c$ 个 $1$ 的决策即可，取得少了，$c$ 个 $0$ 无法全部消掉，显然不优；取得多了，$c$ 个 $0$ 后的 $1$ 又会被异或成 $0$，显然不优。

- $c>p-l$：直接取前缀有 $p-l$ 个 $1$ 的决策即可，正确性显然。

综上，我们只需统计几遍，然后 $O(n)$ 计算即可，时间复杂度 $O(Tn)$，期望得分 $100$ 分。

# Code

记得一些特判，这里仅仅给出正解代码。

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N=1e7+5;
int T,n,l,p,j;
char s[N],t[N];
void calc(int l1,int r1,int l2,int r2){
	int i,j;
	for(i=r1,j=r2;j>=l2;i--,j--)t[i-l1+1]=(s[i]==s[j]?'0':'1');
	for(;i>=l1;i--)t[i-l1+1]=s[i]; 
}
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		scanf("%s",s+1);
		for(l=1;l<=n;l++)if(s[l]=='1')break;
		if(l>n){
			printf("0\n");
			continue;
		}
		for(p=l+1;p<=n;p++)if(s[p]=='0')break;
		if(p>n){
			for(int i=l;i<n;i++)printf("%c",s[i]);
			if(l>1)printf("1\n");
			else printf("0\n");
			continue;
		}
		for(j=p;j<=n;j++)if(s[j]=='1')break;
		int cnt=min(j-p,p-l);
		calc(l,n,p-cnt,n-cnt);
		for(int i=1;i<=n-l+1;i++)printf("%c",t[i]);
		printf("\n");
	} 
	return 0;
} 
```
[record](https://www.luogu.com.cn/record/218914196)。

---

## 作者：CommandSR (赞：1)

## 题意

[link](https://www.luogu.com.cn/problem/P12651)

## 题解

首先显然要让位数更大，所以我们令 $s_1 = S$。接下来需要找一个字串 $s_2$ 最大化 $s_2 \oplus S$。

我们找到第一个 $1$ 的位置 $p$，$p$ 后面第一个 $0$ 的位置 $q$，$q$ 后面第一个 $1$ 的位置 $r$。那么 $[p,q)$ 是一段连续的 $1$，$[q,r)$ 是一段连续的 $0$。我们设 $x=q-p$，$y=r-q$。

若 $x\le y$，那么就把这串连续的 $1$ 尽可能多地填到后面那串 $0$ 中，新增加的 $1$ 的数量是 $x$。

若 $x>y$，那么就把那段连续的 $0$ 用 $1$ 填满，如果再往后填就要把 $1$ 变成 $0$ 了，所以新增加的 $1$ 的数量是 $y$。

根据上面的原则贪心即可。

考虑特殊情况：
1. 全是 $1$，把最后一个变成 $0$。
2. 全是 $0$ 输出 $0$。
3. 前面一串 $0$ 后面一串 $1$，即 $q$ 找不到，输出后面那串 $1$。

## Code

```cpp
// ----------------- Main Code -----------------
const int N = 1e7 + 5;
int n;
string s;
bool t[N];
void calc(int l1, int r1, int l2, int r2) {
	int i, j;
	for (i = r1, j = r2; j >= l2; --i, --j) t[i-l1+1] = (s[i] == s[j] ? 0 : 1);
	for (; i >= l1; --i) t[i-l1+1] = (s[i] == '1');
}
void RUF() {
	cin >> n >> s; s = " " + s;
	int cnt0 = 0, cnt1 = 0;
	F(i, 1, n) cnt0 += (s[i] == '0'), cnt1 += (s[i] == '1');
	if (!cnt1) { cout << "0\n"; return; }
	if (!cnt0) {
		F(i, 1, n-1) cout << 1;
		cout << "0\n";
		return;
	}
	int p = 1, q = -1, r = n + 1;
	F(i, 1, n) if (s[i] == '1') { p = i; break; }
	F(i, p, n) if (s[i] == '0') { q = i; break; }
	if (q == -1) {
		F(i, p, n) cout << 1;
		cout << '\n';
		return;
	}
	F(i, q, n) if (s[i] == '1') { r = i; break; }
	int cnt = min(q - p, r - q);
	calc(p, n, q - cnt, n - cnt);
	F(i, 1, n-p+1) cout << t[i]; cout << '\n';
}
int main() {
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	int T; cin >> T; F(czs, 1, T) RUF();
	return 0;
}
```

---

## 作者：Cwkapn (赞：1)

## 题意简述
给定一个整数的二进制形式 $S$，要选出两个子串 $s_1,s_2$ 使得这两个子串进行异或操作后的值最大。

## 题目分析
首先考虑 $3$ 种特殊情况：
1. $S$ 中的所有位都是 $0$。此时答案显然为 $0$。
2. $S$ 中的所有位都是 $1$。根据异或的定义，答案为 $S$ 是不可能的，因为需要有 $0$ 才能使所有位都不变。根据贪心的思想，答案要尽可能大需要让高位（靠左侧的位）尽可能大，所以将 $S$ 与 $1$ 求异或使得最低位变为 $0$。
3. $S$ 形如 $00000011111$，即高位均为 $0$ 低位均为 $1$。因为不可能让原本为 $0$ 的位变为 $1$，所以此时答案不可能大于 $S$。于是将 $S$ 与 $0$ 求异或使得答案为 $S$。

现在考虑一般情况。上面的特殊情况启示了使用贪心法解决这道题，即尽可能使高位为 $1$。由此可以看出 $s_1$ 与 $s_2$ 必然有其一是 $S$。为了方便讨论，不妨设 $s_1=S$。

注意到，刚才的贪心思路等价于，使从左到右的第一个 $0$ 尽可能靠右。因此要尽可能填补 $s_1$ 中的 $0$。

设去掉前导 $0$ 后，第一次出现的连续 $1$ 个数为 $x$，第一次出现的连续 $0$ 个数为 $y$。显然这 $y$ 个 $0$ 只能用 $x$ 个 $1$ 中的一些填补。如果 $x \le y$，则用 $x$ 个 $1$ 填补 $y$ 个 $0$ 中所在位更高的 $x$ 个即可；反之，则应将多余的 $y-x$ 个 $1$ 去掉，防止将后面的 $1$ 变为 $0$。

综上，需要找到从左到右第一个连续的 $\min(x,y)$ 个 $1$ 作为 $s_2$ 的起始部分。接下来即可直接得到完整的 $s_2$。这个方法的时间复杂度为 $\mathcal{O}(n)$。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
char t[10000007];
int n;
int main() {
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	int _;
	cin >> _;
	while (_--) {
		cin >> n >> s;
		s = "#" + s;
		bool all0 = true, all1 = true;
		for (int i = 1; i <= n; i++) {
			if (s[i] == '0') all1 = false;
			if (s[i] == '1') all0 = false; 
		}
		if (all0) {
			cout << "0\n";
			continue;
		} else if (all1) {
			for (int i = 1; i < n; i++) cout << '1';
			cout << "0\n";
			continue;
		}
		int p = 1;
		for (int i = 1; i <= n; i++) if (s[i] == '1') {p = i; break;}
		int q = -1;
		for (int i = p + 1; i <= n; i++) if (s[i] == '0') {q = i; break;}
		if (q == -1) {
			for (int i = p; i <= n; i++) cout << '1';
			cout << '\n';
			continue;
		}
		int r;
		for (r = q; r <= n; r++) {
			if (s[r] == '1') break;
		}
		int x = q - p, y = r - q;
		int cnt = min(x, y);
		int la = p, ra = n, lb = q - cnt, rb = n - cnt;
    	for (int i = ra, j = rb, k = ra - la + 1; i >= la && j >= lb && k >= 1; i--, j--, k--) t[k] = (s[i] != s[j]) ? '1' : '0';
    	for (int i = ra - (rb - lb + 1), k = ra - la + 1 - (rb - lb + 1); i >= la && k >= 1; i--, k--) t[k] = s[i];
		for (int i = 1; i <= n - p + 1; i++) cout << t[i];
		cout << '\n';
	}
	return 0;
} 
```

---

## 作者：_H17_ (赞：0)

## 题目分析

我们考虑让尽量高的位置为 $1$，所以这个串从第一次出现 $1$ 的位置到末尾的这个子串一定要选。

接下来我们要尽量填补这个串靠前的 $0$（如果没有 $0$ 分两种情况，在第一个 $1$ 前有 $0$ 那就异或 $0$，不然只能异或 $1$）。

第一个 $1$ 之后最靠前的 $0$ 怎么填补？显然我们取的第二个子串长度至少能到这个位置，那就需要用这个位置前的 $1$ 来补。假设一开始连续了 $a$ 个 $1$，后面有 $b$ 个 $0$。如果 $b\ge a$，那就把 $1$ 尽量补到这些更靠前的 $0$ 来；如果 $b<a$，我们把最靠后的 $b$ 个 $1$ 补到空位来保证不影响前面的 $1$，同时也不影响后面的 $1$。

这样保证了最开头的 $1$ 一定被选的情况下，尽量选取更多的 $0$ 变成 $1$。

时间复杂度 $O(T\times n)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,hav1,hav0,len0,len1;
string s;
void Main(){
    hav1=hav0=len0=len1=0;
    cin>>n>>s;
    s=" "+s;
    for(int i=1;i<=n;i++){
        if(s[i]=='1')
            hav1=1;
        else
            hav0=1;
    }
    if(!hav1){
        cout<<"0\n";
        return;
    }
    else if(!hav0){
        for(int i=1;i<=n;i++)
            cout<<"10"[i==n];
        cout<<'\n';
        return;
    }
    for(int i=1;i<=n;i++){
        if(s[i]=='1'){
            s=s.substr(i,s.size()-i);
            s=" "+s;
            break;
        }
    }
    n=s.size()-1,hav0=0;
    for(int i=1;i<=n;i++)
        if(s[i]=='0'){
            hav0=i;
            break;
        }
    if(!hav0){
        for(int i=1;i<=n;i++)
            cout<<s[i];
        cout<<'\n';
        return;
    }
    for(int i=hav1;i<=n;i++){
        if(s[i]=='1')
            len1++;
        else
            break;
    }
    for(int i=hav0;i<=n;i++){
        if(s[i]=='0')
            len0++;
        else
            break;
    }
    if(len0>=len1){
        for(int i=1;i<=len1;i++)
            cout<<s[i];
        for(int i=len1+1,j=1;i<=n;i++,j++)
            cout<<(char(((s[i]^48)^(s[j]^48))^48));
        cout<<'\n';
    }
    else{
        for(int i=1;i<=len1;i++)
            cout<<s[i];
        for(int i=len1+1,j=len1-len0+1;i<=n;i++,j++)
            cout<<(char(((s[i]^48)^(s[j]^48))^48));
        cout<<'\n';
    }
    return;
}
int main(){
    for(cin>>T;T;--T)
        Main();
    return 0;
}
```

---


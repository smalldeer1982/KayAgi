# [KOI 2022 Round 2] 食事计划

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

在 KOI 国家，铁柱所在的地方有 $N$ 个餐厅。每个餐厅只售卖一种食物，食物的类型通过整数 $A_i$ 来表示，$i$（$1 \leq i \leq N$）。

铁柱计划访问所有的餐厅，并为自己制定一个食事计划。铁柱的食事计划可以用从 $1$ 到 $N$ 的整数排列 $P$ 来表示。举例来说，如果 $P = [2, 4, 3, 1]$，这意味着铁柱将依次访问餐厅 2、4、3 和 1。

由于铁柱不希望连续吃相同类型的食物，所以在他的食事计划中，连续的两个餐厅必须提供不同类型的食物。也就是说，对于 $i = 1, 2, \dots, N-1$，$A_{P_i} \neq A_{P_{i+1}}$ 必须成立，而符合这一条件的食事计划被称为合法食事计划。

例如，假设 $N = 9$，且提供的食物类型是 $A = [1, 1, 1, 2, 2, 3, 3, 4, 3]$，则如果铁柱的食事计划是 $P = [3, 4, 1, 5, 6, 2, 7, 8, 9]$，那么计划中的每两个相邻餐厅的食物类型都不同，符合条件。

若铁柱的食事计划是 $P = [1, 4, 2, 5, 6, 3, 7, 8, 9]$，这也是一个合法的食事计划，并且是按字典顺序最前的合法计划。

然而，若食物类型是 $A = [1, 1, 1]$，无论怎样安排食事计划，都无法满足“连续两餐不同类型”的要求。

当给定 $N$ 个餐厅的食物类型时，如果无法制定合法的食事计划，则输出 `-1`；否则，输出字典序最前的合法食事计划。

## 说明/提示

**约束条件**

- $1 \leq N \leq 300\,000$
- $1 \leq A_i \leq N$

**子任务**

1. （5 分）$N \leq 8$
2. （12 分）$N \leq 20$
3. （32 分）$N \leq 5\,000$
4. （51 分）无额外约束条件

## 样例 #1

### 输入

```
9
1 1 1 2 2 3 3 4 3```

### 输出

```
1 4 2 5 6 3 7 8 9```

## 样例 #2

### 输入

```
3
1 1 1```

### 输出

```
-1```

# 题解

## 作者：Mirasycle (赞：2)

超级简单题。

首先如何判定合法？找到序列众数，只要其出现次数 $\le \lceil\dfrac{n}{2} \rceil$，就必然合法，不需要考虑出现次数次大的数之类的，因为我们只要交替排列就必然是一种合法的方案。

于是推广一下，假设我们已经填入了一段前缀，那么如果长度为 $k$ 的后缀中众数出现次数 $\le \lceil\dfrac{k}{2} \rceil$ 就必然能继续往后面填。

由于本题是字典序，所以我们按位贪心，一位一位填。首先一个决策点是与上一个位置中的 $a$ 不相同的数中位置最小的数，但是我们不能直接填这个，因为填完之后可能会造成后缀不满足上一段的判定要求。

于是我们就先判断一下如果这个数不填众数，后面会不会不合法，使用 ` std::set ` 维护剩余数中的众数。每次找到众数如果这个位置不填它的话，后续位置不能满足上述要求就填它，注意如果是多个众数的话需要取位置字典序最小的。否则我们就填位置字典序最小的点。

时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
const int maxn=3e5+10;
void cmax(int &x,int y){ x=x>y?x:y; }
void cmin(int &x,int y){ x=x<y?x:y; }
struct node{
	int c,pos,x;
	bool operator < (const node &rhs) const{ return c>rhs.c||(c==rhs.c&&pos<rhs.pos); }
};
int a[maxn],cnt[maxn],cur[maxn];
int lst[maxn],nxt[maxn],col,n;
set<node> s1; set<pair<int,int> > s2;
set<pair<int,int> >::iterator it;
void op(int x){
	cout<<cur[x]<<" "; col=x;
	s1.erase((node){cnt[x],cur[x],x}); s2.erase(mp(cur[x],x));
	cnt[x]--; if(!cnt[x]) return ;
	cur[x]=nxt[cur[x]]; s1.insert((node){cnt[x],cur[x],x}); s2.insert(mp(cur[x],x));
}
int main(){
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i]; cnt[a[i]]++;
		if(lst[a[i]]) nxt[lst[a[i]]]=i;
		else cur[a[i]]=i;
		lst[a[i]]=i; 
	}
	for(int i=1;i<=n;i++)
		if(cnt[i]) s1.insert((node){cnt[i],cur[i],i});
	for(int i=1;i<=n;i++)
		if(cur[i]) s2.insert(mp(cur[i],i));
	if((*s1.begin()).c>(n+1)/2){ cout<<"-1"; return 0; }
	for(int i=1;i<=n;i++){
		node z=*s1.begin();
		if(z.c>(n-i+1)/2) op(z.x);
		else{
			it=s2.begin();
			if((*it).se!=col) op((*it).se);
			else{ ++it; op((*it).se); }
		}
	}
	return 0;
}
```

---

## 作者：Eason2009 (赞：1)

根据经典结论：无解当且仅当原序列所有的数出现次数都不大于原序列长的一半上取整。证明大概就是考虑将出现次数最多的数与出现次数最少的数两两配对。

考虑怎么最小化某个后缀的字典序，若存在某个数出现次数大于剩余后缀长的一半，要想使得有解，只能填这个数，先判掉这种情况。可以用 set 维护每种数的出现次数，只考虑最大值即可（因为一个序列最多只有一个绝对众数）。

否则我们可以自由填数（因为这不会使无解条件成立），只需保证当前数与前一个数不同即可。有很多种维护做法，我这里偷懒使用了线段树套 set 维护最小位置，具体的，以数的种类为下标，每个叶子节点开个 set 维护原序列中该数的下标集合，填入某个数时等价于删除一个下标，在对应的 set 里删除即可。

时间复杂度：$O(n\log^2n)$。


```cpp
    cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],cnt[a[i]]++,upd(1,1,n,a[i],i);
	for(int i=1;i<=n;i++) s.insert({cnt[a[i]],a[i]}),upd(1,1,n,i,n+1);
	for(int i=1;i<=n;i++)
	{
		if((*s.rbegin()).fi>(n-i+1)/2)
		{
			pii u=*s.rbegin();
			s.erase(u);
			col[i]=u.se;
			s.insert({u.fi-1,u.se});
			ans[i]=qry(1,1,n,u.se,u.se);
			del(1,1,n,u.se,ans[i]);
			cnt[u.se]--;
			continue;
		}
		int p=min(qry(1,1,n,1,col[i-1]-1),qry(1,1,n,col[i-1]+1,n));
		ans[i]=p;
		col[i]=a[p];
		del(1,1,n,a[p],p);
		pii u=*s.find({cnt[a[p]],a[p]});
		s.erase(u);
		s.insert({u.fi-1,u.se});
		cnt[a[p]]--;
	}
```

---


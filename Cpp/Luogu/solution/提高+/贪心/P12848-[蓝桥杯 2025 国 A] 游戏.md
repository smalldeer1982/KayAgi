# [蓝桥杯 2025 国 A] 游戏

## 题目描述

小蓝正在进行一个游戏。这个游戏有 $n$ 个槽位和 $n-1$ 个石块，初始时第 $n$ 个槽位是空的，其余每个槽位都有一个石块，对于两个相连的槽位 $u, v$，若 $u$ 是空的，那么小蓝可以将 $v$ 里的石块移到 $u$ 中。开始时，对于任意的 $1 \leq i < n$，第 $i$ 个槽位和第 $i+1$ 个槽位是相连的。游戏的最终目的是将每一个编号为 $i$ 的石块移动到编号为 $i$ 的槽位中。

小蓝在经过几次简单的尝试后发现，这个游戏并不一定有解，但好在他可以花费 1 的代价，任选两个槽位使它们相连。小蓝希望你帮他求出，至少要花费多少的代价，能够让这个游戏有解。

## 说明/提示

**【样例说明】**

小蓝可以令槽位 1 和槽位 5 相连，然后将石块 4 移动到槽位 5，将石块 1 移动到槽位 1，将石块 2 移动到槽位 2，将石块 3 移动到槽位 3，将石块 4 移动到槽位 4，即可完成游戏的目标。

**【评测用例规模与约定】**

对于 30% 的评测用例，$n \leq 5$；

对于 50% 的评测用例，最小代价不超过 1；

对于所有评测用例，$1 \leq n \leq 3 \times 10^5$，$1 \leq a_i < n$。

## 样例 #1

### 输入

```
5
4 1 2 3```

### 输出

```
1```

# 题解

## 作者：InterRiver (赞：5)

关于本题，有一个重要的结论：答案一定不超过 $2$，评测用例规模与约定中隐约暗示了这一点。

该结论的证明如下：

+ 若 $n < 3$，结论显然正确。

+ 若 $n \ge 3$，在 $(1, n)$ 间连一条边，在 $(n - 2, n)$ 间连一条边。于是游戏一定有解：
  + $(1, n)$ 的边可以用于将整个序列循环移位：全体序列向右移动一次，然后将位置 $n$ 的石块移动到位置 $1$。
  + $(n - 2, n)$ 的边可以用于将 $n - 2$ 位置和 $n - 1$ 位置的石块互换位置，实际上就是一个长度为 $2$ 的循环移位。
  + 基于上述两种操作，我们可以实现交换任意两个相邻的石块的操作。只需将它们循环位移到最后，然后交换即可。
  + 能交换任意两个相邻元素意味着可以对任意序列进行排序。

既然答案有且仅有 $0, 1, 2$，我们可以分类讨论：

答案为 $0$ 当且仅当序列已经有序，因为不加边就不能改变序列。

否则，答案为 $1$ 当且仅当存在一个区间，对其进行循环位移后全体序列有序。

+ 充分性：令该区间为 $[x, y]$，我们可以连接 $(x, y + 1)$，将 $[y + 1, n - 1]$ 区间的石块右移一次，然后对目标区间做循环移位。
+ 必要性：对于我们连接的一条边 $(x, y)$，$[1, x - 1]$ 和 $[y, n - 1]$ 位置的石块不可能改变在序列中的位置，且 $[x, y - 1]$ 区间内只能够循环移位。
+ 如何找到这个可能的区间呢？区间外一定有 $a_i = i$，区间内一定有 $a_i \ne i$，只要找到第一个和最后一个位置不正确的石块，检查该区间是否可以通过循环移位变得有序即可。

否则答案为 $2$。

---

## 作者：fish_love_cat (赞：1)

那很 Ad-hoc 了。

---

容易发现不加边数之间的相对顺序不会改变，所以答案为 $0$ 当且仅当原数列升序。

---

不容易发现答案至多为 $2$。

考虑构造。

我们将 $(1,n)$ 连边形成一个环，然后把 $(1,n-1)$ 连边。

于是这样就有了交换相邻数字的功能。

冒泡即可。

---

不容易发现环是可以将一个区间的数循环移动的。

那么如果可以通过循环右移某一个区间完成排序，代价只为 $1$。

---

分讨完了，做完了。实际上你只需要发现答案上界这题就没难度了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int b[300005];
int a[600005];
int main(){
    int n;
    cin>>n;
    if(n<=2){
        cout<<0;
        return 0;
    }
    for(int i=1;i<n;i++)
        cin>>b[i];
    int l,r;
    for(int i=1;i<n;i++)
        if(i!=b[i]){
            l=i;
            break;
        }
    for(int i=n-1;i;i--)
        if(i!=b[i]){
            r=i;
            break;
        }
    for(int i=1;l<=r;i++,l++)
        a[i]=b[l],n=i;n++;
    for(int i=1;i<n;i++)a[i+n-1]=a[i];
    for(int i=2,sum=0;i<=n*2-2;i++){
        if(a[i]>a[i-1])sum++;
        else sum=0;
        if(sum==n-2){
            cout<<(i>n-1);
            return 0;
        }
    }
    cout<<2;
    return 0;
}
```

---

## 作者：SafariMo (赞：1)

> 结论：答案不超过 $2$。

 考虑构造。
 
 先连边 $(1,n)$。此时 $1 \sim n$ 构成了一个环。然后连边 $(3, n)$，此时可以交换 $(2 , 3)$。

不断操作后可以成功排序。

现在仅需判断答案是否为 $0 , 1$。

- 答案为 $0$ 当且仅当 $a_i = i$。
- 答案为 $1$ 时，说明连边 $(L , R)$ 即可，$L$ 为满足 $a_i \ne i$ 的最小的 $L$，$R$ 为满足 $a_i \ne i$ 的最大的 $R$，判断是否可行是简单的。

[Submission](https://www.luogu.com.cn/record/220747657)

---


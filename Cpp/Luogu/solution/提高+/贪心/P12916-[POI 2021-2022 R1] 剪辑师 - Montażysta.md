# [POI 2021/2022 R1] 剪辑师 / Montażysta

## 题目背景

翻译来自于 [LibreOJ](https://loj.ac/p/4103)。

## 题目描述

**题目译自 [XXIX Olimpiada Informatyczna – I etap](https://sio2.mimuw.edu.pl/c/oi29-1/dashboard/) [Montażysta](https://sio2.mimuw.edu.pl/c/oi29-1/p/mon/)**

Bajtazar 接手了剪辑 $n$ 部关于 POI 题目讲解的视频的任务。已知剪辑第 $i$ 部视频需要 $t_{i}$ 天，并且必须在第 $d_{i}$ 天之前发布。Bajtazar 有光纤网络，所以剪辑好的视频可以立即上传到服务器上。但是剪辑过程非常耗费硬件资源，而 Bajtazar 只有一台电脑，所以他一次只能剪辑一部视频。

视频很多，Bajtazar 担心他不能按时完成所有的任务。请你帮助他，计算出如果他最早可以在第 $1$ 天开始剪辑，他最多能按时发布多少部视频。为了让 Bajtazar 更有信心，你还需要给出一个具体的工作计划，说明如何达到这个结果。

## 说明/提示

**附加样例**

1. 该样例满足 $n=1000 ; t_{i}=5 \cdot 10^{8}, d_{i}=i \cdot 10^{6}$。答案是 $2$。
2. 该样例满足 $n=1000 , t_{i}=2, d_{i}=1999$。答案是 $999$。
3. 该样例满足 $n=5\cdot 10^5, t_{i} \in\{1,2,3\}, d_{i}=10^{9}$。答案是 $5\cdot 10^5$。

详细子任务附加限制及分值如下表所示。如果你的程序正确地输出了 $m$，而方案不正确，你将获得该测试点 $50 \%$ 的分数。

| 子任务编号 | 附加限制 | 分值 |
| :---: | :--: | :---: |
| $1$ | $n \leq 10$ | $20$ |
| $2$ | $n \leq 1000$ | $30$ |
| $3$ | $t_{i}, d_{i} \leq 10^{6}$ | $20$ |
| $4$ | 无附加限制 | $30$ |

## 样例 #1

### 输入

```
5
4 5
2 4
5 3
1 9
3 10```

### 输出

```
3
2 3
4 7
5 8```

# 题解

## 作者：FS_NEO (赞：3)

反悔贪心模板题。

维护一个按任务用时排序的大根堆，保存当前选中的任务。

将任务按照发布期限排序，若当前状态下该任务可以完成，则钦定任务完成，并扔进堆中；否则取出堆顶，若当前任务用时比堆顶短，则弹出堆顶，将该任务塞进去。容易证明这是优的。

题目要求打印方案，于是在循环结束后，取出堆中所有元素，即为选中的任务。

Code:

```cpp
/*

  2025.6.26

 * Happy Zenith noise *

*/
#include<bits/stdc++.h>
#define int long long
#define fi first
#define se second
#define pb push_back
using namespace std;
typedef pair<int,int>P;
const int MAXN=1000005;
struct node{
	int w,t,id;
}a[MAXN],b[MAXN];
int n,s,ans;
priority_queue<P>q;
bool cmp(node x,node y){return x.t<y.t;}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].w>>a[i].t,a[i].id=i;
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++){
		if(s+a[i].w<=a[i].t){
			s+=a[i].w;ans++;
			q.push({a[i].w,i});
		}
		else if(!q.empty()){
			P tmp=q.top();
			if(tmp.fi>a[i].w)q.pop(),s=s-tmp.fi+a[i].w,q.push({a[i].w,i});
		}
	}	
	cout<<ans<<"\n";s=1,ans=0;
	while(!q.empty())b[++ans]=a[q.top().se],q.pop();
	sort(b+1,b+1+ans,cmp);
	for(int i=1;i<=ans;i++)cout<<b[i].id<<" "<<s<<"\n",s+=b[i].w;
    return 0;
}
```

---

## 作者：fish_love_cat (赞：2)

五倍经验：P12916，P11457，P11328，P4053，AT_cf17_final_d

---

每个任务有一个截止时间，于是有贪心思路，让截止时间急的优先完成。

但这是错的，有一个完不成了，那么无论如何都会少一个任务，于是不一定舍弃当前任务，可以贪心的找一个前面很长的任务扔掉节约时间。

于是套一个优先队列，做完了。

方案把优先队列里面的按原顺序排回去，然后统计开始时间就行。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct fish{
    int fix,ed;
    bool operator <(const fish &x)const{
        return fix<x.fix;
    }
    int id,st;
}a[1500005];
bool cmp(fish x,fish y){
    return x.ed<y.ed;
}
priority_queue<fish>q;
int sum;
vector<fish>ans;
signed main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    cin>>a[i].fix>>a[i].ed,a[i].id=i;
    sort(a+1,a+1+n,cmp);
    for(int i=1;i<=n;i++){
        a[i].st=sum+1;
        sum+=a[i].fix;
        q.push(a[i]);
        while(sum>a[i].ed)
        sum-=q.top().fix,q.pop();
    }
    cout<<q.size()<<'\n';
    int st=1;
    while(!q.empty())ans.push_back(q.top()),q.pop();
    sort(ans.begin(),ans.end(),cmp);
    for(int i=0;i<ans.size();i++)cout<<ans[i].id<<' '<<st<<'\n',st+=ans[i].fix;
    return 0;
}
```

---

## 作者：er_mao_jpg (赞：0)

## P12916 [POI 2021/2022 R1] 剪辑师 / Montażysta 题解
题目传送门：[题解：P12916 [POI 2021/2022 R1] 剪辑师 / Montażysta](https://www.luogu.com.cn/problem/P12916) 。

### 闲话

从 [P4053 [JSOI2007] 建筑抢修](https://www.luogu.com.cn/problem/P4053) 的多倍经验来的，思路一样，做了本题的可以过去看看。

### 题意大意

有 $n$ 个视频。第 $i$ 个视频可以用 $t_i$ 和 $d_i$ 来描述。制作第 $i$ 个视频需要 $t_i$ 天，要在第 $d_i$ 天结束前做完。

从第 $1$ 天开始工作，问最多可以做多少个视频。

### 思路分析
和 [P4053 [JSOI2007] 建筑抢修](https://www.luogu.com.cn/problem/P4053) 一样，是一个反悔贪心，只不过多了一个方案输出。

贪心策略如下。

设当前的天数为 $now$。因为每个视频对答案提供的价值都最多为 $1$ 而截止时间早的视频在时间增加的过程中会越早不能提供价值，所以我们先做截止时间早的视频。我们就以截止时间 $d_i$ 为关键字将视频从小到大排序。

当目前视频制作数 $ans$ 一定时，我们还是想让 $now$ 尽量小一点。从这一点就可以想出反悔机制：做到第 $i$ 个视频时，如果时间充裕 $t_i + now \le d_i$，我们就做这个视频，$ans + 1$，并将这个视频加入以花费时间 $t_i$ 为关键字的大根堆中；如果 $ t_i + now > d_i$，那么取出大根堆的堆顶，将当前视频替换掉在堆顶的视频，$now$ 减去堆顶，再将本视频存入大根堆里，$ans$ 值不变。

如此将 $n$ 个视频都扫一遍，就可以得出答案 $ans$。

还存在优先队列里的视频，就是我们选出来要做的视频，我们将队里的视频取出，以截止时间 $d_i$ 为关键字对这些视频从小到大排序，然后按顺序输出即可。

其余细节实现请见代码。
### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

long long n, ans, now;
long long a, b;
struct node{
	long long idx, t, d;//分别为视频编号，花费时间，截止时间
	bool operator < (const node &er_mao)const{//以花费时间为关键字从大到小排序
		return er_mao.t > t;
	}
}num[600010];
long long cnt;
priority_queue <node> q; //优先队列实现大根堆维护花费时间

bool cmp(node x, node y){//以截止时间为关键字从小到大排序
	return x.d < y.d;
}
int main(){
	ios::sync_with_stdio(false);//解绑操作，加快输入输出速度
	cin.tie(0);
	cout.tie(0);
    
	cin >> n;//输入
	for(int i = 1; i <= n; i++){
		cin >> num[i].t >> num[i].d;
		num[i].idx = i;//别忘记将编号也存起来，因为输出时要输出编号
	}
	
	sort(num + 1, num + 1 + n, cmp);//排序
    
	for(int i = 1; i <= n ;i++){
		now += num[i].t;//先选这一个视频
		q.push(num[i]);
        
		if(now <= num[i].d){//时间足够做完这个视频
			ans++;
		}else{//反悔操作
			now -= q.top().t;//丢掉花费时间最长的视频
			q.pop();
		}
	}
    
	while (!q.empty()){//还在队列里的就是选出的视频
		cnt++;
		num[cnt] = q.top();
		q.pop();
	}
    now = 1; //因为是从第一天开始，所以now设为1
	sort(num + 1, num + 1 + cnt, cmp);//将选出的视频以截止时间为关键字排序
    
	cout << ans << '\n';//输出视频个数
	for(int i = 1;  i <= cnt; i++){//输出方案
		cout << num[i].idx << " " << now << '\n';
		now += num[i].t;
	}
	return 0;
} 
```
### 写在最后
帮到你的话请点赞题解喵，点赞题解谢谢喵

---

## 作者：zhuangzhihe (赞：0)

与这题十分类似：[P4053 建筑抢修](https://www.luogu.com.cn/problem/P4053)，感兴趣可以先去做一下。

第一眼观看时，可以看出，这道题应该与每项工作的紧急程度有关。因为显而易见的，如果一项工作完成后还可以完成其他的工作，但其它工作完成后就不能再完成这项工作了，我们应当先完成这项工作。

举个例子，假设我们现在已经耗费了 $100000$ 的时间，工作 $a$ 的截止开始时间为 $114514$，工作所需时间为 $2$，工作 $b$ 的截止开始时间为 $123456$，工作所需时间为 $20000$，此时如果先完成 $b$，时间就变成 $120000$，此时无法再完成 $a$。但如果先完成 $a$，此时时间变为 $100002$，我们仍有充足的时间去完成 $b$。所以可以得出结论，我们一般应当先完成最紧急的任务。

然而“紧急”是如何定义的呢？我们可以先猜想，截止开始时间越早，这项工作就越紧急。然而很快可以给出反例。

假设我们现在已经耗费了 $100000$ 的时间，工作 $a$ 的截止开始时间为 $114514$，工作所需时间为 $2$，工作 $b$ 的截止开始时间为 $114513$，工作所需时间为 $20000$，此时如果先完成 $b$，时间就变成 $120000$，此时无法再完成 $a$。但如果先完成 $a$，此时时间变为 $100002$，我们仍有充足的时间去完成 $b$。

上面这个例子仅仅是在开头的例子上将 $b$ 的截止开始时间修改为了 $114513$，此时会发现，我们仍然是先完成 $a$ 更划算，但此时 $b$ 的截止开始时间显然比 $a$ 更早，因此我们的猜想被推翻了。

然而再观察这个例子，我们可以发现它的截止结束时间就是他的截止开始时间加上它的所需完成时间，也就是说，在这个截止结束时间之前，你必须要完成这项工作，而不是开始你的工作。

我们继续猜想，会不会一项工作的紧急程度是由截止结束时间决定的呢？观看上面两个例子，会发现该结论在上述例子中均成立。那么我们再使用数学证明。

设两个工作截止开始时间为 $s_i$ 与 $s_j$，完成所需时间为 $t_i$ 与 $t_j$，当前已耗费的时间为 $time$，如果我们的最优选择方式为先完成工作 $i$ 再完成工作 $j$，也就是说先完成工作 $i$ 能完成工作 $j$，反之则不行，那么显然有两个不等式，分别是 $time+t_i\le s_j$ 与 $time+t_j>s_i$。

将第一个式子两边各加上 $t_j$，第二个式子两边同加上 $t_i$，可以得到 $time+t_i+t_j\le s_j+t_j$ 与 $time+t_j+t_i>s_i+t_i$，发现此时两个式子的左边相同，利用不等式的传递性可得 $s_j+t_j>s_i+t_i$，显然，我们可以将之理解为，如果先完成工作 $i$ 能完成工作 $j$，反之不行，那么工作 $i$ 的截止结束时间一定早于工作 $j$，也就是一般来说，我们应当先完成截止结束时间较早的工作。

所以，我们可以给每项工作按照截止结束时间升序排序，然后依次处理，确认是否完成这项工作。

然而，这个结论在面对一大堆工作时会出问题。我们的结论仅适用于先完成 $i$ 时能完成 $j$，反之不行的情况。如果两个工作一定冲突，我们该选谁呢？很显然，我们应当选择消耗时间较少的而非截止结束时间较早的。

有时也许由于我们的贪心，在前面选择了一个截止结束时间较早但耗时大于当前工作的，并且此时时间不够我们完成这项工作了，那么这就是前面所说的两个工作一定冲突的情况了。我们应当舍弃前面那个耗时较大的而选择现在这个。但如果前面耗时反而更小，那么我们就不用管，就当无事发生。

这样一种思路我们当然可以用大根堆来维护。我们先处理最紧急的，并依次往越来越不紧急的顺序去处理，每次处理时先将这次工作的耗时放进大根堆，如果时间充足就先完成这项工作，否则我们弹出之前耗时最长的工作，也就是大根堆的堆顶，然后再来完成这项工作。当然，如果这项工作本身就是耗时最长的，由于前面我们已经将它放入大根堆中，所以会直接将它自己弹出。然后再修改当前工作时间。

这时也许有同学要问，如果这项工作的耗时会导致工作时间不够怎么办？这种情况我们其实完全不用担心。因为我们是按照紧急程度升序排序后再处理的。凡是放入大根堆的，都一定是我们已经完成的工作。已完成的工作显然在此次工作之前处理，也就是说它的截止结束时间较早，在截止结束时间较早，且它的耗时大于我们当前工作的耗时的情况下，显然如果这项工作能完成，那么放弃这项工作去完成当前工作也是没有问题的。

都讲到这里了，思路已经十分清晰，输出方案即可。接下来代码也很好实现了。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define N 1000005
int n,ans,t;
struct node{
    int first,second,id;
}a[N],b[N];
priority_queue<pair<int,int> > q;
bool cmp(node x,node y){
    return x.first<y.first;
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i].second>>a[i].first,a[i].id=i;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		q.push({a[i].second,i});
		if(t+a[i].second<=a[i].first){
			ans++;
			t+=a[i].second;
		}else{
			t+=(a[i].second-q.top().first);
			q.pop();
		}
	}
	cout<<ans<<'\n';
    ans=0;t=1;
    while(q.size()) b[++ans]=a[q.top().second],q.pop();
    sort(b+1,b+1+ans,cmp);
    for(int i=1;i<=ans;i++){
        cout<<b[i].id<<" "<<t<<'\n';
        t+=b[i].second;
    }
	return 0;
}
```

---

## 作者：dangerous_DZR (赞：0)

~~这道题无非就是[建筑抢修](https://www.luogu.com.cn/problem/P4053)加了个求方案吗？~~
## 分析
考虑贪心，肯定要先做期限短的，若当前时间不够就做一个期限相对较长但耗时短一点的视频。

但是这样只能算出能发布的视频数量，怎么求方案呢？

已知我们排序时的第一关键字是期限，那是不是只要再把选择的任务按期限重新排序就行了！然后从 1 开始把一个个视频的耗时叠加起来并输出不就行了吗！
## 实现
用优先队列存储当前已选择剪辑的视频，按期限长短对视频进行升序排序。每次判断做当前视频是否会超期限，不超就存入队列，总视频数加一；否则与队列中耗时最长者替换，总视频数不变。  
代码如下：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
struct t{
	int x, y, id;
	bool operator < (const t & i)const{//对优先队列定义排序算法
		return x < i.x;
	}
}a[500010];
int n, sum, ans, now = 1;
vector<t> v;
priority_queue<t> q;
bool cmp(t i, t j){//对数组定义排序算法
	return i.y < j.y;
}
signed main(){
	cin >> n;
	for (int i = 1; i <= n && cin >> a[i].x >> a[i].y; i ++)a[i].id = i;//注意要记录编号
	sort(a + 1, a + n + 1, cmp);
	for (int i = 1; i <= n; i ++){
		q.push(a[i]), sum += a[i].x;
		if (sum <= a[i].y)ans ++;
		else sum -= q.top().x, q.pop();//贪心过程
	}
	cout << ans << '\n';
	while (!q.empty())v.push_back(q.top()), q.pop();
	sort(v.begin(), v.end(), cmp);
	for (auto u : v){
		cout << u.id << " " << now << '\n';
		now += u.x;//加上耗时并输出
	}
	return 0;
}
```

---


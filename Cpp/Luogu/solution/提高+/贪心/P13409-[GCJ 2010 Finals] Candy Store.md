# [GCJ 2010 Finals] Candy Store

## 题目描述

经营一家糖果店可不容易！你需要优化各种各样的事情。最近你在销售一种非常受欢迎的糖果，名叫 Whizboppers。这种糖果很快就会变质，因此有如下特性：

- 你必须每天早上从供应商那里购买新的 Whizboppers。
- 你必须用当天早上从供应商那里买来的盒子出售 Whizboppers。

你可以从供应商那里订购任意整数克数的 Whizboppers 盒子。

每天最多有 $k$ 位顾客光临你的商店，并且从第一个顾客开始，他们会选择一个整数数量的美分来购买 Whizboppers：在 $1$ 到 $C$ 美分之间（包含 $1$ 和 $C$）。你将以每克 $1$ 美分的价格出售 Whizboppers；因此，如果某人想花 $4$ 美分，你就会给他正好 $4$ 克的糖果。你可以通过给他一个 $4$ 克的盒子，或者两个 $2$ 克的盒子和两个 $1$ 克的盒子来实现。

你需要订购最少数量的盒子，以保证无论每个人点多少克，你都能满足所有顾客的需求。

注意：当某个人选择购买多少糖果时，你已经知道之前的人买了多少，但你不知道后面的人会买多少。

例如，如果每天最多有 $2$ 位顾客，每人最多花 $2$ 美分（$k=2$，$C=2$），你可以从供应商那里购买四个 $1$ 克的盒子。但你可以做得更好：如果你买两个 $1$ 克的盒子和一个 $2$ 克的盒子，你也能满足所有顾客。如下所示：

```
第一位顾客   发出的盒子     第二位顾客   发出的盒子
------------------------------------------------
  2 美分      1 个 2 克盒子    2 美分       2 个 1 克盒子
                                 1 美分        1 个 1 克盒子
  -------------------------------------------------------
  1 美分      1 个 1 克盒子    2 美分       1 个 2 克盒子
                                 1 美分        1 个 1 克盒子
```

无论第一位顾客点多少，你都能分配盒子，使得第二位顾客仍然能得到正确数量的糖果。因此对于 $k=2, C=2$，你每天只需准备 $3$ 个盒子即可满足任意顺序的订单。

## 说明/提示

**样例解释**

在第一个样例中，你可以购买一个 $1$ 克盒子和两个 $2$ 克盒子。在第二个样例中，你可以购买两个 $1$ 克盒子和一个 $2$ 克盒子。

**数据范围**

- $1 \leq T \leq 100$。

**小数据集（7 分，测试集 1 - 可见）**

- $1 \leq k \leq 20$。
- $1 \leq C \leq 3$。

**大数据集（20 分，测试集 2 - 隐藏）**

- $1 \leq k \leq 1000$。
- $1 \leq C \leq 10^{12}$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4
1 5
2 2
10 3
2 50```

### 输出

```
Case #1: 3
Case #2: 3
Case #3: 19
Case #4: 11```

# 题解

## 作者：nueryim (赞：4)

# 题解：P13409 [GCJ 2010 Finals] Candy Store

>一道很有构造难度的贪心
>
>先说结论再给证明

## 题意

每天会有 $k$ 个人光顾糖果店，每个人都可能买 $1\sim C$ 个糖果。

你可以提前订购任意正整数容量的盒子任意个，但要保证无论这 $k$ 个顾客买多少糖果，你都能给每人选出若干盒子使得盒子的容量**恰好**为那人买的糖果数。

求你**最少**提前订购几个盒子。

## 结论

设答案为 $n$，可以构造一个长 $n$ 的盒子容量的数列，记为 $a_1\sim a_n$，满足：

- $i=1$：$a_i=1$
- $i>1$：$a_i=\lfloor\frac{\sum_{j=1}^{i-1}a_j}{k}\rfloor+1$
- $n$ 是最小满足：$\sum_{i=1}^n a_i\geq k\cdot C$ 的正整数

直接按照此公式递推直到 $\sum_{i=1}^n a_i\geq k\cdot C$ 时输出 $n$ 即可。

注意到每次递推相当于将 $\sum_{i=1}^n a_i$ 乘上 $\frac{k+1}{k}$ 再加一，当 $k=1000$ 时不出 $30000$ 次递推就能使和达到 $10^{12}$ 的大小。

## 证明

### Step 1：证有方法按照 $a_1\sim a_n$ 给每位顾客分配盒子

分配方法：遇到一位顾客时，假设这位顾客要买 $b$ 个糖果，重复以下步骤直到 $b=0$：

- 找到 $a$ 中还存在的最大的盒子 $a_i$ 满足 $a_i\leq b$
- 将 $a_i$ 标为不存在，令 $b=b-a_i$

使用归纳法证明这样分配是正确的：

>设当前盒子集合的总容量为 $V$，则每个盒子大小不超过 $
X=\lfloor\frac{V}{k}\rfloor+1$。
>
>设当前顾客需求总容量为 $L$

- **归纳边界**：首先当顾客只要 1 个糖果时，选 $a_i=1$ 即可。
- **归纳假设**：在当前总容量为 $V$ 时，总订单容量不大于 $V$ 时，能处理当前所有顾客
- **归纳过程**：考虑添加一个新的盒子 $X$（当前总容量为 $V+X$）我们证明当 $L\leq V+X$ 时，我们的分配方法依然正确：

1. 存在订单 $\geq X$，此时根据我们的分配方法，会将订单立刻减去 $X$，此时有 $L\leq V$，根据归纳假设，这种情况正确。
2. 所有订单 $\leq X-1$，此时订单总容量为 $L=k\cdot (X-1)=k\cdot\lfloor\frac{V}{k}\rfloor\leq V$，根据归纳假设，这种情况也正确。

### Step 2：证明此序列的长度 $n$ 最小

因为有 $\sum_{i=1}^n a_i\geq k\cdot C$，所以证明此序列的长度 $n$ 最小相当于证明此序列的元素 $a_i$ 最大。

考虑让其中一个 $a_i$ 变得更大会怎么样，让一个 $a_i>\lfloor\frac{\sum_{j=1}^{i-1}a_j}{k}\rfloor+1$，那么如果所有人都买 $\lfloor\frac{\sum_{j=1}^{i-1}a_j}{k}\rfloor+1$ 个糖果：

- $a_i$ 太大了无法被使用
- 比 $a_i$ 小的盒子的总容量为：$\sum_{j=1}^{i-1}a_j$
- 顾客需求总容量为：$(\lfloor\frac{\sum_{j=1}^{i-1}a_j}{k}\rfloor+1)\cdot k$

所以能使用的盒子总容量**小于**顾客需求总容量，不合法

所以此序列的元素 $a_i$ 最大，长度 $n$ 最小。

## 代码

~~~cpp
// P13409 (AC)

#include <iostream>
#include <cstdio>

#define lnt long long

using namespace std;

int T;
lnt k, c;

inline void init(int id)
{
    cin >> k >> c;
}

inline void work(int id)
{
    lnt sum = 0;
    lnt cnt = 0;
    while (sum < k * c)
    {
        cnt ++;
        sum += (sum / k) + 1;
    }
    cout << "Case #" << id << ": " << cnt << "\n";
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);

    cin >> T;
    for (int i = 1; i <= T; i ++)
    {
        init(i);
        work(i);
    }

    return 0;
}
~~~

---


# [OOI 2024] More Gifts

## 题目描述

信息学闭赛的主办方决定为参赛选手准备礼物。共准备了 $k$ 盒完全相同的礼品盒，每盒中有 $n$ 个礼物。这些礼物按顺序叠放在一起，最上面是 $a_1$ 型礼物，下面是 $a_2$ 型，以此类推，最底下是 $a_n$ 型礼物。

礼物的分发方式如下：首先，从第一盒礼物的顶部依次发放，直到第一盒发完；然后从第二盒的顶部依次发放，直到第二盒发完；依此类推，最后发放第 $k$ 盒礼物。

每位参赛者可以一次性领取多个礼物，因此分发时会先给第一个参赛者发礼物，然后是第二个，依次进行。已知如果某位参赛者收到超过 $t$ 种不同类型的礼物，他会太高兴，导致比赛发挥失常。为了让大家都能正常参赛，主办方决定每位参赛者收到的不同类型礼物不能超过 $t$ 种（注意，同一种礼物可以收到多个）。

主办方希望让信息学闭赛更具专属感，于是想邀请尽量少的参赛者。请你帮助主办方计算，最少需要邀请多少参赛者，才能让所有礼物都被分完，并且每位参赛者收到的不同类型礼物不超过 $t$ 种。

## 说明/提示

### 说明

在第一个样例中，每盒礼物从上到下的类型如下（不同颜色表示在盒中的位置）：

:::align{center}
![](https://cdn.luogu.com.cn/upload/image_hosting/7a0npd0f.png)
:::

共有 $4$ 盒礼物，礼物的发放顺序如下：

:::aligned{center}
![](https://cdn.luogu.com.cn/upload/image_hosting/anlvf2nr.png)
:::

由于 $t=1$，每位参赛者只能收到一种类型的礼物：

:::aligned{center}
![](https://cdn.luogu.com.cn/upload/image_hosting/sxu9l82y.png)
:::

在第二个样例中，发放顺序及礼物分组如下：

:::aligned{center}
![](https://cdn.luogu.com.cn/upload/image_hosting/cezyhq06.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/ic7s6njx.png)
:::

在第三个样例中，发放顺序如下：

:::aligned{center}
![](https://cdn.luogu.com.cn/upload/image_hosting/14b4v2bt.png)
:::

此时一种最优的分配方式如下：

:::aligned{center}
![](https://cdn.luogu.com.cn/upload/image_hosting/a31c7071.png)
:::

### 计分方式

本题共六组测试。只有通过该组及其所有依赖组全部测试，才能获得该组分数。部分组不要求通过样例测试。

| 组别 | 分值 | 额外约束 | $n$ | $k$ | $t$ | 依赖组 | 备注 |
|:------:|:------:|:----------------------:|:--:|:--:|:--:|:---------------:|:-------:|
| 0 | 0 | -- | -- | -- | -- | -- | 样例。 |
| 1 | 14 | $n \le 100$ | $k \le 10$ | -- | 0 | -- |
| 2 | 12 | -- | -- | $t = 1$ | -- | -- |
| 3 | 16 | $n \le 1000$ | $k \le 1000$ | -- | 0, 1 | -- |
| 4 | 21 | $n \le 1500$ | $k \le 10^6$ | -- | 0, 1, 3 | -- |
| 5 | 18 | -- | $k \le 10^6$ | -- | 0, 1, 3, 4 | -- |
| 6 | 19 | -- | -- | -- | 0 -- 5 | -- |

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
2 4 1
1 2```

### 输出

```
8```

## 样例 #2

### 输入

```
4 3 1
1 1 2 1```

### 输出

```
7```

## 样例 #3

### 输入

```
7 2 3
1 2 3 4 5 6 7```

### 输出

```
5```

# 题解

## 作者：FFTotoro (赞：0)

[XVIII Open Olympiad in Informatics - Final Stage, Day 1 T3](https://codeforces.com/contest/1939/problem/C) 非官方题解。

赛时没反应过来基环树找环，惨痛 $81$ 分。

以下所有内容均默认数组下标从 $0$ 开始。称一个礼物的“编号”为它是**其中一堆**中的第几个，也就是说其编号与它在 $n$ 堆中的哪一堆无关。

令 $c$ 为不同的礼物种类数，特判掉 $c\le t$ 的情况，此时答案为 $1$；接下来只考虑 $c>t$ 的情况，容易发现在这种情况下若一位参赛者如果拿的第一个礼物在第 $i(0\le i<k-2)$ 堆，下一位参赛者的**第一个**礼物不可能在第 $i+2$ 堆中。

先考虑怎样的分配礼物策略是最优的：显然是对于每个人能拿就拿。于是对于每个 $i(0\le i<n)$，处理出一位参赛者拿的第一个礼物的编号是 $i$ 时，下一个参赛者第一个拿的礼物的编号，记为 $nx_i$（如果她的最后一个礼物在和下一个参赛者的第一个礼物不在同一个堆，为了方便，不妨令 $nx_i\ge n$；即如果下一个参赛者的第一个礼物是下一堆中的第 $j$ 个，那么 $nx_i=n+j$）。所有的 $nx_i$ 可以使用数组或 `std::set` 简单地预处理。

但这样还不够。于是对于每个 $i$ 考虑再处理出对于一个第一次拿编号为 $i$ 的礼物的参赛者，从她开始发放礼物，第一个拿到下一个堆的礼物的参赛者拿到的第一个礼物的编号 $f_i$，以及这个过程中间的参赛者个数 $d_i$。这部分可以通过 BFS 得出答案。

于是令 $p\leftarrow 0$，不断执行 $p=nx_{f_p}-n$ 并累加 $d_p$，即可通过 $k\le 10^6$ 的部分，并像我一样在赛时获得 $81$ 分的高分。这部分的代码实现因人而异，例如你可能需要将最后的答案加上 $k$ 才能的到正确答案，等等。

考虑优化上述的过程。我们发现 $p$ 在经过若干次的循环（这个次数不超过 $n$）后又会回到原来有过的一个值，并不断循环：因为每个 $p$ 仅对应一个 $nx_{f_p}-n$，这是一个内向基环树的结构。于是考虑找规律，具体地，找到循环的周期，处理循环之前的部分以及最后剩余的不完整的一个循环里 $d_p$ 的累加值，并快速计算出中间完整循环部分 $d_p$ 的累加值即可得出答案。这部分的实现细节可以参考代码。

可以借助 `std::set` 与 `std::map` 较为简单地实现 $O(n\log n)$ 做法（但是有 TLE 的风险）。也可以通过离散化、哈希表使时间复杂度降低至 $O(n)$。

放代码：

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
using namespace std;
struct Hash{
  static uint64_t splitmix64(uint64_t x){
    x+=0x9e3779b97f4a7c15;
    x=(x^x>>30)*0xbf58476d1ce4e5b9;
    x=(x^x>>27)*0x94d049bb133111eb;
    return x^x>>31;
  }
  size_t operator()(uint64_t x)const{
    static const uint64_t FIXED_RANDOM=chrono::steady_clock::now().time_since_epoch().count();
    return splitmix64(x+FIXED_RANDOM);
  }
};
// 哈希函数，可以参照：https://codeforces.com/blog/entry/62393
int main(){
  ios::sync_with_stdio(false);
  cin.tie(0); cout.tie(0);
  int n,k,t; long long c=0; cin>>n>>k>>t;
  vector<int> a(n);
  __gnu_pbds::gp_hash_table<int,int,Hash> m;
  for(auto &i:a)
    if(cin>>i;m.find(i)==m.end())m[i]=c++;
  for(auto &i:a)i=m[i]; // 离散化
  if(c<=t)cout<<"1\n",exit(0);
  vector<int> nx(n),d(n),f(n),s(n);
  vector<vector<int> > g(n);
  for(int i=0,l=0,e=0;i<n;i++){
    while(1){
      if(++s[a[l%n]]==1)e++;
      if(e>t){
        nx[i]=l,s[a[l%n]]=0,e--;
        if(l<n)g[l].emplace_back(i);
        break;
      } // 拿的礼物种类 > t
      l++;
    }
    if(!--s[a[i]])e--;
  } // 预处理 nx[i]
  queue<int> q;
  for(int i=n-1;i>=0;i--)
    if(nx[i]>=n)q.emplace(f[i]=i);
  while(!q.empty()){
    int u=q.front(); q.pop();
    for(int i:g[u])
      f[i]=f[u],d[i]=d[u]+1,q.emplace(i);
  } // 预处理 f[i] 与 d[i]
  vector<int> w(n<<1),b(n,-1);
  for(int i=c=0,p=0;i<k;i++){
    if(~b[p]){
      int x=(k-b[p])/(i-b[p]),r=(k-b[p])%(i-b[p]);
      c+=(c-w[b[p]]+d[p])*(x-1);
      for(int j=0;j<r;j++)
        c+=d[p],p=nx[f[p]]-n;
      break;
    } // 找到环
    w[b[p]=i]=(c+=d[p]),p=nx[f[p]]-n;
  } // 基环树找环
  cout<<c+k<<endl;
  return 0;
}
```

---

## 作者：chen_zhe (赞：0)

**这是官方题解的 AI 中文翻译。**

**子任务 1. $n \leq 100, k \leq 10$。**

我们使用动态规划。令 $dp[i]$ 表示长度为 $i$ 的前缀所需的最少子段数量，初始 $dp[1] = 1$。

状态 $i$ 的转移方式为：若子段 $[j + 1, i]$ 内不同数字的数量不超过 $t$，则 $dp[i] = \min(dp[i], dp[j] + 1)$。

如果我们从末尾开始递推动态转移，可以通过维护子段内不同数字的数量，在 $O(1)$ 时间内判断条件成立与否。这样可以得到 $O((nk)^2)$ 或 $O((nk)^2 \log(nk))$ 的解法。

**子任务 2. $t = 1$。**

我们将原数组划分为若干连续相等数字的块。设块的数量为 $cnt$。则答案为 $cnt \cdot k$（若首块与末块不同），否则为 $(cnt - 1) \cdot k + 1$。

**贪心解法的证明。**

考虑某个最优划分，假设它与贪心划分不同。找到第一个出现分歧的位置。在这种情况下，最优划分该子段的长度比贪心划分短。将该子段的右端点向贪心划分的位置右移，划分仍然合法，子段数量不会增加。不断重复此过程，最优划分最终会变为贪心划分，且子段数量不会增多。因此，贪心划分是最优的。

**子任务 3. $n \leq 1000, k \leq 1000$。**

我们构造一个长度为 $nk$ 的完全重复数组。用贪心算法得到最小所需礼物数。时间复杂度为 $O(nk)$ 或 $O(nk\log(nk))$。

**子任务 4. $n \leq 1500, k \leq 10^6$。**

考虑如下算法：从原数组的第 $i$ 个位置开始，贪心地收集礼物，直到当前栈的末尾。然后继续从下一个栈收集，只要不会增加子段数量。对于原数组每个位置 $i$，我们记下停止收集后的下一个位置，以及过程中得到的子段数，分别记为 $go[i]$ 和 $cnt[i]$。

$go$ 与 $cnt$ 两个数组可以直接用 $O(n^2 \log n)$ 预处理得到。然后，为了计算答案，我们引入一个参数 $cur$，表示当前最优划分到数组的哪个位置。我们从 $1$ 到 $k$ 依次循环，每次将 $cnt[cur]$ 加入答案，并将 $cur$ 更新为 $go[cur]$。答案计算为 $O(k)$，加上预处理，总复杂度为 $O(n^2 \log n + k)$。

**子任务 5. $k \leq 10^6$。**

我们将学习如何在 $O(n)$ 时间内求出 $go$ 和 $cnt$ 两个数组。方法是用双指针法，对于每个位置 $i$，找到包含不超过 $t$ 个不同数字的最长子段，记为 $len$。从原数组末尾开始递推，位置 $i$ 的转移如下：
- 若 $i + len \geqslant n - 1$，则 $go[i] = (i + len) \% n + 1$，其中 $\%$ 表示取模运算，$cnt[i] = 1$。
- 否则，$go[i] = go[i + len + 1]$，同样 $\%$ 为取模运算，$cnt[i] = cnt[i + len + 1] + 1$。

像子任务 4 那样计算答案，总复杂度为 $O(n + k)$ 或 $O(n \log n + k)$。

**完整解法。**

我们对答案的计算进行优化。注意到如果 $k > n$，那么在计算答案时，$cur$ 的取值会出现重复。找到第一次出现重复的位置，记录发生重复所需的步数及这段时间内答案的增量。将剩余栈数除以步数，得到还需重复多少次，剩余部分单独处理。

总的来说，解法复杂度为 $O(n)$ 或 $O(n \log n)$。

---


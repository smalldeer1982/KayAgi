# [KOI 2025 #1] 快递运输

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

2050 年，快递最优化研究所 (KOI, Kurier Optimization Institute) 建立了一个全国范围的基于机器人的快递运输网络。

该网络由 $N$ 个物流中心和连接它们的 $N-1$ 条道路组成，物流中心的编号从 1 到 $N$。每条道路的编号从 1 到 $N-1$，其中第 $i$ 条 ($1 \le i \le N-1$) 道路连接着 $U_i$ 和 $V_i$ 两个物流中心，道路的长度为 $W_i$。任何一个物流中心都可以通过一条或多条道路到达其他任何一个物流中心。也就是说，快递运输网络是一个由道路连接而成的连通结构。此外，任意两条不同的道路除了在它们的端点（即物流中心）外，不会在任何其他点相交。

我们将所有物流中心和所有道路上的任意点统称为一个**地点**。两个地点 $x, y$ 之间的距离 $d(x, y)$ 定义为从地点 $x$ 到达地点 $y$ 必须经过的最短路径长度。当然，若 $x=y$，则 $d(x, y) = 0$。

一些机器人被放置在特定的物流中心。每个机器人都带有一个给定的**通信范围**。一个通信范围为 $X$、初始位于地点 $p$ 的机器人，可以在满足 $d(p, z) \le X$ 的所有地点 $z$ 之间自由地、往复地移动，并可以在自己可移动范围内的任意地点取件或放件。

您作为研究所的研究员，需要判断是否可以利用协作的机器人，将快递从 1 号物流中心运输到 $N$ 号物流中心。也就是说，一个机器人可以将快递放在某个地点，然后另一个机器人可以从同一地点取走快递并继续运输。

您需要对总共 $Q$ 个场景进行分析，这些场景是相互关联的。第 $j$ ($1 \le j \le Q$) 个场景的形态如下：

*   1 $A_j$ $B_j$：在第 $j-1$ 个场景的基础上，增加一个新机器人。该机器人的初始位置为 $A_j$ 号物流中心，通信范围为 $B_j$。
*   2 $C_j$：在第 $j-1$ 个场景的基础上，移除在第 $C_j$ 个场景中添加的机器人。保证在第 $C_j$ 个场景中确实添加了一个新的机器人，且同一个机器人不会被移除两次以上。

规定，第 0 个场景为初始状态，即没有任何机器人被放置。

对于每个场景，请编写一个程序来判断，机器人是否能够协作将快递从 1 号物流中心运输到 $N$ 号物流中心。

## 说明/提示

### 样例 1 说明

假设我们考虑第八个场景。此时总共放置了六个机器人。其中一种可能的运输方式如下：
1.  位于 1 号物流中心的唯一一个机器人通信范围为 4。该机器人从 1 号物流中心拿起快递，并将其放在 3 号物流中心。
2.  位于 2 号物流中心的唯一一个机器人通信范围为 12。该机器人从 3 号物流中心移动并拿起快递，然后将其放在从 3 号物流中心到 4 号物流中心的道路上，距离 3 号物流中心为 1 的位置。
3.  位于 8 号物流中心的唯一一个机器人通信范围为 8。该机器人从 3 号到 4 号道路上距离 3 号物流中心为 1 的位置移动并拿起快递，然后将其放在从 4 号到 5 号道路上距离 4 号物流中心为 3 的位置。
4.  位于 10 号物流中心的唯一一个机器人通信范围为 9。该机器人从 4 号到 5 号道路上距离 4 号物流中心为 3 的位置移动并拿起快递，然后将其放在 11 号物流中心。

因为可以运输快递，所以应当输出 **YES**。

假设我们考虑第十个场景。此时总共放置了六个机器人。没有任何机器人能够拿起最初放在 1 号物流中心的快递。因此，无法运输快递。所以应当输出 **NO**。

### 限制条件

*   给定的所有数都是整数。
*   $2 \le N \le 200,000$
*   $1 \le Q \le 200,000$
*   对于每个 $1 \le i \le N-1$ 的 $i$，有 $1 \le U_i, V_i \le N$ 且 $1 \le W_i \le 10^9$。
*   运输网络是连通的。
*   对于每个 $1 \le j \le Q$ 的 $j$：
    *   如果第 $j$ 个场景是增加新机器人，则 $1 \le A_j \le N$ 且 $1 \le B_j \le 10^{15}$。
    *   如果第 $j$ 个场景是移除机器人，则 $1 \le C_j \le j-1$ 且第 $C_j$ 个场景必须是增加新机器人的场景。同一个机器人不会被移除超过一次。

### 子任务

1.  (8 分) $N \le 100, Q \le 6$。对于每个 $1 \le i \le N-1$ 的 $i$，$W_i \le 10$。
2.  (13 分) 对于每个 $1 \le i \le N-1$ 的 $i$，$U_i = i, V_i = i+1$。此外，$N, Q \le 2500$。
3.  (25 分) $N, Q \le 2500$。
4.  (27 分) 对于每个 $1 \le i \le N-1$ 的 $i$，$U_i = i, V_i = i+1$。
5.  (30 分) 所有的场景都是增加新机器人的场景。
6.  (26 分) 对于每个 $1 \le i \le N-1$ 的 $i$，$W_i = 1$。对于所有 $j$，如果是增加新机器人的场景，$B_j \le 10$。
7.  (21 分) 无附加限制条件。

## 样例 #1

### 输入

```
11 10
1 3 3
2 3 10
3 4 5
4 5 8
9 6 4
4 7 2
7 8 2
5 9 1
9 10 2
5 11 3
1 1 4
1 2 12
1 6 6
1 7 1
1 8 8
1 9 6
1 10 9
1 11 2
2 7
2 1```

### 输出

```
NO
NO
NO
NO
NO
YES
YES
YES
YES
NO```

# 题解

## 作者：chen_zhe (赞：2)

### 子问题 1

考虑使用 $O(Q)$ 台机器人的所有 $O(Q!)$ 种顺序。设 $W_i$ 的最大值为 $X$，如果我们维护对所有 $O(NX)$ 个位置的可达性，就可以在 $O(Q! \times NQ^2X)$ 时间内解决问题。

### 子问题 2

由于运输网络是线性结构，每个机器人可以在一条直线上的一个区间内自由移动。也就是说，一个信号范围为 $X$、初始位置为 $p$ 的机器人，可以以 $p$ 为中心，在半径为 $X$ 的区间内自由移动。对于每个查询，为了确认机器人的区间列表是否完全覆盖了整个区间，我们对 $O(Q)$ 个区间进行排序，并在线性时间内检查每个区间。时间复杂度为排序所需的 $O(Q^2 \log Q)$。

### 子问题 3

我们预先通过深度优先搜索，找出一条从 1 号物流中心到 N 号物流中心的路径。可以计算出每个机器人能在这条路径上的哪个区间内自由移动。也就是说，对于一个信号范围为 $X$、初始位置为 $p$ 的机器人，通过从 $p$ 点开始在 DFS 树上向父节点移动 $k = O(N)$ 次，找到路径上最近的顶点 $v$，就可以认为该机器人能以 $v$ 为中心，在半径为 $X-k$ 的区间内自由移动。这样，问题就归约为了子问题 2。时间复杂度为 $O(Q^2 \log Q + NQ)$。

### 子问题 4

由于运输网络是线性结构，我们如同子问题 2 一样，计算每个机器人自由移动的区间。对于每个查询，可以通过线段树，将确认机器人区间列表是否完全覆盖整个区间的过程，优化到每次查询 $O(\log(N+Q))$。也就是说，在坐标离散化之后，对每个机器人自由移动的区间执行加 1 操作，然后判断整个线段树的最小值是否不小于 1 即可。时间复杂度为 $O((N + Q) \log(N + Q))$。

### 子问题 5

该子问题只有添加机器人的查询。我们需要像子问题 3 那样求出每个机器人的区间，但这需要比 $O(N)$ 更快。这可以在 DFS 树上利用稀疏表（倍增），在 $O(\log N)$ 时间内计算出第几级祖先位于路径上。由于添加机器人后，答案从 "YES" 不会变为 "NO"，所以答案会一直为 "NO"，直到某个时刻变为 "YES"。我们可以对表示该时刻的查询下标进行二分搜索。如果用与子问题 2 相同的方式检查机器人区间列表是否完全覆盖，则可以在 $O(Q \log N + Q \log^2 Q)$ 时间内解决问题。

### 子问题 6

求每个机器人区间的过程与子问题 3 相同。由于区间长度很短，对于每个查询，确认机器人区间列表是否完全覆盖整个区间的过程，可以通过简单地遍历区间，并为数组中对应区间的所有元素加 1 来执行。在此过程中，如果维护数组中值为 0 的下标数量，就可以在常数时间内判断数组中是否存在值为 0 的下标，即最小值是否不小于 1。时间复杂度为 $O(Q \log N + Q\max(B_j))$。

### 子问题 7

求每个机器人区间的过程与子问题 3 相同。之后，通过子问题 4 的解法可以解决问题。时间复杂度为 $O((N + Q) \log(N + Q))$。

```cpp
#include <cstdio>
#include <vector>
#include <utility>
#include <algorithm>
using namespace std;
 
int tree[1048576], lazy[1048576];
 
void propagate(int i, int b, int e) {
    if (b < e) for (int j: { i * 2 + 1, i * 2 + 2 }) lazy[j] += lazy[i];
    tree[i] += lazy[i];
    lazy[i] = 0;
}
 
int update(int i, int b, int e, int l, int r, int v) {
    propagate(i, b, e);
    if (r < b || e < l) return tree[i];
    if (l <= b && e <= r) {
        lazy[i] += v;
        propagate(i, b, e);
        return tree[i];
    }
    int m = (b + e) / 2;
    return tree[i] = min(update(i * 2 + 1, b, m, l, r, v), update(i * 2 + 2, m + 1, e, l, r, v));
}
 
int query(int i, int b, int e, int l, int r) {
    propagate(i, b, e);
    if (r < b || e < l) return (int)1e9;
    if (l <= b && e <= r) return tree[i];
    int m = (b + e) / 2;
    return min(query(i * 2 + 1, b, m, l, r), query(i * 2 + 2, m + 1, e, l, r));
}
 
int n, q;
vector<pair<int, int>> adj[200006];
vector<pair<pair<long long, long long>, int>> queries;
int par[200006], path[200006], sp[20][200006];
long long dist[20][200006], depth[200006];
vector<long long> compress;
 
void dfs(int x, int prev = -1) {
    par[x] = prev;
    sp[0][x] = prev;
    for (auto &[ i, j ]: adj[x]) {
        if (i != prev) {
            depth[i] = depth[x] + j;
            dfs(i, x);
            dist[0][i] = j;
        }
    }
}
 
pair<int, long long> reduction(int a, long long b) {
    for (int t = 19; t >= 0; t--) {
        if (sp[t][a] == -1 || path[sp[t][a]]) continue;
        b -= dist[t][a];
        a = sp[t][a];
    }
    if (!path[a]) {
        b -= dist[0][a];
        a = sp[0][a];
    }
    return { a, b };
}
 
int main() {
    scanf("%d%d", &n, &q);
    for (int i = 0; i < n - 1; i++) {
        int u, v, w;
        scanf("%d%d%d", &u, &v, &w);
        u--, v--;
        adj[u].push_back({ v, w });
        adj[v].push_back({ u, w });
    }
    for (int t = 0; t < 20; t++) for (int i = 0; i < n; i++) {
        sp[t][i] = -1;
        dist[t][i] = (long long)1e18;
    }
    depth[0] = 0;
    dfs(0);
    for (int t = 1; t < 20; t++) for (int i = 0; i < n; i++) {
        if (sp[t - 1][i] == -1) {
            sp[t][i] = -1;
            dist[t][i] = (long long)1e18;
        } else {
            sp[t][i] = sp[t - 1][sp[t - 1][i]];
            dist[t][i] = min((long long)1e18, dist[t - 1][i] + dist[t - 1][sp[t - 1][i]]);
        }
    }
    for (int i = 0; i < n; i++) path[i] = 0;
    path[0] = 1;
    for (int i = n - 1; i != 0; i = par[i]) path[i] = 1;
    for (int i = 0; i < q; i++) {
        int t, x;
        long long y;
        scanf("%d", &t);
        if (t == 1) {
            scanf("%d%lld", &x, &y);
            x--;
            auto [ a, b ] = reduction(x, y);
            queries.push_back({ { depth[a] - b, depth[a] + b }, 1 });
        } else {
            scanf("%d", &x);
            x--;
            queries.push_back({ queries[x].first, -1 });
        }
    }
    compress.push_back(depth[0]);
    compress.push_back(depth[n - 1]);
    for (auto &[ i, j ]: queries) {
        compress.push_back(i.first);
        compress.push_back(i.second);
    }
    sort(compress.begin(), compress.end());
    compress.erase(unique(compress.begin(), compress.end()), compress.end());
    for (auto &[ i, j ]: queries) {
        i.first = lower_bound(compress.begin(), compress.end(), i.first) - compress.begin();
        i.second = upper_bound(compress.begin(), compress.end(), i.second - 1) - compress.begin() - 1;
    }
    int fi = lower_bound(compress.begin(), compress.end(), depth[0]) - compress.begin();
    int se = lower_bound(compress.begin(), compress.end(), depth[n - 1]) - compress.begin() - 1;
    for (auto &[ i, j ]: queries) {
        update(0, 0, 524287, i.first, i.second, j);
        puts(query(0, 0, 524287, fi, se) ? "YES" : "NO");
    }
}
```

---

## 作者：ran_qwq (赞：1)

upd on 2025.8.3：修改了一处 min 写成 max 的笔误。

下面我们定义 $1\sim n$ 上的位置集合为主干道，其他位置为岔路。我们没必要把快递搬出主干道，证明考虑我们把物品搬到了从【主干道一位置 $u$ 分出的岔路】上的一位置 $v$。那么 $u$ 肯定是可达的，且相比 $v$ 更靠近 $n$，所以比 $v$ 更优。

所以每个机器人的有效覆盖范围是主干道上的一段区间，直接转化为链的情况。设机器人物流中心到主干道距离为 $d$，离 $1$ 点距离为 $D$，则可以覆盖主干道上离 $1$ 点距离为 $[D-X,D+X-2d]$。

能到达 $n$ 的充要条件是每个位置都有区间覆盖，加机器人和删机器人的操作都可以用区间加区间求 min 线段树维护。因为线段树上的区间端点是整数所以要转成左闭右开区间。

值域过大，可以离散化，也可以动态开点，反正空间开得下，时间也够。

[这是代码。](https://www.luogu.com.cn/paste/7ureloez)

---


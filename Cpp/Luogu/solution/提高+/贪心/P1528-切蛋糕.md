# 切蛋糕

## 题目描述

Facer今天买了 $n$ 块蛋糕，不料被信息组中球球等好吃懒做的家伙发现了，没办法，只好浪费一点来填他们的嘴巴。他答应给每个人留一口，然后量了量每个人口的大小。Facer 有把刀，可以切蛋糕，但他不能把两块蛋糕拼起来，但是他又不会给任何人两块蛋糕。现在问你，facer 怎样切蛋糕，才能满足最多的人。（facer 的刀很强，切的时候不会浪费蛋糕）。

 
 

## 样例 #1

### 输入

```
4
30
40
50
25
10
15
16
17
18
19
20
21
25
24
30

 
```

### 输出

```
7
```

# 题解

## 作者：shiroha (赞：41)



**此题算法Tag**：二分查找、深度优先搜索、贪心、~~剪枝~~

### 分析
- 贪心：对于同样的蛋糕，相比于给嘴大的人吃，给嘴小的人吃可以满足更多人。优先将蛋糕喂给嘴小的人可以获得**局部**最优解。
- 判断：判断一个局部最优解是不是整体最优解，只能通过~~暴力的~~搜索的方式。但是这样的话会消耗很多的时间。
- 二分：此题答案可行域连续，可以使用二分查找确定答案，再由搜索验证答案是否合理以缩小区间直到可以确定最优解。
- 剪枝：为了避免TLE，还应对一些细节进行一些优化。比如：嘴比最大的蛋糕大的人是不可能满足的，应当直接剔除。

### 搜索
+ 搜索之前，根据分析，将所有的人根据嘴的大小进行升序排列。如果有n个人可以被满足，那么这n个人一定是数组的前n个元素。
+ 对待检验值进行DFS搜索。如果满足了它的需求，就递归搜索它的前一个人是否可以被剩下来的蛋糕满足。
+ 如果嘴最小的人的需求也可以被满足，那么递归中止，验证通过；如果中途出现某人的需求不能被满足，那么就回溯到上一级递归。
+ 如果找到了满足测试值人数的蛋糕分配方式，就直接退出查找，以避免不必要的性能浪费。

### 优化
- **求值备用**：排列嘴大小之后要计算前缀和，可以方便后续的使用；读入蛋糕的时候需要计算最大的蛋糕和蛋糕总值以备使用。~~使用优先级队列存储蛋糕~~。
- **缩小区间**：如果某人的嘴比最大的蛋糕还要大，那么根据题意，他的需求将永远无法得到满足。此时可以收紧二分查找区间以减少查找次数。
- **浪费蛋糕**：如果某块蛋糕（或者被啃过的蛋糕）小于当前嘴最小的人的需求，那么此蛋糕将无法再发挥任何作用了，可以存储起来。
- **等大需求**：因为对嘴的大小进行了排序，确保了先查找的嘴不小于后查找的嘴。若相邻两嘴大小相等，后者已经遍历了部分蛋糕数组才求出结果，等于说是已遍历部分的蛋糕一定不能满足要求。为了减少遍历，可以将此时的数组坐标传给下一级递归，在需求相等的下一级递归中跳过这些不可能的部分，以节约时间。

### 说明
+ 设置非遍历终点的返回点时，应确保回溯代码可以正常执行。不规范的写法可能导致部分语句根本上是`Unreachable`的，无法执行到。
+ 每一个递归层应当都有独立的`wasted`标志。因为它会根据每一层递归遍历到的蛋糕情况而被修改。
+ *~~代码不规范，调试两行泪~~*
+ *~~其实这都是本人做题过程中遇到的问题或手抖犯下的错误~~*

### 代码
```c++
#include <iostream>
#include <algorithm>

#define max(a,b) (a>b?a:b)
#define MIN_NEED mouth[1]

using namespace std;

int n,m;
int cake[55],mouth[1050];

int prefixSum[1050];                // 排序后嘴大小的前缀和
int maxCake,allCake;                // 最大蛋糕和所有蛋糕总和
int totalCake,needCake;             // 搜索：当前全部可用蛋糕和还需要的蛋糕
int wasteCake;                      // 优化：浪费的蛋糕渣

bool sub_DFS(int toTest, int origin)            // origin：遍历蛋糕数组的起点
{
    /* 结束递归 */
    if(toTest<1)
        return true;                            // 已经完成1~toTest的人的喂食，测试通过
    if(totalCake-wasteCake<needCake)
        return false;                           // 总蛋糕小于总需求，必然失败，停止搜索
    
    /* 搜索 */
    bool flag = false;
    for(int i=origin;i<=n;++i)                  // 遍历蛋糕，尝试将蛋糕喂给第toTest号人
    {
        if(cake[i]>=mouth[toTest])              
        {
            needCake-=mouth[toTest];            // 喂食：消耗蛋糕，满足需求                 
            totalCake-=mouth[toTest];
            cake[i]-=mouth[toTest];
            
            bool wasted = false;                // 回溯：是否使用了蛋糕渣优化
            if(cake[i]<MIN_NEED)                // 优化：蛋糕渣不能满足最低需求，不可用
            {
                wasteCake+=cake[i];             // 此蛋糕渣将被浪费，设置优化启动的标志
                wasted = true;
            }
            if(mouth[toTest]==mouth[toTest-1])  // 下一个测试对象的嘴和当前的嘴一样大
            { 
                if(sub_DFS(toTest-1,i))         // 优化：从当前的位置继续遍历蛋糕列表
                flag = true;                    // 优化：找到解决方案，就不再继续搜索
            }
            else if(sub_DFS(toTest-1,1))        // 无法优化，直接递归。
                flag = true;                    // 优化：同上分支

            /* 回溯 */
            if(wasted)                          // 若做了优化，则撤回         
                wasteCake-=cake[i];                
            cake[i]+=mouth[toTest];             // 撤回全部变化
            totalCake+=mouth[toTest];
            needCake+=mouth[toTest];

            if(flag) return true;
        }
    }

    /* 结束递归 */
    return false;                               // 无法找到合适的蛋糕，测试失败
}

inline bool DFS(int toTest)                     // DFS：检查答案toTest是否可行
{
    /* 准备变量 */
    totalCake = allCake;                          
    needCake = prefixSum[toTest];
    wasteCake = 0;

    /* 启动递归 */
    return sub_DFS(toTest,1);
}

int main()
{
    /* 优化读写 */
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    /* 初始化 */
    cake[0] = mouth[0] = 0;
    prefixSum[0] = 0;
    maxCake = allCake = 0;

    /* 读入 */
    cin>>n;
    for(int i=1;i<=n;++i)
    {
        cin>>cake[i];
        maxCake=max(maxCake,cake[i]);           // 找到最大蛋糕并计算总值
        allCake+=cake[i];
    }
    cin>>m;
    for(int i=1;i<=m;++i)
        cin>>mouth[i];

    /* 预处理 */
    sort(mouth+1,mouth+1+m);                    // 贪心：先满足小嘴，进行升序排序
    for(int i=1;i<=m;++i)
        prefixSum[i]=prefixSum[i-1]+mouth[i];   // 计算前缀和    

    /* 二分查找 */
    int l=1,r=m;
    while(mouth[r]>maxCake)--r;                 // 优化：缩小二分查找范围
    int mid;
    while(l<=r)
    {
        mid = ((l+r)>>1);
        if(DFS(mid))l=mid+1;                 
        else r=mid-1;                       
    }
    cout<<r;                               

    return 0;
}
```
注释写的还算详细吧……就算文字说明的很屑应该也能看懂代码吧==

2019-11-09-5:55-A.M> 狗命要紧，洗洗睡罢（）

## ~~此题还可以使用神秘的随机化算法~~

---

## 作者：凌幽 (赞：27)

###贪心思想+二分答案+dfs判断

- 贪心地想，如果一块蛋糕能满足口较大的人，那么口较小的人一定能满足，并且能满足的人可能会更多，所以先满足口较小的人

- 二分可以满足的最多的人有多少

- dfs判断是否前mid人是否可行

但是，麻烦来了，TLE怎么办？

###剪枝

剪枝
1. 把人按口的大小排序，并记录前缀和与蛋糕总数，显然，前缀和是递增的，那么这样，我们可以通过缩小二分范围来达到加速的目的。若所有的蛋糕都不能满足某一个人的口，那么可以将其删去

2. waste浪费，对于一块蛋糕，将其分出去一部分满足一些人后，倘若剩余部分连口最小的人都无法满足，那么剩余部分一定不能满足任何人，就属于浪费的部分。若蛋糕有用的部分（总数-浪费）不能满足前mid个人，那么当前二分的答案不可行

3. 由于口是递增的，在dfs过程中，可能会遇到这么一种情况，第i个人与第i-1个人的口相同，那么考虑，若不能满足第i-1个人，那么一定不能满足第i个人，进行剪枝

###AC代码

```cpp
#include<cmath>
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
#define R register
#define ll long long
#define inf 707406378
inline void in(int &x){
    static int ch;static bool flag;
    for(flag=0,ch=getchar(); ch<'0'||ch>'9'; ch=getchar())flag|= ch=='-';
    for(x=0; isdigit(ch); ch=getchar())x=(x<<1)+(x<<3)+ch-48;
    x=flag?-x:x;
}
inline void write(int x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+48);
}
int n,m;
int l,r,mid;
int sum,waste;
int all[1050],mouth[1050];
int cake[55],t[55];
inline bool dfs(int person,int part){
    if(!person)return 1;
    if(sum-waste<all[mid])return 0;//剪枝
    for(int i=part;i<=n;++i)
        if(t[i]>=mouth[person]){
            t[i]-=mouth[person];
            if(t[i]<mouth[1])waste+=t[i];
            if(mouth[person]==mouth[person-1]){//剪枝
                if(dfs(person-1,i))return 1;
            }
            else if(dfs(person-1,1))return 1;
            if(t[i]<mouth[1])waste-=t[i];
            t[i]+=mouth[person];
        }
    return 0;
}
inline int dy(){
    in(n);
    for(int i=1;i<=n;++i)
        in(cake[i]),sum+=cake[i];
    in(m);
    for(int i=1;i<=m;++i)in(mouth[i]);
    sort(mouth+1,mouth+1+m);
    while(sum<mouth[m])m--;//缩小二分范围
    for(int i=1;i<=m;++i)all[i]=all[i-1]+mouth[i];
    r=m;
    while(l<=r){
        waste=0;
        for(int i=1;i<=n;++i)t[i]=cake[i];
        mid=(r-l)/2+l;
        if(dfs(mid,1))l=mid+1;
        else r=mid-1; 
    }
    write(r);
}
int QAQ = dy();
int main(){;}
```

---

## 作者：文艺平衡树 (赞：13)

早就想出了二分答案，但是苦于不知道怎么验证解的可行性。看了下其他大佬的题解才知道要用dfs验证，嫌麻烦＆不甘心，于是我决定————随机化贪心。
```cpp
#include<stdio.h>
#include<stdlib.h>
#include<algorithm>
#include<queue>
using namespace std;
int c[51],p[1100],n,m,b[51];
priority_queue<int> tmp;
bool cmp(int x,int y){
	return x>y;
}
bool check(int N){
	int i,j,time=1000;
	while(time--){//既然拼RP，当然要多rand几遍 
		for(i=1;i<=n;i++)
			b[i]=c[i];//复制一份蛋糕副本 
		random_shuffle(b+1,b+n+1);//该函数的功能是把一段区间随机打乱 
		int flag;
		for(i=N;i>=1;i--){//这里对要满足的人从大到小枚举 
			flag=0;
			for(j=1;j<=n;j++){//n比较小，暴力枚举蛋糕 
				if(b[j]>=p[i]){
					flag=1;
					b[j]-=p[i];
					break;
				}
			}
			if(!flag) break;//如果找不到可以满足这个口的蛋糕，说明不行 
		}
		if(flag) return true;
	}
	return false;
}
int main(){
	int i,j,l,r,mid,ans=0;
	scanf("%d",&n);
	for(i=1;i<=n;i++)
		scanf("%d",&c[i]);
	scanf("%d",&m);
	for(i=1;i<=m;i++)
		scanf("%d",&p[i]);
	sort(p+1,p+m+1);//贪心，口小的人优先取 
	l=0;r=m;
	while(l<=r){//二分 
		mid=l+r>>1;
		if(mid>=0&&check(mid)){
			ans=mid;
			l=mid+1;
		}
		else r=mid-1;
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：SIXIANG32 (赞：9)

随机化算法，yyds！  
闲话少说，切入正题——  

---
由于小 SX 的搜索很差，他并没有想到什么好的剪枝方法，只想到了二分的框架和贪心的思路，所以他决定用**随机化算法**。  
首先贪心的想，我们可以把嘴巴大小 $mth$ 降序排序，这样的话，如果我们二分到了 $mid$ 张嘴，那么必然会全部用到 $mth_{1} \sim mth_{mid}$，证明~~过于弱智~~略。  
所以说现在的问题就是如何判定 $mid$ 个人能吃掉。  

---
我们可以从 $mth_{mid}$ 试到 $mth_{1}$，然后看看 $n$ 个蛋糕是否能吃饱。  
那么问题来了，人枚举的是固定的，但是每个人吃的蛋糕就很玄学。  
大部分人用的是搜索，但事实上随机化比搜索更简洁（bao）优美（li）。  
如果我们只是碰到了第一个可以吃的蛋糕就吃，那么没准就不是最优解了，这是显然的。  
那么我们就可以来一点点魔幻的操作了——```random_shuffle```，随机打乱一个数组。    
我们对于蛋糕多 ```random_shuffle``` 几遍，然后按照上面的规则来计算，算能不能让 $mid$ 个人吃掉，就能判定啦~  
```random_shuffle``` 保险一点可以搞 $3000$ 次，但对于这道题 $900$ 就够了。  

---
代码：
```cpp
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <algorithm>
#define MAXN 100000
#define QWQ cout << "QWQ" << endl;
using namespace std;
int n, m, cke[MAXN + 10], mth[MAXN + 10], qz[MAXN + 10], cp[MAXN + 10], sum = 0; 
bool flag = 0;
bool check(int mid) {
	for(int p = 1; p <= 1500; p++) {
		for(int i = 1; i <= n; i++) cp[i] = cke[i];
		random_shuffle(cp + 1, cp + n + 1);
		bool eye = 0;//表示这样的蛋糕排列行不行
		for(int i = mid; i >= 1; i--) {//枚举每个嘴
			bool flag = 0;
			for(int j = 1; j <= n; j++) {//枚举每个蛋糕
				if(cp[j] >= mth[i]) {//能吃，吃
					cp[j] -= mth[i];
					flag = 1; break;
				}
			}
			if(!flag) {//如果不行，标记
				eye = 1;
				break;
			} 
		}
		if(!eye) return 1;//如果都行，直接返回
	}
	return 0;//mid 人不行
}
int main() {
	cin >> n; for(int p = 1; p <= n; p++) cin >> cke[p];
	cin >> m; for(int p = 1; p <= m; p++) cin >> mth[p];  
	sort(mth + 1, mth + m + 1);
	int l = 1, r = m;
	while(l <= r) {
		int mid = (l + r) >> 1;
		if(check(mid)) l = mid + 1;
		else r = mid - 1;
	}
	cout << r << endl;
}
```

---

## 作者：lsm123 (赞：7)

给定m个人和n块蛋糕


首先是需要先sort一遍把人的嘴的大小拍一遍序，如果是我，的话，用有限的蛋糕，满足的更多的人，我会选择满足
嘴巴小的人
所以先sort一遍，把所有的人的嘴巴排序一遍，二分答案
WDC：二分的作用是先假定我可以满足x个人的嘴巴，每一次二分出一个答案后，都要对答案进行验证
而DFS、深搜的目的就是验证二分的区域对不对
根据二分答案的大，小来不断更新右边界，左边界直到找到一个确切的值

对于Dfs，
operate：

1.先要维护一下目前的蛋糕的数量总共的大小
2.在维护目前的人的嘴的总需求，
3.维护一下每块蛋糕被啃后的大小

对于operate1 
如果现在的蛋糕目前的数量不足以满足所有人的嘴的总数，直接return就ok，不可能满足了（这时候
flag是false，根据flag来调整可以满足的人的数量，那么调小区间就ok，）反之，如果flag是true的话，就说明 ，蛋糕数量
还不少啊，就可以调大了区间的大小，
（operate1这一步主要是用来调一下去区间的大小）

对于operate2
 
时刻记录一下还需要的蛋糕数量 （与operate1结合分析），每次满足一个人，就把他的嘴删去



对于operate3

如果这个蛋糕被好多个人啃了，只剩下了一丢丢，那么如果这一丢丢的蛋糕渣渣就连第一个人都不能满足的话，那么
他就失去了存在的意义（有他没他都一样），那么operate1中维护的蛋糕剩余总数就要减去现在的蛋糕的大小
.
.
.
.
（优化）
剪枝，去掉一些显然没有用的步骤，起到优化的目的
省时间，空间



对于假定的人数，（就像是用石子，沙子，水填满水瓶一样，先填体积大的）
dfs（x，j）
第x块蛋糕，第j个人，
对于x-1个人的嘴的大小一定是<=第x个人的嘴的大小



每一步都要判断一下当前的蛋糕数量和，人的需求的之间的比较



根据小于和等于进行剪枝，
如果是小于，就要从第一块蛋糕开始扫
for循环套起来（j  1---n）
dfs(x-1,j)


如果x-1的嘴的大小和x的嘴的大小是一样的话
因为第x个嘴已经是从第1个扫到了第j个这时候发现第j个可以满足x的嘴
那么就说明第x-1张嘴（和第x张嘴是一样的，）就没有必要从第一个开始扫了
从第j个开始（第j个有可能还能满足x-1的嘴，如果j这块蛋糕足够大的话）
.
.
.
.
进行一系列操作
.
.
.
.
.
.
.
.
回溯，怎么操作的怎么退回去（把蛋糕补回来，吃的蛋糕都吐出来）
这个深搜，是对假象的检验，也就是说，我的这个假象不一定是正确的，对于每一次假象，都要做好
假象是错误的回溯过程

深搜进行的每一步都是基于上一步是正确的这个条件下，从2号到5号，发现5号以后走不动了，那么就需要对从2--5的
操作进行复原，怎么来的怎么回去，在进行换一条路的搜索，直到结束，返回一定的值（flag）
他也会一直返回，进行完所有的搜索，（加入搜索成功了她会返回true然后，在返回，如果不成功，也会返回一定值
false然后在回溯，总之一定是会回溯的，只不过是时间不一样，从一条路换到另一条路是是在这一小步上直接回溯
搜到的最后，是全部从底部一步一步的向上回溯
）



```cpp
#include<iostream>
#include<cstdio>
#include<stdio.h>
#include<algorithm>
#include<cmath>/*2分，搜索*/
using namespace std;
int n,m;
int tot=0;//用tot这个数组来记录这个数组的蛋糕总数 
int size_cake[55],num_peo[2000];
int sum[2025];//sum这个数组用来记前缀和 
int l,r;bool flag; 
int chi;
int ck;
//剪枝过程更多的是在dfs的判断中， 
void dfs(int x,int y)
{
	if(x<1)
	//分蛋糕的过程就像是乌鸦用石子，沙子，水去填满一个瓶子，聪明的乌鸦一定是先去用大的体积的东西去填，然后是小的
	//一旦是确定（假定） 了可以喂饱的人，就是要求到这往前从后往前喂同学们，如果分到了一个人，这个人的序号比1还要小，那么就是说明喂完了所有人
//返回true就ok	 
	{
		flag=true;
		return;
	}
	for(int i=y;i<=n;i++)//是从第y块蛋糕开始分 
	{
		if(tot<chi)return;//如果我的 蛋糕的总数比人的需求总量还要少，那么不管我怎么去分蛋糕，我的结果都是false，这时候就没必要了直接返回
		if(flag)return;
		if(x<1)
		{
			flag=true;
			return;
		 } 
		 if(size_cake[i]>=num_peo[x])
		 {
			size_cake[i]-=num_peo[x];
			tot-=num_peo[x];
			chi-=num_peo[x];
			if(tot<num_peo[1]&&x!=1)return;
			if(size_cake[i]<num_peo[1])tot-=size_cake[i];
			if(num_peo[x]==num_peo[x-1])dfs(x-1,i);
			else dfs(x-1,1);	
			if(size_cake[i]<num_peo[1])tot+=size_cake[i];
			size_cake[i]+=num_peo[x];
			tot+=num_peo[x];
			chi+=num_peo[x]; 
		 }//因为这个过程不过只是自己假象的，所以就像是把皇后一样，一定要回溯，最后的时候蛋糕一点都会少，人们吃的蛋糕都会吐出来的 
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&size_cake[i]);
		tot+=size_cake[i];
	} 
	scanf("%d",&m);
	for(int j=1;j<=m;j++)scanf("%d",&num_peo[j]);
	sort(num_peo+1,num_peo+1+m);
	for(int i=1;i<=m;i++) sum[i]=sum[i-1]+num_peo[i];//前缀和是上一个人的前缀和+本人的嘴的大小 
    //先要进行第一个优化，如果给出一个前缀和，在二分答案之前首先要筛掉一些没有用的，就是如果前缀和大于tot，前缀和就要向前移动
    int oo=m;
	while(sum[oo]>tot)oo--;//通过前缀和饿进行优化 可以通过这一些剪枝来 减去没有必要的二分区间
	l=1,r=oo;
	while(l<=r)
	{
		int mid=(l+r)/2;
			flag=false;
		chi=sum[mid];
		dfs(mid,1);//mid是当前开始的人们所需要的蛋糕数目的总和，1是指从第一块蛋糕开始搜索
		//其实，蛋糕排序与否并不重要，都无所谓，不怕浪费时间去sort一行就自己写呗
		//dfs就是依据情况而定的check函数，不管怎么样，check函数都会返回一个值，根据这个值的情况进行下一步操作
		if(flag)//情况时可行的
		{
			l=mid+1;	
		 } 
		 else{
		 	r=mid-1;
		 }
			
	}
	cout<<l-1<<endl;
}
```
(https://cdn.luogu.com.cn/upload/image_hosting/gtk7qf75.png))



菜鸡冒泡

---

## 作者：letitdown (赞：5)

#### 前言
蒟弱本来是在~~亿万年前~~做二分答案专题[栅栏](https://www.luogu.com.cn/problem/P2329)的，由于数据水所以过掉了，后来发现有一个数据加强版，也就是[本题](https://www.luogu.com.cn/problem/P1528)，于是爆T了...过了有个五六个月回来填坑了...现在开O2是在最优解第一个（自豪ing
#### 题目描述
有 $n$ 块 大小分别为 $a_i$ 的蛋糕，分给 $m$ 个嘴大小分别为 $b_i$ 的人，但是蛋糕只能以整块的形式给人，求最多给多少人。
#### 思路
很明显，答案在排序之后具有单调性，所以可以二分能够分给多少人，但二分并没有一个明确的套路切蛋糕，所以需要进行深搜；

于是来考虑最优贪心策略：

1. 首先将所有蛋糕和嘴的大小排序，优先喂嘴小的人；

对应着这两行：
```
n=read();F(i,1,n)a[i]=read(),tot+=a[i];std::sort(a+1,a+n+1);
m=read();F(i,1,m)b[i]=read();std::sort(b+1,b+m+1);
```
2. 排完序后，考虑缩小二分范围，我们从小到大求得嘴大小的前缀和，如果到第 $i$ 个人的嘴大小总和 $pre_i$ 超过了上面求出的蛋糕大小总和 $tot$，或者 $b_i>a[n]$，那么到这里无论如何切都无法满足条件，二分的最大边界就是 $i-1$ 了。另外，如果蛋糕总和都比最小的嘴小，那么一个也不能满足。

对应着这三行：
```
if(tot<b[1]){pi(0);return 0;}
F(i,1,m){pre[i]=pre[i-1]+b[i];if(pre[i]>tot||b[i]>a[n]){cnt=i-1;break;}}
if(!cnt)cnt=m;
```
我们开始二分+深搜：

1. 在深搜过程中，枚举能够切下够这口嘴吃的蛋糕，切掉后蛋糕总大小要减去嘴的大小。如果这块蛋糕切剩下的不够最小嘴的，那么就相当于这块蛋糕没有用了，蛋糕总大小要再减去没有用的这部分。

也就是这样：
```
if(a[i]>=b[x]){
		a[i]-=b[x];tot-=b[x];
		if(a[i]<b[1])tot-=a[i];
}
```
2. 显然，当剩下几张嘴的总大小比剩下几块蛋糕的总大小还要大时，方案是不符合的。

也就是这句：
```
if(pre[x]>tot)return 0;
```
3. 当当前搜索到的这口嘴与下一个要搜索的嘴大小相同时，既然已经枚举到了第 $i$ 块蛋糕，说明第 $i$ 块蛋糕之前的蛋糕对于这个大小的嘴都是没有正确方案的，于是搜索下一口嘴时就可以直接从第 $i$ 块蛋糕枚举。

这句话的实现长这样：
```
if(b[x]==b[x-1])fl=check(x-1,i);else fl=check(x-1,1);
```

最后无论有没有正确方案都要记得回溯啊！
```
if(a[i]<b[1])tot+=a[i];
a[i]+=b[x];tot+=b[x];
```
到最后如果枚举完所有的蛋糕都没有正确方案，就可以直接 $return\ 0$ 了。

于是本题就可以愉快的结束了～
## CODE
```cpp
#include<cstring>
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
namespace EMT{
	#define pf printf
	#define F(i,a,b) for(register int i=a;i<=b;i++)
	#define D(i,a,b) for(register int i=a;i>=b;i--)
	inline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
	inline void pi(int x){pf("%d",x);}inline void pn(){pf("\n");}inline void ps(int a[],int size){F(i,1,size)pi(a[i]);pn();}
	int n,m,a[55],b[1100],ans,cnt,ws,tot,pre[1100];
	inline bool check(int x,int st){
		if(!x)return 1;
		if(pre[x]>tot)return 0;
		bool fl=0;
		F(i,st,n){
			if(a[i]>=b[x]){
				a[i]-=b[x];tot-=b[x];
				if(a[i]<b[1])tot-=a[i];
				if(b[x]==b[x-1])fl=check(x-1,i);else fl=check(x-1,1);
				if(a[i]<b[1])tot+=a[i];
				a[i]+=b[x];tot+=b[x];
				if(fl)return 1;
			}
		}return 0;
	}
	inline short main(){
		n=read();F(i,1,n)a[i]=read(),tot+=a[i];std::sort(a+1,a+n+1);
		m=read();F(i,1,m)b[i]=read();std::sort(b+1,b+m+1);;;;;;
		if(tot<b[1]){pi(0);return 0;}
		F(i,1,m){pre[i]=pre[i-1]+b[i];if(pre[i]>tot||b[i]>a[n]){cnt=i-1;break;}}
		if(!cnt)cnt=m;
		int l=1,r=cnt,ans=0;
		while(l<=r){
			int mid=(l+r)>>1;
			if(check(mid,1))l=mid+1,ans=mid;
			else r=mid-1;
		}
		pi(ans);
		return 0;
	}
}
signed main(){return EMT::main();}
```


---

## 作者：Unordered_OIer (赞：3)

# P1528 题解
贪心是肯定的，二分答案+$dfs$就不是那么多人想到了，估计这就是为什么这道题蓝的原因吧
## 题意
切蛋糕满足最多的人
## 解答
贪心思想很容易想到，~~不讲了~~。但有一个比较麻烦的问题就是check。

我们先假设check的函数已经写好了，那么我们怎么解出最优答案呢？想必各位已经想到了，$\large{二分答案}$。

那么我们先打一遍板子：
```cpp
	void binary_search(){
		int leftbound=0,rightbound=n,ans=0;
		while(leftbound<=rightbound){
			int mid=leftbound+(rightbound-leftbound)/2;
			if(valid_next_status(mid)) leftbound=mid+1,ans=mid;
			else rightbound=mid-1;
		}
	}
```

好的那么我们来~~硬淦~~写check函数，不难看出一定是$dfs$判断的吧。（你自己模拟几下找找感觉不就行了

好的，一个$dfs$写好了，然后快乐地交上去，发现$\huge{\text{TLE}}$
![](https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2986019800,1056897466&fm=26&gp=0.jpg)

然后避免不了的优化来了。。。  
1. 排序是肯定的
2. 前缀和是肯定的
3. **我们要缩小二分答案的范围**  
如果所有的蛋糕总重量加起来都没有所有的人能吃，那么我们不用苦苦枚举所有的情况了，直接缩小范围，代码就是:
```cpp
while(prefix[n]>tot)--n;
```
4. $dfs$剪枝显然  
我们设想：如果第$i$个人和$i-1$个人的嘴巴一样大，那么不能满足$i-1$当然也不能满足$i$，这样就可以剪掉一大部分计算，以至于$\huge{\color{lightgreen}AC}$


总代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace cut_cake{
	const int N=2009;
	int m,n,a[N],b[N],c[N],prefix[N],rest,tot;
	bool judge_valid(int d,int last){
		if(d<=0) return 1;
		if(rest+prefix[d]>tot) return 0;
		for(int i=last;i<=m;++i)
		    if(c[i]>=b[d]){
		    	c[i]-=b[d];
		    	if(c[i]<b[1]) rest+=c[i];
		    	if(judge_valid(d-1,b[d]==b[d-1]?i:1)) return 1;
		    	if(c[i]<b[1]) rest-=c[i];
		    	c[i]+=b[d];
			}
		return 0;
	}
	bool valid_next_status(int mid){
		for(int i=1;i<=n;++i) c[i]=a[i];
		rest=0;
		return judge_valid(mid,1);
	}
	void binary_search(){
		int leftbound=0,rightbound=n,ans=0;
		while(leftbound<=rightbound){
			int mid=leftbound+(rightbound-leftbound)/2;
			if(valid_next_status(mid)) leftbound=mid+1,ans=mid;
			else rightbound=mid-1;
		}
	}
	void init_all(){
		cin>>m;
		for(int i=1;i<=m;i++)cin>>a[i],tot+=a[i];
		cin>>n;
		for(int i=1;i<=n;i++)cin>>b[i];
	}
	void sort_ab(){
		sort(a+1,a+1+m);
		sort(b+1,b+1+n);
	}
	void solve_first(){
		for(int i=1;i<=n;++i)prefix[i]=prefix[i-1]+b[i];
		while(prefix[n]>tot)--n;
	}
	void solve_second(){
		binary_search();
		cout<<ans<<endl;
	}
	int _main(){
		init_all();
		sort_ab();
		solve_first();
		solve_second();
		return 0;
	}
}
int main(){cut_cake::_main();}
```

---

## 作者：gryql (赞：1)

鉴于打了太多注释，这里这简单说一下做法，如果单纯DFS的话样例或需要用5s，一部分优化可能过50%到70%，又容易推得贪心，DP一定不是正确的做法（反例好找的SO EASY）。AC的做法可以是二分人数，不断地DFS，然后把所有能想到的剪枝，什么可行性，最优性简直都放上，卡卡就能过了。因为代码复杂度太高，时间复杂度也不好算了，反正东卡西卡过了。


复制代码





```cpp
type sz=array[0..2000] of longint;
var a,b,sum:sz;
    n,i,x,y,st,lst,mid,m,summ,ans:longint;
    flag:boolean;
procedure qsort(r,l:longint;var a:sz);
var
     i,j,k:longint;
begin
     i:=r;
     j:=l;
     k:=a[(i+j) shr 1];
     repeat
          while a[i]<k do inc(i);
          while a[j]>k do dec(j);
          if i<=j then begin
              a[0]:=a[i];
              a[i]:=a[j];
              a[j]:=a[0];
              inc(i);
              dec(j);
          end;
     until i>j;
     if i<l then qsort(i,l,a);
     if r<j then qsort(r,j,a);
end;
//通用快排，由小到大的顺序
procedure dfs(beg,k:longint);
//b数组是排好序的，beg表示当前是从第几个蛋糕开始的
var
     i:longint;
begin
     if k=0 then 
        begin
            flag:=true;
            exit;
        end;
     if summ+sum[mid]>ans then exit;
     //优化，如果当前合法的蛋糕没有的值加上此刻处理人的蛋糕权值要比总权值要大，则退出。
     for i:=beg to n do 
        if a[i]>=b[k] then 
            begin
                a[i]:=a[i]-b[k];
                if a[i]<b[1] then inc(summ,a[i]);
                //summ表示没有用的蛋糕数量，如果第一个人都无法满足那么蛋糕a[i]等于没用
                if b[k]=b[k-1] then dfs(i,k-1) else dfs(st,k-1);
                //如果b[k]=b[k+1],那么只有i到n这些蛋糕可取(想想这是为什么)
                if a[i]<b[1] then dec(summ,a[i]);
                a[i]:=a[i]+b[k];
                //两行回溯
                if flag then exit;
            end;
end;
begin
     readln(n);
     for i:=1 to n do readln(a[i]);
     readln(m);
     for i:=1 to m do readln(b[i]);
     qsort(1,n,a);
     qsort(1,m,b);
     st:=1;
     while (a[st]<b[1]) and (st<n) do inc(st);    
     //把没用的蛋糕去掉，处理后sum是能用的蛋糕
     for i:=st to n do inc(ans,a[i]);
     lst:=m;
     while (b[lst]>a[n]) and (lst>1) do dec(lst); 
     //把不能满足的人去掉，现在只需要满足ss个人就行了
     for lst:=1 to lst+1 do 
        begin
            sum[lst]:=sum[lst-1]+b[lst];
            //sum[i]表示到i蛋糕时所有蛋糕的总权值，所有蛋糕加起来都无法满足可以的人那么退出
            if sum[lst]>ans then break;
        end;
     dec(lst);//从上层循环的影像中退出来
     x:=0;
     y:=lst;
     while x<y do 
     //需要满足的人数小于所有的人数
        begin
            mid:=(x+y+1) shr 1;
            //二分查找的是人，位运算:shr 1==>div 2;
            flag:=false;
            summ:=0;
            dfs(st,mid);
            if flag then x:=mid else y:=mid-1;
        end;
     writeln(x);
end.
```

---

## 作者：Daisy (赞：1)

将嘴排序和蛋糕排序

从小到大看蛋糕能装的最多嘴的数字(在保证最的数量最多同时也保证嘴的大小总和最大)

二分答案注意上下界





```cpp
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<iostream>
#define maxn 2005
using namespace std;
int mid;
int n,m;
int mouth[maxn],cake[maxn];
int tot=0,space;
int sum[maxn],fcake[maxn];
int cmp(const void *a, const void *b)
{
    return(*(int *)a-*(int *)b);
}
bool dfs(int deep,int pos)
{
    if(deep<=0)return 1;
    if(tot-space<sum[mid])return 0;//¼ôÖ¦
    //dfsÊ±¼ÇÂ¼µ±Ç°ÀË·ÑµÄµ°¸âºÍ
    //×Üµ°¸âÁ¿-µ±Ç°ÀË·ÑµÄµ°¸âºÍ<µ±Ç°¶þ·ÖµÄÒªÂú×ãµÄ×ì´óÐ¡ºÍ
    //¾ÍËµÃ÷ÎÞ·¨Âú×ã£¬ÔòÍË³ö¡£
    for(int i=pos;i<=n;++i)
    {
        if(fcake[i]>=mouth[deep])
        {
            fcake[i]-=mouth[deep];
            if(fcake[i]<mouth[1]) space+=fcake[i];
            if(mouth[deep]==mouth[deep-1]) //¼ôÖ¦
            //dfsÊ±Èôµ±Ç°×ì°Í´óÐ¡ÓëÏÂÒ»¸öÏàÍ¬£¬ÔòÏÂÒ»¸öÎÞÐè´Óµ°¸â1¿ªÊ¼Ã¶¾Ù
            //Ö±½Ó´Óµ±Ç°×ì°ÍÃ¶¾ÙµÄµ°¸âi¿ªÊ¼
               {
                  if(dfs(deep-1,i)) return 1;
               }
               else if(dfs(deep-1,1)) return 1;
               if(fcake[i]<mouth[1]) space-=fcake[i];
               fcake[i]+=mouth[deep];
        }
    }
    return 0;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;++i)
    {
        scanf("%d",&cake[i]);
        tot+=cake[i];    
    }
    cin>>m;
    for(int i=1;i<=m;++i)
    {
        scanf("%d",&mouth[i]);
    }
     qsort(cake+1,n,sizeof(int),cmp);
    qsort(mouth+1,m,sizeof(int),cmp);
    sum[0]=0;
    for(int i=1;i<=m;++i)sum[i]=sum[i-1]+mouth[i];
    while(sum[m]>tot)--m;//¼ôÖ¦
    //ÒÔ×îÐ¡µÄ×ìÀÛ¼Ó£¬Óëµ°¸â×ÜºÍ±È½Ï£¬ÕÒµ½×î¶àÄÜÂú×ãµÄ×ìÊý£¬¾ÍÊÇ¶þ·ÖÉÏ±ß½ç
    int l=0,r=m;
    while(l<=r)
    {
        mid=l+r>>1;    
        for(int i=1;i<=n;++i)fcake[i]=cake[i];
        space=0;
        if(dfs(mid,1))l=mid+1;
        else r=mid-1;        
    }
    cout<<l-1;
    puts("");
    return 0;
}
```

---


# 牛宫

## 题目描述

AP 神牛准备给自己盖一座很华丽的矩形宫殿。于是，他看中了一块 $N \times M$ 的矩形空地。

空地中每个格子都有自己的海拔高度 $a_{i,j}$。AP 想让他的宫殿的平均海拔在海平面之上（假设海平面的高度是 0，平均数都会算吧？）。而且，AP 希望他的宫殿尽量大，能够容纳更多的人来膜拜他。请问 AP 的宫殿最后会有多大？


## 说明/提示

对于 $50\%$ 的数据，$N,M \le 100$；

对于 $100 \%$ 的数据，$1 \le N,M \le 200$，$-2\times10^9 \le a_{i,j} \le 16315$。


## 样例 #1

### 输入

```
3 2
4 0
-10 8
-2 -2
```

### 输出

```
4
```

# 题解

## 作者：ChenHacker (赞：53)

### 这是一名蒟蒻在考场上自己想出来的题解！和下面的大佬的思路都不一样的题解！

我的解法 O(n * n * n * logn),下面那些单调栈是真的牛逼啊。

其实是我把这一题想难了，看下面的O(n * n * n * logn)的解法思路比我简单多了，我这里只是提供一个 **_与众不同_** 的解法。

我这个算法是基于暴力优化而来的

首先对于二维的子矩阵问题（比如[最大子矩阵](http://noi.openjudge.cn/ch0206/1768/)），一个常规的思路就是枚举左右区间，然后按照一维的算法来搞

#### 所以我这里只要讲一维的解法就好了（斜眼笑）

#### 谈谈一维的n^2暴力算法

先枚举左端点，然后枚举右端点，然后前缀和O(1)算出sum[l, r]的值如果大于零就跟新ans就好了

然后我这时想到一个馊主意：
>对于每一个l，必然有k个r使它可以更新ans，是不是把前缀和sort一下就可以二分了？

然后我很快否定了这个想法，因为就算找到了k个r，我还是得一个一个去更新答案啊。

#### 于是我又想到了前缀最大值，哈哈哈然后这一题就被我A掉了

### 至于代码，

我有一个码风优美的代码，可惜这里位置太少我贴不下，如果您实在需要，可以email me to  2041026133@qq.com来购买我的代码，目前定价1000000000000000000 rmb, 有需要的快来找我

当然如果你没有那么多钱，您可以先打个暴力拿到60分然后通过代码公开计划在[这里](https://www.luogu.org/record/22383893)查看我的代码

我绝对不会告诉你[我的博客](https://ch66.cf/2019/08/08/题解-P1565-【牛宫】/)上面也有代码的

### 蒟蒻写题解不易，顺手留赞，感激不尽！

---

## 作者：Captain_Paul (赞：15)

这题真的神奇

$n^4$暴力开着O2嗖嗖飞起也是没谁了


------------


正解是$n^3$或者$n^3logn$

因为我太菜了所以只会后者

其实这种做法就是把暴力的一层枚举转化为了二分

首先做一个竖着的前缀和（$sum[i][j]=sum[i-1][j]+a[i][j]$）

然后枚举$i$和$j$作为矩阵的上下两个边界

确定了上下边界，再用横着的前缀和算出每一列及其之前的总和

然后二分一个长度len，算一下矩形面积更新答案就好了

问题就在于如何check这个二分的答案

从len到m枚举，res取其中$t[i-len]$的最小值($t$为前缀和)

因为要求矩阵总和$>0$，所以当存在一个$i$满足$t[i]>res$时，这个答案就是可行的

如果这个最小值不是$t[i-len]$，那么还存在更优的解

n^3做法单调栈dp太神了orzzzzz

```
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
#define reg register
using namespace std;
typedef long long ll;
const int N=205;
int n,m,ans;
ll a[N][N],s[N][N],t[N];
inline ll read()
{
	ll x=0; bool w=1; 
	char c=getchar();
	while (!isdigit(c)&&c!='-') c=getchar();
	if (c=='-') c=getchar(),w=0;
	while (isdigit(c))
	{
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar();
	}
	return w?x:-x;
}
inline bool check(int x)
{
	ll res=0;
	for (reg int i=x;i<=m;i++)
	{
		res=min(res,t[i-x]);
		if (t[i]>res) return 1;
	}
	return 0;
}
inline int getlen()
{
	int l=1,r=m,len=0;
	while (l<=r)
	{
		int mid=(l+r)>>1;
		if (check(mid)) len=mid,l=mid+1;
		else r=mid-1;
	}
	return len;
}
int main()
{
	n=read(),m=read();
	for (reg int i=1;i<=n;i++)
	  for (reg int j=1;j<=m;j++)
	    s[i][j]=s[i-1][j]+(a[i][j]=read());
	for (reg int i=1;i<=n;i++)
	  for (reg int j=i;j<=n;j++)
	  {
	  	  for (reg int k=1;k<=m;k++) t[k]=t[k-1]+s[j][k]-s[i-1][k];
	  	  ans=max(ans,(j-i+1)*getlen());
	  }
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：dinglinxi0409 (赞：15)

直接暴力枚举就可以了。
```cpp
#include <bits/stdc++.h>
using namespace std;
long long a[201][201],sum[201][201];
int main()
{
	long long ans=0,z=0;
	int m,n,i,j,x,y;
	cin>>n>>m;
	for (i=1;i<=n;i++) for (j=1;j<=m;j++) {cin>>a[i][j]; sum[i][j]=sum[i][j-1]+sum[i-1][j]-sum[i-1][j-1]+a[i][j];} //输入和预处理
	for (i=1;i<=n;i++) for (j=1;j<=m;j++) for (x=i;x<=n;x++) for (y=j;y<=m;y++) //暴力枚举
		if (!(sum[x][y]+sum[i-1][j-1]-sum[x][j-1]-sum[i-1][y]<=0)) //如果平均海拔在海平面以上
			if ((z=(long long)(x-i+1)*(y-j+1))>=ans) ans=z; //如果面积比原来的最大面积大，那么就更新最大面积
	cout<<ans<<endl; //输出最大面积
	return 0;
}
```


---

## 作者：JOHNKRAM (赞：10)

先枚举上边界，再枚举下边界，每次处理一个下边界的过程中，利用上一个下边界的计算结果快速求出每一列的海拔和，按海拔和升序排列，再求出最大宽，乘以长，更新结果即可。


---

## 作者：zhyh (赞：8)

感谢b2097152的思路(%)，去掉一个log的复杂度，变成了O(N^3)

首先O(N^2)枚举矩形横边，对于纵边，用前缀和处理出相应的N个和，然后对该数列再做一次前缀和——此时答案就是这个新数列{Sn}中满足 Si<Sj 的(j-i)最大值再乘上横边枚举的边长，更新答案即可。

对于{Sn}，易知若存在 Sn<=Sm 且 n<m，则作为上述的Si，Sn必定比Sm更优；同样地，作为上述的Sj，Sm更优。因此将{Sn}从前建立单调减序列l，从后反向建立单调增序列r。枚举ri，依次找出使j最小（满足序号和数值都小于当前ri）的lj，更新答案，复杂度O(N)。

代码如下：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
typedef long long LL;
LL N,M,a[205][205],sum[205][205],ans;

LL solve(int u,int v){
    LL s[205],l[205],r[205],tmp=0;
    s[0]=0,l[0]=r[0]=1,l[1]=0,r[1]=N;//考虑前缀和，以0为l[1]
    for(int i=1;i<=N;i++)s[i]=s[i-1]+sum[i][v]-sum[i][u-1];
    for(int i=1;i<N;i++) if(s[i]<s[l[l[0]]])l[++l[0]]=i;
    for(int i=N-1;i>0;i--)if(s[i]>s[r[r[0]]])r[++r[0]]=i;//构造
    for(int i=1;i<=r[0];i++){
        while(l[0]>1 && ( l[l[0]]>=r[i] || s[l[l[0]]]<s[r[i]] ))l[0]-=1;//查找最小的l
        if(s[l[l[0]]]>=s[r[i]] && s[l[l[0]+1]]<s[r[i]])l[0]+=1;//细节处理
        if(s[l[l[0]]]<s[r[i]])tmp=max(tmp,r[i]-l[l[0]]);
    }
    return tmp;
}
int main()
{
    scanf("%lld%lld",&N,&M);
    for(int i=1;i<=N;i++)
    for(int j=1;j<=M;j++){
        scanf("%lld",&a[i][j]);
        sum[i][j]=sum[i][j-1]+a[i][j];
    }
    for(int k=0;k<M;k++)
    for(int i=1;i+k<=M;i++)//枚举横边
    ans=max(ans,solve(i,i+k)*(k+1));//更新答案
    printf("%lld\n",ans);
    return 0;
}
```
此外，若是二分答案，则是O(N^3logN)，仍能满足数据；或者还可以用排序做到与二分一样的复杂度2333。具体依然是在{Sn}上，附带相应的坐标，对其升序排一遍，就得到了一个坐标序列p。然后只要在p序列上找到满足 n<m 的(pm-pn)的最大值即可。

---

## 作者：kczno1 (赞：7)

这题有O(n^3)做法

见http://kczno1.blog.uoj.ac/blog/2787


---

## 作者：喝水 (赞：4)

[题目传送门](/problem/P1565)

无需单调栈的 $\Theta(n^3)$ 做法。

首先问题通过枚举行转化为序列上选择尽可能长的区间，使得区间和大于 $0$。

我们来 $\Theta(n)$ 解决这个问题：

从左向右枚举右端点。记当前枚举到 $i$，且到此答案为 $p$。显然，要使答案更大，必须存在符合题意的、以 $i$ 为右端点的、长度大于 $p$ 的区间才行，否则我们可以跳过 $i$。这个判定问题等价于命题 $sum_i-(\min_{j=0}^{i-p} sum_j)\geq0$（$sum$ 为前缀和），这可以通过预处理 $\Theta(1)$ 求解。若该命题为真，我们令 $p\to p+1$，并重复这个过程，否则跳出 $i$ 的枚举。

因为 $p$ 单调，复杂度 $\Theta(n)$，总复杂度 $\Theta(n^3)$。

---

## 作者：licone (赞：4)

这题n,m<=200，所以一定不能用四重循环，但是三重循环还是比较快的。

（楼下的可能是数据加强之前发的题解。）


单调栈+动态规划+前缀和+二分~

（所以为什么是普及+/提高啊！）


我们枚举长方形的宽的左右坐标，然后对于每个位置，求出它的最长长，乘起来更新面积。


用前缀和数组记录一下，可以很方便的的更新面积。


（思路来自<http://blog.csdn.net/pzler/article/details/40116845> ，orz jjs98）





```cpp
#include<cstdio>
#include<iostream>
using namespace std;
#define ll long long
ll n,m,x,a[201][201],f[201],sta[201],len,ans;
ll findd(ll u)
{
    ll l=1,r=len,tot=-1;
    while(l<=r)
    {
        ll mid=(l+r)>>1;
        if(sta[mid]<u)
        {
            r=mid-1;tot=mid;
        }
        else l=mid+1;
    }
    return tot;
}
int main()
{
    scanf("%lld%lld",&n,&m);
    for(ll i=1;i<=n;i++)
      for(ll j=1;j<=m;j++)
      {
          scanf("%lld",&x);
          a[i][j]=a[i][j-1]+x;
      }
    for(ll i=1;i<=m;i++)
      for(ll j=1;j<=m;j++)
      {
          ll area=0;sta[0]=1e10;len=0;
          for(ll k=1;k<=n;k++)
          {
              area+=a[k][j]-a[k][i-1];
              if(area>0) ans=max(ans,k*(j-i+1));
              else
              {
                  int z=findd(area);
                  if(z!=-1) ans=max(ans,(j-i+1)*(k-f[z]));
            }
            if(sta[len]>area) sta[++len]=area,f[len]=k;
        }
      }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：brsjdys (赞：3)

#  [我的博客](https://www.cnblogs.com/drurry/p/7764553.html)

题意很简单，求最大子矩阵和，且该矩阵和大于等于0。

输入时顺便做前缀和，然后是用三重循环枚举矩阵的长和宽，分别是宽的起始到宽的结束和长。

当当前矩阵与上一个矩阵相加大于0时，可直接得到一个新的矩阵并更新答案；

所以这道题最终要解决的是如何处理当前矩阵与上一个矩阵相加小于0的情况。

易知每个矩阵都可被纵向分割为两个小矩阵，那么就可以用二分查找，看当前矩阵和上一个矩阵组成的新矩阵是否能被分割成这样两个矩阵：一个矩阵和小于0，另一个大于0；

如果可以找到，那么更新答案；

因为宽始终不变，所以还需记录下小于0的那个矩阵的长，再用新矩阵的长减去即可；

最后要注意每次记录下矩阵和小于0的值和该矩阵的长，用单调栈记录。
```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
using namespace std;
long long n,m,ans;
long long top,sta[222222];
long long s[222][222],area;
long long a[222][222],kn[222222],f2[222][222];
long long ef(long long x)//二分查找出当前矩阵所包含的最小的小于0的矩阵
{
     long long l=1,r=top,mid,ans1=-1;
     while(l<=r)
     {
        mid=(l+r)/2;
        if(sta[mid]<x)
        {
            r=mid-1;ans1=mid;
        }
        else l=mid+1;
     }
     return ans1;
}
int main()
{
   scanf("%lld%lld",&n,&m);
   for(long long i=1;i<=n;i++)
   for(long long j=1;j<=m;j++)
   {
      scanf("%lld",&a[i][j]);
      s[i][j]=a[i][j]+s[i][j-1];//前缀和
   }
   for(long long i=1;i<=m;i++)//枚举起始宽
   for(long long j=i;j<=m;j++)//枚举结束宽
   {
      area=0;
      sta[0]=0,top=0;
      for(long long k=1;k<=n;k++)//枚举长
      {
         area+=s[k][j]-s[k][i-1];
         if(area>0)  ans=max(ans,(j-i+1)*k);
         else
         {
             long long num=ef(area);//矩阵和
             if(num!=-1)  ans=max(ans,(j-i+1)*(k-kn[num]));
             //找到了新矩阵所包含的大于0的矩阵才更新
             if(area<sta[top]) 
             {
                sta[++top]=area;//记录area<0的值
                kn[top]=k;//同时记录该矩阵的长
             }
         }
      }
   }
   cout<<ans<<endl;
   return 0;
}
```

---

## 作者：咯咯咯 (赞：2)

玄学算法(n•n/2•m•logm)

1、枚举连续行，压缩为一维 ；

2、在一维区间中求出b数组,且记下每个b值的原始位置；

3、将b归并排（注意需要保留原始位置的信息）

//归并比快拍稳定多了，用快排会慢

4、O(n) 枚举右端点，同时更新最小左端点，更新答案


```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define For(i,a,b) for(register int i=a;i<=b;i++)
using namespace std;
struct DATA
{
	long long val;
	int num;
	bool operator <(const DATA &x) const
	{
		if (val!=x.val)return val<x.val ;
		return num<x.num ;
	}
} b[210];
long long s[210][210];
int n,m;
int a[210][210];
DATA c[210];
void mgsort(int l,int r)
{
	int mid=(l+r)>>1;
	if (l!=r) mgsort(l,mid),mgsort(mid+1,r);
	int i=l,j=mid+1,t=l;
	while (i<=mid||j<=r)
	{
		if (i<=mid&&(b[i]<b[j]||j>r))
		{
			c[t++]=b[i++];
		}
		else
		{
			c[t++]=b[j++];
		}
	}
	For(i,l,r) b[i]=c[i];
}
int main()
{
//	freopen("long.in","r",stdin);
//	freopen("long.out","w",stdout);
	scanf("%d%d",&n,&m);
	For(i,1,n)
	{
		For(j,1,m)
		{
			scanf("%d",&a[i][j]);
			s[i][j]=s[i-1][j]+a[i][j];
		}
	}
	int ans=0;
	For(i,1,n)
	{
		For(j,i,n)
		{
			b[0]=(DATA){0,0};
			For(k,1,m) b[k]=(DATA){b[k-1].val+s[j][k]-s[i-1][k],k};			
			mgsort(0,m);
			int l=0x3f3f3f3f;			
			For(k,0,m)
			{
				l=min(l,b[k].num);
				if (l!=b[k].num) ans=max(ans,(j-i+1)*(b[k].num-l));
			}
		}
	}
	cout<<ans<<endl;
//	fclose(stdin);fclose(stdout);
	return 0;
}
```

---

## 作者：夏色祭 (赞：1)

#P党真是越来越少了

#我来补一发

##玄学的方法，时间O(n^3logn)，似乎还挺快的。。。

枚举起始行和终点行，把从起始行到终点行每一列上的数看成一个数（用前缀和就行了），然后在用一个数组记录前缀和，假设我们用了sum[i]保存前i个之和，下面要用到**↓**。

接下来**二分**。。。

**二分**最多可以占领的列数，这是最骚的。。。

对于判断当前的mid能否成功，这需要O(n)的时间来wei来wei去wei

对于i>=mid的sum[i]，判断当前sum[i]-min{sum[0],sum[1],sum[2]...sum[i-mid]}（用个变量边做边存就行了）是否>0，平局海拔要>海平面的话，即面积总和>0

#难度假的吧，真的是个妖怪

#注意：数据十分wei，需要各种long long

丑陋的代码，非丑陋之人不得欣（fu）赏（zhi）：

```cpp
var
  a:array[0..201,0..201]of longint;
  sum:array[0..201,0..201]of int64;
  b:array[0..201]of int64;//不是long long要炸（wei）的
  n,m,i,j,k,anss,l,r,mid,ans,min:longint;
function check(x:longint):boolean;
var
  i:longint;
  min:int64;//注意这也要开long long
begin
  min:=0;
  for i:=x to m do
    begin
      if min>b[i-x] then min:=b[i-x];
      if (b[i]-min>0) then exit(true);
    end;
  exit(false);
end;//判断当前mid能都成立
begin
  readln(n,m);
  for i:=1 to n do 
    begin
      for j:=1 to m do 
        begin
          read(a[i,j]);
          sum[i,j]:=sum[i-1,j]+a[i,j];
        end;
      readln;
    end;
  for i:=1 to n do 
    for j:=i to n do
      begin
        for k:=1 to m do b[k]:=b[k-1]+(sum[j,k]-sum[i-1,k]);//前缀和
        anss:=0;
        l:=1;
        r:=m;
        while l<=r do 
          begin
            mid:=(l+r) >> 1;
            if check(mid) then begin l:=mid+1;anss:=mid; end
              else r:=mid-1;
          end;//二分
        if anss*(j-i+1)>ans then ans:=anss*(j-i+1);//找个max
      end;
  writeln(ans);
end.
```

---

